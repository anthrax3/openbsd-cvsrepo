head	1.39;
access;
symbols
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.39.0.28
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.39.0.24
	OPENBSD_5_9_BASE:1.39
	OPENBSD_5_8:1.39.0.26
	OPENBSD_5_8_BASE:1.39
	OPENBSD_5_7:1.39.0.18
	OPENBSD_5_7_BASE:1.39
	OPENBSD_5_6:1.39.0.22
	OPENBSD_5_6_BASE:1.39
	OPENBSD_5_5:1.39.0.20
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.39.0.16
	OPENBSD_5_4_BASE:1.39
	OPENBSD_5_3:1.39.0.14
	OPENBSD_5_3_BASE:1.39
	OPENBSD_5_2:1.39.0.12
	OPENBSD_5_2_BASE:1.39
	OPENBSD_5_1_BASE:1.39
	OPENBSD_5_1:1.39.0.10
	OPENBSD_5_0:1.39.0.8
	OPENBSD_5_0_BASE:1.39
	OPENBSD_4_9:1.39.0.6
	OPENBSD_4_9_BASE:1.39
	OPENBSD_4_8:1.39.0.4
	OPENBSD_4_8_BASE:1.39
	OPENBSD_4_7:1.39.0.2
	OPENBSD_4_7_BASE:1.39
	OPENBSD_4_6:1.33.0.6
	OPENBSD_4_6_BASE:1.33
	OPENBSD_4_5:1.33.0.2
	OPENBSD_4_5_BASE:1.33
	OPENBSD_4_4:1.31.0.2
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.29.0.2
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.26.0.2
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.23.0.2
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.22.0.10
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.22.0.8
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.22.0.6
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.22.0.4
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.22.0.2
	OPENBSD_3_6_BASE:1.22
	SMP_SYNC_A:1.21
	SMP_SYNC_B:1.21
	OPENBSD_3_5:1.20.0.2
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	UBC_SYNC_A:1.17
	OPENBSD_3_3:1.16.0.6
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.4
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	UBC_SYNC_B:1.16
	UBC:1.12.0.2
	UBC_BASE:1.12
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.14
	OPENBSD_2_8:1.7.0.12
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.10
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.8
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.6
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.4
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.39
date	2009.12.15.15.53.48;	author beck;	state Exp;
branches;
next	1.38;

1.38
date	2009.09.02.18.20.54;	author thib;	state Exp;
branches;
next	1.37;

1.37
date	2009.08.27.23.26.56;	author thib;	state Exp;
branches;
next	1.36;

1.36
date	2009.08.26.12.08.10;	author thib;	state Exp;
branches;
next	1.35;

1.35
date	2009.08.20.15.04.24;	author thib;	state Exp;
branches;
next	1.34;

1.34
date	2009.08.10.10.59.12;	author thib;	state Exp;
branches;
next	1.33;

1.33
date	2009.01.24.23.30.42;	author thib;	state Exp;
branches;
next	1.32;

1.32
date	2009.01.19.23.40.36;	author thib;	state Exp;
branches;
next	1.31;

1.31
date	2008.06.14.19.33.58;	author beck;	state Exp;
branches;
next	1.30;

1.30
date	2008.06.10.22.59.09;	author thib;	state Exp;
branches;
next	1.29;

1.29
date	2007.12.13.22.32.55;	author thib;	state Exp;
branches;
next	1.28;

1.28
date	2007.10.28.14.03.47;	author thib;	state Exp;
branches;
next	1.27;

1.27
date	2007.09.20.12.54.31;	author thib;	state Exp;
branches;
next	1.26;

1.26
date	2007.06.21.22.59.49;	author thib;	state Exp;
branches;
next	1.25;

1.25
date	2007.04.12.13.24.39;	author thib;	state Exp;
branches;
next	1.24;

1.24
date	2007.03.18.15.05.33;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2007.01.16.17.52.18;	author thib;	state Exp;
branches;
next	1.22;

1.22
date	2004.08.03.17.11.48;	author marius;	state Exp;
branches;
next	1.21;

1.21
date	2004.04.26.18.57.36;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2004.03.02.05.46.00;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2003.09.23.16.51.13;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.02.23.28.20;	author millert;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2003.05.13.02.09.47;	author jason;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.14.01.27.13;	author millert;	state Exp;
branches
	1.16.6.1;
next	1.15;

1.15
date	2002.02.23.23.47.13;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.22.20.19.14;	author csapuntz;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.19.08.58.06;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.27.05.27.12;	author art;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2001.11.15.23.15.15;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.25.03.28.14;	author csapuntz;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.25.02.15.48;	author csapuntz;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.23.02.14.27;	author csapuntz;	state Exp;
branches;
next	1.7;

1.7
date	98.08.06.19.35.02;	author csapuntz;	state Exp;
branches
	1.7.8.1;
next	1.6;

1.6
date	97.11.06.05.59.06;	author csapuntz;	state Exp;
branches;
next	1.5;

1.5
date	97.10.06.20.20.55;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.10.06.15.23.46;	author csapuntz;	state Exp;
branches;
next	1.3;

1.3
date	96.03.31.13.16.16;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.02.29.09.25.04;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.23;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.23;	author deraadt;	state Exp;
branches;
next	;

1.7.8.1
date	2001.07.04.10.55.53;	author niklas;	state Exp;
branches;
next	1.7.8.2;

1.7.8.2
date	2001.12.05.01.02.40;	author niklas;	state Exp;
branches;
next	1.7.8.3;

1.7.8.3
date	2002.03.06.02.17.13;	author niklas;	state Exp;
branches;
next	1.7.8.4;

1.7.8.4
date	2002.03.28.15.02.48;	author niklas;	state Exp;
branches;
next	1.7.8.5;

1.7.8.5
date	2003.05.16.00.29.45;	author niklas;	state Exp;
branches;
next	1.7.8.6;

1.7.8.6
date	2003.06.07.11.07.44;	author ho;	state Exp;
branches;
next	1.7.8.7;

1.7.8.7
date	2004.02.19.10.57.27;	author niklas;	state Exp;
branches;
next	1.7.8.8;

1.7.8.8
date	2004.06.05.23.13.08;	author niklas;	state Exp;
branches;
next	;

1.12.2.1
date	2002.02.02.03.28.26;	author art;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2002.06.11.03.32.04;	author art;	state Exp;
branches;
next	1.12.2.3;

1.12.2.3
date	2002.10.29.18.31.52;	author art;	state Exp;
branches;
next	1.12.2.4;

1.12.2.4
date	2002.11.04.18.02.32;	author art;	state Exp;
branches;
next	1.12.2.5;

1.12.2.5
date	2003.05.19.22.36.43;	author tedu;	state Exp;
branches;
next	;

1.16.6.1
date	2004.03.03.08.50.13;	author brad;	state Exp;
branches;
next	;

1.18.2.1
date	2004.03.03.08.32.11;	author brad;	state Exp;
branches;
next	;


desc
@@


1.39
log
@
Make sillyrename not so damn silly. The kindergarten algorithm here for
picking a name meant that more than 58 sillys in a directory and we fail
with EINVAL, resulting in strange problems for nfs which in turn causes
pain and stress in building, and PTSD in nfs and vfs hackers. Has bit us
in the butt since the vienna f2k7 hackathon.

good suggestions from deraadt@@ guenther@@ and otto@@

ok deraadt@@,oga@@,blambert@@,krw@@,guenther@@, and a "very special ok" tedu@@

Oh god, I'm an nfs hacker..
@
text
@/*	$OpenBSD: nfsnode.h,v 1.38 2009/09/02 18:20:54 thib Exp $	*/
/*	$NetBSD: nfsnode.h,v 1.16 1996/02/18 11:54:04 fvdl Exp $	*/

/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Rick Macklem at The University of Guelph.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)nfsnode.h	8.9 (Berkeley) 5/14/95
 */


#ifndef _NFS_NFSNODE_H_
#define _NFS_NFSNODE_H_

#ifndef _NFS_NFS_H_
#include <nfs/nfs.h>
#endif

#include <sys/rwlock.h>

/*
 * Silly rename structure that hangs off the nfsnode until the name
 * can be removed by nfs_inactive()
 */
struct sillyrename {
	struct	ucred *s_cred;
	struct	vnode *s_dvp;
	long	s_namlen;
	char	s_name[24];
};

/*
 * The nfsnode is the nfs equivalent to ufs's inode. Any similarity
 * is purely coincidental.
 * There is a unique nfsnode allocated for each active file,
 * each current directory, each mounted-on file, text file, and the root.
 * An nfsnode is 'named' by its file handle. (nget/nfs_node.c)
 * If this structure exceeds 256 bytes (it is currently 256 using 4.4BSD-Lite
 * type definitions), file handles of > 32 bytes should probably be split out
 * into a separate malloc()'d data structure. (Reduce the size of nfsfh_t by
 * changing the definition in sys/mount.h of NFS_SMALLFH.)
 * NB: Hopefully the current order of the fields is such that everything will
 *     be well aligned and, therefore, tightly packed.
 */
struct nfsnode {
	RB_ENTRY(nfsnode)	n_entry;	/* filehandle/node tree. */
	u_quad_t		n_size;		/* Current size of file */
	struct vattr		n_vattr;	/* Vnode attribute cache */
	time_t			n_attrstamp;	/* Attr. cache timestamp */
	struct timespec 	n_mtime;	/* Prev modify time. */
	time_t			n_ctime;	/* Prev create time. */
	nfsfh_t			*n_fhp;		/* NFS File Handle */
	struct vnode		*n_vnode;	/* associated vnode */
	struct lockf		*n_lockf;	/* Locking record of file */
	int			n_error;	/* Save write error value */
	union {
		struct timespec	nf_atim;	/* Special file times */
		nfsuint64	nd_cookieverf;	/* Cookie verifier (dir only) */
	} n_un1;
	union {
		struct timespec	nf_mtim;
		off_t		nd_direof;	/* Dir. EOF offset cache */
	} n_un2;
	struct sillyrename	*n_sillyrename;	/* Ptr to silly rename struct */
	short			n_fhsize;	/* size in bytes, of fh */
	short			n_flag;		/* Flag for locking.. */
	nfsfh_t			n_fh;		/* Small File Handle */
	time_t			n_accstamp;	/* Access cache timestamp */
	uid_t			n_accuid;	/* Last access requester */
	int			n_accmode;	/* Last mode requested */
	int			n_accerror;	/* Last returned error */
	struct ucred		*n_rcred;
	struct ucred		*n_wcred;

	off_t			n_pushedlo;	/* 1st blk in commited range */
	off_t			n_pushedhi;	/* Last block in range */
	off_t			n_pushlo;	/* 1st block in commit range */
	off_t			n_pushhi;	/* Last block in range */
	struct rwlock		n_commitlock;	/* Serialize commits */
	int			n_commitflags;
};

/*
 * Values for n_commitflags
 */
#define NFS_COMMIT_PUSH_VALID   0x0001          /* push range valid */
#define NFS_COMMIT_PUSHED_VALID 0x0002          /* pushed range valid */

#define n_atim		n_un1.nf_atim
#define n_mtim		n_un2.nf_mtim
#define n_cookieverf	n_un1.nd_cookieverf
#define n_direofoffset	n_un2.nd_direof

/*
 * Flags for n_flag
 */
#define	NFLUSHWANT	0x0001	/* Want wakeup from a flush in prog. */
#define	NFLUSHINPROG	0x0002	/* Avoid multiple calls to vinvalbuf() */
#define	NMODIFIED	0x0004	/* Might have a modified buffer in bio */
#define	NWRITEERR	0x0008	/* Flag write errors so close will know */
#define	NACC		0x0100	/* Special file accessed */
#define	NUPD		0x0200	/* Special file updated */
#define	NCHG		0x0400	/* Special file times changed */

#define NFS_INVALIDATE_ATTRCACHE(np)	((np)->n_attrstamp = 0)

/*
 * Convert between nfsnode pointers and vnode pointers
 */
#define VTONFS(vp)	((struct nfsnode *)(vp)->v_data)
#define NFSTOV(np)	((np)->n_vnode)

/*
 * Queue head for nfsiod's
 */
extern TAILQ_HEAD(nfs_bufqhead, buf) nfs_bufq;
extern uint32_t nfs_bufqlen, nfs_bufqmax;

#endif		/* _NFS_NFSNODE_H_ */
@


1.38
log
@Backout the asyncio/aiod change, as it causes buf's to get hung.
problem noticed by deraadt@@

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsnode.h,v 1.36 2009/08/26 12:08:10 thib Exp $	*/
d56 1
a56 1
	char	s_name[20];
@


1.37
log
@introduce a flag member to struct nfs_aiod, and use flags instead of the exit
and worked members. nad_worked becomes NFSAIOD_WAKEUP, which is set after if
an aiod was removed from the idle list and woken up by nfs_asyncio().

don't rely on tsleep wchans being unique, that is keep going back to sleep if
woken up unless the NFSAIOD_WAKEUP flag is set.

fix a divide by zero crash if nfs.vfs.iothreads is set to 0, as that can happen
when we recalculate the maximum buf's to queue up for each aiod.

in nfs_asyncio() set the nad_mnt to NULL before returning the aiod back to the
idle list in the case where we have already queued up to many bufs, otherwise
we trip an assertion.

minimize the time we are holding the nfs_aiodl_mtx to only when we are inserting
or removing from the lists, with the exception of nfs_set_naiod() as it would
make the loops more complicated and its uncommon in any case.

tested by myself and deraadt@@
"fine with me" deraadt@@
@
text
@d140 5
a144 22
/* nfs aiod datas. */
struct nfs_aiod {
	LIST_ENTRY(nfs_aiod)	 nad_all;
	LIST_ENTRY(nfs_aiod)	 nad_idle;
	struct nfsmount		*nad_mnt;
	int			 nad_flags;
};

/* Flags for nad_flags. */
#define	NFSAIOD_EXIT	0x0001	/* aiod being asked to exit. */
#define	NFSAIOD_WAKEUP	0x0002	/* aiod being asked to wakeup. */
/* used by nfs_set_naiod(), for convience. */
#define	NFSAIOD_QUIT	(NFSAIOD_EXIT|NFSAIOD_WAKEUP)	/* aiod must quit. */


LIST_HEAD(nfs_aiodhead, nfs_aiod);

extern struct mutex				nfs_aiodl_mtx;
extern struct nfs_aiodhead			nfs_aiods_all;
extern struct nfs_aiodhead			nfs_aiods_idle;
extern int					nfs_numaiods;
extern int					nfs_aiodbufqmax;
@


1.36
log
@make sure that an aiod has been removed from the nfs_aiods_idle list
before inserting it back into the list.

crashes debugged with help from deraadt@@ who also tested this fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsnode.h,v 1.32 2009/01/19 23:40:36 thib Exp $	*/
d145 1
a145 2
	int			 nad_exiting;
	int			 nad_worked; /* Was removed from idle list. */
d147 7
@


1.35
log
@Rework the way we do async I/O in nfs. Introduce separate buf queues for
each mount, and when work is "found", peg an aiod to that mount todo the
I/O. Make nfs_asyncio() a bit smarter when deciding when to do asyncio
and when to force it sync, this is done by keeping the aiod's one two lists,
an "idle" and an "all" list, so asyncio is only done when there are aiods
hanging around todo it for us or are already pegged to the mount.

Idea liked by at least beck@@ (and I think art@@).
Extensive testing done by myself and jasper and a few others on various
arch's.

Ideas/Code from Net/Free.

OK blambert@@.
@
text
@d146 1
@


1.34
log
@Use an RB tree instead of a hashtable for fh/node lookups.

Idea from NetBSD.

OK blambert@@
@
text
@d140 15
a154 5
/*
 * Queue head for nfsiod's
 */
extern TAILQ_HEAD(nfs_bufqhead, buf) nfs_bufq;
extern uint32_t nfs_bufqlen, nfs_bufqmax;
@


1.33
log
@Use a timespec instead of a time_t for the clients nfsnode
mtime, gives us better granularity, helps with cache consistency.

Idea lifted from NetBSD.

OK blambert@@
@
text
@d73 1
a73 1
	LIST_ENTRY(nfsnode)	n_hash;		/* Hash chain */
@


1.32
log
@Introduce a macro to invalidate the attribute
cache instead of setting n_attrstamp to 0 directly.

Lift the macro name from NetBSD.
prompted by and OK blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsnode.h,v 1.31 2008/06/14 19:33:58 beck Exp $	*/
d77 1
a77 1
	time_t			n_mtime;	/* Prev modify time. */
@


1.31
log
@
Ensure each nfsiod can actually enqueue more than one asynchio - this mirrors
the accidental situation that used to happen when it leaked buffers and allowed
the syncer to do it, however this puts a limit on how much of the buffer cache
it is allowed to consume to a sensible amount - improves nfs write performance
since we don't have to do tons of them synch now.

Modifies the existing code to use wakeup_one instead of cruft, and now
all nfsiod's tsleep the same way.

ok thib@@ art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsnode.h,v 1.30 2008/06/10 22:59:09 thib Exp $	*/
d131 2
@


1.30
log
@
o Avoid putting duplicate entries into the name cache,
  add a function to handle cache_enter()'s for us since
  we need to update the appropriate timestamps so we don't
  miss on lookup;
o Do not purge the dvp in nfs_rmdir(), since there's no need;
o cache the new entry created in nfs_mkdir();
o Do caching of the access modes, this drastically reduces the
  amount of over the wire access RPCs we do in the NFSv3 case.

This diff was written by Pedro Martelletto, sometime in 2004.
A lot of people have been running with it at one time or another,
this includes at least markus and matthieu.

OK deraadt@@, blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsnode.h,v 1.29 2007/12/13 22:32:55 thib Exp $	*/
d142 1
@


1.29
log
@Garbage collect nfsdmap and leftover code. That structure
was used as a part of the "old-style directory caching"
that was removed in 2001;

ok beck@@, blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsnode.h,v 1.28 2007/10/28 14:03:47 thib Exp $	*/
d95 4
@


1.28
log
@remove some unused members of struct nfsnode;
some spacing while there.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsnode.h,v 1.27 2007/09/20 12:54:31 thib Exp $	*/
a59 16
 * This structure is used to save the logical directory offset to
 * NFS cookie mappings.
 * The mappings are stored in a list headed
 * by n_cookies, as required.
 * There is one mapping for each NFS_DIRBLKSIZ bytes of directory information
 * stored in increasing logical offset byte order.
 */
#define NFSNUMCOOKIES		31

struct nfsdmap {
	LIST_ENTRY(nfsdmap)	ndm_list;
	int			ndm_eocookie;
	nfsuint64		ndm_cookies[NFSNUMCOOKIES];
};

/*
d91 1
a91 4
	union {
		struct sillyrename *nf_silly;	/* Ptr to silly rename struct */
		LIST_HEAD(, nfsdmap) nd_cook;	/* cookies */
	} n_un3;
a113 1
#define n_sillyrename	n_un3.nf_silly
a115 1
#define n_cookies	n_un3.nd_cook
@


1.27
log
@MALLOC/FREE -> malloc/free + M_ZERO.
Uneeded includes and casts...

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsnode.h,v 1.26 2007/06/21 22:59:49 thib Exp $	*/
a90 2
	u_quad_t		n_brev;		/* Modify rev when cached */
	u_quad_t		n_lrev;		/* Modify rev for lease */
a94 1
	time_t			n_expiry;	/* Lease expiry time */
d117 6
a122 6
	off_t                    n_pushedlo;    /* 1st blk in commited range */
	off_t                    n_pushedhi;    /* Last block in range */
	off_t                    n_pushlo;      /* 1st block in commit range */
	off_t                    n_pushhi;      /* Last block in range */
	struct rwlock            n_commitlock;  /* Serialize commits */
	int                      n_commitflags;
@


1.26
log
@remove a whole bunch of duplicate function
prototypes.
(survived build/release on macppc/amd64).

ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsnode.h,v 1.25 2007/04/12 13:24:39 thib Exp $	*/
d83 1
a83 1
 * into a separate MALLOC()'d data structure. (Reduce the size of nfsfh_t by
@


1.25
log
@remove unused members from struct nfsmount and nfsnode;

ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsnode.h,v 1.24 2007/03/18 15:05:33 mickey Exp $	*/
d163 1
a163 58
#ifdef _KERNEL
/*
 * Prototypes for NFS vnode operations
 */
int	nfs_lookup(void *);
int	nfs_create(void *);
int	nfs_mknod(void *);
int	nfs_open(void *);
int	nfs_close(void *);
int	nfsspec_close(void *);
int	nfsfifo_close(void *);
int	nfs_access(void *);
int	nfsspec_access(void *);
int	nfs_getattr(void *);
int	nfs_setattr(void *);
int	nfs_read(void *);
int	nfs_write(void *);
int	nfsspec_read(void *);
int	nfsspec_write(void *);
int	nfsfifo_read(void *);
int	nfsfifo_write(void *);
#define nfs_ioctl ((int (*)(void *))enoioctl)
int	nfs_poll(void *);
#define nfs_revoke vop_generic_revoke
int	nfs_fsync(void *);
int	nfs_remove(void *);
int	nfs_link(void *);
int	nfs_rename(void *);
int	nfs_mkdir(void *);
int	nfs_rmdir(void *);
int	nfs_symlink(void *);
int	nfs_readdir(void *);
int	nfs_readlink(void *);
int	nfs_inactive(void *);
int	nfs_reclaim(void *);
int	nfsfifo_reclaim(void *);
#define nfs_lock ((int (*)(void *))vop_generic_lock)
#define nfs_unlock ((int (*)(void *))vop_generic_unlock)
#define nfs_islocked ((int (*)(void *))vop_generic_islocked)
int	nfs_bmap(void *);
int	nfs_strategy(void *);
int	nfs_print(void *);
int	nfs_pathconf(void *);
int	nfs_advlock(void *);
int	nfs_bwrite(void *);
int	nfs_vget(struct mount *, ino_t, struct vnode **);

/* other stuff */
int	nfs_removeit(struct sillyrename *);
int	nfs_nget(struct mount *,nfsfh_t *,int,struct nfsnode **);
int	nfs_lookitup(struct vnode *,char *,int,struct ucred *,struct proc *,struct nfsnode **);
int	nfs_sillyrename(struct vnode *,struct vnode *,struct componentname *);

extern int (**nfsv2_vnodeop_p)(void *);

#endif /* _KERNEL */

#endif
@


1.24
log
@get rid of noop vop_reallocblks; pedro@@ miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsnode.h,v 1.23 2007/01/16 17:52:18 thib Exp $	*/
a89 1
	CIRCLEQ_ENTRY(nfsnode)	n_timer;	/* Nqnfs timer chain */
@


1.23
log
@Retire VOP_LEASE(); It was a bit for NQNFS and has
effectively been a no-op for quite some time now,
without promise for future usage.

ok pedro@@
Testing by krw@@ (earlier diff)
and Johan Mson Lindman (tybollt@@solace.miun.se)
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsnode.h,v 1.22 2004/08/03 17:11:48 marius Exp $	*/
a209 2
#define nfs_reallocblks \
	((int (*)(void *))eopnotsupp)
@


1.22
log
@NFS commit coalescion: instead of sending a commit for each block, coalesce
these into larger ranges wherever possible.

this should speed up NFS writes quite a bit.

ok art@@ millert@@ pedro@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsnode.h,v 1.21 2004/04/26 18:57:36 millert Exp $	*/
a180 2
#define	nfs_lease_check ((int (*)(void *))nullop)
#define nqnfs_vop_lease_check	lease_check
@


1.21
log
@nfs_poll cannot simply be defined to seltrue so use a stub nfs_poll
duplicated from UFS.  Closes PR 3757; OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsnode.h,v 1.20 2004/03/02 05:46:00 tedu Exp $	*/
d46 2
d120 7
d128 6
@


1.20
log
@silly fifos aren't a real fs, so we have to be sure to call reclaim
in the host fs.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsnode.h,v 1.19 2003/09/23 16:51:13 millert Exp $	*/
d173 1
a173 1
#define nfs_poll ((int (*)(void *))seltrue)
@


1.19
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsnode.h,v 1.18 2003/06/02 23:28:20 millert Exp $	*/
d186 1
@


1.18
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsnode.h,v 1.17 2003/05/13 02:09:47 jason Exp $	*/
d173 1
a173 1
#define nfs_select ((int (*)(void *))seltrue)
@


1.18.2.1
log
@MFC:
Fix from tedu@@

prevent memory leak on revoke by freeing resources in a real reclaim
function.
also check fifoinfo is valid before deref.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsnode.h,v 1.18 2003/06/02 23:28:20 millert Exp $	*/
a185 1
int	nfsfifo_reclaim(void *);
@


1.17
log
@Kill a bunch more commons (very few left =)
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsnode.h,v 1.16 2002/03/14 01:27:13 millert Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.16
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsnode.h,v 1.15 2002/02/23 23:47:13 art Exp $	*/
d151 1
a151 1
TAILQ_HEAD(, buf) nfs_bufq;
@


1.16.6.1
log
@MFC:
Fix from tedu@@

prevent memory leak on revoke by freeing resources in a real reclaim
function.
also check fifoinfo is valid before deref.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsnode.h,v 1.16 2002/03/14 01:27:13 millert Exp $	*/
a189 1
int	nfsfifo_reclaim(void *);
@


1.15
log
@Sigh. The diff is out for testing for three months without a single problem.
Two days after commit people report serious lockups all over the place.
Back out nfs locking changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsnode.h,v 1.13 2001/12/19 08:58:06 art Exp $	*/
d157 14
a170 14
int	nfs_lookup __P((void *));
int	nfs_create __P((void *));
int	nfs_mknod __P((void *));
int	nfs_open __P((void *));
int	nfs_close __P((void *));
int	nfsspec_close __P((void *));
int	nfsfifo_close __P((void *));
int	nfs_access __P((void *));
int	nfsspec_access __P((void *));
int	nfs_getattr __P((void *));
int	nfs_setattr __P((void *));
int	nfs_read __P((void *));
int	nfs_write __P((void *));
#define	nfs_lease_check ((int (*) __P((void *)))nullop)
d172 6
a177 6
int	nfsspec_read __P((void *));
int	nfsspec_write __P((void *));
int	nfsfifo_read __P((void *));
int	nfsfifo_write __P((void *));
#define nfs_ioctl ((int (*) __P((void *)))enoioctl)
#define nfs_select ((int (*) __P((void *)))seltrue)
d179 21
a199 21
int	nfs_fsync __P((void *));
int	nfs_remove __P((void *));
int	nfs_link __P((void *));
int	nfs_rename __P((void *));
int	nfs_mkdir __P((void *));
int	nfs_rmdir __P((void *));
int	nfs_symlink __P((void *));
int	nfs_readdir __P((void *));
int	nfs_readlink __P((void *));
int	nfs_inactive __P((void *));
int	nfs_reclaim __P((void *));
#define nfs_lock ((int (*) __P((void *)))vop_generic_lock)
#define nfs_unlock ((int (*) __P((void *)))vop_generic_unlock)
#define nfs_islocked ((int (*) __P((void *)))vop_generic_islocked)
int	nfs_bmap __P((void *));
int	nfs_strategy __P((void *));
int	nfs_print __P((void *));
int	nfs_pathconf __P((void *));
int	nfs_advlock __P((void *));
int	nfs_bwrite __P((void *));
int	nfs_vget __P((struct mount *, ino_t, struct vnode **));
d201 1
a201 1
	((int (*) __P((void *)))eopnotsupp)
d204 4
a207 4
int	nfs_removeit __P((struct sillyrename *));
int	nfs_nget __P((struct mount *,nfsfh_t *,int,struct nfsnode **));
int	nfs_lookitup __P((struct vnode *,char *,int,struct ucred *,struct proc *,struct nfsnode **));
int	nfs_sillyrename __P((struct vnode *,struct vnode *,struct componentname *));
d209 1
a209 1
extern int (**nfsv2_vnodeop_p) __P((void *));
@


1.14
log
@More locking in the NFS code
@
text
@a121 1
	struct lock             n_lock;
d190 3
a192 3
int     nfs_lock __P((void *));
int     nfs_unlock __P((void *));
int     nfs_islocked __P((void *));
@


1.13
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsnode.h,v 1.11 2001/11/15 23:15:15 art Exp $	*/
d122 1
d191 3
a193 3
#define nfs_lock ((int (*) __P((void *)))vop_generic_lock)
#define nfs_unlock ((int (*) __P((void *)))vop_generic_unlock)
#define nfs_islocked ((int (*) __P((void *)))vop_generic_islocked)
@


1.12
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@a121 6
	off_t			n_pushedlo;     /* 1st blk in commited range */
	off_t			n_pushedhi;     /* Last block in range */
	off_t			n_pushlo;       /* 1st block in commit range */
	off_t			n_pushhi;       /* Last block in range */
	struct lock		n_commitlock;   /* Serialize commits XXX */
	int			n_commitflags;
a123 6
/*
 * Values for n_commitflags
 */
#define NFS_COMMIT_PUSH_VALID		0x0001	/* push range valid */
#define NFS_COMMIT_PUSHED_VALID		0x0002	/* pushed range valid */

a201 2
int	nfs_getpages __P((void *));
int	nfs_putpages __P((void *));
@


1.12.2.1
log
@Merge in UBC performance changes from NetBSD.
Fix a bunch of merge errors from yesterday.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsnode.h,v 1.12 2001/11/27 05:27:12 art Exp $	*/
a48 1
#include <miscfs/genfs/genfs.h>
a90 1
	struct genfs_node	n_gnode;
a221 1
int	nfs_gop_write(struct vnode *, struct vm_page **, int, int);
@


1.12.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsnode.h,v 1.12.2.1 2002/02/02 03:28:26 art Exp $	*/
d171 14
a184 14
int	nfs_lookup(void *);
int	nfs_create(void *);
int	nfs_mknod(void *);
int	nfs_open(void *);
int	nfs_close(void *);
int	nfsspec_close(void *);
int	nfsfifo_close(void *);
int	nfs_access(void *);
int	nfsspec_access(void *);
int	nfs_getattr(void *);
int	nfs_setattr(void *);
int	nfs_read(void *);
int	nfs_write(void *);
#define	nfs_lease_check ((int (*)(void *))nullop)
d186 6
a191 6
int	nfsspec_read(void *);
int	nfsspec_write(void *);
int	nfsfifo_read(void *);
int	nfsfifo_write(void *);
#define nfs_ioctl ((int (*)(void *))enoioctl)
#define nfs_select ((int (*)(void *))seltrue)
d193 21
a213 21
int	nfs_fsync(void *);
int	nfs_remove(void *);
int	nfs_link(void *);
int	nfs_rename(void *);
int	nfs_mkdir(void *);
int	nfs_rmdir(void *);
int	nfs_symlink(void *);
int	nfs_readdir(void *);
int	nfs_readlink(void *);
int	nfs_inactive(void *);
int	nfs_reclaim(void *);
#define nfs_lock ((int (*)(void *))vop_generic_lock)
#define nfs_unlock ((int (*)(void *))vop_generic_unlock)
#define nfs_islocked ((int (*)(void *))vop_generic_islocked)
int	nfs_bmap(void *);
int	nfs_strategy(void *);
int	nfs_print(void *);
int	nfs_pathconf(void *);
int	nfs_advlock(void *);
int	nfs_bwrite(void *);
int	nfs_vget(struct mount *, ino_t, struct vnode **);
d215 3
a217 3
	((int (*)(void *))eopnotsupp)
int	nfs_getpages(void *);
int	nfs_putpages(void *);
d220 4
a223 4
int	nfs_removeit(struct sillyrename *);
int	nfs_nget(struct mount *,nfsfh_t *,int,struct nfsnode **);
int	nfs_lookitup(struct vnode *,char *,int,struct ucred *,struct proc *,struct nfsnode **);
int	nfs_sillyrename(struct vnode *,struct vnode *,struct componentname *);
d226 1
a226 1
extern int (**nfsv2_vnodeop_p)(void *);
@


1.12.2.3
log
@Resurrect Costas nfs locking on the UBC branch. It's needed here.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsnode.h,v 1.14 2002/02/22 20:19:14 csapuntz Exp $	*/
a123 1
	struct lock		n_lock;
d204 3
a206 3
int	nfs_lock(void *);
int	nfs_unlock(void *);
int 	nfs_islocked(void *);
@


1.12.2.4
log
@Huge sync to NetBSD plus lots of bugfixes.
 - uvm is as in netbsd-current minus uvm_map forward merge.
 - various locking bugfixes in nfs.
 - make sure that all specops and fifoops are correct in all vnodeop vectors.
 - make the filesystem code more like filsystem code and less like vm code.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsnode.h,v 1.12.2.3 2002/10/29 18:31:52 art Exp $	*/
a155 1
#define NTRUNCDELAYED	0x1000	/* Should be truncated later */
@


1.12.2.5
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d167 1
a167 1
extern TAILQ_HEAD(nfs_bufqhead, buf) nfs_bufq;
@


1.11
log
@Remove creds from struct buf, move the creds that nfs need into the nfs node.
While in the area, convert nfs node allocation from malloc to pool and do
some cleanups.
Based on the UBC changes in NetBSD. niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsnode.h,v 1.10 2001/06/25 03:28:14 csapuntz Exp $	*/
d122 6
d130 6
d214 2
@


1.10
log
@Remove NQNFS
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsnode.h,v 1.9 2001/06/25 02:15:48 csapuntz Exp $	*/
d120 2
d146 1
a146 1
#define NFSTOV(np)	((struct vnode *)(np)->n_vnode)
@


1.9
log
@
Get rid of old directory caching scheme which caused persistent duplicates.

Still not correct for NFSv3 but that's hard.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsnode.h,v 1.8 2001/06/23 02:14:27 csapuntz Exp $	*/
a135 3
#define	NQNFSNONCACHE	0x0020	/* Non-cachable lease */
#define	NQNFSWRITE	0x0040	/* Write lease */
#define	NQNFSEVICTED	0x0080	/* Has been evicted */
@


1.8
log
@Get rid of several unused vnode operations
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsnode.h,v 1.7 1998/08/06 19:35:02 csapuntz Exp $	*/
a208 2
nfsuint64 *nfs_getcookie __P((struct nfsnode *, off_t, int));
void nfs_invaldir __P((struct vnode *));
@


1.7
log
@

Rename vop_revoke, vn_bwrite, vop_noislocked, vop_nolock, vop_nounlock
to be vop_generic_revoke, vop_generic_bwrite, vop_generic_islocked,
vop_generic_lock and vop_generic_unlock.

Create vop_generic_abortop and propogate change to all file systems.

Fix PR/371.

Get rid of locking in NULLFS (should be mostly unnecessary now except for
forced unmounts).
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsnode.h,v 1.6 1997/11/06 05:59:06 csapuntz Exp $	*/
a179 1
int	nfs_mmap __P((void *));
a180 1
#define nfs_seek ((int (*) __P((void *)))nullop)
a198 1
int	nfs_blkatoff __P((void *));
a200 1
int	nfs_valloc __P((void *));
a202 3
int	nfs_vfree __P((void *));
int	nfs_truncate __P((void *));
int	nfs_update __P((void *));
@


1.7.8.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsnode.h,v 1.7 1998/08/06 19:35:02 csapuntz Exp $	*/
d136 3
d180 1
d182 1
d201 1
d204 1
d207 3
d216 2
@


1.7.8.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a119 8
	struct ucred		*n_rcred;
	struct ucred		*n_wcred;
	off_t			n_pushedlo;     /* 1st blk in commited range */
	off_t			n_pushedhi;     /* Last block in range */
	off_t			n_pushlo;       /* 1st block in commit range */
	off_t			n_pushhi;       /* Last block in range */
	struct lock		n_commitlock;   /* Serialize commits XXX */
	int			n_commitflags;
a121 6
/*
 * Values for n_commitflags
 */
#define NFS_COMMIT_PUSH_VALID		0x0001	/* push range valid */
#define NFS_COMMIT_PUSHED_VALID		0x0002	/* pushed range valid */

d144 1
a144 1
#define NFSTOV(np)	((np)->n_vnode)
a199 2
int	nfs_getpages __P((void *));
int	nfs_putpages __P((void *));
@


1.7.8.3
log
@Merge in trunk
@
text
@d122 6
d130 6
d214 2
@


1.7.8.4
log
@Merge in -current from roughly a week ago
@
text
@d157 14
a170 14
int	nfs_lookup(void *);
int	nfs_create(void *);
int	nfs_mknod(void *);
int	nfs_open(void *);
int	nfs_close(void *);
int	nfsspec_close(void *);
int	nfsfifo_close(void *);
int	nfs_access(void *);
int	nfsspec_access(void *);
int	nfs_getattr(void *);
int	nfs_setattr(void *);
int	nfs_read(void *);
int	nfs_write(void *);
#define	nfs_lease_check ((int (*)(void *))nullop)
d172 6
a177 6
int	nfsspec_read(void *);
int	nfsspec_write(void *);
int	nfsfifo_read(void *);
int	nfsfifo_write(void *);
#define nfs_ioctl ((int (*)(void *))enoioctl)
#define nfs_select ((int (*)(void *))seltrue)
d179 21
a199 21
int	nfs_fsync(void *);
int	nfs_remove(void *);
int	nfs_link(void *);
int	nfs_rename(void *);
int	nfs_mkdir(void *);
int	nfs_rmdir(void *);
int	nfs_symlink(void *);
int	nfs_readdir(void *);
int	nfs_readlink(void *);
int	nfs_inactive(void *);
int	nfs_reclaim(void *);
#define nfs_lock ((int (*)(void *))vop_generic_lock)
#define nfs_unlock ((int (*)(void *))vop_generic_unlock)
#define nfs_islocked ((int (*)(void *))vop_generic_islocked)
int	nfs_bmap(void *);
int	nfs_strategy(void *);
int	nfs_print(void *);
int	nfs_pathconf(void *);
int	nfs_advlock(void *);
int	nfs_bwrite(void *);
int	nfs_vget(struct mount *, ino_t, struct vnode **);
d201 1
a201 1
	((int (*)(void *))eopnotsupp)
d204 4
a207 4
int	nfs_removeit(struct sillyrename *);
int	nfs_nget(struct mount *,nfsfh_t *,int,struct nfsnode **);
int	nfs_lookitup(struct vnode *,char *,int,struct ucred *,struct proc *,struct nfsnode **);
int	nfs_sillyrename(struct vnode *,struct vnode *,struct componentname *);
d209 1
a209 1
extern int (**nfsv2_vnodeop_p)(void *);
@


1.7.8.5
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d151 1
a151 1
extern TAILQ_HEAD(nfs_bufqhead, buf) nfs_bufq;
@


1.7.8.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsnode.h,v 1.7.8.5 2003/05/16 00:29:45 niklas Exp $	*/
d19 5
a23 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.7.8.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d173 1
a173 1
#define nfs_poll ((int (*)(void *))seltrue)
@


1.7.8.8
log
@Merge with the trunk
@
text
@d173 1
a173 1
int	nfs_poll(void *);
a185 1
int	nfsfifo_reclaim(void *);
@


1.6
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsnode.h,v 1.5 1997/10/06 20:20:55 deraadt Exp $	*/
d179 1
a179 1
#define nfs_revoke vop_revoke
a190 1
int	nfs_abortop __P((void *));
d193 3
a195 3
#define nfs_lock ((int (*) __P((void *)))vop_nolock)
#define nfs_unlock ((int (*) __P((void *)))vop_nounlock)
#define nfs_islocked ((int (*) __P((void *)))vop_noislocked)
@


1.5
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsnode.h,v 1.3 1996/03/31 13:16:16 mickey Exp $	*/
a193 1
#ifdef Lite2_integrated
a196 5
#else
int	nfs_lock __P((void *));
int	nfs_unlock __P((void *));
int	nfs_islocked __P((void *));
#endif /* Lite2_integrated */
@


1.4
log
@VFS Lite2 Changes
@
text
@d194 1
d198 5
@


1.3
log
@From NetBSD: NFSv3 import (tomorrow's Net's kernel)
Open's patches kept in. i'll possibly take a look at Lite2 soon,
is there smth usefull ?..
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsnode.h,v 1.2 1996/02/29 09:25:04 niklas Exp $	*/
a193 1
#ifdef Lite2_integrated
a196 5
#else
int	nfs_lock __P((void *));
int	nfs_unlock __P((void *));
int	nfs_islocked __P((void *));
#endif /* Lite2_integrated */
@


1.2
log
@From NetBSD: merge with 960217 (still NFSv2)
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: nfsnode.h,v 1.15 1996/02/09 21:48:47 christos Exp $	*/
d39 1
a39 1
 *	@@(#)nfsnode.h	8.6 (Berkeley) 8/18/94
d42 8
d62 16
d83 6
a89 1

d91 29
a119 20
	LIST_ENTRY(nfsnode) n_hash;	/* Hash chain */
	CIRCLEQ_ENTRY(nfsnode) n_timer;	/* Nqnfs timer chain */
	nfsv2fh_t n_fh;			/* NFS File Handle */
	long	n_flag;			/* Flag for locking.. */
	struct	vnode *n_vnode;		/* vnode associated with this node */
	struct	vattr n_vattr;		/* Vnode attribute cache */
	time_t	n_attrstamp;		/* Time stamp for cached attributes */
	struct	sillyrename *n_sillyrename; /* Ptr to silly rename struct */
	u_quad_t n_size;		/* Current size of file */
	int	n_error;		/* Save write error value */
	u_long	n_direofoffset;		/* Dir. EOF offset cache */
	time_t	n_mtime;		 /* Prev modify time. */
	time_t	n_ctime;		 /* Prev create time. */
	u_quad_t n_brev;		 /* Modify rev when cached */
	u_quad_t n_lrev;		 /* Modify rev for lease */
	time_t	n_expiry;		 /* Lease expiry time */
	struct	lockf *n_lockf;		/* Advisory lock records */
	struct	sillyrename n_silly;	/* Silly rename struct */
	struct	timeval n_atim;		/* Special file times */
	struct	timeval n_mtim;
d122 7
d158 67
a224 53
int	nfs_lookup	__P((void *));
int	nfs_create	__P((void *));
int	nfs_mknod	__P((void *));
int	nfs_open	__P((void *));
int	nfs_close	__P((void *));
int	nfsspec_close	__P((void *));
#ifdef FIFO
int	nfsfifo_close	__P((void *));
#endif
int	nfs_access	__P((void *));
int	nfsspec_access	__P((void *));
int	nfs_getattr	__P((void *));
int	nfs_setattr	__P((void *));
int	nfs_read	__P((void *));
int	nfs_write	__P((void *));
#define	nfs_lease_check (int (*) __P((void *))) nullop
int	nfsspec_read	__P((void *));
int	nfsspec_write	__P((void *));
#ifdef FIFO
int	nfsfifo_read	__P((void *));
int	nfsfifo_write	__P((void *));
#endif
#define nfs_ioctl 	(int (*) __P((void *))) enoioctl
#define nfs_select 	(int (*) __P((void *))) seltrue
int	nfs_mmap	__P((void *));
int	nfs_fsync	__P((void *));
#define nfs_seek 	(int (*) __P((void *))) nullop
int	nfs_remove	__P((void *));
int	nfs_link	__P((void *));
int	nfs_rename	__P((void *));
int	nfs_mkdir	__P((void *));
int	nfs_rmdir	__P((void *));
int	nfs_symlink	__P((void *));
int	nfs_readdir	__P((void *));
int	nfs_readlink	__P((void *));
int	nfs_abortop	__P((void *));
int	nfs_inactive	__P((void *));
int	nfs_reclaim	__P((void *));
int	nfs_lock	__P((void *));
int	nfs_unlock	__P((void *));
int	nfs_bmap	__P((void *));
int	nfs_strategy	__P((void *));
int	nfs_print	__P((void *));
int	nfs_islocked	__P((void *));
int	nfs_pathconf	__P((void *));
int	nfs_advlock	__P((void *));
int	nfs_blkatoff	__P((void *));
int	nfs_valloc	__P((void *));
#define nfs_reallocblks (int (*) __P((void *))) eopnotsupp
int	nfs_vfree	__P((void *));
int	nfs_truncate	__P((void *));
int	nfs_update	__P((void *));
int	nfs_bwrite	__P((void *));
d229 2
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: nfsnode.h,v 1.14 1995/03/26 20:37:32 jtc Exp $	*/
d113 6
a118 6
int	nfs_lookup __P((struct vop_lookup_args *));
int	nfs_create __P((struct vop_create_args *));
int	nfs_mknod __P((struct vop_mknod_args *));
int	nfs_open __P((struct vop_open_args *));
int	nfs_close __P((struct vop_close_args *));
int	nfsspec_close __P((struct vop_close_args *));
d120 1
a120 1
int	nfsfifo_close __P((struct vop_close_args *));
d122 9
a130 9
int	nfs_access __P((struct vop_access_args *));
int	nfsspec_access __P((struct vop_access_args *));
int	nfs_getattr __P((struct vop_getattr_args *));
int	nfs_setattr __P((struct vop_setattr_args *));
int	nfs_read __P((struct vop_read_args *));
int	nfs_write __P((struct vop_write_args *));
#define	nfs_lease_check ((int (*) __P((struct  vop_lease_args *)))nullop)
int	nfsspec_read __P((struct vop_read_args *));
int	nfsspec_write __P((struct vop_write_args *));
d132 2
a133 2
int	nfsfifo_read __P((struct vop_read_args *));
int	nfsfifo_write __P((struct vop_write_args *));
d135 34
a168 33
#define nfs_ioctl ((int (*) __P((struct  vop_ioctl_args *)))enoioctl)
#define nfs_select ((int (*) __P((struct  vop_select_args *)))seltrue)
int	nfs_mmap __P((struct vop_mmap_args *));
int	nfs_fsync __P((struct vop_fsync_args *));
#define nfs_seek ((int (*) __P((struct  vop_seek_args *)))nullop)
int	nfs_remove __P((struct vop_remove_args *));
int	nfs_link __P((struct vop_link_args *));
int	nfs_rename __P((struct vop_rename_args *));
int	nfs_mkdir __P((struct vop_mkdir_args *));
int	nfs_rmdir __P((struct vop_rmdir_args *));
int	nfs_symlink __P((struct vop_symlink_args *));
int	nfs_readdir __P((struct vop_readdir_args *));
int	nfs_readlink __P((struct vop_readlink_args *));
int	nfs_abortop __P((struct vop_abortop_args *));
int	nfs_inactive __P((struct vop_inactive_args *));
int	nfs_reclaim __P((struct vop_reclaim_args *));
int	nfs_lock __P((struct vop_lock_args *));
int	nfs_unlock __P((struct vop_unlock_args *));
int	nfs_bmap __P((struct vop_bmap_args *));
int	nfs_strategy __P((struct vop_strategy_args *));
int	nfs_print __P((struct vop_print_args *));
int	nfs_islocked __P((struct vop_islocked_args *));
int	nfs_pathconf __P((struct vop_pathconf_args *));
int	nfs_advlock __P((struct vop_advlock_args *));
int	nfs_blkatoff __P((struct vop_blkatoff_args *));
int	nfs_vget __P((struct mount *, ino_t, struct vnode **));
int	nfs_valloc __P((struct vop_valloc_args *));
#define nfs_reallocblks \
	((int (*) __P((struct  vop_reallocblks_args *)))eopnotsupp)
int	nfs_vfree __P((struct vop_vfree_args *));
int	nfs_truncate __P((struct vop_truncate_args *));
int	nfs_update __P((struct vop_update_args *));
int	nfs_bwrite __P((struct vop_bwrite_args *));
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
