head	1.28;
access;
symbols
	OPENBSD_6_2:1.28.0.10
	OPENBSD_6_2_BASE:1.28
	OPENBSD_6_1:1.28.0.8
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.28.0.4
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.28.0.2
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.27.0.4
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.24.0.4
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.23.0.22
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.18
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.16
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.14
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.12
	OPENBSD_5_0:1.23.0.10
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.8
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.6
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.4
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.21.0.2
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.19.0.2
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.15.0.2
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.12.0.12
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.10
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.8
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.6
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.4
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.9
	UBC:1.7.0.4
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.10
	OPENBSD_2_8:1.6.0.8
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.6
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.4
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.12
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.10
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.8
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.6
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.4
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.28
date	2015.08.28.00.03.54;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	NdgfPIGUgJxQPnT7;

1.27
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.26;
commitid	p4LJxGKbi0BU2cG6;

1.26
date	2014.11.18.10.42.15;	author dlg;	state Exp;
branches;
next	1.25;
commitid	4DOHz2gKfCx7RejS;

1.25
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.24;
commitid	uzzBR7hz9ncd4O6G;

1.24
date	2014.07.12.18.43.52;	author tedu;	state Exp;
branches;
next	1.23;
commitid	FE3DG5cICjyI4jWx;

1.23
date	2009.06.04.18.36.43;	author thib;	state Exp;
branches;
next	1.22;

1.22
date	2009.05.30.17.20.29;	author thib;	state Exp;
branches;
next	1.21;

1.21
date	2008.12.24.02.43.52;	author thib;	state Exp;
branches;
next	1.20;

1.20
date	2008.10.20.13.40.19;	author blambert;	state Exp;
branches;
next	1.19;

1.19
date	2008.07.05.12.45.06;	author thib;	state Exp;
branches;
next	1.18;

1.18
date	2008.06.12.20.24.06;	author blambert;	state Exp;
branches;
next	1.17;

1.17
date	2008.06.11.04.52.27;	author blambert;	state Exp;
branches;
next	1.16;

1.16
date	2008.04.14.10.39.19;	author thib;	state Exp;
branches;
next	1.15;

1.15
date	2007.10.29.11.16.49;	author thib;	state Exp;
branches;
next	1.14;

1.14
date	2007.10.28.14.12.41;	author thib;	state Exp;
branches;
next	1.13;

1.13
date	2007.09.20.12.54.31;	author thib;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.26.21.22.14;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2004.07.16.15.01.51;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.02.23.28.19;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.03.20.57.00;	author nate;	state Exp;
branches;
next	1.8;

1.8
date	2002.01.16.21.51.16;	author ericj;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.25.03.28.09;	author csapuntz;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	99.04.28.09.28.17;	author art;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	96.04.21.22.30.28;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.17.04.50.30;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.03.31.13.15.50;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.02.29.09.24.55;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.22;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.22;	author deraadt;	state Exp;
branches;
next	;

1.6.4.1
date	2001.07.04.10.55.49;	author niklas;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2002.03.06.02.17.12;	author niklas;	state Exp;
branches;
next	1.6.4.3;

1.6.4.3
date	2003.03.28.00.08.46;	author niklas;	state Exp;
branches;
next	1.6.4.4;

1.6.4.4
date	2003.06.07.11.07.44;	author ho;	state Exp;
branches;
next	;

1.7.4.1
date	2002.01.31.22.55.47;	author niklas;	state Exp;
branches;
next	1.7.4.2;

1.7.4.2
date	2002.10.29.00.36.49;	author art;	state Exp;
branches;
next	;


desc
@@


1.28
log
@fairly simple sizes for free(); ok tedu
@
text
@/*	$OpenBSD: nfs_srvcache.c,v 1.27 2015/03/14 03:38:52 jsg Exp $	*/
/*	$NetBSD: nfs_srvcache.c,v 1.12 1996/02/18 11:53:49 fvdl Exp $	*/

/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Rick Macklem at The University of Guelph.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)nfs_srvcache.c	8.3 (Berkeley) 3/30/95
 */

/*
 * Reference: Chet Juszczak, "Improving the Performance and Correctness
 *		of an NFS Server", in Proc. Winter 1989 USENIX Conference,
 *		pages 53-63. San Diego, February 1989.
 */
#include <sys/param.h>
#include <sys/mount.h>
#include <sys/kernel.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/socket.h>
#include <sys/queue.h>

#include <crypto/siphash.h>

#include <netinet/in.h>
#include <nfs/nfsproto.h>
#include <nfs/nfs.h>
#include <nfs/nfsrvcache.h>
#include <nfs/nfs_var.h>

extern struct nfsstats nfsstats;
extern int nfsv2_procid[NFS_NPROCS];
long numnfsrvcache, desirednfsrvcache = NFSRVCACHESIZ;

struct nfsrvcache	*nfsrv_lookupcache(struct nfsrv_descript *);
void			 nfsrv_cleanentry(struct nfsrvcache *);

LIST_HEAD(nfsrvhash, nfsrvcache) *nfsrvhashtbl;
SIPHASH_KEY nfsrvhashkey;
TAILQ_HEAD(nfsrvlru, nfsrvcache) nfsrvlruhead;
u_long nfsrvhash;
#define	NFSRCHASH(xid) \
    (&nfsrvhashtbl[SipHash24(&nfsrvhashkey, &(xid), sizeof(xid)) & nfsrvhash])

#define	NETFAMILY(rp)	\
	(((rp)->rc_flag & RC_INETADDR) ? AF_INET : AF_UNSPEC)

/* Array that defines which nfs rpc's are nonidempotent */
int nonidempotent[NFS_NPROCS] = {
	0, 0, 1, 0, 0, 0, 0, 1,
	1, 1, 1, 1, 1, 1, 1, 1,
	0, 0, 0, 0, 0, 0, 0
};

/* True iff the rpc reply is an nfs status ONLY! */
int nfsv2_repstat[NFS_NPROCS] = {
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 1, 1, 1, 1, 0, 1,
	0, 0
};

void
nfsrv_cleanentry(struct nfsrvcache *rp)
{
	if ((rp->rc_flag & RC_REPMBUF) != 0)
		m_freem(rp->rc_reply);

	if ((rp->rc_flag & RC_NAM) != 0)
		m_free(rp->rc_nam);

	rp->rc_flag &= ~(RC_REPSTATUS|RC_REPMBUF);
}

/* Initialize the server request cache list */
void
nfsrv_initcache(void)
{

	nfsrvhashtbl = hashinit(desirednfsrvcache, M_NFSD, M_WAITOK, &nfsrvhash);
	arc4random_buf(&nfsrvhashkey, sizeof(nfsrvhashkey));
	TAILQ_INIT(&nfsrvlruhead);
}

/*
 * Look for the request in the cache
 * If found then
 *    return action and optionally reply
 * else
 *    insert it in the cache
 *
 * The rules are as follows:
 * - if in progress, return DROP request
 * - if completed within DELAY of the current time, return DROP it
 * - if completed a longer time ago return REPLY if the reply was cached or
 *   return DOIT
 * Update/add new request at end of lru list
 */
int
nfsrv_getcache(struct nfsrv_descript *nd, struct nfssvc_sock *slp,
    struct mbuf **repp)
{
	struct nfsrvhash *hash;
	struct nfsrvcache *rp;
	struct mbuf *mb;
	struct sockaddr_in *saddr;
	int ret;

	/*
	 * Don't cache recent requests for reliable transport protocols.
	 * (Maybe we should for the case of a reconnect, but..)
	 */
	if (!nd->nd_nam2)
		return (RC_DOIT);

	rp = nfsrv_lookupcache(nd);
	if (rp) {
		/* If not at end of LRU chain, move it there */
		if (TAILQ_NEXT(rp, rc_lru)) {
			TAILQ_REMOVE(&nfsrvlruhead, rp, rc_lru);
			TAILQ_INSERT_TAIL(&nfsrvlruhead, rp, rc_lru);
		}
		if (rp->rc_state == RC_UNUSED)
			panic("nfsrv cache");
		if (rp->rc_state == RC_INPROG) {
			nfsstats.srvcache_inproghits++;
			ret = RC_DROPIT;
		} else if (rp->rc_flag & RC_REPSTATUS) {
			nfsstats.srvcache_nonidemdonehits++;
			nfs_rephead(0, nd, slp, rp->rc_status, repp, &mb);
			ret = RC_REPLY;
		} else if (rp->rc_flag & RC_REPMBUF) {
			nfsstats.srvcache_nonidemdonehits++;
			*repp = m_copym(rp->rc_reply, 0, M_COPYALL, M_WAIT);
			ret = RC_REPLY;
		} else {
			nfsstats.srvcache_idemdonehits++;
			rp->rc_state = RC_INPROG;
			ret = RC_DOIT;
		}
		rp->rc_flag &= ~RC_LOCKED;
		if (rp->rc_flag & RC_WANTED) {
			rp->rc_flag &= ~RC_WANTED;
			wakeup(rp);
		}
		return (ret);
	}

	nfsstats.srvcache_misses++;
	if (numnfsrvcache < desirednfsrvcache) {
		rp = malloc(sizeof(*rp), M_NFSD, M_WAITOK|M_ZERO);
		numnfsrvcache++;
		rp->rc_flag = RC_LOCKED;
	} else {
		rp = TAILQ_FIRST(&nfsrvlruhead);
		while ((rp->rc_flag & RC_LOCKED) != 0) {
			rp->rc_flag |= RC_WANTED;
			tsleep(rp, PZERO-1, "nfsrc", 0);
			rp = TAILQ_FIRST(&nfsrvlruhead);
		}
		rp->rc_flag |= RC_LOCKED;
		LIST_REMOVE(rp, rc_hash);
		TAILQ_REMOVE(&nfsrvlruhead, rp, rc_lru);
		nfsrv_cleanentry(rp);
		rp->rc_flag &= (RC_LOCKED | RC_WANTED);
	}
	TAILQ_INSERT_TAIL(&nfsrvlruhead, rp, rc_lru);
	rp->rc_state = RC_INPROG;
	rp->rc_xid = nd->nd_retxid;
	saddr = mtod(nd->nd_nam, struct sockaddr_in *);
	switch (saddr->sin_family) {
	case AF_INET:
		rp->rc_flag |= RC_INETADDR;
		rp->rc_inetaddr = saddr->sin_addr.s_addr;
		break;
	default:
		rp->rc_flag |= RC_NAM;
		rp->rc_nam = m_copym(nd->nd_nam, 0, M_COPYALL, M_WAIT);
		break;
	};
	rp->rc_proc = nd->nd_procnum;
	hash = NFSRCHASH(nd->nd_retxid);
	LIST_INSERT_HEAD(hash, rp, rc_hash);
	rp->rc_flag &= ~RC_LOCKED;
	if (rp->rc_flag & RC_WANTED) {
		rp->rc_flag &= ~RC_WANTED;
		wakeup(rp);
	}
	return (RC_DOIT);
}

/* Update a request cache entry after the rpc has been done */
void
nfsrv_updatecache(struct nfsrv_descript *nd, int repvalid,
    struct mbuf *repmbuf)
{
	struct nfsrvcache *rp;

	if (!nd->nd_nam2)
		return;

	rp = nfsrv_lookupcache(nd);
	if (rp) {
		nfsrv_cleanentry(rp);
		rp->rc_state = RC_DONE;
		/*
		 * If we have a valid reply update status and save
		 * the reply for non-idempotent rpc's.
		 */
		if (repvalid && nonidempotent[nd->nd_procnum]) {
			if ((nd->nd_flag & ND_NFSV3) == 0 &&
			  nfsv2_repstat[nfsv2_procid[nd->nd_procnum]]) {
				rp->rc_status = nd->nd_repstat;
				rp->rc_flag |= RC_REPSTATUS;
			} else {
				rp->rc_reply = m_copym(repmbuf, 0, M_COPYALL,
				    M_WAIT);
				rp->rc_flag |= RC_REPMBUF;
			}
		}
		rp->rc_flag &= ~RC_LOCKED;
		if (rp->rc_flag & RC_WANTED) {
			rp->rc_flag &= ~RC_WANTED;
			wakeup(rp);
		}
		return;
	}
}

/* Clean out the cache. Called when the last nfsd terminates. */
void
nfsrv_cleancache(void)
{
	struct nfsrvcache *rp, *nextrp;

	for (rp = TAILQ_FIRST(&nfsrvlruhead); rp != NULL; rp = nextrp) {
		nextrp = TAILQ_NEXT(rp, rc_lru);
		LIST_REMOVE(rp, rc_hash);
		TAILQ_REMOVE(&nfsrvlruhead, rp, rc_lru);
		nfsrv_cleanentry(rp);
		free(rp, M_NFSD, sizeof(*rp));
	}
	numnfsrvcache = 0;
}

struct nfsrvcache *
nfsrv_lookupcache(struct nfsrv_descript *nd)
{
	struct nfsrvhash	*hash;
	struct nfsrvcache	*rp;

	hash = NFSRCHASH(nd->nd_retxid);
loop:
	LIST_FOREACH(rp, hash, rc_hash) {
		if (nd->nd_retxid == rp->rc_xid &&
		    nd->nd_procnum == rp->rc_proc &&
		    netaddr_match(NETFAMILY(rp), &rp->rc_haddr, nd->nd_nam)) {
			if ((rp->rc_flag & RC_LOCKED)) {
				rp->rc_flag |= RC_WANTED;
				tsleep(rp, PZERO - 1, "nfsrc", 0);
				goto loop;
			}
			rp->rc_flag |= RC_LOCKED;
			return (rp);
		}
	}

	return (NULL);
}
@


1.27
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_srvcache.c,v 1.26 2014/11/18 10:42:15 dlg Exp $	*/
d269 1
a269 1
		free(rp, M_NFSD, 0);
@


1.26
log
@use siphash for key lookups in all the filesystem hashes.

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_srvcache.c,v 1.25 2014/09/14 14:17:26 jsg Exp $	*/
a54 1
#include <nfs/rpcv2.h>
@


1.25
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_srvcache.c,v 1.24 2014/07/12 18:43:52 tedu Exp $	*/
d52 2
a67 2
#define	NFSRCHASH(xid)	\
	(&nfsrvhashtbl[((xid) + ((xid) >> 24)) & nfsrvhash])
d69 1
d72 2
d110 1
d132 1
d211 2
a212 1
	LIST_INSERT_HEAD(NFSRCHASH(nd->nd_retxid), rp, rc_hash);
d278 1
d281 1
d283 1
a283 1
	LIST_FOREACH(rp, NFSRCHASH(nd->nd_retxid), rc_hash) {
@


1.24
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_srvcache.c,v 1.23 2009/06/04 18:36:43 thib Exp $	*/
a46 1
#include <sys/proc.h>
@


1.23
log
@Plug mbuf leaks in the DRC, when we reuse entries we didn't
free the mbufs the entry has (socket name, reply).

Found with dlg@@'s amazing mbuf debug diff, fix is based on
the same thing in NetBSD (by yamt@@netbsd.org).

OK blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_srvcache.c,v 1.22 2009/05/30 17:20:29 thib Exp $	*/
d265 1
a265 1
		free(rp, M_NFSD);
@


1.22
log
@Remove unused procnums (NQNFS leftovers) and cleanup.

OK blambert@@ sometime ago
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_srvcache.c,v 1.20 2008/10/20 13:40:19 blambert Exp $	*/
d65 1
d90 12
d189 1
a189 4
		if (rp->rc_flag & RC_REPMBUF)
			m_freem(rp->rc_reply);
		if (rp->rc_flag & RC_NAM)
			m_freem(rp->rc_nam);
d228 1
d264 1
a264 4
		if (rp->rc_flag & RC_REPMBUF)
			m_freem(rp->rc_reply);
		if (rp->rc_flag & RC_NAM)
			m_freem(rp->rc_nam);
@


1.21
log
@Replace the TRUE/FALSE defines with 1/0 respectively. This doesn't
hurt readability and it was just plain annoying seeing them defined
in every other .c file.

OK blambert@@
@
text
@d79 1
a79 2
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0
@


1.20
log
@Be pedantically correct in freeing allocated mbufs, even upon clearing
the server cache on shutdown.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_srvcache.c,v 1.19 2008/07/05 12:45:06 thib Exp $	*/
a71 3
#define	TRUE	1
#define	FALSE	0

d77 4
a80 26
	FALSE,
	FALSE,
	TRUE,
	FALSE,
	FALSE,
	FALSE,
	FALSE,
	TRUE,
	TRUE,
	TRUE,
	TRUE,
	TRUE,
	TRUE,
	TRUE,
	TRUE,
	TRUE,
	FALSE,
	FALSE,
	FALSE,
	FALSE,
	FALSE,
	FALSE,
	FALSE,
	FALSE,
	FALSE,
	FALSE,
d85 3
a87 18
	FALSE,
	FALSE,
	FALSE,
	FALSE,
	FALSE,
	FALSE,
	FALSE,
	FALSE,
	FALSE,
	FALSE,
	TRUE,
	TRUE,
	TRUE,
	TRUE,
	FALSE,
	TRUE,
	FALSE,
	FALSE,
@


1.19
log
@
use m_freem() instead of MFREE() since we ignore the
mbuf that points to the rest of the chain (if it is a
chain).

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_srvcache.c,v 1.18 2008/06/12 20:24:06 blambert Exp $	*/
d294 4
@


1.18
log
@Remove now-vestigial bpos pointer from NFS. For building outgoing
NFS mbufs, mbufs now contain all their internal buffer state internally,
the way god intended.

ok thib@@

testing johan@@ (and possibly merdely@@; this diff's been around for a bit...)
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_srvcache.c,v 1.17 2008/06/11 04:52:27 blambert Exp $	*/
d220 1
a220 1
			MFREE(rp->rc_nam, mb);
@


1.17
log
@Canonical for() -> queue.h FOREACH macro conversions.
Also, it is historical practice to #include <sys/queue.h>
when using queue.h macros.

ok thib@@ krw@@

special thanks to krw@@ for reminders vice violence
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_srvcache.c,v 1.16 2008/04/14 10:39:19 thib Exp $	*/
a159 1
	caddr_t bpos;
d183 1
a183 2
			nfs_rephead(0, nd, slp, rp->rc_status, repp, &mb,
			    &bpos);
@


1.16
log
@move the cache lookup code into a function, instead repeating
it twice, makes this nicer as a bonus;

From NetBSD.

tested by johan@@, ok blambert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_srvcache.c,v 1.15 2007/10/29 11:16:49 thib Exp $	*/
d51 1
@


1.15
log
@Touch of KNF and style(9), spaces and comments.
make pretty.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_srvcache.c,v 1.14 2007/10/28 14:12:41 thib Exp $	*/
d63 2
d168 31
a198 41
loop:
	LIST_FOREACH(rp, NFSRCHASH(nd->nd_retxid), rc_hash) {
	    if (nd->nd_retxid == rp->rc_xid && nd->nd_procnum == rp->rc_proc &&
		netaddr_match(NETFAMILY(rp), &rp->rc_haddr, nd->nd_nam)) {
			if ((rp->rc_flag & RC_LOCKED) != 0) {
				rp->rc_flag |= RC_WANTED;
				tsleep(rp, PZERO-1, "nfsrc", 0);
				goto loop;
			}
			rp->rc_flag |= RC_LOCKED;
			/* If not at end of LRU chain, move it there */
			if (TAILQ_NEXT(rp, rc_lru)) {
				TAILQ_REMOVE(&nfsrvlruhead, rp, rc_lru);
				TAILQ_INSERT_TAIL(&nfsrvlruhead, rp, rc_lru);
			}
			if (rp->rc_state == RC_UNUSED)
				panic("nfsrv cache");
			if (rp->rc_state == RC_INPROG) {
				nfsstats.srvcache_inproghits++;
				ret = RC_DROPIT;
			} else if (rp->rc_flag & RC_REPSTATUS) {
				nfsstats.srvcache_nonidemdonehits++;
				nfs_rephead(0, nd, slp, rp->rc_status,
				   repp, &mb, &bpos);
				ret = RC_REPLY;
			} else if (rp->rc_flag & RC_REPMBUF) {
				nfsstats.srvcache_nonidemdonehits++;
				*repp = m_copym(rp->rc_reply, 0, M_COPYALL,
						M_WAIT);
				ret = RC_REPLY;
			} else {
				nfsstats.srvcache_idemdonehits++;
				rp->rc_state = RC_INPROG;
				ret = RC_DOIT;
			}
			rp->rc_flag &= ~RC_LOCKED;
			if (rp->rc_flag & RC_WANTED) {
				rp->rc_flag &= ~RC_WANTED;
				wakeup(rp);
			}
			return (ret);
d200 1
d202 1
d257 17
a273 8
loop:
	LIST_FOREACH(rp, NFSRCHASH(nd->nd_retxid), rc_hash) {
	    if (nd->nd_retxid == rp->rc_xid && nd->nd_procnum == rp->rc_proc &&
		netaddr_match(NETFAMILY(rp), &rp->rc_haddr, nd->nd_nam)) {
			if ((rp->rc_flag & RC_LOCKED) != 0) {
				rp->rc_flag |= RC_WANTED;
				tsleep(rp, PZERO-1, "nfsrc", 0);
				goto loop;
a274 23
			rp->rc_flag |= RC_LOCKED;
			rp->rc_state = RC_DONE;
			/*
			 * If we have a valid reply update status and save
			 * the reply for non-idempotent rpc's.
			 */
			if (repvalid && nonidempotent[nd->nd_procnum]) {
				if ((nd->nd_flag & ND_NFSV3) == 0 &&
				  nfsv2_repstat[nfsv2_procid[nd->nd_procnum]]) {
					rp->rc_status = nd->nd_repstat;
					rp->rc_flag |= RC_REPSTATUS;
				} else {
					rp->rc_reply = m_copym(repmbuf,
						0, M_COPYALL, M_WAIT);
					rp->rc_flag |= RC_REPMBUF;
				}
			}
			rp->rc_flag &= ~RC_LOCKED;
			if (rp->rc_flag & RC_WANTED) {
				rp->rc_flag &= ~RC_WANTED;
				wakeup(rp);
			}
			return;
d276 6
d298 23
@


1.14
log
@Remove the "frev" argument from nfs_rephead(); and clean up the "frev"
variables, that are declared all over, since they are passed via macros
to nfs_rephead(); which doesn't do anything with it.

OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_srvcache.c,v 1.13 2007/09/20 12:54:31 thib Exp $	*/
a43 1
#include <sys/vnode.h>
a50 1
#include <sys/socketvar.h>
a52 1
#include <nfs/nfsm_subs.h>
d63 1
a63 1
#define	NFSRCHASH(xid) \
d69 1
a69 1
#define TRUE	1
d72 2
a73 2
#define	NETFAMILY(rp) \
		(((rp)->rc_flag & RC_INETADDR) ? AF_INET : AF_UNSPEC)
d75 1
a75 3
/*
 * Static array that defines which nfs rpc's are nonidempotent
 */
d106 1
a106 1
static int nfsv2_repstat[NFS_NPROCS] = {
d127 1
a127 3
/*
 * Initialize the server request cache list
 */
d129 1
a129 1
nfsrv_initcache()
d151 2
a152 4
nfsrv_getcache(nd, slp, repp)
	struct nfsrv_descript *nd;
	struct nfssvc_sock *slp;
	struct mbuf **repp;
d172 1
a172 1
				(void) tsleep((caddr_t)rp, PZERO-1, "nfsrc", 0);
d204 1
a204 1
				wakeup((caddr_t)rp);
d218 1
a218 1
			(void) tsleep((caddr_t)rp, PZERO-1, "nfsrc", 0);
d249 1
a249 1
		wakeup((caddr_t)rp);
d254 1
a254 3
/*
 * Update a request cache entry after the rpc has been done
 */
d256 2
a257 4
nfsrv_updatecache(nd, repvalid, repmbuf)
	struct nfsrv_descript *nd;
	int repvalid;
	struct mbuf *repmbuf;
d269 1
a269 1
				(void) tsleep((caddr_t)rp, PZERO-1, "nfsrc", 0);
d292 1
a292 1
				wakeup((caddr_t)rp);
d299 1
a299 3
/*
 * Clean out the cache. Called when the last nfsd terminates.
 */
d301 1
a301 1
nfsrv_cleancache()
@


1.13
log
@MALLOC/FREE -> malloc/free + M_ZERO.
Uneeded includes and casts...

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_srvcache.c,v 1.12 2004/12/26 21:22:14 miod Exp $	*/
d198 1
a198 1
				   (u_quad_t *)0, repp, &mb, &bpos);
@


1.12
log
@Use list and queue macros where applicable to make the code easier to read;
no change in compiler assembly output.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_srvcache.c,v 1.11 2004/07/16 15:01:51 henning Exp $	*/
d220 1
a220 3
		rp = (struct nfsrvcache *)malloc((u_long)sizeof *rp,
		    M_NFSD, M_WAITOK);
		bzero((char *)rp, sizeof *rp);
@


1.11
log
@kill netiso stuff here as well, millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_srvcache.c,v 1.10 2003/06/02 23:28:19 millert Exp $	*/
d176 1
a176 2
	for (rp = NFSRCHASH(nd->nd_retxid)->lh_first; rp != NULL;
	    rp = LIST_NEXT(rp, rc_hash)) {
d279 1
a279 2
	for (rp = NFSRCHASH(nd->nd_retxid)->lh_first; rp != NULL;
	    rp = LIST_NEXT(rp, rc_hash)) {
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_srvcache.c,v 1.9 2002/07/03 20:57:00 nate Exp $	*/
a54 3
#ifdef ISO
#include <netiso/iso.h>
#endif
d76 1
a76 1
		(((rp)->rc_flag & RC_INETADDR) ? AF_INET : AF_ISO)
a250 1
	case AF_ISO:
@


1.9
log
@Remove unused function parameter 'cache' from nfs_rephead
ok costa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_srvcache.c,v 1.8 2002/01/16 21:51:16 ericj Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.8
log
@
use queue.h macro's
remove register
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_srvcache.c,v 1.7 2001/06/25 03:28:09 csapuntz Exp $	*/
d206 1
a206 1
				   0, (u_quad_t *)0, repp, &mb, &bpos);
@


1.7
log
@Remove NQNFS
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_srvcache.c,v 1.6 1999/04/28 09:28:17 art Exp $	*/
d166 1
a166 1
	register struct nfsrv_descript *nd;
d170 1
a170 1
	register struct nfsrvcache *rp;
d183 2
a184 2
	for (rp = NFSRCHASH(nd->nd_retxid)->lh_first; rp != 0;
	    rp = rp->rc_hash.le_next) {
d194 1
a194 1
			if (rp->rc_lru.tqe_next) {
d234 1
a234 1
		rp = nfsrvlruhead.tqh_first;
d238 1
a238 1
			rp = nfsrvlruhead.tqh_first;
d279 1
a279 1
	register struct nfsrv_descript *nd;
d283 1
a283 1
	register struct nfsrvcache *rp;
d288 2
a289 2
	for (rp = NFSRCHASH(nd->nd_retxid)->lh_first; rp != 0;
	    rp = rp->rc_hash.le_next) {
d330 1
a330 1
	register struct nfsrvcache *rp, *nextrp;
d332 2
a333 2
	for (rp = nfsrvlruhead.tqh_first; rp != 0; rp = nextrp) {
		nextrp = rp->rc_lru.tqe_next;
@


1.7.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_srvcache.c,v 1.8 2002/01/16 21:51:16 ericj Exp $	*/
d166 1
a166 1
	struct nfsrv_descript *nd;
d170 1
a170 1
	struct nfsrvcache *rp;
d183 2
a184 2
	for (rp = NFSRCHASH(nd->nd_retxid)->lh_first; rp != NULL;
	    rp = LIST_NEXT(rp, rc_hash)) {
d194 1
a194 1
			if (TAILQ_NEXT(rp, rc_lru)) {
d234 1
a234 1
		rp = TAILQ_FIRST(&nfsrvlruhead);
d238 1
a238 1
			rp = TAILQ_FIRST(&nfsrvlruhead);
d279 1
a279 1
	struct nfsrv_descript *nd;
d283 1
a283 1
	struct nfsrvcache *rp;
d288 2
a289 2
	for (rp = NFSRCHASH(nd->nd_retxid)->lh_first; rp != NULL;
	    rp = LIST_NEXT(rp, rc_hash)) {
d330 1
a330 1
	struct nfsrvcache *rp, *nextrp;
d332 2
a333 2
	for (rp = TAILQ_FIRST(&nfsrvlruhead); rp != NULL; rp = nextrp) {
		nextrp = TAILQ_NEXT(rp, rc_lru);
@


1.7.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_srvcache.c,v 1.7.4.1 2002/01/31 22:55:47 niklas Exp $	*/
d206 1
a206 1
				   (u_quad_t *)0, repp, &mb, &bpos);
@


1.6
log
@zap the newhashinit hack.
Add an extra flag to hashinit telling if it should wait in malloc.
update all calls to hashinit.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_srvcache.c,v 1.5 1996/04/21 22:30:28 deraadt Exp $	*/
a66 1
#include <nfs/nqnfs.h>
@


1.6.4.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_srvcache.c,v 1.6 1999/04/28 09:28:17 art Exp $	*/
d67 1
@


1.6.4.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d166 1
a166 1
	struct nfsrv_descript *nd;
d170 1
a170 1
	struct nfsrvcache *rp;
d183 2
a184 2
	for (rp = NFSRCHASH(nd->nd_retxid)->lh_first; rp != NULL;
	    rp = LIST_NEXT(rp, rc_hash)) {
d194 1
a194 1
			if (TAILQ_NEXT(rp, rc_lru)) {
d234 1
a234 1
		rp = TAILQ_FIRST(&nfsrvlruhead);
d238 1
a238 1
			rp = TAILQ_FIRST(&nfsrvlruhead);
d279 1
a279 1
	struct nfsrv_descript *nd;
d283 1
a283 1
	struct nfsrvcache *rp;
d288 2
a289 2
	for (rp = NFSRCHASH(nd->nd_retxid)->lh_first; rp != NULL;
	    rp = LIST_NEXT(rp, rc_hash)) {
d330 1
a330 1
	struct nfsrvcache *rp, *nextrp;
d332 2
a333 2
	for (rp = TAILQ_FIRST(&nfsrvlruhead); rp != NULL; rp = nextrp) {
		nextrp = TAILQ_NEXT(rp, rc_lru);
@


1.6.4.3
log
@Sync the SMP branch with 3.3
@
text
@d206 1
a206 1
				   (u_quad_t *)0, repp, &mb, &bpos);
@


1.6.4.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_srvcache.c,v 1.6.4.3 2003/03/28 00:08:46 niklas Exp $	*/
d19 5
a23 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.5
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_srvcache.c,v 1.4 1996/04/17 04:50:30 mickey Exp $	*/
d147 1
a147 1
	nfsrvhashtbl = hashinit(desirednfsrvcache, M_NFSD, &nfsrvhash);
@


1.4
log
@Minor cleanups. Checked against Lite2.
(NetBSD's was really just a Lite2's, but w/ 64bit support)
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_srvcache.c,v 1.3 1996/03/31 13:15:50 mickey Exp $	*/
d207 1
a207 1
				   0, (u_quad_t *)NULL, repp, &mb, &bpos);
@


1.3
log
@From NetBSD: NFSv3 import (tomorrow's Net's kernel)
Open's patches kept in. i'll possibly take a look at Lite2 soon,
is there smth usefull ?..
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_srvcache.c,v 1.2 1996/02/29 09:24:55 niklas Exp $	*/
d207 1
a207 1
				   0, (u_quad_t *)0, repp, &mb, &bpos);
@


1.2
log
@From NetBSD: merge with 960217 (still NFSv2)
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: nfs_srvcache.c,v 1.11 1996/02/09 21:48:32 christos Exp $	*/
d39 1
a39 1
 *	@@(#)nfs_srvcache.c	8.2 (Berkeley) 8/18/94
d64 1
a64 1
#include <nfs/nfsv2.h>
d70 2
a96 1
	FALSE,
d105 4
d119 1
a119 1
static int repliesstatus[NFS_NPROCS] = {
a137 5
	FALSE,
	FALSE,
	FALSE,
	FALSE,
	TRUE,
d166 3
a168 3
nfsrv_getcache(nam, nd, repp)
	struct mbuf *nam;
	register struct nfsd *nd;
d177 5
a181 1
	if (nd->nd_nqlflag != NQL_NOVAL)
d187 1
a187 1
		netaddr_match(NETFAMILY(rp), &rp->rc_haddr, nam)) {
d206 1
a206 1
				nfs_rephead(0, nd, rp->rc_status,
d253 1
a253 1
	saddr = mtod(nam, struct sockaddr_in *);
d262 1
a262 1
		rp->rc_nam = m_copym(nam, 0, M_COPYALL, M_WAIT);
d279 2
a280 3
nfsrv_updatecache(nam, nd, repvalid, repmbuf)
	struct mbuf *nam;
	register struct nfsd *nd;
d286 1
a286 1
	if (nd->nd_nqlflag != NQL_NOVAL)
d292 1
a292 1
		netaddr_match(NETFAMILY(rp), &rp->rc_haddr, nam)) {
d305 2
a306 1
				if (repliesstatus[nd->nd_procnum]) {
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: nfs_srvcache.c,v 1.10 1994/12/13 17:17:03 mycroft Exp $	*/
d68 1
d143 1
d165 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
