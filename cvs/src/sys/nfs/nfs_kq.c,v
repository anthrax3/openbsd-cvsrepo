head	1.22;
access;
symbols
	OPENBSD_6_2:1.22.0.14
	OPENBSD_6_2_BASE:1.22
	OPENBSD_6_1:1.22.0.12
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.22.0.8
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.4
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.22.0.6
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.21.0.2
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.16.0.8
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.4
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.2
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.15.0.16
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.14
	OPENBSD_5_0:1.15.0.12
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.10
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.8
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.4
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.6
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.2
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.12.0.2
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.10.0.2
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.9.0.2
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.2.0.6
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.4
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.2
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.1.0.6
	OPENBSD_3_8_BASE:1.1
	OPENBSD_3_7:1.1.0.4
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.2
	OPENBSD_3_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.22
date	2014.11.15.00.03.12;	author tedu;	state Exp;
branches;
next	1.21;
commitid	DARBwcixOE2oqaWx;

1.21
date	2014.08.06.19.31.30;	author guenther;	state Exp;
branches;
next	1.20;
commitid	L7DFwsMrSM5j5JKv;

1.20
date	2014.07.12.18.43.52;	author tedu;	state Exp;
branches;
next	1.19;
commitid	FE3DG5cICjyI4jWx;

1.19
date	2014.07.08.17.19.26;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	EF98ch02VpFassUi;

1.18
date	2014.06.15.11.43.24;	author sf;	state Exp;
branches;
next	1.17;
commitid	Y0AWLKcfCeF28jP4;

1.17
date	2014.03.28.17.57.11;	author mpi;	state Exp;
branches;
next	1.16;

1.16
date	2012.12.05.23.20.23;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2009.01.19.23.40.36;	author thib;	state Exp;
branches;
next	1.14;

1.14
date	2008.09.11.16.06.01;	author thib;	state Exp;
branches;
next	1.13;

1.13
date	2008.08.20.12.08.04;	author thib;	state Exp;
branches;
next	1.12;

1.12
date	2008.06.26.05.42.20;	author ray;	state Exp;
branches;
next	1.11;

1.11
date	2008.06.11.04.52.27;	author blambert;	state Exp;
branches;
next	1.10;

1.10
date	2007.09.20.12.54.31;	author thib;	state Exp;
branches;
next	1.9;

1.9
date	2007.06.01.23.47.57;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2007.05.31.20.29.23;	author thib;	state Exp;
branches;
next	1.7;

1.7
date	2007.05.29.00.17.32;	author thib;	state Exp;
branches;
next	1.6;

1.6
date	2007.05.28.21.47.50;	author thib;	state Exp;
branches;
next	1.5;

1.5
date	2007.05.17.23.46.28;	author thib;	state Exp;
branches;
next	1.4;

1.4
date	2007.04.19.14.46.44;	author thib;	state Exp;
branches;
next	1.3;

1.3
date	2007.04.12.18.21.19;	author thib;	state Exp;
branches;
next	1.2;

1.2
date	2005.11.19.02.18.01;	author pedro;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.21.17.30.56;	author marius;	state Exp;
branches;
next	;


desc
@@


1.22
log
@add sizes for free(ptr, sizeof(*ptr)). use sizeof(*ptr) for malloc sizes.
@
text
@/*	$OpenBSD: nfs_kq.c,v 1.21 2014/08/06 19:31:30 guenther Exp $ */
/*	$NetBSD: nfs_kq.c,v 1.7 2003/10/30 01:43:10 simonb Exp $	*/

/*-
 * Copyright (c) 2002 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jaromir Dolecek.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/mount.h>
#include <sys/malloc.h>
#include <sys/vnode.h>
#include <sys/unistd.h>
#include <sys/file.h>
#include <sys/kthread.h>
#include <sys/rwlock.h>
#include <sys/queue.h>

#include <nfs/rpcv2.h>
#include <nfs/nfsproto.h>
#include <nfs/nfs.h>
#include <nfs/nfsnode.h>
#include <nfs/nfs_var.h>

void	nfs_kqpoll(void *);

void	filt_nfsdetach(struct knote *);
int	filt_nfsread(struct knote *, long);
int	filt_nfsvnode(struct knote *, long);

struct kevq {
	SLIST_ENTRY(kevq)	kev_link;
	struct vnode		*vp;
	u_int			usecount;
	u_int			flags;
#define KEVQ_BUSY	0x01	/* currently being processed */
#define KEVQ_WANT	0x02	/* want to change this entry */
	struct timespec		omtime;	/* old modification time */
	struct timespec		octime;	/* old change time */
	nlink_t			onlink;	/* old number of references to file */
};
SLIST_HEAD(kevqlist, kevq);

struct rwlock nfskevq_lock = RWLOCK_INITIALIZER("nfskqlk");
struct proc *pnfskq;
struct kevqlist kevlist = SLIST_HEAD_INITIALIZER(kevlist);

/*
 * This quite simplistic routine periodically checks for server changes
 * of any of the watched files every NFS_MINATTRTIMO/2 seconds.
 * Only changes in size, modification time, change time and nlinks
 * are being checked, everything else is ignored.
 * The routine only calls VOP_GETATTR() when it's likely it would get
 * some new data, i.e. when the vnode expires from attrcache. This
 * should give same result as periodically running stat(2) from userland,
 * while keeping CPU/network usage low, and still provide proper kevent
 * semantics.
 * The poller thread is created when first vnode is added to watch list,
 * and exits when the watch list is empty. The overhead of thread creation
 * isn't really important, neither speed of attach and detach of knote.
 */
/* ARGSUSED */
void
nfs_kqpoll(void *arg)
{
	struct kevq *ke;
	struct vattr attr;
	struct proc *p = pnfskq;
	u_quad_t osize;
	int error;

	for(;;) {
		rw_enter_write(&nfskevq_lock);
		SLIST_FOREACH(ke, &kevlist, kev_link) {
			struct nfsnode *np = VTONFS(ke->vp);

#ifdef DEBUG
			printf("nfs_kqpoll on: ");
			VOP_PRINT(ke->vp);
#endif
			/* skip if still in attrcache */
			if (nfs_getattrcache(ke->vp, &attr) != ENOENT)
				continue;

			/*
			 * Mark entry busy, release lock and check
			 * for changes.
			 */
			ke->flags |= KEVQ_BUSY;
			rw_exit_write(&nfskevq_lock);

			/* save v_size, nfs_getattr() updates it */
			osize = np->n_size;

			error = VOP_GETATTR(ke->vp, &attr, p->p_ucred, p);
			if (error == ESTALE) {
				NFS_INVALIDATE_ATTRCACHE(np);
				VN_KNOTE(ke->vp, NOTE_DELETE);
				goto next;
			}

			/* following is a bit fragile, but about best
			 * we can get */
			if (attr.va_size != osize) {
				int flags = NOTE_WRITE;

				if (attr.va_size > osize)
					flags |= NOTE_EXTEND;
				else
					flags |= NOTE_TRUNCATE;

				VN_KNOTE(ke->vp, flags);
				ke->omtime = attr.va_mtime;
			} else if (attr.va_mtime.tv_sec != ke->omtime.tv_sec
			    || attr.va_mtime.tv_nsec != ke->omtime.tv_nsec) {
				VN_KNOTE(ke->vp, NOTE_WRITE);
				ke->omtime = attr.va_mtime;
			}

			if (attr.va_ctime.tv_sec != ke->octime.tv_sec
			    || attr.va_ctime.tv_nsec != ke->octime.tv_nsec) {
				VN_KNOTE(ke->vp, NOTE_ATTRIB);
				ke->octime = attr.va_ctime;
			}

			if (attr.va_nlink != ke->onlink) {
				VN_KNOTE(ke->vp, NOTE_LINK);
				ke->onlink = attr.va_nlink;
			}

next:
			rw_enter_write(&nfskevq_lock);
			ke->flags &= ~KEVQ_BUSY;
			if (ke->flags & KEVQ_WANT) {
				ke->flags &= ~KEVQ_WANT;
				wakeup(ke);
			}
		}

		if (SLIST_EMPTY(&kevlist)) {
			/* Nothing more to watch, exit */
			pnfskq = NULL;
			rw_exit_write(&nfskevq_lock);
			kthread_exit(0);
		}
		rw_exit_write(&nfskevq_lock);

		/* wait a while before checking for changes again */
		tsleep(pnfskq, PSOCK, "nfskqpw", NFS_MINATTRTIMO * hz / 2);

	}
}

void
filt_nfsdetach(struct knote *kn)
{
	struct vnode *vp = (struct vnode *)kn->kn_hook;
	struct kevq *ke;

	SLIST_REMOVE(&vp->v_selectinfo.si_note, kn, knote, kn_selnext);

	/* Remove the vnode from watch list */
	rw_enter_write(&nfskevq_lock);
	SLIST_FOREACH(ke, &kevlist, kev_link) {
		if (ke->vp == vp) {
			while (ke->flags & KEVQ_BUSY) {
				ke->flags |= KEVQ_WANT;
				rw_exit_write(&nfskevq_lock);
				(void) tsleep(ke, PSOCK, "nfskqdet", 0);
				rw_enter_write(&nfskevq_lock);
			}

			if (ke->usecount > 1) {
				/* keep, other kevents need this */
				ke->usecount--;
			} else {
				/* last user, g/c */
				SLIST_REMOVE(&kevlist, ke, kevq, kev_link);
				free(ke, M_KEVENT, sizeof(*ke));
			}
			break;
		}
	}
	rw_exit_write(&nfskevq_lock);
}

int
filt_nfsread(struct knote *kn, long hint)
{
	struct vnode *vp = (struct vnode *)kn->kn_hook;
	struct nfsnode *np = VTONFS(vp);

	/*
	 * filesystem is gone, so set the EOF flag and schedule
	 * the knote for deletion.
	 */
	if (hint == NOTE_REVOKE) {
		kn->kn_flags |= (EV_EOF | EV_ONESHOT);
		return (1);
	}

	kn->kn_data = np->n_size - kn->kn_fp->f_offset;
#ifdef DEBUG
	printf("nfsread event. %lld\n", kn->kn_data);
#endif
	if (kn->kn_data == 0 && kn->kn_sfflags & NOTE_EOF) {
		kn->kn_fflags |= NOTE_EOF;
		return (1);
	}
        return (kn->kn_data != 0);
}

int
filt_nfsvnode(struct knote *kn, long hint)
{
	if (kn->kn_sfflags & hint)
		kn->kn_fflags |= hint;
	if (hint == NOTE_REVOKE) {
		kn->kn_flags |= EV_EOF;
		return (1);
	}
	return (kn->kn_fflags != 0);
}

static const struct filterops nfsread_filtops = 
	{ 1, NULL, filt_nfsdetach, filt_nfsread };
static const struct filterops nfsvnode_filtops = 
	{ 1, NULL, filt_nfsdetach, filt_nfsvnode };

int
nfs_kqfilter(void *v)
{
	struct vop_kqfilter_args *ap = v;
	struct vnode *vp;
	struct knote *kn;
	struct kevq *ke;
	int error = 0;
	struct vattr attr;
	struct proc *p = curproc;	/* XXX */

	vp = ap->a_vp;
	kn = ap->a_kn;

#ifdef DEBUG
	printf("nfs_kqfilter(%d) on: ", kn->kn_filter);
	VOP_PRINT(vp);
#endif

	switch (kn->kn_filter) {
	case EVFILT_READ:
		kn->kn_fop = &nfsread_filtops;
		break;
	case EVFILT_VNODE:
		kn->kn_fop = &nfsvnode_filtops;
		break;
	default:
		return (EINVAL);
	}

	kn->kn_hook = vp;

	/*
	 * Put the vnode to watched list.
	 */
	
	/*
	 * Fetch current attributes. It's only needed when the vnode
	 * is not watched yet, but we need to do this without lock
	 * held. This is likely cheap due to attrcache, so do it now.
	 */ 
	memset(&attr, 0, sizeof(attr));
	(void) VOP_GETATTR(vp, &attr, p->p_ucred, p);

	rw_enter_write(&nfskevq_lock);

	/* ensure the poller is running */
	if (!pnfskq) {
		error = kthread_create(nfs_kqpoll, NULL, &pnfskq,
				"nfskqpoll");
		if (error)
			goto out;
	}

	SLIST_FOREACH(ke, &kevlist, kev_link)
		if (ke->vp == vp)
			break;

	if (ke) {
		/* already watched, so just bump usecount */
		ke->usecount++;
	} else {
		/* need a new one */
		ke = malloc(sizeof(*ke), M_KEVENT, M_WAITOK);
		ke->vp = vp;
		ke->usecount = 1;
		ke->flags = 0;
		ke->omtime = attr.va_mtime;
		ke->octime = attr.va_ctime;
		ke->onlink = attr.va_nlink;
		SLIST_INSERT_HEAD(&kevlist, ke, kev_link);
	}

	/* kick the poller */
	wakeup(pnfskq);

	SLIST_INSERT_HEAD(&vp->v_selectinfo.si_note, kn, kn_selnext);

out:
	rw_exit_write(&nfskevq_lock);
	return (error);
}
@


1.21
log
@Support NOTE_EOF for kqueue EVFILT_READ filters on NFS files.

committing for jsg@@,  ok reyk@@ tedu@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_kq.c,v 1.20 2014/07/12 18:43:52 tedu Exp $ */
d206 1
a206 1
				free(ke, M_KEVENT, 0);
d320 1
a320 1
		ke = malloc(sizeof(struct kevq), M_KEVENT, M_WAITOK);
@


1.20
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_kq.c,v 1.19 2014/07/08 17:19:26 deraadt Exp $ */
d233 4
@


1.19
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_kq.c,v 1.18 2014/06/15 11:43:24 sf Exp $ */
d206 1
a206 1
				free(ke, M_KEVENT);
@


1.18
log
@Fix a few format string bugs with -DDEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_kq.c,v 1.17 2014/03/28 17:57:11 mpi Exp $ */
a44 2

#include <uvm/uvm_extern.h>
@


1.17
log
@Reduce uvm include madness.  Use <uvm/uvm_extern.h> instead of
<uvm/uvm.h> if possible and remove double inclusions.

ok beck@@, mlarkin@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_kq.c,v 1.16 2012/12/05 23:20:23 deraadt Exp $ */
d233 1
a233 1
	printf("nfsread event. %d\n", kn->kn_data);
@


1.16
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_kq.c,v 1.15 2009/01/19 23:40:36 thib Exp $ */
a46 1
#include <uvm/uvm.h>
@


1.15
log
@Introduce a macro to invalidate the attribute
cache instead of setting n_attrstamp to 0 directly.

Lift the macro name from NetBSD.
prompted by and OK blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_kq.c,v 1.14 2008/09/11 16:06:01 thib Exp $ */
a31 2

#include <sys/cdefs.h>
@


1.14
log
@
issue a NOTE_TRUNCATE if the file size has shrinked

ok tedu@@, blambert@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_kq.c,v 1.13 2008/08/20 12:08:04 thib Exp $ */
d129 1
a129 1
				np->n_attrstamp = 0;
@


1.13
log
@Return EINVAL instead of '1' for invalid kq filters.

From NetBSD;
OK art@@, blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_kq.c,v 1.12 2008/06/26 05:42:20 ray Exp $ */
d137 8
a144 3
				int extended = (attr.va_size > osize);
				VN_KNOTE(ke->vp, NOTE_WRITE
				    | (extended ? NOTE_EXTEND : 0));
@


1.12
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_kq.c,v 1.11 2008/06/11 04:52:27 blambert Exp $ */
d280 1
a280 1
		return (1);
@


1.11
log
@Canonical for() -> queue.h FOREACH macro conversions.
Also, it is historical practice to #include <sys/queue.h>
when using queue.h macros.

ok thib@@ krw@@

special thanks to krw@@ for reminders vice violence
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_kq.c,v 1.10 2007/09/20 12:54:31 thib Exp $ */
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.10
log
@MALLOC/FREE -> malloc/free + M_ZERO.
Uneeded includes and casts...

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_kq.c,v 1.9 2007/06/01 23:47:57 deraadt Exp $ */
d53 1
@


1.9
log
@pedro ok'd this ~3500 line diff which removes the vop argument
"ap = v" comments in under 8 seconds, so it must be ok.  and it compiles
too.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_kq.c,v 1.8 2007/05/31 20:29:23 thib Exp $ */
d212 1
a212 1
				FREE(ke, M_KEVENT);
d322 1
a322 2
		MALLOC(ke, struct kevq *,
		    sizeof(struct kevq), M_KEVENT, M_WAITOK);
@


1.8
log
@kill some ifdef noyet code, de-static functions (makes my traces nicer),
some comments and style.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_kq.c,v 1.7 2007/05/29 00:17:32 thib Exp $ */
d262 1
a262 4
	struct vop_kqfilter_args /* {
		struct vnode	*a_vp;
		struct knote	*a_kn;
	} */ *ap = v;
@


1.7
log
@Add a name argument to the RWLOCK_INITIALIZER macro.
Pick reasonble names for the locks involved..

ok tedu@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_kq.c,v 1.6 2007/05/28 21:47:50 thib Exp $ */
d63 6
d83 2
a84 2
static struct proc *pnfskq;
static struct kevqlist kevlist = SLIST_HEAD_INITIALIZER(kevlist);
d101 1
a101 1
static void
d182 1
a182 2
		tsleep(pnfskq, PSOCK, "nfskqpw",
			NFS_MINATTRTIMO * hz / 2);
d187 1
a187 1
static void
a192 5
#ifdef notyet
	/* XXXLUKEM lock the struct? */
	SLIST_REMOVE(&vp->v_klist, kn, knote, kn_selnext);
#endif

d220 1
a220 1
static int
a234 2
	/* XXXLUKEM lock the struct? */

d242 1
a242 1
static int
a339 5

#ifdef notyet
	/* XXXLUKEM lock the struct? */
	SLIST_INSERT_HEAD(&vp->v_klist, kn, kn_selnext);
#endif
@


1.6
log
@zap annoying __KERNEL_RCSID().

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_kq.c,v 1.5 2007/05/17 23:46:28 thib Exp $ */
d76 1
a76 1
struct rwlock nfskevq_lock = RWLOCK_INITIALIZER;
@


1.5
log
@Collapse struct v_selectinfo in struct vnode, remove the
simplelock and reuse the name for the selinfo member.
Clean-up accordingly.

ok tedu@@,art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_kq.c,v 1.4 2007/04/19 14:46:44 thib Exp $ */
a40 3
#ifdef __NetBSD__
__KERNEL_RCSID(0, "$NetBSD: nfs_kq.c,v 1.7 2003/10/30 01:43:10 simonb Exp $");
#endif /* __NetBSD__ */
@


1.4
log
@Replace the nfskevq_lock lockmgr lock with rwlock.
Replace nfs_kqinit() wich just calls lockinit with
RWLOCK_INITALIZER. Assorted cleanup.

ok tedu@@
"reads good" art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_kq.c,v 1.3 2007/04/12 18:21:19 thib Exp $ */
d196 1
a196 4
	simple_lock(&vp->v_selectinfo.vsi_lock);
	SLIST_REMOVE(&vp->v_selectinfo.vsi_selinfo.si_note,
	    kn, knote, kn_selnext);
	simple_unlock(&vp->v_selectinfo.vsi_lock);
d344 1
a344 3
	simple_lock(&vp->v_selectinfo.vsi_lock);
        SLIST_INSERT_HEAD(&vp->v_selectinfo.vsi_selinfo.si_note, kn, kn_selnext);
        simple_unlock(&vp->v_selectinfo.vsi_lock);
@


1.3
log
@If VOP_GETATTR() in the nfs_kqpoll() loop returns ESTALE, catch it.
Not doing so can lead to clients missing out if the file is for
example removed on the server and the client is doing a 'tail -f' on it.
If it returns ESTALE, mark the file deleted and proceed to handling the
next entry.

ok tedu@@,art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_kq.c,v 1.2 2005/11/19 02:18:01 pedro Exp $ */
d55 1
d79 1
a79 1
static struct lock nfskevq_lock;
a82 6
void
nfs_kqinit(void)
{
	lockinit(&nfskevq_lock, PSOCK, "nfskqlck", 0, 0);
}

d108 1
a108 1
		lockmgr(&nfskevq_lock, LK_EXCLUSIVE, NULL);
d125 1
a125 1
			lockmgr(&nfskevq_lock, LK_RELEASE, NULL);
d162 1
a162 1
			lockmgr(&nfskevq_lock, LK_EXCLUSIVE, NULL);
d173 1
a173 1
			lockmgr(&nfskevq_lock, LK_RELEASE, NULL);
d176 1
a176 1
		lockmgr(&nfskevq_lock, LK_RELEASE, NULL);
d202 1
a202 1
	lockmgr(&nfskevq_lock, LK_EXCLUSIVE, NULL);
d207 1
a207 1
				lockmgr(&nfskevq_lock, LK_RELEASE, NULL);
d209 1
a209 1
				lockmgr(&nfskevq_lock, LK_EXCLUSIVE, NULL);
d223 1
a223 1
	lockmgr(&nfskevq_lock, LK_RELEASE, NULL);
d314 1
a314 1
	lockmgr(&nfskevq_lock, LK_EXCLUSIVE, NULL);
d356 2
a357 3
    out:
	lockmgr(&nfskevq_lock, LK_RELEASE, NULL);

@


1.2
log
@Remove unnecessary lockmgr() archaism that was costing too much in terms
of panics and bugfixes. Access curproc directly, do not expect a process
pointer as an argument. Should fix many "process context required" bugs.
Incentive and okay millert@@, okay marc@@. Various testing, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_kq.c,v 1.1 2004/07/21 17:30:56 marius Exp $ */
d110 1
d135 6
a140 1
			(void) VOP_GETATTR(ke->vp, &attr, p->p_ucred, p);
d166 1
@


1.1
log
@kqueue support for NFS, adapted from netbsd.

ok art@@ pedro@@, "get it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d112 1
a112 1
		lockmgr(&nfskevq_lock, LK_EXCLUSIVE, NULL, p);
d129 1
a129 1
			lockmgr(&nfskevq_lock, LK_RELEASE, NULL, p);
d160 1
a160 1
			lockmgr(&nfskevq_lock, LK_EXCLUSIVE, NULL, p);
d171 1
a171 1
			lockmgr(&nfskevq_lock, LK_RELEASE, NULL, p);
d174 1
a174 1
		lockmgr(&nfskevq_lock, LK_RELEASE, NULL, p);
a187 1
	struct proc *p = curproc;
d200 1
a200 1
	lockmgr(&nfskevq_lock, LK_EXCLUSIVE, NULL, p);
d205 1
a205 1
				lockmgr(&nfskevq_lock, LK_RELEASE, NULL, p);
d207 1
a207 1
				lockmgr(&nfskevq_lock, LK_EXCLUSIVE, NULL, p);
d221 1
a221 1
	lockmgr(&nfskevq_lock, LK_RELEASE, NULL, p);
d312 1
a312 1
	lockmgr(&nfskevq_lock, LK_EXCLUSIVE, NULL, p);
d355 1
a355 1
	lockmgr(&nfskevq_lock, LK_RELEASE, NULL, p);
@

