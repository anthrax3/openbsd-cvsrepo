head	1.113;
access;
symbols
	OPENBSD_6_1:1.113.0.4
	OPENBSD_6_1_BASE:1.113
	OPENBSD_6_0:1.109.0.2
	OPENBSD_6_0_BASE:1.109
	OPENBSD_5_9:1.107.0.2
	OPENBSD_5_9_BASE:1.107
	OPENBSD_5_8:1.107.0.4
	OPENBSD_5_8_BASE:1.107
	OPENBSD_5_7:1.106.0.2
	OPENBSD_5_7_BASE:1.106
	OPENBSD_5_6:1.100.0.4
	OPENBSD_5_6_BASE:1.100
	OPENBSD_5_5:1.99.0.4
	OPENBSD_5_5_BASE:1.99
	OPENBSD_5_4:1.97.0.2
	OPENBSD_5_4_BASE:1.97
	OPENBSD_5_3:1.95.0.2
	OPENBSD_5_3_BASE:1.95
	OPENBSD_5_2:1.93.0.6
	OPENBSD_5_2_BASE:1.93
	OPENBSD_5_1_BASE:1.93
	OPENBSD_5_1:1.93.0.4
	OPENBSD_5_0:1.93.0.2
	OPENBSD_5_0_BASE:1.93
	OPENBSD_4_9:1.92.0.6
	OPENBSD_4_9_BASE:1.92
	OPENBSD_4_8:1.92.0.4
	OPENBSD_4_8_BASE:1.92
	OPENBSD_4_7:1.92.0.2
	OPENBSD_4_7_BASE:1.92
	OPENBSD_4_6:1.83.0.4
	OPENBSD_4_6_BASE:1.83
	OPENBSD_4_5:1.80.0.2
	OPENBSD_4_5_BASE:1.80
	OPENBSD_4_4:1.79.0.2
	OPENBSD_4_4_BASE:1.79
	OPENBSD_4_3:1.69.0.2
	OPENBSD_4_3_BASE:1.69
	OPENBSD_4_2:1.66.0.2
	OPENBSD_4_2_BASE:1.66
	OPENBSD_4_1:1.62.0.4
	OPENBSD_4_1_BASE:1.62
	OPENBSD_4_0:1.62.0.2
	OPENBSD_4_0_BASE:1.62
	OPENBSD_3_9:1.59.0.2
	OPENBSD_3_9_BASE:1.59
	OPENBSD_3_8:1.57.0.2
	OPENBSD_3_8_BASE:1.57
	OPENBSD_3_7:1.55.0.2
	OPENBSD_3_7_BASE:1.55
	OPENBSD_3_6:1.53.0.2
	OPENBSD_3_6_BASE:1.53
	SMP_SYNC_A:1.52
	SMP_SYNC_B:1.52
	OPENBSD_3_5:1.51.0.4
	OPENBSD_3_5_BASE:1.51
	OPENBSD_3_4:1.51.0.2
	OPENBSD_3_4_BASE:1.51
	UBC_SYNC_A:1.49
	OPENBSD_3_3:1.49.0.2
	OPENBSD_3_3_BASE:1.49
	OPENBSD_3_2:1.48.0.4
	OPENBSD_3_2_BASE:1.48
	OPENBSD_3_1:1.48.0.2
	OPENBSD_3_1_BASE:1.48
	UBC_SYNC_B:1.48
	UBC:1.41.0.2
	UBC_BASE:1.41
	OPENBSD_3_0:1.37.0.2
	OPENBSD_3_0_BASE:1.37
	OPENBSD_2_9_BASE:1.32
	OPENBSD_2_9:1.32.0.2
	OPENBSD_2_8:1.31.0.2
	OPENBSD_2_8_BASE:1.31
	OPENBSD_2_7:1.30.0.4
	OPENBSD_2_7_BASE:1.30
	SMP:1.30.0.2
	SMP_BASE:1.30
	kame_19991208:1.27
	OPENBSD_2_6:1.27.0.2
	OPENBSD_2_6_BASE:1.27
	OPENBSD_2_5:1.25.0.4
	OPENBSD_2_5_BASE:1.25
	OPENBSD_2_4:1.25.0.2
	OPENBSD_2_4_BASE:1.25
	OPENBSD_2_3:1.24.0.2
	OPENBSD_2_3_BASE:1.24
	OPENBSD_2_2:1.21.0.2
	OPENBSD_2_2_BASE:1.21
	OPENBSD_2_1:1.19.0.2
	OPENBSD_2_1_BASE:1.19
	OPENBSD_2_0:1.13.0.2
	OPENBSD_2_0_BASE:1.13
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.113
date	2017.02.22.11.42.46;	author mpi;	state Exp;
branches;
next	1.112;
commitid	QPdM5oUknMlUIDue;

1.112
date	2016.11.15.13.46.54;	author mpi;	state Exp;
branches;
next	1.111;
commitid	Ahq50n8vWoZILsRZ;

1.111
date	2016.09.27.01.37.38;	author dlg;	state Exp;
branches;
next	1.110;
commitid	HwDxz9mxZKQUWHxT;

1.110
date	2016.08.13.20.53.17;	author guenther;	state Exp;
branches;
next	1.109;
commitid	15rk0aE492iEzsGW;

1.109
date	2016.04.26.18.37.03;	author natano;	state Exp;
branches;
next	1.108;
commitid	WbumX8gCUOD8jZ5X;

1.108
date	2016.03.17.18.52.31;	author bluhm;	state Exp;
branches;
next	1.107;
commitid	XOU3hWgTktDOU9BT;

1.107
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.106;
commitid	p4LJxGKbi0BU2cG6;

1.106
date	2015.01.17.17.49.27;	author deraadt;	state Exp;
branches;
next	1.105;
commitid	buV4jzMNnBVDajYs;

1.105
date	2014.12.18.20.59.21;	author tedu;	state Exp;
branches;
next	1.104;
commitid	A8MlA6JGDExx7uTs;

1.104
date	2014.12.16.18.30.04;	author tedu;	state Exp;
branches;
next	1.103;
commitid	P6Av4XGqOi3rFasL;

1.103
date	2014.11.15.00.03.12;	author tedu;	state Exp;
branches;
next	1.102;
commitid	DARBwcixOE2oqaWx;

1.102
date	2014.11.14.23.01.44;	author tedu;	state Exp;
branches;
next	1.101;
commitid	IWzLFxf7O2DJPe2b;

1.101
date	2014.09.08.06.24.13;	author jsg;	state Exp;
branches;
next	1.100;
commitid	ZqXwxwmeo3l29NOg;

1.100
date	2014.07.12.18.43.52;	author tedu;	state Exp;
branches;
next	1.99;
commitid	FE3DG5cICjyI4jWx;

1.99
date	2013.12.01.16.40.56;	author krw;	state Exp;
branches;
next	1.98;

1.98
date	2013.09.20.23.51.44;	author fgsch;	state Exp;
branches;
next	1.97;

1.97
date	2013.04.17.16.22.24;	author florian;	state Exp;
branches;
next	1.96;

1.96
date	2013.04.15.15.32.19;	author jsing;	state Exp;
branches;
next	1.95;

1.95
date	2013.01.16.04.05.22;	author deraadt;	state Exp;
branches;
next	1.94;

1.94
date	2012.09.10.11.10.59;	author jsing;	state Exp;
branches;
next	1.93;

1.93
date	2011.07.09.00.24.44;	author beck;	state Exp;
branches;
next	1.92;

1.92
date	2009.10.19.22.24.18;	author jsg;	state Exp;
branches;
next	1.91;

1.91
date	2009.09.02.18.20.54;	author thib;	state Exp;
branches;
next	1.90;

1.90
date	2009.08.25.13.41.29;	author thib;	state Exp;
branches;
next	1.89;

1.89
date	2009.08.20.15.04.24;	author thib;	state Exp;
branches;
next	1.88;

1.88
date	2009.08.13.15.18.16;	author blambert;	state Exp;
branches;
next	1.87;

1.87
date	2009.08.10.10.59.12;	author thib;	state Exp;
branches;
next	1.86;

1.86
date	2009.08.04.17.12.39;	author thib;	state Exp;
branches;
next	1.85;

1.85
date	2009.07.20.16.49.40;	author thib;	state Exp;
branches;
next	1.84;

1.84
date	2009.07.13.15.39.55;	author thib;	state Exp;
branches;
next	1.83;

1.83
date	2009.06.04.00.31.42;	author blambert;	state Exp;
branches;
next	1.82;

1.82
date	2009.06.02.23.16.59;	author thib;	state Exp;
branches;
next	1.81;

1.81
date	2009.04.13.17.51.57;	author blambert;	state Exp;
branches;
next	1.80;

1.80
date	2008.12.24.02.43.52;	author thib;	state Exp;
branches;
next	1.79;

1.79
date	2008.07.28.13.35.14;	author thib;	state Exp;
branches;
next	1.78;

1.78
date	2008.07.10.18.17.56;	author thib;	state Exp;
branches;
next	1.77;

1.77
date	2008.07.05.12.51.04;	author thib;	state Exp;
branches;
next	1.76;

1.76
date	2008.06.14.22.44.07;	author blambert;	state Exp;
branches;
next	1.75;

1.75
date	2008.06.13.22.11.32;	author blambert;	state Exp;
branches;
next	1.74;

1.74
date	2008.06.12.20.24.06;	author blambert;	state Exp;
branches;
next	1.73;

1.73
date	2008.06.11.04.52.27;	author blambert;	state Exp;
branches;
next	1.72;

1.72
date	2008.04.25.12.33.41;	author blambert;	state Exp;
branches;
next	1.71;

1.71
date	2008.04.14.13.46.13;	author blambert;	state Exp;
branches;
next	1.70;

1.70
date	2008.03.16.19.42.57;	author otto;	state Exp;
branches;
next	1.69;

1.69
date	2008.01.06.18.38.32;	author deraadt;	state Exp;
branches;
next	1.68;

1.68
date	2007.09.20.12.54.31;	author thib;	state Exp;
branches;
next	1.67;

1.67
date	2007.09.11.13.41.52;	author blambert;	state Exp;
branches;
next	1.66;

1.66
date	2007.06.20.15.00.43;	author thib;	state Exp;
branches;
next	1.65;

1.65
date	2007.06.13.18.05.27;	author thib;	state Exp;
branches;
next	1.64;

1.64
date	2007.06.12.19.25.27;	author thib;	state Exp;
branches;
next	1.63;

1.63
date	2007.04.12.13.24.39;	author thib;	state Exp;
branches;
next	1.62;

1.62
date	2006.05.29.16.49.42;	author avsm;	state Exp;
branches;
next	1.61;

1.61
date	2006.05.28.23.29.32;	author avsm;	state Exp;
branches;
next	1.60;

1.60
date	2006.04.19.11.55.55;	author pedro;	state Exp;
branches;
next	1.59;

1.59
date	2005.12.27.18.31.12;	author miod;	state Exp;
branches;
next	1.58;

1.58
date	2005.11.30.10.35.08;	author pedro;	state Exp;
branches;
next	1.57;

1.57
date	2005.05.22.17.37.49;	author pedro;	state Exp;
branches;
next	1.56;

1.56
date	2005.03.31.21.39.44;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2005.02.01.15.00.04;	author pvalchev;	state Exp;
branches;
next	1.54;

1.54
date	2005.01.24.00.14.40;	author marius;	state Exp;
branches;
next	1.53;

1.53
date	2004.06.21.23.50.38;	author tholo;	state Exp;
branches;
next	1.52;

1.52
date	2004.04.12.23.58.10;	author tedu;	state Exp;
branches;
next	1.51;

1.51
date	2003.08.14.07.46.40;	author mickey;	state Exp;
branches;
next	1.50;

1.50
date	2003.06.02.23.28.20;	author millert;	state Exp;
branches;
next	1.49;

1.49
date	2002.12.11.02.38.52;	author mickey;	state Exp;
branches;
next	1.48;

1.48
date	2002.03.14.01.27.13;	author millert;	state Exp;
branches;
next	1.47;

1.47
date	2002.02.23.23.47.13;	author art;	state Exp;
branches;
next	1.46;

1.46
date	2002.02.22.20.19.14;	author csapuntz;	state Exp;
branches;
next	1.45;

1.45
date	2002.02.10.22.02.05;	author nate;	state Exp;
branches;
next	1.44;

1.44
date	2002.01.16.21.51.16;	author ericj;	state Exp;
branches;
next	1.43;

1.43
date	2002.01.11.01.20.56;	author nate;	state Exp;
branches;
next	1.42;

1.42
date	2001.12.19.08.58.06;	author art;	state Exp;
branches;
next	1.41;

1.41
date	2001.12.11.09.32.46;	author art;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	2001.12.10.02.19.34;	author art;	state Exp;
branches;
next	1.39;

1.39
date	2001.11.27.05.27.12;	author art;	state Exp;
branches;
next	1.38;

1.38
date	2001.11.14.23.37.33;	author mickey;	state Exp;
branches;
next	1.37;

1.37
date	2001.07.27.05.43.17;	author csapuntz;	state Exp;
branches;
next	1.36;

1.36
date	2001.06.30.08.35.27;	author csapuntz;	state Exp;
branches;
next	1.35;

1.35
date	2001.06.25.03.28.12;	author csapuntz;	state Exp;
branches;
next	1.34;

1.34
date	2001.06.24.21.16.20;	author csapuntz;	state Exp;
branches;
next	1.33;

1.33
date	2001.05.16.12.48.32;	author ho;	state Exp;
branches;
next	1.32;

1.32
date	2001.02.20.01.50.11;	author assar;	state Exp;
branches
	1.32.2.1;
next	1.31;

1.31
date	2000.05.19.16.36.04;	author mickey;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2000.02.07.04.57.17;	author assar;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	2000.01.06.03.35.37;	author smurph;	state Exp;
branches;
next	1.28;

1.28
date	2000.01.01.23.50.59;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	99.06.10.05.55.16;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	99.05.31.17.34.52;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	98.08.19.22.26.56;	author csapuntz;	state Exp;
branches;
next	1.24;

1.24
date	98.02.08.22.41.45;	author tholo;	state Exp;
branches;
next	1.23;

1.23
date	97.11.11.11.20.32;	author niklas;	state Exp;
branches;
next	1.22;

1.22
date	97.11.06.05.59.05;	author csapuntz;	state Exp;
branches;
next	1.21;

1.21
date	97.10.06.20.20.52;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	97.10.06.15.23.45;	author csapuntz;	state Exp;
branches;
next	1.19;

1.19
date	97.04.18.10.15.20;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	97.04.18.09.30.48;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	97.04.18.09.28.03;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.01.15.03.52.27;	author kstailey;	state Exp;
branches;
next	1.15;

1.15
date	96.12.24.20.14.32;	author dm;	state Exp;
branches;
next	1.14;

1.14
date	96.12.17.03.46.39;	author dm;	state Exp;
branches;
next	1.13;

1.13
date	96.09.21.11.06.22;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	96.06.02.16.47.23;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	96.06.01.04.43.59;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	96.05.28.13.44.08;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.05.14.22.41.32;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.04.21.22.30.34;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.04.17.04.50.34;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.03.31.13.16.00;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.02.29.09.24.58;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.01.08.07.36.28;	author dm;	state Exp;
branches;
next	1.3;

1.3
date	95.12.21.14.42.26;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.28.14.53.07;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.22;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.22;	author deraadt;	state Exp;
branches;
next	;

1.30.2.1
date	2001.05.14.22.44.58;	author niklas;	state Exp;
branches;
next	1.30.2.2;

1.30.2.2
date	2001.07.04.10.55.52;	author niklas;	state Exp;
branches;
next	1.30.2.3;

1.30.2.3
date	2001.10.31.03.30.30;	author nate;	state Exp;
branches;
next	1.30.2.4;

1.30.2.4
date	2001.12.05.01.02.40;	author niklas;	state Exp;
branches;
next	1.30.2.5;

1.30.2.5
date	2002.03.06.02.17.12;	author niklas;	state Exp;
branches;
next	1.30.2.6;

1.30.2.6
date	2002.03.28.15.02.48;	author niklas;	state Exp;
branches;
next	1.30.2.7;

1.30.2.7
date	2003.03.28.00.08.46;	author niklas;	state Exp;
branches;
next	1.30.2.8;

1.30.2.8
date	2003.06.07.11.07.44;	author ho;	state Exp;
branches;
next	1.30.2.9;

1.30.2.9
date	2004.02.19.10.57.27;	author niklas;	state Exp;
branches;
next	1.30.2.10;

1.30.2.10
date	2004.06.05.23.13.07;	author niklas;	state Exp;
branches;
next	;

1.31.2.1
date	2001.08.06.22.08.49;	author miod;	state Exp;
branches;
next	;

1.32.2.1
date	2001.07.30.22.07.10;	author jason;	state Exp;
branches;
next	;

1.41.2.1
date	2002.01.31.22.55.47;	author niklas;	state Exp;
branches;
next	1.41.2.2;

1.41.2.2
date	2002.06.11.03.32.04;	author art;	state Exp;
branches;
next	1.41.2.3;

1.41.2.3
date	2002.10.29.18.31.51;	author art;	state Exp;
branches;
next	1.41.2.4;

1.41.2.4
date	2002.11.04.18.02.32;	author art;	state Exp;
branches;
next	1.41.2.5;

1.41.2.5
date	2003.05.19.22.36.43;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.113
log
@Keep local definitions local.

"good work" deraadt@@, ok visa@@
@
text
@/*	$OpenBSD: nfs_vfsops.c,v 1.112 2016/11/15 13:46:54 mpi Exp $	*/
/*	$NetBSD: nfs_vfsops.c,v 1.46.4.1 1996/05/25 22:40:35 fvdl Exp $	*/

/*
 * Copyright (c) 1989, 1993, 1995
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Rick Macklem at The University of Guelph.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)nfs_vfsops.c	8.12 (Berkeley) 5/20/95
 */

#include <sys/param.h>
#include <sys/conf.h>
#include <sys/ioctl.h>
#include <sys/signal.h>
#include <sys/proc.h>
#include <sys/namei.h>
#include <sys/vnode.h>
#include <sys/lock.h>
#include <sys/kernel.h>
#include <sys/mount.h>
#include <sys/swap.h>
#include <sys/buf.h>
#include <sys/mbuf.h>
#include <sys/dirent.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/systm.h>
#include <sys/sysctl.h>
#include <sys/queue.h>

#include <netinet/in.h>

#include <nfs/rpcv2.h>
#include <nfs/nfsproto.h>
#include <nfs/nfsnode.h>
#include <nfs/nfs.h>
#include <nfs/nfsmount.h>
#include <nfs/xdr_subs.h>
#include <nfs/nfsm_subs.h>
#include <nfs/nfsdiskless.h>
#include <nfs/nfs_var.h>

extern struct nfsstats nfsstats;
extern int nfs_ticks;
extern u_int32_t nfs_procids[NFS_NPROCS];

int		nfs_sysctl(int *, u_int, void *, size_t *, void *, size_t, struct proc *);
int		nfs_checkexp(struct mount *, struct mbuf *, int *, struct ucred **);
struct mount	*nfs_mount_diskless(struct nfs_dlmount *, char *, int);
int	mountnfs(struct nfs_args *, struct mount *, struct mbuf *,
	    const char *, char *);
int	nfs_quotactl(struct mount *, int, uid_t, caddr_t, struct proc *);
int	nfs_root(struct mount *, struct vnode **);
int	nfs_start(struct mount *, int, struct proc *);
int	nfs_statfs(struct mount *, struct statfs *, struct proc *);
int	nfs_sync(struct mount *, int, struct ucred *, struct proc *);
int	nfs_unmount(struct mount *, int, struct proc *);
int	nfs_vget(struct mount *, ino_t, struct vnode **);
int	nfs_vptofh(struct vnode *, struct fid *);
int	nfs_mountroot(void);
void	nfs_decode_args(struct nfsmount *, struct nfs_args *,
	    struct nfs_args *);
int	nfs_fhtovp(struct mount *, struct fid *, struct vnode **);

/*
 * nfs vfs operations.
 */
const struct vfsops nfs_vfsops = {
	nfs_mount,
	nfs_start,
	nfs_unmount,
	nfs_root,
	nfs_quotactl,
	nfs_statfs,
	nfs_sync,
	nfs_vget,
	nfs_fhtovp,
	nfs_vptofh,
	nfs_vfs_init,
	nfs_sysctl,
	nfs_checkexp
};

/*
 * nfs statfs call
 */
int
nfs_statfs(struct mount *mp, struct statfs *sbp, struct proc *p)
{
	struct vnode *vp;
	struct nfs_statfs *sfp = NULL;
	struct nfsm_info	info;
	u_int32_t *tl;
	int32_t t1;
	caddr_t cp2;
	struct nfsmount *nmp = VFSTONFS(mp);
	int error = 0, retattr;
	struct ucred *cred;
	struct nfsnode *np;
	u_quad_t tquad;

	info.nmi_v3 = (nmp->nm_flag & NFSMNT_NFSV3);

	error = nfs_nget(mp, (nfsfh_t *)nmp->nm_fh, nmp->nm_fhsize, &np);
	if (error)
		return (error);
	vp = NFSTOV(np);
	cred = crget();
	cred->cr_ngroups = 0;
	if (info.nmi_v3 && (nmp->nm_flag & NFSMNT_GOTFSINFO) == 0)
		(void)nfs_fsinfo(nmp, vp, cred, p);
	nfsstats.rpccnt[NFSPROC_FSSTAT]++;
	info.nmi_mb = info.nmi_mreq = nfsm_reqhead(NFSX_FH(info.nmi_v3));
	nfsm_fhtom(&info, vp, info.nmi_v3);

	info.nmi_procp = p;
	info.nmi_cred = cred;
	error = nfs_request(vp, NFSPROC_FSSTAT, &info);
	if (info.nmi_v3)
		nfsm_postop_attr(vp, retattr);
	if (error) {
		m_freem(info.nmi_mrep);
		goto nfsmout;
	}

	nfsm_dissect(sfp, struct nfs_statfs *, NFSX_STATFS(info.nmi_v3));
	sbp->f_iosize = min(nmp->nm_rsize, nmp->nm_wsize);
	if (info.nmi_v3) {
		sbp->f_bsize = NFS_FABLKSIZE;
		tquad = fxdr_hyper(&sfp->sf_tbytes);
		sbp->f_blocks = tquad / (u_quad_t)NFS_FABLKSIZE;
		tquad = fxdr_hyper(&sfp->sf_fbytes);
		sbp->f_bfree = tquad / (u_quad_t)NFS_FABLKSIZE;
		tquad = fxdr_hyper(&sfp->sf_abytes);
		sbp->f_bavail = (quad_t)tquad / (quad_t)NFS_FABLKSIZE;

		tquad = fxdr_hyper(&sfp->sf_tfiles);
		sbp->f_files = tquad;
		tquad = fxdr_hyper(&sfp->sf_ffiles);
		sbp->f_ffree = tquad;
		sbp->f_favail = tquad;
	} else {
		sbp->f_bsize = fxdr_unsigned(int32_t, sfp->sf_bsize);
		sbp->f_blocks = fxdr_unsigned(int32_t, sfp->sf_blocks);
		sbp->f_bfree = fxdr_unsigned(int32_t, sfp->sf_bfree);
		sbp->f_bavail = fxdr_unsigned(int32_t, sfp->sf_bavail);
		sbp->f_files = 0;
		sbp->f_ffree = 0;
		sbp->f_favail = 0;
	}
	copy_statfs_info(sbp, mp);
	m_freem(info.nmi_mrep);
nfsmout: 
	vrele(vp);
	crfree(cred);
	return (error);
}

/*
 * nfs version 3 fsinfo rpc call
 */
int
nfs_fsinfo(struct nfsmount *nmp, struct vnode *vp, struct ucred *cred,
    struct proc *p)
{
	struct nfsv3_fsinfo *fsp;
	struct nfsm_info	info;
	int32_t t1;
	u_int32_t *tl, pref, max;
	caddr_t cp2;
	int error = 0, retattr;

	nfsstats.rpccnt[NFSPROC_FSINFO]++;
	info.nmi_mb = info.nmi_mreq = nfsm_reqhead(NFSX_FH(1));
	nfsm_fhtom(&info, vp, 1);

	info.nmi_procp = p;
	info.nmi_cred = cred;
	error = nfs_request(vp, NFSPROC_FSINFO, &info);

	nfsm_postop_attr(vp, retattr);
	if (error) {
		m_freem(info.nmi_mrep);
		goto nfsmout;
	}

	nfsm_dissect(fsp, struct nfsv3_fsinfo *, NFSX_V3FSINFO);
	pref = fxdr_unsigned(u_int32_t, fsp->fs_wtpref);
	if (pref < nmp->nm_wsize)
		nmp->nm_wsize = (pref + NFS_FABLKSIZE - 1) &
			~(NFS_FABLKSIZE - 1);
	max = fxdr_unsigned(u_int32_t, fsp->fs_wtmax);
	if (max < nmp->nm_wsize) {
		nmp->nm_wsize = max & ~(NFS_FABLKSIZE - 1);
		if (nmp->nm_wsize == 0)
			nmp->nm_wsize = max;
	}
	pref = fxdr_unsigned(u_int32_t, fsp->fs_rtpref);
	if (pref < nmp->nm_rsize)
		nmp->nm_rsize = (pref + NFS_FABLKSIZE - 1) &
			~(NFS_FABLKSIZE - 1);
	max = fxdr_unsigned(u_int32_t, fsp->fs_rtmax);
	if (max < nmp->nm_rsize) {
		nmp->nm_rsize = max & ~(NFS_FABLKSIZE - 1);
		if (nmp->nm_rsize == 0)
			nmp->nm_rsize = max;
	}
	pref = fxdr_unsigned(u_int32_t, fsp->fs_dtpref);
	if (pref < nmp->nm_readdirsize)
		nmp->nm_readdirsize = (pref + NFS_DIRBLKSIZ - 1) &
			~(NFS_DIRBLKSIZ - 1);
	if (max < nmp->nm_readdirsize) {
		nmp->nm_readdirsize = max & ~(NFS_DIRBLKSIZ - 1);
		if (nmp->nm_readdirsize == 0)
			nmp->nm_readdirsize = max;
	}
	nmp->nm_flag |= NFSMNT_GOTFSINFO;

	m_freem(info.nmi_mrep);
nfsmout: 
	return (error);
}

struct nfs_diskless nfs_diskless;

/*
 * Mount a remote root fs via. NFS.  It goes like this:
 * - Call nfs_boot_init() to fill in the nfs_diskless struct
 *   (using RARP, bootparam RPC, mountd RPC)
 * - hand craft the swap nfs vnode hanging off a fake mount point
 *	if swdevt[0].sw_dev == NODEV
 * - build the rootfs mount point and call mountnfs() to do the rest.
 */
int
nfs_mountroot(void)
{
	struct vattr attr;
	struct mount *mp;
	struct vnode *vp;
	struct proc *procp;
	long n;
	int error;

	procp = curproc; /* XXX */

	/*
	 * Call nfs_boot_init() to fill in the nfs_diskless struct.
	 * Side effect:	 Finds and configures a network interface.
	 */
	nfs_boot_init(&nfs_diskless, procp);

	/*
	 * Create the root mount point.
	 */
	if (nfs_boot_getfh(&nfs_diskless.nd_boot, "root", &nfs_diskless.nd_root, -1))
		panic("nfs_mountroot: root");
	mp = nfs_mount_diskless(&nfs_diskless.nd_root, "/", 0);
	nfs_root(mp, &rootvp);
	printf("root on %s\n", nfs_diskless.nd_root.ndm_host);

	/*
	 * Link it into the mount list.
	 */
	TAILQ_INSERT_TAIL(&mountlist, mp, mnt_list);
	vfs_unbusy(mp);

	/* Get root attributes (for the time). */
	error = VOP_GETATTR(rootvp, &attr, procp->p_ucred, procp);
	if (error) panic("nfs_mountroot: getattr for root");
	n = attr.va_atime.tv_sec;
#ifdef	DEBUG
	printf("root time: 0x%lx\n", n);
#endif
	inittodr(n);

#ifdef notyet
	/* Set up swap credentials. */
	proc0.p_ucred->cr_uid = ntohl(nfs_diskless.swap_ucred.cr_uid);
	proc0.p_ucred->cr_gid = ntohl(nfs_diskless.swap_ucred.cr_gid);
	if ((proc0.p_ucred->cr_ngroups = ntohs(nfs_diskless.swap_ucred.cr_ngroups)) >
		NGROUPS_MAX)
		proc0.p_ucred->cr_ngroups = NGROUPS_MAX;
	for (i = 0; i < proc0.p_ucred->cr_ngroups; i++)
	    proc0.p_ucred->cr_groups[i] = ntohl(nfs_diskless.swap_ucred.cr_groups[i]);
#endif

	/*
	 * "Mount" the swap device.
	 *
	 * On a "dataless" configuration (swap on disk) we will have:
	 *	(swdevt[0].sw_dev != NODEV) identifying the swap device.
	 */
	if (swdevt[0].sw_dev != NODEV) {
		if (bdevvp(swapdev, &swapdev_vp))
			panic("nfs_mountroot: can't setup swap vp");
		printf("swap on device 0x%x\n", swdevt[0].sw_dev);
		return (0);
	}

	/*
	 * If swapping to an nfs node:	(swdevt[0].sw_dev == NODEV)
	 * Create a fake mount point just for the swap vnode so that the
	 * swap file can be on a different server from the rootfs.
	 *
	 * Wait 5 retries, finally no swap is cool. -mickey
	 */
	error = nfs_boot_getfh(&nfs_diskless.nd_boot, "swap", &nfs_diskless.nd_swap, 5);
	if (!error) {
		mp = nfs_mount_diskless(&nfs_diskless.nd_swap, "/swap", 0);
		nfs_root(mp, &vp);
		vfs_unbusy(mp);

		/*
		 * Since the swap file is not the root dir of a file system,
		 * hack it to a regular file.
		 */
		vp->v_type = VREG;
		vp->v_flag = 0;

		/*
		 * Next line is a hack to make swapmount() work on NFS
		 * swap files.
		 */
		swdevt[0].sw_dev = NETDEV;
		/* end hack */
		nfs_diskless.sw_vp = vp;

		/*
		 * Find out how large the swap file is.
		 */
		error = VOP_GETATTR(vp, &attr, procp->p_ucred, procp);
		if (error)
			printf("nfs_mountroot: getattr for swap\n");
		n = (long) (attr.va_size >> DEV_BSHIFT);

		printf("swap on %s\n", nfs_diskless.nd_swap.ndm_host);
#ifdef	DEBUG
		printf("swap size: 0x%lx (blocks)\n", n);
#endif
		return (0);
	}

	printf("WARNING: no swap\n");
	swdevt[0].sw_dev = NODEV;
	return (0);
}

/*
 * Internal version of mount system call for diskless setup.
 */
struct mount *
nfs_mount_diskless(struct nfs_dlmount *ndmntp, char *mntname, int mntflag)
{
	struct mount *mp;
	struct mbuf *m;
	int error;

	if (vfs_rootmountalloc("nfs", mntname, &mp))
		panic("nfs_mount_diskless: vfs_rootmountalloc failed");
	mp->mnt_flag |= mntflag;

	/* Get mbuf for server sockaddr. */
	m = m_get(M_WAIT, MT_SONAME);
	bcopy(ndmntp->ndm_args.addr, mtod(m, caddr_t),
	    (m->m_len = ndmntp->ndm_args.addr->sa_len));

	error = mountnfs(&ndmntp->ndm_args, mp, m, mntname,
	    ndmntp->ndm_args.hostname);
	if (error)
		panic("nfs_mountroot: mount %s failed: %d", mntname, error);

	return (mp);
}

void
nfs_decode_args(struct nfsmount *nmp, struct nfs_args *argp,
    struct nfs_args *nargp)
{
	int s;
	int adjsock = 0;
	int maxio;

	s = splsoftnet();

#if 0
	/* Re-bind if rsrvd port requested and wasn't on one */
	adjsock = !(nmp->nm_flag & NFSMNT_RESVPORT)
		  && (argp->flags & NFSMNT_RESVPORT);
#endif
	/* Also re-bind if we're switching to/from a connected UDP socket */
	adjsock |= ((nmp->nm_flag & NFSMNT_NOCONN) !=
	    (argp->flags & NFSMNT_NOCONN));

	/* Update flags atomically.  Don't change the lock bits. */
	nmp->nm_flag =
	    (argp->flags & ~NFSMNT_INTERNAL) | (nmp->nm_flag & NFSMNT_INTERNAL);
	splx(s);

	if ((argp->flags & NFSMNT_TIMEO) && argp->timeo > 0) {
		nmp->nm_timeo = (argp->timeo * NFS_HZ + 5) / 10;
		if (nmp->nm_timeo < NFS_MINTIMEO)
			nmp->nm_timeo = NFS_MINTIMEO;
		else if (nmp->nm_timeo > NFS_MAXTIMEO)
			nmp->nm_timeo = NFS_MAXTIMEO;
	}

	if ((argp->flags & NFSMNT_RETRANS) && argp->retrans > 1)
		nmp->nm_retry = MIN(argp->retrans, NFS_MAXREXMIT);
	if (!(nmp->nm_flag & NFSMNT_SOFT))
		nmp->nm_retry = NFS_MAXREXMIT + 1; /* past clip limit */

	if (argp->flags & NFSMNT_NFSV3) {
		if (argp->sotype == SOCK_DGRAM)
			maxio = NFS_MAXDGRAMDATA;
		else
			maxio = NFS_MAXDATA;
	} else
		maxio = NFS_V2MAXDATA;

	if ((argp->flags & NFSMNT_WSIZE) && argp->wsize > 0) {
		int osize = nmp->nm_wsize;
		nmp->nm_wsize = argp->wsize;
		/* Round down to multiple of blocksize */
		nmp->nm_wsize &= ~(NFS_FABLKSIZE - 1);
		if (nmp->nm_wsize <= 0)
			nmp->nm_wsize = NFS_FABLKSIZE;
		adjsock |= (nmp->nm_wsize != osize);
	}
	if (nmp->nm_wsize > maxio)
		nmp->nm_wsize = maxio;
	if (nmp->nm_wsize > MAXBSIZE)
		nmp->nm_wsize = MAXBSIZE;

	if ((argp->flags & NFSMNT_RSIZE) && argp->rsize > 0) {
		int osize = nmp->nm_rsize;
		nmp->nm_rsize = argp->rsize;
		/* Round down to multiple of blocksize */
		nmp->nm_rsize &= ~(NFS_FABLKSIZE - 1);
		if (nmp->nm_rsize <= 0)
			nmp->nm_rsize = NFS_FABLKSIZE;
		adjsock |= (nmp->nm_rsize != osize);
	}
	if (nmp->nm_rsize > maxio)
		nmp->nm_rsize = maxio;
	if (nmp->nm_rsize > MAXBSIZE)
		nmp->nm_rsize = MAXBSIZE;

	if ((argp->flags & NFSMNT_READDIRSIZE) && argp->readdirsize > 0) {
		nmp->nm_readdirsize = argp->readdirsize;
		/* Round down to multiple of blocksize */
		nmp->nm_readdirsize &= ~(NFS_DIRBLKSIZ - 1);
		if (nmp->nm_readdirsize < NFS_DIRBLKSIZ)
			nmp->nm_readdirsize = NFS_DIRBLKSIZ;
	} else if (argp->flags & NFSMNT_RSIZE)
		nmp->nm_readdirsize = nmp->nm_rsize;

	if (nmp->nm_readdirsize > maxio)
		nmp->nm_readdirsize = maxio;

	if ((argp->flags & NFSMNT_MAXGRPS) && argp->maxgrouplist >= 0 &&
		argp->maxgrouplist <= NFS_MAXGRPS)
		nmp->nm_numgrps = argp->maxgrouplist;
	if ((argp->flags & NFSMNT_READAHEAD) && argp->readahead >= 0 &&
		argp->readahead <= NFS_MAXRAHEAD)
		nmp->nm_readahead = argp->readahead;
	if (argp->flags & NFSMNT_ACREGMIN && argp->acregmin >= 0) {
		if (argp->acregmin > 0xffff)
			nmp->nm_acregmin = 0xffff;
		else
			nmp->nm_acregmin = argp->acregmin;
	}
	if (argp->flags & NFSMNT_ACREGMAX && argp->acregmax >= 0) {
		if (argp->acregmax > 0xffff)
			nmp->nm_acregmax = 0xffff;
		else
			nmp->nm_acregmax = argp->acregmax;
	}
	if (nmp->nm_acregmin > nmp->nm_acregmax)
	  nmp->nm_acregmin = nmp->nm_acregmax;

	if (argp->flags & NFSMNT_ACDIRMIN && argp->acdirmin >= 0) {
		if (argp->acdirmin > 0xffff)
			nmp->nm_acdirmin = 0xffff;
		else
			nmp->nm_acdirmin = argp->acdirmin;
	}
	if (argp->flags & NFSMNT_ACDIRMAX && argp->acdirmax >= 0) {
		if (argp->acdirmax > 0xffff)
			nmp->nm_acdirmax = 0xffff;
		else
			nmp->nm_acdirmax = argp->acdirmax;
	}
	if (nmp->nm_acdirmin > nmp->nm_acdirmax)
	  nmp->nm_acdirmin = nmp->nm_acdirmax;

	if (nmp->nm_so && adjsock) {
		nfs_disconnect(nmp);
		if (nmp->nm_sotype == SOCK_DGRAM)
			while (nfs_connect(nmp, NULL)) {
				printf("nfs_args: retrying connect\n");
				(void) tsleep(&lbolt,
					      PSOCK, "nfscon", 0);
			}
	}

	/* Update nargp based on nmp */
	nargp->wsize = nmp->nm_wsize;
	nargp->rsize = nmp->nm_rsize;
	nargp->readdirsize = nmp->nm_readdirsize;
	nargp->timeo = nmp->nm_timeo;
	nargp->retrans = nmp->nm_retry;
	nargp->maxgrouplist = nmp->nm_numgrps;
	nargp->readahead = nmp->nm_readahead;
	nargp->acregmin = nmp->nm_acregmin;
	nargp->acregmax = nmp->nm_acregmax;
	nargp->acdirmin = nmp->nm_acdirmin;
	nargp->acdirmax = nmp->nm_acdirmax;
}

/*
 * VFS Operations.
 *
 * mount system call
 * It seems a bit dumb to copyinstr() the host here and then
 * bcopy() it in mountnfs(), but I wanted to detect errors before
 * doing the sockargs() call because sockargs() allocates an mbuf and
 * an error after that means that I have to release the mbuf.
 */
/* ARGSUSED */
int
nfs_mount(struct mount *mp, const char *path, void *data,
    struct nameidata *ndp, struct proc *p)
{
	int error;
	struct nfs_args args;
	struct mbuf *nam;
	char hst[MNAMELEN];
	size_t len;
	u_char nfh[NFSX_V3FHMAX];

	error = copyin(data, &args, sizeof(args.version));
	if (error)
		return (error);
	if (args.version == 3) {
		error = copyin(data, &args, sizeof(struct nfs_args3));
		args.flags &= ~(NFSMNT_INTERNAL|NFSMNT_NOAC);
	} else if (args.version == NFS_ARGSVERSION) {
		error = copyin(data, &args, sizeof(struct nfs_args));
		args.flags &= ~NFSMNT_NOAC; /* XXX - compatibility */
	} else
		return (EPROGMISMATCH);
	if (error)
		return (error);

	if ((args.flags & (NFSMNT_NFSV3|NFSMNT_RDIRPLUS)) == NFSMNT_RDIRPLUS)
		return (EINVAL);

	if (nfs_niothreads < 0) {
		nfs_niothreads = 4;
		nfs_getset_niothreads(1);
	}

	if (mp->mnt_flag & MNT_UPDATE) {
		struct nfsmount *nmp = VFSTONFS(mp);

		if (nmp == NULL)
			return (EIO);
		/*
		 * When doing an update, we can't change from or to
		 * v3.
		 */
		args.flags = (args.flags & ~(NFSMNT_NFSV3)) |
		    (nmp->nm_flag & (NFSMNT_NFSV3));
		nfs_decode_args(nmp, &args, &mp->mnt_stat.mount_info.nfs_args);
		return (0);
	}
	if (args.fhsize < 0 || args.fhsize > NFSX_V3FHMAX)
		return (EINVAL);
	error = copyin(args.fh, nfh, args.fhsize);
	if (error)
		return (error);
	error = copyinstr(args.hostname, hst, MNAMELEN-1, &len);
	if (error)
		return (error);
	memset(&hst[len], 0, MNAMELEN - len);
	/* sockargs() call must be after above copyin() calls */
	error = sockargs(&nam, args.addr, args.addrlen, MT_SONAME);
	if (error)
		return (error);
	args.fh = nfh;
	error = mountnfs(&args, mp, nam, path, hst);
	return (error);
}

/*
 * Common code for mount and mountroot
 */
int
mountnfs(struct nfs_args *argp, struct mount *mp, struct mbuf *nam,
    const char *pth, char *hst)
{
	struct nfsmount *nmp;
	int error;

	if (mp->mnt_flag & MNT_UPDATE) {
		nmp = VFSTONFS(mp);
		/* update paths, file handles, etc, here	XXX */
		m_freem(nam);
		return (0);
	} else {
		nmp = malloc(sizeof(*nmp), M_NFSMNT,
		    M_WAITOK|M_ZERO);
		mp->mnt_data = nmp;
	}

	vfs_getnewfsid(mp);
	nmp->nm_mountp = mp;
	nmp->nm_timeo = NFS_TIMEO;
	nmp->nm_retry = NFS_RETRANS;
	nmp->nm_wsize = NFS_WSIZE;
	nmp->nm_rsize = NFS_RSIZE;
	nmp->nm_readdirsize = NFS_READDIRSIZE;
	nmp->nm_numgrps = NFS_MAXGRPS;
	nmp->nm_readahead = NFS_DEFRAHEAD;
	nmp->nm_fhsize = argp->fhsize;
	nmp->nm_acregmin = NFS_MINATTRTIMO;
	nmp->nm_acregmax = NFS_MAXATTRTIMO;
	nmp->nm_acdirmin = NFS_MINATTRTIMO;
	nmp->nm_acdirmax = NFS_MAXATTRTIMO;
	bcopy(argp->fh, nmp->nm_fh, argp->fhsize);
	mp->mnt_stat.f_namemax = MAXNAMLEN;
	memset(mp->mnt_stat.f_mntonname, 0, MNAMELEN);
	strlcpy(mp->mnt_stat.f_mntonname, pth, MNAMELEN);
	memset(mp->mnt_stat.f_mntfromname, 0, MNAMELEN);
	strlcpy(mp->mnt_stat.f_mntfromname, hst, MNAMELEN);
	memset(mp->mnt_stat.f_mntfromspec, 0, MNAMELEN);
	strlcpy(mp->mnt_stat.f_mntfromspec, hst, MNAMELEN);
	bcopy(argp, &mp->mnt_stat.mount_info.nfs_args, sizeof(*argp));
	nmp->nm_nam = nam;
	nfs_decode_args(nmp, argp, &mp->mnt_stat.mount_info.nfs_args);

	nfs_ninit(nmp);
	TAILQ_INIT(&nmp->nm_reqsq);
	timeout_set_proc(&nmp->nm_rtimeout, nfs_timer, nmp);

	/* Set up the sockets and per-host congestion */
	nmp->nm_sotype = argp->sotype;
	nmp->nm_soproto = argp->proto;

	/*
	 * For Connection based sockets (TCP,...) defer the connect until
	 * the first request, in case the server is not responding.
	 */
	if (nmp->nm_sotype == SOCK_DGRAM &&
	    (error = nfs_connect(nmp, NULL)))
		goto bad;

	/*
	 * This is silly, but it has to be set so that vinifod() works.
	 * We do not want to do an nfs_statfs() here since we can get
	 * stuck on a dead server and we are holding a lock on the mount
	 * point.
	 */
	mp->mnt_stat.f_iosize = NFS_MAXDGRAMDATA;

	return (0);
bad:
	nfs_disconnect(nmp);
	free(nmp, M_NFSMNT, sizeof(*nmp));
	m_freem(nam);
	return (error);
}

/* unmount system call */
int
nfs_unmount(struct mount *mp, int mntflags, struct proc *p)
{
	struct nfsmount *nmp;
	int error, flags;

	nmp = VFSTONFS(mp);
	flags = 0;

	if (mntflags & MNT_FORCE)
		flags |= FORCECLOSE;

	error = vflush(mp, NULL, flags);
	if (error)
		return (error);

	nfs_disconnect(nmp);
	m_freem(nmp->nm_nam);
	timeout_del(&nmp->nm_rtimeout);
	free(nmp, M_NFSMNT, sizeof(*nmp));
	mp->mnt_data = NULL;
	return (0);
}

/*
 * Return root of a filesystem
 */
int
nfs_root(struct mount *mp, struct vnode **vpp)
{
	struct nfsmount *nmp;
	struct nfsnode *np;
	int error;

	nmp = VFSTONFS(mp);
	error = nfs_nget(mp, (nfsfh_t *)nmp->nm_fh, nmp->nm_fhsize, &np);
	if (error)
		return (error);
	*vpp = NFSTOV(np);
	return (0);
}

/*
 * Flush out the buffer cache
 */
int
nfs_sync(struct mount *mp, int waitfor, struct ucred *cred, struct proc *p)
{
	struct vnode *vp;
	int error, allerror = 0;

	/*
	 * Don't traverse the vnode list if we want to skip all of them.
	 */
	if (waitfor == MNT_LAZY)
		return (allerror);

	/*
	 * Force stale buffer cache information to be flushed.
	 */
loop:
	LIST_FOREACH(vp, &mp->mnt_vnodelist, v_mntvnodes) {
		/*
		 * If the vnode that we are about to sync is no longer
		 * associated with this mount point, start over.
		 */
		if (vp->v_mount != mp)
			goto loop;
		if (VOP_ISLOCKED(vp) || LIST_FIRST(&vp->v_dirtyblkhd) == NULL)
			continue;
		if (vget(vp, LK_EXCLUSIVE, p))
			goto loop;
		error = VOP_FSYNC(vp, cred, waitfor, p);
		if (error)
			allerror = error;
		vput(vp);
	}

	return (allerror);
}

/*
 * NFS flat namespace lookup.
 * Currently unsupported.
 */
/* ARGSUSED */
int
nfs_vget(struct mount *mp, ino_t ino, struct vnode **vpp)
{

	return (EOPNOTSUPP);
}

/*
 * Do that sysctl thang...
 */
int
nfs_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen, struct proc *p)
{
	int rv;

	/*
	 * All names at this level are terminal.
	 */
	if(namelen > 1)
		return ENOTDIR;	/* overloaded */

	switch(name[0]) {
	case NFS_NFSSTATS:
		if(!oldp) {
			*oldlenp = sizeof nfsstats;
			return 0;
		}

		if(*oldlenp < sizeof nfsstats) {
			*oldlenp = sizeof nfsstats;
			return ENOMEM;
		}

		rv = copyout(&nfsstats, oldp, sizeof nfsstats);
		if(rv) return rv;

		if(newp && newlen != sizeof nfsstats)
			return EINVAL;

		if(newp) {
			return copyin(newp, &nfsstats, sizeof nfsstats);
		}
		return 0;

	case NFS_NIOTHREADS:
		nfs_getset_niothreads(0);

		rv = sysctl_int(oldp, oldlenp, newp, newlen, &nfs_niothreads);
		if (newp)
			nfs_getset_niothreads(1);

		return rv;

	default:
		return EOPNOTSUPP;
	}
}


/*
 * At this point, this should never happen
 */
/* ARGSUSED */
int
nfs_fhtovp(struct mount *mp, struct fid *fhp, struct vnode **vpp)
{
	return (EINVAL);
}

/*
 * Vnode pointer to File handle, should never happen either
 */
/* ARGSUSED */
int
nfs_vptofh(struct vnode *vp, struct fid *fhp)
{
	return (EINVAL);
}

/*
 * Vfs start routine, a no-op.
 */
/* ARGSUSED */
int
nfs_start(struct mount *mp, int flags, struct proc *p)
{
	return (0);
}

/*
 * Do operations associated with quotas, not supported
 */
/* ARGSUSED */
int
nfs_quotactl(struct mount *mp, int cmd, uid_t uid, caddr_t arg, struct proc *p)
{
	return (EOPNOTSUPP);
}

/*
 * check export permission, not supported
 */
/* ARGUSED */
int
nfs_checkexp(struct mount *mp, struct mbuf *nam, int *exflagsp,
    struct ucred **credanonp)
{
	return (EOPNOTSUPP);
}

@


1.112
log
@Switch nfs_timer() to timeout_set_proc(9) as it might end up doing a
PRU_SEND.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.111 2016/09/27 01:37:38 dlg Exp $	*/
d77 14
@


1.111
log
@replace the use of RB macros with the RBT functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.110 2016/08/13 20:53:17 guenther Exp $	*/
d657 1
a657 1
	timeout_set(&nmp->nm_rtimeout, nfs_timer, nmp);
@


1.110
log
@Eliminate pointless casts to qaddr_t of a value being assigned to a void*

ok kettenis@@ krw@@ natano@@ dlg@@ espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.109 2016/04/26 18:37:03 natano Exp $	*/
d655 1
a655 1
	RB_INIT(&nmp->nm_ntree);
@


1.109
log
@Populate all necessary statfs members in .vfs_statfs. cd9660, udf,
msdosfs and nfsv2 don't set f_namemax. ntfs and ext2fs don't set
f_namemeax and f_favail. fusefs doesn't set f_mntfromspec, f_favail and
f_iosize. Also, make all filesystems use copy_statfs_info(), so that all
statfs information is filled in correctly for the (sb != &mp->mnt-stat)
case.

ok stefan
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.108 2016/03/17 18:52:31 bluhm Exp $	*/
d626 1
a626 1
		mp->mnt_data = (qaddr_t)nmp;
@


1.108
log
@Set mnt_data to NULL after freeing the file system specific mount point.
OK krw@@ natano@@ as part of a larger diff
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.107 2015/03/14 03:38:52 jsg Exp $	*/
a154 1
		sbp->f_namemax = MAXNAMLEN;
d162 1
d644 7
a650 4
	strncpy(&mp->mnt_stat.f_fstypename[0], mp->mnt_vfc->vfc_name, MFSNAMELEN);
	bcopy(pth, mp->mnt_stat.f_mntonname, MNAMELEN);
	bcopy(hst, mp->mnt_stat.f_mntfromname, MNAMELEN);
	bcopy(hst, mp->mnt_stat.f_mntfromspec, MNAMELEN);
@


1.107
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.106 2015/01/17 17:49:27 deraadt Exp $	*/
d705 1
@


1.106
log
@use NGROUPS_MAX
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.105 2014/12/18 20:59:21 tedu Exp $	*/
a57 1
#include <net/if.h>
@


1.105
log
@delete a whole mess of unnecessary caddr_t casts
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.104 2014/12/16 18:30:04 tedu Exp $	*/
d295 2
a296 2
		NGROUPS)
		proc0.p_ucred->cr_ngroups = NGROUPS;
@


1.104
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.103 2014/11/15 00:03:12 tedu Exp $	*/
d378 1
a378 1
	bcopy((caddr_t)ndmntp->ndm_args.addr, mtod(m, caddr_t),
d515 1
a515 1
				(void) tsleep((caddr_t)&lbolt,
d559 1
a559 2
		error = copyin (data, (caddr_t)&args,
				sizeof (struct nfs_args3));
d562 1
a562 1
		error = copyin(data, (caddr_t)&args, sizeof (struct nfs_args));
d593 1
a593 1
	error = copyin((caddr_t)args.fh, (caddr_t)nfh, args.fhsize);
d644 1
a644 1
	bcopy((caddr_t)argp->fh, (caddr_t)nmp->nm_fh, argp->fhsize);
@


1.103
log
@add sizes for free(ptr, sizeof(*ptr)). use sizeof(*ptr) for malloc sizes.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.102 2014/11/14 23:01:44 tedu Exp $	*/
d45 1
@


1.102
log
@bzero -> memset
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.101 2014/09/08 06:24:13 jsg Exp $	*/
d625 1
a625 1
		nmp = malloc(sizeof(struct nfsmount), M_NFSMNT,
d680 1
a680 1
	free((caddr_t)nmp, M_NFSMNT, 0);
d705 1
a705 1
	free(nmp, M_NFSMNT, 0);
@


1.101
log
@remove uneeded route.h includes
ok miod@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.100 2014/07/12 18:43:52 tedu Exp $	*/
d599 1
a599 1
	bzero(&hst[len], MNAMELEN - len);
@


1.100
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.99 2013/12/01 16:40:56 krw Exp $	*/
a57 1
#include <net/route.h>
@


1.99
log
@Change 'mountlist' from CIRCLEQ to TAILQ. Be paranoid and
use TAILQ_*_SAFE more than might be needed.

Bulk ports build by sthen@@ showed nobody sticking their fingers
so deep into the kernel.

Feedback and suggestions from millert@@. ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.98 2013/09/20 23:51:44 fgsch Exp $	*/
d681 1
a681 1
	free((caddr_t)nmp, M_NFSMNT);
d706 1
a706 1
	free(nmp, M_NFSMNT);
@


1.98
log
@Add support for root on nfs using v3. Code adapted from NetBSD.
Tested on sparc by miod, octeon by aalm and armv7 by me.
miod ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.97 2013/04/17 16:22:24 florian Exp $	*/
d278 1
a278 1
	CIRCLEQ_INSERT_TAIL(&mountlist, mp, mnt_list);
@


1.97
log
@Unbreak and cleanup diskless swap automount.

Initial diff to replace unclear short variable name "nd" by
"nfs_diskless" and to display the real nfs path to swap in pstat -s by
deraadt@@

Testing by me revealed diskless swap automount was broken since some
time.  Fix this by passing and using the correct vnode in nfs_diskless
to swapmount().

Lots of input / help deraadt@@, tweaks by deraadt@@
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.96 2013/04/15 15:32:19 jsing Exp $	*/
a367 1
	struct nfs_args args;
a375 23
	/* Initialize mount args. */
	bzero((caddr_t) &args, sizeof(args));
	args.addr     = (struct sockaddr *)&ndmntp->ndm_saddr;
	args.addrlen  = args.addr->sa_len;
	args.sotype   = SOCK_DGRAM;
	args.fh	      = ndmntp->ndm_fh;
	args.fhsize   = NFSX_V2FH;
	args.hostname = ndmntp->ndm_host;

#ifdef	NFS_BOOT_OPTIONS
	args.flags    |= NFS_BOOT_OPTIONS;
#endif
#ifdef	NFS_BOOT_RWSIZE
	/*
	 * Reduce rsize,wsize for interfaces that consistently
	 * drop fragments of long UDP messages.	 (i.e. wd8003).
	 * You can always change these later via remount.
	 */
	args.flags   |= NFSMNT_WSIZE | NFSMNT_RSIZE;
	args.wsize    = NFS_BOOT_RWSIZE;
	args.rsize    = NFS_BOOT_RWSIZE;
#endif

d378 2
a379 2
	bcopy((caddr_t)args.addr, mtod(m, caddr_t),
	    (m->m_len = args.addr->sa_len));
d381 2
a382 1
	error = mountnfs(&args, mp, m, mntname, args.hostname);
@


1.96
log
@Add an f_mntfromspec member to struct statfs, which specifies the name of
the special provided when the mount was requested. This may be the same as
the special that was actually used for the mount (e.g. in the case of a
device node) or it may be different (e.g. in the case of a DUID).

Whilst here, change f_ctime to a 64 bit type and remove the pointless
f_spare members.

Compatibility goo courtesy of guenther@@

ok krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.95 2013/01/16 04:05:22 deraadt Exp $	*/
d238 2
a250 1
	struct nfs_diskless nd;
d264 1
a264 2
	bzero((caddr_t) &nd, sizeof(nd));
	nfs_boot_init(&nd, procp);
d269 1
a269 1
	if (nfs_boot_getfh(&nd.nd_boot, "root", &nd.nd_root, -1))
d271 1
a271 1
	mp = nfs_mount_diskless(&nd.nd_root, "/", 0);
d273 1
a273 1
	printf("root on %s\n", nd.nd_root.ndm_host);
d292 3
a294 3
	proc0.p_ucred->cr_uid = ntohl(nd.swap_ucred.cr_uid);
	proc0.p_ucred->cr_gid = ntohl(nd.swap_ucred.cr_gid);
	if ((proc0.p_ucred->cr_ngroups = ntohs(nd.swap_ucred.cr_ngroups)) >
d298 1
a298 1
	    proc0.p_ucred->cr_groups[i] = ntohl(nd.swap_ucred.cr_groups[i]);
a306 2
	if (bdevvp(swapdev, &swapdev_vp))
		panic("nfs_mountroot: can't setup swap vp");
d308 2
d321 1
a321 1
	error = nfs_boot_getfh(&nd.nd_boot, "swap", &nd.nd_swap, 5);
d323 1
a323 1
		mp = nfs_mount_diskless(&nd.nd_swap, "/swap", 0);
a336 1
		 * XXX-smurph
d340 1
a340 1
		swdevt[0].sw_vp = vp;
d350 1
a350 1
		printf("swap on %s\n", nd.nd_swap.ndm_host);
a358 2
	swdevt[0].sw_vp = NULL;

@


1.95
log
@do not expose NETDEV to userland from param.h
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.94 2012/09/10 11:10:59 jsing Exp $	*/
d673 1
d675 1
a675 1
	bcopy(pth, mp->mnt_stat.f_mntonname, MNAMELEN);
@


1.94
log
@Cleanup VFS mount string handling:

- Avoid using copyinstr() without checking the return value.

- sys_mount() has already copied the path in, so pass this to the
  filesystem mount code so that it does not have to copy it in again.

- Avoid copyinstr()/bzero() dance when we can simply bzero() and strlcpy().

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.92 2009/10/19 22:24:18 jsg Exp $	*/
d47 1
@


1.93
log
@KNF
ok md5  "can't be worse" thib@@
@
text
@d563 2
a564 2
 * It seems a bit dumb to copyinstr() the host and path here and then
 * bcopy() them in mountnfs(), but I wanted to detect errors before
d576 1
a576 1
	char pth[MNAMELEN], hst[MNAMELEN];
d580 1
a580 1
	error = copyin (data, &args, sizeof (args.version));
d587 1
a587 2
	}
	else if (args.version == NFS_ARGSVERSION) {
d590 1
a590 2
	}
	else
a621 4
	error = copyinstr(path, pth, MNAMELEN-1, &len);
	if (error)
		return (error);
	bzero(&pth[len], MNAMELEN - len);
d631 1
a631 1
	error = mountnfs(&args, mp, nam, pth, hst);
d639 2
a640 2
mountnfs(struct nfs_args *argp, struct mount *mp, struct mbuf *nam, char *pth,
    char *hst)
@


1.92
log
@antsy
no binary change apart from nfsm_reqhead() which is clearly correct.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.91 2009/09/02 18:20:54 thib Exp $	*/
d260 1
a260 1
	 * Side effect:  Finds and configures a network interface.
d314 1
a314 1
	 * If swapping to an nfs node:  (swdevt[0].sw_dev == NODEV)
d333 5
a337 4
		/* 
		 * Next line is a hack to make swapmount() work on NFS swap files. 
		 * XXX-smurph 
		 */ 
d384 1
a384 1
	args.fh       = ndmntp->ndm_fh;
d394 1
a394 1
	 * drop fragments of long UDP messages.  (i.e. wd8003).
a868 1

a878 1

a888 1

a898 1

@


1.91
log
@Backout the asyncio/aiod change, as it causes buf's to get hung.
problem noticed by deraadt@@

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.87 2009/08/10 10:59:12 thib Exp $	*/
d101 1
a101 4
nfs_statfs(mp, sbp, p)
	struct mount *mp;
	struct statfs *sbp;
	struct proc *p;
d176 2
a177 5
nfs_fsinfo(nmp, vp, cred, p)
	struct nfsmount *nmp;
	struct vnode *vp;
	struct ucred *cred;
	struct proc *p;
d246 1
a246 1
nfs_mountroot()
d367 1
a367 4
nfs_mount_diskless(ndmntp, mntname, mntflag)
	struct nfs_dlmount *ndmntp;
	char *mntname;
	int mntflag;
d414 2
a415 4
nfs_decode_args(nmp, argp, nargp)
	struct nfsmount *nmp;
	struct nfs_args *argp;
	struct nfs_args *nargp;
d569 2
a570 6
nfs_mount(mp, path, data, ndp, p)
	struct mount *mp;
	const char *path;
	void *data;
	struct nameidata *ndp;
	struct proc *p;
d644 2
a645 5
mountnfs(argp, mp, nam, pth, hst)
	struct nfs_args *argp;
	struct mount *mp;
	struct mbuf *nam;
	char *pth, *hst;
d743 1
a743 3
nfs_root(mp, vpp)
	struct mount *mp;
	struct vnode **vpp;
d761 1
a761 5
nfs_sync(mp, waitfor, cred, p)
	struct mount *mp;
	int waitfor;
	struct ucred *cred;
	struct proc *p;
d802 1
a802 4
nfs_vget(mp, ino, vpp)
	struct mount *mp;
	ino_t ino;
	struct vnode **vpp;
d813 1
a813 1
	   size_t newlen, struct proc *p)
d866 1
a866 4
nfs_fhtovp(mp, fhp, vpp)
	struct mount *mp;
	struct fid *fhp;
	struct vnode **vpp;
d877 1
a877 3
nfs_vptofh(vp, fhp)
	struct vnode *vp;
	struct fid *fhp;
d888 1
a888 4
nfs_start(mp, flags, p)
	struct mount *mp;
	int flags;
	struct proc *p;
d899 1
a899 6
nfs_quotactl(mp, cmd, uid, arg, p)
	struct mount *mp;
	int cmd;
	uid_t uid;
	caddr_t arg;
	struct proc *p;
d910 2
a911 5
nfs_checkexp(mp, nam, exflagsp, credanonp)
	struct mount *mp;
	struct mbuf *nam;
	int *exflagsp;
	struct ucred **credanonp;
@


1.90
log
@move to having requests on a per nfsmount tailq instead of one global one.
also make the rexmit timeout per nfsmount, and make sure to start/stop the
timer appropriately.

now the nfs_timer() only fires if there is work todo, not always at nfs_ticks
(it did, even if there where no nfsmounts in the system!).

OK blambert@@
@
text
@d614 3
a616 4
	if (nfs_numaiods == -1) {
		error = nfs_set_naiod(NFS_DEFASYNCDAEMON);
		if (error)
			return (error);
d674 3
a676 3
		nmp = malloc(sizeof(*nmp), M_NFSMNT, M_WAITOK|M_ZERO);
		mp->mnt_data = nmp;
		TAILQ_INIT(&nmp->nm_bufq);
d842 1
a842 1
	int rv, naiods;
d874 5
a878 7
		naiods = nfs_numaiods;
		rv = sysctl_int(oldp, oldlenp, newp, newlen, &naiods);
		if (newp && rv == 0) {
			if (naiods < 0)
				return (EINVAL);
			rv = nfs_set_naiod(naiods);
		}
@


1.89
log
@Rework the way we do async I/O in nfs. Introduce separate buf queues for
each mount, and when work is "found", peg an aiod to that mount todo the
I/O. Make nfs_asyncio() a bit smarter when deciding when to do asyncio
and when to force it sync, this is done by keeping the aiod's one two lists,
an "idle" and an "all" list, so asyncio is only done when there are aiods
hanging around todo it for us or are already pegged to the mount.

Idea liked by at least beck@@ (and I think art@@).
Extensive testing done by myself and jasper and a few others on various
arch's.

Ideas/Code from Net/Free.

OK blambert@@.
@
text
@d703 2
d753 1
@


1.88
log
@Teach nfsm_fhtom about nfsm_info structs

ok thib@@
@
text
@d614 4
a617 3
	if (nfs_niothreads < 0) {
		nfs_niothreads = 4;
		nfs_getset_niothreads(1);
d675 3
a677 3
		nmp = malloc(sizeof(struct nfsmount), M_NFSMNT,
		    M_WAITOK|M_ZERO);
		mp->mnt_data = (qaddr_t)nmp;
d840 1
a840 1
	int rv;
d872 7
a878 5
		nfs_getset_niothreads(0);

		rv = sysctl_int(oldp, oldlenp, newp, newlen, &nfs_niothreads);
		if (newp)
			nfs_getset_niothreads(1);
@


1.87
log
@Use an RB tree instead of a hashtable for fh/node lookups.

Idea from NetBSD.

OK blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.82 2009/06/02 23:16:59 thib Exp $	*/
d130 1
a130 1
	nfsm_fhtom(&info.nmi_mb, vp, info.nmi_v3);
d194 1
a194 1
	nfsm_fhtom(&info.nmi_mb, vp, 1);
@


1.86
log
@group all of the on-stack variables that are uses by the nfsm_macros
to keep the data munging "state" into an nfsm_info structure. Each
function now has this structure on its stack, and it and its members
are now passed around so that the macros/functions can work there magic.

this will make removing the nfsm_* macros way easier.

Idea/code picked up from DragonflyBSD.

Tested by krw@@, jacekm@@ and myself.

OK blambert@@.
@
text
@d701 2
@


1.85
log
@(struct foo *)0 -> NULL, every where I could find it.

OK blambert@@
@
text
@d108 1
d111 1
a111 1
	caddr_t dpos, cp2;
d113 1
a113 2
	int error = 0, v3 = (nmp->nm_flag & NFSMNT_NFSV3), retattr;
	struct mbuf *mreq, *mrep = NULL, *md, *mb;
d118 2
d126 1
a126 1
	if (v3 && (nmp->nm_flag & NFSMNT_GOTFSINFO) == 0)
d129 2
a130 2
	mb = mreq = nfsm_reqhead(NFSX_FH(v3));
	nfsm_fhtom(&mb, vp, v3);
d132 4
a135 3
	error = nfs_request(vp, mreq, NFSPROC_FSSTAT, p, cred, &mrep,
	    &md, &dpos);
	if (v3)
d138 1
a138 1
		m_freem(mrep);
d142 1
a142 1
	nfsm_dissect(sfp, struct nfs_statfs *, NFSX_STATFS(v3));
d144 1
a144 1
	if (v3) {
d168 1
a168 1
	m_freem(mrep);
d186 1
d189 1
a189 1
	caddr_t dpos, cp2;
a190 1
	struct mbuf *mreq, *mrep, *md, *mb;
d193 2
a194 2
	mb = mreq = nfsm_reqhead(NFSX_FH(1));
	nfsm_fhtom(&mb, vp, 1);
d196 3
a198 2
	error = nfs_request(vp, mreq, NFSPROC_FSINFO, p, cred, &mrep,
	    &md, &dpos);
d202 1
a202 1
		m_freem(mrep);
d238 1
a238 1
	m_freem(mrep);
@


1.84
log
@Make the callers of nfs_request() responsible for freeing the reply mbuf,
if the reply is an error and retire the NFS_RETERR hack. For NFSv3 mounts
the flag was set and reply mbuf not freed to allow the callers to handle
the post-op attributes, or just free the mbuf for NFSv2.

Tested by myself and jasper@@ on various arch's.
OK blambert@@.
@
text
@d544 1
a544 1
			while (nfs_connect(nmp, (struct nfsreq *)0)) {
d706 1
a706 1
	    (error = nfs_connect(nmp, (struct nfsreq *)0)))
@


1.83
log
@Demacro nfsm_lookup for great justice.

Thanks to ckuethe for saving much typing with a drive-by perl script.

ok thib@@
@
text
@d129 3
a131 7
	if ((error = nfs_request(vp, mreq, NFSPROC_FSSTAT, p, cred, &mrep,
	    &md, &dpos)) != 0) {
		if (error & NFSERR_RETERR)
			error &= ~NFSERR_RETERR;
		else
			goto nfsmout;
	}
d135 1
a135 2
		if (mrep != NULL)
			m_freem(mrep);
d138 1
d192 20
a211 6
	if ((error = nfs_request(vp, mreq, NFSPROC_FSINFO, p, cred, &mrep,
	    &md, &dpos)) != 0) {
		if (error & NFSERR_RETERR)
			error &= ~NFSERR_RETERR;
		else
			goto nfsmout;
d213 18
a230 33
	nfsm_postop_attr(vp, retattr);
	if (!error) {
		nfsm_dissect(fsp, struct nfsv3_fsinfo *, NFSX_V3FSINFO);
		pref = fxdr_unsigned(u_int32_t, fsp->fs_wtpref);
		if (pref < nmp->nm_wsize)
			nmp->nm_wsize = (pref + NFS_FABLKSIZE - 1) &
				~(NFS_FABLKSIZE - 1);
		max = fxdr_unsigned(u_int32_t, fsp->fs_wtmax);
		if (max < nmp->nm_wsize) {
			nmp->nm_wsize = max & ~(NFS_FABLKSIZE - 1);
			if (nmp->nm_wsize == 0)
				nmp->nm_wsize = max;
		}
		pref = fxdr_unsigned(u_int32_t, fsp->fs_rtpref);
		if (pref < nmp->nm_rsize)
			nmp->nm_rsize = (pref + NFS_FABLKSIZE - 1) &
				~(NFS_FABLKSIZE - 1);
		max = fxdr_unsigned(u_int32_t, fsp->fs_rtmax);
		if (max < nmp->nm_rsize) {
			nmp->nm_rsize = max & ~(NFS_FABLKSIZE - 1);
			if (nmp->nm_rsize == 0)
				nmp->nm_rsize = max;
		}
		pref = fxdr_unsigned(u_int32_t, fsp->fs_dtpref);
		if (pref < nmp->nm_readdirsize)
			nmp->nm_readdirsize = (pref + NFS_DIRBLKSIZ - 1) &
				~(NFS_DIRBLKSIZ - 1);
		if (max < nmp->nm_readdirsize) {
			nmp->nm_readdirsize = max & ~(NFS_DIRBLKSIZ - 1);
			if (nmp->nm_readdirsize == 0)
				nmp->nm_readdirsize = max;
		}
		nmp->nm_flag |= NFSMNT_GOTFSINFO;
d232 2
@


1.82
log
@give the retransmission count booking keeping a facelift,
just store the maximun amount of rexmits in one place and
cleanup. Also make sure this only effects soft mounts.

OK blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.80 2008/12/24 02:43:52 thib Exp $	*/
d129 7
a135 1
	nfsm_request(vp, NFSPROC_FSSTAT, p, cred);
d196 7
a202 1
	nfsm_request(vp, NFSPROC_FSINFO, p, cred);
@


1.81
log
@Convert macros to functions to reduce kernel memory usage.

In snaps for a while (way too long, according to deraadt@@)
@
text
@a69 3
#define	NQ_DEADTHRESH	NQ_NEVERDEAD	/* Default nm_deadthresh */
#define	NQ_NEVERDEAD	9	/* Greater than max. nm_timeouts */

d443 4
a446 5
	if ((argp->flags & NFSMNT_RETRANS) && argp->retrans > 1) {
		nmp->nm_retry = argp->retrans;
		if (nmp->nm_retry > NFS_MAXREXMIT)
			nmp->nm_retry = NFS_MAXREXMIT;
	}
a501 3
	if ((argp->flags & NFSMNT_DEADTHRESH) && argp->deadthresh >= 1 &&
		argp->deadthresh <= NQ_NEVERDEAD)
		nmp->nm_deadthresh = argp->deadthresh;
a549 1
	nargp->deadthresh = nmp->nm_deadthresh;
a674 1
	nmp->nm_deadthresh = NQ_DEADTHRESH;
@


1.80
log
@Replace the TRUE/FALSE defines with 1/0 respectively. This doesn't
hurt readability and it was just plain annoying seeing them defined
in every other .c file.

OK blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.79 2008/07/28 13:35:14 thib Exp $	*/
d131 1
a131 1
	nfsm_fhtom(vp, v3);
d192 1
a192 1
	nfsm_fhtom(vp, 1);
@


1.79
log
@
dont stuff nfs mount point flags into the statfs f_flags member, its
wrong. But this was harmless anyway since sys_statfs() sets this field
corrently after calling VFS_STATFS();

ok pedro@@, blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.78 2008/07/10 18:17:56 thib Exp $	*/
a99 3
#define TRUE	1
#define	FALSE	0

d611 1
a611 1
		nfs_getset_niothreads(TRUE);
@


1.78
log
@nuke two bogus ARGSUSED
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.77 2008/07/05 12:51:04 thib Exp $	*/
a143 1
	sbp->f_flags = nmp->nm_flag;
@


1.77
log
@
Clean up some old dead code, mostly nqnfs and kerberos leftovers
for uid goo, mostly zapping unused members from various structures.

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.76 2008/06/14 22:44:07 blambert Exp $	*/
a774 1
/* ARGSUSED */
@


1.76
log
@Replace nfsm_build/bcopy with nfsm_{buf,str}tombuf functions in
filehandle -> mbuf write macros.

Removes `magic' variable cp which was used only in these macros,
and should lead to marginally better mbuf packing as well.

`slap it in' thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.75 2008/06/13 22:11:32 blambert Exp $	*/
a675 1
		TAILQ_INIT(&nmp->nm_uidlruhead);
@


1.75
log
@Kill one-liner macro which obfuscated mbuf pointer assignment.

Rescue nfsm_reqhead macro name and rename nfsm_reqh.

End of one-liners from nfsm_subs.h.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.74 2008/06/12 20:24:06 blambert Exp $	*/
a113 1
	caddr_t cp;
a187 1
	caddr_t cp;
@


1.74
log
@Remove now-vestigial bpos pointer from NFS. For building outgoing
NFS mbufs, mbufs now contain all their internal buffer state internally,
the way god intended.

ok thib@@

testing johan@@ (and possibly merdely@@; this diff's been around for a bit...)
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.73 2008/06/11 04:52:27 blambert Exp $	*/
d134 1
a134 1
	nfsm_reqhead(vp, NFSPROC_FSSTAT, NFSX_FH(v3));
d197 1
a197 1
	nfsm_reqhead(vp, NFSPROC_FSINFO, NFSX_FH(1));
@


1.73
log
@Canonical for() -> queue.h FOREACH macro conversions.
Also, it is historical practice to #include <sys/queue.h>
when using queue.h macros.

ok thib@@ krw@@

special thanks to krw@@ for reminders vice violence
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.72 2008/04/25 12:33:41 blambert Exp $	*/
d117 1
a117 1
	caddr_t bpos, dpos, cp2;
d192 1
a192 1
	caddr_t bpos, dpos, cp2;
@


1.72
log
@Plug potential mbuf leak by changing m_free to m_freem.

From NetBSD.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.71 2008/04/14 13:46:13 blambert Exp $	*/
d54 1
d799 1
a799 2
	for (vp = LIST_FIRST(&mp->mnt_vnodelist); vp != NULL;
	     vp = LIST_NEXT(vp, v_mntvnodes)) {
@


1.71
log
@Rework NFS mbuf write routines:

nfsm_uiotombuf():
- no meaningful return, function becomes void
- replace frankensteined uiomove/MGET with actual call to uiomove

nfsm_strtmbuf():
- no meaningful return, becomes void
- rename and reorder parameters to be consistent with other functions
- becomes wrapper to nfsm_uiotombuf

nfsm_buftombuf():
- new function; unused but slated for future use
- wrapper to nfsm_uiotombuf

As a bonus, making these functions void removes much unneeded code and
garbage collects `magic' variable t2 which was only used (invisibly)
by the macros from nfsm_subs.h

Preps the way for removing much more NFS goo...

testing by myself, thib@@ and merdely@@
ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.70 2008/03/16 19:42:57 otto Exp $	*/
d140 1
a140 1
			m_free(mrep);
@


1.70
log
@Widen some struct statfs fields to support large filesystem stata
and add some to be able to support statvfs(2). Do the compat dance
to provide backward compatibility.  ok thib@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.69 2008/01/06 18:38:32 deraadt Exp $	*/
d115 1
a115 1
	int32_t t1, t2;
d189 1
a189 1
	int32_t t1, t2;
@


1.69
log
@diff missed in previous commit:
More NFS-related kernel shrinkage...

When you use a macro ~200 times, it tends to bloat your code, so make a
function out of it.

Shaves ~8.5 kB from my kernel.

ok thib@@, "looks good" krw@@

In snaps for 1+ week with no negative reports.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.68 2007/09/20 12:54:31 thib Exp $	*/
d49 1
d149 1
a149 1
		sbp->f_blocks = (u_int32_t)(tquad / (u_quad_t)NFS_FABLKSIZE);
d151 1
a151 1
		sbp->f_bfree = (u_int32_t)(tquad / (u_quad_t)NFS_FABLKSIZE);
d153 8
a160 5
		sbp->f_bavail = (int32_t)((quad_t)tquad / (quad_t)NFS_FABLKSIZE);
		sbp->f_files = (fxdr_unsigned(int32_t,
		    sfp->sf_tfiles.nfsuquad[1]) & 0x7fffffff);
		sbp->f_ffree = (fxdr_unsigned(int32_t,
		    sfp->sf_ffiles.nfsuquad[1]) & 0x7fffffff);
d169 1
a169 7
	if (sbp != &mp->mnt_stat) {
		bcopy(mp->mnt_stat.f_mntonname, sbp->f_mntonname, MNAMELEN);
		bcopy(mp->mnt_stat.f_mntfromname, sbp->f_mntfromname, MNAMELEN);
		bcopy(&mp->mnt_stat.mount_info.nfs_args,
		    &sbp->mount_info.nfs_args, sizeof(struct nfs_args));
	}
	strncpy(&sbp->f_fstypename[0], mp->mnt_vfc->vfc_name, MFSNAMELEN);
@


1.68
log
@MALLOC/FREE -> malloc/free + M_ZERO.
Uneeded includes and casts...

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.67 2007/09/11 13:41:52 blambert Exp $	*/
d118 1
a118 1
	struct mbuf *mreq, *mrep = NULL, *md, *mb, *mb2;
d195 1
a195 1
	struct mbuf *mreq, *mrep, *md, *mb, *mb2;
@


1.67
log
@Replace nfsm_reqdone and nfsm_srvdone macros inline. No binary change.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.66 2007/06/20 15:00:43 thib Exp $	*/
d676 2
a677 3
		MALLOC(nmp, struct nfsmount *, sizeof (struct nfsmount),
		    M_NFSMNT, M_WAITOK);
		bzero((caddr_t)nmp, sizeof (struct nfsmount));
@


1.66
log
@READDIRPLUS is v3 only, bail out if the mount isnt a v3.
Prevents weird things from happening.

ok tedu@@,pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.65 2007/06/13 18:05:27 thib Exp $	*/
d172 2
a173 1
	nfsm_reqdone;
d235 2
a236 1
	nfsm_reqdone;
@


1.65
log
@- Remove the nm_inprog member from struct nfsmount;
  NQNFS leftover.
- Remove setting of the NFSMNT_DISMINPROG flag, its set
  and unset in the same function servering no purpose,
  im however going to reuse it shortly.
- kill an if thats always true (NFSMNT_KERB cant be set)
- misc cleanup and KNF.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.64 2007/06/12 19:25:27 thib Exp $	*/
d610 3
@


1.64
log
@remove some unused externs;
smallish cleanup (move prototypes and externs togather).

ok toby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.63 2007/04/12 13:24:39 thib Exp $	*/
a687 1
	nmp->nm_inprog = NULLVP;
d729 1
a729 3
/*
 * unmount system call
 */
d731 1
a731 4
nfs_unmount(mp, mntflags, p)
	struct mount *mp;
	int mntflags;
	struct proc *p;
d734 4
a737 1
	int error, flags = 0;
a740 8
	nmp = VFSTONFS(mp);
	/*
	 * Goes something like this..
	 * - Call vflush() to clear out vnodes for this file system,
	 *   except for the root vnode.
	 * - Close the socket
	 * - Free up the data structures
	 */
a741 6
	/*
	 * Must handshake with nqnfs_clientd() if it is active.
	 */
	nmp->nm_flag |= NFSMNT_DISMINPROG;
	while (nmp->nm_inprog != NULLVP)
		(void) tsleep((caddr_t)&lbolt, PSOCK, "nfsdism", 0);
d743 1
a743 2
	if (error) {
		nmp->nm_flag &= ~NFSMNT_DISMINPROG;
a744 8
	}

	/*
	 * We are now committed to the unmount.
	 * For NQNFS, let the server daemon free the nfsmount structure.
	 */
	if (nmp->nm_flag & NFSMNT_KERB)
		nmp->nm_flag |= NFSMNT_DISMNT;
d748 1
a748 3

	if ((nmp->nm_flag & NFSMNT_KERB) == 0)
		free((caddr_t)nmp, M_NFSMNT);
@


1.63
log
@remove unused members from struct nfsmount and nfsnode;

ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.62 2006/05/29 16:49:42 avsm Exp $	*/
d73 1
d75 3
a77 3
int nfs_sysctl(int *, u_int, void *, size_t *, void *, size_t, struct proc *);
int nfs_checkexp(struct mount *mp, struct mbuf *nam,
	 int *extflagsp, struct ucred **credanonp);
a97 5
extern u_int32_t nfs_procids[NFS_NPROCS];
extern u_int32_t nfs_prog, nfs_vers;

struct mount *nfs_mount_diskless(struct nfs_dlmount *, char *, int);

a798 2

extern int syncprt;
@


1.62
log
@revert vfs.nfs.privport sysctl, broke a few architectures
requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.60 2006/04/19 11:55:55 pedro Exp $	*/
a691 1
	CIRCLEQ_INIT(&nmp->nm_timerhead);
@


1.61
log
@Add support for NFS mounts to be from non-reserved ports:

- new sysctl vfs.nfs.privport to require NFS mount requests to be on
reserved ports when set to 1 (the default).
- mountd now automatically sets the sysctl depending on the -n flag.
- add mountd_flags to rc.conf to enable the -n flag at boot.
deraadt@@ ok
@
text
@a72 1
extern int nfs_privport;
a913 2
	case NFS_PRIVPORT:
		return(sysctl_int(oldp, oldlenp, newp, newlen, &nfs_privport));
@


1.60
log
@Remove unused mount list simple_lock() goo
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.59 2005/12/27 18:31:12 miod Exp $	*/
d73 1
d915 2
@


1.59
log
@Remove unused sw_nblks field of struct swdevt. Then, remove swapconf()
which duplicates work done by uvm_swap_init().
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.58 2005/11/30 10:35:08 pedro Exp $	*/
a281 1
	simple_lock(&mountlist_slock);
a282 1
	simple_unlock(&mountlist_slock);
@


1.58
log
@No need for vfs_busy() and vfs_unbusy() to take a process pointer
anymore. Testing by jolan@@, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.57 2005/05/22 17:37:49 pedro Exp $	*/
a359 1
		swdevt[0].sw_nblks = n;
a365 1
	swdevt[0].sw_nblks = 0;
@


1.57
log
@optimize nfs_sync() a bit, by not iterating over the list of vnodes
belonging to a mount point if we want to skip all of them, okay art@@ a
couple of days ago, commit it deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.56 2005/03/31 21:39:44 deraadt Exp $	*/
d285 1
a285 1
	vfs_unbusy(mp, procp);
d331 1
a331 1
		vfs_unbusy(mp, procp);
@


1.56
log
@re-commit marius commit:
> fix preposterous time warnings in the nfs client; caused by false hits
> in the attribute cache
> based on original fix by pedro@@, ok pedro@@, tedu@@; testing kettenis@@
was backed out because too close to release
put back in now, since tree is unlocked.  unfortunately it appears that even
after MANY MAILS ON THIS SUBJECT, NOONE HAS DONE THIS.  WTF?  Noone wants
to FINISH jobs anymore?
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.54 2005/01/24 00:14:40 marius Exp $	*/
d826 6
d843 1
a843 2
		if (VOP_ISLOCKED(vp) || LIST_FIRST(&vp->v_dirtyblkhd) == NULL ||
		    waitfor == MNT_LAZY)
d852 1
@


1.55
log
@backout nfs_subs.c rev1.51 nfs_vfsops.c rev1.54:
fix preposterous time warnings in the nfs client; caused by false hits
in the attribute cache

too close to release, save for immediately after unlock
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.53 2004/06/21 23:50:38 tholo Exp $	*/
a261 9

	/*
	 * XXX time must be non-zero when we init the interface or else
	 * the arp code will wedge.  [Fixed now in if_ether.c]
	 * However, the NFS attribute cache gives false "hits" when
	 * time_second < NFS_ATTRTIMEO(np) so keep this in for now.
	 */
	if (time_second < NFS_MAXATTRTIMO)
		time_second = NFS_MAXATTRTIMO;
@


1.54
log
@fix preposterous time warnings in the nfs client; caused by false hits
in the attribute cache

based on original fix by pedro@@, ok pedro@@, tedu@@; testing kettenis@@
@
text
@d264 9
@


1.53
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.52 2004/04/12 23:58:10 tedu Exp $	*/
a261 9

	/*
	 * XXX time must be non-zero when we init the interface or else
	 * the arp code will wedge.  [Fixed now in if_ether.c]
	 * However, the NFS attribute cache gives false "hits" when
	 * time_second < NFS_ATTRTIMEO(np) so keep this in for now.
	 */
	if (time_second < NFS_MAXATTRTIMO)
		time_second = NFS_MAXATTRTIMO;
@


1.52
log
@make sockargs take void *, combine a len check.
from pedro martelletto, ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.51 2003/08/14 07:46:40 mickey Exp $	*/
d267 1
a267 1
	 * time.tv_sec < NFS_ATTRTIMEO(np) so keep this in for now.
d269 2
a270 2
	if (time.tv_sec < NFS_MAXATTRTIMO)
		time.tv_sec = NFS_MAXATTRTIMO;
@


1.51
log
@constify vfsops; tedu@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.50 2003/06/02 23:28:20 millert Exp $	*/
d661 1
a661 1
	error = sockargs(&nam, (caddr_t)args.addr, args.addrlen, MT_SONAME);
@


1.50
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.49 2002/12/11 02:38:52 mickey Exp $	*/
d81 1
a81 1
struct vfsops nfs_vfsops = {
@


1.49
log
@in mountroot:
check system clock against root atime, not mtime, since the
later does not change that often and is a bad mark to sync unto.
remove a bogus splnet() i've put way back in 96 w/ v3 integration.
miod@@ tested on diskless sparc and sparc64, mickey@@ on hppa
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.48 2002/03/14 01:27:13 millert Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.48
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.47 2002/02/23 23:47:13 art Exp $	*/
d303 1
a303 1
	n = attr.va_mtime.tv_sec;
a307 5

	/* 
	 * XXX splnet, so networks will receive...
	 */
	splnet();
@


1.47
log
@Sigh. The diff is out for testing for three months without a single problem.
Two days after commit people report serious lockups all over the place.
Back out nfs locking changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.45 2002/02/10 22:02:05 nate Exp $	*/
d78 3
a80 5
int nfs_sysctl
    __P((int *, u_int, void *, size_t *, void *, size_t, struct proc *));
int nfs_checkexp
    __P((struct mount *mp, struct mbuf *nam,
	 int *extflagsp, struct ucred **credanonp));
d104 1
a104 2
struct mount *nfs_mount_diskless
    __P((struct nfs_dlmount *, char *, int));
@


1.46
log
@More locking in the NFS code
@
text
@d184 1
a184 1
	vput(vp);
@


1.45
log
@theo doesn't like this code
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.44 2002/01/16 21:51:16 ericj Exp $	*/
d184 1
a184 1
	vrele(vp);
@


1.44
log
@
use queue.h macro's
remove register
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.43 2002/01/11 01:20:56 nate Exp $	*/
a932 4
	case NFS_NORSVPORT:
		rv = sysctl_int(oldp, oldlenp, newp, newlen, &nfs_norsvport);
		return rv;
		
@


1.43
log
@Add a new sysctl that removes the requirement for reserved ports to be
used by the nfs server.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.42 2001/12/19 08:58:06 art Exp $	*/
d118 1
a118 1
	register struct statfs *sbp;
d121 5
a125 5
	register struct vnode *vp;
	register struct nfs_statfs *sfp = NULL;
	register caddr_t cp;
	register u_int32_t *tl;
	register int32_t t1, t2;
d194 2
a195 2
	register struct nfsmount *nmp;
	register struct vnode *vp;
d199 4
a202 4
	register struct nfsv3_fsinfo *fsp;
	register caddr_t cp;
	register int32_t t1, t2;
	register u_int32_t *tl, pref, max;
d646 1
a646 1
		register struct nfsmount *nmp = VFSTONFS(mp);
d686 2
a687 2
	register struct nfs_args *argp;
	register struct mount *mp;
d691 1
a691 1
	register struct nfsmount *nmp;
d769 1
a769 1
	register struct nfsmount *nmp;
d843 1
a843 1
	register struct vnode *vp;
d850 2
a851 3
	for (vp = mp->mnt_vnodelist.lh_first;
	     vp != NULL;
	     vp = vp->v_mntvnodes.le_next) {
d858 1
a858 1
		if (VOP_ISLOCKED(vp) || vp->v_dirtyblkhd.lh_first == NULL ||
d949 1
a949 1
	register struct mount *mp;
d1006 1
a1006 1
	register struct mount *mp;
@


1.42
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.38 2001/11/14 23:37:33 mickey Exp $	*/
d934 4
@


1.41
log
@minor fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.40 2001/12/10 02:19:34 art Exp $	*/
a750 2
	mp->mnt_fs_bshift = DEV_BSHIFT;
	mp->mnt_dev_bshift = DEV_BSHIFT;
d859 2
a860 3
		if (waitfor == MNT_LAZY ||
		    (LIST_EMPTY(&vp->v_dirtyblkhd) &&
		     vp->v_uobj.uo_npages == 0))
@


1.41.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.44 2002/01/16 21:51:16 ericj Exp $	*/
d118 1
a118 1
	struct statfs *sbp;
d121 5
a125 5
	struct vnode *vp;
	struct nfs_statfs *sfp = NULL;
	caddr_t cp;
	u_int32_t *tl;
	int32_t t1, t2;
d194 2
a195 2
	struct nfsmount *nmp;
	struct vnode *vp;
d199 4
a202 4
	struct nfsv3_fsinfo *fsp;
	caddr_t cp;
	int32_t t1, t2;
	u_int32_t *tl, pref, max;
d646 1
a646 1
		struct nfsmount *nmp = VFSTONFS(mp);
d686 2
a687 2
	struct nfs_args *argp;
	struct mount *mp;
d691 1
a691 1
	struct nfsmount *nmp;
d771 1
a771 1
	struct nfsmount *nmp;
d845 1
a845 1
	struct vnode *vp;
d852 3
a854 2
	for (vp = LIST_FIRST(&mp->mnt_vnodelist); vp != NULL;
	     vp = LIST_NEXT(vp, v_mntvnodes)) {
a936 4
	case NFS_NORSVPORT:
		rv = sysctl_int(oldp, oldlenp, newp, newlen, &nfs_norsvport);
		return rv;
		
d949 1
a949 1
	struct mount *mp;
d1006 1
a1006 1
	struct mount *mp;
@


1.41.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.41.2.1 2002/01/31 22:55:47 niklas Exp $	*/
d78 5
a82 3
int nfs_sysctl(int *, u_int, void *, size_t *, void *, size_t, struct proc *);
int nfs_checkexp(struct mount *mp, struct mbuf *nam,
	 int *extflagsp, struct ucred **credanonp);
d106 2
a107 1
struct mount *nfs_mount_diskless(struct nfs_dlmount *, char *, int);
d936 4
@


1.41.2.3
log
@Resurrect Costas nfs locking on the UBC branch. It's needed here.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.46 2002/02/22 20:19:14 csapuntz Exp $	*/
d181 1
a181 1
	vput(vp);
@


1.41.2.4
log
@Huge sync to NetBSD plus lots of bugfixes.
 - uvm is as in netbsd-current minus uvm_map forward merge.
 - various locking bugfixes in nfs.
 - make sure that all specops and fifoops are correct in all vnodeop vectors.
 - make the filesystem code more like filsystem code and less like vm code.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.41.2.3 2002/10/29 18:31:51 art Exp $	*/
d144 1
a144 1
		nfsm_postop_attr(vp, retattr, 0);
d208 1
a208 1
	nfsm_postop_attr(vp, retattr, 0);
@


1.41.2.5
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d303 1
a303 1
	n = attr.va_atime.tv_sec;
d308 5
@


1.40
log
@Merge in struct uvm_vnode into struct vnode.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.39 2001/11/27 05:27:12 art Exp $	*/
d752 1
a752 1
	mp->mnt_dev_bshift = -1;
d861 1
a861 1
		if (waitfor == MNT_LAZY || VOP_ISLOCKED(vp) ||
@


1.39
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.38 2001/11/14 23:37:33 mickey Exp $	*/
d863 1
a863 1
		     vp->v_uvm.u_obj.uo_npages == 0))
@


1.38
log
@allow swaples diskless configs; deradt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.37 2001/07/27 05:43:17 csapuntz Exp $	*/
d751 2
d861 3
a863 2
		if (VOP_ISLOCKED(vp) || vp->v_dirtyblkhd.lh_first == NULL ||
		    waitfor == MNT_LAZY)
@


1.37
log
@

Don't accept arbitrary size file handles as the kernel buffer we are copying
it into is fixed and on the stack
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.36 2001/06/30 08:35:27 csapuntz Exp $	*/
d289 2
a290 1
	nfs_boot_getfh(&nd.nd_boot, "root", &nd.nd_root);
d345 2
d348 28
a375 19
	nfs_boot_getfh(&nd.nd_boot, "swap", &nd.nd_swap);
	mp = nfs_mount_diskless(&nd.nd_swap, "/swap", 0);
	nfs_root(mp, &vp);
	vfs_unbusy(mp, procp);
	printf("swap on %s\n", nd.nd_swap.ndm_host);

	/*
	 * Since the swap file is not the root dir of a file system,
	 * hack it to a regular file.
	 */
	vp->v_type = VREG;
	vp->v_flag = 0;
	/* 
	 * Next line is a hack to make swapmount() work on NFS swap files. 
	 * XXX-smurph 
	 */ 
	swdevt[0].sw_dev = NETDEV;
	/* end hack */
	swdevt[0].sw_vp = vp;
d377 1
a377 7
	/*
	 * Find out how large the swap file is.
	 */
	error = VOP_GETATTR(vp, &attr, procp->p_ucred, procp);
	if (error)
		panic("nfs_mountroot: getattr for swap");
	n = (long) (attr.va_size >> DEV_BSHIFT);
d379 1
a379 1
	printf("swap size: 0x%lx (blocks)\n", n);
d381 8
a388 1
	swdevt[0].sw_nblks = n;
@


1.36
log
@

Get root filehandle via nfs_root.

Fix problem with diskless clients
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.35 2001/06/25 03:28:12 csapuntz Exp $	*/
d646 2
@


1.35
log
@Remove NQNFS
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.34 2001/06/24 21:16:20 csapuntz Exp $	*/
d107 1
a107 1
    __P((struct nfs_dlmount *, char *, int, struct vnode **));
d290 2
a291 1
	mp = nfs_mount_diskless(&nd.nd_root, "/", 0, &vp);
a299 1
	rootvp = vp;
d303 1
a303 1
	error = VOP_GETATTR(vp, &attr, procp->p_ucred, procp);
d346 2
a347 1
	mp = nfs_mount_diskless(&nd.nd_swap, "/swap", 0, &vp);
d384 1
a384 1
nfs_mount_diskless(ndmntp, mntname, mntflag, vpp)
a387 1
	struct vnode **vpp;
d426 1
a426 1
	error = mountnfs(&args, mp, m, mntname, args.hostname, vpp);
a605 1
	struct vnode *vp;
d662 1
a662 1
	error = mountnfs(&args, mp, nam, pth, hst, &vp);
d670 1
a670 1
mountnfs(argp, mp, nam, pth, hst, vpp)
a674 1
	struct vnode **vpp;
@


1.34
log
@Change handling of NFS root vnode. Moves recognition of NFS root vnode into
nfs_nget.

Root vnode no longer pinned in inode cache. Also, forceable unmounts of an
nfs file system now work even if there are extra references to the NFS root.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.33 2001/05/16 12:48:32 ho Exp $	*/
a69 1
#include <nfs/nqnfs.h>
d72 3
a526 3
	if ((argp->flags & NFSMNT_LEASETERM) && argp->leaseterm >= 2 &&
		argp->leaseterm <= NQ_MAXLEASE)
		nmp->nm_leaseterm = argp->leaseterm;
a529 1

a577 1
	nargp->leaseterm = nmp->nm_leaseterm;
d640 1
a640 1
		 * v3 and/or nqnfs.
d642 2
a643 2
		args.flags = (args.flags & ~(NFSMNT_NFSV3|NFSMNT_NQNFS)) |
		    (nmp->nm_flag & (NFSMNT_NFSV3|NFSMNT_NQNFS));
a695 8
	if (argp->flags & NFSMNT_NQNFS)
		/*
		 * We have to set mnt_maxsymlink to a non-zero value so
		 * that COMPAT_43 routines will know that we are setting
		 * the d_type field in directories (and can zero it for
		 * unsuspecting binaries).
		 */
		mp->mnt_maxsymlinklen = 1;
a702 1
	nmp->nm_leaseterm = NQ_DEFLEASE;
d786 1
a786 1
	if (nmp->nm_flag & (NFSMNT_NQNFS | NFSMNT_KERB))
d792 1
a792 1
	if ((nmp->nm_flag & (NFSMNT_NQNFS | NFSMNT_KERB)) == 0)
@


1.33
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.32 2001/02/20 01:50:11 assar Exp $	*/
a681 1
	struct nfsnode *np;
a682 1
	struct vattr attrs;
a749 13
	/*
	 * A reference count is needed on the nfsnode representing the
	 * remote root.  If this object is not persistent, then backward
	 * traversals of the mount point (i.e. "..") will not work if
	 * the nfsnode gets flushed out of the cache. Ufs does not have
	 * this problem, because one can identify root inodes by their
	 * number == ROOTINO (2).
	 */
	error = nfs_nget(mp, (nfsfh_t *)nmp->nm_fh, nmp->nm_fhsize, &np);
	if (error)
		goto bad;
	*vpp = NFSTOV(np);
	VOP_GETATTR(*vpp, &attrs, curproc->p_ucred, curproc);	/* XXX */
a768 2
	struct nfsnode *np;
	struct vnode *vp;
a775 1
	 * - Check for activity on the root vnode (other than ourselves).
a777 1
	 * - Decrement reference on the vnode representing remote root.
a780 13
	/*
	 * We need to decrement the ref. count on the nfsnode representing
	 * the remote root.  See comment in mountnfs().  The VFS unmount()
	 * has done vput on this vnode, otherwise we would get deadlock!
	 */
	error = nfs_nget(mp, (nfsfh_t *)nmp->nm_fh, nmp->nm_fhsize, &np);
	if (error)
		return(error);
	vp = NFSTOV(np);
	if (vp->v_usecount > 2) {
		vput(vp);
		return (EBUSY);
	}
d788 1
a788 1
	error = vflush(mp, vp, flags);
a789 1
		vput(vp);
a800 6
	/*
	 * There are two reference counts to get rid of here.
	 */
	vrele(vp);
	vrele(vp);
	vgone(vp);
a816 1
	register struct vnode *vp;
d825 1
a825 5
	vp = NFSTOV(np);
	if (vp->v_type == VNON)
		vp->v_type = VDIR;
	vp->v_flag = VROOT;
	*vpp = vp;
@


1.32
log
@use void * consistently in vfs_mount and sys_mount.  ok @@art
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.31 2000/05/19 16:36:04 mickey Exp $	*/
a420 2
	if (m == NULL)
		panic("nfs_mountroot: mget soname for %s", mntname);
@


1.32.2.1
log
@MFC (csapuntz):
Don't accept arbitrary size file handles as the kernel buffer we are copying
it into is fixed and on the stack
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.32 2001/02/20 01:50:11 assar Exp $	*/
a651 2
	if (args.fhsize < 0 || args.fhsize > NFSX_V3FHMAX)
		return (EINVAL);
@


1.31
log
@from tsarna@@netbsd.org (sysctl changes to come later):
Death to nfsiod!

It is replaced by kernel threads that do the same thing. The number of
kernel threads used is set with the vfs.nfs.iothreads sysctl.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.30 2000/02/07 04:57:17 assar Exp $	*/
d604 1
a604 1
	caddr_t data;
d616 1
a616 1
	error = copyin (data, (caddr_t)&args, sizeof (args.version));
@


1.31.2.1
log
@Pull in patch from current (from csapuntz):
Don't accept arbitrary size file handles as the kernel buffer we are copying
it into is fixed and on the stack
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.31 2000/05/19 16:36:04 mickey Exp $	*/
a651 2
	if (args.fhsize < 0 || args.fhsize > NFSX_V3FHMAX)
		return (EINVAL);
@


1.30
log
@update to use new checkexp vfs operation
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.29 2000/01/06 03:35:37 smurph Exp $	*/
d56 1
d632 6
d970 9
d1055 1
@


1.30.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.32 2001/02/20 01:50:11 assar Exp $	*/
a55 1
#include <sys/sysctl.h>
d603 1
a603 1
	void *data;
d615 1
a615 1
	error = copyin (data, &args, sizeof (args.version));
a630 6

	if (nfs_niothreads < 0) {
		nfs_niothreads = 4;
		nfs_getset_niothreads(TRUE);
	}

a962 9
	case NFS_NIOTHREADS:
		nfs_getset_niothreads(0);

		rv = sysctl_int(oldp, oldlenp, newp, newlen, &nfs_niothreads);
		if (newp)
			nfs_getset_niothreads(1);

		return rv;

a1038 1

@


1.30.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.30.2.1 2001/05/14 22:44:58 niklas Exp $	*/
d70 1
a72 3
#define	NQ_DEADTHRESH	NQ_NEVERDEAD	/* Default nm_deadthresh */
#define	NQ_NEVERDEAD	9	/* Greater than max. nm_timeouts */

d105 1
a105 1
    __P((struct nfs_dlmount *, char *, int));
d288 1
a288 2
	mp = nfs_mount_diskless(&nd.nd_root, "/", 0);
	nfs_root(mp, &rootvp);
d297 1
d301 1
a301 1
	error = VOP_GETATTR(rootvp, &attr, procp->p_ucred, procp);
d344 1
a344 2
	mp = nfs_mount_diskless(&nd.nd_swap, "/swap", 0);
	nfs_root(mp, &vp);
d381 1
a381 1
nfs_mount_diskless(ndmntp, mntname, mntflag)
d385 1
d421 2
d426 1
a426 1
	error = mountnfs(&args, mp, m, mntname, args.hostname);
d527 3
d533 1
d582 1
d611 1
d645 1
a645 1
		 * v3.
d647 2
a648 2
		args.flags = (args.flags & ~(NFSMNT_NFSV3)) |
		    (nmp->nm_flag & (NFSMNT_NFSV3));
d668 1
a668 1
	error = mountnfs(&args, mp, nam, pth, hst);
d676 1
a676 1
mountnfs(argp, mp, nam, pth, hst)
d681 1
d684 1
d686 1
d703 8
d718 1
d754 13
d786 2
d795 1
d798 1
d802 13
d822 1
a822 1
	error = vflush(mp, NULL, flags);
d824 1
d833 1
a833 1
	if (nmp->nm_flag & NFSMNT_KERB)
d836 6
d845 1
a845 1
	if ((nmp->nm_flag & NFSMNT_KERB) == 0)
d858 1
d867 5
a871 1
	*vpp = NFSTOV(np);
@


1.30.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.30.2.2 2001/07/04 10:55:52 niklas Exp $	*/
a645 2
	if (args.fhsize < 0 || args.fhsize > NFSX_V3FHMAX)
		return (EINVAL);
@


1.30.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d289 1
a289 2
	if (nfs_boot_getfh(&nd.nd_boot, "root", &nd.nd_root, -1))
		panic("nfs_mountroot: root");
a343 2
	 *
	 * Wait 5 retries, finally no swap is cool. -mickey
d345 5
a349 5
	error = nfs_boot_getfh(&nd.nd_boot, "swap", &nd.nd_swap, 5);
	if (!error) {
		mp = nfs_mount_diskless(&nd.nd_swap, "/swap", 0);
		nfs_root(mp, &vp);
		vfs_unbusy(mp, procp);
d351 13
a363 6
		/*
		 * Since the swap file is not the root dir of a file system,
		 * hack it to a regular file.
		 */
		vp->v_type = VREG;
		vp->v_flag = 0;
d365 7
a371 17
		/* 
		 * Next line is a hack to make swapmount() work on NFS swap files. 
		 * XXX-smurph 
		 */ 
		swdevt[0].sw_dev = NETDEV;
		/* end hack */
		swdevt[0].sw_vp = vp;

		/*
		 * Find out how large the swap file is.
		 */
		error = VOP_GETATTR(vp, &attr, procp->p_ucred, procp);
		if (error)
			printf("nfs_mountroot: getattr for swap\n");
		n = (long) (attr.va_size >> DEV_BSHIFT);

		printf("swap on %s\n", nd.nd_swap.ndm_host);
d373 1
a373 1
		printf("swap size: 0x%lx (blocks)\n", n);
d375 1
a375 8
		swdevt[0].sw_nblks = n;
		return (0);
	}

	printf("WARNING: no swap\n");
	swdevt[0].sw_dev = NODEV;
	swdevt[0].sw_vp = NULL;
	swdevt[0].sw_nblks = 0;
a737 2
	mp->mnt_fs_bshift = DEV_BSHIFT;
	mp->mnt_dev_bshift = -1;
d846 2
a847 3
		if (waitfor == MNT_LAZY || VOP_ISLOCKED(vp) ||
		    (LIST_EMPTY(&vp->v_dirtyblkhd) &&
		     vp->v_uvm.u_obj.uo_npages == 0))
@


1.30.2.5
log
@Merge in trunk
@
text
@d118 1
a118 1
	struct statfs *sbp;
d121 5
a125 5
	struct vnode *vp;
	struct nfs_statfs *sfp = NULL;
	caddr_t cp;
	u_int32_t *tl;
	int32_t t1, t2;
d194 2
a195 2
	struct nfsmount *nmp;
	struct vnode *vp;
d199 4
a202 4
	struct nfsv3_fsinfo *fsp;
	caddr_t cp;
	int32_t t1, t2;
	u_int32_t *tl, pref, max;
d646 1
a646 1
		struct nfsmount *nmp = VFSTONFS(mp);
d686 2
a687 2
	struct nfs_args *argp;
	struct mount *mp;
d691 1
a691 1
	struct nfsmount *nmp;
d751 2
d771 1
a771 1
	struct nfsmount *nmp;
d845 1
a845 1
	struct vnode *vp;
d852 3
a854 2
	for (vp = LIST_FIRST(&mp->mnt_vnodelist); vp != NULL;
	     vp = LIST_NEXT(vp, v_mntvnodes)) {
d861 3
a863 2
		if (VOP_ISLOCKED(vp) || LIST_FIRST(&vp->v_dirtyblkhd) == NULL ||
		    waitfor == MNT_LAZY)
d949 1
a949 1
	struct mount *mp;
d1006 1
a1006 1
	struct mount *mp;
@


1.30.2.6
log
@Merge in -current from roughly a week ago
@
text
@d78 5
a82 3
int nfs_sysctl(int *, u_int, void *, size_t *, void *, size_t, struct proc *);
int nfs_checkexp(struct mount *mp, struct mbuf *nam,
	 int *extflagsp, struct ucred **credanonp);
d106 2
a107 1
struct mount *nfs_mount_diskless(struct nfs_dlmount *, char *, int);
@


1.30.2.7
log
@Sync the SMP branch with 3.3
@
text
@d303 1
a303 1
	n = attr.va_atime.tv_sec;
d308 5
@


1.30.2.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.30.2.7 2003/03/28 00:08:46 niklas Exp $	*/
d19 5
a23 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.30.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d81 1
a81 1
const struct vfsops nfs_vfsops = {
@


1.30.2.10
log
@Merge with the trunk
@
text
@d661 1
a661 1
	error = sockargs(&nam, args.addr, args.addrlen, MT_SONAME);
@


1.29
log
@Fix for NFS swap device.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.28 2000/01/01 23:50:59 millert Exp $	*/
d77 3
d96 2
a97 1
	nfs_sysctl
d974 1
a974 1
nfs_fhtovp(mp, fhp, nam, vpp, exflagsp, credanonp)
a976 1
	struct mbuf *nam;
a977 2
	int *exflagsp;
	struct ucred **credanonp;
d1023 14
@


1.28
log
@Correct casts in nfs_statfs() V3 code to correspond to reality (ie:
struct statfs).  Also, Make sure we do signed arithmatic when computing
f_bavail.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.27 1999/06/10 05:55:16 millert Exp $	*/
d349 6
@


1.27
log
@Fill in mount_info in nfs_decode_args
 o that way zero fields in nfs_args get filled in
 o changes via mount -u become visible
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.26 1999/05/31 17:34:52 millert Exp $	*/
d152 1
a152 1
		sbp->f_blocks = (long)(tquad / ((u_quad_t)NFS_FABLKSIZE));
d154 1
a154 1
		sbp->f_bfree = (long)(tquad / ((u_quad_t)NFS_FABLKSIZE));
d156 1
a156 1
		sbp->f_bavail = (long)(tquad / ((u_quad_t)NFS_FABLKSIZE));
@


1.26
log
@New struct statfs with mount options.  NOTE: this replaces statfs(2),
fstatfs(2), and getfsstat(2) so you will need to build a new kernel
before doing a "make build" or you will get "unimplemented syscall" errors.

The new struct statfs has the following featuires:
o Has a u_int32_t flags field--now softdep can have a real flag.

o Uses u_int32_t instead of longs (nicer on the alpha).  Note: the man
page used to lie about setting invalid/unused fields to -1.  SunOS does
that but our code never has.

o Gets rid of f_type completely.  It hasn't been used since NetBSD 0.9
and having it there but always 0 is confusing.  It is conceivable
that this may cause some old code to not compile but that is better
than silently breaking.

o Adds a mount_info union that contains the FSTYPE_args struct.  This
means that "mount" can now tell you all the options a filesystem was
mounted with.  This is especially nice for NFS.

Other changes:
o The linux statfs emulation didn't convert between BSD fs names
  and linux f_type numbers.  Now it does, since the BSD f_type
  number is useless to linux apps (and has been removed anyway)

o FreeBSD's struct statfs is different from our (both old and new)
and thus needs conversion.  Previously, the OpenBSD syscalls
were used without any real translation.

o mount(8) will now show extra info when invoked with no arguments.
However, to see *everything* you need to use the -v (verbose) flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.25 1998/08/19 22:26:56 csapuntz Exp $	*/
d423 1
a423 1
nfs_decode_args(nmp, argp)
d426 1
d562 15
d632 1
a632 1
		nfs_decode_args(nmp, &args);
d716 1
a716 1
	nfs_decode_args(nmp, argp);
@


1.25
log
@

Change fxdr_hyper to return a u_quad_t. This minimizes the evil clobbering
of lvalues that ANSI abhors.

And it fixes df on NFS version 3 mounts on Sparcs.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.24 1998/02/08 22:41:45 tholo Exp $	*/
a146 5
#ifdef COMPAT_09
	sbp->f_type = 2;
#else
	sbp->f_type = 0;
#endif
d172 2
a694 5
#ifdef COMPAT_09
	mp->mnt_stat.f_type = 2;
#else
	mp->mnt_stat.f_type = 0;
#endif
d698 1
d711 1
a711 1
		(error = nfs_connect(nmp, (struct nfsreq *)0)))
@


1.24
log
@Updates to match type changes in syscall tables
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.23 1997/11/11 11:20:32 niklas Exp $	*/
d156 1
a156 1
		fxdr_hyper(&sfp->sf_tbytes, &tquad);
d158 1
a158 1
		fxdr_hyper(&sfp->sf_fbytes, &tquad);
d160 1
a160 1
		fxdr_hyper(&sfp->sf_abytes, &tquad);
@


1.23
log
@Make diskless machines boot again. remove statics
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.22 1997/11/06 05:59:05 csapuntz Exp $	*/
d579 1
a579 1
	char *path;
@


1.22
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.21 1997/10/06 20:20:52 deraadt Exp $	*/
d75 2
a76 2
static int nfs_sysctl(int *, u_int, void *, size_t *, void *, size_t,
		      struct proc *);
d99 2
a100 2
static struct mount *
nfs_mount_diskless __P((struct nfs_dlmount *, char *, int, struct vnode **));
d372 1
a372 1
static struct mount *
d384 3
a386 10
	vfs_rootmountalloc("nfs", mntname, &mp);
	/* Create the mount point. */
	mp = (struct mount *)malloc((u_long)sizeof(struct mount),
	    M_MOUNT, M_WAITOK);
	if (mp == NULL)
		panic("nfs_mountroot: malloc mount for %s", mntname);
	bzero((char *)mp, (u_long)sizeof(struct mount));

	mp->mnt_op = &nfs_vfsops;
	mp->mnt_flag = mntflag;
d416 1
a416 1
	      (m->m_len = args.addr->sa_len));
d909 1
a909 1
static int
@


1.21
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.19 1997/04/18 10:15:20 deraadt Exp $	*/
a74 1
#ifdef notyet
a76 1
#endif
a81 1
	MOUNT_NFS,
a92 1
#ifdef notyet
a93 1
#endif
d178 1
a178 1
	strncpy(&sbp->f_fstypename[0], mp->mnt_op->vfs_name, MFSNAMELEN);
a291 1
#ifdef Lite2_integrated
a296 8
#else
	if (vfs_lock(mp))
		panic("nfs_mountroot: vfs_lock");
	CIRCLEQ_INSERT_TAIL(&mountlist, mp, mnt_list);
	mp->mnt_vnodecovered = NULLVP;
	vfs_unlock(mp);
	rootvp = vp;
#endif
a342 1
#ifdef Lite2_integrated
a343 1
#endif
a383 1
#ifdef Lite2_integrated
a384 1
#else
d391 1
a391 1
#endif
d677 2
a678 5
#ifdef Lite2_integrated
	vfs_getnewfsid(mp, makefstype(MOUNT_NFS));
#else
	getnewfsid(mp, makefstype(MOUNT_NFS));
#endif
d710 1
a710 1
	strncpy(&mp->mnt_stat.f_fstypename[0], mp->mnt_op->vfs_name, MFSNAMELEN);
d885 2
a886 1
		if (VOP_ISLOCKED(vp) || vp->v_dirtyblkhd.lh_first == NULL)
a887 1
#ifdef Lite2_integrated
a888 3
#else
		if (vget(vp, 1))
#endif
a912 1
#ifdef notyet
a954 1
#endif
@


1.20
log
@VFS Lite2 Changes
@
text
@d75 1
d78 1
d84 1
d96 1
d98 1
d183 1
a183 1
	strncpy(&sbp->f_fstypename[0], mp->mnt_vfc->vfc_name, MFSNAMELEN);
d297 1
d303 8
d357 1
d359 1
d400 1
d402 1
d409 1
a409 1

d695 5
a699 2

	vfs_getnewfsid(mp);
d731 1
a731 1
	strncpy(&mp->mnt_stat.f_fstypename[0], mp->mnt_vfc->vfc_name, MFSNAMELEN);
d906 1
a906 2
		if (VOP_ISLOCKED(vp) || vp->v_dirtyblkhd.lh_first == NULL ||
		    waitfor == MNT_LAZY)
d908 1
d910 3
d937 1
d980 1
@


1.19
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.18 1997/04/18 09:30:48 deraadt Exp $	*/
a74 1
#ifdef notyet
a76 1
#endif
a81 1
	MOUNT_NFS,
a92 1
#ifdef notyet
a93 1
#endif
d178 1
a178 1
	strncpy(&sbp->f_fstypename[0], mp->mnt_op->vfs_name, MFSNAMELEN);
a291 1
#ifdef Lite2_integrated
a296 8
#else
	if (vfs_lock(mp))
		panic("nfs_mountroot: vfs_lock");
	CIRCLEQ_INSERT_TAIL(&mountlist, mp, mnt_list);
	mp->mnt_vnodecovered = NULLVP;
	vfs_unlock(mp);
	rootvp = vp;
#endif
a342 1
#ifdef Lite2_integrated
a343 1
#endif
a383 1
#ifdef Lite2_integrated
a384 1
#else
d391 1
a391 1
#endif
d677 2
a678 5
#ifdef Lite2_integrated
	vfs_getnewfsid(mp, makefstype(MOUNT_NFS));
#else
	getnewfsid(mp, makefstype(MOUNT_NFS));
#endif
d710 1
a710 1
	strncpy(&mp->mnt_stat.f_fstypename[0], mp->mnt_op->vfs_name, MFSNAMELEN);
d885 2
a886 1
		if (VOP_ISLOCKED(vp) || vp->v_dirtyblkhd.lh_first == NULL)
a887 1
#ifdef Lite2_integrated
a888 3
#else
		if (vget(vp, 1))
#endif
a912 1
#ifdef notyet
a954 1
#endif
@


1.18
log
@new socket required if changing NOCONN; fvdl
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.17 1997/04/18 09:28:03 deraadt Exp $	*/
a269 3

	if (root_device->dv_class != DV_IFNET)
		return (ENODEV);
@


1.17
log
@ensure nfs_mountroot device is a network device; from who-knows-who at
netbsd but who-can-tell because they don't make their cvs tree available
so that people can check and give proper credit.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.16 1997/01/15 03:52:27 kstailey Exp $	*/
d469 3
@


1.16
log
@prevent -Wall warning:
nfs_vfsops.c:456: warning: `adjsock' might be used uninitialized in this function
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.15 1996/12/24 20:14:32 dm Exp $	*/
d270 3
@


1.15
log
@reclaim NFSMNT_RESVPORT bit, and add more traditional attribute cache timeout flags
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.14 1996/12/17 03:46:39 dm Exp $	*/
d456 1
a456 1
	int adjsock;
@


1.14
log
@NFS attribute cache timeout mount param
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.13 1996/09/21 11:06:22 deraadt Exp $	*/
a420 1
	args.flags    = NFSMNT_RESVPORT;
d461 1
d465 1
d547 7
a553 1
	if (argp->flags & NFSMNT_ACTIMES) {
d556 1
a556 1
		else if (argp->acregmax >= 0)
d558 11
a568 6
		if (argp->acregmin >= 0) {
			if (argp->acregmin > nmp->nm_acregmax)
				nmp->nm_acregmin = nmp->nm_acregmax;
			else
				nmp->nm_acregmin = argp->acregmin;
		}
d571 1
a571 1
		else if (argp->acdirmax >= 0)
a572 6
		if (argp->acdirmin >= 0) {
			if (argp->acdirmin > nmp->nm_acdirmax)
				nmp->nm_acdirmin = nmp->nm_acdirmax;
			else
				nmp->nm_acdirmin = argp->acdirmin;
		}
d574 2
d620 1
a620 1
		args.flags &= ~NFSMNT_INTERNAL;
d622 1
a622 1
	else if (args.version == NFS_ARGSVERSION)
d624 2
a629 1
	args.flags |= NFSMNT_RESVPORT;		/* ALWAYS allocate one */
@


1.13
log
@fix NFSSERVER w/o NFSCLIENT; netbsd pr#1780, cgd@@netbsd (yes, a 10month
old PR and the fix is mostly unchanged).
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.12 1996/06/02 16:47:23 niklas Exp $	*/
d546 23
d606 1
a606 1
	error = copyin(data, (caddr_t)&args, sizeof (struct nfs_args));
d609 8
a616 1
	if (args.version != NFS_ARGSVERSION)
d618 2
d709 4
@


1.12
log
@removed an unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.11 1996/06/01 04:43:59 mickey Exp $	*/
d95 1
a95 1
	nfs_init,
@


1.11
log
@allow client-only kernel to be compiled.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.10 1996/05/28 13:44:08 deraadt Exp $	*/
a815 1
	struct vattr attrs;
@


1.10
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.9 1996/05/14 22:41:32 deraadt Exp $	*/
d72 1
a72 1
struct nfsstats nfsstats;
@


1.9
log
@NFSMNT_RESVPORT set in wrong place
@
text
@d1 2
a2 2
/*	$OpenBSD: nfs_vfsops.c,v 1.7 1996/04/17 04:50:34 mickey Exp $	*/
/*	$NetBSD: nfs_vfsops.c,v 1.46 1996/03/24 23:58:10 fvdl Exp $	*/
d594 6
d720 1
a720 1
	VOP_GETATTR(*vpp, &attrs, curproc->p_ucred, curproc);
d816 1
@


1.8
log
@partial sync with netbsd 960418, more to come
@
text
@d588 1
a594 1
		args.flags |= NFSMNT_RESVPORT;	/* ALWAYS allocate one */
@


1.7
log
@Minor cleanups. Checked against Lite2.
(NetBSD's was really just a Lite2's, but w/ 64bit support)
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.6 1996/03/31 13:16:00 mickey Exp $	*/
d549 1
a549 1
			while (nfs_connect(nmp, (struct nfsreq *)NULL)) {
d692 1
a692 1
		(error = nfs_connect(nmp, (struct nfsreq *)NULL)))
@


1.6
log
@From NetBSD: NFSv3 import (tomorrow's Net's kernel)
Open's patches kept in. i'll possibly take a look at Lite2 soon,
is there smth usefull ?..
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_vfsops.c,v 1.5 1996/02/29 09:24:58 niklas Exp $	*/
d120 1
a120 1
	register struct nfs_statfs *sfp;
a131 3
#ifndef nolint
	sfp = (struct nfs_statfs *)0;
#endif
d549 1
a549 1
			while (nfs_connect(nmp, (struct nfsreq *)0)) {
d692 1
a692 1
		(error = nfs_connect(nmp, (struct nfsreq *)0)))
@


1.5
log
@From NetBSD: merge with 960217 (still NFSv2)
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: nfs_vfsops.c,v 1.42 1996/02/13 17:53:35 gwr Exp $	*/
d5 1
a5 1
 * Copyright (c) 1989, 1993
d39 1
a39 1
 *	@@(#)nfs_vfsops.c	8.3 (Berkeley) 1/4/94
d62 1
a62 1
#include <nfs/nfsv2.h>
d64 1
a65 1
#include <nfs/nfs.h>
d72 8
d96 3
d101 2
a102 3
extern u_long nfs_procids[NFS_NPROCS];
extern u_long nfs_prog, nfs_vers;
void nfs_disconnect __P((struct nfsmount *));
d120 1
a120 1
	register struct nfsv2_statfs *sfp;
d122 2
a123 1
	register int32_t t1;
d125 3
a127 3
	int error = 0, isnq;
	struct mbuf *mreq, *mrep, *md, *mb, *mb2;
	struct nfsmount *nmp;
d130 1
d132 5
a136 3
	nmp = VFSTONFS(mp);
	isnq = (nmp->nm_flag & NFSMNT_NQNFS);
	if ((error = nfs_nget(mp, &nmp->nm_fh, &np)) != 0)
a138 1
	nfsstats.rpccnt[NFSPROC_STATFS]++;
d141 14
a154 4
	nfsm_reqhead(vp, NFSPROC_STATFS, NFSX_FH);
	nfsm_fhtom(vp);
	nfsm_request(vp, NFSPROC_STATFS, p, cred);
	nfsm_dissect(sfp, struct nfsv2_statfs *, NFSX_STATFS(isnq));
d161 13
a173 8
	sbp->f_iosize = NFS_MAXDGRAMDATA;
	sbp->f_bsize = fxdr_unsigned(int32_t, sfp->sf_bsize);
	sbp->f_blocks = fxdr_unsigned(int32_t, sfp->sf_blocks);
	sbp->f_bfree = fxdr_unsigned(int32_t, sfp->sf_bfree);
	sbp->f_bavail = fxdr_unsigned(int32_t, sfp->sf_bavail);
	if (isnq) {
		sbp->f_files = fxdr_unsigned(int32_t, sfp->sf_files);
		sbp->f_ffree = fxdr_unsigned(int32_t, sfp->sf_ffree);
d175 4
d194 60
d300 7
d313 1
d320 1
a320 1
	printf("root time: 0x%x\n", n);
d324 5
d360 3
d381 1
a381 1
	printf("swap size: 0x%x (blocks)\n", n);
d403 3
d412 1
d421 2
a422 1
	args.fh       = (nfsv2fh_t *)ndmntp->ndm_fh;
d449 1
a449 1
		panic("nfs_mountroot: mount %s failed: %d", mntname);
d461 1
d488 8
d500 1
a500 1
		nmp->nm_wsize &= ~0x1ff;
d502 1
a502 3
			nmp->nm_wsize = 512;
		else if (nmp->nm_wsize > NFS_MAXDATA)
			nmp->nm_wsize = NFS_MAXDATA;
d505 2
d514 1
a514 1
		nmp->nm_rsize &= ~0x1ff;
d516 1
a516 3
			nmp->nm_rsize = 512;
		else if (nmp->nm_rsize > NFS_MAXDATA)
			nmp->nm_rsize = NFS_MAXDATA;
d519 2
d524 12
d584 1
a584 1
	nfsv2fh_t nfh;
d589 2
d600 1
a600 1
	error = copyin((caddr_t)args.fh, (caddr_t)&nfh, sizeof (nfsv2fh_t));
d603 2
a604 1
	if ((error = copyinstr(path, pth, MNAMELEN-1, &len)) != 0)
d607 2
a608 1
	if ((error = copyinstr(args.hostname, hst, MNAMELEN-1, &len)) != 0)
d612 1
a612 2
	error = sockargs(&nam, (caddr_t)args.addr,
			 args.addrlen, MT_SONAME);
d615 1
a615 1
	args.fh = &nfh;
d646 1
d648 3
d652 1
a653 5
	if ((argp->flags & (NFSMNT_NQNFS | NFSMNT_MYWRITE)) ==
		(NFSMNT_NQNFS | NFSMNT_MYWRITE)) {
		error = EPERM;
		goto bad;
	}
d666 1
d673 2
a674 1
	bcopy((caddr_t)argp->fh, (caddr_t)&nmp->nm_fh, sizeof(nfsv2fh_t));
d713 2
a714 1
	if ((error = nfs_nget(mp, &nmp->nm_fh, &np)) != 0)
d758 2
a759 1
	if ((error = nfs_nget(mp, &nmp->nm_fh, &np)) != 0)
d773 2
a774 1
	if ((error = vflush(mp, vp, flags)) != 0) {
d815 2
a816 1
	if ((error = nfs_nget(mp, &nmp->nm_fh, &np)) != 0)
d820 1
a820 1
	    vp->v_type = VDIR;
d857 3
d861 1
d863 2
a864 1
		if ((error = VOP_FSYNC(vp, cred, waitfor, p)) != 0)
d885 46
@


1.4
log
@graichen@@freebsd.org: fixed -type:=direct mounts in amd
@
text
@d1 2
a2 1
/*	$NetBSD: nfs_vfsops.c,v 1.39 1995/12/19 23:07:49 cgd Exp $	*/
d54 1
d70 1
d122 1
a122 1
	if (error = nfs_nget(mp, &nmp->nm_fh, &np))
a176 1
	struct ucred *cred;
d201 1
d203 1
a203 1
	printf("root on %s\n", &nd.nd_root.ndm_host);
d218 1
a218 1
	n = attr.va_mtime.ts_sec;
d253 1
d255 1
a255 1
	printf("swap on %s\n", &nd.nd_swap.ndm_host);
d297 1
a297 1
	    M_MOUNT, M_NOWAIT);
d334 2
a335 1
	if (error = mountnfs(&args, mp, m, mntname, args.hostname, vpp))
d452 2
a453 1
	if (error = copyin(data, (caddr_t)&args, sizeof (struct nfs_args)))
d464 2
a465 1
	if (error = copyin((caddr_t)args.fh, (caddr_t)&nfh, sizeof (nfsv2fh_t)))
d467 1
a467 1
	if (error = copyinstr(path, pth, MNAMELEN-1, &len))
d470 1
a470 1
	if (error = copyinstr(args.hostname, hst, MNAMELEN-1, &len))
d474 3
a476 2
	if (error = sockargs(&nam, (caddr_t)args.addr,
		args.addrlen, MT_SONAME))
d574 1
a574 1
	if (error = nfs_nget(mp, &nmp->nm_fh, &np))
a599 1
	extern int doforce;
d618 1
a618 1
	if (error = nfs_nget(mp, &nmp->nm_fh, &np))
d632 1
a632 1
	if (error = vflush(mp, vp, flags)) {
d673 1
a673 1
	if (error = nfs_nget(mp, &nmp->nm_fh, &np))
d716 1
a716 1
		if (error = VOP_FSYNC(vp, cred, waitfor, p))
@


1.3
log
@from cgd; handle 64-bit pointers and longs
@
text
@d489 1
d569 1
d669 2
a670 1
	vp->v_type = VDIR;
@


1.2
log
@force NFSMNT_RESVPORT on always
@
text
@d1 1
a1 1
/*	$NetBSD: nfs_vfsops.c,v 1.38 1995/08/13 00:00:08 mycroft Exp $	*/
d109 1
a109 1
	register long t1;
d136 4
a139 4
	sbp->f_bsize = fxdr_unsigned(long, sfp->sf_bsize);
	sbp->f_blocks = fxdr_unsigned(long, sfp->sf_blocks);
	sbp->f_bfree = fxdr_unsigned(long, sfp->sf_bfree);
	sbp->f_bavail = fxdr_unsigned(long, sfp->sf_bavail);
d141 2
a142 2
		sbp->f_files = fxdr_unsigned(long, sfp->sf_files);
		sbp->f_ffree = fxdr_unsigned(long, sfp->sf_ffree);
@


1.1
log
@Initial revision
@
text
@d455 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
