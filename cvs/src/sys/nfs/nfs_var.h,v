head	1.63;
access;
symbols
	OPENBSD_6_2:1.63.0.2
	OPENBSD_6_2_BASE:1.63
	OPENBSD_6_1:1.63.0.4
	OPENBSD_6_1_BASE:1.63
	OPENBSD_6_0:1.61.0.2
	OPENBSD_6_0_BASE:1.61
	OPENBSD_5_9:1.60.0.10
	OPENBSD_5_9_BASE:1.60
	OPENBSD_5_8:1.60.0.12
	OPENBSD_5_8_BASE:1.60
	OPENBSD_5_7:1.60.0.4
	OPENBSD_5_7_BASE:1.60
	OPENBSD_5_6:1.60.0.8
	OPENBSD_5_6_BASE:1.60
	OPENBSD_5_5:1.60.0.6
	OPENBSD_5_5_BASE:1.60
	OPENBSD_5_4:1.60.0.2
	OPENBSD_5_4_BASE:1.60
	OPENBSD_5_3:1.59.0.12
	OPENBSD_5_3_BASE:1.59
	OPENBSD_5_2:1.59.0.10
	OPENBSD_5_2_BASE:1.59
	OPENBSD_5_1_BASE:1.59
	OPENBSD_5_1:1.59.0.8
	OPENBSD_5_0:1.59.0.6
	OPENBSD_5_0_BASE:1.59
	OPENBSD_4_9:1.59.0.4
	OPENBSD_4_9_BASE:1.59
	OPENBSD_4_8:1.59.0.2
	OPENBSD_4_8_BASE:1.59
	OPENBSD_4_7:1.58.0.2
	OPENBSD_4_7_BASE:1.58
	OPENBSD_4_6:1.51.0.4
	OPENBSD_4_6_BASE:1.51
	OPENBSD_4_5:1.48.0.2
	OPENBSD_4_5_BASE:1.48
	OPENBSD_4_4:1.42.0.2
	OPENBSD_4_4_BASE:1.42
	OPENBSD_4_3:1.33.0.2
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.28.0.2
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.23.0.12
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.23.0.10
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.23.0.8
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.23.0.6
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.23.0.4
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.23.0.2
	OPENBSD_3_6_BASE:1.23
	SMP_SYNC_A:1.21
	SMP_SYNC_B:1.21
	OPENBSD_3_5:1.21.0.8
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.21.0.6
	OPENBSD_3_4_BASE:1.21
	UBC_SYNC_A:1.21
	OPENBSD_3_3:1.21.0.4
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.21.0.2
	OPENBSD_3_2_BASE:1.21
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	UBC_SYNC_B:1.21
	UBC:1.16.0.2
	UBC_BASE:1.16
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.4
	OPENBSD_2_8:1.12.0.2
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.10.0.4
	OPENBSD_2_7_BASE:1.10
	SMP:1.10.0.2
	SMP_BASE:1.10
	kame_19991208:1.9
	OPENBSD_2_6:1.9.0.6
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.4
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.8.0.2
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.63
date	2017.02.22.11.42.46;	author mpi;	state Exp;
branches;
next	1.62;
commitid	QPdM5oUknMlUIDue;

1.62
date	2016.09.27.01.37.38;	author dlg;	state Exp;
branches;
next	1.61;
commitid	HwDxz9mxZKQUWHxT;

1.61
date	2016.04.29.14.40.36;	author beck;	state Exp;
branches;
next	1.60;
commitid	p3EbVWCYrcYkiFMB;

1.60
date	2013.06.11.16.42.17;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2010.04.12.16.37.38;	author beck;	state Exp;
branches;
next	1.58;

1.58
date	2009.09.02.18.20.54;	author thib;	state Exp;
branches;
next	1.57;

1.57
date	2009.08.20.15.04.24;	author thib;	state Exp;
branches;
next	1.56;

1.56
date	2009.08.13.15.18.16;	author blambert;	state Exp;
branches;
next	1.55;

1.55
date	2009.08.13.15.03.19;	author blambert;	state Exp;
branches;
next	1.54;

1.54
date	2009.08.10.10.59.12;	author thib;	state Exp;
branches;
next	1.53;

1.53
date	2009.08.10.09.38.44;	author thib;	state Exp;
branches;
next	1.52;

1.52
date	2009.08.04.17.12.39;	author thib;	state Exp;
branches;
next	1.51;

1.51
date	2009.06.04.01.02.42;	author blambert;	state Exp;
branches;
next	1.50;

1.50
date	2009.04.13.17.51.57;	author blambert;	state Exp;
branches;
next	1.49;

1.49
date	2009.03.30.19.58.50;	author blambert;	state Exp;
branches;
next	1.48;

1.48
date	2009.01.20.18.03.33;	author blambert;	state Exp;
branches;
next	1.47;

1.47
date	2009.01.18.21.04.41;	author blambert;	state Exp;
branches;
next	1.46;

1.46
date	2009.01.16.17.11.28;	author thib;	state Exp;
branches;
next	1.45;

1.45
date	2009.01.15.19.41.18;	author thib;	state Exp;
branches;
next	1.44;

1.44
date	2008.10.16.07.57.06;	author blambert;	state Exp;
branches;
next	1.43;

1.43
date	2008.08.09.10.14.02;	author thib;	state Exp;
branches;
next	1.42;

1.42
date	2008.06.14.00.23.26;	author thib;	state Exp;
branches;
next	1.41;

1.41
date	2008.06.13.22.11.32;	author blambert;	state Exp;
branches;
next	1.40;

1.40
date	2008.06.13.03.49.26;	author blambert;	state Exp;
branches;
next	1.39;

1.39
date	2008.06.12.20.24.06;	author blambert;	state Exp;
branches;
next	1.38;

1.38
date	2008.06.10.22.59.09;	author thib;	state Exp;
branches;
next	1.37;

1.37
date	2008.06.09.22.49.15;	author djm;	state Exp;
branches;
next	1.36;

1.36
date	2008.06.09.22.47.42;	author djm;	state Exp;
branches;
next	1.35;

1.35
date	2008.04.22.18.53.34;	author thib;	state Exp;
branches;
next	1.34;

1.34
date	2008.04.14.13.46.13;	author blambert;	state Exp;
branches;
next	1.33;

1.33
date	2008.01.06.17.38.23;	author blambert;	state Exp;
branches;
next	1.32;

1.32
date	2007.12.13.18.32.55;	author blambert;	state Exp;
branches;
next	1.31;

1.31
date	2007.10.28.14.12.41;	author thib;	state Exp;
branches;
next	1.30;

1.30
date	2007.10.14.19.34.41;	author thib;	state Exp;
branches;
next	1.29;

1.29
date	2007.10.13.17.38.43;	author thib;	state Exp;
branches;
next	1.28;

1.28
date	2007.06.21.22.59.49;	author thib;	state Exp;
branches;
next	1.27;

1.27
date	2007.06.01.07.13.47;	author thib;	state Exp;
branches;
next	1.26;

1.26
date	2007.04.19.14.46.44;	author thib;	state Exp;
branches;
next	1.25;

1.25
date	2007.04.13.17.09.22;	author thib;	state Exp;
branches;
next	1.24;

1.24
date	2007.04.11.12.18.54;	author thib;	state Exp;
branches;
next	1.23;

1.23
date	2004.08.03.17.11.48;	author marius;	state Exp;
branches;
next	1.22;

1.22
date	2004.07.21.17.30.56;	author marius;	state Exp;
branches;
next	1.21;

1.21
date	2002.07.03.20.57.00;	author nate;	state Exp;
branches;
next	1.20;

1.20
date	2002.07.02.04.23.25;	author ericj;	state Exp;
branches;
next	1.19;

1.19
date	2002.04.10.18.16.46;	author csapuntz;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.14.01.27.13;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.19.08.58.06;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.27.05.27.12;	author art;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2001.11.15.23.15.15;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.25.03.28.12;	author csapuntz;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.25.02.15.47;	author csapuntz;	state Exp;
branches;
next	1.12;

1.12
date	2000.06.30.01.06.02;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2000.05.19.16.36.03;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2000.02.07.04.48.42;	author assar;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	98.08.06.19.34.59;	author csapuntz;	state Exp;
branches;
next	1.8;

1.8
date	98.02.22.01.21.32;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	97.11.06.05.59.04;	author csapuntz;	state Exp;
branches;
next	1.6;

1.6
date	97.10.06.20.20.51;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.10.06.15.23.44;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	96.12.14.15.36.51;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.09.21.11.06.20;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.31.13.15.58;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	96.02.29.09.24.57;	author niklas;	state Exp;
branches;
next	;

1.10.2.1
date	2001.05.14.22.44.58;	author niklas;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2001.07.04.10.55.51;	author niklas;	state Exp;
branches;
next	1.10.2.3;

1.10.2.3
date	2001.12.05.01.02.40;	author niklas;	state Exp;
branches;
next	1.10.2.4;

1.10.2.4
date	2002.03.06.02.17.12;	author niklas;	state Exp;
branches;
next	1.10.2.5;

1.10.2.5
date	2002.03.28.15.02.48;	author niklas;	state Exp;
branches;
next	1.10.2.6;

1.10.2.6
date	2003.03.28.00.08.46;	author niklas;	state Exp;
branches;
next	;

1.16.2.1
date	2002.06.11.03.32.04;	author art;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2002.10.29.00.36.49;	author art;	state Exp;
branches;
next	1.16.2.3;

1.16.2.3
date	2002.11.04.18.02.32;	author art;	state Exp;
branches;
next	;


desc
@@


1.63
log
@Keep local definitions local.

"good work" deraadt@@, ok visa@@
@
text
@/*	$OpenBSD: nfs_var.h,v 1.62 2016/09/27 01:37:38 dlg Exp $	*/
/*	$NetBSD: nfs_var.h,v 1.3 1996/02/18 11:53:54 fvdl Exp $	*/

/*
 * Copyright (c) 1996 Christos Zoulas.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Christos Zoulas.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * XXX needs <nfs/rpcv2.h> and <nfs/nfs.h> because of typedefs.
 */
#ifndef _NFS_NFS_VAR_H_
#define _NFS_NFS_VAR_H_

#ifdef _KERNEL

struct nfsnode;
struct sillyrename;
struct componentname;
struct nfs_diskless;
struct nfsm_info;

/* nfs_bio.c */
int nfs_bioread(struct vnode *, struct uio *, int, struct ucred *);
int nfs_write(void *);
int nfs_vinvalbuf(struct vnode *, int, struct ucred *, struct proc *);
int nfs_asyncio(struct buf *, int readahead);
int nfs_doio(struct buf *, struct proc *);

/* nfs_boot.c */
int nfs_boot_init(struct nfs_diskless *, struct proc *);

/* nfs_node.c */
void nfs_ninit(struct nfsmount *);
int nfs_nget(struct mount *, nfsfh_t *, int, struct nfsnode **);
int nfs_inactive(void *);
int nfs_reclaim(void *);

/* nfs_vnops.c */
int nfs_readlink(void *);
int nfs_readlinkrpc(struct vnode *, struct uio *, struct ucred *);
int nfs_readrpc(struct vnode *, struct uio *);
int nfs_writerpc(struct vnode *, struct uio *, int *, int *);
int nfs_removeit(struct sillyrename *);
int nfs_mmap(void *);
int nfs_blkatoff(void *);
int nfs_writebp(struct buf *, int);

#define	nfs_ioctl	((int (*)(void *))enoioctl)

/* nfs_serv.c */
int nfsrv3_access(struct nfsrv_descript *, struct nfssvc_sock *,
		       struct proc *, struct mbuf **);
int nfsrv_getattr(struct nfsrv_descript *, struct nfssvc_sock *,
		       struct proc *, struct mbuf **);
int nfsrv_setattr(struct nfsrv_descript *, struct nfssvc_sock *,
		       struct proc *, struct mbuf **);
int nfsrv_lookup(struct nfsrv_descript *, struct nfssvc_sock *,
		      struct proc *, struct mbuf **);
int nfsrv_readlink(struct nfsrv_descript *, struct nfssvc_sock *,
			struct proc *, struct mbuf **);
int nfsrv_read(struct nfsrv_descript *, struct nfssvc_sock *,
		    struct proc *, struct mbuf **);
int nfsrv_write(struct nfsrv_descript *, struct nfssvc_sock *,
		     struct proc *, struct mbuf **);
int nfsrv_create(struct nfsrv_descript *, struct nfssvc_sock *,
		      struct proc *, struct mbuf **);
int nfsrv_mknod(struct nfsrv_descript *, struct nfssvc_sock *,
		     struct proc *, struct mbuf **);
int nfsrv_remove(struct nfsrv_descript *, struct nfssvc_sock *,
		      struct proc *, struct mbuf **);
int nfsrv_rename(struct nfsrv_descript *, struct nfssvc_sock *,
		      struct proc *, struct mbuf **);
int nfsrv_link(struct nfsrv_descript *, struct nfssvc_sock *,
		    struct proc *, struct mbuf **);
int nfsrv_symlink(struct nfsrv_descript *, struct nfssvc_sock *,
		       struct proc *, struct mbuf **);
int nfsrv_mkdir(struct nfsrv_descript *, struct nfssvc_sock *,
		     struct proc *, struct mbuf **);
int nfsrv_rmdir(struct nfsrv_descript *, struct nfssvc_sock *,
		     struct proc *, struct mbuf **);
int nfsrv_readdir(struct nfsrv_descript *, struct nfssvc_sock *,
		       struct proc *, struct mbuf **);
int nfsrv_readdirplus(struct nfsrv_descript *, struct nfssvc_sock *,
			   struct proc *, struct mbuf **);
int nfsrv_commit(struct nfsrv_descript *, struct nfssvc_sock *,
		      struct proc *, struct mbuf **);
int nfsrv_statfs(struct nfsrv_descript *, struct nfssvc_sock *,
		      struct proc *, struct mbuf **);
int nfsrv_fsinfo(struct nfsrv_descript *, struct nfssvc_sock *,
		      struct proc *, struct mbuf **);
int nfsrv_pathconf(struct nfsrv_descript *, struct nfssvc_sock *,
		        struct proc *, struct mbuf **);
int nfsrv_null(struct nfsrv_descript *, struct nfssvc_sock *,
		    struct proc *, struct mbuf **);
int nfsrv_noop(struct nfsrv_descript *, struct nfssvc_sock *,
		    struct proc *, struct mbuf **);

/* nfs_socket.c */
int nfs_connect(struct nfsmount *, struct nfsreq *);
void nfs_disconnect(struct nfsmount *);
int nfs_send(struct socket *, struct mbuf *, struct mbuf *,
		  struct nfsreq *);
int nfs_request(struct vnode *, int, struct nfsm_info *);
int nfs_rephead(int, struct nfsrv_descript *, struct nfssvc_sock *, int,
		struct mbuf **, struct mbuf **);
void nfs_timer(void *);
int nfs_sigintr(struct nfsmount *, struct nfsreq *, struct proc *);
int nfs_sndlock(int *, struct nfsreq *);
void nfs_sndunlock(int *);
void nfsrv_rcv(struct socket *, caddr_t, int);
int nfsrv_dorec(struct nfssvc_sock *, struct nfsd *,
		     struct nfsrv_descript **);
void nfsrv_wakenfsd(struct nfssvc_sock *);

/* nfs_srvcache.c */
void nfsrv_initcache(void );
int nfsrv_getcache(struct nfsrv_descript *, struct nfssvc_sock *,
			struct mbuf **);
void nfsrv_updatecache(struct nfsrv_descript *, int, struct mbuf *);
void nfsrv_cleancache(void);

/* nfs_subs.c */
struct mbuf *nfsm_reqhead(int);
void nfsm_rpchead(struct nfsreq *, struct ucred *, int);
void *nfsm_build(struct mbuf **, u_int);
int nfsm_mbuftouio(struct mbuf **, struct uio *, int, caddr_t *);
void nfsm_uiotombuf(struct mbuf **, struct uio *, size_t);
void nfsm_strtombuf(struct mbuf **, void *, size_t);
void nfsm_buftombuf(struct mbuf **, void *, size_t);
int nfsm_disct(struct mbuf **, caddr_t *, int, int, caddr_t *);
int nfs_adv(struct mbuf **, caddr_t *, int, int);
int nfsm_strtmbuf(struct mbuf **, char **, char *, long);
int nfs_vfs_init(struct vfsconf *);
int nfs_attrtimeo(struct nfsnode *);
int nfs_loadattrcache(struct vnode **, struct mbuf **, caddr_t *,
			   struct vattr *);
int nfs_getattrcache(struct vnode *, struct vattr *);
int nfs_namei(struct nameidata *, fhandle_t *, int, struct nfssvc_sock *,
		   struct mbuf *, struct mbuf **, caddr_t *, struct vnode **,
		   struct proc *);
void nfsm_v3attrbuild(struct mbuf **, struct vattr *, int);
void nfsm_adj(struct mbuf *, int, int);
void nfsm_srvwcc(struct nfsrv_descript *, int, struct vattr *, int,
		      struct vattr *, struct nfsm_info *);
void nfsm_srvpostop_attr(struct nfsrv_descript *, int, struct vattr *,
			     struct nfsm_info *);
void nfsm_srvfattr(struct nfsrv_descript *, struct vattr *,
			struct nfs_fattr *);
int nfsrv_fhtovp(fhandle_t *, int, struct vnode **, struct ucred *,
		      struct nfssvc_sock *, struct mbuf *, int *);
int netaddr_match(int, union nethostaddr *, struct mbuf *);
void nfs_clearcommit(struct mount *);
int nfs_in_committed_range(struct vnode *, struct buf *);
int nfs_in_tobecommitted_range(struct vnode *, struct buf *);
void nfs_add_committed_range(struct vnode *, struct buf *);
void nfs_del_committed_range(struct vnode *, struct buf *);
void nfs_add_tobecommitted_range(struct vnode *, struct buf *);
void nfs_del_tobecommitted_range(struct vnode *, struct buf *);
void nfs_merge_commit_ranges(struct vnode *);
int nfsrv_errmap(struct nfsrv_descript *, int);
int nfsm_srvsattr(struct mbuf **, struct vattr *, struct mbuf *, caddr_t *);
void nfsm_fhtom(struct nfsm_info *, struct vnode *, int);
void nfsm_srvfhtom(struct mbuf **, fhandle_t *, int);

/* nfs_syscalls.c */
int sys_nfssvc(struct proc *, void *, register_t *);
void nfsrv_init(int);
void start_nfsio(void *);
void nfs_getset_niothreads(int);

/* nfs_kq.c */
int  nfs_kqfilter(void *);

/* Internal NFS utility macros */
#define	mb_offset(m)	(mtod((m), caddr_t) + (m)->m_len)
#define	nfsm_padlen(s)	(nfsm_rndup(s) - (s))

#endif /* _KERNEL */
#endif /* _NFS_NFS_VAR_H_ */
@


1.62
log
@replace the use of RB macros with the RBT functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.61 2016/04/29 14:40:36 beck Exp $	*/
a49 1
struct buf *nfs_getcacheblk(struct vnode *, daddr_t, int, struct proc *);
a63 11
int nfs_poll(void *);
int nfs_null(struct vnode *, struct ucred *, struct proc *);
int nfs_access(void *);
int nfs_open(void *);
int nfs_close(void *);
int nfs_getattr(void *);
int nfs_setattr(void *);
int nfs_setattrrpc(struct vnode *, struct vattr *, struct ucred *,
			struct proc *);
int nfs_lookup(void *);
int nfs_read(void *);
a67 5
int nfs_mknodrpc(struct vnode *, struct vnode **, struct componentname *,
		      struct vattr *);
int nfs_mknod(void *);
int nfs_create(void *);
int nfs_remove(void *);
a68 22
int nfs_removerpc(struct vnode *, char *, int, struct ucred *,
		       struct proc *);
int nfs_rename(void *);
int nfs_renameit(struct vnode *, struct componentname *,
		      struct sillyrename *);
int nfs_renamerpc(struct vnode *, char *, int, struct vnode *, char *, int,
		       struct ucred *, struct proc *);
int nfs_link(void *);
int nfs_symlink(void *);
int nfs_mkdir(void *);
int nfs_rmdir(void *);
int nfs_readdir(void *);
int nfs_readdirrpc(struct vnode *, struct uio *, struct ucred *, int *);
int nfs_readdirplusrpc(struct vnode *, struct uio *, struct ucred *, int *,
    struct proc *);
int nfs_sillyrename(struct vnode *, struct vnode *,
			 struct componentname *);
int nfs_lookitup(struct vnode *, char *, int, struct ucred *,
		      struct proc *, struct nfsnode **);
int nfs_commit(struct vnode *, u_quad_t, int, struct proc *);
int nfs_bmap(void *);
int nfs_strategy(void *);
a69 5
int nfs_fsync(void *);
int nfs_flush(struct vnode *, struct ucred *, int, struct proc *, int);
int nfs_pathconf(void *);
int nfs_advlock(void *);
int nfs_print(void *);
a70 1
int nfs_bwrite(void *);
a71 8
int nfsspec_access(void *);
int nfsspec_read(void *);
int nfsspec_write(void *);
int nfsspec_close(void *);
int nfsfifo_read(void *);
int nfsfifo_write(void *);
int nfsfifo_close(void *);
int nfsfifo_reclaim(void *);
a121 2
int nfsrv_access(struct vnode *, int, struct ucred *, int, struct proc *,
		    int);
a124 1
int nfs_reconnect(struct nfsreq *);
a127 2
int nfs_receive(struct nfsreq *, struct mbuf **, struct mbuf **);
int nfs_reply(struct nfsreq *);
a134 4
int nfs_rcvlock(struct nfsreq *);
void nfs_rcvunlock(int *);
int nfs_getreq(struct nfsrv_descript *, struct nfsd *, int);
void nfs_msg(struct nfsreq *, char *);
a135 1
int nfsrv_getstream(struct nfssvc_sock *, int);
a148 1
u_int32_t nfs_get_xid(void);
a191 4
int nfssvc_addsock(struct file *, struct mbuf *);
int nfssvc_nfsd(struct nfsd *);
void nfsrv_zapsock(struct nfssvc_sock *);
void nfsrv_slpderef(struct nfssvc_sock *);
a192 1
void nfssvc_iod(void *);
@


1.61
log
@Fix some gibbering horrors due to uninitialized struct nameidata's

1) turn NDINITAT into a function and make the macros point to it
with the later goal of getting rid of them.

2) Sweep the kernel for places where people make a struct nameidata manually
on the stack and fill in what they hope are the required fields and count
on prayer and clean living to always get them right. Instead use NDINIT
everywhere. NFS was especially bad for this and there have likely
been things lurking there for a while.

3) Add a couple of strategic KASSERT's to catch future offenders.

ok krw@@ sthen@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.60 2013/06/11 16:42:17 deraadt Exp $	*/
d59 1
@


1.60
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.59 2010/04/12 16:37:38 beck Exp $	*/
d98 2
a99 1
int nfs_readdirplusrpc(struct vnode *, struct uio *, struct ucred *, int *);
@


1.59
log
@
Don't jump the queue if we have to wait on the client side because
the nfs_bufq is full - instead tsleep waiting for one of our nfsiod's
to free up space for us in the queue so we can enqueue on the end.

ok blambert@@, tedu@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.58 2009/09/02 18:20:54 thib Exp $	*/
d50 1
a50 1
struct buf *nfs_getcacheblk(struct vnode *, daddr64_t, int, struct proc *);
@


1.58
log
@Backout the asyncio/aiod change, as it causes buf's to get hung.
problem noticed by deraadt@@

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.55 2009/08/13 15:03:19 blambert Exp $	*/
d52 1
a52 1
int nfs_asyncio(struct buf *);
@


1.57
log
@Rework the way we do async I/O in nfs. Introduce separate buf queues for
each mount, and when work is "found", peg an aiod to that mount todo the
I/O. Make nfs_asyncio() a bit smarter when deciding when to do asyncio
and when to force it sync, this is done by keeping the aiod's one two lists,
an "idle" and an "all" list, so asyncio is only done when there are aiods
hanging around todo it for us or are already pegged to the mount.

Idea liked by at least beck@@ (and I think art@@).
Extensive testing done by myself and jasper and a few others on various
arch's.

Ideas/Code from Net/Free.

OK blambert@@.
@
text
@a46 5
/* nfs_aiod.c */
void	nfs_aiod(void *);
int	nfs_set_naiod(int);
void	nfs_init_aiod(void);

d259 3
@


1.56
log
@Teach nfsm_fhtom about nfsm_info structs

ok thib@@
@
text
@d47 5
a263 3
void nfssvc_iod(void *);
void start_nfsio(void *);
void nfs_getset_niothreads(int);
@


1.55
log
@change version 3 post-operation attribute building function to not
use mbufs directly, but the shiny new nfsm_info struct

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.54 2009/08/10 10:59:12 thib Exp $	*/
d249 1
a249 1
void nfsm_fhtom(struct mbuf **, struct vnode *, int);
@


1.54
log
@Use an RB tree instead of a hashtable for fh/node lookups.

Idea from NetBSD.

OK blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.53 2009/08/10 09:38:44 thib Exp $	*/
d231 1
a231 1
		      struct vattr *, struct mbuf **);
d233 1
a233 1
			     struct mbuf **);
@


1.53
log
@Remove the v2 writegather code. It did help alot back in the 80s
but extensive performance benchmarking done by myself and jasper@@
has shown that it doesn't help, at all - even on vaxens and in some
cases it makes things significantly slower.

"this excites me sexually" jetpack@@
Tested by jasper@@.
OK blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.50 2009/04/13 17:51:57 blambert Exp $	*/
a58 1
void nfs_nhinit(void);
@


1.52
log
@group all of the on-stack variables that are uses by the nfsm_macros
to keep the data munging "state" into an nfsm_info structure. Each
function now has this structure on its stack, and it and its members
are now passed around so that the macros/functions can work there magic.

this will make removing the nfsm_* macros way easier.

Idea/code picked up from DragonflyBSD.

Tested by krw@@, jacekm@@ and myself.

OK blambert@@.
@
text
@a141 3
int nfsrv_writegather(struct nfsrv_descript **, struct nfssvc_sock *,
			   struct proc *, struct mbuf **);
void nfsrvw_coalesce(struct nfsrv_descript *, struct nfsrv_descript *);
a248 2
void nfsrvw_sort(gid_t *, int);
void nfsrv_setcred(struct ucred *, struct ucred *);
@


1.51
log
@simplify argument list for nfssvc_nfsd()

ok thib@@
@
text
@d45 1
d188 1
a188 5
int nfs_request(struct vnode *, struct mbuf *, int, struct proc *,
		     struct ucred *, struct mbuf **, struct mbuf **,
		     caddr_t *);
int nfs_request1(struct nfsreq *, struct ucred *, struct mbuf **,
		    struct mbuf **, caddr_t *);
@


1.50
log
@Convert macros to functions to reduce kernel memory usage.

In snaps for a while (way too long, according to deraadt@@)
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.49 2009/03/30 19:58:50 blambert Exp $	*/
d264 1
a264 1
int nfssvc_nfsd(struct nfsd_srvargs *, caddr_t, struct proc *);
@


1.49
log
@Convert a sizeable macro to a much-leaner function. Saves (IIRC) 5k on i386.

In snaps for a while.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.48 2009/01/20 18:03:33 blambert Exp $	*/
d258 2
@


1.48
log
@Start reworking NFS client mbuf handling by creating an interface which
requires well-formed mbuf chains to work. Existing function name is now
a wrapper to this interface. Much, much more work to follow which will
build on this.

Truly change we can believe in.

ok thib@@, who would have preferred this in two commits, but I'm impatient :)

testing on multiple arches (i386, arm, amd64, and sparc64 at least) by many,
thanks to all who did so
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.47 2009/01/18 21:04:41 blambert Exp $	*/
d257 1
@


1.47
log
@remove function which only called nfssvc_iod(), and pass nfssvc_iod()
to kthread_create()

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.46 2009/01/16 17:11:28 thib Exp $	*/
d190 2
d218 1
a218 1
void nfsm_rpchead(struct nfsreq *, struct ucred *, int, struct mbuf *, int);
@


1.46
log
@turn nfs_msg into void functions, also make it take an nfsreq
argument since all of the info we need is there, makes it and
the use it a tad bit nicer.

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.45 2009/01/15 19:41:18 thib Exp $	*/
d263 1
a263 1
int nfssvc_iod(struct proc *);
@


1.45
log
@remove prototypes for nonexistent functions
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.44 2008/10/16 07:57:06 blambert Exp $	*/
d199 1
a199 1
int nfs_msg(struct proc *, char *, char *);
@


1.44
log
@Don't hide the fact that NFS uses vop_generic_* functions behind
#define's in nfs_var.h

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.43 2008/08/09 10:14:02 thib Exp $	*/
a112 4
int nfs_valloc(void *);
int nfs_vfree(void *);
int nfs_truncate(void *);
int nfs_update(void *);
@


1.43
log
@o nfs_vinvalbuf() is always called with the intrflag as 1, and then
  checks if the mount is actually interrutable, and if not sets it 0.
  remove this argument from nfs_vinvalbuf and just do the checking inside
  the function.
o give nfs_vinvalbuf() a makeover so it looks nice. (spacing, casts, &c);
o Actually pass PCATCH too tsleep() if the mount it interrutable.

ok art@@, blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.42 2008/06/14 00:23:26 thib Exp $	*/
a128 4
#define	nfs_revoke	vop_generic_revoke
#define	nfs_lock	vop_generic_lock
#define	nfs_unlock	vop_generic_unlock
#define	nfs_islocked	vop_generic_islocked
@


1.42
log
@put the canonical ifdef dance for multiple inclusion, also put all the
contents of this file inside #ifdef _KERNEL; there's nothing here that
userland should ever need/touch.

but then again, some userland programs define _KERNEL before they include
kernel header files *shrugh*...

survived a build, OK blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.41 2008/06/13 22:11:32 blambert Exp $	*/
d50 1
a50 2
int nfs_vinvalbuf(struct vnode *, int, struct ucred *, struct proc *,
		       int);
@


1.41
log
@Kill one-liner macro which obfuscated mbuf pointer assignment.

Rescue nfsm_reqhead macro name and rename nfsm_reqh.

End of one-liners from nfsm_subs.h.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.40 2008/06/13 03:49:26 blambert Exp $	*/
d34 1
a34 1
 * XXX needs <nfs/rpcv2.h> and <nfs/nfs.h> because of typedefs
d36 4
a40 18
struct vnode;
struct uio;
struct ucred;
struct proc;
struct buf;
struct nfs_diskless;
struct sockaddr_in;
struct nfs_dlmount;
struct vnode;
struct nfsd;
struct mbuf;
struct file;
struct nfssvc_sock;
struct nfsmount;
struct socket;
struct nfsreq;
struct vattr;
struct nameidata;
d44 1
a44 4
struct nfsd_srvargs;
struct nfsrv_descript;
struct nfs_fattr;
union nethostaddr;
d282 3
@


1.40
log
@Replace one-line macro which only obfuscated the fact that
the function it was named after took 4 arguments instead of 2.

"get it in; get it in; get it in" thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.39 2008/06/12 20:24:06 blambert Exp $	*/
d240 1
a240 1
struct mbuf *nfsm_reqh(struct vnode *, u_long, int);
@


1.39
log
@Remove now-vestigial bpos pointer from NFS. For building outgoing
NFS mbufs, mbufs now contain all their internal buffer state internally,
the way god intended.

ok thib@@

testing johan@@ (and possibly merdely@@; this diff's been around for a bit...)
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.38 2008/06/10 22:59:09 thib Exp $	*/
d263 1
a263 1
void nfsm_srvpostopattr(struct nfsrv_descript *, int, struct vattr *,
@


1.38
log
@
o Avoid putting duplicate entries into the name cache,
  add a function to handle cache_enter()'s for us since
  we need to update the appropriate timestamps so we don't
  miss on lookup;
o Do not purge the dvp in nfs_rmdir(), since there's no need;
o cache the new entry created in nfs_mkdir();
o Do caching of the access modes, this drastically reduces the
  amount of over the wire access RPCs we do in the NFSv3 case.

This diff was written by Pedro Martelletto, sometime in 2004.
A lot of people have been running with it at one time or another,
this includes at least markus and matthieu.

OK deraadt@@, blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.37 2008/06/09 22:49:15 djm Exp $	*/
d217 1
a217 1
		struct mbuf **, struct mbuf **, caddr_t *);
d240 1
a240 1
struct mbuf *nfsm_reqh(struct vnode *, u_long, int, caddr_t *);
d243 1
a243 1
void *nfsm_build(struct mbuf **, u_int, caddr_t *);
d245 3
a247 3
void nfsm_uiotombuf(struct mbuf **, struct uio *, size_t, caddr_t *);
void nfsm_strtombuf(struct mbuf **, void *, size_t, caddr_t *);
void nfsm_buftombuf(struct mbuf **, void *, size_t, caddr_t *);
d259 1
a259 1
void nfsm_v3attrbuild(struct mbuf **, struct vattr *, int, caddr_t *);
d262 1
a262 1
		      struct vattr *, struct mbuf **, char **);
d264 1
a264 1
			     struct mbuf **, char **);
@


1.37
log
@nfsm_get_xid() => nfs_get_xid() after thib@@ informed me that the
nfsm_* functions are for mbufs
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.36 2008/06/09 22:47:42 djm Exp $	*/
d252 1
@


1.36
log
@Introduce a facility to generate unpredictable 32 bit numbers with
near maximal (2^32) cycle times. These are useful for network
IDs in cases where there are negative consequences to ID prediction
and/or reuse.

Use the idgen32() functions to generate IPv6 IDs and NFS client/server
XIDs.

Pseudorandom permutation code in crypto/idgen.c based on public
domain skip32.c from Greg Rose.

feedback & ok thib@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.35 2008/04/22 18:53:34 thib Exp $	*/
d241 1
a241 1
u_int32_t nfsm_get_xid(void);
@


1.35
log
@remove the "kerbflag" argument from nfsrv_fhtovp() and nfs_namei()
(the latter only had it to pass it to nfsrv_fhtovp()).

appropriate cleanup also;

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.34 2008/04/14 13:46:13 blambert Exp $	*/
d241 1
@


1.34
log
@Rework NFS mbuf write routines:

nfsm_uiotombuf():
- no meaningful return, function becomes void
- replace frankensteined uiomove/MGET with actual call to uiomove

nfsm_strtmbuf():
- no meaningful return, becomes void
- rename and reorder parameters to be consistent with other functions
- becomes wrapper to nfsm_uiotombuf

nfsm_buftombuf():
- new function; unused but slated for future use
- wrapper to nfsm_uiotombuf

As a bonus, making these functions void removes much unneeded code and
garbage collects `magic' variable t2 which was only used (invisibly)
by the macros from nfsm_subs.h

Preps the way for removing much more NFS goo...

testing by myself, thib@@ and merdely@@
ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.33 2008/01/06 17:38:23 blambert Exp $	*/
d256 1
a256 1
		   struct proc *, int);
d266 1
a266 1
		      struct nfssvc_sock *, struct mbuf *, int *, int);
@


1.33
log
@More NFS-related kernel shrinkage...

When you use a macro ~200 times, it tends to bloat your code, so make a
function out of it.

Shaves ~8.5 kB from my kernel.

ok thib@@, "looks good" krw@@

In snaps for 1+ week with no negative reports.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.32 2007/12/13 18:32:55 blambert Exp $	*/
d244 3
a246 1
int nfsm_uiotombuf(struct uio *, struct mbuf **, int, caddr_t *);
d294 3
@


1.32
log
@convert massive (expanded to 150+ lines) nfsm_v3attr macro to a function

shaves an insane (~8K) amount from an i386 kernel

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.31 2007/10/28 14:12:41 thib Exp $	*/
d242 1
a242 1

@


1.31
log
@Remove the "frev" argument from nfs_rephead(); and clean up the "frev"
variables, that are declared all over, since they are passed via macros
to nfs_rephead(); which doesn't do anything with it.

OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.30 2007/10/14 19:34:41 thib Exp $	*/
d255 1
@


1.30
log
@Remove now unused functions dealing with kerberos
authentication.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.29 2007/10/13 17:38:43 thib Exp $	*/
d217 1
a217 1
		u_quad_t *, struct mbuf **, struct mbuf **, caddr_t *);
@


1.29
log
@Remove alot of dead kerberos code (add sane comments too).

Cleanup and partly redo the way we create the RPC header, by having
nfsm_rpchead() do a bit more work. Right now this is pretty RPCAUTH_UNIX
centric, but since it is the only auth method we support right now thats
fine.

Make sure we can never generate a zero xid, thats forbidden by the RFC.

Misc cleanup.

tested by a few.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.28 2007/06/21 22:59:49 thib Exp $	*/
a286 6
int nfs_getauth(struct nfsmount *, struct nfsreq *, struct ucred *,
		     char **, int *, char *, int *, NFSKERBKEY_T);
int nfs_getnickauth(struct nfsmount *, struct ucred *, char **, int *,
			 char *, int);
int nfs_savenickauth(struct nfsmount *, struct ucred *, int, NFSKERBKEY_T,
			  struct mbuf **, char **, struct mbuf *);
@


1.28
log
@remove a whole bunch of duplicate function
prototypes.
(survived build/release on macppc/amd64).

ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.27 2007/06/01 07:13:47 thib Exp $	*/
d241 2
a242 3
struct mbuf *nfsm_rpchead(struct ucred *, int, int, int, int, char *, int,
			       char *, struct mbuf *, int, struct mbuf **,
			       u_int32_t *);
@


1.27
log
@daddr_t -> daddr64_t;
Basically the usage of daddr_t was to math out arguments to
nfs_getcacheblk, wich calls getblk();

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.26 2007/04/19 14:46:44 thib Exp $	*/
d82 1
d144 7
@


1.26
log
@Replace the nfskevq_lock lockmgr lock with rwlock.
Replace nfs_kqinit() wich just calls lockinit with
RWLOCK_INITALIZER. Assorted cleanup.

ok tedu@@
"reads good" art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.25 2007/04/13 17:09:22 thib Exp $	*/
d66 1
a66 1
struct buf *nfs_getcacheblk(struct vnode *, daddr_t, int, struct proc *);
@


1.25
log
@Move the declaration of VN_KNOTE() into vnode.h instead of having
multiple defines all over;

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.24 2007/04/11 12:18:54 thib Exp $	*/
a288 1
void nfs_kqinit(void);
@


1.24
log
@remove duplicate prototype;

ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.23 2004/08/03 17:11:48 marius Exp $	*/
a287 1

a290 2
#define VN_KNOTE(vp, b) \
        KNOTE(&vp->v_selectinfo.vsi_selinfo.si_note, (b))
@


1.23
log
@NFS commit coalescion: instead of sending a commit for each block, coalesce
these into larger ranges wherever possible.

this should speed up NFS writes quite a bit.

ok art@@ millert@@ pedro@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.22 2004/07/21 17:30:56 marius Exp $	*/
a72 1
int nfs_boot_init(struct nfs_diskless *, struct proc *);
@


1.22
log
@kqueue support for NFS, adapted from netbsd.

ok art@@ pedro@@, "get it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.21 2002/07/03 20:57:00 nate Exp $	*/
d260 7
@


1.21
log
@Remove unused function parameter 'cache' from nfs_rephead
ok costa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.20 2002/07/02 04:23:25 ericj Exp $	*/
d280 8
@


1.20
log
@
use hash.h for nfs_hash as well as namei's hash
ok art@@ costa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.19 2002/04/10 18:16:46 csapuntz Exp $	*/
d209 2
a210 2
int nfs_rephead(int, struct nfsrv_descript *, struct nfssvc_sock *,
		     int, int, u_quad_t *, struct mbuf **, struct mbuf **,			     caddr_t *);
@


1.19
log
@nfs_realign from FreeBSD. The old code was over-optimized, occasionally overwriting
other parts of a TCP stream, occasionally dereferencing NULL pointers
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.18 2002/03/14 01:27:13 millert Exp $	*/
a77 1
u_long nfs_hash(nfsfh_t *, int);
@


1.18
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.17 2001/12/19 08:58:06 art Exp $	*/
a217 1
void nfs_realign(struct mbuf *, int);
@


1.17
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.15 2001/11/15 23:15:15 art Exp $	*/
d64 7
a70 7
int nfs_bioread __P((struct vnode *, struct uio *, int, struct ucred *));
int nfs_write __P((void *));
struct buf *nfs_getcacheblk __P((struct vnode *, daddr_t, int, struct proc *));
int nfs_vinvalbuf __P((struct vnode *, int, struct ucred *, struct proc *,
		       int));
int nfs_asyncio __P((struct buf *));
int nfs_doio __P((struct buf *, struct proc *));
d73 2
a74 2
int nfs_boot_init __P((struct nfs_diskless *, struct proc *));
int nfs_boot_init __P((struct nfs_diskless *, struct proc *));
d77 5
a81 5
void nfs_nhinit __P((void));
u_long nfs_hash __P((nfsfh_t *, int));
int nfs_nget __P((struct mount *, nfsfh_t *, int, struct nfsnode **));
int nfs_inactive __P((void *));
int nfs_reclaim __P((void *));
d84 32
a115 32
int nfs_null __P((struct vnode *, struct ucred *, struct proc *));
int nfs_access __P((void *));
int nfs_open __P((void *));
int nfs_close __P((void *));
int nfs_getattr __P((void *));
int nfs_setattr __P((void *));
int nfs_setattrrpc __P((struct vnode *, struct vattr *, struct ucred *,
			struct proc *));
int nfs_lookup __P((void *));
int nfs_read __P((void *));
int nfs_readlink __P((void *));
int nfs_readlinkrpc __P((struct vnode *, struct uio *, struct ucred *));
int nfs_readrpc __P((struct vnode *, struct uio *));
int nfs_writerpc __P((struct vnode *, struct uio *, int *, int *));
int nfs_mknodrpc __P((struct vnode *, struct vnode **, struct componentname *,
		      struct vattr *));
int nfs_mknod __P((void *));
int nfs_create __P((void *));
int nfs_remove __P((void *));
int nfs_removeit __P((struct sillyrename *));
int nfs_removerpc __P((struct vnode *, char *, int, struct ucred *,
		       struct proc *));
int nfs_rename __P((void *));
int nfs_renameit __P((struct vnode *, struct componentname *,
		      struct sillyrename *));
int nfs_renamerpc __P((struct vnode *, char *, int, struct vnode *, char *, int,
		       struct ucred *, struct proc *));
int nfs_link __P((void *));
int nfs_symlink __P((void *));
int nfs_mkdir __P((void *));
int nfs_rmdir __P((void *));
int nfs_readdir __P((void *));
d118 27
a144 27
int nfs_sillyrename __P((struct vnode *, struct vnode *,
			 struct componentname *));
int nfs_lookitup __P((struct vnode *, char *, int, struct ucred *,
		      struct proc *, struct nfsnode **));
int nfs_commit __P((struct vnode *, u_quad_t, int, struct proc *));
int nfs_bmap __P((void *));
int nfs_strategy __P((void *));
int nfs_mmap __P((void *));
int nfs_fsync __P((void *));
int nfs_flush __P((struct vnode *, struct ucred *, int, struct proc *, int));
int nfs_pathconf __P((void *));
int nfs_advlock __P((void *));
int nfs_print __P((void *));
int nfs_blkatoff __P((void *));
int nfs_valloc __P((void *));
int nfs_vfree __P((void *));
int nfs_truncate __P((void *));
int nfs_update __P((void *));
int nfs_bwrite __P((void *));
int nfs_writebp __P((struct buf *, int));
int nfsspec_access __P((void *));
int nfsspec_read __P((void *));
int nfsspec_write __P((void *));
int nfsspec_close __P((void *));
int nfsfifo_read __P((void *));
int nfsfifo_write __P((void *));
int nfsfifo_close __P((void *));
d147 51
a197 51
int nfsrv3_access __P((struct nfsrv_descript *, struct nfssvc_sock *,
		       struct proc *, struct mbuf **));
int nfsrv_getattr __P((struct nfsrv_descript *, struct nfssvc_sock *,
		       struct proc *, struct mbuf **));
int nfsrv_setattr __P((struct nfsrv_descript *, struct nfssvc_sock *,
		       struct proc *, struct mbuf **));
int nfsrv_lookup __P((struct nfsrv_descript *, struct nfssvc_sock *,
		      struct proc *, struct mbuf **));
int nfsrv_readlink __P((struct nfsrv_descript *, struct nfssvc_sock *,
			struct proc *, struct mbuf **));
int nfsrv_read __P((struct nfsrv_descript *, struct nfssvc_sock *,
		    struct proc *, struct mbuf **));
int nfsrv_write __P((struct nfsrv_descript *, struct nfssvc_sock *,
		     struct proc *, struct mbuf **));
int nfsrv_writegather __P((struct nfsrv_descript **, struct nfssvc_sock *,
			   struct proc *, struct mbuf **));
void nfsrvw_coalesce __P((struct nfsrv_descript *, struct nfsrv_descript *));
int nfsrv_create __P((struct nfsrv_descript *, struct nfssvc_sock *,
		      struct proc *, struct mbuf **));
int nfsrv_mknod __P((struct nfsrv_descript *, struct nfssvc_sock *,
		     struct proc *, struct mbuf **));
int nfsrv_remove __P((struct nfsrv_descript *, struct nfssvc_sock *,
		      struct proc *, struct mbuf **));
int nfsrv_rename __P((struct nfsrv_descript *, struct nfssvc_sock *,
		      struct proc *, struct mbuf **));
int nfsrv_link __P((struct nfsrv_descript *, struct nfssvc_sock *,
		    struct proc *, struct mbuf **));
int nfsrv_symlink __P((struct nfsrv_descript *, struct nfssvc_sock *,
		       struct proc *, struct mbuf **));
int nfsrv_mkdir __P((struct nfsrv_descript *, struct nfssvc_sock *,
		     struct proc *, struct mbuf **));
int nfsrv_rmdir __P((struct nfsrv_descript *, struct nfssvc_sock *,
		     struct proc *, struct mbuf **));
int nfsrv_readdir __P((struct nfsrv_descript *, struct nfssvc_sock *,
		       struct proc *, struct mbuf **));
int nfsrv_readdirplus __P((struct nfsrv_descript *, struct nfssvc_sock *,
			   struct proc *, struct mbuf **));
int nfsrv_commit __P((struct nfsrv_descript *, struct nfssvc_sock *,
		      struct proc *, struct mbuf **));
int nfsrv_statfs __P((struct nfsrv_descript *, struct nfssvc_sock *,
		      struct proc *, struct mbuf **));
int nfsrv_fsinfo __P((struct nfsrv_descript *, struct nfssvc_sock *,
		      struct proc *, struct mbuf **));
int nfsrv_pathconf __P((struct nfsrv_descript *, struct nfssvc_sock *,
		        struct proc *, struct mbuf **));
int nfsrv_null __P((struct nfsrv_descript *, struct nfssvc_sock *,
		    struct proc *, struct mbuf **));
int nfsrv_noop __P((struct nfsrv_descript *, struct nfssvc_sock *,
		    struct proc *, struct mbuf **));
int nfsrv_access __P((struct vnode *, int, struct ucred *, int, struct proc *,
		    int));
d200 8
a207 8
int nfs_connect __P((struct nfsmount *, struct nfsreq *));
int nfs_reconnect __P((struct nfsreq *));
void nfs_disconnect __P((struct nfsmount *));
int nfs_send __P((struct socket *, struct mbuf *, struct mbuf *,
		  struct nfsreq *));
int nfs_receive __P((struct nfsreq *, struct mbuf **, struct mbuf **));
int nfs_reply __P((struct nfsreq *));
int nfs_request __P((struct vnode *, struct mbuf *, int, struct proc *,
d209 17
a225 17
		     caddr_t *));
int nfs_rephead __P((int, struct nfsrv_descript *, struct nfssvc_sock *,
		     int, int, u_quad_t *, struct mbuf **, struct mbuf **,			     caddr_t *));
void nfs_timer __P((void *));
int nfs_sigintr __P((struct nfsmount *, struct nfsreq *, struct proc *));
int nfs_sndlock __P((int *, struct nfsreq *));
void nfs_sndunlock __P((int *));
int nfs_rcvlock __P((struct nfsreq *));
void nfs_rcvunlock __P((int *));
void nfs_realign __P((struct mbuf *, int));
int nfs_getreq __P((struct nfsrv_descript *, struct nfsd *, int));
int nfs_msg __P((struct proc *, char *, char *));
void nfsrv_rcv __P((struct socket *, caddr_t, int));
int nfsrv_getstream __P((struct nfssvc_sock *, int));
int nfsrv_dorec __P((struct nfssvc_sock *, struct nfsd *,
		     struct nfsrv_descript **));
void nfsrv_wakenfsd __P((struct nfssvc_sock *));
d228 5
a232 5
void nfsrv_initcache __P((void ));
int nfsrv_getcache __P((struct nfsrv_descript *, struct nfssvc_sock *,
			struct mbuf **));
void nfsrv_updatecache __P((struct nfsrv_descript *, int, struct mbuf *));
void nfsrv_cleancache __P((void));
d235 2
a236 2
struct mbuf *nfsm_reqh __P((struct vnode *, u_long, int, caddr_t *));
struct mbuf *nfsm_rpchead __P((struct ucred *, int, int, int, int, char *, int,
d238 11
a248 11
			       u_int32_t *));
int nfsm_mbuftouio __P((struct mbuf **, struct uio *, int, caddr_t *));
int nfsm_uiotombuf __P((struct uio *, struct mbuf **, int, caddr_t *));
int nfsm_disct __P((struct mbuf **, caddr_t *, int, int, caddr_t *));
int nfs_adv __P((struct mbuf **, caddr_t *, int, int));
int nfsm_strtmbuf __P((struct mbuf **, char **, char *, long));
int nfs_vfs_init __P((struct vfsconf *));
int nfs_loadattrcache __P((struct vnode **, struct mbuf **, caddr_t *,
			   struct vattr *));
int nfs_getattrcache __P((struct vnode *, struct vattr *));
int nfs_namei __P((struct nameidata *, fhandle_t *, int, struct nfssvc_sock *,
d250 15
a264 15
		   struct proc *, int));
void nfsm_adj __P((struct mbuf *, int, int));
void nfsm_srvwcc __P((struct nfsrv_descript *, int, struct vattr *, int,
		      struct vattr *, struct mbuf **, char **));
void nfsm_srvpostopattr __P((struct nfsrv_descript *, int, struct vattr *,
			     struct mbuf **, char **));
void nfsm_srvfattr __P((struct nfsrv_descript *, struct vattr *,
			struct nfs_fattr *));
int nfsrv_fhtovp __P((fhandle_t *, int, struct vnode **, struct ucred *,
		      struct nfssvc_sock *, struct mbuf *, int *, int));
int netaddr_match __P((int, union nethostaddr *, struct mbuf *));
void nfs_clearcommit __P((struct mount *));
int nfsrv_errmap __P((struct nfsrv_descript *, int));
void nfsrvw_sort __P((gid_t *, int));
void nfsrv_setcred __P((struct ucred *, struct ucred *));
d267 15
a281 15
int sys_nfssvc __P((struct proc *, void *, register_t *));
int nfssvc_addsock __P((struct file *, struct mbuf *));
int nfssvc_nfsd __P((struct nfsd_srvargs *, caddr_t, struct proc *));
void nfsrv_zapsock __P((struct nfssvc_sock *));
void nfsrv_slpderef __P((struct nfssvc_sock *));
void nfsrv_init __P((int));
int nfssvc_iod __P((struct proc *));
void start_nfsio __P((void *));
void nfs_getset_niothreads __P((int));
int nfs_getauth __P((struct nfsmount *, struct nfsreq *, struct ucred *,
		     char **, int *, char *, int *, NFSKERBKEY_T));
int nfs_getnickauth __P((struct nfsmount *, struct ucred *, char **, int *,
			 char *, int));
int nfs_savenickauth __P((struct nfsmount *, struct ucred *, int, NFSKERBKEY_T,
			  struct mbuf **, char **, struct mbuf *));
@


1.16
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d122 1
a122 1
int nfs_commit __P((struct vnode *, u_quad_t, unsigned, struct proc *));
d137 1
a260 1

a261 8
void nfs_merge_commit_ranges __P((struct vnode *));
int nfs_in_committed_range __P((struct vnode *, off_t, off_t));
int nfs_in_tobecommitted_range __P((struct vnode *, off_t, off_t));
void nfs_add_committed_range __P((struct vnode *, off_t, off_t));
void nfs_del_committed_range __P((struct vnode *, off_t, off_t));
void nfs_add_tobecommitted_range __P((struct vnode *, off_t, off_t));
void nfs_del_tobecommitted_range __P((struct vnode *, off_t, off_t));

@


1.16.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.16 2001/11/27 05:27:12 art Exp $	*/
d64 7
a70 7
int nfs_bioread(struct vnode *, struct uio *, int, struct ucred *);
int nfs_write(void *);
struct buf *nfs_getcacheblk(struct vnode *, daddr_t, int, struct proc *);
int nfs_vinvalbuf(struct vnode *, int, struct ucred *, struct proc *,
		       int);
int nfs_asyncio(struct buf *);
int nfs_doio(struct buf *, struct proc *);
d73 2
a74 2
int nfs_boot_init(struct nfs_diskless *, struct proc *);
int nfs_boot_init(struct nfs_diskless *, struct proc *);
d77 5
a81 5
void nfs_nhinit(void);
u_long nfs_hash(nfsfh_t *, int);
int nfs_nget(struct mount *, nfsfh_t *, int, struct nfsnode **);
int nfs_inactive(void *);
int nfs_reclaim(void *);
d84 32
a115 32
int nfs_null(struct vnode *, struct ucred *, struct proc *);
int nfs_access(void *);
int nfs_open(void *);
int nfs_close(void *);
int nfs_getattr(void *);
int nfs_setattr(void *);
int nfs_setattrrpc(struct vnode *, struct vattr *, struct ucred *,
			struct proc *);
int nfs_lookup(void *);
int nfs_read(void *);
int nfs_readlink(void *);
int nfs_readlinkrpc(struct vnode *, struct uio *, struct ucred *);
int nfs_readrpc(struct vnode *, struct uio *);
int nfs_writerpc(struct vnode *, struct uio *, int *, int *);
int nfs_mknodrpc(struct vnode *, struct vnode **, struct componentname *,
		      struct vattr *);
int nfs_mknod(void *);
int nfs_create(void *);
int nfs_remove(void *);
int nfs_removeit(struct sillyrename *);
int nfs_removerpc(struct vnode *, char *, int, struct ucred *,
		       struct proc *);
int nfs_rename(void *);
int nfs_renameit(struct vnode *, struct componentname *,
		      struct sillyrename *);
int nfs_renamerpc(struct vnode *, char *, int, struct vnode *, char *, int,
		       struct ucred *, struct proc *);
int nfs_link(void *);
int nfs_symlink(void *);
int nfs_mkdir(void *);
int nfs_rmdir(void *);
int nfs_readdir(void *);
d118 26
a143 26
int nfs_sillyrename(struct vnode *, struct vnode *,
			 struct componentname *);
int nfs_lookitup(struct vnode *, char *, int, struct ucred *,
		      struct proc *, struct nfsnode **);
int nfs_commit(struct vnode *, u_quad_t, unsigned int, struct proc *);
int nfs_bmap(void *);
int nfs_strategy(void *);
int nfs_mmap(void *);
int nfs_fsync(void *);
int nfs_flush(struct vnode *, struct ucred *, int, struct proc *, int);
int nfs_pathconf(void *);
int nfs_advlock(void *);
int nfs_print(void *);
int nfs_blkatoff(void *);
int nfs_valloc(void *);
int nfs_vfree(void *);
int nfs_truncate(void *);
int nfs_update(void *);
int nfs_bwrite(void *);
int nfsspec_access(void *);
int nfsspec_read(void *);
int nfsspec_write(void *);
int nfsspec_close(void *);
int nfsfifo_read(void *);
int nfsfifo_write(void *);
int nfsfifo_close(void *);
d146 51
a196 51
int nfsrv3_access(struct nfsrv_descript *, struct nfssvc_sock *,
		       struct proc *, struct mbuf **);
int nfsrv_getattr(struct nfsrv_descript *, struct nfssvc_sock *,
		       struct proc *, struct mbuf **);
int nfsrv_setattr(struct nfsrv_descript *, struct nfssvc_sock *,
		       struct proc *, struct mbuf **);
int nfsrv_lookup(struct nfsrv_descript *, struct nfssvc_sock *,
		      struct proc *, struct mbuf **);
int nfsrv_readlink(struct nfsrv_descript *, struct nfssvc_sock *,
			struct proc *, struct mbuf **);
int nfsrv_read(struct nfsrv_descript *, struct nfssvc_sock *,
		    struct proc *, struct mbuf **);
int nfsrv_write(struct nfsrv_descript *, struct nfssvc_sock *,
		     struct proc *, struct mbuf **);
int nfsrv_writegather(struct nfsrv_descript **, struct nfssvc_sock *,
			   struct proc *, struct mbuf **);
void nfsrvw_coalesce(struct nfsrv_descript *, struct nfsrv_descript *);
int nfsrv_create(struct nfsrv_descript *, struct nfssvc_sock *,
		      struct proc *, struct mbuf **);
int nfsrv_mknod(struct nfsrv_descript *, struct nfssvc_sock *,
		     struct proc *, struct mbuf **);
int nfsrv_remove(struct nfsrv_descript *, struct nfssvc_sock *,
		      struct proc *, struct mbuf **);
int nfsrv_rename(struct nfsrv_descript *, struct nfssvc_sock *,
		      struct proc *, struct mbuf **);
int nfsrv_link(struct nfsrv_descript *, struct nfssvc_sock *,
		    struct proc *, struct mbuf **);
int nfsrv_symlink(struct nfsrv_descript *, struct nfssvc_sock *,
		       struct proc *, struct mbuf **);
int nfsrv_mkdir(struct nfsrv_descript *, struct nfssvc_sock *,
		     struct proc *, struct mbuf **);
int nfsrv_rmdir(struct nfsrv_descript *, struct nfssvc_sock *,
		     struct proc *, struct mbuf **);
int nfsrv_readdir(struct nfsrv_descript *, struct nfssvc_sock *,
		       struct proc *, struct mbuf **);
int nfsrv_readdirplus(struct nfsrv_descript *, struct nfssvc_sock *,
			   struct proc *, struct mbuf **);
int nfsrv_commit(struct nfsrv_descript *, struct nfssvc_sock *,
		      struct proc *, struct mbuf **);
int nfsrv_statfs(struct nfsrv_descript *, struct nfssvc_sock *,
		      struct proc *, struct mbuf **);
int nfsrv_fsinfo(struct nfsrv_descript *, struct nfssvc_sock *,
		      struct proc *, struct mbuf **);
int nfsrv_pathconf(struct nfsrv_descript *, struct nfssvc_sock *,
		        struct proc *, struct mbuf **);
int nfsrv_null(struct nfsrv_descript *, struct nfssvc_sock *,
		    struct proc *, struct mbuf **);
int nfsrv_noop(struct nfsrv_descript *, struct nfssvc_sock *,
		    struct proc *, struct mbuf **);
int nfsrv_access(struct vnode *, int, struct ucred *, int, struct proc *,
		    int);
d199 8
a206 8
int nfs_connect(struct nfsmount *, struct nfsreq *);
int nfs_reconnect(struct nfsreq *);
void nfs_disconnect(struct nfsmount *);
int nfs_send(struct socket *, struct mbuf *, struct mbuf *,
		  struct nfsreq *);
int nfs_receive(struct nfsreq *, struct mbuf **, struct mbuf **);
int nfs_reply(struct nfsreq *);
int nfs_request(struct vnode *, struct mbuf *, int, struct proc *,
d208 17
a224 16
		     caddr_t *);
int nfs_rephead(int, struct nfsrv_descript *, struct nfssvc_sock *,
		     int, int, u_quad_t *, struct mbuf **, struct mbuf **,			     caddr_t *);
void nfs_timer(void *);
int nfs_sigintr(struct nfsmount *, struct nfsreq *, struct proc *);
int nfs_sndlock(int *, struct nfsreq *);
void nfs_sndunlock(int *);
int nfs_rcvlock(struct nfsreq *);
void nfs_rcvunlock(int *);
int nfs_getreq(struct nfsrv_descript *, struct nfsd *, int);
int nfs_msg(struct proc *, char *, char *);
void nfsrv_rcv(struct socket *, caddr_t, int);
int nfsrv_getstream(struct nfssvc_sock *, int);
int nfsrv_dorec(struct nfssvc_sock *, struct nfsd *,
		     struct nfsrv_descript **);
void nfsrv_wakenfsd(struct nfssvc_sock *);
d227 5
a231 5
void nfsrv_initcache(void );
int nfsrv_getcache(struct nfsrv_descript *, struct nfssvc_sock *,
			struct mbuf **);
void nfsrv_updatecache(struct nfsrv_descript *, int, struct mbuf *);
void nfsrv_cleancache(void);
d234 2
a235 2
struct mbuf *nfsm_reqh(struct vnode *, u_long, int, caddr_t *);
struct mbuf *nfsm_rpchead(struct ucred *, int, int, int, int, char *, int,
d237 11
a247 11
			       u_int32_t *);
int nfsm_mbuftouio(struct mbuf **, struct uio *, int, caddr_t *);
int nfsm_uiotombuf(struct uio *, struct mbuf **, int, caddr_t *);
int nfsm_disct(struct mbuf **, caddr_t *, int, int, caddr_t *);
int nfs_adv(struct mbuf **, caddr_t *, int, int);
int nfsm_strtmbuf(struct mbuf **, char **, char *, long);
int nfs_vfs_init(struct vfsconf *);
int nfs_loadattrcache(struct vnode **, struct mbuf **, caddr_t *,
			   struct vattr *);
int nfs_getattrcache(struct vnode *, struct vattr *);
int nfs_namei(struct nameidata *, fhandle_t *, int, struct nfssvc_sock *,
d249 24
a272 24
		   struct proc *, int);
void nfsm_adj(struct mbuf *, int, int);
void nfsm_srvwcc(struct nfsrv_descript *, int, struct vattr *, int,
		      struct vattr *, struct mbuf **, char **);
void nfsm_srvpostopattr(struct nfsrv_descript *, int, struct vattr *,
			     struct mbuf **, char **);
void nfsm_srvfattr(struct nfsrv_descript *, struct vattr *,
			struct nfs_fattr *);
int nfsrv_fhtovp(fhandle_t *, int, struct vnode **, struct ucred *,
		      struct nfssvc_sock *, struct mbuf *, int *, int);
int netaddr_match(int, union nethostaddr *, struct mbuf *);

void nfs_clearcommit(struct mount *);
void nfs_merge_commit_ranges(struct vnode *);
int nfs_in_committed_range(struct vnode *, off_t, off_t);
int nfs_in_tobecommitted_range(struct vnode *, off_t, off_t);
void nfs_add_committed_range(struct vnode *, off_t, off_t);
void nfs_del_committed_range(struct vnode *, off_t, off_t);
void nfs_add_tobecommitted_range(struct vnode *, off_t, off_t);
void nfs_del_tobecommitted_range(struct vnode *, off_t, off_t);

int nfsrv_errmap(struct nfsrv_descript *, int);
void nfsrvw_sort(gid_t *, int);
void nfsrv_setcred(struct ucred *, struct ucred *);
d275 15
a289 15
int sys_nfssvc(struct proc *, void *, register_t *);
int nfssvc_addsock(struct file *, struct mbuf *);
int nfssvc_nfsd(struct nfsd_srvargs *, caddr_t, struct proc *);
void nfsrv_zapsock(struct nfssvc_sock *);
void nfsrv_slpderef(struct nfssvc_sock *);
void nfsrv_init(int);
int nfssvc_iod(struct proc *);
void start_nfsio(void *);
void nfs_getset_niothreads(int);
int nfs_getauth(struct nfsmount *, struct nfsreq *, struct ucred *,
		     char **, int *, char *, int *, NFSKERBKEY_T);
int nfs_getnickauth(struct nfsmount *, struct ucred *, char **, int *,
			 char *, int);
int nfs_savenickauth(struct nfsmount *, struct ucred *, int, NFSKERBKEY_T,
			  struct mbuf **, char **, struct mbuf *);
@


1.16.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.16.2.1 2002/06/11 03:32:04 art Exp $	*/
d78 1
d209 2
a210 2
int nfs_rephead(int, struct nfsrv_descript *, struct nfssvc_sock *, int,
		u_quad_t *, struct mbuf **, struct mbuf **, caddr_t *);
@


1.16.2.3
log
@Huge sync to NetBSD plus lots of bugfixes.
 - uvm is as in netbsd-current minus uvm_map forward merge.
 - various locking bugfixes in nfs.
 - make sure that all specops and fifoops are correct in all vnodeop vectors.
 - make the filesystem code more like filsystem code and less like vm code.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.16.2.2 2002/10/29 00:36:49 art Exp $	*/
d243 1
a243 1
			   struct vattr *, int flags);
a244 1
void nfs_delayedtruncate(struct vnode *);
a257 3

/* flags for nfs_loadattrcache and friends */
#define	NAC_NOTRUNC	1	/* don't truncate file size */
@


1.15
log
@Remove creds from struct buf, move the creds that nfs need into the nfs node.
While in the area, convert nfs node allocation from malloc to pool and do
some cleanups.
Based on the UBC changes in NetBSD. niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.14 2001/06/25 03:28:12 csapuntz Exp $	*/
d122 1
a122 1
int nfs_commit __P((struct vnode *, u_quad_t, int, struct proc *));
a136 1
int nfs_writebp __P((struct buf *, int));
d260 1
d262 8
@


1.14
log
@Remove NQNFS
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.13 2001/06/25 02:15:47 csapuntz Exp $	*/
d69 2
a70 2
int nfs_asyncio __P((struct buf *, struct ucred *));
int nfs_doio __P((struct buf *, struct ucred *, struct proc *));
d96 2
a97 3
int nfs_readrpc __P((struct vnode *, struct uio *, struct ucred *));
int nfs_writerpc __P((struct vnode *, struct uio *, struct ucred *, int *,
		      int *));
d122 1
a122 2
int nfs_commit __P((struct vnode *, u_quad_t, int, struct ucred *,
		    struct proc *));
@


1.13
log
@
Get rid of old directory caching scheme which caused persistent duplicates.

Still not correct for NFSv3 but that's hard.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.12 2000/06/30 01:06:02 art Exp $	*/
a48 2
struct nqlease;
struct nqhost;
a146 27

/* nfs_nqlease.c */
void nqnfs_lease_updatetime __P((int));
void nqnfs_clientlease __P((struct nfsmount *, struct nfsnode *, int, int,
			    time_t, u_quad_t));
void nqsrv_locklease __P((struct nqlease *));
void nqsrv_unlocklease __P((struct nqlease *));
int nqsrv_getlease __P((struct vnode *, u_int32_t *, int, struct nfssvc_sock *,
			struct proc *, struct mbuf *, int *, u_quad_t *,
			struct ucred *));
int nqnfs_vop_lease_check __P((void *));
void nqsrv_addhost __P((struct nqhost *, struct nfssvc_sock *, struct mbuf *));
void nqsrv_instimeq __P((struct nqlease *, u_int32_t));
int nqsrv_cmpnam __P((struct nfssvc_sock *, struct mbuf *, struct nqhost *));
void nqsrv_send_eviction __P((struct vnode *, struct nqlease *,
			      struct nfssvc_sock *, struct mbuf *,
			      struct ucred *));
void nqsrv_waitfor_expiry __P((struct nqlease *));
void nqnfs_serverd __P((void));
int nqnfsrv_getlease __P((struct nfsrv_descript *, struct nfssvc_sock *,
			  struct proc *, struct mbuf **));
int nqnfsrv_vacated __P((struct nfsrv_descript *, struct nfssvc_sock *,
			 struct proc *, struct mbuf **));
int nqnfs_getlease __P((struct vnode *, int, struct ucred *, struct proc *));
int nqnfs_vacated __P((struct vnode *, struct ucred *));
int nqnfs_callback __P((struct nfsmount *, struct mbuf *, struct mbuf *,
			caddr_t));
@


1.12
log
@Remove redundant declaration of nfs_init.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.11 2000/05/19 16:36:03 mickey Exp $	*/
d119 2
a120 2
int nfs_readdirrpc __P((struct vnode *, struct uio *, struct ucred *));
int nfs_readdirplusrpc __P((struct vnode *, struct uio *, struct ucred *));
a291 2
nfsuint64 *nfs_getcookie __P((struct nfsnode *, off_t off, int));
void nfs_invaldir __P((struct vnode *));
@


1.11
log
@from tsarna@@netbsd.org (sysctl changes to come later):
Death to nfsiod!

It is replaced by kernel threads that do the same thing. The number of
kernel threads used is set with the vfs.nfs.iothreads sysctl.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.10 2000/02/07 04:48:42 assar Exp $	*/
a275 1
void nfs_init __P((void));
@


1.10
log
@removed prototype of sys_getfh - it is now a normal syscall
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.9 1998/08/06 19:34:59 csapuntz Exp $	*/
d308 2
@


1.10.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.12 2000/06/30 01:06:02 art Exp $	*/
d276 1
a307 2
void start_nfsio __P((void *));
void nfs_getset_niothreads __P((int));
@


1.10.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.10.2.1 2001/05/14 22:44:58 niklas Exp $	*/
d49 2
d119 2
a120 2
int nfs_readdirrpc(struct vnode *, struct uio *, struct ucred *, int *);
int nfs_readdirplusrpc(struct vnode *, struct uio *, struct ucred *, int *);
d150 27
d292 2
@


1.10.2.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d69 2
a70 2
int nfs_asyncio __P((struct buf *));
int nfs_doio __P((struct buf *, struct proc *));
d96 3
a98 2
int nfs_readrpc __P((struct vnode *, struct uio *));
int nfs_writerpc __P((struct vnode *, struct uio *, int *, int *));
d123 2
a124 1
int nfs_commit __P((struct vnode *, u_quad_t, unsigned, struct proc *));
d139 1
a262 1

a263 8
void nfs_merge_commit_ranges __P((struct vnode *));
int nfs_in_committed_range __P((struct vnode *, off_t, off_t));
int nfs_in_tobecommitted_range __P((struct vnode *, off_t, off_t));
void nfs_add_committed_range __P((struct vnode *, off_t, off_t));
void nfs_del_committed_range __P((struct vnode *, off_t, off_t));
void nfs_add_tobecommitted_range __P((struct vnode *, off_t, off_t));
void nfs_del_tobecommitted_range __P((struct vnode *, off_t, off_t));

@


1.10.2.4
log
@Merge in trunk
@
text
@d122 1
a122 1
int nfs_commit __P((struct vnode *, u_quad_t, int, struct proc *));
a136 1
int nfs_writebp __P((struct buf *, int));
d260 1
d262 8
@


1.10.2.5
log
@Merge in -current from roughly a week ago
@
text
@d64 7
a70 7
int nfs_bioread(struct vnode *, struct uio *, int, struct ucred *);
int nfs_write(void *);
struct buf *nfs_getcacheblk(struct vnode *, daddr_t, int, struct proc *);
int nfs_vinvalbuf(struct vnode *, int, struct ucred *, struct proc *,
		       int);
int nfs_asyncio(struct buf *);
int nfs_doio(struct buf *, struct proc *);
d73 2
a74 2
int nfs_boot_init(struct nfs_diskless *, struct proc *);
int nfs_boot_init(struct nfs_diskless *, struct proc *);
d77 5
a81 5
void nfs_nhinit(void);
u_long nfs_hash(nfsfh_t *, int);
int nfs_nget(struct mount *, nfsfh_t *, int, struct nfsnode **);
int nfs_inactive(void *);
int nfs_reclaim(void *);
d84 32
a115 32
int nfs_null(struct vnode *, struct ucred *, struct proc *);
int nfs_access(void *);
int nfs_open(void *);
int nfs_close(void *);
int nfs_getattr(void *);
int nfs_setattr(void *);
int nfs_setattrrpc(struct vnode *, struct vattr *, struct ucred *,
			struct proc *);
int nfs_lookup(void *);
int nfs_read(void *);
int nfs_readlink(void *);
int nfs_readlinkrpc(struct vnode *, struct uio *, struct ucred *);
int nfs_readrpc(struct vnode *, struct uio *);
int nfs_writerpc(struct vnode *, struct uio *, int *, int *);
int nfs_mknodrpc(struct vnode *, struct vnode **, struct componentname *,
		      struct vattr *);
int nfs_mknod(void *);
int nfs_create(void *);
int nfs_remove(void *);
int nfs_removeit(struct sillyrename *);
int nfs_removerpc(struct vnode *, char *, int, struct ucred *,
		       struct proc *);
int nfs_rename(void *);
int nfs_renameit(struct vnode *, struct componentname *,
		      struct sillyrename *);
int nfs_renamerpc(struct vnode *, char *, int, struct vnode *, char *, int,
		       struct ucred *, struct proc *);
int nfs_link(void *);
int nfs_symlink(void *);
int nfs_mkdir(void *);
int nfs_rmdir(void *);
int nfs_readdir(void *);
d118 27
a144 27
int nfs_sillyrename(struct vnode *, struct vnode *,
			 struct componentname *);
int nfs_lookitup(struct vnode *, char *, int, struct ucred *,
		      struct proc *, struct nfsnode **);
int nfs_commit(struct vnode *, u_quad_t, int, struct proc *);
int nfs_bmap(void *);
int nfs_strategy(void *);
int nfs_mmap(void *);
int nfs_fsync(void *);
int nfs_flush(struct vnode *, struct ucred *, int, struct proc *, int);
int nfs_pathconf(void *);
int nfs_advlock(void *);
int nfs_print(void *);
int nfs_blkatoff(void *);
int nfs_valloc(void *);
int nfs_vfree(void *);
int nfs_truncate(void *);
int nfs_update(void *);
int nfs_bwrite(void *);
int nfs_writebp(struct buf *, int);
int nfsspec_access(void *);
int nfsspec_read(void *);
int nfsspec_write(void *);
int nfsspec_close(void *);
int nfsfifo_read(void *);
int nfsfifo_write(void *);
int nfsfifo_close(void *);
d147 51
a197 51
int nfsrv3_access(struct nfsrv_descript *, struct nfssvc_sock *,
		       struct proc *, struct mbuf **);
int nfsrv_getattr(struct nfsrv_descript *, struct nfssvc_sock *,
		       struct proc *, struct mbuf **);
int nfsrv_setattr(struct nfsrv_descript *, struct nfssvc_sock *,
		       struct proc *, struct mbuf **);
int nfsrv_lookup(struct nfsrv_descript *, struct nfssvc_sock *,
		      struct proc *, struct mbuf **);
int nfsrv_readlink(struct nfsrv_descript *, struct nfssvc_sock *,
			struct proc *, struct mbuf **);
int nfsrv_read(struct nfsrv_descript *, struct nfssvc_sock *,
		    struct proc *, struct mbuf **);
int nfsrv_write(struct nfsrv_descript *, struct nfssvc_sock *,
		     struct proc *, struct mbuf **);
int nfsrv_writegather(struct nfsrv_descript **, struct nfssvc_sock *,
			   struct proc *, struct mbuf **);
void nfsrvw_coalesce(struct nfsrv_descript *, struct nfsrv_descript *);
int nfsrv_create(struct nfsrv_descript *, struct nfssvc_sock *,
		      struct proc *, struct mbuf **);
int nfsrv_mknod(struct nfsrv_descript *, struct nfssvc_sock *,
		     struct proc *, struct mbuf **);
int nfsrv_remove(struct nfsrv_descript *, struct nfssvc_sock *,
		      struct proc *, struct mbuf **);
int nfsrv_rename(struct nfsrv_descript *, struct nfssvc_sock *,
		      struct proc *, struct mbuf **);
int nfsrv_link(struct nfsrv_descript *, struct nfssvc_sock *,
		    struct proc *, struct mbuf **);
int nfsrv_symlink(struct nfsrv_descript *, struct nfssvc_sock *,
		       struct proc *, struct mbuf **);
int nfsrv_mkdir(struct nfsrv_descript *, struct nfssvc_sock *,
		     struct proc *, struct mbuf **);
int nfsrv_rmdir(struct nfsrv_descript *, struct nfssvc_sock *,
		     struct proc *, struct mbuf **);
int nfsrv_readdir(struct nfsrv_descript *, struct nfssvc_sock *,
		       struct proc *, struct mbuf **);
int nfsrv_readdirplus(struct nfsrv_descript *, struct nfssvc_sock *,
			   struct proc *, struct mbuf **);
int nfsrv_commit(struct nfsrv_descript *, struct nfssvc_sock *,
		      struct proc *, struct mbuf **);
int nfsrv_statfs(struct nfsrv_descript *, struct nfssvc_sock *,
		      struct proc *, struct mbuf **);
int nfsrv_fsinfo(struct nfsrv_descript *, struct nfssvc_sock *,
		      struct proc *, struct mbuf **);
int nfsrv_pathconf(struct nfsrv_descript *, struct nfssvc_sock *,
		        struct proc *, struct mbuf **);
int nfsrv_null(struct nfsrv_descript *, struct nfssvc_sock *,
		    struct proc *, struct mbuf **);
int nfsrv_noop(struct nfsrv_descript *, struct nfssvc_sock *,
		    struct proc *, struct mbuf **);
int nfsrv_access(struct vnode *, int, struct ucred *, int, struct proc *,
		    int);
d200 8
a207 8
int nfs_connect(struct nfsmount *, struct nfsreq *);
int nfs_reconnect(struct nfsreq *);
void nfs_disconnect(struct nfsmount *);
int nfs_send(struct socket *, struct mbuf *, struct mbuf *,
		  struct nfsreq *);
int nfs_receive(struct nfsreq *, struct mbuf **, struct mbuf **);
int nfs_reply(struct nfsreq *);
int nfs_request(struct vnode *, struct mbuf *, int, struct proc *,
d209 17
a225 17
		     caddr_t *);
int nfs_rephead(int, struct nfsrv_descript *, struct nfssvc_sock *,
		     int, int, u_quad_t *, struct mbuf **, struct mbuf **,			     caddr_t *);
void nfs_timer(void *);
int nfs_sigintr(struct nfsmount *, struct nfsreq *, struct proc *);
int nfs_sndlock(int *, struct nfsreq *);
void nfs_sndunlock(int *);
int nfs_rcvlock(struct nfsreq *);
void nfs_rcvunlock(int *);
void nfs_realign(struct mbuf *, int);
int nfs_getreq(struct nfsrv_descript *, struct nfsd *, int);
int nfs_msg(struct proc *, char *, char *);
void nfsrv_rcv(struct socket *, caddr_t, int);
int nfsrv_getstream(struct nfssvc_sock *, int);
int nfsrv_dorec(struct nfssvc_sock *, struct nfsd *,
		     struct nfsrv_descript **);
void nfsrv_wakenfsd(struct nfssvc_sock *);
d228 5
a232 5
void nfsrv_initcache(void );
int nfsrv_getcache(struct nfsrv_descript *, struct nfssvc_sock *,
			struct mbuf **);
void nfsrv_updatecache(struct nfsrv_descript *, int, struct mbuf *);
void nfsrv_cleancache(void);
d235 2
a236 2
struct mbuf *nfsm_reqh(struct vnode *, u_long, int, caddr_t *);
struct mbuf *nfsm_rpchead(struct ucred *, int, int, int, int, char *, int,
d238 11
a248 11
			       u_int32_t *);
int nfsm_mbuftouio(struct mbuf **, struct uio *, int, caddr_t *);
int nfsm_uiotombuf(struct uio *, struct mbuf **, int, caddr_t *);
int nfsm_disct(struct mbuf **, caddr_t *, int, int, caddr_t *);
int nfs_adv(struct mbuf **, caddr_t *, int, int);
int nfsm_strtmbuf(struct mbuf **, char **, char *, long);
int nfs_vfs_init(struct vfsconf *);
int nfs_loadattrcache(struct vnode **, struct mbuf **, caddr_t *,
			   struct vattr *);
int nfs_getattrcache(struct vnode *, struct vattr *);
int nfs_namei(struct nameidata *, fhandle_t *, int, struct nfssvc_sock *,
d250 15
a264 15
		   struct proc *, int);
void nfsm_adj(struct mbuf *, int, int);
void nfsm_srvwcc(struct nfsrv_descript *, int, struct vattr *, int,
		      struct vattr *, struct mbuf **, char **);
void nfsm_srvpostopattr(struct nfsrv_descript *, int, struct vattr *,
			     struct mbuf **, char **);
void nfsm_srvfattr(struct nfsrv_descript *, struct vattr *,
			struct nfs_fattr *);
int nfsrv_fhtovp(fhandle_t *, int, struct vnode **, struct ucred *,
		      struct nfssvc_sock *, struct mbuf *, int *, int);
int netaddr_match(int, union nethostaddr *, struct mbuf *);
void nfs_clearcommit(struct mount *);
int nfsrv_errmap(struct nfsrv_descript *, int);
void nfsrvw_sort(gid_t *, int);
void nfsrv_setcred(struct ucred *, struct ucred *);
d267 15
a281 15
int sys_nfssvc(struct proc *, void *, register_t *);
int nfssvc_addsock(struct file *, struct mbuf *);
int nfssvc_nfsd(struct nfsd_srvargs *, caddr_t, struct proc *);
void nfsrv_zapsock(struct nfssvc_sock *);
void nfsrv_slpderef(struct nfssvc_sock *);
void nfsrv_init(int);
int nfssvc_iod(struct proc *);
void start_nfsio(void *);
void nfs_getset_niothreads(int);
int nfs_getauth(struct nfsmount *, struct nfsreq *, struct ucred *,
		     char **, int *, char *, int *, NFSKERBKEY_T);
int nfs_getnickauth(struct nfsmount *, struct ucred *, char **, int *,
			 char *, int);
int nfs_savenickauth(struct nfsmount *, struct ucred *, int, NFSKERBKEY_T,
			  struct mbuf **, char **, struct mbuf *);
@


1.10.2.6
log
@Sync the SMP branch with 3.3
@
text
@d78 1
d210 2
a211 2
int nfs_rephead(int, struct nfsrv_descript *, struct nfssvc_sock *, int,
		u_quad_t *, struct mbuf **, struct mbuf **, caddr_t *);
d218 1
@


1.9
log
@

Rename vop_revoke, vn_bwrite, vop_noislocked, vop_nolock, vop_nounlock
to be vop_generic_revoke, vop_generic_bwrite, vop_generic_islocked,
vop_generic_lock and vop_generic_unlock.

Create vop_generic_abortop and propogate change to all file systems.

Fix PR/371.

Get rid of locking in NULLFS (should be mostly unnecessary now except for
forced unmounts).
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.8 1998/02/22 01:21:32 niklas Exp $	*/
a300 1
int sys_getfh __P((struct proc *, void *, register_t *));
@


1.8
log
@Changes made for GCC 2.8 -Wall pleasures
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.7 1997/11/06 05:59:04 csapuntz Exp $	*/
a83 1
int nfs_abortop __P((void *));
@


1.7
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.6 1997/10/06 20:20:51 deraadt Exp $	*/
d63 1
@


1.6
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.4 1996/12/14 15:36:51 deraadt Exp $	*/
a82 3
int nfs_lock __P((void *));
int nfs_unlock __P((void *));
int nfs_islocked __P((void *));
d275 1
a275 1
void nfs_vfs_init __P((void));
@


1.5
log
@VFS Lite2 Changes
@
text
@d83 3
d278 1
a278 1
int nfs_vfs_init __P((struct vfsconf *));
@


1.4
log
@better nfsrv_access() control, from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.3 1996/09/21 11:06:20 deraadt Exp $	*/
a82 3
int nfs_lock __P((void *));
int nfs_unlock __P((void *));
int nfs_islocked __P((void *));
d275 1
a275 1
void nfs_vfs_init __P((void));
@


1.3
log
@fix NFSSERVER w/o NFSCLIENT; netbsd pr#1780, cgd@@netbsd (yes, a 10month
old PR and the fix is mostly unchanged).
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_var.h,v 1.1 1996/02/29 09:24:57 niklas Exp $	*/
d230 2
a231 1
int nfsrv_access __P((struct vnode *, int, struct ucred *, int, struct proc *));
@


1.2
log
@From NetBSD: NFSv3 import (tomorrow's Net's kernel)
Open's patches kept in. i'll possibly take a look at Lite2 soon,
is there smth usefull ?..
@
text
@d277 1
@


1.1
log
@From NetBSD: merge with 960217 (still NFSv2)
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: nfs_var.h,v 1.2 1996/02/13 17:06:52 christos Exp $	*/
d33 4
d61 2
a62 2
struct nfsd_cargs;

d66 1
d79 8
a86 2
struct nfsnodehashhead *nfs_hash __P((nfsv2fh_t *));
int nfs_nget __P((struct mount *, nfsv2fh_t *, struct nfsnode **));
d90 10
d102 7
a108 1
int nfs_writerpc __P((struct vnode *, struct uio *, struct ucred *, int));
d110 3
d115 7
d123 1
a123 1
int nfs_readdirlookrpc __P((struct vnode *, struct uio *, struct ucred *));
d126 26
a151 1
int nfs_lookitup __P((struct sillyrename *, nfsv2fh_t *, struct proc *));
d154 9
a162 3
int nqsrv_getlease __P((struct vnode *, u_int *, int, struct nfsd *,
			struct mbuf *, int *, u_quad_t *, struct ucred *));
int lease_check __P((void *));
d164 1
a164 1
void nqsrv_instimeq __P((struct nqlease *, u_long));
d171 4
a174 4
int nqnfsrv_getlease __P((struct nfsd *, struct mbuf *, struct mbuf *, caddr_t,
			  struct ucred *, struct mbuf *, struct mbuf **));
int nqnfsrv_vacated __P((struct nfsd *, struct mbuf *, struct mbuf *, caddr_t,
			 struct ucred *, struct mbuf *, struct mbuf **));
d178 1
a178 8
		 	caddr_t));
int nqnfs_clientd __P((struct nfsmount *, struct ucred *, struct nfsd_cargs *,
	               int, caddr_t, struct proc *));
void nqnfs_clientlease __P((struct nfsmount *, struct nfsnode *, int, int ,
			    time_t, u_quad_t));
void lease_updatetime __P((int));
void nqsrv_locklease __P((struct nqlease *));
void nqsrv_unlocklease __P((struct nqlease *));
d181 49
a229 39
int nqnfsrv_access __P((struct nfsd *, struct mbuf *, struct mbuf *, caddr_t,
			struct ucred *, struct mbuf *, struct mbuf **));
int nfsrv_getattr __P((struct nfsd *, struct mbuf *, struct mbuf *, caddr_t,
		       struct ucred *, struct mbuf *, struct mbuf **));
int nfsrv_setattr __P((struct nfsd *, struct mbuf *, struct mbuf *, caddr_t,
		       struct ucred *, struct mbuf *, struct mbuf **));
int nfsrv_lookup __P((struct nfsd *, struct mbuf *, struct mbuf *, caddr_t,
		      struct ucred *, struct mbuf *, struct mbuf **));
int nfsrv_readlink __P((struct nfsd *, struct mbuf *, struct mbuf *, caddr_t,
			struct ucred *, struct mbuf *, struct mbuf **));
int nfsrv_read __P((struct nfsd *, struct mbuf *, struct mbuf *, caddr_t,
		    struct ucred *, struct mbuf *, struct mbuf **));
int nfsrv_write __P((struct nfsd *, struct mbuf *, struct mbuf *, caddr_t,
		     struct ucred *, struct mbuf *, struct mbuf **));
int nfsrv_create __P((struct nfsd *, struct mbuf *, struct mbuf *, caddr_t,
		      struct ucred *, struct mbuf *, struct mbuf **));
int nfsrv_remove __P((struct nfsd *, struct mbuf *, struct mbuf *, caddr_t,
		      struct ucred *, struct mbuf *, struct mbuf **));
int nfsrv_rename __P((struct nfsd *, struct mbuf *, struct mbuf *, caddr_t,
		      struct ucred *, struct mbuf *, struct mbuf **));
int nfsrv_link __P((struct nfsd *, struct mbuf *, struct mbuf *, caddr_t,
		    struct ucred *, struct mbuf *, struct mbuf **));
int nfsrv_symlink __P((struct nfsd *, struct mbuf *, struct mbuf *, caddr_t,
		       struct ucred *, struct mbuf *, struct mbuf **));
int nfsrv_mkdir __P((struct nfsd *, struct mbuf *, struct mbuf *, caddr_t,
		     struct ucred *, struct mbuf *, struct mbuf **));
int nfsrv_rmdir __P((struct nfsd *, struct mbuf *, struct mbuf *, caddr_t,
		     struct ucred *, struct mbuf *, struct mbuf **));
int nfsrv_readdir __P((struct nfsd *, struct mbuf *, struct mbuf *, caddr_t,
		       struct ucred *, struct mbuf *, struct mbuf **));
int nqnfsrv_readdirlook __P((struct nfsd *, struct mbuf *, struct mbuf *,
			     caddr_t, struct ucred *, struct mbuf *,
			     struct mbuf **));
int nfsrv_statfs __P((struct nfsd *, struct mbuf *, struct mbuf *, caddr_t,
		      struct ucred *, struct mbuf *, struct mbuf **));
int nfsrv_null __P((struct nfsd *, struct mbuf *, struct mbuf *, caddr_t,
		    struct ucred *, struct mbuf *, struct mbuf **));
int nfsrv_noop __P((struct nfsd *, struct mbuf *, struct mbuf *, caddr_t,
		    struct ucred *, struct mbuf *, struct mbuf **));
d243 2
a244 2
int nfs_rephead __P((int, struct nfsd *, int, int, u_quad_t *, struct mbuf **,
		     struct mbuf **, caddr_t *));
d252 2
a253 2
int nfs_getreq __P((struct nfsd *, int));
void nfs_msg __P((struct proc *, char *, char *));
d256 2
a257 1
int nfsrv_dorec __P((struct nfssvc_sock *, struct nfsd *));
d261 4
a264 3
void nfsrv_initcache __P((void));
int nfsrv_getcache __P((struct mbuf *, struct nfsd *, struct mbuf **));
void nfsrv_updatecache __P((struct mbuf *, struct nfsd *, int, struct mbuf *));
d269 2
a270 2
struct mbuf *nfsm_rpchead __P((struct ucred *, int, int, int, int, char *,
			       struct mbuf *, int, struct mbuf **,
d277 1
d282 2
a283 1
		   struct mbuf *, struct mbuf **, caddr_t *, struct proc *));
d285 6
d292 1
a292 1
		      struct nfssvc_sock *, struct mbuf *, int *));
d294 6
d302 2
d311 5
a315 2
		     int *, char **, int *));

@
