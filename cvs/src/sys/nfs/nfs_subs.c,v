head	1.135;
access;
symbols
	OPENBSD_6_2_BASE:1.135
	OPENBSD_6_1:1.134.0.4
	OPENBSD_6_1_BASE:1.134
	OPENBSD_6_0:1.131.0.2
	OPENBSD_6_0_BASE:1.131
	OPENBSD_5_9:1.129.0.2
	OPENBSD_5_9_BASE:1.129
	OPENBSD_5_8:1.128.0.4
	OPENBSD_5_8_BASE:1.128
	OPENBSD_5_7:1.125.0.2
	OPENBSD_5_7_BASE:1.125
	OPENBSD_5_6:1.116.0.4
	OPENBSD_5_6_BASE:1.116
	OPENBSD_5_5:1.115.0.4
	OPENBSD_5_5_BASE:1.115
	OPENBSD_5_4:1.113.0.10
	OPENBSD_5_4_BASE:1.113
	OPENBSD_5_3:1.113.0.8
	OPENBSD_5_3_BASE:1.113
	OPENBSD_5_2:1.113.0.6
	OPENBSD_5_2_BASE:1.113
	OPENBSD_5_1_BASE:1.113
	OPENBSD_5_1:1.113.0.4
	OPENBSD_5_0:1.113.0.2
	OPENBSD_5_0_BASE:1.113
	OPENBSD_4_9:1.112.0.2
	OPENBSD_4_9_BASE:1.112
	OPENBSD_4_8:1.108.0.2
	OPENBSD_4_8_BASE:1.108
	OPENBSD_4_7:1.107.0.2
	OPENBSD_4_7_BASE:1.107
	OPENBSD_4_6:1.96.0.4
	OPENBSD_4_6_BASE:1.96
	OPENBSD_4_5:1.92.0.2
	OPENBSD_4_5_BASE:1.92
	OPENBSD_4_4:1.84.0.2
	OPENBSD_4_4_BASE:1.84
	OPENBSD_4_3:1.69.0.2
	OPENBSD_4_3_BASE:1.69
	OPENBSD_4_2:1.61.0.2
	OPENBSD_4_2_BASE:1.61
	OPENBSD_4_1:1.59.0.2
	OPENBSD_4_1_BASE:1.59
	OPENBSD_4_0:1.57.0.2
	OPENBSD_4_0_BASE:1.57
	OPENBSD_3_9:1.55.0.2
	OPENBSD_3_9_BASE:1.55
	OPENBSD_3_8:1.54.0.2
	OPENBSD_3_8_BASE:1.54
	OPENBSD_3_7:1.52.0.2
	OPENBSD_3_7_BASE:1.52
	OPENBSD_3_6:1.50.0.2
	OPENBSD_3_6_BASE:1.50
	SMP_SYNC_A:1.44
	SMP_SYNC_B:1.44
	OPENBSD_3_5:1.43.0.4
	OPENBSD_3_5_BASE:1.43
	OPENBSD_3_4:1.43.0.2
	OPENBSD_3_4_BASE:1.43
	UBC_SYNC_A:1.42
	OPENBSD_3_3:1.42.0.6
	OPENBSD_3_3_BASE:1.42
	OPENBSD_3_2:1.42.0.4
	OPENBSD_3_2_BASE:1.42
	OPENBSD_3_1:1.42.0.2
	OPENBSD_3_1_BASE:1.42
	UBC_SYNC_B:1.42
	UBC:1.37.0.2
	UBC_BASE:1.37
	OPENBSD_3_0:1.34.0.2
	OPENBSD_3_0_BASE:1.34
	OPENBSD_2_9_BASE:1.29
	OPENBSD_2_9:1.29.0.4
	OPENBSD_2_8:1.29.0.2
	OPENBSD_2_8_BASE:1.29
	OPENBSD_2_7:1.28.0.4
	OPENBSD_2_7_BASE:1.28
	SMP:1.28.0.2
	SMP_BASE:1.28
	kame_19991208:1.27
	OPENBSD_2_6:1.27.0.2
	OPENBSD_2_6_BASE:1.27
	OPENBSD_2_5:1.26.0.2
	OPENBSD_2_5_BASE:1.26
	OPENBSD_2_4:1.23.0.2
	OPENBSD_2_4_BASE:1.23
	OPENBSD_2_3:1.22.0.2
	OPENBSD_2_3_BASE:1.22
	OPENBSD_2_2:1.21.0.2
	OPENBSD_2_2_BASE:1.21
	OPENBSD_2_1:1.19.0.2
	OPENBSD_2_1_BASE:1.19
	OPENBSD_2_0:1.12.0.2
	OPENBSD_2_0_BASE:1.12
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.135
date	2017.08.29.02.51.27;	author deraadt;	state Exp;
branches;
next	1.134;
commitid	rqeb3Cn0JHXrssFn;

1.134
date	2017.02.22.11.42.46;	author mpi;	state Exp;
branches;
next	1.133;
commitid	QPdM5oUknMlUIDue;

1.133
date	2016.09.15.02.00.18;	author dlg;	state Exp;
branches;
next	1.132;
commitid	RlO92XR575sygHqm;

1.132
date	2016.08.30.07.12.49;	author dlg;	state Exp;
branches;
next	1.131;
commitid	Azi9BJ1uL9Pnlws6;

1.131
date	2016.04.29.14.40.36;	author beck;	state Exp;
branches;
next	1.130;
commitid	p3EbVWCYrcYkiFMB;

1.130
date	2016.03.19.12.04.16;	author natano;	state Exp;
branches;
next	1.129;
commitid	gAjwyca5TfuoJAhn;

1.129
date	2016.02.13.15.45.05;	author stefan;	state Exp;
branches;
next	1.128;
commitid	TfAXGeazXTFF4kij;

1.128
date	2015.06.16.11.09.40;	author mpi;	state Exp;
branches;
next	1.127;
commitid	h7z8lokZ0dFyuWpg;

1.127
date	2015.04.17.04.43.21;	author guenther;	state Exp;
branches;
next	1.126;
commitid	zOwbm07fp3gPB2qr;

1.126
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.125;
commitid	p4LJxGKbi0BU2cG6;

1.125
date	2015.02.10.21.56.10;	author miod;	state Exp;
branches;
next	1.124;
commitid	C5iGb36LQxjM60Q3;

1.124
date	2015.01.17.17.49.27;	author deraadt;	state Exp;
branches;
next	1.123;
commitid	buV4jzMNnBVDajYs;

1.123
date	2014.12.29.05.29.28;	author miod;	state Exp;
branches;
next	1.122;
commitid	UbmX4MifiudCV4qQ;

1.122
date	2014.12.23.01.55.03;	author tedu;	state Exp;
branches;
next	1.121;
commitid	ywJDLQPvFwXxtHEL;

1.121
date	2014.12.18.21.00.12;	author tedu;	state Exp;
branches;
next	1.120;
commitid	3dwOU7vSbxwa0t7t;

1.120
date	2014.12.18.20.59.21;	author tedu;	state Exp;
branches;
next	1.119;
commitid	A8MlA6JGDExx7uTs;

1.119
date	2014.11.18.02.37.31;	author tedu;	state Exp;
branches;
next	1.118;
commitid	Z1vcFtHO8wRH0yRt;

1.118
date	2014.11.14.23.01.44;	author tedu;	state Exp;
branches;
next	1.117;
commitid	IWzLFxf7O2DJPe2b;

1.117
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.116;
commitid	uzzBR7hz9ncd4O6G;

1.116
date	2014.07.08.17.19.26;	author deraadt;	state Exp;
branches;
next	1.115;
commitid	EF98ch02VpFassUi;

1.115
date	2013.11.27.16.02.54;	author jsing;	state Exp;
branches;
next	1.114;

1.114
date	2013.08.13.05.52.25;	author guenther;	state Exp;
branches;
next	1.113;

1.113
date	2011.07.04.21.00.10;	author deraadt;	state Exp;
branches;
next	1.112;

1.112
date	2010.12.21.20.14.43;	author thib;	state Exp;
branches;
next	1.111;

1.111
date	2010.09.10.16.34.09;	author thib;	state Exp;
branches;
next	1.110;

1.110
date	2010.09.09.10.37.04;	author thib;	state Exp;
branches;
next	1.109;

1.109
date	2010.09.06.23.44.10;	author thib;	state Exp;
branches;
next	1.108;

1.108
date	2010.05.19.08.31.23;	author thib;	state Exp;
branches;
next	1.107;

1.107
date	2009.10.19.22.24.18;	author jsg;	state Exp;
branches;
next	1.106;

1.106
date	2009.09.02.18.20.54;	author thib;	state Exp;
branches;
next	1.105;

1.105
date	2009.08.25.13.41.29;	author thib;	state Exp;
branches;
next	1.104;

1.104
date	2009.08.20.15.04.24;	author thib;	state Exp;
branches;
next	1.103;

1.103
date	2009.08.13.15.18.16;	author blambert;	state Exp;
branches;
next	1.102;

1.102
date	2009.08.13.15.03.19;	author blambert;	state Exp;
branches;
next	1.101;

1.101
date	2009.08.10.10.59.12;	author thib;	state Exp;
branches;
next	1.100;

1.100
date	2009.08.10.09.38.44;	author thib;	state Exp;
branches;
next	1.99;

1.99
date	2009.08.04.17.12.39;	author thib;	state Exp;
branches;
next	1.98;

1.98
date	2009.07.20.16.49.40;	author thib;	state Exp;
branches;
next	1.97;

1.97
date	2009.07.09.22.29.56;	author thib;	state Exp;
branches;
next	1.96;

1.96
date	2009.05.30.17.20.29;	author thib;	state Exp;
branches;
next	1.95;

1.95
date	2009.05.22.00.19.25;	author thib;	state Exp;
branches;
next	1.94;

1.94
date	2009.04.13.17.51.57;	author blambert;	state Exp;
branches;
next	1.93;

1.93
date	2009.03.30.19.58.50;	author blambert;	state Exp;
branches;
next	1.92;

1.92
date	2009.01.24.23.30.42;	author thib;	state Exp;
branches;
next	1.91;

1.91
date	2009.01.20.18.03.33;	author blambert;	state Exp;
branches;
next	1.90;

1.90
date	2009.01.13.19.44.20;	author grange;	state Exp;
branches;
next	1.89;

1.89
date	2008.12.24.02.48.36;	author thib;	state Exp;
branches;
next	1.88;

1.88
date	2008.12.24.02.43.52;	author thib;	state Exp;
branches;
next	1.87;

1.87
date	2008.11.24.20.14.52;	author thib;	state Exp;
branches;
next	1.86;

1.86
date	2008.08.25.09.26.17;	author pedro;	state Exp;
branches;
next	1.85;

1.85
date	2008.08.08.20.44.38;	author blambert;	state Exp;
branches;
next	1.84;

1.84
date	2008.06.15.04.03.40;	author thib;	state Exp;
branches;
next	1.83;

1.83
date	2008.06.14.00.26.13;	author thib;	state Exp;
branches;
next	1.82;

1.82
date	2008.06.13.22.11.32;	author blambert;	state Exp;
branches;
next	1.81;

1.81
date	2008.06.13.17.24.13;	author thib;	state Exp;
branches;
next	1.80;

1.80
date	2008.06.13.03.49.26;	author blambert;	state Exp;
branches;
next	1.79;

1.79
date	2008.06.12.20.24.06;	author blambert;	state Exp;
branches;
next	1.78;

1.78
date	2008.06.11.08.11.33;	author thib;	state Exp;
branches;
next	1.77;

1.77
date	2008.06.10.22.59.09;	author thib;	state Exp;
branches;
next	1.76;

1.76
date	2008.06.09.22.49.15;	author djm;	state Exp;
branches;
next	1.75;

1.75
date	2008.06.09.22.47.42;	author djm;	state Exp;
branches;
next	1.74;

1.74
date	2008.04.22.18.53.34;	author thib;	state Exp;
branches;
next	1.73;

1.73
date	2008.04.19.19.38.00;	author thib;	state Exp;
branches;
next	1.72;

1.72
date	2008.04.18.06.42.20;	author djm;	state Exp;
branches;
next	1.71;

1.71
date	2008.04.16.20.02.46;	author damien;	state Exp;
branches;
next	1.70;

1.70
date	2008.04.14.13.46.13;	author blambert;	state Exp;
branches;
next	1.69;

1.69
date	2008.01.06.17.38.23;	author blambert;	state Exp;
branches;
next	1.68;

1.68
date	2007.12.13.18.32.55;	author blambert;	state Exp;
branches;
next	1.67;

1.67
date	2007.11.28.19.27.43;	author thib;	state Exp;
branches;
next	1.66;

1.66
date	2007.11.05.21.18.56;	author thib;	state Exp;
branches;
next	1.65;

1.65
date	2007.10.13.17.38.43;	author thib;	state Exp;
branches;
next	1.64;

1.64
date	2007.10.08.17.39.52;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2007.10.07.16.30.26;	author miod;	state Exp;
branches;
next	1.62;

1.62
date	2007.09.20.12.54.31;	author thib;	state Exp;
branches;
next	1.61;

1.61
date	2007.04.19.14.46.44;	author thib;	state Exp;
branches;
next	1.60;

1.60
date	2007.04.13.10.01.35;	author thib;	state Exp;
branches;
next	1.59;

1.59
date	2006.12.29.13.04.37;	author pedro;	state Exp;
branches;
next	1.58;

1.58
date	2006.11.01.00.12.35;	author thib;	state Exp;
branches;
next	1.57;

1.57
date	2006.05.29.16.49.42;	author avsm;	state Exp;
branches;
next	1.56;

1.56
date	2006.05.28.23.29.32;	author avsm;	state Exp;
branches;
next	1.55;

1.55
date	2005.10.19.16.50.46;	author pedro;	state Exp;
branches;
next	1.54;

1.54
date	2005.04.02.01.00.38;	author mickey;	state Exp;
branches;
next	1.53;

1.53
date	2005.03.31.21.47.49;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2005.02.01.15.00.04;	author pvalchev;	state Exp;
branches;
next	1.51;

1.51
date	2005.01.24.00.14.40;	author marius;	state Exp;
branches;
next	1.50;

1.50
date	2004.08.03.17.11.48;	author marius;	state Exp;
branches;
next	1.49;

1.49
date	2004.08.03.06.58.40;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2004.07.21.17.30.55;	author marius;	state Exp;
branches;
next	1.47;

1.47
date	2004.07.16.15.01.51;	author henning;	state Exp;
branches;
next	1.46;

1.46
date	2004.07.13.21.04.29;	author millert;	state Exp;
branches;
next	1.45;

1.45
date	2004.06.21.23.50.38;	author tholo;	state Exp;
branches;
next	1.44;

1.44
date	2004.05.14.04.00.34;	author tedu;	state Exp;
branches;
next	1.43;

1.43
date	2003.06.02.23.28.19;	author millert;	state Exp;
branches;
next	1.42;

1.42
date	2002.03.14.01.27.13;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	2002.02.10.22.02.05;	author nate;	state Exp;
branches;
next	1.40;

1.40
date	2002.01.16.21.51.16;	author ericj;	state Exp;
branches;
next	1.39;

1.39
date	2002.01.11.01.20.56;	author nate;	state Exp;
branches;
next	1.38;

1.38
date	2001.12.19.08.58.06;	author art;	state Exp;
branches;
next	1.37;

1.37
date	2001.12.10.02.19.34;	author art;	state Exp;
branches
	1.37.2.1;
next	1.36;

1.36
date	2001.11.27.05.27.12;	author art;	state Exp;
branches;
next	1.35;

1.35
date	2001.11.06.19.53.21;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2001.08.19.18.14.54;	author art;	state Exp;
branches;
next	1.33;

1.33
date	2001.08.19.17.45.07;	author jason;	state Exp;
branches;
next	1.32;

1.32
date	2001.06.27.04.58.46;	author art;	state Exp;
branches;
next	1.31;

1.31
date	2001.06.25.03.28.10;	author csapuntz;	state Exp;
branches;
next	1.30;

1.30
date	2001.06.25.02.15.47;	author csapuntz;	state Exp;
branches;
next	1.29;

1.29
date	2000.06.26.22.48.15;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2000.02.07.04.57.17;	author assar;	state Exp;
branches
	1.28.2.1;
next	1.27;

1.27
date	99.04.28.09.28.17;	author art;	state Exp;
branches;
next	1.26;

1.26
date	99.02.26.03.16.25;	author art;	state Exp;
branches;
next	1.25;

1.25
date	99.02.06.23.07.45;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	99.01.16.13.28.25;	author niklas;	state Exp;
branches;
next	1.23;

1.23
date	98.08.19.22.26.55;	author csapuntz;	state Exp;
branches;
next	1.22;

1.22
date	97.11.06.05.59.03;	author csapuntz;	state Exp;
branches;
next	1.21;

1.21
date	97.10.06.20.20.49;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	97.10.06.15.23.43;	author csapuntz;	state Exp;
branches;
next	1.19;

1.19
date	97.04.28.00.40.14;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	97.04.28.00.37.06;	author angelos;	state Exp;
branches;
next	1.17;

1.17
date	97.04.27.23.55.49;	author angelos;	state Exp;
branches;
next	1.16;

1.16
date	97.04.25.09.30.14;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	96.12.18.18.30.58;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	96.12.17.03.46.38;	author dm;	state Exp;
branches;
next	1.13;

1.13
date	96.10.15.11.34.15;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	96.09.25.11.57.25;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	96.09.21.11.06.19;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.07.27.11.09.39;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.07.23.21.32.31;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.05.28.13.44.08;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.04.21.22.30.30;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.04.17.04.50.31;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.03.31.13.15.53;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.02.29.09.24.56;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.01.08.07.36.26;	author dm;	state Exp;
branches;
next	1.2;

1.2
date	95.12.21.14.42.24;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.22;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.22;	author deraadt;	state Exp;
branches;
next	;

1.28.2.1
date	2001.05.14.22.44.57;	author niklas;	state Exp;
branches;
next	1.28.2.2;

1.28.2.2
date	2001.07.04.10.55.50;	author niklas;	state Exp;
branches;
next	1.28.2.3;

1.28.2.3
date	2001.10.31.03.30.30;	author nate;	state Exp;
branches;
next	1.28.2.4;

1.28.2.4
date	2001.11.13.22.59.59;	author niklas;	state Exp;
branches;
next	1.28.2.5;

1.28.2.5
date	2001.12.05.01.02.40;	author niklas;	state Exp;
branches;
next	1.28.2.6;

1.28.2.6
date	2002.03.06.02.17.12;	author niklas;	state Exp;
branches;
next	1.28.2.7;

1.28.2.7
date	2002.03.28.15.02.48;	author niklas;	state Exp;
branches;
next	1.28.2.8;

1.28.2.8
date	2003.06.07.11.07.44;	author ho;	state Exp;
branches;
next	1.28.2.9;

1.28.2.9
date	2004.06.05.23.13.07;	author niklas;	state Exp;
branches;
next	;

1.37.2.1
date	2002.01.31.22.55.47;	author niklas;	state Exp;
branches;
next	1.37.2.2;

1.37.2.2
date	2002.06.11.03.32.04;	author art;	state Exp;
branches;
next	1.37.2.3;

1.37.2.3
date	2002.11.04.18.02.32;	author art;	state Exp;
branches;
next	;


desc
@@


1.135
log
@Remove old deactivated pledge path code.  A replacement mechanism is
being brewed.
ok beck
@
text
@/*	$OpenBSD: nfs_subs.c,v 1.134 2017/02/22 11:42:46 mpi Exp $	*/
/*	$NetBSD: nfs_subs.c,v 1.27.4.3 1996/07/08 20:34:24 jtc Exp $	*/

/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Rick Macklem at The University of Guelph.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)nfs_subs.c	8.8 (Berkeley) 5/22/95
 */


/*
 * These functions support the macros and help fiddle mbuf chains for
 * the nfs op functions. They do things like create the rpc header and
 * copy data between mbuf chains and uio lists.
 */
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/mount.h>
#include <sys/vnode.h>
#include <sys/namei.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/stat.h>
#include <sys/pool.h>
#include <sys/time.h>

#include <nfs/rpcv2.h>
#include <nfs/nfsproto.h>
#include <nfs/nfsnode.h>
#include <nfs/nfs.h>
#include <nfs/xdr_subs.h>
#include <nfs/nfsm_subs.h>
#include <nfs/nfsmount.h>
#include <nfs/nfs_var.h>

#include <uvm/uvm_extern.h>

#include <netinet/in.h>

#include <crypto/idgen.h>

int	nfs_attrtimeo(struct nfsnode *np);
u_int32_t nfs_get_xid(void);

/*
 * Data items converted to xdr at startup, since they are constant
 * This is kinda hokey, but may save a little time doing byte swaps
 */
u_int32_t nfs_xdrneg1;
u_int32_t rpc_call, rpc_vers, rpc_reply, rpc_msgdenied, rpc_autherr,
	rpc_mismatch, rpc_auth_unix, rpc_msgaccepted;
u_int32_t nfs_prog, nfs_true, nfs_false;

/* And other global data */
nfstype nfsv2_type[9] = { NFNON, NFREG, NFDIR, NFBLK, NFCHR, NFLNK, NFNON,
		      NFCHR, NFNON };
nfstype nfsv3_type[9] = { NFNON, NFREG, NFDIR, NFBLK, NFCHR, NFLNK, NFSOCK,
		      NFFIFO, NFNON };
enum vtype nv2tov_type[8] = { VNON, VREG, VDIR, VBLK, VCHR, VLNK, VNON, VNON };
enum vtype nv3tov_type[8]={ VNON, VREG, VDIR, VBLK, VCHR, VLNK, VSOCK, VFIFO };
int nfs_ticks;
struct nfsstats nfsstats;

/*
 * Mapping of old NFS Version 2 RPC numbers to generic numbers.
 */
int nfsv3_procid[NFS_NPROCS] = {
	NFSPROC_NULL,
	NFSPROC_GETATTR,
	NFSPROC_SETATTR,
	NFSPROC_NOOP,
	NFSPROC_LOOKUP,
	NFSPROC_READLINK,
	NFSPROC_READ,
	NFSPROC_NOOP,
	NFSPROC_WRITE,
	NFSPROC_CREATE,
	NFSPROC_REMOVE,
	NFSPROC_RENAME,
	NFSPROC_LINK,
	NFSPROC_SYMLINK,
	NFSPROC_MKDIR,
	NFSPROC_RMDIR,
	NFSPROC_READDIR,
	NFSPROC_FSSTAT,
	NFSPROC_NOOP,
	NFSPROC_NOOP,
	NFSPROC_NOOP,
	NFSPROC_NOOP,
	NFSPROC_NOOP
};

/*
 * and the reverse mapping from generic to Version 2 procedure numbers
 */
int nfsv2_procid[NFS_NPROCS] = {
	NFSV2PROC_NULL,
	NFSV2PROC_GETATTR,
	NFSV2PROC_SETATTR,
	NFSV2PROC_LOOKUP,
	NFSV2PROC_NOOP,
	NFSV2PROC_READLINK,
	NFSV2PROC_READ,
	NFSV2PROC_WRITE,
	NFSV2PROC_CREATE,
	NFSV2PROC_MKDIR,
	NFSV2PROC_SYMLINK,
	NFSV2PROC_CREATE,
	NFSV2PROC_REMOVE,
	NFSV2PROC_RMDIR,
	NFSV2PROC_RENAME,
	NFSV2PROC_LINK,
	NFSV2PROC_READDIR,
	NFSV2PROC_NOOP,
	NFSV2PROC_STATFS,
	NFSV2PROC_NOOP,
	NFSV2PROC_NOOP,
	NFSV2PROC_NOOP,
	NFSV2PROC_NOOP
};

/*
 * Maps errno values to nfs error numbers.
 * Use NFSERR_IO as the catch all for ones not specifically defined in
 * RFC 1094.
 */
static u_char nfsrv_v2errmap[] = {
  NFSERR_PERM,	NFSERR_NOENT,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,
  NFSERR_NXIO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,
  NFSERR_IO,	NFSERR_IO,	NFSERR_ACCES,	NFSERR_IO,	NFSERR_IO,
  NFSERR_IO,	NFSERR_EXIST,	NFSERR_IO,	NFSERR_NODEV,	NFSERR_NOTDIR,
  NFSERR_ISDIR,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,
  NFSERR_IO,	NFSERR_FBIG,	NFSERR_NOSPC,	NFSERR_IO,	NFSERR_ROFS,
  NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,
  NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,
  NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,
  NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,
  NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,
  NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,
  NFSERR_IO,	NFSERR_IO,	NFSERR_NAMETOL,	NFSERR_IO,	NFSERR_IO,
  NFSERR_NOTEMPTY, NFSERR_IO,	NFSERR_IO,	NFSERR_DQUOT,	NFSERR_STALE
  /* Everything after this maps to NFSERR_IO, so far */
};

/*
 * Maps errno values to nfs error numbers.
 * Although it is not obvious whether or not NFS clients really care if
 * a returned error value is in the specified list for the procedure, the
 * safest thing to do is filter them appropriately. For Version 2, the
 * X/Open XNFS document is the only specification that defines error values
 * for each RPC (The RFC simply lists all possible error values for all RPCs),
 * so I have decided to not do this for Version 2.
 * The first entry is the default error return and the rest are the valid
 * errors for that RPC in increasing numeric order.
 */
static short nfsv3err_null[] = {
	0,
	0,
};

static short nfsv3err_getattr[] = {
	NFSERR_IO,
	NFSERR_IO,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_SERVERFAULT,
	0,
};

static short nfsv3err_setattr[] = {
	NFSERR_IO,
	NFSERR_PERM,
	NFSERR_IO,
	NFSERR_ACCES,
	NFSERR_INVAL,
	NFSERR_NOSPC,
	NFSERR_ROFS,
	NFSERR_DQUOT,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_NOT_SYNC,
	NFSERR_SERVERFAULT,
	0,
};

static short nfsv3err_lookup[] = {
	NFSERR_IO,
	NFSERR_NOENT,
	NFSERR_IO,
	NFSERR_ACCES,
	NFSERR_NOTDIR,
	NFSERR_NAMETOL,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_SERVERFAULT,
	0,
};

static short nfsv3err_access[] = {
	NFSERR_IO,
	NFSERR_IO,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_SERVERFAULT,
	0,
};

static short nfsv3err_readlink[] = {
	NFSERR_IO,
	NFSERR_IO,
	NFSERR_ACCES,
	NFSERR_INVAL,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_NOTSUPP,
	NFSERR_SERVERFAULT,
	0,
};

static short nfsv3err_read[] = {
	NFSERR_IO,
	NFSERR_IO,
	NFSERR_NXIO,
	NFSERR_ACCES,
	NFSERR_INVAL,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_SERVERFAULT,
	0,
};

static short nfsv3err_write[] = {
	NFSERR_IO,
	NFSERR_IO,
	NFSERR_ACCES,
	NFSERR_INVAL,
	NFSERR_FBIG,
	NFSERR_NOSPC,
	NFSERR_ROFS,
	NFSERR_DQUOT,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_SERVERFAULT,
	0,
};

static short nfsv3err_create[] = {
	NFSERR_IO,
	NFSERR_IO,
	NFSERR_ACCES,
	NFSERR_EXIST,
	NFSERR_NOTDIR,
	NFSERR_NOSPC,
	NFSERR_ROFS,
	NFSERR_NAMETOL,
	NFSERR_DQUOT,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_NOTSUPP,
	NFSERR_SERVERFAULT,
	0,
};

static short nfsv3err_mkdir[] = {
	NFSERR_IO,
	NFSERR_IO,
	NFSERR_ACCES,
	NFSERR_EXIST,
	NFSERR_NOTDIR,
	NFSERR_NOSPC,
	NFSERR_ROFS,
	NFSERR_NAMETOL,
	NFSERR_DQUOT,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_NOTSUPP,
	NFSERR_SERVERFAULT,
	0,
};

static short nfsv3err_symlink[] = {
	NFSERR_IO,
	NFSERR_IO,
	NFSERR_ACCES,
	NFSERR_EXIST,
	NFSERR_NOTDIR,
	NFSERR_NOSPC,
	NFSERR_ROFS,
	NFSERR_NAMETOL,
	NFSERR_DQUOT,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_NOTSUPP,
	NFSERR_SERVERFAULT,
	0,
};

static short nfsv3err_mknod[] = {
	NFSERR_IO,
	NFSERR_IO,
	NFSERR_ACCES,
	NFSERR_EXIST,
	NFSERR_NOTDIR,
	NFSERR_NOSPC,
	NFSERR_ROFS,
	NFSERR_NAMETOL,
	NFSERR_DQUOT,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_NOTSUPP,
	NFSERR_SERVERFAULT,
	NFSERR_BADTYPE,
	0,
};

static short nfsv3err_remove[] = {
	NFSERR_IO,
	NFSERR_NOENT,
	NFSERR_IO,
	NFSERR_ACCES,
	NFSERR_NOTDIR,
	NFSERR_ROFS,
	NFSERR_NAMETOL,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_SERVERFAULT,
	0,
};

static short nfsv3err_rmdir[] = {
	NFSERR_IO,
	NFSERR_NOENT,
	NFSERR_IO,
	NFSERR_ACCES,
	NFSERR_EXIST,
	NFSERR_NOTDIR,
	NFSERR_INVAL,
	NFSERR_ROFS,
	NFSERR_NAMETOL,
	NFSERR_NOTEMPTY,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_NOTSUPP,
	NFSERR_SERVERFAULT,
	0,
};

static short nfsv3err_rename[] = {
	NFSERR_IO,
	NFSERR_NOENT,
	NFSERR_IO,
	NFSERR_ACCES,
	NFSERR_EXIST,
	NFSERR_XDEV,
	NFSERR_NOTDIR,
	NFSERR_ISDIR,
	NFSERR_INVAL,
	NFSERR_NOSPC,
	NFSERR_ROFS,
	NFSERR_MLINK,
	NFSERR_NAMETOL,
	NFSERR_NOTEMPTY,
	NFSERR_DQUOT,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_NOTSUPP,
	NFSERR_SERVERFAULT,
	0,
};

static short nfsv3err_link[] = {
	NFSERR_IO,
	NFSERR_IO,
	NFSERR_ACCES,
	NFSERR_EXIST,
	NFSERR_XDEV,
	NFSERR_NOTDIR,
	NFSERR_INVAL,
	NFSERR_NOSPC,
	NFSERR_ROFS,
	NFSERR_MLINK,
	NFSERR_NAMETOL,
	NFSERR_DQUOT,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_NOTSUPP,
	NFSERR_SERVERFAULT,
	0,
};

static short nfsv3err_readdir[] = {
	NFSERR_IO,
	NFSERR_IO,
	NFSERR_ACCES,
	NFSERR_NOTDIR,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_BAD_COOKIE,
	NFSERR_TOOSMALL,
	NFSERR_SERVERFAULT,
	0,
};

static short nfsv3err_readdirplus[] = {
	NFSERR_IO,
	NFSERR_IO,
	NFSERR_ACCES,
	NFSERR_NOTDIR,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_BAD_COOKIE,
	NFSERR_NOTSUPP,
	NFSERR_TOOSMALL,
	NFSERR_SERVERFAULT,
	0,
};

static short nfsv3err_fsstat[] = {
	NFSERR_IO,
	NFSERR_IO,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_SERVERFAULT,
	0,
};

static short nfsv3err_fsinfo[] = {
	NFSERR_STALE,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_SERVERFAULT,
	0,
};

static short nfsv3err_pathconf[] = {
	NFSERR_STALE,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_SERVERFAULT,
	0,
};

static short nfsv3err_commit[] = {
	NFSERR_IO,
	NFSERR_IO,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_SERVERFAULT,
	0,
};

static short *nfsrv_v3errmap[] = {
	nfsv3err_null,
	nfsv3err_getattr,
	nfsv3err_setattr,
	nfsv3err_lookup,
	nfsv3err_access,
	nfsv3err_readlink,
	nfsv3err_read,
	nfsv3err_write,
	nfsv3err_create,
	nfsv3err_mkdir,
	nfsv3err_symlink,
	nfsv3err_mknod,
	nfsv3err_remove,
	nfsv3err_rmdir,
	nfsv3err_rename,
	nfsv3err_link,
	nfsv3err_readdir,
	nfsv3err_readdirplus,
	nfsv3err_fsstat,
	nfsv3err_fsinfo,
	nfsv3err_pathconf,
	nfsv3err_commit,
};

struct pool nfsreqpl;

/*
 * Create the header for an rpc request packet
 * The hsiz is the size of the rest of the nfs request header.
 * (just used to decide if a cluster is a good idea)
 */
struct mbuf *
nfsm_reqhead(int hsiz)
{
	struct mbuf *mb;

	MGET(mb, M_WAIT, MT_DATA);
	if (hsiz > MLEN)
		MCLGET(mb, M_WAIT);
	mb->m_len = 0;
	
	/* Finally, return values */
	return (mb);
}

/*
 * Return an unpredictable XID in XDR form.
 */
u_int32_t
nfs_get_xid(void)
{
	static struct idgen32_ctx nfs_xid_ctx;
	static int called = 0;

	if (!called) {
		called = 1;
		idgen32_init(&nfs_xid_ctx);
	}
	return (txdr_unsigned(idgen32(&nfs_xid_ctx)));
}

/*
 * Build the RPC header and fill in the authorization info.
 * Right now we are pretty centric around RPCAUTH_UNIX, in the
 * future, this function will need some love to be able to handle
 * other authorization methods, such as Kerberos.
 */
void
nfsm_rpchead(struct nfsreq *req, struct ucred *cr, int auth_type)
{
	struct mbuf	*mb;
	u_int32_t	*tl;
	int		i, authsiz, auth_len, ngroups;

	KASSERT(auth_type == RPCAUTH_UNIX);

	/*
	 * RPCAUTH_UNIX fits in an hdr mbuf, in the future other
	 * authorization methods need to figure out their own sizes
	 * and allocate and chain mbuf's accorindgly.
	 */
	mb = req->r_mreq;

	/*
	 * We need to start out by finding how big the authorization cred
	 * and verifer are for the auth_type, to be able to correctly
	 * align the mbuf header/chain.
	 */
	switch (auth_type) {
	case RPCAUTH_UNIX:
		/*
		 * In the RPCAUTH_UNIX case, the size is the static
		 * part as shown in RFC1831 + the number of groups,
		 * RPCAUTH_UNIX has a zero verifer.
		 */
		if (cr->cr_ngroups > req->r_nmp->nm_numgrps)
			ngroups = req->r_nmp->nm_numgrps;
		else
			ngroups = cr->cr_ngroups;

		auth_len = (ngroups << 2) + 5 * NFSX_UNSIGNED;
		authsiz = nfsm_rndup(auth_len);
		/* The authorization size + the size of the static part */
		MH_ALIGN(mb, authsiz + 10 * NFSX_UNSIGNED);
		break;
	}

	mb->m_len = 0;

	/* First the RPC header. */
	tl = nfsm_build(&mb, 6 * NFSX_UNSIGNED);

	/* Get a new (non-zero) xid */
	*tl++ = req->r_xid = nfs_get_xid();
	*tl++ = rpc_call;
	*tl++ = rpc_vers;
	*tl++ = nfs_prog;
	if (ISSET(req->r_nmp->nm_flag, NFSMNT_NFSV3)) {
		*tl++ = txdr_unsigned(NFS_VER3);
		*tl = txdr_unsigned(req->r_procnum);
	} else {
		*tl++ = txdr_unsigned(NFS_VER2);
		*tl = txdr_unsigned(nfsv2_procid[req->r_procnum]);
	}

	/* The Authorization cred and its verifier */
	switch (auth_type) {
	case RPCAUTH_UNIX:
		tl = nfsm_build(&mb, auth_len + 4 * NFSX_UNSIGNED);
		*tl++ = txdr_unsigned(RPCAUTH_UNIX);
		*tl++ = txdr_unsigned(authsiz);

		/* The authorization cred */
		*tl++ = 0;		/* stamp */
		*tl++ = 0;		/* NULL hostname */
		*tl++ = txdr_unsigned(cr->cr_uid);
		*tl++ = txdr_unsigned(cr->cr_gid);
		*tl++ = txdr_unsigned(ngroups);
		for (i = 0; i < ngroups; i++)
			*tl++ = txdr_unsigned(cr->cr_groups[i]);
		/* The authorization verifier */
		*tl++ = txdr_unsigned(RPCAUTH_NULL);
		*tl = 0;
		break;
	}

	mb->m_pkthdr.len += authsiz + 10 * NFSX_UNSIGNED;
	mb->m_pkthdr.ph_ifidx = 0;
}

/*
 * copies mbuf chain to the uio scatter/gather list
 */
int
nfsm_mbuftouio(struct mbuf **mrep, struct uio *uiop, int siz, caddr_t *dpos)
{
	char *mbufcp, *uiocp;
	int xfer, left, len;
	struct mbuf *mp;
	long uiosiz, rem;
	int error = 0;

	mp = *mrep;
	mbufcp = *dpos;
	len = mtod(mp, caddr_t)+mp->m_len-mbufcp;
	rem = nfsm_padlen(siz);
	while (siz > 0) {
		if (uiop->uio_iovcnt <= 0 || uiop->uio_iov == NULL)
			return (EFBIG);
		left = uiop->uio_iov->iov_len;
		uiocp = uiop->uio_iov->iov_base;
		if (left > siz)
			left = siz;
		uiosiz = left;
		while (left > 0) {
			while (len == 0) {
				mp = mp->m_next;
				if (mp == NULL)
					return (EBADRPC);
				mbufcp = mtod(mp, caddr_t);
				len = mp->m_len;
			}
			xfer = (left > len) ? len : left;
			if (uiop->uio_segflg == UIO_SYSSPACE)
				memcpy(uiocp, mbufcp, xfer);
			else
				copyout(mbufcp, uiocp, xfer);
			left -= xfer;
			len -= xfer;
			mbufcp += xfer;
			uiocp += xfer;
			uiop->uio_offset += xfer;
			uiop->uio_resid -= xfer;
		}
		if (uiop->uio_iov->iov_len <= siz) {
			uiop->uio_iovcnt--;
			uiop->uio_iov++;
		} else {
			uiop->uio_iov->iov_base =
			    (char *)uiop->uio_iov->iov_base + uiosiz;
			uiop->uio_iov->iov_len -= uiosiz;
		}
		siz -= uiosiz;
	}
	*dpos = mbufcp;
	*mrep = mp;
	if (rem > 0) {
		if (len < rem)
			error = nfs_adv(mrep, dpos, rem, len);
		else
			*dpos += rem;
	}
	return (error);
}

/*
 * Copy a uio scatter/gather list to an mbuf chain.
 */
void
nfsm_uiotombuf(struct mbuf **mp, struct uio *uiop, size_t len)
{
	struct mbuf *mb, *mb2;
	size_t xfer, pad;

	mb = *mp;

	pad = nfsm_padlen(len);

	/* XXX -- the following should be done by the caller */
	uiop->uio_resid = len;
	uiop->uio_rw = UIO_WRITE;

	while (len) {
		xfer = ulmin(len, M_TRAILINGSPACE(mb));
		uiomove(mb_offset(mb), xfer, uiop);
		mb->m_len += xfer;
		len -= xfer;
		if (len > 0) {
			MGET(mb2, M_WAIT, MT_DATA);
			if (len > MLEN)
				MCLGET(mb2, M_WAIT);
			mb2->m_len = 0;
			mb->m_next = mb2;
			mb = mb2;
		}
	}

	if (pad > 0) {
		if (pad > M_TRAILINGSPACE(mb)) {
			MGET(mb2, M_WAIT, MT_DATA);
			mb2->m_len = 0;
			mb->m_next = mb2;
			mb = mb2;
		}
		memset(mb_offset(mb), 0, pad);
		mb->m_len += pad;
	}

	*mp = mb;
}

/*
 * Copy a buffer to an mbuf chain
 */
void
nfsm_buftombuf(struct mbuf **mp, void *buf, size_t len)
{
	struct iovec iov;
	struct uio io;

	iov.iov_base = buf;
	iov.iov_len = len;

	io.uio_iov = &iov;
	io.uio_iovcnt = 1;
	io.uio_resid = len;
	io.uio_segflg = UIO_SYSSPACE;
	io.uio_rw = UIO_WRITE;

	nfsm_uiotombuf(mp, &io, len);
}

/*
 * Copy a string to an mbuf chain
 */
void
nfsm_strtombuf(struct mbuf **mp, void *str, size_t len)
{
	struct iovec iov[2];
	struct uio io;
	uint32_t strlen;

	strlen = txdr_unsigned(len);

	iov[0].iov_base = &strlen;
	iov[0].iov_len = sizeof(uint32_t);
	iov[1].iov_base = str;
	iov[1].iov_len = len;

	io.uio_iov = iov;
	io.uio_iovcnt = 2;
	io.uio_resid = sizeof(uint32_t) + len;
	io.uio_segflg = UIO_SYSSPACE;
	io.uio_rw = UIO_WRITE;

	nfsm_uiotombuf(mp, &io, io.uio_resid);
}

/*
 * Help break down an mbuf chain by setting the first siz bytes contiguous
 * pointed to by returned val.
 * This is used by the macros nfsm_dissect and nfsm_dissecton for tough
 * cases. (The macros use the vars. dpos and dpos2)
 */
int
nfsm_disct(struct mbuf **mdp, caddr_t *dposp, int siz, int left, caddr_t *cp2)
{
	struct mbuf *mp, *mp2;
	int siz2, xfer;
	caddr_t p;

	mp = *mdp;
	while (left == 0) {
		*mdp = mp = mp->m_next;
		if (mp == NULL)
			return (EBADRPC);
		left = mp->m_len;
		*dposp = mtod(mp, caddr_t);
	}
	if (left >= siz) {
		*cp2 = *dposp;
		*dposp += siz;
	} else if (mp->m_next == NULL) {
		return (EBADRPC);
	} else if (siz > MHLEN) {
		panic("nfs S too big");
	} else {
		MGET(mp2, M_WAIT, MT_DATA);
		mp2->m_next = mp->m_next;
		mp->m_next = mp2;
		mp->m_len -= left;
		mp = mp2;
		*cp2 = p = mtod(mp, caddr_t);
		bcopy(*dposp, p, left);		/* Copy what was left */
		siz2 = siz-left;
		p += left;
		mp2 = mp->m_next;
		/* Loop around copying up the siz2 bytes */
		while (siz2 > 0) {
			if (mp2 == NULL)
				return (EBADRPC);
			xfer = (siz2 > mp2->m_len) ? mp2->m_len : siz2;
			if (xfer > 0) {
				bcopy(mtod(mp2, caddr_t), p, xfer);
				mp2->m_data += xfer;
				mp2->m_len -= xfer;
				p += xfer;
				siz2 -= xfer;
			}
			if (siz2 > 0)
				mp2 = mp2->m_next;
		}
		mp->m_len = siz;
		*mdp = mp2;
		*dposp = mtod(mp2, caddr_t);
	}
	return (0);
}

/*
 * Advance the position in the mbuf chain.
 */
int
nfs_adv(struct mbuf **mdp, caddr_t *dposp, int offs, int left)
{
	struct mbuf *m;
	int s;

	m = *mdp;
	s = left;
	while (s < offs) {
		offs -= s;
		m = m->m_next;
		if (m == NULL)
			return (EBADRPC);
		s = m->m_len;
	}
	*mdp = m;
	*dposp = mtod(m, caddr_t)+offs;
	return (0);
}

/*
 * Called once to initialize data structures...
 */
void
nfs_init(void)
{
	rpc_vers = txdr_unsigned(RPC_VER2);
	rpc_call = txdr_unsigned(RPC_CALL);
	rpc_reply = txdr_unsigned(RPC_REPLY);
	rpc_msgdenied = txdr_unsigned(RPC_MSGDENIED);
	rpc_msgaccepted = txdr_unsigned(RPC_MSGACCEPTED);
	rpc_mismatch = txdr_unsigned(RPC_MISMATCH);
	rpc_autherr = txdr_unsigned(RPC_AUTHERR);
	rpc_auth_unix = txdr_unsigned(RPCAUTH_UNIX);
	nfs_prog = txdr_unsigned(NFS_PROG);
	nfs_true = txdr_unsigned(1);
	nfs_false = txdr_unsigned(0);
	nfs_xdrneg1 = txdr_unsigned(-1);
	nfs_ticks = (hz * NFS_TICKINTVL + 500) / 1000;
	if (nfs_ticks < 1)
		nfs_ticks = 1;
#ifdef NFSSERVER
	nfsrv_init(0);			/* Init server data structures */
	nfsrv_initcache();		/* Init the server request cache */
#endif /* NFSSERVER */

	pool_init(&nfsreqpl, sizeof(struct nfsreq), 0, IPL_NONE, PR_WAITOK,
	    "nfsreqpl", NULL);
}

#ifdef NFSCLIENT
int
nfs_vfs_init(struct vfsconf *vfsp)
{
	extern struct pool nfs_node_pool;

	TAILQ_INIT(&nfs_bufq);

	pool_init(&nfs_node_pool, sizeof(struct nfsnode), 0, IPL_NONE,
		  PR_WAITOK, "nfsnodepl", NULL);

	return (0);
}

/*
 * Attribute cache routines.
 * nfs_loadattrcache() - loads or updates the cache contents from attributes
 *	that are on the mbuf list
 * nfs_getattrcache() - returns valid attributes if found in cache, returns
 *	error otherwise
 */

/*
 * Load the attribute cache (that lives in the nfsnode entry) with
 * the values on the mbuf list and
 * Iff vap not NULL
 *    copy the attributes to *vaper
 */
int
nfs_loadattrcache(struct vnode **vpp, struct mbuf **mdp, caddr_t *dposp,
    struct vattr *vaper)
{
	struct vnode *vp = *vpp;
	struct vattr *vap;
	struct nfs_fattr *fp;
	extern struct vops nfs_specvops;
	struct nfsnode *np;
	int32_t t1;
	caddr_t cp2;
	int error = 0;
	int32_t rdev;
	struct mbuf *md;
	enum vtype vtyp;
	mode_t vmode;
	struct timespec mtime;
	struct vnode *nvp;
	int v3 = NFS_ISV3(vp);
	uid_t uid;
	gid_t gid;

	md = *mdp;
	t1 = (mtod(md, caddr_t) + md->m_len) - *dposp;
	error = nfsm_disct(mdp, dposp, NFSX_FATTR(v3), t1, &cp2);
	if (error)
		return (error);
	fp = (struct nfs_fattr *)cp2;
	if (v3) {
		vtyp = nfsv3tov_type(fp->fa_type);
		vmode = fxdr_unsigned(mode_t, fp->fa_mode);
		rdev = makedev(fxdr_unsigned(u_int32_t, fp->fa3_rdev.specdata1),
			fxdr_unsigned(u_int32_t, fp->fa3_rdev.specdata2));
		fxdr_nfsv3time(&fp->fa3_mtime, &mtime);
	} else {
		vtyp = nfsv2tov_type(fp->fa_type);
		vmode = fxdr_unsigned(mode_t, fp->fa_mode);
		if (vtyp == VNON || vtyp == VREG)
			vtyp = IFTOVT(vmode);
		rdev = fxdr_unsigned(int32_t, fp->fa2_rdev);
		fxdr_nfsv2time(&fp->fa2_mtime, &mtime);

		/*
		 * Really ugly NFSv2 kludge.
		 */
		if (vtyp == VCHR && rdev == 0xffffffff)
			vtyp = VFIFO;
	}

	/*
	 * If v_type == VNON it is a new node, so fill in the v_type,
	 * n_mtime fields. Check to see if it represents a special 
	 * device, and if so, check for a possible alias. Once the
	 * correct vnode has been obtained, fill in the rest of the
	 * information.
	 */
	np = VTONFS(vp);
	if (vp->v_type != vtyp) {
		cache_purge(vp);
		vp->v_type = vtyp;
		if (vp->v_type == VFIFO) {
#ifndef FIFO
			return (EOPNOTSUPP);
#else
                        extern struct vops nfs_fifovops;
			vp->v_op = &nfs_fifovops;
#endif /* FIFO */
		}
		if (vp->v_type == VCHR || vp->v_type == VBLK) {
			vp->v_op = &nfs_specvops;
			nvp = checkalias(vp, (dev_t)rdev, vp->v_mount);
			if (nvp) {
				/*
				 * Discard unneeded vnode, but save its nfsnode.
				 * Since the nfsnode does not have a lock, its
				 * vnode lock has to be carried over.
				 */

				nvp->v_data = vp->v_data;
				vp->v_data = NULL;
				vp->v_op = &spec_vops;
				vrele(vp);
				vgone(vp);
				/*
				 * Reinitialize aliased node.
				 */
				np->n_vnode = nvp;
				*vpp = vp = nvp;
			}
		}
		np->n_mtime = mtime;
	}
	vap = &np->n_vattr;
	vap->va_type = vtyp;
	vap->va_rdev = (dev_t)rdev;
	vap->va_mtime = mtime;
	vap->va_fsid = vp->v_mount->mnt_stat.f_fsid.val[0];

	uid = fxdr_unsigned(uid_t, fp->fa_uid);
	gid = fxdr_unsigned(gid_t, fp->fa_gid);
	/* Invalidate access cache if uid, gid or mode changed. */
	if (np->n_accstamp != -1 &&
	    (gid != vap->va_gid || uid != vap->va_uid ||
	    (vmode & 07777) != vap->va_mode))
		np->n_accstamp = -1;

	vap->va_mode = (vmode & 07777);

	switch (vtyp) {
	case VBLK:
		vap->va_blocksize = BLKDEV_IOSIZE;
		break;
	case VCHR:
		vap->va_blocksize = MAXBSIZE;
		break;
	default:
		vap->va_blocksize = v3 ? vp->v_mount->mnt_stat.f_iosize :
		     fxdr_unsigned(int32_t, fp->fa2_blocksize);
		break;
	}
	if (v3) {
		vap->va_nlink = fxdr_unsigned(nlink_t, fp->fa_nlink);
		vap->va_uid = fxdr_unsigned(uid_t, fp->fa_uid);
		vap->va_gid = fxdr_unsigned(gid_t, fp->fa_gid);
		vap->va_size = fxdr_hyper(&fp->fa3_size);
		vap->va_bytes = fxdr_hyper(&fp->fa3_used);
		vap->va_fileid = fxdr_hyper(&fp->fa3_fileid);
		fxdr_nfsv3time(&fp->fa3_atime, &vap->va_atime);
		fxdr_nfsv3time(&fp->fa3_ctime, &vap->va_ctime);
		vap->va_flags = 0;
		vap->va_filerev = 0;
	} else {
		vap->va_nlink = fxdr_unsigned(nlink_t, fp->fa_nlink);
		vap->va_uid = fxdr_unsigned(uid_t, fp->fa_uid);
		vap->va_gid = fxdr_unsigned(gid_t, fp->fa_gid);
		vap->va_size = fxdr_unsigned(u_int32_t, fp->fa2_size);
		vap->va_bytes =
		    (u_quad_t)fxdr_unsigned(int32_t, fp->fa2_blocks) *
		    NFS_FABLKSIZE;
		vap->va_fileid = fxdr_unsigned(int32_t, fp->fa2_fileid);
		fxdr_nfsv2time(&fp->fa2_atime, &vap->va_atime);
		vap->va_flags = 0;
		vap->va_ctime.tv_sec = fxdr_unsigned(u_int32_t,
		    fp->fa2_ctime.nfsv2_sec);
		vap->va_ctime.tv_nsec = 0;
		vap->va_gen = fxdr_unsigned(u_int32_t,fp->fa2_ctime.nfsv2_usec);
		vap->va_filerev = 0;
	}

	if (vap->va_size != np->n_size) {
		if (vap->va_type == VREG) {
			if (np->n_flag & NMODIFIED) {
				if (vap->va_size < np->n_size)
					vap->va_size = np->n_size;
				else
					np->n_size = vap->va_size;
			} else
				np->n_size = vap->va_size;
			uvm_vnp_setsize(vp, np->n_size);
		} else
			np->n_size = vap->va_size;
	}
	np->n_attrstamp = time_second;
	if (vaper != NULL) {
		bcopy(vap, vaper, sizeof(*vap));
		if (np->n_flag & NCHG) {
			if (np->n_flag & NACC)
				vaper->va_atime = np->n_atim;
			if (np->n_flag & NUPD)
				vaper->va_mtime = np->n_mtim;
		}
	}
	return (0);
}

int
nfs_attrtimeo(struct nfsnode *np)
{
	struct vnode *vp = np->n_vnode;
	struct nfsmount *nmp = VFSTONFS(vp->v_mount);
	int tenthage = (time_second - np->n_mtime.tv_sec) / 10;
	int minto, maxto;

	if (vp->v_type == VDIR) {
		maxto = nmp->nm_acdirmax;
		minto = nmp->nm_acdirmin;
	}
	else {
		maxto = nmp->nm_acregmax;
		minto = nmp->nm_acregmin;
	}

	if (np->n_flag & NMODIFIED || tenthage < minto)
		return minto;
	else if (tenthage < maxto)
		return tenthage;
	else
		return maxto;
}

/*
 * Check the time stamp
 * If the cache is valid, copy contents to *vap and return 0
 * otherwise return an error
 */
int
nfs_getattrcache(struct vnode *vp, struct vattr *vaper)
{
	struct nfsnode *np = VTONFS(vp);
	struct vattr *vap;

	if (np->n_attrstamp == 0 ||
	    (time_second - np->n_attrstamp) >= nfs_attrtimeo(np)) {
		nfsstats.attrcache_misses++;
		return (ENOENT);
	}
	nfsstats.attrcache_hits++;
	vap = &np->n_vattr;
	if (vap->va_size != np->n_size) {
		if (vap->va_type == VREG) {
			if (np->n_flag & NMODIFIED) {
				if (vap->va_size < np->n_size)
					vap->va_size = np->n_size;
				else
					np->n_size = vap->va_size;
			} else
				np->n_size = vap->va_size;
			uvm_vnp_setsize(vp, np->n_size);
		} else
			np->n_size = vap->va_size;
	}
	bcopy(vap, vaper, sizeof(struct vattr));
	if (np->n_flag & NCHG) {
		if (np->n_flag & NACC)
			vaper->va_atime = np->n_atim;
		if (np->n_flag & NUPD)
			vaper->va_mtime = np->n_mtim;
	}
	return (0);
}
#endif /* NFSCLIENT */

/*
 * Set up nameidata for a lookup() call and do it
 */
int
nfs_namei(struct nameidata *ndp, fhandle_t *fhp, int len,
    struct nfssvc_sock *slp, struct mbuf *nam, struct mbuf **mdp,
    caddr_t *dposp, struct vnode **retdirp, struct proc *p)
{
	int i, rem;
	struct mbuf *md;
	char *fromcp, *tocp;
	struct vnode *dp;
	int error, rdonly;
	struct componentname *cnp = &ndp->ni_cnd;

	*retdirp = NULL;
	cnp->cn_pnbuf = pool_get(&namei_pool, PR_WAITOK);
	/*
	 * Copy the name from the mbuf list to ndp->ni_pnbuf
	 * and set the various ndp fields appropriately.
	 */
	fromcp = *dposp;
	tocp = cnp->cn_pnbuf;
	md = *mdp;
	rem = mtod(md, caddr_t) + md->m_len - fromcp;
	for (i = 0; i < len; i++) {
		while (rem == 0) {
			md = md->m_next;
			if (md == NULL) {
				error = EBADRPC;
				goto out;
			}
			fromcp = mtod(md, caddr_t);
			rem = md->m_len;
		}
		if (*fromcp == '\0' || *fromcp == '/') {
			error = EACCES;
			goto out;
		}
		*tocp++ = *fromcp++;
		rem--;
	}
	*tocp = '\0';
	*mdp = md;
	*dposp = fromcp;
	len = nfsm_padlen(len);
	if (len > 0) {
		if (rem >= len)
			*dposp += len;
		else if ((error = nfs_adv(mdp, dposp, len, rem)) != 0)
			goto out;
	}
	ndp->ni_pathlen = tocp - cnp->cn_pnbuf;
	cnp->cn_nameptr = cnp->cn_pnbuf;
	/*
	 * Extract and set starting directory.
	 */
	error = nfsrv_fhtovp(fhp, 0, &dp, ndp->ni_cnd.cn_cred, slp,
	    nam, &rdonly);
	if (error)
		goto out;
	if (dp->v_type != VDIR) {
		vrele(dp);
		error = ENOTDIR;
		goto out;
	}
	vref(dp);
	*retdirp = dp;
	ndp->ni_startdir = dp;
	if (rdonly)
		cnp->cn_flags |= (NOCROSSMOUNT | RDONLY);
	else
		cnp->cn_flags |= NOCROSSMOUNT;

	/*
	 * And call lookup() to do the real work
	 */
	cnp->cn_proc = p;
	error = vfs_lookup(ndp);
	if (error)
		goto out;
	/*
	 * Check for encountering a symbolic link
	 */
	if (cnp->cn_flags & ISSYMLINK) {
		if ((cnp->cn_flags & LOCKPARENT) && ndp->ni_pathlen == 1)
			vput(ndp->ni_dvp);
		else
			vrele(ndp->ni_dvp);
		vput(ndp->ni_vp);
		ndp->ni_vp = NULL;
		error = EINVAL;
		goto out;
	}
	/*
	 * Check for saved name request
	 */
	if (cnp->cn_flags & (SAVENAME | SAVESTART)) {
		cnp->cn_flags |= HASBUF;
		return (0);
	}
out:
	pool_put(&namei_pool, cnp->cn_pnbuf);
	return (error);
}

/*
 * A fiddled version of m_adj() that ensures null fill to a long
 * boundary and only trims off the back end
 */
void
nfsm_adj(struct mbuf *mp, int len, int nul)
{
	struct mbuf *m;
	int count, i;
	char *cp;

	/*
	 * Trim from tail.  Scan the mbuf chain,
	 * calculating its length and finding the last mbuf.
	 * If the adjustment only affects this mbuf, then just
	 * adjust and return.  Otherwise, rescan and truncate
	 * after the remaining size.
	 */
	count = 0;
	m = mp;
	for (;;) {
		count += m->m_len;
		if (m->m_next == NULL)
			break;
		m = m->m_next;
	}
	if (m->m_len > len) {
		m->m_len -= len;
		if (nul > 0) {
			cp = mtod(m, caddr_t)+m->m_len-nul;
			for (i = 0; i < nul; i++)
				*cp++ = '\0';
		}
		return;
	}
	count -= len;
	if (count < 0)
		count = 0;
	/*
	 * Correct length for chain is "count".
	 * Find the mbuf with last data, adjust its length,
	 * and toss data from remaining mbufs on chain.
	 */
	for (m = mp; m; m = m->m_next) {
		if (m->m_len >= count) {
			m->m_len = count;
			if (nul > 0) {
				cp = mtod(m, caddr_t)+m->m_len-nul;
				for (i = 0; i < nul; i++)
					*cp++ = '\0';
			}
			break;
		}
		count -= m->m_len;
	}
	for (m = m->m_next;m;m = m->m_next)
		m->m_len = 0;
}

/*
 * Make these functions instead of macros, so that the kernel text size
 * doesn't get too big...
 */
void
nfsm_srvwcc(struct nfsrv_descript *nfsd, int before_ret,
    struct vattr *before_vap, int after_ret, struct vattr *after_vap,
    struct nfsm_info *info)
{
	u_int32_t *tl;

	if (before_ret) {
		tl = nfsm_build(&info->nmi_mb, NFSX_UNSIGNED);
		*tl = nfs_false;
	} else {
		tl = nfsm_build(&info->nmi_mb, 7 * NFSX_UNSIGNED);
		*tl++ = nfs_true;
		txdr_hyper(before_vap->va_size, tl);
		tl += 2;
		txdr_nfsv3time(&(before_vap->va_mtime), tl);
		tl += 2;
		txdr_nfsv3time(&(before_vap->va_ctime), tl);
	}
	nfsm_srvpostop_attr(nfsd, after_ret, after_vap, info);
}

void
nfsm_srvpostop_attr(struct nfsrv_descript *nfsd, int after_ret,
    struct vattr *after_vap, struct nfsm_info *info)
{
	u_int32_t *tl;
	struct nfs_fattr *fp;

	if (after_ret) {
		tl = nfsm_build(&info->nmi_mb, NFSX_UNSIGNED);
		*tl = nfs_false;
	} else {
		tl = nfsm_build(&info->nmi_mb, NFSX_UNSIGNED + NFSX_V3FATTR);
		*tl++ = nfs_true;
		fp = (struct nfs_fattr *)tl;
		nfsm_srvfattr(nfsd, after_vap, fp);
	}
}

void
nfsm_srvfattr(struct nfsrv_descript *nfsd, struct vattr *vap,
    struct nfs_fattr *fp)
{

	fp->fa_nlink = txdr_unsigned(vap->va_nlink);
	fp->fa_uid = txdr_unsigned(vap->va_uid);
	fp->fa_gid = txdr_unsigned(vap->va_gid);
	if (nfsd->nd_flag & ND_NFSV3) {
		fp->fa_type = vtonfsv3_type(vap->va_type);
		fp->fa_mode = vtonfsv3_mode(vap->va_mode);
		txdr_hyper(vap->va_size, &fp->fa3_size);
		txdr_hyper(vap->va_bytes, &fp->fa3_used);
		fp->fa3_rdev.specdata1 = txdr_unsigned(major(vap->va_rdev));
		fp->fa3_rdev.specdata2 = txdr_unsigned(minor(vap->va_rdev));
		fp->fa3_fsid.nfsuquad[0] = 0;
		fp->fa3_fsid.nfsuquad[1] = txdr_unsigned(vap->va_fsid);
		txdr_hyper(vap->va_fileid, &fp->fa3_fileid);
		txdr_nfsv3time(&vap->va_atime, &fp->fa3_atime);
		txdr_nfsv3time(&vap->va_mtime, &fp->fa3_mtime);
		txdr_nfsv3time(&vap->va_ctime, &fp->fa3_ctime);
	} else {
		fp->fa_type = vtonfsv2_type(vap->va_type);
		fp->fa_mode = vtonfsv2_mode(vap->va_type, vap->va_mode);
		fp->fa2_size = txdr_unsigned(vap->va_size);
		fp->fa2_blocksize = txdr_unsigned(vap->va_blocksize);
		if (vap->va_type == VFIFO)
			fp->fa2_rdev = 0xffffffff;
		else
			fp->fa2_rdev = txdr_unsigned(vap->va_rdev);
		fp->fa2_blocks = txdr_unsigned(vap->va_bytes / NFS_FABLKSIZE);
		fp->fa2_fsid = txdr_unsigned(vap->va_fsid);
		fp->fa2_fileid = txdr_unsigned((u_int32_t)vap->va_fileid);
		txdr_nfsv2time(&vap->va_atime, &fp->fa2_atime);
		txdr_nfsv2time(&vap->va_mtime, &fp->fa2_mtime);
		txdr_nfsv2time(&vap->va_ctime, &fp->fa2_ctime);
	}
}

/*
 * nfsrv_fhtovp() - convert a fh to a vnode ptr (optionally locked)
 * 	- look up fsid in mount list (if not found ret error)
 *	- get vp and export rights by calling VFS_FHTOVP() and VFS_CHECKEXP()
 *	- if cred->cr_uid == 0 or MNT_EXPORTANON set it to credanon
 *	- if not lockflag unlock it with VOP_UNLOCK()
 */
int
nfsrv_fhtovp(fhandle_t *fhp, int lockflag, struct vnode **vpp,
    struct ucred *cred, struct nfssvc_sock *slp, struct mbuf *nam,
    int *rdonlyp)
{
	struct proc *p = curproc;	/* XXX */
	struct mount *mp;
	int i;
	struct ucred *credanon;
	int error, exflags;
	struct sockaddr_in *saddr;

	*vpp = NULL;
	mp = vfs_getvfs(&fhp->fh_fsid);

	if (!mp)
		return (ESTALE);
	error = VFS_CHECKEXP(mp, nam, &exflags, &credanon);
	if (error)
		return (error);
	error = VFS_FHTOVP(mp, &fhp->fh_fid, vpp);
	if (error)
		return (error);

	saddr = mtod(nam, struct sockaddr_in *);
	if (saddr->sin_family == AF_INET &&
	    (ntohs(saddr->sin_port) >= IPPORT_RESERVED ||
	    (slp->ns_so->so_type == SOCK_STREAM && ntohs(saddr->sin_port) == 20))) {
		vput(*vpp);
		return (NFSERR_AUTHERR | AUTH_TOOWEAK);
	}

	/* Check/setup credentials. */
	if (cred->cr_uid == 0 || (exflags & MNT_EXPORTANON)) {
		cred->cr_uid = credanon->cr_uid;
		cred->cr_gid = credanon->cr_gid;
		for (i = 0; i < credanon->cr_ngroups && i < NGROUPS_MAX; i++)
			cred->cr_groups[i] = credanon->cr_groups[i];
		cred->cr_ngroups = i;
	}
	if (exflags & MNT_EXRDONLY)
		*rdonlyp = 1;
	else
		*rdonlyp = 0;
	if (!lockflag)
		VOP_UNLOCK(*vpp, p);

	return (0);
}

/*
 * This function compares two net addresses by family and returns non zero
 * if they are the same host, or if there is any doubt it returns 0.
 * The AF_INET family is handled as a special case so that address mbufs
 * don't need to be saved to store "struct in_addr", which is only 4 bytes.
 */
int
netaddr_match(int family, union nethostaddr *haddr, struct mbuf *nam)
{
	struct sockaddr_in *inetaddr;

	switch (family) {
	case AF_INET:
		inetaddr = mtod(nam, struct sockaddr_in *);
		if (inetaddr->sin_family == AF_INET &&
		    inetaddr->sin_addr.s_addr == haddr->had_inetaddr)
			return (1);
		break;
	default:
		break;
	};
	return (0);
}

/*
 * The write verifier has changed (probably due to a server reboot), so all
 * B_NEEDCOMMIT blocks will have to be written again. Since they are on the
 * dirty block list as B_DELWRI, all this takes is clearing the B_NEEDCOMMIT
 * flag. Once done the new write verifier can be set for the mount point.
 */
void
nfs_clearcommit(struct mount *mp)
{
	struct vnode *vp, *nvp;
	struct buf *bp, *nbp;
	int s;

	s = splbio();
loop:
	for (vp = LIST_FIRST(&mp->mnt_vnodelist); vp != NULL; vp = nvp) {
		if (vp->v_mount != mp)	/* Paranoia */
			goto loop;
		nvp = LIST_NEXT(vp, v_mntvnodes);
		for (bp = LIST_FIRST(&vp->v_dirtyblkhd); bp != NULL; bp = nbp) {
			nbp = LIST_NEXT(bp, b_vnbufs);
			if ((bp->b_flags & (B_BUSY | B_DELWRI | B_NEEDCOMMIT))
				== (B_DELWRI | B_NEEDCOMMIT))
				bp->b_flags &= ~B_NEEDCOMMIT;
		}
	}
	splx(s);
}

void
nfs_merge_commit_ranges(struct vnode *vp)
{
	struct nfsnode *np = VTONFS(vp);

	if (!(np->n_commitflags & NFS_COMMIT_PUSHED_VALID)) {
		np->n_pushedlo = np->n_pushlo;
		np->n_pushedhi = np->n_pushhi;
		np->n_commitflags |= NFS_COMMIT_PUSHED_VALID;
	} else {
		if (np->n_pushlo < np->n_pushedlo)
			np->n_pushedlo = np->n_pushlo;
		if (np->n_pushhi > np->n_pushedhi)
			np->n_pushedhi = np->n_pushhi;
	}

	np->n_pushlo = np->n_pushhi = 0;
	np->n_commitflags &= ~NFS_COMMIT_PUSH_VALID;
}

int
nfs_in_committed_range(struct vnode *vp, struct buf *bp)
{
	struct nfsnode *np = VTONFS(vp);
	off_t lo, hi;

	if (!(np->n_commitflags & NFS_COMMIT_PUSHED_VALID))
		return 0;
	lo = (off_t)bp->b_blkno * DEV_BSIZE;
	hi = lo + bp->b_dirtyend;

	return (lo >= np->n_pushedlo && hi <= np->n_pushedhi);
}

int
nfs_in_tobecommitted_range(struct vnode *vp, struct buf *bp)
{
	struct nfsnode *np = VTONFS(vp);
	off_t lo, hi;

	if (!(np->n_commitflags & NFS_COMMIT_PUSH_VALID))
		return 0;
	lo = (off_t)bp->b_blkno * DEV_BSIZE;
	hi = lo + bp->b_dirtyend;

	return (lo >= np->n_pushlo && hi <= np->n_pushhi);
}

void
nfs_add_committed_range(struct vnode *vp, struct buf *bp)
{
	struct nfsnode *np = VTONFS(vp);
	off_t lo, hi;

	lo = (off_t)bp->b_blkno * DEV_BSIZE;
	hi = lo + bp->b_dirtyend;

	if (!(np->n_commitflags & NFS_COMMIT_PUSHED_VALID)) {
		np->n_pushedlo = lo;
		np->n_pushedhi = hi;
		np->n_commitflags |= NFS_COMMIT_PUSHED_VALID;
	} else {
		if (hi > np->n_pushedhi)
			np->n_pushedhi = hi;
		if (lo < np->n_pushedlo)
			np->n_pushedlo = lo;
	}
}

void
nfs_del_committed_range(struct vnode *vp, struct buf *bp)
{
	struct nfsnode *np = VTONFS(vp);
	off_t lo, hi;

	if (!(np->n_commitflags & NFS_COMMIT_PUSHED_VALID))
		return;

	lo = (off_t)bp->b_blkno * DEV_BSIZE;
	hi = lo + bp->b_dirtyend;

	if (lo > np->n_pushedhi || hi < np->n_pushedlo)
		return;
	if (lo <= np->n_pushedlo)
		np->n_pushedlo = hi;
	else if (hi >= np->n_pushedhi)
		np->n_pushedhi = lo;
	else {
		/*
		 * XXX There's only one range. If the deleted range
		 * is in the middle, pick the largest of the
		 * contiguous ranges that it leaves.
		 */
		if ((np->n_pushedlo - lo) > (hi - np->n_pushedhi))
			np->n_pushedhi = lo;
		else
			np->n_pushedlo = hi;
	}
}

void
nfs_add_tobecommitted_range(struct vnode *vp, struct buf *bp)
{
	struct nfsnode *np = VTONFS(vp);
	off_t lo, hi;

	lo = (off_t)bp->b_blkno * DEV_BSIZE;
	hi = lo + bp->b_dirtyend;

	if (!(np->n_commitflags & NFS_COMMIT_PUSH_VALID)) {
		np->n_pushlo = lo;
		np->n_pushhi = hi;
		np->n_commitflags |= NFS_COMMIT_PUSH_VALID;
	} else {
		if (lo < np->n_pushlo)
			np->n_pushlo = lo;
		if (hi > np->n_pushhi)
			np->n_pushhi = hi;
	}
}

void
nfs_del_tobecommitted_range(struct vnode *vp, struct buf *bp)
{
	struct nfsnode *np = VTONFS(vp);
	off_t lo, hi;

	if (!(np->n_commitflags & NFS_COMMIT_PUSH_VALID))
		return;

	lo = (off_t)bp->b_blkno * DEV_BSIZE;
	hi = lo + bp->b_dirtyend;

	if (lo > np->n_pushhi || hi < np->n_pushlo)
		return;

	if (lo <= np->n_pushlo)
		np->n_pushlo = hi;
	else if (hi >= np->n_pushhi)
		np->n_pushhi = lo;
	else {
		/*
		 * XXX There's only one range. If the deleted range
		 * is in the middle, pick the largest of the
		 * contiguous ranges that it leaves.
		 */
		if ((np->n_pushlo - lo) > (hi - np->n_pushhi))
			np->n_pushhi = lo;
		else
			np->n_pushlo = hi;
	}
}

/*
 * Map errnos to NFS error numbers. For Version 3 also filter out error
 * numbers not specified for the associated procedure.
 */
int
nfsrv_errmap(struct nfsrv_descript *nd, int err)
{
	short *defaulterrp, *errp;

	if (nd->nd_flag & ND_NFSV3) {
	    if (nd->nd_procnum <= NFSPROC_COMMIT) {
		errp = defaulterrp = nfsrv_v3errmap[nd->nd_procnum];
		while (*++errp) {
			if (*errp == err)
				return (err);
			else if (*errp > err)
				break;
		}
		return ((int)*defaulterrp);
	    } else
		return (err & 0xffff);
	}
	if (err <= nitems(nfsrv_v2errmap))
		return ((int)nfsrv_v2errmap[err - 1]);
	return (NFSERR_IO);
}

/*
 * If full is non zero, set all fields, otherwise just set mode and time fields
 */
void
nfsm_v3attrbuild(struct mbuf **mp, struct vattr *a, int full)
{
	struct mbuf *mb;
	u_int32_t *tl;

	mb = *mp;

	if (a->va_mode != (mode_t)VNOVAL) {
		tl = nfsm_build(&mb, 2 * NFSX_UNSIGNED);
		*tl++ = nfs_true;
		*tl = txdr_unsigned(a->va_mode);
	} else {
		tl = nfsm_build(&mb, NFSX_UNSIGNED);
		*tl = nfs_false;
	}
	if (full && a->va_uid != (uid_t)VNOVAL) {
		tl = nfsm_build(&mb, 2 * NFSX_UNSIGNED);
		*tl++ = nfs_true;
		*tl = txdr_unsigned(a->va_uid);
	} else {
		tl = nfsm_build(&mb, NFSX_UNSIGNED);
		*tl = nfs_false;
	}
	if (full && a->va_gid != (gid_t)VNOVAL) {
		tl = nfsm_build(&mb, 2 * NFSX_UNSIGNED);
		*tl++ = nfs_true;
		*tl = txdr_unsigned((a)->va_gid);
	} else {
		tl = nfsm_build(&mb, NFSX_UNSIGNED);
		*tl = nfs_false;
	}
	if (full && a->va_size != VNOVAL) {
		tl = nfsm_build(&mb, 3 * NFSX_UNSIGNED);
		*tl++ = nfs_true;
		txdr_hyper(a->va_size, tl);
	} else {
		tl = nfsm_build(&mb, NFSX_UNSIGNED);
		*tl = nfs_false;
	}
	if (a->va_atime.tv_nsec != VNOVAL) {
		if (a->va_atime.tv_sec != time_second) {
			tl = nfsm_build(&mb, 3 * NFSX_UNSIGNED);
			*tl++ = txdr_unsigned(NFSV3SATTRTIME_TOCLIENT);
			txdr_nfsv3time(&a->va_atime, tl);
		} else {
			tl = nfsm_build(&mb, NFSX_UNSIGNED);
			*tl = txdr_unsigned(NFSV3SATTRTIME_TOSERVER);
		}
	} else {
		tl = nfsm_build(&mb, NFSX_UNSIGNED);
		*tl = txdr_unsigned(NFSV3SATTRTIME_DONTCHANGE);
	}
	if (a->va_mtime.tv_nsec != VNOVAL) {
		if (a->va_mtime.tv_sec != time_second) {
			tl = nfsm_build(&mb, 3 * NFSX_UNSIGNED);
			*tl++ = txdr_unsigned(NFSV3SATTRTIME_TOCLIENT);
			txdr_nfsv3time(&a->va_mtime, tl);
		} else {
			tl = nfsm_build(&mb, NFSX_UNSIGNED);
			*tl = txdr_unsigned(NFSV3SATTRTIME_TOSERVER);
		}
	} else {
		tl = nfsm_build(&mb, NFSX_UNSIGNED);
		*tl = txdr_unsigned(NFSV3SATTRTIME_DONTCHANGE);
	}

	*mp = mb;
}

/*
 * Ensure a contiguous buffer len bytes long
 */
void *
nfsm_build(struct mbuf **mp, u_int len)
{
	struct mbuf *mb, *mb2;
	caddr_t bpos;

	mb = *mp;
	bpos = mb_offset(mb);

	if (len > M_TRAILINGSPACE(mb)) {
		MGET(mb2, M_WAIT, MT_DATA);
		if (len > MLEN)
			panic("build > MLEN");
		mb->m_next = mb2;
		mb = mb2;
		mb->m_len = 0;
		bpos = mtod(mb, caddr_t);
	}
	mb->m_len += len;

	*mp = mb;

	return (bpos);
}

void
nfsm_fhtom(struct nfsm_info *info, struct vnode *v, int v3)
{
	struct nfsnode *n = VTONFS(v);

	if (v3) {
		nfsm_strtombuf(&info->nmi_mb, n->n_fhp, n->n_fhsize);
	} else {
		nfsm_buftombuf(&info->nmi_mb, n->n_fhp, NFSX_V2FH);
	}
}

void
nfsm_srvfhtom(struct mbuf **mp, fhandle_t *f, int v3)
{
	if (v3) {
		nfsm_strtombuf(mp, f, NFSX_V3FH);
	} else {
		nfsm_buftombuf(mp, f, NFSX_V2FH);
	}
}

int
nfsm_srvsattr(struct mbuf **mp, struct vattr *va, struct mbuf *mrep,
    caddr_t *dposp)
{
	struct nfsm_info	info;
	uint32_t *tl, t1;
	caddr_t cp2;
	int error = 0;

	info.nmi_md = *mp;
	info.nmi_dpos = *dposp;

	nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);
	if (*tl == nfs_true) {
		nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);
		va->va_mode = nfstov_mode(*tl);
	}

	nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);
	if (*tl == nfs_true) {
		nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);
		va->va_uid = fxdr_unsigned(uid_t, *tl);
	}

	nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);
	if (*tl == nfs_true) {
		nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);
		va->va_gid = fxdr_unsigned(gid_t, *tl);
	}

	nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);
	if (*tl == nfs_true) {
		nfsm_dissect(tl, u_int32_t *, 2 * NFSX_UNSIGNED);
		va->va_size = fxdr_hyper(tl);
	}

	nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);
	switch (fxdr_unsigned(int, *tl)) {
	case NFSV3SATTRTIME_TOCLIENT:
		va->va_vaflags |= VA_UTIMES_CHANGE;
		va->va_vaflags &= ~VA_UTIMES_NULL;
		nfsm_dissect(tl, u_int32_t *, 2 * NFSX_UNSIGNED);
		fxdr_nfsv3time(tl, &va->va_atime);
		break;
	case NFSV3SATTRTIME_TOSERVER:
		va->va_vaflags |= VA_UTIMES_CHANGE;
		getnanotime(&va->va_atime);
		break;
	};

	nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);
	switch (fxdr_unsigned(int, *tl)) {
	case NFSV3SATTRTIME_TOCLIENT:
		va->va_vaflags |= VA_UTIMES_CHANGE;
		va->va_vaflags &= ~VA_UTIMES_NULL;
		nfsm_dissect(tl, u_int32_t *, 2 * NFSX_UNSIGNED);
		fxdr_nfsv3time(tl, &va->va_mtime);
		break;
	case NFSV3SATTRTIME_TOSERVER:
		va->va_vaflags |= VA_UTIMES_CHANGE;
		getnanotime(&va->va_mtime);
		break;
	};

	*dposp = info.nmi_dpos;
	*mp = info.nmi_md;
nfsmout:
	return (error);
}

void
txdr_nfsv2time(const struct timespec *from, struct nfsv2_time *to)
{
	if (from->tv_nsec == VNOVAL) {
		to->nfsv2_sec = nfs_xdrneg1;
		to->nfsv2_usec = nfs_xdrneg1;
	} else if (from->tv_sec == -1) {
		/*
		 * can't request a time of -1; send
		 * -1.000001 == {-2,999999} instead
		 */
		to->nfsv2_sec = htonl(-2);
		to->nfsv2_usec = htonl(999999);
	} else {
		to->nfsv2_sec = htonl(from->tv_sec);
		to->nfsv2_usec = htonl(from->tv_nsec / 1000);
	}
}
@


1.134
log
@Keep local definitions local.

"good work" deraadt@@, ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.133 2016/09/15 02:00:18 dlg Exp $	*/
a1247 6

	/*
	 * Should be 0, if not someone didn't init ndp with NDINIT,
	 * go find and murder the offender messily.
	 */
	KASSERT (ndp->ni_p_path == NULL && ndp->ni_p_size == 0);
@


1.133
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.132 2016/08/30 07:12:49 dlg Exp $	*/
d73 1
@


1.132
log
@pool_setipl for nfs pools

ok natano@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.131 2016/04/29 14:40:36 beck Exp $	*/
d900 1
a900 1
	pool_init(&nfsreqpl, sizeof(struct nfsreq), 0, 0, PR_WAITOK,
a901 1
	pool_setipl(&nfsreqpl, IPL_NONE);
d912 2
a913 3
	pool_init(&nfs_node_pool, sizeof(struct nfsnode), 0, 0, PR_WAITOK,
	    "nfsnodepl", NULL);
	pool_setipl(&nfs_node_pool, IPL_NONE);
@


1.131
log
@Fix some gibbering horrors due to uninitialized struct nameidata's

1) turn NDINITAT into a function and make the macros point to it
with the later goal of getting rid of them.

2) Sweep the kernel for places where people make a struct nameidata manually
on the stack and fill in what they hope are the required fields and count
on prayer and clean living to always get them right. Instead use NDINIT
everywhere. NFS was especially bad for this and there have likely
been things lurking there for a while.

3) Add a couple of strategic KASSERT's to catch future offenders.

ok krw@@ sthen@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.130 2016/03/19 12:04:16 natano Exp $	*/
d902 1
d915 1
@


1.130
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.129 2016/02/13 15:45:05 stefan Exp $	*/
d1247 7
@


1.129
log
@Convert to uiomove. From Martin Natano.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.128 2015/06/16 11:09:40 mpi Exp $	*/
d1473 1
a1473 1
		VOP_UNLOCK(*vpp, 0, p);
@


1.128
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.127 2015/04/17 04:43:21 guenther Exp $	*/
d715 2
a716 2
		xfer = min(len, M_TRAILINGSPACE(mb));
		uiomovei(mb_offset(mb), xfer, uiop);
@


1.127
log
@Tweaks utimensat/futimens handling to always update ctime, even when both
atime and mtime are UTIME_OMIT (at least for ufs, tmpfs, and ext2fs), and
to correctly handle a timestamp of -1.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.126 2015/03/14 03:38:52 jsg Exp $	*/
d629 1
a629 1
	mb->m_pkthdr.rcvif = NULL;
@


1.126
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.125 2015/02/10 21:56:10 miod Exp $	*/
d1754 1
a1754 1
	if (a->va_atime.tv_sec != VNOVAL) {
d1767 1
a1767 1
	if (a->va_mtime.tv_sec != VNOVAL) {
d1873 1
d1879 1
d1887 1
d1893 1
d1902 19
@


1.125
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.124 2015/01/17 17:49:27 deraadt Exp $	*/
a55 1
#include <sys/specdev.h>
@


1.124
log
@use NGROUPS_MAX
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.123 2014/12/29 05:29:28 miod Exp $	*/
d717 1
a717 1
		uiomove(mb_offset(mb), xfer, uiop);
@


1.123
log
@Explicitely include <uvm/uvm_extern.h> in order to build on variable page size
architectures.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.122 2014/12/23 01:55:03 tedu Exp $	*/
d1465 1
a1465 1
		for (i = 0; i < credanon->cr_ngroups && i < NGROUPS; i++)
@


1.122
log
@change req pool alloc to null. add prwaitok here and nfs_node_pool which
is also sleeping in all callers, but already used null
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.121 2014/12/18 21:00:12 tedu Exp $	*/
d67 1
@


1.121
log
@convert one hot looking bcopy to memcpy
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.120 2014/12/18 20:59:21 tedu Exp $	*/
d900 2
a901 2
	pool_init(&nfsreqpl, sizeof(struct nfsreq), 0, 0, 0, "nfsreqpl",
	    &pool_allocator_nointr);
d912 1
a912 1
	pool_init(&nfs_node_pool, sizeof(struct nfsnode), 0, 0, 0,
@


1.120
log
@delete a whole mess of unnecessary caddr_t casts
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.119 2014/11/18 02:37:31 tedu Exp $	*/
d666 1
a666 1
				bcopy(mbufcp, uiocp, xfer);
@


1.119
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.118 2014/11/14 23:01:44 tedu Exp $	*/
d1096 1
a1096 1
		bcopy((caddr_t)vap, (caddr_t)vaper, sizeof(*vap));
d1163 1
a1163 1
	bcopy((caddr_t)vap, (caddr_t)vaper, sizeof(struct vattr));
@


1.118
log
@bzero -> memset
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.117 2014/09/14 14:17:26 jsg Exp $	*/
a69 1
#include <dev/rndvar.h>
@


1.117
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.116 2014/07/08 17:19:26 deraadt Exp $	*/
d737 1
a737 1
		bzero(mb_offset(mb), pad);
@


1.116
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.115 2013/11/27 16:02:54 jsing Exp $	*/
a44 1
#include <sys/proc.h>
@


1.115
log
@If the v_type is going to change when loading the NFS attribute cache,
purge the vnode from the namecache first. This prevents cache_purge()
from later getting confused and trying to cache_zap() a namecache entry
multiple times over, due to cache_zap() believing that the entry does not
need to be removed from the vnode destinations queue.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.114 2013/08/13 05:52:25 guenther Exp $	*/
a57 2

#include <uvm/uvm_extern.h>
@


1.114
log
@Switch time_t, ino_t, clock_t, and struct kevent's ident and data
members to 64bit types.  Assign new syscall numbers for (almost
all) the syscalls that involve the affected types, including anything
with time_t, timeval, itimerval, timespec, rusage, dirent, stat,
or kevent arguments.  Add a d_off member to struct dirent and replace
getdirentries() with getdents(), thus immensely simplifying and
accelerating telldir/seekdir.  Build perl with -DBIG_TIME.

Bump the major on every single base library: the compat bits included
here are only good enough to make the transition; the T32 compat
option will be burned as soon as we've reached the new world are
are happy with the snapshots for all architectures.

DANGER: ABI incompatibility.  Updating to this kernel requires extra
work or you won't be able to login: install a snapshot instead.

Much assistance in fixing userland issues from deraadt@@ and tedu@@
and build assistance from todd@@ and otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.113 2011/07/04 21:00:10 deraadt Exp $	*/
d994 1
@


1.113
log
@move the specfs code to a place people can see it; ok guenther thib krw
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.112 2010/12/21 20:14:43 thib Exp $	*/
d1061 1
a1061 2
		vap->va_fileid = fxdr_unsigned(int32_t,
		    fp->fa3_fileid.nfsuquad[1]);
d1402 1
a1402 2
		fp->fa3_fileid.nfsuquad[0] = 0;
		fp->fa3_fileid.nfsuquad[1] = txdr_unsigned(vap->va_fileid);
d1417 1
a1417 1
		fp->fa2_fileid = txdr_unsigned(vap->va_fileid);
@


1.112
log
@Bring back the "End the VOP experiment." diff, naddy's issues where
unrelated, and his alpha is much happier now.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.111 2010/09/10 16:34:09 thib Exp $	*/
d57 1
a69 1
#include <miscfs/specfs/specdev.h>
@


1.111
log
@Backout the VOP diff until the issues naddy was seeing on alpha (gcc3)
have been resolved.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.110 2010/09/09 10:37:04 thib Exp $	*/
d943 1
a943 1
	extern int (**spec_nfsv2nodeop_p)(void *);
d999 2
a1000 2
			extern int (**fifo_nfsv2nodeop_p)(void *);
			vp->v_op = fifo_nfsv2nodeop_p;
d1004 1
a1004 1
			vp->v_op = spec_nfsv2nodeop_p;
d1015 1
a1015 1
				vp->v_op = spec_vnodeop_p;
@


1.110
log
@Rename lookup/relookup to vfs_lookup/vfs_relookup.

OK oga@@, beck@@, matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.109 2010/09/06 23:44:10 thib Exp $	*/
d943 1
a943 1
	extern struct vops nfs_specvops;
d999 2
a1000 2
                        extern struct vops nfs_fifovops;
			vp->v_op = &nfs_fifovops;
d1004 1
a1004 1
			vp->v_op = &nfs_specvops;
d1015 1
a1015 1
				vp->v_op = &spec_vops;
@


1.109
log
@End the VOP experiment. Instead of the ridicolusly complicated operation
vector setup that has questionable features (that have, as far as I can
tell never been used in practice, atleast not in OpenBSD), remove all
the gunk and favor a simple struct full of function pointers that get
set directly by each of the filesystems.

Removes gobs of ugly code and makes things simpler by a magnitude.

The only downside of this is that we loose the vnoperate feature so
the spec/fifo operations of the filesystems need to be kept in sync
with specfs and fifofs, this is no big deal as the API it self is pretty
static.

Many thanks to armani@@ who pulled an earlier version of this diff to
current after c2k10 and Gabriel Kihlman on tech@@ for testing.

Liked by many. "come on, find your balls" deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.108 2010/05/19 08:31:23 thib Exp $	*/
d1255 1
a1255 1
	error = lookup(ndp);
@


1.108
log
@clean up a few things that where left to rot after bob's vfs cache work.
sync a few comments to reality (or remove them), remove the cn_hash member
from struct componentname, spacing.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.107 2009/10/19 22:24:18 jsg Exp $	*/
d943 1
a943 1
	extern int (**spec_nfsv2nodeop_p)(void *);
d999 2
a1000 2
			extern int (**fifo_nfsv2nodeop_p)(void *);
			vp->v_op = fifo_nfsv2nodeop_p;
d1004 1
a1004 1
			vp->v_op = spec_nfsv2nodeop_p;
d1015 1
a1015 1
				vp->v_op = spec_vnodeop_p;
@


1.107
log
@antsy
no binary change apart from nfsm_reqhead() which is clearly correct.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.106 2009/09/02 18:20:54 thib Exp $	*/
a1202 1
	cnp->cn_hash = 0;
a1216 1
		cnp->cn_hash += (u_char)*fromcp;
@


1.106
log
@Backout the asyncio/aiod change, as it causes buf's to get hung.
problem noticed by deraadt@@

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.102 2009/08/13 15:03:19 blambert Exp $	*/
d518 1
a518 2
nfsm_reqhead(hsiz)
	int hsiz;
d640 1
a640 5
nfsm_mbuftouio(mrep, uiop, siz, dpos)
	struct mbuf **mrep;
	struct uio *uiop;
	int siz;
	caddr_t *dpos;
d801 1
a801 6
nfsm_disct(mdp, dposp, siz, left, cp2)
	struct mbuf **mdp;
	caddr_t *dposp;
	int siz;
	int left;
	caddr_t *cp2;
d859 1
a859 5
nfs_adv(mdp, dposp, offs, left)
	struct mbuf **mdp;
	caddr_t *dposp;
	int offs;
	int left;
d882 1
a882 1
nfs_init()
d937 2
a938 5
nfs_loadattrcache(vpp, mdp, dposp, vaper)
	struct vnode **vpp;
	struct mbuf **mdp;
	caddr_t *dposp;
	struct vattr *vaper;
d1112 1
a1112 2
nfs_attrtimeo(np)
	struct nfsnode *np;
d1142 1
a1142 3
nfs_getattrcache(vp, vaper)
	struct vnode *vp;
	struct vattr *vaper;
d1182 3
a1184 10
nfs_namei(ndp, fhp, len, slp, nam, mdp, dposp, retdirp, p)
	struct nameidata *ndp;
	fhandle_t *fhp;
	int len;
	struct nfssvc_sock *slp;
	struct mbuf *nam;
	struct mbuf **mdp;
	caddr_t *dposp;
	struct vnode **retdirp;
	struct proc *p;
d1290 1
a1290 4
nfsm_adj(mp, len, nul)
	struct mbuf *mp;
	int len;
	int nul;
d1389 2
a1390 4
nfsm_srvfattr(nfsd, vap, fp)
	struct nfsrv_descript *nfsd;
	struct vattr *vap;
	struct nfs_fattr *fp;
d1436 3
a1438 8
nfsrv_fhtovp(fhp, lockflag, vpp, cred, slp, nam, rdonlyp)
	fhandle_t *fhp;
	int lockflag;
	struct vnode **vpp;
	struct ucred *cred;
	struct nfssvc_sock *slp;
	struct mbuf *nam;
	int *rdonlyp;
d1492 1
a1492 4
netaddr_match(family, haddr, nam)
	int family;
	union nethostaddr *haddr;
	struct mbuf *nam;
d1516 1
a1516 2
nfs_clearcommit(mp)
	struct mount *mp;
d1539 1
a1539 2
nfs_merge_commit_ranges(vp)
	struct vnode *vp;
d1559 1
a1559 3
nfs_in_committed_range(vp, bp)
	struct vnode *vp;
	struct buf *bp;
d1573 1
a1573 3
nfs_in_tobecommitted_range(vp, bp)
	struct vnode *vp;
	struct buf *bp;
d1587 1
a1587 3
nfs_add_committed_range(vp, bp)
	struct vnode *vp;
	struct buf *bp;
d1608 1
a1608 3
nfs_del_committed_range(vp, bp)
	struct vnode *vp;
	struct buf *bp;
d1639 1
a1639 3
nfs_add_tobecommitted_range(vp, bp)
	struct vnode *vp;
	struct buf *bp;
d1660 1
a1660 3
nfs_del_tobecommitted_range(vp, bp)
	struct vnode *vp;
	struct buf *bp;
d1696 1
a1696 3
nfsrv_errmap(nd, err)
	struct nfsrv_descript *nd;
	int err;
@


1.105
log
@move to having requests on a per nfsmount tailq instead of one global one.
also make the rexmit timeout per nfsmount, and make sure to start/stop the
timer appropriately.

now the nfs_timer() only fires if there is work todo, not always at nfs_ticks
(it did, even if there where no nfsmounts in the system!).

OK blambert@@
@
text
@d928 1
a928 3
	LIST_INIT(&nfs_aiods_all);
	LIST_INIT(&nfs_aiods_idle);
	mtx_init(&nfs_aiodl_mtx, IPL_BIO);
@


1.104
log
@Rework the way we do async I/O in nfs. Introduce separate buf queues for
each mount, and when work is "found", peg an aiod to that mount todo the
I/O. Make nfs_asyncio() a bit smarter when deciding when to do asyncio
and when to force it sync, this is done by keeping the aiod's one two lists,
an "idle" and an "all" list, so asyncio is only done when there are aiods
hanging around todo it for us or are already pegged to the mount.

Idea liked by at least beck@@ (and I think art@@).
Extensive testing done by myself and jasper and a few others on various
arch's.

Ideas/Code from Net/Free.

OK blambert@@.
@
text
@a897 2
	static struct timeout nfs_timer_to;

a919 8

	/*
	 * Initialize reply list and start timer
	 */
	TAILQ_INIT(&nfs_reqq);

	timeout_set(&nfs_timer_to, nfs_timer, &nfs_timer_to);
	nfs_timer(&nfs_timer_to);
@


1.103
log
@Teach nfsm_fhtom about nfsm_info structs

ok thib@@
@
text
@d938 3
a940 1
	TAILQ_INIT(&nfs_bufq);
@


1.102
log
@change version 3 post-operation attribute building function to not
use mbufs directly, but the shiny new nfsm_info struct

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.101 2009/08/10 10:59:12 thib Exp $	*/
d1886 1
a1886 1
nfsm_fhtom(struct mbuf **mp, struct vnode *v, int v3)
d1891 1
a1891 1
		nfsm_strtombuf(mp, n->n_fhp, n->n_fhsize);
d1893 1
a1893 1
		nfsm_buftombuf(mp, n->n_fhp, NFSX_V2FH);
@


1.101
log
@Use an RB tree instead of a hashtable for fh/node lookups.

Idea from NetBSD.

OK blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.100 2009/08/10 09:38:44 thib Exp $	*/
d1139 1
a1139 1
nfs_attrtimeo (np)
d1389 3
a1391 7
nfsm_srvwcc(nfsd, before_ret, before_vap, after_ret, after_vap, mbp)
	struct nfsrv_descript *nfsd;
	int before_ret;
	struct vattr *before_vap;
	int after_ret;
	struct vattr *after_vap;
	struct mbuf **mbp;
a1392 1
	struct mbuf *mb = *mbp;
d1396 1
a1396 1
		tl = nfsm_build(&mb, NFSX_UNSIGNED);
d1399 1
a1399 1
		tl = nfsm_build(&mb, 7 * NFSX_UNSIGNED);
d1407 1
a1407 2
	*mbp = mb;
	nfsm_srvpostop_attr(nfsd, after_ret, after_vap, mbp);
d1411 2
a1412 5
nfsm_srvpostop_attr(nfsd, after_ret, after_vap, mbp)
	struct nfsrv_descript *nfsd;
	int after_ret;
	struct vattr *after_vap;
	struct mbuf **mbp;
a1413 1
	struct mbuf *mb = *mbp;
d1418 1
a1418 1
		tl = nfsm_build(&mb, NFSX_UNSIGNED);
d1421 1
a1421 1
		tl = nfsm_build(&mb, NFSX_UNSIGNED + NFSX_V3FATTR);
a1425 1
	*mbp = mb;
@


1.100
log
@Remove the v2 writegather code. It did help alot back in the 80s
but extensive performance benchmarking done by myself and jasper@@
has shown that it doesn't help, at all - even on vaxens and in some
cases it makes things significantly slower.

"this excites me sexually" jetpack@@
Tested by jasper@@.
OK blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.93 2009/03/30 19:58:50 blambert Exp $	*/
d934 1
a934 2
nfs_vfs_init(vfsp)
	struct vfsconf *vfsp;
d936 2
d939 3
a941 1
	nfs_nhinit();			/* Init the nfsnode table */
@


1.99
log
@group all of the on-stack variables that are uses by the nfsm_macros
to keep the data munging "state" into an nfsm_info structure. Each
function now has this structure on its stack, and it and its members
are now passed around so that the macros/functions can work there magic.

this will make removing the nfsm_* macros way easier.

Idea/code picked up from DragonflyBSD.

Tested by krw@@, jacekm@@ and myself.

OK blambert@@.
@
text
@a1792 42
 * Sort the group list in increasing numerical order.
 * (Insertion sort by Chris Torek, who was grossed out by the bubble sort
 *  that used to be here.)
 */
void
nfsrvw_sort(list, num)
        gid_t *list;
        int num;
{
	int i, j;
	gid_t v;

	/* Insertion sort. */
	for (i = 1; i < num; i++) {
		v = list[i];
		/* find correct slot for value v, moving others up */
		for (j = i; --j >= 0 && v < list[j];)
			list[j + 1] = list[j];
		list[j + 1] = v;
	}
}

/*
 * copy credentials making sure that the result can be compared with bcmp().
 */
void
nfsrv_setcred(incred, outcred)
	struct ucred *incred, *outcred;
{
	int i;

	bzero((caddr_t)outcred, sizeof (struct ucred));
	outcred->cr_ref = 1;
	outcred->cr_uid = incred->cr_uid;
	outcred->cr_gid = incred->cr_gid;
	outcred->cr_ngroups = incred->cr_ngroups;
	for (i = 0; i < incred->cr_ngroups; i++)
		outcred->cr_groups[i] = incred->cr_groups[i];
	nfsrvw_sort(outcred->cr_groups, outcred->cr_ngroups);
}

/*
@


1.98
log
@(struct foo *)0 -> NULL, every where I could find it.

OK blambert@@
@
text
@a673 7
#ifdef notdef
			/* Not Yet.. */
			if (uiop->uio_iov->iov_op != NULL)
				(*(uiop->uio_iov->iov_op))
				(mbufcp, uiocp, xfer);
			else
#endif
d1961 1
a1961 1
	struct mbuf *md;
d1963 1
a1963 1
	caddr_t dpos, cp2;
d1966 2
a1967 2
	md = *mp;
	dpos = *dposp;
d2017 2
a2018 2
	*dposp = dpos;
	*mp = md;
@


1.97
log
@Remove the VREF() macro and replaces all instances with a call to verf(),
which is exactly what the macro does.

Macro's that are nothing more then:
#define FUNCTION(arg) function(arg)
are almost always pointless and should go away.

OK blambert@@
Agreed by many.
@
text
@d1234 1
a1234 1
	*retdirp = (struct vnode *)0;
d1351 1
a1351 1
		if (m->m_next == (struct mbuf *)0)
d1509 1
a1509 1
	*vpp = (struct vnode *)0;
@


1.96
log
@Remove unused procnums (NQNFS leftovers) and cleanup.

OK blambert@@ sometime ago
@
text
@d1287 1
a1287 1
	VREF(dp);
@


1.95
log
@retire the nfs rtt log code, this isnt really all that
usefull, and has been disabled for a long long time.
Cleans house a bit.

OK blambert@@
@
text
@a122 3
	NFSPROC_NOOP,
	NFSPROC_NOOP,
	NFSPROC_NOOP,
d152 1
a152 4
	NFSV2PROC_NOOP,
	NFSV2PROC_NOOP,
	NFSV2PROC_NOOP,
	NFSV2PROC_NOOP,
@


1.94
log
@Convert macros to functions to reduce kernel memory usage.

In snaps for a while (way too long, according to deraadt@@)
@
text
@a66 1
#include <nfs/nfsrtt.h>
a515 2
extern struct nfsrtt nfsrtt;

a912 1
	nfsrtt.pos = 0;
@


1.93
log
@Convert a sizeable macro to a much-leaner function. Saves (IIRC) 5k on i386.

In snaps for a while.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.92 2009/01/24 23:30:42 thib Exp $	*/
d1950 22
@


1.92
log
@Use a timespec instead of a time_t for the clients nfsnode
mtime, gives us better granularity, helps with cache consistency.

Idea lifted from NetBSD.

OK blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.91 2009/01/20 18:03:33 blambert Exp $	*/
d1950 66
@


1.91
log
@Start reworking NFS client mbuf handling by creating an interface which
requires well-formed mbuf chains to work. Existing function name is now
a wrapper to this interface. Much, much more work to follow which will
build on this.

Truly change we can believe in.

ok thib@@, who would have preferred this in two commits, but I'm impatient :)

testing on multiple arches (i386, arm, amd64, and sparc64 at least) by many,
thanks to all who did so
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.90 2009/01/13 19:44:20 grange Exp $	*/
d1066 1
a1066 1
		np->n_mtime = mtime.tv_sec;
d1158 1
a1158 1
	int tenthage = (time_second - np->n_mtime) / 10;
@


1.90
log
@Trivial lvalue abuse fixes, no binary changes.
ok millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.89 2008/12/24 02:48:36 thib Exp $	*/
d564 1
a564 2
nfsm_rpchead(struct nfsreq *req, struct ucred *cr, int auth_type,
    struct mbuf *mrest, int mrest_len)
d574 1
a574 1
	 * authorization methods need to figure out there own sizes
d577 1
a577 1
	MGETHDR(mb, M_WAIT, MT_DATA);
d642 1
a642 2
	mb->m_next = mrest;
	mb->m_pkthdr.len = authsiz + 10 * NFSX_UNSIGNED + mrest_len;
a643 1
	req->r_mreq = mb;
@


1.89
log
@fix a typo made in last commit, also slightly better wording for
another comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.88 2008/12/24 02:43:52 thib Exp $	*/
d708 2
a709 1
			(char *)uiop->uio_iov->iov_base += uiosiz;
@


1.88
log
@Replace the TRUE/FALSE defines with 1/0 respectively. This doesn't
hurt readability and it was just plain annoying seeing them defined
in every other .c file.

OK blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.87 2008/11/24 20:14:52 thib Exp $	*/
d1561 1
a1561 1
 * if they are the same host, of there is any doubt it returns 0.
d1854 1
a1854 1
 * If full is true, set all fields, otherwise just set mode and time fields
@


1.87
log
@use the shiny new nitems macro
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.86 2008/08/25 09:26:17 pedro Exp $	*/
d928 2
a929 2
	nfs_true = txdr_unsigned(TRUE);
	nfs_false = txdr_unsigned(FALSE);
d1290 1
a1290 1
	error = nfsrv_fhtovp(fhp, FALSE, &dp, ndp->ni_cnd.cn_cred, slp,
d1560 2
a1561 3
 * This function compares two net addresses by family and returns TRUE
 * if they are the same host.
 * If there is any doubt, return FALSE.
@


1.86
log
@Correctly invalidate attribute cache entries in case the vnode mode
changes, okay beck@@, tedu@@ and thib@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.85 2008/08/08 20:44:38 blambert Exp $	*/
d1807 1
a1807 1
	if (err <= sizeof(nfsrv_v2errmap)/sizeof(nfsrv_v2errmap[0]))
@


1.85
log
@After beck@@ changed the way nfsiod's are notified of work, the
nfs_iodwant array became unused. Garbage collect and free up
a few bytes.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.84 2008/06/15 04:03:40 thib Exp $	*/
a1071 1
	vap->va_mode = (vmode & 07777);
d1081 1
a1081 1
	    vmode != vap->va_mode))
d1083 2
@


1.84
log
@unroll the NFSMADV() macro and nuke it

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.83 2008/06/14 00:26:13 thib Exp $	*/
a516 1
extern struct proc *nfs_iodwant[NFS_MAXASYNCDAEMON];
a955 5
	int i;

	/* Ensure async daemons disabled */
	for (i = 0; i < NFS_MAXASYNCDAEMON; i++)
		nfs_iodwant[i] = (struct proc *)0;
@


1.83
log
@use nfsm_padlen() where appropriate;

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.82 2008/06/13 22:11:32 blambert Exp $	*/
d869 1
a869 1
				NFSMADV(mp2, xfer);
@


1.82
log
@Kill one-liner macro which obfuscated mbuf pointer assignment.

Rescue nfsm_reqhead macro name and rename nfsm_reqh.

End of one-liners from nfsm_subs.h.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.81 2008/06/13 17:24:13 thib Exp $	*/
d669 1
a669 1
	rem = nfsm_rndup(siz)-siz;
d1283 1
a1283 1
	len = nfsm_rndup(len)-len;
@


1.81
log
@remove rpc_auth_kerb variable, its now unused...
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.80 2008/06/13 03:49:26 blambert Exp $	*/
d528 1
a528 3
nfsm_reqh(vp, procid, hsiz)
	struct vnode *vp;
	u_long procid;
@


1.80
log
@Replace one-line macro which only obfuscated the fact that
the function it was named after took 4 arguments instead of 2.

"get it in; get it in; get it in" thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.79 2008/06/12 20:24:06 blambert Exp $	*/
d85 1
a85 2
	rpc_mismatch, rpc_auth_unix, rpc_msgaccepted,
	rpc_auth_kerb;
a929 1
	rpc_auth_kerb = txdr_unsigned(RPCAUTH_KERB4);
@


1.79
log
@Remove now-vestigial bpos pointer from NFS. For building outgoing
NFS mbufs, mbufs now contain all their internal buffer state internally,
the way god intended.

ok thib@@

testing johan@@ (and possibly merdely@@; this diff's been around for a bit...)
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.78 2008/06/11 08:11:33 thib Exp $	*/
d1438 1
a1438 1
	nfsm_srvpostopattr(nfsd, after_ret, after_vap, mbp);
d1442 1
a1442 1
nfsm_srvpostopattr(nfsd, after_ret, after_vap, mbp)
@


1.78
log
@return an XDR'rd xid from nfs_get_xid() and kill the nfs_xid global
variable;

ok & feedback deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.77 2008/06/10 22:59:09 thib Exp $	*/
d529 1
a529 1
nfsm_reqh(vp, procid, hsiz, bposp)
a532 1
	caddr_t *bposp;
a534 1
	caddr_t bpos;
a539 1
	bpos = mtod(mb, caddr_t);
a541 1
	*bposp = bpos;
a572 1
	caddr_t		bpos;
a608 1
	bpos = mtod(mb, caddr_t);
d611 1
a611 1
	tl = nfsm_build(&mb, 6 * NFSX_UNSIGNED, &bpos);
d629 1
a629 1
		tl = nfsm_build(&mb, auth_len + 4 * NFSX_UNSIGNED, &bpos);
d732 1
a732 1
nfsm_uiotombuf(struct mbuf **mp, struct uio *uiop, size_t len, caddr_t *bposp)
a770 1
	*bposp = mb_offset(mb);
d778 1
a778 1
nfsm_buftombuf(struct mbuf **mp, void *buf, size_t len, caddr_t *bposp)
d792 1
a792 1
	nfsm_uiotombuf(mp, &io, len, bposp);
d799 1
a799 1
nfsm_strtombuf(struct mbuf **mp, void *str, size_t len, caddr_t *bposp)
d818 1
a818 1
	nfsm_uiotombuf(mp, &io, io.uio_resid, bposp);
d1414 1
a1414 1
nfsm_srvwcc(nfsd, before_ret, before_vap, after_ret, after_vap, mbp, bposp)
a1420 1
	char **bposp;
a1422 1
	char *bpos = *bposp;
d1426 1
a1426 1
		tl = nfsm_build(&mb, NFSX_UNSIGNED, &bpos);
d1429 1
a1429 1
		tl = nfsm_build(&mb, 7 * NFSX_UNSIGNED, &bpos);
a1436 1
	*bposp = bpos;
d1438 1
a1438 1
	nfsm_srvpostopattr(nfsd, after_ret, after_vap, mbp, bposp);
d1442 1
a1442 1
nfsm_srvpostopattr(nfsd, after_ret, after_vap, mbp, bposp)
a1446 1
	char **bposp;
a1448 1
	char *bpos = *bposp;
d1453 1
a1453 1
		tl = nfsm_build(&mb, NFSX_UNSIGNED, &bpos);
d1456 1
a1456 1
		tl = nfsm_build(&mb, NFSX_UNSIGNED + NFSX_V3FATTR, &bpos);
a1461 1
	*bposp = bpos;
d1867 1
a1867 1
nfsm_v3attrbuild(struct mbuf **mp, struct vattr *a, int full, caddr_t *bposp)
a1870 1
	caddr_t bpos;
a1872 1
	bpos = *bposp;
d1875 1
a1875 1
		tl = nfsm_build(&mb, 2 * NFSX_UNSIGNED, &bpos);
d1879 1
a1879 1
		tl = nfsm_build(&mb, NFSX_UNSIGNED, &bpos);
d1883 1
a1883 1
		tl = nfsm_build(&mb, 2 * NFSX_UNSIGNED, &bpos);
d1887 1
a1887 1
		tl = nfsm_build(&mb, NFSX_UNSIGNED, &bpos);
d1891 1
a1891 1
		tl = nfsm_build(&mb, 2 * NFSX_UNSIGNED, &bpos);
d1895 1
a1895 1
		tl = nfsm_build(&mb, NFSX_UNSIGNED, &bpos);
d1899 1
a1899 1
		tl = nfsm_build(&mb, 3 * NFSX_UNSIGNED, &bpos);
d1903 1
a1903 1
		tl = nfsm_build(&mb, NFSX_UNSIGNED, &bpos);
d1908 1
a1908 1
			tl = nfsm_build(&mb, 3 * NFSX_UNSIGNED, &bpos);
d1912 1
a1912 1
			tl = nfsm_build(&mb, NFSX_UNSIGNED, &bpos);
d1916 1
a1916 1
		tl = nfsm_build(&mb, NFSX_UNSIGNED, &bpos);
d1921 1
a1921 1
			tl = nfsm_build(&mb, 3 * NFSX_UNSIGNED, &bpos);
d1925 1
a1925 1
			tl = nfsm_build(&mb, NFSX_UNSIGNED, &bpos);
d1929 1
a1929 1
		tl = nfsm_build(&mb, NFSX_UNSIGNED, &bpos);
a1932 1
	*bposp = bpos;
d1940 1
a1940 1
nfsm_build(struct mbuf **mp, u_int len, caddr_t *bposp)
d1946 1
a1946 1
	bpos = *bposp;
a1958 1
	*bposp = bpos + len;
@


1.77
log
@
o Avoid putting duplicate entries into the name cache,
  add a function to handle cache_enter()'s for us since
  we need to update the appropriate timestamps so we don't
  miss on lookup;
o Do not purge the dvp in nfs_rmdir(), since there's no need;
o cache the new entry created in nfs_mkdir();
o Do caching of the access modes, this drastically reduces the
  amount of over the wire access RPCs we do in the NFSv3 case.

This diff was written by Pedro Martelletto, sometime in 2004.
A lot of people have been running with it at one time or another,
this includes at least markus and matthieu.

OK deraadt@@, blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.76 2008/06/09 22:49:15 djm Exp $	*/
a89 1
static u_int32_t nfs_xid = 0;
d550 1
a550 1
 * Return an unpredictable XID.
d562 1
a562 1
	return idgen32(&nfs_xid_ctx);
d620 1
a620 3
	nfs_xid = nfs_get_xid();

	*tl++ = req->r_xid = txdr_unsigned(nfs_xid);
@


1.76
log
@nfsm_get_xid() => nfs_get_xid() after thib@@ informed me that the
nfsm_* functions are for mbufs
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.75 2008/06/09 22:47:42 djm Exp $	*/
d1018 2
d1096 9
d1146 1
@


1.75
log
@Introduce a facility to generate unpredictable 32 bit numbers with
near maximal (2^32) cycle times. These are useful for network
IDs in cases where there are negative consequences to ID prediction
and/or reuse.

Use the idgen32() functions to generate IPv6 IDs and NFS client/server
XIDs.

Pseudorandom permutation code in crypto/idgen.c based on public
domain skip32.c from Greg Rose.

feedback & ok thib@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.74 2008/04/22 18:53:34 thib Exp $	*/
d554 1
a554 1
nfsm_get_xid(void)
d621 1
a621 1
	nfs_xid = nfsm_get_xid();
@


1.74
log
@remove the "kerbflag" argument from nfsrv_fhtovp() and nfs_namei()
(the latter only had it to pass it to nfsrv_fhtovp()).

appropriate cleanup also;

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.73 2008/04/19 19:38:00 thib Exp $	*/
d75 1
d551 16
a577 1
	u_int32_t	xid;
d621 1
a621 6
	do {
		while ((xid = arc4random() & 0xff) == 0)
			;
		nfs_xid += xid;
	} while (nfs_xid == 0);

@


1.73
log
@in nfsm_reqh(), only allocate an mbuf cluster if the
len exceeds MLEN, not MINCLSIZE; inspired by a similar
commit from damien.

ok damien@@, blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.72 2008/04/18 06:42:20 djm Exp $	*/
d1224 1
a1224 1
nfs_namei(ndp, fhp, len, slp, nam, mdp, dposp, retdirp, p, kerbflag)
a1233 1
	int kerbflag;
d1287 1
a1287 1
	    nam, &rdonly, kerbflag);
d1507 1
a1507 1
nfsrv_fhtovp(fhp, lockflag, vpp, cred, slp, nam, rdonlyp, kerbflag)
a1514 1
	int kerbflag;
d1543 2
a1544 12
	/*
	 * Check/setup credentials.
	 */
	if (exflags & MNT_EXKERB) {
		if (!kerbflag) {
			vput(*vpp);
			return (NFSERR_AUTHERR | AUTH_TOOWEAK);
		}
	} else if (kerbflag) {
		vput(*vpp);
		return (NFSERR_AUTHERR | AUTH_TOOWEAK);
	} else if (cred->cr_uid == 0 || (exflags & MNT_EXPORTANON)) {
@


1.72
log
@use arc4random_uniform() for random number requests that are not a
power of two.

use arc4random_bytes() when requesting more than a word of PRNG
output.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.71 2008/04/16 20:02:46 damien Exp $	*/
d539 1
a539 1
	if (hsiz >= MINCLSIZE)
@


1.71
log
@more efficient use of mbufs in nfsm_uiotombuf().
allocate a mbuf cluster only if length is greater than MLEN
instead of MINCLSIZE.

ok blambert@@, thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.70 2008/04/14 13:46:13 blambert Exp $	*/
d606 1
a606 1
		while ((xid = arc4random() % 256) == 0)
@


1.70
log
@Rework NFS mbuf write routines:

nfsm_uiotombuf():
- no meaningful return, function becomes void
- replace frankensteined uiomove/MGET with actual call to uiomove

nfsm_strtmbuf():
- no meaningful return, becomes void
- rename and reorder parameters to be consistent with other functions
- becomes wrapper to nfsm_uiotombuf

nfsm_buftombuf():
- new function; unused but slated for future use
- wrapper to nfsm_uiotombuf

As a bonus, making these functions void removes much unneeded code and
garbage collects `magic' variable t2 which was only used (invisibly)
by the macros from nfsm_subs.h

Preps the way for removing much more NFS goo...

testing by myself, thib@@ and merdely@@
ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.69 2008/01/06 17:38:23 blambert Exp $	*/
d750 1
a750 1
			if (len > MINCLSIZE)
@


1.69
log
@More NFS-related kernel shrinkage...

When you use a macro ~200 times, it tends to bloat your code, so make a
function out of it.

Shaves ~8.5 kB from my kernel.

ok thib@@, "looks good" krw@@

In snaps for 1+ week with no negative reports.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.68 2007/12/13 18:32:55 blambert Exp $	*/
d727 1
a727 2
 * copies a uio scatter/gather list to an mbuf chain.
 * NOTE: can ony handle iovcnt == 1
d729 2
a730 6
int
nfsm_uiotombuf(uiop, mq, siz, bpos)
	struct uio *uiop;
	struct mbuf **mq;
	int siz;
	caddr_t *bpos;
d732 6
a737 10
	char *uiocp;
	struct mbuf *mp, *mp2;
	int xfer, left, mlen;
	int uiosiz, clflg, rem;
	char *cp;

#ifdef DIAGNOSTIC
	if (uiop->uio_iovcnt != 1)
		panic("nfsm_uiotombuf: iovcnt != 1");
#endif
d739 16
a754 40
	if (siz > MLEN)		/* or should it >= MCLBYTES ?? */
		clflg = 1;
	else
		clflg = 0;
	rem = nfsm_rndup(siz)-siz;
	mp = mp2 = *mq;
	while (siz > 0) {
		left = uiop->uio_iov->iov_len;
		uiocp = uiop->uio_iov->iov_base;
		if (left > siz)
			left = siz;
		uiosiz = left;
		while (left > 0) {
			mlen = M_TRAILINGSPACE(mp);
			if (mlen == 0) {
				MGET(mp, M_WAIT, MT_DATA);
				if (clflg)
					MCLGET(mp, M_WAIT);
				mp->m_len = 0;
				mp2->m_next = mp;
				mp2 = mp;
				mlen = M_TRAILINGSPACE(mp);
			}
			xfer = (left > mlen) ? mlen : left;
#ifdef notdef
			/* Not Yet.. */
			if (uiop->uio_iov->iov_op != NULL)
				(*(uiop->uio_iov->iov_op))
				(uiocp, mtod(mp, caddr_t)+mp->m_len, xfer);
			else
#endif
			if (uiop->uio_segflg == UIO_SYSSPACE)
				bcopy(uiocp, mtod(mp, caddr_t)+mp->m_len, xfer);
			else
				copyin(uiocp, mtod(mp, caddr_t)+mp->m_len, xfer);
			mp->m_len += xfer;
			left -= xfer;
			uiocp += xfer;
			uiop->uio_offset += xfer;
			uiop->uio_resid -= xfer;
a755 3
		(char *)uiop->uio_iov->iov_base += uiosiz;
		uiop->uio_iov->iov_len -= uiosiz;
		siz -= uiosiz;
d757 7
a763 5
	if (rem > 0) {
		if (rem > M_TRAILINGSPACE(mp)) {
			MGET(mp, M_WAIT, MT_DATA);
			mp->m_len = 0;
			mp2->m_next = mp;
d765 53
a817 9
		cp = mtod(mp, caddr_t)+mp->m_len;
		for (left = 0; left < rem; left++)
			*cp++ = '\0';
		mp->m_len += rem;
		*bpos = cp;
	} else
		*bpos = mtod(mp, caddr_t)+mp->m_len;
	*mq = mp;
	return (0);
a909 66
	return (0);
}

/*
 * Copy a string into mbufs for the hard cases...
 */
int
nfsm_strtmbuf(mb, bpos, cp, siz)
	struct mbuf **mb;
	char **bpos;
	char *cp;
	long siz;
{
	struct mbuf *m1 = NULL, *m2;
	long left, xfer, len, tlen;
	u_int32_t *tl;
	int putsize;

	putsize = 1;
	m2 = *mb;
	left = M_TRAILINGSPACE(m2);
	if (left > 0) {
		tl = ((u_int32_t *)(*bpos));
		*tl++ = txdr_unsigned(siz);
		putsize = 0;
		left -= NFSX_UNSIGNED;
		m2->m_len += NFSX_UNSIGNED;
		if (left > 0) {
			bcopy(cp, (caddr_t) tl, left);
			siz -= left;
			cp += left;
			m2->m_len += left;
			left = 0;
		}
	}
	/* Loop around adding mbufs */
	while (siz > 0) {
		MGET(m1, M_WAIT, MT_DATA);
		if (siz > MLEN)
			MCLGET(m1, M_WAIT);
		m1->m_len = NFSMSIZ(m1);
		m2->m_next = m1;
		m2 = m1;
		tl = mtod(m1, u_int32_t *);
		tlen = 0;
		if (putsize) {
			*tl++ = txdr_unsigned(siz);
			m1->m_len -= NFSX_UNSIGNED;
			tlen = NFSX_UNSIGNED;
			putsize = 0;
		}
		if (siz < m1->m_len) {
			len = nfsm_rndup(siz);
			xfer = siz;
			if (xfer < len)
				*(tl+(xfer>>2)) = 0;
		} else {
			xfer = len = m1->m_len;
		}
		bcopy(cp, (caddr_t) tl, xfer);
		m1->m_len = len+tlen;
		siz -= xfer;
		cp += xfer;
	}
	*mb = m1;
	*bpos = mtod(m1, caddr_t)+m1->m_len;
@


1.68
log
@convert massive (expanded to 150+ lines) nfsm_v3attr macro to a function

shaves an insane (~8K) amount from an i386 kernel

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.67 2007/11/28 19:27:43 thib Exp $	*/
d559 1
a559 1
	struct mbuf	*mb, *mb2;
d602 1
a602 1
	nfsm_build(tl, u_int32_t *, 6 * NFSX_UNSIGNED);
d627 1
a627 1
		nfsm_build(tl, u_int32_t *, auth_len + 4 * NFSX_UNSIGNED);
d1467 1
a1467 1
	struct mbuf *mb = *mbp, *mb2;
d1472 1
a1472 1
		nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED);
d1475 1
a1475 1
		nfsm_build(tl, u_int32_t *, 7 * NFSX_UNSIGNED);
d1496 1
a1496 1
	struct mbuf *mb = *mbp, *mb2;
d1502 1
a1502 1
		nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED);
d1505 1
a1505 1
		nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED + NFSX_V3FATTR);
d1930 1
a1930 1
	struct mbuf *mb, *mb2;
d1938 1
a1938 1
		nfsm_build(tl, u_int32_t *, 2 * NFSX_UNSIGNED);
d1942 1
a1942 1
		nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED);
d1946 1
a1946 1
		nfsm_build(tl, u_int32_t *, 2 * NFSX_UNSIGNED);
d1950 1
a1950 1
		nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED);
d1954 1
a1954 1
		nfsm_build(tl, u_int32_t *, 2 * NFSX_UNSIGNED);
d1958 1
a1958 1
		nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED);
d1962 1
a1962 1
		nfsm_build(tl, u_int32_t *, 3 * NFSX_UNSIGNED);
d1966 1
a1966 1
		nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED);
d1971 1
a1971 1
			nfsm_build(tl, u_int32_t *, 3 * NFSX_UNSIGNED);
d1975 1
a1975 1
			nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED);
d1979 1
a1979 1
		nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED);
d1984 1
a1984 1
			nfsm_build(tl, u_int32_t *, 3 * NFSX_UNSIGNED);
d1988 1
a1988 1
			nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED);
d1992 1
a1992 1
		nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED);
d1998 29
@


1.67
log
@fill the va_blocksize with something a litte saner,
make stat(2) return st_blocksize thats a bit closer
to reality.

From NetBSD;

OK art@@, beck@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.66 2007/11/05 21:18:56 thib Exp $	*/
d1922 76
@


1.66
log
@deinline nfs_attrtimeo(); and remove some associated
#ifdef goo.

ok krw@@, blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.65 2007/10/13 17:38:43 thib Exp $	*/
d1139 12
a1155 1
		vap->va_blocksize = NFS_FABLKSIZE;
a1167 1
		vap->va_blocksize = fxdr_unsigned(int32_t, fp->fa2_blocksize);
@


1.65
log
@Remove alot of dead kerberos code (add sane comments too).

Cleanup and partly redo the way we create the RPC header, by having
nfsm_rpchead() do a bit more work. Right now this is pretty RPCAUTH_UNIX
centric, but since it is the only auth method we support right now thats
fine.

Make sure we can never generate a zero xid, thats forbidden by the RFC.

Misc cleanup.

tested by a few.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.64 2007/10/08 17:39:52 deraadt Exp $	*/
a75 6
#ifdef __GNUC__
#define INLINE __inline
#else
#define INLINE
#endif

d1196 1
a1196 1
INLINE int
@


1.64
log
@shrink nfsrv_v2errmap[] and check table size more carefully to avoid
dependency on ELAST; ok miod thib
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.63 2007/10/07 16:30:26 miod Exp $	*/
a95 1
static u_int32_t nfs_xid_touched = 0;
d557 3
a559 3
 * The authorization string argument is only used when the credentials
 * come from outside of the kernel.
 * Returns the head of the mbuf list.
d561 3
a563 15
struct mbuf *
nfsm_rpchead(cr, nmflag, procid, auth_type, auth_len, auth_str, verf_len,
	verf_str, mrest, mrest_len, mbp, xidp)
	struct ucred *cr;
	int nmflag;
	int procid;
	int auth_type;
	int auth_len;
	char *auth_str;
	int verf_len;
	char *verf_str;
	struct mbuf *mrest;
	int mrest_len;
	struct mbuf **mbp;
	u_int32_t *xidp;
d565 7
a571 6
	struct mbuf *mb;
	u_int32_t *tl;
	caddr_t bpos;
	int i;
	struct mbuf *mreq, *mb2;
	int siz, grpsiz, authsiz;
d573 5
a577 1
	authsiz = nfsm_rndup(auth_len);
d579 21
a599 3
	if ((authsiz + 10 * NFSX_UNSIGNED) >= MINCLSIZE) {
		MCLGET(mb, M_WAIT);
	} else if ((authsiz + 10 * NFSX_UNSIGNED) < MHLEN) {
d601 1
a601 2
	} else {
		MH_ALIGN(mb, 8 * NFSX_UNSIGNED);
d603 1
a604 1
	mreq = mb;
d607 2
a608 4
	/*
	 * First the RPC header.
	 */
	nfsm_build(tl, u_int32_t *, 8 * NFSX_UNSIGNED);
d611 5
d617 2
a618 10
	if ((nfs_xid == 0) && (nfs_xid_touched == 0)) {
		nfs_xid = arc4random();
		nfs_xid_touched = 1;
	} else {
		while ((*xidp = arc4random() % 256) == 0)
			;
		nfs_xid += *xidp;
	}
	    
	*tl++ = *xidp = txdr_unsigned(nfs_xid);
d621 2
a622 2
	*tl++ = txdr_unsigned(NFS_PROG);
	if (nmflag & NFSMNT_NFSV3)
d624 2
a625 1
	else
d627 2
a628 4
	if (nmflag & NFSMNT_NFSV3)
		*tl++ = txdr_unsigned(procid);
	else
		*tl++ = txdr_unsigned(nfsv2_procid[procid]);
d630 1
a630 5
	/*
	 * And then the authorization cred.
	 */
	*tl++ = txdr_unsigned(auth_type);
	*tl = txdr_unsigned(authsiz);
d633 6
a638 2
		nfsm_build(tl, u_int32_t *, auth_len);
		*tl++ = 0;		/* stamp ?? */
d642 2
a643 3
		grpsiz = (auth_len >> 2) - 5;
		*tl++ = txdr_unsigned(grpsiz);
		for (i = 0; i < grpsiz; i++)
d645 1
a645 59
		break;
	case RPCAUTH_KERB4:
		siz = auth_len;
		while (siz > 0) {
			if (M_TRAILINGSPACE(mb) == 0) {
				MGET(mb2, M_WAIT, MT_DATA);
				if (siz >= MINCLSIZE)
					MCLGET(mb2, M_WAIT);
				mb->m_next = mb2;
				mb = mb2;
				mb->m_len = 0;
				bpos = mtod(mb, caddr_t);
			}
			i = min(siz, M_TRAILINGSPACE(mb));
			bcopy(auth_str, bpos, i);
			mb->m_len += i;
			auth_str += i;
			bpos += i;
			siz -= i;
		}
		if ((siz = (nfsm_rndup(auth_len) - auth_len)) > 0) {
			for (i = 0; i < siz; i++)
				*bpos++ = '\0';
			mb->m_len += siz;
		}
		break;
	};

	/*
	 * And the verifier...
	 */
	nfsm_build(tl, u_int32_t *, 2 * NFSX_UNSIGNED);
	if (verf_str) {
		*tl++ = txdr_unsigned(RPCAUTH_KERB4);
		*tl = txdr_unsigned(verf_len);
		siz = verf_len;
		while (siz > 0) {
			if (M_TRAILINGSPACE(mb) == 0) {
				MGET(mb2, M_WAIT, MT_DATA);
				if (siz >= MINCLSIZE)
					MCLGET(mb2, M_WAIT);
				mb->m_next = mb2;
				mb = mb2;
				mb->m_len = 0;
				bpos = mtod(mb, caddr_t);
			}
			i = min(siz, M_TRAILINGSPACE(mb));
			bcopy(verf_str, bpos, i);
			mb->m_len += i;
			verf_str += i;
			bpos += i;
			siz -= i;
		}
		if ((siz = (nfsm_rndup(verf_len) - verf_len)) > 0) {
			for (i = 0; i < siz; i++)
				*bpos++ = '\0';
			mb->m_len += siz;
		}
	} else {
d648 1
d650 1
d652 3
a654 4
	mreq->m_pkthdr.len = authsiz + 10 * NFSX_UNSIGNED + mrest_len;
	mreq->m_pkthdr.rcvif = (struct ifnet *)0;
	*mbp = mb;
	return (mreq);
@


1.63
log
@Make sure nfsrv_v2errmap[] really contains ELAST initialized values.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.62 2007/09/20 12:54:31 thib Exp $	*/
d175 1
a175 1
static u_char nfsrv_v2errmap[ELAST] = {
d189 2
a190 5
  NFSERR_NOTEMPTY, NFSERR_IO,	NFSERR_IO,	NFSERR_DQUOT,	NFSERR_STALE,
  NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,
  NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,
  NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,
  NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO
d1928 1
a1928 1
	if (err <= ELAST)
@


1.62
log
@MALLOC/FREE -> malloc/free + M_ZERO.
Uneeded includes and casts...

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.61 2007/04/19 14:46:44 thib Exp $	*/
d192 2
a193 1
  NFSERR_IO,
@


1.61
log
@Replace the nfskevq_lock lockmgr lock with rwlock.
Replace nfs_kqinit() wich just calls lockinit with
RWLOCK_INITALIZER. Assorted cleanup.

ok tedu@@
"reads good" art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.60 2007/04/13 10:01:35 thib Exp $	*/
a54 1
#include <sys/malloc.h>
@


1.60
log
@remove some unneeded externs and unused declerations.
There's no need to extern stuff thats declared in the same file.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.59 2006/12/29 13:04:37 pedro Exp $	*/
a1072 4

#ifdef NFSCLIENT
	nfs_kqinit();
#endif	
@


1.59
log
@Avoid void * arithmetic, okay deraadt@@, suggestions from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.58 2006/11/01 00:12:35 thib Exp $	*/
a529 7
extern struct nfsstats nfsstats;
extern nfstype nfsv2_type[9];
extern nfstype nfsv3_type[9];
extern struct nfsnodehashhead *nfsnodehashtbl;
extern u_long nfsnodehash;

LIST_HEAD(nfsnodehashhead, nfsnode);
@


1.58
log
@move the declaration of nfsstats from nfs_bio.c to
nfs_subs.c so it gets pulled in for NFSSERVER only
kernels.

ok deraadt@@,krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.57 2006/05/29 16:49:42 avsm Exp $	*/
d781 1
a781 1
			uiop->uio_iov->iov_base += uiosiz;
d860 1
a860 1
		uiop->uio_iov->iov_base += uiosiz;
@


1.57
log
@revert vfs.nfs.privport sysctl, broke a few architectures
requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.55 2005/10/19 16:50:46 pedro Exp $	*/
d105 1
@


1.56
log
@Add support for NFS mounts to be from non-reserved ports:

- new sysctl vfs.nfs.privport to require NFS mount requests to be on
reserved ports when set to 1 (the default).
- mountd now automatically sets the sysctl depending on the -n flag.
- add mountd_flags to rc.conf to enable the -n flag at boot.
deraadt@@ ok
@
text
@a104 1
int nfs_privport = 1;
d1657 6
a1662 9
	if (nfs_privport) {
		saddr = mtod(nam, struct sockaddr_in *);
		if (saddr->sin_family == AF_INET &&
		    (ntohs(saddr->sin_port) >= IPPORT_RESERVED ||
		    (slp->ns_so->so_type == SOCK_STREAM &&
		    ntohs(saddr->sin_port) == 20))) {
			vput(*vpp);
			return (NFSERR_AUTHERR | AUTH_TOOWEAK);
		}
@


1.55
log
@Remove v_vnlock from struct vnode, okay krw@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.54 2005/04/02 01:00:38 mickey Exp $	*/
d105 1
d1658 9
a1666 6
	saddr = mtod(nam, struct sockaddr_in *);
	if (saddr->sin_family == AF_INET &&
	    (ntohs(saddr->sin_port) >= IPPORT_RESERVED ||
	    (slp->ns_so->so_type == SOCK_STREAM && ntohs(saddr->sin_port) == 20))) {
		vput(*vpp);
		return (NFSERR_AUTHERR | AUTH_TOOWEAK);
@


1.54
log
@use pool for struct nfsreq; tedu@@ pedro@@ ok and testing by mark patruck <mark@@2ls4agd.net> on several archs
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.53 2005/03/31 21:47:49 deraadt Exp $	*/
a1192 2
				nvp->v_vnlock = vp->v_vnlock;
				vp->v_vnlock = NULL;
@


1.53
log
@re-commit marius commit:
> fix preposterous time warnings in the nfs client; caused by false hits
> in the attribute cache
> based on original fix by pedro@@, ok pedro@@, tedu@@; testing kettenis@@
was backed out because too close to release
put back in now, since tree is unlocked.  unfortunately it appears that even
after MANY MAILS ON THIS SUBJECT, NOONE HAS DONE THIS.  WTF?  Noone wants
to FINISH jobs anymore?
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.51 2005/01/24 00:14:40 marius Exp $	*/
d537 2
d1068 3
@


1.52
log
@backout nfs_subs.c rev1.51 nfs_vfsops.c rev1.54:
fix preposterous time warnings in the nfs client; caused by false hits
in the attribute cache

too close to release, save for immediately after unlock
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.50 2004/08/03 17:11:48 marius Exp $	*/
d1306 2
a1307 1
	if ((time_second - np->n_attrstamp) >= nfs_attrtimeo(np)) {
@


1.51
log
@fix preposterous time warnings in the nfs client; caused by false hits
in the attribute cache

based on original fix by pedro@@, ok pedro@@, tedu@@; testing kettenis@@
@
text
@d1306 1
a1306 2
	if (np->n_attrstamp == 0 ||
	    (time_second - np->n_attrstamp) >= nfs_attrtimeo(np)) {
@


1.50
log
@NFS commit coalescion: instead of sending a commit for each block, coalesce
these into larger ranges wherever possible.

this should speed up NFS writes quite a bit.

ok art@@ millert@@ pedro@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.49 2004/08/03 06:58:40 miod Exp $	*/
d1306 2
a1307 1
	if ((time_second - np->n_attrstamp) >= nfs_attrtimeo(np)) {
@


1.49
log
@When accessing device nodes over nfs, do not trim major and minor numbers
to 8 bits only; found the hard way by henning@@.

Ok deraadt@@ marius@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.48 2004/07/21 17:30:55 marius Exp $	*/
d1745 166
@


1.48
log
@kqueue support for NFS, adapted from netbsd.

ok art@@ pedro@@, "get it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.47 2004/07/16 15:01:51 henning Exp $	*/
d1142 2
a1143 2
		rdev = makedev(fxdr_unsigned(u_char, fp->fa3_rdev.specdata1),
			fxdr_unsigned(u_char, fp->fa3_rdev.specdata2));
@


1.47
log
@kill netiso stuff here as well, millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.46 2004/07/13 21:04:29 millert Exp $	*/
d1074 4
@


1.46
log
@Change mode_t and nlink_t from 16bit to 32bit.  This allows us to
use mode_t in syscalls.master and to use mode_t in more places in
the kernel.  It also makes lint much more useful on kernel code.

I've also added a placeholder for st_birthtime to make a UFS2 import
easier at some future date.

Requested by and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.45 2004/06/21 23:50:38 tholo Exp $	*/
a73 3
#ifdef ISO
#include <netiso/iso.h>
#endif
a1706 15
#ifdef ISO
	case AF_ISO:
	    {
		struct sockaddr_iso *isoaddr1, *isoaddr2;

		isoaddr1 = mtod(nam, struct sockaddr_iso *);
		isoaddr2 = mtod(haddr->had_nam, struct sockaddr_iso *);
		if (isoaddr1->siso_family == AF_ISO &&
		    isoaddr1->siso_nlen > 0 &&
		    isoaddr1->siso_nlen == isoaddr2->siso_nlen &&
		    SAME_ISOADDR(isoaddr1, isoaddr2))
			return (1);
		break;
	    }
#endif	/* ISO */
@


1.45
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.44 2004/05/14 04:00:34 tedu Exp $	*/
d1127 1
a1127 1
	u_short vmode;
d1140 1
a1140 1
		vmode = fxdr_unsigned(u_short, fp->fa_mode);
d1146 1
a1146 1
		vmode = fxdr_unsigned(u_short, fp->fa_mode);
d1210 1
a1210 1
		vap->va_nlink = fxdr_unsigned(u_short, fp->fa_nlink);
d1223 1
a1223 1
		vap->va_nlink = fxdr_unsigned(u_short, fp->fa_nlink);
@


1.44
log
@use pool for namei pathbuf.  testing ok millert@@ tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.43 2003/06/02 23:28:19 millert Exp $	*/
d1253 1
a1253 1
	np->n_attrstamp = time.tv_sec;
d1272 1
a1272 1
	int tenthage = (time.tv_sec - np->n_mtime) / 10;
d1305 1
a1305 1
	if ((time.tv_sec - np->n_attrstamp) >= nfs_attrtimeo(np)) {
@


1.43
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.42 2002/03/14 01:27:13 millert Exp $	*/
d56 1
d1359 1
a1359 1
	MALLOC(cnp->cn_pnbuf, char *, len + 1, M_NAMEI, M_WAITOK);
d1446 1
a1446 1
	FREE(cnp->cn_pnbuf, M_NAMEI);
@


1.42
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.41 2002/02/10 22:02:05 nate Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.41
log
@theo doesn't like this code
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.40 2002/01/16 21:51:16 ericj Exp $	*/
d89 1
a89 1
int	nfs_attrtimeo __P((struct nfsnode *np));
d1122 1
a1122 1
	extern int (**spec_nfsv2nodeop_p) __P((void *));
d1176 1
a1176 1
			extern int (**fifo_nfsv2nodeop_p) __P((void *));
@


1.40
log
@
use queue.h macro's
remove register
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.39 2002/01/11 01:20:56 nate Exp $	*/
d1657 1
a1657 1
	    ((ntohs(saddr->sin_port) >= IPPORT_RESERVED && !nfs_norsvport) ||
@


1.39
log
@Add a new sysctl that removes the requirement for reserved ports to be
used by the nfs server.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.38 2001/12/19 08:58:06 art Exp $	*/
d555 2
a556 2
	register struct mbuf *mb;
	register caddr_t bpos;
d578 1
a578 1
	register struct ucred *cr;
d591 4
a594 4
	register struct mbuf *mb;
	register u_int32_t *tl;
	register caddr_t bpos;
	register int i;
d731 1
a731 1
	register struct uio *uiop;
d735 3
a737 3
	register char *mbufcp, *uiocp;
	register int xfer, left, len;
	register struct mbuf *mp;
d806 1
a806 1
	register struct uio *uiop;
d811 3
a813 3
	register char *uiocp;
	register struct mbuf *mp, *mp2;
	register int xfer, left, mlen;
d898 3
a900 3
	register struct mbuf *mp, *mp2;
	register int siz2, xfer;
	register caddr_t p;
d960 2
a961 2
	register struct mbuf *m;
	register int s;
d987 1
a987 1
	register struct mbuf *m1 = NULL, *m2;
d1087 1
a1087 1
	register int i;
d1119 3
a1121 3
	register struct vnode *vp = *vpp;
	register struct vattr *vap;
	register struct nfs_fattr *fp;
d1123 2
a1124 2
	register struct nfsnode *np;
	register int32_t t1;
d1302 1
a1302 1
	register struct vnode *vp;
d1305 2
a1306 2
	register struct nfsnode *np = VTONFS(vp);
	register struct vattr *vap;
d1343 1
a1343 1
	register struct nameidata *ndp;
d1354 3
a1356 3
	register int i, rem;
	register struct mbuf *md;
	register char *fromcp, *tocp;
d1460 1
a1460 1
	register int len;
d1463 3
a1465 3
	register struct mbuf *m;
	register int count, i;
	register char *cp;
d1523 1
a1523 1
	register struct vattr *before_vap;
d1529 3
a1531 3
	register struct mbuf *mb = *mbp, *mb2;
	register char *bpos = *bposp;
	register u_int32_t *tl;
d1558 4
a1561 4
	register struct mbuf *mb = *mbp, *mb2;
	register char *bpos = *bposp;
	register u_int32_t *tl;
	register struct nfs_fattr *fp;
d1578 3
a1580 3
	register struct nfsrv_descript *nfsd;
	register struct vattr *vap;
	register struct nfs_fattr *fp;
d1637 2
a1638 2
	register struct mount *mp;
	register int i;
d1704 1
a1704 1
	register struct sockaddr_in *inetaddr;
d1716 1
a1716 1
		register struct sockaddr_iso *isoaddr1, *isoaddr2;
d1744 2
a1745 2
	register struct vnode *vp, *nvp;
	register struct buf *bp, *nbp;
d1750 1
a1750 1
	for (vp = mp->mnt_vnodelist.lh_first; vp; vp = nvp) {
d1753 3
a1755 3
		nvp = vp->v_mntvnodes.le_next;
		for (bp = vp->v_dirtyblkhd.lh_first; bp; bp = nbp) {
			nbp = bp->b_vnbufs.le_next;
d1771 1
a1771 1
	register int err;
d1773 1
a1773 1
	register short *defaulterrp, *errp;
d1800 2
a1801 2
        register gid_t *list;
        register int num;
d1803 1
a1803 1
	register int i, j;
d1821 1
a1821 1
	register struct ucred *incred, *outcred;
d1823 1
a1823 1
	register int i;
@


1.38
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.35 2001/11/06 19:53:21 miod Exp $	*/
d1657 1
a1657 1
	    (ntohs(saddr->sin_port) >= IPPORT_RESERVED ||
@


1.37
log
@Merge in struct uvm_vnode into struct vnode.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.36 2001/11/27 05:27:12 art Exp $	*/
a41 34
/*
 * Copyright 2000 Wasabi Systems, Inc.
 * All rights reserved.
 *
 * Written by Frank van der Linden for Wasabi Systems, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed for the NetBSD Project by
 *      Wasabi Systems, Inc.
 * 4. The name of Wasabi Systems, Inc. may not be used to endorse
 *    or promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
d1244 10
a1253 3
		if ((np->n_flag & NMODIFIED) && vap->va_size < np->n_size) {
			vap->va_size = np->n_size;
		} else {
a1254 4
			if (vap->va_type == VREG) {
				uvm_vnp_setsize(vp, np->n_size);
			}
		}
d1744 2
a1745 3
	struct vnode *vp;
	struct vm_page *pg;
	struct nfsnode *np;
d1749 10
a1758 11
	LIST_FOREACH(vp, &mp->mnt_vnodelist, v_mntvnodes) {
		if (vp->v_type == VNON)
			continue;
		np = VTONFS(vp);
		np->n_pushlo = np->n_pushhi = np->n_pushedlo =
		    np->n_pushedhi = 0;
		np->n_commitflags &=
		    ~(NFS_COMMIT_PUSH_VALID | NFS_COMMIT_PUSHED_VALID);
		simple_lock(&vp->v_uobj.vmobjlock);
		TAILQ_FOREACH(pg, &vp->v_uobj.memq, listq) {
			pg->flags &= ~PG_NEEDCOMMIT;
a1759 1
		simple_unlock(&vp->v_uobj.vmobjlock);
a1761 187
}

void
nfs_merge_commit_ranges(vp)
	struct vnode *vp;
{
	struct nfsnode *np = VTONFS(vp);

	if (!(np->n_commitflags & NFS_COMMIT_PUSHED_VALID)) {
		np->n_pushedlo = np->n_pushlo;
		np->n_pushedhi = np->n_pushhi;
		np->n_commitflags |= NFS_COMMIT_PUSHED_VALID;
	} else {
		if (np->n_pushlo < np->n_pushedlo)
			np->n_pushedlo = np->n_pushlo;
		if (np->n_pushhi > np->n_pushedhi)
			np->n_pushedhi = np->n_pushhi;
	}

	np->n_pushlo = np->n_pushhi = 0;
	np->n_commitflags &= ~NFS_COMMIT_PUSH_VALID;

#ifdef fvdl_debug
	printf("merge: committed: %u - %u\n", (unsigned)np->n_pushedlo,
	    (unsigned)np->n_pushedhi);
#endif
}

int
nfs_in_committed_range(vp, off, len)
	struct vnode *vp;
	off_t off, len;
{
	struct nfsnode *np = VTONFS(vp);
	off_t lo, hi;

	if (!(np->n_commitflags & NFS_COMMIT_PUSHED_VALID))
		return 0;
	lo = off;
	hi = lo + len;

	return (lo >= np->n_pushedlo && hi <= np->n_pushedhi);
}

int
nfs_in_tobecommitted_range(vp, off, len)
	struct vnode *vp;
	off_t off, len;
{
	struct nfsnode *np = VTONFS(vp);
	off_t lo, hi;

	if (!(np->n_commitflags & NFS_COMMIT_PUSH_VALID))
		return 0;
	lo = off;
	hi = lo + len;

	return (lo >= np->n_pushlo && hi <= np->n_pushhi);
}

void
nfs_add_committed_range(vp, off, len)
	struct vnode *vp;
	off_t off, len;
{
	struct nfsnode *np = VTONFS(vp);
	off_t lo, hi;

	lo = off;
	hi = lo + len;

	if (!(np->n_commitflags & NFS_COMMIT_PUSHED_VALID)) {
		np->n_pushedlo = lo;
		np->n_pushedhi = hi;
		np->n_commitflags |= NFS_COMMIT_PUSHED_VALID;
	} else {
		if (hi > np->n_pushedhi)
			np->n_pushedhi = hi;
		if (lo < np->n_pushedlo)
			np->n_pushedlo = lo;
	}
#ifdef fvdl_debug
	printf("add: committed: %u - %u\n", (unsigned)np->n_pushedlo,
	    (unsigned)np->n_pushedhi);
#endif
}

void
nfs_del_committed_range(vp, off, len)
	struct vnode *vp;
	off_t off, len;
{
	struct nfsnode *np = VTONFS(vp);
	off_t lo, hi;

	if (!(np->n_commitflags & NFS_COMMIT_PUSHED_VALID))
		return;

	lo = off;
	hi = lo + len;

	if (lo > np->n_pushedhi || hi < np->n_pushedlo)
		return;
	if (lo <= np->n_pushedlo)
		np->n_pushedlo = hi;
	else if (hi >= np->n_pushedhi)
		np->n_pushedhi = lo;
	else {
		/*
		 * XXX There's only one range. If the deleted range
		 * is in the middle, pick the largest of the
		 * contiguous ranges that it leaves.
		 */
		if ((np->n_pushedlo - lo) > (hi - np->n_pushedhi))
			np->n_pushedhi = lo;
		else
			np->n_pushedlo = hi;
	}
#ifdef fvdl_debug
	printf("del: committed: %u - %u\n", (unsigned)np->n_pushedlo,
	    (unsigned)np->n_pushedhi);
#endif
}

void
nfs_add_tobecommitted_range(vp, off, len)
	struct vnode *vp;
	off_t off, len;
{
	struct nfsnode *np = VTONFS(vp);
	off_t lo, hi;

	lo = off;
	hi = lo + len;

	if (!(np->n_commitflags & NFS_COMMIT_PUSH_VALID)) {
		np->n_pushlo = lo;
		np->n_pushhi = hi;
		np->n_commitflags |= NFS_COMMIT_PUSH_VALID;
	} else {
		if (lo < np->n_pushlo)
			np->n_pushlo = lo;
		if (hi > np->n_pushhi)
			np->n_pushhi = hi;
	}
#ifdef fvdl_debug
	printf("add: tobecommitted: %u - %u\n", (unsigned)np->n_pushlo,
	    (unsigned)np->n_pushhi);
#endif
}

void
nfs_del_tobecommitted_range(vp, off, len)
	struct vnode *vp;
	off_t off, len;
{
	struct nfsnode *np = VTONFS(vp);
	off_t lo, hi;

	if (!(np->n_commitflags & NFS_COMMIT_PUSH_VALID))
		return;

	lo = off;
	hi = lo + len;

	if (lo > np->n_pushhi || hi < np->n_pushlo)
		return;

	if (lo <= np->n_pushlo)
		np->n_pushlo = hi;
	else if (hi >= np->n_pushhi)
		np->n_pushhi = lo;
	else {
		/*
		 * XXX There's only one range. If the deleted range
		 * is in the middle, pick the largest of the
		 * contiguous ranges that it leaves.
		 */
		if ((np->n_pushlo - lo) > (hi - np->n_pushhi))
			np->n_pushhi = lo;
		else
			np->n_pushlo = hi;
	}
#ifdef fvdl_debug
	printf("del: tobecommitted: %u - %u\n", (unsigned)np->n_pushlo,
	    (unsigned)np->n_pushhi);
#endif
@


1.37.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.40 2002/01/16 21:51:16 ericj Exp $	*/
d589 2
a590 2
	struct mbuf *mb;
	caddr_t bpos;
d612 1
a612 1
	struct ucred *cr;
d625 4
a628 4
	struct mbuf *mb;
	u_int32_t *tl;
	caddr_t bpos;
	int i;
d765 1
a765 1
	struct uio *uiop;
d769 3
a771 3
	char *mbufcp, *uiocp;
	int xfer, left, len;
	struct mbuf *mp;
d840 1
a840 1
	struct uio *uiop;
d845 3
a847 3
	char *uiocp;
	struct mbuf *mp, *mp2;
	int xfer, left, mlen;
d932 3
a934 3
	struct mbuf *mp, *mp2;
	int siz2, xfer;
	caddr_t p;
d994 2
a995 2
	struct mbuf *m;
	int s;
d1021 1
a1021 1
	struct mbuf *m1 = NULL, *m2;
d1121 1
a1121 1
	int i;
d1153 3
a1155 3
	struct vnode *vp = *vpp;
	struct vattr *vap;
	struct nfs_fattr *fp;
d1157 2
a1158 2
	struct nfsnode *np;
	int32_t t1;
d1333 1
a1333 1
	struct vnode *vp;
d1336 2
a1337 2
	struct nfsnode *np = VTONFS(vp);
	struct vattr *vap;
d1374 1
a1374 1
	struct nameidata *ndp;
d1385 3
a1387 3
	int i, rem;
	struct mbuf *md;
	char *fromcp, *tocp;
d1491 1
a1491 1
	int len;
d1494 3
a1496 3
	struct mbuf *m;
	int count, i;
	char *cp;
d1554 1
a1554 1
	struct vattr *before_vap;
d1560 3
a1562 3
	struct mbuf *mb = *mbp, *mb2;
	char *bpos = *bposp;
	u_int32_t *tl;
d1589 4
a1592 4
	struct mbuf *mb = *mbp, *mb2;
	char *bpos = *bposp;
	u_int32_t *tl;
	struct nfs_fattr *fp;
d1609 3
a1611 3
	struct nfsrv_descript *nfsd;
	struct vattr *vap;
	struct nfs_fattr *fp;
d1668 2
a1669 2
	struct mount *mp;
	int i;
d1688 1
a1688 1
	    ((ntohs(saddr->sin_port) >= IPPORT_RESERVED && !nfs_norsvport) ||
d1735 1
a1735 1
	struct sockaddr_in *inetaddr;
d1747 1
a1747 1
		struct sockaddr_iso *isoaddr1, *isoaddr2;
d1992 1
a1992 1
	int err;
d1994 1
a1994 1
	short *defaulterrp, *errp;
d2021 2
a2022 2
        gid_t *list;
        int num;
d2024 1
a2024 1
	int i, j;
d2042 1
a2042 1
	struct ucred *incred, *outcred;
d2044 1
a2044 1
	int i;
@


1.37.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.37.2.1 2002/01/31 22:55:47 niklas Exp $	*/
d123 1
a123 1
int	nfs_attrtimeo(struct nfsnode *np);
d1156 1
a1156 1
	extern int (**spec_nfsv2nodeop_p)(void *);
d1210 1
a1210 1
			extern int (**fifo_nfsv2nodeop_p)(void *);
d1688 1
a1688 1
	    (ntohs(saddr->sin_port) >= IPPORT_RESERVED ||
@


1.37.2.3
log
@Huge sync to NetBSD plus lots of bugfixes.
 - uvm is as in netbsd-current minus uvm_map forward merge.
 - various locking bugfixes in nfs.
 - make sure that all specops and fifoops are correct in all vnodeop vectors.
 - make the filesystem code more like filsystem code and less like vm code.
@
text
@d1 2
a2 2
/*	$OpenBSD: nfs_subs.c,v 1.37.2.2 2002/06/11 03:32:04 art Exp $	*/
/*	$NetBSD: nfs_subs.c,v 1.104 2002/08/23 05:38:51 enami Exp $	*/
a144 1
int nfs_commitsize;
a1127 1
	nfs_commitsize = uvmexp.npages << (PAGE_SHIFT - 4);
d1147 1
a1147 1
nfs_loadattrcache(vpp, mdp, dposp, vaper, flags)
a1151 1
	int flags;
d1283 1
a1283 10
				if ((flags & NAC_NOTRUNC)
				    && np->n_size < vp->v_size) {
					/*
					 * we can't free pages now because
					 * the pages can be owned by ourselves.
					 */
					np->n_flag |= NTRUNCDELAYED;
				} else {
					uvm_vnp_setsize(vp, np->n_size);
				}
a1297 12
}

void
nfs_delayedtruncate(vp)
	struct vnode *vp;
{
	struct nfsnode *np = VTONFS(vp);

	if (np->n_flag & NTRUNCDELAYED) {
		np->n_flag &= ~NTRUNCDELAYED;
		uvm_vnp_setsize(vp, np->n_size);
	}
@


1.36
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.35 2001/11/06 19:53:21 miod Exp $	*/
d1789 2
a1790 2
		simple_lock(&vp->v_uvm.u_obj.vmobjlock);
		TAILQ_FOREACH(pg, &vp->v_uvm.u_obj.memq, listq) {
d1793 1
a1793 1
		simple_unlock(&vp->v_uvm.u_obj.vmobjlock);
@


1.35
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.34 2001/08/19 18:14:54 art Exp $	*/
d42 34
d1278 3
a1280 10
		if (vap->va_type == VREG) {
			if (np->n_flag & NMODIFIED) {
				if (vap->va_size < np->n_size)
					vap->va_size = np->n_size;
				else
					np->n_size = vap->va_size;
			} else
				np->n_size = vap->va_size;
			uvm_vnp_setsize(vp, np->n_size);
		} else
d1282 4
d1775 3
a1777 2
	register struct vnode *vp, *nvp;
	register struct buf *bp, *nbp;
d1781 11
a1791 10
loop:
	for (vp = mp->mnt_vnodelist.lh_first; vp; vp = nvp) {
		if (vp->v_mount != mp)	/* Paranoia */
			goto loop;
		nvp = vp->v_mntvnodes.le_next;
		for (bp = vp->v_dirtyblkhd.lh_first; bp; bp = nbp) {
			nbp = bp->b_vnbufs.le_next;
			if ((bp->b_flags & (B_BUSY | B_DELWRI | B_NEEDCOMMIT))
				== (B_DELWRI | B_NEEDCOMMIT))
				bp->b_flags &= ~B_NEEDCOMMIT;
d1793 1
d1796 187
@


1.34
log
@Stop whining.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.33 2001/08/19 17:45:07 jason Exp $	*/
d62 1
a62 1
#include <vm/vm.h>
a74 2

#include <vm/vm.h>
@


1.33
log
@add __sparc64__ to list of arch's not checked for bloated structures (also
correct alpha -> __alpha__)
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.32 2001/06/27 04:58:46 art Exp $	*/
a1051 22

#if !defined(__alpha__) && !defined(__sparc64__) && defined(DIAGNOSTIC)
	/*
	 * Check to see if major data structures haven't bloated.
	 */
	if (sizeof (struct nfsnode) > NFS_NODEALLOC) {
		printf("struct nfsnode bloated (> %dbytes)\n", NFS_NODEALLOC);
		printf("Try reducing NFS_SMALLFH\n");
	}
	if (sizeof (struct nfsmount) > NFS_MNTALLOC) {
		printf("struct nfsmount bloated (> %dbytes)\n", NFS_MNTALLOC);
		printf("Try reducing NFS_MUIDHASHSIZ\n");
	}
	if (sizeof (struct nfssvc_sock) > NFS_SVCALLOC) {
		printf("struct nfssvc_sock bloated (> %dbytes)\n",NFS_SVCALLOC);
		printf("Try reducing NFS_UIDHASHSIZ\n");
	}
	if (sizeof (struct nfsuid) > NFS_UIDALLOC) {
		printf("struct nfsuid bloated (> %dbytes)\n",NFS_UIDALLOC);
		printf("Try unionizing the nu_nickname and nu_flag fields\n");
	}
#endif
@


1.32
log
@Remove old vm.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.31 2001/06/25 03:28:10 csapuntz Exp $	*/
d1053 1
a1053 1
#if !defined(alpha) && defined(DIAGNOSTIC)
@


1.31
log
@Remove NQNFS
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.30 2001/06/25 02:15:47 csapuntz Exp $	*/
a1275 1
#if defined(UVM)
a1276 3
#else
			vnode_pager_setsize(vp, (u_long)np->n_size);
#endif
a1346 1
#if defined(UVM)
a1347 3
#else
			vnode_pager_setsize(vp, (u_long)np->n_size);
#endif
@


1.30
log
@
Get rid of old directory caching scheme which caused persistent duplicates.

Still not correct for NFSv3 but that's hard.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.29 2000/06/26 22:48:15 art Exp $	*/
a70 1
#include <nfs/nqnfs.h>
d101 1
a101 1
u_int32_t nfs_prog, nqnfs_prog, nfs_true, nfs_false;
a536 4
extern time_t nqnfsstarttime;
extern int nqsrv_clockskew;
extern int nqsrv_writeslack;
extern int nqsrv_maxlease;
a537 1
extern int nqnfs_piggy[NFS_NPROCS];
a557 1
	register u_int32_t *tl;
a558 3
	struct mbuf *mb2;
	struct nfsmount *nmp;
	int nqflag;
a565 17
	/*
	 * For NQNFS, add lease request.
	 */
	if (vp) {
		nmp = VFSTONFS(vp->v_mount);
		if (nmp->nm_flag & NFSMNT_NQNFS) {
			nqflag = NQNFS_NEEDLEASE(vp, procid);
			if (nqflag) {
				nfsm_build(tl, u_int32_t *, 2*NFSX_UNSIGNED);
				*tl++ = txdr_unsigned(nqflag);
				*tl = txdr_unsigned(nmp->nm_leaseterm);
			} else {
				nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED);
				*tl = 0;
			}
		}
	}
d632 5
a636 10
	if (nmflag & NFSMNT_NQNFS) {
		*tl++ = txdr_unsigned(NQNFS_PROG);
		*tl++ = txdr_unsigned(NQNFS_VER3);
	} else {
		*tl++ = txdr_unsigned(NFS_PROG);
		if (nmflag & NFSMNT_NFSV3)
			*tl++ = txdr_unsigned(NFS_VER3);
		else
			*tl++ = txdr_unsigned(NFS_VER2);
	}
a1085 1
	nqnfs_prog = txdr_unsigned(NQNFS_PROG);
a1095 11

	/*
	 * Initialize the nqnfs client/server stuff.
	 */
	if (nqnfsstarttime == 0) {
		nqnfsstarttime = boottime.tv_sec + nqsrv_maxlease
			+ nqsrv_clockskew + nqsrv_writeslack;
		NQLOADNOVRAM(nqnfsstarttime);
		CIRCLEQ_INIT(&nqtimerhead);
		nqfhhashtbl = hashinit(NQLCHSZ, M_NQLEASE, M_WAITOK, &nqfhhash);
	}
@


1.29
log
@Convert nfs_timer to new timeouts.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.28 2000/02/07 04:57:17 assar Exp $	*/
a1807 82
}

static nfsuint64 nfs_nullcookie = {{ 0, 0 }};
/*
 * This function finds the directory cookie that corresponds to the
 * logical byte offset given.
 */
nfsuint64 *
nfs_getcookie(np, off, add)
	register struct nfsnode *np;
	off_t off;
	int add;
{
	register struct nfsdmap *dp, *dp2;
	register int pos;

	pos = off / NFS_DIRBLKSIZ;
	if (pos == 0) {
#ifdef DIAGNOSTIC
		if (add)
			panic("nfs getcookie add at 0");
#endif
		return (&nfs_nullcookie);
	}
	pos--;
	dp = np->n_cookies.lh_first;
	if (!dp) {
		if (add) {
			MALLOC(dp, struct nfsdmap *, sizeof (struct nfsdmap),
				M_NFSDIROFF, M_WAITOK);
			dp->ndm_eocookie = 0;
			LIST_INSERT_HEAD(&np->n_cookies, dp, ndm_list);
		} else
			return ((nfsuint64 *)0);
	}
	while (pos >= NFSNUMCOOKIES) {
		pos -= NFSNUMCOOKIES;
		if (dp->ndm_list.le_next) {
			if (!add && dp->ndm_eocookie < NFSNUMCOOKIES &&
				pos >= dp->ndm_eocookie)
				return ((nfsuint64 *)0);
			dp = dp->ndm_list.le_next;
		} else if (add) {
			MALLOC(dp2, struct nfsdmap *, sizeof (struct nfsdmap),
				M_NFSDIROFF, M_WAITOK);
			dp2->ndm_eocookie = 0;
			LIST_INSERT_AFTER(dp, dp2, ndm_list);
			dp = dp2;
		} else
			return ((nfsuint64 *)0);
	}
	if (pos >= dp->ndm_eocookie) {
		if (add)
			dp->ndm_eocookie = pos + 1;
		else
			return ((nfsuint64 *)0);
	}
	return (&dp->ndm_cookies[pos]);
}

/*
 * Invalidate cached directory information, except for the actual directory
 * blocks (which are invalidated separately).
 * Done mainly to avoid the use of stale offset cookies.
 */
void
nfs_invaldir(vp)
	register struct vnode *vp;
{
#ifdef notdef /* XXX */
	register struct nfsnode *np = VTONFS(vp);

#ifdef DIAGNOSTIC
	if (vp->v_type != VDIR)
		panic("nfs: invaldir not dir");
#endif
	np->n_direofoffset = 0;
	np->n_cookieverf.nfsuquad[0] = 0;
	np->n_cookieverf.nfsuquad[1] = 0;
	if (np->n_cookies.lh_first)
		np->n_cookies.lh_first->ndm_eocookie = 0;
#endif
@


1.28
log
@update to use new checkexp vfs operation
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.27 1999/04/28 09:28:17 art Exp $	*/
d1083 2
d1145 3
a1147 1
	nfs_timer(NULL);
@


1.28.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.29 2000/06/26 22:48:15 art Exp $	*/
a1082 2
	static struct timeout nfs_timer_to;

d1143 1
a1143 3

	timeout_set(&nfs_timer_to, nfs_timer, &nfs_timer_to);
	nfs_timer(&nfs_timer_to);
@


1.28.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.28.2.1 2001/05/14 22:44:57 niklas Exp $	*/
d71 1
d102 1
a102 1
u_int32_t nfs_prog, nfs_true, nfs_false;
d538 4
d543 1
d564 1
d566 3
d576 17
d659 10
a668 5
	*tl++ = txdr_unsigned(NFS_PROG);
	if (nmflag & NFSMNT_NFSV3)
		*tl++ = txdr_unsigned(NFS_VER3);
	else
		*tl++ = txdr_unsigned(NFS_VER2);
d1118 1
d1131 11
d1320 1
d1322 3
d1395 1
d1397 3
d1808 82
@


1.28.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.28.2.2 2001/07/04 10:55:50 niklas Exp $	*/
d1052 22
@


1.28.2.4
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d62 1
a62 1
#include <uvm/uvm_extern.h>
d75 2
@


1.28.2.5
log
@Merge in -current
@
text
@a41 34
/*
 * Copyright 2000 Wasabi Systems, Inc.
 * All rights reserved.
 *
 * Written by Frank van der Linden for Wasabi Systems, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed for the NetBSD Project by
 *      Wasabi Systems, Inc.
 * 4. The name of Wasabi Systems, Inc. may not be used to endorse
 *    or promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
d1244 10
a1253 3
		if ((np->n_flag & NMODIFIED) && vap->va_size < np->n_size) {
			vap->va_size = np->n_size;
		} else {
a1254 4
			if (vap->va_type == VREG) {
				uvm_vnp_setsize(vp, np->n_size);
			}
		}
d1744 2
a1745 3
	struct vnode *vp;
	struct vm_page *pg;
	struct nfsnode *np;
d1749 10
a1758 11
	LIST_FOREACH(vp, &mp->mnt_vnodelist, v_mntvnodes) {
		if (vp->v_type == VNON)
			continue;
		np = VTONFS(vp);
		np->n_pushlo = np->n_pushhi = np->n_pushedlo =
		    np->n_pushedhi = 0;
		np->n_commitflags &=
		    ~(NFS_COMMIT_PUSH_VALID | NFS_COMMIT_PUSHED_VALID);
		simple_lock(&vp->v_uvm.u_obj.vmobjlock);
		TAILQ_FOREACH(pg, &vp->v_uvm.u_obj.memq, listq) {
			pg->flags &= ~PG_NEEDCOMMIT;
a1759 1
		simple_unlock(&vp->v_uvm.u_obj.vmobjlock);
a1761 187
}

void
nfs_merge_commit_ranges(vp)
	struct vnode *vp;
{
	struct nfsnode *np = VTONFS(vp);

	if (!(np->n_commitflags & NFS_COMMIT_PUSHED_VALID)) {
		np->n_pushedlo = np->n_pushlo;
		np->n_pushedhi = np->n_pushhi;
		np->n_commitflags |= NFS_COMMIT_PUSHED_VALID;
	} else {
		if (np->n_pushlo < np->n_pushedlo)
			np->n_pushedlo = np->n_pushlo;
		if (np->n_pushhi > np->n_pushedhi)
			np->n_pushedhi = np->n_pushhi;
	}

	np->n_pushlo = np->n_pushhi = 0;
	np->n_commitflags &= ~NFS_COMMIT_PUSH_VALID;

#ifdef fvdl_debug
	printf("merge: committed: %u - %u\n", (unsigned)np->n_pushedlo,
	    (unsigned)np->n_pushedhi);
#endif
}

int
nfs_in_committed_range(vp, off, len)
	struct vnode *vp;
	off_t off, len;
{
	struct nfsnode *np = VTONFS(vp);
	off_t lo, hi;

	if (!(np->n_commitflags & NFS_COMMIT_PUSHED_VALID))
		return 0;
	lo = off;
	hi = lo + len;

	return (lo >= np->n_pushedlo && hi <= np->n_pushedhi);
}

int
nfs_in_tobecommitted_range(vp, off, len)
	struct vnode *vp;
	off_t off, len;
{
	struct nfsnode *np = VTONFS(vp);
	off_t lo, hi;

	if (!(np->n_commitflags & NFS_COMMIT_PUSH_VALID))
		return 0;
	lo = off;
	hi = lo + len;

	return (lo >= np->n_pushlo && hi <= np->n_pushhi);
}

void
nfs_add_committed_range(vp, off, len)
	struct vnode *vp;
	off_t off, len;
{
	struct nfsnode *np = VTONFS(vp);
	off_t lo, hi;

	lo = off;
	hi = lo + len;

	if (!(np->n_commitflags & NFS_COMMIT_PUSHED_VALID)) {
		np->n_pushedlo = lo;
		np->n_pushedhi = hi;
		np->n_commitflags |= NFS_COMMIT_PUSHED_VALID;
	} else {
		if (hi > np->n_pushedhi)
			np->n_pushedhi = hi;
		if (lo < np->n_pushedlo)
			np->n_pushedlo = lo;
	}
#ifdef fvdl_debug
	printf("add: committed: %u - %u\n", (unsigned)np->n_pushedlo,
	    (unsigned)np->n_pushedhi);
#endif
}

void
nfs_del_committed_range(vp, off, len)
	struct vnode *vp;
	off_t off, len;
{
	struct nfsnode *np = VTONFS(vp);
	off_t lo, hi;

	if (!(np->n_commitflags & NFS_COMMIT_PUSHED_VALID))
		return;

	lo = off;
	hi = lo + len;

	if (lo > np->n_pushedhi || hi < np->n_pushedlo)
		return;
	if (lo <= np->n_pushedlo)
		np->n_pushedlo = hi;
	else if (hi >= np->n_pushedhi)
		np->n_pushedhi = lo;
	else {
		/*
		 * XXX There's only one range. If the deleted range
		 * is in the middle, pick the largest of the
		 * contiguous ranges that it leaves.
		 */
		if ((np->n_pushedlo - lo) > (hi - np->n_pushedhi))
			np->n_pushedhi = lo;
		else
			np->n_pushedlo = hi;
	}
#ifdef fvdl_debug
	printf("del: committed: %u - %u\n", (unsigned)np->n_pushedlo,
	    (unsigned)np->n_pushedhi);
#endif
}

void
nfs_add_tobecommitted_range(vp, off, len)
	struct vnode *vp;
	off_t off, len;
{
	struct nfsnode *np = VTONFS(vp);
	off_t lo, hi;

	lo = off;
	hi = lo + len;

	if (!(np->n_commitflags & NFS_COMMIT_PUSH_VALID)) {
		np->n_pushlo = lo;
		np->n_pushhi = hi;
		np->n_commitflags |= NFS_COMMIT_PUSH_VALID;
	} else {
		if (lo < np->n_pushlo)
			np->n_pushlo = lo;
		if (hi > np->n_pushhi)
			np->n_pushhi = hi;
	}
#ifdef fvdl_debug
	printf("add: tobecommitted: %u - %u\n", (unsigned)np->n_pushlo,
	    (unsigned)np->n_pushhi);
#endif
}

void
nfs_del_tobecommitted_range(vp, off, len)
	struct vnode *vp;
	off_t off, len;
{
	struct nfsnode *np = VTONFS(vp);
	off_t lo, hi;

	if (!(np->n_commitflags & NFS_COMMIT_PUSH_VALID))
		return;

	lo = off;
	hi = lo + len;

	if (lo > np->n_pushhi || hi < np->n_pushlo)
		return;

	if (lo <= np->n_pushlo)
		np->n_pushlo = hi;
	else if (hi >= np->n_pushhi)
		np->n_pushhi = lo;
	else {
		/*
		 * XXX There's only one range. If the deleted range
		 * is in the middle, pick the largest of the
		 * contiguous ranges that it leaves.
		 */
		if ((np->n_pushlo - lo) > (hi - np->n_pushhi))
			np->n_pushhi = lo;
		else
			np->n_pushlo = hi;
	}
#ifdef fvdl_debug
	printf("del: tobecommitted: %u - %u\n", (unsigned)np->n_pushlo,
	    (unsigned)np->n_pushhi);
#endif
@


1.28.2.6
log
@Merge in trunk
@
text
@d42 34
d589 2
a590 2
	struct mbuf *mb;
	caddr_t bpos;
d612 1
a612 1
	struct ucred *cr;
d625 4
a628 4
	struct mbuf *mb;
	u_int32_t *tl;
	caddr_t bpos;
	int i;
d765 1
a765 1
	struct uio *uiop;
d769 3
a771 3
	char *mbufcp, *uiocp;
	int xfer, left, len;
	struct mbuf *mp;
d840 1
a840 1
	struct uio *uiop;
d845 3
a847 3
	char *uiocp;
	struct mbuf *mp, *mp2;
	int xfer, left, mlen;
d932 3
a934 3
	struct mbuf *mp, *mp2;
	int siz2, xfer;
	caddr_t p;
d994 2
a995 2
	struct mbuf *m;
	int s;
d1021 1
a1021 1
	struct mbuf *m1 = NULL, *m2;
d1121 1
a1121 1
	int i;
d1153 3
a1155 3
	struct vnode *vp = *vpp;
	struct vattr *vap;
	struct nfs_fattr *fp;
d1157 2
a1158 2
	struct nfsnode *np;
	int32_t t1;
d1278 3
a1280 10
		if (vap->va_type == VREG) {
			if (np->n_flag & NMODIFIED) {
				if (vap->va_size < np->n_size)
					vap->va_size = np->n_size;
				else
					np->n_size = vap->va_size;
			} else
				np->n_size = vap->va_size;
			uvm_vnp_setsize(vp, np->n_size);
		} else
d1282 4
d1333 1
a1333 1
	struct vnode *vp;
d1336 2
a1337 2
	struct nfsnode *np = VTONFS(vp);
	struct vattr *vap;
d1374 1
a1374 1
	struct nameidata *ndp;
d1385 3
a1387 3
	int i, rem;
	struct mbuf *md;
	char *fromcp, *tocp;
d1491 1
a1491 1
	int len;
d1494 3
a1496 3
	struct mbuf *m;
	int count, i;
	char *cp;
d1554 1
a1554 1
	struct vattr *before_vap;
d1560 3
a1562 3
	struct mbuf *mb = *mbp, *mb2;
	char *bpos = *bposp;
	u_int32_t *tl;
d1589 4
a1592 4
	struct mbuf *mb = *mbp, *mb2;
	char *bpos = *bposp;
	u_int32_t *tl;
	struct nfs_fattr *fp;
d1609 3
a1611 3
	struct nfsrv_descript *nfsd;
	struct vattr *vap;
	struct nfs_fattr *fp;
d1668 2
a1669 2
	struct mount *mp;
	int i;
d1735 1
a1735 1
	struct sockaddr_in *inetaddr;
d1747 1
a1747 1
		struct sockaddr_iso *isoaddr1, *isoaddr2;
d1775 3
a1777 2
	struct vnode *vp, *nvp;
	struct buf *bp, *nbp;
d1781 11
a1791 10
loop:
	for (vp = LIST_FIRST(&mp->mnt_vnodelist); vp != NULL; vp = nvp) {
		if (vp->v_mount != mp)	/* Paranoia */
			goto loop;
		nvp = LIST_NEXT(vp, v_mntvnodes);
		for (bp = LIST_FIRST(&vp->v_dirtyblkhd); bp != NULL; bp = nbp) {
			nbp = LIST_NEXT(bp, b_vnbufs);
			if ((bp->b_flags & (B_BUSY | B_DELWRI | B_NEEDCOMMIT))
				== (B_DELWRI | B_NEEDCOMMIT))
				bp->b_flags &= ~B_NEEDCOMMIT;
d1793 1
d1798 187
d1992 1
a1992 1
	int err;
d1994 1
a1994 1
	short *defaulterrp, *errp;
d2021 2
a2022 2
        gid_t *list;
        int num;
d2024 1
a2024 1
	int i, j;
d2042 1
a2042 1
	struct ucred *incred, *outcred;
d2044 1
a2044 1
	int i;
@


1.28.2.7
log
@Merge in -current from roughly a week ago
@
text
@d89 1
a89 1
int	nfs_attrtimeo(struct nfsnode *np);
d1122 1
a1122 1
	extern int (**spec_nfsv2nodeop_p)(void *);
d1176 1
a1176 1
			extern int (**fifo_nfsv2nodeop_p)(void *);
@


1.28.2.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.28.2.7 2002/03/28 15:02:48 niklas Exp $	*/
d19 5
a23 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.28.2.9
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a55 1
#include <sys/pool.h>
d1358 1
a1358 1
	cnp->cn_pnbuf = pool_get(&namei_pool, PR_WAITOK);
d1445 1
a1445 1
	pool_put(&namei_pool, cnp->cn_pnbuf);
@


1.27
log
@zap the newhashinit hack.
Add an extra flag to hashinit telling if it should wait in malloc.
update all calls to hashinit.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.26 1999/02/26 03:16:25 art Exp $	*/
d1693 1
a1693 1
 *	- get vp and export rights by calling VFS_FHTOVP()
d1720 4
a1723 1
	error = VFS_FHTOVP(mp, &fhp->fh_fid, nam, vpp, &exflags, &credanon);
@


1.26
log
@compatibility with uvm vnode pager
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.25 1999/02/06 23:07:45 millert Exp $	*/
d1136 1
a1136 1
		nqfhhashtbl = hashinit(NQLCHSZ, M_NQLEASE, &nqfhhash);
@


1.25
log
@Use bitwise operations to extract high and low words from the quad
in txdr_hyper.  This should be more portable than casting to an array
of ints and pulling out the two 32-bit words (this produced incorrect
results on alpha for the high word for filesystems < 4gig).  As a side
effect, txdr_hyper now takes a u_quad_t as its first arg, not u_quad_t *.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.24 1999/01/16 13:28:25 niklas Exp $	*/
d1316 3
d1320 1
d1391 3
d1395 1
@


1.24
log
@Do not lose st_blocks on NFSv2 mounts when files>2GB
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.23 1998/08/19 22:26:55 csapuntz Exp $	*/
d1603 1
a1603 1
		txdr_hyper(&(before_vap->va_size), tl);
d1653 2
a1654 2
		txdr_hyper(&vap->va_size, &fp->fa3_size);
		txdr_hyper(&vap->va_bytes, &fp->fa3_used);
@


1.23
log
@

Change fxdr_hyper to return a u_quad_t. This minimizes the evil clobbering
of lvalues that ANSI abhors.

And it fixes df on NFS version 3 mounts on Sparcs.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.22 1997/11/06 05:59:03 csapuntz Exp $	*/
d1295 3
a1297 2
		vap->va_bytes = fxdr_unsigned(int32_t, fp->fa2_blocks)
		    * NFS_FABLKSIZE;
@


1.22
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.21 1997/10/06 20:20:49 deraadt Exp $	*/
d1280 1
a1280 1
		fxdr_hyper(&fp->fa3_size, &vap->va_size);
d1282 1
a1282 1
		fxdr_hyper(&fp->fa3_used, &vap->va_bytes);
@


1.21
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.19 1997/04/28 00:40:14 deraadt Exp $	*/
d1147 3
a1149 2
void
nfs_vfs_init()
d1158 2
d1253 1
a1253 1
#ifdef Lite2_integrated
a1255 1
#endif
a1698 1
#ifdef Lite2_integrated
a1699 1
#endif
a1706 1
#ifdef Lite2_integrated
d1708 1
a1708 3
#else
	mp = getvfs(&fhp->fh_fsid);
#endif
a1745 1
#ifdef Lite2_integrated
d1747 1
a1747 3
#else
		VOP_UNLOCK(*vpp);
#endif
@


1.20
log
@VFS Lite2 Changes
@
text
@d1147 2
a1148 3
int
nfs_vfs_init(vfsp)
	struct vfsconf *vfsp;
a1156 2

	return (0);
d1250 1
a1250 1

d1253 1
d1697 1
d1699 1
d1707 1
d1709 3
a1711 1

d1749 1
d1751 3
a1753 1

@


1.19
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.18 1997/04/28 00:37:06 angelos Exp $	*/
d1147 3
a1149 2
void
nfs_vfs_init()
d1158 2
d1253 1
a1253 1
#ifdef Lite2_integrated
a1255 1
#endif
a1698 1
#ifdef Lite2_integrated
a1699 1
#endif
a1706 1
#ifdef Lite2_integrated
d1708 1
a1708 3
#else
	mp = getvfs(&fhp->fh_fsid);
#endif
a1745 1
#ifdef Lite2_integrated
d1747 1
a1747 3
#else
		VOP_UNLOCK(*vpp);
#endif
@


1.18
log
@Previous patch didn't make much sense. We now set the initial NFS xid
(for requests) to some random value, and then increase that by a small
(1-255) random value for each requests.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.17 1997/04/27 23:55:49 angelos Exp $	*/
d647 7
a653 11
	if ((nfs_xid == 0) && (nfs_xid_touched == 0))
	{
	    nfs_xid = arc4random();
	    nfs_xid_touched = 1;
	}
	else
	{
	    while ((*xidp = arc4random() % 256) == 0)
	      ;

	    nfs_xid += *xidp;
@


1.17
log
@Random/unique NFS xids.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.15 1996/12/18 18:30:58 niklas Exp $	*/
a70 1
#include <nfs/nfsrvcache.h>
a91 6
#define NFSRCHASH(xid) \
        (&nfsrvhashtbl[((xid) + ((xid) >> 24)) & nfsrvhash])
extern LIST_HEAD(nfsrvhash, nfsrvcache) *nfsrvhashtbl;
extern TAILQ_HEAD(nfsrvlru, nfsrvcache) nfsrvlruhead;
extern u_long nfsrvhash;

d106 1
a623 1
	register struct nfsrvcache *rp;
d647 6
a652 1
	do
d654 1
a654 3
	    i = 0;

	    while (((*xidp = arc4random()) == nfs_xid) || (*xidp == 0))
d657 2
a658 1
	    nfs_xid = *xidp;
a659 10
	    for (rp = NFSRCHASH(nfs_xid)->lh_first; rp !=0; 
		 rp = rp->rc_hash.le_next)
	      if ((nfs_xid == rp->rc_xid) &&
		  (rp->rc_proc == procid))
	      {
		  i = 1;     /* do the loop again */
		  break;
	      }
	} while (i);
     
@


1.16
log
@require reserved ports. avoid ftp bounce.
@
text
@d71 1
d85 2
d93 6
d630 1
a632 2
	struct timeval tv;
	static u_int32_t base;
d652 1
a652 14
	/*
	 * derive initial xid from system time
	 * XXX time is invalid if root not yet mounted
	 */
	if (!base && (rootvp)) {
		microtime(&tv);
		base = tv.tv_sec << 12;
		nfs_xid = base;
	}
	/*
	 * Skip zero xid if it should ever happen.
	 */
	if (++nfs_xid == 0)
		nfs_xid++;
d654 19
@


1.15
log
@Conditionalize GCC and ANSI/ISO C dependencies
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.14 1996/12/17 03:46:38 dm Exp $	*/
d57 1
d1707 1
d1720 9
@


1.14
log
@NFS attribute cache timeout mount param
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.13 1996/10/15 11:34:15 deraadt Exp $	*/
d83 8
d1332 3
a1334 2
inline int
nfs_attrtimeo (struct nfsnode *np)
@


1.13
log
@nqnfs code is for client+server; spotted by niklas
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.12 1996/09/25 11:57:25 niklas Exp $	*/
d1324 25
d1362 1
a1362 1
	if ((time.tv_sec - np->n_attrstamp) >= NFS_ATTRTIMEO(np)) {
@


1.12
log
@Drop unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.11 1996/09/21 11:06:19 deraadt Exp $	*/
d1120 1
d1123 1
a1123 1
	 * Initialize the nqnfs server stuff.
a1131 1
#endif /* NFSSERVER */
@


1.11
log
@fix NFSSERVER w/o NFSCLIENT; netbsd pr#1780, cgd@@netbsd (yes, a 10month
old PR and the fix is mostly unchanged).
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.10 1996/07/27 11:09:39 deraadt Exp $	*/
a1076 2
	register int i;

@


1.10
log
@fvdl; We're only handling uio with iovcnt == 1, so don't ever attempt to
increment uio_iov, this will get us into nasty trouble. (Thanks to
Matthias Drochner for tracking this down).
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.9 1996/07/23 21:32:31 deraadt Exp $	*/
a1118 7
#ifdef NFSCLIENT
	/* Ensure async daemons disabled */
	for (i = 0; i < NFS_MAXASYNCDAEMON; i++)
		nfs_iodwant[i] = (struct proc *)0;
	TAILQ_INIT(&nfs_bufq);
	nfs_nhinit();			/* Init the nfsnode table */
#endif /* NFSCLIENT */
a1121 1
#endif /* NFSSERVER */
d1133 1
d1143 12
@


1.9
log
@sync
@
text
@d1 2
a2 2
/*	$OpenBSD: nfs_subs.c,v 1.8 1996/05/28 13:44:08 deraadt Exp $	*/
/*	$NetBSD: nfs_subs.c,v 1.27.4.1 1996/05/25 22:40:34 fvdl Exp $	*/
d615 1
a615 1
	static u_long base;
d829 2
a830 1
 * copies a uio scatter/gather list to an mbuf chain...
d845 5
a856 2
		if (uiop->uio_iovcnt <= 0 || uiop->uio_iov == NULL)
			return (EINVAL);
d891 2
a892 7
		if (uiop->uio_iov->iov_len <= siz) {
			uiop->uio_iovcnt--;
			uiop->uio_iov++;
		} else {
			uiop->uio_iov->iov_base += uiosiz;
			uiop->uio_iov->iov_len -= uiosiz;
		}
@


1.8
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.6 1996/04/17 04:50:31 mickey Exp $	*/
d59 1
d614 2
d634 13
d649 1
@


1.7
log
@partial sync with netbsd 960418, more to come
@
text
@d2 1
a2 1
/*	$NetBSD: nfs_subs.c,v 1.27 1996/04/03 23:25:36 thorpej Exp $	*/
@


1.6
log
@Minor cleanups. Checked against Lite2.
(NetBSD's was really just a Lite2's, but w/ 64bit support)
@
text
@d1 2
a2 2
/*	$OpenBSD: nfs_subs.c,v 1.5 1996/03/31 13:15:53 mickey Exp $	*/
/*	$NetBSD: nfs_subs.c,v 1.26 1996/03/13 00:44:17 fvdl Exp $	*/
d731 1
a731 1
	mreq->m_pkthdr.rcvif = (struct ifnet *)NULL;
d1106 1
a1106 1
		nfs_iodwant[i] = (struct proc *)NULL;
d1209 3
d1214 1
d1371 1
a1371 1
	*retdirp = (struct vnode *)NULL;
d1435 2
a1436 1
	if ((error = lookup(ndp)) != 0)
d1488 1
a1488 1
		if (m->m_next == (struct mbuf *)NULL)
d1654 1
a1654 1
	*vpp = (struct vnode *)NULL;
d1770 1
a1770 1
			return ((nfsuint64 *)NULL);
d1777 1
a1777 1
				return ((nfsuint64 *)NULL);
d1786 1
a1786 1
			return ((nfsuint64 *)NULL);
d1792 1
a1792 1
			return ((nfsuint64 *)NULL);
@


1.5
log
@From NetBSD: NFSv3 import (tomorrow's Net's kernel)
Open's patches kept in. i'll possibly take a look at Lite2 soon,
is there smth usefull ?..
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_subs.c,v 1.4 1996/02/29 09:24:56 niklas Exp $	*/
d731 1
a731 1
	mreq->m_pkthdr.rcvif = (struct ifnet *)0;
d1106 1
a1106 1
		nfs_iodwant[i] = (struct proc *)0;
d1367 1
a1367 1
	*retdirp = (struct vnode *)0;
d1377 1
d1392 1
d1431 1
a1431 2
	error = lookup(ndp);
	if (error)
d1483 1
a1483 1
		if (m->m_next == (struct mbuf *)0)
d1649 1
a1649 1
	*vpp = (struct vnode *)0;
d1765 1
a1765 1
			return ((nfsuint64 *)0);
d1772 1
a1772 1
				return ((nfsuint64 *)0);
d1781 1
a1781 1
			return ((nfsuint64 *)0);
d1787 1
a1787 1
			return ((nfsuint64 *)0);
@


1.4
log
@From NetBSD: merge with 960217 (still NFSv2)
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: nfs_subs.c,v 1.24 1996/02/09 21:48:34 christos Exp $	*/
d39 1
a39 1
 *	@@(#)nfs_subs.c	8.3 (Berkeley) 1/4/94
d42 1
d58 3
d63 1
a63 1
#include <nfs/nfsv2.h>
a81 3
#define TRUE	1
#define	FALSE	0

a85 1
u_long nfs_procids[NFS_NPROCS];
d88 1
a88 1
	rpc_mismatch, rpc_auth_unix, rpc_msgaccepted, rpc_rejectedcred,
d90 1
a90 1
u_int32_t nfs_vers, nfs_prog, nfs_true, nfs_false;
d94 429
a522 1
enum vtype ntov_type[7] = { VNON, VREG, VDIR, VBLK, VCHR, VLNK, VNON };
a523 1
extern int nqnfs_piggy[NFS_NPROCS];
a525 1
extern u_int32_t nqnfs_prog, nqnfs_vers;
d529 6
a536 1
extern struct nfsnodehashhead *nfs_hash __P((nfsv2fh_t *));
d592 2
a593 2
nfsm_rpchead(cr, nqnfs, procid, auth_type, auth_len, auth_str, mrest,
	mrest_len, mbp, xidp)
d595 1
a595 1
	int nqnfs;
d600 2
a614 2
	if (auth_type == RPCAUTH_NQNFS)
		authsiz += 2 * NFSX_UNSIGNED;
d616 1
a616 1
	if ((authsiz + 10*NFSX_UNSIGNED) >= MINCLSIZE) {
d618 2
a619 2
	} else if ((authsiz + 10*NFSX_UNSIGNED) < MHLEN) {
		MH_ALIGN(mb, authsiz + 10*NFSX_UNSIGNED);
d621 1
a621 1
		MH_ALIGN(mb, 8*NFSX_UNSIGNED);
d630 1
a630 1
	nfsm_build(tl, u_int32_t *, 8*NFSX_UNSIGNED);
d636 1
a636 1
	if (nqnfs) {
d638 1
a638 1
		*tl++ = txdr_unsigned(NQNFS_VER1);
d641 4
a644 1
		*tl++ = txdr_unsigned(NFS_VER2);
d646 4
a649 1
	*tl++ = txdr_unsigned(procid);
d668 1
a668 4
	case RPCAUTH_NQNFS:
		nfsm_build(tl, u_int32_t *, 2*NFSX_UNSIGNED);
		*tl++ = txdr_unsigned(cr->cr_uid);
		*tl = txdr_unsigned(auth_len);
d694 35
a728 3
	nfsm_build(tl, u_int32_t *, 2*NFSX_UNSIGNED);
	*tl++ = txdr_unsigned(RPCAUTH_NULL);
	*tl = 0;
d730 1
a730 1
	mreq->m_pkthdr.len = authsiz + 10*NFSX_UNSIGNED + mrest_len;
d1063 22
a1092 1
	rpc_rejectedcred = txdr_unsigned(AUTH_REJECTCRED);
d1094 1
a1094 2
	rpc_auth_kerb = txdr_unsigned(RPCAUTH_NQNFS);
	nfs_vers = txdr_unsigned(NFS_VER2);
d1096 1
d1100 3
a1102 3
	/* Loop thru nfs procids */
	for (i = 0; i < NFS_NPROCS; i++)
		nfs_procids[i] = txdr_unsigned(i);
a1121 2
		nqnfs_prog = txdr_unsigned(NQNFS_PROG);
		nqnfs_vers = txdr_unsigned(NQNFS_VER1);
d1157 1
a1157 1
	register struct nfsv2_fattr *fp;
a1159 1
	register struct nfsnodehashhead *nhpp;
d1161 3
a1163 2
	caddr_t dpos, cp2;
	int error = 0, isnq;
a1166 1
	long rdev;
d1169 1
d1172 2
a1173 4
	dpos = *dposp;
	t1 = (mtod(md, caddr_t) + md->m_len) - dpos;
	isnq = (VFSTONFS(vp->v_mount)->nm_flag & NFSMNT_NQNFS);
	error = nfsm_disct(&md, &dpos, NFSX_FATTR(isnq), t1, &cp2);
d1176 7
a1182 8
	fp = (struct nfsv2_fattr *)cp2;
	vtyp = nfstov_type(fp->fa_type);
	vmode = fxdr_unsigned(u_short, fp->fa_mode);
	if (vtyp == VNON || vtyp == VREG)
		vtyp = IFTOVT(vmode);
	if (isnq) {
		rdev = fxdr_unsigned(int32_t, fp->fa_nqrdev);
		fxdr_nqtime(&fp->fa_nqmtime, &mtime);
d1184 12
a1195 2
		rdev = fxdr_unsigned(int32_t, fp->fa_nfsrdev);
		fxdr_nfstime(&fp->fa_nfsmtime, &mtime);
d1197 1
d1207 1
a1207 4
		if (vtyp == VCHR && rdev == 0xffffffff)
			vp->v_type = vtyp = VFIFO;
		else
			vp->v_type = vtyp;
a1208 1
#ifdef FIFO
a1210 3
#else
			return (EOPNOTSUPP);
#endif /* FIFO */
d1218 2
d1221 4
a1224 1
				LIST_REMOVE(np, n_hash);
a1233 2
				nhpp = nfs_hash(&np->n_fh);
				LIST_INSERT_HEAD(nhpp, np, n_hash);
a1241 3
	vap->va_nlink = fxdr_unsigned(u_short, fp->fa_nlink);
	vap->va_uid = fxdr_unsigned(uid_t, fp->fa_uid);
	vap->va_gid = fxdr_unsigned(gid_t, fp->fa_gid);
d1245 13
a1257 10
	if (isnq) {
		fxdr_hyper(&fp->fa_nqsize, &vap->va_size);
		vap->va_blocksize = fxdr_unsigned(int32_t, fp->fa_nqblocksize);
		fxdr_hyper(&fp->fa_nqbytes, &vap->va_bytes);
		vap->va_fileid = fxdr_unsigned(int32_t, fp->fa_nqfileid);
		fxdr_nqtime(&fp->fa_nqatime, &vap->va_atime);
		vap->va_flags = fxdr_unsigned(u_int32_t, fp->fa_nqflags);
		fxdr_nqtime(&fp->fa_nqctime, &vap->va_ctime);
		vap->va_gen = fxdr_unsigned(u_int32_t, fp->fa_nqgen);
		fxdr_hyper(&fp->fa_nqfilerev, &vap->va_filerev);
d1259 9
a1267 5
		vap->va_size = fxdr_unsigned(u_int32_t, fp->fa_nfssize);
		vap->va_blocksize = fxdr_unsigned(int32_t, fp->fa_nfsblocksize);
		vap->va_bytes = fxdr_unsigned(int32_t, fp->fa_nfsblocks) * NFS_FABLKSIZE;
		vap->va_fileid = fxdr_unsigned(int32_t, fp->fa_nfsfileid);
		fxdr_nfstime(&fp->fa_nfsatime, &vap->va_atime);
d1269 4
a1272 2
		fxdr_nfstime(&fp->fa_nfsctime, &vap->va_ctime);
		vap->va_gen = 0;
a1288 2
	*dposp = dpos;
	*mdp = md;
a1290 5
#ifdef notdef
		if ((np->n_flag & NMODIFIED) && np->n_size > vap->va_size)
		if (np->n_size > vap->va_size)
			vaper->va_size = np->n_size;
#endif
d1292 4
a1295 10
			if (np->n_flag & NACC) {
				vaper->va_atime.tv_sec = np->n_atim.tv_sec;
				vaper->va_atime.tv_nsec =
				    np->n_atim.tv_usec * 1000;
			}
			if (np->n_flag & NUPD) {
				vaper->va_mtime.tv_sec = np->n_mtim.tv_sec;
				vaper->va_mtime.tv_nsec =
				    np->n_mtim.tv_usec * 1000;
			}
d1314 1
a1314 6
	if (VFSTONFS(vp->v_mount)->nm_flag & NFSMNT_NQLOOKLEASE) {
		if (!NQNFS_CKCACHABLE(vp, NQL_READ) || np->n_attrstamp == 0) {
			nfsstats.attrcache_misses++;
			return (ENOENT);
		}
	} else if ((time.tv_sec - np->n_attrstamp) >= NFS_ATTRTIMEO(np)) {
a1333 8
#ifdef notdef
	if ((np->n_flag & NMODIFIED) == 0) {
		np->n_size = vaper->va_size;
		vnode_pager_setsize(vp, (u_long)np->n_size);
	} else if (np->n_size > vaper->va_size)
	if (np->n_size > vaper->va_size)
		vaper->va_size = np->n_size;
#endif
d1335 4
a1338 8
		if (np->n_flag & NACC) {
			vaper->va_atime.tv_sec = np->n_atim.tv_sec;
			vaper->va_atime.tv_nsec = np->n_atim.tv_usec * 1000;
		}
		if (np->n_flag & NUPD) {
			vaper->va_mtime.tv_sec = np->n_mtim.tv_sec;
			vaper->va_mtime.tv_nsec = np->n_mtim.tv_usec * 1000;
		}
d1342 1
a1342 1
#endif
d1348 1
a1348 1
nfs_namei(ndp, fhp, len, slp, nam, mdp, dposp, p)
d1356 1
d1358 1
d1367 1
d1388 1
a1388 1
			error = EINVAL;
d1410 1
a1410 1
			     nam, &rdonly);
d1418 2
d1429 2
a1430 1
	if ((error = lookup(ndp)) != 0)
d1515 1
a1515 1
	while ((m = m->m_next) != NULL)
d1520 103
d1630 1
a1630 1
nfsrv_fhtovp(fhp, lockflag, vpp, cred, slp, nam, rdonlyp)
d1638 1
d1640 3
a1643 1
	register struct nfsuid *uidp;
d1649 6
a1654 1
	if ((mp = getvfs(&fhp->fh_fsid)) == NULL)
d1663 1
a1663 6
		for (uidp = NUIDHASH(slp, cred->cr_uid)->lh_first; uidp != 0;
		    uidp = uidp->nu_hash.le_next) {
			if (uidp->nu_uid == cred->cr_uid)
				break;
		}
		if (uidp == 0) {
d1665 1
a1665 1
			return (NQNFS_AUTHERR);
d1667 3
a1669 5
		cred->cr_uid = uidp->nu_cr.cr_uid;
		cred->cr_gid = uidp->nu_cr.cr_gid;
		for (i = 0; i < uidp->nu_cr.cr_ngroups; i++)
			cred->cr_groups[i] = uidp->nu_cr.cr_groups[i];
		cred->cr_ngroups = i;
d1682 3
d1686 1
d1731 183
@


1.3
log
@graichen@@freebsd.org: fixed -type:=direct mounts in amd
@
text
@d1 2
a2 1
/*	$NetBSD: nfs_subs.c,v 1.22 1995/12/19 23:07:43 cgd Exp $	*/
d67 1
d71 2
d273 1
d348 1
d436 1
d499 1
d526 1
d533 1
a533 1
	register struct mbuf *m1, *m2;
d592 1
d645 1
a645 1
	nfs_timer();
d663 1
d673 1
a673 1
	extern int (**spec_nfsv2nodeop_p)();
d690 2
a691 1
	if (error = nfsm_disct(&md, &dpos, NFSX_FATTR(isnq), t1, &cp2))
d720 1
a720 1
			extern int (**fifo_nfsv2nodeop_p)();
d728 2
a729 1
			if (nvp = checkalias(vp, (dev_t)rdev, vp->v_mount)) {
d748 1
a748 1
		np->n_mtime = mtime.ts_sec;
d805 2
a806 2
				vaper->va_atime.ts_sec = np->n_atim.tv_sec;
				vaper->va_atime.ts_nsec =
d810 2
a811 2
				vaper->va_mtime.ts_sec = np->n_mtim.tv_sec;
				vaper->va_mtime.ts_nsec =
d824 1
d867 2
a868 2
			vaper->va_atime.ts_sec = np->n_atim.tv_sec;
			vaper->va_atime.ts_nsec = np->n_atim.tv_usec * 1000;
d871 2
a872 2
			vaper->va_mtime.ts_sec = np->n_mtim.tv_sec;
			vaper->va_mtime.ts_nsec = np->n_mtim.tv_usec * 1000;
d882 1
d933 1
a933 1
		else if (error = nfs_adv(mdp, dposp, len, rem))
d941 3
a943 2
	if (error = nfsrv_fhtovp(fhp, FALSE, &dp, ndp->ni_cnd.cn_cred, slp,
	    nam, &rdonly))
d959 1
a959 1
	if (error = lookup(ndp))
d1044 1
a1044 1
	while (m = m->m_next)
d1055 1
d1074 2
a1075 1
	if (error = VFS_FHTOVP(mp, &fhp->fh_fid, nam, vpp, &exflags, &credanon))
d1118 1
@


1.2
log
@from cgd; handle 64-bit pointers and longs
@
text
@d701 1
a701 1
	if (vp->v_type == VNON) {
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: nfs_subs.c,v 1.21 1995/09/08 13:52:23 ws Exp $	*/
d82 2
a83 2
u_long nfs_xdrneg1;
u_long rpc_call, rpc_vers, rpc_reply, rpc_msgdenied, rpc_autherr,
d86 1
a86 1
u_long nfs_vers, nfs_prog, nfs_true, nfs_false;
d89 1
a89 1
static u_long nfs_xid = 0;
d95 1
a95 1
extern u_long nqnfs_prog, nqnfs_vers;
d116 1
a116 1
	register u_long *tl;
d136 1
a136 1
				nfsm_build(tl, u_long *, 2*NFSX_UNSIGNED);
d140 1
a140 1
				nfsm_build(tl, u_long *, NFSX_UNSIGNED);
d168 1
a168 1
	u_long *xidp;
d171 1
a171 1
	register u_long *tl;
d195 1
a195 1
	nfsm_build(tl, u_long *, 8*NFSX_UNSIGNED);
d217 1
a217 1
		nfsm_build(tl, u_long *, auth_len);
d228 1
a228 1
		nfsm_build(tl, u_long *, 2*NFSX_UNSIGNED);
d256 1
a256 1
	nfsm_build(tl, u_long *, 2*NFSX_UNSIGNED);
d526 1
a526 1
	u_long *tl;
d533 1
a533 1
		tl = ((u_long *)(*bpos));
d554 1
a554 1
		tl = mtod(m1, u_long *);
d665 1
a665 1
	register long t1;
d687 1
a687 1
		rdev = fxdr_unsigned(long, fp->fa_nqrdev);
d690 1
a690 1
		rdev = fxdr_unsigned(long, fp->fa_nfsrdev);
d748 1
a748 1
		vap->va_blocksize = fxdr_unsigned(long, fp->fa_nqblocksize);
d750 1
a750 1
		vap->va_fileid = fxdr_unsigned(long, fp->fa_nqfileid);
d752 1
a752 1
		vap->va_flags = fxdr_unsigned(u_long, fp->fa_nqflags);
d754 1
a754 1
		vap->va_gen = fxdr_unsigned(u_long, fp->fa_nqgen);
d757 4
a760 4
		vap->va_size = fxdr_unsigned(u_long, fp->fa_nfssize);
		vap->va_blocksize = fxdr_unsigned(long, fp->fa_nfsblocksize);
		vap->va_bytes = fxdr_unsigned(long, fp->fa_nfsblocks) * NFS_FABLKSIZE;
		vap->va_fileid = fxdr_unsigned(long, fp->fa_nfsfileid);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
