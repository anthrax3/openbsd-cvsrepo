head	1.115;
access;
symbols
	OPENBSD_6_1:1.114.0.4
	OPENBSD_6_1_BASE:1.114
	OPENBSD_6_0:1.111.0.4
	OPENBSD_6_0_BASE:1.111
	OPENBSD_5_9:1.111.0.2
	OPENBSD_5_9_BASE:1.111
	OPENBSD_5_8:1.110.0.4
	OPENBSD_5_8_BASE:1.110
	OPENBSD_5_7:1.107.0.2
	OPENBSD_5_7_BASE:1.107
	OPENBSD_5_6:1.105.0.4
	OPENBSD_5_6_BASE:1.105
	OPENBSD_5_5:1.103.0.4
	OPENBSD_5_5_BASE:1.103
	OPENBSD_5_4:1.102.0.2
	OPENBSD_5_4_BASE:1.102
	OPENBSD_5_3:1.101.0.8
	OPENBSD_5_3_BASE:1.101
	OPENBSD_5_2:1.101.0.6
	OPENBSD_5_2_BASE:1.101
	OPENBSD_5_1_BASE:1.101
	OPENBSD_5_1:1.101.0.4
	OPENBSD_5_0:1.101.0.2
	OPENBSD_5_0_BASE:1.101
	OPENBSD_4_9:1.98.0.4
	OPENBSD_4_9_BASE:1.98
	OPENBSD_4_8:1.98.0.2
	OPENBSD_4_8_BASE:1.98
	OPENBSD_4_7:1.96.0.2
	OPENBSD_4_7_BASE:1.96
	OPENBSD_4_6:1.85.0.4
	OPENBSD_4_6_BASE:1.85
	OPENBSD_4_5:1.78.0.2
	OPENBSD_4_5_BASE:1.78
	OPENBSD_4_4:1.67.0.2
	OPENBSD_4_4_BASE:1.67
	OPENBSD_4_3:1.57.0.2
	OPENBSD_4_3_BASE:1.57
	OPENBSD_4_2:1.49.0.2
	OPENBSD_4_2_BASE:1.49
	OPENBSD_4_1:1.46.0.2
	OPENBSD_4_1_BASE:1.46
	OPENBSD_4_0:1.44.0.2
	OPENBSD_4_0_BASE:1.44
	OPENBSD_3_9:1.43.0.2
	OPENBSD_3_9_BASE:1.43
	OPENBSD_3_8:1.42.0.2
	OPENBSD_3_8_BASE:1.42
	OPENBSD_3_7:1.41.0.2
	OPENBSD_3_7_BASE:1.41
	OPENBSD_3_6:1.39.0.2
	OPENBSD_3_6_BASE:1.39
	SMP_SYNC_A:1.35
	SMP_SYNC_B:1.35
	OPENBSD_3_5:1.35.0.2
	OPENBSD_3_5_BASE:1.35
	OPENBSD_3_4:1.34.0.2
	OPENBSD_3_4_BASE:1.34
	UBC_SYNC_A:1.32
	OPENBSD_3_3:1.32.0.2
	OPENBSD_3_3_BASE:1.32
	OPENBSD_3_2:1.31.0.2
	OPENBSD_3_2_BASE:1.31
	OPENBSD_3_1:1.26.0.2
	OPENBSD_3_1_BASE:1.26
	UBC_SYNC_B:1.31
	UBC:1.22.0.4
	UBC_BASE:1.22
	OPENBSD_3_0:1.22.0.2
	OPENBSD_3_0_BASE:1.22
	OPENBSD_2_9_BASE:1.20
	OPENBSD_2_9:1.20.0.2
	OPENBSD_2_8:1.19.0.2
	OPENBSD_2_8_BASE:1.19
	OPENBSD_2_7:1.16.0.4
	OPENBSD_2_7_BASE:1.16
	SMP:1.16.0.2
	SMP_BASE:1.16
	kame_19991208:1.15
	OPENBSD_2_6:1.15.0.4
	OPENBSD_2_6_BASE:1.15
	OPENBSD_2_5:1.15.0.2
	OPENBSD_2_5_BASE:1.15
	OPENBSD_2_4:1.13.0.2
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.12.0.4
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.12.0.2
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.11.0.2
	OPENBSD_2_1_BASE:1.11
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.115
date	2017.05.08.09.11.20;	author mpi;	state Exp;
branches;
next	1.114;
commitid	SjSDMce3oBjiPQj5;

1.114
date	2017.03.03.09.41.20;	author mpi;	state Exp;
branches;
next	1.113;
commitid	KFfoA9Sc5ZswSFTf;

1.113
date	2017.02.22.11.42.46;	author mpi;	state Exp;
branches;
next	1.112;
commitid	QPdM5oUknMlUIDue;

1.112
date	2016.12.19.08.36.50;	author mpi;	state Exp;
branches;
next	1.111;
commitid	QqHqT2WhCBWqYgGJ;

1.111
date	2015.08.24.14.00.29;	author bluhm;	state Exp;
branches;
next	1.110;
commitid	0LcoZC9QTu9wgpyX;

1.110
date	2015.07.15.22.16.42;	author deraadt;	state Exp;
branches;
next	1.109;
commitid	ncpqEGjDtSFuLAgn;

1.109
date	2015.06.11.16.00.36;	author mikeb;	state Exp;
branches;
next	1.108;
commitid	w8IDt6Gom39hMclD;

1.108
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.107;
commitid	p4LJxGKbi0BU2cG6;

1.107
date	2015.01.17.17.49.27;	author deraadt;	state Exp;
branches;
next	1.106;
commitid	buV4jzMNnBVDajYs;

1.106
date	2014.11.14.23.01.44;	author tedu;	state Exp;
branches;
next	1.105;
commitid	IWzLFxf7O2DJPe2b;

1.105
date	2014.04.18.13.35.31;	author kettenis;	state Exp;
branches;
next	1.104;

1.104
date	2014.03.22.06.05.45;	author guenther;	state Exp;
branches;
next	1.103;

1.103
date	2014.01.19.03.04.54;	author claudio;	state Exp;
branches;
next	1.102;

1.102
date	2013.07.04.20.05.55;	author sf;	state Exp;
branches;
next	1.101;

1.101
date	2011.07.05.04.48.02;	author guenther;	state Exp;
branches;
next	1.100;

1.100
date	2011.04.18.21.44.56;	author guenther;	state Exp;
branches;
next	1.99;

1.99
date	2011.04.15.04.52.40;	author guenther;	state Exp;
branches;
next	1.98;

1.98
date	2010.07.05.16.32.07;	author deraadt;	state Exp;
branches;
next	1.97;

1.97
date	2010.07.02.02.40.17;	author blambert;	state Exp;
branches;
next	1.96;

1.96
date	2009.10.19.22.24.18;	author jsg;	state Exp;
branches;
next	1.95;

1.95
date	2009.08.25.13.41.29;	author thib;	state Exp;
branches;
next	1.94;

1.94
date	2009.08.10.09.38.44;	author thib;	state Exp;
branches;
next	1.93;

1.93
date	2009.08.04.17.12.39;	author thib;	state Exp;
branches;
next	1.92;

1.92
date	2009.07.30.14.04.28;	author thib;	state Exp;
branches;
next	1.91;

1.91
date	2009.07.22.13.04.56;	author blambert;	state Exp;
branches;
next	1.90;

1.90
date	2009.07.20.16.49.40;	author thib;	state Exp;
branches;
next	1.89;

1.89
date	2009.07.20.11.47.58;	author blambert;	state Exp;
branches;
next	1.88;

1.88
date	2009.07.18.20.30.22;	author thib;	state Exp;
branches;
next	1.87;

1.87
date	2009.07.18.14.40.31;	author thib;	state Exp;
branches;
next	1.86;

1.86
date	2009.07.13.15.39.55;	author thib;	state Exp;
branches;
next	1.85;

1.85
date	2009.06.04.19.19.27;	author blambert;	state Exp;
branches;
next	1.84;

1.84
date	2009.06.03.02.23.23;	author thib;	state Exp;
branches;
next	1.83;

1.83
date	2009.06.03.00.12.34;	author thib;	state Exp;
branches;
next	1.82;

1.82
date	2009.06.02.23.16.59;	author thib;	state Exp;
branches;
next	1.81;

1.81
date	2009.05.30.17.20.29;	author thib;	state Exp;
branches;
next	1.80;

1.80
date	2009.05.22.00.19.25;	author thib;	state Exp;
branches;
next	1.79;

1.79
date	2009.05.15.12.07.18;	author thib;	state Exp;
branches;
next	1.78;

1.78
date	2009.02.22.07.47.22;	author otto;	state Exp;
branches;
next	1.77;

1.77
date	2009.01.24.23.35.47;	author thib;	state Exp;
branches;
next	1.76;

1.76
date	2009.01.24.11.40.06;	author thib;	state Exp;
branches;
next	1.75;

1.75
date	2009.01.22.18.14.21;	author bluhm;	state Exp;
branches;
next	1.74;

1.74
date	2009.01.22.13.51.37;	author bluhm;	state Exp;
branches;
next	1.73;

1.73
date	2009.01.20.18.03.33;	author blambert;	state Exp;
branches;
next	1.72;

1.72
date	2009.01.16.17.11.28;	author thib;	state Exp;
branches;
next	1.71;

1.71
date	2008.12.24.02.43.52;	author thib;	state Exp;
branches;
next	1.70;

1.70
date	2008.10.31.17.28.47;	author blambert;	state Exp;
branches;
next	1.69;

1.69
date	2008.10.26.15.53.16;	author blambert;	state Exp;
branches;
next	1.68;

1.68
date	2008.09.12.15.41.40;	author thib;	state Exp;
branches;
next	1.67;

1.67
date	2008.07.10.18.17.56;	author thib;	state Exp;
branches;
next	1.66;

1.66
date	2008.07.05.18.28.08;	author blambert;	state Exp;
branches;
next	1.65;

1.65
date	2008.07.05.17.34.26;	author thib;	state Exp;
branches;
next	1.64;

1.64
date	2008.06.14.03.16.06;	author thib;	state Exp;
branches;
next	1.63;

1.63
date	2008.06.14.01.21.17;	author blambert;	state Exp;
branches;
next	1.62;

1.62
date	2008.06.13.03.54.26;	author blambert;	state Exp;
branches;
next	1.61;

1.61
date	2008.06.12.20.24.06;	author blambert;	state Exp;
branches;
next	1.60;

1.60
date	2008.06.11.04.52.27;	author blambert;	state Exp;
branches;
next	1.59;

1.59
date	2008.05.23.15.51.12;	author thib;	state Exp;
branches;
next	1.58;

1.58
date	2008.05.13.17.47.42;	author thib;	state Exp;
branches;
next	1.57;

1.57
date	2008.01.06.17.38.23;	author blambert;	state Exp;
branches;
next	1.56;

1.56
date	2007.12.28.17.25.18;	author thib;	state Exp;
branches;
next	1.55;

1.55
date	2007.10.28.14.12.41;	author thib;	state Exp;
branches;
next	1.54;

1.54
date	2007.10.17.17.44.23;	author thib;	state Exp;
branches;
next	1.53;

1.53
date	2007.10.15.21.09.44;	author thib;	state Exp;
branches;
next	1.52;

1.52
date	2007.10.13.17.38.43;	author thib;	state Exp;
branches;
next	1.51;

1.51
date	2007.09.20.15.30.41;	author blambert;	state Exp;
branches;
next	1.50;

1.50
date	2007.09.20.12.54.31;	author thib;	state Exp;
branches;
next	1.49;

1.49
date	2007.06.25.20.40.00;	author thib;	state Exp;
branches;
next	1.48;

1.48
date	2007.05.31.23.04.09;	author thib;	state Exp;
branches;
next	1.47;

1.47
date	2007.04.24.18.15.04;	author thib;	state Exp;
branches;
next	1.46;

1.46
date	2006.10.28.20.56.46;	author thib;	state Exp;
branches;
next	1.45;

1.45
date	2006.09.20.21.56.21;	author thib;	state Exp;
branches;
next	1.44;

1.44
date	2006.08.04.12.35.57;	author pedro;	state Exp;
branches;
next	1.43;

1.43
date	2006.01.24.15.06.41;	author aaron;	state Exp;
branches;
next	1.42;

1.42
date	2005.04.02.01.00.38;	author mickey;	state Exp;
branches;
next	1.41;

1.41
date	2004.12.26.21.22.13;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2004.12.10.19.55.21;	author millert;	state Exp;
branches;
next	1.39;

1.39
date	2004.07.14.18.32.34;	author pedro;	state Exp;
branches;
next	1.38;

1.38
date	2004.07.10.20.39.15;	author marius;	state Exp;
branches;
next	1.37;

1.37
date	2004.06.24.19.35.26;	author tholo;	state Exp;
branches;
next	1.36;

1.36
date	2004.06.21.23.50.38;	author tholo;	state Exp;
branches;
next	1.35;

1.35
date	2003.12.08.09.33.36;	author mickey;	state Exp;
branches;
next	1.34;

1.34
date	2003.07.10.22.53.19;	author tedu;	state Exp;
branches;
next	1.33;

1.33
date	2003.06.02.23.28.19;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2002.10.29.12.47.06;	author art;	state Exp;
branches;
next	1.31;

1.31
date	2002.08.01.22.38.44;	author csapuntz;	state Exp;
branches;
next	1.30;

1.30
date	2002.07.30.19.00.43;	author csapuntz;	state Exp;
branches;
next	1.29;

1.29
date	2002.07.03.20.57.00;	author nate;	state Exp;
branches;
next	1.28;

1.28
date	2002.06.11.15.45.44;	author hin;	state Exp;
branches;
next	1.27;

1.27
date	2002.05.17.18.41.01;	author csapuntz;	state Exp;
branches;
next	1.26;

1.26
date	2002.04.11.18.44.24;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2002.04.10.18.16.46;	author csapuntz;	state Exp;
branches;
next	1.24;

1.24
date	2002.03.14.01.27.13;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2002.01.16.21.51.16;	author ericj;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.25.03.28.09;	author csapuntz;	state Exp;
branches
	1.22.4.1;
next	1.21;

1.21
date	2001.05.20.08.32.35;	author angelos;	state Exp;
branches;
next	1.20;

1.20
date	2001.03.28.20.03.08;	author angelos;	state Exp;
branches;
next	1.19;

1.19
date	2000.08.10.16.28.42;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2000.08.07.17.12.15;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2000.06.26.22.48.14;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2000.01.04.16.03.00;	author itojun;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	99.03.02.20.59.55;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	99.02.06.23.07.44;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	98.08.19.22.26.53;	author csapuntz;	state Exp;
branches;
next	1.12;

1.12
date	97.07.28.19.54.17;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.04.25.09.22.31;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.04.18.10.13.27;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.04.18.09.58.11;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.12.24.20.14.29;	author dm;	state Exp;
branches;
next	1.7;

1.7
date	96.07.03.07.10.33;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.04.21.22.30.26;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.04.17.04.50.29;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.03.31.13.15.47;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.02.29.09.24.53;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.21.14.42.23;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.22;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.22;	author deraadt;	state Exp;
branches;
next	;

1.16.2.1
date	2001.05.14.22.44.57;	author niklas;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2001.07.04.10.55.49;	author niklas;	state Exp;
branches;
next	1.16.2.3;

1.16.2.3
date	2002.03.06.02.17.12;	author niklas;	state Exp;
branches;
next	1.16.2.4;

1.16.2.4
date	2002.03.28.15.02.48;	author niklas;	state Exp;
branches;
next	1.16.2.5;

1.16.2.5
date	2003.03.28.00.08.46;	author niklas;	state Exp;
branches;
next	1.16.2.6;

1.16.2.6
date	2003.06.07.11.07.43;	author ho;	state Exp;
branches;
next	1.16.2.7;

1.16.2.7
date	2004.02.19.10.57.26;	author niklas;	state Exp;
branches;
next	;

1.22.4.1
date	2002.01.31.22.55.47;	author niklas;	state Exp;
branches;
next	1.22.4.2;

1.22.4.2
date	2002.02.02.03.28.26;	author art;	state Exp;
branches;
next	1.22.4.3;

1.22.4.3
date	2002.06.11.03.32.04;	author art;	state Exp;
branches;
next	1.22.4.4;

1.22.4.4
date	2002.10.29.00.36.49;	author art;	state Exp;
branches;
next	1.22.4.5;

1.22.4.5
date	2003.05.19.22.36.43;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.115
log
@Sync nfs_connect() w/ sys_connect().

ok bluhm@@
@
text
@/*	$OpenBSD: nfs_socket.c,v 1.114 2017/03/03 09:41:20 mpi Exp $	*/
/*	$NetBSD: nfs_socket.c,v 1.27 1996/04/15 20:20:00 thorpej Exp $	*/

/*
 * Copyright (c) 1989, 1991, 1993, 1995
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Rick Macklem at The University of Guelph.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)nfs_socket.c	8.5 (Berkeley) 3/30/95
 */

/*
 * Socket operations for use by nfs
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/mount.h>
#include <sys/kernel.h>
#include <sys/mbuf.h>
#include <sys/vnode.h>
#include <sys/domain.h>
#include <sys/protosw.h>
#include <sys/signalvar.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/syslog.h>
#include <sys/tprintf.h>
#include <sys/namei.h>
#include <sys/pool.h>
#include <sys/queue.h>

#include <netinet/in.h>
#include <netinet/tcp.h>

#include <nfs/rpcv2.h>
#include <nfs/nfsproto.h>
#include <nfs/nfs.h>
#include <nfs/xdr_subs.h>
#include <nfs/nfsm_subs.h>
#include <nfs/nfsmount.h>
#include <nfs/nfs_var.h>

/* External data, mostly RPC constants in XDR form. */
extern u_int32_t rpc_reply, rpc_msgdenied, rpc_mismatch, rpc_vers,
	rpc_auth_unix, rpc_msgaccepted, rpc_call, rpc_autherr;
extern u_int32_t nfs_prog;
extern struct nfsstats nfsstats;
extern int nfsv3_procid[NFS_NPROCS];
extern int nfs_ticks;

extern struct pool nfsrv_descript_pl;

/*
 * There is a congestion window for outstanding rpcs maintained per mount
 * point. The cwnd size is adjusted in roughly the way that:
 * Van Jacobson, Congestion avoidance and Control, In "Proceedings of
 * SIGCOMM '88". ACM, August 1988.
 * describes for TCP. The cwnd size is chopped in half on a retransmit timeout
 * and incremented by 1/cwnd when each rpc reply is received and a full cwnd
 * of rpcs is in progress.
 * (The sent count and cwnd are scaled for integer arith.)
 * Variants of "slow start" were tried and were found to be too much of a
 * performance hit (ave. rtt 3 times larger),
 * I suspect due to the large rtt that nfs rpcs have.
 */
#define	NFS_CWNDSCALE	256
#define	NFS_MAXCWND	(NFS_CWNDSCALE * 32)
int nfs_backoff[8] = { 2, 4, 8, 16, 32, 64, 128, 256 };

/* RTT estimator */
enum nfs_rto_timers nfs_ptimers[NFS_NPROCS] = {
	NFS_DEFAULT_TIMER,	/* NULL */
	NFS_GETATTR_TIMER,	/* GETATTR */
	NFS_DEFAULT_TIMER,	/* SETATTR */
	NFS_LOOKUP_TIMER,	/* LOOKUP */
	NFS_GETATTR_TIMER,	/* ACCESS */
	NFS_READ_TIMER,		/* READLINK */
	NFS_READ_TIMER,		/* READ */
	NFS_WRITE_TIMER,	/* WRITE */
	NFS_DEFAULT_TIMER,	/* CREATE */
	NFS_DEFAULT_TIMER,	/* MKDIR */
	NFS_DEFAULT_TIMER,	/* SYMLINK */
	NFS_DEFAULT_TIMER,	/* MKNOD */
	NFS_DEFAULT_TIMER,	/* REMOVE */
	NFS_DEFAULT_TIMER,	/* RMDIR */
	NFS_DEFAULT_TIMER,	/* RENAME */
	NFS_DEFAULT_TIMER,	/* LINK */
	NFS_READ_TIMER,		/* READDIR */
	NFS_READ_TIMER,		/* READDIRPLUS */
	NFS_DEFAULT_TIMER,	/* FSSTAT */
	NFS_DEFAULT_TIMER,	/* FSINFO */
	NFS_DEFAULT_TIMER,	/* PATHCONF */
	NFS_DEFAULT_TIMER,	/* COMMIT */
	NFS_DEFAULT_TIMER,	/* NOOP */
};

void nfs_init_rtt(struct nfsmount *);
void nfs_update_rtt(struct nfsreq *);
int  nfs_estimate_rto(struct nfsmount *, u_int32_t procnum);

void nfs_realign(struct mbuf **, int);
void nfs_realign_fixup(struct mbuf *, struct mbuf *, unsigned int *);

int nfs_rcvlock(struct nfsreq *);
int nfs_receive(struct nfsreq *, struct mbuf **, struct mbuf **);
int nfs_reconnect(struct nfsreq *);
int nfs_reply(struct nfsreq *);
void nfs_msg(struct nfsreq *, char *);
void nfs_rcvunlock(int *);

int nfsrv_getstream(struct nfssvc_sock *, int);

unsigned int nfs_realign_test = 0;
unsigned int nfs_realign_count = 0;

/* Initialize the RTT estimator state for a new mount point. */
void
nfs_init_rtt(struct nfsmount *nmp)
{
	int i;

	for (i = 0; i < NFS_MAX_TIMER; i++)
		nmp->nm_srtt[i] = NFS_INITRTT;
	for (i = 0; i < NFS_MAX_TIMER; i++)
		nmp->nm_sdrtt[i] = 0;
}

/*
 * Update a mount point's RTT estimator state using data from the
 * passed-in request.
 * 
 * Use a gain of 0.125 on the mean and a gain of 0.25 on the deviation.
 *
 * NB: Since the timer resolution of NFS_HZ is so course, it can often
 * result in r_rtt == 0. Since r_rtt == N means that the actual RTT is
 * between N + dt and N + 2 - dt ticks, add 1 before calculating the
 * update values.
 */
void
nfs_update_rtt(struct nfsreq *rep)
{
	int t1 = rep->r_rtt + 1;
	int index = nfs_ptimers[rep->r_procnum] - 1;
	int *srtt = &rep->r_nmp->nm_srtt[index];
	int *sdrtt = &rep->r_nmp->nm_sdrtt[index];

	t1 -= *srtt >> 3;
	*srtt += t1;
	if (t1 < 0)
		t1 = -t1;
	t1 -= *sdrtt >> 2;
	*sdrtt += t1;
}

/*
 * Estimate RTO for an NFS RPC sent via an unreliable datagram.
 *
 * Use the mean and mean deviation of RTT for the appropriate type
 * of RPC for the frequent RPCs and a default for the others.
 * The justification for doing "other" this way is that these RPCs
 * happen so infrequently that timer est. would probably be stale.
 * Also, since many of these RPCs are non-idempotent, a conservative
 * timeout is desired.
 *
 * getattr, lookup - A+2D
 * read, write     - A+4D
 * other           - nm_timeo
 */
int
nfs_estimate_rto(struct nfsmount *nmp, u_int32_t procnum)
{
	enum nfs_rto_timers timer = nfs_ptimers[procnum];
	int index = timer - 1;
	int rto;

	switch (timer) {
	case NFS_GETATTR_TIMER:
	case NFS_LOOKUP_TIMER:
		rto = ((nmp->nm_srtt[index] + 3) >> 2) +
				((nmp->nm_sdrtt[index] + 1) >> 1);
		break;
	case NFS_READ_TIMER:
	case NFS_WRITE_TIMER:
		rto = ((nmp->nm_srtt[index] + 7) >> 3) +
				(nmp->nm_sdrtt[index] + 1);
		break;
	default:
		rto = nmp->nm_timeo;
		return (rto);
	}

	if (rto < NFS_MINRTO)
		rto = NFS_MINRTO;
	else if (rto > NFS_MAXRTO)
		rto = NFS_MAXRTO;

	return (rto);
}



/*
 * Initialize sockets and congestion for a new NFS connection.
 * We do not free the sockaddr if error.
 */
int
nfs_connect(struct nfsmount *nmp, struct nfsreq *rep)
{
	struct socket *so;
	int s, error, rcvreserve, sndreserve;
	struct sockaddr *saddr;
	struct sockaddr_in *sin;
	struct mbuf *m;

	nmp->nm_so = NULL;
	saddr = mtod(nmp->nm_nam, struct sockaddr *);
	error = socreate(saddr->sa_family, &nmp->nm_so, nmp->nm_sotype, 
		nmp->nm_soproto);
	if (error)
		goto bad;
	so = nmp->nm_so;
	nmp->nm_soflags = so->so_proto->pr_flags;

	/*
	 * Some servers require that the client port be a reserved port number.
	 * We always allocate a reserved port, as this prevents filehandle
	 * disclosure through UDP port capture.
	 */
	if (saddr->sa_family == AF_INET) {
		struct mbuf *mopt;
		int *ip;

		MGET(mopt, M_WAIT, MT_SOOPTS);
		mopt->m_len = sizeof(int);
		ip = mtod(mopt, int *);
		*ip = IP_PORTRANGE_LOW;
		error = sosetopt(so, IPPROTO_IP, IP_PORTRANGE, mopt);
		if (error)
			goto bad;

		MGET(m, M_WAIT, MT_SONAME);
		sin = mtod(m, struct sockaddr_in *);
		memset(sin, 0, sizeof(*sin));
		sin->sin_len = m->m_len = sizeof(struct sockaddr_in);
		sin->sin_family = AF_INET;
		sin->sin_addr.s_addr = INADDR_ANY;
		sin->sin_port = htons(0);
		error = sobind(so, m, &proc0);
		m_freem(m);
		if (error)
			goto bad;

		MGET(mopt, M_WAIT, MT_SOOPTS);
		mopt->m_len = sizeof(int);
		ip = mtod(mopt, int *);
		*ip = IP_PORTRANGE_DEFAULT;
		error = sosetopt(so, IPPROTO_IP, IP_PORTRANGE, mopt);
		if (error)
			goto bad;
	}

	/*
	 * Protocols that do not require connections may be optionally left
	 * unconnected for servers that reply from a port other than NFS_PORT.
	 */
	if (nmp->nm_flag & NFSMNT_NOCONN) {
		if (nmp->nm_soflags & PR_CONNREQUIRED) {
			error = ENOTCONN;
			goto bad;
		}
	} else {
		error = soconnect(so, nmp->nm_nam);
		if (error)
			goto bad;

		/*
		 * Wait for the connection to complete. Cribbed from the
		 * connect system call but with the wait timing out so
		 * that interruptible mounts don't hang here for a long time.
		 */
		s = solock(so);
		while ((so->so_state & SS_ISCONNECTING) && so->so_error == 0) {
			sosleep(so, &so->so_timeo, PSOCK, "nfscon", 2 * hz);
			if ((so->so_state & SS_ISCONNECTING) &&
			    so->so_error == 0 && rep &&
			    (error = nfs_sigintr(nmp, rep, rep->r_procp)) != 0){
				so->so_state &= ~SS_ISCONNECTING;
				sounlock(s);
				goto bad;
			}
		}
		if (so->so_error) {
			error = so->so_error;
			so->so_error = 0;
			sounlock(s);
			goto bad;
		}
		sounlock(s);
	}
	/*
	 * Always set receive timeout to detect server crash and reconnect.
	 * Otherwise, we can get stuck in soreceive forever.
	 */
	so->so_rcv.sb_timeo = (5 * hz);
	if (nmp->nm_flag & (NFSMNT_SOFT | NFSMNT_INT))
		so->so_snd.sb_timeo = (5 * hz);
	else
		so->so_snd.sb_timeo = 0;
	if (nmp->nm_sotype == SOCK_DGRAM) {
		sndreserve = nmp->nm_wsize + NFS_MAXPKTHDR;
		rcvreserve = (max(nmp->nm_rsize, nmp->nm_readdirsize) +
		    NFS_MAXPKTHDR) * 2;
	} else if (nmp->nm_sotype == SOCK_SEQPACKET) {
		sndreserve = (nmp->nm_wsize + NFS_MAXPKTHDR) * 2;
		rcvreserve = (max(nmp->nm_rsize, nmp->nm_readdirsize) +
		    NFS_MAXPKTHDR) * 2;
	} else {
		if (nmp->nm_sotype != SOCK_STREAM)
			panic("nfscon sotype");
		if (so->so_proto->pr_flags & PR_CONNREQUIRED) {
			MGET(m, M_WAIT, MT_SOOPTS);
			*mtod(m, int32_t *) = 1;
			m->m_len = sizeof(int32_t);
			sosetopt(so, SOL_SOCKET, SO_KEEPALIVE, m);
		}
		if (so->so_proto->pr_protocol == IPPROTO_TCP) {
			MGET(m, M_WAIT, MT_SOOPTS);
			*mtod(m, int32_t *) = 1;
			m->m_len = sizeof(int32_t);
			sosetopt(so, IPPROTO_TCP, TCP_NODELAY, m);
		}
		sndreserve = (nmp->nm_wsize + NFS_MAXPKTHDR +
		    sizeof (u_int32_t)) * 2;
		rcvreserve = (nmp->nm_rsize + NFS_MAXPKTHDR +
		    sizeof (u_int32_t)) * 2;
	}
	error = soreserve(so, sndreserve, rcvreserve);
	if (error)
		goto bad;
	so->so_rcv.sb_flags |= SB_NOINTR;
	so->so_snd.sb_flags |= SB_NOINTR;

	/* Initialize other non-zero congestion variables */
	nfs_init_rtt(nmp);
	nmp->nm_cwnd = NFS_MAXCWND / 2;	    /* Initial send window */
	nmp->nm_sent = 0;
	nmp->nm_timeouts = 0;
	return (0);

bad:
	nfs_disconnect(nmp);
	return (error);
}

/*
 * Reconnect routine:
 * Called when a connection is broken on a reliable protocol.
 * - clean up the old socket
 * - nfs_connect() again
 * - set R_MUSTRESEND for all outstanding requests on mount point
 * If this fails the mount point is DEAD!
 * nb: Must be called with the nfs_sndlock() set on the mount point.
 */
int
nfs_reconnect(struct nfsreq *rep)
{
	struct nfsreq *rp;
	struct nfsmount *nmp = rep->r_nmp;
	int s, error;

	nfs_disconnect(nmp);
	while ((error = nfs_connect(nmp, rep)) != 0) {
		if (error == EINTR || error == ERESTART)
			return (EINTR);
		(void) tsleep((caddr_t)&lbolt, PSOCK, "nfsrecon", 0);
	}

	/*
	 * Loop through outstanding request list and fix up all requests
	 * on old socket.
	 */
	s = splsoftnet();
	TAILQ_FOREACH(rp, &nmp->nm_reqsq, r_chain) {
		rp->r_flags |= R_MUSTRESEND;
		rp->r_rexmit = 0;
	}
	splx(s);
	return (0);
}

/*
 * NFS disconnect. Clean up and unlink.
 */
void
nfs_disconnect(struct nfsmount *nmp)
{
	struct socket *so;

	if (nmp->nm_so) {
		so = nmp->nm_so;
		nmp->nm_so = NULL;
		soshutdown(so, SHUT_RDWR);
		soclose(so);
	}
}

/*
 * This is the nfs send routine. For connection based socket types, it
 * must be called with an nfs_sndlock() on the socket.
 * "rep == NULL" indicates that it has been called from a server.
 * For the client side:
 * - return EINTR if the RPC is terminated, 0 otherwise
 * - set R_MUSTRESEND if the send fails for any reason
 * - do any cleanup required by recoverable socket errors (???)
 * For the server side:
 * - return EINTR or ERESTART if interrupted by a signal
 * - return EPIPE if a connection is lost for connection based sockets (TCP...)
 * - do any cleanup required by recoverable socket errors (???)
 */
int
nfs_send(struct socket *so, struct mbuf *nam, struct mbuf *top,
    struct nfsreq *rep)
{
	struct mbuf *sendnam;
	int error, soflags, flags;

	if (rep) {
		if (rep->r_flags & R_SOFTTERM) {
			m_freem(top);
			return (EINTR);
		}
		if ((so = rep->r_nmp->nm_so) == NULL) {
			rep->r_flags |= R_MUSTRESEND;
			m_freem(top);
			return (0);
		}
		rep->r_flags &= ~R_MUSTRESEND;
		soflags = rep->r_nmp->nm_soflags;
	} else
		soflags = so->so_proto->pr_flags;
	if ((soflags & PR_CONNREQUIRED) || (so->so_state & SS_ISCONNECTED))
		sendnam = NULL;
	else
		sendnam = nam;
	if (so->so_type == SOCK_SEQPACKET)
		flags = MSG_EOR;
	else
		flags = 0;

	error = sosend(so, sendnam, NULL, top, NULL, flags);
	if (error) {
		if (rep) {
			/*
			 * Deal with errors for the client side.
			 */
			if (rep->r_flags & R_SOFTTERM)
				error = EINTR;
			else
				rep->r_flags |= R_MUSTRESEND;
		}

		/*
		 * Handle any recoverable (soft) socket errors here. (???)
		 */
		if (error != EINTR && error != ERESTART &&
			error != EWOULDBLOCK && error != EPIPE)
			error = 0;
	}
	return (error);
}

#ifdef NFSCLIENT
/*
 * Receive a Sun RPC Request/Reply. For SOCK_DGRAM, the work is all
 * done by soreceive(), but for SOCK_STREAM we must deal with the Record
 * Mark and consolidate the data into a new mbuf list.
 * nb: Sometimes TCP passes the data up to soreceive() in long lists of
 *     small mbufs.
 * For SOCK_STREAM we must be very careful to read an entire record once
 * we have read any of it, even if the system call has been interrupted.
 */
int
nfs_receive(struct nfsreq *rep, struct mbuf **aname, struct mbuf **mp)
{
	struct socket *so;
	struct uio auio;
	struct iovec aio;
	struct mbuf *m;
	struct mbuf *control;
	u_int32_t len;
	struct mbuf **getnam;
	int error, sotype, rcvflg;
	struct proc *p = curproc;	/* XXX */

	/*
	 * Set up arguments for soreceive()
	 */
	*mp = NULL;
	*aname = NULL;
	sotype = rep->r_nmp->nm_sotype;

	/*
	 * For reliable protocols, lock against other senders/receivers
	 * in case a reconnect is necessary.
	 * For SOCK_STREAM, first get the Record Mark to find out how much
	 * more there is to get.
	 * We must lock the socket against other receivers
	 * until we have an entire rpc request/reply.
	 */
	if (sotype != SOCK_DGRAM) {
		error = nfs_sndlock(&rep->r_nmp->nm_flag, rep);
		if (error)
			return (error);
tryagain:
		/*
		 * Check for fatal errors and resending request.
		 */
		/*
		 * Ugh: If a reconnect attempt just happened, nm_so
		 * would have changed. NULL indicates a failed
		 * attempt that has essentially shut down this
		 * mount point.
		 */
		if (rep->r_mrep || (rep->r_flags & R_SOFTTERM)) {
			nfs_sndunlock(&rep->r_nmp->nm_flag);
			return (EINTR);
		}
		so = rep->r_nmp->nm_so;
		if (!so) {
			error = nfs_reconnect(rep); 
			if (error) {
				nfs_sndunlock(&rep->r_nmp->nm_flag);
				return (error);
			}
			goto tryagain;
		}
		while (rep->r_flags & R_MUSTRESEND) {
			m = m_copym(rep->r_mreq, 0, M_COPYALL, M_WAIT);
			nfsstats.rpcretries++;
			rep->r_rtt = 0;
			rep->r_flags &= ~R_TIMING;
			error = nfs_send(so, rep->r_nmp->nm_nam, m, rep);
			if (error) {
				if (error == EINTR || error == ERESTART ||
				    (error = nfs_reconnect(rep)) != 0) {
					nfs_sndunlock(&rep->r_nmp->nm_flag);
					return (error);
				}
				goto tryagain;
			}
		}
		nfs_sndunlock(&rep->r_nmp->nm_flag);
		if (sotype == SOCK_STREAM) {
			aio.iov_base = (caddr_t) &len;
			aio.iov_len = sizeof(u_int32_t);
			auio.uio_iov = &aio;
			auio.uio_iovcnt = 1;
			auio.uio_segflg = UIO_SYSSPACE;
			auio.uio_rw = UIO_READ;
			auio.uio_offset = 0;
			auio.uio_resid = sizeof(u_int32_t);
			auio.uio_procp = p;
			do {
			   rcvflg = MSG_WAITALL;
			   error = soreceive(so, NULL, &auio, NULL, NULL,
			       &rcvflg, 0);
			   if (error == EWOULDBLOCK && rep) {
				if (rep->r_flags & R_SOFTTERM)
					return (EINTR);
				/*
				 * looks like the server died after it
				 * received the request, make sure
				 * that we will retransmit and we
				 * don't get stuck here forever.
				 */
				if (rep->r_rexmit >= rep->r_nmp->nm_retry) {
					nfsstats.rpctimeouts++;
					error = EPIPE;
				}
			   }
			} while (error == EWOULDBLOCK);
			if (!error && auio.uio_resid > 0) {
			    log(LOG_INFO,
				 "short receive (%zu/%zu) from nfs server %s\n",
				 sizeof(u_int32_t) - auio.uio_resid,
				 sizeof(u_int32_t),
				 rep->r_nmp->nm_mountp->mnt_stat.f_mntfromname);
			    error = EPIPE;
			}
			if (error)
				goto errout;

			len = ntohl(len) & ~0x80000000;
			/*
			 * This is SERIOUS! We are out of sync with the sender
			 * and forcing a disconnect/reconnect is all I can do.
			 */
			if (len > NFS_MAXPACKET) {
			    log(LOG_ERR, "%s (%u) from nfs server %s\n",
				"impossible packet length",
				len,
				rep->r_nmp->nm_mountp->mnt_stat.f_mntfromname);
			    error = EFBIG;
			    goto errout;
			}
			auio.uio_resid = len;
			do {
			    rcvflg = MSG_WAITALL;
			    error =  soreceive(so, NULL, &auio, mp, NULL,
			        &rcvflg, 0);
			} while (error == EWOULDBLOCK || error == EINTR ||
				 error == ERESTART);
			if (!error && auio.uio_resid > 0) {
			    log(LOG_INFO,
				"short receive (%zu/%u) from nfs server %s\n",
				len - auio.uio_resid, len,
				rep->r_nmp->nm_mountp->mnt_stat.f_mntfromname);
			    error = EPIPE;
			}
		} else {
			/*
			 * NB: Since uio_resid is big, MSG_WAITALL is ignored
			 * and soreceive() will return when it has either a
			 * control msg or a data msg.
			 * We have no use for control msg., but must grab them
			 * and then throw them away so we know what is going
			 * on.
			 */
			auio.uio_resid = len = 100000000; /* Anything Big */
			auio.uio_procp = p;
			do {
			    rcvflg = 0;
			    error =  soreceive(so, NULL, &auio, mp, &control,
			        &rcvflg, 0);
			    m_freem(control);
			    if (error == EWOULDBLOCK && rep) {
				if (rep->r_flags & R_SOFTTERM)
					return (EINTR);
			    }
			} while (error == EWOULDBLOCK ||
				 (!error && *mp == NULL && control));
			if ((rcvflg & MSG_EOR) == 0)
				printf("Egad!!\n");
			if (!error && *mp == NULL)
				error = EPIPE;
			len -= auio.uio_resid;
		}
errout:
		if (error && error != EINTR && error != ERESTART) {
			m_freem(*mp);
			*mp = NULL;
			if (error != EPIPE)
				log(LOG_INFO,
				    "receive error %d from nfs server %s\n",
				    error,
				 rep->r_nmp->nm_mountp->mnt_stat.f_mntfromname);
			error = nfs_sndlock(&rep->r_nmp->nm_flag, rep);
			if (!error) {
				error = nfs_reconnect(rep);
				if (!error)
					goto tryagain;
				nfs_sndunlock(&rep->r_nmp->nm_flag);
			}
		}
	} else {
		if ((so = rep->r_nmp->nm_so) == NULL)
			return (EACCES);
		if (so->so_state & SS_ISCONNECTED)
			getnam = NULL;
		else
			getnam = aname;
		auio.uio_resid = len = 1000000;
		auio.uio_procp = p;
		do {
			rcvflg = 0;
			error =  soreceive(so, getnam, &auio, mp, NULL,
			    &rcvflg, 0);
			if (error == EWOULDBLOCK &&
			    (rep->r_flags & R_SOFTTERM))
				return (EINTR);
		} while (error == EWOULDBLOCK);
		len -= auio.uio_resid;
	}
	if (error) {
		m_freem(*mp);
		*mp = NULL;
	}
	/*
	 * Search for any mbufs that are not a multiple of 4 bytes long
	 * or with m_data not longword aligned.
	 * These could cause pointer alignment problems, so copy them to
	 * well aligned mbufs.
	 */
	nfs_realign(mp, 5 * NFSX_UNSIGNED);
	return (error);
}

/*
 * Implement receipt of reply on a socket.
 * We must search through the list of received datagrams matching them
 * with outstanding requests using the xid, until ours is found.
 */
int
nfs_reply(struct nfsreq *myrep)
{
	struct nfsreq *rep;
	struct nfsmount *nmp = myrep->r_nmp;
	struct nfsm_info	info;
	struct mbuf *nam;
	u_int32_t rxid, *tl, t1;
	caddr_t cp2;
	int s, error;

	/*
	 * Loop around until we get our own reply
	 */
	for (;;) {
		/*
		 * Lock against other receivers so that I don't get stuck in
		 * sbwait() after someone else has received my reply for me.
		 * Also necessary for connection based protocols to avoid
		 * race conditions during a reconnect.
		 */
		error = nfs_rcvlock(myrep);
		if (error)
			return (error == EALREADY ? 0 : error);

		/*
		 * Get the next Rpc reply off the socket
		 */
		error = nfs_receive(myrep, &nam, &info.nmi_mrep);
		nfs_rcvunlock(&nmp->nm_flag);
		if (error) {

			/*
			 * Ignore routing errors on connectionless protocols??
			 */
			if (NFSIGNORE_SOERROR(nmp->nm_soflags, error)) {
				if (nmp->nm_so)
					nmp->nm_so->so_error = 0;
				continue;
			}
			return (error);
		}
		m_freem(nam);
	
		/*
		 * Get the xid and check that it is an rpc reply
		 */
		info.nmi_md = info.nmi_mrep;
		info.nmi_dpos = mtod(info.nmi_md, caddr_t);
		nfsm_dissect(tl, u_int32_t *, 2*NFSX_UNSIGNED);
		rxid = *tl++;
		if (*tl != rpc_reply) {
			nfsstats.rpcinvalid++;
			m_freem(info.nmi_mrep);
nfsmout:
			continue;
		}

		/*
		 * Loop through the request list to match up the reply
		 * Iff no match, just drop the datagram
		 */
		s = splsoftnet();
		TAILQ_FOREACH(rep, &nmp->nm_reqsq, r_chain) {
			if (rep->r_mrep == NULL && rxid == rep->r_xid) {
				/* Found it.. */
				rep->r_mrep = info.nmi_mrep;
				rep->r_md = info.nmi_md;
				rep->r_dpos = info.nmi_dpos;

				/*
				 * Update congestion window.
				 * Do the additive increase of
				 * one rpc/rtt.
				 */
				if (nmp->nm_cwnd <= nmp->nm_sent) {
					nmp->nm_cwnd +=
					   (NFS_CWNDSCALE * NFS_CWNDSCALE +
					   (nmp->nm_cwnd >> 1)) / nmp->nm_cwnd;
					if (nmp->nm_cwnd > NFS_MAXCWND)
						nmp->nm_cwnd = NFS_MAXCWND;
				}
				rep->r_flags &= ~R_SENT;
				nmp->nm_sent -= NFS_CWNDSCALE;

				if (rep->r_flags & R_TIMING)
					nfs_update_rtt(rep);

				nmp->nm_timeouts = 0;
				break;
			}
		}
		splx(s);
		/*
		 * If not matched to a request, drop it.
		 * If it's mine, get out.
		 */
		if (rep == 0) {
			nfsstats.rpcunexpected++;
			m_freem(info.nmi_mrep);
		} else if (rep == myrep) {
			if (rep->r_mrep == NULL)
				panic("nfsreply nil");
			return (0);
		}
	}
}

/*
 * nfs_request - goes something like this
 *	- fill in request struct
 *	- links it into list
 *	- calls nfs_send() for first transmit
 *	- calls nfs_receive() to get reply
 *	- break down rpc header and return with nfs reply pointed to
 *	  by mrep or error
 * nb: always frees up mreq mbuf list
 */
int
nfs_request(struct vnode *vp, int procnum, struct nfsm_info *infop)
{
	struct mbuf *m;
	u_int32_t *tl;
	struct nfsmount *nmp;
	struct timeval tv;
	caddr_t cp2;
	int t1, i, s, error = 0;
	int trylater_delay;
	struct nfsreq *rep;
	int  mrest_len;
	struct nfsm_info	info;

	rep = pool_get(&nfsreqpl, PR_WAITOK);
	rep->r_nmp = VFSTONFS(vp->v_mount);
	rep->r_vp = vp;
	rep->r_procp = infop->nmi_procp;
	rep->r_procnum = procnum;

	mrest_len = 0;
	m = infop->nmi_mreq;
	while (m) {
		mrest_len += m->m_len;
		m = m->m_next;
	}

	/* empty mbuf for AUTH_UNIX header */
	rep->r_mreq = m_gethdr(M_WAIT, MT_DATA);
	rep->r_mreq->m_next = infop->nmi_mreq;
	rep->r_mreq->m_pkthdr.len = mrest_len;

	trylater_delay = NFS_MINTIMEO;

	nmp = rep->r_nmp;

	/* Get the RPC header with authorization. */
	nfsm_rpchead(rep, infop->nmi_cred, RPCAUTH_UNIX);
	m = rep->r_mreq;

	/*
	 * For stream protocols, insert a Sun RPC Record Mark.
	 */
	if (nmp->nm_sotype == SOCK_STREAM) {
		M_PREPEND(m, NFSX_UNSIGNED, M_WAIT);
		*mtod(m, u_int32_t *) = htonl(0x80000000 |
			 (m->m_pkthdr.len - NFSX_UNSIGNED));
	}

tryagain:
	rep->r_rtt = rep->r_rexmit = 0;
	if (nfs_ptimers[rep->r_procnum] != NFS_DEFAULT_TIMER)
		rep->r_flags = R_TIMING;
	else
		rep->r_flags = 0;
	rep->r_mrep = NULL;

	/*
	 * Do the client side RPC.
	 */
	nfsstats.rpcrequests++;
	/*
	 * Chain request into list of outstanding requests. Be sure
	 * to put it LAST so timer finds oldest requests first.
	 */
	s = splsoftnet();
	if (TAILQ_EMPTY(&nmp->nm_reqsq))
		timeout_add(&nmp->nm_rtimeout, nfs_ticks);
	TAILQ_INSERT_TAIL(&nmp->nm_reqsq, rep, r_chain);

	/*
	 * If backing off another request or avoiding congestion, don't
	 * send this one now but let timer do it. If not timing a request,
	 * do it now.
	 */
	if (nmp->nm_so && (nmp->nm_sotype != SOCK_DGRAM ||
		(nmp->nm_flag & NFSMNT_DUMBTIMR) ||
		nmp->nm_sent < nmp->nm_cwnd)) {
		splx(s);
		if (nmp->nm_soflags & PR_CONNREQUIRED)
			error = nfs_sndlock(&nmp->nm_flag, rep);
		if (!error) {
			error = nfs_send(nmp->nm_so, nmp->nm_nam,
					m_copym(m, 0, M_COPYALL, M_WAIT),
					rep);
			if (nmp->nm_soflags & PR_CONNREQUIRED)
				nfs_sndunlock(&nmp->nm_flag);
		}
		if (!error && (rep->r_flags & R_MUSTRESEND) == 0) {
			nmp->nm_sent += NFS_CWNDSCALE;
			rep->r_flags |= R_SENT;
		}
	} else {
		splx(s);
		rep->r_rtt = -1;
	}

	/*
	 * Wait for the reply from our send or the timer's.
	 */
	if (!error || error == EPIPE)
		error = nfs_reply(rep);

	/*
	 * RPC done, unlink the request.
	 */
	s = splsoftnet();
	TAILQ_REMOVE(&nmp->nm_reqsq, rep, r_chain);
	if (TAILQ_EMPTY(&nmp->nm_reqsq))
		timeout_del(&nmp->nm_rtimeout);
	splx(s);

	/*
	 * Decrement the outstanding request count.
	 */
	if (rep->r_flags & R_SENT) {
		rep->r_flags &= ~R_SENT;	/* paranoia */
		nmp->nm_sent -= NFS_CWNDSCALE;
	}

	/*
	 * If there was a successful reply and a tprintf msg.
	 * tprintf a response.
	 */
	if (!error && (rep->r_flags & R_TPRINTFMSG))
		nfs_msg(rep, "is alive again");
	info.nmi_mrep = rep->r_mrep;
	info.nmi_md = rep->r_md;
	info.nmi_dpos = rep->r_dpos;
	if (error) {
		infop->nmi_mrep = NULL;
		goto nfsmout1;
	}

	/*
	 * break down the rpc header and check if ok
	 */
	nfsm_dissect(tl, u_int32_t *, 3 * NFSX_UNSIGNED);
	if (*tl++ == rpc_msgdenied) {
		if (*tl == rpc_mismatch)
			error = EOPNOTSUPP;
		else
			error = EACCES;	/* Should be EAUTH. */
		infop->nmi_mrep = NULL;
		goto nfsmout1;
	}

	/*
	 * Since we only support RPCAUTH_UNIX atm we step over the
	 * reply verifer type, and in the (error) case that there really
	 * is any data in it, we advance over it.
	 */
	tl++;			/* Step over verifer type */
	i = fxdr_unsigned(int32_t, *tl);
	if (i > 0)
		nfsm_adv(nfsm_rndup(i));	/* Should not happen */

	nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);
	/* 0 == ok */
	if (*tl == 0) {
		nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);
		if (*tl != 0) {
			error = fxdr_unsigned(int, *tl);
			if ((nmp->nm_flag & NFSMNT_NFSV3) &&
			    error == NFSERR_TRYLATER) {
				m_freem(info.nmi_mrep);
				error = 0;
				tv.tv_sec = trylater_delay;
				tv.tv_usec = 0;
				tsleep(&tv, PSOCK, "nfsretry", tvtohz(&tv));
				trylater_delay *= NFS_TIMEOUTMUL;
				if (trylater_delay > NFS_MAXTIMEO)
					trylater_delay = NFS_MAXTIMEO;

				goto tryagain;
			}

			/*
			 * If the File Handle was stale, invalidate the
			 * lookup cache, just in case.
			 */
			if (error == ESTALE)
				cache_purge(rep->r_vp);
		}
		goto nfsmout;
	}

	error = EPROTONOSUPPORT;

nfsmout:
	infop->nmi_mrep = info.nmi_mrep;
	infop->nmi_md = info.nmi_md;
	infop->nmi_dpos = info.nmi_dpos;
nfsmout1:
	m_freem(rep->r_mreq);
	pool_put(&nfsreqpl, rep);
	return (error);
}
#endif /* NFSCLIENT */

/*
 * Generate the rpc reply header
 * siz arg. is used to decide if adding a cluster is worthwhile
 */
int
nfs_rephead(int siz, struct nfsrv_descript *nd, struct nfssvc_sock *slp,
    int err, struct mbuf **mrq, struct mbuf **mbp)
{
	u_int32_t *tl;
	struct mbuf *mreq;
	struct mbuf *mb;

	MGETHDR(mreq, M_WAIT, MT_DATA);
	mb = mreq;
	/*
	 * If this is a big reply, use a cluster else
	 * try and leave leading space for the lower level headers.
	 */
	siz += RPC_REPLYSIZ;
	if (siz >= MHLEN - max_hdr) {
		MCLGET(mreq, M_WAIT);
	} else
		mreq->m_data += max_hdr;
	tl = mtod(mreq, u_int32_t *);
	mreq->m_len = 6 * NFSX_UNSIGNED;
	*tl++ = txdr_unsigned(nd->nd_retxid);
	*tl++ = rpc_reply;
	if (err == ERPCMISMATCH || (err & NFSERR_AUTHERR)) {
		*tl++ = rpc_msgdenied;
		if (err & NFSERR_AUTHERR) {
			*tl++ = rpc_autherr;
			*tl = txdr_unsigned(err & ~NFSERR_AUTHERR);
			mreq->m_len -= NFSX_UNSIGNED;
		} else {
			*tl++ = rpc_mismatch;
			*tl++ = txdr_unsigned(RPC_VER2);
			*tl = txdr_unsigned(RPC_VER2);
		}
	} else {
		*tl++ = rpc_msgaccepted;

		/* AUTH_UNIX requires RPCAUTH_NULL. */
		*tl++ = 0;
		*tl++ = 0;

		switch (err) {
		case EPROGUNAVAIL:
			*tl = txdr_unsigned(RPC_PROGUNAVAIL);
			break;
		case EPROGMISMATCH:
			*tl = txdr_unsigned(RPC_PROGMISMATCH);
			tl = nfsm_build(&mb, 2 * NFSX_UNSIGNED);
			*tl++ = txdr_unsigned(NFS_VER2);
			*tl = txdr_unsigned(NFS_VER3);
			break;
		case EPROCUNAVAIL:
			*tl = txdr_unsigned(RPC_PROCUNAVAIL);
			break;
		case EBADRPC:
			*tl = txdr_unsigned(RPC_GARBAGE);
			break;
		default:
			*tl = 0;
			if (err != NFSERR_RETVOID) {
				tl = nfsm_build(&mb, NFSX_UNSIGNED);
				if (err)
				    *tl = txdr_unsigned(nfsrv_errmap(nd, err));
				else
				    *tl = 0;
			}
			break;
		};
	}

	*mrq = mreq;
	if (mbp != NULL)
		*mbp = mb;
	if (err != 0 && err != NFSERR_RETVOID)
		nfsstats.srvrpc_errs++;
	return (0);
}

/*
 * nfs timer routine
 * Scan the nfsreq list and retranmit any requests that have timed out.
 */
void
nfs_timer(void *arg)
{
	struct nfsmount *nmp = arg;
	struct nfsreq *rep;
	struct mbuf *m;
	struct socket *so;
	int timeo, s, error;

	NET_LOCK(s);
	TAILQ_FOREACH(rep, &nmp->nm_reqsq, r_chain) {
		if (rep->r_mrep || (rep->r_flags & R_SOFTTERM))
			continue;
		if (nfs_sigintr(nmp, rep, rep->r_procp)) {
			rep->r_flags |= R_SOFTTERM;
			continue;
		}
		if (rep->r_rtt >= 0) {
			rep->r_rtt++;
			if (nmp->nm_flag & NFSMNT_DUMBTIMR)
				timeo = nmp->nm_timeo;
			else
				timeo = nfs_estimate_rto(nmp, rep->r_procnum);
			if (nmp->nm_timeouts > 0)
				timeo *= nfs_backoff[nmp->nm_timeouts - 1];
			if (rep->r_rtt <= timeo)
				continue;
			if (nmp->nm_timeouts < nitems(nfs_backoff))
				nmp->nm_timeouts++;
		}

		/* Check for server not responding. */
		if ((rep->r_flags & R_TPRINTFMSG) == 0 && rep->r_rexmit > 4) {
			nfs_msg(rep, "not responding");
			rep->r_flags |= R_TPRINTFMSG;
		}
		if (rep->r_rexmit >= nmp->nm_retry) {	/* too many */
			nfsstats.rpctimeouts++;
			rep->r_flags |= R_SOFTTERM;
			continue;
		}
		if (nmp->nm_sotype != SOCK_DGRAM) {
			if (++rep->r_rexmit > NFS_MAXREXMIT)
				rep->r_rexmit = NFS_MAXREXMIT;
			continue;
		}

		if ((so = nmp->nm_so) == NULL)
			continue;

		/*
		 * If there is enough space and the window allows..
		 *	Resend it
		 * Set r_rtt to -1 in case we fail to send it now.
		 */
		rep->r_rtt = -1;
		if (sbspace(&so->so_snd) >= rep->r_mreq->m_pkthdr.len &&
		   ((nmp->nm_flag & NFSMNT_DUMBTIMR) ||
		    (rep->r_flags & R_SENT) ||
		    nmp->nm_sent < nmp->nm_cwnd) &&
		   (m = m_copym(rep->r_mreq, 0, M_COPYALL, M_DONTWAIT))){
			if ((nmp->nm_flag & NFSMNT_NOCONN) == 0)
			    error = (*so->so_proto->pr_usrreq)(so, PRU_SEND, m,
			    NULL, NULL, curproc);
			else
			    error = (*so->so_proto->pr_usrreq)(so, PRU_SEND, m,
			    nmp->nm_nam, NULL, curproc);
			if (error) {
				if (NFSIGNORE_SOERROR(nmp->nm_soflags, error))
					so->so_error = 0;
			} else {
				/*
				 * Iff first send, start timing
				 * else turn timing off, backoff timer
				 * and divide congestion window by 2.
				 */
				if (rep->r_flags & R_SENT) {
					rep->r_flags &= ~R_TIMING;
					if (++rep->r_rexmit > NFS_MAXREXMIT)
						rep->r_rexmit = NFS_MAXREXMIT;
					nmp->nm_cwnd >>= 1;
					if (nmp->nm_cwnd < NFS_CWNDSCALE)
						nmp->nm_cwnd = NFS_CWNDSCALE;
					nfsstats.rpcretries++;
				} else {
					rep->r_flags |= R_SENT;
					nmp->nm_sent += NFS_CWNDSCALE;
				}
				rep->r_rtt = 0;
			}
		}
	}
	NET_UNLOCK(s);
	timeout_add(&nmp->nm_rtimeout, nfs_ticks);
}

/*
 * Test for a termination condition pending on the process.
 * This is used for NFSMNT_INT mounts.
 */
int
nfs_sigintr(struct nfsmount *nmp, struct nfsreq *rep, struct proc *p)
{

	if (rep && (rep->r_flags & R_SOFTTERM))
		return (EINTR);
	if (!(nmp->nm_flag & NFSMNT_INT))
		return (0);
	if (p && p->p_siglist &&
	    (((p->p_siglist & ~p->p_sigmask) &
	    ~p->p_p->ps_sigacts->ps_sigignore) & NFSINT_SIGMASK))
		return (EINTR);
	return (0);
}

/*
 * Lock a socket against others.
 * Necessary for STREAM sockets to ensure you get an entire rpc request/reply
 * and also to avoid race conditions between the processes with nfs requests
 * in progress when a reconnect is necessary.
 */
int
nfs_sndlock(int *flagp, struct nfsreq *rep)
{
	struct proc *p;
	int slpflag = 0, slptimeo = 0;

	if (rep) {
		p = rep->r_procp;
		if (rep->r_nmp->nm_flag & NFSMNT_INT)
			slpflag = PCATCH;
	} else
		p = NULL;
	while (*flagp & NFSMNT_SNDLOCK) {
		if (rep && nfs_sigintr(rep->r_nmp, rep, p))
			return (EINTR);
		*flagp |= NFSMNT_WANTSND;
		(void) tsleep((caddr_t)flagp, slpflag | (PZERO - 1), "nfsndlck",
			slptimeo);
		if (slpflag == PCATCH) {
			slpflag = 0;
			slptimeo = 2 * hz;
		}
	}
	*flagp |= NFSMNT_SNDLOCK;
	return (0);
}

/*
 * Unlock the stream socket for others.
 */
void
nfs_sndunlock(int *flagp)
{

	if ((*flagp & NFSMNT_SNDLOCK) == 0)
		panic("nfs sndunlock");
	*flagp &= ~NFSMNT_SNDLOCK;
	if (*flagp & NFSMNT_WANTSND) {
		*flagp &= ~NFSMNT_WANTSND;
		wakeup((caddr_t)flagp);
	}
}

int
nfs_rcvlock(struct nfsreq *rep)
{
	int *flagp = &rep->r_nmp->nm_flag;
	int slpflag, slptimeo = 0;

	if (*flagp & NFSMNT_INT)
		slpflag = PCATCH;
	else
		slpflag = 0;

	while (*flagp & NFSMNT_RCVLOCK) {
		if (nfs_sigintr(rep->r_nmp, rep, rep->r_procp))
			return (EINTR);
		*flagp |= NFSMNT_WANTRCV;
		(void) tsleep((caddr_t)flagp, slpflag | (PZERO - 1), "nfsrcvlk",
			slptimeo);
		if (rep->r_mrep != NULL) {
			/*
			 * Don't take the lock if our reply has been received
			 * while we where sleeping.
			 */
			 return (EALREADY);
		}
		if (slpflag == PCATCH) {
			slpflag = 0;
			slptimeo = 2 * hz;
		}
	}
	*flagp |= NFSMNT_RCVLOCK;
	return (0);
}

/*
 * Unlock the stream socket for others.
 */
void
nfs_rcvunlock(int *flagp)
{

	if ((*flagp & NFSMNT_RCVLOCK) == 0)
		panic("nfs rcvunlock");
	*flagp &= ~NFSMNT_RCVLOCK;
	if (*flagp & NFSMNT_WANTRCV) {
		*flagp &= ~NFSMNT_WANTRCV;
		wakeup((caddr_t)flagp);
	}
}

/*
 * Auxiliary routine to align the length of mbuf copies made with m_copyback().
 */
void
nfs_realign_fixup(struct mbuf *m, struct mbuf *n, unsigned int *off)
{
	size_t padding;

	/*
	 * The maximum number of bytes that m_copyback() places in a mbuf is
	 * always an aligned quantity, so realign happens at the chain's tail.
	 */
	while (n->m_next != NULL)
		n = n->m_next;

	/*
	 * Pad from the next elements in the source chain. Loop until the
	 * destination chain is aligned, or the end of the source is reached.
	 */
	do {
		m = m->m_next;
		if (m == NULL)
			return;

		padding = min(ALIGN(n->m_len) - n->m_len, m->m_len);
		if (padding > M_TRAILINGSPACE(n))
			panic("nfs_realign_fixup: no memory to pad to");

		bcopy(mtod(m, void *), mtod(n, char *) + n->m_len, padding);

		n->m_len += padding;
		m_adj(m, padding);
		*off += padding;

	} while (!ALIGNED_POINTER(n->m_len, void *));
}

/*
 * The NFS RPC parsing code uses the data address and the length of mbuf
 * structures to calculate on-memory addresses. This function makes sure these
 * parameters are correctly aligned.
 */
void
nfs_realign(struct mbuf **pm, int hsiz)
{
	struct mbuf *m;
	struct mbuf *n = NULL;
	unsigned int off = 0;

	++nfs_realign_test;
	while ((m = *pm) != NULL) {
		if (!ALIGNED_POINTER(m->m_data, void *) ||
		    !ALIGNED_POINTER(m->m_len,  void *)) {
			MGET(n, M_WAIT, MT_DATA);
#define ALIGN_POINTER(n) ((u_int)(((n) + sizeof(void *)) & ~sizeof(void *)))
			if (ALIGN_POINTER(m->m_len) >= MINCLSIZE) {
				MCLGET(n, M_WAIT);
			}
			n->m_len = 0;
			break;
		}
		pm = &m->m_next;
	}
	/*
	 * If n is non-NULL, loop on m copying data, then replace the
	 * portion of the chain that had to be realigned.
	 */
	if (n != NULL) {
		++nfs_realign_count;
		while (m) {
			m_copyback(n, off, m->m_len, mtod(m, caddr_t), M_WAIT);

			/*
			 * If an unaligned amount of memory was copied, fix up
			 * the last mbuf created by m_copyback().
			 */
			if (!ALIGNED_POINTER(m->m_len, void *))
				nfs_realign_fixup(m, n, &off);

			off += m->m_len;
			m = m->m_next;
		}
		m_freem(*pm);
		*pm = n;
	}
}


/*
 * Parse an RPC request
 * - verify it
 * - fill in the cred struct.
 */
int
nfs_getreq(struct nfsrv_descript *nd, struct nfsd *nfsd, int has_header)
{
	int len, i;
	u_int32_t *tl;
	int32_t t1;
	caddr_t cp2;
	u_int32_t nfsvers, auth_type;
	int error = 0;
	struct nfsm_info	info;

	info.nmi_mrep = nd->nd_mrep;
	info.nmi_md = nd->nd_md;
	info.nmi_dpos = nd->nd_dpos;
	if (has_header) {
		nfsm_dissect(tl, u_int32_t *, 10 * NFSX_UNSIGNED);
		nd->nd_retxid = fxdr_unsigned(u_int32_t, *tl++);
		if (*tl++ != rpc_call) {
			m_freem(info.nmi_mrep);
			return (EBADRPC);
		}
	} else
		nfsm_dissect(tl, u_int32_t *, 8 * NFSX_UNSIGNED);
	nd->nd_repstat = 0;
	nd->nd_flag = 0;
	if (*tl++ != rpc_vers) {
		nd->nd_repstat = ERPCMISMATCH;
		nd->nd_procnum = NFSPROC_NOOP;
		return (0);
	}
	if (*tl != nfs_prog) {
		nd->nd_repstat = EPROGUNAVAIL;
		nd->nd_procnum = NFSPROC_NOOP;
		return (0);
	}
	tl++;
	nfsvers = fxdr_unsigned(u_int32_t, *tl++);
	if (nfsvers != NFS_VER2 && nfsvers != NFS_VER3) {
		nd->nd_repstat = EPROGMISMATCH;
		nd->nd_procnum = NFSPROC_NOOP;
		return (0);
	}
	if (nfsvers == NFS_VER3)
		nd->nd_flag = ND_NFSV3;
	nd->nd_procnum = fxdr_unsigned(u_int32_t, *tl++);
	if (nd->nd_procnum == NFSPROC_NULL)
		return (0);
	if (nd->nd_procnum >= NFS_NPROCS ||
		(nd->nd_procnum > NFSPROC_COMMIT) ||
		(!nd->nd_flag && nd->nd_procnum > NFSV2PROC_STATFS)) {
		nd->nd_repstat = EPROCUNAVAIL;
		nd->nd_procnum = NFSPROC_NOOP;
		return (0);
	}
	if ((nd->nd_flag & ND_NFSV3) == 0)
		nd->nd_procnum = nfsv3_procid[nd->nd_procnum];
	auth_type = *tl++;
	len = fxdr_unsigned(int, *tl++);
	if (len < 0 || len > RPCAUTH_MAXSIZ) {
		m_freem(info.nmi_mrep);
		return (EBADRPC);
	}

	/* Handle auth_unix */
	if (auth_type == rpc_auth_unix) {
		len = fxdr_unsigned(int, *++tl);
		if (len < 0 || len > NFS_MAXNAMLEN) {
			m_freem(info.nmi_mrep);
			return (EBADRPC);
		}
		nfsm_adv(nfsm_rndup(len));
		nfsm_dissect(tl, u_int32_t *, 3 * NFSX_UNSIGNED);
		memset(&nd->nd_cr, 0, sizeof (struct ucred));
		nd->nd_cr.cr_ref = 1;
		nd->nd_cr.cr_uid = fxdr_unsigned(uid_t, *tl++);
		nd->nd_cr.cr_gid = fxdr_unsigned(gid_t, *tl++);
		len = fxdr_unsigned(int, *tl);
		if (len < 0 || len > RPCAUTH_UNIXGIDS) {
			m_freem(info.nmi_mrep);
			return (EBADRPC);
		}
		nfsm_dissect(tl, u_int32_t *, (len + 2) * NFSX_UNSIGNED);
		for (i = 0; i < len; i++)
		    if (i < NGROUPS_MAX)
			nd->nd_cr.cr_groups[i] = fxdr_unsigned(gid_t, *tl++);
		    else
			tl++;
		nd->nd_cr.cr_ngroups = (len > NGROUPS_MAX) ? NGROUPS_MAX : len;
		len = fxdr_unsigned(int, *++tl);
		if (len < 0 || len > RPCAUTH_MAXSIZ) {
			m_freem(info.nmi_mrep);
			return (EBADRPC);
		}
		if (len > 0)
			nfsm_adv(nfsm_rndup(len));
	} else {
		nd->nd_repstat = (NFSERR_AUTHERR | AUTH_REJECTCRED);
		nd->nd_procnum = NFSPROC_NOOP;
		return (0);
	}

	nd->nd_md = info.nmi_md;
	nd->nd_dpos = info.nmi_dpos;
	return (0);
nfsmout:
	return (error);
}

void
nfs_msg(struct nfsreq *rep, char *msg)
{
	tpr_t tpr;

	if (rep->r_procp)
		tpr = tprintf_open(rep->r_procp);
	else
		tpr = NULL;

	tprintf(tpr, "nfs server %s: %s\n",
	    rep->r_nmp->nm_mountp->mnt_stat.f_mntfromname, msg);
	tprintf_close(tpr);
}

#ifdef NFSSERVER
/*
 * Socket upcall routine for the nfsd sockets.
 * The caddr_t arg is a pointer to the "struct nfssvc_sock".
 * Essentially do as much as possible non-blocking, else punt and it will
 * be called with M_WAIT from an nfsd.
 */
void
nfsrv_rcv(struct socket *so, caddr_t arg, int waitflag)
{
	struct nfssvc_sock *slp = (struct nfssvc_sock *)arg;
	struct mbuf *m;
	struct mbuf *mp, *nam;
	struct uio auio;
	int flags, error;

	if ((slp->ns_flag & SLP_VALID) == 0)
		return;

	/* Defer soreceive() to an nfsd. */
	if (waitflag == M_DONTWAIT) {
		slp->ns_flag |= SLP_NEEDQ;
		goto dorecs;
	}

	auio.uio_procp = NULL;
	if (so->so_type == SOCK_STREAM) {
		/*
		 * Do soreceive().
		 */
		auio.uio_resid = 1000000000;
		flags = MSG_DONTWAIT;
		error = soreceive(so, &nam, &auio, &mp, NULL,
		    &flags, 0);
		if (error || mp == NULL) {
			if (error == EWOULDBLOCK)
				slp->ns_flag |= SLP_NEEDQ;
			else
				slp->ns_flag |= SLP_DISCONN;
			goto dorecs;
		}
		m = mp;
		if (slp->ns_rawend) {
			slp->ns_rawend->m_next = m;
			slp->ns_cc += 1000000000 - auio.uio_resid;
		} else {
			slp->ns_raw = m;
			slp->ns_cc = 1000000000 - auio.uio_resid;
		}
		while (m->m_next)
			m = m->m_next;
		slp->ns_rawend = m;

		/*
		 * Now try and parse record(s) out of the raw stream data.
		 */
		error = nfsrv_getstream(slp, waitflag);
		if (error) {
			if (error == EPERM)
				slp->ns_flag |= SLP_DISCONN;
			else
				slp->ns_flag |= SLP_NEEDQ;
		}
	} else {
		do {
			auio.uio_resid = 1000000000;
			flags = MSG_DONTWAIT;
			error = soreceive(so, &nam, &auio, &mp,
			    NULL, &flags, 0);
			if (mp) {
				if (nam) {
					m = nam;
					m->m_next = mp;
				} else
					m = mp;
				if (slp->ns_recend)
					slp->ns_recend->m_nextpkt = m;
				else
					slp->ns_rec = m;
				slp->ns_recend = m;
				m->m_nextpkt = NULL;
			}
			if (error) {
				if ((so->so_proto->pr_flags & PR_CONNREQUIRED)
					&& error != EWOULDBLOCK) {
					slp->ns_flag |= SLP_DISCONN;
					goto dorecs;
				}
			}
		} while (mp);
	}

	/*
	 * Now try and process the request records, non-blocking.
	 */
dorecs:
	if (waitflag == M_DONTWAIT &&
		(slp->ns_rec || (slp->ns_flag & (SLP_NEEDQ | SLP_DISCONN))))
		nfsrv_wakenfsd(slp);
}

/*
 * Try and extract an RPC request from the mbuf data list received on a
 * stream socket. The "waitflag" argument indicates whether or not it
 * can sleep.
 */
int
nfsrv_getstream(struct nfssvc_sock *slp, int waitflag)
{
	struct mbuf *m, **mpp;
	char *cp1, *cp2;
	int len;
	struct mbuf *om, *m2, *recm;
	u_int32_t recmark;

	if (slp->ns_flag & SLP_GETSTREAM)
		return (0);
	slp->ns_flag |= SLP_GETSTREAM;
	for (;;) {
	    if (slp->ns_reclen == 0) {
		if (slp->ns_cc < NFSX_UNSIGNED) {
			slp->ns_flag &= ~SLP_GETSTREAM;
			return (0);
		}
		m = slp->ns_raw;
		if (m->m_len >= NFSX_UNSIGNED) {
			bcopy(mtod(m, caddr_t), (caddr_t)&recmark, NFSX_UNSIGNED);
			m->m_data += NFSX_UNSIGNED;
			m->m_len -= NFSX_UNSIGNED;
		} else {
			cp1 = (caddr_t)&recmark;
			cp2 = mtod(m, caddr_t);
			while (cp1 < ((caddr_t)&recmark) + NFSX_UNSIGNED) {
				while (m->m_len == 0) {
					m = m->m_next;
					cp2 = mtod(m, caddr_t);
				}
				*cp1++ = *cp2++;
				m->m_data++;
				m->m_len--;
			}
		}
		slp->ns_cc -= NFSX_UNSIGNED;
		recmark = ntohl(recmark);
		slp->ns_reclen = recmark & ~0x80000000;
		if (recmark & 0x80000000)
			slp->ns_flag |= SLP_LASTFRAG;
		else
			slp->ns_flag &= ~SLP_LASTFRAG;
		if (slp->ns_reclen > NFS_MAXPACKET) {
			slp->ns_flag &= ~SLP_GETSTREAM;
			return (EPERM);
		}
	    }

	    /*
	     * Now get the record part.
	     */
	    recm = NULL;
	    if (slp->ns_cc == slp->ns_reclen) {
		recm = slp->ns_raw;
		slp->ns_raw = slp->ns_rawend = NULL;
		slp->ns_cc = slp->ns_reclen = 0;
	    } else if (slp->ns_cc > slp->ns_reclen) {
		len = 0;
		m = slp->ns_raw;
		om = NULL;
		while (len < slp->ns_reclen) {
			if ((len + m->m_len) > slp->ns_reclen) {
				m2 = m_copym(m, 0, slp->ns_reclen - len,
					waitflag);
				if (m2) {
					if (om) {
						om->m_next = m2;
						recm = slp->ns_raw;
					} else
						recm = m2;
					m->m_data += slp->ns_reclen - len;
					m->m_len -= slp->ns_reclen - len;
					len = slp->ns_reclen;
				} else {
					slp->ns_flag &= ~SLP_GETSTREAM;
					return (EWOULDBLOCK);
				}
			} else if ((len + m->m_len) == slp->ns_reclen) {
				om = m;
				len += m->m_len;
				m = m->m_next;
				recm = slp->ns_raw;
				om->m_next = NULL;
			} else {
				om = m;
				len += m->m_len;
				m = m->m_next;
			}
		}
		slp->ns_raw = m;
		slp->ns_cc -= len;
		slp->ns_reclen = 0;
	    } else {
		slp->ns_flag &= ~SLP_GETSTREAM;
		return (0);
	    }

	    /*
	     * Accumulate the fragments into a record.
	     */
	    mpp = &slp->ns_frag;
	    while (*mpp)
		mpp = &((*mpp)->m_next);
	    *mpp = recm;
	    if (slp->ns_flag & SLP_LASTFRAG) {
		if (slp->ns_recend)
		    slp->ns_recend->m_nextpkt = slp->ns_frag;
		else
		    slp->ns_rec = slp->ns_frag;
		slp->ns_recend = slp->ns_frag;
		slp->ns_frag = NULL;
	    }
	}
}

/*
 * Parse an RPC header.
 */
int
nfsrv_dorec(struct nfssvc_sock *slp, struct nfsd *nfsd,
    struct nfsrv_descript **ndp)
{
	struct mbuf *m, *nam;
	struct nfsrv_descript *nd;
	int error;

	*ndp = NULL;
	if ((slp->ns_flag & SLP_VALID) == 0 ||
	    (m = slp->ns_rec) == NULL)
		return (ENOBUFS);
	slp->ns_rec = m->m_nextpkt;
	if (slp->ns_rec)
		m->m_nextpkt = NULL;
	else
		slp->ns_recend = NULL;
	if (m->m_type == MT_SONAME) {
		nam = m;
		m = m->m_next;
		nam->m_next = NULL;
	} else
		nam = NULL;
	nd = pool_get(&nfsrv_descript_pl, PR_WAITOK);
	nfs_realign(&m, 10 * NFSX_UNSIGNED);
	nd->nd_md = nd->nd_mrep = m;
	nd->nd_nam2 = nam;
	nd->nd_dpos = mtod(m, caddr_t);
	error = nfs_getreq(nd, nfsd, 1);
	if (error) {
		m_freem(nam);
		pool_put(&nfsrv_descript_pl, nd);
		return (error);
	}
	*ndp = nd;
	nfsd->nfsd_nd = nd;
	return (0);
}


/*
 * Search for a sleeping nfsd and wake it up.
 * SIDE EFFECT: If none found, set NFSD_CHECKSLP flag, so that one of the
 * running nfsds will go look for the work in the nfssvc_sock list.
 */
void
nfsrv_wakenfsd(struct nfssvc_sock *slp)
{
	struct nfsd	*nfsd;

	if ((slp->ns_flag & SLP_VALID) == 0)
		return;

	TAILQ_FOREACH(nfsd, &nfsd_head, nfsd_chain) {
		if (nfsd->nfsd_flag & NFSD_WAITING) {
			nfsd->nfsd_flag &= ~NFSD_WAITING;
			if (nfsd->nfsd_slp)
				panic("nfsd wakeup");
			slp->ns_sref++;
			nfsd->nfsd_slp = slp;
			wakeup_one(nfsd);
			return;
		}
	}

	slp->ns_flag |= SLP_DOREC;
	nfsd_head_flag |= NFSD_CHECKSLP;
}
#endif /* NFSSERVER */
@


1.114
log
@Prevent a recursion in the socket layer.

Always defere soreceive() to an nfsd(8) process instead of doing it in
the 'softnet' thread.  Avoiding this recursion ensure that we do not
introduce a new sleeping point by releasing and grabbing the netlock.

Tested by many, committing now in order to find possible performance
regression.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.113 2017/02/22 11:42:46 mpi Exp $	*/
d309 1
a309 1
		s = splsoftnet();
d311 1
a311 2
			(void) tsleep((caddr_t)&so->so_timeo, PSOCK,
				"nfscon", 2 * hz);
d316 1
a316 1
				splx(s);
d323 1
a323 1
			splx(s);
d326 1
a326 1
		splx(s);
@


1.113
log
@Keep local definitions local.

"good work" deraadt@@, ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.112 2016/12/19 08:36:50 mpi Exp $	*/
d1583 2
a1584 4
#ifdef notdef
	/*
	 * Define this to test for nfsds handling this under heavy load.
	 */
d1586 2
a1587 1
		slp->ns_flag |= SLP_NEEDQ; goto dorecs;
d1589 1
a1589 1
#endif
a1591 10
		/*
		 * If there are already records on the queue, defer soreceive()
		 * to an nfsd so that there is feedback to the TCP layer that
		 * the nfs servers are heavily loaded.
		 */
		if (slp->ns_rec && waitflag == M_DONTWAIT) {
			slp->ns_flag |= SLP_NEEDQ;
			goto dorecs;
		}

@


1.112
log
@Introduce the NET_LOCK() a rwlock used to serialize accesses to the parts
of the network stack that are not yet ready to be executed in parallel or
where new sleeping points are not possible.

This first pass replace all the entry points leading to ip_output(). This
is done to not introduce new sleeping points when trying to acquire ART's
write lock, needed when a new L2 entry is created via the RT_RESOLVE.

Inputs from and ok bluhm@@, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.111 2015/08/24 14:00:29 bluhm Exp $	*/
d131 10
@


1.111
log
@In kernel initialize struct sockaddr_in and sockaddr_in6 to zero
everywhere to avoid passing around pointers to uninitialized stack
memory.  While there, fix the call to in6_recoverscope() in
fill_drlist().
OK deraadt@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.110 2015/07/15 22:16:42 deraadt Exp $	*/
d1135 1
a1135 1
	s = splsoftnet();
d1218 1
a1218 1
	splx(s);
@


1.110
log
@m_freem() can handle NULL, do not check for this condition beforehands.
ok stsp mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.109 2015/06/11 16:00:36 mikeb Exp $	*/
d261 2
a262 1
		sin->sin_len = m->m_len = sizeof (struct sockaddr_in);
@


1.109
log
@Convert from hzto(9) to tvtohz(9);  OK dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.108 2015/03/14 03:38:52 jsg Exp $	*/
d653 1
a653 2
			    if (control)
				m_freem(control);
d763 1
a763 2
		if (nam)
			m_freem(nam);
@


1.108
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.107 2015/01/17 17:49:27 deraadt Exp $	*/
d1008 1
a1008 1
				tv.tv_sec = time_second + trylater_delay;
d1010 1
a1010 1
				tsleep(&tv, PSOCK, "nfsretry", hzto(&tv));
@


1.107
log
@use NGROUPS_MAX
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.106 2014/11/14 23:01:44 tedu Exp $	*/
a68 1
#include <nfs/nfsnode.h>
@


1.106
log
@bzero -> memset
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.105 2014/04/18 13:35:31 kettenis Exp $	*/
d1517 1
a1517 1
		    if (i < NGROUPS)
d1521 1
a1521 1
		nd->nd_cr.cr_ngroups = (len > NGROUPS) ? NGROUPS : len;
@


1.105
log
@If somebody else is already processing the RPC requests on a stream socket,
don't panic, but just return.

tested by nicm@@
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.104 2014/03/22 06:05:45 guenther Exp $	*/
d1506 1
a1506 1
		bzero((caddr_t)&nd->nd_cr, sizeof (struct ucred));
@


1.104
log
@Move p_sigacts from struct proc to struct process.

testing help mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.103 2014/01/19 03:04:54 claudio Exp $	*/
d1684 1
a1684 1
		panic("nfs getstream");
@


1.103
log
@Remove max_datalen. It is only used once an can be replaced easily with
MHLEN - max_hdr in that place. OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.102 2013/07/04 20:05:55 sf Exp $	*/
d1237 2
a1238 2
	    (((p->p_siglist & ~p->p_sigmask) & ~p->p_sigacts->ps_sigignore) &
	    NFSINT_SIGMASK))
@


1.102
log
@format string fixes: size_t and signedness

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.101 2011/07/05 04:48:02 guenther Exp $	*/
d1061 1
a1061 1
	if (siz >= max_datalen) {
@


1.101
log
@Recommit the reverted sigacts change now that the NFS use-after-free
problem has been tracked down.  This fixes the sharing of the signal
handling state: shared bits go in sigacts, per-rthread bits goes in
struct proc.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.100 2011/04/18 21:44:56 guenther Exp $	*/
d603 1
a603 1
				 "short receive (%d/%d) from nfs server %s\n",
d618 1
a618 1
			    log(LOG_ERR, "%s (%d) from nfs server %s\n",
d634 1
a634 1
				"short receive (%d/%d) from nfs server %s\n",
@


1.100
log
@Revert the sigacts diff: NFS can apparently retain pointers to processes
until they're zombies and then send them signals (for intr mounts).  Until
that is untangled, the sigacts change is unsafe.  sthen@@ was the victim
for this one
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.98 2010/07/05 16:32:07 deraadt Exp $	*/
d51 1
d1237 1
a1237 1
	    (((p->p_siglist & ~p->p_sigmask) & ~p->p_sigignore) &
@


1.99
log
@Correct the sharing of the signal handling state: stuff that should
be shared (p_sigignore, p_sigcatch, P_NOCLDSTOP, P_NOCLDWAIT) moves
to struct sigacts, wihle stuff that should be per rthread (ps_oldmask,
SAS_OLDMASK, ps_sigstk) moves to struct proc.  Treat the coredumping
state bits (ps_sig, ps_code, ps_type, ps_sigval) as per-rthread
until our locking around coredumping is better.

Oh, and remove the old SunOS-compat ps_usertramp member.

"I like the sound of this" tedu@@
@
text
@a50 1
#include <sys/signalvar.h>
d1236 1
a1236 1
	    (((p->p_siglist & ~p->p_sigmask) & ~p->p_sigacts->ps_sigignore) &
@


1.98
log
@If we find something is not aligned according to ALIGNED_POINTER(), we
cannot then re-align it using ALIGN().  That is not portable since we
have architectures where the modulo are quite different.  define an
ALIGN_POINTER() macro in place, and use it in one spot.

This caused a NFS crash on sparc (which borrows mbufs and chains them
itself in insane ways).  I heard claudio and beck trying to diagnose
it from over the room when suddenly I knew exactly what it was.
blambert spent a few hours on it making sure that I wasn't insane.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.97 2010/07/02 02:40:17 blambert Exp $	*/
d51 1
d1237 1
a1237 1
	    (((p->p_siglist & ~p->p_sigmask) & ~p->p_sigignore) &
@


1.97
log
@m_copyback can fail to allocate memory, but is a void fucntion so gymnastics
are required to detect that.

Change the function to take a wait argument (used in nfs server, but
M_NOWAIT everywhere else for now) and to return an error

ok claudio@@ henning@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.96 2009/10/19 22:24:18 jsg Exp $	*/
d1394 2
a1395 1
			if (ALIGN(m->m_len) >= MINCLSIZE) {
@


1.96
log
@antsy
no binary change apart from nfsm_reqhead() which is clearly correct.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.95 2009/08/25 13:41:29 thib Exp $	*/
d1409 1
a1409 1
			m_copyback(n, off, m->m_len, mtod(m, caddr_t));
@


1.95
log
@move to having requests on a per nfsmount tailq instead of one global one.
also make the rexmit timeout per nfsmount, and make sure to start/stop the
timer appropriately.

now the nfs_timer() only fires if there is work todo, not always at nfs_ticks
(it did, even if there where no nfsmounts in the system!).

OK blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.90 2009/07/20 16:49:40 thib Exp $	*/
d225 1
a225 3
nfs_connect(nmp, rep)
	struct nfsmount *nmp;
	struct nfsreq *rep;
d383 1
a383 2
nfs_reconnect(rep)
	struct nfsreq *rep;
d413 1
a413 2
nfs_disconnect(nmp)
	struct nfsmount *nmp;
d439 2
a440 5
nfs_send(so, nam, top, rep)
	struct socket *so;
	struct mbuf *nam;
	struct mbuf *top;
	struct nfsreq *rep;
d501 1
a501 4
nfs_receive(rep, aname, mp)
	struct nfsreq *rep;
	struct mbuf **aname;
	struct mbuf **mp;
d723 1
a723 2
nfs_reply(myrep)
	struct nfsreq *myrep;
d1046 2
a1047 7
nfs_rephead(siz, nd, slp, err, mrq, mbp)
	int siz;
	struct nfsrv_descript *nd;
	struct nfssvc_sock *slp;
	int err;
	struct mbuf **mrq;
	struct mbuf **mbp;
d1228 1
a1228 4
nfs_sigintr(nmp, rep, p)
	struct nfsmount *nmp;
	struct nfsreq *rep;
	struct proc *p;
d1249 1
a1249 3
nfs_sndlock(flagp, rep)
	int *flagp;
	struct nfsreq *rep;
d1279 1
a1279 2
nfs_sndunlock(flagp)
	int *flagp;
d1292 1
a1292 2
nfs_rcvlock(rep)
	struct nfsreq *rep;
d1328 1
a1328 2
nfs_rcvunlock(flagp)
	int *flagp;
d1433 1
a1433 4
nfs_getreq(nd, nfsd, has_header)
	struct nfsrv_descript *nd;
	struct nfsd *nfsd;
	int has_header;
d1563 1
a1563 4
nfsrv_rcv(so, arg, waitflag)
	struct socket *so;
	caddr_t arg;
	int waitflag;
d1673 1
a1673 3
nfsrv_getstream(slp, waitflag)
	struct nfssvc_sock *slp;
	int waitflag;
d1792 2
a1793 4
nfsrv_dorec(slp, nfsd, ndp)
	struct nfssvc_sock *slp;
	struct nfsd *nfsd;
	struct nfsrv_descript **ndp;
@


1.94
log
@Remove the v2 writegather code. It did help alot back in the 80s
but extensive performance benchmarking done by myself and jasper@@
has shown that it doesn't help, at all - even on vaxens and in some
cases it makes things significantly slower.

"this excites me sexually" jetpack@@
Tested by jasper@@.
OK blambert@@
@
text
@a78 2
struct nfsreqhead nfs_reqq;

d404 3
a406 5
	TAILQ_FOREACH(rp, &nfs_reqq, r_chain) {
		if (rp->r_nmp == nmp) {
			rp->r_flags |= R_MUSTRESEND;
			rp->r_rexmit = 0;
		}
d797 1
a797 1
		TAILQ_FOREACH(rep, &nfs_reqq, r_chain) {
d918 3
a920 1
	TAILQ_INSERT_TAIL(&nfs_reqq, rep, r_chain);
d959 3
a961 1
	TAILQ_REMOVE(&nfs_reqq, rep, r_chain);
d1144 1
a1144 2
nfs_timer(arg)
	void *arg;
d1146 1
a1146 1
	struct timeout *to = (struct timeout *)arg;
d1150 1
a1150 3
	struct nfsmount *nmp;
	int timeo;
	int s, error;
d1153 1
a1153 2
	TAILQ_FOREACH(rep, &nfs_reqq, r_chain) {
		nmp = rep->r_nmp;
d1236 1
a1236 1
	timeout_add(to, nfs_ticks);
@


1.93
log
@group all of the on-stack variables that are uses by the nfsm_macros
to keep the data munging "state" into an nfsm_info structure. Each
function now has this structure on its stack, and it and its members
are now passed around so that the macros/functions can work there magic.

this will make removing the nfsm_* macros way easier.

Idea/code picked up from DragonflyBSD.

Tested by krw@@, jacekm@@ and myself.

OK blambert@@.
@
text
@a1153 4
#ifdef NFSSERVER
	struct nfssvc_sock *slp;
	struct timeval tv;
#endif
a1238 13

#ifdef NFSSERVER
	/*
	 * Scan the write gathering queues for writes that need to be
	 * completed now.
	 */
	getmicrotime(&tv);
	TAILQ_FOREACH(slp, &nfssvc_sockhead, ns_chain) {
		if (LIST_FIRST(&slp->ns_tq) &&
		    timercmp(&LIST_FIRST(&slp->ns_tq)->nd_time, &tv, <=))
			nfsrv_wakenfsd(slp);
	}
#endif /* NFSSERVER */
a1550 2
		if (nd->nd_cr.cr_ngroups > 1)
		    nfsrvw_sort(nd->nd_cr.cr_groups, nd->nd_cr.cr_ngroups);
@


1.92
log
@make sure we only ever try to read out post-op attributes
or wcc data if we have a proper reply.

found the hard way by ariane@@, tested by ariane@@.

OK blambert@@
@
text
@d742 2
a743 1
	struct mbuf *mrep, *nam, *md;
d745 1
a745 1
	caddr_t dpos, cp2;
d765 1
a765 1
		error = nfs_receive(myrep, &nam, &mrep);
d785 2
a786 2
		md = mrep;
		dpos = mtod(md, caddr_t);
d791 1
a791 1
			m_freem(mrep);
d804 3
a806 3
				rep->r_mrep = mrep;
				rep->r_md = md;
				rep->r_dpos = dpos;
d837 1
a837 1
			m_freem(mrep);
d857 1
a857 9
nfs_request(vp, mrest, procnum, procp, cred, mrp, mdp, dposp)
	struct vnode *vp;
	struct mbuf *mrest;
	int procnum;
	struct proc *procp;
	struct ucred *cred;
	struct mbuf **mrp;
	struct mbuf **mdp;
	caddr_t *dposp;
d860 6
d868 1
d873 1
a873 1
	rep->r_procp = procp;
d877 1
a877 1
	m = mrest;
d885 1
a885 1
	rep->r_mreq->m_next = mrest;
a887 16
	return (nfs_request1(rep, cred, mrp, mdp, dposp));
}

int
nfs_request1(struct nfsreq *rep, struct ucred *cred, struct mbuf **mrp,
    struct mbuf **mdp, caddr_t *dposp)
{
	struct mbuf *m, *mrep;
	u_int32_t *tl;
	struct nfsmount *nmp;
	struct mbuf *md;
	struct timeval tv;
	caddr_t dpos, cp2;
	int t1, i, s, error = 0;
	int trylater_delay;

d893 1
a893 1
	nfsm_rpchead(rep, cred, RPCAUTH_UNIX);
d978 3
a980 3
	mrep = rep->r_mrep;
	md = rep->r_md;
	dpos = rep->r_dpos;
d982 1
a982 1
		*mrp = NULL;
d995 1
a995 1
		*mrp = NULL;
d1017 1
a1017 1
				m_freem(mrep);
d1042 3
a1044 3
	*mrp = mrep;
	*mdp = md;
	*dposp = dpos;
d1486 1
a1486 1
	caddr_t dpos, cp2;
d1489 1
a1489 1
	struct mbuf *mrep, *md;
d1491 3
a1493 3
	mrep = nd->nd_mrep;
	md = nd->nd_md;
	dpos = nd->nd_dpos;
d1498 1
a1498 1
			m_freem(mrep);
d1539 1
a1539 1
		m_freem(mrep);
d1547 1
a1547 1
			m_freem(mrep);
d1558 1
a1558 1
			m_freem(mrep);
d1572 1
a1572 1
			m_freem(mrep);
d1583 2
a1584 2
	nd->nd_md = md;
	nd->nd_dpos = dpos;
@


1.91
log
@Instead of calculating a number of seconds to sleep, tsleep()ing on
lbolt and waking up every second and checking to see if the correct
number of seconds has passed, just calculate the timeout once and
pass that to tsleep().

ok thib@@
@
text
@d997 4
a1000 2
	if (error)
		goto nfsmout;
d1011 2
a1012 1
		goto nfsmout;
d1061 1
@


1.90
log
@(struct foo *)0 -> NULL, every where I could find it.

OK blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.89 2009/07/20 11:47:58 blambert Exp $	*/
d899 1
a899 1
	time_t waituntil;
d1029 1
a1029 1
				error == NFSERR_TRYLATER) {
d1032 3
a1034 4
				waituntil = time_second + trylater_delay;
				while (time_second < waituntil)
					(void) tsleep((caddr_t)&lbolt,
						PSOCK, "nqnfstry", 0);
@


1.89
log
@For memory that gets allocated for every NFS request, pools make more
sense than malloc.

ok thib@@, who says the puffin still gets it either way
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.88 2009/07/18 20:30:22 thib Exp $	*/
d237 1
a237 1
	nmp->nm_so = (struct socket *)0;
d427 1
a427 1
		nmp->nm_so = (struct socket *)0;
d471 1
a471 1
		sendnam = (struct mbuf *)0;
d479 1
a479 2
	error = sosend(so, sendnam, (struct uio *)0, top,
		(struct mbuf *)0, flags);
d530 2
a531 2
	*mp = (struct mbuf *)0;
	*aname = (struct mbuf *)0;
d597 2
a598 3
			   error = soreceive(so, (struct mbuf **)0, &auio,
				(struct mbuf **)0, (struct mbuf **)0, &rcvflg,
				0);
d641 2
a642 2
			    error =  soreceive(so, (struct mbuf **)0,
				&auio, mp, (struct mbuf **)0, &rcvflg, 0);
d665 2
a666 2
			    error =  soreceive(so, (struct mbuf **)0,
				&auio, mp, &control, &rcvflg, 0);
d684 1
a684 1
			*mp = (struct mbuf *)0;
d702 1
a702 1
			getnam = (struct mbuf **)0;
d709 2
a710 2
			error =  soreceive(so, getnam, &auio, mp,
				(struct mbuf **)0, &rcvflg, 0);
d719 1
a719 1
		*mp = (struct mbuf *)0;
d1227 1
a1227 1
			    (struct mbuf *)0, (struct mbuf *)0, curproc);
d1230 1
a1230 1
			    nmp->nm_nam, (struct mbuf *)0, curproc);
d1314 1
a1314 1
		p = (struct proc *)0;
d1664 1
a1664 1
		error = soreceive(so, &nam, &auio, &mp, (struct mbuf **)0,
d1666 1
a1666 1
		if (error || mp == (struct mbuf *)0) {
d1700 1
a1700 1
			    (struct mbuf **)0, &flags, 0);
d1712 1
a1712 1
				m->m_nextpkt = (struct mbuf *)0;
d1795 1
a1795 1
		slp->ns_raw = slp->ns_rawend = (struct mbuf *)0;
d1800 1
a1800 1
		om = (struct mbuf *)0;
d1823 1
a1823 1
				om->m_next = (struct mbuf *)0;
d1851 1
a1851 1
		slp->ns_frag = (struct mbuf *)0;
d1871 1
a1871 1
	    (m = slp->ns_rec) == (struct mbuf *)0)
d1875 1
a1875 1
		m->m_nextpkt = (struct mbuf *)0;
d1877 1
a1877 1
		slp->ns_recend = (struct mbuf *)0;
@


1.88
log
@if -> in, and the sentance makes more sense.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.87 2009/07/18 14:40:31 thib Exp $	*/
d81 2
d1886 1
a1886 1
	nd = malloc(sizeof(struct nfsrv_descript), M_NFSRVDESC, M_WAITOK);
d1894 1
a1894 1
		free(nd, M_NFSRVDESC);
@


1.87
log
@Fixes for the NFSERR_RETERR commit.

- Make sure to set the mbuf pointers and the dpos pointer correctly
in nfs_request() before returning an error.

- Fix potential mbufs leaks in nfs_{read,write}rpc for v2. The reply
mbuf was not being freed before the jump to nfsmout.
- Reorder error handling to prevent an error case being treated as a
non-error case.

Fixes issues noticed by sthen@@ and ajacoutot@@. Tested by both of them.
Reviewd by oga@@
OK blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.84 2009/06/03 02:23:23 thib Exp $	*/
d1014 1
a1014 1
	 * reply verifer type, and if the (error) case that there really
@


1.86
log
@Make the callers of nfs_request() responsible for freeing the reply mbuf,
if the reply is an error and retire the NFS_RETERR hack. For NFSv3 mounts
the flag was set and reply mbuf not freed to allow the callers to handle
the post-op attributes, or just free the mbuf for NFSv2.

Tested by myself and jasper@@ on various arch's.
OK blambert@@.
@
text
@d997 2
a998 5
	if (error) {
		m_freem(rep->r_mreq);
		pool_put(&nfsreqpl, rep);
		return (error);
	}
d1008 2
a1009 5
			error = EACCES;
		m_freem(mrep);
		m_freem(rep->r_mreq);
		pool_put(&nfsreqpl, rep);
		return (error);
a1049 5

		*mrp = mrep;
		*mdp = md;
		*dposp = dpos;

d1056 3
@


1.85
log
@typo; init -> in it

ok thib@@
@
text
@a1054 11

			if (nmp->nm_flag & NFSMNT_NFSV3 || error == ESTALE) {
				*mrp = mrep;
				*mdp = md;
				*dposp = dpos;
				error |= NFSERR_RETERR;
			} else
				m_freem(mrep);
			m_freem(rep->r_mreq);
			pool_put(&nfsreqpl, rep);
			return (error);
d1060 2
a1061 3
		m_freem(rep->r_mreq);
		pool_put(&nfsreqpl, rep);
		return (0);
d1063 1
a1063 1
	m_freem(mrep);
d1065 1
@


1.84
log
@remove cruft that snuck in with previous
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.83 2009/06/03 00:12:34 thib Exp $	*/
d1021 1
a1021 1
	 * is any data init, we advance over it.
@


1.83
log
@Lift the NFS over UDP retransmit logic from FreeBSD.

OK blambert@@

FreeBSD commit message:
Refactor the NFS over UDP retransmit timeout estimation logic to allow
the estimator to be more easily tuned and maintained.

There should be no functional change except there is now a lower limit
on the retransmit timeout to prevent the client from retransmitting
faster than the server's disks can fill requests, and an upper limit
to prevent the estimator from taking to long to retransmit during a
server outage.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.82 2009/06/02 23:16:59 thib Exp $	*/
a95 1
#define	NFS_NBACKOFF	8
@


1.82
log
@give the retransmission count booking keeping a facelift,
just store the maximun amount of rexmits in one place and
cleanup. Also make sure this only effects soft mounts.

OK blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.77 2009/01/24 23:35:47 thib Exp $	*/
d71 1
a71 22
/*
 * Estimate rto for an nfs rpc sent via. an unreliable datagram.
 * Use the mean and mean deviation of rtt for the appropriate type of rpc
 * for the frequent rpcs and a default for the others.
 * The justification for doing "other" this way is that these rpcs
 * happen so infrequently that timer est. would probably be stale.
 * Also, since many of these rpcs are
 * non-idempotent, a conservative timeout is desired.
 * getattr, lookup - A+2D
 * read, write     - A+4D
 * other           - nm_timeo
 */
#define	NFS_RTO(n, t) \
	((t) == 0 ? (n)->nm_timeo : \
	 ((t) < 3 ? \
	  (((((n)->nm_srtt[t-1] + 3) >> 2) + (n)->nm_sdrtt[t-1] + 1) >> 1) : \
	  ((((n)->nm_srtt[t-1] + 7) >> 3) + (n)->nm_sdrtt[t-1] + 1)))
#define	NFS_SRTT(r)	(r)->r_nmp->nm_srtt[proct[(r)->r_procnum] - 1]
#define	NFS_SDRTT(r)	(r)->r_nmp->nm_sdrtt[proct[(r)->r_procnum] - 1]
/*
 * External data, mostly RPC constants in XDR form
 */
d79 1
a79 11
/*
 * Defines which timer to use for the procnum.
 * 0 - default
 * 1 - getattr
 * 2 - lookup
 * 3 - read
 * 4 - write
 */
static int proct[NFS_NPROCS] = {
	0, 1, 0, 2, 1, 3, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0,
};
d96 33
a128 1
static int nfs_backoff[8] = { 2, 4, 8, 16, 32, 64, 128, 256, };
d135 85
a219 1
struct nfsreqhead nfs_reqq;
d365 1
a365 4
	nmp->nm_srtt[0] = nmp->nm_srtt[1] = nmp->nm_srtt[2] =
	    nmp->nm_srtt[3] = (NFS_TIMEO << 3);
	nmp->nm_sdrtt[0] = nmp->nm_sdrtt[1] = nmp->nm_sdrtt[2] =
	    nmp->nm_sdrtt[3] = 0;
a742 1
	int32_t t1;
d744 1
a744 1
	u_int32_t rxid, *tl;
d822 4
a825 21
				/*
				 * Update rtt using a gain of 0.125 on the mean
				 * and a gain of 0.25 on the deviation.
				 */
				if (rep->r_flags & R_TIMING) {
					/*
					 * Since the timer resolution of
					 * NFS_HZ is so course, it can often
					 * result in r_rtt == 0. Since
					 * r_rtt == N means that the actual
					 * rtt is between N+dt and N+2-dt ticks,
					 * add 1.
					 */
					t1 = rep->r_rtt + 1;
					t1 -= (NFS_SRTT(rep) >> 3);
					NFS_SRTT(rep) += t1;
					if (t1 < 0)
						t1 = -t1;
					t1 -= (NFS_SDRTT(rep) >> 2);
					NFS_SDRTT(rep) += t1;
				}
d924 1
a924 1
	if (proct[rep->r_procnum] > 0)
d1206 1
a1206 1
				timeo = NFS_RTO(nmp, proct[rep->r_procnum]);
@


1.81
log
@Remove unused procnums (NQNFS leftovers) and cleanup.

OK blambert@@ sometime ago
@
text
@a858 4
	if (nmp->nm_flag & NFSMNT_SOFT)
		rep->r_retry = nmp->nm_retry;
	else
		rep->r_retry = NFS_MAXREXMIT + 1;	/* past clip limit */
d1109 2
a1110 4
 * Nfs timer routine
 * Scan the nfsreq list and retranmit any requests that have timed out
 * To avoid retransmission attempts on STREAM sockets (in the future) make
 * sure to set the r_retry field to 0 (implies nm_retry == 0).
d1150 3
a1152 5
		/*
		 * Check for server not responding
		 */
		if ((rep->r_flags & R_TPRINTFMSG) == 0 &&
		     rep->r_rexmit > nmp->nm_deadthresh) {
d1156 1
a1156 1
		if (rep->r_rexmit >= rep->r_retry) {	/* too many */
d1166 1
@


1.80
log
@retire the nfs rtt log code, this isnt really all that
usefull, and has been disabled for a long long time.
Cleans house a bit.

OK blambert@@
@
text
@a109 1
	0, 0, 0,
@


1.79
log
@nicer (unique) wmesg for the tsleep(9) in nfs_reconnect();
@
text
@a68 1
#include <nfs/nfsrtt.h>
a128 2
int nfsrtton = 0;
struct nfsrtt nfsrtt;
a726 2
				if (nfsrtton) {
					struct rttl *rt;
a727 15
					rt = &nfsrtt.rttl[nfsrtt.pos];
					rt->proc = rep->r_procnum;
					rt->rto = NFS_RTO(nmp, proct[rep->r_procnum]);
					rt->sent = nmp->nm_sent;
					rt->cwnd = nmp->nm_cwnd;
					rt->srtt = nmp->nm_srtt[proct[rep->r_procnum] - 1];
					rt->sdrtt = nmp->nm_sdrtt[proct[rep->r_procnum] - 1];
					rt->fsid = nmp->nm_mountp->mnt_stat.f_fsid;
					getmicrotime(&rt->tstamp);
					if (rep->r_flags & R_TIMING)
						rt->rtt = rep->r_rtt;
					else
						rt->rtt = 1000000;
					nfsrtt.pos = (nfsrtt.pos + 1) % NFSRTTLOGSIZ;
				}
@


1.78
log
@fix PR 6082: do not create more fd's than will fit in the message on
the receiving side when passing fd's. ok deraadt@@ kettenis@@
@
text
@d319 1
a319 1
		(void) tsleep((caddr_t)&lbolt, PSOCK, "nfscon", 0);
@


1.77
log
@Use a timespec for the server write deadline and procrastination
timeouts. Rrids us of the ugly cur_sec variable, and some shadows.
Also helps with granularity.

Diff from blambert@@ who asked me to commit this since he's away for
some days and we wanted to put this in with the timespec changes in
the nfsnode.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.76 2009/01/24 11:40:06 thib Exp $	*/
d520 2
a521 1
				(struct mbuf **)0, (struct mbuf **)0, &rcvflg);
d565 1
a565 1
				&auio, mp, (struct mbuf **)0, &rcvflg);
d589 1
a589 1
				&auio, mp, &control, &rcvflg);
d633 1
a633 1
				(struct mbuf **)0, &rcvflg);
d1648 2
a1649 1
		error = soreceive(so, &nam, &auio, &mp, (struct mbuf **)0, &flags);
d1684 1
a1684 1
						(struct mbuf **)0, &flags);
@


1.76
log
@magic 8 -> nitems(nfs_backoff)

prompted by David <dunnoseriously _att_ gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.75 2009/01/22 18:14:21 bluhm Exp $	*/
a1151 1
	u_quad_t cur_usec;
a1245 1
	cur_usec = (u_quad_t)tv.tv_sec * 1000000 + (u_quad_t)tv.tv_usec;
d1248 1
a1248 1
		    LIST_FIRST(&slp->ns_tq)->nd_time <= cur_usec)
@


1.75
log
@After the NFS server had sent a reply of size readsize or readdirsize,
the udp receive space got completely filled up.  Even if the next
packet from the server was a small reply, it got dropped by
udp_input().  After a second the client resent the NFS request.

Doubling rcvreserve reduces the chance of retransmits by having
enough recv space for multiple NFS replies even if there comes a
big one.

found with pedro@@,  ok blambert@@, thib@@, pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.74 2009/01/22 13:51:37 bluhm Exp $	*/
d1174 1
a1174 1
			if (nmp->nm_timeouts < 8)
@


1.74
log
@The variable nfs_reqq was protected by splsoftnet() only in 3 out
of 5 cases.  In the functions nfs_reconnect() and nfs_reply() put
the TAILQ_FOREACH over nfs_reqq also inside splsoftnet() protection.

found with pedro@@,  ok blambert@@, pedro@@, thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.73 2009/01/20 18:03:33 blambert Exp $	*/
d251 2
a252 2
		rcvreserve = max(nmp->nm_rsize, nmp->nm_readdirsize) +
		    NFS_MAXPKTHDR;
@


1.73
log
@Start reworking NFS client mbuf handling by creating an interface which
requires well-formed mbuf chains to work. Existing function name is now
a wrapper to this interface. Much, much more work to follow which will
build on this.

Truly change we can believe in.

ok thib@@, who would have preferred this in two commits, but I'm impatient :)

testing on multiple arches (i386, arm, amd64, and sparc64 at least) by many,
thanks to all who did so
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.72 2009/01/16 17:11:28 thib Exp $	*/
d313 1
a313 1
	int error;
d326 1
d333 1
d668 1
a668 1
	int error;
d722 1
d786 1
@


1.72
log
@turn nfs_msg into void functions, also make it take an nfsreq
argument since all of the info we need is there, makes it and
the use it a tad bit nicer.

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.71 2008/12/24 02:43:52 thib Exp $	*/
d819 29
a848 1
	struct nfsreq *rep;
a849 1
	int i;
d854 1
a854 1
	int t1, s, error = 0, mrest_len;
d859 1
a859 13
	nmp = VFSTONFS(vp->v_mount);
	rep = pool_get(&nfsreqpl, PR_WAITOK);
	rep->r_nmp = nmp;
	rep->r_vp = vp;
	rep->r_procp = procp;
	rep->r_procnum = procnum;
	i = 0;
	m = mrest;
	while (m) {
		i += m->m_len;
		m = m->m_next;
	}
	mrest_len = i;
d862 1
a862 1
	nfsm_rpchead(rep, cred, RPCAUTH_UNIX, mrest, mrest_len);
d880 1
a880 1
	if (proct[procnum] > 0)
d1011 1
a1011 1
				cache_purge(vp);
@


1.71
log
@Replace the TRUE/FALSE defines with 1/0 respectively. This doesn't
hurt readability and it was just plain annoying seeing them defined
in every other .c file.

OK blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.70 2008/10/31 17:28:47 blambert Exp $	*/
d935 1
a935 2
		nfs_msg(rep->r_procp, nmp->nm_mountp->mnt_stat.f_mntfromname,
		    "is alive again");
d1163 1
a1163 3
			nfs_msg(rep->r_procp,
			    nmp->nm_mountp->mnt_stat.f_mntfromname,
			    "not responding");
d1569 2
a1570 4
int
nfs_msg(p, server, msg)
	struct proc *p;
	char *server, *msg;
d1574 2
a1575 2
	if (p)
		tpr = tprintf_open(p);
d1578 3
a1580 1
	tprintf(tpr, "nfs server %s: %s\n", server, msg);
a1581 1
	return (0);
@


1.70
log
@Revert last commit; mbuf leaks are not solved by double-freeing mbuf chains

blambert@@--

Real solution is to fix NFS mbuf handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.69 2008/10/26 15:53:16 blambert Exp $	*/
a71 3
#define	TRUE	1
#define	FALSE	0

d1858 1
a1858 1
	error = nfs_getreq(nd, nfsd, TRUE);
@


1.69
log
@Plug mbuf leak in RPC record error case.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.68 2008/09/12 15:41:40 thib Exp $	*/
d1863 1
a1863 4
		if (nd->nd_nam2)
			m_freem(nd->nd_nam2);
		if (nd->nd_mrep)
			m_freem(nd->nd_mrep);
@


1.68
log
@move the declaration of nfsrv3_procs to nfs_syscalls.c

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.67 2008/07/10 18:17:56 thib Exp $	*/
d1863 4
a1866 1
		m_freem(nam);
@


1.67
log
@nuke two bogus ARGSUSED
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.66 2008/07/05 18:28:08 blambert Exp $	*/
a1591 31
int (*nfsrv3_procs[NFS_NPROCS])(struct nfsrv_descript *,
				    struct nfssvc_sock *, struct proc *,
				    struct mbuf **) = {
	nfsrv_null,
	nfsrv_getattr,
	nfsrv_setattr,
	nfsrv_lookup,
	nfsrv3_access,
	nfsrv_readlink,
	nfsrv_read,
	nfsrv_write,
	nfsrv_create,
	nfsrv_mkdir,
	nfsrv_symlink,
	nfsrv_mknod,
	nfsrv_remove,
	nfsrv_rmdir,
	nfsrv_rename,
	nfsrv_link,
	nfsrv_readdir,
	nfsrv_readdirplus,
	nfsrv_statfs,
	nfsrv_fsinfo,
	nfsrv_pathconf,
	nfsrv_commit,
	nfsrv_noop,
	nfsrv_noop,
	nfsrv_noop,
	nfsrv_noop
};

@


1.66
log
@When waking an nfs daemon, use wakeup_one vice wakeup, as
a) we're attempting to wake a specific process which
b) sleeps on a unique address
which means that there's no need to continue traversing the sleep
queue once the process has been found and awakened.

"looks good too me" thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.65 2008/07/05 17:34:26 thib Exp $	*/
a658 1
/* ARGSUSED */
@


1.65
log
@
Remove R_GETONEREP and the code that checks if its set
(its never set).

"please kill it" blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.64 2008/06/14 03:16:06 thib Exp $	*/
d1925 1
a1925 1
			wakeup(nfsd);
@


1.64
log
@Replace magic '2' and '3' with defines for nfs version numbers

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.63 2008/06/14 01:21:17 blambert Exp $	*/
a698 2
				if (myrep->r_flags & R_GETONEREP)
					return (0);
a716 2
			if (myrep->r_flags & R_GETONEREP)
				return (0);
a798 2
		if (myrep->r_flags & R_GETONEREP)
			return (0);
d1331 1
@


1.63
log
@Clean up nfsrv_wakenfsd(); variable name change to be in line with the
rest of NFS code, canonical for() -> LIST_FOREACH() change, minor
readability changes.

ANSIfy function while here.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.62 2008/06/13 03:54:26 blambert Exp $	*/
d1094 2
a1095 2
			*tl++ = txdr_unsigned(2);
			*tl = txdr_unsigned(3);
@


1.62
log
@Remove dead-end and never-used kerberos code in nfs. Future work
to support authentication other than AUTH_UNIX will replace this
with a (hopefully) much better system.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.61 2008/06/12 20:24:06 blambert Exp $	*/
d1916 1
a1916 2
nfsrv_wakenfsd(slp)
	struct nfssvc_sock *slp;
d1918 1
a1918 1
	struct nfsd *nd;
d1922 5
a1926 5
	for (nd = TAILQ_FIRST(&nfsd_head); nd != NULL;
	    nd = TAILQ_NEXT(nd, nfsd_chain)) {
		if (nd->nfsd_flag & NFSD_WAITING) {
			nd->nfsd_flag &= ~NFSD_WAITING;
			if (nd->nfsd_slp)
d1929 2
a1930 2
			nd->nfsd_slp = slp;
			wakeup((caddr_t)nd);
d1934 1
@


1.61
log
@Remove now-vestigial bpos pointer from NFS. For building outgoing
NFS mbufs, mbufs now contain all their internal buffer state internally,
the way god intended.

ok thib@@

testing johan@@ (and possibly merdely@@; this diff's been around for a bit...)
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.60 2008/06/11 04:52:27 blambert Exp $	*/
d98 1
a98 2
	rpc_auth_unix, rpc_msgaccepted, rpc_call, rpc_autherr,
	rpc_auth_kerb;
d1083 4
a1086 35
		/*
		 * For Kerberos authentication, we must send the nickname
		 * verifier back, otherwise just RPCAUTH_NULL.
		 */
		if (nd->nd_flag & ND_KERBFULL) {
		    struct nfsuid *nuidp;
		    struct timeval ktvin, ktvout;

		    LIST_FOREACH(nuidp, NUIDHASH(slp, nd->nd_cr.cr_uid),
		     nu_hash) {
			if (nuidp->nu_cr.cr_uid == nd->nd_cr.cr_uid &&
			    (!nd->nd_nam2 || netaddr_match(NU_NETFAM(nuidp),
			     &nuidp->nu_haddr, nd->nd_nam2)))
			    break;
		    }
		    if (nuidp) {
			ktvin.tv_sec =
			    txdr_unsigned(nuidp->nu_timestamp.tv_sec - 1);
			ktvin.tv_usec =
			    txdr_unsigned(nuidp->nu_timestamp.tv_usec);

			*tl++ = rpc_auth_kerb;
			*tl++ = txdr_unsigned(3 * NFSX_UNSIGNED);
			*tl = ktvout.tv_sec;
			tl = nfsm_build(&mb, 3 * NFSX_UNSIGNED);
			*tl++ = ktvout.tv_usec;
			*tl++ = txdr_unsigned(nuidp->nu_cr.cr_uid);
		    } else {
			*tl++ = 0;
			*tl++ = 0;
		    }
		} else {
			*tl++ = 0;
			*tl++ = 0;
		}
d1477 1
a1477 3
	struct uio uio;
	struct iovec iov;
	caddr_t dpos, cp2, cp;
d1479 1
a1479 2
	uid_t nickuid;
	int error = 0, ticklen;
a1480 2
	struct nfsuid *nuidp;
	struct timeval tvin, tvout;
d1534 1
a1534 4
	nd->nd_flag &= ~ND_KERBAUTH;
	/*
	 * Handle auth_unix or auth_kerb.
	 */
a1567 90
	} else if (auth_type == rpc_auth_kerb) {
		switch (fxdr_unsigned(int, *tl++)) {
		case RPCAKN_FULLNAME:
			ticklen = fxdr_unsigned(int, *tl);
			*((u_int32_t *)nfsd->nfsd_authstr) = *tl;
			uio.uio_resid = nfsm_rndup(ticklen) + NFSX_UNSIGNED;
			nfsd->nfsd_authlen = uio.uio_resid + NFSX_UNSIGNED;
			if (uio.uio_resid > (len - 2 * NFSX_UNSIGNED)) {
				m_freem(mrep);
				return (EBADRPC);
			}
			uio.uio_offset = 0;
			uio.uio_iov = &iov;
			uio.uio_iovcnt = 1;
			uio.uio_segflg = UIO_SYSSPACE;
			iov.iov_base = (caddr_t)&nfsd->nfsd_authstr[4];
			iov.iov_len = RPCAUTH_MAXSIZ - 4;
			nfsm_mtouio(&uio, uio.uio_resid);
			nfsm_dissect(tl, u_int32_t *, 2 * NFSX_UNSIGNED);
			if (*tl++ != rpc_auth_kerb ||
				fxdr_unsigned(int, *tl) != 4 * NFSX_UNSIGNED) {
				printf("Bad kerb verifier\n");
				nd->nd_repstat = (NFSERR_AUTHERR|AUTH_BADVERF);
				nd->nd_procnum = NFSPROC_NOOP;
				return (0);
			}
			nfsm_dissect(cp, caddr_t, 4 * NFSX_UNSIGNED);
			tl = (u_int32_t *)cp;
			if (fxdr_unsigned(int, *tl) != RPCAKN_FULLNAME) {
				printf("Not fullname kerb verifier\n");
				nd->nd_repstat = (NFSERR_AUTHERR|AUTH_BADVERF);
				nd->nd_procnum = NFSPROC_NOOP;
				return (0);
			}
			cp += NFSX_UNSIGNED;
			bcopy(cp, nfsd->nfsd_verfstr, 3 * NFSX_UNSIGNED);
			nfsd->nfsd_verflen = 3 * NFSX_UNSIGNED;
			nd->nd_flag |= ND_KERBFULL;
			nfsd->nfsd_flag |= NFSD_NEEDAUTH;
			break;
		case RPCAKN_NICKNAME:
			if (len != 2 * NFSX_UNSIGNED) {
				printf("Kerb nickname short\n");
				nd->nd_repstat = (NFSERR_AUTHERR|AUTH_BADCRED);
				nd->nd_procnum = NFSPROC_NOOP;
				return (0);
			}
			nickuid = fxdr_unsigned(uid_t, *tl);
			nfsm_dissect(tl, u_int32_t *, 2 * NFSX_UNSIGNED);
			if (*tl++ != rpc_auth_kerb ||
				fxdr_unsigned(int, *tl) != 3 * NFSX_UNSIGNED) {
				printf("Kerb nick verifier bad\n");
				nd->nd_repstat = (NFSERR_AUTHERR|AUTH_BADVERF);
				nd->nd_procnum = NFSPROC_NOOP;
				return (0);
			}
			nfsm_dissect(tl, u_int32_t *, 3 * NFSX_UNSIGNED);
			tvin.tv_sec = *tl++;
			tvin.tv_usec = *tl;

			LIST_FOREACH(nuidp, NUIDHASH(nfsd->nfsd_slp, nickuid),
			    nu_hash) {
				if (nuidp->nu_cr.cr_uid == nickuid &&
				    (!nd->nd_nam2 ||
				     netaddr_match(NU_NETFAM(nuidp),
				      &nuidp->nu_haddr, nd->nd_nam2)))
					break;
			}
			if (!nuidp) {
				nd->nd_repstat =
					(NFSERR_AUTHERR|AUTH_REJECTCRED);
				nd->nd_procnum = NFSPROC_NOOP;
				return (0);
			}

			tvout.tv_sec = fxdr_unsigned(long, tvout.tv_sec);
			tvout.tv_usec = fxdr_unsigned(long, tvout.tv_usec);
			if (nuidp->nu_expire < time_second ||
			    nuidp->nu_timestamp.tv_sec > tvout.tv_sec ||
			    (nuidp->nu_timestamp.tv_sec == tvout.tv_sec &&
			     nuidp->nu_timestamp.tv_usec > tvout.tv_usec)) {
				nuidp->nu_expire = 0;
				nd->nd_repstat =
				    (NFSERR_AUTHERR|AUTH_REJECTVERF);
				nd->nd_procnum = NFSPROC_NOOP;
				return (0);
			}
			nfsrv_setcred(&nuidp->nu_cr, &nd->nd_cr);
			nd->nd_flag |= ND_KERBNICK;
		};
@


1.60
log
@Canonical for() -> queue.h FOREACH macro conversions.
Also, it is historical practice to #include <sys/queue.h>
when using queue.h macros.

ok thib@@ krw@@

special thanks to krw@@ for reminders vice violence
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.59 2008/05/23 15:51:12 thib Exp $	*/
d1043 1
a1043 1
nfs_rephead(siz, nd, slp, err, mrq, mbp, bposp)
a1049 1
	caddr_t *bposp;
a1052 1
	caddr_t bpos;
a1067 1
	bpos = ((caddr_t)tl) + mreq->m_len;
a1075 1
			bpos -= NFSX_UNSIGNED;
d1108 1
a1108 1
			tl = nfsm_build(&mb, 3 * NFSX_UNSIGNED, &bpos);
d1125 1
a1125 1
			tl = nfsm_build(&mb, 2 * NFSX_UNSIGNED, &bpos);
d1138 1
a1138 1
				tl = nfsm_build(&mb, NFSX_UNSIGNED, &bpos);
a1150 1
	*bposp = bpos;
@


1.59
log
@Deal with the situation when TCP nfs mounts timeout and processes
get hung in nfs_reconnect() because they do not have the proper
privilages to bind to a socket, by adding a struct proc * argument
to sobind() (and the *_usrreq() routines, and finally in{6}_pcbbind)
and do the sobind() with proc0 in nfs_connect.

OK markus@@, blambert@@.
"go ahead" deraadt@@.

Fixes an issue reported by bernd@@ (Tested by bernd@@).
Fixes PR5135 too.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.58 2008/05/13 17:47:42 thib Exp $	*/
d57 1
d729 1
a729 2
		for (rep = TAILQ_FIRST(&nfs_reqq); rep != NULL;
		    rep = TAILQ_NEXT(rep, r_chain)) {
@


1.58
log
@
don't grab the receive lock in nfs_rcvlock if the reply has
already been received while we slept. prevents processes from
monopolising the lock.

From FreeBSD;

ok blambert@@
tested by johan@@ and a few others
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.57 2008/01/06 17:38:23 blambert Exp $	*/
d190 1
a190 1
		error = sobind(so, m);
d1242 1
a1242 1
			    (struct mbuf *)0, (struct mbuf *)0);
d1245 1
a1245 1
			    nmp->nm_nam, (struct mbuf *)0);
@


1.57
log
@More NFS-related kernel shrinkage...

When you use a macro ~200 times, it tends to bloat your code, so make a
function out of it.

Shaves ~8.5 kB from my kernel.

ok thib@@, "looks good" krw@@

In snaps for 1+ week with no negative reports.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.56 2007/12/28 17:25:18 thib Exp $	*/
d684 2
a685 6
			return (error);
		/* Already received, bye bye */
		if (myrep->r_mrep != NULL) {
			nfs_rcvunlock(&nmp->nm_flag);
			return (0);
		}
d1380 7
@


1.56
log
@nfs_sndlock() is often called with its rep argument
as NULL, so make sure its non-NULL before attempting
to reference it.

Fixes PR5694; Confirmed by submitter.

OK art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.55 2007/10/28 14:12:41 thib Exp $	*/
d1059 1
a1059 1
	struct mbuf *mb, *mb2;
d1116 1
a1116 1
			nfsm_build(tl, u_int32_t *, 3 * NFSX_UNSIGNED);
d1133 1
a1133 1
			nfsm_build(tl, u_int32_t *, 2 * NFSX_UNSIGNED);
d1146 1
a1146 1
				nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED);
@


1.55
log
@Remove the "frev" argument from nfs_rephead(); and clean up the "frev"
variables, that are declared all over, since they are passed via macros
to nfs_rephead(); which doesn't do anything with it.

OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.54 2007/10/17 17:44:23 thib Exp $	*/
d1336 1
a1336 1
		if (nfs_sigintr(rep->r_nmp, rep, p))
@


1.54
log
@use TAILQ_FOREACH() where applicable in nfs_timer();

ok art@@, blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.53 2007/10/15 21:09:44 thib Exp $	*/
d1047 1
a1047 1
nfs_rephead(siz, nd, slp, err, frev, mrq, mbp, bposp)
a1051 1
	u_quad_t *frev;
@


1.53
log
@Remove a set, but unused varible in nfs_socket();
NQNFS leftover.

ok miod@@,blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.52 2007/10/13 17:38:43 thib Exp $	*/
d1190 1
a1190 2
	for (rep = TAILQ_FIRST(&nfs_reqq); rep != NULL;
	    rep = TAILQ_NEXT(rep, r_chain)) {
d1284 4
a1287 5
	for (slp = TAILQ_FIRST(&nfssvc_sockhead); slp != NULL;
	    slp = TAILQ_NEXT(slp, ns_chain)) {
	    if (LIST_FIRST(&slp->ns_tq) &&
	        LIST_FIRST(&slp->ns_tq)->nd_time <= cur_usec)
		nfsrv_wakenfsd(slp);
@


1.52
log
@Remove alot of dead kerberos code (add sane comments too).

Cleanup and partly redo the way we create the RPC header, by having
nfsm_rpchead() do a bit more work. Right now this is pretty RPCAUTH_UNIX
centric, but since it is the only auth method we support right now thats
fine.

Make sure we can never generate a zero xid, thats forbidden by the RFC.

Misc cleanup.

tested by a few.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.51 2007/09/20 15:30:41 blambert Exp $	*/
d840 1
a840 1
	time_t reqtime, waituntil;
a895 3

	/* Get send time for nqnfs */
	reqtime = time_second;
@


1.51
log
@Don't rely on mbuf.h including pool.h (which is going to stop soon)

ok thib@@ henning@@ art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.50 2007/09/20 12:54:31 thib Exp $	*/
d839 1
a839 2
	struct mbuf *md, *mheadend;
	char nickv[RPCX_NICKVERF];
d842 2
a843 6
	int t1, s, error = 0, mrest_len, auth_len, auth_type;
	int trylater_delay, failed_auth = 0;
	int verf_len, verf_type;
	u_int32_t xid;
	char *auth_str, *verf_str;
	NFSKERBKEY_T key;		/* save session key */
d861 3
a863 30
	/*
	 * Get the RPC header with authorization.
	 */
kerbauth:
	verf_str = auth_str = (char *)0;
	if (nmp->nm_flag & NFSMNT_KERB) {
		verf_str = nickv;
		verf_len = sizeof (nickv);
		auth_type = RPCAUTH_KERB4;
		bzero((caddr_t)key, sizeof (key));
		if (failed_auth || nfs_getnickauth(nmp, cred, &auth_str,
			&auth_len, verf_str, verf_len)) {
			error = nfs_getauth(nmp, rep, cred, &auth_str,
				&auth_len, verf_str, &verf_len, key);
			if (error) {
				pool_put(&nfsreqpl, rep);
				m_freem(mrest);
				return (error);
			}
		}
	} else {
		auth_type = RPCAUTH_UNIX;
		auth_len = (((cred->cr_ngroups > nmp->nm_numgrps) ?
			nmp->nm_numgrps : cred->cr_ngroups) << 2) +
			5 * NFSX_UNSIGNED;
	}
	m = nfsm_rpchead(cred, nmp->nm_flag, procnum, auth_type, auth_len,
	     auth_str, verf_len, verf_str, mrest, mrest_len, &mheadend, &xid);
	if (auth_str)
		free(auth_str, M_TEMP);
d873 1
a873 2
	rep->r_mreq = m;
	rep->r_xid = xid;
d971 1
a971 10
		else if ((nmp->nm_flag & NFSMNT_KERB) && *tl++ == rpc_autherr) {
			if (!failed_auth) {
				failed_auth++;
				mheadend->m_next = (struct mbuf *)0;
				m_freem(mrep);
				m_freem(rep->r_mreq);
				goto kerbauth;
			} else
				error = EAUTH;
		} else
d980 3
a982 1
	 * Grab any Kerberos verifier, otherwise just throw it away.
d984 1
a984 1
	verf_type = fxdr_unsigned(int, *tl++);
d986 3
a988 6
	if ((nmp->nm_flag & NFSMNT_KERB) && verf_type == RPCAUTH_KERB4) {
		error = nfs_savenickauth(nmp, cred, i, key, &md, &dpos, mrep);
		if (error)
			goto nfsmout;
	} else if (i > 0)
		nfsm_adv(nfsm_rndup(i));
@


1.50
log
@MALLOC/FREE -> malloc/free + M_ZERO.
Uneeded includes and casts...

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.49 2007/06/25 20:40:00 thib Exp $	*/
d56 1
@


1.49
log
@replace magic number with a define.
(2 -> SHUT_RDWR in calls to soshutdown()).

From Iruata Souza.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.48 2007/05/31 23:04:09 thib Exp $	*/
d2073 1
a2073 2
	MALLOC(nd, struct nfsrv_descript *, sizeof (struct nfsrv_descript),
		M_NFSRVDESC, M_WAITOK);
d2081 1
a2081 1
		free((caddr_t)nd, M_NFSRVDESC);
@


1.48
log
@when getting ESTALE from the server, allow the client to retry in the
nfsv2 client case, this matches v3 behaviour to that extent.
This is to work around the fact that when the namecache is large, we
dont purge vnodes correctly out of it.

ok beck@@,pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.47 2007/04/24 18:15:04 thib Exp $	*/
d349 1
a349 1
		soshutdown(so, 2);
@


1.47
log
@Dont log() send failures in nfs_send(), they arent helpful since we retry
and recover for the client case (or terminate with EINTR if to many retries),
and in the server case, if we cant send due to f.x network troubles its up to
the client to retry not the server.
(server not responding messages are logged in another place though).

discussed with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.46 2006/10/28 20:56:46 thib Exp $	*/
d1058 2
a1059 1
			if (nmp->nm_flag & NFSMNT_NFSV3) {
@


1.46
log
@Dont initialize the nm_srtt and nm_sdrtt arrays
out of bounds.

ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.45 2006/09/20 21:56:21 thib Exp $	*/
a403 2
			log(LOG_INFO, "nfs send error %d for server %s\n",error,
			    rep->r_nmp->nm_mountp->mnt_stat.f_mntfromname);
d411 1
a411 2
		} else
			log(LOG_INFO, "nfsd send error %d\n", error);
@


1.45
log
@Fix the way delays between request retransmissions are calculated
in the case where NFSERR_TRYLATER is received from the server.

Adapted from NetBSD.
ok pedro@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.44 2006/08/04 12:35:57 pedro Exp $	*/
d286 2
a287 2
	nmp->nm_srtt[0] = nmp->nm_srtt[1] = nmp->nm_srtt[2] = nmp->nm_srtt[3] =
		nmp->nm_srtt[4] = (NFS_TIMEO << 3);
d289 1
a289 1
		nmp->nm_sdrtt[3] = nmp->nm_sdrtt[4] = 0;
@


1.44
log
@Fix up mbuf length and do 64-bit alignment where needed, joint work
with Nicholas Marriott <nicm__@@ntlworld.com>, closes PR 5036
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.43 2006/01/24 15:06:41 aaron Exp $	*/
d846 1
a846 1
	int trylater_delay = 15, trylater_cnt = 0, failed_auth = 0;
d852 2
d1048 4
a1051 3
				trylater_delay *= nfs_backoff[trylater_cnt];
				if (trylater_cnt < 7)
					trylater_cnt++;
@


1.43
log
@Fix NULL dereference on error condition in nfs_reply().  nmp->nm_so can
become NULL if the nfs_reply() -> nfs_receive() -> nfs_reconnect() datapath
fails.  pedro@@ ok "I think this is a good fix"
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.42 2005/04/02 01:00:38 mickey Exp $	*/
d136 1
d1458 40
a1497 1
 *  NFS parsing code requires 32-bit alignment
d1504 1
a1504 1
	int off = 0;
d1508 2
a1509 1
		if ((m->m_len & 0x3) || (mtod(m, long) & 0x3)) {
d1511 1
a1511 1
			if (m->m_len >= MINCLSIZE) {
d1527 8
@


1.42
log
@use pool for struct nfsreq; tedu@@ pedro@@ ok and testing by mark patruck <mark@@2ls4agd.net> on several archs
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.41 2004/12/26 21:22:13 miod Exp $	*/
d702 2
a703 1
				nmp->nm_so->so_error = 0;
@


1.41
log
@Use list and queue macros where applicable to make the code easier to read;
no change in compiler assembly output.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.40 2004/12/10 19:55:21 millert Exp $	*/
d851 1
a851 1
	MALLOC(rep, struct nfsreq *, sizeof(struct nfsreq), M_NFSREQ, M_WAITOK);
d879 1
a879 1
				free((caddr_t)rep, M_NFSREQ);
d991 1
a991 1
		free((caddr_t)rep, M_NFSREQ);
d1015 1
a1015 1
		free((caddr_t)rep, M_NFSREQ);
d1064 1
a1064 1
			free((caddr_t)rep, M_NFSREQ);
d1072 1
a1072 1
		FREE((caddr_t)rep, M_NFSREQ);
d1079 1
a1079 1
	free((caddr_t)rep, M_NFSREQ);
@


1.40
log
@In nfs_connect() move the setting of so->so_rcv.sb_timeo out of the
if () else since it is common to both cases and makes the code
clearer.  OK pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.39 2004/07/14 18:32:34 pedro Exp $	*/
d1143 2
a1144 2
		    for (nuidp = NUIDHASH(slp, nd->nd_cr.cr_uid)->lh_first;
		 	nuidp != NULL; nuidp = LIST_NEXT(nuidp, nu_hash)) {
d1667 2
a1668 2
			for (nuidp = NUIDHASH(nfsd->nfsd_slp,nickuid)->lh_first;
			    nuidp != NULL; nuidp = LIST_NEXT(nuidp, nu_hash)) {
@


1.39
log
@on nfs_reconnect(), don't reset the rexmit of all nfs reqs, but only
of those belonging to the given nfs mount. ok marius@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.38 2004/07/10 20:39:15 marius Exp $	*/
d241 6
a246 2
	if (nmp->nm_flag & (NFSMNT_SOFT | NFSMNT_INT)) {
		so->so_rcv.sb_timeo = (5 * hz);
d248 1
a248 7
	} else {
		/*
		 * enable receive timeout to detect server crash and
		 * reconnect.  otherwise, we can be stuck in soreceive
		 * forever.
		 */
		so->so_rcv.sb_timeo = (5 * hz);
a249 1
	}
@


1.38
log
@fix for where a TCP NFS connection could sleep in soreceive() forever,
this fixes some problems people have experienced with NFS mounts freezing
on NFS server reboot/crash.

ok deraadt@@ pedro@@ tholo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.37 2004/06/24 19:35:26 tholo Exp $	*/
d331 1
a331 1
		if (rp->r_nmp == nmp)
d333 2
a334 2

		rp->r_rexmit = 0;
@


1.37
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.36 2004/06/21 23:50:38 tholo Exp $	*/
d245 6
a250 1
		so->so_rcv.sb_timeo = 0;
d330 1
a330 2
	for (rp = TAILQ_FIRST(&nfs_reqq); rp != NULL;
	    rp = TAILQ_NEXT(rp, r_chain)) {
d333 2
d499 2
d529 10
@


1.36
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.35 2003/12/08 09:33:36 mickey Exp $	*/
d735 1
a735 1
					rt->tstamp = time;
d1212 1
d1310 2
a1311 1
	cur_usec = (u_quad_t)time.tv_sec * 1000000 + (u_quad_t)time.tv_usec;
@


1.35
log
@nfs_reqq is operated at softnet other places and thus softclock is not high enough; tedu@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.34 2003/07/10 22:53:19 tedu Exp $	*/
d914 1
a914 1
	reqtime = time.tv_sec;
d1025 2
a1026 2
				waituntil = time.tv_sec + trylater_delay;
				while (time.tv_sec < waituntil)
d1667 1
a1667 1
			if (nuidp->nu_expire < time.tv_sec ||
@


1.34
log
@unlock on error condition.  from Tim Wiess.  ok csapuntz@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.33 2003/06/02 23:28:19 millert Exp $	*/
d910 1
a910 1
	s = splsoftclock();
d952 1
a952 1
	s = splsoftclock();
@


1.33
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.32 2002/10/29 12:47:06 art Exp $	*/
d600 1
a600 1
			if (!error)
d602 4
a605 2
			if (!error)
				goto tryagain;
@


1.32
log
@Get rid of some commons.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.31 2002/08/01 22:38:44 csapuntz Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.31
log
@Fix handling of 0-length RPC fragments
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.30 2002/07/30 19:00:43 csapuntz Exp $	*/
d142 2
@


1.30
log
@Bug/type found by tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.29 2002/07/03 20:57:00 nate Exp $	*/
d1867 1
a1867 1
	struct mbuf *om, *m2, *recm = NULL;
d1913 1
@


1.29
log
@Remove unused function parameter 'cache' from nfs_rephead
ok costa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.28 2002/06/11 15:45:44 hin Exp $	*/
d1185 1
a1185 1
	if (mrq != NULL)
@


1.28
log
@Remove some unused code for dealing with nfs over kerberos. No actual change,
just some #ifdef'ed out code removed.

ok deraadt@@, art@@ and csapuntz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.27 2002/05/17 18:41:01 csapuntz Exp $	*/
d1074 1
a1074 1
nfs_rephead(siz, nd, slp, err, cache, frev, mrq, mbp, bposp)
a1078 1
	int cache;
@


1.27
log
@Fix nfs_realign to allocate new mbufs. Taken from freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.26 2002/04/11 18:44:24 millert Exp $	*/
a1141 8
			/*
			 * Encrypt the timestamp in ecb mode using the
			 * session key.
			 */
#ifdef NFSKERB
			XXX
#endif

a1664 8

			/*
			 * Now, decrypt the timestamp using the session key
			 * and validate it.
			 */
#ifdef NFSKERB
			XXX
#endif
@


1.26
log
@Back out nfs_realign() change, it causes "pool_get: must have NOWAIT" panics.
deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.25 2002/04/10 18:16:46 csapuntz Exp $	*/
d139 3
a141 1
void nfs_realign(struct mbuf *, int);
d535 1
d636 1
a636 1
	nfs_realign(*mp, 5 * NFSX_UNSIGNED);
d1448 1
a1448 2
 * Check for badly aligned mbuf data areas and
 * realign data in an mbuf list by copying the data areas up, as required.
d1451 2
a1452 1
nfs_realign(m, hsiz)
d1454 2
a1455 6
	int hsiz;
{
	struct mbuf *m2;
	int siz, mlen, olen;
	caddr_t tcp, fcp;
	struct mbuf *mnew;
d1457 9
a1465 17
	while (m) {
	    /*
	     * This never happens for UDP, rarely happens for TCP
	     * but frequently happens for iso transport.
	     */
	    if ((m->m_len & 0x3) || (mtod(m, long) & 0x3)) {
		olen = m->m_len;
		fcp = mtod(m, caddr_t);
		if ((long)fcp & 0x3) {
		        if (m->m_flags & M_PKTHDR)
				m_tag_delete_chain(m, NULL);
			m->m_flags &= ~M_PKTHDR;
			if (m->m_flags & M_EXT)
				m->m_data = m->m_ext.ext_buf +
					((m->m_ext.ext_size - olen) & ~0x3);
			else
				m->m_data = m->m_dat;
d1467 8
a1474 14
		m->m_len = 0;
		tcp = mtod(m, caddr_t);
		mnew = m;
		m2 = m->m_next;
	
		/*
		 * If possible, only put the first invariant part
		 * of the RPC header in the first mbuf.
		 */
		mlen = M_TRAILINGSPACE(m);
		if (olen <= hsiz && mlen > hsiz)
			mlen = hsiz;
	
		/* Loop through the mbuf list consolidating data. */
d1476 2
a1477 24
			while (olen > 0) {
				if (mlen == 0) {
				        if (m2->m_flags & M_PKTHDR)
						m_tag_delete_chain(m2, NULL);
					m2->m_flags &= ~M_PKTHDR;
					if (m2->m_flags & M_EXT)
						m2->m_data = m2->m_ext.ext_buf;
					else
						m2->m_data = m2->m_dat;
					m2->m_len = 0;
					mlen = M_TRAILINGSPACE(m2);
					tcp = mtod(m2, caddr_t);
					mnew = m2;
					m2 = m2->m_next;
				}
				siz = min(mlen, olen);
				if (tcp != fcp)
					bcopy(fcp, tcp, siz);
				mnew->m_len += siz;
				mlen -= siz;
				olen -= siz;
				tcp += siz;
				fcp += siz;
			}
a1478 4
			if (m) {
				olen = m->m_len;
				fcp = mtod(m, caddr_t);
			}
d1480 2
a1481 12
	
		/*
		 * Finally, set m_len == 0 for any trailing mbufs that have
		 * been copied out of.
		 */
		while (m2) {
			m2->m_len = 0;
			m2 = m2->m_next;
		}
		return;
	    }
	    m = m->m_next;
d1485 1
a1839 1
				nfs_realign(mp, 10 * NFSX_UNSIGNED);
a1982 1
		nfs_realign(slp->ns_frag, 10 * NFSX_UNSIGNED);
d2023 1
@


1.25
log
@nfs_realign from FreeBSD. The old code was over-optimized, occasionally overwriting
other parts of a TCP stream, occasionally dereferencing NULL pointers
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.24 2002/03/14 01:27:13 millert Exp $	*/
d139 1
a139 3
void nfs_realign(struct mbuf **, int);
unsigned int nfs_realign_test = 0;
unsigned int nfs_realign_count = 0;
a532 1

d633 1
a633 1
	nfs_realign(mp, 5 * NFSX_UNSIGNED);
d1445 2
a1446 1
 *  NFS parsing code requires 32-bit alignment
d1449 3
a1451 1
nfs_realign(struct mbuf **pm, int hsiz)
d1453 4
a1456 3
	struct mbuf *m;
	struct mbuf *n = NULL;
	int off = 0;
d1458 17
a1474 9
	++nfs_realign_test;
	while ((m = *pm) != NULL) {
		if ((m->m_len & 0x3) || (mtod(m, long) & 0x3)) {
			MGET(n, M_WAIT, MT_DATA);
			if (m->m_len >= MINCLSIZE) {
				MCLGET(n, M_WAIT);
			}
			n->m_len = 0;
			break;
d1476 14
a1489 8
		pm = &m->m_next;
	}
	/*
	 * If n is non-NULL, loop on m copying data, then replace the
	 * portion of the chain that had to be realigned.
	 */
	if (n != NULL) {
		++nfs_realign_count;
d1491 24
a1514 2
			m_copyback(n, off, m->m_len, mtod(m, caddr_t));
			off += m->m_len;
d1516 4
d1521 12
a1532 2
		m_freem(*pm);
		*pm = n;
a1535 1

d1890 1
a1890 1
				nfs_realign(&mp, 10 * NFSX_UNSIGNED);
d2034 1
a2034 1
		nfs_realign(&slp->ns_frag, 10 * NFSX_UNSIGNED);
@


1.24
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.23 2002/01/16 21:51:16 ericj Exp $	*/
d139 4
d535 1
d636 1
a636 1
	nfs_realign(*mp, 5 * NFSX_UNSIGNED);
d1448 1
a1448 2
 * Check for badly aligned mbuf data areas and
 * realign data in an mbuf list by copying the data areas up, as required.
d1451 2
a1452 1
nfs_realign(m, hsiz)
d1454 2
a1455 6
	int hsiz;
{
	struct mbuf *m2;
	int siz, mlen, olen;
	caddr_t tcp, fcp;
	struct mbuf *mnew;
d1457 9
a1465 17
	while (m) {
	    /*
	     * This never happens for UDP, rarely happens for TCP
	     * but frequently happens for iso transport.
	     */
	    if ((m->m_len & 0x3) || (mtod(m, long) & 0x3)) {
		olen = m->m_len;
		fcp = mtod(m, caddr_t);
		if ((long)fcp & 0x3) {
		        if (m->m_flags & M_PKTHDR)
				m_tag_delete_chain(m, NULL);
			m->m_flags &= ~M_PKTHDR;
			if (m->m_flags & M_EXT)
				m->m_data = m->m_ext.ext_buf +
					((m->m_ext.ext_size - olen) & ~0x3);
			else
				m->m_data = m->m_dat;
d1467 8
a1474 14
		m->m_len = 0;
		tcp = mtod(m, caddr_t);
		mnew = m;
		m2 = m->m_next;
	
		/*
		 * If possible, only put the first invariant part
		 * of the RPC header in the first mbuf.
		 */
		mlen = M_TRAILINGSPACE(m);
		if (olen <= hsiz && mlen > hsiz)
			mlen = hsiz;
	
		/* Loop through the mbuf list consolidating data. */
d1476 2
a1477 24
			while (olen > 0) {
				if (mlen == 0) {
				        if (m2->m_flags & M_PKTHDR)
						m_tag_delete_chain(m2, NULL);
					m2->m_flags &= ~M_PKTHDR;
					if (m2->m_flags & M_EXT)
						m2->m_data = m2->m_ext.ext_buf;
					else
						m2->m_data = m2->m_dat;
					m2->m_len = 0;
					mlen = M_TRAILINGSPACE(m2);
					tcp = mtod(m2, caddr_t);
					mnew = m2;
					m2 = m2->m_next;
				}
				siz = min(mlen, olen);
				if (tcp != fcp)
					bcopy(fcp, tcp, siz);
				mnew->m_len += siz;
				mlen -= siz;
				olen -= siz;
				tcp += siz;
				fcp += siz;
			}
a1478 4
			if (m) {
				olen = m->m_len;
				fcp = mtod(m, caddr_t);
			}
d1480 2
a1481 12
	
		/*
		 * Finally, set m_len == 0 for any trailing mbufs that have
		 * been copied out of.
		 */
		while (m2) {
			m2->m_len = 0;
			m2 = m2->m_next;
		}
		return;
	    }
	    m = m->m_next;
d1485 1
d1840 1
a1840 1
				nfs_realign(mp, 10 * NFSX_UNSIGNED);
d1984 1
a1984 1
		nfs_realign(slp->ns_frag, 10 * NFSX_UNSIGNED);
@


1.23
log
@
use queue.h macro's
remove register
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.22 2001/06/25 03:28:09 csapuntz Exp $	*/
d1775 1
a1775 1
int (*nfsrv3_procs[NFS_NPROCS]) __P((struct nfsrv_descript *,
d1777 1
a1777 1
				    struct mbuf **)) = {
@


1.22
log
@Remove NQNFS
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.21 2001/05/20 08:32:35 angelos Exp $	*/
d145 1
a145 1
	register struct nfsmount *nmp;
d148 1
a148 1
	register struct socket *so;
d306 1
a306 1
	register struct nfsreq *rep;
d308 2
a309 2
	register struct nfsreq *rp;
	register struct nfsmount *nmp = rep->r_nmp;
d323 2
a324 1
	for (rp = nfs_reqq.tqh_first; rp != 0; rp = rp->r_chain.tqe_next) {
d336 1
a336 1
	register struct nfsmount *nmp;
d338 1
a338 1
	register struct socket *so;
d363 1
a363 1
	register struct socket *so;
d365 1
a365 1
	register struct mbuf *top;
d432 1
a432 1
	register struct nfsreq *rep;
d436 1
a436 1
	register struct socket *so;
d439 1
a439 1
	register struct mbuf *m;
d645 3
a647 3
	register struct nfsreq *rep;
	register struct nfsmount *nmp = myrep->r_nmp;
	register int32_t t1;
d712 2
a713 2
		for (rep = nfs_reqq.tqh_first; rep != 0;
		    rep = rep->r_chain.tqe_next) {
d814 4
a817 4
	register struct mbuf *m, *mrep;
	register struct nfsreq *rep;
	register u_int32_t *tl;
	register int i;
d1080 2
a1081 2
	register u_int32_t *tl;
	register struct mbuf *mreq;
d1121 1
a1121 1
		    register struct nfsuid *nuidp;
d1125 1
a1125 1
			nuidp != 0; nuidp = nuidp->nu_hash.le_next) {
d1220 2
a1221 1
	for (rep = nfs_reqq.tqh_first; rep != 0; rep = rep->r_chain.tqe_next) {
d1314 4
a1317 3
	for (slp = nfssvc_sockhead.tqh_first; slp != 0;
	    slp = slp->ns_chain.tqe_next) {
	    if (slp->ns_tq.lh_first && slp->ns_tq.lh_first->nd_time<=cur_usec)
d1333 1
a1333 1
	register struct proc *p;
d1355 1
a1355 1
	register int *flagp;
d1387 1
a1387 1
	register int *flagp;
d1401 1
a1401 1
	register struct nfsreq *rep;
d1403 1
a1403 1
	register int *flagp = &rep->r_nmp->nm_flag;
d1430 1
a1430 1
	register int *flagp;
d1448 1
a1448 1
	register struct mbuf *m;
d1451 3
a1453 3
	register struct mbuf *m2;
	register int siz, mlen, olen;
	register caddr_t tcp, fcp;
d1541 1
a1541 1
	register struct nfsrv_descript *nd;
d1545 3
a1547 3
	register int len, i;
	register u_int32_t *tl;
	register int32_t t1;
d1555 1
a1555 1
	register struct nfsuid *nuidp;
d1708 1
a1708 1
			    nuidp != 0; nuidp = nuidp->nu_hash.le_next) {
d1818 2
a1819 2
	register struct nfssvc_sock *slp = (struct nfssvc_sock *)arg;
	register struct mbuf *m;
d1927 1
a1927 1
	register struct nfssvc_sock *slp;
d1930 3
a1932 3
	register struct mbuf *m, **mpp;
	register char *cp1, *cp2;
	register int len;
d2048 1
a2048 1
	register struct nfssvc_sock *slp;
d2052 2
a2053 2
	register struct mbuf *m, *nam;
	register struct nfsrv_descript *nd;
d2097 1
a2097 1
	register struct nfsd *nd;
d2101 2
a2102 1
	for (nd = nfsd_head.tqh_first; nd != 0; nd = nd->nfsd_chain.tqe_next) {
@


1.22.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.23 2002/01/16 21:51:16 ericj Exp $	*/
d145 1
a145 1
	struct nfsmount *nmp;
d148 1
a148 1
	struct socket *so;
d306 1
a306 1
	struct nfsreq *rep;
d308 2
a309 2
	struct nfsreq *rp;
	struct nfsmount *nmp = rep->r_nmp;
d323 1
a323 2
	for (rp = TAILQ_FIRST(&nfs_reqq); rp != NULL;
	    rp = TAILQ_NEXT(rp, r_chain)) {
d335 1
a335 1
	struct nfsmount *nmp;
d337 1
a337 1
	struct socket *so;
d362 1
a362 1
	struct socket *so;
d364 1
a364 1
	struct mbuf *top;
d431 1
a431 1
	struct nfsreq *rep;
d435 1
a435 1
	struct socket *so;
d438 1
a438 1
	struct mbuf *m;
d644 3
a646 3
	struct nfsreq *rep;
	struct nfsmount *nmp = myrep->r_nmp;
	int32_t t1;
d711 2
a712 2
		for (rep = TAILQ_FIRST(&nfs_reqq); rep != NULL;
		    rep = TAILQ_NEXT(rep, r_chain)) {
d813 4
a816 4
	struct mbuf *m, *mrep;
	struct nfsreq *rep;
	u_int32_t *tl;
	int i;
d1079 2
a1080 2
	u_int32_t *tl;
	struct mbuf *mreq;
d1120 1
a1120 1
		    struct nfsuid *nuidp;
d1124 1
a1124 1
		 	nuidp != NULL; nuidp = LIST_NEXT(nuidp, nu_hash)) {
d1219 1
a1219 2
	for (rep = TAILQ_FIRST(&nfs_reqq); rep != NULL;
	    rep = TAILQ_NEXT(rep, r_chain)) {
d1312 3
a1314 4
	for (slp = TAILQ_FIRST(&nfssvc_sockhead); slp != NULL;
	    slp = TAILQ_NEXT(slp, ns_chain)) {
	    if (LIST_FIRST(&slp->ns_tq) &&
	        LIST_FIRST(&slp->ns_tq)->nd_time <= cur_usec)
d1330 1
a1330 1
	struct proc *p;
d1352 1
a1352 1
	int *flagp;
d1384 1
a1384 1
	int *flagp;
d1398 1
a1398 1
	struct nfsreq *rep;
d1400 1
a1400 1
	int *flagp = &rep->r_nmp->nm_flag;
d1427 1
a1427 1
	int *flagp;
d1445 1
a1445 1
	struct mbuf *m;
d1448 3
a1450 3
	struct mbuf *m2;
	int siz, mlen, olen;
	caddr_t tcp, fcp;
d1538 1
a1538 1
	struct nfsrv_descript *nd;
d1542 3
a1544 3
	int len, i;
	u_int32_t *tl;
	int32_t t1;
d1552 1
a1552 1
	struct nfsuid *nuidp;
d1705 1
a1705 1
			    nuidp != NULL; nuidp = LIST_NEXT(nuidp, nu_hash)) {
d1815 2
a1816 2
	struct nfssvc_sock *slp = (struct nfssvc_sock *)arg;
	struct mbuf *m;
d1924 1
a1924 1
	struct nfssvc_sock *slp;
d1927 3
a1929 3
	struct mbuf *m, **mpp;
	char *cp1, *cp2;
	int len;
d2045 1
a2045 1
	struct nfssvc_sock *slp;
d2049 2
a2050 2
	struct mbuf *m, *nam;
	struct nfsrv_descript *nd;
d2094 1
a2094 1
	struct nfsd *nd;
d2098 1
a2098 2
	for (nd = TAILQ_FIRST(&nfsd_head); nd != NULL;
	    nd = TAILQ_NEXT(nd, nfsd_chain)) {
@


1.22.4.2
log
@Merge in UBC performance changes from NetBSD.
Fix a bunch of merge errors from yesterday.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.22.4.1 2002/01/31 22:55:47 niklas Exp $	*/
d905 1
a905 1
	s = splsoftnet();
d947 1
a947 1
	s = splsoftnet();
@


1.22.4.3
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.22.4.2 2002/02/02 03:28:26 art Exp $	*/
a138 4
void nfs_realign(struct mbuf **, int);
unsigned int nfs_realign_test = 0;
unsigned int nfs_realign_count = 0;

a530 1

d631 1
a631 1
	nfs_realign(mp, 5 * NFSX_UNSIGNED);
d1443 2
a1444 1
 *  NFS parsing code requires 32-bit alignment
d1447 3
a1449 1
nfs_realign(struct mbuf **pm, int hsiz)
d1451 4
a1454 3
	struct mbuf *m;
	struct mbuf *n = NULL;
	int off = 0;
d1456 17
a1472 9
	++nfs_realign_test;
	while ((m = *pm) != NULL) {
		if ((m->m_len & 0x3) || (mtod(m, long) & 0x3)) {
			MGET(n, M_WAIT, MT_DATA);
			if (m->m_len >= MINCLSIZE) {
				MCLGET(n, M_WAIT);
			}
			n->m_len = 0;
			break;
d1474 14
a1487 8
		pm = &m->m_next;
	}
	/*
	 * If n is non-NULL, loop on m copying data, then replace the
	 * portion of the chain that had to be realigned.
	 */
	if (n != NULL) {
		++nfs_realign_count;
d1489 24
a1512 2
			m_copyback(n, off, m->m_len, mtod(m, caddr_t));
			off += m->m_len;
d1514 4
d1519 12
a1530 2
		m_freem(*pm);
		*pm = n;
a1533 1

d1775 1
a1775 1
int (*nfsrv3_procs[NFS_NPROCS])(struct nfsrv_descript *,
d1777 1
a1777 1
				    struct mbuf **) = {
d1888 1
d2032 1
a2072 1
	nfs_realign(&m, 10 * NFSX_UNSIGNED);
@


1.22.4.4
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.22.4.3 2002/06/11 03:32:04 art Exp $	*/
d1074 1
a1074 1
nfs_rephead(siz, nd, slp, err, frev, mrq, mbp, bposp)
d1079 1
d1142 8
d1194 1
a1194 1
	if (mbp != NULL)
d1674 8
d1884 1
a1884 1
	struct mbuf *om, *m2, *recm;
a1929 1
	    recm = NULL;
@


1.22.4.5
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a141 2

struct nfsreqhead nfs_reqq;
@


1.21
log
@tdbi->tags cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.20 2001/03/28 20:03:08 angelos Exp $	*/
a71 1
#include <nfs/nqnfs.h>
d102 1
a102 2
extern u_int32_t nfs_prog, nqnfs_prog;
extern time_t nqnfsstarttime;
d699 2
a700 7
			if (nmp->nm_flag & NFSMNT_NQNFS) {
				if (nqnfs_callback(nmp, mrep, md, dpos))
					nfsstats.rpcinvalid++;
			} else {
				nfsstats.rpcinvalid++;
				m_freem(mrep);
			}
a818 1
	struct nfsnode *np;
d822 2
a823 2
	int t1, nqlflag, cachable, s, error = 0, mrest_len, auth_len, auth_type;
	int trylater_delay = NQ_TRYLATERDEL, trylater_cnt = 0, failed_auth = 0;
a825 1
	u_quad_t frev;
a1046 18
		/*
		 * For nqnfs, get any lease in reply
		 */
		if (nmp->nm_flag & NFSMNT_NQNFS) {
			nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);
			if (*tl) {
				np = VTONFS(vp);
				nqlflag = fxdr_unsigned(int, *tl);
				nfsm_dissect(tl, u_int32_t *, 4*NFSX_UNSIGNED);
				cachable = fxdr_unsigned(int, *tl++);
				reqtime += fxdr_unsigned(int, *tl++);
				if (reqtime > time.tv_sec) {
				    frev = fxdr_hyper(tl);
				    nqnfs_clientlease(nmp, np, nqlflag,
					cachable, reqtime, frev);
				}
			}
		}
d1165 2
a1166 7
			if (nd->nd_flag & ND_NQNFS) {
				*tl++ = txdr_unsigned(3);
				*tl = txdr_unsigned(3);
			} else {
				*tl++ = txdr_unsigned(2);
				*tl = txdr_unsigned(3);
			}
a1186 15
	/*
	 * For nqnfs, piggyback lease as requested.
	 */
	if ((nd->nd_flag & ND_NQNFS) && err == 0) {
		if (nd->nd_flag & ND_LEASE) {
			nfsm_build(tl, u_int32_t *, 5 * NFSX_UNSIGNED);
			*tl++ = txdr_unsigned(nd->nd_flag & ND_LEASE);
			*tl++ = txdr_unsigned(cache);
			*tl++ = txdr_unsigned(nd->nd_duration);
			txdr_hyper(*frev, tl);
		} else {
			nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED);
			*tl = 0;
		}
	}
a1214 1
	static long lasttime = 0;
a1307 8
	 * Call the nqnfs server timer once a second to handle leases.
	 */
	if (lasttime != time.tv_sec) {
		lasttime = time.tv_sec;
		nqnfs_serverd();
	}

	/*
d1550 1
a1550 1
	int error = 0, nqnfs = 0, ticklen;
d1575 3
a1577 7
		if (*tl == nqnfs_prog)
			nqnfs++;
		else {
			nd->nd_repstat = EPROGUNAVAIL;
			nd->nd_procnum = NFSPROC_NOOP;
			return (0);
		}
d1581 1
a1581 2
	if (((nfsvers < NFS_VER2 || nfsvers > NFS_VER3) && !nqnfs) ||
		(nfsvers != NQNFS_VER3 && nqnfs)) {
d1586 1
a1586 3
	if (nqnfs)
		nd->nd_flag = (ND_NFSV3 | ND_NQNFS);
	else if (nfsvers == NFS_VER3)
d1592 1
a1592 1
		(!nqnfs && nd->nd_procnum >= NQNFSPROC_GETLEASE) ||
a1747 13
	/*
	 * For nqnfs, get piggybacked lease request.
	 */
	if (nqnfs && nd->nd_procnum != NQNFSPROC_EVICTED) {
		nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);
		nd->nd_flag |= fxdr_unsigned(int, *tl);
		if (nd->nd_flag & ND_LEASE) {
			nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);
			nd->nd_duration = fxdr_unsigned(u_int32_t, *tl);
		} else
			nd->nd_duration = NQ_MINLEASE;
	} else
		nd->nd_duration = NQ_MINLEASE;
d1797 2
a1798 2
	nqnfsrv_getlease,
	nqnfsrv_vacated,
@


1.20
log
@Allow tdbi's to appear in mbufs throughout the stack; this allows
security properties of the packets to be pushed up to the application
(not done yet). Eventually, this will be turned into a packet
attributes framework.

Make sure tdbi's are free'd/cleared properly whenever drivers (or NFS)
does weird things with mbufs.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.19 2000/08/10 16:28:42 deraadt Exp $	*/
d1518 2
a1519 5
		        if (m->m_flags & M_PKTHDR) {
			        if (m->m_pkthdr.tdbi) /* XXX */
				        free(m->m_pkthdr.tdbi, M_TEMP);
				m->m_pkthdr.tdbi = NULL;
			}
d1540 1
a1540 3
		/*
		 * Loop through the mbuf list consolidating data.
		 */
d1544 2
a1545 7
				        if (m2->m_flags & M_PKTHDR) {
					        /* XXX */
					        if (m2->m_pkthdr.tdbi)
						        free(m2->m_pkthdr.tdbi,
							     M_TEMP);
						m2->m_pkthdr.tdbi = NULL;
					}
@


1.19
log
@unfortunately, i must undo this patch, since it causes client hangs on sparc machines, and only on them. until more is known, out this comes
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.17 2000/06/26 22:48:14 art Exp $	*/
d1518 5
d1549 7
@


1.18
log
@fix obvious error, spotted by ericj
@
text
@d1234 1
d1236 1
a1236 2
		*mrq = mreq;
	*mbp = mb;
@


1.17
log
@Convert nfs_timer to new timeouts.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.16 2000/01/04 16:03:00 itojun Exp $	*/
a1233 1
	*mrq = mreq;
d1235 2
a1236 1
		*mbp = mb;
@


1.16
log
@fix mbuf out-of-bound writes on nfsv2 mounts.

netbsd sys/nfs/nfs_socket.c 1.43 -> 1.44
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.15 1999/03/02 20:59:55 millert Exp $	*/
d1251 1
a1251 1
	void *arg;	/* never used */
d1253 6
a1258 5
	register struct nfsreq *rep;
	register struct mbuf *m;
	register struct socket *so;
	register struct nfsmount *nmp;
	register int timeo;
d1261 1
a1261 1
	register struct nfssvc_sock *slp;
d1375 1
a1375 1
	timeout(nfs_timer, (void *)0, nfs_ticks);
@


1.16.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.20 2001/03/28 20:03:08 angelos Exp $	*/
d1251 1
a1251 1
	void *arg;
d1253 5
a1257 6
	struct timeout *to = (struct timeout *)arg;
	struct nfsreq *rep;
	struct mbuf *m;
	struct socket *so;
	struct nfsmount *nmp;
	int timeo;
d1260 1
a1260 1
	struct nfssvc_sock *slp;
d1374 1
a1374 1
	timeout_add(to, nfs_ticks);
a1516 5
		        if (m->m_flags & M_PKTHDR) {
			        if (m->m_pkthdr.tdbi) /* XXX */
				        free(m->m_pkthdr.tdbi, M_TEMP);
				m->m_pkthdr.tdbi = NULL;
			}
a1542 7
				        if (m2->m_flags & M_PKTHDR) {
					        /* XXX */
					        if (m2->m_pkthdr.tdbi)
						        free(m2->m_pkthdr.tdbi,
							     M_TEMP);
						m2->m_pkthdr.tdbi = NULL;
					}
@


1.16.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.16.2.1 2001/05/14 22:44:57 niklas Exp $	*/
d72 1
d103 2
a104 1
extern u_int32_t nfs_prog;
d701 7
a707 2
			nfsstats.rpcinvalid++;
			m_freem(mrep);
d826 1
d830 2
a831 2
	int t1, s, error = 0, mrest_len, auth_len, auth_type;
	int trylater_delay = 15, trylater_cnt = 0, failed_auth = 0;
d834 1
d1056 18
d1192 7
a1198 2
			*tl++ = txdr_unsigned(2);
			*tl = txdr_unsigned(3);
d1219 15
d1262 1
d1356 8
d1518 5
a1522 2
		        if (m->m_flags & M_PKTHDR)
				m_tag_delete_chain(m, NULL);
d1543 3
a1545 1
		/* Loop through the mbuf list consolidating data. */
d1549 7
a1555 2
				        if (m2->m_flags & M_PKTHDR)
						m_tag_delete_chain(m2, NULL);
d1616 1
a1616 1
	int error = 0, ticklen;
d1641 7
a1647 3
		nd->nd_repstat = EPROGUNAVAIL;
		nd->nd_procnum = NFSPROC_NOOP;
		return (0);
d1651 2
a1652 1
	if (nfsvers != NFS_VER2 && nfsvers != NFS_VER3) {
d1657 3
a1659 1
	if (nfsvers == NFS_VER3)
d1665 1
a1665 1
		(nd->nd_procnum > NFSPROC_COMMIT) ||
d1821 13
d1883 2
a1884 2
	nfsrv_noop,
	nfsrv_noop,
@


1.16.2.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d145 1
a145 1
	struct nfsmount *nmp;
d148 1
a148 1
	struct socket *so;
d306 1
a306 1
	struct nfsreq *rep;
d308 2
a309 2
	struct nfsreq *rp;
	struct nfsmount *nmp = rep->r_nmp;
d323 1
a323 2
	for (rp = TAILQ_FIRST(&nfs_reqq); rp != NULL;
	    rp = TAILQ_NEXT(rp, r_chain)) {
d335 1
a335 1
	struct nfsmount *nmp;
d337 1
a337 1
	struct socket *so;
d362 1
a362 1
	struct socket *so;
d364 1
a364 1
	struct mbuf *top;
d431 1
a431 1
	struct nfsreq *rep;
d435 1
a435 1
	struct socket *so;
d438 1
a438 1
	struct mbuf *m;
d644 3
a646 3
	struct nfsreq *rep;
	struct nfsmount *nmp = myrep->r_nmp;
	int32_t t1;
d711 2
a712 2
		for (rep = TAILQ_FIRST(&nfs_reqq); rep != NULL;
		    rep = TAILQ_NEXT(rep, r_chain)) {
d813 4
a816 4
	struct mbuf *m, *mrep;
	struct nfsreq *rep;
	u_int32_t *tl;
	int i;
d1079 2
a1080 2
	u_int32_t *tl;
	struct mbuf *mreq;
d1120 1
a1120 1
		    struct nfsuid *nuidp;
d1124 1
a1124 1
		 	nuidp != NULL; nuidp = LIST_NEXT(nuidp, nu_hash)) {
d1219 1
a1219 2
	for (rep = TAILQ_FIRST(&nfs_reqq); rep != NULL;
	    rep = TAILQ_NEXT(rep, r_chain)) {
d1312 3
a1314 4
	for (slp = TAILQ_FIRST(&nfssvc_sockhead); slp != NULL;
	    slp = TAILQ_NEXT(slp, ns_chain)) {
	    if (LIST_FIRST(&slp->ns_tq) &&
	        LIST_FIRST(&slp->ns_tq)->nd_time <= cur_usec)
d1330 1
a1330 1
	struct proc *p;
d1352 1
a1352 1
	int *flagp;
d1384 1
a1384 1
	int *flagp;
d1398 1
a1398 1
	struct nfsreq *rep;
d1400 1
a1400 1
	int *flagp = &rep->r_nmp->nm_flag;
d1427 1
a1427 1
	int *flagp;
d1445 1
a1445 1
	struct mbuf *m;
d1448 3
a1450 3
	struct mbuf *m2;
	int siz, mlen, olen;
	caddr_t tcp, fcp;
d1538 1
a1538 1
	struct nfsrv_descript *nd;
d1542 3
a1544 3
	int len, i;
	u_int32_t *tl;
	int32_t t1;
d1552 1
a1552 1
	struct nfsuid *nuidp;
d1705 1
a1705 1
			    nuidp != NULL; nuidp = LIST_NEXT(nuidp, nu_hash)) {
d1815 2
a1816 2
	struct nfssvc_sock *slp = (struct nfssvc_sock *)arg;
	struct mbuf *m;
d1924 1
a1924 1
	struct nfssvc_sock *slp;
d1927 3
a1929 3
	struct mbuf *m, **mpp;
	char *cp1, *cp2;
	int len;
d2045 1
a2045 1
	struct nfssvc_sock *slp;
d2049 2
a2050 2
	struct mbuf *m, *nam;
	struct nfsrv_descript *nd;
d2094 1
a2094 1
	struct nfsd *nd;
d2098 1
a2098 2
	for (nd = TAILQ_FIRST(&nfsd_head); nd != NULL;
	    nd = TAILQ_NEXT(nd, nfsd_chain)) {
@


1.16.2.4
log
@Merge in -current from roughly a week ago
@
text
@d1775 1
a1775 1
int (*nfsrv3_procs[NFS_NPROCS])(struct nfsrv_descript *,
d1777 1
a1777 1
				    struct mbuf **) = {
@


1.16.2.5
log
@Sync the SMP branch with 3.3
@
text
@a138 6
void nfs_realign(struct mbuf **, int);
unsigned int nfs_realign_test = 0;
unsigned int nfs_realign_count = 0;

struct nfsreqhead nfs_reqq;

a530 1

d631 1
a631 1
	nfs_realign(mp, 5 * NFSX_UNSIGNED);
d1069 1
a1069 1
nfs_rephead(siz, nd, slp, err, frev, mrq, mbp, bposp)
d1074 1
d1137 8
d1189 1
a1189 1
	if (mbp != NULL)
d1443 2
a1444 1
 *  NFS parsing code requires 32-bit alignment
d1447 3
a1449 1
nfs_realign(struct mbuf **pm, int hsiz)
d1451 4
a1454 3
	struct mbuf *m;
	struct mbuf *n = NULL;
	int off = 0;
d1456 17
a1472 9
	++nfs_realign_test;
	while ((m = *pm) != NULL) {
		if ((m->m_len & 0x3) || (mtod(m, long) & 0x3)) {
			MGET(n, M_WAIT, MT_DATA);
			if (m->m_len >= MINCLSIZE) {
				MCLGET(n, M_WAIT);
			}
			n->m_len = 0;
			break;
d1474 14
a1487 8
		pm = &m->m_next;
	}
	/*
	 * If n is non-NULL, loop on m copying data, then replace the
	 * portion of the chain that had to be realigned.
	 */
	if (n != NULL) {
		++nfs_realign_count;
d1489 24
a1512 2
			m_copyback(n, off, m->m_len, mtod(m, caddr_t));
			off += m->m_len;
d1514 13
d1528 3
a1530 2
		m_freem(*pm);
		*pm = n;
a1533 1

d1722 8
d1888 1
d1933 1
a1933 1
	struct mbuf *om, *m2, *recm;
a1978 1
	    recm = NULL;
d2032 1
a2072 1
	nfs_realign(&m, 10 * NFSX_UNSIGNED);
@


1.16.2.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.16.2.5 2003/03/28 00:08:46 niklas Exp $	*/
d19 5
a23 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.16.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d600 1
a600 1
			if (!error) {
d602 2
a603 4
				if (!error)
					goto tryagain;
				nfs_sndunlock(&rep->r_nmp->nm_flag);
			}
d908 1
a908 1
	s = splsoftnet();
d950 1
a950 1
	s = splsoftnet();
@


1.15
log
@When an NFS3 server replies with NFS3ERR_JUKEBOX, currently, it
panics the kernel, because the kernel tries to reuse a freed mbuf;
dm@@reeducation-labor.lcs.mit.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.14 1999/02/06 23:07:44 millert Exp $	*/
d1118 1
a1118 1
	if (siz >= MINCLSIZE) {
@


1.14
log
@Use bitwise operations to extract high and low words from the quad
in txdr_hyper.  This should be more portable than casting to an array
of ints and pulling out the two 32-bit words (this produced incorrect
results on alpha for the high word for filesystems < 4gig).  As a side
effect, txdr_hyper now takes a u_quad_t as its first arg, not u_quad_t *.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.13 1998/08/19 22:26:53 csapuntz Exp $	*/
d931 3
a933 2
			m = m_copym(m, 0, M_COPYALL, M_WAIT);
			error = nfs_send(nmp->nm_so, nmp->nm_nam, m, rep);
@


1.13
log
@

Change fxdr_hyper to return a u_quad_t. This minimizes the evil clobbering
of lvalues that ANSI abhors.

And it fixes df on NFS version 3 mounts on Sparcs.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.12 1997/07/28 19:54:17 deraadt Exp $	*/
d1227 1
a1227 1
			txdr_hyper(frev, tl);
@


1.12
log
@allocate random ports
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.10 1997/04/18 10:13:27 deraadt Exp $	*/
d1067 1
a1067 1
				    fxdr_hyper(tl, &frev);
@


1.11
log
@XXX should do reserved ports
@
text
@a154 1
	u_int16_t tport;
d171 11
d187 2
a188 6
		/* XXX should do random allocation */
		tport = IPPORT_RESERVED - 1;
		sin->sin_port = htons(tport);
		while ((error = sobind(so, m)) == EADDRINUSE &&
		       --tport > IPPORT_RESERVED / 2)
			sin->sin_port = htons(tport);
d190 8
@


1.10
log
@cleanup -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.9 1997/04/18 09:58:11 deraadt Exp $	*/
d177 1
@


1.9
log
@avoid possible *NULL; fvdl
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.8 1996/12/24 20:14:29 dm Exp $	*/
d1219 1
a1219 1
	if (mrq != NULL)n
@


1.8
log
@reclaim NFSMNT_RESVPORT bit, and add more traditional attribute cache timeout flags
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.7 1996/07/03 07:10:33 deraadt Exp $	*/
d1219 2
a1220 1
	*mbp = mb;
@


1.7
log
@cannot check for < NFS_MINPACKET on some transports; from guy@@netapp.com
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.6 1996/04/21 22:30:26 deraadt Exp $	*/
d168 2
d171 1
a171 1
	if (saddr->sa_family == AF_INET && (nmp->nm_flag & NFSMNT_RESVPORT)) {
@


1.6
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.5 1996/04/17 04:50:29 mickey Exp $	*/
d2021 1
a2021 1
		if (slp->ns_reclen < NFS_MINPACKET || slp->ns_reclen > NFS_MAXPACKET) {
@


1.5
log
@Minor cleanups. Checked against Lite2.
(NetBSD's was really just a Lite2's, but w/ 64bit support)
@
text
@d1 2
a2 2
/*	$OpenBSD: nfs_socket.c,v 1.4 1996/03/31 13:15:47 mickey Exp $	*/
/*	$NetBSD: nfs_socket.c,v 1.26 1996/02/25 17:47:26 fvdl Exp $	*/
d157 1
a157 1
	nmp->nm_so = (struct socket *)NULL;
d326 1
a326 1
		nmp->nm_so = (struct socket *)NULL;
d370 1
a370 1
		sendnam = (struct mbuf *)NULL;
d378 2
a379 2
	error = sosend(so, sendnam, (struct uio *)NULL, top,
		(struct mbuf *)NULL, flags);
d433 2
a434 2
	*mp = (struct mbuf *)NULL;
	*aname = (struct mbuf *)NULL;
d498 2
a499 2
			   error = soreceive(so, (struct mbuf **)NULL, &auio,
			   (struct mbuf **)NULL, (struct mbuf **)NULL, &rcvflg);
d531 2
a532 2
			    error =  soreceive(so, (struct mbuf **)NULL,
				&auio, mp, (struct mbuf **)NULL, &rcvflg);
d555 1
a555 1
			    error =  soreceive(so, (struct mbuf **)NULL,
d574 1
a574 1
			*mp = (struct mbuf *)NULL;
d590 1
a590 1
			getnam = (struct mbuf **)NULL;
d598 1
a598 1
				(struct mbuf **)NULL, &rcvflg);
d607 1
a607 1
		*mp = (struct mbuf *)NULL;
d839 1
a839 1
	verf_str = auth_str = (char *)NULL;
d975 1
a975 1
				mheadend->m_next = (struct mbuf *)NULL;
d1239 2
a1241 1
#ifdef NFSSERVER
d1243 1
a1244 2
	int s, error;
	u_quad_t cur_usec;
d1304 1
a1304 1
			        (struct mbuf *)NULL, (struct mbuf *)NULL);
d1307 1
a1307 1
			        nmp->nm_nam, (struct mbuf *)NULL);
d1355 1
a1355 1
	timeout(nfs_timer, NULL, nfs_ticks);
d1399 1
a1399 1
		p = (struct proc *)NULL;
d1902 2
a1903 3
		error = soreceive(so, &nam, &auio, &mp,
			(struct mbuf **)NULL, &flags);
		if (error || mp == NULL) {
d1937 1
a1937 1
				(struct mbuf **)NULL, &flags);
d1950 1
a1950 1
				m->m_nextpkt = (struct mbuf *)NULL;
d2032 1
a2032 1
		slp->ns_raw = slp->ns_rawend = (struct mbuf *)NULL;
d2037 1
a2037 1
		om = (struct mbuf *)NULL;
d2060 1
a2060 1
				om->m_next = (struct mbuf *)NULL;
d2089 1
a2089 1
		slp->ns_frag = (struct mbuf *)NULL;
d2109 1
a2109 1
	    (m = slp->ns_rec) == NULL)
d2113 1
a2113 1
		m->m_nextpkt = (struct mbuf *)NULL;
d2115 1
a2115 1
		slp->ns_recend = (struct mbuf *)NULL;
@


1.4
log
@From NetBSD: NFSv3 import (tomorrow's Net's kernel)
Open's patches kept in. i'll possibly take a look at Lite2 soon,
is there smth usefull ?..
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_socket.c,v 1.3 1996/02/29 09:24:53 niklas Exp $	*/
d157 1
a157 1
	nmp->nm_so = (struct socket *)0;
d326 1
a326 1
		nmp->nm_so = (struct socket *)0;
d370 1
a370 1
		sendnam = (struct mbuf *)0;
d378 2
a379 2
	error = sosend(so, sendnam, (struct uio *)0, top,
		(struct mbuf *)0, flags);
d433 2
a434 2
	*mp = (struct mbuf *)0;
	*aname = (struct mbuf *)0;
d498 2
a499 2
			   error = soreceive(so, (struct mbuf **)0, &auio,
				(struct mbuf **)0, (struct mbuf **)0, &rcvflg);
d531 2
a532 2
			    error =  soreceive(so, (struct mbuf **)0,
				&auio, mp, (struct mbuf **)0, &rcvflg);
d555 1
a555 1
			    error =  soreceive(so, (struct mbuf **)0,
d574 1
a574 1
			*mp = (struct mbuf *)0;
d590 1
a590 1
			getnam = (struct mbuf **)0;
d598 1
a598 1
				(struct mbuf **)0, &rcvflg);
d607 1
a607 1
		*mp = (struct mbuf *)0;
d839 1
a839 1
	verf_str = auth_str = (char *)0;
d975 1
a975 1
				mheadend->m_next = (struct mbuf *)0;
d1304 1
a1304 1
			    (struct mbuf *)0, (struct mbuf *)0);
d1307 1
a1307 1
			    nmp->nm_nam, (struct mbuf *)0);
d1355 1
a1355 1
	timeout(nfs_timer, (void *)0, nfs_ticks);
d1399 1
a1399 1
		p = (struct proc *)0;
d1902 3
a1904 2
		error = soreceive(so, &nam, &auio, &mp, (struct mbuf **)0, &flags);
		if (error || mp == (struct mbuf *)0) {
d1938 1
a1938 1
						(struct mbuf **)0, &flags);
d1951 1
a1951 1
				m->m_nextpkt = (struct mbuf *)0;
d2033 1
a2033 1
		slp->ns_raw = slp->ns_rawend = (struct mbuf *)0;
d2038 1
a2038 1
		om = (struct mbuf *)0;
d2061 1
a2061 1
				om->m_next = (struct mbuf *)0;
d2090 1
a2090 1
		slp->ns_frag = (struct mbuf *)0;
d2110 1
a2110 1
	    (m = slp->ns_rec) == (struct mbuf *)0)
d2114 1
a2114 1
		m->m_nextpkt = (struct mbuf *)0;
d2116 1
a2116 1
		slp->ns_recend = (struct mbuf *)0;
@


1.3
log
@From NetBSD: merge with 960217 (still NFSv2)
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: nfs_socket.c,v 1.23 1996/02/09 21:48:29 christos Exp $	*/
d5 1
a5 1
 * Copyright (c) 1989, 1991, 1993
d39 1
a39 1
 *	@@(#)nfs_socket.c	8.3 (Berkeley) 1/12/94
d63 1
d65 1
a65 1
#include <nfs/nfsv2.h>
d101 1
a101 1
	rpc_auth_unix, rpc_msgaccepted, rpc_call, rpc_autherr, rpc_rejectedcred,
d103 1
a103 1
extern u_int32_t nfs_prog, nfs_vers, nqnfs_prog, nqnfs_vers;
d105 3
a107 26
extern int nonidempotent[NFS_NPROCS];

/*
 * Maps errno values to nfs error numbers.
 * Use NFSERR_IO as the catch all for ones not specifically defined in
 * RFC 1094.
 */
static int nfsrv_errmap[ELAST] = {
  NFSERR_PERM,	NFSERR_NOENT,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,
  NFSERR_NXIO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,
  NFSERR_IO,	NFSERR_IO,	NFSERR_ACCES,	NFSERR_IO,	NFSERR_IO,
  NFSERR_IO,	NFSERR_EXIST,	NFSERR_IO,	NFSERR_NODEV,	NFSERR_NOTDIR,
  NFSERR_ISDIR,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,
  NFSERR_IO,	NFSERR_FBIG,	NFSERR_NOSPC,	NFSERR_IO,	NFSERR_ROFS,
  NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,
  NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,
  NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,
  NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,
  NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,
  NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,
  NFSERR_IO,	NFSERR_IO,	NFSERR_NAMETOL,	NFSERR_IO,	NFSERR_IO,
  NFSERR_NOTEMPTY, NFSERR_IO,	NFSERR_IO,	NFSERR_DQUOT,	NFSERR_STALE,
  NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,
  NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,
  NFSERR_IO,
};
d118 2
a119 1
	0, 1, 0, 0, 2, 3, 3, 0, 4, 0, 0, 0, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0,
d159 2
a160 2
	error = socreate(saddr->sa_family,
			 &nmp->nm_so, nmp->nm_sotype, nmp->nm_soproto);
d195 2
a196 1
		if ((error = soconnect(so, nmp->nm_nam)) != 0)
d210 1
a210 1
			    (error = nfs_sigintr(nmp, rep, rep->r_procp))) {
d233 2
a234 1
		rcvreserve = nmp->nm_rsize + NFS_MAXPKTHDR;
d237 2
a238 1
		rcvreserve = (nmp->nm_rsize + NFS_MAXPKTHDR) * 2;
d259 2
a260 1
	if ((error = soreserve(so, sndreserve, rcvreserve)) != 0)
d446 2
a447 1
		if ((error = nfs_sndlock(&rep->r_nmp->nm_flag, rep)) != 0)
d463 4
a466 2
		if ((so = rep->r_nmp->nm_so) == NULL) {
			if ((error = nfs_reconnect(rep)) != 0) {
d478 1
a478 1
				    (error = nfs_reconnect(rep))) {
d647 2
a648 1
		if ((error = nfs_rcvlock(myrep)) != 0)
d810 1
d815 1
d818 2
a819 1
	char *auth_str;
d839 1
a839 1
	auth_str = (char *)0;
d841 8
a848 3
		if (failed_auth) {
			error = nfs_getauth(nmp, rep, cred, &auth_type,
				&auth_str, &auth_len);
a853 3
		} else {
			auth_type = RPCAUTH_UNIX;
			auth_len = 5 * NFSX_UNSIGNED;
d861 2
a862 2
	m = nfsm_rpchead(cred, (nmp->nm_flag & NFSMNT_NQNFS), procnum,
	     auth_type, auth_len, auth_str, mrest, mrest_len, &mheadend, &xid);
d968 1
a968 1
	nfsm_dissect(tl, u_int32_t *, 3*NFSX_UNSIGNED);
d973 1
a973 1
			if (*tl == rpc_rejectedcred && failed_auth == 0) {
d990 1
a990 2
	 * skip over the auth_verf, someday we may want to cache auth_short's
	 * for nfs_reqhead(), but for now just dump it
d992 8
a999 4
	if (*++tl != 0) {
		i = nfsm_rndup(fxdr_unsigned(int32_t, *tl));
		nfsm_adv(i);
	}
d1006 3
a1008 3
			m_freem(mrep);
			if ((nmp->nm_flag & NFSMNT_NQNFS) &&
			    error == NQNFS_TRYLATER) {
d1026 7
d1064 2
a1067 2
	error = EPROTONOSUPPORT;
nfsmout:
d1077 1
a1077 1
nfs_rephead(siz, nd, err, cache, frev, mrq, mbp, bposp)
d1079 2
a1080 1
	struct nfsd *nd;
d1105 2
a1106 2
	mreq->m_len = 6*NFSX_UNSIGNED;
	bpos = ((caddr_t)tl)+mreq->m_len;
d1109 1
a1109 1
	if (err == ERPCMISMATCH || err == NQNFS_AUTHERR) {
d1111 1
a1111 1
		if (err == NQNFS_AUTHERR) {
d1113 1
a1113 1
			*tl = rpc_rejectedcred;
d1118 2
a1119 2
			*tl++ = txdr_unsigned(2);
			*tl = txdr_unsigned(2);
d1123 44
a1166 2
		*tl++ = 0;
		*tl++ = 0;
d1173 8
a1180 3
			nfsm_build(tl, u_int32_t *, 2*NFSX_UNSIGNED);
			*tl++ = txdr_unsigned(2);
			*tl = txdr_unsigned(2);	/* someday 3 */
d1185 3
d1190 1
a1190 1
			if (err != VNOVAL) {
d1193 1
a1193 1
					*tl = txdr_unsigned(nfsrv_errmap[err - 1]);
d1195 1
a1195 1
					*tl = 0;
d1204 4
a1207 4
	if (nd->nd_nqlflag != NQL_NOVAL && err == 0) {
		if (nd->nd_nqlflag) {
			nfsm_build(tl, u_int32_t *, 5*NFSX_UNSIGNED);
			*tl++ = txdr_unsigned(nd->nd_nqlflag);
a1211 2
			if (nd->nd_nqlflag != 0)
				panic("nqreph");
d1219 1
a1219 1
	if (err != 0 && err != VNOVAL)
d1232 1
a1232 1
	void *arg;
d1239 1
d1244 1
d1342 11
d1355 1
a1355 1
	timeout(nfs_timer, (void *)0, hz / NFS_HZ);
d1571 3
a1573 2
nfs_getreq(nd, has_header)
	register struct nfsd *nd;
d1581 1
a1581 1
	caddr_t dpos, cp2;
d1583 2
a1584 1
	int error = 0, nqnfs = 0;
d1586 2
d1593 2
a1594 2
		nfsm_dissect(tl, u_int32_t *, 10*NFSX_UNSIGNED);
		nd->nd_retxid = fxdr_unsigned(u_int32_t , *tl++);
d1599 2
a1600 3
	} else {
		nfsm_dissect(tl, u_int32_t *, 8*NFSX_UNSIGNED);
	}
d1602 1
a1607 1
	nfsvers = nfs_vers;
d1609 1
a1609 1
		if (*tl == nqnfs_prog) {
d1611 1
a1611 2
			nfsvers = nqnfs_vers;
		} else {
d1618 3
a1620 1
	if (*tl++ != nfsvers) {
d1625 5
a1629 1
	nd->nd_procnum = fxdr_unsigned(u_int32_t , *tl++);
d1633 2
a1634 2
		(!nqnfs && nd->nd_procnum > NFSPROC_STATFS) ||
		(*tl != rpc_auth_unix && *tl != rpc_auth_kerb)) {
d1639 2
d1648 1
d1659 3
a1661 1
		nfsm_dissect(tl, u_int32_t *, 3*NFSX_UNSIGNED);
d1669 1
a1669 1
		nfsm_dissect(tl, u_int32_t *, (len + 2)*NFSX_UNSIGNED);
d1671 4
a1674 4
			if (i < NGROUPS)
				nd->nd_cr.cr_groups[i] = fxdr_unsigned(gid_t, *tl++);
			else
				tl++;
d1676 4
a1679 5
	} else if (auth_type == rpc_auth_kerb) {
		nd->nd_cr.cr_uid = fxdr_unsigned(uid_t, *tl++);
		nd->nd_authlen = fxdr_unsigned(int, *tl);
		uio.uio_resid = nfsm_rndup(nd->nd_authlen);
		if (uio.uio_resid > (len - 2 * NFSX_UNSIGNED)) {
d1683 84
a1766 10
		uio.uio_offset = 0;
		uio.uio_iov = &iov;
		uio.uio_iovcnt = 1;
		uio.uio_segflg = UIO_SYSSPACE;
		iov.iov_base = (caddr_t)nd->nd_authstr;
		iov.iov_len = RPCAUTH_MAXSIZ;
		nfsm_mtouio(&uio, uio.uio_resid);
		nfsm_dissect(tl, u_int32_t *, 2 * NFSX_UNSIGNED);
		nd->nd_flag |= NFSD_NEEDAUTH;
	}
d1768 19
a1786 13
	/*
	 * Do we have any use for the verifier.
	 * According to the "Remote Procedure Call Protocol Spec." it
	 * should be AUTH_NULL, but some clients make it AUTH_UNIX?
	 * For now, just skip over it
	 */
	len = fxdr_unsigned(int, *++tl);
	if (len < 0 || len > RPCAUTH_MAXSIZ) {
		m_freem(mrep);
		return (EBADRPC);
	}
	if (len > 0) {
		nfsm_adv(nfsm_rndup(len));
d1794 2
a1795 2
		nd->nd_nqlflag = fxdr_unsigned(int, *tl);
		if (nd->nd_nqlflag) {
d1797 1
a1797 1
			nd->nd_duration = fxdr_unsigned(int, *tl);
d1800 1
a1800 2
	} else {
		nd->nd_nqlflag = NQL_NOVAL;
a1801 1
	}
d1809 1
a1809 1
void
d1822 1
d1826 2
a1827 2
int (*nfsrv_procs[NFS_NPROCS]) __P((struct nfsd *, struct mbuf *, struct mbuf *,
				    caddr_t, struct ucred *, struct mbuf *,
a1831 1
	nfsrv_noop,
d1833 1
a1835 1
	nfsrv_noop,
d1838 3
d1842 1
a1844 3
	nfsrv_symlink,
	nfsrv_mkdir,
	nfsrv_rmdir,
d1846 1
d1848 3
a1850 1
	nqnfsrv_readdirlook,
d1854 1
a1854 1
	nqnfsrv_access,
d1925 2
a1926 1
		if ((error = nfsrv_getstream(slp, waitflag)) != 0) {
d1981 1
a1981 1
	register struct mbuf *m;
d1985 1
a1985 1
	u_long recmark;
d2015 6
a2020 1
		slp->ns_reclen = ntohl(recmark) & ~0x80000000;
d2074 17
a2090 6
	    nfs_realign(recm, 10 * NFSX_UNSIGNED);
	    if (slp->ns_recend)
		slp->ns_recend->m_nextpkt = recm;
	    else
		slp->ns_rec = recm;
	    slp->ns_recend = recm;
d2098 1
a2098 1
nfsrv_dorec(slp, nd)
d2100 2
a2101 1
	register struct nfsd *nd;
d2103 2
a2104 1
	register struct mbuf *m;
d2107 1
d2111 2
a2112 1
	if ((slp->ns_rec = m->m_nextpkt) != NULL)
d2117 14
a2130 10
		nd->nd_nam = m;
		nd->nd_md = nd->nd_mrep = m->m_next;
		m->m_next = (struct mbuf *)0;
	} else {
		nd->nd_nam = (struct mbuf *)0;
		nd->nd_md = nd->nd_mrep = m;
	}
	nd->nd_dpos = mtod(nd->nd_md, caddr_t);
	if ((error = nfs_getreq(nd, TRUE)) != 0) {
		m_freem(nd->nd_nam);
d2133 2
d2138 1
d2152 4
a2155 4
	for (nd = nfsd_head.tqh_first; nd != 0; nd = nd->nd_chain.tqe_next) {
		if (nd->nd_flag & NFSD_WAITING) {
			nd->nd_flag &= ~NFSD_WAITING;
			if (nd->nd_slp)
d2158 1
a2158 1
			nd->nd_slp = slp;
@


1.2
log
@from cgd; handle 64-bit pointers and longs
@
text
@d1 2
a2 1
/*	$NetBSD: nfs_socket.c,v 1.22 1995/12/19 23:07:38 cgd Exp $	*/
d59 1
d72 1
a158 4
int	nfs_sbwait();
void	nfs_disconnect(), nfs_realign(), nfsrv_wakenfsd(), nfs_sndunlock();
void	nfs_rcvunlock(), nqnfs_serverd(), nqnfs_clientlease();
struct mbuf *nfsm_rpchead();
d166 1
d180 3
a182 2
	if (error = socreate(saddr->sa_family,
		&nmp->nm_so, nmp->nm_sotype, nmp->nm_soproto))
d216 1
a216 1
		if (error = soconnect(so, nmp->nm_nam))
d277 1
a277 1
	if (error = soreserve(so, sndreserve, rcvreserve))
d306 1
d315 1
a315 1
	while (error = nfs_connect(nmp, rep)) {
d362 1
d431 1
d463 1
a463 1
		if (error = nfs_sndlock(&rep->r_nmp->nm_flag, rep))
d480 1
a480 1
			if (error = nfs_reconnect(rep)) {
d489 2
a490 1
			if (error = nfs_send(so, rep->r_nmp->nm_nam, m, rep)) {
d639 1
d661 1
a661 1
		if (error = nfs_rcvlock(myrep))
d805 1
a821 1
	struct nfsreq *reph;
d1074 1
d1188 1
d1190 1
d1298 1
d1322 1
d1368 1
d1506 1
d1655 1
d1671 3
a1673 23
int	nfsrv_null(),
	nfsrv_getattr(),
	nfsrv_setattr(),
	nfsrv_lookup(),
	nfsrv_readlink(),
	nfsrv_read(),
	nfsrv_write(),
	nfsrv_create(),
	nfsrv_remove(),
	nfsrv_rename(),
	nfsrv_link(),
	nfsrv_symlink(),
	nfsrv_mkdir(),
	nfsrv_rmdir(),
	nfsrv_readdir(),
	nfsrv_statfs(),
	nfsrv_noop(),
	nqnfsrv_readdirlook(),
	nqnfsrv_getlease(),
	nqnfsrv_vacated(),
	nqnfsrv_access();

int (*nfsrv_procs[NFS_NPROCS])() = {
d1767 1
a1767 1
		if (error = nfsrv_getstream(slp, waitflag)) {
d1817 1
d1825 1
a1825 1
	struct mbuf *om, *m2, *recm;
d1922 1
d1933 1
a1933 1
	if (slp->ns_rec = m->m_nextpkt)
d1946 1
a1946 1
	if (error = nfs_getreq(nd, TRUE)) {
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: nfs_socket.c,v 1.21 1995/08/13 00:00:01 mycroft Exp $	*/
d96 2
a97 2
extern u_long rpc_reply, rpc_msgdenied, rpc_mismatch, rpc_vers, rpc_auth_unix,
	rpc_msgaccepted, rpc_call, rpc_autherr, rpc_rejectedcred,
d99 1
a99 1
extern u_long nfs_prog, nfs_vers, nqnfs_prog, nqnfs_vers;
d176 1
a176 1
	u_short tport;
d261 2
a262 2
			*mtod(m, int *) = 1;
			m->m_len = sizeof(int);
d267 2
a268 2
			*mtod(m, int *) = 1;
			m->m_len = sizeof(int);
d271 4
a274 4
		sndreserve = (nmp->nm_wsize + NFS_MAXPKTHDR + sizeof (u_long))
				* 2;
		rcvreserve = (nmp->nm_rsize + NFS_MAXPKTHDR + sizeof (u_long))
				* 2;
d438 1
a438 1
	u_long len;
d497 1
a497 1
			aio.iov_len = sizeof(u_long);
d503 1
a503 1
			auio.uio_resid = sizeof(u_long);
d517 2
a518 2
				 sizeof(u_long) - auio.uio_resid,
				 sizeof(u_long),
d639 1
a639 1
	register long t1;
d641 1
a641 1
	u_long rxid, *tl;
d688 1
a688 1
		nfsm_dissect(tl, u_long *, 2*NFSX_UNSIGNED);
d811 1
a811 1
	register u_long *tl;
d821 1
a821 1
	u_long xid;
d873 1
a873 1
		*mtod(m, u_long *) = htonl(0x80000000 |
d970 1
a970 1
	nfsm_dissect(tl, u_long *, 3*NFSX_UNSIGNED);
d996 1
a996 1
		i = nfsm_rndup(fxdr_unsigned(long, *tl));
d999 1
a999 1
	nfsm_dissect(tl, u_long *, NFSX_UNSIGNED);
d1002 1
a1002 1
		nfsm_dissect(tl, u_long *, NFSX_UNSIGNED);
d1034 1
a1034 1
			nfsm_dissect(tl, u_long *, NFSX_UNSIGNED);
d1038 1
a1038 1
				nfsm_dissect(tl, u_long *, 4*NFSX_UNSIGNED);
d1078 1
a1078 1
	register u_long *tl;
d1094 1
a1094 1
	tl = mtod(mreq, u_long *);
d1121 1
a1121 1
			nfsm_build(tl, u_long *, 2*NFSX_UNSIGNED);
d1131 1
a1131 1
				nfsm_build(tl, u_long *, NFSX_UNSIGNED);
d1146 1
a1146 1
			nfsm_build(tl, u_long *, 5*NFSX_UNSIGNED);
d1154 1
a1154 1
			nfsm_build(tl, u_long *, NFSX_UNSIGNED);
d1418 1
a1418 1
	    if ((m->m_len & 0x3) || (mtod(m, int) & 0x3)) {
d1421 1
a1421 1
		if ((int)fcp & 0x3) {
d1499 2
a1500 2
	register u_long *tl;
	register long t1;
d1504 1
a1504 1
	u_long nfsvers, auth_type;
d1512 2
a1513 2
		nfsm_dissect(tl, u_long *, 10*NFSX_UNSIGNED);
		nd->nd_retxid = fxdr_unsigned(u_long, *tl++);
d1519 1
a1519 1
		nfsm_dissect(tl, u_long *, 8*NFSX_UNSIGNED);
d1544 1
a1544 1
	nd->nd_procnum = fxdr_unsigned(u_long, *tl++);
d1571 1
a1571 1
		nfsm_dissect(tl, u_long *, 3*NFSX_UNSIGNED);
d1579 1
a1579 1
		nfsm_dissect(tl, u_long *, (len + 2)*NFSX_UNSIGNED);
d1601 1
a1601 1
		nfsm_dissect(tl, u_long *, 2 * NFSX_UNSIGNED);
d1624 1
a1624 1
		nfsm_dissect(tl, u_long *, NFSX_UNSIGNED);
d1627 1
a1627 1
			nfsm_dissect(tl, u_long *, NFSX_UNSIGNED);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
