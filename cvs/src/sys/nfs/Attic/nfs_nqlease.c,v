head	1.17;
access;
symbols
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	UBC_SYNC_A:1.17
	UBC_SYNC_B:1.17
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_8:1.14.0.10
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.14.0.8
	OPENBSD_2_7_BASE:1.14
	SMP:1.14.0.6
	SMP_BASE:1.14
	kame_19991208:1.14
	OPENBSD_2_6:1.14.0.4
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.14.0.2
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.13.0.2
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.12.0.2
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2001.06.25.03.28.07;	author csapuntz;	state dead;
branches;
next	1.16;

1.16
date	2001.06.25.02.15.46;	author csapuntz;	state Exp;
branches;
next	1.15;

1.15
date	2001.02.24.19.07.11;	author csapuntz;	state Exp;
branches;
next	1.14;

1.14
date	99.02.06.23.07.40;	author millert;	state Exp;
branches
	1.14.6.1;
next	1.13;

1.13
date	98.08.19.22.26.51;	author csapuntz;	state Exp;
branches;
next	1.12;

1.12
date	97.11.06.05.59.01;	author csapuntz;	state Exp;
branches;
next	1.11;

1.11
date	97.10.06.20.20.46;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.10.06.15.23.41;	author csapuntz;	state Exp;
branches;
next	1.9;

1.9
date	97.04.18.10.13.23;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.04.18.10.02.36;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.06.01.04.43.58;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.04.21.22.30.20;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.04.17.04.50.26;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.03.31.13.15.38;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.02.29.09.24.51;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.21.14.42.20;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.22;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.22;	author deraadt;	state Exp;
branches;
next	;

1.14.6.1
date	2001.05.14.22.44.57;	author niklas;	state Exp;
branches;
next	1.14.6.2;

1.14.6.2
date	2001.07.04.10.55.47;	author niklas;	state dead;
branches;
next	;


desc
@@


1.17
log
@Remove NQNFS
@
text
@/*	$OpenBSD: nfs_nqlease.c,v 1.16 2001/06/25 02:15:46 csapuntz Exp $	*/
/*	$NetBSD: nfs_nqlease.c,v 1.14 1996/02/18 14:06:50 fvdl Exp $	*/

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Rick Macklem at The University of Guelph.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)nfs_nqlease.c	8.9 (Berkeley) 5/20/95
 */

/*
 * References:
 *	Cary G. Gray and David R. Cheriton, "Leases: An Efficient Fault-Tolerant
 *		Mechanism for Distributed File Cache Consistency",
 *		In Proc. of the Twelfth ACM Symposium on Operating Systems
 *		Principals, pg. 202-210, Litchfield Park, AZ, Dec. 1989.
 *	Michael N. Nelson, Brent B. Welch and John K. Ousterhout, "Caching
 *		in the Sprite Network File System", ACM TOCS 6(1),
 *		pages 134-154, February 1988.
 *	V. Srinivasan and Jeffrey C. Mogul, "Spritely NFS: Implementation and
 *		Performance of Cache-Consistency Protocols", Digital
 *		Equipment Corporation WRL Research Report 89/5, May 1989.
 */
#include <sys/param.h>
#include <sys/vnode.h>
#include <sys/mount.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/file.h>
#include <sys/buf.h>
#include <sys/stat.h>
#include <sys/protosw.h>
#include <sys/namei.h>

#include <netinet/in.h>
#include <nfs/rpcv2.h>
#include <nfs/nfsproto.h>
#include <nfs/nfs.h>
#include <nfs/nfsm_subs.h>
#include <nfs/xdr_subs.h>
#include <nfs/nqnfs.h>
#include <nfs/nfsnode.h>
#include <nfs/nfsmount.h>
#include <nfs/nfs_var.h>

time_t nqnfsstarttime = (time_t)0;
int nqsrv_clockskew = NQ_CLOCKSKEW;
int nqsrv_writeslack = NQ_WRITESLACK;
int nqsrv_maxlease = NQ_MAXLEASE;
int nqsrv_maxnumlease = NQ_MAXNUMLEASE;

/*
 * Signifies which rpcs can have piggybacked lease requests
 */
int nqnfs_piggy[NFS_NPROCS] = {
	0,
	0,
	ND_WRITE,
	ND_READ,
	0,
	ND_READ,
	ND_READ,
	ND_WRITE,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	ND_READ,
	ND_READ,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
};

extern nfstype nfsv2_type[9];
extern nfstype nfsv3_type[9];
extern struct nfssvc_sock *nfs_udpsock, *nfs_cltpsock;
extern int nfsd_waiting;
struct nfsstats nfsstats;


#define TRUE	1
#define	FALSE	0

/*
 * Get or check for a lease for "vp", based on ND_CHECK flag.
 * The rules are as follows:
 * - if a current non-caching lease, reply non-caching
 * - if a current lease for same host only, extend lease
 * - if a read cachable lease and a read lease request
 *	add host to list any reply cachable
 * - else { set non-cachable for read-write sharing }
 *	send eviction notice messages to all other hosts that have lease
 *	wait for lease termination { either by receiving vacated messages
 *					from all the other hosts or expiry
 *					via. timeout }
 *	modify lease to non-cachable
 * - else if no current lease, issue new one
 * - reply
 * - return boolean TRUE iff nam should be m_freem()'d
 * NB: Since nqnfs_serverd() is called from a timer, any potential tsleep()
 *     in here must be framed by nqsrv_locklease() and nqsrv_unlocklease().
 *     nqsrv_locklease() is coded such that at least one of LC_LOCKED and
 *     LC_WANTED is set whenever a process is tsleeping in it. The exception
 *     is when a new lease is being allocated, since it is not in the timer
 *     queue yet. (Ditto for the splsoftclock() and splx(s) calls)
 */
int
nqsrv_getlease(vp, duration, flags, slp, procp, nam, cachablep, frev, cred)
	struct vnode *vp;
	u_int32_t *duration;
	int flags;
	struct nfssvc_sock *slp;
	struct proc *procp;
	struct mbuf *nam;
	int *cachablep;
	u_quad_t *frev;
	struct ucred *cred;
{
	register struct nqlease *lp;
	register struct nqfhhashhead *lpp = NULL;
	register struct nqhost *lph = NULL;
	struct nqlease *tlp;
	struct nqm **lphp;
	struct vattr vattr;
	fhandle_t fh;
	int i, ok, error, s;

	if (vp->v_type != VREG && vp->v_type != VDIR && vp->v_type != VLNK)
		return (0);
	if (*duration > nqsrv_maxlease)
		*duration = nqsrv_maxlease;
	error = VOP_GETATTR(vp, &vattr, cred, procp);
	if (error)
		return (error);
	*frev = vattr.va_filerev;
	s = splsoftclock();
	tlp = 0;
	if ((flags & ND_CHECK) == 0)
		nfsstats.srvnqnfs_getleases++;
	if (tlp == 0) {
		/*
		 * Find the lease by searching the hash list.
		 */
		fh.fh_fsid = vp->v_mount->mnt_stat.f_fsid;
		error = VFS_VPTOFH(vp, &fh.fh_fid);
		if (error) {
			splx(s);
			return (error);
		}
		lpp = NQFHHASH(fh.fh_fid.fid_data);
		for (lp = lpp->lh_first; lp != 0; lp = lp->lc_hash.le_next)
			if (fh.fh_fsid.val[0] == lp->lc_fsid.val[0] &&
			    fh.fh_fsid.val[1] == lp->lc_fsid.val[1] &&
			    !bcmp(fh.fh_fid.fid_data, lp->lc_fiddata,
				  fh.fh_fid.fid_len - sizeof (int32_t))) {
				/* Found it */
				lp->lc_vp = vp;
				tlp = lp;
				break;
			}
	} else
		lp = tlp;
	if (lp != 0) {
		if ((lp->lc_flag & LC_NONCACHABLE) ||
		    (lp->lc_morehosts == (struct nqm *)0 &&
		     nqsrv_cmpnam(slp, nam, &lp->lc_host)))
			goto doreply;
		if ((flags & ND_READ) && (lp->lc_flag & LC_WRITE) == 0) {
			if (flags & ND_CHECK)
				goto doreply;
			if (nqsrv_cmpnam(slp, nam, &lp->lc_host))
				goto doreply;
			i = 0;
			if (lp->lc_morehosts) {
				lph = lp->lc_morehosts->lpm_hosts;
				lphp = &lp->lc_morehosts->lpm_next;
				ok = 1;
			} else {
				lphp = &lp->lc_morehosts;
				ok = 0;
			}
			while (ok && (lph->lph_flag & LC_VALID)) {
				if (nqsrv_cmpnam(slp, nam, lph))
					goto doreply;
				if (++i == LC_MOREHOSTSIZ) {
					i = 0;
					if (*lphp) {
						lph = (*lphp)->lpm_hosts;
						lphp = &((*lphp)->lpm_next);
					} else
						ok = 0;
				} else
					lph++;
			}
			nqsrv_locklease(lp);
			if (!ok) {
				*lphp = (struct nqm *)
					malloc(sizeof (struct nqm),
						M_NQMHOST, M_WAITOK);
				bzero((caddr_t)*lphp, sizeof (struct nqm));
				lph = (*lphp)->lpm_hosts;
			}
			nqsrv_addhost(lph, slp, nam);
			nqsrv_unlocklease(lp);
		} else {
			lp->lc_flag |= LC_NONCACHABLE;
			nqsrv_locklease(lp);
			nqsrv_send_eviction(vp, lp, slp, nam, cred);
			nqsrv_waitfor_expiry(lp);
			nqsrv_unlocklease(lp);
		}
doreply:
		/*
		 * Update the lease and return
		 */
		if ((flags & ND_CHECK) == 0)
			nqsrv_instimeq(lp, *duration);
		if (lp->lc_flag & LC_NONCACHABLE)
			*cachablep = 0;
		else {
			*cachablep = 1;
			if (flags & ND_WRITE)
				lp->lc_flag |= LC_WRITTEN;
		}
		splx(s);
		return (0);
	}
	splx(s);
	if (flags & ND_CHECK)
		return (0);

	/*
	 * Allocate new lease
	 * The value of nqsrv_maxnumlease should be set generously, so that
	 * the following "printf" happens infrequently.
	 */
	if (nfsstats.srvnqnfs_leases > nqsrv_maxnumlease) {
		printf("Nqnfs server, too many leases\n");
		do {
			(void) tsleep((caddr_t)&lbolt, PSOCK,
					"nqsrvnuml", 0);
		} while (nfsstats.srvnqnfs_leases > nqsrv_maxnumlease);
	}
	MALLOC(lp, struct nqlease *, sizeof (struct nqlease), M_NQLEASE, M_WAITOK);
	bzero((caddr_t)lp, sizeof (struct nqlease));
	if (flags & ND_WRITE)
		lp->lc_flag |= (LC_WRITE | LC_WRITTEN);
	nqsrv_addhost(&lp->lc_host, slp, nam);
	lp->lc_vp = vp;
	lp->lc_fsid = fh.fh_fsid;
	bcopy(fh.fh_fid.fid_data, lp->lc_fiddata,
	    fh.fh_fid.fid_len - sizeof (int32_t));
	if(!lpp)
		panic("nfs_nqlease.c: Phoney lpp");
	LIST_INSERT_HEAD(lpp, lp, lc_hash);
	s = splsoftclock();
	nqsrv_instimeq(lp, *duration);
	splx(s);
	*cachablep = 1;
	if (++nfsstats.srvnqnfs_leases > nfsstats.srvnqnfs_maxleases)
		nfsstats.srvnqnfs_maxleases = nfsstats.srvnqnfs_leases;
	return (0);
}

/*
 * Local lease check for server syscalls.
 * Just set up args and let nqsrv_getlease() do the rest.
 */
int
nqnfs_vop_lease_check(v)
	void *v;
{
	struct vop_lease_args /* {
		struct vnode *a_vp;
		struct proc *a_p;
		struct ucred *a_cred;
		int a_flag;
	} */ *ap = v;
	u_int32_t duration = 0;
	int cache;
	u_quad_t frev;

	(void) nqsrv_getlease(ap->a_vp, &duration, ND_CHECK | ap->a_flag,
	    NQLOCALSLP, ap->a_p, (struct mbuf *)0, &cache, &frev, ap->a_cred);
	return (0);
}

/*
 * Add a host to an nqhost structure for a lease.
 */
void
nqsrv_addhost(lph, slp, nam)
	register struct nqhost *lph;
	struct nfssvc_sock *slp;
	struct mbuf *nam;
{
	register struct sockaddr_in *saddr;

	if (slp == NQLOCALSLP)
		lph->lph_flag |= (LC_VALID | LC_LOCAL);
	else if (slp == nfs_udpsock) {
		saddr = mtod(nam, struct sockaddr_in *);
		lph->lph_flag |= (LC_VALID | LC_UDP);
		lph->lph_inetaddr = saddr->sin_addr.s_addr;
		lph->lph_port = saddr->sin_port;
	} else if (slp == nfs_cltpsock) {
		lph->lph_nam = m_copym(nam, 0, M_COPYALL, M_WAIT);
		lph->lph_flag |= (LC_VALID | LC_CLTP);
	} else {
		lph->lph_flag |= (LC_VALID | LC_SREF);
		lph->lph_slp = slp;
		slp->ns_sref++;
	}
}

/*
 * Update the lease expiry time and position it in the timer queue correctly.
 */
void
nqsrv_instimeq(lp, duration)
	register struct nqlease *lp;
	u_int32_t duration;
{
	register struct nqlease *tlp;
	time_t newexpiry;

	newexpiry = time.tv_sec + duration + nqsrv_clockskew;
	if (lp->lc_expiry == newexpiry)
		return;
	if (lp->lc_timer.cqe_next != 0)
		CIRCLEQ_REMOVE(&nqtimerhead, lp, lc_timer);
	lp->lc_expiry = newexpiry;

	/*
	 * Find where in the queue it should be.
	 */
	tlp = nqtimerhead.cqh_last;
	while (tlp != (void *)&nqtimerhead && tlp->lc_expiry > newexpiry)
		tlp = tlp->lc_timer.cqe_prev;
#ifdef HASNVRAM
	if (tlp == nqtimerhead.cqh_last)
		NQSTORENOVRAM(newexpiry);
#endif /* HASNVRAM */
	if (tlp == (void *)&nqtimerhead) {
		CIRCLEQ_INSERT_HEAD(&nqtimerhead, lp, lc_timer);
	} else {
		CIRCLEQ_INSERT_AFTER(&nqtimerhead, tlp, lp, lc_timer);
	}
}

/*
 * Compare the requesting host address with the lph entry in the lease.
 * Return true iff it is the same.
 * This is somewhat messy due to the union in the nqhost structure.
 * The local host is indicated by the special value of NQLOCALSLP for slp.
 */
int
nqsrv_cmpnam(slp, nam, lph)
	register struct nfssvc_sock *slp;
	struct mbuf *nam;
	register struct nqhost *lph;
{
	register struct sockaddr_in *saddr;
	struct mbuf *addr;
	union nethostaddr lhaddr;
	int ret;

	if (slp == NQLOCALSLP) {
		if (lph->lph_flag & LC_LOCAL)
			return (1);
		else
			return (0);
	}
	if (slp == nfs_udpsock || slp == nfs_cltpsock)
		addr = nam;
	else
		addr = slp->ns_nam;
	if (lph->lph_flag & LC_UDP)
		ret = netaddr_match(AF_INET, &lph->lph_haddr, addr);
	else if (lph->lph_flag & LC_CLTP)
		ret = netaddr_match(AF_ISO, &lph->lph_claddr, addr);
	else {
		if ((lph->lph_slp->ns_flag & SLP_VALID) == 0)
			return (0);
		saddr = mtod(lph->lph_slp->ns_nam, struct sockaddr_in *);
		if (saddr->sin_family == AF_INET)
			lhaddr.had_inetaddr = saddr->sin_addr.s_addr;
		else
			lhaddr.had_nam = lph->lph_slp->ns_nam;
		ret = netaddr_match(saddr->sin_family, &lhaddr, addr);
	}
	return (ret);
}

/*
 * Send out eviction notice messages to all other hosts for the lease.
 */
void
nqsrv_send_eviction(vp, lp, slp, nam, cred)
	struct vnode *vp;
	register struct nqlease *lp;
	struct nfssvc_sock *slp;
	struct mbuf *nam;
	struct ucred *cred;
{
	register struct nqhost *lph = &lp->lc_host;
	register struct mbuf *m;
	register int siz;
	struct nqm *lphnext = lp->lc_morehosts;
	struct mbuf *mreq, *mb, *mb2, *nam2, *mheadend;
	struct socket *so;
	struct sockaddr_in *saddr;
	nfsfh_t nfh;
	fhandle_t *fhp;
	caddr_t bpos, cp;
	u_int32_t xid, *tl;
	int len = 1, ok = 1, i = 0;
	int sotype, *solockp;

	while (ok && (lph->lph_flag & LC_VALID)) {
		if (nqsrv_cmpnam(slp, nam, lph))
			lph->lph_flag |= LC_VACATED;
		else if ((lph->lph_flag & (LC_LOCAL | LC_VACATED)) == 0) {
			if (lph->lph_flag & LC_UDP) {
				MGET(nam2, M_WAIT, MT_SONAME);
				saddr = mtod(nam2, struct sockaddr_in *);
				nam2->m_len = saddr->sin_len =
					sizeof (struct sockaddr_in);
				saddr->sin_family = AF_INET;
				saddr->sin_addr.s_addr = lph->lph_inetaddr;
				saddr->sin_port = lph->lph_port;
				so = nfs_udpsock->ns_so;
			} else if (lph->lph_flag & LC_CLTP) {
				nam2 = lph->lph_nam;
				so = nfs_cltpsock->ns_so;
			} else if (lph->lph_slp->ns_flag & SLP_VALID) {
				nam2 = (struct mbuf *)0;
				so = lph->lph_slp->ns_so;
			} else
				goto nextone;
			sotype = so->so_type;
			if (so->so_proto->pr_flags & PR_CONNREQUIRED)
				solockp = &lph->lph_slp->ns_solock;
			else
				solockp = (int *)0;
			nfsm_reqhead((struct vnode *)0, NQNFSPROC_EVICTED,
			    NFSX_V3FH + NFSX_UNSIGNED);
			fhp = &nfh.fh_generic;
			bzero((caddr_t)fhp, sizeof(nfh));
			fhp->fh_fsid = vp->v_mount->mnt_stat.f_fsid;
			VFS_VPTOFH(vp, &fhp->fh_fid);
			nfsm_srvfhtom(fhp, 1);
			m = mreq;
			siz = 0;
			while (m) {
				siz += m->m_len;
				m = m->m_next;
			}
			if (siz <= 0 || siz > NFS_MAXPACKET) {
				printf("mbuf siz=%d\n",siz);
				panic("Bad nfs svc reply");
			}
			m = nfsm_rpchead(cred, (NFSMNT_NFSV3 | NFSMNT_NQNFS),
				NQNFSPROC_EVICTED,
				RPCAUTH_UNIX, 5 * NFSX_UNSIGNED, (char *)0,
				0, (char *)0, mreq, siz, &mheadend, &xid);
			/*
			 * For stream protocols, prepend a Sun RPC
			 * Record Mark.
			 */
			if (sotype == SOCK_STREAM) {
				M_PREPEND(m, NFSX_UNSIGNED, M_WAIT);
				*mtod(m, u_int32_t *) = htonl(0x80000000 |
					(m->m_pkthdr.len - NFSX_UNSIGNED));
			}
			if (((lph->lph_flag & (LC_UDP | LC_CLTP)) == 0 &&
			    (lph->lph_slp->ns_flag & SLP_VALID) == 0) ||
			    (solockp && (*solockp & NFSMNT_SNDLOCK)))
				m_freem(m);
			else {
				if (solockp)
					*solockp |= NFSMNT_SNDLOCK;
				(void) nfs_send(so, nam2, m,
						(struct nfsreq *)0);
				if (solockp)
					nfs_sndunlock(solockp);
			}
			if (lph->lph_flag & LC_UDP)
				MFREE(nam2, m);
		}
nextone:
		if (++i == len) {
			if (lphnext) {
				i = 0;
				len = LC_MOREHOSTSIZ;
				lph = lphnext->lpm_hosts;
				lphnext = lphnext->lpm_next;
			} else
				ok = 0;
		} else
			lph++;
	}
}

/*
 * Wait for the lease to expire.
 * This will occur when all clients have sent "vacated" messages to
 * this server OR when it expires do to timeout.
 */
void
nqsrv_waitfor_expiry(lp)
	register struct nqlease *lp;
{
	register struct nqhost *lph;
	register int i;
	struct nqm *lphnext;
	int len, ok;

tryagain:
	if (time.tv_sec > lp->lc_expiry)
		return;
	lph = &lp->lc_host;
	lphnext = lp->lc_morehosts;
	len = 1;
	i = 0;
	ok = 1;
	while (ok && (lph->lph_flag & LC_VALID)) {
		if ((lph->lph_flag & (LC_LOCAL | LC_VACATED)) == 0) {
			lp->lc_flag |= LC_EXPIREDWANTED;
			(void) tsleep((caddr_t)&lp->lc_flag, PSOCK,
					"nqexp", 0);
			goto tryagain;
		}
		if (++i == len) {
			if (lphnext) {
				i = 0;
				len = LC_MOREHOSTSIZ;
				lph = lphnext->lpm_hosts;
				lphnext = lphnext->lpm_next;
			} else
				ok = 0;
		} else
			lph++;
	}
}

#ifdef NFSSERVER
/*
 * Nqnfs server timer that maintains the server lease queue.
 * Scan the lease queue for expired entries:
 * - when one is found, wakeup anyone waiting for it
 *   else dequeue and free
 */
void
nqnfs_serverd()
{
	register struct nqlease *lp;
	register struct nqhost *lph;
	struct nqlease *nextlp;
	struct nqm *lphnext, *olphnext;
	struct mbuf *n;
	int i, len, ok;

	for (lp = nqtimerhead.cqh_first; lp != (void *)&nqtimerhead;
	    lp = nextlp) {
		if (lp->lc_expiry >= time.tv_sec)
			break;
		nextlp = lp->lc_timer.cqe_next;
		if (lp->lc_flag & LC_EXPIREDWANTED) {
			lp->lc_flag &= ~LC_EXPIREDWANTED;
			wakeup((caddr_t)&lp->lc_flag);
		} else if ((lp->lc_flag & (LC_LOCKED | LC_WANTED)) == 0) {
		    /*
		     * Make a best effort at keeping a write caching lease long
		     * enough by not deleting it until it has been explicitly
		     * vacated or there have been no writes in the previous
		     * write_slack seconds since expiry and the nfsds are not
		     * all busy. The assumption is that if the nfsds are not
		     * all busy now (no queue of nfs requests), then the client
		     * would have been able to do at least one write to the
		     * file during the last write_slack seconds if it was still
		     * trying to push writes to the server.
		     */
		    if ((lp->lc_flag & (LC_WRITE | LC_VACATED)) == LC_WRITE &&
			((lp->lc_flag & LC_WRITTEN) || nfsd_waiting == 0)) {
			lp->lc_flag &= ~LC_WRITTEN;
			nqsrv_instimeq(lp, nqsrv_writeslack);
		    } else {
			CIRCLEQ_REMOVE(&nqtimerhead, lp, lc_timer);
			LIST_REMOVE(lp, lc_hash);
			lph = &lp->lc_host;
			lphnext = lp->lc_morehosts;
			olphnext = (struct nqm *)0;
			len = 1;
			i = 0;
			ok = 1;
			while (ok && (lph->lph_flag & LC_VALID)) {
				if (lph->lph_flag & LC_CLTP)
					MFREE(lph->lph_nam, n);
				if (lph->lph_flag & LC_SREF)
					nfsrv_slpderef(lph->lph_slp);
				if (++i == len) {
					if (olphnext) {
						free((caddr_t)olphnext, M_NQMHOST);
						olphnext = (struct nqm *)0;
					}
					if (lphnext) {
						olphnext = lphnext;
						i = 0;
						len = LC_MOREHOSTSIZ;
						lph = lphnext->lpm_hosts;
						lphnext = lphnext->lpm_next;
					} else
						ok = 0;
				} else
					lph++;
			}
			FREE((caddr_t)lp, M_NQLEASE);
			if (olphnext)
				free((caddr_t)olphnext, M_NQMHOST);
			nfsstats.srvnqnfs_leases--;
		    }
		}
	}
}

/*
 * Called from nfssvc_nfsd() for a getlease rpc request.
 * Do the from/to xdr translation and call nqsrv_getlease() to
 * do the real work.
 */
int
nqnfsrv_getlease(nfsd, slp, procp, mrq)
	struct nfsrv_descript *nfsd;
	struct nfssvc_sock *slp;
	struct proc *procp;
	struct mbuf **mrq;
{
	struct mbuf *mrep = nfsd->nd_mrep, *md = nfsd->nd_md;
	struct mbuf *nam = nfsd->nd_nam;
	caddr_t dpos = nfsd->nd_dpos;
	struct ucred *cred = &nfsd->nd_cr;
	register struct nfs_fattr *fp;
	struct vattr va;
	struct vnode *vp;
	nfsfh_t nfh;
	fhandle_t *fhp;
	register u_int32_t *tl;
	register int32_t t1;
	u_quad_t frev;
	caddr_t bpos;
	int error = 0;
	char *cp2;
	struct mbuf *mb, *mb2, *mreq;
	int flags, rdonly, cache;

	fhp = &nfh.fh_generic;
	nfsm_srvmtofh(fhp);
	nfsm_dissect(tl, u_int32_t *, 2 * NFSX_UNSIGNED);
	flags = fxdr_unsigned(int, *tl++);
	nfsd->nd_duration = fxdr_unsigned(int, *tl);
	error = nfsrv_fhtovp(fhp, 1, &vp, cred, slp, nam, &rdonly,
		(nfsd->nd_flag & ND_KERBAUTH));
	if (error)
		nfsm_reply(0);
	if (rdonly && flags == ND_WRITE) {
		vput(vp);
		error = EROFS;
		nfsm_reply(0);
	}
	(void) nqsrv_getlease(vp, &nfsd->nd_duration, flags, slp, procp,
		nam, &cache, &frev, cred);
	error = VOP_GETATTR(vp, &va, cred, procp);
	vput(vp);
	nfsm_reply(NFSX_V3FATTR + 4 * NFSX_UNSIGNED);
	nfsm_build(tl, u_int32_t *, 4 * NFSX_UNSIGNED);
	*tl++ = txdr_unsigned(cache);
	*tl++ = txdr_unsigned(nfsd->nd_duration);
	txdr_hyper(frev, tl);
	nfsm_build(fp, struct nfs_fattr *, NFSX_V3FATTR);
	nfsm_srvfillattr(&va, fp);
	nfsm_srvdone;
}

/*
 * Called from nfssvc_nfsd() when a "vacated" message is received from a
 * client. Find the entry and expire it.
 */
int
nqnfsrv_vacated(nfsd, slp, procp, mrq)
	struct nfsrv_descript *nfsd;
	struct nfssvc_sock *slp;
	struct proc *procp;
	struct mbuf **mrq;
{
	struct mbuf *mrep = nfsd->nd_mrep, *md = nfsd->nd_md;
	struct mbuf *nam = nfsd->nd_nam;
	caddr_t dpos = nfsd->nd_dpos;
	register struct nqlease *lp;
	register struct nqhost *lph;
	struct nqlease *tlp = (struct nqlease *)0;
	nfsfh_t nfh;
	fhandle_t *fhp;
	register u_int32_t *tl;
	register int32_t t1;
	struct nqm *lphnext;
	struct mbuf *mreq, *mb;
	int error = 0, i, len, ok, gotit = 0, cache = 0;
	char *cp2, *bpos;
	u_quad_t frev;

	fhp = &nfh.fh_generic;
	nfsm_srvmtofh(fhp);
	m_freem(mrep);
	/*
	 * Find the lease by searching the hash list.
	 */
	for (lp = NQFHHASH(fhp->fh_fid.fid_data)->lh_first; lp != 0;
	    lp = lp->lc_hash.le_next)
		if (fhp->fh_fsid.val[0] == lp->lc_fsid.val[0] &&
		    fhp->fh_fsid.val[1] == lp->lc_fsid.val[1] &&
		    !bcmp(fhp->fh_fid.fid_data, lp->lc_fiddata,
			  MAXFIDSZ)) {
			/* Found it */
			tlp = lp;
			break;
		}
	if (tlp != 0) {
		lp = tlp;
		len = 1;
		i = 0;
		lph = &lp->lc_host;
		lphnext = lp->lc_morehosts;
		ok = 1;
		while (ok && (lph->lph_flag & LC_VALID)) {
			if (nqsrv_cmpnam(slp, nam, lph)) {
				lph->lph_flag |= LC_VACATED;
				gotit++;
				break;
			}
			if (++i == len) {
				if (lphnext) {
					len = LC_MOREHOSTSIZ;
					i = 0;
					lph = lphnext->lpm_hosts;
					lphnext = lphnext->lpm_next;
				} else
					ok = 0;
			} else
				lph++;
		}
		if ((lp->lc_flag & LC_EXPIREDWANTED) && gotit) {
			lp->lc_flag &= ~LC_EXPIREDWANTED;
			wakeup((caddr_t)&lp->lc_flag);
		}
nfsmout:
		return (EPERM);
	}
	return (EPERM);
}
#endif /* NFSSERVER */

#ifdef NFSCLIENT
/*
 * Client get lease rpc function.
 */
int
nqnfs_getlease(vp, rwflag, cred, p)
	register struct vnode *vp;
	int rwflag;
	struct ucred *cred;
	struct proc *p;
{
	register u_int32_t *tl;
	register caddr_t cp;
	register int32_t t1, t2;
	register struct nfsnode *np;
	struct nfsmount *nmp = VFSTONFS(vp->v_mount);
	caddr_t bpos, dpos, cp2;
	time_t reqtime;
	int error = 0;
	struct mbuf *mreq, *mrep, *md, *mb, *mb2;
	int cachable;
	u_quad_t frev;

	nfsstats.rpccnt[NQNFSPROC_GETLEASE]++;
	mb = mreq = nfsm_reqh(vp, NQNFSPROC_GETLEASE, NFSX_V3FH+2*NFSX_UNSIGNED,
		 &bpos);
	nfsm_fhtom(vp, 1);
	nfsm_build(tl, u_int32_t *, 2 * NFSX_UNSIGNED);
	*tl++ = txdr_unsigned(rwflag);
	*tl = txdr_unsigned(nmp->nm_leaseterm);
	reqtime = time.tv_sec;
	nfsm_request(vp, NQNFSPROC_GETLEASE, p, cred);
	np = VTONFS(vp);
	nfsm_dissect(tl, u_int32_t *, 4 * NFSX_UNSIGNED);
	cachable = fxdr_unsigned(int, *tl++);
	reqtime += fxdr_unsigned(int, *tl++);
	if (reqtime > time.tv_sec) {
		frev = fxdr_hyper(tl);
		nqnfs_clientlease(nmp, np, rwflag, cachable, reqtime, frev);
		nfsm_loadattr(vp, (struct vattr *)0);
	} else
		error = NQNFS_EXPIRED;
	nfsm_reqdone;
	return (error);
}

/*
 * Client vacated message function.
 */
int
nqnfs_vacated(vp, cred)
	register struct vnode *vp;
	struct ucred *cred;
{
	register caddr_t cp;
	register struct mbuf *m;
	register int i;
	register u_int32_t *tl;
	register int32_t t2;
	caddr_t bpos;
	u_int32_t xid;
	int error = 0;
	struct mbuf *mreq, *mb, *mb2, *mheadend;
	struct nfsmount *nmp;
	struct nfsreq myrep;

	nmp = VFSTONFS(vp->v_mount);
	nfsstats.rpccnt[NQNFSPROC_VACATED]++;
	nfsm_reqhead(vp, NQNFSPROC_VACATED, NFSX_FH(1));
	nfsm_fhtom(vp, 1);
	m = mreq;
	i = 0;
	while (m) {
		i += m->m_len;
		m = m->m_next;
	}
	m = nfsm_rpchead(cred, nmp->nm_flag, NQNFSPROC_VACATED,
		RPCAUTH_UNIX, 5 * NFSX_UNSIGNED, (char *)0,
		0, (char *)0, mreq, i, &mheadend, &xid);
	if (nmp->nm_sotype == SOCK_STREAM) {
		M_PREPEND(m, NFSX_UNSIGNED, M_WAIT);
		*mtod(m, u_int32_t *) = htonl(0x80000000 | (m->m_pkthdr.len -
			NFSX_UNSIGNED));
	}
	myrep.r_flags = 0;
	myrep.r_nmp = nmp;
	if (nmp->nm_soflags & PR_CONNREQUIRED)
		(void) nfs_sndlock(&nmp->nm_flag, (struct nfsreq *)0);
	(void) nfs_send(nmp->nm_so, nmp->nm_nam, m, &myrep);
	if (nmp->nm_soflags & PR_CONNREQUIRED)
		nfs_sndunlock(&nmp->nm_flag);
nfsmout:
	return (error);
}

/*
 * Called for client side callbacks
 */
int
nqnfs_callback(nmp, mrep, md, dpos)
	struct nfsmount *nmp;
	struct mbuf *mrep, *md;
	caddr_t dpos;
{
	register struct vnode *vp;
	register u_int32_t *tl;
	register int32_t t1;
	nfsfh_t nfh;
	fhandle_t *fhp;
	struct nfsnode *np;
	struct nfsd tnfsd;
	struct nfssvc_sock *slp;
	struct nfsrv_descript ndesc;
	register struct nfsrv_descript *nfsd = &ndesc;
	struct mbuf **mrq = (struct mbuf **)0, *mb, *mreq;
	int error = 0, cache = 0;
	char *cp2, *bpos;
	u_quad_t frev;

#ifndef nolint
	slp = NULL;
#endif
	nfsd->nd_mrep = mrep;
	nfsd->nd_md = md;
	nfsd->nd_dpos = dpos;
	error = nfs_getreq(nfsd, &tnfsd, FALSE);
	if (error)
		return (error);
	md = nfsd->nd_md;
	dpos = nfsd->nd_dpos;
	if (nfsd->nd_procnum != NQNFSPROC_EVICTED) {
		m_freem(mrep);
		return (EPERM);
	}
	fhp = &nfh.fh_generic;
	nfsm_srvmtofh(fhp);
	m_freem(mrep);
	error = nfs_nget(nmp->nm_mountp, (nfsfh_t *)fhp, NFSX_V3FH, &np);
	if (error)
		return (error);
	vp = NFSTOV(np);
	if (np->n_timer.cqe_next != 0) {
		np->n_expiry = 0;
		np->n_flag |= NQNFSEVICTED;
		if (nmp->nm_timerhead.cqh_first != np) {
			CIRCLEQ_REMOVE(&nmp->nm_timerhead, np, n_timer);
			CIRCLEQ_INSERT_HEAD(&nmp->nm_timerhead, np, n_timer);
		}
	}
	vrele(vp);
	nfsm_srvdone;
}

/*
 * Nqnfs client helper daemon. Runs once a second to expire leases.
 * It also get authorization strings for "kerb" mounts.
 * It must start at the beginning of the list again after any potential
 * "sleep" since nfs_reclaim() called from vclean() can pull a node off
 * the list asynchronously.
 */
int
nqnfs_clientd(nmp, cred, ncd, flag, argp, p)
	register struct nfsmount *nmp;
	struct ucred *cred;
	struct nfsd_cargs *ncd;
	int flag;
	caddr_t argp;
	struct proc *p;
{
	register struct nfsnode *np;
	struct vnode *vp;
	struct nfsreq myrep;
	struct nfsuid *nuidp, *nnuidp;
	int error = 0, vpid;

	/*
	 * First initialize some variables
	 */

	/*
	 * If an authorization string is being passed in, get it.
	 */
	if ((flag & NFSSVC_GOTAUTH) &&
	    (nmp->nm_flag & (NFSMNT_WAITAUTH | NFSMNT_DISMNT)) == 0) {
	    if (nmp->nm_flag & NFSMNT_HASAUTH)
		panic("cld kerb");
	    if ((flag & NFSSVC_AUTHINFAIL) == 0) {
		if (ncd->ncd_authlen <= nmp->nm_authlen &&
		    ncd->ncd_verflen <= nmp->nm_verflen &&
		    !copyin(ncd->ncd_authstr,nmp->nm_authstr,ncd->ncd_authlen)&&
		    !copyin(ncd->ncd_verfstr,nmp->nm_verfstr,ncd->ncd_verflen)){
		    nmp->nm_authtype = ncd->ncd_authtype;
		    nmp->nm_authlen = ncd->ncd_authlen;
		    nmp->nm_verflen = ncd->ncd_verflen;
#ifdef NFSKERB
		    nmp->nm_key = ncd->ncd_key;
#endif
		} else
		    nmp->nm_flag |= NFSMNT_AUTHERR;
	    } else
		nmp->nm_flag |= NFSMNT_AUTHERR;
	    nmp->nm_flag |= NFSMNT_HASAUTH;
	    wakeup((caddr_t)&nmp->nm_authlen);
	} else
	    nmp->nm_flag |= NFSMNT_WAITAUTH;

	/*
	 * Loop every second updating queue until there is a termination sig.
	 */
	while ((nmp->nm_flag & NFSMNT_DISMNT) == 0) {
	    if (nmp->nm_flag & NFSMNT_NQNFS) {
		/*
		 * If there are no outstanding requests (and therefore no
		 * processes in nfs_reply) and there is data in the receive
		 * queue, poke for callbacks.
		 */
		if (nfs_reqq.tqh_first == 0 && nmp->nm_so &&
		    nmp->nm_so->so_rcv.sb_cc > 0) {
		    myrep.r_flags = R_GETONEREP;
		    myrep.r_nmp = nmp;
		    myrep.r_mrep = (struct mbuf *)0;
		    myrep.r_procp = (struct proc *)0;
		    (void) nfs_reply(&myrep);
		}

		/*
		 * Loop through the leases, updating as required.
		 */
		np = nmp->nm_timerhead.cqh_first;
		while (np != (void *)&nmp->nm_timerhead &&
		       (nmp->nm_flag & NFSMNT_DISMINPROG) == 0) {
			vp = NFSTOV(np);
			vpid = vp->v_id;
			if (np->n_expiry < time.tv_sec) {
			   if (vget(vp, LK_EXCLUSIVE, p) == 0) {
			     nmp->nm_inprog = vp;
			     if (vpid == vp->v_id) {
				CIRCLEQ_REMOVE(&nmp->nm_timerhead, np, n_timer);
				np->n_timer.cqe_next = 0;
				if (np->n_flag & (NMODIFIED | NQNFSEVICTED)) {
					if (np->n_flag & NQNFSEVICTED) {
						if (vp->v_type == VDIR) {
							np->n_direofoffset = 0;
						}
						cache_purge(vp);
						(void) nfs_vinvalbuf(vp,
						       V_SAVE, cred, p, 0);
						np->n_flag &= ~NQNFSEVICTED;
						(void) nqnfs_vacated(vp, cred);
					} else if (vp->v_type == VREG) {
						(void) VOP_FSYNC(vp, cred,
						    MNT_WAIT, p);
						np->n_flag &= ~NMODIFIED;
					}
				}
			      }
			      vrele(vp);
			      nmp->nm_inprog = NULLVP;
			    }
			} else if ((np->n_expiry - NQ_RENEWAL) < time.tv_sec) {
			    if ((np->n_flag & (NQNFSWRITE | NQNFSNONCACHE))
				 == NQNFSWRITE && vp->v_dirtyblkhd.lh_first &&
				 vget(vp, LK_EXCLUSIVE, p) == 0) {
				 nmp->nm_inprog = vp;
				 if (vpid == vp->v_id &&
				     nqnfs_getlease(vp, ND_WRITE, cred, p)==0)
					np->n_brev = np->n_lrev;
				 vrele(vp);
				 nmp->nm_inprog = NULLVP;
			    }
			} else
				break;
			if (np == nmp->nm_timerhead.cqh_first)
				break;
			np = nmp->nm_timerhead.cqh_first;
		}
	    }

	    /*
	     * Get an authorization string, if required.
	     */
	    if ((nmp->nm_flag & (NFSMNT_WAITAUTH | NFSMNT_DISMNT | NFSMNT_HASAUTH)) == 0) {
		ncd->ncd_authuid = nmp->nm_authuid;
		if (copyout((caddr_t)ncd, argp, sizeof (struct nfsd_cargs)))
			nmp->nm_flag |= NFSMNT_WAITAUTH;
		else
			return (ENEEDAUTH);
	    }

	    /*
	     * Wait a bit (no pun) and do it again.
	     */
	    if ((nmp->nm_flag & NFSMNT_DISMNT) == 0 &&
		(nmp->nm_flag & (NFSMNT_WAITAUTH | NFSMNT_HASAUTH))) {
		    error = tsleep((caddr_t)&nmp->nm_authstr, PSOCK | PCATCH,
			"nqnfstimr", hz / 3);
		    if (error == EINTR || error == ERESTART)
			(void) dounmount(nmp->nm_mountp, MNT_FORCE, p);
	    }
	}

	/*
	 * Finally, we can free up the mount structure.
	 */
	for (nuidp = nmp->nm_uidlruhead.tqh_first; nuidp != 0; nuidp = nnuidp) {
		nnuidp = nuidp->nu_lru.tqe_next;
		LIST_REMOVE(nuidp, nu_hash);
		TAILQ_REMOVE(&nmp->nm_uidlruhead, nuidp, nu_lru);
		free((caddr_t)nuidp, M_NFSUID);
	}
	free((caddr_t)nmp, M_NFSMNT);
	if (error == EWOULDBLOCK)
		error = 0;
	return (error);
}

/*
 * Update a client lease.
 */
void
nqnfs_clientlease(nmp, np, rwflag, cachable, expiry, frev)
	register struct nfsmount *nmp;
	register struct nfsnode *np;
	int rwflag, cachable;
	time_t expiry;
	u_quad_t frev;
{
	register struct nfsnode *tp;

	if (np->n_timer.cqe_next != 0) {
		CIRCLEQ_REMOVE(&nmp->nm_timerhead, np, n_timer);
		if (rwflag == ND_WRITE)
			np->n_flag |= NQNFSWRITE;
	} else if (rwflag == ND_READ)
		np->n_flag &= ~NQNFSWRITE;
	else
		np->n_flag |= NQNFSWRITE;
	if (cachable)
		np->n_flag &= ~NQNFSNONCACHE;
	else
		np->n_flag |= NQNFSNONCACHE;
	np->n_expiry = expiry;
	np->n_lrev = frev;
	tp = nmp->nm_timerhead.cqh_last;
	while (tp != (void *)&nmp->nm_timerhead && tp->n_expiry > np->n_expiry)
		tp = tp->n_timer.cqe_prev;
	if (tp == (void *)&nmp->nm_timerhead) {
		CIRCLEQ_INSERT_HEAD(&nmp->nm_timerhead, np, n_timer);
	} else {
		CIRCLEQ_INSERT_AFTER(&nmp->nm_timerhead, tp, np, n_timer);
	}
}
#endif /* NFSCLIENT */

/*
 * Adjust all timer queue expiry times when the time of day clock is changed.
 * Called from the settimeofday() syscall.
 */
void
nqnfs_lease_updatetime(deltat)
	register int deltat;
{
	register struct nqlease *lp;
	register struct nfsnode *np;
	struct mount *mp;
	struct nfsmount *nmp;
	int s;
	struct proc *p = curproc;	/* XXX */
	struct mount *nxtmp;

	if (nqnfsstarttime != 0)
		nqnfsstarttime += deltat;
	s = splsoftclock();
	for (lp = nqtimerhead.cqh_first; lp != (void *)&nqtimerhead;
	    lp = lp->lc_timer.cqe_next)
		lp->lc_expiry += deltat;
	splx(s);

	/*
	 * Search the mount list for all nqnfs mounts and do their timer
	 * queues.
	 */
	simple_lock(&mountlist_slock);
	for (mp = mountlist.cqh_first; mp != (void *)&mountlist; mp = nxtmp) {
		if (vfs_busy(mp, LK_NOWAIT, &mountlist_slock, p)) {
			nxtmp = mp->mnt_list.cqe_next;
			continue;
		}
		if (!strncmp(&mp->mnt_stat.f_fstypename[0], MOUNT_NFS,
		    MFSNAMELEN)) {
			nmp = VFSTONFS(mp);
			if (nmp->nm_flag & NFSMNT_NQNFS) {
				for (np = nmp->nm_timerhead.cqh_first;
				    np != (void *)&nmp->nm_timerhead;
				    np = np->n_timer.cqe_next) {
					np->n_expiry += deltat;
				}
			}
		}
		simple_lock(&mountlist_slock);
		nxtmp = mp->mnt_list.cqe_next;
		vfs_unbusy(mp, p);
	}
	simple_unlock(&mountlist_slock);
}

/*
 * Lock a server lease.
 */
void
nqsrv_locklease(lp)
	struct nqlease *lp;
{

	while (lp->lc_flag & LC_LOCKED) {
		lp->lc_flag |= LC_WANTED;
		(void) tsleep((caddr_t)lp, PSOCK, "nqlc", 0);
	}
	lp->lc_flag |= LC_LOCKED;
	lp->lc_flag &= ~LC_WANTED;
}

/*
 * Unlock a server lease.
 */
void
nqsrv_unlocklease(lp)
	struct nqlease *lp;
{

	lp->lc_flag &= ~LC_LOCKED;
	if (lp->lc_flag & LC_WANTED)
		wakeup((caddr_t)lp);
}
@


1.16
log
@
Get rid of old directory caching scheme which caused persistent duplicates.

Still not correct for NFSv3 but that's hard.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_nqlease.c,v 1.15 2001/02/24 19:07:11 csapuntz Exp $	*/
@


1.15
log
@

Cleanup of vnode interface continues. Get rid of VHOLD/HOLDRELE.
Change VM/UVM to use buf_replacevnode to change the vnode associated
with a buffer.

Addition v_bioflag for flags written in interrupt handlers
(and read at splbio, though not strictly necessary)

Add vwaitforio and use it instead of a while loop of v_numoutput.

Fix race conditions when manipulation vnode free list
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_nqlease.c,v 1.14 1999/02/06 23:07:40 millert Exp $	*/
d1049 3
a1051 2
						if (vp->v_type == VDIR)
							nfs_invaldir(vp);
@


1.14
log
@Use bitwise operations to extract high and low words from the quad
in txdr_hyper.  This should be more portable than casting to an array
of ints and pulling out the two 32-bit words (this produced incorrect
results on alpha for the high word for filesystems < 4gig).  As a side
effect, txdr_hyper now takes a u_quad_t as its first arg, not u_quad_t *.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_nqlease.c,v 1.13 1998/08/19 22:26:51 csapuntz Exp $	*/
d182 1
a182 1
	tlp = vp->v_lease;
a202 1
				vp->v_lease = lp;
a300 1
	vp->v_lease = lp;
a635 7
			/*
			 * This soft reference may no longer be valid, but
			 * no harm done. The worst case is if the vnode was
			 * recycled and has another valid lease reference,
			 * which is dereferenced prematurely.
			 */
			lp->lc_vp->v_lease = (struct nqlease *)0;
@


1.14.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_nqlease.c,v 1.15 2001/02/24 19:07:11 csapuntz Exp $	*/
d182 1
a182 1
	tlp = 0;
d203 1
d302 1
d638 7
@


1.14.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_nqlease.c,v 1.14.6.1 2001/05/14 22:44:57 niklas Exp $	*/
@


1.13
log
@

Change fxdr_hyper to return a u_quad_t. This minimizes the evil clobbering
of lvalues that ANSI abhors.

And it fixes df on NFS version 3 mounts on Sparcs.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_nqlease.c,v 1.12 1997/11/06 05:59:01 csapuntz Exp $	*/
d733 1
a733 1
	txdr_hyper(&frev, tl);
@


1.12
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_nqlease.c,v 1.11 1997/10/06 20:20:46 deraadt Exp $	*/
d854 1
a854 1
		fxdr_hyper(tl, &frev);
@


1.11
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_nqlease.c,v 1.9 1997/04/18 10:13:23 deraadt Exp $	*/
a1050 1
#ifdef Lite2_integrated
a1051 3
#else
			   if (vget(vp, 1) == 0) {
#endif
a1077 1
#ifdef Lite2_integrated
a1078 3
#else
				 vget(vp, 1) == 0) {
#endif
a1182 1
#ifdef Lite2_integrated
a1184 1
#endif
a1197 1
#ifdef Lite2_integrated
a1219 16
#else /* Lite2_integrated */
	for (mp = mountlist.cqh_first; mp != (void *)&mountlist;
	     mp = mp->mnt_list.cqe_next) {
		if (!strncmp(&mp->mnt_stat.f_fstypename[0], MOUNT_NFS,
		    MFSNAMELEN)) {
			nmp = VFSTONFS(mp);
			if (nmp->nm_flag & NFSMNT_NQNFS) {
				for (np = nmp->nm_timerhead.cqh_first;
				    np != (void *)&nmp->nm_timerhead;
				    np = np->n_timer.cqe_next) {
					np->n_expiry += deltat;
				}
			}
		}
	}
#endif
@


1.10
log
@VFS Lite2 Changes
@
text
@d1051 1
d1053 3
d1082 1
d1084 3
d1191 1
d1194 1
d1208 1
d1231 16
@


1.9
log
@cleanup -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_nqlease.c,v 1.8 1997/04/18 10:02:36 deraadt Exp $	*/
a1050 1
#ifdef Lite2_integrated
a1051 3
#else
			   if (vget(vp, 1) == 0) {
#endif
a1077 1
#ifdef Lite2_integrated
a1078 3
#else
				 vget(vp, 1) == 0) {
#endif
a1182 1
#ifdef Lite2_integrated
a1184 1
#endif
a1197 1
#ifdef Lite2_integrated
a1219 16
#else /* Lite2_integrated */
	for (mp = mountlist.cqh_first; mp != (void *)&mountlist;
	     mp = mp->mnt_list.cqe_next) {
		if (!strncmp(&mp->mnt_stat.f_fstypename[0], MOUNT_NFS,
		    MFSNAMELEN)) {
			nmp = VFSTONFS(mp);
			if (nmp->nm_flag & NFSMNT_NQNFS) {
				for (np = nmp->nm_timerhead.cqh_first;
				    np != (void *)&nmp->nm_timerhead;
				    np = np->n_timer.cqe_next) {
					np->n_expiry += deltat;
				}
			}
		}
	}
#endif
@


1.8
log
@Fix some bugs in NQNFS (malformed RPC requests, no directory lease eviction);
fvdl
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_nqlease.c,v 1.7 1996/06/01 04:43:58 mickey Exp $	*/
d68 1
@


1.7
log
@allow client-only kernel to be compiled.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_nqlease.c,v 1.5 1996/04/17 04:50:26 mickey Exp $	*/
d459 1
d462 1
a462 1
	u_int32_t xid;
d493 3
a495 4
				NFSX_V3FH);
			nfsm_build(cp, caddr_t, NFSX_V3FH);
			bzero(cp, NFSX_V3FH);
			fhp = (fhandle_t *)cp;
d498 1
d838 1
a838 1
	
d881 1
a881 1
	
d884 1
a884 1
	nfsm_reqhead(vp, NQNFSPROC_VACATED, NFSX_V3FH);
d1059 1
a1059 2
				if ((np->n_flag & (NMODIFIED | NQNFSEVICTED))
				    && vp->v_type == VREG) {
d1061 3
d1068 1
a1068 1
					} else {
@


1.6
log
@partial sync with netbsd 960418, more to come
@
text
@d122 1
a122 1
extern struct nfsstats nfsstats;
@


1.5
log
@Minor cleanups. Checked against Lite2.
(NetBSD's was really just a Lite2's, but w/ 64bit support)
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_nqlease.c,v 1.4 1996/03/31 13:15:38 mickey Exp $	*/
d184 1
a184 1
	if (tlp == NULL) {
d208 1
a208 1
	if (lp != NULL) {
d210 1
a210 1
		    (lp->lc_morehosts == NULL &&
d330 1
a330 1
	    NQLOCALSLP, ap->a_p, (struct mbuf *)NULL, &cache, &frev, ap->a_cred);
d376 1
a376 1
	if (lp->lc_timer.cqe_next != NULL)
d482 1
a482 1
				nam2 = (struct mbuf *)NULL;
d490 2
a491 2
				solockp = (int *)NULL;
			nfsm_reqhead((struct vnode *)NULL, NQNFSPROC_EVICTED,
d510 2
a511 2
				RPCAUTH_UNIX, 5 * NFSX_UNSIGNED, NULL,
				0, NULL, mreq, siz, &mheadend, &xid);
d529 1
a529 1
						(struct nfsreq *)NULL);
d642 1
a642 1
			lp->lc_vp->v_lease = (struct nqlease *)NULL;
d645 1
a645 1
			olphnext = (struct nqm *)NULL;
d657 1
a657 1
						olphnext = (struct nqm *)NULL;
d753 1
a753 1
	struct nqlease *tlp = NULL;
d780 1
a780 1
	if (tlp != NULL) {
d854 1
a854 1
		nfsm_loadattr(vp, (struct vattr *)NULL);
d892 2
a893 2
		RPCAUTH_UNIX, 5 * NFSX_UNSIGNED, NULL,
		0, NULL, mreq, i, &mheadend, &xid);
d902 1
a902 1
		(void) nfs_sndlock(&nmp->nm_flag, (struct nfsreq *)NULL);
d929 1
a929 1
	struct mbuf **mrq = NULL, *mb, *mreq;
d1035 2
a1036 2
		    myrep.r_mrep = (struct mbuf *)NULL;
		    myrep.r_procp = (struct proc *)NULL;
@


1.4
log
@From NetBSD: NFSv3 import (tomorrow's Net's kernel)
Open's patches kept in. i'll possibly take a look at Lite2 soon,
is there smth usefull ?..
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_nqlease.c,v 1.3 1996/02/29 09:24:51 niklas Exp $	*/
d184 1
a184 1
	if (tlp == 0) {
d208 1
a208 1
	if (lp != 0) {
d210 1
a210 1
		    (lp->lc_morehosts == (struct nqm *)0 &&
d330 1
a330 1
	    NQLOCALSLP, ap->a_p, (struct mbuf *)0, &cache, &frev, ap->a_cred);
d376 1
a376 1
	if (lp->lc_timer.cqe_next != 0)
d482 1
a482 1
				nam2 = (struct mbuf *)0;
d490 2
a491 2
				solockp = (int *)0;
			nfsm_reqhead((struct vnode *)0, NQNFSPROC_EVICTED,
d510 2
a511 2
				RPCAUTH_UNIX, 5 * NFSX_UNSIGNED, (char *)0,
				0, (char *)0, mreq, siz, &mheadend, &xid);
d529 1
a529 1
						(struct nfsreq *)0);
d642 1
a642 1
			lp->lc_vp->v_lease = (struct nqlease *)0;
d645 1
a645 1
			olphnext = (struct nqm *)0;
d657 1
a657 1
						olphnext = (struct nqm *)0;
d753 1
a753 1
	struct nqlease *tlp = (struct nqlease *)0;
d780 1
a780 1
	if (tlp != 0) {
d854 1
a854 1
		nfsm_loadattr(vp, (struct vattr *)0);
d892 2
a893 2
		RPCAUTH_UNIX, 5 * NFSX_UNSIGNED, (char *)0,
		0, (char *)0, mreq, i, &mheadend, &xid);
d902 1
a902 1
		(void) nfs_sndlock(&nmp->nm_flag, (struct nfsreq *)0);
d929 1
a929 1
	struct mbuf **mrq = (struct mbuf **)0, *mb, *mreq;
d1035 2
a1036 2
		    myrep.r_mrep = (struct mbuf *)0;
		    myrep.r_procp = (struct proc *)0;
@


1.3
log
@From NetBSD: merge with 960217 (still NFSv2)
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: nfs_nqlease.c,v 1.12 1996/02/09 21:48:26 christos Exp $	*/
d39 1
a39 1
 *	@@(#)nfs_nqlease.c	8.5 (Berkeley) 8/18/94
d71 1
a71 1
#include <nfs/nfsv2.h>
a80 1
u_int32_t nqnfs_prog, nqnfs_vers;
a90 2
	NQL_READ,
	NQL_WRITE,
d92 2
a93 3
	NQL_READ,
	NQL_READ,
	NQL_READ,
d95 3
a97 1
	NQL_WRITE,
a104 1
	NQL_READ,
d106 6
a111 1
	NQL_READ,
d118 2
a119 1
extern nfstype nfs_type[9];
d122 2
d129 1
a129 1
 * Get or check for a lease for "vp", based on NQL_CHECK flag.
d152 1
a152 1
nqsrv_getlease(vp, duration, flags, nd, nam, cachablep, frev, cred)
d154 1
a154 1
	u_int *duration;
d156 2
a157 1
	struct nfsd *nd;
d176 2
a177 1
	if ((error = VOP_GETATTR(vp, &vattr, cred, nd->nd_procp)) != 0)
d182 1
a182 1
	if ((flags & NQL_CHECK) == 0)
d189 2
a190 1
		if ((error = VFS_VPTOFH(vp, &fh.fh_fid)) != 0) {
d211 1
a211 1
		     nqsrv_cmpnam(nd->nd_slp, nam, &lp->lc_host)))
d213 2
a214 2
		if ((flags & NQL_READ) && (lp->lc_flag & LC_WRITE) == 0) {
			if (flags & NQL_CHECK)
d216 1
a216 1
			if (nqsrv_cmpnam(nd->nd_slp, nam, &lp->lc_host))
d228 1
a228 1
				if (nqsrv_cmpnam(nd->nd_slp, nam, lph))
d248 1
a248 1
			nqsrv_addhost(lph, nd->nd_slp, nam);
d253 1
a253 1
			nqsrv_send_eviction(vp, lp, nd->nd_slp, nam, cred);
d261 1
a261 1
		if ((flags & NQL_CHECK) == 0)
d267 1
a267 1
			if (flags & NQL_WRITE)
d274 1
a274 1
	if (flags & NQL_CHECK)
d291 1
a291 1
	if (flags & NQL_WRITE)
d293 1
a293 1
	nqsrv_addhost(&lp->lc_host, nd->nd_slp, nam);
d298 2
d316 1
a316 1
lease_check(v)
d325 2
a326 2
	int duration = 0, cache;
	struct nfsd nfsd;
d329 3
a331 5
	nfsd.nd_slp = NQLOCALSLP;
	nfsd.nd_procp = ap->a_p;
	(void) nqsrv_getlease(ap->a_vp, &duration, NQL_CHECK | ap->a_flag,
		&nfsd, (struct mbuf *)0, &cache, &frev, ap->a_cred);
	return 0;
d368 1
a368 1
	u_long duration;
d386 1
d389 1
d492 3
a494 3
				NFSX_FH);
			nfsm_build(cp, caddr_t, NFSX_FH);
			bzero(cp, NFSX_FH);
d508 4
a511 3
			m = nfsm_rpchead(cred, TRUE, NQNFSPROC_EVICTED,
				RPCAUTH_UNIX, 5*NFSX_UNSIGNED, (char *)0,
				mreq, siz, &mheadend, &xid);
d685 5
a689 6
nqnfsrv_getlease(nfsd, mrep, md, dpos, cred, nam, mrq)
	struct nfsd *nfsd;
	struct mbuf *mrep, *md;
	caddr_t dpos;
	struct ucred *cred;
	struct mbuf *nam, **mrq;
d691 5
a695 1
	register struct nfsv2_fattr *fp;
d698 1
a698 1
	nfsv2fh_t nfh;
d711 1
a711 1
	nfsm_dissect(tl, u_int32_t *, 2*NFSX_UNSIGNED);
d714 2
a715 2
	error = nfsrv_fhtovp(fhp,
			     TRUE, &vp, cred, nfsd->nd_slp, nam, &rdonly);
d718 2
a719 1
	if (rdonly && flags == NQL_WRITE) {
d723 1
a723 1
	(void) nqsrv_getlease(vp, &nfsd->nd_duration, flags, nfsd,
d725 1
a725 1
	error = VOP_GETATTR(vp, &va, cred, nfsd->nd_procp);
d727 2
a728 2
	nfsm_reply(NFSX_NQFATTR + 4*NFSX_UNSIGNED);
	nfsm_build(tl, u_int32_t *, 4*NFSX_UNSIGNED);
d732 2
a733 2
	nfsm_build(fp, struct nfsv2_fattr *, NFSX_NQFATTR);
	nfsm_srvfillattr;
d742 5
a746 6
nqnfsrv_vacated(nfsd, mrep, md, dpos, cred, nam, mrq)
	struct nfsd *nfsd;
	struct mbuf *mrep, *md;
	caddr_t dpos;
	struct ucred *cred;
	struct mbuf *nam, **mrq;
d748 3
d754 1
a754 1
	nfsv2fh_t nfh;
d759 4
a762 2
	int error = 0, i, len, ok, gotit = 0;
	char *cp2;
d788 1
a788 1
			if (nqsrv_cmpnam(nfsd->nd_slp, nam, lph)) {
d828 1
a828 1
	register int32_t t1;
d839 1
a839 1
	mb = mreq = nfsm_reqh(vp, NQNFSPROC_GETLEASE, NFSX_FH+2*NFSX_UNSIGNED,
d841 2
a842 2
	nfsm_fhtom(vp);
	nfsm_build(tl, u_int32_t *, 2*NFSX_UNSIGNED);
d848 1
a848 1
	nfsm_dissect(tl, u_int32_t *, 4*NFSX_UNSIGNED);
d872 2
d883 2
a884 2
	nfsm_reqhead(vp, NQNFSPROC_VACATED, NFSX_FH);
	nfsm_fhtom(vp);
d891 3
a893 3
	m = nfsm_rpchead(cred, TRUE, NQNFSPROC_VACATED,
		RPCAUTH_UNIX, 5*NFSX_UNSIGNED, (char *)0,
		mreq, i, &mheadend, &xid);
d906 1
d922 1
a922 1
	nfsv2fh_t nfh;
d925 8
a932 3
	struct nfsd nd;
	int error;
	char *cp2;
d934 8
a941 4
	nd.nd_mrep = mrep;
	nd.nd_md = md;
	nd.nd_dpos = dpos;
	if ((error = nfs_getreq(&nd, FALSE)) != 0)
d943 3
a945 3
	md = nd.nd_md;
	dpos = nd.nd_dpos;
	if (nd.nd_procnum != NQNFSPROC_EVICTED) {
d952 1
a952 1
	error = nfs_nget(nmp->nm_mountp, (nfsv2fh_t *) fhp, &np);
d987 1
a992 2
	nqnfs_prog = txdr_unsigned(NQNFS_PROG);
	nqnfs_vers = txdr_unsigned(NQNFS_VER1);
d998 14
a1011 11
		(nmp->nm_flag & (NFSMNT_WAITAUTH | NFSMNT_DISMNT)) == 0) {
		if (nmp->nm_flag & NFSMNT_HASAUTH)
			panic("cld kerb");
		if ((flag & NFSSVC_AUTHINFAIL) == 0) {
			if (ncd->ncd_authlen <= RPCAUTH_MAXSIZ &&
				copyin(ncd->ncd_authstr, nmp->nm_authstr,
				ncd->ncd_authlen) == 0) {
				nmp->nm_authtype = ncd->ncd_authtype;
				nmp->nm_authlen = ncd->ncd_authlen;
			} else
				nmp->nm_flag |= NFSMNT_AUTHERR;
d1013 5
a1017 3
			nmp->nm_flag |= NFSMNT_AUTHERR;
		nmp->nm_flag |= NFSMNT_HASAUTH;
		wakeup((caddr_t)&nmp->nm_authlen);
d1019 1
a1019 1
		nmp->nm_flag |= NFSMNT_WAITAUTH;
a1046 2
if (strncmp(&vp->v_mount->mnt_stat.f_fstypename[0], MOUNT_NFS, MFSNAMELEN))
	panic("trash2");
d1049 3
d1053 1
a1055 2
if (strncmp(&vp->v_mount->mnt_stat.f_fstypename[0], MOUNT_NFS, MFSNAMELEN))
	panic("trash3");
d1078 3
d1082 1
a1083 1
if (strncmp(&vp->v_mount->mnt_stat.f_fstypename[0], MOUNT_NFS, MFSNAMELEN)) panic("trash4");
d1085 1
a1085 1
				     nqnfs_getlease(vp, NQL_WRITE, cred, p)==0)
d1120 10
d1151 1
a1151 1
		if (rwflag == NQL_WRITE)
d1153 1
a1153 1
	} else if (rwflag == NQL_READ)
d1179 1
a1179 1
lease_updatetime(deltat)
d1187 4
d1204 24
d1242 1
@


1.2
log
@from cgd; handle 64-bit pointers and longs
@
text
@d1 2
a2 1
/*	$NetBSD: nfs_nqlease.c,v 1.11 1995/12/19 23:07:29 cgd Exp $	*/
d78 1
a85 5
void nqsrv_instimeq(), nqsrv_send_eviction(), nfs_sndunlock();
void nqsrv_unlocklease(), nqsrv_waitfor_expiry(), nfsrv_slpderef();
void nqsrv_addhost(), nqsrv_locklease(), nqnfs_serverd();
void nqnfs_clientlease();
struct mbuf *nfsm_rpchead();
d146 1
d158 2
a159 2
	register struct nqfhhashhead *lpp;
	register struct nqhost *lph;
d170 1
a170 1
	if (error = VOP_GETATTR(vp, &vattr, cred, nd->nd_procp))
d182 1
a182 1
		if (error = VFS_VPTOFH(vp, &fh.fh_fid)) {
d305 4
a308 1
lease_check(ap)
d314 1
a314 2
	} */ *ap;
{
d323 1
d393 1
d591 1
a591 1
	register struct nqlease *lp, *lq;
d673 1
d700 3
a702 2
	if (error = nfsrv_fhtovp(fhp,
	    TRUE, &vp, cred, nfsd->nd_slp, nam, &rdonly))
d726 1
d800 1
d845 1
d891 1
d910 1
a910 1
	if (error = nfs_getreq(&nd, FALSE))
d921 2
a922 1
	if (error = nfs_nget(nmp->nm_mountp, fhp, &np))
d944 1
d956 1
a956 1
	int error, vpid;
d1012 2
a1013 1
if (strncmp(&vp->v_mount->mnt_stat.f_fstypename[0], MOUNT_NFS, MFSNAMELEN)) panic("trash2");
d1019 2
a1020 1
if (strncmp(&vp->v_mount->mnt_stat.f_fstypename[0], MOUNT_NFS, MFSNAMELEN)) panic("trash3");
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: nfs_nqlease.c,v 1.10 1995/06/18 14:48:01 cgd Exp $	*/
d79 1
a79 1
u_long nqnfs_prog, nqnfs_vers;
d151 1
a151 1
	u_long *duration;
d193 1
a193 1
				  fh.fh_fid.fid_len - sizeof (long))) {
d291 1
a291 1
	    fh.fh_fid.fid_len - sizeof (long));
d449 1
a449 1
	u_long xid;
d505 1
a505 1
				*mtod(m, u_long *) = htonl(0x80000000 |
d683 2
a684 2
	register u_long *tl;
	register long t1;
d694 1
a694 1
	nfsm_dissect(tl, u_long *, 2*NFSX_UNSIGNED);
d709 1
a709 1
	nfsm_build(tl, u_long *, 4*NFSX_UNSIGNED);
d734 2
a735 2
	register u_long *tl;
	register long t1;
d801 1
a801 1
	register u_long *tl;
d803 1
a803 1
	register long t1;
d817 1
a817 1
	nfsm_build(tl, u_long *, 2*NFSX_UNSIGNED);
d823 1
a823 1
	nfsm_dissect(tl, u_long *, 4*NFSX_UNSIGNED);
d847 1
a847 1
	u_long xid;
d868 1
a868 1
		*mtod(m, u_long *) = htonl(0x80000000 | (m->m_pkthdr.len -
d890 2
a891 2
	register u_long *tl;
	register long t1;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
