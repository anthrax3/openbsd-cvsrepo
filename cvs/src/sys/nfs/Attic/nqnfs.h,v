head	1.5;
access;
symbols
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	UBC_SYNC_A:1.5
	UBC_SYNC_B:1.5
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.22
	OPENBSD_2_8:1.4.0.20
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.18
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.16
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.14
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.12
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.10
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.8
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.6
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2001.06.25.03.28.16;	author csapuntz;	state dead;
branches;
next	1.4;

1.4
date	96.04.17.04.50.42;	author mickey;	state Exp;
branches
	1.4.16.1;
next	1.3;

1.3
date	96.03.31.13.16.22;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	95.12.21.14.42.31;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.23;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.23;	author deraadt;	state Exp;
branches;
next	;

1.4.16.1
date	2001.07.04.10.55.55;	author niklas;	state dead;
branches;
next	;


desc
@@


1.5
log
@Remove NQNFS
@
text
@/*	$OpenBSD: nqnfs.h,v 1.4 1996/04/17 04:50:42 mickey Exp $	*/
/*	$NetBSD: nqnfs.h,v 1.6 1996/02/18 11:54:10 fvdl Exp $	*/

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Rick Macklem at The University of Guelph.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)nqnfs.h	8.3 (Berkeley) 3/30/95
 */


#ifndef _NFS_NQNFS_H_
#define _NFS_NQNFS_H_

/*
 * Definitions for NQNFS (Not Quite NFS) cache consistency protocol.
 */

/* Tunable constants */
#define	NQ_CLOCKSKEW	3	/* Clock skew factor (sec) */
#define	NQ_WRITESLACK	5	/* Delay for write cache flushing */
#define	NQ_MAXLEASE	60	/* Max lease duration (sec) */
#define	NQ_MINLEASE	5	/* Min lease duration (sec) */
#define	NQ_DEFLEASE	30	/* Default lease duration (sec) */
#define	NQ_RENEWAL	3	/* Time before expiry (sec) to renew */
#define	NQ_TRYLATERDEL	15	/* Initial try later delay (sec) */
#define	NQ_MAXNUMLEASE	2048	/* Upper bound on number of server leases */
#define	NQ_DEADTHRESH	NQ_NEVERDEAD	/* Default nm_deadthresh */
#define	NQ_NEVERDEAD	9	/* Greater than max. nm_timeouts */
#define	NQLCHSZ		256	/* Server hash table size */

#define	NQNFS_PROG	300105	/* As assigned by Sun */
#define	NQNFS_VER3	3
#define	NQNFS_EVICTSIZ	156	/* Size of eviction request in bytes */

/*
 * Definitions used for saving the "last lease expires" time in Non-volatile
 * RAM on the server. The default definitions below assume that NOVRAM is not
 * available.
 */
#ifdef HASNVRAM
#  undef HASNVRAM
#endif
#define	NQSTORENOVRAM(t)
#define	NQLOADNOVRAM(t)

/*
 * Defn and structs used on the server to maintain state for current leases.
 * The list of host(s) that hold the lease are kept as nqhost structures.
 * The first one lives in nqlease and any others are held in a linked
 * list of nqm structures hanging off of nqlease.
 *
 * Each nqlease structure is chained into two lists. The first is a list
 * ordered by increasing expiry time for nqsrv_timer() and the second is a chain
 * hashed on lc_fh.
 */
#define	LC_MOREHOSTSIZ	10

struct nqhost {
	union {
		struct {
			u_int16_t udp_flag;
			u_int16_t	udp_port;
			union nethostaddr udp_haddr;
		} un_udp;
		struct {
			u_int16_t connless_flag;
			u_int16_t connless_spare;
			union nethostaddr connless_haddr;
		} un_connless;
		struct {
			u_int16_t conn_flag;
			u_int16_t conn_spare;
			struct nfssvc_sock *conn_slp;
		} un_conn;
	} lph_un;
};
#define	lph_flag	lph_un.un_udp.udp_flag
#define	lph_port	lph_un.un_udp.udp_port
#define	lph_haddr	lph_un.un_udp.udp_haddr
#define	lph_inetaddr	lph_un.un_udp.udp_haddr.had_inetaddr
#define	lph_claddr	lph_un.un_connless.connless_haddr
#define	lph_nam		lph_un.un_connless.connless_haddr.had_nam
#define	lph_slp		lph_un.un_conn.conn_slp

struct nqlease {
	LIST_ENTRY(nqlease) lc_hash;	/* Fhandle hash list */
	CIRCLEQ_ENTRY(nqlease) lc_timer; /* Timer queue list */
	time_t		lc_expiry;	/* Expiry time (sec) */
	struct nqhost	lc_host;	/* Host that got lease */
	struct nqm	*lc_morehosts;	/* Other hosts that share read lease */
	fsid_t		lc_fsid;	/* Fhandle */
	char		lc_fiddata[MAXFIDSZ];
	struct vnode	*lc_vp;		/* Soft reference to associated vnode */
};
#define	lc_flag		lc_host.lph_un.un_udp.udp_flag

/* lc_flag bits */
#define	LC_VALID	0x0001	/* Host address valid */
#define	LC_WRITE	0x0002	/* Write cache */
#define	LC_NONCACHABLE	0x0004	/* Non-cachable lease */
#define	LC_LOCKED	0x0008	/* Locked */
#define	LC_WANTED	0x0010	/* Lock wanted */
#define	LC_EXPIREDWANTED 0x0020	/* Want lease when expired */
#define	LC_UDP		0x0040	/* Host address for udp socket */
#define	LC_CLTP		0x0080	/* Host address for other connectionless */
#define	LC_LOCAL	0x0100	/* Host is server */
#define	LC_VACATED	0x0200	/* Host has vacated lease */
#define	LC_WRITTEN	0x0400	/* Recently wrote to the leased file */
#define	LC_SREF		0x0800	/* Holds a nfssvc_sock reference */

struct nqm {
	struct nqm	*lpm_next;
	struct nqhost	lpm_hosts[LC_MOREHOSTSIZ];
};

/*
 * Special value for slp for local server calls.
 */
#define	NQLOCALSLP	((struct nfssvc_sock *) -1)

/*
 * Server side macros.
 */
#define	nqsrv_getl(v, l) \
		(void) nqsrv_getlease((v), &nfsd->nd_duration, \
		 ((nfsd->nd_flag & ND_LEASE) ? (nfsd->nd_flag & ND_LEASE) : \
		 ((l) | ND_CHECK)), \
		 slp, procp, nfsd->nd_nam, &cache, &frev, cred)

/*
 * Client side macros that check for a valid lease.
 */
#define	NQNFS_CKINVALID(v, n, f) \
 ((time.tv_sec > (n)->n_expiry && \
 VFSTONFS((v)->v_mount)->nm_timeouts < VFSTONFS((v)->v_mount)->nm_deadthresh) \
  || ((f) == ND_WRITE && ((n)->n_flag & NQNFSWRITE) == 0))

#define	NQNFS_CKCACHABLE(v, f) \
 ((time.tv_sec <= VTONFS(v)->n_expiry || \
  VFSTONFS((v)->v_mount)->nm_timeouts >= VFSTONFS((v)->v_mount)->nm_deadthresh) \
   && (VTONFS(v)->n_flag & NQNFSNONCACHE) == 0 && \
   ((f) == ND_READ || (VTONFS(v)->n_flag & NQNFSWRITE)))

#define	NQNFS_NEEDLEASE(v, p) \
		(time.tv_sec > VTONFS(v)->n_expiry ? \
		 ((VTONFS(v)->n_flag & NQNFSEVICTED) ? 0 : nqnfs_piggy[p]) : \
		 (((time.tv_sec + NQ_RENEWAL) > VTONFS(v)->n_expiry && \
		   nqnfs_piggy[p]) ? \
		   ((VTONFS(v)->n_flag & NQNFSWRITE) ? \
		    ND_WRITE : nqnfs_piggy[p]) : 0))

/*
 * List head for timer queue.
 */
CIRCLEQ_HEAD(, nqlease) nqtimerhead;

/*
 * List head for the file handle hash table.
 */
#define	NQFHHASH(f) \
	(&nqfhhashtbl[(*((u_int32_t *)(f))) & nqfhhash])
LIST_HEAD(nqfhhashhead, nqlease) *nqfhhashtbl;
u_long nqfhhash;

/*
 * Nqnfs return status numbers.
 */
#define	NQNFS_EXPIRED	500
#define	NQNFS_TRYLATER	501

#ifdef _KERNEL
void	nqnfs_lease_updatetime __P((int));
int	nqsrv_cmpnam __P((struct nfssvc_sock *,struct mbuf *,struct nqhost *));
int	nqsrv_getlease __P((struct vnode *, u_int32_t *, int,
		struct nfssvc_sock *, struct proc *, struct mbuf *, int *,
		u_quad_t *, struct ucred *));
int	nqnfs_getlease __P((struct vnode *, int, struct ucred *,struct proc *));
int	nqnfs_callback __P((struct nfsmount *, struct mbuf *, struct mbuf *,
		caddr_t));
int	nqnfs_clientd __P((struct nfsmount *, struct ucred *,
		struct nfsd_cargs *, int, caddr_t, struct proc *));
#endif

#endif
@


1.4
log
@Minor cleanups. Checked against Lite2.
(NetBSD's was really just a Lite2's, but w/ 64bit support)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.4.16.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: nqnfs.h,v 1.4 1996/04/17 04:50:42 mickey Exp $	*/
@


1.3
log
@From NetBSD: NFSv3 import (tomorrow's Net's kernel)
Open's patches kept in. i'll possibly take a look at Lite2 soon,
is there smth usefull ?..
@
text
@d1 1
@


1.2
log
@from cgd; handle 64-bit pointers and longs
@
text
@d1 1
a1 1
/*	$NetBSD: nqnfs.h,v 1.5 1995/12/19 23:08:21 cgd Exp $	*/
d38 1
a38 1
 *	@@(#)nqnfs.h	8.2 (Berkeley) 8/18/94
d41 4
d63 1
a63 1
#define	NQNFS_VER1	1
d71 3
d93 1
a93 1
			u_int16_t udp_port;
a147 8
 * Flag bits for flags argument to nqsrv_getlease.
 */
#define	NQL_READ	LEASE_READ	/* Read Request */
#define	NQL_WRITE	LEASE_WRITE	/* Write Request */
#define	NQL_CHECK	0x4		/* Check for lease */
#define	NQL_NOVAL	0xffffffff	/* Invalid */

/*
d157 3
a159 3
		 ((nfsd->nd_nqlflag != 0 && nfsd->nd_nqlflag != NQL_NOVAL) ? nfsd->nd_nqlflag : \
		 ((l) | NQL_CHECK)), \
		 nfsd, nam, &cache, &frev, cred)
d167 1
a167 1
  || ((f) == NQL_WRITE && ((n)->n_flag & NQNFSWRITE) == 0))
d173 1
a173 1
   ((f) == NQL_READ || (VTONFS(v)->n_flag & NQNFSWRITE)))
d181 1
a181 1
		    NQL_WRITE : nqnfs_piggy[p]) : 0))
d201 15
a215 1
#define NQNFS_AUTHERR	502
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: nqnfs.h,v 1.4 1994/12/13 17:17:08 mycroft Exp $	*/
d85 2
a86 2
			u_short udp_flag;
			u_short	udp_port;
d90 2
a91 2
			u_short connless_flag;
			u_short connless_spare;
d95 2
a96 2
			u_short conn_flag;
			u_short conn_spare;
d193 1
a193 1
	(&nqfhhashtbl[(*((u_long *)(f))) & nqfhhash])
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
