head	1.45;
access;
symbols
	OPENBSD_6_2_BASE:1.45
	OPENBSD_6_1:1.45.0.8
	OPENBSD_6_1_BASE:1.45
	OPENBSD_6_0:1.45.0.4
	OPENBSD_6_0_BASE:1.45
	OPENBSD_5_9:1.45.0.2
	OPENBSD_5_9_BASE:1.45
	OPENBSD_5_8:1.44.0.6
	OPENBSD_5_8_BASE:1.44
	OPENBSD_5_7:1.44.0.2
	OPENBSD_5_7_BASE:1.44
	OPENBSD_5_6:1.43.0.22
	OPENBSD_5_6_BASE:1.43
	OPENBSD_5_5:1.43.0.20
	OPENBSD_5_5_BASE:1.43
	OPENBSD_5_4:1.43.0.16
	OPENBSD_5_4_BASE:1.43
	OPENBSD_5_3:1.43.0.14
	OPENBSD_5_3_BASE:1.43
	OPENBSD_5_2:1.43.0.12
	OPENBSD_5_2_BASE:1.43
	OPENBSD_5_1_BASE:1.43
	OPENBSD_5_1:1.43.0.10
	OPENBSD_5_0:1.43.0.8
	OPENBSD_5_0_BASE:1.43
	OPENBSD_4_9:1.43.0.6
	OPENBSD_4_9_BASE:1.43
	OPENBSD_4_8:1.43.0.4
	OPENBSD_4_8_BASE:1.43
	OPENBSD_4_7:1.43.0.2
	OPENBSD_4_7_BASE:1.43
	OPENBSD_4_6:1.38.0.4
	OPENBSD_4_6_BASE:1.38
	OPENBSD_4_5:1.33.0.2
	OPENBSD_4_5_BASE:1.33
	OPENBSD_4_4:1.31.0.2
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.24.0.2
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.16.0.6
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.4
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.2
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.15.0.8
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.6
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.4
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.2
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.4
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.11.0.14
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.12
	UBC:1.11.0.12
	UBC_BASE:1.11
	OPENBSD_3_0:1.11.0.10
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.8
	OPENBSD_2_8:1.11.0.6
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.4
	OPENBSD_2_7_BASE:1.11
	SMP:1.11.0.2
	SMP_BASE:1.11
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.4
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.2
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.6
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.4
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.45
date	2015.08.29.23.07.51;	author deraadt;	state Exp;
branches;
next	1.44;
commitid	skKRyCLqDVAHBQ4Q;

1.44
date	2014.12.18.20.59.21;	author tedu;	state Exp;
branches;
next	1.43;
commitid	A8MlA6JGDExx7uTs;

1.43
date	2009.08.10.09.18.31;	author blambert;	state Exp;
branches;
next	1.42;

1.42
date	2009.08.09.13.34.41;	author thib;	state Exp;
branches;
next	1.41;

1.41
date	2009.08.04.17.12.39;	author thib;	state Exp;
branches;
next	1.40;

1.40
date	2009.07.30.14.04.28;	author thib;	state Exp;
branches;
next	1.39;

1.39
date	2009.07.20.16.49.40;	author thib;	state Exp;
branches;
next	1.38;

1.38
date	2009.06.06.00.33.51;	author thib;	state Exp;
branches;
next	1.37;

1.37
date	2009.06.05.19.34.58;	author jasper;	state Exp;
branches;
next	1.36;

1.36
date	2009.06.04.00.31.42;	author blambert;	state Exp;
branches;
next	1.35;

1.35
date	2009.04.13.17.51.57;	author blambert;	state Exp;
branches;
next	1.34;

1.34
date	2009.03.30.19.58.50;	author blambert;	state Exp;
branches;
next	1.33;

1.33
date	2009.01.24.23.30.42;	author thib;	state Exp;
branches;
next	1.32;

1.32
date	2008.12.24.16.53.20;	author thib;	state Exp;
branches;
next	1.31;

1.31
date	2008.06.15.04.03.40;	author thib;	state Exp;
branches;
next	1.30;

1.30
date	2008.06.14.22.44.07;	author blambert;	state Exp;
branches;
next	1.29;

1.29
date	2008.06.13.22.11.32;	author blambert;	state Exp;
branches;
next	1.28;

1.28
date	2008.06.13.03.49.26;	author blambert;	state Exp;
branches;
next	1.27;

1.27
date	2008.06.12.20.24.06;	author blambert;	state Exp;
branches;
next	1.26;

1.26
date	2008.05.27.19.06.28;	author blambert;	state Exp;
branches;
next	1.25;

1.25
date	2008.04.14.13.46.13;	author blambert;	state Exp;
branches;
next	1.24;

1.24
date	2008.01.06.17.38.23;	author blambert;	state Exp;
branches;
next	1.23;

1.23
date	2007.12.13.18.32.55;	author blambert;	state Exp;
branches;
next	1.22;

1.22
date	2007.11.07.23.40.52;	author thib;	state Exp;
branches;
next	1.21;

1.21
date	2007.11.06.19.36.44;	author thib;	state Exp;
branches;
next	1.20;

1.20
date	2007.10.30.23.19.35;	author thib;	state Exp;
branches;
next	1.19;

1.19
date	2007.10.28.14.12.41;	author thib;	state Exp;
branches;
next	1.18;

1.18
date	2007.09.26.16.00.55;	author blambert;	state Exp;
branches;
next	1.17;

1.17
date	2007.09.11.13.41.52;	author blambert;	state Exp;
branches;
next	1.16;

1.16
date	2006.04.02.18.35.11;	author otto;	state Exp;
branches;
next	1.15;

1.15
date	2004.06.24.19.35.26;	author tholo;	state Exp;
branches;
next	1.14;

1.14
date	2004.06.21.23.50.38;	author tholo;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.02.23.28.20;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.03.20.57.00;	author nate;	state Exp;
branches;
next	1.11;

1.11
date	2000.01.05.20.50.52;	author millert;	state Exp;
branches
	1.11.2.1
	1.11.12.1;
next	1.10;

1.10
date	99.02.06.23.07.47;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	99.01.10.20.06.53;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.08.19.22.26.58;	author csapuntz;	state Exp;
branches;
next	1.7;

1.7
date	97.02.24.13.50.04;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.04.21.22.30.38;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.04.17.04.50.38;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.03.31.13.16.09;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.02.29.09.25.02;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.21.14.42.28;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.23;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.23;	author deraadt;	state Exp;
branches;
next	;

1.11.2.1
date	2003.03.28.00.08.47;	author niklas;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2003.06.07.11.07.44;	author ho;	state Exp;
branches;
next	;

1.11.12.1
date	2002.10.29.00.36.49;	author art;	state Exp;
branches;
next	1.11.12.2;

1.11.12.2
date	2002.11.04.18.02.32;	author art;	state Exp;
branches;
next	;


desc
@@


1.45
log
@fix ugly indents; no harmful macros harmed
@
text
@/*	$OpenBSD: nfsm_subs.h,v 1.44 2014/12/18 20:59:21 tedu Exp $	*/
/*	$NetBSD: nfsm_subs.h,v 1.10 1996/03/20 21:59:56 fvdl Exp $	*/

/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Rick Macklem at The University of Guelph.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)nfsm_subs.h	8.2 (Berkeley) 3/30/95
 */


#ifndef _NFS_NFSM_SUBS_H_
#define _NFS_NFSM_SUBS_H_

struct nfsm_info {
	struct mbuf	 *nmi_mreq;
	struct mbuf	 *nmi_mrep;

	struct proc	 *nmi_procp;	/* XXX XXX XXX */
	struct ucred	 *nmi_cred;	/* XXX XXX XXX */

	/* Setting up / Tearing down. */
	struct mbuf	 *nmi_md;
	struct mbuf	 *nmi_mb;
	caddr_t		  nmi_dpos;

	int		  nmi_v3;  
};

#define nfsm_dissect(a, c, s) {						\
	t1 = mtod(info.nmi_md, caddr_t) + info.nmi_md->m_len -		\
	    info.nmi_dpos;						\
	if (t1 >= (s)) {						\
		(a) = (c)(info.nmi_dpos);				\
		info.nmi_dpos += (s);					\
	} else if ((t1 =						\
		  nfsm_disct(&info.nmi_md, &info.nmi_dpos, (s), t1,	\
		      &cp2)) != 0) {					\
		error = t1;						\
		m_freem(info.nmi_mrep);					\
		goto nfsmout;						\
	} else {							\
		(a) = (c)cp2;						\
	}								\
}

#define nfsm_srvpostop_fh(f) {						\
	tl = nfsm_build(&info.nmi_mb, 2 * NFSX_UNSIGNED + NFSX_V3FH);	\
	*tl++ = nfs_true;						\
	*tl++ = txdr_unsigned(NFSX_V3FH);				\
	bcopy((f), tl, NFSX_V3FH);			\
}

#define nfsm_mtofh(d, v, v3, f)	{					\
	struct nfsnode *ttnp; nfsfh_t *ttfhp; int ttfhsize;		\
	if (v3) {							\
		nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);		\
		(f) = fxdr_unsigned(int, *tl);				\
	} else								\
		(f) = 1;						\
	if (f) {							\
		nfsm_getfh(ttfhp, ttfhsize, (v3));			\
		if ((t1 = nfs_nget((d)->v_mount, ttfhp, ttfhsize, 	\
		    &ttnp)) != 0) {					\
			error = t1;					\
			m_freem(info.nmi_mrep);				\
			goto nfsmout;					\
		}							\
		(v) = NFSTOV(ttnp);					\
	}								\
	if (v3) {							\
		nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);		\
		if (f)							\
			(f) = fxdr_unsigned(int, *tl);			\
		else if (fxdr_unsigned(int, *tl))			\
			nfsm_adv(NFSX_V3FATTR);				\
	}								\
	if (f)								\
		nfsm_loadattr((v), NULL);				\
}

#define nfsm_getfh(f, s, v3) {						\
	if (v3) {							\
		nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);		\
		if (((s) = fxdr_unsigned(int, *tl)) <= 0 ||		\
			(s) > NFSX_V3FHMAX) {				\
			m_freem(info.nmi_mrep);				\
			error = EBADRPC;				\
			goto nfsmout;					\
		}							\
	} else								\
		(s) = NFSX_V2FH;					\
	nfsm_dissect((f), nfsfh_t *, nfsm_rndup(s)); 			\
}

#define nfsm_loadattr(v, a) {						\
	struct vnode *ttvp = (v);					\
	if ((t1 = nfs_loadattrcache(&ttvp, &info.nmi_md,		\
	    &info.nmi_dpos, (a))) != 0) {				\
		error = t1;						\
		m_freem(info.nmi_mrep);					\
		goto nfsmout;						\
	}								\
	(v) = ttvp;							\
}

#define nfsm_postop_attr(v, f) { if (info.nmi_mrep != NULL) {		\
	struct vnode *ttvp = (v);					\
	nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);			\
	if (((f) = fxdr_unsigned(int, *tl)) != 0) {			\
		if ((t1 = nfs_loadattrcache(&ttvp, &info.nmi_md,	\
		    &info.nmi_dpos, NULL)) != 0) {			\
			error = t1;					\
			(f) = 0;					\
			m_freem(info.nmi_mrep);				\
			goto nfsmout;					\
		}							\
		(v) = ttvp;						\
	}								\
} }

/* Used as (f) for nfsm_wcc_data() */
#define NFSV3_WCCRATTR	0
#define NFSV3_WCCCHK	1

#define nfsm_wcc_data(v, f) do { if (info.nmi_mrep != NULL) {		\
	struct timespec	 _mtime;					\
	int		 ttattrf, ttretf = 0;				\
									\
	nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);			\
	if (*tl == nfs_true) {						\
		nfsm_dissect(tl, u_int32_t *, 6 * NFSX_UNSIGNED);	\
		fxdr_nfsv3time(tl + 2, &_mtime);			\
		if (f) {						\
			ttretf = timespeccmp(&VTONFS(v)->n_mtime,	\
			    &_mtime, !=);				\
		}							\
	}								\
	nfsm_postop_attr((v), ttattrf);					\
	if (f) {							\
		(f) = ttretf;						\
	} else {							\
		(f) = ttattrf;						\
	}								\
} } while (0)

#define nfsm_strsiz(s, m) {						\
	nfsm_dissect(tl, u_int32_t *,NFSX_UNSIGNED);			\
	if (((s) = fxdr_unsigned(int32_t, *tl)) > (m)) {		\
		m_freem(info.nmi_mrep);					\
		error = EBADRPC;					\
		goto nfsmout;						\
	}								\
}

#define nfsm_srvnamesiz(s) {						\
	nfsm_dissect(tl, u_int32_t *,NFSX_UNSIGNED);			\
	if (((s) = fxdr_unsigned(int32_t, *tl)) > NFS_MAXNAMLEN) 	\
		error = NFSERR_NAMETOL;					\
	if ((s) <= 0)							\
		error = EBADRPC;					\
	if (error)							\
		nfsm_reply(0);						\
}

#define nfsm_mtouio(p, s)						\
	if ((s) > 0 &&							\
	    (t1 = nfsm_mbuftouio(&info.nmi_md, (p), (s),		\
	        &info.nmi_dpos)) != 0) {				\
		error = t1;						\
		m_freem(info.nmi_mrep);					\
		goto nfsmout;						\
	}

#define nfsm_rndup(a)	(((a)+3)&(~0x3))

#define nfsm_strtom(a, s, m)						\
	if ((s) > (m)) {						\
		m_freem(info.nmi_mreq);					\
		error = ENAMETOOLONG;					\
		goto nfsmout;						\
	}								\
	nfsm_strtombuf(&info.nmi_mb, (a), (s))

#define nfsm_reply(s) {							\
	nfsd->nd_repstat = error;					\
	if (error && !(nfsd->nd_flag & ND_NFSV3))			\
	   (void) nfs_rephead(0, nfsd, slp, error,			\
		&info.nmi_mreq, &info.nmi_mb);				\
	else								\
	   (void) nfs_rephead((s), nfsd, slp, error,			\
		&info.nmi_mreq, &info.nmi_mb);				\
	if (info.nmi_mrep != NULL) {					\
		m_freem(info.nmi_mrep);					\
		info.nmi_mrep = NULL;					\
	}								\
	*mrq = info.nmi_mreq;						\
	if (error && (!(nfsd->nd_flag & ND_NFSV3) || error == EBADRPC))	\
		return(0);						\
}

#define nfsm_writereply(s, v3) {					\
	nfsd->nd_repstat = error;					\
	if (error && !(v3))						\
	   (void) nfs_rephead(0, nfsd, slp, error, &info.nmi_mreq,	\
	       &info.nmi_mb);						\
	else								\
	   (void) nfs_rephead((s), nfsd, slp, error, &info.nmi_mreq,	\
	       &info.nmi_mb);						\
}

#define nfsm_adv(s) {							\
	t1 = mtod(info.nmi_md, caddr_t) + info.nmi_md->m_len -		\
	    info.nmi_dpos;						\
	if (t1 >= (s)) {						\
		info.nmi_dpos += (s);					\
	} else if ((t1 = nfs_adv(&info.nmi_md, &info.nmi_dpos,		\
	      (s), t1)) != 0) {						\
		error = t1;						\
		m_freem(info.nmi_mrep);					\
		goto nfsmout;						\
	}								\
}

#define nfsm_srvmtofh(f) {						\
	if (nfsd->nd_flag & ND_NFSV3) {					\
		nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);		\
		if (fxdr_unsigned(int, *tl) != NFSX_V3FH) {		\
			error = EBADRPC;				\
			nfsm_reply(0);					\
		}							\
	}								\
	nfsm_dissect(tl, u_int32_t *, NFSX_V3FH);			\
	bcopy(tl, (f), NFSX_V3FH);			\
	if ((nfsd->nd_flag & ND_NFSV3) == 0)				\
	nfsm_adv(NFSX_V2FH - NFSX_V3FH);				\
}

#endif
@


1.44
log
@delete a whole mess of unnecessary caddr_t casts
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsm_subs.h,v 1.43 2009/08/10 09:18:31 blambert Exp $	*/
d174 3
a176 3
#define nfsm_strsiz(s,m) {						\
	nfsm_dissect(tl,u_int32_t *,NFSX_UNSIGNED);			\
	if (((s) = fxdr_unsigned(int32_t,*tl)) > (m)) {			\
d184 2
a185 2
	nfsm_dissect(tl,u_int32_t *,NFSX_UNSIGNED);			\
	if (((s) = fxdr_unsigned(int32_t,*tl)) > NFS_MAXNAMLEN) 	\
d193 1
a193 1
#define nfsm_mtouio(p,s)						\
d195 1
a195 1
	    (t1 = nfsm_mbuftouio(&info.nmi_md,(p),(s),			\
d204 1
a204 1
#define nfsm_strtom(a,s,m)						\
@


1.43
log
@The only caller of NFSMSIZ got changed yesterday, so remove it.

High five from thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsm_subs.h,v 1.42 2009/08/09 13:34:41 thib Exp $	*/
d78 1
a78 1
	bcopy((caddr_t)(f), (caddr_t)tl, NFSX_V3FH);			\
d261 1
a261 1
	bcopy((caddr_t)tl, (caddr_t)(f), NFSX_V3FH);			\
@


1.42
log
@set the mrq pointer (request) in the nfsm_reply() macro, as we can return from it.
This can cause us to follow garbage in the nfsd loop, causing two kinds of hell.

problem noticed by nicm@@. OK blambert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsm_subs.h,v 1.37 2009/06/05 19:34:58 jasper Exp $	*/
a40 4


#define	NFSMSIZ(m)	(((m)->m_flags & M_EXT) ? (m)->m_ext.ext_size : \
			    (((m)->m_flags & M_PKTHDR) ? MHLEN : MLEN))
@


1.41
log
@group all of the on-stack variables that are uses by the nfsm_macros
to keep the data munging "state" into an nfsm_info structure. Each
function now has this structure on its stack, and it and its members
are now passed around so that the macros/functions can work there magic.

this will make removing the nfsm_* macros way easier.

Idea/code picked up from DragonflyBSD.

Tested by krw@@, jacekm@@ and myself.

OK blambert@@.
@
text
@d228 1
@


1.40
log
@make sure we only ever try to read out post-op attributes
or wcc data if we have a proper reply.

found the hard way by ariane@@, tested by ariane@@.

OK blambert@@
@
text
@d43 17
a59 26
/*
 * These macros do strange and peculiar things to mbuf chains for
 * the assistance of the nfs code. To attempt to use them for any
 * other purpose will be dangerous. (they make weird assumptions)
 */

/*
 * First define what the actual subs. return
 */

#define	M_HASCL(m)	((m)->m_flags & M_EXT)
#define	NFSMSIZ(m)	((M_HASCL(m)) ? (m)->m_ext.ext_size : \
				(((m)->m_flags & M_PKTHDR) ? MHLEN : MLEN))

/*
 * Now for the macros that do the simple stuff and call the functions
 * for the hard stuff.
 * These macros use several vars. declared in nfsm_reqhead and these
 * vars. must not be used elsewhere unless you are careful not to corrupt
 * them. The vars. starting with pN and tN (N=1,2,3,..) are temporaries
 * that may be used so long as the value is not expected to retained
 * after a macro.
 * I know, this is kind of dorkey, but it makes the actual op functions
 * fairly clean and deals with the mess caused by the xdr discriminating
 * unions.
 */
d62 2
a63 1
	t1 = mtod(md, caddr_t)+md->m_len-dpos;				\
d65 2
a66 2
		(a) = (c)(dpos);					\
		dpos += (s);						\
d68 2
a69 1
		  nfsm_disct(&md, &dpos, (s), t1, &cp2)) != 0) {	\
d71 1
a71 1
		m_freem(mrep);						\
d79 1
a79 1
	tl = nfsm_build(&mb, 2 * NFSX_UNSIGNED + NFSX_V3FH);		\
d97 1
a97 1
			m_freem(mrep);					\
d118 1
a118 1
			m_freem(mrep);					\
d129 2
a130 1
	if ((t1 = nfs_loadattrcache(&ttvp, &md, &dpos, (a))) != 0) {	\
d132 1
a132 1
		m_freem(mrep);						\
d138 1
a138 1
#define nfsm_postop_attr(v, f) { if (mrep != NULL) {			\
d142 2
a143 2
		if ((t1 = nfs_loadattrcache(&ttvp, &md, &dpos,		\
			NULL)) != 0) {					\
d146 1
a146 1
			m_freem(mrep);					\
d157 1
a157 1
#define nfsm_wcc_data(v, f) do { if (mrep != NULL) {			\
d181 1
a181 1
		m_freem(mrep);						\
d199 2
a200 1
	    (t1 = nfsm_mbuftouio(&md,(p),(s),&dpos)) != 0) {		\
d202 1
a202 1
		m_freem(mrep);						\
d210 1
a210 1
		m_freem(mreq);						\
d214 1
a214 1
	nfsm_strtombuf(&mb, (a), (s))
d220 1
a220 1
		mrq, &mb);						\
d223 4
a226 4
		mrq, &mb);						\
	if (mrep != NULL) {						\
		m_freem(mrep);						\
		mrep = NULL;						\
a227 1
	mreq = *mrq;							\
d235 2
a236 1
	   (void) nfs_rephead(0, nfsd, slp, error, &mreq, &mb);		\
d238 2
a239 1
	   (void) nfs_rephead((s), nfsd, slp, error, &mreq, &mb);	\
d243 2
a244 1
	t1 = mtod(md, caddr_t)+md->m_len-dpos;				\
d246 3
a248 2
		dpos += (s);						\
	} else if ((t1 = nfs_adv(&md, &dpos, (s), t1)) != 0) {		\
d250 1
a250 1
		m_freem(mrep);						\
@


1.39
log
@(struct foo *)0 -> NULL, every where I could find it.

OK blambert@@
@
text
@d144 1
a144 1
#define nfsm_postop_attr(v, f) {					\
d157 1
a157 1
}
d163 1
a163 1
#define nfsm_wcc_data(v, f) do {					\
d182 1
a182 1
} while (0)
@


1.38
log
@turdshine previous
@
text
@d117 1
a117 1
		nfsm_loadattr((v), (struct vattr *)0);			\
d149 1
a149 1
			(struct vattr *)0)) != 0) {			\
@


1.37
log
@- make this a lot more readable; no binary change

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsm_subs.h,v 1.36 2009/06/04 00:31:42 blambert Exp $	*/
d70 33
a102 7
#define	nfsm_dissect(a, c, s)						\
		{ t1 = mtod(md, caddr_t)+md->m_len-dpos;		\
		if (t1 >= (s)) {					\
			(a) = (c)(dpos);				\
			dpos += (s);					\
		} else if ((t1 =					\
			  nfsm_disct(&md, &dpos, (s), t1, &cp2)) != 0){	\
d106 6
a111 15
		} else {						\
			(a) = (c)cp2;					\
		} }

#define nfsm_srvpostop_fh(f)						\
		{ tl = nfsm_build(&mb, 2 * NFSX_UNSIGNED + NFSX_V3FH);	\
		*tl++ = nfs_true;					\
		*tl++ = txdr_unsigned(NFSX_V3FH);			\
		bcopy((caddr_t)(f), (caddr_t)tl, NFSX_V3FH);		\
		}

#define nfsm_mtofh(d, v, v3, f)						\
		{ struct nfsnode *ttnp; nfsfh_t *ttfhp; int ttfhsize;	\
		if (v3) {						\
			nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);	\
d113 15
a127 11
		} else							\
			(f) = 1;					\
		if (f) {						\
			nfsm_getfh(ttfhp, ttfhsize, (v3));		\
			if ((t1 = nfs_nget((d)->v_mount, ttfhp, ttfhsize, \
			    &ttnp)) != 0) {				\
				error = t1;				\
				m_freem(mrep);				\
				goto nfsmout;				\
			}						\
			(v) = NFSTOV(ttnp);				\
d129 14
a142 10
		if (v3) {						\
			nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);	\
			if (f)						\
				(f) = fxdr_unsigned(int, *tl);		\
			else if (fxdr_unsigned(int, *tl))		\
				nfsm_adv(NFSX_V3FATTR);			\
		}							\
		if (f)							\
			nfsm_loadattr((v), (struct vattr *)0);		\
		}
d144 6
a149 16
#define nfsm_getfh(f, s, v3)						\
		{ if (v3) {						\
			nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);	\
			if (((s) = fxdr_unsigned(int, *tl)) <= 0 ||	\
				(s) > NFSX_V3FHMAX) {			\
				m_freem(mrep);				\
				error = EBADRPC;			\
				goto nfsmout;				\
			}						\
		} else							\
			(s) = NFSX_V2FH;				\
		nfsm_dissect((f), nfsfh_t *, nfsm_rndup(s)); }

#define	nfsm_loadattr(v, a)						\
		{ struct vnode *ttvp = (v);				\
		if ((t1 = nfs_loadattrcache(&ttvp, &md, &dpos, (a))) != 0) { \
d151 1
d155 3
a157 15
		(v) = ttvp; }

#define	nfsm_postop_attr(v, f)						\
		{ struct vnode *ttvp = (v);				\
		nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);		\
		if (((f) = fxdr_unsigned(int, *tl)) != 0) {		\
			if ((t1 = nfs_loadattrcache(&ttvp, &md, &dpos,	\
				(struct vattr *)0)) != 0) {		\
				error = t1;				\
				(f) = 0;				\
				m_freem(mrep);				\
				goto nfsmout;				\
			}						\
			(v) = ttvp;					\
		} }
d163 1
a163 1
#define	nfsm_wcc_data(v, f) do {					\
d184 8
a191 7
#define	nfsm_strsiz(s,m) \
		{ nfsm_dissect(tl,u_int32_t *,NFSX_UNSIGNED);		\
		if (((s) = fxdr_unsigned(int32_t,*tl)) > (m)) {		\
			m_freem(mrep);					\
			error = EBADRPC;				\
			goto nfsmout;					\
		} }
d193 9
a201 9
#define	nfsm_srvnamesiz(s) \
		{ nfsm_dissect(tl,u_int32_t *,NFSX_UNSIGNED);		\
		if (((s) = fxdr_unsigned(int32_t,*tl)) > NFS_MAXNAMLEN) \
			error = NFSERR_NAMETOL;				\
		if ((s) <= 0)						\
			error = EBADRPC;				\
		if (error)						\
			nfsm_reply(0);					\
		}
d204 6
a209 6
		if ((s) > 0 &&						\
		   (t1 = nfsm_mbuftouio(&md,(p),(s),&dpos)) != 0) {	\
			error = t1;					\
			m_freem(mrep);					\
			goto nfsmout;					\
		}
d213 43
a255 47
#define	nfsm_strtom(a,s,m)			\
		if ((s) > (m)) {		\
			m_freem(mreq);		\
			error = ENAMETOOLONG;	\
			goto nfsmout;		\
		}				\
		nfsm_strtombuf(&mb, (a), (s))

#define	nfsm_reply(s)						\
		{						\
		nfsd->nd_repstat = error;			\
		if (error && !(nfsd->nd_flag & ND_NFSV3))	\
		   (void) nfs_rephead(0, nfsd, slp, error,	\
			mrq, &mb);				\
		else						\
		   (void) nfs_rephead((s), nfsd, slp, error,	\
			mrq, &mb);				\
		if (mrep != NULL) {				\
			m_freem(mrep);				\
			mrep = NULL;				\
		}						\
		mreq = *mrq;					\
		if (error && (!(nfsd->nd_flag & ND_NFSV3) ||	\
			error == EBADRPC))			\
			return(0);				\
		}

#define	nfsm_writereply(s, v3)					\
		{						\
		nfsd->nd_repstat = error;			\
		if (error && !(v3))				\
		   (void) nfs_rephead(0, nfsd, slp, error,	\
			&mreq, &mb);				\
		else						\
		   (void) nfs_rephead((s), nfsd, slp, error,	\
			&mreq, &mb);				\
		}

#define	nfsm_adv(s)							\
		{ t1 = mtod(md, caddr_t)+md->m_len-dpos;		\
		if (t1 >= (s)) {					\
			dpos += (s);					\
		} else if ((t1 = nfs_adv(&md, &dpos, (s), t1)) != 0) {	\
			error = t1;					\
			m_freem(mrep);					\
			goto nfsmout;					\
		} }
d257 6
a262 7
#define nfsm_srvmtofh(f)						\
		{ if (nfsd->nd_flag & ND_NFSV3) {			\
			nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED);	\
			if (fxdr_unsigned(int, *tl) != NFSX_V3FH) {	\
				error = EBADRPC;			\
				nfsm_reply(0);				\
			}						\
d264 6
a269 5
		nfsm_dissect(tl, u_int32_t *, NFSX_V3FH);		\
		bcopy((caddr_t)tl, (caddr_t)(f), NFSX_V3FH);		\
		if ((nfsd->nd_flag & ND_NFSV3) == 0)			\
			nfsm_adv(NFSX_V2FH - NFSX_V3FH);		\
		}
@


1.36
log
@Demacro nfsm_lookup for great justice.

Thanks to ckuethe for saving much typing with a drive-by perl script.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsm_subs.h,v 1.35 2009/04/13 17:51:57 blambert Exp $	*/
d70 12
a81 11
#define	nfsm_dissect(a, c, s) \
		{ t1 = mtod(md, caddr_t)+md->m_len-dpos; \
		if (t1 >= (s)) { \
			(a) = (c)(dpos); \
			dpos += (s); \
		} else if ((t1 = nfsm_disct(&md, &dpos, (s), t1, &cp2)) != 0){ \
			error = t1; \
			m_freem(mrep); \
			goto nfsmout; \
		} else { \
			(a) = (c)cp2; \
d84 5
a88 5
#define nfsm_srvpostop_fh(f) \
		{ tl = nfsm_build(&mb, 2 * NFSX_UNSIGNED + NFSX_V3FH); \
		*tl++ = nfs_true; \
		*tl++ = txdr_unsigned(NFSX_V3FH); \
		bcopy((caddr_t)(f), (caddr_t)tl, NFSX_V3FH); \
d91 9
a99 9
#define nfsm_mtofh(d, v, v3, f) \
		{ struct nfsnode *ttnp; nfsfh_t *ttfhp; int ttfhsize; \
		if (v3) { \
			nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED); \
			(f) = fxdr_unsigned(int, *tl); \
		} else \
			(f) = 1; \
		if (f) { \
			nfsm_getfh(ttfhp, ttfhsize, (v3)); \
d101 16
a116 16
				&ttnp)) != 0) { \
				error = t1; \
				m_freem(mrep); \
				goto nfsmout; \
			} \
			(v) = NFSTOV(ttnp); \
		} \
		if (v3) { \
			nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED); \
			if (f) \
				(f) = fxdr_unsigned(int, *tl); \
			else if (fxdr_unsigned(int, *tl)) \
				nfsm_adv(NFSX_V3FATTR); \
		} \
		if (f) \
			nfsm_loadattr((v), (struct vattr *)0); \
d119 11
a129 11
#define nfsm_getfh(f, s, v3) \
		{ if (v3) { \
			nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED); \
			if (((s) = fxdr_unsigned(int, *tl)) <= 0 || \
				(s) > NFSX_V3FHMAX) { \
				m_freem(mrep); \
				error = EBADRPC; \
				goto nfsmout; \
			} \
		} else \
			(s) = NFSX_V2FH; \
d132 2
a133 2
#define	nfsm_loadattr(v, a) \
		{ struct vnode *ttvp = (v); \
d135 4
a138 4
			error = t1; \
			m_freem(mrep); \
			goto nfsmout; \
		} \
d141 12
a152 12
#define	nfsm_postop_attr(v, f) \
		{ struct vnode *ttvp = (v); \
		nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED); \
		if (((f) = fxdr_unsigned(int, *tl)) != 0) { \
			if ((t1 = nfs_loadattrcache(&ttvp, &md, &dpos, \
				(struct vattr *)0)) != 0) { \
				error = t1; \
				(f) = 0; \
				m_freem(mrep); \
				goto nfsmout; \
			} \
			(v) = ttvp; \
d181 5
a185 5
		{ nfsm_dissect(tl,u_int32_t *,NFSX_UNSIGNED); \
		if (((s) = fxdr_unsigned(int32_t,*tl)) > (m)) { \
			m_freem(mrep); \
			error = EBADRPC; \
			goto nfsmout; \
d189 1
a189 1
		{ nfsm_dissect(tl,u_int32_t *,NFSX_UNSIGNED); \
d191 5
a195 5
			error = NFSERR_NAMETOL; \
		if ((s) <= 0) \
			error = EBADRPC; \
		if (error) \
			nfsm_reply(0); \
d198 6
a203 6
#define nfsm_mtouio(p,s) \
		if ((s) > 0 && \
		   (t1 = nfsm_mbuftouio(&md,(p),(s),&dpos)) != 0) { \
			error = t1; \
			m_freem(mrep); \
			goto nfsmout; \
d208 6
a213 6
#define	nfsm_strtom(a,s,m) \
		if ((s) > (m)) { \
			m_freem(mreq); \
			error = ENAMETOOLONG; \
			goto nfsmout; \
		} \
d216 17
a232 17
#define	nfsm_reply(s) \
		{ \
		nfsd->nd_repstat = error; \
		if (error && !(nfsd->nd_flag & ND_NFSV3)) \
		   (void) nfs_rephead(0, nfsd, slp, error, \
			mrq, &mb); \
		else \
		   (void) nfs_rephead((s), nfsd, slp, error, \
			mrq, &mb); \
		if (mrep != NULL) { \
			m_freem(mrep); \
			mrep = NULL; \
		} \
		mreq = *mrq; \
		if (error && (!(nfsd->nd_flag & ND_NFSV3) || \
			error == EBADRPC)) \
			return(0); \
d235 9
a243 9
#define	nfsm_writereply(s, v3) \
		{ \
		nfsd->nd_repstat = error; \
		if (error && !(v3)) \
		   (void) nfs_rephead(0, nfsd, slp, error, \
			&mreq, &mb); \
		else \
		   (void) nfs_rephead((s), nfsd, slp, error, \
			&mreq, &mb); \
d246 8
a253 8
#define	nfsm_adv(s) \
		{ t1 = mtod(md, caddr_t)+md->m_len-dpos; \
		if (t1 >= (s)) { \
			dpos += (s); \
		} else if ((t1 = nfs_adv(&md, &dpos, (s), t1)) != 0) { \
			error = t1; \
			m_freem(mrep); \
			goto nfsmout; \
d256 12
a267 12
#define nfsm_srvmtofh(f) \
		{ if (nfsd->nd_flag & ND_NFSV3) { \
			nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED); \
			if (fxdr_unsigned(int, *tl) != NFSX_V3FH) { \
				error = EBADRPC; \
				nfsm_reply(0); \
			} \
		} \
		nfsm_dissect(tl, u_int32_t *, NFSX_V3FH); \
		bcopy((caddr_t)tl, (caddr_t)(f), NFSX_V3FH); \
		if ((nfsd->nd_flag & ND_NFSV3) == 0) \
			nfsm_adv(NFSX_V2FH - NFSX_V3FH); \
@


1.35
log
@Convert macros to functions to reduce kernel memory usage.

In snaps for a while (way too long, according to deraadt@@)
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsm_subs.h,v 1.34 2009/03/30 19:58:50 blambert Exp $	*/
a205 9

#define	nfsm_request(v, t, p, c)	\
		if ((error = nfs_request((v), mreq, (t), (p), \
		   (c), &mrep, &md, &dpos)) != 0) { \
			if (error & NFSERR_RETERR) \
				error &= ~NFSERR_RETERR; \
			else \
				goto nfsmout; \
		}
@


1.34
log
@Convert a sizeable macro to a much-leaner function. Saves (IIRC) 5k on i386.

In snaps for a while.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsm_subs.h,v 1.33 2009/01/24 23:30:42 thib Exp $	*/
a80 15
		} }

#define nfsm_fhtom(v, v3) \
	      { if (v3) { \
			nfsm_strtombuf(&mb, VTONFS(v)->n_fhp, \
			    VTONFS(v)->n_fhsize); \
		} else { \
			nfsm_buftombuf(&mb, VTONFS(v)->n_fhp, NFSX_V2FH); \
		} }

#define nfsm_srvfhtom(f, v3) \
		{ if (v3) { \
			nfsm_strtombuf(&mb, (f), NFSX_V3FH); \
		} else { \
			nfsm_buftombuf(&mb, (f), NFSX_V2FH); \
@


1.33
log
@Use a timespec instead of a time_t for the clients nfsnode
mtime, gives us better granularity, helps with cache consistency.

Idea lifted from NetBSD.

OK blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsm_subs.h,v 1.32 2008/12/24 16:53:20 thib Exp $	*/
a291 44

#define nfsm_srvsattr(a) \
		{ nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED); \
		if (*tl == nfs_true) { \
			nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED); \
			(a)->va_mode = nfstov_mode(*tl); \
		} \
		nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED); \
		if (*tl == nfs_true) { \
			nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED); \
			(a)->va_uid = fxdr_unsigned(uid_t, *tl); \
		} \
		nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED); \
		if (*tl == nfs_true) { \
			nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED); \
			(a)->va_gid = fxdr_unsigned(gid_t, *tl); \
		} \
		nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED); \
		if (*tl == nfs_true) { \
			nfsm_dissect(tl, u_int32_t *, 2 * NFSX_UNSIGNED); \
			(a)->va_size = fxdr_hyper(tl); \
		} \
		nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED); \
		switch (fxdr_unsigned(int, *tl)) { \
		case NFSV3SATTRTIME_TOCLIENT: \
			(a)->va_vaflags &= ~VA_UTIMES_NULL; \
			nfsm_dissect(tl, u_int32_t *, 2 * NFSX_UNSIGNED); \
			fxdr_nfsv3time(tl, &(a)->va_atime); \
			break; \
		case NFSV3SATTRTIME_TOSERVER: \
			getnanotime(&(a)->va_atime); \
			break; \
		}; \
		nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED); \
		switch (fxdr_unsigned(int, *tl)) { \
		case NFSV3SATTRTIME_TOCLIENT: \
			(a)->va_vaflags &= ~VA_UTIMES_NULL; \
			nfsm_dissect(tl, u_int32_t *, 2 * NFSX_UNSIGNED); \
			fxdr_nfsv3time(tl, &(a)->va_mtime); \
			break; \
		case NFSV3SATTRTIME_TOSERVER: \
			getnanotime(&(a)->va_mtime); \
			break; \
		}; }
@


1.32
log
@Low hanging macro fruit. Inline the nfsm_srvstrsiz macro since
its used only once and nuke its definition.

Stolen from blambert's bag'o'diffs.

OK blambert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsm_subs.h,v 1.31 2008/06/15 04:03:40 thib Exp $	*/
d173 20
a192 15
#define	nfsm_wcc_data(v, f) \
		{ int ttattrf, ttretf = 0; \
		nfsm_dissect(tl, u_int32_t *, NFSX_UNSIGNED); \
		if (*tl == nfs_true) { \
			nfsm_dissect(tl, u_int32_t *, 6 * NFSX_UNSIGNED); \
			if (f) \
				ttretf = (VTONFS(v)->n_mtime == \
					fxdr_unsigned(u_int32_t, *(tl + 2))); \
		} \
		nfsm_postop_attr((v), ttattrf); \
		if (f) { \
			(f) = ttretf; \
		} else { \
			(f) = ttattrf; \
		} }
@


1.31
log
@unroll the NFSMADV() macro and nuke it

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsm_subs.h,v 1.30 2008/06/14 22:44:07 blambert Exp $	*/
a194 7
		} }

#define	nfsm_srvstrsiz(s,m) \
		{ nfsm_dissect(tl,u_int32_t *,NFSX_UNSIGNED); \
		if (((s) = fxdr_unsigned(int32_t,*tl)) > (m) || (s) <= 0) { \
			error = EBADRPC; \
			nfsm_reply(0); \
@


1.30
log
@Replace nfsm_build/bcopy with nfsm_{buf,str}tombuf functions in
filehandle -> mbuf write macros.

Removes `magic' variable cp which was used only in these macros,
and should lead to marginally better mbuf packing as well.

`slap it in' thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsm_subs.h,v 1.29 2008/06/13 22:11:32 blambert Exp $	*/
a53 1
#define	NFSMADV(m, s)	(m)->m_data += (s)
@


1.29
log
@Kill one-liner macro which obfuscated mbuf pointer assignment.

Rescue nfsm_reqhead macro name and rename nfsm_reqh.

End of one-liners from nfsm_subs.h.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsm_subs.h,v 1.28 2008/06/13 03:49:26 blambert Exp $	*/
d89 1
a89 2
			cp = nfsm_build(&mb, NFSX_V2FH); \
			bcopy((caddr_t)VTONFS(v)->n_fhp, cp, NFSX_V2FH); \
d94 1
a94 3
			tl = nfsm_build(&mb, NFSX_UNSIGNED + NFSX_V3FH); \
			*tl++ = txdr_unsigned(NFSX_V3FH); \
			bcopy((caddr_t)(f), (caddr_t)tl, NFSX_V3FH); \
d96 1
a96 2
			cp = nfsm_build(&mb, NFSX_V2FH); \
			bcopy((caddr_t)(f), cp, NFSX_V2FH); \
@


1.28
log
@Replace one-line macro which only obfuscated the fact that
the function it was named after took 4 arguments instead of 2.

"get it in; get it in; get it in" thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsm_subs.h,v 1.27 2008/06/12 20:24:06 blambert Exp $	*/
a225 3

#define	nfsm_reqhead(v,a,s) \
		mb = mreq = nfsm_reqh((v),(a),(s))
@


1.27
log
@Remove now-vestigial bpos pointer from NFS. For building outgoing
NFS mbufs, mbufs now contain all their internal buffer state internally,
the way god intended.

ok thib@@

testing johan@@ (and possibly merdely@@; this diff's been around for a bit...)
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsm_subs.h,v 1.26 2008/05/27 19:06:28 blambert Exp $	*/
a301 3

#define nfsm_srvpostop_attr(r, a) \
		nfsm_srvpostopattr(nfsd, (r), (a), &mb)
@


1.26
log
@Remove bloated and nasty nfsm_clget macro; while here, replace some
handrolled loops with nfsm_strtombuf and nfsm_buftombuf.

ok deraadt@@ via thib@@; ok 'nfs buddy' thib@@
testing johan@@, merdely@@; thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsm_subs.h,v 1.25 2008/04/14 13:46:13 blambert Exp $	*/
d87 1
a87 1
			    VTONFS(v)->n_fhsize, &bpos); \
d89 1
a89 1
			cp = nfsm_build(&mb, NFSX_V2FH, &bpos); \
d95 1
a95 1
			tl = nfsm_build(&mb, NFSX_UNSIGNED + NFSX_V3FH,&bpos); \
d99 1
a99 1
			cp = nfsm_build(&mb, NFSX_V2FH, &bpos); \
d104 1
a104 1
		{ tl = nfsm_build(&mb, 2 * NFSX_UNSIGNED + NFSX_V3FH, &bpos); \
d228 1
a228 1
		mb = mreq = nfsm_reqh((v),(a),(s),&bpos)
d247 1
a247 1
		nfsm_strtombuf(&mb, (a), (s), &bpos)
d254 1
a254 1
			mrq, &mb, &bpos); \
d257 1
a257 1
			mrq, &mb, &bpos); \
d273 1
a273 1
			&mreq, &mb, &bpos); \
d276 1
a276 1
			&mreq, &mb, &bpos); \
d304 1
a304 1
		nfsm_srvpostopattr(nfsd, (r), (a), &mb, &bpos)
@


1.25
log
@Rework NFS mbuf write routines:

nfsm_uiotombuf():
- no meaningful return, function becomes void
- replace frankensteined uiomove/MGET with actual call to uiomove

nfsm_strtmbuf():
- no meaningful return, becomes void
- rename and reorder parameters to be consistent with other functions
- becomes wrapper to nfsm_uiotombuf

nfsm_buftombuf():
- new function; unused but slated for future use
- wrapper to nfsm_uiotombuf

As a bonus, making these functions void removes much unneeded code and
garbage collects `magic' variable t2 which was only used (invisibly)
by the macros from nfsm_subs.h

Preps the way for removing much more NFS goo...

testing by myself, thib@@ and merdely@@
ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsm_subs.h,v 1.24 2008/01/06 17:38:23 blambert Exp $	*/
a301 14

#define	nfsm_clget \
		if (bp >= be) { \
			if (mp == mb) \
				mp->m_len += bp-bpos; \
			MGET(mp, M_WAIT, MT_DATA); \
			MCLGET(mp, M_WAIT); \
			mp->m_len = NFSMSIZ(mp); \
			mp2->m_next = mp; \
			mp2 = mp; \
			bp = mtod(mp, caddr_t); \
			be = bp+mp->m_len; \
		} \
		tl = (u_int32_t *)bp
@


1.24
log
@More NFS-related kernel shrinkage...

When you use a macro ~200 times, it tends to bloat your code, so make a
function out of it.

Shaves ~8.5 kB from my kernel.

ok thib@@, "looks good" krw@@

In snaps for 1+ week with no negative reports.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsm_subs.h,v 1.23 2007/12/13 18:32:55 blambert Exp $	*/
d86 2
a87 14
			t2 = nfsm_rndup(VTONFS(v)->n_fhsize) + NFSX_UNSIGNED; \
			if (t2 <= M_TRAILINGSPACE(mb)) { \
				tl = nfsm_build(&mb, t2, &bpos); \
				*tl++ = txdr_unsigned(VTONFS(v)->n_fhsize); \
				*(tl + ((t2>>2) - 2)) = 0; \
				bcopy((caddr_t)VTONFS(v)->n_fhp,(caddr_t)tl, \
					VTONFS(v)->n_fhsize); \
			} else if ((t2 = nfsm_strtmbuf(&mb, &bpos, \
				(caddr_t)VTONFS(v)->n_fhp, \
				  VTONFS(v)->n_fhsize)) != 0) { \
				error = t2; \
				m_freem(mreq); \
				goto nfsmout; \
			} \
d247 1
a247 11
		t2 = nfsm_rndup(s)+NFSX_UNSIGNED; \
		if (t2 <= M_TRAILINGSPACE(mb)) { \
			tl = nfsm_build(&mb, t2, &bpos); \
			*tl++ = txdr_unsigned(s); \
			*(tl+((t2>>2)-2)) = 0; \
			bcopy((caddr_t)(a), (caddr_t)tl, (s)); \
		} else if ((t2 = nfsm_strtmbuf(&mb, &bpos, (a), (s))) != 0) { \
			error = t2; \
			m_freem(mreq); \
			goto nfsmout; \
		}
@


1.23
log
@convert massive (expanded to 150+ lines) nfsm_v3attr macro to a function

shaves an insane (~8K) amount from an i386 kernel

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsm_subs.h,v 1.22 2007/11/07 23:40:52 thib Exp $	*/
a70 14
#define	nfsm_build(a,c,s) \
		{ if ((s) > M_TRAILINGSPACE(mb)) { \
			MGET(mb2, M_WAIT, MT_DATA); \
			if ((s) > MLEN) \
				panic("build > MLEN"); \
			mb->m_next = mb2; \
			mb = mb2; \
			mb->m_len = 0; \
			bpos = mtod(mb, caddr_t); \
		} \
		(a) = (c)(bpos); \
		mb->m_len += (s); \
		bpos += (s); }

d88 1
a88 1
				nfsm_build(tl, u_int32_t *, t2); \
d101 1
a101 1
			nfsm_build(cp, caddr_t, NFSX_V2FH); \
d107 1
a107 1
			nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED + NFSX_V3FH); \
d111 1
a111 1
			nfsm_build(cp, caddr_t, NFSX_V2FH); \
d116 1
a116 1
		{ nfsm_build(tl, u_int32_t *, 2 * NFSX_UNSIGNED + NFSX_V3FH); \
d261 1
a261 1
			nfsm_build(tl,u_int32_t *,t2); \
@


1.22
log
@more low hanging fruit; Expand the nfsm_srvwcc_data() macro
and nuke it's definition.

OK krw@@, blamers@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsm_subs.h,v 1.21 2007/11/06 19:36:44 thib Exp $	*/
a218 63

/* If full is true, set all fields, otherwise just set mode and time fields */
#define nfsm_v3attrbuild(a, full)						\
		{ if ((a)->va_mode != (mode_t)VNOVAL) {				\
			nfsm_build(tl, u_int32_t *, 2 * NFSX_UNSIGNED);		\
			*tl++ = nfs_true;					\
			*tl = txdr_unsigned((a)->va_mode);			\
		} else {							\
			nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED);		\
			*tl = nfs_false;					\
		}								\
		if ((full) && (a)->va_uid != (uid_t)VNOVAL) {			\
			nfsm_build(tl, u_int32_t *, 2 * NFSX_UNSIGNED);		\
			*tl++ = nfs_true;					\
			*tl = txdr_unsigned((a)->va_uid);			\
		} else {							\
			nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED);		\
			*tl = nfs_false;					\
		}								\
		if ((full) && (a)->va_gid != (gid_t)VNOVAL) {			\
			nfsm_build(tl, u_int32_t *, 2 * NFSX_UNSIGNED);		\
			*tl++ = nfs_true;					\
			*tl = txdr_unsigned((a)->va_gid);			\
		} else {							\
			nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED);		\
			*tl = nfs_false;					\
		}								\
		if ((full) && (a)->va_size != VNOVAL) {				\
			nfsm_build(tl, u_int32_t *, 3 * NFSX_UNSIGNED);		\
			*tl++ = nfs_true;					\
			txdr_hyper((a)->va_size, tl);				\
		} else {							\
			nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED);		\
			*tl = nfs_false;					\
		}								\
		if ((a)->va_atime.tv_sec != VNOVAL) {				\
			if ((a)->va_atime.tv_sec != time_second) {		\
				nfsm_build(tl, u_int32_t *, 3 * NFSX_UNSIGNED);	\
				*tl++ = txdr_unsigned(NFSV3SATTRTIME_TOCLIENT);	\
				txdr_nfsv3time(&(a)->va_atime, tl);		\
			} else {						\
				nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED);	\
				*tl = txdr_unsigned(NFSV3SATTRTIME_TOSERVER);	\
			}							\
		} else {							\
			nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED);		\
			*tl = txdr_unsigned(NFSV3SATTRTIME_DONTCHANGE);		\
		}								\
		if ((a)->va_mtime.tv_sec != VNOVAL) {				\
			if ((a)->va_mtime.tv_sec != time_second) {		\
				nfsm_build(tl, u_int32_t *, 3 * NFSX_UNSIGNED);	\
				*tl++ = txdr_unsigned(NFSV3SATTRTIME_TOCLIENT);	\
				txdr_nfsv3time(&(a)->va_mtime, tl);		\
			} else {						\
				nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED);	\
				*tl = txdr_unsigned(NFSV3SATTRTIME_TOSERVER);	\
			}							\
		} else {							\
			nfsm_build(tl, u_int32_t *, NFSX_UNSIGNED);		\
			*tl = txdr_unsigned(NFSV3SATTRTIME_DONTCHANGE);		\
		}								\
		}
				
@


1.21
log
@Expand the nfsm_srvfillattr() macro and
nuke it's definition.

OK krw@@, blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsm_subs.h,v 1.20 2007/10/30 23:19:35 thib Exp $	*/
a414 3

#define nfsm_srvwcc_data(br, b, ar, a) \
		nfsm_srvwcc(nfsd, (br), (b), (ar), (a), &mb, &bpos)
@


1.20
log
@remove an unused macro, NFSMINOFF;

ok beck@@, blambert@@
"Kill it. Kill it dead." krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsm_subs.h,v 1.19 2007/10/28 14:12:41 thib Exp $	*/
a414 3

#define	nfsm_srvfillattr(a, f) \
		nfsm_srvfattr(nfsd, (a), (f))
@


1.19
log
@Remove the "frev" argument from nfs_rephead(); and clean up the "frev"
variables, that are declared all over, since they are passed via macros
to nfs_rephead(); which doesn't do anything with it.

OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsm_subs.h,v 1.18 2007/09/26 16:00:55 blambert Exp $	*/
a53 7
#define	NFSMINOFF(m) \
		if (M_HASCL(m)) \
			(m)->m_data = (m)->m_ext.ext_buf; \
		else if ((m)->m_flags & M_PKTHDR) \
			(m)->m_data = (m)->m_pktdat; \
		else \
			(m)->m_data = (m)->m_dat
@


1.18
log
@nfsm_uiotom macro does nothing but hide error-handling code; replace
inline in the one place that it's called

ok thib@@, weingart@@
"I don't see why not" fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsm_subs.h,v 1.17 2007/09/11 13:41:52 blambert Exp $	*/
d359 1
a359 1
		   (void) nfs_rephead(0, nfsd, slp, error, &frev, \
d362 1
a362 1
		   (void) nfs_rephead((s), nfsd, slp, error, &frev, \
d378 1
a378 1
		   (void) nfs_rephead(0, nfsd, slp, error, &frev, \
d381 1
a381 1
		   (void) nfs_rephead((s), nfsd, slp, error, &frev, \
@


1.17
log
@Replace nfsm_reqdone and nfsm_srvdone macros inline. No binary change.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsm_subs.h,v 1.16 2006/04/02 18:35:11 otto Exp $	*/
a319 7
			goto nfsmout; \
		}

#define nfsm_uiotom(p,s) \
		if ((t1 = nfsm_uiotombuf((p),&mb,(s),&bpos)) != 0) { \
			error = t1; \
			m_freem(mreq); \
@


1.16
log
@When setting timestamps TOSERVER having write permissions is adaquate;
problem experienced by Han Boetes; fix with "nfs4" rick at snowhite
dot cis dot uoguelph dot ca. ok pedro@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsm_subs.h,v 1.15 2004/06/24 19:35:26 tholo Exp $	*/
a332 3
#define nfsm_reqdone	m_freem(mrep); \
		nfsmout: 

a360 4

#define	nfsm_srvdone \
		nfsmout: \
		return(error)
@


1.15
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsm_subs.h,v 1.14 2004/06/21 23:50:38 tholo Exp $	*/
d470 1
d481 1
@


1.14
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsm_subs.h,v 1.13 2003/06/02 23:28:20 millert Exp $	*/
d474 1
a474 2
			(a)->va_atime.tv_sec = time.tv_sec; \
			(a)->va_atime.tv_nsec = time.tv_usec * 1000; \
d484 1
a484 2
			(a)->va_mtime.tv_sec = time.tv_sec; \
			(a)->va_mtime.tv_nsec = time.tv_usec * 1000; \
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsm_subs.h,v 1.12 2002/07/03 20:57:00 nate Exp $	*/
d262 1
a262 1
			if ((a)->va_atime.tv_sec != time.tv_sec) {		\
d275 1
a275 1
			if ((a)->va_mtime.tv_sec != time.tv_sec) {		\
@


1.12
log
@Remove unused function parameter 'cache' from nfs_rephead
ok costa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsm_subs.h,v 1.11 2000/01/05 20:50:52 millert Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.11
log
@In the NFSMSIZ macro, don't assume that m_ext.ext_size == MCLBYTES.
From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsm_subs.h,v 1.10 1999/02/06 23:07:47 millert Exp $	*/
d377 1
a377 1
		   (void) nfs_rephead(0, nfsd, slp, error, cache, &frev, \
d380 1
a380 1
		   (void) nfs_rephead((s), nfsd, slp, error, cache, &frev, \
d396 1
a396 1
		   (void) nfs_rephead(0, nfsd, slp, error, cache, &frev, \
d399 1
a399 1
		   (void) nfs_rephead((s), nfsd, slp, error, cache, &frev, \
@


1.11.2.1
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d377 1
a377 1
		   (void) nfs_rephead(0, nfsd, slp, error, &frev, \
d380 1
a380 1
		   (void) nfs_rephead((s), nfsd, slp, error, &frev, \
d396 1
a396 1
		   (void) nfs_rephead(0, nfsd, slp, error, &frev, \
d399 1
a399 1
		   (void) nfs_rephead((s), nfsd, slp, error, &frev, \
@


1.11.2.2
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsm_subs.h,v 1.11.2.1 2003/03/28 00:08:47 niklas Exp $	*/
d19 5
a23 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.11.12.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsm_subs.h,v 1.11 2000/01/05 20:50:52 millert Exp $	*/
d377 1
a377 1
		   (void) nfs_rephead(0, nfsd, slp, error, &frev, \
d380 1
a380 1
		   (void) nfs_rephead((s), nfsd, slp, error, &frev, \
d396 1
a396 1
		   (void) nfs_rephead(0, nfsd, slp, error, &frev, \
d399 1
a399 1
		   (void) nfs_rephead((s), nfsd, slp, error, &frev, \
@


1.11.12.2
log
@Huge sync to NetBSD plus lots of bugfixes.
 - uvm is as in netbsd-current minus uvm_map forward merge.
 - various locking bugfixes in nfs.
 - make sure that all specops and fifoops are correct in all vnodeop vectors.
 - make the filesystem code more like filsystem code and less like vm code.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsm_subs.h,v 1.11.12.1 2002/10/29 00:36:49 art Exp $	*/
d172 1
a172 1
			nfsm_loadattr((v), (struct vattr *)0, 0); \
d188 1
a188 1
#define	nfsm_loadattr(v, a, flags) \
d190 1
a190 2
		if ((t1 = nfs_loadattrcache(&ttvp, &md, &dpos, (a), (flags))) \
		    != 0) { \
d197 1
a197 1
#define	nfsm_postop_attr(v, f, flags) \
d202 1
a202 1
				(struct vattr *)0, (flags))) != 0) { \
d215 1
a215 1
#define	nfsm_wcc_data(v, f, flags) \
d224 1
a224 1
		nfsm_postop_attr((v), ttattrf, (flags)); \
@


1.10
log
@Use bitwise operations to extract high and low words from the quad
in txdr_hyper.  This should be more portable than casting to an array
of ints and pulling out the two 32-bit words (this produced incorrect
results on alpha for the high word for filesystems < 4gig).  As a side
effect, txdr_hyper now takes a u_quad_t as its first arg, not u_quad_t *.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsm_subs.h,v 1.9 1999/01/10 20:06:53 millert Exp $	*/
d66 2
a67 2
#define	NFSMSIZ(m)	((M_HASCL(m))?MCLBYTES: \
				(((m)->m_flags & M_PKTHDR)?MHLEN:MLEN))
@


1.9
log
@Fix for creating files on a Solaris 7 server with NFSv3 (the request was
slightly garbled but older servers seemed to understand it); dfr@@freebsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsm_subs.h,v 1.8 1998/08/19 22:26:58 csapuntz Exp $	*/
d260 1
a260 1
			txdr_hyper(&(a)->va_size, tl);				\
@


1.8
log
@

Change fxdr_hyper to return a u_quad_t. This minimizes the evil clobbering
of lvalues that ANSI abhors.

And it fixes df on NFS version 3 mounts on Sparcs.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsm_subs.h,v 1.7 1997/02/24 13:50:04 niklas Exp $	*/
d231 60
a290 10
#define nfsm_v3sattr(s, a) \
		{ (s)->sa_modetrue = nfs_true; \
		(s)->sa_mode = vtonfsv3_mode((a)->va_mode); \
		(s)->sa_uidfalse = nfs_false; \
		(s)->sa_gidfalse = nfs_false; \
		(s)->sa_sizefalse = nfs_false; \
		(s)->sa_atimetype = txdr_unsigned(NFSV3SATTRTIME_TOCLIENT); \
		txdr_nfsv3time(&(a)->va_atime, &(s)->sa_atime); \
		(s)->sa_mtimetype = txdr_unsigned(NFSV3SATTRTIME_TOCLIENT); \
		txdr_nfsv3time(&(a)->va_mtime, &(s)->sa_mtime); \
d292 1
@


1.7
log
@OpenBSD tag
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsm_subs.h,v 1.10 1996/03/20 21:59:56 fvdl Exp $	*/
d418 1
a418 1
			fxdr_hyper(tl, &(a)->va_size); \
@


1.6
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
@


1.5
log
@Minor cleanups. Checked against Lite2.
(NetBSD's was really just a Lite2's, but w/ 64bit support)
@
text
@a0 1
/*	$OpenBSD: nfsm_subs.h,v 1.4 1996/03/31 13:16:09 mickey Exp $	*/
d171 1
a171 1
			nfsm_loadattr((v), (struct vattr *)NULL); \
d201 1
a201 1
				(struct vattr *)NULL)) != 0) { \
@


1.4
log
@From NetBSD: NFSv3 import (tomorrow's Net's kernel)
Open's patches kept in. i'll possibly take a look at Lite2 soon,
is there smth usefull ?..
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsm_subs.h,v 1.3 1996/02/29 09:25:02 niklas Exp $	*/
d172 1
a172 1
			nfsm_loadattr((v), (struct vattr *)0); \
d202 1
a202 1
				(struct vattr *)0)) != 0) { \
@


1.3
log
@From NetBSD: merge with 960217 (still NFSv2)
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: nfsm_subs.h,v 1.8 1996/02/09 21:48:43 christos Exp $	*/
d39 1
a39 1
 *	@@(#)nfsm_subs.h	8.1 (Berkeley) 6/16/93
d42 5
d56 1
d96 1
a96 1
#define	nfsm_dissect(a,c,s) \
d101 2
a102 2
		} else if ((error = nfsm_disct(&md, &dpos, \
					       (s), t1, &cp2)) != 0) { \
d109 61
a169 14
#define nfsm_fhtom(v) \
		nfsm_build(cp,caddr_t,NFSX_FH); \
		bcopy((caddr_t)&(VTONFS(v)->n_fh), cp, NFSX_FH)

#define nfsm_srvfhtom(f) \
		nfsm_build(cp,caddr_t,NFSX_FH); \
		bcopy((caddr_t)(f), cp, NFSX_FH)

#define nfsm_mtofh(d,v) \
		{ struct nfsnode *np; nfsv2fh_t *fhp; \
		nfsm_dissect(fhp,nfsv2fh_t *,NFSX_FH); \
		if ((error = nfs_nget((d)->v_mount, fhp, &np)) != 0) { \
			m_freem(mrep); \
			goto nfsmout; \
d171 2
a172 2
		(v) = NFSTOV(np); \
		nfsm_loadattr(v, (struct vattr *)0); \
d175 17
a191 3
#define	nfsm_loadattr(v,a) \
		{ struct vnode *tvp = (v); \
		if ((error = nfs_loadattrcache(&tvp, &md, &dpos, (a))) != 0) { \
d195 47
a241 1
		(v) = tvp; }
d258 10
d270 2
a271 1
		    (error = nfsm_mbuftouio(&md,(p),(s),&dpos)) != 0) { \
d277 2
a278 1
		if ((error = nfsm_uiotombuf((p),&mb,(s),&bpos)) != 0) { \
d293 6
a298 2
					 (c), &mrep, &md, &dpos)) != 0) \
			goto nfsmout
d312 2
a313 2
		} else if ((error = nfsm_strtmbuf(&mb, &bpos, \
						  (a), (s))) != 0) { \
d325 2
a326 2
		if (error) \
		   (void) nfs_rephead(0, nfsd, error, cache, &frev, \
d329 1
a329 1
		   (void) nfs_rephead((s), nfsd, error, cache, &frev, \
d331 4
a334 1
		m_freem(mrep); \
d336 2
a337 1
		if (error) \
d341 11
d353 1
a353 1
		t1 = mtod(md, caddr_t)+md->m_len-dpos; \
d356 2
a357 1
		} else if ((error = nfs_adv(&md, &dpos, (s), t1)) != 0) { \
d360 1
a360 1
		}
d363 12
a374 2
		nfsm_dissect(tl, u_int32_t *, NFSX_FH); \
		bcopy((caddr_t)tl, (caddr_t)f, NFSX_FH)
d390 52
a441 36
#define	nfsm_srvfillattr \
	fp->fa_type = vtonfs_type(va.va_type); \
	fp->fa_mode = vtonfs_mode(va.va_type, va.va_mode); \
	fp->fa_nlink = txdr_unsigned(va.va_nlink); \
	fp->fa_uid = txdr_unsigned(va.va_uid); \
	fp->fa_gid = txdr_unsigned(va.va_gid); \
	if (nfsd->nd_nqlflag == NQL_NOVAL) { \
		fp->fa_nfsblocksize = txdr_unsigned(va.va_blocksize); \
		if (va.va_type == VFIFO) \
			fp->fa_nfsrdev = 0xffffffff; \
		else \
			fp->fa_nfsrdev = txdr_unsigned(va.va_rdev); \
		fp->fa_nfsfsid = txdr_unsigned(va.va_fsid); \
		fp->fa_nfsfileid = txdr_unsigned(va.va_fileid); \
		fp->fa_nfssize = txdr_unsigned(va.va_size); \
		fp->fa_nfsblocks = txdr_unsigned(va.va_bytes / NFS_FABLKSIZE); \
		txdr_nfstime(&va.va_atime, &fp->fa_nfsatime); \
		txdr_nfstime(&va.va_mtime, &fp->fa_nfsmtime); \
		txdr_nfstime(&va.va_ctime, &fp->fa_nfsctime); \
	} else { \
		fp->fa_nqblocksize = txdr_unsigned(va.va_blocksize); \
		if (va.va_type == VFIFO) \
			fp->fa_nqrdev = 0xffffffff; \
		else \
			fp->fa_nqrdev = txdr_unsigned(va.va_rdev); \
		fp->fa_nqfsid = txdr_unsigned(va.va_fsid); \
		fp->fa_nqfileid = txdr_unsigned(va.va_fileid); \
		txdr_hyper(&va.va_size, &fp->fa_nqsize); \
		txdr_hyper(&va.va_bytes, &fp->fa_nqbytes); \
		txdr_nqtime(&va.va_atime, &fp->fa_nqatime); \
		txdr_nqtime(&va.va_mtime, &fp->fa_nqmtime); \
		txdr_nqtime(&va.va_ctime, &fp->fa_nqctime); \
		fp->fa_nqflags = txdr_unsigned(va.va_flags); \
		fp->fa_nqgen = txdr_unsigned(va.va_gen); \
		txdr_hyper(&va.va_filerev, &fp->fa_nqfilerev); \
	}
d443 1
@


1.2
log
@from cgd; handle 64-bit pointers and longs
@
text
@d1 2
a2 1
/*	$NetBSD: nfsm_subs.h,v 1.7 1995/12/19 23:08:00 cgd Exp $	*/
a50 2
extern struct mbuf *nfsm_reqh();

d95 2
a96 1
		} else if (error = nfsm_disct(&md, &dpos, (s), t1, &cp2)) { \
d114 1
a114 1
		if (error = nfs_nget((d)->v_mount, fhp, &np)) { \
d124 1
a124 1
		if (error = nfs_loadattrcache(&tvp, &md, &dpos, (a))) { \
d147 1
a147 1
		   (error = nfsm_mbuftouio(&md,(p),(s),&dpos))) { \
d153 1
a153 1
		if (error = nfsm_uiotombuf((p),&mb,(s),&bpos)) { \
d167 2
a168 2
		if (error = nfs_request((v), mreq, (t), (p), \
		   (c), &mrep, &md, &dpos)) \
d183 2
a184 1
		} else if (error = nfsm_strtmbuf(&mb, &bpos, (a), (s))) { \
d212 1
a212 1
		} else if (error = nfs_adv(&md, &dpos, (s), t1)) { \
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: nfsm_subs.h,v 1.6 1995/05/23 06:25:30 mycroft Exp $	*/
d131 2
a132 2
		{ nfsm_dissect(tl,u_long *,NFSX_UNSIGNED); \
		if (((s) = fxdr_unsigned(long,*tl)) > (m)) { \
d139 2
a140 2
		{ nfsm_dissect(tl,u_long *,NFSX_UNSIGNED); \
		if (((s) = fxdr_unsigned(long,*tl)) > (m) || (s) <= 0) { \
d179 1
a179 1
			nfsm_build(tl,u_long *,t2); \
d217 1
a217 1
		nfsm_dissect(tl, u_long *, NFSX_FH); \
d232 1
a232 1
		tl = (u_long *)bp
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
