head	1.29;
access;
symbols
	OPENBSD_6_0:1.29.0.4
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.28.0.4
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.22.0.6
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.22.0.4
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.20.0.16
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.14
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.12
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.10
	OPENBSD_5_0:1.20.0.8
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.6
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.4
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.19.0.6
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.2
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.17.0.2
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.14.0.6
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.4
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.2
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.13.0.8
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.6
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.4
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.12.0.14
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.12
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.10
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.8
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.6
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.4
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.12
	UBC:1.12.0.2
	UBC_BASE:1.12
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.16
	OPENBSD_2_8:1.9.0.14
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.12
	OPENBSD_2_7_BASE:1.9
	SMP:1.9.0.10
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.9.0.8
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.6
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.4
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.7.0.4
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.29
date	2015.08.24.14.00.29;	author bluhm;	state Exp;
branches;
next	1.28;
commitid	0LcoZC9QTu9wgpyX;

1.28
date	2015.07.15.22.16.42;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	ncpqEGjDtSFuLAgn;

1.27
date	2015.06.16.11.09.40;	author mpi;	state Exp;
branches;
next	1.26;
commitid	h7z8lokZ0dFyuWpg;

1.26
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.25;
commitid	p4LJxGKbi0BU2cG6;

1.25
date	2014.12.18.20.59.21;	author tedu;	state Exp;
branches;
next	1.24;
commitid	A8MlA6JGDExx7uTs;

1.24
date	2014.11.18.02.37.31;	author tedu;	state Exp;
branches;
next	1.23;
commitid	Z1vcFtHO8wRH0yRt;

1.23
date	2014.11.14.23.01.44;	author tedu;	state Exp;
branches;
next	1.22;
commitid	IWzLFxf7O2DJPe2b;

1.22
date	2013.11.11.09.15.35;	author mpi;	state Exp;
branches;
next	1.21;

1.21
date	2013.08.27.03.32.12;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2009.10.19.22.24.18;	author jsg;	state Exp;
branches;
next	1.19;

1.19
date	2009.02.22.07.47.22;	author otto;	state Exp;
branches;
next	1.18;

1.18
date	2009.01.24.11.33.34;	author thib;	state Exp;
branches;
next	1.17;

1.17
date	2008.06.10.23.15.32;	author blambert;	state Exp;
branches;
next	1.16;

1.16
date	2008.06.09.22.47.42;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2008.05.23.15.51.12;	author thib;	state Exp;
branches;
next	1.14;

1.14
date	2007.02.27.19.09.56;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2004.11.18.15.09.07;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.14.23.37.33;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.27.05.45.00;	author nate;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.16.12.48.32;	author ho;	state Exp;
branches;
next	1.9;

1.9
date	98.02.28.14.03.08;	author deraadt;	state Exp;
branches
	1.9.10.1;
next	1.8;

1.8
date	98.02.23.09.46.53;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.04.27.23.06.01;	author angelos;	state Exp;
branches;
next	1.6;

1.6
date	97.04.25.09.22.34;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.06.10.07.30.04;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.21.22.30.16;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.17.04.50.22;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	95.12.21.14.42.17;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.21;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.21;	author deraadt;	state Exp;
branches;
next	;

1.9.10.1
date	2001.07.04.10.55.44;	author niklas;	state Exp;
branches;
next	1.9.10.2;

1.9.10.2
date	2001.12.05.01.02.40;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.29
log
@In kernel initialize struct sockaddr_in and sockaddr_in6 to zero
everywhere to avoid passing around pointers to uninitialized stack
memory.  While there, fix the call to in6_recoverscope() in
fill_drlist().
OK deraadt@@ mpi@@
@
text
@/*	$OpenBSD: krpc_subr.c,v 1.28 2015/07/15 22:16:42 deraadt Exp $	*/
/*	$NetBSD: krpc_subr.c,v 1.12.4.1 1996/06/07 00:52:26 cgd Exp $	*/

/*
 * Copyright (c) 1995 Gordon Ross, Adam Glass
 * Copyright (c) 1992 Regents of the University of California.
 * All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * partially based on:
 *      libnetboot/rpc.c
 *               @@(#) Header: rpc.c,v 1.12 93/09/28 08:31:56 leres Exp  (LBL)
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/conf.h>
#include <sys/ioctl.h>
#include <sys/proc.h>
#include <sys/mount.h>
#include <sys/mbuf.h>
#include <sys/reboot.h>
#include <sys/socket.h>
#include <sys/socketvar.h>

#include <netinet/in.h>

#include <nfs/rpcv2.h>
#include <nfs/krpc.h>
#include <nfs/xdr_subs.h>
#include <crypto/idgen.h>

/*
 * Kernel support for Sun RPC
 *
 * Used currently for bootstrapping in nfs diskless configurations.
 */

/*
 * Generic RPC headers
 */

struct auth_info {
	u_int32_t 	authtype;	/* auth type */
	u_int32_t	authlen;	/* auth length */
};

struct auth_unix {
	int32_t   ua_time;
	int32_t   ua_hostname;	/* null */
	int32_t   ua_uid;
	int32_t   ua_gid;
	int32_t   ua_gidlist;	/* null */
};

struct rpc_call {
	u_int32_t	rp_xid;		/* request transaction id */
	int32_t 	rp_direction;	/* call direction (0) */
	u_int32_t	rp_rpcvers;	/* rpc version (2) */
	u_int32_t	rp_prog;	/* program */
	u_int32_t	rp_vers;	/* version */
	u_int32_t	rp_proc;	/* procedure */
	struct	auth_info rpc_auth;
	struct	auth_unix rpc_unix;
	struct	auth_info rpc_verf;
};

struct rpc_reply {
	u_int32_t rp_xid;		/* request transaction id */
	int32_t   rp_direction;		/* call direction (1) */
	int32_t   rp_astatus;		/* accept status (0: accepted) */
	union {
		u_int32_t rpu_errno;
		struct {
			struct auth_info rok_auth;
			u_int32_t	rok_status;
		} rpu_rok;
	} rp_u;
};
#define rp_errno  rp_u.rpu_errno
#define rp_auth   rp_u.rpu_rok.rok_auth
#define rp_status rp_u.rpu_rok.rok_status

#define MIN_REPLY_HDR 16	/* xid, dir, astat, errno */

u_int32_t krpc_get_xid(void);

/*
 * Return an unpredictable XID.
 */
u_int32_t
krpc_get_xid(void)
{
	static struct idgen32_ctx krpc_xid_ctx;
	static int called = 0;

	if (!called) {
		called = 1;
		idgen32_init(&krpc_xid_ctx);
	}
	return idgen32(&krpc_xid_ctx);
}

/*
 * What is the longest we will wait before re-sending a request?
 * Note this is also the frequency of "RPC timeout" messages.
 * The re-send loop count sup linearly to this maximum, so the
 * first complaint will happen after (1+2+3+4+5)=15 seconds.
 */
#define	MAX_RESEND_DELAY 5	/* seconds */

/*
 * Call portmap to lookup a port number for a particular rpc program
 * Returns non-zero error on failure.
 */
int
krpc_portmap(struct sockaddr_in *sin, u_int prog, u_int vers, u_int16_t *portp)
{
	struct sdata {
		u_int32_t prog;		/* call program */
		u_int32_t vers;		/* call version */
		u_int32_t proto;	/* call protocol */
		u_int32_t port;		/* call port (unused) */
	} *sdata;
	struct rdata {
		u_int16_t pad;
		u_int16_t port;
	} *rdata;
	struct mbuf *m;
	int error;

	/* The portmapper port is fixed. */
	if (prog == PMAPPROG) {
		*portp = htons(PMAPPORT);
		return 0;
	}

	m = m_get(M_WAIT, MT_DATA);
	sdata = mtod(m, struct sdata *);
	m->m_len = sizeof(*sdata);

	/* Do the RPC to get it. */
	sdata->prog = txdr_unsigned(prog);
	sdata->vers = txdr_unsigned(vers);
	sdata->proto = txdr_unsigned(IPPROTO_UDP);
	sdata->port = 0;

	sin->sin_port = htons(PMAPPORT);
	error = krpc_call(sin, PMAPPROG, PMAPVERS,
	    PMAPPROC_GETPORT, &m, NULL, -1);
	if (error) 
		return error;

	if (m->m_len < sizeof(*rdata)) {
		m = m_pullup(m, sizeof(*rdata));
		if (m == NULL)
			return ENOBUFS;
	}
	rdata = mtod(m, struct rdata *);
	*portp = rdata->port;

	m_freem(m);
	return 0;
}

/*
 * Do a remote procedure call (RPC) and wait for its reply.
 * If from_p is non-null, then we are doing broadcast, and
 * the address from whence the response came is saved there.
 * data:	input/output
 * from_p:	output
 */
int
krpc_call(struct sockaddr_in *sa, u_int prog, u_int vers, u_int func,
    struct mbuf **data, struct mbuf **from_p, int retries)
{
	struct socket *so;
	struct sockaddr_in *sin;
	struct mbuf *m, *nam, *mhead, *from, *mopt;
	struct rpc_call *call;
	struct rpc_reply *reply;
	struct uio auio;
	int error, rcvflg, timo, secs, len;
	static u_int32_t xid = 0;
	char addr[INET_ADDRSTRLEN];
	int *ip;
	struct timeval tv;

	/*
	 * Validate address family.
	 * Sorry, this is INET specific...
	 */
	if (sa->sin_family != AF_INET)
		return (EAFNOSUPPORT);

	/* Free at end if not null. */
	nam = mhead = NULL;
	from = NULL;

	/*
	 * Create socket and set its receive timeout.
	 */
	if ((error = socreate(AF_INET, &so, SOCK_DGRAM, 0)))
		goto out;

	m = m_get(M_WAIT, MT_SOOPTS);
	tv.tv_sec = 1;
	tv.tv_usec = 0;
	memcpy(mtod(m, struct timeval *), &tv, sizeof tv);
	m->m_len = sizeof(tv);
	if ((error = sosetopt(so, SOL_SOCKET, SO_RCVTIMEO, m)))
		goto out;

	/*
	 * Enable broadcast if necessary.
	 */
	if (from_p) {
		int32_t *on;
		m = m_get(M_WAIT, MT_SOOPTS);
		on = mtod(m, int32_t *);
		m->m_len = sizeof(*on);
		*on = 1;
		if ((error = sosetopt(so, SOL_SOCKET, SO_BROADCAST, m)))
			goto out;
	}

	/*
	 * Bind the local endpoint to a reserved port,
	 * because some NFS servers refuse requests from
	 * non-reserved (non-privileged) ports.
	 */
	MGET(mopt, M_WAIT, MT_SOOPTS);
	mopt->m_len = sizeof(int);
	ip = mtod(mopt, int *);
	*ip = IP_PORTRANGE_LOW;
	error = sosetopt(so, IPPROTO_IP, IP_PORTRANGE, mopt);
	if (error)
		goto out;

	MGET(m, M_WAIT, MT_SONAME);
	sin = mtod(m, struct sockaddr_in *);
	memset(sin, 0, sizeof(*sin));
	sin->sin_len = m->m_len = sizeof(struct sockaddr_in);
	sin->sin_family = AF_INET;
	sin->sin_addr.s_addr = INADDR_ANY;
	sin->sin_port = htons(0);
	error = sobind(so, m, &proc0);
	m_freem(m);
	if (error) {
		printf("bind failed\n");
		goto out;
	}

	MGET(mopt, M_WAIT, MT_SOOPTS);
	mopt->m_len = sizeof(int);
	ip = mtod(mopt, int *);
	*ip = IP_PORTRANGE_DEFAULT;
	error = sosetopt(so, IPPROTO_IP, IP_PORTRANGE, mopt);
	if (error)
		goto out;

	/*
	 * Setup socket address for the server.
	 */
	nam = m_get(M_WAIT, MT_SONAME);
	sin = mtod(nam, struct sockaddr_in *);
	bcopy(sa, sin, (nam->m_len = sa->sin_len));

	/*
	 * Prepend RPC message header.
	 */
	mhead = m_gethdr(M_WAIT, MT_DATA);
	mhead->m_next = *data;
	call = mtod(mhead, struct rpc_call *);
	mhead->m_len = sizeof(*call);
	memset(call, 0, sizeof(*call));
	/* rpc_call part */
	xid = krpc_get_xid();
	call->rp_xid = txdr_unsigned(xid);
	/* call->rp_direction = 0; */
	call->rp_rpcvers = txdr_unsigned(2);
	call->rp_prog = txdr_unsigned(prog);
	call->rp_vers = txdr_unsigned(vers);
	call->rp_proc = txdr_unsigned(func);
	/* rpc_auth part (auth_unix as root) */
	call->rpc_auth.authtype = txdr_unsigned(RPCAUTH_UNIX);
	call->rpc_auth.authlen  = txdr_unsigned(sizeof(struct auth_unix));
	/* rpc_verf part (auth_null) */
	call->rpc_verf.authtype = 0;
	call->rpc_verf.authlen  = 0;

	/*
	 * Setup packet header
	 */
	len = 0;
	m = mhead;
	while (m) {
		len += m->m_len;
		m = m->m_next;
	}
	mhead->m_pkthdr.len = len;
	mhead->m_pkthdr.ph_ifidx = 0;

	/*
	 * Send it, repeatedly, until a reply is received,
	 * but delay each re-send by an increasing amount.
	 * If the delay hits the maximum, start complaining.
	 */
	for (timo = 0; retries; retries--) {
		/* Send RPC request (or re-send). */
		m = m_copym(mhead, 0, M_COPYALL, M_WAIT);
		if (m == NULL) {
			error = ENOBUFS;
			goto out;
		}
		error = sosend(so, nam, NULL, m, NULL, 0);
		if (error) {
			printf("krpc_call: sosend: %d\n", error);
			goto out;
		}
		m = NULL;

		/* Determine new timeout. */
		if (timo < MAX_RESEND_DELAY)
			timo++;
		else
			printf("RPC timeout for server %s (0x%x) prog %u\n",
			    inet_ntop(AF_INET, &sin->sin_addr,
				addr, sizeof(addr)),
			    ntohl(sin->sin_addr.s_addr), prog);

		/*
		 * Wait for up to timo seconds for a reply.
		 * The socket receive timeout was set to 1 second.
		 */
		secs = timo;
		while (secs > 0) {
			m_freem(from);
			from = NULL;

			m_freem(m);
			m = NULL;

			auio.uio_resid = len = 1<<16;
			auio.uio_procp = NULL;
			rcvflg = 0;
			error = soreceive(so, &from, &auio, &m, NULL, &rcvflg,
			    0);
			if (error == EWOULDBLOCK) {
				secs--;
				continue;
			}
			if (error)
				goto out;
			len -= auio.uio_resid;

			/* Does the reply contain at least a header? */
			if (len < MIN_REPLY_HDR)
				continue;
			if (m->m_len < MIN_REPLY_HDR)
				continue;
			reply = mtod(m, struct rpc_reply *);

			/* Is it the right reply? */
			if (reply->rp_direction != txdr_unsigned(RPC_REPLY))
				continue;

			if (reply->rp_xid != txdr_unsigned(xid))
				continue;

			/* Was RPC accepted? (authorization OK) */
			if (reply->rp_astatus != 0) {
				error = fxdr_unsigned(u_int32_t, reply->rp_errno);
				printf("rpc denied, error=%d\n", error);
				continue;
			}

			/* Did the call succeed? */
			if (reply->rp_status != 0) {
				error = fxdr_unsigned(u_int32_t, reply->rp_status);
				printf("rpc denied, status=%d\n", error);
				continue;
			}

			goto gotreply;	/* break two levels */

		} /* while secs */
	} /* forever send/receive */

	error = ETIMEDOUT;
	goto out;

 gotreply:

	/*
	 * Get RPC reply header into first mbuf,
	 * get its length, then strip it off.
	 */
	len = sizeof(*reply);
	if (m->m_len < len) {
		m = m_pullup(m, len);
		if (m == NULL) {
			error = ENOBUFS;
			goto out;
		}
	}
	reply = mtod(m, struct rpc_reply *);
	if (reply->rp_auth.authtype != 0) {
		len += fxdr_unsigned(u_int32_t, reply->rp_auth.authlen);
		len = (len + 3) & ~3; /* XXX? */
	}
	m_adj(m, len);

	/* result */
	*data = m;
	if (from_p && error == 0) {
		*from_p = from;
		from = NULL;
	}

 out:
	m_freem(nam);
	m_freem(mhead);
	m_freem(from);
	soclose(so);
	return error;
}

/*
 * eXternal Data Representation routines.
 * (but with non-standard args...)
 */

/*
 * String representation for RPC.
 */
struct xdr_string {
	u_int32_t len;		/* length without null or padding */
	char data[4];	/* data (longer, of course) */
    /* data is padded to a long-word boundary */
};

struct mbuf *
xdr_string_encode(char *str, int len)
{
	struct mbuf *m;
	struct xdr_string *xs;
	int dlen;	/* padded string length */
	int mlen;	/* message length */

	dlen = (len + 3) & ~3;
	mlen = dlen + 4;

	if (mlen > MCLBYTES)		/* If too big, we just can't do it. */
		return (NULL);

	m = m_get(M_WAIT, MT_DATA);
	if (mlen > MLEN) {
		MCLGET(m, M_WAIT);
		if ((m->m_flags & M_EXT) == 0) {
			(void) m_free(m);	/* There can be only one. */
			return (NULL);
		}
	}
	xs = mtod(m, struct xdr_string *);
	m->m_len = mlen;
	xs->len = txdr_unsigned(len);
	bcopy(str, xs->data, len);
	return (m);
}

struct mbuf *
xdr_string_decode(struct mbuf *m, char *str, int *len_p)
{
	struct xdr_string *xs;
	int mlen;	/* message length */
	int slen;	/* string length */

	if (m->m_len < 4) {
		m = m_pullup(m, 4);
		if (m == NULL)
			return (NULL);
	}
	xs = mtod(m, struct xdr_string *);
	slen = fxdr_unsigned(u_int32_t, xs->len);
	mlen = 4 + ((slen + 3) & ~3);

	if (slen > *len_p)
		slen = *len_p;
	if (slen > m->m_pkthdr.len) {
		m_freem(m);
		return (NULL);
	}
	m_copydata(m, 4, slen, str);
	m_adj(m, mlen);

	str[slen] = '\0';
	*len_p = slen;

	return (m);
}


/*
 * Inet address in RPC messages
 * (Note, really four ints, NOT chars.  Blech.)
 */
struct xdr_inaddr {
	u_int32_t atype;
	u_int32_t addr[4];
};

struct mbuf *
xdr_inaddr_encode(struct in_addr *ia)
{
	struct mbuf *m;
	struct xdr_inaddr *xi;
	u_int8_t *cp;
	u_int32_t *ip;

	m = m_get(M_WAIT, MT_DATA);
	xi = mtod(m, struct xdr_inaddr *);
	m->m_len = sizeof(*xi);
	xi->atype = txdr_unsigned(1);
	ip = xi->addr;
	cp = (u_int8_t *)&ia->s_addr;
	*ip++ = txdr_unsigned(*cp++);
	*ip++ = txdr_unsigned(*cp++);
	*ip++ = txdr_unsigned(*cp++);
	*ip++ = txdr_unsigned(*cp++);

	return (m);
}

struct mbuf *
xdr_inaddr_decode(struct mbuf *m, struct in_addr *ia)
{
	struct xdr_inaddr *xi;
	u_int8_t *cp;
	u_int32_t *ip;

	if (m->m_len < sizeof(*xi)) {
		m = m_pullup(m, sizeof(*xi));
		if (m == NULL)
			return (NULL);
	}
	xi = mtod(m, struct xdr_inaddr *);
	if (xi->atype != txdr_unsigned(1)) {
		ia->s_addr = INADDR_ANY;
		goto out;
	}
	ip = xi->addr;
	cp = (u_int8_t *)&ia->s_addr;
	*cp++ = fxdr_unsigned(u_int8_t, *ip++);
	*cp++ = fxdr_unsigned(u_int8_t, *ip++);
	*cp++ = fxdr_unsigned(u_int8_t, *ip++);
	*cp++ = fxdr_unsigned(u_int8_t, *ip++);

out:
	m_adj(m, sizeof(*xi));
	return (m);
}
@


1.28
log
@m_freem() can handle NULL, do not check for this condition beforehands.
ok stsp mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: krpc_subr.c,v 1.27 2015/06/16 11:09:40 mpi Exp $	*/
d273 2
a274 1
	sin->sin_len = m->m_len = sizeof (struct sockaddr_in);
@


1.27
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: krpc_subr.c,v 1.26 2015/03/14 03:38:52 jsg Exp $	*/
d368 6
a373 8
			if (from) {
				m_freem(from);
				from = NULL;
			}
			if (m) {
				m_freem(m);
				m = NULL;
			}
d452 3
a454 3
	if (nam) m_freem(nam);
	if (mhead) m_freem(mhead);
	if (from) m_freem(from);
@


1.26
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: krpc_subr.c,v 1.25 2014/12/18 20:59:21 tedu Exp $	*/
d332 1
a332 1
	mhead->m_pkthdr.rcvif = NULL;
@


1.25
log
@delete a whole mess of unnecessary caddr_t casts
@
text
@d1 1
a1 1
/*	$OpenBSD: krpc_subr.c,v 1.24 2014/11/18 02:37:31 tedu Exp $	*/
a56 1
#include <net/if.h>
@


1.24
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: krpc_subr.c,v 1.23 2014/11/14 23:01:44 tedu Exp $	*/
d298 1
a298 1
	bcopy((caddr_t)sa, (caddr_t)sin, (nam->m_len = sa->sin_len));
@


1.23
log
@bzero -> memset
@
text
@d1 1
a1 1
/*	$OpenBSD: krpc_subr.c,v 1.22 2013/11/11 09:15:35 mpi Exp $	*/
a62 1
#include <dev/rndvar.h>
@


1.22
log
@Replace most of our formating functions to convert IPv4/6 addresses from
network to presentation format to inet_ntop().

The few remaining functions will be soon converted.

ok mikeb@@, deraadt@@ and moral support from henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: krpc_subr.c,v 1.21 2013/08/27 03:32:12 deraadt Exp $	*/
d308 1
a308 1
	bzero((caddr_t)call, sizeof(*call));
@


1.21
log
@Manipulate timevals seperately, not inside a mbuf.  Alignment constraints
miod ran into.
ok miod matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: krpc_subr.c,v 1.20 2009/10/19 22:24:18 jsg Exp $	*/
d218 1
d360 2
a361 1
			    inet_ntoa(sin->sin_addr),
@


1.20
log
@antsy
no binary change apart from nfsm_reqhead() which is clearly correct.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: krpc_subr.c,v 1.19 2009/02/22 07:47:22 otto Exp $	*/
d219 1
a219 1
	struct timeval *tv;
d239 4
a242 4
	tv = mtod(m, struct timeval *);
	m->m_len = sizeof(*tv);
	tv->tv_sec = 1;
	tv->tv_usec = 0;
@


1.19
log
@fix PR 6082: do not create more fd's than will fit in the message on
the receiving side when passing fd's. ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: krpc_subr.c,v 1.18 2009/01/24 11:33:34 thib Exp $	*/
d150 1
a150 4
krpc_portmap(sin,  prog, vers, portp)
	struct sockaddr_in *sin;		/* server address */
	u_int prog, vers;	/* host order */
	u_int16_t *portp;	/* network order */
d203 2
d207 2
a208 6
krpc_call(sa, prog, vers, func, data, from_p, retries)
	struct sockaddr_in *sa;
	u_int prog, vers, func;
	struct mbuf **data;	/* input/output */
	struct mbuf **from_p;	/* output */
	int retries;
d476 1
a476 3
xdr_string_encode(str, len)
	char *str;
	int len;
d505 1
a505 4
xdr_string_decode(m, str, len_p)
	struct mbuf *m;
	char *str;
	int *len_p;		/* bufsize - 1 */
d546 1
a546 2
xdr_inaddr_encode(ia)
	struct in_addr *ia;		/* already in network order */
d568 1
a568 3
xdr_inaddr_decode(m, ia)
	struct mbuf *m;
	struct in_addr *ia;		/* already in network order */
@


1.18
log
@make sure the from mbuf gets freed on error to.

from David <dunnoseriously _att_ gmail.com>
ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: krpc_subr.c,v 1.17 2008/06/10 23:15:32 blambert Exp $	*/
d384 2
a385 1
			error = soreceive(so, &from, &auio, &m, NULL, &rcvflg);
@


1.17
log
@Remove redundant code that only leaked an mbuf.

ok krw@@, deraadt@@, thib@@

earlier commit for some reason did not go through
prodded by nfs buddy
@
text
@d1 1
a1 1
/*	$OpenBSD: krpc_subr.c,v 1.16 2008/06/09 22:47:42 djm Exp $	*/
d452 1
a452 1
	if (from_p) {
@


1.16
log
@Introduce a facility to generate unpredictable 32 bit numbers with
near maximal (2^32) cycle times. These are useful for network
IDs in cases where there are negative consequences to ID prediction
and/or reuse.

Use the idgen32() functions to generate IPv6 IDs and NFS client/server
XIDs.

Pseudorandom permutation code in crypto/idgen.c based on public
domain skip32.c from Greg Rose.

feedback & ok thib@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: krpc_subr.c,v 1.15 2008/05/23 15:51:12 thib Exp $	*/
a268 6
	m = m_getclr(M_WAIT, MT_SONAME);
	sin = mtod(m, struct sockaddr_in *);
	sin->sin_len = m->m_len = sizeof(*sin);
	sin->sin_family = AF_INET;
	sin->sin_addr.s_addr = INADDR_ANY;

@


1.15
log
@Deal with the situation when TCP nfs mounts timeout and processes
get hung in nfs_reconnect() because they do not have the proper
privilages to bind to a socket, by adding a struct proc * argument
to sobind() (and the *_usrreq() routines, and finally in{6}_pcbbind)
and do the sobind() with proc0 in nfs_connect.

OK markus@@, blambert@@.
"go ahead" deraadt@@.

Fixes an issue reported by bernd@@ (Tested by bernd@@).
Fixes PR5135 too.
@
text
@d1 1
a1 1
/*	$OpenBSD: krpc_subr.c,v 1.14 2007/02/27 19:09:56 deraadt Exp $	*/
d64 1
d119 18
a222 1
	u_int32_t newxid;
d320 1
a320 2
	while ((newxid = arc4random()) == xid);
	xid = newxid;
@


1.14
log
@clarify RPC timeout messages so regular people can understand; ok various
@
text
@d1 1
a1 1
/*	$OpenBSD: krpc_subr.c,v 1.13 2004/11/18 15:09:07 markus Exp $	*/
d271 1
a271 1
	error = sobind(so, m);
@


1.13
log
@enable receive() accounting and use uio_procp for send() accounting, too
ok deraadt, jared, djm
@
text
@d1 1
a1 1
/*	$OpenBSD: krpc_subr.c,v 1.12 2001/11/14 23:37:33 mickey Exp $	*/
d352 3
a354 2
			printf("RPC timeout for server 0x%x\n",
			       ntohl(sin->sin_addr.s_addr));
@


1.12
log
@allow swaples diskless configs; deradt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: krpc_subr.c,v 1.11 2001/06/27 05:45:00 nate Exp $	*/
d370 1
@


1.11
log
@recieve -> receive
@
text
@d1 1
a1 1
/*	$OpenBSD: krpc_subr.c,v 1.10 2001/05/16 12:48:32 ho Exp $	*/
d167 1
a167 1
	    PMAPPROC_GETPORT, &m, NULL);
d189 1
a189 1
krpc_call(sa, prog, vers, func, data, from_p)
d194 1
d334 1
a334 2
	timo = 0;
	for (;;) {
@


1.10
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: krpc_subr.c,v 1.9 1998/02/28 14:03:08 deraadt Exp $	*/
d219 1
a219 1
	 * Create socket and set its recieve timeout.
@


1.9
log
@krpc_call() should use random reserved ports
@
text
@d1 1
a1 1
/*	$OpenBSD: krpc_subr.c,v 1.8 1998/02/23 09:46:53 deraadt Exp $	*/
a155 2
	if (m == NULL)
		return ENOBUFS;
d205 1
d225 5
a229 2
	if (m == NULL) {
		error = ENOBUFS;
a230 9
	} else {
		struct timeval *tv;
		tv = mtod(m, struct timeval *);
		m->m_len = sizeof(*tv);
		tv->tv_sec = 1;
		tv->tv_usec = 0;
		if ((error = sosetopt(so, SOL_SOCKET, SO_RCVTIMEO, m)))
			goto out;
	}
a237 4
		if (m == NULL) {
			error = ENOBUFS;
			goto out;
		}
a288 4
	if (nam == NULL) {
		error = ENOBUFS;
		goto out;
	}
@


1.9.10.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: krpc_subr.c,v 1.9 1998/02/28 14:03:08 deraadt Exp $	*/
d156 2
a206 1
	struct timeval *tv;
d220 1
a220 1
	 * Create socket and set its receive timeout.
d226 2
a227 5
	tv = mtod(m, struct timeval *);
	m->m_len = sizeof(*tv);
	tv->tv_sec = 1;
	tv->tv_usec = 0;
	if ((error = sosetopt(so, SOL_SOCKET, SO_RCVTIMEO, m)))
d229 9
d245 4
d300 4
@


1.9.10.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d167 1
a167 1
	    PMAPPROC_GETPORT, &m, NULL, -1);
d189 1
a189 1
krpc_call(sa, prog, vers, func, data, from_p, retries)
a193 1
	int retries;
d333 2
a334 1
	for (timo = 0; retries; retries--) {
@


1.8
log
@do not copy from past end of mbuf; found by ivan
@
text
@d1 1
a1 1
/*	$OpenBSD: krpc_subr.c,v 1.7 1997/04/27 23:06:01 angelos Exp $	*/
d169 1
a169 1
					  PMAPPROC_GETPORT, &m, NULL);
d199 1
a199 1
	struct mbuf *m, *nam, *mhead, *from;
d206 1
a206 1
	u_int16_t tport;
d266 16
a281 8
	/* XXX should do random allocation */
	tport = IPPORT_RESERVED;
	do {
		tport--;
		sin->sin_port = htons(tport);
		error = sobind(so, m);
	} while (error == EADDRINUSE &&
			 tport > IPPORT_RESERVED / 2);
d288 8
d305 1
a305 2
	bcopy((caddr_t)sa, (caddr_t)sin,
		  (nam->m_len = sa->sin_len));
@


1.7
log
@Randomize RPC xid.
@
text
@d1 1
a1 1
/*	$OpenBSD: krpc_subr.c,v 1.5 1996/06/10 07:30:04 deraadt Exp $	*/
d518 4
@


1.6
log
@XXX should do reserved ports
@
text
@d63 1
d204 2
a205 1
	static u_int32_t xid = ~0xFF;
d301 2
a302 1
	xid++;
@


1.5
log
@do not lose an mbuf, ensure MCLGET did not give a chain
@
text
@d1 1
a1 1
/*	$OpenBSD: krpc_subr.c,v 1.3 1996/04/17 04:50:22 mickey Exp $	*/
d264 1
@


1.4
log
@partial sync with netbsd 960418, more to come
@
text
@d2 1
a2 1
/*	$NetBSD: krpc_subr.c,v 1.12 1996/02/18 11:53:36 fvdl Exp $	*/
d475 3
a479 2
		if (mlen > MCLBYTES)
			return(NULL);
d481 4
a484 2
		if (m == NULL)
			return NULL;
@


1.3
log
@Minor cleanups. Checked against Lite2.
(NetBSD's was really just a Lite2's, but w/ 64bit support)
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: krpc_subr.c,v 1.11 1995/12/19 23:07:19 cgd Exp $	*/
@


1.2
log
@from cgd; handle 64-bit pointers and longs
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: krpc_subr.c,v 1.10 1995/08/08 20:43:43 gwr Exp $	*/
d99 3
a101 3
	u_int32_t	rp_xid;		/* request transaction id */
	int32_t 	rp_direction;	/* call direction (1) */
	int32_t 	rp_astatus;	/* accept status (0: accepted) */
d103 1
a103 1
		u_int32_t	rpu_errno;
d132 1
a132 1
	u_int16_t *portp;		/* network order */
d135 4
a138 4
		u_int32_t	prog;		/* call program */
		u_int32_t	vers;		/* call version */
		u_int32_t	proto;		/* call protocol */
		u_int32_t	port;		/* call port (unused) */
d203 1
a203 1
	u_int tport;
d240 1
a240 1
		int *on;
d246 1
a246 1
		on = mtod(m, int *);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

