head	1.65;
access;
symbols
	OPENBSD_6_2_BASE:1.65
	OPENBSD_6_1:1.65.0.4
	OPENBSD_6_1_BASE:1.65
	OPENBSD_6_0:1.64.0.2
	OPENBSD_6_0_BASE:1.64
	OPENBSD_5_9:1.63.0.2
	OPENBSD_5_9_BASE:1.63
	OPENBSD_5_8:1.62.0.4
	OPENBSD_5_8_BASE:1.62
	OPENBSD_5_7:1.61.0.2
	OPENBSD_5_7_BASE:1.61
	OPENBSD_5_6:1.56.0.4
	OPENBSD_5_6_BASE:1.56
	OPENBSD_5_5:1.55.0.16
	OPENBSD_5_5_BASE:1.55
	OPENBSD_5_4:1.55.0.12
	OPENBSD_5_4_BASE:1.55
	OPENBSD_5_3:1.55.0.10
	OPENBSD_5_3_BASE:1.55
	OPENBSD_5_2:1.55.0.8
	OPENBSD_5_2_BASE:1.55
	OPENBSD_5_1_BASE:1.55
	OPENBSD_5_1:1.55.0.6
	OPENBSD_5_0:1.55.0.4
	OPENBSD_5_0_BASE:1.55
	OPENBSD_4_9:1.55.0.2
	OPENBSD_4_9_BASE:1.55
	OPENBSD_4_8:1.52.0.2
	OPENBSD_4_8_BASE:1.52
	OPENBSD_4_7:1.51.0.2
	OPENBSD_4_7_BASE:1.51
	OPENBSD_4_6:1.44.0.6
	OPENBSD_4_6_BASE:1.44
	OPENBSD_4_5:1.44.0.2
	OPENBSD_4_5_BASE:1.44
	OPENBSD_4_4:1.40.0.2
	OPENBSD_4_4_BASE:1.40
	OPENBSD_4_3:1.37.0.2
	OPENBSD_4_3_BASE:1.37
	OPENBSD_4_2:1.35.0.2
	OPENBSD_4_2_BASE:1.35
	OPENBSD_4_1:1.32.0.4
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.32.0.2
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.31.0.2
	OPENBSD_3_9_BASE:1.31
	OPENBSD_3_8:1.28.0.4
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.28.0.2
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.27.0.2
	OPENBSD_3_6_BASE:1.27
	SMP_SYNC_A:1.26
	SMP_SYNC_B:1.26
	OPENBSD_3_5:1.26.0.4
	OPENBSD_3_5_BASE:1.26
	OPENBSD_3_4:1.26.0.2
	OPENBSD_3_4_BASE:1.26
	UBC_SYNC_A:1.25
	OPENBSD_3_3:1.25.0.4
	OPENBSD_3_3_BASE:1.25
	OPENBSD_3_2:1.25.0.2
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.24.0.2
	OPENBSD_3_1_BASE:1.24
	UBC_SYNC_B:1.25
	UBC:1.18.0.2
	UBC_BASE:1.18
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.10
	OPENBSD_2_8:1.13.0.8
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.13.0.6
	OPENBSD_2_7_BASE:1.13
	SMP:1.13.0.4
	SMP_BASE:1.13
	kame_19991208:1.13
	OPENBSD_2_6:1.13.0.2
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.12.0.4
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.65
date	2016.09.27.01.37.38;	author dlg;	state Exp;
branches;
next	1.64;
commitid	HwDxz9mxZKQUWHxT;

1.64
date	2016.03.19.12.04.16;	author natano;	state Exp;
branches;
next	1.63;
commitid	gAjwyca5TfuoJAhn;

1.63
date	2016.02.09.00.56.04;	author mmcc;	state Exp;
branches;
next	1.62;
commitid	uu9IVc2iTxfFOx3V;

1.62
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.61;
commitid	p4LJxGKbi0BU2cG6;

1.61
date	2014.12.23.07.54.13;	author tedu;	state Exp;
branches;
next	1.60;
commitid	jF3vn9OZllBIR3jn;

1.60
date	2014.12.23.04.48.47;	author tedu;	state Exp;
branches;
next	1.59;
commitid	zO23WPquCE0mDXU1;

1.59
date	2014.12.16.18.30.04;	author tedu;	state Exp;
branches;
next	1.58;
commitid	P6Av4XGqOi3rFasL;

1.58
date	2014.11.15.00.03.12;	author tedu;	state Exp;
branches;
next	1.57;
commitid	DARBwcixOE2oqaWx;

1.57
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.56;
commitid	uzzBR7hz9ncd4O6G;

1.56
date	2014.07.12.18.43.52;	author tedu;	state Exp;
branches;
next	1.55;
commitid	FE3DG5cICjyI4jWx;

1.55
date	2010.12.21.20.14.43;	author thib;	state Exp;
branches;
next	1.54;

1.54
date	2010.09.10.16.34.09;	author thib;	state Exp;
branches;
next	1.53;

1.53
date	2010.09.06.23.44.10;	author thib;	state Exp;
branches;
next	1.52;

1.52
date	2010.08.07.03.50.02;	author krw;	state Exp;
branches;
next	1.51;

1.51
date	2009.12.17.16.30.47;	author beck;	state Exp;
branches;
next	1.50;

1.50
date	2009.12.15.17.04.00;	author beck;	state Exp;
branches;
next	1.49;

1.49
date	2009.12.15.16.20.07;	author beck;	state Exp;
branches;
next	1.48;

1.48
date	2009.08.14.17.52.18;	author thib;	state Exp;
branches;
next	1.47;

1.47
date	2009.08.11.17.06.11;	author thib;	state Exp;
branches;
next	1.46;

1.46
date	2009.08.10.10.59.12;	author thib;	state Exp;
branches;
next	1.45;

1.45
date	2009.07.20.16.49.40;	author thib;	state Exp;
branches;
next	1.44;

1.44
date	2008.12.24.02.43.52;	author thib;	state Exp;
branches;
next	1.43;

1.43
date	2008.12.23.21.56.12;	author thib;	state Exp;
branches;
next	1.42;

1.42
date	2008.08.09.10.14.02;	author thib;	state Exp;
branches;
next	1.41;

1.41
date	2008.08.08.20.40.24;	author blambert;	state Exp;
branches;
next	1.40;

1.40
date	2008.06.14.10.55.21;	author mk;	state Exp;
branches;
next	1.39;

1.39
date	2008.06.11.04.52.27;	author blambert;	state Exp;
branches;
next	1.38;

1.38
date	2008.06.10.22.59.09;	author thib;	state Exp;
branches;
next	1.37;

1.37
date	2007.12.13.22.32.55;	author thib;	state Exp;
branches;
next	1.36;

1.36
date	2007.09.20.12.54.31;	author thib;	state Exp;
branches;
next	1.35;

1.35
date	2007.06.01.23.47.57;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2007.05.29.00.17.33;	author thib;	state Exp;
branches;
next	1.33;

1.33
date	2007.05.28.21.07.31;	author thib;	state Exp;
branches;
next	1.32;

1.32
date	2006.05.07.20.12.41;	author tedu;	state Exp;
branches;
next	1.31;

1.31
date	2006.01.09.12.43.16;	author pedro;	state Exp;
branches;
next	1.30;

1.30
date	2005.11.19.15.48.04;	author pedro;	state Exp;
branches;
next	1.29;

1.29
date	2005.11.19.02.18.01;	author pedro;	state Exp;
branches;
next	1.28;

1.28
date	2004.12.26.21.22.13;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2004.08.03.17.11.48;	author marius;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.02.23.28.19;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2002.07.02.04.23.25;	author ericj;	state Exp;
branches;
next	1.24;

1.24
date	2002.03.14.01.27.13;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2002.02.23.23.47.13;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2002.02.22.20.19.14;	author csapuntz;	state Exp;
branches;
next	1.21;

1.21
date	2002.01.23.00.39.48;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2002.01.16.21.51.16;	author ericj;	state Exp;
branches;
next	1.19;

1.19
date	2001.12.19.08.58.06;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.01.01.44.35;	author art;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2001.11.27.05.27.12;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.15.23.15.15;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.25.03.28.06;	author csapuntz;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.24.21.16.19;	author csapuntz;	state Exp;
branches;
next	1.13;

1.13
date	99.04.28.09.28.17;	author art;	state Exp;
branches
	1.13.4.1;
next	1.12;

1.12
date	98.08.21.23.16.39;	author csapuntz;	state Exp;
branches;
next	1.11;

1.11
date	98.08.06.19.34.58;	author csapuntz;	state Exp;
branches;
next	1.10;

1.10
date	97.11.06.05.59.00;	author csapuntz;	state Exp;
branches;
next	1.9;

1.9
date	97.10.06.20.20.45;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.10.06.15.23.41;	author csapuntz;	state Exp;
branches;
next	1.7;

1.7
date	97.04.18.10.09.46;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.04.21.22.30.19;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.04.17.04.50.25;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.03.31.13.15.36;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.02.29.09.24.50;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.21.14.42.20;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.22;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.22;	author deraadt;	state Exp;
branches;
next	;

1.13.4.1
date	2001.07.04.10.55.46;	author niklas;	state Exp;
branches;
next	1.13.4.2;

1.13.4.2
date	2001.12.05.01.02.40;	author niklas;	state Exp;
branches;
next	1.13.4.3;

1.13.4.3
date	2002.03.06.02.17.12;	author niklas;	state Exp;
branches;
next	1.13.4.4;

1.13.4.4
date	2002.03.28.15.02.48;	author niklas;	state Exp;
branches;
next	1.13.4.5;

1.13.4.5
date	2003.03.28.00.08.46;	author niklas;	state Exp;
branches;
next	1.13.4.6;

1.13.4.6
date	2003.06.07.11.07.43;	author ho;	state Exp;
branches;
next	;

1.18.2.1
date	2002.01.31.22.55.47;	author niklas;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2002.02.02.03.28.26;	author art;	state Exp;
branches;
next	1.18.2.3;

1.18.2.3
date	2002.06.11.03.32.03;	author art;	state Exp;
branches;
next	1.18.2.4;

1.18.2.4
date	2002.10.29.00.36.49;	author art;	state Exp;
branches;
next	1.18.2.5;

1.18.2.5
date	2002.10.29.18.31.51;	author art;	state Exp;
branches;
next	1.18.2.6;

1.18.2.6
date	2002.11.04.18.02.32;	author art;	state Exp;
branches;
next	;


desc
@@


1.65
log
@replace the use of RB macros with the RBT functions.
@
text
@/*	$OpenBSD: nfs_node.c,v 1.64 2016/03/19 12:04:16 natano Exp $	*/
/*	$NetBSD: nfs_node.c,v 1.16 1996/02/18 11:53:42 fvdl Exp $	*/

/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Rick Macklem at The University of Guelph.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)nfs_node.c	8.6 (Berkeley) 5/22/95
 */


#include <sys/param.h>
#include <sys/systm.h>
#include <sys/timeout.h>
#include <sys/mount.h>
#include <sys/namei.h>
#include <sys/vnode.h>
#include <sys/lock.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/pool.h>
#include <sys/rwlock.h>
#include <sys/queue.h>

#include <nfs/rpcv2.h>
#include <nfs/nfsproto.h>
#include <nfs/nfsnode.h>
#include <nfs/nfsmount.h>
#include <nfs/nfs_var.h>

struct pool nfs_node_pool;
extern int prtactive;

struct rwlock nfs_hashlock = RWLOCK_INITIALIZER("nfshshlk");

/* XXX */
extern struct vops nfs_vops;

/* filehandle to node lookup. */
static __inline int
nfsnode_cmp(const struct nfsnode *a, const struct nfsnode *b)
{
	if (a->n_fhsize != b->n_fhsize)
		return (a->n_fhsize - b->n_fhsize);
	return (memcmp(a->n_fhp, b->n_fhp, a->n_fhsize));
}

RBT_PROTOTYPE(nfs_nodetree, nfsnode, n_entry, nfsnode_cmp);
RBT_GENERATE(nfs_nodetree, nfsnode, n_entry, nfsnode_cmp);

void
nfs_ninit(struct nfsmount *nmp)
{
	RBT_INIT(nfs_nodetree, &nmp->nm_ntree);
}

/*
 * Look up a vnode/nfsnode by file handle and store the pointer in *npp.
 * Callers must check for mount points!!
 * An error number is returned.
 */
int
nfs_nget(struct mount *mnt, nfsfh_t *fh, int fhsize, struct nfsnode **npp)
{
	struct nfsmount		*nmp;
	struct nfsnode		*np, find, *np2;
	struct vnode		*vp, *nvp;
	struct proc		*p = curproc;		/* XXX */
	int			 error;

	nmp = VFSTONFS(mnt);

loop:
	rw_enter_write(&nfs_hashlock);
	find.n_fhp = fh;
	find.n_fhsize = fhsize;
	np = RBT_FIND(nfs_nodetree, &nmp->nm_ntree, &find);
	if (np != NULL) {
		rw_exit_write(&nfs_hashlock);
		vp = NFSTOV(np);
		error = vget(vp, LK_EXCLUSIVE, p);
		if (error)
			goto loop;
		*npp = np;
		return (0);
	}

	/*
	 * getnewvnode() could recycle a vnode, potentially formerly
	 * owned by NFS. This will cause a VOP_RECLAIM() to happen,
	 * which will cause recursive locking, so we unlock before
	 * calling getnewvnode() lock again afterwards, but must check
	 * to see if this nfsnode has been added while we did not hold
	 * the lock.
	 */
	rw_exit_write(&nfs_hashlock);
	error = getnewvnode(VT_NFS, mnt, &nfs_vops, &nvp);
	/* note that we don't have this vnode set up completely yet */
	rw_enter_write(&nfs_hashlock);
	if (error) {
		*npp = NULL;
		rw_exit_write(&nfs_hashlock);
		return (error);
	}
	nvp->v_flag |= VLARVAL;
	np = RBT_FIND(nfs_nodetree, &nmp->nm_ntree, &find);
	if (np != NULL) {
		vgone(nvp);
		rw_exit_write(&nfs_hashlock);
		goto loop;
	}

	vp = nvp;
	np = pool_get(&nfs_node_pool, PR_WAITOK | PR_ZERO);
	vp->v_data = np;
	/* we now have an nfsnode on this vnode */
	vp->v_flag &= ~VLARVAL;
	np->n_vnode = vp;

	rw_init(&np->n_commitlock, "nfs_commitlk");

	/* 
	 * Are we getting the root? If so, make sure the vnode flags
	 * are correct 
	 */
	if ((fhsize == nmp->nm_fhsize) && !bcmp(fh, nmp->nm_fh, fhsize)) {
		if (vp->v_type == VNON)
			vp->v_type = VDIR;
		vp->v_flag |= VROOT;
	}

	np->n_fhp = &np->n_fh;
	bcopy(fh, np->n_fhp, fhsize);
	np->n_fhsize = fhsize;
	np2 = RBT_INSERT(nfs_nodetree, &nmp->nm_ntree, np);
	KASSERT(np2 == NULL);
	np->n_accstamp = -1;
	rw_exit(&nfs_hashlock);
	*npp = np;

	return (0);
}

int
nfs_inactive(void *v)
{
	struct vop_inactive_args	*ap = v;
	struct nfsnode			*np;
	struct sillyrename		*sp;

#ifdef DIAGNOSTIC
	if (prtactive && ap->a_vp->v_usecount != 0)
		vprint("nfs_inactive: pushing active", ap->a_vp);
#endif
	if (ap->a_vp->v_flag & VLARVAL)
		/*
		 * vnode was incompletely set up, just return
		 * as we are throwing it away.
		 */
		return(0);
#ifdef DIAGNOSTIC
	if (ap->a_vp->v_data == NULL)
		panic("NULL v_data (no nfsnode set up?) in vnode %p",
		    ap->a_vp);
#endif
	np = VTONFS(ap->a_vp);
	if (ap->a_vp->v_type != VDIR) {
		sp = np->n_sillyrename;
		np->n_sillyrename = NULL;
	} else
		sp = NULL;
	if (sp) {
		/*
		 * Remove the silly file that was rename'd earlier
		 */
		nfs_vinvalbuf(ap->a_vp, 0, sp->s_cred, curproc);
		nfs_removeit(sp);
		crfree(sp->s_cred);
		vrele(sp->s_dvp);
		free(sp, M_NFSREQ, sizeof(*sp));
	}
	np->n_flag &= (NMODIFIED | NFLUSHINPROG | NFLUSHWANT);

	VOP_UNLOCK(ap->a_vp, ap->a_p);
	return (0);
}

/*
 * Reclaim an nfsnode so that it can be used for other purposes.
 */
int
nfs_reclaim(void *v)
{
	struct vop_reclaim_args	*ap = v;
	struct vnode		*vp = ap->a_vp;
	struct nfsmount		*nmp;
	struct nfsnode		*np = VTONFS(vp);

#ifdef DIAGNOSTIC
	if (prtactive && vp->v_usecount != 0)
		vprint("nfs_reclaim: pushing active", vp);
#endif
	if (ap->a_vp->v_flag & VLARVAL)
		/*
		 * vnode was incompletely set up, just return
		 * as we are throwing it away.
		 */
		return(0);
#ifdef DIAGNOSTIC
	if (ap->a_vp->v_data == NULL)
		panic("NULL v_data (no nfsnode set up?) in vnode %p",
		    ap->a_vp);
#endif
	nmp = VFSTONFS(vp->v_mount);
	rw_enter_write(&nfs_hashlock);
	RBT_REMOVE(nfs_nodetree, &nmp->nm_ntree, np);
	rw_exit_write(&nfs_hashlock);

	if (np->n_rcred)
		crfree(np->n_rcred);
	if (np->n_wcred)
		crfree(np->n_wcred);

	cache_purge(vp);
	pool_put(&nfs_node_pool, vp->v_data);
	vp->v_data = NULL;

	return (0);
}
@


1.64
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.63 2016/02/09 00:56:04 mmcc Exp $	*/
d75 8
a82 2
RB_PROTOTYPE(nfs_nodetree, nfsnode, n_entry, nfsnode_cmp);
RB_GENERATE(nfs_nodetree, nfsnode, n_entry, nfsnode_cmp);
d104 1
a104 1
	np = RB_FIND(nfs_nodetree, &nmp->nm_ntree, &find);
d133 1
a133 1
	np = RB_FIND(nfs_nodetree, &nmp->nm_ntree, &find);
d162 1
a162 1
	np2 = RB_INSERT(nfs_nodetree, &nmp->nm_ntree, np);
d243 1
a243 1
	RB_REMOVE(nfs_nodetree, &nmp->nm_ntree, np);
@


1.63
log
@sync a function's comment with its signature

ok tedu@@, with a slight tweak
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.62 2015/03/14 03:38:52 jsg Exp $	*/
d205 1
a205 1
	VOP_UNLOCK(ap->a_vp, 0, ap->a_p);
@


1.62
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.61 2014/12/23 07:54:13 tedu Exp $	*/
d79 1
a79 1
 * Look up a vnode/nfsnode by file handle.
d81 1
a81 2
 * In all cases, a pointer to a
 * nfsnode structure is returned.
@


1.61
log
@to be safe, revert locking change until further tested.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.59 2014/12/16 18:30:04 tedu Exp $	*/
a53 1
#include <nfs/nfs.h>
@


1.60
log
@optimize locking a wee bit by holding it for critical parts only
@
text
@d121 2
d125 1
a127 5
	/* grab one of these too while we're outside the lock */
	np2 = pool_get(&nfs_node_pool, PR_WAITOK | PR_ZERO);

	/* note that we don't have this vnode set up completely yet */
	rw_enter_write(&nfs_hashlock);
a129 1
	/* lost race. undo and repeat */
a130 1
		pool_put(&nfs_node_pool, np2);
d137 1
a137 1
	np = np2;
@


1.59
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.58 2014/11/15 00:03:12 tedu Exp $	*/
a120 2
	/* note that we don't have this vnode set up completely yet */
	rw_enter_write(&nfs_hashlock);
a122 1
		rw_exit_write(&nfs_hashlock);
d125 5
d132 1
d134 1
d141 1
a141 1
	np = pool_get(&nfs_node_pool, PR_WAITOK | PR_ZERO);
@


1.58
log
@add sizes for free(ptr, sizeof(*ptr)). use sizeof(*ptr) for malloc sizes.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.57 2014/09/14 14:17:26 jsg Exp $	*/
d45 1
@


1.57
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.56 2014/07/12 18:43:52 tedu Exp $	*/
d202 1
a202 1
		free(sp, M_NFSREQ, 0);
@


1.56
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.55 2010/12/21 20:14:43 thib Exp $	*/
d41 1
a41 1
#include <sys/proc.h>
@


1.55
log
@Bring back the "End the VOP experiment." diff, naddy's issues where
unrelated, and his alpha is much happier now.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.54 2010/09/10 16:34:09 thib Exp $	*/
d202 1
a202 1
		free(sp, M_NFSREQ);
@


1.54
log
@Backout the VOP diff until the issues naddy was seeing on alpha (gcc3)
have been resolved.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.53 2010/09/06 23:44:10 thib Exp $	*/
d63 3
a86 1
	extern int (**nfsv2_vnodeop_p)(void *);		/* XXX */
d119 1
a119 1
	error = getnewvnode(VT_NFS, mnt, nfsv2_vnodeop_p, &nvp);
@


1.53
log
@End the VOP experiment. Instead of the ridicolusly complicated operation
vector setup that has questionable features (that have, as far as I can
tell never been used in practice, atleast not in OpenBSD), remove all
the gunk and favor a simple struct full of function pointers that get
set directly by each of the filesystems.

Removes gobs of ugly code and makes things simpler by a magnitude.

The only downside of this is that we loose the vnoperate feature so
the spec/fifo operations of the filesystems need to be kept in sync
with specfs and fifofs, this is no big deal as the API it self is pretty
static.

Many thanks to armani@@ who pulled an earlier version of this diff to
current after c2k10 and Gabriel Kihlman on tech@@ for testing.

Liked by many. "come on, find your balls" deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.52 2010/08/07 03:50:02 krw Exp $	*/
a62 3
/* XXX */
extern struct vops nfs_vops;

d84 1
d117 1
a117 1
	error = getnewvnode(VT_NFS, mnt, &nfs_vops, &nvp);
@


1.52
log
@No "\n" needed at the end of panic() strings.

Bogus chunks pointed out by matthew@@ and miod@@. No cookies for
marco@@ and jasper@@.

ok deraadt@@ miod@@ matthew@@ jasper@@ macro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.51 2009/12/17 16:30:47 beck Exp $	*/
d63 3
a86 1
	extern int (**nfsv2_vnodeop_p)(void *);		/* XXX */
d119 1
a119 1
	error = getnewvnode(VT_NFS, mnt, nfsv2_vnodeop_p, &nvp);
@


1.51
log
@This fixes a case where we could panic on a null deref with a bad vnode
in nfs_inactive, on a reboot.

The core of the problem was in nfs_nget, when we lose the race to put a new
nfsnode in the tree, we have previously allocated a vnode, which getnewvnode
has done an insmntque into the nfs mp's mntlist. The problem being we then
try again with a new vnode, abandoning this one on the mntlist, leaving
junk there for us to die on when we unmount.

This introduces VLARVAL - so we can indicate in a vnode that the higher
level stuff hiding in v_data is incompletely set up. This flag is then
used by nfs to deal with a halfway set up vnode and release it correctly.

analysis and bogus fix by art@@, correct fix by me after serveral failed
attempts and much painful testing by krw@@, good suggestions by tedu and miod

ok krw@@ oga@@ thib@@ blambert@@ art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.50 2009/12/15 17:04:00 beck Exp $	*/
d183 1
a183 1
		panic("NULL v_data (no nfsnode set up?) in vnode %p\n",
d231 1
a231 1
		panic("NULL v_data (no nfsnode set up?) in vnode %p\n",
@


1.50
log
@back out previous fix, apparently neither art or i can fix anything right on the first try

vgone doesn't work in other cases of this. I must fix this slightly differntly
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.49 2009/12/15 16:20:07 beck Exp $	*/
d118 1
d125 1
a125 1

d128 1
d136 2
d168 1
a168 1
	struct nfsnode			*np = VTONFS(ap->a_vp);
d175 12
a186 1

d216 1
a216 1
	struct nfsmount		*nmp = VFSTONFS(vp->v_mount);
d223 12
a234 1

@


1.49
log
@This fixes a case where we could panic on a null deref with a bad vnode
in nfs_inactive, on a reboot.

The core of the problem was in nfs_nget, when we lose the race to put a new
nfsnode in the tree, we have previously allocated a vnode, which getnewvnode
has done an insmntque into the nfs mp's mntlist. The problem being we then
try again with a new vnode, abandoning this one on the mntlist, leaving
junk there for us to die on when we unmount.

analysis and bogus fix by art@@, correct fix by me. much painful testing by
krw@@

ok oga@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.48 2009/08/14 17:52:18 thib Exp $	*/
a126 1
		vgone(nvp); /*remove from mnt queue - don't leak vnodes*/
@


1.48
log
@Use the nfs_hashlock to protect the nfs_nodetree hanging of the mount.

What can happen is that a recycling of a vnode could pull one from out
under us (since NFS has issues with ref counts...).

Dance around getnewvnode() since we can end up recycling vnodes that
where formerly owned by NFS, causing recursive locking.

We where lucky with the old hashtables has the race was rare but now
with more aggresive recycling we loose, just as theo found out on vax.

help from oga, beck and blambert (beck mostly screamed though).

ok oga@@, beck@@, blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.43 2008/12/23 21:56:12 thib Exp $	*/
d127 1
@


1.47
log
@tiny knf and use curproc directly instead of a setting up a local proc
pointer since its just used in one place.

ok blambert@@
@
text
@d86 1
a86 1
	struct nfsnode		*np, find;
d94 1
a94 1
	/* XXXTHIB: locking. */
d99 1
d101 2
a102 1
		if (vget(vp, LK_EXCLUSIVE, p))
d108 9
a116 3
	if (rw_enter(&nfs_hashlock, RW_WRITE|RW_SLEEPFAIL))
		goto loop;

d118 1
d121 1
a121 1
		rw_exit(&nfs_hashlock);
d125 6
d151 2
a152 1
	RB_INSERT(nfs_nodetree, &nmp->nm_ntree, np);
d209 1
d211 1
@


1.46
log
@Use an RB tree instead of a hashtable for fh/node lookups.

Idea from NetBSD.

OK blambert@@
@
text
@d145 1
a145 2
nfs_inactive(v)
	void *v;
d147 3
a149 6
	struct vop_inactive_args *ap = v;
	struct nfsnode *np;
	struct sillyrename *sp;
	struct proc *p = curproc;	/* XXX */

	np = VTONFS(ap->a_vp);
d165 1
a165 1
		nfs_vinvalbuf(ap->a_vp, 0, sp->s_cred, p);
@


1.45
log
@(struct foo *)0 -> NULL, every where I could find it.

OK blambert@@
@
text
@a47 1
#include <sys/hash.h>
a57 4
LIST_HEAD(nfsnodehashhead, nfsnode) *nfsnodehashtbl;
u_long nfsnodehash;
struct rwlock nfs_hashlock = RWLOCK_INITIALIZER("nfshshlk");

a58 1

d61 1
a61 1
#define	nfs_hash(x,y)	hash32_buf((x), (y), HASHINIT)
d63 3
a65 6
/*
 * Initialize hash links for nfsnodes
 * and build nfsnode free list.
 */
void
nfs_nhinit()
d67 3
a69 3
	nfsnodehashtbl = hashinit(desiredvnodes, M_NFSNODE, M_WAITOK, &nfsnodehash);
	pool_init(&nfs_node_pool, sizeof(struct nfsnode), 0, 0, 0, "nfsnodepl",
	    &pool_allocator_nointr);
d72 3
d82 1
a82 5
nfs_nget(mntp, fhp, fhsize, npp)
	struct mount *mntp;
	nfsfh_t *fhp;
	int fhsize;
	struct nfsnode **npp;
d84 8
a91 8
	struct nfsmount *nmp;
	struct proc *p = curproc;	/* XXX */
	struct nfsnode *np;
	struct nfsnodehashhead *nhpp;
	struct vnode *vp;
	extern int (**nfsv2_vnodeop_p)(void *);
	struct vnode *nvp;
	int error;
a92 1
	nhpp = NFSNOHASH(nfs_hash(fhp, fhsize));
d94 5
a98 4
	LIST_FOREACH(np, nhpp, n_hash) {
		if (mntp != NFSTOV(np)->v_mount || np->n_fhsize != fhsize ||
		    bcmp((caddr_t)fhp, (caddr_t)np->n_fhp, fhsize))
			continue;
d103 1
a103 1
		return(0);
d105 1
d108 2
a109 1
	error = getnewvnode(VT_NFS, mntp, nfsv2_vnodeop_p, &nvp);
d111 1
a111 1
		*npp = 0;
d115 1
d127 1
a127 3
	nmp = VFSTONFS(mntp);
	if ((fhsize == nmp->nm_fhsize) &&
	    !bcmp(fhp, nmp->nm_fh, fhsize)) {
d132 1
a132 2
	
	LIST_INSERT_HEAD(nhpp, np, n_hash);
d134 1
a134 1
	bcopy((caddr_t)fhp, (caddr_t)np->n_fhp, fhsize);
d136 1
d140 1
d185 1
a185 2
nfs_reclaim(v)
	void *v;
d187 4
a190 3
	struct vop_reclaim_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct nfsnode *np = VTONFS(vp);
d197 1
a197 2
	if (np->n_hash.le_prev != NULL)
		LIST_REMOVE(np, n_hash);
d203 1
d207 1
@


1.44
log
@Replace the TRUE/FALSE defines with 1/0 respectively. This doesn't
hurt readability and it was just plain annoying seeing them defined
in every other .c file.

OK blambert@@
@
text
@d170 1
a170 1
		np->n_sillyrename = (struct sillyrename *)0;
d172 1
a172 1
		sp = (struct sillyrename *)0;
@


1.43
log
@small indent fix
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.42 2008/08/09 10:14:02 thib Exp $	*/
a65 3

#define TRUE	1
#define	FALSE	0
@


1.42
log
@o nfs_vinvalbuf() is always called with the intrflag as 1, and then
  checks if the mount is actually interrutable, and if not sets it 0.
  remove this argument from nfs_vinvalbuf and just do the checking inside
  the function.
o give nfs_vinvalbuf() a makeover so it looks nice. (spacing, casts, &c);
o Actually pass PCATCH too tsleep() if the mount it interrutable.

ok art@@, blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.41 2008/08/08 20:40:24 blambert Exp $	*/
d97 1
d137 6
a142 8
	{
		struct nfsmount *nmp = VFSTONFS(mntp);
		if ((fhsize == nmp->nm_fhsize) &&
		    !bcmp(fhp, nmp->nm_fh, fhsize)) {
			if (vp->v_type == VNON)
				vp->v_type = VDIR;
			vp->v_flag |= VROOT;
		}
@


1.41
log
@Remove code for variable-sized allocations of NFS filehandles by malloc(),
as it was never used because there were 64-bit buffers already allocated
for filehandles in nfsnode structs.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.40 2008/06/14 10:55:21 mk Exp $	*/
d181 1
a181 1
		(void) nfs_vinvalbuf(ap->a_vp, 0, sp->s_cred, p, 1);
@


1.40
log
@A bunch of pool_get() + bzero() -> pool_get(..., .. | PR_ZERO)
conversions that should shave a few bytes off the kernel.

ok henning, krw, jsing, oga, miod, and thib (``even though i usually prefer
FOO|BAR''; thanks for looking.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.39 2008/06/11 04:52:27 blambert Exp $	*/
d147 1
a147 4
	if (fhsize > NFS_SMALLFH) {
		np->n_fhp = malloc(fhsize, M_NFSBIGFH, M_WAITOK);
	} else
		np->n_fhp = &np->n_fh;
a211 3
	if (np->n_fhsize > NFS_SMALLFH)
		free(np->n_fhp, M_NFSBIGFH);

a220 1

@


1.39
log
@Canonical for() -> queue.h FOREACH macro conversions.
Also, it is historical practice to #include <sys/queue.h>
when using queue.h macros.

ok thib@@ krw@@

special thanks to krw@@ for reminders vice violence
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.38 2008/06/10 22:59:09 thib Exp $	*/
d126 1
a126 2
	np = pool_get(&nfs_node_pool, PR_WAITOK);
	bzero((caddr_t)np, sizeof *np);
@


1.38
log
@
o Avoid putting duplicate entries into the name cache,
  add a function to handle cache_enter()'s for us since
  we need to update the appropriate timestamps so we don't
  miss on lookup;
o Do not purge the dvp in nfs_rmdir(), since there's no need;
o cache the new entry created in nfs_mkdir();
o Do caching of the access modes, this drastically reduces the
  amount of over the wire access RPCs we do in the NFSv3 case.

This diff was written by Pedro Martelletto, sometime in 2004.
A lot of people have been running with it at one time or another,
this includes at least markus and matthieu.

OK deraadt@@, blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.37 2007/12/13 22:32:55 thib Exp $	*/
d50 1
d107 1
a107 1
	for (np = LIST_FIRST(nhpp); np != NULL; np = LIST_NEXT(np, n_hash)) {
@


1.37
log
@Garbage collect nfsdmap and leftover code. That structure
was used as a part of the "old-style directory caching"
that was removed in 2001;

ok beck@@, blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.36 2007/09/20 12:54:31 thib Exp $	*/
d153 1
@


1.36
log
@MALLOC/FREE -> malloc/free + M_ZERO.
Uneeded includes and casts...

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.35 2007/06/01 23:47:57 deraadt Exp $	*/
a204 1
	struct nfsdmap *dp, *dp2;
d214 1
a214 14
	/*
	 * Free up any directory cookie structures and
	 * large file handle structures that might be associated with
	 * this nfs node.
	 */
	if (vp->v_type == VDIR) {
		dp = LIST_FIRST(&np->n_cookies);
		while (dp) {
			dp2 = dp;
			dp = LIST_NEXT(dp, ndm_list);
			free(dp2, M_NFSDIROFF);
		}
	}
	if (np->n_fhsize > NFS_SMALLFH) {
a215 1
	}
d220 1
a220 1
		crfree(np->n_wcred);	
@


1.35
log
@pedro ok'd this ~3500 line diff which removes the vop argument
"ap = v" comments in under 8 seconds, so it must be ok.  and it compiles
too.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.34 2007/05/29 00:17:33 thib Exp $	*/
d187 1
a187 1
		FREE((caddr_t)sp, M_NFSREQ);
d225 1
a225 1
			FREE((caddr_t)dp2, M_NFSDIROFF);
@


1.34
log
@Add a name argument to the RWLOCK_INITIALIZER macro.
Pick reasonble names for the locks involved..

ok tedu@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.33 2007/05/28 21:07:31 thib Exp $	*/
d162 1
a162 4
	struct vop_inactive_args /* {
		struct vnode *a_vp;
		struct proc *a_p;
	} */ *ap = v;
d202 1
a202 3
	struct vop_reclaim_args /* {
		struct vnode *a_vp;
	} */ *ap = v;
@


1.33
log
@lockmgr -> rwlock for the nfs_hashlock.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.32 2006/05/07 20:12:41 tedu Exp $	*/
d60 1
a60 1
struct rwlock nfs_hashlock = RWLOCK_INITIALIZER;
@


1.32
log
@add a name to rwlock so that we can tell where procs are getting stuck
without breaking into ddb.  doubles the size of rwlock [1], but moving
forward this really helps.  ok/tested pedro fgsch millert krw
[1 - next person to add a field to this struct gets whipped with a wet noodle]
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.31 2006/01/09 12:43:16 pedro Exp $	*/
d49 1
d60 1
a60 1
struct lock nfs_hashlock;
a78 2
	lockinit(&nfs_hashlock, PINOD, "nfs_hashlock", 0, 0);

d116 1
a116 1
	if (lockmgr(&nfs_hashlock, LK_EXCLUSIVE|LK_SLEEPFAIL, NULL))
d121 1
a121 1
		lockmgr(&nfs_hashlock, LK_RELEASE, NULL);
d153 1
a153 1
	lockmgr(&nfs_hashlock, LK_RELEASE, NULL);
@


1.31
log
@Put vprint() under DIAGNOSTIC, as to save space in generated ramdisks.
Inspiration from miod@@, okay deraadt@@. Tested on i386, macppc and amd64.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.30 2005/11/19 15:48:04 pedro Exp $	*/
d131 1
a131 1
	rw_init(&np->n_commitlock);
@


1.30
log
@Use NULL where NULL is meant
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.29 2005/11/19 02:18:01 pedro Exp $	*/
d172 2
d176 2
d213 1
d216 1
@


1.29
log
@Remove unnecessary lockmgr() archaism that was costing too much in terms
of panics and bugfixes. Access curproc directly, do not expect a process
pointer as an argument. Should fix many "process context required" bugs.
Incentive and okay millert@@, okay marc@@. Various testing, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.28 2004/12/26 21:22:13 miod Exp $	*/
d154 1
a154 1
	lockmgr(&nfs_hashlock, LK_RELEASE, 0);
@


1.28
log
@Use list and queue macros where applicable to make the code easier to read;
no change in compiler assembly output.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.27 2004/08/03 17:11:48 marius Exp $	*/
d117 1
a117 1
	if (lockmgr(&nfs_hashlock, LK_EXCLUSIVE|LK_SLEEPFAIL, NULL, p))
d122 1
a122 1
		lockmgr(&nfs_hashlock, LK_RELEASE, NULL, p);
d154 1
a154 1
	lockmgr(&nfs_hashlock, LK_RELEASE, 0, p);
@


1.27
log
@NFS commit coalescion: instead of sending a commit for each block, coalesce
these into larger ranges wherever possible.

this should speed up NFS writes quite a bit.

ok art@@ millert@@ pedro@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.26 2003/06/02 23:28:19 millert Exp $	*/
d224 1
a224 1
			dp = dp->ndm_list.le_next;
@


1.26
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.25 2002/07/02 04:23:25 ericj Exp $	*/
d130 2
@


1.25
log
@
use hash.h for nfs_hash as well as namei's hash
ok art@@ costa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.24 2002/03/14 01:27:13 millert Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.24
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.23 2002/02/23 23:47:13 art Exp $	*/
d52 1
d72 2
a85 19
}

/*
 * Compute an entry in the NFS hash table structure
 */
u_long
nfs_hash(fhp, fhsize)
	nfsfh_t *fhp;
	int fhsize;
{
	u_char *fhpp;
	u_long fhsum;
	int i;

	fhpp = &fhp->fh_bytes[0];
	fhsum = 0;
	for (i = 0; i < fhsize; i++)
		fhsum += *fhpp++;
	return (fhsum);
@


1.23
log
@Sigh. The diff is out for testing for three months without a single problem.
Two days after commit people report serious lockups all over the place.
Back out nfs locking changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.21 2002/01/23 00:39:48 art Exp $	*/
d121 1
a121 1
	extern int (**nfsv2_vnodeop_p)__P((void *));
@


1.22
log
@More locking in the NFS code
@
text
@a147 2
	lockinit(&np->n_lock, PINOD, "nfsvlock", 0, 0);
	lockmgr(&np->n_lock, LK_EXCLUSIVE, 0, p);
d197 4
a200 5

	/*
	 * Remove the silly file that was rename'd earlier
	 */
	if (sp)
d202 1
a202 16

	np->n_flag &= (NMODIFIED | NFLUSHINPROG | NFLUSHWANT);
	
	VOP_UNLOCK(ap->a_vp, 0, ap->a_p);

	if (sp) {
		/* Note: sp->s_dvp may already be locked somewhere up in 
		   the call stack as _inactive is called from many places
		   in the code. Thus, this call below requires that
		   recursive locks be enabled in vn_lock.
		*/
		int error = vn_lock(sp->s_dvp, LK_EXCLUSIVE, ap->a_p);
		if (error == 0) {
			nfs_removeit(sp);
			vput(sp->s_dvp);
		}
d204 2
a205 1
      		FREE((caddr_t)sp, M_NFSREQ);
d207 1
d209 1
d259 1
@


1.21
log
@Pool deals fairly well with physical memory shortage, but it doesn't deal
well (not at all) with shortages of the vm_map where the pages are mapped
(usually kmem_map).

Try to deal with it:
 - group all information the backend allocator for a pool in a separate
   struct. The pool will only have a pointer to that struct.
 - change the pool_init API to reflect that.
 - link all pools allocating from the same allocator on a linked list.
 - Since an allocator is responsible to wait for physical memory it will
   only fail (waitok) when it runs out of its backing vm_map, carefully
   drain pools using the same allocator so that va space is freed.
   (see comments in code for caveats and details).
 - change pool_reclaim to return if it actually succeeded to free some
   memory, use that information to make draining easier and more efficient.
 - get rid of PR_URGENT, noone uses it.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.20 2002/01/16 21:51:16 ericj Exp $	*/
d148 2
d199 11
d211 10
a220 5
		/*
		 * Remove the silly file that was rename'd earlier
		 */
		(void) nfs_vinvalbuf(ap->a_vp, 0, sp->s_cred, p, 1);
		nfs_removeit(sp);
d222 1
a222 2
		vrele(sp->s_dvp);
		FREE((caddr_t)sp, M_NFSREQ);
a223 1
	np->n_flag &= (NMODIFIED | NFLUSHINPROG | NFLUSHWANT);
a224 1
	VOP_UNLOCK(ap->a_vp, 0, ap->a_p);
a273 1

@


1.20
log
@
use queue.h macro's
remove register
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.19 2001/12/19 08:58:06 art Exp $	*/
d82 1
a82 1
	    0, pool_page_alloc_nointr, pool_page_free_nointr, M_NFSNODE);
@


1.19
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.16 2001/11/15 23:15:15 art Exp $	*/
d127 1
a127 1
	for (np = nhpp->lh_first; np != 0; np = np->n_hash.le_next) {
d239 1
a239 1
		dp = np->n_cookies.lh_first;
@


1.18
log
@Unlock and drop vnode if VOP_GETATTR fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.17 2001/11/27 05:27:12 art Exp $	*/
a147 1
	lockinit(&np->n_commitlock, PINOD, "nfsclock", 0, 0);
a171 13

	/*
	 * XXXUBC doing this while holding the nfs_hashlock is bad,
	 * but there's no alternative at the moment.
	 */
	error = VOP_GETATTR(vp, &np->n_vattr, curproc->p_ucred, curproc);
	if (error) {
		lockmgr(&nfs_hashlock, LK_RELEASE, 0, p);
		vrele(vp);
		return error;
	}
	uvm_vnp_setsize(vp, np->n_vattr.va_size);

a187 1
	struct vnode *vp = ap->a_vp;
d189 4
a192 4
	np = VTONFS(vp);
	if (prtactive && vp->v_usecount != 0)
		vprint("nfs_inactive: pushing active", vp);
	if (vp->v_type != VDIR) {
d201 1
a201 1
		(void) nfs_vinvalbuf(vp, 0, sp->s_cred, p, 1);
d209 1
a209 1
	VOP_UNLOCK(vp, 0, ap->a_p);
@


1.18.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.21 2002/01/23 00:39:48 art Exp $	*/
d82 1
a82 1
	    &pool_allocator_nointr);
d127 1
a127 1
	for (np = LIST_FIRST(nhpp); np != NULL; np = LIST_NEXT(np, n_hash)) {
d254 1
a254 1
		dp = LIST_FIRST(&np->n_cookies);
@


1.18.2.2
log
@Merge in UBC performance changes from NetBSD.
Fix a bunch of merge errors from yesterday.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.18.2.1 2002/01/31 22:55:47 niklas Exp $	*/
a70 9
void nfs_gop_size(struct vnode *, off_t, off_t *);
int nfs_gop_alloc(struct vnode *, off_t, off_t, int, struct ucred *);

struct genfs_ops nfs_genfsops = {
	nfs_gop_size,
	nfs_gop_alloc,
	nfs_gop_write,
};

a150 1
	genfs_node_init(vp, &nfs_genfsops);
d174 5
a178 3
	lockmgr(&nfs_hashlock, LK_RELEASE, 0, p);

	error = VOP_GETATTR(vp, &np->n_vattr, curproc->p_ucred, p);
d180 1
d186 1
d201 1
a201 1
	struct proc *p = ap->a_p;
d211 2
a212 8
		sp = NULL;
	if (sp != NULL)
		nfs_vinvalbuf(vp, 0, sp->s_cred, p, 1);

	np->n_flag &= (NMODIFIED | NFLUSHINPROG | NFLUSHWANT);
	VOP_UNLOCK(vp, 0, p);
	if (sp != NULL) {

d216 1
a216 2
		
		vn_lock(sp->s_dvp, LK_EXCLUSIVE | LK_RETRY, p);
d219 1
a219 1
		vput(sp->s_dvp);
d222 3
d265 1
a265 1
	if (np->n_rcred) {
d267 1
a267 2
	}
	if (np->n_wcred) {
a268 1
	}
a274 12
void
nfs_gop_size(struct vnode *vp, off_t size, off_t *eobp)
{
	*eobp = MAX(size, vp->v_size);
}

int
nfs_gop_alloc(struct vnode *vp, off_t off, off_t len, int flags,
    struct ucred *cred)
{
	return 0;
}
@


1.18.2.3
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.18.2.2 2002/02/02 03:28:26 art Exp $	*/
d130 1
a130 1
	extern int (**nfsv2_vnodeop_p)(void *);
@


1.18.2.4
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.18.2.3 2002/06/11 03:32:03 art Exp $	*/
a51 1
#include <sys/hash.h>
a79 2
#define	nfs_hash(x,y)	hash32_buf((x), (y), HASHINIT)

d92 19
@


1.18.2.5
log
@Resurrect Costas nfs locking on the UBC branch. It's needed here.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.22 2002/02/22 20:19:14 csapuntz Exp $	*/
a140 2
	lockinit(&np->n_lock, PINOD, "nfsvlock", 0, 0);
	lockmgr(&np->n_lock, LK_EXCLUSIVE, 0, p);
d202 1
a202 5

	/*
	 * Remove the silly file that was rename'd earlier
	 */
	if (sp)
d208 1
d210 1
a210 4
		 * Note: sp->s_dvp may already be locked somewhere up in 
		 * the call stack as _inactive is called from many places
		 * in the code. Thus, this call below requires that
		 * recursive locks be enabled in vn_lock.
d212 3
a214 5
		int error = vn_lock(sp->s_dvp, LK_EXCLUSIVE, ap->a_p);
		if (error == 0) {
			nfs_removeit(sp);
			vput(sp->s_dvp);
		}
d216 1
d270 1
@


1.18.2.6
log
@Huge sync to NetBSD plus lots of bugfixes.
 - uvm is as in netbsd-current minus uvm_map forward merge.
 - various locking bugfixes in nfs.
 - make sure that all specops and fifoops are correct in all vnodeop vectors.
 - make the filesystem code more like filsystem code and less like vm code.
@
text
@d1 2
a2 2
/*	$OpenBSD: nfs_node.c,v 1.18.2.4 2002/10/29 00:36:49 art Exp $	*/
/*	$NetBSD: nfs_node.c,v 1.53 2002/03/16 23:05:25 chs Exp $	*/
a73 1
int nfs_gop_write(struct vnode *, struct vm_page **, int, int);
d171 1
d174 1
a174 1
		vput(vp);
a289 11
}

int
nfs_gop_write(struct vnode *vp, struct vm_page **pgs, int npages, int flags)
{
	int i;

	for (i = 0; i < npages; i++) {
		pmap_page_protect(pgs[i], VM_PROT_READ);
	}
	return genfs_gop_write(vp, pgs, npages, flags);
@


1.17
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.16 2001/11/15 23:15:15 art Exp $	*/
d180 2
@


1.16
log
@Remove creds from struct buf, move the creds that nfs need into the nfs node.
While in the area, convert nfs node allocation from malloc to pool and do
some cleanups.
Based on the UBC changes in NetBSD. niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.15 2001/06/25 03:28:06 csapuntz Exp $	*/
d148 1
d173 11
d200 1
d202 4
a205 4
	np = VTONFS(ap->a_vp);
	if (prtactive && ap->a_vp->v_usecount != 0)
		vprint("nfs_inactive: pushing active", ap->a_vp);
	if (ap->a_vp->v_type != VDIR) {
d214 1
a214 1
		(void) nfs_vinvalbuf(ap->a_vp, 0, sp->s_cred, p, 1);
d222 1
a222 1
	VOP_UNLOCK(ap->a_vp, 0, ap->a_p);
@


1.15
log
@Remove NQNFS
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.14 2001/06/24 21:16:19 csapuntz Exp $	*/
d51 1
d62 5
d78 2
d81 2
a82 1
	nfsnodehashtbl = hashinit(desiredvnodes, M_NFSNODE, M_WAITOK, &nfsnodehash);
d90 1
a90 1
	register nfsfh_t *fhp;
d93 3
a95 3
	register u_char *fhpp;
	register u_long fhsum;
	register int i;
d113 1
a113 1
	register nfsfh_t *fhp;
d118 1
a118 1
	register struct nfsnode *np, *np2;
d120 1
a120 1
	register struct vnode *vp;
a124 1
retry:
d137 2
d142 1
d146 1
a146 1
	MALLOC(np, struct nfsnode *, sizeof *np, M_NFSNODE, M_WAITOK);
d149 1
a163 14

	np->n_vnode = vp;
	/*
	 * Insert the nfsnode in the hash queue for its new file handle
	 */
	for (np2 = nhpp->lh_first; np2 != 0; np2 = np2->n_hash.le_next) {
		if (vp->v_mount != NFSTOV(np2)->v_mount || 
		    fhsize != np2->n_fhsize ||
		    bcmp((caddr_t)fhp, (caddr_t)np2->n_fhp, fhsize))
			continue;
		
		vrele(vp);
		goto retry;
	}
d167 1
a167 1
		MALLOC(np->n_fhp, nfsfh_t *, fhsize, M_NFSBIGFH, M_WAITOK);
d172 1
d185 2
a186 2
	register struct nfsnode *np;
	register struct sillyrename *sp;
a187 1
	extern int prtactive;
d223 3
a225 4
	register struct vnode *vp = ap->a_vp;
	register struct nfsnode *np = VTONFS(vp);
	register struct nfsdmap *dp, *dp2;
	extern int prtactive;
d247 1
a247 1
		FREE((caddr_t)np->n_fhp, M_NFSBIGFH);
d250 4
d255 2
a256 2
	FREE(vp->v_data, M_NFSNODE);
	vp->v_data = (void *)0;
@


1.14
log
@Change handling of NFS root vnode. Moves recognition of NFS root vnode into
nfs_nget.

Root vnode no longer pinned in inode cache. Also, forceable unmounts of an
nfs file system now work even if there are extra references to the NFS root.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.13 1999/04/28 09:28:17 art Exp $	*/
a56 1
#include <nfs/nqnfs.h>
d209 1
a209 2
	np->n_flag &= (NMODIFIED | NFLUSHINPROG | NFLUSHWANT | NQNFSEVICTED |
		NQNFSNONCACHE | NQNFSWRITE);
a226 1
	register struct nfsmount *nmp = VFSTONFS(vp->v_mount);
a234 7

	/*
	 * For nqnfs, take it off the timer queue as required.
	 */
	if ((nmp->nm_flag & NFSMNT_NQNFS) && np->n_timer.cqe_next != 0) {
		CIRCLEQ_REMOVE(&nmp->nm_timerhead, np, n_timer);
	}
@


1.13
log
@zap the newhashinit hack.
Add an extra flag to hashinit telling if it should wait in malloc.
update all calls to hashinit.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.12 1998/08/21 23:16:39 csapuntz Exp $	*/
d139 15
@


1.13.4.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.13 1999/04/28 09:28:17 art Exp $	*/
d57 1
a138 15

	/* 
	 * Are we getting the root? If so, make sure the vnode flags
	 * are correct 
	 */
	{
		struct nfsmount *nmp = VFSTONFS(mntp);
		if ((fhsize == nmp->nm_fhsize) &&
		    !bcmp(fhp, nmp->nm_fh, fhsize)) {
			if (vp->v_type == VNON)
				vp->v_type = VDIR;
			vp->v_flag |= VROOT;
		}
	}

d195 2
a196 1
	np->n_flag &= (NMODIFIED | NFLUSHINPROG | NFLUSHWANT);
d214 1
d223 7
@


1.13.4.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a50 1
#include <sys/pool.h>
a60 5
struct lock nfs_hashlock;

struct pool nfs_node_pool;

extern int prtactive;
d72 1
a73 4
	lockinit(&nfs_hashlock, PINOD, "nfs_hashlock", 0, 0);

	pool_init(&nfs_node_pool, sizeof(struct nfsnode), 0, 0, 0, "nfsnodepl",
	    0, pool_page_alloc_nointr, pool_page_free_nointr, M_NFSNODE);
d81 1
a81 1
	nfsfh_t *fhp;
d84 3
a86 3
	u_char *fhpp;
	u_long fhsum;
	int i;
d104 1
a104 1
	nfsfh_t *fhp;
d109 1
a109 1
	struct nfsnode *np;
d111 1
a111 1
	struct vnode *vp;
d116 1
a128 2
	if (lockmgr(&nfs_hashlock, LK_EXCLUSIVE|LK_SLEEPFAIL, NULL, p))
		goto loop;
a131 1
		lockmgr(&nfs_hashlock, LK_RELEASE, NULL, p);
d135 1
a135 1
	np = pool_get(&nfs_node_pool, PR_WAITOK);
a136 1
	lockinit(&np->n_commitlock, PINOD, "nfsclock", 0, 0);
a137 1
	np->n_vnode = vp;
d152 14
d169 1
a169 1
		np->n_fhp = malloc(fhsize, M_NFSBIGFH, M_WAITOK);
a173 14

	/*
	 * XXXUBC doing this while holding the nfs_hashlock is bad,
	 * but there's no alternative at the moment.
	 */
	error = VOP_GETATTR(vp, &np->n_vattr, curproc->p_ucred, curproc);
	if (error) {
		lockmgr(&nfs_hashlock, LK_RELEASE, 0, p);
		vrele(vp);
		return error;
	}
	uvm_vnp_setsize(vp, np->n_vattr.va_size);

	lockmgr(&nfs_hashlock, LK_RELEASE, 0, p);
d186 2
a187 2
	struct nfsnode *np;
	struct sillyrename *sp;
d189 1
a189 1
	struct vnode *vp = ap->a_vp;
d191 4
a194 4
	np = VTONFS(vp);
	if (prtactive && vp->v_usecount != 0)
		vprint("nfs_inactive: pushing active", vp);
	if (vp->v_type != VDIR) {
d203 1
a203 1
		(void) nfs_vinvalbuf(vp, 0, sp->s_cred, p, 1);
d211 1
a211 1
	VOP_UNLOCK(vp, 0, ap->a_p);
d225 4
a228 3
	struct vnode *vp = ap->a_vp;
	struct nfsnode *np = VTONFS(vp);
	struct nfsdmap *dp, *dp2;
d250 1
a250 1
		free(np->n_fhp, M_NFSBIGFH);
a252 4
	if (np->n_rcred)
		crfree(np->n_rcred);
	if (np->n_wcred)
		crfree(np->n_wcred);	
d254 2
a255 2
	pool_put(&nfs_node_pool, vp->v_data);
	vp->v_data = NULL;
@


1.13.4.3
log
@Merge in trunk
@
text
@d82 1
a82 1
	    &pool_allocator_nointr);
d127 1
a127 1
	for (np = LIST_FIRST(nhpp); np != NULL; np = LIST_NEXT(np, n_hash)) {
d148 1
d173 13
d202 1
d204 4
a207 4
	np = VTONFS(ap->a_vp);
	if (prtactive && ap->a_vp->v_usecount != 0)
		vprint("nfs_inactive: pushing active", ap->a_vp);
	if (ap->a_vp->v_type != VDIR) {
d216 1
a216 1
		(void) nfs_vinvalbuf(ap->a_vp, 0, sp->s_cred, p, 1);
d224 1
a224 1
	VOP_UNLOCK(ap->a_vp, 0, ap->a_p);
d254 1
a254 1
		dp = LIST_FIRST(&np->n_cookies);
@


1.13.4.4
log
@Merge in -current from roughly a week ago
@
text
@d121 1
a121 1
	extern int (**nfsv2_vnodeop_p)(void *);
@


1.13.4.5
log
@Sync the SMP branch with 3.3
@
text
@a51 1
#include <sys/hash.h>
a70 2
#define	nfs_hash(x,y)	hash32_buf((x), (y), HASHINIT)

d83 19
@


1.13.4.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.13.4.5 2003/03/28 00:08:46 niklas Exp $	*/
d19 5
a23 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.12
log
@

Fix malloc race in nfs_node.c
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.11 1998/08/06 19:34:58 csapuntz Exp $	*/
d74 1
a74 1
	nfsnodehashtbl = hashinit(desiredvnodes, M_NFSNODE, &nfsnodehash);
@


1.11
log
@

Rename vop_revoke, vn_bwrite, vop_noislocked, vop_nolock, vop_nounlock
to be vop_generic_revoke, vop_generic_bwrite, vop_generic_islocked,
vop_generic_lock and vop_generic_unlock.

Create vop_generic_abortop and propogate change to all file systems.

Fix PR/371.

Get rid of locking in NULLFS (should be mostly unnecessary now except for
forced unmounts).
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.10 1997/11/06 05:59:00 csapuntz Exp $	*/
d110 1
a110 1
	register struct nfsnode *np;
d117 1
d143 10
d221 2
a222 1
	LIST_REMOVE(np, n_hash);
@


1.10
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.9 1997/10/06 20:20:45 deraadt Exp $	*/
a241 18
/*
 * Nfs abort op, called after namei() when a CREATE/DELETE isn't actually
 * done. Currently nothing to do.
 */
/* ARGSUSED */
int
nfs_abortop(v)
	void *v;
{
	struct vop_abortop_args /* {
		struct vnode *a_dvp;
		struct componentname *a_cnp;
	} */ *ap = v;

	if ((ap->a_cnp->cn_flags & (HASBUF | SAVESTART)) == HASBUF)
		FREE(ap->a_cnp->cn_pnbuf, M_NAMEI);
	return (0);
}
@


1.9
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.7 1997/04/18 10:09:46 deraadt Exp $	*/
a108 1
#ifdef Lite2_integrated
a109 1
#endif
a123 1
#ifdef Lite2_integrated
a124 3
#else
		if (vget(vp, 1))
#endif
a158 1
#ifdef Lite2_integrated
a159 1
#endif
d186 1
a186 1
#ifdef Lite2_integrated
a187 1
#endif
a240 58

#ifndef Lite2_integrated
/*
 * Lock an nfsnode
 */
int
nfs_lock(v)
	void *v;
{
	struct vop_lock_args /* {
		struct vnode *a_vp;
	} */ *ap = v;
	register struct vnode *vp = ap->a_vp;

	/*
	 * Ugh, another place where interruptible mounts will get hung.
	 * If you make this sleep interruptible, then you have to fix all
	 * the VOP_LOCK() calls to expect interruptibility.
	 */
	while (vp->v_flag & VXLOCK) {
		vp->v_flag |= VXWANT;
		(void) tsleep((caddr_t)vp, PINOD, "nfslck", 0);
	}
	if (vp->v_tag == VT_NON)
		return (ENOENT);
	return (0);
}

/*
 * Unlock an nfsnode
 */
int
nfs_unlock(v)
	void *v;
{
#if 0
	struct vop_unlock_args /* {
		struct vnode *a_vp;
	} */ *ap = v;
#endif
	return (0);
}

/*
 * Check for a locked nfsnode
 */
int
nfs_islocked(v)
	void *v;
{
#if 0
	struct vop_islocked_args /* {
		struct vnode *a_vp;
	} */ *ap = v;
#endif
	return (0);
}
#endif /* Lite2_integrated */
@


1.8
log
@VFS Lite2 Changes
@
text
@d109 1
d111 1
d126 1
d128 3
d165 1
d167 1
d194 1
a194 1

d196 1
d250 58
@


1.7
log
@Don't set sillyrename field to 0 for directories, as it's in a union with
the head of the cookie list. Fixes PR 3215, fix supplied by Hiroshi Tezuka
<tezuka@@trc.rwcp.or.jp>. Should also fix M_NFSDIROFF memory leak; fvdl
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.6 1996/04/21 22:30:19 deraadt Exp $	*/
a108 1
#ifdef Lite2_integrated
a109 1
#endif
a123 1
#ifdef Lite2_integrated
a124 3
#else
		if (vget(vp, 1))
#endif
a158 1
#ifdef Lite2_integrated
a159 1
#endif
d186 1
a186 1
#ifdef Lite2_integrated
a187 1
#endif
a240 58

#ifndef Lite2_integrated
/*
 * Lock an nfsnode
 */
int
nfs_lock(v)
	void *v;
{
	struct vop_lock_args /* {
		struct vnode *a_vp;
	} */ *ap = v;
	register struct vnode *vp = ap->a_vp;

	/*
	 * Ugh, another place where interruptible mounts will get hung.
	 * If you make this sleep interruptible, then you have to fix all
	 * the VOP_LOCK() calls to expect interruptibility.
	 */
	while (vp->v_flag & VXLOCK) {
		vp->v_flag |= VXWANT;
		(void) tsleep((caddr_t)vp, PINOD, "nfslck", 0);
	}
	if (vp->v_tag == VT_NON)
		return (ENOENT);
	return (0);
}

/*
 * Unlock an nfsnode
 */
int
nfs_unlock(v)
	void *v;
{
#if 0
	struct vop_unlock_args /* {
		struct vnode *a_vp;
	} */ *ap = v;
#endif
	return (0);
}

/*
 * Check for a locked nfsnode
 */
int
nfs_islocked(v)
	void *v;
{
#if 0
	struct vop_islocked_args /* {
		struct vnode *a_vp;
	} */ *ap = v;
#endif
	return (0);
}
#endif /* Lite2_integrated */
@


1.6
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.5 1996/04/17 04:50:25 mickey Exp $	*/
d177 1
a177 1
	if (ap->a_vp->v_type != VDIR)
d179 2
a180 1
	else
a181 1
	np->n_sillyrename = (struct sillyrename *)0;
@


1.5
log
@Minor cleanups. Checked against Lite2.
(NetBSD's was really just a Lite2's, but w/ 64bit support)
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.4 1996/03/31 13:15:36 mickey Exp $	*/
d180 2
a181 2
		sp = NULL;
	np->n_sillyrename = NULL;
d247 1
a247 1
	vp->v_data = NULL;
@


1.4
log
@From NetBSD: NFSv3 import (tomorrow's Net's kernel)
Open's patches kept in. i'll possibly take a look at Lite2 soon,
is there smth usefull ?..
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs_node.c,v 1.3 1996/02/29 09:24:50 niklas Exp $	*/
d180 2
a181 2
		sp = (struct sillyrename *)0;
	np->n_sillyrename = (struct sillyrename *)0;
d247 1
a247 1
	vp->v_data = (void *)0;
@


1.3
log
@From NetBSD: merge with 960217 (still NFSv2)
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: nfs_node.c,v 1.15 1996/02/09 21:48:24 christos Exp $	*/
d39 1
a39 1
 *	@@(#)nfs_node.c	8.2 (Berkeley) 12/30/93
d42 1
d53 1
a53 1
#include <nfs/nfsv2.h>
a59 2
#define	NFSNOHASH(fhsum) \
	(&nfsnodehashtbl[(fhsum) & nfsnodehash])
d80 4
a83 3
struct nfsnodehashhead *
nfs_hash(fhp)
	register nfsv2fh_t *fhp;
d87 1
a87 1
	int i;
d91 1
a91 1
	for (i = 0; i < NFSX_FH; i++)
d93 1
a93 1
	return (NFSNOHASH(fhsum));
d103 1
a103 1
nfs_nget(mntp, fhp, npp)
d105 2
a106 1
	register nfsv2fh_t *fhp;
d109 3
d115 1
d119 1
a119 1
	nhpp = nfs_hash(fhp);
d122 2
a123 2
		if (mntp != NFSTOV(np)->v_mount ||
		    bcmp((caddr_t)fhp, (caddr_t)&np->n_fh, NFSX_FH))
d126 3
d130 1
d142 1
a147 1
	np->n_flag = 0;
d149 6
a154 13
	bcopy((caddr_t)fhp, (caddr_t)&np->n_fh, NFSX_FH);
	np->n_attrstamp = 0;
	np->n_direofoffset = 0;
	np->n_sillyrename = (struct sillyrename *)0;
	np->n_size = 0;
	np->n_mtime = 0;
	np->n_lockf = 0;
	if (VFSTONFS(mntp)->nm_flag & NFSMNT_NQNFS) {
		np->n_brev = 0;
		np->n_lrev = 0;
		np->n_expiry = (time_t)0;
		np->n_timer.cqe_next = (struct nfsnode *)0;
	}
d165 3
d177 4
a180 1
	sp = np->n_sillyrename;
d190 1
a190 3
#ifdef SILLYSEPARATE
		free((caddr_t)sp, M_NFSREQ);
#endif
d194 3
d213 1
d218 1
d227 18
d251 1
d271 1
a271 1
		sleep((caddr_t)vp, PINOD);
a304 1

d307 1
@


1.2
log
@from cgd; handle 64-bit pointers and longs
@
text
@d1 2
a2 1
/*	$NetBSD: nfs_node.c,v 1.14 1995/12/19 23:07:27 cgd Exp $	*/
d57 1
d71 1
d102 1
a110 1
	extern int (**nfsv2_vnodeop_p)();
d126 2
a127 1
	if (error = getnewvnode(VT_NFS, mntp, nfsv2_vnodeop_p, &nvp)) {
d157 4
a160 1
nfs_inactive(ap)
d163 1
a163 2
	} */ *ap;
{
d194 4
a197 1
nfs_reclaim(ap)
d200 1
a200 2
	} */ *ap;
{
d225 4
a228 1
nfs_lock(ap)
d231 1
a231 2
	} */ *ap;
{
d251 5
a255 1
nfs_unlock(ap)
d258 2
a259 3
	} */ *ap;
{

d266 5
a270 1
nfs_islocked(ap)
d273 2
a274 2
	} */ *ap;
{
d285 3
a287 1
nfs_abortop(ap)
d291 1
a291 2
	} */ *ap;
{
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: nfs_node.c,v 1.13 1994/08/18 22:47:46 mycroft Exp $	*/
a71 4
#ifndef lint
	if ((sizeof(struct nfsnode) - 1) & sizeof(struct nfsnode))
		printf("nfs_nhinit: bad size %d\n", sizeof(struct nfsnode));
#endif /* not lint */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
