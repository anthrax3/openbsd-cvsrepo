head	1.9;
access;
symbols;
locks; strict;
comment	@# @;


1.9
date	2017.06.25.06.54.26;	author otto;	state Exp;
branches;
next	1.8;
commitid	UGd2a3nyFxB4AJP4;

1.8
date	2017.06.22.16.01.48;	author deraadt;	state Exp;
branches;
next	1.7;
commitid	NU9rSPp0mUySxS04;

1.7
date	2017.06.05.17.47.33;	author deraadt;	state Exp;
branches;
next	1.6;
commitid	oVXmxNee04jb9CGy;

1.6
date	2017.06.05.13.52.32;	author deraadt;	state Exp;
branches;
next	1.5;
commitid	ewXrwLrevr5JI8ed;

1.5
date	2017.06.04.13.55.04;	author deraadt;	state Exp;
branches;
next	1.4;
commitid	BHpYWaQMiUPzZrKX;

1.4
date	2017.06.03.22.11.27;	author deraadt;	state Exp;
branches;
next	1.3;
commitid	RcmvI82DH1KklIaz;

1.3
date	2017.06.03.22.08.02;	author deraadt;	state Exp;
branches;
next	1.2;
commitid	CLTWAu3TkOsXuZ8o;

1.2
date	2017.06.02.12.57.45;	author deraadt;	state Exp;
branches;
next	1.1;
commitid	UeC6e5n1TUmv2yQG;

1.1
date	2017.05.31.19.18.18;	author deraadt;	state Exp;
branches;
next	;
commitid	HlDgymhwBU2bW7Tm;


desc
@@


1.9
log
@ldd is more strict wrt semicolons, they can only appear after an
expression line. Removing the extra semicolons makes both ld and
ldd accept the link script generated, although ldd produces a wrong
object file on arm64; ok kettenis@@ deraadt@@
@
text
@#!/bin/sh -

umask 007

PAGE_SIZE=`sysctl -n hw.pagesize`
PAD=$1
GAPDUMMY=$2

RANDOM1=$((RANDOM % (3 * PAGE_SIZE)))
RANDOM2=$((RANDOM % PAGE_SIZE))
RANDOM3=$((RANDOM % PAGE_SIZE))
RANDOM4=$((RANDOM % PAGE_SIZE))
RANDOM5=$((RANDOM % PAGE_SIZE))

cat > gap.link << __EOF__

PHDRS {
	text PT_LOAD FILEHDR PHDRS;
	rodata PT_LOAD;
	data PT_LOAD;
	bss PT_LOAD;
}

SECTIONS {
	.text : ALIGN($PAGE_SIZE) {
		LONG($PAD)
		. += $RANDOM1;
		. = ALIGN($PAGE_SIZE);
		endboot = .;
		PROVIDE (endboot = .);
		. = ALIGN($PAGE_SIZE);
		. += $RANDOM2;
		. = ALIGN(16);
		*(.text .text.*)
	} :text =$PAD

	.rodata : {
		LONG($PAD)
		. += $RANDOM3;
		. = ALIGN(16);
		*(.rodata .rodata.*)
	} :rodata =$PAD

	.data : {
		LONG($PAD)
		. = . + $RANDOM4;	/* fragment of page */
		. = ALIGN(16);
		*(.data .data.*)
	} :data =$PAD

	.bss : {
		. = . + $RANDOM5;	/* fragment of page */
		. = ALIGN(16);
		*(.bss .bss.*)
	} :bss

	note.ABI-tag 0 : { *(.note.ABI-tag) }
	.MIPS.options : { *(.MIPS.options) }
}
__EOF__

ld -r gap.link $GAPDUMMY -o gap.o
@


1.8
log
@Generate a gap.link script, and use that to generate gap.o.  On multi-ABI
architectures we must also link against a gapdummy.o to repair the ABI
of the resulting .o file.  Woe is me.
Also repair install: target to update the linkkit & hash when a kernel
is installed.
ok rpe tb mlarkin and tested by others also
@
text
@d26 1
a26 1
		LONG($PAD);
d38 1
a38 1
		LONG($PAD);
d45 1
a45 1
		LONG($PAD);
@


1.7
log
@include machine/param.h before machine.asm.h because uhm alpha.
@
text
@d3 1
a3 1
PADBYTE=$1
d5 56
a60 24
cat << __EOF__
#include <machine/param.h>
#include <machine/asm.h>

	.text
	.balign	PAGE_SIZE, $PADBYTE
	.space	$RANDOM, $PADBYTE
	.balign	PAGE_SIZE, $PADBYTE

	.globl	endboot
endboot:
	.space	PAGE_SIZE, $PADBYTE
	.space	$RANDOM % PAGE_SIZE, $PADBYTE
	.balign	16, $PADBYTE

	/*
	 * Randomly bias future data, bss, and rodata objects,
	 * does not help for objects in locore0.S though
	  */
	.data
	.space	$RANDOM % PAGE_SIZE, $PADBYTE

	.section .bss
	.space	$RANDOM % PAGE_SIZE
d62 1
a62 3
	.section .rodata
	.space	$RANDOM % PAGE_SIZE, $PADBYTE
__EOF__
@


1.6
log
@Avoid use of _C_LABEL, since it is not portable to all our architectures.
And anyways, everything is ELF now.
@
text
@d6 1
a7 1
#include <machine/param.h>
@


1.5
log
@Don't need to provide a padbyte value for .bss, it will always be 0
pointed out by kettenis
@
text
@d15 1
a15 1
_C_LABEL(endboot):
@


1.4
log
@".section .bss" is portable to more platforms than plain ".bss"
@
text
@d28 1
a28 1
	.space	$RANDOM % PAGE_SIZE, $PADBYTE
@


1.3
log
@use .balign instead of .align, it is portable to more architectures
discussed with patrick
@
text
@d27 1
a27 1
	.bss
@


1.2
log
@typo; meant to say locore0.S
@
text
@d10 1
a10 1
	.align	PAGE_SIZE, $PADBYTE
d12 1
a12 1
	.align	PAGE_SIZE, $PADBYTE
d17 2
a18 2
	.space	$RANDOM % PAGE_SIZE,  $PADBYTE
	.align	16, $PADBYTE
@


1.1
log
@Split early startup code out of locore.S into locore0.S.  Adjust link
run so that this locore0.o is always at the start of the executable.
But randomize the link order of all other .o files in the kernel, so
that their exec/rodata/data/bss segments land all over the place.
Late during kernel boot, unmap the early startup code.

As a result, the internal layout of every newly build bsd kernel is
different from past kernels.  Internal relative offsets are not known
to an outside attacker.  The only known offsets are in the startup code,
which has been unmapped.

Ramdisk kernels cannot be compiled like this, because they are gzip'd.
When the internal pointer references change, the compression dictionary
bloats and results in poorer compression.

ok kettenis mlarkin visa, also thanks to tedu for getting me back to this
@
text
@d22 1
a22 1
	 * does not help for objects in locore.S though
@

