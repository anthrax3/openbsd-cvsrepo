head	1.4;
access;
symbols;
locks; strict;
comment	@# @;


1.4
date	2017.06.03.22.11.27;	author deraadt;	state Exp;
branches;
next	1.3;
commitid	RcmvI82DH1KklIaz;

1.3
date	2017.06.03.22.08.02;	author deraadt;	state Exp;
branches;
next	1.2;
commitid	CLTWAu3TkOsXuZ8o;

1.2
date	2017.06.02.12.57.45;	author deraadt;	state Exp;
branches;
next	1.1;
commitid	UeC6e5n1TUmv2yQG;

1.1
date	2017.05.31.19.18.18;	author deraadt;	state Exp;
branches;
next	;
commitid	HlDgymhwBU2bW7Tm;


desc
@@


1.4
log
@".section .bss" is portable to more platforms than plain ".bss"
@
text
@#!/bin/sh -

PADBYTE=$1

cat << __EOF__
#include <machine/asm.h>
#include <machine/param.h>

	.text
	.balign	PAGE_SIZE, $PADBYTE
	.space	$RANDOM, $PADBYTE
	.balign	PAGE_SIZE, $PADBYTE

	.globl	endboot
_C_LABEL(endboot):
	.space	PAGE_SIZE, $PADBYTE
	.space	$RANDOM % PAGE_SIZE, $PADBYTE
	.balign	16, $PADBYTE

	/*
	 * Randomly bias future data, bss, and rodata objects,
	 * does not help for objects in locore0.S though
	  */
	.data
	.space	$RANDOM % PAGE_SIZE, $PADBYTE

	.section .bss
	.space	$RANDOM % PAGE_SIZE, $PADBYTE

	.section .rodata
	.space	$RANDOM % PAGE_SIZE, $PADBYTE
__EOF__
@


1.3
log
@use .balign instead of .align, it is portable to more architectures
discussed with patrick
@
text
@d27 1
a27 1
	.bss
@


1.2
log
@typo; meant to say locore0.S
@
text
@d10 1
a10 1
	.align	PAGE_SIZE, $PADBYTE
d12 1
a12 1
	.align	PAGE_SIZE, $PADBYTE
d17 2
a18 2
	.space	$RANDOM % PAGE_SIZE,  $PADBYTE
	.align	16, $PADBYTE
@


1.1
log
@Split early startup code out of locore.S into locore0.S.  Adjust link
run so that this locore0.o is always at the start of the executable.
But randomize the link order of all other .o files in the kernel, so
that their exec/rodata/data/bss segments land all over the place.
Late during kernel boot, unmap the early startup code.

As a result, the internal layout of every newly build bsd kernel is
different from past kernels.  Internal relative offsets are not known
to an outside attacker.  The only known offsets are in the startup code,
which has been unmapped.

Ramdisk kernels cannot be compiled like this, because they are gzip'd.
When the internal pointer references change, the compression dictionary
bloats and results in poorer compression.

ok kettenis mlarkin visa, also thanks to tedu for getting me back to this
@
text
@d22 1
a22 1
	 * does not help for objects in locore.S though
@

