head	1.1;
access;
symbols;
locks; strict;
comment	@# @;


1.1
date	2017.05.31.19.18.18;	author deraadt;	state Exp;
branches;
next	;
commitid	HlDgymhwBU2bW7Tm;


desc
@@


1.1
log
@Split early startup code out of locore.S into locore0.S.  Adjust link
run so that this locore0.o is always at the start of the executable.
But randomize the link order of all other .o files in the kernel, so
that their exec/rodata/data/bss segments land all over the place.
Late during kernel boot, unmap the early startup code.

As a result, the internal layout of every newly build bsd kernel is
different from past kernels.  Internal relative offsets are not known
to an outside attacker.  The only known offsets are in the startup code,
which has been unmapped.

Ramdisk kernels cannot be compiled like this, because they are gzip'd.
When the internal pointer references change, the compression dictionary
bloats and results in poorer compression.

ok kettenis mlarkin visa, also thanks to tedu for getting me back to this
@
text
@#!/bin/sh -

PADBYTE=$1

cat << __EOF__
#include <machine/asm.h>
#include <machine/param.h>

	.text
	.align	PAGE_SIZE, $PADBYTE
	.space	$RANDOM, $PADBYTE
	.align	PAGE_SIZE, $PADBYTE

	.globl	endboot
_C_LABEL(endboot):
	.space	PAGE_SIZE, $PADBYTE
	.space	$RANDOM % PAGE_SIZE,  $PADBYTE
	.align	16, $PADBYTE

	/*
	 * Randomly bias future data, bss, and rodata objects,
	 * does not help for objects in locore.S though
	  */
	.data
	.space	$RANDOM % PAGE_SIZE, $PADBYTE

	.bss
	.space	$RANDOM % PAGE_SIZE, $PADBYTE

	.section .rodata
	.space	$RANDOM % PAGE_SIZE, $PADBYTE
__EOF__
@
