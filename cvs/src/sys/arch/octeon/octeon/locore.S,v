head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.2
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.8.0.2
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.6.0.8
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.4
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.5.0.8
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.6
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3;
locks; strict;
comment	@# @;


1.10
date	2016.08.14.08.23.52;	author visa;	state Exp;
branches;
next	1.9;
commitid	at8t1tG4p7ou4Cj7;

1.9
date	2016.08.06.09.32.05;	author visa;	state Exp;
branches;
next	1.8;
commitid	nTtOWc39qknmy3ZN;

1.8
date	2016.04.14.15.48.09;	author visa;	state Exp;
branches;
next	1.7;
commitid	gdINd0BKxMk9xlGC;

1.7
date	2015.08.19.13.14.09;	author visa;	state Exp;
branches;
next	1.6;
commitid	aB2TqedMPjZjsoRh;

1.6
date	2014.03.13.02.17.13;	author yasuoka;	state Exp;
branches;
next	1.5;

1.5
date	2012.10.03.11.18.23;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2012.06.17.11.02.32;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2010.11.23.22.06.57;	author syuu;	state Exp;
branches;
next	1.2;

1.2
date	2010.11.08.12.36.57;	author syuu;	state Exp;
branches;
next	1.1;

1.1
date	2010.09.20.06.32.30;	author syuu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Utilize the TLB Execute-Inhibit bit with non-executable mappings on CPUs
that support the Execute-Inhibit exception. This makes user space W^X
effective on Octeon Plus and later Octeon versions.

Feedback from miod@@, thanks!
No objection from deraadt@@
@
text
@/*	$OpenBSD: locore.S,v 1.9 2016/08/06 09:32:05 visa Exp $ */

/*
 * Copyright (c) 2001-2004 Opsycon AB  (www.opsycon.se / www.opsycon.com)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */
#include <sys/errno.h>
#include <sys/syscall.h>

#include <machine/param.h>
#include <machine/asm.h>
#include <machine/cpu.h>
#include <mips64/mips_cpu.h>
#include <machine/regnum.h>
#include <machine/cpustate.h>
#include <octeon/dev/cn30xxcorereg.h>

#include "assym.h"

	.set	noreorder		# Noreorder is default style!
	.set	mips64r2
	.globl	start
	.globl	kernel_text
kernel_text = start
start:
/* initialize ebase */
	dla	t0, 0xffffffff80000000
	mtc0	t0, COP_0_EBASE

/* initialize cvmctl */
	dli     t0, COP_0_CVMCTL_FUSE_START_BIT|COP_0_CVMCTL_NOFDA_CP2|\
		    COP_0_CVMCTL_IPPCI|COP_0_CVMCTL_IPTI
	dmtc0	t0, COP_0_CVMCTL

/* initialize cvmmemctl */
#if 0
	dli	t0, 0x1846104 # If you want to skip write buffer, use this
#else
	dli	t0, 0x46104
#endif
	dmtc0	t0, COP_0_CVMMEMCTL

	mfc0    v0, COP_0_STATUS_REG
	li	v1, ~(SR_INT_ENAB | SR_ERL | SR_EXL)
	and	v0, v1
	mtc0    v0, COP_0_STATUS_REG    # disable all interrupts

	mtc0	zero, COP_0_CAUSE_REG	# Clear soft interrupts

	LA	gp, _gp

	/* Let the init core continue. The others have to wait. */
	bne	a2, zero, 2f
	nop
#if defined(MULTIPROCESSOR)
	rdhwr   t2, $0
1:	ll	t0, cpu_spinup_mask
	bne	t2, t0, 1b
	nop
	move	t0, zero
	sc	t0, cpu_spinup_mask
	beqz	t0, 1b
	nop
	j	hw_cpu_spinup_trampoline
	nop
#else
	/* Halt extra cores on single-processor kernel. */
1:	wait
	j	1b
	nop
#endif
2:
	/*
	 * Initialize stack and call machine startup.
	 */
	LA	t0, start - FRAMESZ(CF_SZ)
	PTR_S	ra, CF_RA_OFFS(t0)		# save uboot return address
	PTR_S	sp, 0(t0)			# and stack
	move	sp, t0
	jal	mips_init			# mips_init(argc, argv, envp,
	nop					#    callvec, esym)

	beqz	v0, 1f				# upon failure, return to uboot
	nop

	PTR_S	zero, CF_RA_OFFS(sp)		# Zero out old ra for debugger
	move	sp, v0				# switch to new stack
	jal	main				# main(regs)
	move	a0, zero
	PANIC("Startup failed!")

1:	PTR_L	ra, CF_RA_OFFS(sp)
	PTR_L	sp, 0(sp)
	jr	ra
	nop

LEAF(get_cvmctl, 0)
	.set push
	.set mips64r2
	dmfc0	v0, $9, 7
	jr	ra
	nop
END(get_cvmctl)

LEAF(get_cvmmemctl, 0)
	.set push
	.set mips64r2
	dmfc0	v0, $11, 7
	jr	ra
	nop
END(get_cvmmemctl)


#if defined(MULTIPROCESSOR)
LEAF(hw_cpu_spinup_trampoline, 0)
	LA	t0, cpu_spinup_a0
	ld	a0, 0(t0)
	LA	t0, cpu_spinup_sp
	ld	sp, 0(t0)
	jal	hw_cpu_hatch
	nop
END(hw_cpu_spinup_trampoline)

LEAF(hw_getcurcpu, 0)
	GET_CPU_INFO(v0, v1)
	jr	ra
	nop
END(hw_getcurcpu)

LEAF(hw_setcurcpu, 0)
	dmtc0	a0, COP_0_ERROR_PC
	j	ra
	nop
END(hw_setcurcpu)
#endif /* MULTIPROCESSOR */
@


1.9
log
@Add PageGrain bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.8 2016/04/14 15:48:09 visa Exp $ */
a62 4

/* initialize pagegrain */
	dli	t0, PGRAIN_ELPA
	dmtc0	t0, COP_0_TLB_PG_GRAIN
@


1.8
log
@Enable write buffering with write merging. This improves overall
performance notably.

Discussed with Miod long ago
Tested by and ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.7 2015/08/19 13:14:09 visa Exp $ */
d65 1
a65 1
	dli	t0, 0x20000000
@


1.7
log
@Halt extra cores on SP kernel, to avoid trashing the system if there
is more than one active CPU. Additionally pick an init core at runtime.
This allows booting the system with a set of CPUs that does not contain
core 0, at least in terms of the early-stage boot code.

ok jasper@@ (a while ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.6 2014/03/13 02:17:13 yasuoka Exp $ */
d57 1
d59 1
a59 1
/*
d61 1
a61 1
*/
@


1.6
log
@Drop the REPUN bit from CvmCtl register not to allow unaligned access.
Also add new cn30xxcorereg.h to provide constant variables of octeon
core.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.5 2012/10/03 11:18:23 miod Exp $ */
d76 3
d80 1
a80 3
	rdhwr	t2, $0
	beqz	t2, 2f
	nop
d90 6
a96 1
#endif
@


1.5
log
@Split ever-growing mips <machine/cpu.h> into what 99% of the kernel needs,
which will remain in <machine/cpu.h>, and a new mips_cpu.h containing only the
goriest md details, which are only of interest to a handful set of files; this
is similar in spirit to what alpha does, but here <machine/cpu.h> does not
include the new file.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.4 2012/06/17 11:02:32 miod Exp $ */
d37 1
d52 2
a53 1
	dli	t0, 0x900043F0
@


1.4
log
@Remove leftover loongson or sgi references.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.3 2010/11/23 22:06:57 syuu Exp $ */
d34 1
@


1.3
log
@passing stack pointer to secondary processors
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.2 2010/11/08 12:36:57 syuu Exp $ */
d92 1
a92 1
	PTR_S	ra, CF_RA_OFFS(t0)		# save pmon return address
d98 1
a98 1
	beqz	v0, 1f				# upon failure, return to pmon
@


1.2
log
@clear ERL register on secondary processors
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.1 2010/09/20 06:32:30 syuu Exp $ */
d54 1
d56 1
a56 1
	dli	t0, 0x1846104 # If you want to skip write buffer, use this
a57 1
	dli	t0, 0x46104
a63 9
#if defined(MULTIPROCESSOR)
	rdhwr	t2, $0
	beqz	t2, 1f
	nop
	j	octeon_ap_wait
	nop
1:
#endif

d71 17
a91 1
	LA	gp, _gp
d131 4
a134 9
	mfc0	v0, COP_0_STATUS_REG
	li	v1, ~(SR_INT_ENAB | SR_ERL | SR_EXL)
	and	v0, v1
	ori	v0, SR_KX | SR_UX
	mtc0	v0, COP_0_STATUS_REG		# disable all interrupts
	mtc0	zero, COP_0_CAUSE_REG		# Clear soft interrupts
	LA	gp, _gp
	LA	a0, cpu_info_boot_secondary
	ld	a0, 0(a0)
a149 18

/*
 * Called on APs to wait until they are told to launch.
 */
LEAF(octeon_ap_wait, 0)
1:	ll	t0, octeon_ap_boot
	bne	t2, t0, 1b
	nop

	move	t0, zero
	sc	t0, octeon_ap_boot

	beqz	t0, 1b
	nop

	j	hw_cpu_spinup_trampoline
	nop
END(octeon_ap_wait)
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.2 2010/02/14 22:39:33 miod Exp $ */
d54 1
a54 1
/* 
d125 1
a125 1
	li	v1, ~SR_INT_ENAB
a149 9
 * This function must be implemented in assembly because it is called early
 * in AP boot without a valid stack.
 */
LEAF(platform_processor_id, 0)
	jr	ra
	rdhwr	v0, $0
END(platform_processor_id)

/*
a152 3
	jal	platform_processor_id
	nop

d154 1
a154 1
	bne	v0, t0, 1b
@

