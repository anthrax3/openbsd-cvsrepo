head	1.16;
access;
symbols
	OPENBSD_6_2:1.16.0.2
	OPENBSD_6_2_BASE:1.16
	OPENBSD_6_1:1.10.0.4
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.8.0.2
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.6.0.8
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.4
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.5.0.8
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.6
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3;
locks; strict;
comment	@# @;


1.16
date	2017.06.08.12.11.46;	author visa;	state Exp;
branches;
next	1.15;
commitid	lLhCQE6nlyPKAxcf;

1.15
date	2017.06.06.14.39.48;	author visa;	state Exp;
branches;
next	1.14;
commitid	IJCm4dgRA6KA0bwB;

1.14
date	2017.06.06.14.35.53;	author visa;	state Exp;
branches;
next	1.13;
commitid	QWErRa8vERX82mC2;

1.13
date	2017.06.05.15.23.11;	author visa;	state Exp;
branches;
next	1.12;
commitid	iUFbc1kKgMfuS7an;

1.12
date	2017.05.09.15.11.33;	author visa;	state Exp;
branches;
next	1.11;
commitid	42heNvhIvgTTzEqV;

1.11
date	2017.04.03.13.51.54;	author visa;	state Exp;
branches;
next	1.10;
commitid	EBw82NJSINlHhfi5;

1.10
date	2016.08.14.08.23.52;	author visa;	state Exp;
branches;
next	1.9;
commitid	at8t1tG4p7ou4Cj7;

1.9
date	2016.08.06.09.32.05;	author visa;	state Exp;
branches;
next	1.8;
commitid	nTtOWc39qknmy3ZN;

1.8
date	2016.04.14.15.48.09;	author visa;	state Exp;
branches;
next	1.7;
commitid	gdINd0BKxMk9xlGC;

1.7
date	2015.08.19.13.14.09;	author visa;	state Exp;
branches;
next	1.6;
commitid	aB2TqedMPjZjsoRh;

1.6
date	2014.03.13.02.17.13;	author yasuoka;	state Exp;
branches;
next	1.5;

1.5
date	2012.10.03.11.18.23;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2012.06.17.11.02.32;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2010.11.23.22.06.57;	author syuu;	state Exp;
branches;
next	1.2;

1.2
date	2010.11.08.12.36.57;	author syuu;	state Exp;
branches;
next	1.1;

1.1
date	2010.09.20.06.32.30;	author syuu;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Wrap startup code with .ent and .end for proper disassembly.
@
text
@/*	$OpenBSD: locore.S,v 1.15 2017/06/06 14:39:48 visa Exp $ */

/*
 * Copyright (c) 2001-2004 Opsycon AB  (www.opsycon.se / www.opsycon.com)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */
#include <sys/errno.h>
#include <sys/syscall.h>

#include <machine/param.h>
#include <machine/asm.h>
#include <machine/cpu.h>
#include <mips64/mips_cpu.h>
#include <machine/regnum.h>
#include <machine/cpustate.h>
#include <octeon/dev/cn30xxcorereg.h>

#include "assym.h"

#define RNG_CONTROL_ADDR	0x9001180040000000
#define RNG_CONTROL_ENABLE	0x3
#define RNG_ENTROPY_ADDR	0x9001400000000000

	.set	noreorder		# Noreorder is default style!
	.set	mips64r2
	.globl	locore_start
	.ent	locore_start, 0
locore_start:
/* initialize ebase */
	dla	t0, 0xffffffff80000000
	mtc0	t0, COP_0_EBASE

/* initialize cvmctl */
	dli     t0, COP_0_CVMCTL_FUSE_START_BIT|COP_0_CVMCTL_NOFDA_CP2|\
		    COP_0_CVMCTL_IPPCI|COP_0_CVMCTL_IPTI
	dmtc0	t0, COP_0_CVMCTL

/* initialize cvmmemctl */
#if 0
	dli	t0, 0x1846104 # If you want to skip write buffer, use this
#else
	dli	t0, 0x46104
#endif
	dmtc0	t0, COP_0_CVMMEMCTL

	mfc0    v0, COP_0_STATUS_REG
	li	v1, ~(SR_INT_ENAB | SR_ERL | SR_EXL)
	and	v0, v1
	mtc0    v0, COP_0_STATUS_REG    # disable all interrupts

	mtc0	zero, COP_0_CAUSE_REG	# Clear soft interrupts

	LA	gp, _gp

	/* Let the init core continue. The others have to wait. */
	bne	a2, zero, 2f
	nop
#if defined(MULTIPROCESSOR)
	rdhwr   t2, $0
	LA	t1, cpu_spinup_mask
1:	ll	t0, 0(t1)
	bne	t2, t0, 1b
	nop
	move	t0, zero
	sc	t0, 0(t1)
	beqz	t0, 1b
	nop
	j	hw_cpu_spinup_trampoline
	nop
#else
	/* Halt extra cores on single-processor kernel. */
1:	wait
	j	1b
	nop
#endif
2:
	/*
	 * Augment the randomdata section using entropy from the RNG.
	 */

	/* Enable the RNG. */
	dli	t0, RNG_CONTROL_ADDR
	ld	t1, (t0)
	ori	t1, RNG_CONTROL_ENABLE
	sd	t1, (t0)

	LA	t0, __kernel_randomdata
	LA	t1, __kernel_randomdata_end
	dli	t2, RNG_ENTROPY_ADDR
1:
	/* Delay to let entropy accumulate. */
	li	v0, 0x1000
2:
	bne	v0, zero, 2b
	subu	v0, v0, 1
	/* Mix entropy. */
	ld	v0, (t0)			# load from randomdata
	ld	v1, (t2)			# load entropy
	xor	v0, v0, v1			# mix entropy
	daddu	t0, t0, 8			# advance ptr
	blt	t0, t1, 1b
	sd	v0, -8(t0)			# store to randomdata

	/*
	 * Initialize stack and call machine startup.
	 */
	LA	t0, start - FRAMESZ(CF_SZ)
	PTR_S	ra, CF_RA_OFFS(t0)		# save uboot return address
	PTR_S	sp, 0(t0)			# and stack
	move	sp, t0
	jal	mips_init			# mips_init(argc, argv, envp,
	nop					#    callvec, esym)

	beqz	v0, 1f				# upon failure, return to uboot
	nop

	PTR_S	zero, CF_RA_OFFS(sp)		# Zero out old ra for debugger
	move	sp, v0				# switch to new stack
	jal	main				# main(regs)
	move	a0, zero
	PANIC("Startup failed!")

1:	PTR_L	ra, CF_RA_OFFS(sp)
	PTR_L	sp, 0(sp)
	jr	ra
	nop
	.end	locore_start

#if defined(MULTIPROCESSOR)
LEAF(hw_cpu_spinup_trampoline, 0)
	LA	t0, cpu_spinup_a0
	ld	a0, 0(t0)
	LA	t0, cpu_spinup_sp
	ld	sp, 0(t0)
	jal	hw_cpu_hatch
	nop
END(hw_cpu_spinup_trampoline)

LEAF(hw_getcurcpu, 0)
	GET_CPU_INFO(v0, v1)
	jr	ra
	nop
END(hw_getcurcpu)

LEAF(hw_setcurcpu, 0)
	dmtc0	a0, COP_0_ERROR_PC
	j	ra
	nop
END(hw_setcurcpu)
#endif /* MULTIPROCESSOR */
@


1.15
log
@Remove code that is not needed right now.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.14 2017/06/06 14:35:53 visa Exp $ */
d48 1
d148 1
@


1.14
log
@Implement startup smashing in C. The code should be moved
under arch/mips64 once loongson and sgi have gap.o.

Discussed with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.13 2017/06/05 15:23:11 visa Exp $ */
a146 17

LEAF(get_cvmctl, 0)
	.set push
	.set mips64r2
	dmfc0	v0, $9, 7
	jr	ra
	nop
END(get_cvmctl)

LEAF(get_cvmmemctl, 0)
	.set push
	.set mips64r2
	dmfc0	v0, $11, 7
	jr	ra
	nop
END(get_cvmmemctl)

@


1.13
log
@Randomize the link order of .o files in the kernel on octeon.
Unlike on some other architectures, it is not possible to unmap
the early boot code. Instead, the code is smashed during boot.

Input from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.12 2017/05/09 15:11:33 visa Exp $ */
a122 11

	/*
	 * Smash the very early boot code by overwriting it.
	 */
	li	v0, 0x00000034			# TEQ zero, zero
	LA	t0, start
	LA	t1, endboot
1:
	daddu	t0, t0, 4
	blt	t0, t1, 1b
	sw	v0, -4(t0)
@


1.12
log
@Mix bits from the built-in RNG with the randomdata section at boot time.
This should improve considerably the quality of early entropy and
stack protector guard data on octeon.

Suggested by and OK deraadt@@
OK kettenis@@, jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.11 2017/04/03 13:51:54 visa Exp $ */
d47 2
a48 4
	.globl	start
	.globl	kernel_text
kernel_text = start
start:
d123 11
@


1.11
log
@Compute address for ll/sc only once.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.10 2016/08/14 08:23:52 visa Exp $ */
d41 4
d99 27
@


1.10
log
@Utilize the TLB Execute-Inhibit bit with non-executable mappings on CPUs
that support the Execute-Inhibit exception. This makes user space W^X
effective on Octeon Plus and later Octeon versions.

Feedback from miod@@, thanks!
No objection from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.9 2016/08/06 09:32:05 visa Exp $ */
d78 2
a79 1
1:	ll	t0, cpu_spinup_mask
d83 1
a83 1
	sc	t0, cpu_spinup_mask
@


1.9
log
@Add PageGrain bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.8 2016/04/14 15:48:09 visa Exp $ */
a62 4

/* initialize pagegrain */
	dli	t0, PGRAIN_ELPA
	dmtc0	t0, COP_0_TLB_PG_GRAIN
@


1.8
log
@Enable write buffering with write merging. This improves overall
performance notably.

Discussed with Miod long ago
Tested by and ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.7 2015/08/19 13:14:09 visa Exp $ */
d65 1
a65 1
	dli	t0, 0x20000000
@


1.7
log
@Halt extra cores on SP kernel, to avoid trashing the system if there
is more than one active CPU. Additionally pick an init core at runtime.
This allows booting the system with a set of CPUs that does not contain
core 0, at least in terms of the early-stage boot code.

ok jasper@@ (a while ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.6 2014/03/13 02:17:13 yasuoka Exp $ */
d57 1
d59 1
a59 1
/*
d61 1
a61 1
*/
@


1.6
log
@Drop the REPUN bit from CvmCtl register not to allow unaligned access.
Also add new cn30xxcorereg.h to provide constant variables of octeon
core.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.5 2012/10/03 11:18:23 miod Exp $ */
d76 3
d80 1
a80 3
	rdhwr	t2, $0
	beqz	t2, 2f
	nop
d90 6
a96 1
#endif
@


1.5
log
@Split ever-growing mips <machine/cpu.h> into what 99% of the kernel needs,
which will remain in <machine/cpu.h>, and a new mips_cpu.h containing only the
goriest md details, which are only of interest to a handful set of files; this
is similar in spirit to what alpha does, but here <machine/cpu.h> does not
include the new file.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.4 2012/06/17 11:02:32 miod Exp $ */
d37 1
d52 2
a53 1
	dli	t0, 0x900043F0
@


1.4
log
@Remove leftover loongson or sgi references.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.3 2010/11/23 22:06:57 syuu Exp $ */
d34 1
@


1.3
log
@passing stack pointer to secondary processors
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.2 2010/11/08 12:36:57 syuu Exp $ */
d92 1
a92 1
	PTR_S	ra, CF_RA_OFFS(t0)		# save pmon return address
d98 1
a98 1
	beqz	v0, 1f				# upon failure, return to pmon
@


1.2
log
@clear ERL register on secondary processors
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.1 2010/09/20 06:32:30 syuu Exp $ */
d54 1
d56 1
a56 1
	dli	t0, 0x1846104 # If you want to skip write buffer, use this
a57 1
	dli	t0, 0x46104
a63 9
#if defined(MULTIPROCESSOR)
	rdhwr	t2, $0
	beqz	t2, 1f
	nop
	j	octeon_ap_wait
	nop
1:
#endif

d71 17
a91 1
	LA	gp, _gp
d131 4
a134 9
	mfc0	v0, COP_0_STATUS_REG
	li	v1, ~(SR_INT_ENAB | SR_ERL | SR_EXL)
	and	v0, v1
	ori	v0, SR_KX | SR_UX
	mtc0	v0, COP_0_STATUS_REG		# disable all interrupts
	mtc0	zero, COP_0_CAUSE_REG		# Clear soft interrupts
	LA	gp, _gp
	LA	a0, cpu_info_boot_secondary
	ld	a0, 0(a0)
a149 18

/*
 * Called on APs to wait until they are told to launch.
 */
LEAF(octeon_ap_wait, 0)
1:	ll	t0, octeon_ap_boot
	bne	t2, t0, 1b
	nop

	move	t0, zero
	sc	t0, octeon_ap_boot

	beqz	t0, 1b
	nop

	j	hw_cpu_spinup_trampoline
	nop
END(octeon_ap_wait)
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.2 2010/02/14 22:39:33 miod Exp $ */
d54 1
a54 1
/* 
d125 1
a125 1
	li	v1, ~SR_INT_ENAB
a149 9
 * This function must be implemented in assembly because it is called early
 * in AP boot without a valid stack.
 */
LEAF(platform_processor_id, 0)
	jr	ra
	rdhwr	v0, $0
END(platform_processor_id)

/*
a152 3
	jal	platform_processor_id
	nop

d154 1
a154 1
	bne	v0, t0, 1b
@

