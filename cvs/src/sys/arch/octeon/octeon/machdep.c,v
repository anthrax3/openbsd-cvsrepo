head	1.82;
access;
symbols
	OPENBSD_6_1:1.82.0.2
	OPENBSD_6_1_BASE:1.82
	OPENBSD_6_0:1.74.0.2
	OPENBSD_6_0_BASE:1.74
	OPENBSD_5_9:1.71.0.2
	OPENBSD_5_9_BASE:1.71
	OPENBSD_5_8:1.67.0.4
	OPENBSD_5_8_BASE:1.67
	OPENBSD_5_7:1.63.0.2
	OPENBSD_5_7_BASE:1.63
	OPENBSD_5_6:1.60.0.4
	OPENBSD_5_6_BASE:1.60
	OPENBSD_5_5:1.41.0.4
	OPENBSD_5_5_BASE:1.41
	OPENBSD_5_4:1.37.0.2
	OPENBSD_5_4_BASE:1.37
	OPENBSD_5_3:1.23.0.2
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.19.0.2
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.4
	OPENBSD_5_0:1.15.0.2
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7;
locks; strict;
comment	@ * @;


1.82
date	2017.01.06.15.37.44;	author fcambus;	state Exp;
branches;
next	1.81;
commitid	0l7pHJQOGB2InAEV;

1.81
date	2016.12.17.14.14.09;	author visa;	state Exp;
branches;
next	1.80;
commitid	zuqFzDrGcaiqTMyk;

1.80
date	2016.12.17.11.17.56;	author visa;	state Exp;
branches;
next	1.79;
commitid	sUI4iYvToftLNPaI;

1.79
date	2016.11.26.15.42.03;	author martijn;	state Exp;
branches;
next	1.78;
commitid	PKujs3O0c30b4I7u;

1.78
date	2016.10.27.13.19.27;	author visa;	state Exp;
branches;
next	1.77;
commitid	6Ve06RHpI01QGFsX;

1.77
date	2016.10.26.13.42.54;	author visa;	state Exp;
branches;
next	1.76;
commitid	khNYWeTCmYcllpHh;

1.76
date	2016.10.09.11.25.40;	author tom;	state Exp;
branches;
next	1.75;
commitid	DfYvEDcFmu1LY9q1;

1.75
date	2016.08.14.08.23.52;	author visa;	state Exp;
branches;
next	1.74;
commitid	at8t1tG4p7ou4Cj7;

1.74
date	2016.07.01.15.12.37;	author visa;	state Exp;
branches;
next	1.73;
commitid	OBMBIbYFQmMsJKTC;

1.73
date	2016.03.21.14.20.57;	author visa;	state Exp;
branches;
next	1.72;
commitid	TQ0mb3irSyFB0n6b;

1.72
date	2016.03.06.19.42.27;	author mpi;	state Exp;
branches;
next	1.71;
commitid	cyYKarj4qRTft4gD;

1.71
date	2016.01.16.11.15.37;	author visa;	state Exp;
branches;
next	1.70;
commitid	1K5ni53Uqdh0w1ne;

1.70
date	2015.12.02.14.56.15;	author visa;	state Exp;
branches;
next	1.69;
commitid	oALFtDqDiyWkFrrf;

1.69
date	2015.12.02.14.52.51;	author visa;	state Exp;
branches;
next	1.68;
commitid	EMq6eNi5pYeeTG0M;

1.68
date	2015.08.20.13.41.41;	author visa;	state Exp;
branches;
next	1.67;
commitid	6xVPyb3g3HgjLXcb;

1.67
date	2015.07.19.16.48.38;	author visa;	state Exp;
branches;
next	1.66;
commitid	yF5Np3kdEQoc5u3T;

1.66
date	2015.07.15.23.22.40;	author pirofti;	state Exp;
branches;
next	1.65;
commitid	khIZKJ0vJ7wGXPqz;

1.65
date	2015.07.15.23.07.23;	author pirofti;	state Exp;
branches;
next	1.64;
commitid	GFcol4Bq83c8HJSx;

1.64
date	2015.06.25.10.56.00;	author jmatthew;	state Exp;
branches;
next	1.63;
commitid	Hvj4a9AnOfnExL6b;

1.63
date	2014.12.10.15.29.53;	author mikeb;	state Exp;
branches;
next	1.62;
commitid	qHQiR2HLROzvZr7B;

1.62
date	2014.09.20.09.28.24;	author kettenis;	state Exp;
branches;
next	1.61;
commitid	IFRB8AkvBMXMTAKW;

1.61
date	2014.08.11.18.56.49;	author miod;	state Exp;
branches;
next	1.60;
commitid	so4P7oFhL2prGC7B;

1.60
date	2014.07.21.17.25.47;	author uebayasi;	state Exp;
branches;
next	1.59;
commitid	7QO4UJr3EKVAMc8t;

1.59
date	2014.07.13.22.53.39;	author uebayasi;	state Exp;
branches;
next	1.58;
commitid	wsdp3qtXGjMj98oD;

1.58
date	2014.07.13.22.13.07;	author uebayasi;	state Exp;
branches;
next	1.57;
commitid	qYPOd6Qi4aRBKldK;

1.57
date	2014.07.13.18.07.38;	author jasper;	state Exp;
branches;
next	1.56;
commitid	w33yHfOw0YiCHBmL;

1.56
date	2014.07.13.14.16.09;	author jasper;	state Exp;
branches;
next	1.55;
commitid	wW47szqwFc9xxzFu;

1.55
date	2014.07.13.13.19.01;	author jasper;	state Exp;
branches;
next	1.54;
commitid	XB6RjC4Q6YQSZCcr;

1.54
date	2014.07.11.22.28.05;	author uebayasi;	state Exp;
branches;
next	1.53;
commitid	fOXKrBuMmlMGQdd4;

1.53
date	2014.07.10.21.46.03;	author mpi;	state Exp;
branches;
next	1.52;
commitid	iYq3Z1ZWDKR3sS9G;

1.52
date	2014.07.10.20.15.27;	author uebayasi;	state Exp;
branches;
next	1.51;
commitid	YzvTa4t6mddz7Mh4;

1.51
date	2014.07.10.13.34.32;	author uebayasi;	state Exp;
branches;
next	1.50;
commitid	xpsLTYRIkonFtkr1;

1.50
date	2014.07.10.12.13.49;	author uebayasi;	state Exp;
branches;
next	1.49;
commitid	aofvn6ceiucgjg4N;

1.49
date	2014.06.17.01.33.04;	author jmatthew;	state Exp;
branches;
next	1.48;
commitid	Vozs7jQDUDtEgOjM;

1.48
date	2014.05.31.15.49.28;	author mpi;	state Exp;
branches;
next	1.47;
commitid	eA4Y0YE1IUzj6hpW;

1.47
date	2014.05.30.13.46.16;	author mpi;	state Exp;
branches;
next	1.46;

1.46
date	2014.05.10.22.37.12;	author jasper;	state Exp;
branches;
next	1.45;

1.45
date	2014.05.10.22.25.16;	author jasper;	state Exp;
branches;
next	1.44;

1.44
date	2014.04.03.08.07.16;	author mpi;	state Exp;
branches;
next	1.43;

1.43
date	2014.03.13.03.52.55;	author dlg;	state Exp;
branches;
next	1.42;

1.42
date	2014.03.09.10.12.17;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2013.09.28.12.40.31;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2013.08.23.08.18.25;	author pirofti;	state Exp;
branches;
next	1.39;

1.39
date	2013.08.21.11.25.33;	author pirofti;	state Exp;
branches;
next	1.38;

1.38
date	2013.08.20.14.58.05;	author pirofti;	state Exp;
branches;
next	1.37;

1.37
date	2013.06.05.01.32.22;	author jasper;	state Exp;
branches;
next	1.36;

1.36
date	2013.06.02.20.29.36;	author jasper;	state Exp;
branches;
next	1.35;

1.35
date	2013.06.01.21.25.26;	author jasper;	state Exp;
branches;
next	1.34;

1.34
date	2013.06.01.17.08.26;	author jasper;	state Exp;
branches;
next	1.33;

1.33
date	2013.04.08.09.42.26;	author jasper;	state Exp;
branches;
next	1.32;

1.32
date	2013.04.06.07.53.57;	author jasper;	state Exp;
branches;
next	1.31;

1.31
date	2013.04.03.12.03.06;	author jasper;	state Exp;
branches;
next	1.30;

1.30
date	2013.03.27.18.32.05;	author jasper;	state Exp;
branches;
next	1.29;

1.29
date	2013.03.19.09.19.10;	author jasper;	state Exp;
branches;
next	1.28;

1.28
date	2013.03.19.09.17.53;	author jasper;	state Exp;
branches;
next	1.27;

1.27
date	2013.03.15.09.19.31;	author jasper;	state Exp;
branches;
next	1.26;

1.26
date	2013.03.15.09.19.01;	author jasper;	state Exp;
branches;
next	1.25;

1.25
date	2013.03.15.09.18.19;	author jasper;	state Exp;
branches;
next	1.24;

1.24
date	2013.03.13.14.30.57;	author jasper;	state Exp;
branches;
next	1.23;

1.23
date	2012.10.08.21.47.50;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2012.10.03.19.42.54;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2012.10.03.11.18.23;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2012.09.29.19.11.08;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2012.07.16.16.06.40;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2012.06.17.11.02.32;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2012.03.25.13.52.52;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2012.03.15.18.57.22;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2011.06.26.22.40.00;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2011.06.24.19.47.48;	author naddy;	state Exp;
branches;
next	1.13;

1.13
date	2011.06.05.19.41.07;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2011.05.30.22.25.22;	author oga;	state Exp;
branches;
next	1.11;

1.11
date	2011.05.08.20.49.19;	author syuu;	state Exp;
branches;
next	1.10;

1.10
date	2011.05.08.13.45.03;	author syuu;	state Exp;
branches;
next	1.9;

1.9
date	2011.05.08.13.39.30;	author syuu;	state Exp;
branches;
next	1.8;

1.8
date	2011.05.08.13.24.55;	author syuu;	state Exp;
branches;
next	1.7;

1.7
date	2010.11.28.20.53.41;	author syuu;	state Exp;
branches;
next	1.6;

1.6
date	2010.11.23.22.06.57;	author syuu;	state Exp;
branches;
next	1.5;

1.5
date	2010.11.23.18.46.29;	author syuu;	state Exp;
branches;
next	1.4;

1.4
date	2010.10.24.15.40.03;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2010.10.01.16.13.59;	author syuu;	state Exp;
branches;
next	1.2;

1.2
date	2010.09.21.06.21.00;	author syuu;	state Exp;
branches;
next	1.1;

1.1
date	2010.09.20.06.32.30;	author syuu;	state Exp;
branches;
next	;


desc
@@


1.82
log
@Ansify cpu_sysctl() on mips64 platforms.

OK patrick@@, visa@@, jasper@@, mpi@@
@
text
@/*	$OpenBSD: machdep.c,v 1.81 2016/12/17 14:14:09 visa Exp $ */

/*
 * Copyright (c) 2009, 2010 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * Copyright (c) 2003-2004 Opsycon AB  (www.opsycon.se / www.opsycon.com)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/buf.h>
#include <sys/reboot.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/msgbuf.h>
#include <sys/tty.h>
#include <sys/user.h>
#include <sys/exec.h>
#include <sys/sysctl.h>
#include <sys/mount.h>
#include <sys/syscallargs.h>
#include <sys/exec_elf.h>
#include <sys/timetc.h>
#ifdef SYSVSHM
#include <sys/shm.h>
#endif
#ifdef SYSVSEM
#include <sys/sem.h>
#endif

#include <net/if.h>

#include <uvm/uvm_extern.h>

#include <machine/db_machdep.h>
#include <ddb/db_interface.h>

#include <machine/autoconf.h>
#include <mips64/cache.h>
#include <machine/cpu.h>
#include <mips64/mips_cpu.h>
#include <machine/memconf.h>

#include <dev/cons.h>
#include <dev/ofw/fdt.h>

#include <octeon/dev/cn30xxipdreg.h>
#include <octeon/dev/iobusvar.h>
#include <machine/octeonreg.h>
#include <machine/octeonvar.h>
#include <machine/octeon_model.h>

/* The following is used externally (sysctl_hw) */
char	machine[] = MACHINE;		/* Machine "architecture" */
char	cpu_model[64];

struct uvm_constraint_range  dma_constraint = { 0x0, 0xffffffffUL };
struct uvm_constraint_range *uvm_md_constraints[] = { NULL };

vm_map_t exec_map;
vm_map_t phys_map;

struct boot_desc *octeon_boot_desc;
struct boot_info *octeon_boot_info;

void *octeon_fdt;

char uboot_rootdev[OCTEON_ARGV_MAX];

/*
 * safepri is a safe priority for sleep to set for a spin-wait
 * during autoconfiguration or after a panic.
 */
int   safepri = 0;

caddr_t	msgbufbase;

int	physmem;		/* Max supported memory, changes to actual. */
int	ncpu = 1;		/* At least one CPU in the system. */
struct	user *proc0paddr;

struct cpu_hwinfo bootcpu_hwinfo;

/* Pointers to the start and end of the symbol table. */
caddr_t	ssym;
caddr_t	esym;
caddr_t	ekern;

struct phys_mem_desc mem_layout[MAXMEMSEGS];

void		dumpsys(void);
void		dumpconf(void);
vaddr_t		mips_init(__register_t, __register_t, __register_t, __register_t);
boolean_t 	is_memory_range(paddr_t, psize_t, psize_t);
void		octeon_memory_init(struct boot_info *);
int		octeon_cpuspeed(int *);
void		octeon_tlb_init(void);
static void	process_bootargs(void);
static uint64_t	get_ncpusfound(void);

#ifdef MULTIPROCESSOR
uint32_t	ipi_intr(uint32_t, struct trapframe *);
#endif

extern void 	parse_uboot_root(void);

cons_decl(cn30xxuart);
struct consdev uartcons = cons_init(cn30xxuart);

u_int		ipdclock_get_timecount(struct timecounter *);

struct timecounter ipdclock_timecounter = {
	.tc_get_timecount = ipdclock_get_timecount,
	.tc_poll_pps = NULL,
	.tc_counter_mask = 0xffffffff,	/* truncated to 32 bits */
	.tc_frequency = 0,		/* determined at runtime */
	.tc_name = "ipdclock",
	.tc_quality = 0			/* ipdclock can be overridden
					 * by cp0 counter */
};

void
octeon_memory_init(struct boot_info *boot_info)
{
	struct octeon_bootmem_block *block;
	struct octeon_bootmem_desc *memdesc;
	paddr_t blockaddr;
	uint64_t fp, lp;
	int i;

	physmem = atop((uint64_t)boot_info->dram_size << 20);

	if (boot_info->phys_mem_desc_addr == 0)
		panic("bootmem desc is missing");
	memdesc = (struct octeon_bootmem_desc *)PHYS_TO_XKPHYS(
	    boot_info->phys_mem_desc_addr, CCA_CACHED);
	printf("bootmem desc 0x%x version %d.%d\n",
	    boot_info->phys_mem_desc_addr, memdesc->major_version,
	    memdesc->minor_version);
	if (memdesc->major_version > 3)
		panic("unhandled bootmem desc version %d.%d",
		    memdesc->major_version, memdesc->minor_version);

	blockaddr = memdesc->head_addr;
	if (blockaddr == 0)
		panic("bootmem list is empty");
	for (i = 0; i < MAXMEMSEGS && blockaddr != 0; blockaddr = block->next) {
		block = (struct octeon_bootmem_block *)PHYS_TO_XKPHYS(
		    blockaddr, CCA_CACHED);
		printf("avail phys mem 0x%016lx - 0x%016lx\n", blockaddr,
		    (paddr_t)(blockaddr + block->size));

		fp = atop(round_page(blockaddr));
		lp = atop(trunc_page(blockaddr + block->size));

		/* Clamp to the range of the pmap. */
		if (fp > atop(pfn_to_pad(PG_FRAME)))
			continue;
		if (lp > atop(pfn_to_pad(PG_FRAME)) + 1)
			lp = atop(pfn_to_pad(PG_FRAME)) + 1;
		if (fp >= lp)
			continue;

		/* Skip small fragments. */
		if (lp - fp < atop(1u << 20))
			continue;

		mem_layout[i].mem_first_page = fp;
		mem_layout[i].mem_last_page = lp;
		i++;
	}

	printf("Total DRAM Size 0x%016llX\n",
	    (uint64_t)boot_info->dram_size << 20);

	for (i = 0; mem_layout[i].mem_last_page; i++) {
		printf("mem_layout[%d] page 0x%016llX -> 0x%016llX\n", i,
		    mem_layout[i].mem_first_page, mem_layout[i].mem_last_page);
	}
}

/*
 * Do all the stuff that locore normally does before calling main().
 * Reset mapping and set up mapping to hardware and init "wired" reg.
 */
vaddr_t
mips_init(__register_t a0, __register_t a1, __register_t a2 __unused,
	__register_t a3)
{
	uint prid;
	vaddr_t xtlb_handler;
	int i;
	struct boot_desc *boot_desc;
	struct boot_info *boot_info;

	extern char start[], edata[], end[];
	extern char exception[], e_exception[];
	extern void xtlb_miss;

	boot_desc = (struct boot_desc *)a3;
	boot_info = (struct boot_info *)
	    PHYS_TO_XKPHYS(boot_desc->boot_info_addr, CCA_CACHED);

#ifdef MULTIPROCESSOR
	/*
	 * Set curcpu address on primary processor.
	 */
	setcurcpu(&cpu_info_primary);
#endif
	/*
	 * Clear the compiled BSS segment in OpenBSD code.
	 */

	bzero(edata, end - edata);

	/*
	 * Set up early console output.
	 */
	cn_tab = &uartcons;

	/*
	 * Reserve space for the symbol table, if it exists.
	 */
	ssym = (char *)(vaddr_t)*(int32_t *)end;
	if (((long)ssym - (long)end) >= 0 &&
	    ((long)ssym - (long)end) <= 0x1000 &&
	    ssym[0] == ELFMAG0 && ssym[1] == ELFMAG1 &&
	    ssym[2] == ELFMAG2 && ssym[3] == ELFMAG3) {
		/* Pointers exist directly after kernel. */
		esym = (char *)(vaddr_t)*((int32_t *)end + 1);
		ekern = esym;
	} else {
		/* Pointers aren't setup either... */
		ssym = NULL;
		esym = NULL;
		ekern = end;
	}

	prid = cp0_get_prid();

	bootcpu_hwinfo.clock = boot_desc->eclock;

	/*
	 * Look at arguments passed to us and compute boothowto.
	 */
	boothowto = RB_AUTOBOOT;

	octeon_memory_init(boot_info);

	/*
	 * Set pagesize to enable use of page macros and functions.
	 * Commit available memory to UVM system.
	 */

	uvmexp.pagesize = PAGE_SIZE;
	uvm_setpagesize();

	for (i = 0; i < MAXMEMSEGS && mem_layout[i].mem_last_page != 0; i++) {
		uint64_t fp, lp;
		uint64_t firstkernpage, lastkernpage;
		paddr_t firstkernpa, lastkernpa;

		/* kernel is linked in CKSEG0 */
		firstkernpa = CKSEG0_TO_PHYS((vaddr_t)start);
		lastkernpa = CKSEG0_TO_PHYS((vaddr_t)ekern);

		firstkernpage = atop(trunc_page(firstkernpa));
		lastkernpage = atop(round_page(lastkernpa));

		fp = mem_layout[i].mem_first_page;
		lp = mem_layout[i].mem_last_page;

		/* Account for kernel and kernel symbol table. */
		if (fp >= firstkernpage && lp < lastkernpage)
			continue;	/* In kernel. */

		if (lp < firstkernpage || fp > lastkernpage) {
			uvm_page_physload(fp, lp, fp, lp, 0);
			continue;	/* Outside kernel. */
		}

		if (fp >= firstkernpage)
			fp = lastkernpage;
		else if (lp < lastkernpage)
			lp = firstkernpage;
		else { /* Need to split! */
			uint64_t xp = firstkernpage;
			uvm_page_physload(fp, xp, fp, xp, 0);
			fp = lastkernpage;
		}
		if (lp > fp) {
			uvm_page_physload(fp, lp, fp, lp, 0);
		}
	}

	bootcpu_hwinfo.c0prid = prid;
	bootcpu_hwinfo.type = (prid >> 8) & 0xff;
	bootcpu_hwinfo.c1prid = 0;	/* No FPU */
	bootcpu_hwinfo.tlbsize = 1 + ((cp0_get_config_1() >> 25) & 0x3f);
	bcopy(&bootcpu_hwinfo, &curcpu()->ci_hw, sizeof(struct cpu_hwinfo));

	/*
	 * Configure cache.
	 */

	Octeon_ConfigCache(curcpu());
	Octeon_SyncCache(curcpu());

	octeon_tlb_init();

	/*
	 * Save the the boot information for future reference since we can't
	 * retrieve it anymore after we've fully bootstrapped the kernel.
	 */

	bcopy(&boot_info, &octeon_boot_info, sizeof(octeon_boot_info));
	bcopy(&boot_desc, &octeon_boot_desc, sizeof(octeon_boot_desc));

	snprintf(cpu_model, sizeof(cpu_model), "Cavium OCTEON (rev %d.%d) @@ %d MHz",
		 (bootcpu_hwinfo.c0prid >> 4) & 0x0f,
		 bootcpu_hwinfo.c0prid & 0x0f,
		 bootcpu_hwinfo.clock / 1000000);

	cpu_cpuspeed = octeon_cpuspeed;

	ncpusfound = get_ncpusfound();

	process_bootargs();

	/*
	 * Save the FDT and let the system use it.
	 */
	if (octeon_boot_info->ver_minor >= 3 &&
	    octeon_boot_info->fdt_addr != 0) {
		void *fdt;
		size_t fdt_size;

		fdt = (void *)PHYS_TO_XKPHYS(octeon_boot_info->fdt_addr,
		    CCA_CACHED);
		if (fdt_init(fdt) != 0 && (fdt_size = fdt_get_size(fdt)) != 0) {
			octeon_fdt = (void *)pmap_steal_memory(fdt_size, NULL,
			    NULL);
			memcpy(octeon_fdt, fdt, fdt_size);
			fdt_init(octeon_fdt);
		}
	}

	/*
	 * Get a console, very early but after initial mapping setup.
	 */

	consinit();
	printf("Initial setup done, switching console.\n");

#define DEBUG
#ifdef DEBUG
#define DUMP_BOOT_DESC(field, format) \
	printf("boot_desc->" #field ":" #format "\n", boot_desc->field)
#define DUMP_BOOT_INFO(field, format) \
	printf("boot_info->" #field ":" #format "\n", boot_info->field)

	DUMP_BOOT_DESC(desc_ver, %d);
	DUMP_BOOT_DESC(desc_size, %d);
	DUMP_BOOT_DESC(stack_top, %llx);
	DUMP_BOOT_DESC(heap_start, %llx);
	DUMP_BOOT_DESC(heap_end, %llx);
	DUMP_BOOT_DESC(argc, %d);
	DUMP_BOOT_DESC(flags, %#x);
	DUMP_BOOT_DESC(core_mask, %#x);
	DUMP_BOOT_DESC(dram_size, %d);
	DUMP_BOOT_DESC(phy_mem_desc_addr, %#x);
	DUMP_BOOT_DESC(debugger_flag_addr, %#x);
	DUMP_BOOT_DESC(eclock, %d);
	DUMP_BOOT_DESC(boot_info_addr, %#llx);

	DUMP_BOOT_INFO(ver_major, %d);
	DUMP_BOOT_INFO(ver_minor, %d);
	DUMP_BOOT_INFO(stack_top, %llx);
	DUMP_BOOT_INFO(heap_start, %llx);
	DUMP_BOOT_INFO(heap_end, %llx);
	DUMP_BOOT_INFO(boot_desc_addr, %#llx);
	DUMP_BOOT_INFO(exception_base_addr, %#x);
	DUMP_BOOT_INFO(stack_size, %d);
	DUMP_BOOT_INFO(flags, %#x);
	DUMP_BOOT_INFO(core_mask, %#x);
	DUMP_BOOT_INFO(dram_size, %d);
	DUMP_BOOT_INFO(phys_mem_desc_addr, %#x);
	DUMP_BOOT_INFO(debugger_flags_addr, %#x);
	DUMP_BOOT_INFO(eclock, %d);
	DUMP_BOOT_INFO(dclock, %d);
	DUMP_BOOT_INFO(board_type, %d);
	DUMP_BOOT_INFO(board_rev_major, %d);
	DUMP_BOOT_INFO(board_rev_minor, %d);
	DUMP_BOOT_INFO(mac_addr_count, %d);
	DUMP_BOOT_INFO(cf_common_addr, %#llx);
	DUMP_BOOT_INFO(cf_attr_addr, %#llx);
	DUMP_BOOT_INFO(led_display_addr, %#llx);
	DUMP_BOOT_INFO(dfaclock, %d);
	DUMP_BOOT_INFO(config_flags, %#x);
	if (octeon_boot_info->ver_minor >= 3)
		DUMP_BOOT_INFO(fdt_addr, %#llx);
#endif

	/*
	 * It is possible to launch the kernel from the bootloader without
	 * physical CPU 0. That does not really work, however, because of the
	 * way how the kernel assigns and uses cpuids. Moreover, cnmac(4) is
	 * hard coded to use CPU 0 for packet reception.
	 */
	if (!(octeon_boot_info->core_mask & 1))
		panic("cannot run without physical CPU 0");

	/*
	 * Init message buffer.
	 */
	msgbufbase = (caddr_t)pmap_steal_memory(MSGBUFSIZE, NULL,NULL);
	initmsgbuf(msgbufbase, MSGBUFSIZE);

	/*
	 * Allocate U page(s) for proc[0], pm_tlbpid 1.
	 */

	proc0.p_addr = proc0paddr = curcpu()->ci_curprocpaddr =
	    (struct user *)pmap_steal_memory(USPACE, NULL, NULL);
	proc0.p_md.md_regs = (struct trapframe *)&proc0paddr->u_pcb.pcb_regs;
	tlb_set_pid(MIN_USER_ASID);

	/*
	 * Bootstrap VM system.
	 */

	pmap_bootstrap();

	/*
	 * Copy down exception vector code.
	 */

	bcopy(exception, (char *)CACHE_ERR_EXC_VEC, e_exception - exception);
	bcopy(exception, (char *)GEN_EXC_VEC, e_exception - exception);

	/*
	 * Build proper TLB refill handler trampolines.
	 */

	xtlb_handler = (vaddr_t)&xtlb_miss;
	build_trampoline(TLB_MISS_EXC_VEC, xtlb_handler);
	build_trampoline(XTLB_MISS_EXC_VEC, xtlb_handler);

	/*
	 * Turn off bootstrap exception vectors.
	 * (this is done by PMON already, but it doesn't hurt to be safe)
	 */

	setsr(getsr() & ~SR_BOOT_EXC_VEC);
	proc0.p_md.md_regs->sr = getsr();

#ifdef DDB
	db_machine_init();
	if (boothowto & RB_KDB)
		Debugger();
#endif

#ifdef MULTIPROCESSOR
	set_intr(INTPRI_IPI, CR_INT_1, ipi_intr);
#endif

	ipdclock_timecounter.tc_frequency = octeon_ioclock_speed();
	tc_init(&ipdclock_timecounter);

	/*
	 * Return the new kernel stack pointer.
	 */
	return ((vaddr_t)proc0paddr + USPACE - 64);
}

/*
 * Console initialization: called early on from main, before vm init or startup.
 * Do enough configuration to choose and initialize a console.
 */
void
consinit()
{
	static int console_ok = 0;

	if (console_ok == 0) {
		cninit();
		console_ok = 1;
	}
}

/*
 * cpu_startup: allocate memory for variable-sized tables, initialize CPU, and
 * do auto-configuration.
 */
void
cpu_startup()
{
	vaddr_t minaddr, maxaddr;

	/*
	 * Good {morning,afternoon,evening,night}.
	 */
	printf(version);
	printf("real mem = %lu (%luMB)\n", ptoa((psize_t)physmem),
	    ptoa((psize_t)physmem)/1024/1024);

	/*
	 * Allocate a submap for exec arguments. This map effectively
	 * limits the number of processes exec'ing at any time.
	 */
	minaddr = vm_map_min(kernel_map);
	exec_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    16 * NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);
	/* Allocate a submap for physio. */
	phys_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    VM_PHYS_SIZE, 0, FALSE, NULL);

	printf("avail mem = %lu (%luMB)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free)/1024/1024);

	/*
	 * Set up buffers, so they can be used to read disk labels.
	 */
	bufinit();

	/*
	 * Configure the system.
	 */
	if (boothowto & RB_CONFIG) {
#ifdef BOOT_CONFIG
		user_config();
#else
		printf("kernel does not support -c; continuing..\n");
#endif
	}
}

int
octeon_cpuspeed(int *freq)
{
	extern struct boot_info *octeon_boot_info;
	*freq = octeon_boot_info->eclock / 1000000;
	return (0);
}

int
octeon_ioclock_speed(void)
{
	extern struct boot_info *octeon_boot_info;
	u_int64_t mio_rst_boot, rst_boot;
	int chipid;

	chipid = octeon_get_chipid();
	switch (octeon_model_family(chipid)) {
	case OCTEON_MODEL_FAMILY_CN61XX:
		mio_rst_boot = octeon_xkphys_read_8(MIO_RST_BOOT);
		return OCTEON_IO_REF_CLOCK * ((mio_rst_boot >>
		    MIO_RST_BOOT_PNR_MUL_SHIFT) & MIO_RST_BOOT_PNR_MUL_MASK);
	case OCTEON_MODEL_FAMILY_CN71XX:
		rst_boot = octeon_xkphys_read_8(RST_BOOT);
		return OCTEON_IO_REF_CLOCK * ((rst_boot >>
		    RST_BOOT_PNR_MUL_SHIFT) & RST_BOOT_PNR_MUL_MASK);
	default:
		return octeon_boot_info->eclock;
	}
}

void
octeon_tlb_init(void)
{
	uint32_t pgrain = 0;

#ifdef MIPS_PTE64
	pgrain |= PGRAIN_ELPA;
#endif
	if (cp0_get_config_3() & CONFIG3_RXI)
		pgrain |= PGRAIN_XIE;
	cp0_set_pagegrain(pgrain);

	tlb_init(bootcpu_hwinfo.tlbsize);
}

static u_int64_t
get_ncpusfound(void)
{
	extern struct boot_desc *octeon_boot_desc;
	uint64_t core_mask = octeon_boot_desc->core_mask;
	uint64_t i, m, ncpus = 0;

	for (i = 0, m = 1 ; i < OCTEON_MAXCPUS; i++, m <<= 1)
		if (core_mask & m)
			ncpus++;

	return ncpus;
}

static void
process_bootargs(void)
{
	int i;
	extern struct boot_desc *octeon_boot_desc;

	/*
	 * U-Boot doesn't pass us anything by default, we need to explicitly
	 * pass the rootdevice.
	 */
	for (i = 0; i < octeon_boot_desc->argc; i++ ) {
		const char *arg = (const char*)
		    PHYS_TO_XKPHYS(octeon_boot_desc->argv[i], CCA_CACHED);

		if (octeon_boot_desc->argv[i] == 0)
			continue;

#ifdef DEBUG
		printf("boot_desc->argv[%d] = %s\n", i, arg);
#endif

		/*
		 * XXX: We currently only expect one other argument,
		 * rootdev=ROOTDEV.
		 */
		if (strncmp(arg, "rootdev=", 8) == 0) {
			if (*uboot_rootdev == '\0') {
				strlcpy(uboot_rootdev, arg,
					sizeof(uboot_rootdev));
				parse_uboot_root();
                        }
		}
	}
}

/*
 * Machine dependent system variables.
 */
int
cpu_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen, struct proc *p)
{
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return ENOTDIR;		/* Overloaded */

	switch (name[0]) {
	default:
		return EOPNOTSUPP;
	}
}

int	waittime = -1;

__dead void
boot(int howto)
{
	int chipid;

	if (curproc)
		savectx(curproc->p_addr, 0);

	if (cold) {
		if ((howto & RB_USERREQ) == 0)
			howto |= RB_HALT;
		goto haltsys;
	}

	boothowto = howto;
	if ((howto & RB_NOSYNC) == 0 && waittime < 0) {
		waittime = 0;
		vfs_shutdown();

		if ((howto & RB_TIMEBAD) == 0) {
			resettodr();
		} else {
			printf("WARNING: not updating battery clock\n");
		}
	}
	if_downall();

	uvm_shutdown();
	splhigh();
	cold = 1;

	if ((howto & RB_DUMP) != 0)
		dumpsys();

haltsys:
	config_suspend_all(DVACT_POWERDOWN);

	if ((howto & RB_HALT) != 0) {
		if ((howto & RB_POWERDOWN) != 0)
			printf("System Power Down not supported,"
			" halting system.\n");
		else
			printf("System Halt.\n");
	} else {
		printf("System restart.\n");
		(void)disableintr();
		tlb_set_wired(0);
		tlb_flush(bootcpu_hwinfo.tlbsize);

		chipid = octeon_get_chipid();
		switch (octeon_model_family(chipid)) {
		case OCTEON_MODEL_FAMILY_CN71XX:
			octeon_xkphys_write_8(RST_SOFT_RST, 1);
			break;
		default:
			octeon_xkphys_write_8(OCTEON_CIU_BASE +
			    CIU_SOFT_RST, 1);
			break;
		}
	}

	for (;;)
		continue;
	/* NOTREACHED */
}

u_long	dumpmag = 0x8fca0101;	/* Magic number for savecore. */
int	dumpsize = 0;			/* Also for savecore. */
long	dumplo = 0;

void
dumpconf(void)
{
	int nblks;

	if (dumpdev == NODEV ||
	    (nblks = (bdevsw[major(dumpdev)].d_psize)(dumpdev)) == 0)
		return;
	if (nblks <= ctod(1))
		return;

	dumpsize = ptoa(physmem);
	if (dumpsize > atop(round_page(dbtob(nblks - dumplo))))
		dumpsize = atop(round_page(dbtob(nblks - dumplo)));
	else if (dumplo == 0)
		dumplo = nblks - btodb(ptoa(physmem));

	/*
	 * Don't dump on the first page in case the dump device includes a 
	 * disk label.
	 */
	if (dumplo < btodb(PAGE_SIZE))
		dumplo = btodb(PAGE_SIZE);
}

void
dumpsys()
{
	/* XXX TBD */
}

boolean_t
is_memory_range(paddr_t pa, psize_t len, psize_t limit)
{
	struct phys_mem_desc *seg;
	uint64_t fp, lp;
	int i;

	fp = atop(pa);
	lp = atop(round_page(pa + len));

	if (limit != 0 && lp > atop(limit))
		return FALSE;

	for (i = 0, seg = mem_layout; i < MAXMEMSEGS; i++, seg++)
		if (fp >= seg->mem_first_page && lp <= seg->mem_last_page)
			return TRUE;

	return FALSE;
}

u_int
ipdclock_get_timecount(struct timecounter *arg)
{
        return octeon_xkphys_read_8(IPD_CLK_COUNT);
}

#ifdef MULTIPROCESSOR
uint32_t cpu_spinup_mask = 0;
uint64_t cpu_spinup_a0, cpu_spinup_sp;
static int (*ipi_handler)(void *);

extern bus_space_t iobus_tag;
extern bus_space_handle_t iobus_h;

void
hw_cpu_boot_secondary(struct cpu_info *ci)
{
	vaddr_t kstack;

	kstack = alloc_contiguous_pages(USPACE);
	if (kstack == 0)
		panic("unable to allocate idle stack\n");
	ci->ci_curprocpaddr = (void *)kstack;
	cpu_spinup_a0 = (uint64_t)ci;
	cpu_spinup_sp = (uint64_t)(kstack + USPACE);
	cpu_spinup_mask = (uint32_t)ci->ci_cpuid;

	while (!cpuset_isset(&cpus_running, ci))
		;
}

void
hw_cpu_hatch(struct cpu_info *ci)
{
	int s;

	/*
	 * Set curcpu address on this processor.
	 */
	setcurcpu(ci);

	/*
	 * Make sure we can access the extended address space.
	 * Note that r10k and later do not allow XUSEG accesses
	 * from kernel mode unless SR_UX is set.
	 */
	setsr(getsr() | SR_KX | SR_UX);

	octeon_tlb_init();
	tlb_set_pid(0);

	/*
	 * Turn off bootstrap exception vectors.
	 */
	setsr(getsr() & ~SR_BOOT_EXC_VEC);

	/*
	 * Clear out the I and D caches.
	 */
	Octeon_ConfigCache(ci);
	Mips_SyncCache(ci);

	printf("cpu%lu launched\n", cpu_number());

	(*md_startclock)(ci);
	ncpus++;
	cpuset_add(&cpus_running, ci);
	octeon_intr_init();
	mips64_ipi_init();
	octeon_setintrmask(0);
	spl0();
	(void)updateimask(0);

	SCHED_LOCK(s);
	cpu_switchto(NULL, sched_chooseproc());
}

/*
 * IPI dispatcher.
 */
uint32_t
ipi_intr(uint32_t hwpend, struct trapframe *frame)
{
	u_long cpuid = cpu_number();

	/*
	 * Mask all pending interrupts.
	 */
	bus_space_write_8(&iobus_tag, iobus_h, CIU_IP3_EN0(cpuid), 0);

	if (ipi_handler == NULL)
		return hwpend;

	ipi_handler((void *)cpuid);

	/*
	 * Reenable interrupts which have been serviced.
	 */
	bus_space_write_8(&iobus_tag, iobus_h, CIU_IP3_EN0(cpuid),
		(1ULL << CIU_INT_MBOX0)|(1ULL << CIU_INT_MBOX1));
	return hwpend;
}

int
hw_ipi_intr_establish(int (*func)(void *), u_long cpuid)
{
	if (cpuid == 0)
		ipi_handler = func;

	bus_space_write_8(&iobus_tag, iobus_h, CIU_MBOX_CLR(cpuid),
		0xffffffff);
	bus_space_write_8(&iobus_tag, iobus_h, CIU_IP3_EN0(cpuid),
		(1ULL << CIU_INT_MBOX0)|(1ULL << CIU_INT_MBOX1));

	return 0;
};

void
hw_ipi_intr_set(u_long cpuid)
{
	bus_space_write_8(&iobus_tag, iobus_h, CIU_MBOX_SET(cpuid), 1);
}

void
hw_ipi_intr_clear(u_long cpuid)
{
	uint64_t clr =
		bus_space_read_8(&iobus_tag, iobus_h, CIU_MBOX_CLR(cpuid));
	bus_space_write_8(&iobus_tag, iobus_h, CIU_MBOX_CLR(cpuid), clr);
}
#endif /* MULTIPROCESSOR */
@


1.81
log
@Fix IO clock speed and system reset on Octeon III.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.80 2016/12/17 11:17:56 visa Exp $ */
d672 2
a673 8
cpu_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
@


1.80
log
@On some systems, the firmware advertises multiple tiny and disjoint
regions of free memory whose size is no more than a few page frames.
Ignore them in order not to clutter uvm with fragments.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.79 2016/11/26 15:42:03 martijn Exp $ */
d586 1
a587 1
	u_int64_t mio_rst_boot;
d595 4
a598 1
		break;
d696 2
d741 11
a751 1
		octeon_xkphys_write_8(OCTEON_CIU_BASE + CIU_SOFT_RST, 1);
@


1.79
log
@Start process_bootargs at 0 instead of 1.
When using endbootargs in U-Boot arguments start at position 0.

OK visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.78 2016/10/27 13:19:27 visa Exp $ */
d198 4
@


1.78
log
@Revert previous `ncpus' change because the percpu code now works
without it.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.77 2016/10/26 13:42:54 visa Exp $ */
d633 2
a634 4
	 * The kernel is booted via a bootoctlinux command. Thus we need to skip
	 * argv[0] when we start to decode the boot arguments (${bootargs}).
	 * Note that U-Boot doesn't pass us anything by default, we need to
	 * explicitly pass the rootdevice.
d636 1
a636 1
	for (i = 1; i < octeon_boot_desc->argc; i++ ) {
d649 1
a649 1
		 * argv[1], rootdev=ROOTDEV.
@


1.77
log
@Increment `ncpus' to its final value already during autoconfiguration so
that percpu data areas get allocated properly on mips64 platforms. It is
too late to set the value during launch of secondary CPUs.

ok jasper@@ kettenis@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.76 2016/10/09 11:25:40 tom Exp $ */
d862 1
@


1.76
log
@Apply consistency to forever loops with continue and NOTREACHED

Same thought from kettenis@@, ok krw@@ phessler@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.75 2016/08/14 08:23:52 visa Exp $ */
a861 1
	ncpus++;
@


1.75
log
@Utilize the TLB Execute-Inhibit bit with non-executable mappings on CPUs
that support the Execute-Inhibit exception. This makes user space W^X
effective on Octeon Plus and later Octeon versions.

Feedback from miod@@, thanks!
No objection from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.74 2016/07/01 15:12:37 visa Exp $ */
d737 2
a738 1
	for (;;) ;
@


1.74
log
@Add fdt init for octeon.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.73 2016/03/21 14:20:57 visa Exp $ */
d133 1
d341 1
a341 1
	tlb_init(bootcpu_hwinfo.tlbsize);
d597 15
d844 1
a844 1
	tlb_init(64);
@


1.73
log
@On Octeon systems, U-Boot provides a list of usable memory regions. Use
the list instead of hardcoded regions in memory setup. Works on
EdgeRouter Lite, EdgeRouter Pro, Lanner MR326b and Movidis 16x.

Tested by jj@@
Tested by and ok jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.72 2016/03/06 19:42:27 mpi Exp $ */
d81 1
d102 2
d362 18
d431 2
@


1.72
log
@Rename mips64's trap_frame into trapframe.

For coherency with other archs and in order to use it in MI code.

ok visa@@, tobiasu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.71 2016/01/16 11:15:37 visa Exp $ */
d157 4
a160 1
	extern char end[];
a161 1
	uint32_t realmem_bytes;
d163 1
a163 2
	realmem_bytes = boot_info->dram_size << 20;
	physmem = atop(realmem_bytes);
d165 33
a197 28
	/*-
	 * Octeon Memory looks as follows:
         *   PA
	 * First 256 MB DR0
	 * 0000 0000 0000 0000     to  0000 0000 0FFF FFFF
	 * Second 256 MB DR1
	 * 0000 0004 1000 0000     to  0000 0004 1FFF FFFF
	 * Over 512MB Memory DR2  15.5GB
	 * 0000 0000 2000 0000     to  0000 0003 FFFF FFFF
	 */

	/* DR0, ignoring everything below the kernel image */
	mem_layout[0].mem_first_page =
	    atop(CKSEG0_TO_PHYS(round_page((vaddr_t)&end)));
	if (physmem > atop(256 << 20))
		mem_layout[0].mem_last_page = atop(256 << 20);
	else
		mem_layout[0].mem_last_page = physmem;

	/* DR1 */
	i = 1;
	if (physmem > atop(256 << 20)) {
		mem_layout[i].mem_first_page = atop(0x410000000ULL);
		if (physmem > atop(512 << 20))
			mem_layout[i].mem_last_page = atop(0x420000000ULL);
		else
			mem_layout[i].mem_last_page =
			    atop(0x410000000ULL) + physmem - atop(256 << 20);
d201 2
a202 10
	/* DR2 */
	if (physmem > atop(512 << 20)) {
		mem_layout[i].mem_first_page = atop(0x20000000ULL);
		mem_layout[i].mem_last_page =
		    atop(0x20000000ULL) + physmem - atop(512 << 20);
		/* i++; */
	}

	printf("Total DRAM Size 0x%016X\n",
	    (uint32_t)(boot_info->dram_size << 20));
@


1.71
log
@Panic if someone boots the kernel by force without CPU 0. The system
will not work without that core.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.70 2015/12/02 14:56:15 visa Exp $ */
d134 1
a134 1
uint32_t	ipi_intr(uint32_t, struct trap_frame *);
d435 1
a435 1
	proc0.p_md.md_regs = (struct trap_frame *)&proc0paddr->u_pcb.pcb_regs;
d840 1
a840 1
ipi_intr(uint32_t hwpend, struct trap_frame *frame)
@


1.70
log
@Enable the DR1 region even with 32-bit page table entries. Those have
enough bits for addressing the region.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.69 2015/12/02 14:52:51 visa Exp $ */
d413 9
@


1.69
log
@Clean up octeon memory region setup.

Diff by miod@@ during c2k15
Tested by jbg@@, jasper@@, pirofti@@
OK jasper@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.68 2015/08/20 13:41:41 visa Exp $ */
a185 1
#ifdef MIPS_PTE64
a192 1
#endif
@


1.68
log
@Use the IPD Clock Count register as a timecounter, making the clock
tick in Octeon MP land.

ok pirofti@@, miod@@, uebayasi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.67 2015/07/19 16:48:38 visa Exp $ */
a153 4
#define btoc(x) (((x)+PAGE_MASK)>>PAGE_SHIFT)

#define OCTEON_DRAM_FIRST_256_END	0xfffffffull

a156 3
	uint64_t phys_avail[10 + 2] = {0,};
	uint64_t startpfn, endpfn;
	uint32_t realmem;
d161 2
a162 22
	startpfn = atop(CKSEG0_TO_PHYS((vaddr_t)&end) + PAGE_SIZE);
	endpfn = atop(96 << 20);
	mem_layout[0].mem_first_page = startpfn;
	mem_layout[0].mem_last_page = endpfn;

	physmem = endpfn - startpfn;

	realmem_bytes = ((boot_info->dram_size << 20) - PAGE_SIZE);
	realmem_bytes &= ~(PAGE_SIZE - 1);

	/* phys_avail regions are in bytes */
	phys_avail[0] =
	    (CKSEG0_TO_PHYS((uint64_t)&end) + PAGE_SIZE) & ~(PAGE_SIZE - 1);

	if (realmem_bytes > OCTEON_DRAM_FIRST_256_END) {
		phys_avail[1] = OCTEON_DRAM_FIRST_256_END;
		realmem_bytes -= OCTEON_DRAM_FIRST_256_END;
		realmem_bytes &= ~(PAGE_SIZE - 1);
	} else
		phys_avail[1] = realmem_bytes;

	mem_layout[0].mem_last_page = atop(phys_avail[1]);
a173 1
	physmem = atop(phys_avail[1] - phys_avail[0]);
d175 20
a194 17
	if (realmem_bytes > OCTEON_DRAM_FIRST_256_END) {
		/* take out the upper non-cached 1/2 */
		phys_avail[2] = 0x410000000ULL;
		phys_avail[3] =
		    (0x410000000ULL + OCTEON_DRAM_FIRST_256_END);
		physmem += btoc(phys_avail[3] - phys_avail[2]);
		mem_layout[2].mem_first_page = atop(phys_avail[2]);
		mem_layout[2].mem_last_page = atop(phys_avail[3] - 1);
		realmem_bytes -= OCTEON_DRAM_FIRST_256_END;

		/* Now map the rest of the memory */
		phys_avail[4] = 0x20000000ULL;
		phys_avail[5] = (0x20000000ULL + realmem_bytes);
		physmem += btoc(phys_avail[5] - phys_avail[4]);
		mem_layout[1].mem_first_page = atop(phys_avail[4]);
		mem_layout[1].mem_last_page = atop(phys_avail[5] - 1);
		realmem_bytes = 0;
d197 7
a203 1
 	realmem = physmem;
a207 4
	for (i = 0; phys_avail[i]; i += 2) {
		printf("Bank %d = 0x%016lX   ->  0x%016lX\n", i >> 1,
		    (long)phys_avail[i], (long)phys_avail[i + 1]);
	}
@


1.67
log
@Register the IPI handler early enough for the correct idle_mask to
propagate to all threads. Otherwise early-started kernel threads run
IPIs disabled, which will lead to a deadlock soon after other cores
have started.

ok miod@@ pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.66 2015/07/15 23:22:40 pirofti Exp $ */
d59 1
d82 1
d142 12
d493 3
d773 6
@


1.66
log
@Ditch the octeon simulator non-sense.

Discussed with miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.65 2015/07/15 23:07:23 pirofti Exp $ */
d131 4
d475 4
a762 2
uint32_t ipi_intr(uint32_t, struct trap_frame *);

d842 3
a864 1
	set_intr(INTPRI_IPI, CR_INT_1, ipi_intr);
@


1.65
log
@Refix memory handling for machines with less than 256M broken by revision 1.64.

Allows my DSR-500 to boot again.

Okay miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.64 2015/06/25 10:56:00 jmatthew Exp $ */
d157 3
a159 7
	/* Simulator we limit to 96 meg */
	if (boot_info->board_type == BOARD_TYPE_SIM) {
		realmem_bytes = (96 << 20);
	} else {
		realmem_bytes = ((boot_info->dram_size << 20) - PAGE_SIZE);
		realmem_bytes &= ~(PAGE_SIZE - 1);
	}
d164 6
a169 10
	/* Simulator gets 96Meg period. */
	if (boot_info->board_type == BOARD_TYPE_SIM) {
		phys_avail[1] = (96 << 20);
	} else {
		if (realmem_bytes > OCTEON_DRAM_FIRST_256_END) {
			phys_avail[1] = OCTEON_DRAM_FIRST_256_END;
			realmem_bytes -= OCTEON_DRAM_FIRST_256_END;
			realmem_bytes &= ~(PAGE_SIZE - 1);
		} else
			phys_avail[1] = realmem_bytes;
d171 1
a171 2
		mem_layout[0].mem_last_page = atop(phys_avail[1]);
	}
d178 1
a178 1
	 * Second 256 MB DR1 
d185 18
a202 20
	if (boot_info->board_type != BOARD_TYPE_SIM) {
		if (realmem_bytes > OCTEON_DRAM_FIRST_256_END) {
			/* take out the upper non-cached 1/2 */
			phys_avail[2] = 0x410000000ULL;
			phys_avail[3] =
			    (0x410000000ULL + OCTEON_DRAM_FIRST_256_END);
			physmem += btoc(phys_avail[3] - phys_avail[2]);
			mem_layout[2].mem_first_page = atop(phys_avail[2]);
			mem_layout[2].mem_last_page = atop(phys_avail[3] - 1);
			realmem_bytes -= OCTEON_DRAM_FIRST_256_END;

			/* Now map the rest of the memory */
			phys_avail[4] = 0x20000000ULL;
			phys_avail[5] = (0x20000000ULL + realmem_bytes);
			physmem += btoc(phys_avail[5] - phys_avail[4]);
			mem_layout[1].mem_first_page = atop(phys_avail[4]);
			mem_layout[1].mem_last_page = atop(phys_avail[5] - 1);
			realmem_bytes = 0;
		}
 	}
@


1.64
log
@Re-enable memory above 256mb now that uvm_pmr_get1page() has been fixed.
From Visa Hankala.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.63 2014/12/10 15:29:53 mikeb Exp $ */
a210 8
			realmem_bytes = 0;
		} else {
			/* Now map the rest of the memory */
			phys_avail[2] = 0x410000000ULL;
			phys_avail[3] = (0x410000000ULL + realmem_bytes);
			physmem += btoc(phys_avail[3] - phys_avail[2]);
			mem_layout[1].mem_first_page = atop(phys_avail[2]);
			mem_layout[1].mem_last_page = atop(phys_avail[3] - 1);
@


1.63
log
@retire shutdown hooks; ok deraadt, krw
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.62 2014/09/20 09:28:24 kettenis Exp $ */
a195 1
#if 0 /* XXX: need fix on mips64 pmap code */
a202 1
#endif
a212 1
#if 0 /* XXX: need fix on mips64 pmap code */
a219 1
#endif
@


1.62
log
@Use config_suspend_all(9).

ok mpi@@, uebayasi@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.61 2014/08/11 18:56:49 miod Exp $ */
a697 1
	doshutdownhooks();
@


1.61
log
@Do not use CKSEG0 to quickly map physical addresses, but XKPHYS, for we are
not limited to 512MB physmem.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.60 2014/07/21 17:25:47 uebayasi Exp $ */
a667 2
	struct device *mainbus;

d699 1
a699 3
	mainbus = device_mainbus();
	if (mainbus != NULL)
		config_suspend(mainbus, DVACT_POWERDOWN);
@


1.60
log
@boot(9): Reduce annoying style diffs

- Always use either: ((x & RB_XXX) != 0) or ((x & RB_XXX) == 0) in boolean
  context (mostly if (x), or x ? y : z)
  - prom_halt() in alpha is confirmed to take int as boolean

Converted by coccinelle.  No functional change intended.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d261 2
a262 2
	boot_info = 
		(struct boot_info *)PHYS_TO_CKSEG0(boot_desc->boot_info_addr);
d616 2
a617 2
		const char *arg =
		    (const char*)PHYS_TO_CKSEG0(octeon_boot_desc->argv[i]);
d619 1
a619 1
		if (arg == NULL)
d623 1
a623 2
		printf("boot_desc->argv[%d] = %s\n",
		       i, (const char *)PHYS_TO_CKSEG0(octeon_boot_desc->argv[i]));
@


1.59
log
@boot(9): Cosmetic changes to improve diff'ability.
@
text
@d697 1
a697 1
	if (howto & RB_DUMP)
d706 2
a707 2
	if (howto & RB_HALT) {
		if (howto & RB_POWERDOWN)
@


1.58
log
@Cosmetic changes to reduce diffs.
@
text
@d721 1
a721 1
	/*NOTREACHED*/
@


1.57
log
@consistency with upcoming bootloader device parsing of the uboot arguments,
root= becomes rootdev=
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.56 2014/07/13 14:16:09 jasper Exp $ */
d694 1
a694 1
	splhigh();		/* Disable interrupts. */
@


1.56
log
@print leading '0x' for addresses and masks with DUMP_BOOT_{DESC,INFO}

ok pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.54 2014/07/11 22:28:05 uebayasi Exp $ */
d629 1
a629 1
		 * argv[1], root=ROOTDEV.
d631 1
a631 1
		if (strncmp(arg, "root=", 5) == 0) {
@


1.55
log
@- fix off-by-one in getting the number of cores in the system
- unbreak GENERIC.MP build
@
text
@d410 2
a411 2
	DUMP_BOOT_DESC(flags, %x);
	DUMP_BOOT_DESC(core_mask, %x);
d413 2
a414 2
	DUMP_BOOT_DESC(phy_mem_desc_addr, %x);
	DUMP_BOOT_DESC(debugger_flag_addr, %x);
d416 1
a416 1
	DUMP_BOOT_DESC(boot_info_addr, %llx);
d423 2
a424 2
	DUMP_BOOT_INFO(boot_desc_addr, %llx);
	DUMP_BOOT_INFO(exception_base_addr, %x);
d426 2
a427 2
	DUMP_BOOT_INFO(flags, %x);
	DUMP_BOOT_INFO(core_mask, %x);
d429 2
a430 2
	DUMP_BOOT_INFO(phys_mem_desc_addr, %x);
	DUMP_BOOT_INFO(debugger_flags_addr, %x);
d437 3
a439 3
	DUMP_BOOT_INFO(cf_common_addr, %llx);
	DUMP_BOOT_INFO(cf_attr_addr, %llx);
	DUMP_BOOT_INFO(led_display_addr, %llx);
d441 1
a441 1
	DUMP_BOOT_INFO(config_flags, %x);
@


1.54
log
@boot(9): Undo curproc-overriding hacks

Some (not all) boot(9) implementations have ancient hacks which overrides if
(curproc == NULL).  This was probably made in a hope to forcibly proceed
various clean-shutdown related code, including VFS shutdown.  Let's clarify
that clean-shutdown needs process context; it is impossible to cleanly shutdown
VFS from within e.g. a panic in SPL_HIGH.

OK kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d594 1
a594 1
	uint64_t i, m, ncpus = 1;
d837 1
a837 1
	printf("cpu%d launched\n", cpu_number());
d903 1
a903 1
#endif
@


1.53
log
@Set cold to 1 before executing the DVACT_POWERDOWN handlers when halting or
rebooting a machine, like it is done in the hibernate case.

At least some USB host controller drivers rely on this to busy way instead
of sleeping.  Avoid a panic on macppc with an uhci(4) cardbus plugged in.

ok deraadt@@, uebayashi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.52 2014/07/10 20:15:27 uebayasi Exp $ */
a681 4
		extern struct proc proc0;
		/* fill curproc with live object */
		if (curproc == NULL)
			curproc = &proc0;
@


1.52
log
@boot(9): Remove comments about RB_*, "cold", and savectx()

Again remove slightly different comments to reduce diffs.  These will be
re-added once boot() become MI and its specification is clearly re-defined.

OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d698 2
a699 1
	(void) splhigh();		/* Extreme priority. */
@


1.51
log
@boot(): Remove comments about RB_TIMEBAD to reduce diffs

RB_TIMEBAD is documented well enough that the comment is not needed.  sparc64
does slightly different and its comment is left with XXX.

OK deraadt@@ miod@@
@
text
@a670 1
	/* Take a snapshot before clobbering any registers. */
a674 4
		/*
		 * If the system is cold, just halt, unless the user
		 * explicitly asked for reboot.
		 */
@


1.50
log
@boot(): Unify declarations

OK deraadt@@
@
text
@a690 3
		/*
		 * Synchronize the disks...
		 */
a693 4
		/*
		 * If we've been adjusting the clock, the todr will be out of
		 * sync; adjust it now.
		 */
@


1.49
log
@The io clock on Octeon II (CN6xxx) runs at a different rate to the cpu clock.
Program the uarts based on the io clock rate on these platforms.

ok jasper@@ pirofti@@ yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.48 2014/05/31 15:49:28 mpi Exp $ */
d666 1
a666 1
void
@


1.48
log
@Revert previous diff setting cold to 1 on shutdown because it breaks machine
with softraid(4) disks.

softraid(4) is the last real consumer of the doshutdownhooks(9) API and it is
not trivial to convert its hook to a DVACT_POWERDOWN handler since the latter
does not allow to sleep.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.47 2014/05/30 13:46:16 mpi Exp $ */
d84 1
d568 19
@


1.47
log
@Set cold to 1 before executing the DVACT_POWERDOWN handlers when halting or
rebooting a machine, like it is done in the hibernate case.

At least some USB host controller drivers rely on this to busy way instead
of sleeping.  Avoid a panic on macppc with an uhci(4) cardbus plugged in.

ok deraadt@@, uebayashi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.46 2014/05/10 22:37:12 jasper Exp $ */
d690 1
a690 2
	splhigh();		/* Disable interrupts. */
	cold = 1;
@


1.46
log
@spello in comment and tweak DUMP_BOOT_DESC a tad
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.45 2014/05/10 22:25:16 jasper Exp $ */
d690 2
a691 1
	(void) splhigh();		/* Extreme priority. */
@


1.45
log
@various format string fixes and remove -Wno-format from octeon

feedback/ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.44 2014/04/03 08:07:16 mpi Exp $ */
d405 3
a407 3
	DUMP_BOOT_DESC(stack_top, %llu);
	DUMP_BOOT_DESC(heap_start, %llu);
	DUMP_BOOT_DESC(heap_end, %llu);
d592 1
a592 1
	 * Note that U-Boot doesn't pass us anything by default, we need
@


1.44
log
@Moar <uvm/uvm.h> -> <uvm/uvm_extern.h> love.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.43 2014/03/13 03:52:55 dlg Exp $ */
d236 1
a236 1
		printf("mem_layout[%d] page 0x%016lX -> 0x%016lX\n", i,
d405 3
a407 3
	DUMP_BOOT_DESC(stack_top, %d);
	DUMP_BOOT_DESC(heap_start, %d);
	DUMP_BOOT_DESC(heap_end, %d);
d415 1
a415 1
	DUMP_BOOT_DESC(boot_info_addr, %x);
d419 4
a422 4
	DUMP_BOOT_INFO(stack_top, %x);
	DUMP_BOOT_INFO(heap_start, %x);
	DUMP_BOOT_INFO(heap_end, %x);
	DUMP_BOOT_INFO(boot_desc_addr, %x);
d436 3
a438 3
	DUMP_BOOT_INFO(cf_common_addr, %x);
	DUMP_BOOT_INFO(cf_attr_addr, %x);
	DUMP_BOOT_INFO(led_display_addr, %x);
d527 1
a527 1
	printf("real mem = %u (%uMB)\n", ptoa((psize_t)physmem),
d541 1
a541 1
	printf("avail mem = %u (%uMB)\n", ptoa(uvmexp.free),
d604 1
a604 1
		       i, PHYS_TO_CKSEG0(octeon_boot_desc->argv[i]));
@


1.43
log
@get rid of the assumption that the head of the alldevs list is the
"mainbus" device. this breaks when mpath is enabled because it
attaches before mainbus and therefore takes the head position.

have autoconf provide device_mainbus() which looks up mainbus_cd,
and use that instead.

discussed with deraadt who just wants mpath stuff to move forward
despite there being many ways to shine this particular turd.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.42 2014/03/09 10:12:17 miod Exp $ */
d67 1
a67 1
#include <uvm/uvm.h>
@


1.42
log
@Rework the per-cpu cache information. Use a common struct to store the line
size, the number of sets, and the total size (and the set size, for convenience)
per cache (I$, D$, L2, L3).
This allows cpu.c to print the number of ways (sets) of L2 and L3 caches from
the cache information, rather than hardcoding this from the processor type.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.41 2013/09/28 12:40:31 miod Exp $ */
d649 1
d697 3
a699 2
	if (!TAILQ_EMPTY(&alldevs))
		config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.41
log
@In boot(), do not iterate over alldevs if it's empty (i.e. halting from ddb
with ddb entered early with boot -d or from UKC).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.40 2013/08/23 08:18:25 pirofti Exp $ */
a894 12
}

void
hw_cpu_init_secondary(struct cpu_info *ci)
{
	ci->ci_cacheways = 2;
	ci->ci_l1instcachesize = 32 * 1024;
	ci->ci_l1instcacheline = 64;
	ci->ci_l1datacachesize = 32 * 1024;
	ci->ci_l1datacacheline = 64;
	ci->ci_l2size = ci->ci_hw.l2size;
	ci->ci_l3size = 0;
@


1.40
log
@Fix memory initialization for octeon's with less than 256MB.

Don't substract the 256MB upperbound from realmem_bytes if the current
available memory is less than that.

Makes my DSR-500 kernel reach userland.

Okay miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.39 2013/08/21 11:25:33 pirofti Exp $ */
d696 2
a697 1
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.39
log
@Missed a spot in my last commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.38 2013/08/20 14:58:05 pirofti Exp $ */
d171 1
a171 1
		if (realmem_bytes > OCTEON_DRAM_FIRST_256_END)
d173 3
a175 1
		else
d177 1
a177 2
		realmem_bytes -= OCTEON_DRAM_FIRST_256_END;
		realmem_bytes &= ~(PAGE_SIZE - 1);
@


1.38
log
@Have some style(9).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.37 2013/06/05 01:32:22 jasper Exp $ */
d170 1
a170 1
	}else{
@


1.37
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.36 2013/06/02 20:29:36 jasper Exp $ */
d159 1
a159 1
	}else{
d164 2
a165 2
	phys_avail[0] = (CKSEG0_TO_PHYS((uint64_t)&end) + 
			 PAGE_SIZE ) & ~(PAGE_SIZE - 1);
d193 1
a193 1
		if(realmem_bytes > OCTEON_DRAM_FIRST_256_END){
d197 2
a198 2
			phys_avail[3] = (0x410000000ULL 
					 + OCTEON_DRAM_FIRST_256_END);
d201 1
a201 1
			mem_layout[2].mem_last_page = atop(phys_avail[3]-1);
d210 3
a212 3
			mem_layout[1].mem_last_page = atop(phys_avail[5]-1);
			realmem_bytes=0;
		}else{
d219 2
a220 2
			mem_layout[1].mem_last_page = atop(phys_avail[3]-1);
			realmem_bytes=0;
d227 2
a228 1
	printf("Total DRAM Size 0x%016X\n", (uint32_t) (boot_info->dram_size << 20));
d230 3
a232 3
	for(i=0;phys_avail[i];i+=2){
		printf("Bank %d = 0x%016lX   ->  0x%016lX\n",i>>1, 
		       (long)phys_avail[i], (long)phys_avail[i+1]);
d234 3
a236 4
	for( i=0;mem_layout[i].mem_last_page;i++){
		printf("mem_layout[%d] page 0x%016lX -> 0x%016lX\n",i,
		       mem_layout[i].mem_first_page,
		       mem_layout[i].mem_last_page);
@


1.36
log
@move octeonreg.h to a more generic location and add multiple inclusion
guards while here.

ok uebayasi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.35 2013/06/01 21:25:26 jasper Exp $ */
d121 6
a126 6
void	dumpsys(void);
void	dumpconf(void);
vaddr_t	mips_init(__register_t, __register_t, __register_t, __register_t);
boolean_t is_memory_range(paddr_t, psize_t, psize_t);
void	octeon_memory_init(struct boot_info *);
int	octeon_cpuspeed(int *);
d130 1
a130 1
extern void parse_uboot_root(void);
@


1.35
log
@- remove more backward compat code and switch the callers over to the new function

ok uebayasi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.34 2013/06/01 17:08:26 jasper Exp $ */
d82 1
a82 1
#include <octeon/dev/octeonreg.h>
@


1.34
log
@corectly initialize the number of cores/cpus on the board. this fixes a NULL
deref in cpuattach() since we advertised only a single CPU, but tried to
attach two.

with this diff bsd.mp boots up on the ERL.

discussed with pirofti@@
ok miod@@ pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.33 2013/04/08 09:42:26 jasper Exp $ */
d708 1
a708 1
		octeon_write_csr(OCTEON_CIU_BASE + CIU_SOFT_RST, 1);
@


1.33
log
@allow octeon to find it's root device, based on the flags passed by U-Boot. The ${bootcmd}
needs to be something like 'bootoctlinux root=/dev/octcf0'.

This will be temporary untill we have proper bootblocks, but for now, this (in combination)
with an upcoming installer diff allows my CAM-0100 to autoboot straight of the disk, without
having to load the kernel via TFTP.

ok bcallah@@ yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.32 2013/04/06 07:53:57 jasper Exp $ */
d128 1
d384 2
d568 13
d801 1
a801 1
	
@


1.32
log
@allow GENERIC.MP to compile again...just for shits and giggles.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.31 2013/04/03 12:03:06 jasper Exp $ */
d98 2
d127 3
d383 2
d563 39
@


1.31
log
@fix comment detailing the memory map

from syuu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.30 2013/03/27 18:32:05 jasper Exp $ */
d724 1
a724 1
	if (kstack == NULL)
@


1.30
log
@fill in cpu_model.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.29 2013/03/19 09:19:10 jasper Exp $ */
d178 1
a178 2
	 * 0000 0000 0000 0000     to  0000 0000 0000 0000
	 * 0000 0000 0FFF FFFF     to  0000 0000 0FFF FFFF
d180 1
a180 2
	 * 0000 0004 1000 0000     to  0000 0004 1000 0000
	 * 0000 0004 1FFF FFFF     to  0000 0004 1FFF FFFF
d182 1
a182 3
	 * 0000 0000 2000 0000     to  0000 0000 2000 0000
	 * 0000 0003 FFFF FFFF     to  0000 0003 FFFF FFFF
	 *
@


1.29
log
@implement octeon_cpuspeed()

ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.24 2013/03/13 14:30:57 jasper Exp $ */
d87 1
a87 1
char	cpu_model[30];
d375 5
d508 1
a508 1
 * cpu_startup: allocate memory for variable-sized tables, initialize CPU, and 
@


1.28
log
@instead of treating boot_info->cf_common_addr special, save the whole of boot_info
for future use.

ok yasuoka@@
@
text
@d124 1
d375 2
d547 8
@


1.27
log
@print a dump of structs boot_info/boot_desc which contain useful information
to have in the dmesg, for the time being

ok bcallah@@ yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.26 2013/03/15 09:19:01 jasper Exp $ */
d95 3
a253 1
	extern uint64_t cf_found;
d367 2
a368 1
	 * Save some initial values needed for device configuration.
d371 2
a372 1
	bcopy(&boot_info->cf_common_addr, &cf_found, sizeof(cf_found));
@


1.26
log
@add some board types which will be used later to identify particular boards

ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.23 2012/10/08 21:47:50 deraadt Exp $ */
d377 1
@


1.25
log
@save a copy of the address at which the CF bus can be found, and use this in octcf(4) for
a better probe function which doesn't unconditionally tries to attach octcf(4). this would
cause endless faults on the EdgeRouter Lite as it lacks a CF bus.

feedback and testing bcallah@@ and chris@@
ok yasuoka@@
@
text
@a84 2
#define BOARD_TYPE_SIM 1

@


1.24
log
@Allow octeon to reboot by poking the right address for a soft cpu reset.
No more yanking the powercable when I hit ddb :)

also tested by bcallah@@

ok bcallah@@ chris@@ yasuoka@@
@
text
@d83 1
a83 66

struct boot_desc {
	uint32_t desc_ver;
	uint32_t desc_size;
	uint64_t stack_top;
	uint64_t heap_start;
	uint64_t heap_end;
	uint64_t __unused17;
	uint64_t __unused16;
	uint32_t __unused18;
	uint32_t __unused15;
	uint32_t __unused14;
	uint32_t argc;
	uint32_t argv[64];
	uint32_t flags;
	uint32_t core_mask;
	uint32_t dram_size;
	uint32_t phy_mem_desc_addr;
	uint32_t debugger_flag_addr;
	uint32_t eclock;
	uint32_t __unused10;
	uint32_t __unused9;
	uint16_t __unused8;
	uint8_t __unused7;
	uint8_t __unused6;
	uint16_t __unused5;
	uint8_t __unused4;
	uint8_t __unused3;
	uint8_t __unused2[20];
	uint8_t __unused1[6];
	uint8_t __unused0;
	uint64_t boot_info_addr;
};

struct boot_info {
	uint32_t ver_major;
	uint32_t ver_minor;
	uint64_t stack_top;
	uint64_t heap_start;
	uint64_t heap_end;
	uint64_t boot_desc_addr;
	uint32_t exception_base_addr;
	uint32_t stack_size;
	uint32_t flags;
	uint32_t core_mask;
	uint32_t dram_size;
	uint32_t phys_mem_desc_addr;
	uint32_t debugger_flags_addr;
	uint32_t eclock;
	uint32_t dclock;
	uint32_t __unused0;
	uint16_t board_type;
	uint8_t board_rev_major;
	uint8_t board_rev_minor;
	uint16_t __unused1;
	uint8_t __unused2;
	uint8_t __unused3;
	char board_serial[20];
	uint8_t mac_addr_base[6];
	uint8_t mac_addr_count;
	uint64_t cf_common_addr;
	uint64_t cf_attr_addr;
	uint64_t led_display_addr;
	uint32_t dfaclock;
	uint32_t config_flags;
};
d253 1
d365 6
@


1.23
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.22 2012/10/03 19:42:54 miod Exp $ */
a684 1
		void (*__reset)(void) = (void (*)(void))RESET_EXC_VEC;
d689 1
a689 1
		__reset();
@


1.22
log
@Don't include <mips64/archtype.h> when you don't need it.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.21 2012/10/03 11:18:23 miod Exp $ */
d676 1
@


1.21
log
@Split ever-growing mips <machine/cpu.h> into what 99% of the kernel needs,
which will remain in <machine/cpu.h>, and a new mips_cpu.h containing only the
goriest md details, which are only of interest to a handful set of files; this
is similar in spirit to what alpha does, but here <machine/cpu.h> does not
include the new file.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.20 2012/09/29 19:11:08 miod Exp $ */
a79 2

#include <mips64/archtype.h>
@


1.20
log
@Kill the mostly unused VMTLB_xxx and VMNUM_xxx defines. Move all tlb
knowledge to <machine/pte.h>. Add specific routines for tlb handling setup
(at cpu initialization time) and tlb ASID wrap.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.19 2012/07/16 16:06:40 miod Exp $ */
d76 1
@


1.19
log
@Forgot these files during the recent clock churning.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.17 2012/03/25 13:52:52 miod Exp $ */
d429 1
a429 4
	tlb_set_page_mask(TLB_PAGE_MASK);
	tlb_set_wired(0);
	tlb_flush(bootcpu_hwinfo.tlbsize);
	tlb_set_wired(UPAGES / 2);
d497 1
a497 1
	tlb_set_pid(1);
d796 1
a796 5
	tlb_set_page_mask(TLB_PAGE_MASK);
	tlb_set_wired(0);
	tlb_flush(64);
	tlb_set_wired(UPAGES / 2);

@


1.18
log
@Remove leftover loongson or sgi references.
@
text
@d819 1
a819 1
	cpu_startclock(ci);
@


1.17
log
@Move cache handling routines related definitions to a dedicated header file,
rather than abusing <machine/cpu.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.16 2012/03/15 18:57:22 miod Exp $ */
a155 1
char	pmon_bootp[80];
a156 5
/*
 * Even though the system is 64bit, the hardware is constrained to up
 * to 2G of contigous physical memory (direct 2GB DMA area), so there
 * is no particular constraint. paddr_t is long so: 
 */
a185 1
extern	void parsepmonbp(void);
d252 1
a252 1
	physmem = btoc(phys_avail[1] - phys_avail[0]);
d418 2
a419 3
	/* FPU reports itself as type 5, version 0.1... */
	bootcpu_hwinfo.c1prid = bootcpu_hwinfo.c0prid;
	bootcpu_hwinfo.tlbsize = 64;
@


1.16
log
@uncached_base was introduced early in IP27 support, since these designs use
subspaces in the CCA_NC uncached memory space. However, being coherent,
there was never a need for bus_dma to use uncached addresses.

This means that, on the only systems where uncached_base was not set to
PHYS_TO_XKPHYS(0, CCA_NC), it was never used.

Remove the variable, and replace PHYS_TO_UNCACHED() with
PHYS_TO_XKPHYS(, CCA_NC). No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.15 2011/06/26 22:40:00 deraadt Exp $ */
d74 1
@


1.15
log
@if_downall() cannot be done MI in sys_reboot() because vfs_shutdown()
might need network (ie. nfs).  Move the call to the MD boot() routines.
This cause for boot hangs diagnosed by kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.14 2011/06/24 19:47:48 naddy Exp $ */
a174 1
vaddr_t	uncached_base;
a372 2

	uncached_base = PHYS_TO_XKPHYS(0, CCA_NC);
@


1.14
log
@machdep.kbdreset enables a shutdown by Ctrl-Alt-Del on amd64 and
i386.  Stop abusing it on other archs for controling a shutdown by
pressing the soft power button:

* Add a MI sysctl hw.allowpowerdown; if set to 1 (the default) it
  allows a power button shutdown.
* Make acpi(4)/acpibtn(4) honor hw.allowpowerdown.
* Switch the various power button intercepts on landisk, sgi, sparc64
  and zaurus over to hw.allowpowerdown.
* Garbage collect the machdep.kbdreset sysctl on all archs other than
  amd64 and i386.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.13 2011/06/05 19:41:07 deraadt Exp $ */
d66 1
d680 1
@


1.13
log
@Move the bufcachepercent setting code to MI locations -- set it to 42%
for now; that is unlikely to hit some of the remaining starvation bugs.
Repair the bufpages calculation too; i386 was doing it ahead of time
(incorrectly) and then re-calculating it.
ok thib
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.12 2011/05/30 22:25:22 oga Exp $ */
a178 1
int	kbd_reset;
a631 4
	case CPU_KBDRESET:
		if (securelevel > 0)
			return (sysctl_rdint(oldp, oldlenp, newp, kbd_reset));
		return (sysctl_int(oldp, oldlenp, newp, newlen, &kbd_reset));
@


1.12
log
@Remove the freelist member from vm_physseg

The new world order of pmemrange makes this data completely redundant
(being dealt with by the pmemrange constraints instead). Remove all code
that messes with the freelist.

While touching every caller of uvm_page_physload() anyway, add the flags
argument to all callers (all but one is 0 and that one already used
PHYSLOAD_DEVICE) and remove the macro magic to allow callers to continue
without it.

Should shrink the code a bit, as well.

matthew@@ pointed out some mistakes i'd made.
``freelist death, I like. Ok.' ariane@@
`I agree with the general direction, go ahead and i'll fix any fallout
shortly'' miod@@ (68k 88k and vax i could not check would build)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.11 2011/05/08 20:49:19 syuu Exp $ */
a154 12

/*
 * Declare these as initialized data so we can patch them.
 */
#ifndef	BUFCACHEPERCENT
#define	BUFCACHEPERCENT	5	/* Can be changed in config. */
#endif
#ifndef	BUFPAGES
#define BUFPAGES 0		/* Can be changed in config. */
#endif
int	bufpages = BUFPAGES;
int	bufcachepercent = BUFCACHEPERCENT;
@


1.11
log
@memory handling fix
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.10 2011/05/08 13:45:03 syuu Exp $ */
a229 1
	mem_layout[0].mem_freelist = VM_FREELIST_DEFAULT;
a282 1
			mem_layout[2].mem_freelist = VM_FREELIST_DEFAULT;
a291 1
			mem_layout[1].mem_freelist = VM_FREELIST_DEFAULT;
a300 1
			mem_layout[1].mem_freelist = VM_FREELIST_DEFAULT;
a401 1
		unsigned int freelist;
a412 1
		freelist = mem_layout[i].mem_freelist;
d419 1
a419 1
			uvm_page_physload(fp, lp, fp, lp, freelist);
d429 1
a429 1
			uvm_page_physload(fp, xp, fp, xp, freelist);
d433 1
a433 1
			uvm_page_physload(fp, lp, fp, lp, freelist);
@


1.10
log
@fix variable name
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.9 2011/05/08 13:39:30 syuu Exp $ */
d276 1
a276 1
#if 0
d282 4
a285 3
			mem_layout[1].mem_first_page = atop(phys_avail[2]);
			mem_layout[1].mem_last_page = atop(phys_avail[3]-1);
			mem_layout[1].mem_freelist = VM_FREELIST_DEFAULT;
d287 1
a287 1
#endif
d292 3
a294 3
			mem_layout[2].mem_first_page = atop(phys_avail[4]);
			mem_layout[2].mem_last_page = atop(phys_avail[5]-1);
			mem_layout[2].mem_freelist = VM_FREELIST_DEFAULT;
d297 1
d306 1
@


1.9
log
@combus renamed uartbus, com_oct renamed cn30xxuart
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.8 2011/05/08 13:24:55 syuu Exp $ */
d210 1
a210 1
struct consdev octcons = cons_init(cn30xxuart);
d359 1
a359 1
	cn_tab = &octcons;
@


1.8
log
@obio renamed iobus, moved interrupt handler code to dev/octeon_intr.c
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.7 2010/11/28 20:53:41 syuu Exp $ */
d209 2
a210 2
cons_decl(com_oct);
struct consdev octcons = cons_init(com_oct);
@


1.7
log
@boot descriptor support added
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.6 2010/11/23 22:06:57 syuu Exp $ */
d80 1
a80 1
#include <octeon/dev/obiovar.h>
d790 2
a791 2
extern bus_space_t obio_tag;
extern bus_space_handle_t obio_h;
d850 1
a850 1
	obio_intr_init();
d852 1
a852 1
	obio_setintrmask(0);
d871 1
a871 1
	bus_space_write_8(&obio_tag, obio_h, CIU_IP3_EN0(cpuid), 0);
d878 1
a878 1
	bus_space_write_8(&obio_tag, obio_h, CIU_IP3_EN0(cpuid),
d889 1
a889 1
	bus_space_write_8(&obio_tag, obio_h, CIU_MBOX_CLR(cpuid),
d891 1
a891 1
	bus_space_write_8(&obio_tag, obio_h, CIU_IP3_EN0(cpuid),
d901 1
a901 1
	bus_space_write_8(&obio_tag, obio_h, CIU_MBOX_SET(cpuid), 1);
d908 2
a909 2
		bus_space_read_8(&obio_tag, obio_h, CIU_MBOX_CLR(cpuid));
	bus_space_write_8(&obio_tag, obio_h, CIU_MBOX_CLR(cpuid), clr);
@


1.6
log
@passing stack pointer to secondary processors
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.5 2010/11/23 18:46:29 syuu Exp $ */
d83 68
d207 1
a207 1
void	octeon_memory_init(void);
d214 2
d217 1
a217 1
octeon_memory_init(void)
d219 1
a219 1
	uint64_t phys_avail[10 + 2];
d224 2
a232 1
	uint32_t realmem_bytes;
d234 5
a238 3
#if 0
	if (octeon_board_real()) {
		realmem_bytes = (octeon_dram - PAGE_SIZE);
a239 5
	} else 
#endif
	{
		/* Simulator we limit to 96 meg */
		realmem_bytes = (96 << 20);
a241 1
	memset((void*)phys_avail,0,sizeof(phys_avail));
d244 5
a248 2
#if 0
	if (octeon_board_real()) {
a255 5
	} else
#endif
	{
		/* Simulator gets 96Meg period. */
		phys_avail[1] = (96 << 20);
d257 1
d273 3
a276 2
	if (octeon_board_real()){
		if(realmem_bytes > OCTEON_DRAM_FIRST_256_END){
d286 1
d306 1
a306 1
#endif
d308 3
a310 3
#if 0
	printf("Total DRAM Size 0x%016X\n", (uint32_t) octeon_dram);
#endif
d333 2
d340 4
d381 1
a381 2
	/* XXX: We should get clockrate from boot descriptor */
	bootcpu_hwinfo.clock = 500000000;
d390 1
a390 1
	octeon_memory_init();
d465 46
@


1.5
log
@Correct interrupt handling
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.4 2010/10/24 15:40:03 miod Exp $ */
d665 2
a666 2
unsigned octeon_ap_boot = ~0;
struct cpu_info *cpu_info_boot_secondary = NULL;
d683 3
a685 2
	cpu_info_boot_secondary = ci;
	octeon_ap_boot = ci->ci_cpuid;
d725 2
@


1.4
log
@Move build_trampoline() and setregs() to a common location for all mips ports.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.3 2010/10/01 16:13:59 syuu Exp $ */
a79 2
#include <machine/octeon_pcmap_regs.h>

d667 7
a682 1

a683 1
	
a725 1

d728 1
a728 1

a730 1

d738 23
d764 9
a772 2
	obio_intr_establish(CIU_INT_MBOX(cpuid), IPL_IPI, func,
		(void *)cpuid, NULL);
d779 1
a779 1
	*(uint64_t *)OCTEON_CIU_MBOX_SETX(cpuid) = 1;
d785 3
a787 1
	*(uint64_t *)OCTEON_CIU_MBOX_CLRX(cpuid) = 1;
d790 11
@


1.3
log
@Implemented combus to support com device on OCTEON without modifing dev/ic/com.c ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.2 2010/09/21 06:21:00 syuu Exp $ */
a135 1
void	build_trampoline(vaddr_t, vaddr_t);
a451 67
 * Build a tlb trampoline
 */
void
build_trampoline(vaddr_t addr, vaddr_t dest)
{
	const uint32_t insns[] = {
		0x3c1a0000,	/* lui k0, imm16 */
		0x675a0000,	/* daddiu k0, k0, imm16 */
		0x001ad438,	/* dsll k0, k0, 0x10 */
		0x675a0000,	/* daddiu k0, k0, imm16 */
		0x001ad438,	/* dsll k0, k0, 0x10 */
		0x675a0000,	/* daddiu k0, k0, imm16 */
		0x03400008,	/* jr k0 */
		0x00000000	/* nop */
	};
	uint32_t *dst = (uint32_t *)addr;
	const uint32_t *src = insns;
	uint32_t a, b, c, d;

	/*
	 * Decompose the handler address in the four components which,
	 * added with sign extension, will produce the correct address.
	 */
	d = dest & 0xffff;
	dest >>= 16;
	if (d & 0x8000)
		dest++;
	c = dest & 0xffff;
	dest >>= 16;
	if (c & 0x8000)
		dest++;
	b = dest & 0xffff;
	dest >>= 16;
	if (b & 0x8000)
		dest++;
	a = dest & 0xffff;

	/*
	 * Build the trampoline, skipping noop computations.
	 */
	*dst++ = *src++ | a;
	if (b != 0)
		*dst++ = *src++ | b;
	else
		src++;
	*dst++ = *src++;
	if (c != 0)
		*dst++ = *src++ | c;
	else
		src++;
	*dst++ = *src++;
	if (d != 0)
		*dst++ = *src++ | d;
	else
		src++;
	*dst++ = *src++;
	*dst++ = *src++;

	/*
	 * Note that we keep the delay slot instruction a nop, instead
	 * of branching to the second instruction of the handler and
	 * having its first instruction in the delay slot, so that the
	 * tlb handler is free to use k0 immediately.
	 */
}

/*
a538 32

/*
 * Set registers on exec for native exec format. For o64/64.
 */
void
setregs(p, pack, stack, retval)
	struct proc *p;
	struct exec_package *pack;
	u_long stack;
	register_t *retval;
{
	struct cpu_info *ci = curcpu();

	bzero((caddr_t)p->p_md.md_regs, sizeof(struct trap_frame));
	p->p_md.md_regs->sp = stack;
	p->p_md.md_regs->pc = pack->ep_entry & ~3;
	p->p_md.md_regs->t9 = pack->ep_entry & ~3; /* abicall req */
	p->p_md.md_regs->sr = SR_FR_32 | SR_XX | SR_KSU_USER | SR_KX | SR_UX |
	    SR_EXL | SR_INT_ENAB;
	p->p_md.md_regs->sr |= idle_mask & SR_INT_MASK;
	p->p_md.md_regs->ic = (idle_mask << 8) & IC_INT_MASK;
	p->p_md.md_flags &= ~MDP_FPUSED;
	if (ci->ci_fpuproc == p)
		ci->ci_fpuproc = NULL;
	p->p_md.md_ss_addr = 0;
	p->p_md.md_pc_ctrl = 0;
	p->p_md.md_watch_1 = 0;
	p->p_md.md_watch_2 = 0;

	retval[1] = 0;
}

@


1.2
log
@Remove bootinfo.c which has license issue. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.1 2010/09/20 06:32:30 syuu Exp $ */
d144 3
d284 5
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.19 2010/05/08 21:59:56 miod Exp $ */
a83 1
#include <machine/bootinfo.h>
d163 1
d167 3
a169 1
	} else {
d177 1
d186 3
a188 1
	} else {
d240 1
d242 1
a262 1
	u_long cpuspeed;
a299 2
	octeon_boot_params_init(a3);

a300 5
	/*
	 * Figure out processor clock speed.
	 * Hopefully the processor speed, in Hertz, will not overflow
	 * uint32_t...
	 */
d302 2
a303 2
	cpuspeed = octeon_get_clock_rate();
	bootcpu_hwinfo.clock = cpuspeed;
@

