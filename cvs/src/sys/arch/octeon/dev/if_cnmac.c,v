head	1.62;
access;
symbols
	OPENBSD_6_1_BASE:1.62
	OPENBSD_6_0:1.52.0.2
	OPENBSD_6_0_BASE:1.52
	OPENBSD_5_9:1.37.0.2
	OPENBSD_5_9_BASE:1.37
	OPENBSD_5_8:1.23.0.4
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.12.0.4
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.7.0.8
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.6
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.4
	OPENBSD_5_0:1.7.0.2
	OPENBSD_5_0_BASE:1.7;
locks; strict;
comment	@ * @;


1.62
date	2017.01.24.03.57.34;	author dlg;	state Exp;
branches;
next	1.61;
commitid	PERtGPXCvlLRRBr8;

1.61
date	2016.11.05.05.14.18;	author visa;	state Exp;
branches;
next	1.60;
commitid	IwAqHpahrCHdBZCT;

1.60
date	2016.11.05.05.09.49;	author visa;	state Exp;
branches;
next	1.59;
commitid	3aZNIKrahnXLhl3A;

1.59
date	2016.11.02.01.29.43;	author visa;	state Exp;
branches;
next	1.58;
commitid	35AyR1qcZQ15uqV0;

1.58
date	2016.08.14.08.49.37;	author visa;	state Exp;
branches;
next	1.57;
commitid	Ee2wVsnNIDHd82uh;

1.57
date	2016.08.06.04.32.24;	author visa;	state Exp;
branches;
next	1.56;
commitid	lbRa5XjXCVkRiBMz;

1.56
date	2016.08.05.13.18.27;	author visa;	state Exp;
branches;
next	1.55;
commitid	gqK8v38Uji2feXEn;

1.55
date	2016.08.04.13.10.31;	author visa;	state Exp;
branches;
next	1.54;
commitid	0L54RPNzULFkReBc;

1.54
date	2016.07.30.09.45.09;	author visa;	state Exp;
branches;
next	1.53;
commitid	qPMO1g0qhl5uZJDu;

1.53
date	2016.07.30.09.29.14;	author visa;	state Exp;
branches;
next	1.52;
commitid	UUvkFxa9Mzejbqe8;

1.52
date	2016.06.22.13.09.35;	author visa;	state Exp;
branches;
next	1.51;
commitid	KLZKLKw34aQIX6oW;

1.51
date	2016.05.30.15.41.28;	author visa;	state Exp;
branches;
next	1.50;
commitid	pQeTOuXCP1quhpMp;

1.50
date	2016.05.29.11.10.25;	author visa;	state Exp;
branches;
next	1.49;
commitid	6Qia14IK1r8MeKBb;

1.49
date	2016.05.24.14.06.39;	author visa;	state Exp;
branches;
next	1.48;
commitid	NmQ36NfjDnWgV8QE;

1.48
date	2016.05.24.12.56.14;	author visa;	state Exp;
branches;
next	1.47;
commitid	R0N0UO0Iw6sA4r7Y;

1.47
date	2016.05.24.12.50.14;	author visa;	state Exp;
branches;
next	1.46;
commitid	crWoRyPywmJajtex;

1.46
date	2016.05.23.15.22.45;	author tedu;	state Exp;
branches;
next	1.45;
commitid	Hsu9ZZbSw737UJHI;

1.45
date	2016.05.21.11.04.38;	author visa;	state Exp;
branches;
next	1.44;
commitid	8L2xIescpwStJQZy;

1.44
date	2016.05.21.10.45.22;	author visa;	state Exp;
branches;
next	1.43;
commitid	x1WUQRc7x4IB08Eo;

1.43
date	2016.05.19.16.17.07;	author visa;	state Exp;
branches;
next	1.42;
commitid	KTKN3Tk9uCs4Usyo;

1.42
date	2016.05.19.15.42.03;	author visa;	state Exp;
branches;
next	1.41;
commitid	xHnTo1w8gEH1iT9X;

1.41
date	2016.04.27.15.44.27;	author visa;	state Exp;
branches;
next	1.40;
commitid	BmYrwebnpbi53Tgk;

1.40
date	2016.04.26.11.22.05;	author visa;	state Exp;
branches;
next	1.39;
commitid	z2weDohCZ7YoL32v;

1.39
date	2016.04.26.11.07.09;	author visa;	state Exp;
branches;
next	1.38;
commitid	6JzAS8wtDR2Z7CT5;

1.38
date	2016.04.13.11.34.00;	author mpi;	state Exp;
branches;
next	1.37;
commitid	RI1iBTF6Zaycxppg;

1.37
date	2015.12.18.13.36.12;	author visa;	state Exp;
branches;
next	1.36;
commitid	MnFMDPctt98eKUU4;

1.36
date	2015.11.25.14.00.27;	author visa;	state Exp;
branches;
next	1.35;
commitid	Snt90KzVS8HTiyw8;

1.35
date	2015.11.25.03.09.58;	author dlg;	state Exp;
branches;
next	1.34;
commitid	B0kwmVGiD5DVx4kv;

1.34
date	2015.11.24.17.11.38;	author mpi;	state Exp;
branches;
next	1.33;
commitid	5gdEnqVoJuTuwdTu;

1.33
date	2015.11.21.05.11.32;	author visa;	state Exp;
branches;
next	1.32;
commitid	aFiZuGW2Sk8jLpV4;

1.32
date	2015.11.20.15.16.06;	author visa;	state Exp;
branches;
next	1.31;
commitid	LDy2W96ujNApZ1Lr;

1.31
date	2015.11.18.16.05.22;	author visa;	state Exp;
branches;
next	1.30;
commitid	2gDAOH7GY5fJnQQl;

1.30
date	2015.11.13.14.43.33;	author visa;	state Exp;
branches;
next	1.29;
commitid	insI61RLGTQraIPg;

1.29
date	2015.10.28.14.04.17;	author visa;	state Exp;
branches;
next	1.28;
commitid	Xhol3D4xmRpcQ7Qa;

1.28
date	2015.10.28.14.00.34;	author visa;	state Exp;
branches;
next	1.27;
commitid	I2YtnBuS5jjZceh6;

1.27
date	2015.10.25.13.22.09;	author mpi;	state Exp;
branches;
next	1.26;
commitid	n8mxDftG1cK0Rpp7;

1.26
date	2015.10.24.05.35.42;	author visa;	state Exp;
branches;
next	1.25;
commitid	wZAHQXs0eU7Zj2Uz;

1.25
date	2015.10.15.14.06.04;	author visa;	state Exp;
branches;
next	1.24;
commitid	PYHrmWwRRUtnEm6n;

1.24
date	2015.10.08.14.24.32;	author visa;	state Exp;
branches;
next	1.23;
commitid	8Cjm6FFYim6bo1uY;

1.23
date	2015.06.11.12.30.42;	author jmatthew;	state Exp;
branches;
next	1.22;
commitid	WYFLHGYwS5er1XQl;

1.22
date	2015.04.30.21.52.49;	author mpi;	state Exp;
branches;
next	1.21;
commitid	BlAw9uOanMMWUzFk;

1.21
date	2014.12.22.02.26.53;	author tedu;	state Exp;
branches;
next	1.20;
commitid	2Ez9mHW0jDzojG4V;

1.20
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.19;
commitid	LS2TNeCue5R9L67C;

1.19
date	2014.08.11.19.00.50;	author miod;	state Exp;
branches;
next	1.18;
commitid	WSyMUxaCd6qqqO0W;

1.18
date	2014.08.11.18.56.49;	author miod;	state Exp;
branches;
next	1.17;
commitid	so4P7oFhL2prGC7B;

1.17
date	2014.08.11.18.29.56;	author miod;	state Exp;
branches;
next	1.16;
commitid	8Kx1Ci8ysFEuhw0R;

1.16
date	2014.08.11.18.08.17;	author miod;	state Exp;
branches;
next	1.15;
commitid	3N1WQMXOTORvYvCh;

1.15
date	2014.07.22.10.35.35;	author mpi;	state Exp;
branches;
next	1.14;
commitid	EXpEDqO4x724IPl8;

1.14
date	2014.05.10.22.25.16;	author jasper;	state Exp;
branches;
next	1.13;

1.13
date	2014.03.10.09.41.27;	author jasper;	state Exp;
branches;
next	1.12;

1.12
date	2013.09.16.20.52.14;	author jmatthew;	state Exp;
branches;
next	1.11;

1.11
date	2013.08.17.10.00.09;	author bluhm;	state Exp;
branches;
next	1.10;

1.10
date	2013.04.12.15.22.26;	author bcallah;	state Exp;
branches;
next	1.9;

1.9
date	2013.03.21.09.29.12;	author jasper;	state Exp;
branches;
next	1.8;

1.8
date	2013.03.21.09.26.31;	author jasper;	state Exp;
branches;
next	1.7;

1.7
date	2011.07.03.21.42.11;	author yasuoka;	state Exp;
branches;
next	1.6;

1.6
date	2011.07.03.20.26.33;	author yasuoka;	state Exp;
branches;
next	1.5;

1.5
date	2011.06.24.02.13.23;	author yasuoka;	state Exp;
branches;
next	1.4;

1.4
date	2011.06.22.07.29.06;	author yasuoka;	state Exp;
branches;
next	1.3;

1.3
date	2011.06.19.02.01.23;	author yasuoka;	state Exp;
branches;
next	1.2;

1.2
date	2011.06.17.03.36.24;	author yasuoka;	state Exp;
branches;
next	1.1;

1.1
date	2011.06.16.11.22.30;	author syuu;	state Exp;
branches;
next	;


desc
@@


1.62
log
@add support for multiple transmit ifqueues per network interface.

an ifq to transmit a packet is picked by the current traffic
conditioner (ie, priq or hfsc) by providing an index into an array
of ifqs. by default interfaces get a single ifq but can ask for
more using if_attach_queues().

the vast majority of our drivers still think there's a 1:1 mapping
between interfaces and transmit queues, so their if_start routines
take an ifnet pointer instead of a pointer to the ifqueue struct.
instead of changing all the drivers in the tree, drivers can opt
into using an if_qstart routine and setting the IFXF_MPSAFE flag.
the stack provides a compatability wrapper from the new if_qstart
handler to the previous if_start handlers if IFXF_MPSAFE isnt set.

enabling hfsc on an interface configures it to transmit everything
through the first ifq. any other ifqs are left configured as priq,
but unused, when hfsc is enabled.

getting this in now so everyone can kick the tyres.

ok mpi@@ visa@@ (who provided some tweaks for cnmac).
@
text
@/*	$OpenBSD: if_cnmac.c,v 1.61 2016/11/05 05:14:18 visa Exp $	*/

/*
 * Copyright (c) 2007 Internet Initiative Japan, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#include "bpfilter.h"

/*
 * XXXSEIL
 * If no free send buffer is available, free all the sent buffer and bail out.
 */
#define OCTEON_ETH_SEND_QUEUE_CHECK

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/pool.h>
#include <sys/proc.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/device.h>
#include <sys/queue.h>
#include <sys/conf.h>
#include <sys/stdint.h> /* uintptr_t */
#include <sys/syslog.h>
#include <sys/endian.h>
#include <sys/atomic.h>

#include <net/if.h>
#include <net/if_media.h>
#include <netinet/in.h>
#include <netinet/if_ether.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <machine/bus.h>
#include <machine/intr.h>
#include <machine/octeonvar.h>
#include <machine/octeon_model.h>

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>

#include <octeon/dev/cn30xxciureg.h>
#include <octeon/dev/cn30xxnpireg.h>
#include <octeon/dev/cn30xxgmxreg.h>
#include <octeon/dev/cn30xxipdreg.h>
#include <octeon/dev/cn30xxpipreg.h>
#include <octeon/dev/cn30xxpowreg.h>
#include <octeon/dev/cn30xxfaureg.h>
#include <octeon/dev/cn30xxfpareg.h>
#include <octeon/dev/cn30xxbootbusreg.h>
#include <octeon/dev/cn30xxfpavar.h>
#include <octeon/dev/cn30xxgmxvar.h>
#include <octeon/dev/cn30xxfauvar.h>
#include <octeon/dev/cn30xxpowvar.h>
#include <octeon/dev/cn30xxipdvar.h>
#include <octeon/dev/cn30xxpipvar.h>
#include <octeon/dev/cn30xxpkovar.h>
#include <octeon/dev/cn30xxsmivar.h>
#include <octeon/dev/iobusvar.h>
#include <octeon/dev/if_cnmacvar.h>

#ifdef OCTEON_ETH_DEBUG
#define	OCTEON_ETH_KASSERT(x)	KASSERT(x)
#define	OCTEON_ETH_KDASSERT(x)	KDASSERT(x)
#else
#define	OCTEON_ETH_KASSERT(x)
#define	OCTEON_ETH_KDASSERT(x)
#endif

/*
 * Set the PKO to think command buffers are an odd length.  This makes it so we
 * never have to divide a comamnd across two buffers.
 */
#define OCTEON_POOL_NWORDS_CMD	\
	    (((uint32_t)OCTEON_POOL_SIZE_CMD / sizeof(uint64_t)) - 1)
#define FPA_COMMAND_BUFFER_POOL_NWORDS	OCTEON_POOL_NWORDS_CMD	/* XXX */

void	octeon_eth_buf_init(struct octeon_eth_softc *);

int	octeon_eth_match(struct device *, void *, void *);
void	octeon_eth_attach(struct device *, struct device *, void *);
void	octeon_eth_pip_init(struct octeon_eth_softc *);
void	octeon_eth_ipd_init(struct octeon_eth_softc *);
void	octeon_eth_pko_init(struct octeon_eth_softc *);
void	octeon_eth_smi_init(struct octeon_eth_softc *);

void	octeon_eth_board_mac_addr(uint8_t *);

int	octeon_eth_mii_readreg(struct device *, int, int);
void	octeon_eth_mii_writereg(struct device *, int, int, int);
void	octeon_eth_mii_statchg(struct device *);

int	octeon_eth_mediainit(struct octeon_eth_softc *);
void	octeon_eth_mediastatus(struct ifnet *, struct ifmediareq *);
int	octeon_eth_mediachange(struct ifnet *);

void	octeon_eth_send_queue_flush_prefetch(struct octeon_eth_softc *);
void	octeon_eth_send_queue_flush_fetch(struct octeon_eth_softc *);
void	octeon_eth_send_queue_flush(struct octeon_eth_softc *);
int	octeon_eth_send_queue_is_full(struct octeon_eth_softc *);
void	octeon_eth_send_queue_add(struct octeon_eth_softc *,
	    struct mbuf *, uint64_t *);
void	octeon_eth_send_queue_del(struct octeon_eth_softc *,
	    struct mbuf **, uint64_t **);
int	octeon_eth_buf_free_work(struct octeon_eth_softc *, uint64_t *);
void	octeon_eth_buf_ext_free(caddr_t, u_int, void *);

int	octeon_eth_ioctl(struct ifnet *, u_long, caddr_t);
void	octeon_eth_watchdog(struct ifnet *);
int	octeon_eth_init(struct ifnet *);
int	octeon_eth_stop(struct ifnet *, int);
void	octeon_eth_start(struct ifqueue *);

int	octeon_eth_send_cmd(struct octeon_eth_softc *, uint64_t, uint64_t);
uint64_t octeon_eth_send_makecmd_w1(int, paddr_t);
uint64_t octeon_eth_send_makecmd_w0(uint64_t, uint64_t, size_t, int, int);
int	octeon_eth_send_makecmd_gbuf(struct octeon_eth_softc *,
	    struct mbuf *, uint64_t *, int *);
int	octeon_eth_send_makecmd(struct octeon_eth_softc *,
	    struct mbuf *, uint64_t *, uint64_t *, uint64_t *);
int	octeon_eth_send_buf(struct octeon_eth_softc *,
	    struct mbuf *, uint64_t *);
int	octeon_eth_send(struct octeon_eth_softc *, struct mbuf *);

int	octeon_eth_reset(struct octeon_eth_softc *);
int	octeon_eth_configure(struct octeon_eth_softc *);
int	octeon_eth_configure_common(struct octeon_eth_softc *);

void	octeon_eth_free_task(void *);
void	octeon_eth_tick_free(void *arg);
void	octeon_eth_tick_misc(void *);

int	octeon_eth_recv_mbuf(struct octeon_eth_softc *,
	    uint64_t *, struct mbuf **, int *);
int	octeon_eth_recv_check(struct octeon_eth_softc *, uint64_t);
int	octeon_eth_recv(struct octeon_eth_softc *, uint64_t *);
void	octeon_eth_recv_intr(void *, uint64_t *);

int	octeon_eth_mbuf_alloc(int);

/* device driver context */
struct	octeon_eth_softc *octeon_eth_gsc[GMX_PORT_NUNITS];
void	*octeon_eth_pow_recv_ih;

/* device parameters */
int	octeon_eth_param_pko_cmd_w0_n2 = 1;

const struct cfattach cnmac_ca =
    { sizeof(struct octeon_eth_softc), octeon_eth_match, octeon_eth_attach };

struct cfdriver cnmac_cd = { NULL, "cnmac", DV_IFNET };

/* ---- buffer management */

const struct octeon_eth_pool_param {
	int			poolno;
	size_t			size;
	size_t			nelems;
} octeon_eth_pool_params[] = {
#define	_ENTRY(x)	{ OCTEON_POOL_NO_##x, OCTEON_POOL_SIZE_##x, OCTEON_POOL_NELEMS_##x }
	_ENTRY(WQE),
	_ENTRY(CMD),
	_ENTRY(SG)
#undef	_ENTRY
};
struct cn30xxfpa_buf	*octeon_eth_pools[8/* XXX */];
#define	octeon_eth_fb_wqe	octeon_eth_pools[OCTEON_POOL_NO_WQE]
#define	octeon_eth_fb_cmd	octeon_eth_pools[OCTEON_POOL_NO_CMD]
#define	octeon_eth_fb_sg	octeon_eth_pools[OCTEON_POOL_NO_SG]

uint64_t octeon_eth_mac_addr = 0;
uint32_t octeon_eth_mac_addr_offset = 0;

int	octeon_eth_mbufs_to_alloc;

void
octeon_eth_buf_init(struct octeon_eth_softc *sc)
{
	static int once;
	int i;
	const struct octeon_eth_pool_param *pp;
	struct cn30xxfpa_buf *fb;

	if (once == 1)
		return;
	once = 1;

	for (i = 0; i < (int)nitems(octeon_eth_pool_params); i++) {
		pp = &octeon_eth_pool_params[i];
		cn30xxfpa_buf_init(pp->poolno, pp->size, pp->nelems, &fb);
		octeon_eth_pools[pp->poolno] = fb;
	}
}

/* ---- autoconf */

int
octeon_eth_match(struct device *parent, void *match, void *aux)
{
	struct cfdata *cf = (struct cfdata *)match;
	struct cn30xxgmx_attach_args *ga = aux;

	if (strcmp(cf->cf_driver->cd_name, ga->ga_name) != 0) {
		return 0;
	}
	return 1;
}

void
octeon_eth_attach(struct device *parent, struct device *self, void *aux)
{
	struct octeon_eth_softc *sc = (void *)self;
	struct cn30xxgmx_attach_args *ga = aux;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	uint8_t enaddr[ETHER_ADDR_LEN];

	KASSERT(MCLBYTES >= OCTEON_POOL_SIZE_PKT + CACHE_LINE_SIZE);

	atomic_add_int(&octeon_eth_mbufs_to_alloc,
	    octeon_eth_mbuf_alloc(OCTEON_ETH_MBUFS_PER_PORT));

	sc->sc_regt = ga->ga_regt;
	sc->sc_dmat = ga->ga_dmat;
	sc->sc_port = ga->ga_portno;
	sc->sc_port_type = ga->ga_port_type;
	sc->sc_gmx = ga->ga_gmx;
	sc->sc_gmx_port = ga->ga_gmx_port;
	sc->sc_phy_addr = ga->ga_phy_addr;

	sc->sc_init_flag = 0;

	/*
	 * XXX
	 * Setting PIP_IP_OFFSET[OFFSET] to 8 causes panic ... why???
	 */
	sc->sc_ip_offset = 0/* XXX */;

	octeon_eth_board_mac_addr(enaddr);
	printf(", address %s\n", ether_sprintf(enaddr));

	octeon_eth_gsc[sc->sc_port] = sc;

	ml_init(&sc->sc_sendq);
	sc->sc_soft_req_thresh = 15/* XXX */;
	sc->sc_ext_callback_cnt = 0;

	cn30xxgmx_stats_init(sc->sc_gmx_port);

	task_set(&sc->sc_free_task, octeon_eth_free_task, sc);
	timeout_set(&sc->sc_tick_misc_ch, octeon_eth_tick_misc, sc);
	timeout_set(&sc->sc_tick_free_ch, octeon_eth_tick_free, sc);

	cn30xxfau_op_init(&sc->sc_fau_done,
	    OCTEON_CVMSEG_ETHER_OFFSET(sc->sc_dev.dv_unit, csm_ether_fau_done),
	    OCT_FAU_REG_ADDR_END - (8 * (sc->sc_dev.dv_unit + 1))/* XXX */);
	cn30xxfau_op_set_8(&sc->sc_fau_done, 0);

	octeon_eth_pip_init(sc);
	octeon_eth_ipd_init(sc);
	octeon_eth_pko_init(sc);
	octeon_eth_smi_init(sc);

	sc->sc_gmx_port->sc_ipd = sc->sc_ipd;
	sc->sc_gmx_port->sc_port_mii = &sc->sc_mii;
	sc->sc_gmx_port->sc_port_ac = &sc->sc_arpcom;

	/* XXX */
	sc->sc_pow = &cn30xxpow_softc;

	octeon_eth_mediainit(sc);

	strncpy(ifp->if_xname, sc->sc_dev.dv_xname, sizeof(ifp->if_xname));
	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_xflags = IFXF_MPSAFE;
	ifp->if_ioctl = octeon_eth_ioctl;
	ifp->if_qstart = octeon_eth_start;
	ifp->if_watchdog = octeon_eth_watchdog;
	ifp->if_hardmtu = OCTEON_ETH_MAX_MTU;
	IFQ_SET_MAXLEN(&ifp->if_snd, max(GATHER_QUEUE_SIZE, IFQ_MAXLEN));

	ifp->if_capabilities = IFCAP_VLAN_MTU | IFCAP_CSUM_TCPv4 |
	    IFCAP_CSUM_UDPv4 | IFCAP_CSUM_TCPv6 | IFCAP_CSUM_UDPv6;

	cn30xxgmx_set_mac_addr(sc->sc_gmx_port, enaddr);
	cn30xxgmx_set_filter(sc->sc_gmx_port);

	if_attach(ifp);

	memcpy(sc->sc_arpcom.ac_enaddr, enaddr, ETHER_ADDR_LEN);
	ether_ifattach(ifp);

#if 1
	octeon_eth_buf_init(sc);
#endif

	if (octeon_eth_pow_recv_ih == NULL)
		octeon_eth_pow_recv_ih = cn30xxpow_intr_establish(
		    OCTEON_POW_GROUP_PIP, IPL_NET | IPL_MPSAFE,
		    octeon_eth_recv_intr, NULL, NULL, cnmac_cd.cd_name);
}

/* ---- submodules */

/* XXX */
void
octeon_eth_pip_init(struct octeon_eth_softc *sc)
{
	struct cn30xxpip_attach_args pip_aa;

	pip_aa.aa_port = sc->sc_port;
	pip_aa.aa_regt = sc->sc_regt;
	pip_aa.aa_tag_type = POW_TAG_TYPE_ORDERED/* XXX */;
	pip_aa.aa_receive_group = OCTEON_POW_GROUP_PIP;
	pip_aa.aa_ip_offset = sc->sc_ip_offset;
	cn30xxpip_init(&pip_aa, &sc->sc_pip);
}

/* XXX */
void
octeon_eth_ipd_init(struct octeon_eth_softc *sc)
{
	struct cn30xxipd_attach_args ipd_aa;

	ipd_aa.aa_port = sc->sc_port;
	ipd_aa.aa_regt = sc->sc_regt;
	ipd_aa.aa_first_mbuff_skip = 0/* XXX */;
	ipd_aa.aa_not_first_mbuff_skip = 0/* XXX */;
	cn30xxipd_init(&ipd_aa, &sc->sc_ipd);
}

/* XXX */
void
octeon_eth_pko_init(struct octeon_eth_softc *sc)
{
	struct cn30xxpko_attach_args pko_aa;

	pko_aa.aa_port = sc->sc_port;
	pko_aa.aa_regt = sc->sc_regt;
	pko_aa.aa_cmdptr = &sc->sc_cmdptr;
	pko_aa.aa_cmd_buf_pool = OCTEON_POOL_NO_CMD;
	pko_aa.aa_cmd_buf_size = OCTEON_POOL_NWORDS_CMD;
	cn30xxpko_init(&pko_aa, &sc->sc_pko);
}

void
octeon_eth_smi_init(struct octeon_eth_softc *sc)
{
	struct cn30xxsmi_attach_args smi_aa;

	smi_aa.aa_port = sc->sc_port;
	smi_aa.aa_regt = sc->sc_regt;
	cn30xxsmi_init(&smi_aa, &sc->sc_smi);
	cn30xxsmi_set_clock(sc->sc_smi, 0x1464ULL); /* XXX */
}

/* ---- XXX */

void
octeon_eth_board_mac_addr(uint8_t *enaddr)
{
	int id;

	/* Initialize MAC addresses from the global address base. */
	if (octeon_eth_mac_addr == 0) {
		memcpy((uint8_t *)&octeon_eth_mac_addr + 2,
		    octeon_boot_info->mac_addr_base, 6);

		/*
		 * Should be allowed to fail hard if couldn't read the
		 * mac_addr_base address...
		 */
		if (octeon_eth_mac_addr == 0)
			return;

		/*
		 * Calculate the offset from the mac_addr_base that will be used
		 * for the next sc->sc_port.
		 */
		id = octeon_get_chipid();

		switch (octeon_model_family(id)) {
		case OCTEON_MODEL_FAMILY_CN56XX:
			octeon_eth_mac_addr_offset = 1;
			break;
		/*
		case OCTEON_MODEL_FAMILY_CN52XX:
		case OCTEON_MODEL_FAMILY_CN63XX:
			octeon_eth_mac_addr_offset = 2;
			break;
		*/
		default:
			octeon_eth_mac_addr_offset = 0;
			break;
		}

		enaddr += octeon_eth_mac_addr_offset;
	}

	/* No more MAC addresses to assign. */
	if (octeon_eth_mac_addr_offset >= octeon_boot_info->mac_addr_count)
		return;

	if (enaddr)
		memcpy(enaddr, (uint8_t *)&octeon_eth_mac_addr + 2, 6);

	octeon_eth_mac_addr++;
	octeon_eth_mac_addr_offset++;
}

/* ---- media */

int
octeon_eth_mii_readreg(struct device *self, int phy_no, int reg)
{
	struct octeon_eth_softc *sc = (struct octeon_eth_softc *)self;
	return cn30xxsmi_read(sc->sc_smi, phy_no, reg);
}

void
octeon_eth_mii_writereg(struct device *self, int phy_no, int reg, int value)
{
	struct octeon_eth_softc *sc = (struct octeon_eth_softc *)self;
	cn30xxsmi_write(sc->sc_smi, phy_no, reg, value);
}

void
octeon_eth_mii_statchg(struct device *self)
{
	struct octeon_eth_softc *sc = (struct octeon_eth_softc *)self;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	cn30xxpko_port_enable(sc->sc_pko, 0);
	cn30xxgmx_port_enable(sc->sc_gmx_port, 0);

	octeon_eth_reset(sc);

	if (ISSET(ifp->if_flags, IFF_RUNNING))
		cn30xxgmx_set_filter(sc->sc_gmx_port);

	cn30xxpko_port_enable(sc->sc_pko, 1);
	cn30xxgmx_port_enable(sc->sc_gmx_port, 1);
}

int
octeon_eth_mediainit(struct octeon_eth_softc *sc)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct mii_softc *child;

	sc->sc_mii.mii_ifp = ifp;
	sc->sc_mii.mii_readreg = octeon_eth_mii_readreg;
	sc->sc_mii.mii_writereg = octeon_eth_mii_writereg;
	sc->sc_mii.mii_statchg = octeon_eth_mii_statchg;
	ifmedia_init(&sc->sc_mii.mii_media, 0, octeon_eth_mediachange,
	    octeon_eth_mediastatus);

	mii_attach(&sc->sc_dev, &sc->sc_mii,
	    0xffffffff, sc->sc_phy_addr, MII_OFFSET_ANY, MIIF_DOPAUSE);

	child = LIST_FIRST(&sc->sc_mii.mii_phys);
	if (child == NULL) {
                /* No PHY attached. */
		ifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER | IFM_MANUAL,
			    0, NULL);
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER | IFM_MANUAL);
	} else {
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER | IFM_AUTO);
	}

	return 0;
}

void
octeon_eth_mediastatus(struct ifnet *ifp, struct ifmediareq *ifmr)
{
	struct octeon_eth_softc *sc = ifp->if_softc;

	mii_pollstat(&sc->sc_mii);
	ifmr->ifm_status = sc->sc_mii.mii_media_status;
	ifmr->ifm_active = sc->sc_mii.mii_media_active;
	ifmr->ifm_active = (sc->sc_mii.mii_media_active & ~IFM_ETH_FMASK) |
	    sc->sc_gmx_port->sc_port_flowflags;
}

int
octeon_eth_mediachange(struct ifnet *ifp)
{
	struct octeon_eth_softc *sc = ifp->if_softc;

	if ((ifp->if_flags & IFF_UP) == 0)
		return 0;

	return mii_mediachg(&sc->sc_mii);
}

/* ---- send buffer garbage collection */

void
octeon_eth_send_queue_flush_prefetch(struct octeon_eth_softc *sc)
{
	OCTEON_ETH_KASSERT(sc->sc_prefetch == 0);
	cn30xxfau_op_inc_fetch_8(&sc->sc_fau_done, 0);
	sc->sc_prefetch = 1;
}

void
octeon_eth_send_queue_flush_fetch(struct octeon_eth_softc *sc)
{
#ifndef  OCTEON_ETH_DEBUG
	if (!sc->sc_prefetch)
		return;
#endif
	OCTEON_ETH_KASSERT(sc->sc_prefetch == 1);
	sc->sc_hard_done_cnt = cn30xxfau_op_inc_read_8(&sc->sc_fau_done);
	OCTEON_ETH_KASSERT(sc->sc_hard_done_cnt <= 0);
	sc->sc_prefetch = 0;
}

void
octeon_eth_send_queue_flush(struct octeon_eth_softc *sc)
{
	const int64_t sent_count = sc->sc_hard_done_cnt;
	int i;

	OCTEON_ETH_KASSERT(sent_count <= 0);

	for (i = 0; i < 0 - sent_count; i++) {
		struct mbuf *m;
		uint64_t *gbuf;

		octeon_eth_send_queue_del(sc, &m, &gbuf);

		cn30xxfpa_buf_put_paddr(octeon_eth_fb_sg, XKPHYS_TO_PHYS(gbuf));

		m_freem(m);
	}

	cn30xxfau_op_add_8(&sc->sc_fau_done, i);
}

int
octeon_eth_send_queue_is_full(struct octeon_eth_softc *sc)
{
#ifdef OCTEON_ETH_SEND_QUEUE_CHECK
	int64_t nofree_cnt;

	nofree_cnt = ml_len(&sc->sc_sendq) + sc->sc_hard_done_cnt; 

	if (__predict_false(nofree_cnt == GATHER_QUEUE_SIZE - 1)) {
		octeon_eth_send_queue_flush(sc);
		return 1;
	}

#endif
	return 0;
}

void
octeon_eth_send_queue_add(struct octeon_eth_softc *sc, struct mbuf *m,
    uint64_t *gbuf)
{
	OCTEON_ETH_KASSERT(m->m_flags & M_PKTHDR);

	m->m_pkthdr.ph_cookie = gbuf;
	ml_enqueue(&sc->sc_sendq, m);

	if (m->m_ext.ext_free_fn != 0)
		sc->sc_ext_callback_cnt++;
}

void
octeon_eth_send_queue_del(struct octeon_eth_softc *sc, struct mbuf **rm,
    uint64_t **rgbuf)
{
	struct mbuf *m;
	m = ml_dequeue(&sc->sc_sendq);
	OCTEON_ETH_KASSERT(m != NULL);

	*rm = m;
	*rgbuf = m->m_pkthdr.ph_cookie;

	if (m->m_ext.ext_free_fn != 0) {
		sc->sc_ext_callback_cnt--;
		OCTEON_ETH_KASSERT(sc->sc_ext_callback_cnt >= 0);
	}
}

int
octeon_eth_buf_free_work(struct octeon_eth_softc *sc, uint64_t *work)
{
	paddr_t addr, pktbuf;
	uint64_t word3;
	unsigned int back, nbufs;

	nbufs = (work[2] & PIP_WQE_WORD2_IP_BUFS) >>
	    PIP_WQE_WORD2_IP_BUFS_SHIFT;
	word3 = work[3];
	while (nbufs-- > 0) {
		addr = word3 & PIP_WQE_WORD3_ADDR, CCA_CACHED;
		back = (word3 & PIP_WQE_WORD3_BACK) >>
		    PIP_WQE_WORD3_BACK_SHIFT;
		pktbuf = (addr & ~(CACHE_LINE_SIZE - 1)) -
		    back * CACHE_LINE_SIZE;

		cn30xxfpa_store(pktbuf, OCTEON_POOL_NO_PKT,
		    OCTEON_POOL_SIZE_PKT / CACHE_LINE_SIZE);

		if (nbufs > 0)
			memcpy(&word3, (void *)PHYS_TO_XKPHYS(addr -
			    sizeof(word3), CCA_CACHED), sizeof(word3));
	}

	cn30xxfpa_buf_put_paddr(octeon_eth_fb_wqe, XKPHYS_TO_PHYS(work));

	return 0;
}

/* ---- ifnet interfaces */

int
octeon_eth_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct octeon_eth_softc *sc = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *)data;
	int s, error = 0;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		if (!(ifp->if_flags & IFF_RUNNING))
			octeon_eth_init(ifp);
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				error = ENETRESET;
			else
				octeon_eth_init(ifp);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				octeon_eth_stop(ifp, 0);
		}
		break;

	case SIOCSIFMEDIA:
		/* Flow control requires full-duplex mode. */
		if (IFM_SUBTYPE(ifr->ifr_media) == IFM_AUTO ||
		    (ifr->ifr_media & IFM_FDX) == 0) {
			ifr->ifr_media &= ~IFM_ETH_FMASK;
		}
		if (IFM_SUBTYPE(ifr->ifr_media) != IFM_AUTO) {
			if ((ifr->ifr_media & IFM_ETH_FMASK) == IFM_FLOW) {
				ifr->ifr_media |=
				    IFM_ETH_TXPAUSE | IFM_ETH_RXPAUSE;
			}
			sc->sc_gmx_port->sc_port_flowflags = 
				ifr->ifr_media & IFM_ETH_FMASK;
		}
		/* FALLTHROUGH */
	case SIOCGIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_mii.mii_media, cmd);
		break;

	default:
		error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data);
	}

	if (error == ENETRESET) {
		if (ISSET(ifp->if_flags, IFF_RUNNING))
			cn30xxgmx_set_filter(sc->sc_gmx_port);
		error = 0;
	}

	splx(s);
	return (error);
}

/* ---- send (output) */

uint64_t
octeon_eth_send_makecmd_w0(uint64_t fau0, uint64_t fau1, size_t len, int segs,
    int ipoffp1)
{
	return cn30xxpko_cmd_word0(
		OCT_FAU_OP_SIZE_64,		/* sz1 */
		OCT_FAU_OP_SIZE_64,		/* sz0 */
		1, fau1, 1, fau0,		/* s1, reg1, s0, reg0 */
		0,				/* le */
		octeon_eth_param_pko_cmd_w0_n2,	/* n2 */
		1, 0,				/* q, r */
		(segs == 1) ? 0 : 1,		/* g */
		ipoffp1, 0, 1,			/* ipoffp1, ii, df */
		segs, (int)len);		/* segs, totalbytes */
}

uint64_t 
octeon_eth_send_makecmd_w1(int size, paddr_t addr)
{
	return cn30xxpko_cmd_word1(
		0, 0,				/* i, back */
		OCTEON_POOL_NO_SG,		/* pool */
		size, addr);			/* size, addr */
}

#define KVTOPHYS(addr)	if_cnmac_kvtophys((vaddr_t)(addr))
paddr_t if_cnmac_kvtophys(vaddr_t);

paddr_t
if_cnmac_kvtophys(vaddr_t kva)
{
	if (IS_XKPHYS(kva))
		return XKPHYS_TO_PHYS(kva);
	else if (kva >= CKSEG0_BASE && kva < CKSEG0_BASE + CKSEG_SIZE)
		return CKSEG0_TO_PHYS(kva);
	else if (kva >= CKSEG1_BASE && kva < CKSEG1_BASE + CKSEG_SIZE)
		return CKSEG1_TO_PHYS(kva);

	panic("%s: non-direct mapped address %p", __func__, (void *)kva);
}

int
octeon_eth_send_makecmd_gbuf(struct octeon_eth_softc *sc, struct mbuf *m0,
    uint64_t *gbuf, int *rsegs)
{
	struct mbuf *m;
	int segs = 0;

	for (m = m0; m != NULL; m = m->m_next) {
		if (__predict_false(m->m_len == 0))
			continue;

		if (segs >= OCTEON_POOL_SIZE_SG / sizeof(uint64_t))
			goto defrag;
		gbuf[segs] = octeon_eth_send_makecmd_w1(m->m_len,
		    KVTOPHYS(m->m_data));
		segs++;
	}

	*rsegs = segs;

	return 0;

defrag:
	if (m_defrag(m0, M_DONTWAIT) != 0)
		return 1;
	gbuf[0] = octeon_eth_send_makecmd_w1(m0->m_len, KVTOPHYS(m0->m_data));
	*rsegs = 1;
	return 0;
}

int
octeon_eth_send_makecmd(struct octeon_eth_softc *sc, struct mbuf *m,
    uint64_t *gbuf, uint64_t *rpko_cmd_w0, uint64_t *rpko_cmd_w1)
{
	uint64_t pko_cmd_w0, pko_cmd_w1;
	int ipoffp1;
	int segs;
	int result = 0;

	if (octeon_eth_send_makecmd_gbuf(sc, m, gbuf, &segs)) {
		log(LOG_WARNING, "%s: large number of transmission"
		    " data segments", sc->sc_dev.dv_xname);
		result = 1;
		goto done;
	}

	/* Get the IP packet offset for TCP/UDP checksum offloading. */
	ipoffp1 = (m->m_pkthdr.csum_flags & (M_TCP_CSUM_OUT | M_UDP_CSUM_OUT))
	    ? (ETHER_HDR_LEN + 1) : 0;

	/*
	 * segs == 1	-> link mode (single continuous buffer)
	 *		   WORD1[size] is number of bytes pointed by segment
	 *
	 * segs > 1	-> gather mode (scatter-gather buffer)
	 *		   WORD1[size] is number of segments
	 */
	pko_cmd_w0 = octeon_eth_send_makecmd_w0(sc->sc_fau_done.fd_regno,
	    0, m->m_pkthdr.len, segs, ipoffp1);
	pko_cmd_w1 = octeon_eth_send_makecmd_w1(
	    (segs == 1) ? m->m_pkthdr.len : segs,
	    (segs == 1) ? 
		KVTOPHYS(m->m_data) :
		XKPHYS_TO_PHYS(gbuf));

	*rpko_cmd_w0 = pko_cmd_w0;
	*rpko_cmd_w1 = pko_cmd_w1;

done:
	return result;
}

int
octeon_eth_send_cmd(struct octeon_eth_softc *sc, uint64_t pko_cmd_w0,
    uint64_t pko_cmd_w1)
{
	uint64_t *cmdptr;
	int result = 0;

	cmdptr = (uint64_t *)PHYS_TO_XKPHYS(sc->sc_cmdptr.cmdptr, CCA_CACHED);
	cmdptr += sc->sc_cmdptr.cmdptr_idx;

	OCTEON_ETH_KASSERT(cmdptr != NULL);

	*cmdptr++ = pko_cmd_w0;
	*cmdptr++ = pko_cmd_w1;

	OCTEON_ETH_KASSERT(sc->sc_cmdptr.cmdptr_idx + 2 <= FPA_COMMAND_BUFFER_POOL_NWORDS - 1);

	if (sc->sc_cmdptr.cmdptr_idx + 2 == FPA_COMMAND_BUFFER_POOL_NWORDS - 1) {
		paddr_t buf;

		buf = cn30xxfpa_buf_get_paddr(octeon_eth_fb_cmd);
		if (buf == 0) {
			log(LOG_WARNING,
			    "%s: cannot allocate command buffer from free pool allocator\n",
			    sc->sc_dev.dv_xname);
			result = 1;
			goto done;
		}
		*cmdptr++ = buf;
		sc->sc_cmdptr.cmdptr = (uint64_t)buf;
		sc->sc_cmdptr.cmdptr_idx = 0;
	} else {
		sc->sc_cmdptr.cmdptr_idx += 2;
	}

	cn30xxpko_op_doorbell_write(sc->sc_port, sc->sc_port, 2);

done:
	return result;
}

int
octeon_eth_send_buf(struct octeon_eth_softc *sc, struct mbuf *m,
    uint64_t *gbuf)
{
	int result = 0, error;
	uint64_t pko_cmd_w0, pko_cmd_w1;

	error = octeon_eth_send_makecmd(sc, m, gbuf, &pko_cmd_w0, &pko_cmd_w1);
	if (error != 0) {
		/* already logging */
		result = error;
		goto done;
	}

	error = octeon_eth_send_cmd(sc, pko_cmd_w0, pko_cmd_w1);
	if (error != 0) {
		/* already logging */
		result = error;
	}

done:
	return result;
}

int
octeon_eth_send(struct octeon_eth_softc *sc, struct mbuf *m)
{
	paddr_t gaddr = 0;
	uint64_t *gbuf = NULL;
	int result = 0, error;

	gaddr = cn30xxfpa_buf_get_paddr(octeon_eth_fb_sg);
	if (gaddr == 0) {
		log(LOG_WARNING,
		    "%s: cannot allocate gather buffer from free pool allocator\n",
		    sc->sc_dev.dv_xname);
		result = 1;
		goto done;
	}

	gbuf = (uint64_t *)(uintptr_t)PHYS_TO_XKPHYS(gaddr, CCA_CACHED);

	error = octeon_eth_send_buf(sc, m, gbuf);
	if (error != 0) {
		/* already logging */
		cn30xxfpa_buf_put_paddr(octeon_eth_fb_sg, gaddr);
		result = error;
		goto done;
	}

	octeon_eth_send_queue_add(sc, m, gbuf);

done:
	return result;
}

void
octeon_eth_start(struct ifqueue *ifq)
{
	struct ifnet *ifp = ifq->ifq_if;
	struct octeon_eth_softc *sc = ifp->if_softc;
	struct mbuf *m;

	if (__predict_false(!cn30xxgmx_link_status(sc->sc_gmx_port))) {
		ifq_purge(ifq);
		return;
	}

	/*
	 * performance tuning
	 * presend iobdma request 
	 */
	octeon_eth_send_queue_flush_prefetch(sc);

	for (;;) {
		octeon_eth_send_queue_flush_fetch(sc); /* XXX */

		/*
		 * XXXSEIL
		 * If no free send buffer is available, free all the sent buffer
		 * and bail out.
		 */
		if (octeon_eth_send_queue_is_full(sc)) {
			ifq_set_oactive(ifq);
			timeout_add(&sc->sc_tick_free_ch, 1);
			return;
		}

		m = ifq_dequeue(ifq);
		if (m == NULL)
			return;

#if NBPFILTER > 0
		if (ifp->if_bpf != NULL)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif

		/* XXX */
		if (ml_len(&sc->sc_sendq) > sc->sc_soft_req_thresh)
			octeon_eth_send_queue_flush(sc);
		if (octeon_eth_send(sc, m)) {
			ifp->if_oerrors++;
			m_freem(m);
			log(LOG_WARNING,
		  	  "%s: failed to transmit packet\n",
		    	  sc->sc_dev.dv_xname);
		}
		/* XXX */

		/*
		 * send next iobdma request 
		 */
		octeon_eth_send_queue_flush_prefetch(sc);
	}

	octeon_eth_send_queue_flush_fetch(sc);
}

void
octeon_eth_watchdog(struct ifnet *ifp)
{
	struct octeon_eth_softc *sc = ifp->if_softc;

	printf("%s: device timeout\n", sc->sc_dev.dv_xname);

	octeon_eth_stop(ifp, 0);

	octeon_eth_configure(sc);

	SET(ifp->if_flags, IFF_RUNNING);
	ifp->if_timer = 0;

	ifq_restart(&ifp->if_snd);
}

int
octeon_eth_init(struct ifnet *ifp)
{
	struct octeon_eth_softc *sc = ifp->if_softc;

	/* XXX don't disable commonly used parts!!! XXX */
	if (sc->sc_init_flag == 0) {
		/* Cancel any pending I/O. */
		octeon_eth_stop(ifp, 0);

		/* Initialize the device */
		octeon_eth_configure(sc);

		cn30xxpko_enable(sc->sc_pko);
		cn30xxipd_enable(sc->sc_ipd);

		sc->sc_init_flag = 1;
	} else {
		cn30xxgmx_port_enable(sc->sc_gmx_port, 1);
	}
	octeon_eth_mediachange(ifp);

	cn30xxgmx_set_mac_addr(sc->sc_gmx_port, sc->sc_arpcom.ac_enaddr);
	cn30xxgmx_set_filter(sc->sc_gmx_port);

	timeout_add_sec(&sc->sc_tick_misc_ch, 1);
	timeout_add_sec(&sc->sc_tick_free_ch, 1);

	SET(ifp->if_flags, IFF_RUNNING);
	ifq_clr_oactive(&ifp->if_snd);

	return 0;
}

int
octeon_eth_stop(struct ifnet *ifp, int disable)
{
	struct octeon_eth_softc *sc = ifp->if_softc;

	CLR(ifp->if_flags, IFF_RUNNING);

	timeout_del(&sc->sc_tick_misc_ch);
	timeout_del(&sc->sc_tick_free_ch);

	mii_down(&sc->sc_mii);

	cn30xxgmx_port_enable(sc->sc_gmx_port, 0);

	intr_barrier(octeon_eth_pow_recv_ih);
	ifq_barrier(&ifp->if_snd);

	ifq_clr_oactive(&ifp->if_snd);
	ifp->if_timer = 0;

	return 0;
}

/* ---- misc */

#define PKO_INDEX_MASK	((1ULL << 12/* XXX */) - 1)

int
octeon_eth_reset(struct octeon_eth_softc *sc)
{
	cn30xxgmx_reset_speed(sc->sc_gmx_port);
	cn30xxgmx_reset_flowctl(sc->sc_gmx_port);
	cn30xxgmx_reset_timing(sc->sc_gmx_port);
	cn30xxgmx_reset_board(sc->sc_gmx_port);

	return 0;
}

int
octeon_eth_configure(struct octeon_eth_softc *sc)
{
	cn30xxgmx_port_enable(sc->sc_gmx_port, 0);

	octeon_eth_reset(sc);

	octeon_eth_configure_common(sc);

	cn30xxpko_port_config(sc->sc_pko);
	cn30xxpko_port_enable(sc->sc_pko, 1);
	cn30xxpip_port_config(sc->sc_pip);

	cn30xxgmx_tx_stats_rd_clr(sc->sc_gmx_port, 1);
	cn30xxgmx_rx_stats_rd_clr(sc->sc_gmx_port, 1);

	cn30xxgmx_port_enable(sc->sc_gmx_port, 1);

	return 0;
}

int
octeon_eth_configure_common(struct octeon_eth_softc *sc)
{
	static int once;

	uint64_t reg;

	if (once == 1)
		return 0;
	once = 1;

#if 0
	octeon_eth_buf_init(sc);
#endif

	cn30xxipd_config(sc->sc_ipd);
	cn30xxpko_config(sc->sc_pko);

	cn30xxpow_config(sc->sc_pow, OCTEON_POW_GROUP_PIP);

	/* Set padding for packets that Octeon does not recognize as IP. */
	reg = octeon_xkphys_read_8(PIP_GBL_CFG);
	reg &= ~PIP_GBL_CFG_NIP_SHF_MASK;
	reg |= ETHER_ALIGN << PIP_GBL_CFG_NIP_SHF_SHIFT;
	octeon_xkphys_write_8(PIP_GBL_CFG, reg);

	return 0;
}

int
octeon_eth_mbuf_alloc(int n)
{
	struct mbuf *m;
	paddr_t pktbuf;

	while (n > 0) {
		m = MCLGETI(NULL, M_NOWAIT, NULL,
		    OCTEON_POOL_SIZE_PKT + CACHE_LINE_SIZE);
		if (m == NULL || !ISSET(m->m_flags, M_EXT)) {
			m_freem(m);
			break;
		}

		m->m_data = (void *)(((vaddr_t)m->m_data + CACHE_LINE_SIZE) &
		    ~(CACHE_LINE_SIZE - 1));
		((struct mbuf **)m->m_data)[-1] = m;

		pktbuf = KVTOPHYS(m->m_data);
		m->m_pkthdr.ph_cookie = (void *)pktbuf;
		cn30xxfpa_store(pktbuf, OCTEON_POOL_NO_PKT,
		    OCTEON_POOL_SIZE_PKT / CACHE_LINE_SIZE);

		n--;
	}
	return n;
}

int
octeon_eth_recv_mbuf(struct octeon_eth_softc *sc, uint64_t *work,
    struct mbuf **rm, int *nmbuf)
{
	struct mbuf *m, *m0, *mprev, **pm;
	paddr_t addr, pktbuf;
	uint64_t word1 = work[1];
	uint64_t word2 = work[2];
	uint64_t word3 = work[3];
	unsigned int back, i, nbufs;
	unsigned int left, total, size;

	cn30xxfpa_buf_put_paddr(octeon_eth_fb_wqe, XKPHYS_TO_PHYS(work));

	nbufs = (word2 & PIP_WQE_WORD2_IP_BUFS) >> PIP_WQE_WORD2_IP_BUFS_SHIFT;
	if (nbufs == 0)
		panic("%s: dynamic short packet", __func__);

	m0 = mprev = NULL;
	total = left = (word1 & PIP_WQE_WORD1_LEN) >> 48;
	for (i = 0; i < nbufs; i++) {
		addr = word3 & PIP_WQE_WORD3_ADDR;
		back = (word3 & PIP_WQE_WORD3_BACK) >> PIP_WQE_WORD3_BACK_SHIFT;
		pktbuf = (addr & ~(CACHE_LINE_SIZE - 1)) -
		    back * CACHE_LINE_SIZE;
		pm = (struct mbuf **)PHYS_TO_XKPHYS(pktbuf, CCA_CACHED) - 1;
		m = *pm;
		*pm = NULL;
		if ((paddr_t)m->m_pkthdr.ph_cookie != pktbuf)
			panic("%s: packet pool is corrupted, mbuf cookie %p != "
			    "pktbuf %p", __func__, m->m_pkthdr.ph_cookie,
			    (void *)pktbuf);

		/*
		 * Because of a hardware bug in some Octeon models the size
		 * field of word3 can be wrong. However, the hardware uses
		 * all space in a buffer before moving to the next one so
		 * it is possible to derive the size of this data segment
		 * from the size of packet data buffers.
		 */
		size = OCTEON_POOL_SIZE_PKT - (addr - pktbuf);
		if (size > left)
			size = left;

		m->m_pkthdr.ph_cookie = NULL;
		m->m_data += addr - pktbuf;
		m->m_len = size;
		left -= size;

		if (m0 == NULL)
			m0 = m;
		else {
			m->m_flags &= ~M_PKTHDR;
			mprev->m_next = m;
		}
		mprev = m;

		if (i + 1 < nbufs)
			memcpy(&word3, (void *)PHYS_TO_XKPHYS(addr -
			    sizeof(word3), CCA_CACHED), sizeof(word3));
	}

	m0->m_pkthdr.len = total;
	*rm = m0;
	*nmbuf = nbufs;

	return 0;
}

int
octeon_eth_recv_check(struct octeon_eth_softc *sc, uint64_t word2)
{
	static struct timeval rxerr_log_interval = { 0, 250000 };
	uint64_t opecode;

	if (__predict_true(!ISSET(word2, PIP_WQE_WORD2_NOIP_RE)))
		return 0;

	opecode = word2 & PIP_WQE_WORD2_NOIP_OPECODE;
	if ((sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG) &&
	    ratecheck(&sc->sc_rxerr_log_last, &rxerr_log_interval))
		log(LOG_DEBUG, "%s: rx error (%lld)\n", sc->sc_dev.dv_xname,
		    opecode);

	/* XXX harmless error? */
	if (opecode == PIP_WQE_WORD2_RE_OPCODE_OVRRUN)
		return 0;

	return 1;
}

int
octeon_eth_recv(struct octeon_eth_softc *sc, uint64_t *work)
{
	struct ifnet *ifp;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	struct mbuf *m;
	uint64_t word2;
	int nmbuf;

	OCTEON_ETH_KASSERT(sc != NULL);
	OCTEON_ETH_KASSERT(work != NULL);

	word2 = work[2];
	ifp = &sc->sc_arpcom.ac_if;

	OCTEON_ETH_KASSERT(ifp != NULL);

	if (!(ifp->if_flags & IFF_RUNNING))
		goto drop;

	if (__predict_false(octeon_eth_recv_check(sc, word2) != 0)) {
		ifp->if_ierrors++;
		goto drop;
	}

	if (__predict_false(octeon_eth_recv_mbuf(sc, work, &m, &nmbuf) != 0)) {
		ifp->if_ierrors++;
		goto drop;
	}

	/* work[0] .. work[3] may not be valid any more */

	OCTEON_ETH_KASSERT(m != NULL);

	cn30xxipd_offload(word2, &m->m_pkthdr.csum_flags);

	ml_enqueue(&ml, m);
	if_input(ifp, &ml);

	nmbuf = octeon_eth_mbuf_alloc(nmbuf);
	if (nmbuf != 0)
		atomic_add_int(&octeon_eth_mbufs_to_alloc, nmbuf);

	return 0;

drop:
	octeon_eth_buf_free_work(sc, work);
	return 1;
}

void
octeon_eth_recv_intr(void *data, uint64_t *work)
{
	struct octeon_eth_softc *sc;
	int port;

	OCTEON_ETH_KASSERT(work != NULL);

	port = (work[1] & PIP_WQE_WORD1_IPRT) >> 42;

	OCTEON_ETH_KASSERT(port < GMX_PORT_NUNITS);

	sc = octeon_eth_gsc[port];

	OCTEON_ETH_KASSERT(sc != NULL);
	OCTEON_ETH_KASSERT(port == sc->sc_port);

	/* XXX process all work queue entries anyway */

	(void)octeon_eth_recv(sc, work);
}

/* ---- tick */

void
octeon_eth_free_task(void *arg)
{
	struct octeon_eth_softc *sc = arg;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct ifqueue *ifq = &ifp->if_snd;
	int resched = 1;
	int timeout;

	if (ml_len(&sc->sc_sendq) > 0) {
		octeon_eth_send_queue_flush_prefetch(sc);
		octeon_eth_send_queue_flush_fetch(sc);
		octeon_eth_send_queue_flush(sc);
	}

	if (ifq_is_oactive(ifq)) {
		ifq_clr_oactive(ifq);
		octeon_eth_start(ifq);

		if (ifq_is_oactive(ifq)) {
			/* The start routine did rescheduling already. */
			resched = 0;
		}
	}

	if (resched) {
		timeout = (sc->sc_ext_callback_cnt > 0) ? 1 : hz;
		timeout_add(&sc->sc_tick_free_ch, timeout);
	}
}

/*
 * octeon_eth_tick_free
 *
 * => garbage collect send gather buffer / mbuf
 * => called at softclock
 */
void
octeon_eth_tick_free(void *arg)
{
	struct octeon_eth_softc *sc = arg;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int to_alloc;

	ifq_serialize(&ifp->if_snd, &sc->sc_free_task);

	if (octeon_eth_mbufs_to_alloc != 0) {
		to_alloc = atomic_swap_uint(&octeon_eth_mbufs_to_alloc, 0);
		to_alloc = octeon_eth_mbuf_alloc(to_alloc);
		if (to_alloc != 0)
			atomic_add_int(&octeon_eth_mbufs_to_alloc, to_alloc);
	}
}

/*
 * octeon_eth_tick_misc
 *
 * => collect statistics
 * => check link status
 * => called at softclock
 */
void
octeon_eth_tick_misc(void *arg)
{
	struct octeon_eth_softc *sc = arg;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int s;

	s = splnet();

	cn30xxgmx_stats(sc->sc_gmx_port);
	cn30xxpip_stats(sc->sc_pip, ifp, sc->sc_port);
	mii_tick(&sc->sc_mii);

	splx(s);

	timeout_add_sec(&sc->sc_tick_misc_ch, 1);
}
@


1.61
log
@Drop unnecessary #ifdef MBUF_TIMESTAMP.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.60 2016/11/05 05:09:49 visa Exp $	*/
d141 1
a141 1
void	octeon_eth_start(struct ifnet *);
d306 1
a306 1
	ifp->if_start = octeon_eth_start;
a706 2
	if_start(ifp);

d924 1
a924 1
octeon_eth_start(struct ifnet *ifp)
d926 1
d931 1
a931 1
		ifq_purge(&ifp->if_snd);
d950 1
a950 1
			ifq_set_oactive(&ifp->if_snd);
d955 1
a955 1
		m = ifq_dequeue(&ifp->if_snd);
d1322 1
d1332 3
a1334 3
	if (ifq_is_oactive(&ifp->if_snd)) {
		ifq_clr_oactive(&ifp->if_snd);
		octeon_eth_start(ifp);
d1336 1
a1336 1
		if (ifq_is_oactive(&ifp->if_snd))
d1339 1
@


1.60
log
@Do not show a device unit number in the cnmac interrupt name. The same
interrupt drives all the cnmac ports.

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.59 2016/11/02 01:29:43 visa Exp $	*/
a52 3
#ifdef MBUF_TIMESTAMP
#include <sys/time.h>
#endif
@


1.59
log
@Make possible to change the link layer address of a cnmac(4) interface.

Asked by and ok stsp@@, ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.58 2016/08/14 08:49:37 visa Exp $	*/
d332 1
a332 1
		    octeon_eth_recv_intr, NULL, NULL, sc->sc_dev.dv_xname);
@


1.58
log
@Remove some annoying debug printfs to get rid of u_quad_t in cnmac.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.57 2016/08/06 04:32:24 visa Exp $	*/
d1028 1
@


1.57
log
@Log RX errors only when the interface's debug flag is set.

While here, remove unused PIP error code aliases.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.56 2016/08/05 13:18:27 visa Exp $	*/
d1383 1
a1383 2
	struct ifnet *ifp;
	u_quad_t iqdrops, delta;
a1387 3
	ifp = &sc->sc_arpcom.ac_if;

	iqdrops = ifp->if_iqdrops;
a1388 5
#ifdef OCTEON_ETH_DEBUG
	delta = ifp->if_iqdrops - iqdrops;
	printf("%s: %qu packets dropped at GMX FIFO\n",
			ifp->if_xname, delta);
#endif
a1389 6
	delta = ifp->if_iqdrops - iqdrops;
#ifdef OCTEON_ETH_DEBUG
	printf("%s: %qu packets dropped at PIP + GMX FIFO\n",
			ifp->if_xname, delta);
#endif

@


1.56
log
@Drop a pointless link carrier check from the RX path.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.55 2016/08/04 13:10:31 visa Exp $	*/
a166 1
int	octeon_eth_recv_check_code(struct octeon_eth_softc *, uint64_t);
a324 3
	/* XXX */
	sc->sc_rate_recv_check_code_cap.tv_sec = 1;

d1225 1
a1225 1
octeon_eth_recv_check_code(struct octeon_eth_softc *sc, uint64_t word2)
d1227 2
a1228 1
	uint64_t opecode = word2 & PIP_WQE_WORD2_NOIP_OPECODE;
d1233 8
a1240 2
	/* this error is harmless */
	if (opecode == PIP_OVER_ERR)
a1243 25
}

int
octeon_eth_recv_check(struct octeon_eth_softc *sc, uint64_t word2)
{
	if (__predict_false(octeon_eth_recv_check_code(sc, word2)) != 0) {
		if ((word2 & PIP_WQE_WORD2_NOIP_OPECODE) == PIP_WQE_WORD2_RE_OPCODE_LENGTH) {
			/* no logging */
			/* XXX inclement special error count */
		} else if ((word2 & PIP_WQE_WORD2_NOIP_OPECODE) == 
				PIP_WQE_WORD2_RE_OPCODE_PARTIAL) {
			/* not an error. it's because of overload */
		}
		else {
			if (ratecheck(&sc->sc_rate_recv_check_code_last,
			    &sc->sc_rate_recv_check_code_cap)) 
				log(LOG_WARNING,
				    "%s: a reception error occured, "
				    "the packet was dropped (error code = %lld)\n",
				    sc->sc_dev.dv_xname, word2 & PIP_WQE_WORD2_NOIP_OPECODE);
		}
		return 1;
	}

	return 0;
@


1.55
log
@Add support for jumbo frames.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.54 2016/07/30 09:45:09 visa Exp $	*/
a167 1
int	octeon_eth_recv_check_link(struct octeon_eth_softc *, uint64_t);
a326 1
	sc->sc_rate_recv_check_link_cap.tv_sec = 1;
a1243 8
octeon_eth_recv_check_link(struct octeon_eth_softc *sc, uint64_t word2)
{
	if (__predict_false(!cn30xxgmx_link_status(sc->sc_gmx_port)))
		return 1;
	return 0;
}

int
a1245 9
	if (__predict_false(octeon_eth_recv_check_link(sc, word2)) != 0) {
		if (ratecheck(&sc->sc_rate_recv_check_link_last,
		    &sc->sc_rate_recv_check_link_cap))
			log(LOG_DEBUG,
			    "%s: link is not up, the packet was dropped\n",
			    sc->sc_dev.dv_xname);
		return 1;
	}

@


1.54
log
@Remove disabled jumbo frame checks. They will not be needed
for jumbo frame support.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.53 2016/07/30 09:29:14 visa Exp $	*/
d313 1
d631 2
a632 1
	unsigned int back;
d634 6
a639 3
	if (ISSET(work[2], PIP_WQE_WORD2_IP_BUFS)) {
		addr = work[3] & PIP_WQE_WORD3_ADDR, CCA_CACHED;
		back = (work[3] & PIP_WQE_WORD3_BACK) >>
d646 4
d1165 1
a1165 1
	struct mbuf *m, **pm;
d1170 2
a1171 1
	unsigned int back;
d1175 47
a1221 18
	if ((word2 >> PIP_WQE_WORD2_IP_BUFS_SHIFT) != 1)
		panic("%s: expected one buffer, got %llu", __func__,
		    word2 >> PIP_WQE_WORD2_IP_BUFS_SHIFT);

	addr = word3 & PIP_WQE_WORD3_ADDR;
	back = (word3 & PIP_WQE_WORD3_BACK) >> PIP_WQE_WORD3_BACK_SHIFT;
	pktbuf = (addr & ~(CACHE_LINE_SIZE - 1)) - back * CACHE_LINE_SIZE;
	pm = (struct mbuf **)PHYS_TO_XKPHYS(pktbuf, CCA_CACHED) - 1;
	m = *pm;
	*pm = NULL;
	if ((paddr_t)m->m_pkthdr.ph_cookie != pktbuf)
		panic("%s: packet pool is corrupted, mbuf cookie %p != "
		    "pktbuf %p", __func__, m->m_pkthdr.ph_cookie,
		    (void *)pktbuf);

	m->m_pkthdr.ph_cookie = NULL;
	m->m_data += addr - pktbuf;
	m->m_len = m->m_pkthdr.len = (word1 & PIP_WQE_WORD1_LEN) >> 48;
d1223 3
a1225 2
	*rm = m;
	*nmbuf = 1;
@


1.53
log
@Drop a redundant parameter of octeon_eth_buf_free_work().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.52 2016/06/22 13:09:35 visa Exp $	*/
a167 3
#if 0 /* not used */
int      octeon_eth_recv_check_jumbo(struct octeon_eth_softc *, uint64_t);
#endif
a327 1
	sc->sc_rate_recv_check_jumbo_cap.tv_sec = 1;
a1204 10
#if 0 /* not used */
int
octeon_eth_recv_check_jumbo(struct octeon_eth_softc *sc, uint64_t word2)
{
	if (__predict_false((word2 & PIP_WQE_WORD2_IP_BUFS) > (1ULL << 56)))
		return 1;
	return 0;
}
#endif

a1223 11

#if 0 /* XXX Performance tuning (Jumbo-frame is not supported yet!) */
	if (__predict_false(octeon_eth_recv_check_jumbo(sc, word2)) != 0) {
		/* XXX jumbo frame */
		if (ratecheck(&sc->sc_rate_recv_check_jumbo_last,
		    &sc->sc_rate_recv_check_jumbo_cap))
			log(LOG_DEBUG,
			    "jumbo frame was received\n");
		return 1;
	}
#endif
@


1.52
log
@Add support for the second GMX interface on Octeon II. This enables
ports eth[0-3] on 8-port EdgeRouters. Currently, port eth0 maps to
network interface cnmac4, eth1 to cnmac5 etc.

ok dlg@@, tested by martijn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.51 2016/05/30 15:41:28 visa Exp $	*/
d137 1
a137 2
int	octeon_eth_buf_free_work(struct octeon_eth_softc *,
	    uint64_t *, uint64_t);
d631 1
a631 2
octeon_eth_buf_free_work(struct octeon_eth_softc *sc, uint64_t *work,
    uint64_t word2)
d636 1
a636 1
	if (ISSET(word2, PIP_WQE_WORD2_IP_BUFS)) {
d1318 1
a1318 1
	octeon_eth_buf_free_work(sc, work, word2);
@


1.51
log
@Fill the packet data pool with standard mbuf clusters instead of
driver-specific memory blocks. This lets the cnmac(4) RX path run
without an mbuf ext_free callback.

ok uebayasi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.50 2016/05/29 11:10:25 visa Exp $	*/
d292 2
a293 2
	    OCTEON_CVMSEG_ETHER_OFFSET(sc->sc_port, csm_ether_fau_done),
	    OCT_FAU_REG_ADDR_END - (8 * (sc->sc_port + 1))/* XXX */);
@


1.50
log
@Map ASX registers only if link control needs them.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.49 2016/05/24 14:06:39 visa Exp $	*/
d52 1
d167 1
a167 1
	    uint64_t *, struct mbuf **);
d177 2
a198 1
	_ENTRY(PKT),
a204 1
#define	octeon_eth_fb_pkt	octeon_eth_pools[OCTEON_POOL_NO_PKT]
d212 1
a212 1
static u_int octeon_ext_free_idx;
d229 1
a229 1
		octeon_eth_pools[i] = fb;
d255 4
a258 3
	if (octeon_ext_free_idx == 0)
		octeon_ext_free_idx =
		    mextfree_register(octeon_eth_buf_ext_free);
d369 1
a369 1
	ipd_aa.aa_first_mbuff_skip = 184/* XXX */;
d635 3
a637 1
	/* XXX when jumbo frame */
d639 5
a643 5
		paddr_t addr;
		paddr_t start_buffer;

		addr = XKPHYS_TO_PHYS(work[3] & PIP_WQE_WORD3_ADDR);
		start_buffer = addr & ~(2048 - 1);
d645 2
a646 1
		cn30xxfpa_buf_put_paddr(octeon_eth_fb_pkt, start_buffer);
a653 6
void
octeon_eth_buf_ext_free(caddr_t buf, u_int size, void *arg)
{
	cn30xxfpa_buf_put_paddr(octeon_eth_fb_pkt, XKPHYS_TO_PHYS(buf));
}

d1131 28
d1160 1
a1160 1
    struct mbuf **rm)
d1162 2
a1163 4
	struct mbuf *m;
	vaddr_t addr;
	vaddr_t ext_buf;
	size_t ext_size;
d1167 1
a1167 4

	MGETHDR(m, M_NOWAIT, MT_DATA);
	if (m == NULL)
		return 1;
d1175 10
a1184 5
	addr = PHYS_TO_XKPHYS(word3 & PIP_WQE_WORD3_ADDR, CCA_CACHED);

	ext_size = OCTEON_POOL_SIZE_PKT;
	ext_buf = addr & ~(ext_size - 1);
	MEXTADD(m, ext_buf, ext_size, 0, octeon_ext_free_idx, NULL);
d1186 2
a1187 1
	m->m_data = (void *)addr;
d1191 1
d1281 1
d1299 1
a1299 1
	if (__predict_false(octeon_eth_recv_mbuf(sc, work, &m) != 0)) {
d1313 4
d1388 1
d1391 7
@


1.49
log
@Drop a redundant set of FPA pool definitions.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.48 2016/05/24 12:56:14 visa Exp $	*/
a72 1
#include <octeon/dev/cn30xxasxreg.h>
a88 1
#include <octeon/dev/cn30xxasxvar.h>
a115 1
void	octeon_eth_asx_init(struct octeon_eth_softc *);
a296 1
	octeon_eth_asx_init(sc);
a299 1
	sc->sc_gmx_port->sc_port_asx = sc->sc_asx;
a383 11
}

/* XXX */
void
octeon_eth_asx_init(struct octeon_eth_softc *sc)
{
	struct cn30xxasx_attach_args asx_aa;

	asx_aa.aa_port = sc->sc_port;
	asx_aa.aa_regt = sc->sc_regt;
	cn30xxasx_init(&asx_aa, &sc->sc_asx);
@


1.48
log
@Try to defragment overly long mbuf chains.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.47 2016/05/24 12:50:14 visa Exp $	*/
d759 1
a759 1
		FPA_GATHER_BUFFER_POOL,		/* pool */
@


1.47
log
@Fix previous.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.46 2016/05/23 15:22:45 tedu Exp $	*/
d791 1
a791 1
			return 1;
d799 7
@


1.46
log
@remove the function pointer from mbufs. this memory is shared with data
via unions, and we don't want to make it easy to control the target.
instead an integer index into an array of acceptable functions is used.
drivers using custom functions must register them to receive an index.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.45 2016/05/21 11:04:38 visa Exp $	*/
d141 1
@


1.45
log
@Make the TX path of cnmac(4) MP-safe and add some ifq oactive logic.

Feedback from dlg@@, ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.44 2016/05/21 10:45:22 visa Exp $	*/
a140 2
void	octeon_eth_buf_ext_free_m(caddr_t, u_int, void *);
void	octeon_eth_buf_ext_free_ext(caddr_t, u_int, void *);
d213 2
d256 4
d623 1
a623 1
	if (m->m_ext.ext_free != NULL)
d638 1
a638 1
	if (m->m_ext.ext_free != NULL) {
d1165 1
a1165 1
	MEXTADD(m, ext_buf, ext_size, 0, octeon_eth_buf_ext_free, NULL);
@


1.44
log
@panic() if an incoming packet does not consist of one buffer. This
makes the number of buffers visible.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.43 2016/05/19 16:17:07 visa Exp $	*/
d165 1
d283 1
d311 1
d725 1
a725 1
	octeon_eth_start(ifp);
d942 5
a952 6
	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		goto last;

	if (__predict_false(!cn30xxgmx_link_status(sc->sc_gmx_port)))
		goto last;

d962 2
a965 1
		/* XXX */
d967 1
a967 1
		IFQ_DEQUEUE(&ifp->if_snd, m);
a993 1
last:
d1004 2
a1008 1
	ifq_clr_oactive(&ifp->if_snd);
d1011 1
a1011 1
	octeon_eth_start(ifp);
d1052 2
d1061 3
a1063 2
	/* Mark the interface as down and cancel the watchdog timer. */
	CLR(ifp->if_flags, IFF_RUNNING);
a1066 2
	intr_barrier(octeon_eth_pow_recv_ih);

d1318 29
d1357 1
a1357 2
	int timo;
	int s;
d1359 1
a1359 16
	s = splnet();
	/* XXX */
	if (ml_len(&sc->sc_sendq) > 0) {
		octeon_eth_send_queue_flush_prefetch(sc);
		octeon_eth_send_queue_flush_fetch(sc);
		octeon_eth_send_queue_flush(sc);
	}
	/* XXX */

	/* XXX ??? */
	timo = hz - (100 * sc->sc_ext_callback_cnt);
	if (timo < 10)
		 timo = 10;
	timeout_add_msec(&sc->sc_tick_free_ch, 1000 * timo / hz);
	/* XXX */
	splx(s);
@


1.43
log
@Fix the previous commit which made work queue entries get released too
early. octeon_eth_recv() will release them in case of packet drop.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.42 2016/05/19 15:42:03 visa Exp $	*/
d1149 3
a1151 1
	KASSERT((word2 >> PIP_WQE_WORD2_IP_BUFS_SHIFT) == 1);
@


1.42
log
@Disable dynamic short buffering to make all RX data land on buffers
taken from the packet data pool.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.41 2016/04/27 15:44:27 visa Exp $	*/
a1142 2
	cn30xxfpa_buf_put_paddr(octeon_eth_fb_wqe, XKPHYS_TO_PHYS(work));

d1146 2
@


1.41
log
@Expand and remove macro OCTEON_ETH_TAP.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.40 2016/04/26 11:22:05 visa Exp $	*/
d658 1
a658 1
octeon_eth_buf_ext_free_m(caddr_t buf, u_int size, void *arg)
a659 12
	uint64_t *work = (void *)arg;

	cn30xxfpa_buf_put_paddr(octeon_eth_fb_wqe, XKPHYS_TO_PHYS(work));
}

void
octeon_eth_buf_ext_free_ext(caddr_t buf, u_int size,
    void *arg)
{
	uint64_t *work = (void *)arg;

	cn30xxfpa_buf_put_paddr(octeon_eth_fb_wqe, XKPHYS_TO_PHYS(work));
d1136 2
a1137 2
	void (*ext_free)(caddr_t, u_int, void *);
	void *ext_buf;
a1138 1
	caddr_t data;
d1143 2
a1147 7
	OCTEON_ETH_KASSERT(m != NULL);

	if ((word2 & PIP_WQE_WORD2_IP_BUFS) == 0) {
		/* Dynamic short */
		ext_free = octeon_eth_buf_ext_free_m;
		ext_buf = &work[4];
		ext_size = 96;
d1149 1
a1149 18
		/*
		 * If the packet is IP, the hardware has padded it so that the
		 * IP source address starts on the next 64-bit word boundary.
		 */
		data = (caddr_t)&work[4] + ETHER_ALIGN;
		if (!ISSET(word2, PIP_WQE_WORD2_IP_NI) &&
		    !ISSET(word2, PIP_WQE_WORD2_IP_V6))
			data += 4;
	} else {
		vaddr_t addr;
		vaddr_t start_buffer;

		addr = PHYS_TO_XKPHYS(word3 & PIP_WQE_WORD3_ADDR, CCA_CACHED);
		start_buffer = addr & ~(2048 - 1);

		ext_free = octeon_eth_buf_ext_free_ext;
		ext_buf = (void *)start_buffer;
		ext_size = 2048;
d1151 1
a1151 2
		data = (void *)addr;
	}
d1153 3
a1155 2
	MEXTADD(m, ext_buf, ext_size, 0, ext_free, work);
	OCTEON_ETH_KASSERT(ISSET(m->m_flags, M_EXT));
d1157 1
a1157 1
	m->m_data = data;
a1158 6
#if 0
	/*
	 * not readonly buffer
	 */
	m->m_flags |= M_EXT_RW;
#endif
a1160 2

	OCTEON_ETH_KASSERT(*rm != NULL);
@


1.40
log
@sc_resume_ch is used nowhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.39 2016/04/26 11:07:09 visa Exp $	*/
a110 11
#if NBPFILTER > 0
#define	OCTEON_ETH_TAP(ifp, m, dir) \
	do { \
		/* Pass this up to any BPF listeners. */ \
		if ((ifp)->if_bpf) \
			bpf_mtap((ifp)->if_bpf, (m), (dir)); \
	} while (0/* CONSTCOND */)
#else
#define	OCTEON_ETH_TAP(ifp, m, dir)
#endif /* NBPFILTER > 0 */

d980 4
a983 1
		OCTEON_ETH_TAP(ifp, m, BPF_DIRECTION_OUT);
@


1.39
log
@Drop an unused workaround which does not even compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.38 2016/04/13 11:34:00 mpi Exp $	*/
a1070 1
	timeout_del(&sc->sc_resume_ch);
@


1.38
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.37 2015/12/18 13:36:12 visa Exp $	*/
a1429 18
#ifdef OCTEON_ETH_FIXUP_ODD_NIBBLE_DYNAMIC
	if (sc->sc_gmx_port->sc_proc_nibble_by_soft &&
	    sc->sc_gmx_port->sc_even_nibble_cnt > PROC_NIBBLE_SOFT_THRESHOLD) {
#ifdef OCTEON_ETH_DEBUG
		log(LOG_DEBUG, "%s: even nibble preamble count %d\n",
		    sc->sc_dev.dv_xname, sc->sc_gmx_port->sc_even_nibble_cnt);
#endif
		if (OCTEON_ETH_FIXUP_ODD_NIBBLE_MODEL_P(sc) &&
		    OCTEON_ETH_FIXUP_ODD_NIBBLE_DYNAMIC_SPEED_P(sc->sc_gmx_port, ifp)) {
			log(LOG_NOTICE, 
			    "%s: the preamble processing switched to hardware\n", 
			    sc->sc_dev.dv_xname);
		}
		sc->sc_gmx_port->sc_proc_nibble_by_soft = 0;
		octeon_eth_mii_statchg((struct device *)sc);
		sc->sc_gmx_port->sc_even_nibble_cnt = 0;
	}
#endif
@


1.37
log
@A store to FPA does not need splnet(). The operation is atomic.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.36 2015/11/25 14:00:27 visa Exp $	*/
a323 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.36
log
@Simplify the setup of gather segments.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.35 2015/11/25 03:09:58 dlg Exp $	*/
a672 1
	int s = splnet();
a674 2

	splx(s);
a681 1
	int s = splnet();
a684 2

	splx(s);
@


1.35
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.34 2015/11/24 17:11:38 mpi Exp $	*/
a784 2
/* TODO: use bus_dma(9) */

d798 1
a798 2
	printf("kva %lx is not able to convert physical address\n", kva);
	panic("if_cnmac_kvtophys");
a806 1
	uint32_t laddr, rlen, nlen;
a808 1

d812 4
a815 28
#if 0	
		OCTEON_ETH_KASSERT(((uint32_t)m->m_data & (PAGE_SIZE - 1))
		   == (kvtophys((vaddr_t)m->m_data) & (PAGE_SIZE - 1)));
#endif

		/*
		 * aligned 4k
		 */
		laddr = (uintptr_t)m->m_data & (PAGE_SIZE - 1);

		if (laddr + m->m_len > PAGE_SIZE) {
			/* XXX */
			rlen = PAGE_SIZE - laddr;
			nlen = m->m_len - rlen;
			*(gbuf + segs) = octeon_eth_send_makecmd_w1(rlen,
			    KVTOPHYS(m->m_data));
			segs++;
			if (segs > 63) {
				return 1;
			}
			/* XXX */
		} else {
			rlen = 0;
			nlen = m->m_len;
		}

		*(gbuf + segs) = octeon_eth_send_makecmd_w1(nlen,
		    KVTOPHYS((caddr_t)m->m_data + rlen));
a816 3
		if (segs > 63) {
			return 1;
		}
a817 2

	OCTEON_ETH_KASSERT(m == NULL);
@


1.34
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.33 2015/11/21 05:11:32 visa Exp $	*/
d1009 1
a1009 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
d1066 1
a1066 1
	CLR(ifp->if_flags, IFF_OACTIVE);
d1100 1
a1100 1
	CLR(ifp->if_flags, IFF_OACTIVE);
d1119 2
a1120 1
	CLR(ifp->if_flags, IFF_RUNNING | IFF_OACTIVE);
@


1.33
log
@Drop sysctl leftovers.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.32 2015/11/20 15:16:06 visa Exp $	*/
a56 1
#include <net/if_dl.h>
@


1.32
log
@Make cnmac compile again after IF_DROP() removal. Just bail out if the
link is down.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.31 2015/11/18 16:05:22 visa Exp $	*/
a49 1
#include <sys/sysctl.h>
d195 1
a195 1
/* sysctl'able parameters */
a196 5
int	octeon_eth_param_pip_dyn_rs = 1;
int	octeon_eth_param_redir = 0;
int	octeon_eth_param_pktbuf = 0;
int	octeon_eth_param_rate = 0;
int	octeon_eth_param_intr = 0;
@


1.31
log
@Take account of padding with dynamic short packets. This fixes the
reception of short non-IP packets which I broke in revision 1.28.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.30 2015/11/13 14:43:33 visa Exp $	*/
d1019 1
a1019 16
	/* XXX assume that OCTEON doesn't buffer packets */
	if (__predict_false(!cn30xxgmx_link_status(sc->sc_gmx_port))) {
		/* dequeue and drop them */
		while (1) {
			IFQ_DEQUEUE(&ifp->if_snd, m);
			if (m == NULL)
				break;
#if 0
#ifdef DDB
			m_print(m, "cd", printf);
#endif
			printf("%s: drop\n", sc->sc_dev.dv_xname);
#endif
			m_freem(m);
			IF_DROP(&ifp->if_snd);
		}
a1020 1
	}
@


1.30
log
@Remove an unnecessary IFQ_POLL(), along with an unused #ifdef block.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.29 2015/10/28 14:04:17 visa Exp $	*/
d1223 1
a1223 1
	void *data;
d1239 8
a1246 1
		data = &work[4 + sc->sc_ip_offset / sizeof(uint64_t)];
@


1.29
log
@Enable TCP/UDP checksum offloading on packet transmission.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.28 2015/10/28 14:00:34 visa Exp $	*/
a1038 4
		IFQ_POLL(&ifp->if_snd, m);
		if (__predict_false(m == NULL))
			break;

d1052 2
a1073 18

/*
 * XXXSEIL
 * Don't schedule send-buffer-free callout every time - those buffers are freed
 * by "free tick".  This makes some packets like NFS slower, but it normally
 * doesn't happen on SEIL.
 */
#ifdef OCTEON_ETH_USENFS
	if (__predict_false(sc->sc_ext_callback_cnt > 0)) {
		int timo;

		/* ??? */
		timo = hz - (100 * sc->sc_ext_callback_cnt);
		if (timo < 10)
			timo = 10;
		callout_schedule(&sc->sc_tick_free_ch, timo);
	}
#endif
@


1.28
log
@Add proper padding to packets that the hardware does not recognize as
IP, to avoid memory alignment issues in the IP stack.

ok miod@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.27 2015/10/25 13:22:09 mpi Exp $	*/
d165 1
a165 1
uint64_t octeon_eth_send_makecmd_w0(uint64_t, uint64_t, size_t, int);
d333 2
a334 1
	ifp->if_capabilities = IFCAP_VLAN_MTU;
d768 2
a769 1
octeon_eth_send_makecmd_w0(uint64_t fau0, uint64_t fau1, size_t len, int segs)
d779 1
a779 1
		0, 0, 1,			/* ipoffp1, ii, df */
d870 1
d881 4
d893 1
a893 1
	    0, m->m_pkthdr.len, segs);
@


1.27
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.26 2015/10/24 05:35:42 visa Exp $	*/
d1204 2
d1218 6
@


1.26
log
@Make use of hardware RX checksum validation.

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.25 2015/10/15 14:06:04 visa Exp $	*/
a704 1
	struct ifaddr *ifa = (struct ifaddr *)data;
a714 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->sc_arpcom, ifa);
@


1.25
log
@Let the rx path of cnmac run without the kernel lock. To avoid the need
of a mutex, the path no longer cleans up the queue of tx requests.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.24 2015/10/08 14:24:32 visa Exp $	*/
d1392 1
a1392 1
	cn30xxipd_offload(word2, m->m_data, &m->m_pkthdr.csum_flags);
@


1.24
log
@Remove the sc_soft_req_cnt field because the number of tx requests is
already tracked in sc_sendq. Replace the sc_flush logic with a simple
Fetch-and-Add store that avoids an unnecessary IOBDMA transaction.

ok uebayasi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.23 2015/06/11 12:30:42 jmatthew Exp $	*/
d353 3
a355 2
		octeon_eth_pow_recv_ih = cn30xxpow_intr_establish(OCTEON_POW_GROUP_PIP,
		    IPL_NET, octeon_eth_recv_intr, NULL, NULL, sc->sc_dev.dv_xname);
d1161 2
a1361 1
	int result = 0;
a1366 10
	/* XXX */
	/*
 	 * performance tuning
	 * presend iobdma request
	 */
	if (ml_len(&sc->sc_sendq) > sc->sc_soft_req_thresh) {
		octeon_eth_send_queue_flush_prefetch(sc);
	}
	/* XXX */

d1375 3
a1379 2
		result = 1;
		octeon_eth_buf_free_work(sc, work, word2);
a1384 2
		result = 1;
		octeon_eth_buf_free_work(sc, work, word2);
a1393 6
	/* XXX */
	if (ml_len(&sc->sc_sendq) > sc->sc_soft_req_thresh) {
		octeon_eth_send_queue_flush_fetch(sc);
		octeon_eth_send_queue_flush(sc);
	}

d1400 2
a1401 7
	/* XXX */
	if (ml_len(&sc->sc_sendq) > sc->sc_soft_req_thresh) {
		octeon_eth_send_queue_flush_fetch(sc);
	}
	/* XXX */

	return result;
@


1.23
log
@convert sc_sendq into an mbuf_list, and use ph_cookie rather than rcvif to
store the sgl address, allowing rcvif to be removed.

ok mpi@@ dlg@@ uebayasi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.22 2015/04/30 21:52:49 mpi Exp $	*/
a146 1
void	octeon_eth_send_queue_flush_sync(struct octeon_eth_softc *);
a590 1
	OCTEON_ETH_KASSERT(sc->sc_flush == 0);
d604 1
a604 19
	cn30xxfau_op_inc_fetch_8(&sc->sc_fau_done, i);
	sc->sc_flush = i;
}

void
octeon_eth_send_queue_flush_sync(struct octeon_eth_softc *sc)
{
	if (sc->sc_flush == 0)
		return;

	OCTEON_ETH_KASSERT(sc->sc_flush > 0);

	/* XXX */
	cn30xxfau_op_inc_read_8(&sc->sc_fau_done);
	sc->sc_soft_req_cnt -= sc->sc_flush;
	OCTEON_ETH_KASSERT(sc->sc_soft_req_cnt >= 0);
	/* XXX */

	sc->sc_flush = 0;
d613 1
a613 1
	nofree_cnt = sc->sc_soft_req_cnt + sc->sc_hard_done_cnt; 
a616 1
		octeon_eth_send_queue_flush_sync(sc);
d1055 1
a1055 1
		if (sc->sc_soft_req_cnt > sc->sc_soft_req_thresh)
a1062 2
		} else {
			sc->sc_soft_req_cnt++;
a1063 2
		if (sc->sc_flush)
			octeon_eth_send_queue_flush_sync(sc);
d1370 1
a1370 1
	if (sc->sc_soft_req_cnt > sc->sc_soft_req_thresh) {
d1404 1
a1404 1
	if (sc->sc_soft_req_cnt > sc->sc_soft_req_thresh) {
a1408 4
	/* XXX */
	if (sc->sc_flush)
		octeon_eth_send_queue_flush_sync(sc);

d1416 1
a1416 1
	if (sc->sc_soft_req_cnt > sc->sc_soft_req_thresh) {
d1463 1
a1463 1
	if (sc->sc_soft_req_cnt > 0) {
a1466 1
		octeon_eth_send_queue_flush_sync(sc);
@


1.22
log
@Convert to if_input().

Tested by jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.21 2014/12/22 02:26:53 tedu Exp $	*/
d295 1
a295 1
	SIMPLEQ_INIT(&sc->sc_sendq);
a644 21
/*
 * (Ab)use m_nextpkt and m_paddr to maintain mbuf chain and pointer to gather
 * buffer.  Other mbuf members may be used by m_freem(), so don't touch them!
 */

struct _send_queue_entry {
	union {
		struct mbuf _sqe_s_mbuf;
		struct {
			char _sqe_s_entry_pad[offsetof(struct mbuf, m_nextpkt)];
			SIMPLEQ_ENTRY(_send_queue_entry) _sqe_s_entry_entry;
		} _sqe_s_entry;
		struct {
			char _sqe_s_gbuf_pad[offsetof(struct mbuf, M_dat.MH.MH_pkthdr.rcvif)];
			uint64_t *_sqe_s_gbuf_gbuf;
		} _sqe_s_gbuf;
	} _sqe_u;
#define	_sqe_entry	_sqe_u._sqe_s_entry._sqe_s_entry_entry
#define	_sqe_gbuf	_sqe_u._sqe_s_gbuf._sqe_s_gbuf_gbuf
};

a648 2
	struct _send_queue_entry *sqe = (struct _send_queue_entry *)m;

d651 2
a652 2
	sqe->_sqe_gbuf = gbuf;
	SIMPLEQ_INSERT_TAIL(&sc->sc_sendq, sqe, _sqe_entry);
d662 3
a664 5
	struct _send_queue_entry *sqe;

	sqe = SIMPLEQ_FIRST(&sc->sc_sendq);
	OCTEON_ETH_KASSERT(sqe != NULL);
	SIMPLEQ_REMOVE_HEAD(&sc->sc_sendq, _sqe_entry);
d666 2
a667 2
	*rm = (void *)sqe;
	*rgbuf = sqe->_sqe_gbuf;
d669 1
a669 1
	if ((*rm)->m_ext.ext_free != NULL) {
@


1.21
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.20 2014/12/19 22:44:58 guenther Exp $	*/
a1313 1
	m->m_pkthdr.rcvif = &sc->sc_arpcom.ac_if;
d1411 1
a1457 3
	/* XXX */

	OCTEON_ETH_TAP(ifp, m, BPF_DIRECTION_IN);
a1461 1
	/* XXX */
d1463 2
a1464 1
	ether_input_mbuf(ifp, m);
@


1.20
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.19 2014/08/11 19:00:50 miod Exp $	*/
a760 1
#ifdef INET
a762 1
#endif
@


1.19
log
@Do not extern octeon_boot_info, <machine/octeonvar.h> declares it for you.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.18 2014/08/11 18:56:49 miod Exp $	*/
d52 1
a68 1
#include <machine/endian.h>
@


1.18
log
@Do not use CKSEG0 to quickly map physical addresses, but XKPHYS, for we are
not limited to 512MB physmem.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.17 2014/08/11 18:29:56 miod Exp $	*/
a427 1
	extern struct boot_info *octeon_boot_info;
d433 1
a433 1
		       octeon_boot_info->mac_addr_base, 6);
@


1.17
log
@Remove evcnt and %b format strings relying upon SEIL extensions. This gives
OCTEON_ETH_DEBUG kernels a chance to build. No functional change for regular
kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.16 2014/08/11 18:08:17 miod Exp $	*/
d602 1
a602 1
		cn30xxfpa_buf_put_paddr(octeon_eth_fb_sg, CKSEG0_TO_PHYS(gbuf));
d710 1
a710 1
		addr = CKSEG0_TO_PHYS(work[3] & PIP_WQE_WORD3_ADDR);
d716 1
a716 1
	cn30xxfpa_buf_put_paddr(octeon_eth_fb_wqe, CKSEG0_TO_PHYS(work));
d727 1
a727 1
	cn30xxfpa_buf_put_paddr(octeon_eth_fb_wqe, CKSEG0_TO_PHYS(work));
d739 2
a740 2
	cn30xxfpa_buf_put_paddr(octeon_eth_fb_wqe, CKSEG0_TO_PHYS(work));
	cn30xxfpa_buf_put_paddr(octeon_eth_fb_pkt, CKSEG0_TO_PHYS(buf));
d942 1
a942 1
		CKSEG0_TO_PHYS(gbuf));
d958 1
a958 1
	cmdptr = (uint64_t *)PHYS_TO_CKSEG0(sc->sc_cmdptr.cmdptr);
a1030 1
	gbuf = (uint64_t *)(uintptr_t)PHYS_TO_CKSEG0(gaddr);
d1032 1
d1302 1
a1302 1
		addr = PHYS_TO_CKSEG0(word3 & PIP_WQE_WORD3_ADDR);
@


1.16
log
@De-static so that my ddb backtrace get closer to reality.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.15 2014/07/22 10:35:35 mpi Exp $	*/
d198 6
a203 6
int		octeon_eth_param_pko_cmd_w0_n2 = 1;
int		octeon_eth_param_pip_dyn_rs = 1;
int		octeon_eth_param_redir = 0;
int		octeon_eth_param_pktbuf = 0;
int		octeon_eth_param_rate = 0;
int		octeon_eth_param_intr = 0;
d205 2
a206 2
struct cfattach cnmac_ca = {sizeof(struct octeon_eth_softc),
    octeon_eth_match, octeon_eth_attach, NULL, NULL};
d208 1
a208 41
struct cfdriver cnmac_cd = {NULL, "cnmac", DV_IFNET};

#ifdef OCTEON_ETH_DEBUG

static const struct octeon_evcnt_entry octeon_evcnt_entries[] = {
#define	_ENTRY(name, type, parent, descr) \
	OCTEON_EVCNT_ENTRY(struct octeon_eth_softc, name, type, parent, descr)
	_ENTRY(rx,			MISC, NULL, "rx"),
	_ENTRY(rxint,			INTR, NULL, "rx intr"),
	_ENTRY(rxrs,			MISC, NULL, "rx dynamic short"),
	_ENTRY(rxbufpkalloc,		MISC, NULL, "rx buf pkt alloc"),
	_ENTRY(rxbufpkput,		MISC, NULL, "rx buf pkt put"),
	_ENTRY(rxbufwqalloc,		MISC, NULL, "rx buf wqe alloc"),
	_ENTRY(rxbufwqput,		MISC, NULL, "rx buf wqe put"),
	_ENTRY(rxerrcode,		MISC, NULL, "rx code error"),
	_ENTRY(rxerrfix,		MISC, NULL, "rx fixup error"),
	_ENTRY(rxerrjmb,		MISC, NULL, "rx jmb error"),
	_ENTRY(rxerrlink,		MISC, NULL, "rx link error"),
	_ENTRY(rxerroff,		MISC, NULL, "rx offload error"),
	_ENTRY(rxonperrshort,		MISC, NULL, "rx onp fixup short error"),
	_ENTRY(rxonperrpreamble,	MISC, NULL, "rx onp fixup preamble error"),
	_ENTRY(rxonperrcrc,		MISC, NULL, "rx onp fixup crc error"),
	_ENTRY(rxonperraddress,		MISC, NULL, "rx onp fixup address error"),
	_ENTRY(rxonponp,		MISC, NULL, "rx onp fixup onp packets"),
	_ENTRY(rxonpok,			MISC, NULL, "rx onp fixup success packets"),
	_ENTRY(tx,			MISC, NULL, "tx"),
	_ENTRY(txadd,			MISC, NULL, "tx add"),
	_ENTRY(txbufcballoc,		MISC, NULL, "tx buf cb alloc"),
	_ENTRY(txbufcbget,		MISC, NULL, "tx buf cb get"),
	_ENTRY(txbufgballoc,		MISC, NULL, "tx buf gb alloc"),
	_ENTRY(txbufgbget,		MISC, NULL, "tx buf gb get"),
	_ENTRY(txbufgbput,		MISC, NULL, "tx buf gb put"),
	_ENTRY(txdel,			MISC, NULL, "tx del"),
	_ENTRY(txerr,			MISC, NULL, "tx error"),
	_ENTRY(txerrcmd,		MISC, NULL, "tx cmd error"),
	_ENTRY(txerrgbuf,		MISC, NULL, "tx gbuf error"),
	_ENTRY(txerrlink,		MISC, NULL, "tx link error"),
	_ENTRY(txerrmkcmd,		MISC, NULL, "tx makecmd error"),
#undef	_ENTRY
};
#endif
a355 3

	OCTEON_EVCNT_ATTACH_EVCNTS(sc, octeon_evcnt_entries,
	    sc->sc_dev.dv_xname);
a602 1
		OCTEON_EVCNT_INC(sc, txbufgbput);
a637 1
		OCTEON_EVCNT_INC(sc, txerrgbuf);
a679 2

	OCTEON_EVCNT_INC(sc, txadd);
a698 2

	OCTEON_EVCNT_INC(sc, txdel);
a713 1
		OCTEON_EVCNT_INC(sc, rxbufpkput);
a716 1
	OCTEON_EVCNT_INC(sc, rxbufwqput);
a724 3
#ifdef OCTEON_ETH_DEBUG
	struct octeon_eth_softc *sc = (void *)(uintptr_t)work[0];
#endif
a726 2
	OCTEON_EVCNT_INC(sc, rxrs);

a727 1
	OCTEON_EVCNT_INC(sc, rxbufwqput);
a736 3
#ifdef OCTEON_ETH_DEBUG
	struct octeon_eth_softc *sc = (void *)(uintptr_t)work[0];
#endif
a739 2
	OCTEON_EVCNT_INC(sc, rxbufwqput);

a740 1
	OCTEON_EVCNT_INC(sc, rxbufpkput);
d856 1
a856 1
	printf("kva %lx is not be able to convert physical address\n", kva);
a978 1
		OCTEON_EVCNT_INC(sc, txbufcbget);
a1001 1
		OCTEON_EVCNT_INC(sc, txerrmkcmd);
a1008 1
		OCTEON_EVCNT_INC(sc, txerrcmd);
a1022 2
	OCTEON_EVCNT_INC(sc, tx);

a1027 1
		OCTEON_EVCNT_INC(sc, txerrgbuf);
a1030 2
	OCTEON_EVCNT_INC(sc, txbufgbget);

a1032 1
	OCTEON_ETH_KASSERT(gbuf != NULL);
a1037 1
		OCTEON_EVCNT_INC(sc, txbufgbput);
a1077 1
			OCTEON_EVCNT_INC(sc, txerrlink);
a1111 1
			OCTEON_EVCNT_INC(sc, txerr);
a1311 3
	/* embed sc pointer into work[0] for _ext_free evcnt */
	work[0] = (uintptr_t)sc;

a1373 1
		OCTEON_EVCNT_INC(sc, rxerrlink);
a1383 1
		OCTEON_EVCNT_INC(sc, rxerrjmb);
a1403 1
		OCTEON_EVCNT_INC(sc, rxerrcode);
a1429 2

	OCTEON_EVCNT_INC(sc, rx);
@


1.15
log
@<netinet/in_systm.h> is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.14 2014/05/10 22:25:16 jasper Exp $	*/
d124 1
a124 1
static void		octeon_eth_buf_init(struct octeon_eth_softc *);
d126 59
a184 63
static int	octeon_eth_match(struct device *, void *, void *);
static void	octeon_eth_attach(struct device *, struct device *, void *);
static void	octeon_eth_pip_init(struct octeon_eth_softc *);
static void	octeon_eth_ipd_init(struct octeon_eth_softc *);
static void	octeon_eth_pko_init(struct octeon_eth_softc *);
static void	octeon_eth_asx_init(struct octeon_eth_softc *);
static void	octeon_eth_smi_init(struct octeon_eth_softc *);

static void	octeon_eth_board_mac_addr(uint8_t *);

static int	octeon_eth_mii_readreg(struct device *, int, int);
static void	octeon_eth_mii_writereg(struct device *, int, int, int);
static void	octeon_eth_mii_statchg(struct device *);

static int	octeon_eth_mediainit(struct octeon_eth_softc *);
static void	octeon_eth_mediastatus(struct ifnet *, struct ifmediareq *);
static int	octeon_eth_mediachange(struct ifnet *);

static void	octeon_eth_send_queue_flush_prefetch(struct octeon_eth_softc *);
static void	octeon_eth_send_queue_flush_fetch(struct octeon_eth_softc *);
static void	octeon_eth_send_queue_flush(struct octeon_eth_softc *);
static void	octeon_eth_send_queue_flush_sync(struct octeon_eth_softc *);
static int	octeon_eth_send_queue_is_full(struct octeon_eth_softc *);
static void	octeon_eth_send_queue_add(struct octeon_eth_softc *,
			    struct mbuf *, uint64_t *);
static void	octeon_eth_send_queue_del(struct octeon_eth_softc *,
			    struct mbuf **, uint64_t **);
static int	octeon_eth_buf_free_work(struct octeon_eth_softc *,
			    uint64_t *, uint64_t);
static void	octeon_eth_buf_ext_free_m(caddr_t, u_int, void *);
static void	octeon_eth_buf_ext_free_ext(caddr_t, u_int, void *);

static int	octeon_eth_ioctl(struct ifnet *, u_long, caddr_t);
static void	octeon_eth_watchdog(struct ifnet *);
static int	octeon_eth_init(struct ifnet *);
static int	octeon_eth_stop(struct ifnet *, int);
static void	octeon_eth_start(struct ifnet *);

static int	octeon_eth_send_cmd(struct octeon_eth_softc *, uint64_t,
			    uint64_t);
static uint64_t	octeon_eth_send_makecmd_w1(int, paddr_t);
static uint64_t octeon_eth_send_makecmd_w0(uint64_t, uint64_t, size_t,
			    int);
static int	octeon_eth_send_makecmd_gbuf(struct octeon_eth_softc *,
			    struct mbuf *, uint64_t *, int *);
static int	octeon_eth_send_makecmd(struct octeon_eth_softc *,
			    struct mbuf *, uint64_t *, uint64_t *, uint64_t *);
static int	octeon_eth_send_buf(struct octeon_eth_softc *,
			    struct mbuf *, uint64_t *);
static int	octeon_eth_send(struct octeon_eth_softc *,
			    struct mbuf *);

static int	octeon_eth_reset(struct octeon_eth_softc *);
static int	octeon_eth_configure(struct octeon_eth_softc *);
static int	octeon_eth_configure_common(struct octeon_eth_softc *);

static void	octeon_eth_tick_free(void *arg);
static void	octeon_eth_tick_misc(void *);

static int	octeon_eth_recv_mbuf(struct octeon_eth_softc *,
			    uint64_t *, struct mbuf **);
static int	octeon_eth_recv_check_code(struct octeon_eth_softc *,
			    uint64_t);
d186 1
a186 2
static int      octeon_eth_recv_check_jumbo(struct octeon_eth_softc *,
			    uint64_t);
d188 4
a191 6
static int	octeon_eth_recv_check_link(struct octeon_eth_softc *,
			    uint64_t);
static int	octeon_eth_recv_check(struct octeon_eth_softc *,
			    uint64_t);
static int	octeon_eth_recv(struct octeon_eth_softc *, uint64_t *);
static void		octeon_eth_recv_intr(void *, uint64_t *);
d194 2
a195 2
static struct	octeon_eth_softc *octeon_eth_gsc[GMX_PORT_NUNITS];
static void	*octeon_eth_pow_recv_ih;
d252 1
a252 1
static const struct octeon_eth_pool_param {
d273 1
a273 1
static void
d294 1
a294 1
static int
d306 1
a306 1
static void
d404 1
a404 1
static void
d418 1
a418 1
static void
d431 1
a431 1
static void
d445 1
a445 1
static void
d455 1
a455 1
static void
d468 1
a468 1
static void
d523 1
a523 1
static int
d530 1
a530 1
static void
d537 1
a537 1
static void
d555 1
a555 1
static int
d584 1
a584 1
static void
d596 1
a596 1
static int
d609 1
a609 1
static void
d617 1
a617 1
static void
d630 1
a630 1
static void
d655 1
a655 1
static void
d672 1
a672 1
static int
d712 1
a712 1
static void
d729 1
a729 1
static void
d750 1
a750 1
static int
d772 1
a772 1
static void
d789 1
a789 1
static void
d810 1
a810 1
static int
d880 1
a880 1
static uint64_t
d895 1
a895 1
static uint64_t 
d923 1
a923 1
static int
d977 1
a977 1
static int
d1014 1
a1014 1
static int
d1056 1
a1056 1
static int
d1082 1
a1082 1
static int
d1121 1
a1121 1
static void
d1222 1
a1222 1
static void
d1238 1
a1238 1
static int
d1271 1
a1271 1
static int
d1295 1
a1295 1
static int
d1306 1
a1306 1
static int
d1327 1
a1327 1
static int
d1348 1
a1348 1
static int
d1410 1
a1410 1
static int
d1426 1
a1426 1
static int
d1435 1
a1435 1
static int
d1443 1
a1443 1
static int
d1491 1
a1491 1
static int
d1567 1
a1567 1
static void
d1597 1
a1597 1
static void
d1630 1
a1630 1
static void
@


1.14
log
@various format string fixes and remove -Wno-format from octeon

feedback/ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.13 2014/03/10 09:41:27 jasper Exp $	*/
a60 1
#include <net/route.h>
a64 4

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
@


1.13
log
@- fix the mediastatus when the interface is not configured.
- remove unneeded comment, kern.netlivelock doesn't get set here.
- rework octeon_eth_mediainit() to be more like other drivers and
  remove a bunch of XXXs in the process.

testing and ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.12 2013/09/16 20:52:14 jmatthew Exp $	*/
d931 1
a931 1
	printf("kva %p is not be able to convert physical address\n", kva);
@


1.12
log
@work out phy addresses before attaching cnmac and pass them to mii_attach
rather than hiding them in the mii read/write functions.

ok dlg@@ jasper@@ bcallah@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.11 2013/08/17 10:00:09 bluhm Exp $	*/
a344 5
	/*
	 * live lock control notifications.
	 * XXX: use sysctl ???
	 */

d571 1
d583 7
a589 3
	/* XXX */
	if (LIST_FIRST(&sc->sc_mii.mii_phys) != NULL) {
		/* XXX */
a590 6
	} else {
		/* XXX */
		ifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER | IFM_NONE,
		    MII_MEDIA_NONE, NULL);
		/* XXX */
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER | IFM_NONE);
d613 2
a614 1
	mii_mediachg(&sc->sc_mii);
d616 1
a616 1
	return 0;
@


1.11
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Remove these include lines from octeon drivers.
test and OK bcallah@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.10 2013/04/12 15:22:26 bcallah Exp $	*/
a261 9
/* XXX board-specific */
static const int	octeon_eth_phy_table[] = {
#if defined __seil5__
	0x04, 0x01, 0x02
#else
	0x02, 0x03, 0x22
#endif
};

d332 1
d544 1
a544 9
	int phy_addr = octeon_eth_phy_table[phy_no];

	if (sc->sc_port >= (int)nitems(octeon_eth_phy_table) ||
	    phy_no != sc->sc_port) {
		log(LOG_ERR,
		    "mii read address mismatch, phy number %d.\n", phy_no);
		return -1;
	}
	return cn30xxsmi_read(sc->sc_smi, phy_addr, reg);
d551 1
a551 9
	int phy_addr = octeon_eth_phy_table[phy_no];

	if (sc->sc_port >= (int)nitems(octeon_eth_phy_table) ||
	    phy_no != sc->sc_port) {
		log(LOG_ERR,
		    "mii write address mismatch, phy number %d.\n", phy_no);
		return;
	}
	cn30xxsmi_write(sc->sc_smi, phy_addr, reg, value);
d585 1
a585 1
	    0xffffffff, sc->sc_port, MII_OFFSET_ANY, MIIF_DOPAUSE);
@


1.10
log
@Fix the log messages displayed to the user.
ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.9 2013/03/21 09:29:12 jasper Exp $	*/
a68 1
#include <netinet/in_var.h>
@


1.9
log
@- remove two now-unused macros.

ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.8 2013/03/21 09:26:31 jasper Exp $	*/
d558 1
a558 1
		    "mii read address is mismatch, phy number %d.\n", phy_no);
d573 1
a573 1
		    "mii write address is mismatch, phy number %d.\n", phy_no);
d1028 2
a1029 2
		log(LOG_WARNING, "%s: there are a lot of number of segments"
		    " of transmission data", sc->sc_dev.dv_xname);
d1079 1
a1079 1
			    "%s: can not allocate command buffer from free pool allocator\n",
d1136 1
a1136 1
		    "%s: can not allocate gather buffer from free pool allocator\n",
d1226 1
a1226 1
		  	  "%s: failed in the transmission of the packet\n",
d1498 1
a1498 1
#if 0 /* XXX Performance tunig (Jumbo-frame is not supported yet!) */
d1516 1
a1516 1
			/* not an erorr. it's because of overload */
d1522 1
a1522 1
				    "%s: the reception error had occured, "
d1710 1
a1710 1
			    "%s: the preamble processing is switched to hardware\n", 
@


1.8
log
@fix detection of the MAC address by reading it from the correct address,
instead of from a random location which resulted in 00:01:02:etc addresses.

confirmed to match up with the MAC addresses linux detects on the ERL;
no phy (atphy(4)) attaches still.

ok bcallah@@ chris@@ yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.7 2011/07/03 21:42:11 yasuoka Exp $	*/
a492 14

#define	ADDR2UINT64(u, a) \
	do { \
		u = \
		    (((uint64_t)a[0] << 40) | ((uint64_t)a[1] << 32) | \
		     ((uint64_t)a[2] << 24) | ((uint64_t)a[3] << 16) | \
		     ((uint64_t)a[4] <<  8) | ((uint64_t)a[5] <<  0)); \
	} while (0)
#define	UINT642ADDR(a, u) \
	do { \
		a[0] = (uint8_t)((u) >> 40); a[1] = (uint8_t)((u) >> 32); \
		a[2] = (uint8_t)((u) >> 24); a[3] = (uint8_t)((u) >> 16); \
		a[4] = (uint8_t)((u) >>  8); a[5] = (uint8_t)((u) >>  0); \
	} while (0)
@


1.7
log
@Tweak the dmesg output a bit.  From brad@@

ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.6 2011/07/03 20:26:33 yasuoka Exp $	*/
d140 1
a140 1
static void	octeon_eth_board_mac_addr(uint8_t *, size_t, int);
d292 3
d351 1
a351 1
	octeon_eth_board_mac_addr(enaddr, sizeof(enaddr), sc->sc_port);
d509 1
a509 1
octeon_eth_board_mac_addr(uint8_t *enaddr, size_t size, int port)
d511 45
a555 2
	uint64_t addr;
	int i;
d557 2
a558 7
	/* XXX read a mac_dsc tuple from EEPROM */
	for (i = 0; i < size; i++)
		enaddr[i] = i;

	ADDR2UINT64(addr, enaddr);
	addr += port;
	UINT642ADDR(enaddr, addr);
@


1.6
log
@- add missing #include "bpfilter.h" on if_cnmac.
- delete #include <sys/cdefs.h> because it's unnecessary.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.5 2011/06/24 02:13:23 yasuoka Exp $	*/
d349 1
a349 1
	printf(": Ethernet address %s\n", ether_sprintf(enaddr));
@


1.5
log
@Remove SET/CLR/ISSET macros from Octeon code.  The kernel already provides
these macros.

This diff from brad@@
built test and ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.4 2011/06/22 07:29:06 yasuoka Exp $	*/
d28 1
a28 1
#include <sys/cdefs.h>
@


1.4
log
@some fixes for cnmac(4)

- Fix MAC address printing for OpenBSD dmesg.
- Set IFCAP_VLAN_MTU to allow for VLAN sized frames.
- Remove commented out code to enable the shutdown hook since OpenBSD
  doesn't use these hooks in Ethernet drivers anymore.

this diff from brad@@
ok and tested by yasuoka@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.3 2011/06/19 02:01:23 yasuoka Exp $	*/
a101 6

#ifndef SET
#define	SET(t, f)	((t) |= (f))
#define	ISSET(t, f)	((t) & (f))
#define	CLR(t, f)	((t) &= ~(f))
#endif
@


1.3
log
@Clean up ioctl handler a bit and rearrange the receive filter callback to
the proper location.

this diff from brad@@
ok and tested by yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.2 2011/06/17 03:36:24 yasuoka Exp $	*/
a338 2
	printf("\n");

d355 1
a355 2
	printf("%s: Ethernet address %s\n", sc->sc_dev.dv_xname,
	    ether_sprintf(enaddr));
a399 1
	ifp->if_stop = octeon_eth_stop; /* XXX */
d403 1
a403 1
	ifp->if_capabilities = 0; /* XXX */
a424 8

#if 0
	/* Make sure the interface is shutdown during reboot. */
	sc->sc_sdhook = shutdownhook_establish(octeon_eth_shutdown, sc);
	if (sc->sc_sdhook == NULL)
		printf("%s: WARNING: unable to establish shutdown hook\n",
		    sc->sc_dev.dv_xname);
#endif
@


1.2
log
@add missing the copyright notice.
delete garbage lines.

ok syuu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnmac.c,v 1.1 2011/06/16 11:22:30 syuu Exp $	*/
d847 1
a848 1
	struct ifaddr *ifa = (struct ifaddr *)data;
d852 1
d855 2
a856 2
		if (!(ifp->if_flags & IFF_UP)) {
			ifp->if_flags |= IFF_UP;
a857 1
		}
d861 1
a861 1
#endif /* INET */
d875 1
a891 1
		/* XXX: Flow contorol */
d894 1
a896 10
		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware filter
			 * accordingly.
			 */
			if (ISSET(ifp->if_flags, IFF_RUNNING))
				cn30xxgmx_set_filter(sc->sc_gmx_port);
			error = 0;
		}
		break;
d898 7
d906 1
a907 1

@


1.1
log
@Ethernet driver merged from IIJ's contribution code.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d3 25
@

