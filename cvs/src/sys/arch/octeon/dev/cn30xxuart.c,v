head	1.11;
access;
symbols
	OPENBSD_6_1:1.9.0.6
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.2
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.7.0.4
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.6
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.5.0.4
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.4.0.6
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.2
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.1.0.8
	OPENBSD_5_3_BASE:1.1
	OPENBSD_5_2:1.1.0.6
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.4
	OPENBSD_5_0:1.1.0.2
	OPENBSD_5_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.11
date	2017.09.21.12.50.20;	author visa;	state Exp;
branches;
next	1.10;
commitid	wrVC9CeqtkcQLrE5;

1.10
date	2017.07.03.08.17.20;	author visa;	state Exp;
branches;
next	1.9;
commitid	T2rMffEZFZhGPIZu;

1.9
date	2016.04.14.13.51.58;	author visa;	state Exp;
branches;
next	1.8;
commitid	IH9Yo1wdu1Lw7qMJ;

1.8
date	2016.04.14.13.49.27;	author visa;	state Exp;
branches;
next	1.7;
commitid	8Gbmj8ersbRHk2zW;

1.7
date	2015.02.05.23.29.33;	author uebayasi;	state Exp;
branches;
next	1.6;
commitid	TQIuo6UPyhnOkVKI;

1.6
date	2015.02.05.23.18.15;	author uebayasi;	state Exp;
branches;
next	1.5;
commitid	MUkNsWQ6eohdrhx0;

1.5
date	2014.06.17.01.33.04;	author jmatthew;	state Exp;
branches;
next	1.4;
commitid	Vozs7jQDUDtEgOjM;

1.4
date	2013.06.05.02.45.03;	author jasper;	state Exp;
branches;
next	1.3;

1.3
date	2013.06.05.01.32.22;	author jasper;	state Exp;
branches;
next	1.2;

1.2
date	2013.06.02.19.47.32;	author jasper;	state Exp;
branches;
next	1.1;

1.1
date	2011.05.08.13.39.30;	author syuu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Ensure proper order of register accesses by readback after write.
This fixes spurious interrupts seen on CN7360.
@
text
@/*	$OpenBSD: cn30xxuart.c,v 1.10 2017/07/03 08:17:20 visa Exp $	*/

/*
 * Copyright (c) 2001-2004 Opsycon AB  (www.opsycon.se / www.opsycon.com)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/tty.h>
#include <sys/conf.h>

#include <dev/ofw/fdt.h>
#include <dev/ofw/openfirm.h>

#include <machine/octeonreg.h>
#include <machine/octeonvar.h>
#include <machine/autoconf.h>
#include <machine/bus.h>
#include <machine/fdt.h>

#include <dev/ic/comreg.h>
#include <dev/ic/comvar.h>
#include <dev/cons.h>

#include <octeon/dev/iobusvar.h>
#include <octeon/dev/cn30xxuartreg.h>

#define OCTEON_UART_FIFO_SIZE		64

int	cn30xxuart_probe(struct device *, void *, void *);
void	cn30xxuart_attach(struct device *, struct device *, void *);
int	cn30xxuart_intr(void *);

struct cfattach cn30xxuart_ca = {
	sizeof(struct com_softc), cn30xxuart_probe, cn30xxuart_attach
};

extern struct cfdriver com_cd;

cons_decl(cn30xxuart);

#define  USR_TXFIFO_NOTFULL		2

/* XXX: What is this used for? Removed from stand/boot/uart.c -r1.2 */
static int delay_changed = 1;
int cn30xxuart_delay(void);
void cn30xxuart_wait_txhr_empty(int);

uint8_t	 uartbus_read_1(bus_space_tag_t, bus_space_handle_t, bus_size_t);
void	 uartbus_write_1(bus_space_tag_t, bus_space_handle_t, bus_size_t,
	    uint8_t);

bus_space_t uartbus_tag = {
	.bus_base = PHYS_TO_XKPHYS(0, CCA_NC),
	.bus_private = NULL,
	._space_read_1 = uartbus_read_1,
	._space_write_1 = uartbus_write_1,
	._space_map = iobus_space_map,
	._space_unmap = iobus_space_unmap
};

void
com_fdt_init_cons(void)
{
	comconsiot = &uartbus_tag;
	comconsaddr = OCTEON_UART0_BASE;
	comconsfreq = octeon_ioclock_speed();
	comconsrate = B115200;
	comconscflag = (TTYDEF_CFLAG & ~(CSIZE | PARENB)) | CS8;
}

int
cn30xxuart_probe(struct device *parent, void *match, void *aux)
{
	struct fdt_attach_args *faa = aux;

	return OF_is_compatible(faa->fa_node, "cavium,octeon-3860-uart");
}

void
cn30xxuart_attach(struct device *parent, struct device *self, void *aux)
{
	struct fdt_attach_args *faa = aux;
	struct com_softc *sc = (void *)self;
	int console = 0;

	if (faa->fa_nreg != 1)
		return;

	if (comconsiot == &uartbus_tag && comconsaddr == faa->fa_reg[0].addr)
		console = 1;

	sc->sc_hwflags = 0;
	sc->sc_swflags = 0;
	sc->sc_frequency = octeon_ioclock_speed();
	sc->sc_uarttype = COM_UART_16550A;
	sc->sc_fifolen = OCTEON_UART_FIFO_SIZE;

	if (!console || comconsattached) {
		sc->sc_iot = &uartbus_tag;
		sc->sc_iobase = faa->fa_reg[0].addr;
		if (bus_space_map(sc->sc_iot, sc->sc_iobase, COM_NPORTS, 0,
		    &sc->sc_ioh)) {
			printf(": could not map UART registers\n");
			return;
		}
	} else {
		/* Reuse the early console settings. */
		sc->sc_iot = comconsiot;
		sc->sc_iobase = comconsaddr;
		if (comcnattach(sc->sc_iot, sc->sc_iobase, comconsrate,
		    sc->sc_frequency, comconscflag))
			panic("could not set up serial console");
		sc->sc_ioh = comconsioh;
	}

	com_attach_subr(sc);

	octeon_intr_establish_fdt(faa->fa_node, IPL_TTY, cn30xxuart_intr, sc,
	    sc->sc_dev.dv_xname);
}

int
cn30xxuart_intr(void *arg)
{
	comintr(arg);

	/*
	 * Always return non-zero to prevent console clutter about spurious
	 * interrupts. comstart() enables the transmitter holding register
	 * empty interrupt before adding data to the FIFO, which can trigger
	 * a premature interrupt on the primary CPU in a multiprocessor system.
	 */
	return 1;
}

/*
 * Early console routines.
 */

int
cn30xxuart_delay(void)
{
	int divisor;
	u_char lcr;
	static int d = 0;

	if (!delay_changed)
		return d;
	delay_changed = 0;
	lcr = octeon_xkphys_read_8(MIO_UART0_LCR);
	octeon_xkphys_write_8(MIO_UART0_LCR, lcr | LCR_DLAB);
	divisor = octeon_xkphys_read_8(MIO_UART0_DLL) |
		octeon_xkphys_read_8(MIO_UART0_DLH) << 8;
	octeon_xkphys_write_8(MIO_UART0_LCR, lcr);

	return 10; /* return an approx delay value */
}

void
cn30xxuart_wait_txhr_empty(int d)
{
	while (((octeon_xkphys_read_8(MIO_UART0_LSR) & LSR_TXRDY) == 0) &&
	    ((octeon_xkphys_read_8(MIO_UART0_USR) & USR_TXFIFO_NOTFULL) == 0))
		delay(d);
}

void
cn30xxuartcninit(struct consdev *consdev)
{
}

void
cn30xxuartcnprobe(struct consdev *consdev)
{
}

void
cn30xxuartcnpollc(dev_t dev, int c)
{
}

void
cn30xxuartcnputc(dev_t dev, int c)
{
	int d;

	/* 1/10th the time to transmit 1 character (estimate). */
	d = cn30xxuart_delay();
	cn30xxuart_wait_txhr_empty(d);
	octeon_xkphys_write_8(MIO_UART0_RBR, (uint8_t)c);
	cn30xxuart_wait_txhr_empty(d);
}

int
cn30xxuartcngetc(dev_t dev)
{
	int c, d;

	/* 1/10th the time to transmit 1 character (estimate). */
	d = cn30xxuart_delay();

	while ((octeon_xkphys_read_8(MIO_UART0_LSR) & LSR_RXRDY) == 0)
		delay(d);

	c = (uint8_t)octeon_xkphys_read_8(MIO_UART0_RBR);

	return (c);
}

/*
 * Bus access routines. These let com(4) work with the 64-bit registers.
 */

uint8_t
uartbus_read_1(bus_space_tag_t tag, bus_space_handle_t handle, bus_size_t off)
{
	return *(volatile uint64_t *)(handle + (off << 3));
}

void
uartbus_write_1(bus_space_tag_t tag, bus_space_handle_t handle, bus_size_t off,
    uint8_t value)
{
	volatile uint64_t *reg = (uint64_t *)(handle + (off << 3));

	*reg = value;
	(void)*reg;
}
@


1.10
log
@Attach com(4) using fdt on octeon.

The relevant part of uartbus(4) is made part of the com(4) glue
to avoid extra maneuvers in the code.
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxuart.c,v 1.9 2016/04/14 13:51:58 visa Exp $	*/
d248 4
a251 1
	*(volatile uint64_t *)(handle + (off << 3)) = value;
@


1.9
log
@Enable UART FIFOs.
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxuart.c,v 1.8 2016/04/14 13:49:27 visa Exp $	*/
d35 4
d42 1
a48 1
#include <octeon/dev/uartbusvar.h>
d72 23
d98 1
a98 24
	struct cfdata *cf = match;
	struct uartbus_attach_args *uba = aux;
	bus_space_tag_t iot = uba->uba_memt;
	bus_space_handle_t ioh;
	int rv = 0, console;

	if (strcmp(uba->uba_name, com_cd.cd_name) != 0)
		return 0;

	console = 1;

	/* if it's in use as console, it's there. */
	if (!(console && !comconsattached)) {
		if (bus_space_map(iot, uba->uba_baseaddr, COM_NPORTS, 0, &ioh)) {
			printf(": can't map uart registers\n");
			return 1;
		}
		rv = comprobe1(iot, ioh);
	} else
		rv = 1;

	/* make a config stanza with exact locators match over a generic line */
	if (cf->cf_loc[0] != -1)
		rv += rv;
d100 1
a100 1
	return rv;
d106 1
d108 4
a111 2
	struct uartbus_attach_args *uba = aux;
	int console;
d113 2
a114 1
	console = 1;
a115 2
	sc->sc_iot = uba->uba_memt;
	sc->sc_iobase = uba->uba_baseaddr;
d122 16
a137 16
	/* if it's in use as console, it's there. */
	if (bus_space_map(sc->sc_iot, sc->sc_iobase, COM_NPORTS, 0, &sc->sc_ioh)) {
		printf(": can't map uart registers\n");
		return;
	}

	if (console && !comconsattached) {
		/*
		 * If we are the console, reuse the existing bus_space
		 * information, so that comcnattach() invokes bus_space_map()
		 * with correct parameters.
		 */

		if (comcnattach(sc->sc_iot, sc->sc_iobase, 115200,
		    sc->sc_frequency, (TTYDEF_CFLAG & ~(CSIZE | PARENB)) | CS8))
			panic("can't setup serial console");
d142 2
a143 2
	octeon_intr_establish(uba->uba_intr, IPL_TTY, cn30xxuart_intr,
	    (void *)sc, sc->sc_dev.dv_xname);
d163 1
d232 17
@


1.8
log
@Wrap comintr() so that the interrupt handler always returns non-zero.
This prevents console clutter about spurious UART interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxuart.c,v 1.7 2015/02/05 23:29:33 uebayasi Exp $	*/
d47 2
d113 2
a114 1
	sc->sc_uarttype = COM_UART_16550;
@


1.7
log
@Whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d49 1
d133 1
a133 1
	octeon_intr_establish(uba->uba_intr, IPL_TTY, comintr,
d135 14
@


1.6
log
@Use octeon_xkphys_*_8().
@
text
@d144 1
a144 1
        static int d = 0;
d146 1
a146 1
        if (!delay_changed)
d148 1
a148 1
        delay_changed = 0;
d162 1
a162 1
        	((octeon_xkphys_read_8(MIO_UART0_USR) & USR_TXFIFO_NOTFULL) == 0))
d188 1
a188 1
        cn30xxuart_wait_txhr_empty(d);
d190 1
a190 1
        cn30xxuart_wait_txhr_empty(d);
@


1.5
log
@The io clock on Octeon II (CN6xxx) runs at a different rate to the cpu clock.
Program the uarts based on the io clock rate on these platforms.

ok jasper@@ pirofti@@ yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxuart.c,v 1.4 2013/06/05 02:45:03 jasper Exp $	*/
d45 1
a57 7
#define  OCTEON_MIO_UART0               0x8001180000000800ull
#define  OCTEON_MIO_UART0_LSR           0x8001180000000828ull
#define  OCTEON_MIO_UART0_RBR           0x8001180000000800ull
#define  OCTEON_MIO_UART0_USR           0x8001180000000938ull
#define  OCTEON_MIO_UART0_LCR           0x8001180000000818ull
#define  OCTEON_MIO_UART0_DLL           0x8001180000000880ull
#define  OCTEON_MIO_UART0_DLH           0x8001180000000888ull
d146 2
a147 1
        if (!delay_changed) return d;
d149 5
a153 5
	lcr = (u_char)*(uint64_t*)OCTEON_MIO_UART0_LCR;
	*(uint64_t*)OCTEON_MIO_UART0_LCR = lcr | LCR_DLAB;
	divisor = (int)(*(uint64_t*)OCTEON_MIO_UART0_DLL |
		*(uint64_t*)OCTEON_MIO_UART0_DLH << 8);
	*(uint64_t*)OCTEON_MIO_UART0_LCR = lcr;
d161 2
a162 2
	while (((*(uint64_t*)OCTEON_MIO_UART0_LSR & LSR_TXRDY) == 0) &&
        	((*(uint64_t*)OCTEON_MIO_UART0_USR & USR_TXFIFO_NOTFULL) == 0))
d182 1
a182 1
cn30xxuartcnputc (dev_t dev, int c)
d189 1
a189 1
	*(uint64_t*)OCTEON_MIO_UART0_RBR = (uint8_t)c;
d194 1
a194 1
cn30xxuartcngetc (dev_t dev)
d201 1
a201 1
	while ((*(uint64_t*)OCTEON_MIO_UART0_LSR & LSR_RXRDY) == 0)
d204 1
a204 1
	c = (uint8_t)*(uint64_t*)OCTEON_MIO_UART0_RBR;
@


1.4
log
@add XXX comment for delay_changed, untill we figure out what it actually does.

ok uebayasi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxuart.c,v 1.3 2013/06/05 01:32:22 jasper Exp $	*/
d35 1
d115 1
a115 1
	sc->sc_frequency = curcpu()->ci_hw.clock;
@


1.3
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxuart.c,v 1.2 2013/06/02 19:47:32 jasper Exp $	*/
d65 1
@


1.2
log
@remove unneeded octeonreg.h include
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxuart.c,v 1.1 2011/05/08 13:39:30 syuu Exp $	*/
d143 1
a143 1
int 
d154 1
a154 1
	divisor = (int)(*(uint64_t*)OCTEON_MIO_UART0_DLL | 
d157 1
a157 1
	
@


1.1
log
@combus renamed uartbus, com_oct renamed cn30xxuart
@
text
@d1 1
a1 1
/*	$OpenBSD: com_oct.c,v 1.2 2010/10/01 16:13:59 syuu Exp $	*/
a43 1
#include <octeon/dev/octeonreg.h>
@

