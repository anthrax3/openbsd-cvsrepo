head	1.4;
access;
symbols
	OPENBSD_6_2_BASE:1.4
	OPENBSD_6_1:1.3.0.12
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.8
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.4
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.6
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.2
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.2.0.10
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.8
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.0.6
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.4
	OPENBSD_5_0:1.1.0.2
	OPENBSD_5_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.4
date	2017.05.02.13.26.49;	author visa;	state Exp;
branches;
next	1.3;
commitid	RNCOX3BHktrY156Z;

1.3
date	2014.08.11.18.08.17;	author miod;	state Exp;
branches;
next	1.2;
commitid	3N1WQMXOTORvYvCh;

1.2
date	2012.12.05.23.20.14;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2011.06.16.11.22.30;	author syuu;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Revise MDIO driver code so that device instances can be attached
using fdt. This lets the system utilize multiple MDIO controllers.

This patch enables all RJ45 Ethernet ports on EdgeRouter Pro.
The SFP module slots do not work yet.

OK kettenis@@, jmatthew@@
@
text
@/*	$OpenBSD: cn30xxsmi.c,v 1.3 2014/08/11 18:08:17 miod Exp $	*/

/*
 * Copyright (c) 2007 Internet Initiative Japan, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/stdint.h>

#include <dev/ofw/fdt.h>
#include <dev/ofw/openfirm.h>

#include <machine/fdt.h>
#include <machine/octeonvar.h>

#include <octeon/dev/cn30xxsmireg.h>
#include <octeon/dev/cn30xxsmivar.h>

int	cn30xxsmi_match(struct device *, void *, void *);
void	cn30xxsmi_attach(struct device *, struct device *, void *);

void	cn30xxsmi_enable(struct cn30xxsmi_softc *);

const struct cfattach cn30xxsmi_ca = {
	sizeof(struct cn30xxsmi_softc), cn30xxsmi_match, cn30xxsmi_attach
};

struct cfdriver cn30xxsmi_cd = {
	NULL, "cn30xxsmi", DV_DULL
};

static SLIST_HEAD(, cn30xxsmi_softc) smi_list =
    SLIST_HEAD_INITIALIZER(smi_list);

#define	_SMI_RD8(sc, off) \
	bus_space_read_8((sc)->sc_regt, (sc)->sc_regh, (off))
#define	_SMI_WR8(sc, off, v) \
	bus_space_write_8((sc)->sc_regt, (sc)->sc_regh, (off), (v))

int
cn30xxsmi_match(struct device *parent, void *match, void *aux)
{
	struct fdt_attach_args *faa = aux;

	return OF_is_compatible(faa->fa_node, "cavium,octeon-3860-mdio");
}

void
cn30xxsmi_attach(struct device *parent, struct device *self, void *aux)
{
	struct fdt_attach_args *faa = aux;
	struct cn30xxsmi_softc *sc = (struct cn30xxsmi_softc *)self;

	if (faa->fa_nreg != 1)
		return;

	sc->sc_node = faa->fa_node;
	sc->sc_regt = faa->fa_iot;

	if (bus_space_map(sc->sc_regt, faa->fa_reg[0].addr, faa->fa_reg[0].size,
	    0, &sc->sc_regh)) {
		printf(": could not map registers\n");
		return;
	}

	SLIST_INSERT_HEAD(&smi_list, sc, sc_link);

	printf("\n");

	_SMI_WR8(sc, SMI_CLK_OFFSET, 0x1464);
	_SMI_WR8(sc, SMI_EN_OFFSET, SMI_EN_EN);
}

int
cn30xxsmi_read(struct cn30xxsmi_softc *sc, int phy_addr, int reg)
{
	uint64_t smi_rd;
	int timo;

	_SMI_WR8(sc, SMI_CMD_OFFSET, SMI_CMD_PHY_OP | 
	    (phy_addr << SMI_CMD_PHY_ADR_SHIFT) |
	    (reg << SMI_CMD_REG_ADR_SHIFT));

	timo = 10000;
	smi_rd = _SMI_RD8(sc, SMI_RD_DAT_OFFSET);
	while (ISSET(smi_rd, SMI_RD_DAT_PENDING)) {
		if (timo-- == 0)
			break;
		delay(10);
		smi_rd = _SMI_RD8(sc, SMI_RD_DAT_OFFSET);
	}
	if (ISSET(smi_rd, SMI_RD_DAT_PENDING)) {
		return -1;
	}

	return ISSET(smi_rd, SMI_RD_DAT_VAL) ? (smi_rd & SMI_RD_DAT_DAT) : 0;
}

void
cn30xxsmi_write(struct cn30xxsmi_softc *sc, int phy_addr, int reg, int value)
{
	uint64_t smi_wr;
	int timo;

	smi_wr = 0;
	SET(smi_wr, value);
	_SMI_WR8(sc, SMI_WR_DAT_OFFSET, smi_wr);

	_SMI_WR8(sc, SMI_CMD_OFFSET, (phy_addr << SMI_CMD_PHY_ADR_SHIFT) |
	    (reg << SMI_CMD_REG_ADR_SHIFT));

	timo = 10000;
	smi_wr = _SMI_RD8(sc, SMI_WR_DAT_OFFSET);
	while (ISSET(smi_wr, SMI_WR_DAT_PENDING)) {
		if (timo-- == 0)
			break;
		delay(10);
		smi_wr = _SMI_RD8(sc, SMI_WR_DAT_OFFSET);
	}
	if (ISSET(smi_wr, SMI_WR_DAT_PENDING)) {
		/* XXX log */
		printf("ERROR: cnmac_mii_writereg(0x%x, 0x%x, 0x%x) timed out.\n",
		    phy_addr, reg, value);
	}
}

int
cn30xxsmi_get_phy(int phandle, int port, struct cn30xxsmi_softc **psmi,
    int *preg)
{
	/* PHY addresses for Portwell CAM-0100 */
	static const int cam0100_phys[] = {
		0x02, 0x03, 0x22
	};

	struct cn30xxsmi_softc *smi;
	int parent, phynode;
	int reg;

	if (phandle != 0) {
		phynode = OF_getnodebyphandle(phandle);
		if (phynode == 0)
			return ENOENT;
		reg = OF_getpropint(phynode, "reg", UINT32_MAX);
		if (reg == UINT32_MAX)
			return ENOENT;

		parent = OF_parent(phynode);
		SLIST_FOREACH(smi, &smi_list, sc_link) {
			if (smi->sc_node == parent)
				goto found;
		}
		return ENOENT;
	} else {
		smi = SLIST_FIRST(&smi_list);
		if (smi == NULL)
			return ENOENT;

		switch (octeon_boot_info->board_type) {
		case BOARD_TYPE_UBIQUITI_E100:
			if (port > 2)
				return ENOENT;
			reg = 7 - port;
			break;
		case BOARD_TYPE_CN3010_EVB_HS5:
			if (port >= nitems(cam0100_phys))
				return ENOENT;
			reg = cam0100_phys[port];
			break;
		default:
			return ENOENT;
		}
	}

found:
	*psmi = smi;
	*preg = reg;
	return 0;
}
@


1.3
log
@De-static so that my ddb backtrace get closer to reality.
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxsmi.c,v 1.2 2012/12/05 23:20:14 deraadt Exp $	*/
d31 1
a31 2
#include <sys/malloc.h>
#include <sys/mbuf.h>
d33 4
a38 2
#include <octeon/dev/cn30xxfpavar.h>
#include <octeon/dev/cn30xxpipreg.h>
d42 3
d47 24
a70 1
/* XXX */
d72 1
a72 2
cn30xxsmi_init(struct cn30xxsmi_attach_args *aa,
    struct cn30xxsmi_softc **rsc)
d74 2
a75 2
	struct cn30xxsmi_softc *sc;
	int status;
d77 2
a78 3
	sc = malloc(sizeof(*sc), M_DEVBUF, M_WAITOK | M_ZERO);
	if (sc == NULL)
		panic("can't allocate memory: %s", __func__);
d80 8
a87 2
	sc->sc_port = aa->aa_port;
	sc->sc_regt = aa->aa_regt;
d89 1
a89 4
	status = bus_space_map(sc->sc_regt, SMI_BASE, SMI_SIZE, 0,
	    &sc->sc_regh);
	if (status != 0)
		panic("can't map %s space", "smi register");
d91 1
a91 1
	cn30xxsmi_enable(sc);
d93 2
a94 1
	*rsc = sc;
a96 5
#define	_SMI_RD8(sc, off) \
	bus_space_read_8((sc)->sc_regt, (sc)->sc_regh, (off))
#define	_SMI_WR8(sc, off, v) \
	bus_space_write_8((sc)->sc_regt, (sc)->sc_regh, (off), (v))

d150 3
a152 2
void
cn30xxsmi_enable(struct cn30xxsmi_softc *sc)
d154 43
a196 2
	_SMI_WR8(sc, SMI_EN_OFFSET, SMI_EN_EN);
}
d198 4
a201 4
void
cn30xxsmi_set_clock(struct cn30xxsmi_softc *sc, uint64_t clock)
{
	_SMI_WR8(sc, SMI_CLK_OFFSET, clock);
a202 1

@


1.2
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxsmi.c,v 1.1 2011/06/16 11:22:30 syuu Exp $	*/
d41 1
a41 1
static void		cn30xxsmi_enable(struct cn30xxsmi_softc *);
d126 1
a126 1
static void
@


1.1
log
@Ethernet driver merged from IIJ's contribution code.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a27 2

#include <sys/cdefs.h>
@

