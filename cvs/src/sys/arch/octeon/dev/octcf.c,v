head	1.28;
access;
symbols
	OPENBSD_6_1:1.28.0.6
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.28.0.4
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.28.0.2
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.27.0.4
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.24.0.4
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.13.0.4
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.7.0.8
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.6
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.4
	OPENBSD_5_0:1.7.0.2
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1;
locks; strict;
comment	@ * @;


1.28
date	2016.01.20.17.23.58;	author stefan;	state Exp;
branches;
next	1.27;
commitid	iJEmZe6Wd2Rh90CY;

1.27
date	2015.07.20.01.38.31;	author jasper;	state Exp;
branches;
next	1.26;
commitid	zSQSaW1rMWcG3djM;

1.26
date	2015.07.19.23.46.50;	author jasper;	state Exp;
branches;
next	1.25;
commitid	srHxICmjHBgmnrAl;

1.25
date	2014.08.11.19.00.50;	author miod;	state Exp;
branches;
next	1.24;
commitid	WSyMUxaCd6qqqO0W;

1.24
date	2014.07.23.10.06.18;	author jasper;	state Exp;
branches;
next	1.23;
commitid	6VGHHLiTTzMmbBe4;

1.23
date	2014.07.22.17.26.03;	author jasper;	state Exp;
branches;
next	1.22;
commitid	GfjzUnXTggdpouNb;

1.22
date	2014.07.22.14.52.35;	author jasper;	state Exp;
branches;
next	1.21;
commitid	FDzV40BIbNs5VJGN;

1.21
date	2014.07.22.14.49.49;	author jasper;	state Exp;
branches;
next	1.20;
commitid	WNy6k2cuHz81uIzQ;

1.20
date	2014.07.22.14.45.34;	author jasper;	state Exp;
branches;
next	1.19;
commitid	5EoU6pIfLxAKEEPy;

1.19
date	2014.07.21.21.07.34;	author jasper;	state Exp;
branches;
next	1.18;
commitid	PXCdkzAY6elrMkus;

1.18
date	2014.07.12.21.47.04;	author pirofti;	state Exp;
branches;
next	1.17;
commitid	SizKr69DwOFV1e13;

1.17
date	2014.07.12.20.38.27;	author krw;	state Exp;
branches;
next	1.16;
commitid	AioMwCB3YCAerBLv;

1.16
date	2014.07.12.20.36.45;	author krw;	state Exp;
branches;
next	1.15;
commitid	XcOFarbNIHPp9Xwa;

1.15
date	2014.07.12.18.44.42;	author tedu;	state Exp;
branches;
next	1.14;
commitid	uKVPYMN2MLxdZxzH;

1.14
date	2014.05.10.22.25.16;	author jasper;	state Exp;
branches;
next	1.13;

1.13
date	2013.11.01.01.06.03;	author dlg;	state Exp;
branches;
next	1.12;

1.12
date	2013.06.11.16.42.10;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2013.06.02.20.29.36;	author jasper;	state Exp;
branches;
next	1.10;

1.10
date	2013.03.19.16.37.12;	author jasper;	state Exp;
branches;
next	1.9;

1.9
date	2013.03.19.09.17.52;	author jasper;	state Exp;
branches;
next	1.8;

1.8
date	2013.03.15.09.18.19;	author jasper;	state Exp;
branches;
next	1.7;

1.7
date	2011.07.06.04.49.35;	author matthew;	state Exp;
branches;
next	1.6;

1.6
date	2011.06.19.04.55.34;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2011.06.19.04.35.06;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2011.06.05.18.40.33;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	2011.06.03.21.14.11;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	2011.05.08.13.24.55;	author syuu;	state Exp;
branches;
next	1.1;

1.1
date	2010.10.26.00.02.01;	author syuu;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Set segflg member of uio struct with symbolic enum value
instead of using magic numbers. No binary change.

Diff from Martin Natano.

ok deraadt@@
@
text
@/*	$OpenBSD: octcf.c,v 1.27 2015/07/20 01:38:31 jasper Exp $ */
/*	$NetBSD: wd.c,v 1.193 1999/02/28 17:15:27 explorer Exp $ */

/*
 * Copyright (c) 1998, 2001 Manuel Bouyer.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *	notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *	notice, this list of conditions and the following disclaimer in the
 *	documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*-
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Charles M. Hannum and by Onno van der Linden.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/mutex.h>
#include <sys/buf.h>
#include <sys/uio.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/disklabel.h>
#include <sys/disk.h>
#include <sys/syslog.h>
#include <sys/proc.h>
#include <sys/vnode.h>
#include <sys/dkio.h>

#include <machine/intr.h>
#include <machine/bus.h>

#include <dev/ata/atareg.h>
#include <dev/ata/atavar.h>
#include <dev/ic/wdcreg.h>
#include <dev/ic/wdcvar.h>

#include <octeon/dev/iobusvar.h>
#include <machine/octeonreg.h>
#include <machine/octeonvar.h>

#define OCTCF_REG_SIZE	8
#define ATAPARAMS_SIZE	512
#define SECTOR_SIZE	512
#define OCTCFDELAY	100 /* 100 microseconds */
#define NR_TRIES	1000

#define DEBUG_XFERS  0x02
#define DEBUG_FUNCS  0x08
#define DEBUG_PROBE  0x10

#ifdef OCTCFDEBUG
int octcfdebug_mask = 0xff;
#define OCTCFDEBUG_PRINT(args, level) do {	\
	if ((octcfdebug_mask & (level)) != 0)	\
		printf args;			\
} while (0)
#else
#define OCTCFDEBUG_PRINT(args, level)
#endif

struct octcf_softc {
	/* General disk infos */
	struct device sc_dev;
	struct disk sc_dk;
	struct bufq sc_bufq;
	struct buf *sc_bp;
	struct ataparams sc_params;/* drive characteristics found */
	int sc_flags;
#define OCTCFF_LOADED		0x10 /* parameters loaded */
	u_int64_t sc_capacity;
	bus_space_tag_t       sc_iot;
	bus_space_handle_t    sc_ioh;
};

int	octcfprobe(struct device *, void *, void *);
void	octcfattach(struct device *, struct device *, void *);
int	octcfdetach(struct device *, int);
int	octcfactivate(struct device *, int);
int	octcfprint(void *, char *);

struct cfattach octcf_ca = {
	sizeof(struct octcf_softc), octcfprobe, octcfattach,
	octcfdetach, octcfactivate
};

struct cfdriver octcf_cd = {
	NULL, "octcf", DV_DISK
};

void  octcfgetdefaultlabel(struct octcf_softc *, struct disklabel *);
int   octcfgetdisklabel(dev_t dev, struct octcf_softc *, struct disklabel *, int);
void  octcfstrategy(struct buf *);
void  octcfstart(void *);
void  _octcfstart(struct octcf_softc*, struct buf *);
void  octcfdone(void *);

cdev_decl(octcf);
bdev_decl(octcf);

#define octcflookup(unit) (struct octcf_softc *)disk_lookup(&octcf_cd, (unit))

int	octcf_write_sectors(struct octcf_softc *, uint32_t, uint32_t, void *);
int	octcf_read_sectors(struct octcf_softc *, uint32_t, uint32_t, void *);
int	octcf_wait_busy(struct octcf_softc *);
void	octcf_command(struct octcf_softc *, uint32_t, uint8_t);
int 	octcf_get_params(struct octcf_softc *, struct ataparams *);

#define OCTCF_REG_READ(wd, reg) \
	bus_space_read_2(wd->sc_iot, wd->sc_ioh, reg & 0x6)
#define OCTCF_REG_WRITE(wd, reg, val) \
	bus_space_write_2(wd->sc_iot, wd->sc_ioh, reg & 0x6, val)

int
octcfprobe(struct device *parent, void *match, void *aux)
{
	if (octeon_boot_info->cf_common_addr == 0) {
		OCTCFDEBUG_PRINT(("%s: No cf bus found\n", __func__), DEBUG_FUNCS | DEBUG_PROBE);
		return 0;
	}

	return 1;
}

void
octcfattach(struct device *parent, struct device *self, void *aux)
{
	struct octcf_softc *wd = (void *)self;
	struct iobus_attach_args *aa = aux;
	int i, blank;
	char buf[41], c, *p, *q;
	uint8_t status;
	OCTCFDEBUG_PRINT(("%s\n", __func__), DEBUG_FUNCS | DEBUG_PROBE);

	wd->sc_iot = aa->aa_bust;

	if (bus_space_map(wd->sc_iot, aa->aa_addr,
	    OCTCF_REG_SIZE, BUS_SPACE_MAP_KSEG0, &wd->sc_ioh)) {
		printf(": couldn't map registers\n");
		return;
	}

	for (i = 0; i < 8; i++) {
		uint64_t cfg =
		*(uint64_t *)PHYS_TO_XKPHYS(
			OCTEON_MIO_BOOT_BASE + MIO_BOOT_REG_CFG(i), CCA_NC);

		if ((cfg & BOOT_CFG_BASE_MASK) ==
			(OCTEON_CF_BASE >> BOOT_CFG_BASE_SHIFT)) {
			if ((cfg & BOOT_CFG_WIDTH_MASK) == 0)
				printf(": doesn't support 8bit cards\n");
			break;
		}
	}

	/* Check if CF is inserted */
	i = 0;
	while ( (status = (OCTCF_REG_READ(wd, wdr_status)>>8)) & WDCS_BSY) {
		if ((i++) == NR_TRIES )     {
			printf(": card not present\n");
			return;
               	}
		DELAY(OCTCFDELAY);
	}

	/* read our drive info */
	if (octcf_get_params(wd, &wd->sc_params) != 0) {
		printf(": IDENTIFY failed\n");
		return;
	}

	for (blank = 0, p = wd->sc_params.atap_model, q = buf, i = 0;
	    i < sizeof(wd->sc_params.atap_model); i++) {
		c = *p++;
		if (c == '\0')
			break;
		if (c != ' ') {
			if (blank) {
				*q++ = ' ';
				blank = 0;
			}
			*q++ = c;
		} else
			blank = 1;
		}
	*q++ = '\0';

	printf(": <%s>\n", buf);
	printf("%s: %d-sector PIO,",
		wd->sc_dev.dv_xname, wd->sc_params.atap_multi & 0xff);

	wd->sc_capacity =
		wd->sc_params.atap_cylinders *
		wd->sc_params.atap_heads *
		wd->sc_params.atap_sectors;
	printf(" CHS, %lluMB, %d cyl, %d head, %d sec, %llu sectors\n",
		wd->sc_capacity / (1048576 / DEV_BSIZE),
		wd->sc_params.atap_cylinders,
		wd->sc_params.atap_heads,
		wd->sc_params.atap_sectors,
		wd->sc_capacity);

	OCTCFDEBUG_PRINT(
		("%s: atap_dmatiming_mimi=%d, atap_dmatiming_recom=%d\n",
		self->dv_xname, wd->sc_params.atap_dmatiming_mimi,
		wd->sc_params.atap_dmatiming_recom), DEBUG_PROBE);

	/*
	 * Initialize disk structures.
	 */
	wd->sc_dk.dk_name = wd->sc_dev.dv_xname;
	bufq_init(&wd->sc_bufq, BUFQ_DEFAULT);

	/* Attach disk. */
	disk_attach(&wd->sc_dev, &wd->sc_dk);
}

int
octcfactivate(struct device *self, int act)
{
	return 0;
}

int
octcfdetach(struct device *self, int flags)
{
	struct octcf_softc *sc = (struct octcf_softc *)self;

	bufq_drain(&sc->sc_bufq);

	disk_gone(octcfopen, self->dv_unit);

	/* Detach disk. */
	bufq_destroy(&sc->sc_bufq);
	disk_detach(&sc->sc_dk);

	return (0);
}

/*
 * Read/write routine for a buffer.  Validates the arguments and schedules the
 * transfer.  Does not wait for the transfer to complete.
 */
void
octcfstrategy(struct buf *bp)
{
	struct octcf_softc *wd;
	int s;

	wd = octcflookup(DISKUNIT(bp->b_dev));
	if (wd == NULL) {
		bp->b_error = ENXIO;
		goto bad;
	}

	OCTCFDEBUG_PRINT(("%s (%s)\n", __func__, wd->sc_dev.dv_xname),
	    DEBUG_XFERS);

	/* If device invalidated (e.g. media change, door open), error. */
	if ((wd->sc_flags & OCTCFF_LOADED) == 0) {
		bp->b_error = EIO;
		goto bad;
	}

	/* Validate the request. */
	if (bounds_check_with_label(bp, wd->sc_dk.dk_label) == -1)
		goto done;

	/* Check that the number of sectors can fit in a byte. */
	if ((bp->b_bcount / wd->sc_dk.dk_label->d_secsize) >= (1 << NBBY)) {
		bp->b_error = EINVAL;
		goto bad;
	}

	/* Queue transfer on drive, activate drive and controller if idle. */
	bufq_queue(&wd->sc_bufq, bp);
	s = splbio();
	octcfstart(wd);
	splx(s);
	device_unref(&wd->sc_dev);
	return;

 bad:
	bp->b_flags |= B_ERROR;
	bp->b_resid = bp->b_bcount;
 done:
	s = splbio();
	biodone(bp);
	splx(s);
	if (wd != NULL)
		device_unref(&wd->sc_dev);
}

/*
 * Queue a drive for I/O.
 */
void
octcfstart(void *arg)
{
	struct octcf_softc *wd = arg;
	struct buf *bp;

	OCTCFDEBUG_PRINT(("%s %s\n", __func__, wd->sc_dev.dv_xname),
	    DEBUG_XFERS);
	while ((bp = bufq_dequeue(&wd->sc_bufq)) != NULL) {
		/* Transfer this buffer now. */
		_octcfstart(wd, bp);
	}
}

void
_octcfstart(struct octcf_softc *wd, struct buf *bp)
{
	struct disklabel *lp;
	u_int64_t secno;
	u_int64_t nsecs;

	lp = wd->sc_dk.dk_label;
	secno = DL_BLKTOSEC(lp, bp->b_blkno) +
	    DL_GETPOFFSET(&lp->d_partitions[DISKPART(bp->b_dev)]);
	nsecs = howmany(bp->b_bcount, lp->d_secsize);
	wd->sc_bp = bp;

	/* Instrumentation. */
	disk_busy(&wd->sc_dk);

	if (bp->b_flags & B_READ)
		bp->b_error = octcf_read_sectors(wd, nsecs, secno, bp->b_data);
	else
		bp->b_error = octcf_write_sectors(wd, nsecs, secno, bp->b_data);

	octcfdone(wd);
}

void
octcfdone(void *arg)
{
	struct octcf_softc *wd = arg;
	struct buf *bp = wd->sc_bp;

	if (bp->b_error == 0)
		bp->b_resid = 0;
	else
		bp->b_flags |= B_ERROR;

	disk_unbusy(&wd->sc_dk, (bp->b_bcount - bp->b_resid),
	    (bp->b_flags & B_READ));
	biodone(bp);
}

int
octcfread(dev_t dev, struct uio *uio, int flags)
{

	OCTCFDEBUG_PRINT(("%s\n", __func__), DEBUG_XFERS);
	return (physio(octcfstrategy, dev, B_READ, minphys, uio));
}

int
octcfwrite(dev_t dev, struct uio *uio, int flags)
{

	OCTCFDEBUG_PRINT(("%s\n", __func__), DEBUG_XFERS);
	return (physio(octcfstrategy, dev, B_WRITE, minphys, uio));
}

int
octcfopen(dev_t dev, int flag, int fmt, struct proc *p)
{
	struct octcf_softc *wd;
	int unit, part;
	int error;

	OCTCFDEBUG_PRINT(("%s\n", __func__), DEBUG_FUNCS);

	unit = DISKUNIT(dev);
	wd = octcflookup(unit);
	if (wd == NULL)
		return ENXIO;

	/*
	 * If this is the first open of this device, add a reference
	 * to the adapter.
	 */
	if ((error = disk_lock(&wd->sc_dk)) != 0)
		goto bad4;

	if (wd->sc_dk.dk_openmask != 0) {
		/*
		 * If any partition is open, but the disk has been invalidated,
		 * disallow further opens.
		 */
		if ((wd->sc_flags & OCTCFF_LOADED) == 0) {
			error = EIO;
			goto bad3;
		}
	} else {
		if ((wd->sc_flags & OCTCFF_LOADED) == 0) {
			wd->sc_flags |= OCTCFF_LOADED;

			/* Load the physical device parameters. */
			octcf_get_params(wd, &wd->sc_params);

			/* Load the partition info if not already loaded. */
			if (octcfgetdisklabel(dev, wd,
			    wd->sc_dk.dk_label, 0) == EIO) {
				error = EIO;
				goto bad;
			}
		}
	}

	part = DISKPART(dev);

	if ((error = disk_openpart(&wd->sc_dk, part, fmt, 1)) != 0)
		goto bad;

	disk_unlock(&wd->sc_dk);
	device_unref(&wd->sc_dev);
	return 0;

bad:
	if (wd->sc_dk.dk_openmask == 0) {
	}

bad3:
	disk_unlock(&wd->sc_dk);
bad4:
	device_unref(&wd->sc_dev);
	return error;
}

int
octcfclose(dev_t dev, int flag, int fmt, struct proc *p)
{
	struct octcf_softc *wd;
	int part = DISKPART(dev);

	wd = octcflookup(DISKUNIT(dev));
	if (wd == NULL)
		return ENXIO;

	OCTCFDEBUG_PRINT(("%s\n", __func__), DEBUG_FUNCS);

	disk_lock_nointr(&wd->sc_dk);

	disk_closepart(&wd->sc_dk, part, fmt);

	disk_unlock(&wd->sc_dk);

	device_unref(&wd->sc_dev);
	return (0);
}

void
octcfgetdefaultlabel(struct octcf_softc *wd, struct disklabel *lp)
{
	OCTCFDEBUG_PRINT(("%s\n", __func__), DEBUG_FUNCS);
	bzero(lp, sizeof(struct disklabel));

	lp->d_secsize = DEV_BSIZE;
	DL_SETDSIZE(lp, wd->sc_capacity);
	lp->d_ntracks = wd->sc_params.atap_heads;
	lp->d_nsectors = wd->sc_params.atap_sectors;
	lp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;
	lp->d_ncylinders = DL_GETDSIZE(lp) / lp->d_secpercyl;
	lp->d_type = DTYPE_ESDI;
	strncpy(lp->d_typename, "ESDI/IDE disk", sizeof lp->d_typename);

	/* XXX - user viscopy() like sd.c */
	strncpy(lp->d_packname, wd->sc_params.atap_model, sizeof lp->d_packname);
	lp->d_flags = 0;
	lp->d_version = 1;

	lp->d_magic = DISKMAGIC;
	lp->d_magic2 = DISKMAGIC;
	lp->d_checksum = dkcksum(lp);
}

/*
 * Fabricate a default disk label, and try to read the correct one.
 */
int
octcfgetdisklabel(dev_t dev, struct octcf_softc *wd, struct disklabel *lp,
    int spoofonly)
{
	int error;

	OCTCFDEBUG_PRINT(("%s\n", __func__), DEBUG_FUNCS);

	octcfgetdefaultlabel(wd, lp);
	error = readdisklabel(DISKLABELDEV(dev), octcfstrategy, lp,
	    spoofonly);
	return (error);
}

int
octcfioctl(dev_t dev, u_long xfer, caddr_t addr, int flag, struct proc *p)
{
	struct octcf_softc *wd;
	struct disklabel *lp;
	int error = 0;

	OCTCFDEBUG_PRINT(("%s\n", __func__), DEBUG_FUNCS);

	wd = octcflookup(DISKUNIT(dev));
	if (wd == NULL)
		return ENXIO;

	if ((wd->sc_flags & OCTCFF_LOADED) == 0) {
		error = EIO;
		goto exit;
	}

	switch (xfer) {
	case DIOCRLDINFO:
		lp = malloc(sizeof(*lp), M_TEMP, M_WAITOK);
		octcfgetdisklabel(dev, wd, lp, 0);
		bcopy(lp, wd->sc_dk.dk_label, sizeof(*lp));
		free(lp, M_TEMP, 0);
		goto exit;

	case DIOCGPDINFO:
		octcfgetdisklabel(dev, wd, (struct disklabel *)addr, 1);
		goto exit;

	case DIOCGDINFO:
		*(struct disklabel *)addr = *(wd->sc_dk.dk_label);
		goto exit;

	case DIOCGPART:
		((struct partinfo *)addr)->disklab = wd->sc_dk.dk_label;
		((struct partinfo *)addr)->part =
		    &wd->sc_dk.dk_label->d_partitions[DISKPART(dev)];
		goto exit;

	case DIOCWDINFO:
	case DIOCSDINFO:
		if ((flag & FWRITE) == 0) {
			error = EBADF;
			goto exit;
		}

		if ((error = disk_lock(&wd->sc_dk)) != 0)
			goto exit;

		error = setdisklabel(wd->sc_dk.dk_label,
		    (struct disklabel *)addr, wd->sc_dk.dk_openmask);
		if (error == 0) {
			if (xfer == DIOCWDINFO)
				error = writedisklabel(DISKLABELDEV(dev),
				    octcfstrategy, wd->sc_dk.dk_label);
		}

		disk_unlock(&wd->sc_dk);
		goto exit;

#ifdef notyet
	case DIOCWFORMAT:
		if ((flag & FWRITE) == 0)
			return EBADF;
		{
		struct format_op *fop;
		struct iovec aiov;
		struct uio auio;

		fop = (struct format_op *)addr;
		aiov.iov_base = fop->df_buf;
		aiov.iov_len = fop->df_count;
		auio.uio_iov = &aiov;
		auio.uio_iovcnt = 1;
		auio.uio_resid = fop->df_count;
		auio.uio_segflg = UIO_USERSPACE;
		auio.uio_offset =
			fop->df_startblk * wd->sc_dk.dk_label->d_secsize;
		auio.uio_procp = p;
		error = physio(wdformat, dev, B_WRITE, minphys, &auio);
		fop->df_count -= auio.uio_resid;
		fop->df_reg[0] = wdc->sc_status;
		fop->df_reg[1] = wdc->sc_error;
		goto exit;
		}
#endif

	default:
		error = ENOTTY;
		goto exit;
	}

#ifdef DIAGNOSTIC
	panic("octcfioctl: impossible");
#endif

 exit:
	device_unref(&wd->sc_dev);
	return (error);
}

#ifdef B_FORMAT
int
wdformat(struct buf *bp)
{
	bp->b_flags |= B_FORMAT;
	return octcfstrategy(bp);
}
#endif

daddr_t
octcfsize(dev_t dev)
{
	struct octcf_softc *wd;
	struct disklabel *lp;
	int part, omask;
	daddr_t size;

	OCTCFDEBUG_PRINT(("%s\n", __func__), DEBUG_FUNCS);

	wd = octcflookup(DISKUNIT(dev));
	if (wd == NULL)
		return (-1);

	part = DISKPART(dev);
	omask = wd->sc_dk.dk_openmask & (1 << part);

	if (omask == 0 && octcfopen(dev, 0, S_IFBLK, NULL) != 0) {
		size = -1;
		goto exit;
	}

	lp = wd->sc_dk.dk_label;
	size = DL_SECTOBLK(lp, DL_GETPSIZE(&lp->d_partitions[part]));
	if (omask == 0 && octcfclose(dev, 0, S_IFBLK, NULL) != 0)
		size = -1;

 exit:
	device_unref(&wd->sc_dev);
	return (size);
}

/*
 * Dump core after a system crash.
 */
int
octcfdump(dev_t dev, daddr_t blkno, caddr_t va, size_t size)
{
	return ENXIO;
}

int
octcf_read_sectors(struct octcf_softc *wd, uint32_t nr_sectors,
	uint32_t start_sector, void *buf)
{
	uint32_t count;
	uint16_t *ptr = (uint16_t*)buf;
	int error;
	uint8_t status;

	while (nr_sectors--) {
		while ((status = (OCTCF_REG_READ(wd, wdr_status)>>8)) & WDCS_BSY)
			DELAY(OCTCFDELAY);
		octcf_command(wd, start_sector++, WDCC_READ);
		error = octcf_wait_busy(wd);
		if (error != 0)
			return (error);

        	volatile uint16_t dummy;
		for (count = 0; count < SECTOR_SIZE; count+=2) {
			uint16_t temp;
			temp = OCTCF_REG_READ(wd, 0x0);
			*ptr++ = swap16(temp);
			if ((count & 0xf) == 0)
				dummy = OCTCF_REG_READ(wd, wdr_status);
		}
	}
	return (0);
}

int
octcf_write_sectors(struct octcf_softc *wd, uint32_t nr_sectors,
	uint32_t start_sector, void *buf)
{
	uint32_t count;
	uint16_t *ptr = (uint16_t*)buf;
	int error;
	uint8_t status;

	while (nr_sectors--) {
		while ((status = (OCTCF_REG_READ(wd, wdr_status)>>8)) & WDCS_BSY)
			DELAY(OCTCFDELAY);
		octcf_command(wd, start_sector++, WDCC_WRITE);
		if((error = octcf_wait_busy(wd)))
			return (error);

	      	volatile uint16_t dummy;
		for (count = 0; count < SECTOR_SIZE; count+=2) {
			uint16_t temp = *ptr++;
			OCTCF_REG_WRITE(wd, 0x0, swap16(temp));
			if ((count & 0xf) == 0)
				dummy = OCTCF_REG_READ(wd, wdr_status);
		}
	}
	return (0);
}

void
octcf_command(struct octcf_softc *wd, uint32_t lba, uint8_t cmd)
{
	OCTCF_REG_WRITE(wd, wdr_seccnt, 1 | ((lba & 0xff) << 8));
	OCTCF_REG_WRITE(wd, wdr_cyl_lo,
		((lba >> 8) & 0xff) | (((lba >> 16) & 0xff) << 8));
	OCTCF_REG_WRITE(wd, wdr_sdh,
		(((lba >> 24) & 0xff) | 0xe0) | (cmd << 8));
}

int
octcf_wait_busy(struct octcf_softc *wd)
{
	uint8_t status;

	status = OCTCF_REG_READ(wd, wdr_status)>>8;
	while ((status & WDCS_BSY) == WDCS_BSY) {
		if ((status & WDCS_DWF) != 0)
			return (EIO);
		DELAY(OCTCFDELAY);
		status = (uint8_t)(OCTCF_REG_READ(wd, wdr_status)>>8);
	}

	if ((status & WDCS_DRQ) == 0)
		return (ENXIO);

	return (0);
}

/* Get the disk's parameters */
int
octcf_get_params(struct octcf_softc *wd, struct ataparams *params)
{
	char *tb;
	int i;
	u_int16_t *p;
	int count;
	uint8_t status;
	int error;

	OCTCFDEBUG_PRINT(("%s\n", __func__), DEBUG_FUNCS);

	tb = malloc(ATAPARAMS_SIZE, M_DEVBUF, M_NOWAIT | M_ZERO);
	if (tb == NULL)
		return CMD_AGAIN;

	while ((status = (OCTCF_REG_READ(wd, wdr_status)>>8)) & WDCS_BSY)
		DELAY(OCTCFDELAY);

	OCTCF_REG_WRITE(wd, wdr_seccnt, 0);
	OCTCF_REG_WRITE(wd, wdr_cyl_lo, 0);
	OCTCF_REG_WRITE(wd, wdr_sdh, 0 | (WDCC_IDENTIFY<<8));

	error = octcf_wait_busy(wd);
	if (error == 0) {
		for (count = 0; count < SECTOR_SIZE; count+=2) {
			uint16_t temp;
			temp = OCTCF_REG_READ(wd, 0x0);

			/* endianess will be swapped below */
			tb[count]   = (temp & 0xff);
			tb[count+1] = (temp & 0xff00)>>8;
		}
	}

	if (error != 0) {
		printf("%s: identify failed: %d\n", __func__, error);
		free(tb, M_DEVBUF, 0);
		return CMD_ERR;
	} else {
		/*
		 * All the fields in the params structure are 16-bit
		 * integers except for the ID strings which are char
		 * strings.  The 16-bit integers are currently in
		 * memory in little-endian, regardless of architecture.
		 * So, they need to be swapped on big-endian architectures
		 * before they are accessed through the ataparams structure.
		 *
		 * The swaps below avoid touching the char strings.
		*/
		swap16_multi((u_int16_t *)tb, 10);
		swap16_multi((u_int16_t *)tb + 20, 3);
		swap16_multi((u_int16_t *)tb + 47, ATAPARAMS_SIZE / 2 - 47);

		/* Read in parameter block. */
		bcopy(tb, params, sizeof(struct ataparams));

		/*
		 * Shuffle string byte order.
		 * ATAPI Mitsumi and NEC drives don't need this.
		 */
		if ((params->atap_config & WDC_CFG_ATAPI_MASK) ==
		    WDC_CFG_ATAPI &&
		    ((params->atap_model[0] == 'N' &&
			params->atap_model[1] == 'E') ||
		     (params->atap_model[0] == 'F' &&
			 params->atap_model[1] == 'X'))) {
			free(tb, M_DEVBUF, 0);
			return CMD_OK;
		}
		for (i = 0; i < sizeof(params->atap_model); i += 2) {
			p = (u_short *)(params->atap_model + i);
			*p = swap16(*p);
		}
		for (i = 0; i < sizeof(params->atap_serial); i += 2) {
			p = (u_short *)(params->atap_serial + i);
			*p = swap16(*p);
		}
		for (i = 0; i < sizeof(params->atap_revision); i += 2) {
			p = (u_short *)(params->atap_revision + i);
			*p = swap16(*p);
		}

		free(tb, M_DEVBUF, 0);
		return CMD_OK;
	}
}
@


1.27
log
@it's unlikely we'll run on physical octeon hardware that's little endian;
therefore remove unneeded ifdef blocks.

ok miod@@ pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: octcf.c,v 1.26 2015/07/19 23:46:50 jasper Exp $ */
d619 1
a619 1
		auio.uio_segflg = 0;
@


1.26
log
@rework how iobus(4) finds and attaches devices.

this allows us to get rid of the static list of children devices, using only
a lookup table for address hints where needed. as a bonus this removes the
'octcf0: [..] not configured' mesage on machines w/o octcf(4).

tested by pirofti@@ on DSR-500 and ERL by me
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: octcf.c,v 1.25 2014/08/11 19:00:50 miod Exp $ */
a820 1
#if BYTE_ORDER == BIG_ENDIAN
d834 1
a834 1
#endif
@


1.25
log
@Do not extern octeon_boot_info, <machine/octeonvar.h> declares it for you.
@
text
@d1 1
a1 1
/*	$OpenBSD: octcf.c,v 1.24 2014/07/23 10:06:18 jasper Exp $ */
d183 1
a183 1
	if (bus_space_map(wd->sc_iot, aa->aa_unit->addr,
@


1.24
log
@correctly drain and destroy the bufq upon detach

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: octcf.c,v 1.23 2014/07/22 17:26:03 jasper Exp $ */
a162 2
	extern struct boot_info *octeon_boot_info;

@


1.23
log
@- remove unneeded header
- move a declaration before code
- sync with wd.c -r1.101 from may 2011 and pass dk_openmask to setdisklabel
@
text
@d1 1
a1 1
/*	$OpenBSD: octcf.c,v 1.22 2014/07/22 14:52:35 jasper Exp $ */
d277 2
d282 1
@


1.22
log
@better warning for 8bit cards
@
text
@d1 1
a1 1
/*	$OpenBSD: octcf.c,v 1.21 2014/07/22 14:49:49 jasper Exp $ */
a75 2
#include <uvm/uvm_extern.h>

d180 1
a181 1
	uint8_t status;
d593 1
a593 1
		    (struct disklabel *)addr, /*wd->sc_dk.dk_openmask : */0);
@


1.21
log
@- use DL_SECTOBLK() instead of handrolling the same functionality
- octcfsize() returns daddr_t, so calculate the return value in a daddr_t
@
text
@d1 1
a1 1
/*	$OpenBSD: octcf.c,v 1.20 2014/07/22 14:45:34 jasper Exp $ */
d201 1
a201 1
				printf(": Doesn't support 8bit card\n");
d461 1
@


1.20
log
@Switch to MI functions disk_{gone,openpart,closepart} instead of handrolling
the same functionality.
@
text
@d1 1
a1 1
/*	$OpenBSD: octcf.c,v 1.19 2014/07/21 21:07:34 jasper Exp $ */
a368 1

d658 1
d660 1
a660 1
	int64_t size;
d676 2
a677 2
	size = DL_GETPSIZE(&wd->sc_dk.dk_label->d_partitions[part]) *
	    (wd->sc_dk.dk_label->d_secsize / DEV_BSIZE);
@


1.19
log
@- whitespace cleanups (trailing whitespace, indentation)
- minor code shuffling and rename a variable to reduce diff with wd.c

no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: octcf.c,v 1.18 2014/07/12 21:47:04 pirofti Exp $ */
a277 1
	int bmaj, cmaj, mn;
d279 1
a279 9
	/* Locate the lowest minor number to be detached. */
	mn = DISKMINOR(self->dv_unit, 0);

	for (bmaj = 0; bmaj < nblkdev; bmaj++)
		if (bdevsw[bmaj].d_open == octcfopen)
			vdevgone(bmaj, mn, mn + MAXPARTITIONS - 1, VBLK);
	for (cmaj = 0; cmaj < nchrdev; cmaj++)
		if (cdevsw[cmaj].d_open == octcfopen)
			vdevgone(cmaj, mn, mn + MAXPARTITIONS - 1, VCHR);
d462 1
a462 6

	/* Check that the partition exists. */
	if (part != RAW_PART &&
	    (part >= wd->sc_dk.dk_label->d_npartitions ||
	     wd->sc_dk.dk_label->d_partitions[part].p_fstype == FS_UNUSED)) {
		error = ENXIO;
a463 13
	}

	/* Insure only one open at a time. */
	switch (fmt) {
	case S_IFCHR:
		wd->sc_dk.dk_copenmask |= (1 << part);
		break;
	case S_IFBLK:
		wd->sc_dk.dk_bopenmask |= (1 << part);
		break;
	}
	wd->sc_dk.dk_openmask =
	    wd->sc_dk.dk_copenmask | wd->sc_dk.dk_bopenmask;
d494 1
a494 10
	switch (fmt) {
	case S_IFCHR:
		wd->sc_dk.dk_copenmask &= ~(1 << part);
		break;
	case S_IFBLK:
		wd->sc_dk.dk_bopenmask &= ~(1 << part);
		break;
	}
	wd->sc_dk.dk_openmask =
	    wd->sc_dk.dk_copenmask | wd->sc_dk.dk_bopenmask;
@


1.18
log
@Fix the last commit by proper dereferencing the disklabel partition.

Found by me, fixed by krw@@. Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: octcf.c,v 1.17 2014/07/12 20:38:27 krw Exp $ */
d194 1
a194 1
		uint64_t cfg = 
d239 1
a239 1
	printf("%s: %d-sector PIO,", 
d311 1
d314 1
d331 1
a331 1
	/* Queue the I/O */
a332 2

	/* Queue transfer on drive, activate drive and controller if idle. */
d435 1
a435 1
	if (wd == NULL) 
d442 1
a442 1
	if ((error = disk_lock(&wd->sc_dk)) != 0) 
d550 1
a550 1
 lp->d_type = DTYPE_ESDI;
a685 1

d731 2
a732 2
int 
octcf_read_sectors(struct octcf_softc *wd, uint32_t nr_sectors, 
d761 1
a761 1
octcf_write_sectors(struct octcf_softc *wd, uint32_t nr_sectors, 
d791 1
a791 1
	OCTCF_REG_WRITE(wd, wdr_cyl_lo, 
d793 1
a793 1
	OCTCF_REG_WRITE(wd, wdr_sdh, 
d797 1
a797 1
int 
d802 1
a802 1
	status = OCTCF_REG_READ(wd, wdr_status)>>8;	
d810 1
a810 1
	if ((status & WDCS_DRQ) == 0) 
d818 1
a818 1
octcf_get_params(struct octcf_softc *wd, struct ataparams *prms)
d858 9
a866 8
		/* All the fields in the params structure are 16-bit
		   integers except for the ID strings which are char
		   strings.  The 16-bit integers are currently in
		   memory in little-endian, regardless of architecture.
		   So, they need to be swapped on big-endian architectures
		   before they are accessed through the ataparams structure.

		   The swaps below avoid touching the char strings.
a867 1

d873 1
a873 1
		bcopy(tb, prms, sizeof(struct ataparams));
d879 1
a879 1
		if ((prms->atap_config & WDC_CFG_ATAPI_MASK) ==
d881 4
a884 4
		    ((prms->atap_model[0] == 'N' &&
			prms->atap_model[1] == 'E') ||
		     (prms->atap_model[0] == 'F' &&
			 prms->atap_model[1] == 'X'))) {
d888 2
a889 2
		for (i = 0; i < sizeof(prms->atap_model); i += 2) {
			p = (u_short *)(prms->atap_model + i);
d892 2
a893 2
		for (i = 0; i < sizeof(prms->atap_serial); i += 2) {
			p = (u_short *)(prms->atap_serial + i);
d896 2
a897 2
		for (i = 0; i < sizeof(prms->atap_revision); i += 2) {
			p = (u_short *)(prms->atap_revision + i);
@


1.17
log
@Oops. Correct variable name more likely to compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: octcf.c,v 1.16 2014/07/12 20:36:45 krw Exp $ */
d376 1
a376 1
	    DL_GETPOFFSET(lp->d_partitions[DISKPART(bp->b_dev)]);
@


1.16
log
@Calculate i/o starts and sizes in 'proper' sectors rather assuming
512-byte sectors. Unlikely to affect CF's in the near future.

ok pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: octcf.c,v 1.15 2014/07/12 18:44:42 tedu Exp $ */
d377 1
a377 1
	nblks = howmany(bp->b_bcount, lp->d_secsize);
@


1.15
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: octcf.c,v 1.14 2014/05/10 22:25:16 jasper Exp $ */
d370 8
a377 7
	uint32_t blkno;
	uint32_t nblks;

	blkno = bp->b_blkno +
	    DL_GETPOFFSET(&wd->sc_dk.dk_label->d_partitions[DISKPART(bp->b_dev)]);
	blkno /= (SECTOR_SIZE / DEV_BSIZE);
	nblks = bp->b_bcount / SECTOR_SIZE;
d385 1
a385 1
		bp->b_error = octcf_read_sectors(wd, nblks, blkno, bp->b_data);
d387 1
a387 1
		bp->b_error = octcf_write_sectors(wd, nblks, blkno, bp->b_data);
@


1.14
log
@various format string fixes and remove -Wno-format from octeon

feedback/ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: octcf.c,v 1.13 2013/11/01 01:06:03 dlg Exp $ */
d602 1
a602 1
		free(lp, M_TEMP);
d854 1
a854 1
		free(tb, M_DEVBUF);
d885 1
a885 1
			free(tb, M_DEVBUF);
d901 1
a901 1
		free(tb, M_DEVBUF);
@


1.13
log
@replace bare use of disksort with bufqs.

tweaks and ok jmatthew@@ testing and ok bcallah@@
@
text
@d1 1
a1 1
/*	$OpenBSD: octcf.c,v 1.12 2013/06/11 16:42:10 deraadt Exp $ */
d201 1
a201 2
				printf(": Doesn't support 8bit card\n",
					wd->sc_dev.dv_xname);
d210 1
a210 1
			printf(": card not present\n", wd->sc_dev.dv_xname);
d218 1
a218 1
		printf(": IDENTIFY failed\n", wd->sc_dev.dv_xname);
@


1.12
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: octcf.c,v 1.11 2013/06/02 20:29:36 jasper Exp $ */
d114 1
a114 1
	struct buf sc_q;
d263 1
d330 3
a334 1
	disksort(&wd->sc_q, bp);
d358 1
a358 1
	struct buf *dp, *bp;
d362 1
a362 8
	while (1) {
		/* Remove the next buffer from the queue or stop. */
		dp = &wd->sc_q;
		bp = dp->b_actf;
		if (bp == NULL)
			return;
		dp->b_actf = bp->b_actf;

@


1.11
log
@move octeonreg.h to a more generic location and add multiple inclusion
guards while here.

ok uebayasi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: octcf.c,v 1.10 2013/03/19 16:37:12 jasper Exp $ */
d696 1
a696 1
daddr64_t
d731 1
a731 1
octcfdump(dev_t dev, daddr64_t blkno, caddr_t va, size_t size)
@


1.10
log
@use __func__ to print the function name, fixes a bunch of pastos along the way.
@
text
@d1 1
a1 1
/*	$OpenBSD: octcf.c,v 1.9 2013/03/19 09:17:52 jasper Exp $ */
d87 1
a87 1
#include <octeon/dev/octeonreg.h>
@


1.9
log
@instead of treating boot_info->cf_common_addr special, save the whole of boot_info
for future use.

ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: octcf.c,v 1.8 2013/03/15 09:18:19 jasper Exp $ */
d168 1
a168 1
		OCTCFDEBUG_PRINT(("octcfprobe: No cf bus found\n"), DEBUG_FUNCS | DEBUG_PROBE);
d182 1
a182 1
	OCTCFDEBUG_PRINT(("octcfattach\n"), DEBUG_FUNCS | DEBUG_PROBE);
d311 1
a311 1
	OCTCFDEBUG_PRINT(("octcfstrategy (%s)\n", wd->sc_dev.dv_xname),
d357 1
a357 1
	OCTCFDEBUG_PRINT(("octcfstart %s\n", wd->sc_dev.dv_xname),
d416 1
a416 1
	OCTCFDEBUG_PRINT(("wdread\n"), DEBUG_XFERS);
d424 1
a424 1
	OCTCFDEBUG_PRINT(("octcfwrite\n"), DEBUG_XFERS);
d435 1
a435 1
	OCTCFDEBUG_PRINT(("octcfopen\n"), DEBUG_FUNCS);
d521 1
a521 1
	OCTCFDEBUG_PRINT(("octcfclose\n"), DEBUG_FUNCS);
d545 1
a545 1
	OCTCFDEBUG_PRINT(("octcfgetdefaultlabel\n"), DEBUG_FUNCS);
d576 1
a576 1
	OCTCFDEBUG_PRINT(("octcfgetdisklabel\n"), DEBUG_FUNCS);
d591 1
a591 1
	OCTCFDEBUG_PRINT(("octcfioctl\n"), DEBUG_FUNCS);
d703 1
a703 1
	OCTCFDEBUG_PRINT(("wdsize\n"), DEBUG_FUNCS);
d832 1
a832 1
	OCTCFDEBUG_PRINT(("octcf_get_parms\n"), DEBUG_FUNCS);
@


1.8
log
@save a copy of the address at which the CF bus can be found, and use this in octcf(4) for
a better probe function which doesn't unconditionally tries to attach octcf(4). this would
cause endless faults on the EdgeRouter Lite as it lacks a CF bus.

feedback and testing bcallah@@ and chris@@
ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: octcf.c,v 1.7 2011/07/06 04:49:35 matthew Exp $ */
d165 1
a165 1
	extern uint64_t cf_found;
d167 1
a167 1
	if (cf_found == 0) {
@


1.7
log
@Eliminate redundant buf validation checks in xxstrategy() methods now
that they're implemented consistently in bounds_check_with_label().

Also, per krw's request, change bounds_check_with_label() to return 0
if the checks succeed, and change the drivers to test == -1 instead of
<= 0.  (Man page update to follow; intentionally omitting
arch/vax/mba/hp.c from this commit because it doesn't even build
currently and miod@@ promises to kill it soon.)

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: octcf.c,v 1.6 2011/06/19 04:55:34 deraadt Exp $ */
d88 1
d163 1
a163 1
octcfprobe(struct device *parent, void *match_, void *aux)
d165 7
@


1.6
log
@Use disk_lock_nointr() in the xxclose() routines so that they cannot
be interrupted.
ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: octcf.c,v 1.5 2011/06/19 04:35:06 deraadt Exp $ */
a304 7
	/* Valid request?  */
	if (bp->b_blkno < 0 ||
	    (bp->b_bcount % wd->sc_dk.dk_label->d_secsize) != 0 ||
	    (bp->b_bcount / wd->sc_dk.dk_label->d_secsize) >= (1 << NBBY)) {
		bp->b_error = EINVAL;
		goto bad;
	}
d310 3
a312 8
	/* If it's a null transfer, return immediately. */
	if (bp->b_bcount == 0)
		goto done;
	/*
	 * Do bounds checking, adjust transfer. if error, process.
	 * If end of partition, just return.
	 */
	if (bounds_check_with_label(bp, wd->sc_dk.dk_label) <= 0)
d314 7
d328 2
a329 1
bad:
a330 2
done:
	/* Toss transfer; we're done early. */
d332 1
@


1.5
log
@Use disk_lock/disk_unlock directly and in the same way in these drivers,
rather than using various wrappings.  Convert vnd to using the sc_dk
rwlock instead of using one of its own.
ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: octcf.c,v 1.4 2011/06/05 18:40:33 matthew Exp $ */
a512 1
	int error = 0;
d519 2
a520 2
	if ((error = disk_lock(&wd->sc_dk)) != 0)
		goto exit;
a534 1
 exit:
d536 1
a536 1
	return (error);
@


1.4
log
@Drop kernel support for the useless DIOCWLABEL ioctl and prune a lot
of silly flag twiddling code in various disk drivers.

ok deraadt@@, miod@@

N.B., users will need a -current disklabel(8) to be able to write new
disklabels to disk now.
@
text
@d1 1
a1 1
/*	$OpenBSD: octcf.c,v 1.3 2011/06/03 21:14:11 matthew Exp $ */
a147 3
#define octcflock(wd)  disk_lock(&(wd)->sc_dk)
#define octcfunlock(wd)  disk_unlock(&(wd)->sc_dk)

d443 1
a443 1
	if ((error = octcflock(wd)) != 0) 
d493 1
a493 1
	octcfunlock(wd);
d502 1
a502 1
	octcfunlock(wd);
d520 1
a520 1
	if ((error = octcflock(wd)) != 0)
d534 1
a534 1
	octcfunlock(wd);
d630 1
a630 1
		if ((error = octcflock(wd)) != 0)
d641 1
a641 1
		octcfunlock(wd);
@


1.3
log
@Get rid of the wlabel argument to bounds_check_with_label().  It's
never done anything in OpenBSD and just clutters disk drivers with
silly flag handling.

More cleanup to follow.

ok deraadt@@, millert@@; no objections krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: octcf.c,v 1.2 2011/05/08 13:24:55 syuu Exp $ */
a116 2
#define OCTCFF_WLABEL		0x04 /* label is writable */
#define OCTCFF_LABELLING	0x08 /* writing label */
a634 1
		wd->sc_flags |= OCTCFF_LABELLING;
a643 1
		wd->sc_flags &= ~OCTCFF_LABELLING;
a644 12
		goto exit;

	case DIOCWLABEL:
		if ((flag & FWRITE) == 0) {
			error = EBADF;
			goto exit;
		}

		if (*(int *)addr)
			wd->sc_flags |= OCTCFF_WLABEL;
		else
			wd->sc_flags &= ~OCTCFF_WLABEL;
@


1.2
log
@obio renamed iobus, moved interrupt handler code to dev/octeon_intr.c
@
text
@d1 1
a1 1
/*	$OpenBSD: octcf.c,v 1.1 2010/10/26 00:02:01 syuu Exp $ */
d329 1
a329 2
	if (bounds_check_with_label(bp, wd->sc_dk.dk_label,
	    (wd->sc_flags & (OCTCFF_WLABEL|OCTCFF_LABELLING)) != 0) <= 0)
@


1.1
log
@Replace broken CF driver with new one, fixed bus_space base address.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.95 2010/09/22 01:18:57 matthew Exp $ */
d86 1
a86 1
#include <octeon/dev/obiovar.h>
d176 1
a176 1
	struct obio_attach_args *oba = aux;
d182 1
a182 1
	wd->sc_iot = oba->oba_memt;
d184 1
a184 1
	if (bus_space_map(wd->sc_iot, oba->oba_baseaddr,
@

