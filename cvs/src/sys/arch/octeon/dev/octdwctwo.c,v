head	1.11;
access;
symbols
	OPENBSD_6_0:1.10.0.2
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.4.0.2
	OPENBSD_5_7_BASE:1.4;
locks; strict;
comment	@ * @;


1.11
date	2017.02.15.14.44.20;	author visa;	state Exp;
branches;
next	1.10;
commitid	YJl3z6vFo1gxVvSh;

1.10
date	2016.03.19.17.17.06;	author visa;	state Exp;
branches;
next	1.9;
commitid	RQtbK9vqoeM7uvRh;

1.9
date	2015.09.01.14.45.24;	author visa;	state Exp;
branches;
next	1.8;
commitid	BAcsUlOZ2miHmZPu;

1.8
date	2015.07.19.00.33.36;	author jasper;	state Exp;
branches;
next	1.7;
commitid	piCxYmwiZDaCchLC;

1.7
date	2015.07.03.16.33.07;	author miod;	state Exp;
branches;
next	1.6;
commitid	LvFxswdRiTPfqdZ4;

1.6
date	2015.04.26.12.24.03;	author jmatthew;	state Exp;
branches;
next	1.5;
commitid	0O8FBo5KrJC7I7mb;

1.5
date	2015.03.19.10.44.21;	author mpi;	state Exp;
branches;
next	1.4;
commitid	NUxJNoRx5n9I3ItV;

1.4
date	2015.02.14.06.46.03;	author uebayasi;	state Exp;
branches;
next	1.3;
commitid	k6nFzY4FH9jEfXf0;

1.3
date	2015.02.12.11.49.13;	author uebayasi;	state Exp;
branches;
next	1.2;
commitid	MyC36J2AIK7uZ9lz;

1.2
date	2015.02.12.00.23.58;	author uebayasi;	state Exp;
branches;
next	1.1;
commitid	cQ8sBsRzsjd6g5fT;

1.1
date	2015.02.11.00.15.41;	author uebayasi;	state Exp;
branches;
next	;
commitid	wPaMk1TOUMG2AZZI;


desc
@@


1.11
log
@Mark dwc2_intr() as MP-safe on octeon. The driver's internal state
is protected by a mutex.

OK stsp@@ jmatthew@@
@
text
@/*	$OpenBSD: octdwctwo.c,v 1.10 2016/03/19 17:17:06 visa Exp $	*/

/*
 * Copyright (c) 2015 Masao Uebayashi <uebayasi@@tombiinc.com>
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>

#include <machine/intr.h>
#include <machine/bus.h>
#include <machine/octeonreg.h>
#include <machine/octeonvar.h>
#include <machine/octeon_model.h>

#include <octeon/dev/iobusvar.h>
#include <octeon/dev/octhcireg.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdivar.h>

#include <dev/usb/dwc2/dwc2var.h>
#include <dev/usb/dwc2/dwc2.h>
#include <dev/usb/dwc2/dwc2_core.h>

struct octdwctwo_softc {
	struct dwc2_softc	sc_dwc2;

	/* USBN bus space */
	bus_space_tag_t		sc_bust;
	bus_space_handle_t	sc_regh;
	bus_space_handle_t	sc_regh2;

	void			*sc_ih;
};

int			octdwctwo_match(struct device *, void *, void *);
void			octdwctwo_attach(struct device *, struct device *,
			    void *);
int			octdwctwo_set_dma_addr(void *, dma_addr_t, int);
u_int64_t		octdwctwo_reg2_rd(struct octdwctwo_softc *, bus_size_t);
void			octdwctwo_reg2_wr(struct octdwctwo_softc *, bus_size_t,
			    u_int64_t);
void			octdwctwo_reg_set(struct octdwctwo_softc *, bus_size_t,
			    u_int64_t);
void			octdwctwo_reg_clear(struct octdwctwo_softc *,
			    bus_size_t, u_int64_t);
u_int32_t		octdwctwo_read_4(bus_space_tag_t, bus_space_handle_t,
			    bus_size_t);
void			octdwctwo_write_4(bus_space_tag_t, bus_space_handle_t,
			    bus_size_t, u_int32_t);


const struct cfattach octdwctwo_ca = {
	sizeof(struct octdwctwo_softc), octdwctwo_match, octdwctwo_attach,
};

struct cfdriver dwctwo_cd = {
	NULL, "dwctwo", DV_DULL
};

static struct dwc2_core_params octdwctwo_params = {
	.otg_cap = 2,
	.otg_ver = 0,
	.dma_enable = 1,
	.dma_desc_enable = 0,
	.speed = 0,
	.enable_dynamic_fifo = 1,
	.en_multiple_tx_fifo = 0,
	.host_rx_fifo_size = 456,
	.host_nperio_tx_fifo_size = 912,
	.host_perio_tx_fifo_size = 256,
	.max_transfer_size = 65535,
	.max_packet_count = 511,
	.host_channels = 8,
	.phy_type = 1,
	.phy_utmi_width = 16,
	.phy_ulpi_ddr = 0,
	.phy_ulpi_ext_vbus = 0,
	.i2c_enable = 0,
	.ulpi_fs_ls = 0,
	.host_support_fs_ls_low_power = 0,
	.host_ls_low_power_phy_clk = 0,
	.ts_dline = 0,
	.reload_ctl = 0,
	.ahbcfg = 0x7,
	.uframe_sched = 1,
};

static struct dwc2_core_dma_config octdwctwo_dma_config = {
	.set_dma_addr = octdwctwo_set_dma_addr,
};

/*
 * This bus space tag adjusts register addresses to account for
 * dwc2 using little endian addressing.  dwc2 only does 32bit reads
 * and writes, so only those functions are provided.
 */
bus_space_t octdwctwo_tag = {
	.bus_base = PHYS_TO_XKPHYS(0, CCA_NC),
	.bus_private = NULL,
	._space_read_4 =	octdwctwo_read_4,
	._space_write_4 =	octdwctwo_write_4,
	._space_map =		iobus_space_map,
	._space_unmap =		iobus_space_unmap,
	._space_subregion =	generic_space_region,
	._space_vaddr =		generic_space_vaddr
};

int
octdwctwo_match(struct device *parent, void *match, void *aux)
{
	int id;

	id = octeon_get_chipid();
	switch (octeon_model_family(id)) {
	case OCTEON_MODEL_FAMILY_CN30XX:
	case OCTEON_MODEL_FAMILY_CN31XX:
	case OCTEON_MODEL_FAMILY_CN50XX:
		return (1);
	default:
		return (0);
	}
}

void
octdwctwo_attach(struct device *parent, struct device *self, void *aux)
{
	struct octdwctwo_softc *sc = (struct octdwctwo_softc *)self;
	struct iobus_attach_args *aa = aux;
	uint64_t clk;
	int rc;

	sc->sc_dwc2.sc_iot = &octdwctwo_tag;
	sc->sc_dwc2.sc_bus.pipe_size = sizeof(struct usbd_pipe);
	sc->sc_dwc2.sc_bus.dmatag = aa->aa_dmat;
	sc->sc_dwc2.sc_params = &octdwctwo_params;

	rc = bus_space_map(sc->sc_dwc2.sc_iot, USBC_BASE, USBC_SIZE,
	    0, &sc->sc_dwc2.sc_ioh);
	KASSERT(rc == 0);

	sc->sc_bust = aa->aa_bust;
	rc = bus_space_map(sc->sc_bust, USBN_BASE, USBN_SIZE,
	    0, &sc->sc_regh);
	KASSERT(rc == 0);
	rc = bus_space_map(sc->sc_bust, USBN_2_BASE, USBN_2_SIZE,
	    0, &sc->sc_regh2);
	KASSERT(rc == 0);

	/*
	 * Clock setup.
	 */
	clk = bus_space_read_8(sc->sc_bust, sc->sc_regh, USBN_CLK_CTL_OFFSET);
	clk |= USBN_CLK_CTL_POR;
	clk &= ~(USBN_CLK_CTL_HRST | USBN_CLK_CTL_PRST | USBN_CLK_CTL_HCLK_RST |
	    USBN_CLK_CTL_ENABLE | USBN_CLK_CTL_P_C_SEL | USBN_CLK_CTL_P_RTYPE);
	clk |= SET_USBN_CLK_CTL_DIVIDE(0x4ULL)
	    | SET_USBN_CLK_CTL_DIVIDE2(0x0ULL);

	bus_space_write_8(sc->sc_bust, sc->sc_regh, USBN_CLK_CTL_OFFSET, clk);
	bus_space_read_8(sc->sc_bust, sc->sc_regh, USBN_CLK_CTL_OFFSET);

	/*
	 * Reset HCLK and wait for it to stabilize.
	 */
	octdwctwo_reg_set(sc, USBN_CLK_CTL_OFFSET, USBN_CLK_CTL_HCLK_RST);
	delay(64);

	octdwctwo_reg_clear(sc, USBN_CLK_CTL_OFFSET, USBN_CLK_CTL_POR);

	/*
	 * Wait for the PHY clock to start.
	 */
	delay(1000);

	octdwctwo_reg_set(sc, USBN_USBP_CTL_STATUS_OFFSET,
	    USBN_USBP_CTL_STATUS_ATE_RESET);
	delay(10);

	octdwctwo_reg_clear(sc, USBN_USBP_CTL_STATUS_OFFSET,
			USBN_USBP_CTL_STATUS_ATE_RESET);
	octdwctwo_reg_set(sc, USBN_CLK_CTL_OFFSET, USBN_CLK_CTL_PRST);

	/*
	 * Select host mode.
	 */
	octdwctwo_reg_clear(sc, USBN_USBP_CTL_STATUS_OFFSET,
	    USBN_USBP_CTL_STATUS_HST_MODE);
	delay(1);

	octdwctwo_reg_set(sc, USBN_CLK_CTL_OFFSET, USBN_CLK_CTL_HRST);

	/*
	 * Enable clock.
	 */
	octdwctwo_reg_set(sc, USBN_CLK_CTL_OFFSET, USBN_CLK_CTL_ENABLE);
	delay(1);

	strlcpy(sc->sc_dwc2.sc_vendor, "Octeon", sizeof(sc->sc_dwc2.sc_vendor));

	rc = dwc2_init(&sc->sc_dwc2);
	if (rc != 0)
		return;
	octdwctwo_dma_config.set_dma_addr_data = sc;
	rc = dwc2_dma_config(&sc->sc_dwc2, &octdwctwo_dma_config);
	if (rc != 0)
		return;

	printf("\n");

	sc->sc_dwc2.sc_child = config_found(&sc->sc_dwc2.sc_bus.bdev,
	    &sc->sc_dwc2.sc_bus, usbctlprint);

	sc->sc_ih = octeon_intr_establish(CIU_INT_USB, IPL_USB | IPL_MPSAFE,
	    dwc2_intr, (void *)&sc->sc_dwc2, sc->sc_dwc2.sc_bus.bdev.dv_xname);
	KASSERT(sc->sc_ih != NULL);
}

int
octdwctwo_set_dma_addr(void *data, dma_addr_t dma_addr, int ch)
{
	struct octdwctwo_softc *sc = data;

	octdwctwo_reg2_wr(sc,
	    USBN_DMA0_INB_CHN0_OFFSET + ch * 0x8, dma_addr);
	octdwctwo_reg2_wr(sc,
	    USBN_DMA0_OUTB_CHN0_OFFSET + ch * 0x8, dma_addr);
	return 0;
}

u_int64_t
octdwctwo_reg2_rd(struct octdwctwo_softc *sc, bus_size_t offset)
{
	u_int64_t value;

	value = bus_space_read_8(sc->sc_bust, sc->sc_regh2, offset);
	return value;
}

void
octdwctwo_reg2_wr(struct octdwctwo_softc *sc, bus_size_t offset, u_int64_t value)
{
	bus_space_write_8(sc->sc_bust, sc->sc_regh2, offset, value);
	/* guarantee completion of the store operation on RSL registers*/
	bus_space_read_8(sc->sc_bust, sc->sc_regh2, offset);
}

void
octdwctwo_reg_set(struct octdwctwo_softc *sc, bus_size_t offset,
    u_int64_t bits)
{
	u_int64_t value;
	value = bus_space_read_8(sc->sc_bust, sc->sc_regh, offset);
	value |= bits;

	bus_space_write_8(sc->sc_bust, sc->sc_regh, offset, value);
	bus_space_read_8(sc->sc_bust, sc->sc_regh, offset);
}

void
octdwctwo_reg_clear(struct octdwctwo_softc *sc, bus_size_t offset,
    u_int64_t bits)
{
	u_int64_t value;
	value = bus_space_read_8(sc->sc_bust, sc->sc_regh, offset);
	value &= ~bits;

	bus_space_write_8(sc->sc_bust, sc->sc_regh, offset, value);
	bus_space_read_8(sc->sc_bust, sc->sc_regh, offset);
}

u_int32_t
octdwctwo_read_4(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o)
{
	return *(volatile u_int32_t *)(h + (o^4));
}

void
octdwctwo_write_4(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
    u_int32_t v)
{
	*(volatile u_int32_t *)(h + (o^4)) = v;
}
@


1.10
log
@Attach dwctwo(4) only on Octeon models that have a DWC2 controller.

OK uebayasi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: octdwctwo.c,v 1.9 2015/09/01 14:45:24 visa Exp $	*/
d229 2
a230 2
	sc->sc_ih = octeon_intr_establish(CIU_INT_USB, IPL_USB, dwc2_intr,
	    (void *)&sc->sc_dwc2, sc->sc_dwc2.sc_bus.bdev.dv_xname);
@


1.9
log
@Increase transfer FIFOs for dwc2, to improve USB performance. The new
values are from dwc2 of NetBSD.

ok jmatthew@@, jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: octdwctwo.c,v 1.8 2015/07/19 00:33:36 jasper Exp $	*/
d27 1
d127 11
a137 1
	return (1);
@


1.8
log
@set usb vendor string to 'Octeon' instead of ''

ok pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: octdwctwo.c,v 1.7 2015/07/03 16:33:07 miod Exp $	*/
d83 3
a85 3
	.host_rx_fifo_size = 256/*XXX*/,
	.host_nperio_tx_fifo_size = 128/*XXX*/,
	.host_perio_tx_fifo_size = 128/*XXX*/,
@


1.7
log
@Put the newline at the right place.
@
text
@d1 1
a1 1
/*	$OpenBSD: octdwctwo.c,v 1.6 2015/04/26 12:24:03 jmatthew Exp $	*/
d202 2
@


1.6
log
@Get dwc2 working on octeon.
- transplant the clock setup code from octhci
- add a bus space tag to deal with dwc2 using little endian addressing
- bump up the rx fifo size, necessary for umass/sd to work

tested on an edgerouter lite, which can almost boot by itself now
ok uebayasi@@ (various parts), miod@@ (bus space bits)
@
text
@d1 1
a1 1
/*	$OpenBSD: octdwctwo.c,v 1.5 2015/03/19 10:44:21 mpi Exp $	*/
d210 3
a218 2

	printf("\n");
@


1.5
log
@Let it compile!
@
text
@d1 1
a1 1
/*	$OpenBSD: octdwctwo.c,v 1.4 2015/02/14 06:46:03 uebayasi Exp $	*/
d57 9
d83 1
a83 1
	.host_rx_fifo_size = 128/*XXX*/,
d107 16
d134 1
d137 1
a137 1
	sc->sc_dwc2.sc_iot = aa->aa_bust;
d142 1
a142 1
	rc = bus_space_map(aa->aa_bust, USBC_BASE, USBC_SIZE,
d154 49
d247 37
@


1.4
log
@Don't defer initialization.  config_defer(9) doesn't defer things as
deferred as interrupt starts working.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a21 2
#include <sys/malloc.h>
#include <sys/pool.h>
d28 3
a33 9
#include <dev/usb/usb_mem.h>
#include <dev/usb/usb_quirks.h>

#include <octeon/dev/usb_port.h>
#include <octeon/dev/iobusvar.h>
#include <octeon/dev/cn30xxusbnvar.h>
#include <octeon/dev/cn30xxusbcvar.h>
#include <octeon/dev/cn30xxusbnreg.h>
#include <octeon/dev/cn30xxusbcreg.h>
@


1.3
log
@Set external DMA address configuration interface.
@
text
@a60 1
void			octdwctwo_attach_deferred(struct device *);
d136 10
a150 19

	config_defer(self, octdwctwo_attach_deferred);
}

void
octdwctwo_attach_deferred(struct device *self)
{
	struct octdwctwo_softc *sc = (struct octdwctwo_softc *)self;
	int error;

	error = dwc2_init(&sc->sc_dwc2);
	if (error != 0)
		return;
	octdwctwo_dma_config.set_dma_addr_data = sc;
	error = dwc2_dma_config(&sc->sc_dwc2, &octdwctwo_dma_config);
	if (error != 0)
		return;
	sc->sc_dwc2.sc_child = config_found(&sc->sc_dwc2.sc_bus.bdev,
	    &sc->sc_dwc2.sc_bus, usbctlprint);
@


1.2
log
@- Use config_defer() to call actual attachment.
- Set parameters passed to dwc2.
@
text
@d49 1
a49 1
#if 0
d53 2
a54 1
#endif
d62 4
d103 4
a128 1
#if 0
d130 1
a130 1
	rc = bus_space_map(aa->aa_bust, USBN_2_BASE, USBN_2_SIZE,
d133 3
a135 1
#endif
d155 4
d161 29
@


1.1
log
@Minimal attachment to build-test dwc2(4).
@
text
@d34 1
d36 1
d38 4
a41 1
#include <octeon/dev/octhcireg.h>
d49 5
d71 25
d112 5
a116 1
	rc = bus_space_map(aa->aa_bust, USBN_BASE, USBN_SIZE,
d118 1
a118 2
	if (rc != 0)
		panic(": can't map registers");
d121 1
d123 2
a124 8
	    0, &sc->sc_dma_reg);
	if (rc != 0)
		panic(": can't map dma registers");

	rc = bus_space_map(aa->aa_bust, USBC_BASE, USBC_SIZE,
	    0, &sc->sc_regc);
	if (rc != 0)
		panic(": can't map control registers");
d129 1
a129 2
	if (sc->sc_ih == NULL)
		panic(": interrupt establish failed");
d131 1
a131 3
	sc->sc_dwc2.sc_bus.pipe_size = sizeof(struct usbd_pipe);
	sc->sc_dwc2.sc_dmat = aa->aa_dmat;
	sc->sc_dwc2.sc_params = &octdwctwo_params;
d133 1
a133 1
	config_found((void *)sc, &sc->sc_dwc2.sc_bus.bdev, usbctlprint);
@

