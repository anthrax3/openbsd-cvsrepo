head	1.36;
access;
symbols
	OPENBSD_6_1:1.32.0.4
	OPENBSD_6_1_BASE:1.32
	OPENBSD_6_0:1.25.0.2
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.4
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.11.0.4
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.3.0.6
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.4
	OPENBSD_5_0:1.3.0.2
	OPENBSD_5_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.36
date	2017.09.08.05.36.52;	author deraadt;	state Exp;
branches;
next	1.35;
commitid	uRv5pa9QDlZaYgwD;

1.35
date	2017.06.29.10.56.18;	author visa;	state Exp;
branches;
next	1.34;
commitid	vsRvgFnzhdvu2Z6q;

1.34
date	2017.05.02.13.26.49;	author visa;	state Exp;
branches;
next	1.33;
commitid	RNCOX3BHktrY156Z;

1.33
date	2017.04.08.10.53.48;	author visa;	state Exp;
branches;
next	1.32;
commitid	FjZROiYy2KWcHFkv;

1.32
date	2017.01.22.10.17.37;	author dlg;	state Exp;
branches;
next	1.31;
commitid	VyLWTsbepAOk7VQM;

1.31
date	2016.11.26.15.36.10;	author martijn;	state Exp;
branches;
next	1.30;
commitid	wmlfTtbPd6tIh6wF;

1.30
date	2016.10.29.11.20.27;	author visa;	state Exp;
branches;
next	1.29;
commitid	kE0AA8C0KftzpEYB;

1.29
date	2016.10.29.11.00.19;	author visa;	state Exp;
branches;
next	1.28;
commitid	t7kz6Z4ma3M29x99;

1.28
date	2016.10.21.15.15.08;	author visa;	state Exp;
branches;
next	1.27;
commitid	6siXm3cAk6FarYpR;

1.27
date	2016.10.21.15.06.14;	author visa;	state Exp;
branches;
next	1.26;
commitid	9MKFi3N7TGntHJqg;

1.26
date	2016.08.04.13.10.31;	author visa;	state Exp;
branches;
next	1.25;
commitid	0L54RPNzULFkReBc;

1.25
date	2016.06.22.13.09.35;	author visa;	state Exp;
branches;
next	1.24;
commitid	KLZKLKw34aQIX6oW;

1.24
date	2016.06.18.15.59.34;	author visa;	state Exp;
branches;
next	1.23;
commitid	S0FTtHRKnjpzgWoO;

1.23
date	2016.06.09.15.29.22;	author visa;	state Exp;
branches;
next	1.22;
commitid	FJKDwQ5aqBYvlTcl;

1.22
date	2016.05.29.11.10.25;	author visa;	state Exp;
branches;
next	1.21;
commitid	6Qia14IK1r8MeKBb;

1.21
date	2016.05.29.11.00.24;	author visa;	state Exp;
branches;
next	1.20;
commitid	xVVDOdMMycnJUngM;

1.20
date	2015.07.19.23.46.50;	author jasper;	state Exp;
branches;
next	1.19;
commitid	srHxICmjHBgmnrAl;

1.19
date	2015.06.24.09.40.53;	author mpi;	state Exp;
branches;
next	1.18;
commitid	MVWrtktB46JRxFWT;

1.18
date	2015.02.11.07.05.39;	author dlg;	state Exp;
branches;
next	1.17;
commitid	JTpbkhDknrIuy9pn;

1.17
date	2014.12.09.06.58.28;	author doug;	state Exp;
branches;
next	1.16;
commitid	yWAxzpQP2PPpYlfT;

1.16
date	2014.08.11.19.00.50;	author miod;	state Exp;
branches;
next	1.15;
commitid	WSyMUxaCd6qqqO0W;

1.15
date	2014.08.11.18.52.54;	author miod;	state Exp;
branches;
next	1.14;
commitid	3pQH5uCxERPmO1Mq;

1.14
date	2014.08.11.18.29.56;	author miod;	state Exp;
branches;
next	1.13;
commitid	8Kx1Ci8ysFEuhw0R;

1.13
date	2014.08.11.18.08.17;	author miod;	state Exp;
branches;
next	1.12;
commitid	3N1WQMXOTORvYvCh;

1.12
date	2014.05.07.14.44.54;	author pirofti;	state Exp;
branches;
next	1.11;

1.11
date	2013.10.30.20.48.04;	author pirofti;	state Exp;
branches;
next	1.10;

1.10
date	2013.10.24.22.32.29;	author jasper;	state Exp;
branches;
next	1.9;

1.9
date	2013.10.23.09.35.36;	author mpi;	state Exp;
branches;
next	1.8;

1.8
date	2013.10.22.14.06.08;	author bcallah;	state Exp;
branches;
next	1.7;

1.7
date	2013.09.19.00.15.59;	author jmatthew;	state Exp;
branches;
next	1.6;

1.6
date	2013.09.16.20.52.13;	author jmatthew;	state Exp;
branches;
next	1.5;

1.5
date	2012.12.05.23.20.14;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2012.11.28.01.15.33;	author brad;	state Exp;
branches;
next	1.3;

1.3
date	2011.07.03.20.31.39;	author yasuoka;	state Exp;
branches;
next	1.2;

1.2
date	2011.06.24.02.13.23;	author yasuoka;	state Exp;
branches;
next	1.1;

1.1
date	2011.06.16.11.22.30;	author syuu;	state Exp;
branches;
next	;


desc
@@


1.36
log
@If you use sys/param.h, you don't need sys/types.h
@
text
@/*	$OpenBSD: cn30xxgmx.c,v 1.35 2017/06/29 10:56:18 visa Exp $	*/

/*
 * Copyright (c) 2007 Internet Initiative Japan, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/syslog.h>

#include <dev/ofw/openfirm.h>

#include <machine/bus.h>
#include <machine/octeon_model.h>
#include <machine/octeonvar.h>

#include <octeon/dev/iobusvar.h>
#include <octeon/dev/cn30xxasxvar.h>
#include <octeon/dev/cn30xxciureg.h>
#include <octeon/dev/cn30xxgmxreg.h>
#include <octeon/dev/cn30xxgmxvar.h>
#include <octeon/dev/cn30xxipdvar.h>
#include <octeon/dev/cn30xxpipvar.h>
#include <octeon/dev/cn30xxsmivar.h>

#define	dprintf(...)
#define	OCTEON_ETH_KASSERT	KASSERT

#define	ADDR2UINT64(u, a) \
	do { \
		u = \
		    (((uint64_t)a[0] << 40) | ((uint64_t)a[1] << 32) | \
		     ((uint64_t)a[2] << 24) | ((uint64_t)a[3] << 16) | \
		     ((uint64_t)a[4] <<  8) | ((uint64_t)a[5] <<  0)); \
	} while (0)
#define	UINT642ADDR(a, u) \
	do { \
		a[0] = (uint8_t)((u) >> 40); a[1] = (uint8_t)((u) >> 32); \
		a[2] = (uint8_t)((u) >> 24); a[3] = (uint8_t)((u) >> 16); \
		a[4] = (uint8_t)((u) >>  8); a[5] = (uint8_t)((u) >>  0); \
	} while (0)

#define	_GMX_RD8(sc, off) \
	bus_space_read_8((sc)->sc_port_gmx->sc_regt, (sc)->sc_port_gmx->sc_regh, (off))
#define	_GMX_WR8(sc, off, v) \
	bus_space_write_8((sc)->sc_port_gmx->sc_regt, (sc)->sc_port_gmx->sc_regh, (off), (v))
#define	_GMX_PORT_RD8(sc, off) \
	bus_space_read_8((sc)->sc_port_gmx->sc_regt, (sc)->sc_port_regh, (off))
#define	_GMX_PORT_WR8(sc, off, v) \
	bus_space_write_8((sc)->sc_port_gmx->sc_regt, (sc)->sc_port_regh, (off), (v))

#define PCS_READ_8(sc, reg) \
	bus_space_read_8((sc)->sc_port_gmx->sc_regt, (sc)->sc_port_pcs_regh, \
	    (reg))
#define PCS_WRITE_8(sc, reg, val) \
	bus_space_write_8((sc)->sc_port_gmx->sc_regt, (sc)->sc_port_pcs_regh, \
	    (reg), (val))

struct cn30xxgmx_port_ops {
	int	(*port_ops_enable)(struct cn30xxgmx_port_softc *, int);
	int	(*port_ops_speed)(struct cn30xxgmx_port_softc *);
	int	(*port_ops_timing)(struct cn30xxgmx_port_softc *);
};

int	cn30xxgmx_match(struct device *, void *, void *);
void	cn30xxgmx_attach(struct device *, struct device *, void *);
int	cn30xxgmx_print(void *, const char *);
int	cn30xxgmx_port_phy_addr(int);
int	cn30xxgmx_init(struct cn30xxgmx_softc *);
int	cn30xxgmx_rx_frm_ctl_xable(struct cn30xxgmx_port_softc *,
	    uint64_t, int);
int	cn30xxgmx_rgmii_enable(struct cn30xxgmx_port_softc *, int);
int	cn30xxgmx_rgmii_speed(struct cn30xxgmx_port_softc *);
int	cn30xxgmx_rgmii_speed_newlink(struct cn30xxgmx_port_softc *,
	    uint64_t *);
int	cn30xxgmx_rgmii_speed_speed(struct cn30xxgmx_port_softc *);
int	cn30xxgmx_rgmii_timing(struct cn30xxgmx_port_softc *);
int	cn30xxgmx_sgmii_enable(struct cn30xxgmx_port_softc *, int);
int	cn30xxgmx_sgmii_speed(struct cn30xxgmx_port_softc *);
int	cn30xxgmx_sgmii_timing(struct cn30xxgmx_port_softc *);
int	cn30xxgmx_tx_ovr_bp_enable(struct cn30xxgmx_port_softc *, int);
int	cn30xxgmx_rx_pause_enable(struct cn30xxgmx_port_softc *, int);

#ifdef OCTEON_ETH_DEBUG
void	cn30xxgmx_dump(void);
void	cn30xxgmx_debug_reset(void);
int	cn30xxgmx_intr_drop(void *);
int	cn30xxgmx_rgmii_speed_newlink_log(struct cn30xxgmx_port_softc *,
	    uint64_t);
#endif

static const int	cn30xxgmx_rx_adr_cam_regs[] = {
	GMX0_RX0_ADR_CAM0, GMX0_RX0_ADR_CAM1, GMX0_RX0_ADR_CAM2,
	GMX0_RX0_ADR_CAM3, GMX0_RX0_ADR_CAM4, GMX0_RX0_ADR_CAM5
};

struct cn30xxgmx_port_ops cn30xxgmx_port_ops_mii = {
	/* XXX not implemented */
};

struct cn30xxgmx_port_ops cn30xxgmx_port_ops_gmii = {
	.port_ops_enable = cn30xxgmx_rgmii_enable,
	.port_ops_speed = cn30xxgmx_rgmii_speed,
	.port_ops_timing = cn30xxgmx_rgmii_timing,
};

struct cn30xxgmx_port_ops cn30xxgmx_port_ops_rgmii = {
	.port_ops_enable = cn30xxgmx_rgmii_enable,
	.port_ops_speed = cn30xxgmx_rgmii_speed,
	.port_ops_timing = cn30xxgmx_rgmii_timing,
};

struct cn30xxgmx_port_ops cn30xxgmx_port_ops_sgmii = {
	.port_ops_enable = cn30xxgmx_sgmii_enable,
	.port_ops_speed = cn30xxgmx_sgmii_speed,
	.port_ops_timing = cn30xxgmx_sgmii_timing,
};

struct cn30xxgmx_port_ops cn30xxgmx_port_ops_spi42 = {
	/* XXX not implemented */
};

struct cn30xxgmx_port_ops *cn30xxgmx_port_ops[] = {
	[GMX_MII_PORT] = &cn30xxgmx_port_ops_mii,
	[GMX_GMII_PORT] = &cn30xxgmx_port_ops_gmii,
	[GMX_RGMII_PORT] = &cn30xxgmx_port_ops_rgmii,
	[GMX_SGMII_PORT] = &cn30xxgmx_port_ops_sgmii,
	[GMX_SPI42_PORT] = &cn30xxgmx_port_ops_spi42
};

#ifdef OCTEON_ETH_DEBUG
void	*cn30xxgmx_intr_drop_ih;

struct cn30xxgmx_port_softc *__cn30xxgmx_port_softc[GMX_PORT_NUNITS];
#endif

struct cfattach cn30xxgmx_ca = {sizeof(struct cn30xxgmx_softc),
    cn30xxgmx_match, cn30xxgmx_attach, NULL, NULL};

struct cfdriver cn30xxgmx_cd = {NULL, "cn30xxgmx", DV_DULL};

int
cn30xxgmx_match(struct device *parent, void *match, void *aux)
{
	struct cfdata *cf = (struct cfdata *)match;
	struct iobus_attach_args *aa = aux;

	if (strcmp(cf->cf_driver->cd_name, aa->aa_name) != 0)
		return 0;
	if (cf->cf_unit != aa->aa_unitno)
		return 0;
	return 1;
}

int
cn30xxgmx_get_phy_phandle(int port)
{
	char name[64];
	int node;
	int phandle = 0;

	snprintf(name, sizeof(name),
	    "/soc/pip@@11800a0000000/interface@@%x/ethernet@@%x",
	    port / 16, port % 16);
	node = OF_finddevice(name);
	if (node != - 1)
		phandle = OF_getpropint(node, "phy-handle", 0);
	return phandle;
}

void
cn30xxgmx_attach(struct device *parent, struct device *self, void *aux)
{
	struct cn30xxgmx_attach_args gmx_aa;
	struct iobus_attach_args *aa = aux;
	struct cn30xxgmx_port_softc *port_sc;
	struct cn30xxgmx_softc *sc = (void *)self;
	struct cn30xxsmi_softc *smi;
	int i;
	int phy_addr;
	int port;
	int status;

	printf("\n");

	sc->sc_regt = aa->aa_bust; /* XXX why there are iot? */
	sc->sc_unitno = aa->aa_unitno;

	status = bus_space_map(sc->sc_regt, aa->aa_addr,
	    GMX0_BASE_IF_SIZE(sc->sc_nports), 0, &sc->sc_regh);
	if (status != 0)
		panic(": can't map register");

	cn30xxgmx_init(sc);

	sc->sc_ports = mallocarray(sc->sc_nports, sizeof(*sc->sc_ports),
	    M_DEVBUF, M_NOWAIT | M_ZERO);
	if (sc->sc_ports == NULL) {
		printf("%s: out of memory\n", sc->sc_dev.dv_xname);
		return;
	}

	for (i = 0; i < sc->sc_nports; i++) {
		port = GMX_PORT_NUM(sc->sc_unitno, i);
		if (cn30xxsmi_get_phy(cn30xxgmx_get_phy_phandle(port), port,
		    &smi, &phy_addr))
			continue;

		port_sc = &sc->sc_ports[i];
		port_sc->sc_port_gmx = sc;
		port_sc->sc_port_no = port;
		port_sc->sc_port_type = sc->sc_port_types[i];
		port_sc->sc_port_ops = cn30xxgmx_port_ops[port_sc->sc_port_type];
		status = bus_space_map(sc->sc_regt,
		    aa->aa_addr + GMX0_BASE_PORT_SIZE * i,
		    GMX0_BASE_PORT_SIZE, 0, &port_sc->sc_port_regh);
		if (status != 0)
			panic(": can't map port register");

		switch (port_sc->sc_port_type) {
		case GMX_MII_PORT:
		case GMX_GMII_PORT:
		case GMX_RGMII_PORT: {
			struct cn30xxasx_attach_args asx_aa;

			asx_aa.aa_port = i;
			asx_aa.aa_regt = aa->aa_bust;
			cn30xxasx_init(&asx_aa, &port_sc->sc_port_asx);
			break;
		}
		case GMX_SGMII_PORT:
			if (bus_space_map(sc->sc_regt,
			    PCS_BASE(sc->sc_unitno, i), PCS_SIZE, 0,
			    &port_sc->sc_port_pcs_regh))
				panic("could not map PCS registers");
			break;
		default:
			/* nothing */
			break;
		}

		(void)memset(&gmx_aa, 0, sizeof(gmx_aa));
		gmx_aa.ga_regt = aa->aa_bust;
		gmx_aa.ga_dmat = aa->aa_dmat;
		gmx_aa.ga_addr = aa->aa_addr;
		gmx_aa.ga_name = "cnmac";
		gmx_aa.ga_portno = port_sc->sc_port_no;
		gmx_aa.ga_port_type = sc->sc_port_types[i];
		gmx_aa.ga_gmx = sc;
		gmx_aa.ga_gmx_port = port_sc;
		gmx_aa.ga_phy_addr = phy_addr;
		gmx_aa.ga_smi = smi;

		config_found(self, &gmx_aa, cn30xxgmx_print);

#ifdef OCTEON_ETH_DEBUG
		__cn30xxgmx_port_softc[port_sc->sc_port_no] = port_sc;
#endif
	}

#ifdef OCTEON_ETH_DEBUG
	if (cn30xxgmx_intr_drop_ih == NULL)
		cn30xxgmx_intr_drop_ih = octeon_intr_establish(
		   ffs64(CIU_INTX_SUM0_GMX_DRP) - 1, IPL_NET,
		   cn30xxgmx_intr_drop, NULL, "cn30xxgmx");
#endif
}

int
cn30xxgmx_print(void *aux, const char *pnp)
{
	struct cn30xxgmx_attach_args *ga = aux;
	static const char *types[] = {
		[GMX_MII_PORT] = "MII",
		[GMX_GMII_PORT] = "GMII",
		[GMX_RGMII_PORT] = "RGMII",
		[GMX_SGMII_PORT] = "SGMII"
	};

#if DEBUG
	if (pnp)
		printf("%s at %s", ga->ga_name, pnp);
#endif

	printf(": %s", types[ga->ga_port_type]);

	return UNCONF;
}

int
cn30xxgmx_init(struct cn30xxgmx_softc *sc)
{
	int result = 0;
	uint64_t inf_mode;
	int i, id;

	inf_mode = bus_space_read_8(sc->sc_regt, sc->sc_regh, GMX0_INF_MODE);
	if ((inf_mode & INF_MODE_EN) == 0) {
		printf("ports are disabled\n");
		sc->sc_nports = 0;
		return 1;
	}

	id = octeon_get_chipid();

	switch (octeon_model_family(id)) {
	case OCTEON_MODEL_FAMILY_CN31XX:
		/*
		 * CN31XX-HM-1.01
		 * 14.1 Packet Interface Introduction
		 * Table 14-1 Packet Interface Configuration
		 * 14.8 GMX Registers, Interface Mode Register, GMX0_INF_MODE
		 */
		if ((inf_mode & INF_MODE_TYPE) == 0) {
			/* all three ports configured as RGMII */
			sc->sc_nports = 3;
			sc->sc_port_types[0] = GMX_RGMII_PORT;
			sc->sc_port_types[1] = GMX_RGMII_PORT;
			sc->sc_port_types[2] = GMX_RGMII_PORT;
		} else {
			/* port 0: RGMII, port 1: GMII, port 2: disabled */
			/* XXX CN31XX-HM-1.01 says "Port 3: disabled"; typo? */
			sc->sc_nports = 2;
			sc->sc_port_types[0] = GMX_RGMII_PORT;
			sc->sc_port_types[1] = GMX_GMII_PORT;
		}
		break;
	case OCTEON_MODEL_FAMILY_CN30XX:
	case OCTEON_MODEL_FAMILY_CN50XX:
		/*
		 * CN30XX-HM-1.0
		 * 13.1 Packet Interface Introduction
		 * Table 13-1 Packet Interface Configuration
		 * 13.8 GMX Registers, Interface Mode Register, GMX0_INF_MODE
		 */
		if ((inf_mode & INF_MODE_P0MII) == 0)
			sc->sc_port_types[0] = GMX_RGMII_PORT;
		else
			sc->sc_port_types[0] = GMX_MII_PORT;
		if ((inf_mode & INF_MODE_TYPE) == 0) {
			/* port 1 and 2 are configred as RGMII ports */
			sc->sc_nports = 3;
			sc->sc_port_types[1] = GMX_RGMII_PORT;
			sc->sc_port_types[2] = GMX_RGMII_PORT;
		} else {
			/* port 1: GMII/MII, port 2: disabled */
			/* GMII or MII port is slected by GMX_PRT1_CFG[SPEED] */
			sc->sc_nports = 2;
			sc->sc_port_types[1] = GMX_GMII_PORT;
		}
		/* port 2 is in CN3010/CN5010 only */
		if ((octeon_model(id) != OCTEON_MODEL_CN3010) &&
		    (octeon_model(id) != OCTEON_MODEL_CN5010))
			if (sc->sc_nports == 3)
				sc->sc_nports = 2;
		break;
	case OCTEON_MODEL_FAMILY_CN61XX: {
		uint64_t qlm_cfg;

		if (sc->sc_unitno == 0)
			qlm_cfg = octeon_xkphys_read_8(MIO_QLM_CFG(2));
		else
			qlm_cfg = octeon_xkphys_read_8(MIO_QLM_CFG(0));
		if ((qlm_cfg & MIO_QLM_CFG_CFG) == 2) {
			sc->sc_nports = 4;
			for (i = 0; i < sc->sc_nports; i++)
				sc->sc_port_types[i] = GMX_SGMII_PORT;
		} else if ((qlm_cfg & MIO_QLM_CFG_CFG) == 3) {
			printf("XAUI interface is not supported\n");
			sc->sc_nports = 0;
			result = 1;
		} else {
			/* The interface is disabled. */
			sc->sc_nports = 0;
			result = 1;
		}
		break;
	}
	case OCTEON_MODEL_FAMILY_CN71XX:
		switch (inf_mode & INF_MODE_MODE) {
		case INF_MODE_MODE_SGMII:
			sc->sc_nports = 4;
			for (i = 0; i < sc->sc_nports; i++)
				sc->sc_port_types[i] = GMX_SGMII_PORT;
			break;
#ifdef notyet
		case INF_MODE_MODE_XAUI:
#endif
		default:
			sc->sc_nports = 0;
			result = 1;
		}
		break;
	case OCTEON_MODEL_FAMILY_CN38XX:
	case OCTEON_MODEL_FAMILY_CN56XX:
	case OCTEON_MODEL_FAMILY_CN58XX:
	default:
		printf("unsupported octeon model: 0x%x\n", octeon_get_chipid());
		sc->sc_nports = 0;
		result = 1;
		break;
	}

	return result;
}

/* XXX RGMII specific */
int
cn30xxgmx_link_enable(struct cn30xxgmx_port_softc *sc, int enable)
{
	uint64_t prt_cfg;

	cn30xxgmx_tx_int_enable(sc, enable);
	cn30xxgmx_rx_int_enable(sc, enable);

	prt_cfg = _GMX_PORT_RD8(sc, GMX0_PRT0_CFG);
	if (enable) {
		if (cn30xxgmx_link_status(sc)) {
			SET(prt_cfg, PRTN_CFG_EN);
		}
	} else {
		CLR(prt_cfg, PRTN_CFG_EN);
	}
	_GMX_PORT_WR8(sc, GMX0_PRT0_CFG, prt_cfg);
	/*
	 * According to CN30XX-HM-1.0, 13.4.2 Link Status Changes:
	 * > software should read back to flush the write operation.
	 */
	(void)_GMX_PORT_RD8(sc, GMX0_PRT0_CFG);

	return 0;
}

/* XXX RGMII specific */
int
cn30xxgmx_stats_init(struct cn30xxgmx_port_softc *sc)
{
        _GMX_PORT_WR8(sc, GMX0_RX0_STATS_PKTS, 0x0ULL);
        _GMX_PORT_WR8(sc, GMX0_RX0_STATS_PKTS_DRP, 0x0ULL);
        _GMX_PORT_WR8(sc, GMX0_RX0_STATS_PKTS_BAD, 0x0ULL);
        _GMX_PORT_WR8(sc, GMX0_TX0_STAT0, 0x0ULL);
        _GMX_PORT_WR8(sc, GMX0_TX0_STAT1, 0x0ULL);
        _GMX_PORT_WR8(sc, GMX0_TX0_STAT3, 0x0ULL);
        _GMX_PORT_WR8(sc, GMX0_TX0_STAT9, 0x0ULL);
	return 0;
}

int
cn30xxgmx_tx_stats_rd_clr(struct cn30xxgmx_port_softc *sc, int enable)
{
	_GMX_PORT_WR8(sc, GMX0_TX0_STATS_CTL, enable ? 0x1ULL : 0x0ULL);
	return 0;
}

int
cn30xxgmx_rx_stats_rd_clr(struct cn30xxgmx_port_softc *sc, int enable)
{
	_GMX_PORT_WR8(sc, GMX0_RX0_STATS_CTL, enable ? 0x1ULL : 0x0ULL);
	return 0;
}

void
cn30xxgmx_rx_stats_dec_bad(struct cn30xxgmx_port_softc *sc)
{
	uint64_t tmp;

        tmp = _GMX_PORT_RD8(sc, GMX0_RX0_STATS_PKTS_BAD);
	_GMX_PORT_WR8(sc, GMX0_RX0_STATS_PKTS_BAD, tmp - 1);
}

int
cn30xxgmx_tx_ovr_bp_enable(struct cn30xxgmx_port_softc *sc, int enable)
{
	uint64_t ovr_bp;
	int index = GMX_PORT_INDEX(sc->sc_port_no);

	ovr_bp = _GMX_RD8(sc, GMX0_TX_OVR_BP);
	if (enable) {
		CLR(ovr_bp, (1 << index) << TX_OVR_BP_EN_SHIFT);
		SET(ovr_bp, (1 << index) << TX_OVR_BP_BP_SHIFT);
		/* XXX really??? */
		SET(ovr_bp, (1 << index) << TX_OVR_BP_IGN_FULL_SHIFT);
	} else {
		SET(ovr_bp, (1 << index) << TX_OVR_BP_EN_SHIFT);
		CLR(ovr_bp, (1 << index) << TX_OVR_BP_BP_SHIFT);
		/* XXX really??? */
		SET(ovr_bp, (1 << index) << TX_OVR_BP_IGN_FULL_SHIFT);
	}
	_GMX_WR8(sc, GMX0_TX_OVR_BP, ovr_bp);
	return 0;
}

int
cn30xxgmx_rx_pause_enable(struct cn30xxgmx_port_softc *sc, int enable)
{
	if (enable) {
		cn30xxgmx_rx_frm_ctl_enable(sc, RXN_FRM_CTL_CTL_BCK);
	} else {
		cn30xxgmx_rx_frm_ctl_disable(sc, RXN_FRM_CTL_CTL_BCK);
	}

	return 0;
}

void
cn30xxgmx_tx_int_enable(struct cn30xxgmx_port_softc *sc, int enable)
{
	uint64_t tx_int_xxx = 0;

	SET(tx_int_xxx,
	    TX_INT_REG_LATE_COL |
	    TX_INT_REG_XSDEF |
	    TX_INT_REG_XSCOL |
	    TX_INT_REG_UNDFLW |
	    TX_INT_REG_PKO_NXA);
	_GMX_WR8(sc, GMX0_TX_INT_REG, tx_int_xxx);
	_GMX_WR8(sc, GMX0_TX_INT_EN, enable ? tx_int_xxx : 0);
}

void
cn30xxgmx_rx_int_enable(struct cn30xxgmx_port_softc *sc, int enable)
{
	uint64_t rx_int_xxx = 0;

	SET(rx_int_xxx, 0 |
	    RXN_INT_REG_PHY_DUPX |
	    RXN_INT_REG_PHY_SPD |
	    RXN_INT_REG_PHY_LINK |
	    RXN_INT_REG_IFGERR |
	    RXN_INT_REG_COLDET |
	    RXN_INT_REG_FALERR |
	    RXN_INT_REG_RSVERR |
	    RXN_INT_REG_PCTERR |
	    RXN_INT_REG_OVRERR |
	    RXN_INT_REG_NIBERR |
	    RXN_INT_REG_SKPERR |
	    RXN_INT_REG_RCVERR |
	    RXN_INT_REG_LENERR |
	    RXN_INT_REG_ALNERR |
	    RXN_INT_REG_FCSERR |
	    RXN_INT_REG_JABBER |
	    RXN_INT_REG_MAXERR |
	    RXN_INT_REG_CAREXT |
	    RXN_INT_REG_MINERR);
	_GMX_PORT_WR8(sc, GMX0_RX0_INT_REG, rx_int_xxx);
	_GMX_PORT_WR8(sc, GMX0_RX0_INT_EN, enable ? rx_int_xxx : 0);
}

int
cn30xxgmx_rx_frm_ctl_enable(struct cn30xxgmx_port_softc *sc,
    uint64_t rx_frm_ctl)
{
	struct ifnet *ifp = &sc->sc_port_ac->ac_if;
	unsigned int maxlen;

	maxlen = roundup(ifp->if_hardmtu + ETHER_HDR_LEN + ETHER_CRC_LEN +
	    ETHER_VLAN_ENCAP_LEN, 8);
	_GMX_PORT_WR8(sc, GMX0_RX0_JABBER, maxlen);

	return cn30xxgmx_rx_frm_ctl_xable(sc, rx_frm_ctl, 1);
}

int
cn30xxgmx_rx_frm_ctl_disable(struct cn30xxgmx_port_softc *sc,
    uint64_t rx_frm_ctl)
{
	return cn30xxgmx_rx_frm_ctl_xable(sc, rx_frm_ctl, 0);
}

int
cn30xxgmx_rx_frm_ctl_xable(struct cn30xxgmx_port_softc *sc,
    uint64_t rx_frm_ctl, int enable)
{
	uint64_t tmp;

	tmp = _GMX_PORT_RD8(sc, GMX0_RX0_FRM_CTL);
	if (enable)
		SET(tmp, rx_frm_ctl);
	else
		CLR(tmp, rx_frm_ctl);
	_GMX_PORT_WR8(sc, GMX0_RX0_FRM_CTL, tmp);

	return 0;
}

int
cn30xxgmx_tx_thresh(struct cn30xxgmx_port_softc *sc, int cnt)
{
	_GMX_PORT_WR8(sc, GMX0_TX0_THRESH, cnt);
	return 0;
}

int
cn30xxgmx_set_mac_addr(struct cn30xxgmx_port_softc *sc, uint8_t *addr)
{
	uint64_t mac;
	int i;

	ADDR2UINT64(mac, addr);

	cn30xxgmx_link_enable(sc, 0);

	sc->sc_mac = mac;
	_GMX_PORT_WR8(sc, GMX0_SMAC0, mac);
	for (i = 0; i < 6; i++)
		_GMX_PORT_WR8(sc, cn30xxgmx_rx_adr_cam_regs[i], addr[i]);

	cn30xxgmx_link_enable(sc, 1);

	return 0;
}

#define	OCTEON_ETH_USE_GMX_CAM

int
cn30xxgmx_set_filter(struct cn30xxgmx_port_softc *sc)
{
	struct ifnet *ifp = &sc->sc_port_ac->ac_if;
	struct arpcom *ac = sc->sc_port_ac;
#ifdef OCTEON_ETH_USE_GMX_CAM
	struct ether_multi *enm;
	struct ether_multistep step;
#endif
	uint64_t cam_en = 0x01ULL;
	uint64_t ctl = 0;
	int multi = 0;

	cn30xxgmx_link_enable(sc, 0);

	SET(ctl, RXN_ADR_CTL_CAM_MODE);
	CLR(ctl, RXN_ADR_CTL_MCST_ACCEPT | RXN_ADR_CTL_MCST_AFCAM |
	    RXN_ADR_CTL_MCST_REJECT);
	CLR(ifp->if_flags, IFF_ALLMULTI);

	/*
	 * Always accept broadcast frames.
	 */
	SET(ctl, RXN_ADR_CTL_BCST);

	if (ISSET(ifp->if_flags, IFF_PROMISC)) {
		SET(ifp->if_flags, IFF_ALLMULTI);
		CLR(ctl, RXN_ADR_CTL_CAM_MODE);
		SET(ctl, RXN_ADR_CTL_MCST_ACCEPT);
		cam_en = 0x00ULL;
	} else if (ac->ac_multirangecnt > 0 || ac->ac_multicnt > 7) {
		SET(ifp->if_flags, IFF_ALLMULTI);
		SET(ctl, RXN_ADR_CTL_MCST_ACCEPT);
	} else {
#ifdef OCTEON_ETH_USE_GMX_CAM
		/*
		 * Note first entry is self MAC address; other 7 entires are
		 * available for multicast addresses.
		 */
		ETHER_FIRST_MULTI(step, sc->sc_port_ac, enm);
		while (enm != NULL) {
			int i;

			dprintf("%d: %02x:%02x:%02x:%02x:%02x:%02x\n"
			    multi + 1,
			    enm->enm_addrlo[0], enm->enm_addrlo[1],
			    enm->enm_addrlo[2], enm->enm_addrlo[3],
			    enm->enm_addrlo[4], enm->enm_addrlo[5]);
			multi++;

			SET(cam_en, 1ULL << multi); /* XXX */

			for (i = 0; i < 6; i++) {
				uint64_t tmp;

				/* XXX */
				tmp = _GMX_PORT_RD8(sc,
				    cn30xxgmx_rx_adr_cam_regs[i]);
				CLR(tmp, 0xffULL << (8 * multi));
				SET(tmp, (uint64_t)enm->enm_addrlo[i] <<
				    (8 * multi));
				_GMX_PORT_WR8(sc, cn30xxgmx_rx_adr_cam_regs[i],
				    tmp);
			}

			for (i = 0; i < 6; i++)
				dprintf("cam%d = %016llx\n", i,
				    _GMX_PORT_RD8(sc,
				    cn30xxgmx_rx_adr_cam_regs[i]));

			ETHER_NEXT_MULTI(step, enm);
		}

		if (multi)
			SET(ctl, RXN_ADR_CTL_MCST_AFCAM);
		else
			SET(ctl, RXN_ADR_CTL_MCST_REJECT);

		OCTEON_ETH_KASSERT(enm == NULL);
#else
		/*
		 * XXX
		 * Never use DMAC filter for multicast addresses, but register
		 * only single entry for self address.  FreeBSD code do so.
		 */
		SET(ifp->if_flags, IFF_ALLMULTI);
		SET(ctl, RXN_ADR_CTL_MCST_ACCEPT);
#endif
	}

	dprintf("ctl = %llx, cam_en = %llx\n", ctl, cam_en);
	_GMX_PORT_WR8(sc, GMX0_RX0_ADR_CTL, ctl);
	_GMX_PORT_WR8(sc, GMX0_RX0_ADR_CAM_EN, cam_en);

	cn30xxgmx_link_enable(sc, 1);

	return 0;
}

int
cn30xxgmx_port_enable(struct cn30xxgmx_port_softc *sc, int enable)
{
	(*sc->sc_port_ops->port_ops_enable)(sc, enable);
	return 0;
}

int
cn30xxgmx_reset_speed(struct cn30xxgmx_port_softc *sc)
{
	struct ifnet *ifp = &sc->sc_port_ac->ac_if;
	if (ISSET(sc->sc_port_mii->mii_flags, MIIF_DOINGAUTO)) {
		log(LOG_WARNING,
		    "%s: autonegotiation has not been completed yet\n",
		    ifp->if_xname);
		return 1;
	}
	(*sc->sc_port_ops->port_ops_speed)(sc);
	return 0;
}

int
cn30xxgmx_reset_timing(struct cn30xxgmx_port_softc *sc)
{
	(*sc->sc_port_ops->port_ops_timing)(sc);
	return 0;
}

int
cn30xxgmx_reset_board(struct cn30xxgmx_port_softc *sc)
{

	return 0;
}

int
cn30xxgmx_reset_flowctl(struct cn30xxgmx_port_softc *sc)
{
	struct ifmedia_entry *ife = sc->sc_port_mii->mii_media.ifm_cur;

	/*
	 * Get flow control negotiation result.
	 */
#ifdef GMX_802_3X_DISABLE_AUTONEG
	/* Tentative support for SEIL-compat.. */
	if (IFM_SUBTYPE(ife->ifm_media) == IFM_AUTO) {
		sc->sc_port_flowflags &= ~IFM_ETH_FMASK;
	}
#else
	/* Default configuration of NetBSD */
	if (IFM_SUBTYPE(ife->ifm_media) == IFM_AUTO &&
	    (sc->sc_port_mii->mii_media_active & IFM_ETH_FMASK) !=
			sc->sc_port_flowflags) {
		sc->sc_port_flowflags =
			sc->sc_port_mii->mii_media_active & IFM_ETH_FMASK;
		sc->sc_port_mii->mii_media_active &= ~IFM_ETH_FMASK;
	}
#endif /* GMX_802_3X_DISABLE_AUTONEG */

	/*
	 * 802.3x Flow Control Capabilities
	 */
	if (sc->sc_port_flowflags & IFM_ETH_TXPAUSE) {
		cn30xxgmx_tx_ovr_bp_enable(sc, 1);
	} else {
		cn30xxgmx_tx_ovr_bp_enable(sc, 0);
	}
	if (sc->sc_port_flowflags & IFM_ETH_RXPAUSE) {
		cn30xxgmx_rx_pause_enable(sc, 1);
	} else {
		cn30xxgmx_rx_pause_enable(sc, 0);
	}

	return 0;
}

int
cn30xxgmx_rgmii_enable(struct cn30xxgmx_port_softc *sc, int enable)
{
	uint64_t mode;

	/* XXX */
	mode = _GMX_RD8(sc, GMX0_INF_MODE);
	if (ISSET(mode, INF_MODE_EN)) {
		cn30xxasx_enable(sc->sc_port_asx, 1);
	}

	return 0;
}

int
cn30xxgmx_rgmii_speed(struct cn30xxgmx_port_softc *sc)
{
	struct ifnet *ifp = &sc->sc_port_ac->ac_if;
	uint64_t newlink;
	int baudrate;

	/* XXX */
	cn30xxgmx_link_enable(sc, 1);

	cn30xxgmx_rgmii_speed_newlink(sc, &newlink);
	if (sc->sc_link == newlink) {
		return 0;
	}
#ifdef OCTEON_ETH_DEBUG
	cn30xxgmx_rgmii_speed_newlink_log(sc, newlink);
#endif
	sc->sc_link = newlink;

	switch (sc->sc_link & RXN_RX_INBND_SPEED) {
	case RXN_RX_INBND_SPEED_2_5:
		baudrate = IF_Mbps(10);
		break;
	case RXN_RX_INBND_SPEED_25:
		baudrate = IF_Mbps(100);
		break;
	case RXN_RX_INBND_SPEED_125:
		baudrate = IF_Gbps(1);
		break;
	default:
		baudrate = 0/* XXX */;
		break;
	}
	ifp->if_baudrate = baudrate;

	cn30xxgmx_link_enable(sc, 0);

	/*
	 * According to CN30XX-HM-1.0, 13.4.2 Link Status Changes:
	 * wait a max_packet_time
	 * max_packet_time(us) = (max_packet_size(bytes) * 8) / link_speed(Mbps)
	 */
	delay((GMX_FRM_MAX_SIZ * 8) / (baudrate / 1000000));

	cn30xxgmx_rgmii_speed_speed(sc);

	cn30xxgmx_link_enable(sc, 1);
	cn30xxasx_enable(sc->sc_port_asx, 1);

	return 0;
}

int
cn30xxgmx_rgmii_speed_newlink(struct cn30xxgmx_port_softc *sc,
    uint64_t *rnewlink)
{
	uint64_t newlink;

	/* Inband status does not seem to work */
	newlink = _GMX_PORT_RD8(sc, GMX0_RX0_RX_INBND);

	*rnewlink = newlink;
	return 0;
}

#ifdef OCTEON_ETH_DEBUG
int
cn30xxgmx_rgmii_speed_newlink_log(struct cn30xxgmx_port_softc *sc,
    uint64_t newlink)
{
	struct ifnet *ifp = &sc->sc_port_ac->ac_if;
	const char *status_str;
	const char *speed_str;
	const char *duplex_str;
	int is_status_changed;
	int is_speed_changed;
	int is_linked;
	char status_buf[80/* XXX */];
	char speed_buf[80/* XXX */];

	is_status_changed = (newlink & RXN_RX_INBND_STATUS) !=
	    (sc->sc_link & RXN_RX_INBND_STATUS);
	is_speed_changed = (newlink & RXN_RX_INBND_SPEED) !=
	    (sc->sc_link & RXN_RX_INBND_SPEED);
	is_linked = ISSET(newlink, RXN_RX_INBND_STATUS);
	if (is_status_changed) {
		if (is_linked)
			status_str = "link up";
		else
			status_str = "link down";
	} else {
		if (is_linked) {
			/* any other conditions? */
			if (is_speed_changed)
				status_str = "link change";
			else
				status_str = NULL;
		} else {
			status_str = NULL;
		}
	}

	if (status_str != NULL) {
		if ((is_speed_changed && is_linked) || is_linked) {
			switch (newlink & RXN_RX_INBND_SPEED) {
			case RXN_RX_INBND_SPEED_2_5:
				speed_str = "10baseT";
				break;
			case RXN_RX_INBND_SPEED_25:
				speed_str = "100baseTX";
				break;
			case RXN_RX_INBND_SPEED_125:
				speed_str = "1000baseT";
				break;
			default:
				panic("Unknown link speed");
				break;
			}

			if (ISSET(newlink, RXN_RX_INBND_DUPLEX))
				duplex_str = "-FDX";
			else
				duplex_str = "";

			(void)snprintf(speed_buf, sizeof(speed_buf), "(%s%s)",
			    speed_str, duplex_str);
		} else {
			speed_buf[0] = '\0';
		}
		(void)snprintf(status_buf, sizeof(status_buf), "%s: %s%s%s\n",
		    ifp->if_xname, status_str, (is_speed_changed | is_linked) ? " " : "",
		    speed_buf);
		log(LOG_CRIT, status_buf);
	}

	return 0;
}
#endif

int
cn30xxgmx_rgmii_speed_speed(struct cn30xxgmx_port_softc *sc)
{
	uint64_t prt_cfg;
	uint64_t tx_clk, tx_slot, tx_burst;

	prt_cfg = _GMX_PORT_RD8(sc, GMX0_PRT0_CFG);

	switch (sc->sc_link & RXN_RX_INBND_SPEED) {
	case RXN_RX_INBND_SPEED_2_5:
		/* 10Mbps */
		/*
		 * "GMX Tx Clock Generation Registers", CN30XX-HM-1.0;
		 * > 8ns x 50 = 400ns (2.5MHz TXC clock)
		 */
		tx_clk = 50;
		/*
		 * "TX Slottime Counter Registers", CN30XX-HM-1.0;
		 * > 10/100Mbps: set SLOT to 0x40
		 */
		tx_slot = 0x40;
		/*
		 * "TX Burst-Counter Registers", CN30XX-HM-1.0;
		 * > 10/100Mbps: set BURST to 0x0
		 */
		tx_burst = 0;
		/*
		 * "GMX Tx Port Configuration Registers", CN30XX-HM-1.0;
		 * > Slot time for half-duplex operation
		 * >   0 = 512 bittimes (10/100Mbps operation)
		 */
		CLR(prt_cfg, PRTN_CFG_SLOTTIME);
		/*
		 * "GMX Port Configuration Registers", CN30XX-HM-1.0;
		 * > Link speed
		 * >   0 = 10/100Mbps operation
		 * >     in RGMII mode: GMX0_TX(0..2)_CLK[CLK_CNT] > 1
		 */
		CLR(prt_cfg, PRTN_CFG_SPEED);
		break;
	case RXN_RX_INBND_SPEED_25:
		/* 100Mbps */
		/*
		 * "GMX Tx Clock Generation Registers", CN30XX-HM-1.0;
		 * > 8ns x 5 = 40ns (25.0MHz TXC clock)
		 */
		tx_clk = 5;
		/*
		 * "TX Slottime Counter Registers", CN30XX-HM-1.0;
		 * > 10/100Mbps: set SLOT to 0x40
		 */
		tx_slot = 0x40;
		/*
		 * "TX Burst-Counter Registers", CN30XX-HM-1.0;
		 * > 10/100Mbps: set BURST to 0x0
		 */
		tx_burst = 0;
		/*
		 * "GMX Tx Port Configuration Registers", CN30XX-HM-1.0;
		 * > Slot time for half-duplex operation
		 * >   0 = 512 bittimes (10/100Mbps operation)
		 */
		CLR(prt_cfg, PRTN_CFG_SLOTTIME);
		/*
		 * "GMX Port Configuration Registers", CN30XX-HM-1.0;
		 * > Link speed
		 * >   0 = 10/100Mbps operation
		 * >     in RGMII mode: GMX0_TX(0..2)_CLK[CLK_CNT] > 1
		 */
		CLR(prt_cfg, PRTN_CFG_SPEED);
		break;
	case RXN_RX_INBND_SPEED_125:
		/* 1000Mbps */
		/*
		 * "GMX Tx Clock Generation Registers", CN30XX-HM-1.0;
		 * > 8ns x 1 = 8ns (125.0MHz TXC clock)
		 */
		tx_clk = 1;
		/*
		 * "TX Slottime Counter Registers", CN30XX-HM-1.0;
		 * > 1000Mbps: set SLOT to 0x200
		 */
		tx_slot = 0x200;
		/*
		 * "TX Burst-Counter Registers", CN30XX-HM-1.0;
		 * > 1000Mbps: set BURST to 0x2000
		 */
		tx_burst = 0x2000;
		/*
		 * "GMX Tx Port Configuration Registers", CN30XX-HM-1.0;
		 * > Slot time for half-duplex operation
		 * >   1 = 4096 bittimes (1000Mbps operation)
		 */
		SET(prt_cfg, PRTN_CFG_SLOTTIME);
		/*
		 * "GMX Port Configuration Registers", CN30XX-HM-1.0;
		 * > Link speed
		 * >   1 = 1000Mbps operation
		 */
		SET(prt_cfg, PRTN_CFG_SPEED);
		break;
	default:
		/* NOT REACHED! */
		/* Following configuration is default value of system.
		*/
		tx_clk = 1;
		tx_slot = 0x200;
		tx_burst = 0x2000;
		SET(prt_cfg, PRTN_CFG_SLOTTIME);
		SET(prt_cfg, PRTN_CFG_SPEED);
		break;
	}

	/* Setup Duplex mode(negotiated) */
	/*
	 * "GMX Port Configuration Registers", CN30XX-HM-1.0;
	 * > Duplex mode: 0 = half-duplex mode, 1=full-duplex
	 */
	if (ISSET(sc->sc_link, RXN_RX_INBND_DUPLEX)) {
		/* Full-Duplex */
		SET(prt_cfg, PRTN_CFG_DUPLEX);
	} else {
		/* Half-Duplex */
		CLR(prt_cfg, PRTN_CFG_DUPLEX);
	}

	_GMX_PORT_WR8(sc, GMX0_TX0_CLK, tx_clk);
	_GMX_PORT_WR8(sc, GMX0_TX0_SLOT, tx_slot);
	_GMX_PORT_WR8(sc, GMX0_TX0_BURST, tx_burst);
	_GMX_PORT_WR8(sc, GMX0_PRT0_CFG, prt_cfg);

	return 0;
}

int
cn30xxgmx_rgmii_timing(struct cn30xxgmx_port_softc *sc)
{
	int clk_tx_setting;
	int clk_rx_setting;
	uint64_t rx_frm_ctl;

	/* RGMII TX Threshold Registers, CN30XX-HM-1.0;
	 * > Number of 16-byte ticks to accumulate in the TX FIFO before
	 * > sending on the RGMII interface. This field should be large
	 * > enough to prevent underflow on the RGMII interface and must
	 * > never be set to less than 0x4. This register cannot exceed
	 * > the TX FIFO depth of 0x40 words.
	 */
	/* Default parameter of CN30XX */
	cn30xxgmx_tx_thresh(sc, 32);

	rx_frm_ctl = 0 |
	    /* RXN_FRM_CTL_NULL_DIS |	(cn5xxx only) */
	    /* RXN_FRM_CTL_PRE_ALIGN |	(cn5xxx only) */
	    /* RXN_FRM_CTL_PAD_LEN |	(cn3xxx only) */
	    /* RXN_FRM_CTL_VLAN_LEN |	(cn3xxx only) */
	    RXN_FRM_CTL_PRE_FREE |
	    RXN_FRM_CTL_CTL_SMAC |
	    RXN_FRM_CTL_CTL_MCST |
	    RXN_FRM_CTL_CTL_DRP |
	    RXN_FRM_CTL_PRE_STRP |
	    RXN_FRM_CTL_PRE_CHK;
	cn30xxgmx_rx_frm_ctl_enable(sc, rx_frm_ctl);

	/* XXX PHY-dependent parameter */
	/* RGMII RX Clock-Delay Registers, CN30XX-HM-1.0;
	 * > Delay setting to place n RXC (RGMII receive clock) delay line.
	 * > The intrinsic delay can range from 50ps to 80ps per tap,
	 * > which corresponds to skews of 1.25ns to 2.00ns at 25 taps(CSR+1).
	 * > This is the best match for the RGMII specification which wants
	 * > 1ns - 2.6ns of skew.
	 */
	/* RGMII TX Clock-Delay Registers, CN30XX-HM-1.0;
	 * > Delay setting to place n TXC (RGMII transmit clock) delay line.
	 * > ...
	 */

	switch (octeon_boot_info->board_type) {
	default:
		/* Default parameter of CN30XX */
		clk_tx_setting = 24;
		clk_rx_setting = 24;
		break;
	case BOARD_TYPE_UBIQUITI_E100:
		clk_tx_setting = 16;
		clk_rx_setting = 0;
		break;
	}

	cn30xxasx_clk_set(sc->sc_port_asx, clk_tx_setting, clk_rx_setting);

	return 0;
}

int
cn30xxgmx_sgmii_enable(struct cn30xxgmx_port_softc *sc, int enable)
{
	uint64_t ctl_reg, status, timer_count;
	uint64_t cpu_freq = octeon_boot_info->eclock / 1000000;
	int done;
	int i;

	if (!enable)
		return 0;

	/* Set link timer interval to 1.6ms. */
	timer_count = PCS_READ_8(sc, PCS_LINK_TIMER_COUNT);
	CLR(timer_count, PCS_LINK_TIMER_COUNT_MASK);
	SET(timer_count, ((1600 * cpu_freq) >> 10) & PCS_LINK_TIMER_COUNT_MASK);
	PCS_WRITE_8(sc, PCS_LINK_TIMER_COUNT, timer_count);

	/* Reset the PCS. */
	ctl_reg = PCS_READ_8(sc, PCS_MR_CONTROL);
	SET(ctl_reg, PCS_MR_CONTROL_RESET);
	PCS_WRITE_8(sc, PCS_MR_CONTROL, ctl_reg);

	/* Wait for the reset to complete. */
	done = 0;
	for (i = 0; i < 1000000; i++) {
		ctl_reg = PCS_READ_8(sc, PCS_MR_CONTROL);
		if (!ISSET(ctl_reg, PCS_MR_CONTROL_RESET)) {
			done = 1;
			break;
		}
	}
	if (!done) {
		printf("SGMII reset timeout on port %d\n", sc->sc_port_no);
		return 1;
	}

	/* Start a new SGMII autonegotiation. */
	SET(ctl_reg, PCS_MR_CONTROL_AN_EN);
	SET(ctl_reg, PCS_MR_CONTROL_RST_AN);
	CLR(ctl_reg, PCS_MR_CONTROL_PWR_DN);
	PCS_WRITE_8(sc, PCS_MR_CONTROL, ctl_reg);

	/* Wait for the SGMII autonegotiation to complete. */
	done = 0;
	for (i = 0; i < 1000000; i++) {
		status = PCS_READ_8(sc, PCS_MR_STATUS);
		if (ISSET(status, PCS_MR_STATUS_AN_CPT)) {
			done = 1;
			break;
		}
	}
	if (!done) {
		printf("SGMII autonegotiation timeout on port %d\n",
		    sc->sc_port_no);
		return 1;
	}

	return 0;
}

int
cn30xxgmx_sgmii_speed(struct cn30xxgmx_port_softc *sc)
{
	uint64_t misc_ctl, prt_cfg;
	int tx_burst, tx_slot;

	cn30xxgmx_link_enable(sc, 0);

	prt_cfg = _GMX_PORT_RD8(sc, GMX0_PRT0_CFG);

	if (ISSET(sc->sc_port_mii->mii_media_active, IFM_FDX))
		SET(prt_cfg, PRTN_CFG_DUPLEX);
	else
		CLR(prt_cfg, PRTN_CFG_DUPLEX);

	misc_ctl = PCS_READ_8(sc, PCS_MISC_CTL);
	CLR(misc_ctl, PCS_MISC_CTL_SAMP_PT);

	/* Disable the GMX port if the link is down. */
	if (cn30xxgmx_link_status(sc))
		CLR(misc_ctl, PCS_MISC_CTL_GMXENO);
	else
		SET(misc_ctl, PCS_MISC_CTL_GMXENO);

	switch (sc->sc_port_ac->ac_if.if_baudrate) {
	case IF_Mbps(10):
		tx_slot = 0x40;
		tx_burst = 0;
		CLR(prt_cfg, PRTN_CFG_SPEED);
		SET(prt_cfg, PRTN_CFG_SPEED_MSB);
		CLR(prt_cfg, PRTN_CFG_SLOTTIME);
		misc_ctl |= 25 & PCS_MISC_CTL_SAMP_PT;
		break;
	case IF_Mbps(100):
		tx_slot = 0x40;
		tx_burst = 0;
		CLR(prt_cfg, PRTN_CFG_SPEED);
		CLR(prt_cfg, PRTN_CFG_SPEED_MSB);
		CLR(prt_cfg, PRTN_CFG_SLOTTIME);
		misc_ctl |= 5 & PCS_MISC_CTL_SAMP_PT;
		break;
	case IF_Gbps(1):
	default:
		tx_slot = 0x200;
		tx_burst = 0x2000;
		SET(prt_cfg, PRTN_CFG_SPEED);
		CLR(prt_cfg, PRTN_CFG_SPEED_MSB);
		SET(prt_cfg, PRTN_CFG_SLOTTIME);
		misc_ctl |= 1 & PCS_MISC_CTL_SAMP_PT;
		break;
	}

	PCS_WRITE_8(sc, PCS_MISC_CTL, misc_ctl);

	_GMX_PORT_WR8(sc, GMX0_TX0_SLOT, tx_slot);
	_GMX_PORT_WR8(sc, GMX0_TX0_BURST, tx_burst);
	_GMX_PORT_WR8(sc, GMX0_PRT0_CFG, prt_cfg);

	cn30xxgmx_link_enable(sc, 1);

	return 0;
}

int
cn30xxgmx_sgmii_timing(struct cn30xxgmx_port_softc *sc)
{
	uint64_t rx_frm_ctl;

	cn30xxgmx_tx_thresh(sc, 32);

	rx_frm_ctl =
	    RXN_FRM_CTL_PRE_FREE |
	    RXN_FRM_CTL_CTL_SMAC |
	    RXN_FRM_CTL_CTL_MCST |
	    RXN_FRM_CTL_CTL_DRP |
	    RXN_FRM_CTL_PRE_STRP |
	    RXN_FRM_CTL_PRE_CHK;
	cn30xxgmx_rx_frm_ctl_enable(sc, rx_frm_ctl);

	return 0;
}

void
cn30xxgmx_stats(struct cn30xxgmx_port_softc *sc)
{
	struct ifnet *ifp = &sc->sc_port_ac->ac_if;
	uint64_t tmp;

	ifp->if_ierrors +=
	    (uint32_t)_GMX_PORT_RD8(sc, GMX0_RX0_STATS_PKTS_BAD);
	ifp->if_iqdrops +=
	    (uint32_t)_GMX_PORT_RD8(sc, GMX0_RX0_STATS_PKTS_DRP);
	tmp = _GMX_PORT_RD8(sc, GMX0_TX0_STAT0);
	ifp->if_oerrors +=
	    (uint32_t)tmp + ((uint32_t)(tmp >> 32) * 16);
	ifp->if_collisions += ((uint32_t)tmp) * 16;
	tmp = _GMX_PORT_RD8(sc, GMX0_TX0_STAT1);
	ifp->if_collisions +=
	    ((uint32_t)tmp * 2) + (uint32_t)(tmp >> 32);
	tmp = _GMX_PORT_RD8(sc, GMX0_TX0_STAT9);
	ifp->if_oerrors += (uint32_t)(tmp >> 32);
}

/* ---- DMAC filter */

#ifdef notyet
/*
 * DMAC filter configuration
 *	accept all
 *	reject 0 addrs (virtually accept all?)
 *	reject N addrs
 *	accept N addrs
 *	accept 0 addrs (virtually reject all?)
 *	reject all
 */

/* XXX local namespace */
#define	_POLICY			CN30XXGMX_FILTER_POLICY
#define	_POLICY_ACCEPT_ALL	CN30XXGMX_FILTER_POLICY_ACCEPT_ALL
#define	_POLICY_ACCEPT		CN30XXGMX_FILTER_POLICY_ACCEPT
#define	_POLICY_REJECT		CN30XXGMX_FILTER_POLICY_REJECT
#define	_POLICY_REJECT_ALL	CN30XXGMX_FILTER_POLICY_REJECT_ALL

int	cn30xxgmx_setfilt_addrs(struct cn30xxgmx_port_softc *,
	    size_t, uint8_t **);

int
cn30xxgmx_setfilt(struct cn30xxgmx_port_softc *sc, enum _POLICY policy,
    size_t naddrs, uint8_t **addrs)
{
	uint64_t rx_adr_ctl;

	KASSERT(policy >= _POLICY_ACCEPT_ALL);
	KASSERT(policy <= _POLICY_REJECT_ALL);

	rx_adr_ctl = _GMX_PORT_RD8(sc, GMX0_RX0_ADR_CTL);
	CLR(rx_adr_ctl, RXN_ADR_CTL_CAM_MODE | RXN_ADR_CTL_MCST);

	switch (policy) {
	case _POLICY_ACCEPT_ALL:
	case _POLICY_REJECT_ALL:
		KASSERT(naddrs == 0);
		KASSERT(addrs == NULL);

		SET(rx_adr_ctl, (policy == _POLICY_ACCEPT_ALL) ?
		    RXN_ADR_CTL_MCST_ACCEPT : RXN_ADR_CTL_MCST_REJECT);
		break;
	case _POLICY_ACCEPT:
	case _POLICY_REJECT:
		if (naddrs > CN30XXGMX_FILTER_NADDRS_MAX)
			return E2BIG;
		SET(rx_adr_ctl, (policy == _POLICY_ACCEPT) ?
		    RXN_ADR_CTL_CAM_MODE : 0);
		SET(rx_adr_ctl, RXN_ADR_CTL_MCST_AFCAM);
		/* set GMX0_RXN_ADR_CAM_EN, GMX0_RXN_ADR_CAM[0-5] */
		cn30xxgmx_setfilt_addrs(sc, naddrs, addrs);
		break;
	}

	/* set GMX0_RXN_ADR_CTL[MCST] */
	_GMX_PORT_WR8(sc, GMX0_RX0_ADR_CTL, rx_adr_ctl);

	return 0;
}

int
cn30xxgmx_setfilt_addrs(struct cn30xxgmx_port_softc *sc, size_t naddrs,
    uint8_t **addrs)
{
	uint64_t rx_adr_cam_en;
	uint64_t rx_adr_cam_addrs[CN30XXGMX_FILTER_NADDRS_MAX];
	int i, j;

	KASSERT(naddrs <= CN30XXGMX_FILTER_NADDRS_MAX);

	rx_adr_cam_en = 0;
	(void)memset(rx_adr_cam_addrs, 0, sizeof(rx_adr_cam_addrs));

	for (i = 0; i < naddrs; i++) {
		SET(rx_adr_cam_en, 1ULL << i);
		for (j = 0; j < 6; j++)
			SET(rx_adr_cam_addrs[j],
			    (uint64_t)addrs[i][j] << (8 * i));
	}

	/* set GMX0_RXN_ADR_CAM_EN, GMX0_RXN_ADR_CAM[0-5] */
	_GMX_PORT_WR8(sc, GMX0_RX0_ADR_CAM_EN, rx_adr_cam_en);
	for (j = 0; j < 6; j++)
		_GMX_PORT_WR8(sc, cn30xxgmx_rx_adr_cam_regs[j],
		    rx_adr_cam_addrs[j]);

	return 0;
}
#endif

/* ---- interrupt */

#ifdef OCTEON_ETH_DEBUG
void	cn30xxgmx_intr_rml_gmx0(void);

int	cn30xxgmx_intr_rml_verbose;

void
cn30xxgmx_intr_rml_gmx0(void)
{
	struct cn30xxgmx_port_softc *sc;
	int i;
	uint64_t reg;

	sc = __cn30xxgmx_port_softc[0];
	if (sc == NULL)
		return;

	/* GMX0_RXn_INT_REG or GMX0_TXn_INT_REG */
	reg = cn30xxgmx_get_tx_int_reg(sc);
	if (cn30xxgmx_intr_rml_verbose && reg != 0)
		printf("%s: GMX_TX_INT_REG=0x%016llx\n", __func__, reg);

	for (i = 0; i < GMX_PORT_NUNITS; i++) {
		sc = __cn30xxgmx_port_softc[i];
		if (sc == NULL)
			continue;
		reg = cn30xxgmx_get_rx_int_reg(sc);
		if (cn30xxgmx_intr_rml_verbose)
			printf("%s: GMX_RX_INT_REG=0x%016llx\n", __func__, reg);
	}
}

int
cn30xxgmx_intr_drop(void *arg)
{
	octeon_xkphys_write_8(CIU_INT0_SUM0, CIU_INTX_SUM0_GMX_DRP);
	return (1);
}

uint64_t
cn30xxgmx_get_rx_int_reg(struct cn30xxgmx_port_softc *sc)
{
	uint64_t reg;
	uint64_t rx_int_reg = 0;

	reg = _GMX_PORT_RD8(sc, GMX0_RX0_INT_REG);
	/* clear */
	SET(rx_int_reg, 0 |
	    RXN_INT_REG_PHY_DUPX |
	    RXN_INT_REG_PHY_SPD |
	    RXN_INT_REG_PHY_LINK |
	    RXN_INT_REG_IFGERR |
	    RXN_INT_REG_COLDET |
	    RXN_INT_REG_FALERR |
	    RXN_INT_REG_RSVERR |
	    RXN_INT_REG_PCTERR |
	    RXN_INT_REG_OVRERR |
	    RXN_INT_REG_NIBERR |
	    RXN_INT_REG_SKPERR |
	    RXN_INT_REG_RCVERR |
	    RXN_INT_REG_LENERR |
	    RXN_INT_REG_ALNERR |
	    RXN_INT_REG_FCSERR |
	    RXN_INT_REG_JABBER |
	    RXN_INT_REG_MAXERR |
	    RXN_INT_REG_CAREXT |
	    RXN_INT_REG_MINERR);
	_GMX_PORT_WR8(sc, GMX0_RX0_INT_REG, rx_int_reg);

	return reg;
}

uint64_t
cn30xxgmx_get_tx_int_reg(struct cn30xxgmx_port_softc *sc)
{
	uint64_t reg;
	uint64_t tx_int_reg = 0;

	reg = _GMX_PORT_RD8(sc, GMX0_TX_INT_REG);
	/* clear */
	SET(tx_int_reg, 0 |
	    TX_INT_REG_LATE_COL |
	    TX_INT_REG_XSDEF |
	    TX_INT_REG_XSCOL |
	    TX_INT_REG_UNDFLW |
	    TX_INT_REG_PKO_NXA);
	_GMX_PORT_WR8(sc, GMX0_TX_INT_REG, tx_int_reg);

	return reg;
}
#endif	/* OCTEON_ETH_DEBUG */

/* ---- debug */

#ifdef OCTEON_ETH_DEBUG
#define	_ENTRY(x)	{ #x, x }

struct cn30xxgmx_dump_reg_ {
	const char *name;
	size_t	offset;
};

const struct cn30xxgmx_dump_reg_ cn30xxgmx_dump_regs_[] = {
	_ENTRY(GMX0_SMAC0),
	_ENTRY(GMX0_BIST0),
	_ENTRY(GMX0_RX_PRTS),
	_ENTRY(GMX0_RX_BP_DROP0),
	_ENTRY(GMX0_RX_BP_DROP1),
	_ENTRY(GMX0_RX_BP_DROP2),
	_ENTRY(GMX0_RX_BP_ON0),
	_ENTRY(GMX0_RX_BP_ON1),
	_ENTRY(GMX0_RX_BP_ON2),
	_ENTRY(GMX0_RX_BP_OFF0),
	_ENTRY(GMX0_RX_BP_OFF1),
	_ENTRY(GMX0_RX_BP_OFF2),
	_ENTRY(GMX0_TX_PRTS),
	_ENTRY(GMX0_TX_IFG),
	_ENTRY(GMX0_TX_JAM),
	_ENTRY(GMX0_TX_COL_ATTEMPT),
	_ENTRY(GMX0_TX_PAUSE_PKT_DMAC),
	_ENTRY(GMX0_TX_PAUSE_PKT_TYPE),
	_ENTRY(GMX0_TX_OVR_BP),
	_ENTRY(GMX0_TX_BP),
	_ENTRY(GMX0_TX_CORRUPT),
	_ENTRY(GMX0_RX_PRT_INFO),
	_ENTRY(GMX0_TX_LFSR),
	_ENTRY(GMX0_TX_INT_REG),
	_ENTRY(GMX0_TX_INT_EN),
	_ENTRY(GMX0_NXA_ADR),
	_ENTRY(GMX0_BAD_REG),
	_ENTRY(GMX0_STAT_BP),
	_ENTRY(GMX0_TX_CLK_MSK0),
	_ENTRY(GMX0_TX_CLK_MSK1),
	_ENTRY(GMX0_RX_TX_STATUS),
	_ENTRY(GMX0_INF_MODE),
};

const struct cn30xxgmx_dump_reg_ cn30xxgmx_dump_port_regs_[] = {
	_ENTRY(GMX0_RX0_INT_REG),
	_ENTRY(GMX0_RX0_INT_EN),
	_ENTRY(GMX0_PRT0_CFG),
	_ENTRY(GMX0_RX0_FRM_CTL),
	_ENTRY(GMX0_RX0_FRM_CHK),
	_ENTRY(GMX0_RX0_FRM_MIN),
	_ENTRY(GMX0_RX0_FRM_MAX),
	_ENTRY(GMX0_RX0_JABBER),
	_ENTRY(GMX0_RX0_DECISION),
	_ENTRY(GMX0_RX0_UDD_SKP),
	_ENTRY(GMX0_RX0_STATS_CTL),
	_ENTRY(GMX0_RX0_IFG),
	_ENTRY(GMX0_RX0_RX_INBND),
	_ENTRY(GMX0_RX0_ADR_CTL),
	_ENTRY(GMX0_RX0_ADR_CAM_EN),
	_ENTRY(GMX0_RX0_ADR_CAM0),
	_ENTRY(GMX0_RX0_ADR_CAM1),
	_ENTRY(GMX0_RX0_ADR_CAM2),
	_ENTRY(GMX0_RX0_ADR_CAM3),
	_ENTRY(GMX0_RX0_ADR_CAM4),
	_ENTRY(GMX0_RX0_ADR_CAM5),
	_ENTRY(GMX0_TX0_CLK),
	_ENTRY(GMX0_TX0_THRESH),
	_ENTRY(GMX0_TX0_APPEND),
	_ENTRY(GMX0_TX0_SLOT),
	_ENTRY(GMX0_TX0_BURST),
	_ENTRY(GMX0_TX0_PAUSE_PKT_TIME),
	_ENTRY(GMX0_TX0_MIN_PKT),
	_ENTRY(GMX0_TX0_PAUSE_PKT_INTERVAL),
	_ENTRY(GMX0_TX0_SOFT_PAUSE),
	_ENTRY(GMX0_TX0_PAUSE_TOGO),
	_ENTRY(GMX0_TX0_PAUSE_ZERO),
	_ENTRY(GMX0_TX0_STATS_CTL),
	_ENTRY(GMX0_TX0_CTL),
};

const struct cn30xxgmx_dump_reg_ cn30xxgmx_dump_port_stats_[] = {
	_ENTRY(GMX0_RX0_STATS_PKTS),
	_ENTRY(GMX0_RX0_STATS_OCTS),
	_ENTRY(GMX0_RX0_STATS_PKTS_CTL),
	_ENTRY(GMX0_RX0_STATS_OCTS_CTL),
	_ENTRY(GMX0_RX0_STATS_PKTS_DMAC),
	_ENTRY(GMX0_RX0_STATS_OCTS_DMAC),
	_ENTRY(GMX0_RX0_STATS_PKTS_DRP),
	_ENTRY(GMX0_RX0_STATS_OCTS_DRP),
	_ENTRY(GMX0_RX0_STATS_PKTS_BAD),
	_ENTRY(GMX0_TX0_STAT0),
	_ENTRY(GMX0_TX0_STAT1),
	_ENTRY(GMX0_TX0_STAT2),
	_ENTRY(GMX0_TX0_STAT3),
	_ENTRY(GMX0_TX0_STAT4),
	_ENTRY(GMX0_TX0_STAT5),
	_ENTRY(GMX0_TX0_STAT6),
	_ENTRY(GMX0_TX0_STAT7),
	_ENTRY(GMX0_TX0_STAT8),
	_ENTRY(GMX0_TX0_STAT9),
};

void	cn30xxgmx_dump_common(void);
void	cn30xxgmx_dump_port0(void);
void	cn30xxgmx_dump_port1(void);
void	cn30xxgmx_dump_port2(void);
void	cn30xxgmx_dump_port0_regs(void);
void	cn30xxgmx_dump_port1_regs(void);
void	cn30xxgmx_dump_port2_regs(void);
void	cn30xxgmx_dump_port0_stats(void);
void	cn30xxgmx_dump_port1_stats(void);
void	cn30xxgmx_dump_port2_stats(void);
void	cn30xxgmx_dump_port_regs(int);
void	cn30xxgmx_dump_port_stats(int);
void	cn30xxgmx_dump_common_x(int, const struct cn30xxgmx_dump_reg_ *, size_t);
void	cn30xxgmx_dump_port_x(int, const struct cn30xxgmx_dump_reg_ *, size_t);
void	cn30xxgmx_dump_x(int, const struct cn30xxgmx_dump_reg_ *, size_t, size_t, int);
void	cn30xxgmx_dump_x_index(char *, size_t, int);

void
cn30xxgmx_dump(void)
{
	cn30xxgmx_dump_common();
	cn30xxgmx_dump_port0();
	cn30xxgmx_dump_port1();
	cn30xxgmx_dump_port2();
}

void
cn30xxgmx_dump_common(void)
{
	cn30xxgmx_dump_common_x(0, cn30xxgmx_dump_regs_,
	    nitems(cn30xxgmx_dump_regs_));
}

void
cn30xxgmx_dump_port0(void)
{
	cn30xxgmx_dump_port_regs(0);
	cn30xxgmx_dump_port_stats(0);
}

void
cn30xxgmx_dump_port1(void)
{
	cn30xxgmx_dump_port_regs(1);
	cn30xxgmx_dump_port_stats(1);
}

void
cn30xxgmx_dump_port2(void)
{
	cn30xxgmx_dump_port_regs(2);
	cn30xxgmx_dump_port_stats(2);
}

void
cn30xxgmx_dump_port_regs(int portno)
{
	cn30xxgmx_dump_port_x(portno, cn30xxgmx_dump_port_regs_,
	    nitems(cn30xxgmx_dump_port_regs_));
}

void
cn30xxgmx_dump_port_stats(int portno)
{
	struct cn30xxgmx_port_softc *sc = __cn30xxgmx_port_softc[0];
	uint64_t rx_stats_ctl;
	uint64_t tx_stats_ctl;

	rx_stats_ctl = _GMX_RD8(sc, GMX0_BASE_PORT_SIZE * portno + GMX0_RX0_STATS_CTL);
	_GMX_WR8(sc, GMX0_BASE_PORT_SIZE * portno + GMX0_RX0_STATS_CTL,
	    rx_stats_ctl & ~RXN_STATS_CTL_RD_CLR);
	tx_stats_ctl = _GMX_RD8(sc, GMX0_BASE_PORT_SIZE * portno + GMX0_TX0_STATS_CTL);
	_GMX_WR8(sc, GMX0_BASE_PORT_SIZE * portno + GMX0_TX0_STATS_CTL,
	    tx_stats_ctl & ~TXN_STATS_CTL_RD_CLR);
	cn30xxgmx_dump_port_x(portno, cn30xxgmx_dump_port_stats_,
	    nitems(cn30xxgmx_dump_port_stats_));
	_GMX_WR8(sc, GMX0_BASE_PORT_SIZE * portno + GMX0_RX0_STATS_CTL, rx_stats_ctl);
	_GMX_WR8(sc, GMX0_BASE_PORT_SIZE * portno + GMX0_TX0_STATS_CTL, tx_stats_ctl);
}

void
cn30xxgmx_dump_common_x(int portno, const struct cn30xxgmx_dump_reg_ *regs, size_t size)
{
	cn30xxgmx_dump_x(portno, regs, size, 0, 0);
}

void
cn30xxgmx_dump_port_x(int portno, const struct cn30xxgmx_dump_reg_ *regs, size_t size)
{
	cn30xxgmx_dump_x(portno, regs, size, GMX0_BASE_PORT_SIZE * portno, 1);
}

void
cn30xxgmx_dump_x(int portno, const struct cn30xxgmx_dump_reg_ *regs, size_t size, size_t base, int index)
{
	struct cn30xxgmx_port_softc *sc = __cn30xxgmx_port_softc[0];
	const struct cn30xxgmx_dump_reg_ *reg;
	uint64_t tmp;
	char name[64];
	int i;

	for (i = 0; i < (int)size; i++) {
		reg = &regs[i];
		tmp = _GMX_RD8(sc, base + reg->offset);

		snprintf(name, sizeof(name), "%s", reg->name);
		if (index > 0)
			cn30xxgmx_dump_x_index(name, sizeof(name), portno);

		printf("\t%-24s: %016llx\n", name, tmp);
	}
}

/* not in libkern */
static char *strstr(const char *, const char *);
static char *
strstr(const char *s, const char *find)
{
        char c, sc;
        size_t len;

        if ((c = *find++) != 0) {
                len = strlen(find);
                do {
                        do {
                                if ((sc = *s++) == 0)
                                        return (NULL);
                        } while (sc != c);
                } while (strncmp(s, find, len) != 0);
                s--;
        }
        return (char *)s;
}

void
cn30xxgmx_dump_x_index(char *buf, size_t len, int index)
{
	static const char *patterns[] = { "_TX0_", "_RX0_", "_PRT0_" };
	int i;

	for (i = 0; i < (int)nitems(patterns); i++) {
		char *p;

		p = strstr(buf, patterns[i]);
		if (p == NULL)
			continue;
		p = strchr(p, '0');
		KASSERT(p != NULL);
		*p = '0' + index;
		return;
	}
}

void
cn30xxgmx_debug_reset(void)
{
	int i;

	for (i = 0; i < 3; i++)
		cn30xxgmx_link_enable(__cn30xxgmx_port_softc[i], 0);
	for (i = 0; i < 3; i++)
		cn30xxgmx_link_enable(__cn30xxgmx_port_softc[i], 1);
}
#endif
@


1.35
log
@Always use the maximum permissible frame size for Rx size limit.
This lets a change of interface MTU take effect immediately without
link cycling and brings cnmac(4) into line with other jumbo frame
capable NIC drivers.

Prompted by Joe Holden on misc@@
OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxgmx.c,v 1.34 2017/05/02 13:26:49 visa Exp $	*/
a30 1
#include <sys/types.h>
@


1.34
log
@Revise MDIO driver code so that device instances can be attached
using fdt. This lets the system utilize multiple MDIO controllers.

This patch enables all RJ45 Ethernet ports on EdgeRouter Pro.
The SFP module slots do not work yet.

OK kettenis@@, jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxgmx.c,v 1.33 2017/04/08 10:53:48 visa Exp $	*/
d581 1
a581 1
	maxlen = roundup(ifp->if_mtu + ETHER_HDR_LEN + ETHER_CRC_LEN +
@


1.33
log
@Make network ports work on Shasta.
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxgmx.c,v 1.32 2017/01/22 10:17:37 dlg Exp $	*/
d43 1
d46 1
d48 2
a49 2
#include <octeon/dev/cn30xxasxvar.h>
#include <octeon/dev/cn30xxgmxvar.h>
d181 1
a181 1
cn30xxgmx_port_phy_addr(int port)
a182 4
	static const int octeon_eth_phy_table[] = {
		/* portwell cam-0100 */
		0x02, 0x03, 0x22
	};
d184 2
a185 3
	int phynode = 0;
	int portnode = -1;
	uint32_t phy = 0;
d190 4
a193 31
	portnode = OF_finddevice(name);
	if (portnode != -1) {
		phy = OF_getpropint(portnode, "phy-handle", 0);
		if (phy != 0)
			phynode = OF_getnodebyphandle(phy);
		if (phynode != 0)
			return OF_getpropint(phynode, "reg", 0);
	}

	switch (octeon_boot_info->board_type) {
	case BOARD_TYPE_UBIQUITI_E100:	/* port 0: 7, port 1: 6 */
		if (port > 2)
			return -1;
		return 7 - port;

	case BOARD_TYPE_UBIQUITI_E200:
		if (port >= 0 && port < 4)
			/* XXX RJ45/SFP combos use the second MDIO. */
			return port + 4;  /* GMX0: eth[4-7] */
		else if (port >= 16 && port < 20)
			return port - 16; /* GMX1: eth[0-3] */
		return -1;

	case BOARD_TYPE_CN3010_EVB_HS5:
		if (port >= nitems(octeon_eth_phy_table))
			return -1;
		return octeon_eth_phy_table[port];

	default:
		return -1;
	}
d199 3
d203 1
a203 2
	struct iobus_attach_args *aa = aux;
	struct cn30xxgmx_attach_args gmx_aa;
d206 1
a207 1
	struct cn30xxgmx_port_softc *port_sc;
d229 3
a231 3
		phy_addr = cn30xxgmx_port_phy_addr(
		    GMX_PORT_NUM(sc->sc_unitno, i));
		if (phy_addr == -1)
d236 1
a236 1
		port_sc->sc_port_no = GMX_PORT_NUM(sc->sc_unitno, i);
d277 1
@


1.32
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxgmx.c,v 1.31 2016/11/26 15:36:10 martijn Exp $	*/
d431 15
@


1.31
log
@Remove unnecessary function cn30xxgmx_submatch and call config_found
instead of config_found_sm.

OK visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxgmx.c,v 1.30 2016/10/29 11:20:27 visa Exp $	*/
a1325 2
	ifp->if_opackets +=
	    (uint32_t)_GMX_PORT_RD8(sc, GMX0_TX0_STAT3);
@


1.30
log
@If the system has fdt, use it for locating network PHYs.
Skip a network port if its PHY cannot be found.

Tested on Lanner MR-326B (has fdt) by pirofti@@, and
on EdgeRouter Pro (has fdt) and on EdgeRouter Lite (no fdt) by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxgmx.c,v 1.29 2016/10/29 11:00:19 visa Exp $	*/
a90 1
int	cn30xxgmx_submatch(struct device *, void *, void *);
d306 1
a306 2
		config_found_sm(self, &gmx_aa,
		    cn30xxgmx_print, cn30xxgmx_submatch);
a339 8
}

int
cn30xxgmx_submatch(struct device *parent, void *vcf, void *aux)
{
	struct cfdata *cf = vcf;

	return (*cf->cf_attach->ca_match)(parent, vcf, aux);
@


1.29
log
@Make PHY address lookups fail instead of using CAM-0100 entries
when the system board is unhandled.
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxgmx.c,v 1.28 2016/10/21 15:15:08 visa Exp $	*/
d36 2
d186 16
d233 2
a235 1
	int i;
d258 5
d305 1
a305 5
		gmx_aa.ga_phy_addr = cn30xxgmx_port_phy_addr(
		    port_sc->sc_port_no);
		if (gmx_aa.ga_phy_addr == -1)
			panic(": don't know phy address for port %d",
			    port_sc->sc_port_no);
@


1.28
log
@Check if memory allocation failed.
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxgmx.c,v 1.27 2016/10/21 15:06:14 visa Exp $	*/
d199 1
a199 1
	default:
d203 3
@


1.27
log
@Fix grammar, and simplify a little.

Pointed out by pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxgmx.c,v 1.26 2016/08/04 13:10:31 visa Exp $	*/
d230 4
@


1.26
log
@Add support for jumbo frames.
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxgmx.c,v 1.25 2016/06/22 13:09:35 visa Exp $	*/
d334 1
a334 1
		printf("port are disable\n");
d336 1
a336 2
		result = 1;
		return result;
@


1.25
log
@Add support for the second GMX interface on Octeon II. This enables
ports eth[0-3] on 8-port EdgeRouters. Currently, port eth0 maps to
network interface cnmac4, eth1 to cnmac5 etc.

ok dlg@@, tested by martijn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxgmx.c,v 1.24 2016/06/18 15:59:34 visa Exp $	*/
d574 6
a579 7
	/*
	 * XXX Jumbo-frame Workarounds
	 *     Current implementation of cnmac is required to
	 *     configure GMX0_RX0_JABBER[CNT] as follows:
	 *	RX0_FRM_MAX(1536) <= GMX0_RX0_JABBER <= 1536(0x600)
	 */
	_GMX_PORT_WR8(sc, GMX0_RX0_JABBER, GMX_FRM_MAX_SIZ);
@


1.24
log
@Make the 1 Gbps SGMII settings the default to define a consistent set of
parameters even if a link is down.
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxgmx.c,v 1.23 2016/06/09 15:29:22 visa Exp $	*/
a28 5
/*
 *  support GMX0 interface only
 *  take no thought for other GMX interface
 */

d219 1
d234 1
a234 1
		port_sc->sc_port_no = i;
d270 1
a270 1
		gmx_aa.ga_portno = i;
d274 2
a275 1
		gmx_aa.ga_phy_addr = cn30xxgmx_port_phy_addr(i);
d277 2
a278 1
			panic(": don't know phy address for port %d", i);
d284 1
a284 1
		__cn30xxgmx_port_softc[i] = port_sc;
d496 1
d500 2
a501 2
		CLR(ovr_bp, (1 << sc->sc_port_no) << TX_OVR_BP_EN_SHIFT);
		SET(ovr_bp, (1 << sc->sc_port_no) << TX_OVR_BP_BP_SHIFT);
d503 1
a503 1
		SET(ovr_bp, (1 << sc->sc_port_no) << TX_OVR_BP_IGN_FULL_SHIFT);
d505 2
a506 2
		SET(ovr_bp, (1 << sc->sc_port_no) << TX_OVR_BP_EN_SHIFT);
		CLR(ovr_bp, (1 << sc->sc_port_no) << TX_OVR_BP_BP_SHIFT);
d508 1
a508 1
		SET(ovr_bp, (1 << sc->sc_port_no) << TX_OVR_BP_IGN_FULL_SHIFT);
@


1.23
log
@Add SGMII support and PHY addresses for 8-port EdgeRouters. This makes
plain RJ45 ports eth[4-7] usable.

ok dlg@@, tested by martijn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxgmx.c,v 1.22 2016/05/29 11:10:25 visa Exp $	*/
d1262 1
a1268 2
		break;
	default:
@


1.22
log
@Map ASX registers only if link control needs them.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxgmx.c,v 1.21 2016/05/29 11:00:24 visa Exp $	*/
d78 7
d105 3
d140 6
d154 1
d161 1
a161 1
struct cn30xxgmx_port_softc *__cn30xxgmx_port_softc[3/* XXX */];
d196 8
d226 1
a226 1
	    GMX0_BASE_IF_SIZE, 0, &sc->sc_regh);
d258 6
d305 2
a306 1
		[GMX_RGMII_PORT] = "RGMII"
d332 1
a332 1
	int id;
d395 22
d1156 143
@


1.21
log
@The same MAC filter setup code should work with all PHY link types.
Remove unnecessary abstraction.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxgmx.c,v 1.20 2015/07/19 23:46:50 jasper Exp $	*/
d221 16
@


1.20
log
@rework how iobus(4) finds and attaches devices.

this allows us to get rid of the static list of children devices, using only
a lookup table for address hints where needed. as a bonus this removes the
'octcf0: [..] not configured' mesage on machines w/o octcf(4).

tested by pirofti@@ on DSR-500 and ERL by me
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxgmx.c,v 1.19 2015/06/24 09:40:53 mpi Exp $	*/
a81 3
	int	(*port_ops_set_mac_addr)(struct cn30xxgmx_port_softc *,
		    uint8_t *, uint64_t);
	int	(*port_ops_set_filter)(struct cn30xxgmx_port_softc *);
a97 3
int	cn30xxgmx_rgmii_set_mac_addr(struct cn30xxgmx_port_softc *,
	    uint8_t *, uint64_t);
int	cn30xxgmx_rgmii_set_filter(struct cn30xxgmx_port_softc *);
a121 2
	.port_ops_set_mac_addr = cn30xxgmx_rgmii_set_mac_addr,
	.port_ops_set_filter = cn30xxgmx_rgmii_set_filter
a127 2
	.port_ops_set_mac_addr = cn30xxgmx_rgmii_set_mac_addr,
	.port_ops_set_filter = cn30xxgmx_rgmii_set_filter
d549 2
a550 1
	uint64_t mac = 0;
d553 10
a562 1
	(*sc->sc_port_ops->port_ops_set_mac_addr)(sc, addr, mac);
d566 2
d571 93
a663 1
	(*sc->sc_port_ops->port_ops_set_filter)(sc);
a1085 114

	return 0;
}

int
cn30xxgmx_rgmii_set_mac_addr(struct cn30xxgmx_port_softc *sc, uint8_t *addr,
    uint64_t mac)
{
	int i;

	cn30xxgmx_link_enable(sc, 0);

	sc->sc_mac = mac;
	_GMX_PORT_WR8(sc, GMX0_SMAC0, mac);
	for (i = 0; i < 6; i++)
		_GMX_PORT_WR8(sc, cn30xxgmx_rx_adr_cam_regs[i], addr[i]);

	cn30xxgmx_link_enable(sc, 1);

	return 0;
}

#define	OCTEON_ETH_USE_GMX_CAM

int
cn30xxgmx_rgmii_set_filter(struct cn30xxgmx_port_softc *sc)
{
	struct ifnet *ifp = &sc->sc_port_ac->ac_if;
	struct arpcom *ac = sc->sc_port_ac;
#ifdef OCTEON_ETH_USE_GMX_CAM
	struct ether_multi *enm;
	struct ether_multistep step;
#endif
	uint64_t cam_en = 0x01ULL;
	uint64_t ctl = 0;
	int multi = 0;

	cn30xxgmx_link_enable(sc, 0);

	SET(ctl, RXN_ADR_CTL_CAM_MODE);
	CLR(ctl, RXN_ADR_CTL_MCST_ACCEPT | RXN_ADR_CTL_MCST_AFCAM | RXN_ADR_CTL_MCST_REJECT);
	CLR(ifp->if_flags, IFF_ALLMULTI);

	/*
	 * Always accept broadcast frames.
	 */
	SET(ctl, RXN_ADR_CTL_BCST);

	if (ISSET(ifp->if_flags, IFF_PROMISC)) {
		SET(ifp->if_flags, IFF_ALLMULTI);
		CLR(ctl, RXN_ADR_CTL_CAM_MODE);
		SET(ctl, RXN_ADR_CTL_MCST_ACCEPT);
		cam_en = 0x00ULL;
	} else if (ac->ac_multirangecnt > 0 || ac->ac_multicnt > 7) {
		SET(ifp->if_flags, IFF_ALLMULTI);
		SET(ctl, RXN_ADR_CTL_MCST_ACCEPT);
	} else {
#ifdef OCTEON_ETH_USE_GMX_CAM
		/*
		 * Note first entry is self MAC address; other 7 entires are available
		 * for multicast addresses.
		 */
		ETHER_FIRST_MULTI(step, sc->sc_port_ac, enm);
		while (enm != NULL) {
			int i;

			dprintf("%d: %02x:%02x:%02x:%02x:%02x:%02x\n"
			    multi + 1,
			    enm->enm_addrlo[0], enm->enm_addrlo[1],
			    enm->enm_addrlo[2], enm->enm_addrlo[3],
			    enm->enm_addrlo[4], enm->enm_addrlo[5]);
			multi++;

			SET(cam_en, 1ULL << multi); /* XXX */

			for (i = 0; i < 6; i++) {
				uint64_t tmp;

				/* XXX */
				tmp = _GMX_PORT_RD8(sc, cn30xxgmx_rx_adr_cam_regs[i]);
				CLR(tmp, 0xffULL << (8 * multi));
				SET(tmp, (uint64_t)enm->enm_addrlo[i] << (8 * multi));
				_GMX_PORT_WR8(sc, cn30xxgmx_rx_adr_cam_regs[i], tmp);
			}

			for (i = 0; i < 6; i++)
				dprintf("cam%d = %016llx\n", i,
				    _GMX_PORT_RD8(sc, cn30xxgmx_rx_adr_cam_regs[i]));

			ETHER_NEXT_MULTI(step, enm);
		}

		if (multi)
			SET(ctl, RXN_ADR_CTL_MCST_AFCAM);
		else
			SET(ctl, RXN_ADR_CTL_MCST_REJECT);

		OCTEON_ETH_KASSERT(enm == NULL);
#else
		/*
		 * XXX
		 * Never use DMAC filter for multicast addresses, but register only
		 * single entry for self address.  FreeBSD code do so.
		 */
		SET(ifp->if_flags, IFF_ALLMULTI);
		SET(ctl, RXN_ADR_CTL_MCST_ACCEPT);
#endif
	}

	dprintf("ctl = %llx, cam_en = %llx\n", ctl, cam_en);
	_GMX_PORT_WR8(sc, GMX0_RX0_ADR_CTL, ctl);
	_GMX_PORT_WR8(sc, GMX0_RX0_ADR_CAM_EN, cam_en);

	cn30xxgmx_link_enable(sc, 1);
@


1.19
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxgmx.c,v 1.18 2015/02/11 07:05:39 dlg Exp $	*/
d209 2
a210 2
	
	status = bus_space_map(sc->sc_regt, aa->aa_unit->addr,
d227 1
a227 1
		    aa->aa_unit->addr + GMX0_BASE_PORT_SIZE * i,
d235 1
a235 1
		gmx_aa.ga_addr = aa->aa_unit->addr;
@


1.18
log
@no md code wants lockmgr locks, so no md code needs to include sys/lock.h

with and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxgmx.c,v 1.17 2014/12/09 06:58:28 doug Exp $	*/
a1115 2
	ifp->if_ipackets +=
	    (uint32_t)_GMX_PORT_RD8(sc, GMX0_RX0_STATS_PKTS);
@


1.17
log
@Replace some malloc(n*size,...) calls with mallocarray().

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxgmx.c,v 1.16 2014/08/11 19:00:50 miod Exp $	*/
a37 1
#include <sys/lock.h>
@


1.16
log
@Do not extern octeon_boot_info, <machine/octeonvar.h> declares it for you.
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxgmx.c,v 1.15 2014/08/11 18:52:54 miod Exp $	*/
d218 2
a219 2
	sc->sc_ports = malloc(sizeof(*sc->sc_ports) * sc->sc_nports, M_DEVBUF,
	    M_NOWAIT | M_ZERO);
@


1.15
log
@Get rid of the `quirks' member, which is never initialized (but by zero at
softc creation) anyway. Sorry, we are not trying to support SEIL-specific
hardware at this point.
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxgmx.c,v 1.14 2014/08/11 18:29:56 miod Exp $	*/
a939 1
	extern struct boot_info *octeon_boot_info;
@


1.14
log
@Remove evcnt and %b format strings relying upon SEIL extensions. This gives
OCTEON_ETH_DEBUG kernels a chance to build. No functional change for regular
kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxgmx.c,v 1.13 2014/08/11 18:08:17 miod Exp $	*/
d720 1
a720 1
	uint64_t newlink = 0;
d722 2
a723 43
	switch (sc->sc_quirks &
	    (OCTEON_ETH_QUIRKS_SEILX | OCTEON_ETH_QUIRKS_SEILX2PORT0 |
	     OCTEON_ETH_QUIRKS_L2SWPORT)) {
	default:
		/* Inband status does not seem to work */
		newlink = _GMX_PORT_RD8(sc, GMX0_RX0_RX_INBND);
		break;
	case OCTEON_ETH_QUIRKS_SEILX | OCTEON_ETH_QUIRKS_SEILX2PORT0:
		SET(newlink, RXN_RX_INBND_SPEED_125);
		SET(newlink, RXN_RX_INBND_DUPLEX);
		SET(newlink, RXN_RX_INBND_STATUS);
		break;
	case OCTEON_ETH_QUIRKS_L2SWPORT:
		SET(newlink, RXN_RX_INBND_SPEED_125);
		SET(newlink, RXN_RX_INBND_DUPLEX);
		SET(newlink, RXN_RX_INBND_STATUS);
		break;
	case OCTEON_ETH_QUIRKS_SEILX:
		newlink = 0;
		switch (IFM_SUBTYPE(sc->sc_port_mii->mii_media_active)) {
		default:
			SET(newlink, RXN_RX_INBND_SPEED_125);
			break;
		case IFM_100_TX:
			SET(newlink, RXN_RX_INBND_SPEED_25);
			break;
		case IFM_10_T:
			/* XXX how can this happen? */
			SET(newlink, RXN_RX_INBND_SPEED_2_5);
			break;
		}
		SET(newlink,
		    ISSET(sc->sc_port_mii->mii_media_active, IFM_FDX) ?
		    RXN_RX_INBND_DUPLEX : 0);
		SET(newlink,
		    ISSET(sc->sc_port_mii->mii_media_status, IFM_ACTIVE) ?
		    RXN_RX_INBND_STATUS : 0);
		break;
	case OCTEON_ETH_QUIRKS_SEILX2PORT0:
		/* NOTREACHED */
		OCTEON_ETH_KASSERT(0);
		break;
	}
a965 2
	if (sc->sc_quirks & OCTEON_ETH_QUIRKS_SEILX1_REVB)
		rx_frm_ctl |= RXN_FRM_CTL_PRE_ALIGN;
d980 2
a981 8
	switch (sc->sc_quirks & OCTEON_ETH_QUIRKS_SEILX) {
	case OCTEON_ETH_QUIRKS_SEILX:
		/*
		 * Table.4-6, Summary of ASX Registers, SEIL_HS_v03;
		 */
		clk_tx_setting = 0;
		clk_rx_setting = 0;
		break;
a986 4
	}

	/* board specific overrides */
	switch (octeon_boot_info->board_type) {
@


1.13
log
@De-static so that my ddb backtrace get closer to reality.
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxgmx.c,v 1.12 2014/05/07 14:44:54 pirofti Exp $	*/
d92 1
d105 2
a108 1
void	cn30xxgmx_intr_evcnt_attach(struct cn30xxgmx_softc *);
a151 9
int octeon_eth_phy_table[] = {
#if defined __seil5__
	0x04, 0x01, 0x02
#else
	/* portwell cam-0100 */
	0x02, 0x03, 0x22
#endif
};

d153 1
a153 9
static void		*cn30xxgmx_intr_drop_ih;
struct evcnt		cn30xxgmx_intr_drop_evcnt =
			    EVCNT_INITIALIZER(EVCNT_TYPE_INTR, NULL, "octeon",
			    "gmx drop intr");
struct evcnt		cn30xxgmx_intr_evcnt =
			    EVCNT_INITIALIZER(EVCNT_TYPE_INTR, NULL, "octeon",
			    "gmx intr");
EVCNT_ATTACH_STATIC(cn30xxgmx_intr_drop_evcnt);
EVCNT_ATTACH_STATIC(cn30xxgmx_intr_evcnt);
d179 4
a182 1
	extern struct boot_info *octeon_boot_info;
d185 1
a185 1
	case BOARD_TYPE_UBIQUITI_E100:
a254 1
	cn30xxgmx_intr_evcnt_attach(sc);
d257 2
a258 2
		   ffs64(CIU_INTX_SUM0_GMX_DRP) - 1, 0, IPL_NET,
		   cn30xxgmx_intr_drop, NULL);
a1288 50
/* tx - per unit (gmx0, gmx1, ...) */
static const struct octeon_evcnt_entry cn30xxgmx_intr_evcnt_tx_entries[] = {
#define	_ENTRY(name, type, parent, descr) \
	OCTEON_EVCNT_ENTRY(struct cn30xxgmx_softc, name, type, parent, descr)
	_ENTRY(latecol,		MISC, NULL, "tx late collision"),
	_ENTRY(xsdef,		MISC, NULL, "tx excessive deferral"),
	_ENTRY(xscol,		MISC, NULL, "tx excessive collision"),
	_ENTRY(undflw,		MISC, NULL, "tx underflow"),
	_ENTRY(pkonxa,		MISC, NULL, "tx port addr out-of-range")
#undef	_ENTRY
};

/* rx - per port (gmx0:0, gmx0:1, ...) */
static const struct octeon_evcnt_entry cn30xxgmx_intr_evcnt_rx_entries[] = {
#define	_ENTRY(name, type, parent, descr) \
	OCTEON_EVCNT_ENTRY(struct cn30xxgmx_port_softc, name, type, parent, descr)
	_ENTRY(minerr,		MISC, NULL, "rx min error"),
	_ENTRY(carext,		MISC, NULL, "rx carrier error"),
	_ENTRY(maxerr,		MISC, NULL, "rx max error"),
	_ENTRY(jabber,		MISC, NULL, "rx jabber error"),
	_ENTRY(fcserr,		MISC, NULL, "rx fcs error"),
	_ENTRY(alnerr,		MISC, NULL, "rx align error"),
	_ENTRY(lenerr,		MISC, NULL, "rx length error"),
	_ENTRY(rcverr,		MISC, NULL, "rx receive error"),
	_ENTRY(skperr,		MISC, NULL, "rx skip error"),
	_ENTRY(niberr,		MISC, NULL, "rx nibble error"),
	_ENTRY(ovrerr,		MISC, NULL, "rx overflow error"),
	_ENTRY(pckterr,		MISC, NULL, "rx packet error"),
	_ENTRY(rsverr,		MISC, NULL, "rx reserved opcode error"),
	_ENTRY(falerr,		MISC, NULL, "rx false carrier error"),
	_ENTRY(coldet,		MISC, NULL, "rx collision detect"),
	_ENTRY(ifgerr,		MISC, NULL, "rx ifg error")
#undef	_ENTRY
};

void
cn30xxgmx_intr_evcnt_attach(struct cn30xxgmx_softc *sc)
{
	struct cn30xxgmx_port_softc *port_sc;
	int i;

	OCTEON_EVCNT_ATTACH_EVCNTS(sc, cn30xxgmx_intr_evcnt_tx_entries,
	    sc->sc_dev.dv_xname);
	for (i = 0; i < sc->sc_nports; i++) {
		port_sc = &sc->sc_ports[i];
		OCTEON_EVCNT_ATTACH_EVCNTS(port_sc, cn30xxgmx_intr_evcnt_rx_entries,
		    sc->sc_dev.dv_xname);
	}
}

d1292 1
a1292 1
	struct cn30xxgmx_port_softc *sc = NULL/* XXX gcc */;
d1294 1
a1294 3
	uint64_t reg = 0/* XXX gcc */;

	cn30xxgmx_intr_evcnt.ev_count++;
d1303 1
a1303 11
		printf("%s: GMX_TX_INT_REG=0x%016" PRIx64 "\n", __func__, reg);
	if (reg & TX_INT_REG_LATE_COL)
		OCTEON_EVCNT_INC(sc->sc_port_gmx, latecol);
	if (reg & TX_INT_REG_XSDEF)
		OCTEON_EVCNT_INC(sc->sc_port_gmx, xsdef);
	if (reg & TX_INT_REG_XSCOL)
		OCTEON_EVCNT_INC(sc->sc_port_gmx, xscol);
	if (reg & TX_INT_REG_UNDFLW)
		OCTEON_EVCNT_INC(sc->sc_port_gmx, undflw);
	if (reg & TX_INT_REG_PKO_NXA)
		OCTEON_EVCNT_INC(sc->sc_port_gmx, pkonxa);
d1311 1
a1311 31
			printf("%s: GMX_RX_INT_REG=0x%016" PRIx64 "\n", __func__, reg);
		if (reg & RXN_INT_REG_MINERR)
			OCTEON_EVCNT_INC(sc, minerr);
		if (reg & RXN_INT_REG_CAREXT)
			OCTEON_EVCNT_INC(sc, carext);
		if (reg & RXN_INT_REG_JABBER)
			OCTEON_EVCNT_INC(sc, jabber);
		if (reg & RXN_INT_REG_FCSERR)
			OCTEON_EVCNT_INC(sc, fcserr);
		if (reg & RXN_INT_REG_ALNERR)
			OCTEON_EVCNT_INC(sc, alnerr);
		if (reg & RXN_INT_REG_LENERR)
			OCTEON_EVCNT_INC(sc, lenerr);
		if (reg & RXN_INT_REG_RCVERR)
			OCTEON_EVCNT_INC(sc, rcverr);
		if (reg & RXN_INT_REG_SKPERR)
			OCTEON_EVCNT_INC(sc, skperr);
		if (reg & RXN_INT_REG_NIBERR)
			OCTEON_EVCNT_INC(sc, niberr);
		if (reg & RXN_INT_REG_OVRERR)
			OCTEON_EVCNT_INC(sc, ovrerr);
		if (reg & RXN_INT_REG_PCTERR)
			OCTEON_EVCNT_INC(sc, pckterr);
		if (reg & RXN_INT_REG_RSVERR)
			OCTEON_EVCNT_INC(sc, rsverr);
		if (reg & RXN_INT_REG_FALERR)
			OCTEON_EVCNT_INC(sc, falerr);
		if (reg & RXN_INT_REG_COLDET)
			OCTEON_EVCNT_INC(sc, coldet);
		if (reg & RXN_INT_REG_IFGERR)
			OCTEON_EVCNT_INC(sc, ifgerr);
a1314 10
#ifdef notyet
void
cn30xxgmx_intr_rml_gmx1(void)
{
	uint64_t reg = 0/* XXX gcc */;

		/* GMX1_RXn_INT_REG or GMX1_TXn_INT_REG */
}
#endif

a1318 1
	cn30xxgmx_intr_drop_evcnt.ev_count++;
d1378 1
a1378 1
#define	_ENTRY(x)	{ #x, x##_BITS, x }
a1381 1
	const char *format;
d1385 1
a1385 1
static const struct cn30xxgmx_dump_reg_ cn30xxgmx_dump_regs_[] = {
d1420 1
a1420 1
static const struct cn30xxgmx_dump_reg_ cn30xxgmx_dump_port_regs_[] = {
d1457 1
a1457 1
static const struct cn30xxgmx_dump_reg_ cn30xxgmx_dump_port_stats_[] = {
d1479 16
a1494 16
void		cn30xxgmx_dump_common(void);
void		cn30xxgmx_dump_port0(void);
void		cn30xxgmx_dump_port1(void);
void		cn30xxgmx_dump_port2(void);
void		cn30xxgmx_dump_port0_regs(void);
void		cn30xxgmx_dump_port1_regs(void);
void		cn30xxgmx_dump_port2_regs(void);
void		cn30xxgmx_dump_port0_stats(void);
void		cn30xxgmx_dump_port1_stats(void);
void		cn30xxgmx_dump_port2_stats(void);
void		cn30xxgmx_dump_port_regs(int);
void		cn30xxgmx_dump_port_stats(int);
void		cn30xxgmx_dump_common_x(int, const struct cn30xxgmx_dump_reg_ *, size_t);
void		cn30xxgmx_dump_port_x(int, const struct cn30xxgmx_dump_reg_ *, size_t);
void		cn30xxgmx_dump_x(int, const struct cn30xxgmx_dump_reg_ *, size_t, size_t, int);
void		cn30xxgmx_dump_x_index(char *, size_t, int);
a1577 1
	char buf[512];
a1583 5
		if (reg->format == NULL)
			snprintf(buf, sizeof(buf), "%016" PRIx64, tmp);
		else
			bitmask_snprintf(tmp, reg->format, buf, sizeof(buf));

d1588 1
a1588 1
		printf("\t%-24s: %s\n", name, buf);
d1590 21
@


1.12
log
@Fix whitespace mistakes.
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxgmx.c,v 1.11 2013/10/30 20:48:04 pirofti Exp $	*/
d88 16
a103 16
static int	cn30xxgmx_match(struct device *, void *, void *);
static void	cn30xxgmx_attach(struct device *, struct device *, void *);
static int	cn30xxgmx_print(void *, const char *);
static int	cn30xxgmx_submatch(struct device *, void *, void *);
static int	cn30xxgmx_init(struct cn30xxgmx_softc *);
static int	cn30xxgmx_rx_frm_ctl_xable(struct cn30xxgmx_port_softc *,
		    uint64_t, int);
static int	cn30xxgmx_rgmii_enable(struct cn30xxgmx_port_softc *, int);
static int	cn30xxgmx_rgmii_speed(struct cn30xxgmx_port_softc *);
static int	cn30xxgmx_rgmii_speed_newlink(struct cn30xxgmx_port_softc *,
		    uint64_t *);
static int	cn30xxgmx_rgmii_speed_speed(struct cn30xxgmx_port_softc *);
static int	cn30xxgmx_rgmii_timing(struct cn30xxgmx_port_softc *);
static int	cn30xxgmx_rgmii_set_mac_addr(struct cn30xxgmx_port_softc *,
		    uint8_t *, uint64_t);
static int	cn30xxgmx_rgmii_set_filter(struct cn30xxgmx_port_softc *);
d106 6
a111 6
void		cn30xxgmx_intr_evcnt_attach(struct cn30xxgmx_softc *);
void		cn30xxgmx_dump(void);
void		cn30xxgmx_debug_reset(void);
int		cn30xxgmx_intr_drop(void *);
static int	cn30xxgmx_rgmii_speed_newlink_log(
		    struct cn30xxgmx_port_softc *, uint64_t);
d178 1
a178 1
static int
d191 1
a191 1
static int
d209 1
a209 1
static void
d275 1
a275 1
static int
d295 1
a295 1
static int
d303 1
a303 1
static int
d448 1
a448 1
static int
d469 1
a469 1
static int
d547 1
a547 1
static int
d663 1
a663 1
static int
d677 1
a677 1
static int
d729 1
a729 1
static int
d784 1
a784 1
static int
d857 1
a857 1
static int
d991 1
a991 1
static int
d1064 1
a1064 1
static int
d1084 1
a1084 1
static int
d1223 2
a1224 2
static int	cn30xxgmx_setfilt_addrs(struct cn30xxgmx_port_softc *,
		    size_t, uint8_t **);
d1265 1
a1265 1
static int
d1298 1
a1298 1
void			cn30xxgmx_intr_rml_gmx0(void);
d1300 1
a1300 1
int			cn30xxgmx_intr_rml_verbose;
@


1.11
log
@Remove redundant base adrress printing during attach.

Okay jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxgmx.c,v 1.10 2013/10/24 22:32:29 jasper Exp $	*/
d1050 1
a1050 1
	
@


1.10
log
@no need to inform us about every state and link speed change, so move that
under a debug ifdef.

ok pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxgmx.c,v 1.9 2013/10/23 09:35:36 mpi Exp $	*/
d290 1
a290 2
	printf(" address=0x%016llx: %s", ga->ga_addr,
	    types[ga->ga_port_type]);
@


1.9
log
@Do not print the higher address of the muticast range in debug mode,
since in this case it is always the same as the lower address (not a
real range).

ok pirofti@@, jasper@@, bcallah@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxgmx.c,v 1.8 2013/10/22 14:06:08 bcallah Exp $	*/
a98 2
static int	cn30xxgmx_rgmii_speed_newlink_log(
		    struct cn30xxgmx_port_softc *, uint64_t);
d110 2
d692 1
d694 1
d784 1
d856 1
@


1.8
log
@Replace some backwards compat functions with the current ones; the old
ones were removed some time ago.

Noticed by William Orr <will AT worrbase DOT com>

ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxgmx.c,v 1.7 2013/09/19 00:15:59 jmatthew Exp $	*/
d1123 1
a1123 2
			dprintf("%d: lo(%02x:%02x:%02x:%02x:%02x:%02x) - "
			    "hi(%02x:%02x:%02x:%02x:%02x:%02x)\n",
d1127 1
a1127 4
			    enm->enm_addrlo[4], enm->enm_addrlo[5],
			    enm->enm_addrhi[0], enm->enm_addrhi[1],
			    enm->enm_addrhi[2], enm->enm_addrhi[3],
			    enm->enm_addrhi[4], enm->enm_addrhi[5]);
@


1.7
log
@get ethernet working on the edgerouter lite

- add atphy(4) to configs
- allow separate rx and tx clock settings
- add phy mapping for the erl
- add tx/rx clock settings for erl

ok miod@@ bcallah@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxgmx.c,v 1.6 2013/09/16 20:52:13 jmatthew Exp $	*/
d1434 1
a1434 1
	octeon_write_csr(CIU_INT0_SUM0, CIU_INTX_SUM0_GMX_DRP);
@


1.6
log
@work out phy addresses before attaching cnmac and pass them to mii_attach
rather than hiding them in the mii read/write functions.

ok dlg@@ jasper@@ bcallah@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxgmx.c,v 1.5 2012/12/05 23:20:14 deraadt Exp $	*/
d44 1
d194 13
a206 3
	if (port >= nitems(octeon_eth_phy_table))
		return -1;
	return octeon_eth_phy_table[port];
d991 3
a993 1
	int clk_set_setting;
d1038 2
a1039 1
		clk_set_setting = 0;
d1043 10
a1052 1
		clk_set_setting = 24;
d1056 1
a1056 1
	cn30xxasx_clk_set(sc->sc_port_asx, clk_set_setting);
@


1.5
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxgmx.c,v 1.4 2012/11/28 01:15:33 brad Exp $	*/
d149 9
d190 8
d243 3
@


1.4
log
@- Use IF_Gbps(1) instead of IF_Mbps(1000)
- Use IF_Mbps() instead of multiplying the link speed by a bare value
- Remove a useless comment as baudrate is already handled properly
- Remove some commented out bits of code
- Use IF_Mbps() instead of the bare value

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxgmx.c,v 1.3 2011/07/03 20:31:39 yasuoka Exp $	*/
a33 2
#include <sys/cdefs.h>

a38 1
#include <sys/cdefs.h>
@


1.3
log
@Rewrite the multicast handling for OpenBSD.  From brad@@

ok and tested yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxgmx.c,v 1.2 2011/06/24 02:13:23 yasuoka Exp $	*/
d675 1
a675 1
		baudrate = IF_Mbps(1000);
@


1.2
log
@Remove SET/CLR/ISSET macros from Octeon code.  The kernel already provides
these macros.

This diff from brad@@
built test and ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cn30xxgmx.c,v 1.1 2011/06/16 11:22:30 syuu Exp $	*/
d1045 1
d1050 1
a1052 1
	uint64_t cam_en = 0x01ULL; /* XXX */
d1056 9
a1064 4
	if (ISSET(ifp->if_flags, IFF_BROADCAST)) {
		dprintf("accept broadcast\n");
		SET(ctl, RXN_ADR_CTL_BCST);
	}
d1066 1
a1066 1
		dprintf("promiscas(reject cam)\n");
d1068 5
a1073 4
		dprintf("not promiscas(accept cam)\n");
		SET(ctl, RXN_ADR_CTL_CAM_MODE);
	}

d1075 30
a1104 4
	/*
	 * Note first entry is self MAC address; other 7 entires are available
	 * for multicast addresses.
	 */
d1106 3
a1108 19
	ETHER_FIRST_MULTI(step, sc->sc_port_ac, enm);
	while (enm != NULL) {
		int i;

		dprintf("%d: lo(%02x:%02x:%02x:%02x:%02x:%02x) - "
		    "hi(%02x:%02x:%02x:%02x:%02x:%02x)\n",
		    multi + 1,
		    enm->enm_addrlo[0], enm->enm_addrlo[1],
		    enm->enm_addrlo[2], enm->enm_addrlo[3],
		    enm->enm_addrlo[4], enm->enm_addrlo[5],
		    enm->enm_addrhi[0], enm->enm_addrhi[1],
		    enm->enm_addrhi[2], enm->enm_addrhi[3],
		    enm->enm_addrhi[4], enm->enm_addrhi[5]);
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			dprintf("all multicast\n");
			SET(ifp->if_flags, IFF_ALLMULTI);
			goto setmulti;
		}
		multi++;
d1110 1
a1110 4
		/* XXX */
		if (multi >= 8) {
			SET(ifp->if_flags, IFF_ALLMULTI);
			goto setmulti;
d1113 4
a1116 1
		SET(cam_en, 1ULL << multi); /* XXX */
d1118 1
a1118 18
		for (i = 0; i < 6; i++) {
			uint64_t tmp;

			/* XXX */
			tmp = _GMX_PORT_RD8(sc, cn30xxgmx_rx_adr_cam_regs[i]);
			CLR(tmp, 0xffULL << (8 * multi));
			SET(tmp, (uint64_t)enm->enm_addrlo[i] << (8 * multi));
			_GMX_PORT_WR8(sc, cn30xxgmx_rx_adr_cam_regs[i], tmp);
			    
		}
		for (i = 0; i < 6; i++)
			dprintf("cam%d = %016llx\n", i,
			    _GMX_PORT_RD8(sc, cn30xxgmx_rx_adr_cam_regs[i]));
		ETHER_NEXT_MULTI(step, enm);
	}
	CLR(ifp->if_flags, IFF_ALLMULTI);

	OCTEON_ETH_KASSERT(enm == NULL);
d1120 7
a1126 7
	/*
	 * XXX
	 * Never use DMAC filter for multicast addresses, but register only
	 * single entry for self address.  FreeBSD code do so.
	 */
	SET(ifp->if_flags, IFF_ALLMULTI);
	goto setmulti;
a1127 22

setmulti:
	if (ISSET(ifp->if_flags, IFF_ALLMULTI) ||
	    ISSET(ifp->if_flags, IFF_PROMISC)) {
		/* XXX */
		dprintf("accept all multicast\n");
		SET(ctl, RXN_ADR_CTL_MCST_ACCEPT);
	} else if (multi) {
		/* XXX */
		dprintf("use cam\n");
		SET(ctl, RXN_ADR_CTL_MCST_AFCAM);
	} else {
		/* XXX */
		dprintf("reject all multicast\n");
		SET(ctl, RXN_ADR_CTL_MCST_REJECT);
	}

	/* XXX */
	if (ISSET(ifp->if_flags, IFF_PROMISC)) {
		cam_en = 0x00ULL;
	} else if (ISSET(ifp->if_flags, IFF_ALLMULTI)) {
		cam_en = 0x01ULL;
@


1.1
log
@Ethernet driver merged from IIJ's contribution code.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a56 6

#ifndef SET
#define	SET(t, f)	((t) |= (f))
#define	ISSET(t, f)	((t) & (f))
#define	CLR(t, f)	((t) &= ~(f))
#endif
@

