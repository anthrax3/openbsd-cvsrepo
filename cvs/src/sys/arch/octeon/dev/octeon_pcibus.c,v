head	1.19;
access;
symbols
	OPENBSD_6_2_BASE:1.19
	OPENBSD_6_1:1.19.0.4
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.17.0.4
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.12.0.4
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.6.0.8
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5;
locks; strict;
comment	@ * @;


1.19
date	2016.10.21.12.36.19;	author pirofti;	state Exp;
branches;
next	1.18;
commitid	AakGlE74xpqm7Wta;

1.18
date	2016.10.21.07.55.48;	author pirofti;	state Exp;
branches;
next	1.17;
commitid	629WDMoGndN8kjG6;

1.17
date	2015.10.03.13.53.54;	author semarie;	state Exp;
branches;
next	1.16;
commitid	83CdXFKzYb5RT1Si;

1.16
date	2014.08.11.19.00.50;	author miod;	state Exp;
branches;
next	1.15;
commitid	WSyMUxaCd6qqqO0W;

1.15
date	2014.07.12.18.44.42;	author tedu;	state Exp;
branches;
next	1.14;
commitid	uKVPYMN2MLxdZxzH;

1.14
date	2014.05.11.09.23.49;	author jasper;	state Exp;
branches;
next	1.13;

1.13
date	2014.05.10.22.25.16;	author jasper;	state Exp;
branches;
next	1.12;

1.12
date	2013.08.29.07.56.50;	author pirofti;	state Exp;
branches;
next	1.11;

1.11
date	2013.08.29.07.53.07;	author pirofti;	state Exp;
branches;
next	1.10;

1.10
date	2013.06.02.19.47.01;	author jasper;	state Exp;
branches;
next	1.9;

1.9
date	2013.06.01.01.16.20;	author jasper;	state Exp;
branches;
next	1.8;

1.8
date	2013.06.01.01.02.53;	author jasper;	state Exp;
branches;
next	1.7;

1.7
date	2013.03.21.09.25.48;	author jasper;	state Exp;
branches;
next	1.6;

1.6
date	2011.05.08.13.24.55;	author syuu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.04.20.01.05;	author syuu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.04.17.06.31;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.04.16.46.35;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2010.11.23.18.46.29;	author syuu;	state Exp;
branches;
next	1.1;

1.1
date	2010.10.28.22.52.10;	author syuu;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Revert previous commit.

I was building in the wrong tree and got confused. Sorry!
@
text
@/*	$OpenBSD: octeon_pcibus.c,v 1.17 2015/10/03 13:53:54 semarie Exp $	*/
/*	$NetBSD: bonito_mainbus.c,v 1.11 2008/04/28 20:23:10 martin Exp $	*/
/*	$NetBSD: bonito_pci.c,v 1.5 2008/04/28 20:23:28 martin Exp $	*/

/*
 * Copyright (c) 2009, 2010 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*-
 * Copyright (c) 2001 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/extent.h>
#include <sys/malloc.h>

#include <machine/autoconf.h>
#include <machine/bus.h>
#include <machine/intr.h>
#include <machine/octeonvar.h>

#include <dev/pci/pcidevs.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/ppbreg.h>

#include <octeon/dev/iobusvar.h>
#include <octeon/dev/octeon_pcibus.h>
#include <octeon/dev/octeon_pcibusvar.h>

#include <uvm/uvm_extern.h>

#ifdef DEBUG
#define OCTEON_PCIDEBUG(p) printf p
#else
#define OCTEON_PCIDEBUG(p)
#endif

#define REG_READ32(addr)	(*(volatile uint32_t *)(addr))
#define REG_WRITE32(addr, data)	(*(volatile uint32_t *)(addr) = (uint32_t)(data))

int	octeon_pcibus_match(struct device *, void *, void *);
void	octeon_pcibus_attach(struct device *, struct device *, void *);
int	octeon_pcibus_intr_map(int dev, int fn, int pin);

const struct cfattach pcibus_ca = {
	sizeof(struct octeon_pcibus_softc),
	octeon_pcibus_match, octeon_pcibus_attach
};

struct cfdriver pcibus_cd = {
	NULL, "pcibus", DV_DULL
};

bus_addr_t  octeon_pcibus_pa_to_device(paddr_t);
paddr_t     octeon_pcibus_device_to_pa(bus_addr_t);
void        octeon_pcibus_attach_hook(struct device *, struct device *,
                                      struct pcibus_attach_args *);
int         octeon_pcibus_bus_maxdevs(void *, int);
pcitag_t    octeon_pcibus_make_tag(void *, int, int, int);
void        octeon_pcibus_decompose_tag(void *, pcitag_t, int *, int *, int *);
int	    octeon_pcibus_pci_conf_size(void *, pcitag_t);
pcireg_t    octeon_pcibus_pci_conf_read(void *, pcitag_t, int);
void        octeon_pcibus_pci_conf_write(void *, pcitag_t, int, pcireg_t);
int         octeon_pcibus_pci_intr_map(struct pci_attach_args *,
                                       pci_intr_handle_t *);
const char *octeon_pcibus_pci_intr_string(void *, pci_intr_handle_t);
void       *octeon_pcibus_pci_intr_establish(void *, pci_intr_handle_t, int,
                                             int (*)(void *), void *, char *);
void        octeon_pcibus_pci_intr_disestablish(void *, void *);


struct machine_bus_dma_tag octeon_pcibus_bus_dma_tag = {
	._cookie = NULL,
	._dmamap_create =	_dmamap_create,
	._dmamap_destroy =	_dmamap_destroy,
	._dmamap_load =		_dmamap_load,
	._dmamap_load_mbuf =	_dmamap_load_mbuf,
	._dmamap_load_uio =	_dmamap_load_uio,
	._dmamap_load_raw =	_dmamap_load_raw,
	._dmamap_load_buffer =	_dmamap_load_buffer,
	._dmamap_unload =	_dmamap_unload,
	._dmamap_sync =		_dmamap_sync,
	._dmamem_alloc =	_dmamem_alloc,
	._dmamem_free =		_dmamem_free,
	._dmamem_map =		_dmamem_map,
	._dmamem_unmap =	_dmamem_unmap,
	._dmamem_mmap =		_dmamem_mmap,
	._pa_to_device =	octeon_pcibus_pa_to_device,
	._device_to_pa =	octeon_pcibus_device_to_pa
};

int octeon_pcibus_io_map(bus_space_tag_t, bus_addr_t, bus_size_t, int,
    bus_space_handle_t *);
int octeon_pcibus_mem_map(bus_space_tag_t, bus_addr_t, bus_size_t, int,
    bus_space_handle_t *);

#define _OCTEON_PCIBUS_PCIIO_BASE	0x00001000
#define _OCTEON_PCIBUS_PCIIO_SIZE	0x08000000
#define _OCTEON_PCIBUS_PCIMEM_BASE	0x80000000
#define _OCTEON_PCIBUS_PCIMEM_SIZE	0x40000000

struct mips_bus_space octeon_pcibus_pci_io_space_tag = {
	.bus_base = PHYS_TO_XKPHYS(_OCTEON_PCIBUS_PCIIO_BASE, CCA_NC),
	.bus_private = NULL,
	._space_read_1 =	generic_space_read_1,
	._space_write_1 =	generic_space_write_1,
	._space_read_2 =	generic_space_read_2,
	._space_write_2 =	generic_space_write_2,
	._space_read_4 =	generic_space_read_4,
	._space_write_4 =	generic_space_write_4,
	._space_read_8 =	generic_space_read_8,
	._space_write_8 =	generic_space_write_8,
	._space_read_raw_2 =	generic_space_read_raw_2,
	._space_write_raw_2 =	generic_space_write_raw_2,
	._space_read_raw_4 =	generic_space_read_raw_4,
	._space_write_raw_4 =	generic_space_write_raw_4,
	._space_read_raw_8 =	generic_space_read_raw_8,
	._space_write_raw_8 =	generic_space_write_raw_8,
	._space_map =		octeon_pcibus_io_map,
	._space_unmap =		generic_space_unmap,
	._space_subregion =	generic_space_region,
	._space_vaddr =		generic_space_vaddr
};

struct mips_bus_space octeon_pcibus_pci_mem_space_tag = {
	.bus_base = PHYS_TO_XKPHYS(_OCTEON_PCIBUS_PCIMEM_BASE, CCA_NC),
	.bus_private = NULL,
	._space_read_1 =	generic_space_read_1,
	._space_write_1 =	generic_space_write_1,
	._space_read_2 =	generic_space_read_2,
	._space_write_2 =	generic_space_write_2,
	._space_read_4 =	generic_space_read_4,
	._space_write_4 =	generic_space_write_4,
	._space_read_8 =	generic_space_read_8,
	._space_write_8 =	generic_space_write_8,
	._space_read_raw_2 =	generic_space_read_raw_2,
	._space_write_raw_2 =	generic_space_write_raw_2,
	._space_read_raw_4 =	generic_space_read_raw_4,
	._space_write_raw_4 =	generic_space_write_raw_4,
	._space_read_raw_8 =	generic_space_read_raw_8,
	._space_write_raw_8 =	generic_space_write_raw_8,
	._space_map =		octeon_pcibus_mem_map,
	._space_unmap =		generic_space_unmap,
	._space_subregion =	generic_space_region,
	._space_vaddr =		generic_space_vaddr
};

int
octeon_pcibus_match(struct device *parent, void *vcf, void *aux)
{
	struct iobus_attach_args *aa = aux;

	if ((octeon_boot_info->config_flags & BOOTINFO_CFG_FLAG_PCI_HOST) == 0) {
		OCTEON_PCIDEBUG(("%s, no PCI host function detected.\n", __func__));
		return 0;
	}

	if (strcmp(aa->aa_name, pcibus_cd.cd_name) == 0)
		return 1;

	return 0;
}

void
octeon_pcibus_attach(struct device *parent, struct device *self, void *aux)
{
	struct octeon_pcibus_softc *sc;
	struct pcibus_attach_args pba;

	sc = (struct octeon_pcibus_softc *)self;
	sc->sc_aa = aux;

	printf("\n");

	/*
	 * Attach PCI bus.
	 */
	sc->sc_pc.pc_attach_hook = octeon_pcibus_attach_hook;
	sc->sc_pc.pc_bus_maxdevs = octeon_pcibus_bus_maxdevs;
	sc->sc_pc.pc_make_tag = octeon_pcibus_make_tag;
	sc->sc_pc.pc_decompose_tag = octeon_pcibus_decompose_tag;

	sc->sc_pc.pc_conf_v = sc;
	sc->sc_pc.pc_conf_size = octeon_pcibus_pci_conf_size;
	sc->sc_pc.pc_conf_read = octeon_pcibus_pci_conf_read;
	sc->sc_pc.pc_conf_write = octeon_pcibus_pci_conf_write;

	sc->sc_pc.pc_intr_v = sc;
	sc->sc_pc.pc_intr_map = octeon_pcibus_pci_intr_map;
	sc->sc_pc.pc_intr_string = octeon_pcibus_pci_intr_string;
	sc->sc_pc.pc_intr_establish = octeon_pcibus_pci_intr_establish;
	sc->sc_pc.pc_intr_disestablish = octeon_pcibus_pci_intr_disestablish;

	bzero(&pba, sizeof pba);
	pba.pba_busname = "pci";
	pba.pba_iot = &octeon_pcibus_pci_io_space_tag;
	pba.pba_memt = &octeon_pcibus_pci_mem_space_tag;
	pba.pba_dmat = &octeon_pcibus_bus_dma_tag;
	pba.pba_pc = &sc->sc_pc;
	pba.pba_domain = pci_ndomains++;
	pba.pba_bus = 0;
	pba.pba_ioex = octeon_pcibus_get_resource_extent(&sc->sc_pc, 1);
	pba.pba_memex = octeon_pcibus_get_resource_extent(&sc->sc_pc, 0);

	config_found(&sc->sc_dev, &pba, octeon_pcibus_print);
}

bus_addr_t
octeon_pcibus_pa_to_device(paddr_t pa)
{
	OCTEON_PCIDEBUG(("%s:%d: pa=%p\n", __func__, __LINE__, (void *)pa));

	return pa & 0x1ffffffffffffUL;
}

paddr_t
octeon_pcibus_device_to_pa(bus_addr_t addr)
{
	OCTEON_PCIDEBUG(("%s:%d: addr=%lx\n", __func__, __LINE__, addr));

	return PHYS_TO_XKPHYS(addr, CCA_NC);
}

int
octeon_pcibus_print(void *aux, const char *pnp)
{
	struct pcibus_attach_args *pba = aux;

	if (pnp)
		printf("%s at %s", pba->pba_busname, pnp);
	printf(" bus %d", pba->pba_bus);

	return UNCONF;
}

/*
 * various PCI helpers
 */
void
octeon_pcibus_attach_hook(struct device *parent, struct device *self,
    struct pcibus_attach_args *pba)
{
}

/*
 * PCI configuration space access routines
 */
int
octeon_pcibus_bus_maxdevs(void *v, int busno)
{
	return (32);
}

pcitag_t
octeon_pcibus_make_tag(void *unused, int b, int d, int f)
{
	return (b << 16) | (d << 11) | (f << 8);
}

void
octeon_pcibus_decompose_tag(void *unused, pcitag_t tag, int *bp, int *dp, int *fp)
{
	if (bp != NULL)
		*bp = (tag >> 16) & 0xff;
	if (dp != NULL)
		*dp = (tag >> 11) & 0x1f;
	if (fp != NULL)
		*fp = (tag >> 8) & 0x7;
}

int
octeon_pcibus_pci_conf_size(void *v, pcitag_t tag)
{
	return PCI_CONFIG_SPACE_SIZE;
}

pcireg_t
octeon_pcibus_pci_conf_read(void *v, pcitag_t tag, int offset)
{
	pcireg_t data;
	uint64_t cfgoff;

	if (tag == 0){
		if (offset & 0x4){
			cfgoff = OCTEON_PCI_CFG1 + (offset & 0xfff8);
		} else {
			cfgoff = OCTEON_PCI_CFG0 + (offset & 0xfff8);
		}
	} else {
		cfgoff = tag + offset;
		if (offset & 0x4) {
			cfgoff = OCTEON_PCI_CONFIG_BASE1 + (cfgoff & 0xfffffff8);
		} else {
			cfgoff = OCTEON_PCI_CONFIG_BASE0 + (cfgoff & 0xfffffff8);
		}
	}

	data = REG_READ32(cfgoff);
	return data;
}

void
octeon_pcibus_pci_conf_write(void *v, pcitag_t tag, int offset, pcireg_t data)
{
	uint64_t cfgoff;

	if (tag == 0){
		if (offset & 0x4){
			cfgoff = OCTEON_PCI_CFG1 + (offset & 0xfff8);
		} else {
			cfgoff = OCTEON_PCI_CFG0 + (offset & 0xfff8);
		}
	} else {
		cfgoff = tag + offset;
		if (offset & 0x4){
			cfgoff = OCTEON_PCI_CONFIG_BASE1 + (cfgoff & 0xfffffff8);
		} else {
			cfgoff = OCTEON_PCI_CONFIG_BASE0 + (cfgoff & 0xfffffff8);
		}
	}

	REG_WRITE32(cfgoff, data);
}


/*
 * PCI Interrupt handling
 */
int
octeon_pcibus_pci_intr_map(struct pci_attach_args *pa, pci_intr_handle_t *ihp)
{
#if 0
	struct octeon_pcibus_softc *sc = pa->pa_pc->pc_intr_v;
#endif
	int bus, dev, fn, pin;

	*ihp = (pci_intr_handle_t)-1;

	if (pa->pa_intrpin == 0)	/* no interrupt needed */
		return 1;

#ifdef DIAGNOSTIC
	if (pa->pa_intrpin > 4) {
		printf("%s: bad interrupt pin %d\n", __func__, pa->pa_intrpin);
		return 1;
	}
#endif

	pci_decompose_tag(pa->pa_pc, pa->pa_tag, &bus, &dev, &fn);
	if (pa->pa_bridgetag) {
		pin = PPB_INTERRUPT_SWIZZLE(pa->pa_rawintrpin, dev);
		*ihp = pa->pa_bridgeih[pin - 1];
	} else {
		if (bus == 0)
			*ihp = octeon_pcibus_intr_map(dev, fn, pa->pa_intrpin);

		if (*ihp == (pci_intr_handle_t)-1)
			return 1;
	}

	return 0;
}

const char *
octeon_pcibus_pci_intr_string(void *cookie, pci_intr_handle_t ih)
{
	static char irqstr[sizeof("irq 0123456789")];

	snprintf(irqstr, sizeof irqstr, "irq %ld", ih);
	return irqstr;
}

void *
octeon_pcibus_pci_intr_establish(void *cookie, pci_intr_handle_t ih, int level,
    int (*cb)(void *), void *cbarg, char *name)
{
	return octeon_intr_establish(ih, level, cb, cbarg, name);
}

void
octeon_pcibus_pci_intr_disestablish(void *cookie, void *ihp)
{
	struct octeon_pcibus_softc *sc;
	struct iobus_attach_args *aa;

	sc = (struct octeon_pcibus_softc *)cookie;
	aa = sc->sc_aa;

// XXX: this cause panic...
//	iobus_intr_disestablish(ihp);
}

/*
 * bus_space mapping routines.
 */
int
octeon_pcibus_io_map(bus_space_tag_t t, bus_addr_t offs, bus_size_t size, int flags,
    bus_space_handle_t *bshp)
{
	if (ISSET(flags, BUS_SPACE_MAP_CACHEABLE)) {
		offs +=
		    PHYS_TO_XKPHYS(0, CCA_CACHED) - PHYS_TO_XKPHYS(0, CCA_NC);
	}
	*bshp = t->bus_base + offs;
	return 0;
}

int
octeon_pcibus_mem_map(bus_space_tag_t t, bus_addr_t offs, bus_size_t size, int flags,
    bus_space_handle_t *bshp)
{
	if (ISSET(flags, BUS_SPACE_MAP_CACHEABLE)) {
		offs +=
		    PHYS_TO_XKPHYS(0, CCA_CACHED) - PHYS_TO_XKPHYS(0, CCA_NC);
	}
	*bshp = t->bus_base + offs;
	return 0;
}

/*
 * PCI resource handling
 */
struct extent *
octeon_pcibus_get_resource_extent(pci_chipset_tag_t pc, int io)
{
	struct octeon_pcibus_softc *sc = pc->pc_conf_v;
	struct extent *ex;
	char *exname;
	int exnamesz;

	exnamesz = 1 + 16 + 4;
	exname = malloc(exnamesz, M_DEVBUF, M_NOWAIT);
	if (exname == NULL)
		return NULL;
	snprintf(exname, exnamesz, "%s%s", sc->sc_dev.dv_xname,
	    io ? "_io" : "_mem");

	ex = extent_create(exname, 0, 0xffffffffffffffff, M_DEVBUF, NULL, 0,
	    EX_NOWAIT | EX_FILLED);
	if (ex == NULL)
		goto error;

	if (io) {
		if (extent_free(ex, _OCTEON_PCIBUS_PCIIO_BASE,
		    _OCTEON_PCIBUS_PCIIO_SIZE, EX_NOWAIT) != 0)
			goto error;
	} else {
		if (extent_free(ex, _OCTEON_PCIBUS_PCIMEM_BASE,
		    _OCTEON_PCIBUS_PCIMEM_SIZE, EX_NOWAIT) != 0)
			goto error;
	}

#ifdef DEBUG
	extent_print(ex);
#endif
	return ex;

error:
	if (ex != NULL)
		extent_destroy(ex);
	free(exname, M_DEVBUF, exnamesz);
	return NULL;
}

/*
 * PCI model specific routines
 */

int
octeon_pcibus_intr_map(int dev, int fn, int pin)
{
	return CIU_INT_PCI_INTA + ((pin - 1) & 3);
}
@


1.18
log
@Fix build: declare the pcie read/write routines before using them.
@
text
@a109 3
pcireg_t    octeon_pcibus_pcie_conf_read(void *, pcitag_t, int);
void        octeon_pcibus_pcie_conf_write(void *, pcitag_t, int, pcireg_t);

a135 3
#define _OCTEON_PCIBUS_PCIEIO_BASE	0x10438000
#define _OCTEON_PCIBUS_PCIEMEM_BASE	0x00638000

a140 46
struct mips_bus_space octeon_pcibus_pcie_io_space_tag = {
	.bus_base = PHYS_TO_XKPHYS(_OCTEON_PCIBUS_PCIEIO_BASE, CCA_NC),
	.bus_private = NULL,
	._space_read_1 =	generic_space_read_1,
	._space_write_1 =	generic_space_write_1,
	._space_read_2 =	generic_space_read_2,
	._space_write_2 =	generic_space_write_2,
	._space_read_4 =	generic_space_read_4,
	._space_write_4 =	generic_space_write_4,
	._space_read_8 =	generic_space_read_8,
	._space_write_8 =	generic_space_write_8,
	._space_read_raw_2 =	generic_space_read_raw_2,
	._space_write_raw_2 =	generic_space_write_raw_2,
	._space_read_raw_4 =	generic_space_read_raw_4,
	._space_write_raw_4 =	generic_space_write_raw_4,
	._space_read_raw_8 =	generic_space_read_raw_8,
	._space_write_raw_8 =	generic_space_write_raw_8,
	._space_map =		octeon_pcibus_io_map,
	._space_unmap =		generic_space_unmap,
	._space_subregion =	generic_space_region,
	._space_vaddr =		generic_space_vaddr
};

struct mips_bus_space octeon_pcibus_pcie_mem_space_tag = {
	.bus_base = PHYS_TO_XKPHYS(_OCTEON_PCIBUS_PCIEMEM_BASE, CCA_NC),
	.bus_private = NULL,
	._space_read_1 =	generic_space_read_1,
	._space_write_1 =	generic_space_write_1,
	._space_read_2 =	generic_space_read_2,
	._space_write_2 =	generic_space_write_2,
	._space_read_4 =	generic_space_read_4,
	._space_write_4 =	generic_space_write_4,
	._space_read_8 =	generic_space_read_8,
	._space_write_8 =	generic_space_write_8,
	._space_read_raw_2 =	generic_space_read_raw_2,
	._space_write_raw_2 =	generic_space_write_raw_2,
	._space_read_raw_4 =	generic_space_read_raw_4,
	._space_write_raw_4 =	generic_space_write_raw_4,
	._space_read_raw_8 =	generic_space_read_raw_8,
	._space_write_raw_8 =	generic_space_write_raw_8,
	._space_map =		octeon_pcibus_mem_map,
	._space_unmap =		generic_space_unmap,
	._space_subregion =	generic_space_region,
	._space_vaddr =		generic_space_vaddr
};

d224 2
a225 7
	if (1) {
		sc->sc_pc.pc_conf_read = octeon_pcibus_pcie_conf_read;
		sc->sc_pc.pc_conf_write = octeon_pcibus_pcie_conf_write;
	} else {
		sc->sc_pc.pc_conf_read = octeon_pcibus_pci_conf_read;
		sc->sc_pc.pc_conf_write = octeon_pcibus_pci_conf_write;
	}
d235 2
a236 8
	if (1) {
		pba.pba_iot = &octeon_pcibus_pcie_io_space_tag;
		pba.pba_memt = &octeon_pcibus_pcie_mem_space_tag;
		pba.pba_bus = 1;
	} else {
		pba.pba_iot = &octeon_pcibus_pci_io_space_tag;
		pba.pba_memt = &octeon_pcibus_pci_mem_space_tag;
	}
a342 44
{
	uint64_t cfgoff;

	if (tag == 0){
		if (offset & 0x4){
			cfgoff = OCTEON_PCI_CFG1 + (offset & 0xfff8);
		} else {
			cfgoff = OCTEON_PCI_CFG0 + (offset & 0xfff8);
		}
	} else {
		cfgoff = tag + offset;
		if (offset & 0x4){
			cfgoff = OCTEON_PCI_CONFIG_BASE1 + (cfgoff & 0xfffffff8);
		} else {
			cfgoff = OCTEON_PCI_CONFIG_BASE0 + (cfgoff & 0xfffffff8);
		}
	}

	REG_WRITE32(cfgoff, data);
}

pcireg_t
octeon_pcibus_pcie_conf_read(void *v, pcitag_t tag, int offset)
{
	pcireg_t data;
	uint64_t cfgoff;

	if (tag == 0){
		return -1;
	} else {
		cfgoff = tag + offset;
		if (offset & 0x4) {
			cfgoff = OCTEON_PCI_CONFIG_BASE1 + (cfgoff & 0xfffffff8);
		} else {
			cfgoff = OCTEON_PCI_CONFIG_BASE0 + (cfgoff & 0xfffffff8);
		}
	}

	data = REG_READ32(cfgoff);
	return data;
}

void
octeon_pcibus_pcie_conf_write(void *v, pcitag_t tag, int offset, pcireg_t data)
@


1.17
log
@correct a memory leak in error code path.

noticed by miod@@
ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: octeon_pcibus.c,v 1.16 2014/08/11 19:00:50 miod Exp $	*/
d110 3
d139 3
d147 46
d276 7
a282 2
	sc->sc_pc.pc_conf_read = octeon_pcibus_pci_conf_read;
	sc->sc_pc.pc_conf_write = octeon_pcibus_pci_conf_write;
d292 8
a299 2
	pba.pba_iot = &octeon_pcibus_pci_io_space_tag;
	pba.pba_memt = &octeon_pcibus_pci_mem_space_tag;
d406 44
@


1.16
log
@Do not extern octeon_boot_info, <machine/octeonvar.h> declares it for you.
@
text
@d1 1
a1 1
/*	$OpenBSD: octeon_pcibus.c,v 1.15 2014/07/12 18:44:42 tedu Exp $	*/
a468 1
	int errors;
d471 1
a471 1
	exname = (char *)malloc(exnamesz, M_DEVBUF, M_NOWAIT);
d480 1
a480 1
		goto out;
a481 2
	exname = NULL;
	errors = 0;
d483 3
a485 3
		if (extent_free(ex, _OCTEON_PCIBUS_PCIIO_BASE, _OCTEON_PCIBUS_PCIIO_SIZE,
		    EX_NOWAIT) != 0)
			errors++;
d487 3
a489 8
		if (extent_free(ex, _OCTEON_PCIBUS_PCIMEM_BASE, _OCTEON_PCIBUS_PCIMEM_SIZE,
		    EX_NOWAIT) != 0)
			errors++;
	}

	if (errors != 0) {
		extent_destroy(ex);
		ex = NULL;
d495 1
d497 5
a501 5
out:
	if (exname != NULL)
		free(exname, M_DEVBUF, 0);

	return ex;
@


1.15
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: octeon_pcibus.c,v 1.14 2014/05/11 09:23:49 jasper Exp $	*/
a190 1
	extern struct boot_info *octeon_boot_info;
@


1.14
log
@hide two printfs behind an ifdef DEBUG; spotted by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: octeon_pcibus.c,v 1.13 2014/05/10 22:25:16 jasper Exp $	*/
d507 1
a507 1
		free(exname, M_DEVBUF);
@


1.13
log
@various format string fixes and remove -Wno-format from octeon

feedback/ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: octeon_pcibus.c,v 1.12 2013/08/29 07:56:50 pirofti Exp $	*/
d251 1
a251 1
	printf("%s:%d: pa=%p\n", __func__, __LINE__, (void *)pa);
d259 1
a259 1
	printf("%s:%d: addr=%lx\n", __func__, __LINE__, addr);
@


1.12
log
@Ditch useless variable during attach.

Okay miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: octeon_pcibus.c,v 1.11 2013/08/29 07:53:07 pirofti Exp $	*/
d251 1
a251 1
	printf("%s:%d: pa=%p\n", __func__, __LINE__, pa);
d259 1
a259 1
	printf("%s:%d: addr=%p\n", __func__, __LINE__, addr);
d409 1
a409 1
	snprintf(irqstr, sizeof irqstr, "irq %d", ih);
@


1.11
log
@Fix attach messages format for the pcibus.

Before:
pcibus0 at iobus0 irq 0pci0 at pcibus0 bus 0

After:
pcibus0 at iobus0 irq 0
pci0 at pcibus0 bus 0

Found on my DSR-500. Okay miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: octeon_pcibus.c,v 1.10 2013/06/02 19:47:01 jasper Exp $	*/
a207 1
	struct iobus_attach_args *aa;
d211 1
a211 2
	aa = aux;
	sc->sc_aa = aa;
@


1.10
log
@- remove double rcs ids
@
text
@d1 1
a1 1
/*	$OpenBSD: octeon_pcibus.c,v 1.9 2013/06/01 01:16:20 jasper Exp $	*/
d214 2
@


1.9
log
@remove bogus XXX comment, 32 is just the way it is.
@
text
@d1 1
a1 2
/*	$OpenBSD: octeon_pcibus.c,v 1.8 2013/06/01 01:02:53 jasper Exp $	*/
/*	$OpenBSD: octeon_pcibus.c,v 1.8 2013/06/01 01:02:53 jasper Exp $	*/
@


1.8
log
@make the way of doing debug printfs generic
@
text
@d1 2
a2 2
/*	$OpenBSD: octeon_pcibus.c,v 1.7 2013/03/21 09:25:48 jasper Exp $	*/
/*	$OpenBSD: octeon_pcibus.c,v 1.7 2013/03/21 09:25:48 jasper Exp $	*/
d198 1
d292 1
a292 2
	/* XXX */
	return 32;
@


1.7
log
@use boot_info->config_flags to determine if we're running on a host that has
PCI capabilities, instead of blindly trying to attach pci/pcibus.

this fixes a hang on the EdgeRouter Lite (which lacks PCI) and causes no
regressions on the CAM-0100 (which does have PCI, tested by bcallah@@)

ok bcallah@@ chris@@
@
text
@d1 2
a2 2
/*	$OpenBSD: octeon_pcibus.c,v 1.6 2011/05/08 13:24:55 syuu Exp $	*/
/*	$OpenBSD: octeon_pcibus.c,v 1.6 2011/05/08 13:24:55 syuu Exp $	*/
d72 2
a73 6
#if 1
#define	OCTEON_PCIBUS_DEBUG
#endif

#ifdef OCTEON_PCIBUS_DEBUG
#define DEBUG_PRINT(p) printf p
d75 1
a75 1
#define DEBUG_PRINT(p)
d195 1
a195 3
#ifdef OCTEON_PCIBUS_DEBUG
		printf("%s, no PCI host function detected.\n", __func__);
#endif
d502 1
a502 1
#ifdef OCTEON_PCIBUS_DEBUG
@


1.6
log
@obio renamed iobus, moved interrupt handler code to dev/octeon_intr.c
@
text
@d1 2
a2 2
/*	$OpenBSD: octeon_pcibus.c,v 1.5 2010/12/04 20:01:05 syuu Exp $	*/
/*	$OpenBSD: octeon_pcibus.c,v 1.5 2010/12/04 20:01:05 syuu Exp $	*/
d59 1
d196 1
d198 6
@


1.5
log
@correct constant name
@
text
@d1 2
a2 2
/*	$OpenBSD: octeon_pcibus.c,v 1.4 2010/12/04 17:06:31 miod Exp $	*/
/*	$OpenBSD: octeon_pcibus.c,v 1.4 2010/12/04 17:06:31 miod Exp $	*/
d65 1
a65 1
#include <octeon/dev/obiovar.h>
d194 1
a194 1
	struct obio_attach_args *oba = aux;
d196 1
a196 1
	if (strcmp(oba->oba_name, pcibus_cd.cd_name) == 0)
d206 1
a206 1
	struct obio_attach_args *oba;
d210 2
a211 2
	oba = aux;
	sc->sc_oba = oba;
d416 1
a416 1
	return obio_intr_establish(ih, level, cb, cbarg, name);
d423 1
a423 1
	struct obio_attach_args *oba;
d426 1
a426 1
	oba = sc->sc_oba;
d429 1
a429 1
//	obio_intr_disestablish(ihp);
@


1.4
log
@Introduce a new pci routine, pci_conf_size(), which returns the size of a
given pcitag_t configuration address space. Currently, all pci controllers
will return the usual 0x100 bytes of PCI configuration space, but this will
eventually change on PCIe-capable controlers.
ok kettenis@@
@
text
@d1 2
a2 2
/*	$OpenBSD: octeon_pcibus.c,v 1.3 2010/12/04 16:46:35 miod Exp $	*/
/*	$OpenBSD: octeon_pcibus.c,v 1.3 2010/12/04 16:46:35 miod Exp $	*/
d313 1
a313 1
	return PCI_CONFIGURATION_SPACE_SIZE;
@


1.3
log
@Remove pci configuration space acces hook infrastructure, which got copied
from loongson but isn't necessary on octeon.
ok syuu@@
@
text
@d1 2
a2 2
/*	$OpenBSD: octeon_pcibus.c,v 1.2 2010/11/23 18:46:29 syuu Exp $	*/
/*	$OpenBSD: octeon_pcibus.c,v 1.2 2010/11/23 18:46:29 syuu Exp $	*/
d104 1
d145 1
a145 1
bus_space_t octeon_pcibus_pci_io_space_tag = {
d168 1
a168 1
bus_space_t octeon_pcibus_pci_mem_space_tag = {
d222 1
d308 6
@


1.2
log
@Correct interrupt handling
@
text
@d1 2
a2 2
/*	$OpenBSD: octeon_pcibus.c,v 1.1 2010/10/28 22:52:10 syuu Exp $	*/
/*	$OpenBSD: octeon_pcibus.c,v 1.1 2010/10/28 22:52:10 syuu Exp $	*/
a86 1
void	octeon_pcibus_pci_attach_hook(pci_chipset_tag_t pc);
a104 1
pcireg_t    octeon_pcibus_pci_conf_read_internal(pcitag_t, int);
a211 2
	SLIST_INIT(&sc->sc_hook);

a307 28
/* PCI Configuration Space access hook structure */
struct octeon_pcibus_cfg_hook {
	SLIST_ENTRY(octeon_pcibus_cfg_hook) next;
	int	(*read)(void *, pci_chipset_tag_t, pcitag_t, int, pcireg_t *);
	int	(*write)(void *, pci_chipset_tag_t, pcitag_t, int, pcireg_t);
	void	*cookie;
};

int
octeon_pcibus_pci_hook(pci_chipset_tag_t pc, void *cookie,
    int (*r)(void *, pci_chipset_tag_t, pcitag_t, int, pcireg_t *),
    int (*w)(void *, pci_chipset_tag_t, pcitag_t, int, pcireg_t))
{
	struct octeon_pcibus_softc *sc = pc->pc_conf_v;
	struct octeon_pcibus_cfg_hook *och;

	DEBUG_PRINT(("%s:%s:%d:\n", __FILE__, __FUNCTION__, __LINE__));
	och = malloc(sizeof *och, M_DEVBUF, M_NOWAIT);
	if (och == NULL)
		return ENOMEM;

	och->read = r;
	och->write = w;
	och->cookie = cookie;
	SLIST_INSERT_HEAD(&sc->sc_hook, och, next);
	return 0;
}

a310 17
	struct octeon_pcibus_softc *sc = v;
	struct octeon_pcibus_cfg_hook *hook;
	pcireg_t data;

	SLIST_FOREACH(hook, &sc->sc_hook, next) {
		if (hook->read != NULL &&
		    (*hook->read)(hook->cookie, &sc->sc_pc, tag, offset,
		      &data) != 0)
			return data;
	}

	return octeon_pcibus_pci_conf_read_internal(tag, offset);
}

pcireg_t
octeon_pcibus_pci_conf_read_internal(pcitag_t tag, int offset)
{
a505 4
void
octeon_pcibus_pci_attach_hook(pci_chipset_tag_t pc)
{
}
@


1.1
log
@Inital commit of PCI and SATA support for OCTEON
@
text
@d1 2
a2 2
/*	$OpenBSD: octeon_pcibus.c,v 1.00 2010/09/11 21:59:56 mark Exp $	*/
/*	$OpenBSD: bonito.c,v 1.14 2010/05/08 21:59:56 miod Exp $	*/
d457 1
a457 7
	struct octeon_pcibus_softc *sc;
	struct obio_attach_args *oba;

	sc = (struct octeon_pcibus_softc *)cookie;
	oba = sc->sc_oba;

	return obio_intr_establish(oba->oba_intr, level, cb, cbarg, name);
@

