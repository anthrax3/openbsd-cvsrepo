head	1.10;
access;
symbols
	OPENBSD_6_1:1.8.0.4
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.7.0.2
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.6.0.2
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.4.0.4
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.3.0.4
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.8
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.6
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.2
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.2.0.8
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.6
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.4
	OPENBSD_5_0:1.2.0.2
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1;
locks; strict;
comment	@ * @;


1.10
date	2017.06.11.10.01.23;	author visa;	state Exp;
branches;
next	1.9;
commitid	bPs1aUZZRkMdyaOc;

1.9
date	2017.04.06.15.25.24;	author visa;	state Exp;
branches;
next	1.8;
commitid	QVDxDRC170mHzIld;

1.8
date	2016.12.08.16.27.46;	author visa;	state Exp;
branches;
next	1.7;
commitid	BeLTHk6EmbfN28Ae;

1.7
date	2016.03.06.19.42.27;	author mpi;	state Exp;
branches;
next	1.6;
commitid	cyYKarj4qRTft4gD;

1.6
date	2015.09.26.04.05.42;	author visa;	state Exp;
branches;
next	1.5;
commitid	BoxovA6Z5uASJfr5;

1.5
date	2015.09.13.20.38.45;	author kettenis;	state Exp;
branches;
next	1.4;
commitid	MW9yRxgkKFAx03on;

1.4
date	2015.07.08.13.37.31;	author dlg;	state Exp;
branches;
next	1.3;
commitid	Ds9kNjjKbF4CbIsT;

1.3
date	2013.05.17.19.38.52;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2011.05.08.13.24.55;	author syuu;	state Exp;
branches;
next	1.1;

1.1
date	2010.09.20.06.32.30;	author syuu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Define register_splx_handler() in one place.
@
text
@/*	$OpenBSD: intr.h,v 1.9 2017/04/06 15:25:24 visa Exp $ */

/*
 * Copyright (c) 2001-2004 Opsycon AB  (www.opsycon.se / www.opsycon.com)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#ifndef _MACHINE_INTR_H_
#define _MACHINE_INTR_H_

/*
 * The interrupt level ipl is a logical level; per-platform interrupt
 * code will turn it into the appropriate hardware interrupt masks
 * values.
 *
 * Interrupt sources on the CPU are kept enabled regardless of the
 * current ipl value; individual hardware sources interrupting while
 * logically masked are masked on the fly, remembered as pending, and
 * unmasked at the first splx() opportunity.
 *
 * An exception to this rule is the clock interrupt. Clock interrupts
 * are always allowed to happen, but will (of course!) not be serviced
 * if logically masked.  The reason for this is that clocks usually sit on
 * INT5 and cannot be easily masked if external hardware masking is used.
 */

/* Interrupt priority `levels'; not mutually exclusive. */
#define	IPL_NONE	0	/* nothing */
#define	IPL_SOFTINT	1	/* soft interrupts */
#define	IPL_BIO		2	/* block I/O */
#define IPL_AUDIO	IPL_BIO
#define	IPL_NET		3	/* network */
#define	IPL_TTY		4	/* terminal */
#define	IPL_VM		5	/* memory allocation */
#define	IPL_CLOCK	6	/* clock */
#define	IPL_SCHED	IPL_CLOCK
#define	IPL_HIGH	7	/* everything */
#define	IPL_IPI         8       /* interprocessor interrupt */
#define	NIPLS		9	/* Number of levels */

#define IPL_MPFLOOR	IPL_TTY

/* Interrupt priority 'flags'. */
#define	IPL_MPSAFE	0x100

/* Interrupt sharing types. */
#define	IST_NONE	0	/* none */
#define	IST_PULSE	1	/* pulsed */
#define	IST_EDGE	2	/* edge-triggered */
#define	IST_LEVEL	3	/* level-triggered */

#define	SINTBIT(q)	(q)
#define	SINTMASK(q)	(1 << SINTBIT(q))

/* Soft interrupt masks. */

#define	IPL_SOFT	0
#define	IPL_SOFTCLOCK	1
#define	IPL_SOFTNET	2
#define	IPL_SOFTTTY	3

#define	SI_SOFT		0	/* for IPL_SOFT */
#define	SI_SOFTCLOCK	1	/* for IPL_SOFTCLOCK */
#define	SI_SOFTNET	2	/* for IPL_SOFTNET */
#define	SI_SOFTTTY	3	/* for IPL_SOFTTTY */

#define	SI_NQUEUES	4

#ifndef _LOCORE

#include <machine/mutex.h>
#include <sys/queue.h>

struct soft_intrhand {
	TAILQ_ENTRY(soft_intrhand) sih_list;
	void	(*sih_func)(void *);
	void	*sih_arg;
	struct soft_intrq *sih_siq;
	int	sih_pending;
};

struct soft_intrq {
	TAILQ_HEAD(, soft_intrhand) siq_list;
	int siq_si;
	struct mutex siq_mtx;
};

void	 softintr_disestablish(void *);
void	 softintr_dispatch(int);
void	*softintr_establish(int, void (*)(void *), void *);
void	 softintr_init(void);
void	 softintr_schedule(void *);

/* XXX For legacy software interrupts. */
extern struct soft_intrhand *softnet_intrhand;

#define	setsoftnet()	softintr_schedule(softnet_intrhand)

#define	splsoft()	splraise(IPL_SOFTINT)
#define splbio()	splraise(IPL_BIO)
#define splnet()	splraise(IPL_NET)
#define spltty()	splraise(IPL_TTY)
#define splaudio()	splraise(IPL_AUDIO)
#define splvm()		splraise(IPL_VM)
#define splclock()	splraise(IPL_CLOCK)
#define splsched()	splraise(IPL_SCHED)
#define splhigh()	splraise(IPL_HIGH)

#define splsoftclock()	splsoft()
#define splsoftnet()	splsoft()
#define splstatclock()	splhigh()

#define spllock()	splhigh()
#define spl0()		spllower(0)

void	splinit(void);

#define	splassert(X)
#define	splsoftassert(X)

void	register_splx_handler(void (*)(int));
int	splraise(int);
void	splx(int);
int	spllower(int);

/*
 * Interrupt control struct used by interrupt dispatchers
 * to hold interrupt handler info.
 */

#include <sys/evcount.h>

struct intrhand {
	struct	intrhand	*ih_next;
	int			(*ih_fun)(void *);
	void			*ih_arg;
	int			 ih_level;
	int			 ih_irq;
	struct evcount		 ih_count;
	int			 ih_flags;
#define	IH_ALLOCATED		0x01
#define	IH_MPSAFE		0x02
};

void	intr_barrier(void *);

/*
 * Low level interrupt dispatcher registration data.
 */

/* Schedule priorities for base interrupts (CPU) */
#define	INTPRI_IPI	0
#define	INTPRI_CLOCK	1
/* other values are system-specific */

#define NLOWINT	16		/* Number of low level registrations possible */

extern uint32_t idle_mask;

struct trapframe;
void	set_intr(int, uint32_t, uint32_t(*)(uint32_t, struct trapframe *));

uint32_t updateimask(uint32_t);
void	dosoftint(void);

#ifdef MULTIPROCESSOR
#define ENABLEIPI() updateimask(~CR_INT_1) /* enable IPI interrupt level */
#endif
void	octeon_intr_init(void);
void	octeon_setintrmask(int);
void   *octeon_intr_establish(int, int, int (*)(void *),
	    void *, const char *);
void	octeon_intr_disestablish(void *);
void	octeon_intr_init(void);

void	*octeon_intr_establish_fdt(int, int, int (*)(void *),
	    void *, const char *);
void	*octeon_intr_establish_fdt_idx(int, int, int, int (*)(void *),
	    void *, const char *);
void	 octeon_intr_disestablish_fdt(void *);

#endif /* _LOCORE */

#endif /* _MACHINE_INTR_H_ */
@


1.9
log
@Extend the fdt interrupt API a little.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.8 2016/12/08 16:27:46 visa Exp $ */
d142 1
a142 12
/* Inlines */
static __inline void register_splx_handler(void (*)(int));

typedef void (int_f)(int);
extern int_f *splx_hand;

static __inline void
register_splx_handler(void(*handler)(int))
{
	splx_hand = handler;
}

@


1.8
log
@Add a routine for setting up interrupt handlers using fdt.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.7 2016/03/06 19:42:27 mpi Exp $ */
d205 5
d212 1
a212 2
void	octeon_intr_disestablish(void *);
void	octeon_intr_init(void);
@


1.7
log
@Rename mips64's trap_frame into trapframe.

For coherency with other archs and in order to use it in MI code.

ok visa@@, tobiasu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.6 2015/09/26 04:05:42 visa Exp $ */
d204 2
@


1.6
log
@Let MP-safe interrupt handlers run without the kernel lock on octeon.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.5 2015/09/13 20:38:45 kettenis Exp $ */
d192 2
a193 2
struct trap_frame;
void	set_intr(int, uint32_t, uint32_t(*)(uint32_t, struct trap_frame *));
@


1.5
log
@intr_barrier(9) for loongson, octeon and sgi.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.4 2015/07/08 13:37:31 dlg Exp $ */
d65 1
a65 1
#define	IPL_MPSAFE	0	/* no "mpsafe" interrupts */
d174 1
@


1.4
log
@unify the mutex implementations on all the mips64 platforms.

this basically copies the sgi implementation to mips64 and removes
it from the rest. this way they get an optimised UP mutex implementation
and correct asserts on all platforms.

ok miod@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.3 2013/05/17 19:38:52 kettenis Exp $ */
d175 2
@


1.3
log
@Add a dummy IPL_MPSAFE definition.

ok miod@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.2 2011/05/08 13:24:55 syuu Exp $ */
d61 2
@


1.2
log
@obio renamed iobus, moved interrupt handler code to dev/octeon_intr.c
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.1 2010/09/20 06:32:30 syuu Exp $ */
d61 3
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.41 2010/01/18 16:59:23 miod Exp $ */
d193 6
@

