head	1.37;
access;
symbols
	OPENBSD_6_2:1.37.0.4
	OPENBSD_6_2_BASE:1.37
	OPENBSD_6_1:1.33.0.4
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.31.0.2
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.24.0.2
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.24.0.4
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.20.0.4
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.15.0.4
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.1.0.8
	OPENBSD_5_3_BASE:1.1
	OPENBSD_5_2:1.1.0.6
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.4
	OPENBSD_5_0:1.1.0.2
	OPENBSD_5_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.37
date	2017.07.31.14.53.56;	author visa;	state Exp;
branches;
next	1.36;
commitid	iVSJqs5zWyPJiANX;

1.36
date	2017.07.30.16.08.09;	author visa;	state Exp;
branches;
next	1.35;
commitid	m0KR1mktijK8kds8;

1.35
date	2017.07.29.02.50.17;	author visa;	state Exp;
branches;
next	1.34;
commitid	Vov3eo1zjIV4YN8T;

1.34
date	2017.06.19.13.45.22;	author visa;	state Exp;
branches;
next	1.33;
commitid	SCPmdOwUgBgLbJnI;

1.33
date	2016.12.17.13.13.57;	author visa;	state Exp;
branches;
next	1.32;
commitid	q05p54qqcqItEtCb;

1.32
date	2016.10.29.11.00.19;	author visa;	state Exp;
branches;
next	1.31;
commitid	t7kz6Z4ma3M29x99;

1.31
date	2016.07.16.10.19.55;	author visa;	state Exp;
branches;
next	1.30;
commitid	UuPw6MsMu1Baaz2R;

1.30
date	2016.07.10.10.18.58;	author visa;	state Exp;
branches;
next	1.29;
commitid	ljeJMKR26CJ1ICNZ;

1.29
date	2016.07.01.15.12.37;	author visa;	state Exp;
branches;
next	1.28;
commitid	OBMBIbYFQmMsJKTC;

1.28
date	2016.06.22.13.09.35;	author visa;	state Exp;
branches;
next	1.27;
commitid	KLZKLKw34aQIX6oW;

1.27
date	2016.05.30.15.41.28;	author visa;	state Exp;
branches;
next	1.26;
commitid	pQeTOuXCP1quhpMp;

1.26
date	2016.05.24.13.11.02;	author visa;	state Exp;
branches;
next	1.25;
commitid	f95LsZHvv4Jv3N6g;

1.25
date	2016.03.21.14.20.57;	author visa;	state Exp;
branches;
next	1.24;
commitid	TQ0mb3irSyFB0n6b;

1.24
date	2015.07.20.19.44.32;	author pirofti;	state Exp;
branches;
next	1.23;
commitid	8BQ1mX3eNLtSDODb;

1.23
date	2015.07.15.23.22.40;	author pirofti;	state Exp;
branches;
next	1.22;
commitid	khIZKJ0vJ7wGXPqz;

1.22
date	2014.10.26.15.13.04;	author jasper;	state Exp;
branches;
next	1.21;
commitid	jRxoSQuFYq9jtt7C;

1.21
date	2014.08.11.18.29.56;	author miod;	state Exp;
branches;
next	1.20;
commitid	8Kx1Ci8ysFEuhw0R;

1.20
date	2014.07.14.10.23.58;	author jasper;	state Exp;
branches;
next	1.19;
commitid	3lf26COlDMZ3MfO8;

1.19
date	2014.07.12.20.31.52;	author jasper;	state Exp;
branches;
next	1.18;
commitid	58bAinq9cNCCG0eJ;

1.18
date	2014.07.09.18.31.34;	author pirofti;	state Exp;
branches;
next	1.17;
commitid	TdGpaadeCFwuGgJ5;

1.17
date	2014.06.17.01.33.04;	author jmatthew;	state Exp;
branches;
next	1.16;
commitid	Vozs7jQDUDtEgOjM;

1.16
date	2014.03.29.18.09.30;	author guenther;	state Exp;
branches;
next	1.15;

1.15
date	2013.11.04.17.51.03;	author bcallah;	state Exp;
branches;
next	1.14;

1.14
date	2013.11.04.17.49.37;	author bcallah;	state Exp;
branches;
next	1.13;

1.13
date	2013.10.30.19.33.06;	author pirofti;	state Exp;
branches;
next	1.12;

1.12
date	2013.06.01.23.16.15;	author jasper;	state Exp;
branches;
next	1.11;

1.11
date	2013.06.01.22.20.35;	author jasper;	state Exp;
branches;
next	1.10;

1.10
date	2013.06.01.21.29.35;	author jasper;	state Exp;
branches;
next	1.9;

1.9
date	2013.06.01.21.25.26;	author jasper;	state Exp;
branches;
next	1.8;

1.8
date	2013.06.01.21.23.56;	author jasper;	state Exp;
branches;
next	1.7;

1.7
date	2013.06.01.17.08.26;	author jasper;	state Exp;
branches;
next	1.6;

1.6
date	2013.04.05.19.55.46;	author jasper;	state Exp;
branches;
next	1.5;

1.5
date	2013.03.21.09.24.55;	author jasper;	state Exp;
branches;
next	1.4;

1.4
date	2013.03.19.09.17.52;	author jasper;	state Exp;
branches;
next	1.3;

1.3
date	2013.03.15.09.19.01;	author jasper;	state Exp;
branches;
next	1.2;

1.2
date	2013.03.15.09.18.19;	author jasper;	state Exp;
branches;
next	1.1;

1.1
date	2011.06.16.11.22.30;	author syuu;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Replace OCTEON_MAXCPUS with MAXCPUS to avoid redundancy.
@
text
@/*	$OpenBSD: octeonvar.h,v 1.36 2017/07/30 16:08:09 visa Exp $	*/
/*	$NetBSD: maltavar.h,v 1.3 2002/03/18 10:10:16 simonb Exp $	*/

/*-
 * Copyright (c) 2001 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _MIPS_OCTEON_OCTEONVAR_H_
#define _MIPS_OCTEON_OCTEONVAR_H_

#include <machine/bus.h>

/* XXX elsewhere */
#define	_ASM_PROLOGUE \
		"	.set push			\n" \
		"	.set noreorder			\n"
#define	_ASM_PROLOGUE_MIPS64 \
		_ASM_PROLOGUE				\
		"	.set mips64			\n"
#define	_ASM_PROLOGUE_OCTEON \
		_ASM_PROLOGUE				\
		"	.set arch=octeon		\n"
#define	_ASM_EPILOGUE \
		"	.set pop			\n"
/*
 * subbits = __BITS64_GET(XXX, bits);
 * bits = __BITS64_SET(XXX, subbits);
 */
#ifndef	__BITS64_GET
#define	__BITS64_GET(name, bits)	\
	    (((uint64_t)(bits) & name) >> name##_SHIFT)
#endif
#ifndef	__BITS64_SET
#define	__BITS64_SET(name, subbits)	\
	    (((uint64_t)(subbits) << name##_SHIFT) & name)
#endif

struct octeon_config {
	bus_space_tag_t mc_iobus_bust;
	bus_space_tag_t mc_bootbus_bust;

	bus_dma_tag_t mc_iobus_dmat;
	bus_dma_tag_t mc_bootbus_dmat;
};

/*
 * FPA map
 */

#define	OCTEON_POOL_NO_PKT	0
#define	OCTEON_POOL_NO_WQE	1
#define	OCTEON_POOL_NO_CMD	2
#define	OCTEON_POOL_NO_SG	3
#define	OCTEON_POOL_NO_XXX_4	4
#define	OCTEON_POOL_NO_XXX_5	5
#define	OCTEON_POOL_NO_XXX_6	6
#define	OCTEON_POOL_NO_DUMP	7	/* FPA debug dump */

#define	OCTEON_POOL_SIZE_PKT	1920	/* 128 x 15 */
#define	OCTEON_POOL_SIZE_WQE	128	/* 128 x 1 */
#define	OCTEON_POOL_SIZE_CMD	1024	/* 128 x 8 */
#define	OCTEON_POOL_SIZE_SG	128	/* 128 x 1 */
#define	OCTEON_POOL_SIZE_XXX_4	0
#define	OCTEON_POOL_SIZE_XXX_5	0
#define	OCTEON_POOL_SIZE_XXX_6	0
#define	OCTEON_POOL_SIZE_XXX_7	0

#define	OCTEON_POOL_NELEMS_PKT		4096
#define	OCTEON_POOL_NELEMS_WQE		4096
#define	OCTEON_POOL_NELEMS_CMD		32
#define	OCTEON_POOL_NELEMS_SG		4096
#define	OCTEON_POOL_NELEMS_XXX_4	0
#define	OCTEON_POOL_NELEMS_XXX_5	0
#define	OCTEON_POOL_NELEMS_XXX_6	0
#define	OCTEON_POOL_NELEMS_XXX_7	0

/*
 * CVMSEG (``scratch'') memory map
 */
struct octeon_cvmseg_map {
	uint64_t		csm_pow_intr;

	struct octeon_cvmseg_ether_map {
		uint64_t	csm_ether_fau_done;
	} csm_ether[12/* XXX */];
} __packed;
#define	OCTEON_CVMSEG_OFFSET(entry) \
	offsetof(struct octeon_cvmseg_map, entry)
#define	OCTEON_CVMSEG_ETHER_OFFSET(n, entry) \
	(offsetof(struct octeon_cvmseg_map, csm_ether) + \
	 sizeof(struct octeon_cvmseg_ether_map) * (n) + \
	 offsetof(struct octeon_cvmseg_ether_map, entry))

/*
 * FAU register map
 *
 * => FAU registers exist in FAU unit
 * => devices (PKO) can access these registers
 * => CPU can read those values after loading them into CVMSEG
 */
struct octeon_fau_map {
	struct {
		/* PKO command index */
		uint64_t	_fau_map_port_pkocmdidx;
		/* send requested */
		uint64_t	_fau_map_port_txreq;
		/* send completed */
		uint64_t	_fau_map_port_txdone;
		/* XXX */
		uint64_t	_fau_map_port_pad;
	} __packed _fau_map_port[3];
};

/*
 * POW qos/group map
 */

#define	OCTEON_POW_QOS_PIP		0
#define	OCTEON_POW_QOS_CORE1		1
#define	OCTEON_POW_QOS_XXX_2		2
#define	OCTEON_POW_QOS_XXX_3		3
#define	OCTEON_POW_QOS_XXX_4		4
#define	OCTEON_POW_QOS_XXX_5		5
#define	OCTEON_POW_QOS_XXX_6		6
#define	OCTEON_POW_QOS_XXX_7		7

#define	OCTEON_POW_GROUP_PIP		0
#define	OCTEON_POW_GROUP_XXX_1		1
#define	OCTEON_POW_GROUP_XXX_2		2
#define	OCTEON_POW_GROUP_XXX_3		3
#define	OCTEON_POW_GROUP_XXX_4		4
#define	OCTEON_POW_GROUP_XXX_5		5
#define	OCTEON_POW_GROUP_XXX_6		6
#define	OCTEON_POW_GROUP_CORE1_SEND	7
#define	OCTEON_POW_GROUP_CORE1_TASK_0	8
#define	OCTEON_POW_GROUP_CORE1_TASK_1	9
#define	OCTEON_POW_GROUP_CORE1_TASK_2	10
#define	OCTEON_POW_GROUP_CORE1_TASK_3	11
#define	OCTEON_POW_GROUP_CORE1_TASK_4	12
#define	OCTEON_POW_GROUP_CORE1_TASK_5	13
#define	OCTEON_POW_GROUP_CORE1_TASK_6	14
#define	OCTEON_POW_GROUP_CORE1_TASK_7	15

/*
 * Octeon board types known to work with OpenBSD/octeon.
 * NB: BOARD_TYPE_UBIQUITI_E100 is also used by other vendors, but we don't run
 * on those boards yet.
 */
#define	BOARD_TYPE_CN3010_EVB_HS5	11
#define	BOARD_TYPE_UBIQUITI_E100	20002
#define	BOARD_TYPE_UBIQUITI_E200	20003
#define	BOARD_TYPE_UBIQUITI_E1000	20010
#define	BOARD_TYPE_RHINOLABS_SHASTA	20012
#define	BOARD_TYPE_DSR_500		20015
#define	BOARD_TYPE_UBIQUITI_E300	20300

#if defined(_KERNEL) || defined(_STANDALONE)
#define OCTEON_ARGV_MAX 64

struct boot_desc {
	uint32_t	desc_ver;
	uint32_t	desc_size;
	uint64_t	stack_top;
	uint64_t 	heap_start;
	uint64_t	heap_end;
	uint64_t      	__unused17;
	uint64_t     	__unused16;
	uint32_t      	__unused18;
	uint32_t      	__unused15;
	uint32_t      	__unused14;
	uint32_t	argc;
	uint32_t	argv[OCTEON_ARGV_MAX];
	uint32_t	flags;
	uint32_t	core_mask;
	uint32_t	dram_size;
	uint32_t	phy_mem_desc_addr;
	uint32_t	debugger_flag_addr;
	uint32_t	eclock;
	uint32_t      	__unused10;
	uint32_t      	__unused9;
	uint16_t      	__unused8;
	uint8_t 	__unused7;
	uint8_t 	__unused6;
	uint16_t 	__unused5;
	uint8_t 	__unused4;
	uint8_t 	__unused3;
	uint8_t 	__unused2[20];
	uint8_t 	__unused1[6];
	uint8_t 	__unused0;
	uint64_t 	boot_info_addr;
};

struct boot_info {
	uint32_t ver_major;
	uint32_t ver_minor;
	uint64_t stack_top;
	uint64_t heap_start;
	uint64_t heap_end;
	uint64_t boot_desc_addr;
	uint32_t exception_base_addr;
	uint32_t stack_size;
	uint32_t flags;
	uint32_t core_mask;
	uint32_t dram_size;
	uint32_t phys_mem_desc_addr;
	uint32_t debugger_flags_addr;
	uint32_t eclock;
	uint32_t dclock;
	uint32_t __unused0;
	uint16_t board_type;
	uint8_t board_rev_major;
	uint8_t board_rev_minor;
	uint16_t __unused1;
	uint8_t __unused2;
	uint8_t __unused3;
	char board_serial[20];
	uint8_t mac_addr_base[6];
	uint8_t mac_addr_count;
	uint64_t cf_common_addr;
	uint64_t cf_attr_addr;
	uint64_t led_display_addr;
	uint32_t dfaclock;
	uint32_t config_flags;
	/* The fields below are available when ver_minor >= 3. */
	uint64_t fdt_addr;
};

struct octeon_bootmem_desc {
	uint32_t	lock;
	uint32_t	flags;
	uint64_t	head_addr;
	uint32_t	major_version;
	uint32_t	minor_version;
	uint64_t	app_data_addr;
	uint64_t	app_data_size;
	uint32_t	named_block_num_blocks;
	uint32_t	named_block_name_len;
	uint64_t	named_block_array_addr;
};

struct octeon_bootmem_block {
	uint64_t	next;
	uint64_t	size;
};

extern struct boot_desc *octeon_boot_desc;
extern struct boot_info *octeon_boot_info;

#ifdef _KERNEL
/* Device capabilities advertised in boot_info->config_flags */
#define BOOTINFO_CFG_FLAG_PCI_HOST	(1ull << 0)
#define BOOTINFO_CFG_FLAG_PCI_TARGET	(1ull << 1)
#define BOOTINFO_CFG_FLAG_DEBUG		(1ull << 2)
#define BOOTINFO_CFG_FLAG_NO_MAGIC	(1ull << 3)

int	octeon_ioclock_speed(void);

#endif /* _KERNEL */
#endif /* _KERNEL || _STANDALONE */

static inline int
ffs64(uint64_t val)
{
	int ret;

	__asm volatile ( \
		_ASM_PROLOGUE_MIPS64
		"	dclz	%0, %1			\n"
		_ASM_EPILOGUE
		: "=r"(ret) : "r"(val));
	return 64 - ret;
}

static inline int
ffs32(uint32_t val)
{
	int ret;

	__asm __volatile ( \
		_ASM_PROLOGUE_MIPS64
		"	clz	%0, %1			\n"
		_ASM_EPILOGUE
		: "=r"(ret) : "r"(val));
	return 32 - ret;
}

static inline uint64_t
octeon_xkphys_read_8(paddr_t address)
{
	volatile uint64_t *p =
	    (volatile uint64_t *)(PHYS_TO_XKPHYS(address, CCA_NC));
	return (*p);
}

#define	MIO_BOOT_BIST_STAT			0x00011800000000f8ULL
static inline void
octeon_xkphys_write_8(paddr_t address, uint64_t value)
{
	*(volatile uint64_t *)(PHYS_TO_XKPHYS(address, CCA_NC)) = value;

	/*
	 * It seems an immediate read is necessary when doing a write to an RSL
	 * register in order to complete the write.
	 * We use MIO_BOOT_BIST_STAT because it's apparently the fastest
	 * write.
	 */

	/*
	 * XXX
	 * This if would be better writen as:
	 * if ((address & 0xffffff0000000000ULL) == OCTEON_MIO_BOOT_BASE) {
	 * but octeonreg.h can't be included here and we want this inlined
	 *
	 * Note that the SDK masks with 0x7ffff but that doesn't make sense.
	 * This is a physical address.
	 */
	if (((address >> 40) & 0xfffff) == (0x118)) {
		value = *(volatile uint64_t *)
		    (PHYS_TO_XKPHYS(MIO_BOOT_BIST_STAT, CCA_NC));
	}
}

static inline void
octeon_iobdma_write_8(uint64_t value)
{
	uint64_t addr = 0xffffffffffffa200ULL;

	*(volatile uint64_t *)addr = value;
}

static inline uint64_t
octeon_cvmseg_read_8(size_t offset)
{
	return octeon_xkphys_read_8(0xffffffffffff8000ULL + offset);
}

static inline void
octeon_cvmseg_write_8(size_t offset, uint64_t value)
{
	octeon_xkphys_write_8(0xffffffffffff8000ULL + offset, value);
}

static inline uint64_t
octeon_get_cycles(void)
{
	uint64_t tmp;

	__asm volatile (
		_ASM_PROLOGUE_MIPS64
		"	dmfc0	%[tmp], $9, 6		\n"
		_ASM_EPILOGUE
		: [tmp]"=&r"(tmp));
	return tmp;
}

static inline void
octeon_synciobdma(void)
{
	__asm volatile (
		_ASM_PROLOGUE_OCTEON
		"	synciobdma\n"
		_ASM_EPILOGUE
		: : : "memory");
}

#endif	/* _MIPS_OCTEON_OCTEONVAR_H_ */
@


1.36
log
@Bump MAXCPUS on octeon.
@
text
@d1 1
a1 1
/*	$OpenBSD: octeonvar.h,v 1.35 2017/07/29 02:50:17 visa Exp $	*/
a190 2

#define OCTEON_MAXCPUS	16
@


1.35
log
@There is no RTC on the E300 boards.
@
text
@d1 1
a1 1
/*	$OpenBSD: octeonvar.h,v 1.34 2017/06/19 13:45:22 visa Exp $	*/
d192 1
a192 2
/* Maximum number of cores on <= CN52XX */
#define OCTEON_MAXCPUS	4
@


1.34
log
@There is no RTC on the E1000 board.
@
text
@d1 1
a1 1
/*	$OpenBSD: octeonvar.h,v 1.33 2016/12/17 13:13:57 visa Exp $	*/
d187 1
@


1.33
log
@There is no RTC on Shasta, so do not attach the driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: octeonvar.h,v 1.32 2016/10/29 11:00:19 visa Exp $	*/
d184 1
@


1.32
log
@Make PHY address lookups fail instead of using CAM-0100 entries
when the system board is unhandled.
@
text
@d1 1
a1 1
/*	$OpenBSD: octeonvar.h,v 1.31 2016/07/16 10:19:55 visa Exp $	*/
d184 1
@


1.31
log
@Remove octeon_disable_interrupt() and octeon_restore_status().
They are unused and equivalent to disableintr() and setsr().

While here, clean up a few other leftovers.
@
text
@d1 1
a1 1
/*	$OpenBSD: octeonvar.h,v 1.30 2016/07/10 10:18:58 visa Exp $	*/
d181 1
@


1.30
log
@Use the synciobdma instruction instead of the sync instruction for
flushing any pending local IOBDMA operations. The sync instruction is
overkill because it implies a full memory barrier.

ok jasper@@ (long time ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: octeonvar.h,v 1.29 2016/07/01 15:12:37 visa Exp $	*/
a75 8
/*
	struct mips_bus_dma_tag mc_core1_dmat;

	struct extent *mc_io_ex;
	struct extent *mc_mem_ex;

	int	mc_mallocsafe;
*/
a286 7
void	octeon_bus_io_init(bus_space_tag_t, void *);
void	octeon_bus_mem_init(bus_space_tag_t, void *);
void	octeon_cal_timer(int);
void	octeon_dma_init(struct octeon_config *);
void	octeon_intr_init(void);
int	octeon_get_ethaddr(int, u_int8_t *);

a371 29
}

/* XXX */
static inline uint32_t
octeon_disable_interrupt(uint32_t *new)
{
	uint32_t s, tmp;

	__asm volatile (
		_ASM_PROLOGUE
		"	mfc0	%[s], $12		\n"
		"	and	%[tmp], %[s], ~1	\n"
		"	mtc0	%[tmp], $12		\n"
		_ASM_EPILOGUE
		: [s]"=&r"(s), [tmp]"=&r"(tmp));
	if (new)
		*new = tmp;
	return s;
}

/* XXX */
static inline void
octeon_restore_status(uint32_t s)
{
	__asm volatile (
		_ASM_PROLOGUE
		"	mtc0	%[s], $12		\n"
		_ASM_EPILOGUE
		:: [s]"r"(s));
@


1.29
log
@Add fdt init for octeon.
@
text
@d1 1
a1 1
/*	$OpenBSD: octeonvar.h,v 1.28 2016/06/22 13:09:35 visa Exp $	*/
d429 10
@


1.28
log
@Add support for the second GMX interface on Octeon II. This enables
ports eth[0-3] on 8-port EdgeRouters. Currently, port eth0 maps to
network interface cnmac4, eth1 to cnmac5 etc.

ok dlg@@, tested by martijn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: octeonvar.h,v 1.27 2016/05/30 15:41:28 visa Exp $	*/
d263 2
@


1.27
log
@Fill the packet data pool with standard mbuf clusters instead of
driver-specific memory blocks. This lets the cnmac(4) RX path run
without an mbuf ext_free callback.

ok uebayasi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: octeonvar.h,v 1.26 2016/05/24 13:11:02 visa Exp $	*/
a120 4
	/* 0-3 */
	uint64_t		csm_xxx_0;
	uint64_t		csm_xxx_1;
	uint64_t		csm_xxx_2;
a122 1
	/* 4-19 */
a123 1
		uint64_t	csm_ether_fau_req;
d125 1
a125 6
		uint64_t	csm_ether_fau_cmdptr;
		uint64_t	csm_ether_xxx_3;
	} csm_ether[4/* XXX */];

	/* 20-32 */
	uint64_t	xxx_20_32[32 - 20];
@


1.26
log
@Reduce the size of gather buffers and allocate more of them to make
better use of memory. This should prevent gather buffer starvation on
currently supported systems.

Discussed with mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: octeonvar.h,v 1.25 2016/03/21 14:20:57 visa Exp $	*/
d99 1
a99 1
#define	OCTEON_POOL_SIZE_PKT	2048	/* 128 x 16 */
@


1.25
log
@On Octeon systems, U-Boot provides a list of usable memory regions. Use
the list instead of hardcoded regions in memory setup. Works on
EdgeRouter Lite, EdgeRouter Pro, Lanner MR326b and Movidis 16x.

Tested by jj@@
Tested by and ok jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: octeonvar.h,v 1.24 2015/07/20 19:44:32 pirofti Exp $	*/
d102 1
a102 1
#define	OCTEON_POOL_SIZE_SG	512	/* 128 x 4 */
d111 1
a111 1
#define	OCTEON_POOL_NELEMS_SG		1024
@


1.24
log
@Add a new flash driver for Octeon that allows access to the internal
memory on (at least) D-Link DSR500 machines.

This follows the CFI specification with code borrowed from zrouter
(FreeBSD). The idea, once the current driver is thoroughly tested, would
be to move it to MI land.

The prerequisites to MI are width, shift and row detection and handling.
In the long run I hope to be able to also add wdc support.

For now write support is disabled.

Okay miod@@, deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: octeonvar.h,v 1.23 2015/07/15 23:22:40 pirofti Exp $	*/
d274 18
@


1.23
log
@Ditch the octeon simulator non-sense.

Discussed with miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: octeonvar.h,v 1.22 2014/10/26 15:13:04 jasper Exp $	*/
d202 1
@


1.22
log
@- add board type of edgerouter pro
- don't attach octrtc on the edgerouter pro either

openbsd boots fine on this system, but as there's no ethernet support yet
there's no storage at all right now.

ok pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: octeonvar.h,v 1.21 2014/08/11 18:29:56 miod Exp $	*/
a199 1
#define	BOARD_TYPE_SIM			1
@


1.21
log
@Remove evcnt and %b format strings relying upon SEIL extensions. This gives
OCTEON_ETH_DEBUG kernels a chance to build. No functional change for regular
kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: octeonvar.h,v 1.20 2014/07/14 10:23:58 jasper Exp $	*/
d197 2
a198 5
 * One of the main reasons for keeping this list is to be able to tell which
 * boards do and do not have octcf(4). Currently the only board not to have octcf(4)
 * is BOARD_TYPE_UBIQUITI_E100. Sadly, this number is also used by other vendors, but
 * we don't run on those boards yet. When that time comes, iobus needs extra care for
 * not blindly attaching octcf(4) on every board.
d202 1
@


1.20
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: octeonvar.h,v 1.19 2014/07/12 20:31:52 jasper Exp $	*/
a422 43

/* -------------------------------------------------------------------------- */

/* ---- event counter */

#if defined(OCTEON_ETH_DEBUG)
#define	OCTEON_EVCNT_INC(sc, name) \
	do { (sc)->sc_ev_##name.ev_count++; } while (0)
#define	OCTEON_EVCNT_ADD(sc, name, n) \
	do { (sc)->sc_ev_##name.ev_count += (n); } while (0)
#define	OCTEON_EVCNT_ATTACH_EVCNTS(sc, entries, devname) \
do {								\
	int i;							\
	const struct octeon_evcnt_entry *ee;			\
								\
	for (i = 0; i < (int)nitems(entries); i++) {	\
		ee = &(entries)[i];				\
		evcnt_attach_dynamic(				\
		    (struct evcnt *)((uintptr_t)(sc) + ee->ee_offset), \
		    ee->ee_type, ee->ee_parent, devname,	\
		    ee->ee_name);				\
	}							\
} while (0)
#else
#define	OCTEON_EVCNT_INC(sc, name)
#define	OCTEON_EVCNT_ADD(sc, name, n)
#define	OCTEON_EVCNT_ATTACH_EVCNTS(sc, entries, devname)
#endif

struct octeon_evcnt_entry {
	size_t		ee_offset;
	int		ee_type;
	struct evcnt	*ee_parent;
	const char	*ee_name;
};

#define	OCTEON_EVCNT_ENTRY(_sc_type, _var, _ev_type, _parent, _name) \
	{							\
		.ee_offset = offsetof(_sc_type, sc_ev_##_var),	\
		.ee_type = EVCNT_TYPE_##_ev_type,		\
		.ee_parent = _parent,				\
		.ee_name = _name				\
	}
@


1.19
log
@add guards to just make available to the bootblocks what they need.

prompted by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: octeonvar.h,v 1.18 2014/07/09 18:31:34 pirofti Exp $	*/
d213 30
a242 30
	uint32_t desc_ver;
	uint32_t desc_size;
	uint64_t stack_top;
	uint64_t heap_start;
	uint64_t heap_end;
	uint64_t __unused17;
	uint64_t __unused16;
	uint32_t __unused18;
	uint32_t __unused15;
	uint32_t __unused14;
	uint32_t argc;
	uint32_t argv[OCTEON_ARGV_MAX];
	uint32_t flags;
	uint32_t core_mask;
	uint32_t dram_size;
	uint32_t phy_mem_desc_addr;
	uint32_t debugger_flag_addr;
	uint32_t eclock;
	uint32_t __unused10;
	uint32_t __unused9;
	uint16_t __unused8;
	uint8_t __unused7;
	uint8_t __unused6;
	uint16_t __unused5;
	uint8_t __unused4;
	uint8_t __unused3;
	uint8_t __unused2[20];
	uint8_t __unused1[6];
	uint8_t __unused0;
	uint64_t boot_info_addr;
@


1.18
log
@Add ffs routine needed for upcoming octhci interrupt routine.

Okay miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: octeonvar.h,v 1.17 2014/06/17 01:33:04 jmatthew Exp $	*/
d206 1
a206 1
#ifdef _KERNEL
d281 1
d298 1
@


1.17
log
@The io clock on Octeon II (CN6xxx) runs at a different rate to the cpu clock.
Program the uarts based on the io clock rate on these platforms.

ok jasper@@ pirofti@@ yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: octeonvar.h,v 1.16 2014/03/29 18:09:30 guenther Exp $	*/
d309 13
@


1.16
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: octeonvar.h,v 1.15 2013/11/04 17:51:03 bcallah Exp $	*/
d293 3
@


1.15
log
@A few too many tabs snuck in there.
@
text
@d1 1
a1 1
/*	$OpenBSD: octeonvar.h,v 1.14 2013/11/04 17:49:37 bcallah Exp $	*/
d300 1
a300 1
	__asm __volatile ( \
d370 1
a370 1
	__asm __volatile (
d386 1
a386 1
	__asm __volatile (
d398 1
a398 1
	__asm __volatile (
@


1.14
log
@Add RCS ID.
ok pirofti@@ jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD$							*/
@


1.13
log
@It seems an immediate read is necessary when doing a write to an RSL
register in order to complete the write.

Okay miod@@
@
text
@d1 1
@


1.12
log
@remove unused octeon prefetch macros which won't work due to the fact it
uses '.set arch=octeon' and as has only gotten support for that after the
gplv3 switch.

ok uebayasi@@
@
text
@d315 1
d320 21
@


1.11
log
@as discussed with uebayasi@@ we should only use the "sync" instruction on octeon,
instead of syncs/syncw etc.
so remove the OCTEON_SYNC* macros and use mips_sync() directly.

ok uebayasi@@
@
text
@a306 28
/*
 * Prefetch
 *
 *	OCTEON_PREF		normal (L1 and L2)
 *	OCTEON_PREF_L1		L1 only
 *	OCTEON_PREF_L2		L2 only
 *	OCTEON_PREF_DWB		don't write back
 *	OCTEON_PREF_PFS		prepare for store
 */
#define __OCTEON_PREF_N(n, base, offset)			\
	__asm __volatile (					\
		"	.set	push				\
		"	.set	arch=octeon			\n" \
		"	pref	"#n", "#offset"(%[base])	\n" \
		"	.set	pop				\
		: : [base] "d" (base)				\
	)
#define __OCTEON_PREF_0(base, offset)	__OCTEON_PREF_N(0, base, offset)
#define __OCTEON_PREF_4(base, offset)	__OCTEON_PREF_N(4, base, offset)
#define __OCTEON_PREF_28(base, offset)	__OCTEON_PREF_N(28, base, offset)
#define __OCTEON_PREF_29(base, offset)	__OCTEON_PREF_N(29, base, offset)
#define __OCTEON_PREF_30(base, offset)	__OCTEON_PREF_N(30, base, offset)
#define OCTEON_PREF(base, offset)	__OCTEON_PREF_0(base, offset)
#define OCTEON_PREF_L1(base, offset)	__OCTEON_PREF_4(base, offset)
#define OCTEON_PREF_L2(base, offset)	__OCTEON_PREF_28(base, offset)
#define OCTEON_PREF_DWB(base, offset)	__OCTEON_PREF_29(base, offset)
#define OCTEON_PREF_PFS(base, offset)	__OCTEON_PREF_30(base, offset)

@


1.10
log
@- whitespace cleanup
- add a comment explaining how OCTEON_MAXCPUS was derived
@
text
@a334 14
/*
 * Sync
 */
#define OCTEON_SYNCCOMMON(name) \
	__asm __volatile ( \
		_ASM_PROLOGUE_OCTEON			\
		"	"#name"				\n" \
		_ASM_EPILOGUE				\
		::: "memory")
#define OCTEON_SYNCIOBDMA	__asm __volatile (".word 0x8f" : : :"memory")
#define OCTEON_SYNCW		__asm __volatile (".word  0x10f" : : )
#define OCTEON_SYNC		OCTEON_SYNCCOMMON(sync)
#define OCTEON_SYNCWS		__asm __volatile (".word  0x14f" : : )

@


1.9
log
@- remove more backward compat code and switch the callers over to the new function

ok uebayasi@@
@
text
@d207 2
d307 1
a307 1
/* 
d388 1
a388 1
        
d414 1
a414 1
{ 
@


1.8
log
@- remove an __mips_o32 block which'll never be used on openbsd
- remove some defines intended for backward compat, but that are unused now.

ok uebayasi@@
@
text
@a360 8
/* XXX backward compatibility */
#if 1
#define octeon_read_csr(address) \
	octeon_xkphys_read_8(address)
#define octeon_write_csr(address, value) \
	octeon_xkphys_write_8(address, value)
#endif

@


1.7
log
@corectly initialize the number of cores/cpus on the board. this fixes a NULL
deref in cpuattach() since we advertised only a single CPU, but tried to
attach two.

with this diff bsd.mp boots up on the ERL.

discussed with pirofti@@
ok miod@@ pirofti@@
@
text
@a345 7
/* XXX backward compatibility */
#if 1
#define	OCT_SYNCIOBDMA		OCTEON_SYNCIOBDMA
#define	OCT_SYNCW		OCTEON_SYNCW
#define	OCT_SYNC		OCTEON_SYNC
#define	OCT_SYNCWS		OCTEON_SYNCWS
#endif
a420 16
#if defined(__mips_o32)
	uint32_t s, lo, hi;
  
	s = octeon_disable_interrupt((void *)0);
	__asm __volatile (
		_ASM_PROLOGUE_MIPS64
		"	dmfc0	%[lo], $9, 6		\n"
		"	add	%[hi], %[lo], $0	\n"
		"	srl	%[hi], 32		\n"
		"	sll	%[lo], 32		\n"
		"	srl	%[lo], 32		\n"
		_ASM_EPILOGUE
		: [lo]"=&r"(lo), [hi]"=&r"(hi));
	octeon_restore_status(s);
	return ((uint64_t)hi << 32) + (uint64_t)lo;
#else
a428 1
#endif
@


1.6
log
@don't hardcode the size of u-boot's argv, but use a define instead.
to be re-used shortly elsewhere..
@
text
@d207 1
@


1.5
log
@- remove an unused variable (octeon_configuration)
- add some flags which will be used to determine the device capabilities which
  are advertised by uboot.

ok bcallah@@ chris@@
@
text
@d206 2
d220 1
a220 1
	uint32_t argv[64];
@


1.4
log
@instead of treating boot_info->cf_common_addr special, save the whole of boot_info
for future use.

ok yasuoka@@
@
text
@d275 5
a279 1
extern struct octeon_config	octeon_configuration;
@


1.3
log
@add some board types which will be used later to identify particular boards

ok yasuoka@@
@
text
@d272 2
a273 2
/* Contains the address for the CF bus, if one was found. */
uint64_t cf_found;
@


1.2
log
@save a copy of the address at which the CF bus can be found, and use this in octcf(4) for
a better probe function which doesn't unconditionally tries to attach octcf(4). this would
cause endless faults on the EdgeRouter Lite as it lacks a CF bus.

feedback and testing bcallah@@ and chris@@
ok yasuoka@@
@
text
@d194 11
@


1.1
log
@Ethernet driver merged from IIJ's contribution code.
@
text
@d195 69
@

