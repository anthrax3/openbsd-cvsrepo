head	1.16;
access;
symbols
	OPENBSD_5_5:1.15.0.42
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.38
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.36
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.34
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.32
	OPENBSD_5_0:1.15.0.30
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.28
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.26
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.22
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.24
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.20
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.18
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.16
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.14
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.12
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.10
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.8
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.6
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.4
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.2
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.9.0.12
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.10
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.8
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.6
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.9
	UBC:1.9.0.4
	UBC_BASE:1.9
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.5.0.8
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.6
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.4
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	mvme88kport:1.1.1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	first_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2014.03.18.22.36.36;	author miod;	state dead;
branches;
next	1.15;

1.15
date	2004.04.26.14.31.11;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2004.04.26.12.34.05;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2004.01.12.21.33.15;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2004.01.12.07.46.16;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2003.11.08.16.43.00;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.11.22.08.57;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.28.20.46.39;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.12.12.03.02;	author heko;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.12.07.29.27;	author smurph;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.28.21.21.24;	author smurph;	state Exp;
branches;
next	1.5;

1.5
date	99.09.27.20.46.19;	author smurph;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	99.02.09.06.36.27;	author smurph;	state Exp;
branches;
next	1.3;

1.3
date	97.03.03.20.21.07;	author rahnds;	state Exp;
branches;
next	1.2;

1.2
date	97.03.03.19.07.38;	author rahnds;	state dead;
branches;
next	1.1;

1.1
date	95.10.18.10.54.23;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.10.54.23;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.03.03.19.31.35;	author rahnds;	state Exp;
branches;
next	;

1.5.4.1
date	2001.04.18.16.11.24;	author niklas;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2001.10.31.03.01.19;	author nate;	state Exp;
branches;
next	1.5.4.3;

1.5.4.3
date	2004.02.19.10.49.07;	author niklas;	state Exp;
branches;
next	1.5.4.4;

1.5.4.4
date	2004.06.05.23.09.50;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/* $OpenBSD: pcb.h,v 1.15 2004/04/26 14:31:11 miod Exp $ */
/* public domain */
#include <m88k/pcb.h>
@


1.15
log
@Fix RCSID
@
text
@d1 1
a1 1
/* $OpenBSD$ */
@


1.14
log
@Start factorizing luna88k and mvme88k common parts.
For now, include files only.
@
text
@d1 1
a1 1
/* $OpenBSD */
@


1.13
log
@Shrink the reg structure, for it to only contain registers (eh), and make
the remaining fielhs only available in struct trapframe.

This has the additional benefit of preventing smarty-pants from altering
the frame a bit too easily from ddb, at the expense of a few ugly casts in
ddb.
@
text
@d1 3
a3 149
/*	$OpenBSD: pcb.h,v 1.12 2004/01/12 07:46:16 miod Exp $ */
/*
 * Copyright (c) 1996 Nivas Madhur
 * Mach Operating System
 * Copyright (c) 1993-1992 Carnegie Mellon University
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON AND OMRON ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON AND OMRON DISCLAIM ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */
/*
 * Motorola 88100 pcb definitions
 *
 */
/*
 */
#ifndef _M88K_PCB_H_
#define _M88K_PCB_H_

#include <machine/reg.h>

/*
 * Our PCB is the regular PCB+Save area for kernel frame.
 * Upon entering kernel mode from user land, save the user context
 * in the saved_state area - this is passed as the exception frame.
 * On a context switch, only registers that need to be saved by the
 * C calling convention and few other regs (pc, psr etc) are saved
 * in the kernel_state part of the PCB. Typically, trap frames are
 * saved on the stack (by low level handlers or by hardware) but,
 * we just decided to do it in the PCB.
 */

struct m88100_pcb {
	unsigned pcb_pc;	/* address to return */
	unsigned pcb_ipl;
	unsigned pcb_r14;
	unsigned pcb_r15;
	unsigned pcb_r16;
	unsigned pcb_r17;
	unsigned pcb_r18;
	unsigned pcb_r19;
	unsigned pcb_r20;
	unsigned pcb_r21;
	unsigned pcb_r22;
	unsigned pcb_r23;
	unsigned pcb_r24;
	unsigned pcb_r25;
	unsigned pcb_r26;
	unsigned pcb_r27;
	unsigned pcb_r28;
	unsigned pcb_r29;
	unsigned pcb_r30;
	unsigned pcb_sp; 	/* kernel stack pointer */
	/* floating-point state */
	unsigned pcb_fcr62;
	unsigned pcb_fcr63;
};

struct trapframe {
	struct reg	tf_regs;
	register_t	tf_vector;	/* exception vector number */
	register_t	tf_mask;	/* interrupt mask level */
	register_t	tf_mode;	/* interrupt mode */
	register_t	tf_scratch1;	/* reserved for use by locore */
	register_t	tf_ipfsr;	/* P BUS status */
	register_t	tf_dpfsr;	/* P BUS status */
	register_t	tf_cpu;		/* cpu number */
};

#define	tf_r		tf_regs.r
#define	tf_sp		tf_regs.r[31]
#define	tf_epsr		tf_regs.epsr
#define	tf_fpsr		tf_regs.fpsr
#define	tf_fpcr		tf_regs.fpcr
#define	tf_sxip		tf_regs.sxip
#define	tf_snip		tf_regs.snip
#define	tf_sfip		tf_regs.sfip
#define	tf_exip		tf_regs.sxip
#define	tf_enip		tf_regs.snip
#define	tf_ssbr		tf_regs.ssbr
#define	tf_dmt0		tf_regs.dmt0
#define	tf_dmd0		tf_regs.dmd0
#define	tf_dma0		tf_regs.dma0
#define	tf_dmt1		tf_regs.dmt1
#define	tf_dmd1		tf_regs.dmd1
#define	tf_dma1		tf_regs.dma1
#define	tf_dmt2		tf_regs.dmt2
#define	tf_dmd2		tf_regs.dmd2
#define	tf_dma2		tf_regs.dma2
#define	tf_duap		tf_regs.ssbr
#define	tf_dsr		tf_regs.dmt0
#define	tf_dlar		tf_regs.dmd0
#define	tf_dpar		tf_regs.dma0
#define	tf_isr		tf_regs.dmt1
#define	tf_ilar		tf_regs.dmd1
#define	tf_ipar		tf_regs.dma1
#define	tf_isap		tf_regs.dmt2
#define	tf_dsap		tf_regs.dmd2
#define	tf_iuap		tf_regs.dma2
#define	tf_fpecr	tf_regs.fpecr
#define	tf_fphs1	tf_regs.fphs1
#define	tf_fpls1	tf_regs.fpls1
#define	tf_fphs2	tf_regs.fphs2
#define	tf_fpls2	tf_regs.fpls2
#define	tf_fppt		tf_regs.fppt
#define	tf_fprh		tf_regs.fprh
#define	tf_fprl		tf_regs.fprl
#define	tf_fpit		tf_regs.fpit

struct pcb
{
	struct m88100_pcb	kernel_state;
	struct trapframe	user_state;
	int			pcb_onfault;
};

/*
 *	Location of saved user registers for the proc.
 */
#define	USER_REGS(p) \
	(((struct reg *)(&((p)->p_addr->u_pcb.user_state))))
/*
 * The pcb is augmented with machine-dependent additional data for
 * core dumps.  Note that the trapframe here is a copy of the one
 * from the top of the kernel stack (included here so that the kernel
 * stack itself need not be dumped).
 */
struct md_coredump {
	struct	trapframe md_tf;
};

#endif /* _M88K_PCB_H_ */
@


1.12
log
@Get rid of that ugly m88100_saved_state structure, use trapframe everywhere
instead.

Allow struct reg and struct trapframe to live different lives and grow
separately. Righty now they are still the same, and code expects a trapframe
to always start with a struct reg. This may change...
@
text
@d1 1
a1 1
/*	$OpenBSD: pcb.h,v 1.11 2003/11/08 16:43:00 miod Exp $ */
d77 8
a84 3
	union {
		struct reg	r;
	} F_r;
d87 39
a125 46
#define	tf_r		F_r.r.r
#define	tf_sp		F_r.r.r[31]
#define	tf_epsr		F_r.r.epsr
#define	tf_fpsr		F_r.r.fpsr
#define	tf_fpcr		F_r.r.fpcr
#define	tf_sxip		F_r.r.sxip
#define	tf_snip		F_r.r.snip
#define	tf_sfip		F_r.r.sfip
#define	tf_exip		F_r.r.sxip
#define	tf_enip		F_r.r.snip
#define	tf_ssbr		F_r.r.ssbr
#define	tf_dmt0		F_r.r.dmt0
#define	tf_dmd0		F_r.r.dmd0
#define	tf_dma0		F_r.r.dma0
#define	tf_dmt1		F_r.r.dmt1
#define	tf_dmd1		F_r.r.dmd1
#define	tf_dma1		F_r.r.dma1
#define	tf_dmt2		F_r.r.dmt2
#define	tf_dmd2		F_r.r.dmd2
#define	tf_dma2		F_r.r.dma2
#define	tf_duap		F_r.r.ssbr
#define	tf_dsr		F_r.r.dmt0
#define	tf_dlar		F_r.r.dmd0
#define	tf_dpar		F_r.r.dma0
#define	tf_isr		F_r.r.dmt1
#define	tf_ilar		F_r.r.dmd1
#define	tf_ipar		F_r.r.dma1
#define	tf_isap		F_r.r.dmt2
#define	tf_dsap		F_r.r.dmd2
#define	tf_iuap		F_r.r.dma2
#define	tf_fpecr	F_r.r.fpecr
#define	tf_fphs1	F_r.r.fphs1
#define	tf_fpls1	F_r.r.fpls1
#define	tf_fphs2	F_r.r.fphs2
#define	tf_fpls2	F_r.r.fpls2
#define	tf_fppt		F_r.r.fppt
#define	tf_fprh		F_r.r.fprh
#define	tf_fprl		F_r.r.fprl
#define	tf_fpit		F_r.r.fpit
#define	tf_scratch1	F_r.r.scratch1
#define	tf_vector	F_r.r.vector
#define	tf_mask		F_r.r.mask
#define	tf_mode		F_r.r.mode
#define	tf_ipfsr	F_r.r.ipfsr
#define	tf_dpfsr	F_r.r.dpfsr
#define	tf_cpu		F_r.r.cpu
@


1.11
log
@Save the current floatingpoint state in the pcb.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcb.h,v 1.10 2003/10/11 22:08:57 miod Exp $ */
d45 2
a46 2
 * in the kernel_state part of the PCB. Typically, trap fames are
 * save on the stack (by low level handlers or by hardware) but,
a49 7
/*
 * This must always be an even number of words long so that our stack
 * will always be properly aligned (88k need 8 byte alignment). Also,
 * place r14 on double word boundary so that we can use st.d while
 * saving the regs.
 */

d76 52
a127 2
#define m88100_saved_state reg
#define trapframe m88100_saved_state
d131 3
a133 3
	struct m88100_pcb		kernel_state;
	struct m88100_saved_state	user_state;
	int				pcb_onfault;
d140 1
a140 1
	(((struct m88100_saved_state *)  (&((p)->p_addr->u_pcb.user_state))))
@


1.10
log
@Nuke trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcb.h,v 1.9 2001/09/28 20:46:39 miod Exp $ */
d58 23
a80 20
    unsigned pcb_pc;	/* address to return */
    unsigned pcb_ipl;
    unsigned pcb_r14;
    unsigned pcb_r15;
    unsigned pcb_r16;
    unsigned pcb_r17;
    unsigned pcb_r18;
    unsigned pcb_r19;
    unsigned pcb_r20;
    unsigned pcb_r21;
    unsigned pcb_r22;
    unsigned pcb_r23;
    unsigned pcb_r24;
    unsigned pcb_r25;
    unsigned pcb_r26;
    unsigned pcb_r27;
    unsigned pcb_r28;
    unsigned pcb_r29;
    unsigned pcb_r30;
    unsigned pcb_sp; 	/* kernel stack pointer */
d88 3
a90 4
  struct m88100_pcb            kernel_state;
  struct m88100_saved_state    user_state;
  int	 		       pcb_onfault;	/* for copyin/copyout faults */
  int	 		       pcb_pad;		/* pad it XXX */
a91 2

typedef	struct pcb	*pcb_t;		/* exported */
@


1.9
log
@Typos of the day.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcb.h,v 1.8 2001/08/12 12:03:02 heko Exp $ */
d28 2
a29 2
/* 
 * Motorola 88100 pcb definitions 
d39 1
a39 1
/* 
@


1.8
log
@#(endif|else) foo is incorrect, make it #endif /* foo */
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pcb.h,v 1.7 2001/01/12 07:29:27 smurph Exp $ */
d52 1
a52 1
 * will always be properly aligned (88k need 8 byte alignmet). Also,
@


1.7
log
@Update vm interface to MACHIN_NEW_NONCONTIG.  Fix compile warning in pcctwo.c
@
text
@d1 1
a1 1
/*	$OpenBSD: pcb.h,v 1.6 2000/12/28 21:21:24 smurph Exp $ */
d108 1
a108 1
#endif _M88K_PCB_H_
@


1.6
log
@mvme88k updates to -current.  finally!
@
text
@d1 1
a1 1
/*	$OpenBSD: pcb.h,v 1.5 1999/09/27 20:46:19 smurph Exp $ */
d34 4
a37 2
#ifndef _PCB_H_
#define _PCB_H_
d80 1
a80 57

/*
 *	m88100_saved_state	this structure corresponds to the state
 *				of the user registers as saved on the
 *				stack upon kernel entry.  This structure
 *				is used internally only.  Since this
 *				structure may change from version to
 *				version, it is hidden from the user.
 */

/* This must always be an even number of words long */

struct m88100_saved_state {
    unsigned r[32];  /* 0 - 31 */
#define   tf_sp r[31]
    unsigned epsr;   /* 32 */
    unsigned fpsr;
    unsigned fpcr;
#define exip sxip
    unsigned sxip;
#define enip snip
    unsigned snip;
    unsigned sfip;
    unsigned ssbr;
    unsigned dmt0;
    unsigned dmd0;
    unsigned dma0;
    unsigned dmt1;
    unsigned dmd1;
    unsigned dma1;
    unsigned dmt2;
    unsigned dmd2;
    unsigned dma2;
    unsigned fpecr;
    unsigned fphs1;
    unsigned fpls1;
    unsigned fphs2;
    unsigned fpls2;
    unsigned fppt;
    unsigned fprh;
    unsigned fprl;
    unsigned fpit;
    unsigned vector;	      /* exception vector number */
    unsigned mask;	      /* interrupt mask level */
    unsigned mode;	      /* interrupt mode */
    unsigned scratch1;	   /* used by locore trap handling code */
    unsigned ipfsr;        /* P BUS status - used in inst fault handling */
    unsigned dpfsr;        /* P BUS status - used in data fault handling */
    unsigned dsr;          /* MVME197 */
    unsigned dlar;         /* MVME197 */
    unsigned dpar;         /* MVME197 */
    unsigned isr;          /* MVME197 */
    unsigned ilar;         /* MVME197 */
    unsigned ipar;         /* MVME197 */
    unsigned pad;          /* alignment */
};

d108 1
a108 1
#endif  _PCB_H_
@


1.5
log
@Adding support for MVME188 and MVME197
@
text
@d1 1
a1 1
/*	$OpenBSD: pcb.h,v 1.4 1999/02/09 06:36:27 smurph Exp $ */
d92 1
a92 1
#define pcb_sp r[31]
@


1.5.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcb.h,v 1.7 2001/01/12 07:29:27 smurph Exp $ */
d34 2
a35 4
#ifndef _M88K_PCB_H_
#define _M88K_PCB_H_

#include <machine/reg.h>
d78 57
a134 1
#define m88100_saved_state reg
d162 1
a162 1
#endif _M88K_PCB_H_
@


1.5.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: pcb.h,v 1.5.4.1 2001/04/18 16:11:24 niklas Exp $ */
d52 1
a52 1
 * will always be properly aligned (88k need 8 byte alignment). Also,
d108 1
a108 1
#endif /* _M88K_PCB_H_ */
@


1.5.4.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d28 2
a29 2
/*
 * Motorola 88100 pcb definitions
d39 1
a39 1
/*
d45 2
a46 2
 * in the kernel_state part of the PCB. Typically, trap frames are
 * saved on the stack (by low level handlers or by hardware) but,
d50 7
d58 20
a77 34
	unsigned pcb_pc;	/* address to return */
	unsigned pcb_ipl;
	unsigned pcb_r14;
	unsigned pcb_r15;
	unsigned pcb_r16;
	unsigned pcb_r17;
	unsigned pcb_r18;
	unsigned pcb_r19;
	unsigned pcb_r20;
	unsigned pcb_r21;
	unsigned pcb_r22;
	unsigned pcb_r23;
	unsigned pcb_r24;
	unsigned pcb_r25;
	unsigned pcb_r26;
	unsigned pcb_r27;
	unsigned pcb_r28;
	unsigned pcb_r29;
	unsigned pcb_r30;
	unsigned pcb_sp; 	/* kernel stack pointer */
	/* floating-point state */
	unsigned pcb_fcr62;
	unsigned pcb_fcr63;
};

struct trapframe {
	struct reg	tf_regs;
	register_t	tf_vector;	/* exception vector number */
	register_t	tf_mask;	/* interrupt mask level */
	register_t	tf_mode;	/* interrupt mode */
	register_t	tf_scratch1;	/* reserved for use by locore */
	register_t	tf_ipfsr;	/* P BUS status */
	register_t	tf_dpfsr;	/* P BUS status */
	register_t	tf_cpu;		/* cpu number */
d80 2
a81 39
#define	tf_r		tf_regs.r
#define	tf_sp		tf_regs.r[31]
#define	tf_epsr		tf_regs.epsr
#define	tf_fpsr		tf_regs.fpsr
#define	tf_fpcr		tf_regs.fpcr
#define	tf_sxip		tf_regs.sxip
#define	tf_snip		tf_regs.snip
#define	tf_sfip		tf_regs.sfip
#define	tf_exip		tf_regs.sxip
#define	tf_enip		tf_regs.snip
#define	tf_ssbr		tf_regs.ssbr
#define	tf_dmt0		tf_regs.dmt0
#define	tf_dmd0		tf_regs.dmd0
#define	tf_dma0		tf_regs.dma0
#define	tf_dmt1		tf_regs.dmt1
#define	tf_dmd1		tf_regs.dmd1
#define	tf_dma1		tf_regs.dma1
#define	tf_dmt2		tf_regs.dmt2
#define	tf_dmd2		tf_regs.dmd2
#define	tf_dma2		tf_regs.dma2
#define	tf_duap		tf_regs.ssbr
#define	tf_dsr		tf_regs.dmt0
#define	tf_dlar		tf_regs.dmd0
#define	tf_dpar		tf_regs.dma0
#define	tf_isr		tf_regs.dmt1
#define	tf_ilar		tf_regs.dmd1
#define	tf_ipar		tf_regs.dma1
#define	tf_isap		tf_regs.dmt2
#define	tf_dsap		tf_regs.dmd2
#define	tf_iuap		tf_regs.dma2
#define	tf_fpecr	tf_regs.fpecr
#define	tf_fphs1	tf_regs.fphs1
#define	tf_fpls1	tf_regs.fpls1
#define	tf_fphs2	tf_regs.fphs2
#define	tf_fpls2	tf_regs.fpls2
#define	tf_fppt		tf_regs.fppt
#define	tf_fprh		tf_regs.fprh
#define	tf_fprl		tf_regs.fprl
#define	tf_fpit		tf_regs.fpit
d85 4
a88 3
	struct m88100_pcb	kernel_state;
	struct trapframe	user_state;
	int			pcb_onfault;
d91 2
d97 1
a97 1
	(((struct reg *)(&((p)->p_addr->u_pcb.user_state))))
@


1.5.4.4
log
@Merge with the trunk
@
text
@d1 149
a149 3
/* $OpenBSD$ */
/* public domain */
#include <m88k/pcb.h>
@


1.4
log
@Added kernel support for user debugging.  Fixed file ID's
@
text
@d1 1
a1 1
/*	$OpenBSD: pcb.h,v 1.1 1998/12/15 06:02:55 smurph Exp $ */
d91 3
a93 1
    unsigned r[32];
d96 1
a96 1
    unsigned epsr;
d98 1
d120 13
a132 7
    unsigned vector;	/* exception vector number */
    unsigned mask;	/* interrupt mask level */
    unsigned mode;	/* interrupt mode */
    unsigned scratch1;	/* used by locore trap handling code */
    unsigned ipfsr;      /* P BUS status - used in inst fault handling */
    unsigned dpfsr;      /* P BUS status - used in data fault handling */
    unsigned pad;	/* alignment */
@


1.3
log
@Cleanup after import. This also seems to bring up the current version.
@
text
@d1 1
@


1.2
log
@This is a remove to get rid of the old mvme88k port which was incomplete
to replace it with a working version. The kernel compiles and works
at least.  The new version will be imported shortly.
@
text
@d2 1
d42 3
a44 1
 * in the kernel_state part of the PCB.
d47 6
a52 1
/* This must always be an even number of words long */
d56 1
a74 1
    unsigned pcb_mask;
d116 8
a123 6
    unsigned vector;   /* exception vector number */
    unsigned mask;	   /* interrupt mask level */
    unsigned mode;     /* interrupt mode */
    unsigned scratch1; /* used by locore trap handling code */
    unsigned pad;      /* to make an even length */
} ;
d129 1
a130 1
  struct m88100_pcb            kernel_state;
d132 1
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@initial 88k import; code by nivas and based on mach luna88k
@
text
@@


1.1.1.2
log
@Third try at importing the mvme88k port. This is a working kernel
from nivas.
Userland and compiler still need to be worked on.
Make certain what directory the import is done from.
@
text
@a1 1
 * Copyright (c) 1996 Nivas Madhur
d41 1
a41 3
 * in the kernel_state part of the PCB. Typically, trap fames are
 * save on the stack (by low level handlers or by hardware) but,
 * we just decided to do it in the PCB.
d44 1
a44 6
/*
 * This must always be an even number of words long so that our stack
 * will always be properly aligned (88k need 8 byte alignmet). Also,
 * place r14 on double word boundary so that we can use st.d while
 * saving the regs.
 */
a47 1
    unsigned pcb_ipl;
d66 1
d108 6
a113 8
    unsigned vector;	/* exception vector number */
    unsigned mask;	/* interrupt mask level */
    unsigned mode;	/* interrupt mode */
    unsigned scratch1;	/* used by locore trap handling code */
    unsigned ipfsr;      /* P BUS status - used in inst fault handling */
    unsigned dpfsr;      /* P BUS status - used in data fault handling */
    unsigned pad;	/* alignment */
};
d119 1
a120 1
  struct m88100_saved_state    user_state;
a121 1
  int	 		       pcb_pad;		/* pad it XXX */
@
