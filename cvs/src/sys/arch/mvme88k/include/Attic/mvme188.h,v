head	1.36;
access;
symbols
	OPENBSD_5_5:1.35.0.6
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.35.0.2
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.34.0.8
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.34.0.6
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.4
	OPENBSD_5_0:1.34.0.2
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.33.0.8
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.33.0.6
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.33.0.2
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.33.0.4
	OPENBSD_4_6_BASE:1.33
	OPENBSD_4_5:1.32.0.6
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.32.0.4
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.32.0.2
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.30.0.2
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.28.0.2
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.27.0.2
	OPENBSD_4_0_BASE:1.27
	OPENBSD_3_9:1.20.0.6
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.4
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.2
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.19.0.2
	OPENBSD_3_6_BASE:1.19
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.12.0.8
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.6
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.4
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.12
	UBC:1.10.0.2
	UBC_BASE:1.10
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.1.0.8
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.6
	OPENBSD_2_7_BASE:1.1
	SMP:1.1.0.4
	SMP_BASE:1.1
	kame_19991208:1.1
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.36
date	2014.03.18.22.36.36;	author miod;	state dead;
branches;
next	1.35;

1.35
date	2013.05.17.22.46.27;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2011.03.23.16.54.36;	author pirofti;	state Exp;
branches;
next	1.33;

1.33
date	2009.03.08.16.03.05;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2007.12.27.23.17.55;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2007.11.11.13.06.57;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2007.05.19.17.03.47;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2007.05.14.17.00.40;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2006.11.18.22.53.11;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2006.06.11.13.30.44;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2006.04.27.20.19.31;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2006.04.17.18.28.19;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2006.04.17.18.26.28;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2006.04.15.22.31.47;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2006.04.15.15.45.24;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2006.04.13.21.16.15;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2004.10.01.19.00.51;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2004.08.02.08.35.00;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2004.07.23.22.19.09;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2004.04.26.12.34.05;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2004.04.14.23.06.18;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2003.10.11.22.08.57;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2003.09.28.16.01.12;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2003.09.16.20.52.19;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2002.01.14.21.34.41;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.22.07.35.43;	author smurph;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.19.05.06.26;	author smurph;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2001.12.16.23.49.46;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2001.12.14.04.30.11;	author smurph;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.26.14.31.07;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.12.12.03.02;	author heko;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.16.00.05.25;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.07.23.37.16;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.01.03.38.18;	author smurph;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.14.20.25.24;	author smurph;	state Exp;
branches;
next	1.1;

1.1
date	99.09.27.20.46.18;	author smurph;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2001.04.18.16.11.23;	author niklas;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2001.10.31.03.01.19;	author nate;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2002.03.06.02.04.44;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2004.02.19.10.49.07;	author niklas;	state Exp;
branches;
next	1.1.4.5;

1.1.4.5
date	2004.06.05.23.09.50;	author niklas;	state Exp;
branches;
next	;

1.10.2.1
date	2002.01.31.22.55.18;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.36
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: mvme188.h,v 1.35 2013/05/17 22:46:27 miod Exp $ */
/*
 * Copyright (c) 1999 Steve Murphree, Jr.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Steve Murphree, Jr.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
/*
 * Mach Operating System
 * Copyright (c) 1991 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 */

#ifndef	_MACHINE_MVME188_H_
#define	_MACHINE_MVME188_H_

#define MVME188_EPROM		0xffc00000
#define MVME188_EPROM_SIZE	0x00080000
#define MVME188_SRAM		0xffe00000
#define MVME188_SRAM_SIZE	0x00020000
#define MVME188_UTILITY		0xfff00000
#define MVME188_UTILITY_SIZE	0x00090000

/*
 * MVME188 declarations for hardware level device registers and such.
 */

/* per-processor interrupt enable registers */
#define	MVME188_IENBASE	0xfff84000
#define MVME188_IEN0	0xfff84004	/* interrupt enable CPU 0 */
#define MVME188_IEN1	0xfff84008	/* interrupt enable CPU 1 */
#define MVME188_IEN2	0xfff84010	/* interrupt enable CPU 2 */
#define MVME188_IEN3	0xfff84020	/* interrupt enable CPU 3 */
#define	MVME188_IENALL	0xfff8403c	/* simultaneous write */
#define	MVME188_IEN(cpu)	(MVME188_IENBASE + (4 << (cpu)))

#define MVME188_IST	0xfff84040 	/* interrupt status register */

#define MVME188_SETSWI	0xfff84080 	/* generate soft interrupt */
#define MVME188_CLRSWI	0xfff84084 	/* reset soft interrupt */
#define MVME188_ISTATE	0xfff84088 	/* HW interrupt status */
#define MVME188_CLRINT	0xfff8408c 	/* reset HW interrupt */

#define MVME188_VIRQLV	0xfff85000
#define	MVME188_VIACK1V	0xfff85004
#define	MVME188_VIACK2V	0xfff85008
#define	MVME188_VIACK3V	0xfff8500c
#define	MVME188_VIACK4V	0xfff85010
#define	MVME188_VIACK5V	0xfff85014
#define	MVME188_VIACK6V	0xfff85018
#define	MVME188_VIACK7V	0xfff8501c
#define	MVME188_VIRQV	0xfff85020
#define M188_IVEC		0x40	/* vector returned upon MVME188 int */

#define	MVME188_GLOBAL0	0xfff86001	/* global control and status regs */
#define	MVME188_GLOBAL1	0xfff86003
#define	M188_LRST		0x80
#define	M188_SYSCON		0x40
#define	MVME188_BRDID	0xfff86005
#define	MVME188_CGCSR0	0xfff86007
#define	MVME188_CGCSR1	0xfff86009
#define	MVME188_CGCSR2	0xfff8600b
#define	MVME188_CGCSR3	0xfff8600d
#define	MVME188_CGCSR4	0xfff8600f
#define MVME188_UCSR	0xfff87000	/* utility control and status reg */
#define	MVME188_BASAD	0xfff87004	/* base address reg */
#define MVME188_GLBRES	0xfff8700c	/* global reset reg */

#define MVME188_CCSR	0xfff88000	/* CPU board control status reg */
#define MVME188_ERROR	0xfff88004	/* Mbus fault reg */
#define MVME188_PCNFA	0xfff88008	/* Pbus A decoder reg */
#define MVME188_PCNFB	0xfff8800c	/* Pbus B decoder reg */
#define MVME188_EXTAD	0xfff88010	/* A24 master A24-A31 addr reg */
#define MVME188_WHOAMI	0xfff88018	/* whoami reg */
#define MVME188_WMAD	0xfff88020	/* write mbus addr decoder reg */
#define MVME188_RMAD	0xfff88024	/* read mbus addr decoder reg */
#define MVME188_WVAD	0xfff88028	/* write vmebus addr decoder reg */
#define MVME188_RVAD	0xfff8802c	/* read vmebus adds decoder reg */

/*
 * IEN and IST register bits
 * Refer to MVME188 RISC Microcomputer User's Manual, table 4.3
 */

#define IRQ_ABORT		0x80000000	/* 31 */
#define IRQ_ACF			0x40000000	/* 30 */
#define IRQ_ARBTO		0x20000000	/* 29 */
#define IRQ_DTI			0x10000000	/* 28 */
#define IRQ_SWI7		0x08000000	/* 27 */
#define IRQ_SWI6		0x04000000	/* 26 */
#define IRQ_SWI5		0x02000000	/* 25 */
#define IRQ_SWI4		0x01000000	/* 24 */
#define IRQ_VME7		0x00800000	/* 23 */
#define IRQ_CIOI		0x00200000	/* 21 */
#define IRQ_SF			0x00100000	/* 20 */
#define IRQ_VME6		0x00080000	/* 19 */
#define IRQ_DI			0x00020000	/* 17 */
#define IRQ_SIGHPI		0x00010000	/* 16 */
#define IRQ_VME5		0x00004000	/* 14 */
#define IRQ_VME4		0x00001000	/* 12 */
#define IRQ_VME3		0x00000400	/* 10 */
#define IRQ_LMI			0x00000100	/* 08 */
#define IRQ_SIGLPI		0x00000080	/* 07 */
#define IRQ_VME2		0x00000040	/* 06 */
#define IRQ_VME1		0x00000010	/* 04 */
#define IRQ_SWI3		0x00000008	/* 03 */
#define IRQ_SWI2		0x00000004	/* 02 */
#define IRQ_SWI1		0x00000002	/* 01 */
#define IRQ_SWI0		0x00000001	/* 00 */

#define IST_STRING	"\20" \
	"\40ABRT\37ACF\36ARBTO\35DTI\34SWI7\33SWI6\32SWI5\31SWI4" \
	"\30IRQ7\26CIOI\25SF\24IRQ6\22DI\21SIGHPI" \
	"\17IRQ5\15IRQ4\13IRQ3\11LMI" \
	"\10SIGLPI\7IRQ2\5IRQ1\4SWI3\3SWI2\2SWI1\1SWI0"

/* IPI bits (see below) */
#define	CLOCK_IPI_MASK		(IRQ_SWI7 | IRQ_SWI6 | IRQ_SWI5 | IRQ_SWI4)
#define	IPI_MASK		(IRQ_SWI3 | IRQ_SWI2 | IRQ_SWI1 | IRQ_SWI0)

#define ISR_GET_CURRENT_MASK(cpu) \
	(*(volatile u_int *)MVME188_IST & int_mask_reg[cpu])

/*
 * Software interrupts 0 to 3, and 4 to 7, are used to deliver IPIs to cpu0-3.
 * We use two bits because we want clock ipis to be maskable.
 * We rely on the fact that the control bits for these interrupts are
 * the same in the interrupt registers and the set/clear SWI registers.
 */
/* values for SETSWI and CLRSWI registers */
#define	SWI_IPI_BIT(cpuid)		(0x01 << (cpuid))
#define	SWI_CLOCK_IPI_BIT(cpuid)	(0x10 << (cpuid))
/* values for IEN and IST registers */
#define	SWI_IPI_MASK(cpuid)		(IRQ_SWI0 << (cpuid))
#define	SWI_CLOCK_IPI_MASK(cpuid)	(IRQ_SWI4 << (cpuid))

/*
 * ISTATE and CLRINT register bits
 */

#define ISTATE_ABORT		0x04
#define	ISTATE_ACFAIL		0x02
#define	ISTATE_SYSFAIL		0x01

/*
 * UCSR register bits
 */

#define UCSR_PWRUPBIT 	0x00004000	/* powerup indicator */
#define UCSR_DRVSFBIT 	0x00002000	/* Board system fail */
#define UCSR_BRIRQBIT 	0x00001000	/* drives VME IRQ1 broadcast int */
#define UCSR_ROBINBIT 	0x00000800	/* sel round robin VME arbiter mode */
#define UCSR_BRLVBITS 	0x00000600	/* VME bus request level 0-3 */
#define UCSR_RNEVERBIT  0x00000100	/* VME bus never release once req'd */
#define UCSR_RONRBIT	0x00000080	/* VME bus req release on no request */
#define UCSR_RWDBIT	0x00000040	/* VME bus request release when done */
#define UCSR_EARBTOBIT  0x00000020	/* enable VME arbiter bus timeout */
#define VTOSELBITS	0x00000018	/* VMEbus timeout select bits */
#define VTO32US			0x00	/* 32 usec */
#define VTO64US			0x01	/* 64 usec */
#define VTO128US		0x10	/* 128 usec */
#define VTODISABLE		0x18	/* disabled */

/* these are the various Z8536 CIO counter/timer registers */
#define CIO_BASE		0xfff83000
#define CIO_PORTC		0xfff83000
#define CIO_PORTB		0xfff83004
#define CIO_PORTA		0xfff83008
#define CIO_CTRL		0xfff8300c

#define DART_BASE		0xfff82000

/*
 * HYPERmodule CMMU addresses
 */

#define VME_CMMU_I0	0xfff7e000
#define VME_CMMU_I1	0xfff7d000
#define VME_CMMU_I2	0xfff7b000
#define VME_CMMU_I3	0xfff77000
#define VME_CMMU_D0	0xfff6f000
#define VME_CMMU_D1	0xfff5f000
#define VME_CMMU_D2	0xfff3f000
#define VME_CMMU_D3	0xfff7f000

#endif	/* _MACHINE_MVME188_H_ */
@


1.35
log
@Replace the bunch of md_* function pointers with a `struct board' containing
function pointers for all the board-specific code.

Add a bunch of `struct board' methods to cover most, if not all, of the
`per-board' logic. This allows most of the md drivers to be cleaned up and
no longer need to embed board-specific knowledge.
@
text
@d1 1
a1 1
/*	$OpenBSD: mvme188.h,v 1.34 2011/03/23 16:54:36 pirofti Exp $ */
@


1.34
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mvme188.h,v 1.33 2009/03/08 16:03:05 miod Exp $ */
a216 8

#if defined(_KERNEL) && !defined(_LOCORE)
extern u_int32_t pfsr_save_188_straight[];
extern u_int32_t pfsr_save_188_double[];
extern u_int32_t pfsr_save_188_quad[];

extern u_int32_t int_mask_val[NIPLS];
#endif
@


1.33
log
@Move more z8536 defines from MVME188 specific code to the MI header and use it.
@
text
@d1 1
a1 1
/*	$OpenBSD: mvme188.h,v 1.32 2007/12/27 23:17:55 miod Exp $ */
d46 2
a47 2
#ifndef	__MACHINE_MVME188_H__
#define	__MACHINE_MVME188_H__
d226 1
a226 1
#endif	/* __MACHINE_MVME188_H__ */
@


1.32
log
@Make the mvme188 interrupt handling closer to the aviion interrupt handling:
non-VME syscon interrupt sources will now use their own intrhand array,
and interrupt sources will be enabled in the arbiter as interrupt handlers
are registered. This allows VME devices to use the whole 256 interrupts range.
@
text
@d1 1
a1 1
/*	$OpenBSD: mvme188.h,v 1.31 2007/11/11 13:06:57 miod Exp $ */
a201 52

#define CIO_MICR		0x00	/* Master interrupt control register */
#define CIO_MICR_MIE		0x80
#define CIO_MICR_DLC		0x40
#define CIO_MICR_NV		0x20
#define CIO_MICR_PAVIS		0x10
#define CIO_MICR_PBVIS		0x08
#define CIO_MICR_CTVIS		0x04
#define CIO_MICR_RJA		0x02
#define CIO_MICR_RESET		0x01

#define CIO_MCCR		0x01	/* Master config control register */
#define CIO_MCCR_PBE		0x80
#define CIO_MCCR_CT1E		0x40
#define CIO_MCCR_CT2E		0x20
#define CIO_MCCR_CT3E		0x10
#define CIO_MCCR_PLC		0x08
#define CIO_MCCR_PAE		0x04

#define CIO_CTMS1		0x1c	/* Counter/timer mode specification #1 */
#define CIO_CTMS2		0x1d	/* Counter/timer mode specification #2 */
#define CIO_CTMS3		0x1e	/* Counter/timer mode specification #3 */
#define CIO_CTMS_CSC		0x80	/* Continuous Single Cycle */
#define CIO_CTMS_EOE		0x40	/* External Output Enable  */
#define CIO_CTMS_ECE		0x20	/* External Count Enable   */
#define CIO_CTMS_ETE		0x10	/* External Trigger Enable */
#define CIO_CTMS_EGE		0x08	/* External Gate Enable    */
#define CIO_CTMS_REB		0x04	/* Retrigger Enable Bit    */
#define CIO_CTMS_PO		0x00	/* Pulse Output            */
#define CIO_CTMS_OSO		0x01	/* One Shot Output         */
#define CIO_CTMS_SWO		0x02	/* Square Wave Output      */

#define CIO_IVR			0x04	/* Interrupt vector register */

#define CIO_CSR1		0x0a	/* Command and status register CTC #1 */
#define CIO_CSR2		0x0b	/* Command and status register CTC #2 */
#define CIO_CSR3		0x0c	/* Command and status register CTC #3 */

#define CIO_CT1MSB		0x16	/* CTC #1 Timer constant - MSB */
#define CIO_CT1LSB		0x17	/* CTC #1 Timer constant - LSB */
#define CIO_CT2MSB		0x18	/* CTC #2 Timer constant - MSB */
#define CIO_CT2LSB		0x19	/* CTC #2 Timer constant - LSB */
#define CIO_CT3MSB		0x1a	/* CTC #3 Timer constant - MSB */
#define CIO_CT3LSB		0x1b	/* CTC #3 Timer constant - LSB */
#define CIO_PDCA		0x23	/* Port A data direction control */
#define CIO_PDCB		0x2b	/* Port B data direction control */

#define CIO_GCB			0x04	/* CTC Gate command bit */
#define CIO_TCB			0x02	/* CTC Trigger command bit */
#define CIO_IE			0xc0	/* CTC Interrupt enable (set) */
#define CIO_CIP			0x20	/* CTC Clear interrupt pending */
#define CIO_IP			0x20	/* CTC Interrupt pending */
@


1.31
log
@Use two software interrupt sources per processor for IPIs, instead of only
one, so that we can have maskable and unmaskable IPIs. Make the clock ipis
maskable, and masked at IPL_CLOCK and above. This allows us to get rid
of the retrig hack in setipl().
@
text
@d1 1
a1 1
/*	$OpenBSD: mvme188.h,v 1.30 2007/05/19 17:03:47 miod Exp $ */
a148 4
/* groups by function */

/* hardware irq bits */
#define HW_FAILURE_MASK		(IRQ_ABORT | IRQ_ACF | IRQ_ARBTO | IRQ_SF)
d150 2
a151 30
#define CLOCK_IPI_MASK		(IRQ_SWI7 | IRQ_SWI6 | IRQ_SWI5 | IRQ_SWI4)
#define IPI_MASK		(IRQ_SWI3 | IRQ_SWI2 | IRQ_SWI1 | IRQ_SWI0)
/* VME irq bits */
#define VME_INTERRUPT_MASK	(IRQ_VME7 | IRQ_VME6 | IRQ_VME5 | IRQ_VME4 | \
				 IRQ_VME3 | IRQ_VME2 | IRQ_VME1)
/* on-board irq bits */
#define OBIO_INTERRUPT_MASK	(IRQ_DTI | IRQ_CIOI | IRQ_DI | IRQ_SIGHPI | \
				 IRQ_LMI | IRQ_SIGLPI)

/* groups by interrupt levels */

#define LVL7			(IRQ_ABORT | IRQ_ACF /* | IRQ_VME7 */ | IRQ_SF)
#define LVL6			(IRQ_VME6)
#define LVL5			(IRQ_VME5 | IRQ_DTI | IRQ_CIOI)
#define LVL4			(IRQ_VME4)
#define LVL3			(IRQ_VME3 | IRQ_DI)
#define LVL2			(IRQ_VME2)
#define LVL1			(IRQ_VME1)

/* interrupts we want to process on the master CPU only */
#define SLAVE_MASK (HW_FAILURE_MASK | OBIO_INTERRUPT_MASK | VME_INTERRUPT_MASK)

#define MASK_LVL_0		(LVL7 | LVL6 | LVL5 | LVL4 | LVL3 | LVL2 | LVL1)
#define MASK_LVL_1		(LVL7 | LVL6 | LVL5 | LVL4 | LVL3 | LVL2)
#define MASK_LVL_2		(LVL7 | LVL6 | LVL5 | LVL4 | LVL3)
#define MASK_LVL_3		(LVL7 | LVL6 | LVL5 | LVL4)
#define MASK_LVL_4		(LVL7 | LVL6 | LVL5)
#define MASK_LVL_5		(LVL7 | LVL6)
#define MASK_LVL_6		(LVL7)
#define MASK_LVL_7		(IRQ_ABORT)
a152 1
#define INT_LEVEL	        8		/* # of interrupt level + 1 */
d274 2
@


1.30
log
@Try reducing the number of IPIs, by only reinflicting them to us if we are
lowering the spl.

Also, warn and halt in tracks if the interrupt pin of a secondary cpu never
clears (found the hard way in one of the 2P256 modules here), since there is
nothing better we can do.

Last, do not attempt to handle VME interrupts on secondary processors yes
(this confuses the bus, since both processors will perform a VME interrupt
acknowledge sequence, but only one will succeed).

This lets processes correctly run on all the available processors in
single-user mode, but there are still issues to sort out.
@
text
@d1 1
a1 1
/*	$OpenBSD: mvme188.h,v 1.29 2007/05/14 17:00:40 miod Exp $ */
a152 2
/* software irq bits */
#define SOFT_INTERRUPT_MASK	(IRQ_SWI7 | IRQ_SWI6 | IRQ_SWI5 | IRQ_SWI4)
d154 1
a171 1
#define LVL0			(0x0)
d190 2
a191 1
 * Software interrupts 0 to 3 are used to deliver IPIs to cpu0-3.
d195 6
a200 1
#define	IPI_BIT(cpuid)		(1 << (cpuid))
@


1.29
log
@Work in progress IPI mechanism, currently only implemented on MVME188, to
send clock ticks to secondary processors.
@
text
@d1 1
a1 1
/*	$OpenBSD: mvme188.h,v 1.28 2006/11/18 22:53:11 miod Exp $ */
d61 1
d67 1
d166 1
a166 1
#define LVL7			(IRQ_ABORT | IRQ_ACF | IRQ_VME7 | IRQ_SF)
d176 1
a176 1
#define SLAVE_MASK		(HW_FAILURE_MASK | OBIO_INTERRUPT_MASK)
d189 1
a189 1
	(*(volatile u_int *)MVME188_IST & *int_mask_reg[cpu])
@


1.28
log
@Rework the PFSR register analysis code on mvme88k: split it into four
independent subfunctions, turn PFSR_SAVE into a couple of NOP, and replace
them early at runtime with a branch to the selected routine, which will
return to pfsr_save.
This is really better for 188 systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: mvme188.h,v 1.27 2006/06/11 13:30:44 miod Exp $ */
d152 3
a154 2
#define SOFT_INTERRUPT_MASK	(IRQ_SWI7 | IRQ_SWI6 | IRQ_SWI5 | IRQ_SWI4 | \
				 IRQ_SWI3 | IRQ_SWI2 | IRQ_SWI1 | IRQ_SWI0)
d188 7
@


1.27
log
@Typo
@
text
@d1 1
a1 1
/*	$OpenBSD: mvme188.h,v 1.26 2006/04/27 20:19:31 miod Exp $ */
d288 6
@


1.26
log
@Adjust sizes for the mandatory 1:1 mappings created in pmap_bootstrap().
Saves up to 12KB of no longer necessary page tables.
@
text
@d1 1
a1 1
/*	$OpenBSD: mvme188.h,v 1.25 2006/04/17 18:28:19 miod Exp $ */
d144 1
a144 1
	"\17IRQ5\15IRQ4\13IRQ3\11LWI" \
@


1.25
log
@Do not mask the MVME188 abort button interrupt at splhigh(), similar to MVME197.
@
text
@d1 1
a1 1
/*	$OpenBSD: mvme188.h,v 1.24 2006/04/17 18:26:28 miod Exp $ */
d53 2
a54 4
#define MVME188_UTILITY		0xff000000
#define MVME188_UTILITY_SIZE	0x01000000
#define UTIL_START		0xffc00000  /* start of MVME188 utility space */
#define UTIL_SIZE		0x003fffff  /* size of MVME188 utility space */
@


1.24
log
@Better constant names for the MVME188 GCSR set.
@
text
@d1 1
a1 1
/*	$OpenBSD: mvme188.h,v 1.23 2006/04/15 22:31:47 miod Exp $ */
d184 1
a184 1
#define MASK_LVL_7		0x00000000 /* all ints disabled */
@


1.23
log
@Remove DART defines from <machine/mvme188.h> (except for its base address),
and compensate in clock.c which still needs to access a few of its
registers.

While there, access DART registers as bytes as advised in the manual, not
as ints.
@
text
@d1 1
a1 1
/*	$OpenBSD: mvme188.h,v 1.22 2006/04/15 15:45:24 miod Exp $ */
d87 10
a96 7
#define MVME188_GCSR	0xfff86000	/* global control and status reg */
#define GLB0		0xfff86001
#define GLB1		0xfff86003
#define GLB2		0xfff86005
#define GLB3		0xfff86007
#define	M188_LRST	0x00000080
#define	M188_SYSCON	0x00000040
@


1.22
log
@Clean up <machine/mvme188.h> out of duplicate defines, sort them by relevance,
add more comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: mvme188.h,v 1.21 2006/04/13 21:16:15 miod Exp $ */
a272 1
/* these are the DART read registers */
a273 30
#define DART_MRA		0xfff82000	/* mode A */
#define DART_SRA		0xfff82004	/* status A */
#define DART_RBA		0xfff8200c	/* receive buffer A */
#define DART_IPCR		0xfff82010	/* input port change */
#define DART_ISR		0xfff82014	/* interrupt status */
#define DART_CUR		0xfff82018	/* count upper */
#define DART_CLR		0xfff8201c	/* count lower */
#define DART_MR1B		0xfff82020	/* mode B */
#define DART_SRB		0xfff82024	/* status B */
#define DART_RBB		0xfff8202c	/* receive buffer B */
#define DART_IVR		0xfff82030	/* interrupt vector */
#define DART_INP		0xfff82034	/* input port */
#define DART_STARTC		0xfff82038	/* start counter cmd */
#define DART_STOPC		0xfff8203c	/* stop counter cmd */

/* these are the DART write registers */
#define DART_CSRA		0xfff82004	/* clock select A */
#define DART_CRA		0xfff82008	/* command A */
#define DART_TBA		0xfff8200c	/* transmit buffer A */
#define DART_ACR		0xfff82010	/* auxiliary control */
#define DART_IMR		0xfff82014	/* interrupt mask reg*/
#define DART_CTUR		0xfff82018	/* counter/timer MSB */
#define DART_CTLR		0xfff8201c	/* counter/timer LSB */
#define DART_MRB		0xfff82020	/* mode B */
#define DART_CSRB		0xfff82024	/* clock select B */
#define DART_CRB		0xfff82028	/* command B */
#define DART_TBB		0xfff8202c	/* transmit buffer B */
#define DART_OPCR		0xfff82034	/* output port config*/
#define DART_OPRS		0xfff82038	/* output port set */
#define DART_OPRR		0xfff8203c	/* output port reset */
@


1.21
log
@Drop the ivec[] interrupt acknowledge address array, compute the address
itself in the interrupt dispatcher instead of accessing the array: this
computation is of similar complexity, so why bother adding a memory
indirection. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mvme188.h,v 1.20 2004/10/01 19:00:51 miod Exp $ */
d49 1
a49 1
#define MVME188_EPROM		0xFFC00000
d51 1
a51 1
#define MVME188_SRAM		0xFFE00000
d53 1
a53 1
#define MVME188_UTILITY		0xFF000000
d55 2
a56 2
#define UTIL_START		0xFFC00000  /* start of MVME188 utility space */
#define UTIL_SIZE		0x003FFFFF  /* size of MVME188 utility space */
a61 4
/* base address for the interrupt control registers */
#define INTR_CONTROL_BASE	0xfff84000
#define VMEA24SPACE	0xEEC00000 	/*  VMEA24 master addr space (4 Meg) */

d63 22
a84 36
#define MVME188_IEN0	0xFFF84004	/* interrupt enable CPU 0 */
#define MVME188_IEN1	0xFFF84008	/* interrupt enable CPU 1 */
#define MVME188_IEN2	0xFFF84010	/* interrupt enable CPU 2 */
#define MVME188_IEN3	0xFFF84020	/* interrupt enable CPU 3 */

/* same as above */
#define IEN0_REG	0xfff84004
#define IEN1_REG	0xfff84008
#define IEN2_REG	0xfff84010
#define IEN3_REG	0xfff84020

#define IENALL_REG	0xfff8403c

#define MVME188_IST	0xFFF84040 	/* interrupt status register */
#define IST_REG		0xfff84040	/* same as above */

#define MVME188_SETSWI	0xFFF84080 	/* generate soft interrupt */
#define MVME188_CLRSWI	0xFFF84084 	/* reset soft interrupt */
#define MVME188_ISTATE	0xFFF84088 	/* HW interrupt status */
#define MVME188_CLRINT	0xFFF8408C 	/* reset HW interrupt */

/* same as above */
#define SETSWI_REG	0xfff84080	/* SETSWI register addr */
#define CLRSWI_REG	0xfff84084	/* CLRSWI register addr */
#define ISTATE_REG	0xfff84088
#define CLRINT_REG	0xfff8408C

#define MVME188_VIRQLV	0xFFF85000
#define	MVME188_VIACK1V	0xFFF85004
#define	MVME188_VIACK2V	0xFFF85008
#define	MVME188_VIACK3V	0xFFF8500C
#define	MVME188_VIACK4V	0xFFF85010
#define	MVME188_VIACK5V	0xFFF85014
#define	MVME188_VIACK6V	0xFFF85018
#define	MVME188_VIACK7V	0xFFF8501C
#define	MVME188_VIRQV	0xFFF85020
d87 1
a87 6
#define MVME188_GCSR	0xFFF86000	/* 188 global control and status reg */
#define MVME188_UCSR	0xFFF87000	/* 188 utility control and status reg */
#define MVME188_BASAD	0xFFF87004	/* 188 base address reg */
#define MVME188_GLBRES	0xFFF8700C	/* 188 global reset reg */

#define GCSR_BASE	0xfff86000
d94 14
a107 56
#define UCSR_REG	0xfff87000
#define GLBRES_REG	0xfff8700C

#define MVME188_CCSR	0xFFF88000	/* 188 CPU board control status reg */
#define MVME188_ERROR	0xFFF88004	/* 188 Mbus fault reg */
#define MVME188_PCNFA	0xFFF88008	/* 188 Pbus A decoder reg */
#define MVME188_PCNFB	0xFFF8800C	/* 188 Pbus B decoder reg */
#define MVME188_EXTAD	0xFFF88010	/* 188 A24 master A24-A31 addr reg */
#define MVME188_WHOAMI	0xFFF88018	/* 188 whoami reg */
#define MVME188_WMAD	0xFFF88020	/* 188 write mbus addr decoder reg */
#define MVME188_RMAD	0xFFF88024	/* 188 read mbus addr decoder reg */
#define MVME188_WVAD	0xFFF88028	/* 188 write vmebus addr decoder reg */
#define MVME188_RVAD	0xFFF8802C	/* 188 read vmebus adds decoder reg */

/* duplicates of above */
#define CCSR_REG	0xfff88000
#define ERROR_REG	0xfff88004	/* ERROR register addr */
#define PCNFA_REG	0xfff88008
#define PCNFB_REG	0xfff8800c
#define EXTAD_REG	0xfff88010
#define EXTAM_REG	0xfff88014
#define WHOAMI_REG	0xfff88018	/* WHOAMI register addr */
#define WMAD_REG	0xfff88020
#define RMAD_REG	0xfff88024
#define WVAD_REG	0xfff88028
#define RVAD_REG	0xfff8802c

#define MAD_MDS		0x07	/* 188 MAD Device Select bits */

#define VMEA24		0x5	/* Mbus addess decode select for VMEA24 */
#define VADV		0x1	/* vmeaddres decode enable */
#define VBDSELBIT	0	/* bit to enable vme slave response low true */
#define VBDISABLE	0x1	/* VME BUS Disable */
#define VSDBIT		1	/* bit number to enable snooping low true */
#define VSDISABLE	0x2	/* VME Snoop Disable */
#define VASPBIT		21	/* addr space 0 = A32, 1 = A24 bit */
#define VASP		0x00200000	/* A24 VME address space */
#define VPN		0x00400000	/* Page Number LSB */
#define PAGECNT		0x400	/* number of (4 meg) pages to map */

#define UCSR_PWRUPBIT 	0x4000	/* 188 UCSR powerup indicator */
#define UCSR_DRVSFBIT 	0x2000	/* 188 UCSR Board system fail */
#define UCSR_BRIRQBIT 	0x1000	/* 188 UCSR drives VME IRQ1 broadcast int */
#define UCSR_ROBINBIT 	0x800	/* 188 UCSR sel round robin VME arbiter mode */
#define UCSR_BRLVBITS 	0x600	/* 188 UCSR VME bus request level 0-3 */
#define UCSR_RNEVERBIT  0x100	/* 188 UCSR VME bus never release once req'd */
#define UCSR_RONRBIT	0x80	/* 188 UCSR VME bus req release on no request */
#define UCSR_RWDBIT	0x40	/* 188 UCSR VME bus request release when done */
#define UCSR_EARBTOBIT  0x20	/* 188 UCSR enable VME arbiter bus timeout */

/* MVME188 VMEbus data transfer timeout select */
#define VTOSELBITS	0x18	/* 188 UCSR VMEbus timeout select bits */
#define VTO32US		0x00	/* VMEbus timeout length - 32 MicroSec */
#define VTO64US		0x01	/* VMEbus timeout length - 64 MicroSec */
#define VTO128US	0x10	/* VMEbus timeout length - 128 MicroSec */
#define VTODISABLE	0x18	/* VMEbus timeout length - disabled */
d110 2
a111 2
 * processor dependend code section
 * main goal is to concentrate HW dependencies into a few lines
a112 19
#define ISR_LOW_SOFTINT_MASK(cpu)	(1 << (cpu))
#define ISR_HIGH_SOFTINT_MASK(cpu)	(1 << ((cpu) + 24))
#define ISR_LOW_SOFTMASK		0xf
#define ISR_HIGH_SOFTMASK		(0xf << 24)
#define ISR_SOFTINT_EXCEPT_MASK(cpu) \
	(ISR_LOW_SOFTINT_MASK(cpu) | ISR_HIGH_SOFTINT_MASK(cpu) | 0xf0fffff0)
#define ISR_CLOCKINT_MASK		(1 << IEN_CIOI_LOG)

#define ISR_RESET_NMI			*(int *volatile)MVME188_CLRINT = 1 << CLRINT_CLRABRTI_LOG
#define ISR_RESET_SYSFAIL		*(int *volatile)MVME188_CLRINT = 1 << CLRINT_CLRSFI_LOG
#define ISR_RESET_ACFAIL		*(int *volatile)MVME188_CLRINT = 1 << CLRINT_CLRACFI_LOG
#define ISR_RESET_LOW_SOFTINT(cpu)	*(int *)MVME188_CLRSWI = ISR_LOW_SOFTINT_MASK(cpu)
#define ISR_RESET_HIGH_SOFTINT(cpu)	*(int *)MVME188_CLRSWI = (1 << (cpu + MAX_CPUS))
#define ISR_DETERMINE_LOW_SOFTINT(cpu)	*(unsigned int *volatile)MVME188_IST & ISR_LOW_SOFTINT_MASK(cpu)
#define ISR_DETERMINE_HIGH_SOFTINT(cpu)	*(unsigned int *volatile)MVME188_IST & ISR_HIGH_SOFTINT_MASK(cpu)
#define ISR_GENERATE_LOW_SOFTINT(cpu)	*((unsigned int *volatile)MVME188_SETSWI) = ISR_LOW_SOFTINT_MASK(cpu)
#define ISR_GENERATE_HIGH_SOFTINT(cpu)	*((unsigned int *volatile)MVME188_SETSWI) = (1 << (cpu + MAX_CPUS))
#define ISR_RESET_MACHINE		*((unsigned *volatile) MVME188_GLBRES) = 1
#define ISR_GET_CURRENT_MASK(cpu)	*int_mask_reg[cpu] & *(int *volatile)MVME188_IST
d114 68
a181 1
#define IST_STRING "\20\40ABRT\37ACF\36ARBTO\35DTI\34SWI7\33SWI6\32SWI5\31SWI4\30IRQ7\27res\26CIOI\25SF\24IRQ6\23res\22DI\21SIGHPI\20res\17IRQ5\16res\15IRQ4\14res\13IRQ3\12res\11LWI\10SIGLPI\7IRQ2\6res\5IRQ1\4SWI3\3SWI2\2SWI1\1SWI0"
d184 2
d187 7
a193 36
#define IEN_ABRT_LOG		31
#define IEN_CIOI_LOG		21
#define IEN_DTI_LOG		28
#define IEN_DI_LOG		17

#define CLRINT_CLRABRTI_LOG	2		/* offset into CLRSWI */
#define CLRINT_CLRACFI_LOG	1		/* offset into CLRSWI */
#define CLRINT_CLRSFI_LOG	0		/* offset into CLRSWI */

/* the following codes are the INT exception enable and status bits. */
/* Refer to MVME188 RISC Microcomputer User's Manual, 4-10. */
#define ABRT_BIT		0x80000000	/* 31 */
#define ACF_BIT			0x40000000	/* 30 */
#define ARBTO_BIT		0x20000000	/* 29 */
#define DTI_BIT			0x10000000	/* 28 */
#define SWI7_BIT		0x08000000	/* 27 */
#define SWI6_BIT		0x04000000	/* 26 */
#define SWI5_BIT		0x02000000	/* 25 */
#define SWI4_BIT		0x01000000	/* 24 */
#define IRQ7_BIT		0x00800000	/* 23 */
#define CIOI_BIT		0x00200000	/* 21 */
#define SF_BIT			0x00100000	/* 20 */
#define IRQ6_BIT		0x00080000	/* 19 */
#define DI_BIT			0x00020000	/* 17 */
#define SIGHPI_BIT		0x00010000	/* 16 */
#define IRQ5_BIT		0x00004000	/* 14 */
#define IRQ4_BIT		0x00001000	/* 12 */
#define IRQ3_BIT		0x00000400	/* 10 */
#define LMI_BIT			0x00000100	/* 08 */
#define SIGLPI_BIT		0x00000080	/* 07 */
#define IRQ2_BIT		0x00000040	/* 06 */
#define IRQ1_BIT		0x00000010	/* 04 */
#define SWI3_BIT		0x00000008	/* 03 */
#define SWI2_BIT		0x00000004	/* 02 */
#define SWI1_BIT		0x00000002	/* 01 */
#define SWI0_BIT		0x00000001	/* 00 */
d196 1
a196 2
 * masks and offsets for IST
 * These are a combination of the above
d198 15
a212 28
#define HW_FAILURE_MASK		0xE0100000	/* hardware irq bits */
#define SOFT_INTERRUPT_MASK	0x0F00000F	/* software irq bits */
#define VME_INTERRUPT_MASK	0x00885450	/* vme irq bits */
#define OBIO_INTERRUPT_MASK	0x10330180	/* on board I/O */

#define HW_FAILURE_ACF		ACF_BIT		/* AC failure */
#define HW_FAILURE_ABRTO	ARBTO_BIT	/* Arbiter timeout */
#define HW_FAILURE_SYSFAIL	SF_BIT		/* SYSFAIL asserted */
#define HW_FAILURE_ABORT	ABRT_BIT	/* Abort pressed */

#define LVL7 (ABRT_BIT | ACF_BIT | IRQ7_BIT | SF_BIT)
#define LVL6 (IRQ6_BIT)
#define LVL5 (IRQ5_BIT | DTI_BIT | CIOI_BIT)
#define LVL4 (IRQ4_BIT)
#define LVL3 (IRQ3_BIT | DI_BIT)
#define LVL2 (IRQ2_BIT)
#define LVL1 (IRQ1_BIT)
#define LVL0 (0x0)
#define SLAVE_MASK (LVL6 | LVL1)

#define MASK_LVL_0 (LVL7 | LVL6 | LVL5 | LVL4 | LVL3 | LVL2 | LVL1)
#define MASK_LVL_1 (LVL7 | LVL6 | LVL5 | LVL4 | LVL3 | LVL2)
#define MASK_LVL_2 (LVL7 | LVL6 | LVL5 | LVL4 | LVL3)
#define MASK_LVL_3 (LVL7 | LVL6 | LVL5 | LVL4)
#define MASK_LVL_4 (LVL7 | LVL6 | LVL5)
#define MASK_LVL_5 (LVL7 | LVL6)
#define MASK_LVL_6 (LVL7)
#define MASK_LVL_7 0x00000000 /* all ints disabled */
@


1.20
log
@More mvme88k code cleaning:
- merge locore_c_routines.c into machdep.c
- split machdep.c into really machdep.c content, and board-specific routines
  (memory sizing, early initialization, etc).

No functionnal change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mvme188.h,v 1.19 2004/08/02 08:35:00 miod Exp $ */
d94 11
a375 3

#define M188_IACK		0xFFF85000
#define M188_IVEC		0x40	/* vector returned upon MVME188 int */
@


1.19
log
@More include files cleaning:
- move MAX_CPUS constant to <machine/cpu.h>
- do not include <machine/board.h> unless needed. In fact, remove this file
  entirely on mvme88k, and include <machine/mvme*.h> on a
  compiling-for-this-board basis
- keep MAX_CMMUS constant private to the m8820x code
@
text
@d1 1
a1 1
/*	$OpenBSD: mvme188.h,v 1.18 2004/07/23 22:19:09 miod Exp $ */
a364 9

#ifndef _LOCORE

extern unsigned int m188_curspl[MAX_CPUS];
extern unsigned int int_mask_val[INT_LEVEL];
extern unsigned int int_mask_shadow[MAX_CPUS];
extern unsigned int *volatile int_mask_reg[MAX_CPUS];

#endif
@


1.18
log
@Eventually get the MVME188 reset sequence to work, and allow it to return
to the BUG instead of spinning if our reset fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: mvme188.h,v 1.17 2004/04/26 12:34:05 miod Exp $ */
a352 2
#ifndef _LOCORE

d354 1
a354 1
 * Externals
d356 11
@


1.17
log
@Start factorizing luna88k and mvme88k common parts.
For now, include files only.
@
text
@d1 1
a1 1
/*	$OpenBSD: mvme188.h,v 1.16 2004/04/14 23:06:18 miod Exp $ */
a99 4
#define GLOBAL0		GCSR_BASE + 0x01
#define GLOBAL1		GCSR_BASE + 0x03
#define GLOBAL2		GCSR_BASE + 0x05
#define GLOBAL3		GCSR_BASE + 0x07
d105 1
a105 1
#define	M188_SYSCONNEG	0x00000040
a369 2


@


1.16
log
@After enough checks on real hardware, it turns out the documentation is wrong,
for once - SCON in GLOBAL1 on MVME188 is an SCON*, thus low if the board is
the system controller.
@
text
@d1 1
a1 1
/*	$OpenBSD: mvme188.h,v 1.15 2003/10/11 22:08:57 miod Exp $ */
d109 1
a109 1
#define M188_SYSCONNEG	0x00000040
@


1.15
log
@Nuke trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: mvme188.h,v 1.14 2003/09/28 16:01:12 miod Exp $ */
d108 2
a109 1
#define M188_SYSCON	0x00000040
@


1.14
log
@Remove duplicate CMMU address definitions.
@
text
@d1 1
a1 1
/*	$OpenBSD: mvme188.h,v 1.13 2003/09/16 20:52:19 miod Exp $ */
d256 4
a259 4
#define MASK_LVL_1 (LVL7 | LVL6 | LVL5 | LVL4 | LVL3 | LVL2) 
#define MASK_LVL_2 (LVL7 | LVL6 | LVL5 | LVL4 | LVL3)  
#define MASK_LVL_3 (LVL7 | LVL6 | LVL5 | LVL4)    
#define MASK_LVL_4 (LVL7 | LVL6 | LVL5)    
d367 1
a367 1
#endif 
@


1.13
log
@Remove unused material from include files, as well as the annoying U() macro
which is only used to obfuscate things.

Doing this points out that the BUG memory is not at the same address on
187 and 197 (the 197 BUG is inside obio), so provide distinct constants,
and treat 187 and 197 slightly differently in pmap_bootstrap(). However, we
now need to map the 197 flash memory as well...

While there, simplify and constify pmap_table_build() and its associated data.
@
text
@d1 1
a1 1
/*	$OpenBSD: mvme188.h,v 1.12 2002/01/14 21:34:41 miod Exp $ */
a47 9

#define VME_CMMU_I0	0xFFF7E000 	/* MVME188 code CMMU 0 */
#define VME_CMMU_I1	0xFFF7D000 	/* MVME188 code CMMU 1 */
#define VME_CMMU_I2	0xFFF7B000 	/* MVME188 code CMMU 2 */
#define VME_CMMU_I3	0xFFF77000 	/* MVME188 code CMMU 3 */
#define VME_CMMU_D0	0xFFF6F000 	/* MVME188 data CMMU 0 */
#define VME_CMMU_D1	0xFFF5F000 	/* MVME188 data CMMU 1 */
#define VME_CMMU_D2	0xFFF3F000 	/* MVME188 data CMMU 2 */
#define VME_CMMU_D3	0xFFF7F000 	/* MVME188 data CMMU 3 */
@


1.12
log
@volatile police.
@
text
@d1 1
a1 1
/*	$OpenBSD: mvme188.h,v 1.11 2001/12/22 07:35:43 smurph Exp $ */
d49 17
a65 33
/*
 * Something to put append a 'U' to a long constant if it's C so that
 * it'll be unsigned in both ANSI and traditional.
 */
#ifndef UDEFINED
#if defined(_LOCORE)
#define U(num)	num
#else
#if defined(__STDC__)
#define U(num)	num ## U
#else
#define U(num)	num/**/U
#endif
#endif
#endif

#define VME_CMMU_I0	U(0xFFF7E000) 	/* MVME188 code CMMU 0 */
#define VME_CMMU_I1	U(0xFFF7D000) 	/* MVME188 code CMMU 1 */
#define VME_CMMU_I2	U(0xFFF7B000) 	/* MVME188 code CMMU 2 */
#define VME_CMMU_I3	U(0xFFF77000) 	/* MVME188 code CMMU 3 */
#define VME_CMMU_D0	U(0xFFF6F000) 	/* MVME188 data CMMU 0 */
#define VME_CMMU_D1	U(0xFFF5F000) 	/* MVME188 data CMMU 1 */
#define VME_CMMU_D2	U(0xFFF3F000) 	/* MVME188 data CMMU 2 */
#define VME_CMMU_D3	U(0xFFF7F000) 	/* MVME188 data CMMU 3 */

#define MVME188_EPROM		U(0xFFC00000)
#define MVME188_EPROM_SIZE	U(0x00080000)
#define MVME188_SRAM		U(0xFFE00000)
#define MVME188_SRAM_SIZE	U(0x00020000)
#define MVME188_UTILITY		U(0xFF000000)
#define MVME188_UTILITY_SIZE	U(0x01000000)
#define UTIL_START		U(0xFFC00000)  /* start of MVME188 utility space */
#define UTIL_SIZE		U(0x003FFFFF)  /* size of MVME188 utility space */
d72 2
a73 2
#define INTR_CONTROL_BASE	U(0xfff84000)
#define VMEA24SPACE	U(0xEEC00000) 	/*  VMEA24 master addr space (4 Meg) */
d76 4
a79 4
#define MVME188_IEN0	U(0xFFF84004)	/* interrupt enable CPU 0 */
#define MVME188_IEN1	U(0xFFF84008)	/* interrupt enable CPU 1 */
#define MVME188_IEN2	U(0xFFF84010)	/* interrupt enable CPU 2 */
#define MVME188_IEN3	U(0xFFF84020)	/* interrupt enable CPU 3 */
d82 14
a95 14
#define IEN0_REG	U(0xfff84004)
#define IEN1_REG	U(0xfff84008)
#define IEN2_REG	U(0xfff84010)
#define IEN3_REG	U(0xfff84020)

#define IENALL_REG	U(0xfff8403c)

#define MVME188_IST	U(0xFFF84040) 	/* interrupt status register */
#define IST_REG		U(0xfff84040)	/* same as above */

#define MVME188_SETSWI	U(0xFFF84080) 	/* generate soft interrupt */
#define MVME188_CLRSWI	U(0xFFF84084) 	/* reset soft interrupt */
#define MVME188_ISTATE	U(0xFFF84088) 	/* HW interrupt status */
#define MVME188_CLRINT	U(0xFFF8408C) 	/* reset HW interrupt */
d98 9
a106 9
#define SETSWI_REG	U(0xfff84080)	/* SETSWI register addr */
#define CLRSWI_REG	U(0xfff84084)	/* CLRSWI register addr */
#define ISTATE_REG	U(0xfff84088)
#define CLRINT_REG	U(0xfff8408C)

#define MVME188_GCSR	U(0xFFF86000)	/* 188 global control and status reg */
#define MVME188_UCSR	U(0xFFF87000)	/* 188 utility control and status reg */
#define MVME188_BASAD	U(0xFFF87004)	/* 188 base address reg */
#define MVME188_GLBRES	U(0xFFF8700C)	/* 188 global reset reg */
d108 1
a108 1
#define GCSR_BASE	U(0xfff86000)
d113 18
a130 18
#define GLB0		U(0xfff86001)
#define GLB1		U(0xfff86003)
#define GLB2		U(0xfff86005)
#define GLB3		U(0xfff86007)
#define M188_SYSCON	U(0x00000040)
#define UCSR_REG	U(0xfff87000)
#define GLBRES_REG	U(0xfff8700C)

#define MVME188_CCSR	U(0xFFF88000)	/* 188 CPU board control status reg */
#define MVME188_ERROR	U(0xFFF88004)	/* 188 Mbus fault reg */
#define MVME188_PCNFA	U(0xFFF88008)	/* 188 Pbus A decoder reg */
#define MVME188_PCNFB	U(0xFFF8800C)	/* 188 Pbus B decoder reg */
#define MVME188_EXTAD	U(0xFFF88010)	/* 188 A24 master A24-A31 addr reg */
#define MVME188_WHOAMI	U(0xFFF88018)	/* 188 whoami reg */
#define MVME188_WMAD	U(0xFFF88020)	/* 188 write mbus addr decoder reg */
#define MVME188_RMAD	U(0xFFF88024)	/* 188 read mbus addr decoder reg */
#define MVME188_WVAD	U(0xFFF88028)	/* 188 write vmebus addr decoder reg */
#define MVME188_RVAD	U(0xFFF8802C)	/* 188 read vmebus adds decoder reg */
d133 11
a143 11
#define CCSR_REG	U(0xfff88000)
#define ERROR_REG	U(0xfff88004)	/* ERROR register addr */
#define PCNFA_REG	U(0xfff88008)
#define PCNFB_REG	U(0xfff8800c)
#define EXTAD_REG	U(0xfff88010)
#define EXTAM_REG	U(0xfff88014)
#define WHOAMI_REG	U(0xfff88018)	/* WHOAMI register addr */
#define WMAD_REG	U(0xfff88020)
#define RMAD_REG	U(0xfff88024)
#define WVAD_REG	U(0xfff88028)
#define RVAD_REG	U(0xfff8802c)
d179 2
a180 2
#define ISR_LOW_SOFTINT_MASK(cpu)	(1<<cpu)
#define ISR_HIGH_SOFTINT_MASK(cpu)	(1<<(cpu + 24))
d182 8
a189 7
#define ISR_HIGH_SOFTMASK		(0xf<<24)
#define ISR_SOFTINT_EXCEPT_MASK(cpu)	(ISR_LOW_SOFTINT_MASK(cpu) | ISR_HIGH_SOFTINT_MASK(cpu) | 0xf0fffff0)
#define ISR_CLOCKINT_MASK		(1<<IEN_CIOI_LOG)

#define ISR_RESET_NMI			*(int *volatile)MVME188_CLRINT = 1<<CLRINT_CLRABRTI_LOG
#define ISR_RESET_SYSFAIL		*(int *volatile)MVME188_CLRINT = 1<<CLRINT_CLRSFI_LOG
#define ISR_RESET_ACFAIL		*(int *volatile)MVME188_CLRINT = 1<<CLRINT_CLRACFI_LOG
d191 1
a191 1
#define ISR_RESET_HIGH_SOFTINT(cpu)	*(int *)MVME188_CLRSWI = (1<<(cpu + MAX_CPUS))
d195 1
a195 1
#define ISR_GENERATE_HIGH_SOFTINT(cpu)	*((unsigned int *volatile)MVME188_SETSWI) = (1<<(cpu + MAX_CPUS))
d214 25
a238 25
#define ABRT_BIT		U(0x80000000)	/* 31 */
#define ACF_BIT			U(0x40000000)	/* 30 */
#define ARBTO_BIT		U(0x20000000)	/* 29 */
#define DTI_BIT			U(0x10000000)	/* 28 */
#define SWI7_BIT		U(0x08000000)	/* 27 */
#define SWI6_BIT		U(0x04000000)	/* 26 */
#define SWI5_BIT		U(0x02000000)	/* 25 */
#define SWI4_BIT		U(0x01000000)	/* 24 */	   
#define IRQ7_BIT		U(0x00800000)	/* 23 */
#define CIOI_BIT		U(0x00200000)	/* 21 */
#define SF_BIT			U(0x00100000)	/* 20 */
#define IRQ6_BIT		U(0x00080000)	/* 19 */
#define DI_BIT			U(0x00020000)	/* 17 */
#define SIGHPI_BIT		U(0x00010000)	/* 16 */
#define IRQ5_BIT		U(0x00004000)	/* 14 */
#define IRQ4_BIT		U(0x00001000)	/* 12 */
#define IRQ3_BIT		U(0x00000400)	/* 10 */
#define LMI_BIT			U(0x00000100)	/* 08 */
#define SIGLPI_BIT		U(0x00000080)	/* 07 */
#define IRQ2_BIT		U(0x00000040)	/* 06 */
#define IRQ1_BIT		U(0x00000010)	/* 04 */
#define SWI3_BIT		U(0x00000008)	/* 03 */
#define SWI2_BIT		U(0x00000004)	/* 02 */
#define SWI1_BIT		U(0x00000002)	/* 01 */
#define SWI0_BIT		U(0x00000001)	/* 00 */
d244 4
a247 4
#define HW_FAILURE_MASK		U(0xE0100000)	/* hardware irq bits */
#define SOFT_INTERRUPT_MASK	U(0x0F00000F)	/* software irq bits */
#define VME_INTERRUPT_MASK	U(0x00885450)   /* vme irq bits */
#define OBIO_INTERRUPT_MASK	U(0x10330180)	/* on board I/O */
d271 1
a271 1
#define MASK_LVL_7 U(0x00000000) /* all ints disabled */
d274 5
a278 5
#define CIO_BASE		U(0xfff83000)
#define CIO_PORTC		U(0xfff83000)
#define CIO_PORTB		U(0xfff83004)
#define CIO_PORTA		U(0xfff83008)
#define CIO_CTRL		U(0xfff8300c)
d333 15
a347 15
#define DART_BASE		U(0xfff82000)
#define DART_MRA		U(0xfff82000)	/* mode A */
#define DART_SRA		U(0xfff82004)	/* status A */
#define DART_RBA		U(0xfff8200c)	/* receive buffer A */
#define DART_IPCR		U(0xfff82010)	/* input port change */
#define DART_ISR		U(0xfff82014)	/* interrupt status */
#define DART_CUR		U(0xfff82018)	/* count upper */
#define DART_CLR		U(0xfff8201c)	/* count lower */
#define DART_MR1B		U(0xfff82020)	/* mode B */
#define DART_SRB		U(0xfff82024)	/* status B */
#define DART_RBB		U(0xfff8202c)	/* receive buffer B */
#define DART_IVR		U(0xfff82030)	/* interrupt vector */
#define DART_INP		U(0xfff82034)	/* input port */
#define DART_STARTC		U(0xfff82038)	/* start counter cmd */
#define DART_STOPC		U(0xfff8203c)	/* stop counter cmd */
d350 14
a363 14
#define DART_CSRA		U(0xfff82004)	/* clock select A */
#define DART_CRA		U(0xfff82008)	/* command A */
#define DART_TBA		U(0xfff8200c)	/* transmit buffer A */
#define DART_ACR		U(0xfff82010)	/* auxiliary control */
#define DART_IMR		U(0xfff82014)	/* interrupt mask reg*/
#define DART_CTUR		U(0xfff82018)	/* counter/timer MSB */
#define DART_CTLR		U(0xfff8201c)	/* counter/timer LSB */
#define DART_MRB		U(0xfff82020)	/* mode B */
#define DART_CSRB		U(0xfff82024)	/* clock select B */
#define DART_CRB		U(0xfff82028)	/* command B */
#define DART_TBB		U(0xfff8202c)	/* transmit buffer B */
#define DART_OPCR		U(0xfff82034)	/* output port config*/
#define DART_OPRS		U(0xfff82038)	/* output port set */
#define DART_OPRR		U(0xfff8203c)	/* output port reset */
d378 1
a378 1
#define M188_IACK		U(0xFFF85000)
d381 1
a381 1
#endif /* __MACHINE_MVME188_H__ */
@


1.11
log
@rename m882xx.h to m8820x.h
@
text
@d1 1
a1 1
/*	$OpenBSD: mvme188.h,v 1.10 2001/12/19 05:06:26 smurph Exp $ */
d202 3
a204 3
#define ISR_RESET_NMI			*(volatile int *)MVME188_CLRINT = 1<<CLRINT_CLRABRTI_LOG
#define ISR_RESET_SYSFAIL		*(volatile int *)MVME188_CLRINT = 1<<CLRINT_CLRSFI_LOG
#define ISR_RESET_ACFAIL		*(volatile int *)MVME188_CLRINT = 1<<CLRINT_CLRACFI_LOG
d207 6
a212 6
#define ISR_DETERMINE_LOW_SOFTINT(cpu)	*(volatile unsigned int *)MVME188_IST & ISR_LOW_SOFTINT_MASK(cpu)
#define ISR_DETERMINE_HIGH_SOFTINT(cpu)	*(volatile unsigned int *)MVME188_IST & ISR_HIGH_SOFTINT_MASK(cpu)
#define ISR_GENERATE_LOW_SOFTINT(cpu)	*((volatile unsigned int *)MVME188_SETSWI) = ISR_LOW_SOFTINT_MASK(cpu)
#define ISR_GENERATE_HIGH_SOFTINT(cpu)	*((volatile unsigned int *)MVME188_SETSWI) = (1<<(cpu + MAX_CPUS))
#define ISR_RESET_MACHINE		*((volatile unsigned *) MVME188_GLBRES) = 1
#define ISR_GET_CURRENT_MASK(cpu)	*int_mask_reg[cpu] & *(volatile int *)MVME188_IST
d389 1
a389 1
extern volatile unsigned int *int_mask_reg[MAX_CPUS];
@


1.10
log
@board.h overhaul.  split definitions by arch.
@
text
@d1 1
a1 1
/*	$OpenBSD: mvme188.h,v 1.9 2001/12/16 23:49:46 miod Exp $ */
d16 1
a16 1
 *      This product includes software developed by Nivas Madhur.
@


1.10.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: mvme188.h,v 1.12 2002/01/14 21:34:41 miod Exp $ */
d16 1
a16 1
 *      This product includes software developed by Steve Murphree, Jr.
d202 3
a204 3
#define ISR_RESET_NMI			*(int *volatile)MVME188_CLRINT = 1<<CLRINT_CLRABRTI_LOG
#define ISR_RESET_SYSFAIL		*(int *volatile)MVME188_CLRINT = 1<<CLRINT_CLRSFI_LOG
#define ISR_RESET_ACFAIL		*(int *volatile)MVME188_CLRINT = 1<<CLRINT_CLRACFI_LOG
d207 6
a212 6
#define ISR_DETERMINE_LOW_SOFTINT(cpu)	*(unsigned int *volatile)MVME188_IST & ISR_LOW_SOFTINT_MASK(cpu)
#define ISR_DETERMINE_HIGH_SOFTINT(cpu)	*(unsigned int *volatile)MVME188_IST & ISR_HIGH_SOFTINT_MASK(cpu)
#define ISR_GENERATE_LOW_SOFTINT(cpu)	*((unsigned int *volatile)MVME188_SETSWI) = ISR_LOW_SOFTINT_MASK(cpu)
#define ISR_GENERATE_HIGH_SOFTINT(cpu)	*((unsigned int *volatile)MVME188_SETSWI) = (1<<(cpu + MAX_CPUS))
#define ISR_RESET_MACHINE		*((unsigned *volatile) MVME188_GLBRES) = 1
#define ISR_GET_CURRENT_MASK(cpu)	*int_mask_reg[cpu] & *(int *volatile)MVME188_IST
d389 1
a389 1
extern unsigned int *volatile int_mask_reg[MAX_CPUS];
@


1.9
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: mvme188.h,v 1.7 2001/08/26 14:31:07 miod Exp $ */
d65 8
@


1.8
log
@Repair MVME187 after MVME197 merge.
@
text
@a64 8
#define VME_CMMU_I0	U(0xFFF7E000) 	/* MVME188 code CMMU 0 */
#define VME_CMMU_I1	U(0xFFF7D000) 	/* MVME188 code CMMU 1 */
#define VME_CMMU_I2	U(0xFFF7B000) 	/* MVME188 code CMMU 2 */
#define VME_CMMU_I3	U(0xFFF77000) 	/* MVME188 code CMMU 3 */
#define VME_CMMU_D0	U(0xFFF6F000) 	/* MVME188 data CMMU 0 */
#define VME_CMMU_D1	U(0xFFF5F000) 	/* MVME188 data CMMU 1 */
#define VME_CMMU_D2	U(0xFFF3F000) 	/* MVME188 data CMMU 2 */
#define VME_CMMU_D3	U(0xFFF7F000) 	/* MVME188 data CMMU 3 */
@


1.7
log
@Add prototypes, fix compilation warnings, random style fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: mvme188.h,v 1.6 2001/08/12 12:03:02 heko Exp $ */
d65 8
@


1.6
log
@#(endif|else) foo is incorrect, make it #endif /* foo */
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mvme188.h,v 1.5 2001/03/16 00:05:25 miod Exp $ */
d55 1
a55 1
#	define U(num)	num
d57 5
a61 5
#  if defined(__STDC__)
#	define U(num)	num ## U
#  else
#	define U(num)	num/**/U
#  endif
@


1.5
log
@More function prototypes.
Move badwordaddr() to a macro.
@
text
@d1 1
a1 1
/*	$OpenBSD: mvme188.h,v 1.4 2001/03/07 23:37:16 miod Exp $ */
d388 1
a388 1
#endif	__MACHINE_MVME188_H__
@


1.4
log
@Inclusion from assembly code is detected with _LOCORE, no more fancy symbols.
@
text
@d1 1
a1 1
/*	$OpenBSD: mvme188.h,v 1.3 2001/02/01 03:38:18 smurph Exp $ */
d382 1
a382 5
/*
 * Prototypes
 */
void block_obio_interrupt(unsigned mask);
void unblock_obio_interrupt(unsigned mask);
@


1.3
log
@Major changes to get MVME188 working.  More header and code cleanups.  The
kernel is tested on MVME188A/2P256 and MVME188A/1P64.
@
text
@d1 1
a1 1
/*	$OpenBSD: mvme188.h,v 1.2 2001/01/14 20:25:24 smurph Exp $ */
d54 1
a54 1
#if defined(ASSEMBLER)
d372 1
a372 1
#ifndef ASSEMBLER
@


1.2
log
@Complete move to UVM virtual memory system.  More header fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: mvme188.h,v 1.1 1999/09/27 20:46:18 smurph Exp $ */
d66 5
a70 5
#define MVME188_EPROM		   U(0xFFC00000)
#define MVME188_EPROM_SIZE	   U(0x00080000)
#define MVME188_SRAM		      U(0xFFE00000)
#define MVME188_SRAM_SIZE	   U(0x00020000)
#define MVME188_UTILITY		   U(0xFF000000)
d72 2
a73 2
#define UTIL_START            U(0xFFC00000)  /* start of MVME188 utility space */
#define UTIL_SIZE             U(0x003FFFFF)  /* size of MVME188 utility space */
d81 1
a81 1
#define VMEA24SPACE 	   U(0xEEC00000) 	/*  VMEA24 master addr space (4 Meg) */
d84 4
a87 4
#define MVME188_IEN0	   U(0xFFF84004)	/* interrupt enable CPU 0 */
#define MVME188_IEN1	   U(0xFFF84008)	/* interrupt enable CPU 1 */
#define MVME188_IEN2	   U(0xFFF84010)	/* interrupt enable CPU 2 */
#define MVME188_IEN3	   U(0xFFF84020)	/* interrupt enable CPU 3 */
d90 4
a93 4
#define IEN0_REG        U(0xfff84004)
#define IEN1_REG        U(0xfff84008)
#define IEN2_REG        U(0xfff84010)
#define IEN3_REG        U(0xfff84020)
d95 1
a95 1
#define IENALL_REG      U(0xfff8403c)
d97 2
a98 2
#define MVME188_IST	   U(0xFFF84040) 	/* interrupt status register */
#define IST_REG         U(0xfff84040)	/* same as above */
d106 33
a138 33
#define SETSWI_REG   U(0xfff84080)	/* SETSWI register addr */
#define CLRSWI_REG   U(0xfff84084)	/* CLRSWI register addr */
#define ISTATE_REG   U(0xfff84088)
#define CLRINT_REG   U(0xfff8408C)

#define MVME188_GCSR 	U(0xFFF86000)	/* 188 global control and status reg */
#define MVME188_UCSR 	U(0xFFF87000)	/* 188 utility control and status reg */
#define MVME188_BASAD 	U(0xFFF87004)	/* 188 base address reg */
#define MVME188_GLBRES 	U(0xFFF8700C)	/* 188 global reset reg */

#define GCSR_BASE    U(0xfff86000)
#define GLOBAL0      GCSR_BASE + 0x01
#define GLOBAL1      GCSR_BASE + 0x03
#define GLOBAL2      GCSR_BASE + 0x05
#define GLOBAL3      GCSR_BASE + 0x07
#define GLB0         U(0xfff86001)
#define GLB1         U(0xfff86003)
#define GLB2         U(0xfff86005)
#define GLB3         U(0xfff86007)
#define M188_SYSCON  U(0x00000040)
#define UCSR_REG     U(0xfff87000)
#define GLBRES_REG   U(0xfff8700C)

#define MVME188_CCSR 	U(0xFFF88000)	/* 188 CPU board control status reg */
#define MVME188_ERROR 	U(0xFFF88004)	/* 188 Mbus fault reg */
#define MVME188_PCNFA 	U(0xFFF88008)	/* 188 Pbus A decoder reg */
#define MVME188_PCNFB 	U(0xFFF8800C)	/* 188 Pbus B decoder reg */
#define MVME188_EXTAD 	U(0xFFF88010)	/* 188 A24 master A24-A31 addr reg */
#define MVME188_WHOAMI 	U(0xFFF88018)	/* 188 whoami reg */
#define MVME188_WMAD 	U(0xFFF88020)	/* 188 write mbus addr decoder reg */
#define MVME188_RMAD 	U(0xFFF88024)	/* 188 read mbus addr decoder reg */
#define MVME188_WVAD 	U(0xFFF88028)	/* 188 write vmebus addr decoder reg */
#define MVME188_RVAD 	U(0xFFF8802C)	/* 188 read vmebus adds decoder reg */
d141 24
a164 24
#define CCSR_REG     U(0xfff88000)
#define ERROR_REG    U(0xfff88004)	/* ERROR register addr */
#define PCNFA_REG    U(0xfff88008)
#define PCNFB_REG    U(0xfff8800c)
#define EXTAD_REG    U(0xfff88010)
#define EXTAM_REG    U(0xfff88014)
#define WHOAMI_REG   U(0xfff88018)	/* WHOAMI register addr */
#define WMAD_REG     U(0xfff88020)
#define RMAD_REG     U(0xfff88024)
#define WVAD_REG     U(0xfff88028)
#define RVAD_REG     U(0xfff8802c)

#define MAD_MDS		   0x07	/* 188 MAD Device Select bits */

#define VMEA24 		   0x5	/* Mbus addess decode select for VMEA24 */
#define VADV		      0x1	/* vmeaddres decode enable */
#define VBDSELBIT 	   0 	   /* bit to enable vme slave response low true */
#define VBDISABLE	      0x1	/* VME BUS Disable */
#define VSDBIT    	   1 	   /* bit number to enable snooping low true */
#define VSDISABLE	      0x2	/* VME Snoop Disable */
#define VASPBIT	 	   21 	/* addr space 0 = A32, 1 = A24 bit */
#define VASP		      0x00200000 /* A24 VME address space */
#define VPN		         0x00400000 /* Page Number LSB */
#define PAGECNT		   0x400	/* number of (4 meg) pages to map */
d169 6
a174 6
#define UCSR_ROBINBIT 	0x800	   /* 188 UCSR sel round robin VME arbiter mode */
#define UCSR_BRLVBITS 	0x600	   /* 188 UCSR VME bus request level 0-3 */
#define UCSR_RNEVERBIT  0x100	   /* 188 UCSR VME bus never release once req'd */
#define UCSR_RONRBIT	   0x80	   /* 188 UCSR VME bus req release on no request */
#define UCSR_RWDBIT		0x40	   /* 188 UCSR VME bus request release when done */
#define UCSR_EARBTOBIT  0x20	   /* 188 UCSR enable VME arbiter bus timeout */
d177 5
a181 5
#define VTOSELBITS 	0x18	/* 188 UCSR VMEbus timeout select bits */
#define VTO32US 	   0x00	/* VMEbus timeout length - 32 MicroSec */
#define VTO64US 	   0x01	/* VMEbus timeout length - 64 MicroSec */
#define VTO128US 	   0x10	/* VMEbus timeout length - 128 MicroSec */
#define VTODISABLE 	0x18	/* VMEbus timeout length - disabled */
a209 12
/*
 * masks and offsets for IST
 */
#define HW_FAILURE_MASK		   U(0x60100000)	/* HW failure bits */
#define HW_FAILURE_ACF		   U(0x40000000)  /* AC failure */
#define HW_FAILURE_ABRTO	   U(0x20000000)  /* Arbiter timeout */
#define HW_FAILURE_SYSFAIL	   U(0x00100000) 	/* SYSFAIL asserted */

#define SOFT_INTERRUPT_MASK	U(0x0F00000F)	/* software irq bits */
#define VME_INTERRUPT_MASK	   U(0x00885450)	/* vme irq bits */
#define OBIO_INTERRUPT_MASK	U(0xF0320100)  /* on board I/O */

d221 39
a259 34
#define ABRT_BIT     U(0x80000000)
#define ACF_BIT      U(0x40000000)
#define ARBTO_BIT    U(0x20000000)
#define DTI_BIT      U(0x10000000)
#define SWI7_BIT     U(0x08000000)
#define SWI6_BIT     U(0x04000000)
#define SWI5_BIT     U(0x02000000)
#define SWI4_BIT     U(0x01000000)
#define IRQ7_BIT     U(0x00800000)
#define CIOI_BIT     U(0x00200000)
#define SF_BIT       U(0x00100000)
#define IRQ6_BIT     U(0x00080000)
#define DI_BIT       U(0x00020000)
#define SIGHPI_BIT   U(0x00010000)
#define IRQ5_BIT     U(0x00004000)
#define IRQ4_BIT     U(0x00001000)
#define IRQ3_BIT     U(0x00000400)
#define LMI_BIT      U(0x00000100)
#define SIGLPI_BIT   U(0x00000080)
#define IRQ2_BIT     U(0x00000040)
#define IRQ1_BIT     U(0x00000010)
#define SWI3_BIT     U(0x00000008)
#define SWI2_BIT     U(0x00000004)
#define SWI1_BIT     U(0x00000002)
#define SWI0_BIT     U(0x00000001)

#define ABRT_BIT     U(0x80000000)
#define ACF_BIT      U(0x40000000)
#define ARBTO_BIT    U(0x20000000)
#define DTI_BIT      U(0x10000000)
#define CIOI_BIT     U(0x00200000)
#define SF_BIT       U(0x00100000)
#define DI_BIT       U(0x00020000)
#define LMI_BIT      U(0x00000100)
d281 57
a337 57
#define CIO_BASE     U(0xfff83000)
#define CIO_PORTC    U(0xfff83000)
#define CIO_PORTB    U(0xfff83004)
#define CIO_PORTA    U(0xfff83008)
#define CIO_CTRL     U(0xfff8300c)

#define CIO_MICR        0x00	/* Master interrupt control register */
#define CIO_MICR_MIE    0x80
#define CIO_MICR_DLC    0x40
#define CIO_MICR_NV     0x20
#define CIO_MICR_PAVIS  0x10
#define CIO_MICR_PBVIS  0x08
#define CIO_MICR_CTVIS  0x04
#define CIO_MICR_RJA    0x02
#define CIO_MICR_RESET  0x01

#define CIO_MCCR        0x01	/* Master configuration control register */
#define CIO_MCCR_PBE    0x80
#define CIO_MCCR_CT1E   0x40
#define CIO_MCCR_CT2E   0x20
#define CIO_MCCR_CT3E   0x10
#define CIO_MCCR_PLC    0x08
#define CIO_MCCR_PAE    0x04

#define CIO_CTMS1       0x1c	/* Counter/timer mode specification #1 */
#define CIO_CTMS2       0x1d	/* Counter/timer mode specification #2 */
#define CIO_CTMS3       0x1e	/* Counter/timer mode specification #3 */
#define CIO_CTMS_CSC    0x80  /* Continuous Single Cycle */
#define CIO_CTMS_EOE    0x40  /* External Output Enable  */
#define CIO_CTMS_ECE    0x20  /* External Count Enable   */
#define CIO_CTMS_ETE    0x10  /* External Trigger Enable */
#define CIO_CTMS_EGE    0x08  /* External Gate Enable    */
#define CIO_CTMS_REB    0x04  /* Retrigger Enable Bit    */
#define CIO_CTMS_PO     0x00  /* Pulse Output            */
#define CIO_CTMS_OSO    0x01  /* One Shot Output         */
#define CIO_CTMS_SWO    0x02  /* Square Wave Output      */

#define CIO_IVR         0x04	/* Interrupt vector register */

#define CIO_CSR1        0x0a	/* Command and status register CTC #1 */
#define CIO_CSR2        0x0b	/* Command and status register CTC #2 */
#define CIO_CSR3        0x0c	/* Command and status register CTC #3 */

#define CIO_CT1MSB      0x16	/* CTC #1 Timer constant - MSB */
#define CIO_CT1LSB      0x17	/* CTC #1 Timer constant - LSB */
#define CIO_CT2MSB      0x18	/* CTC #2 Timer constant - MSB */
#define CIO_CT2LSB      0x19	/* CTC #2 Timer constant - LSB */
#define CIO_CT3MSB      0x1a	/* CTC #3 Timer constant - MSB */
#define CIO_CT3LSB      0x1b	/* CTC #3 Timer constant - LSB */
#define CIO_PDCA        0x23	/* Port A data direction control */
#define CIO_PDCB        0x2b	/* Port B data direction control */

#define CIO_GCB         0x04	/* CTC Gate command bit */
#define CIO_TCB         0x02	/* CTC Trigger command bit */
#define CIO_IE          0xc0	/* CTC Interrupt enable (set) */
#define CIO_CIP         0x20	/* CTC Clear interrupt pending */
#define CIO_IP          0x20	/* CTC Interrupt pending */
d340 15
a354 15
#define DART_BASE    U(0xfff82000)
#define DART_MRA     U(0xfff82000)	/* mode A */
#define DART_SRA     U(0xfff82004)	/* status A */
#define DART_RBA     U(0xfff8200c)	/* receive buffer A */
#define DART_IPCR    U(0xfff82010)	/* input port change */
#define DART_ISR     U(0xfff82014)	/* interrupt status */
#define DART_CUR     U(0xfff82018)	/* count upper */
#define DART_CLR     U(0xfff8201c)	/* count lower */
#define DART_MR1B    U(0xfff82020)	/* mode B */
#define DART_SRB     U(0xfff82024)	/* status B */
#define DART_RBB     U(0xfff8202c)	/* receive buffer B */
#define DART_IVR     U(0xfff82030)	/* interrupt vector */
#define DART_INP     U(0xfff82034)	/* input port */
#define DART_STARTC  U(0xfff82038)	/* start counter cmd */
#define DART_STOPC   U(0xfff8203c)	/* stop counter cmd */
d357 14
a370 14
#define DART_CSRA    U(0xfff82004)	/* clock select A */
#define DART_CRA     U(0xfff82008)	/* command A */
#define DART_TBA     U(0xfff8200c)	/* transmit buffer A */
#define DART_ACR     U(0xfff82010)	/* auxiliary control */
#define DART_IMR     U(0xfff82014)	/* interrupt mask reg*/
#define DART_CTUR    U(0xfff82018)	/* counter/timer MSB */
#define DART_CTLR    U(0xfff8201c)	/* counter/timer LSB */
#define DART_MRB     U(0xfff82020)	/* mode B */
#define DART_CSRB    U(0xfff82024)	/* clock select B */
#define DART_CRB     U(0xfff82028)	/* command B */
#define DART_TBB     U(0xfff8202c)	/* transmit buffer B */
#define DART_OPCR    U(0xfff82034)	/* output port config*/
#define DART_OPRS    U(0xfff82038)	/* output port set */
#define DART_OPRR    U(0xfff8203c)	/* output port reset */
d388 3
a390 1
#define M188_IACK        U(0xFFF85000)
@


1.1
log
@Adding support for MVME188 and MVME197
@
text
@d1 1
a1 1
/*	$OpenBSD: mvme188.h,v 1.0 1999/05/29 04:41:45 smurph Exp $ */
d46 2
a47 2
#ifndef	_MACHINE_MVME188_H
#define	_MACHINE_MVME188_H
d397 1
a397 1
#endif	/* _MACHINE_MVME188_H */
@


1.1.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: mvme188.h,v 1.5 2001/03/16 00:05:25 miod Exp $ */
d46 2
a47 2
#ifndef	__MACHINE_MVME188_H__
#define	__MACHINE_MVME188_H__
d54 1
a54 1
#if defined(_LOCORE)
d66 5
a70 5
#define MVME188_EPROM		U(0xFFC00000)
#define MVME188_EPROM_SIZE	U(0x00080000)
#define MVME188_SRAM		U(0xFFE00000)
#define MVME188_SRAM_SIZE	U(0x00020000)
#define MVME188_UTILITY		U(0xFF000000)
d72 2
a73 2
#define UTIL_START		U(0xFFC00000)  /* start of MVME188 utility space */
#define UTIL_SIZE		U(0x003FFFFF)  /* size of MVME188 utility space */
d81 1
a81 1
#define VMEA24SPACE	U(0xEEC00000) 	/*  VMEA24 master addr space (4 Meg) */
d84 4
a87 4
#define MVME188_IEN0	U(0xFFF84004)	/* interrupt enable CPU 0 */
#define MVME188_IEN1	U(0xFFF84008)	/* interrupt enable CPU 1 */
#define MVME188_IEN2	U(0xFFF84010)	/* interrupt enable CPU 2 */
#define MVME188_IEN3	U(0xFFF84020)	/* interrupt enable CPU 3 */
d90 4
a93 4
#define IEN0_REG	U(0xfff84004)
#define IEN1_REG	U(0xfff84008)
#define IEN2_REG	U(0xfff84010)
#define IEN3_REG	U(0xfff84020)
d95 1
a95 1
#define IENALL_REG	U(0xfff8403c)
d97 2
a98 2
#define MVME188_IST	U(0xFFF84040) 	/* interrupt status register */
#define IST_REG		U(0xfff84040)	/* same as above */
d106 33
a138 33
#define SETSWI_REG	U(0xfff84080)	/* SETSWI register addr */
#define CLRSWI_REG	U(0xfff84084)	/* CLRSWI register addr */
#define ISTATE_REG	U(0xfff84088)
#define CLRINT_REG	U(0xfff8408C)

#define MVME188_GCSR	U(0xFFF86000)	/* 188 global control and status reg */
#define MVME188_UCSR	U(0xFFF87000)	/* 188 utility control and status reg */
#define MVME188_BASAD	U(0xFFF87004)	/* 188 base address reg */
#define MVME188_GLBRES	U(0xFFF8700C)	/* 188 global reset reg */

#define GCSR_BASE	U(0xfff86000)
#define GLOBAL0		GCSR_BASE + 0x01
#define GLOBAL1		GCSR_BASE + 0x03
#define GLOBAL2		GCSR_BASE + 0x05
#define GLOBAL3		GCSR_BASE + 0x07
#define GLB0		U(0xfff86001)
#define GLB1		U(0xfff86003)
#define GLB2		U(0xfff86005)
#define GLB3		U(0xfff86007)
#define M188_SYSCON	U(0x00000040)
#define UCSR_REG	U(0xfff87000)
#define GLBRES_REG	U(0xfff8700C)

#define MVME188_CCSR	U(0xFFF88000)	/* 188 CPU board control status reg */
#define MVME188_ERROR	U(0xFFF88004)	/* 188 Mbus fault reg */
#define MVME188_PCNFA	U(0xFFF88008)	/* 188 Pbus A decoder reg */
#define MVME188_PCNFB	U(0xFFF8800C)	/* 188 Pbus B decoder reg */
#define MVME188_EXTAD	U(0xFFF88010)	/* 188 A24 master A24-A31 addr reg */
#define MVME188_WHOAMI	U(0xFFF88018)	/* 188 whoami reg */
#define MVME188_WMAD	U(0xFFF88020)	/* 188 write mbus addr decoder reg */
#define MVME188_RMAD	U(0xFFF88024)	/* 188 read mbus addr decoder reg */
#define MVME188_WVAD	U(0xFFF88028)	/* 188 write vmebus addr decoder reg */
#define MVME188_RVAD	U(0xFFF8802C)	/* 188 read vmebus adds decoder reg */
d141 24
a164 24
#define CCSR_REG	U(0xfff88000)
#define ERROR_REG	U(0xfff88004)	/* ERROR register addr */
#define PCNFA_REG	U(0xfff88008)
#define PCNFB_REG	U(0xfff8800c)
#define EXTAD_REG	U(0xfff88010)
#define EXTAM_REG	U(0xfff88014)
#define WHOAMI_REG	U(0xfff88018)	/* WHOAMI register addr */
#define WMAD_REG	U(0xfff88020)
#define RMAD_REG	U(0xfff88024)
#define WVAD_REG	U(0xfff88028)
#define RVAD_REG	U(0xfff8802c)

#define MAD_MDS		0x07	/* 188 MAD Device Select bits */

#define VMEA24		0x5	/* Mbus addess decode select for VMEA24 */
#define VADV		0x1	/* vmeaddres decode enable */
#define VBDSELBIT	0	/* bit to enable vme slave response low true */
#define VBDISABLE	0x1	/* VME BUS Disable */
#define VSDBIT		1	/* bit number to enable snooping low true */
#define VSDISABLE	0x2	/* VME Snoop Disable */
#define VASPBIT		21	/* addr space 0 = A32, 1 = A24 bit */
#define VASP		0x00200000	/* A24 VME address space */
#define VPN		0x00400000	/* Page Number LSB */
#define PAGECNT		0x400	/* number of (4 meg) pages to map */
d169 6
a174 6
#define UCSR_ROBINBIT 	0x800	/* 188 UCSR sel round robin VME arbiter mode */
#define UCSR_BRLVBITS 	0x600	/* 188 UCSR VME bus request level 0-3 */
#define UCSR_RNEVERBIT  0x100	/* 188 UCSR VME bus never release once req'd */
#define UCSR_RONRBIT	0x80	/* 188 UCSR VME bus req release on no request */
#define UCSR_RWDBIT	0x40	/* 188 UCSR VME bus request release when done */
#define UCSR_EARBTOBIT  0x20	/* 188 UCSR enable VME arbiter bus timeout */
d177 5
a181 5
#define VTOSELBITS	0x18	/* 188 UCSR VMEbus timeout select bits */
#define VTO32US		0x00	/* VMEbus timeout length - 32 MicroSec */
#define VTO64US		0x01	/* VMEbus timeout length - 64 MicroSec */
#define VTO128US	0x10	/* VMEbus timeout length - 128 MicroSec */
#define VTODISABLE	0x18	/* VMEbus timeout length - disabled */
d210 12
d233 34
a266 39
#define ABRT_BIT		U(0x80000000)	/* 31 */
#define ACF_BIT			U(0x40000000)	/* 30 */
#define ARBTO_BIT		U(0x20000000)	/* 29 */
#define DTI_BIT			U(0x10000000)	/* 28 */
#define SWI7_BIT		U(0x08000000)	/* 27 */
#define SWI6_BIT		U(0x04000000)	/* 26 */
#define SWI5_BIT		U(0x02000000)	/* 25 */
#define SWI4_BIT		U(0x01000000)	/* 24 */	   
#define IRQ7_BIT		U(0x00800000)	/* 23 */
#define CIOI_BIT		U(0x00200000)	/* 21 */
#define SF_BIT			U(0x00100000)	/* 20 */
#define IRQ6_BIT		U(0x00080000)	/* 19 */
#define DI_BIT			U(0x00020000)	/* 17 */
#define SIGHPI_BIT		U(0x00010000)	/* 16 */
#define IRQ5_BIT		U(0x00004000)	/* 14 */
#define IRQ4_BIT		U(0x00001000)	/* 12 */
#define IRQ3_BIT		U(0x00000400)	/* 10 */
#define LMI_BIT			U(0x00000100)	/* 08 */
#define SIGLPI_BIT		U(0x00000080)	/* 07 */
#define IRQ2_BIT		U(0x00000040)	/* 06 */
#define IRQ1_BIT		U(0x00000010)	/* 04 */
#define SWI3_BIT		U(0x00000008)	/* 03 */
#define SWI2_BIT		U(0x00000004)	/* 02 */
#define SWI1_BIT		U(0x00000002)	/* 01 */
#define SWI0_BIT		U(0x00000001)	/* 00 */

/*
 * masks and offsets for IST
 * These are a combination of the above
 */
#define HW_FAILURE_MASK		U(0xE0100000)	/* hardware irq bits */
#define SOFT_INTERRUPT_MASK	U(0x0F00000F)	/* software irq bits */
#define VME_INTERRUPT_MASK	U(0x00885450)   /* vme irq bits */
#define OBIO_INTERRUPT_MASK	U(0x10330180)	/* on board I/O */

#define HW_FAILURE_ACF		ACF_BIT		/* AC failure */
#define HW_FAILURE_ABRTO	ARBTO_BIT	/* Arbiter timeout */
#define HW_FAILURE_SYSFAIL	SF_BIT		/* SYSFAIL asserted */
#define HW_FAILURE_ABORT	ABRT_BIT	/* Abort pressed */
d288 57
a344 57
#define CIO_BASE		U(0xfff83000)
#define CIO_PORTC		U(0xfff83000)
#define CIO_PORTB		U(0xfff83004)
#define CIO_PORTA		U(0xfff83008)
#define CIO_CTRL		U(0xfff8300c)

#define CIO_MICR		0x00	/* Master interrupt control register */
#define CIO_MICR_MIE		0x80
#define CIO_MICR_DLC		0x40
#define CIO_MICR_NV		0x20
#define CIO_MICR_PAVIS		0x10
#define CIO_MICR_PBVIS		0x08
#define CIO_MICR_CTVIS		0x04
#define CIO_MICR_RJA		0x02
#define CIO_MICR_RESET		0x01

#define CIO_MCCR		0x01	/* Master config control register */
#define CIO_MCCR_PBE		0x80
#define CIO_MCCR_CT1E		0x40
#define CIO_MCCR_CT2E		0x20
#define CIO_MCCR_CT3E		0x10
#define CIO_MCCR_PLC		0x08
#define CIO_MCCR_PAE		0x04

#define CIO_CTMS1		0x1c	/* Counter/timer mode specification #1 */
#define CIO_CTMS2		0x1d	/* Counter/timer mode specification #2 */
#define CIO_CTMS3		0x1e	/* Counter/timer mode specification #3 */
#define CIO_CTMS_CSC		0x80	/* Continuous Single Cycle */
#define CIO_CTMS_EOE		0x40	/* External Output Enable  */
#define CIO_CTMS_ECE		0x20	/* External Count Enable   */
#define CIO_CTMS_ETE		0x10	/* External Trigger Enable */
#define CIO_CTMS_EGE		0x08	/* External Gate Enable    */
#define CIO_CTMS_REB		0x04	/* Retrigger Enable Bit    */
#define CIO_CTMS_PO		0x00	/* Pulse Output            */
#define CIO_CTMS_OSO		0x01	/* One Shot Output         */
#define CIO_CTMS_SWO		0x02	/* Square Wave Output      */

#define CIO_IVR			0x04	/* Interrupt vector register */

#define CIO_CSR1		0x0a	/* Command and status register CTC #1 */
#define CIO_CSR2		0x0b	/* Command and status register CTC #2 */
#define CIO_CSR3		0x0c	/* Command and status register CTC #3 */

#define CIO_CT1MSB		0x16	/* CTC #1 Timer constant - MSB */
#define CIO_CT1LSB		0x17	/* CTC #1 Timer constant - LSB */
#define CIO_CT2MSB		0x18	/* CTC #2 Timer constant - MSB */
#define CIO_CT2LSB		0x19	/* CTC #2 Timer constant - LSB */
#define CIO_CT3MSB		0x1a	/* CTC #3 Timer constant - MSB */
#define CIO_CT3LSB		0x1b	/* CTC #3 Timer constant - LSB */
#define CIO_PDCA		0x23	/* Port A data direction control */
#define CIO_PDCB		0x2b	/* Port B data direction control */

#define CIO_GCB			0x04	/* CTC Gate command bit */
#define CIO_TCB			0x02	/* CTC Trigger command bit */
#define CIO_IE			0xc0	/* CTC Interrupt enable (set) */
#define CIO_CIP			0x20	/* CTC Clear interrupt pending */
#define CIO_IP			0x20	/* CTC Interrupt pending */
d347 15
a361 15
#define DART_BASE		U(0xfff82000)
#define DART_MRA		U(0xfff82000)	/* mode A */
#define DART_SRA		U(0xfff82004)	/* status A */
#define DART_RBA		U(0xfff8200c)	/* receive buffer A */
#define DART_IPCR		U(0xfff82010)	/* input port change */
#define DART_ISR		U(0xfff82014)	/* interrupt status */
#define DART_CUR		U(0xfff82018)	/* count upper */
#define DART_CLR		U(0xfff8201c)	/* count lower */
#define DART_MR1B		U(0xfff82020)	/* mode B */
#define DART_SRB		U(0xfff82024)	/* status B */
#define DART_RBB		U(0xfff8202c)	/* receive buffer B */
#define DART_IVR		U(0xfff82030)	/* interrupt vector */
#define DART_INP		U(0xfff82034)	/* input port */
#define DART_STARTC		U(0xfff82038)	/* start counter cmd */
#define DART_STOPC		U(0xfff8203c)	/* stop counter cmd */
d364 14
a377 14
#define DART_CSRA		U(0xfff82004)	/* clock select A */
#define DART_CRA		U(0xfff82008)	/* command A */
#define DART_TBA		U(0xfff8200c)	/* transmit buffer A */
#define DART_ACR		U(0xfff82010)	/* auxiliary control */
#define DART_IMR		U(0xfff82014)	/* interrupt mask reg*/
#define DART_CTUR		U(0xfff82018)	/* counter/timer MSB */
#define DART_CTLR		U(0xfff8201c)	/* counter/timer LSB */
#define DART_MRB		U(0xfff82020)	/* mode B */
#define DART_CSRB		U(0xfff82024)	/* clock select B */
#define DART_CRB		U(0xfff82028)	/* command B */
#define DART_TBB		U(0xfff8202c)	/* transmit buffer B */
#define DART_OPCR		U(0xfff82034)	/* output port config*/
#define DART_OPRS		U(0xfff82038)	/* output port set */
#define DART_OPRR		U(0xfff8203c)	/* output port reset */
d379 1
a379 1
#ifndef _LOCORE
d389 5
a393 1

d395 1
d397 1
a397 4
#define M188_IACK		U(0xFFF85000)
#define M188_IVEC		0x40	/* vector returned upon MVME188 int */

#endif	__MACHINE_MVME188_H__
@


1.1.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: mvme188.h,v 1.1.4.1 2001/04/18 16:11:23 niklas Exp $ */
d55 1
a55 1
#define U(num)	num
d57 5
a61 5
#if defined(__STDC__)
#define U(num)	num ## U
#else
#define U(num)	num/**/U
#endif
d388 1
a388 1
#endif /* __MACHINE_MVME188_H__ */
@


1.1.4.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d16 1
a16 1
 *      This product includes software developed by Steve Murphree, Jr.
a64 8
#define VME_CMMU_I0	U(0xFFF7E000) 	/* MVME188 code CMMU 0 */
#define VME_CMMU_I1	U(0xFFF7D000) 	/* MVME188 code CMMU 1 */
#define VME_CMMU_I2	U(0xFFF7B000) 	/* MVME188 code CMMU 2 */
#define VME_CMMU_I3	U(0xFFF77000) 	/* MVME188 code CMMU 3 */
#define VME_CMMU_D0	U(0xFFF6F000) 	/* MVME188 data CMMU 0 */
#define VME_CMMU_D1	U(0xFFF5F000) 	/* MVME188 data CMMU 1 */
#define VME_CMMU_D2	U(0xFFF3F000) 	/* MVME188 data CMMU 2 */
#define VME_CMMU_D3	U(0xFFF7F000) 	/* MVME188 data CMMU 3 */
d194 3
a196 3
#define ISR_RESET_NMI			*(int *volatile)MVME188_CLRINT = 1<<CLRINT_CLRABRTI_LOG
#define ISR_RESET_SYSFAIL		*(int *volatile)MVME188_CLRINT = 1<<CLRINT_CLRSFI_LOG
#define ISR_RESET_ACFAIL		*(int *volatile)MVME188_CLRINT = 1<<CLRINT_CLRACFI_LOG
d199 6
a204 6
#define ISR_DETERMINE_LOW_SOFTINT(cpu)	*(unsigned int *volatile)MVME188_IST & ISR_LOW_SOFTINT_MASK(cpu)
#define ISR_DETERMINE_HIGH_SOFTINT(cpu)	*(unsigned int *volatile)MVME188_IST & ISR_HIGH_SOFTINT_MASK(cpu)
#define ISR_GENERATE_LOW_SOFTINT(cpu)	*((unsigned int *volatile)MVME188_SETSWI) = ISR_LOW_SOFTINT_MASK(cpu)
#define ISR_GENERATE_HIGH_SOFTINT(cpu)	*((unsigned int *volatile)MVME188_SETSWI) = (1<<(cpu + MAX_CPUS))
#define ISR_RESET_MACHINE		*((unsigned *volatile) MVME188_GLBRES) = 1
#define ISR_GET_CURRENT_MASK(cpu)	*int_mask_reg[cpu] & *(int *volatile)MVME188_IST
d381 1
a381 1
extern unsigned int *volatile int_mask_reg[MAX_CPUS];
@


1.1.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d49 33
a81 8
#define MVME188_EPROM		0xFFC00000
#define MVME188_EPROM_SIZE	0x00080000
#define MVME188_SRAM		0xFFE00000
#define MVME188_SRAM_SIZE	0x00020000
#define MVME188_UTILITY		0xFF000000
#define MVME188_UTILITY_SIZE	0x01000000
#define UTIL_START		0xFFC00000  /* start of MVME188 utility space */
#define UTIL_SIZE		0x003FFFFF  /* size of MVME188 utility space */
d88 2
a89 2
#define INTR_CONTROL_BASE	0xfff84000
#define VMEA24SPACE	0xEEC00000 	/*  VMEA24 master addr space (4 Meg) */
d92 4
a95 4
#define MVME188_IEN0	0xFFF84004	/* interrupt enable CPU 0 */
#define MVME188_IEN1	0xFFF84008	/* interrupt enable CPU 1 */
#define MVME188_IEN2	0xFFF84010	/* interrupt enable CPU 2 */
#define MVME188_IEN3	0xFFF84020	/* interrupt enable CPU 3 */
d98 14
a111 14
#define IEN0_REG	0xfff84004
#define IEN1_REG	0xfff84008
#define IEN2_REG	0xfff84010
#define IEN3_REG	0xfff84020

#define IENALL_REG	0xfff8403c

#define MVME188_IST	0xFFF84040 	/* interrupt status register */
#define IST_REG		0xfff84040	/* same as above */

#define MVME188_SETSWI	0xFFF84080 	/* generate soft interrupt */
#define MVME188_CLRSWI	0xFFF84084 	/* reset soft interrupt */
#define MVME188_ISTATE	0xFFF84088 	/* HW interrupt status */
#define MVME188_CLRINT	0xFFF8408C 	/* reset HW interrupt */
d114 9
a122 9
#define SETSWI_REG	0xfff84080	/* SETSWI register addr */
#define CLRSWI_REG	0xfff84084	/* CLRSWI register addr */
#define ISTATE_REG	0xfff84088
#define CLRINT_REG	0xfff8408C

#define MVME188_GCSR	0xFFF86000	/* 188 global control and status reg */
#define MVME188_UCSR	0xFFF87000	/* 188 utility control and status reg */
#define MVME188_BASAD	0xFFF87004	/* 188 base address reg */
#define MVME188_GLBRES	0xFFF8700C	/* 188 global reset reg */
d124 1
a124 1
#define GCSR_BASE	0xfff86000
d129 18
a146 18
#define GLB0		0xfff86001
#define GLB1		0xfff86003
#define GLB2		0xfff86005
#define GLB3		0xfff86007
#define M188_SYSCON	0x00000040
#define UCSR_REG	0xfff87000
#define GLBRES_REG	0xfff8700C

#define MVME188_CCSR	0xFFF88000	/* 188 CPU board control status reg */
#define MVME188_ERROR	0xFFF88004	/* 188 Mbus fault reg */
#define MVME188_PCNFA	0xFFF88008	/* 188 Pbus A decoder reg */
#define MVME188_PCNFB	0xFFF8800C	/* 188 Pbus B decoder reg */
#define MVME188_EXTAD	0xFFF88010	/* 188 A24 master A24-A31 addr reg */
#define MVME188_WHOAMI	0xFFF88018	/* 188 whoami reg */
#define MVME188_WMAD	0xFFF88020	/* 188 write mbus addr decoder reg */
#define MVME188_RMAD	0xFFF88024	/* 188 read mbus addr decoder reg */
#define MVME188_WVAD	0xFFF88028	/* 188 write vmebus addr decoder reg */
#define MVME188_RVAD	0xFFF8802C	/* 188 read vmebus adds decoder reg */
d149 11
a159 11
#define CCSR_REG	0xfff88000
#define ERROR_REG	0xfff88004	/* ERROR register addr */
#define PCNFA_REG	0xfff88008
#define PCNFB_REG	0xfff8800c
#define EXTAD_REG	0xfff88010
#define EXTAM_REG	0xfff88014
#define WHOAMI_REG	0xfff88018	/* WHOAMI register addr */
#define WMAD_REG	0xfff88020
#define RMAD_REG	0xfff88024
#define WVAD_REG	0xfff88028
#define RVAD_REG	0xfff8802c
d195 2
a196 2
#define ISR_LOW_SOFTINT_MASK(cpu)	(1 << (cpu))
#define ISR_HIGH_SOFTINT_MASK(cpu)	(1 << ((cpu) + 24))
d198 7
a204 8
#define ISR_HIGH_SOFTMASK		(0xf << 24)
#define ISR_SOFTINT_EXCEPT_MASK(cpu) \
	(ISR_LOW_SOFTINT_MASK(cpu) | ISR_HIGH_SOFTINT_MASK(cpu) | 0xf0fffff0)
#define ISR_CLOCKINT_MASK		(1 << IEN_CIOI_LOG)

#define ISR_RESET_NMI			*(int *volatile)MVME188_CLRINT = 1 << CLRINT_CLRABRTI_LOG
#define ISR_RESET_SYSFAIL		*(int *volatile)MVME188_CLRINT = 1 << CLRINT_CLRSFI_LOG
#define ISR_RESET_ACFAIL		*(int *volatile)MVME188_CLRINT = 1 << CLRINT_CLRACFI_LOG
d206 1
a206 1
#define ISR_RESET_HIGH_SOFTINT(cpu)	*(int *)MVME188_CLRSWI = (1 << (cpu + MAX_CPUS))
d210 1
a210 1
#define ISR_GENERATE_HIGH_SOFTINT(cpu)	*((unsigned int *volatile)MVME188_SETSWI) = (1 << (cpu + MAX_CPUS))
d229 25
a253 25
#define ABRT_BIT		0x80000000	/* 31 */
#define ACF_BIT			0x40000000	/* 30 */
#define ARBTO_BIT		0x20000000	/* 29 */
#define DTI_BIT			0x10000000	/* 28 */
#define SWI7_BIT		0x08000000	/* 27 */
#define SWI6_BIT		0x04000000	/* 26 */
#define SWI5_BIT		0x02000000	/* 25 */
#define SWI4_BIT		0x01000000	/* 24 */
#define IRQ7_BIT		0x00800000	/* 23 */
#define CIOI_BIT		0x00200000	/* 21 */
#define SF_BIT			0x00100000	/* 20 */
#define IRQ6_BIT		0x00080000	/* 19 */
#define DI_BIT			0x00020000	/* 17 */
#define SIGHPI_BIT		0x00010000	/* 16 */
#define IRQ5_BIT		0x00004000	/* 14 */
#define IRQ4_BIT		0x00001000	/* 12 */
#define IRQ3_BIT		0x00000400	/* 10 */
#define LMI_BIT			0x00000100	/* 08 */
#define SIGLPI_BIT		0x00000080	/* 07 */
#define IRQ2_BIT		0x00000040	/* 06 */
#define IRQ1_BIT		0x00000010	/* 04 */
#define SWI3_BIT		0x00000008	/* 03 */
#define SWI2_BIT		0x00000004	/* 02 */
#define SWI1_BIT		0x00000002	/* 01 */
#define SWI0_BIT		0x00000001	/* 00 */
d259 4
a262 4
#define HW_FAILURE_MASK		0xE0100000	/* hardware irq bits */
#define SOFT_INTERRUPT_MASK	0x0F00000F	/* software irq bits */
#define VME_INTERRUPT_MASK	0x00885450	/* vme irq bits */
#define OBIO_INTERRUPT_MASK	0x10330180	/* on board I/O */
d280 4
a283 4
#define MASK_LVL_1 (LVL7 | LVL6 | LVL5 | LVL4 | LVL3 | LVL2)
#define MASK_LVL_2 (LVL7 | LVL6 | LVL5 | LVL4 | LVL3)
#define MASK_LVL_3 (LVL7 | LVL6 | LVL5 | LVL4)
#define MASK_LVL_4 (LVL7 | LVL6 | LVL5)
d286 1
a286 1
#define MASK_LVL_7 0x00000000 /* all ints disabled */
d289 5
a293 5
#define CIO_BASE		0xfff83000
#define CIO_PORTC		0xfff83000
#define CIO_PORTB		0xfff83004
#define CIO_PORTA		0xfff83008
#define CIO_CTRL		0xfff8300c
d348 15
a362 15
#define DART_BASE		0xfff82000
#define DART_MRA		0xfff82000	/* mode A */
#define DART_SRA		0xfff82004	/* status A */
#define DART_RBA		0xfff8200c	/* receive buffer A */
#define DART_IPCR		0xfff82010	/* input port change */
#define DART_ISR		0xfff82014	/* interrupt status */
#define DART_CUR		0xfff82018	/* count upper */
#define DART_CLR		0xfff8201c	/* count lower */
#define DART_MR1B		0xfff82020	/* mode B */
#define DART_SRB		0xfff82024	/* status B */
#define DART_RBB		0xfff8202c	/* receive buffer B */
#define DART_IVR		0xfff82030	/* interrupt vector */
#define DART_INP		0xfff82034	/* input port */
#define DART_STARTC		0xfff82038	/* start counter cmd */
#define DART_STOPC		0xfff8203c	/* stop counter cmd */
d365 14
a378 14
#define DART_CSRA		0xfff82004	/* clock select A */
#define DART_CRA		0xfff82008	/* command A */
#define DART_TBA		0xfff8200c	/* transmit buffer A */
#define DART_ACR		0xfff82010	/* auxiliary control */
#define DART_IMR		0xfff82014	/* interrupt mask reg*/
#define DART_CTUR		0xfff82018	/* counter/timer MSB */
#define DART_CTLR		0xfff8201c	/* counter/timer LSB */
#define DART_MRB		0xfff82020	/* mode B */
#define DART_CSRB		0xfff82024	/* clock select B */
#define DART_CRB		0xfff82028	/* command B */
#define DART_TBB		0xfff8202c	/* transmit buffer B */
#define DART_OPCR		0xfff82034	/* output port config*/
#define DART_OPRS		0xfff82038	/* output port set */
#define DART_OPRR		0xfff8203c	/* output port reset */
d391 1
a391 1
#endif
d393 1
a393 1
#define M188_IACK		0xFFF85000
d396 1
a396 1
#endif	/* __MACHINE_MVME188_H__ */
@


1.1.4.5
log
@Merge with the trunk
@
text
@d108 1
a108 2
#define	M188_LRST	0x00000080
#define	M188_SYSCONNEG	0x00000040
@


