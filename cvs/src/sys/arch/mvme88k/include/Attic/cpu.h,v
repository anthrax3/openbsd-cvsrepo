head	1.48;
access;
symbols
	OPENBSD_5_5:1.47.0.6
	OPENBSD_5_5_BASE:1.47
	OPENBSD_5_4:1.47.0.2
	OPENBSD_5_4_BASE:1.47
	OPENBSD_5_3:1.45.0.8
	OPENBSD_5_3_BASE:1.45
	OPENBSD_5_2:1.45.0.6
	OPENBSD_5_2_BASE:1.45
	OPENBSD_5_1_BASE:1.45
	OPENBSD_5_1:1.45.0.4
	OPENBSD_5_0:1.45.0.2
	OPENBSD_5_0_BASE:1.45
	OPENBSD_4_9:1.44.0.8
	OPENBSD_4_9_BASE:1.44
	OPENBSD_4_8:1.44.0.6
	OPENBSD_4_8_BASE:1.44
	OPENBSD_4_7:1.44.0.2
	OPENBSD_4_7_BASE:1.44
	OPENBSD_4_6:1.44.0.4
	OPENBSD_4_6_BASE:1.44
	OPENBSD_4_5:1.43.0.2
	OPENBSD_4_5_BASE:1.43
	OPENBSD_4_4:1.37.0.6
	OPENBSD_4_4_BASE:1.37
	OPENBSD_4_3:1.37.0.4
	OPENBSD_4_3_BASE:1.37
	OPENBSD_4_2:1.37.0.2
	OPENBSD_4_2_BASE:1.37
	OPENBSD_4_1:1.35.0.4
	OPENBSD_4_1_BASE:1.35
	OPENBSD_4_0:1.35.0.2
	OPENBSD_4_0_BASE:1.35
	OPENBSD_3_9:1.32.0.6
	OPENBSD_3_9_BASE:1.32
	OPENBSD_3_8:1.32.0.4
	OPENBSD_3_8_BASE:1.32
	OPENBSD_3_7:1.32.0.2
	OPENBSD_3_7_BASE:1.32
	OPENBSD_3_6:1.30.0.2
	OPENBSD_3_6_BASE:1.30
	SMP_SYNC_A:1.27
	SMP_SYNC_B:1.27
	OPENBSD_3_5:1.24.0.2
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	UBC_SYNC_A:1.19
	OPENBSD_3_3:1.19.0.4
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.19.0.2
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	UBC_SYNC_B:1.19
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.6.0.8
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.6
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.4
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	mvme88kport:1.1.1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	first_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.48
date	2014.03.18.22.36.36;	author miod;	state dead;
branches;
next	1.47;

1.47
date	2013.05.17.22.46.27;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2013.05.17.22.40.01;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2011.03.23.16.54.36;	author pirofti;	state Exp;
branches;
next	1.44;

1.44
date	2009.03.15.20.39.53;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2009.02.27.05.19.34;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2009.02.21.18.37.48;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2009.02.16.23.03.33;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2009.02.16.22.55.03;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2009.02.13.23.33.51;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2009.02.13.23.26.51;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2007.05.14.17.00.40;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2007.03.22.18.52.39;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2006.05.13.16.05.50;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2006.05.08.14.36.10;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2006.04.15.15.43.36;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2004.11.09.12.01.16;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2004.11.08.16.39.31;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2004.08.03.21.16.23;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2004.07.30.19.02.08;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2004.07.24.15.05.07;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2004.04.26.14.31.11;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2004.04.26.12.34.05;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2004.04.24.19.51.48;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2004.01.12.07.46.16;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2003.11.09.00.32.00;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2003.10.05.20.27.46;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2003.09.20.13.57.35;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.02.23.27.52;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.07.21.33.43;	author nordin;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.14.01.26.39;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.01.14.21.34.41;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2001.12.20.06.07.28;	author smurph;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.16.23.49.46;	author miod;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.12.13.08.55.51;	author smurph;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.08.23.57.37;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2001.09.23.02.52.27;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.12.12.03.02;	author heko;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.01.23.27.46;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.09.05.44.40;	author smurph;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.07.23.42.32;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.14.20.25.23;	author smurph;	state Exp;
branches;
next	1.6;

1.6
date	99.09.27.20.46.17;	author smurph;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	99.02.09.06.36.26;	author smurph;	state Exp;
branches;
next	1.4;

1.4
date	98.12.15.04.45.49;	author smurph;	state Exp;
branches;
next	1.3;

1.3
date	97.03.03.20.20.54;	author rahnds;	state Exp;
branches;
next	1.2;

1.2
date	97.03.03.19.07.24;	author rahnds;	state dead;
branches;
next	1.1;

1.1
date	95.10.18.10.54.23;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.10.54.23;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.03.03.19.31.38;	author rahnds;	state Exp;
branches;
next	;

1.6.4.1
date	2001.04.18.16.11.15;	author niklas;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2001.07.04.10.20.03;	author niklas;	state Exp;
branches;
next	1.6.4.3;

1.6.4.3
date	2001.10.31.03.01.18;	author nate;	state Exp;
branches;
next	1.6.4.4;

1.6.4.4
date	2001.11.13.21.04.15;	author niklas;	state Exp;
branches;
next	1.6.4.5;

1.6.4.5
date	2002.03.06.02.04.44;	author niklas;	state Exp;
branches;
next	1.6.4.6;

1.6.4.6
date	2002.03.28.10.36.02;	author niklas;	state Exp;
branches;
next	1.6.4.7;

1.6.4.7
date	2003.03.27.23.32.18;	author niklas;	state Exp;
branches;
next	1.6.4.8;

1.6.4.8
date	2003.06.07.11.13.17;	author ho;	state Exp;
branches;
next	1.6.4.9;

1.6.4.9
date	2004.02.19.10.49.07;	author niklas;	state Exp;
branches;
next	1.6.4.10;

1.6.4.10
date	2004.06.05.23.09.49;	author niklas;	state Exp;
branches;
next	;

1.15.2.1
date	2002.01.31.22.55.18;	author niklas;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2002.06.11.03.37.10;	author art;	state Exp;
branches;
next	;


desc
@@


1.48
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/* $OpenBSD: cpu.h,v 1.47 2013/05/17 22:46:27 miod Exp $ */
/*
 * Copyright (c) 1996 Nivas Madhur
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#ifndef	_MACHINE_CPU_H_
#define	_MACHINE_CPU_H_

#include <m88k/cpu.h>

#ifdef _KERNEL

extern int cpuspeed;

__dead void doboot(void);
void	nmihand(void *);

/* M88100 PFSR machine-dependent code snippets */
extern u_int32_t pfsr_save_single[];
extern u_int32_t pfsr_save_188_straight[];
extern u_int32_t pfsr_save_188_double[];
extern u_int32_t pfsr_save_188_quad[];

#endif /* _KERNEL */

#endif
@


1.47
log
@Replace the bunch of md_* function pointers with a `struct board' containing
function pointers for all the board-specific code.

Add a bunch of `struct board' methods to cover most, if not all, of the
`per-board' logic. This allows most of the md drivers to be cleaned up and
no longer need to embed board-specific knowledge.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.46 2013/05/17 22:40:01 miod Exp $ */
@


1.46
log
@Move interrupt-related defines from <machine/cpu.h> to <machine/intr.h>.
No functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.45 2011/03/23 16:54:36 pirofti Exp $ */
a48 14
/* board dependent pointers */
extern void	(*md_interrupt_func_ptr)(struct trapframe *);
#define	md_interrupt_func	(*md_interrupt_func_ptr)
extern int	(*md_nmi_func_ptr)(struct trapframe *);
#define	md_nmi_func		(*md_nmi_func_ptr)
extern void	(*md_nmi_wrapup_func_ptr)(struct trapframe *);
#define	md_nmi_wrapup_func	(*md_nmi_wrapup_func_ptr)
extern u_int	(*md_getipl)(void);
extern u_int	(*md_setipl)(u_int);
extern u_int	(*md_raiseipl)(u_int);
extern void	(*md_init_clocks)(void);
extern void	(*md_send_ipi)(int, cpuid_t);
extern void	(*md_delay)(int);
extern void	(*md_smp_setup)(struct cpu_info *);
d51 6
@


1.45
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.44 2009/03/15 20:39:53 miod Exp $ */
d47 1
a47 1
#include <sys/evcount.h>
d63 1
a63 33

struct intrhand {
	SLIST_ENTRY(intrhand) ih_link;
	int	(*ih_fn)(void *);
	void	*ih_arg;
	int	ih_ipl;
	int	ih_wantframe;
	struct evcount ih_count;
};

int	intr_establish(int, struct intrhand *, const char *);
int	intr_findvec(int, int, int);

/*
 * There are 256 possible vectors on a mvme88k platform (including
 * onboard and VME vectors. Use intr_establish() to register a
 * handler for the given vector. vector number is used to index
 * into the intr_handlers[] table.
 */
#define	NVMEINTR	256
typedef SLIST_HEAD(, intrhand) intrhand_t;
extern intrhand_t intr_handlers[NVMEINTR];

#ifdef MVME188
/*
 * Currently registered VME interrupt vectors for a given IPL, if they
 * are unique. Used to help the MVME188 interrupt handler when it's getting
 * behind.
 */
extern u_int vmevec_hints[8];
#endif

void	doboot(void);
@


1.44
log
@Generic softinterrupt support for m88k based platforms, adapted from arm
with different locking mechanism. 88110 soft ipi are replaced with an
ipi callback which is checked upon return from exception (it can not be kept
as a softintr, as the generic softinterrupt code doesn't have per-cpu
pending softintr queues).
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.43 2009/02/27 05:19:34 miod Exp $ */
d40 2
a41 2
#ifndef	_MVME88K_CPU_H_
#define	_MVME88K_CPU_H_
@


1.43
log
@Rework nmi handling to handle ``complex'' NMI faster, and return as fast as
possible from the exception, without doing the AST and softintr dance.

This should avoid too much stack usage under load.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.42 2009/02/21 18:37:48 miod Exp $ */
a42 1
#include <sys/evcount.h>
d47 2
a61 1
extern void	(*md_soft_ipi)(void);
@


1.42
log
@Move part of the mp lock logic into per-cpu callbacks; on MVME197DP we need
to disable NMI sources in addition to interrupt sources, and we can not
use a quick sequence with shadowing frozen as done for atomic ops.

This lets GENERIC.MP boot multiuser on MVME197DP boards, and is so far stable
enough to be able to recompile a kernel from scratch (with make -j2).
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.41 2009/02/16 23:03:33 miod Exp $ */
d51 1
a51 1
extern void	(*md_nmi_func_ptr)(struct trapframe *);
d53 2
@


1.41
log
@More 88110 SMP work. Contains, horribly entangled:
- dma_cachectl() split into a ``local cpu only'' and ``all cpus'', and an ipi
  to broadcast ``local dma_cachectl'' is added.
- cpu_info fields are rearranged, to have the 88100-specific information
  and the 88110-specific information overlap, and has many more 88110
  ugly things.
- more ipi handling in the 197-specific area. Since it is not possible to
  have the second processor receive any hardware interrupt (selection
  is done on a level basis via ISEL, and we definitely do not want the
  main cpu to lose interrupts), the best we can do is to inflict ourselves
  a soft interrupt for late ipi processing. It gets used for softclock and
  hardclock on the secondary processor, but since the soft interrupt
  dispatcher doesn't have an exception frame, we have to remember parts
  of it to build a fake clockframe from the soft ipi handler (ugly but
  works).

This now lets GENERIC.MP run a few userland binaries before bugs trigger.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.40 2009/02/16 22:55:03 miod Exp $ */
d60 1
@


1.40
log
@Since NMI are now handled separately, remove the ``interrupt type'' argument
from interrupt() and related function pointers.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.39 2009/02/13 23:33:51 miod Exp $ */
d59 1
@


1.39
log
@Use a different dispatcher for the NMI traps on 88110, these are too
different from regular hardware interrupts to be worth handling the
same way.

Disable IPI reception while we are handling pending IPIs. And do not
reenable them by mistake if we need to send an IPI in return.

This lets GENERIC.MP boot single user on a MVME197DP. There are still
many bugs to fix.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.38 2009/02/13 23:26:51 miod Exp $ */
d49 1
a49 1
extern void	(*md_interrupt_func_ptr)(u_int, struct trapframe *);
@


1.38
log
@Make delay() a per-board function pointer.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.37 2007/05/14 17:00:40 miod Exp $ */
d51 2
@


1.37
log
@Work in progress IPI mechanism, currently only implemented on MVME188, to
send clock ticks to secondary processors.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.36 2007/03/22 18:52:39 miod Exp $ */
d56 1
@


1.36
log
@When registering VME interrupts, maintain a direct ipl->vector table, as long
as no more than one interrupt is registered for a given level.

Then, if the VME interrupt vector reading cycle fails on the 188 interrupt
arbiter, we can use this table as a hint if it has a valid entry, since
we know on which ipl line the interrupt occured.

This basically silences the
m188_ext_int: timeout getting VME interrupt vector, level 3, mask 0x400<IRQ3>
occasional messages appearing when the MVME376 is overloaded.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.35 2006/05/13 16:05:50 miod Exp $ */
d55 1
@


1.35
log
@Oops, intr_findvec() proto is still necessary.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.34 2006/05/08 14:36:10 miod Exp $ */
d77 9
@


1.34
log
@Replace gazillions of badvaddr() or badwordaddr() calls with badaddr() calls.
With a few prototype declarations shuffling, this finally allows
<machine/locore.h> to die.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.33 2006/04/15 15:43:36 miod Exp $ */
d66 1
@


1.33
log
@nmihand() is mvme88k only, move it out of m88k common area.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.32 2004/11/09 12:01:16 miod Exp $ */
d49 1
a49 1
extern void (*md_interrupt_func_ptr)(u_int, struct trapframe *);
d51 4
a54 4
extern u_int (*md_getipl)(void);
extern u_int (*md_setipl)(u_int);
extern u_int (*md_raiseipl)(u_int);
extern void (*md_init_clocks)(void);
d77 2
a78 1
void nmihand(void *);
@


1.32
log
@Split {get,set,raise}ipl() into per-board implementations.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.31 2004/11/08 16:39:31 miod Exp $ */
d76 2
@


1.31
log
@Kill struct md_p, which was really only necessary for mvme88k; on
luna88k it disappears completely, while mvme88k keeps 3 global variables,
one of them scheduled to disappear very soon.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.30 2004/08/03 21:16:23 deraadt Exp $ */
a48 1
extern volatile u_int8_t *md_intr_mask;
d51 3
@


1.30
log
@hide more inside _KERNEL; miod ok
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.29 2004/07/30 19:02:08 miod Exp $ */
d47 6
@


1.29
log
@Move evcount structures inside struct intrhand, this makes more sense and
gives us more counters in the process.

Also clean up intrhand structures and usage, especially move them to SLISTs.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.28 2004/07/24 15:05:07 miod Exp $ */
d46 2
d68 2
@


1.28
log
@intr_establish() and related defines are mvme88k-only, so move them back from
<m88k/cpu.h>, and simplify the return values while there.
@
text
@d1 1
a1 1
/* $OpenBSD: cpu.h,v 1.27 2004/04/26 14:31:11 miod Exp $ */
d43 1
d47 1
d52 1
a52 1
	struct	intrhand *ih_next;
d55 1
a55 1
int	intr_establish(int vec, struct intrhand *);
d63 3
a65 1
extern struct intrhand *intr_handlers[256];
@


1.27
log
@Fix RCSID
@
text
@d1 42
a42 2
/* $OpenBSD$ */
/* public domain */
d44 20
@


1.26
log
@Start factorizing luna88k and mvme88k common parts.
For now, include files only.
@
text
@d1 1
a1 1
/* $OpenBSD */
@


1.25
log
@Preliminary switch to an mvme88k bus_space world. Not all drivers have been
converted yet, and they rely upon some linear mappings provided by bus_space.

In order to not impact performance, almost all the bus_space accesses go
through macros and inline functions. This currently restricts us to D16 and
D32 access modes, which are selected at compilation time. Since there are no
plans to support D8 vme devices in the future, this is acceptable for now.

This makes the "len" locator for vme devices go away, and allows to simplify
some code which was using the pcctwo device, and will now directly access
hardware which is known to exist, rather than wait until the device is
attached.

While there, try to enforce more interrupt vector number checks, since these
changes pointed out that dart(4) had been working correctly so far by sheer
luck only.
@
text
@d1 3
a3 174
/*	$OpenBSD: cpu.h,v 1.24 2004/01/12 07:46:16 miod Exp $ */
/*
 * Copyright (c) 1996 Nivas Madhur
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef __MACHINE_CPU_H__
#define __MACHINE_CPU_H__

/*
 * CTL_MACHDEP definitinos.
 */
#define	CPU_CONSDEV	1	/* dev_t: console terminal device */
#define	CPU_MAXID	2	/* number of valid machdep ids */

#define	CTL_MACHDEP_NAMES { \
	{ 0, 0 }, \
	{ "console_device", CTLTYPE_STRUCT }, \
}

#ifdef _KERNEL

#include <machine/psl.h>
#include <machine/pcb.h>
#include <machine/board.h>

/*
 * definitions of cpu-dependent requirements
 * referenced in generic code
 */
#define	cpu_exec(p)	/* nothing */
#define	cpu_wait(p)	/* nothing */
#define	cpu_swapout(p)	/* nothing */

/*
 * Arguments to hardclock and gatherstats encapsulate the previous
 * machine state in an opaque clockframe. CLKF_INTR is only valid
 * if the process is in kernel mode. Clockframe is really trapframe,
 * so pointer to clockframe can be safely cast into a pointer to
 * trapframe.
 */
struct clockframe {
	struct trapframe tf;
};

#define	CLKF_USERMODE(framep)	((((struct trapframe *)(framep))->tf_epsr & PSR_MODE) == 0)
#define	CLKF_PC(framep)		(((struct trapframe *)(framep))->tf_sxip & XIP_ADDR)
#define	CLKF_INTR(framep)	(((struct trapframe *)(framep))->tf_r[31] >= UADDR)

/*
 * Get interrupt glue.
 */
#include <machine/intr.h>

#define SIR_NET		1
#define SIR_CLOCK	2

#define setsoftint(x)	(ssir |= (x))
#define setsoftnet()	(ssir |= SIR_NET)
#define setsoftclock()	(ssir |= SIR_CLOCK)

#define siroff(x)	(ssir &= ~x)

extern int	ssir;
extern int	want_ast;

/*
 * Preempt the current process if in interrupt from user mode,
 * or after the current trap/syscall if in system mode.
 */
extern int	want_resched;		/* resched() was called */
#define	need_resched()		(want_resched = 1, want_ast = 1)

/*
 * Give a profiling tick to the current process when the user profiling
 * buffer pages are invalid.  On the sparc, request an ast to send us
 * through trap(), marking the proc as needing a profiling tick.
 */
#define	need_proftick(p)	((p)->p_flag |= P_OWEUPC, want_ast = 1)

/*
 * Notify the current process (p) that it has a signal pending,
 * process as soon as possible.
 */
#define	signotify(p)		(want_ast = 1)

struct intrhand {
	int	(*ih_fn)(void *);
	void	*ih_arg;
	int	ih_ipl;
	int	ih_wantframe;
	struct	intrhand *ih_next;
};

int	intr_establish(int vec, struct intrhand *);

/*
 * return values for intr_establish()
 */

#define INTR_EST_SUCC 		0
#define INTR_EST_BADVEC		1
#define INTR_EST_BADIPL		2


/*
 * There are 256 possible vectors on a MVME1x7 platform (including
 * onboard and VME vectors. Use intr_establish() to register a
 * handler for the given vector. vector number is used to index
 * into the intr_handlers[] table.
 */
extern struct intrhand *intr_handlers[256];

/*
 * switchframe - should be double word aligned.
 */
struct switchframe {
	u_int	sf_pc;			/* pc */
	void	*sf_proc;		/* proc pointer */
};

/* This struct defines the machine dependent pointers */
struct md_p {
	void (*clock_init_func)(void);      /* interval clock init function */
	void (*statclock_init_func)(void);  /* statistics clock init function */
	void (*delayclock_init_func)(void); /* delay clock init function */
	void (*delay_func)(void);           /* delay clock function */
	void (*interrupt_func)(u_int, struct trapframe *);       /* interrupt func */
	u_char *volatile intr_mask;
	u_char *volatile intr_ipl;
	u_char *volatile intr_src;
};

extern struct md_p md;

int badvaddr(vaddr_t, int);
void nmihand(void *);

#endif /* _KERNEL */
#endif /* __MACHINE_CPU_H__ */
@


1.24
log
@Get rid of that ugly m88100_saved_state structure, use trapframe everywhere
instead.

Allow struct reg and struct trapframe to live different lives and grow
separately. Righty now they are still the same, and code expects a trapframe
to always start with a struct reg. This may change...
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.23 2003/11/09 00:32:00 miod Exp $ */
a87 24

/*
 * Internal IO space (iiomapsize).
 *
 * Internal IO space is mapped in the kernel from ``OBIO_START'' to
 * ``intiolimit'' (defined in locore.s).  Since it is always mapped,
 * conversion between physical and kernel virtual addresses is easy.
 */

#ifdef VIRTMAP
/* This will do non 1:1 phys/virt memory mapping in the future - SPM */
#define	ISIIOVA(va) \
	((char *)(va) >= intiobase && (char *)(va) < intiolimit)
#define	IIOV(pa)	((int)(pa)-(int)iiomapbase+(int)intiobase)
#define	IIOP(va)	((int)(va)-(int)intiobase+(int)iiomapbase)
#define	IIOPOFF(pa)	((int)(pa)-(int)iiomapbase)

#else

#define	ISIIOVA(va) 1
#define	IIOV(pa)	((pa))
#define	IIOP(va)	((va))
#define	IIOPOFF(pa)	((int)(pa)-(int)OBIO_START)
#endif
@


1.23
log
@Typos; Jonathan Gray
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.22 2003/10/05 20:27:46 miod Exp $ */
d80 3
a82 3
#define	CLKF_USERMODE(framep)	((((struct trapframe *)(framep))->epsr & PSR_MODE) == 0)
#define	CLKF_PC(framep)		(((struct trapframe *)(framep))->sxip & XIP_ADDR)
#define	CLKF_INTR(framep)	(((struct trapframe *)(framep))->r[31] >= UADDR)
d186 1
a186 1
	void (*interrupt_func)(u_int, struct m88100_saved_state *);       /* interrupt func */
@


1.22
log
@Kill vm_offset_t and vm_size_t, in favor of the [pv]addr_t and [pv]size_t
typedefs.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.21 2003/09/20 13:57:35 miod Exp $ */
d180 1
a180 1
/* This struct defines the machine dependant pointers */
@


1.21
log
@Cleanup uses of intstack and interrupt_stack[] - also makes time % in top
more realistic.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.20 2003/06/02 23:27:52 millert Exp $ */
d97 1
a97 1
#ifdef VIRTMAP 
d134 1
a134 1
 * buffer pages are invalid.  On the sparc, request an ast to send us 
d194 2
a195 3

int badvaddr(vm_offset_t va, int size);
void nmihand(void *framep);
@


1.20
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.19 2002/06/07 21:33:43 nordin Exp $ */
a79 2
extern int intstack;

d81 2
a82 2
#define	CLKF_PC(framep)		(((struct trapframe *)(framep))->sxip & ~3)
#define	CLKF_INTR(framep)	(((struct trapframe *)(framep))->r[31] > intstack)
@


1.19
log
@Remove obsolete CLKF_BASEPRI(). ok niklas@@, miod@@ and art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.18 2002/03/14 01:26:39 millert Exp $ */
d24 1
a24 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.18
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.17 2002/01/14 21:34:41 miod Exp $ */
a86 1
#define	CLKF_BASEPRI(framep)	(((struct trapframe *)(framep))->mask == 0)
@


1.17
log
@volatile police.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.16 2001/12/20 06:07:28 smurph Exp $ */
d153 1
a153 1
	int	(*ih_fn) __P((void *));
d160 1
a160 1
int	intr_establish __P((int vec, struct intrhand *));
d189 5
a193 5
	void (*clock_init_func) __P((void));      /* interval clock init function */
	void (*statclock_init_func) __P((void));  /* statistics clock init function */
	void (*delayclock_init_func) __P((void)); /* delay clock init function */
	void (*delay_func) __P((void));           /* delay clock function */
	void (*interrupt_func) __P((u_int, struct m88100_saved_state *));       /* interrupt func */
d202 2
a203 2
int badvaddr __P((vm_offset_t va, int size));
void nmihand __P((void *framep));
@


1.16
log
@machine dependant pointer changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.15 2001/12/16 23:49:46 miod Exp $ */
d194 3
a196 3
	volatile u_char *intr_mask;
	volatile u_char *intr_ipl;
	volatile u_char *intr_src;
@


1.15
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.13 2001/11/08 23:57:37 miod Exp $ */
d187 2
a188 3
/* This struct defines the machine dependant function pointers */

struct funcp {
d193 4
a196 2
   void (*interrupt_func) __P((u_int, struct m88100_saved_state *));       /* interrupt func */
   void (*fp_precise_func) __P((void));      /* floating point precise function */
d199 2
a200 1
extern struct funcp mdfp;
@


1.15.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.17 2002/01/14 21:34:41 miod Exp $ */
d187 3
a189 2
/* This struct defines the machine dependant pointers */
struct md_p {
d194 2
a195 4
	void (*interrupt_func) __P((u_int, struct m88100_saved_state *));       /* interrupt func */
	u_char *volatile intr_mask;
	u_char *volatile intr_ipl;
	u_char *volatile intr_src;
d198 1
a198 2
extern struct md_p md;

@


1.15.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.15.2.1 2002/01/31 22:55:18 niklas Exp $ */
d87 1
d153 1
a153 1
	int	(*ih_fn)(void *);
d160 1
a160 1
int	intr_establish(int vec, struct intrhand *);
d189 5
a193 5
	void (*clock_init_func)(void);      /* interval clock init function */
	void (*statclock_init_func)(void);  /* statistics clock init function */
	void (*delayclock_init_func)(void); /* delay clock init function */
	void (*delay_func)(void);           /* delay clock function */
	void (*interrupt_func)(u_int, struct m88100_saved_state *);       /* interrupt func */
d202 2
a203 2
int badvaddr(vm_offset_t va, int size);
void nmihand(void *framep);
@


1.14
log
@Support for MVME197 completed.  Fix SPL defs.
@
text
@d187 3
a189 2
/* This struct defines the machine dependant pointers */
struct md_p {
d194 2
a195 7
	void (*interrupt_func) __P((u_int, struct m88100_saved_state *));       /* interrupt func */
	void (*fp_precise_func) __P((void));      /* floating point precise function */
	void (*trap_func) __P((unsigned, struct m88100_saved_state *));
	void (*syscall_func) __P((register_t, struct m88100_saved_state *));
	volatile u_char *intr_mask;
	volatile u_char *intr_ipl;
	volatile u_char *intr_src;
d198 1
a198 2
extern struct md_p md;

@


1.13
log
@COPY_SIGCODE serve no purpose nowadays.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.12 2001/09/23 02:52:27 miod Exp $ */
d187 2
a188 3
/* This struct defines the machine dependant function pointers */

struct funcp {
d193 7
a199 2
   void (*interrupt_func) __P((u_int, struct m88100_saved_state *));       /* interrupt func */
   void (*fp_precise_func) __P((void));      /* floating point precise function */
d202 2
a203 1
extern struct funcp mdfp;
@


1.12
log
@Declare machdep.conssole_device sysctl.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.11 2001/08/12 12:03:02 heko Exp $ */
a68 2
#define	COPY_SIGCODE		/* copy sigcode above user stack in exec */

@


1.11
log
@#(endif|else) foo is incorrect, make it #endif /* foo */
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.10 2001/07/01 23:27:46 miod Exp $ */
d51 2
a52 1
#define	CPU_MAXID	1	/* no valid machdep ids */
d56 1
@


1.10
log
@Variable declarations without extern are evil.
Also, use PSR_MODE instead of a hardcoded constant in CLKF_USERMODE.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.9 2001/03/09 05:44:40 smurph Exp $ */
d204 1
a204 1
#endif __MACHINE_CPU_H__
@


1.9
log
@kernel will compile with -Werror.  Added intr.h
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.8 2001/03/07 23:42:32 miod Exp $ */
d86 1
a86 1
#define	CLKF_USERMODE(framep)	((((struct trapframe *)(framep))->epsr & 80000000) == 0)
a114 1
#define ackbarf	((char *)(va) >= OBIO_START && (char *)(va) < (OBIO_START + OBIO_SIZE))
d129 2
a130 2
int	ssir;
int	want_ast;
d136 1
a136 1
int	want_resched;		/* resched() was called */
@


1.8
log
@Strict prototypes for interrupt handlers and a few machine-dependent
callbacks.
While there, some warning hunting.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.7 2001/01/14 20:25:23 smurph Exp $ */
d90 5
@


1.7
log
@Complete move to UVM virtual memory system.  More header fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.6 1999/09/27 20:46:17 smurph Exp $ */
d84 1
a84 1
extern intstack;
d149 1
a149 1
	int	(*ih_fn)();
d186 6
a191 6
	void (*clock_init_func)();      /* interval clock init function */
	void (*statclock_init_func)();  /* statistics clock init function */
	void (*delayclock_init_func)(); /* delay clock init function */
	void (*delay_func)();           /* delay clock function */
   void (*interrupt_func)();       /* interrupt func */
   void (*fp_precise_func)();      /* floating point precise function */
d195 3
@


1.6
log
@Adding support for MVME188 and MVME197
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.5 1999/02/09 06:36:26 smurph Exp $ */
d45 2
a46 2
#ifndef _CPU_H_
#define _CPU_H_
d197 1
a197 1
#endif /* _CPU_H_ */
@


1.6.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.9 2001/03/09 05:44:40 smurph Exp $ */
d45 2
a46 2
#ifndef __MACHINE_CPU_H__
#define __MACHINE_CPU_H__
d84 1
a84 1
extern int intstack;
a91 5
 * Get interrupt glue.
 */
#include <machine/intr.h>

/*
d149 1
a149 1
	int	(*ih_fn) __P((void *));
d186 6
a191 6
	void (*clock_init_func) __P((void));      /* interval clock init function */
	void (*statclock_init_func) __P((void));  /* statistics clock init function */
	void (*delayclock_init_func) __P((void)); /* delay clock init function */
	void (*delay_func) __P((void));           /* delay clock function */
   void (*interrupt_func) __P((u_int, struct m88100_saved_state *));       /* interrupt func */
   void (*fp_precise_func) __P((void));      /* floating point precise function */
a195 3
int badvaddr __P((vm_offset_t va, int size));
void nmihand __P((void *framep));

d197 1
a197 1
#endif __MACHINE_CPU_H__
@


1.6.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.6.4.1 2001/04/18 16:11:15 niklas Exp $ */
d86 1
a86 1
#define	CLKF_USERMODE(framep)	((((struct trapframe *)(framep))->epsr & PSR_MODE) == 0)
d115 1
d130 2
a131 2
extern int	ssir;
extern int	want_ast;
d137 1
a137 1
extern int	want_resched;		/* resched() was called */
@


1.6.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.6.4.2 2001/07/04 10:20:03 niklas Exp $ */
d51 1
a51 2
#define	CPU_CONSDEV	1	/* dev_t: console terminal device */
#define	CPU_MAXID	2	/* number of valid machdep ids */
a54 1
	{ "console_device", CTLTYPE_STRUCT }, \
d204 1
a204 1
#endif /* __MACHINE_CPU_H__ */
@


1.6.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d69 2
@


1.6.4.5
log
@Merge in trunk
@
text
@d187 3
a189 2
/* This struct defines the machine dependant pointers */
struct md_p {
d194 2
a195 4
	void (*interrupt_func) __P((u_int, struct m88100_saved_state *));       /* interrupt func */
	u_char *volatile intr_mask;
	u_char *volatile intr_ipl;
	u_char *volatile intr_src;
d198 1
a198 2
extern struct md_p md;

@


1.6.4.6
log
@Merge in -current from about a week ago
@
text
@d153 1
a153 1
	int	(*ih_fn)(void *);
d160 1
a160 1
int	intr_establish(int vec, struct intrhand *);
d189 5
a193 5
	void (*clock_init_func)(void);      /* interval clock init function */
	void (*statclock_init_func)(void);  /* statistics clock init function */
	void (*delayclock_init_func)(void); /* delay clock init function */
	void (*delay_func)(void);           /* delay clock function */
	void (*interrupt_func)(u_int, struct m88100_saved_state *);       /* interrupt func */
d202 2
a203 2
int badvaddr(vm_offset_t va, int size);
void nmihand(void *framep);
@


1.6.4.7
log
@Sync the SMP branch with 3.3
@
text
@d87 1
@


1.6.4.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.6.4.7 2003/03/27 23:32:18 niklas Exp $ */
d24 5
a28 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.6.4.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d80 5
a84 3
#define	CLKF_USERMODE(framep)	((((struct trapframe *)(framep))->tf_epsr & PSR_MODE) == 0)
#define	CLKF_PC(framep)		(((struct trapframe *)(framep))->tf_sxip & XIP_ADDR)
#define	CLKF_INTR(framep)	(((struct trapframe *)(framep))->tf_r[31] >= UADDR)
d99 1
a99 1
#ifdef VIRTMAP
d136 1
a136 1
 * buffer pages are invalid.  On the sparc, request an ast to send us
d182 1
a182 1
/* This struct defines the machine dependent pointers */
d188 1
a188 1
	void (*interrupt_func)(u_int, struct trapframe *);       /* interrupt func */
d196 3
a198 2
int badvaddr(vaddr_t, int);
void nmihand(void *);
@


1.6.4.10
log
@Merge with the trunk
@
text
@d1 198
a198 3
/* $OpenBSD$ */
/* public domain */
#include <m88k/cpu.h>
@


1.5
log
@Added kernel support for user debugging.  Fixed file ID's
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.1 1998/12/15 04:45:50 smurph Exp $ */
d182 13
@


1.4
log
@Commit for the first real OpenBSD mvme88k kernel.
@
text
@d1 1
@


1.3
log
@Cleanup after import. This also seems to bring up the current version.
@
text
@d60 1
d90 25
d118 1
@


1.2
log
@This is a remove to get rid of the old mvme88k port which was incomplete
to replace it with a working version. The kernel compiles and works
at least.  The new version will be imported shortly.
@
text
@d2 1
d56 1
a56 1
#ifdef KERNEL
d59 1
a71 9
 * See syscall() for an explanation of the following.  Note that the
 * locore bootstrap code follows the syscall stack protocol.  The
 * framep argument is unused.
 */
#define cpu_set_init_frame(p, fp) \
	(p)->p_md.md_tf = (struct trapframe *) \
	    ((caddr_t)(p)->p_addr)

/*
d73 4
a76 1
 * machine state in an opaque clockframe.
d79 1
a79 3
	int	pc;	/* program counter at time of interrupt */
	int	sr;	/* status register at time of interrupt */
	int	ipl;	/* mask level at the time of interrupt  */
d82 6
a87 4
#define	CLKF_USERMODE(framep)	(((framep)->sr & 80000000) == 0)
#define	CLKF_BASEPRI(framep)	((framep)->ipl == 0)
#define	CLKF_PC(framep)		((framep)->pc & ~3)
#define	CLKF_INTR(framep)	(0)
d92 2
a93 2
#define setsoftnet()	(ssir |= SIR_NET, want_ast = 1)
#define setsoftclock()	(ssir |= SIR_CLOCK, want_ast = 1)
d120 36
a155 1
#endif /* KERNEL */
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@initial 88k import; code by nivas and based on mach luna88k
@
text
@@


1.1.1.2
log
@Third try at importing the mvme88k port. This is a working kernel
from nivas.
Userland and compiler still need to be worked on.
Make certain what directory the import is done from.
@
text
@a1 1
 * Copyright (c) 1996 Nivas Madhur
d55 1
a55 1
#ifdef _KERNEL
a57 1
#include <machine/pcb.h>
d70 9
d80 1
a80 4
 * machine state in an opaque clockframe. CLKF_INTR is only valid
 * if the process is in kernel mode. Clockframe is really trapframe,
 * so pointer to clockframe can be safely cast into a pointer to
 * trapframe.
d83 3
a85 1
	struct trapframe tf;
d88 4
a91 6
extern intstack;

#define	CLKF_USERMODE(framep)	((((struct trapframe *)(framep))->epsr & 80000000) == 0)
#define	CLKF_BASEPRI(framep)	(((struct trapframe *)(framep))->mask == 0)
#define	CLKF_PC(framep)		(((struct trapframe *)(framep))->sxip & ~3)
#define	CLKF_INTR(framep)	(((struct trapframe *)(framep))->r[31] > intstack)
d96 2
a97 2
#define setsoftnet()	(ssir |= SIR_NET)
#define setsoftclock()	(ssir |= SIR_CLOCK)
d124 1
a124 36
struct intrhand {
	int	(*ih_fn)();
	void	*ih_arg;
	int	ih_ipl;
	int	ih_wantframe;
	struct	intrhand *ih_next;
};

int	intr_establish __P((int vec, struct intrhand *));

/*
 * return values for intr_establish()
 */

#define INTR_EST_SUCC 		0
#define INTR_EST_BADVEC		1
#define INTR_EST_BADIPL		2


/*
 * There are 256 possible vectors on a MVME1x7 platform (including
 * onboard and VME vectors. Use intr_establish() to register a
 * handler for the given vector. vector number is used to index
 * into the intr_handlers[] table.
 */
extern struct intrhand *intr_handlers[256];

/*
 * switchframe - should be double word aligned.
 */
struct switchframe {
	u_int	sf_pc;			/* pc */
	void	*sf_proc;		/* proc pointer */
};

#endif /* _KERNEL */
@
