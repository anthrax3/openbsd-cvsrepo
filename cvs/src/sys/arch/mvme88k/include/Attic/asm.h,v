head	1.29;
access;
symbols
	OPENBSD_5_5:1.28.0.42
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.28.0.38
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.28.0.36
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.28.0.34
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.32
	OPENBSD_5_0:1.28.0.30
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.28.0.28
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.28.0.26
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.28.0.22
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.28.0.24
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.28.0.20
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.28.0.18
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.28.0.16
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.28.0.14
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.28.0.12
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.28.0.10
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.28.0.8
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.28.0.6
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.28.0.4
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.28.0.2
	OPENBSD_3_6_BASE:1.28
	SMP_SYNC_A:1.28
	SMP_SYNC_B:1.28
	OPENBSD_3_5:1.26.0.2
	OPENBSD_3_5_BASE:1.26
	OPENBSD_3_4:1.23.0.4
	OPENBSD_3_4_BASE:1.23
	UBC_SYNC_A:1.23
	OPENBSD_3_3:1.23.0.2
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.20.0.4
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.20.0.2
	OPENBSD_3_1_BASE:1.20
	UBC_SYNC_B:1.20
	UBC:1.18.0.2
	UBC_BASE:1.18
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.6.0.8
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.6
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.4
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	mvme88kport:1.1.1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	first_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.29
date	2014.03.18.22.36.36;	author miod;	state dead;
branches;
next	1.28;

1.28
date	2004.04.26.14.31.11;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2004.04.26.12.34.05;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2004.01.23.17.26.05;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2003.10.05.20.25.08;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2003.09.16.20.52.19;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2003.01.14.03.20.14;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2003.01.07.22.04.51;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2003.01.02.21.40.46;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2001.12.25.01.22.43;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2001.12.22.19.15.40;	author smurph;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.16.23.49.46;	author miod;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2001.12.13.08.55.51;	author smurph;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.20.23.55.20;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2001.10.28.00.58.29;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.21.02.19.31;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.24.22.50.03;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.12.12.03.02;	author heko;	state Exp;
branches;
next	1.11;

1.11
date	2001.07.04.08.09.23;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.20.05.53.05;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.07.23.37.14;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.01.03.38.17;	author smurph;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.14.20.25.23;	author smurph;	state Exp;
branches;
next	1.6;

1.6
date	99.09.27.20.46.16;	author smurph;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	98.12.15.04.45.49;	author smurph;	state Exp;
branches;
next	1.4;

1.4
date	97.03.25.17.07.37;	author rahnds;	state Exp;
branches;
next	1.3;

1.3
date	97.03.03.20.20.44;	author rahnds;	state Exp;
branches;
next	1.2;

1.2
date	97.03.03.19.07.16;	author rahnds;	state dead;
branches;
next	1.1;

1.1
date	95.10.18.10.54.22;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.10.54.22;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.03.03.19.31.27;	author rahnds;	state Exp;
branches;
next	;

1.6.4.1
date	2001.04.18.16.11.12;	author niklas;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2001.07.04.10.20.02;	author niklas;	state Exp;
branches;
next	1.6.4.3;

1.6.4.3
date	2001.10.31.03.01.18;	author nate;	state Exp;
branches;
next	1.6.4.4;

1.6.4.4
date	2001.11.13.21.04.15;	author niklas;	state Exp;
branches;
next	1.6.4.5;

1.6.4.5
date	2001.12.05.00.39.12;	author niklas;	state Exp;
branches;
next	1.6.4.6;

1.6.4.6
date	2002.03.06.02.04.44;	author niklas;	state Exp;
branches;
next	1.6.4.7;

1.6.4.7
date	2003.03.27.23.32.18;	author niklas;	state Exp;
branches;
next	1.6.4.8;

1.6.4.8
date	2004.02.19.10.49.06;	author niklas;	state Exp;
branches;
next	1.6.4.9;

1.6.4.9
date	2004.06.05.23.09.49;	author niklas;	state Exp;
branches;
next	;

1.18.2.1
date	2002.01.31.22.55.18;	author niklas;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2003.05.19.21.45.53;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/* $OpenBSD: asm.h,v 1.28 2004/04/26 14:31:11 miod Exp $ */
/* public domain */
#include <m88k/asm.h>
@


1.28
log
@Fix RCSID
@
text
@d1 1
a1 1
/* $OpenBSD$ */
@


1.27
log
@Start factorizing luna88k and mvme88k common parts.
For now, include files only.
@
text
@d1 1
a1 1
/* $OpenBSD */
@


1.26
log
@Get rid of a few (mostly DDB related) unused defines and macros.
@
text
@d1 3
a3 310
/*	$OpenBSD: asm.h,v 1.25 2003/10/05 20:25:08 miod Exp $	*/

/*
 * Mach Operating System
 * Copyright (c) 1993-1992 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON AND OMRON ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON AND OMRON DISCLAIM ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#ifndef __MACHINE_M88K_ASM_H__
#define __MACHINE_M88K_ASM_H__

#ifdef __STDC__
#define	_C_LABEL(name)		_ ## name
#else
#define	_C_LABEL(name)		_/**/name
#endif

#define	_ASM_LABEL(name)	name

#define	_ENTRY(name) \
	.text; .align 8; .globl name; name:

#define	ENTRY(name)		_ENTRY(_C_LABEL(name))
#define	ASENTRY(name)		_ENTRY(_ASM_LABEL(name))

#define	GLOBAL(name) \
	.globl _C_LABEL(name); _C_LABEL(name):

#define ASGLOBAL(name) \
	.globl _ASM_LABEL(name); _ASM_LABEL(name):

#define	LOCAL(name) \
	_C_LABEL(name):

#define	ASLOCAL(name) \
	_ASM_LABEL(name):

#define	BSS(name, size) \
	.comm	_C_LABEL(name), size

#define	ASBSS(name, size) \
	.comm	_ASM_LABEL(name), size

#ifdef	__ELF__
#define	WEAK_ALIAS(alias,sym)						\
	.weak alias;							\
	alias = sym
#else
#ifdef	__STDC__
#define	WEAK_ALIAS(alias,sym)						\
	.weak _##alias;							\
	_##alias = _##sym
#else
#define	WEAK_ALIAS(alias,sym)						\
	.weak _/**/alias;						\
	_/**/alias = _/**/sym
#endif
#endif

#ifdef _KERNEL

/*
 * Control register symbolic names
 */

#define	PID	cr0
#define	PSR	cr1
#define	EPSR	cr2
#define	SSBR	cr3
#define	SXIP	cr4
#define	SNIP	cr5
#define	SFIP	cr6
#define	VBR	cr7
#define	DMT0	cr8
#define	DMD0	cr9
#define	DMA0	cr10
#define	DMT1	cr11
#define	DMD1	cr12
#define	DMA1	cr13
#define	DMT2	cr14
#define	DMD2	cr15
#define	DMA2	cr16
#define	SR0	cr17
#define	SR1	cr18
#define	SR2	cr19
#define	SR3	cr20

/* MVME197 only */
#define	SRX	cr16
#define	EXIP	cr4
#define	ENIP	cr5
#define	ICMD	cr25
#define	ICTL	cr26
#define	ISAR	cr27
#define	ISAP	cr28
#define	IUAP	cr29
#define	IIR	cr30
#define	IBP	cr31
#define	IPPU	cr32
#define	IPPL	cr33
#define	ISR	cr34
#define	ILAR	cr35
#define	IPAR	cr36
#define	DCMD	cr40
#define	DCTL	cr41
#define	DSAR	cr42
#define	DSAP	cr43
#define	DUAP	cr44
#define	DIR	cr45
#define	DBP	cr46
#define	DPPU	cr47
#define	DPPL	cr48
#define	DSR	cr49
#define	DLAR	cr50
#define	DPAR	cr51
/* end MVME197 only */

#define	FPECR	fcr0
#define	FPHS1	fcr1
#define	FPLS1	fcr2
#define	FPHS2	fcr3
#define	FPLS2	fcr4
#define	FPPT	fcr5
#define	FPRH	fcr6
#define	FPRL	fcr7
#define	FPIT	fcr8
#define	FPSR	fcr62
#define	FPCR	fcr63

/*
 * At various times, there is the need to clear the pipeline (i.e.
 * synchronize).  A "tb1 0, r0, foo" will do that (because a trap
 * instruction always synchronizes, and this particular instruction
 * will never actually take the trap).
 */
#if 0
#define	FLUSH_PIPELINE		tcnd	ne0, r0, 0
#define	FLUSH_PIPELINE_STRING	"tcnd	ne0, r0, 0"
#else
#define	FLUSH_PIPELINE		tb1	0, r0, 0
#define	FLUSH_PIPELINE_STRING	"tb1	0, r0, 0"
#endif
#define	NOP			or	r0, r0, r0
#define	NOP_STRING		"or	r0, r0, r0"

#define RTE	NOP ; rte

/*
 * Useful in some situations.
 */
#define CALL(NAME, ARG1, ARG2) \
	subu	r31, r31, 32; \
	or	r2, r0, ARG1; \
	bsr.n	NAME; \
	 or	r3, r0, ARG2; \
	addu	r31, r31, 32

/* This define is similar to CALL, but accepts a function pointer XXX smurph */
#define CALLP(NAME, ARG1, ARG2) \
	subu	r31, r31, 32; \
	or.u	r5, r0, hi16(NAME); \
	ld	r4, r5, lo16(NAME); \
	or	r2, r0, ARG1; \
	jsr.n	r4; \
	 or	r3, r0, ARG2; \
	addu	r31, r31, 32

/*
 * SR1 - CPU FLAGS REGISTER
 * XXX clean this when the trap handler is reworked. Among the things
 * I like to see is having the trap frame on the kernel stack instead
 * of putting in the PCB. If done properly, we don't need SR1 for doing
 * anything special. nivas
 *
 * SR1 contains flags about the current CPU status.
 *
 * The bit FLAG_IGNORE_DATA_EXCEPTION indicates that any data exceptions
 * 	should be ignored (well, at least treated in a special way).
 * The bit FLAG_ENABLING_FPU indicates that the exception handler is
 * 	in the process of enabling the FPU (so that an exception can
 * 	be serviced).  This is needed because enabling the FPU can
 *	cause other exceptions to happen, and the whole system is
 *	in a rather precarious state and so special cautions must
 * 	be taken.
 */
#define FLAG_CPU_FIELD_WIDTH		2	/* must be <= 12 */
#define FLAG_IGNORE_DATA_EXCEPTION	5
#define FLAG_ENABLING_FPU		7
#define FLAG_FROM_KERNEL		8

/* REGister OFFset into the E.F. (exception frame) */
#define REG_OFF(reg_num)  ((reg_num) * 4) /* (num * sizeof(register_t))  */
#define GENREG_OFF(num)	(REG_OFF(EF_R0 + (num))) /* GENeral REGister OFFset */

/*
 * Some registers used during the setting up of the new exception frame.
 * Don't choose r1, r30, or r31 for any of them.
 *
 * Also, if any are 'r2' or 'r3', be careful using with CALL above!
 */
#define	FLAGS	r2
#define	TMP	r3
#define	TMP2	r10
#define	TMP3	r11
#define	SAVE_TMP2	st	r10, r31, GENREG_OFF(10)
#define	SAVE_TMP3	st	r11, r31, GENREG_OFF(11)
#define	RESTORE_TMP2	ld	r10, r31, GENREG_OFF(10)
#define	RESTORE_TMP3	ld	r11, r31, GENREG_OFF(11)

/*
 * Info about the PSR
 */
#define	PSR_SHADOW_FREEZE_BIT		0
#define	PSR_INTERRUPT_DISABLE_BIT	1
#define	PSR_FPU_DISABLE_BIT		3
#define	PSR_BIG_ENDIAN_MODE		30
#define	PSR_SUPERVISOR_MODE_BIT		31
/*
 * mc88110 PSR bit definitions (MVME197)
 */
#define PSR_GRAPHICS_DISABLE_BIT	4
#define PSR_SERIAL_MODE_BIT		29
#define PSR_CARRY_BIT			28
#define PSR_SERIALIZE_BIT		25

/*
 * Status bits for an SXIP/SNIP/SFIP address.
 */
#define	RTE_VALID_BIT		1
#define	RTE_ERROR_BIT		0

/*
 * Info about DMT0/DMT1/DMT2
 */
#define	DMT_VALID_BIT		0
#define	DMT_WRITE_BIT		1
#define	DMT_LOCK_BIT		12
#define	DMT_DOUBLE_BIT		13
#define	DMT_DAS_BIT		14
#define	DMT_DREG_OFFSET		7
#define	DMT_DREG_WIDTH		5

/*
 * Bits for eh_debug.
 */
#define	DEBUG_INTERRUPT_BIT		0
#define	DEBUG_DATA_BIT			1
#define	DEBUG_INSTRUCTION_BIT		2
#define	DEBUG_MISALIGN_BIT		3
#define	DEBUG_UNIMP_BIT			4
#define	DEBUG_DIVIDE_BIT		5
#define	DEBUG_OF_BIT			6
#define	DEBUG_FPp_BIT			7
#define	DEBUG_FPi_BIT			8
#define	DEBUG_SYSCALL_BIT	 	9
#define	DEBUG_MACHSYSCALL_BIT		10
#define	DEBUG_UNIMPLEMENTED_BIT		11
#define	DEBUG_PRIVILEGE_BIT		12
#define	DEBUG_BOUNDS_BIT		13
#define	DEBUG_OVERFLOW_BIT		14
#define	DEBUG_ERROR_BIT			15
#define	DEBUG_SIGSYS_BIT		16
#define	DEBUG_SIGTRAP_BIT		17
#define	DEBUG_BREAK_BIT			18
#define	DEBUG_TRACE_BIT			19
#define	DEBUG_KDB_BIT			20
#define	DEBUG_JKDB_BIT			21
#define	DEBUG_BUGCALL_BIT		22
/* MVME197 Non-Maskable Interrupt */
#define	DEBUG_NON_MASK_BIT		23
/* MVME197 Data Read Miss (Software Table Searches) */
#define	DEBUG_197_READ_BIT		25
/* MVME197 Data Write Miss (Software Table Searches) */
#define	DEBUG_197_WRITE_BIT		26
/* MVME197 Inst ATC Miss (Software Table Searches) */
#define	DEBUG_197_INST_BIT		27

#define	DEBUG_UNKNOWN_BIT		31

/* exception vector marker */
#define	UNKNOWN_HANDLER		0xffffffff
#define	END_OF_VECTOR_LIST	0xfffffffe

#define	VECTOR(x) \
	word	_C_LABEL(x)

#endif	/* _KERNEL */

#endif /* __MACHINE_M88K_ASM_H__ */
@


1.25
log
@De-register
@
text
@d1 1
a1 1
/*	$OpenBSD: asm.h,v 1.24 2003/09/16 20:52:19 miod Exp $	*/
a170 1
 * NOTE: If ARG1 or ARG2 are r2 or r3, strange things may happen.  Watch out!
d176 1
a176 1
	or	r3, r0, ARG2; \
d186 1
a186 1
	or	r3, r0, ARG2; \
a199 4
 * The bit FLAG_INTERRUPT_EXCEPTION indicates that the current exception
 * 	is the interrupt exception.  Such information can be gotten
 * 	in other ways, but having it in the flags makes it easy for the
 *	exception handler to check quickly.
d208 3
a210 7
#define FLAG_IGNORE_DATA_EXCEPTION	5	/* bit number 5  */
#define FLAG_INTERRUPT_EXCEPTION	6	/* bit number 6  */
#define FLAG_ENABLING_FPU		7	/* bit number 7  */
#define FLAG_FROM_KERNEL		8	/* bit number 8  */
#define FLAG_187			9	/* bit number 9  */
#define FLAG_188			10	/* bit number 10 */
#define FLAG_197			11	/* bit number 11 */
@


1.24
log
@Remove unused material from include files, as well as the annoying U() macro
which is only used to obfuscate things.

Doing this points out that the BUG memory is not at the same address on
187 and 197 (the 197 BUG is inside obio), so provide distinct constants,
and treat 187 and 197 slightly differently in pmap_bootstrap(). However, we
now need to map the 197 flash memory as well...

While there, simplify and constify pmap_table_build() and its associated data.
@
text
@d1 1
a1 1
/*	$OpenBSD: asm.h,v 1.23 2003/01/14 03:20:14 miod Exp $	*/
d222 1
a222 1
#define REG_OFF(reg_num)  ((reg_num) * 4) /* (num * sizeof(register int))  */
@


1.23
log
@Define exception vector tables as assembly source, with the appropriate
macros, rather than include files - no need to pollute <machine/> area...
@
text
@d1 1
a1 1
/*	$OpenBSD: asm.h,v 1.22 2003/01/07 22:04:51 miod Exp $	*/
a223 4

#define GENERAL_BREATHING_ROOM	/* arbitrarily */ 200
#define KERNEL_STACK_BREATHING_ROOM 	\
	(GENERAL_BREATHING_ROOM + SIZEOF_STRUCT_PCB + SIZEOF_STRUCT_UTHREAD)
@


1.22
log
@Remove duplicate SRX definition.
@
text
@d1 1
a1 1
/*	$OpenBSD: asm.h,v 1.21 2003/01/02 21:40:46 miod Exp $	*/
d314 2
a315 4
/*
 * These things for locore_c_routines.c and locore.S
 */
#define	PREDEFINED_BY_ROM	0xffffffff
d317 3
@


1.21
log
@Adapt to recent changes in libc/libc_r wrt weak symbols, so that programs
can link against libc without unresolved symbols again.

Anyone who correctly guessed that my m88k hard drive has been recovered,
wins a strawberry lollipop.
@
text
@d1 1
a1 1
/*	$OpenBSD: asm.h,v 1.20 2001/12/25 01:22:43 miod Exp $	*/
a103 1
#define	SRX	cr16 
d110 1
a110 1
#define	SRX	cr16 
d196 1
a196 1
 * 
d245 1
a245 1
 * Info about the PSR 
d252 2
a253 2
/* 
 * mc88110 PSR bit definitions (MVME197) 
@


1.20
log
@Oops, macros from the wrong tree escaped.
@
text
@d1 1
a1 1
/*	$OpenBSD: asm.h,v 1.19 2001/12/22 19:15:40 smurph Exp $	*/
d64 16
@


1.19
log
@Bring in PSR bit definitions.
@
text
@d1 1
a1 1
/*	$OpenBSD: asm.h,v 1.18 2001/12/16 23:49:46 miod Exp $	*/
a63 7

#define	PANIC(message) \
	or.u	r2, r0, hi16(9f); \
	bsr.n	_C_LABEL(panic); \
	or	r2, r2, lo16(9f); \
9: \
	.string	message
@


1.18
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: asm.h,v 1.16 2001/11/20 23:55:20 miod Exp $	*/
d244 7
@


1.18.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: asm.h,v 1.20 2001/12/25 01:22:43 miod Exp $	*/
d65 7
a243 7
/* 
 * mc88110 PSR bit definitions (MVME197) 
 */
#define PSR_GRAPHICS_DISABLE_BIT	4
#define PSR_SERIAL_MODE_BIT		29
#define PSR_CARRY_BIT			28
#define PSR_SERIALIZE_BIT		25
@


1.18.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a64 16
#ifdef	__ELF__
#define	WEAK_ALIAS(alias,sym)						\
	.weak alias;							\
	alias = sym
#else
#ifdef	__STDC__
#define	WEAK_ALIAS(alias,sym)						\
	.weak _##alias;							\
	_##alias = _##sym
#else
#define	WEAK_ALIAS(alias,sym)						\
	.weak _/**/alias;						\
	_/**/alias = _/**/sym
#endif
#endif

d88 1
d95 1
a95 1
#define	SRX	cr16
d181 1
a181 1
 *
d230 1
a230 1
 * Info about the PSR
d237 2
a238 2
/*
 * mc88110 PSR bit definitions (MVME197)
d299 4
a302 2
/* exception vector marker */
#define	UNKNOWN_HANDLER		0xffffffff
a303 3

#define	VECTOR(x) \
	word	_C_LABEL(x)
@


1.17
log
@Support for MVME197 completed.  Fix SPL defs.
@
text
@a38 5
/* Define EH_DEBUG to be non-zero to compile-in various debugging things */
#ifndef	EH_DEBUG
#define EH_DEBUG 0
#endif	EH_DEBUG

a211 1
#define FLAG_TBE			12	/* bit number 12 */
d239 5
a243 12
#define PSR_SHADOW_FREEZE_BIT		0
#define PSR_INTERRUPT_DISABLE_BIT	1
#define PSR_FPU_DISABLE_BIT		3
#define PSR_BIG_ENDIAN_MODE		30
#define PSR_SUPERVISOR_MODE_BIT		31
/* 
 * mc88110 PSR bit definitions (MVME197) 
 */
#define PSR_GRAPHICS_DISABLE_BIT	4
#define PSR_SERIAL_MODE_BIT		29
#define PSR_CARRY_BIT			28
#define PSR_SERIALIZE_BIT		25
a244 2
#define DSR_TBE				21
#define DCTL_MEN			5
@


1.16
log
@Prevent more symbol clashes when compiling userland.
@
text
@d1 1
a1 1
/*	$OpenBSD: asm.h,v 1.15 2001/10/28 00:58:29 miod Exp $	*/
d39 5
d217 1
d245 12
a256 5
#define	PSR_SHADOW_FREEZE_BIT		0
#define	PSR_INTERRUPT_DISABLE_BIT	1
#define	PSR_FPU_DISABLE_BIT		3
#define	PSR_BIG_ENDIAN_MODE		30
#define	PSR_SUPERVISOR_MODE_BIT		31
d258 2
@


1.15
log
@Use the same pipeline flush instruction everywhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: asm.h,v 1.14 2001/09/21 02:19:31 miod Exp $	*/
d65 35
a99 24
#define RTE	NOP ; rte

#define PID    cr0
#define PSR    cr1
#define EPSR	cr2
#define SSBR	cr3
#define SXIP	cr4
#define SNIP	cr5
#define SFIP	cr6
#define VBR    cr7
#define DMT0	cr8
#define DMD0	cr9
#define DMA0	cr10
#define DMT1	cr11
#define DMD1	cr12
#define DMA1	cr13
#define DMT2	cr14
#define DMD2	cr15
#define DMA2	cr16
#define SRX    cr16 
#define SR0    cr17
#define SR1    cr18
#define SR2    cr19
#define SR3    cr20
d102 27
a128 27
#define SRX    cr16 
#define EXIP	cr4
#define ENIP	cr5
#define ICMD   cr25
#define ICTL   cr26
#define ISAR   cr27
#define ISAP   cr28
#define IUAP   cr29
#define IIR    cr30
#define IBP    cr31
#define IPPU   cr32
#define IPPL   cr33
#define ISR    cr34
#define ILAR   cr35
#define IPAR   cr36
#define DCMD   cr40
#define DCTL   cr41
#define DSAR   cr42
#define DSAP   cr43
#define DUAP   cr44
#define DIR    cr45
#define DBP    cr46
#define DPPU   cr47
#define DPPL   cr48
#define DSR    cr49
#define DLAR   cr50
#define DPAR   cr51
d131 11
a141 11
#define FPECR	fcr0
#define FPHS1	fcr1
#define FPLS1	fcr2
#define FPHS2	fcr3
#define FPLS2	fcr4
#define FPPT	fcr5
#define FPRH	fcr6
#define FPRL	fcr7
#define FPIT	fcr8
#define FPSR	fcr62
#define FPCR	fcr63
d159 2
d165 6
a170 6
#define CALL(NAME, ARG1, ARG2)             \
  		subu	r31, r31, 32	; \
                or      r2, r0, ARG1    ; \
                bsr.n   NAME            ; \
                or      r3, r0, ARG2	; \
		addu	r31, r31, 32
d173 8
a180 24
#define CALLP(NAME, ARG1, ARG2)              \
  		subu	r31, r31, 32	   ; \
                or.u	r5, r0, hi16(NAME) ; \
                ld	r4, r5, lo16(NAME) ; \
		or      r2, r0, ARG1       ; \
                jsr.n   r4                 ; \
                or      r3, r0, ARG2	   ; \
		addu	r31, r31, 32

/* This define can replace the xcr instruction XXX smurph */
#define XCR(DR, SR, CR)         ; \
      stcr   r13,    SR0   ; \
      or      r13, r0, SR     ; \
                ldcr   DR, CR      ; \
      stcr   r13, CR      ; \
      ldcr   r13, SR0

/* This define can be used to debug sub routine returns XXX smurph*/
#define STORE_R1(varname)               ; \
      stcr   r13,    SR0   /* r13 now free */   ; \
      /* save r1 to memory location varname */   ; \
      or.u   r13, r0,  hi16(varname)         ; \
      st   r1,  r13, lo16(varname)         ; \
      ldcr   r13, SR0   /* retore r13   */   
d227 8
a234 8
#define FLAGS	r2
#define TMP	r3
#define TMP2	r10
#define TMP3	r11
#define SAVE_TMP2	st	r10, r31, GENREG_OFF(10)
#define SAVE_TMP3	st	r11, r31, GENREG_OFF(11)
#define RESTORE_TMP2	ld	r10, r31, GENREG_OFF(10)
#define RESTORE_TMP3	ld	r11, r31, GENREG_OFF(11)
d239 5
a243 5
#define PSR_SHADOW_FREEZE_BIT		 0
#define PSR_INTERRUPT_DISABLE_BIT	 1
#define PSR_FPU_DISABLE_BIT		 3
#define PSR_BIG_ENDIAN_MODE		30
#define PSR_SUPERVISOR_MODE_BIT		31
d248 2
a249 2
#define RTE_VALID_BIT	 1
#define RTE_ERROR_BIT	 0
d254 7
a260 7
#define DMT_VALID_BIT	 0
#define DMT_WRITE_BIT 	 1
#define DMT_LOCK_BIT	12
#define DMT_DOUBLE_BIT	13
#define DMT_DAS_BIT     14
#define DMT_DREG_OFFSET	 7
#define DMT_DREG_WIDTH	 5
d265 33
a297 40
#define DEBUG_INTERRUPT_BIT	0
#define DEBUG_DATA_BIT			1
#define DEBUG_INSTRUCTION_BIT	2
#define DEBUG_MISALIGN_BIT		3
#define DEBUG_UNIMP_BIT			4
#define DEBUG_DIVIDE_BIT		5
#define DEBUG_OF_BIT			   6
#define DEBUG_FPp_BIT			7
#define DEBUG_FPi_BIT			8
#define DEBUG_SYSCALL_BIT	 	9
#define DEBUG_MACHSYSCALL_BIT	10
#define DEBUG_UNIMPLEMENTED_BIT	11
#define DEBUG_PRIVILEGE_BIT	12
#define DEBUG_BOUNDS_BIT		13
#define DEBUG_OVERFLOW_BIT		14
#define DEBUG_ERROR_BIT			15
#define DEBUG_SIGSYS_BIT		16
#define DEBUG_SIGTRAP_BIT		17
#define DEBUG_BREAK_BIT			18
#define DEBUG_TRACE_BIT			19
#define DEBUG_KDB_BIT			20
#define DEBUG_JKDB_BIT			21
#define DEBUG_BUGCALL_BIT		22
#define DEBUG_NON_MASK_BIT	   23		/* MVME197 Non-Maskable Interrupt */
#define DEBUG_197_READ_BIT    25    /* MVME197 Data Read Miss (Software Table Searches) */
#define DEBUG_197_WRITE_BIT   26    /* MVME197 Data Write Miss (Software Table Searches) */
#define DEBUG_197_INST_BIT    27    /* MVME197 Inst ATC Miss (Software Table Searches) */

#define DEBUG_UNKNOWN_BIT		31

/*
 * These things for vector_init.c and locore.c
 */
#if defined(_LOCORE)
# define  PREDEFINED_BY_ROM       0xffffffff
# define  END_OF_VECTOR_LIST      0xfffffffe
#else
# define  PREDEFINED_BY_ROM       0xffffffffU
# define  END_OF_VECTOR_LIST      0xfffffffeU
#endif
d300 1
a300 2
 * Define ERROR__XXX_USR if the xxx.usr bug (mask C82N) is present.
 * This implements the workaround.
d302 2
a303 1
#define ERRATA__XXX_USR 	1
d305 1
a305 14
#ifndef CMMU_DEFS
#define CMMU_DEFS
#define SBC_CMMU_I		0xFFF77000 	/* Single Board Computer code CMMU */
#define SBC_CMMU_D		0xFFF7F000 	/* Single Board Computer data CMMU */

#define VME_CMMU_I0		0xFFF7E000 	/* MVME188 code CMMU 0 */
#define VME_CMMU_I1		0xFFF7D000 	/* MVME188 code CMMU 1 */
#define VME_CMMU_I2		0xFFF7B000 	/* MVME188 code CMMU 2 */
#define VME_CMMU_I3		0xFFF77000 	/* MVME188 code CMMU 3 */
#define VME_CMMU_D0		0xFFF6F000 	/* MVME188 data CMMU 0 */
#define VME_CMMU_D1		0xFFF5F000 	/* MVME188 data CMMU 1 */
#define VME_CMMU_D2		0xFFF3F000 	/* MVME188 data CMMU 2 */
#define VME_CMMU_D3		0xFFF7F000 	/* MVME188 data CMMU 3 */
#endif /* CMMU_DEFS */
@


1.14
log
@Don't protect useful macro definitions with #ifdef _LOCORE, as libc needs
some of them.
@
text
@d1 1
a1 1
/*	$OpenBSD: asm.h,v 1.13 2001/08/24 22:50:03 miod Exp $	*/
d139 2
a140 1
#define FLUSH_PIPELINE	tcnd	ne0, r0, 0
d142 2
a143 1
#define FLUSH_PIPELINE	tb1 0, r0, 0
d145 2
a146 1
#define NOP		or r0, r0, r0
@


1.13
log
@Define the usual <machine/asm.h> macros, for convenience of .S parts.
@
text
@d1 1
a1 1
/*	$OpenBSD: asm.h,v 1.12 2001/08/12 12:03:02 heko Exp $	*/
a32 1
#ifdef	_LOCORE
a63 2

#endif	/* _LOCORE */
@


1.12
log
@#(endif|else) foo is incorrect, make it #endif /* foo */
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: asm.h,v 1.11 2001/07/04 08:09:23 niklas Exp $	*/
d33 1
d35 1
a35 1
#	define FUNC(NAME) _##NAME
d37 1
a37 1
#	define FUNC(NAME) _/**/NAME
d40 1
a40 8
/* Define EH_DEBUG to be non-zero to compile-in various debugging things */
#ifndef	EH_DEBUG
#define EH_DEBUG 1
#endif /* EH_DEBUG */

#define	ENTRY(NAME) \
    .align 8; .globl FUNC(NAME); FUNC(NAME):
    
d42 25
a66 12
#define  LABEL(name)	 name:  .globl name ;
/*
 * _LABEL(name)
 *	Defines one visible only to the file, unless debugging
 * 	is enabled, in which case it's visible to the world (and
 *	hence to debuggers, and such).
 */
#if EH_DEBUG
#  define _LABEL(name)	name:	.globl name ;
#else
#  define _LABEL(name)	name:               ;
#endif
d292 3
a294 3
#define DEBUG_197_READ_BIT    25    /* MVME198 Data Read Miss (Software Table Searches) */
#define DEBUG_197_WRITE_BIT   26    /* MVME198 Data Write Miss (Software Table Searches) */
#define DEBUG_197_INST_BIT    27    /* MVME198 Inst ATC Miss (Software Table Searches) */
@


1.11
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 1
a42 1
#endif	EH_DEBUG
d323 1
a323 1
#endif __MACHINE_M88K_ASM_H__
@


1.10
log
@assym.s -> assym.h
@
text
@d1 2
@


1.9
log
@Inclusion from assembly code is detected with _LOCORE, no more fancy symbols.
@
text
@a41 5
#if 0
/* this gives the offsets into various structures of various elements, etc */
#include "assym.s"
#endif

@


1.8
log
@Major changes to get MVME188 working.  More header and code cleanups.  The
kernel is tested on MVME188A/2P256 and MVME188A/1P64.
@
text
@d297 1
a297 1
#if defined(ASSEMBLER)
@


1.7
log
@Complete move to UVM virtual memory system.  More header fixes.
@
text
@d203 1
a203 1
#define FLAG_CPU_FIELD_WIDTH		   4	/* must be <= 12 */
d205 6
a210 6
#define FLAG_INTERRUPT_EXCEPTION	   6	/* bit number 6  */
#define FLAG_ENABLING_FPU		      7	/* bit number 7  */
#define FLAG_FROM_KERNEL            8  /* bit number 8  */
#define FLAG_187 		               8	/* bit number 9  */
#define FLAG_188 		               9	/* bit number 10 */
#define FLAG_197 		              10	/* bit number 11 */
a214 1

@


1.6
log
@Adding support for MVME188 and MVME197
@
text
@d28 2
a29 2
#ifndef __M88K_ASM_H__
#define __M88K_ASM_H__
d327 1
a327 1
#endif /* __M88K_ASM_H__ */
@


1.6.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d28 2
a29 2
#ifndef __MACHINE_M88K_ASM_H__
#define __MACHINE_M88K_ASM_H__
d203 1
a203 1
#define FLAG_CPU_FIELD_WIDTH		2	/* must be <= 12 */
d205 6
a210 6
#define FLAG_INTERRUPT_EXCEPTION	6	/* bit number 6  */
#define FLAG_ENABLING_FPU		7	/* bit number 7  */
#define FLAG_FROM_KERNEL		8	/* bit number 8  */
#define FLAG_187			9	/* bit number 9  */
#define FLAG_188			10	/* bit number 10 */
#define FLAG_197			11	/* bit number 11 */
d216 1
d298 1
a298 1
#if defined(_LOCORE)
d327 1
a327 1
#endif __MACHINE_M88K_ASM_H__
@


1.6.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d42 5
@


1.6.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@a0 2
/*	$OpenBSD$	*/

d32 1
a32 1
#define	_C_LABEL(name)		_ ## name
d34 1
a34 1
#define	_C_LABEL(name)		_/**/name
d37 21
a57 25
#define	_ASM_LABEL(name)	name

#define	_ENTRY(name) \
	.text; .align 8; .globl name; name:

#define	ENTRY(name)		_ENTRY(_C_LABEL(name))
#define	ASENTRY(name)		_ENTRY(_ASM_LABEL(name))

#define	GLOBAL(name) \
	.globl _C_LABEL(name); _C_LABEL(name):

#define ASGLOBAL(name) \
	.globl _ASM_LABEL(name); _ASM_LABEL(name):

#define	LOCAL(name) \
	_C_LABEL(name):

#define	ASLOCAL(name) \
	_ASM_LABEL(name):

#define	BSS(name, size) \
	.comm	_C_LABEL(name), size

#define	ASBSS(name, size) \
	.comm	_ASM_LABEL(name), size
d283 3
a285 3
#define DEBUG_197_READ_BIT    25    /* MVME197 Data Read Miss (Software Table Searches) */
#define DEBUG_197_WRITE_BIT   26    /* MVME197 Data Write Miss (Software Table Searches) */
#define DEBUG_197_INST_BIT    27    /* MVME197 Inst ATC Miss (Software Table Searches) */
d321 1
a321 1
#endif /* __MACHINE_M88K_ASM_H__ */
@


1.6.4.4
log
@Merge in -current
@
text
@d139 1
a139 2
#define	FLUSH_PIPELINE		tcnd	ne0, r0, 0
#define	FLUSH_PIPELINE_STRING	"tcnd	ne0, r0, 0"
d141 1
a141 2
#define	FLUSH_PIPELINE		tb1	0, r0, 0
#define	FLUSH_PIPELINE_STRING	"tb1	0, r0, 0"
d143 1
a143 2
#define	NOP			or	r0, r0, r0
#define	NOP_STRING		"or	r0, r0, r0"
@


1.6.4.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: asm.h,v 1.6.4.4 2001/11/13 21:04:15 niklas Exp $	*/
d65 24
a88 35
#define	PANIC(message) \
	or.u	r2, r0, hi16(9f); \
	bsr.n	_C_LABEL(panic); \
	or	r2, r2, lo16(9f); \
9: \
	.string	message

#ifdef _KERNEL

/*
 * Control register symbolic names
 */

#define	PID	cr0
#define	PSR	cr1
#define	EPSR	cr2
#define	SSBR	cr3
#define	SXIP	cr4
#define	SNIP	cr5
#define	SFIP	cr6
#define	VBR	cr7
#define	DMT0	cr8
#define	DMD0	cr9
#define	DMA0	cr10
#define	DMT1	cr11
#define	DMD1	cr12
#define	DMA1	cr13
#define	DMT2	cr14
#define	DMD2	cr15
#define	DMA2	cr16
#define	SRX	cr16 
#define	SR0	cr17
#define	SR1	cr18
#define	SR2	cr19
#define	SR3	cr20
d91 27
a117 27
#define	SRX	cr16 
#define	EXIP	cr4
#define	ENIP	cr5
#define	ICMD	cr25
#define	ICTL	cr26
#define	ISAR	cr27
#define	ISAP	cr28
#define	IUAP	cr29
#define	IIR	cr30
#define	IBP	cr31
#define	IPPU	cr32
#define	IPPL	cr33
#define	ISR	cr34
#define	ILAR	cr35
#define	IPAR	cr36
#define	DCMD	cr40
#define	DCTL	cr41
#define	DSAR	cr42
#define	DSAP	cr43
#define	DUAP	cr44
#define	DIR	cr45
#define	DBP	cr46
#define	DPPU	cr47
#define	DPPL	cr48
#define	DSR	cr49
#define	DLAR	cr50
#define	DPAR	cr51
d120 11
a130 11
#define	FPECR	fcr0
#define	FPHS1	fcr1
#define	FPLS1	fcr2
#define	FPHS2	fcr3
#define	FPLS2	fcr4
#define	FPPT	fcr5
#define	FPRH	fcr6
#define	FPRL	fcr7
#define	FPIT	fcr8
#define	FPSR	fcr62
#define	FPCR	fcr63
a147 2
#define RTE	NOP ; rte

d152 6
a157 6
#define CALL(NAME, ARG1, ARG2) \
	subu	r31, r31, 32; \
	or	r2, r0, ARG1; \
	bsr.n	NAME; \
	or	r3, r0, ARG2; \
	addu	r31, r31, 32
d160 24
a183 8
#define CALLP(NAME, ARG1, ARG2) \
	subu	r31, r31, 32; \
	or.u	r5, r0, hi16(NAME); \
	ld	r4, r5, lo16(NAME); \
	or	r2, r0, ARG1; \
	jsr.n	r4; \
	or	r3, r0, ARG2; \
	addu	r31, r31, 32
d230 8
a237 8
#define	FLAGS	r2
#define	TMP	r3
#define	TMP2	r10
#define	TMP3	r11
#define	SAVE_TMP2	st	r10, r31, GENREG_OFF(10)
#define	SAVE_TMP3	st	r11, r31, GENREG_OFF(11)
#define	RESTORE_TMP2	ld	r10, r31, GENREG_OFF(10)
#define	RESTORE_TMP3	ld	r11, r31, GENREG_OFF(11)
d242 5
a246 5
#define	PSR_SHADOW_FREEZE_BIT		0
#define	PSR_INTERRUPT_DISABLE_BIT	1
#define	PSR_FPU_DISABLE_BIT		3
#define	PSR_BIG_ENDIAN_MODE		30
#define	PSR_SUPERVISOR_MODE_BIT		31
d251 2
a252 2
#define	RTE_VALID_BIT		1
#define	RTE_ERROR_BIT		0
d257 7
a263 7
#define	DMT_VALID_BIT		0
#define	DMT_WRITE_BIT		1
#define	DMT_LOCK_BIT		12
#define	DMT_DOUBLE_BIT		13
#define	DMT_DAS_BIT		14
#define	DMT_DREG_OFFSET		7
#define	DMT_DREG_WIDTH		5
d268 40
a307 33
#define	DEBUG_INTERRUPT_BIT		0
#define	DEBUG_DATA_BIT			1
#define	DEBUG_INSTRUCTION_BIT		2
#define	DEBUG_MISALIGN_BIT		3
#define	DEBUG_UNIMP_BIT			4
#define	DEBUG_DIVIDE_BIT		5
#define	DEBUG_OF_BIT			6
#define	DEBUG_FPp_BIT			7
#define	DEBUG_FPi_BIT			8
#define	DEBUG_SYSCALL_BIT	 	9
#define	DEBUG_MACHSYSCALL_BIT		10
#define	DEBUG_UNIMPLEMENTED_BIT		11
#define	DEBUG_PRIVILEGE_BIT		12
#define	DEBUG_BOUNDS_BIT		13
#define	DEBUG_OVERFLOW_BIT		14
#define	DEBUG_ERROR_BIT			15
#define	DEBUG_SIGSYS_BIT		16
#define	DEBUG_SIGTRAP_BIT		17
#define	DEBUG_BREAK_BIT			18
#define	DEBUG_TRACE_BIT			19
#define	DEBUG_KDB_BIT			20
#define	DEBUG_JKDB_BIT			21
#define	DEBUG_BUGCALL_BIT		22
/* MVME197 Non-Maskable Interrupt */
#define	DEBUG_NON_MASK_BIT		23
/* MVME197 Data Read Miss (Software Table Searches) */
#define	DEBUG_197_READ_BIT		25
/* MVME197 Data Write Miss (Software Table Searches) */
#define	DEBUG_197_WRITE_BIT		26
/* MVME197 Inst ATC Miss (Software Table Searches) */
#define	DEBUG_197_INST_BIT		27

#define	DEBUG_UNKNOWN_BIT		31
d310 2
a311 1
 * These things for locore_c_routines.c and locore.S
d313 1
a313 2
#define	PREDEFINED_BY_ROM	0xffffffff
#define	END_OF_VECTOR_LIST	0xfffffffe
d315 14
a328 1
#endif	/* _KERNEL */
@


1.6.4.6
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d65 7
a243 7
/* 
 * mc88110 PSR bit definitions (MVME197) 
 */
#define PSR_GRAPHICS_DISABLE_BIT	4
#define PSR_SERIAL_MODE_BIT		29
#define PSR_CARRY_BIT			28
#define PSR_SERIALIZE_BIT		25
@


1.6.4.7
log
@Sync the SMP branch with 3.3
@
text
@a64 16
#ifdef	__ELF__
#define	WEAK_ALIAS(alias,sym)						\
	.weak alias;							\
	alias = sym
#else
#ifdef	__STDC__
#define	WEAK_ALIAS(alias,sym)						\
	.weak _##alias;							\
	_##alias = _##sym
#else
#define	WEAK_ALIAS(alias,sym)						\
	.weak _/**/alias;						\
	_/**/alias = _/**/sym
#endif
#endif

d88 1
d95 1
a95 1
#define	SRX	cr16
d181 1
a181 1
 *
d230 1
a230 1
 * Info about the PSR
d237 2
a238 2
/*
 * mc88110 PSR bit definitions (MVME197)
d299 4
a302 2
/* exception vector marker */
#define	UNKNOWN_HANDLER		0xffffffff
a303 3

#define	VECTOR(x) \
	word	_C_LABEL(x)
@


1.6.4.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d171 1
d177 1
a177 1
	 or	r3, r0, ARG2; \
d187 1
a187 1
	 or	r3, r0, ARG2; \
d201 4
d213 7
a219 3
#define FLAG_IGNORE_DATA_EXCEPTION	5
#define FLAG_ENABLING_FPU		7
#define FLAG_FROM_KERNEL		8
d222 1
a222 1
#define REG_OFF(reg_num)  ((reg_num) * 4) /* (num * sizeof(register_t))  */
d224 4
@


1.6.4.9
log
@Merge with the trunk
@
text
@d1 310
a310 3
/* $OpenBSD$ */
/* public domain */
#include <m88k/asm.h>
@


1.5
log
@Commit for the first real OpenBSD mvme88k kernel.
@
text
@d66 2
a67 2
#define PID	cr0
#define PSR	cr1
d73 1
a73 1
#define VBR	cr7
d83 36
a118 4
#define SR0	cr17
#define SR1	cr18
#define SR2	cr19
#define SR3	cr20
d155 26
d203 8
a210 6
#define FLAG_CPU_FIELD_WIDTH		4	/* must be <= 12 */

#define FLAG_IGNORE_DATA_EXCEPTION	5	/* bit number 5 */
#define FLAG_INTERRUPT_EXCEPTION	6	/* bit number 6 */
#define FLAG_ENABLING_FPU		7	/* bit number 7 */

d265 13
a277 13
#define DEBUG_INTERRUPT_BIT		 0
#define DEBUG_DATA_BIT			 1
#define DEBUG_INSTRUCTION_BIT		 2
#define DEBUG_MISALIGN_BIT		 3
#define DEBUG_UNIMP_BIT			 4
#define DEBUG_DIVIDE_BIT		 5
#define DEBUG_OF_BIT			 6
#define DEBUG_FPp_BIT			 7
#define DEBUG_FPi_BIT			 8
#define DEBUG_SYSCALL_BIT	 	 9
#define DEBUG_MACHSYSCALL_BIT		10
#define DEBUG_UNIMPLEMENTED_BIT		11
#define DEBUG_PRIVILEGE_BIT		12
d288 4
d312 14
a325 6
#if !defined(CMMU_I)
#define CMMU_I	0xFFF77000
#endif
#if !defined(CMMU_D)
#define CMMU_D	0xFFF7F000
#endif
@


1.4
log
@Ok here is the mvme88k userland, minus a few important pieces.
as, ld change need to be merged. It is known that shared libraries and C++
do not work.
If anyone wants to step forward and take over the mvme88k port please do.
It was dumped on me when the original developer, Nivas, left his previous
job and started a new one.

I am trying to get the port in a shape that someone could take over.
@
text
@d39 1
a39 1
#define EH_DEBUG 0
d51 1
a51 1
#define  LABEL(name)	name:;  .globl name ;
d105 3
d109 1
@


1.3
log
@Cleanup after import. This also seems to bring up the current version.
@
text
@d42 1
d45 1
@


1.2
log
@This is a remove to get rid of the old mvme88k port which was incomplete
to replace it with a working version. The kernel compiles and works
at least.  The new version will be imported shortly.
@
text
@a26 39
/*
 * HISTORY
 * $Log: asm.h,v $
 * Revision 1.1  1995/10/18 10:54:22  deraadt
 * Initial revision
 *
 * Revision 2.3  93/01/26  18:05:05  danner
 * 	Added #ifndef file wrapper.
 * 	[93/01/24            jfriedl]
 * 
 * Revision 2.2  92/08/03  17:46:50  jfriedl
 * 	Brought to m88k directory.
 * 	[92/07/24            jfriedl]
 * 
 * Revision 2.1.1.1  92/05/27  15:24:16  danner
 * 	Move FLUSH_PIPELINE, REG_OFF definitions here.
 * 	[92/05/17            danner]
 * 
 * Revision 2.3  92/02/18  18:00:24  elf
 * 	Typo correction (from Torbjorn Granlund <tege@@sics.se>).
 * 	[92/02/06            danner]
 * 
 * 	moved RTE definition here
 * 	[92/02/02            danner]
 * 
 * Revision 2.2  91/07/09  23:16:20  danner
 * 	Initial 3.0 Checkin
 * 	[91/06/26  11:57:57  danner]
 * 
 * Revision 2.2  91/04/05  13:55:26  mbj
 * 	Initial code from the Omron 1.10 kernel release corresponding to X130.
 * 	The Copyright has been adjusted to correspond to the understanding
 * 	between CMU and the Omron Corporation.
 * 	[91/04/04            rvb]
 * 
 * 	Corrected ENTRY Macro to use NEWLINE instead of \\ Hack
 * 	[91/03/07            danner]
 * 
 */
a27 7
/*
 * 	File:	m88k/asm.h
 *
 *	This header file is intended to hold definitions useful for M88K
 *	assembly routines.
 *
 */
d31 4
a34 6
#ifndef prepend_underbar
#    ifdef __STDC__
#        define prepend_underbar(NAME) _##NAME
#    else
#        define prepend_underbar(NAME) _/**/NAME
#    endif
d37 8
d46 15
a60 1
    align 4 NEWLINE prepend_underbar(NAME): NEWLINE global prepend_underbar(NAME)
d62 1
a62 1
#define RTE	NOP NEWLINE rte
d99 1
a99 1
 * synchronize).  A "tcnd ne0, r0, foo" will do that (because a trap
d103 1
a103 1
#define FLUSH_PIPELINE	tcnd ne0, r0, 0
d106 40
d150 98
a247 4
#if !defined(LABEL)
#define  LABEL(name)	name: global name NEWLINE
#define _LABEL(name)	name:               NEWLINE
#endif /* LABEL */
@


1.1
log
@Initial revision
@
text
@d29 4
a32 1
 * $Log:	asm.h,v $
@


1.1.1.1
log
@initial 88k import; code by nivas and based on mach luna88k
@
text
@@


1.1.1.2
log
@Third try at importing the mvme88k port. This is a working kernel
from nivas.
Userland and compiler still need to be worked on.
Make certain what directory the import is done from.
@
text
@d27 36
d64 7
d74 6
a79 4
#ifdef __STDC__
#	define FUNC(NAME) _##NAME
#else
#	define FUNC(NAME) _/**/NAME
a81 8
/* Define EH_DEBUG to be non-zero to compile-in various debugging things */
#ifndef	EH_DEBUG
#define EH_DEBUG 0
#endif	EH_DEBUG

/* this gives the offsets into various structures of various elements, etc */
#include "assym.s"

d83 1
a83 2
    .align 8; .globl FUNC(NAME); FUNC(NAME):
    
d85 1
a85 14
#define  LABEL(name)	name:;  .globl name ;
/*
 * _LABEL(name)
 *	Defines one visible only to the file, unless debugging
 * 	is enabled, in which case it's visible to the world (and
 *	hence to debuggers, and such).
 */
#if EH_DEBUG
#  define _LABEL(name)	name:	.globl name ;
#else
#  define _LABEL(name)	name:               ;
#endif

#define RTE	NOP ; rte
d122 1
a122 1
 * synchronize).  A "tb1 0, r0, foo" will do that (because a trap
d126 1
a126 1
#define FLUSH_PIPELINE	tb1 0, r0, 0
a128 40
/*
 * Useful in some situations.
 * NOTE: If ARG1 or ARG2 are r2 or r3, strange things may happen.  Watch out!
 */
#define CALL(NAME, ARG1, ARG2)             \
  		subu	r31, r31, 32	; \
                or      r2, r0, ARG1    ; \
                bsr.n   NAME            ; \
                or      r3, r0, ARG2	; \
		addu	r31, r31, 32

/*
 * SR1 - CPU FLAGS REGISTER
 * XXX clean this when the trap handler is reworked. Among the things
 * I like to see is having the trap frame on the kernel stack instead
 * of putting in the PCB. If done properly, we don't need SR1 for doing
 * anything special. nivas
 * 
 * SR1 contains flags about the current CPU status.
 *
 * The bit FLAG_IGNORE_DATA_EXCEPTION indicates that any data exceptions
 * 	should be ignored (well, at least treated in a special way).
 * The bit FLAG_INTERRUPT_EXCEPTION indicates that the current exception
 * 	is the interrupt exception.  Such information can be gotten
 * 	in other ways, but having it in the flags makes it easy for the
 *	exception handler to check quickly.
 * The bit FLAG_ENABLING_FPU indicates that the exception handler is
 * 	in the process of enabling the FPU (so that an exception can
 * 	be serviced).  This is needed because enabling the FPU can
 *	cause other exceptions to happen, and the whole system is
 *	in a rather precarious state and so special cautions must
 * 	be taken.
 */
#define FLAG_CPU_FIELD_WIDTH		4	/* must be <= 12 */

#define FLAG_IGNORE_DATA_EXCEPTION	5	/* bit number 5 */
#define FLAG_INTERRUPT_EXCEPTION	6	/* bit number 6 */
#define FLAG_ENABLING_FPU		7	/* bit number 7 */


d133 4
a136 98

#define GENERAL_BREATHING_ROOM	/* arbitrarily */ 200
#define KERNEL_STACK_BREATHING_ROOM 	\
	(GENERAL_BREATHING_ROOM + SIZEOF_STRUCT_PCB + SIZEOF_STRUCT_UTHREAD)

/*
 * Some registers used during the setting up of the new exception frame.
 * Don't choose r1, r30, or r31 for any of them.
 *
 * Also, if any are 'r2' or 'r3', be careful using with CALL above!
 */
#define FLAGS	r2
#define TMP	r3
#define TMP2	r10
#define TMP3	r11
#define SAVE_TMP2	st	r10, r31, GENREG_OFF(10)
#define SAVE_TMP3	st	r11, r31, GENREG_OFF(11)
#define RESTORE_TMP2	ld	r10, r31, GENREG_OFF(10)
#define RESTORE_TMP3	ld	r11, r31, GENREG_OFF(11)

/*
 * Info about the PSR 
 */
#define PSR_SHADOW_FREEZE_BIT		 0
#define PSR_INTERRUPT_DISABLE_BIT	 1
#define PSR_FPU_DISABLE_BIT		 3
#define PSR_BIG_ENDIAN_MODE		30
#define PSR_SUPERVISOR_MODE_BIT		31

/*
 * Status bits for an SXIP/SNIP/SFIP address.
 */
#define RTE_VALID_BIT	 1
#define RTE_ERROR_BIT	 0

/*
 * Info about DMT0/DMT1/DMT2
 */
#define DMT_VALID_BIT	 0
#define DMT_WRITE_BIT 	 1
#define DMT_LOCK_BIT	12
#define DMT_DOUBLE_BIT	13
#define DMT_DAS_BIT     14
#define DMT_DREG_OFFSET	 7
#define DMT_DREG_WIDTH	 5

/*
 * Bits for eh_debug.
 */
#define DEBUG_INTERRUPT_BIT		 0
#define DEBUG_DATA_BIT			 1
#define DEBUG_INSTRUCTION_BIT		 2
#define DEBUG_MISALIGN_BIT		 3
#define DEBUG_UNIMP_BIT			 4
#define DEBUG_DIVIDE_BIT		 5
#define DEBUG_OF_BIT			 6
#define DEBUG_FPp_BIT			 7
#define DEBUG_FPi_BIT			 8
#define DEBUG_SYSCALL_BIT	 	 9
#define DEBUG_MACHSYSCALL_BIT		10
#define DEBUG_UNIMPLEMENTED_BIT		11
#define DEBUG_PRIVILEGE_BIT		12
#define DEBUG_BOUNDS_BIT		13
#define DEBUG_OVERFLOW_BIT		14
#define DEBUG_ERROR_BIT			15
#define DEBUG_SIGSYS_BIT		16
#define DEBUG_SIGTRAP_BIT		17
#define DEBUG_BREAK_BIT			18
#define DEBUG_TRACE_BIT			19
#define DEBUG_KDB_BIT			20
#define DEBUG_JKDB_BIT			21
#define DEBUG_BUGCALL_BIT		22

#define DEBUG_UNKNOWN_BIT		31

/*
 * These things for vector_init.c and locore.c
 */
#if defined(ASSEMBLER)
# define  PREDEFINED_BY_ROM       0xffffffff
# define  END_OF_VECTOR_LIST      0xfffffffe
#else
# define  PREDEFINED_BY_ROM       0xffffffffU
# define  END_OF_VECTOR_LIST      0xfffffffeU
#endif

/*
 * Define ERROR__XXX_USR if the xxx.usr bug (mask C82N) is present.
 * This implements the workaround.
 */
#define ERRATA__XXX_USR 	1

#if !defined(CMMU_I)
#define CMMU_I	0xFFF77000
#endif
#if !defined(CMMU_D)
#define CMMU_D	0xFFF7F000
#endif
@
