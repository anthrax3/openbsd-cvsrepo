head	1.28;
access;
symbols
	OPENBSD_5_5:1.27.0.42
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.27.0.38
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.27.0.36
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.34
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.32
	OPENBSD_5_0:1.27.0.30
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.27.0.28
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.26
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.27.0.22
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.27.0.24
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.27.0.20
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.27.0.18
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3:1.27.0.16
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.27.0.14
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.27.0.12
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.27.0.10
	OPENBSD_4_0_BASE:1.27
	OPENBSD_3_9:1.27.0.8
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.27.0.6
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.27.0.4
	OPENBSD_3_7_BASE:1.27
	OPENBSD_3_6:1.27.0.2
	OPENBSD_3_6_BASE:1.27
	SMP_SYNC_A:1.27
	SMP_SYNC_B:1.27
	OPENBSD_3_5:1.25.0.2
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	UBC_SYNC_A:1.18
	OPENBSD_3_3:1.18.0.2
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.17.0.4
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	UBC_SYNC_B:1.17
	UBC:1.14.0.2
	UBC_BASE:1.14
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.4.0.10
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.8
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.6
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.4
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	mvme88kport:1.1.1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	first_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.28
date	2014.03.18.22.36.36;	author miod;	state dead;
branches;
next	1.27;

1.27
date	2004.04.26.14.31.11;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2004.04.26.12.34.05;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2003.12.19.18.08.20;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2003.11.08.21.45.18;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2003.10.13.18.45.16;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2003.10.05.20.27.46;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2003.09.26.22.27.25;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2003.09.07.13.52.17;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.02.23.27.52;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2003.01.24.09.57.41;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.14.01.26.39;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.12.24.04.12.37;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.22.19.17.01;	author smurph;	state Exp;
branches;
next	1.14;

1.14
date	2001.12.16.23.49.46;	author miod;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2001.12.13.08.55.51;	author smurph;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.24.22.47.18;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.12.12.03.02;	author heko;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.07.23.57.58;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.27.04.29.19;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.14.21.30.40;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.09.05.44.40;	author smurph;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.14.20.25.24;	author smurph;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.13.05.18.59;	author smurph;	state Exp;
branches;
next	1.4;

1.4
date	99.02.09.06.36.27;	author smurph;	state Exp;
branches
	1.4.6.1;
next	1.3;

1.3
date	97.03.03.20.21.05;	author rahnds;	state Exp;
branches;
next	1.2;

1.2
date	97.03.03.19.07.36;	author rahnds;	state dead;
branches;
next	1.1;

1.1
date	95.10.18.10.54.22;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.10.54.22;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.03.03.19.31.25;	author rahnds;	state Exp;
branches;
next	;

1.4.6.1
date	2001.04.18.16.11.22;	author niklas;	state Exp;
branches;
next	1.4.6.2;

1.4.6.2
date	2001.07.04.10.20.03;	author niklas;	state Exp;
branches;
next	1.4.6.3;

1.4.6.3
date	2001.10.31.03.01.19;	author nate;	state Exp;
branches;
next	1.4.6.4;

1.4.6.4
date	2002.03.06.02.04.44;	author niklas;	state Exp;
branches;
next	1.4.6.5;

1.4.6.5
date	2002.03.28.10.36.02;	author niklas;	state Exp;
branches;
next	1.4.6.6;

1.4.6.6
date	2002.03.29.23.46.49;	author niklas;	state Exp;
branches;
next	1.4.6.7;

1.4.6.7
date	2003.03.27.23.32.18;	author niklas;	state Exp;
branches;
next	1.4.6.8;

1.4.6.8
date	2003.06.07.11.13.17;	author ho;	state Exp;
branches;
next	1.4.6.9;

1.4.6.9
date	2004.02.19.10.49.07;	author niklas;	state Exp;
branches;
next	1.4.6.10;

1.4.6.10
date	2004.06.05.23.09.50;	author niklas;	state Exp;
branches;
next	;

1.14.2.1
date	2002.01.31.22.55.18;	author niklas;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2002.06.11.03.37.10;	author art;	state Exp;
branches;
next	1.14.2.3;

1.14.2.3
date	2003.05.19.21.45.53;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/* $OpenBSD: mmu.h,v 1.27 2004/04/26 14:31:11 miod Exp $ */
/* public domain */
#include <m88k/mmu.h>
@


1.27
log
@Fix RCSID
@
text
@d1 1
a1 1
/* $OpenBSD$ */
@


1.26
log
@Start factorizing luna88k and mvme88k common parts.
For now, include files only.
@
text
@d1 1
a1 1
/* $OpenBSD */
@


1.25
log
@When temporarily unlocking a pmap, do not release the spl as well.
While there, get rid of that ugly PT_FREE() macro.
@
text
@d1 3
a3 252
/*	$OpenBSD: mmu.h,v 1.24 2003/11/08 21:45:18 miod Exp $ */

/*
 * This file bears almost no resemblance to the original m68k file,
 * so the following copyright notice is questionable, but we are
 * nice people.
 */

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: pte.h 1.13 92/01/20$
 *
 *	@@(#)pte.h	8.1 (Berkeley) 6/10/93
 */

#ifndef	_MACHINE_MMU_H_
#define	_MACHINE_MMU_H_

/*
 * Parameters which determine the 'geometry' of the m88K page tables in memory.
 */

#define SDT_BITS	10		/* M88K segment table size bits */
#define PDT_BITS	10		/* M88K page table size bits */
#define PG_BITS		PAGE_SHIFT	/* M88K hardware page size bits */

/*
 * Common fields for APR, SDT and PTE
 */

/* address frame */
#define	PG_FRAME	0xfffff000
#define	PG_SHIFT	PG_BITS
#define	PG_PFNUM(x)	(((x) & PG_FRAME) >> PG_SHIFT)

/* cache control bits */
#define	CACHE_DFL	0x00000000
#define	CACHE_INH	0x00000040	/* cache inhibit */
#define	CACHE_GLOBAL	0x00000080	/* global scope */
#define	CACHE_WT	0x00000200	/* write through */

#define	CACHE_MASK	(CACHE_INH | CACHE_GLOBAL | CACHE_WT)

/*
 * Area descriptors
 */

#define	APR_V		0x00000001	/* valid bit */

/*
 * 88200 PATC (TLB)
 */

#define PATC_ENTRIES	56

/*
 * BATC entries
 */

#define	BATC_V		0x00000001
#define	BATC_PROT	0x00000002
#define	BATC_INH	0x00000004
#define	BATC_GLOBAL	0x00000008
#define	BATC_WT		0x00000010
#define	BATC_SO		0x00000020


/*
 * Segment table entries
 */

typedef u_int32_t	sdt_entry_t;

#define	SDT_ENTRY_NULL	((sdt_entry_t *) 0)

#define	SG_V		0x00000001
#define	SG_NV		0x00000000
#define	SG_PROT		0x00000004
#define	SG_RO		0x00000004
#define	SG_RW		0x00000000
#define	SG_SO		0x00000100

#define	SDT_VALID(sdt)	(*(sdt) & SG_V)
#define	SDT_SUP(sdt)	(*(sdt) & SG_SO)
#define	SDT_WP(sdt)	(*(sdt) & SG_PROT)

/*
 * Page table entries
 */

typedef u_int32_t	pt_entry_t;

#define	PT_ENTRY_NULL	((pt_entry_t *) 0)

#define	PG_V		0x00000001
#define	PG_NV		0x00000000
#define	PG_PROT		0x00000004
#define	PG_U		0x00000008
#define	PG_M		0x00000010
#define	PG_RO		0x00000004
#define	PG_RW		0x00000000
#define	PG_SO		0x00000100
#define	PG_W		0x00000020	/* XXX unused but reserved field */
#define	PG_U0		0x00000400	/* U0 bit for M88110 */
#define	PG_U1		0x00000800	/* U1 bit for M88110 */

#define	PDT_VALID(pte)	(*(pte) & PG_V)
#define	PDT_SUP(pte)	(*(pte) & PG_SO)
#define	PDT_WP(pte)	(*(pte) & PG_PROT)

/*
 * Indirect descriptors (mc81110)
 */

typedef	u_int32_t	pt_ind_entry_t;

/* validity bits */
#define	IND_V		0x00000001
#define	IND_NV		0x00000000
#define	IND_MASKED	0x00000002
#define	IND_UNMASKED	0x00000003
#define	IND_MASK	0x00000003

#define	IND_FRAME	0xfffffffc
#define	IND_SHIFT	2

#define	IND_PDA(x)	((x) & IND_FRAME >> IND_SHIFT)

/*
 * Number of entries in a page table.
 */

#define	SDT_ENTRIES	(1<<(SDT_BITS))
#define PDT_ENTRIES	(1<<(PDT_BITS))

/*
 * Size in bytes of a single page table.
 */

#define SDT_SIZE	(sizeof(sdt_entry_t) * SDT_ENTRIES)
#define PDT_SIZE	(sizeof(pt_entry_t) * PDT_ENTRIES)

/*
 * Shifts and masks
 */

#define SDT_SHIFT	(PDT_BITS + PG_BITS)
#define PDT_SHIFT	(PG_BITS)

#define SDT_MASK	(((1 << SDT_BITS) - 1) << SDT_SHIFT)
#define PDT_MASK	(((1 << PDT_BITS) - 1) << PDT_SHIFT)

#define	SDTIDX(va)	(((va) & SDT_MASK) >> SDT_SHIFT)
#define	PDTIDX(va)	(((va) & PDT_MASK) >> PDT_SHIFT)

/* XXX uses knowledge of pmap structure */
#define SDTENT(map, va)	((sdt_entry_t *)((map)->pm_stab + SDTIDX(va)))

/*
 * Va spaces mapped by tables and PDT table group.
 */

#define PDT_VA_SPACE			(PDT_ENTRIES * PAGE_SIZE)

/*
 * Number of sdt entries used to map user and kernel space.
 */

#define USER_SDT_ENTRIES	SDTIDX(VM_MIN_KERNEL_ADDRESS)
#define KERNEL_SDT_ENTRIES	(SDT_ENTRIES - USER_SDT_ENTRIES)

/*
 * Parameters and macros for BATC
 */

/* number of bits to BATC shift (log2(BATC_BLKBYTES)) */
#define BATC_BLKSHIFT	19
/* 'block' size of a BATC entry mapping */
#define BATC_BLKBYTES	(1 << BATC_BLKSHIFT)
/* BATC block mask */
#define BATC_BLKMASK	(BATC_BLKBYTES-1)
/* number of BATC entries */
#define BATC_MAX	8

/* physical and logical block address */
#define	BATC_PSHIFT	6
#define	BATC_VSHIFT	(BATC_PSHIFT + (32 - BATC_BLKSHIFT))

#define BATC_BLK_ALIGNED(x)	((x & BATC_BLKMASK) == 0)

#define M88K_BTOBLK(x)	(x >> BATC_BLKSHIFT)

/*
 * DMA and caching control
 */
#define DMA_CACHE_SYNC		0x1
#define DMA_CACHE_SYNC_INVAL	0x2
#define DMA_CACHE_INV		0x3

static pt_entry_t invalidate_pte(pt_entry_t *);
static __inline__ pt_entry_t
invalidate_pte(pt_entry_t *pte)
{
	pt_entry_t oldpte;

	oldpte = PG_NV;
	__asm__ __volatile__
	    ("xmem %0, %2, r0" : "=r"(oldpte) : "0"(oldpte), "r"(pte));
	__asm__ __volatile__ ("tb1 0, r0, 0");
	return oldpte;
}

extern vaddr_t kmapva;

#define kvtopte(va)	\
	((pt_entry_t *)(PG_PFNUM(*((sdt_entry_t *)kmapva + \
	    SDTIDX(va) + SDT_ENTRIES)) << PDT_SHIFT) + PDTIDX(va))

u_int kvtop(vaddr_t);

#endif /* __MACHINE_MMU_H__ */
@


1.24
log
@Inline invalidate_pte().
@
text
@d1 1
a1 1
/*	$OpenBSD: mmu.h,v 1.23 2003/10/13 18:45:16 miod Exp $ */
a188 2

#define PT_FREE(tbl)	uvm_km_free(kernel_map, (vaddr_t)tbl, PAGE_SIZE)
@


1.23
log
@Get rid of the "page table group" stuff. "groups" used to be one logical page
big anyways.

However, getting rid of the various constants (expanding to 0 for logs and
shifts, and 1 for size) allows us to do further simplifications in some pmap
loops, as there is no risk anymore of address wrapround.

While there, fix some typos and comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: mmu.h,v 1.22 2003/10/05 20:27:46 miod Exp $ */
d233 12
a244 1
pt_entry_t invalidate_pte(pt_entry_t *);
@


1.22
log
@Kill vm_offset_t and vm_size_t, in favor of the [pv]addr_t and [pv]size_t
typedefs.
@
text
@d1 1
a1 1
/*	$OpenBSD: mmu.h,v 1.21 2003/09/26 22:27:25 miod Exp $ */
d181 2
a182 5
#define SDT_MASK	(((1<<SDT_BITS)-1) << SDT_SHIFT)
#define PDT_MASK	(((1<<PDT_BITS)-1) << PDT_SHIFT)

#define SDT_NEXT(va)	(((va) + (1<<SDT_SHIFT)) & SDT_MASK)
#define PDT_NEXT(va)	(((va) + (1<<PDT_SHIFT)) & (SDT_MASK|PDT_MASK))
a189 8
/*
 * Size of a PDT table group.
 */

#define LOG2_PDT_SIZE			(PDT_BITS + 2)
#define LOG2_PDT_TABLE_GROUP_SIZE	(PAGE_SHIFT - LOG2_PDT_SIZE)
#define PDT_TABLE_GROUP_SIZE		(1 << LOG2_PDT_TABLE_GROUP_SIZE)

a196 1
#define PDT_TABLE_GROUP_VA_SPACE	(PDT_VA_SPACE * PDT_TABLE_GROUP_SIZE)
a243 1

@


1.21
log
@Death to the bitfields, this time cmmu_apr_t and batc_entry_t. In the
process, remove duplicate batc defines.
@
text
@d1 1
a1 1
/*	$OpenBSD: mmu.h,v 1.20 2003/09/07 13:52:17 miod Exp $ */
d175 1
a175 1
 * Shifts and masks 
d245 1
a245 1
void dma_cachectl(vm_offset_t, int, int);
d247 1
a247 3
unsigned invalidate_pte(pt_entry_t *);

extern vm_offset_t kmapva;
d253 1
a253 1
u_int kvtop(vm_offset_t);
@


1.20
log
@The PTE bit used to flag wiring is zeroed behind our back on 88110, so
switch to another, safe, unused bit.

From the MC88110UM via deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mmu.h,v 1.19 2003/06/02 23:27:52 millert Exp $ */
d68 4
a71 4
#define	CACHE_DFL	0x0000000
#define	CACHE_INH	0x0000040	/* cache inhibit */
#define	CACHE_GLOBAL	0x0000080	/* global scope */
#define	CACHE_WT	0x0000200	/* write through */
d73 1
a73 1
#define	CACHE_MASK	(~(CACHE_INH | CACHE_GLOBAL | CACHE_WT))
d79 1
a79 16
typedef struct cmmu_apr {
	unsigned long
			st_base:20,	/* segment table base address */
			rsvA:2,		/* reserved */
			wt:1,		/* writethrough (cache control) */
			rsvB:1,		/* reserved */
			g:1,		/* global (cache control) */
			ci:1,		/* cache inhibit */
			rsvC:5,		/* reserved */
			te:1;		/* translation enable */
} cmmu_apr_t;

typedef union apr_template {
	cmmu_apr_t	field;
	unsigned long	bits;
} apr_template_t;
d91 7
a97 16
typedef struct {
	unsigned long
			lba:13,		/* logical block address */
			pba:13,		/* physical block address */
			sup:1,		/* supervisor mode bit */
			wt:1,		/* writethrough (cache control) */
			g:1,		/* global (cache control) */
			ci:1,		/* cache inhibit */
			wp:1,		/* write protect */
			v:1;		/* valid */
} batc_entry_t;

typedef union batc_template {
	batc_entry_t	field;
	unsigned long	bits;
} batc_template_t;
d230 4
a245 9

/*
 * Alignment checks for pages (must lie on page boundaries).
 */

#define PAGE_ALIGNED(ad)	(((vm_offset_t)(ad) & PAGE_MASK) == 0)
#define	CHECK_PAGE_ALIGN(ad,who)	\
    if (!PAGE_ALIGNED(ad))		\
    	printf("%s: addr  %x not page aligned.\n", who, ad)
@


1.19
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: mmu.h,v 1.18 2003/01/24 09:57:41 miod Exp $ */
d158 2
a159 1
#define	PG_W		0x00000400	/* XXX unused but reserved field */
@


1.18
log
@Convert m88k pmap from physseg to VM_PAGE_MD.

This allows us to remove some ambiguities on how some functions are called,
remove some diagnostic checks for conditions that can never happen and
remove the ugly hack with "pmap_initialized".

Then, rework internal function interfaces and some logic so as to stop
fetching vm_page from a pa and the reverse every now and then - this makes
some pmap operations run much faster.

While there, various KNF and whitespace fixes, and rename some structure
fields to be closer to the m68k pmap.

per art@@'s idea.
@
text
@d1 1
a1 1
/*	$OpenBSD: mmu.h,v 1.17 2002/03/14 01:26:39 millert Exp $ */
d26 1
a26 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.17
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: mmu.h,v 1.16 2001/12/24 04:12:37 miod Exp $ */
d218 1
a218 1
#define SDTENT(map, va)	((sdt_entry_t *)((map)->sdt_vaddr + SDTIDX(va)))
@


1.16
log
@- completely change the mmu segment and page table structure definitions,
to use constant bitmasks instead of bitfields.
- remove unnecessary (as long as we are not running SMP) locks on the
physsegs.
- update the pmap code to take these changes into account, and gratuitously
change several names and code paths to be closer to existing m68k pmaps. It's
a bit faster now.
- change pmap.c's usage of vm_{offset,size}_t to {p,v}{addr,size}_t.
- remove dead or unused stuff from pmap.c, fix typos, etc

Tested on 187 and 188, should not make things worse for 197.
@
text
@d1 1
a1 1
/*	$OpenBSD: mmu.h,v 1.15 2001/12/22 19:17:01 smurph Exp $ */
d268 1
a268 1
void dma_cachectl __P((vm_offset_t, int, int));
d279 1
a279 1
unsigned invalidate_pte __P((pt_entry_t *));
d287 1
a287 1
u_int kvtop __P((vm_offset_t));
@


1.15
log
@mc88110 mods.
@
text
@d1 1
a1 1
/*	$OpenBSD: mmu.h,v 1.14 2001/12/16 23:49:46 miod Exp $ */
d3 50
a52 2
#ifndef	__MACHINE_MMU_H__
#define	__MACHINE_MMU_H__
d55 1
a55 1
 * Parameters which determine the 'geometry' of the M88K page tables in memory.
d57 3
a59 2
#define SDT_BITS	10	/* M88K segment table size bits */
#define PDT_BITS	10	/* M88K page table size bits */
d63 18
a80 1
 * M88K area descriptors
d82 1
a100 57
 * M88K segment descriptors
 */
typedef struct sdt_entry {
	unsigned long
			table_addr:20,	/* page table base address */
			rsvA:2,		/* reserved */
			wt:1,		/* writethrough (cache control) */
			sup:1,		/* supervisor protection */
			g:1,		/* global (cache control) */
			no_cache:1,	/* cache inhibit */
			rsvB:3,		/* reserved */
			prot:1,		/* write protect */
			rsvC:1,		/* reserved */
			dtype:1;	/* valid */
} sdt_entry_t;

typedef union sdt_entry_template {
	sdt_entry_t	sdt_desc;
	unsigned long	bits;
} sdt_entry_template_t;

#define SDT_ENTRY_NULL	((sdt_entry_t *) 0)
	    
/*
 * M88K page descriptors
 */
typedef struct pt_entry {
	unsigned long
			pfn:20,		/* page frame address */
			rsvA:1,		/* reserved (U1 on mc88110) */
			wired:1,	/* wired bit <<software>> */
			wt:1,		/* writethrough (cache control) */
			sup:1,		/* supervisor protection */
			g:1,		/* global (cache control) */
			ci:1,		/* cache inhibit */
			rsvB:1,		/* reserved */
			modified:1,	/* modified */
			pg_used:1,	/* used (referenced) */
			prot:1,		/* write protect */
			dtype:2;	/* descriptor type (bit 2 only on mc88110) */
} pt_entry_t;

/* mc88110 indirect descriptors */
typedef struct pt_ind_entry {
	unsigned long
			pda:30,		/* page descriptor address */
			dtype:2;	/* valid */
} pt_ind_entry_t;

typedef union pte_template {
	pt_entry_t	pte;
	unsigned long	bits;
} pte_template_t;

#define PT_ENTRY_NULL	((pt_entry_t *) 0)

/*
d107 1
a107 1
 * M88K BATC entries
d109 1
d128 1
a128 1
 * Parameters and macros for BATC
a129 3
#define BATC_BLKBYTES	(512*1024)	/* 'block' size of a BATC entry mapping */
#define BATC_BLKSHIFT	19		/* number of bits to BATC shift (log2(BATC_BLKBYTES)) */
#define BATC_BLKMASK	(BATC_BLKBYTES-1)	/* BATC block mask */
d131 1
a131 1
#define BATC_MAX	8		/* number of BATC entries */
d133 8
a140 1
#define BATC_BLK_ALIGNED(x)	((x & BATC_BLKMASK) == 0)
d142 3
a144 1
#define M88K_BTOBLK(x)	(x >> BATC_BLKSHIFT)
d147 1
a147 1
 * protection codes (prot field)
d149 19
a167 2
#define M88K_RO		1	/* read only */
#define M88K_RW		0	/* read/write */
d170 1
a170 1
 * protection codes (sup field)
a171 2
#define M88K_SUPV	1	/* translation can only be done in supervisor mode */
#define M88K_USER	0	/* translation can be done supv. or user mode */
d173 13
a185 7
/*
 * descriptor types
 */
#define DT_INVALID	0
#define DT_VALID	1
#define DT_IND_MASKED	2
#define DT_IND_UMASKED	3
d190 1
d197 1
d204 1
d211 2
a212 2
#define SDT_NEXT(va)	((va + (1<<SDT_SHIFT)) & SDT_MASK)
#define PDT_NEXT(va)	((va + (1<<PDT_SHIFT)) & (SDT_MASK|PDT_MASK))
d214 2
a215 2
#define	SDTIDX(va)	((va & SDT_MASK) >> SDT_SHIFT)
#define	PDTIDX(va)	((va & PDT_MASK) >> PDT_SHIFT)
d217 2
a218 1
#define SDTENT(map, va)	((sdt_entry_t *)(map->sdt_vaddr + SDTIDX(va)))
d223 1
d227 1
a229 1

d233 1
d240 1
d245 1
a245 1
 * Macros to check if the descriptor is valid.
a246 2
#define SDT_VALID(sd_ptr)	((sd_ptr)->dtype == DT_VALID)
#define PDT_VALID(pd_ptr)	((pd_ptr)->dtype == DT_VALID)
d248 12
a259 7
/*
 * Alignment checks for pages (must lie on page boundaries).
 */
#define PAGE_ALIGNED(ad)	(((vm_offset_t)(ad) & PAGE_MASK) == 0)
#define	CHECK_PAGE_ALIGN(ad,who)	\
    if (!PAGE_ALIGNED(ad))		\
    	printf("%s: addr  %x not page aligned.\n", who, ad)
d262 1
a262 1
 * Parameters for ATC(TLB) fulsh
d264 3
d268 1
a268 8
#define CMMU_SCR	0x004

#define FLUSH_SUP_ALL	0x37
#define FLUSH_USR_ALL	0x33
#define FLUSH_SUP_SEG	0x36
#define FLUSH_USR_SEG	0x32
#define FLUSH_SUP_PG	0x35
#define FLUSH_USR_PG	0x31
d271 1
a271 1
 * Cache coontrol bits for pte
a272 4
#define CACHE_DFL	0
#define CACHE_INH	0x40
#define CACHE_GLOBAL	0x80
#define CACHE_WT	0x200
d274 4
a277 1
#define CACHE_MASK	(~(unsigned)(CACHE_INH | CACHE_GLOBAL | CACHE_WT))
d279 1
a279 4
/*
 * Prototype for invalidate_pte found in locore_asm_routines.S
 */
unsigned invalidate_pte(pt_entry_t *pointer);
d284 2
a285 6
({ 									\
	sdt_entry_t *sdt; 						\
	sdt = (sdt_entry_t *)kmapva + SDTIDX(va) + SDT_ENTRIES;		\
	(pte_template_t *)(sdt->table_addr << PDT_SHIFT) + PDTIDX(va);	\
})
extern u_int kvtop __P((vm_offset_t));
d287 1
a287 3
#define DMA_CACHE_SYNC		0x1
#define DMA_CACHE_SYNC_INVAL	0x2
#define DMA_CACHE_INV		0x3
@


1.14
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: mmu.h,v 1.12 2001/08/24 22:47:18 miod Exp $ */
d63 1
a63 1
			rsvA:1,		/* reserved */
d73 1
a73 2
			rsvC:1,		/* reserved */
			dtype:1;	/* valid */
d76 7
d146 2
a253 1
extern void dma_cachectl(vm_offset_t, int, int);
@


1.14.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: mmu.h,v 1.16 2001/12/24 04:12:37 miod Exp $ */
d3 2
a4 5
/*
 * This file bears almost no resemblance to the original m68k file,
 * so the following copyright notice is questionable, but we are
 * nice people.
 */
d7 1
a7 46
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: pte.h 1.13 92/01/20$
 *
 *	@@(#)pte.h	8.1 (Berkeley) 6/10/93
 */

#ifndef	_MACHINE_MMU_H_
#define	_MACHINE_MMU_H_

/*
 * Parameters which determine the 'geometry' of the m88K page tables in memory.
d9 2
a10 3

#define SDT_BITS	10		/* M88K segment table size bits */
#define PDT_BITS	10		/* M88K page table size bits */
d14 1
a14 18
 * Common fields for APR, SDT and PTE
 */

/* address frame */
#define	PG_FRAME	0xfffff000
#define	PG_SHIFT	PG_BITS
#define	PG_PFNUM(x)	(((x) & PG_FRAME) >> PG_SHIFT)

/* cache control bits */
#define	CACHE_DFL	0x0000000
#define	CACHE_INH	0x0000040	/* cache inhibit */
#define	CACHE_GLOBAL	0x0000080	/* global scope */
#define	CACHE_WT	0x0000200	/* write through */

#define	CACHE_MASK	(~(CACHE_INH | CACHE_GLOBAL | CACHE_WT))

/*
 * Area descriptors
a15 1

d34 51
d91 1
a91 1
 * BATC entries
a92 1

d111 1
a111 1
 * Segment table entries
d113 3
d117 1
a117 1
typedef u_int32_t	sdt_entry_t;
d119 1
a119 1
#define	SDT_ENTRY_NULL	((sdt_entry_t *) 0)
d121 1
a121 6
#define	SG_V		0x00000001
#define	SG_NV		0x00000000
#define	SG_PROT		0x00000004
#define	SG_RO		0x00000004
#define	SG_RW		0x00000000
#define	SG_SO		0x00000100
d123 5
a127 3
#define	SDT_VALID(sdt)	(*(sdt) & SG_V)
#define	SDT_SUP(sdt)	(*(sdt) & SG_SO)
#define	SDT_WP(sdt)	(*(sdt) & SG_PROT)
d130 1
a130 1
 * Page table entries
d132 2
a133 19

typedef u_int32_t	pt_entry_t;

#define	PT_ENTRY_NULL	((pt_entry_t *) 0)

#define	PG_V		0x00000001
#define	PG_NV		0x00000000
#define	PG_PROT		0x00000004
#define	PG_U		0x00000008
#define	PG_M		0x00000010
#define	PG_RO		0x00000004
#define	PG_RW		0x00000000
#define	PG_SO		0x00000100
#define	PG_W		0x00000400	/* XXX unused but reserved field */
#define	PG_U1		0x00000800	/* U1 bit for M88110 */

#define	PDT_VALID(pte)	(*(pte) & PG_V)
#define	PDT_SUP(pte)	(*(pte) & PG_SO)
#define	PDT_WP(pte)	(*(pte) & PG_PROT)
d136 1
a136 1
 * Indirect descriptors (mc81110)
d138 2
a139 14

typedef	u_int32_t	pt_ind_entry_t;

/* validity bits */
#define	IND_V		0x00000001
#define	IND_NV		0x00000000
#define	IND_MASKED	0x00000002
#define	IND_UNMASKED	0x00000003
#define	IND_MASK	0x00000003

#define	IND_FRAME	0xfffffffc
#define	IND_SHIFT	2

#define	IND_PDA(x)	((x) & IND_FRAME >> IND_SHIFT)
a143 1

a149 1

a155 1

d162 2
a163 2
#define SDT_NEXT(va)	(((va) + (1<<SDT_SHIFT)) & SDT_MASK)
#define PDT_NEXT(va)	(((va) + (1<<PDT_SHIFT)) & (SDT_MASK|PDT_MASK))
d165 2
a166 2
#define	SDTIDX(va)	(((va) & SDT_MASK) >> SDT_SHIFT)
#define	PDTIDX(va)	(((va) & PDT_MASK) >> PDT_SHIFT)
d168 1
a168 2
/* XXX uses knowledge of pmap structure */
#define SDTENT(map, va)	((sdt_entry_t *)((map)->sdt_vaddr + SDTIDX(va)))
a172 1

d176 1
a177 1
#define PT_FREE(tbl)	uvm_km_free(kernel_map, (vaddr_t)tbl, PAGE_SIZE)
a181 1

a187 1

d192 7
a198 1
 * Parameters and macros for BATC
d200 4
d205 3
a207 8
/* number of bits to BATC shift (log2(BATC_BLKBYTES)) */
#define BATC_BLKSHIFT	19
/* 'block' size of a BATC entry mapping */
#define BATC_BLKBYTES	(1 << BATC_BLKSHIFT)
/* BATC block mask */
#define BATC_BLKMASK	(BATC_BLKBYTES-1)
/* number of BATC entries */
#define BATC_MAX	8
d209 1
a209 1
#define BATC_BLK_ALIGNED(x)	((x & BATC_BLKMASK) == 0)
d211 6
a216 1
#define M88K_BTOBLK(x)	(x >> BATC_BLKSHIFT)
d219 1
a219 1
 * DMA and caching control
d221 4
a224 3
#define DMA_CACHE_SYNC		0x1
#define DMA_CACHE_SYNC_INVAL	0x2
#define DMA_CACHE_INV		0x3
d226 1
a226 1
void dma_cachectl __P((vm_offset_t, int, int));
d229 1
a229 1
 * Alignment checks for pages (must lie on page boundaries).
d231 1
a231 7

#define PAGE_ALIGNED(ad)	(((vm_offset_t)(ad) & PAGE_MASK) == 0)
#define	CHECK_PAGE_ALIGN(ad,who)	\
    if (!PAGE_ALIGNED(ad))		\
    	printf("%s: addr  %x not page aligned.\n", who, ad)

unsigned invalidate_pte __P((pt_entry_t *));
d236 6
a241 2
	((pt_entry_t *)(PG_PFNUM(*((sdt_entry_t *)kmapva + \
	    SDTIDX(va) + SDT_ENTRIES)) << PDT_SHIFT) + PDTIDX(va))
d243 4
a246 1
u_int kvtop __P((vm_offset_t));
@


1.14.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mmu.h,v 1.14.2.1 2002/01/31 22:55:18 niklas Exp $ */
d268 1
a268 1
void dma_cachectl(vm_offset_t, int, int);
d279 1
a279 1
unsigned invalidate_pte(pt_entry_t *);
d287 1
a287 1
u_int kvtop(vm_offset_t);
@


1.14.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d218 1
a218 1
#define SDTENT(map, va)	((sdt_entry_t *)((map)->pm_stab + SDTIDX(va)))
@


1.13
log
@Support for MVME197 completed.  Fix SPL defs.
@
text
@d63 1
a63 1
			rsvA:1,		/* reserved (U1 on mc88110) */
d73 2
a74 1
			dtype:2;	/* descriptor type (bit 2 only on mc88110) */
a76 7
/* mc88110 indirect descriptors */
typedef struct pt_ind_entry {
	unsigned long
			pda:30,		/* page descriptor address */
			dtype:2;	/* valid */
} pt_ind_entry_t;

a139 2
#define DT_IND_MASKED	2
#define DT_IND_UMASKED	3
d246 1
@


1.12
log
@Cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: mmu.h,v 1.11 2001/08/12 12:03:02 heko Exp $ */
d63 1
a63 1
			rsvA:1,		/* reserved */
d73 1
a73 2
			rsvC:1,		/* reserved */
			dtype:1;	/* valid */
d76 7
d146 2
a253 1
extern void dma_cachectl(vm_offset_t, int, int);
@


1.11
log
@#(endif|else) foo is incorrect, make it #endif /* foo */
deraadt@@ ok
@
text
@d1 1
a1 10
/*	$OpenBSD: mmu.h,v 1.10 2001/08/07 23:57:58 miod Exp $ */
/*
 * Ashura Project
 */
/*
 * HISTORY
 *
 * Original SCCS ID in ISEDL 
 * @@(#)mmu.h 1.22		 90/09/20 19:13:34
 */
a205 11
 * Flags for cmmu_store() <cmmu.s>
 */
#define STORE_CMD	0
#define STORE_UAPR	4
#define STORE_SAPR	8
#define STORE_BATCWP	0x400

#define C_CMMU		0
#define D_CMMU		0x1000

/*
d229 1
a229 1
 * Prototype for invalidate_pte found in "motorola/m88k/m88100/misc.s"
@


1.10
log
@One more typo.
There are probably lots of free commits left for spelling wizards
out there.
@
text
@d1 1
a1 1
/*	$OpenBSD: mmu.h,v 1.9 2001/06/27 04:29:19 art Exp $ */
d268 1
a268 1
#endif __MACHINE_MMU_H__
@


1.9
log
@rip old vm
@
text
@d1 1
a1 1
/*	$OpenBSD: mmu.h,v 1.8 2001/06/14 21:30:40 miod Exp $ */
d34 1
a34 1
			te:1;		/* transration enable */
@


1.8
log
@Big cleanup of VM issues:
o get rid of m88k_foo macros when there is an mi foo macro
o remove the ability, for the pmap module, to handle a native mmu page
  size different from the vm module page size. This allows some
  optimizations in pmap.c
o remove dead stuff from <machine/vmparam.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: mmu.h,v 1.7 2001/03/09 05:44:40 smurph Exp $ */
a184 1
#if defined(UVM)
a185 3
#else
#define PT_FREE(tbl)	kmem_free(kernel_map, (vm_offset_t)tbl, PAGE_SIZE)
#endif
@


1.7
log
@kernel will compile with -Werror.  Added intr.h
@
text
@d1 1
a1 1
/*	$OpenBSD: mmu.h,v 1.6 2001/01/14 20:25:24 smurph Exp $ */
a14 4
/* for m88k_pgbytes, m8kk_pgshift */
#include <machine/vmparam.h> 


d20 1
a20 21
#define PG_BITS		M88K_PGSHIFT	/* M88K hardware page size bits */

/*
 * Shifts and masks for M88K (hardware) page
 */
/* M88K_PGBYTES, PG_SHIFT in vm_param.h */
#define M88K_PGOFSET	(M88K_PGBYTES-1)	/* offset into M88K page */
#define M88K_PGMASK	(~M88K_PGOFSET)		/* page mask */ 

/*
 * Convert byte address to page frame number
 */
#define M88K_BTOP(x)	(((unsigned) (x)) >> M88K_PGSHIFT)
#define M88K_PTOB(x)	(((unsigned) (x)) << M88K_PGSHIFT)

/* 
 * Round off or truncate to the nearest page. These will work for
 * either addresses of counts. (i.e. 1 byte round to 1 page bytes).
 */
#define M88K_TRUNC_PAGE(x)	(((unsigned) (x) & M88K_PGMASK))
#define M88K_ROUND_PAGE(x)	M88K_TRUNC_PAGE((x) + M88K_PGOFSET)
d195 1
a195 1
#define PDT_VA_SPACE			(PDT_ENTRIES * M88K_PGBYTES)
d213 1
a213 1
#define PAGE_ALIGNED(ad)	(((vm_offset_t)(ad) & ~M88K_PGMASK) == 0)
a218 21
 * Validate PTE's for all hardware pages in a VM page.
 * "ptes_per_vm_page" should be set in pmap_bootstrap.
 *
 * PARAMETERS:
 *		pt_entry_t 	*start;
 * 		unsigned long	template;
 */
#define DO_PTES(start, template)			\
{							\
    int i_;						\
    pt_entry_t *p_ = start;				\
							\
    for (i_ = ptes_per_vm_page; i_>0; i_--) {		\
	*(int *)p_++ = (unsigned long)(template);	\
	template += M88K_PGBYTES;			\
	/* (unsigned long)(template) for m88k C compiler\
		'90.7.24	Fuzzy		*/	\
    }							\
}

/*
d265 1
a265 1
u_int kvtop( );
@


1.6
log
@Complete move to UVM virtual memory system.  More header fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: mmu.h,v 1.5 2001/01/13 05:18:59 smurph Exp $ */
d310 1
a310 1

@


1.5
log
@Booting kernel with MACHINE_NEW_NONCONTIG.  UVM code added but not working.
New stand config.  Lots of header fixes.  Can now cross-compile i386->m88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: mmu.h,v 1.4 1999/02/09 06:36:27 smurph Exp $ */
d12 2
a13 2
#ifndef	_MACHINE_MMU_
#define	_MACHINE_MMU_
d317 2
a318 2
#endif
/* endif _MACHINE_MMU_ */
@


1.4
log
@Added kernel support for user debugging.  Fixed file ID's
@
text
@d1 1
a1 1
/*	$OpenBSD: mmu.h,v 1.1 1998/12/15 04:45:50 smurph Exp $ */
d209 6
a214 1
#define PT_FREE(tbl)		kmem_free(kernel_map, (vm_offset_t)tbl, PAGE_SIZE)
@


1.4.6.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: mmu.h,v 1.7 2001/03/09 05:44:40 smurph Exp $ */
d12 2
a13 2
#ifndef	__MACHINE_MMU_H__
#define	__MACHINE_MMU_H__
d209 1
a209 6
#if defined(UVM)
#define PT_FREE(tbl)	uvm_km_free(kernel_map, (vaddr_t)tbl, PAGE_SIZE)
#else
#define PT_FREE(tbl)	kmem_free(kernel_map, (vm_offset_t)tbl, PAGE_SIZE)
#endif

d305 1
a305 1
u_int kvtop( );
d312 2
a313 2
#endif __MACHINE_MMU_H__

@


1.4.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: mmu.h,v 1.4.6.1 2001/04/18 16:11:22 niklas Exp $ */
d15 4
d24 21
a44 1
#define PG_BITS		PAGE_SHIFT	/* M88K hardware page size bits */
d209 1
d211 3
d219 1
a219 1
#define PDT_VA_SPACE			(PDT_ENTRIES * PAGE_SIZE)
d237 1
a237 1
#define PAGE_ALIGNED(ad)	(((vm_offset_t)(ad) & PAGE_MASK) == 0)
d243 21
d310 1
a310 1
extern u_int kvtop __P((vm_offset_t));
@


1.4.6.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: mmu.h,v 1.4.6.2 2001/07/04 10:20:03 niklas Exp $ */
d34 1
a34 1
			te:1;		/* translation enable */
d215 11
d249 1
a249 1
 * Prototype for invalidate_pte found in locore_asm_routines.S
d268 1
a268 1
#endif /* __MACHINE_MMU_H__ */
@


1.4.6.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d12 2
a13 50
/*
 * This file bears almost no resemblance to the original m68k file,
 * so the following copyright notice is questionable, but we are
 * nice people.
 */

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: pte.h 1.13 92/01/20$
 *
 *	@@(#)pte.h	8.1 (Berkeley) 6/10/93
 */

#ifndef	_MACHINE_MMU_H_
#define	_MACHINE_MMU_H_
d16 1
a16 1
 * Parameters which determine the 'geometry' of the m88K page tables in memory.
d18 2
a19 3

#define SDT_BITS	10		/* M88K segment table size bits */
#define PDT_BITS	10		/* M88K page table size bits */
d23 1
a23 1
 * Common fields for APR, SDT and PTE
a24 18

/* address frame */
#define	PG_FRAME	0xfffff000
#define	PG_SHIFT	PG_BITS
#define	PG_PFNUM(x)	(((x) & PG_FRAME) >> PG_SHIFT)

/* cache control bits */
#define	CACHE_DFL	0x0000000
#define	CACHE_INH	0x0000040	/* cache inhibit */
#define	CACHE_GLOBAL	0x0000080	/* global scope */
#define	CACHE_WT	0x0000200	/* write through */

#define	CACHE_MASK	(~(CACHE_INH | CACHE_GLOBAL | CACHE_WT))

/*
 * Area descriptors
 */

d43 51
d100 1
a100 1
 * BATC entries
a101 1

d120 1
a120 1
 * Segment table entries
d122 3
d126 1
a126 1
typedef u_int32_t	sdt_entry_t;
d128 1
a128 1
#define	SDT_ENTRY_NULL	((sdt_entry_t *) 0)
d130 1
a130 6
#define	SG_V		0x00000001
#define	SG_NV		0x00000000
#define	SG_PROT		0x00000004
#define	SG_RO		0x00000004
#define	SG_RW		0x00000000
#define	SG_SO		0x00000100
d132 5
a136 3
#define	SDT_VALID(sdt)	(*(sdt) & SG_V)
#define	SDT_SUP(sdt)	(*(sdt) & SG_SO)
#define	SDT_WP(sdt)	(*(sdt) & SG_PROT)
d139 1
a139 1
 * Page table entries
d141 2
a142 19

typedef u_int32_t	pt_entry_t;

#define	PT_ENTRY_NULL	((pt_entry_t *) 0)

#define	PG_V		0x00000001
#define	PG_NV		0x00000000
#define	PG_PROT		0x00000004
#define	PG_U		0x00000008
#define	PG_M		0x00000010
#define	PG_RO		0x00000004
#define	PG_RW		0x00000000
#define	PG_SO		0x00000100
#define	PG_W		0x00000400	/* XXX unused but reserved field */
#define	PG_U1		0x00000800	/* U1 bit for M88110 */

#define	PDT_VALID(pte)	(*(pte) & PG_V)
#define	PDT_SUP(pte)	(*(pte) & PG_SO)
#define	PDT_WP(pte)	(*(pte) & PG_PROT)
d145 1
a145 1
 * Indirect descriptors (mc81110)
d147 2
a148 14

typedef	u_int32_t	pt_ind_entry_t;

/* validity bits */
#define	IND_V		0x00000001
#define	IND_NV		0x00000000
#define	IND_MASKED	0x00000002
#define	IND_UNMASKED	0x00000003
#define	IND_MASK	0x00000003

#define	IND_FRAME	0xfffffffc
#define	IND_SHIFT	2

#define	IND_PDA(x)	((x) & IND_FRAME >> IND_SHIFT)
a152 1

a158 1

a164 1

d171 2
a172 2
#define SDT_NEXT(va)	(((va) + (1<<SDT_SHIFT)) & SDT_MASK)
#define PDT_NEXT(va)	(((va) + (1<<PDT_SHIFT)) & (SDT_MASK|PDT_MASK))
d174 2
a175 2
#define	SDTIDX(va)	(((va) & SDT_MASK) >> SDT_SHIFT)
#define	PDTIDX(va)	(((va) & PDT_MASK) >> PDT_SHIFT)
d177 1
a177 2
/* XXX uses knowledge of pmap structure */
#define SDTENT(map, va)	((sdt_entry_t *)((map)->sdt_vaddr + SDTIDX(va)))
a181 1

d185 1
a186 1
#define PT_FREE(tbl)	uvm_km_free(kernel_map, (vaddr_t)tbl, PAGE_SIZE)
a190 1

a196 1

d201 1
a201 1
 * Parameters and macros for BATC
d203 2
d206 11
a216 8
/* number of bits to BATC shift (log2(BATC_BLKBYTES)) */
#define BATC_BLKSHIFT	19
/* 'block' size of a BATC entry mapping */
#define BATC_BLKBYTES	(1 << BATC_BLKSHIFT)
/* BATC block mask */
#define BATC_BLKMASK	(BATC_BLKBYTES-1)
/* number of BATC entries */
#define BATC_MAX	8
d218 1
a218 1
#define BATC_BLK_ALIGNED(x)	((x & BATC_BLKMASK) == 0)
d220 6
a225 1
#define M88K_BTOBLK(x)	(x >> BATC_BLKSHIFT)
d228 1
a228 1
 * DMA and caching control
d230 4
a233 3
#define DMA_CACHE_SYNC		0x1
#define DMA_CACHE_SYNC_INVAL	0x2
#define DMA_CACHE_INV		0x3
d235 1
a235 1
void dma_cachectl __P((vm_offset_t, int, int));
d238 1
a238 1
 * Alignment checks for pages (must lie on page boundaries).
d240 1
a240 7

#define PAGE_ALIGNED(ad)	(((vm_offset_t)(ad) & PAGE_MASK) == 0)
#define	CHECK_PAGE_ALIGN(ad,who)	\
    if (!PAGE_ALIGNED(ad))		\
    	printf("%s: addr  %x not page aligned.\n", who, ad)

unsigned invalidate_pte __P((pt_entry_t *));
d245 6
a250 2
	((pt_entry_t *)(PG_PFNUM(*((sdt_entry_t *)kmapva + \
	    SDTIDX(va) + SDT_ENTRIES)) << PDT_SHIFT) + PDTIDX(va))
d252 4
a255 1
u_int kvtop __P((vm_offset_t));
@


1.4.6.5
log
@Merge in -current from about a week ago
@
text
@d277 1
a277 1
void dma_cachectl(vm_offset_t, int, int);
d288 1
a288 1
unsigned invalidate_pte(pt_entry_t *);
d296 1
a296 1
u_int kvtop(vm_offset_t);
@


1.4.6.6
log
@Manually fix old merge error
@
text
@d2 9
@


1.4.6.7
log
@Sync the SMP branch with 3.3
@
text
@d218 1
a218 1
#define SDTENT(map, va)	((sdt_entry_t *)((map)->pm_stab + SDTIDX(va)))
@


1.4.6.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mmu.h,v 1.4.6.7 2003/03/27 23:32:18 niklas Exp $ */
d26 5
a30 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.4.6.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d68 4
a71 4
#define	CACHE_DFL	0x00000000
#define	CACHE_INH	0x00000040	/* cache inhibit */
#define	CACHE_GLOBAL	0x00000080	/* global scope */
#define	CACHE_WT	0x00000200	/* write through */
d73 1
a73 1
#define	CACHE_MASK	(CACHE_INH | CACHE_GLOBAL | CACHE_WT)
d79 16
a94 1
#define	APR_V		0x00000001	/* valid bit */
d106 16
a121 7
#define	BATC_V		0x00000001
#define	BATC_PROT	0x00000002
#define	BATC_INH	0x00000004
#define	BATC_GLOBAL	0x00000008
#define	BATC_WT		0x00000010
#define	BATC_SO		0x00000020

d158 1
a158 2
#define	PG_W		0x00000020	/* XXX unused but reserved field */
#define	PG_U0		0x00000400	/* U0 bit for M88110 */
d198 1
a198 1
 * Shifts and masks
d204 5
a208 2
#define SDT_MASK	(((1 << SDT_BITS) - 1) << SDT_SHIFT)
#define PDT_MASK	(((1 << PDT_BITS) - 1) << PDT_SHIFT)
d217 10
d231 1
a252 4
/* physical and logical block address */
#define	BATC_PSHIFT	6
#define	BATC_VSHIFT	(BATC_PSHIFT + (32 - BATC_BLKSHIFT))

d264 5
a268 12
static pt_entry_t invalidate_pte(pt_entry_t *);
static __inline__ pt_entry_t
invalidate_pte(pt_entry_t *pte)
{
	pt_entry_t oldpte;

	oldpte = PG_NV;
	__asm__ __volatile__
	    ("xmem %0, %2, r0" : "=r"(oldpte) : "0"(oldpte), "r"(pte));
	__asm__ __volatile__ ("tb1 0, r0, 0");
	return oldpte;
}
d270 8
a277 1
extern vaddr_t kmapva;
d283 1
a283 1
u_int kvtop(vaddr_t);
d286 1
@


1.4.6.10
log
@Merge with the trunk
@
text
@d1 252
a252 3
/* $OpenBSD$ */
/* public domain */
#include <m88k/mmu.h>
@


1.3
log
@Cleanup after import. This also seems to bring up the current version.
@
text
@d1 1
@


1.2
log
@This is a remove to get rid of the old mvme88k port which was incomplete
to replace it with a working version. The kernel compiles and works
at least.  The new version will be imported shortly.
@
text
@d208 1
a208 1
#define PT_FREE(tbl)		kmem_free(kernel_map, tbl, PAGE_SIZE)
d304 6
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@initial 88k import; code by nivas and based on mach luna88k
@
text
@@


1.1.1.2
log
@Third try at importing the mvme88k port. This is a working kernel
from nivas.
Userland and compiler still need to be worked on.
Make certain what directory the import is done from.
@
text
@d208 1
a208 1
#define PT_FREE(tbl)		kmem_free(kernel_map, (vm_offset_t)tbl, PAGE_SIZE)
a303 6


#define DMA_CACHE_SYNC		0x1
#define DMA_CACHE_SYNC_INVAL	0x2
#define DMA_CACHE_INV		0x3
extern void dma_cachectl(vm_offset_t, int, int);
@
