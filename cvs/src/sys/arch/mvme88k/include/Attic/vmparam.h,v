head	1.29;
access;
symbols
	OPENBSD_5_5:1.28.0.16
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.28.0.12
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.28.0.10
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.28.0.8
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.6
	OPENBSD_5_0:1.28.0.4
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.28.0.2
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.27.0.26
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.27.0.22
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.27.0.24
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.27.0.20
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.27.0.18
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3:1.27.0.16
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.27.0.14
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.27.0.12
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.27.0.10
	OPENBSD_4_0_BASE:1.27
	OPENBSD_3_9:1.27.0.8
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.27.0.6
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.27.0.4
	OPENBSD_3_7_BASE:1.27
	OPENBSD_3_6:1.27.0.2
	OPENBSD_3_6_BASE:1.27
	SMP_SYNC_A:1.27
	SMP_SYNC_B:1.27
	OPENBSD_3_5:1.25.0.2
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.21.0.4
	OPENBSD_3_4_BASE:1.21
	UBC_SYNC_A:1.21
	OPENBSD_3_3:1.21.0.2
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.20.0.4
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.20.0.2
	OPENBSD_3_1_BASE:1.20
	UBC_SYNC_B:1.20
	UBC:1.18.0.2
	UBC_BASE:1.18
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.6.0.8
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.6
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.4
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	mvme88kport:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	first_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.29
date	2014.03.18.22.36.36;	author miod;	state dead;
branches;
next	1.28;

1.28
date	2010.12.31.21.38.08;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2004.04.26.14.31.11;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2004.04.26.12.34.05;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2003.12.28.22.12.34;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2003.10.05.20.27.46;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2003.10.02.10.18.11;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2003.09.20.13.57.35;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2003.01.24.09.57.41;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2002.02.17.22.59.53;	author maja;	state Exp;
branches;
next	1.19;

1.19
date	2001.12.24.04.12.37;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.05.16.25.44;	author art;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2001.11.30.17.37.43;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.09.22.18.00.10;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.12.19.30.19;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.12.12.03.02;	author heko;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.27.06.19.49;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.14.21.30.40;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.06.00.45.53;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.05.20.56.46;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.07.23.37.17;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.13.05.18.59;	author smurph;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.12.07.29.27;	author smurph;	state Exp;
branches;
next	1.6;

1.6
date	99.09.27.20.46.19;	author smurph;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	99.02.09.06.36.27;	author smurph;	state Exp;
branches;
next	1.4;

1.4
date	98.12.15.04.45.50;	author smurph;	state Exp;
branches;
next	1.3;

1.3
date	97.03.03.20.21.23;	author rahnds;	state Exp;
branches;
next	1.2;

1.2
date	97.03.03.19.07.53;	author rahnds;	state dead;
branches;
next	1.1;

1.1
date	95.10.18.10.54.21;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.10.54.21;	author deraadt;	state Exp;
branches;
next	;

1.6.4.1
date	2001.04.18.16.11.28;	author niklas;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2001.07.04.10.20.06;	author niklas;	state Exp;
branches;
next	1.6.4.3;

1.6.4.3
date	2001.10.31.03.01.19;	author nate;	state Exp;
branches;
next	1.6.4.4;

1.6.4.4
date	2001.12.05.00.39.12;	author niklas;	state Exp;
branches;
next	1.6.4.5;

1.6.4.5
date	2002.03.06.02.04.44;	author niklas;	state Exp;
branches;
next	1.6.4.6;

1.6.4.6
date	2003.03.27.23.32.18;	author niklas;	state Exp;
branches;
next	1.6.4.7;

1.6.4.7
date	2004.02.19.10.49.07;	author niklas;	state Exp;
branches;
next	1.6.4.8;

1.6.4.8
date	2004.06.05.23.09.50;	author niklas;	state Exp;
branches;
next	;

1.18.2.1
date	2002.01.31.22.55.18;	author niklas;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2002.06.11.03.37.10;	author art;	state Exp;
branches;
next	1.18.2.3;

1.18.2.3
date	2003.05.19.21.45.53;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/* $OpenBSD: vmparam.h,v 1.28 2010/12/31 21:38:08 miod Exp $ */
/* public domain */

/*
 * Physical memory is mapped 1:1 at the bottom of the supervisor address
 * space. Kernel virtual memory space starts from the end of physical memory,
 * up to the on-board devices appearing all over the last 8MB of address space.
 */
#define VM_MIN_KERNEL_ADDRESS	((vaddr_t)0x00000000)
#define VM_MAX_KERNEL_ADDRESS	((vaddr_t)0xff800000)

#include <m88k/vmparam.h>
@


1.28
log
@Massive overhauling of the m88k pmap, though I can't pretend it's a new pmap
since a large part of the structures and logic remains.

Since m88k has separate supervisor/user spaces, we can map physical memory 1:1
in supervisor space, and have the kernel virtual address space start from the
end of physical memory.

This allows us to switch to __HAVE_PMAP_DIRECT. And to get rid of the double
mapped sdt, since now their virtual and physical addresses will always match.

The upper bound of the kernel virtual memory space is now platform dependent,
until the code which relies upon some hardware devices being mapped 1:1 in
supervisor mode is updated to no longer require this (this is mainly a PITA on
luna88k, where onboard devices start at 0x40000000, leaving only 1GB of KVA at
the moment - still much better than the previous 512MB).

Tested on mvme88k only (187, 188, 197LE, 197DP). Other platforms ought to
work, aviion will be checked shortly and fixed if necessary. No known
OpenBSD/luna88k system in working condition at the moment.
@
text
@d1 1
a1 1
/* $OpenBSD: vmparam.h,v 1.27 2004/04/26 14:31:11 miod Exp $ */
@


1.27
log
@Fix RCSID
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d3 9
@


1.26
log
@Start factorizing luna88k and mvme88k common parts.
For now, include files only.
@
text
@d1 1
a1 1
/* $OpenBSD */
@


1.25
log
@Crank default data and stack limits, align with m68k values.
@
text
@d1 3
a3 133
/*	$OpenBSD: vmparam.h,v 1.24 2003/10/05 20:27:46 miod Exp $ */
/*
 * Mach Operating System
 * Copyright (c) 1992 Carnegie Mellon University
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */

/*
 *	machine dependent virtual memory parameters.
 */


#ifndef	_MACHINE_VM_PARAM_
#define _MACHINE_VM_PARAM_

/*
 * USRTEXT is the start of the user text/data space, while USRSTACK
 * is the top (end) of the user stack.
 */
#define	USRTEXT		0x1000			/* Start of user text */
#define	USRSTACK	0x80000000		/* Start of user stack */

/*
 * Virtual memory related constants, all in bytes
 */
#ifndef MAXTSIZ
#define	MAXTSIZ		(8*1024*1024)		/* max text size */
#endif
#ifndef DFLDSIZ
#define	DFLDSIZ		(32*1024*1024)		/* initial data size limit */
#endif
#ifndef MAXDSIZ
#define	MAXDSIZ		(64*1024*1024)		/* max data size */
#endif
#ifndef	DFLSSIZ
#define	DFLSSIZ		(2*1024*1024)		/* initial stack size limit */
#endif
#ifndef	MAXSSIZ
#define	MAXSSIZ		MAXDSIZ			/* max stack size */
#endif

/*
 * Size of shared memory map
 */
#ifndef SHMMAXPGS
#define SHMMAXPGS	1024
#endif

/*
 * The time for a process to be blocked before being very swappable.
 * This is a number of seconds which the system takes as being a non-trivial
 * amount of real time.  You probably shouldn't change this;
 * it is used in subtle ways (fractions and multiples of it are, that is, like
 * half of a ``long time'', almost a long time, etc.)
 * It is related to human patience and other factors which don't really
 * change over time.
 */
#define	MAXSLP 		20

#define	VM_MIN_ADDRESS		((vaddr_t) 0)
#define	VM_MAX_ADDRESS		((vaddr_t) 0xffc00000)
#define VM_MAXUSER_ADDRESS	VM_MAX_ADDRESS

/* on vme188, max = 0xf0000000 */

#define VM_MIN_KERNEL_ADDRESS	((vaddr_t) 0)
#define VM_MAX_KERNEL_ADDRESS	((vaddr_t) 0x20000000)

#define KERNEL_STACK_SIZE	(3 * PAGE_SIZE)	/* kernel stack size */
#define INTSTACK_SIZE		(4 * PAGE_SIZE)	/* interrupt stack size */

/* virtual sizes (bytes) for various kernel submaps */
#define VM_PHYS_SIZE		(1 * NPTEPG * PAGE_SIZE)

/*
 * Constants which control the way the VM system deals with memory segments.
 * The mvme88k only has one physical memory segment.
 */
#define	VM_PHYSSEG_MAX		1
#define	VM_PHYSSEG_STRAT	VM_PSTRAT_BSEARCH
#define	VM_PHYSSEG_NOADD

#define VM_NFREELIST		1
#define VM_FREELIST_DEFAULT	0

#ifndef _LOCORE
/*
 * pmap-specific data stored in the vm_physmem[] array.
 */

/* XXX - belongs in pmap.h, but put here because of ordering issues */
struct pv_entry {
	struct pv_entry	*pv_next;	/* next pv_entry */
	struct pmap	*pv_pmap;	/* pmap where mapping lies */
	vaddr_t		pv_va;		/* virtual address for mapping */
	int		pv_flags;
};

#define	__HAVE_VM_PAGE_MD
struct vm_page_md {
	struct pv_entry pvent;
};

#define	VM_MDPAGE_INIT(pg) do {			\
	(pg)->mdpage.pvent.pv_next = NULL;	\
	(pg)->mdpage.pvent.pv_pmap = PMAP_NULL;	\
	(pg)->mdpage.pvent.pv_va = 0;		\
	(pg)->mdpage.pvent.pv_flags = 0;	\
} while (0)

#endif /* _LOCORE */

#endif /* _MACHINE_VM_PARAM_ */
@


1.24
log
@Kill vm_offset_t and vm_size_t, in favor of the [pv]addr_t and [pv]size_t
typedefs.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.23 2003/10/02 10:18:11 miod Exp $ */
d50 1
a50 1
#define	DFLDSIZ		(16*1024*1024)		/* initial data size limit */
d56 1
a56 1
#define	DFLSSIZ		(512*1024)		/* initial stack size limit */
@


1.23
log
@Round VM_MAX_KERNEL_ADDRESS to a page boundary.
@
text
@d1 2
a2 2
/*	$OpenBSD: vmparam.h,v 1.22 2003/09/20 13:57:35 miod Exp $ */
/* 
d6 1
a6 1
 * 
d12 1
a12 1
 * 
d16 1
a16 1
 * 
d18 1
a18 1
 * 
d23 2
a24 2
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon 
d80 2
a81 2
#define	VM_MIN_ADDRESS		((vm_offset_t) 0)
#define	VM_MAX_ADDRESS		((vm_offset_t) 0xffc00000)
d86 2
a87 2
#define VM_MIN_KERNEL_ADDRESS	((vm_offset_t) 0)
#define VM_MAX_KERNEL_ADDRESS	((vm_offset_t) 0x20000000)
@


1.22
log
@Cleanup uses of intstack and interrupt_stack[] - also makes time % in top
more realistic.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.21 2003/01/24 09:57:41 miod Exp $ */
d81 1
a81 1
#define	VM_MAX_ADDRESS		((vm_offset_t) 0xffc00000U)
d87 1
a87 1
#define VM_MAX_KERNEL_ADDRESS	((vm_offset_t) 0x1fffffff)
@


1.21
log
@Convert m88k pmap from physseg to VM_PAGE_MD.

This allows us to remove some ambiguities on how some functions are called,
remove some diagnostic checks for conditions that can never happen and
remove the ugly hack with "pmap_initialized".

Then, rework internal function interfaces and some logic so as to stop
fetching vm_page from a pa and the reverse every now and then - this makes
some pmap operations run much faster.

While there, various KNF and whitespace fixes, and rename some structure
fields to be closer to the m68k pmap.

per art@@'s idea.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.20 2002/02/17 22:59:53 maja Exp $ */
d90 1
a90 1
#define INTSTACK_SIZE		(3 * PAGE_SIZE)	/* interrupt stack size */
@


1.20
log
@Patch from Daniel Lucq <daniel@@lucq.org>

The patch allows you to change the value of NMBCLUSTERS, BUFCACHEPERCENT
and NKMEMPAGES using the config command, instead of recompiling the kernel.

This is the kernel part of the patch. I have compiled it on i386, sparc64,
alpha and macppc. -moj ok art@@ maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.19 2001/12/24 04:12:37 miod Exp $ */
d110 12
a121 4
#define __HAVE_PMAP_PHYSSEG
struct pmap_physseg {
	struct pv_entry *pvent;		/* pv table for this seg */
	char *attrs;			/* page modify list for this seg */
d123 8
@


1.19
log
@- completely change the mmu segment and page table structure definitions,
to use constant bitmasks instead of bitfields.
- remove unnecessary (as long as we are not running SMP) locks on the
physsegs.
- update the pmap code to take these changes into account, and gratuitously
change several names and code paths to be closer to existing m68k pmaps. It's
a bit faster now.
- change pmap.c's usage of vm_{offset,size}_t to {p,v}{addr,size}_t.
- remove dead or unused stuff from pmap.c, fix typos, etc

Tested on 187 and 188, should not make things worse for 197.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.18 2001/12/05 16:25:44 art Exp $ */
a92 1
#define VM_MBUF_SIZE		(NMBCLUSTERS * MCLBYTES)
@


1.18
log
@VM_KMEM_SIZE no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.17 2001/11/30 17:37:43 art Exp $ */
a114 1
	struct simplelock *plock;	/* page lock for this seg */
@


1.18.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.19 2001/12/24 04:12:37 miod Exp $ */
d115 1
@


1.18.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.18.2.1 2002/01/31 22:55:18 niklas Exp $ */
d93 1
@


1.18.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d110 4
a113 12

/* XXX - belongs in pmap.h, but put here because of ordering issues */
struct pv_entry {
	struct pv_entry	*pv_next;	/* next pv_entry */
	struct pmap	*pv_pmap;	/* pmap where mapping lies */
	vaddr_t		pv_va;		/* virtual address for mapping */
	int		pv_flags;
};

#define	__HAVE_VM_PAGE_MD
struct vm_page_md {
	struct pv_entry pvent;
a114 8

#define	VM_MDPAGE_INIT(pg) do {			\
	(pg)->mdpage.pvent.pv_next = NULL;	\
	(pg)->mdpage.pvent.pv_pmap = PMAP_NULL;	\
	(pg)->mdpage.pvent.pv_va = 0;		\
	(pg)->mdpage.pvent.pv_flags = 0;	\
} while (0)

@


1.17
log
@Now that pmaps can have vm_page_md, make pmap_physseg optional.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.16 2001/09/22 18:00:10 miod Exp $ */
a93 1
#define VM_KMEM_SIZE		(NKMEMCLUSTERS * PAGE_SIZE)
@


1.16
log
@Remove more old, dusty, unused defines.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.15 2001/08/12 19:30:19 miod Exp $ */
d112 1
@


1.15
log
@g/c old, unused, constants.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.14 2001/08/12 12:03:02 heko Exp $ */
a62 11
 * Default sizes of swap allocation chunks (see dmap.h).
 * The actual values may be changed in vminit() based on MAXDSIZ.
 * With MAXDSIZ of 16Mb and NDMAP of 38, dmmax will be 1024.
 * DMMIN should be at least ctod(1) so that vtod() works.
 * vminit() insures this.
 */
#define	DMMIN	32			/* smallest swap allocation */
#define	DMMAX	4096			/* largest potential swap allocation */
#define	DMTEXT	1024			/* swap allocation for text */

/*
a79 12
/*
 * A swapped in process is given a small amount of core without being bothered
 * by the page replacement algorithm.  Basically this says that if you are
 * swapped in you deserve some resources.  We protect the last SAFERSS
 * pages against paging and will just swap you out rather than paging you.
 */
#define	SAFERSS		4		/* nominal ``small'' resident set size
					   protected against replacement */

/*
 * Mach derived constants
 */
@


1.14
log
@#(endif|else) foo is incorrect, make it #endif /* foo */
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.13 2001/06/27 06:19:49 art Exp $ */
a62 15
 * PTEs for mapping user space into the kernel for phyio operations.
 * One page is enough to handle 4Mb of simultaneous raw IO operations.
 */
#ifndef USRIOSIZE
#define USRIOSIZE	(1 * NPTEPG)	/* 4mb */
#endif

/*
 * External IO space map size.
 */
#ifndef EIOMAPSIZE
#define EIOMAPSIZE	1024		/* in pages */
#endif

/*
a99 6
#define	VM_MINUSER_ADDRESS	((vm_offset_t) 0)
#define	VM_MAXUSER_ADDRESS	((vm_offset_t) 0xffc00000U)

#define VM_MINKERNEL_ADDRESS	((vm_offset_t) 0)
#define VM_MAXKERNEL_ADDRESS	((vm_offset_t) 0x1fffffff)

d105 1
a105 3

#define	VM_MIN_USER_ADDRESS	((vm_offset_t) 0)
#define	VM_MAX_USER_ADDRESS	((vm_offset_t) 0xffc00000U)
d118 1
a118 1
#define VM_PHYS_SIZE		(USRIOSIZE * PAGE_SIZE)
@


1.13
log
@MNN is no longer an option.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.12 2001/06/14 21:30:40 miod Exp $ */
d165 1
a165 1
#endif	_MACHINE_VM_PARAM_
@


1.12
log
@Big cleanup of VM issues:
o get rid of m88k_foo macros when there is an mi foo macro
o remove the ability, for the pmap module, to handle a native mmu page
  size different from the vm module page size. This allows some
  optimizations in pmap.c
o remove dead stuff from <machine/vmparam.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.11 2001/05/06 00:45:53 art Exp $ */
a142 4
/* Use new VM page bootstrap interface. */
#define	MACHINE_NEW_NONCONTIG

#if defined(MACHINE_NEW_NONCONTIG)
a163 2

#endif /* MACHINE_NEW_NONCONTIG */
@


1.11
log
@Update some comments wrt. the CLSIZE changes.
And remove that memory price comment from 1981. It is amusing, but also
confusing because the math in there is only correct on vax.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.10 2001/05/05 20:56:46 art Exp $ */
a28 5
 * HISTORY
 */
/*
 *	File:	vm_param.h
 *
a29 3
 *	Most of the declarations are preceeded by M88K_ (or m88k_)
 *	which is OK because only M88K specific code will be using
 *	them.
d124 2
a125 25
#define BYTE_SIZE	8	/* byte size in bits */

#define M88K_PGBYTES	(1<<12)	/* bytes per m88k page */
#define M88K_PGSHIFT	12	/* number of bits to shift for pages */

/*
 *	Convert bytes to pages and convert pages to bytes.
 *	No rounding is used.
 */

#define	m88k_btop(x)		(((unsigned)(x)) >> M88K_PGSHIFT)
#define	m88k_ptob(x)		(((unsigned)(x)) << M88K_PGSHIFT)

/*
 *	Round off or truncate to the nearest page.  These will work
 *	for either addresses or counts.  (i.e. 1 byte rounds to 1 page
 *	bytes.
 */

#define m88k_round_page(x)	((((unsigned)(x)) + M88K_PGBYTES - 1) & \
					~(M88K_PGBYTES-1))
#define m88k_trunc_page(x)	(((unsigned)(x)) & ~(M88K_PGBYTES-1))

#define	VM_MIN_ADDRESS	((vm_offset_t) 0)
#define	VM_MAX_ADDRESS	((vm_offset_t) 0xffc00000U)
d128 1
a128 1
#define	VM_MAX_USER_ADDRESS  ((vm_offset_t) 0xffc00000U)
d135 2
a136 2
#define KERNEL_STACK_SIZE	(3*4096)	/* kernel stack size */
#define INTSTACK_SIZE		(3*4096)	/* interrupt stack size */
d139 3
a141 11
#define VM_MBUF_SIZE		(NMBCLUSTERS*MCLBYTES)
#define VM_KMEM_SIZE		(NKMEMCLUSTERS*PAGE_SIZE)
#define VM_PHYS_SIZE		(USRIOSIZE*PAGE_SIZE)

/*
 *	Conversion between MACHINE pages and VM pages
 */

#define trunc_m88k_to_vm(p)	(atop(trunc_page(m88k_ptob(p))))
#define round_m88k_to_vm(p)	(atop(round_page(m88k_ptob(p))))
#define vm_to_m88k(p)		(m88k_btop(ptoa(p)))
d149 1
a149 1
 * The hp300 only has one physical memory segment.
a169 48


#if	1	/*Do we really need all this stuff*/
#if	1	/*Do we really need all this stuff*/
#if	1	/*Do we really need all this stuff*/
#define	M88K_SGPAGES	(1<<10)	/* pages per m88k segment */
#define	M88K_SGPGSHIFT	10	/* number of bits to shift for segment-page */
#define	M88K_ALSEGMS	(1<<10)	/* segments per m88k all space */
#define	M88K_ALSGSHIFT	10	/* number of bits to shift for all-segment */

#define	M88K_SGBYTES	(1<<22)	/* bytes per m88k segments */
#define	M88K_SGSHIFT	22	/* number of bits to shift for segment */
#define	M88K_ALPAGES	(1<<20)	/* pages per m88k all space */
#define	M88K_ALPGSHIFT	20	/* number of bits to shift for all-page */

/*
 *	Convert bytes to pages and convert pages to bytes.
 *	No rounding is used.
 */

#define	m88k_btopr(x)		(((unsigned)(x) + (M88K_PGBYTES - 1)) >> M88K_PGSHIFT)
#define	m88k_btosr(x)		(((unsigned)(x) + (M88K_SGBYTES - 1)) >> M88K_SGSHIFT)
#define	m88k_btos(x)		(((unsigned)(x)) >> M88K_SGSHIFT)
#define	m88k_stob(x)		(((unsigned)(x)) << M88K_SGSHIFT)
#define	m88k_ptosr(x)		(((unsigned)(x) + (M88K_SGPAGES - 1)) >> M88K_SGPGSHIFT)
#define	m88k_ptos(x)		(((unsigned)(x)) >> M88K_SGPGSHIFT)
#define	m88k_stop(x)		(((unsigned)(x)) << M88K_SGPGSHIFT)

/*
 *	Round off or truncate to the nearest page.  These will work
 *	for either addresses or counts.  (i.e. 1 byte rounds to 1 page
 *	bytes.
 */

#define m88k_round_segm(x)	((((unsigned)(x)) + M88K_SGBYTES - 1) & \
					~(M88K_SGBYTES-1))
#define m88k_next_segm(x)	((((unsigned)(x)) & ~(M88K_SGBYTES-1)) + \
					M88K_SGBYTES)
#define m88k_trunc_segm(x)	(((unsigned)(x)) & ~(M88K_SGBYTES-1))

#define m88k_round_seg(x)	((((unsigned)(x)) + M88K_SGBYTES - 1) & \
					~(M88K_SGBYTES-1))
#define m88k_trunc_seg(x)	(((unsigned)(x)) & ~(M88K_SGBYTES-1))

#define	VEQR_ADDR	0x20000000	/* kernel virtual eq phy mapping */
#endif	/*  Do we really need all this stuff */
#endif	/*  Do we really need all this stuf  */
#endif	/*  Do we really need all this stuff */
@


1.10
log
@Get rid of CLSIZE and all related stuff.
CLSIZE -> 1
CLBYTES -> PAGE_SIZE
OLOFSET -> PAGE_MASK
etc.
At the same time some archs needed some cleaning in vmparam.h so that
goes in at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.9 2001/03/07 23:37:17 miod Exp $ */
a118 7
 * Note that each process has at least UPAGES+CLSIZE pages which are not
 * paged anyways (this is currently 8+2=10 pages or 5k bytes), so this
 * number just means a swapped in process is given around 25k bytes.
 * Just for fun: current memory prices are 4600$ a megabyte on VAX (4/22/81),
 * so we loan each swapped in process memory worth 100$, or just admit
 * that we don't consider it worthwhile and swap it out to disk which costs
 * $30/mb or about $0.75.
@


1.9
log
@Inclusion from assembly code is detected with _LOCORE, no more fancy symbols.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.8 2001/01/13 05:18:59 smurph Exp $ */
d178 2
a179 2
#define VM_KMEM_SIZE		(NKMEMCLUSTERS*CLBYTES)
#define VM_PHYS_SIZE		(USRIOSIZE*CLBYTES)
@


1.8
log
@Booting kernel with MACHINE_NEW_NONCONTIG.  UVM code added but not working.
New stand config.  Lots of header fixes.  Can now cross-compile i386->m88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.7 2001/01/12 07:29:27 smurph Exp $ */
d204 1
a204 1
#ifndef ASSEMBLER
d213 1
a213 1
#endif /* ASSEMBLER */
@


1.7
log
@Update vm interface to MACHIN_NEW_NONCONTIG.  Fix compile warning in pcctwo.c
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.6 1999/09/27 20:46:19 smurph Exp $ */
d204 1
d213 2
@


1.6
log
@Adding support for MVME188 and MVME197
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.5 1999/02/09 06:36:27 smurph Exp $ */
d71 8
d179 1
d188 26
@


1.6.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.9 2001/03/07 23:37:17 miod Exp $ */
a70 8
 * PTEs for mapping user space into the kernel for phyio operations.
 * One page is enough to handle 4Mb of simultaneous raw IO operations.
 */
#ifndef USRIOSIZE
#define USRIOSIZE	(1 * NPTEPG)	/* 4mb */
#endif

/*
a170 1
#define VM_PHYS_SIZE		(USRIOSIZE*CLBYTES)
a178 29

/* Use new VM page bootstrap interface. */
#define	MACHINE_NEW_NONCONTIG

#if defined(MACHINE_NEW_NONCONTIG)
/*
 * Constants which control the way the VM system deals with memory segments.
 * The hp300 only has one physical memory segment.
 */
#define	VM_PHYSSEG_MAX		1
#define	VM_PHYSSEG_STRAT	VM_PSTRAT_BSEARCH
#define	VM_PHYSSEG_NOADD

#define VM_NFREELIST		1
#define VM_FREELIST_DEFAULT	0

#ifndef _LOCORE
/*
 * pmap-specific data stored in the vm_physmem[] array.
 */
struct pmap_physseg {
	struct pv_entry *pvent;		/* pv table for this seg */
	char *attrs;			/* page modify list for this seg */
	struct simplelock *plock;	/* page lock for this seg */
};
#endif /* _LOCORE */

#endif /* MACHINE_NEW_NONCONTIG */

@


1.6.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.6.4.1 2001/04/18 16:11:28 niklas Exp $ */
d29 5
d35 3
d119 7
d139 25
a163 2
#define	VM_MIN_ADDRESS		((vm_offset_t) 0)
#define	VM_MAX_ADDRESS		((vm_offset_t) 0xffc00000U)
d166 1
a166 1
#define	VM_MAX_USER_ADDRESS	((vm_offset_t) 0xffc00000U)
d173 2
a174 2
#define KERNEL_STACK_SIZE	(3 * PAGE_SIZE)	/* kernel stack size */
#define INTSTACK_SIZE		(3 * PAGE_SIZE)	/* interrupt stack size */
d177 3
a179 3
#define VM_MBUF_SIZE		(NMBCLUSTERS * MCLBYTES)
#define VM_KMEM_SIZE		(NKMEMCLUSTERS * PAGE_SIZE)
#define VM_PHYS_SIZE		(USRIOSIZE * PAGE_SIZE)
d182 12
d195 1
a195 1
 * The mvme88k only has one physical memory segment.
d214 50
@


1.6.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.6.4.2 2001/07/04 10:20:06 niklas Exp $ */
d63 26
d106 18
d126 3
a128 1
#define VM_MAXUSER_ADDRESS	VM_MAX_ADDRESS
d141 1
a141 1
#define VM_PHYS_SIZE		(1 * NPTEPG * PAGE_SIZE)
d165 1
a165 1
#endif /* _MACHINE_VM_PARAM_ */
@


1.6.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.6.4.3 2001/10/31 03:01:19 nate Exp $ */
a111 1
#define __HAVE_PMAP_PHYSSEG
@


1.6.4.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d93 2
d116 1
@


1.6.4.6
log
@Sync the SMP branch with 3.3
@
text
@d110 4
a113 7

/* XXX - belongs in pmap.h, but put here because of ordering issues */
struct pv_entry {
	struct pv_entry	*pv_next;	/* next pv_entry */
	struct pmap	*pv_pmap;	/* pmap where mapping lies */
	vaddr_t		pv_va;		/* virtual address for mapping */
	int		pv_flags;
a114 13

#define	__HAVE_VM_PAGE_MD
struct vm_page_md {
	struct pv_entry pvent;
};

#define	VM_MDPAGE_INIT(pg) do {			\
	(pg)->mdpage.pvent.pv_next = NULL;	\
	(pg)->mdpage.pvent.pv_pmap = PMAP_NULL;	\
	(pg)->mdpage.pvent.pv_va = 0;		\
	(pg)->mdpage.pvent.pv_flags = 0;	\
} while (0)

@


1.6.4.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d2 1
a2 1
/*
d6 1
a6 1
 *
d12 1
a12 1
 *
d16 1
a16 1
 *
d18 1
a18 1
 *
d23 2
a24 2
 *
 * any improvements or extensions that they make and grant Carnegie Mellon
d50 1
a50 1
#define	DFLDSIZ		(32*1024*1024)		/* initial data size limit */
d56 1
a56 1
#define	DFLSSIZ		(2*1024*1024)		/* initial stack size limit */
d80 2
a81 2
#define	VM_MIN_ADDRESS		((vaddr_t) 0)
#define	VM_MAX_ADDRESS		((vaddr_t) 0xffc00000)
d86 2
a87 2
#define VM_MIN_KERNEL_ADDRESS	((vaddr_t) 0)
#define VM_MAX_KERNEL_ADDRESS	((vaddr_t) 0x20000000)
d90 1
a90 1
#define INTSTACK_SIZE		(4 * PAGE_SIZE)	/* interrupt stack size */
@


1.6.4.8
log
@Merge with the trunk
@
text
@d1 133
a133 3
/* $OpenBSD$ */
/* public domain */
#include <m88k/vmparam.h>
@


1.5
log
@Added kernel support for user debugging.  Fixed file ID's
@
text
@d1 1
a1 1
/*	$OpenBSD: vmparam.h,v 1.1 1998/12/15 04:45:50 smurph Exp $ */
d158 1
a158 1
#define	VM_MAX_USER_ADDRESS	((vm_offset_t) 0xffc00000U)
@


1.4
log
@Commit for the first real OpenBSD mvme88k kernel.
@
text
@d1 1
@


1.3
log
@Cleanup after import. This also seems to bring up the current version.
@
text
@d70 7
@


1.2
log
@This is a remove to get rid of the old mvme88k port which was incomplete
to replace it with a working version. The kernel compiles and works
at least.  The new version will be imported shortly.
@
text
@@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@initial 88k import; code by nivas and based on mach luna88k
@
text
@@
