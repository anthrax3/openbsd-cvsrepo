head	1.38;
access;
symbols
	OPENBSD_5_5:1.37.0.16
	OPENBSD_5_5_BASE:1.37
	OPENBSD_5_4:1.37.0.12
	OPENBSD_5_4_BASE:1.37
	OPENBSD_5_3:1.37.0.10
	OPENBSD_5_3_BASE:1.37
	OPENBSD_5_2:1.37.0.8
	OPENBSD_5_2_BASE:1.37
	OPENBSD_5_1_BASE:1.37
	OPENBSD_5_1:1.37.0.6
	OPENBSD_5_0:1.37.0.4
	OPENBSD_5_0_BASE:1.37
	OPENBSD_4_9:1.37.0.2
	OPENBSD_4_9_BASE:1.37
	OPENBSD_4_8:1.36.0.26
	OPENBSD_4_8_BASE:1.36
	OPENBSD_4_7:1.36.0.22
	OPENBSD_4_7_BASE:1.36
	OPENBSD_4_6:1.36.0.24
	OPENBSD_4_6_BASE:1.36
	OPENBSD_4_5:1.36.0.20
	OPENBSD_4_5_BASE:1.36
	OPENBSD_4_4:1.36.0.18
	OPENBSD_4_4_BASE:1.36
	OPENBSD_4_3:1.36.0.16
	OPENBSD_4_3_BASE:1.36
	OPENBSD_4_2:1.36.0.14
	OPENBSD_4_2_BASE:1.36
	OPENBSD_4_1:1.36.0.12
	OPENBSD_4_1_BASE:1.36
	OPENBSD_4_0:1.36.0.10
	OPENBSD_4_0_BASE:1.36
	OPENBSD_3_9:1.36.0.8
	OPENBSD_3_9_BASE:1.36
	OPENBSD_3_8:1.36.0.6
	OPENBSD_3_8_BASE:1.36
	OPENBSD_3_7:1.36.0.4
	OPENBSD_3_7_BASE:1.36
	OPENBSD_3_6:1.36.0.2
	OPENBSD_3_6_BASE:1.36
	SMP_SYNC_A:1.35
	SMP_SYNC_B:1.35
	OPENBSD_3_5:1.33.0.2
	OPENBSD_3_5_BASE:1.33
	OPENBSD_3_4:1.29.0.4
	OPENBSD_3_4_BASE:1.29
	UBC_SYNC_A:1.29
	OPENBSD_3_3:1.29.0.2
	OPENBSD_3_3_BASE:1.29
	OPENBSD_3_2:1.27.0.2
	OPENBSD_3_2_BASE:1.27
	OPENBSD_3_1:1.26.0.2
	OPENBSD_3_1_BASE:1.26
	UBC_SYNC_B:1.27
	UBC:1.22.0.2
	UBC_BASE:1.22
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.9.0.8
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.6
	OPENBSD_2_7_BASE:1.9
	SMP:1.9.0.4
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	mvme88kport:1.1.1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	first_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.38
date	2014.03.18.22.36.36;	author miod;	state dead;
branches;
next	1.37;

1.37
date	2010.12.31.21.38.08;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2004.07.25.11.06.42;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2004.05.20.09.20.42;	author kettenis;	state Exp;
branches;
next	1.34;

1.34
date	2004.04.14.13.43.47;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2003.12.19.21.25.02;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2003.12.14.22.08.01;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2003.10.11.22.08.57;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2003.09.26.22.27.25;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2003.01.24.09.57.41;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2003.01.24.00.51.52;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2002.05.07.00.54.34;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2002.03.14.01.26.39;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2002.02.05.22.52.48;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2001.12.24.04.12.37;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2001.12.22.10.22.13;	author smurph;	state Exp;
branches;
next	1.22;

1.22
date	2001.12.16.23.49.46;	author miod;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2001.12.12.19.33.38;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2001.12.05.00.11.51;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.28.16.13.28;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2001.11.28.15.34.16;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2001.10.28.00.58.06;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2001.08.18.20.50.18;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.12.21.34.48;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.12.20.13.07;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.06.20.48.22;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.14.21.30.40;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.13.05.18.59;	author smurph;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.12.07.29.27;	author smurph;	state Exp;
branches;
next	1.9;

1.9
date	99.09.27.20.46.19;	author smurph;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	99.07.18.18.00.06;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	99.07.18.16.45.54;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	99.05.29.04.41.45;	author smurph;	state Exp;
branches;
next	1.5;

1.5
date	99.02.09.06.36.27;	author smurph;	state Exp;
branches;
next	1.4;

1.4
date	98.12.15.04.45.50;	author smurph;	state Exp;
branches;
next	1.3;

1.3
date	97.03.03.20.21.09;	author rahnds;	state Exp;
branches;
next	1.2;

1.2
date	97.03.03.19.07.40;	author rahnds;	state dead;
branches;
next	1.1;

1.1
date	95.10.18.10.54.22;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.10.54.22;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.03.03.19.31.28;	author rahnds;	state Exp;
branches;
next	;

1.9.4.1
date	2001.04.18.16.11.24;	author niklas;	state Exp;
branches;
next	1.9.4.2;

1.9.4.2
date	2001.07.04.10.20.04;	author niklas;	state Exp;
branches;
next	1.9.4.3;

1.9.4.3
date	2001.10.31.03.01.19;	author nate;	state Exp;
branches;
next	1.9.4.4;

1.9.4.4
date	2001.11.13.21.04.15;	author niklas;	state Exp;
branches;
next	1.9.4.5;

1.9.4.5
date	2001.12.05.00.39.12;	author niklas;	state Exp;
branches;
next	1.9.4.6;

1.9.4.6
date	2002.03.06.02.04.44;	author niklas;	state Exp;
branches;
next	1.9.4.7;

1.9.4.7
date	2002.03.28.10.36.02;	author niklas;	state Exp;
branches;
next	1.9.4.8;

1.9.4.8
date	2003.03.27.23.32.18;	author niklas;	state Exp;
branches;
next	1.9.4.9;

1.9.4.9
date	2004.02.19.10.49.07;	author niklas;	state Exp;
branches;
next	1.9.4.10;

1.9.4.10
date	2004.06.05.23.09.50;	author niklas;	state Exp;
branches;
next	;

1.22.2.1
date	2002.01.31.22.55.18;	author niklas;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2002.06.11.03.37.10;	author art;	state Exp;
branches;
next	1.22.2.3;

1.22.2.3
date	2003.05.19.21.45.53;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.38
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/* $OpenBSD: pmap.h,v 1.37 2010/12/31 21:38:08 miod Exp $ */
/* public domain */
#include <m88k/pmap.h>
@


1.37
log
@Massive overhauling of the m88k pmap, though I can't pretend it's a new pmap
since a large part of the structures and logic remains.

Since m88k has separate supervisor/user spaces, we can map physical memory 1:1
in supervisor space, and have the kernel virtual address space start from the
end of physical memory.

This allows us to switch to __HAVE_PMAP_DIRECT. And to get rid of the double
mapped sdt, since now their virtual and physical addresses will always match.

The upper bound of the kernel virtual memory space is now platform dependent,
until the code which relies upon some hardware devices being mapped 1:1 in
supervisor mode is updated to no longer require this (this is mainly a PITA on
luna88k, where onboard devices start at 0x40000000, leaving only 1GB of KVA at
the moment - still much better than the previous 512MB).

Tested on mvme88k only (187, 188, 197LE, 197DP). Other platforms ought to
work, aviion will be checked shortly and fixed if necessary. No known
OpenBSD/luna88k system in working condition at the moment.
@
text
@d1 1
a1 1
/* $OpenBSD: pmap.h,v 1.36 2004/07/25 11:06:42 miod Exp $ */
@


1.36
log
@Merge luna88k and mvme88k pmap. The pmap will now assume that the memory
below the kernel text is reserved for the PROM, instead of using fixed
(but different) values between luna88k and mvme88k.

Tested on mvme88k by myself, on luna88k by aoyama@@
@
text
@d1 1
a1 1
/* $OpenBSD: pmap.h,v 1.35 2004/05/20 09:20:42 kettenis Exp $ */
a2 4

#ifndef	_MVME88K_PMAP_H_
#define	_MVME88K_PMAP_H_

a3 6

#ifdef	_KERNEL
vaddr_t	pmap_bootstrap_md(vaddr_t);
#endif

#endif	_MVME88K_PMAP_H_
@


1.35
log
@Properly flush instruction cache for ptrace(PT_WRTIE_{DI}, ...) on powerpc
and m68k.
ok drahn@@, millert@@
@
text
@d1 2
a2 16
/*	$OpenBSD: pmap.h,v 1.34 2004/04/14 13:43:47 miod Exp $ */
/*
 * Mach Operating System
 * Copyright (c) 1991 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 */
#ifndef _MACHINE_PMAP_H_
#define _MACHINE_PMAP_H_
d4 2
a5 2
#include <machine/mmu.h>
#include <machine/pcb.h>
d7 1
a7 3
/*
 * PMAP structure
 */
d9 2
a10 12
/* #define PMAP_USE_BATC */
struct pmap {
	sdt_entry_t		*pm_stab;	/* virtual pointer to sdt */
	u_int32_t		pm_apr;
	int			pm_count;	/* reference count */
	/* cpus using of this pmap; NCPU must be <= 32 */
	u_int32_t		pm_cpus;
	struct simplelock	pm_lock;
	struct pmap_statistics	pm_stats;	/* pmap statistics */
#ifdef	PMAP_USE_BATC
	u_int32_t		pm_ibatc[BATC_MAX];	/* instruction BATCs */
	u_int32_t		pm_dbatc[BATC_MAX];	/* data BATCs */
a11 40
};

#define PMAP_NULL ((pmap_t) 0)

/* 	The PV (Physical to virtual) List.
 *
 * For each vm_page_t, pmap keeps a list of all currently valid virtual
 * mappings of that page. An entry is a pv_entry_t; the list is the
 * pv_head_table. This is used by things like pmap_remove, when we must
 * find and remove all mappings for a particular physical page.
 */
/* XXX - struct pv_entry moved to vmparam.h because of include ordering issues */

typedef struct pmap *pmap_t;
typedef struct pv_entry *pv_entry_t;

#ifdef	_KERNEL

extern	pmap_t		kernel_pmap;
extern	struct pmap	kernel_pmap_store;
extern	caddr_t		vmmap;

#define	pmap_kernel()			(&kernel_pmap_store)
#define pmap_resident_count(pmap)	((pmap)->pm_stats.resident_count)
#define	pmap_wired_count(pmap)		((pmap)->pm_stats.wired_count)
#define pmap_phys_address(frame)        ((paddr_t)(ptoa(frame)))

#define pmap_copy(dp,sp,d,l,s)		do { /* nothing */ } while (0)
#define pmap_update(pmap)		do { /* nothing (yet) */ } while (0)

#define	pmap_clear_modify(pg)		pmap_unsetbit(pg, PG_M)
#define	pmap_clear_reference(pg)	pmap_unsetbit(pg, PG_U)

#define pmap_proc_iflush(p,va,len)	do { /* nothing */ } while (0)

void pmap_bootstrap(vaddr_t);
void pmap_cache_ctrl(pmap_t, vaddr_t, vaddr_t, u_int);
boolean_t pmap_unsetbit(struct vm_page *, int);

#endif	/* _KERNEL */
d13 1
a13 1
#endif /* _MACHINE_PMAP_H_ */
@


1.34
log
@Simplify pmap_bootstrap() interface.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.33 2003/12/19 21:25:02 miod Exp $ */
d70 2
@


1.33
log
@The physical address of a pmap's segment table is only used to compute an
apr value used in pmap_activate(). So, rather than storing the address in the
pmap structure, store the precomputed apr value...
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.32 2003/12/14 22:08:01 miod Exp $ */
d71 1
a71 1
void pmap_bootstrap(vaddr_t, paddr_t *, paddr_t *, vaddr_t *, vaddr_t *);
@


1.32
log
@Replace pmap_testbit/pmap_changebit sequences with a tailor-made pmap_unsetbit
routine, in order to speed up pmap_clear_modify() and pmap_clear_reference().
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.31 2003/10/11 22:08:57 miod Exp $ */
a26 1
	sdt_entry_t		*pm_stpa;	/* physical pointer to sdt */
d28 1
d30 2
a33 4

	/* cpus using of this pmap; NCPU must be <= 32 */
	u_int32_t		pm_cpus;

@


1.31
log
@Nuke trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.30 2003/09/26 22:27:25 miod Exp $ */
d68 4
a71 1
#define pmap_update(pmap)	do { /* nothing (yet) */ } while (0)
d75 1
@


1.30
log
@Death to the bitfields, this time cmmu_apr_t and batc_entry_t. In the
process, remove duplicate batc defines.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.29 2003/01/24 09:57:41 miod Exp $ */
d40 1
a40 1
}; 
@


1.29
log
@Convert m88k pmap from physseg to VM_PAGE_MD.

This allows us to remove some ambiguities on how some functions are called,
remove some diagnostic checks for conditions that can never happen and
remove the ugly hack with "pmap_initialized".

Then, rework internal function interfaces and some logic so as to stop
fetching vm_page from a pa and the reverse every now and then - this makes
some pmap operations run much faster.

While there, various KNF and whitespace fixes, and rename some structure
fields to be closer to the m68k pmap.

per art@@'s idea.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.28 2003/01/24 00:51:52 miod Exp $ */
d18 2
a19 2
#include <machine/mmu.h>		/* batc_template_t, BATC_MAX, etc.*/
#include <machine/pcb.h>		/* pcb_t, etc.*/
d37 2
a38 2
	batc_template_t		pm_ibatc[BATC_MAX];	/* instruction BATCs */
	batc_template_t		pm_dbatc[BATC_MAX];	/* data BATCs */
@


1.28
log
@PMAP_{DE,}ACTIVATE are not used anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.27 2002/05/07 00:54:34 miod Exp $ */
a19 3
#include <machine/psl.h>		/* get standard goodies		*/

typedef sdt_entry_t *sdt_ptr_t;
a23 1
typedef struct pmap *pmap_t;
d27 5
a31 5
	sdt_ptr_t		sdt_paddr;	/* physical pointer to sdt */
	sdt_ptr_t		sdt_vaddr;	/* virtual pointer to sdt */
	int			ref_count;	/* reference count */
	struct simplelock	lock;
	struct pmap_statistics	stats;		/* pmap statistics */
d34 1
a34 1
	u_int32_t		cpus_using;
d37 2
a38 7
	batc_template_t		i_batc[BATC_MAX];	/* instruction BATCs */
	batc_template_t		d_batc[BATC_MAX];	/* data BATCs */
#endif

#ifdef	DEBUG
	pmap_t			next;
	pmap_t			prev;
d51 4
a54 5
typedef  struct pv_entry {
	struct pv_entry	*next;	/* next pv_entry */
	pmap_t		pmap;	/* pmap where mapping lies */
	vaddr_t		va;	/* virtual address for mapping */
} *pv_entry_t;
d63 2
a64 2
#define pmap_resident_count(pmap)	((pmap)->stats.resident_count)
#define	pmap_wired_count(pmap)		((pmap)->stats.wired_count)
d67 2
a68 1
#define pmap_update(pmap)	/* nothing (yet) */
@


1.27
log
@Spring pmap cleaning:
- update and fix comments
- clean the batc code (still not used by default)
- there was some KNF left to do
- fix incorrect locking behaviour in pmap_remove_all()
- fix incorrect pmap_remove_range() call which would cause the kernel to
  enter an infinite loop sometimes at shutdown
- fix an off-by-one page loop in pmap_protect()

This should bring the extra bits of stability I need to resume working on the
compiler...
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.26 2002/03/14 01:26:39 millert Exp $ */
a77 3

#define PMAP_ACTIVATE(proc)	pmap_activate(proc)
#define PMAP_DEACTIVATE(proc)	pmap_deactivate(proc)
@


1.26
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.25 2002/02/05 22:52:48 miod Exp $ */
a16 1
#define OMRON_PMAP
d29 1
d40 6
a45 1
#ifdef DEBUG
a48 6

	/* for OMRON_PMAP */
	batc_template_t		i_batc[BATC_MAX];	/* instruction BATCs */
	batc_template_t		d_batc[BATC_MAX];	/* data BATCs */
	/* end OMRON_PMAP */

d83 1
a83 1
void pmap_cache_ctrl(pmap_t, vaddr_t, vaddr_t, unsigned);
@


1.25
log
@Provide a definition for pmap_wired_count.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.24 2001/12/24 04:12:37 miod Exp $ */
d83 2
a84 2
void pmap_bootstrap __P((vaddr_t, paddr_t *, paddr_t *, vaddr_t *, vaddr_t *));
void pmap_cache_ctrl __P((pmap_t, vaddr_t, vaddr_t, unsigned));
@


1.24
log
@- completely change the mmu segment and page table structure definitions,
to use constant bitmasks instead of bitfields.
- remove unnecessary (as long as we are not running SMP) locks on the
physsegs.
- update the pmap code to take these changes into account, and gratuitously
change several names and code paths to be closer to existing m68k pmaps. It's
a bit faster now.
- change pmap.c's usage of vm_{offset,size}_t to {p,v}{addr,size}_t.
- remove dead or unused stuff from pmap.c, fix typos, etc

Tested on 187 and 188, should not make things worse for 197.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.23 2001/12/22 10:22:13 smurph Exp $ */
d75 1
@


1.23
log
@correct pmap_map.  mc88110 modifications.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.22 2001/12/16 23:49:46 miod Exp $ */
d23 1
a23 1
typedef struct sdt_entry *sdt_ptr_t;
d31 5
a35 5
	sdt_ptr_t           sdt_paddr;	    /* physical pointer to sdt */
	sdt_ptr_t           sdt_vaddr;	    /* virtual pointer to sdt */
	int                 ref_count;	    /* reference count */
	struct simplelock   lock;
	struct pmap_statistics stats;	    /* pmap statistics */
d38 1
a38 1
	unsigned long      cpus_using;
d41 2
a42 2
	pmap_t              next;
	pmap_t              prev;
d46 2
a47 2
	batc_template_t i_batc[BATC_MAX];  /* instruction BATCs */
	batc_template_t d_batc[BATC_MAX];  /* data BATCs */
d64 1
a64 1
	vm_offset_t	va;	/* virtual address for mapping */
d73 3
a75 4
#define	pmap_kernel()		(&kernel_pmap_store)
#define pmap_resident_count(pmap) ((pmap)->stats.resident_count)
/* Used in builtin/device_pager.c */
#define pmap_phys_address(frame)        ((vm_offset_t) (ptoa(frame)))
a80 1
#define PMAP_CONTEXT(pmap, thread)
d82 3
a84 34
/*
 * Modes used when calling pmap_cache_flush().
 */
#define	FLUSH_CACHE		0
#define	FLUSH_CODE_CACHE	1
#define	FLUSH_DATA_CACHE	2
#define	FLUSH_LOCAL_CACHE	3
#define	FLUSH_LOCAL_CODE_CACHE	4
#define	FLUSH_LOCAL_DATA_CACHE	5

/**************************************************************************/
/*** Prototypes for public functions defined in pmap.c ********************/
/**************************************************************************/

void pmap_bootstrap __P((vm_offset_t, vm_offset_t *, vm_offset_t *,
			 vm_offset_t *, vm_offset_t *));
void pmap_cache_ctrl __P((pmap_t, vm_offset_t, vm_offset_t, unsigned));
pt_entry_t *pmap_pte __P((pmap_t, vm_offset_t));
void pmap_cache_ctrl __P((pmap_t, vm_offset_t, vm_offset_t, unsigned));
void pmap_zero_page __P((vm_offset_t));
void pmap_remove_all __P((vm_offset_t));
vm_offset_t pmap_extract_unlocked __P((pmap_t, vm_offset_t));
void copy_to_phys __P((vm_offset_t, vm_offset_t, int));
void copy_from_phys __P((vm_offset_t, vm_offset_t, int));
void pmap_redzone __P((pmap_t, vm_offset_t));
void icache_flush __P((vm_offset_t));
void pmap_dcache_flush __P((pmap_t, vm_offset_t));
void pmap_cache_flush __P((pmap_t, vm_offset_t, int, int));
void pmap_print __P((pmap_t));
void pmap_print_trace __P((pmap_t, vm_offset_t, boolean_t));
vm_offset_t pmap_map __P((vm_offset_t, vm_offset_t, vm_offset_t,
			  vm_prot_t, unsigned int));
vm_offset_t pmap_map_batc __P((vm_offset_t, vm_offset_t, vm_offset_t,
			       vm_prot_t, unsigned int));
@


1.22
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.20 2001/12/05 00:11:51 millert Exp $ */
d31 8
a38 8
    sdt_ptr_t		sdt_paddr;	/* physical pointer to sdt */
    sdt_ptr_t		sdt_vaddr;	/* virtual pointer to sdt */
    int			ref_count;	/* reference count */
    struct simplelock	lock;
    struct pmap_statistics stats;	/* pmap statistics */
    
    /* cpus using of this pmap; NCPU must be <= 32 */
    unsigned long      cpus_using;
d41 2
a42 2
    pmap_t		next;
    pmap_t		prev;
d45 4
a48 4
   /* for OMRON_PMAP */
   batc_template_t i_batc[BATC_MAX];  /* instruction BATCs */
   batc_template_t d_batc[BATC_MAX];  /* data BATCs */
   /* end OMRON_PMAP */
d62 3
a64 3
   struct pv_entry   *next;      /* next pv_entry */
   pmap_t      pmap;    /* pmap where mapping lies */
   vm_offset_t va;      /* virtual address for mapping */
d83 1
d85 1
a85 1
 * Modes used when calling pmap_cache_fulsh().
d98 20
a117 63
vm_offset_t pmap_map(
		vm_offset_t virt,
		vm_offset_t start,
		vm_offset_t end,
		vm_prot_t prot);

vm_offset_t pmap_map_batc(
      vm_offset_t virt,
      vm_offset_t start,
      vm_offset_t end,
      vm_prot_t prot,
      unsigned cmode);

void pmap_bootstrap(
    vm_offset_t load_start, /* IN */
    vm_offset_t *phys_start, /* IN/OUT */
    vm_offset_t *phys_end, /* IN */
    vm_offset_t *virt_start, /* OUT */
    vm_offset_t *virt_end); /* OUT */

pt_entry_t *pmap_pte(pmap_t map, vm_offset_t virt);
void pmap_cache_ctrl(pmap_t pmap, vm_offset_t s, vm_offset_t e, unsigned mode);
void pmap_zero_page(vm_offset_t phys);
void pmap_remove_all(vm_offset_t phys);
vm_offset_t pmap_extract_unlocked(pmap_t pmap, vm_offset_t va);
void copy_to_phys(vm_offset_t srcva, vm_offset_t dstpa, int bytecount);
void copy_from_phys(vm_offset_t srcpa, vm_offset_t dstva, int bytecount);
void pmap_redzone(pmap_t pmap, vm_offset_t va);
void icache_flush(vm_offset_t pa);
void pmap_dcache_flush(pmap_t pmap, vm_offset_t va);
void pmap_cache_flush(pmap_t pmap, vm_offset_t virt, int bytes, int mode);
void pmap_print (pmap_t pmap);
void pmap_print_trace (pmap_t pmap, vm_offset_t va, boolean_t long_format);

#if 0
#ifdef OMRON_PMAP
 void pmap_set_batc(
    pmap_t pmap,
    boolean_t data,
    int i,
    vm_offset_t va,
    vm_offset_t pa,
    boolean_t super,
    boolean_t wt,
    boolean_t global,
    boolean_t ci,
    boolean_t wp,
    boolean_t valid);

 void use_batc(
    task_t task, 
    boolean_t data,         /* for data-cmmu ? */
    int i,                  /* batc number */
    vm_offset_t va,         /* virtual address */
    vm_offset_t pa,         /* physical address */
    boolean_t s,            /* for super-mode ? */
    boolean_t wt,           /* is writethrough */
    boolean_t g,            /* is global ? */
    boolean_t ci,           /* is cache inhibited ? */
    boolean_t wp,           /* is write-protected ? */
    boolean_t v);           /* is valid ? */
#endif
#endif /* 0 */
d120 1
a120 1
#endif /* endif  _MACHINE_PMAP_H_ */
@


1.22.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.24 2001/12/24 04:12:37 miod Exp $ */
d23 1
a23 1
typedef sdt_entry_t *sdt_ptr_t;
d31 8
a38 8
	sdt_ptr_t		sdt_paddr;	/* physical pointer to sdt */
	sdt_ptr_t		sdt_vaddr;	/* virtual pointer to sdt */
	int			ref_count;	/* reference count */
	struct simplelock	lock;
	struct pmap_statistics	stats;		/* pmap statistics */

	/* cpus using of this pmap; NCPU must be <= 32 */
	u_int32_t		cpus_using;
d41 2
a42 2
	pmap_t			next;
	pmap_t			prev;
d45 4
a48 4
	/* for OMRON_PMAP */
	batc_template_t		i_batc[BATC_MAX];	/* instruction BATCs */
	batc_template_t		d_batc[BATC_MAX];	/* data BATCs */
	/* end OMRON_PMAP */
d62 3
a64 3
	struct pv_entry	*next;	/* next pv_entry */
	pmap_t		pmap;	/* pmap where mapping lies */
	vaddr_t		va;	/* virtual address for mapping */
d73 4
a76 3
#define	pmap_kernel()			(&kernel_pmap_store)
#define pmap_resident_count(pmap)	((pmap)->stats.resident_count)
#define pmap_phys_address(frame)        ((paddr_t)(ptoa(frame)))
d82 78
a159 4

void pmap_bootstrap __P((vaddr_t, paddr_t *, paddr_t *, vaddr_t *, vaddr_t *));
void pmap_cache_ctrl __P((pmap_t, vaddr_t, vaddr_t, unsigned));

d162 1
a162 1
#endif /* _MACHINE_PMAP_H_ */
@


1.22.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.22.2.1 2002/01/31 22:55:18 niklas Exp $ */
d17 1
a29 1
/* #define PMAP_USE_BATC */
d40 6
a45 1
#ifdef	PMAP_USE_BATC
d48 1
a48 1
#endif
a49 4
#ifdef	DEBUG
	pmap_t			next;
	pmap_t			prev;
#endif
a74 1
#define	pmap_wired_count(pmap)		((pmap)->stats.wired_count)
d82 2
a83 2
void pmap_bootstrap(vaddr_t, paddr_t *, paddr_t *, vaddr_t *, vaddr_t *);
void pmap_cache_ctrl(pmap_t, vaddr_t, vaddr_t, u_int);
@


1.22.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d20 3
d27 1
d31 5
a35 5
	sdt_entry_t		*pm_stpa;	/* physical pointer to sdt */
	sdt_entry_t		*pm_stab;	/* virtual pointer to sdt */
	int			pm_count;	/* reference count */
	struct simplelock	pm_lock;
	struct pmap_statistics	pm_stats;	/* pmap statistics */
d38 1
a38 1
	u_int32_t		pm_cpus;
d41 7
a47 2
	batc_template_t		pm_ibatc[BATC_MAX];	/* instruction BATCs */
	batc_template_t		pm_dbatc[BATC_MAX];	/* data BATCs */
d60 5
a64 4
/* XXX - struct pv_entry moved to vmparam.h because of include ordering issues */

typedef struct pmap *pmap_t;
typedef struct pv_entry *pv_entry_t;
d73 2
a74 2
#define pmap_resident_count(pmap)	((pmap)->pm_stats.resident_count)
#define	pmap_wired_count(pmap)		((pmap)->pm_stats.wired_count)
d77 4
a80 2
#define pmap_copy(dp,sp,d,l,s)		do { /* nothing */ } while (0)
#define pmap_update(pmap)	do { /* nothing (yet) */ } while (0)
@


1.21
log
@Remove prototypes for non-existent mach leftovers, or duplicated in
<uvm/uvm_pmap.h>.
@
text
@d73 3
a75 2
#define	pmap_kernel()			(&kernel_pmap_store)
#define pmap_resident_count(pmap)	((pmap)->stats.resident_count)
a82 1

d84 1
a84 1
 * Modes used when calling pmap_cache_flush().
d93 67
a159 4
void pmap_bootstrap __P((vm_offset_t, vm_offset_t *, vm_offset_t *,
    vm_offset_t *, vm_offset_t *));
void pmap_cache_ctrl __P((pmap_t, vm_offset_t, vm_offset_t, unsigned));

d162 1
a162 1
#endif	/* _MACHINE_PMAP_H_ */
@


1.20
log
@Update pmap_update macro for arches Art missed.  Still just a noop.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.19 2001/11/28 16:13:28 art Exp $ */
d73 2
a74 3
#define	pmap_kernel()		(&kernel_pmap_store)
#define pmap_resident_count(pmap) ((pmap)->stats.resident_count)
/* Used in builtin/device_pager.c */
d82 1
d84 1
a84 1
 * Modes used when calling pmap_cache_fulsh().
d93 4
a96 67
/**************************************************************************/
/*** Prototypes for public functions defined in pmap.c ********************/
/**************************************************************************/

vm_offset_t pmap_map(
		vm_offset_t virt,
		vm_offset_t start,
		vm_offset_t end,
		vm_prot_t prot);

vm_offset_t pmap_map_batc(
      vm_offset_t virt,
      vm_offset_t start,
      vm_offset_t end,
      vm_prot_t prot,
      unsigned cmode);

void pmap_bootstrap(
    vm_offset_t load_start, /* IN */
    vm_offset_t *phys_start, /* IN/OUT */
    vm_offset_t *phys_end, /* IN */
    vm_offset_t *virt_start, /* OUT */
    vm_offset_t *virt_end); /* OUT */

pt_entry_t *pmap_pte(pmap_t map, vm_offset_t virt);
void pmap_cache_ctrl(pmap_t pmap, vm_offset_t s, vm_offset_t e, unsigned mode);
void pmap_zero_page(vm_offset_t phys);
void pmap_remove_all(vm_offset_t phys);
vm_offset_t pmap_extract_unlocked(pmap_t pmap, vm_offset_t va);
void copy_to_phys(vm_offset_t srcva, vm_offset_t dstpa, int bytecount);
void copy_from_phys(vm_offset_t srcpa, vm_offset_t dstva, int bytecount);
void pmap_redzone(pmap_t pmap, vm_offset_t va);
void icache_flush(vm_offset_t pa);
void pmap_dcache_flush(pmap_t pmap, vm_offset_t va);
void pmap_cache_flush(pmap_t pmap, vm_offset_t virt, int bytes, int mode);
void pmap_print (pmap_t pmap);
void pmap_print_trace (pmap_t pmap, vm_offset_t va, boolean_t long_format);

#if 0
#ifdef OMRON_PMAP
 void pmap_set_batc(
    pmap_t pmap,
    boolean_t data,
    int i,
    vm_offset_t va,
    vm_offset_t pa,
    boolean_t super,
    boolean_t wt,
    boolean_t global,
    boolean_t ci,
    boolean_t wp,
    boolean_t valid);

 void use_batc(
    task_t task, 
    boolean_t data,         /* for data-cmmu ? */
    int i,                  /* batc number */
    vm_offset_t va,         /* virtual address */
    vm_offset_t pa,         /* physical address */
    boolean_t s,            /* for super-mode ? */
    boolean_t wt,           /* is writethrough */
    boolean_t g,            /* is global ? */
    boolean_t ci,           /* is cache inhibited ? */
    boolean_t wp,           /* is write-protected ? */
    boolean_t v);           /* is valid ? */
#endif
#endif /* 0 */
d99 1
a99 1
#endif /* endif  _MACHINE_PMAP_H_ */
@


1.19
log
@zap some typedefs.
vm_map_t -> struct vm_map *
vm_map_entry_t -> struct vm_map_entry *
simple_lock_data_t -> struct simplelock

(uvm not done yet, coming in the next commit)
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.18 2001/11/28 15:34:16 art Exp $ */
d78 1
a78 1
#define pmap_update()		/* nothing */
@


1.18
log
@Make pmap_update functions into nops so that we can have a consistent
pmap_update API (right now it's nop).
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.17 2001/10/28 00:58:06 miod Exp $ */
d34 1
a34 1
    simple_lock_data_t	lock;
@


1.17
log
@Define kernel_pmap only if _KERNEL defined.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.16 2001/08/18 20:50:18 art Exp $ */
d77 2
@


1.16
log
@Move pmap_{de,}activate to vm/pmap.h, it's same on all archs.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.15 2001/08/12 21:34:48 miod Exp $ */
a52 1
extern	pmap_t	kernel_pmap;
d69 3
a71 2
extern struct pmap	kernel_pmap_store;
extern caddr_t vmmap;
@


1.15
log
@Actually, I'm not fond of include files including <uvm/uvm_extern.h>,
especially when this is in fact, not necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.14 2001/08/12 20:13:07 miod Exp $ */
a93 3

void pmap_activate(struct proc *p);
void pmap_deactivate(struct proc *p);
@


1.14
log
@Adapt to <vm/vm_prot.h> removal.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.13 2001/08/06 20:48:22 miod Exp $ */
a18 3
#include <machine/psl.h>		/* get standard goodies		*/
#include <vm/vm_param.h>
#include <uvm/uvm_extern>h>
d21 1
@


1.13
log
@Working kernel crash dumps.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.12 2001/06/14 21:30:40 miod Exp $ */
d21 1
a21 1
#include <vm/vm_prot.h>			/* vm_prot_t 			*/
@


1.12
log
@Big cleanup of VM issues:
o get rid of m88k_foo macros when there is an mi foo macro
o remove the ability, for the pmap module, to handle a native mmu page
  size different from the vm module page size. This allows some
  optimizations in pmap.c
o remove dead stuff from <machine/vmparam.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.11 2001/01/13 05:18:59 smurph Exp $ */
d73 1
@


1.11
log
@Booting kernel with MACHINE_NEW_NONCONTIG.  UVM code added but not working.
New stand config.  Lots of header fixes.  Can now cross-compile i386->m88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.10 2001/01/12 07:29:27 smurph Exp $ */
d77 1
a77 3
#define pmap_phys_address(frame)        ((vm_offset_t) (M88K_PTOB(frame)))
/* Used in kern/mach_timedev.c */
#define pmap_phys_to_frame(phys)        ((int) (M88K_BTOP(phys)))
a97 1
int pmap_check_transaction(pmap_t pmap, vm_offset_t va, vm_prot_t type);
a126 2
boolean_t pmap_verify_free(vm_offset_t phys);
boolean_t pmap_valid_page(vm_offset_t p);
@


1.10
log
@Update vm interface to MACHIN_NEW_NONCONTIG.  Fix compile warning in pcctwo.c
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.9 1999/09/27 20:46:19 smurph Exp $ */
d70 1
a70 1
#include <vm/vm.h>
d72 1
a72 4
#define PMAP_ACTIVATE(pmap, th, my_cpu)	_pmap_activate(pmap, th, my_cpu)
#define PMAP_DEACTIVATE(pmap, th, my_cpu) _pmap_deactivate(pmap, th, my_cpu)

#define PMAP_CONTEXT(pmap, thread)
d74 1
a75 1

a77 1

d81 3
a83 8
/*
 * Since Our PCB has no infomation about the mapping,
 * we have nothing to do in PMAP_PCB_INITIALIZE.
 * XXX
 */
/* Used in machine/pcb.c */
#define PMAP_PCB_INITIALIZE(x)

a97 2
void _pmap_activate(pmap_t pmap, pcb_t, int my_cpu);
void _pmap_deactivate(pmap_t pmap, pcb_t, int my_cpu);
a114 9
#ifdef JUNK
int pmap_attribute(
    pmap_t pmap,
    vm_offset_t address,
    vm_size_t size,
    vm_machine_attribute_t attribute,
    vm_machine_attribute_val_t* value);  /* IN/OUT */
#endif /* JUNK */

a126 1
pmap_t pmap_kernel(void);
d167 1
@


1.9
log
@Adding support for MVME188 and MVME197
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.8 1999/07/18 18:00:06 deraadt Exp $ */
d54 2
a55 1
#include <vm/vm.h>
d57 12
a68 1
#define PMAP_NULL ((pmap_t) 0)
d70 1
a70 1
extern	pmap_t	kernel_pmap;
d109 2
a110 2
void pmap_activate(pmap_t my_pmap, pcb_t, int cpu);
void pmap_deactivate(pmap_t pmap, pcb_t, int cpu);
@


1.9.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.11 2001/01/13 05:18:59 smurph Exp $ */
d54 2
d57 1
d60 2
a61 12
/* 	The PV (Physical to virtual) List.
 *
 * For each vm_page_t, pmap keeps a list of all currently valid virtual
 * mappings of that page. An entry is a pv_entry_t; the list is the
 * pv_head_table. This is used by things like pmap_remove, when we must
 * find and remove all mappings for a particular physical page.
 */
typedef  struct pv_entry {
   struct pv_entry   *next;      /* next pv_entry */
   pmap_t      pmap;    /* pmap where mapping lies */
   vm_offset_t va;      /* virtual address for mapping */
} *pv_entry_t;
d63 1
a63 1
#ifdef	_KERNEL
d65 1
a65 1
extern struct pmap	kernel_pmap_store;
a66 2
#define	pmap_kernel()		(&kernel_pmap_store)
#define pmap_resident_count(pmap) ((pmap)->stats.resident_count)
d69 1
d73 8
a80 3
#define PMAP_ACTIVATE(proc)	pmap_activate(proc)
#define PMAP_DEACTIVATE(proc)	pmap_deactivate(proc)
#define PMAP_CONTEXT(pmap, thread)
d95 4
a98 2
void pmap_activate(struct proc *p);
void pmap_deactivate(struct proc *p);
d114 9
d135 1
a175 1
#endif	/* _KERNEL */
@


1.9.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.9.4.1 2001/04/18 16:11:24 niklas Exp $ */
d77 3
a79 1
#define pmap_phys_address(frame)        ((vm_offset_t) (ptoa(frame)))
d100 1
d130 2
@


1.9.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.9.4.2 2001/07/04 10:20:04 niklas Exp $ */
d19 3
a23 1
#include <machine/psl.h>		/* get standard goodies		*/
a72 1
extern caddr_t vmmap;
d95 3
@


1.9.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d53 1
d70 2
a71 3
extern	pmap_t		kernel_pmap;
extern	struct pmap	kernel_pmap_store;
extern	caddr_t		vmmap;
@


1.9.4.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.9.4.4 2001/11/13 21:04:15 niklas Exp $ */
d34 1
a34 1
    struct simplelock	lock;
a76 2

#define pmap_update()		/* nothing */
@


1.9.4.6
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d23 1
a23 1
typedef sdt_entry_t *sdt_ptr_t;
d31 8
a38 8
	sdt_ptr_t		sdt_paddr;	/* physical pointer to sdt */
	sdt_ptr_t		sdt_vaddr;	/* virtual pointer to sdt */
	int			ref_count;	/* reference count */
	struct simplelock	lock;
	struct pmap_statistics	stats;		/* pmap statistics */

	/* cpus using of this pmap; NCPU must be <= 32 */
	u_int32_t		cpus_using;
d41 2
a42 2
	pmap_t			next;
	pmap_t			prev;
d45 4
a48 4
	/* for OMRON_PMAP */
	batc_template_t		i_batc[BATC_MAX];	/* instruction BATCs */
	batc_template_t		d_batc[BATC_MAX];	/* data BATCs */
	/* end OMRON_PMAP */
d62 3
a64 3
	struct pv_entry	*next;	/* next pv_entry */
	pmap_t		pmap;	/* pmap where mapping lies */
	vaddr_t		va;	/* virtual address for mapping */
d73 4
a76 4
#define	pmap_kernel()			(&kernel_pmap_store)
#define pmap_resident_count(pmap)	((pmap)->stats.resident_count)
#define	pmap_wired_count(pmap)		((pmap)->stats.wired_count)
#define pmap_phys_address(frame)        ((paddr_t)(ptoa(frame)))
d78 1
a78 1
#define pmap_update(pmap)	/* nothing (yet) */
d82 78
a159 4

void pmap_bootstrap __P((vaddr_t, paddr_t *, paddr_t *, vaddr_t *, vaddr_t *));
void pmap_cache_ctrl __P((pmap_t, vaddr_t, vaddr_t, unsigned));

d162 1
a162 1
#endif /* _MACHINE_PMAP_H_ */
@


1.9.4.7
log
@Merge in -current from about a week ago
@
text
@d83 2
a84 2
void pmap_bootstrap(vaddr_t, paddr_t *, paddr_t *, vaddr_t *, vaddr_t *);
void pmap_cache_ctrl(pmap_t, vaddr_t, vaddr_t, unsigned);
@


1.9.4.8
log
@Sync the SMP branch with 3.3
@
text
@d17 1
d21 3
d28 1
a29 1
/* #define PMAP_USE_BATC */
d31 5
a35 5
	sdt_entry_t		*pm_stpa;	/* physical pointer to sdt */
	sdt_entry_t		*pm_stab;	/* virtual pointer to sdt */
	int			pm_count;	/* reference count */
	struct simplelock	pm_lock;
	struct pmap_statistics	pm_stats;	/* pmap statistics */
d38 1
a38 1
	u_int32_t		pm_cpus;
d40 3
a42 3
#ifdef	PMAP_USE_BATC
	batc_template_t		pm_ibatc[BATC_MAX];	/* instruction BATCs */
	batc_template_t		pm_dbatc[BATC_MAX];	/* data BATCs */
d44 6
d61 5
a65 4
/* XXX - struct pv_entry moved to vmparam.h because of include ordering issues */

typedef struct pmap *pmap_t;
typedef struct pv_entry *pv_entry_t;
d74 2
a75 2
#define pmap_resident_count(pmap)	((pmap)->pm_stats.resident_count)
#define	pmap_wired_count(pmap)		((pmap)->pm_stats.wired_count)
d78 4
a81 2
#define pmap_copy(dp,sp,d,l,s)		do { /* nothing */ } while (0)
#define pmap_update(pmap)	do { /* nothing (yet) */ } while (0)
d84 1
a84 1
void pmap_cache_ctrl(pmap_t, vaddr_t, vaddr_t, u_int);
@


1.9.4.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d18 2
a19 2
#include <machine/mmu.h>
#include <machine/pcb.h>
d27 1
a28 1
	u_int32_t		pm_apr;
d30 3
d35 1
a35 2
	struct simplelock	pm_lock;
	struct pmap_statistics	pm_stats;	/* pmap statistics */
d37 2
a38 2
	u_int32_t		pm_ibatc[BATC_MAX];	/* instruction BATCs */
	u_int32_t		pm_dbatc[BATC_MAX];	/* data BATCs */
d40 1
a40 1
};
d68 1
a68 4
#define pmap_update(pmap)		do { /* nothing (yet) */ } while (0)

#define	pmap_clear_modify(pg)		pmap_unsetbit(pg, PG_M)
#define	pmap_clear_reference(pg)	pmap_unsetbit(pg, PG_U)
a71 1
boolean_t pmap_unsetbit(struct vm_page *, int);
@


1.9.4.10
log
@Merge with the trunk
@
text
@d71 1
a71 3
#define pmap_proc_iflush(p,va,len)	do { /* nothing */ } while (0)

void pmap_bootstrap(vaddr_t);
@


1.8
log
@pmap_activate() and pmap_deactivate() are MD
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.6 1999/05/29 04:41:45 smurph Exp $ */
d38 3
d97 2
a98 2
void pmap_activate(pmap_t my_pmap, pcb_t);
void pmap_deactivate(pmap_t pmap, pcb_t);
@


1.7
log
@fix pmap_activate() and pmap_deactivate() arguments after art changed things
@
text
@d94 2
@


1.6
log
@Added vme bus device drivers. MVME328, MVME376, MVME332
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.5 1999/02/09 06:36:27 smurph Exp $ */
a93 2
void pmap_activate(pmap_t my_pmap, pcb_t);
void pmap_deactivate(pmap_t pmap, pcb_t);
@


1.5
log
@Added kernel support for user debugging.  Fixed file ID's
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.1 1998/12/15 06:02:55 smurph Exp $ */
d97 6
@


1.4
log
@Commit for the first real OpenBSD mvme88k kernel.
@
text
@d1 1
@


1.3
log
@Cleanup after import. This also seems to bring up the current version.
@
text
@d35 1
a35 1

@


1.2
log
@This is a remove to get rid of the old mvme88k port which was incomplete
to replace it with a working version. The kernel compiles and works
at least.  The new version will be imported shortly.
@
text
@d2 11
a12 1
 * HISTORY
a17 5
/* use builtin memcpy in gcc 2.0 */
#if (__GNUC__ > 1)
#define bcopy(a,b,c) memcpy(b,a,c)
#endif

a94 1
void pmap_protect(pmap_t pmap, vm_offset_t s, vm_offset_t e, vm_prot_t prot);
a95 11
void pmap_page_protect(vm_offset_t phys, vm_prot_t prot);

vm_offset_t pmap_map(
      vm_offset_t virt,
      vm_offset_t start,
      vm_offset_t end,
      vm_prot_t prot
  #ifdef OMRON_PMAP
      , unsigned cmode
  #endif
      );
a103 8
void pmap_enter(
      pmap_t pmap,
      vm_offset_t va,
      vm_offset_t pa,
      vm_prot_t prot,
      boolean_t wired);


a119 19
#ifdef MACH_KERNEL
 void pmap_init();
#else
 void pmap_init(vm_offset_t phys_start, vm_offset_t phys_end);
#endif

void pmap_copy(
    pmap_t dst_pmap,
    pmap_t src_pmap,
    vm_offset_t dst_addr,
    vm_size_t len,
    vm_offset_t src_addr);

void pmap_pageable(
    pmap_t pmap,
    vm_offset_t start,
    vm_offset_t end,
    boolean_t pageable);

a122 6
pmap_t pmap_create(vm_size_t size);
void pmap_pinit(pmap_t p);
void pmap_release(pmap_t p);
void pmap_destroy(pmap_t p);
void pmap_reference(pmap_t p);
void pmap_remove(pmap_t map, vm_offset_t s, vm_offset_t e);
a123 2
void pmap_change_wiring(pmap_t map, vm_offset_t v, boolean_t wired);
vm_offset_t pmap_extract(pmap_t pmap, vm_offset_t va);
a124 2
void pmap_update(void);
void pmap_collect(pmap_t pmap);
a125 1
void pmap_copy_page(vm_offset_t src, vm_offset_t dst);
a128 4
void pmap_clear_modify(vm_offset_t phys);
boolean_t pmap_is_modified(vm_offset_t phys);
void pmap_clear_reference(vm_offset_t phys);
boolean_t pmap_is_referenced(vm_offset_t phys);
a135 3
void pmap_virtual_space(vm_offset_t *startp, vm_offset_t *endp);
unsigned pmap_free_pages(void);
boolean_t pmap_next_page(vm_offset_t *addrp);
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@initial 88k import; code by nivas and based on mach luna88k
@
text
@@


1.1.1.2
log
@Third try at importing the mvme88k port. This is a working kernel
from nivas.
Userland and compiler still need to be worked on.
Make certain what directory the import is done from.
@
text
@d2 1
a2 11
 * Mach Operating System
 * Copyright (c) 1991 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
d8 5
d90 1
d92 11
d111 8
d135 19
d157 6
d164 2
d167 2
d170 1
d174 4
d185 3
@
