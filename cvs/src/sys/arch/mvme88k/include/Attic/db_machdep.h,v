head	1.31;
access;
symbols
	OPENBSD_5_5:1.30.0.36
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.30.0.32
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.30.0.30
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.28
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.26
	OPENBSD_5_0:1.30.0.24
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.30.0.22
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.30.0.20
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.30.0.16
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.30.0.18
	OPENBSD_4_6_BASE:1.30
	OPENBSD_4_5:1.30.0.14
	OPENBSD_4_5_BASE:1.30
	OPENBSD_4_4:1.30.0.12
	OPENBSD_4_4_BASE:1.30
	OPENBSD_4_3:1.30.0.10
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.30.0.8
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.30.0.6
	OPENBSD_4_1_BASE:1.30
	OPENBSD_4_0:1.30.0.4
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.30.0.2
	OPENBSD_3_9_BASE:1.30
	OPENBSD_3_8:1.29.0.6
	OPENBSD_3_8_BASE:1.29
	OPENBSD_3_7:1.29.0.4
	OPENBSD_3_7_BASE:1.29
	OPENBSD_3_6:1.29.0.2
	OPENBSD_3_6_BASE:1.29
	SMP_SYNC_A:1.29
	SMP_SYNC_B:1.29
	OPENBSD_3_5:1.27.0.2
	OPENBSD_3_5_BASE:1.27
	OPENBSD_3_4:1.21.0.8
	OPENBSD_3_4_BASE:1.21
	UBC_SYNC_A:1.21
	OPENBSD_3_3:1.21.0.6
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.21.0.4
	OPENBSD_3_2_BASE:1.21
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	UBC_SYNC_B:1.21
	UBC:1.18.0.2
	UBC_BASE:1.18
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.5.0.10
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.8
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.6
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.4
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	mvme88kport:1.1.1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	first_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2014.03.18.22.36.36;	author miod;	state dead;
branches;
next	1.30;

1.30
date	2005.10.24.19.28.29;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2004.04.26.14.31.11;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2004.04.26.12.34.05;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2004.01.12.07.46.16;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2004.01.07.16.22.18;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2003.12.21.13.23.34;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2003.10.05.20.23.53;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2003.09.26.19.04.28;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2003.09.16.20.49.05;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.14.03.15.57;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.03.14.01.26.39;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2001.12.22.08.31.05;	author smurph;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.16.23.49.46;	author miod;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2001.12.13.08.55.51;	author smurph;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.27.05.35.36;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.09.00.12.19;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.06.00.30.38;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.31.01.06.29;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.26.14.31.07;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.12.21.34.48;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.12.21.00.14;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.12.20.13.07;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.16.00.05.24;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.09.05.44.40;	author smurph;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.08.00.03.22;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	99.02.09.06.36.26;	author smurph;	state Exp;
branches
	1.5.6.1;
next	1.4;

1.4
date	98.12.15.04.45.49;	author smurph;	state Exp;
branches;
next	1.3;

1.3
date	97.03.03.20.20.56;	author rahnds;	state Exp;
branches;
next	1.2;

1.2
date	97.03.03.19.07.26;	author rahnds;	state dead;
branches;
next	1.1;

1.1
date	95.10.18.10.54.24;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.10.54.24;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.03.03.19.31.46;	author rahnds;	state Exp;
branches;
next	;

1.5.6.1
date	2001.04.18.16.11.16;	author niklas;	state Exp;
branches;
next	1.5.6.2;

1.5.6.2
date	2001.10.31.03.01.18;	author nate;	state Exp;
branches;
next	1.5.6.3;

1.5.6.3
date	2001.11.13.21.04.15;	author niklas;	state Exp;
branches;
next	1.5.6.4;

1.5.6.4
date	2001.12.05.00.39.12;	author niklas;	state Exp;
branches;
next	1.5.6.5;

1.5.6.5
date	2002.03.06.02.04.44;	author niklas;	state Exp;
branches;
next	1.5.6.6;

1.5.6.6
date	2002.03.28.10.36.02;	author niklas;	state Exp;
branches;
next	1.5.6.7;

1.5.6.7
date	2004.02.19.10.49.07;	author niklas;	state Exp;
branches;
next	1.5.6.8;

1.5.6.8
date	2004.06.05.23.09.50;	author niklas;	state Exp;
branches;
next	;

1.18.2.1
date	2002.01.31.22.55.18;	author niklas;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2002.06.11.03.37.10;	author art;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/* $OpenBSD: db_machdep.h,v 1.30 2005/10/24 19:28:29 miod Exp $ */
/* public domain */
#include <m88k/db_machdep.h>

#ifdef DDB

void m88k_db_prom_cmd(db_expr_t, int, db_expr_t, char *);

#define	EXTRA_MACHDEP_COMMANDS \
	{ "prom",	m88k_db_prom_cmd,		0,	NULL },

#endif
@


1.30
log
@Factorize db_interface code between luna88k and mvme88k, removing dead code
in the process; the arch-agnostic code keeps the ability for a specific
machine to define its own machine commands, such as "machine prom" for
mvme88k, in addition to the ``regular'' m88k machine commands.
@
text
@d1 1
a1 1
/* $OpenBSD: db_machdep.h,v 1.29 2004/04/26 14:31:11 miod Exp $ */
@


1.29
log
@Fix RCSID
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d4 9
@


1.28
log
@Start factorizing luna88k and mvme88k common parts.
For now, include files only.
@
text
@d1 1
a1 1
/* $OpenBSD */
@


1.27
log
@Get rid of that ugly m88100_saved_state structure, use trapframe everywhere
instead.

Allow struct reg and struct trapframe to live different lives and grow
separately. Righty now they are still the same, and code expects a trapframe
to always start with a struct reg. This may change...
@
text
@d1 3
a3 167
/*	$OpenBSD: db_machdep.h,v 1.26 2004/01/07 16:22:18 miod Exp $ */
/*
 * Mach Operating System
 * Copyright (c) 1993-1991 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON AND OMRON ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON AND OMRON DISCLAIM ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*
 * Machine-dependent defined for the new kernel debugger
 */

#ifndef  _M88K_DB_MACHDEP_H_
#define  _M88K_DB_MACHDEP_H_

/* trap numbers used by ddb */
#define	DDB_ENTRY_BKPT_NO	130
#define	DDB_ENTRY_TRACE_NO	131
#define DDB_ENTRY_TRAP_NO	132

#ifndef	_LOCORE

#include <machine/pcb.h>
#include <machine/trap.h>

#include <uvm/uvm_param.h>

/*
 * The low two bits of sxip, snip, sfip have valid bits
 * in them that need to masked to get the correct addresses
 */
#define PC_REGS(regs) \
	cputyp == CPU_88110 ? ((regs)->exip & ~3) : \
	  (((regs)->sxip & 2) ? (regs)->sxip & ~3 : \
	    ((regs)->snip & 2 ? (regs)->snip & ~3 : (regs)->sfip & ~3))

/* inst_return(ins) - is the instruction a function call return.
 * Not mutually exclusive with inst_branch. Should be a jmp r1. */
#define inst_return(I) (((I)&0xfffffbffU) == 0xf400c001U ? TRUE : FALSE)

/*
 * inst_call - function call predicate: is the instruction a function call.
 * Could be either bsr or jsr
 */
#define inst_call(I) ({ unsigned i = (I); \
	((((i) & 0xf8000000U) == 0xc8000000U || /*bsr*/ \
          ((i) & 0xfffffbe0U) == 0xf400c800U)   /*jsr*/ \
	? TRUE : FALSE) \
;})

#ifdef DDB

/*
 * This is a hack so that mc88100 can use software single step
 * and mc88110 can use the wonderful hardware single step
 * feature. XXX smurph
 */
#define INTERNAL_SSTEP		/* Use local Single Step routines */

#define BKPT_SIZE	(4)	/* number of bytes in bkpt inst. */
#define BKPT_INST	(0xF000D000 | DDB_ENTRY_BKPT_NO) /* tb0, 0,r0, vector 130 */
#define BKPT_SET(inst)	(BKPT_INST)

/* Entry trap for the debugger - used for inline assembly breaks*/
#define ENTRY_ASM       	"tb0 0, r0, 132"

typedef	vaddr_t		db_addr_t;
typedef	long		db_expr_t;
typedef	struct reg	db_regs_t;
extern db_regs_t	ddb_regs;	/* register state */
#define	DDB_REGS	(&ddb_regs)

extern int db_noisy;

unsigned inst_load(unsigned);
unsigned inst_store(unsigned);
boolean_t inst_branch(unsigned);
db_addr_t next_instr_address(db_addr_t, unsigned);
db_addr_t branch_taken(u_int, db_addr_t, db_expr_t (*)(db_regs_t *, int),
		       db_regs_t *);
int ddb_break_trap(int type, db_regs_t *eframe);
int ddb_entry_trap(int level, db_regs_t *eframe);

/* breakpoint/watchpoint foo */
#define IS_BREAKPOINT_TRAP(type,code) ((type)==T_KDB_BREAK)
#if defined(T_WATCHPOINT)
#define IS_WATCHPOINT_TRAP(type,code) ((type)==T_KDB_WATCH)
#else
#define IS_WATCHPOINT_TRAP(type,code) 0
#endif /* T_WATCHPOINT */

/* we don't want coff support */
#define DB_NO_COFF 1

#ifdef INTERNAL_SSTEP
db_expr_t getreg_val(db_regs_t *, int);
void db_set_single_step(db_regs_t *);
void db_clear_single_step(db_regs_t *);
#else
/* need software single step */
#define SOFTWARE_SSTEP 1 /* we need this for mc88100 */
#endif

/*
 * Debugger can get to any address space
 */

#define DB_ACCESS_LEVEL DB_ACCESS_ANY

#define DB_VALID_KERN_ADDR(addr) (!badaddr((void *)(addr), 1))
#define DB_VALID_ADDRESS(addr,user) \
  (user ? db_check_user_addr(addr) : DB_VALID_KERN_ADDR(addr))

/* instruction type checking - others are implemented in db_sstep.c */

#define inst_trap_return(ins)  ((ins) == 0xf400fc00U)

/* don't need to load symbols */
#define DB_SYMBOLS_PRELOADED 1

/* machine specific commands have been added to ddb */
#define DB_MACHINE_COMMANDS 1

/*
 * This routine should return true for instructions that result in unconditonal
 * transfers of the flow of control. (Unconditional Jumps, subroutine calls,
 * subroutine returns, etc).
 *
 *  Trap and return from trap  should not  be listed here.
 */
#define inst_unconditional_flow_transfer(I) ({ unsigned i = (I); \
    ((((i) & 0xf0000000U) == 0xc0000000U || /* br, bsr */ \
      ((i) & 0xfffff3e0U) == 0xf400c000U)   /* jmp, jsr */ \
     ? TRUE: FALSE) \
;})

/* Return true if the instruction has a delay slot.  */
#define db_branch_is_delayed(I)	inst_delayed(I)

#define	db_printf_enter	db_printing

int m88k_print_instruction(unsigned iadr, long inst);

#endif	/* DDB */
#endif	/* _LOCORE */

#endif	/* _M88K_DB_MACHDEP_H_ */
@


1.26
log
@Remove duplicate definitions with MI ddb headers, and fix db_stack_trace_print
prototype in the process.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.25 2003/12/21 13:23:34 miod Exp $ */
d43 1
a43 1
#include <machine/pcb.h>	/* m88100_saved_state */
d52 4
a55 3
#define PC_REGS(regs) cputyp == CPU_88110 ? (regs->exip & ~3) :\
	((regs->sxip & 2) ?  regs->sxip & ~3 : \
	(regs->snip & 2 ? regs->snip & ~3 : regs->sfip & ~3))
d89 1
a89 1
typedef	struct m88100_saved_state db_regs_t;
@


1.25
log
@Switch db_expr_t from int to long, per consistency with other platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.24 2003/10/05 20:23:53 miod Exp $ */
a92 1
extern int quiet_db_read_bytes;
@


1.24
log
@Correct db_{read,write}_bytes prototypes and use the official ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.23 2003/09/26 19:04:28 miod Exp $ */
d87 1
a87 1
typedef	int		db_expr_t;
d116 1
a116 1
extern register_t getreg_val(db_regs_t *, int);
@


1.23
log
@Death to bitfields, this time "struct psr".
Also clean <machine/psl.h> contents while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.22 2003/09/16 20:49:05 miod Exp $ */
d72 1
a72 1
/* 
d74 1
a74 1
 * and mc88110 can use the wonderful hardware single step 
d86 2
a87 2
typedef	vm_offset_t		db_addr_t;
typedef	int			db_expr_t;
d117 2
a118 2
void db_set_single_step(register db_regs_t *);
void db_clear_single_step(register db_regs_t *);
d122 1
a122 1
#endif 
@


1.22
log
@Clean <machine/db_machdep.h> of unused material. Also, let this file be
includable even without option DDB, in which case it will only define
the PC_REGS(), inst_return() and inst_call() macros; this removes the need
to declare them a second time in trap.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.21 2002/03/14 03:15:57 millert Exp $ */
a43 1
#include <machine/psl.h>
@


1.21
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.20 2002/03/14 01:26:39 millert Exp $ */
a27 3
/*
 * HISTORY
 */
d49 24
a92 35
/*
 * the low two bits of sxip, snip, sfip have valid bits
 * in them that need to masked to get the correct addresses
 */

#define m88k_pc(regs) \
({ \
    int ret; \
 \
    if (cputyp == CPU_88110) \
	ret = regs->exip & ~3; \
    else if (regs->sxip & 2) /* is valid */ \
	ret = regs->sxip & ~3; \
    else if (regs->snip & 2) \
	ret = regs->snip & ~3; \
    else if (regs->sfip & 2) \
	ret = regs->sfip & ~3; \
    /* we are in trouble - none of the program counters is valid */ \
    ret;  \
})

/*
 * This is an actual function due to the fact that the sxip
 * or snip could be nooped out due to a jmp or rte
 */
#define PC_REGS(regs) cputyp == CPU_88110 ? (regs->exip & ~3) :\
	((regs->sxip & 2) ?  regs->sxip & ~3 : \
	(regs->snip & 2 ? regs->snip & ~3 : regs->sfip & ~3))
#define l_PC_REGS(regs) cputyp == CPU_88110 ? (regs->exip & ~3) :\
	((regs->sxip & 2) ?  regs->sxip : \
	(regs->snip & 2 ? regs->snip : regs->sfip ))

#define pC_REGS(regs) cputyp == CPU_88110 ? (regs->exip & ~3) :\
	(regs->sxip & 2) ? regs->sxip : (regs->snip & 2 ? \
				regs->snip : regs->sfip)
a93 4
#define NOISY(x) if (db_noisy) x
#define NOISY2(x) if (db_noisy >= 2) x
#define NOISY3(x) if (db_noisy >= 3) x

a95 5
/* These versions are not constantly doing SPL */
/*#define	cnmaygetc	db_getc*/
/*#define	cngetc		db_getc*/
/*#define	cnputc		db_putc*/

a143 14
/* inst_return(ins) - is the instruction a function call return.
 * Not mutually exclusive with inst_branch. Should be a jmp r1. */
#define inst_return(I) (((I)&0xfffffbffU) == 0xf400c001U ? TRUE : FALSE)

#ifdef __GNUC__
/*
 * inst_call - function call predicate: is the instruction a function call.
 * Could be either bsr or jsr
 */
#define inst_call(I) ({ unsigned i = (I); \
	((((i) & 0xf8000000U) == 0xc8000000U || /*bsr*/ \
          ((i) & 0xfffffbe0U) == 0xf400c800U)   /*jsr*/ \
	? TRUE : FALSE) \
;})
a160 2
#endif	/* __GNUC__ */

d165 1
@


1.20
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.19 2001/12/22 08:31:05 smurph Exp $ */
d123 2
a124 3
db_addr_t branch_taken __P((u_int, db_addr_t,
			    db_expr_t (*)(db_regs_t *, int),
			    db_regs_t *));
d154 1
a154 1
#define DB_VALID_KERN_ADDR(addr) (!badaddr((void*)(addr), 1))
@


1.19
log
@mc88110 support in ddb.  Bring in bit definitions.
We can support hardware sstep for mc88110 and
software sstep for mc88100.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.18 2001/12/16 23:49:46 miod Exp $ */
d119 4
a122 4
unsigned inst_load __P((unsigned));
unsigned inst_store __P((unsigned));
boolean_t inst_branch __P((unsigned));
db_addr_t next_instr_address __P((db_addr_t, unsigned));
d124 1
a124 1
			    db_expr_t (*) __P((db_regs_t *, int)),
d126 2
a127 2
int ddb_break_trap __P((int type, db_regs_t *eframe));
int ddb_entry_trap __P((int level, db_regs_t *eframe));
d141 3
a143 3
extern register_t getreg_val __P((db_regs_t *, int));
void db_set_single_step __P((register db_regs_t *));
void db_clear_single_step __P((register db_regs_t *));
d203 1
a203 1
int m88k_print_instruction __P((unsigned iadr, long inst));
@


1.18
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.16 2001/11/27 05:35:36 miod Exp $ */
d52 9
a60 2
#define BKPT_SIZE	(4)		/* number of bytes in bkpt inst. */
#define BKPT_INST	(0xF000D000 | DDB_ENTRY_BKPT_NO)	/* tb0, 0,r0, vector 130 */
d81 3
a83 1
    if (regs->sxip & 2) /* is valid */ \
d97 2
a98 1
#define PC_REGS(regs) ((regs->sxip & 2) ?  regs->sxip & ~3 : \
d100 2
a101 1
#define l_PC_REGS(regs) ((regs->sxip & 2) ?  regs->sxip : \
d104 2
a105 1
#define pC_REGS(regs) (regs->sxip & 2) ? regs->sxip : (regs->snip & 2 ? \
d124 2
a125 1
    db_expr_t (*) __P((db_regs_t *, int)), db_regs_t *));
d140 5
d146 2
a147 1
#define SOFTWARE_SSTEP 1 /* we need this XXX nivas */
@


1.18.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.19 2001/12/22 08:31:05 smurph Exp $ */
d52 2
a53 9
/* 
 * This is a hack so that mc88100 can use software single step
 * and mc88110 can use the wonderful hardware single step 
 * feature. XXX smurph
 */
#define INTERNAL_SSTEP		/* Use local Single Step routines */

#define BKPT_SIZE	(4)	/* number of bytes in bkpt inst. */
#define BKPT_INST	(0xF000D000 | DDB_ENTRY_BKPT_NO) /* tb0, 0,r0, vector 130 */
d74 1
a74 3
    if (cputyp == CPU_88110) \
	ret = regs->exip & ~3; \
    else if (regs->sxip & 2) /* is valid */ \
d88 1
a88 2
#define PC_REGS(regs) cputyp == CPU_88110 ? (regs->exip & ~3) :\
	((regs->sxip & 2) ?  regs->sxip & ~3 : \
d90 1
a90 2
#define l_PC_REGS(regs) cputyp == CPU_88110 ? (regs->exip & ~3) :\
	((regs->sxip & 2) ?  regs->sxip : \
d93 1
a93 2
#define pC_REGS(regs) cputyp == CPU_88110 ? (regs->exip & ~3) :\
	(regs->sxip & 2) ? regs->sxip : (regs->snip & 2 ? \
d112 1
a112 2
			    db_expr_t (*) __P((db_regs_t *, int)),
			    db_regs_t *));
a126 5
#ifdef INTERNAL_SSTEP
extern register_t getreg_val __P((db_regs_t *, int));
void db_set_single_step __P((register db_regs_t *));
void db_clear_single_step __P((register db_regs_t *));
#else
d128 1
a128 2
#define SOFTWARE_SSTEP 1 /* we need this for mc88100 */
#endif 
@


1.18.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.18.2.1 2002/01/31 22:55:18 niklas Exp $ */
d119 9
a127 8
unsigned inst_load(unsigned);
unsigned inst_store(unsigned);
boolean_t inst_branch(unsigned);
db_addr_t next_instr_address(db_addr_t, unsigned);
db_addr_t branch_taken(u_int, db_addr_t, db_expr_t (*)(db_regs_t *, int),
		       db_regs_t *);
int ddb_break_trap(int type, db_regs_t *eframe);
int ddb_entry_trap(int level, db_regs_t *eframe);
d141 3
a143 3
extern register_t getreg_val(db_regs_t *, int);
void db_set_single_step(register db_regs_t *);
void db_clear_single_step(register db_regs_t *);
d155 1
a155 1
#define DB_VALID_KERN_ADDR(addr) (!badaddr((void *)(addr), 1))
d203 1
a203 1
int m88k_print_instruction(unsigned iadr, long inst);
@


1.17
log
@Support for MVME197 completed.  Fix SPL defs.
@
text
@d52 1
a52 2
#define INTERNAL_SSTEP		/* Use local Single Step routines */
#define BKPT_SIZE	(4)	/* number of bytes in bkpt inst. */
d74 1
a74 3
    if (cputyp == CPU_88110) \
            ret = regs->sxip & ~3; \
    else if (regs->sxip & 2) /* is valid */ \
d88 1
a88 2
#define PC_REGS(regs) cputyp == CPU_88110 ? (regs->exip & ~3) :\
	((regs->sxip & 2) ?  regs->sxip & ~3 : \
d90 1
a90 2
#define l_PC_REGS(regs) cputyp == CPU_88110 ? (regs->exip & ~3) :\
	((regs->sxip & 2) ?  regs->sxip : \
d93 1
a93 2
#define pC_REGS(regs) cputyp == CPU_88110 ? (regs->exip & ~3) :\
	(regs->sxip & 2) ? regs->sxip : (regs->snip & 2 ? \
a126 5
#ifdef INTERNAL_SSTEP
extern register_t getreg_val __P((db_regs_t *, int));
void db_set_single_step __P((register db_regs_t *));
void db_clear_single_step __P((register db_regs_t *));
#else
d128 1
a128 2
#define SOFTWARE_SSTEP 1 /* we need this for mc88100 */
#endif 
@


1.16
log
@Declare symbolic names for the various interrupts used by ddb.
Make this file #include-able from locore.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.15 2001/11/09 00:12:19 miod Exp $ */
d52 2
a53 1
#define BKPT_SIZE	(4)		/* number of bytes in bkpt inst. */
d75 3
a77 1
    if (regs->sxip & 2) /* is valid */ \
d91 2
a92 1
#define PC_REGS(regs) ((regs->sxip & 2) ?  regs->sxip & ~3 : \
d94 2
a95 1
#define l_PC_REGS(regs) ((regs->sxip & 2) ?  regs->sxip : \
d98 2
a99 1
#define pC_REGS(regs) (regs->sxip & 2) ? regs->sxip : (regs->snip & 2 ? \
d133 5
d139 2
a140 1
#define SOFTWARE_SSTEP 1 /* we need this XXX nivas */
@


1.15
log
@Ouch, more variables declarations in .h files lacking ``extern'' safety
belts.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.14 2001/11/06 00:30:38 art Exp $ */
d39 7
d53 1
a53 1
#define BKPT_INST	(0xF000D082U)	/* tb0, 0,r0, vector 132 */
a57 1
#define DDB_ENTRY_TRAP_NO	132
d185 2
@


1.14
log
@Kill vm/vm_param.h, move it to uvm/uvm_param.h
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.13 2001/08/31 01:06:29 miod Exp $ */
d53 5
a57 5
typedef vm_offset_t   db_addr_t;
typedef int           db_expr_t;
typedef struct m88100_saved_state db_regs_t;
db_regs_t	      ddb_regs;	/* register state */
#define DDB_REGS      (&ddb_regs)
@


1.13
log
@There's no point having a Debugger() clone here.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.12 2001/08/26 14:31:07 miod Exp $ */
d43 1
a43 1
#include <vm/vm_param.h>
@


1.12
log
@Add prototypes, fix compilation warnings, random style fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.11 2001/08/12 21:34:48 miod Exp $ */
a51 2

void gimmeabreak __P((void));
@


1.11
log
@Actually, I'm not fond of include files including <uvm/uvm_extern.h>,
especially when this is in fact, not necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.10 2001/08/12 21:00:14 mickey Exp $ */
d45 3
a47 3
#define BKPT_SIZE        (4)                /* number of bytes in bkpt inst. */
#define BKPT_INST       (0xF000D082U)             /* tb0, 0,r0, vector 132 */
#define BKPT_SET(inst)  (BKPT_INST)
@


1.10
log
@vm_inherit.h no more
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.9 2001/08/12 20:13:07 miod Exp $ */
a38 3
#include <sys/types.h>
#include <vm/vm_param.h>
#include <uvm/uvm_extern.h>
d42 2
@


1.9
log
@Adapt to <vm/vm_prot.h> removal.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.8 2001/03/16 00:05:24 miod Exp $ */
a40 1
#include <vm/vm_inherit.h>
@


1.8
log
@More function prototypes.
Move badwordaddr() to a macro.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.7 2001/03/09 05:44:40 smurph Exp $ */
a39 1
#include <vm/vm_prot.h>
d42 1
a42 1
/*#include <vm/lock.h>*/
@


1.7
log
@kernel will compile with -Werror.  Added intr.h
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.6 2001/03/08 00:03:22 miod Exp $ */
d182 2
@


1.6
log
@Some warning hunting.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.5 1999/02/09 06:36:26 smurph Exp $ */
d112 2
@


1.5
log
@Added kernel support for user debugging.  Fixed file ID's
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.1 1998/12/15 04:45:50 smurph Exp $ */
d37 1
a37 1
#define  _M88K_DB_MACHDEP_H_ 1
d56 2
d104 8
a111 1
#define	cnputc		db_putc
@


1.5.6.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.8 2001/03/16 00:05:24 miod Exp $ */
d37 1
a37 1
#define  _M88K_DB_MACHDEP_H_
a55 2
void gimmeabreak __P((void));

d102 1
a102 10
/*#define	cnputc		db_putc*/

unsigned inst_load __P((unsigned));
unsigned inst_store __P((unsigned));
boolean_t inst_branch __P((unsigned));
db_addr_t next_instr_address __P((db_addr_t, unsigned));
db_addr_t branch_taken __P((u_int, db_addr_t,
    db_expr_t (*) __P((db_regs_t *, int)), db_regs_t *));
int ddb_break_trap __P((int type, db_regs_t *eframe));
int ddb_entry_trap __P((int level, db_regs_t *eframe));
a170 2

int m88k_print_instruction __P((unsigned iadr, long inst));
@


1.5.6.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.5.6.1 2001/04/18 16:11:16 niklas Exp $ */
d39 5
d48 3
a50 5
#include <vm/vm_param.h>

#define BKPT_SIZE	(4)		/* number of bytes in bkpt inst. */
#define BKPT_INST	(0xF000D082U)	/* tb0, 0,r0, vector 132 */
#define BKPT_SET(inst)	(BKPT_INST)
d55 2
@


1.5.6.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d43 1
a43 1
#include <uvm/uvm_param.h>
d53 5
a57 5
typedef	vm_offset_t		db_addr_t;
typedef	int			db_expr_t;
typedef	struct m88100_saved_state db_regs_t;
extern db_regs_t	ddb_regs;	/* register state */
#define	DDB_REGS	(&ddb_regs)
@


1.5.6.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.5.6.3 2001/11/13 21:04:15 niklas Exp $ */
a38 7
/* trap numbers used by ddb */
#define	DDB_ENTRY_BKPT_NO	130
#define	DDB_ENTRY_TRACE_NO	131
#define DDB_ENTRY_TRAP_NO	132

#ifndef	_LOCORE

d46 1
a46 1
#define BKPT_INST	(0xF000D000 | DDB_ENTRY_BKPT_NO)	/* tb0, 0,r0, vector 130 */
d51 1
a178 2

#endif	/* _LOCORE */
@


1.5.6.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d52 2
a53 9
/* 
 * This is a hack so that mc88100 can use software single step
 * and mc88110 can use the wonderful hardware single step 
 * feature. XXX smurph
 */
#define INTERNAL_SSTEP		/* Use local Single Step routines */

#define BKPT_SIZE	(4)	/* number of bytes in bkpt inst. */
#define BKPT_INST	(0xF000D000 | DDB_ENTRY_BKPT_NO) /* tb0, 0,r0, vector 130 */
d74 1
a74 3
    if (cputyp == CPU_88110) \
	ret = regs->exip & ~3; \
    else if (regs->sxip & 2) /* is valid */ \
d88 1
a88 2
#define PC_REGS(regs) cputyp == CPU_88110 ? (regs->exip & ~3) :\
	((regs->sxip & 2) ?  regs->sxip & ~3 : \
d90 1
a90 2
#define l_PC_REGS(regs) cputyp == CPU_88110 ? (regs->exip & ~3) :\
	((regs->sxip & 2) ?  regs->sxip : \
d93 1
a93 2
#define pC_REGS(regs) cputyp == CPU_88110 ? (regs->exip & ~3) :\
	(regs->sxip & 2) ? regs->sxip : (regs->snip & 2 ? \
d112 1
a112 2
			    db_expr_t (*) __P((db_regs_t *, int)),
			    db_regs_t *));
a126 5
#ifdef INTERNAL_SSTEP
extern register_t getreg_val __P((db_regs_t *, int));
void db_set_single_step __P((register db_regs_t *));
void db_clear_single_step __P((register db_regs_t *));
#else
d128 1
a128 2
#define SOFTWARE_SSTEP 1 /* we need this for mc88100 */
#endif 
@


1.5.6.6
log
@Merge in -current from about a week ago
@
text
@d119 9
a127 8
unsigned inst_load(unsigned);
unsigned inst_store(unsigned);
boolean_t inst_branch(unsigned);
db_addr_t next_instr_address(db_addr_t, unsigned);
db_addr_t branch_taken(u_int, db_addr_t, db_expr_t (*)(db_regs_t *, int),
		       db_regs_t *);
int ddb_break_trap(int type, db_regs_t *eframe);
int ddb_entry_trap(int level, db_regs_t *eframe);
d141 3
a143 3
extern register_t getreg_val(db_regs_t *, int);
void db_set_single_step(register db_regs_t *);
void db_clear_single_step(register db_regs_t *);
d155 1
a155 1
#define DB_VALID_KERN_ADDR(addr) (!badaddr((void *)(addr), 1))
d203 1
a203 1
int m88k_print_instruction(unsigned iadr, long inst);
@


1.5.6.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d28 3
d46 2
a47 1
#include <machine/pcb.h>
d52 1
a52 26
/*
 * The low two bits of sxip, snip, sfip have valid bits
 * in them that need to masked to get the correct addresses
 */
#define PC_REGS(regs) \
	cputyp == CPU_88110 ? ((regs)->exip & ~3) : \
	  (((regs)->sxip & 2) ? (regs)->sxip & ~3 : \
	    ((regs)->snip & 2 ? (regs)->snip & ~3 : (regs)->sfip & ~3))

/* inst_return(ins) - is the instruction a function call return.
 * Not mutually exclusive with inst_branch. Should be a jmp r1. */
#define inst_return(I) (((I)&0xfffffbffU) == 0xf400c001U ? TRUE : FALSE)

/*
 * inst_call - function call predicate: is the instruction a function call.
 * Could be either bsr or jsr
 */
#define inst_call(I) ({ unsigned i = (I); \
	((((i) & 0xf8000000U) == 0xc8000000U || /*bsr*/ \
          ((i) & 0xfffffbe0U) == 0xf400c800U)   /*jsr*/ \
	? TRUE : FALSE) \
;})

#ifdef DDB

/*
d54 1
a54 1
 * and mc88110 can use the wonderful hardware single step
d66 3
a68 3
typedef	vaddr_t		db_addr_t;
typedef	long		db_expr_t;
typedef	struct reg	db_regs_t;
d72 35
d108 10
d140 3
a142 3
db_expr_t getreg_val(db_regs_t *, int);
void db_set_single_step(db_regs_t *);
void db_clear_single_step(db_regs_t *);
d146 1
a146 1
#endif
d167 14
d198 2
a203 1
#endif	/* DDB */
@


1.5.6.8
log
@Merge with the trunk
@
text
@d1 167
a167 3
/* $OpenBSD$ */
/* public domain */
#include <m88k/db_machdep.h>
@


1.4
log
@Commit for the first real OpenBSD mvme88k kernel.
@
text
@d1 1
@


1.3
log
@Cleanup after import. This also seems to bring up the current version.
@
text
@d42 1
a42 1
#include <vm/lock.h>
d99 2
a100 2
#define	cnmaygetc	db_getc
#define	cngetc		db_getc
@


1.2
log
@This is a remove to get rid of the old mvme88k port which was incomplete
to replace it with a working version. The kernel compiles and works
at least.  The new version will be imported shortly.
@
text
@d84 4
a87 2
#define PC_REGS(regs) (regs->sxip & 2) ? regs->sxip & ~3 : (regs->snip & 2 ? \
				regs->snip & ~3 : regs->sfip & ~3)
d115 1
a115 1
#define SOFTWARE_SSTEP 1
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@initial 88k import; code by nivas and based on mach luna88k
@
text
@@


1.1.1.2
log
@Third try at importing the mvme88k port. This is a working kernel
from nivas.
Userland and compiler still need to be worked on.
Make certain what directory the import is done from.
@
text
@d84 2
a85 4
#define PC_REGS(regs) ((regs->sxip & 2) ?  regs->sxip & ~3 : \
	(regs->snip & 2 ? regs->snip & ~3 : regs->sfip & ~3))
#define l_PC_REGS(regs) ((regs->sxip & 2) ?  regs->sxip : \
	(regs->snip & 2 ? regs->snip : regs->sfip ))
d113 1
a113 1
#define SOFTWARE_SSTEP 1 /* we need this XXX nivas */
@
