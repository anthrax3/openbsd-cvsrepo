head	1.33;
access;
symbols
	OPENBSD_3_9:1.30.0.2
	OPENBSD_3_9_BASE:1.30
	OPENBSD_3_8:1.27.0.2
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.26.0.2
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.24.0.2
	OPENBSD_3_6_BASE:1.24
	SMP_SYNC_A:1.22
	SMP_SYNC_B:1.22
	OPENBSD_3_5:1.21.0.2
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.17.0.4
	OPENBSD_3_4_BASE:1.17
	UBC_SYNC_A:1.17
	OPENBSD_3_3:1.17.0.2
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.16.0.4
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	UBC_SYNC_B:1.16
	UBC:1.13.0.2
	UBC_BASE:1.13
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.5.0.10
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.8
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.6
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.4
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	mvme88kport:1.1.1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	first_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.33
date	2006.05.08.14.36.10;	author miod;	state dead;
branches;
next	1.32;

1.32
date	2006.05.08.14.03.35;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2006.04.13.21.16.15;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2005.12.03.16.52.16;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2005.12.03.14.30.06;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2005.09.13.19.12.21;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2005.04.27.14.09.45;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2004.11.09.21.50.01;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2004.10.01.19.00.51;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2004.08.01.17.18.05;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2004.07.28.12.28.48;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2004.04.16.23.35.52;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2004.01.23.17.26.05;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2004.01.12.07.46.16;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2003.10.05.20.27.46;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2003.09.16.20.52.19;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2003.01.13.20.12.16;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.14.01.26.39;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.01.14.21.34.41;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2001.12.22.17.57.11;	author smurph;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.16.23.49.46;	author miod;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2001.12.13.08.55.51;	author smurph;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.06.00.30.38;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.26.14.31.07;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.18.01.47.53;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.16.00.05.25;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.09.05.44.40;	author smurph;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.08.00.03.22;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	99.02.09.06.36.26;	author smurph;	state Exp;
branches
	1.5.6.1;
next	1.4;

1.4
date	98.12.15.04.45.50;	author smurph;	state Exp;
branches;
next	1.3;

1.3
date	97.03.03.20.21.02;	author rahnds;	state Exp;
branches;
next	1.2;

1.2
date	97.03.03.19.07.33;	author rahnds;	state dead;
branches;
next	1.1;

1.1
date	95.10.18.10.54.23;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.10.54.23;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.03.03.19.31.34;	author rahnds;	state Exp;
branches;
next	;

1.5.6.1
date	2001.04.18.16.11.21;	author niklas;	state Exp;
branches;
next	1.5.6.2;

1.5.6.2
date	2001.10.31.03.01.19;	author nate;	state Exp;
branches;
next	1.5.6.3;

1.5.6.3
date	2001.11.13.21.04.15;	author niklas;	state Exp;
branches;
next	1.5.6.4;

1.5.6.4
date	2002.03.06.02.04.44;	author niklas;	state Exp;
branches;
next	1.5.6.5;

1.5.6.5
date	2002.03.28.10.36.02;	author niklas;	state Exp;
branches;
next	1.5.6.6;

1.5.6.6
date	2003.03.27.23.32.18;	author niklas;	state Exp;
branches;
next	1.5.6.7;

1.5.6.7
date	2004.02.19.10.49.07;	author niklas;	state Exp;
branches;
next	1.5.6.8;

1.5.6.8
date	2004.06.05.23.09.50;	author niklas;	state Exp;
branches;
next	;

1.13.2.1
date	2002.01.31.22.55.18;	author niklas;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2002.06.11.03.37.10;	author art;	state Exp;
branches;
next	1.13.2.3;

1.13.2.3
date	2003.05.19.21.45.53;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.33
log
@Replace gazillions of badvaddr() or badwordaddr() calls with badaddr() calls.
With a few prototype declarations shuffling, this finally allows
<machine/locore.h> to die.
@
text
@/*	$OpenBSD: locore.h,v 1.32 2006/05/08 14:03:35 miod Exp $	*/

#ifndef _MACHINE_LOCORE_H_
#define _MACHINE_LOCORE_H_

/*
 * C prototypes for various routines defined in locore_* and friends
 */

/* subr.S */

int badaddr(vaddr_t addr, int size);
#define badwordaddr(x) badaddr(x, 4)
void doboot(void);

/* machdep.c */

unsigned getipl(void);
int intr_findvec(int, int, int);
void myetheraddr(u_char *);
void set_cpu_number(cpuid_t);

/* eh.S */

void sigsys(void);
void stepbpt(void);
void userbpt(void);
void syscall_handler(void);
void cache_flush_handler(void);
void m88110_sigsys(void);
void m88110_stepbpt(void);
void m88110_userbpt(void);
void m88110_syscall_handler(void);
void m88110_cache_flush_handler(void);

#endif /* _MACHINE_LOCORE_H_ */
@


1.32
log
@Clean the internal m88k trap type codes; while there, simplify and
factorize the build of the VBR page betweem luna88k and mvme88k.

Tested by aoyama@@ and I.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.h,v 1.31 2006/04/13 21:16:15 miod Exp $	*/
@


1.31
log
@Drop the ivec[] interrupt acknowledge address array, compute the address
itself in the interrupt dispatcher instead of accessing the array: this
computation is of similar complexity, so why bother adding a memory
indirection. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.h,v 1.30 2005/12/03 16:52:16 miod Exp $	*/
a25 1
void sigtrap(void);
a30 1
void m88110_sigtrap(void);
@


1.30
log
@Turn read_processor_identification_register() into a simple macro with a
much, much, much shorter name. It is only used to print cpu revision anyway...
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.h,v 1.29 2005/12/03 14:30:06 miod Exp $	*/
a21 2

extern volatile u_int8_t *ivec[];
@


1.29
log
@Switch m88k ports to __HAVE_CPUINFO. Current cpu pointer is held in SR0
on all running processors.
Tested aoyama@@ and I
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.h,v 1.28 2005/09/13 19:12:21 miod Exp $	*/
a11 1
unsigned read_processor_identification_register(void);
@


1.28
log
@Oops, fix ivec[] prototype.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.h,v 1.27 2005/04/27 14:09:45 miod Exp $	*/
a14 1
void set_cpu_number(unsigned number);
d17 1
a17 1
/* locore_c_routines.c */
a19 3

/* machdep.c */

d21 2
a22 1
void myetheraddr(u_char *cp);
@


1.27
log
@Allow userland to cause the data cache to be flushed for any arbitrary address
range in the current process, using trap #451.

This is necessary for proper gcc trampolines operation, and, later, ld.so...
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.h,v 1.26 2004/11/09 21:50:01 miod Exp $	*/
d27 1
a27 1
extern volatile u_int8_t *ivec[8];
@


1.26
log
@Kill guarded_access() - the way we map OBIO, there is no need for special
treatement of interrupt vectors variables, a simple read will do.

While there, speed up the interrupt handlers a bit:
- remove old debug code or only compile it if option DEBUG.
- use short circuits for setipl() if we know interrupts are disabled at
  this point: there is no need playing with the psr in these cases.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.h,v 1.25 2004/10/01 19:00:51 miod Exp $	*/
d36 1
d42 1
@


1.25
log
@More mvme88k code cleaning:
- merge locore_c_routines.c into machdep.c
- split machdep.c into really machdep.c content, and board-specific routines
  (memory sizing, early initialization, etc).

No functionnal change.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.h,v 1.24 2004/08/01 17:18:05 miod Exp $	*/
a16 2

int guarded_access(volatile u_int8_t *, unsigned, u_int8_t *);
@


1.24
log
@Move 88100 DAE code to its own file, shared between luna88k and mvme88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.h,v 1.23 2004/07/28 12:28:48 miod Exp $	*/
a5 2
#include <uvm/uvm_param.h>

d18 1
a18 2
int guarded_access(unsigned char *volatile address,
    unsigned len, u_char *vec);
a25 4
void _doboot(void);
vaddr_t get_slave_stack(void);
void slave_pre_main(void);
int slave_main(void);
a26 1
void bugsyscall(void);
d28 2
a29 7
void dosoftint(void);
void mvme_bootstrap(void);
void m187_ext_int(u_int v, struct trapframe *eframe);
void m188_reset(void);
void m188_ext_int(u_int v, struct trapframe *eframe);
unsigned int safe_level(unsigned mask, unsigned curlevel);
void m197_ext_int(u_int v, struct trapframe *eframe);
a32 2
struct proc;
void proc_do_uret(struct proc *);
a42 4

/* process.S */
void savectx(struct pcb *);
void switch_exit(struct proc *);
@


1.23
log
@Remove EH_DEBUG code.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.h,v 1.22 2004/04/16 23:35:52 miod Exp $	*/
d12 1
a12 20
/* locore_asm_routines.S */

unsigned int do_load_word(vaddr_t address,
    boolean_t supervisor_mode);
unsigned int do_load_half(vaddr_t address,
    boolean_t supervisor_mode);
unsigned int do_load_byte(vaddr_t address,
    boolean_t supervisor_mode);

void do_store_word(vaddr_t address, unsigned int data,
    boolean_t supervisor_mode);
void do_store_half(vaddr_t address, unsigned int data,
    boolean_t supervisor_mode);
void do_store_byte(vaddr_t address, unsigned int data,
    boolean_t supervisor_mode);

unsigned do_xmem_word(vaddr_t address, unsigned int data,
    boolean_t supervisor_mode);
unsigned do_xmem_byte(vaddr_t address, unsigned int data,
    boolean_t supervisor_mode);
a23 3

void dae_print(unsigned *eframe);
void data_access_emulation(unsigned *eframe);
@


1.22
log
@When a VMEBus device needs to use two interrupt vectors, be nice and let it
actually use two distinct vectors, rather than twice the same.

Because of this, print vector last in vmeprint() so that dmesg remains pretty
in the multi-vector case.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.h,v 1.21 2004/01/23 17:26:05 miod Exp $	*/
a58 2
void MY_info(struct trapframe *f, caddr_t p, int flags, char *s);
void MY_info_done(struct trapframe *f, int flags);
@


1.21
log
@Get rid of a few (mostly DDB related) unused defines and macros.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.h,v 1.20 2004/01/12 07:46:16 miod Exp $	*/
d55 1
a55 1
int intr_findvec(int start, int end);
@


1.20
log
@Get rid of that ugly m88100_saved_state structure, use trapframe everywhere
instead.

Allow struct reg and struct trapframe to live different lives and grow
separately. Righty now they are still the same, and code expects a trapframe
to always start with a struct reg. This may change...
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.h,v 1.19 2003/10/05 20:27:46 miod Exp $	*/
a37 1
int db_are_interrupts_disabled(void);
@


1.19
log
@Kill vm_offset_t and vm_size_t, in favor of the [pv]addr_t and [pv]size_t
typedefs.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.h,v 1.18 2003/09/16 20:52:19 miod Exp $	*/
d63 1
a63 1
void m187_ext_int(u_int v, struct m88100_saved_state *eframe);
d65 1
a65 1
void m188_ext_int(u_int v, struct m88100_saved_state *eframe);
d67 1
a67 1
void m197_ext_int(u_int v, struct m88100_saved_state *eframe);
@


1.18
log
@Remove unused material from include files, as well as the annoying U() macro
which is only used to obfuscate things.

Doing this points out that the BUG memory is not at the same address on
187 and 197 (the 197 BUG is inside obio), so provide distinct constants,
and treat 187 and 197 slightly differently in pmap_bootstrap(). However, we
now need to map the 197 flash memory as well...

While there, simplify and constify pmap_table_build() and its associated data.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.h,v 1.17 2003/01/13 20:12:16 miod Exp $	*/
d14 1
a14 1
unsigned int do_load_word(vm_offset_t address,
d16 1
a16 1
unsigned int do_load_half(vm_offset_t address,
d18 1
a18 1
unsigned int do_load_byte(vm_offset_t address,
d21 1
a21 1
void do_store_word(vm_offset_t address, unsigned int data,
d23 1
a23 1
void do_store_half(vm_offset_t address, unsigned int data,
d25 1
a25 1
void do_store_byte(vm_offset_t address, unsigned int data,
d28 1
a28 1
unsigned do_xmem_word(vm_offset_t address, unsigned int data,
d30 1
a30 1
unsigned do_xmem_byte(vm_offset_t address, unsigned int data,
d34 1
a34 1
int badaddr(vm_offset_t addr, int size);
d53 1
a53 1
vm_offset_t get_slave_stack(void);
@


1.17
log
@Clean up ipl handling: be sure to always return valid levels in getipl(),
and check input level in setipl() if DIAGNOSTIC.

Doing this pointed out an horrible bug where exception frames would refer
to the saved ipl at the time the exception was processed, but would not
save it before, and the joys of stack values would make it a correct value
90% of the time. Of course, bad things could happen when restoring the
``saved'' ipl...
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.h,v 1.16 2002/03/14 01:26:39 millert Exp $	*/
a39 3
void fubail(void);
void subail(void);

a44 1
#ifdef M88100
a46 1
#endif 
a62 1
#ifdef MVME187
a63 2
#endif
#ifdef MVME188
a66 2
#endif
#ifdef MVME197
a67 1
#endif
a72 1
#ifdef M88100
a77 2
#endif 
#ifdef M88110
a82 1
#endif 
@


1.16
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.h,v 1.15 2002/01/14 21:34:41 miod Exp $	*/
a52 1
unsigned spl(void);
a53 5
#ifdef DDB
unsigned db_spl(void);
unsigned db_getipl(void);
#endif

@


1.15
log
@volatile police.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.h,v 1.14 2001/12/22 17:57:11 smurph Exp $	*/
d14 18
a31 18
unsigned int do_load_word __P((vm_offset_t address,
    boolean_t supervisor_mode));
unsigned int do_load_half __P((vm_offset_t address,
    boolean_t supervisor_mode));
unsigned int do_load_byte __P((vm_offset_t address,
    boolean_t supervisor_mode));

void do_store_word __P((vm_offset_t address, unsigned int data,
    boolean_t supervisor_mode));
void do_store_half __P((vm_offset_t address, unsigned int data,
    boolean_t supervisor_mode));
void do_store_byte __P((vm_offset_t address, unsigned int data,
    boolean_t supervisor_mode));

unsigned do_xmem_word __P((vm_offset_t address, unsigned int data,
    boolean_t supervisor_mode));
unsigned do_xmem_byte __P((vm_offset_t address, unsigned int data,
    boolean_t supervisor_mode));
d33 2
a34 2
unsigned read_processor_identification_register __P((void));
int badaddr __P((vm_offset_t addr, int size));
d36 3
a38 3
void set_cpu_number __P((unsigned number));
void doboot __P((void));
int db_are_interrupts_disabled __P((void));
d40 2
a41 2
void fubail __P((void));
void subail __P((void));
d43 2
a44 2
int guarded_access __P((unsigned char *volatile address,
    unsigned len, u_char *vec));
d49 2
a50 2
void dae_print __P((unsigned *eframe));
void data_access_emulation __P((unsigned *eframe));
d53 2
a54 2
unsigned spl __P((void));
unsigned getipl __P((void));
d56 2
a57 2
unsigned db_spl __P((void));
unsigned db_getipl __P((void));
d63 11
a73 11
void _doboot __P((void));
vm_offset_t get_slave_stack __P((void));
void slave_pre_main __P((void));
int slave_main __P((void));
int intr_findvec __P((int start, int end));
void bugsyscall __P((void));
void myetheraddr __P((u_char *cp));
void dosoftint __P((void));
void MY_info __P((struct trapframe *f, caddr_t p, int flags, char *s));
void MY_info_done __P((struct trapframe *f, int flags));
void mvme_bootstrap __P((void));
d75 1
a75 1
void m187_ext_int __P((u_int v, struct m88100_saved_state *eframe));
d78 3
a80 3
void m188_reset __P((void));
void m188_ext_int __P((u_int v, struct m88100_saved_state *eframe));
unsigned int safe_level __P((unsigned mask, unsigned curlevel));
d83 1
a83 1
void m197_ext_int __P((u_int v, struct m88100_saved_state *eframe));
d89 1
a89 1
void proc_do_uret __P((struct proc *));
d91 5
a95 5
void sigsys __P((void));
void sigtrap __P((void));
void stepbpt __P((void));
void userbpt __P((void));
void syscall_handler __P((void));
d98 5
a102 5
void m88110_sigsys __P((void));
void m88110_sigtrap __P((void));
void m88110_stepbpt __P((void));
void m88110_userbpt __P((void));
void m88110_syscall_handler __P((void));
d106 2
a107 2
void savectx __P((struct pcb *));
void switch_exit __P((struct proc *));
@


1.14
log
@change function names to reflect cpu type instead of board type.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.h,v 1.13 2001/12/16 23:49:46 miod Exp $	*/
d43 1
a43 1
int guarded_access __P((volatile unsigned char *address,
@


1.13
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.h,v 1.11 2001/11/06 00:30:38 art Exp $	*/
a42 1
#if defined(MVME187) || defined(MVME188)
a44 2
#endif 

d48 1
a48 1
#if defined(MVME187) || defined(MVME188)
d52 1
a52 7
#ifdef MVME188
unsigned int safe_level __P((unsigned mask, unsigned curlevel));
#if 0
void block_obio_interrupt __P((unsigned mask));
void unblock_obio_interrupt __P((unsigned mask));
#endif
#endif 
d74 3
d80 1
d82 2
a83 2
#if defined(MVME187) || defined(MVME197)
void sbc_ext_int __P((u_int v, struct m88100_saved_state *eframe));
a85 1

d90 1
a90 1
#if defined(MVME187) || defined(MVME188)
d97 6
a102 6
#if defined(MVME197)
void m197_sigsys __P((void));
void m197_sigtrap __P((void));
void m197_stepbpt __P((void));
void m197_userbpt __P((void));
void m197_syscall_handler __P((void));
@


1.13.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.h,v 1.15 2002/01/14 21:34:41 miod Exp $	*/
d43 2
a44 1
int guarded_access __P((unsigned char *volatile address,
d46 2
d51 1
a51 1
#ifdef M88100
d55 7
a61 1

a82 3
#ifdef MVME187
void m187_ext_int __P((u_int v, struct m88100_saved_state *eframe));
#endif
a85 1
unsigned int safe_level __P((unsigned mask, unsigned curlevel));
d87 2
a88 2
#ifdef MVME197
void m197_ext_int __P((u_int v, struct m88100_saved_state *eframe));
d91 1
d96 1
a96 1
#ifdef M88100
d103 6
a108 6
#ifdef M88110
void m88110_sigsys __P((void));
void m88110_sigtrap __P((void));
void m88110_stepbpt __P((void));
void m88110_userbpt __P((void));
void m88110_syscall_handler __P((void));
@


1.13.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.h,v 1.13.2.1 2002/01/31 22:55:18 niklas Exp $	*/
d14 18
a31 18
unsigned int do_load_word(vm_offset_t address,
    boolean_t supervisor_mode);
unsigned int do_load_half(vm_offset_t address,
    boolean_t supervisor_mode);
unsigned int do_load_byte(vm_offset_t address,
    boolean_t supervisor_mode);

void do_store_word(vm_offset_t address, unsigned int data,
    boolean_t supervisor_mode);
void do_store_half(vm_offset_t address, unsigned int data,
    boolean_t supervisor_mode);
void do_store_byte(vm_offset_t address, unsigned int data,
    boolean_t supervisor_mode);

unsigned do_xmem_word(vm_offset_t address, unsigned int data,
    boolean_t supervisor_mode);
unsigned do_xmem_byte(vm_offset_t address, unsigned int data,
    boolean_t supervisor_mode);
d33 2
a34 2
unsigned read_processor_identification_register(void);
int badaddr(vm_offset_t addr, int size);
d36 3
a38 3
void set_cpu_number(unsigned number);
void doboot(void);
int db_are_interrupts_disabled(void);
d40 2
a41 2
void fubail(void);
void subail(void);
d43 2
a44 2
int guarded_access(unsigned char *volatile address,
    unsigned len, u_char *vec);
d49 2
a50 2
void dae_print(unsigned *eframe);
void data_access_emulation(unsigned *eframe);
d53 2
a54 2
unsigned spl(void);
unsigned getipl(void);
d56 2
a57 2
unsigned db_spl(void);
unsigned db_getipl(void);
d63 11
a73 11
void _doboot(void);
vm_offset_t get_slave_stack(void);
void slave_pre_main(void);
int slave_main(void);
int intr_findvec(int start, int end);
void bugsyscall(void);
void myetheraddr(u_char *cp);
void dosoftint(void);
void MY_info(struct trapframe *f, caddr_t p, int flags, char *s);
void MY_info_done(struct trapframe *f, int flags);
void mvme_bootstrap(void);
d75 1
a75 1
void m187_ext_int(u_int v, struct m88100_saved_state *eframe);
d78 3
a80 3
void m188_reset(void);
void m188_ext_int(u_int v, struct m88100_saved_state *eframe);
unsigned int safe_level(unsigned mask, unsigned curlevel);
d83 1
a83 1
void m197_ext_int(u_int v, struct m88100_saved_state *eframe);
d89 1
a89 1
void proc_do_uret(struct proc *);
d91 5
a95 5
void sigsys(void);
void sigtrap(void);
void stepbpt(void);
void userbpt(void);
void syscall_handler(void);
d98 5
a102 5
void m88110_sigsys(void);
void m88110_sigtrap(void);
void m88110_stepbpt(void);
void m88110_userbpt(void);
void m88110_syscall_handler(void);
d106 2
a107 2
void savectx(struct pcb *);
void switch_exit(struct proc *);
@


1.13.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d53 1
d55 5
@


1.12
log
@Support for MVME197 completed.  Fix SPL defs.
@
text
@d43 1
d46 2
d51 1
a51 1
#ifdef M88100
d55 7
a61 1

a82 3
#ifdef MVME187
void m187_ext_int __P((u_int v, struct m88100_saved_state *eframe));
#endif
a85 1
unsigned int safe_level __P((unsigned mask, unsigned curlevel));
d87 2
a88 2
#ifdef MVME197
void m197_ext_int __P((u_int v, struct m88100_saved_state *eframe));
d91 1
d96 1
a96 1
#ifdef M88100
d103 6
a108 6
#ifdef M88110
void m88110_sigsys __P((void));
void m88110_sigtrap __P((void));
void m88110_stepbpt __P((void));
void m88110_userbpt __P((void));
void m88110_syscall_handler __P((void));
@


1.11
log
@Kill vm/vm_param.h, move it to uvm/uvm_param.h
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.h,v 1.10 2001/08/26 14:31:07 miod Exp $	*/
a42 1
#if defined(MVME187) || defined(MVME188)
a44 2
#endif 

d48 1
a48 1
#if defined(MVME187) || defined(MVME188)
d52 1
a52 7
#ifdef MVME188
unsigned int safe_level __P((unsigned mask, unsigned curlevel));
#if 0
void block_obio_interrupt __P((unsigned mask));
void unblock_obio_interrupt __P((unsigned mask));
#endif
#endif 
d74 3
d80 1
d82 2
a83 2
#if defined(MVME187) || defined(MVME197)
void sbc_ext_int __P((u_int v, struct m88100_saved_state *eframe));
a85 1

d90 1
a90 1
#if defined(MVME187) || defined(MVME188)
d97 6
a102 6
#if defined(MVME197)
void m197_sigsys __P((void));
void m197_sigtrap __P((void));
void m197_stepbpt __P((void));
void m197_userbpt __P((void));
void m197_syscall_handler __P((void));
@


1.10
log
@Add prototypes, fix compilation warnings, random style fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.h,v 1.9 2001/03/18 01:47:53 miod Exp $	*/
d6 1
a6 1
#include <vm/vm_param.h>
@


1.9
log
@Correct prototype for guarded_access().
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.h,v 1.8 2001/03/16 00:05:25 miod Exp $	*/
d40 3
d57 1
d60 1
d94 2
d110 4
@


1.8
log
@More function prototypes.
Move badwordaddr() to a macro.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.h,v 1.7 2001/03/09 05:44:40 smurph Exp $	*/
d42 1
a42 1
    unsigned len, unsigned *vec));
@


1.7
log
@kernel will compile with -Werror.  Added intr.h
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.h,v 1.6 2001/03/08 00:03:22 miod Exp $	*/
d9 1
a9 1
 * C prototypes for various routines defined in locore_*
d12 3
a14 1
extern unsigned int do_load_word __P((vm_offset_t address,
d16 1
a16 1
extern unsigned int do_load_half __P((vm_offset_t address,
d18 1
a18 1
extern unsigned int do_load_byte __P((vm_offset_t address,
d21 1
a21 1
extern void do_store_word __P((vm_offset_t address, unsigned int data,
d23 1
a23 1
extern void do_store_half __P((vm_offset_t address, unsigned int data,
d25 1
a25 1
extern void do_store_byte __P((vm_offset_t address, unsigned int data,
d28 1
a28 1
extern unsigned do_xmem_word __P((vm_offset_t address, unsigned int data,
d30 1
a30 1
extern unsigned do_xmem_byte __P((vm_offset_t address, unsigned int data,
d33 55
a87 4
extern unsigned read_processor_identification_register __P((void));
extern int badaddr __P((vm_offset_t addr, int size));
extern void set_cpu_number __P((unsigned number));
extern void doboot __P((void));
d90 12
a101 3
extern void dae_print __P((unsigned *eframe));
extern void data_access_emulation __P((unsigned *eframe));
extern int guarded_access( );
@


1.6
log
@Some warning hunting.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d30 11
@


1.5
log
@Added kernel support for user debugging.  Fixed file ID's
@
text
@d1 1
a1 56
/*	$OpenBSD: locore.h,v 1.1 1998/12/15 04:45:50 smurph Exp $ */
/*
 * Mach Operating System
 * Copyright (c) 1993-1991 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON AND OMRON ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON AND OMRON DISCLAIM ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */
/*     "locore.h"		  Omron Corporation
 * This file created by Omron Corporation, 1990.
 * NOTE: Any assembly file that includes this one must define ASSEMBLER first
 */

#ifndef __MACHINE_LOCORE_H__
#define __MACHINE_LOCORE_H__


/*
 **********************************************************************
	SYNTACTICAL AND SEMANTIC DOO-DADS
 **********************************************************************
 */
/*
 * NEWLINE is defined in 'assmy.s' in the object area to be a double
 * backslash, which 'as' interprets the same as '\n'
 */

/*
 * If this has been included in an assembly file, make sure
 * LOCORE is defined.  Always make sure KERNEL is defined.
 */
#if defined(ASSEMBLER) && !defined(LOCORE)
#  define LOCORE
#endif
#if !defined(KERNEL)
#  define KERNEL
#endif
d3 2
a4 4
/* Define EH_DEBUG to be non-zero to compile-in various debugging things */
#ifndef	EH_DEBUG
#define EH_DEBUG 0
#endif	EH_DEBUG
d6 1
a6 2
/* this gives the offsets into various structures of various elements, etc */
#include "assym.s"
d9 1
a9 7
 * LABEL(name)
 * 	Defines the name to be a label visible to the world.
 *
 * _LABEL(name)
 *	Defines one visible only to the file, unless debugging
 * 	is enabled, in which case it's visible to the world (and
 *	hence to debuggers, and such).
a10 7
#define LABEL(name)	name:	global name NEWLINE

#if EH_DEBUG
#  define _LABEL(name)	name:	global name NEWLINE
#else
#  define _LABEL(name)	name:               NEWLINE
#endif
d12 6
d19 6
a24 203
/*
 * Useful in some situations.
 * NOTE: If ARG1 or ARG2 are r2 or r3, strange things may happen.  Watch out!
 */
#define CALL(NAME, ARG1, ARG2)             \
  		subu	r31, r31, 32	NEWLINE \
                or      r2, r0, ARG1    NEWLINE \
                bsr.n   NAME            NEWLINE \
                or      r3, r0, ARG2	NEWLINE \
		addu	r31, r31, 32

/*
 **********************************************************************
	SYMBOLIC CONSTANTS AND VALUES and other important things
 **********************************************************************
 */

/*
 * SR1 - CPU FLAGS REGISTER
 * 
 * SR1 contains flags about the current CPU status.
 *
 * The lowest FLAG_CPU_FIELD_WIDTH bits hold the cpu number (currently 0-3).
 *
 *
 * The bit FLAG_IGNORE_DATA_EXCEPTION indicates that any data exceptions
 * 	should be ignored (well, at least treated in a special way).
 * The bit FLAG_INTERRUPT_EXCEPTION indicates that the current exception
 * 	is the interrupt exception.  Such information can be gotten
 * 	in other ways, but having it in the flags makes it easy for the
 *	exception handler to check quickly.
 * The bit FLAG_ENABLING_FPU indicates that the exception handler is
 * 	in the process of enabling the FPU (so that an exception can
 * 	be serviced).  This is needed because enabling the FPU can
 *	cause other exceptions to happen, and the whole system is
 *	in a rather precarious state and so special cautions must
 * 	be taken.
 */
#define FLAG_CPU_FIELD_WIDTH		4	/* must be <= 12 */

#define FLAG_IGNORE_DATA_EXCEPTION	5	/* bit number 5 */
#define FLAG_INTERRUPT_EXCEPTION	6	/* bit number 6 */
#define FLAG_ENABLING_FPU		7	/* bit number 7 */


/* REGister OFFset into the E.F. (exception frame) */
#define REG_OFF(reg_num)  ((reg_num) * 4) /* (num * sizeof(register int))  */
#define GENREG_OFF(num)	(REG_OFF(EF_R0 + (num))) /* GENeral REGister OFFset */


#define GENERAL_BREATHING_ROOM	/* arbitrarily */ 200
#define KERNEL_STACK_BREATHING_ROOM 	\
	(GENERAL_BREATHING_ROOM + SIZEOF_STRUCT_PCB + SIZEOF_STRUCT_UTHREAD)

/*
 * Some registers used during the setting up of the new exception frame.
 * Don't choose r1, r30, or r31 for any of them.
 *
 * Also, if any are 'r2' or 'r3', be careful using with CALL above!
 */
#define FLAGS	r2
#define TMP	r3
#define TMP2	r10
#define TMP3	r11
#define SAVE_TMP2	st	r10, r31, GENREG_OFF(10)
#define SAVE_TMP3	st	r11, r31, GENREG_OFF(11)
#define RESTORE_TMP2	ld	r10, r31, GENREG_OFF(10)
#define RESTORE_TMP3	ld	r11, r31, GENREG_OFF(11)


/* alternate CPU control register names */
#define PID	cr0
#define PSR	cr1
#define EPSR	cr2
#define SSBR	cr3
#define SXIP	cr4
#define SNIP	cr5
#define SFIP	cr6
#define VBR	cr7
#define DMT0	cr8
#define DMD0	cr9
#define DMA0	cr10
#define DMT1	cr11
#define DMD1	cr12
#define DMA1	cr13
#define DMT2	cr14
#define DMD2	cr15
#define DMA2	cr16
#define SR0	cr17
#define SR1	cr18
#define SR2	cr19
#define SR3	cr20
#define FPECR	fcr0
#define FPHS1	fcr1
#define FPLS1	fcr2
#define FPHS2	fcr3
#define FPLS2	fcr4
#define FPPT	fcr5
#define FPRH	fcr6
#define FPRL	fcr7
#define FPIT	fcr8
#define FPSR	fcr62
#define FPCR	fcr63

/*
 * Info about the PSR 
 */
#define PSR_SHADOW_FREEZE_BIT		 0
#define PSR_INTERRUPT_DISABLE_BIT	 1
#define PSR_FPU_DISABLE_BIT		 3
#define PSR_BIG_ENDIAN_MODE		30
#define PSR_SUPERVISOR_MODE_BIT		31

/*
 * Status bits for an SXIP/SNIP/SFIP address.
 */
#define RTE_VALID_BIT	 1
#define RTE_ERROR_BIT	 0

/*
 * Info about DMT0/DMT1/DMT2
 */
#define DMT_VALID_BIT	 0
#define DMT_WRITE_BIT 	 1
#define DMT_LOCK_BIT	12
#define DMT_DOUBLE_BIT	13
#define DMT_DAS_BIT     14
#define DMT_DREG_OFFSET	 7
#define DMT_DREG_WIDTH	 5

/*
 * Bits for eh_debug.
 */
#define DEBUG_INTERRUPT_BIT		 0
#define DEBUG_DATA_BIT			 1
#define DEBUG_INSTRUCTION_BIT		 2
#define DEBUG_MISALIGN_BIT		 3
#define DEBUG_UNIMP_BIT			 4
#define DEBUG_DIVIDE_BIT		 5
#define DEBUG_OF_BIT			 6
#define DEBUG_FPp_BIT			 7
#define DEBUG_FPi_BIT			 8
#define DEBUG_SYSCALL_BIT	 	 9
#define DEBUG_MACHSYSCALL_BIT		10
#define DEBUG_UNIMPLEMENTED_BIT		11
#define DEBUG_PRIVILEGE_BIT		12
#define DEBUG_BOUNDS_BIT		13
#define DEBUG_OVERFLOW_BIT		14
#define DEBUG_ERROR_BIT			15
#define DEBUG_SIGSYS_BIT		16
#define DEBUG_SIGTRAP_BIT		17
#define DEBUG_BREAK_BIT			18
#define DEBUG_TRACE_BIT			19
#define DEBUG_KDB_BIT			20
#define DEBUG_JKDB_BIT			21
#define DEBUG_BUGCALL_BIT		22

#define DEBUG_UNKNOWN_BIT		31

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#define YES		1
#define NO		0

#define	SCSI_INTS	0x10
#define	SCSI_SSTS	0x18
#define SCSI_DREG	0x28

/* change software timer for 8mm device support -- 90/08/21 CEC OKUI */
#define	SCSI_WAIT	0x5000000

/*
 * At various times, there is the need to clear the pipeline (i.e.
 * synchronize).  A "tcnd ne0, r0, foo" will do that (because a trap
 * instruction always synchronizes, and this particular instruction
 * will never actually take the trap).
 */
#define FLUSH_PIPELINE	tcnd	ne0, r0, 0

/*
 * NOP -- NO-Operation.
 *
 * A do-nothing one clock doesn't-touch-the-scoreboard type of instruction,
 * in case one's needed (sometimes useful for debugging).
 */
#define NOP		or r0, r0, r0

/*
 * These things for vector_init.c and locore.c
 */
#if defined(ASSEMBLER)
# define  PREDEFINED_BY_ROM       0xffffffff
# define  END_OF_VECTOR_LIST      0xfffffffe
#else
# define  PREDEFINED_BY_ROM       0xffffffffU
# define  END_OF_VECTOR_LIST      0xfffffffeU
#endif

/*
 * Define ERROR__XXX_USR if the xxx.usr bug (mask C82N) is present.
 * This implements the workaround.
 */
#define ERRATA__XXX_USR 	1
d26 4
a29 1
#define USERMODE(x) (!(x & (1 << PSR_SUPERVISOR_MODE_BIT)))
d31 1
a31 1
#endif /* __MACHINE_LOCORE_H__ */
@


1.5.6.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 34
a34 1
/*	$OpenBSD: locore.h,v 1.9 2001/03/18 01:47:53 miod Exp $	*/
a35 2
#ifndef _MACHINE_LOCORE_H_
#define _MACHINE_LOCORE_H_
d37 9
a45 1
#include <vm/vm_param.h>
d48 8
a55 53
 * C prototypes for various routines defined in locore_* and friends
 */

/* locore_asm_routines.S */

unsigned int do_load_word __P((vm_offset_t address,
    boolean_t supervisor_mode));
unsigned int do_load_half __P((vm_offset_t address,
    boolean_t supervisor_mode));
unsigned int do_load_byte __P((vm_offset_t address,
    boolean_t supervisor_mode));

void do_store_word __P((vm_offset_t address, unsigned int data,
    boolean_t supervisor_mode));
void do_store_half __P((vm_offset_t address, unsigned int data,
    boolean_t supervisor_mode));
void do_store_byte __P((vm_offset_t address, unsigned int data,
    boolean_t supervisor_mode));

unsigned do_xmem_word __P((vm_offset_t address, unsigned int data,
    boolean_t supervisor_mode));
unsigned do_xmem_byte __P((vm_offset_t address, unsigned int data,
    boolean_t supervisor_mode));

unsigned read_processor_identification_register __P((void));
int badaddr __P((vm_offset_t addr, int size));
#define badwordaddr(x) badaddr(x, 4)
void set_cpu_number __P((unsigned number));
void doboot __P((void));
int db_are_interrupts_disabled __P((void));

#if defined(MVME187) || defined(MVME188)
int guarded_access __P((volatile unsigned char *address,
    unsigned len, u_char *vec));
#endif 


/* locore_c_routines.c */

#if defined(MVME187) || defined(MVME188)
void dae_print __P((unsigned *eframe));
void data_access_emulation __P((unsigned *eframe));
#endif 
#ifdef MVME188
unsigned int safe_level __P((unsigned mask, unsigned curlevel));
void block_obio_interrupt __P((unsigned mask));
void unblock_obio_interrupt __P((unsigned mask));
#endif 
unsigned spl __P((void));
unsigned getipl __P((void));
#ifdef DDB
unsigned db_spl __P((void));
unsigned db_getipl __P((void));
d58 4
d63 2
a64 1
/* machdep.c */
d66 15
a80 14
void _doboot __P((void));
vm_offset_t get_slave_stack __P((void));
void slave_pre_main __P((void));
int slave_main __P((void));
int intr_findvec __P((int start, int end));
void bugsyscall __P((void));
void myetheraddr __P((u_char *cp));
void dosoftint __P((void));
void MY_info __P((struct trapframe *f, caddr_t p, int flags, char *s));
void MY_info_done __P((struct trapframe *f, int flags));
void mvme_bootstrap __P((void));
#ifdef MVME188
void m188_reset __P((void));
void m188_ext_int __P((u_int v, struct m88100_saved_state *eframe));
d82 198
a279 2
#if defined(MVME187) || defined(MVME197)
void sbc_ext_int __P((u_int v, struct m88100_saved_state *eframe));
d282 5
d288 1
a288 16
/* eh.S */

#if defined(MVME187) || defined(MVME188)
void sigsys __P((void));
void sigtrap __P((void));
void stepbpt __P((void));
void userbpt __P((void));
void syscall_handler __P((void));
#endif 
#if defined(MVME197)
void m197_sigsys __P((void));
void m197_sigtrap __P((void));
void m197_stepbpt __P((void));
void m197_userbpt __P((void));
void m197_syscall_handler __P((void));
#endif 
d290 1
a290 1
#endif /* _MACHINE_LOCORE_H_ */
@


1.5.6.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.h,v 1.5.6.1 2001/04/18 16:11:21 niklas Exp $	*/
a39 3
void fubail __P((void));
void subail __P((void));

a53 1
#if 0
a55 1
#endif
a88 2
struct proc;
void proc_do_uret __P((struct proc *));
a102 4

/* process.S */
void savectx __P((struct pcb *));
void switch_exit __P((struct proc *));
@


1.5.6.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d6 1
a6 1
#include <uvm/uvm_param.h>
@


1.5.6.4
log
@Merge in trunk
@
text
@d43 2
a44 1
int guarded_access __P((unsigned char *volatile address,
d46 2
d51 1
a51 1
#ifdef M88100
d55 7
a61 1

a82 3
#ifdef MVME187
void m187_ext_int __P((u_int v, struct m88100_saved_state *eframe));
#endif
a85 1
unsigned int safe_level __P((unsigned mask, unsigned curlevel));
d87 2
a88 2
#ifdef MVME197
void m197_ext_int __P((u_int v, struct m88100_saved_state *eframe));
d91 1
d96 1
a96 1
#ifdef M88100
d103 6
a108 6
#ifdef M88110
void m88110_sigsys __P((void));
void m88110_sigtrap __P((void));
void m88110_stepbpt __P((void));
void m88110_userbpt __P((void));
void m88110_syscall_handler __P((void));
@


1.5.6.5
log
@Merge in -current from about a week ago
@
text
@d14 18
a31 18
unsigned int do_load_word(vm_offset_t address,
    boolean_t supervisor_mode);
unsigned int do_load_half(vm_offset_t address,
    boolean_t supervisor_mode);
unsigned int do_load_byte(vm_offset_t address,
    boolean_t supervisor_mode);

void do_store_word(vm_offset_t address, unsigned int data,
    boolean_t supervisor_mode);
void do_store_half(vm_offset_t address, unsigned int data,
    boolean_t supervisor_mode);
void do_store_byte(vm_offset_t address, unsigned int data,
    boolean_t supervisor_mode);

unsigned do_xmem_word(vm_offset_t address, unsigned int data,
    boolean_t supervisor_mode);
unsigned do_xmem_byte(vm_offset_t address, unsigned int data,
    boolean_t supervisor_mode);
d33 2
a34 2
unsigned read_processor_identification_register(void);
int badaddr(vm_offset_t addr, int size);
d36 3
a38 3
void set_cpu_number(unsigned number);
void doboot(void);
int db_are_interrupts_disabled(void);
d40 2
a41 2
void fubail(void);
void subail(void);
d43 2
a44 2
int guarded_access(unsigned char *volatile address,
    unsigned len, u_char *vec);
d49 2
a50 2
void dae_print(unsigned *eframe);
void data_access_emulation(unsigned *eframe);
d53 2
a54 2
unsigned spl(void);
unsigned getipl(void);
d56 2
a57 2
unsigned db_spl(void);
unsigned db_getipl(void);
d63 11
a73 11
void _doboot(void);
vm_offset_t get_slave_stack(void);
void slave_pre_main(void);
int slave_main(void);
int intr_findvec(int start, int end);
void bugsyscall(void);
void myetheraddr(u_char *cp);
void dosoftint(void);
void MY_info(struct trapframe *f, caddr_t p, int flags, char *s);
void MY_info_done(struct trapframe *f, int flags);
void mvme_bootstrap(void);
d75 1
a75 1
void m187_ext_int(u_int v, struct m88100_saved_state *eframe);
d78 3
a80 3
void m188_reset(void);
void m188_ext_int(u_int v, struct m88100_saved_state *eframe);
unsigned int safe_level(unsigned mask, unsigned curlevel);
d83 1
a83 1
void m197_ext_int(u_int v, struct m88100_saved_state *eframe);
d89 1
a89 1
void proc_do_uret(struct proc *);
d91 5
a95 5
void sigsys(void);
void sigtrap(void);
void stepbpt(void);
void userbpt(void);
void syscall_handler(void);
d98 5
a102 5
void m88110_sigsys(void);
void m88110_sigtrap(void);
void m88110_stepbpt(void);
void m88110_userbpt(void);
void m88110_syscall_handler(void);
d106 2
a107 2
void savectx(struct pcb *);
void switch_exit(struct proc *);
@


1.5.6.6
log
@Sync the SMP branch with 3.3
@
text
@d53 1
d55 5
@


1.5.6.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d14 1
a14 1
unsigned int do_load_word(vaddr_t address,
d16 1
a16 1
unsigned int do_load_half(vaddr_t address,
d18 1
a18 1
unsigned int do_load_byte(vaddr_t address,
d21 1
a21 1
void do_store_word(vaddr_t address, unsigned int data,
d23 1
a23 1
void do_store_half(vaddr_t address, unsigned int data,
d25 1
a25 1
void do_store_byte(vaddr_t address, unsigned int data,
d28 1
a28 1
unsigned do_xmem_word(vaddr_t address, unsigned int data,
d30 1
a30 1
unsigned do_xmem_byte(vaddr_t address, unsigned int data,
d34 1
a34 1
int badaddr(vaddr_t addr, int size);
d38 4
d48 1
d51 1
d58 1
a58 1
vaddr_t get_slave_stack(void);
d68 4
a71 1
void m187_ext_int(u_int v, struct trapframe *eframe);
d73 1
a73 1
void m188_ext_int(u_int v, struct trapframe *eframe);
d75 4
a78 1
void m197_ext_int(u_int v, struct trapframe *eframe);
d84 1
d90 2
d97 1
@


1.5.6.8
log
@Merge with the trunk
@
text
@d55 1
a55 1
int intr_findvec(int, int, int);
@


1.4
log
@Commit for the first real OpenBSD mvme88k kernel.
@
text
@d1 1
@


1.3
log
@Cleanup after import. This also seems to bring up the current version.
@
text
@d75 1
@


1.2
log
@This is a remove to get rid of the old mvme88k port which was incomplete
to replace it with a working version. The kernel compiles and works
at least.  The new version will be imported shortly.
@
text
@a27 1
 **********************************************************************
a28 11
 *
 * HISTORY
 * 
 *
 **********************************************************************
 *
 * This file contains defines and such used by (most of) the assembly
 * routines for Omron's Luna88 Mach system.  It also may be included by
 * some C language files.
 *
 **********************************************************************
a29 1
 *
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@initial 88k import; code by nivas and based on mach luna88k
@
text
@@


1.1.1.2
log
@Third try at importing the mvme88k port. This is a working kernel
from nivas.
Userland and compiler still need to be worked on.
Make certain what directory the import is done from.
@
text
@d28 1
d30 11
d42 1
@
