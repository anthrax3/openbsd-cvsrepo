head	1.21;
access;
symbols
	OPENBSD_5_5:1.20.0.42
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.38
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.36
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.34
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.32
	OPENBSD_5_0:1.20.0.30
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.28
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.26
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.22
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.24
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.20
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.18
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.16
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.14
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.12
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.10
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.8
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.6
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.4
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.2
	OPENBSD_3_6_BASE:1.20
	SMP_SYNC_A:1.20
	SMP_SYNC_B:1.20
	OPENBSD_3_5:1.18.0.2
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.11.0.8
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.6
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.11
	UBC:1.9.0.2
	UBC_BASE:1.9
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.1.0.8
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.6
	OPENBSD_2_7_BASE:1.1
	SMP:1.1.0.4
	SMP_BASE:1.1
	kame_19991208:1.1
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.21
date	2014.03.18.22.36.36;	author miod;	state dead;
branches;
next	1.20;

1.20
date	2004.04.26.14.31.11;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2004.04.26.12.34.05;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2004.01.20.14.35.52;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2004.01.09.00.23.04;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2004.01.02.17.08.57;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2003.11.09.00.32.00;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2003.10.05.20.35.22;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2003.09.26.22.27.25;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2003.09.16.20.52.19;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.01.26.39;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.22.09.49.39;	author smurph;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.16.23.49.46;	author miod;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2001.12.14.04.30.11;	author smurph;	state Exp;
branches;
next	1.7;

1.7
date	2001.12.13.08.55.51;	author smurph;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.27.05.36.40;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.26.14.31.07;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.11.01.55.52;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.09.05.44.40;	author smurph;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.07.23.37.15;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	99.09.27.20.46.17;	author smurph;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2001.04.18.16.11.14;	author niklas;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2001.10.31.03.01.18;	author nate;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2001.12.05.00.39.12;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2002.03.06.02.04.44;	author niklas;	state Exp;
branches;
next	1.1.4.5;

1.1.4.5
date	2002.03.28.10.36.02;	author niklas;	state Exp;
branches;
next	1.1.4.6;

1.1.4.6
date	2004.02.19.10.49.07;	author niklas;	state Exp;
branches;
next	1.1.4.7;

1.1.4.7
date	2004.06.05.23.09.49;	author niklas;	state Exp;
branches;
next	;

1.9.2.1
date	2002.01.31.22.55.18;	author niklas;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2002.06.11.03.37.10;	author art;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/* $OpenBSD: cmmu.h,v 1.20 2004/04/26 14:31:11 miod Exp $ */
/* public domain */
#include <m88k/cmmu.h>
@


1.20
log
@Fix RCSID
@
text
@d1 1
a1 1
/* $OpenBSD$ */
@


1.19
log
@Start factorizing luna88k and mvme88k common parts.
For now, include files only.
@
text
@d1 1
a1 1
/* $OpenBSD */
@


1.18
log
@Use shifts and logical arithmetic, rather than multiplications and integer
arithmetic, when computing cmmu numbers.
@
text
@d1 3
a3 103
/*	$OpenBSD: cmmu.h,v 1.17 2004/01/09 00:23:04 miod Exp $ */
/*
 * Mach Operating System
 * Copyright (c) 1993-1992 Carnegie Mellon University
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */

#ifndef	_MACHINE_CMMU_H_
#define	_MACHINE_CMMU_H_

#include <machine/mmu.h>

#ifndef	_LOCORE
/*
 * Prototypes and stuff for cmmu.c.
 */
extern unsigned cpu_sets[MAX_CPUS];
extern unsigned master_cpu;
extern int max_cpus, max_cmmus;

/*
 * This lock protects the cmmu SAR and SCR's; other ports
 * can be accessed without locking it
 *
 * May be used from "db_interface.c".
 */
extern struct simplelock cmmu_cpu_lock;

#define CMMU_LOCK   simple_lock(&cmmu_cpu_lock)
#define CMMU_UNLOCK simple_unlock(&cmmu_cpu_lock)

/* machine dependent cmmu function pointer structure */
struct cmmu_p {
	void (*cmmu_init_func)(void);
	void (*setup_board_config_func)(void);
	void (*cpu_configuration_print_func)(int);
	void (*cmmu_shutdown_now_func)(void);
	void (*cmmu_parity_enable_func)(void);
	unsigned (*cmmu_cpu_number_func)(void);
	void (*cmmu_set_sapr_func)(unsigned, unsigned);
	void (*cmmu_set_uapr_func)(unsigned);
	void (*cmmu_set_pair_batc_entry_func)(unsigned, unsigned, unsigned);
	void (*cmmu_flush_tlb_func)(unsigned, unsigned, vaddr_t, vsize_t);
	void (*cmmu_pmap_activate_func)(unsigned, unsigned,
	    u_int32_t i_batc[BATC_MAX], u_int32_t d_batc[BATC_MAX]);
	void (*cmmu_flush_cache_func)(int, paddr_t, psize_t);
	void (*cmmu_flush_inst_cache_func)(int, paddr_t, psize_t);
	void (*cmmu_flush_data_cache_func)(int, paddr_t, psize_t);
	void (*dma_cachectl_func)(vaddr_t, vsize_t, int);
	/* DDB only */
	void (*cmmu_dump_config_func)(void);
	void (*cmmu_show_translation_func)(unsigned, unsigned, unsigned, int);
	/* DEBUG only */
	void (*show_apr_func)(unsigned);
};

/* THE pointer! */
extern struct cmmu_p *cmmu;

/* The macros... */
#define cmmu_init		(cmmu->cmmu_init_func)
#define setup_board_config	(cmmu->setup_board_config_func)
#define	cpu_configuration_print(a)	(cmmu->cpu_configuration_print_func)(a)
#define	cmmu_shutdown_now	(cmmu->cmmu_shutdown_now_func)
#define	cmmu_parity_enable	(cmmu->cmmu_parity_enable_func)
#define	cmmu_cpu_number		(cmmu->cmmu_cpu_number_func)
#define	cmmu_set_sapr(a, b)	(cmmu->cmmu_set_sapr_func)(a, b)
#define	cmmu_set_uapr(a)	(cmmu->cmmu_set_uapr_func)(a)
#define	cmmu_set_pair_batc_entry(a, b, c)	(cmmu->cmmu_set_pair_batc_entry_func)(a, b, c)
#define	cmmu_flush_tlb(a, b, c, d) 	(cmmu->cmmu_flush_tlb_func)(a, b, c, d)
#define	cmmu_pmap_activate(a, b, c, d) 	(cmmu->cmmu_pmap_activate_func)(a, b, c, d)
#define	cmmu_flush_cache(a, b, c)	(cmmu->cmmu_flush_cache_func)(a, b, c)
#define	cmmu_flush_inst_cache(a, b, c)	(cmmu->cmmu_flush_inst_cache_func)(a, b, c)
#define	cmmu_flush_data_cache(a, b, c)	(cmmu->cmmu_flush_data_cache_func)(a, b, c)
#define	dma_cachectl(a, b, c)	(cmmu->dma_cachectl_func)(a, b, c)
#define	cmmu_dump_config	(cmmu->cmmu_dump_config_func)
#define	cmmu_show_translation(a, b, c, d)	(cmmu->cmmu_show_translation_func)(a, b, c, d)
#define show_apr(ap)		(cmmu->show_apr_func)(ap)

#endif	/* _LOCORE */

#endif	/* _MACHINE_CMMU_H_ */

@


1.17
log
@Do not define new m8820x specific constants for what are common cache and
apr validity constants, really.

And get rid of the old cache_policy debug trick.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.16 2004/01/02 17:08:57 miod Exp $ */
a37 1
extern int cpu_cmmu_ratio;
@


1.16
log
@When both cmmu_dofoo() and cmmu_remote_dofoo() exist, kill the first one,
and rename the second one to the first one, i.e. have the cmmu_dofoo()
functions always take a cpu# parameter.

No functional change, simply makes code more readable and saves a few
call frames.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.15 2003/11/09 00:32:00 miod Exp $ */
a39 1
extern unsigned cache_policy;
@


1.15
log
@Typos; Jonathan Gray
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.14 2003/10/05 20:35:22 miod Exp $ */
d62 1
a62 1
	void (*cmmu_remote_set_sapr_func)(unsigned, unsigned);
d65 1
a65 2
	void (*cmmu_flush_remote_tlb_func)(unsigned, unsigned, vaddr_t, vsize_t);
	void (*cmmu_flush_tlb_func)(unsigned, vaddr_t, vsize_t);
d68 3
a70 6
	void (*cmmu_flush_remote_cache_func)(int, paddr_t, psize_t);
	void (*cmmu_flush_cache_func)(paddr_t, psize_t);
	void (*cmmu_flush_remote_inst_cache_func)(int, paddr_t, psize_t);
	void (*cmmu_flush_inst_cache_func)(paddr_t, psize_t);
	void (*cmmu_flush_remote_data_cache_func)(int, paddr_t, psize_t);
	void (*cmmu_flush_data_cache_func)(paddr_t, psize_t);
d89 1
a89 1
#define	cmmu_remote_set_sapr(a, b)	(cmmu->cmmu_remote_set_sapr_func)(a, b)
d92 1
a92 2
#define	cmmu_flush_remote_tlb(a, b, c, d) 	(cmmu->cmmu_flush_remote_tlb_func)(a, b, c, d)
#define	cmmu_flush_tlb(a, b, c)	(cmmu->cmmu_flush_tlb_func)(a, b, c)
d94 3
a96 6
#define	cmmu_flush_remote_cache(a, b, c)	(cmmu->cmmu_flush_remote_cache_func)(a, b, c)
#define	cmmu_flush_cache(a, b)	(cmmu->cmmu_flush_cache_func)(a, b)
#define	cmmu_flush_remote_inst_cache(a, b, c)	(cmmu->cmmu_flush_remote_inst_cache_func)(a, b, c)
#define	cmmu_flush_inst_cache(a, b)	(cmmu->cmmu_flush_inst_cache_func)(a, b)
#define	cmmu_flush_remote_data_cache(a, b, c)	(cmmu->cmmu_flush_remote_data_cache_func)(a, b, c)
#define	cmmu_flush_data_cache(a, b)	(cmmu->cmmu_flush_data_cache_func)(a, b)
@


1.14
log
@More cmmu routines cleanup:
- remove unused routines (which were mostly here for debugging anyway)
- do not include <machine/m88*.h> from <machine/cmmu.h> but rather only
  from the modules which need them
- try to simplify the MVME187 codepath in the 8820x code, whenever possible
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.13 2003/09/26 22:27:25 miod Exp $ */
d54 1
a54 1
/* machine dependant cmmu function pointer structure */
@


1.13
log
@Death to the bitfields, this time cmmu_apr_t and batc_entry_t. In the
process, remove duplicate batc defines.
@
text
@d1 2
a2 2
/*	$OpenBSD: cmmu.h,v 1.12 2003/09/16 20:52:19 miod Exp $ */
/* 
d6 1
a6 1
 * 
d12 1
a12 1
 * 
d16 1
a16 1
 * 
d18 1
a18 1
 * 
d23 2
a24 2
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon 
a32 22
/* Area Description */
#define AREA_D_WT	0x00000200	/* write through */
#define AREA_D_G	0x00000080	/* global */
#define AREA_D_CI	0x00000040	/* cache inhibit */
#define AREA_D_TE	0x00000001	/* translation enable */

/* Segment Description */
#define SEG_D_WT	0x00000200	/* write through */
#define SEG_D_SP	0x00000100	/* supervisor protection */
#define SEG_D_G		0x00000080	/* global */
#define SEG_D_CI	0x00000040	/* cache inhibit */
#define SEG_D_WP	0x00000004	/* write protect */
#define SEG_D_V		0x00000001	/* valid */

/*
 * Flags for cmmu_flush_tlb
 */
#define FLUSH_KERNEL    1
#define FLUSH_USER      0
#define FLUSH_ALL       ((vm_offset_t)~0)


d44 2
a45 2
 * This lock protects the cmmu SAR and SCR's; other ports 
 * can be accessed without locking it 
a56 1
	void (*show_apr_func)(unsigned);
a57 2
	void (*setup_cmmu_config_func)(void);
	void (*cmmu_dump_config_func)(void);
a61 2
	unsigned (*cmmu_get_idr_func)(unsigned);
	void (*cmmu_set_sapr_func)(unsigned);
a63 1
	void (*cmmu_set_batc_entry_func)(unsigned, unsigned, unsigned, unsigned);
d65 2
a66 2
	void (*cmmu_flush_remote_tlb_func)(unsigned, unsigned, vm_offset_t, int);
	void (*cmmu_flush_tlb_func)(unsigned, vm_offset_t, int);
d69 9
a77 9
	void (*cmmu_flush_remote_cache_func)(int, vm_offset_t, int);
	void (*cmmu_flush_cache_func)(vm_offset_t, int);
	void (*cmmu_flush_remote_inst_cache_func)(int, vm_offset_t, int);
	void (*cmmu_flush_inst_cache_func)(vm_offset_t, int);
	void (*cmmu_flush_remote_data_cache_func)(int, vm_offset_t, int);
	void (*cmmu_flush_data_cache_func)(vm_offset_t, int);
	void (*dma_cachectl_func)(vm_offset_t, int, int);
#ifdef DDB
	unsigned (*cmmu_get_by_mode_func)(int, int);
d79 2
a80 3
	void (*cmmu_cache_state_func)(unsigned, unsigned);
	void (*show_cmmu_info_func)(unsigned);
#endif /* end if DDB */
a85 3
extern struct cmmu_p cmmu88110;
extern struct cmmu_p cmmu8820x;

d87 1
a87 2
#define cmmu_init (cmmu->cmmu_init_func)
#define show_apr(ap) (cmmu->show_apr_func)(ap)
a88 2
#define	setup_cmmu_config 	(cmmu->setup_cmmu_config_func)
#define	cmmu_dump_config	(cmmu->cmmu_dump_config_func)
a92 2
#define	cmmu_get_idr(a)		(cmmu->cmmu_get_idr_func)(a)
#define	cmmu_set_sapr(a)	(cmmu->cmmu_set_sapr_func)(a)
a94 1
#define	cmmu_set_batc_entry(a, b, c, d) 	(cmmu->cmmu_set_batc_entry_func)(a, b, c, d)
d98 1
a98 1
#define	cmmu_pmap_activate(a, b, c, d) 	(cmmu->cmmu_pmap_activate_func)(a, b, c, d) 
d106 1
a106 2
#ifdef DDB
#define	cmmu_get_by_mode(a, b)	(cmmu->cmmu_get_by_mode_func)(a, b)
d108 1
a108 3
#define	cmmu_cache_state(a, b)	(cmmu->cmmu_cache_state_func)(a, b)
#define	show_cmmu_info(a)	(cmmu->show_cmmu_info_func)(a)
#endif /* end if DDB */
a110 8

#ifdef M88100
#include <machine/m8820x.h>
#endif /* M88100 */
#ifdef M88110
#include <machine/m88110.h>
#include <machine/m88410.h>
#endif /* M88110 */
@


1.12
log
@Remove unused material from include files, as well as the annoying U() macro
which is only used to obfuscate things.

Doing this points out that the BUG memory is not at the same address on
187 and 197 (the 197 BUG is inside obio), so provide distinct constants,
and treat 187 and 197 slightly differently in pmap_bootstrap(). However, we
now need to map the 197 flash memory as well...

While there, simplify and constify pmap_table_build() and its associated data.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.11 2002/03/14 01:26:39 millert Exp $ */
d96 1
a96 2
					     batc_template_t i_batc[BATC_MAX],
					     batc_template_t d_batc[BATC_MAX]);
@


1.11
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.10 2001/12/22 09:49:39 smurph Exp $ */
d61 1
a61 1
extern unsigned number_cpus, master_cpu;
a62 2
extern unsigned number_cpus;
extern unsigned master_cpu;
@


1.10
log
@masive cmmu overhaul.  function pointers now control cmmu functionality
instead of case statements based on cpu type.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.9 2001/12/16 23:49:46 miod Exp $ */
d80 18
a97 18
	void (*cmmu_init_func) __P((void));
	void (*show_apr_func) __P((unsigned));
	void (*setup_board_config_func) __P((void));
	void (*setup_cmmu_config_func) __P((void));
	void (*cmmu_dump_config_func) __P((void));
	void (*cpu_configuration_print_func) __P((int));
	void (*cmmu_shutdown_now_func) __P((void));
	void (*cmmu_parity_enable_func) __P((void));
	unsigned (*cmmu_cpu_number_func) __P((void));
	unsigned (*cmmu_get_idr_func) __P((unsigned));
	void (*cmmu_set_sapr_func) __P((unsigned));
	void (*cmmu_remote_set_sapr_func) __P((unsigned, unsigned));
	void (*cmmu_set_uapr_func) __P((unsigned));
	void (*cmmu_set_batc_entry_func) __P((unsigned, unsigned, unsigned, unsigned));
	void (*cmmu_set_pair_batc_entry_func) __P((unsigned, unsigned, unsigned));
	void (*cmmu_flush_remote_tlb_func) __P((unsigned, unsigned, vm_offset_t, int));
	void (*cmmu_flush_tlb_func) __P((unsigned, vm_offset_t, int));
	void (*cmmu_pmap_activate_func) __P((unsigned, unsigned,
d99 8
a106 8
					     batc_template_t d_batc[BATC_MAX]));
	void (*cmmu_flush_remote_cache_func) __P((int, vm_offset_t, int));
	void (*cmmu_flush_cache_func) __P((vm_offset_t, int));
	void (*cmmu_flush_remote_inst_cache_func) __P((int, vm_offset_t, int));
	void (*cmmu_flush_inst_cache_func) __P((vm_offset_t, int));
	void (*cmmu_flush_remote_data_cache_func) __P((int, vm_offset_t, int));
	void (*cmmu_flush_data_cache_func) __P((vm_offset_t, int));
	void (*dma_cachectl_func) __P((vm_offset_t, int, int));
d108 4
a111 4
	unsigned (*cmmu_get_by_mode_func) __P((int, int));
	void (*cmmu_show_translation_func) __P((unsigned, unsigned, unsigned, int));
	void (*cmmu_cache_state_func) __P((unsigned, unsigned));
	void (*show_cmmu_info_func) __P((unsigned));
@


1.9
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.6 2001/11/27 05:36:40 miod Exp $ */
d31 2
d63 2
a66 11
#ifdef CMMU_DEBUG
void show_apr(unsigned value);
void show_sctr(unsigned value);
#endif

#ifdef DDB
void cmmu_show_translation(unsigned, unsigned, unsigned, int);
void cmmu_cache_state(unsigned, unsigned);
void show_cmmu_info(unsigned);
#endif 

d68 4
a71 1
 * Prototypes from "mvme88k/mvme88k/cmmu.c"
d73 1
d75 78
a152 46
unsigned cmmu_cpu_number(void);
unsigned cmmu_remote_get(unsigned cpu, unsigned r, unsigned data);
unsigned cmmu_get_idr(unsigned data);
void cmmu_init(void);
void cmmu_shutdown_now(void);
void cmmu_parity_enable(void);
void setup_board_config(void);
void setup_cmmu_config(void);
void cmmu_dump_config(void);
unsigned cmmu_get_by_mode(int cpu, int mode);
void cpu_configuration_print(int master);
void dma_cachectl(vm_offset_t va, int size, int op);
void cmmu_remote_set(unsigned cpu, unsigned r, unsigned data, unsigned x);
void cmmu_set_sapr(unsigned ap);
void cmmu_remote_set_sapr(unsigned cpu, unsigned ap);
void cmmu_set_uapr(unsigned ap);
void cmmu_flush_tlb(unsigned kernel, vm_offset_t vaddr, int size);
void cmmu_flush_remote_cache(int cpu, vm_offset_t physaddr, int size);
void cmmu_flush_cache(vm_offset_t physaddr, int size);
void cmmu_flush_remote_inst_cache(int cpu, vm_offset_t physaddr, int size);
void cmmu_flush_inst_cache(vm_offset_t physaddr, int size);
void cmmu_flush_remote_data_cache(int cpu, vm_offset_t physaddr, int size);
void cmmu_flush_data_cache(vm_offset_t physaddr, int size);

void cmmu_pmap_activate(
    unsigned cpu,
    unsigned uapr,
    batc_template_t i_batc[BATC_MAX],
    batc_template_t d_batc[BATC_MAX]);

void cmmu_flush_remote_tlb(
	unsigned cpu,
	unsigned kernel,
	vm_offset_t vaddr,
	int size);

void cmmu_set_batc_entry(
     unsigned cpu,
     unsigned entry_no,
     unsigned data,   /* 1 = data, 0 = instruction */
     unsigned value);  /* the value to stuff into the batc */

void cmmu_set_pair_batc_entry(
     unsigned cpu,
     unsigned entry_no,
     unsigned value);  /* the value to stuff into the batc */
d156 8
d165 1
@


1.9.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.10 2001/12/22 09:49:39 smurph Exp $ */
a30 2
#include <machine/mmu.h>

a60 2
extern unsigned number_cpus;
extern unsigned master_cpu;
d63 11
d75 1
a75 4
 * This lock protects the cmmu SAR and SCR's; other ports 
 * can be accessed without locking it 
 *
 * May be used from "db_interface.c".
a76 1
extern struct simplelock cmmu_cpu_lock;
d78 46
a123 78
#define CMMU_LOCK   simple_lock(&cmmu_cpu_lock)
#define CMMU_UNLOCK simple_unlock(&cmmu_cpu_lock)

/* machine dependant cmmu function pointer structure */
struct cmmu_p {
	void (*cmmu_init_func) __P((void));
	void (*show_apr_func) __P((unsigned));
	void (*setup_board_config_func) __P((void));
	void (*setup_cmmu_config_func) __P((void));
	void (*cmmu_dump_config_func) __P((void));
	void (*cpu_configuration_print_func) __P((int));
	void (*cmmu_shutdown_now_func) __P((void));
	void (*cmmu_parity_enable_func) __P((void));
	unsigned (*cmmu_cpu_number_func) __P((void));
	unsigned (*cmmu_get_idr_func) __P((unsigned));
	void (*cmmu_set_sapr_func) __P((unsigned));
	void (*cmmu_remote_set_sapr_func) __P((unsigned, unsigned));
	void (*cmmu_set_uapr_func) __P((unsigned));
	void (*cmmu_set_batc_entry_func) __P((unsigned, unsigned, unsigned, unsigned));
	void (*cmmu_set_pair_batc_entry_func) __P((unsigned, unsigned, unsigned));
	void (*cmmu_flush_remote_tlb_func) __P((unsigned, unsigned, vm_offset_t, int));
	void (*cmmu_flush_tlb_func) __P((unsigned, vm_offset_t, int));
	void (*cmmu_pmap_activate_func) __P((unsigned, unsigned,
					     batc_template_t i_batc[BATC_MAX],
					     batc_template_t d_batc[BATC_MAX]));
	void (*cmmu_flush_remote_cache_func) __P((int, vm_offset_t, int));
	void (*cmmu_flush_cache_func) __P((vm_offset_t, int));
	void (*cmmu_flush_remote_inst_cache_func) __P((int, vm_offset_t, int));
	void (*cmmu_flush_inst_cache_func) __P((vm_offset_t, int));
	void (*cmmu_flush_remote_data_cache_func) __P((int, vm_offset_t, int));
	void (*cmmu_flush_data_cache_func) __P((vm_offset_t, int));
	void (*dma_cachectl_func) __P((vm_offset_t, int, int));
#ifdef DDB
	unsigned (*cmmu_get_by_mode_func) __P((int, int));
	void (*cmmu_show_translation_func) __P((unsigned, unsigned, unsigned, int));
	void (*cmmu_cache_state_func) __P((unsigned, unsigned));
	void (*show_cmmu_info_func) __P((unsigned));
#endif /* end if DDB */
};

/* THE pointer! */
extern struct cmmu_p *cmmu;

extern struct cmmu_p cmmu88110;
extern struct cmmu_p cmmu8820x;

/* The macros... */
#define cmmu_init (cmmu->cmmu_init_func)
#define show_apr(ap) (cmmu->show_apr_func)(ap)
#define setup_board_config	(cmmu->setup_board_config_func)
#define	setup_cmmu_config 	(cmmu->setup_cmmu_config_func)
#define	cmmu_dump_config	(cmmu->cmmu_dump_config_func)
#define	cpu_configuration_print(a)	(cmmu->cpu_configuration_print_func)(a)
#define	cmmu_shutdown_now	(cmmu->cmmu_shutdown_now_func)
#define	cmmu_parity_enable	(cmmu->cmmu_parity_enable_func)
#define	cmmu_cpu_number		(cmmu->cmmu_cpu_number_func)
#define	cmmu_get_idr(a)		(cmmu->cmmu_get_idr_func)(a)
#define	cmmu_set_sapr(a)	(cmmu->cmmu_set_sapr_func)(a)
#define	cmmu_remote_set_sapr(a, b)	(cmmu->cmmu_remote_set_sapr_func)(a, b)
#define	cmmu_set_uapr(a)	(cmmu->cmmu_set_uapr_func)(a)
#define	cmmu_set_batc_entry(a, b, c, d) 	(cmmu->cmmu_set_batc_entry_func)(a, b, c, d)
#define	cmmu_set_pair_batc_entry(a, b, c)	(cmmu->cmmu_set_pair_batc_entry_func)(a, b, c)
#define	cmmu_flush_remote_tlb(a, b, c, d) 	(cmmu->cmmu_flush_remote_tlb_func)(a, b, c, d)
#define	cmmu_flush_tlb(a, b, c)	(cmmu->cmmu_flush_tlb_func)(a, b, c)
#define	cmmu_pmap_activate(a, b, c, d) 	(cmmu->cmmu_pmap_activate_func)(a, b, c, d) 
#define	cmmu_flush_remote_cache(a, b, c)	(cmmu->cmmu_flush_remote_cache_func)(a, b, c)
#define	cmmu_flush_cache(a, b)	(cmmu->cmmu_flush_cache_func)(a, b)
#define	cmmu_flush_remote_inst_cache(a, b, c)	(cmmu->cmmu_flush_remote_inst_cache_func)(a, b, c)
#define	cmmu_flush_inst_cache(a, b)	(cmmu->cmmu_flush_inst_cache_func)(a, b)
#define	cmmu_flush_remote_data_cache(a, b, c)	(cmmu->cmmu_flush_remote_data_cache_func)(a, b, c)
#define	cmmu_flush_data_cache(a, b)	(cmmu->cmmu_flush_data_cache_func)(a, b)
#define	dma_cachectl(a, b, c)	(cmmu->dma_cachectl_func)(a, b, c)
#ifdef DDB
#define	cmmu_get_by_mode(a, b)	(cmmu->cmmu_get_by_mode_func)(a, b)
#define	cmmu_show_translation(a, b, c, d)	(cmmu->cmmu_show_translation_func)(a, b, c, d)
#define	cmmu_cache_state(a, b)	(cmmu->cmmu_cache_state_func)(a, b)
#define	show_cmmu_info(a)	(cmmu->show_cmmu_info_func)(a)
#endif /* end if DDB */
a126 8
#ifdef M88100
#include <machine/m8820x.h>
#endif /* M88100 */
#ifdef M88110
#include <machine/m88110.h>
#include <machine/m88410.h>
#endif /* M88110 */

a127 1

@


1.9.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.9.2.1 2002/01/31 22:55:18 niklas Exp $ */
d80 18
a97 18
	void (*cmmu_init_func)(void);
	void (*show_apr_func)(unsigned);
	void (*setup_board_config_func)(void);
	void (*setup_cmmu_config_func)(void);
	void (*cmmu_dump_config_func)(void);
	void (*cpu_configuration_print_func)(int);
	void (*cmmu_shutdown_now_func)(void);
	void (*cmmu_parity_enable_func)(void);
	unsigned (*cmmu_cpu_number_func)(void);
	unsigned (*cmmu_get_idr_func)(unsigned);
	void (*cmmu_set_sapr_func)(unsigned);
	void (*cmmu_remote_set_sapr_func)(unsigned, unsigned);
	void (*cmmu_set_uapr_func)(unsigned);
	void (*cmmu_set_batc_entry_func)(unsigned, unsigned, unsigned, unsigned);
	void (*cmmu_set_pair_batc_entry_func)(unsigned, unsigned, unsigned);
	void (*cmmu_flush_remote_tlb_func)(unsigned, unsigned, vm_offset_t, int);
	void (*cmmu_flush_tlb_func)(unsigned, vm_offset_t, int);
	void (*cmmu_pmap_activate_func)(unsigned, unsigned,
d99 8
a106 8
					     batc_template_t d_batc[BATC_MAX]);
	void (*cmmu_flush_remote_cache_func)(int, vm_offset_t, int);
	void (*cmmu_flush_cache_func)(vm_offset_t, int);
	void (*cmmu_flush_remote_inst_cache_func)(int, vm_offset_t, int);
	void (*cmmu_flush_inst_cache_func)(vm_offset_t, int);
	void (*cmmu_flush_remote_data_cache_func)(int, vm_offset_t, int);
	void (*cmmu_flush_data_cache_func)(vm_offset_t, int);
	void (*dma_cachectl_func)(vm_offset_t, int, int);
d108 4
a111 4
	unsigned (*cmmu_get_by_mode_func)(int, int);
	void (*cmmu_show_translation_func)(unsigned, unsigned, unsigned, int);
	void (*cmmu_cache_state_func)(unsigned, unsigned);
	void (*show_cmmu_info_func)(unsigned);
@


1.8
log
@Repair MVME187 after MVME197 merge.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.7 2001/12/13 08:55:51 smurph Exp $ */
a30 2
#include <machine/mmu.h>

d61 12
a72 3
extern unsigned number_cpus;
extern unsigned master_cpu;
extern int      max_cpus, max_cmmus;
d74 2
a75 5
/* 
 * This lock protects the cmmu SAR and SCR's; other ports 
 * can be accessed without locking it 
 *
 * May be used from "db_interface.c".
a76 1
extern struct simplelock cmmu_cpu_lock;
d78 46
a123 78
#define CMMU_LOCK   simple_lock(&cmmu_cpu_lock)
#define CMMU_UNLOCK simple_unlock(&cmmu_cpu_lock)

/* machine dependant cmmu function pointer structure */
struct cmmu_p {
	void (*cmmu_init_func) __P((void));
	void (*show_apr_func) __P((unsigned));
	void (*setup_board_config_func) __P((void));
	void (*setup_cmmu_config_func) __P((void));
	void (*cmmu_dump_config_func) __P((void));
	void (*cpu_configuration_print_func) __P((int));
	void (*cmmu_shutdown_now_func) __P((void));
	void (*cmmu_parity_enable_func) __P((void));
	unsigned (*cmmu_cpu_number_func) __P((void));
	unsigned (*cmmu_get_idr_func) __P((unsigned));
	void (*cmmu_set_sapr_func) __P((unsigned));
	void (*cmmu_remote_set_sapr_func) __P((unsigned, unsigned));
	void (*cmmu_set_uapr_func) __P((unsigned));
	void (*cmmu_set_batc_entry_func) __P((unsigned, unsigned, unsigned, unsigned));
	void (*cmmu_set_pair_batc_entry_func) __P((unsigned, unsigned, unsigned));
	void (*cmmu_flush_remote_tlb_func) __P((unsigned, unsigned, vm_offset_t, int));
	void (*cmmu_flush_tlb_func) __P((unsigned, vm_offset_t, int));
	void (*cmmu_pmap_activate_func) __P((unsigned, unsigned,
					     batc_template_t i_batc[BATC_MAX],
					     batc_template_t d_batc[BATC_MAX]));
	void (*cmmu_flush_remote_cache_func) __P((int, vm_offset_t, int));
	void (*cmmu_flush_cache_func) __P((vm_offset_t, int));
	void (*cmmu_flush_remote_inst_cache_func) __P((int, vm_offset_t, int));
	void (*cmmu_flush_inst_cache_func) __P((vm_offset_t, int));
	void (*cmmu_flush_remote_data_cache_func) __P((int, vm_offset_t, int));
	void (*cmmu_flush_data_cache_func) __P((vm_offset_t, int));
	void (*dma_cachectl_func) __P((vm_offset_t, int, int));
#ifdef DDB
	unsigned (*cmmu_get_by_mode_func) __P((int, int));
	void (*cmmu_show_translation_func) __P((unsigned, unsigned, unsigned, int));
	void (*cmmu_cache_state_func) __P((unsigned, unsigned));
	void (*show_cmmu_info_func) __P((unsigned));
#endif /* end if DDB */
};

/* THE pointer! */
extern struct cmmu_p *cmmu;

extern struct cmmu_p cmmu88110;
extern struct cmmu_p cmmu8820x;

/* The macros... */
#define cmmu_init (cmmu->cmmu_init_func)
#define show_apr(ap) (cmmu->show_apr_func)(ap)
#define setup_board_config	(cmmu->setup_board_config_func)
#define	setup_cmmu_config 	(cmmu->setup_cmmu_config_func)
#define	cmmu_dump_config	(cmmu->cmmu_dump_config_func)
#define	cpu_configuration_print(a)	(cmmu->cpu_configuration_print_func)(a)
#define	cmmu_shutdown_now	(cmmu->cmmu_shutdown_now_func)
#define	cmmu_parity_enable	(cmmu->cmmu_parity_enable_func)
#define	cmmu_cpu_number		(cmmu->cmmu_cpu_number_func)
#define	cmmu_get_idr(a)		(cmmu->cmmu_get_idr_func)(a)
#define	cmmu_set_sapr(a)	(cmmu->cmmu_set_sapr_func)(a)
#define	cmmu_remote_set_sapr(a, b)	(cmmu->cmmu_remote_set_sapr_func)(a, b)
#define	cmmu_set_uapr(a)	(cmmu->cmmu_set_uapr_func)(a)
#define	cmmu_set_batc_entry(a, b, c, d) 	(cmmu->cmmu_set_batc_entry_func)(a, b, c, d)
#define	cmmu_set_pair_batc_entry(a, b, c)	(cmmu->cmmu_set_pair_batc_entry_func)(a, b, c)
#define	cmmu_flush_remote_tlb(a, b, c, d) 	(cmmu->cmmu_flush_remote_tlb_func)(a, b, c, d)
#define	cmmu_flush_tlb(a, b, c)	(cmmu->cmmu_flush_tlb_func)(a, b, c)
#define	cmmu_pmap_activate(a, b, c, d) 	(cmmu->cmmu_pmap_activate_func)(a, b, c, d) 
#define	cmmu_flush_remote_cache(a, b, c)	(cmmu->cmmu_flush_remote_cache_func)(a, b, c)
#define	cmmu_flush_cache(a, b)	(cmmu->cmmu_flush_cache_func)(a, b)
#define	cmmu_flush_remote_inst_cache(a, b, c)	(cmmu->cmmu_flush_remote_inst_cache_func)(a, b, c)
#define	cmmu_flush_inst_cache(a, b)	(cmmu->cmmu_flush_inst_cache_func)(a, b)
#define	cmmu_flush_remote_data_cache(a, b, c)	(cmmu->cmmu_flush_remote_data_cache_func)(a, b, c)
#define	cmmu_flush_data_cache(a, b)	(cmmu->cmmu_flush_data_cache_func)(a, b)
#define	dma_cachectl(a, b, c)	(cmmu->dma_cachectl_func)(a, b, c)
#ifdef DDB
#define	cmmu_get_by_mode(a, b)	(cmmu->cmmu_get_by_mode_func)(a, b)
#define	cmmu_show_translation(a, b, c, d)	(cmmu->cmmu_show_translation_func)(a, b, c, d)
#define	cmmu_cache_state(a, b)	(cmmu->cmmu_cache_state_func)(a, b)
#define	show_cmmu_info(a)	(cmmu->show_cmmu_info_func)(a)
#endif /* end if DDB */
a126 8
#ifdef M88100
#include <machine/m8820x.h>
#endif /* M88100 */
#ifdef M88110
#include <machine/m88110.h>
#include <machine/m88410.h>
#endif /* M88110 */

a127 1

@


1.7
log
@Support for MVME197 completed.  Fix SPL defs.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.6 2001/11/27 05:36:40 miod Exp $ */
a88 2
	void (*cmmu_remote_set_func) __P((unsigned, unsigned, unsigned, unsigned));
	unsigned (*cmmu_remote_get_func) __P((unsigned, unsigned, unsigned));
a130 2
#define	cmmu_remote_set(a, b, c, d)	(cmmu->cmmu_remote_set_func)(a, b, c, d)
#define	cmmu_remote_get(a, b, c)	(cmmu->cmmu_remote_get_func)(a, b, c)
@


1.6
log
@A few cleanups to have less include files include each other.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.5 2001/08/26 14:31:07 miod Exp $ */
d31 2
d63 11
a73 1
extern int max_cpus, max_cmmus;
d75 2
a76 4
#ifdef CMMU_DEBUG
void show_apr(unsigned value);
void show_sctr(unsigned value);
#endif
d78 73
d152 5
a156 4
void cmmu_show_translation(unsigned, unsigned, unsigned, int);
void cmmu_cache_state(unsigned, unsigned);
void show_cmmu_info(unsigned);
#endif 
d158 1
a158 3
/*
 * Prototypes from "mvme88k/mvme88k/cmmu.c"
 */
d160 7
a166 46
unsigned cmmu_cpu_number(void);
unsigned cmmu_remote_get(unsigned cpu, unsigned r, unsigned data);
unsigned cmmu_get_idr(unsigned data);
void cmmu_init(void);
void cmmu_shutdown_now(void);
void cmmu_parity_enable(void);
void setup_board_config(void);
void setup_cmmu_config(void);
void cmmu_dump_config(void);
unsigned cmmu_get_by_mode(int cpu, int mode);
void cpu_configuration_print(int master);
void dma_cachectl(vm_offset_t va, int size, int op);
void cmmu_remote_set(unsigned cpu, unsigned r, unsigned data, unsigned x);
void cmmu_set_sapr(unsigned ap);
void cmmu_remote_set_sapr(unsigned cpu, unsigned ap);
void cmmu_set_uapr(unsigned ap);
void cmmu_flush_tlb(unsigned kernel, vm_offset_t vaddr, int size);
void cmmu_flush_remote_cache(int cpu, vm_offset_t physaddr, int size);
void cmmu_flush_cache(vm_offset_t physaddr, int size);
void cmmu_flush_remote_inst_cache(int cpu, vm_offset_t physaddr, int size);
void cmmu_flush_inst_cache(vm_offset_t physaddr, int size);
void cmmu_flush_remote_data_cache(int cpu, vm_offset_t physaddr, int size);
void cmmu_flush_data_cache(vm_offset_t physaddr, int size);

void cmmu_pmap_activate(
    unsigned cpu,
    unsigned uapr,
    batc_template_t i_batc[BATC_MAX],
    batc_template_t d_batc[BATC_MAX]);

void cmmu_flush_remote_tlb(
	unsigned cpu,
	unsigned kernel,
	vm_offset_t vaddr,
	int size);

void cmmu_set_batc_entry(
     unsigned cpu,
     unsigned entry_no,
     unsigned data,   /* 1 = data, 0 = instruction */
     unsigned value);  /* the value to stuff into the batc */

void cmmu_set_pair_batc_entry(
     unsigned cpu,
     unsigned entry_no,
     unsigned value);  /* the value to stuff into the batc */
d168 1
a168 1
#endif	/* _LOCORE */
a169 1
#endif	/* _MACHINE_CMMU_H_ */
@


1.5
log
@Add prototypes, fix compilation warnings, random style fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.4 2001/08/11 01:55:52 miod Exp $ */
a26 12
/*
 * HISTORY
 * 
 */


#ifndef	__MACHINE_CMMU_H__
#define	__MACHINE_CMMU_H__

#ifndef _LOCORE
#include <machine/mmu.h>		 /* batc_template_t */
#endif
d28 2
a29 1
#include <machine/board.h>
d127 1
a127 1
#endif	/* __MACHINE_CMMU_H__ */
@


1.4
log
@Include files serve a purpose. Move lots of extern statements from
foo_cmmu.c to cmmu.h ; also don't check for 197 in m18x_cmmu.c, as this
code is 18x specific.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.3 2001/03/09 05:44:40 smurph Exp $ */
d79 1
a79 1
#if DDB
a89 3
#if !DDB
static
#endif /* !DDB */
a94 3
#if !DDB
static
#endif /* !DDB */
@


1.3
log
@kernel will compile with -Werror.  Added intr.h
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.2 2001/03/07 23:37:15 miod Exp $ */
d70 1
a70 1
extern unsigned ncpus;
d72 1
d84 1
d86 1
a86 1
 * Prototypes from "mvme88k/mvme88k/cmmu.c
@


1.2
log
@Inclusion from assembly code is detected with _LOCORE, no more fancy symbols.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.1 1999/09/27 20:46:17 smurph Exp $ */
d74 2
a75 2
 void show_apr(unsigned value);
 void show_sctr(unsigned value);
d78 5
d84 1
a84 1
 * Prototypes from "mvme88k/mvme88k/cmmu.c"
d86 1
d99 6
@


1.1
log
@Adding support for MVME188 and MVME197
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.0 1999/02/09 06:36:26 smurph Exp $ */
d36 1
a36 1
#ifndef ASSEMBLER
d64 1
a64 1
#ifndef	ASSEMBLER
d128 1
a128 1
#endif	/* ASSEMBLER */
@


1.1.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.3 2001/03/09 05:44:40 smurph Exp $ */
d36 1
a36 1
#ifndef _LOCORE
d64 1
a64 1
#ifndef	_LOCORE
d74 2
a75 2
void show_apr(unsigned value);
void show_sctr(unsigned value);
a77 5
#if DDB
void cmmu_show_translation(unsigned, unsigned, unsigned, int);
void cmmu_cache_state(unsigned, unsigned);
void show_cmmu_info(unsigned);
#endif 
d79 1
a79 1
 * Prototypes from "mvme88k/mvme88k/cmmu.c
a80 1

a92 6
void setup_board_config(void);
void setup_cmmu_config(void);
void cmmu_dump_config(void);
unsigned cmmu_get_by_mode(int cpu, int mode);
void cpu_configuration_print(int master);
void dma_cachectl(vm_offset_t va, int size, int op);
d128 1
a128 1
#endif	/* _LOCORE */
@


1.1.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.1.4.1 2001/04/18 16:11:14 niklas Exp $ */
d70 1
a70 1
extern unsigned number_cpus, master_cpu;
a71 1
extern int max_cpus, max_cmmus;
d78 1
a78 1
#ifdef DDB
a82 1

d84 1
a84 1
 * Prototypes from "mvme88k/mvme88k/cmmu.c"
d88 3
d96 3
@


1.1.4.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.1.4.2 2001/10/31 03:01:18 nate Exp $ */
d27 12
d40 1
a40 2
#ifndef	_MACHINE_CMMU_H_
#define	_MACHINE_CMMU_H_
d138 1
a138 1
#endif	/* _MACHINE_CMMU_H_ */
@


1.1.4.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a30 2
#include <machine/mmu.h>

a60 2
extern unsigned number_cpus;
extern unsigned master_cpu;
d63 11
d75 1
a75 4
 * This lock protects the cmmu SAR and SCR's; other ports 
 * can be accessed without locking it 
 *
 * May be used from "db_interface.c".
a76 1
extern struct simplelock cmmu_cpu_lock;
d78 46
a123 78
#define CMMU_LOCK   simple_lock(&cmmu_cpu_lock)
#define CMMU_UNLOCK simple_unlock(&cmmu_cpu_lock)

/* machine dependant cmmu function pointer structure */
struct cmmu_p {
	void (*cmmu_init_func) __P((void));
	void (*show_apr_func) __P((unsigned));
	void (*setup_board_config_func) __P((void));
	void (*setup_cmmu_config_func) __P((void));
	void (*cmmu_dump_config_func) __P((void));
	void (*cpu_configuration_print_func) __P((int));
	void (*cmmu_shutdown_now_func) __P((void));
	void (*cmmu_parity_enable_func) __P((void));
	unsigned (*cmmu_cpu_number_func) __P((void));
	unsigned (*cmmu_get_idr_func) __P((unsigned));
	void (*cmmu_set_sapr_func) __P((unsigned));
	void (*cmmu_remote_set_sapr_func) __P((unsigned, unsigned));
	void (*cmmu_set_uapr_func) __P((unsigned));
	void (*cmmu_set_batc_entry_func) __P((unsigned, unsigned, unsigned, unsigned));
	void (*cmmu_set_pair_batc_entry_func) __P((unsigned, unsigned, unsigned));
	void (*cmmu_flush_remote_tlb_func) __P((unsigned, unsigned, vm_offset_t, int));
	void (*cmmu_flush_tlb_func) __P((unsigned, vm_offset_t, int));
	void (*cmmu_pmap_activate_func) __P((unsigned, unsigned,
					     batc_template_t i_batc[BATC_MAX],
					     batc_template_t d_batc[BATC_MAX]));
	void (*cmmu_flush_remote_cache_func) __P((int, vm_offset_t, int));
	void (*cmmu_flush_cache_func) __P((vm_offset_t, int));
	void (*cmmu_flush_remote_inst_cache_func) __P((int, vm_offset_t, int));
	void (*cmmu_flush_inst_cache_func) __P((vm_offset_t, int));
	void (*cmmu_flush_remote_data_cache_func) __P((int, vm_offset_t, int));
	void (*cmmu_flush_data_cache_func) __P((vm_offset_t, int));
	void (*dma_cachectl_func) __P((vm_offset_t, int, int));
#ifdef DDB
	unsigned (*cmmu_get_by_mode_func) __P((int, int));
	void (*cmmu_show_translation_func) __P((unsigned, unsigned, unsigned, int));
	void (*cmmu_cache_state_func) __P((unsigned, unsigned));
	void (*show_cmmu_info_func) __P((unsigned));
#endif /* end if DDB */
};

/* THE pointer! */
extern struct cmmu_p *cmmu;

extern struct cmmu_p cmmu88110;
extern struct cmmu_p cmmu8820x;

/* The macros... */
#define cmmu_init (cmmu->cmmu_init_func)
#define show_apr(ap) (cmmu->show_apr_func)(ap)
#define setup_board_config	(cmmu->setup_board_config_func)
#define	setup_cmmu_config 	(cmmu->setup_cmmu_config_func)
#define	cmmu_dump_config	(cmmu->cmmu_dump_config_func)
#define	cpu_configuration_print(a)	(cmmu->cpu_configuration_print_func)(a)
#define	cmmu_shutdown_now	(cmmu->cmmu_shutdown_now_func)
#define	cmmu_parity_enable	(cmmu->cmmu_parity_enable_func)
#define	cmmu_cpu_number		(cmmu->cmmu_cpu_number_func)
#define	cmmu_get_idr(a)		(cmmu->cmmu_get_idr_func)(a)
#define	cmmu_set_sapr(a)	(cmmu->cmmu_set_sapr_func)(a)
#define	cmmu_remote_set_sapr(a, b)	(cmmu->cmmu_remote_set_sapr_func)(a, b)
#define	cmmu_set_uapr(a)	(cmmu->cmmu_set_uapr_func)(a)
#define	cmmu_set_batc_entry(a, b, c, d) 	(cmmu->cmmu_set_batc_entry_func)(a, b, c, d)
#define	cmmu_set_pair_batc_entry(a, b, c)	(cmmu->cmmu_set_pair_batc_entry_func)(a, b, c)
#define	cmmu_flush_remote_tlb(a, b, c, d) 	(cmmu->cmmu_flush_remote_tlb_func)(a, b, c, d)
#define	cmmu_flush_tlb(a, b, c)	(cmmu->cmmu_flush_tlb_func)(a, b, c)
#define	cmmu_pmap_activate(a, b, c, d) 	(cmmu->cmmu_pmap_activate_func)(a, b, c, d) 
#define	cmmu_flush_remote_cache(a, b, c)	(cmmu->cmmu_flush_remote_cache_func)(a, b, c)
#define	cmmu_flush_cache(a, b)	(cmmu->cmmu_flush_cache_func)(a, b)
#define	cmmu_flush_remote_inst_cache(a, b, c)	(cmmu->cmmu_flush_remote_inst_cache_func)(a, b, c)
#define	cmmu_flush_inst_cache(a, b)	(cmmu->cmmu_flush_inst_cache_func)(a, b)
#define	cmmu_flush_remote_data_cache(a, b, c)	(cmmu->cmmu_flush_remote_data_cache_func)(a, b, c)
#define	cmmu_flush_data_cache(a, b)	(cmmu->cmmu_flush_data_cache_func)(a, b)
#define	dma_cachectl(a, b, c)	(cmmu->dma_cachectl_func)(a, b, c)
#ifdef DDB
#define	cmmu_get_by_mode(a, b)	(cmmu->cmmu_get_by_mode_func)(a, b)
#define	cmmu_show_translation(a, b, c, d)	(cmmu->cmmu_show_translation_func)(a, b, c, d)
#define	cmmu_cache_state(a, b)	(cmmu->cmmu_cache_state_func)(a, b)
#define	show_cmmu_info(a)	(cmmu->show_cmmu_info_func)(a)
#endif /* end if DDB */
a126 8
#ifdef M88100
#include <machine/m8820x.h>
#endif /* M88100 */
#ifdef M88110
#include <machine/m88110.h>
#include <machine/m88410.h>
#endif /* M88110 */

a127 1

@


1.1.4.5
log
@Merge in -current from about a week ago
@
text
@d80 18
a97 18
	void (*cmmu_init_func)(void);
	void (*show_apr_func)(unsigned);
	void (*setup_board_config_func)(void);
	void (*setup_cmmu_config_func)(void);
	void (*cmmu_dump_config_func)(void);
	void (*cpu_configuration_print_func)(int);
	void (*cmmu_shutdown_now_func)(void);
	void (*cmmu_parity_enable_func)(void);
	unsigned (*cmmu_cpu_number_func)(void);
	unsigned (*cmmu_get_idr_func)(unsigned);
	void (*cmmu_set_sapr_func)(unsigned);
	void (*cmmu_remote_set_sapr_func)(unsigned, unsigned);
	void (*cmmu_set_uapr_func)(unsigned);
	void (*cmmu_set_batc_entry_func)(unsigned, unsigned, unsigned, unsigned);
	void (*cmmu_set_pair_batc_entry_func)(unsigned, unsigned, unsigned);
	void (*cmmu_flush_remote_tlb_func)(unsigned, unsigned, vm_offset_t, int);
	void (*cmmu_flush_tlb_func)(unsigned, vm_offset_t, int);
	void (*cmmu_pmap_activate_func)(unsigned, unsigned,
d99 8
a106 8
					     batc_template_t d_batc[BATC_MAX]);
	void (*cmmu_flush_remote_cache_func)(int, vm_offset_t, int);
	void (*cmmu_flush_cache_func)(vm_offset_t, int);
	void (*cmmu_flush_remote_inst_cache_func)(int, vm_offset_t, int);
	void (*cmmu_flush_inst_cache_func)(vm_offset_t, int);
	void (*cmmu_flush_remote_data_cache_func)(int, vm_offset_t, int);
	void (*cmmu_flush_data_cache_func)(vm_offset_t, int);
	void (*dma_cachectl_func)(vm_offset_t, int, int);
d108 4
a111 4
	unsigned (*cmmu_get_by_mode_func)(int, int);
	void (*cmmu_show_translation_func)(unsigned, unsigned, unsigned, int);
	void (*cmmu_cache_state_func)(unsigned, unsigned);
	void (*show_cmmu_info_func)(unsigned);
@


1.1.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d2 1
a2 1
/*
d6 1
a6 1
 *
d12 1
a12 1
 *
d16 1
a16 1
 *
d18 1
a18 1
 *
d23 2
a24 2
 *
 * any improvements or extensions that they make and grant Carnegie Mellon
d33 22
d60 4
d68 2
a69 2
 * This lock protects the cmmu SAR and SCR's; other ports
 * can be accessed without locking it
d78 1
a78 1
/* machine dependent cmmu function pointer structure */
d81 1
d83 2
d89 3
a91 1
	void (*cmmu_set_sapr_func)(unsigned, unsigned);
d93 1
d95 2
a96 1
	void (*cmmu_flush_tlb_func)(unsigned, unsigned, vaddr_t, vsize_t);
d98 11
a108 7
	    u_int32_t i_batc[BATC_MAX], u_int32_t d_batc[BATC_MAX]);
	void (*cmmu_flush_cache_func)(int, paddr_t, psize_t);
	void (*cmmu_flush_inst_cache_func)(int, paddr_t, psize_t);
	void (*cmmu_flush_data_cache_func)(int, paddr_t, psize_t);
	void (*dma_cachectl_func)(vaddr_t, vsize_t, int);
	/* DDB only */
	void (*cmmu_dump_config_func)(void);
d110 3
a112 2
	/* DEBUG only */
	void (*show_apr_func)(unsigned);
d118 3
d122 2
a123 1
#define cmmu_init		(cmmu->cmmu_init_func)
d125 2
d131 3
a133 1
#define	cmmu_set_sapr(a, b)	(cmmu->cmmu_set_sapr_func)(a, b)
d135 1
d137 9
a145 5
#define	cmmu_flush_tlb(a, b, c, d) 	(cmmu->cmmu_flush_tlb_func)(a, b, c, d)
#define	cmmu_pmap_activate(a, b, c, d) 	(cmmu->cmmu_pmap_activate_func)(a, b, c, d)
#define	cmmu_flush_cache(a, b, c)	(cmmu->cmmu_flush_cache_func)(a, b, c)
#define	cmmu_flush_inst_cache(a, b, c)	(cmmu->cmmu_flush_inst_cache_func)(a, b, c)
#define	cmmu_flush_data_cache(a, b, c)	(cmmu->cmmu_flush_data_cache_func)(a, b, c)
d147 2
a148 1
#define	cmmu_dump_config	(cmmu->cmmu_dump_config_func)
d150 3
a152 1
#define show_apr(ap)		(cmmu->show_apr_func)(ap)
d155 8
@


1.1.4.7
log
@Merge with the trunk
@
text
@d1 103
a103 3
/* $OpenBSD$ */
/* public domain */
#include <m88k/cmmu.h>
@


