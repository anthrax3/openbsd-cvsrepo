head	1.50;
access;
symbols
	OPENBSD_5_5:1.49.0.4
	OPENBSD_5_5_BASE:1.49
	OPENBSD_5_4:1.48.0.8
	OPENBSD_5_4_BASE:1.48
	OPENBSD_5_3:1.48.0.6
	OPENBSD_5_3_BASE:1.48
	OPENBSD_5_2:1.48.0.4
	OPENBSD_5_2_BASE:1.48
	OPENBSD_5_1_BASE:1.48
	OPENBSD_5_1:1.48.0.2
	OPENBSD_5_0:1.47.0.4
	OPENBSD_5_0_BASE:1.47
	OPENBSD_4_9:1.47.0.2
	OPENBSD_4_9_BASE:1.47
	OPENBSD_4_8:1.45.0.4
	OPENBSD_4_8_BASE:1.45
	OPENBSD_4_7:1.45.0.2
	OPENBSD_4_7_BASE:1.45
	OPENBSD_4_6:1.44.0.4
	OPENBSD_4_6_BASE:1.44
	OPENBSD_4_5:1.42.0.6
	OPENBSD_4_5_BASE:1.42
	OPENBSD_4_4:1.42.0.2
	OPENBSD_4_4_BASE:1.42
	OPENBSD_4_3:1.41.0.2
	OPENBSD_4_3_BASE:1.41
	OPENBSD_4_2:1.39.0.2
	OPENBSD_4_2_BASE:1.39
	OPENBSD_4_1:1.35.0.2
	OPENBSD_4_1_BASE:1.35
	OPENBSD_4_0:1.34.0.2
	OPENBSD_4_0_BASE:1.34
	OPENBSD_3_9:1.33.0.2
	OPENBSD_3_9_BASE:1.33
	OPENBSD_3_8:1.31.0.2
	OPENBSD_3_8_BASE:1.31
	OPENBSD_3_7:1.30.0.2
	OPENBSD_3_7_BASE:1.30
	OPENBSD_3_6:1.29.0.2
	OPENBSD_3_6_BASE:1.29
	SMP_SYNC_A:1.28
	SMP_SYNC_B:1.28
	OPENBSD_3_5:1.25.0.2
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.23.0.2
	OPENBSD_3_4_BASE:1.23
	UBC_SYNC_A:1.21
	OPENBSD_3_3:1.20.0.6
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.20.0.4
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.20.0.2
	OPENBSD_3_1_BASE:1.20
	UBC_SYNC_B:1.20
	UBC:1.17.0.2
	UBC_BASE:1.17
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.7.0.4
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	SMP:1.6.0.4
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	mvme88kport:1.1.1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.50
date	2014.03.18.22.36.36;	author miod;	state dead;
branches;
next	1.49;

1.49
date	2013.11.02.23.10.30;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2011.10.09.17.01.34;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2010.12.23.20.05.08;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2010.11.18.21.13.19;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2009.10.26.20.17.27;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2009.03.15.20.39.53;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2009.03.05.21.55.15;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2008.07.21.04.35.54;	author todd;	state Exp;
branches;
next	1.41;

1.41
date	2007.10.28.19.48.47;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2007.10.13.12.55.21;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2007.06.15.01.19.08;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2007.06.01.19.25.10;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2007.05.04.19.30.55;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2007.05.04.03.44.44;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2006.11.28.16.56.50;	author dlg;	state Exp;
branches;
next	1.34;

1.34
date	2006.05.02.21.43.09;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2006.01.11.07.22.01;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2005.12.27.18.31.10;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2005.04.30.16.42.37;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2004.12.25.23.02.25;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2004.07.20.20.33.21;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2004.05.04.15.27.20;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2004.04.24.19.51.49;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2004.04.14.20.18.18;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2004.02.11.20.41.08;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2003.10.05.20.25.08;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2003.09.02.20.14.08;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2003.09.02.17.32.44;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2003.04.06.18.54.19;	author ho;	state Exp;
branches;
next	1.20;

1.20
date	2002.03.14.01.26.39;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.01.16.20.50.17;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.24.04.07.26;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.10.00.58.04;	author miod;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2001.11.20.23.55.39;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.09.00.12.21;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.28.20.49.17;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2001.09.19.21.32.19;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.05.22.34.01;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.04.29.19.00.02;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.16.00.03.58;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.09.05.44.41;	author smurph;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.13.05.18.59;	author smurph;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.03.00.54.53;	author todd;	state Exp;
branches;
next	1.6;

1.6
date	99.09.27.19.13.20;	author smurph;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	99.05.29.04.41.45;	author smurph;	state Exp;
branches;
next	1.4;

1.4
date	98.12.15.05.11.01;	author smurph;	state Exp;
branches;
next	1.3;

1.3
date	97.03.03.20.21.28;	author rahnds;	state Exp;
branches;
next	1.2;

1.2
date	97.03.03.19.07.57;	author rahnds;	state dead;
branches;
next	1.1;

1.1
date	95.10.18.12.32.17;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.03.03.19.32.09;	author rahnds;	state Exp;
branches;
next	;

1.6.4.1
date	2000.03.24.09.08.16;	author niklas;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2001.04.18.16.11.29;	author niklas;	state Exp;
branches;
next	1.6.4.3;

1.6.4.3
date	2001.07.04.10.20.06;	author niklas;	state Exp;
branches;
next	1.6.4.4;

1.6.4.4
date	2001.10.31.03.01.19;	author nate;	state Exp;
branches;
next	1.6.4.5;

1.6.4.5
date	2001.11.13.21.04.15;	author niklas;	state Exp;
branches;
next	1.6.4.6;

1.6.4.6
date	2001.12.05.00.39.12;	author niklas;	state Exp;
branches;
next	1.6.4.7;

1.6.4.7
date	2002.03.06.02.04.44;	author niklas;	state Exp;
branches;
next	1.6.4.8;

1.6.4.8
date	2002.03.28.10.36.02;	author niklas;	state Exp;
branches;
next	1.6.4.9;

1.6.4.9
date	2003.05.13.19.41.06;	author ho;	state Exp;
branches;
next	1.6.4.10;

1.6.4.10
date	2004.02.19.10.49.07;	author niklas;	state Exp;
branches;
next	1.6.4.11;

1.6.4.11
date	2004.06.05.23.09.50;	author niklas;	state Exp;
branches;
next	;

1.17.2.1
date	2002.01.31.22.55.18;	author niklas;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2002.06.11.03.37.10;	author art;	state Exp;
branches;
next	1.17.2.3;

1.17.2.3
date	2003.05.19.21.45.53;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.50
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: autoconf.c,v 1.49 2013/11/02 23:10:30 miod Exp $	*/
/*
 * Copyright (c) 1998 Steve Murphree, Jr.
 * Copyright (c) 1996 Nivas Madhur
 * Copyright (c) 1994 Christian E. Hopps
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christian E. Hopps.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/reboot.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/disklabel.h>
#include <sys/kernel.h>

#include <uvm/uvm.h>

#include <machine/asm_macro.h>   /* enable/disable interrupts */
#include <machine/autoconf.h>
#include <machine/bugio.h>
#include <machine/cpu.h>
#include <machine/vmparam.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <dev/cons.h>

/*
 * The following several variables are related to
 * the configuration process, and are used in initializing
 * the machine.
 */

void	dumpconf(void);
int	get_target(int *, int *, int *);

int cold = 1;   /* 1 if still booting */

paddr_t bootaddr;
int bootpart, bootbus;
struct device *bootdv;	/* set by device drivers (if found) */

/*
 * called at boot time, configure all devices on the system.
 */
void
cpu_configure()
{
	extern void cpu_hatch_secondary_processors(void *);
	softintr_init();

	if (config_rootfound("mainbus", "mainbus") == 0)
		panic("no mainbus found");


	/*
	 * Finally switch to the real console driver,
	 * and say goodbye to the BUG!
	 */
	cn_tab = NULL;
	cninit();

#ifdef MULTIPROCESSOR
	/*
	 * Spin up the other processors, but do not give them work to
	 * do yet.
	 */
	cpu_hatch_secondary_processors(NULL);
#endif

	/* NO BUG CALLS FROM NOW ON */

	/*
	 * Switch to our final trap vectors, and unmap the BUG data area.
	 */
	set_vbr(kernel_vbr);
	pmap_unmap_firmware();

	cold = 0;

	/*
	 * Turn external interrupts on.
	 */
	set_psr(get_psr() & ~PSR_IND);
	spl0();
}

void
diskconf(void)
{
	printf("boot device: %s\n",
	    (bootdv) ? bootdv->dv_xname : "<unknown>");

	setroot(bootdv, bootpart, RB_USERREQ);
	dumpconf();
}

void
device_register(struct device *dev, void *aux)
{
	if (bootpart == -1) /* ignore flag from controller driver? */
		return;

	/*
	 * scsi: sd,cd
	 */
	if (strcmp("cd", dev->dv_cfdata->cf_driver->cd_name) == 0 ||
	    strcmp("sd", dev->dv_cfdata->cf_driver->cd_name) == 0) {
		struct scsi_attach_args *sa = aux;
		int target, bus, lun;

		if (get_target(&target, &bus, &lun) != 0)
			return;
    
		/* make sure we are on the expected scsibus */
		if (bootbus != bus)
			return;

		if (sa->sa_sc_link->target == target &&
		    sa->sa_sc_link->lun == lun) {
			bootdv = dev;
			return;
		}
	}

	/*
	 * ethernet: ie,le
	 */
	else if (strcmp("ie", dev->dv_cfdata->cf_driver->cd_name) == 0 ||
	    strcmp("le", dev->dv_cfdata->cf_driver->cd_name) == 0) {
		struct confargs *ca = aux;

		if (ca->ca_paddr == bootaddr) {
			bootdv = dev;
			return;
		}
	}
}

/*
 * Returns the ID of the SCSI disk based on Motorola's CLUN/DLUN stuff
 * bootdev == CLUN << 8 | DLUN.
 * This handles SBC SCSI and MVME32[78].
 */
int
get_target(int *target, int *bus, int *lun)
{
	extern int bootdev;

	switch (bootdev >> 8) {
	/* built-in controller */
	case 0x00:
	/* MVME327 */
	case 0x02:
	case 0x03:
		*bus = 0;
		*target = (bootdev & 0x70) >> 4;
		*lun = (bootdev & 0x07);
		return (0);
	/* MVME328 */
	case 0x06:
	case 0x07:
	case 0x16:
	case 0x17:
	case 0x18:
	case 0x19:
		*bus = (bootdev & 0x40) >> 6;
		*target = (bootdev & 0x38) >> 3;
		*lun = (bootdev & 0x07);
		return (0);
	default:
		return (ENODEV);
	}
}

struct nam2blk nam2blk[] = {
	{ "sd",		4 },
	{ "cd",		6 },
	{ "rd",		7 },
	{ "vnd",	8 },
	{ NULL,		-1 }
};
@


1.49
log
@Create the initial page tables in the area between the end of the firmware
data area and the kernel image, whenever possible.

On 88100/88200 systems, use BATC mappings to map the kernel text (and the
kernel data for non-MULTIPROCESSOR kernels). 88110 to follow soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.48 2011/10/09 17:01:34 miod Exp $	*/
@


1.48
log
@Rework secondary processor initialization. cmmu initialization is now
performed much earlier in the processor startup.
No visible change, paves the way for the much important diff three commits
from here.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.47 2010/12/23 20:05:08 miod Exp $	*/
d102 1
a102 2
	 * Switch to our final trap vectors, and unmap whatever is below
	 * the kernel.
d105 1
a105 2
	pmap_kremove(0, (vsize_t)kernel_vbr);
	pmap_update(pmap_kernel());
@


1.47
log
@The exception vector page on m88k systems has always been the same page as
the one used by the firmware, which (at least on mvme88k) is at address zero.

This is unfortunate, since this means that NULL pointer dereferences in the
kernel are not caught, and writes cause havoc.

This behaviour was necessary to be able to use the PROM system call interface
during early bootstrap, without having to disassemble the VBR page and
update branches - which use pc-relative displacement - if we were to use
a different VBR address.

On mvme88k, change this and actually set up two VBR pages: one, over the PROM
page (except for the system call vectors), and another one in the kernel
image (which will be mapped read-only). We'll run with the PROM page until
the end of autoconf, and then switch to the kernel one, and unmap all the
PROM below it.

As a bonus, the final kernel page can use optimized data access fault
handlers, which do not have to check for faults caused by badaddr(), since
badaddr() is only used during device probe on buses which do not support
hotplug.

There are a few infrastructure collateral damage on aviion and luna88k, but
these ports do not change their behaviour yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.46 2010/11/18 21:13:19 miod Exp $	*/
d94 1
a94 4
	 * do yet. This is normally done when attaching mainbus, but
	 * on MVME188 boards, the system hangs if secondary processors
	 * try to issue BUG calls (i.e. when printing their information
	 * on console), so this has been postponed until now.
d96 1
a96 2
	if (brdtyp == BRD_188)
		cpu_hatch_secondary_processors(NULL);
@


1.46
log
@Do not #include <sys/dkstat.h> if you don't need anything from it.
ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.45 2009/10/26 20:17:27 deraadt Exp $	*/
d43 2
d47 1
d77 1
a82 5
	/*
	 * Turn external interrupts on.
	 */
	set_psr(get_psr() & ~PSR_IND);
	spl0();
d91 22
d114 6
@


1.45
log
@Do not do strncmp comparisons on dv_xname because longer device names which
look similar could arrive in the future.  Instead, compare directly against
dv_cfdata->cf_driver->cd_name
Issue originally spotted by miod
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.44 2009/03/15 20:39:53 miod Exp $	*/
a36 1
#include <sys/dkstat.h>
@


1.44
log
@Generic softinterrupt support for m88k based platforms, adapted from arm
with different locking mechanism. 88110 soft ipi are replaced with an
ipi callback which is checked upon return from exception (it can not be kept
as a softintr, as the generic softinterrupt code doesn't have per-cpu
pending softintr queues).
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.43 2009/03/05 21:55:15 miod Exp $	*/
d115 2
a116 2
	if (strncmp("cd", dev->dv_xname, 2) == 0 ||
	    strncmp("sd", dev->dv_xname, 2) == 0) {
d137 2
a138 2
	else if (strncmp("ie", dev->dv_xname, 2) == 0 ||
	    strncmp("le", dev->dv_xname, 2) == 0) {
@


1.43
log
@Change SMP secondary processor startup to have them ``hatch'' earlier,
so that they can invoke sched_init_cpu() before the scheduler starts,
which allows the horrible kluge in cpu_configure() to die.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.42 2008/07/21 04:35:54 todd Exp $	*/
d75 2
@


1.42
log
@nam2blk[] needs a "vnd" entry for some things (like softraid)
ok marco@@ no objection miod@@ need this for regress djm@@ no objection krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.41 2007/10/28 19:48:47 miod Exp $	*/
a74 20
#ifdef MULTIPROCESSOR
	/*
	 * XXX This is gross. We can not invoke sched_init_cpu after
	 * XXX init has been forked. But since we start secondary
	 * XXX processors very late in the boot process, it is not
	 * XXX possible to do this from the secondary processors
	 * XXX themselves.
	 * XXX Instead, do this now, even though this may cause
	 * XXX idle procs to be allocated for missing or unreliable
	 * XXX processors.
	 */
	cpuid_t cpu;
	for (cpu = 0; cpu < max_cpus; cpu++) {
		if (cpu == curcpu()->ci_cpuid)
			continue;

		sched_init_cpu(&m88k_cpus[cpu]);
	}
#endif

d90 1
@


1.41
log
@This is a horrible kluge: invoke sched_init_cpu for seconday processors
before they are started (and not skipping gaps for machine setups with
holes in cpu slots). Since we start secondary cpus very late in the boot
process, and sched_init_cpu() has to be invoked before proc0 execve's init,
I don't think there is a better way to do this.

This lets MVME188 systems with more than one processor boot multiuser.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.40 2007/10/13 12:55:21 miod Exp $	*/
d205 1
@


1.40
log
@Enable interrupts in secondary processors before invoking cpu_switchto(),
rather the expecting it to do this for us.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.39 2007/06/15 01:19:08 deraadt Exp $	*/
d75 20
@


1.39
log
@no need to include machine/disklabel.h when sys/disklabel.h is already
pulled in.
look at how doing it in one architecture gets that code copied to the
derivative architectures... amazing..
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.38 2007/06/01 19:25:10 deraadt Exp $	*/
a79 3
	 *
	 * XXX We have a race here. If we enable interrupts after setroot(),
	 * the kernel dies.
@


1.38
log
@some architectures called setroot() from cpu_configure(), *way* before some
subsystems were enabled.  others used a *md_diskconf -> diskconf() method to
make sure init_main could "do late setroot".  Change all architectures to
have diskconf(), use it directly & late.  tested by todd and myself on most
architectures, ok miod too
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.38 2007/06/01 19:20:46 deraadt Exp $	*/
a46 1
#include <machine/disklabel.h>
@


1.37
log
@make findblkmajor() and findblkname() MI; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.36 2007/05/04 03:44:44 deraadt Exp $	*/
a87 6
	printf("boot device: %s\n",
	    (bootdv) ? bootdv->dv_xname : "<unknown>");

	setroot(bootdv, bootpart, RB_USERREQ);
	dumpconf();

d94 2
d97 8
a104 1
	cold = 0;
@


1.36
log
@setroot() was a ugly mix of MI and MD code, with different bugs on different
machines.  Instead -- build one solid clean MI version, and thenchange all
the architectures to use it.  ok various people, tested on almost all cases.
(it is a 10094 line diff..)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.35 2006/11/28 16:56:50 dlg Exp $	*/
d182 1
a182 4
static struct {
	char	*name;
	int	maj;
} nam2blk[] = {
d186 1
a187 23

int
findblkmajor(struct device *dv)
{
	char *name = dv->dv_xname;
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); i++)
		if (!strncmp(name, nam2blk[i].name, strlen(nam2blk[i].name)))
			return (nam2blk[i].maj);
	return (-1);
}

char *
findblkname(int maj)
{
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); i++)
		if (nam2blk[i].maj == maj)
			return (nam2blk[i].name);
	return (NULL);
}
@


1.35
log
@rename scsibus_attach_args to scsi_attach_args. this can help avoid
confusing when trying to attach scsibus to a hba, since it is really meant
for attaching scsi devices to scsibus.

ok deraadt@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.34 2006/05/02 21:43:09 miod Exp $	*/
a60 2
struct	device *parsedisk(char *, int, int, dev_t *);
void	setroot(void);
a61 2
int	findblkmajor(struct device *);
struct device *getdisk(char *, int, int, dev_t *);
a75 1

d87 5
a91 1
	setroot();
a103 272
struct nam2blk {
	char *name;
	int maj;
} nam2blk[] = {
	{ "sd",	4 },
	{ "cd", 6 },
	{ "rd",	7 },
};

int
findblkmajor(dv)
	struct device *dv;
{
	char *name = dv->dv_xname;
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); ++i)
		if (strncmp(name, nam2blk[i].name, strlen(nam2blk[0].name)) == 0)
			return (nam2blk[i].maj);
	return (-1);
}

struct device *
getdisk(str, len, defpart, devp)
	char *str;
	int len, defpart;
	dev_t *devp;
{
	struct device *dv;

	if ((dv = parsedisk(str, len, defpart, devp)) == NULL) {
		printf("use one of:");
		TAILQ_FOREACH(dv, &alldevs, dv_list) {
			if (dv->dv_class == DV_DISK)
				printf(" %s[a-p]", dv->dv_xname);
#ifdef NFSCLIENT
			if (dv->dv_class == DV_IFNET)
				printf(" %s", dv->dv_xname);
#endif
		}
		printf("\n");
	}
	return (dv);
}

struct device *
parsedisk(str, len, defpart, devp)
	char *str;
	int len, defpart;
	dev_t *devp;
{
	struct device *dv;
	char *cp, c;
	int majdev, unit, part;

	if (len == 0)
		return (NULL);
	cp = str + len - 1;
	c = *cp;
	if (c >= 'a' && (c - 'a') < MAXPARTITIONS) {
		part = c - 'a';
		*cp = '\0';
	} else
		part = defpart;

	TAILQ_FOREACH(dv, &alldevs, dv_list) {
		if (dv->dv_class == DV_DISK &&
		    strcmp(str, dv->dv_xname) == 0) {
			majdev = findblkmajor(dv);
			unit = dv->dv_unit;
			if (majdev < 0)
				panic("parsedisk");
			*devp = MAKEDISKDEV(majdev, unit, part);
			break;
		}
#ifdef NFSCLIENT
		if (dv->dv_class == DV_IFNET &&
		    strcmp(str, dv->dv_xname) == 0) {
			*devp = NODEV;
			break;
		}
#endif
	}

	*cp = c;
	return (dv);
}

/*
 * Attempt to find the device from which we were booted.
 * If we can do so, and not instructed not to do so,
 * change rootdev to correspond to the load device.
 *
 * XXX Actually, swap and root must be on the same type of device,
 * (ie. DV_DISK or DV_IFNET) because of how (*mountroot) is written.
 * That should be fixed.
 */
void
setroot()
{
	struct swdevt *swp;
	struct device *dv;
	int len, majdev, unit;
	dev_t nrootdev, nswapdev = NODEV;
	char buf[128];
	dev_t temp;
#if defined(NFSCLIENT)
	extern char *nfsbootdevname;
#endif

	printf("boot device: %s\n",
	    (bootdv) ? bootdv->dv_xname : "<unknown>");

	/*
	 * If 'swap generic' and we could not determine the boot device,
	 * ask the user.
	 */
	if (mountroot == NULL && bootdv == NULL)
		boothowto |= RB_ASKNAME;

	if (boothowto & RB_ASKNAME) {
		for (;;) {
			printf("root device ");
			if (bootdv != NULL)
				printf("(default %s%c)",
				    bootdv->dv_xname,
				    bootdv->dv_class == DV_DISK ? 'a' : ' ');
			printf(": ");
			len = getsn(buf, sizeof(buf));
			if (len == 0 && bootdv != NULL) {
				strlcpy(buf, bootdv->dv_xname, sizeof buf);
				len = strlen(buf);
			}
			if (len > 0 && buf[len - 1] == '*') {
				buf[--len] = '\0';
				dv = getdisk(buf, len, 1, &nrootdev);
				if (dv) {
					bootdv = dv;
					nswapdev = nrootdev;
					goto gotswap;
				}
			}
			dv = getdisk(buf, len, 0, &nrootdev);
			if (dv) {
				bootdv = dv;
				break;
			}
		}

		/*
		 * because swap must be on same device as root, for
		 * network devices this is easy.
		 */
		if (bootdv->dv_class == DV_IFNET) {
			goto gotswap;
		}
		for (;;) {
			printf("swap device ");
			if (bootdv != NULL)
				printf("(default %s%c)",
				    bootdv->dv_xname,
				    bootdv->dv_class == DV_DISK ? 'b' : ' ');
			printf(": ");
			len = getsn(buf, sizeof(buf));
			if (len == 0 && bootdv != NULL) {
				switch (bootdv->dv_class) {
				case DV_IFNET:
					nswapdev = NODEV;
					break;
				case DV_DISK:
					nswapdev = MAKEDISKDEV(major(nrootdev),
					    DISKUNIT(nrootdev), 1);
					break;
				case DV_TAPE:
				case DV_TTY:
				case DV_DULL:
				case DV_CPU:
					break;
				}
				break;
			}
			dv = getdisk(buf, len, 1, &nswapdev);
			if (dv) {
				if (dv->dv_class == DV_IFNET)
					nswapdev = NODEV;
				break;
			}
		}
gotswap:
		rootdev = nrootdev;
		dumpdev = nswapdev;
		swdevt[0].sw_dev = nswapdev;
		swdevt[1].sw_dev = NODEV;
	} else if (mountroot == NULL) {
		/*
		 * `swap generic': Use the device the ROM told us to use.
		 */
		if (bootdv == NULL)
			panic("boot device not known");

		majdev = findblkmajor(bootdv);
		if (majdev >= 0) {
			/*
			 * Root and swap are on a disk.
			 * val[2] of the boot device is the partition number.
			 * Assume swap is on partition b.
			 */
			unit = bootdv->dv_unit;
			rootdev = MAKEDISKDEV(majdev, unit, bootpart);
			nswapdev = dumpdev = MAKEDISKDEV(major(rootdev),
			    DISKUNIT(rootdev), 1);
		} else {
			/*
			 * Root and swap are on a net.
			 */
			nswapdev = dumpdev = NODEV;
		}
		swdevt[0].sw_dev = nswapdev;
		swdevt[1].sw_dev = NODEV;
	} else {
		/*
		 * `root DEV swap DEV': honour rootdev/swdevt.
		 * rootdev/swdevt/mountroot already properly set.
		 */
		return;
	}

	switch (bootdv->dv_class) {
#if defined(NFSCLIENT)
	case DV_IFNET:
		mountroot = nfs_mountroot;
		nfsbootdevname = bootdv->dv_xname;
		return;
#endif
#if defined(FFS)
	case DV_DISK:
		mountroot = dk_mountroot;
		majdev = major(rootdev);
		unit = DISKUNIT(rootdev);
		printf("root on %s%c\n", bootdv->dv_xname,
		    DISKPART(rootdev) + 'a');
		break;
#endif
	default:
		printf("can't figure root, hope your kernel is right\n");
		return;
	}

	/*
	 * Make the swap partition on the root drive the primary swap.
	 */
	temp = NODEV;
	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		if (majdev == major(swp->sw_dev) &&
		    unit == DISKUNIT(swp->sw_dev)) {
			temp = swdevt[0].sw_dev;
			swdevt[0].sw_dev = swp->sw_dev;
			swp->sw_dev = temp;
			break;
		}
	}
	if (swp->sw_dev == NODEV)
		return;

	/*
	 * If dumpdev was the same as the old primary swap device, move
	 * it to the new primary swap device.
	 */
	if (temp == dumpdev)
		dumpdev = swdevt[0].sw_dev;
}

d180 32
@


1.34
log
@Wave goodbye to bugtty on mvme88k as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.33 2006/01/11 07:22:01 miod Exp $	*/
d388 1
a388 1
		struct scsibus_attach_args *sa = aux;
@


1.33
log
@Switch to __HAVE_DEVICE_REGISTER to find the device we're booted from.
Simpler, better.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.32 2005/12/27 18:31:10 miod Exp $	*/
a62 1
char	buginchr(void);
@


1.32
log
@Remove unused sw_nblks field of struct swdevt. Then, remove swapconf()
which duplicates work done by uvm_swap_init().
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.31 2005/04/30 16:42:37 miod Exp $	*/
d50 3
d67 1
d111 1
a111 1
	{ "st",	5 },
d376 78
@


1.31
log
@Remove m88k_psr_type and function with utterly long names to control the psr,
and use get_psr() / set_psr() or simple macros that expand into them everywhere.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.30 2004/12/25 23:02:25 miod Exp $	*/
a59 1
void	swapconf(void);
d90 1
a90 1
	swapconf();
a99 21
}

/*
 * Configure swap space and related parameters.
 */
void
swapconf()
{
	struct swdevt *swp;
	int nblks;

	for (swp = swdevt; swp->sw_dev != NODEV; swp++)
		if (bdevsw[major(swp->sw_dev)].d_psize) {
			nblks =
			    (*bdevsw[major(swp->sw_dev)].d_psize)(swp->sw_dev);
			if (nblks != -1 &&
			    (swp->sw_nblks == 0 || swp->sw_nblks > nblks))
				swp->sw_nblks = nblks;
			swp->sw_nblks = ctod(dtoc(swp->sw_nblks));
		}
	dumpconf();
@


1.30
log
@Use list and queue macros where applicable to make the code easier to read;
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.29 2004/07/20 20:33:21 miod Exp $	*/
d88 1
a88 1
	enable_interrupt();
@


1.29
log
@Let the boot device detection code handle secondary SCSI buses.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.28 2004/05/04 15:27:20 miod Exp $	*/
d156 1
a156 2
		for (dv = alldevs.tqh_first; dv != NULL;
		    dv = dv->dv_list.tqe_next) {
d189 1
a189 1
	for (dv = alldevs.tqh_first; dv != NULL; dv = dv->dv_list.tqe_next) {
@


1.28
log
@Always ask the user for the root device if we are "swap generic" and the
boot device is not known, as other arches do.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.27 2004/04/24 19:51:49 miod Exp $	*/
d69 1
a69 1
int bootpart;
@


1.27
log
@Preliminary switch to an mvme88k bus_space world. Not all drivers have been
converted yet, and they rely upon some linear mappings provided by bus_space.

In order to not impact performance, almost all the bus_space accesses go
through macros and inline functions. This currently restricts us to D16 and
D32 access modes, which are selected at compilation time. Since there are no
plans to support D8 vme devices in the future, this is acceptable for now.

This makes the "len" locator for vme devices go away, and allows to simplify
some code which was using the pcctwo device, and will now directly access
hardware which is known to exist, rather than wait until the device is
attached.

While there, try to enforce more interrupt vector number checks, since these
changes pointed out that dart(4) had been working correctly so far by sheer
luck only.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.26 2004/04/14 20:18:18 miod Exp $	*/
d237 7
@


1.26
log
@Nuke getdevunit(), nothing uses it.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.25 2004/02/11 20:41:08 miod Exp $	*/
d68 1
a68 1
void *bootaddr;
@


1.25
log
@Keep using the BUG as the console device until autoconf is over, rather
than switching early.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.24 2003/10/05 20:25:08 miod Exp $	*/
a64 1
struct device *getdevunit(char *name, int unit);
a123 5
/*
 * the rest of this file was adapted from Theo de Raadt's code in the
 * sparc port to nuke the "options GENERIC" stuff.
 */

a387 28
}

/*
 * find a device matching "name" and unit number
 */
struct device *
getdevunit(name, unit)
	char *name;
	int unit;
{
	struct device *dev = alldevs.tqh_first;
	char num[10], fullname[16];
	int lunit;

	/* compute length of name and decimal expansion of unit number */
	snprintf(num, sizeof num, "%d", unit);
	lunit = strlen(num);
	if (strlen(name) + lunit >= sizeof(fullname) - 1)
		panic("config_attach: device name too long");

	strlcpy(fullname, name, sizeof fullname);
	strlcat(fullname, num, sizeof fullname);

	while (strcmp(dev->dv_xname, fullname) != 0) {
		if ((dev = dev->dv_list.tqe_next) == NULL)
			return NULL;
	}
	return dev;
@


1.24
log
@De-register
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.23 2003/09/02 20:14:08 miod Exp $	*/
d64 2
a65 1
struct device	*getdisk(char *, int, int, dev_t *);
a78 2
	struct consdev *temp;
	extern struct consdev bootcons;
d87 1
a87 3
	 * the kernel dies. If we enable interrupts here, console on cl does
	 * not work (for boot -a). So we switch to the boot console for the
	 * time being...
a88 3
	temp = cn_tab;
	cn_tab = &bootcons;

d94 6
a99 1
	cn_tab = temp;
@


1.23
log
@There is a weird problems related to interrupts - we need to enable them too
early for the console to be reliable, so revert to the bug console for boot -a.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.22 2003/09/02 17:32:44 deraadt Exp $	*/
d111 2
a112 2
	register struct swdevt *swp;
	register int nblks;
d127 1
a127 1
 * the rest of this file was adapted from Theo de Raadt's code in the 
d145 1
a145 1
	register int i;
d159 1
a159 1
	register struct device *dv;
d183 2
a184 2
	register struct device *dv;
	register char *cp, c;
d232 3
a234 3
	register struct swdevt *swp;
	register struct device *dv;
	register int len, majdev, unit;
@


1.22
log
@just like mvme68k; miod ok
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.21 2003/04/06 18:54:19 ho Exp $	*/
d50 2
d78 3
d85 6
a90 2
	 * Turn external interrupts on. We have all the drivers in
	 * place now!
d92 3
d100 2
a101 3
	/*
	 * Done with autoconfig!
	 */
@


1.21
log
@strcat/strcpy/sprintf cleanup. krw@@, anil@@ ok. art@@ tested sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.20 2002/03/14 01:26:39 millert Exp $	*/
a59 1
int	getsb(char *, int);
d97 1
a97 1
void 
a128 1

d223 1
a223 1
	register int len, majdev, unit, part;
d236 1
a236 1
			printf("root device");
d242 1
a242 1
			len = getsb(buf, sizeof(buf));
d250 1
a250 1
				if (dv != NULL) {
d257 1
a257 1
			if (dv != NULL) {
d277 1
a277 1
			len = getsb(buf, sizeof(buf));
d296 1
a296 1
			if (dv != NULL) {
a320 1
			part = bootpart;
d322 1
a322 1
			rootdev = MAKEDISKDEV(majdev, unit, part);
d375 9
a383 7
	if (swp->sw_dev != NODEV)
		/*
		 * If dumpdev was the same as the old primary swap device,
		 * move it to the new primary swap device.
		 */
		if (temp == dumpdev)
			dumpdev = swdevt[0].sw_dev;
a411 45
}

int
getsb(cp, size)
	char *cp;
	int size;
{
	register char *lp;
	register int c;
	register int len;

	lp = cp;
	len = 0;
	for (;;) {
		c = buginchr();
		switch (c) {
		case '\n':
		case '\r':
			printf("\n");
			*lp++ = '\0';
			return (len);
		case '\b':
		case '\177':
			if (len) {
				--len;
				--lp;
				printf("\b \b");
			}
			continue;
		case '@@':
		case 'u' & 037:
			len = 0;
			lp = cp;
			printf("\n");
			continue;
		default:
			if (len + 1 >= size || c < ' ') {
				printf("\007");
				continue;
			}
			printf("%c", c);
			++len;
			*lp++ = c;
		}
	}
@


1.20
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.19 2002/01/16 20:50:17 miod Exp $	*/
d246 1
a246 1
				strcpy(buf, bootdv->dv_xname);
d400 1
a400 1
	sprintf(num, "%d", unit);
d405 2
a406 2
	strcpy(fullname, name);
	strcat(fullname, num);
@


1.19
log
@Don't include <sys/map.h> when you don't need what's in it.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.18 2001/12/24 04:07:26 miod Exp $	*/
d56 8
a63 8
struct	device *parsedisk __P((char *, int, int, dev_t *));
void	setroot __P((void));
void	swapconf __P((void));
char	buginchr __P((void));
int	getsb __P((char *, int));
void	dumpconf __P((void));
int	findblkmajor __P((struct device *));
struct device	*getdisk __P((char *, int, int, dev_t *));
@


1.18
log
@<machine/pte.h> not needed here.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.17 2001/12/10 00:58:04 miod Exp $	*/
a35 1
#include <sys/map.h>
@


1.17
log
@No need to include <sys/dmap.h> and define related variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.16 2001/11/20 23:55:39 miod Exp $	*/
a48 1
#include <machine/pte.h>
@


1.17.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.19 2002/01/16 20:50:17 miod Exp $	*/
d36 1
d49 1
@


1.17.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.17.2.1 2002/01/31 22:55:18 niklas Exp $	*/
d56 8
a63 8
struct	device *parsedisk(char *, int, int, dev_t *);
void	setroot(void);
void	swapconf(void);
char	buginchr(void);
int	getsb(char *, int);
void	dumpconf(void);
int	findblkmajor(struct device *);
struct device	*getdisk(char *, int, int, dev_t *);
@


1.17.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d246 1
a246 1
				strlcpy(buf, bootdv->dv_xname, sizeof buf);
d400 1
a400 1
	snprintf(num, sizeof num, "%d", unit);
d405 2
a406 2
	strlcpy(fullname, name, sizeof fullname);
	strlcat(fullname, num, sizeof fullname);
@


1.16
log
@Oops.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.15 2001/11/09 00:12:21 miod Exp $	*/
a38 1
#include <sys/dmap.h>
@


1.15
log
@Ouch, more variables declarations in .h files lacking ``extern'' safety
belts.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.14 2001/09/28 20:49:17 miod Exp $	*/
d72 1
a72 1
struct device *bootdev;	/* set by device drivers (if found) */
@


1.14
log
@Variable declarations in .h files without extern keywords suck.
Especially when not all of these variables are used.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.13 2001/09/19 21:32:19 miod Exp $	*/
d72 1
a79 2
	bootdv = NULL; /* set by device drivers (if found) */

@


1.13
log
@Now is a good time to commit this cosmetic maxpartition-related change...
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.12 2001/05/05 22:34:01 art Exp $	*/
d68 4
a71 1
int cold;   /* 1 if still booting */
@


1.12
log
@Rename configure() to cpu_configure().
Move it from cpu_startup() to main().
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.11 2001/04/29 19:00:02 miod Exp $	*/
d158 1
a158 1
				printf(" %s[a-h]", dv->dv_xname);
@


1.11
log
@Replace resource maps with extents, and cleanup associated variables.
Idea from art's todolist, art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.10 2001/03/16 00:03:58 miod Exp $	*/
a61 1
void	configure __P((void));
d74 1
a74 1
configure()
@


1.10
log
@Update the configuration procedure, to get in sync with other ports:
- support any number of partition (not a power of two)
- better computation of swap and dump devices
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.9 2001/03/09 05:44:41 smurph Exp $	*/
a70 4
/* XXX must be allocated statically because of early console init */
struct   map extiomap[EIOMAPSIZE/16];
extern   void *extiobase;

a77 1
/*	rminit(extiomap, (long)EIOMAPSIZE, (long)1, "extio", EIOMAPSIZE/16);*/
@


1.9
log
@kernel will compile with -Werror.  Added intr.h
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.8 2001/01/13 05:18:59 smurph Exp $	*/
d44 2
a45 1
#include <machine/vmparam.h>
d47 1
a48 1
#include <machine/autoconf.h>
d51 1
d66 3
a69 1
#include <sys/kernel.h>
d81 1
a81 1
   bootdv = NULL; /* set by device drivers (if found) */
d84 2
a85 31
   if (config_rootfound("mainbus", "mainbus") == 0)
      panic("no mainbus found");

   /*
    * Turn external interrupts on. We have all the drivers in
    * place now!
    */
   enable_interrupt();
   spl0();
   setroot();
   swapconf();
   /*
    * Done with autoconfig!
    */
   cold = 0;
}

/*ARGSUSED*/
int
simple_devprint(auxp, pnp)
	void *auxp;
	char *pnp;
{
   return (QUIET);
}

int
matchname(fp, sp)
	char *fp, *sp;
{
   int len;
d87 13
a99 6
   len = strlen(fp);
   if (strlen(sp) != len)
      return (0);
   if (bcmp(fp, sp, len) == 0)
      return (1);
   return (0);
d108 2
a109 2
   register struct swdevt *swp;
   register int nblks;
d111 10
a120 9
   for (swp = swdevt; swp->sw_dev != NODEV; swp++)
      if (bdevsw[major(swp->sw_dev)].d_psize) {
         nblks =
         (*bdevsw[major(swp->sw_dev)].d_psize)(swp->sw_dev);
         if (nblks != -1 &&
             (swp->sw_nblks == 0 || swp->sw_nblks > nblks))
            swp->sw_nblks = nblks;
      }
   dumpconf();
d129 2
a130 2
   char *name;
   int maj;
d132 3
a134 3
   { "sd",     4},
   { "st",     5},
   { "rd",     7},
d138 1
a138 1
static int
d142 2
a143 2
   char *name = dv->dv_xname;
   register int i;
d145 4
a148 4
   for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); ++i)
      if (strncmp(name, nam2blk[i].name, strlen(nam2blk[0].name)) == 0)
         return (nam2blk[i].maj);
   return (-1);
d151 1
a151 1
static struct device *
d157 1
a157 1
   register struct device *dv;
d159 6
a164 6
   if ((dv = parsedisk(str, len, defpart, devp)) == NULL) {
      printf("use one of:");
      for (dv = alldevs.tqh_first; dv != NULL;
          dv = dv->dv_list.tqe_next) {
         if (dv->dv_class == DV_DISK)
            printf(" %s[a-h]", dv->dv_xname);
d166 2
a167 2
         if (dv->dv_class == DV_IFNET)
            printf(" %s", dv->dv_xname);
d169 4
a172 4
      }
      printf("\n");
   }
   return (dv);
d181 24
a204 24
   register struct device *dv;
   register char *cp, c;
   int majdev, mindev, part;

   if (len == 0)
      return (NULL);
   cp = str + len - 1;
   c = *cp;
   if (c >= 'a' && c <= 'h') {
      part = c - 'a';
      *cp = '\0';
   } else
      part = defpart;

   for (dv = alldevs.tqh_first; dv != NULL; dv = dv->dv_list.tqe_next) {
      if (dv->dv_class == DV_DISK &&
          strcmp(str, dv->dv_xname) == 0) {
         majdev = findblkmajor(dv);
         if (majdev < 0)
            panic("parsedisk");
         mindev = (dv->dv_unit << PARTITIONSHIFT) + part;
         *devp = makedev(majdev, mindev);
         break;
      }
d206 5
a210 5
      if (dv->dv_class == DV_IFNET &&
          strcmp(str, dv->dv_xname) == 0) {
         *devp = NODEV;
         break;
      }
d212 1
a212 1
   }
d214 2
a215 2
   *cp = c;
   return (dv);
d230 6
a235 6
   register struct swdevt *swp;
   register struct device *dv;
   register int len, majdev, mindev;
   dev_t nrootdev, nswapdev = NODEV;
   char buf[128];
   dev_t temp;
d237 1
a237 1
   extern char *nfsbootdevname;
d240 2
a241 2
   printf("boot device: %s\n",
          (bootdv) ? bootdv->dv_xname : "<unknown>");
d243 107
a349 112
   if (boothowto & RB_ASKNAME) {
      for (;;) {
         printf("root device");
         if (bootdv != NULL)
            printf("(default %s%c)",
                   bootdv->dv_xname,
                   bootdv->dv_class == DV_DISK
                   ? 'a' : ' ');
         printf(": ");
         len = getsb(buf, sizeof(buf));
         if (len == 0 && bootdv != NULL) {
            strcpy(buf, bootdv->dv_xname);
            len = strlen(buf);
         }
         if (len > 0 && buf[len - 1] == '*') {
            buf[--len] = '\0';
            dv = getdisk(buf, len, 1, &nrootdev);
            if (dv != NULL) {
               bootdv = dv;
               nswapdev = nrootdev;
               goto gotswap;
            }
         }
         dv = getdisk(buf, len, 0, &nrootdev);
         if (dv != NULL) {
            bootdv = dv;
            break;
         }
      }

      /*
       * because swap must be on same device as root, for
       * network devices this is easy.
       */
      if (bootdv->dv_class == DV_IFNET) {
         goto gotswap;
      }
      for (;;) {
         printf("swap device ");
         if (bootdv != NULL)
            printf("(default %s%c)",
                   bootdv->dv_xname,
                   bootdv->dv_class == DV_DISK?'b':' ');
         printf(": ");
         len = getsb(buf, sizeof(buf));
         if (len == 0 && bootdv != NULL) {
            switch (bootdv->dv_class) {
               case DV_IFNET:
                  nswapdev = NODEV;
                  break;
               case DV_DISK:
                  nswapdev = makedev(major(nrootdev),
                                     (minor(nrootdev) & ~ PARTITIONMASK) | 1);
                  break;
               case DV_TAPE:
               case DV_TTY:
               case DV_DULL:
               case DV_CPU:
                  break;
            }
            break;
         }
         dv = getdisk(buf, len, 1, &nswapdev);
         if (dv) {
            if (dv->dv_class == DV_IFNET)
               nswapdev = NODEV;
            break;
         }
      }
      gotswap:
      rootdev = nrootdev;
      dumpdev = nswapdev;
      swdevt[0].sw_dev = nswapdev;
      swdevt[1].sw_dev = NODEV;

   } else if (mountroot == NULL) {

      /*
       * `swap generic': Use the device the ROM told us to use.
       */
      if (bootdv == NULL)
         panic("boot device not known");

      majdev = findblkmajor(bootdv);
      if (majdev >= 0) {
         /*
          * Root and swap are on a disk.
          * val[2] of the boot device is the partition number.
          * Assume swap is on partition b.
          */
         int part = bootpart;
         mindev = (bootdv->dv_unit << PARTITIONSHIFT) + part;
         rootdev = makedev(majdev, mindev);
         nswapdev = dumpdev = makedev(major(rootdev),
                                      (minor(rootdev) & ~ PARTITIONMASK) | 1);
      } else {
         /*
          * Root and swap are on a net.
          */
         nswapdev = dumpdev = NODEV;
      }
      swdevt[0].sw_dev = nswapdev;
      swdevt[1].sw_dev = NODEV;

   } else {

      /*
       * `root DEV swap DEV': honour rootdev/swdevt.
       * rootdev/swdevt/mountroot already properly set.
       */
      return;
   }
d351 1
a351 1
   switch (bootdv->dv_class) {
d353 4
a356 4
      case DV_IFNET:
         mountroot = nfs_mountroot;
         nfsbootdevname = bootdv->dv_xname;
         return;
d359 7
a365 7
      case DV_DISK:
         mountroot = dk_mountroot;
         majdev = major(rootdev);
         mindev = minor(rootdev);
         printf("root on %s%c\n", bootdv->dv_xname,
                (mindev & PARTITIONMASK) + 'a');
         break;
d367 25
a391 28
      default:
         printf("can't figure root, hope your kernel is right\n");
         return;
   }

   /*
    * XXX: What is this doing?
    */
   mindev &= ~PARTITIONMASK;
   temp = NODEV;
   for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
      if (majdev == major(swp->sw_dev) &&
          mindev == (minor(swp->sw_dev) & ~PARTITIONMASK)) {
         temp = swdevt[0].sw_dev;
         swdevt[0].sw_dev = swp->sw_dev;
         swp->sw_dev = temp;
         break;
      }
   }
   if (swp->sw_dev == NODEV)
      return;

   /*
    * If dumpdev was the same as the old primary swap device, move
    * it to the new primary swap device.
    */
   if (temp == dumpdev)
      dumpdev = swdevt[0].sw_dev;
d402 18
a419 18
   struct device *dev = alldevs.tqh_first;
   char num[10], fullname[16];
   int lunit;

   /* compute length of name and decimal expansion of unit number */
   sprintf(num, "%d", unit);
   lunit = strlen(num);
   if (strlen(name) + lunit >= sizeof(fullname) - 1)
      panic("config_attach: device name too long");

   strcpy(fullname, name);
   strcat(fullname, num);

   while (strcmp(dev->dv_xname, fullname) != 0) {
      if ((dev = dev->dv_list.tqe_next) == NULL)
         return NULL;
   }
   return dev;
d427 38
a464 42
   register char *lp;
   register int len;
   register int c;

   lp = cp;
   len = 0;
   for (;;) {
      c = buginchr();

      switch (c) {
         case '\n':
         case '\r':
            printf("\n");
            *lp++ = '\0';
            return (len);
         case '\b':
         case '\177':
            if (len) {
               printf("\b \b");
               --lp;
               --len;
            }
            break;
         case 'u' & 037:
            while (len) {
               printf("\b \b");
               --lp;
               --len;
            }
            break;
         case '\t':
            c = ' ';
         default:
            if (len + 1 >= size || c < ' ') {
               printf("\007");
               break;
            }
            printf("%c", c);
            ++len;
            *lp++ = c;
      }
   }
@


1.8
log
@Booting kernel with MACHINE_NEW_NONCONTIG.  UVM code added but not working.
New stand config.  Lots of header fixes.  Can now cross-compile i386->m88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.7 2000/03/03 00:54:53 todd Exp $	*/
d57 7
a63 7
struct   device *parsedisk __P((char *, int, int, dev_t *));
void  setroot __P((void));
void  swapconf __P((void));
void  configure __P((void));
char    buginchr __P((void));
int   getsb __P((char *, int));

d100 2
a101 2
void *auxp;
char *pnp;
d108 1
a108 1
char *fp, *sp;
d157 1
a157 1
struct device *dv;
d170 3
a172 3
char *str;
int len, defpart;
dev_t *devp;
d194 3
a196 3
char *str;
int len, defpart;
dev_t *devp;
d424 2
a425 2
char *name;
int unit;
d449 2
a450 2
char *cp;
int size;
@


1.7
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.6 1999/09/27 19:13:20 smurph Exp $	*/
a494 17

/*
 * Slave CPU pre-main routine.
 * Determine CPU number and set it.
 *
 * Running on an interrupt stack here; do nothing fancy.
 *
 * Called from "mvme88k/locore.S"
 */
void slave_pre_main(void)
{
   set_cpu_number(cmmu_cpu_number()); /* Determine cpu number by CMMU */
   splhigh();
   enable_interrupt();
}


@


1.6
log
@Added to support MVME188 and MVME197
@
text
@d1 1
a32 1
 *	$Id: autoconf.c,v 1.4 1998/12/15 05:11:01 smurph Exp $
@


1.6.4.1
log
@Sync with -current
@
text
@a0 1
/*	$OpenBSD$	*/
d32 1
@


1.6.4.2
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.10 2001/03/16 00:03:58 miod Exp $	*/
d44 1
a44 2
#include <sys/kernel.h>

d46 1
a47 1
#include <machine/cpu.h>
a49 1
#include <machine/vmparam.h>
d57 6
a62 9
struct	device *parsedisk __P((char *, int, int, dev_t *));
void	setroot __P((void));
void	swapconf __P((void));
void	configure __P((void));
char	buginchr __P((void));
int	getsb __P((char *, int));
void	dumpconf __P((void));
int	findblkmajor __P((struct device *));
struct device	*getdisk __P((char *, int, int, dev_t *));
d65 1
d77 1
a77 1
	bootdv = NULL; /* set by device drivers (if found) */
d80 31
a110 2
	if (config_rootfound("mainbus", "mainbus") == 0)
		panic("no mainbus found");
d112 6
a117 13
	/*
	 * Turn external interrupts on. We have all the drivers in
	 * place now!
	 */
	enable_interrupt();
	spl0();
	setroot();
	swapconf();

	/*
	 * Done with autoconfig!
	 */
	cold = 0;
d126 2
a127 2
	register struct swdevt *swp;
	register int nblks;
d129 9
a137 10
	for (swp = swdevt; swp->sw_dev != NODEV; swp++)
		if (bdevsw[major(swp->sw_dev)].d_psize) {
			nblks =
			    (*bdevsw[major(swp->sw_dev)].d_psize)(swp->sw_dev);
			if (nblks != -1 &&
			    (swp->sw_nblks == 0 || swp->sw_nblks > nblks))
				swp->sw_nblks = nblks;
			swp->sw_nblks = ctod(dtoc(swp->sw_nblks));
		}
	dumpconf();
d146 2
a147 2
	char *name;
	int maj;
d149 3
a151 3
	{ "sd",	4 },
	{ "st",	5 },
	{ "rd",	7 },
d155 1
a155 1
int
d157 1
a157 1
	struct device *dv;
d159 2
a160 2
	char *name = dv->dv_xname;
	register int i;
d162 4
a165 4
	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); ++i)
		if (strncmp(name, nam2blk[i].name, strlen(nam2blk[0].name)) == 0)
			return (nam2blk[i].maj);
	return (-1);
d168 1
a168 1
struct device *
d170 12
a181 12
	char *str;
	int len, defpart;
	dev_t *devp;
{
	register struct device *dv;

	if ((dv = parsedisk(str, len, defpart, devp)) == NULL) {
		printf("use one of:");
		for (dv = alldevs.tqh_first; dv != NULL;
		    dv = dv->dv_list.tqe_next) {
			if (dv->dv_class == DV_DISK)
				printf(" %s[a-h]", dv->dv_xname);
d183 2
a184 2
			if (dv->dv_class == DV_IFNET)
				printf(" %s", dv->dv_xname);
d186 4
a189 4
		}
		printf("\n");
	}
	return (dv);
d194 28
a221 28
	char *str;
	int len, defpart;
	dev_t *devp;
{
	register struct device *dv;
	register char *cp, c;
	int majdev, unit, part;

	if (len == 0)
		return (NULL);
	cp = str + len - 1;
	c = *cp;
	if (c >= 'a' && (c - 'a') < MAXPARTITIONS) {
		part = c - 'a';
		*cp = '\0';
	} else
		part = defpart;

	for (dv = alldevs.tqh_first; dv != NULL; dv = dv->dv_list.tqe_next) {
		if (dv->dv_class == DV_DISK &&
		    strcmp(str, dv->dv_xname) == 0) {
			majdev = findblkmajor(dv);
			unit = dv->dv_unit;
			if (majdev < 0)
				panic("parsedisk");
			*devp = MAKEDISKDEV(majdev, unit, part);
			break;
		}
d223 5
a227 5
		if (dv->dv_class == DV_IFNET &&
		    strcmp(str, dv->dv_xname) == 0) {
			*devp = NODEV;
			break;
		}
d229 1
a229 1
	}
d231 2
a232 2
	*cp = c;
	return (dv);
d247 6
a252 6
	register struct swdevt *swp;
	register struct device *dv;
	register int len, majdev, unit, part;
	dev_t nrootdev, nswapdev = NODEV;
	char buf[128];
	dev_t temp;
d254 1
a254 1
	extern char *nfsbootdevname;
d257 2
a258 2
	printf("boot device: %s\n",
	    (bootdv) ? bootdv->dv_xname : "<unknown>");
d260 112
a371 107
	if (boothowto & RB_ASKNAME) {
		for (;;) {
			printf("root device");
			if (bootdv != NULL)
				printf("(default %s%c)",
				    bootdv->dv_xname,
				    bootdv->dv_class == DV_DISK ? 'a' : ' ');
			printf(": ");
			len = getsb(buf, sizeof(buf));
			if (len == 0 && bootdv != NULL) {
				strcpy(buf, bootdv->dv_xname);
				len = strlen(buf);
			}
			if (len > 0 && buf[len - 1] == '*') {
				buf[--len] = '\0';
				dv = getdisk(buf, len, 1, &nrootdev);
				if (dv != NULL) {
					bootdv = dv;
					nswapdev = nrootdev;
					goto gotswap;
				}
			}
			dv = getdisk(buf, len, 0, &nrootdev);
			if (dv != NULL) {
				bootdv = dv;
				break;
			}
		}

		/*
		 * because swap must be on same device as root, for
		 * network devices this is easy.
		 */
		if (bootdv->dv_class == DV_IFNET) {
			goto gotswap;
		}
		for (;;) {
			printf("swap device ");
			if (bootdv != NULL)
				printf("(default %s%c)",
				    bootdv->dv_xname,
				    bootdv->dv_class == DV_DISK ? 'b' : ' ');
			printf(": ");
			len = getsb(buf, sizeof(buf));
			if (len == 0 && bootdv != NULL) {
				switch (bootdv->dv_class) {
				case DV_IFNET:
					nswapdev = NODEV;
					break;
				case DV_DISK:
					nswapdev = MAKEDISKDEV(major(nrootdev),
					    DISKUNIT(nrootdev), 1);
					break;
				case DV_TAPE:
				case DV_TTY:
				case DV_DULL:
				case DV_CPU:
					break;
				}
				break;
			}
			dv = getdisk(buf, len, 1, &nswapdev);
			if (dv != NULL) {
				if (dv->dv_class == DV_IFNET)
					nswapdev = NODEV;
				break;
			}
		}
gotswap:
		rootdev = nrootdev;
		dumpdev = nswapdev;
		swdevt[0].sw_dev = nswapdev;
		swdevt[1].sw_dev = NODEV;
	} else if (mountroot == NULL) {
		/*
		 * `swap generic': Use the device the ROM told us to use.
		 */
		if (bootdv == NULL)
			panic("boot device not known");

		majdev = findblkmajor(bootdv);
		if (majdev >= 0) {
			/*
			 * Root and swap are on a disk.
			 * val[2] of the boot device is the partition number.
			 * Assume swap is on partition b.
			 */
			part = bootpart;
			unit = bootdv->dv_unit;
			rootdev = MAKEDISKDEV(majdev, unit, part);
			nswapdev = dumpdev = MAKEDISKDEV(major(rootdev),
			    DISKUNIT(rootdev), 1);
		} else {
			/*
			 * Root and swap are on a net.
			 */
			nswapdev = dumpdev = NODEV;
		}
		swdevt[0].sw_dev = nswapdev;
		swdevt[1].sw_dev = NODEV;
	} else {
		/*
		 * `root DEV swap DEV': honour rootdev/swdevt.
		 * rootdev/swdevt/mountroot already properly set.
		 */
		return;
	}
d373 1
a373 1
	switch (bootdv->dv_class) {
d375 4
a378 4
	case DV_IFNET:
		mountroot = nfs_mountroot;
		nfsbootdevname = bootdv->dv_xname;
		return;
d381 7
a387 7
	case DV_DISK:
		mountroot = dk_mountroot;
		majdev = major(rootdev);
		unit = DISKUNIT(rootdev);
		printf("root on %s%c\n", bootdv->dv_xname,
		    DISKPART(rootdev) + 'a');
		break;
d389 28
a416 25
	default:
		printf("can't figure root, hope your kernel is right\n");
		return;
	}

	/*
	 * Make the swap partition on the root drive the primary swap.
	 */
	temp = NODEV;
	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		if (majdev == major(swp->sw_dev) &&
		    unit == DISKUNIT(swp->sw_dev)) {
			temp = swdevt[0].sw_dev;
			swdevt[0].sw_dev = swp->sw_dev;
			swp->sw_dev = temp;
			break;
		}
	}
	if (swp->sw_dev != NODEV)
		/*
		 * If dumpdev was the same as the old primary swap device,
		 * move it to the new primary swap device.
		 */
		if (temp == dumpdev)
			dumpdev = swdevt[0].sw_dev;
d424 2
a425 2
	char *name;
	int unit;
d427 18
a444 18
	struct device *dev = alldevs.tqh_first;
	char num[10], fullname[16];
	int lunit;

	/* compute length of name and decimal expansion of unit number */
	sprintf(num, "%d", unit);
	lunit = strlen(num);
	if (strlen(name) + lunit >= sizeof(fullname) - 1)
		panic("config_attach: device name too long");

	strcpy(fullname, name);
	strcat(fullname, num);

	while (strcmp(dev->dv_xname, fullname) != 0) {
		if ((dev = dev->dv_list.tqe_next) == NULL)
			return NULL;
	}
	return dev;
d449 2
a450 2
	char *cp;
	int size;
d452 42
a493 38
	register char *lp;
	register int c;
	register int len;

	lp = cp;
	len = 0;
	for (;;) {
		c = buginchr();
		switch (c) {
		case '\n':
		case '\r':
			printf("\n");
			*lp++ = '\0';
			return (len);
		case '\b':
		case '\177':
			if (len) {
				--len;
				--lp;
				printf("\b \b");
			}
			continue;
		case '@@':
		case 'u' & 037:
			len = 0;
			lp = cp;
			printf("\n");
			continue;
		default:
			if (len + 1 >= size || c < ' ') {
				printf("\007");
				continue;
			}
			printf("%c", c);
			++len;
			*lp++ = c;
		}
	}
d495 17
@


1.6.4.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.6.4.2 2001/04/18 16:11:29 niklas Exp $	*/
d62 1
d71 4
d79 1
a79 1
cpu_configure()
d82 1
@


1.6.4.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.6.4.3 2001/07/04 10:20:06 niklas Exp $	*/
d68 1
a68 4
int cold = 1;   /* 1 if still booting */

void *bootaddr;
int bootpart;
d158 1
a158 1
				printf(" %s[a-p]", dv->dv_xname);
@


1.6.4.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a71 1
struct device *bootdev;	/* set by device drivers (if found) */
d79 2
@


1.6.4.6
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.6.4.5 2001/11/13 21:04:15 niklas Exp $	*/
d72 1
a72 1
struct device *bootdv;	/* set by device drivers (if found) */
@


1.6.4.7
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d36 1
d39 1
d50 1
@


1.6.4.8
log
@Merge in -current from about a week ago
@
text
@d56 8
a63 8
struct	device *parsedisk(char *, int, int, dev_t *);
void	setroot(void);
void	swapconf(void);
char	buginchr(void);
int	getsb(char *, int);
void	dumpconf(void);
int	findblkmajor(struct device *);
struct device	*getdisk(char *, int, int, dev_t *);
@


1.6.4.9
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.6.4.8 2002/03/28 10:36:02 niklas Exp $	*/
d246 1
a246 1
				strlcpy(buf, bootdv->dv_xname, sizeof buf);
d400 1
a400 1
	snprintf(num, sizeof num, "%d", unit);
d405 2
a406 2
	strlcpy(fullname, name, sizeof fullname);
	strlcat(fullname, num, sizeof fullname);
@


1.6.4.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a49 2
#include <dev/cons.h>

d60 1
a76 3
	struct consdev *temp;
	extern struct consdev bootcons;

d81 2
a82 6
	 * Turn external interrupts on.
	 *
	 * XXX We have a race here. If we enable interrupts after setroot(),
	 * the kernel dies. If we enable interrupts here, console on cl does
	 * not work (for boot -a). So we switch to the boot console for the
	 * time being...
a83 3
	temp = cn_tab;
	cn_tab = &bootcons;

d89 3
a91 2
	cn_tab = temp;

d98 1
a98 1
void
d101 2
a102 2
	struct swdevt *swp;
	int nblks;
d117 1
a117 1
 * the rest of this file was adapted from Theo de Raadt's code in the
d130 1
d136 1
a136 1
	int i;
d150 1
a150 1
	struct device *dv;
d174 2
a175 2
	struct device *dv;
	char *cp, c;
d223 3
a225 3
	struct swdevt *swp;
	struct device *dv;
	int len, majdev, unit;
d238 1
a238 1
			printf("root device ");
d244 1
a244 1
			len = getsn(buf, sizeof(buf));
d252 1
a252 1
				if (dv) {
d259 1
a259 1
			if (dv) {
d279 1
a279 1
			len = getsn(buf, sizeof(buf));
d298 1
a298 1
			if (dv) {
d323 1
d325 1
a325 1
			rootdev = MAKEDISKDEV(majdev, unit, bootpart);
d378 7
a384 9
	if (swp->sw_dev == NODEV)
		return;

	/*
	 * If dumpdev was the same as the old primary swap device, move
	 * it to the new primary swap device.
	 */
	if (temp == dumpdev)
		dumpdev = swdevt[0].sw_dev;
d413 45
@


1.6.4.11
log
@Merge with the trunk
@
text
@d64 1
a64 1
struct device *getdisk(char *, int, int, dev_t *);
d68 1
a68 1
paddr_t bootaddr;
d78 2
d88 3
a90 1
	 * the kernel dies.
d92 3
d100 1
a100 6
	/*
	 * Finally switch to the real console driver,
	 * and say goodbye to the BUG!
	 */
	cn_tab = NULL;
	cninit();
d126 5
a244 7
	/*
	 * If 'swap generic' and we could not determine the boot device,
	 * ask the user.
	 */
	if (mountroot == NULL && bootdv == NULL)
		boothowto |= RB_ASKNAME;

d395 28
@


1.5
log
@Added vme bus device drivers. MVME328, MVME376, MVME332
@
text
@d45 1
d57 4
a60 4
struct	device *parsedisk __P((char *, int, int, dev_t *));
void	setroot __P((void));
void 	swapconf __P((void));
void	configure __P((void));
d62 1
a62 1
int	getsb __P((char *, int));
d64 1
a64 1
int cold;	/* 1 if still booting */
d68 2
a69 2
struct	map extiomap[EIOMAPSIZE/16];
extern	void *extiobase;
d77 18
a94 18
	bootdv = NULL; /* set by device drivers (if found) */
	/*rminit(extiomap, (long)EIOMAPSIZE, (long)1, "extio", EIOMAPSIZE/16);*/
	
	if (config_rootfound("mainbus", "mainbus") == 0)
		panic("no mainbus found");

	/*
	 * Turn external interrupts on. We have all the drivers in
	 * place now!
	 */
	enable_interrupt();
	spl0();
	setroot();
	swapconf();
	/*
	 * Done with autoconfig!
  	 */
	cold = 0;
d100 2
a101 2
	void *auxp;
	char *pnp;
d103 1
a103 1
	return(QUIET);
d108 1
a108 1
	char *fp, *sp;
d110 1
a110 1
	int len;
d112 6
a117 6
	len = strlen(fp);
	if (strlen(sp) != len)
		return(0);
	if (bcmp(fp, sp, len) == 0)
		return(1);
	return(0);
d126 12
a137 12
	register struct swdevt *swp;
	register int nblks;
	for (swp = swdevt; swp->sw_dev != NODEV; swp++){
		if (bdevsw[major(swp->sw_dev)].d_psize) {
			nblks =
			  (*bdevsw[major(swp->sw_dev)].d_psize)(swp->sw_dev);
			if (nblks != -1 &&
			    (swp->sw_nblks == 0 || swp->sw_nblks > nblks))
				swp->sw_nblks = nblks;
		}
	}
	dumpconf();
d146 2
a147 2
	char *name;
	int maj;
d149 3
a151 3
	{ "sd",		4 },
	{ "st",		5 },
	{ "rd",		7 },
d157 1
a157 1
	struct device *dv;
d159 2
a160 2
	char *name = dv->dv_xname;
	register int i;
d162 4
a165 4
	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); ++i)
		if (strncmp(name, nam2blk[i].name, strlen(nam2blk[0].name)) == 0)
			return (nam2blk[i].maj);
	return (-1);
d170 12
a181 12
	char *str;
	int len, defpart;
	dev_t *devp;
{
	register struct device *dv;

	if ((dv = parsedisk(str, len, defpart, devp)) == NULL) {
		printf("use one of:");
		for (dv = alldevs.tqh_first; dv != NULL;
		    dv = dv->dv_list.tqe_next) {
			if (dv->dv_class == DV_DISK)
				printf(" %s[a-h]", dv->dv_xname);
d183 2
a184 2
			if (dv->dv_class == DV_IFNET)
				printf(" %s", dv->dv_xname);
d186 4
a189 4
		}
		printf("\n");
	}
	return (dv);
d194 28
a221 28
	char *str;
	int len, defpart;
	dev_t *devp;
{
	register struct device *dv;
	register char *cp, c;
	int majdev, mindev, part;

	if (len == 0)
		return (NULL);
	cp = str + len - 1;
	c = *cp;
	if (c >= 'a' && c <= 'h') {
		part = c - 'a';
		*cp = '\0';
	} else
		part = defpart;

	for (dv = alldevs.tqh_first; dv != NULL; dv = dv->dv_list.tqe_next) {
		if (dv->dv_class == DV_DISK &&
		    strcmp(str, dv->dv_xname) == 0) {
			majdev = findblkmajor(dv);
			if (majdev < 0)
				panic("parsedisk");
			mindev = (dv->dv_unit << PARTITIONSHIFT) + part;
			*devp = makedev(majdev, mindev);
			break;
		}
d223 5
a227 5
		if (dv->dv_class == DV_IFNET &&
		    strcmp(str, dv->dv_xname) == 0) {
			*devp = NODEV;
			break;
		}
d229 1
a229 1
	}
d231 2
a232 2
	*cp = c;
	return (dv);
d247 6
a252 6
	register struct swdevt *swp;
	register struct device *dv;
	register int len, majdev, mindev;
	dev_t nrootdev, nswapdev = NODEV;
	char buf[128];
	dev_t temp;
d254 1
a254 1
	extern char *nfsbootdevname;
d257 2
a258 2
	printf("boot device: %s\n",
		(bootdv) ? bootdv->dv_xname : "<unknown>");
d260 112
a371 112
	if (boothowto & RB_ASKNAME) {
		for (;;) {
			printf("root device");
			if (bootdv != NULL)
				printf("(default %s%c)",
					bootdv->dv_xname,
					bootdv->dv_class == DV_DISK
						? 'a' : ' ');
			printf(": ");
			len = getsb(buf, sizeof(buf));
			if (len == 0 && bootdv != NULL) {
				strcpy(buf, bootdv->dv_xname);
				len = strlen(buf);
			}
			if (len > 0 && buf[len - 1] == '*') {
				buf[--len] = '\0';
				dv = getdisk(buf, len, 1, &nrootdev);
				if (dv != NULL) {
					bootdv = dv;
					nswapdev = nrootdev;
					goto gotswap;
				}
			}
			dv = getdisk(buf, len, 0, &nrootdev);
			if (dv != NULL) {
				bootdv = dv;
				break;
			}
		}

		/*
		 * because swap must be on same device as root, for
		 * network devices this is easy.
		 */
		if (bootdv->dv_class == DV_IFNET) {
			goto gotswap;
		}
		for (;;) {
			printf("swap device ");
			if (bootdv != NULL)
				printf("(default %s%c)",
					bootdv->dv_xname,
					bootdv->dv_class == DV_DISK?'b':' ');
			printf(": ");
			len = getsb(buf, sizeof(buf));
			if (len == 0 && bootdv != NULL) {
				switch (bootdv->dv_class) {
				case DV_IFNET:
					nswapdev = NODEV;
					break;
				case DV_DISK:
					nswapdev = makedev(major(nrootdev),
					    (minor(nrootdev) & ~ PARTITIONMASK) | 1);
					break;
				case DV_TAPE:
				case DV_TTY:
				case DV_DULL:
				case DV_CPU:
					break;
				}
				break;
			}
			dv = getdisk(buf, len, 1, &nswapdev);
			if (dv) {
				if (dv->dv_class == DV_IFNET)
					nswapdev = NODEV;
				break;
			}
		}
gotswap:
		rootdev = nrootdev;
		dumpdev = nswapdev;
		swdevt[0].sw_dev = nswapdev;
		swdevt[1].sw_dev = NODEV;

	} else if (mountroot == NULL) {

		/*
		 * `swap generic': Use the device the ROM told us to use.
		 */
		if (bootdv == NULL)
			panic("boot device not known");

		majdev = findblkmajor(bootdv);
		if (majdev >= 0) {
			/*
			 * Root and swap are on a disk.
			 * val[2] of the boot device is the partition number.
			 * Assume swap is on partition b.
			 */
			int part = bootpart;
			mindev = (bootdv->dv_unit << PARTITIONSHIFT) + part;
			rootdev = makedev(majdev, mindev);
			nswapdev = dumpdev = makedev(major(rootdev),
			    (minor(rootdev) & ~ PARTITIONMASK) | 1);
		} else {
			/*
			 * Root and swap are on a net.
			 */
			nswapdev = dumpdev = NODEV;
		}
		swdevt[0].sw_dev = nswapdev;
		swdevt[1].sw_dev = NODEV;

	} else {

		/*
		 * `root DEV swap DEV': honour rootdev/swdevt.
		 * rootdev/swdevt/mountroot already properly set.
		 */
		return;
	}
d373 1
a373 1
	switch (bootdv->dv_class) {
d375 4
a378 4
	case DV_IFNET:
		mountroot = nfs_mountroot;
		nfsbootdevname = bootdv->dv_xname;
		return;
d381 7
a387 7
	case DV_DISK:
		mountroot = dk_mountroot;
		majdev = major(rootdev);
		mindev = minor(rootdev);
		printf("root on %s%c\n", bootdv->dv_xname,
		    (mindev & PARTITIONMASK) + 'a');
		break;
d389 28
a416 28
	default:
		printf("can't figure root, hope your kernel is right\n");
		return;
	}

	/*
	 * XXX: What is this doing?
	 */
	mindev &= ~PARTITIONMASK;
	temp = NODEV;
	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		if (majdev == major(swp->sw_dev) &&
		    mindev == (minor(swp->sw_dev) & ~PARTITIONMASK)) {
			temp = swdevt[0].sw_dev;
			swdevt[0].sw_dev = swp->sw_dev;
			swp->sw_dev = temp;
			break;
		}
	}
	if (swp->sw_dev == NODEV)
		return;

	/*
	 * If dumpdev was the same as the old primary swap device, move
	 * it to the new primary swap device.
	 */
	if (temp == dumpdev)
		dumpdev = swdevt[0].sw_dev;
d424 2
a425 2
	char *name;
	int unit;
d427 18
a444 18
	struct device *dev = alldevs.tqh_first;
	char num[10], fullname[16];
	int lunit;

	/* compute length of name and decimal expansion of unit number */
	sprintf(num, "%d", unit);
	lunit = strlen(num);
	if (strlen(name) + lunit >= sizeof(fullname) - 1)
		panic("config_attach: device name too long");

	strcpy(fullname, name);
	strcat(fullname, num);

	while (strcmp(dev->dv_xname, fullname) != 0) {
		if ((dev = dev->dv_list.tqe_next) == NULL)
			return NULL;
	}
	return dev;
d449 2
a450 2
	char *cp;
	int size;
d452 42
a493 42
	register char *lp;
	register int len;
	register int c;

	lp = cp;
	len = 0;
	for (;;) {
		c = buginchr();

		switch (c) {
		case '\n':
		case '\r':
			printf("\n");
			*lp++ = '\0';
			return (len);
		case '\b':
		case '\177':
			if (len) {
				printf("\b \b");
				--lp;
				--len;
			}
			break;
		case 'u' & 037:
			while (len) {
				printf("\b \b");
				--lp;
				--len;
			}
			break;
		case '\t':
			c = ' ';
		default:
			if (len + 1 >= size || c < ' ') {
				printf("\007");
				break;
			}
			printf("%c", c);
			++len;
			*lp++ = c;
		}
	}
d495 17
@


1.4
log
@Commit for the first working mvme88k port.
@
text
@d32 1
a32 1
 *	$Id: autoconf.c,v 1.3 1997/03/03 20:21:28 rahnds Exp $
d77 1
a77 1
/*	rminit(extiomap, (long)EIOMAPSIZE, (long)1, "extio", EIOMAPSIZE/16);*/
d127 1
a127 2

	for (swp = swdevt; swp->sw_dev != NODEV; swp++)
d135 1
@


1.3
log
@Cleanup after import. This also seems to bring up the current version.
@
text
@d2 1
d32 1
a32 1
 *	$Id: autoconf.c,v 1.1.1.1 1997/03/03 19:32:09 rahnds Exp $
d36 4
d44 1
d46 3
d50 12
a61 3
void configure __P((void));
void setroot __P((void));
void swapconf __P((void));
d66 4
d76 3
a87 10
	
#if 0
#ifdef GENERIC
	if ((boothowto & RB_ASKNAME) == 0)
		setroot();
	setconf();
#else
	setroot();
#endif
#endif /* 0 */
a89 1

d119 4
a122 1
void
d125 27
a151 3
	struct swdevt *swp;
	u_int maj;
	int nb;
a152 2
	for (swp = swdevt; swp->sw_dev > 0; swp++) {
		maj = major(swp->sw_dev);
d154 12
a165 2
		if (maj > nblkdev)
			break;
d167 7
a173 16
		if (bdevsw[maj].d_psize) {
			nb = bdevsw[maj].d_psize(swp->sw_dev);
			if (nb > 0 && 
			    (swp->sw_nblks == 0 || swp->sw_nblks > nb))
				swp->sw_nblks = nb;
			else
				swp->sw_nblks = 0;
		}
		swp->sw_nblks = ctod(dtoc(swp->sw_nblks));
	}
	if (dumplo == 0 && dumpdev != NODEV && bdevsw[major(dumpdev)].d_psize)
	/*dumplo = (*bdevsw[major(dumpdev)].d_psize)(dumpdev) - physmem;*/
		dumplo = (*bdevsw[major(dumpdev)].d_psize)(dumpdev) -
			ctob(physmem)/DEV_BSIZE;
	if (dumplo < 0)
		dumplo = 0;
d175 14
a188 1
	dumpconf();
d191 38
a228 2
#define	DOSWAP			/* change swdevt and dumpdev */
u_long	bootdev = 0;		/* should be dev_t, but not until 32 bits */
d230 3
a232 7
static	char devname[][2] = {
	0,0,
	0,0,
	0,0,
	0,0,
	's','d',	/* 4 = sd -- new SCSI system */
};
d234 9
d246 123
a368 7
	int majdev, mindev, unit, part, adaptor;
	dev_t temp, orootdev;
	struct swdevt *swp;

	printf("setroot boothowto %x bootdev %x\n", boothowto, bootdev);
	if (boothowto & RB_DFLTROOT ||
	    (bootdev & B_MAGICMASK) != (u_long)B_DEVMAGIC)
d370 20
a389 2
	majdev = (bootdev >> B_TYPESHIFT) & B_TYPEMASK;
	if (majdev > sizeof(devname) / sizeof(devname[0]))
d391 2
a392 5
	adaptor = (bootdev >> B_ADAPTORSHIFT) & B_ADAPTORMASK;
	part = (bootdev >> B_PARTITIONSHIFT) & B_PARTITIONMASK;
	unit = (bootdev >> B_UNITSHIFT) & B_UNITMASK;
	orootdev = rootdev;
	rootdev = MAKEDISKDEV(majdev, unit, part);
d394 1
a394 2
	 * If the original rootdev is the same as the one
	 * just calculated, don't need to adjust the swap configuration.
d396 3
a398 9
	if (rootdev == orootdev)
		return;
	printf("changing root device to %c%c%d%c\n",
		devname[majdev][0], devname[majdev][1],
		unit, part + 'a');
#ifdef DOSWAP
	mindev = DISKUNIT(rootdev);
	for (swp = swdevt; swp->sw_dev; swp++) {
		printf("DOSWAP swap %x dev %x\n", swp, swp->sw_dev);
d400 1
a400 1
		    mindev == DISKUNIT(swp->sw_dev)) {
d407 1
a407 1
	if (swp->sw_dev == 0)
d409 1
d411 2
a412 2
	 * If dumpdev was the same as the old primary swap
	 * device, move it to the new primary swap device.
d416 77
a492 1
#endif
@


1.2
log
@This is a remove to get rid of the old mvme88k port which was incomplete
to replace it with a working version. The kernel compiles and works
at least.  The new version will be imported shortly.
@
text
@d2 1
d31 1
a31 1
 *	$Id: autoconf.c,v 1.1 1995/10/18 12:32:17 deraadt Exp $
a44 1
int realconfig=0;
d47 1
d49 1
a49 1
 * called at boot time, configure all devices on system
d54 3
d58 2
a59 1
	 * this is the real thing baby (i.e. not console init)
d61 2
a62 4
	realconfig = 1;

	if (config_rootfound("mainbus", "mainbus") == 0)
		panic("no mainbus found");
d64 1
d72 2
d75 4
a103 17
/*
 * this function needs to get enough configured to do a console
 * basically this means start attaching the grfxx's that support 
 * the console. Kinda hacky but it works.
 */
int
config_console()
{	
	struct cfdata *cf;

	/*
	 * we need mainbus' cfdata.
	 */
	cf = config_rootsearch(NULL, "mainbus", "mainbus");
	if (cf == NULL)
		panic("no mainbus");
}
d135 1
@


1.1
log
@moved from m88k directory
@
text
@d30 1
a30 1
 *	$Id: autoconf.c,v 1.1.1.1 1995/10/18 10:54:25 deraadt Exp $
@


1.1.1.1
log
@Third try at importing the mvme88k port. This is a working kernel
from nivas.
Userland and compiler still need to be worked on.
Make certain what directory the import is done from.
@
text
@a1 1
 * Copyright (c) 1996 Nivas Madhur
d30 1
a30 1
 *	$Id: autoconf.c,v 1.3 1996/08/02 02:44:11 build Exp build $
d44 1
a46 1

d48 1
a48 1
 * called at boot time, configure all devices on the system.
d53 5
a59 7

	/*
	 * Turn external interrupts on. We have all the drivers in
	 * place now!
	 */
	enable_interrupt();
	spl0();
a60 1
#if 0
a67 2
#endif /* 0 */
	setroot();
a68 4

	/*
	 * Done with autoconfig!
  	 */
d94 17
a141 1
	dumpconf();
@
