head	1.29;
access;
symbols
	SMP_SYNC_A:1.29
	SMP_SYNC_B:1.29
	OPENBSD_3_5:1.28.0.2
	OPENBSD_3_5_BASE:1.28
	OPENBSD_3_4:1.24.0.2
	OPENBSD_3_4_BASE:1.24
	UBC_SYNC_A:1.21
	OPENBSD_3_3:1.21.0.2
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.20.0.4
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.20.0.2
	OPENBSD_3_1_BASE:1.20
	UBC_SYNC_B:1.20
	UBC:1.18.0.2
	UBC_BASE:1.18
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_8:1.7.0.8
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.6
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.4
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	mvme88kport:1.1.1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@# @;


1.29
date	2004.04.29.14.33.27;	author miod;	state dead;
branches;
next	1.28;

1.28
date	2004.01.23.17.26.06;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2003.11.08.21.45.19;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2003.11.03.06.54.26;	author david;	state Exp;
branches;
next	1.25;

1.25
date	2003.10.27.10.43.44;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2003.08.13.08.52.44;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2003.08.11.20.45.17;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2003.08.03.23.34.09;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2003.01.09.22.27.09;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2002.01.21.20.35.51;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2002.01.21.19.59.19;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.16.23.49.46;	author miod;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2001.12.13.08.55.52;	author smurph;	state Exp;
branches;
next	1.16;

1.16
date	2001.08.24.22.53.15;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.27.04.29.19;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.20.05.53.09;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2001.03.09.05.44.41;	author smurph;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.08.22.25.06;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.07.23.40.35;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.01.03.38.20;	author smurph;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.14.20.25.25;	author smurph;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.13.05.18.59;	author smurph;	state Exp;
branches;
next	1.7;

1.7
date	99.09.27.19.13.22;	author smurph;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	99.02.09.06.36.28;	author smurph;	state Exp;
branches;
next	1.5;

1.5
date	98.12.15.05.11.02;	author smurph;	state Exp;
branches;
next	1.4;

1.4
date	97.05.24.03.02.31;	author rahnds;	state Exp;
branches;
next	1.3;

1.3
date	97.03.03.20.21.37;	author rahnds;	state Exp;
branches;
next	1.2;

1.2
date	97.03.03.19.08.06;	author rahnds;	state dead;
branches;
next	1.1;

1.1
date	95.10.18.12.32.24;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.03.03.19.32.18;	author rahnds;	state Exp;
branches;
next	;

1.7.4.1
date	2001.04.18.16.11.34;	author niklas;	state Exp;
branches;
next	1.7.4.2;

1.7.4.2
date	2001.07.04.10.20.13;	author niklas;	state Exp;
branches;
next	1.7.4.3;

1.7.4.3
date	2001.10.31.03.01.19;	author nate;	state Exp;
branches;
next	1.7.4.4;

1.7.4.4
date	2002.03.06.02.04.45;	author niklas;	state Exp;
branches;
next	1.7.4.5;

1.7.4.5
date	2003.03.27.23.32.18;	author niklas;	state Exp;
branches;
next	1.7.4.6;

1.7.4.6
date	2004.02.19.10.49.07;	author niklas;	state Exp;
branches;
next	1.7.4.7;

1.7.4.7
date	2004.06.05.23.09.50;	author niklas;	state dead;
branches;
next	;

1.18.2.1
date	2002.01.31.22.55.19;	author niklas;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2003.05.19.21.45.53;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Continue factorizing m88k common code, this time files in <arch>/<arch>
which were copied verbatim from mvme88k to luna88k.

This requires backing out syntactic sugar in mvme88k kernel configuration
files which would deduct the required processor types from the board models,
as the common code only depends upon the M88100 and M88110 defines.
@
text
@/* $OpenBSD: locore_asm_routines.S,v 1.28 2004/01/23 17:26:06 miod Exp $	*/
/*
 * Mach Operating System
 * Copyright (c) 1993-1992 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * Copyright (c) 1996 Nivas Madhur
 * Copyright (c) 1998 Steve Murphree, Jr.
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON AND OMRON ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON AND OMRON DISCLAIM ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include "assym.h"

#include <sys/errno.h>

#include <machine/asm.h>
#include <machine/board.h>
#include <machine/cpu_number.h>
#include <machine/trap.h>

/*****************************************************************************
 * DO_LOAD_ADDRESS
 *
 * 	unsigned int do_load_word(address, supervisor_mode)
 *	vaddr_t address;		\\ in r2
 *	boolean_t supervisor_mode;	\\ in r3
 *
 * Return the word at ADDRESS (from user space if SUPERVISOR_MODE is zero,
 * supervisor space if non-zero).
 *
 */

ENTRY(do_load_word)	/* do_load_word(address, supervisor) */
	bcnd	ne0,r3,1f
#ifdef ERRATA__XXX_USR
	NOP
	ld.usr	r2,r2,r0
	NOP
	NOP
	NOP
#else
	ld.usr	r2,r2,r0
#endif
	br	2f
1:	ld	r2,r2,r0
2:	jmp	r1

ENTRY(do_load_half)	/* do_load_half(address, supervisor) */
	bcnd	ne0,r3,1f
#ifdef ERRATA__XXX_USR
	NOP
	ld.h.usr	r2,r2,r0
	NOP
	NOP
	NOP
#else
	ld.h.usr	r2,r2,r0
#endif
	br	2f
1:	ld.h	r2,r2,r0
2:	jmp	r1

ENTRY(do_load_byte)	/* do_load_byte(address, supervisor) */
	bcnd	ne0,r3,1f
#ifdef ERRATA__XXX_USR
	NOP
	ld.b.usr	r2,r2,r0
	NOP
	NOP
	NOP
#else
	ld.b.usr	r2,r2,r0
#endif
	br	2f
1:	ld.b	r2,r2,r0
2:	jmp	r1

ENTRY(do_store_word)	/* do_store_word(address, data, supervisor) */
	bcnd	ne0,r4,1f
#ifdef ERRATA__XXX_USR
	NOP
	st.usr	r3,r2,r0
	NOP
	NOP
	NOP
#else
	st.usr	r3,r2,r0
#endif
	br	2f
1:	st	r3,r2,r0
2:	jmp	r1

ENTRY(do_store_half)	/* do_store_half(address, data, supervisor) */
	bcnd	ne0,r4,1f
#ifdef ERRATA__XXX_USR
	NOP
	st.h.usr	r3,r2,r0
	NOP
	NOP
	NOP
#else
	st.h.usr	r3,r2,r0
#endif
	br	2f
1:	st.h	r3,r2,r0
2:	jmp	r1

ENTRY(do_store_byte)	/* do_store_byte(address, data, supervisor) */
	bcnd	ne0,r4,1f
#ifdef ERRATA__XXX_USR
	NOP
	st.b.usr	r3,r2,r0
	NOP
	NOP
	NOP
#else
	st.b.usr	r3,r2,r0
#endif
	br	2f
1:	st.b	r3,r2,r0
2:	jmp	r1

ENTRY(do_xmem_word)	/* do_xmem_word(address, data, supervisor) */
	bcnd	ne0,r4,1f
#ifdef ERRATA__XXX_USR
	NOP
	xmem.usr	r3,r2,r0
	NOP
	NOP
	NOP
#else
	xmem.usr	r3,r2,r0
#endif
	br	2f
1:	xmem	r3,r2,r0
2:	jmp	r1

ENTRY(do_xmem_byte)	/* do_xmem_byte(address, data, supervisor) */
	bcnd	ne0,r4,1f
#ifdef ERRATA__XXX_USR
	NOP
	xmem.bu.usr	r3,r2,r0
	NOP
	NOP
	NOP
#else
	xmem.bu.usr	r3,r2,r0
#endif
	br	2f
1:	xmem.bu	r3,r2,r0
2:	jmp	r1

/*
 * Copy specified amount of data from user space into the kernel
 * copyin(from, to, len)
 *	r2 == from (user source address)
 *	r3 == to (kernel destination address)
 *	r4 == length
 * (r1=return addr)
 */

#define	SRC	r2
#define	DEST	r3
#define	LEN	r4

ENTRY(copyin)
	/* set up fault handler */
	or.u	r5,   r0,   hi16(_C_LABEL(curpcb))
	ld	r6,   r5,   lo16(_C_LABEL(curpcb))
	or.u	r5,   r0,   hi16(_ASM_LABEL(Lciflt))
	or	r5,   r5,   lo16(_ASM_LABEL(Lciflt))
	st	r5,   r6,   PCB_ONFAULT	/* pcb_onfault = Lciflt */

#if 0
	bcnd	ne0,  LEN,  1f		/* XXX optimize len = 0 case */
	or	r2,   r0,   0
	br	_ASM_LABEL(Lcidone)
1:	bcnd	lt0,  LEN,  _ASM_LABEL(Lciflt)	/* EFAULT if len < 0 */
#endif

	/* If it's a small length (less than 8), then do byte-by-byte */
	cmp	r9,   LEN,  8
	bb1	lt,   r9,   _ASM_LABEL(copyin_byte_only)

	/* If they're not aligned similarly, use byte only... */
	xor	r9,   SRC,  DEST
	mask	r8,   r9,   0x3
	bcnd	ne0,  r8,   _ASM_LABEL(copyin_byte_only)

	/*
	 * At this point, we don't know if they're word aligned or not,
	 * but we know that what needs to be done to one to align
	 * it is what's needed for the other.
	 */
	bb1	0,    SRC,  _ASM_LABEL(copyin_left_align_to_halfword)
ASLOCAL(copyin_left_aligned_to_halfword)
	bb1	1,    SRC,  _ASM_LABEL(copyin_left_align_to_word)
ASLOCAL(copyin_left_aligned_to_word)
	bb1	0,    LEN,  _ASM_LABEL(copyin_right_align_to_halfword)
ASLOCAL(copyin_right_aligned_to_halfword)
	bb1	1,    LEN,  _ASM_LABEL(copyin_right_align_to_word)
ASLOCAL(copyin_right_aligned_to_word)

	/* At this point, both SRC and DEST are aligned to a word */
	/* boundry, and LEN is an even multiple of 4.             */
	bb1.n	2,    LEN,  _ASM_LABEL(copyin_right_align_to_doubleword)
	 or	r7,   r0,   4

ASLOCAL(copyin_right_aligned_to_doubleword)
#ifdef ERRATA__XXX_USR
	NOP
	ld.usr	r5,   SRC,  r0
	NOP
	NOP
	NOP
	ld.usr	r6,   SRC,  r7
	NOP
	NOP
	NOP
#else
	ld.usr	r5,   SRC,  r0
	ld.usr	r6,   SRC,  r7
#endif
	subu	LEN,  LEN,  8
	st	r5,   DEST, r0
	addu	SRC,  SRC,  8
	st	r6,   DEST, r7
	bcnd.n	ne0,  LEN,  _ASM_LABEL(copyin_right_aligned_to_doubleword)
	 addu	DEST, DEST, 8
	br.n	_ASM_LABEL(Lcidone)
	 or	r2, r0, r0	/* successful return */

	/***************************************************/

ASLOCAL(copyin_left_align_to_halfword)
#ifdef ERRATA__XXX_USR
	NOP
	ld.b.usr	r5,   SRC,  r0
	NOP
	NOP
	NOP
#else
	ld.b.usr	r5,   SRC,  r0
#endif
	subu	LEN,  LEN,  1
	st.b	r5,   DEST, r0
	addu	SRC,  SRC,  1
	br.n	_ASM_LABEL(copyin_left_aligned_to_halfword)
	 addu	DEST, DEST, 1

ASLOCAL(copyin_left_align_to_word)
#ifdef ERRATA__XXX_USR
	NOP
	ld.h.usr	r5,   SRC,  r0
	NOP
	NOP
	NOP
#else
	ld.h.usr	r5,   SRC,  r0
#endif
	subu	LEN,  LEN,  2
	st.h	r5,   DEST, r0
	addu	SRC,  SRC,  2
	br.n	_ASM_LABEL(copyin_left_aligned_to_word)
	 addu	DEST, DEST, 2

ASLOCAL(copyin_right_align_to_halfword)
	subu	LEN,  LEN,  1
#ifdef ERRATA__XXX_USR
	NOP
	ld.b.usr	r5,   SRC,  LEN
	NOP
	NOP
	NOP
#else
	ld.b.usr	r5,   SRC,  LEN
#endif
	br.n	_ASM_LABEL(copyin_right_aligned_to_halfword)
	 st.b	r5,   DEST, LEN

ASLOCAL(copyin_right_align_to_word)
	subu	LEN,  LEN,  2
#ifdef ERRATA__XXX_USR
	NOP
	ld.h.usr	r5,   SRC,  LEN
	NOP
	NOP
	NOP
#else
	ld.h.usr	r5,   SRC,  LEN
#endif
	br.n	_ASM_LABEL(copyin_right_aligned_to_word)
	 st.h	r5,   DEST, LEN

ASLOCAL(copyin_right_align_to_doubleword)
	subu	LEN,  LEN,  4
#ifdef ERRATA__XXX_USR
	NOP
	ld.usr	r5,   SRC,  LEN
	NOP
	NOP
	NOP
#else
	ld.usr	r5,   SRC,  LEN
#endif
	bcnd.n	ne0,  LEN, _ASM_LABEL(copyin_right_aligned_to_doubleword)
	 st	r5,   DEST, LEN
	br.n	_ASM_LABEL(Lcidone)
   	 or	r2, r0, r0	/* successful return */

ASLOCAL(copyin_byte_only)
	bcnd	eq0, LEN, 2f
1:
	subu	LEN, LEN, 1
#ifdef ERRATA__XXX_USR
	NOP
	ld.b.usr	r5, SRC, LEN
	NOP
	NOP
	NOP
#else
	ld.b.usr	r5, SRC, LEN
#endif
	bcnd.n	ne0, LEN, 1b
	 st.b	r5, DEST, LEN
2:
	br.n	_ASM_LABEL(Lcidone)
	 or	r2, r0, r0	/* successful return */

ASLOCAL(Lcidone)
	or.u	r5,r0,hi16(_C_LABEL(curpcb))
	ld	r6,r5,lo16(_C_LABEL(curpcb))
	jmp.n	r1
	 st	r0,r6,PCB_ONFAULT

ASLOCAL(Lciflt)
	br.n	_ASM_LABEL(Lcidone)
	 or	r2, r0, EFAULT	/* return fault */

#undef	SRC
#undef	DEST
#undef	LEN
/*######################################################################*/
/*######################################################################*/

/*
 * Copy a null terminated string from the user space to the kernel
 * address space.
 *
 * copyinstr(from, to, maxlen, &lencopied)
 * r2 == from
 * r3 == to
 * r4 == maxlen
 * r5 == len actually transferred (includes the terminating NULL!!!)
 * r6 & r7 - used as temporaries
 */
#define	SRC	r2
#define	DEST	r3
#define	CNT	r4
#define	LEN	r5

ENTRY(copyinstr)

	/* setup fault handler */
	or.u	r6,   r0,   hi16(_C_LABEL(curpcb))
	ld	r7,   r6,   lo16(_C_LABEL(curpcb))
	or.u	r6,   r0,   hi16(_ASM_LABEL(Lcisflt))
	or	r6,   r6,   lo16(_ASM_LABEL(Lcisflt))
	st	r6,   r7,   PCB_ONFAULT
	or	r6,   r0,   0
	bcnd	lt0,  CNT,  _ASM_LABEL(Lcisflt)
	bcnd	eq0,  CNT,  _ASM_LABEL(Lcistoolong)
1:
#ifdef ERRATA__XXX_USR
	NOP
	ld.bu.usr	r7,   SRC,  r6
	NOP
	NOP
	NOP
#else
	ld.bu.usr	r7,   SRC,  r6
#endif
	st.b	r7, DEST, r6
	bcnd.n	eq0,  r7, 2f		/* all done */
	 addu	r6,   r6, 1
	cmp	r7,   r6, CNT
	bb1	lt,   r7, 1b

ASLOCAL(Lcistoolong)
	or	r2,   r0, ENAMETOOLONG	/* overflow */

ASLOCAL(Lcisnull)
	bcnd	eq0,r6, _ASM_LABEL(Lcisdone)	/* do not attempt to clear last byte */
					/* if we did not write to the string */
	subu	r6,   r6, 1
	st.b	r0, DEST, r6		/* clear last byte */
	br.n	_ASM_LABEL(Lcisdone)
	 addu	r6,   r6, 1
2:					/* all done */
	or	r2,   r0, 0

ASLOCAL(Lcisdone)
	bcnd	eq0, LEN, 3f
	st	r6, r0, LEN
3:
	or.u	r5,r0,hi16(_C_LABEL(curpcb))
	ld	r6,r5,lo16(_C_LABEL(curpcb))
	jmp.n	r1
	 st	r0,r6,PCB_ONFAULT	/* clear the handler */

ASLOCAL(Lcisflt)
	br.n	_ASM_LABEL(Lcisnull)
	 or	r2, r0, EFAULT		/* return fault */

#undef	SRC
#undef	DEST
#undef	CNT
#undef	LEN

/*
 * Copy specified amount of data from kernel to the user space
 * Copyout(from, to, len)
 *	r2 == from (kernel source address)
 *	r3 == to (user destination address)
 *	r4 == length
 */

#define	SRC	r2
#define	DEST	r3
#define	LEN	r4

ENTRY(copyout)
	/* setup fault handler */
	or.u	r5,   r0,   hi16(_C_LABEL(curpcb))
	ld	r6,   r5,   lo16(_C_LABEL(curpcb))
	or.u	r5,   r0,   hi16(_ASM_LABEL(Lcoflt))
	or	r5,   r5,   lo16(_ASM_LABEL(Lcoflt))
	st	r5,   r6,   PCB_ONFAULT	/* pcb_onfault = Lcoflt */
#if 0
	bcnd	ne0,  LEN,  1f		/* XXX optimize len = 0 case */
	or	r2,   r0,   0
	br	_ASM_LABEL(Lcodone)
1:	bcnd	lt0,  LEN,  _ASM_LABEL(Lcoflt)	/* EFAULT if len < 0 */
#endif
	/* If it's a small length (less than 8), then do byte-by-byte */
	cmp	r9,   LEN,  8
	bb1	lt,   r9,   _ASM_LABEL(copyout_byte_only)

	/* If they're not aligned similarly, use byte only... */
	xor	r9,   SRC,  DEST
	mask	r8,   r9,   0x3
	bcnd	ne0,  r8,   _ASM_LABEL(copyout_byte_only)

	/*
	 * At this point, we don't know if they're word aligned or not,
	 * but we know that what needs to be done to one to align
	 * it is what's needed for the other.
	 */
	bb1	0,    SRC,  _ASM_LABEL(copyout_left_align_to_halfword)
ASLOCAL(copyout_left_aligned_to_halfword)
	bb1	1,    SRC,  _ASM_LABEL(copyout_left_align_to_word)
ASLOCAL(copyout_left_aligned_to_word)
	bb1	0,    LEN,  _ASM_LABEL(copyout_right_align_to_halfword)
ASLOCAL(copyout_right_aligned_to_halfword)
	bb1	1,    LEN,  _ASM_LABEL(copyout_right_align_to_word)
ASLOCAL(copyout_right_aligned_to_word)

	/*
	 * At this point, both SRC and DEST are aligned to a word
	 * boundry, and LEN is an even multiple of 4.
	 */
	bb1.n	2,    LEN,  _ASM_LABEL(copyout_right_align_to_doubleword)
	 or	r7,   r0,   4

ASLOCAL(copyout_right_aligned_to_doubleword)
	ld 	r5,   SRC,  r0
	ld    	r6,   SRC,  r7
	subu	LEN,  LEN,  8
#ifdef ERRATA__XXX_USR
	NOP
	st.usr	r5,   DEST, r0
	NOP
	NOP
	NOP
#else
	st.usr	r5,   DEST, r0
#endif
	addu	SRC,  SRC,  8
#ifdef ERRATA__XXX_USR
	NOP
	st.usr	r6,   DEST, r7
	NOP
	NOP
	NOP
#else
	st.usr	r6,   DEST, r7
#endif
	bcnd.n	ne0,  LEN,  _ASM_LABEL(copyout_right_aligned_to_doubleword)
	 addu	DEST, DEST, 8
	or	r2, r0, r0	/* successful return */
	br	_ASM_LABEL(Lcodone)

	/***************************************************/
ASLOCAL(copyout_left_align_to_halfword)
	ld.b	r5,   SRC,  r0
	subu	LEN,  LEN,  1
#ifdef ERRATA__XXX_USR
	NOP
	st.b.usr	r5,   DEST, r0
	NOP
	NOP
	NOP
#else
	st.b.usr	r5,   DEST, r0
#endif
	addu	SRC,  SRC,  1
	br.n	_ASM_LABEL(copyout_left_aligned_to_halfword)
	 addu	DEST, DEST, 1

ASLOCAL(copyout_left_align_to_word)
	ld.h	r5,   SRC,  r0
	subu	LEN,  LEN,  2
#ifdef ERRATA__XXX_USR
	NOP
	st.h.usr	r5,   DEST, r0
	NOP
	NOP
	NOP
#else
	st.h.usr	r5,   DEST, r0
#endif
	addu	SRC,  SRC,  2
	br.n	_ASM_LABEL(copyout_left_aligned_to_word)
	 addu	DEST, DEST, 2

ASLOCAL(copyout_right_align_to_halfword)
	subu	LEN,  LEN,  1
	ld.b	r5,   SRC,  LEN
#ifdef ERRATA__XXX_USR
	NOP
	st.b.usr	r5,   DEST, LEN
	NOP
	NOP
	NOP
	br	_ASM_LABEL(copyout_right_aligned_to_halfword)
#else
	br.n	_ASM_LABEL(copyout_right_aligned_to_halfword)
	 st.b.usr	r5,   DEST, LEN
#endif

ASLOCAL(copyout_right_align_to_word)
	subu	LEN,  LEN,  2
	ld.h	r5,   SRC,  LEN
#ifdef ERRATA__XXX_USR
	NOP
	st.h.usr	r5,   DEST, LEN
	NOP
	NOP
	NOP
	br	_ASM_LABEL(copyout_right_aligned_to_word)
#else
	br.n	_ASM_LABEL(copyout_right_aligned_to_word)
	 st.h.usr	r5,   DEST, LEN
#endif

ASLOCAL(copyout_right_align_to_doubleword)
	subu	LEN,  LEN,  4
	ld	r5,   SRC,  LEN
#ifdef ERRATA__XXX_USR
	NOP
	st.usr	r5,   DEST, LEN
	NOP
	NOP
	NOP
	bcnd	ne0,  LEN, _ASM_LABEL(copyout_right_aligned_to_doubleword)
#else
	bcnd.n	ne0,  LEN, _ASM_LABEL(copyout_right_aligned_to_doubleword)
	 st.usr	r5,   DEST, LEN
#endif
	br.n	_ASM_LABEL(Lcodone)
	 or	r2, r0, r0	/* successful return */

ASLOCAL(copyout_byte_only)
	bcnd	eq0, LEN, 2f
1:
	subu	LEN, LEN, 1
	ld.b	r5, SRC, LEN
#ifdef ERRATA__XXX_USR
	NOP
	st.b.usr	r5, DEST, LEN
	NOP
	NOP
	NOP
	bcnd	ne0, LEN, 1b
#else
	bcnd.n	ne0, LEN, 1b
	 st.b.usr	r5, DEST, LEN
#endif

2:
	br.n	_ASM_LABEL(Lcodone)
	 or	r2, r0, r0	/* successful return */

ASLOCAL(Lcodone)
	or.u	r5,r0,hi16(_C_LABEL(curpcb))
	ld	r6,r5,lo16(_C_LABEL(curpcb))
	jmp.n	r1
	 st	r0,r6,PCB_ONFAULT	/* clear the handler */

ASLOCAL(Lcoflt)
	br.n	_ASM_LABEL(Lcodone)
	 or	r2, r0, EFAULT	/* return fault */

#undef	SRC
#undef	DEST
#undef	LEN

/*
 * Copy a null terminated string from the kernel space to the user
 * address space.
 *
 * copyoutstr(from, to, maxlen, &lencopied)
 * r2 == from
 * r3 == to
 * r4 == maxlen that can be copied
 * r5 == len actually copied (including the terminating NULL!!!)
 */

#define	SRC	r2
#define	DEST	r3
#define	CNT	r4
#define	LEN	r5

ENTRY(copyoutstr)
	/* setup fault handler */
	or.u	r6,   r0,   hi16(_C_LABEL(curpcb))
	ld	r7,   r6,   lo16(_C_LABEL(curpcb))
	or.u	r6,   r0,   hi16(_ASM_LABEL(Lcosflt))
	or	r6,   r6,   lo16(_ASM_LABEL(Lcosflt))
	st	r6,   r7,   PCB_ONFAULT
	bcnd	lt0,  CNT,  _ASM_LABEL(Lcosflt)
	bcnd	eq0,  CNT,  _ASM_LABEL(Lcosdone)
	or	r6,   r0,   0
1:
	ld.bu	r7,   SRC,  r6
#ifdef ERRATA__XXX_USR
	NOP
	st.b.usr	r7,   DEST,  r6
	NOP
	NOP
	NOP
#else
	st.b.usr	r7,   DEST,  r6
#endif
	bcnd.n	eq0,  r7, 2f		/* all done */
	 addu	r6,   r6, 1
	cmp	r7,   r6, CNT
	bb1	lt,   r7, 1b
	br.n	_ASM_LABEL(Lcosdone)
	 or	r2,   r0, ENAMETOOLONG
2:
	br.n	_ASM_LABEL(Lcosdone)
	 or	r2,   r0, 0

ASLOCAL(Lcosflt)
	br.n	_ASM_LABEL(Lcosdone)
	 or	r2, r0, EFAULT

ASLOCAL(Lcosdone)
	bcnd	eq0, LEN, 3f
	st	r6, r0, LEN
3:	or.u	r5,r0,hi16(_C_LABEL(curpcb))
	ld	r6,r5,lo16(_C_LABEL(curpcb))
	jmp.n	r1
	 st	r0,r6,PCB_ONFAULT	/* clear the handler */

#undef	SRC
#undef	DEST
#undef	CNT
#undef	LEN

/*######################################################################*/

/*
 * kcopy(const void *src, void *dst, size_t len);
 *
 * Copy len bytes from src to dst, aborting if we encounter a page fault.
 */
ENTRY(kcopy)
	or.u	r5,   r0,   hi16(_C_LABEL(curpcb))
	ld	r6,   r5,   lo16(_C_LABEL(curpcb))
	or.u	r5,   r0,   hi16(_ASM_LABEL(kcopy_fault))
	or	r5,   r5,   lo16(_ASM_LABEL(kcopy_fault))
	st	r5,   r6,   PCB_ONFAULT		/* pcb_onfault = kcopy_fault */
	bcnd	le0,r4,_ASM_LABEL(kcopy_out)	/* nothing to do if <= 0 */
/*
 *	check position of source and destination data
 */
	cmp 	r9,r2,r3	/* compare source address to destination */
	bb1	eq,r9,_ASM_LABEL(kcopy_out)	/* nothing to do if equal */
	bb1	lo,r9,_ASM_LABEL(kcopy_revers)e	/* reverse copy if src < dest */
/*
 *	source address is greater than destination address, copy forward
 */
	cmp 	r9,r4,16	/* see if we have at least 16 bytes */
	bb1	lt,r9,_ASM_LABEL(kf_byte_copy)	/* copy bytes for small length */
/*
 *	determine copy strategy based on alignment of source and destination
 */
	mask	r6,r2,3		/* get 2 low order bits of source address */
	mask	r7,r3,3		/* get 2 low order bits of destintation addr */
	mak	r6,r6,0<4>	/* convert source bits to table offset */
	mak	r7,r7,0<2>	/* convert destination bits to table offset */
	or.u	r12,r0,hi16(_ASM_LABEL(kf_strat))
	or	r12,r12,lo16(_ASM_LABEL(kf_strat))
	addu	r6,r6,r7	/* compute final table offset for strategy */
	ld	r12,r12,r6	/* load the strategy routine */
	jmp	r12		/* branch to strategy routine */

/*
 * Copy three bytes from src to destination then copy words
 */
ASLOCAL(kf_3byte_word_copy)
	ld.bu	r6,r2,0		/* load byte from source */
	ld.bu	r7,r2,1		/* load byte from source */
	ld.bu	r8,r2,2		/* load byte from source */
	st.b	r6,r3,0		/* store byte to destination */
	st.b	r7,r3,1		/* store byte to destination */
	st.b	r8,r3,2		/* store byte to destination */
	addu	r2,r2,3		/* increment source pointer */
	addu	r3,r3,3		/* increment destination pointer */
	br.n	_ASM_LABEL(kf_word_copy)	/* copy full words */
	 subu	r4,r4,3		/* decrement length */

/*
 * Copy 1 halfword from src to destination then copy words
 */
ASLOCAL(kf_1half_word_copy)
	ld.hu	r6,r2,0		/* load half-word from source */
	st.h	r6,r3,0		/* store half-word to destination */
	addu	r2,r2,2		/* increment source pointer */
	addu	r3,r3,2		/* increment destination pointer */
	br.n	_ASM_LABEL(kf_word_copy)	/* copy full words */
	 subu	r4,r4,2		/* decrement remaining length */

/*
 * Copy 1 byte from src to destination then copy words
 */
ASLOCAL(kf_1byte_word_copy)
	ld.bu	r6,r2,0		/* load 1 byte from source */
	st.b	r6,r3,0		/* store 1 byte to destination */
	addu	r2,r2,1		/* increment source pointer */
	addu	r3,r3,1		/* increment destination pointer */
	subu	r4,r4,1		/* decrement remaining length */
	/* fall through to word copy */
/*
 * Copy as many full words as possible, 4 words per loop
 */
ASLOCAL(kf_word_copy)
	cmp	r10,r4,16	/* see if we have 16 bytes remaining */
	bb1	lo,r10,_ASM_LABEL(kf_byte_copy) 	/* not enough left, copy bytes */
	ld	r6,r2,0		/* load first word */
	ld	r7,r2,4		/* load second word */
	ld	r8,r2,8		/* load third word */
	ld	r9,r2,12	/* load fourth word */
	st	r6,r3,0		/* store first word */
	st	r7,r3,4		/* store second word */
	st 	r8,r3,8		/* store third word */
	st 	r9,r3,12	/* store fourth word */
	addu	r2,r2,16	/* increment source pointer */
	addu	r3,r3,16	/* increment destination pointer */
	br.n	_ASM_LABEL(kf_word_copy)	/* copy another block */
	 subu	r4,r4,16	/* decrement remaining length */

ASLOCAL(kf_1byte_half_copy)
	ld.bu	r6,r2,0		/* load 1 byte from source */
	st.b	r6,r3,0		/* store 1 byte to destination */
	addu	r2,r2,1		/* increment source pointer */
	addu	r3,r3,1		/* increment destination pointer */
	subu	r4,r4,1		/* decrement remaining length */
	/* fall through to half copy */

ASLOCAL(kf_half_copy)
	cmp	r10,r4,16	/* see if we have 16 bytes remaining */
	bb1	lo,r10,_ASM_LABEL(kf_byte_copy)	/* not enough left, copy bytes */
	ld.hu	r6,r2,0		/* load first half-word */
	ld.hu	r7,r2,2		/* load second half-word */
	ld.hu	r8,r2,4		/* load third half-word */
	ld.hu	r9,r2,6		/* load fourth half-word */
	ld.hu	r10,r2,8	/* load fifth half-word */
	ld.hu	r11,r2,10	/* load sixth half-word */
	ld.hu	r12,r2,12	/* load seventh half-word */
	ld.hu	r13,r2,14	/* load eighth half-word */
	st.h	r6,r3,0		/* store first half-word */
	st.h	r7,r3,2		/* store second half-word */
	st.h 	r8,r3,4		/* store third half-word */
	st.h 	r9,r3,6		/* store fourth half-word */
	st.h	r10,r3,8	/* store fifth half-word */
	st.h	r11,r3,10	/* store sixth half-word */
	st.h 	r12,r3,12	/* store seventh half-word */
	st.h 	r13,r3,14	/* store eighth half-word */
	addu	r2,r2,16	/* increment source pointer */
	addu	r3,r3,16	/* increment destination pointer */
	br.n	_ASM_LABEL(kf_half_copy)	/* copy another block */
	 subu	r4,r4,16	/* decrement remaining length */

ASLOCAL(kf_byte_copy)
	bcnd	eq0,r4,_ASM_LABEL(kcopy_out)	/* branch if nothing left to copy */
	ld.bu	r6,r2,0		/* load byte from source */
	st.b	r6,r3,0		/* store byte in destination */
	addu	r2,r2,1		/* increment source pointer */
	addu	r3,r3,1		/* increment destination pointer */
	br.n	_ASM_LABEL(kf_byte_copy)	/* branch for next byte */
	 subu	r4,r4,1		/* decrement remaining length */

/*
 *	source address is less than destination address, copy in reverse
 */
ASLOCAL(kcopy_reverse)
/*
 * start copy pointers at end of data
 */
	addu	r2,r2,r4	/* start source at end of data */
	addu	r3,r3,r4	/* start destination at end of data */
/*
 * check for short data
 */
	cmp 	r9,r4,16	/* see if we have at least 16 bytes */
	bb1	lt,r9,_ASM_LABEL(kr_byte_copy)	/* copy bytes for small data length */
/*
 *	determine copy strategy based on alignment of source and destination
 */
	mask	r6,r2,3		/* get 2 low order bits of source address */
	mask	r7,r3,3		/* get 2 low order bits of destintation addr */
	mak	r6,r6,0<4>	/* convert source bits to table offset */
	mak	r7,r7,0<2>	/* convert destination bits to table offset */
	or.u	r12,r0,hi16(_ASM_LABEL(kr_strat))
	or	r12,r12,lo16(_ASM_LABEL(kr_strat))
	addu	r6,r6,r7	/* compute final table offset for strategy */
	ld	r12,r12,r6	/* load the strategy routine */
	jmp	r12		/* branch to strategy routine */

/*
 * Copy three bytes from src to destination then copy words
 */
ASLOCAL(kr_3byte_word_copy)
	subu	r2,r2,3		/* decrement source pointer */
	subu	r3,r3,3		/* decrement destination pointer */
	ld.bu	r6,r2,0		/* load byte from source */
	ld.bu	r7,r2,1		/* load byte from source */
	ld.bu	r8,r2,2		/* load byte from source */
	st.b	r6,r3,0		/* store byte to destination */
	st.b	r7,r3,1		/* store byte to destination */
	st.b	r8,r3,2		/* store byte to destination */
	br.n	_ASM_LABEL(kr_word_copy)	/* copy full words */
	 subu	r4,r4,3		/* decrement length */

/*
 * Copy 1 halfword from src to destination then copy words
 */
ASLOCAL(kr_1half_word_copy)
	subu	r2,r2,2		/* decrement source pointer */
	subu	r3,r3,2		/* decrement destination pointer */
	ld.hu	r6,r2,0		/* load half-word from source */
	st.h	r6,r3,0		/* store half-word to destination */
	br.n	_ASM_LABEL(kr_word_copy)	/* copy full words */
	 subu	r4,r4,2		/* decrement remaining length */

/*
 * Copy 1 byte from src to destination then copy words
 */
ASLOCAL(kr_1byte_word_copy)
	subu	r2,r2,1		/* decrement source pointer */
	subu	r3,r3,1		/* decrement destination pointer */
	ld.bu	r6,r2,0		/* load 1 byte from source */
	st.b	r6,r3,0		/* store 1 byte to destination */
	subu	r4,r4,1		/* decrement remaining length */
	/* fall through to word copy */
/*
 * Copy as many full words as possible, 4 words per loop
 */
ASLOCAL(kr_word_copy)
	cmp	r10,r4,16	/* see if we have 16 bytes remaining */
	bb1	lo,r10,_ASM_LABEL(kr_byte_copy)	/* not enough left, copy bytes */
	subu	r2,r2,16	/* decrement source pointer */
	subu	r3,r3,16	/* decrement destination pointer */
	ld	r6,r2,0		/* load first word */
	ld	r7,r2,4		/* load second word */
	ld	r8,r2,8		/* load third word */
	ld	r9,r2,12	/* load fourth word */
	st	r6,r3,0		/* store first word */
	st	r7,r3,4		/* store second word */
	st 	r8,r3,8		/* store third word */
	st 	r9,r3,12	/* store fourth word */
	br.n	_ASM_LABEL(kr_word_copy)	/* copy another block */
	 subu	r4,r4,16	/* decrement remaining length */

ASLOCAL(kr_1byte_half_copy)
	subu	r2,r2,1		/* decrement source pointer */
	subu	r3,r3,1		/* decrement destination pointer */
	ld.bu	r6,r2,0		/* load 1 byte from source */
	st.b	r6,r3,0		/* store 1 byte to destination */
	subu	r4,r4,1		/* decrement remaining length */
	/* fall through to half copy */

ASLOCAL(kr_half_copy)
	cmp	r10,r4,16	/* see if we have 16 bytes remaining */
	bb1	lo,r10,_ASM_LABEL(kr_byte_copy)	/* not enough left, copy bytes */
	subu	r2,r2,16	/* decrement source pointer */
	subu	r3,r3,16	/* decrement destination pointer */
	ld.hu	r6,r2,0		/* load first half-word */
	ld.hu	r7,r2,2		/* load second half-word */
	ld.hu	r8,r2,4		/* load third half-word */
	ld.hu	r9,r2,6		/* load fourth half-word */
	ld.hu	r10,r2,8	/* load fifth half-word */
	ld.hu	r11,r2,10	/* load sixth half-word */
	ld.hu	r12,r2,12	/* load seventh half-word */
	ld.hu	r13,r2,14	/* load eighth half-word */
	st.h	r6,r3,0		/* store first half-word */
	st.h	r7,r3,2		/* store second half-word */
	st.h 	r8,r3,4		/* store third half-word */
	st.h 	r9,r3,6		/* store fourth half-word */
	st.h	r10,r3,8	/* store fifth half-word */
	st.h	r11,r3,10	/* store sixth half-word */
	st.h 	r12,r3,12	/* store seventh half-word */
	st.h 	r13,r3,14	/* store eighth half-word */
	br.n	_ASM_LABEL(kr_half_copy)	/* copy another block */
	 subu	r4,r4,16	/* decrement remaining length */

ASLOCAL(kr_byte_copy)
	bcnd	eq0,r4,_ASM_LABEL(kcopy_out)	/* branch if nothing left to copy */
	subu	r2,r2,1		/* decrement source pointer */
	subu	r3,r3,1		/* decrement destination pointer */
	ld.bu	r6,r2,0		/* load byte from source */
	st.b	r6,r3,0		/* store byte in destination */
	br.n	_ASM_LABEL(kr_byte_copy)	/* branch for next byte */
	 subu	r4,r4,1		/* decrement remaining length */

ASLOCAL(kcopy_out)
	or	r2,   r0,   0		/* return success */
ASLOCAL(kcopy_out_fault)
	or.u	r5,r0,hi16(_C_LABEL(curpcb))
	ld	r6,r5,lo16(_C_LABEL(curpcb))
	st	r0,r6,PCB_ONFAULT	/* clear the handler */
	jmp	r1		/* all done, return to caller */

ASLOCAL(kcopy_fault)
	or	r2,   r0,   EFAULT	/* return fault */
	br	_ASM_LABEL(kcopy_out_fault)

	data
	align	4
ASLOCAL(kf_strat)
	word	_ASM_LABEL(kf_word_copy)
	word	_ASM_LABEL(kf_byte_copy)
	word	_ASM_LABEL(kf_half_copy)
	word	_ASM_LABEL(kf_byte_copy)
	word	_ASM_LABEL(kf_byte_copy)
	word	_ASM_LABEL(kf_3byte_word_copy)
	word	_ASM_LABEL(kf_byte_copy)
	word	_ASM_LABEL(kf_1byte_half_copy)
	word	_ASM_LABEL(kf_half_copy)
	word	_ASM_LABEL(kf_byte_copy)
	word	_ASM_LABEL(kf_1half_word_copy)
	word	_ASM_LABEL(kf_byte_copy)
	word	_ASM_LABEL(kf_byte_copy)
	word	_ASM_LABEL(kf_1byte_half_copy)
	word	_ASM_LABEL(kf_byte_copy)
	word	_ASM_LABEL(kf_1byte_word_copy)

ASLOCAL(kr_strat)
	word	_ASM_LABEL(kr_word_copy)
	word	_ASM_LABEL(kr_byte_copy)
	word	_ASM_LABEL(kr_half_copy)
	word	_ASM_LABEL(kr_byte_copy)
	word	_ASM_LABEL(kr_byte_copy)
	word	_ASM_LABEL(kr_1byte_word_copy)
	word	_ASM_LABEL(kr_byte_copy)
	word	_ASM_LABEL(kr_1byte_half_copy)
	word	_ASM_LABEL(kr_half_copy)
	word	_ASM_LABEL(kr_byte_copy)
	word	_ASM_LABEL(kr_1half_word_copy)
	word	_ASM_LABEL(kr_byte_copy)
	word	_ASM_LABEL(kr_byte_copy)
	word	_ASM_LABEL(kr_1byte_half_copy)
	word	_ASM_LABEL(kr_byte_copy)
	word	_ASM_LABEL(kr_3byte_word_copy)

/*
 * Gcc 2 generates calls to memcpy for bcopies of unknown size. memcpy can
 * simply be implemented as ovbcopy but the src (r2, r3) and dst args need to
 * be switched.
 */
/*
 * void memcpy(dest, source, count)
 *
 */
ENTRY(memcpy)
	or 	r5, r0, r2	/* dst -> tmp */
	or	r2, r0, r3	/* src -> 1st arg */
	br.n	_C_LABEL(ovbcopy)
	 or	r3, r0, r5	/* dst -> 2nd arg */

/*
 * void bcopy(source, destination, count)
 *
 * copy count bytes of data from source to destination
 * Don Harper (don@@omron.co.jp), Omron Corporation.
 *
 */

ENTRY(bcopy)
ENTRY(ovbcopy)
	bcnd	le0,r4,_ASM_LABEL(bcopy_out)	/* nothing to do if <= 0 */
/*
 *	check position of source and destination data
 */
	cmp 	r9,r2,r3	/* compare source address to destination */
	bb1	eq,r9,_ASM_LABEL(bcopy_out)	/* nothing to do if equal */
	bb1	lo,r9,_ASM_LABEL(bcopy_reverse)	/* reverse copy if src < dest */
/*
 *	source address is greater than destination address, copy forward
 */
	cmp 	r9,r4,16	/* see if we have at least 16 bytes */
	bb1	lt,r9,_ASM_LABEL(f_byte_copy)	/* copy bytes for small data length */
/*
 *	determine copy strategy based on alignment of source and destination
 */
	mask	r6,r2,3		/* get 2 low order bits of source address */
	mask	r7,r3,3		/* get 2 low order bits of destintation addr */
	mak	r6,r6,0<4>	/* convert source bits to table offset */
	mak	r7,r7,0<2>	/* convert destination bits to table offset */
	or.u	r12,r0,hi16(_ASM_LABEL(f_strat))
	or	r12,r12,lo16(_ASM_LABEL(f_strat))
	addu	r6,r6,r7	/* compute final table offset for strategy */
	ld	r12,r12,r6	/* load the strategy routine */
	jmp	r12		/* branch to strategy routine */


/*
 * Copy three bytes from src to destination then copy words
 */
ASLOCAL(f_3byte_word_copy)
	ld.bu	r6,r2,0		/* load byte from source */
	ld.bu	r7,r2,1		/* load byte from source */
	ld.bu	r8,r2,2		/* load byte from source */
	st.b	r6,r3,0		/* store byte to destination */
	st.b	r7,r3,1		/* store byte to destination */
	st.b	r8,r3,2		/* store byte to destination */
	addu	r2,r2,3		/* increment source pointer */
	addu	r3,r3,3		/* increment destination pointer */
	br.n	_ASM_LABEL(f_word_copy)	/* copy full words */
	 subu	r4,r4,3		/* decrement length */

/*
 * Copy 1 halfword from src to destination then copy words
 */
ASLOCAL(f_1half_word_copy)
	ld.hu	r6,r2,0		/* load half-word from source */
	st.h	r6,r3,0		/* store half-word to destination */
	addu	r2,r2,2		/* increment source pointer */
	addu	r3,r3,2		/* increment destination pointer */
	br.n	_ASM_LABEL(f_word_copy)	/* copy full words */
	 subu	r4,r4,2		/* decrement remaining length */

/*
 * Copy 1 byte from src to destination then copy words
 */
ASLOCAL(f_1byte_word_copy)
	ld.bu	r6,r2,0		/* load 1 byte from source */
	st.b	r6,r3,0		/* store 1 byte to destination */
	addu	r2,r2,1		/* increment source pointer */
	addu	r3,r3,1		/* increment destination pointer */
	subu	r4,r4,1		/* decrement remaining length */
	/* fall through to word copy */
/*
 * Copy as many full words as possible, 4 words per loop
 */
ASLOCAL(f_word_copy)
	cmp	r10,r4,16	/* see if we have 16 bytes remaining */
	bb1	lo,r10,_ASM_LABEL(f_byte_copy)	/* not enough left, copy bytes */
	ld	r6,r2,0		/* load first word */
	ld	r7,r2,4		/* load second word */
	ld	r8,r2,8		/* load third word */
	ld	r9,r2,12	/* load fourth word */
	st	r6,r3,0		/* store first word */
	st	r7,r3,4		/* store second word */
	st 	r8,r3,8		/* store third word */
	st 	r9,r3,12	/* store fourth word */
	addu	r2,r2,16	/* increment source pointer */
	addu	r3,r3,16	/* increment destination pointer */
	br.n	_ASM_LABEL(f_word_copy)	/* branch to copy another block */
	 subu	r4,r4,16	/* decrement remaining length */

ASLOCAL(f_1byte_half_copy)
	ld.bu	r6,r2,0		/* load 1 byte from source */
	st.b	r6,r3,0		/* store 1 byte to destination */
	addu	r2,r2,1		/* increment source pointer */
	addu	r3,r3,1		/* increment destination pointer */
	subu	r4,r4,1		/* decrement remaining length */
	/* fall through to half copy */

ASLOCAL(f_half_copy)
	cmp	r10,r4,16	/* see if we have 16 bytes remaining */
	bb1	lo,r10,_ASM_LABEL(f_byte_copy)	/* not enough left, copy bytes */
	ld.hu	r6,r2,0		/* load first half-word */
	ld.hu	r7,r2,2		/* load second half-word */
	ld.hu	r8,r2,4		/* load third half-word */
	ld.hu	r9,r2,6		/* load fourth half-word */
	ld.hu	r10,r2,8	/* load fifth half-word */
	ld.hu	r11,r2,10	/* load sixth half-word */
	ld.hu	r12,r2,12	/* load seventh half-word */
	ld.hu	r13,r2,14	/* load eighth half-word */
	st.h	r6,r3,0		/* store first half-word */
	st.h	r7,r3,2		/* store second half-word */
	st.h 	r8,r3,4		/* store third half-word */
	st.h 	r9,r3,6		/* store fourth half-word */
	st.h	r10,r3,8	/* store fifth half-word */
	st.h	r11,r3,10	/* store sixth half-word */
	st.h 	r12,r3,12	/* store seventh half-word */
	st.h 	r13,r3,14	/* store eighth half-word */
	addu	r2,r2,16	/* increment source pointer */
	addu	r3,r3,16	/* increment destination pointer */
	br.n	_ASM_LABEL(f_half_copy)	/* branch to copy another block */
	 subu	r4,r4,16	/* decrement remaining length */

ASLOCAL(f_byte_copy)
	bcnd	eq0,r4,_ASM_LABEL(bcopy_out)	/* branch if nothing left to copy */
	ld.bu	r6,r2,0		/* load byte from source */
	st.b	r6,r3,0		/* store byte in destination */
	addu	r2,r2,1		/* increment source pointer */
	addu	r3,r3,1		/* increment destination pointer */
	br.n	_ASM_LABEL(f_byte_copy)	/* branch for next byte */
	 subu	r4,r4,1		/* decrement remaining length */

/*
 *	source address is less than destination address, copy in reverse
 */
ASLOCAL(bcopy_reverse)
/*
 * start copy pointers at end of data
 */
	addu	r2,r2,r4	/* start source at end of data */
	addu	r3,r3,r4	/* start destination at end of data */
/*
 * check for short data
 */
	cmp 	r9,r4,16	/* see if we have at least 16 bytes */
	bb1	lt,r9,_ASM_LABEL(r_byte_copy)	/* copy bytes for small data length */
/*
 *	determine copy strategy based on alignment of source and destination
 */
	mask	r6,r2,3		/* get 2 low order bits of source address */
	mask	r7,r3,3		/* get 2 low order bits of destintation addr */
	mak	r6,r6,0<4>	/* convert source bits to table offset */
	mak	r7,r7,0<2>	/* convert destination bits to table offset */
	or.u	r12,r0,hi16(_ASM_LABEL(r_strat))
	or	r12,r12,lo16(_ASM_LABEL(r_strat))
	addu	r6,r6,r7	/* compute final table offset for strategy */
	ld	r12,r12,r6	/* load the strategy routine */
	jmp	r12		/* branch to strategy routine */

/*
 * Copy three bytes from src to destination then copy words
 */
ASLOCAL(r_3byte_word_copy)
	subu	r2,r2,3		/* decrement source pointer */
	subu	r3,r3,3		/* decrement destination pointer */
	ld.bu	r6,r2,0		/* load byte from source */
	ld.bu	r7,r2,1		/* load byte from source */
	ld.bu	r8,r2,2		/* load byte from source */
	st.b	r6,r3,0		/* store byte to destination */
	st.b	r7,r3,1		/* store byte to destination */
	st.b	r8,r3,2		/* store byte to destination */
	br.n	_ASM_LABEL(r_word_copy)	/* copy full words */
	 subu	r4,r4,3		/* decrement length */

/*
 * Copy 1 halfword from src to destination then copy words
 */
ASLOCAL(r_1half_word_copy)
	subu	r2,r2,2		/* decrement source pointer */
	subu	r3,r3,2		/* decrement destination pointer */
	ld.hu	r6,r2,0		/* load half-word from source */
	st.h	r6,r3,0		/* store half-word to destination */
	br.n	_ASM_LABEL(r_word_copy)	/* copy full words */
	 subu	r4,r4,2		/* decrement remaining length */

/*
 * Copy 1 byte from src to destination then copy words
 */
ASLOCAL(r_1byte_word_copy)
	subu	r2,r2,1		/* decrement source pointer */
	subu	r3,r3,1		/* decrement destination pointer */
	ld.bu	r6,r2,0		/* load 1 byte from source */
	st.b	r6,r3,0		/* store 1 byte to destination */
	subu	r4,r4,1		/* decrement remaining length */
	/* fall through to word copy */
/*
 * Copy as many full words as possible, 4 words per loop
 */
ASLOCAL(r_word_copy)
	cmp	r10,r4,16	/* see if we have 16 bytes remaining */
	bb1	lo,r10,_ASM_LABEL(r_byte_copy)	/* not enough left, copy bytes */
	subu	r2,r2,16	/* decrement source pointer */
	subu	r3,r3,16	/* decrement destination pointer */
	ld	r6,r2,0		/* load first word */
	ld	r7,r2,4		/* load second word */
	ld	r8,r2,8		/* load third word */
	ld	r9,r2,12	/* load fourth word */
	st	r6,r3,0		/* store first word */
	st	r7,r3,4		/* store second word */
	st 	r8,r3,8		/* store third word */
	st 	r9,r3,12	/* store fourth word */
	br.n	_ASM_LABEL(r_word_copy)	/* branch to copy another block */
	 subu	r4,r4,16	/* decrement remaining length */

ASLOCAL(r_1byte_half_copy)
	subu	r2,r2,1		/* decrement source pointer */
	subu	r3,r3,1		/* decrement destination pointer */
	ld.bu	r6,r2,0		/* load 1 byte from source */
	st.b	r6,r3,0		/* store 1 byte to destination */
	subu	r4,r4,1		/* decrement remaining length */
	/* fall through to half copy */

ASLOCAL(r_half_copy)
	cmp	r10,r4,16	/* see if we have 16 bytes remaining */
	bb1	lo,r10,_ASM_LABEL(r_byte_copy)	/* not enough left, copy bytes */
	subu	r2,r2,16	/* decrement source pointer */
	subu	r3,r3,16	/* decrement destination pointer */
	ld.hu	r6,r2,0		/* load first half-word */
	ld.hu	r7,r2,2		/* load second half-word */
	ld.hu	r8,r2,4		/* load third half-word */
	ld.hu	r9,r2,6		/* load fourth half-word */
	ld.hu	r10,r2,8	/* load fifth half-word */
	ld.hu	r11,r2,10	/* load sixth half-word */
	ld.hu	r12,r2,12	/* load seventh half-word */
	ld.hu	r13,r2,14	/* load eighth half-word */
	st.h	r6,r3,0		/* store first half-word */
	st.h	r7,r3,2		/* store second half-word */
	st.h 	r8,r3,4		/* store third half-word */
	st.h 	r9,r3,6		/* store fourth half-word */
	st.h	r10,r3,8	/* store fifth half-word */
	st.h	r11,r3,10	/* store sixth half-word */
	st.h 	r12,r3,12	/* store seventh half-word */
	st.h 	r13,r3,14	/* store eighth half-word */
	br.n	_ASM_LABEL(r_half_copy)	/* branch to copy another block */
	 subu	r4,r4,16	/* decrement remaining length */

ASLOCAL(r_byte_copy)
	bcnd	eq0,r4,_ASM_LABEL(bcopy_out)	/* branch if nothing left to copy */
	subu	r2,r2,1		/* decrement source pointer */
	subu	r3,r3,1		/* decrement destination pointer */
	ld.bu	r6,r2,0		/* load byte from source */
	st.b	r6,r3,0		/* store byte in destination */
	br.n	_ASM_LABEL(r_byte_copy)	/* branch for next byte */
	 subu	r4,r4,1		/* decrement remaining length */

ASLOCAL(bcopy_out)
	jmp	r1		/* all done, return to caller */

	data
	align	4
ASLOCAL(f_strat)
	word	_ASM_LABEL(f_word_copy)
	word	_ASM_LABEL(f_byte_copy)
	word	_ASM_LABEL(f_half_copy)
	word	_ASM_LABEL(f_byte_copy)
	word	_ASM_LABEL(f_byte_copy)
	word	_ASM_LABEL(f_3byte_word_copy)
	word	_ASM_LABEL(f_byte_copy)
	word	_ASM_LABEL(f_1byte_half_copy)
	word	_ASM_LABEL(f_half_copy)
	word	_ASM_LABEL(f_byte_copy)
	word	_ASM_LABEL(f_1half_word_copy)
	word	_ASM_LABEL(f_byte_copy)
	word	_ASM_LABEL(f_byte_copy)
	word	_ASM_LABEL(f_1byte_half_copy)
	word	_ASM_LABEL(f_byte_copy)
	word	_ASM_LABEL(f_1byte_word_copy)

ASLOCAL(r_strat)
	word	_ASM_LABEL(r_word_copy)
	word	_ASM_LABEL(r_byte_copy)
	word	_ASM_LABEL(r_half_copy)
	word	_ASM_LABEL(r_byte_copy)
	word	_ASM_LABEL(r_byte_copy)
	word	_ASM_LABEL(r_1byte_word_copy)
	word	_ASM_LABEL(r_byte_copy)
	word	_ASM_LABEL(r_1byte_half_copy)
	word	_ASM_LABEL(r_half_copy)
	word	_ASM_LABEL(r_byte_copy)
	word	_ASM_LABEL(r_1half_word_copy)
	word	_ASM_LABEL(r_byte_copy)
	word	_ASM_LABEL(r_byte_copy)
	word	_ASM_LABEL(r_1byte_half_copy)
	word	_ASM_LABEL(r_byte_copy)
	word	_ASM_LABEL(r_3byte_word_copy)

	text

/*######################################################################*/

/*
 * April 1990, Omron Corporation
 * jfriedl@@nff.ncl.omron.co.jp
 *
 * void bzero(destination, length)
 *
 * Clear (set to zero) LENGTH bytes of memory starting at DESTINATION.
 * Note that there is no return value.
 *
 * This is fast. Really fast. Especially for long lengths.
 */
#define R_dest			r2
#define R_len			r3

#define R_bytes			r4
#define R_mark_address		r5
#define R_addr			r6	/* R_addr && R_temp SHARE */
#define R_temp			r6	/* R_addr && R_temp SHARE */

ENTRY(bzero)
	/*
	 * If the destination is not word aligned, we'll word align
	 * it first to make things easier.
	 *
	 * We'll check to see first if bit #0 is set and then bit #1
	 * (of the destination address). If either are set, it's
	 * not word aligned.
	 */
	bb1	0, R_dest, _ASM_LABEL(not_initially_word_aligned)
	bb1	1, R_dest, _ASM_LABEL(not_initially_word_aligned)

ASLOCAL(now_word_aligned)
	/*
	 * before we get into the main loop, grab the
	 * address of the label "mark" below.
	 */
	or.u	R_mark_address, r0, hi16(_ASM_LABEL(mark))
	or	R_mark_address, R_mark_address, lo16(_ASM_LABEL(mark))

ASLOCAL(top_of_main_loop)
#define MAX_AT_ONE_TIME 128
	/*
	 * Now we find out how many words we can zero-fill in a row.
	 * We do this by doing something like:
	 *
	 *	bytes &= 0xfffffffc;
	 *	if (bytes > MAX_AT_ONE_TIME)
	 *		bytes = MAX_AT_ONE_TIME;
	 */

	/*
	 * Clear lower two bits of length to give us the number of bytes
	 * ALIGNED TO THE WORD LENGTH remaining to move.
	 */
	clr	R_bytes, R_len, 2<0>

	/* if we're done clearing WORDS, jump out */
	bcnd	eq0, R_bytes, _ASM_LABEL(done_doing_words)

	/* if the number of bytes > MAX_AT_ONE_TIME, do only the max */
	cmp	R_temp, R_bytes, MAX_AT_ONE_TIME
	bb1	lt, R_temp, 1f

	/*
	 * Since we're doing the max, we know exactly where we're
	 * jumping (the first one in the list!), so we can jump
	 * right there.  However, we've still got to adjust
	 * the length, so we'll jump to where we ajust the length
	 * which just happens to fall through to the first store zero
	 * in the list.
	 *
	 * Note, however, that we're jumping to an instruction that
	 * would be in the delay slot for the jump in front of it,
	 * so if you change things here, WATCH OUT.
	 */
	br.n	do_max
	 or	R_bytes, r0, MAX_AT_ONE_TIME

1:
	/*
	 * Now we have the number of bytes to zero during this iteration,
	 * (which, as it happens, is the last iteration if we're here).
	 * We'll calculate the proper place to jump and then jump there,
	 * after adjusting the length.  NOTE that there is a label between
	 * the "jmp.n" and the "subu" below... the "subu" is NOT always
	 * executed in the delay slot of the "jmp.n".
 	 */
	subu	R_addr, R_mark_address, R_bytes

	/* and go there (after adjusting the length via ".n") */
	jmp.n	R_addr
ASLOCAL(do_max)
	  subu	R_len, R_len, R_bytes	/* NOTE: this is in the delay slot! */

	st	r0, R_dest, 0x7c	/* 128 */
	st	r0, R_dest, 0x78	/* 124 */
	st	r0, R_dest, 0x74	/* 120 */
	st	r0, R_dest, 0x70	/* 116 */
	st	r0, R_dest, 0x6c	/* 112 */
	st	r0, R_dest, 0x68	/* 108 */
	st	r0, R_dest, 0x64	/* 104 */
	st	r0, R_dest, 0x60	/* 100 */
	st	r0, R_dest, 0x5c	/*  96 */
	st	r0, R_dest, 0x58	/*  92 */
	st	r0, R_dest, 0x54	/*  88 */
	st	r0, R_dest, 0x50	/*  84 */
	st	r0, R_dest, 0x4c	/*  80 */
	st	r0, R_dest, 0x48	/*  76 */
	st	r0, R_dest, 0x44	/*  72 */
	st	r0, R_dest, 0x40	/*  68 */
	st	r0, R_dest, 0x3c	/*  64 */
	st	r0, R_dest, 0x38	/*  60 */
	st	r0, R_dest, 0x34	/*  56 */
	st	r0, R_dest, 0x30	/*  52 */
	st	r0, R_dest, 0x2c	/*  44 */
	st	r0, R_dest, 0x28	/*  40 */
	st	r0, R_dest, 0x24	/*  36 */
	st	r0, R_dest, 0x20	/*  32 */
	st	r0, R_dest, 0x1c	/*  28 */
	st	r0, R_dest, 0x18	/*  24 */
	st	r0, R_dest, 0x14	/*  20 */
	st	r0, R_dest, 0x10	/*  16 */
	st	r0, R_dest, 0x0c	/*  12 */
	st	r0, R_dest, 0x08	/*   8 */
	st	r0, R_dest, 0x04	/*   4 */
	st	r0, R_dest, 0x00	/*   0 */

ASLOCAL(mark)
	br.n	_ASM_LABEL(top_of_main_loop)
	 addu	R_dest, R_dest, R_bytes	/* bump up the dest address */

ASLOCAL(done_doing_words)
	bcnd	ne0, R_len, 1f
	jmp	r1

1:
	subu	R_len, R_len, 1
	bcnd.n	ne0, R_len, 1b
	 st.b	r0, R_dest, R_len
1:
	jmp	r1

ASLOCAL(not_initially_word_aligned)
	/*
	 * Bzero to word-align the address (at least if the length allows it).
	 */
	bcnd	eq0, R_len, 1b
	st.b	r0, R_dest, 0
	addu	R_dest, R_dest, 1
	mask	R_temp, R_dest, 0x3
	bcnd.n	eq0, R_temp, _ASM_LABEL(now_word_aligned)
	 subu	R_len, R_len, 1
	br	_ASM_LABEL(not_initially_word_aligned)

#undef	R_dest
#undef	R_len
#undef	R_bytes
#undef	R_mark_address
#undef	R_addr
#undef	R_temp
#undef	MAX_AT_ONE_TIME

/*
 * non-local goto
 *	int setjmp(label_t *);
 *	void longjmp(label_t*);
 */
ENTRY(setjmp)
	st	r1,r2,0
	st	r14,r2,4
	st	r15,r2,2*4
	st	r16,r2,3*4
	st	r17,r2,4*4
	st	r18,r2,5*4
	st	r19,r2,6*4
	st	r20,r2,7*4
	st	r21,r2,8*4
	st	r22,r2,9*4
	st	r23,r2,10*4
	st	r24,r2,11*4
	st	r25,r2,12*4
	st	r26,r2,13*4
	st	r27,r2,14*4
	st	r28,r2,15*4
	st	r29,r2,16*4
	st	r30,r2,17*4
	st	r31,r2,18*4
	jmp.n	r1
	 or	r2,r0,r0

ENTRY(longjmp)
	ld	r1,r2,0
	ld	r14,r2,4
	ld	r15,r2,2*4
	ld	r16,r2,3*4
	ld	r17,r2,4*4
	ld	r18,r2,5*4
	ld	r19,r2,6*4
	ld	r20,r2,7*4
	ld	r21,r2,8*4
	ld	r22,r2,9*4
	ld	r23,r2,10*4
	ld	r24,r2,11*4
	ld	r25,r2,12*4
	ld	r26,r2,13*4
	ld	r27,r2,14*4
	ld	r28,r2,15*4
	ld	r29,r2,16*4
	ld	r30,r2,17*4
	ld	r31,r2,18*4
	jmp.n	r1
	 or	r2,r0,1

ENTRY(read_processor_identification_register)
	jmp.n	r1
	 ldcr	r2, PID

GLOBAL(guarded_access_start)
ENTRY(guarded_access)
	cmp	 r9,r3,4
	bb1	 eq,r9,@@L145
	cmp	 r9,r3,2
	bb1	 eq,r9,@@L144
	cmp	 r9,r3,1
	bb1	 eq,r9,@@L143
	br	 _C_LABEL(guarded_access_bad)
@@L143:
	ld.b	 r9,r0,r2
	tb1	0, r0, 0
	st.b	 r9,r0,r4
	br	 @@L142
@@L144:
	ld.h	 r9,r0,r2
	tb1	0, r0, 0
	st.h	 r9,r0,r4
	br	 @@L142
@@L145:
	ld	 r9,r0,r2
	tb1	0, r0, 0
	st	 r9,r0,r4
	br	 @@L142

GLOBAL(guarded_access_bad)
	jmp.n	 r1
	 or	 r2,r0,EFAULT

@@L142:
	jmp.n	 r1
	 or	 r2,r0,0

GLOBAL(guarded_access_end)

/*
 * void set_cpu_number(unsigned number);
 *
 * Sets the kernel cpu number for this cpu to the given value.
 *
 * Input:
 *	r1	return address
 *	r2 	the number (should be 0, 1, 2, or 3).
 *
 * Other registers used:
 *	r3	temp
 *	r4	original PSR
 *	r5	temporary new PSR
 */
ENTRY(set_cpu_number)
#ifdef DEBUG
	/* make sure the CPU number is valid */
	clr	r3, r2, FLAG_CPU_FIELD_WIDTH<0>
	bcnd	ne0, r3, 1f	/* bad cpu number */
#endif

	/* going to change a control register -- disable interrupts */
	ldcr	r4, PSR
	set	r5, r4, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r5, PSR
	FLUSH_PIPELINE

	/* put in the cpu number */
	ldcr	r3, SR1				/* get the flags */
	clr	r3, r3, FLAG_CPU_FIELD_WIDTH<0>	/* clean the slate */
	or	r3, r3, r2			/* add the cpu number */
	stcr	r3, SR1				/* put back */

	/* put back the PSR to what it was before and return */
	stcr	r4, PSR
	FLUSH_PIPELINE
	jmp	r1

#ifdef DEBUG
1:	/* bad cpu number*/
	or.u	r2, r0, hi16(9f)
	bsr.n	_C_LABEL(panic)
	 or	r2, r2, lo16(9f)

	data
9:	string "set_cpu_number: bad CPU number %x\0"
#endif
@


1.28
log
@Get rid of a few (mostly DDB related) unused defines and macros.
@
text
@d1 1
a1 1
/* $OpenBSD: locore_asm_routines.S,v 1.27 2003/11/08 21:45:19 miod Exp $	*/
@


1.27
log
@Inline invalidate_pte().
@
text
@d1 1
a1 1
/* $OpenBSD: locore_asm_routines.S,v 1.26 2003/11/03 06:54:26 david Exp $	*/
a171 8
#ifdef DDB
ENTRY(db_are_interrupts_disabled)
	ldcr	r2, PSR
	set	r3, r0, 1<PSR_INTERRUPT_DISABLE_BIT>
	jmp.n	r1
	 and	r2, r2, r3
#endif /* DDB */

a1535 6
#ifdef DDB
ENTRY(db_flush_pipeline)
	FLUSH_PIPELINE
	jmp	r1
#endif /* DDB */

d1590 1
d1594 1
d1601 1
a1601 2
	tcnd	ne0,r0,10 /* make sure interrupts are really disabled */
			  /* if they are not, branch to error_handler() */
d1613 1
d1620 2
a1621 1
9:	string "set_cpu_number: bad CPU number\0"
@


1.26
log
@spelling fixes (in the comments)
@
text
@d1 1
a1 1
/* $OpenBSD: locore_asm_routines.S,v 1.25 2003/10/27 10:43:44 miod Exp $	*/
a1542 14

/*
 *       invalidate_pte(pte)
 *
 *       This function will invalidate specified pte indivisibly
 *       to avoid the write-back of used-bit and/or modify-bit into
 *       that pte.  It also returns the pte found in the table.
 */
ENTRY(invalidate_pte)
	or	r3,r0,r0	| r3 = PG_NV
	xmem	r3,r2,r0	| exchange with *pte
	FLUSH_PIPELINE
	jmp.n	r1
	 or	r2,r3,r0	| return previous value
@


1.25
log
@Remove dead code and polish comments
@
text
@d1 1
a1 1
/* $OpenBSD: locore_asm_routines.S,v 1.24 2003/08/13 08:52:44 miod Exp $	*/
d212 1
a212 1
	/* If they're not aligned similiarly, use byte only... */
d476 1
a476 1
	/* If they're not aligned similiarly, use byte only... */
@


1.24
log
@Always force a pipeline flush after a PSR change, not before. How could
this have ever worked?
@
text
@d1 1
a1 1
/* $OpenBSD: locore_asm_routines.S,v 1.23 2003/08/11 20:45:17 miod Exp $	*/
d44 1
a44 1
 *	vm_offset_t address;		\\ in r2
d1552 3
a1554 3
	or	r3,r0,r0
	xmem	r3,r2,r0
	tb1	0,r0,0
d1556 1
a1556 1
	 or	r2,r3,r0
d1568 1
a1568 9
ENTRY(safe_byte_access)
	ld.b	 r9,r0,r2
	tb1	 0,r0,0
	br	 @@L1
	or	r0,r0,r0
@@L1:
	st.b	 r9,r0,r3
	jmp	r1

a1569 1
GLOBAL(guarded_access_start)
d1596 1
d1598 2
a1601 2
	jmp.n	 r1
	 or	 r2,r0,0
@


1.23
log
@Sprinkle proper use of _C_LABEL and _ASM_LABEL in the .S files (except for
the _fp.S which are too scary at the moment). This will be necessary to
move to ELF in the future.

Use local symbols whenever possible.

Attempt to use delayed branches whenever possible.

Remove stupid or straightforward comments, some hardcoded values, and a
few unused variables or routines.
@
text
@d1 1
a1 1
/* $OpenBSD: locore_asm_routines.S,v 1.22 2003/08/03 23:34:09 miod Exp $	*/
d1634 1
d1645 1
@


1.22
log
@Resistance is futile, you will be KNF'ed.
And then it will be easier to debug this mess (no functional change yet).
@
text
@d1 1
a1 1
/* $OpenBSD: locore_asm_routines.S,v 1.21 2003/01/09 22:27:09 miod Exp $	*/
a179 4
GLOBAL(FAULT_ERROR)
	or	r2,r0,1		/* bad copy */
	jmp	r1

d195 5
a199 5
	or.u	r5,   r0,   hi16(_curpcb)
	ld	r6,   r5,   lo16(_curpcb)
	or.u	r5,   r0,   hi16(.Lciflt)
	or	r5,   r5,   lo16(.Lciflt)
	st	r5,   r6,   PCB_ONFAULT	/* pcb_onfault = .Lciflt */
d204 2
a205 2
	br	.Lcidone
1:	bcnd	lt0,  LEN,  .Lciflt	/* EFAULT if len < 0 */
d210 1
a210 1
	bb1	lt,   r9,   copyin_byte_only
d215 1
a215 1
	bcnd	ne0,  r8,   copyin_byte_only
d222 8
a229 8
	bb1	0,    SRC,  copyin_left_align_to_halfword
copyin_left_aligned_to_halfword:
	bb1	1,    SRC,  copyin_left_align_to_word
copyin_left_aligned_to_word:
	bb1	0,    LEN,  copyin_right_align_to_halfword
copyin_right_aligned_to_halfword:
	bb1	1,    LEN,  copyin_right_align_to_word
copyin_right_aligned_to_word:
d233 1
a233 1
	bb1.n	2,    LEN,  copyin_right_align_to_doubleword
d236 1
a236 1
copyin_right_aligned_to_doubleword:
d255 1
a255 1
	bcnd.n	ne0,  LEN,  copyin_right_aligned_to_doubleword
d257 2
a258 2
	or	r2, r0, r0	/* successful return */
	br	.Lcidone
d262 1
a262 1
copyin_left_align_to_halfword:
d275 1
a275 1
	br.n	copyin_left_aligned_to_halfword
d278 1
a278 1
copyin_left_align_to_word:
d291 1
a291 1
	br.n	copyin_left_aligned_to_word
d294 1
a294 1
copyin_right_align_to_halfword:
d305 1
a305 1
	br.n	copyin_right_aligned_to_halfword
d308 1
a308 1
copyin_right_align_to_word:
d319 1
a319 1
	br.n	copyin_right_aligned_to_word
d322 1
a322 1
copyin_right_align_to_doubleword:
d333 1
a333 1
	bcnd.n	ne0,  LEN, copyin_right_aligned_to_doubleword
d335 2
a336 2
   	or	r2, r0, r0	/* successful return */
	br	.Lcidone
d338 1
a338 1
copyin_byte_only:
d353 13
a365 10
2:	or	r2, r0, r0	/* successful return */
	br	.Lcidone
.Lcidone:
	or.u	r5,r0,hi16(_curpcb)
	ld	r6,r5,lo16(_curpcb)
	st	r0,r6,PCB_ONFAULT
	jmp	r1
.Lciflt:
	or	r2, r0, EFAULT	/* return fault */
	br	.Lcidone
d392 4
a395 4
	or.u	r6,   r0,   hi16(_curpcb)
	ld	r7,   r6,   lo16(_curpcb)
	or.u	r6,   r0,   hi16(.Lcisflt)
	or	r6,   r6,   lo16(.Lcisflt)
d398 2
a399 2
	bcnd	lt0,  CNT,   .Lcisflt
	bcnd	eq0,  CNT,   .Lcistoolong
d416 1
a416 1
.Lcistoolong:
d419 2
a420 2
.Lcisnull:
	bcnd	eq0,r6, .Lcisdone	/* do not attempt to clear last byte */
d424 1
a424 1
	br.n	.Lcisdone
d429 1
a429 1
.Lcisdone:
d433 8
a440 7
	or.u	r5,r0,hi16(_curpcb)
	ld	r6,r5,lo16(_curpcb)
	st	r0,r6,PCB_ONFAULT	/* clear the handler */
	jmp	r1
.Lcisflt:
	or	r2, r0, EFAULT		/* return fault */
	br	.Lcisnull
d461 5
a465 9
#if 0
	tb0 0, r0, 132	/* entry trap */
	SET_PCB_ONFAULT(r5, r6, .Lcoflt)
#endif
	or.u	r5,   r0,   hi16(_curpcb)
	ld	r6,   r5,   lo16(_curpcb)
	or.u	r5,   r0,   hi16(.Lcoflt)
	or	r5,   r5,   lo16(.Lcoflt)
	st	r5,   r6,   PCB_ONFAULT	/* pcb_onfault = .Lcoflt */
d469 2
a470 2
	br	.Lcodone
1:	bcnd	lt0,  LEN,  .Lcoflt	/* EFAULT if len < 0 */
d474 1
a474 1
	bb1	lt,   r9,   copyout_byte_only
d479 1
a479 1
	bcnd	ne0,  r8,   copyout_byte_only
d486 8
a493 8
	bb1	0,    SRC,  copyout_left_align_to_halfword
copyout_left_aligned_to_halfword:
	bb1	1,    SRC,  copyout_left_align_to_word
copyout_left_aligned_to_word:
	bb1	0,    LEN,  copyout_right_align_to_halfword
copyout_right_aligned_to_halfword:
	bb1	1,    LEN,  copyout_right_align_to_word
copyout_right_aligned_to_word:
d499 1
a499 1
	bb1.n	2,    LEN,  copyout_right_align_to_doubleword
d502 1
a502 1
copyout_right_aligned_to_doubleword:
d525 1
a525 1
	bcnd.n	ne0,  LEN,  copyout_right_aligned_to_doubleword
d528 1
a528 1
	br	.Lcodone
d531 1
a531 1
copyout_left_align_to_halfword:
d544 1
a544 1
	br.n	copyout_left_aligned_to_halfword
d547 1
a547 1
copyout_left_align_to_word:
d560 1
a560 1
	br.n	copyout_left_aligned_to_word
d563 1
a563 1
copyout_right_align_to_halfword:
d572 1
a572 1
	br	copyout_right_aligned_to_halfword
d574 1
a574 1
	br.n	copyout_right_aligned_to_halfword
d578 1
a578 1
copyout_right_align_to_word:
d587 1
a587 1
	br	copyout_right_aligned_to_word
d589 1
a589 1
	br.n	copyout_right_aligned_to_word
d593 1
a593 1
copyout_right_align_to_doubleword:
d602 1
a602 1
	bcnd	ne0,  LEN, copyout_right_aligned_to_doubleword
d604 1
a604 1
	bcnd.n	ne0,  LEN, copyout_right_aligned_to_doubleword
d607 2
a608 2
	or	r2, r0, r0	/* successful return */
	br	.Lcodone
d610 1
a610 1
ASGLOBAL(copyout_byte_only)
d627 9
a635 2
2:	or	r2, r0, r0	/* successful return */
	br	.Lcodone
d637 3
a639 8
.Lcodone:
	or.u	r5,r0,hi16(_curpcb)
	ld	r6,r5,lo16(_curpcb)
	st	r0,r6,PCB_ONFAULT	/* clear the handler */
	jmp	r1
.Lcoflt:
	or	r2, r0, EFAULT	/* return fault */
	br	.Lcodone
d663 4
a666 4
	or.u	r6,   r0,   hi16(_curpcb)
	ld	r7,   r6,   lo16(_curpcb)
	or.u	r6,   r0,   hi16(.Lcosflt)
	or	r6,   r6,   lo16(.Lcosflt)
d668 2
a669 2
	bcnd	lt0,  CNT,   .Lcosflt
	bcnd	eq0,  CNT,   .Lcosdone
d686 9
a694 5
	or	r2,   r0, ENAMETOOLONG	/* over flow */
	br	.Lcosdone
2:   					/* all done */
	or	r2,   r0, 0
	br	.Lcosdone
d696 1
a696 5
.Lcosflt:
	or	r2, r0, EFAULT	/* return fault */
	br	.Lcosdone

.Lcosdone:
d699 4
a702 4
3:	or.u	r5,r0,hi16(_curpcb)
	ld	r6,r5,lo16(_curpcb)
	st	r0,r6,PCB_ONFAULT	/* clear the handler */
	jmp	r1
d717 6
a722 6
	or.u	r5,   r0,   hi16(_curpcb)
	ld	r6,   r5,   lo16(_curpcb)
	or.u	r5,   r0,   hi16(kcopy_fault)
	or	r5,   r5,   lo16(kcopy_fault)
	st	r5,   r6,   PCB_ONFAULT	/* pcb_onfault = kcopy_fault */
	bcnd	le0,r4,kcopy_out	/* nothing to do if count <= 0 */
d727 2
a728 2
	bb1	eq,r9,kcopy_out	/* nothing to do if addresses are equal */
	bb1	lo,r9,kcopy_reverse	/* copy in reverse if src < dest */
d733 1
a733 1
	bb1	lt,r9,kf_byte_copy	/* copy bytes for small data length */
d741 2
a742 2
	or.u	r12,r0,hi16(kf_strat)	/* forward strategy table address (high) */
	or	r12,r12,lo16(kf_strat)	/* forward strategy table address (low) */
d750 1
a750 1
ASGLOBAL(kf_3byte_word_copy)
d759 1
a759 1
	br.n	kf_word_copy	/* copy full words */
d765 1
a765 1
ASGLOBAL(kf_1half_word_copy)
d770 1
a770 1
	br.n	kf_word_copy	/* copy full words */
d776 1
a776 1
ASGLOBAL(kf_1byte_word_copy)
d786 1
a786 1
ASGLOBAL(kf_word_copy)
d788 1
a788 1
	bb1	lo,r10,kf_byte_copy 	/* not enough left, copy bytes */
d799 1
a799 1
	br.n	kf_word_copy	/* branch to copy another block */
d802 1
a802 1
ASGLOBAL(kf_1byte_half_copy)
d810 1
a810 1
ASGLOBAL(kf_half_copy)
d812 1
a812 1
	bb1	lo,r10,kf_byte_copy	/* not enough left, copy bytes */
d831 1
a831 1
	br.n	kf_half_copy	/* branch to copy another block */
d834 2
a835 2
ASGLOBAL(kf_byte_copy)
	bcnd	eq0,r4,kcopy_out	/* branch if nothing left to copy */
d840 1
a840 1
	br.n	kf_byte_copy	/* branch for next byte */
d846 1
a846 1
ASGLOBAL(kcopy_reverse)
d856 1
a856 1
	bb1	lt,r9,kr_byte_copy	/* copy bytes for small data length */
d864 2
a865 2
	or.u	r12,r0,hi16(kr_strat)	/* reverse strategy table address (high) */
	or	r12,r12,lo16(kr_strat)	/* reverse strategy table address (low) */
d873 1
a873 1
ASGLOBAL(kr_3byte_word_copy)
d882 1
a882 1
	br.n	kr_word_copy	/* copy full words */
d888 1
a888 1
ASGLOBAL(kr_1half_word_copy)
d893 1
a893 1
	br.n	kr_word_copy	/* copy full words */
d899 1
a899 1
ASGLOBAL(kr_1byte_word_copy)
d909 1
a909 1
ASGLOBAL(kr_word_copy)
d911 1
a911 1
	bb1	lo,r10,kr_byte_copy	/* not enough left, copy bytes */
d922 1
a922 1
	br.n	kr_word_copy	/* branch to copy another block */
d925 1
a925 1
ASGLOBAL(kr_1byte_half_copy)
d933 1
a933 1
ASGLOBAL(kr_half_copy)
d935 1
a935 1
	bb1	lo,r10,kr_byte_copy	/* not enough left, copy bytes */
d954 1
a954 1
	br.n	kr_half_copy	/* branch to copy another block */
d957 2
a958 2
ASGLOBAL(kr_byte_copy)
	bcnd	eq0,r4,kcopy_out	/* branch if nothing left to copy */
d963 1
a963 1
	br.n	kr_byte_copy	/* branch for next byte */
d966 1
a966 1
ASGLOBAL(kcopy_out)
d968 3
a970 3
ASGLOBAL(kcopy_out_fault)
	or.u	r5,r0,hi16(_curpcb)
	ld	r6,r5,lo16(_curpcb)
d974 1
a974 1
ASGLOBAL(kcopy_fault)
d976 1
a976 1
	br	kcopy_out_fault
d980 35
a1014 57
ASGLOBAL(kf_strat)
	word	kf_word_copy
	word	kf_byte_copy
	word	kf_half_copy
	word	kf_byte_copy
	word	kf_byte_copy
	word	kf_3byte_word_copy
	word	kf_byte_copy
	word	kf_1byte_half_copy
	word	kf_half_copy
	word	kf_byte_copy
	word	kf_1half_word_copy
	word	kf_byte_copy
	word	kf_byte_copy
	word	kf_1byte_half_copy
	word	kf_byte_copy
	word	kf_1byte_word_copy

ASGLOBAL(kr_strat)
	word	kr_word_copy
	word	kr_byte_copy
	word	kr_half_copy
	word	kr_byte_copy
	word	kr_byte_copy
	word	kr_1byte_word_copy
	word	kr_byte_copy
	word	kr_1byte_half_copy
	word	kr_half_copy
	word	kr_byte_copy
	word	kr_1half_word_copy
	word	kr_byte_copy
	word	kr_byte_copy
	word	kr_1byte_half_copy
	word	kr_byte_copy
	word	kr_3byte_word_copy

	text
#ifdef notyet  /* This give a stack problem.  For now, use the above */
ENTRY(kcopy)
	or.u	r5,   r0,   hi16(_curpcb)
	ld	r6,   r5,   lo16(_curpcb)
	or.u	r5,   r0,   hi16(kcfault)
	or	r5,   r5,   lo16(kcfault)
	st	r5,   r6,   PCB_ONFAULT	/* pcb_onfault = kcfault */
	subu	r31,  r31,  40
	bsr	_ovbcopy	/* call ovbcopy */
	addu	r31,  r31,  40
	or	r2,   r0,   0		/* return success */
kcdone:
	or.u	r5,r0,hi16(_curpcb)
	ld	r6,r5,lo16(_curpcb)
	st	r0,r6,PCB_ONFAULT	/* clear the handler */
	jmp	r1			/* return */
kcfault:
	or	r2,   r0,   EFAULT	/* return fault */
	br     kcdone
#endif /* 0 */
d1028 1
a1028 1
	br.n	_ovbcopy	/* call ovbcopy */
d1041 1
a1041 1
	bcnd	le0,r4,bcopy_out	/* nothing to do if count <= 0 */
d1046 2
a1047 2
	bb1	eq,r9,bcopy_out	/* nothing to do if addresses are equal */
	bb1	lo,r9,bcopy_reverse	/* copy in reverse if src < dest */
d1052 1
a1052 1
	bb1	lt,r9,f_byte_copy	/* copy bytes for small data length */
d1060 2
a1061 2
	or.u	r12,r0,hi16(f_strat)	 /* forward strategy table address (high) */
	or	r12,r12,lo16(f_strat)	 /* forward strategy table address (low) */
d1070 1
a1070 1
ASGLOBAL(f_3byte_word_copy)
d1079 1
a1079 1
	br.n	f_word_copy	/* copy full words */
d1085 1
a1085 1
ASGLOBAL(f_1half_word_copy)
d1090 1
a1090 1
	br.n	f_word_copy	/* copy full words */
d1096 1
a1096 1
ASGLOBAL(f_1byte_word_copy)
d1106 1
a1106 1
ASGLOBAL(f_word_copy)
d1108 1
a1108 1
	bb1	lo,r10,f_byte_copy	/* not enough left, copy bytes */
d1119 1
a1119 1
	br.n	f_word_copy	/* branch to copy another block */
d1122 1
a1122 1
ASGLOBAL(f_1byte_half_copy)
d1130 1
a1130 1
ASGLOBAL(f_half_copy)
d1132 1
a1132 1
	bb1	lo,r10,f_byte_copy	/* not enough left, copy bytes */
d1151 1
a1151 1
	br.n	f_half_copy	/* branch to copy another block */
d1154 2
a1155 2
ASGLOBAL(f_byte_copy)
	bcnd	eq0,r4,bcopy_out	/* branch if nothing left to copy */
d1160 1
a1160 1
	br.n	f_byte_copy	/* branch for next byte */
d1166 1
a1166 1
ASGLOBAL(bcopy_reverse)
d1176 1
a1176 1
	bb1	lt,r9,r_byte_copy	/* copy bytes for small data length */
d1184 2
a1185 2
	or.u	r12,r0,hi16(r_strat)	/* reverse strategy table address (high) */
	or	r12,r12,lo16(r_strat)	/* reverse strategy table address (low) */
d1193 1
a1193 1
ASGLOBAL(r_3byte_word_copy)
d1202 1
a1202 1
	br.n	r_word_copy	/* copy full words */
d1208 1
a1208 1
ASGLOBAL(r_1half_word_copy)
d1213 1
a1213 1
	br.n	r_word_copy	/* copy full words */
d1219 1
a1219 1
ASGLOBAL(r_1byte_word_copy)
d1229 1
a1229 1
ASGLOBAL(r_word_copy)
d1231 1
a1231 1
	bb1	lo,r10,r_byte_copy	/* not enough left, copy bytes */
d1242 1
a1242 1
	br.n	r_word_copy	/* branch to copy another block */
d1245 1
a1245 1
ASGLOBAL(r_1byte_half_copy)
d1253 1
a1253 1
ASGLOBAL(r_half_copy)
d1255 1
a1255 1
	bb1	lo,r10,r_byte_copy	/* not enough left, copy bytes */
d1274 1
a1274 1
	br.n	r_half_copy	/* branch to copy another block */
d1277 2
a1278 2
ASGLOBAL(r_byte_copy)
	bcnd	eq0,r4,bcopy_out	/* branch if nothing left to copy */
d1283 1
a1283 1
	br.n	r_byte_copy	/* branch for next byte */
d1286 1
a1286 1
ASGLOBAL(bcopy_out)
d1291 35
a1325 35
ASGLOBAL(f_strat)
	word	f_word_copy
	word	f_byte_copy
	word	f_half_copy
	word	f_byte_copy
	word	f_byte_copy
	word	f_3byte_word_copy
	word	f_byte_copy
	word	f_1byte_half_copy
	word	f_half_copy
	word	f_byte_copy
	word	f_1half_word_copy
	word	f_byte_copy
	word	f_byte_copy
	word	f_1byte_half_copy
	word	f_byte_copy
	word	f_1byte_word_copy

ASGLOBAL(r_strat)
	word	r_word_copy
	word	r_byte_copy
	word	r_half_copy
	word	r_byte_copy
	word	r_byte_copy
	word	r_1byte_word_copy
	word	r_byte_copy
	word	r_1byte_half_copy
	word	r_half_copy
	word	r_byte_copy
	word	r_1half_word_copy
	word	r_byte_copy
	word	r_byte_copy
	word	r_1byte_half_copy
	word	r_byte_copy
	word	r_3byte_word_copy
a1349 2

ENTRY(blkclr)
d1359 2
a1360 2
	bb1	0, R_dest, not_initially_word_aligned
	bb1	1, R_dest, not_initially_word_aligned
d1362 1
a1362 1
   now_word_aligned:
d1367 2
a1368 2
	or.u	R_mark_address, r0, hi16(mark)
	or	R_mark_address, R_mark_address, lo16(mark)
d1370 1
a1370 1
   top_of_main_loop:
d1388 1
a1388 1
	bcnd	eq0, R_bytes, done_doing_words
d1409 1
a1409 2
     1:

d1422 2
a1423 1
do_max:  subu	R_len, R_len, R_bytes	/* NOTE: this is in the delay slot! */
d1458 2
a1459 2
mark:
	br.n	top_of_main_loop
d1462 2
a1463 2
done_doing_words:
	bcnd	ne0, R_len, finish_up_last_bytes
d1466 1
a1466 1
finish_up_last_bytes:
d1468 1
a1468 1
	bcnd.n	ne0, R_len, finish_up_last_bytes
d1470 1
a1470 2

leave:
d1473 1
a1473 1
not_initially_word_aligned:
d1477 1
a1477 1
	bcnd	eq0, R_len, leave
d1481 1
a1481 1
	bcnd.n	eq0, R_temp, now_word_aligned
d1483 1
a1483 1
	br	not_initially_word_aligned
d1498 1
a1498 2
	global _setjmp
_setjmp:
d1521 1
a1521 2
	global	_longjmp
_longjmp:
a1543 30
ENTRY(longjmp_int_enable)
	ld	r1,r2,0
	ld	r14,r2,4
	ld	r15,r2,2*4
	ld	r16,r2,3*4
	ld	r17,r2,4*4
	ld	r18,r2,5*4
	ld	r19,r2,6*4
	ld	r20,r2,7*4
	ld	r21,r2,8*4
	ld	r22,r2,9*4
	ld	r23,r2,10*4
	ld	r24,r2,11*4
	ld	r25,r2,12*4
	ld	r26,r2,13*4
	ld	r27,r2,14*4
	ld	r28,r2,15*4
	ld	r29,r2,16*4
	ld	r30,r2,17*4
	ld	r31,r2,18*4
	or	r2,r3,r0
	ldcr	r10,PSR
	clr	r10,r10,1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r10,PSR
	jmp	r1

ENTRY(getsp)
	or	r2, r0, r31
	jmp	r1

d1578 1
a1578 1
ENTRY(guarded_access_start)
d1585 1
a1585 1
	br	 _guarded_access_bad
d1602 1
a1602 1
ENTRY(guarded_access_bad)
d1604 1
a1604 1
	 or	 r2,r0,14
d1607 1
a1607 1
ENTRY(guarded_access_end)
d1647 6
a1652 6
	or.u	r2, r0, hi16(1f)
	bsr.n	_panic
	 or	r2, r2, lo16(1f)
1:	string "set_cpu_number: bad CPU number\0"
	align   4
	/* will not return */
@


1.21
log
@Remove fetch(9) and store(9) functions from the kernel, and replace the few
remaining instances of them with appropriate copy(9) usage.

ok art@@, tested on all arches unless my memory is non-ECC
@
text
@d1 1
a1 1
/* $OpenBSD: locore_asm_routines.S,v 1.20 2002/01/21 20:35:51 miod Exp $	*/
d172 1
a172 1
#if DDB
d174 4
a177 4
	ldcr	r2, PSR                   /* get the processor status word */
	set  	r3, r0, 1<PSR_INTERRUPT_DISABLE_BIT>   /* set mask */
	jmp.n 	r1                                     /* delayed return */
	and 	r2, r2, r3                             /* r2 = r3 & r2 */
d193 3
a195 3
#define SRC  	r2
#define DEST  	r3
#define LEN  	r4
d199 1
a199 1
	or.u	r5,   r0,   hi16(_curpcb)	
d204 8
a211 6
	
	/*bcnd	ne0,  LEN,  1f ; XXX optimize len = 0 case */
	/*;or	r2,   r0,   0 */
	/*;br	.Lcidone */
	/*;1: ;bcnd	lt0,  LEN,  .Lciflt ; EFAULT if len < 0  */
        
d238 1
a238 1
	or	r7,   r0,   4
d243 1
a243 1
	ld.usr 	r5,   SRC,  r0
d247 1
a247 1
	ld.usr  r6,   SRC,  r7
d252 2
a253 2
	ld.usr 	r5,   SRC,  r0
	ld.usr  r6,   SRC,  r7
d260 2
a261 2
	addu	DEST, DEST, 8
   	or	r2, r0, r0	/* successful return */
d264 1
a264 1
        /***************************************************/
d269 1
a269 1
	ld.b.usr r5,   SRC,  r0
d274 1
a274 1
	ld.b.usr r5,   SRC,  r0
d280 1
a280 1
	addu	DEST, DEST, 1
d285 1
a285 1
	ld.h.usr r5,   SRC,  r0
d290 1
a290 1
	ld.h.usr r5,   SRC,  r0
d292 1
a292 1
	subu    LEN,  LEN,  2
d296 1
a296 1
	addu	DEST, DEST, 2
d302 1
a302 1
	ld.b.usr r5,   SRC,  LEN
d307 1
a307 1
	ld.b.usr r5,   SRC,  LEN
d310 1
a310 1
	st.b	r5,   DEST, LEN
d316 1
a316 1
	ld.h.usr r5,   SRC,  LEN
d321 1
a321 1
	ld.h.usr r5,   SRC,  LEN
d324 1
a324 1
	st.h	r5,   DEST, LEN
d338 1
a338 1
	st	r5,   DEST, LEN
d344 1
a344 1
   1:
d348 1
a348 1
	ld.b.usr r5, SRC, LEN
d353 1
a353 1
	ld.b.usr r5, SRC, LEN
d356 2
a357 2
	st.b	r5, DEST, LEN
   2:	or	r2, r0, r0	/* successful return */
d368 3
a370 3
#undef SRC
#undef DEST
#undef LEN
d374 1
a374 1
/* 
d385 4
a388 4
#define SRC	r2
#define DEST	r3
#define CNT	r4
#define LEN	r5
d390 1
a390 1
ENTRY(copyinstr)                
d393 1
a393 1
	or.u	r6,   r0,   hi16(_curpcb)	
d404 1
a404 1
	ld.bu.usr  	r7,   SRC,  r6
d413 1
a413 1
	addu	r6,   r6, 1
d426 1
a426 1
	addu	r6,   r6, 1
d431 1
a431 1
        bcnd	eq0, LEN, 3f		
d442 4
a445 4
#undef SRC
#undef DEST
#undef CNT
#undef LEN
d455 3
a457 3
#define SRC  	r2
#define DEST  	r3
#define LEN  	r4
d461 5
a465 3
/*	tb0 0, r0, 132     entry trap */
/*	SET_PCB_ONFAULT(r5, r6, .Lcoflt)*/
	or.u	r5,   r0,   hi16(_curpcb)	
d470 6
a475 4
/*	;bcnd	ne0,  LEN,  1f ; XXX optimize len = 0 case */
/*	;or	r2,   r0,   0 */
/*	;br	.Lcodone */
    /*;1: ;bcnd	lt0,  LEN,  .Lcoflt ; EFAULT if len < 0  */
d477 2
a478 2
	cmp	r9,   LEN,  8 
	bb1	lt,   r9,   copyout_byte_only 
d481 3
a483 3
	xor	r9,   SRC,  DEST 
	mask	r8,   r9,   0x3 
	bcnd	ne0,  r8,   copyout_byte_only 
d504 1
a504 1
	or	r7,   r0,   4
d530 2
a531 2
	addu	DEST, DEST, 8
   	or	r2, r0, r0	/* successful return */
d536 1
a536 1
	ld.b   	r5,   SRC,  r0
d540 1
a540 1
	st.b.usr r5,   DEST, r0
d545 1
a545 1
	st.b.usr r5,   DEST, r0
d549 1
a549 1
	addu	DEST, DEST, 1
d552 2
a553 2
	ld.h   	r5,   SRC,  r0
	subu    LEN,  LEN,  2
d556 1
a556 1
	st.h.usr r5,   DEST, r0
d561 1
a561 1
	st.h.usr r5,   DEST, r0
d565 1
a565 1
	addu	DEST, DEST, 2
d569 1
a569 1
	ld.b   	r5,   SRC,  LEN
d571 2
a572 2
	NOP     
	st.b.usr r5,   DEST, LEN
d579 1
a579 1
	st.b.usr r5,   DEST, LEN
d584 1
a584 1
	ld.h   	r5,   SRC,  LEN
d586 2
a587 2
	NOP     
	st.h.usr r5,   DEST, LEN
d592 1
a592 1
#else           
d594 1
a594 1
	st.h.usr r5,   DEST, LEN
d609 1
a609 1
	st.usr	r5,   DEST, LEN
d611 1
a611 1
   	or	r2, r0, r0	/* successful return */
d616 1
a616 1
   1:
d618 1
a618 1
	ld.b   	r5, SRC, LEN
d621 1
a621 1
	st.b.usr r5, DEST, LEN
d628 1
a628 1
	st.b.usr r5, DEST, LEN
d631 1
a631 1
   2:	or	r2, r0, r0	/* successful return */
d643 3
a645 3
#undef SRC
#undef DEST
#undef LEN
d647 1
a647 1
/* 
d658 4
a661 4
#define SRC	r2
#define DEST	r3
#define CNT	r4
#define LEN	r5
d665 1
a665 1
	or.u	r6,   r0,   hi16(_curpcb)	
d673 1
a673 1
   1:	
d677 1
a677 1
	st.b.usr r7,   DEST,  r6
d682 1
a682 1
	st.b.usr r7,   DEST,  r6
d685 1
a685 1
	addu	r6,   r6, 1
d690 1
a690 1
   2:   					/* all done */
d699 1
a699 1
        bcnd	eq0, LEN, 3f		
d701 1
a701 1
   3:	or.u	r5,r0,hi16(_curpcb)
d706 4
a709 4
#undef SRC
#undef DEST
#undef CNT
#undef LEN
d719 1
a719 1
	or.u	r5,   r0,   hi16(_curpcb)	
d724 1
a724 1
	bcnd	le0,r4,kcopy_out /* nothing to do if count <= 0 */
d729 2
a730 2
	bb1	eq,r9,kcopy_out	/* nothing to do if addresses are equal */	
	bb1	lo,r9,kcopy_reverse /* copy in reverse if src < destination */ 
d732 1
a732 1
 *	source address is greater than destination address, copy forward 
d735 1
a735 1
	bb1	lt,r9,kf_byte_copy /* copy bytes for small data length */ 
d743 2
a744 2
	or.u	r12,r0,hi16(kf_strat) /* forward strategy table address (high) */
	or	r12,r12,lo16(kf_strat) /* forward strategy table address (low) */
d762 1
a762 1
	subu	r4,r4,3		/* decrement length */
d773 1
a773 1
	subu	r4,r4,2		/* decrement remaining length */
d775 1
a775 1
/* 
d787 1
a787 1
 */	
d789 1
a789 1
	cmp	r10,r4,16	/* see if we have 16 bytes remaining */	
d802 2
a803 2
	subu	r4,r4,16	/* decrement remaining length */
	
d813 2
a814 2
	cmp	r10,r4,16	/* see if we have 16 bytes remaining */	
	bb1	lo,r10,kf_byte_copy /* not enough left, copy bytes */
d834 2
a835 2
	subu	r4,r4,16	/* decrement remaining length */
	
d837 1
a837 1
	bcnd	eq0,r4,kcopy_out /* branch if nothing left to copy */ 
d842 2
a843 2
	br.n	kf_byte_copy	/* branch for next byte */ 
	subu	r4,r4,1		/* decrement remaining length */
d850 1
a850 1
 * start copy pointers at end of data 
d858 1
a858 1
	bb1	lt,r9,kr_byte_copy /* copy bytes for small data length */ 
d866 2
a867 2
	or.u	r12,r0,hi16(kr_strat) /* reverse strategy table address (high) */
	or	r12,r12,lo16(kr_strat) /* reverse strategy table address (low) */
d885 1
a885 1
	subu	r4,r4,3		/* decrement length */
d896 1
a896 1
	subu	r4,r4,2		/* decrement remaining length */
d898 1
a898 1
/* 
d910 1
a910 1
 */	
d912 2
a913 2
	cmp	r10,r4,16	/* see if we have 16 bytes remaining */	
	bb1	lo,r10,kr_byte_copy 	/* not enough left, copy bytes */
d925 2
a926 2
	subu	r4,r4,16	/* decrement remaining length */
	
d936 2
a937 2
	cmp	r10,r4,16	/* see if we have 16 bytes remaining */	
	bb1	lo,r10,kr_byte_copy /* not enough left, copy bytes */
d957 2
a958 2
	subu	r4,r4,16	/* decrement remaining length */
	
d960 1
a960 1
	bcnd	eq0,r4,kcopy_out /* branch if nothing left to copy */ 
d965 2
a966 2
	br.n	kr_byte_copy	/* branch for next byte */ 
	subu	r4,r4,1		/* decrement remaining length */
d970 1
a970 1
ASGLOBAL(kcopy_out_fault)	
d978 2
a979 2
	br     kcopy_out_fault
	
d1021 1
a1021 1
	or.u	r5,   r0,   hi16(_curpcb)	
d1027 1
a1027 1
	bsr	_ovbcopy      /* call ovbcopy */
d1041 3
a1043 3
 * Gcc 2 generates calls to memcpy for bcopies of unknown size. memcpy
 * can simply be implemented as ovbcopy but the src (r2, r3) and dst args need to
 * be switched. 
d1050 5
a1054 5
 	or 	r5, r0, r2    /* dst -> tmp */
	or	r2, r0, r3    /* src -> 1st arg */
	br.n	_ovbcopy      /* call ovbcopy */
       	or	r3, r0, r5    /* dst -> 2nd arg */
       
d1065 1
a1065 1
	bcnd	le0,r4,bcopy_out /* nothing to do if count <= 0 */
d1070 2
a1071 2
	bb1	eq,r9,bcopy_out	/* nothing to do if addresses are equal */	
	bb1	lo,r9,bcopy_reverse /* copy in reverse if src < destination */
d1073 1
a1073 1
 *	source address is greater than destination address, copy forward 
d1076 1
a1076 1
	bb1	lt,r9,f_byte_copy /* copy bytes for small data length */ 
d1084 2
a1085 2
	or.u	r12,r0,hi16(f_strat) /* forward strategy table address (high) */
	or	r12,r12,lo16(f_strat) /* forward strategy table address (low) */
d1104 1
a1104 1
	subu	r4,r4,3		/* decrement length */
d1115 1
a1115 1
	subu	r4,r4,2		/* decrement remaining length */
d1117 1
a1117 1
/* 
d1129 1
a1129 1
 */	
d1131 2
a1132 2
	cmp	r10,r4,16	/* see if we have 16 bytes remaining */	
	bb1	lo,r10,f_byte_copy 	/* not enough left, copy bytes */
d1144 2
a1145 2
	subu	r4,r4,16	/* decrement remaining length */
	
d1155 2
a1156 2
	cmp	r10,r4,16	/* see if we have 16 bytes remaining */	
	bb1	lo,r10,f_byte_copy /* not enough left, copy bytes */
d1176 2
a1177 2
	subu	r4,r4,16	/* decrement remaining length */
	
d1179 1
a1179 1
	bcnd	eq0,r4,bcopy_out /* branch if nothing left to copy */ 
d1184 2
a1185 2
	br.n	f_byte_copy	/* branch for next byte */ 
	subu	r4,r4,1		/* decrement remaining length */
d1192 1
a1192 1
 * start copy pointers at end of data 
d1200 1
a1200 1
	bb1	lt,r9,r_byte_copy /* copy bytes for small data length */ 
d1208 2
a1209 2
	or.u	r12,r0,hi16(r_strat) /* reverse strategy table address (high) */
	or	r12,r12,lo16(r_strat) /* reverse strategy table address (low) */
d1227 1
a1227 1
	subu	r4,r4,3		/* decrement length */
d1238 1
a1238 1
	subu	r4,r4,2		/* decrement remaining length */
d1240 1
a1240 1
/* 
d1252 1
a1252 1
 */	
d1254 2
a1255 2
	cmp	r10,r4,16	/* see if we have 16 bytes remaining */	
	bb1	lo,r10,r_byte_copy 	/* not enough left, copy bytes */
d1267 2
a1268 2
	subu	r4,r4,16	/* decrement remaining length */
	
d1278 2
a1279 2
	cmp	r10,r4,16	/* see if we have 16 bytes remaining */	
	bb1	lo,r10,r_byte_copy /* not enough left, copy bytes */
d1299 2
a1300 2
	subu	r4,r4,16	/* decrement remaining length */
	
d1302 1
a1302 1
	bcnd	eq0,r4,bcopy_out /* branch if nothing left to copy */ 
d1307 2
a1308 2
	br.n	r_byte_copy	/* branch for next byte */ 
	subu	r4,r4,1		/* decrement remaining length */
d1312 1
a1312 1
	
a1353 1
/*######################################################################*/
d1395 1
a1395 1
	
d1401 1
a1401 1
 	 *
d1433 2
a1434 2
	or	R_bytes, r0, MAX_AT_ONE_TIME
	
d1449 1
a1449 1
do_max: subu	R_len, R_len, R_bytes	/* NOTE: this is in the delay slot! */
d1484 1
a1484 1
   mark:
d1486 1
a1486 3
	addu	R_dest, R_dest, R_bytes	/* bump up the dest address */


d1488 1
a1488 1
   done_doing_words:
d1490 1
a1490 1
	jmp	r1		/* RETURN */
d1492 1
a1492 1
   finish_up_last_bytes:
d1495 1
a1495 1
	st.b	r0, R_dest, R_len
d1497 4
a1500 4
   leave:
	jmp	r1		/* RETURN */
	
   not_initially_word_aligned:
d1509 1
a1509 1
	subu	R_len, R_len, 1
d1512 7
a1518 11
#undef  R_dest
#undef  R_len
#undef  R_bytes
#undef  R_mark_address
#undef  R_addr
#undef  R_temp
#undef  MAX_AT_ONE_TIME

/**********************************************************************/
/**********************************************************************/
/**********************************************************************/
d1547 1
a1547 1
	or	r2,r0,r0
d1571 1
a1571 1
	or	r2,r0,1
d1611 5
a1615 5
        or      r3,r0,r0
        xmem    r3,r2,r0
	tb1     0,r0,0
        jmp.n   r1
        or      r2,r3,r0
d1617 1
a1617 1
#if DDB
d1619 1
a1619 1
        FLUSH_PIPELINE
d1621 1
a1621 1
#endif /* DDB */	
d1624 2
a1625 2
     	jmp.n	r1
	ldcr	r2, PID
d1663 1
a1663 1
	or	 r2,r0,14
d1668 1
a1668 1
	or	 r2,r0,0
d1670 14
a1683 19
/*************************************************************************
 *************************************************************************
 **
 ** void set_cpu_number(unsigned number);
 **
 ** Sets the kernel cpu number for this cpu to the given value.
 **
 ** Input:
 **	r1	return address
 **	r2 	the number (should be 0, 1, 2, or 3).
 **
 ** Other registers used:
 **	r3	temp
 **	r4	original PSR
 **	r5	temporary new PSR
 **
 ** Output:
 **	none
 **/
d1700 1
a1700 1
	
d1705 1
a1705 1
1: /* bad cpu number*/
d1708 1
a1708 1
	or	r2, r2, lo16(1f)
a1711 1

@


1.20
log
@Argh, correctly handle the maxlen == 0 case.
@
text
@d1 1
a1 1
/* $OpenBSD: locore_asm_routines.S,v 1.18 2001/12/16 23:49:46 miod Exp $	*/
a182 175

/*
 * Fetch from user space
 * r2 == address in user space
 */

ENTRY(fuword)
ENTRY(fuiword)
	or.u	r5,   r0,   hi16(_curpcb)	
	ld	r6,   r5,   lo16(_curpcb)
	or.u	r5,   r0,   hi16(fusu_fault)
	or	r5,   r5,   lo16(fusu_fault)
	st	r5,   r6,   PCB_ONFAULT	/* pcb_onfault = fusu_fault */
#ifdef ERRATA__XXX_USR
	NOP
	ld.usr	r5,   r0,  r2
	NOP
	NOP
	NOP
#else
	ld.usr  r5,   r0,  r2
#endif
	or	r2,   r0,  r5
	br	fusu_ret
fusu_fault:
	subu	r2,   r0,  1	
fusu_ret:
	or.u	r5,   r0,   hi16(_curpcb)	
	ld	r6,   r5,   lo16(_curpcb)
	st	r0,   r6,   PCB_ONFAULT	/* pcb_onfault = 0 */

	jmp	r1
		
ENTRY(fusword)
	or.u	r5,   r0,   hi16(_curpcb)	
	ld	r6,   r5,   lo16(_curpcb)
	or.u	r5,   r0,   hi16(fusu_fault)
	or	r5,   r5,   lo16(fusu_fault)
	st	r5,   r6,   PCB_ONFAULT	/* pcb_onfault = fusu_fault */
#ifdef ERRATA__XXX_USR
	NOP
	ld.h.usr r5,   r0,  r2
	NOP
	NOP
	NOP
#else
	ld.h.usr r5,   r0,  r2
#endif
	or	r2,   r0,  r5
	br	fusu_ret
	
ENTRY(fubyte)
ENTRY(fuibyte)
	or.u	r5,   r0,   hi16(_curpcb)	
	ld	r6,   r5,   lo16(_curpcb)
	or.u	r5,   r0,   hi16(fusu_fault)
	or	r5,   r5,   lo16(fusu_fault)
	st	r5,   r6,   PCB_ONFAULT	/* pcb_onfault = fusu_fault */
#ifdef ERRATA__XXX_USR
	NOP
	ld.b.usr r5,   r0,  r2
	NOP
	NOP
	NOP
#else
	ld.b.usr r5,   r0,  r2
#endif
	or	r2,   r0,  r5
	br	fusu_ret

ENTRY(fuswintr)
	or.u	r5,   r0,   hi16(_curpcb)	
	ld	r6,   r5,   lo16(_curpcb)
	or.u	r5,   r0,   hi16(_fubail)
	or	r5,   r5,   lo16(_fubail)
	st	r5,   r6,   PCB_ONFAULT	/* pcb_onfault = fubail */
#ifdef ERRATA__XXX_USR
	NOP
	ld.h.usr r5,   r2, r0
	NOP
	NOP
	NOP
#else
	ld.h.usr r5,   r2, r0
#endif
	or	r2,   r0, r5
	br	fusu_ret

ENTRY(fubail)
	subu	r2,   r0, 1
	br	fusu_ret

/*
 * store to user space.
 * r2 == address in user space
 * r3 == byte/short/word
 */

ENTRY(suword)
ENTRY(suiword)
	or.u	r5,   r0,   hi16(_curpcb)	
	ld	r6,   r5,   lo16(_curpcb)
	or.u	r5,   r0,   hi16(fusu_fault)
	or	r5,   r5,   lo16(fusu_fault)
	st	r5,   r6,   PCB_ONFAULT	/* pcb_onfault = fusu_fault */
#ifdef ERRATA__XXX_USR
	NOP
	st.usr	r3,   r2, r0
	NOP
	NOP
	NOP
#else
	st.usr	r3,   r2, r0
#endif
	or	r2,   r0, r0		/* return success */
	br	fusu_ret

ENTRY(susword)
	or.u	r5,   r0,   hi16(_curpcb)	
	ld	r6,   r5,   lo16(_curpcb)
	or.u	r5,   r0,   hi16(fusu_fault)
	or	r5,   r5,   lo16(fusu_fault)
	st	r5,   r6,   PCB_ONFAULT	/* pcb_onfault = fusu_fault */
#ifdef ERRATA__XXX_USR
	NOP
	st.h.usr r3,   r2, r0
	NOP
	NOP
	NOP
#else
	st.h.usr r3,   r2, r0
#endif
	or	r2,   r0, r0		/* return success */
	br	fusu_ret

ENTRY(subyte)
ENTRY(suibyte)
	or.u	r5,   r0,   hi16(_curpcb)	
	ld	r6,   r5,   lo16(_curpcb)
	or.u	r5,   r0,   hi16(fusu_fault)
	or	r5,   r5,   lo16(fusu_fault)
	st	r5,   r6,   PCB_ONFAULT	/* pcb_onfault = fusu_fault */
#ifdef ERRATA__XXX_USR
	NOP
	st.b.usr r3,   r2, r0
	NOP
	NOP
	NOP
#else
	st.b.usr r3,   r2, r0
#endif
	or	r2,   r0, r0		/* return success */
	br	fusu_ret

ENTRY(suswintr)
	or.u	r5,   r0,   hi16(_curpcb)	
	ld	r6,   r5,   lo16(_curpcb)
	or.u	r5,   r0,   hi16(_subail)
	or	r5,   r5,   lo16(_subail)
	st	r5,   r6,   PCB_ONFAULT	/* pcb_onfault = subail */
#ifdef ERRATA__XXX_USR
	NOP
	st.h.usr r3,   r2, r0
	NOP
	NOP
	NOP
#else
	st.h.usr r3,   r2, r0
#endif
	or	r2,   r0, r0		/* return success */
	br	fusu_ret

ENTRY(subail)
	subu	r2,   r0, 1
	br	fusu_ret
@


1.19
log
@Always clear the destination string in copyinstr() on error, unless we faulted
when writing to the first character.
@
text
@d571 1
a573 1
	or	r6,   r0,   0
d594 2
d613 1
a613 2
	bcnd	eq0,r6, .Lcisdone	/* do not attempt to clear last byte */
	br	.Lcisnull		/* if we faulted on first write */
@


1.18
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d1 1
a1 1
/* $OpenBSD: locore_asm_routines.S,v 1.16 2001/08/24 22:53:15 miod Exp $	*/
d572 1
a572 1
	bcnd	eq0,  CNT,   .Lcisdone
d574 1
a574 1
   1:	
d584 1
a584 1
	st.b	r7,   DEST, r6
d589 10
a598 3
	or	r2,   r0, ENAMETOOLONG	/* over flow */
	br	.Lcisdone
   2:   					/* all done */
a599 1
	br	.Lcisdone
d604 2
a605 1
   3:	or.u	r5,r0,hi16(_curpcb)
d610 3
a612 2
	or	r2, r0, EFAULT	/* return fault */
	br	.Lcisdone
@


1.18.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/* $OpenBSD: locore_asm_routines.S,v 1.20 2002/01/21 20:35:51 miod Exp $	*/
d571 2
d574 1
a574 3
	bcnd	lt0,  CNT,   .Lcisflt
	bcnd	eq0,  CNT,   .Lcistoolong
1:
d584 1
a584 1
	st.b	r7, DEST, r6
d589 3
a591 12

.Lcistoolong:
	or	r2,   r0, ENAMETOOLONG	/* overflow */

.Lcisnull:
	bcnd	eq0,r6, .Lcisdone	/* do not attempt to clear last byte */
					/* if we did not write to the string */
	subu	r6,   r6, 1
	st.b	r0, DEST, r6		/* clear last byte */
	br.n	.Lcisdone
	addu	r6,   r6, 1
2:					/* all done */
d593 1
d598 1
a598 2
3:
	or.u	r5,r0,hi16(_curpcb)
d603 2
a604 2
	or	r2, r0, EFAULT		/* return fault */
	br	.Lcisnull
@


1.18.2.2
log
@sync
@
text
@d1 1
a1 1
/* $OpenBSD$	*/
d183 175
@


1.17
log
@Support for MVME197 completed.  Fix SPL defs.
@
text
@d32 3
d37 1
a37 1
#include <machine/param.h>
a38 1
#include <sys/errno.h>
a171 221
   .data

/*
 * reserve MAX_CPUS words for lockinit and lockeach;
 * counters for simple_lock_init calls and lock acquisition calls.
 */

lockinit:
   zero 4*MAX_CPUS

lockuse:
   zero 4*MAX_CPUS

lockpause:
   zero 4*MAX_CPUS

   .text

/*************************************************************************/
/******************  SIMPLE LOCK OPERATIONS  *****************************/
/*************************************************************************/

#ifdef done_in_kernel
/*************************************************************
 *************************************************************
 **
 **  	void simple_lock_init(int *lock_data)
 **	{
 **		*lock_data = 0;
 **	}
 **
 **  	void simple_unlock(simple_lock_t *)
 **	{
 **		*lock_data = 0;
 **	}
 **/
#undef simple_unlock
ENTRY(simple_lock_init)
	st      r0, r2, 0               /* init */
        
	ldcr	r2, SR1
	extu	r2, r2, FLAG_CPU_FIELD_WIDTH<0>	/* r2 = cpu# */
	mask  	r2, r2, 3			/* play it safe */
        or.u    r3, r0, hi16(lockinit)
        or      r3, r3, lo16(lockinit)
        ld      r4, r3[r2]
        addu    r4, r4, 1
        jmp.n   r1
        st      r4, r3[r2]
        
ENTRY(simple_unlock)
        jmp.n   r1
        st      r0, r2, 0

#if DDB
/* version of simple_unlock for the debugger - should be identical to
   simple_unlock, but should never have breakpoints inserted on it */
ENTRY(db_simple_unlock)
   jmp.n r1
   st    r0, r2, 0
#endif       

/**
 **     Simple_lock
 **
 **	Returns when the lock is taken. It also increments lockuse[cpu]
 **/
ENTRY(simple_lock)
   /* do r3 = test_and_set(r2, 1) */
   or    r3, r0, 1
   xmem  r3, r2, r0
   bcnd  ne0, r3, 1f
#if 0
   ldcr  r5, SR1
   extu  r5, r5, FLAG_CPU_FIELD_WIDTH<0>	/* r5 = cpu# */
   mask  r5, r5, 3				/* play it safe */
   or.u  r3, r0, hi16(lockuse)
   or    r3, r3, lo16(lockuse)
   ld    r4, r3[r5]
   addu  r4, r4, 1
   st    r4, r3[r5]
#endif
   jmp     r1
	
1:
	/* wait until the lock appears to be free */
   or.u  r4, r0, 0x0300
2:
   subu  r4, r4, 1
   bcnd  eq0, r4, _simple_lock_too_long
   ld    r3, r2, 0       /* check lock */
   bcnd  ne0, r3, 2b
   br    _simple_lock	/* looks free... check again with the xmem */

ENTRY(simple_lock_too_long)
#ifdef JEFF_DEBUG
	/* just want to break here.... */
   tb0   0, r0 , 0x84 /* gimmeabreak */
#else
	/* waited too long */
   subu  r31, r31, 0x40
   st    r1, r31, 0x30
   st    r30, r31, 0x34
   st    r2, r31, 0x38
   or    r3, r0, r1
#if 0
   bsr   _report_lock_info
#endif 
   ld    r2, r31, 0x38
   ld    r30, r31, 0x34
   ld    r1, r31, 0x30
   addu  r31, r31, 0x40
   br    _simple_lock
#endif /* JEFF_DEBUG */


#if DDB
/*
 * Version of simple_lock for the kernel debugger; should never have
 * breakpoints set on it. Should be kept consistent with simple_lock.
 */
ENTRY(db_simple_lock)
   /* do r10 = test_and_set(r2, 1) */
   or    r10, r0, 1
   xmem  r10, r2, r0
   bcnd  ne0, r10, db_simple_lock_watch
   
   ldcr  r2, SR1
   extu  r2, r2, FLAG_CPU_FIELD_WIDTH<0>	/* r2 = cpu# */
   mask  r2, r2, 3				/* play it safe */
   or.u  r3, r0, hi16(lockuse)
   or    r3, r3, lo16(lockuse)
   ld    r4, r3[r2]
   addu  r4, r4, 1
   jmp.n r1
   st    r4, r3[r2]
	
db_simple_lock_watch:
	/* wait until the lock appears to be free */
3:
   ld    r10, r2, 0
   bcnd  ne0, r10, 3b
   br    _db_simple_lock	/* looks free... check again with the xmem */
#endif /* DDB */

/*************************************************************
 *************************************************************
 **
 ** 	boolean_t simple_try_lock(simple_lock_t *);
 **
 **	Grab the lock if it's free.  Return zero if the lock was
 **	busy, non-zero if the lock has been taken.
 **/
ENTRY(simple_lock_try)
   or    r3, r0, 1	/* r3 := test_and_set(r2, 1) */
   xmem  r3, r2, r0
   /* If r3 is now zero, we hold the lock -- return non-zero.  */
   /* If r3 is now one,  we didn't get it -- return zero.	     */
   /* Thus, we want to "return(!r3)"			     */
   cmp   r4, r3, r0
   jmp.n r1
   extu  r2, r4, 1<2>

#if DDB
/* version for the kernel debugger - keep consistent with above */
ENTRY(db_simple_lock_try)
   or    r3, r0, 1	/* r3 := test_and_set(r2, 1) */
   xmem  r3, r2, r0
   /* If r3 is now zero, we hold the lock -- return non-zero.  */
   /* If r3 is now one,  we didn't get it -- return zero.	     */
   /* Thus, we want to "return(!r3)"			     */
   cmp   r4, r3, r0
   jmp.n r1
   extu  r2, r4, 1<2>
#endif

#if DDB  /* version for the debugger */
ENTRY(db_simple_lock_held)
   jmp.n r1
   ld    r2, r2, 0
#endif

/*
 * void simple_lock_pause(void). 
 *
 * This routine is called when we find a simple lock held that we wish to
 * acquire, but cannot spin on because we are holding a lock that is in the
 * wrong order to it with respect to the locking hierarchy. Once we drop the
 * lock we are holding, however, we cannot assume the lock we were trying to 
 * acquire is not deallocated. Consequently, we drop the lock we are holding 
 * and wait for a while, then retry. This is the wait for a while routine. 
 *
 * We define a array of counters[cpus], lockpause
 * to tell use how many times this routine is called.
 * We currently wait 128 cycles per call.
 */

ENTRY(simple_lock_pause)
	ldcr	r2, SR1
	extu	r2, r2, FLAG_CPU_FIELD_WIDTH<0>	/* r2 = cpu# */
	mask	r2, r2, 3				/* play it safe */
        or.u    r3, r0, hi16(lockpause)
        or      r3, r3, lo16(lockpause)
        ld      r4, r3[r2]
        or      r5, r0, 128                     /* initialize counters*/
1:      subu    r5, r5, 1                       /* count down */
        bcnd    ne0, r5, 1b
        addu    r4, r4, 1
	jmp.n	r1                              /* return*/
  	st	r4, r3[r2]

#endif /* done_in_kernel */

ENTRY(are_interrupts_disabled)
	ldcr	r2, PSR                   /* get the processor status word */
	set  	r3, r0, 1<PSR_INTERRUPT_DISABLE_BIT>   /* set mask */
	jmp.n 	r1                                     /* delayed return */
	and 	r2, r2, r3                            /* r2 = r3 & r2 */


/* version for the debugger */
d1549 1
a1549 1
now_word_aligned:
d1557 1
a1557 1
top_of_main_loop:
d1645 1
a1645 1
mark:
d1651 1
a1651 1
done_doing_words:
d1655 1
a1655 1
finish_up_last_bytes:
d1663 1
a1663 1
not_initially_word_aligned:
@


1.16
log
@Adapt to the <machine/asm.h> macros (only for entry points for now, because
LABEL has disappeared), and to the trap() name changes.
@
text
@d1 1
a1 1
/* $OpenBSD: locore_asm_routines.S,v 1.15 2001/06/27 04:29:19 art Exp $	*/
a31 3

#include <sys/errno.h>

d34 1
a34 1
#include <machine/cpu_number.h>
d36 1
d170 221
d1768 1
a1768 1
   now_word_aligned:
d1776 1
a1776 1
   top_of_main_loop:
d1864 1
a1864 1
   mark:
d1870 1
a1870 1
   done_doing_words:
d1874 1
a1874 1
   finish_up_last_bytes:
d1882 1
a1882 1
   not_initially_word_aligned:
@


1.15
log
@rip old vm
@
text
@d1 1
a1 1
/* $OpenBSD: locore_asm_routines.S,v 1.14 2001/05/20 05:53:09 miod Exp $	*/
a29 8
/* locore_asm_routines.c 
 *
 **********************************************************************
 * This file created by Omron Corporation, 1990.
 *
 * HISTORY
 *
 **************************************************************RCS*****/
d32 6
a38 4
#include <machine/cpu_number.h>
#include <machine/board.h>
#include <machine/asm.h>
#include <sys/errno.h>
d54 1
a54 1
#if  ERRATA__XXX_USR
d69 1
a69 1
#if  ERRATA__XXX_USR
d84 1
a84 1
#if  ERRATA__XXX_USR
d99 1
a99 1
#if  ERRATA__XXX_USR
d114 1
a114 1
#if  ERRATA__XXX_USR
d129 1
a129 1
#if  ERRATA__XXX_USR
d144 1
a144 1
#if  ERRATA__XXX_USR
d159 1
a159 1
#if  ERRATA__XXX_USR
a171 163
   .data

/*
 * reserve MAX_CPUS words for lockinit and lockeach;
 * counters for simple_lock_init calls and lock acquisition calls.
 */

LABEL(lockinit)
   zero 4*MAX_CPUS

LABEL(lockuse)
   zero 4*MAX_CPUS

LABEL(lockpause)
   zero 4*MAX_CPUS

   .text

/*************************************************************************/
/******************  SIMPLE LOCK OPERATIONS  *****************************/
/*************************************************************************/

#ifdef done_in_kernel
/*************************************************************
 *************************************************************
 **
 **  	void simple_lock_init(int *lock_data)
 **	{
 **		*lock_data = 0;
 **	}
 **
 **  	void simple_unlock(simple_lock_t *)
 **	{
 **		*lock_data = 0;
 **	}
 **/
#undef simple_unlock
ENTRY(simple_lock_init)
	st      r0, r2, 0               /* init */
        
	ldcr	r2, SR1
	extu	r2, r2, FLAG_CPU_FIELD_WIDTH<0>	/* r2 = cpu# */
	mask  	r2, r2, 3			/* play it safe */
        or.u    r3, r0, hi16(lockinit)
        or      r3, r3, lo16(lockinit)
        ld      r4, r3[r2]
        addu    r4, r4, 1
        jmp.n   r1
        st      r4, r3[r2]
        
ENTRY(simple_unlock)
        jmp.n   r1
        st      r0, r2, 0

#if DDB
/* version of simple_unlock for the debugger - should be identical to
   simple_unlock, but should never have breakpoints inserted on it */
ENTRY(db_simple_unlock)
   jmp.n r1
   st    r0, r2, 0
#endif       

/**
 **     Simple_lock
 **
 **	Returns when the lock is taken. It also increments lockuse[cpu]
 **/
ENTRY(simple_lock)
   /* do r3 = test_and_set(r2, 1) */
   or    r3, r0, 1
   xmem  r3, r2, r0
   bcnd  ne0, r3, 1f
#if 0
   ldcr  r5, SR1
   extu  r5, r5, FLAG_CPU_FIELD_WIDTH<0>	/* r5 = cpu# */
   mask  r5, r5, 3				/* play it safe */
   or.u  r3, r0, hi16(lockuse)
   or    r3, r3, lo16(lockuse)
   ld    r4, r3[r5]
   addu  r4, r4, 1
   st    r4, r3[r5]
#endif
   jmp     r1
	
1:
	/* wait until the lock appears to be free */
   or.u  r4, r0, 0x0300
2:
   subu  r4, r4, 1
   bcnd  eq0, r4, _simple_lock_too_long
   ld    r3, r2, 0       /* check lock */
   bcnd  ne0, r3, 2b
   br    _simple_lock	/* looks free... check again with the xmem */

ENTRY(simple_lock_too_long)
#ifdef JEFF_DEBUG
	/* just want to break here.... */
   tb0   0, r0 , 0x84 /* gimmeabreak */
#else
	/* waited too long */
   subu  r31, r31, 0x40
   st    r1, r31, 0x30
   st    r30, r31, 0x34
   st    r2, r31, 0x38
   or    r3, r0, r1
#if 0
   bsr   _report_lock_info
#endif 
   ld    r2, r31, 0x38
   ld    r30, r31, 0x34
   ld    r1, r31, 0x30
   addu  r31, r31, 0x40
   br    _simple_lock
#endif /* JEFF_DEBUG */


#if DDB
/*
 * Version of simple_lock for the kernel debugger; should never have
 * breakpoints set on it. Should be kept consistent with simple_lock.
 */
ENTRY(db_simple_lock)
   /* do r10 = test_and_set(r2, 1) */
   or    r10, r0, 1
   xmem  r10, r2, r0
   bcnd  ne0, r10, db_simple_lock_watch
   
   ldcr  r2, SR1
   extu  r2, r2, FLAG_CPU_FIELD_WIDTH<0>	/* r2 = cpu# */
   mask  r2, r2, 3				/* play it safe */
   or.u  r3, r0, hi16(lockuse)
   or    r3, r3, lo16(lockuse)
   ld    r4, r3[r2]
   addu  r4, r4, 1
   jmp.n r1
   st    r4, r3[r2]
	
db_simple_lock_watch:
	/* wait until the lock appears to be free */
3:
   ld    r10, r2, 0
   bcnd  ne0, r10, 3b
   br    _db_simple_lock	/* looks free... check again with the xmem */
#endif /* DDB */

/*************************************************************
 *************************************************************
 **
 ** 	boolean_t simple_try_lock(simple_lock_t *);
 **
 **	Grab the lock if it's free.  Return zero if the lock was
 **	busy, non-zero if the lock has been taken.
 **/
ENTRY(simple_lock_try)
   or    r3, r0, 1	/* r3 := test_and_set(r2, 1) */
   xmem  r3, r2, r0
   /* If r3 is now zero, we hold the lock -- return non-zero.  */
   /* If r3 is now one,  we didn't get it -- return zero.	     */
   /* Thus, we want to "return(!r3)"			     */
   cmp   r4, r3, r0
   jmp.n r1
   extu  r2, r4, 1<2>

a172 143
/* version for the kernel debugger - keep consistent with above */
ENTRY(db_simple_lock_try)
   or    r3, r0, 1	/* r3 := test_and_set(r2, 1) */
   xmem  r3, r2, r0
   /* If r3 is now zero, we hold the lock -- return non-zero.  */
   /* If r3 is now one,  we didn't get it -- return zero.	     */
   /* Thus, we want to "return(!r3)"			     */
   cmp   r4, r3, r0
   jmp.n r1
   extu  r2, r4, 1<2>
#endif

#if DDB  /* version for the debugger */
ENTRY(db_simple_lock_held)
   jmp.n r1
   ld    r2, r2, 0
#endif

/*
 * void simple_lock_pause(void). 
 *
 * This routine is called when we find a simple lock held that we wish to
 * acquire, but cannot spin on because we are holding a lock that is in the
 * wrong order to it with respect to the locking hierarchy. Once we drop the
 * lock we are holding, however, we cannot assume the lock we were trying to 
 * acquire is not deallocated. Consequently, we drop the lock we are holding 
 * and wait for a while, then retry. This is the wait for a while routine. 
 *
 * We define a array of counters[cpus], lockpause
 * to tell use how many times this routine is called.
 * We currently wait 128 cycles per call.
 */

ENTRY(simple_lock_pause)
	ldcr	r2, SR1
	extu	r2, r2, FLAG_CPU_FIELD_WIDTH<0>	/* r2 = cpu# */
	mask	r2, r2, 3				/* play it safe */
        or.u    r3, r0, hi16(lockpause)
        or      r3, r3, lo16(lockpause)
        ld      r4, r3[r2]
        or      r5, r0, 128                     /* initialize counters*/
1:      subu    r5, r5, 1                       /* count down */
        bcnd    ne0, r5, 1b
        addu    r4, r4, 1
	jmp.n	r1                              /* return*/
  	st	r4, r3[r2]

#endif /* done_in_kernel */

#ifdef now_in_c
/*************************************************************************
 *************************************************************************
 **
 **	void get_psr(unsigned psr)
 **
 **	Enables processor interrupts (for the executing cpu).
 **/
#undef get_psr
ENTRY(get_psr)
	ldcr	r2, PSR
	jmp	r1

/*************************************************************************
 *************************************************************************
 **
 **	void set_psr(unsigned psr)
 **
 **	Enables processor interrupts (for the executing cpu).
 **/

#undef set_psr
ENTRY(set_psr)
	stcr	r2, PSR
        FLUSH_PIPELINE
	jmp	r1

/*************************************************************************
 *************************************************************************
 **
 **	void enable_interrupt(void)
 **
 **	Enables processor interrupts (for the executing cpu).
 **/
#undef enable_interrupt
ENTRY(enable_interrupt)
	ldcr	r2, PSR
	clr	r2, r2, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r2, PSR
        FLUSH_PIPELINE
	jmp	r1

#if DDB
/* a version of enable_interrupt for the debugger; should never
   have breakpoints set it in. Keep it consistent with enable
   interrupt above */
ENTRY(db_enable_interrupt)
	ldcr	r2, PSR
	clr	r2, r2, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r2, PSR
        FLUSH_PIPELINE
	jmp	r1
#endif /* DDB */

/*************************************************************************
 *************************************************************************
 **
 ** unsigned long disable_interrupt(void)
 **
 ** Disables processor interrupts (for the executing CPU) and returns
 ** the *previous* PSR.
 **
 **     if ((oldPSR & 0x02) == 0)
 **		interrupts_were_previously_on = 1;
 **/
#undef disable_interrupt
ENTRY(disable_interrupt)
	ldcr	r2, PSR
	set	r3, r2, 1<PSR_INTERRUPT_DISABLE_BIT>	 /* set disable bit*/
	stcr	r3, PSR
        FLUSH_PIPELINE
	jmp	r1

#if DDB
ENTRY(db_disable_interrupt)
	ldcr	r2, PSR
	set	r3, r2, 1<PSR_INTERRUPT_DISABLE_BIT>	 /* set disable bit*/
	stcr	r3, PSR
        FLUSH_PIPELINE
	jmp	r1
#endif /* DDB */

#endif /* now_in_c */

ENTRY(are_interrupts_disabled)
	ldcr	r2, PSR                   /* get the processor status word */
	set  	r3, r0, 1<PSR_INTERRUPT_DISABLE_BIT>   /* set mask */
	jmp.n 	r1                                     /* delayed return */
	and 	r2, r2, r3                            /* r2 = r3 & r2 */


/* version for the debugger */
#if DDB

d180 1
a180 1
LABEL(_FAULT_ERROR)
a183 2
/* LABEL(_ALLOW_FAULT_START) */

d196 1
a196 1
#if  ERRATA__XXX_USR
d222 1
a222 1
#if  ERRATA__XXX_USR
d241 1
a241 1
#if  ERRATA__XXX_USR
d259 1
a259 1
#if  ERRATA__XXX_USR
d288 1
a288 1
#if  ERRATA__XXX_USR
d306 1
a306 1
#if  ERRATA__XXX_USR
d325 1
a325 1
#if  ERRATA__XXX_USR
d343 1
a343 1
#if  ERRATA__XXX_USR
a358 34
#if 0
/*
 * copystr(fromaddr, toaddr, maxlength, &lencopied)
 *
 * Copy a null terminated string from one point to another in
 * the kernel address space.
 */
ENTRY(copystr)
	or	r6,r0,0
	bcnd	lt0,r4,Lcsflt1		/* negative count, error */
	bcnd	eq0,r4,Lcsdone		/* zero count, all done */
Lcsloop:
	ld	r8,r2,r6		/* copy a byte */
	st	r8,r3,r6		
	addu	r6,r6,1			/* bump the index */
	bcnd	eq0,r8,Lcsdone 		/* if null, done */
	subu	r4,r4,1			/* decrement count to copy */
	bcnd	ne0,r4,Lcsloop		/* if more to copy, loop */
	br	Lcsflt2 		/* ran out of room, error */
Lcsdone:
	bcnd	eq0, r5, Lcsret		/* if return len not desired, return */
	st	r6,r5,0			/* stash it */
Lcsret:
	or	r2,r0,0			/* good status */
	jmp	r1
Lcsflt1:
	or	r2,r0,EFAULT		/* return fault */
	br	Lcsdone
Lcsflt2:
	or	r2,r0,ENAMETOOLONG	/* ran out of space */
	br	Lcsdone	
Lcsdone:
	jmp	r1
#endif /* 0 */
d414 1
a414 1
#if  ERRATA__XXX_USR
d440 1
a440 1
#if  ERRATA__XXX_USR
d456 1
a456 1
#if  ERRATA__XXX_USR
d473 1
a473 1
#if  ERRATA__XXX_USR
d487 1
a487 1
#if  ERRATA__XXX_USR
d501 1
a501 1
#if  ERRATA__XXX_USR
d519 1
a519 1
#if  ERRATA__XXX_USR
d575 1
a575 1
#if  ERRATA__XXX_USR
d670 1
a670 1
#if  ERRATA__XXX_USR
d680 1
a680 1
#if  ERRATA__XXX_USR
d698 1
a698 1
#if  ERRATA__XXX_USR
d714 1
a714 1
#if  ERRATA__XXX_USR
d730 1
a730 1
#if  ERRATA__XXX_USR
d745 1
a745 1
#if  ERRATA__XXX_USR
d760 1
a760 1
#if  ERRATA__XXX_USR
d774 1
a774 1
_LABEL(copyout_byte_only)
d779 1
a779 1
#if  ERRATA__XXX_USR
d835 1
a835 1
#if  ERRATA__XXX_USR
a871 3
/*LABEL(_ALLOW_FAULT_END)*/
/*word 0	*/ /* to separate from routine below */
/*######################################################################*/
d912 1
a912 1
_LABEL(kf_3byte_word_copy)
d927 1
a927 1
_LABEL(kf_1half_word_copy)
d938 1
a938 1
_LABEL(kf_1byte_word_copy)
d948 1
a948 1
_LABEL(kf_word_copy)
d964 1
a964 1
_LABEL(kf_1byte_half_copy)
d972 1
a972 1
_LABEL(kf_half_copy)
d996 1
a996 1
_LABEL(kf_byte_copy)
d1008 1
a1008 1
_LABEL(kcopy_reverse)
d1035 1
a1035 1
_LABEL(kr_3byte_word_copy)
d1050 1
a1050 1
_LABEL(kr_1half_word_copy)
d1061 1
a1061 1
_LABEL(kr_1byte_word_copy)
d1071 1
a1071 1
_LABEL(kr_word_copy)
d1087 1
a1087 1
_LABEL(kr_1byte_half_copy)
d1095 1
a1095 1
_LABEL(kr_half_copy)
d1119 1
a1119 1
_LABEL(kr_byte_copy)
d1128 1
a1128 1
_LABEL(kcopy_out)
d1130 1
a1130 1
_LABEL(kcopy_out_fault)	
d1136 1
a1136 1
_LABEL(kcopy_fault)
d1142 1
a1142 1
_LABEL(kf_strat)
d1160 1
a1160 1
_LABEL(kr_strat)
d1254 1
a1254 1
_LABEL(f_3byte_word_copy)
d1269 1
a1269 1
_LABEL(f_1half_word_copy)
d1280 1
a1280 1
_LABEL(f_1byte_word_copy)
d1290 1
a1290 1
_LABEL(f_word_copy)
d1306 1
a1306 1
_LABEL(f_1byte_half_copy)
d1314 1
a1314 1
_LABEL(f_half_copy)
d1338 1
a1338 1
_LABEL(f_byte_copy)
d1350 1
a1350 1
_LABEL(bcopy_reverse)
d1377 1
a1377 1
_LABEL(r_3byte_word_copy)
d1392 1
a1392 1
_LABEL(r_1half_word_copy)
d1403 1
a1403 1
_LABEL(r_1byte_word_copy)
d1413 1
a1413 1
_LABEL(r_word_copy)
d1429 1
a1429 1
_LABEL(r_1byte_half_copy)
d1437 1
a1437 1
_LABEL(r_half_copy)
d1461 1
a1461 1
_LABEL(r_byte_copy)
d1470 1
a1470 1
_LABEL(bcopy_out)
d1475 1
a1475 1
_LABEL(f_strat)
d1493 1
a1493 1
_LABEL(r_strat)
a1783 255
#ifdef now_in_c
/*
 * This has to be cleaned - we should not use INT_MASK_LEVEL. Should
 * use pcc2_int_lvl instead. XXX nivas
 */
/*
 * I don't think we need to explictly enable interrupts. We can always enable
 * interrupts and depend on the int level and mask in PCC2 to block the
 * appropriate interrupts for us. If we don't depend on the PCC2 to block ints
 * for us, we need to explicitly set the IND bit in the PSR for every spln(x)
 * when x > 0. But for now... Rewrite the whole mess. XXX nivas
 * This is bogus - it is blocking interrupts for all but 0 XXX nivas
 */

ENTRY(spln)
	ldcr	r10,PSR
	or	r11,r0,r10
	or	r5,r2,r0 /* copy of r2 */
	bb1	PSR_INTERRUPT_DISABLE_BIT,r10,1f
	set	r10,r10,1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r10,PSR
        FLUSH_PIPELINE
    1:
#ifdef MVME188
	/* check if it's a mvme188 */
	or.u	r4, r0, hi16(_cputyp)
	ld	r3, r4, lo16(_cputyp)
	cmp	r4, r3, 0x188
	bb1	ne, r4, 2f
	or.u	r2, r0, hi16(IEN0_REG)
	or	r2, r2, lo16(IEN0_REG)
	bsr.n	_m188_get_mask
	subu	r31, r31, 40
	addu	r31, r31, 40
	or	r4,r2,r0 /* old mask in r4 */
	or	r3,r5,r0 /* new mask in r3 */
	or.u	r2, r0, hi16(IEN0_REG)
	or	r2, r2, lo16(IEN0_REG)
	bsr.n	_m188_set_mask
	subu	r31, r31, 40
	addu	r31, r31, 40
	or	r2,r4,r0 /* old mask in r2 */
	br	m188_spln_done
#endif /* MVME188 */    
    2:		
	or.u	r3,r0,hi16(INT_MASK_LEVEL)
	or	r3,r3,lo16(INT_MASK_LEVEL)
	xmem.bu	r2,r3,r0
m188_spln_done:
	bcnd	ne0, r5, 3f
	clr	r11, r11, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r11,PSR
        FLUSH_PIPELINE
    3:
	jmp	r1

ENTRY(getipl)
ENTRY(spl)
	ldcr	r10,PSR
	or	r11,r0,r10
	bb1	PSR_INTERRUPT_DISABLE_BIT, r10, 1f
	set	r10,r10,1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r10,PSR
        FLUSH_PIPELINE
      1:
#ifdef MVME188
	/* check if it's a mvme188 */
	or.u	r4, r0, hi16(_cputyp)
	ld	r3, r4, lo16(_cputyp)
	cmp	r4, r3, 0x188
	bb1	ne, r4, 2f
	/* get the current mask value mvme188 */
	or.u	r2, r0, hi16(IEN0_REG)
	or	r2, r2, lo16(IEN0_REG)
	bsr.n	_m188_get_mask
	subu	r31, r31, 40
	addu	r31, r31, 40
	
	br 	m188_spl_done
#endif	/* MVME188 */
      2:	
	/* get the current mask value mvme1x7 */
	or.u	r3,r0,hi16(INT_MASK_LEVEL)
	ld.b	r2,r3,lo16(INT_MASK_LEVEL)
m188_spl_done:	
	stcr	r11,PSR
        FLUSH_PIPELINE
	jmp	r1

/*
 *	Set the interrupt mask to the value passed in, returning the
 *	the current mask level. This routine does not enable/disable
 *	interrupts explicitly. It is assumed that the callers know what
 *	to do with interrupts.
 */
 
ENTRY(setipl)
	ldcr	r10,PSR
	or	r11,r0,r10
	bb1	PSR_INTERRUPT_DISABLE_BIT, r10, 1f
	set	r10,r10,1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r10,PSR 			/* disable ints, if needed */
   FLUSH_PIPELINE
1:
#ifdef MVME188
	/* check if it's a mvme188 */
	or.u	r4, r0, hi16(_cputyp)
	ld	r3, r4, lo16(_cputyp)
	cmp	r4, r3, 0x188
	bb1	ne, r4, 2f
	or	r3, r0, r2 			/* r3 now new mask value */
	/* get the current mask value mvme188 */
	or.u	r2,r0,hi16(IEN0_REG)
	or	r2,r2,lo16(IEN0_REG)
	bsr.n	_m188_get_mask
	subu	r31, r31, 40
	addu	r31, r31, 40
	or	r4, r0, r2 			/* r4 now current mask value */
	or.u	r2,r0,hi16(IEN0_REG)
	or	r2,r2,lo16(IEN0_REG)
	bsr.n	_m188_set_mask
	subu	r31, r31, 40
	addu	r31, r31, 40
	or	r2, r0, r4			/* r2 now the old value */
	br	m188_setipl_done     
#endif	/* MVME188 */
     2:	
	/* get the current mask value mvme1x7 */
	or.u	r3,r0,hi16(INT_MASK_LEVEL)
	or	r3,r3,lo16(INT_MASK_LEVEL)
	xmem.bu	r2,r3,r0			/* xchng the new mask value */
m188_setipl_done:
        FLUSH_PIPELINE
	stcr	r11,PSR				/* restore psr */
        FLUSH_PIPELINE
	jmp	r1				/* and return the old value */

#if DDB
ENTRY(db_spln)
	ldcr	r10,PSR
	or	r11,r0,r10
	or	r5,r2,r0 /* copy of r2 */
	bb1	PSR_INTERRUPT_DISABLE_BIT,r10,1f
	set	r10,r10,1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r10,PSR
        FLUSH_PIPELINE
    1:
#ifdef MVME188
	/* check if it's a mvme188 */
	or.u	r4, r0, hi16(_cputyp)
	ld	r3, r4, lo16(_cputyp)
	cmp	r4, r3, 0x188
	bb1	ne, r4, 2f
	or.u	r2,r0,hi16(IEN0_REG)
	or	r2,r2,lo16(IEN0_REG)
	bsr.n	_m188_get_mask
	subu	r31, r31, 40
	addu	r31, r31, 40
	or	r4,r2,r0 /* old mask in r4 */
	or	r3,r5,r0 /* new mask in r3 */
	or.u	r2,r0,hi16(IEN0_REG)
	or	r2,r2,lo16(IEN0_REG)
	bsr.n	_m188_set_mask
	subu	r31, r31, 40
	addu	r31, r31, 40
	or	r2,r4,r0 /* old mask in r2 */
	br	m188_db_spln_done
#endif /* MVME188 */    
    2:		
	or.u	r3,r0,hi16(INT_MASK_LEVEL)
	or	r3,r3,lo16(INT_MASK_LEVEL)
	xmem.bu	r2,r3,r0
m188_db_spln_done:
	bcnd	ne0, r5, 3f
	clr	r11, r11, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r11,PSR
        FLUSH_PIPELINE
    3:
	jmp	r1

ENTRY(db_getipl)
ENTRY(db_spl)
	ldcr	r10,PSR
	or	r11,r0,r10
	bb1	PSR_INTERRUPT_DISABLE_BIT, r10, 1f
	set	r10,r10,1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r10,PSR
        FLUSH_PIPELINE
      1:
#ifdef MVME188
	/* check if it's a mvme188 */
	or.u	r4, r0, hi16(_cputyp)
	ld	r3, r4, lo16(_cputyp)
	cmp	r4, r3, 0x188
	bb1	ne, r4, 2f
	/* get the current mask value mvme188 */
	or.u	r2,r0,hi16(IEN0_REG)
	or	r2,r2,lo16(IEN0_REG)
	bsr.n	_m188_get_mask
	subu	r31, r31, 40
	addu	r31, r31, 40
	br 	m188_db_spl_done
#endif /* MVME188 */      
      2:	
	/* get the current mask value mvme1x7 */
	or.u	r3,r0,hi16(INT_MASK_LEVEL)
	ld.b	r2,r3,lo16(INT_MASK_LEVEL)
m188_db_spl_done:	
	stcr	r11,PSR
        FLUSH_PIPELINE
	jmp	r1

ENTRY(db_setipl)
	ldcr	r10,PSR
	or	r11,r0,r10
	bb1	PSR_INTERRUPT_DISABLE_BIT, r10, 1f
	set	r10,r10,1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r10,PSR 			/* disable ints, if needed */
        FLUSH_PIPELINE
     1:
#ifdef MVME188
	/* check if it's a mvme188 */
	or.u	r4, r0, hi16(_cputyp)
	ld	r3, r4, lo16(_cputyp)
	cmp	r4, r3, 0x188
	bb1	ne, r4, 2f
	or	r3, r0, r2 			/* r3 now new mask value */
	/* get the current mask value mvme188 */
	or.u	r2,r0,hi16(IEN0_REG)
	or	r2,r2,lo16(IEN0_REG)
	bsr.n	_m188_get_mask
	subu	r31, r31, 40
	addu	r31, r31, 40
	or	r4, r0, r2 			/* r4 now current mask value */
	or.u	r2,r0,hi16(IEN0_REG)
	or	r2,r2,lo16(IEN0_REG)
	bsr.n	_m188_set_mask
	subu	r31, r31, 40
	addu	r31, r31, 40
	or	r2, r0, r4			/* r2 now the old value */
	br	m188_db_setipl_done     
#endif /* MVME188 */	
     2:	
	/* get the current mask value mvme1x7 */
	or.u	r3,r0,hi16(INT_MASK_LEVEL)
	or	r3,r3,lo16(INT_MASK_LEVEL)
	xmem.bu	r2,r3,r0			/* xchng the new mask value */
m188_db_setipl_done:
        FLUSH_PIPELINE
	stcr	r11,PSR				/* restore psr */
        FLUSH_PIPELINE
	jmp	r1				/* and return the old value */
#endif /* DDB */	
#endif /* now_in_c */

a1836 25
#if 0  /* There is an inline version of this in 
machine/cpu_number.h but it doesn't work right for some reason.
/*************************************************************************
 *************************************************************************
 **
 ** 	int cpu_number(void)
 **
 **	Returns the number of the current cpu. 
 **/
#undef cpu_number
ENTRY(cpu_number)
        or      r2, r0, r0                      /* clear return value */
#ifdef MVME188
	/* check if it's a mvme188 */
	or.u	r4, r0, hi16(_cputyp)
	ld	r3, r4, lo16(_cputyp)
	cmp	r4, r3, 0x188
	bb1	ne, r4, 1f
        ldcr    r2, SR1
#endif /* MVME188 */	
1:    
        jmp.n   r1
	extu	r2, r2, FLAG_CPU_FIELD_WIDTH<0>	/* r2 = cpu# */
#endif
	
@


1.14
log
@assym.s -> assym.h
@
text
@d1 1
a1 1
/* $OpenBSD: locore_asm_routines.S,v 1.13 2001/03/09 05:44:41 smurph Exp $	*/
a1223 1
#if defined(UVM)
a1549 1
#endif /* UVM */
@


1.13
log
@kernel will compile with -Werror.  Added intr.h
@
text
@d1 1
a1 1
/* $OpenBSD: locore_asm_routines.S,v 1.12 2001/03/08 22:25:06 miod Exp $	*/
d39 1
a39 5
#ifndef ASSEMBLER
#define	ASSEMBLER
#endif /* ASSEMBLER */

#include "assym.s"
@


1.12
log
@Define ff1() as a one-liner assembly inline, rather than a function in
locore_asm_routines.
@
text
@d1 1
a1 1
/* $OpenBSD: locore_asm_routines.S,v 1.11 2001/03/07 23:40:35 miod Exp $	*/
d38 4
@


1.11
log
@Get rid of definitions of ASSEMBLER, LOCORE and such. We will get
the correct defines from the Makefile now.
@
text
@d1 1
a1 1
/* $OpenBSD: locore_asm_routines.S,v 1.10 2001/02/01 03:38:20 smurph Exp $	*/
a176 5

ENTRY(ff1)
	jmp.n	r1
	ff1	r2, r2

@


1.10
log
@Major changes to get MVME188 working.  More header and code cleanups.  The
kernel is tested on MVME188A/2P256 and MVME188A/1P64.
@
text
@d1 1
a1 1
/* $OpenBSD: locore_asm_routines.S,v 1.9 2001/01/14 20:25:25 smurph Exp $	*/
a37 4

#ifndef ASSEMBLER
# define ASSEMBLER
#endif
@


1.9
log
@Complete move to UVM virtual memory system.  More header fixes.
@
text
@d1 1
a1 1
/* $OpenBSD: locore_asm_routines.S,v 1.8 2001/01/13 05:18:59 smurph Exp $	*/
d226 4
a229 3
        ldcr    r2, SR1                               /* extract cpu number*/
        clr     r2, r2, 0<FLAG_CPU_FIELD_WIDTH>
        mask    r2, r2, 3               /* play it safe */
d260 3
a262 3
   ldcr  r5, SR1                               /* extract cpu number */
   clr   r5, r5, 0<FLAG_CPU_FIELD_WIDTH>
   mask  r5, r5, 3               /* play it safe */
d313 4
a316 3
   ldcr  r2, SR1                               /* extract cpu number*/
   clr   r2, r2, 0<FLAG_CPU_FIELD_WIDTH>
   mask  r2, r2, 3               /* play it safe*/
d385 3
a387 3
        ldcr    r2, SR1                         /* extract cpu number*/
        clr     r2, r2, FLAG_CPU_FIELD_WIDTH
        mask    r2, r2, 3                       /* play it safe */
d1143 1
a1143 1
#   else
d1146 1
a1146 1
#   endif
d2476 1
a2476 1
        clr	r2, r2, 28<FLAG_CPU_FIELD_WIDTH>/* clears all but the CPU num */
d2519 1
a2519 1
     1: /* bad cpu number*/
d2523 1
a2523 1
	1: string "set_cpu_number: bad CPU number\0"
a2525 1

@


1.8
log
@Booting kernel with MACHINE_NEW_NONCONTIG.  UVM code added but not working.
New stand config.  Lots of header fixes.  Can now cross-compile i386->m88k.
@
text
@d1 1
a1 1
/* $OpenBSD: locore_asm_routines.S,v 1.7 1999/09/27 19:13:22 smurph Exp $	*/
d738 1
a738 1
    /*;1: ;bcnd		lt0,  LEN,  .Lciflt ; EFAULT if len < 0  */
d1240 302
a1543 1
	bsr.n	_ovbcopy      /* call ovbcopy */
d1545 3
a1548 1
	br	kcdone
d1557 1
a1573 1
	
d2174 1
d2176 2
a2177 1
	or	r2, r2, lo16(IEN0_REG)
d2181 1
d2183 2
a2184 1
	or	r2, r2, lo16(IEN0_REG)
d2217 1
d2219 3
a2221 1
	or	r2, r2, lo16(IEN0_REG)
d2257 1
d2259 2
a2260 1
	or	r2,r2,lo16(IEN0_REG)
d2263 1
d2265 2
a2266 1
	or	r2,r2,lo16(IEN0_REG)
d2298 1
d2300 2
a2301 1
	or	r2,r2,lo16(IEN0_REG)
d2305 1
d2307 2
a2308 1
	or	r2,r2,lo16(IEN0_REG)
d2341 1
d2343 2
a2344 1
	or	r2,r2,lo16(IEN0_REG)
d2373 1
d2375 2
a2376 1
	or	r2,r2,lo16(IEN0_REG)
d2379 1
d2381 2
a2382 1
	or	r2,r2,lo16(IEN0_REG)
d2521 1
a2521 1
	1: string "bad CPU number\0"
@


1.7
log
@Added to support MVME188 and MVME197
@
text
@d1 1
a1 1
/* $OpenBSD: locore_asm_routines.S,v 1.6 1999/02/09 06:36:28 smurph Exp $	*/
d1230 25
@


1.7.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/* $OpenBSD: locore_asm_routines.S,v 1.13 2001/03/09 05:44:41 smurph Exp $	*/
d40 2
a41 2
#define	ASSEMBLER
#endif /* ASSEMBLER */
d182 5
d226 3
a228 4
        
	ldcr	r2, SR1
	extu	r2, r2, FLAG_CPU_FIELD_WIDTH<0>	/* r2 = cpu# */
	mask  	r2, r2, 3			/* play it safe */
d259 3
a261 3
   ldcr  r5, SR1
   extu  r5, r5, FLAG_CPU_FIELD_WIDTH<0>	/* r5 = cpu# */
   mask  r5, r5, 3				/* play it safe */
d312 3
a314 4
   
   ldcr  r2, SR1
   extu  r2, r2, FLAG_CPU_FIELD_WIDTH<0>	/* r2 = cpu# */
   mask  r2, r2, 3				/* play it safe */
d383 3
a385 3
	ldcr	r2, SR1
	extu	r2, r2, FLAG_CPU_FIELD_WIDTH<0>	/* r2 = cpu# */
	mask	r2, r2, 3				/* play it safe */
d738 1
a738 1
	/*;1: ;bcnd	lt0,  LEN,  .Lciflt ; EFAULT if len < 0  */
d1141 1
a1141 1
#else
d1144 1
a1144 1
#endif
a1230 329
#if defined(UVM)
/*
 * kcopy(const void *src, void *dst, size_t len);
 *
 * Copy len bytes from src to dst, aborting if we encounter a page fault.
 */
ENTRY(kcopy)
	or.u	r5,   r0,   hi16(_curpcb)	
	ld	r6,   r5,   lo16(_curpcb)
	or.u	r5,   r0,   hi16(kcopy_fault)
	or	r5,   r5,   lo16(kcopy_fault)
	st	r5,   r6,   PCB_ONFAULT	/* pcb_onfault = kcopy_fault */
	bcnd	le0,r4,kcopy_out /* nothing to do if count <= 0 */
/*
 *	check position of source and destination data
 */
	cmp 	r9,r2,r3	/* compare source address to destination */
	bb1	eq,r9,kcopy_out	/* nothing to do if addresses are equal */	
	bb1	lo,r9,kcopy_reverse /* copy in reverse if src < destination */ 
/*
 *	source address is greater than destination address, copy forward 
 */
	cmp 	r9,r4,16	/* see if we have at least 16 bytes */
	bb1	lt,r9,kf_byte_copy /* copy bytes for small data length */ 
/*
 *	determine copy strategy based on alignment of source and destination
 */
	mask	r6,r2,3		/* get 2 low order bits of source address */
	mask	r7,r3,3		/* get 2 low order bits of destintation addr */
	mak	r6,r6,0<4>	/* convert source bits to table offset */
	mak	r7,r7,0<2>	/* convert destination bits to table offset */
	or.u	r12,r0,hi16(kf_strat) /* forward strategy table address (high) */
	or	r12,r12,lo16(kf_strat) /* forward strategy table address (low) */
	addu	r6,r6,r7	/* compute final table offset for strategy */
	ld	r12,r12,r6	/* load the strategy routine */
	jmp	r12		/* branch to strategy routine */

/*
 * Copy three bytes from src to destination then copy words
 */
_LABEL(kf_3byte_word_copy)
	ld.bu	r6,r2,0		/* load byte from source */
	ld.bu	r7,r2,1		/* load byte from source */
	ld.bu	r8,r2,2		/* load byte from source */
	st.b	r6,r3,0		/* store byte to destination */
	st.b	r7,r3,1		/* store byte to destination */
	st.b	r8,r3,2		/* store byte to destination */
	addu	r2,r2,3		/* increment source pointer */
	addu	r3,r3,3		/* increment destination pointer */
	br.n	kf_word_copy	/* copy full words */
	subu	r4,r4,3		/* decrement length */

/*
 * Copy 1 halfword from src to destination then copy words
 */
_LABEL(kf_1half_word_copy)
	ld.hu	r6,r2,0		/* load half-word from source */
	st.h	r6,r3,0		/* store half-word to destination */
	addu	r2,r2,2		/* increment source pointer */
	addu	r3,r3,2		/* increment destination pointer */
	br.n	kf_word_copy	/* copy full words */
	subu	r4,r4,2		/* decrement remaining length */

/* 
 * Copy 1 byte from src to destination then copy words
 */
_LABEL(kf_1byte_word_copy)
	ld.bu	r6,r2,0		/* load 1 byte from source */
	st.b	r6,r3,0		/* store 1 byte to destination */
	addu	r2,r2,1		/* increment source pointer */
	addu	r3,r3,1		/* increment destination pointer */
	subu	r4,r4,1		/* decrement remaining length */
	/* fall through to word copy */
/*
 * Copy as many full words as possible, 4 words per loop
 */	
_LABEL(kf_word_copy)
	cmp	r10,r4,16	/* see if we have 16 bytes remaining */	
	bb1	lo,r10,kf_byte_copy 	/* not enough left, copy bytes */
	ld	r6,r2,0		/* load first word */
	ld	r7,r2,4		/* load second word */
	ld	r8,r2,8		/* load third word */
	ld	r9,r2,12	/* load fourth word */
	st	r6,r3,0		/* store first word */
	st	r7,r3,4		/* store second word */
	st 	r8,r3,8		/* store third word */
	st 	r9,r3,12	/* store fourth word */
	addu	r2,r2,16	/* increment source pointer */
	addu	r3,r3,16	/* increment destination pointer */
	br.n	kf_word_copy	/* branch to copy another block */
	subu	r4,r4,16	/* decrement remaining length */
	
_LABEL(kf_1byte_half_copy)
	ld.bu	r6,r2,0		/* load 1 byte from source */
	st.b	r6,r3,0		/* store 1 byte to destination */
	addu	r2,r2,1		/* increment source pointer */
	addu	r3,r3,1		/* increment destination pointer */
	subu	r4,r4,1		/* decrement remaining length */
	/* fall through to half copy */

_LABEL(kf_half_copy)
	cmp	r10,r4,16	/* see if we have 16 bytes remaining */	
	bb1	lo,r10,kf_byte_copy /* not enough left, copy bytes */
	ld.hu	r6,r2,0		/* load first half-word */
	ld.hu	r7,r2,2		/* load second half-word */
	ld.hu	r8,r2,4		/* load third half-word */
	ld.hu	r9,r2,6		/* load fourth half-word */
	ld.hu	r10,r2,8	/* load fifth half-word */
	ld.hu	r11,r2,10	/* load sixth half-word */
	ld.hu	r12,r2,12	/* load seventh half-word */
	ld.hu	r13,r2,14	/* load eighth half-word */
	st.h	r6,r3,0		/* store first half-word */
	st.h	r7,r3,2		/* store second half-word */
	st.h 	r8,r3,4		/* store third half-word */
	st.h 	r9,r3,6		/* store fourth half-word */
	st.h	r10,r3,8	/* store fifth half-word */
	st.h	r11,r3,10	/* store sixth half-word */
	st.h 	r12,r3,12	/* store seventh half-word */
	st.h 	r13,r3,14	/* store eighth half-word */
	addu	r2,r2,16	/* increment source pointer */
	addu	r3,r3,16	/* increment destination pointer */
	br.n	kf_half_copy	/* branch to copy another block */
	subu	r4,r4,16	/* decrement remaining length */
	
_LABEL(kf_byte_copy)
	bcnd	eq0,r4,kcopy_out /* branch if nothing left to copy */ 
	ld.bu	r6,r2,0		/* load byte from source */
	st.b	r6,r3,0		/* store byte in destination */
	addu	r2,r2,1		/* increment source pointer */
	addu	r3,r3,1		/* increment destination pointer */
	br.n	kf_byte_copy	/* branch for next byte */ 
	subu	r4,r4,1		/* decrement remaining length */

/*
 *	source address is less than destination address, copy in reverse
 */
_LABEL(kcopy_reverse)
/*
 * start copy pointers at end of data 
 */
	addu	r2,r2,r4	/* start source at end of data */
	addu	r3,r3,r4	/* start destination at end of data */
/*
 * check for short data
 */
	cmp 	r9,r4,16	/* see if we have at least 16 bytes */
	bb1	lt,r9,kr_byte_copy /* copy bytes for small data length */ 
/*
 *	determine copy strategy based on alignment of source and destination
 */
	mask	r6,r2,3		/* get 2 low order bits of source address */
	mask	r7,r3,3		/* get 2 low order bits of destintation addr */
	mak	r6,r6,0<4>	/* convert source bits to table offset */
	mak	r7,r7,0<2>	/* convert destination bits to table offset */
	or.u	r12,r0,hi16(kr_strat) /* reverse strategy table address (high) */
	or	r12,r12,lo16(kr_strat) /* reverse strategy table address (low) */
	addu	r6,r6,r7	/* compute final table offset for strategy */
	ld	r12,r12,r6	/* load the strategy routine */
	jmp	r12		/* branch to strategy routine */

/*
 * Copy three bytes from src to destination then copy words
 */
_LABEL(kr_3byte_word_copy)
	subu	r2,r2,3		/* decrement source pointer */
	subu	r3,r3,3		/* decrement destination pointer */
	ld.bu	r6,r2,0		/* load byte from source */
	ld.bu	r7,r2,1		/* load byte from source */
	ld.bu	r8,r2,2		/* load byte from source */
	st.b	r6,r3,0		/* store byte to destination */
	st.b	r7,r3,1		/* store byte to destination */
	st.b	r8,r3,2		/* store byte to destination */
	br.n	kr_word_copy	/* copy full words */
	subu	r4,r4,3		/* decrement length */

/*
 * Copy 1 halfword from src to destination then copy words
 */
_LABEL(kr_1half_word_copy)
	subu	r2,r2,2		/* decrement source pointer */
	subu	r3,r3,2		/* decrement destination pointer */
	ld.hu	r6,r2,0		/* load half-word from source */
	st.h	r6,r3,0		/* store half-word to destination */
	br.n	kr_word_copy	/* copy full words */
	subu	r4,r4,2		/* decrement remaining length */

/* 
 * Copy 1 byte from src to destination then copy words
 */
_LABEL(kr_1byte_word_copy)
	subu	r2,r2,1		/* decrement source pointer */
	subu	r3,r3,1		/* decrement destination pointer */
	ld.bu	r6,r2,0		/* load 1 byte from source */
	st.b	r6,r3,0		/* store 1 byte to destination */
	subu	r4,r4,1		/* decrement remaining length */
	/* fall through to word copy */
/*
 * Copy as many full words as possible, 4 words per loop
 */	
_LABEL(kr_word_copy)
	cmp	r10,r4,16	/* see if we have 16 bytes remaining */	
	bb1	lo,r10,kr_byte_copy 	/* not enough left, copy bytes */
	subu	r2,r2,16	/* decrement source pointer */
	subu	r3,r3,16	/* decrement destination pointer */
	ld	r6,r2,0		/* load first word */
	ld	r7,r2,4		/* load second word */
	ld	r8,r2,8		/* load third word */
	ld	r9,r2,12	/* load fourth word */
	st	r6,r3,0		/* store first word */
	st	r7,r3,4		/* store second word */
	st 	r8,r3,8		/* store third word */
	st 	r9,r3,12	/* store fourth word */
	br.n	kr_word_copy	/* branch to copy another block */
	subu	r4,r4,16	/* decrement remaining length */
	
_LABEL(kr_1byte_half_copy)
	subu	r2,r2,1		/* decrement source pointer */
	subu	r3,r3,1		/* decrement destination pointer */
	ld.bu	r6,r2,0		/* load 1 byte from source */
	st.b	r6,r3,0		/* store 1 byte to destination */
	subu	r4,r4,1		/* decrement remaining length */
	/* fall through to half copy */

_LABEL(kr_half_copy)
	cmp	r10,r4,16	/* see if we have 16 bytes remaining */	
	bb1	lo,r10,kr_byte_copy /* not enough left, copy bytes */
	subu	r2,r2,16	/* decrement source pointer */
	subu	r3,r3,16	/* decrement destination pointer */
	ld.hu	r6,r2,0		/* load first half-word */
	ld.hu	r7,r2,2		/* load second half-word */
	ld.hu	r8,r2,4		/* load third half-word */
	ld.hu	r9,r2,6		/* load fourth half-word */
	ld.hu	r10,r2,8	/* load fifth half-word */
	ld.hu	r11,r2,10	/* load sixth half-word */
	ld.hu	r12,r2,12	/* load seventh half-word */
	ld.hu	r13,r2,14	/* load eighth half-word */
	st.h	r6,r3,0		/* store first half-word */
	st.h	r7,r3,2		/* store second half-word */
	st.h 	r8,r3,4		/* store third half-word */
	st.h 	r9,r3,6		/* store fourth half-word */
	st.h	r10,r3,8	/* store fifth half-word */
	st.h	r11,r3,10	/* store sixth half-word */
	st.h 	r12,r3,12	/* store seventh half-word */
	st.h 	r13,r3,14	/* store eighth half-word */
	br.n	kr_half_copy	/* branch to copy another block */
	subu	r4,r4,16	/* decrement remaining length */
	
_LABEL(kr_byte_copy)
	bcnd	eq0,r4,kcopy_out /* branch if nothing left to copy */ 
	subu	r2,r2,1		/* decrement source pointer */
	subu	r3,r3,1		/* decrement destination pointer */
	ld.bu	r6,r2,0		/* load byte from source */
	st.b	r6,r3,0		/* store byte in destination */
	br.n	kr_byte_copy	/* branch for next byte */ 
	subu	r4,r4,1		/* decrement remaining length */

_LABEL(kcopy_out)
	or	r2,   r0,   0		/* return success */
_LABEL(kcopy_out_fault)	
	or.u	r5,r0,hi16(_curpcb)
	ld	r6,r5,lo16(_curpcb)
	st	r0,r6,PCB_ONFAULT	/* clear the handler */
	jmp	r1		/* all done, return to caller */

_LABEL(kcopy_fault)
	or	r2,   r0,   EFAULT	/* return fault */
	br     kcopy_out_fault
	
	data
	align	4
_LABEL(kf_strat)
	word	kf_word_copy
	word	kf_byte_copy
	word	kf_half_copy
	word	kf_byte_copy
	word	kf_byte_copy
	word	kf_3byte_word_copy
	word	kf_byte_copy
	word	kf_1byte_half_copy
	word	kf_half_copy
	word	kf_byte_copy
	word	kf_1half_word_copy
	word	kf_byte_copy
	word	kf_byte_copy
	word	kf_1byte_half_copy
	word	kf_byte_copy
	word	kf_1byte_word_copy

_LABEL(kr_strat)
	word	kr_word_copy
	word	kr_byte_copy
	word	kr_half_copy
	word	kr_byte_copy
	word	kr_byte_copy
	word	kr_1byte_word_copy
	word	kr_byte_copy
	word	kr_1byte_half_copy
	word	kr_half_copy
	word	kr_byte_copy
	word	kr_1half_word_copy
	word	kr_byte_copy
	word	kr_byte_copy
	word	kr_1byte_half_copy
	word	kr_byte_copy
	word	kr_3byte_word_copy

	text
#ifdef notyet  /* This give a stack problem.  For now, use the above */
ENTRY(kcopy)
	or.u	r5,   r0,   hi16(_curpcb)	
	ld	r6,   r5,   lo16(_curpcb)
	or.u	r5,   r0,   hi16(kcfault)
	or	r5,   r5,   lo16(kcfault)
	st	r5,   r6,   PCB_ONFAULT	/* pcb_onfault = kcfault */
	subu	r31,  r31,  40
	bsr	_ovbcopy      /* call ovbcopy */
	addu	r31,  r31,  40
	or	r2,   r0,   0		/* return success */
kcdone:
	or.u	r5,r0,hi16(_curpcb)
	ld	r6,r5,lo16(_curpcb)
	st	r0,r6,PCB_ONFAULT	/* clear the handler */
	jmp	r1			/* return */
kcfault:
	or	r2,   r0,   EFAULT	/* return fault */
	br     kcdone
#endif /* 0 */
#endif /* UVM */

d1245 1
d1846 1
a1847 3
	bsr.n	_m188_get_mask
	subu	r31, r31, 40
	addu	r31, r31, 40
d1851 1
a1852 3
	bsr.n	_m188_set_mask
	subu	r31, r31, 40
	addu	r31, r31, 40
d1885 1
a1886 4
	bsr.n	_m188_get_mask
	subu	r31, r31, 40
	addu	r31, r31, 40
	
d1922 1
a1923 3
	bsr.n	_m188_get_mask
	subu	r31, r31, 40
	addu	r31, r31, 40
d1926 1
a1927 3
	bsr.n	_m188_set_mask
	subu	r31, r31, 40
	addu	r31, r31, 40
d1959 1
a1960 3
	bsr.n	_m188_get_mask
	subu	r31, r31, 40
	addu	r31, r31, 40
d1964 1
a1965 3
	bsr.n	_m188_set_mask
	subu	r31, r31, 40
	addu	r31, r31, 40
d1998 1
a1999 3
	bsr.n	_m188_get_mask
	subu	r31, r31, 40
	addu	r31, r31, 40
d2028 1
a2029 3
	bsr.n	_m188_get_mask
	subu	r31, r31, 40
	addu	r31, r31, 40
d2032 1
a2033 3
	bsr.n	_m188_set_mask
	subu	r31, r31, 40
	addu	r31, r31, 40
d2125 1
a2125 1
	extu	r2, r2, FLAG_CPU_FIELD_WIDTH<0>	/* r2 = cpu# */
d2168 1
a2168 1
1: /* bad cpu number*/
d2172 1
a2172 1
1:	string "set_cpu_number: bad CPU number\0"
d2175 1
@


1.7.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/* $OpenBSD: locore_asm_routines.S,v 1.7.4.1 2001/04/18 16:11:34 niklas Exp $	*/
d39 5
a43 1
#include "assym.h"
d1228 1
d1555 1
@


1.7.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/* $OpenBSD: locore_asm_routines.S,v 1.7.4.2 2001/07/04 10:20:13 niklas Exp $	*/
d30 8
d40 4
a43 1

a45 5
#include <machine/asm.h>
#include <machine/board.h>
#include <machine/cpu_number.h>
#include <machine/trap.h>

d60 1
a60 1
#ifdef ERRATA__XXX_USR
d75 1
a75 1
#ifdef ERRATA__XXX_USR
d90 1
a90 1
#ifdef ERRATA__XXX_USR
d105 1
a105 1
#ifdef ERRATA__XXX_USR
d120 1
a120 1
#ifdef ERRATA__XXX_USR
d135 1
a135 1
#ifdef ERRATA__XXX_USR
d150 1
a150 1
#ifdef ERRATA__XXX_USR
d165 1
a165 1
#ifdef ERRATA__XXX_USR
d178 163
d342 143
d492 1
a492 1
GLOBAL(FAULT_ERROR)
d496 2
d510 1
a510 1
#ifdef ERRATA__XXX_USR
d536 1
a536 1
#ifdef ERRATA__XXX_USR
d555 1
a555 1
#ifdef ERRATA__XXX_USR
d573 1
a573 1
#ifdef ERRATA__XXX_USR
d602 1
a602 1
#ifdef ERRATA__XXX_USR
d620 1
a620 1
#ifdef ERRATA__XXX_USR
d639 1
a639 1
#ifdef ERRATA__XXX_USR
d657 1
a657 1
#ifdef ERRATA__XXX_USR
d673 34
d762 1
a762 1
#ifdef ERRATA__XXX_USR
d788 1
a788 1
#ifdef ERRATA__XXX_USR
d804 1
a804 1
#ifdef ERRATA__XXX_USR
d821 1
a821 1
#ifdef ERRATA__XXX_USR
d835 1
a835 1
#ifdef ERRATA__XXX_USR
d849 1
a849 1
#ifdef ERRATA__XXX_USR
d867 1
a867 1
#ifdef ERRATA__XXX_USR
d923 1
a923 1
#ifdef ERRATA__XXX_USR
d1018 1
a1018 1
#ifdef ERRATA__XXX_USR
d1028 1
a1028 1
#ifdef ERRATA__XXX_USR
d1046 1
a1046 1
#ifdef ERRATA__XXX_USR
d1062 1
a1062 1
#ifdef ERRATA__XXX_USR
d1078 1
a1078 1
#ifdef ERRATA__XXX_USR
d1093 1
a1093 1
#ifdef ERRATA__XXX_USR
d1108 1
a1108 1
#ifdef ERRATA__XXX_USR
d1122 1
a1122 1
ASGLOBAL(copyout_byte_only)
d1127 1
a1127 1
#ifdef ERRATA__XXX_USR
d1183 1
a1183 1
#ifdef ERRATA__XXX_USR
d1220 3
d1263 1
a1263 1
ASGLOBAL(kf_3byte_word_copy)
d1278 1
a1278 1
ASGLOBAL(kf_1half_word_copy)
d1289 1
a1289 1
ASGLOBAL(kf_1byte_word_copy)
d1299 1
a1299 1
ASGLOBAL(kf_word_copy)
d1315 1
a1315 1
ASGLOBAL(kf_1byte_half_copy)
d1323 1
a1323 1
ASGLOBAL(kf_half_copy)
d1347 1
a1347 1
ASGLOBAL(kf_byte_copy)
d1359 1
a1359 1
ASGLOBAL(kcopy_reverse)
d1386 1
a1386 1
ASGLOBAL(kr_3byte_word_copy)
d1401 1
a1401 1
ASGLOBAL(kr_1half_word_copy)
d1412 1
a1412 1
ASGLOBAL(kr_1byte_word_copy)
d1422 1
a1422 1
ASGLOBAL(kr_word_copy)
d1438 1
a1438 1
ASGLOBAL(kr_1byte_half_copy)
d1446 1
a1446 1
ASGLOBAL(kr_half_copy)
d1470 1
a1470 1
ASGLOBAL(kr_byte_copy)
d1479 1
a1479 1
ASGLOBAL(kcopy_out)
d1481 1
a1481 1
ASGLOBAL(kcopy_out_fault)	
d1487 1
a1487 1
ASGLOBAL(kcopy_fault)
d1493 1
a1493 1
ASGLOBAL(kf_strat)
d1511 1
a1511 1
ASGLOBAL(kr_strat)
d1605 1
a1605 1
ASGLOBAL(f_3byte_word_copy)
d1620 1
a1620 1
ASGLOBAL(f_1half_word_copy)
d1631 1
a1631 1
ASGLOBAL(f_1byte_word_copy)
d1641 1
a1641 1
ASGLOBAL(f_word_copy)
d1657 1
a1657 1
ASGLOBAL(f_1byte_half_copy)
d1665 1
a1665 1
ASGLOBAL(f_half_copy)
d1689 1
a1689 1
ASGLOBAL(f_byte_copy)
d1701 1
a1701 1
ASGLOBAL(bcopy_reverse)
d1728 1
a1728 1
ASGLOBAL(r_3byte_word_copy)
d1743 1
a1743 1
ASGLOBAL(r_1half_word_copy)
d1754 1
a1754 1
ASGLOBAL(r_1byte_word_copy)
d1764 1
a1764 1
ASGLOBAL(r_word_copy)
d1780 1
a1780 1
ASGLOBAL(r_1byte_half_copy)
d1788 1
a1788 1
ASGLOBAL(r_half_copy)
d1812 1
a1812 1
ASGLOBAL(r_byte_copy)
d1821 1
a1821 1
ASGLOBAL(bcopy_out)
d1826 1
a1826 1
ASGLOBAL(f_strat)
d1844 1
a1844 1
ASGLOBAL(r_strat)
d2135 255
d2443 25
@


1.7.4.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/* $OpenBSD$	*/
d571 2
d574 1
a574 3
	bcnd	lt0,  CNT,   .Lcisflt
	bcnd	eq0,  CNT,   .Lcistoolong
1:
d584 1
a584 1
	st.b	r7, DEST, r6
d589 3
a591 12

.Lcistoolong:
	or	r2,   r0, ENAMETOOLONG	/* overflow */

.Lcisnull:
	bcnd	eq0,r6, .Lcisdone	/* do not attempt to clear last byte */
					/* if we did not write to the string */
	subu	r6,   r6, 1
	st.b	r0, DEST, r6		/* clear last byte */
	br.n	.Lcisdone
	addu	r6,   r6, 1
2:					/* all done */
d593 1
d598 1
a598 2
3:
	or.u	r5,r0,hi16(_curpcb)
d603 2
a604 2
	or	r2, r0, EFAULT		/* return fault */
	br	.Lcisnull
@


1.7.4.5
log
@Sync the SMP branch with 3.3
@
text
@d185 175
@


1.7.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d44 1
a44 1
 *	vaddr_t address;		\\ in r2
d172 12
d193 3
a195 3
#define	SRC	r2
#define	DEST	r3
#define	LEN	r4
d199 11
a209 13
	or.u	r5,   r0,   hi16(_C_LABEL(curpcb))
	ld	r6,   r5,   lo16(_C_LABEL(curpcb))
	or.u	r5,   r0,   hi16(_ASM_LABEL(Lciflt))
	or	r5,   r5,   lo16(_ASM_LABEL(Lciflt))
	st	r5,   r6,   PCB_ONFAULT	/* pcb_onfault = Lciflt */

#if 0
	bcnd	ne0,  LEN,  1f		/* XXX optimize len = 0 case */
	or	r2,   r0,   0
	br	_ASM_LABEL(Lcidone)
1:	bcnd	lt0,  LEN,  _ASM_LABEL(Lciflt)	/* EFAULT if len < 0 */
#endif

d212 1
a212 1
	bb1	lt,   r9,   _ASM_LABEL(copyin_byte_only)
d214 1
a214 1
	/* If they're not aligned similarly, use byte only... */
d217 1
a217 1
	bcnd	ne0,  r8,   _ASM_LABEL(copyin_byte_only)
d224 8
a231 8
	bb1	0,    SRC,  _ASM_LABEL(copyin_left_align_to_halfword)
ASLOCAL(copyin_left_aligned_to_halfword)
	bb1	1,    SRC,  _ASM_LABEL(copyin_left_align_to_word)
ASLOCAL(copyin_left_aligned_to_word)
	bb1	0,    LEN,  _ASM_LABEL(copyin_right_align_to_halfword)
ASLOCAL(copyin_right_aligned_to_halfword)
	bb1	1,    LEN,  _ASM_LABEL(copyin_right_align_to_word)
ASLOCAL(copyin_right_aligned_to_word)
d235 2
a236 2
	bb1.n	2,    LEN,  _ASM_LABEL(copyin_right_align_to_doubleword)
	 or	r7,   r0,   4
d238 1
a238 1
ASLOCAL(copyin_right_aligned_to_doubleword)
d241 1
a241 1
	ld.usr	r5,   SRC,  r0
d245 1
a245 1
	ld.usr	r6,   SRC,  r7
d250 2
a251 2
	ld.usr	r5,   SRC,  r0
	ld.usr	r6,   SRC,  r7
d257 4
a260 4
	bcnd.n	ne0,  LEN,  _ASM_LABEL(copyin_right_aligned_to_doubleword)
	 addu	DEST, DEST, 8
	br.n	_ASM_LABEL(Lcidone)
	 or	r2, r0, r0	/* successful return */
d262 1
a262 1
	/***************************************************/
d264 1
a264 1
ASLOCAL(copyin_left_align_to_halfword)
d267 1
a267 1
	ld.b.usr	r5,   SRC,  r0
d272 1
a272 1
	ld.b.usr	r5,   SRC,  r0
d277 2
a278 2
	br.n	_ASM_LABEL(copyin_left_aligned_to_halfword)
	 addu	DEST, DEST, 1
d280 1
a280 1
ASLOCAL(copyin_left_align_to_word)
d283 1
a283 1
	ld.h.usr	r5,   SRC,  r0
d288 1
a288 1
	ld.h.usr	r5,   SRC,  r0
d290 1
a290 1
	subu	LEN,  LEN,  2
d293 2
a294 2
	br.n	_ASM_LABEL(copyin_left_aligned_to_word)
	 addu	DEST, DEST, 2
d296 1
a296 1
ASLOCAL(copyin_right_align_to_halfword)
d300 1
a300 1
	ld.b.usr	r5,   SRC,  LEN
d305 1
a305 1
	ld.b.usr	r5,   SRC,  LEN
d307 2
a308 2
	br.n	_ASM_LABEL(copyin_right_aligned_to_halfword)
	 st.b	r5,   DEST, LEN
d310 1
a310 1
ASLOCAL(copyin_right_align_to_word)
d314 1
a314 1
	ld.h.usr	r5,   SRC,  LEN
d319 1
a319 1
	ld.h.usr	r5,   SRC,  LEN
d321 2
a322 2
	br.n	_ASM_LABEL(copyin_right_aligned_to_word)
	 st.h	r5,   DEST, LEN
d324 1
a324 1
ASLOCAL(copyin_right_align_to_doubleword)
d335 4
a338 4
	bcnd.n	ne0,  LEN, _ASM_LABEL(copyin_right_aligned_to_doubleword)
	 st	r5,   DEST, LEN
	br.n	_ASM_LABEL(Lcidone)
   	 or	r2, r0, r0	/* successful return */
d340 1
a340 1
ASLOCAL(copyin_byte_only)
d342 1
a342 1
1:
d346 1
a346 1
	ld.b.usr	r5, SRC, LEN
d351 1
a351 1
	ld.b.usr	r5, SRC, LEN
d354 15
a368 18
	 st.b	r5, DEST, LEN
2:
	br.n	_ASM_LABEL(Lcidone)
	 or	r2, r0, r0	/* successful return */

ASLOCAL(Lcidone)
	or.u	r5,r0,hi16(_C_LABEL(curpcb))
	ld	r6,r5,lo16(_C_LABEL(curpcb))
	jmp.n	r1
	 st	r0,r6,PCB_ONFAULT

ASLOCAL(Lciflt)
	br.n	_ASM_LABEL(Lcidone)
	 or	r2, r0, EFAULT	/* return fault */

#undef	SRC
#undef	DEST
#undef	LEN
d372 1
a372 1
/*
d383 4
a386 4
#define	SRC	r2
#define	DEST	r3
#define	CNT	r4
#define	LEN	r5
d388 1
a388 1
ENTRY(copyinstr)
d391 4
a394 4
	or.u	r6,   r0,   hi16(_C_LABEL(curpcb))
	ld	r7,   r6,   lo16(_C_LABEL(curpcb))
	or.u	r6,   r0,   hi16(_ASM_LABEL(Lcisflt))
	or	r6,   r6,   lo16(_ASM_LABEL(Lcisflt))
d397 2
a398 2
	bcnd	lt0,  CNT,  _ASM_LABEL(Lcisflt)
	bcnd	eq0,  CNT,  _ASM_LABEL(Lcistoolong)
d402 1
a402 1
	ld.bu.usr	r7,   SRC,  r6
d411 1
a411 1
	 addu	r6,   r6, 1
d415 1
a415 1
ASLOCAL(Lcistoolong)
d418 2
a419 2
ASLOCAL(Lcisnull)
	bcnd	eq0,r6, _ASM_LABEL(Lcisdone)	/* do not attempt to clear last byte */
d423 2
a424 2
	br.n	_ASM_LABEL(Lcisdone)
	 addu	r6,   r6, 1
d428 2
a429 2
ASLOCAL(Lcisdone)
	bcnd	eq0, LEN, 3f
d432 12
a443 13
	or.u	r5,r0,hi16(_C_LABEL(curpcb))
	ld	r6,r5,lo16(_C_LABEL(curpcb))
	jmp.n	r1
	 st	r0,r6,PCB_ONFAULT	/* clear the handler */

ASLOCAL(Lcisflt)
	br.n	_ASM_LABEL(Lcisnull)
	 or	r2, r0, EFAULT		/* return fault */

#undef	SRC
#undef	DEST
#undef	CNT
#undef	LEN
d453 3
a455 3
#define	SRC	r2
#define	DEST	r3
#define	LEN	r4
d459 11
a469 11
	or.u	r5,   r0,   hi16(_C_LABEL(curpcb))
	ld	r6,   r5,   lo16(_C_LABEL(curpcb))
	or.u	r5,   r0,   hi16(_ASM_LABEL(Lcoflt))
	or	r5,   r5,   lo16(_ASM_LABEL(Lcoflt))
	st	r5,   r6,   PCB_ONFAULT	/* pcb_onfault = Lcoflt */
#if 0
	bcnd	ne0,  LEN,  1f		/* XXX optimize len = 0 case */
	or	r2,   r0,   0
	br	_ASM_LABEL(Lcodone)
1:	bcnd	lt0,  LEN,  _ASM_LABEL(Lcoflt)	/* EFAULT if len < 0 */
#endif
d471 2
a472 2
	cmp	r9,   LEN,  8
	bb1	lt,   r9,   _ASM_LABEL(copyout_byte_only)
d474 4
a477 4
	/* If they're not aligned similarly, use byte only... */
	xor	r9,   SRC,  DEST
	mask	r8,   r9,   0x3
	bcnd	ne0,  r8,   _ASM_LABEL(copyout_byte_only)
d484 8
a491 8
	bb1	0,    SRC,  _ASM_LABEL(copyout_left_align_to_halfword)
ASLOCAL(copyout_left_aligned_to_halfword)
	bb1	1,    SRC,  _ASM_LABEL(copyout_left_align_to_word)
ASLOCAL(copyout_left_aligned_to_word)
	bb1	0,    LEN,  _ASM_LABEL(copyout_right_align_to_halfword)
ASLOCAL(copyout_right_aligned_to_halfword)
	bb1	1,    LEN,  _ASM_LABEL(copyout_right_align_to_word)
ASLOCAL(copyout_right_aligned_to_word)
d497 2
a498 2
	bb1.n	2,    LEN,  _ASM_LABEL(copyout_right_align_to_doubleword)
	 or	r7,   r0,   4
d500 1
a500 1
ASLOCAL(copyout_right_aligned_to_doubleword)
d523 4
a526 4
	bcnd.n	ne0,  LEN,  _ASM_LABEL(copyout_right_aligned_to_doubleword)
	 addu	DEST, DEST, 8
	or	r2, r0, r0	/* successful return */
	br	_ASM_LABEL(Lcodone)
d529 2
a530 2
ASLOCAL(copyout_left_align_to_halfword)
	ld.b	r5,   SRC,  r0
d534 1
a534 1
	st.b.usr	r5,   DEST, r0
d539 1
a539 1
	st.b.usr	r5,   DEST, r0
d542 2
a543 2
	br.n	_ASM_LABEL(copyout_left_aligned_to_halfword)
	 addu	DEST, DEST, 1
d545 3
a547 3
ASLOCAL(copyout_left_align_to_word)
	ld.h	r5,   SRC,  r0
	subu	LEN,  LEN,  2
d550 1
a550 1
	st.h.usr	r5,   DEST, r0
d555 1
a555 1
	st.h.usr	r5,   DEST, r0
d558 2
a559 2
	br.n	_ASM_LABEL(copyout_left_aligned_to_word)
	 addu	DEST, DEST, 2
d561 1
a561 1
ASLOCAL(copyout_right_align_to_halfword)
d563 1
a563 1
	ld.b	r5,   SRC,  LEN
d565 2
a567 1
	st.b.usr	r5,   DEST, LEN
d570 1
a570 2
	NOP
	br	_ASM_LABEL(copyout_right_aligned_to_halfword)
d572 2
a573 2
	br.n	_ASM_LABEL(copyout_right_aligned_to_halfword)
	 st.b.usr	r5,   DEST, LEN
d576 1
a576 1
ASLOCAL(copyout_right_align_to_word)
d578 1
a578 1
	ld.h	r5,   SRC,  LEN
d580 2
a581 2
	NOP
	st.h.usr	r5,   DEST, LEN
d585 4
a588 4
	br	_ASM_LABEL(copyout_right_aligned_to_word)
#else
	br.n	_ASM_LABEL(copyout_right_aligned_to_word)
	 st.h.usr	r5,   DEST, LEN
d591 1
a591 1
ASLOCAL(copyout_right_align_to_doubleword)
d600 1
a600 1
	bcnd	ne0,  LEN, _ASM_LABEL(copyout_right_aligned_to_doubleword)
d602 2
a603 2
	bcnd.n	ne0,  LEN, _ASM_LABEL(copyout_right_aligned_to_doubleword)
	 st.usr	r5,   DEST, LEN
d605 2
a606 2
	br.n	_ASM_LABEL(Lcodone)
	 or	r2, r0, r0	/* successful return */
d608 1
a608 1
ASLOCAL(copyout_byte_only)
d610 1
a610 1
1:
d612 1
a612 1
	ld.b	r5, SRC, LEN
d615 1
a615 1
	st.b.usr	r5, DEST, LEN
d622 1
a622 1
	 st.b.usr	r5, DEST, LEN
d625 2
a626 3
2:
	br.n	_ASM_LABEL(Lcodone)
	 or	r2, r0, r0	/* successful return */
d628 12
a639 5
ASLOCAL(Lcodone)
	or.u	r5,r0,hi16(_C_LABEL(curpcb))
	ld	r6,r5,lo16(_C_LABEL(curpcb))
	jmp.n	r1
	 st	r0,r6,PCB_ONFAULT	/* clear the handler */
d641 1
a641 9
ASLOCAL(Lcoflt)
	br.n	_ASM_LABEL(Lcodone)
	 or	r2, r0, EFAULT	/* return fault */

#undef	SRC
#undef	DEST
#undef	LEN

/*
d652 4
a655 4
#define	SRC	r2
#define	DEST	r3
#define	CNT	r4
#define	LEN	r5
d659 4
a662 4
	or.u	r6,   r0,   hi16(_C_LABEL(curpcb))
	ld	r7,   r6,   lo16(_C_LABEL(curpcb))
	or.u	r6,   r0,   hi16(_ASM_LABEL(Lcosflt))
	or	r6,   r6,   lo16(_ASM_LABEL(Lcosflt))
d664 2
a665 2
	bcnd	lt0,  CNT,  _ASM_LABEL(Lcosflt)
	bcnd	eq0,  CNT,  _ASM_LABEL(Lcosdone)
d667 1
a667 1
1:
d671 1
a671 1
	st.b.usr	r7,   DEST,  r6
d676 1
a676 1
	st.b.usr	r7,   DEST,  r6
d679 1
a679 1
	 addu	r6,   r6, 1
d682 5
a686 9
	br.n	_ASM_LABEL(Lcosdone)
	 or	r2,   r0, ENAMETOOLONG
2:
	br.n	_ASM_LABEL(Lcosdone)
	 or	r2,   r0, 0

ASLOCAL(Lcosflt)
	br.n	_ASM_LABEL(Lcosdone)
	 or	r2, r0, EFAULT
d688 6
a693 2
ASLOCAL(Lcosdone)
	bcnd	eq0, LEN, 3f
d695 4
a698 4
3:	or.u	r5,r0,hi16(_C_LABEL(curpcb))
	ld	r6,r5,lo16(_C_LABEL(curpcb))
	jmp.n	r1
	 st	r0,r6,PCB_ONFAULT	/* clear the handler */
d700 4
a703 4
#undef	SRC
#undef	DEST
#undef	CNT
#undef	LEN
d713 6
a718 6
	or.u	r5,   r0,   hi16(_C_LABEL(curpcb))
	ld	r6,   r5,   lo16(_C_LABEL(curpcb))
	or.u	r5,   r0,   hi16(_ASM_LABEL(kcopy_fault))
	or	r5,   r5,   lo16(_ASM_LABEL(kcopy_fault))
	st	r5,   r6,   PCB_ONFAULT		/* pcb_onfault = kcopy_fault */
	bcnd	le0,r4,_ASM_LABEL(kcopy_out)	/* nothing to do if <= 0 */
d723 2
a724 2
	bb1	eq,r9,_ASM_LABEL(kcopy_out)	/* nothing to do if equal */
	bb1	lo,r9,_ASM_LABEL(kcopy_revers)e	/* reverse copy if src < dest */
d726 1
a726 1
 *	source address is greater than destination address, copy forward
d729 1
a729 1
	bb1	lt,r9,_ASM_LABEL(kf_byte_copy)	/* copy bytes for small length */
d737 2
a738 2
	or.u	r12,r0,hi16(_ASM_LABEL(kf_strat))
	or	r12,r12,lo16(_ASM_LABEL(kf_strat))
d746 1
a746 1
ASLOCAL(kf_3byte_word_copy)
d755 2
a756 2
	br.n	_ASM_LABEL(kf_word_copy)	/* copy full words */
	 subu	r4,r4,3		/* decrement length */
d761 1
a761 1
ASLOCAL(kf_1half_word_copy)
d766 2
a767 2
	br.n	_ASM_LABEL(kf_word_copy)	/* copy full words */
	 subu	r4,r4,2		/* decrement remaining length */
d769 1
a769 1
/*
d772 1
a772 1
ASLOCAL(kf_1byte_word_copy)
d781 4
a784 4
 */
ASLOCAL(kf_word_copy)
	cmp	r10,r4,16	/* see if we have 16 bytes remaining */
	bb1	lo,r10,_ASM_LABEL(kf_byte_copy) 	/* not enough left, copy bytes */
d795 4
a798 4
	br.n	_ASM_LABEL(kf_word_copy)	/* copy another block */
	 subu	r4,r4,16	/* decrement remaining length */

ASLOCAL(kf_1byte_half_copy)
d806 3
a808 3
ASLOCAL(kf_half_copy)
	cmp	r10,r4,16	/* see if we have 16 bytes remaining */
	bb1	lo,r10,_ASM_LABEL(kf_byte_copy)	/* not enough left, copy bytes */
d827 5
a831 5
	br.n	_ASM_LABEL(kf_half_copy)	/* copy another block */
	 subu	r4,r4,16	/* decrement remaining length */

ASLOCAL(kf_byte_copy)
	bcnd	eq0,r4,_ASM_LABEL(kcopy_out)	/* branch if nothing left to copy */
d836 2
a837 2
	br.n	_ASM_LABEL(kf_byte_copy)	/* branch for next byte */
	 subu	r4,r4,1		/* decrement remaining length */
d842 1
a842 1
ASLOCAL(kcopy_reverse)
d844 1
a844 1
 * start copy pointers at end of data
d852 1
a852 1
	bb1	lt,r9,_ASM_LABEL(kr_byte_copy)	/* copy bytes for small data length */
d860 2
a861 2
	or.u	r12,r0,hi16(_ASM_LABEL(kr_strat))
	or	r12,r12,lo16(_ASM_LABEL(kr_strat))
d869 1
a869 1
ASLOCAL(kr_3byte_word_copy)
d878 2
a879 2
	br.n	_ASM_LABEL(kr_word_copy)	/* copy full words */
	 subu	r4,r4,3		/* decrement length */
d884 1
a884 1
ASLOCAL(kr_1half_word_copy)
d889 2
a890 2
	br.n	_ASM_LABEL(kr_word_copy)	/* copy full words */
	 subu	r4,r4,2		/* decrement remaining length */
d892 1
a892 1
/*
d895 1
a895 1
ASLOCAL(kr_1byte_word_copy)
d904 4
a907 4
 */
ASLOCAL(kr_word_copy)
	cmp	r10,r4,16	/* see if we have 16 bytes remaining */
	bb1	lo,r10,_ASM_LABEL(kr_byte_copy)	/* not enough left, copy bytes */
d918 4
a921 4
	br.n	_ASM_LABEL(kr_word_copy)	/* copy another block */
	 subu	r4,r4,16	/* decrement remaining length */

ASLOCAL(kr_1byte_half_copy)
d929 3
a931 3
ASLOCAL(kr_half_copy)
	cmp	r10,r4,16	/* see if we have 16 bytes remaining */
	bb1	lo,r10,_ASM_LABEL(kr_byte_copy)	/* not enough left, copy bytes */
d950 5
a954 5
	br.n	_ASM_LABEL(kr_half_copy)	/* copy another block */
	 subu	r4,r4,16	/* decrement remaining length */

ASLOCAL(kr_byte_copy)
	bcnd	eq0,r4,_ASM_LABEL(kcopy_out)	/* branch if nothing left to copy */
d959 2
a960 2
	br.n	_ASM_LABEL(kr_byte_copy)	/* branch for next byte */
	 subu	r4,r4,1		/* decrement remaining length */
d962 1
a962 1
ASLOCAL(kcopy_out)
d964 3
a966 3
ASLOCAL(kcopy_out_fault)
	or.u	r5,r0,hi16(_C_LABEL(curpcb))
	ld	r6,r5,lo16(_C_LABEL(curpcb))
d970 1
a970 1
ASLOCAL(kcopy_fault)
d972 2
a973 2
	br	_ASM_LABEL(kcopy_out_fault)

d976 62
a1037 40
ASLOCAL(kf_strat)
	word	_ASM_LABEL(kf_word_copy)
	word	_ASM_LABEL(kf_byte_copy)
	word	_ASM_LABEL(kf_half_copy)
	word	_ASM_LABEL(kf_byte_copy)
	word	_ASM_LABEL(kf_byte_copy)
	word	_ASM_LABEL(kf_3byte_word_copy)
	word	_ASM_LABEL(kf_byte_copy)
	word	_ASM_LABEL(kf_1byte_half_copy)
	word	_ASM_LABEL(kf_half_copy)
	word	_ASM_LABEL(kf_byte_copy)
	word	_ASM_LABEL(kf_1half_word_copy)
	word	_ASM_LABEL(kf_byte_copy)
	word	_ASM_LABEL(kf_byte_copy)
	word	_ASM_LABEL(kf_1byte_half_copy)
	word	_ASM_LABEL(kf_byte_copy)
	word	_ASM_LABEL(kf_1byte_word_copy)

ASLOCAL(kr_strat)
	word	_ASM_LABEL(kr_word_copy)
	word	_ASM_LABEL(kr_byte_copy)
	word	_ASM_LABEL(kr_half_copy)
	word	_ASM_LABEL(kr_byte_copy)
	word	_ASM_LABEL(kr_byte_copy)
	word	_ASM_LABEL(kr_1byte_word_copy)
	word	_ASM_LABEL(kr_byte_copy)
	word	_ASM_LABEL(kr_1byte_half_copy)
	word	_ASM_LABEL(kr_half_copy)
	word	_ASM_LABEL(kr_byte_copy)
	word	_ASM_LABEL(kr_1half_word_copy)
	word	_ASM_LABEL(kr_byte_copy)
	word	_ASM_LABEL(kr_byte_copy)
	word	_ASM_LABEL(kr_1byte_half_copy)
	word	_ASM_LABEL(kr_byte_copy)
	word	_ASM_LABEL(kr_3byte_word_copy)

/*
 * Gcc 2 generates calls to memcpy for bcopies of unknown size. memcpy can
 * simply be implemented as ovbcopy but the src (r2, r3) and dst args need to
 * be switched.
d1044 5
a1048 5
	or 	r5, r0, r2	/* dst -> tmp */
	or	r2, r0, r3	/* src -> 1st arg */
	br.n	_C_LABEL(ovbcopy)
	 or	r3, r0, r5	/* dst -> 2nd arg */

d1059 1
a1059 1
	bcnd	le0,r4,_ASM_LABEL(bcopy_out)	/* nothing to do if <= 0 */
d1064 2
a1065 2
	bb1	eq,r9,_ASM_LABEL(bcopy_out)	/* nothing to do if equal */
	bb1	lo,r9,_ASM_LABEL(bcopy_reverse)	/* reverse copy if src < dest */
d1067 1
a1067 1
 *	source address is greater than destination address, copy forward
d1070 1
a1070 1
	bb1	lt,r9,_ASM_LABEL(f_byte_copy)	/* copy bytes for small data length */
d1078 2
a1079 2
	or.u	r12,r0,hi16(_ASM_LABEL(f_strat))
	or	r12,r12,lo16(_ASM_LABEL(f_strat))
d1088 1
a1088 1
ASLOCAL(f_3byte_word_copy)
d1097 2
a1098 2
	br.n	_ASM_LABEL(f_word_copy)	/* copy full words */
	 subu	r4,r4,3		/* decrement length */
d1103 1
a1103 1
ASLOCAL(f_1half_word_copy)
d1108 2
a1109 2
	br.n	_ASM_LABEL(f_word_copy)	/* copy full words */
	 subu	r4,r4,2		/* decrement remaining length */
d1111 1
a1111 1
/*
d1114 1
a1114 1
ASLOCAL(f_1byte_word_copy)
d1123 4
a1126 4
 */
ASLOCAL(f_word_copy)
	cmp	r10,r4,16	/* see if we have 16 bytes remaining */
	bb1	lo,r10,_ASM_LABEL(f_byte_copy)	/* not enough left, copy bytes */
d1137 4
a1140 4
	br.n	_ASM_LABEL(f_word_copy)	/* branch to copy another block */
	 subu	r4,r4,16	/* decrement remaining length */

ASLOCAL(f_1byte_half_copy)
d1148 3
a1150 3
ASLOCAL(f_half_copy)
	cmp	r10,r4,16	/* see if we have 16 bytes remaining */
	bb1	lo,r10,_ASM_LABEL(f_byte_copy)	/* not enough left, copy bytes */
d1169 5
a1173 5
	br.n	_ASM_LABEL(f_half_copy)	/* branch to copy another block */
	 subu	r4,r4,16	/* decrement remaining length */

ASLOCAL(f_byte_copy)
	bcnd	eq0,r4,_ASM_LABEL(bcopy_out)	/* branch if nothing left to copy */
d1178 2
a1179 2
	br.n	_ASM_LABEL(f_byte_copy)	/* branch for next byte */
	 subu	r4,r4,1		/* decrement remaining length */
d1184 1
a1184 1
ASLOCAL(bcopy_reverse)
d1186 1
a1186 1
 * start copy pointers at end of data
d1194 1
a1194 1
	bb1	lt,r9,_ASM_LABEL(r_byte_copy)	/* copy bytes for small data length */
d1202 2
a1203 2
	or.u	r12,r0,hi16(_ASM_LABEL(r_strat))
	or	r12,r12,lo16(_ASM_LABEL(r_strat))
d1211 1
a1211 1
ASLOCAL(r_3byte_word_copy)
d1220 2
a1221 2
	br.n	_ASM_LABEL(r_word_copy)	/* copy full words */
	 subu	r4,r4,3		/* decrement length */
d1226 1
a1226 1
ASLOCAL(r_1half_word_copy)
d1231 2
a1232 2
	br.n	_ASM_LABEL(r_word_copy)	/* copy full words */
	 subu	r4,r4,2		/* decrement remaining length */
d1234 1
a1234 1
/*
d1237 1
a1237 1
ASLOCAL(r_1byte_word_copy)
d1246 4
a1249 4
 */
ASLOCAL(r_word_copy)
	cmp	r10,r4,16	/* see if we have 16 bytes remaining */
	bb1	lo,r10,_ASM_LABEL(r_byte_copy)	/* not enough left, copy bytes */
d1260 4
a1263 4
	br.n	_ASM_LABEL(r_word_copy)	/* branch to copy another block */
	 subu	r4,r4,16	/* decrement remaining length */

ASLOCAL(r_1byte_half_copy)
d1271 3
a1273 3
ASLOCAL(r_half_copy)
	cmp	r10,r4,16	/* see if we have 16 bytes remaining */
	bb1	lo,r10,_ASM_LABEL(r_byte_copy)	/* not enough left, copy bytes */
d1292 5
a1296 5
	br.n	_ASM_LABEL(r_half_copy)	/* branch to copy another block */
	 subu	r4,r4,16	/* decrement remaining length */

ASLOCAL(r_byte_copy)
	bcnd	eq0,r4,_ASM_LABEL(bcopy_out)	/* branch if nothing left to copy */
d1301 2
a1302 2
	br.n	_ASM_LABEL(r_byte_copy)	/* branch for next byte */
	 subu	r4,r4,1		/* decrement remaining length */
d1304 1
a1304 1
ASLOCAL(bcopy_out)
d1306 1
a1306 1

d1309 35
a1343 35
ASLOCAL(f_strat)
	word	_ASM_LABEL(f_word_copy)
	word	_ASM_LABEL(f_byte_copy)
	word	_ASM_LABEL(f_half_copy)
	word	_ASM_LABEL(f_byte_copy)
	word	_ASM_LABEL(f_byte_copy)
	word	_ASM_LABEL(f_3byte_word_copy)
	word	_ASM_LABEL(f_byte_copy)
	word	_ASM_LABEL(f_1byte_half_copy)
	word	_ASM_LABEL(f_half_copy)
	word	_ASM_LABEL(f_byte_copy)
	word	_ASM_LABEL(f_1half_word_copy)
	word	_ASM_LABEL(f_byte_copy)
	word	_ASM_LABEL(f_byte_copy)
	word	_ASM_LABEL(f_1byte_half_copy)
	word	_ASM_LABEL(f_byte_copy)
	word	_ASM_LABEL(f_1byte_word_copy)

ASLOCAL(r_strat)
	word	_ASM_LABEL(r_word_copy)
	word	_ASM_LABEL(r_byte_copy)
	word	_ASM_LABEL(r_half_copy)
	word	_ASM_LABEL(r_byte_copy)
	word	_ASM_LABEL(r_byte_copy)
	word	_ASM_LABEL(r_1byte_word_copy)
	word	_ASM_LABEL(r_byte_copy)
	word	_ASM_LABEL(r_1byte_half_copy)
	word	_ASM_LABEL(r_half_copy)
	word	_ASM_LABEL(r_byte_copy)
	word	_ASM_LABEL(r_1half_word_copy)
	word	_ASM_LABEL(r_byte_copy)
	word	_ASM_LABEL(r_byte_copy)
	word	_ASM_LABEL(r_1byte_half_copy)
	word	_ASM_LABEL(r_byte_copy)
	word	_ASM_LABEL(r_3byte_word_copy)
d1348 1
d1369 2
d1380 2
a1381 2
	bb1	0, R_dest, _ASM_LABEL(not_initially_word_aligned)
	bb1	1, R_dest, _ASM_LABEL(not_initially_word_aligned)
d1383 1
a1383 1
ASLOCAL(now_word_aligned)
d1388 4
a1391 4
	or.u	R_mark_address, r0, hi16(_ASM_LABEL(mark))
	or	R_mark_address, R_mark_address, lo16(_ASM_LABEL(mark))

ASLOCAL(top_of_main_loop)
d1396 1
a1396 1
	 *
d1409 1
a1409 1
	bcnd	eq0, R_bytes, _ASM_LABEL(done_doing_words)
d1428 3
a1430 1
	 or	R_bytes, r0, MAX_AT_ONE_TIME
a1431 1
1:
d1444 1
a1444 2
ASLOCAL(do_max)
	  subu	R_len, R_len, R_bytes	/* NOTE: this is in the delay slot! */
d1479 4
a1482 3
ASLOCAL(mark)
	br.n	_ASM_LABEL(top_of_main_loop)
	 addu	R_dest, R_dest, R_bytes	/* bump up the dest address */
a1483 3
ASLOCAL(done_doing_words)
	bcnd	ne0, R_len, 1f
	jmp	r1
d1485 5
a1489 1
1:
d1491 2
a1492 4
	bcnd.n	ne0, R_len, 1b
	 st.b	r0, R_dest, R_len
1:
	jmp	r1
d1494 4
a1497 1
ASLOCAL(not_initially_word_aligned)
d1501 1
a1501 1
	bcnd	eq0, R_len, 1b
d1505 15
a1519 11
	bcnd.n	eq0, R_temp, _ASM_LABEL(now_word_aligned)
	 subu	R_len, R_len, 1
	br	_ASM_LABEL(not_initially_word_aligned)

#undef	R_dest
#undef	R_len
#undef	R_bytes
#undef	R_mark_address
#undef	R_addr
#undef	R_temp
#undef	MAX_AT_ONE_TIME
d1526 2
a1527 1
ENTRY(setjmp)
d1548 1
a1548 1
	 or	r2,r0,r0
d1550 2
a1551 1
ENTRY(longjmp)
d1572 51
a1622 1
	 or	r2,r0,1
d1625 11
a1635 2
	jmp.n	r1
	 ldcr	r2, PID
a1636 1
GLOBAL(guarded_access_start)
d1638 1
d1645 1
a1645 1
	br	 _C_LABEL(guarded_access_bad)
d1662 1
a1662 1
GLOBAL(guarded_access_bad)
d1664 2
a1665 1
	 or	 r2,r0,EFAULT
d1667 1
a1667 1
@@L142:
d1669 1
a1669 1
	 or	 r2,r0,0
d1671 19
a1689 16
GLOBAL(guarded_access_end)

/*
 * void set_cpu_number(unsigned number);
 *
 * Sets the kernel cpu number for this cpu to the given value.
 *
 * Input:
 *	r1	return address
 *	r2 	the number (should be 0, 1, 2, or 3).
 *
 * Other registers used:
 *	r3	temp
 *	r4	original PSR
 *	r5	temporary new PSR
 */
a1690 1
#ifdef DEBUG
a1693 1
#endif
d1699 2
a1700 2
	FLUSH_PIPELINE

d1706 1
a1706 1

a1708 1
	FLUSH_PIPELINE
d1711 7
a1717 5
#ifdef DEBUG
1:	/* bad cpu number*/
	or.u	r2, r0, hi16(9f)
	bsr.n	_C_LABEL(panic)
	 or	r2, r2, lo16(9f)
a1718 3
	data
9:	string "set_cpu_number: bad CPU number %x\0"
#endif
@


1.7.4.7
log
@Merge with the trunk
@
text
@d1 1
a1 1
/* $OpenBSD: locore_asm_routines.S,v 1.7.4.6 2004/02/19 10:49:07 niklas Exp $	*/
@


1.6
log
@Added kernel support for user debugging.  Fixed file ID's
@
text
@d1 1
a1 1
/* $OpenBSD: locore_asm_routines.S,v 1.28 1995/04/19 22:37:27 smurph Exp $	*/
d45 1
a49 1

d182 243
a470 4
/* a version of disable_interrupt for the kernel debugger. Should never
   have breakpoints set in it. Make sure it stays consistent with 
   disable_interrupt */

d480 9
a489 1

d493 4
a496 4
     ldcr	r2, PSR                   /* get the processor status word */
     set  	r3, r0, 1<PSR_INTERRUPT_DISABLE_BIT>   /* set mask */
     jmp.n 	r1                                     /* delayed return */
     and 	r2, r2, r3                            /* r2 = r3 & r2 */
d512 5
a516 5
	or.u		r5,   r0,   hi16(_curpcb)	
	ld		r6,   r5,   lo16(_curpcb)
	or.u		r5,   r0,   hi16(fusu_fault)
	or		r5,   r5,   lo16(fusu_fault)
	st		r5,   r6,   PCB_ONFAULT	/* pcb_onfault = fusu_fault */
d519 1
a519 1
	ld.usr   	r5,   r0,  r2
d524 1
a524 1
	ld.usr   	r5,   r0,  r2
d526 2
a527 2
	or		r2,   r0,  r5
	br		fusu_ret
d529 1
a529 1
	subu		r2,   r0,  1	
d531 3
a533 3
	or.u		r5,   r0,   hi16(_curpcb)	
	ld		r6,   r5,   lo16(_curpcb)
	st		r0,   r6,   PCB_ONFAULT	/* pcb_onfault = 0 */
d535 1
a535 1
	jmp		r1
d538 5
a542 5
	or.u		r5,   r0,   hi16(_curpcb)	
	ld		r6,   r5,   lo16(_curpcb)
	or.u		r5,   r0,   hi16(fusu_fault)
	or		r5,   r5,   lo16(fusu_fault)
	st		r5,   r6,   PCB_ONFAULT	/* pcb_onfault = fusu_fault */
d545 1
a545 1
	ld.h.usr   	r5,   r0,  r2
d550 1
a550 1
	ld.h.usr   	r5,   r0,  r2
d552 2
a553 2
	or		r2,   r0,  r5
	br		fusu_ret
d557 5
a561 5
	or.u		r5,   r0,   hi16(_curpcb)	
	ld		r6,   r5,   lo16(_curpcb)
	or.u		r5,   r0,   hi16(fusu_fault)
	or		r5,   r5,   lo16(fusu_fault)
	st		r5,   r6,   PCB_ONFAULT	/* pcb_onfault = fusu_fault */
d564 1
a564 1
	ld.b.usr   	r5,   r0,  r2
d569 1
a569 1
	ld.b.usr   	r5,   r0,  r2
d571 2
a572 2
	or		r2,   r0,  r5
	br		fusu_ret
d575 5
a579 5
	or.u		r5,   r0,   hi16(_curpcb)	
	ld		r6,   r5,   lo16(_curpcb)
	or.u		r5,   r0,   hi16(_fubail)
	or		r5,   r5,   lo16(_fubail)
	st		r5,   r6,   PCB_ONFAULT	/* pcb_onfault = fubail */
d582 1
a582 1
	ld.h.usr	r5,   r2, r0
d587 1
a587 1
	ld.h.usr	r5,   r2, r0
d589 2
a590 2
	or		r2,   r0, r5
	br		fusu_ret
d593 2
a594 2
	subu		r2,   r0, 1
	br		fusu_ret
d604 5
a608 5
	or.u		r5,   r0,   hi16(_curpcb)	
	ld		r6,   r5,   lo16(_curpcb)
	or.u		r5,   r0,   hi16(fusu_fault)
	or		r5,   r5,   lo16(fusu_fault)
	st		r5,   r6,   PCB_ONFAULT	/* pcb_onfault = fusu_fault */
d611 1
a611 1
	st.usr		r3,   r2, r0
d616 1
a616 1
	st.usr		r3,   r2, r0
d618 2
a619 2
	or		r2,   r0, r0		/* return success */
	br		fusu_ret
d622 5
a626 5
	or.u		r5,   r0,   hi16(_curpcb)	
	ld		r6,   r5,   lo16(_curpcb)
	or.u		r5,   r0,   hi16(fusu_fault)
	or		r5,   r5,   lo16(fusu_fault)
	st		r5,   r6,   PCB_ONFAULT	/* pcb_onfault = fusu_fault */
d629 1
a629 1
	st.h.usr	r3,   r2, r0
d634 1
a634 1
	st.h.usr	r3,   r2, r0
d636 2
a637 2
	or		r2,   r0, r0		/* return success */
	br		fusu_ret
d641 5
a645 5
	or.u		r5,   r0,   hi16(_curpcb)	
	ld		r6,   r5,   lo16(_curpcb)
	or.u		r5,   r0,   hi16(fusu_fault)
	or		r5,   r5,   lo16(fusu_fault)
	st		r5,   r6,   PCB_ONFAULT	/* pcb_onfault = fusu_fault */
d648 1
a648 1
	st.b.usr	r3,   r2, r0
d653 1
a653 1
	st.b.usr	r3,   r2, r0
d655 2
a656 2
	or		r2,   r0, r0		/* return success */
	br		fusu_ret
d659 5
a663 5
	or.u		r5,   r0,   hi16(_curpcb)	
	ld		r6,   r5,   lo16(_curpcb)
	or.u		r5,   r0,   hi16(_subail)
	or		r5,   r5,   lo16(_subail)
	st		r5,   r6,   PCB_ONFAULT	/* pcb_onfault = subail */
d666 1
a666 1
	st.h.usr	r3,   r2, r0
d671 1
a671 1
	st.h.usr	r3,   r2, r0
d673 2
a674 2
	or		r2,   r0, r0		/* return success */
	br		fusu_ret
d677 2
a678 2
	subu		r2,   r0, 1
	br		fusu_ret
d729 5
a733 5
	or.u		r5,   r0,   hi16(_curpcb)	
	ld		r6,   r5,   lo16(_curpcb)
	or.u		r5,   r0,   hi16(.Lciflt)
	or		r5,   r5,   lo16(.Lciflt)
	st		r5,   r6,   PCB_ONFAULT	/* pcb_onfault = .Lciflt */
d735 3
a737 3
	/*bcnd		ne0,  LEN,  1f ; XXX optimize len = 0 case */
	/*;or		r2,   r0,   0 */
	/*;br		.Lcidone */
d741 2
a742 2
	cmp		r9,   LEN,  8
	bb1		lt,   r9,   copyin_byte_only
d745 3
a747 3
	xor		r9,   SRC,  DEST
	mask		r8,   r9,   0x3
	bcnd		ne0,  r8,   copyin_byte_only
d754 1
a754 1
	bb1		0,    SRC,  copyin_left_align_to_halfword
d756 1
a756 1
	bb1		1,    SRC,  copyin_left_align_to_word
d758 1
a758 1
	bb1		0,    LEN,  copyin_right_align_to_halfword
d760 1
a760 1
	bb1		1,    LEN,  copyin_right_align_to_word
d765 2
a766 2
	bb1.n		2,    LEN,  copyin_right_align_to_doubleword
	or		r7,   r0,   4
d771 1
a771 1
	ld.usr 		r5,   SRC,  r0
d775 1
a775 1
	ld.usr    	r6,   SRC,  r7
d780 2
a781 2
	ld.usr 		r5,   SRC,  r0
	ld.usr    	r6,   SRC,  r7
d783 8
a790 8
	subu		LEN,  LEN,  8
	st		r5,   DEST, r0
	addu		SRC,  SRC,  8
	st		r6,   DEST, r7
	bcnd.n		ne0,  LEN,  copyin_right_aligned_to_doubleword
	addu		DEST, DEST, 8
   	or		r2, r0, r0	/* successful return */
	br		.Lcidone
d797 1
a797 1
	ld.b.usr   	r5,   SRC,  r0
d802 1
a802 1
	ld.b.usr   	r5,   SRC,  r0
d804 5
a808 5
	subu		LEN,  LEN,  1
	st.b		r5,   DEST, r0
	addu		SRC,  SRC,  1
	br.n		copyin_left_aligned_to_halfword
	addu		DEST, DEST, 1
d813 1
a813 1
	ld.h.usr   	r5,   SRC,  r0
d818 1
a818 1
	ld.h.usr   	r5,   SRC,  r0
d820 5
a824 5
	subu      	LEN,  LEN,  2
	st.h		r5,   DEST, r0
	addu		SRC,  SRC,  2
	br.n		copyin_left_aligned_to_word
	addu		DEST, DEST, 2
d827 1
a827 1
	subu		LEN,  LEN,  1
d830 1
a830 1
	ld.b.usr   	r5,   SRC,  LEN
d835 1
a835 1
	ld.b.usr   	r5,   SRC,  LEN
d837 2
a838 2
	br.n		copyin_right_aligned_to_halfword
	st.b		r5,   DEST, LEN
d841 1
a841 1
	subu		LEN,  LEN,  2
d844 1
a844 1
	ld.h.usr   	r5,   SRC,  LEN
d849 1
a849 1
	ld.h.usr   	r5,   SRC,  LEN
d851 2
a852 2
	br.n		copyin_right_aligned_to_word
	st.h		r5,   DEST, LEN
d855 1
a855 1
	subu		LEN,  LEN,  4
d858 1
a858 1
	ld.usr		r5,   SRC,  LEN
d863 1
a863 1
	ld.usr		r5,   SRC,  LEN
d865 4
a868 4
	bcnd.n		ne0,  LEN, copyin_right_aligned_to_doubleword
	st		r5,   DEST, LEN
   	or		r2, r0, r0	/* successful return */
	br		.Lcidone
d871 1
a871 1
	bcnd		eq0, LEN, 2f
d873 1
a873 1
	subu		LEN, LEN, 1
d876 1
a876 1
	ld.b.usr   	r5, SRC, LEN
d881 1
a881 1
	ld.b.usr   	r5, SRC, LEN
d883 4
a886 4
	bcnd.n		ne0, LEN, 1b
	st.b		r5, DEST, LEN
   2:	or		r2, r0, r0	/* successful return */
	br		.Lcidone
d888 4
a891 4
	or.u		r5,r0,hi16(_curpcb)
	ld		r6,r5,lo16(_curpcb)
	st		r0,r6,PCB_ONFAULT
	jmp		r1
d893 2
a894 2
	or		r2, r0, EFAULT	/* return fault */
	br		.Lcidone
d918 2
a919 1
ENTRY(copyinstr)
d921 8
a928 8
	or.u		r6,   r0,   hi16(_curpcb)	
	ld		r7,   r6,   lo16(_curpcb)
	or.u		r6,   r0,   hi16(.Lcisflt)
	or		r6,   r6,   lo16(.Lcisflt)
	st		r6,   r7,   PCB_ONFAULT
	bcnd		lt0,  CNT,   .Lcisflt
	bcnd		eq0,  CNT,   .Lcisdone
	or		r6,   r0,   0
d932 1
a932 1
	ld.bu.usr   	r7,   SRC,  r6
d939 7
a945 7
	st.b		r7,   DEST, r6
	bcnd.n		eq0,  r7, 2f		/* all done */
	addu		r6,   r6, 1
	cmp		r7,   r6, CNT
	bb1		lt,   r7, 1b
	or		r2,   r0, ENAMETOOLONG	/* over flow */
	br		.Lcisdone
d947 2
a948 2
	or		r2,   r0, 0
	br		.Lcisdone
d951 6
a956 6
        bcnd		eq0, LEN, 3f		
	st		r6, r0, LEN
   3:	or.u		r5,r0,hi16(_curpcb)
	ld		r6,r5,lo16(_curpcb)
	st		r0,r6,PCB_ONFAULT	/* clear the handler */
	jmp		r1
d958 2
a959 2
	or		r2, r0, EFAULT	/* return fault */
	br		.Lcisdone
d981 10
a990 9
	or.u		r5,   r0,   hi16(_curpcb)	
	ld		r6,   r5,   lo16(_curpcb)
	or.u		r5,   r0,   hi16(.Lcoflt)
	or		r5,   r5,   lo16(.Lcoflt)
	st		r5,   r6,   PCB_ONFAULT	/* pcb_onfault = .Lcoflt */
/*	;bcnd		ne0,  LEN,  1f ; XXX optimize len = 0 case */
/*	;or		r2,   r0,   0 */
/*	;br		.Lcodone */
    /*;1: ;bcnd		lt0,  LEN,  .Lcoflt ; EFAULT if len < 0  */
d992 2
a993 2
	cmp		r9,   LEN,  8 
	bb1		lt,   r9,   copyout_byte_only 
d996 3
a998 3
	xor		r9,   SRC,  DEST 
	mask		r8,   r9,   0x3 
	bcnd		ne0,  r8,   copyout_byte_only 
d1005 1
a1005 1
	bb1		0,    SRC,  copyout_left_align_to_halfword
d1007 1
a1007 1
	bb1		1,    SRC,  copyout_left_align_to_word
d1009 1
a1009 1
	bb1		0,    LEN,  copyout_right_align_to_halfword
d1011 1
a1011 1
	bb1		1,    LEN,  copyout_right_align_to_word
d1018 2
a1019 2
	bb1.n		2,    LEN,  copyout_right_align_to_doubleword
	or		r7,   r0,   4
d1022 3
a1024 3
	ld 		r5,   SRC,  r0
	ld    		r6,   SRC,  r7
	subu		LEN,  LEN,  8
d1027 1
a1027 1
	st.usr		r5,   DEST, r0
d1032 1
a1032 1
	st.usr		r5,   DEST, r0
d1034 1
a1034 1
	addu		SRC,  SRC,  8
d1037 1
a1037 1
	st.usr		r6,   DEST, r7
d1042 1
a1042 1
	st.usr		r6,   DEST, r7
d1044 4
a1047 4
	bcnd.n		ne0,  LEN,  copyout_right_aligned_to_doubleword
	addu		DEST, DEST, 8
   	or		r2, r0, r0	/* successful return */
	br		.Lcodone
d1051 2
a1052 2
	ld.b   		r5,   SRC,  r0
	subu		LEN,  LEN,  1
d1055 1
a1055 1
	st.b.usr	r5,   DEST, r0
d1060 1
a1060 1
	st.b.usr	r5,   DEST, r0
d1062 3
a1064 3
	addu		SRC,  SRC,  1
	br.n		copyout_left_aligned_to_halfword
	addu		DEST, DEST, 1
d1067 2
a1068 2
	ld.h   		r5,   SRC,  r0
	subu      	LEN,  LEN,  2
d1071 1
a1071 1
	st.h.usr	r5,   DEST, r0
d1076 1
a1076 1
	st.h.usr	r5,   DEST, r0
d1078 3
a1080 3
	addu		SRC,  SRC,  2
	br.n		copyout_left_aligned_to_word
	addu		DEST, DEST, 2
d1083 2
a1084 2
	subu		LEN,  LEN,  1
	ld.b   		r5,   SRC,  LEN
d1086 2
a1087 2
	NOP
	st.b.usr	r5,   DEST, LEN
d1091 1
a1091 1
	br		copyout_right_aligned_to_halfword
d1093 2
a1094 2
	br.n		copyout_right_aligned_to_halfword
	st.b.usr	r5,   DEST, LEN
d1098 2
a1099 2
	subu		LEN,  LEN,  2
	ld.h   		r5,   SRC,  LEN
d1101 2
a1102 2
	NOP
	st.h.usr	r5,   DEST, LEN
d1106 4
a1109 4
	br		copyout_right_aligned_to_word
#else
	br.n		copyout_right_aligned_to_word
	st.h.usr	r5,   DEST, LEN
d1113 2
a1114 2
	subu		LEN,  LEN,  4
	ld		r5,   SRC,  LEN
d1117 1
a1117 1
	st.usr		r5,   DEST, LEN
d1121 1
a1121 1
	bcnd		ne0,  LEN, copyout_right_aligned_to_doubleword
d1123 2
a1124 2
	bcnd.n		ne0,  LEN, copyout_right_aligned_to_doubleword
	st.usr		r5,   DEST, LEN
d1126 2
a1127 2
   	or		r2, r0, r0	/* successful return */
	br		.Lcodone
d1130 1
a1130 1
	bcnd		eq0, LEN, 2f
d1132 2
a1133 2
	subu		LEN, LEN, 1
	ld.b   		r5, SRC, LEN
d1136 1
a1136 1
	st.b.usr	r5, DEST, LEN
d1140 1
a1140 1
	bcnd		ne0, LEN, 1b
d1142 2
a1143 2
	bcnd.n		ne0, LEN, 1b
	st.b.usr	r5, DEST, LEN
d1146 2
a1147 2
   2:	or		r2, r0, r0	/* successful return */
	br		.Lcodone
d1150 4
a1153 4
	or.u		r5,r0,hi16(_curpcb)
	ld		r6,r5,lo16(_curpcb)
	st		r0,r6,PCB_ONFAULT	/* clear the handler */
	jmp		r1
d1155 2
a1156 2
	or		r2, r0, EFAULT	/* return fault */
	br		.Lcodone
d1180 8
a1187 8
	or.u		r6,   r0,   hi16(_curpcb)	
	ld		r7,   r6,   lo16(_curpcb)
	or.u		r6,   r0,   hi16(.Lcosflt)
	or		r6,   r6,   lo16(.Lcosflt)
	st		r6,   r7,   PCB_ONFAULT
	bcnd		lt0,  CNT,   .Lcosflt
	bcnd		eq0,  CNT,   .Lcosdone
	or		r6,   r0,   0
d1189 1
a1189 1
	ld.bu		r7,   SRC,  r6
d1192 1
a1192 1
	st.b.usr   	r7,   DEST,  r6
d1197 1
a1197 1
	st.b.usr	r7,   DEST,  r6
d1199 6
a1204 6
	bcnd.n		eq0,  r7, 2f		/* all done */
	addu		r6,   r6, 1
	cmp		r7,   r6, CNT
	bb1		lt,   r7, 1b
	or		r2,   r0, ENAMETOOLONG	/* over flow */
	br		.Lcosdone
d1206 2
a1207 2
	or		r2,   r0, 0
	br		.Lcosdone
d1210 2
a1211 2
	or		r2, r0, EFAULT	/* return fault */
	br		.Lcosdone
d1214 6
a1219 6
        bcnd		eq0, LEN, 3f		
	st		r6, r0, LEN
   3:	or.u		r5,r0,hi16(_curpcb)
	ld		r6,r5,lo16(_curpcb)
	st		r0,r6,PCB_ONFAULT	/* clear the handler */
	jmp		r1
d1590 1
a1590 1
#	define MAX_AT_ONE_TIME 128
d1613 14
a1626 14
		/*
		 * Since we're doing the max, we know exactly where we're
	 	 * jumping (the first one in the list!), so we can jump
		 * right there.  However, we've still got to adjust
		 * the length, so we'll jump to where we ajust the length
	 	 * which just happens to fall through to the first store zero
		 * in the list.
		 *
	 	 * Note, however, that we're jumping to an instruction that
		 * would be in the delay slot for the jump in front of it,
		 * so if you change things here, WATCH OUT.
		 */
		br.n	do_max
		or	R_bytes, r0, MAX_AT_ONE_TIME
d1803 15
d1833 1
a1833 1
	or	r5,r2,r0
d1839 18
d1860 2
a1861 1
	bcnd	ne0, r5, 2f
d1865 1
a1865 1
    2:
d1877 14
d1893 1
d1911 22
a1932 3
        FLUSH_PIPELINE
     1:
	/* get the current mask value */
d1936 1
a1941 14
/*
 *       invalidate_pte(pte)
 *
 *       This function will invalidate specified pte indivisibly
 *       to avoid the write-back of used-bit and/or modify-bit into
 *       that pte.  It also returns the pte found in the table.
 */
ENTRY(invalidate_pte)
        or      r3,r0,r0
        xmem    r3,r2,r0
	tb1     0,r0,0
        jmp.n   r1
        or      r2,r3,r0

a1942 1

d1946 1
a1946 1
	or	r5,r2,r0
d1952 18
d1973 2
a1974 1
	bcnd	ne0, r5, 2f
d1978 31
a2008 1
    2:
d2019 20
a2038 1
	/* get the current mask value */
d2042 1
d2047 2
d2050 1
a2050 14
ENTRY(db_getipl)
ENTRY(db_spl)
	ldcr	r10,PSR
	or	r11,r0,r10
	bb1	PSR_INTERRUPT_DISABLE_BIT, r10, 1f
	set	r10,r10,1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r10,PSR
      1:
	or.u	r3,r0,hi16(INT_MASK_LEVEL)
	ld.b	r2,r3,lo16(INT_MASK_LEVEL)
	stcr	r11,PSR
        FLUSH_PIPELINE
	jmp	r1

d2102 75
@


1.5
log
@Commit for the first working mvme88k port.
@
text
@d1 1
@


1.4
log
@mvme88k will not make release, but just as well make the source as close as
possible.
@
text
@d6 1
d731 1
d742 2
a743 2
	cmp		r9,   LEN,  8
	bb1		lt,   r9,   copyout_byte_only
d746 3
a748 3
	xor		r9,   SRC,  DEST
	mask		r8,   r9,   0x3
	bcnd		ne0,  r8,   copyout_byte_only
@


1.3
log
@Cleanup after import. This also seems to bring up the current version.
@
text
@d41 1
@


1.2
log
@This is a remove to get rid of the old mvme88k port which was incomplete
to replace it with a working version. The kernel compiles and works
at least.  The new version will be imported shortly.
@
text
@d5 1
a40 2
#include <machine/asm.h>
#include <machine/locore.h>
d43 1
a46 8
#undef ENTRY 	/* don't want anything to do with a G?PROF ENTRY() */
#ifdef __STDC__
#  define ENTRY(name)	align 4 NEWLINE _ ## name: global _ ## name
#else
#  define ENTRY(name)	align 4 NEWLINE _/**/name: global _/**/name
#endif


d253 1
a253 1
;LABEL(_ALLOW_FAULT_START)
d266 1
a266 1
	st		r5,   r6,   PCB_ONFAULT	; pcb_onfault = fusu_fault
d283 1
a283 1
	st		r0,   r6,   PCB_ONFAULT	; pcb_onfault = 0
d292 1
a292 1
	st		r5,   r6,   PCB_ONFAULT	; pcb_onfault = fusu_fault
d311 1
a311 1
	st		r5,   r6,   PCB_ONFAULT	; pcb_onfault = fusu_fault
d329 1
a329 1
	st		r5,   r6,   PCB_ONFAULT	; pcb_onfault = fubail
d358 1
a358 1
	st		r5,   r6,   PCB_ONFAULT	; pcb_onfault = fusu_fault
d376 1
a376 1
	st		r5,   r6,   PCB_ONFAULT	; pcb_onfault = fusu_fault
d395 1
a395 1
	st		r5,   r6,   PCB_ONFAULT	; pcb_onfault = fusu_fault
d413 1
a413 1
	st		r5,   r6,   PCB_ONFAULT	; pcb_onfault = subail
a435 1
 * NOTE: maxlength must be < 64K
d438 3
a440 7
	movl	sp@@(4),a0		| a0 = fromaddr
	movl	sp@@(8),a1		| a1 = toaddr
	moveq	#0,d0
	movw	sp@@(14),d0		| d0 = maxlength
	jlt	Lcsflt1			| negative count, error
	jeq	Lcsdone			| zero count, all done
	subql	#1,d0			| set up for dbeq
d442 7
a448 4
	movb	a0@@+,a1@@+		| copy a byte
	dbeq	d0,Lcsloop		| if !null and more, continue
	jne	Lcsflt2			| ran out of room, error
	moveq	#0,d0			| got a null, all done
d450 2
a451 5
	tstl	sp@@(16)			| return length desired?
	jeq	Lcsret			| no, just return
	subl	sp@@(4),a0		| determine how much was copied
	movl	sp@@(16),a1		| return location
	movl	a0,a1@@			| stash it
d453 2
a454 1
	rts
d456 2
a457 2
	moveq	#EFAULT,d0		| copy fault
	jra	Lcsdone
d459 4
a462 3
	moveq	#ENAMETOOLONG,d0	| ran out of space
	jra	Lcsdone	

a463 1
	jmp	r1
d483 1
a483 1
	st		r5,   r6,   PCB_ONFAULT	; pcb_onfault = .Lciflt
d485 4
a488 4
	;bcnd		ne0,  LEN,  1f ; XXX optimize len = 0 case
	;or		r2,   r0,   0
	;br		.Lcidone
    ;1: ;bcnd		lt0,  LEN,  .Lciflt ; EFAULT if len < 0 
d660 1
a660 1
 * r5 == len actually transferred
d689 1
a689 1
	bcnd		eq0,  r7, 2f		; all done
d693 1
a693 1
	or		r2,   r0, ENAMETOOLONG	; over flow
d695 1
a695 1
   2:   					; all done
d733 5
a737 5
	st		r5,   r6,   PCB_ONFAULT	; pcb_onfault = .Lcoflt
	;bcnd		ne0,  LEN,  1f ; XXX optimize len = 0 case
	;or		r2,   r0,   0
	;br		.Lcodone
    ;1: ;bcnd		lt0,  LEN,  .Lcoflt ; EFAULT if len < 0 
d917 1
a917 1
 * r5 == len actually copied
d946 1
a946 1
	bcnd		eq0,  r7, 2f		; all done
d950 1
a950 1
	or		r2,   r0, ENAMETOOLONG	; over flow
d952 1
a952 1
   2:   					; all done
d974 2
a975 2
;LABEL(_ALLOW_FAULT_END)
;word 0	/* to separate from routine below */
d1468 2
d1517 1
a1517 1
	or	r2,r3,r0
d1549 13
d1565 2
d1569 2
d1572 4
a1575 2
	or	r4,r3,lo16(INT_MASK_LEVEL)
	xmem.bu	r2,r4,r0
d1578 1
d1581 1
d1585 1
d1588 2
d1597 24
d1639 2
d1643 2
d1646 4
a1649 2
	or	r4,r3,lo16(INT_MASK_LEVEL)
	xmem.bu	r2,r4,r0
d1652 1
d1655 18
d1676 1
d1679 1
a1693 8
	
#if 0
/*
 *	call rom abort (called when non-maskable interrupt detected)
 */
ENTRY(call_rom_abort)
	tcnd	eq0, r0, EVN_ROM_ABORT	/* trap to ROM */
	jmp	r1			/* and return */
d1695 8
a1702 2
#endif /* 0 */
;------------------------------------------------------------------------
d1704 33
a1736 28
#ifdef JUNK
/* JEFF_DEBUG stuff */
	align 8
raw_xpr_stack_top:
	zero 0x40
raw_xpr_inital_stack_frame:
	zero 0x60
raw_xpr_stack_bottom:

user_raw_xpr: global user_raw_xpr
	ldcr	r5, cr17
	ld	r5, r5, THREAD_TASK
	/* get a stack ... can use r9 no problem */
	or.u	r9, r0, hi16(raw_xpr_inital_stack_frame)
	or	r9, r9, lo16(raw_xpr_inital_stack_frame)
	st	r31, r9, 0x38
	st	r1, r9, 0x3c
	or	r31, r9, r0
	bsr	__raw_xpr
	ld	r1, r31, 0x3c
	ld	r31, r31, 0x38
	rte
;--------------------------------------------------------------
_raw_xpr: global _raw_xpr
	or.u	r5, r0, hi16(_kernel_task)
	ld	r5, r5, lo16(_kernel_task)
	br	__raw_xpr
#endif /* JUNK */
@


1.1
log
@moved from m88k directory
@
text
@@


1.1.1.1
log
@Third try at importing the mvme88k port. This is a working kernel
from nivas.
Userland and compiler still need to be worked on.
Make certain what directory the import is done from.
@
text
@a4 1
 * Copyright (c) 1996 Nivas Madhur
d40 2
a43 1
#include <machine/asm.h>
d47 8
d261 1
a261 1
/* LABEL(_ALLOW_FAULT_START) */
d274 1
a274 1
	st		r5,   r6,   PCB_ONFAULT	/* pcb_onfault = fusu_fault */
d291 1
a291 1
	st		r0,   r6,   PCB_ONFAULT	/* pcb_onfault = 0 */
d300 1
a300 1
	st		r5,   r6,   PCB_ONFAULT	/* pcb_onfault = fusu_fault */
d319 1
a319 1
	st		r5,   r6,   PCB_ONFAULT	/* pcb_onfault = fusu_fault */
d337 1
a337 1
	st		r5,   r6,   PCB_ONFAULT	/* pcb_onfault = fubail */
d366 1
a366 1
	st		r5,   r6,   PCB_ONFAULT	/* pcb_onfault = fusu_fault */
d384 1
a384 1
	st		r5,   r6,   PCB_ONFAULT	/* pcb_onfault = fusu_fault */
d403 1
a403 1
	st		r5,   r6,   PCB_ONFAULT	/* pcb_onfault = fusu_fault */
d421 1
a421 1
	st		r5,   r6,   PCB_ONFAULT	/* pcb_onfault = subail */
d444 1
d447 7
a453 3
	or	r6,r0,0
	bcnd	lt0,r4,Lcsflt1		/* negative count, error */
	bcnd	eq0,r4,Lcsdone		/* zero count, all done */
d455 4
a458 7
	ld	r8,r2,r6		/* copy a byte */
	st	r8,r3,r6		
	addu	r6,r6,1			/* bump the index */
	bcnd	eq0,r8,Lcsdone 		/* if null, done */
	subu	r4,r4,1			/* decrement count to copy */
	bcnd	ne0,r4,Lcsloop		/* if more to copy, loop */
	br	Lcsflt2 		/* ran out of room, error */
d460 5
a464 2
	bcnd	eq0, r5, Lcsret		/* if return len not desired, return */
	st	r6,r5,0			/* stash it */
d466 1
a466 2
	or	r2,r0,0			/* good status */
	jmp	r1
d468 2
a469 2
	or	r2,r0,EFAULT		/* return fault */
	br	Lcsdone
d471 4
a474 3
	or	r2,r0,ENAMETOOLONG	/* ran out of space */
	br	Lcsdone	
Lcsdone:
a475 1
#endif /* 0 */
d495 1
a495 1
	st		r5,   r6,   PCB_ONFAULT	/* pcb_onfault = .Lciflt */
d497 4
a500 4
	/*bcnd		ne0,  LEN,  1f ; XXX optimize len = 0 case */
	/*;or		r2,   r0,   0 */
	/*;br		.Lcidone */
    /*;1: ;bcnd		lt0,  LEN,  .Lciflt ; EFAULT if len < 0  */
d672 1
a672 1
 * r5 == len actually transferred (includes the terminating NULL!!!)
d701 1
a701 1
	bcnd.n		eq0,  r7, 2f		/* all done */
d705 1
a705 1
	or		r2,   r0, ENAMETOOLONG	/* over flow */
d707 1
a707 1
   2:   					/* all done */
d745 5
a749 5
	st		r5,   r6,   PCB_ONFAULT	/* pcb_onfault = .Lcoflt */
/*	;bcnd		ne0,  LEN,  1f ; XXX optimize len = 0 case */
/*	;or		r2,   r0,   0 */
/*	;br		.Lcodone */
    /*;1: ;bcnd		lt0,  LEN,  .Lcoflt ; EFAULT if len < 0  */
d929 1
a929 1
 * r5 == len actually copied (including the terminating NULL!!!)
d958 1
a958 1
	bcnd.n		eq0,  r7, 2f		/* all done */
d962 1
a962 1
	or		r2,   r0, ENAMETOOLONG	/* over flow */
d964 1
a964 1
   2:   					/* all done */
d986 2
a987 2
/*LABEL(_ALLOW_FAULT_END)*/
/*word 0	*/ /* to separate from routine below */
a1479 2
 *	int setjmp(label_t *);
 *	void longjmp(label_t*);
d1527 1
a1527 1
	or	r2,r0,1
a1558 13
/*
 * This has to be cleaned - we should not use INT_MASK_LEVEL. Should
 * use pcc2_int_lvl instead. XXX nivas
 */
/*
 * I don't think we need to explictly enable interrupts. We can always enable
 * interrupts and depend on the int level and mask in PCC2 to block the
 * appropriate interrupts for us. If we don't depend on the PCC2 to block ints
 * for us, we need to explicitly set the IND bit in the PSR for every spln(x)
 * when x > 0. But for now... Rewrite the whole mess. XXX nivas
 * This is bogus - it is blocking interrupts for all but 0 XXX nivas
 */

a1561 2
	or	r5,r2,r0
	bb1	PSR_INTERRUPT_DISABLE_BIT,r10,1f
a1563 2
        FLUSH_PIPELINE
    1:
d1565 2
a1566 4
	or	r3,r3,lo16(INT_MASK_LEVEL)
	xmem.bu	r2,r3,r0
	bcnd	ne0, r5, 2f
	clr	r11, r11, 1<PSR_INTERRUPT_DISABLE_BIT>
a1568 1
    2:
a1570 1
ENTRY(getipl)
a1573 1
	bb1	PSR_INTERRUPT_DISABLE_BIT, r10, 1f
a1575 2
        FLUSH_PIPELINE
      1:
a1582 24
 *	Set the interrupt mask to the value passed in, returning the
 *	the current mask level. This routine does not enable/disable
 *	interrupts explicitly. It is assumed that the callers know what
 *	to do with interrupts.
 */
 
ENTRY(setipl)
	ldcr	r10,PSR
	or	r11,r0,r10
	bb1	PSR_INTERRUPT_DISABLE_BIT, r10, 1f
	set	r10,r10,1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r10,PSR 			/* disable ints, if needed */
        FLUSH_PIPELINE
     1:
	/* get the current mask value */
	or.u	r3,r0,hi16(INT_MASK_LEVEL)
	or	r3,r3,lo16(INT_MASK_LEVEL)
	xmem.bu	r2,r3,r0			/* xchng the new mask value */
        FLUSH_PIPELINE
	stcr	r11,PSR				/* restore psr */
        FLUSH_PIPELINE
	jmp	r1				/* and return the old value */

/*
a1600 2
	or	r5,r2,r0
	bb1	PSR_INTERRUPT_DISABLE_BIT,r10,1f
a1602 2
        FLUSH_PIPELINE
    1:
d1604 2
a1605 4
	or	r3,r3,lo16(INT_MASK_LEVEL)
	xmem.bu	r2,r3,r0
	bcnd	ne0, r5, 2f
	clr	r11, r11, 1<PSR_INTERRUPT_DISABLE_BIT>
a1607 1
    2:
a1609 18
ENTRY(db_setipl)
	ldcr	r10,PSR
	or	r11,r0,r10
	bb1	PSR_INTERRUPT_DISABLE_BIT, r10, 1f
	set	r10,r10,1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r10,PSR 			/* disable ints, if needed */
        FLUSH_PIPELINE
     1:
	/* get the current mask value */
	or.u	r3,r0,hi16(INT_MASK_LEVEL)
	or	r3,r3,lo16(INT_MASK_LEVEL)
	xmem.bu	r2,r3,r0			/* xchng the new mask value */
        FLUSH_PIPELINE
	stcr	r11,PSR				/* restore psr */
        FLUSH_PIPELINE
	jmp	r1				/* and return the old value */

ENTRY(db_getipl)
a1612 1
	bb1	PSR_INTERRUPT_DISABLE_BIT, r10, 1f
a1614 1
      1:
d1629 8
d1638 2
a1639 8
ENTRY(safe_byte_access)
	ld.b	 r9,r0,r2
	tb1	 0,r0,0
	br	 @@L1
	or	r0,r0,r0
@@L1:
	st.b	 r9,r0,r3
	jmp	r1
d1641 28
a1668 33
ENTRY(guarded_access)
ENTRY(guarded_access_start)
	cmp	 r9,r3,4
	bb1	 eq,r9,@@L145
	cmp	 r9,r3,2
	bb1	 eq,r9,@@L144
	cmp	 r9,r3,1
	bb1	 eq,r9,@@L143
	br	 _guarded_access_bad
@@L143:
	ld.b	 r9,r0,r2
	tb1	0, r0, 0
	st.b	 r9,r0,r4
	br	 @@L142
@@L144:
	ld.h	 r9,r0,r2
	tb1	0, r0, 0
	st.h	 r9,r0,r4
	br	 @@L142
@@L145:
	ld	 r9,r0,r2
	tb1	0, r0, 0
	st	 r9,r0,r4
	br	 @@L142

ENTRY(guarded_access_bad)
	jmp.n	 r1
	or	 r2,r0,14
@@L142:

ENTRY(guarded_access_end)
	jmp.n	 r1
	or	 r2,r0,0
@
