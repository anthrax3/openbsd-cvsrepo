head	1.22;
access;
symbols
	SMP_SYNC_A:1.22
	SMP_SYNC_B:1.22
	OPENBSD_3_5:1.21.0.2
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	UBC_SYNC_A:1.16
	OPENBSD_3_3:1.16.0.6
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.4
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	UBC_SYNC_B:1.16
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.6.0.8
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.6
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.4
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	mvme88kport:1.1.1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@# @;


1.22
date	2004.04.29.14.33.27;	author miod;	state dead;
branches;
next	1.21;

1.21
date	2004.01.16.00.13.43;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2003.12.25.00.12.37;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2003.12.24.22.41.45;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2003.11.03.06.54.26;	author david;	state Exp;
branches;
next	1.17;

1.17
date	2003.08.11.20.45.17;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2001.12.22.17.57.11;	author smurph;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.16.23.49.46;	author miod;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.12.14.02.11.45;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.13.08.55.52;	author smurph;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.18.01.43.33;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.24.22.53.15;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.07.22.12.31;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.20.05.53.10;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.09.05.44.41;	author smurph;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.07.23.40.35;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	99.09.27.19.13.22;	author smurph;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	99.02.09.06.36.29;	author smurph;	state Exp;
branches;
next	1.4;

1.4
date	97.05.24.03.02.31;	author rahnds;	state Exp;
branches;
next	1.3;

1.3
date	97.03.03.20.21.40;	author rahnds;	state Exp;
branches;
next	1.2;

1.2
date	97.03.03.19.08.09;	author rahnds;	state dead;
branches;
next	1.1;

1.1
date	95.10.18.12.32.27;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.03.03.19.32.26;	author rahnds;	state Exp;
branches;
next	;

1.6.4.1
date	2001.04.18.16.11.36;	author niklas;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2001.07.04.10.20.16;	author niklas;	state Exp;
branches;
next	1.6.4.3;

1.6.4.3
date	2001.10.31.03.01.19;	author nate;	state Exp;
branches;
next	1.6.4.4;

1.6.4.4
date	2001.12.05.00.39.12;	author niklas;	state Exp;
branches;
next	1.6.4.5;

1.6.4.5
date	2002.03.06.02.04.45;	author niklas;	state Exp;
branches;
next	1.6.4.6;

1.6.4.6
date	2004.02.19.10.49.07;	author niklas;	state Exp;
branches;
next	1.6.4.7;

1.6.4.7
date	2004.06.05.23.09.50;	author niklas;	state dead;
branches;
next	;

1.15.2.1
date	2002.01.31.22.55.19;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Continue factorizing m88k common code, this time files in <arch>/<arch>
which were copied verbatim from mvme88k to luna88k.

This requires backing out syntactic sugar in mvme88k kernel configuration
files which would deduct the required processor types from the board models,
as the common code only depends upon the M88100 and M88110 defines.
@
text
@/* $OpenBSD: m88100_fp.S,v 1.21 2004/01/16 00:13:43 miod Exp $	*/
/*
 * Mach Operating System
 * Copyright (c) 1991 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON AND OMRON ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON AND OMRON DISCLAIM ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/* Floating point trouble routines */
#include "assym.h"
#include <machine/trap.h>
#include <machine/asm.h>

#define destsize 10

/* Floating-Point Status Register bits */
#define inexact 0
#define overflow 1
#define underflow 2
#define divzero 3
#define oper 4

#define sign 31
#define s1size 9
#define s2size 7
#define dsize 5

#define FADDop 0x05
#define FSUBop 0x06
#define FCMPop 0x07
#define FMULop 0x00
#define FDIVop 0x0e
#define FSQRTop 0x0f
#define INTop 0x09
#define NINTop 0x0a
#define TRNCop 0x0b

#define s1nan 7
#define s2nan 6
#define s1inf 5
#define s2inf 4
#define s1zero 3
#define s2zero 2
#define sigbit 19

#define modehi 30
#define modelo 29
#define rndhi 15
#define rndlo 14
#define efunf 7
#define efovf 6
#define efinx 5

ASENTRY(m88100_Xfp_precise)
	or	r29, r3,  r0		/* r29 is now the E.F. */
	subu	r31, r31, 40
	st	r1,  r31, 32
	st	r29, r31, 36

	ld	r2, r29, EF_FPSR * 4
	ld	r3, r29, EF_FPCR * 4
	ld	r4, r29, EF_FPECR * 4
	ld	r5, r29, EF_FPHS1 * 4
	ld	r6, r29, EF_FPLS1 * 4
	ld	r7, r29, EF_FPHS2 * 4
	ld	r8, r29, EF_FPLS2 * 4
	ld	r9, r29, EF_FPPT * 4


	/*
	 * Load into r1 the return address for the 0 handlers. Looking at
	 * FPECR, branch to the appropriate 0 handler. However, if none of the
	 * 0 bits are enabled, then a floating point instruction was issued
	 * with the floating point unit disabled. This will cause an
	 * unimplemented opcode 0.
	 */

	or.u	r1,r0,hi16(wrapup)	/* load return address of function */
	or	r1,r1,lo16(wrapup)

	bb0	6,r4, 3f		/* branch to FPunimp if bit set */
	br	FPuimp
3:
	bb0	7,r4, 4f		/* branch to FPintover if bit set */
	br	FPintover
4:
#if 0
	bb0	5,r4, 5f		/* branch to FPpriviol if bit set */
	br	FPpriviol
#endif
5:
	bb0	4,r4, 6f		/* branch to FPresoper if bit set */
	br	FPresoper
6:
	bb0	3,r4, 7f		/* branch to FPdivzero if bit set */
	br	FPdivzero
7:
	or.u	r4, r4, 0xffff

ASLOCAL(FPuimp)
	subu	r31,r31,40		/* allocate stack */
	st	r1,r31,36		/* save return address */
	st	r3,r31,32		/* save exception frame */
	or	r2,r0,T_FPEPFLT		/* load trap type */
	or	r3, r29, r0
	bsr	_C_LABEL(m88100_trap)
	ld	r1,r31,36		/* recover return address */
	addu	r31,r31,40		/* deallocate stack */
	jmp	r1

	/*
	 * To write back the results to the user registers, disable exceptions
	 * and the floating point unit. Write FPSR and FPCR and load the SNIP
	 * and SFIP.
	 * r5 will contain the upper word of the result
	 * r6 will contain the lower word of the result
	 */

ASLOCAL(wrapup)
	tb1	0,r0,0		/* make sure all floating point operations */
				/* have finished */
	ldcr	r10, cr1	/* load the PSR */
#if 0
	set	r10, r10, 1<PSR_FPU_DISABLE_BIT>
#endif
	set	r10, r10, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r10, cr1

	ld	r1, r31, 32
	ld	r29, r31, 36
	addu	r31, r31, 40

	fstcr	r2, FPSR	/* write revised value of FPSR */
	fstcr	r3, FPCR	/* write revised value of FPCR */

	/* result writeback routine */
	addu	r3, r29, EF_R0 * 4
	extu	r2, r9, 5<0>		/* get 5 bits of destination register */
	bb0	5, r9, writesingle	/* branch if destination is single */

/* writedouble here */
	st	r5, r3 [r2]		/* write high word */
	add	r2, r2, 1		/* for double, the low word is the */
	/* unspecified register */
	clr	r2, r2, 27<5>		/* perform equivalent of mod 32 */
ASLOCAL(writesingle)
	st	r6, r3 [r2]		/* write low word into memory */
	jmp	r1

/*
 * Check if the numerator is zero. If the numerator is zero, then handle
 * this instruction as you would a 0/0 invalid operation.
 */

ASLOCAL(FPdivzero)
	st	r1,r31,0		/* save return address */
	bb1	s1size,r9,1f		/* branch if numerator double */
/* single number */
	clr	r10,r5,1<sign>	/* clear sign bit */
	extu	r11,r6,3<29>	/* grab upper bits of lower word */
	or	r10,r10,r11	/* combine ones of mantissa */
	bcnd	eq0,r10,resoper	/* numerator is zero, handle reserved operand */
	br	setbit		/* set divzero bit */
1:
/* double number */
	clr	r10,r5,1<sign>	/* clear sign bit */
	or	r10,r10,r6	/* or high and low words */
	bcnd	ne0,r10,setbit	/* set divzero bit */

/*
 * The numerator is zero, so handle the invalid operation by setting the
 * invalid operation bit and branching to the user handler if there is one
 * or writing a quiet NaN to the destination.
 */

ASLOCAL(resoper)
	set	r2,r2,1<oper>
#ifdef HANDLER
	bb0	oper,r3,noreshand	/* branch to execute default handling */
					/* for reserved operands */
	bsr	_handler		/* branch to user handler */
	br	FP_div_return
#endif

noreshand:
	set	r5,r0,0<0>	/* put a NaN in high word */
	set	r6,r0,0<0>	/* put a NaN in low word */
	br	FP_div_return
				/* writing to a word which may be ignored */
				/* is just as quick as checking the precision */
				/* of the destination */

/*
 * The operation is divide by zero, so set the divide by zero bit in the
 * FPSR. If the user handler is set, then go to the user handler, else
 * go to the default mode.
 */

setbit:
	set	r2,r2,1<divzero>
#ifdef HANDLER
	bb0	divzero,r3,default	/* go to default routine if no hdlr */
	bsr	_handler		/* execute handler routine */
	br	FP_div_return
#endif

/*
 * Considering the sign of the numerator and zero, write a correctly
 * signed infinity of the proper precision into the destination.
 */

default:
	bb1	dsize,r9,FPzero_double	/* branch to handle double result */
FPzero_single:
	clr	r10,r5,31<0>	/* clear all of S1HI except sign bit */
	xor	r10,r7,r10	/* xor the sign bits of the operands */
	or.u	r6,r0,0x7f80	/* load single precision infinity */
	br.n	FP_div_return
	 or	r6,r6,r10	/* load correctly signed infinity */

FPzero_double:
	clr	r10,r5,31<0>	/* clear all of S1HI except sign bit */
	xor	r10,r7,r10	/* xor the sign bits of the operands */
	or.u	r5,r0,0x7ff0	/* load double precision infinity */
	or	r5,r5,r10	/* load correctly signed infinity */
	or	r6,r0,r0	/* clear lower word of double */

FP_div_return:
	ld	r1,r31,0	/* load return address */
	jmp	r1

/*
 * Both NINT and TRNC require a certain rounding mode, so check which
 * instruction caused the integer conversion overflow. Use a substitute
 * FPCR in r1, and modify the rounding mode if the instruction is NINT
 * or TRNC.
 */
ASLOCAL(FPintover)
	extu	r10,r9,5<11>		/* extract opcode */
	cmp	r11,r10,INTop		/* see if instruction is INT */
	st	r1,r31,0		/* save return address */
	bb1.n	eq,r11,checksize	/* instruction is INT, do not modify */
					/* rounding mode */
	 or	r1,r0,r3		/* load FPCR into r1 */
	cmp	r11,r10,NINTop		/* see if instruction is NINT */
	bb1	eq,r11,NINT		/* instruction is NINT */
TRNC:
	clr	r1,r1,2<rndlo>		/* clear rounding mode bits, */
					/* instruction is TRNC */
	br.n	checksize		/* branch to check size */
	 set	r1,r1,1<rndlo>		/* make rounding mode round towards */
					/* zero */
NINT:
	clr	r1,r1,2<rndlo>		/* make rounding mode round to */
					/* nearest */

/* See whether the source is single or double precision. */

checksize:
	bb1	s2size,r9,checkdoub 	/* S2 is double, branch to see if */
					/* there is a false alarm */

/*
 * An integer has more bits than the mantissa of a single precision floating
 * point number, so to check for false alarms (i.e. valid conversion), simply
 * check the exponents. False alarms are detected for 2**30 to (2**30) - 1
 * and -2**30 to -2**31. Only seven bits need to be looked at since an
 * exception will not occur for the other half of the numbering system.
 * To speed up the processing, first check to see if the exponent is 32 or
 * greater.
 *
 * This code was originally written for the exponent in the control
 * register to have the most significant bit (8 - single, 11 - double)
 * flipped and sign extended. For precise exceptions, however, the most
 * significant bit is only sign extended. Therefore, the code was chopped
 * up so that it would work for positive values of real exponent which were
 * only sign extended.
 */

checksing:
	extu	r10,r7,7<20>	/* internal representation for single */
				/* precision is IEEE 8 bits sign extended */
				/* to 11 bits; for real exp. = 30, the */
				/* above instruction gives a result exp. */
				/* that has the MSB flipped and sign */
				/* extended like in the IMPCR */
	cmp	r11,r10,31	/* compare to 32,but exp. off by 1 */
				/* these 2 instructions to speed up valid */
				/* execution of valid cases */
	bb1	ge,r11,overflw	/* valid case, perform overflow routine */
	bb1	sign,r7,checksingn /* source operand is negative */

/*
 * If the number is positve and the exponent is greater than 30, than it is
 * overflow.
 */
checksingp:
	cmp	r10,r10,29	/* compare to 30, but exp. off by 1 */
	bb1	gt,r10,overflw	/* no false alarm, its overflow */
	br	conversionsp	/* finish single precision conversion */

/*
 * If the number is negative, and the exponent is 30, or 31 with a mantissa
 * of 0, then it is a false alarm.
 */
checksingn:
	cmp	r11,r10,30		/* compare to 31,but exp. off by 1 */
	bb1	lt,r11,conversionsn	/* exp. less than 31, so convert */
	extu	r10,r8,3<29>		/* get upper three bits of lower */
					/* mantissa */
	mak	r12,r7,20<3>		/* get upper 20 bits of mantissa */
	or	r10,r10,r12		/* form complete mantissa */
	bcnd	eq0,r10,conversionsn	/* complete conversion if mantissa */
					/* is 0 */
	br	overflw			/* no false alarm, its overflow */

/*
 * False alarms are detected for 2**30 to (2**30) - 1 and -2**30 to -2**31.
 * Only seven bits need to be looked at since an exception will not occur
 * for the other half of the numbering system.
 * To speed up the processing, first check to see if the exponent is 32 or
 * greater. Since there are more mantissa bits than integer bits, rounding
 * could cause overflow. (2**31) - 1 needs to be checked so that it does
 * not round to 2**31, and -2**31 needs to be checked in case it rounds to
 * -((2**31) + 1).
 */
checkdoub:
	extu	r10,r7,10<20>	/* internal representation for double */
				/* precision is the same IEEE 11 bits */
				/* for real exp. = 30, the */
				/* above instruction gives a result exp. */
				/* that has the MSB flipped and sign */
				/* extended like in the IMPCR */
	cmp	r11,r10,31	/* compare to 32,but exp. off by 1 */
				/* these 2 instructions to speed up valid */
				/* execution of valid cases */
	bb1	ge,r11,overflw	/* valid case, perform overflow routine */
	bb1	sign,r7,checkdoubn /* source operand is negative */

/*
 * If the exponent is not 31, then the floating point number will be rounded
 * before the conversion is done. A branch table is set up with bits 4 and 3
 * being the rounding mode, and bits 2, 1, and 0 are the guard, round, and
 * sticky bits.
 */
checkdoubp:
	cmp	r11,r10,30	/* compare to 31, but exponent off by 1 */
	bb1	eq,r11,overflw	/* no false alarm, its overflow */
	extu	r12,r8,1<22>	/* get LSB for integer with exp. = 30 */
	mak	r12,r12,1<2>	/* start to set up field for branch table */
	extu	r11,r8,1<21>	/* get guard bit */
	mak	r11,r11,1<1>	/* set up field for branch table */
	or	r12,r11,r12	/* set up field for branch table */
	extu	r11,r8,21<0>	/* get bits for sticky bit */
	bcnd	eq0,r11,nostickyp /* do not set sticky */
	set	r12,r12,1<0>	/* set sticky bit */
nostickyp:
	rot	r11,r1,0<rndlo>		/* shift rounding mode to 2 LSB''s */
	mak	r11,r11,2<3>		/* set up field, clear other bits */
	or	r12,r11,r12		/* set up field for branch table */
	lda	r12,r0[r12]		/* scale r12 */
	or.u	r12,r12,hi16(ptable)	/* load pointer into table */
	addu	r12,r12,lo16(ptable)
	jmp	r12

ptable:
	br	conversiondp
	br	conversiondp
	br	conversiondp
	br	paddone
	br	conversiondp
	br	conversiondp
	br	paddone
	br	paddone
	br	conversiondp
	br	conversiondp
	br	conversiondp
	br	conversiondp
	br	conversiondp
	br	conversiondp
	br	conversiondp
	br	conversiondp
	br	conversiondp
	br	conversiondp
	br	conversiondp
	br	conversiondp
	br	conversiondp
	br	conversiondp
	br	conversiondp
	br	conversiondp
	br	conversiondp
	br	paddone
	br	paddone
	br	paddone
	br	conversiondp
	br	paddone
	br	paddone
	br	paddone

/*
 * Add one to the bit of the mantissa which corresponds to the LSB of an
 * integer. If the mantissa overflows, then there is a valid integer
 * overflow conversion; otherwise, the mantissa can be converted to the
 * integer.
 */
paddone:
	or	r10,r0,r0	/* clear r10 */
	set	r10,r10,1<22>	/* set LSB bit to 1 for adding */
	addu.co	r8,r8,r10	/* add the 1 obtained from rounding */
	clr	r11,r7,12<20>	/* clear exponent and sign */
	addu.ci	r11,r0,r11	/* add carry */
	bb1	20,r11,overflw	/* overflow to 2**31, abort the rest */
	br.n	conversiondp	/* since the exp. was 30, and the exp. */
				/* did not round up to 31, the largest */
				/* number that S2 could become is 2**31-1 */
	 or	r7,r0,r11	/* store r11 into r7 for conversion */

/*
 * Now check for negative double precision sources. If the exponent is 30,
 * then convert the false alarm. If the exponent is 31, then check the
 * mantissa bits which correspond to integer bits. If any of them are a one,
 * then there is overflow. If they are zero, then check the guard, round,
 * and sticky bits.
 * Round toward zero and positive will not cause a roundup, but round toward
 * nearest and negative may, so perform those roundings. If there is no
 * overflow, then convert and return.
 */
checkdoubn:
	cmp	r11,r10,29		/* compare to 30, but exp. off by 1 */
	bb1	eq,r11,conversiondn	/* false alarm if exp. = 30 */
	extu	r10,r8,11<21>		/* check upper bits of lower mantissa */
	bcnd	ne0,r10,overflw		/* one of the bits is a 1, so oflow */
	extu	r10,r7,20<0>		/* check upper bits of upper mantissa */
	bcnd	ne0,r10,overflw		/* one of the bits is a 1, so oflow */
	bb0	rndlo,r1,possround	/* rounding mode is either round near */
					/* or round negative, which may cause */
					/* a round */
	br.n	FPintov_return		/* round positive, which will not */
					/* cause a round */
	 set	r6,r0,1<sign>
possround:
	extu	r12,r8,1<20>		/* get guard bit */
	extu	r11,r8,20<0>		/* get bits for sticky bit */
	bcnd.n	eq0,r11,nostickyn	/* do not set sticky */
	 mak	r12,r12,1<1>		/* set up field for branch table */
	set	r12,r12,1<0>		/* set sticky bit */
nostickyn:
	bb1	rndhi,r1,negative	/* rounding mode is negative */
nearest:
	cmp	r12,r12,3		/* are both guard and sticky set */
	bb1	eq,r12,overflw		/* both guard and sticky are set, */
					/* so signal overflow */
	or	r6,r0,r0		/* clear destination register r6 */
	br.n	FPintov_return
	 set	r6,r6,1<sign>		/* set the sign bit and take care of */
					/* this special case */
negative:
	bcnd	ne0,r12,overflw		/* -2**31 will be rounded to */
					/* -(2**31+1), so signal overflow */
	or	r6,r0,r0		/* clear destination register r6 */
	br.n	FPintov_return
	 set	r6,r6,1<sign>		/* set the sign bit and take care of */
					/* this special case */

	/*
	 * Since the exp. was 30, and there was no round-up, the largest
	 * number that S2 could have been was 2**31 - 1
	 */


	/* Convert the single precision positive floating point number. */

conversionsp:
	extu	r6,r8,3<29>	/* extract lower bits of integer */
	mak	r6,r6,3<7>	/* shift left to correct place in integer */
	mak	r10,r7,20<10>	/* shift left upper bits of integer */
	or	r6,r6,r10	/* form most of integer */
	br.n	FPintov_return
	 set	r6,r6,1<30>	/* set hidden one */

	/* Convert the single precision negative floating point number. */

conversionsn:
	bb1	eq,r11,exp31s	/* use old r11 to see if exp. is 31 */
	extu	r6,r8,3<29>	/* extract lower bits of mantissa */
	mak	r6,r6,3<7>	/* shift left to correct place in integer */
	mak	r10,r7,20<10>	/* shift left upper bits of integer */
	or	r6,r6,r10	/* form most of integer */
	set	r6,r6,1<30>	/* set hidden one */
	or.c	r6,r0,r6	/* negate result */
	br.n	FPintov_return
	 addu	r6,r6,1		/* add 1 to get 2''s complement */
exp31s:
	or	r6,r0,r0	/* clear r6 */
	br.n	FPintov_return
	 set	r6,r6,1<sign>	/* set sign bit */

	/* Convert the double precision positive floating point number. */

conversiondp:
	extu	r6,r8,10<22>	/* extract lower bits of integer */
	mak	r10,r7,20<10>	/* shift left upper bits of integer */
	or	r6,r6,r10	/* form most of integer */
	br.n	FPintov_return
	 set	r6,r6,1<30>	/* set hidden one */

	/*
	 * Convert the double precision negative floating point number.
	 * The number, whose exponent is 30, must be rounded before converting.
	 * Bits 4 and 3 are the rounding mode, and bits 2, 1, and 0 are the
	 * guard, round, and sticky bits for the branch table.
	 */

conversiondn:
	extu	r12,r8,1<22>	/* get LSB for integer with exp. = 30 */
	mak	r12,r12,1<2>	/* start to set up field for branch table */
	extu	r11,r8,1<21>	/* get guard bit */
	mak	r11,r11,1<1>	/* set up field for branch table */
	or	r12,r11,r12	/* set up field for branch table */
	extu	r11,r8,21<0>	/* get bits for sticky bit */
	bcnd	eq0,r11,nostkyn	/* do not set sticky */
	set	r12,r12,1<0>	/* set sticky bit */
nostkyn:
	rot	r11,r1,0<rndlo>	/* shift rounding mode to 2 LSB''s */
	mak	r11,r11,2<3>	/* set up field, clear other bits */
	or	r12,r11,r12	/* set up field for branch table */
	lda	r12,r0[r12]	/* scale r12 */
	or.u	r12,r12,hi16(ntable) /* load pointer into table */
	addu	r12,r12,lo16(ntable)
	jmp	r12

ntable:
	br	nnoaddone
	br	nnoaddone
	br	nnoaddone
	br	naddone
	br	nnoaddone
	br	nnoaddone
	br	naddone
	br	naddone
	br	nnoaddone
	br	nnoaddone
	br	nnoaddone
	br	nnoaddone
	br	nnoaddone
	br	nnoaddone
	br	nnoaddone
	br	nnoaddone
	br	nnoaddone
	br	naddone
	br	naddone
	br	naddone
	br	nnoaddone
	br	naddone
	br	naddone
	br	naddone
	br	nnoaddone
	br	nnoaddone
	br	nnoaddone
	br	nnoaddone
	br	nnoaddone
	br	nnoaddone
	br	nnoaddone
	br	nnoaddone

/*
 * Add one to the mantissa, and check to see if it overflows to -2**31.
 * The conversion is done in nnoaddone.
 */

naddone:
	or	r10,r0,r0	/* clear r10 */
	set	r10,r10,1<22>	/* set LSB bit to 1 for adding */
	add.co	r8,r8,r10	/* add the 1 obtained from rounding */
	clr	r7,r7,12<20>	/* clear exponent and sign */
	add.ci	r7,r0,r7	/* add carry */
	bb1	20,r7,maxneg	/* rounded to -2**31,handle separately */
				/* the exponent was originally 30 */
nnoaddone:
	extu	r6,r8,11<22>	/* extract lower bits of integer */
	mak	r10,r7,20<10>	/* shift left upper bits of integer */
	or	r6,r6,r10	/* form most of integer */
	set	r6,r6,1<30>	/* set hidden one */
	or.c	r6,r0,r6	/* negate integer */
	br.n	FPintov_return
	 addu	r6,r6,1		/* add 1 to get 2''s complement */

maxneg:
	or	r6,r0,r0	/* clear integer */
	br.n	FPintov_return
	 set	r6,r6,1<sign>	/* set sign bit */

	/*
	 * For valid overflows, check to see if the integer overflow user
	 * handler is set. If it is set, then go to user handler, else write
	 * the correctly signed largest integer.
	 */

overflw:
	set	r2,r2,1<oper>
#ifdef HANDLER
	bb0	oper,r3,nohandler	/* do not go to user handler routine */
	bsr	_handler		/* go to user handler routine */
	br	FPintov_return
nohandler:
#endif
	bb0.n	sign,r7,FPintov_return	/* if positive then return */
	 set	r6,r6,31<0>		/* set result to largest positive int */
	or.c	r6,r0,r6		/* negate r6, giving largest negative */
					/* integer */

FPintov_return:
	ld	r1,r31,0		/* load return address from memory */
	jmp	r1

/*
 * Some instructions only have the S2 operations, so clear S1HI and S1LO
 * for those instructions so that the previous contents of S1HI and S1LO
 * do not influence this instruction.
 */

ASLOCAL(FPresoper)
	st	r1, r31, 0
	extu	r10,r9,5<11>	/* extract opcode */
#if 0
	cmp	r11,r10,FSQRTop	/* compare to FSQRT */
	bb1	eq,r11,S1clear	/* clear S1 if instruction only had S2 operand */
#endif
	cmp	r11,r10,INTop	/* compare to INT */
	bb1	eq,r11,S1clear	/* clear S1 if instruction only had S2 operand */
	cmp	r11,r10,NINTop	/* compare to NINT */
	bb1	eq,r11,S1clear	/* clear S1 if instruction only had S2 operand */
	cmp	r11,r10,TRNCop	/* compare to TRNC */
	bb0	eq,r11,opercheck /* check for reserved operands */

ASLOCAL(S1clear)
	or	r5,r0,r0	/* clear any NaN''s, denorms, or infinities */
	or	r6,r0,r0	/* that may be left in S1HI,S1LO from a */
				/* previous instruction */

/*
 * r12 contains the following flags:
 *   bit 9 -- s1sign
 *   bit 8 -- s2sign
 *   bit 7 -- s1nan
 *   bit 6 -- s2nan
 *   bit 5 -- s1inf
 *   bit 4 -- s2inf
 *   bit 3 -- s1zero
 *   bit 2 -- s2zero
 *   bit 1 -- s1denorm
 *   bit 0 -- s2denorm
 */

/*
 * Using code for both single and double precision, check if S1 is either
 * a NaN or infinity and set the appropriate flags in r12. Then check if
 * S2 is a NaN or infinity. If it is a NaN, then branch to the NaN routine.
 */

ASLOCAL(opercheck)
	extu	r10,r5,11<20>	/* internal representation for double */
	bb1.n	s1size,r9,S1NaNdoub /* S1 is double precision */
	 or	r12,r0,r0	/* clear operand flag register */
ASLOCAL(S1NaNsing)
	xor	r10,r10,0x0080	/* internal representation for single */
	ext	r10,r10,8<0>	/* precision is IEEE 8 bits sign extended */
				/* to 11 bits; for real exp. > 0, the */
				/* above instructions gives a result exp. */
				/* that has the MSB flipped and sign */
				/* extended like in the IMPCR */
	cmp	r11,r10,127	/* Is exponent equal to IEEE 255 (here 127) */
	bb1	ne,r11,S2NaN	/* source 1 is not a NaN or infinity */
	mak	r10,r5,20<0>	/* load r10 with upper bits of S1 mantissa */
	extu	r11,r6,3<29>	/* get 3 upper bits of lower word */
	or	r11,r10,r11	/* combine any existing 1 */
	bcnd	eq0,r11,noS1NaNs /* since r11 can only hold 0 or a */
				/* > 0 number, branch to noS1NaN when eq0 */
	br.n	S2NaN		/* see if S2 has a NaN */
	 set	r12,r12,1<s1nan> /* indicate that S1 has a NaN */
ASLOCAL(noS1NaNs)
	br.n	S2NaN		/* check contents of S2 */
	 set	r12,r0,1<s1inf>	/* indicate that S1 has an infinity */

ASLOCAL(S1NaNdoub)
	xor	r10,r10,0x0400	/* precision is the same IEEE 11 bits */
				/* The above instructions gives a result exp. */
				/* that has the MSB flipped and sign */
				/* extended like in the IMPCR */
	cmp	r11,r10,1023	/* Is exp. equal to IEEE 2047 (internal 1023) */
	bb1	ne,r11,S2NaN	/* source 1 is not a NaN or infinity */
	mak	r10,r5,20<0>	/* load r10 with upper bits of S1 mantissa */
	or	r11,r6,r10	/* combine existing 1''s of mantissa */
	bcnd	eq0,r11,noS1NaNd /* since r11 can only hold 0 or a > 0 */
				/* number, branch to noS1NaN when eq0 */
	br.n	S2NaN		/* see if S2 has a NaN */
	 set	r12,r12,1<s1nan> /* indicate that S1 has a NaN */
ASLOCAL(noS1NaNd)
	set	r12,r0,1<s1inf>	/* indicate that S1 has an infinity */

ASLOCAL(S2NaN)
	bb1.n	s2size,r9,S2NaNdoub /* S1 is double precision */
	 extu	r10,r7,11<20>	/* internal representation for double */
ASLOCAL(S2NaNsing)
	xor	r10,r10,0x0080	/* internal representation for single */
	ext	r10,r10,8<0>	/* precision is IEEE 8 bits sign extended */
				/* to 11 bits; for real exp. > 0, the */
				/* above instruction gives a result exp. */
				/* that has the MSB flipped and sign */
				/* extended like in the IMPCR */
	cmp	r11,r10,127	/* Is exponent equal to IEEE 255 (here 127) */
	bb1	ne,r11,inf	/* source 2 is not a NaN or infinity */
	mak	r10,r7,20<0>	/* load r10 with upper bits of S1 mantissa */
	extu	r11,r8,3<29>	/* get 3 upper bits of lower word */
	or	r11,r10,r11	/* combine any existing 1''s */
	bcnd	eq0,r11,noS2NaNs /* since r11 can only hold 0 or a > 0 */
				/* number, branch to noS2NaNs when eq0 */
	br.n	_ASM_LABEL(NaN)	/* branch to NaN routine */
	 set	r12,r12,1<s2nan> /* indicate that s2 has a NaN */
ASLOCAL(noS2NaNs)
	bb0	s1nan,r12, 1f	/* branch to NaN if S1 is a NaN */
	br	_ASM_LABEL(NaN)
1:
	br.n	_ASM_LABEL(infinity) /* If S1 had a NaN we would have */
				/* already branched, and S2 does not have a */
				/* NaN, but it does have an infinity, so */
				/* branch to handle the finity */
	 set	r12,r12,1<s2inf> /* indicate that S2 has an infinity */

ASLOCAL(S2NaNdoub)
	xor	r10,r10,0x0400	/* precision is the same IEEE 11 bits */
				/* The above instruction gives a result exp. */
				/* that has the MSB flipped and sign */
				/* extended like in the IMPCR */
	cmp	r11,r10,1023	/* Is exp. equal to IEEE 2047 (internal 1023) */
	bb1	ne,r11,inf	/* source 2 is not a NaN or infinity */
	mak	r10,r7,20<0>	/* load r10 with upper bits of S2 mantissa */
	or	r11,r8,r10	/* combine existing 1''s of mantissa */
	bcnd	eq0,r11,noS2NaNd /* since r11 can only hold 0 or a > 0 */
				/* number, branch to noS2NaNd when eq0 */
	br.n	_ASM_LABEL(NaN)	/* branch to NaN routine */
	 set	r12,r12,1<s2nan> /* indicate that s2 has a NaN */
ASLOCAL(noS2NaNd)
	bb0	s1nan,r12,1f	/* branch to NaN if S1 is a NaN */
	br	_ASM_LABEL(NaN)
1:
	br.n	_ASM_LABEL(infinity) /* If S1 had a NaN we would have */
				/* already branched, and S2 does not have a */
				/* NaN, but it does have an infinity, so */
				/* branch to handle the finity */
	 set	r12,r12,1<s2inf> /* indicate that S2 has an infinity */

/*
 * If S2 was a NaN, the routine would have already branched to NaN. If S1
 * is a NaN, then branch to NaN. If S1 is not a NaN and S2 is infinity, then
 * we would have already branched to infinity. If S1 is infinity, then branch.
 * If the routine still has not branched, then branch to denorm, the only
 * reserved operand left.
 */

ASLOCAL(inf)
	bb0	s1nan,r12,1f	/* branch if S1 has a NaN and S2 does not */
	br	_ASM_LABEL(NaN)
1:
	bb0	s1inf,r12,2f	/* Neither S1 or S2 has a NaN, and we would */
				/* have branched already if S2 had an */
				/* infinity, so branch if S1 is infinity */
	br	_ASM_LABEL(infinity)
2:
	br	_ASM_LABEL(denorm)	/* branch to denorm, the only */
					/* remaining alternative */

/*
 * First check for an underflow user handler. If there is not one, then
 * branch to the routine to make a denormalized number. Before branching
 * to the underflow user handler, add 192 to a single precision exponent
 * and 1536 to a double precision exponent.
 */

ASLOCAL(FPunderflow)
	st	r1,r31,0	/* save return address */
	set	r2,r2,1<underflow>
	set	r2,r2,1<inexact>
#ifdef HANDLER
	bb0	efunf,r12,FPU_denorm	/* jump to default procedure */
	bb1	destsize,r12,doubleprec	/* double precision destination */
singleprec:
	or.u	r6,r0,0x0c00	/* load exponent adjust 192 */
	br.n	callundhand	/* branch to call handler for user handler */
	 add	r12,r6,r12	/* adjust single precision exponent */
doubleprec:
	or.u	r6,r0,0x6000	/* load exponent adjust 1536 */
	add	r12,r6,r12	/* adjust double precision exponent */
callundhand:
	bsr	_handler	/* call handler for user handler */
	br	Ureturn
#endif

/*
 * Now the floating point number, which has an exponent smaller than what
 * IEEE allows, must be denormalized. Denormalization is done by calculating
 * the difference between a denormalized exponent and an underflow exponent
 * and shifting the mantissa by that amount. A one may need to be subtracted
 * from the LSB if a one was added during rounding.
 * r9 is used to contain the guard, round, sticky, and an inaccuracy bit in
 * case some bits were shifted off the mantissa during denormalization.
 * r9 will contain:
 *   bit 4 -- new addone if one added during rounding after denormalization
 *   bit 3 -- inaccuracy flag caused by denormalization or pre-denormalization
 *            inexactness
 *   bit 2 -- guard bit of result
 *   bit 1 -- round bit of result
 *   bit 0 -- sticky bit of result
 */

FPU_denorm:
	bb1.n	destsize,r12,Udouble 	/* denorm for double */
	 extu	r9,r10,3<26>	/* load r9 with grs */
Usingle:
	mak	r5,r10,21<3>	/* extract high 21 bits of mantissa */
	extu	r6,r11,3<29>	/* extract low 3 bits of mantissa */
	or	r11,r5,r6	/* form 24 bits of mantissa */

/* See if the addone bit is set and unround if it is. */
	bb0.n	25,r10,nounrounds /* do not unround if addone bit clear */
	 extu	r6,r12,12<20>	/* extract signed exponent from IMPCR */
unrounds:
	subu	r11,r11,1	/* subtract 1 from mantissa */

/*
 * If the hidden bit is cleared after subtracting the one, then the one added
 * during the rounding must have propagated through the mantissa. The exponent
 * will need to be decremented.
 */
	bb1	23,r11,nounrounds /* if hidden bit is set,then exponent */
				/* does not need to be decremented */
decexps:
	sub	r6,r6,1		/* decrement exponent 1 */
	set	r11,r11,1<23>	/* set the hidden bit */

/*
 * For both single and double precision, there are cases where it is easier
 * and quicker to make a special case. Examples of this are if the shift
 * amount is only 1 or 2, or all the mantissa is shifted off, or all the
 * mantissa is shifted off and it is still shifting, or, in the case of
 * doubles, if the shift amount is around the boundary of MANTLO and MANTHI.
 */

nounrounds:
	or	r8,r0,lo16(0x00000f81)	/* load r8 with -127 in decimal */
					/* for lowest 12 bits */
	sub	r7,r8,r6	/* find difference between two exponents, */
				/* this amount is the shift amount */
	cmp	r6,r7,3		/* check to see if r7 contains 3 or more */
	bb1	ge,r6,threesing	/* br to code that handles shifts of >=3 */
	cmp	r6,r7,2		/* check to see if r7 contains 2 */
	bb1	eq,r6,twosing	/* br to code that handles shifts of 2 */
one:
	rot	r9,r9,0<1>	/* rotate roundoff register once, this places */
				/* guard in round and round in sticky */
	bb0	31,r9,nosticky1s /* do not or round and sticky if sticky is */
				/* 0, this lost bit will be cleared later */
	set	r9,r9,1<0>	/* or round and sticky */
nosticky1s:
	bb0	0,r11,guardclr1s /* do not set guard bit if LSB = 0 */
	set	r9,r9,1<2>	/* set guard bit */
guardclr1s:
	extu	r11,r11,31<1>	/* shift mantissa right 1 */
	br.n	round		/* round result */
	 mak	r9,r9,3<0>	/* clear bits lost during rotation */

twosing:
	rot	r9,r9,0<2>	/* rotate roundff register twice, this places */
				/* guard in sticky */
	bb0	30,r9,nosticky2s /* do not or guard and sticky if stick is 0 */
				/* this lost bit will be cleared later */
	br.n	noround2s	/* skip or old guard and old round if old */
				/* sticky set */
	 set	r9,r9,1<0>	/* or guard and sticky */
nosticky2s:
	bb0	31,r9,noround2s /* do not or guard and round if round is 0 */
				/* this lost bit will be cleared later */
	set	r9,r9,1<0>	/* or guard and round */
noround2s:
	bb0	0,r11,roundclr2s /* do not set round bit if LSB = 0 */
	set	r9,r9,1<1>	/* set round bit */
roundclr2s:
	bb0	1,r11,guardclr2s /* do not set guard bit if LSB + 1 = 0 */
	set	r9,r9,1<2>	/* set guard bit */
guardclr2s:
	extu	r11,r11,30<2>	/* shift mantissa right 2 */
	br.n	round		/* round result */
	 mak	r9,r9,3<0>	/* clear bits lost during rotation */

threesing:
	bb1	0,r9,noguard3s	/* check sticky initially */
				/* sticky is set, forget most of the oring */
nosticky3s:
	bb0	1,r9,noround3s	/* check round initially, do not set sticky */
	br.n	noguard3s	/* forget most of the rest of oring */
	 set	r9,r9,1<0>	/* if round is clear,set sticky if round set */
noround3s:
	bb0.n	2,r9,noguard3s	/* check guard initially, do not set sticky */
	 clr	r9,r9,2<1>	/* clear the original guard and round for when */
				/* you get to round section */
	set	r9,r9,1<0>	/* if guard is clear,set sticky if guard set */
noguard3s:
	cmp	r6,r7,23	/* check if # of shifts is <=23 */
	bb1	gt,r6,s24	/* branch to see if shifts = 24 */
	sub	r6,r7,2		/* get number of bits to check for sticky */
	mak	r6,r6,5<5>	/* shift width into width field */
	mak	r8,r11,r6	/* mask off shifted bits -2 */
	ff1	r8,r8		/* see if r8 has any ones */
	bb1	5,r8,nostky23	/* do not set sticky if no ones found */
	set	r9,r9,1<0>	/* set sticky bit */
nostky23:
	or	r8,r0,34	/* start code to get new mantissa plus two */
				/* extra bits for new round and new guard */
				/* bits */
	subu	r8,r8,r7
	mak	r8,r8,5<5>	/* shift field width into second five bits */
	extu	r6,r6,5<5>	/* shift previous shifted -2 into offset field */
	or	r6,r6,r8	/* complete field */
	extu	r11,r11,r6	/* form new mantissa with two extra bits */

	bb0	0,r11,nornd3s	/* do not set new round bit */
	set	r9,r9,1<1>	/* set new round bit */
nornd3s:
	bb0	1,r11,nogrd3s	/* do not set new guard bit */
	set	r9,r9,1<2>	/* set new guard bit */
nogrd3s:
	br.n	round		/* round mantissa */
	 extu	r11,r11,30<2>	/* shift off remaining two bits */

s24:
	cmp	r6,r7,24	/* check to see if # of shifts is 24 */
	bb1	gt,r6,s25	/* branch to see if shifts = 25 */
	bb1	0,r9,nostky24	/* skip checking if old sticky set */
	extu	r8,r11,22<0>	/* prepare to check bits that will be shifted */
				/* into the sticky */
	ff1	r8,r8		/* see if there are any 1''s */
	bb1	5,r8,nostky24	/* do not set sticky if no ones found */
	set	r9,r9,1<0>	/* set sticky bit */
nostky24:
	bb0	22,r11,nornd24	/* do not set new round bit */
	set	r9,r9,1<1>	/* set new round bit */
nornd24:
	set	r9,r9,1<2>	/* set new guard bit,this is hidden bit */
	br.n	round		/* round mantissa */
	 or	r11,r0,r0	/* clear r11, all of mantissa shifted off */

s25:
	cmp	r6,r7,25	/* check to see if # of shifts is 25 */
	bb1	gt,r6,s26	/* branch to execute for shifts => 26 */
	bb1	0,r9,nostky25	/* skip checking if old sticky set */
	extu	r8,r11,23<0>	/* prepare to check bits that will be shifted */
				/* into the sticky */
	ff1	r8,r8		/* see if there are any 1''s */
	bb1	5,r8,nostky25	/* do not set sticky if no ones found */
	set	r9,r9,1<0>	/* set sticky bit */
nostky25:
	set	r9,r9,1<1>	/* set new round bit,this is hidden bit */
	clr	r9,r9,1<2>	/* clear guard bit since nothing shifted in */
	br.n	round		/* round and assemble result */
	 or	r11,r0,r0	/* clear r11, all of mantissa shifted off */

s26:
	set	r9,r9,1<0>	/* set sticky bit,this contains hidden bit */
	clr	r9,r9,2<1>	/* clear guard and round bits since nothing */
				/* shifted in */
	br.n	round		/* round and assemble result */
	 or	r11,r0,r0	/* clear mantissa */

Udouble:
	mak	r5,r10,21<0>	/* extract upper bits of mantissa */
	bb0.n	25,r10,nounroundd /* do not unround if addone bit clear */
	 extu	r6,r12,12<20>	/* extract signed exponenet from IMPCR */
unroundd:
	or	r8,r0,1
	subu.co	r11,r11,r8	/* subtract 1 from mantissa */
	subu.ci	r5,r5,r0	/* subtract borrow from upper word */
	bb1	20,r5,nounroundd /* if hidden bit is set, then exponent does */
				/* not need to be decremented */
decexpd:
	sub	r6,r6,1		/* decrement exponent 1 */
	set	r5,r5,1<20>	/* set the hidden bit */

nounroundd:
	or	r8,r0,lo16(0x00000c01) /* load r8 with -1023 in decimal */
				/* for lowest 12 bits */
	sub	r7,r8,r6	/* find difference between two exponents, */
				/* this amount is the shift amount */
	cmp	r6,r7,3		/* check to see if r7 contains 3 or more */
	bb1	ge,r6,threedoub	/* br to code that handles shifts of >=3 */
	cmp	r6,r7,2		/* check to see if r7 contains 2 */
	bb1	eq,r6,twodoub	/* br to code that handles shifts of 2 */

onedoub:
	rot	r9,r9,0<1>	/* rotate roundoff register once, this places */
				/* guard in round and round in sticky */
	bb0	31,r9,nosticky1d/* do not or round and sticky if sticky is 0 */
				/* this lost bit will be cleared later */
	set	r9,r9,1<0>	/* or old round and old sticky into new sticky */
nosticky1d:
	bb0	0,r11,guardclr1d /* do not set new guard bit if old LSB = 0 */
	set	r9,r9,1<2>	/* set new guard bit */
guardclr1d:
	extu	r11,r11,31<1>	/* shift lower mantissa over 1 */
	mak	r6,r5,1<31>	/* shift off low bit of high mantissa */
	or	r11,r6,r11	/* load high bit onto lower mantissa */
	extu	r5,r5,20<1>	/* shift right once upper 20 bits of mantissa */
	br.n	round		/* round mantissa and assemble result */
	 mak	r9,r9,3<0>	/* clear bits lost during rotation */

twodoub:
	rot	r9,r9,0<2>	/* rotate roundoff register twice, this places */
				/* old guard into sticky */
	bb0	30,r9,nosticky2d /* do not or old guard and old sticky if */
				/* old sticky is 0 */
	br.n	noround2d	/* skip or of old guard and old round if old */
				/* sticky set */
	 set	r9,r9,1<0>	/* or old guard and old sticky into new sticky */
nosticky2d:
	bb0	31,r9,noround2d	/* do not or old guard and old round if */
				/* old round is 0 */
	set	r9,r9,1<0>	/* or old guard and old round into new sticky */
noround2d:
	bb0	0,r11,roundclr2d /* do not set round bit if old LSB = 0 */
	set	r9,r9,1<1>	/* set new round bit */
roundclr2d:
	bb0	1,r11,guardclr2d /* do not set guard bit if old LSB + 1 = 0 */
	set	r9,r9,1<2>	/* set new guard bit */
guardclr2d:
	extu	r11,r11,30<2>	/* shift lower mantissa over 2 */
	mak	r6,r5,2<30>	/* shift off low bits of high mantissa */
	or	r11,r6,r11	/* load high bit onto lower mantissa */
	extu	r5,r5,19<2>	/* shift right twice upper 19 bits of mantissa */
	br.n	round		/* round mantissa and assemble result */
	 mak	r9,r9,3<0>	/* clear bits lost during rotation */

threedoub:
	bb1	0,r9,noguard3d	/* checky sticky initially */
				/* sticky is set, forget most of rest of oring */
nosticky3d:
	bb0	1,r9,noround3d	/* check old round, do not set sticky if */
				/* old round is clear, set otherwise */
	br.n	noguard3d	/* sticky is set, forget most of rest of oring */
	 set	r9,r9,1<0>	/* set sticky if old round is set */
noround3d:
	bb0	2,r9,noguard3d	/* check old guard, do not set sticky if 0 */
	clr	r9,r9,2<1>	/* clear the original guard and round for when */
				/* you get to round section */
	set	r9,r9,1<0>	/* set sticky if old guard is set */
noguard3d:
	cmp	r6,r7,32	/* do I need to work with a 1 or 2 word mant. */
				/* when forming sticky, round and guard */
	bb1	gt,r6,d33	/* jump to code that handles 2 word mantissas */
	sub	r6,r7,2		/* get number of bits to check for sticky */
	mak	r6,r6,5<5>	/* shift width into width field */
	mak	r8,r11,r6	/* mask off shifted bits -2 */
	ff1	r8,r8		/* see if r8 has any ones */
	bb1	5,r8,nostky32	/* do not set sticky if no ones found */
	set	r9,r9,1<0>	/* set sticky bit */
nostky32:
	or	r8,r0,34	/* start code to get new mantissa plus two */
				/* extra bits for new round and new guard bits, */
				/* the upper word bits will be shifted after */
				/* the round and guard bits are handled */
	subu	r8,r8,r7
	mak	r8,r8,5<5>	/* shift field width into second five bits */
	extu	r6,r6,5<5>	/* shift previous shifted -2 into offset field */
	or	r6,r6,r8	/* complete bit field */
	extu	r11,r11,r6	/* partially form new low mantissa with 2 more */
				/* bits */
	bb0	0,r11,nornd32d	/* do not set new round bit */
	set	r9,r9,1<1>	/* set new round bit */
nornd32d:
	bb0	1,r11,nogrd32d	/* do not set new guard bit */
	set	r9,r9,1<2>	/* set new guard bit */
nogrd32d:
	extu	r11,r11,30<2>	/* shift off remaining two bits */
	mak	r6,r7,5<5>	/* shift field width into second 5 bits, if the */
				/* width is 32, then these bits will be 0 */
	or	r8,r0,32	/* load word length into r8 */
	sub	r8,r8,r7	/* form offset for high bits moved to low word */
	or	r6,r6,r8	/* form complete bit field */
	mak	r6,r5,r6	/* get shifted bits of high word */
	or	r11,r6,r11	/* form new low word of mantissa */
	bcnd	ne0,r8,regular33 /* do not adjust for special case of r8 */
	br.n	round		/* containing zeros, which would cause */
	 or	r5,r0,r0	/* all of the bits to be extracted under */
				/* the regular method */
regular33:
	mak	r6,r7,5<0>	/* place lower 5 bits of shift into r6 */
	mak	r8,r8,5<5>	/* shift r8 into width field */
	or	r6,r6,r8	/* form field for shifting of upper bits */
	br.n	round		/* round and assemble result */
	 extu	r5,r5,r6	/* form new high word mantissa */

d33:
	cmp	r6,r7,33	/* is the number of bits to be shifted is 33? */
	bb1	gt,r6,d34	/* check to see if # of bits is 34 */
	bb1	0,r9,nostky33	/* skip checking if old sticky set */
	mak	r6,r11,31<0>	/* check bits that will be shifted into sticky */
	ff1	r8,r8		/* check for ones */
	bb1	5,r8,nostky33	/* do not set sticky if there are no ones */
	set	r9,r9,1<0>	/* set new sticky bit */
nostky33:
	bb0	31,r11,nornd33	/* do not set round if bit is not a 1 */
	set	r9,r9,1<1>	/* set new round bit */
nornd33:
	bb0	0,r5,nogrd33	/* do not set guard bit if bit is not a 1 */
	set	r9,r9,1<2>	/* set new guard bit */
nogrd33:
	extu	r11,r5,31<1>	/* shift high bits into low word */
	br.n	round		/* round and assemble result */
	 or	r5,r0,r0	/* clear high word */

d34:
	cmp	r6,r7,34	/* is the number of bits to be shifted 34? */
	bb1	gt,r6,d35	/* check to see if # of bits is >= 35 */
	bb1	0,r9,nostky34	/* skip checking if old sticky set */
	ff1	r8,r11		/* check bits that will be shifted into sticky */
	bb1	5,r8,nostky34	/* do not set sticky if there are no ones */
	set	r9,r9,1<0>	/* set new sticky bit */
nostky34:
	bb0	0,r5,nornd34	/* do not set round if bit is not a 1 */
	set	r9,r9,1<1>	/* set new round bit */
nornd34:
	bb0	1,r5,nogrd34	/* do not set guard bit if bit is not a 1 */
	set	r9,r9,1<2>	/* set new guard bit */
nogrd34:
	extu	r11,r5,30<2>	/* shift high bits into low word */
	br.n	round		/* round and assemble result */
	 or	r5,r0,r0	/* clear high word */

d35:
	cmp	r6,r7,52	/* see if # of shifts is 35 <= X <= 52 */
	bb1	gt,r6,d53	/* check to see if # of shifts is 52 */
	bb1.n	0,r9,nostky35	/* skip checking if old sticky set */
	 sub	r7,r7,34	/* subtract 32 from # of shifts so that opera- */
				/* tions can be done on the upper word, and */
				/* then subtract two more checking guard and */
				/* sticky bits */
	ff1	r8,r11		/* see if lower word has a bit for sticky */
	bb1	5,r8,stkycheck35 /* see if upper word has any sticky bits	*/
	br.n	nostky35	/* quit checking for sticky */
	 set	r9,r9,1<0>	/* set sticky bit */
stkycheck35:
	mak	r6,r7,5<5>	/* place width into width field */
	mak	r8,r5,r6	/* mask off shifted bits - 2 */
	ff1	r8,r8		/* see if r8 has any ones */
	bb1	5,r8,nostky35	/* do not set sticky if no ones found */
	set	r9,r9,1<0>	/* set sticky bit */
nostky35:
	or	r8,r0,32	/* look at what does not get shifted off plus */
				/* round and sticky, remember that the r7 value */
				/* was adjusted so that it did not include */
				/* new round or new sticky in shifted off bits */
	subu	r8,r8,r7	/* complement width */
	mak	r8,r8,5<5>	/* shift width into width field */
	or	r8,r7,r8	/* add offset field */
	extu	r11,r5,r8	/* extract upper bits into low word */
	bb0	0,r11,nornd35	/* do not set new round bit */
	set	r9,r9,1<1>	/* set new round bit */
nornd35:
	bb0	1,r11,nogrd35	/* do not set new guard bit */
	set	r9,r9,1<2>	/* set new guard bit */
nogrd35:
	extu	r11,r11,30<2>	/* shift off remaining guard and round bits */
	br.n	round		/* round and assemble result */
	 or	r5,r0,r0	/* clear high word */

d53:
	cmp	r6,r7,53	/* check to see if # of shifts is 53 */
	bb1	gt,r6,d54	/* branch to see if shifts = 54 */
	bb1	0,r9,nostky53	/* skip checking if old sticky set */
	ff1	r8,r11		/* see if lower word has a bit for sticky */
	bb1	5,r8,stkycheck53 /* see if upper word has any sticky bits	*/
	br.n	nostky53	/* quit checking for sticky */
	 set	r9,r9,1<0>	/* set sticky bit */
stkycheck53:
	mak	r6,r5,19<0>	/* check bits that are shifted into sticky */
	ff1	r8,r6		/* see if r6 has any ones */
	bb1	5,r8,nostky53	/* do not set sticky if no ones found */
	set	r9,r9,1<0>	/* set sticky bit */
nostky53:
	bb0	19,r5,nornd53	/* do not set new round bit */
	set	r9,r9,1<1>	/* set new round bit */
nornd53:
	set	r9,r9,1<2>	/* set new guard bit,this is hidden bit */
	or	r5,r0,r0	/* clear high word */
	br.n	round		/* round and assemble result */
	 or	r11,r0,r0	/* clear low word */

d54:
	cmp	r6,r7,54	/* check to see if # of shifts is 54 */
	bb1	gt,r6,d55	/* branch to execute for shifts =>55 */
	bb1	0,r9,nostky54	/* skip checking if old sticky set */
	ff1	r8,r11		/* see if lower word has a bit for sticky */
	bb1	5,r8,stkycheck54 /* see if upper word has any sticky bits	*/
	br.n	nostky54	/* quit checking for sticky */
	 set	r9,r9,1<0>	/* set sticky bit */
stkycheck54:
	mak	r6,r5,20<0>	/* check bits that are shifted into sticky */
	ff1	r8,r6		/* see if r6 has any ones */
	bb1	5,r8,nostky54	/* do not set sticky if no ones found */
	set	r9,r9,1<0>	/* set sticky bit */
nostky54:
	set	r9,r9,1<1>	/* set new round bit,this is hidden bit */
	clr	r9,r9,1<2>	/* clear guard bit since nothing shifted in */
	or	r5,r0,r0	/* clear high word */
	br.n	round		/* round and assemble result */
	 or	r11,r0,r0	/* clear low word */

d55:
	set	r9,r9,1<0>	/* set new sticky bit,this contains hidden bit */
	clr	r9,r9,2<1>	/* clear guard and round bits since nothing */
				/* shifted in */
	or	r5,r0,r0	/* clear high word */
	or	r11,r0,r0	/* clear low word */


/* The first item that the rounding code does is see if either guard, round, */
/* or sticky is set. If all are clear, then there is no denormalization loss */
/* and no need to round, then branch to assemble answer. */
/* For rounding, a branch table is set up. The left two most bits are the */
/* rounding mode. The third bit is either the LSB of the mantissa or the */
/* sign bit, depending on the rounding mode. The three LSB''s are the guard, */
/* round and sticky bits. */

round:
	ff1	r8,r9		/* see if there is denormalization loss */
	bb1	5,r8,assemble	/* no denormalization loss or inexactness */
	extu	r6,r10,2<modelo> /* extract rounding mode */
	bb1.n	modehi,r10,signext /* use sign bit instead of LSB */
	 mak	r6,r6,2<4>	/* shift over rounding mode */
	extu	r7,r11,1<0>	/* extract LSB */
	br.n	grs		/* skip sign extraction */
	 mak	r7,r7,1<3>	/* shift over LSB */
signext:
	extu	r7,r10,1<31>	/* extract sign bit */
	mak	r7,r7,1<3>	/* shift sign bit over */
grs:
	or	r6,r6,r7
	or	r6,r6,r9	/* or in guard, round, and sticky */
	or.u	r1,r0,hi16(roundtable) /* form address of branch table */
	or	r1,r1,lo16(roundtable)
	lda	r6,r1[r6]	/* scale offset into branch table */
	jmp.n	r6		/* jump to branch table */
	 set	r9,r9,1<3>	/* set inexact flag in r9 */

roundtable:
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	addone
	br	addone
	br	addone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	addone
	br	addone
	br	addone
	br	addone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	addone
	br	addone
	br	addone
	br	addone
	br	addone
	br	addone
	br	addone
	br	noaddone
	br	addone
	br	addone
	br	addone
	br	addone
	br	addone
	br	addone
	br	addone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone

/* Round by adding a one to the LSB of the mantissa. */
addone:
	or	r6,r0,1		/* load a 1 into r6 so that add.co can be used */
	add.co	r11,r11,r6	/* add a one to the lower word of result */
	bb0.n	destsize,r12,noaddone /* single result,forget carry */
	 set	r9,r9,1<4>	/* indicate that a 1 has been added */
	add.ci	r5,r5,r0	/* propagate carry into high word */


/* Branch to inexact user handler if there is one. */

noaddone:
	set	r2,r2,1<inexact>
	set	r2,r2,1<underflow>
#ifdef HANDLER
	bb1	efinx,r12,modformdef	/* branch to modify form for user */
					/* handler */
#endif


/* Assemble the result of the denormalization routine for writeback to the */
/* destination register. The exponent of a denormalized number is zero, */
/* so simply assemble the sign and the new mantissa. */

assemble:
	bb1	destsize,r12,doubassem	/* assemble double result */
	bb0	sign,r10,exassems	/* exit assemble if sign is zero */
	set	r11,r11,1<sign>		/* make result negative */
exassems:
	br	Ureturn	

doubassem:
	bb0.n	sign,r10,signclr	/* do not set sign in r10 */
	 or	r10,r5,r0		/* load high word from r5 into r10 */
	set	r10,r10,1<sign>		/* high word with sign loaded */
signclr:
	br	Ureturn


/* modfordef modifies the result of denormalization to the input format of */
/* the inexact user handler. This input format is the same format that */
/* MANTHI, MANTLO, and IMPCR were initially loaded with. */

#ifdef HANDLER
modformdef:
	clr	r12,r12,12<20>	/* clear result exponent,IMPCR complete */
	clr	r10,r10,4<25>	/* clear old guard,round,sticky,and addone */
	mak	r5,r9,3<26>	/* make grs field */
	bb0.n	4,r9,newaddone	/* do not set new addone in MANTHI */
	 or	r10,r5,r10	/* or in new grs field */
	set	r10,r10,1<25>	/* set new addone */
newaddone:
	bb1.n	destsize,r12,moddefd /* branch to handle double precision */
	 clr	r10,r10,21<0>	/* clear upper bits of old mantissa */
moddefs:
	extu	r5,r11,20<3>	/* extract upper bits */
	or	r10,r5,r10	/* MANTHI complete */
	bsr.n	_handler	/* execute user handler for inexact */
	 rot	r11,r11,0<3>	/* MANTLO complete */
	br	Ureturn
moddefd:
	bsr.n	_handler	/* execute user handler for inexact */
	 or	r10,r5,r10	/* MANTHI complete,r5 should be set to OR */
#endif

/* Return to fpui. */

Ureturn:
	ld	r1,r31,0	/* load return address */
	jmp	r1

/*
 * FPoverflow
 */
/* If the overflow user handler bit is not set, then the inexact bit in the */
/* FPSR is set, and the inexact user handler bit is checked. If it is set, */
/* then the inexact user handler is executed, else the default routine for */
/* overflow is executed. */

ASLOCAL(FPoverflow)
	st	r1,r31,0	/* save return address */
	set	r2,r2,1<overflow>
	set	r2,r2,1<inexact>
#ifdef HANDLER
	bb1	efovf,r12,hand	/* go to user handler if bit set for overflow */
	bb0	efinx,r12,nohandler/* if userhandler for inexact not set,then */
				/* round result */
	br	callhandler	/* branch to user handler for inexact */

/* Before the overflow user handler is executed, the exponent is modified */
/* by subtracting 192 for single precision and 1536 for double precision. */

hand:
	bb1	10,r12,doubleprec /* double precision result */
singleprec:
	or.u	r5,r0,0x0c00	/* load exponent adjust */
	br.n	callhandler	/* prepare to call user handler */
	 subu	r12,r12,r5	/* adjust single precision exponent */
doubleprec:
	or.u	r5,r0,0x6000	/* load exponent adjust */
	subu	r12,r12,r5	/* adjust double precision exponent */
callhandler:
	bsr	_handler	/* branch to common handler routine */
	br	return
#endif

/* Determine which rounding mode to use for the default procedure. */

nohandler:
	bb1	modehi,r10,signed /* mode is either round toward pos. or neg. */
	bb0	modelo,r10,OFnearest /* rounding mode is round nearest */
	br	OFzero		/* rounding mode is round zero */
signed:
	bb0	modelo,r10,OFnegative /* rounding mode is round negative */
	br	positive	/* rounding mode is round positive */


/* In the round toward nearest mode, positive values are rounded to */
/* positive infinity and negative values are loaded toward negative infinity. */
/* The value for single or double precision is loaded from a data table. */

OFnearest:
	bb1.n	destsize,r12,neardouble	/* branch to neardouble of */
					/* double result */
	 mask.u	r5,r10,0x8000		/* mask off sign bit from MANTHI */
	or.u	r11,r0,hi16(0x7f800000)	/* load single infinity constant */
	or	r11,r11,lo16(0x7f800000)
	br.n	return			/* return with result */
	 or	r11,r5,r11		/* adjust sign */
neardouble:
	or	r11,r0,r0		/* load lower word of infinity */
	or.u	r10,r0,hi16(0x7ff00000)	/* load upper word of infinity */
	or	r10,r10,lo16(0x7ff00000)
	br.n	return			/* return with result */
	 or	r10,r5,r10		/* adjust sign */


/* In the round toward zero mode, positive values are rounded to the largest */
/* postive finite number and negative values are rounded toward the largest */
/* negative finite number. */
/* The value for single or double precision is loaded from a data table. */

OFzero:
	bb1.n	destsize,r12,zerodouble	/* branch to zerodouble of */
					/* double result */
	 mask.u	r5,r10,0x8000		/* mask off sign bit from MANTHI */
	or.u	r11,r0,hi16(0x7f7fffff)	/* load single finite number constant */
	or	r11,r11,lo16(0x7f7fffff)
	br.n	return			/* return with result */
	 or	r11,r5,r11		/* adjust sign */
zerodouble:
	set	r11,r0,0<0>		/* load lower word of finite number */
	or.u	r10,r0,hi16(0x7fefffff)	/* load upper word of finite number */
	or	r10,r10,lo16(0x7fefffff)
	br.n	return			/* return with result */
	 or	r10,r5,r10		/* adjust sign */


/* In the round toward positve mode, positive values are rounded to */
/* postive infinity and negative values are loaded toward the largest */
/* negative finite number. */
/* The value for single or double precision is loaded from a data table. */

positive:
	bb1	destsize,r12,posdouble	/* branch to section for double result */
possingle:
	bb1	sign,r10,possingleneg	/* branch to section for negatives */
possinglepos:
	or.u	r11,r0,hi16(0x7f800000)	/* load single infinity constant */
	br.n	return			/* return with result */
	 or	r11,r11,lo16(0x7f800000)
possingleneg:
	or.u	r11,r0,hi16(0x7f7fffff)	/* load single finite number constant */
	or	r11,r11,lo16(0x7f7fffff)
	br.n	return			/* return with result */
	 set	r11,r11,1<sign>		/* set sign for negative */
posdouble:
	bb1	sign,r10,posdoubleneg	/* branch to negative double results */
posdoublepos:
	or	r11,r0,r0		/* load lower word of double infinity */
	or.u	r10,r0,hi16(0x7ff00000)	/* load upper word of infinity */
	br.n	return			/* return with result */
	 or	r10,r10,lo16(0x7ff00000)
posdoubleneg:
	set	r11,r0,0<0>		/* load lower word of finite number */
	or.u	r10,r0,hi16(0x7fefffff)	/* load upper word of finite number */
	or	r10,r10,lo16(0x7fefffff)
	br.n	return			/* return with result */
	 set	r10,r10,1<sign>		/* set sign for negative */


/* In the round toward negative mode, positive values are rounded to the largest */
/* postive finite number and negative values are rounded to negative infinity. */
/* The value for single or double precision is loaded from a data table. */

OFnegative:
	bb1	destsize,r12,negdouble	/* branch to section for double result */
negsingle:
	bb1	sign,r10,negsingleneg	/* branch to section for negatives */
negsinglepos:
	or.u	r11,r0,hi16(0x7f7fffff)	/* load single finite number constant */
	br.n	return			/* return with result */
	 or	r11,r11,lo16(0x7f7fffff)
negsingleneg:
	or.u	r11,r0,hi16(0x7f800000)	/* load single infinity constant */
	or	r11,r11,lo16(0x7f800000)
	br.n	return			/* return with result */
	 set	r11,r11,1<sign>		/* set sign for negative */
negdouble:
	bb1	sign,r10,negdoubleneg	/* branch to negative double results */
negdoublepos:
	set	r11,r0,0<0>		/* load lower word of finite number */
	or.u	r10,r0,hi16(0x7fefffff)	/* load upper word of finite number */
	br.n	return			/* return with result */
	 or	r10,r10,lo16(0x7fefffff)
negdoubleneg:
	or	r11,r0,r0		/* load lower word of double infinity */
	or.u	r10,r0,hi16(0x7ff00000)	/* load upper word of infinity */
	or	r10,r10,lo16(0x7ff00000)
	set	r10,r10,1<sign>		/* set sign for negative */

return:
	ld	r1,r31,0		/* ld return address */
	jmp	r1

	data


/* If either S1 or S2 is a signalling NaN, then set the invalid operation */
/* bit of the FPSR. If the invalid operation user handler flag is set and */
/* then NaN is signalling, then branch to the handler routine to go to the */
/* user handler. */
/* If S1 is the only NaN or one of two NaN''s, then write */
/* a quiet S1 to the result. A signalling NaN must be made quiet before */
/* it can be written, but a signalling S2 is not modified in this routine */
/* if S1 is a NaN. */
	text
ASLOCAL(NaN)
	bb0.n	s1nan,r12,S2sigcheck	/* S1 is not a NaN */
	 st	r1,r31,0		/* save return address */
	bb1	sigbit,r5,S2sigcheck	/* S1 is not a signaling NaN */
	set	r2,r2,1<oper>
#ifdef HANDLER
	bb0	oper,r3,S1nohandler	/* branch if no user handler */
	bsr	_handler		/* branch to handler */
	br	FPnan_return
ASLOCAL(S1nohandler)
#endif
	br.n	S1write		/* FPSR bit already set, S1 is made quiet, */
				/* and since we always write S1 if it is a */
				/* NaN, write S1 and skip rest of routine */
	 set	r5,r5,1<sigbit>	/* make S1 a quiet NaN */

ASLOCAL(S2sigcheck)
	bb0	s2nan,r12,S1write	/* S2 is not a NaN */
	bb1	sigbit,r7,S1write	/* S2 is not a signaling NaN */
	set	r2,r2,1<oper>
#ifdef HANDLER
	bb0	oper,r3,S2nohandler	/* branch if no user handler */
	bsr	_handler		/* branch to handler */
	br	FPnan_return
#endif

ASLOCAL(S2nohandler)
	set	r7,r7,1<sigbit>	/* make S2 a quiet NaN */


/* Write a single or double precision quiet NaN unless the opeation is FCMP. */
/* If the operation is FCMP, then set the not comparable bit in the result. */

ASLOCAL(S1write)
	bb0	s1nan,r12,S2write /* do not write S1 if it is not a NaN */
	extu	r10,r9,5<11>	/* extract opcode */
	cmp	r11,r10,FCMPop	/* compare to FCMP */
	bb1	ne,r11,S1noFCMP	/* operation is not FCMP */
	set	r6,r0,1<nc>	/* set the not comparable bit */
	br.n	FPnan_return
	 set	r6,r6,1<ne>	/* set the not equal bit */
ASLOCAL(S1noFCMP)
	bb1.n	dsize,r9,wrdoubS1 /* double destination */
	 set	r5,r5,11<20>	/* set all exponent bits to 1 */
/* The single result will be formed the same way whether S1 is a single or double */
ASLOCAL(wrsingS1)
	mak	r10,r5,28<3>	/* wipe out extra exponent bits */
	extu	r11,r6,3<29>	/* get lower three bits of mantissa */
	or	r10,r10,r11	/* combine all of result except sign */
	clr	r6,r5,31<0>	/* clear all but sign */
	br.n	FPnan_return
	 or	r6,r6,r10	/* form result */

ASLOCAL(wrdoubS1)
	set	r6,r6,29<0>	/* set extra bits of lower word */
	br	FPnan_return	/* no modification necessary for writing */
				/* double to double, so return */

ASLOCAL(S2write)
	extu	r10,r9,5<11>	/* extract opcode */
	cmp	r11,r10,FCMPop	/* compare to FCMP */
	bb1.n	ne,r11,S2noFCMP	/* operation is not FCMP */
	 set	r7,r7,11<20>	/* set all exponent bits to 1 */
	set	r6,r0,1<nc>	/* set the not comparable bit */
	br.n	FPnan_return
	 set	r6,r6,1<ne>	/* set the not equal bit */
ASLOCAL(S2noFCMP)
	bb1.n	dsize,r9,wrdoubS2 /* double destination */
	 set	r5,r5,11<20>	/* set all exponent bits to 1 */
/* The single result will be formed the same way whether S1 is a single or double */
ASLOCAL(wrsingS2)
	mak	r10,r7,28<3>	/* wipe out extra exponent bits */
	extu	r11,r8,3<29>	/* get lower three bits of mantissa */
	or	r10,r10,r11	/* combine all of result except sign */
	clr	r6,r7,31<0>	/* clear all but sign */
	br.n	FPnan_return
	 or	r6,r6,r10	/* form result */

ASLOCAL(wrdoubS2)
	set	r6,r8,29<0>	/* set extra bits of lower word */

/* Return from this subroutine with the result. */

ASLOCAL(FPnan_return)
				/* no modification necessary for writing */
				/* double to double, so return */
	ld	r1,r31, 0	/* retrieve return address */
	jmp	r1

	data

/*
 * infinity
 */

/* Extract the opcode, compare to a constant, and branch to the code */
/* for the instruction. */

ASLOCAL(infinity)
	extu	r10,r9,5<11>	/* extract opcode */
	cmp	r11,r10,FADDop	/* compare to FADD */
	bb1.n	eq,r11,FADD	/* operation is FADD */
	 st	r1,r31,0	/* save return address */
	cmp	r11,r10,FSUBop	/* compare to FSUB */
	bb1	eq,r11,FSUB	/* operation is FSUB */
	cmp	r11,r10,FCMPop	/* compare to FCMP */
	bb1	eq,r11,FCMP	/* operation is FCMP */
	cmp	r11,r10,FMULop	/* compare to FMUL */
	bb1	eq,r11,FMUL	/* operation is FMUL */
	cmp	r11,r10,FDIVop	/* compare to FDIV */
	bb1	eq,r11,FDIV	/* operation is FDIV */
#if 0
	cmp	r11,r10,FSQRTop	/* compare to FSQRT */
	bb1	eq,r11,FSQRT	/* operation is FSQRT */
#endif
	cmp	r11,r10,INTop	/* compare to INT */
	bb1	eq,r11,FP_inf_overflw /* operation is INT */
	cmp	r11,r10,NINTop	/* compare to NINT */
	bb1	eq,r11,FP_inf_overflw /* operation is NINT */
	cmp	r11,r10,TRNCop	/* compare to TRNC */
	bb1	eq,r11,FP_inf_overflw /* operation is TRNC */


/* Adding infinities of opposite signs will cause an exception, */
/* but all other operands will result in a correctly signed infinity. */

FADD:
	bb0	s1inf,r12,addS2write	/* branch if S1 not infinity */
	bb0	s2inf,r12,addS1write	/* S2 is not inf., so branch to write S1 */
	bb1	sign,r5,addS1neg	/* handle case of S1 negative */
addS1pos:
	bb1	sign,r7,excpt		/* adding infinities of different */
					/* signs causes an exception */
	br	poswrinf		/* branch to write positive infinity */
addS1neg:
	bb0	sign,r7,excpt		/* adding infinities of different */
					/* signs causes an exception */
	br	negwrinf		/* branch to write negative infinity */
addS1write:
	bb0	sign,r5,poswrinf	/* branch to write positive infinity */
	br	negwrinf		/* branch to write negative infinity */
addS2write:
	bb0	sign,r7,poswrinf	/* branch to write positive infinity */
	br	negwrinf		/* branch to write negative infinity */


/* Subtracting infinities of the same sign will cause an exception, */
/* but all other operands will result in a correctly signed infinity. */

FSUB:
	bb0	s1inf,r12,subS2write	/* branch if S1 not infinity */
	bb0	s2inf,r12,subS1write	/* S2 is not inf., so branch to write S1 */
	bb1	sign,r5,subS1neg	/* handle case of S1 negative */
subS1pos:
	bb0	sign,r7,excpt		/* subtracting infinities of the same */
					/* sign causes an exception */
	br	poswrinf		/* branch to write positive infinity */
subS1neg:
	bb1	sign,r7,excpt		/* subtracting infinities of the same */
					/* sign causes an exception */
	br	negwrinf		/* branch to write negative infinity */
subS1write:
	bb0	sign,r5,poswrinf	/* branch to write positive infinity */
	br	negwrinf		/* branch to write negative infinity */
subS2write:
	bb1	sign,r7,poswrinf	/* branch to write positive infinity */
	br	negwrinf		/* branch to write negative infinity */


/* Compare the operands, at least one of which is infinity, and set the */
/* correct bits in the destination register. */

FCMP:
	bb0.n	s1inf,r12,FCMPS1f	/* branch for finite S1 */
	 set	r4,r0,1<cp>		/* since neither S1 or S2 is a NaN, */
					/* set cp */
FCMPS1i:
	bb1	sign,r5,FCMPS1ni	/* branch to negative S1i */
FCMPS1pi:
	bb0	s2inf,r12,FCMPS1piS2f	/* branch to finite S2 with S1pi */
FCMPS1piS2i:
	bb1	sign,r7,FCMPS1piS2ni	/* branch to negative S2i with S1pi */
FCMPS1piS2pi:
	set	r4,r4,1<eq>		/* set eq bit */
	set	r4,r4,1<le>		/* set le bit */
	set	r4,r4,1<ge>		/* set ge bit */
	set	r4,r4,1<ib>		/* set ib bit */
	br.n	move
	 set	r4,r4,1<ob>		/* set ob bit */
FCMPS1piS2ni:
	set	r4,r4,1<ne>		/* set ne bit */
	set	r4,r4,1<gt>		/* set gt bit */
	br.n	move
	 set	r4,r4,1<ge>		/* set ge bit */
FCMPS1piS2f:
	set	r4,r4,1<ne>		/* set ne bit */
	set	r4,r4,1<gt>		/* set gt bit */
	bsr.n	_ASM_LABEL(zero)	/* see if any of the operands are zero */
	 set	r4,r4,1<ge>		/* set ge bit */
	bb0	s2zero,r12,FCMPS1piS2nz	/* check for negative if s2 not zero */
	set	r4,r4,1<ou>		/* set ou bit */
	br.n	move
	 set	r4,r4,1<ob>		/* set ob bit */
FCMPS1piS2nz:
	bb1	sign,r7,move		/* return if s2 is negative */
FCMPS1piS2pf:
	set	r4,r4,1<ou>		/* set ou bit */
	br.n	move
	 set	r4,r4,1<ob>		/* set ob bit */
FCMPS1ni:
	bb0	s2inf,r12,FCMPS1niS2f	/* branch to finite S2 with S1ni */
FCMPS1niS2i:
	bb1	sign,r7,FCMPS1niS2ni	/* branch to negative S2i with S1ni */
FCMPS1niS2pi:
	set	r4,r4,1<ne>		/* set eq bit */
	set	r4,r4,1<le>		/* set le bit */
	set	r4,r4,1<lt>		/* set lt bit */
	set	r4,r4,1<ou>		/* set ou bit */
	br.n	move
	 set	r4,r4,1<ob>		/* set ob bit */
FCMPS1niS2ni:
	set	r4,r4,1<eq>		/* set eq bit */
	set	r4,r4,1<le>		/* set le bit */
	br.n	move
	 set	r4,r4,1<ge>		/* set ge bit */
FCMPS1niS2f:
	set	r4,r4,1<ne>		/* set eq bit */
	set	r4,r4,1<le>		/* set le bit */
	bsr.n	_ASM_LABEL(zero)	/* see if any of the operands are zero */
	 set	r4,r4,1<lt>		/* set lt bit */
	bb0	s2zero,r12,FCMPS1niS2nz	/* branch if s2 is not zero */
	set	r4,r4,1<ou>		/* set ou bit */
	br.n	move
	 set	r4,r4,1<ob>		/* set ob bit */
FCMPS1niS2nz:
	bb1	sign,r7,move		/* return if s2 is negative */
	set	r4,r4,1<ou>		/* set ou bit */
	br.n	move
	 set	r4,r4,1<ob>		/* set ob bit */
FCMPS1f:
	bb1	sign,r5,FCMPS1nf	/* branch to negative S1f */
FCMPS1pf:
	bb1.n	sign,r7,FCMPS1pfS2ni	/* branch to negative S2i with S1pf */
	 set	r4,r4,1<ne>		/* set ne bit */
FCMPS1pfS2pi:
	set	r4,r4,1<le>		/* set le bit */
	set	r4,r4,1<lt>		/* set lt bit */
	bsr.n	_ASM_LABEL(zero)
	 set	r4,r4,1<ib>		/* set ib bit */
	bb0	s1zero,r12,FCMPS1pfS2pinozero
FCMPS1pfS2pizero:
	br.n	move
	 set	r4,r4,1<ob>		/* set ob bit */
FCMPS1pfS2pinozero:
	br.n	move
	 set	r4,r4,1<in>		/* set in bit */
FCMPS1pfS2ni:
	set	r4,r4,1<gt>		/* set gt bit */
	br.n	move
	 set	r4,r4,1<ge>		/* set ge bit */
FCMPS1nf:
	bb1.n	sign,r7,FCMPS1nfS2ni	/* branch to negative S2i with S1nf */
	 set	r4,r4,1<ne>		/* set ne bit */
	set	r4,r4,1<le>		/* set gt bit */
	set	r4,r4,1<lt>		/* set ge bit */
	bsr.n	_ASM_LABEL(zero)	/* see which of the operands are zero */
	 set	r4,r4,1<ob>		/* set ob bit */
	bb0	s1zero,r12,FCMPS1nfS2pinozero /* no ls and lo */
FCMPS1nfS2pizero:
	br.n	move
	 set	r4,r4,1<ib>		/* set ib bit */
FCMPS1nfS2pinozero:
	br.n	move
	 set	r4,r4,1<ou>		/* set ou bit */
FCMPS1nfS2ni:
	set	r4,r4,1<gt>		/* set gt bit */
	set	r4,r4,1<ge>		/* set ge bit */

move:
	br.n	inf_return
	 or	r6,r0,r4		/* transfer answer to r6 */


/* Multiplying infinity and zero causes an exception, but all other */
/* operations produce a correctly signed infinity. */

FMUL:
	bsr	_ASM_LABEL(zero)	/* see if any of the operands are zero */
	bb1	s1zero,r12,excpt	/* infinity X 0 causes an exception */
	bb1	s2zero,r12,excpt	/* infinity X 0 causes an exception */
	bb1	sign,r5,FMULS1neg	/* handle negative cases of S1 */
	bb0	sign,r7,poswrinf	/* + X + = + */
	br	negwrinf		/* + X - = - */
FMULS1neg:
	bb1	sign,r7,poswrinf	/* - X - = + */
	br	negwrinf		/* - X + = - */


/* Dividing infinity by infinity causes an exception, but dividing */
/* infinity by a finite yields a correctly signed infinity, and */
/* dividing a finite by an infinity produces a correctly signed zero. */

FDIV:
	bb1	s1inf,r12,FDIVS1inf	/* handle case of S1 being infinity */
	bb1	sign,r5,FDIVS1nf	/* handle cases of S1 being neg. non-inf. */
	bb1	sign,r7,FDIVS1pfS2mi	/* handle case of negative S2 */
FDIVS1pfS2pi:
	br	poswrzero		/* +f / +inf = +0 */
FDIVS1pfS2mi:
	br	negwrzero		/* +f / -inf = -0 */
FDIVS1nf:
	bb1	sign,r7,FDIVS1nfS2mi	/* handle case of negative S2 */
FDIVS1nfS2pi:
	br	negwrzero		/* -f / +inf = -0 */
FDIVS1nfS2mi:
	br	poswrzero		/* -f / -inf = +0 */
FDIVS1inf:
	bb1	s2inf,r12,excpt		/* inf / inf = exception */
	bb1	sign,r5,FDIVS1mi	/* handle cases of S1 being neg. inf. */
	bb1	sign,r7,FDIVS1piS2nf	/* handle case of negative S2 */
FDIVS1piS2pf:
	br	poswrinf		/* +inf / +f = +inf */
FDIVS1piS2nf:
	br	negwrinf		/* +inf / -f = -inf */
FDIVS1mi:
	bb1	sign,r7,FDIVS1miS2nf	/* handle case of negative S2 */
FDIVS1miS2pf:
	br	negwrinf		/* -inf / +f = -inf */
FDIVS1miS2nf:
	br	poswrinf		/* -inf / -f = +inf */


/* The square root of positive infinity is positive infinity, */
/* but the square root of negative infinity is a NaN */

#if 0
FSQRT:
	bb0	sign,r7,poswrinf	/* write sqrt(inf) = inf */
	br	excpt			/* write sqrt(-inf) = NaN */
#endif

excpt:
	set	r2,r2,1<oper>
#ifdef HANDLER
	bb0	oper,r3,nohandler	/* branch if no user handler */
	bsr	_handler		/* branch to interface with user handler */
	br	inf_return
nohandler:
#endif
	set	r5,r0,0<0>	/* write NaN into r5 */
	br.n	inf_return
	 set	r6,r0,0<0>	/* write NaN into r6, writing NaN''s into */
				/* both of these registers is quicker than */
				/* checking for single or double precision */


/* Write positive infinity of the correct precision */

poswrinf:
	bb1	dsize,r9,poswrinfd	/* branch to write double precision inf. */
	br.n	inf_return
	 or.u	r6,r0,0x7f80		/* load r6 with single precision pos inf.	*/
poswrinfd:
	or.u	r5,r0,0x7ff0		/* load double precision pos inf. */
	br.n	inf_return
	 or	r6,r0,r0


/* Write negative infinity of the correct precision */

negwrinf:
	bb1	dsize,r9,negwrinfd	/* branch to write double precision inf. */
	br.n	inf_return
	 or.u	r6,r0,0xff80		/* load r6 with single precision pos inf.	*/
negwrinfd:
	or.u	r5,r0,0xfff0		/* load double precision pos inf. */
	br.n	inf_return
	 or	r6,r0,r0


/* Write a positive zero disregarding precision. */

poswrzero:
	or	r5,r0,r0	/* write to both high word and low word now */
	br.n	inf_return	/* it does not matter that both are written */
	 or	r6,r0,r0


/* Write a negative zero of the correct precision. */

negwrzero:
	or	r6,r0,r0	/* clear low word */
	bb1	dsize,r9,negwrzerod /* branch to write double precision zero */
	br.n	inf_return
	 set	r6,r6,1<31>	/* set sign bit */
negwrzerod:
	or	r5,r0,r0	/* clear high word */
	br.n	inf_return
	 set	r5,r5,1<31>	/* set sign bit */

FP_inf_overflw:
	set	r2,r2,1<oper>
	set	r2,r2,1<overflow>
	set	r2,r2,1<inexact>
#ifdef HANDLER
	bb0	oper,r3,nohandlero /* do not go to user handler routine */
	bsr	_handler	/* go to user handler routine */
	br	inf_return
#endif

nohandlero:
	bb0.n	sign,r7,inf_return /* if positive then return */

	 set	r6,r6,31<0>	/* set result to largest positive integer */
	or.c	r6,r0,r6	/* negate r6,giving largest negative int. */

inf_return:
	ld	r1,r31,0	/* load return address */
	jmp	r1

	data

#define FADD	denorm_FADD
#define FSUB	denorm_FSUB
#define FCMP	denorm_FCMP
#define FMUL	denorm_FMUL
#define FDIV	denorm_FDIV
#define NINT	denorm_NINT
#define TRNC	denorm_TRNC
#define return	denorm_return

/*
 * denorm
 */

/* Check to see if either S1 or S2 is a denormalized number. First */
/* extract the exponent to see if it is zero, and then check to see if */
/* the mantissa is not zero. If the number is denormalized, then set the */
/* 1 or 0 bit 10 r12. */

ASLOCAL(denorm)
	st	r1,r31,0	/* save return address */
dnmcheckS1:
	extu	r10,r5,11<20>	/* extract exponent */
	bcnd	ne0,r10,dnmsetS2 /* S1 is not a denorm, so S2 must be */
	bb1.n	9,r9,dnmcheckS1d /* S1 is double precision */
	 mak	r10,r5,20<3>	/* mak field with only mantissa bits */
				/* into final result */
dnmcheckS1s:
	extu	r11,r6,3<29>	/* get three low bits of mantissa */
	or	r10,r10,r11	/* assemble all of the mantissa bits */
	bcnd	eq0,r10,dnmsetS2 /* S1 is not a denorm, so S2 must be */
	br	dnmsetS1	/* S1 is a denorm */

dnmcheckS1d:
	or	r10,r6,r10	/* or all of mantissa bits */
	bcnd	eq0,r10,dnmsetS2 /* S1 is not a denorm, so S2 must be */
dnmsetS1:
	set	r12,r12,1<1>	/* S1 is a denorm */

dnmcheckS2:
	extu	r10,r7,11<20>	/* extract exponent */
	bcnd	ne0,r10,S1form	/* S2 is not a denorm */
	bb1.n	7,r9,dnmcheckS2d /* S2 is double precision */
	 mak	r10,r7,20<3>	/* mak field with only mantissa bits */
dnmcheckS2s:
	extu	r11,r8,3<29>	/* get three low bits of mantissa */
	or	r10,r10,r11	/* assemble all of the mantissa bits */
	bcnd	eq0,r10,S1form	/* S2 is not a denorm */
	br	dnmsetS2	/* S1 is a denorm */
dnmcheckS2d:
	or	r10,r8,r10	/* or all or mantissa bits */
	bcnd	eq0,r10,S1form	/* S2 is not a denorm */
dnmsetS2:
	set	r12,r12,1<0>	/* S2 is a denorm */


/* Since the operations are going to be reperformed with modified denorms, */
/* the operands which were initially single precision need to be modified */
/* back to single precision.	*/

S1form:
	bb1	9,r9,S2form	/* S1 is double precision, so do not */
				/* modify S1 into single format */
	mak	r11,r5,28<3>	/* over final exponent and mantissa */
				/* eliminating extra 3 bits of exponent */
	extu	r6,r6,3<29>	/* get low 3 bits of mantissa */
	or	r11,r6,r11	/* form complete mantissa and exponent */
	extu	r10,r5,1<31>	/* get the 31 bit */
	mak	r10,r10,1<31>	/* place 31 bit 10 correct position */
	or	r6,r10,r11	/* or 31, exponent, and all of mantissa */

S2form:
	bb1	7,r9,checkop	/* S2 is double precision, so do not */
				/* modify S2 into single format */
	mak	r11,r7,28<3>	/* over final exponent and mantissa */
				/* eliminating extra 3 bits of exponent */
	extu	r8,r8,3<29>	/* get low 3 bits of mantissa */
	or	r11,r8,r11	/* form complete mantissa and exponent */
	extu	r10,r7,1<31>	/* get the 31 bit */
	mak	r10,r10,1<31>	/* place 31 bit 10 correct position */
	or	r8,r10,r11	/* or 31, exponent, and all of mantissa */


/* Extract the opcode, compare to a constant, and branch to the code that */
/* deals with that opcode. */

checkop:
	extu	r10,r9,5<11>	/* extract opcode */
	cmp	r11,r10,0x05	/* compare to FADD */
	bb1	2,r11,FADD	/* operation is FADD */
	cmp	r11,r10,0x06	/* compare to FSUB */
	bb1	2,r11,FSUB	/* operation is FSUB */
	cmp	r11,r10,0x07	/* compare to FCMP */
	bb1	2,r11,FCMP	/* operation is FCMP */
	cmp	r11,r10,0x00	/* compare to FMUL */
	bb1	2,r11,FMUL	/* operation is FMUL */
	cmp	r11,r10,0x0e	/* compare to FDIV */
	bb1	2,r11,FDIV	/* operation is FDIV */
#if 0
	cmp	r11,r10,0x0f	/* compare to FSQRT */
	bb1	2,r11,FSQRT	/* operation is FSQRT */
#endif
	cmp	r11,r10,0x09	/* compare to INT */
	bb1	2,r11,INT	/* operation is INT */
	cmp	r11,r10,0x0a	/* compare to NINT */
	bb1	2,r11,NINT	/* operation is NINT */
	cmp	r11,r10,0x0b	/* compare to TRNC */
	bb1	2,r11,TRNC	/* operation is TRNC */


/* For all the following operations, the denormalized number is set to */
/* zero and the operation is reperformed the correct destination and source */
/* sizes. */

FADD:
	bb0	1,r12,FADDS2dnm	/* S1 is not denorm, so S2 must be */
	or	r5,r0,r0	/* set S1 to zero */
	or	r6,r0,r0
FADDS2chk:
	bb0	0,r12,FADDcalc	/* S2 is not a denorm */
FADDS2dnm:
	or	r7,r0,r0	/* set S2 to zero */
	or	r8,r0,r0
FADDcalc:
	bb1	5,r9,FADDdD	/* branch for double precision destination */
FADDsD:
	bb1	9,r9,FADDsDdS1	/* branch for double precision S1 */
FADDsDsS1:
	bb1	7,r9,FADDsDsS1dS2 /* branch for double precision S2 */
FADDsDsS1sS2:
	br.n	return
	 fadd.sss r6,r6,r8	/* add the two sources and place result 10 S1 */
FADDsDsS1dS2:
	br.n	return
	 fadd.ssd r6,r6,r7	/* add the two sources and place result 10 S1 */
FADDsDdS1:
	bb1	7,r9,FADDsDdS1dS2 /* branch for double precision S2 */
FADDsDdS1sS2:
	br.n	return
	 fadd.sds r6,r5,r8	/* add the two sources and place result 10 S1 */
FADDsDdS1dS2:
	br.n	return
	 fadd.sdd r6,r5,r7	/* add the two sources and place result 10 S1 */
FADDdD:
	bb1	9,r9,FADDdDdS1	/* branch for double precision S1 */
FADDdDsS1:
	bb1	7,r9,FADDdDsS1dS2 /* branch for double precision S2 */
FADDdDsS1sS2:
	br.n	return
	 fadd.dss r5,r6,r8	/* add the two sources and place result 10 S1 */
FADDdDsS1dS2:
	br.n	return
	 fadd.dsd r5,r6,r7	/* add the two sources and place result 10 S1 */
FADDdDdS1:
	bb1	7,r9,FADDdDdS1dS2 /* branch for double precision S2 */
FADDdDdS1sS2:
	br.n	return
	 fadd.dds r5,r5,r8	/* add the two sources and place result 10 S1 */
FADDdDdS1dS2:
	br.n	return
	 fadd.ddd r5,r5,r7	/* add the two sources and place result 10 S1 */

FSUB:
	bb0	1,r12,FSUBS2dnm	/* S1 is not denorm, so S2 must be */
	or	r5,r0,r0	/* set S1 to zero */
	or	r6,r0,r0
FSUBS2chk:
	bb0	0,r12,FSUBcalc	/* S2 is not a denorm */
FSUBS2dnm:
	or	r7,r0,r0	/* set S2 to zero */
	or	r8,r0,r0
FSUBcalc:
	bb1	5,r9,FSUBdD	/* branch for double precision destination */
FSUBsD:
	bb1	9,r9,FSUBsDdS1	/* branch for double precision S1 */
FSUBsDsS1:
	bb1	7,r9,FSUBsDsS1dS2 /* branch for double precision S2 */
FSUBsDsS1sS2:
	br.n	return
	 fsub.sss r6,r6,r8	/* add the two sources and place result 10 S1 */
FSUBsDsS1dS2:
	br.n	return
	 fsub.ssd r6,r6,r7	/* add the two sources and place result 10 S1 */
FSUBsDdS1:
	bb1	7,r9,FSUBsDdS1dS2 /* branch for double precision S2 */
FSUBsDdS1sS2:
	br.n	return
	 fsub.sds r6,r5,r8	/* add the two sources and place result 10 S1 */
FSUBsDdS1dS2:
	br.n	return
	 fsub.sdd r6,r5,r7	/* add the two sources and place result 10 S1 */
FSUBdD:
	bb1	9,r9,FSUBdDdS1	/* branch for double precision S1 */
FSUBdDsS1:
	bb1	7,r9,FSUBdDsS1dS2 /* branch for double precision S2 */
FSUBdDsS1sS2:
	br.n	return
	 fsub.dss r5,r6,r8	/* add the two sources and place result 10 S1 */
FSUBdDsS1dS2:
	br.n	return
	 fsub.dsd r5,r6,r7	/* add the two sources and place result 10 S1 */
FSUBdDdS1:
	bb1	7,r9,FSUBdDdS1dS2 /* branch for double precision S2 */
FSUBdDdS1sS2:
	br.n	return
	 fsub.dds r5,r5,r8	/* add the two sources and place result 10 S1 */
FSUBdDdS1dS2:
	br.n	return
	 fsub.ddd r5,r5,r7	/* add the two sources and place result 10 S1 */

FCMP:
	bb0	1,r12,FCMPS2dnm	/* S1 is not denorm, so S2 must be */
	or	r5,r0,r0	/* set S1 to zero */
	or	r6,r0,r0
FCMPS2chk:
	bb0	0,r12,FCMPcalc	/* S2 is not a denorm */
FCMPS2dnm:
	or	r7,r0,r0	/* set S2 to zero */
	or	r8,r0,r0
FCMPcalc:
	bb1	9,r9,FCMPdS1	/* branch for double precision S1 */
FCMPsS1:
	bb1	7,r9,FCMPsS1dS2	/* branch for double precision S2 */
FCMPsS1sS2:
	br.n	return
	 fcmp.sss r6,r6,r8	/* add the two sources and place result 10 S1 */
FCMPsS1dS2:
	br.n	return
	 fcmp.ssd r6,r6,r7	/* add the two sources and place result 10 S1 */
FCMPdS1:
	bb1	7,r9,FCMPdS1dS2	/* branch for double precision S2 */
FCMPdS1sS2:
	br.n	return
	 fcmp.sds r6,r5,r8	/* add the two sources and place result 10 S1 */
FCMPdS1dS2:
	br.n	return
	 fcmp.sdd r6,r5,r7	/* add the two sources and place result 10 S1 */

FMUL:
	bb0	1,r12,FMULS2dnm	/* S1 is not denorm, so S2 must be */
	or	r5,r0,r0	/* set S1 to zero */
	or	r6,r0,r0
FMULS2chk:
	bb0	0,r12,FMULcalc	/* S2 is not a denorm */
FMULS2dnm:
	or	r7,r0,r0	/* set S2 to zero */
	or	r8,r0,r0
FMULcalc:
	bb1	5,r9,FMULdD	/* branch for double precision destination */
FMULsD:
	bb1	9,r9,FMULsDdS1	/* branch for double precision S1 */
FMULsDsS1:
	bb1	7,r9,FMULsDsS1dS2 /* branch for double precision S2 */
FMULsDsS1sS2:
	br.n	return
	 fmul.sss r6,r6,r8	/* add the two sources and place result 10 S1 */
FMULsDsS1dS2:
	br.n	return
	 fmul.ssd r6,r6,r7	/* add the two sources and place result 10 S1 */
FMULsDdS1:
	bb1	7,r9,FMULsDdS1dS2 /* branch for double precision S2 */
FMULsDdS1sS2:
	br.n	return
	 fmul.sds r6,r5,r8	/* add the two sources and place result 10 S1 */
FMULsDdS1dS2:
	br.n	return
	 fmul.sdd r6,r5,r7	/* add the two sources and place result 10 S1 */
FMULdD:
	bb1	9,r9,FMULdDdS1	/* branch for double precision S1 */
FMULdDsS1:
	bb1	7,r9,FMULdDsS1dS2 /* branch for double precision S2 */
FMULdDsS1sS2:
	br.n	return
	 fmul.dss r5,r6,r8	/* add the two sources and place result 10 S1 */
FMULdDsS1dS2:
	br.n	return
	 fmul.dsd r5,r6,r7	/* add the two sources and place result 10 S1 */
FMULdDdS1:
	bb1	7,r9,FMULdDdS1dS2 /* branch for double precision S2 */
FMULdDdS1sS2:
	br.n	return
	 fmul.dds r5,r5,r8	/* add the two sources and place result 10 S1 */
FMULdDdS1dS2:
	br.n	return
	 fmul.ddd r5,r5,r7	/* add the two sources and place result 10 S1 */

FDIV:
	bb0	1,r12,FDIVS2dnm	/* S1 is not denorm, so S2 must be */
	or	r5,r0,r0	/* set S1 to zero */
	or	r6,r0,r0
FDIVS2chk:
	bb0	0,r12,FDIVcalc	/* S2 is not a denorm */
FDIVS2dnm:
	or	r7,r0,r0	/* set S2 to zero */
	or	r8,r0,r0
FDIVcalc:
	bb1	5,r9,FDIVdD	/* branch for double precision destination */
FDIVsD:
	bb1	9,r9,FDIVsDdS1	/* branch for double precision S1 */
FDIVsDsS1:
	bb1	7,r9,FDIVsDsS1dS2 /* branch for double precision S2 */
FDIVsDsS1sS2:
	fdiv.sss r6,r6,r8	/* add the two sources and place result 10 S1 */
	br	return
FDIVsDsS1dS2:
	fdiv.ssd r6,r6,r7	/* add the two sources and place result 10 S1 */
	br	return
FDIVsDdS1:
	bb1	7,r9,FDIVsDdS1dS2 /* branch for double precision S2 */
FDIVsDdS1sS2:
	fdiv.sds r6,r5,r8	/* add the two sources and place result 10 S1 */
	br	return
FDIVsDdS1dS2:
	fdiv.sdd r6,r5,r7	/* add the two sources and place result 10 S1 */
	br	return
FDIVdD:
	bb1	9,r9,FDIVdDdS1	/* branch for double precision S1 */
FDIVdDsS1:
	bb1	7,r9,FDIVdDsS1dS2 /* branch for double precision S2 */
FDIVdDsS1sS2:
	fdiv.dss r5,r6,r8	/* add the two sources and place result 10 S1 */
	br	return
FDIVdDsS1dS2:
	fdiv.dsd r5,r6,r7	/* add the two sources and place result 10 S1 */
	br	return
FDIVdDdS1:
	bb1	7,r9,FDIVdDdS1dS2 /* branch for double precision S2 */
FDIVdDdS1sS2:
	fdiv.dds r5,r5,r8	/* add the two sources and place result 10 S1 */
	br	return
FDIVdDdS1dS2:
	fdiv.ddd r5,r5,r7	/* add the two sources and place result 10 S1 */
	br	return

#if 0
FSQRT:
	or	r7,r0,r0	/* set S2 to zero */
	or	r8,r0,r0
FSQRTcalc:
	bb1	5,r9,FSQRTdD	/* branch for double precision destination */
FSQRTsD:
	bb1	7,r9,FSQRTsDdS2 /* branch for double precision S2 */
FSQRTsDsS2:
	br.n	return
	 fsqrt.ss r6,r8		/* add the two sources and place result 10 S1 */
FSQRTsDdS2:
	br.n	return
	 fsqrt.sd r6,r7		/* add the two sources and place result 10 S1 */
FSQRTdD:
	bb1	7,r9,FSQRTdDdS2	/* branch for double precision S2 */
FSQRTdDsS2:
	br.n	return
	 fsqrt.ds r5,r8		/* add the two sources and place result 10 S1 */
FSQRTdDdS2:
	br.n	return
	 fsqrt.dd r5,r7		/* add the two sources and place result 10 S1 */
#endif

INT:
	or	r7,r0,r0	/* set S2 to zero */
	or	r8,r0,r0
INTcalc:
	bb1	7,r9,INTdS2	/* branch for double precision S2 */
INTsS2:
	br.n	return
	 int.ss r6,r8		/* add the two sources and place result 10 S1 */
INTdS2:
	br.n	return
	 int.sd r6,r7		/* add the two sources and place result 10 S1 */

NINT:
	or	r7,r0,r0	/* set S2 to zero */
	or	r8,r0,r0
NINTcalc:
	bb1	7,r9,NINTdS2	/* branch for double precision S2 */
NINTsS2:
	br.n	return
	 nint.ss r6,r8		/* add the two sources and place result 10 S1 */
NINTdS2:
	br.n	return
	 nint.sd r6,r7		/* add the two sources and place result 10 S1 */

TRNC:
	or	r7,r0,r0	/* set S2 to zero */
	or	r8,r0,r0
TRNCcalc:
	bb1	7,r9,TRNCdS2	/* branch for double precision S2 */
TRNCsS2:
	br.n	return
	 trnc.ss r6,r8		/* add the two sources and place result 10 S1 */
TRNCdS2:
	trnc.sd r6,r7		/* add the two sources and place result 10 S1 */


/* Return to the routine that detected the reserved operand. */

return:
	ld	r1,r31,0	/* load return address */
	jmp	r1

	data


/* S1 and/or S2 is an infinity, and the other operand may be a zero. */
/* Knowing which operands are infinity, check the remaining operands for zeros. */

ASLOCAL(zero)
	bb0	s1inf,r12,S1noinf	/* see if S1 is zero */
	bb0	s2inf,r12,S2noinf	/* see if S2 is zero */
	jmp	r1

/* See if S1 is zero. Whether or not S1 is a zero, being in this routine */
/* implies that S2 is infinity, so return to subroutine infinity after */
/* completing this code. Set the s1zero flag in r12 if S1 is zero. */

S1noinf:
	bb1	s1size,r9,S1noinfd	/* work with double precision operand */
S1noinfs:
	or	r10,r0,r5		/* load high word into r10 */
	clr	r10,r10,1<sign>		/* clear the sign bit */
	extu	r11,r6,3<29>		/* extract lower 3 bits of mantissa */
	or	r10,r10,r11		/* or these 3 bits with high word */
	bcnd	ne0,r10,operation	/* do not set zero flag */
	jmp.n	r1			/* since this operand was not */
					/* infinity, S2 must have been, */
					/* so return */
	 set	r12,r12,1<s1zero>	/* set zeroflag */
S1noinfd:
	clr	r10,r5,1<sign>		/* clear the sign bit */
	or	r10,r6,r10		/* or high and low word */
	bcnd	ne0,r10,operation	/* do not set zero flag */
	jmp.n	r1			/* since this operand was not */
					/* infinity, S2 must have been, */
					/* so return */
	 set	r12,r12,1<s1zero>	/* set zeroflag */


/* Check S2 for zero. If it is zero, then set the s2zero flag in r12. */

S2noinf:
	bb1	s2size,r9,S2noinfd	/* work with double precision operand */
S2noinfs:
	or	r10,r0,r7		/* load high word into r10 */
	clr	r10,r10,1<sign>		/* clear the sign bit */
	extu	r11,r8,3<29>		/* extract lower 3 bits of mantissa */
	or	r10,r10,r11		/* or these 3 bits with high word */
	bcnd	ne0,r10,operation	/* do not set zero flag */
	jmp.n	r1			/* since this operand was not */
					/* infinity, S1 must have been, */
					/* so return */
	 set	r12,r12,1<s2zero>	/* set zeroflag */
S2noinfd:
	clr	r10,r7,1<sign>		/* clear the sign bit */
	or	r10,r8,r10		/* or high and low word */
	bcnd	ne0,r10,operation	/* do not set zero flag */
	set	r12,r12,1<s2zero>	/* set zeroflag */
					/* since this operand was not */
					/* infinity, S1 must have been, */
					/* so return */
operation:
	jmp	r1

ASENTRY(Xfp_imprecise)
/* input: r3 is the exception frame */
	or	r29, r3, r0		/* r29 is now the E.F. */
	subu	r31, r31, 40
	st	r1,  r31, 32
	st	r29, r31, 36

	ld	r2 , r29, EF_FPSR  * 4
	ld	r3 , r29, EF_FPCR  * 4
	ld	r4 , r29, EF_FPECR * 4
	ld	r10, r29, EF_FPRH  * 4
	ld	r11, r29, EF_FPRL  * 4
	ld	r12, r29, EF_FPIT  * 4

/* Load into r1 the return address for the exception handlers. Looking */
/* at FPECR, branch to the appropriate exception handler. */

	or.u	r1,r0,hi16(fpui_wrapup)/* load return address of functions */
	or	r1,r1,lo16(fpui_wrapup)

	bb0	2,r4,2f			/* branch to FPunderflow if bit set */
	br	_ASM_LABEL(FPunderflow)
2:
	bb0	1,r4,3f			/* branch to FPoverflow if bit set */
	br	_ASM_LABEL(FPoverflow)
3:
	/* XXX handle inexact!!! */
#ifdef HANDLER
	br	_handler		/* branch to handler since bit will */
					/* be set for inexact */
#endif

fpui_wrapup:
	tb1	0,r0,0		/* make sure all floating point operations */
				/* have finished */
	ldcr	r4, cr1	/* load the PSR */
#if 0
	set	r4, r4, 1<PSR_FPU_DISABLE_BIT>
#endif
	set	r4, r4, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r4, cr1
	ld	r1, r31, 32
	ld	r29,r31, 36
	addu	r31, r31, 40

	fstcr	r2, FPSR	/* write revised value of FPSR */
	fstcr	r3, FPCR	/* write revised value of FPCR */

	/* write back the results */
	extu	r2, r12, 5<0>
	addu	r3, r29, EF_R0*4
	bb0	destsize, r12, Iwritesingle
	st	r10, r3 [r2]
	addu	r2, r2, 1
	clr	r2, r2, 27<5>
Iwritesingle:
	st	r11, r3 [r2]
	jmp	r1
@


1.21
log
@People who immediately clobber registers containing the result of subfunctions
as soon as they return deserve to be shot or something.

Make sure the result of imprecise exceptions is safely returned to userland.
Fixes lib/libc/ieeefp/infinity regression test, as well as Perls.
@
text
@d1 1
a1 1
/* $OpenBSD: m88100_fp.S,v 1.20 2003/12/25 00:12:37 miod Exp $	*/
@


1.20
log
@Floating-point status register exception bits are supposed to be maintained
by software, so be sure to set them both the precise _and imprecise_  floating
point exception handlers, whatever the state of the HANDLER define is (which
is anyway, soon to be hitting the dust in a cvs tree near you...)

This allows userland software to really trust fpgetsticky() results.
@
text
@d1 1
a1 1
/* $OpenBSD: m88100_fp.S,v 1.19 2003/12/24 22:41:45 miod Exp $	*/
d2485 1
d2494 1
a2494 1
	ldcr	r10, cr1	/* load the PSR */
d2496 1
a2496 1
	set	r10, r10, 1<PSR_FPU_DISABLE_BIT>
d2498 2
a2499 2
	set	r10, r10, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r10, cr1
@


1.19
log
@Murphy's law applied to BSD:
Every non-KNF file in the source tree contains at least one severe bug.

KNF and a timid start at cleaning, but not very far, so there is no
functional change at the moment.

This code is still pathetic for now, but it sorta works and the price
was right.
@
text
@d1 1
a1 1
/* $OpenBSD: m88100_fp.S,v 1.18 2003/11/03 06:54:26 david Exp $	*/
d35 2
d100 1
a100 1
2:
d129 1
a129 1
	br	fp_p_return
a167 2

ASLOCAL(fp_p_return)
d197 1
a197 1
	set	r2,r2,1<oper>	/* set bit in FPSR */
d220 1
a221 1
	set	r2,r2,1<divzero>	/* set bit in FPSR */
d620 1
d622 1
a622 2
	bb0.n	oper,r3,nohandler	/* do not go to user handler routine */
	 set	r2,r2,1<oper>		/* set invalid operand bit */
d802 2
d806 1
a806 2
	bb1.n	destsize,r12,doubleprec	/* double precision destination */
	 set	r2,r2,1<underflow>	/* set underflow flag in FPSR */
d1351 2
d1354 1
a1354 1
	bb1.n	efinx,r12,modformdef	/* branch to modify form for user */
a1355 1
	 or	r2,r2,5			/* set inexact and underflow flags */
d1420 2
a1422 1
	set	r2,r2,1<overflow> /* set overflow bit in r2 which holds FPSR */
a1423 2
	set	r2,r2,1<inexact> /* set inexact bit in r2 since overflow bit */
				/* in FPCR is not set */
d1580 1
a1580 1
	set	r2,r2,1<oper>		/* set invalid operation bit in FPSR */
d1595 1
a1595 1
	set	r2,r2,1<oper>		/* set invalid operation bit in FPSR */
d1918 1
a1918 1
	set	r2,r2,1<oper>		/* set invalid operation bit of FPSR */
d1977 3
a1979 1
	set	r2,r2,1<oper>	/* set invalid operand bit */
d2460 1
a2460 1
/* input: r3 is the excepton frame */
a2489 17
/*
 * XXX should never get here!
 */
	data
	align 8
1:
	string "error in inprecise fp exception handler, r4 is 0x%08x\0"
	text
	align 8
	or.u	r2, r0, hi16(1b)
	or	r2, r2, lo16(1b)
	or	r3, r4, r0
	bsr	_printf
	or.u	r2, r0, hi16(1b)
	or	r2, r2, lo16(1b)
	bsr	_panic

d2502 3
@


1.18
log
@spelling fixes (in the comments)
@
text
@d1 1
a1 1
/* $OpenBSD: m88100_fp.S,v 1.17 2003/08/11 20:45:17 miod Exp $	*/
a33 27
#define psr cr1
#define spsr cr2
#define ssb cr3
#define scip cr4
#define snip cr5
#define sfip cr6
#define vbr cr7	
#define dmt0 cr8	
#define scratch1 cr18
#define scratch2 cr20
#define fpecr fcr0
#define s1hi fcr1
#define s1lo fcr2
#define s2hi fcr3
#define s2lo fcr4
#define pcr fcr5
#define manthi fcr6
#define mantlo fcr7
#define impcr fcr8
#define fpsr fcr62
#define fpcr fcr63
#define valid 1
#define exception 0
#define exc_disable 0
#define FP_disable 3
#define dexc 27
#define serial 29
d40 1
d45 1
a45 2
#define full 1
#define fault 0
a51 1
#define FLTop 0x04
d55 1
a55 3
#define mode 31
#define s1sign 9
#define s2sign 8
a61 2
#define s1denorm 1
#define s2denorm 0
a62 14
#define sigbits 22
#define sigbitd 19
#define nc 0
#define cp 1
#define eq 2
#define ne 3
#define gt 4
#define le 5
#define lt 6
#define ge 7
#define ou 8
#define ib 9
#define in 10
#define ob 11
a71 2
#define MARK	or	r21, r0, __LINE__
	
d73 1
a73 1
	or	r29, r3, r0     /*  r29 is now the E.F. */
d77 3
a79 3
  
	ld	r2, r29, EF_FPSR  * 4
	ld	r3, r29, EF_FPCR  * 4
d85 12
a96 10
	ld	r9, r29, EF_FPPT  * 4
	
	
	/* Load into r1 the return address for the 0 handlers.  Looking */
	/* at FPECR, branch to the appropriate 0 handler.  However, */
	/* if none of the 0 bits are enabled, then a floating point */
	/* instruction was issued with the floating point unit disabled.  This */
	/* will cause an unimplemented opcode 0. */
	
	or.u	r1,r0,hi16(wrapup) /* load return address of function  */
d98 18
a115 11
2:   	bb0	6,r4, 3f   	/* branch to FPunimp if bit set */
     	br	FPuimp
3:	bb0	7,r4, 4f 	/* branch to FPintover if bit set */
	br	_FPintover
4: /* 	bb0	5,r4, 5f 	;branch to FPpriviol if bit set */
   /* 	br	_FPpriviol */
5: 	bb0	4,r4, 6f 	/* branch to FPresoper if bit set */
	br	_FPresoper
6:   	bb0	3,r4, 7f 	/* branch to FPdivzero if bit set */
    	br	_FPdivzero
7: 
d118 5
a122 6
FPuimp: global FPuimp
fp_p_trap:
	subu    r31,r31,40      /* allocate stack */
	st      r1,r31,36       /* save return address */
	st      r3,r31,32       /* save exception frame */
	or      r2,r0,T_FPEPFLT /* load trap type */
d124 17
a140 17
	bsr     _C_LABEL(m88100_trap)	/* trap */
	ld      r1,r31,36       /* recover return address */
	addu    r31,r31,40      /* deallocate stack */
 	br	fp_p_return

	/* To write back the results to the user registers, disable exceptions */
	/* and the floating point unit.  Write FPSR and FPCR and load the SNIP */
	/* and SFIP. */
	/* r5 will contain the upper word of the result */
	/* r6 will contain the lower word of the result */
	
wrapup: global wrapup
	tb1	0,r0,0          /* make sure all floating point operations */
	/* have finished */
	ldcr	r10, cr1        /* load the PSR */
	or	r10, r10, 0x2   /* disable interrupts */
	stcr	r10, cr1
d142 3
a144 2
Why is this done? -jfriedl
	or	r10, r10, 0x8 /* set SFU 1 disable bit, disable SFU 1 */
d146 1
a146 1
#endif
d150 4
a153 4
  
	fstcr	r2, fpsr	/* write revised value of FPSR */
	fstcr	r3, fpcr	/* write revised value of FPCR */
	
d155 4
a158 4
	addu   r3, r29, EF_R0 * 4
	extu   r2, r9, 5<0>       /* get 5 bits of destination register */
	bb0    5, r9, writesingle /* branch if destination is single */
	
d160 2
a161 2
	st     r5, r3 [r2]       /* write high word */
	add    r2, r2, 1          /* for double, the low word is the  */
d163 3
a165 3
	clr    r2, r2, 27<5>      /* perform equivalent of mod 32 */
writesingle: 
	st     r6, r3 [r2]       /* write low word into memory */
d167 1
a167 1
fp_p_return:
d170 4
a173 4
             text
	     align 8
             global _FPdivzero

d175 3
a177 6
/* Check if the numerator is zero.  If the numerator is zero, then handle */
/* this instruction as you would a 0/0 invalid operation. */

_FPdivzero:  
             st    r1,r31,0  /* save return address */
	     bb1   s1size,r9,1f  /* branch if numerator double */
d179 5
a183 6
  	     clr   r10,r5,1<sign>   /* clear sign bit */
             extu  r11,r6,3<29>     /* grab upper bits of lower word */
             or    r10,r10,r11      /* combine ones of mantissa */
             bcnd  eq0,r10,resoper  /* numerator is zero, handle reserved */
                                    /* operand  */
             br    setbit           /* set divzero bit */
d186 3
a188 7
	     clr   r10,r5,1<sign>   /* clear sign bit */
             or    r10,r10,r6       /* or high and low words */
             bcnd  ne0,r10,setbit   /* set divzero bit */

/* The numerator is zero, so handle the invalid operation by setting the */
/* invalid operation bit and branching to the user handler if there is one */
/* or writing a quiet NaN to the destination. */
d190 8
a197 2
resoper:     
             set   r2,r2,1<oper>    /* set bit in FPSR */
d199 4
a202 4
	     bb0   oper,r3,noreshand /* branch to execute default handling for */
                                    /* reserved operands */
             bsr   _handler         /* branch to user handler */
             br    FP_div_return           /* return from function */
d204 14
a217 12
             
noreshand:   
 	     set   r5,r0,0<0>      /* put a NaN in high word */
             set   r6,r0,0<0>      /* put a NaN in low word */
             br  FP_div_return            /* return from subroutine */
                                   /* writing to a word which may be ignored */
                                   /* is just as quick as checking the precision */
                                   /* of the destination */

/* The operation is divide by zero, so set the divide by zero bit in the */
/* FPSR.  If the user handler is set, then go to the user handler, else */
/* go to the default mode. */
d221 4
a224 4
             set   r2,r2,1<divzero> /* set bit in FPSR */
             bb0   divzero,r3,default /* go to default routine if no handler */
             bsr   _handler         /* execute handler routine */
             br    FP_div_return           /* return from subroutine */
d227 20
d248 3
a250 2
/* Considering the sign of the numerator and zero, write a correctly */
/* signed infinity of the proper precision into the destination. */
d252 17
a268 38
default:     
	     bb1   dsize,r9,FPzero_double  /* branch to handle double result */
FPzero_single:    
   	     clr   r10,r5,31<0>     /* clear all of S1HI except sign bit */
             xor   r10,r7,r10       /* xor the sign bits of the operands */
             or.u  r6,r0,0x7f80     /* load single precision infinity */
             br.n  FP_div_return           /* return from subroutine */
             or    r6,r6,r10        /* load correctly signed infinity */

FPzero_double:     
             clr   r10,r5,31<0>     /* clear all of S1HI except sign bit */
             xor   r10,r7,r10       /* xor the sign bits of the operands */
             or.u  r5,r0,0x7ff0     /* load double precision infinity */
             or    r5,r5,r10        /* load correctly signed infinity */
             or    r6,r0,r0         /* clear lower word of double */

FP_div_return:      
	     ld    r1,r31,0  /* load return address */
             jmp   r1               /* return from subroutine */

	
	
/* Both NINT and TRNC require a certain rounding mode, so check which */
/* instruction caused the integer conversion overflow.  Use a substitute */
/* FPCR in r1, and modify the rounding mode if the instruction is NINT or TRNC. */
	text
	align 8
_FPintover:  global _FPintover
	extu   r10,r9,5<11>         /* extract opcode */
	cmp    r11,r10,INTop        /* see if instruction is INT */
	st     r1,r31,0      /* save return address */
	bb1.n  eq,r11,checksize     /* instruction is INT, do not modify */
	/* rounding mode */
	or     r1,r0,r3             /* load FPCR into r1 */
	cmp    r11,r10,NINTop       /* see if instruction is NINT */
	bb1    eq,r11,NINT          /* instruction is NINT */
	
TRNC:   clr    r1,r1,2<rndlo>          /* clear rounding mode bits, */
d270 7
a276 6
	br.n   checksize            /* branch to check size */
	set    r1,r1,1<rndlo>          /* make rounding mode round towards zero */
	
NINT:   clr    r1,r1,2<rndlo>          /* make rounding mode round to nearest */
	
	
d278 213
a490 188
	
checksize:   bb1    s2size,r9,checkdoub  /* S2 is double, branch to see if there */
/* is a false alarm */
	
	
/* An integer has more bits than the mantissa of a single precision floating */
/* point number, so to check for false alarms (i.e. valid conversion), simply */
/* check the exponents.  False alarms are detected for 2**30 to (2**30) - 1 and */
/* -2**30 to -2**31.  Only seven bits need to be looked at since an exception */
/* will not occur for the other half of the numbering system. */
/* To speed up the processing, first check to see if the exponent is 32 or */
/* greater. */

/* This code was originally written for the exponent in the control */
/* register to have the most significant bit (8 - single, 11 - double)  */
/* flipped and sign extended.  For precise exceptions, however, the most */
/* significant bit is only sign extended.  Therefore, the code was chopped */
/* up so that it would work for positive values of real exponent which were */
/* only sign extended. */
	
checksing:   extu   r10,r7,7<20>         /* internal representation for single */
/* precision is IEEE 8 bits sign extended */
/* to 11 bits; for real exp. = 30, the */
/* above instruction gives a result exp. */
/* that has the MSB flipped and sign */
/* extended like in the IMPCR */
	cmp    r11,r10,31           /* compare to 32,but exp. off by 1 */
/* these 2 instructions to speed up valid */
/* execution of valid cases */
	bb1    ge,r11,overflw       /* valid case, perform overflow routine */
	bb1    sign,r7,checksingn   /* source operand is negative */
	
/* If the number is positve and the exponent is greater than 30, than it is */
	/* overflow. */
	
checksingp:  cmp    r10,r10,29           /* compare to 30, but exp. off by 1 */
	bb1    gt,r10,overflw       /* no false alarm, its overflow */
	br     conversionsp         /* finish single precision conversion */
	
/* If the number is negative, and the exponent is 30, or 31 with a mantissa */
/* of 0, then it is a false alarm. */
	
checksingn:  cmp    r11,r10,30           /* compare to 31,but exp. off by 1 */
	bb1    lt,r11,conversionsn  /* exp. less than 31, so convert */
	extu   r10,r8,3<29>         /* get upper three bits of lower mantissa */
	mak    r12,r7,20<3>         /* get upper 20 bits of mantissa */
	or     r10,r10,r12          /* form complete mantissa */
	bcnd   eq0,r10,conversionsn /* complete conversion if mantissa is 0 */
	br     overflw              /* no false alarm, its overflow */
	
	
/* False alarms are detected for 2**30 to (2**30) - 1 and */
/* -2**30 to -2**31.  Only seven bits need to be looked at since an exception */
/* will not occur for the other half of the numbering system. */
/* To speed up the processing, first check to see if the exponent is 32 or */
/* greater.  Since there are more mantissa bits than integer bits, rounding */
/* could cause overflow.  (2**31) - 1 needs to be checked so that it does */
/* not round to 2**31, and -2**31 needs to be checked in case it rounds to */
/* -((2**31) + 1). */
	
checkdoub:   extu   r10,r7,10<20>        /* internal representation for double */
/* precision is the same IEEE 11 bits  */
/* for real exp. = 30, the */
/* above instruction gives a result exp. */
/* that has the MSB flipped and sign */
/* extended like in the IMPCR */
	cmp    r11,r10,31           /* compare to 32,but exp. off by 1 */
/* these 2 instructions to speed up valid */
/* execution of valid cases */
	bb1    ge,r11,overflw       /* valid case, perform overflow routine */
	bb1    sign,r7,checkdoubn   /* source operand is negative */
	
/* If the exponent is not 31, then the floating point number will be rounded */
/* before the conversion is done.  A branch table is set up with bits 4 and 3 */
/* being the rounding mode, and bits 2, 1, and 0 are the guard, round, and  */
/* sticky bits. */
	
checkdoubp:  cmp    r11,r10,30           /* compare to 31, but exponent off by 1 */
	bb1    eq,r11,overflw       /* no false alarm, its overflow */
	extu   r12,r8,1<22>         /* get LSB for integer with exp. = 30 */
	mak    r12,r12,1<2>         /* start to set up field for branch table */
	extu   r11,r8,1<21>         /* get guard bit */
	mak    r11,r11,1<1>         /* set up field for branch table */
	or     r12,r11,r12          /* set up field for branch table */
	extu   r11,r8,21<0>         /* get bits for sticky bit */
	bcnd   eq0,r11,nostickyp    /* do not set sticky */
	set    r12,r12,1<0>         /* set sticky bit */
nostickyp:   rot    r11,r1,0<rndlo>      /* shift rounding mode to 2 LSB''s */
	mak    r11,r11,2<3>         /* set up field, clear other bits */
	or     r12,r11,r12          /* set up field for branch table */
	lda    r12,r0[r12]          /* scale r12 */
	or.u   r12,r12,hi16(ptable) /* load pointer into table */
	addu   r12,r12,lo16(ptable)
	jmp    r12                  /* jump into branch table */
	
ptable:      br     conversiondp
p00001:      br     conversiondp
p00010:      br     conversiondp
p00011:      br     paddone
p00100:      br     conversiondp
p00101:      br     conversiondp
p00110:      br     paddone
p00111:      br     paddone
p01000:      br     conversiondp
p01001:      br     conversiondp
p01010:      br     conversiondp
p01011:      br     conversiondp
p01100:      br     conversiondp
p01101:      br     conversiondp
p01110:      br     conversiondp
p01111:      br     conversiondp
p10000:      br     conversiondp
p10001:      br     conversiondp
p10010:      br     conversiondp
p10011:      br     conversiondp
p10100:      br     conversiondp
p10101:      br     conversiondp
p10110:      br     conversiondp
p10111:      br     conversiondp
p11000:      br     conversiondp
p11001:      br     paddone
p11010:      br     paddone
p11011:      br     paddone
p11100:      br     conversiondp
p11101:      br     paddone
p11110:      br     paddone
p11111:      br     paddone
	
/* Add one to the bit of the mantissa which corresponds to the LSB of an */
/* integer.  If the mantissa overflows, then there is a valid integer */
/* overflow conversion; otherwise, the mantissa can be converted to the integer. */
	
paddone:     or     r10,r0,r0           /* clear r10 */
	set    r10,r10,1<22>       /* set LSB bit to 1 for adding */
	addu.co r8,r8,r10          /* add the 1 obtained from rounding */
	clr    r11,r7,12<20>       /* clear exponent and sign */
	addu.ci r11,r0,r11         /* add carry */
	bb1    20,r11,overflw      /* overflow to 2**31, abort the rest */
	br.n   conversiondp        /* since the exp. was 30, and the exp. */
	/* did not round up to 31, the largest */
	/* number that S2 could become is 2**31-1 */
	or     r7,r0,r11           /* store r11 into r7 for conversion */
	
/* Now check for negative double precision sources.  If the exponent is 30, */
/* then convert the false alarm.  If the exponent is 31, then check the mantissa */
/* bits which correspond to integer bits.  If any of them are a one, then there */
/* is overflow.  If they are zero, then check the guard, round, and sticky bits. */
/* Round toward zero and positive will not cause a roundup, but round toward */
/* nearest and negative may, so perform those roundings.  If there is no overflow, */
	/* then convert and return from subroutine. */
	
checkdoubn:  cmp    r11,r10,29           /* compare to 30, but exp. off by 1 */
	bb1    eq,r11,conversiondn  /* false alarm if exp. = 30 */
	extu   r10,r8,11<21>        /* check upper bits of lower mantissa */
	bcnd   ne0,r10,overflw      /* one of the bits is a 1, so overflow */
	extu   r10,r7,20<0>         /* check upper bits of upper mantissa */
	bcnd   ne0,r10,overflw      /* one of the bits is a 1, so overflow */
	bb0    rndlo,r1,possround      /* rounding mode is either round near or */
	/* round negative, which may cause a */
	/* round */
	br.n   FPintov_return               /* round positive, which will not cause a */
	/* round */
	set    r6,r0,1<sign>        /* rounding mode is either round zero or */
possround:   extu   r12,r8,1<20>         /* get guard bit */
	extu   r11,r8,20<0>         /* get bits for sticky bit */
	bcnd.n eq0,r11,nostickyn    /* do not set sticky */
	mak    r12,r12,1<1>         /* set up field for branch table */
	set    r12,r12,1<0>         /* set sticky bit */
nostickyn:   bb1    rndhi,r1,negative    /* rounding mode is negative */
nearest:     cmp    r12,r12,3            /* are both guard and sticky set */
	bb1    eq,r12,overflw       /* both guard and sticky are set, */
	/* so signal overflow */
	or     r6,r0,r0             /* clear destination register r6 */
	br.n   FPintov_return               /* return from subroutine */
	set    r6,r6,1<sign>        /* set the sign bit and take care of */
	/* this special case */
negative:    bcnd   ne0,r12,overflw      /* -2**31 will be rounded to -(2**31+1), */
	/* so signal overflow */
	or     r6,r0,r0             /* clear destination register r6 */
	br.n   FPintov_return               /* return from subroutine */
	set    r6,r6,1<sign>        /* set the sign bit and take care of */
	/* this special case */
	
	/* since the exp. was 30, and there was */
	/* no round-up, the largest number that */
	/* S2 could have been was 2**31 - 1 */
	
	
d492 9
a500 9
	
conversionsp: extu  r6,r8,3<29>         /* extract lower bits of integer */
	mak   r6,r6,3<7>           /* shift left to correct place in integer */
	mak   r10,r7,20<10>        /* shift left upper bits of integer */
	or    r6,r6,r10            /* form most of integer */
	br.n  FPintov_return               /* return from subroutine */
	set   r6,r6,1<30>          /* set hidden one */
	
	
d502 16
a517 15
	
conversionsn: bb1   eq,r11,exp31s       /* use old r11 to see if exp. is 31 */
	extu  r6,r8,3<29>          /* extract lower bits of mantissa */
	mak   r6,r6,3<7>           /* shift left to correct place in integer */
	mak   r10,r7,20<10>        /* shift left upper bits of integer */
	or    r6,r6,r10            /* form most of integer */
	set   r6,r6,1<30>          /* set hidden one */
	or.c  r6,r0,r6             /* negate result */
	br.n  FPintov_return               /* return from subroutine */
	addu  r6,r6,1              /* add 1 to get 2''s complement */
exp31s:      or    r6,r0,r0             /* clear r6 */
	br.n  FPintov_return               /* return from subroutine */
	set   r6,r6,1<sign>        /* set sign bit */
	
	
d519 101
a619 91
	
conversiondp: extu r6,r8,10<22>         /* extract lower bits of integer */
	mak   r10,r7,20<10>        /* shift left upper bits of integer */
	or    r6,r6,r10            /* form most of integer */
	br.n  FPintov_return               /* return from subroutine */
	set   r6,r6,1<30>          /* set hidden one */
	
	
	/* Convert the double precision negative floating point number.  The number, */
	/* whose exponent is 30, must be rounded before converting.  Bits 4 and 3 are */
	/* the rounding mode, and bits 2, 1, and 0 are the guard, round, and sticky */
	/* bits for the branch table. */
	
conversiondn: extu   r12,r8,1<22>       /* get LSB for integer with exp. = 30 */
	mak    r12,r12,1<2>        /* start to set up field for branch table */
	extu   r11,r8,1<21>        /* get guard bit */
	mak    r11,r11,1<1>        /* set up field for branch table */
	or     r12,r11,r12         /* set up field for branch table */
	extu   r11,r8,21<0>        /* get bits for sticky bit */
	bcnd   eq0,r11,nostkyn     /* do not set sticky */
	set    r12,r12,1<0>        /* set sticky bit */
nostkyn:     rot    r11,r1,0<rndlo>     /* shift rounding mode to 2 LSB''s */
	mak    r11,r11,2<3>        /* set up field, clear other bits */
	or     r12,r11,r12         /* set up field for branch table */
	lda    r12,r0[r12]         /* scale r12 */
	or.u   r12,r12,hi16(ntable)/* load pointer into table */
	addu   r12,r12,lo16(ntable)
	jmp    r12                 /* jump into branch table */
	
ntable:      br     nnoaddone
n00001:      br     nnoaddone
n00010:      br     nnoaddone
n00011:      br     naddone
n00100:      br     nnoaddone
n00101:      br     nnoaddone
n00110:      br     naddone
n00111:      br     naddone
n01000:      br     nnoaddone
n01001:      br     nnoaddone
n01010:      br     nnoaddone
n01011:      br     nnoaddone
n01100:      br     nnoaddone
n01101:      br     nnoaddone
n01110:      br     nnoaddone
n01111:      br     nnoaddone
n10000:      br     nnoaddone
n10001:      br     naddone
n10010:      br     naddone
n10011:      br     naddone
n10100:      br     nnoaddone
n10101:      br     naddone
n10110:      br     naddone
n10111:      br     naddone
n11000:      br     nnoaddone
n11001:      br     nnoaddone
n11010:      br     nnoaddone
n11011:      br     nnoaddone
n11100:      br     nnoaddone
n11101:      br     nnoaddone
n11110:      br     nnoaddone
n11111:      br     nnoaddone
	
	
	/* Add one to the mantissa, and check to see if it overflows to -2**31. */
/* The conversion is done in nnoaddone:. */
	
naddone:     or     r10,r0,r0           /* clear r10 */
	set    r10,r10,1<22>       /* set LSB bit to 1 for adding */
	add.co r8,r8,r10           /* add the 1 obtained from rounding */
	clr    r7,r7,12<20>        /* clear exponent and sign */
	add.ci r7,r0,r7            /* add carry */
	bb1    20,r7,maxneg        /* rounded to -2**31,handle separately */
	/* the exponent was originally 30 */
nnoaddone:   extu   r6,r8,11<22>        /* extract lower bits of integer */
	mak    r10,r7,20<10>       /* shift left upper bits of integer */
	or     r6,r6,r10           /* form most of integer */
	set    r6,r6,1<30>         /* set hidden one */
	or.c   r6,r0,r6            /* negate integer */
	br.n   FPintov_return              /* return from subroutine */
	addu   r6,r6,1             /* add 1 to get 2''s complement */
	
maxneg:      or     r6,r0,r0            /* clear integer */
	br.n   FPintov_return              /* return from subroutine */
	set    r6,r6,1<sign>       /* set sign bit */
	
	
	/* For valid overflows, check to see if the integer overflow user handler is  */
	/* set.  If it is set, then go to user handler, else write the correctly */
	/* signed largest integer. */
	
overflw:  
d621 5
a625 5
	bb0.n  oper,r3,nohandler   /* do not go to user handler routine */
	set    r2,r2,1<oper>       /* set invalid operand bit */
	bsr    _handler            /* go to user handler routine */
	br     FPintov_return              /* return from subroutine */
nohandler:   
d627 47
a673 8
	bb0.n  sign,r7,FPintov_return      /* if positive then return from subroutine */
	set    r6,r6,31<0>         /* set result to largest positive integer */
	or.c   r6,r0,r6            /* negate r6,giving largest negative int. */
	
FPintov_return:      ld     r1,r31,0     /* load return address from memory */
	jmp    r1                  /* return from subroutine */
	
	data
d675 4
a678 148
/* Some instructions only have the S2 operations, so clear S1HI and S1LO */
/* for those instructions so that the previous contents of S1HI and S1LO */
/* do not influence this instruction. */

             text
GLOBAL(FPresoper)
	     st	    r1, r31, 0
	     extu   r10,r9,5<11>   /* extract opcode */
/*             cmp    r11,r10,FSQRTop ;compare to FSQRT */
/*             bb1    eq,r11,S1clear ;clear S1 if instruction only had S2 operand */
             cmp    r11,r10,INTop  /* compare to INT */
             bb1    eq,r11,S1clear /* clear S1 if instruction only had S2 operand */
             cmp    r11,r10,NINTop /* compare to NINT */
             bb1    eq,r11,S1clear /* clear S1 if instruction only had S2 operand */
             cmp    r11,r10,TRNCop /* compare to TRNC */
             bb0    eq,r11,opercheck /* check for reserved operands */

ASGLOBAL(S1clear)
	     or     r5,r0,r0       /* clear any NaN''s, denorms, or infinities */
             or     r6,r0,r0       /* that may be left in S1HI,S1LO from a  */
                                   /* previous instruction */

/* r12 contains the following flags: */
/* 		bit 9 -- s1sign */
/* 		bit 8 -- s2sign */
/* 		bit 7 -- s1nan */
/* 		bit 6 -- s2nan */
/* 		bit 5 -- s1inf */
/* 		bit 4 -- s2inf */
/* 		bit 3 -- s1zero */
/* 		bit 2 -- s2zero */
/* 		bit 1 -- s1denorm */
/* 		bit 0 -- s2denorm */

/* Using code for both single and double precision, check if S1 is either */
/* a NaN or infinity and set the appropriate flags in r12.  Then check if */
/* S2 is a NaN or infinity.  If it is a NaN, then branch to the NaN routine. */

             
ASGLOBAL(opercheck)
	     extu   r10,r5,11<20>        /* internal representation for double */
             bb1.n  s1size,r9,S1NaNdoub /* S1 is double precision */
             or     r12,r0,r0      /* clear operand flag register */
ASGLOBAL(S1NaNsing)
	     xor    r10,r10,0x0080       /* internal representation for single */
             ext    r10,r10,8<0>         /* precision is IEEE 8 bits sign extended */
                                         /* to 11 bits; for real exp. > 0, the */
                                         /* above instructions gives a result exp. */
                                         /* that has the MSB flipped and sign */
                                         /* extended like in the IMPCR */
             cmp    r11,r10,127    /* Is exponent equal to IEEE 255 (internal 127) */
             bb1    ne,r11,S2NaN   /* source 1 is not a NaN or infinity */
             mak    r10,r5,20<0>   /* load r10 with upper bits of S1 mantissa */
             extu   r11,r6,3<29>   /* get 3 upper bits of lower word */
             or     r11,r10,r11    /* combine any existing 1''s */
             bcnd   eq0,r11,noS1NaNs /* since r11 can only hold 0 or a positive */
                                   /* number, branch to noS1NaN when eq0 */
             br.n   S2NaN          /* see if S2 has a NaN */
             set    r12,r12,1<s1nan> /* indicate that S1 has a NaN */
ASGLOBAL(noS1NaNs)
	     br.n   S2NaN          /* check contents of S2 */
             set    r12,r0,1<s1inf> /* indicate that S1 has an infinity */

ASGLOBAL(S1NaNdoub)
	     xor    r10,r10,0x0400       /* precision is the same IEEE 11 bits  */
                                         /* The */
                                         /* above instructions gives a result exp. */
                                         /* that has the MSB flipped and sign */
                                         /* extended like in the IMPCR */
             cmp    r11,r10,1023   /* Is exp. equal to IEEE 2047 (internal 1023) */
             bb1    ne,r11,S2NaN   /* source 1 is not a NaN or infinity */
             mak    r10,r5,20<0>   /* load r10 with upper bits of S1 mantissa */
             or     r11,r6,r10     /* combine existing 1''s of mantissa */
             bcnd   eq0,r11,noS1NaNd /* since r11 can only hold 0 or a positive */
                                   /* number, branch to noS1NaN when eq0 */
             br.n   S2NaN          /* see if S2 has a NaN */
             set    r12,r12,1<s1nan> /* indicate that S1 has a NaN */
ASGLOBAL(noS1NaNd)
	     set    r12,r0,1<s1inf> /* indicate that S1 has an infinity */

ASGLOBAL(S2NaN)
	     bb1.n  s2size,r9,S2NaNdoub /* S1 is double precision */
             extu   r10,r7,11<20>        /* internal representation for double */
ASGLOBAL(S2NaNsing)
	     xor    r10,r10,0x0080       /* internal representation for single */
             ext    r10,r10,8<0>         /* precision is IEEE 8 bits sign extended */
                                         /* to 11 bits; for real exp. > 0, the */
                                         /* above instruction gives a result exp. */
                                         /* that has the MSB flipped and sign */
                                         /* extended like in the IMPCR */
             cmp    r11,r10,127    /* Is exponent equal to IEEE 255 (internal 127) */
             bb1    ne,r11,inf     /* source 2 is not a NaN or infinity */
             mak    r10,r7,20<0>   /* load r10 with upper bits of S1 mantissa */
             extu   r11,r8,3<29>   /* get 3 upper bits of lower word */
             or     r11,r10,r11    /* combine any existing 1''s */
             bcnd   eq0,r11,noS2NaNs /* since r11 can only hold 0 or a positive */
                                   /* number, branch to noS2NaNs when eq0 */
             br.n   _NaN           /* branch to NaN routine */
             set    r12,r12,1<s2nan> /* indicate that s2 has a NaN */
ASGLOBAL(noS2NaNs)
	     bb0    s1nan,r12, 1f /* branch to NaN if S1 is a NaN */
	     br	    _NaN
1:           br.n   _infinity      /* If S1 had a NaN we would have already */
                                   /* branched, and S2 does not have a NaN, but */
                                   /* it does have an infinity, so branch to  */
                                   /* handle the finity */
             set    r12,r12,1<s2inf> /* indicate that S2 has an infinity */

ASGLOBAL(S2NaNdoub)
	     xor    r10,r10,0x0400       /* precision is the same IEEE 11 bits  */
                                         /* The */
                                         /* above instruction gives a result exp. */
                                         /* that has the MSB flipped and sign */
                                         /* extended like in the IMPCR */
             cmp    r11,r10,1023   /* Is exp. equal to IEEE 2047 (internal 1023) */
             bb1    ne,r11,inf     /* source 2 is not a NaN or infinity */
             mak    r10,r7,20<0>   /* load r10 with upper bits of S2 mantissa */
             or     r11,r8,r10     /* combine existing 1''s of mantissa */
             bcnd   eq0,r11,noS2NaNd /* since r11 can only hold 0 or a positive */
                                   /* number, branch to noS2NaNd when eq0 */
             br.n   _NaN           /* branch to NaN routine */
             set    r12,r12,1<s2nan> /* indicate that s2 has a NaN */
ASGLOBAL(noS2NaNd)
	     bb0    s1nan,r12,1f /* branch to NaN if S1 is a NaN */
	     br	    _NaN
1:           br.n   _infinity      /* If S1 had a NaN we would have already */
                                   /* branched, and S2 does not have a NaN, but */
                                   /* it does have an infinity, so branch to  */
                                   /* handle the finity */
             set    r12,r12,1<s2inf> /* indicate that S2 has an infinity */


/* If S2 was a NaN, the routine would have already branched to NaN.  If S1 */
/* is a NaN, then branch to NaN.  If S1 is not a NaN and S2 is infinity, then */
/* we would have already branched to infinity.  If S1 is infinity, then branch. */
/* If the routine still has not branched, then branch to denorm, the only  */
/* reserved operand left. */

ASGLOBAL(inf)
	     bb0    s1nan,r12,1f  /* branch if S1 has a NaN and S2 does not */
	     br	    _NaN
1:           bb0    s1inf,r12,2f    /* Neither S1 or S2 has a NaN, and we would */
                                    /* have branched already if S2 had an  */
                                    /* infinity, so branch if S1 is infinity */
/*
 * The above "bb0 s1inf, r12,2f" had been a "bb1", but it just didn't make
 * sense (and didn't work, either), so I changed it.
 * 	jfriedl Dec 1, 1989.
a679 2
	     br	    _infinity
2:
d681 91
a771 2
	br     _denorm        /* branch to denorm, the only remaining */
                                   /* alternative */
d773 7
a779 2
/* function _FPunderflow --       */
/* The documentation for this release give an overall description of this code. */
d781 11
a791 2
                text
                global _FPunderflow
d793 6
a798 4
/* First check for an underflow user handler.  If there is not one, then */
/* branch to the routine to make a denormalized number.  Before branching */
/* to the underflow user handler, add 192 to a single precision exponent */
/* and 1536 to a double precision exponent. */
d800 2
a801 1
_FPunderflow:   st    r1,r31,0 /* save return address */
d803 13
a815 10
		bb0 efunf,r12,denorm /* jump to default procedure */
                bb1.n destsize,r12,doubleprec /* double precision destination */
                set   r2,r2,1<underflow>  /* set underflow flag in FPSR */
singleprec:     or.u  r6,r0,0x0c00 /* load exponent adjust 192 */
                br.n  callundhand  /* branch to call handler for user handler */
                add   r12,r6,r12   /* adjust single precision exponent */
doubleprec:     or.u  r6,r0,0x6000 /* load exponent adjust 1536 */
                add   r12,r6,r12   /* adjust double precision exponent */
callundhand:    bsr   _handler     /* call handler for user handler */
                br    Ureturn       /* return from subroutine */
d818 24
a841 20
/* Now the floating point number, which has an exponent smaller than what */
/* IEEE allows, must be denormalized.  Denormalization is done by calculating */
/* the difference between a denormalized exponent and an underflow exponent and */
/* shifting the mantissa by that amount.  A one may need to be subtracted from  */
/* the LSB if a one was added during rounding. */
/* r9 is used to contain the guard, round, sticky, and an inaccuracy bit in */
/* case some bits were shifted off the mantissa during denormalization. */
/* r9 will contain: bit 4 -- new addone if one added during rounding  */
/*                           after denormalization */
/*                  bit 3 -- inaccuracy flag caused by denormalization */
/* 			   or pre-denormalization inexactness */
/*                  bit 2 -- guard bit of result */
/*                  bit 1 -- round bit of result */
/*                  bit 0 -- sticky bit of result */

denorm:         bb1.n destsize,r12,Udouble /* denorm for double */
                extu  r9,r10,3<26>   /* load r9 with grs */
Usingle:         mak   r5,r10,21<3> /* extract high 21 bits of mantissa */
                extu  r6,r11,3<29> /* extract low 3 bits of mantissa */
                or    r11,r5,r6     /* form 24 bits of mantissa */
d844 397
a1240 326
                bb0.n 25,r10,nounrounds /* do not unround if addone bit clear */
                extu  r6,r12,12<20>  /* extract signed exponent from IMPCR */
unrounds:       subu  r11,r11,1      /* subtract 1 from mantissa */
/* If the hidden bit is cleared after subtracting the one, then the one added */
/* during the rounding must have propagated through the mantissa.  The exponent */
/* will need to be decremented. */
                bb1   23,r11,nounrounds /* if hidden bit is set,then exponent does */
                                   /* not need to be decremented */
decexps:        sub   r6,r6,1      /* decrement exponent 1 */
                set   r11,r11,1<23>  /* set the hidden bit */

/* For both single and double precision, there are cases where it is easier */
/* and quicker to make a special case.  Examples of this are if the shift  */
/* amount is only 1 or 2, or all the mantissa is shifted off, or all the */
/* mantissa is shifted off and it is still shifting, or, in the case of  */
/* doubles, if the shift amount is around the boundary of MANTLO and MANTHI. */

nounrounds:     or    r8,r0,lo16(0x00000f81)  /* load r8 with -127 in decimal  */
					    /* for lowest 12 bits */
                sub   r7,r8,r6     /* find difference between two exponents, */
                                   /* this amount is the shift amount */
                cmp   r6,r7,3      /* check to see if r7 contains 3 or more */
                bb1   ge,r6,threesing /* br to code that handles shifts of >=3 */
                cmp   r6,r7,2      /* check to see if r7 contains 2 */
                bb1   eq,r6,twosing /* br to code that handles shifts of 2 */
one:            rot   r9,r9,0<1>   /* rotate roundoff register once, this places */
                                   /* guard in round and round in sticky */
                bb0   31,r9,nosticky1s/* do not or round and sticky if sticky is */
                                   /* 0, this lost bit will be cleared later */
                set   r9,r9,1<0>   /* or round and sticky */
nosticky1s:     bb0   0,r11,guardclr1s /* do not set guard bit if LSB = 0 */
                set   r9,r9,1<2>   /* set guard bit        */
guardclr1s:     extu  r11,r11,31<1> /* shift mantissa right 1 */
                br.n  round        /* round result */
                mak   r9,r9,3<0>   /* clear bits lost during rotation */

twosing:        rot   r9,r9,0<2>   /* rotate roundff register twice, this places */
                                   /* guard in sticky */
                bb0   30,r9,nosticky2s /* do not or guard and sticky if stick is 0 */
                                   /* this lost bit will be cleared later */
                br.n  noround2s    /* skip or old guard and old round if old */
                                   /* sticky set */
                set   r9,r9,1<0>   /* or guard and sticky */
nosticky2s:     bb0   31,r9,noround2s /* do not or guard and round if round is 0 */
                                   /* this lost bit will be cleared later */
                set   r9,r9,1<0>   /* or guard and round */
noround2s:      bb0   0,r11,roundclr2s /* do not set round bit if LSB = 0 */
                set   r9,r9,1<1>   /* set round bit */
roundclr2s:     bb0   1,r11,guardclr2s /* do not set guard bit if LSB + 1 = 0 */
                set   r9,r9,1<2>   /* set guard bit */
guardclr2s:     extu  r11,r11,30<2>  /* shift mantissa right 2 */
                br.n  round        /* round result */
                mak   r9,r9,3<0>   /* clear bits lost during rotation */

threesing:      bb1   0,r9,noguard3s /* check sticky initially */
                                     /* sticky is set, forget most of the oring */
nosticky3s:     bb0   1,r9,noround3s  /* check round initially, do not set sticky */
                br.n  noguard3s    /* forget most of the rest of oring */
                set   r9,r9,1<0>      /* if round is clear,set sticky if round set */
noround3s:      bb0.n 2,r9,noguard3s  /* check guard initially, do not set sticky */
                clr   r9,r9,2<1>   /* clear the original guard and round for when */
                                      /* you get to round section */
                set   r9,r9,1<0>      /* if guard is clear,set sticky if guard set */
noguard3s:      cmp   r6,r7,23     /* check if # of shifts is <=23 */
                bb1   gt,r6,s24    /* branch to see if shifts = 24 */
                sub   r6,r7,2      /* get number of bits to check for sticky */
                mak   r6,r6,5<5>   /* shift width into width field */
                mak   r8,r11,r6     /* mask off shifted bits -2 */
                ff1   r8,r8        /* see if r8 has any ones */
                bb1   5,r8,nostky23 /* do not set sticky if no ones found */
                set   r9,r9,1<0>   /* set sticky bit */
nostky23:       or    r8,r0,34     /* start code to get new mantissa plus two */
                                   /* extra bits for new round and new guard bits */
                subu  r8,r8,r7     
                mak   r8,r8,5<5>   /* shift field width into second five bits */
                extu  r6,r6,5<5>   /* shift previous shifted -2 into offset field */
                or    r6,r6,r8     /* complete field */
                extu  r11,r11,r6     /* form new mantissa with two extra bits */

                bb0   0,r11,nornd3s /* do not set new round bit */
                set   r9,r9,1<1>   /* set new round bit */
nornd3s:        bb0   1,r11,nogrd3s /* do not set new guard bit */
                set   r9,r9,1<2>   /* set new guard bit */
nogrd3s:        br.n  round        /* round mantissa */
                extu  r11,r11,30<2>  /* shift off remaining two bits */

s24:            cmp   r6,r7,24     /* check to see if # of shifts is 24 */
                bb1   gt,r6,s25    /* branch to see if shifts = 25 */
                bb1   0,r9,nostky24 /* skip checking if old sticky set */
                extu  r8,r11,22<0>  /* prepare to check bits that will be shifted */
                                   /* into the sticky */
                ff1   r8,r8        /* see if there are any 1''s */
                bb1   5,r8,nostky24 /* do not set sticky if no ones found */
                set   r9,r9,1<0>   /* set sticky bit */
nostky24:       bb0   22,r11,nornd24 /* do not set new round bit */
                set   r9,r9,1<1>   /* set new round bit */
nornd24:        set   r9,r9,1<2>   /* set new guard bit,this is hidden bit */
                br.n  round        /* round mantissa */
                or    r11,r0,r0     /* clear r11, all of mantissa shifted off */
                
s25:            cmp   r6,r7,25     /* check to see if # of shifts is 25 */
                bb1   gt,r6,s26    /* branch to execute for shifts => 26 */
                bb1   0,r9,nostky25 /* skip checking if old sticky set */
                extu  r8,r11,23<0> /* prepare to check bits that will be shifted */
                                   /* into the sticky */
                ff1   r8,r8        /* see if there are any 1''s */
                bb1   5,r8,nostky25 /* do not set sticky if no ones found */
                set   r9,r9,1<0>   /* set sticky bit */
nostky25:       set   r9,r9,1<1>   /* set new round bit,this is hidden bit */
                clr   r9,r9,1<2>   /* clear guard bit since nothing shifted in */
                br.n  round        /* round and assemble result */
                or    r11,r0,r0    /* clear r11, all of mantissa shifted off */

s26:            set   r9,r9,1<0>   /* set sticky bit,this contains hidden bit */
                clr   r9,r9,2<1>   /* clear guard and round bits since nothing  */
                                   /* shifted in  */
                br.n  round        /* round and assemble result */
                or    r11,r0,r0    /* clear mantissa */

Udouble:         mak   r5,r10,21<0> /* extract upper bits of mantissa */
                bb0.n 25,r10,nounroundd /* do not unround if addone bit clear */
                extu  r6,r12,12<20>/* extract signed exponenet from IMPCR */
unroundd:       or    r8,r0,1
		subu.co  r11,r11,r8     /* subtract 1 from mantissa */
                subu.ci  r5,r5,r0       /* subtract borrow from upper word */
                bb1   20,r5,nounroundd /* if hidden bit is set, then exponent does */
                                       /* not need to be decremented */
decexpd:        sub   r6,r6,1      /* decrement exponent 1 */
                set   r5,r5,1<20>  /* set the hidden bit */

nounroundd:     or    r8,r0,lo16(0x00000c01) /* load r8 with -1023 in decimal  */
					     /* for lowest 12 bits  */
                sub   r7,r8,r6     /* find difference between two exponents, */
                                   /* this amount is the shift amount */
                cmp   r6,r7,3      /* check to see if r7 contains 3 or more */
                bb1   ge,r6,threedoub /* br to code that handles shifts of >=3 */
                cmp   r6,r7,2      /* check to see if r7 contains 2 */
                bb1   eq,r6,twodoub /* br to code that handles shifts of 2 */

onedoub:        rot   r9,r9,0<1>   /* rotate roundoff register once, this places */
                                   /* guard in round and round in sticky */
                bb0   31,r9,nosticky1d/* do not or round and sticky if sticky is 0 */
                                   /* this lost bit will be cleared later */
                set   r9,r9,1<0>   /* or old round and old sticky into new sticky */
nosticky1d:     bb0   0,r11,guardclr1d /* do not set new guard bit if old LSB = 0 */
                set   r9,r9,1<2>   /* set new guard bit */
guardclr1d:     extu  r11,r11,31<1> /* shift lower mantissa over 1 */
                mak   r6,r5,1<31>  /* shift off low bit of high mantissa */
                or    r11,r6,r11   /* load high bit onto lower mantissa */
                extu  r5,r5,20<1>  /* shift right once upper 20 bits of mantissa */
                br.n  round        /* round mantissa and assemble result */
                mak   r9,r9,3<0>   /* clear bits lost during rotation */

twodoub:        rot   r9,r9,0<2>   /* rotate roundoff register twice, this places */
                                   /* old guard into sticky */
                bb0   30,r9,nosticky2d /* do not or old guard and old sticky if  */
                                       /* old sticky is 0 */
                br.n  noround2d    /* skip or of old guard and old round if old */
                                   /* sticky set */
                set   r9,r9,1<0>   /* or old guard and old sticky into new sticky */
nosticky2d:     bb0   31,r9,noround2d /* do not or old guard and old round if */
                                      /* old round is 0 */
                set   r9,r9,1<0>   /* or old guard and old round into new sticky */
noround2d:      bb0   0,r11,roundclr2d /* do not set round bit if old LSB = 0 */
                set   r9,r9,1<1>   /* set new round bit */
roundclr2d:     bb0   1,r11,guardclr2d /* do not set guard bit if old LSB + 1 = 0 */
                set   r9,r9,1<2>   /* set new guard bit */
guardclr2d:     extu  r11,r11,30<2> /* shift lower mantissa over 2 */
                mak   r6,r5,2<30>  /* shift off low bits of high mantissa */
                or    r11,r6,r11   /* load high bit onto lower mantissa */
                extu  r5,r5,19<2>  /* shift right twice upper 19 bits of mantissa */
                br.n  round        /* round mantissa and assemble result */
                mak   r9,r9,3<0>   /* clear bits lost during rotation */

threedoub:      bb1   0,r9,noguard3d /* checky sticky initially */
                                    /* sticky is set, forget most of rest of oring */
nosticky3d:     bb0   1,r9,noround3d /* check old round, do not set sticky if  */
                                     /* old round is clear, set otherwise */
                br.n  noguard3d    /* sticky is set, forget most of rest of oring */
                set   r9,r9,1<0>   /* set sticky if old round is set */
noround3d:      bb0   2,r9,noguard3d /* check old guard, do not set sticky if 0 */
                clr   r9,r9,2<1>   /* clear the original guard and round for when */
                                      /* you get to round section */
                set   r9,r9,1<0>   /* set sticky if old guard is set */
noguard3d:      cmp   r6,r7,32     /* do I need to work with a 1 or 2 word mant. */
                                   /* when forming sticky, round and guard */
                bb1   gt,r6,d33    /* jump to code that handles 2 word mantissas */
                sub   r6,r7,2      /* get number of bits to check for sticky */
                mak   r6,r6,5<5>   /* shift width into width field */
                mak   r8,r11,r6    /* mask off shifted bits -2 */
                ff1   r8,r8        /* see if r8 has any ones */
                bb1   5,r8,nostky32 /* do not set sticky if no ones found */
                set   r9,r9,1<0>   /* set sticky bit */
nostky32:       or    r8,r0,34     /* start code to get new mantissa plus two */
                                   /* extra bits for new round and new guard bits, */
                                   /* the upper word bits will be shifted after */
                                   /* the round and guard bits are handled */
                subu  r8,r8,r7     
                mak   r8,r8,5<5>   /* shift field width into second five bits */
                extu  r6,r6,5<5>   /* shift previous shifted -2 into offset field */
                or    r6,r6,r8     /* complete bit field */
                extu  r11,r11,r6   /* partially form new low mantissa with 2 more  */
                                   /* bits */
                bb0   0,r11,nornd32d /* do not set new round bit */
                set   r9,r9,1<1>   /* set new round bit */
nornd32d:       bb0   1,r11,nogrd32d /* do not set new guard bit */
                set   r9,r9,1<2>   /* set new guard bit */
nogrd32d:       extu  r11,r11,30<2> /* shift off remaining two bits */
                mak   r6,r7,5<5>   /* shift field width into second 5 bits, if the */
                                   /* width is 32, then these bits will be 0 */
                or    r8,r0,32     /* load word length into r8 */
                sub   r8,r8,r7     /* form offset for high bits moved to low word */
                or    r6,r6,r8     /* form complete bit field */
                mak   r6,r5,r6     /* get shifted bits of high word */
                or    r11,r6,r11   /* form new low word of mantissa */
		bcnd  ne0,r8,regular33 /* do not adjust for special case of r8 */
		br.n  round	       /* containing zeros, which would cause */
		or    r5,r0,r0         /* all of the bits to be extracted under */
				       /* the regular method */
regular33:      mak   r6,r7,5<0>   /* place lower 5 bits of shift into r6 */
                mak   r8,r8,5<5>   /* shift r8 into width field */
                or    r6,r6,r8     /* form field for shifting of upper bits */
                br.n  round        /* round and assemble result */
                extu  r5,r5,r6     /* form new high word mantissa */

d33:            cmp   r6,r7,33     /* is the number of bits to be shifted is 33? */
                bb1   gt,r6,d34    /* check to see if # of bits is 34 */
                bb1   0,r9,nostky33 /* skip checking if old sticky set */
                mak   r6,r11,31<0> /* check bits that will be shifted into sticky */
                ff1   r8,r8        /* check for ones */
                bb1   5,r8,nostky33 /* do not set sticky if there are no ones */
                set   r9,r9,1<0>   /* set new sticky bit */
nostky33:       bb0   31,r11,nornd33 /* do not set round if bit is not a 1 */
                set   r9,r9,1<1>   /* set new round bit */
nornd33:        bb0   0,r5,nogrd33 /* do not set guard bit if bit is not a 1 */
                set   r9,r9,1<2>   /* set new guard bit */
nogrd33:        extu  r11,r5,31<1> /* shift high bits into low word */
                br.n  round        /* round and assemble result */
                or    r5,r0,r0     /* clear high word */

d34:            cmp   r6,r7,34     /* is the number of bits to be shifted 34? */
                bb1   gt,r6,d35    /* check to see if # of bits is >= 35 */
                bb1   0,r9,nostky34 /* skip checking if old sticky set */
                ff1   r8,r11       /* check bits that will be shifted into sticky */
                bb1   5,r8,nostky34 /* do not set sticky if there are no ones */
                set   r9,r9,1<0>   /* set new sticky bit */
nostky34:       bb0   0,r5,nornd34 /* do not set round if bit is not a 1 */
                set   r9,r9,1<1>   /* set new round bit */
nornd34:        bb0   1,r5,nogrd34 /* do not set guard bit if bit is not a 1 */
                set   r9,r9,1<2>   /* set new guard bit */
nogrd34:        extu  r11,r5,30<2> /* shift high bits into low word */
                br.n  round        /* round and assemble result */
                or    r5,r0,r0     /* clear high word */

d35:            cmp   r6,r7,52     /* see if # of shifts is 35 <= X <= 52 */
                bb1   gt,r6,d53    /* check to see if # of shifts is 52 */
                bb1.n 0,r9,nostky35 /* skip checking if old sticky set */
                sub   r7,r7,34     /* subtract 32 from # of shifts so that opera- */
                                   /* tions can be done on the upper word, and  */
                                   /* then subtract two more checking guard and */
                                   /* sticky bits */
                ff1   r8,r11       /* see if lower word has a bit for sticky */
                bb1   5,r8,stkycheck35 /* see if upper word has any sticky bits    */
                br.n  nostky35     /* quit checking for sticky */
                set   r9,r9,1<0>   /* set sticky bit */
stkycheck35:    mak   r6,r7,5<5>   /* place width into width field */
                mak   r8,r5,r6     /* mask off shifted bits - 2 */
                ff1   r8,r8        /* see if r8 has any ones */
                bb1   5,r8,nostky35 /* do not set sticky if no ones found */
                set   r9,r9,1<0>   /* set sticky bit */
nostky35:       or    r8,r0,32     /* look at what does not get shifted off plus */
                                   /* round and sticky, remember that the r7 value */
                                   /* was adjusted so that it did not include */
                                   /* new round or new sticky in shifted off bits */
                subu  r8,r8,r7     /* complement width  */
                mak   r8,r8,5<5>   /* shift width into width field */
                or    r8,r7,r8     /* add offset field */
                extu  r11,r5,r8    /* extract upper bits into low word */
                bb0   0,r11,nornd35 /* do not set new round bit */
                set   r9,r9,1<1>   /* set new round bit */
nornd35:        bb0   1,r11,nogrd35 /* do not set new guard bit */
                set   r9,r9,1<2>   /* set new guard bit */
nogrd35:        extu  r11,r11,30<2> /* shift off remaining guard and round bits */
                br.n  round         /* round and assemble result */
                or    r5,r0,r0      /* clear high word */

d53:            cmp   r6,r7,53     /* check to see if # of shifts is 53 */
                bb1   gt,r6,d54    /* branch to see if shifts = 54 */
                bb1   0,r9,nostky53 /* skip checking if old sticky set */
                ff1   r8,r11       /* see if lower word has a bit for sticky */
                bb1   5,r8,stkycheck53 /* see if upper word has any sticky bits    */
                br.n  nostky53     /* quit checking for sticky */
                set   r9,r9,1<0>   /* set sticky bit */
stkycheck53:    mak   r6,r5,19<0>  /* check bits that are shifted into sticky */
                ff1   r8,r6        /* see if r6 has any ones */
                bb1   5,r8,nostky53 /* do not set sticky if no ones found */
                set   r9,r9,1<0>   /* set sticky bit */
nostky53:       bb0   19,r5,nornd53 /* do not set new round bit */
                set   r9,r9,1<1>   /* set new round bit */
nornd53:        set   r9,r9,1<2>   /* set new guard bit,this is hidden bit */
                or    r5,r0,r0     /* clear high word */
                br.n  round        /* round and assemble result */
                or    r11,r0,r0    /* clear low word */

d54:            cmp   r6,r7,54     /* check to see if # of shifts is 54 */
                bb1   gt,r6,d55    /* branch to execute for shifts =>55 */
                bb1   0,r9,nostky54 /* skip checking if old sticky set */
                ff1   r8,r11       /* see if lower word has a bit for sticky */
                bb1   5,r8,stkycheck54 /* see if upper word has any sticky bits    */
                br.n  nostky54     /* quit checking for sticky */
                set   r9,r9,1<0>   /* set sticky bit */
stkycheck54:    mak   r6,r5,20<0>  /* check bits that are shifted into sticky */
                ff1   r8,r6        /* see if r6 has any ones */
                bb1   5,r8,nostky54 /* do not set sticky if no ones found */
                set   r9,r9,1<0>   /* set sticky bit */
nostky54:       set   r9,r9,1<1>   /* set new round bit,this is hidden bit */
                clr   r9,r9,1<2>   /* clear guard bit since nothing shifted in */
                or    r5,r0,r0     /* clear high word */
                br.n  round        /* round and assemble result */
                or    r11,r0,r0    /* clear low word */

d55:            set   r9,r9,1<0>   /* set new sticky bit,this contains hidden bit */
                clr   r9,r9,2<1>   /* clear guard and round bits since nothing */
                                   /* shifted in */
                or    r5,r0,r0     /* clear high word */
                or    r11,r0,r0    /* clear low word */
d1244 1
a1244 1
/* or sticky is set.  If all are clear, then there is no denormalization loss */
d1246 3
a1248 3
/* For rounding, a branch table is set up.  The left two most bits are the  */
/* rounding mode.  The third bit is either the LSB of the mantissa or the */
/* sign bit, depending on the rounding mode.  The three LSB''s are the guard, */
d1251 86
a1336 82
round:          ff1   r8,r9         /* see if there is denormalization loss */
                bb1   5,r8,assemble /* no denormalization loss or inexactness */
                extu  r6,r10,2<modelo>   /* extract rounding mode */
                bb1.n modehi,r10,signext /* use sign bit instead of LSB */
                mak   r6,r6,2<4>    /* shift over rounding mode */
                extu  r7,r11,1<0>   /* extract LSB */
                br.n  grs           /* skip sign extraction */
                mak   r7,r7,1<3>    /* shift over LSB */
signext:        extu  r7,r10,1<31>  /* extract sign bit */
                mak   r7,r7,1<3>    /* shift sign bit over */
grs:            or    r6,r6,r7
                or    r6,r6,r9      /* or in guard, round, and sticky */
                or.u  r1,r0,hi16(roundtable) /* form address of branch table */
                or    r1,r1,lo16(roundtable)
                lda   r6,r1[r6]     /* scale offset into branch table */
                jmp.n r6            /* jump to branch table */
                set   r9,r9,1<3>    /* set inexact flag in r9 */

roundtable:     br    noaddone
r000001:        br    noaddone
r000010:        br    noaddone
r000011:        br    noaddone
r000100:        br    noaddone
r000101:        br    addone
r000110:        br    addone
r000111:        br    addone
r001000:        br    noaddone
r001001:        br    noaddone
r001010:        br    noaddone
r001011:        br    noaddone
r001100:        br    addone
r001101:        br    addone
r001110:        br    addone
r001111:        br    addone
r010000:        br    noaddone
r010001:        br    noaddone
r010010:        br    noaddone
r010011:        br    noaddone
r010100:        br    noaddone
r010101:        br    noaddone
r010110:        br    noaddone
r010111:        br    noaddone
r011000:        br    noaddone
r011001:        br    noaddone
r011010:        br    noaddone
r011011:        br    noaddone
r011100:        br    noaddone
r011101:        br    noaddone
r011110:        br    noaddone
r011111:        br    noaddone
r100000:        br    noaddone
r100001:        br    noaddone
r100010:        br    noaddone
r100011:        br    noaddone
r100100:        br    noaddone
r100101:        br    noaddone
r100110:        br    noaddone
r100111:        br    noaddone
r101000:        br    noaddone
r101001:        br    addone
r101010:        br    addone
r101011:        br    addone
r101100:        br    addone
r101101:        br    addone
r101110:        br    addone
r101111:        br    addone
r110000:        br    noaddone
r110001:        br    addone
r110010:        br    addone
r110011:        br    addone
r110100:        br    addone
r110101:        br    addone
r110110:        br    addone
r110111:        br    addone
r111000:        br    noaddone
r111001:        br    noaddone
r111010:        br    noaddone
r111011:        br    noaddone
r111100:        br    noaddone
r111101:        br    noaddone
r111110:        br    noaddone
r111111:        br    noaddone
d1339 6
a1344 5
addone:         or    r6,r0,1      /* load a 1 into r6 so that add.co can be used */
                add.co r11,r11,r6  /* add a one to the lower word of result */
                bb0.n destsize,r12,noaddone /* single result,forget carry */
                set   r9,r9,1<4>   /* indicate that a 1 has been added */
                add.ci r5,r5,r0    /* propagate carry into high word */
d1349 1
a1349 1
noaddone:       
d1351 3
a1353 3
		bb1.n efinx,r12,modformdef /* branch to modify form for user  */
                                             /* handler */
                or    r2,r2,5      /* set inexact and underflow flags */
d1357 2
a1358 2
/* Assemble the result of the denormalization routine for writeback to the  */
/* destination register.  The exponent of a denormalized number is zero, */
d1361 14
a1374 10
assemble:       bb1   destsize,r12,doubassem /* assemble double result */
                bb0   sign,r10,exassems /* exit assemble if sign is zero */
                set   r11,r11,1<sign>  /* make result negative */
exassems:       br    Ureturn       /* return from subroutine */

doubassem:      bb0.n sign,r10,signclr /* do not set sign in r10 */
		or    r10,r5,r0    /* load high word from r5 into r10 */
                set   r10,r10,1<sign> /* high word with sign loaded */
signclr:        br    Ureturn       /* return from subroutine */
                
d1377 1
a1377 1
/* the inexact user handler.  This input format is the same format that  */
d1381 19
a1399 15
modformdef:     clr   r12,r12,12<20> /* clear result exponent,IMPCR complete */
                clr   r10,r10,4<25>  /* clear old guard,round,sticky,and addone */
                mak   r5,r9,3<26>    /* make grs field */
                bb0.n 4,r9,newaddone /* do not set new addone in MANTHI */
                or    r10,r5,r10     /* or in new grs field */
                set   r10,r10,1<25>  /* set new addone */
newaddone:      bb1.n destsize,r12,moddefd /* branch to handle double precision */
                clr   r10,r10,21<0>  /* clear upper bits of old mantissa */
moddefs:        extu  r5,r11,20<3>   /* extract upper bits */
                or    r10,r5,r10     /* MANTHI complete */
                bsr.n _handler       /* execute user handler for inexact */
                rot   r11,r11,0<3>   /* MANTLO complete */
                br    Ureturn         /* return from subroutine */
moddefd:        bsr.n _handler       /* execute user handler for inexact */
                or    r10,r5,r10     /* MANTHI complete,r5 should be set to OR */
a1401 1

d1404 3
a1406 13
Ureturn:         ld    r1,r31,0 /* load return address */
                jmp   r1           /* return from subroutine */
  
                data

/* function _FPoverflow --       */
/* The documentation for this release gives an overall description of this code. */
data
align 4
msg2: string "here at line %d, r1 is %x\n\0"
text

#line 23
d1408 3
d1412 1
a1412 1
/* FPSR is set, and the inexact user handler bit is checked.  If it is set, */
d1415 3
a1417 5
              text				
	      align 8
              global _FPoverflow
_FPoverflow:  
	      st     r1,r31,0 /* save return address */
d1419 7
a1425 7
              set    r2,r2,1<overflow> /* set overflow bit in r2 which holds FPSR */
              bb1    efovf,r12,hand  /* go to user handler if bit set for overflow */
              set    r2,r2,1<inexact> /* set inexact bit in r2 since overflow bit */
                                /* in FPCR is not set */
              bb0  efinx,r12,nohandler/* if userhandler for inexact not set,then */
                                        /* round result */
              br     callhandler /* branch to user handler for inexact */
d1429 13
a1441 9
 
hand:         bb1    10,r12,doubleprec /* double precision result */
singleprec:   or.u   r5,r0,0x0c00 /* load exponent adjust */
              br.n   callhandler  /* prepare to call user handler */
              subu   r12,r12,r5 /* adjust single precision exponent */
doubleprec:   or.u   r5,r0,0x6000 /* load exponent adjust */
              subu   r12,r12,r5 /* adjust double precision exponent */
callhandler:  bsr    _handler   /* branch to common handler routine */
              br     return     /* return from overflow subroutine */
d1446 7
a1452 5
nohandler:    bb1    modehi,r10,signed /* mode is either round toward pos. or neg. */
              bb0    modelo,r10,OFnearest /* rounding mode is round nearest */
              br     OFzero            /* rounding mode is round zero */
signed:       bb0    modelo,r10,OFnegative /* rounding mode is round negative */
              br     positive        /* rounding mode is round positive */
d1459 8
a1466 8
OFnearest:      
		bb1.n  destsize,r12,neardouble /* branch to neardouble of  */
                                             /* double result */
              mask.u r5,r10,0x8000  /* mask off sign bit from MANTHI */
              or.u   r11,r0,hi16(0x7f800000)  /* load single infinity constant */
              or     r11,r11,lo16(0x7f800000)  
              br.n   return     /* return with result */
              or     r11,r5,r11 /* adjust sign */
d1468 5
a1472 5
	     or     r11,r0,r0           /* load lower word of infinity */
              or.u   r10,r0,hi16(0x7ff00000)  /* load upper word of infinity */
              or     r10,r10,lo16(0x7ff00000)  
              br.n   return     /* return with result */
              or     r10,r5,r10 /* adjust sign */
d1480 14
a1493 14
OFzero:         
		bb1.n  destsize,r12,zerodouble /* branch to zerodouble of  */
                                             /* double result */
              mask.u r5,r10,0x8000  /* mask off sign bit from MANTHI */
              or.u   r11,r0,hi16(0x7f7fffff)  /* load single finite number constant */
              or     r11,r11,lo16(0x7f7fffff)  
              br.n   return     /* return with result */
              or     r11,r5,r11 /* adjust sign */
zerodouble:   
	     set    r11,r0,0<0>          /* load lower word of finite number */
              or.u   r10,r0,hi16(0x7fefffff)  /* load upper word of finite number */
              or     r10,r10,lo16(0x7fefffff)  
              br.n   return     /* return with result */
              or     r10,r5,r10 /* adjust sign */
d1496 1
a1496 1
/* In the round toward positve mode, positive values are rounded to  */
d1501 8
a1508 8
positive:     
              bb1    destsize,r12,posdouble /* branch to section for double result */
possingle:    
  	     bb1    sign,r10,possingleneg /* branch to section for negatives */
possinglepos: 
		or.u   r11,r0,hi16(0x7f800000)  /* load single infinity constant */
              br.n   return     /* return with result */
              or     r11,r11,lo16(0x7f800000)  
d1510 17
a1526 17
	     or.u   r11,r0,hi16(0x7f7fffff)  /* load single finite number constant */
              or     r11,r11,lo16(0x7f7fffff)  
              br.n   return     /* return with result */
              set    r11,r11,1<sign> /* set sign for negative */
posdouble:    
	     bb1    sign,r10,posdoubleneg /* branch to negative double results */
posdoublepos: 
		or     r11,r0,r0  /* load lower word of double infinity */
              or.u   r10,r0,hi16(0x7ff00000)  /* load upper word of infinity */
              br.n   return     /* return with result */
              or     r10,r10,lo16(0x7ff00000)  
posdoubleneg: 
	      set    r11,r0,0<0>          /* load lower word of finite number */
              or.u   r10,r0,hi16(0x7fefffff)  /* load upper word of finite number */
              or     r10,r10,lo16(0x7fefffff)  
              br.n   return     /* return with result */
              set    r10,r10,1<sign> /* set sign for negative */
d1529 1
a1529 1
/* In the round toward negative mode, positive values are rounded to the largest  */
d1533 25
a1557 29
OFnegative: 
	      bb1    destsize,r12,negdouble /* branch to section for double result */
negsingle:    
	      bb1    sign,r10,negsingleneg /* branch to section for negatives */
negsinglepos: 
	      or.u   r11,r0,hi16(0x7f7fffff)  /* load single finite number constant */
              br.n   return     /* return with result */
              or     r11,r11,lo16(0x7f7fffff)  
negsingleneg: 
	      or.u   r11,r0,hi16(0x7f800000)  /* load single infinity constant */
              or     r11,r11,lo16(0x7f800000)  
              br.n   return     /* return with result */
              set    r11,r11,1<sign> /* set sign for negative */
negdouble:    
	   bb1    sign,r10,negdoubleneg /* branch to negative double results */
negdoublepos: 
	      set    r11,r0,0<0>          /* load lower word of finite number */
              or.u   r10,r0,hi16(0x7fefffff)  /* load upper word of finite number */
              br.n   return     /* return with result */
              or     r10,r10,lo16(0x7fefffff)  
negdoubleneg: 
	      or     r11,r0,r0  /* load lower word of double infinity */
              or.u   r10,r0,hi16(0x7ff00000)  /* load upper word of infinity */
              or     r10,r10,lo16(0x7ff00000)  
              set    r10,r10,1<sign> /* set sign for negative */

return:       
	      ld     r1,r31,0 /* ld return address */
              jmp    r1         /* return from subroutine */
d1559 5
a1563 1
              data
d1567 1
a1567 1
/* bit of the FPSR.  If the invalid operation user handler flag is set and */
d1571 1
a1571 1
/* a quiet S1 to the result.  A signalling NaN must be made quiet before */
d1574 6
a1579 23
             text
GLOBAL(NaN)
	        bb0.n	s1nan,r12,S2sigcheck /* S1 is not a NaN */
		st	r1,r31,0 /* save return address */
		bb1	sigbit,r5,S2sigcheck /* S1 is not a signaling NaN */
		set	r2,r2,1<oper>  /* set invalid operation bit in FPSR */
#ifdef JEFF_DEBUGxxxxxxx
		/*
		 * Generate a signal to the offending process.
		 * This uses hardcoded constants from mach/exception.h
		 * and mach/machine/exception.h.
		 */
		ldcr	 r2, cr17	/* first arg: current_thread() */
		or	 r3,  r0, 3	/* second arg: EXC_ARITHMETIC  */
		or	 r4,  r0, 3	/* third arg: EXC_M88K_FLOAT_P */
		or	 r5,  r0, r0
		subu	r31, r31, 48
		bsr.n    _thread_doexception
		st	 r1, r31, 44
		ld	 r1, r31, 44
		br.n	FPnan_return
		addu	r31, r31, 48
#endif
d1581 4
a1584 4
		bb0	oper,r3,S1nohandler /* branch if no user handler */
		bsr	_handler       /* branch to handler */
		br	FPnan_return
ASGLOBAL(S1nohandler)
d1586 9
a1594 9
	        br.n	S1write        /* FPSR bit already set, S1 is made quiet, */
                                   /* and since we always write S1 if it is a */
                                   /* NaN, write S1 and skip rest of routine */
		set	r5,r5,1<sigbit> /* make S1 a quiet NaN */

ASGLOBAL(S2sigcheck)
		bb0	s2nan,r12,S1write /* S2 is not a NaN */
		bb1	sigbit,r7,S1write /* S2 is not a signaling NaN */
		set	r2,r2,1<oper>  /* set invalid operation bit in FPSR */
d1596 3
a1598 3
		bb0	oper,r3,S2nohandler	/* branch if no user handler */
		bsr	_handler       /* branch to handler */
		br	FPnan_return
d1601 2
a1602 2
ASGLOBAL(S2nohandler)
		set    r7,r7,1<sigbit> /* make S2 a quiet NaN */
d1608 11
a1618 11
ASGLOBAL(S1write)
	     bb0    s1nan,r12,S2write /* do not write S1 if it is not a NaN */
             extu   r10,r9,5<11>      /* extract opcode */
             cmp    r11,r10,FCMPop    /* compare to FCMP */
             bb1    ne,r11,S1noFCMP   /* operation is not FCMP */
             set    r6,r0,1<nc>       /* set the not comparable bit */
             br.n   FPnan_return            /* return from subroutine */
             set    r6,r6,1<ne>       /* set the not equal bit */
ASGLOBAL(S1noFCMP)
	     bb1.n  dsize,r9,wrdoubS1 /* double destination */
             set    r5,r5,11<20>      /* set all exponent bits to 1 */
d1620 24
a1643 35
ASGLOBAL(wrsingS1)
	     mak    r10,r5,28<3>      /* wipe out extra exponent bits */
             extu   r11,r6,3<29>      /* get lower three bits of mantissa */
             or     r10,r10,r11       /* combine all of result except sign */
             clr    r6,r5,31<0>       /* clear all but sign */
             br.n   FPnan_return            /* return from function */
             or     r6,r6,r10         /* form result */

ASGLOBAL(wrdoubS1)
/* ;;;;;	     bb1    s1size,r9,wrdoubS1d ;write double source to double dest. */
/* took out the above instruction -- don't see why it's there.... jfriedl */
ASGLOBAL(wrdoubS1s)
	     set    r6,r6,29<0>       /* set extra bits of lower word */
ASGLOBAL(wrdoubS1d)
	     br     FPnan_return      /* no modification necessary for writing */
                                      /* double to double, so return from function */

ASGLOBAL(S2write)
	     extu   r10,r9,5<11>      /* extract opcode */
             cmp    r11,r10,FCMPop    /* compare to FCMP */
             bb1.n  ne,r11,S2noFCMP   /* operation is not FCMP */
             set    r7,r7,11<20>      /* set all exponent bits to 1 */
             set    r6,r0,1<nc>       /* set the not comparable bit */
             br.n   FPnan_return            /* return from subroutine */
             set    r6,r6,1<ne>       /* set the not equal bit */
ASGLOBAL(S2noFCMP)
	     bb1.n  dsize,r9,wrdoubS2 /* double destination */
	/*
	 * In the original, the ".n" above and the "set r5..." below
	 * were omitted here.  Since they're in the S1 stuff above,
	 * and since this isn't working right now (r5 isn't being set
	 * to it's part of the nan), I'll try this...
	 *	jfriedl Dec 1, 1989
	 */
             set    r5,r5,11<20>      /* set all exponent bits to 1 */
d1645 7
a1651 17
ASGLOBAL(wrsingS2)
	     mak    r10,r7,28<3>      /* wipe out extra exponent bits */
             extu   r11,r8,3<29>      /* get lower three bits of mantissa */
             or     r10,r10,r11       /* combine all of result except sign */
             clr    r6,r7,31<0>       /* clear all but sign */
             br.n   FPnan_return            /* return from function */
             or     r6,r6,r10         /* form result */

ASGLOBAL(wrdoubS2)
	
/* ;;;	     bb1  s2size,r9,FPnan_return  ;write double source to double dest. */
	/*
	 * I took out the above branch because I just don't see how it
	 * makes sense. jfriedl Dec 1, '89
	 */
ASGLOBAL(wrdoubS2s)
	     set    r6,r8,29<0>       /* set extra bits of lower word */
d1653 2
d1658 5
a1662 11
ASGLOBAL(FPnan_return)
	     /* no modification necessary for writing */
                                      /* double to double, so return from function */
             ld     r1,r31,	 0   /* retrieve return address */
             jmp    r1                /* return from function */

             data

/* function _infinity --       */
/* See the documentation of this release for an overall description of this */
/* code. */
d1664 5
d1673 23
a1695 23
             text
	     align 8
             global _infinity
_infinity:   extu   r10,r9,5<11>   /* extract opcode */
             cmp    r11,r10,FADDop /* compare to FADD */
             bb1.n  eq,r11,FADD    /* operation is FADD */
             st     r1,r31,0       /* save return address */
             cmp    r11,r10,FSUBop /* compare to FSUB */
             bb1    eq,r11,FSUB    /* operation is FSUB */
             cmp    r11,r10,FCMPop /* compare to FCMP */
             bb1    eq,r11,FCMP    /* operation is FCMP */
             cmp    r11,r10,FMULop /* compare to FMUL */
             bb1    eq,r11,FMUL    /* operation is FMUL */
             cmp    r11,r10,FDIVop /* compare to FDIV */
             bb1    eq,r11,FDIV    /* operation is FDIV */
/*              cmp    r11,r10,FSQRTop;compare to FSQRT */
/*              bb1    eq,r11,FSQRT   ;operation is FSQRT */
             cmp    r11,r10,INTop  /* compare to INT */
             bb1    eq,r11,FP_inf_overflw /* operation is INT */
             cmp    r11,r10,NINTop /* compare to NINT */
             bb1    eq,r11,FP_inf_overflw /* operation is NINT */
             cmp    r11,r10,TRNCop /* compare to TRNC */
             bb1    eq,r11,FP_inf_overflw /* operation is TRNC */
d1701 18
a1718 13
FADD:        bb0    s1inf,r12,addS2write /* branch if S1 not infinity */
             bb0    s2inf,r12,addS1write /* S2 is not inf., so branch to write S1 */
             bb1    sign,r5,addS1neg   /* handle case of S1 negative */
addS1pos:    bb1    sign,r7,excpt      /* adding infinities of different signs */
                                       /* causes an exception */
             br     poswrinf           /* branch to write positive infinity */
addS1neg:    bb0    sign,r7,excpt      /* adding infinities of different signs */
                                       /* causes an exception */
             br     negwrinf           /* branch to write negative infinity */
addS1write:  bb0    sign,r5,poswrinf   /* branch to write positive infinity */
             br     negwrinf           /* branch to write negative infinity */
addS2write:  bb0    sign,r7,poswrinf   /* branch to write positive infinity */
             br     negwrinf           /* branch to write negative infinity */
d1724 18
a1741 13
FSUB:        bb0    s1inf,r12,subS2write /* branch if S1 not infinity */
             bb0    s2inf,r12,subS1write /* S2 is not inf., so branch to write S1 */
             bb1    sign,r5,subS1neg   /* handle case of S1 negative */
subS1pos:    bb0    sign,r7,excpt      /* subtracting infinities of the same sign */
                                       /* causes an exception */
             br     poswrinf           /* branch to write positive infinity */
subS1neg:    bb1    sign,r7,excpt      /* subtracting infinities of the same sign */
                                       /* causes an exception */
             br     negwrinf           /* branch to write negative infinity */
subS1write:  bb0    sign,r5,poswrinf   /* branch to write positive infinity */
             br     negwrinf           /* branch to write negative infinity */
subS2write:  bb1    sign,r7,poswrinf   /* branch to write positive infinity */
             br     negwrinf           /* branch to write negative infinity */
d1747 109
a1855 82
FCMP:        bb0.n  s1inf,r12,FCMPS1f  /* branch for finite S1 */
             set    r4,r0,1<cp>        /* since neither S1 or S2 is a NaN, set cp */
FCMPS1i:     bb1    sign,r5,FCMPS1ni   /* branch to negative S1i */
FCMPS1pi:    bb0    s2inf,r12,FCMPS1piS2f /* branch to finite S2 with S1pi */
FCMPS1piS2i: bb1    sign,r7,FCMPS1piS2ni /* branch to negative S2i with S1pi */
FCMPS1piS2pi: set   r4,r4,1<eq>        /* set eq bit  */
             set    r4,r4,1<le>        /* set le bit */
             set    r4,r4,1<ge>        /* set ge bit */
             set    r4,r4,1<ib>        /* set ib bit */
             br.n   move               /* return from subroutine */
             set    r4,r4,1<ob>        /* set ob bit */
FCMPS1piS2ni: set   r4,r4,1<ne>        /* set ne bit */
             set    r4,r4,1<gt>        /* set gt bit */
             br.n   move               /* return from subroutine */
             set    r4,r4,1<ge>        /* set ge bit */
FCMPS1piS2f: set    r4,r4,1<ne>        /* set ne bit */
             set    r4,r4,1<gt>        /* set gt bit */
             bsr.n  _zero              /* see if any of the operands are zero */
             set    r4,r4,1<ge>        /* set ge bit */
             bb0    s2zero,r12,FCMPS1piS2nz /* check for negative if s2 not zero */
	     set    r4,r4,1<ou>        /* set ou bit */
	     br.n   move
             set    r4,r4,1<ob>        /* set ob bit */
FCMPS1piS2nz: bb1    sign,r7,move     /* return from subroutine if s2 is neg. */
FCMPS1piS2pf: set   r4,r4,1<ou>        /* set ou bit */
             br.n   move             /* return from subroutine */
             set    r4,r4,1<ob>        /* set ob bit */
FCMPS1ni:    bb0    s2inf,r12,FCMPS1niS2f /* branch to finite S2 with S1ni */
FCMPS1niS2i: bb1    sign,r7,FCMPS1niS2ni /* branch to negative S2i with S1ni */
FCMPS1niS2pi: set   r4,r4,1<ne>        /* set eq bit  */
             set    r4,r4,1<le>        /* set le bit */
             set    r4,r4,1<lt>        /* set lt bit */
             set    r4,r4,1<ou>        /* set ou bit */
             br.n   move             /* return from subroutine */
             set    r4,r4,1<ob>        /* set ob bit */
FCMPS1niS2ni: set   r4,r4,1<eq>        /* set eq bit  */
             set    r4,r4,1<le>        /* set le bit */
             br.n   move             /* return from subroutine */
             set    r4,r4,1<ge>        /* set ge bit */
FCMPS1niS2f: set    r4,r4,1<ne>        /* set eq bit  */
             set    r4,r4,1<le>        /* set le bit */
             bsr.n  _zero              /* see if any of the operands are zero */
             set    r4,r4,1<lt>        /* set lt bit */
             bb0    s2zero,r12,FCMPS1niS2nz /* branch if s2 is not zero */
	     set    r4,r4,1<ou>        /* set ou bit */
	     br.n   move
             set    r4,r4,1<ob>        /* set ob bit */
FCMPS1niS2nz: bb1    sign,r7,move     /* return from subroutine if s2 is neg. */
             set    r4,r4,1<ou>        /* set ou bit */
             br.n   move             /* return from subroutine */
             set    r4,r4,1<ob>        /* set ob bit */
FCMPS1f:     bb1    sign,r5,FCMPS1nf   /* branch to negative S1f */
FCMPS1pf:    bb1.n  sign,r7,FCMPS1pfS2ni /* branch to negative S2i with S1pf */
             set   r4,r4,1<ne>        /* set ne bit    */
FCMPS1pfS2pi: set   r4,r4,1<le>        /* set le bit */
             set    r4,r4,1<lt>        /* set lt bit */
	     bsr.n  _zero
             set    r4,r4,1<ib>        /* set ib bit */
             bb0    s1zero,r12,FCMPS1pfS2pinozero
FCMPS1pfS2pizero: br.n   move
             set    r4,r4,1<ob>        /* set ob bit */
FCMPS1pfS2pinozero: br.n move
             set    r4,r4,1<in>        /* set in bit */
FCMPS1pfS2ni: set    r4,r4,1<gt>        /* set gt bit */
             br.n   move             /* return from subroutine */
             set    r4,r4,1<ge>        /* set ge bit */
FCMPS1nf:    bb1.n    sign,r7,FCMPS1nfS2ni /* branch to negative S2i with S1nf */
             set    r4,r4,1<ne>        /* set ne bit */
             set    r4,r4,1<le>        /* set gt bit */
             set    r4,r4,1<lt>        /* set ge bit */
             bsr.n  _zero              /* see which of the operands are zero */
             set    r4,r4,1<ob>        /* set ob bit */
             bb0    s1zero,r12,FCMPS1nfS2pinozero /* no ls and lo */
FCMPS1nfS2pizero: br.n move
             set    r4,r4,1<ib>        /* set ib bit */
FCMPS1nfS2pinozero: br.n move
             set    r4,r4,1<ou>        /* set ou bit */
FCMPS1nfS2ni: set    r4,r4,1<gt>        /* set gt bit */
             set    r4,r4,1<ge>        /* set ge bit */

move:	     br.n   inf_return		/* return from subroutine */
             or	    r6,r0,r4            /* transfer answer to r6 */
d1861 10
a1870 8
FMUL:        bsr    _zero              /* see if any of the operands are zero */
             bb1    s1zero,r12,excpt   /* infinity X 0 causes an exception */
             bb1    s2zero,r12,excpt   /* infinity X 0 causes an exception */
             bb1    sign,r5,FMULS1neg  /* handle negative cases of S1 */
             bb0    sign,r7,poswrinf   /* + X + = + */
             br     negwrinf           /* + X - = - */
FMULS1neg:   bb1    sign,r7,poswrinf   /* - X - = + */
             br     negwrinf           /* - X + = - */
d1873 2
a1874 2
/* Dividing infinity by infinity causes an exception, but dividing  */
/* infinity by a finite yields a correctly signed infinity, and  */
d1877 29
a1905 17
FDIV:        bb1    s1inf,r12,FDIVS1inf /* handle case of S1 being infinity */
             bb1    sign,r5,FDIVS1nf    /* handle cases of S1 being neg. non-inf. */
             bb1    sign,r7,FDIVS1pfS2mi /* handle case of negative S2 */
FDIVS1pfS2pi: br    poswrzero           /* +f / +inf = +0 */
FDIVS1pfS2mi: br    negwrzero           /* +f / -inf = -0 */
FDIVS1nf:    bb1    sign,r7,FDIVS1nfS2mi /* handle case of negative S2 */
FDIVS1nfS2pi: br    negwrzero           /* -f / +inf = -0 */
FDIVS1nfS2mi: br    poswrzero           /* -f / -inf = +0 */
FDIVS1inf:   bb1    s2inf,r12,excpt     /* inf / inf = exception */
             bb1    sign,r5,FDIVS1mi    /* handle cases of S1 being neg. inf. */
             bb1    sign,r7,FDIVS1piS2nf /* handle case of negative S2 */
FDIVS1piS2pf: br    poswrinf            /* +inf / +f = +inf */
FDIVS1piS2nf: br    negwrinf            /* +inf / -f = -inf */
FDIVS1mi:    bb1    sign,r7,FDIVS1miS2nf /* handle case of negative S2 */
FDIVS1miS2pf: br    negwrinf            /* -inf / +f = -inf */
FDIVS1miS2nf: br    poswrinf            /* -inf / -f = +inf */
              
d1910 5
a1914 2
/* FSQRT:       bb0    sign,r7,poswrinf    ;write sqrt(inf) = inf */
/*              br     excpt               ;write sqrt(-inf) = NaN */
d1916 2
a1917 2
excpt:       
             set    r2,r2,1<oper>      /* set invalid operation bit of FPSR */
d1919 4
a1922 4
	     bb0    oper,r3,nohandler  /* branch if no user handler */
             bsr    _handler           /* branch to interface with user handler */
             br     inf_return             /* return from function */
nohandler:   
d1924 5
a1928 5
	     set    r5,r0,0<0>        /* write NaN into r5 */
             br.n   inf_return             /* return from subroutine */
             set    r6,r0,0<0>        /* write NaN into r6, writing NaN''s into */
                                       /* both of these registers is quicker than */
                                       /* checking for single or double precision */
d1933 8
a1940 6
poswrinf:    bb1    dsize,r9,poswrinfd /* branch to write double precision inf. */
             br.n   inf_return             /* return from subroutine */
             or.u   r6,r0,0x7f80       /* load r6 with single precision pos inf.   */
poswrinfd:   or.u   r5,r0,0x7ff0       /* load double precision pos inf. */
             br.n   inf_return             /* return from subroutine */
             or     r6,r0,r0
d1945 8
a1952 6
negwrinf:    bb1    dsize,r9,negwrinfd /* branch to write double precision inf. */
             br.n   inf_return             /* return from subroutine */
             or.u   r6,r0,0xff80       /* load r6 with single precision pos inf.   */
negwrinfd:   or.u   r5,r0,0xfff0       /* load double precision pos inf. */
             br.n   inf_return             /* return from subroutine */
             or     r6,r0,r0
d1957 4
a1960 3
poswrzero:   or     r5,r0,r0           /* write to both high word and low word now */
             br.n   inf_return             /* it does not matter that both are written */
             or     r6,r0,r0     
d1965 12
a1976 10
negwrzero:   or     r6,r0,r0           /* clear low word */
             bb1    dsize,r9,negwrzerod /* branch to write double precision zero */
             br.n   inf_return             /* return from subroutine */
             set    r6,r6,1<31>        /* set sign bit */
negwrzerod:  or     r5,r0,r0           /* clear high word */
             br.n   inf_return             /* return from subroutine */
             set    r5,r5,1<31>        /* set sign bit */
             
FP_inf_overflw:     
             set    r2,r2,1<oper>       /* set invalid operand bit */
d1978 3
a1980 3
	     bb0    oper,r3,nohandlero  /* do not go to user handler routine */
             bsr    _handler            /* go to user handler routine */
             br     inf_return              /* return from subroutine */
d1983 2
a1984 4
nohandlero:  bb0.n  sign,r7,inf_return      /* if positive then return from subroutine */
             
             set    r6,r6,31<0>         /* set result to largest positive integer */
             or.c   r6,r0,r6            /* negate r6,giving largest negative int. */
d1986 2
a1987 2
inf_return:      ld     r1,r31,0          /* load return address */
             jmp    r1                 /* return from subroutine */
d1989 5
a1993 1
             data
a2002 4
/* function _denorm --       */
/* See the documentation for this release for an overall description of this */
/* code. */
       
d2004 5
a2008 1
/* Check to see if either S1 or S2 is a denormalized number.  First  */
d2010 1
a2010 1
/* the mantissa is not zero.  If the number is denormalized, then set the */
d2013 35
a2047 29
             text
	     align 8
             global _denorm
_denorm:     st     r1,r31,0  /* save return address */
dnmcheckS1:  extu   r10,r5,11<20>  /* extract exponent */
             bcnd   ne0,r10,dnmsetS2 /* S1 is not a denorm, so S2 must be */
             bb1.n  9,r9,dnmcheckS1d /* S1 is double precision */
             mak    r10,r5,20<3>   /* mak field with only mantissa bits */
                                   /* into final result */
dnmcheckS1s: extu   r11,r6,3<29>   /* get three low bits of mantissa */
             or     r10,r10,r11    /* assemble all of the mantissa bits */
             bcnd   eq0,r10,dnmsetS2 /* S1 is not a denorm, so S2 must be */
             br     dnmsetS1       /* S1 is a denorm */

dnmcheckS1d: or     r10,r6,r10     /* or all of mantissa bits */
             bcnd   eq0,r10,dnmsetS2 /* S1 is not a denorm, so S2 must be */
dnmsetS1:    set    r12,r12,1<1> /* S1 is a denorm */

dnmcheckS2:  extu   r10,r7,11<20>  /* extract exponent */
             bcnd   ne0,r10,S1form /* S2 is not a denorm */
             bb1.n  7,r9,dnmcheckS2d /* S2 is double precision */
             mak    r10,r7,20<3>   /* mak field with only mantissa bits */
dnmcheckS2s: extu   r11,r8,3<29>   /* get three low bits of mantissa */
             or     r10,r10,r11    /* assemble all of the mantissa bits */
             bcnd   eq0,r10,S1form /* S2 is not a denorm */
             br     dnmsetS2       /* S1 is a denorm */
dnmcheckS2d: or     r10,r8,r10     /* or all or mantissa bits */
             bcnd   eq0,r10,S1form /* S2 is not a denorm */
dnmsetS2:    set    r12,r12,1<0> /* S2 is a denorm */
d2052 1
a2052 1
/* back to single precision.   */
d2054 21
a2074 19
S1form:      bb1    9,r9,S2form /* S1 is double precision, so do not */
                                     /* modify S1 into single format */
             mak    r11,r5,28<3>   /*  over final exponent and mantissa */
                                   /* eliminating extra 3 bits of exponent */
             extu   r6,r6,3<29>    /* get low 3 bits of mantissa */
             or     r11,r6,r11     /* form complete mantissa and exponent */
             extu   r10,r5,1<31> /* get the 31 bit */
             mak    r10,r10,1<31>  /* place 31 bit 10 correct position */
             or     r6,r10,r11     /* or 31, exponent, and all of mantissa */

S2form:      bb1    7,r9,checkop /* S2 is double precision, so do not */
                                      /* modify S2 into single format */
             mak    r11,r7,28<3>   /*  over final exponent and mantissa */
                                   /* eliminating extra 3 bits of exponent */
             extu   r8,r8,3<29>    /* get low 3 bits of mantissa */
             or     r11,r8,r11     /* form complete mantissa and exponent */
             extu   r10,r7,1<31> /* get the 31 bit */
             mak    r10,r10,1<31>  /* place 31 bit 10 correct position */
             or     r8,r10,r11     /* or 31, exponent, and all of mantissa */
d2080 22
a2101 19
checkop:     extu   r10,r9,5<11>   /* extract opcode */
             cmp    r11,r10,0x05 /* compare to FADD */
             bb1    2,r11,FADD    /* operation is FADD */
             cmp    r11,r10,0x06 /* compare to FSUB */
             bb1    2,r11,FSUB    /* operation is FSUB */
             cmp    r11,r10,0x07 /* compare to FCMP */
             bb1    2,r11,FCMP    /* operation is FCMP */
             cmp    r11,r10,0x00 /* compare to FMUL */
             bb1    2,r11,FMUL    /* operation is FMUL */
             cmp    r11,r10,0x0e /* compare to FDIV */
             bb1    2,r11,FDIV    /* operation is FDIV */
/*              cmp    r11,r10,0x0f;compare to FSQRT */
/*              bb1    2,r11,FSQRT   ;operation is FSQRT */
             cmp    r11,r10,0x09  /* compare to INT */
             bb1    2,r11,INT     /* operation is INT */
             cmp    r11,r10,0x0a /* compare to NINT */
             bb1    2,r11,NINT    /* operation is NINT */
             cmp    r11,r10,0x0b /* compare to TRNC */
             bb1    2,r11,TRNC    /* operation is TRNC */
d2108 278
a2385 174
FADD:        bb0    1,r12,FADDS2dnm /* S1 is not denorm, so S2 must be */
             or     r5,r0,r0     /* set S1 to zero */
             or     r6,r0,r0
FADDS2chk:   bb0    0,r12,FADDcalc /* S2 is not a denorm */
FADDS2dnm:   or     r7,r0,r0     /* set S2 to zero */
             or     r8,r0,r0
FADDcalc:    bb1    5,r9,FADDdD   /* branch for double precision destination */
FADDsD:      bb1    9,r9,FADDsDdS1 /* branch for double precision S1 */
FADDsDsS1:   bb1    7,r9,FADDsDsS1dS2 /* branch for double precision S2 */
FADDsDsS1sS2: br.n  return      /* return from subroutine */
              fadd.sss r6,r6,r8   /* add the two sources and place result 10 S1 */
FADDsDsS1dS2: br.n  return      /* return from subroutine */
              fadd.ssd r6,r6,r7   /* add the two sources and place result 10 S1 */
FADDsDdS1:   bb1    7,r9,FADDsDdS1dS2 /* branch for double precision S2 */
FADDsDdS1sS2: br.n  return      /* return from subroutine */
              fadd.sds r6,r5,r8   /* add the two sources and place result 10 S1 */
FADDsDdS1dS2: br.n  return      /* return from subroutine */
              fadd.sdd r6,r5,r7   /* add the two sources and place result 10 S1 */
FADDdD:      bb1    9,r9,FADDdDdS1 /* branch for double precision S1 */
FADDdDsS1:   bb1    7,r9,FADDdDsS1dS2 /* branch for double precision S2 */
FADDdDsS1sS2: br.n  return      /* return from subroutine */
              fadd.dss r5,r6,r8   /* add the two sources and place result 10 S1 */
FADDdDsS1dS2: br.n  return      /* return from subroutine */
              fadd.dsd r5,r6,r7   /* add the two sources and place result 10 S1 */
FADDdDdS1:   bb1    7,r9,FADDdDdS1dS2 /* branch for double precision S2 */
FADDdDdS1sS2: br.n  return      /* return from subroutine */
              fadd.dds r5,r5,r8   /* add the two sources and place result 10 S1 */
FADDdDdS1dS2: br.n  return      /* return from subroutine */
              fadd.ddd r5,r5,r7   /* add the two sources and place result 10 S1 */

FSUB:        bb0    1,r12,FSUBS2dnm /* S1 is not denorm, so S2 must be */
             or     r5,r0,r0     /* set S1 to zero */
             or     r6,r0,r0
FSUBS2chk:   bb0    0,r12,FSUBcalc /* S2 is not a denorm */
FSUBS2dnm:   or     r7,r0,r0     /* set S2 to zero */
             or     r8,r0,r0
FSUBcalc:    bb1    5,r9,FSUBdD   /* branch for double precision destination */
FSUBsD:      bb1    9,r9,FSUBsDdS1 /* branch for double precision S1 */
FSUBsDsS1:   bb1    7,r9,FSUBsDsS1dS2 /* branch for double precision S2 */
FSUBsDsS1sS2: br.n  return      /* return from subroutine */
              fsub.sss r6,r6,r8   /* add the two sources and place result 10 S1 */
FSUBsDsS1dS2: br.n  return      /* return from subroutine */
              fsub.ssd r6,r6,r7   /* add the two sources and place result 10 S1 */
FSUBsDdS1:   bb1    7,r9,FSUBsDdS1dS2 /* branch for double precision S2 */
FSUBsDdS1sS2: br.n  return      /* return from subroutine */
              fsub.sds r6,r5,r8   /* add the two sources and place result 10 S1 */
FSUBsDdS1dS2: br.n  return      /* return from subroutine */
              fsub.sdd r6,r5,r7   /* add the two sources and place result 10 S1 */
FSUBdD:      bb1    9,r9,FSUBdDdS1 /* branch for double precision S1 */
FSUBdDsS1:   bb1    7,r9,FSUBdDsS1dS2 /* branch for double precision S2 */
FSUBdDsS1sS2: br.n  return      /* return from subroutine */
              fsub.dss r5,r6,r8   /* add the two sources and place result 10 S1 */
FSUBdDsS1dS2: br.n  return      /* return from subroutine */
              fsub.dsd r5,r6,r7   /* add the two sources and place result 10 S1 */
FSUBdDdS1:   bb1    7,r9,FSUBdDdS1dS2 /* branch for double precision S2 */
FSUBdDdS1sS2: br.n  return      /* return from subroutine */
              fsub.dds r5,r5,r8   /* add the two sources and place result 10 S1 */
FSUBdDdS1dS2: br.n  return      /* return from subroutine */
              fsub.ddd r5,r5,r7   /* add the two sources and place result 10 S1 */
        
FCMP:        bb0    1,r12,FCMPS2dnm /* S1 is not denorm, so S2 must be */
             or     r5,r0,r0     /* set S1 to zero */
             or     r6,r0,r0
FCMPS2chk:   bb0    0,r12,FCMPcalc /* S2 is not a denorm */
FCMPS2dnm:   or     r7,r0,r0     /* set S2 to zero */
             or     r8,r0,r0
FCMPcalc:    bb1    9,r9,FCMPdS1 /* branch for double precision S1 */
FCMPsS1:     bb1    7,r9,FCMPsS1dS2 /* branch for double precision S2 */
FCMPsS1sS2:  br.n  return      /* return from subroutine */
             fcmp.sss r6,r6,r8   /* add the two sources and place result 10 S1 */
FCMPsS1dS2:  br.n  return      /* return from subroutine */
             fcmp.ssd r6,r6,r7   /* add the two sources and place result 10 S1 */
FCMPdS1:     bb1    7,r9,FCMPdS1dS2 /* branch for double precision S2 */
FCMPdS1sS2:  br.n  return      /* return from subroutine */
             fcmp.sds r6,r5,r8   /* add the two sources and place result 10 S1 */
FCMPdS1dS2:  br.n  return      /* return from subroutine */
             fcmp.sdd r6,r5,r7   /* add the two sources and place result 10 S1 */

FMUL:        bb0    1,r12,FMULS2dnm /* S1 is not denorm, so S2 must be */
             or     r5,r0,r0     /* set S1 to zero */
             or     r6,r0,r0
FMULS2chk:   bb0    0,r12,FMULcalc /* S2 is not a denorm */
FMULS2dnm:   or     r7,r0,r0     /* set S2 to zero */
             or     r8,r0,r0
FMULcalc:    bb1    5,r9,FMULdD   /* branch for double precision destination */
FMULsD:      bb1    9,r9,FMULsDdS1 /* branch for double precision S1 */
FMULsDsS1:   bb1    7,r9,FMULsDsS1dS2 /* branch for double precision S2 */
FMULsDsS1sS2: br.n  return      /* return from subroutine */
              fmul.sss r6,r6,r8   /* add the two sources and place result 10 S1 */
FMULsDsS1dS2: br.n  return      /* return from subroutine */
              fmul.ssd r6,r6,r7   /* add the two sources and place result 10 S1 */
FMULsDdS1:   bb1    7,r9,FMULsDdS1dS2 /* branch for double precision S2 */
FMULsDdS1sS2: br.n  return      /* return from subroutine */
              fmul.sds r6,r5,r8   /* add the two sources and place result 10 S1 */
FMULsDdS1dS2: br.n  return      /* return from subroutine */
              fmul.sdd r6,r5,r7   /* add the two sources and place result 10 S1 */
FMULdD:      bb1    9,r9,FMULdDdS1 /* branch for double precision S1 */
FMULdDsS1:   bb1    7,r9,FMULdDsS1dS2 /* branch for double precision S2 */
FMULdDsS1sS2: br.n  return      /* return from subroutine */
              fmul.dss r5,r6,r8   /* add the two sources and place result 10 S1 */
FMULdDsS1dS2: br.n  return      /* return from subroutine */
              fmul.dsd r5,r6,r7   /* add the two sources and place result 10 S1 */
FMULdDdS1:   bb1    7,r9,FMULdDdS1dS2 /* branch for double precision S2 */
FMULdDdS1sS2: br.n  return      /* return from subroutine */
              fmul.dds r5,r5,r8   /* add the two sources and place result 10 S1 */
FMULdDdS1dS2: br.n  return      /* return from subroutine */
              fmul.ddd r5,r5,r7   /* add the two sources and place result 10 S1 */

FDIV:        bb0    1,r12,FDIVS2dnm /* S1 is not denorm, so S2 must be */
             or     r5,r0,r0     /* set S1 to zero */
             or     r6,r0,r0
FDIVS2chk:   bb0    0,r12,FDIVcalc /* S2 is not a denorm */
FDIVS2dnm:   or     r7,r0,r0     /* set S2 to zero */
             or     r8,r0,r0
FDIVcalc:    bb1    5,r9,FDIVdD   /* branch for double precision destination */
FDIVsD:      bb1    9,r9,FDIVsDdS1 /* branch for double precision S1 */
FDIVsDsS1:   bb1    7,r9,FDIVsDsS1dS2 /* branch for double precision S2 */
FDIVsDsS1sS2: fdiv.sss r6,r6,r8   /* add the two sources and place result 10 S1 */
	      br  return      /* return from subroutine */
FDIVsDsS1dS2: fdiv.ssd r6,r6,r7   /* add the two sources and place result 10 S1 */
              br    return      /* return from subroutine */
FDIVsDdS1:   bb1    7,r9,FDIVsDdS1dS2 /* branch for double precision S2 */
FDIVsDdS1sS2: fdiv.sds r6,r5,r8   /* add the two sources and place result 10 S1 */
	      br    return      /* return from subroutine */
FDIVsDdS1dS2: fdiv.sdd r6,r5,r7   /* add the two sources and place result 10 S1 */
	      br    return      /* return from subroutine */
FDIVdD:      bb1    9,r9,FDIVdDdS1 /* branch for double precision S1 */
FDIVdDsS1:   bb1    7,r9,FDIVdDsS1dS2 /* branch for double precision S2 */
FDIVdDsS1sS2: fdiv.dss r5,r6,r8   /* add the two sources and place result 10 S1 */
	      br    return      /* return from subroutine */
FDIVdDsS1dS2: fdiv.dsd r5,r6,r7   /* add the two sources and place result 10 S1 */
	      br    return      /* return from subroutine */
FDIVdDdS1:   bb1    7,r9,FDIVdDdS1dS2 /* branch for double precision S2 */
FDIVdDdS1sS2: fdiv.dds r5,r5,r8   /* add the two sources and place result 10 S1 */
	      br    return      /* return from subroutine */
FDIVdDdS1dS2: fdiv.ddd r5,r5,r7   /* add the two sources and place result 10 S1 */
	      br    return      /* return from subroutine */

/* FSQRT:       or     r7,r0,r0     ;set S2 to zero */
/*              or     r8,r0,r0 */
/* FSQRTcalc:   bb1    5,r9,FSQRTdD   ;branch for double precision destination */
/* FSQRTsD:     bb1    7,r9,FSQRTsDdS2 ;branch for double precision S2 */
/* FSQRTsDsS2:  br.n   return   ;return from subroutine */
            /* fsqrt.ss r6,r8   ;add the two sources and place result 10 S1 */
/* FSQRTsDdS2:  br.n   return   ;return from subroutine */
            /* fsqrt.sd r6,r7   ;add the two sources and place result 10 S1 */
/* FSQRTdD:     bb1    7,r9,FSQRTdDdS2 ;branch for double precision S2 */
/* FSQRTdDsS2:  br.n   return   ;return from subroutine */
            /* fsqrt.ds r5,r8   ;add the two sources and place result 10 S1 */
/* FSQRTdDdS2:  br.n   return   ;return from subroutine */
            /* fsqrt.dd r5,r7   ;add the two sources and place result 10 S1 */

INT:         or     r7,r0,r0     /* set S2 to zero */
             or     r8,r0,r0
INTcalc:     bb1    7,r9,INTdS2 /* branch for double precision S2 */
INTsS2:      br.n   return   /* return from subroutine */
             int.ss r6,r8    /* add the two sources and place result 10 S1 */
INTdS2:      br.n   return   /* return from subroutine */
             int.sd r6,r7   /* add the two sources and place result 10 S1 */

NINT:        or     r7,r0,r0     /* set S2 to zero */
             or     r8,r0,r0
NINTcalc:    bb1    7,r9,NINTdS2 /* branch for double precision S2 */
NINTsS2:     br.n   return   /* return from subroutine */
             nint.ss r6,r8    /* add the two sources and place result 10 S1 */
NINTdS2:     br.n   return   /* return from subroutine */
             nint.sd r6,r7   /* add the two sources and place result 10 S1 */

TRNC:        or     r7,r0,r0     /* set S2 to zero */
             or     r8,r0,r0
TRNCcalc:    bb1    7,r9,TRNCdS2 /* branch for double precision S2 */
TRNCsS2:     br.n   return   /* return from subroutine */
             trnc.ss r6,r8    /* add the two sources and place result 10 S1 */
TRNCdS2:     trnc.sd r6,r7   /* add the two sources and place result 10 S1 */
d2390 3
a2392 2
return:      ld     r1,r31,0    /* load return address */
             jmp    r1                 /* return from subroutine */
d2394 1
a2394 1
             data
d2400 55
a2454 50
             text
	     align 8
             global _zero
_zero:       bb0    s1inf,r12,S1noinf /* see if S1 is zero */
             bb0    s2inf,r12,S2noinf /* see if S2 is zero */
             jmp    r1                /* return from function */

/* See if S1 is zero.  Whether or not S1 is a zero, being in this routine */
/* implies that S2 is infinity, so return to subroutine infinity after  */
/* completing this code.  Set the s1zero flag in r12 if S1 is zero. */

S1noinf:     bb1    s1size,r9,S1noinfd /* work with double precision operand */
S1noinfs:    or     r10,r0,r5          /* load high word into r10 */
             clr    r10,r10,1<sign>    /* clear the sign bit */
             extu   r11,r6,3<29>       /* extract lower 3 bits of mantissa */
             or     r10,r10,r11        /* or these 3 bits with high word */
             bcnd   ne0,r10,operation  /* do not set zero flag */
             jmp.n  r1                 /* since this operand was not infinity, */
                                       /* S2 must have been, so return from */
                                       /* function */
             set    r12,r12,1<s1zero>  /* set zeroflag */
S1noinfd:    clr    r10,r5,1<sign>     /* clear the sign bit */
             or     r10,r6,r10         /* or high and low word */
             bcnd   ne0,r10,operation  /* do not set zero flag */
             jmp.n  r1                 /* since this operand was not infinity, */
                                       /* S2 must have been, so return from */
                                       /* function */
             set    r12,r12,1<s1zero>  /* set zeroflag */


/* Check S2 for zero.  If it is zero, then set the s2zero flag in r12. */

S2noinf:     bb1    s2size,r9,S2noinfd /* work with double precision operand */
S2noinfs:    or     r10,r0,r7          /* load high word into r10 */
             clr    r10,r10,1<sign>    /* clear the sign bit */
             extu   r11,r8,3<29>       /* extract lower 3 bits of mantissa */
             or     r10,r10,r11        /* or these 3 bits with high word */
             bcnd   ne0,r10,operation  /* do not set zero flag */
             jmp.n  r1                 /* since this operand was not infinity, */
                                       /* S1 must have been, so return from */
                                       /* function */
             set    r12,r12,1<s2zero>  /* set zeroflag */
S2noinfd:    clr    r10,r7,1<sign>     /* clear the sign bit */
             or     r10,r8,r10         /* or high and low word */
             bcnd   ne0,r10,operation  /* do not set zero flag */
             set    r12,r12,1<s2zero>  /* set zeroflag */
                                       /* since this operand was not infinity, */
                                       /* S1 must have been, so return from */
                                       /* function */
operation:   jmp    r1                 /* return from function */
d2457 12
a2468 12
/*  input: r3 is the excepton frame */
		or	r29, r3, r0	/*  r29 is now the E.F. */
		subu	r31, r31, 40
		st	r1,  r31, 32
		st	r29, r31, 36

		ld      r2 , r29, EF_FPSR  * 4
		ld      r3 , r29, EF_FPCR  * 4
		ld      r4 , r29, EF_FPECR * 4
		ld	r10, r29, EF_FPRH  * 4
		ld	r11, r29, EF_FPRL  * 4
		ld	r12, r29, EF_FPIT  * 4
d2470 1
a2470 1
/* Load into r1 the return address for the exception handlers.  Looking */
d2473 2
a2474 2
		or.u	r1,r0,hi16(fpui_wrapup)/* load return address of functions */
		or	r1,r1,lo16(fpui_wrapup)
d2476 6
a2481 5
		bb0  	2,r4,2f /* branch to FPunderflow if bit set */
		br	_FPunderflow
	2:	bb0	1,r4,3f /* branch to FPoverflow if bit set */
		br	_FPoverflow
	3:
d2483 2
a2484 2
		br	_handler	/* branch to handler since bit will be set */
					/* for inexact */
d2486 4
a2489 1
		/* should never get here!!!! */
d2492 3
a2494 1
	1: string "error in inprecise fp exception handler, r4 is 0x%08x"
d2496 7
a2502 8
	text
		or.u r2, r0, hi16(1b)
		or   r2, r2, lo16(1b)
		or   r3, r4, r0
		bsr _printf
		or.u r2, r0, hi16(1b)
		or   r2, r2, lo16(1b)
		bsr _panic
d2505 3
a2507 5
        tb1     0,r0,0          /* make sure all floating point operations */
        ldcr    r5, psr        /* load the PSR */
        /* have finished */
        or      r5, r5, 0x2   /* disable interrupts */
        stcr    r5, psr
d2509 1
a2509 3
Why is this done? -- it screws up things later.
        or      r5, r5, 0x8   /* set SFU 1 disable bit, disable SFU 1 */
        stcr    r5, psr
d2511 2
d2517 1
a2517 1
	/*  write back the results */
a2525 1
/* Return.. */
@


1.17
log
@Sprinkle proper use of _C_LABEL and _ASM_LABEL in the .S files (except for
the _fp.S which are too scary at the moment). This will be necessary to
move to ELF in the future.

Use local symbols whenever possible.

Attempt to use delayed branches whenever possible.

Remove stupid or straightforward comments, some hardcoded values, and a
few unused variables or routines.
@
text
@d1 1
a1 1
/* $OpenBSD: m88100_fp.S,v 1.16 2001/12/22 17:57:11 smurph Exp $	*/
d1372 1
a1372 1
/* postive infinity and negative values are loaded toward negative infinity. */
@


1.16
log
@change function names to reflect cpu type instead of board type.
@
text
@d1 1
a1 1
/* $OpenBSD: m88100_fp.S,v 1.15 2001/12/16 23:49:46 miod Exp $	*/
d120 1
a120 4
	text
	align 8
	global _m88100_Xfp_precise
_m88100_Xfp_precise:
d2225 1
a2225 4
             data

		text					
		align 8
a2226 1
_Xfp_imprecise: global _Xfp_imprecise
@


1.15
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d1 1
a1 1
/* $OpenBSD: m88100_fp.S,v 1.12 2001/11/18 01:43:33 miod Exp $	*/
d167 1
a167 1
	bsr     _C_LABEL(trap18x)           /* trap */
@


1.15.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/* $OpenBSD: m88100_fp.S,v 1.16 2001/12/22 17:57:11 smurph Exp $	*/
d167 1
a167 1
	bsr     _C_LABEL(m88100_trap)	/* trap */
@


1.14
log
@Even more one-liners to get the kernel to link.
@
text
@d1 1
a1 1
/* $OpenBSD: m88100_fp.S,v 1.13 2001/12/13 08:55:52 smurph Exp $	*/
a29 2
#ifdef M88100

d167 1
a167 1
	bsr     _C_LABEL(m88100_trap)           /* trap */
a2300 2
#endif /* M88100 */

@


1.13
log
@Support for MVME197 completed.  Fix SPL defs.
@
text
@d1 1
a1 1
/* $OpenBSD: m88100_fp.S,v 1.12 2001/11/18 01:43:33 miod Exp $	*/
d169 1
a169 1
	bsr     _C_LABEL(trap18x)           /* trap */
@


1.12
log
@Remove \n from more panic messages
@
text
@d1 1
a1 1
/* $OpenBSD: m88100_fp.S,v 1.11 2001/08/24 22:53:15 miod Exp $	*/
d30 2
d2303 2
@


1.11
log
@Adapt to the <machine/asm.h> macros (only for entry points for now, because
LABEL has disappeared), and to the trap() name changes.
@
text
@d1 1
a1 1
/* $OpenBSD: m88100_fp.S,v 1.10 2001/08/07 22:12:31 miod Exp $	*/
d2264 1
a2264 1
	1: string "error in inprecise fp exception handler, r4 is 0x%08x\n\0"
@


1.10
log
@Make config(8) choose which source files to exclude, from the kernel
configuration file options, rather than putting ugly preprocessor
statements and compile empty files.
@
text
@d1 1
a1 1
/* $OpenBSD: m88100_fp.S,v 1.9 2001/05/20 05:53:10 miod Exp $	*/
d167 1
a167 1
	bsr     _trap           /* trap */
d646 1
a646 1
LABEL(_FPresoper)
d658 1
a658 1
_LABEL(S1clear)
d680 1
a680 1
_LABEL(opercheck)
d684 1
a684 1
_LABEL(S1NaNsing)
d700 1
a700 1
_LABEL(noS1NaNs)
d704 1
a704 1
_LABEL(S1NaNdoub)
d718 1
a718 1
_LABEL(noS1NaNd)
d721 1
a721 1
_LABEL(S2NaN)
d724 1
a724 1
_LABEL(S2NaNsing)
d740 1
a740 1
_LABEL(noS2NaNs)
d749 1
a749 1
_LABEL(S2NaNdoub)
d763 1
a763 1
_LABEL(noS2NaNd)
d779 1
a779 1
_LABEL(inf)
d1494 1
a1494 1
LABEL(_NaN)
d1520 1
a1520 1
_LABEL(S1nohandler)
d1527 1
a1527 1
_LABEL(S2sigcheck)
d1537 1
a1537 1
_LABEL(S2nohandler)
d1544 1
a1544 1
_LABEL(S1write)
d1552 1
a1552 1
_LABEL(S1noFCMP)
d1556 1
a1556 1
_LABEL(wrsingS1)
d1564 1
a1564 1
_LABEL(wrdoubS1)
d1567 1
a1567 1
_LABEL(wrdoubS1s)
d1569 1
a1569 1
_LABEL(wrdoubS1d)
d1573 1
a1573 1
_LABEL(S2write)
d1581 1
a1581 1
_LABEL(S2noFCMP)
d1592 1
a1592 1
_LABEL(wrsingS2)
d1600 1
a1600 1
_LABEL(wrdoubS2)
d1607 1
a1607 1
_LABEL(wrdoubS2s)
d1613 1
a1613 1
_LABEL(FPnan_return)
@


1.9
log
@assym.s -> assym.h
@
text
@d1 1
a1 1
/* $OpenBSD: m88100_fp.S,v 1.8 2001/03/09 05:44:41 smurph Exp $	*/
a33 1
#if defined(MVME187) || defined(MVME188)
a2300 1
#endif /* defined(MVME187) || defined(MVME188) */
@


1.8
log
@kernel will compile with -Werror.  Added intr.h
@
text
@d1 1
a1 1
/* $OpenBSD: m88100_fp.S,v 1.7 2001/03/07 23:40:35 miod Exp $	*/
d30 1
a30 5
#ifndef ASSEMBLER
#define	ASSEMBLER
#endif /* ASSEMBLER */

#include "assym.s"
@


1.7
log
@Get rid of definitions of ASSEMBLER, LOCORE and such. We will get
the correct defines from the Makefile now.
@
text
@d1 1
a1 1
/* $OpenBSD: m88100_fp.S,v 1.6 1999/09/27 19:13:22 smurph Exp $	*/
d30 3
@


1.6
log
@Added to support MVME188 and MVME197
@
text
@d1 1
a1 1
/* $OpenBSD: m88100_fp.S,v 1.5 1999/02/09 06:36:29 smurph Exp $	*/
a29 4

#define LOCORE

#define ASSEMBLER
@


1.6.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/* $OpenBSD: m88100_fp.S,v 1.8 2001/03/09 05:44:41 smurph Exp $	*/
d30 4
a33 3
#ifndef ASSEMBLER
#define	ASSEMBLER
#endif /* ASSEMBLER */
@


1.6.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/* $OpenBSD: m88100_fp.S,v 1.6.4.1 2001/04/18 16:11:36 niklas Exp $	*/
d30 5
a34 1
#include "assym.h"
@


1.6.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/* $OpenBSD: m88100_fp.S,v 1.6.4.2 2001/07/04 10:20:16 niklas Exp $	*/
d34 1
d168 1
a168 1
	bsr     _C_LABEL(trap18x)           /* trap */
d647 1
a647 1
GLOBAL(FPresoper)
d659 1
a659 1
ASGLOBAL(S1clear)
d681 1
a681 1
ASGLOBAL(opercheck)
d685 1
a685 1
ASGLOBAL(S1NaNsing)
d701 1
a701 1
ASGLOBAL(noS1NaNs)
d705 1
a705 1
ASGLOBAL(S1NaNdoub)
d719 1
a719 1
ASGLOBAL(noS1NaNd)
d722 1
a722 1
ASGLOBAL(S2NaN)
d725 1
a725 1
ASGLOBAL(S2NaNsing)
d741 1
a741 1
ASGLOBAL(noS2NaNs)
d750 1
a750 1
ASGLOBAL(S2NaNdoub)
d764 1
a764 1
ASGLOBAL(noS2NaNd)
d780 1
a780 1
ASGLOBAL(inf)
d1495 1
a1495 1
GLOBAL(NaN)
d1521 1
a1521 1
ASGLOBAL(S1nohandler)
d1528 1
a1528 1
ASGLOBAL(S2sigcheck)
d1538 1
a1538 1
ASGLOBAL(S2nohandler)
d1545 1
a1545 1
ASGLOBAL(S1write)
d1553 1
a1553 1
ASGLOBAL(S1noFCMP)
d1557 1
a1557 1
ASGLOBAL(wrsingS1)
d1565 1
a1565 1
ASGLOBAL(wrdoubS1)
d1568 1
a1568 1
ASGLOBAL(wrdoubS1s)
d1570 1
a1570 1
ASGLOBAL(wrdoubS1d)
d1574 1
a1574 1
ASGLOBAL(S2write)
d1582 1
a1582 1
ASGLOBAL(S2noFCMP)
d1593 1
a1593 1
ASGLOBAL(wrsingS2)
d1601 1
a1601 1
ASGLOBAL(wrdoubS2)
d1608 1
a1608 1
ASGLOBAL(wrdoubS2s)
d1614 1
a1614 1
ASGLOBAL(FPnan_return)
d2302 1
@


1.6.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/* $OpenBSD: m88100_fp.S,v 1.6.4.3 2001/10/31 03:01:19 nate Exp $	*/
d2264 1
a2264 1
	1: string "error in inprecise fp exception handler, r4 is 0x%08x"
@


1.6.4.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/* $OpenBSD$	*/
d167 1
a167 1
	bsr     _C_LABEL(m88100_trap)	/* trap */
@


1.6.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d34 27
a61 2

/* Floating-Point Status Register bits */
a66 1

d71 2
a72 1

d79 1
d83 3
a85 1

d92 2
d95 14
d118 7
a124 2
ASENTRY(m88100_Xfp_precise)
	or	r29, r3,  r0		/* r29 is now the E.F. */
d128 3
a130 3

	ld	r2, r29, EF_FPSR * 4
	ld	r3, r29, EF_FPCR * 4
d136 10
a145 12
	ld	r9, r29, EF_FPPT * 4


	/*
	 * Load into r1 the return address for the 0 handlers. Looking at
	 * FPECR, branch to the appropriate 0 handler. However, if none of the
	 * 0 bits are enabled, then a floating point instruction was issued
	 * with the floating point unit disabled. This will cause an
	 * unimplemented opcode 0.
	 */

	or.u	r1,r0,hi16(wrapup)	/* load return address of function */
d147 11
a157 18

	bb0	6,r4, 3f		/* branch to FPunimp if bit set */
	br	FPuimp
3:
	bb0	7,r4, 4f		/* branch to FPintover if bit set */
	br	FPintover
4:
#if 0
	bb0	5,r4, 5f		/* branch to FPpriviol if bit set */
	br	FPpriviol
#endif
5:
	bb0	4,r4, 6f		/* branch to FPresoper if bit set */
	br	FPresoper
6:
	bb0	3,r4, 7f		/* branch to FPdivzero if bit set */
	br	FPdivzero
7:
d160 6
a165 5
ASLOCAL(FPuimp)
	subu	r31,r31,40		/* allocate stack */
	st	r1,r31,36		/* save return address */
	st	r3,r31,32		/* save exception frame */
	or	r2,r0,T_FPEPFLT		/* load trap type */
d167 17
a183 17
	bsr	_C_LABEL(m88100_trap)
	ld	r1,r31,36		/* recover return address */
	addu	r31,r31,40		/* deallocate stack */
	jmp	r1

	/*
	 * To write back the results to the user registers, disable exceptions
	 * and the floating point unit. Write FPSR and FPCR and load the SNIP
	 * and SFIP.
	 * r5 will contain the upper word of the result
	 * r6 will contain the lower word of the result
	 */

ASLOCAL(wrapup)
	tb1	0,r0,0		/* make sure all floating point operations */
				/* have finished */
	ldcr	r10, cr1	/* load the PSR */
d185 3
a187 1
	set	r10, r10, 1<PSR_FPU_DISABLE_BIT>
a188 3
	set	r10, r10, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r10, cr1

d192 4
a195 4

	fstcr	r2, FPSR	/* write revised value of FPSR */
	fstcr	r3, FPCR	/* write revised value of FPCR */

d197 4
a200 4
	addu	r3, r29, EF_R0 * 4
	extu	r2, r9, 5<0>		/* get 5 bits of destination register */
	bb0	5, r9, writesingle	/* branch if destination is single */

d202 2
a203 2
	st	r5, r3 [r2]		/* write high word */
	add	r2, r2, 1		/* for double, the low word is the */
d205 5
a209 3
	clr	r2, r2, 27<5>		/* perform equivalent of mod 32 */
ASLOCAL(writesingle)
	st	r6, r3 [r2]		/* write low word into memory */
d212 7
a218 4
/*
 * Check if the numerator is zero. If the numerator is zero, then handle
 * this instruction as you would a 0/0 invalid operation.
 */
d220 3
a222 3
ASLOCAL(FPdivzero)
	st	r1,r31,0		/* save return address */
	bb1	s1size,r9,1f		/* branch if numerator double */
d224 6
a229 5
	clr	r10,r5,1<sign>	/* clear sign bit */
	extu	r11,r6,3<29>	/* grab upper bits of lower word */
	or	r10,r10,r11	/* combine ones of mantissa */
	bcnd	eq0,r10,resoper	/* numerator is zero, handle reserved operand */
	br	setbit		/* set divzero bit */
d232 7
a238 9
	clr	r10,r5,1<sign>	/* clear sign bit */
	or	r10,r10,r6	/* or high and low words */
	bcnd	ne0,r10,setbit	/* set divzero bit */

/*
 * The numerator is zero, so handle the invalid operation by setting the
 * invalid operation bit and branching to the user handler if there is one
 * or writing a quiet NaN to the destination.
 */
d240 2
a241 2
ASLOCAL(resoper)
	set	r2,r2,1<oper>
d243 4
a246 4
	bb0	oper,r3,noreshand	/* branch to execute default handling */
					/* for reserved operands */
	bsr	_handler		/* branch to user handler */
	br	FP_div_return
d248 12
a259 14

noreshand:
	set	r5,r0,0<0>	/* put a NaN in high word */
	set	r6,r0,0<0>	/* put a NaN in low word */
	br	FP_div_return
				/* writing to a word which may be ignored */
				/* is just as quick as checking the precision */
				/* of the destination */

/*
 * The operation is divide by zero, so set the divide by zero bit in the
 * FPSR. If the user handler is set, then go to the user handler, else
 * go to the default mode.
 */
a261 1
	set	r2,r2,1<divzero>
d263 4
a266 3
	bb0	divzero,r3,default	/* go to default routine if no hdlr */
	bsr	_handler		/* execute handler routine */
	br	FP_div_return
a268 4
/*
 * Considering the sign of the numerator and zero, write a correctly
 * signed infinity of the proper precision into the destination.
 */
d270 2
a271 15
default:
	bb1	dsize,r9,FPzero_double	/* branch to handle double result */
FPzero_single:
	clr	r10,r5,31<0>	/* clear all of S1HI except sign bit */
	xor	r10,r7,r10	/* xor the sign bits of the operands */
	or.u	r6,r0,0x7f80	/* load single precision infinity */
	br.n	FP_div_return
	 or	r6,r6,r10	/* load correctly signed infinity */

FPzero_double:
	clr	r10,r5,31<0>	/* clear all of S1HI except sign bit */
	xor	r10,r7,r10	/* xor the sign bits of the operands */
	or.u	r5,r0,0x7ff0	/* load double precision infinity */
	or	r5,r5,r10	/* load correctly signed infinity */
	or	r6,r0,r0	/* clear lower word of double */
d273 38
a310 21
FP_div_return:
	ld	r1,r31,0	/* load return address */
	jmp	r1

/*
 * Both NINT and TRNC require a certain rounding mode, so check which
 * instruction caused the integer conversion overflow. Use a substitute
 * FPCR in r1, and modify the rounding mode if the instruction is NINT
 * or TRNC.
 */
ASLOCAL(FPintover)
	extu	r10,r9,5<11>		/* extract opcode */
	cmp	r11,r10,INTop		/* see if instruction is INT */
	st	r1,r31,0		/* save return address */
	bb1.n	eq,r11,checksize	/* instruction is INT, do not modify */
					/* rounding mode */
	 or	r1,r0,r3		/* load FPCR into r1 */
	cmp	r11,r10,NINTop		/* see if instruction is NINT */
	bb1	eq,r11,NINT		/* instruction is NINT */
TRNC:
	clr	r1,r1,2<rndlo>		/* clear rounding mode bits, */
d312 6
a317 7
	br.n	checksize		/* branch to check size */
	 set	r1,r1,1<rndlo>		/* make rounding mode round towards */
					/* zero */
NINT:
	clr	r1,r1,2<rndlo>		/* make rounding mode round to */
					/* nearest */

d319 188
a506 213

checksize:
	bb1	s2size,r9,checkdoub 	/* S2 is double, branch to see if */
					/* there is a false alarm */

/*
 * An integer has more bits than the mantissa of a single precision floating
 * point number, so to check for false alarms (i.e. valid conversion), simply
 * check the exponents. False alarms are detected for 2**30 to (2**30) - 1
 * and -2**30 to -2**31. Only seven bits need to be looked at since an
 * exception will not occur for the other half of the numbering system.
 * To speed up the processing, first check to see if the exponent is 32 or
 * greater.
 *
 * This code was originally written for the exponent in the control
 * register to have the most significant bit (8 - single, 11 - double)
 * flipped and sign extended. For precise exceptions, however, the most
 * significant bit is only sign extended. Therefore, the code was chopped
 * up so that it would work for positive values of real exponent which were
 * only sign extended.
 */

checksing:
	extu	r10,r7,7<20>	/* internal representation for single */
				/* precision is IEEE 8 bits sign extended */
				/* to 11 bits; for real exp. = 30, the */
				/* above instruction gives a result exp. */
				/* that has the MSB flipped and sign */
				/* extended like in the IMPCR */
	cmp	r11,r10,31	/* compare to 32,but exp. off by 1 */
				/* these 2 instructions to speed up valid */
				/* execution of valid cases */
	bb1	ge,r11,overflw	/* valid case, perform overflow routine */
	bb1	sign,r7,checksingn /* source operand is negative */

/*
 * If the number is positve and the exponent is greater than 30, than it is
 * overflow.
 */
checksingp:
	cmp	r10,r10,29	/* compare to 30, but exp. off by 1 */
	bb1	gt,r10,overflw	/* no false alarm, its overflow */
	br	conversionsp	/* finish single precision conversion */

/*
 * If the number is negative, and the exponent is 30, or 31 with a mantissa
 * of 0, then it is a false alarm.
 */
checksingn:
	cmp	r11,r10,30		/* compare to 31,but exp. off by 1 */
	bb1	lt,r11,conversionsn	/* exp. less than 31, so convert */
	extu	r10,r8,3<29>		/* get upper three bits of lower */
					/* mantissa */
	mak	r12,r7,20<3>		/* get upper 20 bits of mantissa */
	or	r10,r10,r12		/* form complete mantissa */
	bcnd	eq0,r10,conversionsn	/* complete conversion if mantissa */
					/* is 0 */
	br	overflw			/* no false alarm, its overflow */

/*
 * False alarms are detected for 2**30 to (2**30) - 1 and -2**30 to -2**31.
 * Only seven bits need to be looked at since an exception will not occur
 * for the other half of the numbering system.
 * To speed up the processing, first check to see if the exponent is 32 or
 * greater. Since there are more mantissa bits than integer bits, rounding
 * could cause overflow. (2**31) - 1 needs to be checked so that it does
 * not round to 2**31, and -2**31 needs to be checked in case it rounds to
 * -((2**31) + 1).
 */
checkdoub:
	extu	r10,r7,10<20>	/* internal representation for double */
				/* precision is the same IEEE 11 bits */
				/* for real exp. = 30, the */
				/* above instruction gives a result exp. */
				/* that has the MSB flipped and sign */
				/* extended like in the IMPCR */
	cmp	r11,r10,31	/* compare to 32,but exp. off by 1 */
				/* these 2 instructions to speed up valid */
				/* execution of valid cases */
	bb1	ge,r11,overflw	/* valid case, perform overflow routine */
	bb1	sign,r7,checkdoubn /* source operand is negative */

/*
 * If the exponent is not 31, then the floating point number will be rounded
 * before the conversion is done. A branch table is set up with bits 4 and 3
 * being the rounding mode, and bits 2, 1, and 0 are the guard, round, and
 * sticky bits.
 */
checkdoubp:
	cmp	r11,r10,30	/* compare to 31, but exponent off by 1 */
	bb1	eq,r11,overflw	/* no false alarm, its overflow */
	extu	r12,r8,1<22>	/* get LSB for integer with exp. = 30 */
	mak	r12,r12,1<2>	/* start to set up field for branch table */
	extu	r11,r8,1<21>	/* get guard bit */
	mak	r11,r11,1<1>	/* set up field for branch table */
	or	r12,r11,r12	/* set up field for branch table */
	extu	r11,r8,21<0>	/* get bits for sticky bit */
	bcnd	eq0,r11,nostickyp /* do not set sticky */
	set	r12,r12,1<0>	/* set sticky bit */
nostickyp:
	rot	r11,r1,0<rndlo>		/* shift rounding mode to 2 LSB''s */
	mak	r11,r11,2<3>		/* set up field, clear other bits */
	or	r12,r11,r12		/* set up field for branch table */
	lda	r12,r0[r12]		/* scale r12 */
	or.u	r12,r12,hi16(ptable)	/* load pointer into table */
	addu	r12,r12,lo16(ptable)
	jmp	r12

ptable:
	br	conversiondp
	br	conversiondp
	br	conversiondp
	br	paddone
	br	conversiondp
	br	conversiondp
	br	paddone
	br	paddone
	br	conversiondp
	br	conversiondp
	br	conversiondp
	br	conversiondp
	br	conversiondp
	br	conversiondp
	br	conversiondp
	br	conversiondp
	br	conversiondp
	br	conversiondp
	br	conversiondp
	br	conversiondp
	br	conversiondp
	br	conversiondp
	br	conversiondp
	br	conversiondp
	br	conversiondp
	br	paddone
	br	paddone
	br	paddone
	br	conversiondp
	br	paddone
	br	paddone
	br	paddone

/*
 * Add one to the bit of the mantissa which corresponds to the LSB of an
 * integer. If the mantissa overflows, then there is a valid integer
 * overflow conversion; otherwise, the mantissa can be converted to the
 * integer.
 */
paddone:
	or	r10,r0,r0	/* clear r10 */
	set	r10,r10,1<22>	/* set LSB bit to 1 for adding */
	addu.co	r8,r8,r10	/* add the 1 obtained from rounding */
	clr	r11,r7,12<20>	/* clear exponent and sign */
	addu.ci	r11,r0,r11	/* add carry */
	bb1	20,r11,overflw	/* overflow to 2**31, abort the rest */
	br.n	conversiondp	/* since the exp. was 30, and the exp. */
				/* did not round up to 31, the largest */
				/* number that S2 could become is 2**31-1 */
	 or	r7,r0,r11	/* store r11 into r7 for conversion */

/*
 * Now check for negative double precision sources. If the exponent is 30,
 * then convert the false alarm. If the exponent is 31, then check the
 * mantissa bits which correspond to integer bits. If any of them are a one,
 * then there is overflow. If they are zero, then check the guard, round,
 * and sticky bits.
 * Round toward zero and positive will not cause a roundup, but round toward
 * nearest and negative may, so perform those roundings. If there is no
 * overflow, then convert and return.
 */
checkdoubn:
	cmp	r11,r10,29		/* compare to 30, but exp. off by 1 */
	bb1	eq,r11,conversiondn	/* false alarm if exp. = 30 */
	extu	r10,r8,11<21>		/* check upper bits of lower mantissa */
	bcnd	ne0,r10,overflw		/* one of the bits is a 1, so oflow */
	extu	r10,r7,20<0>		/* check upper bits of upper mantissa */
	bcnd	ne0,r10,overflw		/* one of the bits is a 1, so oflow */
	bb0	rndlo,r1,possround	/* rounding mode is either round near */
					/* or round negative, which may cause */
					/* a round */
	br.n	FPintov_return		/* round positive, which will not */
					/* cause a round */
	 set	r6,r0,1<sign>
possround:
	extu	r12,r8,1<20>		/* get guard bit */
	extu	r11,r8,20<0>		/* get bits for sticky bit */
	bcnd.n	eq0,r11,nostickyn	/* do not set sticky */
	 mak	r12,r12,1<1>		/* set up field for branch table */
	set	r12,r12,1<0>		/* set sticky bit */
nostickyn:
	bb1	rndhi,r1,negative	/* rounding mode is negative */
nearest:
	cmp	r12,r12,3		/* are both guard and sticky set */
	bb1	eq,r12,overflw		/* both guard and sticky are set, */
					/* so signal overflow */
	or	r6,r0,r0		/* clear destination register r6 */
	br.n	FPintov_return
	 set	r6,r6,1<sign>		/* set the sign bit and take care of */
					/* this special case */
negative:
	bcnd	ne0,r12,overflw		/* -2**31 will be rounded to */
					/* -(2**31+1), so signal overflow */
	or	r6,r0,r0		/* clear destination register r6 */
	br.n	FPintov_return
	 set	r6,r6,1<sign>		/* set the sign bit and take care of */
					/* this special case */

	/*
	 * Since the exp. was 30, and there was no round-up, the largest
	 * number that S2 could have been was 2**31 - 1
	 */


d508 9
a516 9

conversionsp:
	extu	r6,r8,3<29>	/* extract lower bits of integer */
	mak	r6,r6,3<7>	/* shift left to correct place in integer */
	mak	r10,r7,20<10>	/* shift left upper bits of integer */
	or	r6,r6,r10	/* form most of integer */
	br.n	FPintov_return
	 set	r6,r6,1<30>	/* set hidden one */

d518 15
a532 16

conversionsn:
	bb1	eq,r11,exp31s	/* use old r11 to see if exp. is 31 */
	extu	r6,r8,3<29>	/* extract lower bits of mantissa */
	mak	r6,r6,3<7>	/* shift left to correct place in integer */
	mak	r10,r7,20<10>	/* shift left upper bits of integer */
	or	r6,r6,r10	/* form most of integer */
	set	r6,r6,1<30>	/* set hidden one */
	or.c	r6,r0,r6	/* negate result */
	br.n	FPintov_return
	 addu	r6,r6,1		/* add 1 to get 2''s complement */
exp31s:
	or	r6,r0,r0	/* clear r6 */
	br.n	FPintov_return
	 set	r6,r6,1<sign>	/* set sign bit */

d534 91
a624 102

conversiondp:
	extu	r6,r8,10<22>	/* extract lower bits of integer */
	mak	r10,r7,20<10>	/* shift left upper bits of integer */
	or	r6,r6,r10	/* form most of integer */
	br.n	FPintov_return
	 set	r6,r6,1<30>	/* set hidden one */

	/*
	 * Convert the double precision negative floating point number.
	 * The number, whose exponent is 30, must be rounded before converting.
	 * Bits 4 and 3 are the rounding mode, and bits 2, 1, and 0 are the
	 * guard, round, and sticky bits for the branch table.
	 */

conversiondn:
	extu	r12,r8,1<22>	/* get LSB for integer with exp. = 30 */
	mak	r12,r12,1<2>	/* start to set up field for branch table */
	extu	r11,r8,1<21>	/* get guard bit */
	mak	r11,r11,1<1>	/* set up field for branch table */
	or	r12,r11,r12	/* set up field for branch table */
	extu	r11,r8,21<0>	/* get bits for sticky bit */
	bcnd	eq0,r11,nostkyn	/* do not set sticky */
	set	r12,r12,1<0>	/* set sticky bit */
nostkyn:
	rot	r11,r1,0<rndlo>	/* shift rounding mode to 2 LSB''s */
	mak	r11,r11,2<3>	/* set up field, clear other bits */
	or	r12,r11,r12	/* set up field for branch table */
	lda	r12,r0[r12]	/* scale r12 */
	or.u	r12,r12,hi16(ntable) /* load pointer into table */
	addu	r12,r12,lo16(ntable)
	jmp	r12

ntable:
	br	nnoaddone
	br	nnoaddone
	br	nnoaddone
	br	naddone
	br	nnoaddone
	br	nnoaddone
	br	naddone
	br	naddone
	br	nnoaddone
	br	nnoaddone
	br	nnoaddone
	br	nnoaddone
	br	nnoaddone
	br	nnoaddone
	br	nnoaddone
	br	nnoaddone
	br	nnoaddone
	br	naddone
	br	naddone
	br	naddone
	br	nnoaddone
	br	naddone
	br	naddone
	br	naddone
	br	nnoaddone
	br	nnoaddone
	br	nnoaddone
	br	nnoaddone
	br	nnoaddone
	br	nnoaddone
	br	nnoaddone
	br	nnoaddone

/*
 * Add one to the mantissa, and check to see if it overflows to -2**31.
 * The conversion is done in nnoaddone.
 */

naddone:
	or	r10,r0,r0	/* clear r10 */
	set	r10,r10,1<22>	/* set LSB bit to 1 for adding */
	add.co	r8,r8,r10	/* add the 1 obtained from rounding */
	clr	r7,r7,12<20>	/* clear exponent and sign */
	add.ci	r7,r0,r7	/* add carry */
	bb1	20,r7,maxneg	/* rounded to -2**31,handle separately */
				/* the exponent was originally 30 */
nnoaddone:
	extu	r6,r8,11<22>	/* extract lower bits of integer */
	mak	r10,r7,20<10>	/* shift left upper bits of integer */
	or	r6,r6,r10	/* form most of integer */
	set	r6,r6,1<30>	/* set hidden one */
	or.c	r6,r0,r6	/* negate integer */
	br.n	FPintov_return
	 addu	r6,r6,1		/* add 1 to get 2''s complement */

maxneg:
	or	r6,r0,r0	/* clear integer */
	br.n	FPintov_return
	 set	r6,r6,1<sign>	/* set sign bit */

	/*
	 * For valid overflows, check to see if the integer overflow user
	 * handler is set. If it is set, then go to user handler, else write
	 * the correctly signed largest integer.
	 */

overflw:
	set	r2,r2,1<oper>
d626 5
a630 4
	bb0	oper,r3,nohandler	/* do not go to user handler routine */
	bsr	_handler		/* go to user handler routine */
	br	FPintov_return
nohandler:
d632 8
a639 4
	bb0.n	sign,r7,FPintov_return	/* if positive then return */
	 set	r6,r6,31<0>		/* set result to largest positive int */
	or.c	r6,r0,r6		/* negate r6, giving largest negative */
					/* integer */
d641 148
a788 41
FPintov_return:
	ld	r1,r31,0		/* load return address from memory */
	jmp	r1

/*
 * Some instructions only have the S2 operations, so clear S1HI and S1LO
 * for those instructions so that the previous contents of S1HI and S1LO
 * do not influence this instruction.
 */

ASLOCAL(FPresoper)
	st	r1, r31, 0
	extu	r10,r9,5<11>	/* extract opcode */
#if 0
	cmp	r11,r10,FSQRTop	/* compare to FSQRT */
	bb1	eq,r11,S1clear	/* clear S1 if instruction only had S2 operand */
#endif
	cmp	r11,r10,INTop	/* compare to INT */
	bb1	eq,r11,S1clear	/* clear S1 if instruction only had S2 operand */
	cmp	r11,r10,NINTop	/* compare to NINT */
	bb1	eq,r11,S1clear	/* clear S1 if instruction only had S2 operand */
	cmp	r11,r10,TRNCop	/* compare to TRNC */
	bb0	eq,r11,opercheck /* check for reserved operands */

ASLOCAL(S1clear)
	or	r5,r0,r0	/* clear any NaN''s, denorms, or infinities */
	or	r6,r0,r0	/* that may be left in S1HI,S1LO from a */
				/* previous instruction */

/*
 * r12 contains the following flags:
 *   bit 9 -- s1sign
 *   bit 8 -- s2sign
 *   bit 7 -- s1nan
 *   bit 6 -- s2nan
 *   bit 5 -- s1inf
 *   bit 4 -- s2inf
 *   bit 3 -- s1zero
 *   bit 2 -- s2zero
 *   bit 1 -- s1denorm
 *   bit 0 -- s2denorm
d790 2
d793 2
a794 5
/*
 * Using code for both single and double precision, check if S1 is either
 * a NaN or infinity and set the appropriate flags in r12. Then check if
 * S2 is a NaN or infinity. If it is a NaN, then branch to the NaN routine.
 */
d796 2
a797 91
ASLOCAL(opercheck)
	extu	r10,r5,11<20>	/* internal representation for double */
	bb1.n	s1size,r9,S1NaNdoub /* S1 is double precision */
	 or	r12,r0,r0	/* clear operand flag register */
ASLOCAL(S1NaNsing)
	xor	r10,r10,0x0080	/* internal representation for single */
	ext	r10,r10,8<0>	/* precision is IEEE 8 bits sign extended */
				/* to 11 bits; for real exp. > 0, the */
				/* above instructions gives a result exp. */
				/* that has the MSB flipped and sign */
				/* extended like in the IMPCR */
	cmp	r11,r10,127	/* Is exponent equal to IEEE 255 (here 127) */
	bb1	ne,r11,S2NaN	/* source 1 is not a NaN or infinity */
	mak	r10,r5,20<0>	/* load r10 with upper bits of S1 mantissa */
	extu	r11,r6,3<29>	/* get 3 upper bits of lower word */
	or	r11,r10,r11	/* combine any existing 1 */
	bcnd	eq0,r11,noS1NaNs /* since r11 can only hold 0 or a */
				/* > 0 number, branch to noS1NaN when eq0 */
	br.n	S2NaN		/* see if S2 has a NaN */
	 set	r12,r12,1<s1nan> /* indicate that S1 has a NaN */
ASLOCAL(noS1NaNs)
	br.n	S2NaN		/* check contents of S2 */
	 set	r12,r0,1<s1inf>	/* indicate that S1 has an infinity */

ASLOCAL(S1NaNdoub)
	xor	r10,r10,0x0400	/* precision is the same IEEE 11 bits */
				/* The above instructions gives a result exp. */
				/* that has the MSB flipped and sign */
				/* extended like in the IMPCR */
	cmp	r11,r10,1023	/* Is exp. equal to IEEE 2047 (internal 1023) */
	bb1	ne,r11,S2NaN	/* source 1 is not a NaN or infinity */
	mak	r10,r5,20<0>	/* load r10 with upper bits of S1 mantissa */
	or	r11,r6,r10	/* combine existing 1''s of mantissa */
	bcnd	eq0,r11,noS1NaNd /* since r11 can only hold 0 or a > 0 */
				/* number, branch to noS1NaN when eq0 */
	br.n	S2NaN		/* see if S2 has a NaN */
	 set	r12,r12,1<s1nan> /* indicate that S1 has a NaN */
ASLOCAL(noS1NaNd)
	set	r12,r0,1<s1inf>	/* indicate that S1 has an infinity */

ASLOCAL(S2NaN)
	bb1.n	s2size,r9,S2NaNdoub /* S1 is double precision */
	 extu	r10,r7,11<20>	/* internal representation for double */
ASLOCAL(S2NaNsing)
	xor	r10,r10,0x0080	/* internal representation for single */
	ext	r10,r10,8<0>	/* precision is IEEE 8 bits sign extended */
				/* to 11 bits; for real exp. > 0, the */
				/* above instruction gives a result exp. */
				/* that has the MSB flipped and sign */
				/* extended like in the IMPCR */
	cmp	r11,r10,127	/* Is exponent equal to IEEE 255 (here 127) */
	bb1	ne,r11,inf	/* source 2 is not a NaN or infinity */
	mak	r10,r7,20<0>	/* load r10 with upper bits of S1 mantissa */
	extu	r11,r8,3<29>	/* get 3 upper bits of lower word */
	or	r11,r10,r11	/* combine any existing 1''s */
	bcnd	eq0,r11,noS2NaNs /* since r11 can only hold 0 or a > 0 */
				/* number, branch to noS2NaNs when eq0 */
	br.n	_ASM_LABEL(NaN)	/* branch to NaN routine */
	 set	r12,r12,1<s2nan> /* indicate that s2 has a NaN */
ASLOCAL(noS2NaNs)
	bb0	s1nan,r12, 1f	/* branch to NaN if S1 is a NaN */
	br	_ASM_LABEL(NaN)
1:
	br.n	_ASM_LABEL(infinity) /* If S1 had a NaN we would have */
				/* already branched, and S2 does not have a */
				/* NaN, but it does have an infinity, so */
				/* branch to handle the finity */
	 set	r12,r12,1<s2inf> /* indicate that S2 has an infinity */

ASLOCAL(S2NaNdoub)
	xor	r10,r10,0x0400	/* precision is the same IEEE 11 bits */
				/* The above instruction gives a result exp. */
				/* that has the MSB flipped and sign */
				/* extended like in the IMPCR */
	cmp	r11,r10,1023	/* Is exp. equal to IEEE 2047 (internal 1023) */
	bb1	ne,r11,inf	/* source 2 is not a NaN or infinity */
	mak	r10,r7,20<0>	/* load r10 with upper bits of S2 mantissa */
	or	r11,r8,r10	/* combine existing 1''s of mantissa */
	bcnd	eq0,r11,noS2NaNd /* since r11 can only hold 0 or a > 0 */
				/* number, branch to noS2NaNd when eq0 */
	br.n	_ASM_LABEL(NaN)	/* branch to NaN routine */
	 set	r12,r12,1<s2nan> /* indicate that s2 has a NaN */
ASLOCAL(noS2NaNd)
	bb0	s1nan,r12,1f	/* branch to NaN if S1 is a NaN */
	br	_ASM_LABEL(NaN)
1:
	br.n	_ASM_LABEL(infinity) /* If S1 had a NaN we would have */
				/* already branched, and S2 does not have a */
				/* NaN, but it does have an infinity, so */
				/* branch to handle the finity */
	 set	r12,r12,1<s2inf> /* indicate that S2 has an infinity */
d799 2
a800 19
/*
 * If S2 was a NaN, the routine would have already branched to NaN. If S1
 * is a NaN, then branch to NaN. If S1 is not a NaN and S2 is infinity, then
 * we would have already branched to infinity. If S1 is infinity, then branch.
 * If the routine still has not branched, then branch to denorm, the only
 * reserved operand left.
 */

ASLOCAL(inf)
	bb0	s1nan,r12,1f	/* branch if S1 has a NaN and S2 does not */
	br	_ASM_LABEL(NaN)
1:
	bb0	s1inf,r12,2f	/* Neither S1 or S2 has a NaN, and we would */
				/* have branched already if S2 had an */
				/* infinity, so branch if S1 is infinity */
	br	_ASM_LABEL(infinity)
2:
	br	_ASM_LABEL(denorm)	/* branch to denorm, the only */
					/* remaining alternative */
d802 4
a805 6
/*
 * First check for an underflow user handler. If there is not one, then
 * branch to the routine to make a denormalized number. Before branching
 * to the underflow user handler, add 192 to a single precision exponent
 * and 1536 to a double precision exponent.
 */
d807 1
a807 4
ASLOCAL(FPunderflow)
	st	r1,r31,0	/* save return address */
	set	r2,r2,1<underflow>
	set	r2,r2,1<inexact>
d809 10
a818 12
	bb0	efunf,r12,FPU_denorm	/* jump to default procedure */
	bb1	destsize,r12,doubleprec	/* double precision destination */
singleprec:
	or.u	r6,r0,0x0c00	/* load exponent adjust 192 */
	br.n	callundhand	/* branch to call handler for user handler */
	 add	r12,r6,r12	/* adjust single precision exponent */
doubleprec:
	or.u	r6,r0,0x6000	/* load exponent adjust 1536 */
	add	r12,r6,r12	/* adjust double precision exponent */
callundhand:
	bsr	_handler	/* call handler for user handler */
	br	Ureturn
d821 20
a840 24
/*
 * Now the floating point number, which has an exponent smaller than what
 * IEEE allows, must be denormalized. Denormalization is done by calculating
 * the difference between a denormalized exponent and an underflow exponent
 * and shifting the mantissa by that amount. A one may need to be subtracted
 * from the LSB if a one was added during rounding.
 * r9 is used to contain the guard, round, sticky, and an inaccuracy bit in
 * case some bits were shifted off the mantissa during denormalization.
 * r9 will contain:
 *   bit 4 -- new addone if one added during rounding after denormalization
 *   bit 3 -- inaccuracy flag caused by denormalization or pre-denormalization
 *            inexactness
 *   bit 2 -- guard bit of result
 *   bit 1 -- round bit of result
 *   bit 0 -- sticky bit of result
 */

FPU_denorm:
	bb1.n	destsize,r12,Udouble 	/* denorm for double */
	 extu	r9,r10,3<26>	/* load r9 with grs */
Usingle:
	mak	r5,r10,21<3>	/* extract high 21 bits of mantissa */
	extu	r6,r11,3<29>	/* extract low 3 bits of mantissa */
	or	r11,r5,r6	/* form 24 bits of mantissa */
d843 326
a1168 397
	bb0.n	25,r10,nounrounds /* do not unround if addone bit clear */
	 extu	r6,r12,12<20>	/* extract signed exponent from IMPCR */
unrounds:
	subu	r11,r11,1	/* subtract 1 from mantissa */

/*
 * If the hidden bit is cleared after subtracting the one, then the one added
 * during the rounding must have propagated through the mantissa. The exponent
 * will need to be decremented.
 */
	bb1	23,r11,nounrounds /* if hidden bit is set,then exponent */
				/* does not need to be decremented */
decexps:
	sub	r6,r6,1		/* decrement exponent 1 */
	set	r11,r11,1<23>	/* set the hidden bit */

/*
 * For both single and double precision, there are cases where it is easier
 * and quicker to make a special case. Examples of this are if the shift
 * amount is only 1 or 2, or all the mantissa is shifted off, or all the
 * mantissa is shifted off and it is still shifting, or, in the case of
 * doubles, if the shift amount is around the boundary of MANTLO and MANTHI.
 */

nounrounds:
	or	r8,r0,lo16(0x00000f81)	/* load r8 with -127 in decimal */
					/* for lowest 12 bits */
	sub	r7,r8,r6	/* find difference between two exponents, */
				/* this amount is the shift amount */
	cmp	r6,r7,3		/* check to see if r7 contains 3 or more */
	bb1	ge,r6,threesing	/* br to code that handles shifts of >=3 */
	cmp	r6,r7,2		/* check to see if r7 contains 2 */
	bb1	eq,r6,twosing	/* br to code that handles shifts of 2 */
one:
	rot	r9,r9,0<1>	/* rotate roundoff register once, this places */
				/* guard in round and round in sticky */
	bb0	31,r9,nosticky1s /* do not or round and sticky if sticky is */
				/* 0, this lost bit will be cleared later */
	set	r9,r9,1<0>	/* or round and sticky */
nosticky1s:
	bb0	0,r11,guardclr1s /* do not set guard bit if LSB = 0 */
	set	r9,r9,1<2>	/* set guard bit */
guardclr1s:
	extu	r11,r11,31<1>	/* shift mantissa right 1 */
	br.n	round		/* round result */
	 mak	r9,r9,3<0>	/* clear bits lost during rotation */

twosing:
	rot	r9,r9,0<2>	/* rotate roundff register twice, this places */
				/* guard in sticky */
	bb0	30,r9,nosticky2s /* do not or guard and sticky if stick is 0 */
				/* this lost bit will be cleared later */
	br.n	noround2s	/* skip or old guard and old round if old */
				/* sticky set */
	 set	r9,r9,1<0>	/* or guard and sticky */
nosticky2s:
	bb0	31,r9,noround2s /* do not or guard and round if round is 0 */
				/* this lost bit will be cleared later */
	set	r9,r9,1<0>	/* or guard and round */
noround2s:
	bb0	0,r11,roundclr2s /* do not set round bit if LSB = 0 */
	set	r9,r9,1<1>	/* set round bit */
roundclr2s:
	bb0	1,r11,guardclr2s /* do not set guard bit if LSB + 1 = 0 */
	set	r9,r9,1<2>	/* set guard bit */
guardclr2s:
	extu	r11,r11,30<2>	/* shift mantissa right 2 */
	br.n	round		/* round result */
	 mak	r9,r9,3<0>	/* clear bits lost during rotation */

threesing:
	bb1	0,r9,noguard3s	/* check sticky initially */
				/* sticky is set, forget most of the oring */
nosticky3s:
	bb0	1,r9,noround3s	/* check round initially, do not set sticky */
	br.n	noguard3s	/* forget most of the rest of oring */
	 set	r9,r9,1<0>	/* if round is clear,set sticky if round set */
noround3s:
	bb0.n	2,r9,noguard3s	/* check guard initially, do not set sticky */
	 clr	r9,r9,2<1>	/* clear the original guard and round for when */
				/* you get to round section */
	set	r9,r9,1<0>	/* if guard is clear,set sticky if guard set */
noguard3s:
	cmp	r6,r7,23	/* check if # of shifts is <=23 */
	bb1	gt,r6,s24	/* branch to see if shifts = 24 */
	sub	r6,r7,2		/* get number of bits to check for sticky */
	mak	r6,r6,5<5>	/* shift width into width field */
	mak	r8,r11,r6	/* mask off shifted bits -2 */
	ff1	r8,r8		/* see if r8 has any ones */
	bb1	5,r8,nostky23	/* do not set sticky if no ones found */
	set	r9,r9,1<0>	/* set sticky bit */
nostky23:
	or	r8,r0,34	/* start code to get new mantissa plus two */
				/* extra bits for new round and new guard */
				/* bits */
	subu	r8,r8,r7
	mak	r8,r8,5<5>	/* shift field width into second five bits */
	extu	r6,r6,5<5>	/* shift previous shifted -2 into offset field */
	or	r6,r6,r8	/* complete field */
	extu	r11,r11,r6	/* form new mantissa with two extra bits */

	bb0	0,r11,nornd3s	/* do not set new round bit */
	set	r9,r9,1<1>	/* set new round bit */
nornd3s:
	bb0	1,r11,nogrd3s	/* do not set new guard bit */
	set	r9,r9,1<2>	/* set new guard bit */
nogrd3s:
	br.n	round		/* round mantissa */
	 extu	r11,r11,30<2>	/* shift off remaining two bits */

s24:
	cmp	r6,r7,24	/* check to see if # of shifts is 24 */
	bb1	gt,r6,s25	/* branch to see if shifts = 25 */
	bb1	0,r9,nostky24	/* skip checking if old sticky set */
	extu	r8,r11,22<0>	/* prepare to check bits that will be shifted */
				/* into the sticky */
	ff1	r8,r8		/* see if there are any 1''s */
	bb1	5,r8,nostky24	/* do not set sticky if no ones found */
	set	r9,r9,1<0>	/* set sticky bit */
nostky24:
	bb0	22,r11,nornd24	/* do not set new round bit */
	set	r9,r9,1<1>	/* set new round bit */
nornd24:
	set	r9,r9,1<2>	/* set new guard bit,this is hidden bit */
	br.n	round		/* round mantissa */
	 or	r11,r0,r0	/* clear r11, all of mantissa shifted off */

s25:
	cmp	r6,r7,25	/* check to see if # of shifts is 25 */
	bb1	gt,r6,s26	/* branch to execute for shifts => 26 */
	bb1	0,r9,nostky25	/* skip checking if old sticky set */
	extu	r8,r11,23<0>	/* prepare to check bits that will be shifted */
				/* into the sticky */
	ff1	r8,r8		/* see if there are any 1''s */
	bb1	5,r8,nostky25	/* do not set sticky if no ones found */
	set	r9,r9,1<0>	/* set sticky bit */
nostky25:
	set	r9,r9,1<1>	/* set new round bit,this is hidden bit */
	clr	r9,r9,1<2>	/* clear guard bit since nothing shifted in */
	br.n	round		/* round and assemble result */
	 or	r11,r0,r0	/* clear r11, all of mantissa shifted off */

s26:
	set	r9,r9,1<0>	/* set sticky bit,this contains hidden bit */
	clr	r9,r9,2<1>	/* clear guard and round bits since nothing */
				/* shifted in */
	br.n	round		/* round and assemble result */
	 or	r11,r0,r0	/* clear mantissa */

Udouble:
	mak	r5,r10,21<0>	/* extract upper bits of mantissa */
	bb0.n	25,r10,nounroundd /* do not unround if addone bit clear */
	 extu	r6,r12,12<20>	/* extract signed exponenet from IMPCR */
unroundd:
	or	r8,r0,1
	subu.co	r11,r11,r8	/* subtract 1 from mantissa */
	subu.ci	r5,r5,r0	/* subtract borrow from upper word */
	bb1	20,r5,nounroundd /* if hidden bit is set, then exponent does */
				/* not need to be decremented */
decexpd:
	sub	r6,r6,1		/* decrement exponent 1 */
	set	r5,r5,1<20>	/* set the hidden bit */

nounroundd:
	or	r8,r0,lo16(0x00000c01) /* load r8 with -1023 in decimal */
				/* for lowest 12 bits */
	sub	r7,r8,r6	/* find difference between two exponents, */
				/* this amount is the shift amount */
	cmp	r6,r7,3		/* check to see if r7 contains 3 or more */
	bb1	ge,r6,threedoub	/* br to code that handles shifts of >=3 */
	cmp	r6,r7,2		/* check to see if r7 contains 2 */
	bb1	eq,r6,twodoub	/* br to code that handles shifts of 2 */

onedoub:
	rot	r9,r9,0<1>	/* rotate roundoff register once, this places */
				/* guard in round and round in sticky */
	bb0	31,r9,nosticky1d/* do not or round and sticky if sticky is 0 */
				/* this lost bit will be cleared later */
	set	r9,r9,1<0>	/* or old round and old sticky into new sticky */
nosticky1d:
	bb0	0,r11,guardclr1d /* do not set new guard bit if old LSB = 0 */
	set	r9,r9,1<2>	/* set new guard bit */
guardclr1d:
	extu	r11,r11,31<1>	/* shift lower mantissa over 1 */
	mak	r6,r5,1<31>	/* shift off low bit of high mantissa */
	or	r11,r6,r11	/* load high bit onto lower mantissa */
	extu	r5,r5,20<1>	/* shift right once upper 20 bits of mantissa */
	br.n	round		/* round mantissa and assemble result */
	 mak	r9,r9,3<0>	/* clear bits lost during rotation */

twodoub:
	rot	r9,r9,0<2>	/* rotate roundoff register twice, this places */
				/* old guard into sticky */
	bb0	30,r9,nosticky2d /* do not or old guard and old sticky if */
				/* old sticky is 0 */
	br.n	noround2d	/* skip or of old guard and old round if old */
				/* sticky set */
	 set	r9,r9,1<0>	/* or old guard and old sticky into new sticky */
nosticky2d:
	bb0	31,r9,noround2d	/* do not or old guard and old round if */
				/* old round is 0 */
	set	r9,r9,1<0>	/* or old guard and old round into new sticky */
noround2d:
	bb0	0,r11,roundclr2d /* do not set round bit if old LSB = 0 */
	set	r9,r9,1<1>	/* set new round bit */
roundclr2d:
	bb0	1,r11,guardclr2d /* do not set guard bit if old LSB + 1 = 0 */
	set	r9,r9,1<2>	/* set new guard bit */
guardclr2d:
	extu	r11,r11,30<2>	/* shift lower mantissa over 2 */
	mak	r6,r5,2<30>	/* shift off low bits of high mantissa */
	or	r11,r6,r11	/* load high bit onto lower mantissa */
	extu	r5,r5,19<2>	/* shift right twice upper 19 bits of mantissa */
	br.n	round		/* round mantissa and assemble result */
	 mak	r9,r9,3<0>	/* clear bits lost during rotation */

threedoub:
	bb1	0,r9,noguard3d	/* checky sticky initially */
				/* sticky is set, forget most of rest of oring */
nosticky3d:
	bb0	1,r9,noround3d	/* check old round, do not set sticky if */
				/* old round is clear, set otherwise */
	br.n	noguard3d	/* sticky is set, forget most of rest of oring */
	 set	r9,r9,1<0>	/* set sticky if old round is set */
noround3d:
	bb0	2,r9,noguard3d	/* check old guard, do not set sticky if 0 */
	clr	r9,r9,2<1>	/* clear the original guard and round for when */
				/* you get to round section */
	set	r9,r9,1<0>	/* set sticky if old guard is set */
noguard3d:
	cmp	r6,r7,32	/* do I need to work with a 1 or 2 word mant. */
				/* when forming sticky, round and guard */
	bb1	gt,r6,d33	/* jump to code that handles 2 word mantissas */
	sub	r6,r7,2		/* get number of bits to check for sticky */
	mak	r6,r6,5<5>	/* shift width into width field */
	mak	r8,r11,r6	/* mask off shifted bits -2 */
	ff1	r8,r8		/* see if r8 has any ones */
	bb1	5,r8,nostky32	/* do not set sticky if no ones found */
	set	r9,r9,1<0>	/* set sticky bit */
nostky32:
	or	r8,r0,34	/* start code to get new mantissa plus two */
				/* extra bits for new round and new guard bits, */
				/* the upper word bits will be shifted after */
				/* the round and guard bits are handled */
	subu	r8,r8,r7
	mak	r8,r8,5<5>	/* shift field width into second five bits */
	extu	r6,r6,5<5>	/* shift previous shifted -2 into offset field */
	or	r6,r6,r8	/* complete bit field */
	extu	r11,r11,r6	/* partially form new low mantissa with 2 more */
				/* bits */
	bb0	0,r11,nornd32d	/* do not set new round bit */
	set	r9,r9,1<1>	/* set new round bit */
nornd32d:
	bb0	1,r11,nogrd32d	/* do not set new guard bit */
	set	r9,r9,1<2>	/* set new guard bit */
nogrd32d:
	extu	r11,r11,30<2>	/* shift off remaining two bits */
	mak	r6,r7,5<5>	/* shift field width into second 5 bits, if the */
				/* width is 32, then these bits will be 0 */
	or	r8,r0,32	/* load word length into r8 */
	sub	r8,r8,r7	/* form offset for high bits moved to low word */
	or	r6,r6,r8	/* form complete bit field */
	mak	r6,r5,r6	/* get shifted bits of high word */
	or	r11,r6,r11	/* form new low word of mantissa */
	bcnd	ne0,r8,regular33 /* do not adjust for special case of r8 */
	br.n	round		/* containing zeros, which would cause */
	 or	r5,r0,r0	/* all of the bits to be extracted under */
				/* the regular method */
regular33:
	mak	r6,r7,5<0>	/* place lower 5 bits of shift into r6 */
	mak	r8,r8,5<5>	/* shift r8 into width field */
	or	r6,r6,r8	/* form field for shifting of upper bits */
	br.n	round		/* round and assemble result */
	 extu	r5,r5,r6	/* form new high word mantissa */

d33:
	cmp	r6,r7,33	/* is the number of bits to be shifted is 33? */
	bb1	gt,r6,d34	/* check to see if # of bits is 34 */
	bb1	0,r9,nostky33	/* skip checking if old sticky set */
	mak	r6,r11,31<0>	/* check bits that will be shifted into sticky */
	ff1	r8,r8		/* check for ones */
	bb1	5,r8,nostky33	/* do not set sticky if there are no ones */
	set	r9,r9,1<0>	/* set new sticky bit */
nostky33:
	bb0	31,r11,nornd33	/* do not set round if bit is not a 1 */
	set	r9,r9,1<1>	/* set new round bit */
nornd33:
	bb0	0,r5,nogrd33	/* do not set guard bit if bit is not a 1 */
	set	r9,r9,1<2>	/* set new guard bit */
nogrd33:
	extu	r11,r5,31<1>	/* shift high bits into low word */
	br.n	round		/* round and assemble result */
	 or	r5,r0,r0	/* clear high word */

d34:
	cmp	r6,r7,34	/* is the number of bits to be shifted 34? */
	bb1	gt,r6,d35	/* check to see if # of bits is >= 35 */
	bb1	0,r9,nostky34	/* skip checking if old sticky set */
	ff1	r8,r11		/* check bits that will be shifted into sticky */
	bb1	5,r8,nostky34	/* do not set sticky if there are no ones */
	set	r9,r9,1<0>	/* set new sticky bit */
nostky34:
	bb0	0,r5,nornd34	/* do not set round if bit is not a 1 */
	set	r9,r9,1<1>	/* set new round bit */
nornd34:
	bb0	1,r5,nogrd34	/* do not set guard bit if bit is not a 1 */
	set	r9,r9,1<2>	/* set new guard bit */
nogrd34:
	extu	r11,r5,30<2>	/* shift high bits into low word */
	br.n	round		/* round and assemble result */
	 or	r5,r0,r0	/* clear high word */

d35:
	cmp	r6,r7,52	/* see if # of shifts is 35 <= X <= 52 */
	bb1	gt,r6,d53	/* check to see if # of shifts is 52 */
	bb1.n	0,r9,nostky35	/* skip checking if old sticky set */
	 sub	r7,r7,34	/* subtract 32 from # of shifts so that opera- */
				/* tions can be done on the upper word, and */
				/* then subtract two more checking guard and */
				/* sticky bits */
	ff1	r8,r11		/* see if lower word has a bit for sticky */
	bb1	5,r8,stkycheck35 /* see if upper word has any sticky bits	*/
	br.n	nostky35	/* quit checking for sticky */
	 set	r9,r9,1<0>	/* set sticky bit */
stkycheck35:
	mak	r6,r7,5<5>	/* place width into width field */
	mak	r8,r5,r6	/* mask off shifted bits - 2 */
	ff1	r8,r8		/* see if r8 has any ones */
	bb1	5,r8,nostky35	/* do not set sticky if no ones found */
	set	r9,r9,1<0>	/* set sticky bit */
nostky35:
	or	r8,r0,32	/* look at what does not get shifted off plus */
				/* round and sticky, remember that the r7 value */
				/* was adjusted so that it did not include */
				/* new round or new sticky in shifted off bits */
	subu	r8,r8,r7	/* complement width */
	mak	r8,r8,5<5>	/* shift width into width field */
	or	r8,r7,r8	/* add offset field */
	extu	r11,r5,r8	/* extract upper bits into low word */
	bb0	0,r11,nornd35	/* do not set new round bit */
	set	r9,r9,1<1>	/* set new round bit */
nornd35:
	bb0	1,r11,nogrd35	/* do not set new guard bit */
	set	r9,r9,1<2>	/* set new guard bit */
nogrd35:
	extu	r11,r11,30<2>	/* shift off remaining guard and round bits */
	br.n	round		/* round and assemble result */
	 or	r5,r0,r0	/* clear high word */

d53:
	cmp	r6,r7,53	/* check to see if # of shifts is 53 */
	bb1	gt,r6,d54	/* branch to see if shifts = 54 */
	bb1	0,r9,nostky53	/* skip checking if old sticky set */
	ff1	r8,r11		/* see if lower word has a bit for sticky */
	bb1	5,r8,stkycheck53 /* see if upper word has any sticky bits	*/
	br.n	nostky53	/* quit checking for sticky */
	 set	r9,r9,1<0>	/* set sticky bit */
stkycheck53:
	mak	r6,r5,19<0>	/* check bits that are shifted into sticky */
	ff1	r8,r6		/* see if r6 has any ones */
	bb1	5,r8,nostky53	/* do not set sticky if no ones found */
	set	r9,r9,1<0>	/* set sticky bit */
nostky53:
	bb0	19,r5,nornd53	/* do not set new round bit */
	set	r9,r9,1<1>	/* set new round bit */
nornd53:
	set	r9,r9,1<2>	/* set new guard bit,this is hidden bit */
	or	r5,r0,r0	/* clear high word */
	br.n	round		/* round and assemble result */
	 or	r11,r0,r0	/* clear low word */

d54:
	cmp	r6,r7,54	/* check to see if # of shifts is 54 */
	bb1	gt,r6,d55	/* branch to execute for shifts =>55 */
	bb1	0,r9,nostky54	/* skip checking if old sticky set */
	ff1	r8,r11		/* see if lower word has a bit for sticky */
	bb1	5,r8,stkycheck54 /* see if upper word has any sticky bits	*/
	br.n	nostky54	/* quit checking for sticky */
	 set	r9,r9,1<0>	/* set sticky bit */
stkycheck54:
	mak	r6,r5,20<0>	/* check bits that are shifted into sticky */
	ff1	r8,r6		/* see if r6 has any ones */
	bb1	5,r8,nostky54	/* do not set sticky if no ones found */
	set	r9,r9,1<0>	/* set sticky bit */
nostky54:
	set	r9,r9,1<1>	/* set new round bit,this is hidden bit */
	clr	r9,r9,1<2>	/* clear guard bit since nothing shifted in */
	or	r5,r0,r0	/* clear high word */
	br.n	round		/* round and assemble result */
	 or	r11,r0,r0	/* clear low word */

d55:
	set	r9,r9,1<0>	/* set new sticky bit,this contains hidden bit */
	clr	r9,r9,2<1>	/* clear guard and round bits since nothing */
				/* shifted in */
	or	r5,r0,r0	/* clear high word */
	or	r11,r0,r0	/* clear low word */
d1172 1
a1172 1
/* or sticky is set. If all are clear, then there is no denormalization loss */
d1174 3
a1176 3
/* For rounding, a branch table is set up. The left two most bits are the */
/* rounding mode. The third bit is either the LSB of the mantissa or the */
/* sign bit, depending on the rounding mode. The three LSB''s are the guard, */
d1179 82
a1260 86
round:
	ff1	r8,r9		/* see if there is denormalization loss */
	bb1	5,r8,assemble	/* no denormalization loss or inexactness */
	extu	r6,r10,2<modelo> /* extract rounding mode */
	bb1.n	modehi,r10,signext /* use sign bit instead of LSB */
	 mak	r6,r6,2<4>	/* shift over rounding mode */
	extu	r7,r11,1<0>	/* extract LSB */
	br.n	grs		/* skip sign extraction */
	 mak	r7,r7,1<3>	/* shift over LSB */
signext:
	extu	r7,r10,1<31>	/* extract sign bit */
	mak	r7,r7,1<3>	/* shift sign bit over */
grs:
	or	r6,r6,r7
	or	r6,r6,r9	/* or in guard, round, and sticky */
	or.u	r1,r0,hi16(roundtable) /* form address of branch table */
	or	r1,r1,lo16(roundtable)
	lda	r6,r1[r6]	/* scale offset into branch table */
	jmp.n	r6		/* jump to branch table */
	 set	r9,r9,1<3>	/* set inexact flag in r9 */

roundtable:
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	addone
	br	addone
	br	addone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	addone
	br	addone
	br	addone
	br	addone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	addone
	br	addone
	br	addone
	br	addone
	br	addone
	br	addone
	br	addone
	br	noaddone
	br	addone
	br	addone
	br	addone
	br	addone
	br	addone
	br	addone
	br	addone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
	br	noaddone
d1263 5
a1267 6
addone:
	or	r6,r0,1		/* load a 1 into r6 so that add.co can be used */
	add.co	r11,r11,r6	/* add a one to the lower word of result */
	bb0.n	destsize,r12,noaddone /* single result,forget carry */
	 set	r9,r9,1<4>	/* indicate that a 1 has been added */
	add.ci	r5,r5,r0	/* propagate carry into high word */
d1272 1
a1272 3
noaddone:
	set	r2,r2,1<inexact>
	set	r2,r2,1<underflow>
d1274 3
a1276 2
	bb1	efinx,r12,modformdef	/* branch to modify form for user */
					/* handler */
d1280 2
a1281 2
/* Assemble the result of the denormalization routine for writeback to the */
/* destination register. The exponent of a denormalized number is zero, */
d1284 10
a1293 14
assemble:
	bb1	destsize,r12,doubassem	/* assemble double result */
	bb0	sign,r10,exassems	/* exit assemble if sign is zero */
	set	r11,r11,1<sign>		/* make result negative */
exassems:
	br	Ureturn	

doubassem:
	bb0.n	sign,r10,signclr	/* do not set sign in r10 */
	 or	r10,r5,r0		/* load high word from r5 into r10 */
	set	r10,r10,1<sign>		/* high word with sign loaded */
signclr:
	br	Ureturn

d1296 1
a1296 1
/* the inexact user handler. This input format is the same format that */
d1300 15
a1314 19
modformdef:
	clr	r12,r12,12<20>	/* clear result exponent,IMPCR complete */
	clr	r10,r10,4<25>	/* clear old guard,round,sticky,and addone */
	mak	r5,r9,3<26>	/* make grs field */
	bb0.n	4,r9,newaddone	/* do not set new addone in MANTHI */
	 or	r10,r5,r10	/* or in new grs field */
	set	r10,r10,1<25>	/* set new addone */
newaddone:
	bb1.n	destsize,r12,moddefd /* branch to handle double precision */
	 clr	r10,r10,21<0>	/* clear upper bits of old mantissa */
moddefs:
	extu	r5,r11,20<3>	/* extract upper bits */
	or	r10,r5,r10	/* MANTHI complete */
	bsr.n	_handler	/* execute user handler for inexact */
	 rot	r11,r11,0<3>	/* MANTLO complete */
	br	Ureturn
moddefd:
	bsr.n	_handler	/* execute user handler for inexact */
	 or	r10,r5,r10	/* MANTHI complete,r5 should be set to OR */
d1317 1
d1320 13
a1332 3
Ureturn:
	ld	r1,r31,0	/* load return address */
	jmp	r1
a1333 3
/*
 * FPoverflow
 */
d1335 1
a1335 1
/* FPSR is set, and the inexact user handler bit is checked. If it is set, */
d1338 5
a1342 5

ASLOCAL(FPoverflow)
	st	r1,r31,0	/* save return address */
	set	r2,r2,1<overflow>
	set	r2,r2,1<inexact>
d1344 7
a1350 4
	bb1	efovf,r12,hand	/* go to user handler if bit set for overflow */
	bb0	efinx,r12,nohandler/* if userhandler for inexact not set,then */
				/* round result */
	br	callhandler	/* branch to user handler for inexact */
d1354 9
a1362 13

hand:
	bb1	10,r12,doubleprec /* double precision result */
singleprec:
	or.u	r5,r0,0x0c00	/* load exponent adjust */
	br.n	callhandler	/* prepare to call user handler */
	 subu	r12,r12,r5	/* adjust single precision exponent */
doubleprec:
	or.u	r5,r0,0x6000	/* load exponent adjust */
	subu	r12,r12,r5	/* adjust double precision exponent */
callhandler:
	bsr	_handler	/* branch to common handler routine */
	br	return
d1367 5
a1371 7
nohandler:
	bb1	modehi,r10,signed /* mode is either round toward pos. or neg. */
	bb0	modelo,r10,OFnearest /* rounding mode is round nearest */
	br	OFzero		/* rounding mode is round zero */
signed:
	bb0	modelo,r10,OFnegative /* rounding mode is round negative */
	br	positive	/* rounding mode is round positive */
d1375 1
a1375 1
/* positive infinity and negative values are loaded toward negative infinity. */
d1378 8
a1385 8
OFnearest:
	bb1.n	destsize,r12,neardouble	/* branch to neardouble of */
					/* double result */
	 mask.u	r5,r10,0x8000		/* mask off sign bit from MANTHI */
	or.u	r11,r0,hi16(0x7f800000)	/* load single infinity constant */
	or	r11,r11,lo16(0x7f800000)
	br.n	return			/* return with result */
	 or	r11,r5,r11		/* adjust sign */
d1387 5
a1391 5
	or	r11,r0,r0		/* load lower word of infinity */
	or.u	r10,r0,hi16(0x7ff00000)	/* load upper word of infinity */
	or	r10,r10,lo16(0x7ff00000)
	br.n	return			/* return with result */
	 or	r10,r5,r10		/* adjust sign */
d1399 14
a1412 14
OFzero:
	bb1.n	destsize,r12,zerodouble	/* branch to zerodouble of */
					/* double result */
	 mask.u	r5,r10,0x8000		/* mask off sign bit from MANTHI */
	or.u	r11,r0,hi16(0x7f7fffff)	/* load single finite number constant */
	or	r11,r11,lo16(0x7f7fffff)
	br.n	return			/* return with result */
	 or	r11,r5,r11		/* adjust sign */
zerodouble:
	set	r11,r0,0<0>		/* load lower word of finite number */
	or.u	r10,r0,hi16(0x7fefffff)	/* load upper word of finite number */
	or	r10,r10,lo16(0x7fefffff)
	br.n	return			/* return with result */
	 or	r10,r5,r10		/* adjust sign */
d1415 1
a1415 1
/* In the round toward positve mode, positive values are rounded to */
d1420 8
a1427 8
positive:
	bb1	destsize,r12,posdouble	/* branch to section for double result */
possingle:
	bb1	sign,r10,possingleneg	/* branch to section for negatives */
possinglepos:
	or.u	r11,r0,hi16(0x7f800000)	/* load single infinity constant */
	br.n	return			/* return with result */
	 or	r11,r11,lo16(0x7f800000)
d1429 17
a1445 17
	or.u	r11,r0,hi16(0x7f7fffff)	/* load single finite number constant */
	or	r11,r11,lo16(0x7f7fffff)
	br.n	return			/* return with result */
	 set	r11,r11,1<sign>		/* set sign for negative */
posdouble:
	bb1	sign,r10,posdoubleneg	/* branch to negative double results */
posdoublepos:
	or	r11,r0,r0		/* load lower word of double infinity */
	or.u	r10,r0,hi16(0x7ff00000)	/* load upper word of infinity */
	br.n	return			/* return with result */
	 or	r10,r10,lo16(0x7ff00000)
posdoubleneg:
	set	r11,r0,0<0>		/* load lower word of finite number */
	or.u	r10,r0,hi16(0x7fefffff)	/* load upper word of finite number */
	or	r10,r10,lo16(0x7fefffff)
	br.n	return			/* return with result */
	 set	r10,r10,1<sign>		/* set sign for negative */
d1448 1
a1448 1
/* In the round toward negative mode, positive values are rounded to the largest */
d1452 29
a1480 29
OFnegative:
	bb1	destsize,r12,negdouble	/* branch to section for double result */
negsingle:
	bb1	sign,r10,negsingleneg	/* branch to section for negatives */
negsinglepos:
	or.u	r11,r0,hi16(0x7f7fffff)	/* load single finite number constant */
	br.n	return			/* return with result */
	 or	r11,r11,lo16(0x7f7fffff)
negsingleneg:
	or.u	r11,r0,hi16(0x7f800000)	/* load single infinity constant */
	or	r11,r11,lo16(0x7f800000)
	br.n	return			/* return with result */
	 set	r11,r11,1<sign>		/* set sign for negative */
negdouble:
	bb1	sign,r10,negdoubleneg	/* branch to negative double results */
negdoublepos:
	set	r11,r0,0<0>		/* load lower word of finite number */
	or.u	r10,r0,hi16(0x7fefffff)	/* load upper word of finite number */
	br.n	return			/* return with result */
	 or	r10,r10,lo16(0x7fefffff)
negdoubleneg:
	or	r11,r0,r0		/* load lower word of double infinity */
	or.u	r10,r0,hi16(0x7ff00000)	/* load upper word of infinity */
	or	r10,r10,lo16(0x7ff00000)
	set	r10,r10,1<sign>		/* set sign for negative */

return:
	ld	r1,r31,0		/* ld return address */
	jmp	r1
d1482 1
a1482 1
	data
d1486 1
a1486 1
/* bit of the FPSR. If the invalid operation user handler flag is set and */
d1490 1
a1490 1
/* a quiet S1 to the result. A signalling NaN must be made quiet before */
d1493 23
a1515 6
	text
ASLOCAL(NaN)
	bb0.n	s1nan,r12,S2sigcheck	/* S1 is not a NaN */
	 st	r1,r31,0		/* save return address */
	bb1	sigbit,r5,S2sigcheck	/* S1 is not a signaling NaN */
	set	r2,r2,1<oper>
d1517 4
a1520 4
	bb0	oper,r3,S1nohandler	/* branch if no user handler */
	bsr	_handler		/* branch to handler */
	br	FPnan_return
ASLOCAL(S1nohandler)
d1522 9
a1530 9
	br.n	S1write		/* FPSR bit already set, S1 is made quiet, */
				/* and since we always write S1 if it is a */
				/* NaN, write S1 and skip rest of routine */
	 set	r5,r5,1<sigbit>	/* make S1 a quiet NaN */

ASLOCAL(S2sigcheck)
	bb0	s2nan,r12,S1write	/* S2 is not a NaN */
	bb1	sigbit,r7,S1write	/* S2 is not a signaling NaN */
	set	r2,r2,1<oper>
d1532 3
a1534 3
	bb0	oper,r3,S2nohandler	/* branch if no user handler */
	bsr	_handler		/* branch to handler */
	br	FPnan_return
d1537 2
a1538 2
ASLOCAL(S2nohandler)
	set	r7,r7,1<sigbit>	/* make S2 a quiet NaN */
d1544 11
a1554 11
ASLOCAL(S1write)
	bb0	s1nan,r12,S2write /* do not write S1 if it is not a NaN */
	extu	r10,r9,5<11>	/* extract opcode */
	cmp	r11,r10,FCMPop	/* compare to FCMP */
	bb1	ne,r11,S1noFCMP	/* operation is not FCMP */
	set	r6,r0,1<nc>	/* set the not comparable bit */
	br.n	FPnan_return
	 set	r6,r6,1<ne>	/* set the not equal bit */
ASLOCAL(S1noFCMP)
	bb1.n	dsize,r9,wrdoubS1 /* double destination */
	 set	r5,r5,11<20>	/* set all exponent bits to 1 */
d1556 35
a1590 24
ASLOCAL(wrsingS1)
	mak	r10,r5,28<3>	/* wipe out extra exponent bits */
	extu	r11,r6,3<29>	/* get lower three bits of mantissa */
	or	r10,r10,r11	/* combine all of result except sign */
	clr	r6,r5,31<0>	/* clear all but sign */
	br.n	FPnan_return
	 or	r6,r6,r10	/* form result */

ASLOCAL(wrdoubS1)
	set	r6,r6,29<0>	/* set extra bits of lower word */
	br	FPnan_return	/* no modification necessary for writing */
				/* double to double, so return */

ASLOCAL(S2write)
	extu	r10,r9,5<11>	/* extract opcode */
	cmp	r11,r10,FCMPop	/* compare to FCMP */
	bb1.n	ne,r11,S2noFCMP	/* operation is not FCMP */
	 set	r7,r7,11<20>	/* set all exponent bits to 1 */
	set	r6,r0,1<nc>	/* set the not comparable bit */
	br.n	FPnan_return
	 set	r6,r6,1<ne>	/* set the not equal bit */
ASLOCAL(S2noFCMP)
	bb1.n	dsize,r9,wrdoubS2 /* double destination */
	 set	r5,r5,11<20>	/* set all exponent bits to 1 */
d1592 17
a1608 7
ASLOCAL(wrsingS2)
	mak	r10,r7,28<3>	/* wipe out extra exponent bits */
	extu	r11,r8,3<29>	/* get lower three bits of mantissa */
	or	r10,r10,r11	/* combine all of result except sign */
	clr	r6,r7,31<0>	/* clear all but sign */
	br.n	FPnan_return
	 or	r6,r6,r10	/* form result */
a1609 2
ASLOCAL(wrdoubS2)
	set	r6,r8,29<0>	/* set extra bits of lower word */
d1613 11
a1623 5
ASLOCAL(FPnan_return)
				/* no modification necessary for writing */
				/* double to double, so return */
	ld	r1,r31, 0	/* retrieve return address */
	jmp	r1
a1624 5
	data

/*
 * infinity
 */
d1629 23
a1651 23
ASLOCAL(infinity)
	extu	r10,r9,5<11>	/* extract opcode */
	cmp	r11,r10,FADDop	/* compare to FADD */
	bb1.n	eq,r11,FADD	/* operation is FADD */
	 st	r1,r31,0	/* save return address */
	cmp	r11,r10,FSUBop	/* compare to FSUB */
	bb1	eq,r11,FSUB	/* operation is FSUB */
	cmp	r11,r10,FCMPop	/* compare to FCMP */
	bb1	eq,r11,FCMP	/* operation is FCMP */
	cmp	r11,r10,FMULop	/* compare to FMUL */
	bb1	eq,r11,FMUL	/* operation is FMUL */
	cmp	r11,r10,FDIVop	/* compare to FDIV */
	bb1	eq,r11,FDIV	/* operation is FDIV */
#if 0
	cmp	r11,r10,FSQRTop	/* compare to FSQRT */
	bb1	eq,r11,FSQRT	/* operation is FSQRT */
#endif
	cmp	r11,r10,INTop	/* compare to INT */
	bb1	eq,r11,FP_inf_overflw /* operation is INT */
	cmp	r11,r10,NINTop	/* compare to NINT */
	bb1	eq,r11,FP_inf_overflw /* operation is NINT */
	cmp	r11,r10,TRNCop	/* compare to TRNC */
	bb1	eq,r11,FP_inf_overflw /* operation is TRNC */
d1657 13
a1669 18
FADD:
	bb0	s1inf,r12,addS2write	/* branch if S1 not infinity */
	bb0	s2inf,r12,addS1write	/* S2 is not inf., so branch to write S1 */
	bb1	sign,r5,addS1neg	/* handle case of S1 negative */
addS1pos:
	bb1	sign,r7,excpt		/* adding infinities of different */
					/* signs causes an exception */
	br	poswrinf		/* branch to write positive infinity */
addS1neg:
	bb0	sign,r7,excpt		/* adding infinities of different */
					/* signs causes an exception */
	br	negwrinf		/* branch to write negative infinity */
addS1write:
	bb0	sign,r5,poswrinf	/* branch to write positive infinity */
	br	negwrinf		/* branch to write negative infinity */
addS2write:
	bb0	sign,r7,poswrinf	/* branch to write positive infinity */
	br	negwrinf		/* branch to write negative infinity */
d1675 13
a1687 18
FSUB:
	bb0	s1inf,r12,subS2write	/* branch if S1 not infinity */
	bb0	s2inf,r12,subS1write	/* S2 is not inf., so branch to write S1 */
	bb1	sign,r5,subS1neg	/* handle case of S1 negative */
subS1pos:
	bb0	sign,r7,excpt		/* subtracting infinities of the same */
					/* sign causes an exception */
	br	poswrinf		/* branch to write positive infinity */
subS1neg:
	bb1	sign,r7,excpt		/* subtracting infinities of the same */
					/* sign causes an exception */
	br	negwrinf		/* branch to write negative infinity */
subS1write:
	bb0	sign,r5,poswrinf	/* branch to write positive infinity */
	br	negwrinf		/* branch to write negative infinity */
subS2write:
	bb1	sign,r7,poswrinf	/* branch to write positive infinity */
	br	negwrinf		/* branch to write negative infinity */
d1693 82
a1774 109
FCMP:
	bb0.n	s1inf,r12,FCMPS1f	/* branch for finite S1 */
	 set	r4,r0,1<cp>		/* since neither S1 or S2 is a NaN, */
					/* set cp */
FCMPS1i:
	bb1	sign,r5,FCMPS1ni	/* branch to negative S1i */
FCMPS1pi:
	bb0	s2inf,r12,FCMPS1piS2f	/* branch to finite S2 with S1pi */
FCMPS1piS2i:
	bb1	sign,r7,FCMPS1piS2ni	/* branch to negative S2i with S1pi */
FCMPS1piS2pi:
	set	r4,r4,1<eq>		/* set eq bit */
	set	r4,r4,1<le>		/* set le bit */
	set	r4,r4,1<ge>		/* set ge bit */
	set	r4,r4,1<ib>		/* set ib bit */
	br.n	move
	 set	r4,r4,1<ob>		/* set ob bit */
FCMPS1piS2ni:
	set	r4,r4,1<ne>		/* set ne bit */
	set	r4,r4,1<gt>		/* set gt bit */
	br.n	move
	 set	r4,r4,1<ge>		/* set ge bit */
FCMPS1piS2f:
	set	r4,r4,1<ne>		/* set ne bit */
	set	r4,r4,1<gt>		/* set gt bit */
	bsr.n	_ASM_LABEL(zero)	/* see if any of the operands are zero */
	 set	r4,r4,1<ge>		/* set ge bit */
	bb0	s2zero,r12,FCMPS1piS2nz	/* check for negative if s2 not zero */
	set	r4,r4,1<ou>		/* set ou bit */
	br.n	move
	 set	r4,r4,1<ob>		/* set ob bit */
FCMPS1piS2nz:
	bb1	sign,r7,move		/* return if s2 is negative */
FCMPS1piS2pf:
	set	r4,r4,1<ou>		/* set ou bit */
	br.n	move
	 set	r4,r4,1<ob>		/* set ob bit */
FCMPS1ni:
	bb0	s2inf,r12,FCMPS1niS2f	/* branch to finite S2 with S1ni */
FCMPS1niS2i:
	bb1	sign,r7,FCMPS1niS2ni	/* branch to negative S2i with S1ni */
FCMPS1niS2pi:
	set	r4,r4,1<ne>		/* set eq bit */
	set	r4,r4,1<le>		/* set le bit */
	set	r4,r4,1<lt>		/* set lt bit */
	set	r4,r4,1<ou>		/* set ou bit */
	br.n	move
	 set	r4,r4,1<ob>		/* set ob bit */
FCMPS1niS2ni:
	set	r4,r4,1<eq>		/* set eq bit */
	set	r4,r4,1<le>		/* set le bit */
	br.n	move
	 set	r4,r4,1<ge>		/* set ge bit */
FCMPS1niS2f:
	set	r4,r4,1<ne>		/* set eq bit */
	set	r4,r4,1<le>		/* set le bit */
	bsr.n	_ASM_LABEL(zero)	/* see if any of the operands are zero */
	 set	r4,r4,1<lt>		/* set lt bit */
	bb0	s2zero,r12,FCMPS1niS2nz	/* branch if s2 is not zero */
	set	r4,r4,1<ou>		/* set ou bit */
	br.n	move
	 set	r4,r4,1<ob>		/* set ob bit */
FCMPS1niS2nz:
	bb1	sign,r7,move		/* return if s2 is negative */
	set	r4,r4,1<ou>		/* set ou bit */
	br.n	move
	 set	r4,r4,1<ob>		/* set ob bit */
FCMPS1f:
	bb1	sign,r5,FCMPS1nf	/* branch to negative S1f */
FCMPS1pf:
	bb1.n	sign,r7,FCMPS1pfS2ni	/* branch to negative S2i with S1pf */
	 set	r4,r4,1<ne>		/* set ne bit */
FCMPS1pfS2pi:
	set	r4,r4,1<le>		/* set le bit */
	set	r4,r4,1<lt>		/* set lt bit */
	bsr.n	_ASM_LABEL(zero)
	 set	r4,r4,1<ib>		/* set ib bit */
	bb0	s1zero,r12,FCMPS1pfS2pinozero
FCMPS1pfS2pizero:
	br.n	move
	 set	r4,r4,1<ob>		/* set ob bit */
FCMPS1pfS2pinozero:
	br.n	move
	 set	r4,r4,1<in>		/* set in bit */
FCMPS1pfS2ni:
	set	r4,r4,1<gt>		/* set gt bit */
	br.n	move
	 set	r4,r4,1<ge>		/* set ge bit */
FCMPS1nf:
	bb1.n	sign,r7,FCMPS1nfS2ni	/* branch to negative S2i with S1nf */
	 set	r4,r4,1<ne>		/* set ne bit */
	set	r4,r4,1<le>		/* set gt bit */
	set	r4,r4,1<lt>		/* set ge bit */
	bsr.n	_ASM_LABEL(zero)	/* see which of the operands are zero */
	 set	r4,r4,1<ob>		/* set ob bit */
	bb0	s1zero,r12,FCMPS1nfS2pinozero /* no ls and lo */
FCMPS1nfS2pizero:
	br.n	move
	 set	r4,r4,1<ib>		/* set ib bit */
FCMPS1nfS2pinozero:
	br.n	move
	 set	r4,r4,1<ou>		/* set ou bit */
FCMPS1nfS2ni:
	set	r4,r4,1<gt>		/* set gt bit */
	set	r4,r4,1<ge>		/* set ge bit */

move:
	br.n	inf_return
	 or	r6,r0,r4		/* transfer answer to r6 */
d1780 8
a1787 10
FMUL:
	bsr	_ASM_LABEL(zero)	/* see if any of the operands are zero */
	bb1	s1zero,r12,excpt	/* infinity X 0 causes an exception */
	bb1	s2zero,r12,excpt	/* infinity X 0 causes an exception */
	bb1	sign,r5,FMULS1neg	/* handle negative cases of S1 */
	bb0	sign,r7,poswrinf	/* + X + = + */
	br	negwrinf		/* + X - = - */
FMULS1neg:
	bb1	sign,r7,poswrinf	/* - X - = + */
	br	negwrinf		/* - X + = - */
d1790 2
a1791 2
/* Dividing infinity by infinity causes an exception, but dividing */
/* infinity by a finite yields a correctly signed infinity, and */
d1794 17
a1810 29
FDIV:
	bb1	s1inf,r12,FDIVS1inf	/* handle case of S1 being infinity */
	bb1	sign,r5,FDIVS1nf	/* handle cases of S1 being neg. non-inf. */
	bb1	sign,r7,FDIVS1pfS2mi	/* handle case of negative S2 */
FDIVS1pfS2pi:
	br	poswrzero		/* +f / +inf = +0 */
FDIVS1pfS2mi:
	br	negwrzero		/* +f / -inf = -0 */
FDIVS1nf:
	bb1	sign,r7,FDIVS1nfS2mi	/* handle case of negative S2 */
FDIVS1nfS2pi:
	br	negwrzero		/* -f / +inf = -0 */
FDIVS1nfS2mi:
	br	poswrzero		/* -f / -inf = +0 */
FDIVS1inf:
	bb1	s2inf,r12,excpt		/* inf / inf = exception */
	bb1	sign,r5,FDIVS1mi	/* handle cases of S1 being neg. inf. */
	bb1	sign,r7,FDIVS1piS2nf	/* handle case of negative S2 */
FDIVS1piS2pf:
	br	poswrinf		/* +inf / +f = +inf */
FDIVS1piS2nf:
	br	negwrinf		/* +inf / -f = -inf */
FDIVS1mi:
	bb1	sign,r7,FDIVS1miS2nf	/* handle case of negative S2 */
FDIVS1miS2pf:
	br	negwrinf		/* -inf / +f = -inf */
FDIVS1miS2nf:
	br	poswrinf		/* -inf / -f = +inf */

d1815 2
a1816 5
#if 0
FSQRT:
	bb0	sign,r7,poswrinf	/* write sqrt(inf) = inf */
	br	excpt			/* write sqrt(-inf) = NaN */
#endif
d1818 2
a1819 2
excpt:
	set	r2,r2,1<oper>
d1821 4
a1824 4
	bb0	oper,r3,nohandler	/* branch if no user handler */
	bsr	_handler		/* branch to interface with user handler */
	br	inf_return
nohandler:
d1826 5
a1830 5
	set	r5,r0,0<0>	/* write NaN into r5 */
	br.n	inf_return
	 set	r6,r0,0<0>	/* write NaN into r6, writing NaN''s into */
				/* both of these registers is quicker than */
				/* checking for single or double precision */
d1835 6
a1840 8
poswrinf:
	bb1	dsize,r9,poswrinfd	/* branch to write double precision inf. */
	br.n	inf_return
	 or.u	r6,r0,0x7f80		/* load r6 with single precision pos inf.	*/
poswrinfd:
	or.u	r5,r0,0x7ff0		/* load double precision pos inf. */
	br.n	inf_return
	 or	r6,r0,r0
d1845 6
a1850 8
negwrinf:
	bb1	dsize,r9,negwrinfd	/* branch to write double precision inf. */
	br.n	inf_return
	 or.u	r6,r0,0xff80		/* load r6 with single precision pos inf.	*/
negwrinfd:
	or.u	r5,r0,0xfff0		/* load double precision pos inf. */
	br.n	inf_return
	 or	r6,r0,r0
d1855 3
a1857 4
poswrzero:
	or	r5,r0,r0	/* write to both high word and low word now */
	br.n	inf_return	/* it does not matter that both are written */
	 or	r6,r0,r0
d1862 10
a1871 14
negwrzero:
	or	r6,r0,r0	/* clear low word */
	bb1	dsize,r9,negwrzerod /* branch to write double precision zero */
	br.n	inf_return
	 set	r6,r6,1<31>	/* set sign bit */
negwrzerod:
	or	r5,r0,r0	/* clear high word */
	br.n	inf_return
	 set	r5,r5,1<31>	/* set sign bit */

FP_inf_overflw:
	set	r2,r2,1<oper>
	set	r2,r2,1<overflow>
	set	r2,r2,1<inexact>
d1873 3
a1875 3
	bb0	oper,r3,nohandlero /* do not go to user handler routine */
	bsr	_handler	/* go to user handler routine */
	br	inf_return
d1878 4
a1881 2
nohandlero:
	bb0.n	sign,r7,inf_return /* if positive then return */
d1883 2
a1884 2
	 set	r6,r6,31<0>	/* set result to largest positive integer */
	or.c	r6,r0,r6	/* negate r6,giving largest negative int. */
d1886 1
a1886 5
inf_return:
	ld	r1,r31,0	/* load return address */
	jmp	r1

	data
d1896 4
d1901 1
a1901 5
/*
 * denorm
 */

/* Check to see if either S1 or S2 is a denormalized number. First */
d1903 1
a1903 1
/* the mantissa is not zero. If the number is denormalized, then set the */
d1906 29
a1934 35
ASLOCAL(denorm)
	st	r1,r31,0	/* save return address */
dnmcheckS1:
	extu	r10,r5,11<20>	/* extract exponent */
	bcnd	ne0,r10,dnmsetS2 /* S1 is not a denorm, so S2 must be */
	bb1.n	9,r9,dnmcheckS1d /* S1 is double precision */
	 mak	r10,r5,20<3>	/* mak field with only mantissa bits */
				/* into final result */
dnmcheckS1s:
	extu	r11,r6,3<29>	/* get three low bits of mantissa */
	or	r10,r10,r11	/* assemble all of the mantissa bits */
	bcnd	eq0,r10,dnmsetS2 /* S1 is not a denorm, so S2 must be */
	br	dnmsetS1	/* S1 is a denorm */

dnmcheckS1d:
	or	r10,r6,r10	/* or all of mantissa bits */
	bcnd	eq0,r10,dnmsetS2 /* S1 is not a denorm, so S2 must be */
dnmsetS1:
	set	r12,r12,1<1>	/* S1 is a denorm */

dnmcheckS2:
	extu	r10,r7,11<20>	/* extract exponent */
	bcnd	ne0,r10,S1form	/* S2 is not a denorm */
	bb1.n	7,r9,dnmcheckS2d /* S2 is double precision */
	 mak	r10,r7,20<3>	/* mak field with only mantissa bits */
dnmcheckS2s:
	extu	r11,r8,3<29>	/* get three low bits of mantissa */
	or	r10,r10,r11	/* assemble all of the mantissa bits */
	bcnd	eq0,r10,S1form	/* S2 is not a denorm */
	br	dnmsetS2	/* S1 is a denorm */
dnmcheckS2d:
	or	r10,r8,r10	/* or all or mantissa bits */
	bcnd	eq0,r10,S1form	/* S2 is not a denorm */
dnmsetS2:
	set	r12,r12,1<0>	/* S2 is a denorm */
d1939 1
a1939 1
/* back to single precision.	*/
d1941 19
a1959 21
S1form:
	bb1	9,r9,S2form	/* S1 is double precision, so do not */
				/* modify S1 into single format */
	mak	r11,r5,28<3>	/* over final exponent and mantissa */
				/* eliminating extra 3 bits of exponent */
	extu	r6,r6,3<29>	/* get low 3 bits of mantissa */
	or	r11,r6,r11	/* form complete mantissa and exponent */
	extu	r10,r5,1<31>	/* get the 31 bit */
	mak	r10,r10,1<31>	/* place 31 bit 10 correct position */
	or	r6,r10,r11	/* or 31, exponent, and all of mantissa */

S2form:
	bb1	7,r9,checkop	/* S2 is double precision, so do not */
				/* modify S2 into single format */
	mak	r11,r7,28<3>	/* over final exponent and mantissa */
				/* eliminating extra 3 bits of exponent */
	extu	r8,r8,3<29>	/* get low 3 bits of mantissa */
	or	r11,r8,r11	/* form complete mantissa and exponent */
	extu	r10,r7,1<31>	/* get the 31 bit */
	mak	r10,r10,1<31>	/* place 31 bit 10 correct position */
	or	r8,r10,r11	/* or 31, exponent, and all of mantissa */
d1965 19
a1983 22
checkop:
	extu	r10,r9,5<11>	/* extract opcode */
	cmp	r11,r10,0x05	/* compare to FADD */
	bb1	2,r11,FADD	/* operation is FADD */
	cmp	r11,r10,0x06	/* compare to FSUB */
	bb1	2,r11,FSUB	/* operation is FSUB */
	cmp	r11,r10,0x07	/* compare to FCMP */
	bb1	2,r11,FCMP	/* operation is FCMP */
	cmp	r11,r10,0x00	/* compare to FMUL */
	bb1	2,r11,FMUL	/* operation is FMUL */
	cmp	r11,r10,0x0e	/* compare to FDIV */
	bb1	2,r11,FDIV	/* operation is FDIV */
#if 0
	cmp	r11,r10,0x0f	/* compare to FSQRT */
	bb1	2,r11,FSQRT	/* operation is FSQRT */
#endif
	cmp	r11,r10,0x09	/* compare to INT */
	bb1	2,r11,INT	/* operation is INT */
	cmp	r11,r10,0x0a	/* compare to NINT */
	bb1	2,r11,NINT	/* operation is NINT */
	cmp	r11,r10,0x0b	/* compare to TRNC */
	bb1	2,r11,TRNC	/* operation is TRNC */
d1990 174
a2163 278
FADD:
	bb0	1,r12,FADDS2dnm	/* S1 is not denorm, so S2 must be */
	or	r5,r0,r0	/* set S1 to zero */
	or	r6,r0,r0
FADDS2chk:
	bb0	0,r12,FADDcalc	/* S2 is not a denorm */
FADDS2dnm:
	or	r7,r0,r0	/* set S2 to zero */
	or	r8,r0,r0
FADDcalc:
	bb1	5,r9,FADDdD	/* branch for double precision destination */
FADDsD:
	bb1	9,r9,FADDsDdS1	/* branch for double precision S1 */
FADDsDsS1:
	bb1	7,r9,FADDsDsS1dS2 /* branch for double precision S2 */
FADDsDsS1sS2:
	br.n	return
	 fadd.sss r6,r6,r8	/* add the two sources and place result 10 S1 */
FADDsDsS1dS2:
	br.n	return
	 fadd.ssd r6,r6,r7	/* add the two sources and place result 10 S1 */
FADDsDdS1:
	bb1	7,r9,FADDsDdS1dS2 /* branch for double precision S2 */
FADDsDdS1sS2:
	br.n	return
	 fadd.sds r6,r5,r8	/* add the two sources and place result 10 S1 */
FADDsDdS1dS2:
	br.n	return
	 fadd.sdd r6,r5,r7	/* add the two sources and place result 10 S1 */
FADDdD:
	bb1	9,r9,FADDdDdS1	/* branch for double precision S1 */
FADDdDsS1:
	bb1	7,r9,FADDdDsS1dS2 /* branch for double precision S2 */
FADDdDsS1sS2:
	br.n	return
	 fadd.dss r5,r6,r8	/* add the two sources and place result 10 S1 */
FADDdDsS1dS2:
	br.n	return
	 fadd.dsd r5,r6,r7	/* add the two sources and place result 10 S1 */
FADDdDdS1:
	bb1	7,r9,FADDdDdS1dS2 /* branch for double precision S2 */
FADDdDdS1sS2:
	br.n	return
	 fadd.dds r5,r5,r8	/* add the two sources and place result 10 S1 */
FADDdDdS1dS2:
	br.n	return
	 fadd.ddd r5,r5,r7	/* add the two sources and place result 10 S1 */

FSUB:
	bb0	1,r12,FSUBS2dnm	/* S1 is not denorm, so S2 must be */
	or	r5,r0,r0	/* set S1 to zero */
	or	r6,r0,r0
FSUBS2chk:
	bb0	0,r12,FSUBcalc	/* S2 is not a denorm */
FSUBS2dnm:
	or	r7,r0,r0	/* set S2 to zero */
	or	r8,r0,r0
FSUBcalc:
	bb1	5,r9,FSUBdD	/* branch for double precision destination */
FSUBsD:
	bb1	9,r9,FSUBsDdS1	/* branch for double precision S1 */
FSUBsDsS1:
	bb1	7,r9,FSUBsDsS1dS2 /* branch for double precision S2 */
FSUBsDsS1sS2:
	br.n	return
	 fsub.sss r6,r6,r8	/* add the two sources and place result 10 S1 */
FSUBsDsS1dS2:
	br.n	return
	 fsub.ssd r6,r6,r7	/* add the two sources and place result 10 S1 */
FSUBsDdS1:
	bb1	7,r9,FSUBsDdS1dS2 /* branch for double precision S2 */
FSUBsDdS1sS2:
	br.n	return
	 fsub.sds r6,r5,r8	/* add the two sources and place result 10 S1 */
FSUBsDdS1dS2:
	br.n	return
	 fsub.sdd r6,r5,r7	/* add the two sources and place result 10 S1 */
FSUBdD:
	bb1	9,r9,FSUBdDdS1	/* branch for double precision S1 */
FSUBdDsS1:
	bb1	7,r9,FSUBdDsS1dS2 /* branch for double precision S2 */
FSUBdDsS1sS2:
	br.n	return
	 fsub.dss r5,r6,r8	/* add the two sources and place result 10 S1 */
FSUBdDsS1dS2:
	br.n	return
	 fsub.dsd r5,r6,r7	/* add the two sources and place result 10 S1 */
FSUBdDdS1:
	bb1	7,r9,FSUBdDdS1dS2 /* branch for double precision S2 */
FSUBdDdS1sS2:
	br.n	return
	 fsub.dds r5,r5,r8	/* add the two sources and place result 10 S1 */
FSUBdDdS1dS2:
	br.n	return
	 fsub.ddd r5,r5,r7	/* add the two sources and place result 10 S1 */

FCMP:
	bb0	1,r12,FCMPS2dnm	/* S1 is not denorm, so S2 must be */
	or	r5,r0,r0	/* set S1 to zero */
	or	r6,r0,r0
FCMPS2chk:
	bb0	0,r12,FCMPcalc	/* S2 is not a denorm */
FCMPS2dnm:
	or	r7,r0,r0	/* set S2 to zero */
	or	r8,r0,r0
FCMPcalc:
	bb1	9,r9,FCMPdS1	/* branch for double precision S1 */
FCMPsS1:
	bb1	7,r9,FCMPsS1dS2	/* branch for double precision S2 */
FCMPsS1sS2:
	br.n	return
	 fcmp.sss r6,r6,r8	/* add the two sources and place result 10 S1 */
FCMPsS1dS2:
	br.n	return
	 fcmp.ssd r6,r6,r7	/* add the two sources and place result 10 S1 */
FCMPdS1:
	bb1	7,r9,FCMPdS1dS2	/* branch for double precision S2 */
FCMPdS1sS2:
	br.n	return
	 fcmp.sds r6,r5,r8	/* add the two sources and place result 10 S1 */
FCMPdS1dS2:
	br.n	return
	 fcmp.sdd r6,r5,r7	/* add the two sources and place result 10 S1 */

FMUL:
	bb0	1,r12,FMULS2dnm	/* S1 is not denorm, so S2 must be */
	or	r5,r0,r0	/* set S1 to zero */
	or	r6,r0,r0
FMULS2chk:
	bb0	0,r12,FMULcalc	/* S2 is not a denorm */
FMULS2dnm:
	or	r7,r0,r0	/* set S2 to zero */
	or	r8,r0,r0
FMULcalc:
	bb1	5,r9,FMULdD	/* branch for double precision destination */
FMULsD:
	bb1	9,r9,FMULsDdS1	/* branch for double precision S1 */
FMULsDsS1:
	bb1	7,r9,FMULsDsS1dS2 /* branch for double precision S2 */
FMULsDsS1sS2:
	br.n	return
	 fmul.sss r6,r6,r8	/* add the two sources and place result 10 S1 */
FMULsDsS1dS2:
	br.n	return
	 fmul.ssd r6,r6,r7	/* add the two sources and place result 10 S1 */
FMULsDdS1:
	bb1	7,r9,FMULsDdS1dS2 /* branch for double precision S2 */
FMULsDdS1sS2:
	br.n	return
	 fmul.sds r6,r5,r8	/* add the two sources and place result 10 S1 */
FMULsDdS1dS2:
	br.n	return
	 fmul.sdd r6,r5,r7	/* add the two sources and place result 10 S1 */
FMULdD:
	bb1	9,r9,FMULdDdS1	/* branch for double precision S1 */
FMULdDsS1:
	bb1	7,r9,FMULdDsS1dS2 /* branch for double precision S2 */
FMULdDsS1sS2:
	br.n	return
	 fmul.dss r5,r6,r8	/* add the two sources and place result 10 S1 */
FMULdDsS1dS2:
	br.n	return
	 fmul.dsd r5,r6,r7	/* add the two sources and place result 10 S1 */
FMULdDdS1:
	bb1	7,r9,FMULdDdS1dS2 /* branch for double precision S2 */
FMULdDdS1sS2:
	br.n	return
	 fmul.dds r5,r5,r8	/* add the two sources and place result 10 S1 */
FMULdDdS1dS2:
	br.n	return
	 fmul.ddd r5,r5,r7	/* add the two sources and place result 10 S1 */

FDIV:
	bb0	1,r12,FDIVS2dnm	/* S1 is not denorm, so S2 must be */
	or	r5,r0,r0	/* set S1 to zero */
	or	r6,r0,r0
FDIVS2chk:
	bb0	0,r12,FDIVcalc	/* S2 is not a denorm */
FDIVS2dnm:
	or	r7,r0,r0	/* set S2 to zero */
	or	r8,r0,r0
FDIVcalc:
	bb1	5,r9,FDIVdD	/* branch for double precision destination */
FDIVsD:
	bb1	9,r9,FDIVsDdS1	/* branch for double precision S1 */
FDIVsDsS1:
	bb1	7,r9,FDIVsDsS1dS2 /* branch for double precision S2 */
FDIVsDsS1sS2:
	fdiv.sss r6,r6,r8	/* add the two sources and place result 10 S1 */
	br	return
FDIVsDsS1dS2:
	fdiv.ssd r6,r6,r7	/* add the two sources and place result 10 S1 */
	br	return
FDIVsDdS1:
	bb1	7,r9,FDIVsDdS1dS2 /* branch for double precision S2 */
FDIVsDdS1sS2:
	fdiv.sds r6,r5,r8	/* add the two sources and place result 10 S1 */
	br	return
FDIVsDdS1dS2:
	fdiv.sdd r6,r5,r7	/* add the two sources and place result 10 S1 */
	br	return
FDIVdD:
	bb1	9,r9,FDIVdDdS1	/* branch for double precision S1 */
FDIVdDsS1:
	bb1	7,r9,FDIVdDsS1dS2 /* branch for double precision S2 */
FDIVdDsS1sS2:
	fdiv.dss r5,r6,r8	/* add the two sources and place result 10 S1 */
	br	return
FDIVdDsS1dS2:
	fdiv.dsd r5,r6,r7	/* add the two sources and place result 10 S1 */
	br	return
FDIVdDdS1:
	bb1	7,r9,FDIVdDdS1dS2 /* branch for double precision S2 */
FDIVdDdS1sS2:
	fdiv.dds r5,r5,r8	/* add the two sources and place result 10 S1 */
	br	return
FDIVdDdS1dS2:
	fdiv.ddd r5,r5,r7	/* add the two sources and place result 10 S1 */
	br	return

#if 0
FSQRT:
	or	r7,r0,r0	/* set S2 to zero */
	or	r8,r0,r0
FSQRTcalc:
	bb1	5,r9,FSQRTdD	/* branch for double precision destination */
FSQRTsD:
	bb1	7,r9,FSQRTsDdS2 /* branch for double precision S2 */
FSQRTsDsS2:
	br.n	return
	 fsqrt.ss r6,r8		/* add the two sources and place result 10 S1 */
FSQRTsDdS2:
	br.n	return
	 fsqrt.sd r6,r7		/* add the two sources and place result 10 S1 */
FSQRTdD:
	bb1	7,r9,FSQRTdDdS2	/* branch for double precision S2 */
FSQRTdDsS2:
	br.n	return
	 fsqrt.ds r5,r8		/* add the two sources and place result 10 S1 */
FSQRTdDdS2:
	br.n	return
	 fsqrt.dd r5,r7		/* add the two sources and place result 10 S1 */
#endif

INT:
	or	r7,r0,r0	/* set S2 to zero */
	or	r8,r0,r0
INTcalc:
	bb1	7,r9,INTdS2	/* branch for double precision S2 */
INTsS2:
	br.n	return
	 int.ss r6,r8		/* add the two sources and place result 10 S1 */
INTdS2:
	br.n	return
	 int.sd r6,r7		/* add the two sources and place result 10 S1 */

NINT:
	or	r7,r0,r0	/* set S2 to zero */
	or	r8,r0,r0
NINTcalc:
	bb1	7,r9,NINTdS2	/* branch for double precision S2 */
NINTsS2:
	br.n	return
	 nint.ss r6,r8		/* add the two sources and place result 10 S1 */
NINTdS2:
	br.n	return
	 nint.sd r6,r7		/* add the two sources and place result 10 S1 */

TRNC:
	or	r7,r0,r0	/* set S2 to zero */
	or	r8,r0,r0
TRNCcalc:
	bb1	7,r9,TRNCdS2	/* branch for double precision S2 */
TRNCsS2:
	br.n	return
	 trnc.ss r6,r8		/* add the two sources and place result 10 S1 */
TRNCdS2:
	trnc.sd r6,r7		/* add the two sources and place result 10 S1 */
d2168 2
a2169 3
return:
	ld	r1,r31,0	/* load return address */
	jmp	r1
d2171 1
a2171 1
	data
d2177 68
a2244 62
ASLOCAL(zero)
	bb0	s1inf,r12,S1noinf	/* see if S1 is zero */
	bb0	s2inf,r12,S2noinf	/* see if S2 is zero */
	jmp	r1

/* See if S1 is zero. Whether or not S1 is a zero, being in this routine */
/* implies that S2 is infinity, so return to subroutine infinity after */
/* completing this code. Set the s1zero flag in r12 if S1 is zero. */

S1noinf:
	bb1	s1size,r9,S1noinfd	/* work with double precision operand */
S1noinfs:
	or	r10,r0,r5		/* load high word into r10 */
	clr	r10,r10,1<sign>		/* clear the sign bit */
	extu	r11,r6,3<29>		/* extract lower 3 bits of mantissa */
	or	r10,r10,r11		/* or these 3 bits with high word */
	bcnd	ne0,r10,operation	/* do not set zero flag */
	jmp.n	r1			/* since this operand was not */
					/* infinity, S2 must have been, */
					/* so return */
	 set	r12,r12,1<s1zero>	/* set zeroflag */
S1noinfd:
	clr	r10,r5,1<sign>		/* clear the sign bit */
	or	r10,r6,r10		/* or high and low word */
	bcnd	ne0,r10,operation	/* do not set zero flag */
	jmp.n	r1			/* since this operand was not */
					/* infinity, S2 must have been, */
					/* so return */
	 set	r12,r12,1<s1zero>	/* set zeroflag */


/* Check S2 for zero. If it is zero, then set the s2zero flag in r12. */

S2noinf:
	bb1	s2size,r9,S2noinfd	/* work with double precision operand */
S2noinfs:
	or	r10,r0,r7		/* load high word into r10 */
	clr	r10,r10,1<sign>		/* clear the sign bit */
	extu	r11,r8,3<29>		/* extract lower 3 bits of mantissa */
	or	r10,r10,r11		/* or these 3 bits with high word */
	bcnd	ne0,r10,operation	/* do not set zero flag */
	jmp.n	r1			/* since this operand was not */
					/* infinity, S1 must have been, */
					/* so return */
	 set	r12,r12,1<s2zero>	/* set zeroflag */
S2noinfd:
	clr	r10,r7,1<sign>		/* clear the sign bit */
	or	r10,r8,r10		/* or high and low word */
	bcnd	ne0,r10,operation	/* do not set zero flag */
	set	r12,r12,1<s2zero>	/* set zeroflag */
					/* since this operand was not */
					/* infinity, S1 must have been, */
					/* so return */
operation:
	jmp	r1

ASENTRY(Xfp_imprecise)
/* input: r3 is the exception frame */
	or	r29, r3, r0		/* r29 is now the E.F. */
	subu	r31, r31, 40
	st	r1,  r31, 32
	st	r29, r31, 36
d2246 1
a2246 8
	ld	r2 , r29, EF_FPSR  * 4
	ld	r3 , r29, EF_FPCR  * 4
	ld	r4 , r29, EF_FPECR * 4
	ld	r10, r29, EF_FPRH  * 4
	ld	r11, r29, EF_FPRL  * 4
	ld	r12, r29, EF_FPIT  * 4

/* Load into r1 the return address for the exception handlers. Looking */
d2249 2
a2250 2
	or.u	r1,r0,hi16(fpui_wrapup)/* load return address of functions */
	or	r1,r1,lo16(fpui_wrapup)
d2252 5
a2256 7
	bb0	2,r4,2f			/* branch to FPunderflow if bit set */
	br	_ASM_LABEL(FPunderflow)
2:
	bb0	1,r4,3f			/* branch to FPoverflow if bit set */
	br	_ASM_LABEL(FPoverflow)
3:
	/* XXX handle inexact!!! */
d2258 2
a2259 2
	br	_handler		/* branch to handler since bit will */
					/* be set for inexact */
d2261 13
d2276 5
a2280 3
	tb1	0,r0,0		/* make sure all floating point operations */
				/* have finished */
	ldcr	r4, cr1	/* load the PSR */
d2282 3
a2284 1
	set	r4, r4, 1<PSR_FPU_DISABLE_BIT>
a2285 2
	set	r4, r4, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r4, cr1
d2290 1
a2290 4
	fstcr	r2, FPSR	/* write revised value of FPSR */
	fstcr	r3, FPCR	/* write revised value of FPCR */

	/* write back the results */
d2299 1
@


1.6.4.7
log
@Merge with the trunk
@
text
@d1 1
a1 1
/* $OpenBSD: m88100_fp.S,v 1.6.4.6 2004/02/19 10:49:07 niklas Exp $	*/
@


1.5
log
@Added kernel support for user debugging.  Fixed file ID's
@
text
@d1 1
a1 1
/* $OpenBSD: m88100_fp.S,v 1.28 1995/04/19 22:37:27 smurph Exp $	*/
d39 1
d128 2
a129 2
	global _Xfp_precise
_Xfp_precise:
d2307 1
@


1.4
log
@mvme88k will not make release, but just as well make the source as close as
possible.
@
text
@d1 1
@


1.3
log
@Cleanup after import. This also seems to bring up the current version.
@
text
@d34 1
@


1.2
log
@This is a remove to get rid of the old mvme88k port which was incomplete
to replace it with a working version. The kernel compiles and works
at least.  The new version will be imported shortly.
@
text
@a25 2
 *
 * HISTORY
d30 1
a30 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
d32 1
a32 2
#ifndef __LUNA_SUB_H__
#define __LUNA_SUB_H__
d34 2
a35 10
#ifndef NDEBUG	/* no debugging */
#define NDEBUG
#endif

#ifdef NDEBUG
#  define _LABEL(NAME)	NAME:
#else
#  define _LABEL(NAME)	NAME: global NAME
#endif
#  define LABEL(NAME)	NAME: global NAME
d112 1
a112 57
#define FRAMESIZE 200
#define SWITCHUSER 128
#if 0
#define XR1 4
#define XR2 8
#define XR3 12
#define XR4 16
#define XR5 20
#define XR6 24
#define XR7 28
#define XR8 32
#define XR9 36
#define XR10 40
#define XR11 44
#define XR12 48
#define XR13 52
#define XR14 56
#define XR15 60
#define XR16 64
#define XR17 68
#define XR18 72
#define XR19 76
#define XR20 80
#define XR21 84
#define XR22 88
#define XR23 92
#define XR24 96
#define XR25 100
#define XR26 104
#define XR27 108
#define XR28 112
#define XR29 116
#define XR30 120
#define XR31 124
#define XFPSR 128
#define XFPCR 132
#define XFPECR 136
#define XS1HI 140
#define XS1LO 144
#define XS2HI 148
#define XS2LO 152
#define XPCR 156
#define XMANTHI 140
#define XMANTLO 144
#define XIMPCR 148
#define XSPSR 160
#define XSSB 164
#define XSNIP 168
#define XSFIP 172
#define XRETADDR 176
#define XHANDRETADDR 180
#define XHANDFPECR 184
#define XHANDPR 188
#define XHANDIMP 192
#endif
#define STKSTATE 196
#define handtrap 134
a119 20
#define hiddens 23
#define hiddend 20
#define NUMFRAME 10
#define SIGILL 4
#define SIGFPEPR 8
#define u_sfu1full 0x4
#define u_xcpt 0x8
#define USIZE 0x0ff0
#endif
;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;

#ifndef LOCORE
#define LOCORE

#ifndef ASSEMBLER /* predefined by ascpp, at least */
#define ASSEMBLER
#endif
a120 6
#include <machine/trap.h>
#include "assym.s"
#ifndef __LUNA_SUB_H__
#include "luna_sub.h"
#endif
#endif
d124 1
a124 1
	align 4
d127 1
a127 1
	or	r29, r3, r0     ; r29 is now the E.F.
d142 5
a146 5
	;Load into r1 the return address for the 0 handlers.  Looking
	;at FPECR, branch to the appropriate 0 handler.  However,
	;if none of the 0 bits are enabled, then a floating point
	;instruction was issued with the floating point unit disabled.  This
	;will cause an unimplemented opcode 0.
d148 1
a148 1
	or.u	r1,r0,hi16(wrapup) ;load return address of function 
d150 1
a150 1
2:   	bb0	6,r4, 3f   	;branch to FPunimp if bit set
d152 1
a152 1
3:	bb0	7,r4, 4f 	;branch to FPintover if bit set
d154 3
a156 3
4: ;	bb0	5,r4, 5f 	;branch to FPpriviol if bit set
   ;	br	_FPpriviol
5: 	bb0	4,r4, 6f 	;branch to FPresoper if bit set
d158 1
a158 1
6:   	bb0	3,r4, 7f 	;branch to FPdivzero if bit set
d175 5
a179 5
	;To write back the results to the user registers, disable exceptions
	;and the floating point unit.  Write FPSR and FPCR and load the SNIP
	;and SFIP.
	;r5 will contain the upper word of the result
	;r6 will contain the lower word of the result
d182 4
a185 4
	tb1	0,r0,0          ;make sure all floating point operations
	;have finished
	ldcr	r10, cr1        ;load the PSR
	or	r10, r10, 0x2   ;disable interrupts
d189 1
a189 1
	or	r10, r10, 0x8 ;set SFU 1 disable bit, disable SFU 1
d196 2
a197 2
	fstcr	r2, fpsr	;write revised value of FPSR
	fstcr	r3, fpcr	;write revised value of FPCR
d199 1
a199 1
	;result writeback routine
d201 2
a202 2
	extu   r2, r9, 5<0>       ;get 5 bits of destination register
	bb0    5, r9, writesingle ;branch if destination is single
d204 5
a208 5
;writedouble here
	st     r5, r3 [r2]       ;write high word
	add    r2, r2, 1          ;for double, the low word is the 
	;unspecified register
	clr    r2, r2, 27<5>      ;perform equivalent of mod 32
d210 1
a210 1
	st     r6, r3 [r2]       ;write low word into memory
a213 4
;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
a214 3
#ifndef __LUNA_SUB_H__
#include "luna_sub.h"
#endif
d216 1
d220 2
a221 2
;Check if the numerator is zero.  If the numerator is zero, then handle
;this instruction as you would a 0/0 invalid operation.
d224 2
a225 2
             st    r1,r31,0  ;save return address
	     bb1   s1size,r9,1f  ;branch if numerator double
d227 6
a232 6
  	     clr   r10,r5,1<sign>   ;clear sign bit
             extu  r11,r6,3<29>     ;grab upper bits of lower word
             or    r10,r10,r11      ;combine ones of mantissa
             bcnd  eq0,r10,resoper  ;numerator is zero, handle reserved
                                    ;operand 
             br    setbit           ;set divzero bit
d235 7
a241 7
	     clr   r10,r5,1<sign>   ;clear sign bit
             or    r10,r10,r6       ;or high and low words
             bcnd  ne0,r10,setbit   ;set divzero bit

;The numerator is zero, so handle the invalid operation by setting the
;invalid operation bit and branching to the user handler if there is one
;or writing a quiet NaN to the destination.
d244 1
a244 1
             set   r2,r2,1<oper>    ;set bit in FPSR
d246 4
a249 4
	     bb0   oper,r3,noreshand ;branch to execute default handling for
                                    ;reserved operands
             bsr   _handler         ;branch to user handler
             br    FP_div_return           ;return from function
d253 10
a262 10
 	     set   r5,r0,0<0>      ;put a NaN in high word
             set   r6,r0,0<0>      ;put a NaN in low word
             br  FP_div_return            ;return from subroutine
                                   ;writing to a word which may be ignored
                                   ;is just as quick as checking the precision
                                   ;of the destination

;The operation is divide by zero, so set the divide by zero bit in the
;FPSR.  If the user handler is set, then go to the user handler, else
;go to the default mode.
d266 4
a269 4
             set   r2,r2,1<divzero> ;set bit in FPSR
             bb0   divzero,r3,default ;go to default routine if no handler
             bsr   _handler         ;execute handler routine
             br    FP_div_return           ;return from subroutine
d273 2
a274 2
;Considering the sign of the numerator and zero, write a correctly
;signed infinity of the proper precision into the destination.
d277 1
a277 1
	     bb1   dsize,r9,FPzero_double  ;branch to handle double result
d279 5
a283 5
   	     clr   r10,r5,31<0>     ;clear all of S1HI except sign bit
             xor   r10,r7,r10       ;xor the sign bits of the operands
             or.u  r6,r0,0x7f80     ;load single precision infinity
             br.n  FP_div_return           ;return from subroutine
             or    r6,r6,r10        ;load correctly signed infinity
d286 5
a290 5
             clr   r10,r5,31<0>     ;clear all of S1HI except sign bit
             xor   r10,r7,r10       ;xor the sign bits of the operands
             or.u  r5,r0,0x7ff0     ;load double precision infinity
             or    r5,r5,r10        ;load correctly signed infinity
             or    r6,r0,r0         ;clear lower word of double
d293 2
a294 6
	     ld    r1,r31,0  ;load return address
             jmp   r1               ;return from subroutine
;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
a295 4
#ifndef __LUNA_SUB_H__
#include "luna_sub.h"
#endif
	text
d298 5
a302 4
;Both NINT and TRNC require a certain rounding mode, so check which
;instruction caused the integer conversion overflow.  Use a substitute
;FPCR in r1, and modify the rounding mode if the instruction is NINT or TRNC.
	
d304 110
a413 110
	extu   r10,r9,5<11>         ;extract opcode
	cmp    r11,r10,INTop        ;see if instruction is INT
	st     r1,r31,0      ;save return address
	bb1.n  eq,r11,checksize     ;instruction is INT, do not modify
	;rounding mode
	or     r1,r0,r3             ;load FPCR into r1
	cmp    r11,r10,NINTop       ;see if instruction is NINT
	bb1    eq,r11,NINT          ;instruction is NINT
	
TRNC:   clr    r1,r1,2<rndlo>          ;clear rounding mode bits,
					;instruction is TRNC
	br.n   checksize            ;branch to check size
	set    r1,r1,1<rndlo>          ;make rounding mode round towards zero
	
NINT:   clr    r1,r1,2<rndlo>          ;make rounding mode round to nearest
	
	
;See whether the source is single or double precision.
	
checksize:   bb1    s2size,r9,checkdoub  ;S2 is double, branch to see if there
;is a false alarm
	
	
;An integer has more bits than the mantissa of a single precision floating
;point number, so to check for false alarms (i.e. valid conversion), simply
;check the exponents.  False alarms are detected for 2**30 to (2**30) - 1 and
;-2**30 to -2**31.  Only seven bits need to be looked at since an exception
;will not occur for the other half of the numbering system.
;To speed up the processing, first check to see if the exponent is 32 or
;greater.

;This code was originally written for the exponent in the control
;register to have the most significant bit (8 - single, 11 - double) 
;flipped and sign extended.  For precise exceptions, however, the most
;significant bit is only sign extended.  Therefore, the code was chopped
;up so that it would work for positive values of real exponent which were
;only sign extended.
	
checksing:   extu   r10,r7,7<20>         ;internal representation for single
;precision is IEEE 8 bits sign extended
;to 11 bits; for real exp. = 30, the
;above instruction gives a result exp.
;that has the MSB flipped and sign
;extended like in the IMPCR
	cmp    r11,r10,31           ;compare to 32,but exp. off by 1
;these 2 instructions to speed up valid
;execution of valid cases
	bb1    ge,r11,overflw       ;valid case, perform overflow routine
	bb1    sign,r7,checksingn   ;source operand is negative
	
;If the number is positve and the exponent is greater than 30, than it is
	;overflow.
	
checksingp:  cmp    r10,r10,29           ;compare to 30, but exp. off by 1
	bb1    gt,r10,overflw       ;no false alarm, its overflow
	br     conversionsp         ;finish single precision conversion
	
;If the number is negative, and the exponent is 30, or 31 with a mantissa
;of 0, then it is a false alarm.
	
checksingn:  cmp    r11,r10,30           ;compare to 31,but exp. off by 1
	bb1    lt,r11,conversionsn  ;exp. less than 31, so convert
	extu   r10,r8,3<29>         ;get upper three bits of lower mantissa
	mak    r12,r7,20<3>         ;get upper 20 bits of mantissa
	or     r10,r10,r12          ;form complete mantissa
	bcnd   eq0,r10,conversionsn ;complete conversion if mantissa is 0
	br     overflw              ;no false alarm, its overflow
	
	
;False alarms are detected for 2**30 to (2**30) - 1 and
;-2**30 to -2**31.  Only seven bits need to be looked at since an exception
;will not occur for the other half of the numbering system.
;To speed up the processing, first check to see if the exponent is 32 or
;greater.  Since there are more mantissa bits than integer bits, rounding
;could cause overflow.  (2**31) - 1 needs to be checked so that it does
;not round to 2**31, and -2**31 needs to be checked in case it rounds to
;-((2**31) + 1).
	
checkdoub:   extu   r10,r7,10<20>        ;internal representation for double
;precision is the same IEEE 11 bits 
;for real exp. = 30, the
;above instruction gives a result exp.
;that has the MSB flipped and sign
;extended like in the IMPCR
	cmp    r11,r10,31           ;compare to 32,but exp. off by 1
;these 2 instructions to speed up valid
;execution of valid cases
	bb1    ge,r11,overflw       ;valid case, perform overflow routine
	bb1    sign,r7,checkdoubn   ;source operand is negative
	
;If the exponent is not 31, then the floating point number will be rounded
;before the conversion is done.  A branch table is set up with bits 4 and 3
;being the rounding mode, and bits 2, 1, and 0 are the guard, round, and 
;sticky bits.
	
checkdoubp:  cmp    r11,r10,30           ;compare to 31, but exponent off by 1
	bb1    eq,r11,overflw       ;no false alarm, its overflow
	extu   r12,r8,1<22>         ;get LSB for integer with exp. = 30
	mak    r12,r12,1<2>         ;start to set up field for branch table
	extu   r11,r8,1<21>         ;get guard bit
	mak    r11,r11,1<1>         ;set up field for branch table
	or     r12,r11,r12          ;set up field for branch table
	extu   r11,r8,21<0>         ;get bits for sticky bit
	bcnd   eq0,r11,nostickyp    ;do not set sticky
	set    r12,r12,1<0>         ;set sticky bit
nostickyp:   rot    r11,r1,0<rndlo>      ;shift rounding mode to 2 LSB''s
	mak    r11,r11,2<3>         ;set up field, clear other bits
	or     r12,r11,r12          ;set up field for branch table
	lda    r12,r0[r12]          ;scale r12
	or.u   r12,r12,hi16(ptable) ;load pointer into table
d415 1
a415 1
	jmp    r12                  ;jump into branch table
d450 113
a562 113
;Add one to the bit of the mantissa which corresponds to the LSB of an
;integer.  If the mantissa overflows, then there is a valid integer
;overflow conversion; otherwise, the mantissa can be converted to the integer.
	
paddone:     or     r10,r0,r0           ;clear r10
	set    r10,r10,1<22>       ;set LSB bit to 1 for adding
	addu.co r8,r8,r10          ;add the 1 obtained from rounding
	clr    r11,r7,12<20>       ;clear exponent and sign
	addu.ci r11,r0,r11         ;add carry
	bb1    20,r11,overflw      ;overflow to 2**31, abort the rest
	br.n   conversiondp        ;since the exp. was 30, and the exp.
	;did not round up to 31, the largest
	;number that S2 could become is 2**31-1
	or     r7,r0,r11           ;store r11 into r7 for conversion
	
;Now check for negative double precision sources.  If the exponent is 30,
;then convert the false alarm.  If the exponent is 31, then check the mantissa
;bits which correspond to integer bits.  If any of them are a one, then there
;is overflow.  If they are zero, then check the guard, round, and sticky bits.
;Round toward zero and positive will not cause a roundup, but round toward
;nearest and negative may, so perform those roundings.  If there is no overflow,
	;then convert and return from subroutine.
	
checkdoubn:  cmp    r11,r10,29           ;compare to 30, but exp. off by 1
	bb1    eq,r11,conversiondn  ;false alarm if exp. = 30
	extu   r10,r8,11<21>        ;check upper bits of lower mantissa
	bcnd   ne0,r10,overflw      ;one of the bits is a 1, so overflow
	extu   r10,r7,20<0>         ;check upper bits of upper mantissa
	bcnd   ne0,r10,overflw      ;one of the bits is a 1, so overflow
	bb0    rndlo,r1,possround      ;rounding mode is either round near or
	;round negative, which may cause a
	;round
	br.n   FPintov_return               ;round positive, which will not cause a
	;round
	set    r6,r0,1<sign>        ;rounding mode is either round zero or
possround:   extu   r12,r8,1<20>         ;get guard bit
	extu   r11,r8,20<0>         ;get bits for sticky bit
	bcnd.n eq0,r11,nostickyn    ;do not set sticky
	mak    r12,r12,1<1>         ;set up field for branch table
	set    r12,r12,1<0>         ;set sticky bit
nostickyn:   bb1    rndhi,r1,negative    ;rounding mode is negative
nearest:     cmp    r12,r12,3            ;are both guard and sticky set
	bb1    eq,r12,overflw       ;both guard and sticky are set,
	;so signal overflow
	or     r6,r0,r0             ;clear destination register r6
	br.n   FPintov_return               ;return from subroutine
	set    r6,r6,1<sign>        ;set the sign bit and take care of
	;this special case
negative:    bcnd   ne0,r12,overflw      ;-2**31 will be rounded to -(2**31+1),
	;so signal overflow
	or     r6,r0,r0             ;clear destination register r6
	br.n   FPintov_return               ;return from subroutine
	set    r6,r6,1<sign>        ;set the sign bit and take care of
	;this special case
	
	;since the exp. was 30, and there was
	;no round-up, the largest number that
	;S2 could have been was 2**31 - 1
	
	
	;Convert the single precision positive floating point number.
	
conversionsp: extu  r6,r8,3<29>         ;extract lower bits of integer
	mak   r6,r6,3<7>           ;shift left to correct place in integer
	mak   r10,r7,20<10>        ;shift left upper bits of integer
	or    r6,r6,r10            ;form most of integer
	br.n  FPintov_return               ;return from subroutine
	set   r6,r6,1<30>          ;set hidden one
	
	
	;Convert the single precision negative floating point number.
	
conversionsn: bb1   eq,r11,exp31s       ;use old r11 to see if exp. is 31
	extu  r6,r8,3<29>          ;extract lower bits of mantissa
	mak   r6,r6,3<7>           ;shift left to correct place in integer
	mak   r10,r7,20<10>        ;shift left upper bits of integer
	or    r6,r6,r10            ;form most of integer
	set   r6,r6,1<30>          ;set hidden one
	or.c  r6,r0,r6             ;negate result
	br.n  FPintov_return               ;return from subroutine
	addu  r6,r6,1              ;add 1 to get 2''s complement
exp31s:      or    r6,r0,r0             ;clear r6
	br.n  FPintov_return               ;return from subroutine
	set   r6,r6,1<sign>        ;set sign bit
	
	
	;Convert the double precision positive floating point number.
	
conversiondp: extu r6,r8,10<22>         ;extract lower bits of integer
	mak   r10,r7,20<10>        ;shift left upper bits of integer
	or    r6,r6,r10            ;form most of integer
	br.n  FPintov_return               ;return from subroutine
	set   r6,r6,1<30>          ;set hidden one
	
	
	;Convert the double precision negative floating point number.  The number,
	;whose exponent is 30, must be rounded before converting.  Bits 4 and 3 are
	;the rounding mode, and bits 2, 1, and 0 are the guard, round, and sticky
	;bits for the branch table.
	
conversiondn: extu   r12,r8,1<22>       ;get LSB for integer with exp. = 30
	mak    r12,r12,1<2>        ;start to set up field for branch table
	extu   r11,r8,1<21>        ;get guard bit
	mak    r11,r11,1<1>        ;set up field for branch table
	or     r12,r11,r12         ;set up field for branch table
	extu   r11,r8,21<0>        ;get bits for sticky bit
	bcnd   eq0,r11,nostkyn     ;do not set sticky
	set    r12,r12,1<0>        ;set sticky bit
nostkyn:     rot    r11,r1,0<rndlo>     ;shift rounding mode to 2 LSB''s
	mak    r11,r11,2<3>        ;set up field, clear other bits
	or     r12,r11,r12         ;set up field for branch table
	lda    r12,r0[r12]         ;scale r12
	or.u   r12,r12,hi16(ntable);load pointer into table
d564 1
a564 1
	jmp    r12                 ;jump into branch table
d600 2
a601 2
	;Add one to the mantissa, and check to see if it overflows to -2**31.
;The conversion is done in nnoaddone:.
d603 23
a625 23
naddone:     or     r10,r0,r0           ;clear r10
	set    r10,r10,1<22>       ;set LSB bit to 1 for adding
	add.co r8,r8,r10           ;add the 1 obtained from rounding
	clr    r7,r7,12<20>        ;clear exponent and sign
	add.ci r7,r0,r7            ;add carry
	bb1    20,r7,maxneg        ;rounded to -2**31,handle separately
	;the exponent was originally 30
nnoaddone:   extu   r6,r8,11<22>        ;extract lower bits of integer
	mak    r10,r7,20<10>       ;shift left upper bits of integer
	or     r6,r6,r10           ;form most of integer
	set    r6,r6,1<30>         ;set hidden one
	or.c   r6,r0,r6            ;negate integer
	br.n   FPintov_return              ;return from subroutine
	addu   r6,r6,1             ;add 1 to get 2''s complement
	
maxneg:      or     r6,r0,r0            ;clear integer
	br.n   FPintov_return              ;return from subroutine
	set    r6,r6,1<sign>       ;set sign bit
	
	
	;For valid overflows, check to see if the integer overflow user handler is 
	;set.  If it is set, then go to user handler, else write the correctly
	;signed largest integer.
d629 4
a632 4
	bb0.n  oper,r3,nohandler   ;do not go to user handler routine
	set    r2,r2,1<oper>       ;set invalid operand bit
	bsr    _handler            ;go to user handler routine
	br     FPintov_return              ;return from subroutine
d635 3
a637 3
	bb0.n  sign,r7,FPintov_return      ;if positive then return from subroutine
	set    r6,r6,31<0>         ;set result to largest positive integer
	or.c   r6,r0,r6            ;negate r6,giving largest negative int.
d639 2
a640 2
FPintov_return:      ld     r1,r31,0     ;load return address from memory
	jmp    r1                  ;return from subroutine
a642 4
;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
d644 4
a647 3
#ifndef __LUNA_SUB_H__
#include "luna_sub.h"
#endif
a648 6


;Some instructions only have the S2 operations, so clear S1HI and S1LO
;for those instructions so that the previous contents of S1HI and S1LO
;do not influence this instruction.

d651 9
a659 9
	     extu   r10,r9,5<11>   ;extract opcode
;            cmp    r11,r10,FSQRTop ;compare to FSQRT
;            bb1    eq,r11,S1clear ;clear S1 if instruction only had S2 operand
             cmp    r11,r10,INTop  ;compare to INT
             bb1    eq,r11,S1clear ;clear S1 if instruction only had S2 operand
             cmp    r11,r10,NINTop ;compare to NINT
             bb1    eq,r11,S1clear ;clear S1 if instruction only had S2 operand
             cmp    r11,r10,TRNCop ;compare to TRNC
             bb0    eq,r11,opercheck ;check for reserved operands
d662 19
a680 19
	     or     r5,r0,r0       ;clear any NaN''s, denorms, or infinities
             or     r6,r0,r0       ;that may be left in S1HI,S1LO from a 
                                   ;previous instruction

;r12 contains the following flags:
;		bit 9 -- s1sign
;		bit 8 -- s2sign
;		bit 7 -- s1nan
;		bit 6 -- s2nan
;		bit 5 -- s1inf
;		bit 4 -- s2inf
;		bit 3 -- s1zero
;		bit 2 -- s2zero
;		bit 1 -- s1denorm
;		bit 0 -- s2denorm

;Using code for both single and double precision, check if S1 is either
;a NaN or infinity and set the appropriate flags in r12.  Then check if
;S2 is a NaN or infinity.  If it is a NaN, then branch to the NaN routine.
d684 3
a686 3
	     extu   r10,r5,11<20>        ;internal representation for double
             bb1.n  s1size,r9,S1NaNdoub ;S1 is double precision
             or     r12,r0,r0      ;clear operand flag register
d688 15
a702 15
	     xor    r10,r10,0x0080       ;internal representation for single
             ext    r10,r10,8<0>         ;precision is IEEE 8 bits sign extended
                                         ;to 11 bits; for real exp. > 0, the
                                         ;above instructions gives a result exp.
                                         ;that has the MSB flipped and sign
                                         ;extended like in the IMPCR
             cmp    r11,r10,127    ;Is exponent equal to IEEE 255 (internal 127)
             bb1    ne,r11,S2NaN   ;source 1 is not a NaN or infinity
             mak    r10,r5,20<0>   ;load r10 with upper bits of S1 mantissa
             extu   r11,r6,3<29>   ;get 3 upper bits of lower word
             or     r11,r10,r11    ;combine any existing 1''s
             bcnd   eq0,r11,noS1NaNs ;since r11 can only hold 0 or a positive
                                   ;number, branch to noS1NaN when eq0
             br.n   S2NaN          ;see if S2 has a NaN
             set    r12,r12,1<s1nan> ;indicate that S1 has a NaN
d704 2
a705 2
	     br.n   S2NaN          ;check contents of S2
             set    r12,r0,1<s1inf> ;indicate that S1 has an infinity
d708 13
a720 13
	     xor    r10,r10,0x0400       ;precision is the same IEEE 11 bits 
                                         ;The
                                         ;above instructions gives a result exp.
                                         ;that has the MSB flipped and sign
                                         ;extended like in the IMPCR
             cmp    r11,r10,1023   ;Is exp. equal to IEEE 2047 (internal 1023)
             bb1    ne,r11,S2NaN   ;source 1 is not a NaN or infinity
             mak    r10,r5,20<0>   ;load r10 with upper bits of S1 mantissa
             or     r11,r6,r10     ;combine existing 1''s of mantissa
             bcnd   eq0,r11,noS1NaNd ;since r11 can only hold 0 or a positive
                                   ;number, branch to noS1NaN when eq0
             br.n   S2NaN          ;see if S2 has a NaN
             set    r12,r12,1<s1nan> ;indicate that S1 has a NaN
d722 1
a722 1
	     set    r12,r0,1<s1inf> ;indicate that S1 has an infinity
d725 2
a726 2
	     bb1.n  s2size,r9,S2NaNdoub ;S1 is double precision
             extu   r10,r7,11<20>        ;internal representation for double
d728 15
a742 15
	     xor    r10,r10,0x0080       ;internal representation for single
             ext    r10,r10,8<0>         ;precision is IEEE 8 bits sign extended
                                         ;to 11 bits; for real exp. > 0, the
                                         ;above instruction gives a result exp.
                                         ;that has the MSB flipped and sign
                                         ;extended like in the IMPCR
             cmp    r11,r10,127    ;Is exponent equal to IEEE 255 (internal 127)
             bb1    ne,r11,inf     ;source 2 is not a NaN or infinity
             mak    r10,r7,20<0>   ;load r10 with upper bits of S1 mantissa
             extu   r11,r8,3<29>   ;get 3 upper bits of lower word
             or     r11,r10,r11    ;combine any existing 1''s
             bcnd   eq0,r11,noS2NaNs ;since r11 can only hold 0 or a positive
                                   ;number, branch to noS2NaNs when eq0
             br.n   _NaN           ;branch to NaN routine
             set    r12,r12,1<s2nan> ;indicate that s2 has a NaN
d744 1
a744 1
	     bb0    s1nan,r12, 1f ;branch to NaN if S1 is a NaN
d746 5
a750 5
1:           br.n   _infinity      ;If S1 had a NaN we would have already
                                   ;branched, and S2 does not have a NaN, but
                                   ;it does have an infinity, so branch to 
                                   ;handle the finity
             set    r12,r12,1<s2inf> ;indicate that S2 has an infinity
d753 13
a765 13
	     xor    r10,r10,0x0400       ;precision is the same IEEE 11 bits 
                                         ;The
                                         ;above instruction gives a result exp.
                                         ;that has the MSB flipped and sign
                                         ;extended like in the IMPCR
             cmp    r11,r10,1023   ;Is exp. equal to IEEE 2047 (internal 1023)
             bb1    ne,r11,inf     ;source 2 is not a NaN or infinity
             mak    r10,r7,20<0>   ;load r10 with upper bits of S2 mantissa
             or     r11,r8,r10     ;combine existing 1''s of mantissa
             bcnd   eq0,r11,noS2NaNd ;since r11 can only hold 0 or a positive
                                   ;number, branch to noS2NaNd when eq0
             br.n   _NaN           ;branch to NaN routine
             set    r12,r12,1<s2nan> ;indicate that s2 has a NaN
d767 1
a767 1
	     bb0    s1nan,r12,1f ;branch to NaN if S1 is a NaN
d769 5
a773 5
1:           br.n   _infinity      ;If S1 had a NaN we would have already
                                   ;branched, and S2 does not have a NaN, but
                                   ;it does have an infinity, so branch to 
                                   ;handle the finity
             set    r12,r12,1<s2inf> ;indicate that S2 has an infinity
d776 5
a780 5
;If S2 was a NaN, the routine would have already branched to NaN.  If S1
;is a NaN, then branch to NaN.  If S1 is not a NaN and S2 is infinity, then
;we would have already branched to infinity.  If S1 is infinity, then branch.
;If the routine still has not branched, then branch to denorm, the only 
;reserved operand left.
d783 1
a783 1
	     bb0    s1nan,r12,1f  ;branch if S1 has a NaN and S2 does not
d785 3
a787 3
1:           bb0    s1inf,r12,2f    ;Neither S1 or S2 has a NaN, and we would
                                    ;have branched already if S2 had an 
                                    ;infinity, so branch if S1 is infinity
d796 2
a797 6
	br     _denorm        ;branch to denorm, the only remaining
                                   ;alternative
;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
d799 2
a800 2
;function _FPunderflow --      
;The documentation for this release give an overall description of this code.
d802 1
a802 3
#ifndef __LUNA_SUB_H__
#include "luna_sub.h"
#endif
a803 1
                text
d805 4
a808 4
;First check for an underflow user handler.  If there is not one, then
;branch to the routine to make a denormalized number.  Before branching
;to the underflow user handler, add 192 to a single precision exponent
;and 1536 to a double precision exponent.
d810 1
a810 1
_FPunderflow:   st    r1,r31,0 ;save return address
d812 107
a918 107
		bb0 efunf,r12,denorm ;jump to default procedure
                bb1.n destsize,r12,doubleprec ;double precision destination
                set   r2,r2,1<underflow>  ;set underflow flag in FPSR
singleprec:     or.u  r6,r0,0x0c00 ;load exponent adjust 192
                br.n  callundhand  ;branch to call handler for user handler
                add   r12,r6,r12   ;adjust single precision exponent
doubleprec:     or.u  r6,r0,0x6000 ;load exponent adjust 1536
                add   r12,r6,r12   ;adjust double precision exponent
callundhand:    bsr   _handler     ;call handler for user handler
                br    Ureturn       ;return from subroutine
#endif

;Now the floating point number, which has an exponent smaller than what
;IEEE allows, must be denormalized.  Denormalization is done by calculating
;the difference between a denormalized exponent and an underflow exponent and
;shifting the mantissa by that amount.  A one may need to be subtracted from 
;the LSB if a one was added during rounding.
;r9 is used to contain the guard, round, sticky, and an inaccuracy bit in
;case some bits were shifted off the mantissa during denormalization.
;r9 will contain: bit 4 -- new addone if one added during rounding 
;                          after denormalization
;                 bit 3 -- inaccuracy flag caused by denormalization
;			   or pre-denormalization inexactness
;                 bit 2 -- guard bit of result
;                 bit 1 -- round bit of result
;                 bit 0 -- sticky bit of result

denorm:         bb1.n destsize,r12,Udouble ;denorm for double
                extu  r9,r10,3<26>   ;load r9 with grs
Usingle:         mak   r5,r10,21<3> ;extract high 21 bits of mantissa
                extu  r6,r11,3<29> ;extract low 3 bits of mantissa
                or    r11,r5,r6     ;form 24 bits of mantissa

;See if the addone bit is set and unround if it is.
                bb0.n 25,r10,nounrounds ;do not unround if addone bit clear
                extu  r6,r12,12<20>  ;extract signed exponent from IMPCR
unrounds:       subu  r11,r11,1      ;subtract 1 from mantissa
;If the hidden bit is cleared after subtracting the one, then the one added
;during the rounding must have propagated through the mantissa.  The exponent
;will need to be decremented.
                bb1   23,r11,nounrounds ;if hidden bit is set,then exponent does
                                   ;not need to be decremented
decexps:        sub   r6,r6,1      ;decrement exponent 1
                set   r11,r11,1<23>  ;set the hidden bit

;For both single and double precision, there are cases where it is easier
;and quicker to make a special case.  Examples of this are if the shift 
;amount is only 1 or 2, or all the mantissa is shifted off, or all the
;mantissa is shifted off and it is still shifting, or, in the case of 
;doubles, if the shift amount is around the boundary of MANTLO and MANTHI.

nounrounds:     or    r8,r0,lo16(0x00000f81)  ;load r8 with -127 in decimal 
					    ;for lowest 12 bits
                sub   r7,r8,r6     ;find difference between two exponents,
                                   ;this amount is the shift amount
                cmp   r6,r7,3      ;check to see if r7 contains 3 or more
                bb1   ge,r6,threesing ;br to code that handles shifts of >=3
                cmp   r6,r7,2      ;check to see if r7 contains 2
                bb1   eq,r6,twosing ;br to code that handles shifts of 2
one:            rot   r9,r9,0<1>   ;rotate roundoff register once, this places
                                   ;guard in round and round in sticky
                bb0   31,r9,nosticky1s;do not or round and sticky if sticky is
                                   ;0, this lost bit will be cleared later
                set   r9,r9,1<0>   ;or round and sticky
nosticky1s:     bb0   0,r11,guardclr1s ;do not set guard bit if LSB = 0
                set   r9,r9,1<2>   ;set guard bit       
guardclr1s:     extu  r11,r11,31<1> ;shift mantissa right 1
                br.n  round        ;round result
                mak   r9,r9,3<0>   ;clear bits lost during rotation

twosing:        rot   r9,r9,0<2>   ;rotate roundff register twice, this places
                                   ;guard in sticky
                bb0   30,r9,nosticky2s ;do not or guard and sticky if stick is 0
                                   ;this lost bit will be cleared later
                br.n  noround2s    ;skip or old guard and old round if old
                                   ;sticky set
                set   r9,r9,1<0>   ;or guard and sticky
nosticky2s:     bb0   31,r9,noround2s ;do not or guard and round if round is 0
                                   ;this lost bit will be cleared later
                set   r9,r9,1<0>   ;or guard and round
noround2s:      bb0   0,r11,roundclr2s ;do not set round bit if LSB = 0
                set   r9,r9,1<1>   ;set round bit
roundclr2s:     bb0   1,r11,guardclr2s ;do not set guard bit if LSB + 1 = 0
                set   r9,r9,1<2>   ;set guard bit
guardclr2s:     extu  r11,r11,30<2>  ;shift mantissa right 2
                br.n  round        ;round result
                mak   r9,r9,3<0>   ;clear bits lost during rotation

threesing:      bb1   0,r9,noguard3s ;check sticky initially
                                     ;sticky is set, forget most of the oring
nosticky3s:     bb0   1,r9,noround3s  ;check round initially, do not set sticky
                br.n  noguard3s    ;forget most of the rest of oring
                set   r9,r9,1<0>      ;if round is clear,set sticky if round set
noround3s:      bb0.n 2,r9,noguard3s  ;check guard initially, do not set sticky
                clr   r9,r9,2<1>   ;clear the original guard and round for when
                                      ;you get to round section
                set   r9,r9,1<0>      ;if guard is clear,set sticky if guard set
noguard3s:      cmp   r6,r7,23     ;check if # of shifts is <=23
                bb1   gt,r6,s24    ;branch to see if shifts = 24
                sub   r6,r7,2      ;get number of bits to check for sticky
                mak   r6,r6,5<5>   ;shift width into width field
                mak   r8,r11,r6     ;mask off shifted bits -2
                ff1   r8,r8        ;see if r8 has any ones
                bb1   5,r8,nostky23 ;do not set sticky if no ones found
                set   r9,r9,1<0>   ;set sticky bit
nostky23:       or    r8,r0,34     ;start code to get new mantissa plus two
                                   ;extra bits for new round and new guard bits
d920 25
a944 25
                mak   r8,r8,5<5>   ;shift field width into second five bits
                extu  r6,r6,5<5>   ;shift previous shifted -2 into offset field
                or    r6,r6,r8     ;complete field
                extu  r11,r11,r6     ;form new mantissa with two extra bits

                bb0   0,r11,nornd3s ;do not set new round bit
                set   r9,r9,1<1>   ;set new round bit
nornd3s:        bb0   1,r11,nogrd3s ;do not set new guard bit
                set   r9,r9,1<2>   ;set new guard bit
nogrd3s:        br.n  round        ;round mantissa
                extu  r11,r11,30<2>  ;shift off remaining two bits

s24:            cmp   r6,r7,24     ;check to see if # of shifts is 24
                bb1   gt,r6,s25    ;branch to see if shifts = 25
                bb1   0,r9,nostky24 ;skip checking if old sticky set
                extu  r8,r11,22<0>  ;prepare to check bits that will be shifted
                                   ;into the sticky
                ff1   r8,r8        ;see if there are any 1''s
                bb1   5,r8,nostky24 ;do not set sticky if no ones found
                set   r9,r9,1<0>   ;set sticky bit
nostky24:       bb0   22,r11,nornd24 ;do not set new round bit
                set   r9,r9,1<1>   ;set new round bit
nornd24:        set   r9,r9,1<2>   ;set new guard bit,this is hidden bit
                br.n  round        ;round mantissa
                or    r11,r0,r0     ;clear r11, all of mantissa shifted off
d946 22
a967 22
s25:            cmp   r6,r7,25     ;check to see if # of shifts is 25
                bb1   gt,r6,s26    ;branch to execute for shifts => 26
                bb1   0,r9,nostky25 ;skip checking if old sticky set
                extu  r8,r11,23<0> ;prepare to check bits that will be shifted
                                   ;into the sticky
                ff1   r8,r8        ;see if there are any 1''s
                bb1   5,r8,nostky25 ;do not set sticky if no ones found
                set   r9,r9,1<0>   ;set sticky bit
nostky25:       set   r9,r9,1<1>   ;set new round bit,this is hidden bit
                clr   r9,r9,1<2>   ;clear guard bit since nothing shifted in
                br.n  round        ;round and assemble result
                or    r11,r0,r0    ;clear r11, all of mantissa shifted off

s26:            set   r9,r9,1<0>   ;set sticky bit,this contains hidden bit
                clr   r9,r9,2<1>   ;clear guard and round bits since nothing 
                                   ;shifted in 
                br.n  round        ;round and assemble result
                or    r11,r0,r0    ;clear mantissa

Udouble:         mak   r5,r10,21<0> ;extract upper bits of mantissa
                bb0.n 25,r10,nounroundd ;do not unround if addone bit clear
                extu  r6,r12,12<20>;extract signed exponenet from IMPCR
d969 74
a1042 74
		subu.co  r11,r11,r8     ;subtract 1 from mantissa
                subu.ci  r5,r5,r0       ;subtract borrow from upper word
                bb1   20,r5,nounroundd ;if hidden bit is set, then exponent does
                                       ;not need to be decremented
decexpd:        sub   r6,r6,1      ;decrement exponent 1
                set   r5,r5,1<20>  ;set the hidden bit

nounroundd:     or    r8,r0,lo16(0x00000c01) ;load r8 with -1023 in decimal 
					     ;for lowest 12 bits 
                sub   r7,r8,r6     ;find difference between two exponents,
                                   ;this amount is the shift amount
                cmp   r6,r7,3      ;check to see if r7 contains 3 or more
                bb1   ge,r6,threedoub ;br to code that handles shifts of >=3
                cmp   r6,r7,2      ;check to see if r7 contains 2
                bb1   eq,r6,twodoub ;br to code that handles shifts of 2

onedoub:        rot   r9,r9,0<1>   ;rotate roundoff register once, this places
                                   ;guard in round and round in sticky
                bb0   31,r9,nosticky1d;do not or round and sticky if sticky is 0
                                   ;this lost bit will be cleared later
                set   r9,r9,1<0>   ;or old round and old sticky into new sticky
nosticky1d:     bb0   0,r11,guardclr1d ;do not set new guard bit if old LSB = 0
                set   r9,r9,1<2>   ;set new guard bit
guardclr1d:     extu  r11,r11,31<1> ;shift lower mantissa over 1
                mak   r6,r5,1<31>  ;shift off low bit of high mantissa
                or    r11,r6,r11   ;load high bit onto lower mantissa
                extu  r5,r5,20<1>  ;shift right once upper 20 bits of mantissa
                br.n  round        ;round mantissa and assemble result
                mak   r9,r9,3<0>   ;clear bits lost during rotation

twodoub:        rot   r9,r9,0<2>   ;rotate roundoff register twice, this places
                                   ;old guard into sticky
                bb0   30,r9,nosticky2d ;do not or old guard and old sticky if 
                                       ;old sticky is 0
                br.n  noround2d    ;skip or of old guard and old round if old
                                   ;sticky set
                set   r9,r9,1<0>   ;or old guard and old sticky into new sticky
nosticky2d:     bb0   31,r9,noround2d ;do not or old guard and old round if
                                      ;old round is 0
                set   r9,r9,1<0>   ;or old guard and old round into new sticky
noround2d:      bb0   0,r11,roundclr2d ;do not set round bit if old LSB = 0
                set   r9,r9,1<1>   ;set new round bit
roundclr2d:     bb0   1,r11,guardclr2d ;do not set guard bit if old LSB + 1 = 0
                set   r9,r9,1<2>   ;set new guard bit
guardclr2d:     extu  r11,r11,30<2> ;shift lower mantissa over 2
                mak   r6,r5,2<30>  ;shift off low bits of high mantissa
                or    r11,r6,r11   ;load high bit onto lower mantissa
                extu  r5,r5,19<2>  ;shift right twice upper 19 bits of mantissa
                br.n  round        ;round mantissa and assemble result
                mak   r9,r9,3<0>   ;clear bits lost during rotation

threedoub:      bb1   0,r9,noguard3d ;checky sticky initially
                                    ;sticky is set, forget most of rest of oring
nosticky3d:     bb0   1,r9,noround3d ;check old round, do not set sticky if 
                                     ;old round is clear, set otherwise
                br.n  noguard3d    ;sticky is set, forget most of rest of oring
                set   r9,r9,1<0>   ;set sticky if old round is set
noround3d:      bb0   2,r9,noguard3d ;check old guard, do not set sticky if 0
                clr   r9,r9,2<1>   ;clear the original guard and round for when
                                      ;you get to round section
                set   r9,r9,1<0>   ;set sticky if old guard is set
noguard3d:      cmp   r6,r7,32     ;do I need to work with a 1 or 2 word mant.
                                   ;when forming sticky, round and guard
                bb1   gt,r6,d33    ;jump to code that handles 2 word mantissas
                sub   r6,r7,2      ;get number of bits to check for sticky
                mak   r6,r6,5<5>   ;shift width into width field
                mak   r8,r11,r6    ;mask off shifted bits -2
                ff1   r8,r8        ;see if r8 has any ones
                bb1   5,r8,nostky32 ;do not set sticky if no ones found
                set   r9,r9,1<0>   ;set sticky bit
nostky32:       or    r8,r0,34     ;start code to get new mantissa plus two
                                   ;extra bits for new round and new guard bits,
                                   ;the upper word bits will be shifted after
                                   ;the round and guard bits are handled
d1044 148
a1191 148
                mak   r8,r8,5<5>   ;shift field width into second five bits
                extu  r6,r6,5<5>   ;shift previous shifted -2 into offset field
                or    r6,r6,r8     ;complete bit field
                extu  r11,r11,r6   ;partially form new low mantissa with 2 more 
                                   ;bits
                bb0   0,r11,nornd32d ;do not set new round bit
                set   r9,r9,1<1>   ;set new round bit
nornd32d:       bb0   1,r11,nogrd32d ;do not set new guard bit
                set   r9,r9,1<2>   ;set new guard bit
nogrd32d:       extu  r11,r11,30<2> ;shift off remaining two bits
                mak   r6,r7,5<5>   ;shift field width into second 5 bits, if the
                                   ;width is 32, then these bits will be 0
                or    r8,r0,32     ;load word length into r8
                sub   r8,r8,r7     ;form offset for high bits moved to low word
                or    r6,r6,r8     ;form complete bit field
                mak   r6,r5,r6     ;get shifted bits of high word
                or    r11,r6,r11   ;form new low word of mantissa
		bcnd  ne0,r8,regular33 ;do not adjust for special case of r8
		br.n  round	       ;containing zeros, which would cause
		or    r5,r0,r0         ;all of the bits to be extracted under
				       ;the regular method
regular33:      mak   r6,r7,5<0>   ;place lower 5 bits of shift into r6
                mak   r8,r8,5<5>   ;shift r8 into width field
                or    r6,r6,r8     ;form field for shifting of upper bits
                br.n  round        ;round and assemble result
                extu  r5,r5,r6     ;form new high word mantissa

d33:            cmp   r6,r7,33     ;is the number of bits to be shifted is 33?
                bb1   gt,r6,d34    ;check to see if # of bits is 34
                bb1   0,r9,nostky33 ;skip checking if old sticky set
                mak   r6,r11,31<0> ;check bits that will be shifted into sticky
                ff1   r8,r8        ;check for ones
                bb1   5,r8,nostky33 ;do not set sticky if there are no ones
                set   r9,r9,1<0>   ;set new sticky bit
nostky33:       bb0   31,r11,nornd33 ;do not set round if bit is not a 1
                set   r9,r9,1<1>   ;set new round bit
nornd33:        bb0   0,r5,nogrd33 ;do not set guard bit if bit is not a 1
                set   r9,r9,1<2>   ;set new guard bit
nogrd33:        extu  r11,r5,31<1> ;shift high bits into low word
                br.n  round        ;round and assemble result
                or    r5,r0,r0     ;clear high word

d34:            cmp   r6,r7,34     ;is the number of bits to be shifted 34?
                bb1   gt,r6,d35    ;check to see if # of bits is >= 35
                bb1   0,r9,nostky34 ;skip checking if old sticky set
                ff1   r8,r11       ;check bits that will be shifted into sticky
                bb1   5,r8,nostky34 ;do not set sticky if there are no ones
                set   r9,r9,1<0>   ;set new sticky bit
nostky34:       bb0   0,r5,nornd34 ;do not set round if bit is not a 1
                set   r9,r9,1<1>   ;set new round bit
nornd34:        bb0   1,r5,nogrd34 ;do not set guard bit if bit is not a 1
                set   r9,r9,1<2>   ;set new guard bit
nogrd34:        extu  r11,r5,30<2> ;shift high bits into low word
                br.n  round        ;round and assemble result
                or    r5,r0,r0     ;clear high word

d35:            cmp   r6,r7,52     ;see if # of shifts is 35 <= X <= 52
                bb1   gt,r6,d53    ;check to see if # of shifts is 52
                bb1.n 0,r9,nostky35 ;skip checking if old sticky set
                sub   r7,r7,34     ;subtract 32 from # of shifts so that opera-
                                   ;tions can be done on the upper word, and 
                                   ;then subtract two more checking guard and
                                   ;sticky bits
                ff1   r8,r11       ;see if lower word has a bit for sticky
                bb1   5,r8,stkycheck35 ;see if upper word has any sticky bits   
                br.n  nostky35     ;quit checking for sticky
                set   r9,r9,1<0>   ;set sticky bit
stkycheck35:    mak   r6,r7,5<5>   ;place width into width field
                mak   r8,r5,r6     ;mask off shifted bits - 2
                ff1   r8,r8        ;see if r8 has any ones
                bb1   5,r8,nostky35 ;do not set sticky if no ones found
                set   r9,r9,1<0>   ;set sticky bit
nostky35:       or    r8,r0,32     ;look at what does not get shifted off plus
                                   ;round and sticky, remember that the r7 value
                                   ;was adjusted so that it did not include
                                   ;new round or new sticky in shifted off bits
                subu  r8,r8,r7     ;complement width 
                mak   r8,r8,5<5>   ;shift width into width field
                or    r8,r7,r8     ;add offset field
                extu  r11,r5,r8    ;extract upper bits into low word
                bb0   0,r11,nornd35 ;do not set new round bit
                set   r9,r9,1<1>   ;set new round bit
nornd35:        bb0   1,r11,nogrd35 ;do not set new guard bit
                set   r9,r9,1<2>   ;set new guard bit
nogrd35:        extu  r11,r11,30<2> ;shift off remaining guard and round bits
                br.n  round         ;round and assemble result
                or    r5,r0,r0      ;clear high word

d53:            cmp   r6,r7,53     ;check to see if # of shifts is 53
                bb1   gt,r6,d54    ;branch to see if shifts = 54
                bb1   0,r9,nostky53 ;skip checking if old sticky set
                ff1   r8,r11       ;see if lower word has a bit for sticky
                bb1   5,r8,stkycheck53 ;see if upper word has any sticky bits   
                br.n  nostky53     ;quit checking for sticky
                set   r9,r9,1<0>   ;set sticky bit
stkycheck53:    mak   r6,r5,19<0>  ;check bits that are shifted into sticky
                ff1   r8,r6        ;see if r6 has any ones
                bb1   5,r8,nostky53 ;do not set sticky if no ones found
                set   r9,r9,1<0>   ;set sticky bit
nostky53:       bb0   19,r5,nornd53 ;do not set new round bit
                set   r9,r9,1<1>   ;set new round bit
nornd53:        set   r9,r9,1<2>   ;set new guard bit,this is hidden bit
                or    r5,r0,r0     ;clear high word
                br.n  round        ;round and assemble result
                or    r11,r0,r0    ;clear low word

d54:            cmp   r6,r7,54     ;check to see if # of shifts is 54
                bb1   gt,r6,d55    ;branch to execute for shifts =>55
                bb1   0,r9,nostky54 ;skip checking if old sticky set
                ff1   r8,r11       ;see if lower word has a bit for sticky
                bb1   5,r8,stkycheck54 ;see if upper word has any sticky bits   
                br.n  nostky54     ;quit checking for sticky
                set   r9,r9,1<0>   ;set sticky bit
stkycheck54:    mak   r6,r5,20<0>  ;check bits that are shifted into sticky
                ff1   r8,r6        ;see if r6 has any ones
                bb1   5,r8,nostky54 ;do not set sticky if no ones found
                set   r9,r9,1<0>   ;set sticky bit
nostky54:       set   r9,r9,1<1>   ;set new round bit,this is hidden bit
                clr   r9,r9,1<2>   ;clear guard bit since nothing shifted in
                or    r5,r0,r0     ;clear high word
                br.n  round        ;round and assemble result
                or    r11,r0,r0    ;clear low word

d55:            set   r9,r9,1<0>   ;set new sticky bit,this contains hidden bit
                clr   r9,r9,2<1>   ;clear guard and round bits since nothing
                                   ;shifted in
                or    r5,r0,r0     ;clear high word
                or    r11,r0,r0    ;clear low word


;The first item that the rounding code does is see if either guard, round,
;or sticky is set.  If all are clear, then there is no denormalization loss
;and no need to round, then branch to assemble answer.
;For rounding, a branch table is set up.  The left two most bits are the 
;rounding mode.  The third bit is either the LSB of the mantissa or the
;sign bit, depending on the rounding mode.  The three LSB''s are the guard,
;round and sticky bits.

round:          ff1   r8,r9         ;see if there is denormalization loss
                bb1   5,r8,assemble ;no denormalization loss or inexactness
                extu  r6,r10,2<modelo>   ;extract rounding mode
                bb1.n modehi,r10,signext ;use sign bit instead of LSB
                mak   r6,r6,2<4>    ;shift over rounding mode
                extu  r7,r11,1<0>   ;extract LSB
                br.n  grs           ;skip sign extraction
                mak   r7,r7,1<3>    ;shift over LSB
signext:        extu  r7,r10,1<31>  ;extract sign bit
                mak   r7,r7,1<3>    ;shift sign bit over
d1193 2
a1194 2
                or    r6,r6,r9      ;or in guard, round, and sticky
                or.u  r1,r0,hi16(roundtable) ;form address of branch table
d1196 3
a1198 3
                lda   r6,r1[r6]     ;scale offset into branch table
                jmp.n r6            ;jump to branch table
                set   r9,r9,1<3>    ;set inexact flag in r9
d1265 6
a1270 6
;Round by adding a one to the LSB of the mantissa.
addone:         or    r6,r0,1      ;load a 1 into r6 so that add.co can be used
                add.co r11,r11,r6  ;add a one to the lower word of result
                bb0.n destsize,r12,noaddone ;single result,forget carry
                set   r9,r9,1<4>   ;indicate that a 1 has been added
                add.ci r5,r5,r0    ;propagate carry into high word
d1273 1
a1273 1
;Branch to inexact user handler if there is one.
d1277 3
a1279 3
		bb1.n efinx,r12,modformdef ;branch to modify form for user 
                                             ;handler
                or    r2,r2,5      ;set inexact and underflow flags
d1283 13
a1295 13
;Assemble the result of the denormalization routine for writeback to the 
;destination register.  The exponent of a denormalized number is zero,
;so simply assemble the sign and the new mantissa.

assemble:       bb1   destsize,r12,doubassem ;assemble double result
                bb0   sign,r10,exassems ;exit assemble if sign is zero
                set   r11,r11,1<sign>  ;make result negative
exassems:       br    Ureturn       ;return from subroutine

doubassem:      bb0.n sign,r10,signclr ;do not set sign in r10
		or    r10,r5,r0    ;load high word from r5 into r10
                set   r10,r10,1<sign> ;high word with sign loaded
signclr:        br    Ureturn       ;return from subroutine
d1298 3
a1300 3
;modfordef modifies the result of denormalization to the input format of
;the inexact user handler.  This input format is the same format that 
;MANTHI, MANTLO, and IMPCR were initially loaded with.
d1303 15
a1317 15
modformdef:     clr   r12,r12,12<20> ;clear result exponent,IMPCR complete
                clr   r10,r10,4<25>  ;clear old guard,round,sticky,and addone
                mak   r5,r9,3<26>    ;make grs field
                bb0.n 4,r9,newaddone ;do not set new addone in MANTHI
                or    r10,r5,r10     ;or in new grs field
                set   r10,r10,1<25>  ;set new addone
newaddone:      bb1.n destsize,r12,moddefd ;branch to handle double precision
                clr   r10,r10,21<0>  ;clear upper bits of old mantissa
moddefs:        extu  r5,r11,20<3>   ;extract upper bits
                or    r10,r5,r10     ;MANTHI complete
                bsr.n _handler       ;execute user handler for inexact
                rot   r11,r11,0<3>   ;MANTLO complete
                br    Ureturn         ;return from subroutine
moddefd:        bsr.n _handler       ;execute user handler for inexact
                or    r10,r5,r10     ;MANTHI complete,r5 should be set to OR
d1321 1
a1321 1
;Return to fpui.
d1323 2
a1324 2
Ureturn:         ld    r1,r31,0 ;load return address
                jmp   r1           ;return from subroutine
a1326 4
;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
d1328 2
a1329 2
;function _FPoverflow --      
;The documentation for this release gives an overall description of this code.
a1334 3
#ifndef __LUNA_SUB_H__
#include "luna_sub.h"
#endif
d1336 7
a1343 8
              text				


;If the overflow user handler bit is not set, then the inexact bit in the
;FPSR is set, and the inexact user handler bit is checked.  If it is set,
;then the inexact user handler is executed, else the default routine for
;overflow is executed.

d1345 1
a1345 1
	      st     r1,r31,0 ;save return address
d1347 7
a1353 7
              set    r2,r2,1<overflow> ;set overflow bit in r2 which holds FPSR
              bb1    efovf,r12,hand  ;go to user handler if bit set for overflow
              set    r2,r2,1<inexact> ;set inexact bit in r2 since overflow bit
                                ;in FPCR is not set
              bb0  efinx,r12,nohandler;if userhandler for inexact not set,then
                                        ;round result
              br     callhandler ;branch to user handler for inexact
d1355 2
a1356 2
;Before the overflow user handler is executed, the exponent is modified
;by subtracting 192 for single precision and 1536 for double precision.
d1358 22
a1379 22
hand:         bb1    10,r12,doubleprec ;double precision result
singleprec:   or.u   r5,r0,0x0c00 ;load exponent adjust
              br.n   callhandler  ;prepare to call user handler
              subu   r12,r12,r5 ;adjust single precision exponent
doubleprec:   or.u   r5,r0,0x6000 ;load exponent adjust
              subu   r12,r12,r5 ;adjust double precision exponent
callhandler:  bsr    _handler   ;branch to common handler routine
              br     return     ;return from overflow subroutine
#endif

;Determine which rounding mode to use for the default procedure.

nohandler:    bb1    modehi,r10,signed ;mode is either round toward pos. or neg.
              bb0    modelo,r10,OFnearest ;rounding mode is round nearest
              br     OFzero            ;rounding mode is round zero
signed:       bb0    modelo,r10,OFnegative ;rounding mode is round negative
              br     positive        ;rounding mode is round positive


;In the round toward nearest mode, positive values are rounded to
;postive infinity and negative values are loaded toward negative infinity.
;The value for single or double precision is loaded from a data table.
d1382 4
a1385 4
		bb1.n  destsize,r12,neardouble ;branch to neardouble of 
                                             ;double result
              mask.u r5,r10,0x8000  ;mask off sign bit from MANTHI
              or.u   r11,r0,hi16(0x7f800000)  ;load single infinity constant
d1387 2
a1388 2
              br.n   return     ;return with result
              or     r11,r5,r11 ;adjust sign
d1390 2
a1391 2
	     or     r11,r0,r0           ;load lower word of infinity
              or.u   r10,r0,hi16(0x7ff00000)  ;load upper word of infinity
d1393 2
a1394 2
              br.n   return     ;return with result
              or     r10,r5,r10 ;adjust sign
d1397 4
a1400 4
;In the round toward zero mode, positive values are rounded to the largest
;postive finite number and negative values are rounded toward the largest
;negative finite number.
;The value for single or double precision is loaded from a data table.
d1403 4
a1406 4
		bb1.n  destsize,r12,zerodouble ;branch to zerodouble of 
                                             ;double result
              mask.u r5,r10,0x8000  ;mask off sign bit from MANTHI
              or.u   r11,r0,hi16(0x7f7fffff)  ;load single finite number constant
d1408 2
a1409 2
              br.n   return     ;return with result
              or     r11,r5,r11 ;adjust sign
d1411 2
a1412 2
	     set    r11,r0,0<0>          ;load lower word of finite number
              or.u   r10,r0,hi16(0x7fefffff)  ;load upper word of finite number
d1414 2
a1415 2
              br.n   return     ;return with result
              or     r10,r5,r10 ;adjust sign
d1418 4
a1421 4
;In the round toward positve mode, positive values are rounded to 
;postive infinity and negative values are loaded toward the largest
;negative finite number.
;The value for single or double precision is loaded from a data table.
d1424 1
a1424 1
              bb1    destsize,r12,posdouble ;branch to section for double result
d1426 1
a1426 1
  	     bb1    sign,r10,possingleneg ;branch to section for negatives
d1428 2
a1429 2
		or.u   r11,r0,hi16(0x7f800000)  ;load single infinity constant
              br.n   return     ;return with result
d1432 1
a1432 1
	     or.u   r11,r0,hi16(0x7f7fffff)  ;load single finite number constant
d1434 2
a1435 2
              br.n   return     ;return with result
              set    r11,r11,1<sign> ;set sign for negative
d1437 1
a1437 1
	     bb1    sign,r10,posdoubleneg ;branch to negative double results
d1439 3
a1441 3
		or     r11,r0,r0  ;load lower word of double infinity
              or.u   r10,r0,hi16(0x7ff00000)  ;load upper word of infinity
              br.n   return     ;return with result
d1444 2
a1445 2
	      set    r11,r0,0<0>          ;load lower word of finite number
              or.u   r10,r0,hi16(0x7fefffff)  ;load upper word of finite number
d1447 2
a1448 2
              br.n   return     ;return with result
              set    r10,r10,1<sign> ;set sign for negative
d1451 3
a1453 3
;In the round toward negative mode, positive values are rounded to the largest 
;postive finite number and negative values are rounded to negative infinity.
;The value for single or double precision is loaded from a data table.
d1456 1
a1456 1
	      bb1    destsize,r12,negdouble ;branch to section for double result
d1458 1
a1458 1
	      bb1    sign,r10,negsingleneg ;branch to section for negatives
d1460 2
a1461 2
	      or.u   r11,r0,hi16(0x7f7fffff)  ;load single finite number constant
              br.n   return     ;return with result
d1464 1
a1464 1
	      or.u   r11,r0,hi16(0x7f800000)  ;load single infinity constant
d1466 2
a1467 2
              br.n   return     ;return with result
              set    r11,r11,1<sign> ;set sign for negative
d1469 1
a1469 1
	   bb1    sign,r10,negdoubleneg ;branch to negative double results
d1471 3
a1473 3
	      set    r11,r0,0<0>          ;load lower word of finite number
              or.u   r10,r0,hi16(0x7fefffff)  ;load upper word of finite number
              br.n   return     ;return with result
d1476 2
a1477 2
	      or     r11,r0,r0  ;load lower word of double infinity
              or.u   r10,r0,hi16(0x7ff00000)  ;load upper word of infinity
d1479 1
a1479 1
              set    r10,r10,1<sign> ;set sign for negative
d1482 2
a1483 2
	      ld     r1,r31,0 ;ld return address
              jmp    r1         ;return from subroutine
a1485 4
;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
d1487 9
a1495 3
#ifndef __LUNA_SUB_H__
#include "luna_sub.h"
#endif
a1496 10

;If either S1 or S2 is a signalling NaN, then set the invalid operation
;bit of the FPSR.  If the invalid operation user handler flag is set and
;then NaN is signalling, then branch to the handler routine to go to the
;user handler.
;If S1 is the only NaN or one of two NaN''s, then write
;a quiet S1 to the result.  A signalling NaN must be made quiet before
;it can be written, but a signalling S2 is not modified in this routine
;if S1 is a NaN.
		
d1498 4
a1501 4
	        bb0.n	s1nan,r12,S2sigcheck ;S1 is not a NaN
		st	r1,r31,0 ;save return address
		bb1	sigbit,r5,S2sigcheck ;S1 is not a signaling NaN
		set	r2,r2,1<oper>  ;set invalid operation bit in FPSR
d1520 2
a1521 2
		bb0	oper,r3,S1nohandler ;branch if no user handler
		bsr	_handler       ;branch to handler
d1525 4
a1528 4
	        br.n	S1write        ;FPSR bit already set, S1 is made quiet,
                                   ;and since we always write S1 if it is a
                                   ;NaN, write S1 and skip rest of routine
		set	r5,r5,1<sigbit> ;make S1 a quiet NaN
d1531 3
a1533 3
		bb0	s2nan,r12,S1write ;S2 is not a NaN
		bb1	sigbit,r7,S1write ;S2 is not a signaling NaN
		set	r2,r2,1<oper>  ;set invalid operation bit in FPSR
d1535 2
a1536 2
		bb0	oper,r3,S2nohandler	;branch if no user handler
		bsr	_handler       ;branch to handler
d1541 1
a1541 1
		set    r7,r7,1<sigbit> ;make S2 a quiet NaN
d1544 2
a1545 2
;Write a single or double precision quiet NaN unless the opeation is FCMP.
;If the operation is FCMP, then set the not comparable bit in the result.
d1548 7
a1554 7
	     bb0    s1nan,r12,S2write ;do not write S1 if it is not a NaN
             extu   r10,r9,5<11>      ;extract opcode
             cmp    r11,r10,FCMPop    ;compare to FCMP
             bb1    ne,r11,S1noFCMP   ;operation is not FCMP
             set    r6,r0,1<nc>       ;set the not comparable bit
             br.n   FPnan_return            ;return from subroutine
             set    r6,r6,1<ne>       ;set the not equal bit
d1556 3
a1558 3
	     bb1.n  dsize,r9,wrdoubS1 ;double destination
             set    r5,r5,11<20>      ;set all exponent bits to 1
;The single result will be formed the same way whether S1 is a single or double
d1560 6
a1565 6
	     mak    r10,r5,28<3>      ;wipe out extra exponent bits
             extu   r11,r6,3<29>      ;get lower three bits of mantissa
             or     r10,r10,r11       ;combine all of result except sign
             clr    r6,r5,31<0>       ;clear all but sign
             br.n   FPnan_return            ;return from function
             or     r6,r6,r10         ;form result
d1568 1
a1568 1
;;;;;;	     bb1    s1size,r9,wrdoubS1d ;write double source to double dest.
d1571 1
a1571 1
	     set    r6,r6,29<0>       ;set extra bits of lower word
d1573 2
a1574 2
	     br     FPnan_return      ;no modification necessary for writing
                                      ;double to double, so return from function
d1577 7
a1583 7
	     extu   r10,r9,5<11>      ;extract opcode
             cmp    r11,r10,FCMPop    ;compare to FCMP
             bb1.n  ne,r11,S2noFCMP   ;operation is not FCMP
             set    r7,r7,11<20>      ;set all exponent bits to 1
             set    r6,r0,1<nc>       ;set the not comparable bit
             br.n   FPnan_return            ;return from subroutine
             set    r6,r6,1<ne>       ;set the not equal bit
d1585 1
a1585 1
	     bb1.n  dsize,r9,wrdoubS2 ;double destination
d1593 2
a1594 2
             set    r5,r5,11<20>      ;set all exponent bits to 1
;The single result will be formed the same way whether S1 is a single or double
d1596 6
a1601 6
	     mak    r10,r7,28<3>      ;wipe out extra exponent bits
             extu   r11,r8,3<29>      ;get lower three bits of mantissa
             or     r10,r10,r11       ;combine all of result except sign
             clr    r6,r7,31<0>       ;clear all but sign
             br.n   FPnan_return            ;return from function
             or     r6,r6,r10         ;form result
d1605 1
a1605 1
;;;;	     bb1  s2size,r9,FPnan_return  ;write double source to double dest.
d1611 1
a1611 1
	     set    r6,r8,29<0>       ;set extra bits of lower word
d1614 1
a1614 1
;Return from this subroutine with the result.
d1617 4
a1620 4
	     ;no modification necessary for writing
                                      ;double to double, so return from function
             ld     r1,r31,	 0   ;retrieve return address
             jmp    r1                ;return from function
a1622 8
;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;

;function _infinity --      
;See the documentation of this release for an overall description of this
;code.
d1624 3
a1627 5
#ifndef __LUNA_SUB_H__
#include "luna_sub.h"
#endif
             global _infinity
             text
d1629 2
a1630 2
;Extract the opcode, compare to a constant, and branch to the code
;for the instruction.
d1632 85
a1716 82
_infinity:   extu   r10,r9,5<11>   ;extract opcode
             cmp    r11,r10,FADDop ;compare to FADD
             bb1.n  eq,r11,FADD    ;operation is FADD
             st     r1,r31,0       ;save return address
             cmp    r11,r10,FSUBop ;compare to FSUB
             bb1    eq,r11,FSUB    ;operation is FSUB
             cmp    r11,r10,FCMPop ;compare to FCMP
             bb1    eq,r11,FCMP    ;operation is FCMP
             cmp    r11,r10,FMULop ;compare to FMUL
             bb1    eq,r11,FMUL    ;operation is FMUL
             cmp    r11,r10,FDIVop ;compare to FDIV
             bb1    eq,r11,FDIV    ;operation is FDIV
;             cmp    r11,r10,FSQRTop;compare to FSQRT
;             bb1    eq,r11,FSQRT   ;operation is FSQRT
             cmp    r11,r10,INTop  ;compare to INT
             bb1    eq,r11,FP_inf_overflw ;operation is INT
             cmp    r11,r10,NINTop ;compare to NINT
             bb1    eq,r11,FP_inf_overflw ;operation is NINT
             cmp    r11,r10,TRNCop ;compare to TRNC
             bb1    eq,r11,FP_inf_overflw ;operation is TRNC


;Adding infinities of opposite signs will cause an exception,
;but all other operands will result in a correctly signed infinity.

FADD:        bb0    s1inf,r12,addS2write ;branch if S1 not infinity
             bb0    s2inf,r12,addS1write ;S2 is not inf., so branch to write S1
             bb1    sign,r5,addS1neg   ;handle case of S1 negative
addS1pos:    bb1    sign,r7,excpt      ;adding infinities of different signs
                                       ;causes an exception
             br     poswrinf           ;branch to write positive infinity
addS1neg:    bb0    sign,r7,excpt      ;adding infinities of different signs
                                       ;causes an exception
             br     negwrinf           ;branch to write negative infinity
addS1write:  bb0    sign,r5,poswrinf   ;branch to write positive infinity
             br     negwrinf           ;branch to write negative infinity
addS2write:  bb0    sign,r7,poswrinf   ;branch to write positive infinity
             br     negwrinf           ;branch to write negative infinity


;Subtracting infinities of the same sign will cause an exception,
;but all other operands will result in a correctly signed infinity.

FSUB:        bb0    s1inf,r12,subS2write ;branch if S1 not infinity
             bb0    s2inf,r12,subS1write ;S2 is not inf., so branch to write S1
             bb1    sign,r5,subS1neg   ;handle case of S1 negative
subS1pos:    bb0    sign,r7,excpt      ;subtracting infinities of the same sign
                                       ;causes an exception
             br     poswrinf           ;branch to write positive infinity
subS1neg:    bb1    sign,r7,excpt      ;subtracting infinities of the same sign
                                       ;causes an exception
             br     negwrinf           ;branch to write negative infinity
subS1write:  bb0    sign,r5,poswrinf   ;branch to write positive infinity
             br     negwrinf           ;branch to write negative infinity
subS2write:  bb1    sign,r7,poswrinf   ;branch to write positive infinity
             br     negwrinf           ;branch to write negative infinity


;Compare the operands, at least one of which is infinity, and set the
;correct bits in the destination register.

FCMP:        bb0.n  s1inf,r12,FCMPS1f  ;branch for finite S1
             set    r4,r0,1<cp>        ;since neither S1 or S2 is a NaN, set cp
FCMPS1i:     bb1    sign,r5,FCMPS1ni   ;branch to negative S1i
FCMPS1pi:    bb0    s2inf,r12,FCMPS1piS2f ;branch to finite S2 with S1pi
FCMPS1piS2i: bb1    sign,r7,FCMPS1piS2ni ;branch to negative S2i with S1pi
FCMPS1piS2pi: set   r4,r4,1<eq>        ;set eq bit 
             set    r4,r4,1<le>        ;set le bit
             set    r4,r4,1<ge>        ;set ge bit
             set    r4,r4,1<ib>        ;set ib bit
             br.n   move               ;return from subroutine
             set    r4,r4,1<ob>        ;set ob bit
FCMPS1piS2ni: set   r4,r4,1<ne>        ;set ne bit
             set    r4,r4,1<gt>        ;set gt bit
             br.n   move               ;return from subroutine
             set    r4,r4,1<ge>        ;set ge bit
FCMPS1piS2f: set    r4,r4,1<ne>        ;set ne bit
             set    r4,r4,1<gt>        ;set gt bit
             bsr.n  _zero              ;see if any of the operands are zero
             set    r4,r4,1<ge>        ;set ge bit
             bb0    s2zero,r12,FCMPS1piS2nz ;check for negative if s2 not zero
	     set    r4,r4,1<ou>        ;set ou bit
d1718 23
a1740 23
             set    r4,r4,1<ob>        ;set ob bit
FCMPS1piS2nz: bb1    sign,r7,move     ;return from subroutine if s2 is neg.
FCMPS1piS2pf: set   r4,r4,1<ou>        ;set ou bit
             br.n   move             ;return from subroutine
             set    r4,r4,1<ob>        ;set ob bit
FCMPS1ni:    bb0    s2inf,r12,FCMPS1niS2f ;branch to finite S2 with S1ni
FCMPS1niS2i: bb1    sign,r7,FCMPS1niS2ni ;branch to negative S2i with S1ni
FCMPS1niS2pi: set   r4,r4,1<ne>        ;set eq bit 
             set    r4,r4,1<le>        ;set le bit
             set    r4,r4,1<lt>        ;set lt bit
             set    r4,r4,1<ou>        ;set ou bit
             br.n   move             ;return from subroutine
             set    r4,r4,1<ob>        ;set ob bit
FCMPS1niS2ni: set   r4,r4,1<eq>        ;set eq bit 
             set    r4,r4,1<le>        ;set le bit
             br.n   move             ;return from subroutine
             set    r4,r4,1<ge>        ;set ge bit
FCMPS1niS2f: set    r4,r4,1<ne>        ;set eq bit 
             set    r4,r4,1<le>        ;set le bit
             bsr.n  _zero              ;see if any of the operands are zero
             set    r4,r4,1<lt>        ;set lt bit
             bb0    s2zero,r12,FCMPS1niS2nz ;branch if s2 is not zero
	     set    r4,r4,1<ou>        ;set ou bit
d1742 10
a1751 10
             set    r4,r4,1<ob>        ;set ob bit
FCMPS1niS2nz: bb1    sign,r7,move     ;return from subroutine if s2 is neg.
             set    r4,r4,1<ou>        ;set ou bit
             br.n   move             ;return from subroutine
             set    r4,r4,1<ob>        ;set ob bit
FCMPS1f:     bb1    sign,r5,FCMPS1nf   ;branch to negative S1f
FCMPS1pf:    bb1.n  sign,r7,FCMPS1pfS2ni ;branch to negative S2i with S1pf
             set   r4,r4,1<ne>        ;set ne bit   
FCMPS1pfS2pi: set   r4,r4,1<le>        ;set le bit
             set    r4,r4,1<lt>        ;set lt bit
d1753 1
a1753 1
             set    r4,r4,1<ib>        ;set ib bit
d1756 1
a1756 1
             set    r4,r4,1<ob>        ;set ob bit
d1758 11
a1768 11
             set    r4,r4,1<in>        ;set in bit
FCMPS1pfS2ni: set    r4,r4,1<gt>        ;set gt bit
             br.n   move             ;return from subroutine
             set    r4,r4,1<ge>        ;set ge bit
FCMPS1nf:    bb1.n    sign,r7,FCMPS1nfS2ni ;branch to negative S2i with S1nf
             set    r4,r4,1<ne>        ;set ne bit
             set    r4,r4,1<le>        ;set gt bit
             set    r4,r4,1<lt>        ;set ge bit
             bsr.n  _zero              ;see which of the operands are zero
             set    r4,r4,1<ob>        ;set ob bit
             bb0    s1zero,r12,FCMPS1nfS2pinozero ;no ls and lo
d1770 1
a1770 1
             set    r4,r4,1<ib>        ;set ib bit
d1772 41
a1812 41
             set    r4,r4,1<ou>        ;set ou bit
FCMPS1nfS2ni: set    r4,r4,1<gt>        ;set gt bit
             set    r4,r4,1<ge>        ;set ge bit

move:	     br.n   inf_return		;return from subroutine
             or	    r6,r0,r4            ;transfer answer to r6


;Multiplying infinity and zero causes an exception, but all other
;operations produce a correctly signed infinity.

FMUL:        bsr    _zero              ;see if any of the operands are zero
             bb1    s1zero,r12,excpt   ;infinity X 0 causes an exception
             bb1    s2zero,r12,excpt   ;infinity X 0 causes an exception
             bb1    sign,r5,FMULS1neg  ;handle negative cases of S1
             bb0    sign,r7,poswrinf   ;+ X + = +
             br     negwrinf           ;+ X - = -
FMULS1neg:   bb1    sign,r7,poswrinf   ;- X - = +
             br     negwrinf           ;- X + = -


;Dividing infinity by infinity causes an exception, but dividing 
;infinity by a finite yields a correctly signed infinity, and 
;dividing a finite by an infinity produces a correctly signed zero.

FDIV:        bb1    s1inf,r12,FDIVS1inf ;handle case of S1 being infinity
             bb1    sign,r5,FDIVS1nf    ;handle cases of S1 being neg. non-inf.
             bb1    sign,r7,FDIVS1pfS2mi ;handle case of negative S2
FDIVS1pfS2pi: br    poswrzero           ;+f / +inf = +0
FDIVS1pfS2mi: br    negwrzero           ;+f / -inf = -0
FDIVS1nf:    bb1    sign,r7,FDIVS1nfS2mi ;handle case of negative S2
FDIVS1nfS2pi: br    negwrzero           ;-f / +inf = -0
FDIVS1nfS2mi: br    poswrzero           ;-f / -inf = +0
FDIVS1inf:   bb1    s2inf,r12,excpt     ;inf / inf = exception
             bb1    sign,r5,FDIVS1mi    ;handle cases of S1 being neg. inf.
             bb1    sign,r7,FDIVS1piS2nf ;handle case of negative S2
FDIVS1piS2pf: br    poswrinf            ;+inf / +f = +inf
FDIVS1piS2nf: br    negwrinf            ;+inf / -f = -inf
FDIVS1mi:    bb1    sign,r7,FDIVS1miS2nf ;handle case of negative S2
FDIVS1miS2pf: br    negwrinf            ;-inf / +f = -inf
FDIVS1miS2nf: br    poswrinf            ;-inf / -f = +inf
d1815 2
a1816 2
;The square root of positive infinity is positive infinity,
;but the square root of negative infinity is a NaN
d1818 2
a1819 2
;FSQRT:       bb0    sign,r7,poswrinf    ;write sqrt(inf) = inf
;             br     excpt               ;write sqrt(-inf) = NaN
d1822 1
a1822 1
             set    r2,r2,1<oper>      ;set invalid operation bit of FPSR
d1824 3
a1826 3
	     bb0    oper,r3,nohandler  ;branch if no user handler
             bsr    _handler           ;branch to interface with user handler
             br     inf_return             ;return from function
d1829 5
a1833 5
	     set    r5,r0,0<0>        ;write NaN into r5
             br.n   inf_return             ;return from subroutine
             set    r6,r0,0<0>        ;write NaN into r6, writing NaN''s into
                                       ;both of these registers is quicker than
                                       ;checking for single or double precision
d1836 7
a1842 7
;Write positive infinity of the correct precision

poswrinf:    bb1    dsize,r9,poswrinfd ;branch to write double precision inf.
             br.n   inf_return             ;return from subroutine
             or.u   r6,r0,0x7f80       ;load r6 with single precision pos inf.  
poswrinfd:   or.u   r5,r0,0x7ff0       ;load double precision pos inf.
             br.n   inf_return             ;return from subroutine
d1846 1
a1846 1
;Write negative infinity of the correct precision
d1848 5
a1852 5
negwrinf:    bb1    dsize,r9,negwrinfd ;branch to write double precision inf.
             br.n   inf_return             ;return from subroutine
             or.u   r6,r0,0xff80       ;load r6 with single precision pos inf.  
negwrinfd:   or.u   r5,r0,0xfff0       ;load double precision pos inf.
             br.n   inf_return             ;return from subroutine
d1856 1
a1856 1
;Write a positive zero disregarding precision.
d1858 2
a1859 2
poswrzero:   or     r5,r0,r0           ;write to both high word and low word now
             br.n   inf_return             ;it does not matter that both are written
d1863 1
a1863 1
;Write a negative zero of the correct precision.
d1865 7
a1871 7
negwrzero:   or     r6,r0,r0           ;clear low word
             bb1    dsize,r9,negwrzerod ;branch to write double precision zero
             br.n   inf_return             ;return from subroutine
             set    r6,r6,1<31>        ;set sign bit
negwrzerod:  or     r5,r0,r0           ;clear high word
             br.n   inf_return             ;return from subroutine
             set    r5,r5,1<31>        ;set sign bit
d1874 1
a1874 1
             set    r2,r2,1<oper>       ;set invalid operand bit
d1876 3
a1878 3
	     bb0    oper,r3,nohandlero  ;do not go to user handler routine
             bsr    _handler            ;go to user handler routine
             br     inf_return              ;return from subroutine
d1881 1
a1881 1
nohandlero:  bb0.n  sign,r7,inf_return      ;if positive then return from subroutine
d1883 2
a1884 2
             set    r6,r6,31<0>         ;set result to largest positive integer
             or.c   r6,r0,r6            ;negate r6,giving largest negative int.
d1886 2
a1887 2
inf_return:      ld     r1,r31,0          ;load return address
             jmp    r1                 ;return from subroutine
a1889 4
;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
d1899 3
a1901 3
;function _denorm --      
;See the documentation for this release for an overall description of this
;code.
d1903 8
d1912 80
a1991 1
             text
d1993 2
a1994 88
;Check to see if either S1 or S2 is a denormalized number.  First 
;extract the exponent to see if it is zero, and then check to see if
;the mantissa is not zero.  If the number is denormalized, then set the
;1 or 0 bit 10 r12.

_denorm:     st     r1,r31,0  ;save return address
dnmcheckS1:  extu   r10,r5,11<20>  ;extract exponent
             bcnd   ne0,r10,dnmsetS2 ;S1 is not a denorm, so S2 must be
             bb1.n  9,r9,dnmcheckS1d ;S1 is double precision
             mak    r10,r5,20<3>   ;mak field with only mantissa bits
                                   ;into final result
dnmcheckS1s: extu   r11,r6,3<29>   ;get three low bits of mantissa
             or     r10,r10,r11    ;assemble all of the mantissa bits
             bcnd   eq0,r10,dnmsetS2 ;S1 is not a denorm, so S2 must be
             br     dnmsetS1       ;S1 is a denorm

dnmcheckS1d: or     r10,r6,r10     ;or all of mantissa bits
             bcnd   eq0,r10,dnmsetS2 ;S1 is not a denorm, so S2 must be
dnmsetS1:    set    r12,r12,1<1> ;S1 is a denorm

dnmcheckS2:  extu   r10,r7,11<20>  ;extract exponent
             bcnd   ne0,r10,S1form ;S2 is not a denorm
             bb1.n  7,r9,dnmcheckS2d ;S2 is double precision
             mak    r10,r7,20<3>   ;mak field with only mantissa bits
dnmcheckS2s: extu   r11,r8,3<29>   ;get three low bits of mantissa
             or     r10,r10,r11    ;assemble all of the mantissa bits
             bcnd   eq0,r10,S1form ;S2 is not a denorm
             br     dnmsetS2       ;S1 is a denorm
dnmcheckS2d: or     r10,r8,r10     ;or all or mantissa bits
             bcnd   eq0,r10,S1form ;S2 is not a denorm
dnmsetS2:    set    r12,r12,1<0> ;S2 is a denorm


;Since the operations are going to be reperformed with modified denorms,
;the operands which were initially single precision need to be modified
;back to single precision.  

S1form:      bb1    9,r9,S2form ;S1 is double precision, so do not
                                     ;modify S1 into single format
             mak    r11,r5,28<3>   ; over final exponent and mantissa
                                   ;eliminating extra 3 bits of exponent
             extu   r6,r6,3<29>    ;get low 3 bits of mantissa
             or     r11,r6,r11     ;form complete mantissa and exponent
             extu   r10,r5,1<31> ;get the 31 bit
             mak    r10,r10,1<31>  ;place 31 bit 10 correct position
             or     r6,r10,r11     ;or 31, exponent, and all of mantissa

S2form:      bb1    7,r9,checkop ;S2 is double precision, so do not
                                      ;modify S2 into single format
             mak    r11,r7,28<3>   ; over final exponent and mantissa
                                   ;eliminating extra 3 bits of exponent
             extu   r8,r8,3<29>    ;get low 3 bits of mantissa
             or     r11,r8,r11     ;form complete mantissa and exponent
             extu   r10,r7,1<31> ;get the 31 bit
             mak    r10,r10,1<31>  ;place 31 bit 10 correct position
             or     r8,r10,r11     ;or 31, exponent, and all of mantissa


;Extract the opcode, compare to a constant, and branch to the code that
;deals with that opcode.

checkop:     extu   r10,r9,5<11>   ;extract opcode
             cmp    r11,r10,0x05 ;compare to FADD
             bb1    2,r11,FADD    ;operation is FADD
             cmp    r11,r10,0x06 ;compare to FSUB
             bb1    2,r11,FSUB    ;operation is FSUB
             cmp    r11,r10,0x07 ;compare to FCMP
             bb1    2,r11,FCMP    ;operation is FCMP
             cmp    r11,r10,0x00 ;compare to FMUL
             bb1    2,r11,FMUL    ;operation is FMUL
             cmp    r11,r10,0x0e ;compare to FDIV
             bb1    2,r11,FDIV    ;operation is FDIV
;             cmp    r11,r10,0x0f;compare to FSQRT
;             bb1    2,r11,FSQRT   ;operation is FSQRT
             cmp    r11,r10,0x09  ;compare to INT
             bb1    2,r11,INT     ;operation is INT
             cmp    r11,r10,0x0a ;compare to NINT
             bb1    2,r11,NINT    ;operation is NINT
             cmp    r11,r10,0x0b ;compare to TRNC
             bb1    2,r11,TRNC    ;operation is TRNC


;For all the following operations, the denormalized number is set to
;zero and the operation is reperformed the correct destination and source
;sizes.

FADD:        bb0    1,r12,FADDS2dnm ;S1 is not denorm, so S2 must be
             or     r5,r0,r0     ;set S1 to zero
d1996 2
a1997 2
FADDS2chk:   bb0    0,r12,FADDcalc ;S2 is not a denorm
FADDS2dnm:   or     r7,r0,r0     ;set S2 to zero
d1999 23
a2021 23
FADDcalc:    bb1    5,r9,FADDdD   ;branch for double precision destination
FADDsD:      bb1    9,r9,FADDsDdS1 ;branch for double precision S1
FADDsDsS1:   bb1    7,r9,FADDsDsS1dS2 ;branch for double precision S2
FADDsDsS1sS2: br.n  return      ;return from subroutine
              fadd.sss r6,r6,r8   ;add the two sources and place result 10 S1
FADDsDsS1dS2: br.n  return      ;return from subroutine
              fadd.ssd r6,r6,r7   ;add the two sources and place result 10 S1
FADDsDdS1:   bb1    7,r9,FADDsDdS1dS2 ;branch for double precision S2
FADDsDdS1sS2: br.n  return      ;return from subroutine
              fadd.sds r6,r5,r8   ;add the two sources and place result 10 S1
FADDsDdS1dS2: br.n  return      ;return from subroutine
              fadd.sdd r6,r5,r7   ;add the two sources and place result 10 S1
FADDdD:      bb1    9,r9,FADDdDdS1 ;branch for double precision S1
FADDdDsS1:   bb1    7,r9,FADDdDsS1dS2 ;branch for double precision S2
FADDdDsS1sS2: br.n  return      ;return from subroutine
              fadd.dss r5,r6,r8   ;add the two sources and place result 10 S1
FADDdDsS1dS2: br.n  return      ;return from subroutine
              fadd.dsd r5,r6,r7   ;add the two sources and place result 10 S1
FADDdDdS1:   bb1    7,r9,FADDdDdS1dS2 ;branch for double precision S2
FADDdDdS1sS2: br.n  return      ;return from subroutine
              fadd.dds r5,r5,r8   ;add the two sources and place result 10 S1
FADDdDdS1dS2: br.n  return      ;return from subroutine
              fadd.ddd r5,r5,r7   ;add the two sources and place result 10 S1
d2023 2
a2024 2
FSUB:        bb0    1,r12,FSUBS2dnm ;S1 is not denorm, so S2 must be
             or     r5,r0,r0     ;set S1 to zero
d2026 2
a2027 2
FSUBS2chk:   bb0    0,r12,FSUBcalc ;S2 is not a denorm
FSUBS2dnm:   or     r7,r0,r0     ;set S2 to zero
d2029 23
a2051 23
FSUBcalc:    bb1    5,r9,FSUBdD   ;branch for double precision destination
FSUBsD:      bb1    9,r9,FSUBsDdS1 ;branch for double precision S1
FSUBsDsS1:   bb1    7,r9,FSUBsDsS1dS2 ;branch for double precision S2
FSUBsDsS1sS2: br.n  return      ;return from subroutine
              fsub.sss r6,r6,r8   ;add the two sources and place result 10 S1
FSUBsDsS1dS2: br.n  return      ;return from subroutine
              fsub.ssd r6,r6,r7   ;add the two sources and place result 10 S1
FSUBsDdS1:   bb1    7,r9,FSUBsDdS1dS2 ;branch for double precision S2
FSUBsDdS1sS2: br.n  return      ;return from subroutine
              fsub.sds r6,r5,r8   ;add the two sources and place result 10 S1
FSUBsDdS1dS2: br.n  return      ;return from subroutine
              fsub.sdd r6,r5,r7   ;add the two sources and place result 10 S1
FSUBdD:      bb1    9,r9,FSUBdDdS1 ;branch for double precision S1
FSUBdDsS1:   bb1    7,r9,FSUBdDsS1dS2 ;branch for double precision S2
FSUBdDsS1sS2: br.n  return      ;return from subroutine
              fsub.dss r5,r6,r8   ;add the two sources and place result 10 S1
FSUBdDsS1dS2: br.n  return      ;return from subroutine
              fsub.dsd r5,r6,r7   ;add the two sources and place result 10 S1
FSUBdDdS1:   bb1    7,r9,FSUBdDdS1dS2 ;branch for double precision S2
FSUBdDdS1sS2: br.n  return      ;return from subroutine
              fsub.dds r5,r5,r8   ;add the two sources and place result 10 S1
FSUBdDdS1dS2: br.n  return      ;return from subroutine
              fsub.ddd r5,r5,r7   ;add the two sources and place result 10 S1
d2053 2
a2054 2
FCMP:        bb0    1,r12,FCMPS2dnm ;S1 is not denorm, so S2 must be
             or     r5,r0,r0     ;set S1 to zero
d2056 2
a2057 2
FCMPS2chk:   bb0    0,r12,FCMPcalc ;S2 is not a denorm
FCMPS2dnm:   or     r7,r0,r0     ;set S2 to zero
d2059 11
a2069 11
FCMPcalc:    bb1    9,r9,FCMPdS1 ;branch for double precision S1
FCMPsS1:     bb1    7,r9,FCMPsS1dS2 ;branch for double precision S2
FCMPsS1sS2:  br.n  return      ;return from subroutine
             fcmp.sss r6,r6,r8   ;add the two sources and place result 10 S1
FCMPsS1dS2:  br.n  return      ;return from subroutine
             fcmp.ssd r6,r6,r7   ;add the two sources and place result 10 S1
FCMPdS1:     bb1    7,r9,FCMPdS1dS2 ;branch for double precision S2
FCMPdS1sS2:  br.n  return      ;return from subroutine
             fcmp.sds r6,r5,r8   ;add the two sources and place result 10 S1
FCMPdS1dS2:  br.n  return      ;return from subroutine
             fcmp.sdd r6,r5,r7   ;add the two sources and place result 10 S1
d2071 2
a2072 2
FMUL:        bb0    1,r12,FMULS2dnm ;S1 is not denorm, so S2 must be
             or     r5,r0,r0     ;set S1 to zero
d2074 2
a2075 2
FMULS2chk:   bb0    0,r12,FMULcalc ;S2 is not a denorm
FMULS2dnm:   or     r7,r0,r0     ;set S2 to zero
d2077 23
a2099 23
FMULcalc:    bb1    5,r9,FMULdD   ;branch for double precision destination
FMULsD:      bb1    9,r9,FMULsDdS1 ;branch for double precision S1
FMULsDsS1:   bb1    7,r9,FMULsDsS1dS2 ;branch for double precision S2
FMULsDsS1sS2: br.n  return      ;return from subroutine
              fmul.sss r6,r6,r8   ;add the two sources and place result 10 S1
FMULsDsS1dS2: br.n  return      ;return from subroutine
              fmul.ssd r6,r6,r7   ;add the two sources and place result 10 S1
FMULsDdS1:   bb1    7,r9,FMULsDdS1dS2 ;branch for double precision S2
FMULsDdS1sS2: br.n  return      ;return from subroutine
              fmul.sds r6,r5,r8   ;add the two sources and place result 10 S1
FMULsDdS1dS2: br.n  return      ;return from subroutine
              fmul.sdd r6,r5,r7   ;add the two sources and place result 10 S1
FMULdD:      bb1    9,r9,FMULdDdS1 ;branch for double precision S1
FMULdDsS1:   bb1    7,r9,FMULdDsS1dS2 ;branch for double precision S2
FMULdDsS1sS2: br.n  return      ;return from subroutine
              fmul.dss r5,r6,r8   ;add the two sources and place result 10 S1
FMULdDsS1dS2: br.n  return      ;return from subroutine
              fmul.dsd r5,r6,r7   ;add the two sources and place result 10 S1
FMULdDdS1:   bb1    7,r9,FMULdDdS1dS2 ;branch for double precision S2
FMULdDdS1sS2: br.n  return      ;return from subroutine
              fmul.dds r5,r5,r8   ;add the two sources and place result 10 S1
FMULdDdS1dS2: br.n  return      ;return from subroutine
              fmul.ddd r5,r5,r7   ;add the two sources and place result 10 S1
d2101 2
a2102 2
FDIV:        bb0    1,r12,FDIVS2dnm ;S1 is not denorm, so S2 must be
             or     r5,r0,r0     ;set S1 to zero
d2104 2
a2105 2
FDIVS2chk:   bb0    0,r12,FDIVcalc ;S2 is not a denorm
FDIVS2dnm:   or     r7,r0,r0     ;set S2 to zero
d2107 37
a2143 37
FDIVcalc:    bb1    5,r9,FDIVdD   ;branch for double precision destination
FDIVsD:      bb1    9,r9,FDIVsDdS1 ;branch for double precision S1
FDIVsDsS1:   bb1    7,r9,FDIVsDsS1dS2 ;branch for double precision S2
FDIVsDsS1sS2: fdiv.sss r6,r6,r8   ;add the two sources and place result 10 S1
	      br  return      ;return from subroutine
FDIVsDsS1dS2: fdiv.ssd r6,r6,r7   ;add the two sources and place result 10 S1
              br    return      ;return from subroutine
FDIVsDdS1:   bb1    7,r9,FDIVsDdS1dS2 ;branch for double precision S2
FDIVsDdS1sS2: fdiv.sds r6,r5,r8   ;add the two sources and place result 10 S1
	      br    return      ;return from subroutine
FDIVsDdS1dS2: fdiv.sdd r6,r5,r7   ;add the two sources and place result 10 S1
	      br    return      ;return from subroutine
FDIVdD:      bb1    9,r9,FDIVdDdS1 ;branch for double precision S1
FDIVdDsS1:   bb1    7,r9,FDIVdDsS1dS2 ;branch for double precision S2
FDIVdDsS1sS2: fdiv.dss r5,r6,r8   ;add the two sources and place result 10 S1
	      br    return      ;return from subroutine
FDIVdDsS1dS2: fdiv.dsd r5,r6,r7   ;add the two sources and place result 10 S1
	      br    return      ;return from subroutine
FDIVdDdS1:   bb1    7,r9,FDIVdDdS1dS2 ;branch for double precision S2
FDIVdDdS1sS2: fdiv.dds r5,r5,r8   ;add the two sources and place result 10 S1
	      br    return      ;return from subroutine
FDIVdDdS1dS2: fdiv.ddd r5,r5,r7   ;add the two sources and place result 10 S1
	      br    return      ;return from subroutine

;FSQRT:       or     r7,r0,r0     ;set S2 to zero
;             or     r8,r0,r0
;FSQRTcalc:   bb1    5,r9,FSQRTdD   ;branch for double precision destination
;FSQRTsD:     bb1    7,r9,FSQRTsDdS2 ;branch for double precision S2
;FSQRTsDsS2:  br.n   return   ;return from subroutine
            ;fsqrt.ss r6,r8   ;add the two sources and place result 10 S1
;FSQRTsDdS2:  br.n   return   ;return from subroutine
            ;fsqrt.sd r6,r7   ;add the two sources and place result 10 S1
;FSQRTdD:     bb1    7,r9,FSQRTdDdS2 ;branch for double precision S2
;FSQRTdDsS2:  br.n   return   ;return from subroutine
            ;fsqrt.ds r5,r8   ;add the two sources and place result 10 S1
;FSQRTdDdS2:  br.n   return   ;return from subroutine
            ;fsqrt.dd r5,r7   ;add the two sources and place result 10 S1
d2145 1
a2145 1
INT:         or     r7,r0,r0     ;set S2 to zero
d2147 5
a2151 5
INTcalc:     bb1    7,r9,INTdS2 ;branch for double precision S2
INTsS2:      br.n   return   ;return from subroutine
             int.ss r6,r8    ;add the two sources and place result 10 S1
INTdS2:      br.n   return   ;return from subroutine
             int.sd r6,r7   ;add the two sources and place result 10 S1
d2153 1
a2153 1
NINT:        or     r7,r0,r0     ;set S2 to zero
d2155 5
a2159 5
NINTcalc:    bb1    7,r9,NINTdS2 ;branch for double precision S2
NINTsS2:     br.n   return   ;return from subroutine
             nint.ss r6,r8    ;add the two sources and place result 10 S1
NINTdS2:     br.n   return   ;return from subroutine
             nint.sd r6,r7   ;add the two sources and place result 10 S1
d2161 1
a2161 1
TRNC:        or     r7,r0,r0     ;set S2 to zero
d2163 4
a2166 4
TRNCcalc:    bb1    7,r9,TRNCdS2 ;branch for double precision S2
TRNCsS2:     br.n   return   ;return from subroutine
             trnc.ss r6,r8    ;add the two sources and place result 10 S1
TRNCdS2:     trnc.sd r6,r7   ;add the two sources and place result 10 S1
d2169 1
a2169 1
;Return to the routine that detected the reserved operand.
d2171 2
a2172 2
return:      ld     r1,r31,0    ;load return address
             jmp    r1                 ;return from subroutine
a2174 4
;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
a2175 5
#ifndef __LUNA_SUB_H__
#include "luna_sub.h"
#endif
             global _zero
             text
d2177 2
a2178 2
;S1 and/or S2 is an infinity, and the other operand may be a zero.
;Knowing which operands are infinity, check the remaining operands for zeros.
d2180 50
a2229 47
_zero:       bb0    s1inf,r12,S1noinf ;see if S1 is zero
             bb0    s2inf,r12,S2noinf ;see if S2 is zero
             jmp    r1                ;return from function

;See if S1 is zero.  Whether or not S1 is a zero, being in this routine
;implies that S2 is infinity, so return to subroutine infinity after 
;completing this code.  Set the s1zero flag in r12 if S1 is zero.

S1noinf:     bb1    s1size,r9,S1noinfd ;work with double precision operand
S1noinfs:    or     r10,r0,r5          ;load high word into r10
             clr    r10,r10,1<sign>    ;clear the sign bit
             extu   r11,r6,3<29>       ;extract lower 3 bits of mantissa
             or     r10,r10,r11        ;or these 3 bits with high word
             bcnd   ne0,r10,operation  ;do not set zero flag
             jmp.n  r1                 ;since this operand was not infinity,
                                       ;S2 must have been, so return from
                                       ;function
             set    r12,r12,1<s1zero>  ;set zeroflag
S1noinfd:    clr    r10,r5,1<sign>     ;clear the sign bit
             or     r10,r6,r10         ;or high and low word
             bcnd   ne0,r10,operation  ;do not set zero flag
             jmp.n  r1                 ;since this operand was not infinity,
                                       ;S2 must have been, so return from
                                       ;function
             set    r12,r12,1<s1zero>  ;set zeroflag


;Check S2 for zero.  If it is zero, then set the s2zero flag in r12.

S2noinf:     bb1    s2size,r9,S2noinfd ;work with double precision operand
S2noinfs:    or     r10,r0,r7          ;load high word into r10
             clr    r10,r10,1<sign>    ;clear the sign bit
             extu   r11,r8,3<29>       ;extract lower 3 bits of mantissa
             or     r10,r10,r11        ;or these 3 bits with high word
             bcnd   ne0,r10,operation  ;do not set zero flag
             jmp.n  r1                 ;since this operand was not infinity,
                                       ;S1 must have been, so return from
                                       ;function
             set    r12,r12,1<s2zero>  ;set zeroflag
S2noinfd:    clr    r10,r7,1<sign>     ;clear the sign bit
             or     r10,r8,r10         ;or high and low word
             bcnd   ne0,r10,operation  ;do not set zero flag
             set    r12,r12,1<s2zero>  ;set zeroflag
                                       ;since this operand was not infinity,
                                       ;S1 must have been, so return from
                                       ;function
operation:   jmp    r1                 ;return from function
a2231 4
;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
d2234 2
a2235 2
		align 4
; input: r3 is the excepton frame
d2237 1
a2237 1
		or	r29, r3, r0	; r29 is now the E.F.
d2249 2
a2250 2
;Load into r1 the return address for the exception handlers.  Looking
;at FPECR, branch to the appropriate exception handler.
d2252 1
a2252 1
		or.u	r1,r0,hi16(fpui_wrapup);load return address of functions
d2255 1
a2255 1
		bb0  	2,r4,2f ;branch to FPunderflow if bit set
d2257 1
a2257 1
	2:	bb0	1,r4,3f ;branch to FPoverflow if bit set
d2261 2
a2262 2
		br	_handler	;branch to handler since bit will be set
					;for inexact
d2266 1
a2266 1
	align 4
d2268 1
a2268 1
	align 4
d2279 4
a2282 4
        tb1     0,r0,0          ;make sure all floating point operations
        ldcr    r5, psr        ;load the PSR
        ;have finished
        or      r5, r5, 0x2   ;disable interrupts
d2286 1
a2286 1
        or      r5, r5, 0x8   ;set SFU 1 disable bit, disable SFU 1
d2293 1
a2293 1
	; write back the results
d2302 1
a2302 1
;Return..
@


1.1
log
@moved from m88k directory
@
text
@@


1.1.1.1
log
@Third try at importing the mvme88k port. This is a working kernel
from nivas.
Userland and compiler still need to be worked on.
Make certain what directory the import is done from.
@
text
@d26 2
d32 6
a37 1
#define LOCORE
d39 3
a41 1
#define ASSEMBLER
d43 6
a48 2
#include <machine/trap.h>
#include <machine/asm.h>
d125 57
a181 1

d189 20
d210 6
d219 1
a219 1
	align 8
d222 1
a222 1
	or	r29, r3, r0     /*  r29 is now the E.F. */
d237 5
a241 5
	/* Load into r1 the return address for the 0 handlers.  Looking */
	/* at FPECR, branch to the appropriate 0 handler.  However, */
	/* if none of the 0 bits are enabled, then a floating point */
	/* instruction was issued with the floating point unit disabled.  This */
	/* will cause an unimplemented opcode 0. */
d243 1
a243 1
	or.u	r1,r0,hi16(wrapup) /* load return address of function  */
d245 1
a245 1
2:   	bb0	6,r4, 3f   	/* branch to FPunimp if bit set */
d247 1
a247 1
3:	bb0	7,r4, 4f 	/* branch to FPintover if bit set */
d249 3
a251 3
4: /* 	bb0	5,r4, 5f 	;branch to FPpriviol if bit set */
   /* 	br	_FPpriviol */
5: 	bb0	4,r4, 6f 	/* branch to FPresoper if bit set */
d253 1
a253 1
6:   	bb0	3,r4, 7f 	/* branch to FPdivzero if bit set */
d270 5
a274 5
	/* To write back the results to the user registers, disable exceptions */
	/* and the floating point unit.  Write FPSR and FPCR and load the SNIP */
	/* and SFIP. */
	/* r5 will contain the upper word of the result */
	/* r6 will contain the lower word of the result */
d277 4
a280 4
	tb1	0,r0,0          /* make sure all floating point operations */
	/* have finished */
	ldcr	r10, cr1        /* load the PSR */
	or	r10, r10, 0x2   /* disable interrupts */
d284 1
a284 1
	or	r10, r10, 0x8 /* set SFU 1 disable bit, disable SFU 1 */
d291 2
a292 2
	fstcr	r2, fpsr	/* write revised value of FPSR */
	fstcr	r3, fpcr	/* write revised value of FPCR */
d294 1
a294 1
	/* result writeback routine */
d296 2
a297 2
	extu   r2, r9, 5<0>       /* get 5 bits of destination register */
	bb0    5, r9, writesingle /* branch if destination is single */
d299 5
a303 5
/* writedouble here */
	st     r5, r3 [r2]       /* write high word */
	add    r2, r2, 1          /* for double, the low word is the  */
	/* unspecified register */
	clr    r2, r2, 27<5>      /* perform equivalent of mod 32 */
d305 1
a305 1
	st     r6, r3 [r2]       /* write low word into memory */
d309 4
d314 3
a317 1
	     align 8
d321 2
a322 2
/* Check if the numerator is zero.  If the numerator is zero, then handle */
/* this instruction as you would a 0/0 invalid operation. */
d325 2
a326 2
             st    r1,r31,0  /* save return address */
	     bb1   s1size,r9,1f  /* branch if numerator double */
d328 6
a333 6
  	     clr   r10,r5,1<sign>   /* clear sign bit */
             extu  r11,r6,3<29>     /* grab upper bits of lower word */
             or    r10,r10,r11      /* combine ones of mantissa */
             bcnd  eq0,r10,resoper  /* numerator is zero, handle reserved */
                                    /* operand  */
             br    setbit           /* set divzero bit */
d336 7
a342 7
	     clr   r10,r5,1<sign>   /* clear sign bit */
             or    r10,r10,r6       /* or high and low words */
             bcnd  ne0,r10,setbit   /* set divzero bit */

/* The numerator is zero, so handle the invalid operation by setting the */
/* invalid operation bit and branching to the user handler if there is one */
/* or writing a quiet NaN to the destination. */
d345 1
a345 1
             set   r2,r2,1<oper>    /* set bit in FPSR */
d347 4
a350 4
	     bb0   oper,r3,noreshand /* branch to execute default handling for */
                                    /* reserved operands */
             bsr   _handler         /* branch to user handler */
             br    FP_div_return           /* return from function */
d354 10
a363 10
 	     set   r5,r0,0<0>      /* put a NaN in high word */
             set   r6,r0,0<0>      /* put a NaN in low word */
             br  FP_div_return            /* return from subroutine */
                                   /* writing to a word which may be ignored */
                                   /* is just as quick as checking the precision */
                                   /* of the destination */

/* The operation is divide by zero, so set the divide by zero bit in the */
/* FPSR.  If the user handler is set, then go to the user handler, else */
/* go to the default mode. */
d367 4
a370 4
             set   r2,r2,1<divzero> /* set bit in FPSR */
             bb0   divzero,r3,default /* go to default routine if no handler */
             bsr   _handler         /* execute handler routine */
             br    FP_div_return           /* return from subroutine */
d374 2
a375 2
/* Considering the sign of the numerator and zero, write a correctly */
/* signed infinity of the proper precision into the destination. */
d378 1
a378 1
	     bb1   dsize,r9,FPzero_double  /* branch to handle double result */
d380 5
a384 5
   	     clr   r10,r5,31<0>     /* clear all of S1HI except sign bit */
             xor   r10,r7,r10       /* xor the sign bits of the operands */
             or.u  r6,r0,0x7f80     /* load single precision infinity */
             br.n  FP_div_return           /* return from subroutine */
             or    r6,r6,r10        /* load correctly signed infinity */
d387 5
a391 5
             clr   r10,r5,31<0>     /* clear all of S1HI except sign bit */
             xor   r10,r7,r10       /* xor the sign bits of the operands */
             or.u  r5,r0,0x7ff0     /* load double precision infinity */
             or    r5,r5,r10        /* load correctly signed infinity */
             or    r6,r0,r0         /* clear lower word of double */
d394 6
a399 2
	     ld    r1,r31,0  /* load return address */
             jmp   r1               /* return from subroutine */
d401 4
d407 4
a410 5
/* Both NINT and TRNC require a certain rounding mode, so check which */
/* instruction caused the integer conversion overflow.  Use a substitute */
/* FPCR in r1, and modify the rounding mode if the instruction is NINT or TRNC. */
	text
	align 8
d412 110
a521 110
	extu   r10,r9,5<11>         /* extract opcode */
	cmp    r11,r10,INTop        /* see if instruction is INT */
	st     r1,r31,0      /* save return address */
	bb1.n  eq,r11,checksize     /* instruction is INT, do not modify */
	/* rounding mode */
	or     r1,r0,r3             /* load FPCR into r1 */
	cmp    r11,r10,NINTop       /* see if instruction is NINT */
	bb1    eq,r11,NINT          /* instruction is NINT */
	
TRNC:   clr    r1,r1,2<rndlo>          /* clear rounding mode bits, */
					/* instruction is TRNC */
	br.n   checksize            /* branch to check size */
	set    r1,r1,1<rndlo>          /* make rounding mode round towards zero */
	
NINT:   clr    r1,r1,2<rndlo>          /* make rounding mode round to nearest */
	
	
/* See whether the source is single or double precision. */
	
checksize:   bb1    s2size,r9,checkdoub  /* S2 is double, branch to see if there */
/* is a false alarm */
	
	
/* An integer has more bits than the mantissa of a single precision floating */
/* point number, so to check for false alarms (i.e. valid conversion), simply */
/* check the exponents.  False alarms are detected for 2**30 to (2**30) - 1 and */
/* -2**30 to -2**31.  Only seven bits need to be looked at since an exception */
/* will not occur for the other half of the numbering system. */
/* To speed up the processing, first check to see if the exponent is 32 or */
/* greater. */

/* This code was originally written for the exponent in the control */
/* register to have the most significant bit (8 - single, 11 - double)  */
/* flipped and sign extended.  For precise exceptions, however, the most */
/* significant bit is only sign extended.  Therefore, the code was chopped */
/* up so that it would work for positive values of real exponent which were */
/* only sign extended. */
	
checksing:   extu   r10,r7,7<20>         /* internal representation for single */
/* precision is IEEE 8 bits sign extended */
/* to 11 bits; for real exp. = 30, the */
/* above instruction gives a result exp. */
/* that has the MSB flipped and sign */
/* extended like in the IMPCR */
	cmp    r11,r10,31           /* compare to 32,but exp. off by 1 */
/* these 2 instructions to speed up valid */
/* execution of valid cases */
	bb1    ge,r11,overflw       /* valid case, perform overflow routine */
	bb1    sign,r7,checksingn   /* source operand is negative */
	
/* If the number is positve and the exponent is greater than 30, than it is */
	/* overflow. */
	
checksingp:  cmp    r10,r10,29           /* compare to 30, but exp. off by 1 */
	bb1    gt,r10,overflw       /* no false alarm, its overflow */
	br     conversionsp         /* finish single precision conversion */
	
/* If the number is negative, and the exponent is 30, or 31 with a mantissa */
/* of 0, then it is a false alarm. */
	
checksingn:  cmp    r11,r10,30           /* compare to 31,but exp. off by 1 */
	bb1    lt,r11,conversionsn  /* exp. less than 31, so convert */
	extu   r10,r8,3<29>         /* get upper three bits of lower mantissa */
	mak    r12,r7,20<3>         /* get upper 20 bits of mantissa */
	or     r10,r10,r12          /* form complete mantissa */
	bcnd   eq0,r10,conversionsn /* complete conversion if mantissa is 0 */
	br     overflw              /* no false alarm, its overflow */
	
	
/* False alarms are detected for 2**30 to (2**30) - 1 and */
/* -2**30 to -2**31.  Only seven bits need to be looked at since an exception */
/* will not occur for the other half of the numbering system. */
/* To speed up the processing, first check to see if the exponent is 32 or */
/* greater.  Since there are more mantissa bits than integer bits, rounding */
/* could cause overflow.  (2**31) - 1 needs to be checked so that it does */
/* not round to 2**31, and -2**31 needs to be checked in case it rounds to */
/* -((2**31) + 1). */
	
checkdoub:   extu   r10,r7,10<20>        /* internal representation for double */
/* precision is the same IEEE 11 bits  */
/* for real exp. = 30, the */
/* above instruction gives a result exp. */
/* that has the MSB flipped and sign */
/* extended like in the IMPCR */
	cmp    r11,r10,31           /* compare to 32,but exp. off by 1 */
/* these 2 instructions to speed up valid */
/* execution of valid cases */
	bb1    ge,r11,overflw       /* valid case, perform overflow routine */
	bb1    sign,r7,checkdoubn   /* source operand is negative */
	
/* If the exponent is not 31, then the floating point number will be rounded */
/* before the conversion is done.  A branch table is set up with bits 4 and 3 */
/* being the rounding mode, and bits 2, 1, and 0 are the guard, round, and  */
/* sticky bits. */
	
checkdoubp:  cmp    r11,r10,30           /* compare to 31, but exponent off by 1 */
	bb1    eq,r11,overflw       /* no false alarm, its overflow */
	extu   r12,r8,1<22>         /* get LSB for integer with exp. = 30 */
	mak    r12,r12,1<2>         /* start to set up field for branch table */
	extu   r11,r8,1<21>         /* get guard bit */
	mak    r11,r11,1<1>         /* set up field for branch table */
	or     r12,r11,r12          /* set up field for branch table */
	extu   r11,r8,21<0>         /* get bits for sticky bit */
	bcnd   eq0,r11,nostickyp    /* do not set sticky */
	set    r12,r12,1<0>         /* set sticky bit */
nostickyp:   rot    r11,r1,0<rndlo>      /* shift rounding mode to 2 LSB''s */
	mak    r11,r11,2<3>         /* set up field, clear other bits */
	or     r12,r11,r12          /* set up field for branch table */
	lda    r12,r0[r12]          /* scale r12 */
	or.u   r12,r12,hi16(ptable) /* load pointer into table */
d523 1
a523 1
	jmp    r12                  /* jump into branch table */
d558 113
a670 113
/* Add one to the bit of the mantissa which corresponds to the LSB of an */
/* integer.  If the mantissa overflows, then there is a valid integer */
/* overflow conversion; otherwise, the mantissa can be converted to the integer. */
	
paddone:     or     r10,r0,r0           /* clear r10 */
	set    r10,r10,1<22>       /* set LSB bit to 1 for adding */
	addu.co r8,r8,r10          /* add the 1 obtained from rounding */
	clr    r11,r7,12<20>       /* clear exponent and sign */
	addu.ci r11,r0,r11         /* add carry */
	bb1    20,r11,overflw      /* overflow to 2**31, abort the rest */
	br.n   conversiondp        /* since the exp. was 30, and the exp. */
	/* did not round up to 31, the largest */
	/* number that S2 could become is 2**31-1 */
	or     r7,r0,r11           /* store r11 into r7 for conversion */
	
/* Now check for negative double precision sources.  If the exponent is 30, */
/* then convert the false alarm.  If the exponent is 31, then check the mantissa */
/* bits which correspond to integer bits.  If any of them are a one, then there */
/* is overflow.  If they are zero, then check the guard, round, and sticky bits. */
/* Round toward zero and positive will not cause a roundup, but round toward */
/* nearest and negative may, so perform those roundings.  If there is no overflow, */
	/* then convert and return from subroutine. */
	
checkdoubn:  cmp    r11,r10,29           /* compare to 30, but exp. off by 1 */
	bb1    eq,r11,conversiondn  /* false alarm if exp. = 30 */
	extu   r10,r8,11<21>        /* check upper bits of lower mantissa */
	bcnd   ne0,r10,overflw      /* one of the bits is a 1, so overflow */
	extu   r10,r7,20<0>         /* check upper bits of upper mantissa */
	bcnd   ne0,r10,overflw      /* one of the bits is a 1, so overflow */
	bb0    rndlo,r1,possround      /* rounding mode is either round near or */
	/* round negative, which may cause a */
	/* round */
	br.n   FPintov_return               /* round positive, which will not cause a */
	/* round */
	set    r6,r0,1<sign>        /* rounding mode is either round zero or */
possround:   extu   r12,r8,1<20>         /* get guard bit */
	extu   r11,r8,20<0>         /* get bits for sticky bit */
	bcnd.n eq0,r11,nostickyn    /* do not set sticky */
	mak    r12,r12,1<1>         /* set up field for branch table */
	set    r12,r12,1<0>         /* set sticky bit */
nostickyn:   bb1    rndhi,r1,negative    /* rounding mode is negative */
nearest:     cmp    r12,r12,3            /* are both guard and sticky set */
	bb1    eq,r12,overflw       /* both guard and sticky are set, */
	/* so signal overflow */
	or     r6,r0,r0             /* clear destination register r6 */
	br.n   FPintov_return               /* return from subroutine */
	set    r6,r6,1<sign>        /* set the sign bit and take care of */
	/* this special case */
negative:    bcnd   ne0,r12,overflw      /* -2**31 will be rounded to -(2**31+1), */
	/* so signal overflow */
	or     r6,r0,r0             /* clear destination register r6 */
	br.n   FPintov_return               /* return from subroutine */
	set    r6,r6,1<sign>        /* set the sign bit and take care of */
	/* this special case */
	
	/* since the exp. was 30, and there was */
	/* no round-up, the largest number that */
	/* S2 could have been was 2**31 - 1 */
	
	
	/* Convert the single precision positive floating point number. */
	
conversionsp: extu  r6,r8,3<29>         /* extract lower bits of integer */
	mak   r6,r6,3<7>           /* shift left to correct place in integer */
	mak   r10,r7,20<10>        /* shift left upper bits of integer */
	or    r6,r6,r10            /* form most of integer */
	br.n  FPintov_return               /* return from subroutine */
	set   r6,r6,1<30>          /* set hidden one */
	
	
	/* Convert the single precision negative floating point number. */
	
conversionsn: bb1   eq,r11,exp31s       /* use old r11 to see if exp. is 31 */
	extu  r6,r8,3<29>          /* extract lower bits of mantissa */
	mak   r6,r6,3<7>           /* shift left to correct place in integer */
	mak   r10,r7,20<10>        /* shift left upper bits of integer */
	or    r6,r6,r10            /* form most of integer */
	set   r6,r6,1<30>          /* set hidden one */
	or.c  r6,r0,r6             /* negate result */
	br.n  FPintov_return               /* return from subroutine */
	addu  r6,r6,1              /* add 1 to get 2''s complement */
exp31s:      or    r6,r0,r0             /* clear r6 */
	br.n  FPintov_return               /* return from subroutine */
	set   r6,r6,1<sign>        /* set sign bit */
	
	
	/* Convert the double precision positive floating point number. */
	
conversiondp: extu r6,r8,10<22>         /* extract lower bits of integer */
	mak   r10,r7,20<10>        /* shift left upper bits of integer */
	or    r6,r6,r10            /* form most of integer */
	br.n  FPintov_return               /* return from subroutine */
	set   r6,r6,1<30>          /* set hidden one */
	
	
	/* Convert the double precision negative floating point number.  The number, */
	/* whose exponent is 30, must be rounded before converting.  Bits 4 and 3 are */
	/* the rounding mode, and bits 2, 1, and 0 are the guard, round, and sticky */
	/* bits for the branch table. */
	
conversiondn: extu   r12,r8,1<22>       /* get LSB for integer with exp. = 30 */
	mak    r12,r12,1<2>        /* start to set up field for branch table */
	extu   r11,r8,1<21>        /* get guard bit */
	mak    r11,r11,1<1>        /* set up field for branch table */
	or     r12,r11,r12         /* set up field for branch table */
	extu   r11,r8,21<0>        /* get bits for sticky bit */
	bcnd   eq0,r11,nostkyn     /* do not set sticky */
	set    r12,r12,1<0>        /* set sticky bit */
nostkyn:     rot    r11,r1,0<rndlo>     /* shift rounding mode to 2 LSB''s */
	mak    r11,r11,2<3>        /* set up field, clear other bits */
	or     r12,r11,r12         /* set up field for branch table */
	lda    r12,r0[r12]         /* scale r12 */
	or.u   r12,r12,hi16(ntable)/* load pointer into table */
d672 1
a672 1
	jmp    r12                 /* jump into branch table */
d708 2
a709 2
	/* Add one to the mantissa, and check to see if it overflows to -2**31. */
/* The conversion is done in nnoaddone:. */
d711 23
a733 23
naddone:     or     r10,r0,r0           /* clear r10 */
	set    r10,r10,1<22>       /* set LSB bit to 1 for adding */
	add.co r8,r8,r10           /* add the 1 obtained from rounding */
	clr    r7,r7,12<20>        /* clear exponent and sign */
	add.ci r7,r0,r7            /* add carry */
	bb1    20,r7,maxneg        /* rounded to -2**31,handle separately */
	/* the exponent was originally 30 */
nnoaddone:   extu   r6,r8,11<22>        /* extract lower bits of integer */
	mak    r10,r7,20<10>       /* shift left upper bits of integer */
	or     r6,r6,r10           /* form most of integer */
	set    r6,r6,1<30>         /* set hidden one */
	or.c   r6,r0,r6            /* negate integer */
	br.n   FPintov_return              /* return from subroutine */
	addu   r6,r6,1             /* add 1 to get 2''s complement */
	
maxneg:      or     r6,r0,r0            /* clear integer */
	br.n   FPintov_return              /* return from subroutine */
	set    r6,r6,1<sign>       /* set sign bit */
	
	
	/* For valid overflows, check to see if the integer overflow user handler is  */
	/* set.  If it is set, then go to user handler, else write the correctly */
	/* signed largest integer. */
d737 4
a740 4
	bb0.n  oper,r3,nohandler   /* do not go to user handler routine */
	set    r2,r2,1<oper>       /* set invalid operand bit */
	bsr    _handler            /* go to user handler routine */
	br     FPintov_return              /* return from subroutine */
d743 3
a745 3
	bb0.n  sign,r7,FPintov_return      /* if positive then return from subroutine */
	set    r6,r6,31<0>         /* set result to largest positive integer */
	or.c   r6,r0,r6            /* negate r6,giving largest negative int. */
d747 2
a748 2
FPintov_return:      ld     r1,r31,0     /* load return address from memory */
	jmp    r1                  /* return from subroutine */
d751 10
d762 3
a764 3
/* Some instructions only have the S2 operations, so clear S1HI and S1LO */
/* for those instructions so that the previous contents of S1HI and S1LO */
/* do not influence this instruction. */
a765 1
             text
d768 9
a776 9
	     extu   r10,r9,5<11>   /* extract opcode */
/*             cmp    r11,r10,FSQRTop ;compare to FSQRT */
/*             bb1    eq,r11,S1clear ;clear S1 if instruction only had S2 operand */
             cmp    r11,r10,INTop  /* compare to INT */
             bb1    eq,r11,S1clear /* clear S1 if instruction only had S2 operand */
             cmp    r11,r10,NINTop /* compare to NINT */
             bb1    eq,r11,S1clear /* clear S1 if instruction only had S2 operand */
             cmp    r11,r10,TRNCop /* compare to TRNC */
             bb0    eq,r11,opercheck /* check for reserved operands */
d779 19
a797 19
	     or     r5,r0,r0       /* clear any NaN''s, denorms, or infinities */
             or     r6,r0,r0       /* that may be left in S1HI,S1LO from a  */
                                   /* previous instruction */

/* r12 contains the following flags: */
/* 		bit 9 -- s1sign */
/* 		bit 8 -- s2sign */
/* 		bit 7 -- s1nan */
/* 		bit 6 -- s2nan */
/* 		bit 5 -- s1inf */
/* 		bit 4 -- s2inf */
/* 		bit 3 -- s1zero */
/* 		bit 2 -- s2zero */
/* 		bit 1 -- s1denorm */
/* 		bit 0 -- s2denorm */

/* Using code for both single and double precision, check if S1 is either */
/* a NaN or infinity and set the appropriate flags in r12.  Then check if */
/* S2 is a NaN or infinity.  If it is a NaN, then branch to the NaN routine. */
d801 3
a803 3
	     extu   r10,r5,11<20>        /* internal representation for double */
             bb1.n  s1size,r9,S1NaNdoub /* S1 is double precision */
             or     r12,r0,r0      /* clear operand flag register */
d805 15
a819 15
	     xor    r10,r10,0x0080       /* internal representation for single */
             ext    r10,r10,8<0>         /* precision is IEEE 8 bits sign extended */
                                         /* to 11 bits; for real exp. > 0, the */
                                         /* above instructions gives a result exp. */
                                         /* that has the MSB flipped and sign */
                                         /* extended like in the IMPCR */
             cmp    r11,r10,127    /* Is exponent equal to IEEE 255 (internal 127) */
             bb1    ne,r11,S2NaN   /* source 1 is not a NaN or infinity */
             mak    r10,r5,20<0>   /* load r10 with upper bits of S1 mantissa */
             extu   r11,r6,3<29>   /* get 3 upper bits of lower word */
             or     r11,r10,r11    /* combine any existing 1''s */
             bcnd   eq0,r11,noS1NaNs /* since r11 can only hold 0 or a positive */
                                   /* number, branch to noS1NaN when eq0 */
             br.n   S2NaN          /* see if S2 has a NaN */
             set    r12,r12,1<s1nan> /* indicate that S1 has a NaN */
d821 2
a822 2
	     br.n   S2NaN          /* check contents of S2 */
             set    r12,r0,1<s1inf> /* indicate that S1 has an infinity */
d825 13
a837 13
	     xor    r10,r10,0x0400       /* precision is the same IEEE 11 bits  */
                                         /* The */
                                         /* above instructions gives a result exp. */
                                         /* that has the MSB flipped and sign */
                                         /* extended like in the IMPCR */
             cmp    r11,r10,1023   /* Is exp. equal to IEEE 2047 (internal 1023) */
             bb1    ne,r11,S2NaN   /* source 1 is not a NaN or infinity */
             mak    r10,r5,20<0>   /* load r10 with upper bits of S1 mantissa */
             or     r11,r6,r10     /* combine existing 1''s of mantissa */
             bcnd   eq0,r11,noS1NaNd /* since r11 can only hold 0 or a positive */
                                   /* number, branch to noS1NaN when eq0 */
             br.n   S2NaN          /* see if S2 has a NaN */
             set    r12,r12,1<s1nan> /* indicate that S1 has a NaN */
d839 1
a839 1
	     set    r12,r0,1<s1inf> /* indicate that S1 has an infinity */
d842 2
a843 2
	     bb1.n  s2size,r9,S2NaNdoub /* S1 is double precision */
             extu   r10,r7,11<20>        /* internal representation for double */
d845 15
a859 15
	     xor    r10,r10,0x0080       /* internal representation for single */
             ext    r10,r10,8<0>         /* precision is IEEE 8 bits sign extended */
                                         /* to 11 bits; for real exp. > 0, the */
                                         /* above instruction gives a result exp. */
                                         /* that has the MSB flipped and sign */
                                         /* extended like in the IMPCR */
             cmp    r11,r10,127    /* Is exponent equal to IEEE 255 (internal 127) */
             bb1    ne,r11,inf     /* source 2 is not a NaN or infinity */
             mak    r10,r7,20<0>   /* load r10 with upper bits of S1 mantissa */
             extu   r11,r8,3<29>   /* get 3 upper bits of lower word */
             or     r11,r10,r11    /* combine any existing 1''s */
             bcnd   eq0,r11,noS2NaNs /* since r11 can only hold 0 or a positive */
                                   /* number, branch to noS2NaNs when eq0 */
             br.n   _NaN           /* branch to NaN routine */
             set    r12,r12,1<s2nan> /* indicate that s2 has a NaN */
d861 1
a861 1
	     bb0    s1nan,r12, 1f /* branch to NaN if S1 is a NaN */
d863 5
a867 5
1:           br.n   _infinity      /* If S1 had a NaN we would have already */
                                   /* branched, and S2 does not have a NaN, but */
                                   /* it does have an infinity, so branch to  */
                                   /* handle the finity */
             set    r12,r12,1<s2inf> /* indicate that S2 has an infinity */
d870 13
a882 13
	     xor    r10,r10,0x0400       /* precision is the same IEEE 11 bits  */
                                         /* The */
                                         /* above instruction gives a result exp. */
                                         /* that has the MSB flipped and sign */
                                         /* extended like in the IMPCR */
             cmp    r11,r10,1023   /* Is exp. equal to IEEE 2047 (internal 1023) */
             bb1    ne,r11,inf     /* source 2 is not a NaN or infinity */
             mak    r10,r7,20<0>   /* load r10 with upper bits of S2 mantissa */
             or     r11,r8,r10     /* combine existing 1''s of mantissa */
             bcnd   eq0,r11,noS2NaNd /* since r11 can only hold 0 or a positive */
                                   /* number, branch to noS2NaNd when eq0 */
             br.n   _NaN           /* branch to NaN routine */
             set    r12,r12,1<s2nan> /* indicate that s2 has a NaN */
d884 1
a884 1
	     bb0    s1nan,r12,1f /* branch to NaN if S1 is a NaN */
d886 5
a890 5
1:           br.n   _infinity      /* If S1 had a NaN we would have already */
                                   /* branched, and S2 does not have a NaN, but */
                                   /* it does have an infinity, so branch to  */
                                   /* handle the finity */
             set    r12,r12,1<s2inf> /* indicate that S2 has an infinity */
d893 5
a897 5
/* If S2 was a NaN, the routine would have already branched to NaN.  If S1 */
/* is a NaN, then branch to NaN.  If S1 is not a NaN and S2 is infinity, then */
/* we would have already branched to infinity.  If S1 is infinity, then branch. */
/* If the routine still has not branched, then branch to denorm, the only  */
/* reserved operand left. */
d900 1
a900 1
	     bb0    s1nan,r12,1f  /* branch if S1 has a NaN and S2 does not */
d902 3
a904 3
1:           bb0    s1inf,r12,2f    /* Neither S1 or S2 has a NaN, and we would */
                                    /* have branched already if S2 had an  */
                                    /* infinity, so branch if S1 is infinity */
d913 6
a918 2
	br     _denorm        /* branch to denorm, the only remaining */
                                   /* alternative */
d920 2
a921 2
/* function _FPunderflow --       */
/* The documentation for this release give an overall description of this code. */
d923 4
a927 1
                global _FPunderflow
d929 4
a932 4
/* First check for an underflow user handler.  If there is not one, then */
/* branch to the routine to make a denormalized number.  Before branching */
/* to the underflow user handler, add 192 to a single precision exponent */
/* and 1536 to a double precision exponent. */
d934 1
a934 1
_FPunderflow:   st    r1,r31,0 /* save return address */
d936 107
a1042 107
		bb0 efunf,r12,denorm /* jump to default procedure */
                bb1.n destsize,r12,doubleprec /* double precision destination */
                set   r2,r2,1<underflow>  /* set underflow flag in FPSR */
singleprec:     or.u  r6,r0,0x0c00 /* load exponent adjust 192 */
                br.n  callundhand  /* branch to call handler for user handler */
                add   r12,r6,r12   /* adjust single precision exponent */
doubleprec:     or.u  r6,r0,0x6000 /* load exponent adjust 1536 */
                add   r12,r6,r12   /* adjust double precision exponent */
callundhand:    bsr   _handler     /* call handler for user handler */
                br    Ureturn       /* return from subroutine */
#endif

/* Now the floating point number, which has an exponent smaller than what */
/* IEEE allows, must be denormalized.  Denormalization is done by calculating */
/* the difference between a denormalized exponent and an underflow exponent and */
/* shifting the mantissa by that amount.  A one may need to be subtracted from  */
/* the LSB if a one was added during rounding. */
/* r9 is used to contain the guard, round, sticky, and an inaccuracy bit in */
/* case some bits were shifted off the mantissa during denormalization. */
/* r9 will contain: bit 4 -- new addone if one added during rounding  */
/*                           after denormalization */
/*                  bit 3 -- inaccuracy flag caused by denormalization */
/* 			   or pre-denormalization inexactness */
/*                  bit 2 -- guard bit of result */
/*                  bit 1 -- round bit of result */
/*                  bit 0 -- sticky bit of result */

denorm:         bb1.n destsize,r12,Udouble /* denorm for double */
                extu  r9,r10,3<26>   /* load r9 with grs */
Usingle:         mak   r5,r10,21<3> /* extract high 21 bits of mantissa */
                extu  r6,r11,3<29> /* extract low 3 bits of mantissa */
                or    r11,r5,r6     /* form 24 bits of mantissa */

/* See if the addone bit is set and unround if it is. */
                bb0.n 25,r10,nounrounds /* do not unround if addone bit clear */
                extu  r6,r12,12<20>  /* extract signed exponent from IMPCR */
unrounds:       subu  r11,r11,1      /* subtract 1 from mantissa */
/* If the hidden bit is cleared after subtracting the one, then the one added */
/* during the rounding must have propagated through the mantissa.  The exponent */
/* will need to be decremented. */
                bb1   23,r11,nounrounds /* if hidden bit is set,then exponent does */
                                   /* not need to be decremented */
decexps:        sub   r6,r6,1      /* decrement exponent 1 */
                set   r11,r11,1<23>  /* set the hidden bit */

/* For both single and double precision, there are cases where it is easier */
/* and quicker to make a special case.  Examples of this are if the shift  */
/* amount is only 1 or 2, or all the mantissa is shifted off, or all the */
/* mantissa is shifted off and it is still shifting, or, in the case of  */
/* doubles, if the shift amount is around the boundary of MANTLO and MANTHI. */

nounrounds:     or    r8,r0,lo16(0x00000f81)  /* load r8 with -127 in decimal  */
					    /* for lowest 12 bits */
                sub   r7,r8,r6     /* find difference between two exponents, */
                                   /* this amount is the shift amount */
                cmp   r6,r7,3      /* check to see if r7 contains 3 or more */
                bb1   ge,r6,threesing /* br to code that handles shifts of >=3 */
                cmp   r6,r7,2      /* check to see if r7 contains 2 */
                bb1   eq,r6,twosing /* br to code that handles shifts of 2 */
one:            rot   r9,r9,0<1>   /* rotate roundoff register once, this places */
                                   /* guard in round and round in sticky */
                bb0   31,r9,nosticky1s/* do not or round and sticky if sticky is */
                                   /* 0, this lost bit will be cleared later */
                set   r9,r9,1<0>   /* or round and sticky */
nosticky1s:     bb0   0,r11,guardclr1s /* do not set guard bit if LSB = 0 */
                set   r9,r9,1<2>   /* set guard bit        */
guardclr1s:     extu  r11,r11,31<1> /* shift mantissa right 1 */
                br.n  round        /* round result */
                mak   r9,r9,3<0>   /* clear bits lost during rotation */

twosing:        rot   r9,r9,0<2>   /* rotate roundff register twice, this places */
                                   /* guard in sticky */
                bb0   30,r9,nosticky2s /* do not or guard and sticky if stick is 0 */
                                   /* this lost bit will be cleared later */
                br.n  noround2s    /* skip or old guard and old round if old */
                                   /* sticky set */
                set   r9,r9,1<0>   /* or guard and sticky */
nosticky2s:     bb0   31,r9,noround2s /* do not or guard and round if round is 0 */
                                   /* this lost bit will be cleared later */
                set   r9,r9,1<0>   /* or guard and round */
noround2s:      bb0   0,r11,roundclr2s /* do not set round bit if LSB = 0 */
                set   r9,r9,1<1>   /* set round bit */
roundclr2s:     bb0   1,r11,guardclr2s /* do not set guard bit if LSB + 1 = 0 */
                set   r9,r9,1<2>   /* set guard bit */
guardclr2s:     extu  r11,r11,30<2>  /* shift mantissa right 2 */
                br.n  round        /* round result */
                mak   r9,r9,3<0>   /* clear bits lost during rotation */

threesing:      bb1   0,r9,noguard3s /* check sticky initially */
                                     /* sticky is set, forget most of the oring */
nosticky3s:     bb0   1,r9,noround3s  /* check round initially, do not set sticky */
                br.n  noguard3s    /* forget most of the rest of oring */
                set   r9,r9,1<0>      /* if round is clear,set sticky if round set */
noround3s:      bb0.n 2,r9,noguard3s  /* check guard initially, do not set sticky */
                clr   r9,r9,2<1>   /* clear the original guard and round for when */
                                      /* you get to round section */
                set   r9,r9,1<0>      /* if guard is clear,set sticky if guard set */
noguard3s:      cmp   r6,r7,23     /* check if # of shifts is <=23 */
                bb1   gt,r6,s24    /* branch to see if shifts = 24 */
                sub   r6,r7,2      /* get number of bits to check for sticky */
                mak   r6,r6,5<5>   /* shift width into width field */
                mak   r8,r11,r6     /* mask off shifted bits -2 */
                ff1   r8,r8        /* see if r8 has any ones */
                bb1   5,r8,nostky23 /* do not set sticky if no ones found */
                set   r9,r9,1<0>   /* set sticky bit */
nostky23:       or    r8,r0,34     /* start code to get new mantissa plus two */
                                   /* extra bits for new round and new guard bits */
d1044 25
a1068 25
                mak   r8,r8,5<5>   /* shift field width into second five bits */
                extu  r6,r6,5<5>   /* shift previous shifted -2 into offset field */
                or    r6,r6,r8     /* complete field */
                extu  r11,r11,r6     /* form new mantissa with two extra bits */

                bb0   0,r11,nornd3s /* do not set new round bit */
                set   r9,r9,1<1>   /* set new round bit */
nornd3s:        bb0   1,r11,nogrd3s /* do not set new guard bit */
                set   r9,r9,1<2>   /* set new guard bit */
nogrd3s:        br.n  round        /* round mantissa */
                extu  r11,r11,30<2>  /* shift off remaining two bits */

s24:            cmp   r6,r7,24     /* check to see if # of shifts is 24 */
                bb1   gt,r6,s25    /* branch to see if shifts = 25 */
                bb1   0,r9,nostky24 /* skip checking if old sticky set */
                extu  r8,r11,22<0>  /* prepare to check bits that will be shifted */
                                   /* into the sticky */
                ff1   r8,r8        /* see if there are any 1''s */
                bb1   5,r8,nostky24 /* do not set sticky if no ones found */
                set   r9,r9,1<0>   /* set sticky bit */
nostky24:       bb0   22,r11,nornd24 /* do not set new round bit */
                set   r9,r9,1<1>   /* set new round bit */
nornd24:        set   r9,r9,1<2>   /* set new guard bit,this is hidden bit */
                br.n  round        /* round mantissa */
                or    r11,r0,r0     /* clear r11, all of mantissa shifted off */
d1070 22
a1091 22
s25:            cmp   r6,r7,25     /* check to see if # of shifts is 25 */
                bb1   gt,r6,s26    /* branch to execute for shifts => 26 */
                bb1   0,r9,nostky25 /* skip checking if old sticky set */
                extu  r8,r11,23<0> /* prepare to check bits that will be shifted */
                                   /* into the sticky */
                ff1   r8,r8        /* see if there are any 1''s */
                bb1   5,r8,nostky25 /* do not set sticky if no ones found */
                set   r9,r9,1<0>   /* set sticky bit */
nostky25:       set   r9,r9,1<1>   /* set new round bit,this is hidden bit */
                clr   r9,r9,1<2>   /* clear guard bit since nothing shifted in */
                br.n  round        /* round and assemble result */
                or    r11,r0,r0    /* clear r11, all of mantissa shifted off */

s26:            set   r9,r9,1<0>   /* set sticky bit,this contains hidden bit */
                clr   r9,r9,2<1>   /* clear guard and round bits since nothing  */
                                   /* shifted in  */
                br.n  round        /* round and assemble result */
                or    r11,r0,r0    /* clear mantissa */

Udouble:         mak   r5,r10,21<0> /* extract upper bits of mantissa */
                bb0.n 25,r10,nounroundd /* do not unround if addone bit clear */
                extu  r6,r12,12<20>/* extract signed exponenet from IMPCR */
d1093 74
a1166 74
		subu.co  r11,r11,r8     /* subtract 1 from mantissa */
                subu.ci  r5,r5,r0       /* subtract borrow from upper word */
                bb1   20,r5,nounroundd /* if hidden bit is set, then exponent does */
                                       /* not need to be decremented */
decexpd:        sub   r6,r6,1      /* decrement exponent 1 */
                set   r5,r5,1<20>  /* set the hidden bit */

nounroundd:     or    r8,r0,lo16(0x00000c01) /* load r8 with -1023 in decimal  */
					     /* for lowest 12 bits  */
                sub   r7,r8,r6     /* find difference between two exponents, */
                                   /* this amount is the shift amount */
                cmp   r6,r7,3      /* check to see if r7 contains 3 or more */
                bb1   ge,r6,threedoub /* br to code that handles shifts of >=3 */
                cmp   r6,r7,2      /* check to see if r7 contains 2 */
                bb1   eq,r6,twodoub /* br to code that handles shifts of 2 */

onedoub:        rot   r9,r9,0<1>   /* rotate roundoff register once, this places */
                                   /* guard in round and round in sticky */
                bb0   31,r9,nosticky1d/* do not or round and sticky if sticky is 0 */
                                   /* this lost bit will be cleared later */
                set   r9,r9,1<0>   /* or old round and old sticky into new sticky */
nosticky1d:     bb0   0,r11,guardclr1d /* do not set new guard bit if old LSB = 0 */
                set   r9,r9,1<2>   /* set new guard bit */
guardclr1d:     extu  r11,r11,31<1> /* shift lower mantissa over 1 */
                mak   r6,r5,1<31>  /* shift off low bit of high mantissa */
                or    r11,r6,r11   /* load high bit onto lower mantissa */
                extu  r5,r5,20<1>  /* shift right once upper 20 bits of mantissa */
                br.n  round        /* round mantissa and assemble result */
                mak   r9,r9,3<0>   /* clear bits lost during rotation */

twodoub:        rot   r9,r9,0<2>   /* rotate roundoff register twice, this places */
                                   /* old guard into sticky */
                bb0   30,r9,nosticky2d /* do not or old guard and old sticky if  */
                                       /* old sticky is 0 */
                br.n  noround2d    /* skip or of old guard and old round if old */
                                   /* sticky set */
                set   r9,r9,1<0>   /* or old guard and old sticky into new sticky */
nosticky2d:     bb0   31,r9,noround2d /* do not or old guard and old round if */
                                      /* old round is 0 */
                set   r9,r9,1<0>   /* or old guard and old round into new sticky */
noround2d:      bb0   0,r11,roundclr2d /* do not set round bit if old LSB = 0 */
                set   r9,r9,1<1>   /* set new round bit */
roundclr2d:     bb0   1,r11,guardclr2d /* do not set guard bit if old LSB + 1 = 0 */
                set   r9,r9,1<2>   /* set new guard bit */
guardclr2d:     extu  r11,r11,30<2> /* shift lower mantissa over 2 */
                mak   r6,r5,2<30>  /* shift off low bits of high mantissa */
                or    r11,r6,r11   /* load high bit onto lower mantissa */
                extu  r5,r5,19<2>  /* shift right twice upper 19 bits of mantissa */
                br.n  round        /* round mantissa and assemble result */
                mak   r9,r9,3<0>   /* clear bits lost during rotation */

threedoub:      bb1   0,r9,noguard3d /* checky sticky initially */
                                    /* sticky is set, forget most of rest of oring */
nosticky3d:     bb0   1,r9,noround3d /* check old round, do not set sticky if  */
                                     /* old round is clear, set otherwise */
                br.n  noguard3d    /* sticky is set, forget most of rest of oring */
                set   r9,r9,1<0>   /* set sticky if old round is set */
noround3d:      bb0   2,r9,noguard3d /* check old guard, do not set sticky if 0 */
                clr   r9,r9,2<1>   /* clear the original guard and round for when */
                                      /* you get to round section */
                set   r9,r9,1<0>   /* set sticky if old guard is set */
noguard3d:      cmp   r6,r7,32     /* do I need to work with a 1 or 2 word mant. */
                                   /* when forming sticky, round and guard */
                bb1   gt,r6,d33    /* jump to code that handles 2 word mantissas */
                sub   r6,r7,2      /* get number of bits to check for sticky */
                mak   r6,r6,5<5>   /* shift width into width field */
                mak   r8,r11,r6    /* mask off shifted bits -2 */
                ff1   r8,r8        /* see if r8 has any ones */
                bb1   5,r8,nostky32 /* do not set sticky if no ones found */
                set   r9,r9,1<0>   /* set sticky bit */
nostky32:       or    r8,r0,34     /* start code to get new mantissa plus two */
                                   /* extra bits for new round and new guard bits, */
                                   /* the upper word bits will be shifted after */
                                   /* the round and guard bits are handled */
d1168 148
a1315 148
                mak   r8,r8,5<5>   /* shift field width into second five bits */
                extu  r6,r6,5<5>   /* shift previous shifted -2 into offset field */
                or    r6,r6,r8     /* complete bit field */
                extu  r11,r11,r6   /* partially form new low mantissa with 2 more  */
                                   /* bits */
                bb0   0,r11,nornd32d /* do not set new round bit */
                set   r9,r9,1<1>   /* set new round bit */
nornd32d:       bb0   1,r11,nogrd32d /* do not set new guard bit */
                set   r9,r9,1<2>   /* set new guard bit */
nogrd32d:       extu  r11,r11,30<2> /* shift off remaining two bits */
                mak   r6,r7,5<5>   /* shift field width into second 5 bits, if the */
                                   /* width is 32, then these bits will be 0 */
                or    r8,r0,32     /* load word length into r8 */
                sub   r8,r8,r7     /* form offset for high bits moved to low word */
                or    r6,r6,r8     /* form complete bit field */
                mak   r6,r5,r6     /* get shifted bits of high word */
                or    r11,r6,r11   /* form new low word of mantissa */
		bcnd  ne0,r8,regular33 /* do not adjust for special case of r8 */
		br.n  round	       /* containing zeros, which would cause */
		or    r5,r0,r0         /* all of the bits to be extracted under */
				       /* the regular method */
regular33:      mak   r6,r7,5<0>   /* place lower 5 bits of shift into r6 */
                mak   r8,r8,5<5>   /* shift r8 into width field */
                or    r6,r6,r8     /* form field for shifting of upper bits */
                br.n  round        /* round and assemble result */
                extu  r5,r5,r6     /* form new high word mantissa */

d33:            cmp   r6,r7,33     /* is the number of bits to be shifted is 33? */
                bb1   gt,r6,d34    /* check to see if # of bits is 34 */
                bb1   0,r9,nostky33 /* skip checking if old sticky set */
                mak   r6,r11,31<0> /* check bits that will be shifted into sticky */
                ff1   r8,r8        /* check for ones */
                bb1   5,r8,nostky33 /* do not set sticky if there are no ones */
                set   r9,r9,1<0>   /* set new sticky bit */
nostky33:       bb0   31,r11,nornd33 /* do not set round if bit is not a 1 */
                set   r9,r9,1<1>   /* set new round bit */
nornd33:        bb0   0,r5,nogrd33 /* do not set guard bit if bit is not a 1 */
                set   r9,r9,1<2>   /* set new guard bit */
nogrd33:        extu  r11,r5,31<1> /* shift high bits into low word */
                br.n  round        /* round and assemble result */
                or    r5,r0,r0     /* clear high word */

d34:            cmp   r6,r7,34     /* is the number of bits to be shifted 34? */
                bb1   gt,r6,d35    /* check to see if # of bits is >= 35 */
                bb1   0,r9,nostky34 /* skip checking if old sticky set */
                ff1   r8,r11       /* check bits that will be shifted into sticky */
                bb1   5,r8,nostky34 /* do not set sticky if there are no ones */
                set   r9,r9,1<0>   /* set new sticky bit */
nostky34:       bb0   0,r5,nornd34 /* do not set round if bit is not a 1 */
                set   r9,r9,1<1>   /* set new round bit */
nornd34:        bb0   1,r5,nogrd34 /* do not set guard bit if bit is not a 1 */
                set   r9,r9,1<2>   /* set new guard bit */
nogrd34:        extu  r11,r5,30<2> /* shift high bits into low word */
                br.n  round        /* round and assemble result */
                or    r5,r0,r0     /* clear high word */

d35:            cmp   r6,r7,52     /* see if # of shifts is 35 <= X <= 52 */
                bb1   gt,r6,d53    /* check to see if # of shifts is 52 */
                bb1.n 0,r9,nostky35 /* skip checking if old sticky set */
                sub   r7,r7,34     /* subtract 32 from # of shifts so that opera- */
                                   /* tions can be done on the upper word, and  */
                                   /* then subtract two more checking guard and */
                                   /* sticky bits */
                ff1   r8,r11       /* see if lower word has a bit for sticky */
                bb1   5,r8,stkycheck35 /* see if upper word has any sticky bits    */
                br.n  nostky35     /* quit checking for sticky */
                set   r9,r9,1<0>   /* set sticky bit */
stkycheck35:    mak   r6,r7,5<5>   /* place width into width field */
                mak   r8,r5,r6     /* mask off shifted bits - 2 */
                ff1   r8,r8        /* see if r8 has any ones */
                bb1   5,r8,nostky35 /* do not set sticky if no ones found */
                set   r9,r9,1<0>   /* set sticky bit */
nostky35:       or    r8,r0,32     /* look at what does not get shifted off plus */
                                   /* round and sticky, remember that the r7 value */
                                   /* was adjusted so that it did not include */
                                   /* new round or new sticky in shifted off bits */
                subu  r8,r8,r7     /* complement width  */
                mak   r8,r8,5<5>   /* shift width into width field */
                or    r8,r7,r8     /* add offset field */
                extu  r11,r5,r8    /* extract upper bits into low word */
                bb0   0,r11,nornd35 /* do not set new round bit */
                set   r9,r9,1<1>   /* set new round bit */
nornd35:        bb0   1,r11,nogrd35 /* do not set new guard bit */
                set   r9,r9,1<2>   /* set new guard bit */
nogrd35:        extu  r11,r11,30<2> /* shift off remaining guard and round bits */
                br.n  round         /* round and assemble result */
                or    r5,r0,r0      /* clear high word */

d53:            cmp   r6,r7,53     /* check to see if # of shifts is 53 */
                bb1   gt,r6,d54    /* branch to see if shifts = 54 */
                bb1   0,r9,nostky53 /* skip checking if old sticky set */
                ff1   r8,r11       /* see if lower word has a bit for sticky */
                bb1   5,r8,stkycheck53 /* see if upper word has any sticky bits    */
                br.n  nostky53     /* quit checking for sticky */
                set   r9,r9,1<0>   /* set sticky bit */
stkycheck53:    mak   r6,r5,19<0>  /* check bits that are shifted into sticky */
                ff1   r8,r6        /* see if r6 has any ones */
                bb1   5,r8,nostky53 /* do not set sticky if no ones found */
                set   r9,r9,1<0>   /* set sticky bit */
nostky53:       bb0   19,r5,nornd53 /* do not set new round bit */
                set   r9,r9,1<1>   /* set new round bit */
nornd53:        set   r9,r9,1<2>   /* set new guard bit,this is hidden bit */
                or    r5,r0,r0     /* clear high word */
                br.n  round        /* round and assemble result */
                or    r11,r0,r0    /* clear low word */

d54:            cmp   r6,r7,54     /* check to see if # of shifts is 54 */
                bb1   gt,r6,d55    /* branch to execute for shifts =>55 */
                bb1   0,r9,nostky54 /* skip checking if old sticky set */
                ff1   r8,r11       /* see if lower word has a bit for sticky */
                bb1   5,r8,stkycheck54 /* see if upper word has any sticky bits    */
                br.n  nostky54     /* quit checking for sticky */
                set   r9,r9,1<0>   /* set sticky bit */
stkycheck54:    mak   r6,r5,20<0>  /* check bits that are shifted into sticky */
                ff1   r8,r6        /* see if r6 has any ones */
                bb1   5,r8,nostky54 /* do not set sticky if no ones found */
                set   r9,r9,1<0>   /* set sticky bit */
nostky54:       set   r9,r9,1<1>   /* set new round bit,this is hidden bit */
                clr   r9,r9,1<2>   /* clear guard bit since nothing shifted in */
                or    r5,r0,r0     /* clear high word */
                br.n  round        /* round and assemble result */
                or    r11,r0,r0    /* clear low word */

d55:            set   r9,r9,1<0>   /* set new sticky bit,this contains hidden bit */
                clr   r9,r9,2<1>   /* clear guard and round bits since nothing */
                                   /* shifted in */
                or    r5,r0,r0     /* clear high word */
                or    r11,r0,r0    /* clear low word */


/* The first item that the rounding code does is see if either guard, round, */
/* or sticky is set.  If all are clear, then there is no denormalization loss */
/* and no need to round, then branch to assemble answer. */
/* For rounding, a branch table is set up.  The left two most bits are the  */
/* rounding mode.  The third bit is either the LSB of the mantissa or the */
/* sign bit, depending on the rounding mode.  The three LSB''s are the guard, */
/* round and sticky bits. */

round:          ff1   r8,r9         /* see if there is denormalization loss */
                bb1   5,r8,assemble /* no denormalization loss or inexactness */
                extu  r6,r10,2<modelo>   /* extract rounding mode */
                bb1.n modehi,r10,signext /* use sign bit instead of LSB */
                mak   r6,r6,2<4>    /* shift over rounding mode */
                extu  r7,r11,1<0>   /* extract LSB */
                br.n  grs           /* skip sign extraction */
                mak   r7,r7,1<3>    /* shift over LSB */
signext:        extu  r7,r10,1<31>  /* extract sign bit */
                mak   r7,r7,1<3>    /* shift sign bit over */
d1317 2
a1318 2
                or    r6,r6,r9      /* or in guard, round, and sticky */
                or.u  r1,r0,hi16(roundtable) /* form address of branch table */
d1320 3
a1322 3
                lda   r6,r1[r6]     /* scale offset into branch table */
                jmp.n r6            /* jump to branch table */
                set   r9,r9,1<3>    /* set inexact flag in r9 */
d1389 6
a1394 6
/* Round by adding a one to the LSB of the mantissa. */
addone:         or    r6,r0,1      /* load a 1 into r6 so that add.co can be used */
                add.co r11,r11,r6  /* add a one to the lower word of result */
                bb0.n destsize,r12,noaddone /* single result,forget carry */
                set   r9,r9,1<4>   /* indicate that a 1 has been added */
                add.ci r5,r5,r0    /* propagate carry into high word */
d1397 1
a1397 1
/* Branch to inexact user handler if there is one. */
d1401 3
a1403 3
		bb1.n efinx,r12,modformdef /* branch to modify form for user  */
                                             /* handler */
                or    r2,r2,5      /* set inexact and underflow flags */
d1407 13
a1419 13
/* Assemble the result of the denormalization routine for writeback to the  */
/* destination register.  The exponent of a denormalized number is zero, */
/* so simply assemble the sign and the new mantissa. */

assemble:       bb1   destsize,r12,doubassem /* assemble double result */
                bb0   sign,r10,exassems /* exit assemble if sign is zero */
                set   r11,r11,1<sign>  /* make result negative */
exassems:       br    Ureturn       /* return from subroutine */

doubassem:      bb0.n sign,r10,signclr /* do not set sign in r10 */
		or    r10,r5,r0    /* load high word from r5 into r10 */
                set   r10,r10,1<sign> /* high word with sign loaded */
signclr:        br    Ureturn       /* return from subroutine */
d1422 3
a1424 3
/* modfordef modifies the result of denormalization to the input format of */
/* the inexact user handler.  This input format is the same format that  */
/* MANTHI, MANTLO, and IMPCR were initially loaded with. */
d1427 15
a1441 15
modformdef:     clr   r12,r12,12<20> /* clear result exponent,IMPCR complete */
                clr   r10,r10,4<25>  /* clear old guard,round,sticky,and addone */
                mak   r5,r9,3<26>    /* make grs field */
                bb0.n 4,r9,newaddone /* do not set new addone in MANTHI */
                or    r10,r5,r10     /* or in new grs field */
                set   r10,r10,1<25>  /* set new addone */
newaddone:      bb1.n destsize,r12,moddefd /* branch to handle double precision */
                clr   r10,r10,21<0>  /* clear upper bits of old mantissa */
moddefs:        extu  r5,r11,20<3>   /* extract upper bits */
                or    r10,r5,r10     /* MANTHI complete */
                bsr.n _handler       /* execute user handler for inexact */
                rot   r11,r11,0<3>   /* MANTLO complete */
                br    Ureturn         /* return from subroutine */
moddefd:        bsr.n _handler       /* execute user handler for inexact */
                or    r10,r5,r10     /* MANTHI complete,r5 should be set to OR */
d1445 1
a1445 1
/* Return to fpui. */
d1447 2
a1448 2
Ureturn:         ld    r1,r31,0 /* load return address */
                jmp   r1           /* return from subroutine */
d1451 4
d1456 2
a1457 2
/* function _FPoverflow --       */
/* The documentation for this release gives an overall description of this code. */
d1463 3
d1467 8
a1475 7
/* If the overflow user handler bit is not set, then the inexact bit in the */
/* FPSR is set, and the inexact user handler bit is checked.  If it is set, */
/* then the inexact user handler is executed, else the default routine for */
/* overflow is executed. */
              text				
	      align 8
              global _FPoverflow
d1477 1
a1477 1
	      st     r1,r31,0 /* save return address */
d1479 7
a1485 7
              set    r2,r2,1<overflow> /* set overflow bit in r2 which holds FPSR */
              bb1    efovf,r12,hand  /* go to user handler if bit set for overflow */
              set    r2,r2,1<inexact> /* set inexact bit in r2 since overflow bit */
                                /* in FPCR is not set */
              bb0  efinx,r12,nohandler/* if userhandler for inexact not set,then */
                                        /* round result */
              br     callhandler /* branch to user handler for inexact */
d1487 2
a1488 2
/* Before the overflow user handler is executed, the exponent is modified */
/* by subtracting 192 for single precision and 1536 for double precision. */
d1490 22
a1511 22
hand:         bb1    10,r12,doubleprec /* double precision result */
singleprec:   or.u   r5,r0,0x0c00 /* load exponent adjust */
              br.n   callhandler  /* prepare to call user handler */
              subu   r12,r12,r5 /* adjust single precision exponent */
doubleprec:   or.u   r5,r0,0x6000 /* load exponent adjust */
              subu   r12,r12,r5 /* adjust double precision exponent */
callhandler:  bsr    _handler   /* branch to common handler routine */
              br     return     /* return from overflow subroutine */
#endif

/* Determine which rounding mode to use for the default procedure. */

nohandler:    bb1    modehi,r10,signed /* mode is either round toward pos. or neg. */
              bb0    modelo,r10,OFnearest /* rounding mode is round nearest */
              br     OFzero            /* rounding mode is round zero */
signed:       bb0    modelo,r10,OFnegative /* rounding mode is round negative */
              br     positive        /* rounding mode is round positive */


/* In the round toward nearest mode, positive values are rounded to */
/* postive infinity and negative values are loaded toward negative infinity. */
/* The value for single or double precision is loaded from a data table. */
d1514 4
a1517 4
		bb1.n  destsize,r12,neardouble /* branch to neardouble of  */
                                             /* double result */
              mask.u r5,r10,0x8000  /* mask off sign bit from MANTHI */
              or.u   r11,r0,hi16(0x7f800000)  /* load single infinity constant */
d1519 2
a1520 2
              br.n   return     /* return with result */
              or     r11,r5,r11 /* adjust sign */
d1522 2
a1523 2
	     or     r11,r0,r0           /* load lower word of infinity */
              or.u   r10,r0,hi16(0x7ff00000)  /* load upper word of infinity */
d1525 2
a1526 2
              br.n   return     /* return with result */
              or     r10,r5,r10 /* adjust sign */
d1529 4
a1532 4
/* In the round toward zero mode, positive values are rounded to the largest */
/* postive finite number and negative values are rounded toward the largest */
/* negative finite number. */
/* The value for single or double precision is loaded from a data table. */
d1535 4
a1538 4
		bb1.n  destsize,r12,zerodouble /* branch to zerodouble of  */
                                             /* double result */
              mask.u r5,r10,0x8000  /* mask off sign bit from MANTHI */
              or.u   r11,r0,hi16(0x7f7fffff)  /* load single finite number constant */
d1540 2
a1541 2
              br.n   return     /* return with result */
              or     r11,r5,r11 /* adjust sign */
d1543 2
a1544 2
	     set    r11,r0,0<0>          /* load lower word of finite number */
              or.u   r10,r0,hi16(0x7fefffff)  /* load upper word of finite number */
d1546 2
a1547 2
              br.n   return     /* return with result */
              or     r10,r5,r10 /* adjust sign */
d1550 4
a1553 4
/* In the round toward positve mode, positive values are rounded to  */
/* postive infinity and negative values are loaded toward the largest */
/* negative finite number. */
/* The value for single or double precision is loaded from a data table. */
d1556 1
a1556 1
              bb1    destsize,r12,posdouble /* branch to section for double result */
d1558 1
a1558 1
  	     bb1    sign,r10,possingleneg /* branch to section for negatives */
d1560 2
a1561 2
		or.u   r11,r0,hi16(0x7f800000)  /* load single infinity constant */
              br.n   return     /* return with result */
d1564 1
a1564 1
	     or.u   r11,r0,hi16(0x7f7fffff)  /* load single finite number constant */
d1566 2
a1567 2
              br.n   return     /* return with result */
              set    r11,r11,1<sign> /* set sign for negative */
d1569 1
a1569 1
	     bb1    sign,r10,posdoubleneg /* branch to negative double results */
d1571 3
a1573 3
		or     r11,r0,r0  /* load lower word of double infinity */
              or.u   r10,r0,hi16(0x7ff00000)  /* load upper word of infinity */
              br.n   return     /* return with result */
d1576 2
a1577 2
	      set    r11,r0,0<0>          /* load lower word of finite number */
              or.u   r10,r0,hi16(0x7fefffff)  /* load upper word of finite number */
d1579 2
a1580 2
              br.n   return     /* return with result */
              set    r10,r10,1<sign> /* set sign for negative */
d1583 3
a1585 3
/* In the round toward negative mode, positive values are rounded to the largest  */
/* postive finite number and negative values are rounded to negative infinity. */
/* The value for single or double precision is loaded from a data table. */
d1588 1
a1588 1
	      bb1    destsize,r12,negdouble /* branch to section for double result */
d1590 1
a1590 1
	      bb1    sign,r10,negsingleneg /* branch to section for negatives */
d1592 2
a1593 2
	      or.u   r11,r0,hi16(0x7f7fffff)  /* load single finite number constant */
              br.n   return     /* return with result */
d1596 1
a1596 1
	      or.u   r11,r0,hi16(0x7f800000)  /* load single infinity constant */
d1598 2
a1599 2
              br.n   return     /* return with result */
              set    r11,r11,1<sign> /* set sign for negative */
d1601 1
a1601 1
	   bb1    sign,r10,negdoubleneg /* branch to negative double results */
d1603 3
a1605 3
	      set    r11,r0,0<0>          /* load lower word of finite number */
              or.u   r10,r0,hi16(0x7fefffff)  /* load upper word of finite number */
              br.n   return     /* return with result */
d1608 2
a1609 2
	      or     r11,r0,r0  /* load lower word of double infinity */
              or.u   r10,r0,hi16(0x7ff00000)  /* load upper word of infinity */
d1611 1
a1611 1
              set    r10,r10,1<sign> /* set sign for negative */
d1614 2
a1615 2
	      ld     r1,r31,0 /* ld return address */
              jmp    r1         /* return from subroutine */
d1618 4
d1623 4
d1628 9
a1636 9
/* If either S1 or S2 is a signalling NaN, then set the invalid operation */
/* bit of the FPSR.  If the invalid operation user handler flag is set and */
/* then NaN is signalling, then branch to the handler routine to go to the */
/* user handler. */
/* If S1 is the only NaN or one of two NaN''s, then write */
/* a quiet S1 to the result.  A signalling NaN must be made quiet before */
/* it can be written, but a signalling S2 is not modified in this routine */
/* if S1 is a NaN. */
             text
d1638 4
a1641 4
	        bb0.n	s1nan,r12,S2sigcheck /* S1 is not a NaN */
		st	r1,r31,0 /* save return address */
		bb1	sigbit,r5,S2sigcheck /* S1 is not a signaling NaN */
		set	r2,r2,1<oper>  /* set invalid operation bit in FPSR */
d1660 2
a1661 2
		bb0	oper,r3,S1nohandler /* branch if no user handler */
		bsr	_handler       /* branch to handler */
d1665 4
a1668 4
	        br.n	S1write        /* FPSR bit already set, S1 is made quiet, */
                                   /* and since we always write S1 if it is a */
                                   /* NaN, write S1 and skip rest of routine */
		set	r5,r5,1<sigbit> /* make S1 a quiet NaN */
d1671 3
a1673 3
		bb0	s2nan,r12,S1write /* S2 is not a NaN */
		bb1	sigbit,r7,S1write /* S2 is not a signaling NaN */
		set	r2,r2,1<oper>  /* set invalid operation bit in FPSR */
d1675 2
a1676 2
		bb0	oper,r3,S2nohandler	/* branch if no user handler */
		bsr	_handler       /* branch to handler */
d1681 1
a1681 1
		set    r7,r7,1<sigbit> /* make S2 a quiet NaN */
d1684 2
a1685 2
/* Write a single or double precision quiet NaN unless the opeation is FCMP. */
/* If the operation is FCMP, then set the not comparable bit in the result. */
d1688 7
a1694 7
	     bb0    s1nan,r12,S2write /* do not write S1 if it is not a NaN */
             extu   r10,r9,5<11>      /* extract opcode */
             cmp    r11,r10,FCMPop    /* compare to FCMP */
             bb1    ne,r11,S1noFCMP   /* operation is not FCMP */
             set    r6,r0,1<nc>       /* set the not comparable bit */
             br.n   FPnan_return            /* return from subroutine */
             set    r6,r6,1<ne>       /* set the not equal bit */
d1696 3
a1698 3
	     bb1.n  dsize,r9,wrdoubS1 /* double destination */
             set    r5,r5,11<20>      /* set all exponent bits to 1 */
/* The single result will be formed the same way whether S1 is a single or double */
d1700 6
a1705 6
	     mak    r10,r5,28<3>      /* wipe out extra exponent bits */
             extu   r11,r6,3<29>      /* get lower three bits of mantissa */
             or     r10,r10,r11       /* combine all of result except sign */
             clr    r6,r5,31<0>       /* clear all but sign */
             br.n   FPnan_return            /* return from function */
             or     r6,r6,r10         /* form result */
d1708 1
a1708 1
/* ;;;;;	     bb1    s1size,r9,wrdoubS1d ;write double source to double dest. */
d1711 1
a1711 1
	     set    r6,r6,29<0>       /* set extra bits of lower word */
d1713 2
a1714 2
	     br     FPnan_return      /* no modification necessary for writing */
                                      /* double to double, so return from function */
d1717 7
a1723 7
	     extu   r10,r9,5<11>      /* extract opcode */
             cmp    r11,r10,FCMPop    /* compare to FCMP */
             bb1.n  ne,r11,S2noFCMP   /* operation is not FCMP */
             set    r7,r7,11<20>      /* set all exponent bits to 1 */
             set    r6,r0,1<nc>       /* set the not comparable bit */
             br.n   FPnan_return            /* return from subroutine */
             set    r6,r6,1<ne>       /* set the not equal bit */
d1725 1
a1725 1
	     bb1.n  dsize,r9,wrdoubS2 /* double destination */
d1733 2
a1734 2
             set    r5,r5,11<20>      /* set all exponent bits to 1 */
/* The single result will be formed the same way whether S1 is a single or double */
d1736 6
a1741 6
	     mak    r10,r7,28<3>      /* wipe out extra exponent bits */
             extu   r11,r8,3<29>      /* get lower three bits of mantissa */
             or     r10,r10,r11       /* combine all of result except sign */
             clr    r6,r7,31<0>       /* clear all but sign */
             br.n   FPnan_return            /* return from function */
             or     r6,r6,r10         /* form result */
d1745 1
a1745 1
/* ;;;	     bb1  s2size,r9,FPnan_return  ;write double source to double dest. */
d1751 1
a1751 1
	     set    r6,r8,29<0>       /* set extra bits of lower word */
d1754 1
a1754 1
/* Return from this subroutine with the result. */
d1757 4
a1760 4
	     /* no modification necessary for writing */
                                      /* double to double, so return from function */
             ld     r1,r31,	 0   /* retrieve return address */
             jmp    r1                /* return from function */
d1763 8
a1771 3
/* function _infinity --       */
/* See the documentation of this release for an overall description of this */
/* code. */
d1773 5
d1779 2
a1780 2
/* Extract the opcode, compare to a constant, and branch to the code */
/* for the instruction. */
d1782 82
a1863 85
             text
	     align 8
             global _infinity
_infinity:   extu   r10,r9,5<11>   /* extract opcode */
             cmp    r11,r10,FADDop /* compare to FADD */
             bb1.n  eq,r11,FADD    /* operation is FADD */
             st     r1,r31,0       /* save return address */
             cmp    r11,r10,FSUBop /* compare to FSUB */
             bb1    eq,r11,FSUB    /* operation is FSUB */
             cmp    r11,r10,FCMPop /* compare to FCMP */
             bb1    eq,r11,FCMP    /* operation is FCMP */
             cmp    r11,r10,FMULop /* compare to FMUL */
             bb1    eq,r11,FMUL    /* operation is FMUL */
             cmp    r11,r10,FDIVop /* compare to FDIV */
             bb1    eq,r11,FDIV    /* operation is FDIV */
/*              cmp    r11,r10,FSQRTop;compare to FSQRT */
/*              bb1    eq,r11,FSQRT   ;operation is FSQRT */
             cmp    r11,r10,INTop  /* compare to INT */
             bb1    eq,r11,FP_inf_overflw /* operation is INT */
             cmp    r11,r10,NINTop /* compare to NINT */
             bb1    eq,r11,FP_inf_overflw /* operation is NINT */
             cmp    r11,r10,TRNCop /* compare to TRNC */
             bb1    eq,r11,FP_inf_overflw /* operation is TRNC */


/* Adding infinities of opposite signs will cause an exception, */
/* but all other operands will result in a correctly signed infinity. */

FADD:        bb0    s1inf,r12,addS2write /* branch if S1 not infinity */
             bb0    s2inf,r12,addS1write /* S2 is not inf., so branch to write S1 */
             bb1    sign,r5,addS1neg   /* handle case of S1 negative */
addS1pos:    bb1    sign,r7,excpt      /* adding infinities of different signs */
                                       /* causes an exception */
             br     poswrinf           /* branch to write positive infinity */
addS1neg:    bb0    sign,r7,excpt      /* adding infinities of different signs */
                                       /* causes an exception */
             br     negwrinf           /* branch to write negative infinity */
addS1write:  bb0    sign,r5,poswrinf   /* branch to write positive infinity */
             br     negwrinf           /* branch to write negative infinity */
addS2write:  bb0    sign,r7,poswrinf   /* branch to write positive infinity */
             br     negwrinf           /* branch to write negative infinity */


/* Subtracting infinities of the same sign will cause an exception, */
/* but all other operands will result in a correctly signed infinity. */

FSUB:        bb0    s1inf,r12,subS2write /* branch if S1 not infinity */
             bb0    s2inf,r12,subS1write /* S2 is not inf., so branch to write S1 */
             bb1    sign,r5,subS1neg   /* handle case of S1 negative */
subS1pos:    bb0    sign,r7,excpt      /* subtracting infinities of the same sign */
                                       /* causes an exception */
             br     poswrinf           /* branch to write positive infinity */
subS1neg:    bb1    sign,r7,excpt      /* subtracting infinities of the same sign */
                                       /* causes an exception */
             br     negwrinf           /* branch to write negative infinity */
subS1write:  bb0    sign,r5,poswrinf   /* branch to write positive infinity */
             br     negwrinf           /* branch to write negative infinity */
subS2write:  bb1    sign,r7,poswrinf   /* branch to write positive infinity */
             br     negwrinf           /* branch to write negative infinity */


/* Compare the operands, at least one of which is infinity, and set the */
/* correct bits in the destination register. */

FCMP:        bb0.n  s1inf,r12,FCMPS1f  /* branch for finite S1 */
             set    r4,r0,1<cp>        /* since neither S1 or S2 is a NaN, set cp */
FCMPS1i:     bb1    sign,r5,FCMPS1ni   /* branch to negative S1i */
FCMPS1pi:    bb0    s2inf,r12,FCMPS1piS2f /* branch to finite S2 with S1pi */
FCMPS1piS2i: bb1    sign,r7,FCMPS1piS2ni /* branch to negative S2i with S1pi */
FCMPS1piS2pi: set   r4,r4,1<eq>        /* set eq bit  */
             set    r4,r4,1<le>        /* set le bit */
             set    r4,r4,1<ge>        /* set ge bit */
             set    r4,r4,1<ib>        /* set ib bit */
             br.n   move               /* return from subroutine */
             set    r4,r4,1<ob>        /* set ob bit */
FCMPS1piS2ni: set   r4,r4,1<ne>        /* set ne bit */
             set    r4,r4,1<gt>        /* set gt bit */
             br.n   move               /* return from subroutine */
             set    r4,r4,1<ge>        /* set ge bit */
FCMPS1piS2f: set    r4,r4,1<ne>        /* set ne bit */
             set    r4,r4,1<gt>        /* set gt bit */
             bsr.n  _zero              /* see if any of the operands are zero */
             set    r4,r4,1<ge>        /* set ge bit */
             bb0    s2zero,r12,FCMPS1piS2nz /* check for negative if s2 not zero */
	     set    r4,r4,1<ou>        /* set ou bit */
d1865 23
a1887 23
             set    r4,r4,1<ob>        /* set ob bit */
FCMPS1piS2nz: bb1    sign,r7,move     /* return from subroutine if s2 is neg. */
FCMPS1piS2pf: set   r4,r4,1<ou>        /* set ou bit */
             br.n   move             /* return from subroutine */
             set    r4,r4,1<ob>        /* set ob bit */
FCMPS1ni:    bb0    s2inf,r12,FCMPS1niS2f /* branch to finite S2 with S1ni */
FCMPS1niS2i: bb1    sign,r7,FCMPS1niS2ni /* branch to negative S2i with S1ni */
FCMPS1niS2pi: set   r4,r4,1<ne>        /* set eq bit  */
             set    r4,r4,1<le>        /* set le bit */
             set    r4,r4,1<lt>        /* set lt bit */
             set    r4,r4,1<ou>        /* set ou bit */
             br.n   move             /* return from subroutine */
             set    r4,r4,1<ob>        /* set ob bit */
FCMPS1niS2ni: set   r4,r4,1<eq>        /* set eq bit  */
             set    r4,r4,1<le>        /* set le bit */
             br.n   move             /* return from subroutine */
             set    r4,r4,1<ge>        /* set ge bit */
FCMPS1niS2f: set    r4,r4,1<ne>        /* set eq bit  */
             set    r4,r4,1<le>        /* set le bit */
             bsr.n  _zero              /* see if any of the operands are zero */
             set    r4,r4,1<lt>        /* set lt bit */
             bb0    s2zero,r12,FCMPS1niS2nz /* branch if s2 is not zero */
	     set    r4,r4,1<ou>        /* set ou bit */
d1889 10
a1898 10
             set    r4,r4,1<ob>        /* set ob bit */
FCMPS1niS2nz: bb1    sign,r7,move     /* return from subroutine if s2 is neg. */
             set    r4,r4,1<ou>        /* set ou bit */
             br.n   move             /* return from subroutine */
             set    r4,r4,1<ob>        /* set ob bit */
FCMPS1f:     bb1    sign,r5,FCMPS1nf   /* branch to negative S1f */
FCMPS1pf:    bb1.n  sign,r7,FCMPS1pfS2ni /* branch to negative S2i with S1pf */
             set   r4,r4,1<ne>        /* set ne bit    */
FCMPS1pfS2pi: set   r4,r4,1<le>        /* set le bit */
             set    r4,r4,1<lt>        /* set lt bit */
d1900 1
a1900 1
             set    r4,r4,1<ib>        /* set ib bit */
d1903 1
a1903 1
             set    r4,r4,1<ob>        /* set ob bit */
d1905 11
a1915 11
             set    r4,r4,1<in>        /* set in bit */
FCMPS1pfS2ni: set    r4,r4,1<gt>        /* set gt bit */
             br.n   move             /* return from subroutine */
             set    r4,r4,1<ge>        /* set ge bit */
FCMPS1nf:    bb1.n    sign,r7,FCMPS1nfS2ni /* branch to negative S2i with S1nf */
             set    r4,r4,1<ne>        /* set ne bit */
             set    r4,r4,1<le>        /* set gt bit */
             set    r4,r4,1<lt>        /* set ge bit */
             bsr.n  _zero              /* see which of the operands are zero */
             set    r4,r4,1<ob>        /* set ob bit */
             bb0    s1zero,r12,FCMPS1nfS2pinozero /* no ls and lo */
d1917 1
a1917 1
             set    r4,r4,1<ib>        /* set ib bit */
d1919 41
a1959 41
             set    r4,r4,1<ou>        /* set ou bit */
FCMPS1nfS2ni: set    r4,r4,1<gt>        /* set gt bit */
             set    r4,r4,1<ge>        /* set ge bit */

move:	     br.n   inf_return		/* return from subroutine */
             or	    r6,r0,r4            /* transfer answer to r6 */


/* Multiplying infinity and zero causes an exception, but all other */
/* operations produce a correctly signed infinity. */

FMUL:        bsr    _zero              /* see if any of the operands are zero */
             bb1    s1zero,r12,excpt   /* infinity X 0 causes an exception */
             bb1    s2zero,r12,excpt   /* infinity X 0 causes an exception */
             bb1    sign,r5,FMULS1neg  /* handle negative cases of S1 */
             bb0    sign,r7,poswrinf   /* + X + = + */
             br     negwrinf           /* + X - = - */
FMULS1neg:   bb1    sign,r7,poswrinf   /* - X - = + */
             br     negwrinf           /* - X + = - */


/* Dividing infinity by infinity causes an exception, but dividing  */
/* infinity by a finite yields a correctly signed infinity, and  */
/* dividing a finite by an infinity produces a correctly signed zero. */

FDIV:        bb1    s1inf,r12,FDIVS1inf /* handle case of S1 being infinity */
             bb1    sign,r5,FDIVS1nf    /* handle cases of S1 being neg. non-inf. */
             bb1    sign,r7,FDIVS1pfS2mi /* handle case of negative S2 */
FDIVS1pfS2pi: br    poswrzero           /* +f / +inf = +0 */
FDIVS1pfS2mi: br    negwrzero           /* +f / -inf = -0 */
FDIVS1nf:    bb1    sign,r7,FDIVS1nfS2mi /* handle case of negative S2 */
FDIVS1nfS2pi: br    negwrzero           /* -f / +inf = -0 */
FDIVS1nfS2mi: br    poswrzero           /* -f / -inf = +0 */
FDIVS1inf:   bb1    s2inf,r12,excpt     /* inf / inf = exception */
             bb1    sign,r5,FDIVS1mi    /* handle cases of S1 being neg. inf. */
             bb1    sign,r7,FDIVS1piS2nf /* handle case of negative S2 */
FDIVS1piS2pf: br    poswrinf            /* +inf / +f = +inf */
FDIVS1piS2nf: br    negwrinf            /* +inf / -f = -inf */
FDIVS1mi:    bb1    sign,r7,FDIVS1miS2nf /* handle case of negative S2 */
FDIVS1miS2pf: br    negwrinf            /* -inf / +f = -inf */
FDIVS1miS2nf: br    poswrinf            /* -inf / -f = +inf */
d1962 2
a1963 2
/* The square root of positive infinity is positive infinity, */
/* but the square root of negative infinity is a NaN */
d1965 2
a1966 2
/* FSQRT:       bb0    sign,r7,poswrinf    ;write sqrt(inf) = inf */
/*              br     excpt               ;write sqrt(-inf) = NaN */
d1969 1
a1969 1
             set    r2,r2,1<oper>      /* set invalid operation bit of FPSR */
d1971 3
a1973 3
	     bb0    oper,r3,nohandler  /* branch if no user handler */
             bsr    _handler           /* branch to interface with user handler */
             br     inf_return             /* return from function */
d1976 5
a1980 5
	     set    r5,r0,0<0>        /* write NaN into r5 */
             br.n   inf_return             /* return from subroutine */
             set    r6,r0,0<0>        /* write NaN into r6, writing NaN''s into */
                                       /* both of these registers is quicker than */
                                       /* checking for single or double precision */
d1983 7
a1989 7
/* Write positive infinity of the correct precision */

poswrinf:    bb1    dsize,r9,poswrinfd /* branch to write double precision inf. */
             br.n   inf_return             /* return from subroutine */
             or.u   r6,r0,0x7f80       /* load r6 with single precision pos inf.   */
poswrinfd:   or.u   r5,r0,0x7ff0       /* load double precision pos inf. */
             br.n   inf_return             /* return from subroutine */
d1993 1
a1993 1
/* Write negative infinity of the correct precision */
d1995 5
a1999 5
negwrinf:    bb1    dsize,r9,negwrinfd /* branch to write double precision inf. */
             br.n   inf_return             /* return from subroutine */
             or.u   r6,r0,0xff80       /* load r6 with single precision pos inf.   */
negwrinfd:   or.u   r5,r0,0xfff0       /* load double precision pos inf. */
             br.n   inf_return             /* return from subroutine */
d2003 1
a2003 1
/* Write a positive zero disregarding precision. */
d2005 2
a2006 2
poswrzero:   or     r5,r0,r0           /* write to both high word and low word now */
             br.n   inf_return             /* it does not matter that both are written */
d2010 1
a2010 1
/* Write a negative zero of the correct precision. */
d2012 7
a2018 7
negwrzero:   or     r6,r0,r0           /* clear low word */
             bb1    dsize,r9,negwrzerod /* branch to write double precision zero */
             br.n   inf_return             /* return from subroutine */
             set    r6,r6,1<31>        /* set sign bit */
negwrzerod:  or     r5,r0,r0           /* clear high word */
             br.n   inf_return             /* return from subroutine */
             set    r5,r5,1<31>        /* set sign bit */
d2021 1
a2021 1
             set    r2,r2,1<oper>       /* set invalid operand bit */
d2023 3
a2025 3
	     bb0    oper,r3,nohandlero  /* do not go to user handler routine */
             bsr    _handler            /* go to user handler routine */
             br     inf_return              /* return from subroutine */
d2028 1
a2028 1
nohandlero:  bb0.n  sign,r7,inf_return      /* if positive then return from subroutine */
d2030 2
a2031 2
             set    r6,r6,31<0>         /* set result to largest positive integer */
             or.c   r6,r0,r6            /* negate r6,giving largest negative int. */
d2033 2
a2034 2
inf_return:      ld     r1,r31,0          /* load return address */
             jmp    r1                 /* return from subroutine */
d2037 4
d2050 3
a2052 3
/* function _denorm --       */
/* See the documentation for this release for an overall description of this */
/* code. */
d2054 2
d2057 85
a2141 4
/* Check to see if either S1 or S2 is a denormalized number.  First  */
/* extract the exponent to see if it is zero, and then check to see if */
/* the mantissa is not zero.  If the number is denormalized, then set the */
/* 1 or 0 bit 10 r12. */
d2143 2
a2144 86
             text
	     align 8
             global _denorm
_denorm:     st     r1,r31,0  /* save return address */
dnmcheckS1:  extu   r10,r5,11<20>  /* extract exponent */
             bcnd   ne0,r10,dnmsetS2 /* S1 is not a denorm, so S2 must be */
             bb1.n  9,r9,dnmcheckS1d /* S1 is double precision */
             mak    r10,r5,20<3>   /* mak field with only mantissa bits */
                                   /* into final result */
dnmcheckS1s: extu   r11,r6,3<29>   /* get three low bits of mantissa */
             or     r10,r10,r11    /* assemble all of the mantissa bits */
             bcnd   eq0,r10,dnmsetS2 /* S1 is not a denorm, so S2 must be */
             br     dnmsetS1       /* S1 is a denorm */

dnmcheckS1d: or     r10,r6,r10     /* or all of mantissa bits */
             bcnd   eq0,r10,dnmsetS2 /* S1 is not a denorm, so S2 must be */
dnmsetS1:    set    r12,r12,1<1> /* S1 is a denorm */

dnmcheckS2:  extu   r10,r7,11<20>  /* extract exponent */
             bcnd   ne0,r10,S1form /* S2 is not a denorm */
             bb1.n  7,r9,dnmcheckS2d /* S2 is double precision */
             mak    r10,r7,20<3>   /* mak field with only mantissa bits */
dnmcheckS2s: extu   r11,r8,3<29>   /* get three low bits of mantissa */
             or     r10,r10,r11    /* assemble all of the mantissa bits */
             bcnd   eq0,r10,S1form /* S2 is not a denorm */
             br     dnmsetS2       /* S1 is a denorm */
dnmcheckS2d: or     r10,r8,r10     /* or all or mantissa bits */
             bcnd   eq0,r10,S1form /* S2 is not a denorm */
dnmsetS2:    set    r12,r12,1<0> /* S2 is a denorm */


/* Since the operations are going to be reperformed with modified denorms, */
/* the operands which were initially single precision need to be modified */
/* back to single precision.   */

S1form:      bb1    9,r9,S2form /* S1 is double precision, so do not */
                                     /* modify S1 into single format */
             mak    r11,r5,28<3>   /*  over final exponent and mantissa */
                                   /* eliminating extra 3 bits of exponent */
             extu   r6,r6,3<29>    /* get low 3 bits of mantissa */
             or     r11,r6,r11     /* form complete mantissa and exponent */
             extu   r10,r5,1<31> /* get the 31 bit */
             mak    r10,r10,1<31>  /* place 31 bit 10 correct position */
             or     r6,r10,r11     /* or 31, exponent, and all of mantissa */

S2form:      bb1    7,r9,checkop /* S2 is double precision, so do not */
                                      /* modify S2 into single format */
             mak    r11,r7,28<3>   /*  over final exponent and mantissa */
                                   /* eliminating extra 3 bits of exponent */
             extu   r8,r8,3<29>    /* get low 3 bits of mantissa */
             or     r11,r8,r11     /* form complete mantissa and exponent */
             extu   r10,r7,1<31> /* get the 31 bit */
             mak    r10,r10,1<31>  /* place 31 bit 10 correct position */
             or     r8,r10,r11     /* or 31, exponent, and all of mantissa */


/* Extract the opcode, compare to a constant, and branch to the code that */
/* deals with that opcode. */

checkop:     extu   r10,r9,5<11>   /* extract opcode */
             cmp    r11,r10,0x05 /* compare to FADD */
             bb1    2,r11,FADD    /* operation is FADD */
             cmp    r11,r10,0x06 /* compare to FSUB */
             bb1    2,r11,FSUB    /* operation is FSUB */
             cmp    r11,r10,0x07 /* compare to FCMP */
             bb1    2,r11,FCMP    /* operation is FCMP */
             cmp    r11,r10,0x00 /* compare to FMUL */
             bb1    2,r11,FMUL    /* operation is FMUL */
             cmp    r11,r10,0x0e /* compare to FDIV */
             bb1    2,r11,FDIV    /* operation is FDIV */
/*              cmp    r11,r10,0x0f;compare to FSQRT */
/*              bb1    2,r11,FSQRT   ;operation is FSQRT */
             cmp    r11,r10,0x09  /* compare to INT */
             bb1    2,r11,INT     /* operation is INT */
             cmp    r11,r10,0x0a /* compare to NINT */
             bb1    2,r11,NINT    /* operation is NINT */
             cmp    r11,r10,0x0b /* compare to TRNC */
             bb1    2,r11,TRNC    /* operation is TRNC */


/* For all the following operations, the denormalized number is set to */
/* zero and the operation is reperformed the correct destination and source */
/* sizes. */

FADD:        bb0    1,r12,FADDS2dnm /* S1 is not denorm, so S2 must be */
             or     r5,r0,r0     /* set S1 to zero */
d2146 2
a2147 2
FADDS2chk:   bb0    0,r12,FADDcalc /* S2 is not a denorm */
FADDS2dnm:   or     r7,r0,r0     /* set S2 to zero */
d2149 23
a2171 23
FADDcalc:    bb1    5,r9,FADDdD   /* branch for double precision destination */
FADDsD:      bb1    9,r9,FADDsDdS1 /* branch for double precision S1 */
FADDsDsS1:   bb1    7,r9,FADDsDsS1dS2 /* branch for double precision S2 */
FADDsDsS1sS2: br.n  return      /* return from subroutine */
              fadd.sss r6,r6,r8   /* add the two sources and place result 10 S1 */
FADDsDsS1dS2: br.n  return      /* return from subroutine */
              fadd.ssd r6,r6,r7   /* add the two sources and place result 10 S1 */
FADDsDdS1:   bb1    7,r9,FADDsDdS1dS2 /* branch for double precision S2 */
FADDsDdS1sS2: br.n  return      /* return from subroutine */
              fadd.sds r6,r5,r8   /* add the two sources and place result 10 S1 */
FADDsDdS1dS2: br.n  return      /* return from subroutine */
              fadd.sdd r6,r5,r7   /* add the two sources and place result 10 S1 */
FADDdD:      bb1    9,r9,FADDdDdS1 /* branch for double precision S1 */
FADDdDsS1:   bb1    7,r9,FADDdDsS1dS2 /* branch for double precision S2 */
FADDdDsS1sS2: br.n  return      /* return from subroutine */
              fadd.dss r5,r6,r8   /* add the two sources and place result 10 S1 */
FADDdDsS1dS2: br.n  return      /* return from subroutine */
              fadd.dsd r5,r6,r7   /* add the two sources and place result 10 S1 */
FADDdDdS1:   bb1    7,r9,FADDdDdS1dS2 /* branch for double precision S2 */
FADDdDdS1sS2: br.n  return      /* return from subroutine */
              fadd.dds r5,r5,r8   /* add the two sources and place result 10 S1 */
FADDdDdS1dS2: br.n  return      /* return from subroutine */
              fadd.ddd r5,r5,r7   /* add the two sources and place result 10 S1 */
d2173 2
a2174 2
FSUB:        bb0    1,r12,FSUBS2dnm /* S1 is not denorm, so S2 must be */
             or     r5,r0,r0     /* set S1 to zero */
d2176 2
a2177 2
FSUBS2chk:   bb0    0,r12,FSUBcalc /* S2 is not a denorm */
FSUBS2dnm:   or     r7,r0,r0     /* set S2 to zero */
d2179 23
a2201 23
FSUBcalc:    bb1    5,r9,FSUBdD   /* branch for double precision destination */
FSUBsD:      bb1    9,r9,FSUBsDdS1 /* branch for double precision S1 */
FSUBsDsS1:   bb1    7,r9,FSUBsDsS1dS2 /* branch for double precision S2 */
FSUBsDsS1sS2: br.n  return      /* return from subroutine */
              fsub.sss r6,r6,r8   /* add the two sources and place result 10 S1 */
FSUBsDsS1dS2: br.n  return      /* return from subroutine */
              fsub.ssd r6,r6,r7   /* add the two sources and place result 10 S1 */
FSUBsDdS1:   bb1    7,r9,FSUBsDdS1dS2 /* branch for double precision S2 */
FSUBsDdS1sS2: br.n  return      /* return from subroutine */
              fsub.sds r6,r5,r8   /* add the two sources and place result 10 S1 */
FSUBsDdS1dS2: br.n  return      /* return from subroutine */
              fsub.sdd r6,r5,r7   /* add the two sources and place result 10 S1 */
FSUBdD:      bb1    9,r9,FSUBdDdS1 /* branch for double precision S1 */
FSUBdDsS1:   bb1    7,r9,FSUBdDsS1dS2 /* branch for double precision S2 */
FSUBdDsS1sS2: br.n  return      /* return from subroutine */
              fsub.dss r5,r6,r8   /* add the two sources and place result 10 S1 */
FSUBdDsS1dS2: br.n  return      /* return from subroutine */
              fsub.dsd r5,r6,r7   /* add the two sources and place result 10 S1 */
FSUBdDdS1:   bb1    7,r9,FSUBdDdS1dS2 /* branch for double precision S2 */
FSUBdDdS1sS2: br.n  return      /* return from subroutine */
              fsub.dds r5,r5,r8   /* add the two sources and place result 10 S1 */
FSUBdDdS1dS2: br.n  return      /* return from subroutine */
              fsub.ddd r5,r5,r7   /* add the two sources and place result 10 S1 */
d2203 2
a2204 2
FCMP:        bb0    1,r12,FCMPS2dnm /* S1 is not denorm, so S2 must be */
             or     r5,r0,r0     /* set S1 to zero */
d2206 2
a2207 2
FCMPS2chk:   bb0    0,r12,FCMPcalc /* S2 is not a denorm */
FCMPS2dnm:   or     r7,r0,r0     /* set S2 to zero */
d2209 11
a2219 11
FCMPcalc:    bb1    9,r9,FCMPdS1 /* branch for double precision S1 */
FCMPsS1:     bb1    7,r9,FCMPsS1dS2 /* branch for double precision S2 */
FCMPsS1sS2:  br.n  return      /* return from subroutine */
             fcmp.sss r6,r6,r8   /* add the two sources and place result 10 S1 */
FCMPsS1dS2:  br.n  return      /* return from subroutine */
             fcmp.ssd r6,r6,r7   /* add the two sources and place result 10 S1 */
FCMPdS1:     bb1    7,r9,FCMPdS1dS2 /* branch for double precision S2 */
FCMPdS1sS2:  br.n  return      /* return from subroutine */
             fcmp.sds r6,r5,r8   /* add the two sources and place result 10 S1 */
FCMPdS1dS2:  br.n  return      /* return from subroutine */
             fcmp.sdd r6,r5,r7   /* add the two sources and place result 10 S1 */
d2221 2
a2222 2
FMUL:        bb0    1,r12,FMULS2dnm /* S1 is not denorm, so S2 must be */
             or     r5,r0,r0     /* set S1 to zero */
d2224 2
a2225 2
FMULS2chk:   bb0    0,r12,FMULcalc /* S2 is not a denorm */
FMULS2dnm:   or     r7,r0,r0     /* set S2 to zero */
d2227 23
a2249 23
FMULcalc:    bb1    5,r9,FMULdD   /* branch for double precision destination */
FMULsD:      bb1    9,r9,FMULsDdS1 /* branch for double precision S1 */
FMULsDsS1:   bb1    7,r9,FMULsDsS1dS2 /* branch for double precision S2 */
FMULsDsS1sS2: br.n  return      /* return from subroutine */
              fmul.sss r6,r6,r8   /* add the two sources and place result 10 S1 */
FMULsDsS1dS2: br.n  return      /* return from subroutine */
              fmul.ssd r6,r6,r7   /* add the two sources and place result 10 S1 */
FMULsDdS1:   bb1    7,r9,FMULsDdS1dS2 /* branch for double precision S2 */
FMULsDdS1sS2: br.n  return      /* return from subroutine */
              fmul.sds r6,r5,r8   /* add the two sources and place result 10 S1 */
FMULsDdS1dS2: br.n  return      /* return from subroutine */
              fmul.sdd r6,r5,r7   /* add the two sources and place result 10 S1 */
FMULdD:      bb1    9,r9,FMULdDdS1 /* branch for double precision S1 */
FMULdDsS1:   bb1    7,r9,FMULdDsS1dS2 /* branch for double precision S2 */
FMULdDsS1sS2: br.n  return      /* return from subroutine */
              fmul.dss r5,r6,r8   /* add the two sources and place result 10 S1 */
FMULdDsS1dS2: br.n  return      /* return from subroutine */
              fmul.dsd r5,r6,r7   /* add the two sources and place result 10 S1 */
FMULdDdS1:   bb1    7,r9,FMULdDdS1dS2 /* branch for double precision S2 */
FMULdDdS1sS2: br.n  return      /* return from subroutine */
              fmul.dds r5,r5,r8   /* add the two sources and place result 10 S1 */
FMULdDdS1dS2: br.n  return      /* return from subroutine */
              fmul.ddd r5,r5,r7   /* add the two sources and place result 10 S1 */
d2251 2
a2252 2
FDIV:        bb0    1,r12,FDIVS2dnm /* S1 is not denorm, so S2 must be */
             or     r5,r0,r0     /* set S1 to zero */
d2254 2
a2255 2
FDIVS2chk:   bb0    0,r12,FDIVcalc /* S2 is not a denorm */
FDIVS2dnm:   or     r7,r0,r0     /* set S2 to zero */
d2257 37
a2293 37
FDIVcalc:    bb1    5,r9,FDIVdD   /* branch for double precision destination */
FDIVsD:      bb1    9,r9,FDIVsDdS1 /* branch for double precision S1 */
FDIVsDsS1:   bb1    7,r9,FDIVsDsS1dS2 /* branch for double precision S2 */
FDIVsDsS1sS2: fdiv.sss r6,r6,r8   /* add the two sources and place result 10 S1 */
	      br  return      /* return from subroutine */
FDIVsDsS1dS2: fdiv.ssd r6,r6,r7   /* add the two sources and place result 10 S1 */
              br    return      /* return from subroutine */
FDIVsDdS1:   bb1    7,r9,FDIVsDdS1dS2 /* branch for double precision S2 */
FDIVsDdS1sS2: fdiv.sds r6,r5,r8   /* add the two sources and place result 10 S1 */
	      br    return      /* return from subroutine */
FDIVsDdS1dS2: fdiv.sdd r6,r5,r7   /* add the two sources and place result 10 S1 */
	      br    return      /* return from subroutine */
FDIVdD:      bb1    9,r9,FDIVdDdS1 /* branch for double precision S1 */
FDIVdDsS1:   bb1    7,r9,FDIVdDsS1dS2 /* branch for double precision S2 */
FDIVdDsS1sS2: fdiv.dss r5,r6,r8   /* add the two sources and place result 10 S1 */
	      br    return      /* return from subroutine */
FDIVdDsS1dS2: fdiv.dsd r5,r6,r7   /* add the two sources and place result 10 S1 */
	      br    return      /* return from subroutine */
FDIVdDdS1:   bb1    7,r9,FDIVdDdS1dS2 /* branch for double precision S2 */
FDIVdDdS1sS2: fdiv.dds r5,r5,r8   /* add the two sources and place result 10 S1 */
	      br    return      /* return from subroutine */
FDIVdDdS1dS2: fdiv.ddd r5,r5,r7   /* add the two sources and place result 10 S1 */
	      br    return      /* return from subroutine */

/* FSQRT:       or     r7,r0,r0     ;set S2 to zero */
/*              or     r8,r0,r0 */
/* FSQRTcalc:   bb1    5,r9,FSQRTdD   ;branch for double precision destination */
/* FSQRTsD:     bb1    7,r9,FSQRTsDdS2 ;branch for double precision S2 */
/* FSQRTsDsS2:  br.n   return   ;return from subroutine */
            /* fsqrt.ss r6,r8   ;add the two sources and place result 10 S1 */
/* FSQRTsDdS2:  br.n   return   ;return from subroutine */
            /* fsqrt.sd r6,r7   ;add the two sources and place result 10 S1 */
/* FSQRTdD:     bb1    7,r9,FSQRTdDdS2 ;branch for double precision S2 */
/* FSQRTdDsS2:  br.n   return   ;return from subroutine */
            /* fsqrt.ds r5,r8   ;add the two sources and place result 10 S1 */
/* FSQRTdDdS2:  br.n   return   ;return from subroutine */
            /* fsqrt.dd r5,r7   ;add the two sources and place result 10 S1 */
d2295 1
a2295 1
INT:         or     r7,r0,r0     /* set S2 to zero */
d2297 5
a2301 5
INTcalc:     bb1    7,r9,INTdS2 /* branch for double precision S2 */
INTsS2:      br.n   return   /* return from subroutine */
             int.ss r6,r8    /* add the two sources and place result 10 S1 */
INTdS2:      br.n   return   /* return from subroutine */
             int.sd r6,r7   /* add the two sources and place result 10 S1 */
d2303 1
a2303 1
NINT:        or     r7,r0,r0     /* set S2 to zero */
d2305 5
a2309 5
NINTcalc:    bb1    7,r9,NINTdS2 /* branch for double precision S2 */
NINTsS2:     br.n   return   /* return from subroutine */
             nint.ss r6,r8    /* add the two sources and place result 10 S1 */
NINTdS2:     br.n   return   /* return from subroutine */
             nint.sd r6,r7   /* add the two sources and place result 10 S1 */
d2311 1
a2311 1
TRNC:        or     r7,r0,r0     /* set S2 to zero */
d2313 4
a2316 4
TRNCcalc:    bb1    7,r9,TRNCdS2 /* branch for double precision S2 */
TRNCsS2:     br.n   return   /* return from subroutine */
             trnc.ss r6,r8    /* add the two sources and place result 10 S1 */
TRNCdS2:     trnc.sd r6,r7   /* add the two sources and place result 10 S1 */
d2319 1
a2319 1
/* Return to the routine that detected the reserved operand. */
d2321 2
a2322 2
return:      ld     r1,r31,0    /* load return address */
             jmp    r1                 /* return from subroutine */
d2325 4
d2330 5
d2336 2
a2337 2
/* S1 and/or S2 is an infinity, and the other operand may be a zero. */
/* Knowing which operands are infinity, check the remaining operands for zeros. */
d2339 47
a2385 50
             text
	     align 8
             global _zero
_zero:       bb0    s1inf,r12,S1noinf /* see if S1 is zero */
             bb0    s2inf,r12,S2noinf /* see if S2 is zero */
             jmp    r1                /* return from function */

/* See if S1 is zero.  Whether or not S1 is a zero, being in this routine */
/* implies that S2 is infinity, so return to subroutine infinity after  */
/* completing this code.  Set the s1zero flag in r12 if S1 is zero. */

S1noinf:     bb1    s1size,r9,S1noinfd /* work with double precision operand */
S1noinfs:    or     r10,r0,r5          /* load high word into r10 */
             clr    r10,r10,1<sign>    /* clear the sign bit */
             extu   r11,r6,3<29>       /* extract lower 3 bits of mantissa */
             or     r10,r10,r11        /* or these 3 bits with high word */
             bcnd   ne0,r10,operation  /* do not set zero flag */
             jmp.n  r1                 /* since this operand was not infinity, */
                                       /* S2 must have been, so return from */
                                       /* function */
             set    r12,r12,1<s1zero>  /* set zeroflag */
S1noinfd:    clr    r10,r5,1<sign>     /* clear the sign bit */
             or     r10,r6,r10         /* or high and low word */
             bcnd   ne0,r10,operation  /* do not set zero flag */
             jmp.n  r1                 /* since this operand was not infinity, */
                                       /* S2 must have been, so return from */
                                       /* function */
             set    r12,r12,1<s1zero>  /* set zeroflag */


/* Check S2 for zero.  If it is zero, then set the s2zero flag in r12. */

S2noinf:     bb1    s2size,r9,S2noinfd /* work with double precision operand */
S2noinfs:    or     r10,r0,r7          /* load high word into r10 */
             clr    r10,r10,1<sign>    /* clear the sign bit */
             extu   r11,r8,3<29>       /* extract lower 3 bits of mantissa */
             or     r10,r10,r11        /* or these 3 bits with high word */
             bcnd   ne0,r10,operation  /* do not set zero flag */
             jmp.n  r1                 /* since this operand was not infinity, */
                                       /* S1 must have been, so return from */
                                       /* function */
             set    r12,r12,1<s2zero>  /* set zeroflag */
S2noinfd:    clr    r10,r7,1<sign>     /* clear the sign bit */
             or     r10,r8,r10         /* or high and low word */
             bcnd   ne0,r10,operation  /* do not set zero flag */
             set    r12,r12,1<s2zero>  /* set zeroflag */
                                       /* since this operand was not infinity, */
                                       /* S1 must have been, so return from */
                                       /* function */
operation:   jmp    r1                 /* return from function */
d2388 4
d2394 2
a2395 2
		align 8
/*  input: r3 is the excepton frame */
d2397 1
a2397 1
		or	r29, r3, r0	/*  r29 is now the E.F. */
d2409 2
a2410 2
/* Load into r1 the return address for the exception handlers.  Looking */
/* at FPECR, branch to the appropriate exception handler. */
d2412 1
a2412 1
		or.u	r1,r0,hi16(fpui_wrapup)/* load return address of functions */
d2415 1
a2415 1
		bb0  	2,r4,2f /* branch to FPunderflow if bit set */
d2417 1
a2417 1
	2:	bb0	1,r4,3f /* branch to FPoverflow if bit set */
d2421 2
a2422 2
		br	_handler	/* branch to handler since bit will be set */
					/* for inexact */
d2426 1
a2426 1
	align 8
d2428 1
a2428 1
	align 8
d2439 4
a2442 4
        tb1     0,r0,0          /* make sure all floating point operations */
        ldcr    r5, psr        /* load the PSR */
        /* have finished */
        or      r5, r5, 0x2   /* disable interrupts */
d2446 1
a2446 1
        or      r5, r5, 0x8   /* set SFU 1 disable bit, disable SFU 1 */
d2453 1
a2453 1
	/*  write back the results */
d2462 1
a2462 1
/* Return.. */
@
