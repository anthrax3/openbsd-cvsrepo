head	1.261;
access;
symbols
	OPENBSD_5_5:1.259.0.4
	OPENBSD_5_5_BASE:1.259
	OPENBSD_5_4:1.255.0.2
	OPENBSD_5_4_BASE:1.255
	OPENBSD_5_3:1.248.0.2
	OPENBSD_5_3_BASE:1.248
	OPENBSD_5_2:1.245.0.4
	OPENBSD_5_2_BASE:1.245
	OPENBSD_5_1_BASE:1.245
	OPENBSD_5_1:1.245.0.2
	OPENBSD_5_0:1.244.0.2
	OPENBSD_5_0_BASE:1.244
	OPENBSD_4_9:1.241.0.2
	OPENBSD_4_9_BASE:1.241
	OPENBSD_4_8:1.237.0.2
	OPENBSD_4_8_BASE:1.237
	OPENBSD_4_7:1.235.0.2
	OPENBSD_4_7_BASE:1.235
	OPENBSD_4_6:1.231.0.4
	OPENBSD_4_6_BASE:1.231
	OPENBSD_4_5:1.226.0.4
	OPENBSD_4_5_BASE:1.226
	OPENBSD_4_4:1.213.0.2
	OPENBSD_4_4_BASE:1.213
	OPENBSD_4_3:1.210.0.2
	OPENBSD_4_3_BASE:1.210
	OPENBSD_4_2:1.192.0.2
	OPENBSD_4_2_BASE:1.192
	OPENBSD_4_1:1.185.0.2
	OPENBSD_4_1_BASE:1.185
	OPENBSD_4_0:1.184.0.2
	OPENBSD_4_0_BASE:1.184
	OPENBSD_3_9:1.176.0.2
	OPENBSD_3_9_BASE:1.176
	OPENBSD_3_8:1.165.0.2
	OPENBSD_3_8_BASE:1.165
	OPENBSD_3_7:1.163.0.2
	OPENBSD_3_7_BASE:1.163
	OPENBSD_3_6:1.155.0.2
	OPENBSD_3_6_BASE:1.155
	SMP_SYNC_A:1.142
	SMP_SYNC_B:1.142
	OPENBSD_3_5:1.136.0.2
	OPENBSD_3_5_BASE:1.136
	OPENBSD_3_4:1.110.0.2
	OPENBSD_3_4_BASE:1.110
	UBC_SYNC_A:1.101
	OPENBSD_3_3:1.100.0.2
	OPENBSD_3_3_BASE:1.100
	OPENBSD_3_2:1.95.0.2
	OPENBSD_3_2_BASE:1.95
	OPENBSD_3_1:1.93.0.2
	OPENBSD_3_1_BASE:1.93
	UBC_SYNC_B:1.96
	UBC:1.76.0.2
	UBC_BASE:1.76
	OPENBSD_3_0:1.61.0.2
	OPENBSD_3_0_BASE:1.61
	OPENBSD_2_9:1.31.0.2
	OPENBSD_2_9_BASE:1.31
	OPENBSD_2_8:1.20.0.4
	OPENBSD_2_8_BASE:1.20
	OPENBSD_2_7:1.20.0.2
	OPENBSD_2_7_BASE:1.20
	SMP:1.18.0.2
	SMP_BASE:1.18
	kame_19991208:1.18
	OPENBSD_2_6:1.17.0.2
	OPENBSD_2_6_BASE:1.17
	OPENBSD_2_5:1.12.0.2
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.7.0.6
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	mvme88kport:1.1.1.1
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.261
date	2014.03.18.22.36.36;	author miod;	state dead;
branches;
next	1.260;

1.260
date	2014.03.13.03.52.55;	author dlg;	state Exp;
branches;
next	1.259;

1.259
date	2014.01.19.12.45.35;	author deraadt;	state Exp;
branches;
next	1.258;

1.258
date	2013.11.02.23.10.29;	author miod;	state Exp;
branches;
next	1.257;

1.257
date	2013.10.17.08.02.17;	author deraadt;	state Exp;
branches;
next	1.256;

1.256
date	2013.09.28.12.40.31;	author miod;	state Exp;
branches;
next	1.255;

1.255
date	2013.06.11.16.42.10;	author deraadt;	state Exp;
branches;
next	1.254;

1.254
date	2013.06.03.16.55.22;	author guenther;	state Exp;
branches;
next	1.253;

1.253
date	2013.05.17.22.51.59;	author miod;	state Exp;
branches;
next	1.252;

1.252
date	2013.05.17.22.46.28;	author miod;	state Exp;
branches;
next	1.251;

1.251
date	2013.05.17.22.38.25;	author miod;	state Exp;
branches;
next	1.250;

1.250
date	2013.05.15.20.18.04;	author miod;	state Exp;
branches;
next	1.249;

1.249
date	2013.05.14.20.30.47;	author miod;	state Exp;
branches;
next	1.248;

1.248
date	2012.12.26.22.32.13;	author miod;	state Exp;
branches;
next	1.247;

1.247
date	2012.10.21.09.51.59;	author miod;	state Exp;
branches;
next	1.246;

1.246
date	2012.10.08.21.47.49;	author deraadt;	state Exp;
branches;
next	1.245;

1.245
date	2011.10.09.17.01.34;	author miod;	state Exp;
branches;
next	1.244;

1.244
date	2011.06.26.22.40.00;	author deraadt;	state Exp;
branches;
next	1.243;

1.243
date	2011.06.05.19.41.07;	author deraadt;	state Exp;
branches;
next	1.242;

1.242
date	2011.05.30.22.25.21;	author oga;	state Exp;
branches;
next	1.241;

1.241
date	2011.01.05.22.20.22;	author miod;	state Exp;
branches;
next	1.240;

1.240
date	2010.12.31.21.38.08;	author miod;	state Exp;
branches;
next	1.239;

1.239
date	2010.12.23.20.05.08;	author miod;	state Exp;
branches;
next	1.238;

1.238
date	2010.09.20.06.33.47;	author matthew;	state Exp;
branches;
next	1.237;

1.237
date	2010.06.27.12.41.23;	author miod;	state Exp;
branches;
next	1.236;

1.236
date	2010.06.27.03.03.48;	author thib;	state Exp;
branches;
next	1.235;

1.235
date	2009.08.11.19.17.16;	author miod;	state Exp;
branches;
next	1.234;

1.234
date	2009.08.11.18.46.32;	author miod;	state Exp;
branches;
next	1.233;

1.233
date	2009.08.09.10.40.17;	author blambert;	state Exp;
branches;
next	1.232;

1.232
date	2009.08.02.16.28.39;	author beck;	state Exp;
branches;
next	1.231;

1.231
date	2009.06.15.17.01.26;	author beck;	state Exp;
branches;
next	1.230;

1.230
date	2009.06.03.21.30.20;	author beck;	state Exp;
branches;
next	1.229;

1.229
date	2009.04.19.17.56.13;	author miod;	state Exp;
branches;
next	1.228;

1.228
date	2009.03.15.20.39.53;	author miod;	state Exp;
branches;
next	1.227;

1.227
date	2009.03.05.21.55.15;	author miod;	state Exp;
branches;
next	1.226;

1.226
date	2009.02.27.05.19.36;	author miod;	state Exp;
branches;
next	1.225;

1.225
date	2009.02.21.18.37.49;	author miod;	state Exp;
branches;
next	1.224;

1.224
date	2009.02.21.18.35.22;	author miod;	state Exp;
branches;
next	1.223;

1.223
date	2009.02.20.20.36.14;	author miod;	state Exp;
branches;
next	1.222;

1.222
date	2009.02.16.23.03.33;	author miod;	state Exp;
branches;
next	1.221;

1.221
date	2009.02.16.22.55.03;	author miod;	state Exp;
branches;
next	1.220;

1.220
date	2009.02.13.23.33.51;	author miod;	state Exp;
branches;
next	1.219;

1.219
date	2009.02.13.23.31.29;	author miod;	state Exp;
branches;
next	1.218;

1.218
date	2009.02.13.23.26.51;	author miod;	state Exp;
branches;
next	1.217;

1.217
date	2009.02.08.21.59.21;	author miod;	state Exp;
branches;
next	1.216;

1.216
date	2009.02.08.21.40.58;	author miod;	state Exp;
branches;
next	1.215;

1.215
date	2009.02.01.00.51.32;	author miod;	state Exp;
branches;
next	1.214;

1.214
date	2008.10.30.22.07.18;	author miod;	state Exp;
branches;
next	1.213;

1.213
date	2008.06.27.17.22.14;	author miod;	state Exp;
branches;
next	1.212;

1.212
date	2008.06.08.20.57.19;	author miod;	state Exp;
branches;
next	1.211;

1.211
date	2008.04.09.16.58.10;	author deraadt;	state Exp;
branches;
next	1.210;

1.210
date	2008.01.23.16.37.57;	author jsing;	state Exp;
branches;
next	1.209;

1.209
date	2008.01.13.20.20.29;	author miod;	state Exp;
branches;
next	1.208;

1.208
date	2008.01.13.20.18.56;	author miod;	state Exp;
branches;
next	1.207;

1.207
date	2007.12.31.09.23.54;	author martin;	state Exp;
branches;
next	1.206;

1.206
date	2007.12.27.23.17.55;	author miod;	state Exp;
branches;
next	1.205;

1.205
date	2007.12.15.19.37.41;	author miod;	state Exp;
branches;
next	1.204;

1.204
date	2007.12.15.19.35.54;	author miod;	state Exp;
branches;
next	1.203;

1.203
date	2007.11.17.05.36.23;	author miod;	state Exp;
branches;
next	1.202;

1.202
date	2007.11.17.05.32.05;	author miod;	state Exp;
branches;
next	1.201;

1.201
date	2007.11.15.21.23.16;	author miod;	state Exp;
branches;
next	1.200;

1.200
date	2007.11.14.23.15.07;	author miod;	state Exp;
branches;
next	1.199;

1.199
date	2007.11.14.23.12.46;	author miod;	state Exp;
branches;
next	1.198;

1.198
date	2007.11.06.21.42.56;	author miod;	state Exp;
branches;
next	1.197;

1.197
date	2007.10.28.19.48.47;	author miod;	state Exp;
branches;
next	1.196;

1.196
date	2007.10.28.19.45.52;	author miod;	state Exp;
branches;
next	1.195;

1.195
date	2007.10.28.19.42.12;	author miod;	state Exp;
branches;
next	1.194;

1.194
date	2007.10.13.12.55.21;	author miod;	state Exp;
branches;
next	1.193;

1.193
date	2007.10.10.15.53.52;	author art;	state Exp;
branches;
next	1.192;

1.192
date	2007.06.06.17.15.12;	author deraadt;	state Exp;
branches;
next	1.191;

1.191
date	2007.05.29.20.36.48;	author deraadt;	state Exp;
branches;
next	1.190;

1.190
date	2007.05.27.17.31.57;	author miod;	state Exp;
branches;
next	1.189;

1.189
date	2007.05.26.20.26.51;	author pedro;	state Exp;
branches;
next	1.188;

1.188
date	2007.05.23.20.33.46;	author pvalchev;	state Exp;
branches;
next	1.187;

1.187
date	2007.05.14.17.00.40;	author miod;	state Exp;
branches;
next	1.186;

1.186
date	2007.05.12.20.03.25;	author miod;	state Exp;
branches;
next	1.185;

1.185
date	2006.11.18.22.58.28;	author miod;	state Exp;
branches;
next	1.184;

1.184
date	2006.07.07.19.36.56;	author miod;	state Exp;
branches;
next	1.183;

1.183
date	2006.05.08.14.36.10;	author miod;	state Exp;
branches;
next	1.182;

1.182
date	2006.05.08.14.03.35;	author miod;	state Exp;
branches;
next	1.181;

1.181
date	2006.05.02.21.43.09;	author miod;	state Exp;
branches;
next	1.180;

1.180
date	2006.04.26.20.49.58;	author miod;	state Exp;
branches;
next	1.179;

1.179
date	2006.04.19.22.09.40;	author miod;	state Exp;
branches;
next	1.178;

1.178
date	2006.04.15.15.43.36;	author miod;	state Exp;
branches;
next	1.177;

1.177
date	2006.04.13.21.16.18;	author miod;	state Exp;
branches;
next	1.176;

1.176
date	2005.12.11.21.45.31;	author miod;	state Exp;
branches;
next	1.175;

1.175
date	2005.12.11.21.36.06;	author miod;	state Exp;
branches;
next	1.174;

1.174
date	2005.12.11.17.05.37;	author miod;	state Exp;
branches;
next	1.173;

1.173
date	2005.12.04.15.00.26;	author miod;	state Exp;
branches;
next	1.172;

1.172
date	2005.12.04.12.20.19;	author miod;	state Exp;
branches;
next	1.171;

1.171
date	2005.12.03.14.30.06;	author miod;	state Exp;
branches;
next	1.170;

1.170
date	2005.11.28.22.21.16;	author miod;	state Exp;
branches;
next	1.169;

1.169
date	2005.10.13.19.48.37;	author miod;	state Exp;
branches;
next	1.168;

1.168
date	2005.10.12.19.05.44;	author miod;	state Exp;
branches;
next	1.167;

1.167
date	2005.09.25.20.30.03;	author miod;	state Exp;
branches;
next	1.166;

1.166
date	2005.09.11.23.05.37;	author miod;	state Exp;
branches;
next	1.165;

1.165
date	2005.04.30.16.42.37;	author miod;	state Exp;
branches;
next	1.164;

1.164
date	2005.04.27.14.09.45;	author miod;	state Exp;
branches;
next	1.163;

1.163
date	2004.12.02.19.40.46;	author miod;	state Exp;
branches;
next	1.162;

1.162
date	2004.11.09.18.25.24;	author miod;	state Exp;
branches;
next	1.161;

1.161
date	2004.11.09.12.01.19;	author miod;	state Exp;
branches;
next	1.160;

1.160
date	2004.11.08.16.39.31;	author miod;	state Exp;
branches;
next	1.159;

1.159
date	2004.10.01.19.00.52;	author miod;	state Exp;
branches;
next	1.158;

1.158
date	2004.10.01.05.49.01;	author miod;	state Exp;
branches;
next	1.157;

1.157
date	2004.09.30.14.55.54;	author miod;	state Exp;
branches;
next	1.156;

1.156
date	2004.09.30.09.20.48;	author miod;	state Exp;
branches;
next	1.155;

1.155
date	2004.08.25.08.00.09;	author miod;	state Exp;
branches;
next	1.154;

1.154
date	2004.08.02.14.38.42;	author miod;	state Exp;
branches;
next	1.153;

1.153
date	2004.08.02.08.35.00;	author miod;	state Exp;
branches;
next	1.152;

1.152
date	2004.07.30.20.48.40;	author miod;	state Exp;
branches;
next	1.151;

1.151
date	2004.07.30.20.44.09;	author miod;	state Exp;
branches;
next	1.150;

1.150
date	2004.07.30.19.28.22;	author miod;	state Exp;
branches;
next	1.149;

1.149
date	2004.07.30.19.02.08;	author miod;	state Exp;
branches;
next	1.148;

1.148
date	2004.07.29.10.17.21;	author miod;	state Exp;
branches;
next	1.147;

1.147
date	2004.07.28.12.28.48;	author miod;	state Exp;
branches;
next	1.146;

1.146
date	2004.07.24.15.05.07;	author miod;	state Exp;
branches;
next	1.145;

1.145
date	2004.07.23.22.19.09;	author miod;	state Exp;
branches;
next	1.144;

1.144
date	2004.06.23.03.58.30;	author miod;	state Exp;
branches;
next	1.143;

1.143
date	2004.06.23.00.30.36;	author miod;	state Exp;
branches;
next	1.142;

1.142
date	2004.05.06.18.32.08;	author miod;	state Exp;
branches;
next	1.141;

1.141
date	2004.04.24.19.51.49;	author miod;	state Exp;
branches;
next	1.140;

1.140
date	2004.04.16.23.35.53;	author miod;	state Exp;
branches;
next	1.139;

1.139
date	2004.04.15.21.35.07;	author miod;	state Exp;
branches;
next	1.138;

1.138
date	2004.04.14.23.06.57;	author miod;	state Exp;
branches;
next	1.137;

1.137
date	2004.04.14.13.43.48;	author miod;	state Exp;
branches;
next	1.136;

1.136
date	2004.03.10.23.02.54;	author tom;	state Exp;
branches;
next	1.135;

1.135
date	2004.02.19.15.33.53;	author miod;	state Exp;
branches;
next	1.134;

1.134
date	2004.02.11.20.41.08;	author miod;	state Exp;
branches;
next	1.133;

1.133
date	2004.01.14.11.49.49;	author miod;	state Exp;
branches;
next	1.132;

1.132
date	2004.01.13.21.27.05;	author miod;	state Exp;
branches;
next	1.131;

1.131
date	2004.01.13.17.15.08;	author miod;	state Exp;
branches;
next	1.130;

1.130
date	2004.01.12.23.55.12;	author miod;	state Exp;
branches;
next	1.129;

1.129
date	2004.01.12.17.30.26;	author miod;	state Exp;
branches;
next	1.128;

1.128
date	2004.01.12.07.46.17;	author miod;	state Exp;
branches;
next	1.127;

1.127
date	2004.01.05.20.07.03;	author miod;	state Exp;
branches;
next	1.126;

1.126
date	2004.01.04.01.43.16;	author miod;	state Exp;
branches;
next	1.125;

1.125
date	2004.01.02.23.40.57;	author miod;	state Exp;
branches;
next	1.124;

1.124
date	2004.01.02.17.08.57;	author miod;	state Exp;
branches;
next	1.123;

1.123
date	2003.12.22.23.29.33;	author miod;	state Exp;
branches;
next	1.122;

1.122
date	2003.12.19.22.30.18;	author miod;	state Exp;
branches;
next	1.121;

1.121
date	2003.12.11.18.12.19;	author miod;	state Exp;
branches;
next	1.120;

1.120
date	2003.11.09.00.32.03;	author miod;	state Exp;
branches;
next	1.119;

1.119
date	2003.11.06.21.09.35;	author mickey;	state Exp;
branches;
next	1.118;

1.118
date	2003.10.24.17.44.51;	author miod;	state Exp;
branches;
next	1.117;

1.117
date	2003.10.09.16.30.58;	author miod;	state Exp;
branches;
next	1.116;

1.116
date	2003.10.05.20.27.47;	author miod;	state Exp;
branches;
next	1.115;

1.115
date	2003.10.02.10.19.11;	author miod;	state Exp;
branches;
next	1.114;

1.114
date	2003.09.28.22.13.45;	author miod;	state Exp;
branches;
next	1.113;

1.113
date	2003.09.20.13.57.37;	author miod;	state Exp;
branches;
next	1.112;

1.112
date	2003.09.16.20.52.22;	author miod;	state Exp;
branches;
next	1.111;

1.111
date	2003.09.16.20.46.11;	author miod;	state Exp;
branches;
next	1.110;

1.110
date	2003.09.08.20.44.52;	author miod;	state Exp;
branches;
next	1.109;

1.109
date	2003.09.06.15.07.43;	author miod;	state Exp;
branches;
next	1.108;

1.108
date	2003.09.02.20.14.08;	author miod;	state Exp;
branches;
next	1.107;

1.107
date	2003.09.01.18.21.23;	author miod;	state Exp;
branches;
next	1.106;

1.106
date	2003.08.31.16.52.38;	author miod;	state Exp;
branches;
next	1.105;

1.105
date	2003.08.11.20.45.17;	author miod;	state Exp;
branches;
next	1.104;

1.104
date	2003.08.07.17.23.43;	author miod;	state Exp;
branches;
next	1.103;

1.103
date	2003.08.01.19.53.19;	author miod;	state Exp;
branches;
next	1.102;

1.102
date	2003.08.01.07.47.58;	author miod;	state Exp;
branches;
next	1.101;

1.101
date	2003.05.11.19.41.11;	author deraadt;	state Exp;
branches;
next	1.100;

1.100
date	2003.01.13.20.12.18;	author miod;	state Exp;
branches;
next	1.99;

1.99
date	2003.01.04.23.13.51;	author miod;	state Exp;
branches;
next	1.98;

1.98
date	2003.01.01.23.38.18;	author miod;	state Exp;
branches;
next	1.97;

1.97
date	2002.12.17.23.11.32;	author millert;	state Exp;
branches;
next	1.96;

1.96
date	2002.10.12.02.03.45;	author krw;	state Exp;
branches;
next	1.95;

1.95
date	2002.07.20.19.24.56;	author art;	state Exp;
branches;
next	1.94;

1.94
date	2002.06.04.00.09.08;	author deraadt;	state Exp;
branches;
next	1.93;

1.93
date	2002.03.23.13.28.34;	author espie;	state Exp;
branches;
next	1.92;

1.92
date	2002.03.14.03.15.57;	author millert;	state Exp;
branches;
next	1.91;

1.91
date	2002.03.14.01.26.40;	author millert;	state Exp;
branches;
next	1.90;

1.90
date	2002.03.05.22.11.42;	author miod;	state Exp;
branches;
next	1.89;

1.89
date	2002.02.17.22.59.53;	author maja;	state Exp;
branches;
next	1.88;

1.88
date	2002.01.23.17.51.52;	author art;	state Exp;
branches;
next	1.87;

1.87
date	2002.01.23.17.35.56;	author art;	state Exp;
branches;
next	1.86;

1.86
date	2002.01.16.20.50.17;	author miod;	state Exp;
branches;
next	1.85;

1.85
date	2002.01.14.21.34.41;	author miod;	state Exp;
branches;
next	1.84;

1.84
date	2002.01.10.21.45.33;	author miod;	state Exp;
branches;
next	1.83;

1.83
date	2002.01.07.02.34.04;	author miod;	state Exp;
branches;
next	1.82;

1.82
date	2001.12.24.04.12.40;	author miod;	state Exp;
branches;
next	1.81;

1.81
date	2001.12.22.17.57.11;	author smurph;	state Exp;
branches;
next	1.80;

1.80
date	2001.12.22.09.49.39;	author smurph;	state Exp;
branches;
next	1.79;

1.79
date	2001.12.22.07.35.43;	author smurph;	state Exp;
branches;
next	1.78;

1.78
date	2001.12.20.06.43.23;	author smurph;	state Exp;
branches;
next	1.77;

1.77
date	2001.12.20.06.07.28;	author smurph;	state Exp;
branches;
next	1.76;

1.76
date	2001.12.19.07.04.42;	author smurph;	state Exp;
branches
	1.76.2.1;
next	1.75;

1.75
date	2001.12.16.23.49.46;	author miod;	state Exp;
branches;
next	1.74;

1.74
date	2001.12.14.04.30.12;	author smurph;	state Exp;
branches;
next	1.73;

1.73
date	2001.12.14.01.33.50;	author miod;	state Exp;
branches;
next	1.72;

1.72
date	2001.12.13.08.55.52;	author smurph;	state Exp;
branches;
next	1.71;

1.71
date	2001.12.08.18.05.59;	author miod;	state Exp;
branches;
next	1.70;

1.70
date	2001.12.08.02.24.06;	author art;	state Exp;
branches;
next	1.69;

1.69
date	2001.11.30.23.16.51;	author miod;	state Exp;
branches;
next	1.68;

1.68
date	2001.11.28.16.13.29;	author art;	state Exp;
branches;
next	1.67;

1.67
date	2001.11.28.13.57.18;	author art;	state Exp;
branches;
next	1.66;

1.66
date	2001.11.28.13.47.38;	author art;	state Exp;
branches;
next	1.65;

1.65
date	2001.11.27.05.26.36;	author miod;	state Exp;
branches;
next	1.64;

1.64
date	2001.11.07.01.18.00;	author art;	state Exp;
branches;
next	1.63;

1.63
date	2001.11.06.19.53.15;	author miod;	state Exp;
branches;
next	1.62;

1.62
date	2001.10.28.00.59.02;	author miod;	state Exp;
branches;
next	1.61;

1.61
date	2001.09.28.20.50.07;	author miod;	state Exp;
branches;
next	1.60;

1.60
date	2001.09.23.02.54.27;	author miod;	state Exp;
branches;
next	1.59;

1.59
date	2001.09.21.01.18.52;	author miod;	state Exp;
branches;
next	1.58;

1.58
date	2001.09.19.20.50.56;	author mickey;	state Exp;
branches;
next	1.57;

1.57
date	2001.09.12.00.23.33;	author art;	state Exp;
branches;
next	1.56;

1.56
date	2001.08.26.14.31.12;	author miod;	state Exp;
branches;
next	1.55;

1.55
date	2001.08.24.22.54.51;	author miod;	state Exp;
branches;
next	1.54;

1.54
date	2001.08.24.19.26.15;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2001.08.23.14.01.03;	author art;	state Exp;
branches;
next	1.52;

1.52
date	2001.08.23.12.02.04;	author art;	state Exp;
branches;
next	1.51;

1.51
date	2001.08.23.08.47.34;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2001.08.11.23.21.13;	author art;	state Exp;
branches;
next	1.49;

1.49
date	2001.08.11.01.57.25;	author art;	state Exp;
branches;
next	1.48;

1.48
date	2001.08.06.20.48.26;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2001.08.05.20.35.46;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2001.07.25.13.25.32;	author art;	state Exp;
branches;
next	1.45;

1.45
date	2001.07.05.10.12.15;	author art;	state Exp;
branches;
next	1.44;

1.44
date	2001.07.01.23.27.52;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2001.06.27.06.19.50;	author art;	state Exp;
branches;
next	1.42;

1.42
date	2001.06.27.04.29.19;	author art;	state Exp;
branches;
next	1.41;

1.41
date	2001.06.25.00.43.14;	author mickey;	state Exp;
branches;
next	1.40;

1.40
date	2001.06.14.21.30.45;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2001.06.13.21.24.52;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2001.06.12.23.09.45;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2001.06.05.23.07.50;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2001.05.20.05.53.10;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2001.05.17.18.41.49;	author provos;	state Exp;
branches;
next	1.34;

1.34
date	2001.05.05.22.34.02;	author art;	state Exp;
branches;
next	1.33;

1.33
date	2001.05.05.20.56.47;	author art;	state Exp;
branches;
next	1.32;

1.32
date	2001.04.29.19.00.03;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2001.04.17.04.30.47;	author aaron;	state Exp;
branches;
next	1.30;

1.30
date	2001.03.16.00.08.28;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2001.03.12.22.59.02;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2001.03.09.05.44.42;	author smurph;	state Exp;
branches;
next	1.27;

1.27
date	2001.03.07.23.56.06;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2001.02.12.08.16.24;	author smurph;	state Exp;
branches;
next	1.25;

1.25
date	2001.02.01.03.38.21;	author smurph;	state Exp;
branches;
next	1.24;

1.24
date	2001.01.14.20.25.25;	author smurph;	state Exp;
branches;
next	1.23;

1.23
date	2001.01.13.05.18.59;	author smurph;	state Exp;
branches;
next	1.22;

1.22
date	2001.01.12.07.29.26;	author smurph;	state Exp;
branches;
next	1.21;

1.21
date	2000.12.28.21.21.24;	author smurph;	state Exp;
branches;
next	1.20;

1.20
date	2000.03.23.09.59.55;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2000.02.22.19.27.55;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	99.12.08.06.50.16;	author itojun;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	99.09.27.19.13.23;	author smurph;	state Exp;
branches;
next	1.16;

1.16
date	99.09.03.18.01.30;	author art;	state Exp;
branches;
next	1.15;

1.15
date	99.05.29.04.41.46;	author smurph;	state Exp;
branches;
next	1.14;

1.14
date	99.05.24.23.09.05;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	99.05.22.21.22.27;	author weingart;	state Exp;
branches;
next	1.12;

1.12
date	99.04.11.03.26.28;	author smurph;	state Exp;
branches;
next	1.11;

1.11
date	99.02.09.06.36.29;	author smurph;	state Exp;
branches;
next	1.10;

1.10
date	99.01.11.05.11.44;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	99.01.07.23.16.03;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	98.12.15.05.11.02;	author smurph;	state Exp;
branches;
next	1.7;

1.7
date	97.07.23.06.58.22;	author denny;	state Exp;
branches;
next	1.6;

1.6
date	97.03.03.20.21.43;	author rahnds;	state Exp;
branches;
next	1.5;

1.5
date	97.03.03.19.08.10;	author rahnds;	state dead;
branches;
next	1.4;

1.4
date	97.01.16.20.43.40;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	96.07.27.11.40.45;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.01.05.16.18.03;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.12.32.28;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.03.03.19.32.19;	author rahnds;	state Exp;
branches;
next	;

1.18.2.1
date	2000.03.02.07.04.31;	author niklas;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2000.03.24.09.08.18;	author niklas;	state Exp;
branches;
next	1.18.2.3;

1.18.2.3
date	2001.04.18.16.11.37;	author niklas;	state Exp;
branches;
next	1.18.2.4;

1.18.2.4
date	2001.07.04.10.20.18;	author niklas;	state Exp;
branches;
next	1.18.2.5;

1.18.2.5
date	2001.10.31.03.01.19;	author nate;	state Exp;
branches;
next	1.18.2.6;

1.18.2.6
date	2001.11.13.21.04.15;	author niklas;	state Exp;
branches;
next	1.18.2.7;

1.18.2.7
date	2001.12.05.00.39.12;	author niklas;	state Exp;
branches;
next	1.18.2.8;

1.18.2.8
date	2002.03.06.02.04.45;	author niklas;	state Exp;
branches;
next	1.18.2.9;

1.18.2.9
date	2002.03.28.10.36.02;	author niklas;	state Exp;
branches;
next	1.18.2.10;

1.18.2.10
date	2003.03.27.23.32.18;	author niklas;	state Exp;
branches;
next	1.18.2.11;

1.18.2.11
date	2003.05.13.19.41.06;	author ho;	state Exp;
branches;
next	1.18.2.12;

1.18.2.12
date	2004.02.19.10.49.08;	author niklas;	state Exp;
branches;
next	1.18.2.13;

1.18.2.13
date	2004.06.05.23.09.50;	author niklas;	state Exp;
branches;
next	;

1.76.2.1
date	2002.01.31.22.55.19;	author niklas;	state Exp;
branches;
next	1.76.2.2;

1.76.2.2
date	2002.06.11.03.37.11;	author art;	state Exp;
branches;
next	1.76.2.3;

1.76.2.3
date	2002.10.29.00.28.07;	author art;	state Exp;
branches;
next	1.76.2.4;

1.76.2.4
date	2003.05.19.21.45.53;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.261
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/* $OpenBSD: machdep.c,v 1.260 2014/03/13 03:52:55 dlg Exp $	*/
/*
 * Copyright (c) 1998, 1999, 2000, 2001 Steve Murphree, Jr.
 * Copyright (c) 1996 Nivas Madhur
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Nivas Madhur.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
/*
 * Mach Operating System
 * Copyright (c) 1993-1991 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/buf.h>
#include <sys/reboot.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/mount.h>
#include <sys/msgbuf.h>
#include <sys/syscallargs.h>
#include <sys/exec.h>
#include <sys/sysctl.h>
#include <sys/errno.h>
#include <sys/extent.h>
#include <sys/core.h>
#include <sys/kcore.h>
#include <dev/rndvar.h>

#include <uvm/uvm.h>

#include <machine/asm.h>
#include <machine/asm_macro.h>
#include <machine/board.h>
#include <machine/bug.h>
#include <machine/bugio.h>
#include <machine/cmmu.h>
#include <machine/cpu.h>
#include <machine/kcore.h>
#include <machine/reg.h>
#ifdef M88100
#include <machine/m88100.h>
#endif
#ifdef MVME197
#include <machine/m88410.h>
#endif

#include <mvme88k/mvme88k/clockvar.h>

#include <dev/cons.h>

#include <net/if.h>

#include "ksyms.h"
#if DDB
#include <machine/db_machdep.h>
#include <ddb/db_extern.h>
#include <ddb/db_interface.h>
#include <ddb/db_var.h>
#endif /* DDB */

/*
 * Dummy routines and data to be able to handle unexpected situations and
 * at least report them, until enough of the kernel is initialized.
 */
static u_int
dummy_func(void)
{
	return 0;
}
static const struct board dummy_board = {
    .getipl = (u_int (*)(void))dummy_func,
    .setipl = (u_int (*)(u_int))dummy_func,
    .raiseipl = (u_int (*)(u_int))dummy_func
};
#ifdef MULTIPROCESSOR
struct cpu_info dummy_cpu = {
	.ci_flags = CIF_ALIVE | CIF_PRIMARY,
	.ci_cpuid = 0,
	.ci_mp_atomic_begin =
	    (uint32_t (*)(__cpu_simple_lock_t *, uint*))dummy_func,
	.ci_mp_atomic_end =
	    (void (*)(uint32_t, __cpu_simple_lock_t *, uint))dummy_func
};
#endif

void	consinit(void);
void	cpu_hatch_secondary_processors(void *);
void	dumpconf(void);
void	dumpsys(void);
void	identifycpu(void);
void	mvme_bootstrap(void);
void	mvme88k_vector_init(uint32_t *, uint32_t *);
void	myetheraddr(u_char *);
void	savectx(struct pcb *);
void	secondary_main(void);
vaddr_t	secondary_pre_main(void);
void	_doboot(void);

extern int kernelstart;
register_t kernel_vbr;
intrhand_t intr_handlers[NVMEINTR];

const struct board *platform = &dummy_board;

int physmem;	  /* available physical memory, in pages */

struct vm_map *exec_map = NULL;
struct vm_map *phys_map = NULL;

#ifdef MULTIPROCESSOR
__cpu_simple_lock_t cpu_hatch_mutex;
__cpu_simple_lock_t cpu_boot_mutex = __SIMPLELOCK_LOCKED;
#endif

/*
 * 32 or 34 bit physical address bus depending upon the CPU flavor.
 * 32 bit DMA.
 */
struct uvm_constraint_range  dma_constraint = { 0x0, 0xffffffffUL};
struct uvm_constraint_range *uvm_md_constraints[] = { NULL };

/*
 * Info for CTL_HW
 */
char  machine[] = MACHINE;	 /* cpu "architecture" */
char  cpu_model[120];

int bootdev;					/* set in locore.S */
int cputyp;					/* set in locore.S */
int brdtyp;					/* set in locore.S */
int cpuspeed = 25;				/* safe guess */
u_int dumb_delay_const = 25;

vaddr_t first_addr;
vaddr_t last_addr;

extern struct user *proc0paddr;

struct intrhand	clock_ih;
struct intrhand	statclock_ih;

/*
 * Statistics clock interval and variance, in usec.  Variance must be a
 * power of two.  Since this gives us an even number, not an odd number,
 * we discard one case and compensate.  That is, a variance of 4096 would
 * give us offsets in [0..4095].  Instead, we take offsets in [1..4095].
 * This is symmetric about the point 2048, or statvar/2, and thus averages
 * to that value (assuming uniform random numbers).
 */
int statvar = 8192;
int statmin;			/* statclock interval - 1/2*variance */

#if defined (MVME187) || defined (MVME197)
#define ETHERPAGES 16
void *etherbuf = NULL;
int etherlen;
#endif

#if defined(MVME181) || defined(MVME188)
/*
 * Interrupt masks, one per IPL level.
 */
u_int32_t int_mask_val[NIPLS];
#endif

/*
 * This is to fake out the console routines, while booting.
 */
cons_decl(boot);
#define bootcnpollc nullcnpollc

struct consdev bootcons = {
	NULL,
	NULL,
	bootcngetc,
	bootcnputc,
	bootcnpollc,
	NULL,
	makedev(14, 0),
	CN_LOWPRI,
};

/*
 * Early console initialization: called early on from main, before vm init.
 * We want to stick to the BUG routines for now, and we'll switch to the
 * real console in cpu_startup().
 */
void
consinit()
{
	cn_tab = &bootcons;

#if defined(DDB)
	db_machine_init();
	ddb_init();
	if (boothowto & RB_KDB)
		Debugger();
#endif
}

void
identifycpu()
{
	struct mvmeprom_brdid brdid;
	char suffix[4];
	u_int i;

	bzero(&brdid, sizeof(brdid));
	bugbrdid(&brdid);

	cpuspeed = platform->cpuspeed(&brdid);

	i = 0;
	if (brdid.suffix[0] >= ' ' && brdid.suffix[0] < 0x7f) {
		if (brdid.suffix[0] != '-')
			suffix[i++] = '-';
		suffix[i++] = brdid.suffix[0];
	}
	if (brdid.suffix[1] >= ' ' && brdid.suffix[1] < 0x7f)
		suffix[i++] = brdid.suffix[1];
	suffix[i++] = '\0';

	snprintf(cpu_model, sizeof cpu_model,
	    "Motorola MVME%x%s, %dMHz", brdtyp, suffix, cpuspeed);
}

void
cpu_initclocks()
{
	platform->init_clocks();
}

void
setstatclockrate(int newhz)
{
	/* function stub */
}

void
cpu_startup()
{
	int i;
	vaddr_t minaddr, maxaddr;

	/*
	 * Good {morning,afternoon,evening,night}.
	 */
	printf(version);
	identifycpu();
	printf("real mem = %u (%uMB)\n", ptoa(physmem),
	    ptoa(physmem)/1024/1024);

	/*
	 * Allocate a submap for exec arguments.  This map effectively
	 * limits the number of processes exec'ing at any time.
	 */
	minaddr = vm_map_min(kernel_map);
	exec_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    16 * NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);

	/*
	 * Allocate map for physio.
	 */
	phys_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    VM_PHYS_SIZE, 0, FALSE, NULL);

	printf("avail mem = %lu (%luMB)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free)/1024/1024);

	/*
	 * Set up buffers, so they can be used to read disk labels.
	 */
	bufinit();

	/*
	 * Set up interrupt handlers.
	 */
	for (i = 0; i < NVMEINTR; i++)
		SLIST_INIT(&intr_handlers[i]);

	/*
	 * Configure the system.
	 */
	if (boothowto & RB_CONFIG) {
#ifdef BOOT_CONFIG
		user_config();
#else
		printf("kernel does not support -c; continuing..\n");
#endif
	}
}

__dead void
_doboot()
{
	cold = 0;
	cmmu_shutdown();
	set_vbr(0);		/* restore BUG VBR */
	bugreturn();
	/*NOTREACHED*/
	for (;;);		/* appease gcc */
}

__dead void
boot(howto)
	int howto;
{
	struct device *mainbus;

	/* take a snapshot before clobbering any registers */
	if (curproc && curproc->p_addr)
		savectx(curpcb);

	/* If system is cold, just halt. */
	if (cold) {
		/* (Unless the user explicitly asked for reboot.) */
		if ((howto & RB_USERREQ) == 0)
			howto |= RB_HALT;
		goto haltsys;
	}

	boothowto = howto;
	if ((howto & RB_NOSYNC) == 0) {
		vfs_shutdown();
		/*
		 * If we've been adjusting the clock, the todr
		 * will be out of synch; adjust it now unless
		 * the system was sitting in ddb.
		 */
		if ((howto & RB_TIMEBAD) == 0)
			resettodr();
		else
			printf("WARNING: not updating battery clock\n");
	}
	if_downall();

	uvm_shutdown();
	splhigh();		/* Disable interrupts. */

	/* If rebooting and a dump is requested, do it. */
	if (howto & RB_DUMP)
		dumpsys();

haltsys:
	doshutdownhooks();
	mainbus = device_mainbus();
	if (mainbus != NULL)
		config_suspend(mainbus, DVACT_POWERDOWN);

	if (howto & RB_HALT) {
		printf("System halted. Press any key to reboot...\n\n");
		cnpollc(1);
		cngetc();
		cnpollc(0);
	}

	if (platform->reboot != NULL)
		platform->reboot(howto);

	doboot();	/* will invoke _doboot on a 1:1 mapped stack */
	/*NOTREACHED*/
}

unsigned dumpmag = 0x8fca0101;	 /* magic number for savecore */
int   dumpsize = 0;	/* also for savecore */
long  dumplo = 0;
cpu_kcore_hdr_t cpu_kcore_hdr;

/*
 * This is called by configure to set dumplo and dumpsize.
 * Dumps always skip the first PAGE_SIZE of disk space
 * in case there might be a disk label stored there.
 * If there is extra space, put dump at the end to
 * reduce the chance that swapping trashes it.
 */
void
dumpconf(void)
{
	int nblks;	/* size of dump area */

	if (dumpdev == NODEV ||
	    (nblks = (bdevsw[major(dumpdev)].d_psize)(dumpdev)) == 0)
		return;
	if (nblks <= ctod(1))
		return;

	dumpsize = physmem;

	/* mvme88k only uses a single segment. */
	cpu_kcore_hdr.ram_segs[0].start = 0;
	cpu_kcore_hdr.ram_segs[0].size = ptoa(physmem);
	cpu_kcore_hdr.cputype = cputyp;

	/*
	 * Don't dump on the first block
	 * in case the dump device includes a disk label.
	 */
	if (dumplo < ctod(1))
		dumplo = ctod(1);

	/* Put dump at end of partition, and make it fit. */
	if (dumpsize + 1 > dtoc(nblks - dumplo))
		dumpsize = dtoc(nblks - dumplo) - 1;
	if (dumplo < nblks - ctod(dumpsize) - 1)
		dumplo = nblks - ctod(dumpsize) - 1;
}

/*
 * Doadump comes here after turning off memory management and
 * getting on the dump stack, either when called above, or by
 * the auto-restart code.
 */
void
dumpsys()
{
	int maj;
	int psize;
	daddr_t blkno;	/* current block to write */
				/* dump routine */
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
	int pg;			/* page being dumped */
	paddr_t maddr;		/* PA being dumped */
	int error;		/* error code from (*dump)() */
	kcore_seg_t *kseg_p;
	cpu_kcore_hdr_t *chdr_p;
	char dump_hdr[dbtob(1)];	/* XXX assume hdr fits in 1 block */

	extern int msgbufmapped;

	msgbufmapped = 0;

	/* Make sure dump device is valid. */
	if (dumpdev == NODEV)
		return;
	if (dumpsize == 0) {
		dumpconf();
		if (dumpsize == 0)
			return;
	}
	maj = major(dumpdev);
	if (dumplo < 0) {
		printf("\ndump to dev %u,%u not possible\n", maj,
		    minor(dumpdev));
		return;
	}
	dump = bdevsw[maj].d_dump;
	blkno = dumplo;

	printf("\ndumping to dev %u,%u offset %ld\n", maj,
	    minor(dumpdev), dumplo);

#ifdef UVM_SWAP_ENCRYPT
	uvm_swap_finicrypt_all();
#endif

	/* Setup the dump header */
	kseg_p = (kcore_seg_t *)dump_hdr;
	chdr_p = (cpu_kcore_hdr_t *)&dump_hdr[ALIGN(sizeof(*kseg_p))];
	bzero(dump_hdr, sizeof(dump_hdr));

	CORE_SETMAGIC(*kseg_p, KCORE_MAGIC, MID_MACHINE, CORE_CPU);
	kseg_p->c_size = dbtob(1) - ALIGN(sizeof(*kseg_p));
	*chdr_p = cpu_kcore_hdr;

	printf("dump ");
	psize = (*bdevsw[maj].d_psize)(dumpdev);
	if (psize == -1) {
		printf("area unavailable\n");
		return;
	}

	/* Dump the header. */
	error = (*dump)(dumpdev, blkno++, (caddr_t)dump_hdr, dbtob(1));
	if (error != 0)
		goto abort;

	maddr = (paddr_t)0;
	for (pg = 0; pg < dumpsize; pg++) {
#define NPGMB	(1024 * 1024 / PAGE_SIZE)
		/* print out how many MBs we have dumped */
		if (pg != 0 && (pg % NPGMB) == 0)
			printf("%d ", pg / NPGMB);
#undef NPGMB
		error = (*dump)(dumpdev, blkno, (caddr_t)maddr, PAGE_SIZE);
		if (error == 0) {
			maddr += PAGE_SIZE;
			blkno += btodb(PAGE_SIZE);
		} else
			break;
	}
abort:
	switch (error) {
	case 0:
		printf("succeeded\n");
		break;

	case ENXIO:
		printf("device bad\n");
		break;

	case EFAULT:
		printf("device not ready\n");
		break;

	case EINVAL:
		printf("area improper\n");
		break;

	case EIO:
		printf("i/o error\n");
		break;

	case EINTR:
		printf("aborted from console\n");
		break;

	default:
		printf("error %d\n", error);
		break;
	}
}

#ifdef MULTIPROCESSOR

/*
 * Secondary CPU early initialization routine.
 * Determine CPU number and set it, then allocate the startup stack.
 *
 * Running on a minimal stack here, with interrupts disabled; do nothing fancy.
 */
vaddr_t
secondary_pre_main()
{
	struct cpu_info *ci;
	vaddr_t init_stack;

	/*
	 * Invoke the CMMU initialization routine as early as possible,
	 * so that we do not risk any memory writes to be lost during
	 * cache setup.
	 */
	cmmu_initialize_cpu(cmmu_cpu_number());

	/*
	 * Now initialize your cpu_info structure.
	 */
	set_cpu_number(cmmu_cpu_number());
	ci = curcpu();
	ci->ci_curproc = &proc0;
	platform->smp_setup(ci);

	splhigh();

	/*
	 * Enable MMU on this processor.
	 */
	pmap_bootstrap_cpu(ci->ci_cpuid);

	/*
	 * Allocate UPAGES contiguous pages for the startup stack.
	 */
	init_stack = uvm_km_zalloc(kernel_map, USPACE);
	if (init_stack == (vaddr_t)NULL) {
		printf("cpu%d: unable to allocate startup stack\n",
		    ci->ci_cpuid);
		__cpu_simple_unlock(&cpu_hatch_mutex);
		for (;;) ;
	}

	return (init_stack);
}

/*
 * Further secondary CPU initialization.
 *
 * We are now running on our startup stack, with proper page tables.
 * There is nothing to do but display some details about the CPU and its CMMUs.
 */
void
secondary_main()
{
	struct cpu_info *ci = curcpu();
	int s;

	cpu_configuration_print(0);
	ncpus++;

	sched_init_cpu(ci);
	nanouptime(&ci->ci_schedstate.spc_runtime);
	ci->ci_curproc = NULL;
	ci->ci_randseed = (arc4random() & 0x7fffffff) + 1;

	__cpu_simple_unlock(&cpu_hatch_mutex);

	/* wait for cpu_boot_secondary_processors() */
	__cpu_simple_lock(&cpu_boot_mutex);
	__cpu_simple_unlock(&cpu_boot_mutex);

	spl0();
	SCHED_LOCK(s);
	set_psr(get_psr() & ~PSR_IND);

	SET(ci->ci_flags, CIF_ALIVE);

	cpu_switchto(NULL, sched_chooseproc());
}

#endif	/* MULTIPROCESSOR */

/*
 * Search for the first available interrupt vector in the range start, end.
 * This should really only be used by VME devices.
 */
int
intr_findvec(int start, int end, int skip)
{
	int vec;

#ifdef DEBUG
	if (start < 0 || end >= NVMEINTR || start > end)
		panic("intr_findvec(%d,%d): bad parameters", start, end);
#endif

	for (vec = start; vec <= end; vec++) {
		if (vec == skip)
			continue;
		if (SLIST_EMPTY(&intr_handlers[vec]))
			return vec;
	}
#ifdef DIAGNOSTIC
	printf("intr_findvec(%d,%d,%d): no vector available\n",
	    start, end, skip);
#endif
	return -1;
}

/*
 * Try to insert ih in the list of handlers for vector vec.
 */
int
intr_establish(int vec, struct intrhand *ih, const char *name)
{
	struct intrhand *intr;
	intrhand_t *list;

	list = &intr_handlers[vec];
	if (!SLIST_EMPTY(list)) {
		intr = SLIST_FIRST(list);
		if (intr->ih_ipl != ih->ih_ipl) {
#ifdef DIAGNOSTIC
			panic("intr_establish: there are other handlers with "
			    "vec (0x%x) at ipl %x, but you want it at %x",
			    vec, intr->ih_ipl, ih->ih_ipl);
#endif /* DIAGNOSTIC */
			return EINVAL;
		}
	}

	evcount_attach(&ih->ih_count, name, &ih->ih_ipl);
	SLIST_INSERT_HEAD(list, ih, ih_link);

	return 0;
}

void
nmihand(void *frame)
{
#ifdef DDB
	printf("Abort switch pressed\n");
	if (db_console) {
		/*
		 * We can't use Debugger() here, as we are coming from an
		 * exception handler, and can't assume anything about the
		 * state we are in. Invoke the post-trap ddb entry directly.
		 */
		extern void m88k_db_trap(int, struct trapframe *);
		m88k_db_trap(T_KDB_ENTRY, (struct trapframe *)frame);
	}
#endif
}

int
sys_sysarch(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
#if 0
	struct sys_sysarch_args	/* {
	   syscallarg(int) op;
	   syscallarg(char *) parm;
	} */ *uap = v;
#endif

	return (ENOSYS);
}

/*
 * machine dependent system variables.
 */

int
cpu_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
{
	dev_t consdev;

	/* all sysctl names are this level are terminal */
	if (namelen != 1)
		return (ENOTDIR); /* overloaded */

	switch (name[0]) {
	case CPU_CONSDEV:
		if (cn_tab != NULL)
			consdev = cn_tab->cn_dev;
		else
			consdev = NODEV;
		return (sysctl_rdstruct(oldp, oldlenp, newp, &consdev,
		    sizeof consdev));
	case CPU_CPUTYPE:
		return (sysctl_rdint(oldp, oldlenp, newp, cputyp));
	default:
		return (EOPNOTSUPP);
	}
	/*NOTREACHED*/
}

void
myetheraddr(cp)
	u_char *cp;
{
	struct mvmeprom_brdid brdid;

	bugbrdid(&brdid);
	bcopy(&brdid.etheraddr, cp, 6);
}

void
mvme88k_vector_init(uint32_t *bugvbr, uint32_t *vectors)
{
	extern vaddr_t vector_init(uint32_t *, uint32_t *, int); /* gross */
	unsigned long bugvec[32];
	uint i;

	/*
	 * Set up bootstrap vectors, overwriting the existing BUG vbr
	 * page. This allows us to keep the BUG system call vectors.
	 */

	for (i = 0; i < 16 * 2; i++)
		bugvec[i] = bugvbr[MVMEPROM_VECTOR * 2 + i];
	vector_init(bugvbr, vectors, 1);
	for (i = 0; i < 16 * 2; i++)
		bugvbr[MVMEPROM_VECTOR * 2 + i] = bugvec[i];

	/*
	 * Set up final vectors.
	 */

	kernel_vbr = trunc_page((vaddr_t)&kernelstart);
	vector_init((uint32_t *)kernel_vbr, vectors, 0);
}

/*
 * Called from locore.S during boot,
 * this is the first C code that's run.
 */
void
mvme_bootstrap()
{
	extern struct consdev *cn_tab;
	struct mvmeprom_brdid brdid;
	extern vaddr_t avail_start;
	extern vaddr_t avail_end;
#ifndef MULTIPROCESSOR
	cpuid_t master_cpu;
#endif

	buginit();
	bugbrdid(&brdid);
	brdtyp = brdid.model;

	/*
	 * Use the BUG as console for now. After autoconf, we'll switch to
	 * real hardware.
	 */
	cn_tab = &bootcons;

	/*
	 * Set up interrupt and fp exception handlers based on the machine.
	 */
	switch (brdtyp) {
#ifdef MVME181
	case BRD_180:
	case BRD_181:
		platform = &board_mvme181;
		break;
#endif
#ifdef MVME187
	case BRD_187:
	case BRD_8120:
		platform = &board_mvme187;
		break;
#endif
#ifdef MVME188
	case BRD_188:
		platform = &board_mvme188;
		break;
#endif
#ifdef MVME197
	case BRD_197:
		if (mc88410_present())
			platform = &board_mvme197spdp;
		else
			platform = &board_mvme197le;
		break;
#endif
	default:
		panic("Sorry, this kernel does not support MVME%x", brdtyp);
	}

	platform->bootstrap();

	uvmexp.pagesize = PAGE_SIZE;
	uvm_setpagesize();
	first_addr = round_page(first_addr);
	last_addr = platform->memsize();
	physmem = atop(last_addr);

	cmmu = platform->cmmu;
	setup_board_config();
	master_cpu = cmmu_init();
	set_cpu_number(master_cpu);
#ifdef MULTIPROCESSOR
	platform->smp_setup(curcpu());
#endif
	SET(curcpu()->ci_flags, CIF_ALIVE | CIF_PRIMARY);

#ifdef M88100
	if (CPU_IS88100) {
		m88100_apply_patches();
	}
#endif

	/*
	 * Now that set_cpu_number() set us with a valid cpu_info pointer,
	 * we need to initialize p_addr and curpcb before autoconf, for the
	 * fault handler to behave properly [except for badaddr() faults,
	 * which can be taken care of without a valid curcpu()].
	 */
	proc0.p_addr = proc0paddr;
	curproc = &proc0;
	curpcb = &proc0paddr->u_pcb;

	avail_start = first_addr;	/* first page of memory after kernel image */
	avail_end = last_addr;		/* last page of memory */

#ifdef DEBUG
	printf("MVME%x boot: memory from 0x%x to 0x%x\n",
	    brdtyp, avail_start, avail_end);
#endif
	/*
	 * Tell the VM system about available physical memory.
	 *
	 * The mvme88k boards only have one contiguous area, although BUG
	 * could be set up to configure a non-contiguous scheme; also, we
	 * might want to register ECC memory separately later on...
	 */
	uvm_page_physload(atop(avail_start), atop(avail_end),
	    atop(avail_start), atop(avail_end), 0);

	/*
	 * Initialize message buffer.
	 */
	initmsgbuf((caddr_t)pmap_steal_memory(MSGBUFSIZE, NULL, NULL),
	    MSGBUFSIZE);

	pmap_bootstrap(0, 0x10000);	/* BUG needs 64KB */

#if defined (MVME187) || defined (MVME197)
	/*
	 * Get ethernet buffer - need ETHERPAGES pages physically contiguous.
	 * XXX need to fix ie(4) to support non-1:1 mapped buffers
	 */
	if (brdtyp == BRD_187 || brdtyp == BRD_8120 || brdtyp == BRD_197) {
		etherlen = ETHERPAGES * PAGE_SIZE;
		etherbuf = (void *)uvm_pageboot_alloc(etherlen);
		pmap_cache_ctrl((paddr_t)etherbuf, (paddr_t)etherbuf + etherlen,
		    CACHE_INH);
	}
#endif /* defined (MVME187) || defined (MVME197) */

	/* Initialize the "u-area" pages. */
	bzero((caddr_t)curpcb, USPACE);
#ifdef DEBUG
	printf("leaving mvme_bootstrap()\n");
#endif
}

#ifdef MULTIPROCESSOR
void
cpu_hatch_secondary_processors(void *unused)
{
	struct cpu_info *ci = curcpu();
	cpuid_t cpu;
	int rc;
	extern void secondary_start(void);

	switch (brdtyp) {
#if defined(MVME188) || defined(MVME197)
#ifdef MVME188
	case BRD_188:
#endif
#ifdef MVME197
	case BRD_197:
#endif
		for (cpu = 0; cpu < ncpusfound; cpu++) {
			if (cpu != ci->ci_cpuid) {
				__cpu_simple_lock(&cpu_hatch_mutex);
				rc = spin_cpu(cpu, (vaddr_t)secondary_start);
				switch (rc) {
				case 0:
					__cpu_simple_lock(&cpu_hatch_mutex);
					break;
				default:
					printf("cpu%d: spin_cpu error %d\n",
					    cpu, rc);
					/* FALLTHROUGH */
				case FORKMPU_NO_MPU:
					break;
				}
				__cpu_simple_unlock(&cpu_hatch_mutex);
			}
		}
		break;
#endif
	default:
		break;
	}
}

void
cpu_boot_secondary_processors()
{
	__cpu_simple_unlock(&cpu_boot_mutex);
}
#endif

/*
 * Boot console routines:
 * Enables printing of boot messages before consinit().
 */
void
bootcnprobe(cp)
	struct consdev *cp;
{
	cp->cn_dev = makedev(14, 0);
	cp->cn_pri = CN_LOWPRI;
}

void
bootcninit(cp)
	struct consdev *cp;
{
	/* Nothing to do */
}

int
bootcngetc(dev)
	dev_t dev;
{
	return (buginchr());
}

void
bootcnputc(dev, c)
	dev_t dev;
	int c;
{
	bugoutchr(c);
}

int
getipl(void)
{
	return (int)platform->getipl();
}

int
setipl(int level)
{
	return (int)platform->setipl((u_int)level);
}

int
raiseipl(int level)
{
	return (int)platform->raiseipl((u_int)level);
}

#ifdef MULTIPROCESSOR

void
m88k_send_ipi(int ipi, cpuid_t cpu)
{
	struct cpu_info *ci;

	ci = &m88k_cpus[cpu];
	if (ISSET(ci->ci_flags, CIF_ALIVE))
		platform->send_ipi(ipi, cpu);
}

void
m88k_broadcast_ipi(int ipi)
{
	struct cpu_info *us = curcpu();
	struct cpu_info *ci;
	CPU_INFO_ITERATOR cii;

	CPU_INFO_FOREACH(cii, ci) {
		if (ci == us)
			continue;

		if (ISSET(ci->ci_flags, CIF_ALIVE))
			platform->send_ipi(ipi, ci->ci_cpuid);
	}
}

#endif

void
delay(int us)
{
	platform->delay(us);
}
@


1.260
log
@get rid of the assumption that the head of the alldevs list is the
"mainbus" device. this breaks when mpath is enabled because it
attaches before mainbus and therefore takes the head position.

have autoconf provide device_mainbus() which looks up mainbus_cd,
and use that instead.

discussed with deraadt who just wants mpath stuff to move forward
despite there being many ways to shine this particular turd.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.259 2014/01/19 12:45:35 deraadt Exp $	*/
@


1.259
log
@Initialize ci_randseed better using arc4random() + a trick.  Remove the
libkern srandom() API since it is not suitable for this use.
ok kettenis miod
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.258 2013/11/02 23:10:29 miod Exp $	*/
d347 2
d385 3
a387 2
	if (!TAILQ_EMPTY(&alldevs))
		config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.258
log
@Create the initial page tables in the area between the end of the firmware
data area and the kernel image, whenever possible.

On 88100/88200 systems, use BATC mappings to map the kernel text (and the
kernel data for non-MULTIPROCESSOR kernels). 88110 to follow soon.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.257 2013/10/17 08:02:17 deraadt Exp $	*/
d66 1
d627 1
a627 1
	ci->ci_randseed = random();
@


1.257
log
@Remove support for a.out and ecoff.  We only do elf now.
ok miod
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.256 2013/09/28 12:40:31 miod Exp $	*/
d814 1
a814 1
	vaddr_t avail_start;
d919 2
d929 2
a932 7

	pmap_bootstrap(0, 0x10000);	/* BUG needs 64KB */

#if defined (MVME187) || defined (MVME197)
	if (etherlen != 0)
		pmap_cache_ctrl((paddr_t)etherbuf, (paddr_t)etherbuf + etherlen,		    CACHE_INH);
#endif
@


1.256
log
@In boot(), do not iterate over alldevs if it's empty (i.e. halting from ddb
with ddb entered early with boot -d or from UKC).
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.255 2013/06/11 16:42:10 deraadt Exp $	*/
a714 9
}

int
cpu_exec_aout_makecmds(p, epp)
	struct proc *p;
	struct exec_package *epp;
{

	return (ENOEXEC);
@


1.255
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.254 2013/06/03 16:55:22 guenther Exp $	*/
d382 2
a383 1
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.254
log
@Convert some internal APIs to use timespecs instead of timevals

ok matthew@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.253 2013/05/17 22:51:59 miod Exp $	*/
d452 1
a452 1
	daddr64_t blkno;	/* current block to write */
d454 1
a454 1
	int (*dump)(dev_t, daddr64_t, caddr_t, size_t);
@


1.253
log
@Preliminary support for MVME180 and MVME181 boards. On-board serial ports
and VME controller are supported; tod chip isn't supported yet (coming soon).
MVME236 memory boards are not supported and won't likely be (unless I get my
hands on one).

MVME181-1 boots multiuser (slowly) with MVME328 SCSI and MVME376 Ethernet
despite only having 8MB of memory onboard.

MVME180 untested; might need tweaking to get MVME SCSI and Ethernet boards
supported.

Many thanks to Matti Nummi for lending me an MVME181 board.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.252 2013/05/17 22:46:28 miod Exp $	*/
d623 1
a623 1
	microuptime(&ci->ci_schedstate.spc_runtime);
@


1.252
log
@Replace the bunch of md_* function pointers with a `struct board' containing
function pointers for all the board-specific code.

Add a bunch of `struct board' methods to cover most, if not all, of the
`per-board' logic. This allows most of the md drivers to be cleaned up and
no longer need to embed board-specific knowledge.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.251 2013/05/17 22:38:25 miod Exp $	*/
d842 6
@


1.251
log
@Split inittodr/resettodr code from actual tod routines, to allow for
multiple tod routines in the near future.

Use the mi clock_ymdhms_to_secs and clock_secs_to_ymdhms routines.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.250 2013/05/15 20:18:04 miod Exp $	*/
d67 2
d71 1
d81 2
a82 2
#ifdef MVME188
#include <mvme88k/dev/sysconvar.h>
d84 1
a89 1
#include <uvm/uvm.h>
d99 25
a125 1
void	dumb_delay(int);
a127 1
int	getcpuspeed(struct mvmeprom_brdid *);
a136 7
extern void	m187_bootstrap(void);
extern vaddr_t	m187_memsize(void);
extern void	m188_bootstrap(void);
extern vaddr_t	m188_memsize(void);
extern void	m197_bootstrap(void);
extern vaddr_t	m197_memsize(void);

d141 1
a141 20
static u_int dummy_getipl(void) { return 0; }
static u_int dummy_setipl(u_int whatever) { return 0; }

/* board dependent pointers */
void (*md_interrupt_func_ptr)(struct trapframe *);
#ifdef M88110
int (*md_nmi_func_ptr)(struct trapframe *);
void (*md_nmi_wrapup_func_ptr)(struct trapframe *);
#endif
void (*md_init_clocks)(void);
u_int (*md_getipl)(void) = dummy_getipl;
u_int (*md_setipl)(u_int) = dummy_setipl;
u_int (*md_raiseipl)(u_int) = dummy_setipl;
#ifdef MULTIPROCESSOR
void (*md_send_ipi)(int, cpuid_t);
#endif
void (*md_delay)(int) = dumb_delay;
#ifdef MULTIPROCESSOR
void (*md_smp_setup)(struct cpu_info *);
#endif
d155 1
a155 2
 * 32 bit DMA. "I am not aware of any system where the upper 2 bits
 * have ever been used" - miod@@
d197 7
a238 62
int
getcpuspeed(struct mvmeprom_brdid *brdid)
{
	int speed = 0;
#ifdef MVME188
	u_int i, c;
#endif

	switch (brdtyp) {
#ifdef MVME187
	case BRD_187:
	case BRD_8120:
		/* we already computed the speed in m187_bootstrap() */
		return cpuspeed;
#endif
#ifdef MVME188
	case BRD_188:
		/*
		 * If BUG version prior to 5.x, there is no CNFG block and
		 * speed can be found in the environment.
		 * XXX We don't process ENV data yet - assume 20MHz in this
		 * case.
		 */
		if ((u_int)brdid->rev < 0x50) {
			speed = 20;
		} else {
			for (i = 0; i < 4; i++) {
				c = (u_int)brdid->speed[i];
				if (c == ' ')
					c = '0';
				else if (c > '9' || c < '0') {
					speed = 0;
					break;
				}
				speed = speed * 10 + (c - '0');
			}
			speed = speed / 100;

			if (speed == 20 || speed == 25)
				return speed;
			speed = 25;
		}
		break;
#endif
#ifdef MVME197
	case BRD_197:
		/* we already computed the speed in m197_bootstrap() */
		return cpuspeed;
#endif
	}

	/*
	 * If we end up here, the board information block is damaged and
	 * we can't trust it.
	 * Suppose we are running at the most common speed for our board,
	 * and hope for the best (this really only affects osiop).
	 */
	printf("WARNING: Board Configuration Data invalid, "
	    "replace NVRAM and restore values\n");
	return speed;
}

d249 1
a249 1
	cpuspeed = getcpuspeed(&brdid);
a264 4
/*
 * Set up real-time clocks.
 * These function pointers are set in dev/clock.c.
 */
d268 1
a268 1
	(*md_init_clocks)();
a276 1

d391 2
a392 1
	doboot();
d394 1
a394 1
	for (;;);
d584 1
a584 1
	(*md_smp_setup)(ci);
d689 1
a689 1
			return (EINVAL);
d696 1
a696 9
#ifdef MVME188
	/*
	 * Enable VME interrupt source for this level.
	 */
	if (brdtyp == BRD_188)
		syscon_intsrc_enable(INTSRC_VME + (ih->ih_ipl - 1), ih->ih_ipl);
#endif

	return (0);
d845 1
a845 1
		m187_bootstrap();
d850 1
a850 1
		m188_bootstrap();
d855 4
a858 1
		m197_bootstrap();
d865 2
d870 1
a870 19

	switch (brdtyp) {
#ifdef MVME187
	case BRD_187:
	case BRD_8120:
		last_addr = m187_memsize();
		break;
#endif
#ifdef MVME188
	case BRD_188:
		last_addr = m188_memsize();
		break;
#endif
#ifdef MVME197
	case BRD_197:
		last_addr = m197_memsize();
		break;
#endif
	}
d873 1
d878 1
a878 1
	(*md_smp_setup)(curcpu());
d1032 1
a1032 1
	return (int)(*md_getipl)();
d1038 1
a1038 1
	return (int)(*md_setipl)((u_int)level);
d1044 1
a1044 1
	return (int)(*md_raiseipl)((u_int)level);
d1056 1
a1056 1
		(*md_send_ipi)(ipi, cpu);
d1071 1
a1071 1
			(*md_send_ipi)(ipi, ci->ci_cpuid);
d1080 1
a1080 1
	(*md_delay)(us);
@


1.250
log
@Initialize a teeny few more globals to reasonable values to allow for printf()
to work as soon as cn_tab is initialized. Allows us to correctly printf or
panic early on unrecognized systems. This used to be the case but got lost a
long time ago.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.249 2013/05/14 20:30:47 miod Exp $	*/
d171 1
a1160 6
}

/* delay() routine used until a proper routine is set up */
void
dumb_delay(int us)
{
@


1.249
log
@Older BUG version do not implement the `out cr/lf' BUG system call, and, worse,
do not return from it, for extra fun. The good thing is that the existing
kernel console code logic issueing \n as \r\n works nicely with the regular
BUG output routines, so there was no reason to use this particular BUG routine
in the first place.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.248 2012/12/26 22:32:13 miod Exp $	*/
d122 3
d132 3
a134 3
u_int (*md_getipl)(void);
u_int (*md_setipl)(u_int);
u_int (*md_raiseipl)(u_int);
@


1.248
log
@Nuke commons.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.247 2012/10/21 09:51:59 miod Exp $	*/
d1102 1
a1102 4
	if (c == '\n')
		bugpcrlf();
	else
		bugoutchr(c);
@


1.247
log
@Needs <sys/device.h> now
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.246 2012/10/08 21:47:49 deraadt Exp $	*/
a163 1
int boothowto;					/* set in locore.S */
@


1.246
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.245 2011/10/09 17:01:34 miod Exp $	*/
d55 1
@


1.245
log
@Rework secondary processor initialization. cmmu initialization is now
performed much earlier in the processor startup.
No visible change, paves the way for the much important diff three commits
from here.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.244 2011/06/26 22:40:00 deraadt Exp $	*/
a437 1
	/* Run any shutdown hooks. */
d439 1
@


1.244
log
@if_downall() cannot be done MI in sys_reboot() because vfs_shutdown()
might need network (ie. nfs).  Move the call to the MD boot() routines.
This cause for boot hangs diagnosed by kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.243 2011/06/05 19:41:07 deraadt Exp $	*/
d627 11
a637 1
	set_cpu_number(cmmu_cpu_number()); /* Determine cpu number by CMMU */
d645 1
a645 1
	 * Setup CMMUs and translation tables (shared with the master cpu).
a687 2

	set_vbr(kernel_vbr);
@


1.243
log
@Move the bufcachepercent setting code to MI locations -- set it to 42%
for now; that is unlikely to hit some of the remaining starvation bugs.
Repair the bufpages calculation too; i386 was doing it ahead of time
(incorrectly) and then re-calculating it.
ok thib
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.242 2011/05/30 22:25:21 oga Exp $	*/
d84 1
d428 1
@


1.242
log
@Remove the freelist member from vm_physseg

The new world order of pmemrange makes this data completely redundant
(being dealt with by the pmemrange constraints instead). Remove all code
that messes with the freelist.

While touching every caller of uvm_page_physload() anyway, add the flags
argument to all callers (all but one is 0 and that one already used
PHYSLOAD_DEVICE) and remove the macro magic to allow callers to continue
without it.

Should shrink the code a bit, as well.

matthew@@ pointed out some mistakes i'd made.
``freelist death, I like. Ok.' ariane@@
`I agree with the general direction, go ahead and i'll fix any fallout
shortly'' miod@@ (68k 88k and vax i could not check would build)
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.241 2011/01/05 22:20:22 miod Exp $	*/
a146 14

/*
 * Declare these as initialized data so we can patch them.
 */
#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif

#ifdef	BUFPAGES
int bufpages = BUFPAGES;
#else
int bufpages = 0;
#endif
int bufcachepercent = BUFCACHEPERCENT;
@


1.241
log
@Pass pmap_bootstrap() the memory range used by the PROM/BUG/firmware/whatever,
instead of assuming it is ``everything below the kernel image''.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.240 2010/12/31 21:38:08 miod Exp $	*/
d993 1
a993 1
	    atop(avail_start), atop(avail_end), VM_FREELIST_DEFAULT);
@


1.240
log
@Massive overhauling of the m88k pmap, though I can't pretend it's a new pmap
since a large part of the structures and logic remains.

Since m88k has separate supervisor/user spaces, we can map physical memory 1:1
in supervisor space, and have the kernel virtual address space start from the
end of physical memory.

This allows us to switch to __HAVE_PMAP_DIRECT. And to get rid of the double
mapped sdt, since now their virtual and physical addresses will always match.

The upper bound of the kernel virtual memory space is now platform dependent,
until the code which relies upon some hardware devices being mapped 1:1 in
supervisor mode is updated to no longer require this (this is mainly a PITA on
luna88k, where onboard devices start at 0x40000000, leaving only 1GB of KVA at
the moment - still much better than the previous 512MB).

Tested on mvme88k only (187, 188, 197LE, 197DP). Other platforms ought to
work, aviion will be checked shortly and fixed if necessary. No known
OpenBSD/luna88k system in working condition at the moment.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.239 2010/12/23 20:05:08 miod Exp $	*/
d1012 1
a1012 1
	pmap_bootstrap();
@


1.239
log
@The exception vector page on m88k systems has always been the same page as
the one used by the firmware, which (at least on mvme88k) is at address zero.

This is unfortunate, since this means that NULL pointer dereferences in the
kernel are not caught, and writes cause havoc.

This behaviour was necessary to be able to use the PROM system call interface
during early bootstrap, without having to disassemble the VBR page and
update branches - which use pc-relative displacement - if we were to use
a different VBR address.

On mvme88k, change this and actually set up two VBR pages: one, over the PROM
page (except for the system call vectors), and another one in the kernel
image (which will be mapped read-only). We'll run with the PROM page until
the end of autoconf, and then switch to the kernel one, and unmap all the
PROM below it.

As a bonus, the final kernel page can use optimized data access fault
handlers, which do not have to check for faults caused by badaddr(), since
badaddr() is only used during device probe on buses which do not support
hotplug.

There are a few infrastructure collateral damage on aviion and luna88k, but
these ports do not change their behaviour yet.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.238 2010/09/20 06:33:47 matthew Exp $	*/
a110 1
extern void	m187_startup(void);
a112 1
extern void	m188_startup(void);
a114 1
extern void	m197_startup(void);
a184 3
vaddr_t avail_start, avail_end;
vaddr_t virtual_avail, virtual_end;

d201 6
a353 10
	 * Initialize error message buffer (at end of core).
	 * avail_end was pre-decremented in mvme_bootstrap() to compensate.
	 */
	for (i = 0; i < atop(MSGBUFSIZE); i++)
		pmap_kenter_pa((paddr_t)msgbufp + i * PAGE_SIZE,
		    avail_end + i * PAGE_SIZE, VM_PROT_READ | VM_PROT_WRITE);
	pmap_update(pmap_kernel());
	initmsgbuf((caddr_t)msgbufp, round_page(MSGBUFSIZE));

	/*
a361 22
	 * Grab machine dependent memory spaces
	 */
	switch (brdtyp) {
#ifdef MVME187
	case BRD_187:
	case BRD_8120:
		m187_startup();
		break;
#endif
#ifdef MVME188
	case BRD_188:
		m188_startup();
		break;
#endif
#ifdef MVME197
	case BRD_197:
		m197_startup();
		break;
#endif
	}

	/*
d586 1
a586 4
		pmap_enter(pmap_kernel(), (vaddr_t)vmmap, maddr,
		    VM_PROT_READ, VM_PROT_READ|PMAP_WIRED);

		error = (*dump)(dumpdev, blkno, vmmap, PAGE_SIZE);
d890 2
d978 2
a979 7
	avail_start = first_addr;
	avail_end = last_addr;

	/*
	 * Steal MSGBUFSIZE at the top of physical memory for msgbuf
	 */
	avail_end -= round_page(MSGBUFSIZE);
a984 2
	pmap_bootstrap((vaddr_t)trunc_page((vaddr_t)&kernelstart));

d994 24
@


1.238
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.237 2010/06/27 12:41:23 miod Exp $	*/
d102 1
a102 1
void	mvme88k_vector_init(u_int32_t *, u_int32_t *);
d119 2
d436 1
d438 1
a718 1
	SET(ci->ci_flags, CIF_ALIVE);
d726 2
d731 3
d891 1
a891 1
mvme88k_vector_init(u_int32_t *vbr, u_int32_t *vectors)
d893 8
a900 2
	extern void vector_init(u_int32_t *, u_int32_t *);	/* gross */
	int i;
a901 1
	/* Save BUG vector */
d903 4
a906 1
		bugvec[i] = vbr[MVMEPROM_VECTOR * 2 + i];
d908 3
a910 1
	vector_init(vbr, vectors);
d912 2
a913 3
	/* Save new BUG vector */
	for (i = 0; i < 16 * 2; i++)
		sysbugvec[i] = vbr[MVMEPROM_VECTOR * 2 + i];
a922 1
	extern int kernelstart;
@


1.237
log
@Bunch of include adjustements to restore compilability.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.236 2010/06/27 03:03:48 thib Exp $	*/
d780 1
a780 2
	evcount_attach(&ih->ih_count, name, (void *)&ih->ih_ipl,
	    &evcount_intr);
@


1.236
log
@uvm constraints. Add two mandatory MD symbols, uvm_md_constraints
which contains the constraints for DMA/memory allocation for each
architecture, and dma_constraints which contains the range of addresses
that are dma accessable by the system.

This is based on ariane@@'s physcontig diff, with lots of bugfixes and
additions the following additions by my self:

Introduce a new function pool_set_constraints() which sets the address
range for which we allocate pages for the pool from, this is now used
for the mbuf/mbuf cluster pools to keep them dma accessible.

The !direct archs no longer stuff pages into the kernel object in
uvm_km_getpage_pla but rather do a pmap_extract() in uvm_km_putpages.

Tested heavily by my self on i386, amd64 and sparc64. Some tests on
alpha and SGI.

"commit it" beck, art, oga, deraadt
"i like the diff" deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.234 2009/08/11 18:46:32 miod Exp $	*/
d84 1
a84 2
#include <uvm/uvm_extern.h>
#include <uvm/uvm_swap.h>
d167 1
@


1.235
log
@Do not bother initializing bufpages in the md code if the computation is
exactly the same the mi could will use if bufinit() is invoked with
bufpages == 0.
@
text
@d165 7
@


1.234
log
@With the SysV memory allocation changes, allocsys() doesn't do anything
anymore. Get rid of it completely.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.233 2009/08/09 10:40:17 blambert Exp $	*/
a382 7

	/*
	 * Determine how many buffers to allocate.
	 * We allocate bufcachepercent% of memory for buffer space.
	 */
	if (bufpages == 0)
		bufpages = physmem * bufcachepercent / 100;
@


1.233
log
@Rototill system V message queues.

No longer allocate a static amount of memory for messages in MD
boot path; message queues, message metadata, and message data now
all use dynamic memory, which means that runtime sysctls should now
be trivial to implement.

Since I'm going to be around all week to fix any breakage, this should
probably just go in now.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.232 2009/08/02 16:28:39 beck Exp $	*/
a94 1
caddr_t	allocsys(caddr_t);
d341 1
a341 2
	caddr_t v;
	int sz, i;
a362 11
	 * Find out how much space we need, allocate it,
	 * and then give everything true virtual addresses.
	 */
	sz = (int)allocsys((caddr_t)0);

	if ((v = (caddr_t)uvm_km_zalloc(kernel_map, round_page(sz))) == 0)
		panic("startup: no room for tables");
	if (allocsys(v) - v != sz)
		panic("startup: table size inconsistency");

	/*
a428 20
}

/*
 * Allocate space for system data structures.  We are given
 * a starting virtual address and we return a final virtual
 * address; along the way we set each data structure pointer.
 *
 * We call allocsys() with 0 to find out how much space we want,
 * allocate that much and fill it with zeroes, and then call
 * allocsys() again with the correct base virtual address.
 */
caddr_t
allocsys(v)
	caddr_t v;
{

#define	valloc(name, type, num) \
	    v = (caddr_t)(((name) = (type *)v) + (num))

	return v;
@


1.232
log
@
Dynamic buffer cache support - a re-commit of what was backed out
after c2k9

allows buffer cache to be extended and grow/shrink dynamically

tested by many, ok oga@@, "why not just commit it" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.231 2009/06/15 17:01:26 beck Exp $	*/
a58 3
#ifdef SYSVMSG
#include <sys/msg.h>
#endif
a459 7

#ifdef SYSVMSG
	valloc(msgpool, char, msginfo.msgmax);
	valloc(msgmaps, struct msgmap, msginfo.msgseg);
	valloc(msghdrs, struct msg, msginfo.msgtql);
	valloc(msqids, struct msqid_ds, msginfo.msgmni);
#endif
@


1.231
log
@Back out all the buffer cache changes I committed during c2k9. This reverts three
commits:

1) The sysctl allowing bufcachepercent to be changed at boot time.
2) The change moving the buffer cache hash chains to a red-black tree
3) The dynamic buffer cache (Which depended on the earlier too).

ok on the backout from marco and todd
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.230 2009/06/03 21:30:20 beck Exp $	*/
a405 6

	/* Restrict to at most 25% filled kvm */
	if (bufpages >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / PAGE_SIZE / 4) 
		bufpages = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    PAGE_SIZE / 4;
@


1.230
log
@add kern.bufcachepercent sysctl to allow adjusting the buffer cache
size on a running system.
ok art@@, oga@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.229 2009/04/19 17:56:13 miod Exp $	*/
d406 6
@


1.229
log
@Rename max_cpus to ncpusfound and compute it regardless of option
MULTIPROCESSOR.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.228 2009/03/15 20:39:53 miod Exp $	*/
a405 6

	/* Restrict to at most 25% filled kvm */
	if (bufpages >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / PAGE_SIZE / 4) 
		bufpages = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    PAGE_SIZE / 4;
@


1.228
log
@Generic softinterrupt support for m88k based platforms, adapted from arm
with different locking mechanism. 88110 soft ipi are replaced with an
ipi callback which is checked upon return from exception (it can not be kept
as a softintr, as the generic softinterrupt code doesn't have per-cpu
pending softintr queues).
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.227 2009/03/05 21:55:15 miod Exp $	*/
d1093 1
a1093 1
		for (cpu = 0; cpu < max_cpus; cpu++) {
@


1.227
log
@Change SMP secondary processor startup to have them ``hatch'' earlier,
so that they can invoke sched_init_cpu() before the scheduler starts,
which allows the horrible kluge in cpu_configure() to die.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.226 2009/02/27 05:19:36 miod Exp $	*/
a137 1
void (*md_soft_ipi)(void);
a1205 6
}

void
softipi()
{
	(*md_soft_ipi)();
@


1.226
log
@Rework nmi handling to handle ``complex'' NMI faster, and return as fast as
possible from the exception, without doing the AST and softintr dance.

This should avoid too much stack usage under load.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.225 2009/02/21 18:37:49 miod Exp $	*/
d100 1
d151 2
a152 1
__cpu_simple_lock_t cpu_boot_mutex;
d739 1
a739 1
		__cpu_simple_unlock(&cpu_boot_mutex);
d761 1
d767 4
a772 1
	set_psr(get_psr() & ~PSR_IND);
a773 1

d775 1
d1079 1
a1079 1
cpu_boot_secondary_processors()
d1096 1
a1096 1
				__cpu_simple_lock(&cpu_boot_mutex);
d1100 1
a1100 1
					__cpu_simple_lock(&cpu_boot_mutex);
d1109 1
a1109 1
				__cpu_simple_unlock(&cpu_boot_mutex);
d1117 6
@


1.225
log
@Move part of the mp lock logic into per-cpu callbacks; on MVME197DP we need
to disable NMI sources in addition to interrupt sources, and we can not
use a quick sequence with shadowing frozen as done for atomic ops.

This lets GENERIC.MP boot multiuser on MVME197DP boards, and is so far stable
enough to be able to recompile a kernel from scratch (with make -j2).
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.224 2009/02/21 18:35:22 miod Exp $	*/
d128 2
a129 1
void (*md_nmi_func_ptr)(struct trapframe *);
@


1.224
log
@Get rid of 88110 nmi stacks. This was a good idea, but I outsmarted myself
since it was intended to service NMI occuring in user mode, and we could
end up invoking preempt() and have another cpu start using this stack,
with interesting results.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.223 2009/02/20 20:36:14 miod Exp $	*/
d139 3
d720 1
d1018 3
a1021 1

@


1.223
log
@Let M188 kernel compile.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.222 2009/02/16 23:03:33 miod Exp $	*/
a735 14
	/*
	 * On 88110 processors, allocate UPAGES contiguous pages for
	 * the NMI handling stack.
	 */
	if (CPU_IS88110) {
		ci->ci_nmi_stack = uvm_km_zalloc(kernel_map, USPACE);
		if (ci->ci_nmi_stack == (vaddr_t)NULL) {
			printf("cpu%d: unable to allocate NMI stack\n",
			    ci->ci_cpuid);
			__cpu_simple_unlock(&cpu_boot_mutex);
			for (;;) ;
		}
	}

a1015 6
#ifdef M88110
	if (CPU_IS88110) {
		extern caddr_t nmi_stack;
		curcpu()->ci_nmi_stack = (vaddr_t)&nmi_stack;
	}
#endif
@


1.222
log
@More 88110 SMP work. Contains, horribly entangled:
- dma_cachectl() split into a ``local cpu only'' and ``all cpus'', and an ipi
  to broadcast ``local dma_cachectl'' is added.
- cpu_info fields are rearranged, to have the 88100-specific information
  and the 88110-specific information overlap, and has many more 88110
  ugly things.
- more ipi handling in the 197-specific area. Since it is not possible to
  have the second processor receive any hardware interrupt (selection
  is done on a level basis via ISEL, and we definitely do not want the
  main cpu to lose interrupts), the best we can do is to inflict ourselves
  a soft interrupt for late ipi processing. It gets used for softclock and
  hardclock on the secondary processor, but since the soft interrupt
  dispatcher doesn't have an exception frame, we have to remember parts
  of it to build a fake clockframe from the soft ipi handler (ugly but
  works).

This now lets GENERIC.MP run a few userland binaries before bugs trigger.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.221 2009/02/16 22:55:03 miod Exp $	*/
d236 1
d238 1
@


1.221
log
@Since NMI are now handled separately, remove the ``interrupt type'' argument
from interrupt() and related function pointers.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.220 2009/02/13 23:33:51 miod Exp $	*/
d136 1
d1206 6
@


1.220
log
@Use a different dispatcher for the NMI traps on 88110, these are too
different from regular hardware interrupts to be worth handling the
same way.

Disable IPI reception while we are handling pending IPIs. And do not
reenable them by mistake if we need to send an IPI in return.

This lets GENERIC.MP boot single user on a MVME197DP. There are still
many bugs to fix.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.219 2009/02/13 23:31:29 miod Exp $	*/
d126 1
a126 1
void (*md_interrupt_func_ptr)(u_int, struct trapframe *);
@


1.219
log
@Release the secondary processor initialization interlock a bit later,
after the currently running processor has advertized itself as ready.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.218 2009/02/13 23:26:51 miod Exp $	*/
d127 3
@


1.218
log
@Make delay() a per-board function pointer.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.217 2009/02/08 21:59:21 miod Exp $	*/
a761 2
	__cpu_simple_unlock(&cpu_boot_mutex);

d766 2
@


1.217
log
@Oops, initialize the nmi stack correctly for the boot processor.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.216 2009/02/08 21:40:58 miod Exp $	*/
d83 1
d100 1
d134 1
d179 14
d1205 12
@


1.216
log
@On 88110 processors, use a separate stack to handle NMI; these can occur
while we are switching pcbs and all sort of bad things could happen.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.215 2009/02/01 00:51:32 miod Exp $	*/
d1009 2
a1010 2
		extern vaddr_t nmi_stack;
		curcpu()->ci_nmi_stack = nmi_stack;
@


1.215
log
@Get the cpu speed from the pcctwo configuration on MVME187.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.214 2008/10/30 22:07:18 miod Exp $	*/
d713 14
d1006 7
@


1.214
log
@Initialize random seed for secondary processors.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.213 2008/06/27 17:22:14 miod Exp $	*/
a216 12
	for (i = 0; i < 4; i++) {
		c = (u_int)brdid->speed[i];
		if (c == ' ')
			c = '0';
		else if (c > '9' || c < '0') {
			speed = 0;
			break;
		}
		speed = speed * 10 + (c - '0');
	}
	speed = speed / 100;

d221 2
a222 4
		if (speed == 25 || speed == 33)
			return speed;
		speed = 25;
		break;
d235 12
@


1.213
log
@Clear swap encryption keys before dumping a kernel image.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.212 2008/06/08 20:57:19 miod Exp $	*/
a161 4
#if defined(DDB) || NKSYMS > 0
extern char *esym;
#endif

d737 1
@


1.212
log
@Make sure to cnpollc(1)/cnpollc(0) around cngetc() or getsn() calls.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.211 2008/04/09 16:58:10 deraadt Exp $	*/
d87 1
d608 4
@


1.211
log
@Add new stub uvm_shutdown() and call it from the right place in MD boot()
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.211 2008/04/09 16:50:29 deraadt Exp $	*/
d509 1
d511 1
@


1.210
log
@Cleanup cn_pri. Change constants to more meaningful names, rather than
the hp300 related ones currently in use. CN_NORMAL becomes CN_LOWPRI,
CN_INTERNAL becomes CN_MIDPRI and CN_REMOTE becomes CN_HIGHPRI.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.205 2007/12/15 19:37:41 miod Exp $	*/
d496 2
a497 2
	/* Disable interrupts. */
	splhigh();
@


1.209
log
@Add a machdep.cputype sysctl, which returns the processor type (0 for 88100,
1 for 88110), for userland to have an easy way to figure out.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.208 2008/01/13 20:18:56 miod Exp $	*/
d193 1
a193 1
	CN_NORMAL,
d1090 1
a1090 1
	cp->cn_pri = CN_NORMAL;
@


1.208
log
@Remove unused cpumod variable.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.207 2007/12/31 09:23:54 martin Exp $	*/
d879 2
@


1.207
log
@replace ctob/btoc by ptoa/atop as done for other architectures
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.206 2007/12/27 23:17:55 miod Exp $	*/
a168 1
int cpumod;					/* set in mvme_bootstrap() */
@


1.206
log
@Make the mvme188 interrupt handling closer to the aviion interrupt handling:
non-VME syscon interrupt sources will now use their own intrhand array,
and interrupt sources will be enabled in the arbiter as interrupt handlers
are registered. This allows VME devices to use the whole 256 interrupts range.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.205 2007/12/15 19:37:41 miod Exp $	*/
d331 1
a331 1
	for (i = 0; i < btoc(MSGBUFSIZE); i++)
d342 2
a343 2
	printf("real mem = %u (%uMB)\n", ctob(physmem),
	    ctob(physmem)/1024/1024);
d546 1
a546 1
	cpu_kcore_hdr.ram_segs[0].size = ctob(physmem);
d983 1
a983 1
	physmem = btoc(last_addr);
@


1.205
log
@Unconditionnaly disable the instruction cache on 40MHz MVME197LE boards,
so that they run stably. Definitely overkill and causing a severe performance
hit (they now run about as fast as a 25MHz board with I$ enabled would), but
sometimes you can't fight silicon bugs.

Other boards (i.e. 50MHz ones) are not affected.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.204 2007/12/15 19:35:54 miod Exp $	*/
d80 3
d774 1
a774 1
 * Try to insert ihand in the list of handlers for vector vec.
d777 1
a777 1
intr_establish(int vec, struct intrhand *ihand, const char *name)
a781 8
	if (vec < 0 || vec >= NVMEINTR) {
#ifdef DIAGNOSTIC
		panic("intr_establish: vec (0x%x) not between 0x00 and 0xff",
		      vec);
#endif /* DIAGNOSTIC */
		return (EINVAL);
	}

d785 1
a785 1
		if (intr->ih_ipl != ihand->ih_ipl) {
d789 1
a789 1
			    vec, intr->ih_ipl, ihand->ih_ipl);
d795 1
a795 1
	evcount_attach(&ihand->ih_count, name, (void *)&ihand->ih_ipl,
d797 10
a806 1
	SLIST_INSERT_HEAD(list, ihand, ih_link);
@


1.204
log
@All MVME BUG manuals concur on SR3 being the only register needing to be
preserved across BUG calls, but on the other hand the last 16 traps need to
be restored to BUG values, not only trap #496.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.203 2007/11/17 05:36:23 miod Exp $	*/
d258 2
a259 4
		if (speed == 40 || speed == 50)
			return speed;
		speed = 50;
		break;
@


1.203
log
@Replace many ``unsigned'' variables with ``unsigned int'', ``u_int'' or other
appropriate types. No functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.202 2007/11/17 05:32:05 miod Exp $	*/
d898 1
d901 2
a902 2
	bugvec[0] = vbr[MVMEPROM_VECTOR * 2 + 0];
	bugvec[1] = vbr[MVMEPROM_VECTOR * 2 + 1];
d907 2
a908 2
	sysbugvec[0] = vbr[MVMEPROM_VECTOR * 2 + 0];
	sysbugvec[1] = vbr[MVMEPROM_VECTOR * 2 + 1];
@


1.202
log
@Rework {get,set,raise}ipl() to minimize psr modification, especially on
boards such as mvme1[89]7 where spl changes can be atomic.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.201 2007/11/15 21:23:16 miod Exp $	*/
d1015 1
a1015 1
	pmap_bootstrap((vaddr_t)trunc_page((unsigned)&kernelstart));
@


1.201
log
@Stop referring the initial kernel stack as the ``interrupt stack''. It's
been years since it has last been used for that purpose, so name it the
initialization/startup stack.

While there, do not store the initialization stack in cpu_info, and have
secondary_pre_main() return its value so that the bootstrap code does not
need to fetch it from cpu_info.

This might be reconsidered when the startup stacks will be freed after they
are not used anymore, but there are more things to do first.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.200 2007/11/14 23:15:07 miod Exp $	*/
a97 1
u_int	getipl(void);
a106 2
extern void setlevel(unsigned int);

d1114 1
a1114 1
u_int
d1117 1
a1117 6
	u_int curspl, psr;

	disable_interrupt(psr);
	curspl = (*md_getipl)();
	set_psr(psr);
	return curspl;
d1120 2
a1121 2
unsigned
setipl(unsigned level)
d1123 1
a1123 14
	u_int curspl, psr;

	disable_interrupt(psr);
	curspl = (*md_setipl)(level);

	/*
	 * The flush pipeline is required to make sure the above change gets
	 * through the data pipe and to the hardware; otherwise, the next
	 * bunch of instructions could execute at the wrong spl protection.
	 */
	flush_pipeline();

	set_psr(psr);
	return curspl;
d1126 2
a1127 2
unsigned
raiseipl(unsigned level)
d1129 1
a1129 14
	u_int curspl, psr;

	disable_interrupt(psr);
	curspl = (*md_raiseipl)(level);

	/*
	 * The flush pipeline is required to make sure the above change gets
	 * through the data pipe and to the hardware; otherwise, the next
	 * bunch of instructions could execute at the wrong spl protection.
	 */
	flush_pipeline();

	set_psr(psr);
	return curspl;
@


1.200
log
@Cache curcpu() value into a local variable when it is used more than once in
a function, so that it does not get reloaded from cr17 every time.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.199 2007/11/14 23:12:46 miod Exp $	*/
d105 1
a105 1
void	secondary_pre_main(void);
d683 1
a683 1
 * Determine CPU number and set it, then allocate the idle pcb (and stack).
d687 1
a687 1
void
d691 1
d707 2
a708 2
	ci->ci_init_stack = uvm_km_zalloc(kernel_map, USPACE);
	if (ci->ci_init_stack == (vaddr_t)NULL) {
d714 2
d721 1
a721 1
 * We are now running on our idle stack, with proper page tables.
@


1.199
log
@Merge the ci_alive and ci_primary boolean values of struct cpu_info into
a single ci_flags bitfield.

Also, set_cpu_number() will no longer set CIF_PRIMARY on the primary processor,
it's up to the initialization code to do this.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.198 2007/11/06 21:42:56 miod Exp $	*/
d1038 1
d1052 1
a1052 1
			if (cpu != curcpu()->ci_cpuid) {
d1178 1
d1183 1
a1183 1
		if (ci == curcpu())
@


1.198
log
@Remove the now unused idle_u, and call the secondary processors startup
stack a startup stack.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.197 2007/10/28 19:48:47 miod Exp $	*/
d734 1
a734 1
	ci->ci_alive = 1;
d985 1
a985 1
	curcpu()->ci_alive = 1;
d1170 1
a1170 1
	if (ci->ci_alive)
d1184 1
a1184 1
		if (ci->ci_alive)
@


1.197
log
@This is a horrible kluge: invoke sched_init_cpu for seconday processors
before they are started (and not skipping gaps for machine setups with
holes in cpu slots). Since we start secondary cpus very late in the boot
process, and sched_init_cpu() has to be invoked before proc0 execve's init,
I don't think there is a better way to do this.

This lets MVME188 systems with more than one processor boot multiuser.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.196 2007/10/28 19:45:52 miod Exp $	*/
d704 1
a704 1
	 * Allocate UPAGES contiguous pages for the idle PCB and stack.
d706 4
a709 3
	ci->ci_idle_pcb = (struct pcb *)uvm_km_zalloc(kernel_map, USPACE);
	if (ci->ci_idle_pcb == NULL) {
		printf("cpu%d: unable to allocate idle stack\n", ci->ci_cpuid);
@


1.196
log
@Start secondary processors synchronously. This only wins us a nicer dmesg
output, and nothing else.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.195 2007/10/28 19:42:12 miod Exp $	*/
a726 1
	sched_init_cpu(ci);
@


1.195
log
@Do not flag a processor as ``alive'' until it really is ready to accept IPIs.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.194 2007/10/13 12:55:21 miod Exp $	*/
d138 1
a138 1
__cpu_simple_lock_t cpu_mutex = __SIMPLELOCK_UNLOCKED;
d709 2
d729 2
a730 1
	__cpu_simple_unlock(&cpu_mutex);
d1052 1
d1054 5
a1058 1
				if (rc != 0 && rc != FORKMPU_NO_MPU)
d1061 5
@


1.194
log
@Enable interrupts in secondary processors before invoking cpu_switchto(),
rather the expecting it to do this for us.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.193 2007/10/10 15:53:52 art Exp $	*/
d731 1
d982 1
@


1.193
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.192 2007/06/06 17:15:12 deraadt Exp $	*/
d731 3
@


1.192
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.191 2007/05/29 20:36:48 deraadt Exp $	*/
d722 1
d725 1
d732 2
a733 5
	/*
	 * Upon return, the secondary cpu bootstrap code in locore will
	 * enter the idle loop, waiting for some food to process on this
	 * processor.
	 */
@


1.191
log
@start of dumpconf() unification, which one day we can pray will be MI
(and part of setroot); ok miod
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.190 2007/05/27 17:31:57 miod Exp $	*/
d575 1
a575 1
	daddr_t blkno;		/* current block to write */
d577 1
a577 1
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
@


1.190
log
@Make sure the minaddr hint for uvm_km_suballoc() calls is always initialized.
ok pedro@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.189 2007/05/26 20:26:51 pedro Exp $	*/
d534 1
a534 1
dumpconf()
a536 1
	int maj;
d538 2
a539 1
	if (dumpdev == NODEV)
a540 6
	maj = major(dumpdev);
	if (maj < 0 || maj >= nblkdev)
		panic("dumpconf: bad dumpdev=0x%x", dumpdev);
	if (bdevsw[maj].d_psize == NULL)
		return;
	nblks = (*bdevsw[maj].d_psize)(dumpdev);
@


1.189
log
@Dynamic buffer cache. Initial diff from mickey@@, okay art@@ beck@@ toby@@
deraadt@@ dlg@@.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.188 2007/05/23 20:33:46 pvalchev Exp $	*/
d397 1
@


1.188
log
@Print real/available memory in MB as well as bytes in dmesg, and unify
architectures to print it the same way.
ok henning, miod; i386 part from tom
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.187 2007/05/14 17:00:40 miod Exp $	*/
a143 6
#ifdef	NBUF
int nbuf = NBUF;
#else
int nbuf = 0;
#endif

a326 2
	vsize_t size;
	int base, residual;
d381 2
a382 2
	 * Now allocate buffers proper.  They are different than the above
	 * in that they usually occupy more virtual memory than physical.
d384 2
a385 13
	size = MAXBSIZE * nbuf;
	if (uvm_map(kernel_map, (vaddr_t *) &buffers, round_page(size),
	    NULL, UVM_UNKNOWN_OFFSET, 0, UVM_MAPFLAG(UVM_PROT_NONE,
	      UVM_PROT_NONE, UVM_INH_NONE, UVM_ADV_NORMAL, 0)))
		panic("cpu_startup: cannot allocate VM for buffers");
	minaddr = (vaddr_t)buffers;

	if ((bufpages / nbuf) >= btoc(MAXBSIZE)) {
		/* don't want to alloc more physical mem than needed */
		bufpages = btoc(MAXBSIZE) * nbuf;
	}
	base = bufpages / nbuf;
	residual = bufpages % nbuf;
d387 5
a391 26
	for (i = 0; i < nbuf; i++) {
		vsize_t curbufsize;
		vaddr_t curbuf;
		struct vm_page *pg;

		/*
		 * Each buffer has MAXBSIZE bytes of VM space allocated.  Of
		 * that MAXBSIZE space, we allocate and map (base+1) pages
		 * for the first "residual" buffers, and then we allocate
		 * "base" pages for the rest.
		 */
		curbuf = (vaddr_t)buffers + (i * MAXBSIZE);
		curbufsize = PAGE_SIZE * ((i < residual) ? (base + 1) : base);

		while (curbufsize) {
			pg = uvm_pagealloc(NULL, 0, NULL, 0);
			if (pg == NULL)
				panic("cpu_startup: not enough memory for "
				      "buffer cache");
			pmap_kenter_pa(curbuf, VM_PAGE_TO_PHYS(pg),
			    VM_PROT_READ | VM_PROT_WRITE);
			curbuf += PAGE_SIZE;
			curbufsize -= PAGE_SIZE;
		}
	}
	pmap_update(pmap_kernel());
a407 2
	printf("using %d buffers containing %d bytes of memory\n", nbuf,
	    bufpages * PAGE_SIZE);
a454 28

	/*
	 * Determine how many buffers to allocate.  We use 10% of the
	 * first 2MB of memory, and 5% of the rest, with a minimum of 16
	 * buffers.  We allocate 1/2 as many swap buffer headers as file
	 * i/o buffers.
	 */
	if (bufpages == 0) {
		bufpages = (btoc(2 * 1024 * 1024) + physmem) *
		    bufcachepercent / 100;
	}
	if (nbuf == 0) {
		nbuf = bufpages;
		if (nbuf < 16)
			nbuf = 16;
	}

	/* Restrict to at most 70% filled kvm */
	if (nbuf >
	    (VM_MAX_KERNEL_ADDRESS - VM_MIN_KERNEL_ADDRESS) / MAXBSIZE * 7 / 10)
		nbuf = (VM_MAX_KERNEL_ADDRESS - VM_MIN_KERNEL_ADDRESS) /
		    MAXBSIZE * 7 / 10;

	/* More buffer pages than fits into the buffers is senseless.  */
	if (bufpages > nbuf * MAXBSIZE / PAGE_SIZE)
		bufpages = nbuf * MAXBSIZE / PAGE_SIZE;

	valloc(buf, struct buf, nbuf);
@


1.187
log
@Work in progress IPI mechanism, currently only implemented on MVME188, to
send clock ticks to secondary processors.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.186 2007/05/12 20:03:25 miod Exp $	*/
d352 2
a353 1
	printf("real mem  = %d\n", ctob(physmem));
d446 2
a447 1
	printf("avail mem = %ld (%d pages)\n", ptoa(uvmexp.free), uvmexp.free);
@


1.186
log
@Increment ncpus when hatching a secondary processor.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.185 2006/11/18 22:58:28 miod Exp $	*/
d128 3
d1217 29
@


1.185
log
@On 88100 systems which do not need the xxx.usr instruction workaround,
override the DAE helper routines with workaroundless code while the kernel
text is still writable.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.184 2006/07/07 19:36:56 miod Exp $	*/
d794 1
@


1.184
log
@Get rid of the fixed iomap for device mappings, and allocated va ranges
off kernel_map whenever necessary.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.183 2006/05/08 14:36:10 miod Exp $	*/
d77 3
d1048 6
@


1.183
log
@Replace gazillions of badvaddr() or badwordaddr() calls with badaddr() calls.
With a few prototype declarations shuffling, this finally allows
<machine/locore.h> to die.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.182 2006/05/08 14:03:35 miod Exp $	*/
a130 12
/*
 * iomap stuff is for managing chunks of virtual address space that
 * can be allocated to IO devices.
 * VMEbus drivers use this at this now. Only on-board IO devices' addresses
 * are mapped so that pa == va. XXX smurph.
 */

vaddr_t iomapbase;

struct extent *iomap_extent;
struct vm_map *iomap_map;

a437 11

	/*
	 * Allocate map for external I/O.
	 */
	iomap_map = uvm_km_suballoc(kernel_map, &iomapbase, &maxaddr,
	    IOMAP_SIZE, 0, FALSE, NULL);

	iomap_extent = extent_create("iomap", iomapbase,
	    iomapbase + IOMAP_SIZE, M_DEVBUF, NULL, 0, EX_NOWAIT);
	if (iomap_extent == NULL)
		panic("unable to allocate extent for iomap");
@


1.182
log
@Clean the internal m88k trap type codes; while there, simplify and
factorize the build of the VBR page betweem luna88k and mvme88k.

Tested by aoyama@@ and I.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.181 2006/05/02 21:43:09 miod Exp $	*/
a75 1
#include <machine/locore.h>
d95 1
d99 1
d107 9
a115 9
extern void m187_bootstrap(void);
extern vaddr_t m187_memsize(void);
extern void m187_startup(void);
extern void m188_bootstrap(void);
extern vaddr_t m188_memsize(void);
extern void m188_startup(void);
extern void m197_bootstrap(void);
extern vaddr_t m197_memsize(void);
extern void m197_startup(void);
d977 16
d1179 1
a1179 1
unsigned
a1225 16
}

void
mvme88k_vector_init(u_int32_t *vbr, u_int32_t *vectors)
{
	extern void vector_init(u_int32_t *, u_int32_t *);	/* gross */

	/* Save BUG vector */
	bugvec[0] = vbr[MVMEPROM_VECTOR * 2 + 0];
	bugvec[1] = vbr[MVMEPROM_VECTOR * 2 + 1];

	vector_init(vbr, vectors);

	/* Save new BUG vector */
	sysbugvec[0] = vbr[MVMEPROM_VECTOR * 2 + 0];
	sysbugvec[1] = vbr[MVMEPROM_VECTOR * 2 + 1];
@


1.181
log
@Wave goodbye to bugtty on mvme88k as well.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.180 2006/04/26 20:49:58 miod Exp $	*/
a77 1
#include <machine/trap.h>
a90 4
typedef struct {
	unsigned word_one, word_two;
} m88k_exception_vector_area;

d98 1
a101 1
void	vector_init(m88k_exception_vector_area *, unsigned *);
a1161 75
#define SIGSYS_MAX	501
#define SIGTRAP_MAX	510

#define EMPTY_BR	0xc0000000	/* empty "br" instruction */
#define NO_OP 		0xf4005800	/* "or r0, r0, r0" */

#define BRANCH(FROM, TO) \
	(EMPTY_BR | ((vaddr_t)(TO) - (vaddr_t)(FROM)) >> 2)

#define SET_VECTOR(NUM, VALUE) \
	do { \
		vector[NUM].word_one = NO_OP; \
		vector[NUM].word_two = BRANCH(&vector[NUM].word_two, VALUE); \
	} while (0)

/*
 * vector_init(vector, vector_init_list)
 *
 * This routine sets up the m88k vector table for the running processor.
 * It is called with a very little stack, and interrupts disabled,
 * so don't call any other functions!
 */
void
vector_init(m88k_exception_vector_area *vector, unsigned *vector_init_list)
{
	unsigned num;
	unsigned vec;

	for (num = 0; (vec = vector_init_list[num]) != END_OF_VECTOR_LIST;
	    num++) {
		if (vec != UNKNOWN_HANDLER)
			SET_VECTOR(num, vec);
	}

	/* Save BUG vector */
	bugvec[0] = vector[MVMEPROM_VECTOR].word_one;
	bugvec[1] = vector[MVMEPROM_VECTOR].word_two;

#ifdef M88110
	if (CPU_IS88110) {
		for (; num <= SIGSYS_MAX; num++)
			SET_VECTOR(num, m88110_sigsys);

		for (; num <= SIGTRAP_MAX; num++)
			SET_VECTOR(num, m88110_sigtrap);

		SET_VECTOR(450, m88110_syscall_handler);
		SET_VECTOR(451, m88110_cache_flush_handler);
		SET_VECTOR(504, m88110_stepbpt);
		SET_VECTOR(511, m88110_userbpt);
	}
#endif
#ifdef M88100
	if (CPU_IS88100) {
		for (; num <= SIGSYS_MAX; num++)
			SET_VECTOR(num, sigsys);

		for (; num <= SIGTRAP_MAX; num++)
			SET_VECTOR(num, sigtrap);

		SET_VECTOR(450, syscall_handler);
		SET_VECTOR(451, cache_flush_handler);
		SET_VECTOR(504, stepbpt);
		SET_VECTOR(511, userbpt);
	}
#endif

	/* GCC will by default produce explicit trap 503 for division by zero */
	SET_VECTOR(503, vector_init_list[T_ZERODIV]);

	/* Save new BUG vector */
	sysbugvec[0] = vector[MVMEPROM_VECTOR].word_one;
	sysbugvec[1] = vector[MVMEPROM_VECTOR].word_two;
}

d1209 16
@


1.180
log
@In nmihand(), do not enter ddb with Debugger(), which causes an exception,
as we might not be in a state where we can process a nested exception. This
would then cause an error exception, which handler calls nmihand. Kaboom.
Instead, directly invoke m88k_db_trap(); from the AV tree.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.179 2006/04/19 22:09:40 miod Exp $	*/
a197 3
 * We could use directly the bugtty console, but we want to be able to
 * configure a kernel without bugtty since we do not necessarily need a
 * full-blown console driver.
d1161 4
a1164 3
	if ((char)c == '\n')
		bugoutchr('\r');
	bugoutchr((char)c);
@


1.179
log
@Get rid of the clock device attachment - since the clock is not something
we can live without, move it into the board-dependent code. This even makes
the code slightly smaller.

clock.c is moved from dev/ to mvme88k/ and only keeps common variables and
delay().
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.178 2006/04/15 15:43:36 miod Exp $	*/
d903 9
a911 2
	if (db_console)
		Debugger();
@


1.178
log
@nmihand() is mvme88k only, move it out of m88k common area.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.177 2006/04/13 21:16:18 miod Exp $	*/
d996 6
a1023 6

	/*
	 * Use the BUG as console for now. After autoconf, we'll switch to
	 * real hardware.
	 */
	cn_tab = &bootcons;
@


1.177
log
@Drop the ivec[] interrupt acknowledge address array, compute the address
itself in the interrupt dispatcher instead of accessing the array: this
computation is of similar complexity, so why bother adding a memory
indirection. No functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.176 2005/12/11 21:45:31 miod Exp $	*/
d89 1
d896 10
@


1.176
log
@Work in progress SMP code; mvme88k boards can spin up secondary CPUs,
kernel boots single user. Still a lot of polishing and bugfixing to do.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.175 2005/12/11 21:36:06 miod Exp $	*/
a104 1
void	setupiackvectors(void);
a111 1
extern void m187_setupiackvectors(void);
a114 1
extern void m188_setupiackvectors(void);
a117 1
extern void m197_setupiackvectors(void);
a128 6
#ifdef MVME188
volatile u_int8_t *ivec[8 + 1];
#else
volatile u_int8_t *ivec[8];
#endif

a481 1
	setupiackvectors();
a771 26
	}
}

/*
 * fill up ivec array with interrupt response vector addresses.
 */
void
setupiackvectors()
{
	switch (brdtyp) {
#ifdef MVME187
	case BRD_187:
	case BRD_8120:
		m187_setupiackvectors();
		break;
#endif
#ifdef MVME188
	case BRD_188:
		m188_setupiackvectors();
		break;
#endif
#ifdef MVME197
	case BRD_197:
		m197_setupiackvectors();
		break;
#endif
@


1.175
log
@Factorize soft interrupt code between luna88k and mvme88k.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.174 2005/12/11 17:05:37 miod Exp $	*/
a99 1
vaddr_t	get_slave_stack(void);
d103 2
a105 2
void	slave_pre_main(void);
int	slave_main(void);
d156 4
d439 1
a439 1
		curbufsize = PAGE_SIZE * ((i < residual) ? (base+1) : base);
d812 10
a821 3
/* gets an interrupt stack for slave processors */
vaddr_t
get_slave_stack()
d823 1
a823 1
	vaddr_t addr;
d825 3
a827 1
	addr = (vaddr_t)uvm_km_zalloc(kernel_map, INTSTACK_SIZE);
d829 1
a829 3
	if (addr == NULL)
		panic("Cannot allocate slave stack for cpu %d",
		    cpu_number());
d831 12
a842 1
	return addr;
d846 1
a846 2
 * Slave CPU pre-main routine.
 * Determine CPU number and set it.
d848 2
a849 1
 * Running on an interrupt stack here; do nothing fancy.
d852 1
a852 1
slave_pre_main()
d854 13
a866 3
	set_cpu_number(cmmu_cpu_number()); /* Determine cpu number by CMMU */
	splhigh();
	set_psr(get_psr() & ~PSR_IND);
d869 1
a869 8
/* dummy main routine for slave processors */
int
slave_main()
{
	printf("slave CPU%d started\n", cpu_number());
	while (1); /* spin forever */
	return 0;
}
a1088 33
	/*
	 * If we have more than one CPU, mention which one is the master.
	 * We will also want to spin up slave CPUs on the long run...
	 */
	switch (brdtyp) {
#ifdef MVME188
	case BRD_188:
		printf("CPU%d is master CPU\n", master_cpu);

#if 0
		int i;
		for (i = 0; i < MAX_CPUS; i++) {
			if (!spin_cpu(i))
				printf("CPU%d started\n", i);
		}
#endif
		break;
#endif
#ifdef MVME197
	case BRD_197:
		/*
		 * In the 197DP case, mention which CPU is the master
		 * there too...
		 * XXX TBD
		 */
		break;
#endif
#ifdef MVME187
	default:
		break;
#endif
	}

d1120 32
d1195 1
a1195 1
	(EMPTY_BR | ((unsigned)(TO) - (unsigned)(FROM)) >> 2)
@


1.174
log
@On halt, wait for a keypress on the console and reboot; allows one to have
the BUG set to auto-boot and not lose the machine upon halting.
Requested by deraadt@@ and nick@@ long ago.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.173 2005/12/04 15:00:26 miod Exp $	*/
a68 2
#include <net/netisr.h>

a96 1
void	dosoftint(void);
a139 2
int ssir;

a976 41
}

int netisr;

void
dosoftint()
{
	if (ssir & SIR_NET) {
		siroff(SIR_NET);
		uvmexp.softs++;
#define DONETISR(bit, fn) \
	do { \
		if (netisr & (1 << bit)) { \
			netisr &= ~(1 << bit); \
			fn(); \
		} \
	} while (0)
#include <net/netisr_dispatch.h>
#undef DONETISR
	}

	if (ssir & SIR_CLOCK) {
		siroff(SIR_CLOCK);
		uvmexp.softs++;
		softclock();
	}
}

int
spl0()
{
	int x;
	x = splsoftclock();

	if (ssir) {
		dosoftint();
	}

	setipl(0);

	return (x);
@


1.173
log
@Let cmmu_init() now return the cpuid of the master cpu.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.172 2005/12/04 12:20:19 miod Exp $	*/
d614 2
a615 3
		printf("halted\n\n");
	} else {
		doboot();
d617 2
@


1.172
log
@Slight cmmu code cleanup; use shorter function names, remove parity_enable
and the DDB and DEBUG helpers which are of questionable usefulness, some
stylistic changes.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.171 2005/12/03 14:30:06 miod Exp $	*/
d566 1
a566 1
	cmmu_shutdown_now();
d1035 1
a1035 1
	u_int master_cpu;
d1097 1
a1097 2
	cmmu_init();
	master_cpu = cmmu_cpu_number();
@


1.171
log
@Switch m88k ports to __HAVE_CPUINFO. Current cpu pointer is held in SR0
on all running processors.
Tested aoyama@@ and I
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.170 2005/11/28 22:21:16 miod Exp $	*/
a1094 2

	cmmu_parity_enable();
@


1.170
log
@Switch to per-process AST flags and clean AST-related codepaths; speeds up
forks as a bonus.
Tested on luna88k and mvme88k by aoyama@@ martin@@ and I.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.169 2005/10/13 19:48:37 miod Exp $	*/
a143 1
int want_resched;
a204 1
extern struct pcb *curpcb;
a1032 1

d1034 3
a1036 10

	/*
	 * Must initialize p_addr before autoconfig or
	 * the fault handler will get a NULL reference.
	 * Do this early so that we can take a data or
	 * instruction fault and survive it.
	 */
	proc0.p_addr = proc0paddr;
	curproc = &proc0;
	curpcb = &proc0paddr->u_pcb;
d1102 10
@


1.169
log
@Merge <machine/cpu_number.h> into <machine/cpu.h>, preparing for intrusive
changes.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.168 2005/10/12 19:05:44 miod Exp $	*/
a143 1
int want_ast;
@


1.168
log
@Stop mapping the u area at fixed UADDR in addition to its actual va.
While there, attempt to clean and comment stack usage in the kernel.
No functional change.

From the m88k SMP tree; help&test martin@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.167 2005/09/25 20:30:03 miod Exp $	*/
a76 1
#include <machine/cpu_number.h>
@


1.167
log
@Do not consider userland trap #496 (BUG system call on mvme88k) as special
anymore, since we don't want to allow userland to talk to the BUG. Deliver
SIGSYS instead of doing nothing. Makes things simpler, plus it polluted
luna88k.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.166 2005/09/11 23:05:37 miod Exp $	*/
a113 2
extern void load_u_area(struct proc *);
extern void save_u_area(struct proc *, vaddr_t);
a129 1
vaddr_t interrupt_stack[MAX_CPUS];
d363 1
a363 1
	vaddr_t minaddr, maxaddr, uarea_pages;
a393 11
	 * Grab UADDR virtual address
	 */
	uarea_pages = UADDR;
	uvm_map(kernel_map, (vaddr_t *)&uarea_pages, USPACE,
	    NULL, UVM_UNKNOWN_OFFSET, 0,
	      UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
	        UVM_ADV_NORMAL, 0));
	if (uarea_pages != UADDR)
		panic("uarea_pages %lx: UADDR not free", uarea_pages);

	/*
a828 1
	interrupt_stack[cpu_number()] = addr;
a1171 8
	/* Initialize cached PTEs for u-area mapping. */
	save_u_area(&proc0, (vaddr_t)proc0paddr);

	/*
	 * Map proc0's u-area at the standard address (UADDR).
	 */
	load_u_area(&proc0);

d1173 1
a1173 1
	bzero((caddr_t)UADDR, UPAGES * PAGE_SIZE);
@


1.166
log
@ivec[] needs to be one entry larger on 188.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.165 2005/04/30 16:42:37 miod Exp $	*/
a98 1
void	bugsyscall(void);
a992 5
bugsyscall()
{
}

void
a1264 2
	extern void bugtrap(void);
	extern void m88110_bugtrap(void);
a1285 1
		SET_VECTOR(MVMEPROM_VECTOR, m88110_bugtrap);
a1299 1
		SET_VECTOR(MVMEPROM_VECTOR, bugtrap);
@


1.165
log
@Remove m88k_psr_type and function with utterly long names to control the psr,
and use get_psr() / set_psr() or simple macros that expand into them everywhere.
No functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.164 2005/04/27 14:09:45 miod Exp $	*/
d142 3
d146 1
d345 1
a345 1
 * These function pointers are set in dev/clock.c and dev/sclock.c
@


1.164
log
@Allow userland to cause the data cache to be flushed for any arbitrary address
range in the current process, using trap #451.

This is necessary for proper gcc trampolines operation, and, later, ld.so...
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.163 2004/12/02 19:40:46 miod Exp $	*/
d855 1
a855 1
	enable_interrupt();
d1322 1
a1322 2
	u_int curspl;
	m88k_psr_type psr;
d1324 1
a1324 1
	psr = disable_interrupts_return_psr();
d1333 1
a1333 2
	u_int curspl;
	m88k_psr_type psr;
d1335 1
a1335 1
	psr = disable_interrupts_return_psr();
d1352 1
a1352 2
	u_int curspl;
	m88k_psr_type psr;
d1354 1
a1354 1
	psr = disable_interrupts_return_psr();
@


1.163
log
@We do not support 2MB machines, so don't bother taking them into account
in allocsys().
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.162 2004/11/09 18:25:24 miod Exp $	*/
d1289 1
d1304 1
@


1.162
log
@Kill more unused stuff.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.161 2004/11/09 12:01:19 miod Exp $	*/
d554 2
a555 5
		if (physmem < btoc(2 * 1024 * 1024))
			bufpages = physmem / 10;
		else
			bufpages = (btoc(2 * 1024 * 1024) + physmem) *
			    bufcachepercent / 100;
@


1.161
log
@Split {get,set,raise}ipl() into per-board implementations.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.160 2004/11/08 16:39:31 miod Exp $	*/
a114 4
#ifdef MVME188
extern unsigned int m188_curspl[];		/* XXX temporary */
#endif

a119 1
extern void m187_ext_int(u_int, struct trapframe *);
a123 1
extern void m188_ext_int(u_int, struct trapframe *);
a127 1
extern void m197_ext_int(u_int, struct trapframe *);
@


1.160
log
@Kill struct md_p, which was really only necessary for mvme88k; on
luna88k it disappears completely, while mvme88k keeps 3 global variables,
one of them scheduled to disappear very soon.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.159 2004/10/01 19:00:52 miod Exp $	*/
a142 1
volatile u_int8_t *md_intr_mask;
d145 3
d1330 1
a1330 1
	unsigned curspl;
d1334 1
a1334 14
	switch (brdtyp) {
#ifdef MVME188
	case BRD_188:
		curspl = m188_curspl[cpu_number()];
		break;
#endif /* MVME188 */
#if defined(MVME187) || defined(MVME197)
	case BRD_187:
	case BRD_8120:
	case BRD_197:
		curspl = *md_intr_mask & 0x07;
		break;
#endif /* defined(MVME187) || defined(MVME197) */
	}
d1342 1
a1342 1
	unsigned curspl;
d1346 1
a1346 16
	switch (brdtyp) {
#ifdef MVME188
	case BRD_188:
		curspl = m188_curspl[cpu_number()];
		setlevel(level);
		break;
#endif /* MVME188 */
#if defined(MVME187) || defined(MVME197)
	case BRD_187:
	case BRD_8120:
	case BRD_197:
		curspl = *md_intr_mask & 0x07;
		*md_intr_mask = level;
		break;
#endif /* defined(MVME187) || defined(MVME197) */
	}
d1349 1
a1349 1
	 * The flush pipeline is required to make sure the above write gets
d1362 1
a1362 1
	unsigned curspl;
d1366 1
a1366 18
	switch (brdtyp) {
#ifdef MVME188
	case BRD_188:
		curspl = m188_curspl[cpu_number()];
		if (curspl < level)
			setlevel(level);
		break;
#endif /* MVME188 */
#if defined(MVME187) || defined(MVME197)
	case BRD_187:
	case BRD_8120:
	case BRD_197:
		curspl = *md_intr_mask & 0x07;
		if (curspl < level)
			*md_intr_mask = level;
		break;
#endif /* defined(MVME187) || defined(MVME197) */
	}
d1369 1
a1369 1
	 * The flush pipeline is required to make sure the above write gets
@


1.159
log
@More mvme88k code cleaning:
- merge locore_c_routines.c into machdep.c
- split machdep.c into really machdep.c content, and board-specific routines
  (memory sizing, early initialization, etc).

No functionnal change.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.158 2004/10/01 05:49:01 miod Exp $	*/
d142 4
a145 2
/* machine dependent function pointers. */
struct md_p md;
d233 1
a233 1
	1
d351 1
a351 6
	if (md.clock_init_func != NULL) {
		(*md.clock_init_func)();
	}
	if (md.statclock_init_func != NULL) {
		(*md.statclock_init_func)();
	}
a1074 3
	/* zero out the machine dependent function pointers */
	bzero(&md, sizeof(struct md_p));

d1342 1
a1342 1
		curspl = *md.intr_mask & 0x07;
d1368 2
a1369 2
		curspl = *md.intr_mask & 0x07;
		*md.intr_mask = level;
d1404 1
a1404 1
		curspl = *md.intr_mask & 0x07;
d1406 1
a1406 1
			*md.intr_mask = level;
@


1.158
log
@Oops, trimmed includes too much for RAMDISK.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.157 2004/09/30 14:55:54 miod Exp $	*/
d71 2
a72 1
#include <machine/asm_macro.h>   /* enable/disable interrupts */
a81 12
#ifdef M88100
#include <machine/m88100.h>		/* DMT_VALID */
#endif
#ifdef MVME187
#include <machine/mvme187.h>
#endif
#ifdef MVME197
#include <machine/mvme197.h>
#endif
#ifdef MVME188
#include <machine/mvme188.h>
#endif
a86 7
#ifdef MVME188
#include <mvme88k/dev/sysconreg.h>
#endif
#ifdef MVME197
#include <mvme88k/dev/busswreg.h>
#endif

d94 45
d145 1
a145 54
/* prototypes */
void setupiackvectors(void);
void dumpsys(void);
void consinit(void);
vaddr_t size_memory(void);
vaddr_t memsize187(void);
vaddr_t memsize188(void);
int getcpuspeed(struct mvmeprom_brdid *);
void identifycpu(void);
void save_u_area(struct proc *, vaddr_t);
void load_u_area(struct proc *);
void dumpconf(void);
void m187_ext_int(u_int v, struct trapframe *eframe);
void m188_ext_int(u_int v, struct trapframe *eframe);
void m197_ext_int(u_int v, struct trapframe *eframe);

unsigned char *volatile ivec[] = {
	(unsigned char *)0xFFFE0003, /* not used, no such thing as int 0 */
	(unsigned char *)0xFFFE0007,
	(unsigned char *)0xFFFE000B,
	(unsigned char *)0xFFFE000F,
	(unsigned char *)0xFFFE0013,
	(unsigned char *)0xFFFE0017,
	(unsigned char *)0xFFFE001B,
	(unsigned char *)0xFFFE001F,
	(unsigned char *)0x00000000,
};

#ifdef MVME188
/*
 * *int_mask_reg[CPU]
 * Points to the hardware interrupt status register for each CPU.
 */
unsigned int *volatile int_mask_reg[MAX_CPUS] = {
	(unsigned int *)IEN0_REG,
	(unsigned int *)IEN1_REG,
	(unsigned int *)IEN2_REG,
	(unsigned int *)IEN3_REG
};
#endif

#if defined(MVME187) || defined(MVME197)
volatile vaddr_t obiova;
#ifdef MVME187
volatile vaddr_t bugromva;
volatile vaddr_t sramva;
#endif
#ifdef MVME197
volatile vaddr_t flashva;
#endif
#endif
#ifdef MVME188
volatile vaddr_t utilva;
#endif
d172 1
a172 1
int   nbuf = NBUF;
d174 1
a174 1
int   nbuf = 0;
d182 1
a182 1
int   bufpages = BUFPAGES;
d184 1
a184 1
int   bufpages = 0;
d186 1
a186 3
int   bufcachepercent = BUFCACHEPERCENT;

caddr_t allocsys(caddr_t);
d230 1
a230 1
	makedev(14,0),
a241 1

a251 103
#ifdef MVME187
/*
 * Figure out how much memory is available, by querying the memory controllers.
 */
#include <mvme88k/dev/memcreg.h>
vaddr_t
memsize187()
{
	struct memcreg *memc;
	vaddr_t x;

	memc = (struct memcreg *)MEM_CTLR;
	x = MEMC_MEMCONF_RTOB(memc->memc_memconf);

	memc = (struct memcreg *)(MEM_CTLR + 0x100);
	if (!badaddr((vaddr_t)&memc->memc_memconf, 1))
		x += MEMC_MEMCONF_RTOB(memc->memc_memconf);

	return x;
}
#endif

#ifdef MVME188
/*
 * Figure out how much memory is available, by querying the MBus registers.
 *
 * For every 4MB segment, ask the MBus address decoder which device claimed
 * the range. Since memory is packed at low addresses, we will hit all memory
 * boards in order until reaching either a VME space or a non-claimed space.
 *
 * As a safety measure, we never check for more than 256MB - the 188 can
 * only have up to 4 memory boards, which theoretically can not be larger
 * than 64MB, and I am not aware of third-party larger memory boards.
 */
vaddr_t
memsize188()
{
	unsigned int pgnum;
	int32_t rmad;

#define	MVME188_MAX_MEMORY	((4 * 64) / 4)	/* 4 64MB boards */
	for (pgnum = 0; pgnum <	MVME188_MAX_MEMORY; pgnum++) {
		*(volatile int32_t *)RMAD_REG = (pgnum << 22);
		rmad = *(volatile int32_t *)RMAD_REG;

		if (rmad & 0x04)	/* not a memory board */
			break;
	}

	return (pgnum << 22);
}
#endif

#ifdef MVME197
/*
 * Figure out how much real memory is available.
 * Start looking from the megabyte after the end of the kernel data,
 * until we find non-memory.
 */
vaddr_t
size_memory()
{
	unsigned int *volatile look;
	unsigned int *max;
	extern char *end;
#define PATTERN   0x5a5a5a5a
#define STRIDE    (4*1024) 	/* 4k at a time */
#define Roundup(value, stride) (((unsigned)(value) + (stride) - 1) & ~((stride)-1))
	/*
	 * count it up.
	 */
#define	MAXPHYSMEM	0x30000000	/* 768MB */
	max = (void *)MAXPHYSMEM;
	for (look = (void *)Roundup(end, STRIDE); look < max;
	    look = (int *)((unsigned)look + STRIDE)) {
		unsigned save;

		/* if can't access, we've reached the end */
		if (badwordaddr((vaddr_t)look)) {
#if defined(DEBUG)
			printf("%x\n", look);
#endif
			look = (int *)((int)look - STRIDE);
			break;
		}

		/*
		 * If we write a value, we expect to read the same value back.
		 * We'll do this twice, the 2nd time with the opposite bit
		 * pattern from the first, to make sure we check all bits.
		 */
		save = *look;
		if (*look = PATTERN, *look != PATTERN)
			break;
		if (*look = ~PATTERN, *look != ~PATTERN)
			break;
		*look = save;
	}

	return (trunc_page((unsigned)look));
}
#endif

d378 2
a379 2
		pmap_kenter_pa((paddr_t)msgbufp + i * NBPG,
		    avail_end + i * NBPG, VM_PROT_READ | VM_PROT_WRITE);
d419 6
a424 32
		/*
		 * Grab the SRAM space that we hardwired in pmap_bootstrap
		 */
		sramva = SRAM_START;
		uvm_map(kernel_map, (vaddr_t *)&sramva, SRAM_SIZE,
		    NULL, UVM_UNKNOWN_OFFSET, 0,
		      UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
		        UVM_ADV_NORMAL, 0));
		if (sramva != SRAM_START)
			panic("sramva %lx: SRAM not free", sramva);

		/*
		 * Grab the BUGROM space that we hardwired in pmap_bootstrap
		 */
		bugromva = BUG187_START;
		uvm_map(kernel_map, (vaddr_t *)&bugromva, BUG187_SIZE,
		    NULL, UVM_UNKNOWN_OFFSET, 0,
		      UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
		        UVM_ADV_NORMAL, 0));
		if (bugromva != BUG187_START)
			panic("bugromva %lx: BUGROM not free", bugromva);

		/*
		 * Grab the OBIO space that we hardwired in pmap_bootstrap
		 */
		obiova = OBIO_START;
		uvm_map(kernel_map, (vaddr_t *)&obiova, OBIO_SIZE,
		    NULL, UVM_UNKNOWN_OFFSET, 0,
		      UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
		        UVM_ADV_NORMAL, 0));
		if (obiova != OBIO_START)
			panic("obiova %lx: OBIO not free", obiova);
d429 1
a429 35
		/*
		 * Grab the FLASH space that we hardwired in pmap_bootstrap
		 */
		flashva = FLASH_START;
		uvm_map(kernel_map, (vaddr_t *)&flashva, FLASH_SIZE,
		    NULL, UVM_UNKNOWN_OFFSET, 0,
		      UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
		        UVM_ADV_NORMAL, 0));
		if (flashva != FLASH_START)
			panic("flashva %lx: FLASH not free", flashva);

		/*
		 * Grab the OBIO space that we hardwired in pmap_bootstrap
		 */
		obiova = OBIO_START;
		uvm_map(kernel_map, (vaddr_t *)&obiova, OBIO_SIZE,
		    NULL, UVM_UNKNOWN_OFFSET, 0,
		      UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
		        UVM_ADV_NORMAL, 0));
		if (obiova != OBIO_START)
			panic("obiova %lx: OBIO not free", obiova);
		break;
#endif
#ifdef MVME188
	case BRD_188:
		/*
		 * Grab the UTIL space that we hardwired in pmap_bootstrap
		 */
		utilva = MVME188_UTILITY;
		uvm_map(kernel_map, (vaddr_t *)&utilva, MVME188_UTILITY_SIZE,
		    NULL, UVM_UNKNOWN_OFFSET, 0,
		      UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
		        UVM_ADV_NORMAL, 0));
		if (utilva != MVME188_UTILITY)
			panic("utilva %lx: UTILITY area not free", utilva);
a648 28
#ifdef MVME188
void
m188_reset()
{
	volatile int cnt;

	*(volatile u_int32_t *)IEN0_REG = 0;
	*(volatile u_int32_t *)IEN1_REG = 0;
	*(volatile u_int32_t *)IEN2_REG = 0;
	*(volatile u_int32_t *)IEN3_REG = 0;

	if ((*(volatile u_int8_t *)GLB1) & M188_SYSCON) {
		/* Force a complete VMEbus reset */
		*(volatile u_int32_t *)GLBRES_REG = 1;
	} else {
		/* Force only a local reset */
		*(volatile u_int8_t *)GLB1 |= M188_LRST;
	}

	*(volatile u_int32_t *)UCSR_REG |= 0x2000;	/* clear SYSFAIL */
	for (cnt = 0; cnt < 5*1024*1024; cnt++)
		;
	*(volatile u_int32_t *)UCSR_REG |= 0x2000;	/* clear SYSFAIL */

	printf("reset failed\n");
}
#endif   /* MVME188 */

a818 9
	u_char *vaddr;
#undef MAP_VEC /* Switching to new virtual addresses XXX smurph */
#ifdef MAP_VEC
	extern vaddr_t iomap_mapin(paddr_t, psize_t,  boolean_t);
#endif
	/*
	 * map a page in for phys address 0xfffe0000 (M187) and set the
	 * addresses for various levels.
	 */
d823 2
a824 4
#ifdef MAP_VEC /* do for MVME188 too */
		vaddr = (u_char *)iomap_mapin(M187_IACK, NBPG, 1);
#else
		vaddr = (u_char *)M187_IACK;
a825 2
		break;
#endif /* MVME187 */
d828 2
a829 4
#ifdef MAP_VEC /* do for MVME188 too */
		vaddr = (u_char *)iomap_mapin(M188_IACK, NBPG, 1);
#else
		vaddr = (u_char *)M188_IACK;
a830 12
		ivec[0] = vaddr;	/* We dont use level 0 */
		ivec[1] = vaddr + 0x04;
		ivec[2] = vaddr + 0x08;
		ivec[3] = vaddr + 0x0c;
		ivec[4] = vaddr + 0x10;
		ivec[5] = vaddr + 0x14;
		ivec[6] = vaddr + 0x18;
		ivec[7] = vaddr + 0x1c;
		ivec[8] = vaddr + 0x20;	/* for self inflicted interrupts */
		*ivec[8] = M188_IVEC;	/* supply a vector base for m188ih */
		break;
#endif /* MVME188 */
d833 1
a833 5
#ifdef MAP_VEC /* do for MVME188 too */
		vaddr = (u_char *)iomap_mapin(M197_IACK, NBPG, 1);
#else
		vaddr = (u_char *)M197_IACK;
#endif
a834 4
#endif /* MVME197 */
	}
#ifdef DEBUG
	printf("interrupt ACK address mapped at 0x%x\n", vaddr);
a835 11

#if defined(MVME187) || defined(MVME197)
	if (brdtyp != BRD_188) {
		ivec[0] = vaddr + 0x03;	/* We dont use level 0 */
		ivec[1] = vaddr + 0x07;
		ivec[2] = vaddr + 0x0b;
		ivec[3] = vaddr + 0x0f;
		ivec[4] = vaddr + 0x13;
		ivec[5] = vaddr + 0x17;
		ivec[6] = vaddr + 0x1b;
		ivec[7] = vaddr + 0x1f;
a836 1
#endif
a859 2
 *
 * Called from "mvme88k/locore.S"
d864 3
a866 3
   set_cpu_number(cmmu_cpu_number()); /* Determine cpu number by CMMU */
   splhigh();
   enable_interrupt();
d879 1
a879 1
 * Search for the first avilable interrupt vector in the range start, end.
a940 415
#ifdef MVME188

/*
 *	Device interrupt handler for MVME188
 *
 *      when we enter, interrupts are disabled;
 *      when we leave, they should be disabled,
 *      but they need not be disabled throughout
 *      the routine.
 */

/* Hard coded vector table for onboard devices. */
const unsigned int obio_vec[32] = {
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
        0,SYSCV_SCC,0,0,SYSCV_SYSF,SYSCV_TIMER2,0,0,
	0,0,0,0,SYSCV_TIMER1,0,SYSCV_ACF,SYSCV_ABRT,
};

#define GET_MASK(cpu, val)	*int_mask_reg[cpu] & (val)
#define VME_VECTOR_MASK		0x1ff 		/* mask into VIACK register */
#define VME_BERR_MASK		0x100 		/* timeout during VME IACK cycle */

void
m188_ext_int(u_int v, struct trapframe *eframe)
{
	int cpu = cpu_number();
	unsigned int cur_mask;
	unsigned int level, old_spl;
	struct intrhand *intr;
	intrhand_t *list;
	int ret, intbit;
	unsigned vec;

	cur_mask = ISR_GET_CURRENT_MASK(cpu);
	old_spl = m188_curspl[cpu];
	eframe->tf_mask = old_spl;

	if (cur_mask == 0) {
		/*
		 * Spurious interrupts - may be caused by debug output clearing
		 * DUART interrupts.
		 */
		flush_pipeline();
		goto out;
	}

	uvmexp.intrs++;

	/*
	 * We want to service all interrupts marked in the IST register
	 * They are all valid because the mask would have prevented them
	 * from being generated otherwise.  We will service them in order of
	 * priority.
	 */
	do {
		level = safe_level(cur_mask, old_spl);

		if (old_spl >= level) {
			int i;

			printf("safe level %d <= old level %d\n", level, old_spl);
			printf("cur_mask = 0x%b\n", cur_mask, IST_STRING);
			for (i = 0; i < 4; i++)
				printf("IEN%d = 0x%b  ", i, *int_mask_reg[i], IST_STRING);
			printf("\nCPU0 spl %d  CPU1 spl %d  CPU2 spl %d  CPU3 spl %d\n",
			       m188_curspl[0], m188_curspl[1],
			       m188_curspl[2], m188_curspl[3]);
			for (i = 0; i < 8; i++)
				printf("int_mask[%d] = 0x%08x\n", i, int_mask_val[i]);
			printf("--CPU %d halted--\n", cpu_number());
			spl7();
			for(;;) ;
		}

#ifdef DEBUG
		if (level > 7 || (int)level < 0) {
			panic("int level (%x) is not between 0 and 7", level);
		}
#endif

		setipl(level);

		/*
		 * Do not enable interrupts yet if we know, from cur_mask,
		 * that we have not cleared enough conditions yet.
		 * For now, only the timer interrupt requires its condition
		 * to be cleared before interrupts are enabled.
		 */
		if ((cur_mask & DTI_BIT) == 0) {
			enable_interrupt();
		}

		/* generate IACK and get the vector */

		/*
		 * This is tricky.  If you don't catch all the
		 * interrupts, you die. Game over. Insert coin...
		 * XXX smurph
		 */

		/* find the first bit set in the current mask */
		intbit = ff1(cur_mask);
		if (OBIO_INTERRUPT_MASK & (1 << intbit)) {
			vec = SYSCON_VECT + obio_vec[intbit];
			if (vec == 0) {
				panic("unknown onboard interrupt: mask = 0x%b",
				    1 << intbit, IST_STRING);
			}
		} else if (HW_FAILURE_MASK & (1 << intbit)) {
			vec = SYSCON_VECT + obio_vec[intbit];
			if (vec == 0) {
				panic("unknown hardware failure: mask = 0x%b",
				    1 << intbit, IST_STRING);
			}
		} else if (VME_INTERRUPT_MASK & (1 << intbit)) {
			if (guarded_access(ivec[level], 4, (u_char *)&vec) ==
			    EFAULT) {
				panic("unable to get vector for this vmebus "
				    "interrupt (level %x)", level);
			}
			vec &= VME_VECTOR_MASK;
			if (vec & VME_BERR_MASK) {
				printf("VME vec timeout, vec = %x, mask = 0x%b\n",
				    vec, 1 << intbit, IST_STRING);
				break;
			}
			if (vec == 0) {
				panic("unknown vme interrupt: mask = 0x%b",
				    1 << intbit, IST_STRING);
			}
		} else {
			panic("unknown interrupt: level = %d intbit = 0x%x "
			    "mask = 0x%b",
			    level, intbit, 1 << intbit, IST_STRING);
		}

		list = &intr_handlers[vec];
		if (SLIST_EMPTY(list)) {
			/* increment intr counter */
			intrcnt[M88K_SPUR_IRQ]++;
			printf("Spurious interrupt: level = %d vec = 0x%x, "
			    "intbit = %d mask = 0x%b\n",
			    level, vec, intbit, 1 << intbit, IST_STRING);
		} else {
			/*
			 * Walk through all interrupt handlers in the chain
			 * for the given vector, calling each handler in turn,
			 * till some handler returns a value != 0.
			 */
			ret = 0;
			SLIST_FOREACH(intr, list, ih_link) {
				if (intr->ih_wantframe != 0)
					ret = (*intr->ih_fn)((void *)eframe);
				else
					ret = (*intr->ih_fn)(intr->ih_arg);
				if (ret != 0) {
					intrcnt[level]++;
					intr->ih_count.ec_count++;
					break;
				}
			}
			if (ret == 0) {
				printf("Unclaimed interrupt: level = %d "
				    "vec = 0x%x, intbit = %d mask = 0x%b\n",
				    level, vec, intbit,
				    1 << intbit, IST_STRING);
				break;
			}
		}
	} while ((cur_mask = ISR_GET_CURRENT_MASK(cpu)) != 0);

	/*
	 * process any remaining data access exceptions before
	 * returning to assembler
	 */
	disable_interrupt();
out:
	if (eframe->tf_dmt0 & DMT_VALID)
		m88100_trap(T_DATAFLT, eframe);

	/*
	 * Restore the mask level to what it was when the interrupt
	 * was taken.
	 */
	setipl(eframe->tf_mask);
}

#endif /* MVME188 */

/*
 *	Device interrupt handler for MVME1x7
 *
 *      when we enter, interrupts are disabled;
 *      when we leave, they should be disabled,
 *      but they need not be disabled throughout
 *      the routine.
 */

#ifdef MVME187
void
m187_ext_int(u_int v, struct trapframe *eframe)
{
	int mask, level;
	struct intrhand *intr;
	intrhand_t *list;
	int ret;
	u_char vec;

	/* get level and mask */
	mask = *md.intr_mask & 0x07;
	level = *md.intr_ipl & 0x07;

#ifdef DIAGNOSTIC
	/*
	 * It is really bizarre for the mask and level to the be the same.
	 * pcc2 for 187 blocks all interrupts at and below the mask value,
	 * so we should not be getting an interrupt at the level that is
	 * already blocked. I can't explain this case XXX nivas
	 */

	if ((mask == level) && level) {
		panic("mask == level, %d", level);
	}

	/*
	 * Interrupting level cannot be 0--0 doesn't produce an interrupt.
	 * Weird! XXX nivas
	 */

	if (level == 0) {
		panic("Bogons... level %x and mask %x", level, mask);
	}
#endif

	uvmexp.intrs++;

	/* generate IACK and get the vector */
	flush_pipeline();
	if (guarded_access(ivec[level], 1, &vec) == EFAULT) {
		panic("Unable to get vector for this interrupt (level %x)", level);
	}
	flush_pipeline();
	flush_pipeline();
	flush_pipeline();

	/* block interrupts at level or lower */
	setipl(level);

	enable_interrupt();

	list = &intr_handlers[vec];
	if (SLIST_EMPTY(list)) {
		/* increment intr counter */
		intrcnt[M88K_SPUR_IRQ]++;
		printf("Spurious interrupt (level %x and vec %x)\n",
		       level, vec);
	} else {
#ifdef DIAGNOSTIC
		intr = SLIST_FIRST(list);
		if (intr->ih_ipl != level) {
			panic("Handler ipl %x not the same as level %x. "
			    "vec = 0x%x",
			    intr->ih_ipl, level, vec);
		}
#endif

		/*
		 * Walk through all interrupt handlers in the chain for the
		 * given vector, calling each handler in turn, till some handler
		 * returns a value != 0.
		 */

		ret = 0;
		SLIST_FOREACH(intr, list, ih_link) {
			if (intr->ih_wantframe != 0)
				ret = (*intr->ih_fn)((void *)eframe);
			else
				ret = (*intr->ih_fn)(intr->ih_arg);
			if (ret != 0) {
				intrcnt[level]++;
				intr->ih_count.ec_count++;
				break;
			}
		}

		if (ret == 0) {
			printf("Unclaimed interrupt (level %x and vec %x)\n",
			    level, vec);
		}
	}

	/*
	 * process any remaining data access exceptions before
	 * returning to assembler
	 */
	disable_interrupt();
	if (eframe->tf_dmt0 & DMT_VALID)
		m88100_trap(T_DATAFLT, eframe);

	/*
	 * Restore the mask level to what it was when the interrupt
	 * was taken.
	 */
	setipl(mask);
}
#endif /* MVME187 */

#ifdef MVME197
void
m197_ext_int(u_int v, struct trapframe *eframe)
{
	int mask, level, src;
	struct intrhand *intr;
	intrhand_t *list;
	int ret;
	u_char vec;

	/* get src and mask */
	mask = *md.intr_mask & 0x07;
	src = *md.intr_src;

	if (v == T_NON_MASK) {
		/* This is the abort switch */
		level = IPL_NMI;
		vec = BS_ABORTVEC;
	} else {
		/* get level  */
		level = *md.intr_ipl & 0x07;
	}

#ifdef DIAGNOSTIC
	/*
	 * Interrupting level cannot be 0--0 doesn't produce an interrupt.
	 * Weird! XXX nivas
	 */

	if (level == 0) {
		panic("Bogons... level %x and mask %x", level, mask);
	}
#endif

	uvmexp.intrs++;

	if (v != T_NON_MASK) {
		/* generate IACK and get the vector */
		flush_pipeline();
		if (guarded_access(ivec[level], 1, &vec) == EFAULT) {
			panic("Unable to get vector for this interrupt (level %x)", level);
		}
		flush_pipeline();
		flush_pipeline();
		flush_pipeline();
	}

	if (v != T_NON_MASK || cold == 0) {
		/* block interrupts at level or lower */
		setipl(level);

		enable_interrupt();
	}

	list = &intr_handlers[vec];
	if (SLIST_EMPTY(list)) {
		/* increment intr counter */
		intrcnt[M88K_SPUR_IRQ]++;
		printf("Spurious interrupt (level %x and vec %x)\n",
		       level, vec);
	} else {
#ifdef DIAGNOSTIC
		intr = SLIST_FIRST(list);
		if (intr->ih_ipl != level) {
			panic("Handler ipl %x not the same as level %x. "
			    "vec = 0x%x",
			    intr->ih_ipl, level, vec);
		}
#endif

		/*
		 * Walk through all interrupt handlers in the chain for the
		 * given vector, calling each handler in turn, till some handler
		 * returns a value != 0.
		 */

		ret = 0;
		SLIST_FOREACH(intr, list, ih_link) {
			if (intr->ih_wantframe != 0)
				ret = (*intr->ih_fn)((void *)eframe);
			else
				ret = (*intr->ih_fn)(intr->ih_arg);
			if (ret != 0) {
				intrcnt[level]++;
				intr->ih_count.ec_count++;
				break;
			}
		}

		if (ret == 0) {
			printf("Unclaimed interrupt (level %x and vec %x)\n",
			    level, vec);
		}
	}

	if (v != T_NON_MASK || cold == 0) {
		disable_interrupt();

		/*
		 * Restore the mask level to what it was when the interrupt
		 * was taken.
		 */
		setipl(mask);
	}
}
#endif	/* MVME197 */

a999 2
/* dummys for now */

a1059 1

a1064 7
#ifdef MVME197
	extern struct cmmu_p cmmu88110;
#endif
#if defined(MVME187) || defined(MVME188)
	extern struct cmmu_p cmmu8820x;
#endif
	extern void set_tcfp(void);
d1072 1
a1072 1
	 * instruction fault and survive it. XXX smurph
d1081 1
a1081 1
	buginit(); /* init the bug routines */
d1086 1
a1086 2
	 * set up interrupt and fp exception handlers
	 * based on the machine.
a1088 14
#ifdef MVME188
	case BRD_188:
		cmmu = &cmmu8820x;
		md.interrupt_func = &m188_ext_int;
		md.intr_mask = NULL;
		md.intr_ipl = NULL;
		md.intr_src = NULL;
		/* clear and disable all interrupts */
		*int_mask_reg[0] = 0;
		*int_mask_reg[1] = 0;
		*int_mask_reg[2] = 0;
		*int_mask_reg[3] = 0;
		break;
#endif /* MVME188 */
d1092 1
a1092 5
		cmmu = &cmmu8820x;
		md.interrupt_func = &m187_ext_int;
		md.intr_mask = (u_char *)M187_IMASK;
		md.intr_ipl = (u_char *)M187_ILEVEL;
		md.intr_src = NULL;
d1094 6
a1099 1
#endif /* MVME187 */
d1102 1
a1102 6
		cmmu = &cmmu88110;
		md.interrupt_func = &m197_ext_int;
		md.intr_mask = (u_char *)M197_IMASK;
		md.intr_ipl = (u_char *)M197_ILEVEL;
		md.intr_src = (u_char *)M197_ISRC;
		set_tcfp(); /* Set Time Critical Floating Point Mode */
d1104 1
a1104 1
#endif /* MVME197 */
d1106 1
a1106 1
		panic("mvme_bootstrap: Can't determine cpu type.");
d1109 4
a1112 1
	/* startup fake console driver.  It will be replaced by consinit() */
d1115 1
a1115 1
	uvmexp.pagesize = NBPG;
d1123 1
a1123 1
		last_addr = memsize187();
d1128 1
a1128 1
		last_addr = memsize188();
d1133 1
a1133 1
		last_addr = size_memory();
a1135 2
	default:
		break;
d1151 1
d1163 2
d1172 5
d1181 1
d1188 2
a1189 1
	printf("MVME%x boot: memory from 0x%x to 0x%x\n", brdtyp, avail_start, avail_end);
d1195 4
a1198 1
	 * mvme88k only has one segment.
d1212 1
a1212 1
	bzero((caddr_t)UADDR, UPAGES*NBPG);
d1252 174
@


1.157
log
@More code shuffling, probably the final touch.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.156 2004/09/30 09:20:48 miod Exp $	*/
d80 1
@


1.156
log
@Move common signal code to m88k-agnostic location.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.155 2004/08/25 08:00:09 miod Exp $	*/
a48 1
#include <sys/signalvar.h>
a71 1
#include <machine/mmu.h>
d74 1
a74 1
#include <machine/cmmu.h>		/* CMMU stuff	*/
a78 1
#include <machine/prom.h>
a79 1
#include <machine/trap.h>
a118 1
void regdump(struct trapframe *f);
a176 6
int longformat = 1;  /* for regdump() */
/*
 * safepri is a safe priority for sleep to set for a spin-wait
 * during autoconfiguration or after a panic.
 */
int   safepri = IPL_NONE;
a473 30
 *	Setup u area ptes for u area double mapping.
 */

void
save_u_area(struct proc *p, vaddr_t va)
{
	int i;

	for (i = 0; i < UPAGES; i++) {
		p->p_md.md_upte[i] = *((pt_entry_t *)kvtopte(va));
		va += NBPG;
	}
}

void
load_u_area(struct proc *p)
{
	int i;
	vaddr_t va;
	pt_entry_t *t;

	for (i = 0, va = UADDR; i < UPAGES; i++) {
		t = kvtopte(va);
		*t = p->p_md.md_upte[i];
		va += NBPG;
	}
	cmmu_flush_tlb(cpu_number(), 1, UADDR, USPACE);
}

/*
a779 78
/*
 * Set registers on exec.
 * Clear all except sp and pc.
 */
void
setregs(p, pack, stack, retval)
	struct proc *p;
	struct exec_package *pack;
	u_long stack;
	int retval[2];
{
	struct trapframe *tf = (struct trapframe *)USER_REGS(p);

	/*
	 * The syscall will ``return'' to snip; set it.
	 * argc, argv, envp are placed on the stack by copyregs.
	 * Point r2 to the stack. crt0 should extract envp from
	 * argc & argv before calling user's main.
	 */
#if 0
	/*
	 * I don't think I need to mess with fpstate on 88k because
	 * we make sure the floating point pipeline is drained in
	 * the trap handlers. Should check on this later. XXX Nivas.
	 */

	if ((fs = p->p_md.md_fpstate) != NULL) {
		/*
		 * We hold an FPU state.  If we own *the* FPU chip state
		 * we must get rid of it, and the only way to do that is
		 * to save it.  In any case, get rid of our FPU state.
		 */
		if (p == fpproc) {
			savefpstate(fs);
			fpproc = NULL;
		}
		free((void *)fs, M_SUBPROC);
		p->p_md.md_fpstate = NULL;
	}
#endif /* 0 */
	bzero((caddr_t)tf, sizeof *tf);

	if (cputyp == CPU_88110) {
		/*
		 * user mode, serialize mem, interrupts enabled,
		 * graphics unit, fp enabled
		 */
		tf->tf_epsr = PSR_SRM | PSR_SFD;
		/*
		 * XXX disable OoO for now...
		 */
		tf->tf_epsr |= PSR_SER;
	} else {
		/*
		 * user mode, interrupts enabled,
		 * no graphics unit, fp enabled
		 */
		tf->tf_epsr = PSR_SFD | PSR_SFD2;
	}

	/*
	 * We want to start executing at pack->ep_entry. The way to
	 * do this is force the processor to fetch from ep_entry. Set
	 * NIP to something bogus and invalid so that it will be a NOOP.
	 * And set sfip to ep_entry with valid bit on so that it will be
	 * fetched.  mc88110 - just set exip to pack->ep_entry.
	 */
	if (cputyp == CPU_88110) {
		tf->tf_exip = pack->ep_entry & ~3;
	} else {
		tf->tf_snip = pack->ep_entry & ~3;
		tf->tf_sfip = (pack->ep_entry & ~3) | FIP_V;
	}
	tf->tf_r[2] = stack;
	tf->tf_r[31] = stack;
	retval[1] = 0;
}

a1682 66
int
copystr(fromaddr, toaddr, maxlength, lencopied)
	const void *fromaddr;
	void *toaddr;
	size_t maxlength;
	size_t *lencopied;
{
	u_int tally;

	tally = 0;

	while (maxlength--) {
		*(u_char *)toaddr = *(u_char *)fromaddr++;
		tally++;
		if (*(u_char *)toaddr++ == 0) {
			if (lencopied) *lencopied = tally;
			return (0);
		}
	}

	if (lencopied)
		*lencopied = tally;

	return (ENAMETOOLONG);
}

void
setrunqueue(p)
	struct proc *p;
{
	struct prochd *q;
	struct proc *oldlast;
	int which = p->p_priority >> 2;

	if (p->p_back != NULL)
		panic("setrunqueue %p", p);
	q = &qs[which];
	whichqs |= 1 << which;
	p->p_forw = (struct proc *)q;
	p->p_back = oldlast = q->ph_rlink;
	q->ph_rlink = p;
	oldlast->p_forw = p;
}

/*
 * Remove process p from its run queue, which should be the one
 * indicated by its priority.  Calls should be made at splstatclock().
 */
void
remrunqueue(vp)
	struct proc *vp;
{
	struct proc *p = vp;
	int which = p->p_priority >> 2;
	struct prochd *q;

	if ((whichqs & (1 << which)) == 0)
		panic("remrq %p", p);
	p->p_forw->p_back = p->p_back;
	p->p_back->p_forw = p->p_forw;
	p->p_back = NULL;
	q = &qs[which];
	if (q->ph_link == (struct proc *)q)
		whichqs &= ~(1 << which);
}

a1738 87
}

void
nmihand(void *framep)
{
#if 0
	struct trapframe *frame = framep;
#endif

#if DDB
	printf("Abort Pressed\n");
	Debugger();
#else
	printf("Spurious NMI?\n");
#endif /* DDB */
}

void
regdump(struct trapframe *f)
{
#define R(i) f->tf_r[i]
	printf("R00-05: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	       R(0),R(1),R(2),R(3),R(4),R(5));
	printf("R06-11: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	       R(6),R(7),R(8),R(9),R(10),R(11));
	printf("R12-17: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	       R(12),R(13),R(14),R(15),R(16),R(17));
	printf("R18-23: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	       R(18),R(19),R(20),R(21),R(22),R(23));
	printf("R24-29: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	       R(24),R(25),R(26),R(27),R(28),R(29));
	printf("R30-31: 0x%08x  0x%08x\n",R(30),R(31));
	if (cputyp == CPU_88110) {
		printf("exip %x enip %x\n", f->tf_exip, f->tf_enip);
	} else {
		printf("sxip %x snip %x sfip %x\n",
		    f->tf_sxip, f->tf_snip, f->tf_sfip);
	}
#ifdef M88100
	if (f->tf_vector == 0x3 && cputyp != CPU_88110) {
		/* print dmt stuff for data access fault */
		printf("dmt0 %x dmd0 %x dma0 %x\n",
		    f->tf_dmt0, f->tf_dmd0, f->tf_dma0);
		printf("dmt1 %x dmd1 %x dma1 %x\n",
		    f->tf_dmt1, f->tf_dmd1, f->tf_dma1);
		printf("dmt2 %x dmd2 %x dma2 %x\n",
		    f->tf_dmt2, f->tf_dmd2, f->tf_dma2);
		printf("fault type %d\n", (f->tf_dpfsr >> 16) & 0x7);
		dae_print((unsigned *)f);
	}
	if (longformat && cputyp != CPU_88110) {
		printf("fpsr %x fpcr %x epsr %x ssbr %x\n",
		    f->tf_fpsr, f->tf_fpcr, f->tf_epsr, f->tf_ssbr);
		printf("fpecr %x fphs1 %x fpls1 %x fphs2 %x fpls2 %x\n",
		    f->tf_fpecr, f->tf_fphs1, f->tf_fpls1,
		    f->tf_fphs2, f->tf_fpls2);
		printf("fppt %x fprh %x fprl %x fpit %x\n",
		    f->tf_fppt, f->tf_fprh, f->tf_fprl, f->tf_fpit);
		printf("vector %d mask %x mode %x scratch1 %x cpu %x\n",
		    f->tf_vector, f->tf_mask, f->tf_mode,
		    f->tf_scratch1, f->tf_cpu);
	}
#endif
#ifdef M88110
	if (longformat && cputyp == CPU_88110) {
		printf("fpsr %x fpcr %x fpecr %x epsr %x\n",
		    f->tf_fpsr, f->tf_fpcr, f->tf_fpecr, f->tf_epsr);
		printf("dsap %x duap %x dsr %x dlar %x dpar %x\n",
		    f->tf_dsap, f->tf_duap, f->tf_dsr, f->tf_dlar, f->tf_dpar);
		printf("isap %x iuap %x isr %x ilar %x ipar %x\n",
		    f->tf_isap, f->tf_iuap, f->tf_isr, f->tf_ilar, f->tf_ipar);
		printf("vector %d mask %x mode %x scratch1 %x cpu %x\n",
		    f->tf_vector, f->tf_mask, f->tf_mode,
		    f->tf_scratch1, f->tf_cpu);
	}
#endif
#ifdef MVME188
	if (brdtyp == BRD_188) {
		unsigned int istr, cur_mask;

		istr = *(int *volatile)IST_REG;
		cur_mask = GET_MASK(0, istr);
		printf("emask = 0x%b\n", f->tf_mask, IST_STRING);
		printf("istr  = 0x%b\n", istr, IST_STRING);
		printf("cmask = 0x%b\n", cur_mask, IST_STRING);
	}
#endif
@


1.155
log
@Use a simpler delay() routine for MVME188, from Mach via Luna88k
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.154 2004/08/02 14:38:42 miod Exp $	*/
a896 185
}

struct sigstate {
	int   ss_flags;	     /* which of the following are valid */
	struct   trapframe ss_frame;  /* original exception frame */
};

/*
 * WARNING: code in locore.s assumes the layout shown for sf_signo
 * through sf_handler so... don't screw with them!
 */
struct sigframe {
	int			sf_signo;	/* signo for handler */
	siginfo_t *		sf_sip;
	struct sigcontext *	sf_scp;		/* context ptr for handler */
	sig_t			sf_handler;	/* handler addr for u_sigc */
	struct sigcontext	sf_sc;		/* actual context */
	siginfo_t		sf_si;
};

#ifdef DEBUG
int sigdebug = 0;
int sigpid = 0;
   #define SDB_FOLLOW	0x01
   #define SDB_KSTACK	0x02
   #define SDB_FPSTATE	0x04
#endif

/*
 * Send an interrupt to process.
 */
void
sendsig(catcher, sig, mask, code, type, val)
	sig_t catcher;
	int sig, mask;
	unsigned long code;
	int type;
	union sigval val;
{
	struct proc *p = curproc;
	struct trapframe *tf;
	struct sigacts *psp = p->p_sigacts;
	struct sigframe *fp;
	int oonstack, fsize;
	struct sigframe sf;
	int addr;

	tf = p->p_md.md_tf;
	oonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
	/*
	 * Allocate and validate space for the signal handler
	 * context. Note that if the stack is in data space, the
	 * call to grow() is a nop, and the copyout()
	 * will fail if the process has not already allocated
	 * the space with a `brk'.
	 */
	fsize = sizeof(struct sigframe);
	if ((psp->ps_flags & SAS_ALTSTACK) &&
	    (psp->ps_sigstk.ss_flags & SS_ONSTACK) == 0 &&
	    (psp->ps_sigonstack & sigmask(sig))) {
		fp = (struct sigframe *)(psp->ps_sigstk.ss_sp +
					 psp->ps_sigstk.ss_size - fsize);
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
	} else
		fp = (struct sigframe *)(tf->tf_r[31] - fsize);

	/* make sure the frame is aligned on a 8 byte boundary */
	if (((vaddr_t)fp & 0x07) != 0)
		fp = (struct sigframe *)((vaddr_t)fp & ~0x07);

	if ((unsigned)fp <= USRSTACK - ctob(p->p_vmspace->vm_ssize))
		(void)uvm_grow(p, (unsigned)fp);

#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) ||
	    ((sigdebug & SDB_KSTACK) && (p->p_pid == sigpid)))
		printf("sendsig(%d): sig %d ssp %x usp %x scp %x\n",
		       p->p_pid, sig, &oonstack, fp, &fp->sf_sc);
#endif
	/*
	 * Build the signal context to be used by sigreturn.
	 */
	sf.sf_signo = sig;
	sf.sf_scp = &fp->sf_sc;
	sf.sf_handler = catcher;
	sf.sf_sc.sc_onstack = oonstack;
	sf.sf_sc.sc_mask = mask;

	if (psp->ps_siginfo & sigmask(sig)) {
		sf.sf_sip = &fp->sf_si;
		initsiginfo(&sf.sf_si, sig, code, type, val);
	}

	/*
	 * Copy the whole user context into signal context that we
	 * are building.
	 */
	bcopy((const void *)&tf->tf_regs, (void *)&sf.sf_sc.sc_regs,
	    sizeof(sf.sf_sc.sc_regs));

	if (copyout((caddr_t)&sf, (caddr_t)fp, sizeof sf)) {
		/*
		 * Process has trashed its stack; give it an illegal
		 * instruction to halt it in its tracks.
		 */
		sigexit(p, SIGILL);
		/* NOTREACHED */
	}
	/*
	 * Build the argument list for the signal handler.
	 * Signal trampoline code is at base of user stack.
	 */
	addr = p->p_sigcode;
	if (cputyp != CPU_88110) {
		/* mc88100 */
		tf->tf_snip = (addr & ~3) | NIP_V;
		tf->tf_sfip = (tf->tf_snip + 4) | FIP_V;
	} else {
		/* mc88110 */
		tf->tf_exip = (addr & ~3);
		tf->tf_enip = (tf->tf_exip + 4);
	}
	tf->tf_r[31] = (unsigned)fp;
#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) ||
	    ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid))
		printf("sendsig(%d): sig %d returns\n", p->p_pid, sig);
#endif
}

/*
 * System call to cleanup state after a signal
 * has been taken.  Reset signal mask and
 * stack state from context left by sendsig (above).
 * Return to previous pc and psl as specified by
 * context left by sendsig. Check carefully to
 * make sure that the user has not modified the
 * psl to gain improper privileges or to cause
 * a machine fault.
 */

/* ARGSUSED */
int
sys_sigreturn(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_sigreturn_args /* {
	   syscallarg(struct sigcontext *) sigcntxp;
	} */ *uap = v;
	struct sigcontext *scp;
	struct trapframe *tf;
	struct sigcontext ksc;

	scp = (struct sigcontext *)SCARG(uap, sigcntxp);
#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW)
		printf("sigreturn: pid %d, scp %x\n", p->p_pid, scp);
#endif
	if (((vaddr_t)scp & 3) != 0 ||
	    copyin((caddr_t)scp, (caddr_t)&ksc, sizeof(struct sigcontext)))
		return (EINVAL);

	tf = p->p_md.md_tf;
	scp = &ksc;

	/*
	 * this can be improved by doing
	 *	 bcopy(sc_reg to tf, sizeof sigcontext - 2 words)
	 * XXX nivas
	 */
	bcopy((const void *)&scp->sc_regs, (caddr_t)&tf->tf_regs,
	    sizeof(scp->sc_regs));

	/*
	 * Restore the user supplied information
	 */
	if (scp->sc_onstack & SS_ONSTACK)
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
	else
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
	p->p_sigmask = scp->sc_mask & ~sigcantmask;

	return (EJUSTRETURN);
@


1.154
log
@Fun with the BUG:
- add the board's suffix to the machine description if there is one;
- recognize BUG version < 5 on MVME188, which don't provide a CNFG block.
in this case we'll assume 20MHz for now, until we can parse the ENV data block
correctly...
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.153 2004/08/02 08:35:00 miod Exp $	*/
d236 6
a241 6
int boothowto;	/* set in locore.S */
int bootdev;	/* set in locore.S */
int cputyp;	/* set in locore.S */
int brdtyp;	/* set in locore.S */
int cpumod;	/* set in mvme_bootstrap() */
int cpuspeed;
@


1.153
log
@More include files cleaning:
- move MAX_CPUS constant to <machine/cpu.h>
- do not include <machine/board.h> unless needed. In fact, remove this file
  entirely on mvme88k, and include <machine/mvme*.h> on a
  compiling-for-this-board basis
- keep MAX_CMMUS constant private to the m8820x code
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.152 2004/07/30 20:48:40 miod Exp $	*/
d129 1
a129 1
int getcpuspeed(void);
d395 1
a395 1
getcpuspeed()
a396 1
	struct mvmeprom_brdid brdid;
d398 1
a398 3
	int i, c;

	bugbrdid(&brdid);
d401 1
a401 1
		c = (unsigned char)brdid.speed[i];
d423 13
a435 3
		if (speed == 20 || speed == 25)
			return speed;
		speed = 25;
d461 19
a479 1
	cpuspeed = getcpuspeed();
d481 1
a481 1
	    "Motorola MVME%x, %dMHz", brdtyp, cpuspeed);
@


1.152
log
@Put printf arguments in correct order in a DIAGNOSTIC message.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.151 2004/07/30 20:44:09 miod Exp $	*/
a73 1
#include <machine/board.h>
d85 10
a94 1
#include <machine/m88100.h>		/* DMT_VALID	*/
d362 1
@


1.151
log
@#if DIAGNOSTIC -> #ifdef DIAGNOSTIC
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.150 2004/07/30 19:28:22 miod Exp $	*/
d1467 1
a1467 1
			      intr->ih_ipl, vec, ihand->ih_ipl);
@


1.150
log
@I finally remembered the fast and smart way to know how much memory a
188 system has!
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.149 2004/07/30 19:02:08 miod Exp $	*/
d1453 1
a1453 1
#if DIAGNOSTIC
d1464 1
a1464 1
#if DIAGNOSTIC
@


1.149
log
@Move evcount structures inside struct intrhand, this makes more sense and
gives us more counters in the process.

Also clean up intrhand structures and usage, especially move them to SLISTs.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.148 2004/07/29 10:17:21 miod Exp $	*/
d120 1
d285 1
a285 1
 * Figure out how much memory is available, by querying the memory controllers
d305 32
a336 1
#if defined(MVME188) || defined(MVME197)
d383 1
a383 1
#endif	/* defined(MVME188) || defined(MVME197) */
a2257 1
#if defined(MVME188) || defined(MVME197)
d2260 2
a2264 1
#endif
@


1.148
log
@Better diagnostic message on MVME188 interrupt handler, when we are unable to
fetch the VMEbus interrupt vector in time.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.147 2004/07/28 12:28:48 miod Exp $	*/
d107 1
a107 1
struct intrhand *intr_handlers[256];
d679 1
a679 1
	 * zero out intr_handlers
d681 2
a682 1
	bzero((void *)intr_handlers, 256 * sizeof(struct intrhand *));
d1394 1
a1394 1
	if (start < 0 || end > 255 || start > end)
d1401 2
a1402 2
		if (intr_handlers[vec] == NULL)
			return (vec);
d1408 1
a1408 1
	return (-1);
d1415 1
a1415 1
intr_establish(int vec, struct intrhand *ihand)
d1418 1
d1420 1
a1420 1
	if (vec < 0 || vec > 255) {
d1428 3
a1430 3
	ihand->ih_next = NULL;

	if ((intr = intr_handlers[vec]) != NULL) {
d1439 1
d1441 3
a1443 6
		while (intr->ih_next)
			intr = intr->ih_next;
		intr->ih_next = ihand;
	} else
		intr_handlers[vec] = ihand;

d1477 1
d1584 2
a1585 1
		if ((intr = intr_handlers[vec]) == NULL) {
d1597 2
a1598 1
			for (ret = 0; intr; intr = intr->ih_next) {
a1603 1
					/* increment intr counter */
d1605 1
d1652 1
d1698 2
a1699 1
	if ((intr = intr_handlers[vec]) == NULL) {
d1706 2
a1707 1
		if (intr && intr->ih_ipl != level) {
d1720 3
a1722 2
		for (ret = 0; intr; intr = intr->ih_next) {
			if (intr->ih_wantframe != 0) {
d1724 1
a1724 1
			} else
a1726 1
				/* increment intr counter */
d1728 1
d1761 1
d1809 2
a1810 1
	if ((intr = intr_handlers[vec]) == NULL) {
d1817 2
a1818 1
		if (intr && intr->ih_ipl != level) {
d1831 2
a1832 1
		for (ret = 0; intr; intr = intr->ih_next) {
a1837 1
				/* increment intr counter */
d1839 1
@


1.147
log
@Remove EH_DEBUG code.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.146 2004/07/24 15:05:07 miod Exp $	*/
a104 7
#include <ddb/db_output.h>		/* db_printf()		*/
#endif /* DDB */

#if DDB
#define DEBUG_MSG db_printf
#else
#define DEBUG_MSG printf
d1522 1
a1522 1
		if (level > 7 || (char)level < 0) {
d1569 2
a1570 1
				printf("vme vec timeout");
d2042 1
a2042 1
	DEBUG_MSG("Abort Pressed\n");
d2045 1
a2045 1
	DEBUG_MSG("Spurious NMI?\n");
@


1.146
log
@intr_establish() and related defines are mvme88k-only, so move them back from
<m88k/cpu.h>, and simplify the return values while there.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.145 2004/07/23 22:19:09 miod Exp $	*/
a2038 23

#ifdef EH_DEBUG

void
MY_info(f, p, flags, s)
	struct trapframe  *f;
	caddr_t     p;
	int         flags;
	char        *s;
{
	regdump(f);
	printf("proc %x flags %x type %s\n", p, flags, s);
}

void
MY_info_done(f, flags)
	struct trapframe  *f;
	int         flags;
{
	regdump(f);
}

#endif
@


1.145
log
@Eventually get the MVME188 reset sequence to work, and allow it to return
to the BUG instead of spinning if our reset fails.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.144 2004/06/23 03:58:30 miod Exp $	*/
d1418 1
a1418 3
 * Insert ihand in the list of handlers at vector vec.
 * Return return different error codes for the different
 * errors and let the caller decide what to do.
d1430 1
a1430 1
		return (INTR_EST_BADVEC);
d1433 2
d1442 1
a1442 1
			return (INTR_EST_BADIPL);
a1444 3
		/*
		 * Go to the end of the chain
		 */
a1446 5
	}

	ihand->ih_next = 0;

	if (intr)
d1448 1
a1448 1
	else
d1451 1
a1451 1
	return (INTR_EST_SUCC);
@


1.144
log
@Remove useless debug code.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.143 2004/06/23 00:30:36 miod Exp $	*/
d1085 1
a1085 1
__dead void
d1095 4
a1098 1
	if ((*(volatile u_int8_t *)GLB1) & M188_SYSCONNEG) {
a1100 3
	} else {
		/* Force a complete VMEbus reset */
		*(volatile u_int32_t *)GLBRES_REG = 1;
a1108 2
	for (;;);
	/* NOTREACHED */
@


1.143
log
@Since the NMI interrupt source on 88110 is, well, non maskable, it is
possible to receive it during autoconf.

In this case, do not enable _other_ interrupts while we are servicing it.

Note that, on the MVME197, since we are using the BUG for console output
during autoconf, it is still possible to abort the bootstrap and return
to the BUG with the NMI/ABORT switch.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.142 2004/05/06 18:32:08 miod Exp $	*/
a829 3
#ifdef DEBUG
		printf("exec @@ 0x%x\n", tf->tf_exip);
#endif
@


1.142
log
@When the NVRAM is toast and we have to guess the CPU speed, choose a safer
value depending upon the board type.

This really only affects on-board SCSI on 1x7 anyway.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.141 2004/04/24 19:51:49 miod Exp $	*/
d1813 3
a1815 2
	/* block interrupts at level or lower */
	setipl(level);
d1817 2
a1818 1
	enable_interrupt();
d1858 2
a1859 1
	disable_interrupt();
d1861 6
a1866 5
	/*
	 * Restore the mask level to what it was when the interrupt
	 * was taken.
	 */
	setipl(mask);
@


1.141
log
@Preliminary switch to an mvme88k bus_space world. Not all drivers have been
converted yet, and they rely upon some linear mappings provided by bus_space.

In order to not impact performance, almost all the bus_space accesses go
through macros and inline functions. This currently restricts us to D16 and
D32 access modes, which are selected at compilation time. Since there are no
plans to support D8 vme devices in the future, this is acceptable for now.

This makes the "len" locator for vme devices go away, and allows to simplify
some code which was using the pcctwo device, and will now directly access
hardware which is known to exist, rather than wait until the device is
attached.

While there, try to enforce more interrupt vector number checks, since these
changes pointed out that dart(4) had been working correctly so far by sheer
luck only.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.140 2004/04/16 23:35:53 miod Exp $	*/
d373 4
a376 2
		else if (c > '9' || c < '0')
			goto fail;
a379 1
	return (speed);
d381 25
a405 1
fail:
d407 4
a410 3
	 * If we end up here, the board information block is
	 * damaged and we can't trust it.
	 * Suppose we are running at 25MHz and hope for the best.
d414 1
a414 1
	return (25);
@


1.140
log
@When a VMEBus device needs to use two interrupt vectors, be nice and let it
actually use two distinct vectors, rather than twice the same.

Because of this, print vector last in vmeprint() so that dmesg remains pretty
in the multi-vector case.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.139 2004/04/15 21:35:07 miod Exp $	*/
d1067 4
a1070 4
	*sys_syscon->ien0 = 0;
	*sys_syscon->ien1 = 0;
	*sys_syscon->ien2 = 0;
	*sys_syscon->ien3 = 0;
d1072 1
a1072 1
	if (*sys_syscon->global1 & M188_SYSCONNEG) {
d1074 1
a1074 1
		*sys_syscon->global1 |= M188_LRST;
d1077 1
a1077 1
		*sys_syscon->glbres = 1;
d1080 1
a1080 1
	*sys_syscon->ucsr |= 0x2000; /* clear SYSFAIL* */
d1083 1
a1083 1
	*sys_syscon->ucsr |= 0x2000; /* clear SYSFAIL* */
d1086 1
a1086 1
	for (;;);	/* just in case we survived... */
d1417 2
a1418 1
			panic("intr_establish: there are other handlers with vec (0x%x) at ipl %x, but you want it at %x",
d1453 1
a1453 2

unsigned obio_vec[32] = {
d1544 1
a1544 1
			vec = obio_vec[intbit];
d1550 1
a1550 1
			vec = obio_vec[intbit];
@


1.139
log
@Remove more dead code.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.138 2004/04/14 23:06:57 miod Exp $	*/
d1374 1
a1374 2
intr_findvec(start, end)
	int start, end;
a1378 1
	/* Sanity check! */
d1383 3
a1385 1
	for (vec = start; vec < end; vec++){
d1390 2
a1391 1
	printf("intr_findvec(%d,%d): no vector available\n", start, end);
@


1.138
log
@If resetting a MVME188 which is not system controller, only trigger a local
reset.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.137 2004/04/14 13:43:48 miod Exp $	*/
a1895 32
}

/*
 * insert an element into a queue
 */

void
_insque(velement, vhead)
	void *velement, *vhead;
{
	struct prochd *element, *head;
	element = velement;
	head = vhead;
	element->ph_link = head->ph_link;
	head->ph_link = (struct proc *)element;
	element->ph_rlink = (struct proc *)head;
	((struct prochd *)(element->ph_link))->ph_rlink=(struct proc *)element;
}

/*
 * remove an element from a queue
 */

void
_remque(velement)
	void *velement;
{
	struct prochd *element;
	element = velement;
	((struct prochd *)(element->ph_link))->ph_rlink = element->ph_rlink;
	((struct prochd *)(element->ph_rlink))->ph_link = element->ph_link;
	element->ph_rlink = (struct proc *)0;
@


1.137
log
@Simplify pmap_bootstrap() interface.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.136 2004/03/10 23:02:54 tom Exp $	*/
d1057 1
a1057 1
	for (;;);  /* to keep compiler happy, and me from going crazy */
d1062 1
a1062 1
void
d1071 9
a1079 1
	*sys_syscon->glbres = 1;  /* system reset */
d1084 4
@


1.136
log
@Ensure that we obey a user's ddb> boot reboot command even if the system
is cold (during startup).

This adds RB_USERREQ to sys/reboot.h, uses it in the ddb commands, and
ensures that */*/machdep.c:boot() won't set RB_HALT when cold if this
flag is set.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.135 2004/02/19 15:33:53 miod Exp $	*/
d2303 2
a2304 3
	pmap_bootstrap((vaddr_t)trunc_page((unsigned)&kernelstart) /* = loadpt */,
		       &avail_start, &avail_end, &virtual_avail,
		       &virtual_end);
d2310 1
a2310 1
			  atop(avail_start), atop(avail_end),VM_FREELIST_DEFAULT);
@


1.135
log
@When copyout() of the signal frame fails, sigexit() the process instead of
doing this by an hand-delivered SIGILL.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.134 2004/02/11 20:41:08 miod Exp $	*/
d1020 3
a1022 1
		howto |= RB_HALT;
@


1.134
log
@Keep using the BUG as the console device until autoconf is over, rather
than switching early.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.133 2004/01/14 11:49:49 miod Exp $	*/
d919 2
a920 7
		SIGACTION(p, SIGILL) = SIG_DFL;
		sig = sigmask(SIGILL);
		p->p_sigignore &= ~sig;
		p->p_sigcatch &= ~sig;
		p->p_sigmask &= ~sig;
		psignal(p, SIGILL);
		return;
@


1.133
log
@Remove as many unnecessary includes from the include mess in this file, in
the vain hope to save some compilation time.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.132 2004/01/13 21:27:05 miod Exp $	*/
d251 4
a254 2
 *  XXX this is to fake out the console routines, while
 *  booting. New and improved! :-) smurph
d271 3
a273 3
 * Console initialization: called early on from main,
 * before vm init or startup.  Do enough configuration
 * to choose and initialize a console.
a277 1
	extern struct consdev *cn_tab;
d279 1
a279 5
	/*
	 * Initialize the console before we print anything out.
	 */
	cn_tab = NULL;
	cninit();
@


1.132
log
@Get rid of old MID binary compatibility. This has been a lifesaver back when
the toolchain was in limbo, but now that we have a solid enough in-tree
toolchain, this makes no sense. Plus the libc back then was full of bugs...
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.131 2004/01/13 17:15:08 miod Exp $	*/
a55 2
#include <sys/file.h>
#include <sys/timeout.h>
a56 1
#include <sys/mbuf.h>
a62 1
#include <sys/ioctl.h>
d93 1
d95 2
a96 1
#include <mvme88k/dev/pcctworeg.h>
d98 1
@


1.131
log
@During signal delivery, force the sigframe to be on an 8 byte boundary.
This removes the need for extra padding in struct sigcontext.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.130 2004/01/12 23:55:12 miod Exp $	*/
a1838 24
#ifdef COMPAT_25
	/*
	 * Keep compatibility with older OpenBSD/mvme88k binaries
	 * for a while, to make transition easier.
	 */
	u_long midmag, magic;
	u_short mid;
	struct exec *execp = epp->ep_hdr;

	midmag = ntohl(execp->a_midmag);
	mid = (midmag >> 16) & 0x3ff;
	magic = midmag & 0xffff;

	midmag = mid << 16 | magic;

	switch (midmag) {
	case (OLD_MID_MACHINE << 16) | ZMAGIC:
		return exec_aout_prep_zmagic(p, epp);
	case (OLD_MID_MACHINE << 16) | NMAGIC:
		return exec_aout_prep_nmagic(p, epp);
	case (OLD_MID_MACHINE << 16) | OMAGIC:
		return exec_aout_prep_omagic(p, epp);
	}
#endif
d1840 1
a1840 1
	return ENOEXEC;
@


1.130
log
@Use a struct reg in struct sigcontext, rather than an unsorted pot-pourri
of registers. This also makes signal and sigreturn much simpler.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.129 2004/01/12 17:30:26 miod Exp $	*/
d883 5
@


1.129
log
@Nuke a few unused structures and variables.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.128 2004/01/12 07:46:17 miod Exp $	*/
d910 2
a911 57
	bcopy((caddr_t)tf->tf_r, (caddr_t)sf.sf_sc.sc_regs,
	      sizeof(sf.sf_sc.sc_regs));

	/*
	 * Be sure to keep the xip values intact, especially on 88100: should
	 * we return back to the process, it must be in the same instruction
	 * fetching state, or bad things will happen...
	 */
	if (cputyp != CPU_88110) {
		/* mc88100 */
		sf.sf_sc.sc_xip = tf->tf_sxip;
		sf.sf_sc.sc_nip = tf->tf_snip;
		sf.sf_sc.sc_fip = tf->tf_sfip;
	} else {
		/* mc88110 */
		sf.sf_sc.sc_xip = tf->tf_exip;
		sf.sf_sc.sc_nip = tf->tf_enip;
		sf.sf_sc.sc_fip = 0;
	}
	sf.sf_sc.sc_ps = tf->tf_epsr;
	sf.sf_sc.sc_sp  = tf->tf_r[31];
	sf.sf_sc.sc_fpsr = tf->tf_fpsr;
	sf.sf_sc.sc_fpcr = tf->tf_fpcr;
	if (cputyp != CPU_88110) {
		/* mc88100 */
		sf.sf_sc.sc_ssbr = tf->tf_ssbr;
		sf.sf_sc.sc_dmt0 = tf->tf_dmt0;
		sf.sf_sc.sc_dmd0 = tf->tf_dmd0;
		sf.sf_sc.sc_dma0 = tf->tf_dma0;
		sf.sf_sc.sc_dmt1 = tf->tf_dmt1;
		sf.sf_sc.sc_dmd1 = tf->tf_dmd1;
		sf.sf_sc.sc_dma1 = tf->tf_dma1;
		sf.sf_sc.sc_dmt2 = tf->tf_dmt2;
		sf.sf_sc.sc_dmd2 = tf->tf_dmd2;
		sf.sf_sc.sc_dma2 = tf->tf_dma2;
	} else {
		/* mc88110 */
		sf.sf_sc.sc_dsr  = tf->tf_dsr;
		sf.sf_sc.sc_dlar = tf->tf_dlar;
		sf.sf_sc.sc_dpar = tf->tf_dpar;
		sf.sf_sc.sc_isr  = tf->tf_isr;
		sf.sf_sc.sc_ilar = tf->tf_ilar;
		sf.sf_sc.sc_ipar = tf->tf_ipar;
		sf.sf_sc.sc_isap = tf->tf_isap;
		sf.sf_sc.sc_dsap = tf->tf_dsap;
		sf.sf_sc.sc_iuap = tf->tf_iuap;
		sf.sf_sc.sc_duap = tf->tf_duap;
	}
	sf.sf_sc.sc_fpecr = tf->tf_fpecr;
	sf.sf_sc.sc_fphs1 = tf->tf_fphs1;
	sf.sf_sc.sc_fpls1 = tf->tf_fpls1;
	sf.sf_sc.sc_fphs2 = tf->tf_fphs2;
	sf.sf_sc.sc_fpls2 = tf->tf_fpls2;
	sf.sf_sc.sc_fppt = tf->tf_fppt;
	sf.sf_sc.sc_fprh = tf->tf_fprh;
	sf.sf_sc.sc_fprl = tf->tf_fprl;
	sf.sf_sc.sc_fpit = tf->tf_fpit;
d978 1
a978 1
	if ((int)scp & 3 ||
d990 2
a991 50
	bcopy((caddr_t)scp->sc_regs, (caddr_t)tf->tf_r, sizeof(scp->sc_regs));
	if (cputyp != CPU_88110) {
		/* mc88100 */
		tf->tf_sxip = scp->sc_xip;
		tf->tf_snip = scp->sc_nip;
		tf->tf_sfip = scp->sc_fip;
	} else {
		/* mc88110 */
		tf->tf_exip = scp->sc_xip;
		tf->tf_enip = scp->sc_nip;
		tf->tf_sfip = 0;
	}
	tf->tf_epsr = scp->sc_ps;
	tf->tf_r[31] = scp->sc_sp;
	tf->tf_fpsr = scp->sc_fpsr;
	tf->tf_fpcr = scp->sc_fpcr;
	if (cputyp != CPU_88110) {
		/* mc88100 */
		tf->tf_ssbr = scp->sc_ssbr;
		tf->tf_dmt0 = scp->sc_dmt0;
		tf->tf_dmd0 = scp->sc_dmd0;
		tf->tf_dma0 = scp->sc_dma0;
		tf->tf_dmt1 = scp->sc_dmt1;
		tf->tf_dmd1 = scp->sc_dmd1;
		tf->tf_dma1 = scp->sc_dma1;
		tf->tf_dmt2 = scp->sc_dmt2;
		tf->tf_dmd2 = scp->sc_dmd2;
		tf->tf_dma2 = scp->sc_dma2;
	} else {
		/* mc88110 */
		tf->tf_dsr  = scp->sc_dsr;
		tf->tf_dlar = scp->sc_dlar;
		tf->tf_dpar = scp->sc_dpar;
		tf->tf_isr  = scp->sc_isr;
		tf->tf_ilar = scp->sc_ilar;
		tf->tf_ipar = scp->sc_ipar;
		tf->tf_isap = scp->sc_isap;
		tf->tf_dsap = scp->sc_dsap;
		tf->tf_iuap = scp->sc_iuap;
		tf->tf_duap = scp->sc_duap;
	}
	tf->tf_fpecr = scp->sc_fpecr;
	tf->tf_fphs1 = scp->sc_fphs1;
	tf->tf_fpls1 = scp->sc_fpls1;
	tf->tf_fphs2 = scp->sc_fphs2;
	tf->tf_fpls2 = scp->sc_fpls2;
	tf->tf_fppt = scp->sc_fppt;
	tf->tf_fprh = scp->sc_fprh;
	tf->tf_fprl = scp->sc_fprl;
	tf->tf_fpit = scp->sc_fpit;
d1001 1
@


1.128
log
@Get rid of that ugly m88100_saved_state structure, use trapframe everywhere
instead.

Allow struct reg and struct trapframe to live different lives and grow
separately. Righty now they are still the same, and code expects a trapframe
to always start with a struct reg. This may change...
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.127 2004/01/05 20:07:03 miod Exp $	*/
a230 13
struct bugenv bugargs;

struct kernel {
	void *entry;
	void *symtab;
	void *esym;
	int   bflags;
	int   bdev;
	char *kname;
	void *smini;
	void *emini;
	void *end_load;
}kflags;
d827 1
a827 1
 * thru sf_handler so... don't screw with them!
d830 6
a835 6
	int   sf_signo;	     /* signo for handler */
	siginfo_t *sf_sip;
	struct   sigcontext *sf_scp;  /* context ptr for handler */
	sig_t sf_handler;    /* handler addr for u_sigc */
	struct   sigcontext sf_sc; /* actual context */
	siginfo_t sf_si;
@


1.127
log
@Stop masquerading the M8120 (no-slot MVME187) as a real MVME187, and keep
its value in brdtyp.

Compensate by checking for BRD_8120 everywhere BRD_187 was checked.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.126 2004/01/04 01:43:16 miod Exp $	*/
d133 3
a135 3
void m187_ext_int(u_int v, struct m88100_saved_state *eframe);
void m188_ext_int(u_int v, struct m88100_saved_state *eframe);
void m197_ext_int(u_int v, struct m88100_saved_state *eframe);
d763 1
a763 1
	struct trapframe *tf = USER_REGS(p);
d799 1
a799 1
		tf->epsr = PSR_SRM | PSR_SFD;
d803 1
a803 1
		tf->epsr |= PSR_SER;
d809 1
a809 1
		tf->epsr = PSR_SFD | PSR_SFD2;
d820 1
a820 1
		tf->exip = pack->ep_entry & ~3;
d822 1
a822 1
		printf("exec @@ 0x%x\n", tf->exip);
d825 2
a826 2
		tf->snip = pack->ep_entry & ~3;
		tf->sfip = (pack->ep_entry & ~3) | FIP_V;
d828 2
a829 2
	tf->r[2] = stack;
	tf->r[31] = stack;
d895 1
a895 1
		fp = (struct sigframe *)(tf->r[31] - fsize);
d923 1
a923 1
	bcopy((caddr_t)tf->r, (caddr_t)sf.sf_sc.sc_regs,
d933 3
a935 3
		sf.sf_sc.sc_xip = tf->sxip;
		sf.sf_sc.sc_nip = tf->snip;
		sf.sf_sc.sc_fip = tf->sfip;
d938 2
a939 2
		sf.sf_sc.sc_xip = tf->exip;
		sf.sf_sc.sc_nip = tf->enip;
d942 4
a945 4
	sf.sf_sc.sc_ps = tf->epsr;
	sf.sf_sc.sc_sp  = tf->r[31];
	sf.sf_sc.sc_fpsr = tf->fpsr;
	sf.sf_sc.sc_fpcr = tf->fpcr;
d948 10
a957 10
		sf.sf_sc.sc_ssbr = tf->ssbr;
		sf.sf_sc.sc_dmt0 = tf->dmt0;
		sf.sf_sc.sc_dmd0 = tf->dmd0;
		sf.sf_sc.sc_dma0 = tf->dma0;
		sf.sf_sc.sc_dmt1 = tf->dmt1;
		sf.sf_sc.sc_dmd1 = tf->dmd1;
		sf.sf_sc.sc_dma1 = tf->dma1;
		sf.sf_sc.sc_dmt2 = tf->dmt2;
		sf.sf_sc.sc_dmd2 = tf->dmd2;
		sf.sf_sc.sc_dma2 = tf->dma2;
d960 20
a979 20
		sf.sf_sc.sc_dsr  = tf->dsr;
		sf.sf_sc.sc_dlar = tf->dlar;
		sf.sf_sc.sc_dpar = tf->dpar;
		sf.sf_sc.sc_isr  = tf->isr;
		sf.sf_sc.sc_ilar = tf->ilar;
		sf.sf_sc.sc_ipar = tf->ipar;
		sf.sf_sc.sc_isap = tf->isap;
		sf.sf_sc.sc_dsap = tf->dsap;
		sf.sf_sc.sc_iuap = tf->iuap;
		sf.sf_sc.sc_duap = tf->duap;
	}
	sf.sf_sc.sc_fpecr = tf->fpecr;
	sf.sf_sc.sc_fphs1 = tf->fphs1;
	sf.sf_sc.sc_fpls1 = tf->fpls1;
	sf.sf_sc.sc_fphs2 = tf->fphs2;
	sf.sf_sc.sc_fpls2 = tf->fpls2;
	sf.sf_sc.sc_fppt = tf->fppt;
	sf.sf_sc.sc_fprh = tf->fprh;
	sf.sf_sc.sc_fprl = tf->fprl;
	sf.sf_sc.sc_fpit = tf->fpit;
d1001 2
a1002 2
		tf->snip = (addr & ~3) | NIP_V;
		tf->sfip = (tf->snip + 4) | FIP_V;
d1005 2
a1006 2
		tf->exip = (addr & ~3);
		tf->enip = (tf->exip + 4);
d1008 1
a1008 1
	tf->r[31] = (unsigned)fp;
d1058 1
a1058 1
	bcopy((caddr_t)scp->sc_regs, (caddr_t)tf->r, sizeof(scp->sc_regs));
d1061 3
a1063 3
		tf->sxip = scp->sc_xip;
		tf->snip = scp->sc_nip;
		tf->sfip = scp->sc_fip;
d1066 8
a1073 8
		tf->exip = scp->sc_xip;
		tf->enip = scp->sc_nip;
		tf->sfip = 0;
	}
	tf->epsr = scp->sc_ps;
	tf->r[31] = scp->sc_sp;
	tf->fpsr = scp->sc_fpsr;
	tf->fpcr = scp->sc_fpcr;
d1076 10
a1085 10
		tf->ssbr = scp->sc_ssbr;
		tf->dmt0 = scp->sc_dmt0;
		tf->dmd0 = scp->sc_dmd0;
		tf->dma0 = scp->sc_dma0;
		tf->dmt1 = scp->sc_dmt1;
		tf->dmd1 = scp->sc_dmd1;
		tf->dma1 = scp->sc_dma1;
		tf->dmt2 = scp->sc_dmt2;
		tf->dmd2 = scp->sc_dmd2;
		tf->dma2 = scp->sc_dma2;
d1088 20
a1107 20
		tf->dsr  = scp->sc_dsr;
		tf->dlar = scp->sc_dlar;
		tf->dpar = scp->sc_dpar;
		tf->isr  = scp->sc_isr;
		tf->ilar = scp->sc_ilar;
		tf->ipar = scp->sc_ipar;
		tf->isap = scp->sc_isap;
		tf->dsap = scp->sc_dsap;
		tf->iuap = scp->sc_iuap;
		tf->duap = scp->sc_duap;
	}
	tf->fpecr = scp->sc_fpecr;
	tf->fphs1 = scp->sc_fphs1;
	tf->fpls1 = scp->sc_fpls1;
	tf->fphs2 = scp->sc_fphs2;
	tf->fpls2 = scp->sc_fpls2;
	tf->fppt = scp->sc_fppt;
	tf->fprh = scp->sc_fprh;
	tf->fprl = scp->sc_fprl;
	tf->fpit = scp->sc_fpit;
d1569 1
a1569 1
m188_ext_int(u_int v, struct m88100_saved_state *eframe)
d1580 1
a1580 1
	eframe->mask = old_spl;
d1719 1
a1719 1
	if (eframe->dmt0 & DMT_VALID)
d1726 1
a1726 1
	setipl(eframe->mask);
d1742 1
a1742 1
m187_ext_int(u_int v, struct m88100_saved_state *eframe)
d1834 1
a1834 1
	if (eframe->dmt0 & DMT_VALID)
d1847 1
a1847 1
m197_ext_int(u_int v, struct m88100_saved_state *eframe)
d2210 1
a2210 1
	struct m88100_saved_state *frame = framep;
d2224 1
a2224 1
#define R(i) f->r[i]
d2237 1
a2237 1
		printf("exip %x enip %x\n", f->exip, f->enip);
d2239 2
a2240 1
		printf("sxip %x snip %x sfip %x\n", f->sxip, f->snip, f->sfip);
d2243 1
a2243 1
	if (f->vector == 0x3 && cputyp != CPU_88110) {
d2245 7
a2251 4
		printf("dmt0 %x dmd0 %x dma0 %x\n", f->dmt0, f->dmd0, f->dma0);
		printf("dmt1 %x dmd1 %x dma1 %x\n", f->dmt1, f->dmd1, f->dma1);
		printf("dmt2 %x dmd2 %x dma2 %x\n", f->dmt2, f->dmd2, f->dma2);
		printf("fault type %d\n", (f->dpfsr >> 16) & 0x7);
d2256 1
a2256 1
		       f->fpsr, f->fpcr, f->epsr, f->ssbr);
d2258 2
a2259 1
		       f->fpecr, f->fphs1, f->fpls1, f->fphs2, f->fpls2);
d2261 1
a2261 1
		       f->fppt, f->fprh, f->fprl, f->fpit);
d2263 2
a2264 1
		       f->vector, f->mask, f->mode, f->scratch1, f->cpu);
d2270 1
a2270 1
		       f->fpsr, f->fpcr, f->fpecr, f->epsr);
d2272 1
a2272 1
		       f->dsap, f->duap, f->dsr, f->dlar, f->dpar);
d2274 1
a2274 1
		       f->isap, f->iuap, f->isr, f->ilar, f->ipar);
d2276 2
a2277 1
		       f->vector, f->mask, f->mode, f->scratch1, f->cpu);
d2286 1
a2286 1
		printf("emask = 0x%b\n", f->mask, IST_STRING);
@


1.126
log
@Thou shall not flush TLBs incorrectly.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.125 2004/01/02 23:40:57 miod Exp $	*/
d522 1
d1378 1
a2322 6
	/* to support the M8120.  It's based off of MVME187 */
	if (brdtyp == BRD_8120) {
		brdtyp = BRD_187;
		/* XXX Need to flag the 8120 has a second cl(4) device on-board */
	}

d2344 1
d2376 1
@


1.125
log
@Sync m197_ext_int() logic with m187_ext_int() logic.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.124 2004/01/02 17:08:57 miod Exp $	*/
d443 1
a443 1
	cmmu_flush_tlb(cpu_number(), 1, va, USPACE);
@


1.124
log
@When both cmmu_dofoo() and cmmu_remote_dofoo() exist, kill the first one,
and rename the second one to the first one, i.e. have the cmmu_dofoo()
functions always take a cpu# parameter.

No functional change, simply makes code more readable and saves a few
call frames.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.123 2003/12/22 23:29:33 miod Exp $	*/
d1865 1
d1874 1
a1874 5

	/* and block interrupts at level or lower */
	setipl(level);
	/* and stash it away in the trap frame */
	eframe->mask = mask;
d1889 3
d1900 1
d1906 1
d1913 1
d1938 1
a1938 1
	setipl(eframe->mask);
d1940 1
a1940 1
#endif
@


1.123
log
@Do not play games with the instruction fetch pointers when preserving a
process state in sendsig(), for it must be restored in the exact same fetching
state by sigreturn().

mvme88k now passes the sigreturn regression test.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.122 2003/12/19 22:30:18 miod Exp $	*/
d443 1
a443 1
	cmmu_flush_tlb(1, va, USPACE);
@


1.122
log
@Pass -Wformat, and silence a few vme* debug printf.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.121 2003/12/11 18:12:19 miod Exp $	*/
d924 6
d932 3
a934 3
		sf.sf_sc.sc_xip = tf->sxip & ~3;
		sf.sf_sc.sc_nip = tf->snip & ~3;
		sf.sf_sc.sc_fip = tf->sfip & ~3;
d937 2
a938 2
		sf.sf_sc.sc_xip = tf->exip & ~3;
		sf.sf_sc.sc_nip = tf->enip & ~3;
d979 1
d1051 1
a1051 15
	/*
	 * xip, nip and fip must be multiples of 4.  This is all
	 * that is required; if it holds, just do it.
	 */
#if 0
	if (((scp->sc_xip | scp->sc_nip | scp->sc_fip) & 3) != 0)
		return (EINVAL);
#endif /* 0 */
#if DIAGNOSTIC
	if (((scp->sc_xip | scp->sc_nip | scp->sc_fip) & 3) != 0){
		printf("xip %x nip %x fip %x\n",
		       scp->sc_xip, scp->sc_nip, scp->sc_fip);
		return (EINVAL);
	}
#endif
d1060 3
a1062 3
		tf->sxip = (scp->sc_xip) | XIP_V;
		tf->snip = (scp->sc_nip) | NIP_V;
		tf->sfip = (scp->sc_fip) | FIP_V;
d1065 2
a1066 2
		tf->exip = (scp->sc_xip);
		tf->enip = (scp->sc_nip);
d1111 1
a1111 1
	if (scp->sc_onstack & 01)
@


1.121
log
@Oops, forgot to commit this chunk of pcb_t removal. Spotted by deraadt.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.120 2003/11/09 00:32:03 miod Exp $	*/
d514 1
a514 1
		panic("uarea_pages %x: UADDR not free", uarea_pages);
d531 1
a531 1
			panic("sramva %x: SRAM not free", sramva);
d542 1
a542 1
			panic("bugromva %x: BUGROM not free", bugromva);
d553 1
a553 1
			panic("obiova %x: OBIO not free", obiova);
d567 1
a567 1
			panic("flashva %x: FLASH not free", flashva);
d578 1
a578 1
			panic("obiova %x: OBIO not free", obiova);
d592 1
a592 1
			panic("utilva %x: UTILITY area not free", utilva);
d666 1
a666 1
	printf("avail mem = %ld (%ld pages)\n", ptoa(uvmexp.free), uvmexp.free);
d1489 1
a1489 1
#ifdef DIAGNOSTIC
d1492 1
a1492 1
		panic("intr_findvec(): bad parameters");
d1500 1
a1500 1
	printf("intr_findvec(): uh oh....\n", vec);
d2096 1
a2096 1
		panic("setrunqueue %x", p);
d2118 1
a2118 1
		panic("remrq %x", p);
@


1.120
log
@Typos; Jonathan Gray
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.119 2003/11/06 21:09:35 mickey Exp $	*/
d261 1
a261 1
pcb_t    curpcb;
@


1.119
log
@move netisr definition into md code to allow arch provide suitable allocation; tested on most archs
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.118 2003/10/24 17:44:51 miod Exp $	*/
d118 1
a118 1
/* machine dependant function pointers. */
d517 1
a517 1
	 * Grab machine dependant memory spaces
d2318 1
a2318 1
	/* zero out the machine dependant function pointers */
@


1.118
log
@No \n in panic() messages...
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.117 2003/10/09 16:30:58 miod Exp $	*/
d2143 2
@


1.117
log
@Minor cpp changes to let all kernels in conf/ compile.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.116 2003/10/05 20:27:47 miod Exp $	*/
d514 1
a514 1
		panic("uarea_pages %x: UADDR not free\n", uarea_pages);
d531 1
a531 1
			panic("sramva %x: SRAM not free\n", sramva);
d542 1
a542 1
			panic("bugromva %x: BUGROM not free\n", bugromva);
d553 1
a553 1
			panic("obiova %x: OBIO not free\n", obiova);
d567 1
a567 1
			panic("flashva %x: FLASH not free\n", flashva);
d578 1
a578 1
			panic("obiova %x: OBIO not free\n", obiova);
d592 1
a592 1
			panic("utilva %x: UTILITY area not free\n", utilva);
@


1.116
log
@Kill vm_offset_t and vm_size_t, in favor of the [pv]addr_t and [pv]size_t
typedefs.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.115 2003/10/02 10:19:11 miod Exp $	*/
d2296 1
d2298 2
d2301 1
@


1.115
log
@Ack external interrupts before reenabling them on 187.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.114 2003/09/28 22:13:45 miod Exp $	*/
d91 1
a91 1
#endif 
d116 1
a116 1
vm_offset_t interrupt_stack[MAX_CPUS];
d126 2
a127 2
vm_offset_t size_memory(void);
vm_offset_t memsize187(void);
d130 1
a130 1
void save_u_area(struct proc *, vm_offset_t);
d160 1
a160 1
#endif 
d163 1
a163 1
volatile vm_offset_t obiova;
d165 2
a166 2
volatile vm_offset_t bugromva;
volatile vm_offset_t sramva;
d169 1
a169 1
volatile vm_offset_t flashva;
d173 1
a173 1
volatile vm_offset_t utilva;
d255 2
a256 2
vm_offset_t first_addr = 0;
vm_offset_t last_addr = 0;
d258 2
a259 2
vm_offset_t avail_start, avail_end;
vm_offset_t virtual_avail, virtual_end;
d264 2
a265 2
/* 
 *  XXX this is to fake out the console routines, while 
d268 1
a268 6
void bootcnprobe(struct consdev *);
void bootcninit(struct consdev *);
void bootcnputc(dev_t, int);
int  bootcngetc(dev_t);
extern void nullcnpollc(dev_t, int);

d272 3
a274 3
	NULL, 
	NULL, 
	bootcngetc, 
d311 1
a311 1
vm_offset_t
d315 1
a315 1
	vm_offset_t x;
d317 1
a317 1
	memc = (struct memcreg *)0xfff43000;
d320 2
a321 2
	memc = (struct memcreg *)0xfff43100;
	if (!badaddr((vm_offset_t)&memc->memc_memconf, 1))
d334 1
a334 1
vm_offset_t
d372 1
a372 1
	
d421 1
a421 1
save_u_area(struct proc *p, vm_offset_t va)
d423 5
a427 3
	int i; 
	for (i=0; i<UPAGES; i++) {
		p->p_md.md_upte[i] = *((pt_entry_t *)kvtopte((va + (i * NBPG))));
d434 2
d438 2
a439 3
	int i; 
	for (i=0; i<UPAGES; i++) {
		t = kvtopte((UADDR + (i * NBPG)));
d441 1
d443 1
a443 3
	for (i=0; i<UPAGES; i++) {
		cmmu_flush_tlb(1, (UADDR + (i * NBPG)), NBPG);
	}
d450 1
a450 1
void 
a452 3
#ifdef DEBUG
	printf("cpu_initclocks(): ");
#endif 
a453 3
#ifdef DEBUG
		printf("[interval clock] ");
#endif 
a456 3
#ifdef DEBUG
		printf("[statistics clock]");
#endif 
a458 3
#ifdef DEBUG
	printf("\n");
#endif 
d464 1
a464 1
   /* function stub */
d473 1
a473 1
	vm_size_t size;    
d482 2
a483 2
		pmap_kenter_pa((vm_offset_t)msgbufp + i * NBPG,
			   avail_end + i * NBPG, VM_PROT_READ|VM_PROT_WRITE);
d515 2
a516 2
	
	/* 
d543 1
a543 1
		
d555 1
a555 1
#endif 
d568 1
a568 1
		
d580 1
a580 1
#endif 
d626 1
a626 1
		curbuf = (vm_offset_t) buffers + (i * MAXBSIZE);
d635 1
a635 1
			    VM_PROT_READ|VM_PROT_WRITE);
d648 1
a648 1
	
d655 1
a655 1
	/* 
d704 1
a704 1
	register caddr_t v;
d738 2
a739 2
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / MAXBSIZE * 7 / 10) 
		nbuf = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
d762 1
a762 1
	register struct trapframe *tf = USER_REGS(p);
d792 1
a792 1
	
d794 3
a796 3
		/* 
		 * user mode, serialize mem, interrupts enabled, 
		 * graphics unit, fp enabled 
d798 1
a798 1
		tf->epsr = PSR_SRM | PSR_SFD;  
d804 3
a806 3
		/* 
		 * user mode, interrupts enabled, 
		 * no graphics unit, fp enabled 
d869 3
a871 3
	register struct proc *p = curproc;
	register struct trapframe *tf;
	register struct sigacts *psp = p->p_sigacts;
d895 1
a895 1
	if ((unsigned)fp <= USRSTACK - ctob(p->p_vmspace->vm_ssize)) 
d986 1
a986 1
	/* 
d1029 2
a1030 2
	register struct sigcontext *scp;
	register struct trapframe *tf;
d1058 1
a1058 1
#endif 
d1137 1
a1137 1
	register int howto;
d1185 1
a1185 1
void 
d1339 1
a1339 1
	
d1372 1
a1372 1
	register u_char *vaddr;
d1375 1
a1375 1
	extern vm_offset_t iomap_mapin(vm_offset_t, vm_size_t,  boolean_t);
d1422 1
a1422 1
#endif 
d1439 1
a1439 1
vm_offset_t 
d1442 1
a1442 1
	vm_offset_t addr;
d1444 1
a1444 1
	addr = (vm_offset_t)uvm_km_zalloc(kernel_map, INTSTACK_SIZE);
d1513 1
a1513 1
	register struct intrhand *intr;
d1566 1
a1566 1
	0,0,0,0,SYSCV_TIMER1,0,SYSCV_ACF,SYSCV_ABRT, 
d1573 1
a1573 1
void 
d1598 1
a1598 1
	/* 
d1602 1
a1602 1
	 * priority. 
d1608 1
a1608 1
			register int i;
d1631 1
a1631 1
	  
d1641 1
a1641 1
		
d1644 3
a1646 3
		/* 
		 * This is tricky.  If you don't catch all the 
		 * interrupts, you die. Game over. Insert coin... 
d1687 1
a1687 1
			intrcnt[M88K_SPUR_IRQ]++; 
d1704 1
a1704 1
					intrcnt[level]++; 
d1798 1
a1798 1
		intrcnt[M88K_SPUR_IRQ]++; 
d1823 1
a1823 1
				intrcnt[level]++; 
d1862 1
a1862 1
	
d1903 1
a1903 1
		intrcnt[M88K_SPUR_IRQ]++; 
d1925 1
a1925 1
				intrcnt[level]++; 
d1944 1
a1944 1
#endif 
d2030 1
a2030 1
 * insert an element into a queue 
d2037 1
a2037 1
	register struct prochd *element, *head;
d2054 1
a2054 1
	register struct prochd *element;
d2089 1
a2089 1
	register struct proc *p;
d2091 3
a2093 3
	register struct prochd *q;
	register struct proc *oldlast;
	register int which = p->p_priority >> 2;
d2113 3
a2115 3
	register struct proc *p = vp;
	register int which = p->p_priority >> 2;
	register struct prochd *q;
d2194 1
a2194 1
}  
d2202 1
a2202 1
} 
d2251 1
a2251 1
		printf("fpsr %x fpcr %x epsr %x ssbr %x\n", 
d2253 1
a2253 1
		printf("fpecr %x fphs1 %x fpls1 %x fphs2 %x fpls2 %x\n", 
d2255 1
a2255 1
		printf("fppt %x fprh %x fprl %x fpit %x\n", 
d2257 1
a2257 1
		printf("vector %d mask %x mode %x scratch1 %x cpu %x\n", 
d2260 1
a2260 1
#endif 
d2263 1
a2263 1
		printf("fpsr %x fpcr %x fpecr %x epsr %x\n", 
d2269 1
a2269 1
		printf("vector %d mask %x mode %x scratch1 %x cpu %x\n", 
d2283 1
a2283 1
#endif 
d2296 2
d2301 1
a2301 1
	
d2305 1
a2305 1
	 * Do this early so that we can take a data or 
d2325 2
a2326 2
	/* 
	 * set up interrupt and fp exception handlers 
d2416 1
a2416 1
#endif 
d2436 2
a2437 2
#endif 
	pmap_bootstrap((vm_offset_t)trunc_page((unsigned)&kernelstart) /* = loadpt */, 
d2441 1
a2441 1
	 * Tell the VM system about available physical memory.  
d2448 1
a2448 1
	save_u_area(&proc0, (vm_offset_t)proc0paddr);
d2459 1
a2459 1
#endif 
d2463 1
a2463 1
 * Boot console routines: 
@


1.114
log
@Clean the MVME188 external interrupts routine, and do not let it loop forever
on clock interrupts, because interrupts were re-enabled too early.

Also, remove the old hack restricting the system to only use 32MB of memory.

This makes MVME188 boot multi-user again (only tested on 2P256 so far).
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.113 2003/09/20 13:57:37 miod Exp $	*/
d1773 1
d1793 1
a1793 5

	/* and block interrupts at level or lower */
	setipl(level);
	/* and stash it away in the trap frame */
	eframe->mask = mask;
d1806 3
d1817 1
d1823 1
d1861 1
a1861 1
	setipl(eframe->mask);
@


1.113
log
@Cleanup uses of intstack and interrupt_stack[] - also makes time % in top
more realistic.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.112 2003/09/16 20:52:22 miod Exp $	*/
a376 4
	if ((look > (unsigned int *)0x01FFF000) && (brdtyp == BRD_188)) {
                /* temp hack to fake 32Meg on MVME188 */
		look = (unsigned int *)0x01FFF000; 
	}
d1591 4
a1594 4
	register int cpu = cpu_number();
	register unsigned int cur_mask;
	register unsigned int level, old_spl;
	register struct intrhand *intr;
d1608 1
a1608 1
		return;
d1639 1
d1643 1
d1647 9
a1655 1
		enable_interrupt();
a1667 5
			if (guarded_access(ivec[level], 4, (u_char *)&vec) ==
			    EFAULT) {
				panic("unable to get vector for this vmebus "
				    "interrupt (level %x)", level);
			}
d1687 2
a1688 1
				panic("vme vec timeout");
a1698 5
		if (vec > 0xFF) {
			panic("interrupt vector 0x%x greater than 255!"
			    "level = %d iack = 0x%x", 
			    vec, level, ivec[level]);
		}
d1738 1
a1746 1
	flush_pipeline();
@


1.112
log
@Remove unused material from include files, as well as the annoying U() macro
which is only used to obfuscate things.

Doing this points out that the BUG memory is not at the same address on
187 and 197 (the 197 BUG is inside obio), so provide distinct constants,
and treat 187 and 197 slightly differently in pmap_bootstrap(). However, we
now need to map the 197 flash memory as well...

While there, simplify and constify pmap_table_build() and its associated data.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.111 2003/09/16 20:46:11 miod Exp $	*/
d116 1
a116 1
vm_offset_t interrupt_stack[MAX_CPUS] = {0};
d1461 3
a1463 2
	vm_offset_t addr = 0;
	addr = (vm_offset_t)uvm_km_zalloc(kernel_map, INTSTACK_SIZE + 4096);
d1466 2
a1467 1
		panic("Cannot allocate slave stack");
a1468 2
	if (interrupt_stack[0] == 0)
		interrupt_stack[0] = (vm_offset_t) intstack;
@


1.111
log
@Provide more information about the CPU/CMMU configuration in the dmesg
output. Also, if the board configuration parameter area is invalid, warn the
user and assume safe values - this is likely caused by a dead NVRAM battery.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.110 2003/09/08 20:44:52 miod Exp $	*/
a128 1
int getscsiid(void);
d162 3
d167 5
a171 1
volatile vm_offset_t obiova;
d529 5
a533 8
		NULL, UVM_UNKNOWN_OFFSET, 0, UVM_MAPFLAG(UVM_PROT_NONE, 
						     UVM_PROT_NONE,
						     UVM_INH_NONE,
						     UVM_ADV_NORMAL, 0));
	if (uarea_pages != UADDR) {
		printf("uarea_pages %x: UADDR not free\n", uarea_pages);
		panic("bad UADDR");
	}
d546 28
a573 9
			NULL, UVM_UNKNOWN_OFFSET, 0, UVM_MAPFLAG(UVM_PROT_NONE, 
							     UVM_PROT_NONE,
							     UVM_INH_NONE,
							     UVM_ADV_NORMAL, 0));

		if (sramva != SRAM_START) {
			printf("sramva %x: SRAM not free\n", sramva);
			panic("bad sramva");
		}
a576 2
#endif 
#if defined(MVME187) || defined(MVME197)
d578 1
a578 1
		 * Grab the BUGROM space that we hardwired in pmap_bootstrap
d580 7
a586 11
		bugromva = BUGROM_START;

		uvm_map(kernel_map, (vaddr_t *)&bugromva, BUGROM_SIZE,
			NULL, UVM_UNKNOWN_OFFSET, 0, UVM_MAPFLAG(UVM_PROT_NONE, 
							     UVM_PROT_NONE,
							     UVM_INH_NONE,
							     UVM_ADV_NORMAL, 0));
		if (bugromva != BUGROM_START) {
			printf("bugromva %x: BUGROM not free\n", bugromva);
			panic("bad bugromva");
		}
d593 5
a597 8
			NULL, UVM_UNKNOWN_OFFSET, 0, UVM_MAPFLAG(UVM_PROT_NONE, 
							     UVM_PROT_NONE,
							     UVM_INH_NONE,
							     UVM_ADV_NORMAL, 0));
		if (obiova != OBIO_START) {
			printf("obiova %x: OBIO not free\n", obiova);
			panic("bad OBIO");
		}
d607 5
a611 8
			NULL, UVM_UNKNOWN_OFFSET, 0, UVM_MAPFLAG(UVM_PROT_NONE, 
							     UVM_PROT_NONE,
							     UVM_INH_NONE,
							     UVM_ADV_NORMAL, 0));
		if (utilva != MVME188_UTILITY) {
			printf("utilva %x: UTILITY area not free\n", utilva);
			panic("bad utilva");
		}
d622 2
a623 3
		    NULL, UVM_UNKNOWN_OFFSET, 0,
		    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
				UVM_ADV_NORMAL, 0)))
d666 1
a666 1
				   16*NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);
d672 1
a672 1
				   VM_PHYS_SIZE, 0, FALSE, NULL);
d678 1
a678 1
				   IOMAP_SIZE, 0, FALSE, NULL);
@


1.110
log
@Revert the changes reordering the data access exception processing in the
context of a regular exception. This was probably a good move, but it
eventually causes issues when uptimes grows towards infinity...

Of course, diagnosing such an issue at the same time that the disk drive
is dying and causes problems on his own, is not exactly easy...
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.109 2003/09/06 15:07:43 miod Exp $	*/
d246 2
a247 2
int cpumod = 0; /* set in mvme_bootstrap() */
int cpuspeed = 25;   /* 25 MHZ XXX should be read from NVRAM */
d386 1
d388 8
a395 5
	for (i=0; i<4; i++) {
		c=(unsigned char)brdid.speed[i];
		c-= '0';
		speed *=10;
		speed +=c;
a398 1
}
d400 9
a408 15
int
getscsiid()
{
	struct mvmeprom_brdid brdid;
	int scsiid = 0;
	int i, c;
	bugbrdid(&brdid);
	for (i=0; i<2; i++) {
		c=(unsigned char)brdid.scsiid[i];
		scsiid *=10;
		c-= '0';
		scsiid +=c;
	}
	printf("SCSI ID = %d\n", scsiid);
	return (7); /* hack! */
a416 1
	printf("Model: %s\n", cpu_model);
d2325 1
a2325 1
	if (brdtyp == BRD_8120)
d2327 2
a2405 1
	printf("CPU%d is master CPU\n", master_cpu);
d2407 9
a2415 2
#ifdef notevenclose
	if (brdtyp == BRD_188 && (boothowto & RB_MINIROOT)) {
d2417 1
a2417 1
		for (i=0; i<MAX_CPUS; i++) {
d2421 9
d2431 1
a2431 1
#endif 
@


1.109
log
@Large cleaning of exception handling:
- faster code paths in eh.S, especially for 88110 cpus
- do not service data access exceptions more than one time; also, be sure
  that interrupts are disabled while servicing them.
- cleanup the 88110 trap handler in the same way the 88100 flavour has been
  cleaned recently.

This spotted two bugs, which are fixed there as well:
- add systrace support to the 88110 syscall code
- add emulation support to the 88100 syscall code
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.108 2003/09/02 20:14:08 miod Exp $	*/
a1643 8
		/*
		 * Contrary to other traps, we have not checked for the
		 * data pipeline status yet.
		 * Do it now, before we reenable interrupts.
		 */
		if (eframe->dmt0 & DMT_VALID)
			m88100_trap(T_DATAFLT, eframe);

d1732 8
a1742 1
	disable_interrupt();
a1806 8
	/*
	 * Contrary to other traps, we have not checked for the
	 * data pipeline status yet.
	 * Do it now, before we reenable interrupts.
	 */
	if (eframe->dmt0 & DMT_VALID)
		m88100_trap(T_DATAFLT, eframe);

d1846 8
a1856 1
	disable_interrupt();
@


1.108
log
@There is a weird problems related to interrupts - we need to enable them too
early for the console to be reliable, so revert to the bug console for boot -a.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.107 2003/09/01 18:21:23 miod Exp $	*/
d813 4
d1644 8
a1739 16
	 * process any remaining data access exceptions before
	 * returning to assembler
	 */
	disable_interrupt();
	if (eframe->dmt0 & DMT_VALID) {
		m88100_trap(T_DATAFLT, eframe);
		if (eframe->dmt0 & DMT_VALID) {
#ifdef DEBUG
			printf("m188_ext_int: T_DATAFLT not fixed\n");
#endif
			data_access_emulation((unsigned *)eframe);
			eframe->dmt0 &= ~DMT_VALID;
		}
	}

	/*
d1743 1
d1808 8
a1854 17
	 * process any remaining data access exceptions before
	 * returning to assembler
	 */
	disable_interrupt();

	if (eframe->dmt0 & DMT_VALID) {
		m88100_trap(T_DATAFLT, eframe);
		if (eframe->dmt0 & DMT_VALID) {
#ifdef DEBUG
			printf("m187_ext_int: T_DATAFLT not fixed\n");
#endif
			data_access_emulation((unsigned *)eframe);
			eframe->dmt0 &= ~DMT_VALID;
		}
	}

	/*
d1858 1
@


1.107
log
@Correctly map the message buffer.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.106 2003/08/31 16:52:38 miod Exp $	*/
d270 1
a270 1
static struct consdev bootcons = {
@


1.106
log
@Upon returning from m18*_ext_int(), do not invoke data_access_emulation()
if trap(T_DATAFLT) has been able to correct the issue.

This is, in fact, really a can't-happen situation, anyways.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.105 2003/08/11 20:45:17 miod Exp $	*/
d499 1
a499 1
		pmap_kenter_pa((vm_offset_t)msgbufp, 
@


1.105
log
@Sprinkle proper use of _C_LABEL and _ASM_LABEL in the .S files (except for
the _fp.S which are too scary at the moment). This will be necessary to
move to ELF in the future.

Use local symbols whenever possible.

Attempt to use delayed branches whenever possible.

Remove stupid or straightforward comments, some hardcoded values, and a
few unused variables or routines.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.104 2003/08/07 17:23:43 miod Exp $	*/
d420 1
a420 1
	printf("\nModel: %s\n", cpu_model);
d830 1
d832 1
d1734 7
a1740 2
		data_access_emulation((unsigned *)eframe);
		eframe->dmt0 &= ~DMT_VALID;
d1766 2
a1767 2
	register u_char mask, level;
	register struct intrhand *intr;
a1810 4
	if (vec > 0xff) {
		panic("interrupt vector %x greater than 255", vec);
	}

d1832 1
a1832 1
			if (intr->ih_wantframe != 0)
d1834 1
a1834 1
			else
d1857 7
a1863 2
		data_access_emulation((unsigned *)eframe);
		eframe->dmt0 &= ~DMT_VALID;
a1865 2
	mask = eframe->mask;

d1870 1
a1870 1
	setipl(mask);
d1878 2
a1879 2
	register u_char mask, level, src;
	register struct intrhand *intr;
a1922 4
	if (vec > 0xff) {
		panic("interrupt vector %x greater than 255", vec);
	}

a1961 2
	mask = eframe->mask;

d1966 1
a1966 1
	setipl(mask);
d2298 1
a2298 1
	if (brdtyp == BRD_188 ) {
@


1.104
log
@In sendsig() and sigreturn(), use the SS_xxx flags rather than the SA_xxx
flags (purely cosmetic, as they have the same value).

Also some minor indentation/KNF repairs.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.103 2003/08/01 19:53:19 miod Exp $	*/
a121 2
void m88100_Xfp_precise(void);
void m88110_Xfp_precise(void);
d1147 1
a1147 1
	/* take a snap shot before clobbering any registers */
d2334 1
a2334 1
	/* zreo out the machine dependant function pointers */
@


1.103
log
@Nuke uvm_useracc() call here too.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.102 2003/08/01 07:47:58 miod Exp $	*/
d834 2
a835 2
	tf->snip = pack->ep_entry & ~3;
	tf->sfip = (pack->ep_entry & ~3) | FIP_V;
d888 1
a888 1
	oonstack = psp->ps_sigstk.ss_flags & SA_ONSTACK;
d898 1
a898 1
	    (psp->ps_sigstk.ss_flags & SA_ONSTACK) == 0 &&
d902 1
a902 1
		psp->ps_sigstk.ss_flags |= SA_ONSTACK;
d936 3
a938 3
	sf.sf_sc.sc_xip = tf->sxip & ~3;
	sf.sf_sc.sc_nip = tf->snip & ~3;
	sf.sf_sc.sc_fip = tf->sfip & ~3;
d951 10
a960 10
	sf.sf_sc.sc_ssbr = tf->ssbr;
	sf.sf_sc.sc_dmt0 = tf->dmt0;
	sf.sf_sc.sc_dmd0 = tf->dmd0;
	sf.sf_sc.sc_dma0 = tf->dma0;
	sf.sf_sc.sc_dmt1 = tf->dmt1;
	sf.sf_sc.sc_dmd1 = tf->dmd1;
	sf.sf_sc.sc_dma1 = tf->dma1;
	sf.sf_sc.sc_dmt2 = tf->dmt2;
	sf.sf_sc.sc_dmd2 = tf->dmd2;
	sf.sf_sc.sc_dma2 = tf->dma2;
d1003 2
a1004 2
	tf->snip = (addr & ~3) | NIP_V;
	tf->sfip = (tf->snip + 4) | FIP_V;
d1032 3
a1034 3
struct proc *p;
void *v;
register_t *retval;
d1077 3
a1079 3
	tf->sxip = (scp->sc_xip) | XIP_V;
	tf->snip = (scp->sc_nip) | NIP_V;
	tf->sfip = (scp->sc_fip) | FIP_V;
d1092 10
a1101 10
	tf->ssbr = scp->sc_ssbr;
	tf->dmt0 = scp->sc_dmt0;
	tf->dmd0 = scp->sc_dmd0;
	tf->dma0 = scp->sc_dma0;
	tf->dmt1 = scp->sc_dmt1;
	tf->dmd1 = scp->sc_dmd1;
	tf->dma1 = scp->sc_dma1;
	tf->dmt2 = scp->sc_dmt2;
	tf->dmd2 = scp->sc_dmd2;
	tf->dma2 = scp->sc_dma2;
d1129 1
a1129 1
		p->p_sigacts->ps_sigstk.ss_flags |= SA_ONSTACK;
d1131 1
a1131 1
		p->p_sigacts->ps_sigstk.ss_flags &= ~SA_ONSTACK;
d1472 2
a1473 1
void slave_pre_main()
d1974 2
a1975 2
struct proc *p;
struct exec_package *epp;
d2213 4
a2216 4
struct trapframe  *f;
caddr_t     p;
int         flags;
char        *s;
@


1.102
log
@Compensate for the assym.h lossage, which defines NBPG for now (this will be
cleaned up soon...)
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.101 2003/05/11 19:41:11 deraadt Exp $	*/
d1048 1
a1048 1
	if ((int)scp & 3 || uvm_useracc((caddr_t)scp, sizeof *scp, B_WRITE) == 0 ||
@


1.101
log
@string cleaning; krw ok
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.100 2003/01/13 20:12:18 miod Exp $	*/
a100 1
#include "assym.h"			/* EF_EPSR, etc. */
d2401 1
d2409 3
@


1.100
log
@Clean up ipl handling: be sure to always return valid levels in getipl(),
and check input level in setipl() if DIAGNOSTIC.

Doing this pointed out an horrible bug where exception frames would refer
to the saved ipl at the time the exception was processed, but would not
save it before, and the joys of stack values would make it a correct value
90% of the time. Of course, bad things could happen when restoring the
``saved'' ipl...
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.99 2003/01/04 23:13:51 miod Exp $	*/
d421 2
a422 1
	sprintf(cpu_model, "Motorola MVME%x, %dMHz", brdtyp, cpuspeed);
@


1.99
log
@On MVME187, detect the on-board memory size by probing the memory controllers
like on mvme68k, rather than attempting to find the first off-board memory
location.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.98 2003/01/01 23:38:18 miod Exp $	*/
d183 1
a183 1
int   safepri = PSR_SUPERVISOR;
d1741 1
a1741 1
	setipl((u_char)eframe->mask);
d1766 2
a1767 2
	mask = *md.intr_mask;
	level = *md.intr_ipl;
d1790 1
a1790 1
	setipl((u_char)level);
a1795 4
	if (level > 7 || (char)level < 0) {
		panic("int level (%x) is not between 0 and 7", level);
	}

d1805 1
a1805 1
	if (vec > 0xFF) {
d1858 1
d1865 1
a1865 1
	setipl((u_char)mask);
d1879 1
a1879 1
	mask = *md.intr_mask;
d1888 1
a1888 1
		level = *md.intr_ipl;
d1901 1
a1901 1
	setipl((u_char)level);
a1906 4
	if (level > 7 || (char)level < 0) {
		panic("int level (%x) is not between 0 and 7", level);
	}

d1918 1
a1918 1
	if (vec > 0xFF) {
d1967 1
a1967 1
	setipl((u_char)mask);
@


1.98
log
@Fill cpu_model, so that sysctl hw.model produces something interesting.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.97 2002/12/17 23:11:32 millert Exp $	*/
d130 1
d308 23
a378 1
	physmem = btoc(trunc_page((unsigned)look)); /* in pages */
d381 1
d2402 16
a2417 1
	last_addr = size_memory();
@


1.97
log
@Make SysV-style shared memory and semaphore limits sysctl'able.
Instead of allocating a static amount of memory for the data
structures via valloc() in allocsys(), allocate things dynamically
using pool(9) when possible and malloc(9) when not.  The various
members of struct seminfo and struct shminfo are in kern.seminfo
and kern.shminfo respectively (not all members of kern.seminfo are
changable).

The data structures used still leave something to be desired but
things are not made worse in that respect by this commit.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.96 2002/10/12 02:03:45 krw Exp $	*/
d397 2
a398 1
	printf("\nModel: Motorola MVME%x %dMhz\n", brdtyp, cpuspeed);
@


1.96
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Last bits of diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.95 2002/07/20 19:24:56 art Exp $	*/
a65 6
#ifdef SYSVSEM
#include <sys/sem.h>
#endif
#ifdef SYSVSHM
#include <sys/shm.h>
#endif
a700 12
#ifdef SYSVSHM
	shminfo.shmmax = shmmaxpgs;
	shminfo.shmall = shmmaxpgs;
	shminfo.shmseg = shmseg;
	valloc(shmsegs, struct shmid_ds, shminfo.shmmni);
#endif
#ifdef SYSVSEM
	valloc(sema, struct semid_ds, seminfo.semmni);
	valloc(sem, struct sem, seminfo.semmns);
	/* This is pretty disgusting! */
	valloc(semu, int, (seminfo.semmnu * seminfo.semusz) / sizeof(int));
#endif
@


1.95
log
@Instead of copying out the signal trampoline on top of the stack, create
an uvm aobj, copy out the signal trampoline into it and share that page
among all processes for the same emulation.

This also requires us to actually be able to tell signal code where the
trampoline is located, so introduce a new field in struct proc - p_sigcode
that is a pointer to sigcode. This allows us to remove all the ugly
calculations of the signal trampoline address done in every sendsig
function in the tree (that's why so many files are changed).

Tested by various people. ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.94 2002/06/04 00:09:08 deraadt Exp $	*/
d1681 1
a1681 1
			panic("interrupt vector 0x%x greater than 255!\n"
d1770 1
a1770 1
		panic("mask == level, %d\n", level);
d1779 1
a1779 1
		panic("Bogons... level %x and mask %x\n", level, mask);
d1796 1
a1796 1
		panic("Unable to get vector for this interrupt (level %x)\n", level);
d1893 1
a1893 1
		panic("Bogons... level %x and mask %x\n", level, mask);
d1911 1
a1911 1
			panic("Unable to get vector for this interrupt (level %x)\n", level);
@


1.94
log
@spelling; raj@@cerias.purdue.edu
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.93 2002/03/23 13:28:34 espie Exp $	*/
a878 3
	extern char sigcode[], esigcode[];

#define szsigcode (esigcode - sigcode)
d993 1
a993 1
	addr = (int)PS_STRINGS - szsigcode;
@


1.93
log
@Add variables for config(8) -e time tweak of systemV shared memory
parameters.

Ok millert@@, miod@@, maja@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.92 2002/03/14 03:15:57 millert Exp $	*/
d1021 1
a1021 1
 * psl to gain improper priviledges or to cause
@


1.92
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.91 2002/03/14 01:26:40 millert Exp $	*/
d708 3
@


1.91
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.90 2002/03/05 22:11:42 miod Exp $	*/
d330 3
a332 3
	max = (void*)MAXPHYSMEM;
	for (look = (void*)Roundup(end, STRIDE); look < max;
	    look = (int*)((unsigned)look + STRIDE)) {
@


1.90
log
@Kill prom stuff duplicates from bugio.[ch].
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.89 2002/02/17 22:59:53 maja Exp $	*/
d129 16
a144 16
void m88100_Xfp_precise __P((void));
void m88110_Xfp_precise __P((void));
void setupiackvectors __P((void));
void regdump __P((struct trapframe *f));
void dumpsys __P((void));
void consinit __P((void));
vm_offset_t size_memory __P((void));
int getcpuspeed __P((void));
int getscsiid __P((void));
void identifycpu __P((void));
void save_u_area __P((struct proc *, vm_offset_t));
void load_u_area __P((struct proc *));
void dumpconf __P((void));
void m187_ext_int __P((u_int v, struct m88100_saved_state *eframe));
void m188_ext_int __P((u_int v, struct m88100_saved_state *eframe));
void m197_ext_int __P((u_int v, struct m88100_saved_state *eframe));
d225 1
a225 1
caddr_t allocsys __P((caddr_t));
d270 5
a274 5
void bootcnprobe __P((struct consdev *));
void bootcninit __P((struct consdev *));
void bootcnputc __P((dev_t, int));
int  bootcngetc __P((dev_t));
extern void nullcnpollc __P((dev_t, int));
d1267 1
a1267 1
	int (*dump) __P((dev_t, daddr_t, caddr_t, size_t));
d2321 1
a2321 1
	extern void set_tcfp __P((void));
@


1.89
log
@Patch from Daniel Lucq <daniel@@lucq.org>

The patch allows you to change the value of NMBCLUSTERS, BUFCACHEPERCENT
and NKMEMPAGES using the config command, instead of recompiling the kernel.

This is the kernel part of the patch. I have compiled it on i386, sparc64,
alpha and macppc. -moj ok art@@ maja@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.88 2002/01/23 17:51:52 art Exp $	*/
d368 1
a368 1
	struct bugbrdid brdid;
d385 1
a385 1
	struct bugbrdid brdid;
d1182 1
d2163 1
a2163 1
	struct bugbrdid brdid;
d2323 1
a2323 2
	struct bugbrdid brdid;
	
d2340 1
a2340 1
	brdtyp = brdid.brdno;
@


1.88
log
@move mb_map allocation to mbinit()
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.87 2002/01/23 17:35:56 art Exp $	*/
d213 5
d223 1
a722 3
#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif
d734 1
a734 1
			    BUFCACHEPERCENT / 100;
@


1.87
log
@move definition of mb_map from zillions of machdep.c to uipc_mbuf.c
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.86 2002/01/16 20:50:17 miod Exp $	*/
a656 3
	mb_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
				 VM_MBUF_SIZE, VM_MAP_INTRSAFE, FALSE, NULL);
	
@


1.86
log
@Don't include <sys/map.h> when you don't need what's in it.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.85 2002/01/14 21:34:41 miod Exp $	*/
a190 1
struct vm_map *mb_map = NULL;
@


1.85
log
@volatile police.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.84 2002/01/10 21:45:33 miod Exp $	*/
a50 1
#include <sys/map.h>
@


1.84
log
@Replace asm statements with stuff from asm*.h, or even simple equivalent
C statements.
As a bonus this gets rid of the incorrect gcc 2.95 warnings in machdep.c
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.83 2002/01/07 02:34:04 miod Exp $	*/
d147 1
a147 1
volatile unsigned char *ivec[] = {
d164 5
a168 5
volatile unsigned int *int_mask_reg[MAX_CPUS] = {
	(volatile unsigned int *)IEN0_REG,
	(volatile unsigned int *)IEN1_REG,
	(volatile unsigned int *)IEN2_REG,
	(volatile unsigned int *)IEN3_REG
d317 1
a317 1
	volatile unsigned int *look;
d2303 1
a2303 1
		istr = *(volatile int *)IST_REG;
@


1.83
log
@- increment uvmexp.intrs on interrupts (oops)
- change more fatal situations into panics
- reorganize the execution flow to be shorter if no device interrupt handler
  are registered
- minor style/KNF changes as well
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.82 2001/12/24 04:12:40 miod Exp $	*/
d1760 2
a1761 2
	__asm __volatile("ld.b	%0,%1" : "=r" (mask) : "" (*md.intr_mask));
	__asm __volatile("ld.b	%0,%1" : "=r" (level) : "" (*md.intr_ipl));
d1795 1
a1795 1
	__asm __volatile("tb1	0, r0, 0"); 
d1799 3
a1801 3
	__asm __volatile("tb1	0, r0, 0"); 
	__asm __volatile("tb1	0, r0, 0"); 
	__asm __volatile("tb1	0, r0, 0"); 
d1876 2
a1877 2
	__asm __volatile("ld.b	%0,%1" : "=r" (mask) : "" (*md.intr_mask));
	__asm __volatile("ld.b	%0,%1" : "=r" (src) : "" (*md.intr_src));
d1885 1
a1885 1
		__asm __volatile("ld.b	%0,%1" : "=r" (level) : "" (*md.intr_ipl));
d1910 1
a1910 1
		__asm __volatile("tb1	0, r0, 0"); 
d1914 3
a1916 3
		__asm __volatile("tb1	0, r0, 0"); 
		__asm __volatile("tb1	0, r0, 0"); 
		__asm __volatile("tb1	0, r0, 0");
@


1.82
log
@- completely change the mmu segment and page table structure definitions,
to use constant bitmasks instead of bitfields.
- remove unnecessary (as long as we are not running SMP) locks on the
physsegs.
- update the pmap code to take these changes into account, and gratuitously
change several names and code paths to be closer to existing m68k pmaps. It's
a bit faster now.
- change pmap.c's usage of vm_{offset,size}_t to {p,v}{addr,size}_t.
- remove dead or unused stuff from pmap.c, fix typos, etc

Tested on 187 and 188, should not make things worse for 197.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.81 2001/12/22 17:57:11 smurph Exp $	*/
d1599 2
d1622 1
a1622 1
			printf("--CPU %d halted--", cpu_number());
d1624 1
a1624 2
			while (1)
				;
d1646 4
a1649 3
			if (guarded_access(ivec[level], 4, (u_char *)&vec) == EFAULT) {
				printf("Unable to get vector for this vmebus interrupt (level %x)\n", level);
				goto out_m188;
d1653 2
a1654 2
				printf("unknown onboard interrupt: mask = 0x%b\n", 1 << intbit, IST_STRING);
				panic("m188_ext_int");
a1655 4
			
			
			#define M88K_OBIO1_IRQ	8

d1659 2
a1660 2
				printf("unknown hadware failure: mask = 0x%b\n", 1 << intbit, IST_STRING);
				panic("m188_ext_int");
d1663 4
a1666 3
			if (guarded_access(ivec[level], 4, (u_char *)&vec) == EFAULT) {
				printf("Unable to get vector for this vmebus interrupt (level %x)\n", level);
				goto out_m188;
d1670 1
a1670 2
				printf("m188_ext_int: vme vec timeout\n");
				goto out_m188;
d1673 2
a1674 2
				printf("unknown vme interrupt: mask = 0x%b\n", 1 << intbit, IST_STRING);
				panic("m188_ext_int");
d1677 3
a1679 3
			printf("unknown interrupt: level = %d intbit = 0x%x mask = 0x%b\n",
			       level, intbit, 1 << intbit, IST_STRING);
			panic("m188_ext_int");
d1682 3
a1684 2
			panic("m188_ext_int: interrupt vector 0x%x greater than 255!\nlevel = %d iack = 0x%x", 
			      vec, level, ivec[level]);
d1687 1
a1687 1
		if ((intr = intr_handlers[vec]) == 0){
d1690 25
a1714 17
			printf("Spurious interrupt: level = %d vec = 0x%x, intbit = %d mask = 0x%b\n",
			       level, vec, intbit, 1 << intbit, IST_STRING);

		}
		/*
		 * Walk through all interrupt handlers in the chain for the
		 * given vector, calling each handler in turn, till some handler
		 * returns a value != 0.
		 */
		for (ret = 0; intr; intr = intr->ih_next) {
			if (intr->ih_wantframe != 0)
				ret = (*intr->ih_fn)((void *)eframe);
			else
				ret = (*intr->ih_fn)(intr->ih_arg);
			if (ret){
				/* increment intr counter */
				intrcnt[level]++; 
a1717 8
		if (ret == 0) {
			printf("Unclaimed interrupt: level = %d vec = 0x%x, intbit = %d mask = 0x%b\n",
			       level, vec, intbit, 1 << intbit, IST_STRING);
			break;
		}
#if 0
		disable_interrupt();
#endif 
a1723 1
out_m188:
a1736 1
	return;
d1760 2
a1761 2
	asm volatile("ld.b	%0,%1" : "=r" (mask) : "" (*md.intr_mask));
	asm volatile("ld.b	%0,%1" : "=r" (level) : "" (*md.intr_ipl));
a1771 1
		return;
a1780 1
		return;
d1788 2
d1795 1
a1795 1
	asm volatile("tb1	0, r0, 0"); 
d1797 1
a1797 2
		printf("Unable to get vector for this interrupt (level %x)\n", level);
		goto out;
d1799 3
a1801 3
	asm volatile("tb1	0, r0, 0"); 
	asm volatile("tb1	0, r0, 0"); 
	asm volatile("tb1	0, r0, 0"); 
d1809 1
a1809 1
	if ((intr = intr_handlers[vec]) == 0) {
d1814 6
a1819 5
	}
	if (intr && intr->ih_ipl != level) {
		panic("Handler ipl %x not the same as level %x. vec = 0x%x",
		      intr->ih_ipl, level, vec);
	}
d1821 5
a1825 5
	/*
	 * Walk through all interrupt handlers in the chain for the
	 * given vector, calling each handler in turn, till some handler
	 * returns a value != 0.
	 */
d1827 10
a1836 9
	for (ret = 0; intr; intr = intr->ih_next) {
		if (intr->ih_wantframe != 0)
			ret = (*intr->ih_fn)((void *)eframe);
		else
			ret = (*intr->ih_fn)(intr->ih_arg);
		if (ret){
			/* increment intr counter */
			intrcnt[level]++; 
			break;
a1837 1
	}
d1839 4
a1842 3
	if (ret == 0) {
		printf("Unclaimed interrupt (level %x and vec %x)\n",
		       level, vec);
d1851 1
a1851 2
out:
		if (eframe->dmt0 & DMT_VALID) {
d1853 3
a1855 3
			data_access_emulation((unsigned *)eframe);
			eframe->dmt0 &= ~DMT_VALID;
		}
d1876 2
a1877 2
	asm volatile("ld.b	%0,%1" : "=r" (mask) : "" (*md.intr_mask));
	asm volatile("ld.b	%0,%1" : "=r" (src) : "" (*md.intr_src));
d1885 1
a1885 1
		asm volatile("ld.b	%0,%1" : "=r" (level) : "" (*md.intr_ipl));
d1894 1
a1894 2
		printf("Bogons... level %x and mask %x\n", level, mask);
		goto m197beatit;
d1902 2
d1910 1
a1910 1
		asm volatile("tb1	0, r0, 0"); 
d1912 1
a1912 2
			printf("Unable to get vector for this interrupt (level %x)\n", level);
			goto m197out;
d1914 3
a1916 3
		asm volatile("tb1	0, r0, 0"); 
		asm volatile("tb1	0, r0, 0"); 
		asm volatile("tb1	0, r0, 0");
d1925 1
a1925 1
	if ((intr = intr_handlers[vec]) == 0) {
d1930 6
a1935 5
	}
	if (intr && intr->ih_ipl != level) {
		panic("Handler ipl %x not the same as level %x. vec = 0x%x",
		      intr->ih_ipl, level, vec);
	}
d1937 16
a1952 5
	/*
	 * Walk through all interrupt handlers in the chain for the
	 * given vector, calling each handler in turn, till some handler
	 * returns a value != 0.
	 */
d1954 3
a1956 9
	for (ret = 0; intr; intr = intr->ih_next) {
		if (intr->ih_wantframe != 0)
			ret = (*intr->ih_fn)((void *)eframe);
		else
			ret = (*intr->ih_fn)(intr->ih_arg);
		if (ret){
			/* increment intr counter */
			intrcnt[level]++; 
			break;
a1959 5
	if (ret == 0) {
		printf("Unclaimed interrupt (level %x and vec %x)\n",
		       level, vec);
	}

a1961 1
m197out:
a1968 3

m197beatit:
	return;
@


1.81
log
@change function names to reflect cpu type instead of board type.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.80 2001/12/22 09:49:39 smurph Exp $	*/
d411 1
a411 1
		p->p_md.md_upte[i] = kvtopte((va + (i * NBPG)))->bits;
d418 1
a418 1
	pte_template_t *t;
d423 1
a423 1
		t->bits = p->p_md.md_upte[i];
@


1.80
log
@masive cmmu overhaul.  function pointers now control cmmu functionality
instead of case statements based on cpu type.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.79 2001/12/22 07:35:43 smurph Exp $	*/
d1728 1
a1728 1
		trap18x(T_DATAFLT, eframe);
d1855 1
a1855 1
		trap18x(T_DATAFLT, eframe);
@


1.79
log
@rename m882xx.h to m8820x.h
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.77 2001/12/20 06:07:28 smurph Exp $	*/
d88 1
a88 1
#include <machine/cmmu.h>
a92 2
#include <machine/m88100.h>  		/* DMT_VALID        */
#include <machine/m8820x.h>  		/* CMMU stuff       */
d96 3
a227 1
extern unsigned master_cpu;
d2361 1
d2375 1
d2384 1
@


1.78
log
@MVME197 gets it's own external interrupt routine.
@
text
@d94 1
a94 1
#include <machine/m882xx.h>  		/* CMMU stuff       */
@


1.77
log
@machine dependant pointer changes.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.76 2001/12/19 07:04:42 smurph Exp $	*/
d142 3
a762 3

/* MVME197 TODO list :-) smurph */

d800 14
a813 2
	tf->epsr = PSR_USER;  /* user mode, interrupts enabled, fp enabled */
/*	tf->epsr = PSR_USER | PSR_MXM;*/  /* user mode, interrupts enabled, fp enabled, MXM Mask */
d820 1
a820 1
	 * fetched.
d822 4
a825 1

d828 1
a862 1
/* MVME197 TODO list :-) smurph */
d905 1
a905 1
	    (sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
d929 2
d934 6
d944 2
d956 13
d996 2
d1000 5
d1008 1
a1008 1
	    (sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
d1023 1
a1024 3

/* MVME197 TODO list :-) smurph */

a1068 1

d1070 2
d1075 6
d1085 2
d1097 13
d1753 1
a1753 1
#if defined(MVME187) || defined(MVME197)
d1755 1
a1755 1
sbc_ext_int(u_int v, struct m88100_saved_state *eframe)
a1853 2
#ifdef MVME187
	if (brdtyp != BRD_197) {
d1855 1
a1855 1
			trap18x(T_DATAFLT, eframe);
d1859 74
d1934 31
a1964 1
#endif
d1972 3
d1976 1
a1976 1
#endif /* defined(MVME187) || defined(MVME197) */
d2269 1
a2269 1
		printf("exip %x enip %x\n", f->sxip, f->snip);
d2283 8
a2290 18
		printf("fpsr %x ", f->fpsr);
		printf("fpcr %x ", f->fpcr);
		printf("epsr %x ", f->epsr);
		printf("ssbr %x\n", f->ssbr);
		printf("fpecr %x ", f->fpecr);
		printf("fphs1 %x ", f->fphs1);
		printf("fpls1 %x ", f->fpls1);
		printf("fphs2 %x ", f->fphs2);
		printf("fpls2 %x\n", f->fpls2);
		printf("fppt %x ", f->fppt);
		printf("fprh %x ", f->fprh);
		printf("fprl %x ", f->fprl);
		printf("fpit %x\n", f->fpit);
		printf("vector %d ", f->vector);
		printf("mask %x ", f->mask);
		printf("mode %x ", f->mode);
		printf("scratch1 %x ", f->scratch1);
		printf("cpu %x\n", f->cpu);
d2294 9
a2302 18
	if (longformat && cputyp == CPU_197) {
		printf("fpsr %x ", f->fpsr);
		printf("fpcr %x ", f->fpcr);
		printf("fpecr %x ", f->fpecr);
		printf("epsr %x\n", f->epsr);
		printf("dsap %x ", f->dmt1);
		printf("dsr %x ", f->dsr);
		printf("dlar %x ", f->dlar);
		printf("dpar %x\n", f->dpar);
		printf("isap %x ", f->dmt0);
		printf("isr %x ", f->isr);
		printf("ilar %x ", f->ilar);
		printf("ipar %x\n", f->ipar);
		printf("vector %d ", f->vector);
		printf("mask %x ", f->mask);
		printf("mode %x ", f->mode);
		printf("scratch1 %x ", f->scratch1);
		printf("cpu %x\n", f->cpu);
d2331 11
d2374 1
a2374 1
		md.interrupt_func = &sbc_ext_int;
d2382 1
a2382 1
		md.interrupt_func = &sbc_ext_int;
d2401 1
a2437 8
	
	/*
	 * Must initialize p_addr before autoconfig or
	 * the fault handler will get a NULL reference.
	 */
	proc0.p_addr = proc0paddr;
	curproc = &proc0;
	curpcb = &proc0paddr->u_pcb;
@


1.76
log
@Introduce brdtyp and change what cputyp means.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.75 2001/12/16 23:49:46 miod Exp $	*/
d126 1
a126 1
struct funcp mdfp;
a167 8
#if defined(MVME187) || defined(MVME197)
u_char *int_mask_level = (u_char *)INT_MASK_LEVEL;
u_char *int_pri_level = (u_char *)INT_PRI_LEVEL;
#endif /* defined(MVME187) || defined(MVME197) */

#if defined(MVME187) || defined(MVME197)
volatile u_char *pcc2intr_mask;
volatile u_char *pcc2intr_ipl;
a170 1
#endif /* defined(MVME187) || defined(MVME197) */
d243 3
a245 3
int boothowto; /* read in locore.S */
int bootdev;   /* read in locore.S */
int cputyp;
d437 1
a437 1
	if (mdfp.clock_init_func != NULL) {
d441 1
a441 1
		(*mdfp.clock_init_func)();
d443 1
a443 1
	if (mdfp.statclock_init_func != NULL) {
d447 1
a447 1
		(*mdfp.statclock_init_func)();
d1698 2
a1699 2
	asm volatile("ld.b	%0,%1" : "=r" (mask) : "" (*pcc2intr_mask));
	asm volatile("ld.b	%0,%1" : "=r" (level) : "" (*pcc2intr_ipl));
d2182 1
a2182 1
	bzero(&mdfp, sizeof(struct funcp));
d2199 4
a2202 2
		mdfp.interrupt_func = &m188_ext_int;
		mdfp.fp_precise_func = &m88100_Xfp_precise;
d2212 4
a2215 2
		mdfp.interrupt_func = &sbc_ext_int;
		mdfp.fp_precise_func = &m88100_Xfp_precise;
d2220 4
a2223 2
		mdfp.interrupt_func = &sbc_ext_int;
		mdfp.fp_precise_func = &m88110_Xfp_precise;
@


1.76.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.88 2002/01/23 17:51:52 art Exp $	*/
d51 1
d88 1
a88 1
#include <machine/cmmu.h>		/* CMMU stuff	*/
d93 2
a97 3
#ifdef M88100
#include <machine/m88100.h>		/* DMT_VALID	*/
#endif 
d126 1
a126 1
struct md_p md;
a141 3
void m187_ext_int __P((u_int v, struct m88100_saved_state *eframe));
void m188_ext_int __P((u_int v, struct m88100_saved_state *eframe));
void m197_ext_int __P((u_int v, struct m88100_saved_state *eframe));
d143 1
a143 1
unsigned char *volatile ivec[] = {
d160 5
a164 5
unsigned int *volatile int_mask_reg[MAX_CPUS] = {
	(unsigned int *)IEN0_REG,
	(unsigned int *)IEN1_REG,
	(unsigned int *)IEN2_REG,
	(unsigned int *)IEN3_REG
d168 8
d179 1
d197 1
d233 1
d252 3
a254 3
int boothowto;	/* set in locore.S */
int bootdev;	/* set in locore.S */
int cputyp;	/* set in locore.S */
d323 1
a323 1
	unsigned int *volatile look;
d417 1
a417 1
		p->p_md.md_upte[i] = *((pt_entry_t *)kvtopte((va + (i * NBPG))));
d424 1
a424 1
	pt_entry_t *t;
d429 1
a429 1
		*t = p->p_md.md_upte[i];
d446 1
a446 1
	if (md.clock_init_func != NULL) {
d450 1
a450 1
		(*md.clock_init_func)();
d452 1
a452 1
	if (md.statclock_init_func != NULL) {
d456 1
a456 1
		(*md.statclock_init_func)();
d665 3
d769 3
d809 2
a810 14
	
	if (cputyp == CPU_88110) {
		/* 
		 * user mode, serialize mem, interrupts enabled, 
		 * graphics unit, fp enabled 
		 */
		tf->epsr = PSR_SRM | PSR_SFD;  
	} else {
		/* 
		 * user mode, interrupts enabled, 
		 * no graphics unit, fp enabled 
		 */
		tf->epsr = PSR_SFD | PSR_SFD2;
	}
d817 1
a817 1
	 * fetched.  mc88110 - just set exip to pack->ep_entry.
d819 1
a819 4
	if (cputyp == CPU_88110) {
		tf->exip = pack->ep_entry & ~3;
		printf("exec @@ 0x%x\n", tf->exip);
	} else {
a821 1
	}
d856 1
d899 1
a899 1
	    ((sigdebug & SDB_KSTACK) && (p->p_pid == sigpid)))
a922 2
	if (cputyp != CPU_88110) {
		/* mc88100 */
a925 6
	} else {
		/* mc88110 */
		sf.sf_sc.sc_xip = tf->exip & ~3;
		sf.sf_sc.sc_nip = tf->enip & ~3;
		sf.sf_sc.sc_fip = 0;
	}
a929 2
	if (cputyp != CPU_88110) {
		/* mc88100 */
a939 13
	} else {
		/* mc88110 */
		sf.sf_sc.sc_dsr  = tf->dsr;
		sf.sf_sc.sc_dlar = tf->dlar;
		sf.sf_sc.sc_dpar = tf->dpar;
		sf.sf_sc.sc_isr  = tf->isr;
		sf.sf_sc.sc_ilar = tf->ilar;
		sf.sf_sc.sc_ipar = tf->ipar;
		sf.sf_sc.sc_isap = tf->isap;
		sf.sf_sc.sc_dsap = tf->dsap;
		sf.sf_sc.sc_iuap = tf->iuap;
		sf.sf_sc.sc_duap = tf->duap;
	}
a966 2
	if (cputyp != CPU_88110) {
		/* mc88100 */
a968 5
	} else {
		/* mc88110 */
		tf->exip = (addr & ~3);
		tf->enip = (tf->exip + 4);
	}
d972 1
a972 1
	    ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid))
d987 3
a990 1
/* ARGSUSED */
d1035 1
a1036 2
	if (cputyp != CPU_88110) {
		/* mc88100 */
a1039 6
	} else {
		/* mc88110 */
		tf->exip = (scp->sc_xip);
		tf->enip = (scp->sc_nip);
		tf->sfip = 0;
	}
a1043 2
	if (cputyp != CPU_88110) {
		/* mc88100 */
a1053 13
	} else {
		/* mc88110 */
		tf->dsr  = scp->sc_dsr;
		tf->dlar = scp->sc_dlar;
		tf->dpar = scp->sc_dpar;
		tf->isr  = scp->sc_isr;
		tf->ilar = scp->sc_ilar;
		tf->ipar = scp->sc_ipar;
		tf->isap = scp->sc_isap;
		tf->dsap = scp->sc_dsap;
		tf->iuap = scp->sc_iuap;
		tf->duap = scp->sc_duap;
	}
a1542 2
	uvmexp.intrs++;

d1564 1
a1564 1
			printf("--CPU %d halted--\n", cpu_number());
d1566 2
a1567 1
			for(;;) ;
d1589 3
a1591 4
			if (guarded_access(ivec[level], 4, (u_char *)&vec) ==
			    EFAULT) {
				panic("unable to get vector for this vmebus "
				    "interrupt (level %x)", level);
d1595 2
a1596 2
				panic("unknown onboard interrupt: mask = 0x%b",
				    1 << intbit, IST_STRING);
d1598 4
d1605 2
a1606 2
				panic("unknown hardware failure: mask = 0x%b",
				    1 << intbit, IST_STRING);
d1609 3
a1611 4
			if (guarded_access(ivec[level], 4, (u_char *)&vec) ==
			    EFAULT) {
				panic("unable to get vector for this vmebus "
				    "interrupt (level %x)", level);
d1615 2
a1616 1
				panic("vme vec timeout");
d1619 2
a1620 2
				panic("unknown vme interrupt: mask = 0x%b",
				    1 << intbit, IST_STRING);
d1623 3
a1625 3
			panic("unknown interrupt: level = %d intbit = 0x%x "
			    "mask = 0x%b",
			    level, intbit, 1 << intbit, IST_STRING);
d1628 2
a1629 3
			panic("interrupt vector 0x%x greater than 255!\n"
			    "level = %d iack = 0x%x", 
			    vec, level, ivec[level]);
d1632 1
a1632 1
		if ((intr = intr_handlers[vec]) == NULL) {
d1635 17
a1651 25
			printf("Spurious interrupt: level = %d vec = 0x%x, "
			    "intbit = %d mask = 0x%b\n",
			    level, vec, intbit, 1 << intbit, IST_STRING);
		} else {
			/*
			 * Walk through all interrupt handlers in the chain
			 * for the given vector, calling each handler in turn,
			 * till some handler returns a value != 0.
			 */
			for (ret = 0; intr; intr = intr->ih_next) {
				if (intr->ih_wantframe != 0)
					ret = (*intr->ih_fn)((void *)eframe);
				else
					ret = (*intr->ih_fn)(intr->ih_arg);
				if (ret != 0) {
					/* increment intr counter */
					intrcnt[level]++; 
					break;
				}
			}
			if (ret == 0) {
				printf("Unclaimed interrupt: level = %d "
				    "vec = 0x%x, intbit = %d mask = 0x%b\n",
				    level, vec, intbit,
				    1 << intbit, IST_STRING);
d1655 8
d1669 1
d1672 1
a1672 1
		m88100_trap(T_DATAFLT, eframe);
d1683 1
d1697 1
a1697 1
#ifdef MVME187
d1699 1
a1699 1
m187_ext_int(u_int v, struct m88100_saved_state *eframe)
d1707 2
a1708 2
	mask = *md.intr_mask;
	level = *md.intr_ipl;
d1719 1
d1729 1
a1736 2
	uvmexp.intrs++;

d1742 1
a1742 1
	flush_pipeline();
d1744 2
a1745 1
		panic("Unable to get vector for this interrupt (level %x)\n", level);
d1747 3
a1749 3
	flush_pipeline();
	flush_pipeline();
	flush_pipeline();
d1757 1
a1757 1
	if ((intr = intr_handlers[vec]) == NULL) {
d1762 5
a1766 6
	} else {
		if (intr && intr->ih_ipl != level) {
			panic("Handler ipl %x not the same as level %x. "
			    "vec = 0x%x",
			    intr->ih_ipl, level, vec);
		}
d1768 5
a1772 5
		/*
		 * Walk through all interrupt handlers in the chain for the
		 * given vector, calling each handler in turn, till some handler
		 * returns a value != 0.
		 */
d1774 9
a1782 10
		for (ret = 0; intr; intr = intr->ih_next) {
			if (intr->ih_wantframe != 0)
				ret = (*intr->ih_fn)((void *)eframe);
			else
				ret = (*intr->ih_fn)(intr->ih_arg);
			if (ret != 0) {
				/* increment intr counter */
				intrcnt[level]++; 
				break;
			}
d1784 1
d1786 3
a1788 4
		if (ret == 0) {
			printf("Unclaimed interrupt (level %x and vec %x)\n",
			    level, vec);
		}
d1797 7
a1803 62
	if (eframe->dmt0 & DMT_VALID) {
		m88100_trap(T_DATAFLT, eframe);
		data_access_emulation((unsigned *)eframe);
		eframe->dmt0 &= ~DMT_VALID;
	}
	mask = eframe->mask;

	/*
	 * Restore the mask level to what it was when the interrupt
	 * was taken.
	 */
	setipl((u_char)mask);
}
#endif /* MVME187 */

#ifdef MVME197
void
m197_ext_int(u_int v, struct m88100_saved_state *eframe)
{
	register u_char mask, level, src;
	register struct intrhand *intr;
	int ret;
	u_char vec;

	/* get src and mask */
	mask = *md.intr_mask;
	src = *md.intr_src;
	
	if (v == T_NON_MASK) {
		/* This is the abort switch */
		level = IPL_NMI;
		vec = BS_ABORTVEC;
	} else {
		/* get level  */
		level = *md.intr_ipl;
	}

	/*
	 * Interrupting level cannot be 0--0 doesn't produce an interrupt.
	 * Weird! XXX nivas
	 */

	if (level == 0) {
		panic("Bogons... level %x and mask %x\n", level, mask);
	}

	/* and block interrupts at level or lower */
	setipl((u_char)level);
	/* and stash it away in the trap frame */
	eframe->mask = mask;

	uvmexp.intrs++;

	if (level > 7 || (char)level < 0) {
		panic("int level (%x) is not between 0 and 7", level);
	}

	if (v != T_NON_MASK) {
		/* generate IACK and get the vector */
		flush_pipeline();
		if (guarded_access(ivec[level], 1, &vec) == EFAULT) {
			panic("Unable to get vector for this interrupt (level %x)\n", level);
a1804 3
		flush_pipeline();
		flush_pipeline();
		flush_pipeline();
d1806 1
a1806 44

	if (vec > 0xFF) {
		panic("interrupt vector %x greater than 255", vec);
	}

	enable_interrupt();

	if ((intr = intr_handlers[vec]) == NULL) {
		/* increment intr counter */
		intrcnt[M88K_SPUR_IRQ]++; 
		printf("Spurious interrupt (level %x and vec %x)\n",
		       level, vec);
	} else {
		if (intr && intr->ih_ipl != level) {
			panic("Handler ipl %x not the same as level %x. "
			    "vec = 0x%x",
			    intr->ih_ipl, level, vec);
		}

		/*
		 * Walk through all interrupt handlers in the chain for the
		 * given vector, calling each handler in turn, till some handler
		 * returns a value != 0.
		 */
		for (ret = 0; intr; intr = intr->ih_next) {
			if (intr->ih_wantframe != 0)
				ret = (*intr->ih_fn)((void *)eframe);
			else
				ret = (*intr->ih_fn)(intr->ih_arg);
			if (ret != 0) {
				/* increment intr counter */
				intrcnt[level]++; 
				break;
			}
		}

		if (ret == 0) {
			printf("Unclaimed interrupt (level %x and vec %x)\n",
			    level, vec);
		}
	}

	disable_interrupt();

d1815 1
a1815 1
#endif 
d2108 1
a2108 1
		printf("exip %x enip %x\n", f->exip, f->enip);
d2122 18
a2139 8
		printf("fpsr %x fpcr %x epsr %x ssbr %x\n", 
		       f->fpsr, f->fpcr, f->epsr, f->ssbr);
		printf("fpecr %x fphs1 %x fpls1 %x fphs2 %x fpls2 %x\n", 
		       f->fpecr, f->fphs1, f->fpls1, f->fphs2, f->fpls2);
		printf("fppt %x fprh %x fprl %x fpit %x\n", 
		       f->fppt, f->fprh, f->fprl, f->fpit);
		printf("vector %d mask %x mode %x scratch1 %x cpu %x\n", 
		       f->vector, f->mask, f->mode, f->scratch1, f->cpu);
d2143 18
a2160 9
	if (longformat && cputyp == CPU_88110) {
		printf("fpsr %x fpcr %x fpecr %x epsr %x\n", 
		       f->fpsr, f->fpcr, f->fpecr, f->epsr);
		printf("dsap %x duap %x dsr %x dlar %x dpar %x\n",
		       f->dsap, f->duap, f->dsr, f->dlar, f->dpar);
		printf("isap %x iuap %x isr %x ilar %x ipar %x\n",
		       f->isap, f->iuap, f->isr, f->ilar, f->ipar);
		printf("vector %d mask %x mode %x scratch1 %x cpu %x\n", 
		       f->vector, f->mask, f->mode, f->scratch1, f->cpu);
d2167 1
a2167 1
		istr = *(int *volatile)IST_REG;
a2188 11
	
	
	/*
	 * Must initialize p_addr before autoconfig or
	 * the fault handler will get a NULL reference.
	 * Do this early so that we can take a data or 
	 * instruction fault and survive it. XXX smurph
	 */
	proc0.p_addr = proc0paddr;
	curproc = &proc0;
	curpcb = &proc0paddr->u_pcb;
d2191 1
a2191 1
	bzero(&md, sizeof(struct md_p));
d2208 2
a2209 5
		cmmu = &cmmu8820x;
		md.interrupt_func = &m188_ext_int;
		md.intr_mask = NULL;
		md.intr_ipl = NULL;
		md.intr_src = NULL;
d2219 2
a2220 5
		cmmu = &cmmu8820x;
		md.interrupt_func = &m187_ext_int;
		md.intr_mask = (u_char *)M187_IMASK;
		md.intr_ipl = (u_char *)M187_ILEVEL;
		md.intr_src = NULL;
d2225 2
a2226 5
		cmmu = &cmmu88110;
		md.interrupt_func = &m197_ext_int;
		md.intr_mask = (u_char *)M197_IMASK;
		md.intr_ipl = (u_char *)M197_ILEVEL;
		md.intr_src = (u_char *)M197_ISRC;
a2241 1

d2278 8
@


1.76.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.76.2.1 2002/01/31 22:55:19 niklas Exp $	*/
d129 16
a144 16
void m88100_Xfp_precise(void);
void m88110_Xfp_precise(void);
void setupiackvectors(void);
void regdump(struct trapframe *f);
void dumpsys(void);
void consinit(void);
vm_offset_t size_memory(void);
int getcpuspeed(void);
int getscsiid(void);
void identifycpu(void);
void save_u_area(struct proc *, vm_offset_t);
void load_u_area(struct proc *);
void dumpconf(void);
void m187_ext_int(u_int v, struct m88100_saved_state *eframe);
void m188_ext_int(u_int v, struct m88100_saved_state *eframe);
void m197_ext_int(u_int v, struct m88100_saved_state *eframe);
a212 5

#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif

a217 1
int   bufcachepercent = BUFCACHEPERCENT;
d219 1
a219 1
caddr_t allocsys(caddr_t);
d264 5
a268 5
void bootcnprobe(struct consdev *);
void bootcninit(struct consdev *);
void bootcnputc(dev_t, int);
int  bootcngetc(dev_t);
extern void nullcnpollc(dev_t, int);
d324 3
a326 3
	max = (void *)MAXPHYSMEM;
	for (look = (void *)Roundup(end, STRIDE); look < max;
	    look = (int *)((unsigned)look + STRIDE)) {
d362 1
a362 1
	struct mvmeprom_brdid brdid;
d379 1
a379 1
	struct mvmeprom_brdid brdid;
a701 3
	shminfo.shmmax = shmmaxpgs;
	shminfo.shmall = shmmaxpgs;
	shminfo.shmseg = shmseg;
d717 3
d731 1
a731 1
			    bufcachepercent / 100;
d1015 1
a1015 1
 * psl to gain improper privileges or to cause
a1178 1

d1263 1
a1263 1
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
d2159 1
a2159 1
	struct mvmeprom_brdid brdid;
d2317 1
a2317 1
	extern void set_tcfp(void);
d2319 2
a2320 1
	struct mvmeprom_brdid brdid;
d2337 1
a2337 1
	brdtyp = brdid.model;
@


1.76.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.76.2.2 2002/06/11 03:37:11 art Exp $	*/
d879 3
d996 1
a996 1
	addr = p->p_sigcode;
d1684 1
a1684 1
			panic("interrupt vector 0x%x greater than 255!"
d1773 1
a1773 1
		panic("mask == level, %d", level);
d1782 1
a1782 1
		panic("Bogons... level %x and mask %x", level, mask);
d1799 1
a1799 1
		panic("Unable to get vector for this interrupt (level %x)", level);
d1896 1
a1896 1
		panic("Bogons... level %x and mask %x", level, mask);
d1914 1
a1914 1
			panic("Unable to get vector for this interrupt (level %x)", level);
@


1.76.2.4
log
@sync
@
text
@d1 1
a1 1
/* $OpenBSD$	*/
d66 6
a135 1
vm_offset_t memsize187(void);
d188 1
a188 1
int   safepri = IPL_NONE;
a312 23
#ifdef MVME187
/*
 * Figure out how much memory is available, by querying the memory controllers
 */
#include <mvme88k/dev/memcreg.h>
vm_offset_t
memsize187()
{
	struct memcreg *memc;
	vm_offset_t x;

	memc = (struct memcreg *)0xfff43000;
	x = MEMC_MEMCONF_RTOB(memc->memc_memconf);

	memc = (struct memcreg *)0xfff43100;
	if (!badaddr((vm_offset_t)&memc->memc_memconf, 1))
		x += MEMC_MEMCONF_RTOB(memc->memc_memconf);

	return x;
}
#endif

#if defined(MVME188) || defined(MVME197)
d361 1
a363 1
#endif	/* defined(MVME188) || defined(MVME197) */
d403 1
a403 3
	snprintf(cpu_model, sizeof cpu_model,
	    "Motorola MVME%x, %dMHz", brdtyp, cpuspeed);
	printf("\nModel: %s\n", cpu_model);
d707 12
d1734 1
a1734 1
	setipl(eframe->mask);
d1759 2
a1760 2
	mask = *md.intr_mask & 0x07;
	level = *md.intr_ipl & 0x07;
d1783 1
a1783 1
	setipl(level);
d1789 4
d1802 1
a1802 1
	if (vec > 0xff) {
a1854 1

d1861 1
a1861 1
	setipl(mask);
d1875 1
a1875 1
	mask = *md.intr_mask & 0x07;
d1884 1
a1884 1
		level = *md.intr_ipl & 0x07;
d1897 1
a1897 1
	setipl(level);
d1903 4
d1918 1
a1918 1
	if (vec > 0xff) {
d1967 1
a1967 1
	setipl(mask);
d2395 1
a2395 16
	switch (brdtyp) {
#ifdef MVME187
	case BRD_187:
		last_addr = memsize187();
		break;
#endif
#ifdef MVME188
	case BRD_188:
#endif
#ifdef MVME197
	case BRD_197:
#endif
		last_addr = size_memory();
		break;
	}
	physmem = btoc(last_addr);
@


1.75
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.71 2001/12/08 18:05:59 miod Exp $	*/
d105 1
d255 2
d288 2
a289 1
	1};
d358 1
a358 1
	if ((look > (unsigned int *)0x01FFF000) && (cputyp == CPU_188)) {
d362 1
d405 1
a405 2
	sprintf(cpu_model, "Motorola MVME%x %dMhz", cputyp, cpuspeed);
	printf("\nModel: %s\n", cpu_model);
d524 1
a524 1
	switch (cputyp) {
d526 15
a540 1
	case CPU_187:
d543 1
a543 1
	case CPU_197:
a544 1

a561 15
		 * Grab the SRAM space that we hardwired in pmap_bootstrap
		 */
		sramva = SRAM_START;
		uvm_map(kernel_map, (vaddr_t *)&sramva, SRAM_SIZE,
			NULL, UVM_UNKNOWN_OFFSET, 0, UVM_MAPFLAG(UVM_PROT_NONE, 
							     UVM_PROT_NONE,
							     UVM_INH_NONE,
							     UVM_ADV_NORMAL, 0));

		if (sramva != SRAM_START) {
			printf("sramva %x: SRAM not free\n", sramva);
			panic("bad sramva");
		}

		/*
d577 1
a577 1
	case CPU_188:
d1329 1
a1329 1
	switch (cputyp) {
d1331 1
a1331 1
	case CPU_187:
d1340 1
a1340 1
	case CPU_188:
d1355 1
a1355 1
		*ivec[8] = M188_IVEC;	/* supply a vector for m188ih */
d1359 1
a1359 1
	case CPU_197:
d1373 1
a1373 1
	if (cputyp != CPU_188) {
d1799 1
a1799 1
	if (cputyp != CPU_197) {
d2107 1
a2107 1
	if (cputyp == CPU_197) {
d2112 2
a2113 2
#if defined(MVME187) || defined(MVME188)
	if (f->vector == 0x3 && cputyp != CPU_197) {
d2121 1
a2121 1
	if (longformat && cputyp != CPU_197) {
d2142 1
a2142 1
#ifdef MVME197
d2164 1
a2164 1
	if (cputyp == CPU_188 ) {
d2195 1
a2195 1
	cputyp = brdid.brdno;
d2198 2
a2199 2
	if (cputyp == 0x8120)
		cputyp = CPU_187;
d2205 1
a2205 1
	switch (cputyp) {
d2207 1
a2207 1
	case CPU_188:
d2218 1
a2218 1
	case CPU_187:
d2224 1
a2224 1
	case CPU_197:
d2251 1
a2251 1
	if (cputyp == CPU_188 && (boothowto & RB_MINIROOT)) {
d2265 1
d2267 1
a2267 1
	printf("MVME%x boot: memory from 0x%x to 0x%x\n", cputyp, avail_start, avail_end);
a2271 1

@


1.74
log
@Repair MVME187 after MVME197 merge.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.73 2001/12/14 01:33:50 miod Exp $	*/
d88 1
a88 1
#include <machine/cmmu.h>		/* CMMU stuff	*/
d93 2
a97 3
#ifdef M88100
#include <machine/m88100.h>		/* DMT_VALID	*/
#endif 
a104 1
#include <mvme88k/dev/busswreg.h>
d125 1
a125 1
struct md_p md;
a129 1
void set_tcfp __P((void));
d138 2
a139 2
void save_u_area __P((struct proc *p, vm_offset_t va));
void load_u_area __P((struct proc *p));
a140 3
void m187_ext_int __P((u_int v, struct m88100_saved_state *eframe));
void m188_ext_int __P((u_int v, struct m88100_saved_state *eframe));
void m197_ext_int __P((u_int v, struct m88100_saved_state *eframe));
d167 8
d178 1
d232 1
d251 3
a253 5
int boothowto;	/* set in locore.S */
int bootdev;	/* set in locore.S */
int cputyp;	/* set in locore.S */
int brdtyp;	/* set in locore.S */
int cpumod = 0; /* set in mvme_bootstrap.S */
d285 1
a285 2
	1
};
d354 1
a354 1
	if ((look > (unsigned int *)0x01FFF000) && (brdtyp == BRD_188)) {
a357 1
	
d397 1
a397 1
identifycpu(void)
d400 2
a401 1
	printf("\nModel: Motorola MVME%x %dMhz\n", brdtyp, cpuspeed);
d442 1
a442 1
	if (md.clock_init_func != NULL) {
d446 1
a446 1
		(*md.clock_init_func)();
d448 1
a448 1
	if (md.statclock_init_func != NULL) {
d452 1
a452 1
		(*md.statclock_init_func)();
d491 1
a491 1
	
d520 1
a520 1
	switch (brdtyp) {
d522 1
a522 15
	case BRD_187:
		/*
		 * Grab the SRAM space that we hardwired in pmap_bootstrap
		 */
		sramva = SRAM_START;
		uvm_map(kernel_map, (vaddr_t *)&sramva, SRAM_SIZE,
			NULL, UVM_UNKNOWN_OFFSET, 0, UVM_MAPFLAG(UVM_PROT_NONE, 
							     UVM_PROT_NONE,
							     UVM_INH_NONE,
							     UVM_ADV_NORMAL, 0));

		if (sramva != SRAM_START) {
			printf("sramva %x: SRAM not free\n", sramva);
			panic("bad sramva");
		}
d525 1
a525 1
	case BRD_197:
d527 1
d545 15
d575 1
a575 1
	case BRD_188:
d767 3
d807 2
a808 14
	
	if (cputyp == CPU_88110) {
		/* 
		 * user mode, serialize mem, interrupts enabled, 
		 * graphics unit, fp enabled 
		 */
		tf->epsr = PSR_SRM | PSR_SFD;  
	} else {
		/* 
		 * user mode, interrupts enabled, 
		 * no graphics unit, fp enabled 
		 */
		tf->epsr = PSR_SFD | PSR_SFD2;
	}
d815 1
a815 1
	 * fetched.  mc88110 - just set exip to pack->ep_entry.
d817 3
a819 6
	if (cputyp == CPU_88110) {
		tf->exip = pack->ep_entry & ~3;
	} else {
		tf->snip = pack->ep_entry & ~3;
		tf->sfip = (pack->ep_entry & ~3) | FIP_V;
	}
d854 1
d897 1
a897 1
	    ((sigdebug & SDB_KSTACK) && (p->p_pid == sigpid)))
d921 3
a923 11
	if (cputyp != CPU_88110) {
		/* mc88100 */
		sf.sf_sc.sc_xip = tf->sxip & ~3;
		sf.sf_sc.sc_nip = tf->snip & ~3;
		sf.sf_sc.sc_fip = tf->sfip & ~3;
	} else {
		/* mc88110 */
		sf.sf_sc.sc_xip = tf->exip & ~3;
		sf.sf_sc.sc_nip = tf->enip & ~3;
		sf.sf_sc.sc_fip = 0;
	}
d928 10
a937 25
	if (cputyp != CPU_88110) {
		/* mc88100 */
		sf.sf_sc.sc_ssbr = tf->ssbr;
		sf.sf_sc.sc_dmt0 = tf->dmt0;
		sf.sf_sc.sc_dmd0 = tf->dmd0;
		sf.sf_sc.sc_dma0 = tf->dma0;
		sf.sf_sc.sc_dmt1 = tf->dmt1;
		sf.sf_sc.sc_dmd1 = tf->dmd1;
		sf.sf_sc.sc_dma1 = tf->dma1;
		sf.sf_sc.sc_dmt2 = tf->dmt2;
		sf.sf_sc.sc_dmd2 = tf->dmd2;
		sf.sf_sc.sc_dma2 = tf->dma2;
	} else {
		/* mc88110 */
		sf.sf_sc.sc_dsr  = tf->dsr;
		sf.sf_sc.sc_dlar = tf->dlar;
		sf.sf_sc.sc_dpar = tf->dpar;
		sf.sf_sc.sc_isr  = tf->isr;
		sf.sf_sc.sc_ilar = tf->ilar;
		sf.sf_sc.sc_ipar = tf->ipar;
		sf.sf_sc.sc_isap = tf->isap;
		sf.sf_sc.sc_dsap = tf->dsap;
		sf.sf_sc.sc_iuap = tf->iuap;
		sf.sf_sc.sc_duap = tf->duap;
	}
d965 2
a966 9
	if (cputyp != CPU_88110) {
		/* mc88100 */
		tf->snip = (addr & ~3) | NIP_V;
		tf->sfip = (tf->snip + 4) | FIP_V;
	} else {
		/* mc88110 */
		tf->exip = (addr & ~3);
		tf->enip = (tf->exip + 4);
	}
d970 1
a970 1
	    ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid))
d985 3
a988 1
/* ARGSUSED */
d1033 1
d1035 3
a1037 11
	if (cputyp != CPU_88110) {
		/* mc88100 */
		tf->sxip = (scp->sc_xip) | XIP_V;
		tf->snip = (scp->sc_nip) | NIP_V;
		tf->sfip = (scp->sc_fip) | FIP_V;
	} else {
		/* mc88110 */
		tf->exip = (scp->sc_xip);
		tf->enip = (scp->sc_nip);
		tf->sfip = 0;
	}
d1042 10
a1051 25
	if (cputyp != CPU_88110) {
		/* mc88100 */
		tf->ssbr = scp->sc_ssbr;
		tf->dmt0 = scp->sc_dmt0;
		tf->dmd0 = scp->sc_dmd0;
		tf->dma0 = scp->sc_dma0;
		tf->dmt1 = scp->sc_dmt1;
		tf->dmd1 = scp->sc_dmd1;
		tf->dma1 = scp->sc_dma1;
		tf->dmt2 = scp->sc_dmt2;
		tf->dmd2 = scp->sc_dmd2;
		tf->dma2 = scp->sc_dma2;
	} else {
		/* mc88110 */
		tf->dsr  = scp->sc_dsr;
		tf->dlar = scp->sc_dlar;
		tf->dpar = scp->sc_dpar;
		tf->isr  = scp->sc_isr;
		tf->ilar = scp->sc_ilar;
		tf->ipar = scp->sc_ipar;
		tf->isap = scp->sc_isap;
		tf->dsap = scp->sc_dsap;
		tf->iuap = scp->sc_iuap;
		tf->duap = scp->sc_duap;
	}
d1161 1
a1161 1
dumpconf(void)
d1327 1
a1327 1
	switch (brdtyp) {
d1329 1
a1329 1
	case BRD_187:
d1338 1
a1338 1
	case BRD_188:
d1353 1
a1353 1
		*ivec[8] = M188_IVEC;	/* supply a vector base for m188ih */
d1357 1
a1357 1
	case BRD_197:
d1371 1
a1371 1
	if (brdtyp != BRD_188) {
d1670 1
a1670 1
		m88100_trap(T_DATAFLT, eframe);
d1695 1
a1695 1
#ifdef MVME187
d1697 1
a1697 1
m187_ext_int(u_int v, struct m88100_saved_state *eframe)
d1705 2
a1706 2
	asm volatile("ld.b	%0,%1" : "=r" (mask) : "" (*md.intr_mask));
	asm volatile("ld.b	%0,%1" : "=r" (level) : "" (*md.intr_ipl));
d1796 6
a1801 62
	if (eframe->dmt0 & DMT_VALID) {
		trap(T_DATAFLT, eframe);
		data_access_emulation((unsigned *)eframe);
		eframe->dmt0 &= ~DMT_VALID;
	}
	mask = eframe->mask;

	/*
	 * Restore the mask level to what it was when the interrupt
	 * was taken.
	 */
	setipl((u_char)mask);
}
#endif /* MVME187 */

#ifdef MVME197
void
m197_ext_int(u_int v, struct m88100_saved_state *eframe)
{
	register u_char mask, level, src;
	register struct intrhand *intr;
	int ret;
	u_char vec;

	/* get src and mask */
	asm volatile("ld.b	%0,%1" : "=r" (mask) : "" (*md.intr_mask));
	asm volatile("ld.b	%0,%1" : "=r" (src) : "" (*md.intr_src));
	
	if (v == T_NON_MASK) {
		/* This is the abort switch */
		level = IPL_NMI;
		vec = BS_ABORTVEC;
	} else {
		/* get level  */
		asm volatile("ld.b	%0,%1" : "=r" (level) : "" (*md.intr_ipl));
	}

	/*
	 * Interrupting level cannot be 0--0 doesn't produce an interrupt.
	 * Weird! XXX nivas
	 */

	if (level == 0) {
		printf("Bogons... level %x and mask %x\n", level, mask);
		goto m197beatit;
	}

	/* and block interrupts at level or lower */
	setipl((u_char)level);
	/* and stash it away in the trap frame */
	eframe->mask = mask;

	if (level > 7 || (char)level < 0) {
		panic("int level (%x) is not between 0 and 7", level);
	}

	if (v != T_NON_MASK) {
		/* generate IACK and get the vector */
		asm volatile("tb1	0, r0, 0"); 
		if (guarded_access(ivec[level], 1, &vec) == EFAULT) {
			printf("Unable to get vector for this interrupt (level %x)\n", level);
			goto m197out;
a1802 3
		asm volatile("tb1	0, r0, 0"); 
		asm volatile("tb1	0, r0, 0"); 
		asm volatile("tb1	0, r0, 0");
d1804 1
a1804 44

	if (vec > 0xFF) {
		panic("interrupt vector %x greater than 255", vec);
	}

	enable_interrupt();

	if ((intr = intr_handlers[vec]) == 0) {
		/* increment intr counter */
		intrcnt[M88K_SPUR_IRQ]++; 
		printf("Spurious interrupt (level %x and vec %x)\n",
		       level, vec);
	}
	if (intr && intr->ih_ipl != level) {
		panic("Handler ipl %x not the same as level %x. vec = 0x%x",
		      intr->ih_ipl, level, vec);
	}

	/*
	 * Walk through all interrupt handlers in the chain for the
	 * given vector, calling each handler in turn, till some handler
	 * returns a value != 0.
	 */

	for (ret = 0; intr; intr = intr->ih_next) {
		if (intr->ih_wantframe != 0)
			ret = (*intr->ih_fn)((void *)eframe);
		else
			ret = (*intr->ih_fn)(intr->ih_arg);
		if (ret){
			/* increment intr counter */
			intrcnt[level]++; 
			break;
		}
	}

	if (ret == 0) {
		printf("Unclaimed interrupt (level %x and vec %x)\n",
		       level, vec);
	}

	disable_interrupt();

m197out:
a1811 3

m197beatit:
	return;
d1813 1
a1813 1
#endif 
d2105 2
a2106 2
	if (cputyp == CPU_88110) {
		printf("exip %x enip %x\n", f->exip, f->enip);
d2110 2
a2111 2
#ifdef M88100
	if (f->vector == 0x3 && cputyp != CPU_88110) {
d2119 19
a2137 9
	if (longformat && cputyp != CPU_88110) {
		printf("fpsr %x fpcr %x epsr %x ssbr %x\n", 
		       f->fpsr, f->fpcr, f->epsr, f->ssbr);
		printf("fpecr %x fphs1 %x fpls1 %x fphs2 %x fpls2 %x\n", 
		       f->fpecr, f->fphs1, f->fpls1, f->fphs2, f->fpls2);
		printf("fppt %x fprh %x fprl %x fpit %x\n", 
		       f->fppt, f->fprh, f->fprl, f->fpit);
		printf("vector %d mask %x mode %x scratch1 %x cpu %x\n", 
		       f->vector, f->mask, f->mode, f->scratch1, f->cpu);
d2140 19
a2158 10
#ifdef M88110
	if (longformat && cputyp == CPU_88110) {
		printf("fpsr %x fpcr %x fpecr %x epsr %x\n", 
		       f->fpsr, f->fpcr, f->fpecr, f->epsr);
		printf("dsap %x duap %x dsr %x dlar %x dpar %x\n",
		       f->dsap, f->duap, f->dsr, f->dlar, f->dpar);
		printf("isap %x iuap %x isr %x ilar %x ipar %x\n",
		       f->isap, f->iuap, f->isr, f->ilar, f->ipar);
		printf("vector %d mask %x mode %x scratch1 %x cpu %x\n", 
		       f->vector, f->mask, f->mode, f->scratch1, f->cpu);
d2162 1
a2162 1
	if (brdtyp == BRD_188 ) {
a2177 1
#define ILLADDRESS	U(0x0F000000) 	/* any faulty address */
a2186 12
	
	cold = 1;  /* we are still booting */
	
	/*
	 * Must initialize p_addr before autoconfig or
	 * the fault handler will get a NULL reference.
	 * Do this early so that we can take a data or 
	 * instruction fault and survive it. XXX smurph
	 */
	proc0.p_addr = proc0paddr;
	curproc = &proc0;
	curpcb = &proc0paddr->u_pcb;
d2189 1
a2189 1
	bzero(&md, sizeof(struct md_p));
d2193 1
a2193 1
	brdtyp = brdid.brdno;
d2196 2
a2197 2
	if (brdtyp == BRD_8120)
		brdtyp = BRD_187;
d2200 2
a2201 2
	 * set up interrupt, fp exception handlers 
	 * and cmmu pointers based on the machine.
d2203 1
a2203 1
	switch (brdtyp) {
d2205 3
a2207 6
	case BRD_188:
		cmmu = &cmmu8820x;
		md.interrupt_func = &m188_ext_int;
		md.fp_precise_func = &m88100_Xfp_precise;
		md.trap_func = &m88100_trap;
		md.syscall_func = &m88100_syscall;
d2216 3
a2218 9
	case BRD_187:
		cmmu = &cmmu8820x;
		md.interrupt_func = &m187_ext_int;
		md.fp_precise_func = &m88100_Xfp_precise;
		md.trap_func = &m88100_trap;
		md.syscall_func = &m88100_syscall;
		md.intr_mask = (u_char *)M187_IMASK;
		md.intr_ipl = (u_char *)M187_ILEVEL;
		md.intr_src = NULL;
d2222 3
a2224 9
	case BRD_197:
		cmmu = &cmmu88110;
		md.interrupt_func = &m197_ext_int;
		md.fp_precise_func = &m88110_Xfp_precise;
		md.trap_func = &m88110_trap;
		md.syscall_func = &m88110_syscall;
		md.intr_mask = (u_char *)M197_IMASK;
		md.intr_ipl = (u_char *)M197_ILEVEL;
		md.intr_src = (u_char *)M197_ISRC;
a2239 1

d2249 1
a2249 1
	if (brdtyp == BRD_188 && (boothowto & RB_MINIROOT)) {
a2262 1

d2264 1
a2264 1
	printf("MVME%x boot: memory from 0x%x to 0x%x\n", brdtyp, avail_start, avail_end);
d2269 1
d2277 8
@


1.73
log
@Uncle miod had a GENERIC mvme88k and he wanted the kernel to compile, eieio...
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.72 2001/12/13 08:55:52 smurph Exp $	*/
d88 1
a88 1
#include <machine/cmmu.h>		/* CMMU stuff       */
d97 2
a98 2
#include <machine/m88100.h>
#endif
@


1.72
log
@Support for MVME197 completed.  Fix SPL defs.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.71 2001/12/08 18:05:59 miod Exp $	*/
d96 3
d527 1
a527 1
			NULL, UVM_UNKNOWN_OFFSET,UVM_MAPFLAG(UVM_PROT_NONE, 
d1728 1
a1728 1
		trap18x(T_DATAFLT, eframe);
@


1.71
log
@Be 9600-bauds friendly and panic() on unexpected issues, rather than printf()
in loop.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.70 2001/12/08 02:24:06 art Exp $	*/
d88 1
a88 1
#include <machine/cmmu.h>
a92 2
#include <machine/m88100.h>  		/* DMT_VALID        */
#include <machine/m882xx.h>  		/* CMMU stuff       */
d103 1
d124 1
a124 1
struct funcp mdfp;
d129 1
d138 2
a139 2
void save_u_area __P((struct proc *, vm_offset_t));
void load_u_area __P((struct proc *));
d141 3
a169 8
#if defined(MVME187) || defined(MVME197)
u_char *int_mask_level = (u_char *)INT_MASK_LEVEL;
u_char *int_pri_level = (u_char *)INT_PRI_LEVEL;
#endif /* defined(MVME187) || defined(MVME197) */

#if defined(MVME187) || defined(MVME197)
volatile u_char *pcc2intr_mask;
volatile u_char *pcc2intr_ipl;
a172 1
#endif /* defined(MVME187) || defined(MVME197) */
a225 1
extern unsigned master_cpu;
d244 5
a248 3
int boothowto; /* read in locore.S */
int bootdev;   /* read in locore.S */
int cputyp;
d280 2
a281 1
	1};
d350 1
a350 1
	if ((look > (unsigned int *)0x01FFF000) && (cputyp == CPU_188)) {
d354 1
d394 1
a394 1
identifycpu()
d397 1
a397 2
	sprintf(cpu_model, "Motorola MVME%x %dMhz", cputyp, cpuspeed);
	printf("\nModel: %s\n", cpu_model);
d438 1
a438 1
	if (mdfp.clock_init_func != NULL) {
d442 1
a442 1
		(*mdfp.clock_init_func)();
d444 1
a444 1
	if (mdfp.statclock_init_func != NULL) {
d448 1
a448 1
		(*mdfp.statclock_init_func)();
d487 1
a487 1

d516 1
a516 1
	switch (cputyp) {
d518 15
a532 1
	case CPU_187:
d535 1
a535 1
	case CPU_197:
a536 1

a553 15
		 * Grab the SRAM space that we hardwired in pmap_bootstrap
		 */
		sramva = SRAM_START;
		uvm_map(kernel_map, (vaddr_t *)&sramva, SRAM_SIZE,
			NULL, UVM_UNKNOWN_OFFSET, 0, UVM_MAPFLAG(UVM_PROT_NONE, 
							     UVM_PROT_NONE,
							     UVM_INH_NONE,
							     UVM_ADV_NORMAL, 0));

		if (sramva != SRAM_START) {
			printf("sramva %x: SRAM not free\n", sramva);
			panic("bad sramva");
		}

		/*
d569 1
a569 1
	case CPU_188:
a760 3

/* MVME197 TODO list :-) smurph */

d798 14
a811 2
	tf->epsr = PSR_USER;  /* user mode, interrupts enabled, fp enabled */
/*	tf->epsr = PSR_USER | PSR_MXM;*/  /* user mode, interrupts enabled, fp enabled, MXM Mask */
d818 1
a818 1
	 * fetched.
d820 6
a825 3

	tf->snip = pack->ep_entry & ~3;
	tf->sfip = (pack->ep_entry & ~3) | FIP_V;
a859 1
/* MVME197 TODO list :-) smurph */
d902 1
a902 1
	    (sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
d926 11
a936 3
	sf.sf_sc.sc_xip = tf->sxip & ~3;
	sf.sf_sc.sc_nip = tf->snip & ~3;
	sf.sf_sc.sc_fip = tf->sfip & ~3;
d941 25
a965 10
	sf.sf_sc.sc_ssbr = tf->ssbr;
	sf.sf_sc.sc_dmt0 = tf->dmt0;
	sf.sf_sc.sc_dmd0 = tf->dmd0;
	sf.sf_sc.sc_dma0 = tf->dma0;
	sf.sf_sc.sc_dmt1 = tf->dmt1;
	sf.sf_sc.sc_dmd1 = tf->dmd1;
	sf.sf_sc.sc_dma1 = tf->dma1;
	sf.sf_sc.sc_dmt2 = tf->dmt2;
	sf.sf_sc.sc_dmd2 = tf->dmd2;
	sf.sf_sc.sc_dma2 = tf->dma2;
d993 9
a1001 2
	tf->snip = (addr & ~3) | NIP_V;
	tf->sfip = (tf->snip + 4) | FIP_V;
d1005 1
a1005 1
	    (sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
d1020 1
a1021 3

/* MVME197 TODO list :-) smurph */

a1065 1

d1067 11
a1077 3
	tf->sxip = (scp->sc_xip) | XIP_V;
	tf->snip = (scp->sc_nip) | NIP_V;
	tf->sfip = (scp->sc_fip) | FIP_V;
d1082 25
a1106 10
	tf->ssbr = scp->sc_ssbr;
	tf->dmt0 = scp->sc_dmt0;
	tf->dmd0 = scp->sc_dmd0;
	tf->dma0 = scp->sc_dma0;
	tf->dmt1 = scp->sc_dmt1;
	tf->dmd1 = scp->sc_dmd1;
	tf->dma1 = scp->sc_dma1;
	tf->dmt2 = scp->sc_dmt2;
	tf->dmd2 = scp->sc_dmd2;
	tf->dma2 = scp->sc_dma2;
d1216 1
a1216 1
dumpconf()
d1382 1
a1382 1
	switch (cputyp) {
d1384 1
a1384 1
	case CPU_187:
d1393 1
a1393 1
	case CPU_188:
d1408 1
a1408 1
		*ivec[8] = M188_IVEC;	/* supply a vector for m188ih */
d1412 1
a1412 1
	case CPU_197:
d1426 1
a1426 1
	if (cputyp != CPU_188) {
d1750 1
a1750 1
#if defined(MVME187) || defined(MVME197)
d1752 1
a1752 1
sbc_ext_int(u_int v, struct m88100_saved_state *eframe)
d1760 2
a1761 2
	asm volatile("ld.b	%0,%1" : "=r" (mask) : "" (*pcc2intr_mask));
	asm volatile("ld.b	%0,%1" : "=r" (level) : "" (*pcc2intr_ipl));
d1851 100
a1950 6
#ifdef MVME187
	if (cputyp != CPU_197) {
		if (eframe->dmt0 & DMT_VALID) {
			trap18x(T_DATAFLT, eframe);
			data_access_emulation((unsigned *)eframe);
			eframe->dmt0 &= ~DMT_VALID;
d1953 9
a1961 1
#endif
d1969 3
d1973 1
a1973 1
#endif /* defined(MVME187) || defined(MVME197) */
d2265 2
a2266 2
	if (cputyp == CPU_197) {
		printf("exip %x enip %x\n", f->sxip, f->snip);
d2270 2
a2271 2
#if defined(MVME187) || defined(MVME188)
	if (f->vector == 0x3 && cputyp != CPU_197) {
d2279 9
a2287 19
	if (longformat && cputyp != CPU_197) {
		printf("fpsr %x ", f->fpsr);
		printf("fpcr %x ", f->fpcr);
		printf("epsr %x ", f->epsr);
		printf("ssbr %x\n", f->ssbr);
		printf("fpecr %x ", f->fpecr);
		printf("fphs1 %x ", f->fphs1);
		printf("fpls1 %x ", f->fpls1);
		printf("fphs2 %x ", f->fphs2);
		printf("fpls2 %x\n", f->fpls2);
		printf("fppt %x ", f->fppt);
		printf("fprh %x ", f->fprh);
		printf("fprl %x ", f->fprl);
		printf("fpit %x\n", f->fpit);
		printf("vector %d ", f->vector);
		printf("mask %x ", f->mask);
		printf("mode %x ", f->mode);
		printf("scratch1 %x ", f->scratch1);
		printf("cpu %x\n", f->cpu);
d2290 10
a2299 19
#ifdef MVME197
	if (longformat && cputyp == CPU_197) {
		printf("fpsr %x ", f->fpsr);
		printf("fpcr %x ", f->fpcr);
		printf("fpecr %x ", f->fpecr);
		printf("epsr %x\n", f->epsr);
		printf("dsap %x ", f->dmt1);
		printf("dsr %x ", f->dsr);
		printf("dlar %x ", f->dlar);
		printf("dpar %x\n", f->dpar);
		printf("isap %x ", f->dmt0);
		printf("isr %x ", f->isr);
		printf("ilar %x ", f->ilar);
		printf("ipar %x\n", f->ipar);
		printf("vector %d ", f->vector);
		printf("mask %x ", f->mask);
		printf("mode %x ", f->mode);
		printf("scratch1 %x ", f->scratch1);
		printf("cpu %x\n", f->cpu);
d2303 1
a2303 1
	if (cputyp == CPU_188 ) {
d2319 1
d2329 12
d2343 1
a2343 1
	bzero(&mdfp, sizeof(struct funcp));
d2347 1
a2347 1
	cputyp = brdid.brdno;
d2350 2
a2351 2
	if (cputyp == 0x8120)
		cputyp = CPU_187;
d2354 2
a2355 2
	 * set up interrupt and fp exception handlers 
	 * based on the machine.
d2357 1
a2357 1
	switch (cputyp) {
d2359 6
a2364 3
	case CPU_188:
		mdfp.interrupt_func = &m188_ext_int;
		mdfp.fp_precise_func = &m88100_Xfp_precise;
d2373 9
a2381 3
	case CPU_187:
		mdfp.interrupt_func = &sbc_ext_int;
		mdfp.fp_precise_func = &m88100_Xfp_precise;
d2385 9
a2393 3
	case CPU_197:
		mdfp.interrupt_func = &sbc_ext_int;
		mdfp.fp_precise_func = &m88110_Xfp_precise;
d2409 1
d2419 1
a2419 1
	if (cputyp == CPU_188 && (boothowto & RB_MINIROOT)) {
d2433 1
d2435 1
a2435 1
	printf("MVME%x boot: memory from 0x%x to 0x%x\n", cputyp, avail_start, avail_end);
a2439 1

a2446 8
	/*
	 * Must initialize p_addr before autoconfig or
	 * the fault handler will get a NULL reference.
	 */
	proc0.p_addr = proc0paddr;
	curproc = &proc0;
	curpcb = &proc0paddr->u_pcb;

@


1.70
log
@Sprinkle pmap_update calls where relevant and some other
misc pmap usage fixes.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.69 2001/11/30 23:16:51 miod Exp $	*/
d1716 2
a1717 2
		printf("mask == level, %d\n", level);
		goto beatit;
d1726 2
a1727 2
		printf("Bogons... level %x and mask %x\n", level, mask);
		goto beatit;
a1811 3

beatit:
	return;
@


1.69
log
@Repair after pmap_kenter_pgs() removal.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.68 2001/11/28 16:13:29 art Exp $	*/
d482 1
d637 1
@


1.68
log
@zap some typedefs.
vm_map_t -> struct vm_map *
vm_map_entry_t -> struct vm_map_entry *
simple_lock_data_t -> struct simplelock

(uvm not done yet, coming in the next commit)
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.67 2001/11/28 13:57:18 art Exp $	*/
d630 1
a630 1
			pmap_kenter_pa(va, VM_PAGE_TO_PHYS(pg),
@


1.67
log
@pmap_kenter_pgs(.., 1) is pointless. pmap_kenter_pa instead.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.66 2001/11/28 13:47:38 art Exp $	*/
d195 3
a197 3
vm_map_t exec_map = NULL;
vm_map_t mb_map = NULL;
vm_map_t phys_map = NULL;
d209 1
a209 1
vm_map_t   iomap_map;
@


1.66
log
@Sync in more uvm changes from NetBSD.
This time we're getting rid of KERN_* and VM_PAGER_* error codes and
use errnos instead.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.65 2001/11/27 05:26:36 miod Exp $	*/
d630 2
a631 1
			pmap_kenter_pgs(curbuf, &pg, 1);
@


1.65
log
@Move the declaration of EH_DEBUG and ERRATA__XXX_USR to the kernel
configuration files.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.64 2001/11/07 01:18:00 art Exp $	*/
d600 1
a600 1
				UVM_ADV_NORMAL, 0)) != KERN_SUCCESS)
@


1.64
log
@Add an alignment argument to uvm_map that specifies an alignment hint
for the virtual address.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.63 2001/11/06 19:53:15 miod Exp $	*/
d84 2
d87 1
d1417 1
a1417 1
	while (-1); /* spin forever */
d2052 2
d2071 3
a2073 1
}  
@


1.63
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.62 2001/10/28 00:59:02 miod Exp $	*/
d504 1
a504 1
		NULL, UVM_UNKNOWN_OFFSET,UVM_MAPFLAG(UVM_PROT_NONE, 
d531 1
a531 1
			NULL, UVM_UNKNOWN_OFFSET,UVM_MAPFLAG(UVM_PROT_NONE, 
d545 1
a545 1
			NULL, UVM_UNKNOWN_OFFSET,UVM_MAPFLAG(UVM_PROT_NONE, 
d560 1
a560 1
			NULL, UVM_UNKNOWN_OFFSET,UVM_MAPFLAG(UVM_PROT_NONE, 
d577 1
a577 1
			NULL, UVM_UNKNOWN_OFFSET,UVM_MAPFLAG(UVM_PROT_NONE, 
d595 1
a595 1
		    NULL, UVM_UNKNOWN_OFFSET,
@


1.62
log
@Handle RB_TIMEBAD in boot().
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.61 2001/09/28 20:50:07 miod Exp $	*/
a97 1
#include <vm/vm.h>
@


1.61
log
@cold is now staticly initialized.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.60 2001/09/23 02:54:27 miod Exp $	*/
a117 1
static int waittime = -1;
d1081 4
a1090 4
	/* take a snap shot before clobbering any registers */
	if (curproc && curproc->p_addr)
		savectx(curpcb);

d1092 1
a1092 8
	if ((howto & RB_NOSYNC) == 0 && waittime < 0) {
		extern struct proc proc0;

		/* protect against curproc->p_stats.foo refs in sync()   XXX */
		if (curproc == NULL)
			curproc = &proc0;

		waittime = 0;
a1093 1

d1096 2
a1097 1
		 * will be out of synch; adjust it now.
d1099 4
a1102 1
		resettodr();
@


1.60
log
@Rename kdb_init() to db_machine_init().
Fix prototypos for the early console routines.
Use even more PMAP_NEW syntactic sugar.
Remove some debugging stuff.
Use symbolic values instead of magic numbers.
Fix safepri value.
Implement machdep.console_device sysctl.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.59 2001/09/21 01:18:52 miod Exp $	*/
a2185 2

	cold = 1;  /* we are still booting */
@


1.59
log
@uvm_km_suballoc() will panic if it fails. No need to check the return
value.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.58 2001/09/19 20:50:56 mickey Exp $	*/
d108 2
a132 1
void kdb_init __P((void));
d192 1
a192 1
int   safepri = 0;
d268 3
a270 3
int  bootcnprobe __P((struct consdev *));
int  bootcninit __P((struct consdev *));
void bootcnputc __P((dev_t, char));
d273 1
d275 1
d277 2
a278 2
	(void (*))NULL, 
	(void (*))NULL, 
d280 5
a284 2
	(void (*))bootcnputc,
	bootcnpollc, NULL, makedev(14,0), 1};
d295 1
a298 1

d303 2
a304 1
	kdb_init();
d476 1
a476 1
	 * avail_end was pre-decremented in mvme_bootstrap().
a477 1

d479 2
a480 3
		pmap_enter(kernel_pmap, (vm_offset_t)msgbufp,
			   avail_end + i * NBPG, VM_PROT_READ|VM_PROT_WRITE,
			   VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
d486 2
a487 1
	printf("%s",version);
a641 3
#ifdef DEBUG
	printf("exe_map from 0x%x to 0x%x\n", (unsigned)minaddr, (unsigned)maxaddr);
#endif 
a644 1

d649 1
a649 1
	 * Allocate map for external I/O
a774 3
/*	printf("stack at %x\n", stack);
   printf("%x - %x\n", USRSTACK - MAXSSIZ, USRSTACK);
*/
d803 2
a804 2
	tf->epsr = 0x3f0;  /* user mode, interrupts enabled, fp enabled */
/*	tf->epsr = 0x3f4;*/  /* user mode, interrupts enabled, fp enabled, MXM Mask */
a1057 1
	tf->epsr = scp->sc_ps;
d1853 3
a1855 3
struct proc *p;
void *v;
register_t *retval;
d1857 1
d1862 1
a1862 1
	int error = 0;
d1864 1
a1864 6
	switch ((int)SCARG(uap, op)) {
	default:
		error = EINVAL;
		break;
	}
	return (error);
d1873 7
a1879 7
int *name;
u_int namelen;
void *oldp;
size_t *oldlenp;
void *newp;
size_t newlen;
struct proc *p;
d1881 1
d1888 7
a2242 1
	identifycpu();
d2305 1
a2305 1
int
a2310 1
	return (1);
d2313 1
a2313 1
int
a2317 1
	return (1);
d2330 1
a2330 1
	char c;
d2332 1
a2332 1
	if (c == '\n')
d2334 1
a2334 1
	bugoutchr(c);
@


1.58
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.57 2001/09/12 00:23:33 art Exp $	*/
a644 3
	if (phys_map == NULL) {
		panic("cpu_startup: unable to create phys_map");
	}
d651 1
a651 3
	if (iomap_map == NULL) {
		panic("cpu_startup: unable to create iomap_map");
	}
@


1.57
log
@mbutl no more
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.56 2001/08/26 14:31:12 miod Exp $	*/
a98 2
#include <vm/vm_kern.h>

@


1.56
log
@Add prototypes, fix compilation warnings, random style fixes.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.55 2001/08/24 22:54:51 miod Exp $	*/
d664 1
a664 1
	mb_map = uvm_km_suballoc(kernel_map, (vaddr_t *)&mbutl, &maxaddr,
@


1.55
log
@Adapt to trap() name change.
Only compile compatibility with older mvme88k executables if COMPAT_25
is defined. This makes sense to me, at least...
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.54 2001/08/24 19:26:15 miod Exp $	*/
d83 3
a85 1
#include <machine/locore.h>
d88 5
a92 1
#include <machine/asm_macro.h>   /* enable/disable interrupts */
a94 5
#include <machine/bug.h>
#include <machine/prom.h>
#include <machine/m88100.h>  		/* DMT_VALID        */
#include <machine/m882xx.h>  		/* CMMU stuff       */
#include <machine/kcore.h>
d114 1
a114 1
   #define DEBUG_MSG db_printf
d116 1
a116 1
   #define DEBUG_MSG printf
d126 1
a126 1
/* forwards */
d134 7
d172 1
a172 1
u_char *iackaddr;
a175 2
volatile vm_offset_t kernelva;
volatile vm_offset_t utilva;
d178 4
a187 2
vm_offset_t avail_end, avail_start, avail_next;
int foodebug = 0;    /* for size_memory() */
a188 1
int BugWorks = 0;
a213 1
int   nswbuf = 0;
a223 1
int *nofault;
d230 1
a230 1
char  machine[] = "mvme88k";	 /* cpu "architecture" */
d235 1
a255 6
#ifndef roundup
   #define roundup(value, stride) (((unsigned)(value) + (stride) - 1) & ~((stride)-1))
#endif /* roundup */

vm_size_t   mem_size;
vm_size_t   rawmem_size;
d259 1
a259 1
vm_offset_t avail_start, avail_next, avail_end;
a260 6
vm_offset_t pcc2consvaddr, clconsvaddr;
vm_offset_t miniroot;

void     *end_loaded;
int      bootdev;
int      no_symbols = 1;
a261 1
struct proc *lastproc;
d281 1
a281 1
void  cmmu_init(void);
d311 1
a311 1
size_memory(void)
d328 1
a328 2
		if (foodebug) printf("%x\n", look);
		if (badwordaddr((void*)look)) {
d357 1
a357 1
getcpuspeed(void)
d374 1
a374 1
getscsiid(void)
d431 1
a431 1
cpu_initclocks(void)
a584 2
	default:
		panic("startup: unknown cpu type.");
d661 1
a661 1
	if (iomap_extent == 0)
a670 15
#if 0 /* #ifdef MFS */
	/*
	 * Check to see if a mini-root was loaded into memory. It resides
	 * at the start of the next page just after the end of BSS.
	 */
	{
		extern void *smini;

		if (miniroot && (boothowto & RB_MINIROOT)) {
			boothowto |= RB_DFLTROOT;
			mfs_initminiroot(miniroot);
		}
	}
#endif

a676 5
	 * Configure the system.
	 */
	nofault = NULL;

	/*
d682 3
a758 5
	if (nswbuf == 0) {
		nswbuf = (nbuf / 2) &~ 1;  /* force even */
		if (nswbuf > 256)
			nswbuf = 256;	  /* sanity */
	}
d1078 1
a1078 1
void
d1083 2
d1087 1
a1087 1
void
d1091 6
a1097 1
#if 0
d1100 1
a1100 1
#endif 
d1122 8
d1133 1
a1133 6
		/* If rebooting and a dump is requested, do it. */
		if (howto & RB_DUMP)
			dumpsys();

		/* Run any shutdown hooks. */
		doshutdownhooks();
d1135 1
a1135 1
	doboot();
a1136 1
	for (;;);  /* to keep compiler happy, and me from going crazy */
d1141 1
a1141 1
m188_reset(void)
d1328 1
a1328 1
#undef MAP_VEC /* Swicthing to new virtual addresses XXX smurph */
a1373 2
	default:
		panic("setupiackvectors: unknow cpu");
d1395 1
a1395 1
get_slave_stack(void)
d1417 1
a1417 1
void slave_pre_main(void)
d1426 1
a1426 1
slave_main(void)
d1596 1
a1596 1
			if (guarded_access(ivec[level], 4, &vec) == EFAULT) {
d1616 1
a1616 1
			if (guarded_access(ivec[level], 4, &vec) == EFAULT) {
d2046 1
a2046 1
spl0(void)
d2184 1
a2184 1
mvme_bootstrap(void)
a2186 1
	extern vm_offset_t size_memory(void);
d2188 2
@


1.54
log
@No newline at the end of panic messages.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.53 2001/08/23 14:01:03 art Exp $	*/
d1704 1
a1704 1
		trap(T_DATAFLT, eframe);
d1830 1
d1833 1
a1833 1
			trap(T_DATAFLT, eframe);
d1838 1
d1857 1
a1857 1
#if 1
a1863 1
	int error;
@


1.53
log
@We can now move timeout_init into main().
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.52 2001/08/23 12:02:04 art Exp $	*/
d1660 1
a1660 1
			panic("m188_ext_int: interrupt vector 0x%x greater than 255!\nlevel = %d iack = 0x%x\n", 
@


1.52
log
@Remove even more old timeout tentacles.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.51 2001/08/23 08:47:34 miod Exp $	*/
a676 5
	/*
	 * Initialize timeouts
	 */
	timeout_init();

@


1.51
log
@Provide temporary compatibility with old machine ID binaries for some time.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.50 2001/08/11 23:21:13 art Exp $	*/
a742 1
	valloc(timeouts, struct timeout, ntimeout);
@


1.50
log
@Unnecessary and redundant includes.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.49 2001/08/11 01:57:25 art Exp $	*/
d1861 26
@


1.49
log
@swapmap is gone forever.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.48 2001/08/06 20:48:26 miod Exp $	*/
a97 1
#include <vm/vm_map.h>
a98 1
#include <vm/vm_page.h>
@


1.48
log
@Working kernel crash dumps.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.47 2001/08/05 20:35:46 miod Exp $	*/
a745 3
#if 0
	valloc(swapmap, struct map, nswapmap = maxproc * 2);
#endif 
@


1.47
log
@Use syntaxic sugar provided by PMAP_NEW
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.46 2001/07/25 13:25:32 art Exp $	*/
d78 2
d93 1
d1194 1
d1196 7
d1206 13
a1218 1
	int nblks;
d1221 6
a1226 7
	if (dumpdev != NODEV && bdevsw[major(dumpdev)].d_psize) {
		nblks = (*bdevsw[major(dumpdev)].d_psize)(dumpdev);
		if (dumpsize > btoc(dbtob(nblks - dumplo)))
			dumpsize = btoc(dbtob(nblks - dumplo));
		else if (dumplo == 0)
			dumplo = nblks - btodb(ctob(physmem));
	}
d1231 8
a1238 2
	if (dumplo < btodb(PAGE_SIZE))
		dumplo = btodb(PAGE_SIZE);
d1249 12
d1264 2
d1268 1
a1268 5
	/*
	 * For dumps during autoconfiguration,
	 * if dump device has already configured...
	 */
	if (dumpsize == 0)
d1270 7
a1276 1
	if (dumplo < 0)
d1278 16
a1293 1
	printf("\ndumping to dev %x, offset %d\n", dumpdev, dumplo);
d1295 33
a1327 1
	switch ((*bdevsw[major(dumpdev)].d_dump)(dumpdev)) {
d1332 1
d1336 1
d1340 1
d1344 5
d1350 1
a1350 1
		printf("succeeded\n");
a2251 2

	if (!no_symbols) boothowto |= RB_KDB;
@


1.46
log
@Change the pmap_enter interface to merge access_type and the wired boolean
and arbitrary flags into one argument.

One new flag is PMAP_CANFAIL that tells pmap_enter that it can fail if there
are not enough resources to satisfy the request. If this flag is not passed,
pmap_enter should panic as it should have done before this change (XXX - many
pmaps are still not doing that).

Only i386 and alpha implement CANFAIL for now.

Includes uvm updates from NetBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.45 2001/07/05 10:12:15 art Exp $	*/
d634 1
a634 3
			pmap_enter(kernel_map->pmap, curbuf,
				   VM_PAGE_TO_PHYS(pg), VM_PROT_ALL,
				   VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
@


1.45
log
@Get rid of REAL_CLISTS. It was never implemented and the tentacles are
everywhhere.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.44 2001/07/01 23:27:52 miod Exp $	*/
d484 1
a484 1
			   VM_PROT_READ|VM_PROT_WRITE, TRUE);
d635 2
a636 2
				   VM_PAGE_TO_PHYS(pg), VM_PROT_ALL, TRUE,
				   VM_PROT_READ|VM_PROT_WRITE);
@


1.44
log
@Variable declarations without extern are evil.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.43 2001/06/27 06:19:50 art Exp $	*/
a743 3
#ifdef REAL_CLISTS
	valloc(cfree, struct cblock, nclist);
#endif
@


1.43
log
@MNN is no longer an option.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.42 2001/06/27 04:29:19 art Exp $	*/
d171 4
@


1.42
log
@rip old vm
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.41 2001/06/25 00:43:14 mickey Exp $	*/
a2188 1
#if defined(MACHINE_NEW_NONCONTIG)
a2194 1
#endif /* MACHINE_NEW_NONCONTIG */
@


1.41
log
@cold is in systm now
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.40 2001/06/14 21:30:45 miod Exp $	*/
a98 1
#if defined(UVM)
a99 1
#endif
a182 1
#if defined(UVM)
a185 3
#else
vm_map_t buffer_map;
#endif
a193 1
#if defined(UVM)
a194 3
#else
vm_offset_t iomapbase;
#endif 
a469 1
#if defined(UVM)
a470 3
#else
	vm_offset_t minaddr, maxaddr, uarea_pages;
#endif 
a494 1
#if defined(UVM)
a495 3
#else
	if ((v = (caddr_t)kmem_alloc(kernel_map, round_page(sz))) == 0)
#endif
a503 1
#if defined(UVM)
a508 4
#else
	vm_map_find(kernel_map, vm_object_allocate(USPACE), 0,
		    (vm_offset_t *)&uarea_pages, USPACE, TRUE);
#endif
a530 1
#if defined(UVM)
a535 4
#else
		vm_map_find(kernel_map, vm_object_allocate(BUGROM_SIZE), 0,
			    (vm_offset_t *)&bugromva, BUGROM_SIZE, TRUE);
#endif
a544 1
#if defined(UVM)
a549 4
#else
		vm_map_find(kernel_map, vm_object_allocate(SRAM_SIZE), 0,
			    (vm_offset_t *)&sramva, SRAM_SIZE, TRUE);
#endif
a559 1
#if defined(UVM)
a564 4
#else
		vm_map_find(kernel_map, vm_object_allocate(OBIO_SIZE), 0,
			    (vm_offset_t *)&obiova, OBIO_SIZE, TRUE);
#endif
a576 1
#if defined(UVM)
a581 4
#else
		vm_map_find(kernel_map, vm_object_allocate(MVME188_UTILITY_SIZE), 0,
			    (vm_offset_t *)&utilva, MVME188_UTILITY_SIZE, TRUE);
#endif
a596 1
#if defined(UVM)
a602 8
#else
	buffer_map = kmem_suballoc(kernel_map, (vm_offset_t *)&buffers,
				   &maxaddr, size, TRUE);
	minaddr = (vm_offset_t)buffers;
	if (vm_map_find(buffer_map, vm_object_allocate(size), (vm_offset_t)0,
	    (vm_offset_t *)&minaddr, size, FALSE) != KERN_SUCCESS)
		panic("startup: cannot allocate buffers");
#endif
a611 1
#if defined(UVM)
a635 17
#else
		vm_size_t curbufsize;
		vm_offset_t curbuf;

		/*
		 * First <residual> buffers get (base+1) physical pages
		 * allocated for them.  The rest get (base) physical pages.
		 *
		 * The rest of each buffer occupies virtual space,
		 * but has no physical memory allocated for it.
		 */
		curbuf = (vm_offset_t)buffers + i * MAXBSIZE;
		curbufsize = PAGE_SIZE * (i < residual ? base+1 : base);
		/* this faults in the required physical pages */
		vm_map_pageable(buffer_map, curbuf, curbuf+curbufsize, FALSE);
		vm_map_simplify(buffer_map, curbuf);
#endif 
a641 1
#if defined(UVM)
a643 4
#else
	exec_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr,
				 16*NCARGS, TRUE);
#endif
a651 1
#if defined(UVM)
a653 4
#else
	phys_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr, 
				 VM_PHYS_SIZE, TRUE);
#endif
a660 1
#if defined(UVM)
a662 4
#else
	iomap_map = kmem_suballoc(kernel_map, &iomapbase, &maxaddr, 
				  IOMAP_SIZE, TRUE);
#endif 
a670 1
#if defined(UVM)
a672 4
#else
	mb_map = kmem_suballoc(kernel_map, (vm_offset_t *)&mbutl, &maxaddr,
			       VM_MBUF_SIZE, FALSE);
#endif
a678 1
#if defined(UVM)
a679 4
#else
	printf("avail mem = %ld (%ld pages)\n", ptoa(cnt.v_free_count),
	    ptoa(cnt.v_free_count)/NBPG);
#endif
a799 3
#if !defined(UVM)
	valloc(swbuf, struct buf, nswbuf);
#endif
a936 1
#if defined(UVM)
a938 4
#else
	if ((unsigned)fp <= USRSTACK - ctob(p->p_vmspace->vm_ssize))
		(void)grow(p, (unsigned)fp);
#endif
a1051 1
#if defined(UVM)
a1054 5
#else
	if ((int)scp & 3 || useracc((caddr_t)scp, sizeof *scp, B_WRITE) == 0 ||
	    copyin((caddr_t)scp, (caddr_t)&ksc, sizeof(struct sigcontext)))
		return (EINVAL);
#endif
a1335 1
#if defined(UVM)
a1336 3
#else
	addr = (vm_offset_t)kmem_alloc(kernel_map, INTSTACK_SIZE + 4096);
#endif
a1936 1
#if defined(UVM)
a1937 3
#else
		cnt.v_soft++;
#endif
a1950 1
#if defined(UVM)
a1951 3
#else
		cnt.v_soft++;
#endif
a2150 1
#if defined(UVM)
a2152 3
#else 
	vm_set_page_size();
#endif 
a2193 1
#if defined(UVM)
a2195 4
#else
	vm_page_physload(atop(avail_start), atop(avail_end),
			 atop(avail_start), atop(avail_end));
#endif /* UVM */
@


1.40
log
@Big cleanup of VM issues:
o get rid of m88k_foo macros when there is an mi foo macro
o remove the ability, for the pmap module, to handle a native mmu page
  size different from the vm module page size. This allows some
  optimizations in pmap.c
o remove dead stuff from <machine/vmparam.h>
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.39 2001/06/13 21:24:52 miod Exp $	*/
a174 1
int cold;	  /* boot process flag */
a2217 1
	extern int cold;
@


1.39
log
@Actually, because of multi-interrupts devices, use the opposite loop
direction. My bad, doh !
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.38 2001/06/12 23:09:45 miod Exp $	*/
d511 1
a511 1
	if ((v = (caddr_t)uvm_km_zalloc(kernel_map, m88k_round_page(sz))) == 0)
d513 1
a513 1
	if ((v = (caddr_t)kmem_alloc(kernel_map, m88k_round_page(sz))) == 0)
d642 1
a642 1
	if (uvm_map(kernel_map, (vaddr_t *) &buffers, m88k_round_page(size),
d2280 1
a2280 1
	first_addr = m88k_round_page(first_addr);
d2308 1
a2308 1
	avail_end -= m88k_round_page(MSGBUFSIZE);
d2312 1
a2312 1
	pmap_bootstrap((vm_offset_t)M88K_TRUNC_PAGE((unsigned)&kernelstart) /* = loadpt */, 
@


1.38
log
@In intr_findvec(), correct the for() loop bounds.
And display barf messages only if option DIAGNOSTIC.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.37 2001/06/05 23:07:50 miod Exp $	*/
d1501 1
a1501 1
	for (vec = end; vec > start; --vec){
@


1.37
log
@Call doshutdownhooks() in boot(). Cleanup code path a little.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.36 2001/05/20 05:53:10 miod Exp $	*/
d1495 1
d1499 3
a1501 1
	for (vec = start; vec < end; --vec){
d1505 1
d1507 1
@


1.36
log
@assym.s -> assym.h
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.35 2001/05/17 18:41:49 provos Exp $	*/
d1262 4
a1265 1
	splhigh();	  /* extreme priority */
a1267 1
		bugreturn();
d1269 1
d1272 3
a1274 2
		doboot();
		/*NOTREACHED*/
d1276 1
d1278 1
a1278 1
	while (1);  /* to keep compiler happy, and me from going crazy */
@


1.35
log
@convert mbuf and cluster allocation to pool, mostly from NetBSD
okay art@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.34 2001/05/05 22:34:02 art Exp $	*/
d106 1
a106 1
#include "assym.s"			/* EF_EPSR, etc. */
@


1.34
log
@Rename configure() to cpu_configure().
Move it from cpu_startup() to main().
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.33 2001/05/05 20:56:47 art Exp $	*/
a756 7
	/*
	 * Finally, allocate mbuf pool.  Since mclrefcnt is an off-size
	 * we use the more space efficient malloc in place of kmem_alloc.
	 */
	mclrefcnt = (char *)malloc(NMBCLUSTERS+PAGE_SIZE/MCLBYTES,
				   M_MBUF, M_NOWAIT);
	bzero(mclrefcnt, NMBCLUSTERS+PAGE_SIZE/MCLBYTES);
@


1.33
log
@Get rid of CLSIZE and all related stuff.
CLSIZE -> 1
CLBYTES -> PAGE_SIZE
OLOFSET -> PAGE_MASK
etc.
At the same time some archs needed some cleaning in vmparam.h so that
goes in at the same time.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.32 2001/04/29 19:00:03 miod Exp $	*/
a131 1
void configure __P((void));
a823 1
	configure();
@


1.32
log
@Replace resource maps with extents, and cleanup associated variables.
Idea from art's todolist, art@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.31 2001/04/17 04:30:47 aaron Exp $	*/
d678 1
a678 1
		curbufsize = CLBYTES * ((i < residual) ? (base+1) : base);
d703 1
a703 1
		curbufsize = CLBYTES * (i < residual ? base+1 : base);
d762 1
a762 1
	mclrefcnt = (char *)malloc(NMBCLUSTERS+CLBYTES/MCLBYTES,
d764 1
a764 1
	bzero(mclrefcnt, NMBCLUSTERS+CLBYTES/MCLBYTES);
d785 1
a785 1
	    bufpages * CLBYTES);
d879 1
a879 1
			bufpages = physmem / (10 * CLSIZE);
d882 1
a882 1
			    BUFCACHEPERCENT / (100 * CLSIZE);
d897 2
a898 2
	if (bufpages > nbuf * MAXBSIZE / CLBYTES)
		bufpages = nbuf * MAXBSIZE / CLBYTES;
d1321 1
a1321 1
	 * Don't dump on the first CLBYTES (why CLBYTES?)
d1324 2
a1325 2
	if (dumplo < btodb(CLBYTES))
		dumplo = btodb(CLBYTES);
@


1.31
log
@Implement cnbell(), an optional entrypoint that rings the console bell; from
NetBSD. deraadt@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.30 2001/03/16 00:08:28 miod Exp $	*/
d77 1
a173 1
volatile vm_offset_t extiova;
d208 1
a208 1
struct map *iomap;
a209 1
int      niomap;
d741 1
a741 1
	 * Allocate map for external I/O XXX new code - smurph 
d753 4
a756 1
	rminit(iomap, IOMAP_SIZE, (u_long)iomapbase, "iomap", NIOPMAP);
a909 7
#if 1 /*XXX_FUTURE*/
	/*
	 * Arbitrarily limit the number of devices mapping
	 * the IO space at a given time to NIOPMAP (= 32, default).
	 */
	valloc(iomap, struct map, niomap = NIOPMAP);
#endif
@


1.30
log
@Remove badwordaddr().
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.29 2001/03/12 22:59:02 miod Exp $	*/
d295 1
a295 1
	bootcnpollc, makedev(14,0), 1};
@


1.29
log
@/dev/ksyms support.

Replace netintr() with netisr_dispatch.

Move the location of printf(version) so that it is saved in the message buffer.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.28 2001/03/09 05:44:42 smurph Exp $	*/
a133 1
int badwordaddr __P((void *addr));
a2094 6
}

int
badwordaddr(void *addr)
{
	return badaddr((vm_offset_t)addr, 4);
@


1.28
log
@kernel will compile with -Werror.  Added intr.h
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.27 2001/03/07 23:56:06 miod Exp $	*/
d65 1
a65 1
   #include <sys/msg.h>
d68 1
a68 1
   #include <sys/sem.h>
d71 1
a71 1
   #include <sys/shm.h>
d77 1
a79 2
#include <mvme88k/dev/sysconreg.h>
#include <mvme88k/dev/pcctworeg.h>
d88 2
d102 5
a106 4
#define __IS_MACHDEP_C__
#include <assym.s>			/* EF_EPSR, etc. */
#include <machine/m88100.h>  		/* DMT_VALID        */
#include <machine/m882xx.h>  		/* CMMU stuff       */
d108 2
a109 2
   #include <machine/db_machdep.h>
   #include <ddb/db_output.h>		/* db_printf()		*/
a236 1
extern   char version[];
d250 3
a252 1
char *esym;
d501 4
a2050 58
void netintr()
{
#ifdef INET
	if (netisr & (1 << NETISR_ARP)) {
		netisr &= ~(1 << NETISR_ARP);
		arpintr();
	}
	if (netisr & (1 << NETISR_IP)) {
		netisr &= ~(1 << NETISR_IP);
		ipintr();
	}
#endif
#ifdef INET6
	if (netisr & (1 << NETISR_IPV6)) {
		netisr &= ~(1 << NETISR_IPV6);
		ip6intr();
	}
#endif
#ifdef NETATALK
	if (netisr & (1 << NETISR_ATALK)) {
		netisr &= ~(1 << NETISR_ATALK);
		atintr();
	}
#endif
#ifdef NS
	if (netisr & (1 << NETISR_NS)) {
		netisr &= ~(1 << NETISR_NS);
		nsintr();
	}
#endif
#ifdef ISO
	if (netisr & (1 << NETISR_ISO)) {
		netisr &= ~(1 << NETISR_ISO);
		clnlintr();
	}
#endif
#ifdef CCITT
	if (netisr & (1 << NETISR_CCITT)) {
		netisr &= ~(1 << NETISR_CCITT);
		ccittintr();
	}
#endif
#include "ppp.h"
#if NPPP > 0
	if (netisr & (1 << NETISR_PPP)) {
		netisr &= ~(1 << NETISR_PPP);
		pppintr();
	}
#endif
#include "bridge.h"
#if NBRIDGE > 0
	if (netisr & (1 << NETISR_BRIDGE)) {
		netisr &= ~(1 << NETISR_BRIDGE);
		bridgeintr();
	}
#endif
}

d2061 9
a2069 1
		netintr();
a2080 2

	return;
a2297 1
	printf("%s",version);
@


1.27
log
@Simplification of the interrupt handler prototype and calling convention:
they can either ask for a fixed void* argument, or an execution frame,
but not both anymore - no handler used this third flavour anyway.

Add code for UKC.

While there, some warning hunting.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.26 2001/02/12 08:16:24 smurph Exp $	*/
d81 1
d102 3
a104 3
#include <assym.s>			  /* EF_EPSR, etc. */
#include <machine/m88100.h>  			/* DMT_VALID        */
#include <machine/m882xx.h>  			/* CMMU stuff       */
d107 1
d124 9
a132 3
void m88100_Xfp_precise(void);
void m88110_Xfp_precise(void);
void setupiackvectors(void);
d342 1
a342 1
		if (badwordaddr((vm_offset_t)look)) {
d421 1
a421 1
		p->p_md.md_upte[i] = kvtopte(va + (i * NBPG))->bits;
d432 1
a432 1
		t = kvtopte(UADDR + (i * NBPG));
d436 1
a436 1
		cmmu_flush_tlb(1, UADDR + (i * NBPG), NBPG);
d482 1
a482 1
	vaddr_t minaddr, maxaddr, uarea_pages, addr;
d831 1
a831 1
register caddr_t v;
d921 4
a924 4
struct proc *p;
struct exec_package *pack;
u_long stack;
int retval[2];
d1009 5
a1013 5
sig_t catcher;
int sig, mask;
unsigned long code;
int type;
union sigval val;
d1246 1
a1246 1
register int howto;
d1494 1
a1494 1
int start, end;
d1730 1
a1730 1
		data_access_emulation(eframe);
d1858 1
a1858 1
			data_access_emulation(eframe);
d1935 1
a1935 1
void *velement, *vhead;
d1952 1
a1952 1
void *velement;
d1963 4
a1966 4
const void *fromaddr;
void *toaddr;
size_t maxlength;
size_t *lencopied;
d1989 1
a1989 1
register struct proc *p;
d2011 1
a2011 1
struct proc *vp;
d2036 1
a2036 1
u_char *cp;
d2129 1
a2129 1
spl0()
d2162 2
a2163 2
struct trapframe  *f;
int         flags;
d2210 1
a2210 1
		dae_print(f);
a2266 15
#if DDB
inline int
db_splhigh(void)
{
	return (db_setipl(IPL_HIGH));
}

inline int
db_splx(int s)
{
	return (db_setipl(s));
}
#endif /* DDB */	


a2271 1

d2416 1
a2416 1
struct consdev *cp;
d2425 1
a2425 1
struct consdev *cp;
d2433 1
a2433 1
dev_t dev;
d2440 2
a2441 2
dev_t dev;
char c;
@


1.26
log
@correct buginstat(), statclock now working for '188, systat vmstat now works,
serial driver for '188 working better.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.25 2001/02/01 03:38:21 smurph Exp $	*/
a474 1
	extern char   *kernel_text, *etext;
d478 1
a478 1
	extern vm_offset_t miniroot;
d801 8
d1138 1
a1149 1
	int error;
d1229 1
d1298 1
d1324 1
d1415 1
a1415 1
	defualt:
a1487 1
	register struct intrhand *intr;
d1494 1
a1494 1
		if (intr_handlers[vec] == (struct intrhand *)0)
d1519 1
a1519 1
	if (intr = intr_handlers[vec]) {
d1583 1
a1583 1
	if (! cur_mask) {
d1694 2
a1695 2
			if (intr->ih_wantframe)
				ret = (*intr->ih_fn)(intr->ih_arg, (void *)eframe);
d1712 1
a1712 1
	} while (cur_mask = ISR_GET_CURRENT_MASK(cpu));
d1750 1
a1750 1
	register u_char mask, level, xxxvec;
a1798 1
	/*vec = xxxvec;*/
d1824 2
a1825 2
		if (intr->ih_wantframe)
			ret = (*intr->ih_fn)(intr->ih_arg, (void *)eframe);
d1867 1
d1875 1
d1899 1
d2021 1
a2029 1
	struct bugniocall niocall;
d2031 1
a2123 1
	int level = 0;
d2135 1
d2141 1
d2152 1
d2163 1
d2165 1
d2175 1
a2282 1
	extern char *edata, *end;
a2283 1
	extern unsigned number_cpus;
a2284 1
	extern int lock_wait_time;
a2286 1
	extern unsigned vector_list;
d2436 1
a2450 1
	int s;
@


1.25
log
@Major changes to get MVME188 working.  More header and code cleanups.  The
kernel is tested on MVME188A/2P256 and MVME188A/1P64.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.24 2001/01/14 20:25:25 smurph Exp $	*/
d154 1
a154 1
#endif /* MVME188 */
d355 2
a356 1
		look = (unsigned int *)0x01FFF000; /* temp hack to fake 32Meg on MVME188 */
a526 19
	/*
	 * Grab the BUGROM space that we hardwired in pmap_bootstrap
	 */
	bugromva = BUGROM_START;

#if defined(UVM)
	uvm_map(kernel_map, (vaddr_t *)&bugromva, BUGROM_SIZE,
		NULL, UVM_UNKNOWN_OFFSET,UVM_MAPFLAG(UVM_PROT_NONE, 
						     UVM_PROT_NONE,
						     UVM_INH_NONE,
						     UVM_ADV_NORMAL, 0));
#else
	vm_map_find(kernel_map, vm_object_allocate(BUGROM_SIZE), 0,
		    (vm_offset_t *)&bugromva, BUGROM_SIZE, TRUE);
#endif
	if (bugromva != BUGROM_START) {
		printf("bugromva %x: BUGROM not free\n", bugromva);
		panic("bad bugromva");
	}
d540 20
d1583 6
a1588 4
	/* We want to service all interrupts marked in the IST register  */
	/* They are all valid because the mask would have prevented them */
	/* from being generated otherwise.  We will service them in order of       */
	/* priority. */
a1589 4
		/*
		printf("interrupt: mask = 0x%08x spl = %d imr = 0x%x\n", ISR_GET_CURRENT_MASK(cpu),
				  old_spl, *int_mask_reg[cpu]);
		*/
d1638 4
d1672 3
a1674 1
		if ((intr = intr_handlers[vec]) == 0)
d1677 2
d1689 3
a1691 1
			if (ret)
d1693 1
d1799 2
d1820 3
a1822 1
		if (ret)
d1824 1
a2330 1

@


1.24
log
@Complete move to UVM virtual memory system.  More header fixes.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.23 2001/01/13 05:18:59 smurph Exp $	*/
d126 1
a126 1
unsigned char *ivec[] = {
d135 1
d281 4
a284 1
	NULL, NULL, bootcngetc, bootcnputc,
d303 1
a303 1
#if defined (DDB)
a323 1
#if 1
d354 3
a356 3
#else 
	look = (unsigned int *)0x03FFF000; /* temp hack to fake 32Meg on MVME188 */
#endif 
a402 9
/* The following two functions assume UPAGES == 4 */
#if	UPAGES != 4
   #error "UPAGES changed?"
#endif

#if	USPACE != (UPAGES * NBPG)
   #error "USPACE changed?"
#endif

d525 5
d531 17
d555 1
a557 20
		 * Grab the BUGROM space that we hardwired in pmap_bootstrap
		 */
		bugromva = BUGROM_START;

#if defined(UVM)
		uvm_map(kernel_map, (vaddr_t *)&bugromva, BUGROM_SIZE,
			NULL, UVM_UNKNOWN_OFFSET,UVM_MAPFLAG(UVM_PROT_NONE, 
							     UVM_PROT_NONE,
							     UVM_INH_NONE,
							     UVM_ADV_NORMAL, 0));
#else
		vm_map_find(kernel_map, vm_object_allocate(BUGROM_SIZE), 0,
			    (vm_offset_t *)&bugromva, BUGROM_SIZE, TRUE);
#endif
		if (bugromva != BUGROM_START) {
			printf("bugromva %x: BUGROM not free\n", bugromva);
			panic("bad bugromva");
		}

		/*
a1360 1

d1362 1
a1362 1
	 * map a page in for phys address 0xfffe0000 and set the
d1382 10
d1409 13
a1421 8
	ivec[0] = vaddr + 0x03;
	ivec[1] = vaddr + 0x07;
	ivec[2] = vaddr + 0x0b;
	ivec[3] = vaddr + 0x0f;
	ivec[4] = vaddr + 0x13;
	ivec[5] = vaddr + 0x17;
	ivec[6] = vaddr + 0x1b;
	ivec[7] = vaddr + 0x1f;
d1481 2
a1482 2
		return (-1);
	for (vec = start; vec < end; --vec)
d1485 2
d1502 1
a1502 1
		panic("intr_establish: vec (%x) not between 0 and 0xff",
d1511 1
a1511 1
			panic("intr_establish: there are other handlers with vec (%x) at ipl %x, but you want it at %x",
d1546 2
a1547 2
unsigned obio_vec[32] = {SYSCV_ABRT,SYSCV_ACF,0,SYSCV_TIMER1,0,0,0,0,
	0,0,SYSCV_TIMER2,SYSCV_SYSF,0,0,SYSCV_SCC,0,
d1549 3
a1551 1
	0,0,0,0,0,0,0,0, 
d1553 1
d1555 2
d1561 1
a1561 1
	register int cpu = 0; /*cpu_number();*/
d1565 1
a1565 1
	int ret, intnum;
a1609 2
		setipl((u_char)level);

d1614 4
d1626 10
a1635 5
		intnum = ff1(cur_mask);
		if (intnum & OBIO_INTERRUPT_MASK) {
			vec = obio_vec[intnum];
			if (vec = 0) {
				printf("unknown onboard interrupt: mask = 0x%b\n", 1 << intnum, IST_STRING);
d1638 4
a1641 4
		} else if (intnum & HW_FAILURE_MASK) {
			vec = obio_vec[intnum];
			if (vec = 0) {
				printf("unknown hadware failure: mask = 0x%b\n", 1 << intnum, IST_STRING);
d1644 2
a1645 3
		} else if (intnum & VME_INTERRUPT_MASK) {
			asm volatile("tb1	0, r0, 0"); 
			if (guarded_access(ivec[level], 1, &vec) == EFAULT) {
d1649 9
d1659 2
a1660 1
			printf("unknown interrupt: mask = 0x%b\n", 1 << intnum, IST_STRING);
a1662 20
#if 0
		if (cur_mask & ABRT_BIT) { /* abort button interrupt */
			vec = 110;
		} else if (cur_mask & DTI_BIT) { /* interval timer interrupt */
			vec = SYSCV_TIMER1; 
		} else if (cur_mask & CIOI_BIT) { /* statistics timer interrupt */
			vec = SYSCV_TIMER2; 
		} else if (cur_mask & DI_BIT) {	/* duart interrupt */
			vec = SYSCV_SCC; 
		} else { /* vmebus interrupt */
			asm volatile("tb1	0, r0, 0"); 
			if (guarded_access(ivec[level], 1, &vec) == EFAULT) {
				printf("Unable to get vector for this vmebus interrupt (level %x)\n", level);
				goto out_m188;
			}
		}
#endif
		asm volatile("tb1	0, r0, 0"); 
		asm volatile("tb1	0, r0, 0"); 
		asm volatile("tb1	0, r0, 0"); 
d1664 2
a1665 1
			panic("interrupt vector %x greater than 255", vec);
a1666 3
#if 0
		enable_interrupt(); /* should we ?? */
#endif 
d1669 2
a1670 2
			printf("Spurious interrupt (level %x and vec %x)\n", level, vec);

d1684 8
a1691 2
		if (ret == 0)
			printf("Unclaimed interrupt (level %x and vec %x)\n", level, vec);
a1693 1

d1698 1
a1699 1
	out_m188:
d1822 1
a1822 1
	out:
d1838 1
a1838 1
	beatit:
d2185 1
a2185 1
		printf("vector %x ", f->vector);
d2189 1
a2189 1
		printf("pad %x\n", f->pad);
d2206 1
a2206 1
		printf("vector %x ", f->vector);
d2210 1
a2210 1
		printf("pad %x\n", f->pad);
a2341 3
#ifdef DEBUG
	printf("MVME%x boot: memory from 0x%x to 0x%x\n", cputyp, avail_start, avail_end);
#endif 
d2346 3
@


1.23
log
@Booting kernel with MACHINE_NEW_NONCONTIG.  UVM code added but not working.
New stand config.  Lots of header fixes.  Can now cross-compile i386->m88k.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.21 2000/12/28 21:21:24 smurph Exp $	*/
d148 1
a148 1
#endif /* MVME188 */
d150 1
d153 2
d479 2
a480 1
	vaddr_t minaddr, maxaddr, uarea_pages;
a731 7
	/*   
	 * IOMAP_MAP_START was used for the base address of this map, but
	 * IOMAP_MAP_START == 0xEF000000, which is larger than a signed 
	 * long (int on 88k). This causes rminit() to break when DIAGNOSTIC is 
	 * defined, as it checks (long)addr < 0.  So as a workaround, I use 
	 * 0x10000000 as a base address. XXX smurph
	 */
d758 1
d846 3
d850 4
a853 3
	 * Determine how many buffers to allocate (enough to
	 * hold 5% of total physical memory, but at least 16).
	 * Allocate 1/2 as many swap buffer headers as file i/o buffers.
d855 1
a855 1
	if (bufpages == 0)
d857 1
a857 1
			bufpages = (physmem / 10) / CLSIZE;
d859 3
a861 1
			bufpages = (physmem / 20) / CLSIZE;
d867 11
@


1.22
log
@Update vm interface to MACHIN_NEW_NONCONTIG.  Fix compile warning in pcctwo.c
@
text
@d3 1
a3 1
 * Copyright (c) 1998, 1999 Steve Murphree, Jr.
d95 5
d188 7
a194 1
void *iomapbase;
d475 3
d479 1
d499 6
a504 1
	if ((v = (caddr_t)kmem_alloc(kernel_map, round_page(sz))) == 0)
a511 1

d513 7
a519 1

d522 1
a522 1

d541 7
d550 1
a550 1

d560 7
a566 1

d569 1
d580 7
a586 1

d589 1
a589 1

d602 7
a608 1

d611 1
a611 1

a625 1

d627 8
d639 1
a639 1
			(vm_offset_t *)&minaddr, size, FALSE) != KERN_SUCCESS) {
d641 2
a642 1
	}
d651 26
a688 1

a690 1

d692 1
d699 4
d705 2
d713 8
a720 3
	phys_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr, VM_PHYS_SIZE,
	    TRUE);
	
d735 7
a741 3
	iomap_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr, IOMAP_SIZE,
	    TRUE);
	
a744 2
	
	iomapbase = (void *)kmem_alloc_wait(iomap_map, IOMAP_SIZE);
d754 4
d760 1
a760 1

d766 8
a773 3
	printf("avail mem = %d\n", ptoa(cnt.v_free_count));
	printf("using %d buffers containing %d bytes of memory\n",
	       nbuf, bufpages * CLBYTES);
d868 1
d870 1
d1015 4
d1021 2
a1042 1

d1135 5
d1143 1
d1155 2
a1156 1
	if (((scp->sc_xip | scp->sc_nip | scp->sc_fip) & 3) != 0)
d1159 3
a1161 1

d1220 2
a1221 2
	if (curproc)
		savectx(curproc->p_addr->u_pcb);
d1403 3
a1405 1

d1407 1
d1418 15
d1443 2
a1444 6
 * find a useable interrupt vector in the range start, end. It starts at
 * the end of the range, and searches backwards (to increase the chances
 * of not conflicting with more normal users)  
 * 
 * XXX This is not used yet.  It will provide a facility to 'autovector'
 * VME boards. smurph
d1453 1
d1456 1
a1456 1
	for (vec = end; vec > start; --vec)
d2039 3
d2043 1
d2049 3
d2053 1
d2277 4
d2282 1
d2314 1
a2314 1
	 * Steal one page at the top of physical memory for msgbuf
d2316 1
a2316 1
	avail_end -= PAGE_SIZE;
@


1.21
log
@mvme88k updates to -current.  finally!
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.20 2000/03/23 09:59:55 art Exp $	*/
d169 8
d623 3
a625 3

	phys_map = vm_map_create(kernel_pmap, PHYSIO_MAP_START,
				 PHYSIO_MAP_START + PHYSIO_MAP_SIZE, TRUE);
d640 3
a642 3

	iomap_map = vm_map_create(kernel_pmap, (u_long)0x10000000,
				  (u_long)0x10000000 + IOMAP_SIZE, TRUE);
d646 1
d1097 1
d1100 1
a1100 1

d2171 14
@


1.20
log
@New API for timeouts. Replaces the old timeout()/untimeout() API and
makes it the callers responsibility to allocate resources for the
timeouts.

This is a KISS implementation and does _not_ solve the problems of slow
handling of a large number of pending timeouts (this will be solved in
future work) (although hardclock is now guarateed to take constant time
for handling of timeouts).

Old timeout() and untimeout() are implemented as wrappers around the new
API and kept for compatibility. They will be removed as soon as all
subsystems are converted to use the new API.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.19 2000/02/22 19:27:55 deraadt Exp $	*/
d122 8
a129 8
   (unsigned char *)0xFFFE0003, /* not used, no such thing as int 0 */
   (unsigned char *)0xFFFE0007,
   (unsigned char *)0xFFFE000B,
   (unsigned char *)0xFFFE000F,
   (unsigned char *)0xFFFE0013,
   (unsigned char *)0xFFFE0017,
   (unsigned char *)0xFFFE001B,
   (unsigned char *)0xFFFE001F,
d138 4
a141 4
   (volatile unsigned int *)IEN0_REG,
   (volatile unsigned int *)IEN1_REG,
   (volatile unsigned int *)IEN2_REG,
   (volatile unsigned int *)IEN3_REG
d157 2
a158 2
int physmem;      /* available physical memory, in pages */
int cold;         /* boot process flag */
d201 1
a201 1
char  machine[] = "mvme88k";     /* cpu "architecture" */
d208 9
a216 9
   void *entry;
   void *symtab;
   void *esym;
   int   bflags;
   int   bdev;
   char *kname;
   void *smini;
   void *emini;
   void *end_load;
d258 2
a259 2
NULL, NULL, bootcngetc, bootcnputc,
   bootcnpollc, makedev(14,0), 1};
d269 4
a272 4
   extern struct consdev *cn_tab;
   /*
    * Initialize the console before we print anything out.
    */
d274 2
a275 2
   cn_tab = NULL;
   cninit();
d278 3
a280 3
   kdb_init();
   if (boothowto & RB_KDB)
      Debugger();
d292 3
a294 3
   volatile unsigned int *look;
   unsigned int *max;
   extern char *end;
d299 11
a309 11
   /*
    * count it up.
    */
   max = (void*)MAXPHYSMEM;
   for (look = (void*)Roundup(end, STRIDE); look < max;
       look = (int*)((unsigned)look + STRIDE)) {
      unsigned save;

      /* if can't access, we've reached the end */
      if (foodebug) printf("%x\n", look);
      if (badwordaddr((vm_offset_t)look)) {
d311 1
a311 1
         printf("%x\n", look);
d313 16
a328 16
         look = (int *)((int)look - STRIDE);
         break;
      }

      /*
       * If we write a value, we expect to read the same value back.
       * We'll do this twice, the 2nd time with the opposite bit
       * pattern from the first, to make sure we check all bits.
       */
      save = *look;
      if (*look = PATTERN, *look != PATTERN)
         break;
      if (*look = ~PATTERN, *look != ~PATTERN)
         break;
      *look = save;
   }
d330 1
a330 1
   look = (unsigned int *)0x03FFF000; /* temp hack to fake 32Meg on MVME188 */
d332 2
a333 2
   physmem = btoc(trunc_page((unsigned)look)); /* in pages */
   return (trunc_page((unsigned)look));
d339 12
a350 12
   struct bugbrdid brdid;
   int speed = 0;
   int i, c;
   bugbrdid(&brdid);
   for (i=0; i<4; i++) {
      c=(unsigned char)brdid.speed[i];
      c-= '0';
      speed *=10;
      speed +=c;
   }
   speed = speed / 100;
   return (speed);
d356 12
a367 12
   struct bugbrdid brdid;
   int scsiid = 0;
   int i, c;
   bugbrdid(&brdid);
   for (i=0; i<2; i++) {
      c=(unsigned char)brdid.scsiid[i];
      scsiid *=10;
      c-= '0';
      scsiid +=c;
   }
   printf("SCSI ID = %d\n", scsiid);
   return (7); /* hack! */
d373 3
a375 3
   cpuspeed = getcpuspeed();
   sprintf(cpu_model, "Motorola MVME%x %dMhz", cputyp, cpuspeed);
   printf("\nModel: %s\n", cpu_model);
d394 4
a397 4
   int i; 
   for (i=0; i<UPAGES; i++) {
      p->p_md.md_upte[i] = kvtopte(va + (i * NBPG))->bits;
   }
d403 1
a403 1
   pte_template_t *t;
d405 8
a412 8
   int i; 
   for (i=0; i<UPAGES; i++) {
      t = kvtopte(UADDR + (i * NBPG));
      t->bits = p->p_md.md_upte[i];
   }
   for (i=0; i<UPAGES; i++) {
      cmmu_flush_tlb(1, UADDR + (i * NBPG), NBPG);
   }
d423 1
a423 1
   printf("cpu_initclocks(): ");
d425 1
a425 1
   if (mdfp.clock_init_func != NULL){
d427 1
a427 1
      printf("[interval clock] ");
d429 3
a431 3
      (*mdfp.clock_init_func)();
   }
   if (mdfp.statclock_init_func != NULL){
d433 1
a433 1
      printf("[statistics clock]");
d435 2
a436 2
      (*mdfp.statclock_init_func)();
   }
d438 1
a438 1
   printf("\n");
d452 157
a608 144
   caddr_t v;
   int sz, i;
   vm_size_t size;    
   int base, residual;
   vm_offset_t minaddr, maxaddr, uarea_pages;
   extern vm_offset_t miniroot;
   /*
    * Initialize error message buffer (at end of core).
    * avail_end was pre-decremented in mvme_bootstrap().
    */

   for (i = 0; i < btoc(MSGBUFSIZE); i++)
      pmap_enter(kernel_pmap, (vm_offset_t)msgbufp,
	avail_end + i * NBPG, VM_PROT_READ|VM_PROT_WRITE,
	VM_PROT_READ|VM_PROT_WRITE, TRUE);
   initmsgbuf((caddr_t)msgbufp, round_page(MSGBUFSIZE));

   printf("real mem  = %d\n", ctob(physmem));

   /*
    * Find out how much space we need, allocate it,
    * and then give everything true virtual addresses.
    */
   sz = (int)allocsys((caddr_t)0);
   if ((v = (caddr_t)kmem_alloc(kernel_map, round_page(sz))) == 0)
      panic("startup: no room for tables");
   if (allocsys(v) - v != sz)
      panic("startup: table size inconsistency");

   /*
    * Grab UADDR virtual address
    */

   uarea_pages = UADDR;

   vm_map_find(kernel_map, vm_object_allocate(USPACE), 0,
               (vm_offset_t *)&uarea_pages, USPACE, TRUE);

   if (uarea_pages != UADDR) {
      printf("uarea_pages %x: UADDR not free\n", uarea_pages);
      panic("bad UADDR");
   }

   if (cputyp != CPU_188) {   /* != CPU_188 */
      
      /*
       * Grab the BUGROM space that we hardwired in pmap_bootstrap
       */
      bugromva = BUGROM_START;

      vm_map_find(kernel_map, vm_object_allocate(BUGROM_SIZE), 0,
                  (vm_offset_t *)&bugromva, BUGROM_SIZE, TRUE);

      if (bugromva != BUGROM_START) {
         printf("bugromva %x: BUGROM not free\n", bugromva);
         panic("bad bugromva");
      }

      /*
       * Grab the SRAM space that we hardwired in pmap_bootstrap
       */
      sramva = SRAM_START;

      vm_map_find(kernel_map, vm_object_allocate(SRAM_SIZE), 0,
                  (vm_offset_t *)&sramva, SRAM_SIZE, TRUE);

      if (sramva != SRAM_START) {
         printf("sramva %x: SRAM not free\n", sramva);
         panic("bad sramva");
      }

      /*
       * Grab the OBIO space that we hardwired in pmap_bootstrap
       */
      obiova = OBIO_START;

      vm_map_find(kernel_map, vm_object_allocate(OBIO_SIZE), 0,
                  (vm_offset_t *)&obiova, OBIO_SIZE, TRUE);

      if (obiova != OBIO_START) {
         printf("obiova %x: OBIO not free\n", obiova);
         panic("bad OBIO");
      }
   } else { /* cputyp == CPU_188 */
      /*
       * Grab the UTIL space that we hardwired in pmap_bootstrap
       */
      utilva = MVME188_UTILITY;

      vm_map_find(kernel_map, vm_object_allocate(MVME188_UTILITY_SIZE), 0,
                  (vm_offset_t *)&utilva, MVME188_UTILITY_SIZE, TRUE);

      if (utilva != MVME188_UTILITY) {
         printf("utilva %x: UTILITY area not free\n", utilva);
         panic("bad utilva");
      }
   }

   /*
    * Now allocate buffers proper.  They are different than the above
    * in that they usually occupy more virtual memory than physical.
    */

   size = MAXBSIZE * nbuf;
   buffer_map = kmem_suballoc(kernel_map, (vm_offset_t *)&buffers,
                              &maxaddr, size, TRUE);
   minaddr = (vm_offset_t)buffers;
   if (vm_map_find(buffer_map, vm_object_allocate(size), (vm_offset_t)0,
                   (vm_offset_t *)&minaddr, size, FALSE) != KERN_SUCCESS) {
      panic("startup: cannot allocate buffers");
   }
   if ((bufpages / nbuf) >= btoc(MAXBSIZE)) {
      /* don't want to alloc more physical mem than needed */
      bufpages = btoc(MAXBSIZE) * nbuf;
   }
   base = bufpages / nbuf;
   residual = bufpages % nbuf;

   for (i = 0; i < nbuf; i++) {
      vm_size_t curbufsize;
      vm_offset_t curbuf;

      /*
       * First <residual> buffers get (base+1) physical pages
       * allocated for them.  The rest get (base) physical pages.
       *
       * The rest of each buffer occupies virtual space,
       * but has no physical memory allocated for it.
       */
      curbuf = (vm_offset_t)buffers + i * MAXBSIZE;
      curbufsize = CLBYTES * (i < residual ? base+1 : base);

      /* this faults in the required physical pages */
      vm_map_pageable(buffer_map, curbuf, curbuf+curbufsize, FALSE);

      vm_map_simplify(buffer_map, curbuf);
   }

   /*
    * Allocate a submap for exec arguments.  This map effectively
    * limits the number of processes exec'ing at any time.
    */
   exec_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr,
                            16*NCARGS, TRUE);
d610 1
a610 1
   printf("exe_map from 0x%x to 0x%x\n", (unsigned)minaddr, (unsigned)maxaddr);
d612 26
a637 26
   /*
    * Allocate map for physio.
    */

   phys_map = vm_map_create(kernel_pmap, PHYSIO_MAP_START,
                            PHYSIO_MAP_START + PHYSIO_MAP_SIZE, TRUE);
   if (phys_map == NULL) {
      panic("cpu_startup: unable to create phys_map");
   }

   /* 
    * Allocate map for external I/O XXX new code - smurph 
    */
   /*   
    * IOMAP_MAP_START was used for the base address of this map, but
    * IOMAP_MAP_START == 0xEF000000, which is larger than a signed 
    * long (int on 88k). This causes rminit() to break when DIAGNOSTIC is 
    * defined, as it checks (long)addr < 0.  So as a workaround, I use 
    * 0x10000000 as a base address. XXX smurph
    */
   
   iomap_map = vm_map_create(kernel_pmap, (u_long)0x10000000,
                             (u_long)0x10000000 + IOMAP_SIZE, TRUE);
   if (iomap_map == NULL) {
      panic("cpu_startup: unable to create iomap_map");
   }
d639 1
a639 1
   rminit(iomap, IOMAP_SIZE, (u_long)iomapbase, "iomap", NIOPMAP);
d641 18
a658 18
   /*
    * Finally, allocate mbuf pool.  Since mclrefcnt is an off-size
    * we use the more space efficient malloc in place of kmem_alloc.
    */
   mclrefcnt = (char *)malloc(NMBCLUSTERS+CLBYTES/MCLBYTES,
                              M_MBUF, M_NOWAIT);
   bzero(mclrefcnt, NMBCLUSTERS+CLBYTES/MCLBYTES);
   mb_map = kmem_suballoc(kernel_map, (vm_offset_t *)&mbutl, &maxaddr,
                          VM_MBUF_SIZE, FALSE);

   /*
    * Initialize timeouts
    */
   timeout_init();

   printf("avail mem = %d\n", ptoa(cnt.v_free_count));
   printf("using %d buffers containing %d bytes of memory\n",
          nbuf, bufpages * CLBYTES);
d661 30
a690 30
   /*
    * Check to see if a mini-root was loaded into memory. It resides
    * at the start of the next page just after the end of BSS.
    */
   {
      extern void *smini;

      if (miniroot && (boothowto & RB_MINIROOT)) {
         boothowto |= RB_DFLTROOT;
         mfs_initminiroot(miniroot);
      }
   }
#endif

   /*
    * Set up buffers, so they can be used to read disk labels.
    */
   bufinit();

   /*
    * Configure the system.
    */
   nofault = NULL;

   /*
    * zero out intr_handlers
    */
   bzero((void *)intr_handlers, 256 * sizeof(struct intrhand *));
   setupiackvectors();
   configure();
d711 1
a711 1
   valloc(cfree, struct cblock, nclist);
d713 1
a713 1
   valloc(timeouts, struct timeout, ntimeout);
d715 1
a715 1
   valloc(swapmap, struct map, nswapmap = maxproc * 2);
d718 1
a718 1
   valloc(shmsegs, struct shmid_ds, shminfo.shmmni);
d721 4
a724 4
   valloc(sema, struct semid_ds, seminfo.semmni);
   valloc(sem, struct sem, seminfo.semmns);
   /* This is pretty disgusting! */
   valloc(semu, int, (seminfo.semmnu * seminfo.semusz) / sizeof(int));
d727 28
a754 28
   valloc(msgpool, char, msginfo.msgmax);
   valloc(msgmaps, struct msgmap, msginfo.msgseg);
   valloc(msghdrs, struct msg, msginfo.msgtql);
   valloc(msqids, struct msqid_ds, msginfo.msgmni);
#endif

   /*
    * Determine how many buffers to allocate (enough to
    * hold 5% of total physical memory, but at least 16).
    * Allocate 1/2 as many swap buffer headers as file i/o buffers.
    */
   if (bufpages == 0)
      if (physmem < btoc(2 * 1024 * 1024))
         bufpages = (physmem / 10) / CLSIZE;
      else
         bufpages = (physmem / 20) / CLSIZE;
   if (nbuf == 0) {
      nbuf = bufpages;
      if (nbuf < 16)
         nbuf = 16;
   }
   if (nswbuf == 0) {
      nswbuf = (nbuf / 2) &~ 1;  /* force even */
      if (nswbuf > 256)
         nswbuf = 256;     /* sanity */
   }
   valloc(swbuf, struct buf, nswbuf);
   valloc(buf, struct buf, nbuf);
d757 5
a761 5
   /*
    * Arbitrarily limit the number of devices mapping
    * the IO space at a given time to NIOPMAP (= 32, default).
    */
   valloc(iomap, struct map, niomap = NIOPMAP);
d763 1
a763 1
   return v;
d780 1
a780 1
   register struct trapframe *tf = USER_REGS(p);
d785 6
a790 6
   /*
    * The syscall will ``return'' to snip; set it.
    * argc, argv, envp are placed on the stack by copyregs.
    * Point r2 to the stack. crt0 should extract envp from
    * argc & argv before calling user's main.
    */
d792 19
a810 19
   /*
    * I don't think I need to mess with fpstate on 88k because
    * we make sure the floating point pipeline is drained in
    * the trap handlers. Should check on this later. XXX Nivas.
    */

   if ((fs = p->p_md.md_fpstate) != NULL) {
      /*
       * We hold an FPU state.  If we own *the* FPU chip state
       * we must get rid of it, and the only way to do that is
       * to save it.  In any case, get rid of our FPU state.
       */
      if (p == fpproc) {
         savefpstate(fs);
         fpproc = NULL;
      }
      free((void *)fs, M_SUBPROC);
      p->p_md.md_fpstate = NULL;
   }
d812 2
a813 2
   bzero((caddr_t)tf, sizeof *tf);
   tf->epsr = 0x3f0;  /* user mode, interrupts enabled, fp enabled */
d816 13
a828 13
   /*
    * We want to start executing at pack->ep_entry. The way to
    * do this is force the processor to fetch from ep_entry. Set
    * NIP to something bogus and invalid so that it will be a NOOP.
    * And set sfip to ep_entry with valid bit on so that it will be
    * fetched.
    */

   tf->snip = pack->ep_entry & ~3;
   tf->sfip = (pack->ep_entry & ~3) | FIP_V;
   tf->r[2] = stack;
   tf->r[31] = stack;
   retval[1] = 0;
d832 2
a833 2
   int   ss_flags;      /* which of the following are valid */
   struct   trapframe ss_frame;  /* original exception frame */
d841 6
a846 6
   int   sf_signo;      /* signo for handler */
   siginfo_t *sf_sip;
   struct   sigcontext *sf_scp;  /* context ptr for handler */
   sig_t sf_handler;    /* handler addr for u_sigc */
   struct   sigcontext sf_sc; /* actual context */
   siginfo_t sf_si;
d869 8
a876 8
   register struct proc *p = curproc;
   register struct trapframe *tf;
   register struct sigacts *psp = p->p_sigacts;
   struct sigframe *fp;
   int oonstack, fsize;
   struct sigframe sf;
   int addr;
   extern char sigcode[], esigcode[];
d880 20
a899 20
   tf = p->p_md.md_tf;
   oonstack = psp->ps_sigstk.ss_flags & SA_ONSTACK;
   /*
    * Allocate and validate space for the signal handler
    * context. Note that if the stack is in data space, the
    * call to grow() is a nop, and the copyout()
    * will fail if the process has not already allocated
    * the space with a `brk'.
    */
   fsize = sizeof(struct sigframe);
   if ((psp->ps_flags & SAS_ALTSTACK) &&
       (psp->ps_sigstk.ss_flags & SA_ONSTACK) == 0 &&
       (psp->ps_sigonstack & sigmask(sig))) {
      fp = (struct sigframe *)(psp->ps_sigstk.ss_sp +
                               psp->ps_sigstk.ss_size - fsize);
      psp->ps_sigstk.ss_flags |= SA_ONSTACK;
   } else
      fp = (struct sigframe *)(tf->r[31] - fsize);
   if ((unsigned)fp <= USRSTACK - ctob(p->p_vmspace->vm_ssize))
      (void)grow(p, (unsigned)fp);
d901 73
a973 73
   if ((sigdebug & SDB_FOLLOW) ||
       (sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
      printf("sendsig(%d): sig %d ssp %x usp %x scp %x\n",
             p->p_pid, sig, &oonstack, fp, &fp->sf_sc);
#endif
   /*
    * Build the signal context to be used by sigreturn.
    */
   sf.sf_signo = sig;
   sf.sf_scp = &fp->sf_sc;
   sf.sf_handler = catcher;
   sf.sf_sc.sc_onstack = oonstack;
   sf.sf_sc.sc_mask = mask;

   if (psp->ps_siginfo & sigmask(sig)) {
      sf.sf_sip = &fp->sf_si;
      initsiginfo(&sf.sf_si, sig, code, type, val);
   }


   /*
    * Copy the whole user context into signal context that we
    * are building.
    */
   bcopy((caddr_t)tf->r, (caddr_t)sf.sf_sc.sc_regs,
         sizeof(sf.sf_sc.sc_regs));
   sf.sf_sc.sc_xip = tf->sxip & ~3;
   sf.sf_sc.sc_nip = tf->snip & ~3;
   sf.sf_sc.sc_fip = tf->sfip & ~3;
   sf.sf_sc.sc_ps = tf->epsr;
   sf.sf_sc.sc_sp  = tf->r[31];
   sf.sf_sc.sc_fpsr = tf->fpsr;
   sf.sf_sc.sc_fpcr = tf->fpcr;
   sf.sf_sc.sc_ssbr = tf->ssbr;
   sf.sf_sc.sc_dmt0 = tf->dmt0;
   sf.sf_sc.sc_dmd0 = tf->dmd0;
   sf.sf_sc.sc_dma0 = tf->dma0;
   sf.sf_sc.sc_dmt1 = tf->dmt1;
   sf.sf_sc.sc_dmd1 = tf->dmd1;
   sf.sf_sc.sc_dma1 = tf->dma1;
   sf.sf_sc.sc_dmt2 = tf->dmt2;
   sf.sf_sc.sc_dmd2 = tf->dmd2;
   sf.sf_sc.sc_dma2 = tf->dma2;
   sf.sf_sc.sc_fpecr = tf->fpecr;
   sf.sf_sc.sc_fphs1 = tf->fphs1;
   sf.sf_sc.sc_fpls1 = tf->fpls1;
   sf.sf_sc.sc_fphs2 = tf->fphs2;
   sf.sf_sc.sc_fpls2 = tf->fpls2;
   sf.sf_sc.sc_fppt = tf->fppt;
   sf.sf_sc.sc_fprh = tf->fprh;
   sf.sf_sc.sc_fprl = tf->fprl;
   sf.sf_sc.sc_fpit = tf->fpit;
   if (copyout((caddr_t)&sf, (caddr_t)fp, sizeof sf)) {
      /*
       * Process has trashed its stack; give it an illegal
       * instruction to halt it in its tracks.
       */
      SIGACTION(p, SIGILL) = SIG_DFL;
      sig = sigmask(SIGILL);
      p->p_sigignore &= ~sig;
      p->p_sigcatch &= ~sig;
      p->p_sigmask &= ~sig;
      psignal(p, SIGILL);
      return;
   }
   /* 
    * Build the argument list for the signal handler.
    * Signal trampoline code is at base of user stack.
    */
   addr = (int)PS_STRINGS - szsigcode;
   tf->snip = (addr & ~3) | NIP_V;
   tf->sfip = (tf->snip + 4) | FIP_V;
   tf->r[31] = (unsigned)fp;
d975 3
a977 3
   if ((sigdebug & SDB_FOLLOW) ||
       (sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
      printf("sendsig(%d): sig %d returns\n", p->p_pid, sig);
d1000 7
a1006 7
   struct sys_sigreturn_args /* {
      syscallarg(struct sigcontext *) sigcntxp;
   } */ *uap = v;
   register struct sigcontext *scp;
   register struct trapframe *tf;
   struct sigcontext ksc;
   int error;
d1008 1
a1008 1
   scp = (struct sigcontext *)SCARG(uap, sigcntxp);
d1010 2
a1011 2
   if (sigdebug & SDB_FOLLOW)
      printf("sigreturn: pid %d, scp %x\n", p->p_pid, scp);
d1013 10
a1022 10
   if ((int)scp & 3 || useracc((caddr_t)scp, sizeof *scp, B_WRITE) == 0 ||
       copyin((caddr_t)scp, (caddr_t)&ksc, sizeof(struct sigcontext)))
      return (EINVAL);

   tf = p->p_md.md_tf;
   scp = &ksc;
   /*
    * xip, nip and fip must be multiples of 4.  This is all
    * that is required; if it holds, just do it.
    */
d1024 2
a1025 2
   if (((scp->sc_xip | scp->sc_nip | scp->sc_fip) & 3) != 0)
      return (EINVAL);
d1027 48
a1074 48
   if (((scp->sc_xip | scp->sc_nip | scp->sc_fip) & 3) != 0)
      printf("xip %x nip %x fip %x\n",
             scp->sc_xip, scp->sc_nip, scp->sc_fip);

   /*
    * this can be improved by doing
    *	 bcopy(sc_reg to tf, sizeof sigcontext - 2 words)
    * XXX nivas
    */

   bcopy((caddr_t)scp->sc_regs, (caddr_t)tf->r, sizeof(scp->sc_regs));
   tf->sxip = (scp->sc_xip) | XIP_V;
   tf->snip = (scp->sc_nip) | NIP_V;
   tf->sfip = (scp->sc_fip) | FIP_V;
   tf->epsr = scp->sc_ps;
   tf->r[31] = scp->sc_sp;
   tf->fpsr = scp->sc_fpsr;
   tf->fpcr = scp->sc_fpcr;
   tf->ssbr = scp->sc_ssbr;
   tf->dmt0 = scp->sc_dmt0;
   tf->dmd0 = scp->sc_dmd0;
   tf->dma0 = scp->sc_dma0;
   tf->dmt1 = scp->sc_dmt1;
   tf->dmd1 = scp->sc_dmd1;
   tf->dma1 = scp->sc_dma1;
   tf->dmt2 = scp->sc_dmt2;
   tf->dmd2 = scp->sc_dmd2;
   tf->dma2 = scp->sc_dma2;
   tf->fpecr = scp->sc_fpecr;
   tf->fphs1 = scp->sc_fphs1;
   tf->fpls1 = scp->sc_fpls1;
   tf->fphs2 = scp->sc_fphs2;
   tf->fpls2 = scp->sc_fpls2;
   tf->fppt = scp->sc_fppt;
   tf->fprh = scp->sc_fprh;
   tf->fprl = scp->sc_fprl;
   tf->fpit = scp->sc_fpit;

   tf->epsr = scp->sc_ps;
   /*
    * Restore the user supplied information
    */
   if (scp->sc_onstack & 01)
      p->p_sigacts->ps_sigstk.ss_flags |= SA_ONSTACK;
   else
      p->p_sigacts->ps_sigstk.ss_flags &= ~SA_ONSTACK;
   p->p_sigmask = scp->sc_mask & ~sigcantmask;
   return (EJUSTRETURN);
d1079 2
a1080 2
   cmmu_shutdown_now();
   bugreturn();
d1087 33
a1119 33
   /* take a snap shot before clobbering any registers */
   if (curproc)
      savectx(curproc->p_addr, 0);

   boothowto = howto;
   if ((howto & RB_NOSYNC) == 0 && waittime < 0) {
      extern struct proc proc0;

      /* protect against curproc->p_stats.foo refs in sync()   XXX */
      if (curproc == NULL)
         curproc = &proc0;

      waittime = 0;
      vfs_shutdown();

      /*
       * If we've been adjusting the clock, the todr
       * will be out of synch; adjust it now.
       */
      resettodr();
   }
   splhigh();        /* extreme priority */
   if (howto & RB_HALT) {
      printf("halted\n\n");
      bugreturn();
   } else {
      if (howto & RB_DUMP)
         dumpsys();
      doboot();
      /*NOTREACHED*/
   }
   /*NOTREACHED*/
   while (1);  /* to keep compiler happy, and me from going crazy */
d1126 11
a1136 11
   volatile int cnt;
   
   *sys_syscon->ien0 = 0;
   *sys_syscon->ien1 = 0;
   *sys_syscon->ien2 = 0;
   *sys_syscon->ien3 = 0;
   *sys_syscon->glbres = 1;  /* system reset */
   *sys_syscon->ucsr |= 0x2000; /* clear SYSFAIL* */
   for (cnt = 0; cnt < 5*1024*1024; cnt++)
      ;
   *sys_syscon->ucsr |= 0x2000; /* clear SYSFAIL* */
d1140 2
a1141 2
unsigned dumpmag = 0x8fca0101;   /* magic number for savecore */
int   dumpsize = 0;     /* also for savecore */
d1146 1
a1146 1
   int nblks;
d1148 14
a1161 14
   dumpsize = physmem;
   if (dumpdev != NODEV && bdevsw[major(dumpdev)].d_psize) {
      nblks = (*bdevsw[major(dumpdev)].d_psize)(dumpdev);
      if (dumpsize > btoc(dbtob(nblks - dumplo)))
         dumpsize = btoc(dbtob(nblks - dumplo));
      else if (dumplo == 0)
         dumplo = nblks - btodb(ctob(physmem));
   }
   /*
    * Don't dump on the first CLBYTES (why CLBYTES?)
    * in case the dump device includes a disk label.
    */
   if (dumplo < btodb(CLBYTES))
      dumplo = btodb(CLBYTES);
d1171 1
a1171 1
   extern int msgbufmapped;
d1173 31
a1203 35
   msgbufmapped = 0;
   if (dumpdev == NODEV)
      return;
   /*
    * For dumps during autoconfiguration,
    * if dump device has already configured...
    */
   if (dumpsize == 0)
      dumpconf();
   if (dumplo < 0)
      return;
   printf("\ndumping to dev %x, offset %d\n", dumpdev, dumplo);
   printf("dump ");
   switch ((*bdevsw[major(dumpdev)].d_dump)(dumpdev)) {
      
      case ENXIO:
         printf("device bad\n");
         break;

      case EFAULT:
         printf("device not ready\n");
         break;

      case EINVAL:
         printf("area improper\n");
         break;

      case EIO:
         printf("i/o error\n");
         break;

      default:
         printf("succeeded\n");
         break;
   }
d1212 1
a1212 1
   register u_char *vaddr;
d1215 1
a1215 1
   extern vm_offset_t iomap_mapin(vm_offset_t, vm_size_t,  boolean_t);
d1218 7
a1224 6
   /*
    * map a page in for phys address 0xfffe0000 and set the
    * addresses for various levels.
    */
   switch (cputyp) {
      case CPU_187:
d1226 1
a1226 1
         vaddr = (u_char *)iomap_mapin(M187_IACK, NBPG, 1);
d1228 1
a1228 1
         vaddr = (u_char *)M187_IACK;
d1230 4
a1233 2
         break;
      case CPU_188:
d1235 1
a1235 1
         vaddr = (u_char *)iomap_mapin(M188_IACK, NBPG, 1);
d1237 1
a1237 1
         vaddr = (u_char *)M188_IACK;
d1239 4
a1242 2
         break;
      case CPU_197:
d1244 1
a1244 1
         vaddr = (u_char *)iomap_mapin(M197_IACK, NBPG, 1);
d1246 1
a1246 1
         vaddr = (u_char *)M197_IACK;
d1248 5
a1252 2
         break;
   }
d1254 1
a1254 1
   printf("interrupt ACK address mapped at 0x%x\n", vaddr);
d1256 8
a1263 8
   ivec[0] = vaddr + 0x03;
   ivec[1] = vaddr + 0x07;
   ivec[2] = vaddr + 0x0b;
   ivec[3] = vaddr + 0x0f;
   ivec[4] = vaddr + 0x13;
   ivec[5] = vaddr + 0x17;
   ivec[6] = vaddr + 0x1b;
   ivec[7] = vaddr + 0x1f;
d1270 1
a1270 1
   vm_offset_t addr = 0;
d1272 1
a1272 1
   addr = (vm_offset_t)kmem_alloc(kernel_map, INTSTACK_SIZE + 4096);
d1274 2
a1275 2
   if (addr == NULL)
      panic("Cannot allocate slave stack");
d1277 4
a1280 4
   if (interrupt_stack[0] == 0)
      interrupt_stack[0] = (vm_offset_t) intstack;
   interrupt_stack[cpu_number()] = addr;
   return addr;
d1287 3
a1289 3
   printf("slave CPU%d started\n", cpu_number());
   while (-1); /* spin forever */
   return 0;
d1304 2
a1305 2
   register struct intrhand *intr;
   int vec;
d1307 6
a1312 6
   if (start < 0 || end > 255 || start > end)
      return (-1);
   for (vec = end; vec > start; --vec)
      if (intr_handlers[vec] == (struct intrhand *)0) 
         return (vec);
   return (-1);
d1323 1
a1323 1
   register struct intrhand *intr;
d1325 30
a1354 30
   if (vec < 0 || vec > 255) {
   #if DIAGNOSTIC
      panic("intr_establish: vec (%x) not between 0 and 0xff",
            vec);
   #endif /* DIAGNOSTIC */
      return (INTR_EST_BADVEC);
   }

   if (intr = intr_handlers[vec]) {
      if (intr->ih_ipl != ihand->ih_ipl) {
   #if DIAGNOSTIC
         panic("intr_establish: there are other handlers with vec (%x) at ipl %x, but you want it at %x",
               intr->ih_ipl, vec, ihand->ih_ipl);
   #endif /* DIAGNOSTIC */
         return (INTR_EST_BADIPL);
      }

      /*
       * Go to the end of the chain
       */
      while (intr->ih_next)
         intr = intr->ih_next;
   }

   ihand->ih_next = 0;

   if (intr)
      intr->ih_next = ihand;
   else
      intr_handlers[vec] = ihand;
d1356 1
a1356 1
   return (INTR_EST_SUCC);
d1372 3
a1374 3
                    0,0,SYSCV_TIMER2,SYSCV_SYSF,0,0,SYSCV_SCC,0,
                    0,0,0,0,0,0,0,0,
                    0,0,0,0,0,0,0,0, 
d1381 86
a1466 86
   register int cpu = 0; /*cpu_number();*/
   register unsigned int cur_mask;
   register unsigned int level, old_spl;
   register struct intrhand *intr;
   int ret, intnum;
   unsigned vec;

   cur_mask = ISR_GET_CURRENT_MASK(cpu);
   old_spl = m188_curspl[cpu];
   eframe->mask = old_spl;

   if (! cur_mask) {
      /*
       * Spurious interrupts - may be caused by debug output clearing
       * DUART interrupts.
       */
      flush_pipeline();
      return;
   }

   /* We want to service all interrupts marked in the IST register  */
   /* They are all valid because the mask would have prevented them */
   /* from being generated otherwise.  We will service them in order of       */
   /* priority. */
   do {
      /*
      printf("interrupt: mask = 0x%08x spl = %d imr = 0x%x\n", ISR_GET_CURRENT_MASK(cpu),
                        old_spl, *int_mask_reg[cpu]);
      */
      level = safe_level(cur_mask, old_spl);

      if (old_spl >= level) {
         register int i;

         printf("safe level %d <= old level %d\n", level, old_spl);
         printf("cur_mask = 0x%b\n", cur_mask, IST_STRING);
         for (i = 0; i < 4; i++)
            printf("IEN%d = 0x%b  ", i, *int_mask_reg[i], IST_STRING);
         printf("\nCPU0 spl %d  CPU1 spl %d  CPU2 spl %d  CPU3 spl %d\n",
                m188_curspl[0], m188_curspl[1],
                m188_curspl[2], m188_curspl[3]);
         for (i = 0; i < 8; i++)
            printf("int_mask[%d] = 0x%08x\n", i, int_mask_val[i]);
         printf("--CPU %d halted--", cpu_number());
         spl7();
         while (1)
            ;
      }

      setipl((u_char)level);

      if (level > 7 || (char)level < 0) {
         panic("int level (%x) is not between 0 and 7", level);
      }
      
      /* generate IACK and get the vector */
      
      /* 
       * This is tricky.  If you don't catch all the 
       * interrupts, you die. Game over. Insert coin... 
       * XXX smurph
       */
      
      intnum = ff1(cur_mask);
      if (intnum & OBIO_INTERRUPT_MASK) {
         vec = obio_vec[intnum];
         if (vec = 0) {
            printf("unknown onboard interrupt: mask = 0x%b\n", 1 << intnum, IST_STRING);
            panic("m188_ext_int");
         }
      } else if (intnum & HW_FAILURE_MASK) {
         vec = obio_vec[intnum];
         if (vec = 0) {
            printf("unknown hadware failure: mask = 0x%b\n", 1 << intnum, IST_STRING);
            panic("m188_ext_int");
         }
      } else if (intnum & VME_INTERRUPT_MASK) {
         asm volatile("tb1	0, r0, 0"); 
         if (guarded_access(ivec[level], 1, &vec) == EFAULT) {
            printf("Unable to get vector for this vmebus interrupt (level %x)\n", level);
            goto out_m188;
         }
      } else {
         printf("unknown interrupt: mask = 0x%b\n", 1 << intnum, IST_STRING);
         panic("m188_ext_int");
      }
d1468 22
a1489 22
      if (cur_mask & ABRT_BIT) { /* abort button interrupt */
         vec = 110;
      } else if (cur_mask & DTI_BIT) { /* interval timer interrupt */
         vec = SYSCV_TIMER1; 
      } else if (cur_mask & CIOI_BIT) { /* statistics timer interrupt */
         vec = SYSCV_TIMER2; 
      } else if (cur_mask & DI_BIT) { /* duart interrupt */
         vec = SYSCV_SCC; 
      } else { /* vmebus interrupt */
         asm volatile("tb1	0, r0, 0"); 
         if (guarded_access(ivec[level], 1, &vec) == EFAULT) {
            printf("Unable to get vector for this vmebus interrupt (level %x)\n", level);
            goto out_m188;
         }
      }
#endif
      asm volatile("tb1	0, r0, 0"); 
      asm volatile("tb1	0, r0, 0"); 
      asm volatile("tb1	0, r0, 0"); 
      if (vec > 0xFF) {
         panic("interrupt vector %x greater than 255", vec);
      }
d1491 1
a1491 1
      enable_interrupt(); /* should we ?? */
d1494 40
a1533 40
      if ((intr = intr_handlers[vec]) == 0)
         printf("Spurious interrupt (level %x and vec %x)\n", level, vec);
      
      /*
       * Walk through all interrupt handlers in the chain for the
       * given vector, calling each handler in turn, till some handler
       * returns a value != 0.
       */
      for (ret = 0; intr; intr = intr->ih_next) {
         if (intr->ih_wantframe)
            ret = (*intr->ih_fn)(intr->ih_arg, (void *)eframe);
         else
            ret = (*intr->ih_fn)(intr->ih_arg);
         if (ret)
            break;
      }
      if (ret == 0) 
         printf("Unclaimed interrupt (level %x and vec %x)\n", level, vec);
   } while (cur_mask = ISR_GET_CURRENT_MASK(cpu));


   /*
    * process any remaining data access exceptions before
    * returning to assembler
    */
   disable_interrupt();
out_m188:
   if (eframe->dmt0 & DMT_VALID) {
      trap(T_DATAFLT, eframe);
      data_access_emulation(eframe);
      eframe->dmt0 &= ~DMT_VALID;
   }

   /*
    * Restore the mask level to what it was when the interrupt
    * was taken.
    */
   setipl((u_char)eframe->mask);
   flush_pipeline();
   return;
d1551 107
a1657 107
   register u_char mask, level, xxxvec;
   register struct intrhand *intr;
   int ret;
   u_char vec;

   /* get level and mask */
   asm volatile("ld.b	%0,%1" : "=r" (mask) : "" (*pcc2intr_mask));
   asm volatile("ld.b	%0,%1" : "=r" (level) : "" (*pcc2intr_ipl));

   /*
    * It is really bizarre for the mask and level to the be the same.
    * pcc2 for 187 blocks all interrupts at and below the mask value,
    * so we should not be getting an interrupt at the level that is
    * already blocked. I can't explain this case XXX nivas
    */

   if ((mask == level) && level) {
      printf("mask == level, %d\n", level);
      goto beatit;
   }

   /*
    * Interrupting level cannot be 0--0 doesn't produce an interrupt.
    * Weird! XXX nivas
    */

   if (level == 0) {
      printf("Bogons... level %x and mask %x\n", level, mask);
      goto beatit;
   }

   /* and block interrupts at level or lower */
   setipl((u_char)level);
   /* and stash it away in the trap frame */
   eframe->mask = mask;

   if (level > 7 || (char)level < 0) {
      panic("int level (%x) is not between 0 and 7", level);
   }

   /* generate IACK and get the vector */
   asm volatile("tb1	0, r0, 0"); 
   if (guarded_access(ivec[level], 1, &vec) == EFAULT) {
      printf("Unable to get vector for this interrupt (level %x)\n", level);
      goto out;
   }
   asm volatile("tb1	0, r0, 0"); 
   asm volatile("tb1	0, r0, 0"); 
   asm volatile("tb1	0, r0, 0"); 
   /*vec = xxxvec;*/

   if (vec > 0xFF) {
      panic("interrupt vector %x greater than 255", vec);
   }

   enable_interrupt();

   if ((intr = intr_handlers[vec]) == 0) {
      printf("Spurious interrupt (level %x and vec %x)\n",
             level, vec);
   }
   if (intr && intr->ih_ipl != level) {
      panic("Handler ipl %x not the same as level %x. vec = 0x%x",
            intr->ih_ipl, level, vec);
   }

   /*
    * Walk through all interrupt handlers in the chain for the
    * given vector, calling each handler in turn, till some handler
    * returns a value != 0.
    */

   for (ret = 0; intr; intr = intr->ih_next) {
      if (intr->ih_wantframe)
         ret = (*intr->ih_fn)(intr->ih_arg, (void *)eframe);
      else
         ret = (*intr->ih_fn)(intr->ih_arg);
      if (ret)
         break;
   }

   if (ret == 0) {
      printf("Unclaimed interrupt (level %x and vec %x)\n",
             level, vec);
   }

   /*
    * process any remaining data access exceptions before
    * returning to assembler
    */
   disable_interrupt();

out:
   if (cputyp != CPU_197) {
      if (eframe->dmt0 & DMT_VALID) {
         trap(T_DATAFLT, eframe);
         data_access_emulation(eframe);
         eframe->dmt0 &= ~DMT_VALID;
      }
   }
   mask = eframe->mask;

   /*
    * Restore the mask level to what it was when the interrupt
    * was taken.
    */
   setipl((u_char)mask);
d1659 2
a1660 2
beatit:
   return;
d1668 1
a1668 1
   return ENOEXEC;
d1676 12
a1687 12
   struct sys_sysarch_args /* {
      syscallarg(int) op;
      syscallarg(char *) parm;
   } */ *uap = v;
   int error = 0;

   switch ((int)SCARG(uap, op)) {
      default:
         error = EINVAL;
         break;
   }
   return (error);
d1704 9
a1712 9
   /* all sysctl names are this level are terminal */
   if (namelen != 1)
      return (ENOTDIR); /* overloaded */

   switch (name[0]) {
      default:
         return (EOPNOTSUPP);
   }
   /*NOTREACHED*/
d1723 7
a1729 7
   register struct prochd *element, *head;
   element = velement;
   head = vhead;
   element->ph_link = head->ph_link;
   head->ph_link = (struct proc *)element;
   element->ph_rlink = (struct proc *)head;
   ((struct prochd *)(element->ph_link))->ph_rlink=(struct proc *)element;
d1740 5
a1744 5
   register struct prochd *element;
   element = velement;
   ((struct prochd *)(element->ph_link))->ph_rlink = element->ph_rlink;
   ((struct prochd *)(element->ph_rlink))->ph_link = element->ph_link;
   element->ph_rlink = (struct proc *)0;
d1754 1
a1754 1
   u_int tally;
d1756 1
a1756 1
   tally = 0;
d1758 8
a1765 8
   while (maxlength--) {
      *(u_char *)toaddr = *(u_char *)fromaddr++;
      tally++;
      if (*(u_char *)toaddr++ == 0) {
         if (lencopied) *lencopied = tally;
         return (0);
      }
   }
d1767 2
a1768 2
   if (lencopied)
      *lencopied = tally;
d1770 1
a1770 1
   return (ENAMETOOLONG);
d1777 12
a1788 12
   register struct prochd *q;
   register struct proc *oldlast;
   register int which = p->p_priority >> 2;

   if (p->p_back != NULL)
      panic("setrunqueue %x", p);
   q = &qs[which];
   whichqs |= 1 << which;
   p->p_forw = (struct proc *)q;
   p->p_back = oldlast = q->ph_rlink;
   q->ph_rlink = p;
   oldlast->p_forw = p;
d1799 12
a1810 12
   register struct proc *p = vp;
   register int which = p->p_priority >> 2;
   register struct prochd *q;

   if ((whichqs & (1 << which)) == 0)
      panic("remrq %x", p);
   p->p_forw->p_back = p->p_back;
   p->p_back->p_forw = p->p_forw;
   p->p_back = NULL;
   q = &qs[which];
   if (q->ph_link == (struct proc *)q)
      whichqs &= ~(1 << which);
d1823 4
a1826 4
   struct bugniocall niocall;
   struct bugbrdid brdid;
   bugbrdid(&brdid);
   bcopy(&brdid.etheraddr, cp, 6);
d1832 8
a1839 8
   if (netisr & (1 << NETISR_ARP)) {
      netisr &= ~(1 << NETISR_ARP);
      arpintr();
   }
   if (netisr & (1 << NETISR_IP)) {
      netisr &= ~(1 << NETISR_IP);
      ipintr();
   }
d1842 4
a1845 4
   if (netisr & (1 << NETISR_IPV6)) {
      netisr &= ~(1 << NETISR_IPV6);
      ip6intr();
   }
d1848 4
a1851 4
   if (netisr & (1 << NETISR_ATALK)) {
      netisr &= ~(1 << NETISR_ATALK);
      atintr();
   }
d1854 4
a1857 4
   if (netisr & (1 << NETISR_NS)) {
      netisr &= ~(1 << NETISR_NS);
      nsintr();
   }
d1860 4
a1863 4
   if (netisr & (1 << NETISR_ISO)) {
      netisr &= ~(1 << NETISR_ISO);
      clnlintr();
   }
d1866 4
a1869 4
   if (netisr & (1 << NETISR_CCITT)) {
      netisr &= ~(1 << NETISR_CCITT);
      ccittintr();
   }
d1873 4
a1876 4
   if (netisr & (1 << NETISR_PPP)) {
      netisr &= ~(1 << NETISR_PPP);
      pppintr();
   }
d1880 4
a1883 4
   if (netisr & (1 << NETISR_BRIDGE)) {
      netisr &= ~(1 << NETISR_BRIDGE);
      bridgeintr();
   }
d1890 11
a1900 11
   if (ssir & SIR_NET) {
      siroff(SIR_NET);
      cnt.v_soft++;
      netintr();
   }

   if (ssir & SIR_CLOCK) {
      siroff(SIR_CLOCK);
      cnt.v_soft++;
      softclock();
   }
d1902 1
a1902 1
   return;
d1908 3
a1910 3
   int x;
   int level = 0;
   x = splsoftclock();
d1912 3
a1914 3
   if (ssir) {
      dosoftint();
   }
d1916 1
a1916 1
   setipl(0);
d1918 1
a1918 1
   return (x);
d1923 1
a1923 1
   return badaddr((vm_offset_t)addr, 4);
d1932 2
a1933 2
   regdump(f);
   printf("proc %x flags %x type %s\n", p, flags, s);
d1940 1
a1940 1
   regdump(f);
d1946 1
a1946 1
   struct m88100_saved_state *frame = framep;
d1949 2
a1950 2
   DEBUG_MSG("Abort Pressed\n");
   Debugger();
d1952 1
a1952 1
   DEBUG_MSG("Spurious NMI?\n");
d1959 78
a2036 72
   printf("R00-05: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
          R(0),R(1),R(2),R(3),R(4),R(5));
   printf("R06-11: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
          R(6),R(7),R(8),R(9),R(10),R(11));
   printf("R12-17: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
          R(12),R(13),R(14),R(15),R(16),R(17));
   printf("R18-23: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
          R(18),R(19),R(20),R(21),R(22),R(23));
   printf("R24-29: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
          R(24),R(25),R(26),R(27),R(28),R(29));
   printf("R30-31: 0x%08x  0x%08x\n",R(30),R(31));
   if (cputyp == CPU_197) {
      printf("exip %x enip %x\n", f->sxip, f->snip);
   } else {
      printf("sxip %x snip %x sfip %x\n", f->sxip, f->snip, f->sfip);
   }
   if (f->vector == 0x3 && cputyp != CPU_197) { 
      /* print dmt stuff for data access fault */
      printf("dmt0 %x dmd0 %x dma0 %x\n", f->dmt0, f->dmd0, f->dma0);
      printf("dmt1 %x dmd1 %x dma1 %x\n", f->dmt1, f->dmd1, f->dma1);
      printf("dmt2 %x dmd2 %x dma2 %x\n", f->dmt2, f->dmd2, f->dma2);
      printf("fault type %d\n", (f->dpfsr >> 16) & 0x7);
      dae_print(f);
   }
   if (longformat && cputyp != CPU_197) {
      printf("fpsr %x ", f->fpsr);
      printf("fpcr %x ", f->fpcr);
      printf("epsr %x ", f->epsr);
      printf("ssbr %x\n", f->ssbr);
      printf("fpecr %x ", f->fpecr);
      printf("fphs1 %x ", f->fphs1);
      printf("fpls1 %x ", f->fpls1);
      printf("fphs2 %x ", f->fphs2);
      printf("fpls2 %x\n", f->fpls2);
      printf("fppt %x ", f->fppt);
      printf("fprh %x ", f->fprh);
      printf("fprl %x ", f->fprl);
      printf("fpit %x\n", f->fpit);
      printf("vector %x ", f->vector);
      printf("mask %x ", f->mask);
      printf("mode %x ", f->mode);
      printf("scratch1 %x ", f->scratch1);
      printf("pad %x\n", f->pad);
   }
   if (longformat && cputyp == CPU_197) {
      printf("fpsr %x ", f->fpsr);
      printf("fpcr %x ", f->fpcr);
      printf("fpecr %x ", f->fpecr);
      printf("epsr %x\n", f->epsr);
      printf("dsap %x ", f->dmt1);
      printf("dsr %x ", f->dsr);
      printf("dlar %x ", f->dlar);
      printf("dpar %x\n", f->dpar);
      printf("isap %x ", f->dmt0);
      printf("isr %x ", f->isr);
      printf("ilar %x ", f->ilar);
      printf("ipar %x\n", f->ipar);
      printf("vector %x ", f->vector);
      printf("mask %x ", f->mask);
      printf("mode %x ", f->mode);
      printf("scratch1 %x ", f->scratch1);
      printf("pad %x\n", f->pad);
   }
   if (cputyp == CPU_188 ) {
      unsigned int istr, cur_mask;
      
      istr = *(volatile int *)IST_REG;
      cur_mask = GET_MASK(0, istr);
      printf("emask = 0x%b\n", f->mask, IST_STRING);
      printf("istr  = 0x%b\n", istr, IST_STRING);
      printf("cmask = 0x%b\n", cur_mask, IST_STRING);
   }
d2043 1
a2043 1
   return (db_setipl(IPL_HIGH));
d2049 1
a2049 1
   return (db_setipl(s));
d2063 28
a2090 28
   extern char *edata, *end;
   extern int cold;
   extern unsigned number_cpus;
   extern int kernelstart;
   extern int lock_wait_time;
   extern vm_offset_t size_memory(void);
   extern struct consdev *cn_tab;
   extern unsigned vector_list;
   struct bugbrdid brdid;

   cold = 1;  /* we are still booting */
   
   /* zreo out the machine dependant function pointers */
   bzero(&mdfp, sizeof(struct funcp));
   
   buginit(); /* init the bug routines */
   bugbrdid(&brdid);
   cputyp = brdid.brdno;
   
   /* to support the M8120.  It's based off of MVME187 */
   if (cputyp == 0x8120)
      cputyp = CPU_187;
   
   /* 
    * set up interrupt and fp exception handlers 
    * based on the machine.
    */
   switch (cputyp) {
d2092 9
a2100 9
   case CPU_188:
      mdfp.interrupt_func = &m188_ext_int;
      mdfp.fp_precise_func = &m88100_Xfp_precise;
      /* clear and disable all interrupts */
      *int_mask_reg[0] = 0;
      *int_mask_reg[1] = 0;
      *int_mask_reg[2] = 0;
      *int_mask_reg[3] = 0;
      break;
d2103 4
a2106 4
   case CPU_187:
      mdfp.interrupt_func = &sbc_ext_int;
      mdfp.fp_precise_func = &m88100_Xfp_precise;
      break;
d2109 5
a2113 5
   case CPU_197:
      mdfp.interrupt_func = &sbc_ext_int;
      mdfp.fp_precise_func = &m88110_Xfp_precise;
      set_tcfp(); /* Set Time Critical Floating Point Mode */
      break;
d2115 24
a2138 24
   default:
      panic("mvme_bootstrap: Can't determine cpu type.");
   }

   /* startup fake console driver.  It will be replaced by consinit() */
   cn_tab = &bootcons;

   vm_set_page_size();

   first_addr = m88k_round_page(first_addr);

   if (!no_symbols) boothowto |= RB_KDB;

   last_addr = size_memory();
   cmmu_parity_enable();

   printf("%s",version);
   identifycpu();
   setup_board_config();
   cmmu_init();
   master_cpu = cmmu_cpu_number();
   set_cpu_number(master_cpu);
   printf("CPU%d is master CPU\n", master_cpu);
   
d2140 7
a2146 7
   if (cputyp == CPU_188 && (boothowto & RB_MINIROOT)) {
      int i;
      for (i=0; i<MAX_CPUS; i++) {
         if(!spin_cpu(i))
            printf("CPU%d started\n", i);
      }
   }
d2148 2
a2149 2
   avail_start = first_addr;
   avail_end = last_addr;
d2151 1
a2151 1
   printf("MVME%x boot: memory from 0x%x to 0x%x\n", cputyp, avail_start, avail_end);
d2153 23
a2175 23
   /*
    * Steal one page at the top of physical memory for msgbuf
    */
   avail_end -= PAGE_SIZE;
   pmap_bootstrap((vm_offset_t)M88K_TRUNC_PAGE((unsigned)&kernelstart) /* = loadpt */, 
                  &avail_start, &avail_end, &virtual_avail,
                  &virtual_end);

   /*
    * Must initialize p_addr before autoconfig or
    * the fault handler will get a NULL reference.
    */
   proc0.p_addr = proc0paddr;
   curproc = &proc0;
   curpcb = &proc0paddr->u_pcb;

   /* Initialize cached PTEs for u-area mapping. */
   save_u_area(&proc0, (vm_offset_t)proc0paddr);

   /*
    * Map proc0's u-area at the standard address (UADDR).
    */
   load_u_area(&proc0);
d2177 2
a2178 2
   /* Initialize the "u-area" pages. */
   bzero((caddr_t)UADDR, UPAGES*NBPG);
d2180 1
a2180 1
   printf("leaving mvme_bootstrap()\n");
d2192 3
a2194 3
   cp->cn_dev = makedev(14, 0);
   cp->cn_pri = CN_NORMAL;
   return (1);
d2201 1
a2201 1
   /* Nothing to do */
d2208 1
a2208 1
   return (buginchr());
d2216 4
a2219 5
   int s;

   if (c == '\n')
      bugoutchr('\r');
   bugoutchr(c);
@


1.19
log
@enlarge msgbuf, somewhat line netbsd did
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.18 1999/12/08 06:50:16 itojun Exp $	*/
d58 1
a58 1
#include <sys/callout.h>
d639 1
a639 1
    * Initialize callouts
d641 1
a641 4
   callfree = callout;
   for (i = 1; i < ncallout; i++)
      callout[i-1].c_next = &callout[i];
   callout[i-1].c_next = NULL;
d700 1
a700 1
   valloc(callout, struct callout, ncallout);
@


1.18
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.17 1999/09/27 19:13:23 smurph Exp $	*/
a159 1
int msgbufmapped = 0;
d463 1
a463 1
   for (i = 0; i < btoc(sizeof(struct msgbuf)); i++)
d465 3
a467 4
			avail_end + i * NBPG, VM_PROT_READ|VM_PROT_WRITE,
			VM_PROT_READ|VM_PROT_WRITE, TRUE);

   msgbufmapped = 1;
d1161 2
@


1.18.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/* $OpenBSD$	*/
d160 1
d464 1
a464 1
   for (i = 0; i < btoc(MSGBUFSIZE); i++)
d466 4
a469 3
	avail_end + i * NBPG, VM_PROT_READ|VM_PROT_WRITE,
	VM_PROT_READ|VM_PROT_WRITE, TRUE);
   initmsgbuf((caddr_t)msgbufp, round_page(MSGBUFSIZE));
a1162 2
   extern int msgbufmapped;

@


1.18.2.2
log
@Sync with -current
@
text
@d58 1
a58 1
#include <sys/timeout.h>
d639 1
a639 1
    * Initialize timeouts
d641 4
a644 1
   timeout_init();
d703 1
a703 1
   valloc(timeouts, struct timeout, ntimeout);
@


1.18.2.3
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.31 2001/04/17 04:30:47 aaron Exp $	*/
d3 1
a3 1
 * Copyright (c) 1998, 1999, 2000, 2001 Steve Murphree, Jr.
d65 1
a65 1
#include <sys/msg.h>
d68 1
a68 1
#include <sys/sem.h>
d71 1
a71 1
#include <sys/shm.h>
a76 1

d79 2
a80 1
#include <machine/locore.h>
a87 2
#include <machine/m88100.h>  		/* DMT_VALID        */
#include <machine/m882xx.h>  		/* CMMU stuff       */
d95 4
a98 10

#if defined(UVM)
#include <uvm/uvm_extern.h>
#endif

#include <mvme88k/dev/sysconreg.h>
#include <mvme88k/dev/pcctworeg.h>

#include "assym.s"			/* EF_EPSR, etc. */
#include "ksyms.h"
d100 1
a100 2
#include <machine/db_machdep.h>
#include <ddb/db_output.h>		/* db_printf()		*/
d117 13
a129 19
void m88100_Xfp_precise __P((void));
void m88110_Xfp_precise __P((void));
void setupiackvectors __P((void));
void regdump __P((struct trapframe *f));
void dumpsys __P((void));
void configure __P((void));
void consinit __P((void));
void kdb_init __P((void));

volatile unsigned char *ivec[] = {
	(unsigned char *)0xFFFE0003, /* not used, no such thing as int 0 */
	(unsigned char *)0xFFFE0007,
	(unsigned char *)0xFFFE000B,
	(unsigned char *)0xFFFE000F,
	(unsigned char *)0xFFFE0013,
	(unsigned char *)0xFFFE0017,
	(unsigned char *)0xFFFE001B,
	(unsigned char *)0xFFFE001F,
	(unsigned char *)0x00000000,
d138 4
a141 4
	(volatile unsigned int *)IEN0_REG,
	(volatile unsigned int *)IEN1_REG,
	(volatile unsigned int *)IEN2_REG,
	(volatile unsigned int *)IEN3_REG
d143 1
a143 1
#endif 
a144 1
#if defined(MVME187) || defined(MVME197)
a146 2
#endif /* defined(MVME187) || defined(MVME197) */

d157 2
a158 2
int physmem;	  /* available physical memory, in pages */
int cold;	  /* boot process flag */
a168 8
#if defined(UVM)
vm_map_t exec_map = NULL;
vm_map_t mb_map = NULL;
vm_map_t phys_map = NULL;
#else
vm_map_t buffer_map;
#endif

d175 1
a175 7

#if defined(UVM)
vaddr_t iomapbase;
#else
vm_offset_t iomapbase;
#endif 

d201 1
a201 1
char  machine[] = "mvme88k";	 /* cpu "architecture" */
d204 1
d208 9
a216 9
	void *entry;
	void *symtab;
	void *esym;
	int   bflags;
	int   bdev;
	char *kname;
	void *smini;
	void *emini;
	void *end_load;
d218 1
a218 3
#if defined(DDB) || NKSYMS > 0
extern char *esym;
#endif
d258 2
a259 5
	(void (*))NULL, 
	(void (*))NULL, 
	bootcngetc, 
	(void (*))bootcnputc,
	bootcnpollc, NULL, makedev(14,0), 1};
d269 12
a280 12
	extern struct consdev *cn_tab;
	/*
	 * Initialize the console before we print anything out.
	 */

	cn_tab = NULL;
	cninit();

#if defined(DDB)
	kdb_init();
	if (boothowto & RB_KDB)
		Debugger();
d292 3
a294 3
	volatile unsigned int *look;
	unsigned int *max;
	extern char *end;
d298 12
a309 11
	/*
	 * count it up.
	 */
	max = (void*)MAXPHYSMEM;
	for (look = (void*)Roundup(end, STRIDE); look < max;
	    look = (int*)((unsigned)look + STRIDE)) {
		unsigned save;

		/* if can't access, we've reached the end */
		if (foodebug) printf("%x\n", look);
		if (badwordaddr((void*)look)) {
d311 1
a311 1
			printf("%x\n", look);
d313 21
a333 22
			look = (int *)((int)look - STRIDE);
			break;
		}

		/*
		 * If we write a value, we expect to read the same value back.
		 * We'll do this twice, the 2nd time with the opposite bit
		 * pattern from the first, to make sure we check all bits.
		 */
		save = *look;
		if (*look = PATTERN, *look != PATTERN)
			break;
		if (*look = ~PATTERN, *look != ~PATTERN)
			break;
		*look = save;
	}
	if ((look > (unsigned int *)0x01FFF000) && (cputyp == CPU_188)) {
                /* temp hack to fake 32Meg on MVME188 */
		look = (unsigned int *)0x01FFF000; 
	}
	physmem = btoc(trunc_page((unsigned)look)); /* in pages */
	return (trunc_page((unsigned)look));
d339 12
a350 12
	struct bugbrdid brdid;
	int speed = 0;
	int i, c;
	bugbrdid(&brdid);
	for (i=0; i<4; i++) {
		c=(unsigned char)brdid.speed[i];
		c-= '0';
		speed *=10;
		speed +=c;
	}
	speed = speed / 100;
	return (speed);
d356 12
a367 12
	struct bugbrdid brdid;
	int scsiid = 0;
	int i, c;
	bugbrdid(&brdid);
	for (i=0; i<2; i++) {
		c=(unsigned char)brdid.scsiid[i];
		scsiid *=10;
		c-= '0';
		scsiid +=c;
	}
	printf("SCSI ID = %d\n", scsiid);
	return (7); /* hack! */
d373 3
a375 3
	cpuspeed = getcpuspeed();
	sprintf(cpu_model, "Motorola MVME%x %dMhz", cputyp, cpuspeed);
	printf("\nModel: %s\n", cpu_model);
d378 9
d394 4
a397 4
	int i; 
	for (i=0; i<UPAGES; i++) {
		p->p_md.md_upte[i] = kvtopte((va + (i * NBPG)))->bits;
	}
d403 1
a403 1
	pte_template_t *t;
d405 8
a412 8
	int i; 
	for (i=0; i<UPAGES; i++) {
		t = kvtopte((UADDR + (i * NBPG)));
		t->bits = p->p_md.md_upte[i];
	}
	for (i=0; i<UPAGES; i++) {
		cmmu_flush_tlb(1, (UADDR + (i * NBPG)), NBPG);
	}
d423 1
a423 1
	printf("cpu_initclocks(): ");
d425 1
a425 1
	if (mdfp.clock_init_func != NULL) {
d427 1
a427 1
		printf("[interval clock] ");
d429 3
a431 3
		(*mdfp.clock_init_func)();
	}
	if (mdfp.statclock_init_func != NULL) {
d433 1
a433 1
		printf("[statistics clock]");
d435 2
a436 2
		(*mdfp.statclock_init_func)();
	}
d438 1
a438 1
	printf("\n");
d452 144
a595 244
	caddr_t v;
	int sz, i;
	vm_size_t size;    
	int base, residual;
#if defined(UVM)
	vaddr_t minaddr, maxaddr, uarea_pages;
#else
	vm_offset_t minaddr, maxaddr, uarea_pages;
#endif 

	/*
	 * Initialize error message buffer (at end of core).
	 * avail_end was pre-decremented in mvme_bootstrap().
	 */

	for (i = 0; i < btoc(MSGBUFSIZE); i++)
		pmap_enter(kernel_pmap, (vm_offset_t)msgbufp,
			   avail_end + i * NBPG, VM_PROT_READ|VM_PROT_WRITE,
			   VM_PROT_READ|VM_PROT_WRITE, TRUE);
	initmsgbuf((caddr_t)msgbufp, round_page(MSGBUFSIZE));

	/*
	 * Good {morning,afternoon,evening,night}.
	 */
	printf("%s",version);
	printf("real mem  = %d\n", ctob(physmem));

	/*
	 * Find out how much space we need, allocate it,
	 * and then give everything true virtual addresses.
	 */
	sz = (int)allocsys((caddr_t)0);

#if defined(UVM)
	if ((v = (caddr_t)uvm_km_zalloc(kernel_map, m88k_round_page(sz))) == 0)
#else
	if ((v = (caddr_t)kmem_alloc(kernel_map, m88k_round_page(sz))) == 0)
#endif
		panic("startup: no room for tables");
	if (allocsys(v) - v != sz)
		panic("startup: table size inconsistency");

	/*
	 * Grab UADDR virtual address
	 */
	uarea_pages = UADDR;
#if defined(UVM)
	uvm_map(kernel_map, (vaddr_t *)&uarea_pages, USPACE,
		NULL, UVM_UNKNOWN_OFFSET,UVM_MAPFLAG(UVM_PROT_NONE, 
						     UVM_PROT_NONE,
						     UVM_INH_NONE,
						     UVM_ADV_NORMAL, 0));
#else
	vm_map_find(kernel_map, vm_object_allocate(USPACE), 0,
		    (vm_offset_t *)&uarea_pages, USPACE, TRUE);
#endif
	if (uarea_pages != UADDR) {
		printf("uarea_pages %x: UADDR not free\n", uarea_pages);
		panic("bad UADDR");
	}
	
	/* 
	 * Grab machine dependant memory spaces
	 */
	switch (cputyp) {
#ifdef MVME187
	case CPU_187:
#endif 
#ifdef MVME197
	case CPU_197:
#endif 

#if defined(MVME187) || defined(MVME197)
		/*
		 * Grab the BUGROM space that we hardwired in pmap_bootstrap
		 */
		bugromva = BUGROM_START;

#if defined(UVM)
		uvm_map(kernel_map, (vaddr_t *)&bugromva, BUGROM_SIZE,
			NULL, UVM_UNKNOWN_OFFSET,UVM_MAPFLAG(UVM_PROT_NONE, 
							     UVM_PROT_NONE,
							     UVM_INH_NONE,
							     UVM_ADV_NORMAL, 0));
#else
		vm_map_find(kernel_map, vm_object_allocate(BUGROM_SIZE), 0,
			    (vm_offset_t *)&bugromva, BUGROM_SIZE, TRUE);
#endif
		if (bugromva != BUGROM_START) {
			printf("bugromva %x: BUGROM not free\n", bugromva);
			panic("bad bugromva");
		}
		
		/*
		 * Grab the SRAM space that we hardwired in pmap_bootstrap
		 */
		sramva = SRAM_START;
#if defined(UVM)
		uvm_map(kernel_map, (vaddr_t *)&sramva, SRAM_SIZE,
			NULL, UVM_UNKNOWN_OFFSET,UVM_MAPFLAG(UVM_PROT_NONE, 
							     UVM_PROT_NONE,
							     UVM_INH_NONE,
							     UVM_ADV_NORMAL, 0));
#else
		vm_map_find(kernel_map, vm_object_allocate(SRAM_SIZE), 0,
			    (vm_offset_t *)&sramva, SRAM_SIZE, TRUE);
#endif

		if (sramva != SRAM_START) {
			printf("sramva %x: SRAM not free\n", sramva);
			panic("bad sramva");
		}

		/*
		 * Grab the OBIO space that we hardwired in pmap_bootstrap
		 */
		obiova = OBIO_START;
#if defined(UVM)
		uvm_map(kernel_map, (vaddr_t *)&obiova, OBIO_SIZE,
			NULL, UVM_UNKNOWN_OFFSET,UVM_MAPFLAG(UVM_PROT_NONE, 
							     UVM_PROT_NONE,
							     UVM_INH_NONE,
							     UVM_ADV_NORMAL, 0));
#else
		vm_map_find(kernel_map, vm_object_allocate(OBIO_SIZE), 0,
			    (vm_offset_t *)&obiova, OBIO_SIZE, TRUE);
#endif
		if (obiova != OBIO_START) {
			printf("obiova %x: OBIO not free\n", obiova);
			panic("bad OBIO");
		}
		break;
#endif 
#ifdef MVME188
	case CPU_188:
		/*
		 * Grab the UTIL space that we hardwired in pmap_bootstrap
		 */
		utilva = MVME188_UTILITY;
#if defined(UVM)
		uvm_map(kernel_map, (vaddr_t *)&utilva, MVME188_UTILITY_SIZE,
			NULL, UVM_UNKNOWN_OFFSET,UVM_MAPFLAG(UVM_PROT_NONE, 
							     UVM_PROT_NONE,
							     UVM_INH_NONE,
							     UVM_ADV_NORMAL, 0));
#else
		vm_map_find(kernel_map, vm_object_allocate(MVME188_UTILITY_SIZE), 0,
			    (vm_offset_t *)&utilva, MVME188_UTILITY_SIZE, TRUE);
#endif
		if (utilva != MVME188_UTILITY) {
			printf("utilva %x: UTILITY area not free\n", utilva);
			panic("bad utilva");
		}
		break;
#endif
	default:
		panic("startup: unknown cpu type.");
	}

	/*
	 * Now allocate buffers proper.  They are different than the above
	 * in that they usually occupy more virtual memory than physical.
	 */
	size = MAXBSIZE * nbuf;
#if defined(UVM)
	if (uvm_map(kernel_map, (vaddr_t *) &buffers, m88k_round_page(size),
		    NULL, UVM_UNKNOWN_OFFSET,
		    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
				UVM_ADV_NORMAL, 0)) != KERN_SUCCESS)
		panic("cpu_startup: cannot allocate VM for buffers");
	minaddr = (vaddr_t)buffers;
#else
	buffer_map = kmem_suballoc(kernel_map, (vm_offset_t *)&buffers,
				   &maxaddr, size, TRUE);
	minaddr = (vm_offset_t)buffers;
	if (vm_map_find(buffer_map, vm_object_allocate(size), (vm_offset_t)0,
	    (vm_offset_t *)&minaddr, size, FALSE) != KERN_SUCCESS)
		panic("startup: cannot allocate buffers");
#endif

	if ((bufpages / nbuf) >= btoc(MAXBSIZE)) {
		/* don't want to alloc more physical mem than needed */
		bufpages = btoc(MAXBSIZE) * nbuf;
	}
	base = bufpages / nbuf;
	residual = bufpages % nbuf;

	for (i = 0; i < nbuf; i++) {
#if defined(UVM)
		vsize_t curbufsize;
		vaddr_t curbuf;
		struct vm_page *pg;

		/*
		 * Each buffer has MAXBSIZE bytes of VM space allocated.  Of
		 * that MAXBSIZE space, we allocate and map (base+1) pages
		 * for the first "residual" buffers, and then we allocate
		 * "base" pages for the rest.
		 */
		curbuf = (vm_offset_t) buffers + (i * MAXBSIZE);
		curbufsize = CLBYTES * ((i < residual) ? (base+1) : base);

		while (curbufsize) {
			pg = uvm_pagealloc(NULL, 0, NULL, 0);
			if (pg == NULL)
				panic("cpu_startup: not enough memory for "
				      "buffer cache");
			pmap_enter(kernel_map->pmap, curbuf,
				   VM_PAGE_TO_PHYS(pg), VM_PROT_ALL, TRUE,
				   VM_PROT_READ|VM_PROT_WRITE);
			curbuf += PAGE_SIZE;
			curbufsize -= PAGE_SIZE;
		}
#else
		vm_size_t curbufsize;
		vm_offset_t curbuf;

		/*
		 * First <residual> buffers get (base+1) physical pages
		 * allocated for them.  The rest get (base) physical pages.
		 *
		 * The rest of each buffer occupies virtual space,
		 * but has no physical memory allocated for it.
		 */
		curbuf = (vm_offset_t)buffers + i * MAXBSIZE;
		curbufsize = CLBYTES * (i < residual ? base+1 : base);
		/* this faults in the required physical pages */
		vm_map_pageable(buffer_map, curbuf, curbuf+curbufsize, FALSE);
		vm_map_simplify(buffer_map, curbuf);
#endif 
	}

	/*
	 * Allocate a submap for exec arguments.  This map effectively
	 * limits the number of processes exec'ing at any time.
	 */
#if defined(UVM)
	exec_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
				   16*NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);
#else
	exec_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr,
				 16*NCARGS, TRUE);
#endif
	
d597 1
a597 26
	printf("exe_map from 0x%x to 0x%x\n", (unsigned)minaddr, (unsigned)maxaddr);
#endif 
	/*
	 * Allocate map for physio.
	 */

#if defined(UVM)
	phys_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
				   VM_PHYS_SIZE, 0, FALSE, NULL);
#else
	phys_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr, 
				 VM_PHYS_SIZE, TRUE);
#endif
	if (phys_map == NULL) {
		panic("cpu_startup: unable to create phys_map");
	}

	/* 
	 * Allocate map for external I/O XXX new code - smurph 
	 */
#if defined(UVM)
	iomap_map = uvm_km_suballoc(kernel_map, &iomapbase, &maxaddr,
				   IOMAP_SIZE, 0, FALSE, NULL);
#else
	iomap_map = kmem_suballoc(kernel_map, &iomapbase, &maxaddr, 
				  IOMAP_SIZE, TRUE);
d599 47
a645 33
	if (iomap_map == NULL) {
		panic("cpu_startup: unable to create iomap_map");
	}
	rminit(iomap, IOMAP_SIZE, (u_long)iomapbase, "iomap", NIOPMAP);

	/*
	 * Finally, allocate mbuf pool.  Since mclrefcnt is an off-size
	 * we use the more space efficient malloc in place of kmem_alloc.
	 */
	mclrefcnt = (char *)malloc(NMBCLUSTERS+CLBYTES/MCLBYTES,
				   M_MBUF, M_NOWAIT);
	bzero(mclrefcnt, NMBCLUSTERS+CLBYTES/MCLBYTES);
#if defined(UVM)
	mb_map = uvm_km_suballoc(kernel_map, (vaddr_t *)&mbutl, &maxaddr,
				 VM_MBUF_SIZE, VM_MAP_INTRSAFE, FALSE, NULL);
#else
	mb_map = kmem_suballoc(kernel_map, (vm_offset_t *)&mbutl, &maxaddr,
			       VM_MBUF_SIZE, FALSE);
#endif
	
	/*
	 * Initialize timeouts
	 */
	timeout_init();

#if defined(UVM)
	printf("avail mem = %ld (%ld pages)\n", ptoa(uvmexp.free), uvmexp.free);
#else
	printf("avail mem = %ld (%ld pages)\n", ptoa(cnt.v_free_count),
	    ptoa(cnt.v_free_count)/NBPG);
#endif
	printf("using %d buffers containing %d bytes of memory\n", nbuf,
	    bufpages * CLBYTES);
d648 30
a677 38
	/*
	 * Check to see if a mini-root was loaded into memory. It resides
	 * at the start of the next page just after the end of BSS.
	 */
	{
		extern void *smini;

		if (miniroot && (boothowto & RB_MINIROOT)) {
			boothowto |= RB_DFLTROOT;
			mfs_initminiroot(miniroot);
		}
	}
#endif

	/*
	 * Set up buffers, so they can be used to read disk labels.
	 */
	bufinit();

	/*
	 * Configure the system.
	 */
	nofault = NULL;

	/*
	 * zero out intr_handlers
	 */
	bzero((void *)intr_handlers, 256 * sizeof(struct intrhand *));
	setupiackvectors();

	if (boothowto & RB_CONFIG) {
#ifdef BOOT_CONFIG
		user_config();
#else
		printf("kernel does not support -c; continuing..\n");
#endif
	}
	configure();
d691 1
a691 1
	register caddr_t v;
d698 1
a698 1
	valloc(cfree, struct cblock, nclist);
d700 1
a700 1
	valloc(timeouts, struct timeout, ntimeout);
d702 1
a702 1
	valloc(swapmap, struct map, nswapmap = maxproc * 2);
d705 1
a705 1
	valloc(shmsegs, struct shmid_ds, shminfo.shmmni);
d708 4
a711 4
	valloc(sema, struct semid_ds, seminfo.semmni);
	valloc(sem, struct sem, seminfo.semmns);
	/* This is pretty disgusting! */
	valloc(semu, int, (seminfo.semmnu * seminfo.semusz) / sizeof(int));
d714 28
a741 47
	valloc(msgpool, char, msginfo.msgmax);
	valloc(msgmaps, struct msgmap, msginfo.msgseg);
	valloc(msghdrs, struct msg, msginfo.msgtql);
	valloc(msqids, struct msqid_ds, msginfo.msgmni);
#endif

#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif
	/*
	 * Determine how many buffers to allocate.  We use 10% of the
	 * first 2MB of memory, and 5% of the rest, with a minimum of 16
	 * buffers.  We allocate 1/2 as many swap buffer headers as file
	 * i/o buffers.
	 */
	if (bufpages == 0) {
		if (physmem < btoc(2 * 1024 * 1024))
			bufpages = physmem / (10 * CLSIZE);
		else
			bufpages = (btoc(2 * 1024 * 1024) + physmem) *
			    BUFCACHEPERCENT / (100 * CLSIZE);
	}
	if (nbuf == 0) {
		nbuf = bufpages;
		if (nbuf < 16)
			nbuf = 16;
	}

	/* Restrict to at most 70% filled kvm */
	if (nbuf >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / MAXBSIZE * 7 / 10) 
		nbuf = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    MAXBSIZE * 7 / 10;

	/* More buffer pages than fits into the buffers is senseless.  */
	if (bufpages > nbuf * MAXBSIZE / CLBYTES)
		bufpages = nbuf * MAXBSIZE / CLBYTES;

	if (nswbuf == 0) {
		nswbuf = (nbuf / 2) &~ 1;  /* force even */
		if (nswbuf > 256)
			nswbuf = 256;	  /* sanity */
	}
#if !defined(UVM)
	valloc(swbuf, struct buf, nswbuf);
#endif
	valloc(buf, struct buf, nbuf);
d744 5
a748 5
	/*
	 * Arbitrarily limit the number of devices mapping
	 * the IO space at a given time to NIOPMAP (= 32, default).
	 */
	valloc(iomap, struct map, niomap = NIOPMAP);
d750 1
a750 1
	return v;
d762 4
a765 4
	struct proc *p;
	struct exec_package *pack;
	u_long stack;
	int retval[2];
d767 1
a767 1
	register struct trapframe *tf = USER_REGS(p);
d772 6
a777 6
	/*
	 * The syscall will ``return'' to snip; set it.
	 * argc, argv, envp are placed on the stack by copyregs.
	 * Point r2 to the stack. crt0 should extract envp from
	 * argc & argv before calling user's main.
	 */
d779 19
a797 19
	/*
	 * I don't think I need to mess with fpstate on 88k because
	 * we make sure the floating point pipeline is drained in
	 * the trap handlers. Should check on this later. XXX Nivas.
	 */

	if ((fs = p->p_md.md_fpstate) != NULL) {
		/*
		 * We hold an FPU state.  If we own *the* FPU chip state
		 * we must get rid of it, and the only way to do that is
		 * to save it.  In any case, get rid of our FPU state.
		 */
		if (p == fpproc) {
			savefpstate(fs);
			fpproc = NULL;
		}
		free((void *)fs, M_SUBPROC);
		p->p_md.md_fpstate = NULL;
	}
d799 2
a800 2
	bzero((caddr_t)tf, sizeof *tf);
	tf->epsr = 0x3f0;  /* user mode, interrupts enabled, fp enabled */
d803 13
a815 13
	/*
	 * We want to start executing at pack->ep_entry. The way to
	 * do this is force the processor to fetch from ep_entry. Set
	 * NIP to something bogus and invalid so that it will be a NOOP.
	 * And set sfip to ep_entry with valid bit on so that it will be
	 * fetched.
	 */

	tf->snip = pack->ep_entry & ~3;
	tf->sfip = (pack->ep_entry & ~3) | FIP_V;
	tf->r[2] = stack;
	tf->r[31] = stack;
	retval[1] = 0;
d819 2
a820 2
	int   ss_flags;	     /* which of the following are valid */
	struct   trapframe ss_frame;  /* original exception frame */
d828 6
a833 6
	int   sf_signo;	     /* signo for handler */
	siginfo_t *sf_sip;
	struct   sigcontext *sf_scp;  /* context ptr for handler */
	sig_t sf_handler;    /* handler addr for u_sigc */
	struct   sigcontext sf_sc; /* actual context */
	siginfo_t sf_si;
d850 14
a863 14
	sig_t catcher;
	int sig, mask;
	unsigned long code;
	int type;
	union sigval val;
{
	register struct proc *p = curproc;
	register struct trapframe *tf;
	register struct sigacts *psp = p->p_sigacts;
	struct sigframe *fp;
	int oonstack, fsize;
	struct sigframe sf;
	int addr;
	extern char sigcode[], esigcode[];
d867 20
a886 26
	tf = p->p_md.md_tf;
	oonstack = psp->ps_sigstk.ss_flags & SA_ONSTACK;
	/*
	 * Allocate and validate space for the signal handler
	 * context. Note that if the stack is in data space, the
	 * call to grow() is a nop, and the copyout()
	 * will fail if the process has not already allocated
	 * the space with a `brk'.
	 */
	fsize = sizeof(struct sigframe);
	if ((psp->ps_flags & SAS_ALTSTACK) &&
	    (psp->ps_sigstk.ss_flags & SA_ONSTACK) == 0 &&
	    (psp->ps_sigonstack & sigmask(sig))) {
		fp = (struct sigframe *)(psp->ps_sigstk.ss_sp +
					 psp->ps_sigstk.ss_size - fsize);
		psp->ps_sigstk.ss_flags |= SA_ONSTACK;
	} else
		fp = (struct sigframe *)(tf->r[31] - fsize);
#if defined(UVM)
	if ((unsigned)fp <= USRSTACK - ctob(p->p_vmspace->vm_ssize)) 
		(void)uvm_grow(p, (unsigned)fp);
#else
	if ((unsigned)fp <= USRSTACK - ctob(p->p_vmspace->vm_ssize))
		(void)grow(p, (unsigned)fp);
#endif

d888 73
a960 72
	if ((sigdebug & SDB_FOLLOW) ||
	    (sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
		printf("sendsig(%d): sig %d ssp %x usp %x scp %x\n",
		       p->p_pid, sig, &oonstack, fp, &fp->sf_sc);
#endif
	/*
	 * Build the signal context to be used by sigreturn.
	 */
	sf.sf_signo = sig;
	sf.sf_scp = &fp->sf_sc;
	sf.sf_handler = catcher;
	sf.sf_sc.sc_onstack = oonstack;
	sf.sf_sc.sc_mask = mask;

	if (psp->ps_siginfo & sigmask(sig)) {
		sf.sf_sip = &fp->sf_si;
		initsiginfo(&sf.sf_si, sig, code, type, val);
	}

	/*
	 * Copy the whole user context into signal context that we
	 * are building.
	 */
	bcopy((caddr_t)tf->r, (caddr_t)sf.sf_sc.sc_regs,
	      sizeof(sf.sf_sc.sc_regs));
	sf.sf_sc.sc_xip = tf->sxip & ~3;
	sf.sf_sc.sc_nip = tf->snip & ~3;
	sf.sf_sc.sc_fip = tf->sfip & ~3;
	sf.sf_sc.sc_ps = tf->epsr;
	sf.sf_sc.sc_sp  = tf->r[31];
	sf.sf_sc.sc_fpsr = tf->fpsr;
	sf.sf_sc.sc_fpcr = tf->fpcr;
	sf.sf_sc.sc_ssbr = tf->ssbr;
	sf.sf_sc.sc_dmt0 = tf->dmt0;
	sf.sf_sc.sc_dmd0 = tf->dmd0;
	sf.sf_sc.sc_dma0 = tf->dma0;
	sf.sf_sc.sc_dmt1 = tf->dmt1;
	sf.sf_sc.sc_dmd1 = tf->dmd1;
	sf.sf_sc.sc_dma1 = tf->dma1;
	sf.sf_sc.sc_dmt2 = tf->dmt2;
	sf.sf_sc.sc_dmd2 = tf->dmd2;
	sf.sf_sc.sc_dma2 = tf->dma2;
	sf.sf_sc.sc_fpecr = tf->fpecr;
	sf.sf_sc.sc_fphs1 = tf->fphs1;
	sf.sf_sc.sc_fpls1 = tf->fpls1;
	sf.sf_sc.sc_fphs2 = tf->fphs2;
	sf.sf_sc.sc_fpls2 = tf->fpls2;
	sf.sf_sc.sc_fppt = tf->fppt;
	sf.sf_sc.sc_fprh = tf->fprh;
	sf.sf_sc.sc_fprl = tf->fprl;
	sf.sf_sc.sc_fpit = tf->fpit;
	if (copyout((caddr_t)&sf, (caddr_t)fp, sizeof sf)) {
		/*
		 * Process has trashed its stack; give it an illegal
		 * instruction to halt it in its tracks.
		 */
		SIGACTION(p, SIGILL) = SIG_DFL;
		sig = sigmask(SIGILL);
		p->p_sigignore &= ~sig;
		p->p_sigcatch &= ~sig;
		p->p_sigmask &= ~sig;
		psignal(p, SIGILL);
		return;
	}
	/* 
	 * Build the argument list for the signal handler.
	 * Signal trampoline code is at base of user stack.
	 */
	addr = (int)PS_STRINGS - szsigcode;
	tf->snip = (addr & ~3) | NIP_V;
	tf->sfip = (tf->snip + 4) | FIP_V;
	tf->r[31] = (unsigned)fp;
d962 3
a964 3
	if ((sigdebug & SDB_FOLLOW) ||
	    (sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
		printf("sendsig(%d): sig %d returns\n", p->p_pid, sig);
a981 1
int
d987 7
a993 6
	struct sys_sigreturn_args /* {
	   syscallarg(struct sigcontext *) sigcntxp;
	} */ *uap = v;
	register struct sigcontext *scp;
	register struct trapframe *tf;
	struct sigcontext ksc;
d995 1
a995 1
	scp = (struct sigcontext *)SCARG(uap, sigcntxp);
d997 2
a998 2
	if (sigdebug & SDB_FOLLOW)
		printf("sigreturn: pid %d, scp %x\n", p->p_pid, scp);
d1000 10
a1009 16
#if defined(UVM)
	if ((int)scp & 3 || uvm_useracc((caddr_t)scp, sizeof *scp, B_WRITE) == 0 ||
	    copyin((caddr_t)scp, (caddr_t)&ksc, sizeof(struct sigcontext)))
		return (EINVAL);
#else
	if ((int)scp & 3 || useracc((caddr_t)scp, sizeof *scp, B_WRITE) == 0 ||
	    copyin((caddr_t)scp, (caddr_t)&ksc, sizeof(struct sigcontext)))
		return (EINVAL);
#endif

	tf = p->p_md.md_tf;
	scp = &ksc;
	/*
	 * xip, nip and fip must be multiples of 4.  This is all
	 * that is required; if it holds, just do it.
	 */
d1011 2
a1012 2
	if (((scp->sc_xip | scp->sc_nip | scp->sc_fip) & 3) != 0)
		return (EINVAL);
d1014 48
a1061 51
#if DIAGNOSTIC
	if (((scp->sc_xip | scp->sc_nip | scp->sc_fip) & 3) != 0){
		printf("xip %x nip %x fip %x\n",
		       scp->sc_xip, scp->sc_nip, scp->sc_fip);
		return (EINVAL);
	}
#endif 
	/*
	 * this can be improved by doing
	 *	 bcopy(sc_reg to tf, sizeof sigcontext - 2 words)
	 * XXX nivas
	 */

	bcopy((caddr_t)scp->sc_regs, (caddr_t)tf->r, sizeof(scp->sc_regs));
	tf->sxip = (scp->sc_xip) | XIP_V;
	tf->snip = (scp->sc_nip) | NIP_V;
	tf->sfip = (scp->sc_fip) | FIP_V;
	tf->epsr = scp->sc_ps;
	tf->r[31] = scp->sc_sp;
	tf->fpsr = scp->sc_fpsr;
	tf->fpcr = scp->sc_fpcr;
	tf->ssbr = scp->sc_ssbr;
	tf->dmt0 = scp->sc_dmt0;
	tf->dmd0 = scp->sc_dmd0;
	tf->dma0 = scp->sc_dma0;
	tf->dmt1 = scp->sc_dmt1;
	tf->dmd1 = scp->sc_dmd1;
	tf->dma1 = scp->sc_dma1;
	tf->dmt2 = scp->sc_dmt2;
	tf->dmd2 = scp->sc_dmd2;
	tf->dma2 = scp->sc_dma2;
	tf->fpecr = scp->sc_fpecr;
	tf->fphs1 = scp->sc_fphs1;
	tf->fpls1 = scp->sc_fpls1;
	tf->fphs2 = scp->sc_fphs2;
	tf->fpls2 = scp->sc_fpls2;
	tf->fppt = scp->sc_fppt;
	tf->fprh = scp->sc_fprh;
	tf->fprl = scp->sc_fprl;
	tf->fpit = scp->sc_fpit;

	tf->epsr = scp->sc_ps;
	/*
	 * Restore the user supplied information
	 */
	if (scp->sc_onstack & 01)
		p->p_sigacts->ps_sigstk.ss_flags |= SA_ONSTACK;
	else
		p->p_sigacts->ps_sigstk.ss_flags &= ~SA_ONSTACK;
	p->p_sigmask = scp->sc_mask & ~sigcantmask;
	return (EJUSTRETURN);
a1063 1
void
d1066 2
a1067 2
	cmmu_shutdown_now();
	bugreturn();
d1072 1
a1072 1
	register int howto;
d1074 33
a1106 34
	/* take a snap shot before clobbering any registers */
#if 0
	if (curproc && curproc->p_addr)
		savectx(curpcb);
#endif 
	boothowto = howto;
	if ((howto & RB_NOSYNC) == 0 && waittime < 0) {
		extern struct proc proc0;

		/* protect against curproc->p_stats.foo refs in sync()   XXX */
		if (curproc == NULL)
			curproc = &proc0;

		waittime = 0;
		vfs_shutdown();

		/*
		 * If we've been adjusting the clock, the todr
		 * will be out of synch; adjust it now.
		 */
		resettodr();
	}
	splhigh();	  /* extreme priority */
	if (howto & RB_HALT) {
		printf("halted\n\n");
		bugreturn();
	} else {
		if (howto & RB_DUMP)
			dumpsys();
		doboot();
		/*NOTREACHED*/
	}
	/*NOTREACHED*/
	while (1);  /* to keep compiler happy, and me from going crazy */
d1113 11
a1123 11
	volatile int cnt;

	*sys_syscon->ien0 = 0;
	*sys_syscon->ien1 = 0;
	*sys_syscon->ien2 = 0;
	*sys_syscon->ien3 = 0;
	*sys_syscon->glbres = 1;  /* system reset */
	*sys_syscon->ucsr |= 0x2000; /* clear SYSFAIL* */
	for (cnt = 0; cnt < 5*1024*1024; cnt++)
		;
	*sys_syscon->ucsr |= 0x2000; /* clear SYSFAIL* */
d1127 2
a1128 2
unsigned dumpmag = 0x8fca0101;	 /* magic number for savecore */
int   dumpsize = 0;	/* also for savecore */
a1130 1
void
d1133 1
a1133 1
	int nblks;
d1135 14
a1148 14
	dumpsize = physmem;
	if (dumpdev != NODEV && bdevsw[major(dumpdev)].d_psize) {
		nblks = (*bdevsw[major(dumpdev)].d_psize)(dumpdev);
		if (dumpsize > btoc(dbtob(nblks - dumplo)))
			dumpsize = btoc(dbtob(nblks - dumplo));
		else if (dumplo == 0)
			dumplo = nblks - btodb(ctob(physmem));
	}
	/*
	 * Don't dump on the first CLBYTES (why CLBYTES?)
	 * in case the dump device includes a disk label.
	 */
	if (dumplo < btodb(CLBYTES))
		dumplo = btodb(CLBYTES);
a1155 1
void
d1158 1
a1158 1
	extern int msgbufmapped;
d1160 35
a1194 31
	msgbufmapped = 0;
	if (dumpdev == NODEV)
		return;
	/*
	 * For dumps during autoconfiguration,
	 * if dump device has already configured...
	 */
	if (dumpsize == 0)
		dumpconf();
	if (dumplo < 0)
		return;
	printf("\ndumping to dev %x, offset %d\n", dumpdev, dumplo);
	printf("dump ");
	switch ((*bdevsw[major(dumpdev)].d_dump)(dumpdev)) {
	
	case ENXIO:
		printf("device bad\n");
		break;
	case EFAULT:
		printf("device not ready\n");
		break;
	case EINVAL:
		printf("area improper\n");
		break;
	case EIO:
		printf("i/o error\n");
		break;
	default:
		printf("succeeded\n");
		break;
	}
d1203 1
a1203 1
	register u_char *vaddr;
d1206 1
a1206 1
	extern vm_offset_t iomap_mapin(vm_offset_t, vm_size_t,  boolean_t);
d1208 7
a1214 7
	/*
	 * map a page in for phys address 0xfffe0000 (M187) and set the
	 * addresses for various levels.
	 */
	switch (cputyp) {
#ifdef MVME187
	case CPU_187:
d1216 1
a1216 1
		vaddr = (u_char *)iomap_mapin(M187_IACK, NBPG, 1);
d1218 1
a1218 1
		vaddr = (u_char *)M187_IACK;
d1220 2
a1221 4
		break;
#endif /* MVME187 */
#ifdef MVME188
	case CPU_188:
d1223 1
a1223 1
		vaddr = (u_char *)iomap_mapin(M188_IACK, NBPG, 1);
d1225 1
a1225 1
		vaddr = (u_char *)M188_IACK;
d1227 2
a1228 14
		ivec[0] = vaddr;	/* We dont use level 0 */
		ivec[1] = vaddr + 0x04;
		ivec[2] = vaddr + 0x08;
		ivec[3] = vaddr + 0x0c;
		ivec[4] = vaddr + 0x10;
		ivec[5] = vaddr + 0x14;
		ivec[6] = vaddr + 0x18;
		ivec[7] = vaddr + 0x1c;
		ivec[8] = vaddr + 0x20;	/* for self inflicted interrupts */
		*ivec[8] = M188_IVEC;	/* supply a vector for m188ih */
		break;
#endif /* MVME188 */
#ifdef MVME197
	case CPU_197:
d1230 1
a1230 1
		vaddr = (u_char *)iomap_mapin(M197_IACK, NBPG, 1);
d1232 1
a1232 1
		vaddr = (u_char *)M197_IACK;
d1234 2
a1235 5
		break;
#endif /* MVME197 */
	default:
		panic("setupiackvectors: unknow cpu");
	}
d1237 1
a1237 1
	printf("interrupt ACK address mapped at 0x%x\n", vaddr);
d1239 8
a1246 13

#if defined(MVME187) || defined(MVME197)
	if (cputyp != CPU_188) {
		ivec[0] = vaddr + 0x03;	/* We dont use level 0 */
		ivec[1] = vaddr + 0x07;
		ivec[2] = vaddr + 0x0b;
		ivec[3] = vaddr + 0x0f;
		ivec[4] = vaddr + 0x13;
		ivec[5] = vaddr + 0x17;
		ivec[6] = vaddr + 0x1b;
		ivec[7] = vaddr + 0x1f;
	}
#endif
d1253 1
a1253 6
	vm_offset_t addr = 0;
#if defined(UVM)
	addr = (vm_offset_t)uvm_km_zalloc(kernel_map, INTSTACK_SIZE + 4096);
#else
	addr = (vm_offset_t)kmem_alloc(kernel_map, INTSTACK_SIZE + 4096);
#endif
d1255 1
a1255 2
	if (addr == NULL)
		panic("Cannot allocate slave stack");
d1257 2
a1258 5
	if (interrupt_stack[0] == 0)
		interrupt_stack[0] = (vm_offset_t) intstack;
	interrupt_stack[cpu_number()] = addr;
	return addr;
}
d1260 4
a1263 13
/*
 * Slave CPU pre-main routine.
 * Determine CPU number and set it.
 *
 * Running on an interrupt stack here; do nothing fancy.
 *
 * Called from "mvme88k/locore.S"
 */
void slave_pre_main(void)
{
   set_cpu_number(cmmu_cpu_number()); /* Determine cpu number by CMMU */
   splhigh();
   enable_interrupt();
d1270 3
a1272 3
	printf("slave CPU%d started\n", cpu_number());
	while (-1); /* spin forever */
	return 0;
d1276 6
a1281 2
 * Search for the first avilable interrupt vector in the range start, end.
 * This should really only be used by VME devices.
d1285 1
a1285 1
	int start, end;
d1287 2
a1288 1
	int vec;
d1290 6
a1295 9
	/* Sanity check! */
	if (start < 0 || end > 255 || start > end)
		panic("intr_findvec(): bad parameters");
	for (vec = start; vec < end; --vec){
		if (intr_handlers[vec] == NULL)
			return (vec);
	}
	printf("intr_findvec(): uh oh....\n", vec);
	return (-1);
d1306 1
a1306 1
	register struct intrhand *intr;
d1308 30
a1337 30
	if (vec < 0 || vec > 255) {
#if DIAGNOSTIC
		panic("intr_establish: vec (0x%x) not between 0x00 and 0xff",
		      vec);
#endif /* DIAGNOSTIC */
		return (INTR_EST_BADVEC);
	}

	if ((intr = intr_handlers[vec]) != NULL) {
		if (intr->ih_ipl != ihand->ih_ipl) {
#if DIAGNOSTIC
			panic("intr_establish: there are other handlers with vec (0x%x) at ipl %x, but you want it at %x",
			      intr->ih_ipl, vec, ihand->ih_ipl);
#endif /* DIAGNOSTIC */
			return (INTR_EST_BADIPL);
		}

		/*
		 * Go to the end of the chain
		 */
		while (intr->ih_next)
			intr = intr->ih_next;
	}

	ihand->ih_next = 0;

	if (intr)
		intr->ih_next = ihand;
	else
		intr_handlers[vec] = ihand;
d1339 1
a1339 1
	return (INTR_EST_SUCC);
d1354 4
a1357 6

unsigned obio_vec[32] = {
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
        0,SYSCV_SCC,0,0,SYSCV_SYSF,SYSCV_TIMER2,0,0,
	0,0,0,0,SYSCV_TIMER1,0,SYSCV_ACF,SYSCV_ABRT, 
a1358 1

a1359 2
#define VME_VECTOR_MASK		0x1ff 		/* mask into VIACK register */
#define VME_BERR_MASK		0x100 		/* timeout during VME IACK cycle */
d1364 109
a1472 137
	register int cpu = cpu_number();
	register unsigned int cur_mask;
	register unsigned int level, old_spl;
	register struct intrhand *intr;
	int ret, intbit;
	unsigned vec;

	cur_mask = ISR_GET_CURRENT_MASK(cpu);
	old_spl = m188_curspl[cpu];
	eframe->mask = old_spl;

	if (cur_mask == 0) {
		/*
		 * Spurious interrupts - may be caused by debug output clearing
		 * DUART interrupts.
		 */
		flush_pipeline();
		return;
	}

	/* 
	 * We want to service all interrupts marked in the IST register
	 * They are all valid because the mask would have prevented them
	 * from being generated otherwise.  We will service them in order of
	 * priority. 
	 */
	do {
		level = safe_level(cur_mask, old_spl);

		if (old_spl >= level) {
			register int i;

			printf("safe level %d <= old level %d\n", level, old_spl);
			printf("cur_mask = 0x%b\n", cur_mask, IST_STRING);
			for (i = 0; i < 4; i++)
				printf("IEN%d = 0x%b  ", i, *int_mask_reg[i], IST_STRING);
			printf("\nCPU0 spl %d  CPU1 spl %d  CPU2 spl %d  CPU3 spl %d\n",
			       m188_curspl[0], m188_curspl[1],
			       m188_curspl[2], m188_curspl[3]);
			for (i = 0; i < 8; i++)
				printf("int_mask[%d] = 0x%08x\n", i, int_mask_val[i]);
			printf("--CPU %d halted--", cpu_number());
			spl7();
			while (1)
				;
		}

		if (level > 7 || (char)level < 0) {
			panic("int level (%x) is not between 0 and 7", level);
		}

		setipl(level);
	  
		enable_interrupt();
		
		/* generate IACK and get the vector */

		/* 
		 * This is tricky.  If you don't catch all the 
		 * interrupts, you die. Game over. Insert coin... 
		 * XXX smurph
		 */

		/* find the first bit set in the current mask */
		intbit = ff1(cur_mask);
		if (OBIO_INTERRUPT_MASK & (1 << intbit)) {
			if (guarded_access(ivec[level], 4, &vec) == EFAULT) {
				printf("Unable to get vector for this vmebus interrupt (level %x)\n", level);
				goto out_m188;
			}
			vec = obio_vec[intbit];
			if (vec == 0) {
				printf("unknown onboard interrupt: mask = 0x%b\n", 1 << intbit, IST_STRING);
				panic("m188_ext_int");
			}
			
			
			#define M88K_OBIO1_IRQ	8

		} else if (HW_FAILURE_MASK & (1 << intbit)) {
			vec = obio_vec[intbit];
			if (vec == 0) {
				printf("unknown hadware failure: mask = 0x%b\n", 1 << intbit, IST_STRING);
				panic("m188_ext_int");
			}
		} else if (VME_INTERRUPT_MASK & (1 << intbit)) {
			if (guarded_access(ivec[level], 4, &vec) == EFAULT) {
				printf("Unable to get vector for this vmebus interrupt (level %x)\n", level);
				goto out_m188;
			}
			vec &= VME_VECTOR_MASK;
			if (vec & VME_BERR_MASK) {
				printf("m188_ext_int: vme vec timeout\n");
				goto out_m188;
			}
			if (vec == 0) {
				printf("unknown vme interrupt: mask = 0x%b\n", 1 << intbit, IST_STRING);
				panic("m188_ext_int");
			}
		} else {
			printf("unknown interrupt: level = %d intbit = 0x%x mask = 0x%b\n",
			       level, intbit, 1 << intbit, IST_STRING);
			panic("m188_ext_int");
		}
		if (vec > 0xFF) {
			panic("m188_ext_int: interrupt vector 0x%x greater than 255!\nlevel = %d iack = 0x%x\n", 
			      vec, level, ivec[level]);
		}

		if ((intr = intr_handlers[vec]) == 0){
			/* increment intr counter */
			intrcnt[M88K_SPUR_IRQ]++; 
			printf("Spurious interrupt: level = %d vec = 0x%x, intbit = %d mask = 0x%b\n",
			       level, vec, intbit, 1 << intbit, IST_STRING);

		}
		/*
		 * Walk through all interrupt handlers in the chain for the
		 * given vector, calling each handler in turn, till some handler
		 * returns a value != 0.
		 */
		for (ret = 0; intr; intr = intr->ih_next) {
			if (intr->ih_wantframe != 0)
				ret = (*intr->ih_fn)((void *)eframe);
			else
				ret = (*intr->ih_fn)(intr->ih_arg);
			if (ret){
				/* increment intr counter */
				intrcnt[level]++; 
				break;
			}
		}
		if (ret == 0) {
			printf("Unclaimed interrupt: level = %d vec = 0x%x, intbit = %d mask = 0x%b\n",
			       level, vec, intbit, 1 << intbit, IST_STRING);
			break;
		}
d1474 1
a1474 1
		disable_interrupt();
a1475 1
	} while ((cur_mask = ISR_GET_CURRENT_MASK(cpu)) != 0);
d1477 26
a1502 4
	/*
	 * process any remaining data access exceptions before
	 * returning to assembler
	 */
d1504 13
a1516 14
	disable_interrupt();
	if (eframe->dmt0 & DMT_VALID) {
		trap(T_DATAFLT, eframe);
		data_access_emulation((unsigned *)eframe);
		eframe->dmt0 &= ~DMT_VALID;
	}

	/*
	 * Restore the mask level to what it was when the interrupt
	 * was taken.
	 */
	setipl((u_char)eframe->mask);
	flush_pipeline();
	return;
d1534 91
a1624 95
	register u_char mask, level;
	register struct intrhand *intr;
	int ret;
	u_char vec;

	/* get level and mask */
	asm volatile("ld.b	%0,%1" : "=r" (mask) : "" (*pcc2intr_mask));
	asm volatile("ld.b	%0,%1" : "=r" (level) : "" (*pcc2intr_ipl));

	/*
	 * It is really bizarre for the mask and level to the be the same.
	 * pcc2 for 187 blocks all interrupts at and below the mask value,
	 * so we should not be getting an interrupt at the level that is
	 * already blocked. I can't explain this case XXX nivas
	 */

	if ((mask == level) && level) {
		printf("mask == level, %d\n", level);
		goto beatit;
	}

	/*
	 * Interrupting level cannot be 0--0 doesn't produce an interrupt.
	 * Weird! XXX nivas
	 */

	if (level == 0) {
		printf("Bogons... level %x and mask %x\n", level, mask);
		goto beatit;
	}

	/* and block interrupts at level or lower */
	setipl((u_char)level);
	/* and stash it away in the trap frame */
	eframe->mask = mask;

	if (level > 7 || (char)level < 0) {
		panic("int level (%x) is not between 0 and 7", level);
	}

	/* generate IACK and get the vector */
	asm volatile("tb1	0, r0, 0"); 
	if (guarded_access(ivec[level], 1, &vec) == EFAULT) {
		printf("Unable to get vector for this interrupt (level %x)\n", level);
		goto out;
	}
	asm volatile("tb1	0, r0, 0"); 
	asm volatile("tb1	0, r0, 0"); 
	asm volatile("tb1	0, r0, 0"); 

	if (vec > 0xFF) {
		panic("interrupt vector %x greater than 255", vec);
	}

	enable_interrupt();

	if ((intr = intr_handlers[vec]) == 0) {
		/* increment intr counter */
		intrcnt[M88K_SPUR_IRQ]++; 
		printf("Spurious interrupt (level %x and vec %x)\n",
		       level, vec);
	}
	if (intr && intr->ih_ipl != level) {
		panic("Handler ipl %x not the same as level %x. vec = 0x%x",
		      intr->ih_ipl, level, vec);
	}

	/*
	 * Walk through all interrupt handlers in the chain for the
	 * given vector, calling each handler in turn, till some handler
	 * returns a value != 0.
	 */

	for (ret = 0; intr; intr = intr->ih_next) {
		if (intr->ih_wantframe != 0)
			ret = (*intr->ih_fn)((void *)eframe);
		else
			ret = (*intr->ih_fn)(intr->ih_arg);
		if (ret){
			/* increment intr counter */
			intrcnt[level]++; 
			break;
		}
	}

	if (ret == 0) {
		printf("Unclaimed interrupt (level %x and vec %x)\n",
		       level, vec);
	}

	/*
	 * process any remaining data access exceptions before
	 * returning to assembler
	 */
	disable_interrupt();
d1627 14
a1640 14
	if (cputyp != CPU_197) {
		if (eframe->dmt0 & DMT_VALID) {
			trap(T_DATAFLT, eframe);
			data_access_emulation((unsigned *)eframe);
			eframe->dmt0 &= ~DMT_VALID;
		}
	}
	mask = eframe->mask;

	/*
	 * Restore the mask level to what it was when the interrupt
	 * was taken.
	 */
	setipl((u_char)mask);
d1643 1
a1643 1
	return;
a1646 1
int
d1651 1
a1651 1
	return ENOEXEC;
a1653 1
int
d1659 12
a1670 12
	struct sys_sysarch_args	/* {
	   syscallarg(int) op;
	   syscallarg(char *) parm;
	} */ *uap = v;
	int error = 0;

	switch ((int)SCARG(uap, op)) {
	default:
		error = EINVAL;
		break;
	}
	return (error);
a1676 1
int
d1687 9
a1695 9
	/* all sysctl names are this level are terminal */
	if (namelen != 1)
		return (ENOTDIR); /* overloaded */

	switch (name[0]) {
	default:
		return (EOPNOTSUPP);
	}
	/*NOTREACHED*/
d1704 1
a1704 1
	void *velement, *vhead;
d1706 7
a1712 7
	register struct prochd *element, *head;
	element = velement;
	head = vhead;
	element->ph_link = head->ph_link;
	head->ph_link = (struct proc *)element;
	element->ph_rlink = (struct proc *)head;
	((struct prochd *)(element->ph_link))->ph_rlink=(struct proc *)element;
d1721 1
a1721 1
	void *velement;
d1723 5
a1727 5
	register struct prochd *element;
	element = velement;
	((struct prochd *)(element->ph_link))->ph_rlink = element->ph_rlink;
	((struct prochd *)(element->ph_rlink))->ph_link = element->ph_link;
	element->ph_rlink = (struct proc *)0;
d1732 17
a1748 17
	const void *fromaddr;
	void *toaddr;
	size_t maxlength;
	size_t *lencopied;
{
	u_int tally;

	tally = 0;

	while (maxlength--) {
		*(u_char *)toaddr = *(u_char *)fromaddr++;
		tally++;
		if (*(u_char *)toaddr++ == 0) {
			if (lencopied) *lencopied = tally;
			return (0);
		}
	}
d1750 2
a1751 2
	if (lencopied)
		*lencopied = tally;
d1753 1
a1753 1
	return (ENAMETOOLONG);
d1758 1
a1758 1
	register struct proc *p;
d1760 12
a1771 12
	register struct prochd *q;
	register struct proc *oldlast;
	register int which = p->p_priority >> 2;

	if (p->p_back != NULL)
		panic("setrunqueue %x", p);
	q = &qs[which];
	whichqs |= 1 << which;
	p->p_forw = (struct proc *)q;
	p->p_back = oldlast = q->ph_rlink;
	q->ph_rlink = p;
	oldlast->p_forw = p;
d1780 1
a1780 1
	struct proc *vp;
d1782 12
a1793 12
	register struct proc *p = vp;
	register int which = p->p_priority >> 2;
	register struct prochd *q;

	if ((whichqs & (1 << which)) == 0)
		panic("remrq %x", p);
	p->p_forw->p_back = p->p_back;
	p->p_back->p_forw = p->p_forw;
	p->p_back = NULL;
	q = &qs[which];
	if (q->ph_link == (struct proc *)q)
		whichqs &= ~(1 << which);
a1797 1
void
d1804 1
a1804 1
	u_char *cp;
d1806 62
a1867 4
	struct bugbrdid brdid;

	bugbrdid(&brdid);
	bcopy(&brdid.etheraddr, cp, 6);
d1873 13
a1885 27
	if (ssir & SIR_NET) {
		siroff(SIR_NET);
#if defined(UVM)
		uvmexp.softs++;
#else
		cnt.v_soft++;
#endif
#define DONETISR(bit, fn) \
	do { \
		if (netisr & (1 << bit)) { \
			netisr &= ~(1 << bit); \
			fn(); \
		} \
	} while (0)
#include <net/netisr_dispatch.h>
#undef DONETISR
	}

	if (ssir & SIR_CLOCK) {
		siroff(SIR_CLOCK);
#if defined(UVM)
		uvmexp.softs++;
#else
		cnt.v_soft++;
#endif
		softclock();
	}
d1889 1
a1889 1
spl0(void)
d1891 3
a1893 2
	int x;
	x = splsoftclock();
d1895 3
a1897 3
	if (ssir) {
		dosoftint();
	}
d1899 1
a1899 1
	setipl(0);
d1901 6
a1906 1
	return (x);
a1908 1
void
d1915 2
a1916 2
	regdump(f);
	printf("proc %x flags %x type %s\n", p, flags, s);
a1918 1
void
d1920 2
a1921 2
	struct trapframe  *f;
	int         flags;
d1923 1
a1923 1
	regdump(f);
d1929 1
a1929 3
#if 0
	struct m88100_saved_state *frame = framep;
#endif
d1932 2
a1933 2
	DEBUG_MSG("Abort Pressed\n");
	Debugger();
d1935 1
a1935 1
	DEBUG_MSG("Spurious NMI?\n");
a1938 1
void
d1942 80
a2021 70
	printf("R00-05: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	       R(0),R(1),R(2),R(3),R(4),R(5));
	printf("R06-11: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	       R(6),R(7),R(8),R(9),R(10),R(11));
	printf("R12-17: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	       R(12),R(13),R(14),R(15),R(16),R(17));
	printf("R18-23: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	       R(18),R(19),R(20),R(21),R(22),R(23));
	printf("R24-29: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	       R(24),R(25),R(26),R(27),R(28),R(29));
	printf("R30-31: 0x%08x  0x%08x\n",R(30),R(31));
	if (cputyp == CPU_197) {
		printf("exip %x enip %x\n", f->sxip, f->snip);
	} else {
		printf("sxip %x snip %x sfip %x\n", f->sxip, f->snip, f->sfip);
	}
#if defined(MVME187) || defined(MVME188)
	if (f->vector == 0x3 && cputyp != CPU_197) {
		/* print dmt stuff for data access fault */
		printf("dmt0 %x dmd0 %x dma0 %x\n", f->dmt0, f->dmd0, f->dma0);
		printf("dmt1 %x dmd1 %x dma1 %x\n", f->dmt1, f->dmd1, f->dma1);
		printf("dmt2 %x dmd2 %x dma2 %x\n", f->dmt2, f->dmd2, f->dma2);
		printf("fault type %d\n", (f->dpfsr >> 16) & 0x7);
		dae_print((unsigned *)f);
	}
	if (longformat && cputyp != CPU_197) {
		printf("fpsr %x ", f->fpsr);
		printf("fpcr %x ", f->fpcr);
		printf("epsr %x ", f->epsr);
		printf("ssbr %x\n", f->ssbr);
		printf("fpecr %x ", f->fpecr);
		printf("fphs1 %x ", f->fphs1);
		printf("fpls1 %x ", f->fpls1);
		printf("fphs2 %x ", f->fphs2);
		printf("fpls2 %x\n", f->fpls2);
		printf("fppt %x ", f->fppt);
		printf("fprh %x ", f->fprh);
		printf("fprl %x ", f->fprl);
		printf("fpit %x\n", f->fpit);
		printf("vector %d ", f->vector);
		printf("mask %x ", f->mask);
		printf("mode %x ", f->mode);
		printf("scratch1 %x ", f->scratch1);
		printf("cpu %x\n", f->cpu);
	}
#endif 
#ifdef MVME197
	if (longformat && cputyp == CPU_197) {
		printf("fpsr %x ", f->fpsr);
		printf("fpcr %x ", f->fpcr);
		printf("fpecr %x ", f->fpecr);
		printf("epsr %x\n", f->epsr);
		printf("dsap %x ", f->dmt1);
		printf("dsr %x ", f->dsr);
		printf("dlar %x ", f->dlar);
		printf("dpar %x\n", f->dpar);
		printf("isap %x ", f->dmt0);
		printf("isr %x ", f->isr);
		printf("ilar %x ", f->ilar);
		printf("ipar %x\n", f->ipar);
		printf("vector %d ", f->vector);
		printf("mask %x ", f->mask);
		printf("mode %x ", f->mode);
		printf("scratch1 %x ", f->scratch1);
		printf("cpu %x\n", f->cpu);
	}
#endif
#ifdef MVME188
	if (cputyp == CPU_188 ) {
		unsigned int istr, cur_mask;
d2023 4
a2026 7
		istr = *(volatile int *)IST_REG;
		cur_mask = GET_MASK(0, istr);
		printf("emask = 0x%b\n", f->mask, IST_STRING);
		printf("istr  = 0x%b\n", istr, IST_STRING);
		printf("cmask = 0x%b\n", cur_mask, IST_STRING);
	}
#endif 
d2028 2
d2036 1
d2040 28
a2067 24
	extern int cold;
	extern int kernelstart;
	extern vm_offset_t size_memory(void);
	extern struct consdev *cn_tab;
	struct bugbrdid brdid;

	cold = 1;  /* we are still booting */

	/* zreo out the machine dependant function pointers */
	bzero(&mdfp, sizeof(struct funcp));

	buginit(); /* init the bug routines */
	bugbrdid(&brdid);
	cputyp = brdid.brdno;

	/* to support the M8120.  It's based off of MVME187 */
	if (cputyp == 0x8120)
		cputyp = CPU_187;

	/* 
	 * set up interrupt and fp exception handlers 
	 * based on the machine.
	 */
	switch (cputyp) {
d2069 9
a2077 9
	case CPU_188:
		mdfp.interrupt_func = &m188_ext_int;
		mdfp.fp_precise_func = &m88100_Xfp_precise;
		/* clear and disable all interrupts */
		*int_mask_reg[0] = 0;
		*int_mask_reg[1] = 0;
		*int_mask_reg[2] = 0;
		*int_mask_reg[3] = 0;
		break;
d2080 4
a2083 4
	case CPU_187:
		mdfp.interrupt_func = &sbc_ext_int;
		mdfp.fp_precise_func = &m88100_Xfp_precise;
		break;
d2086 5
a2090 5
	case CPU_197:
		mdfp.interrupt_func = &sbc_ext_int;
		mdfp.fp_precise_func = &m88110_Xfp_precise;
		set_tcfp(); /* Set Time Critical Floating Point Mode */
		break;
d2092 24
a2115 27
	default:
		panic("mvme_bootstrap: Can't determine cpu type.");
	}

	/* startup fake console driver.  It will be replaced by consinit() */
	cn_tab = &bootcons;

#if defined(UVM)
	uvmexp.pagesize = NBPG;
	uvm_setpagesize();
#else 
	vm_set_page_size();
#endif 
	first_addr = m88k_round_page(first_addr);

	if (!no_symbols) boothowto |= RB_KDB;

	last_addr = size_memory();
	cmmu_parity_enable();

	identifycpu();
	setup_board_config();
	cmmu_init();
	master_cpu = cmmu_cpu_number();
	set_cpu_number(master_cpu);
	printf("CPU%d is master CPU\n", master_cpu);

d2117 7
a2123 7
	if (cputyp == CPU_188 && (boothowto & RB_MINIROOT)) {
		int i;
		for (i=0; i<MAX_CPUS; i++) {
			if (!spin_cpu(i))
				printf("CPU%d started\n", i);
		}
	}
d2125 2
a2126 6
	avail_start = first_addr;
	avail_end = last_addr;
	/*
	 * Steal MSGBUFSIZE at the top of physical memory for msgbuf
	 */
	avail_end -= m88k_round_page(MSGBUFSIZE);
d2128 1
a2128 1
	printf("MVME%x boot: memory from 0x%x to 0x%x\n", cputyp, avail_start, avail_end);
d2130 23
a2152 33
	pmap_bootstrap((vm_offset_t)M88K_TRUNC_PAGE((unsigned)&kernelstart) /* = loadpt */, 
		       &avail_start, &avail_end, &virtual_avail,
		       &virtual_end);

#if defined(MACHINE_NEW_NONCONTIG)
	/*
	 * Tell the VM system about available physical memory.  
	 * mvme88k only has one segment.
	 */
#if defined(UVM)
	uvm_page_physload(atop(avail_start), atop(avail_end),
			  atop(avail_start), atop(avail_end),VM_FREELIST_DEFAULT);
#else
	vm_page_physload(atop(avail_start), atop(avail_end),
			 atop(avail_start), atop(avail_end));
#endif /* UVM */
#endif /* MACHINE_NEW_NONCONTIG */
	
	/*
	 * Must initialize p_addr before autoconfig or
	 * the fault handler will get a NULL reference.
	 */
	proc0.p_addr = proc0paddr;
	curproc = &proc0;
	curpcb = &proc0paddr->u_pcb;

	/* Initialize cached PTEs for u-area mapping. */
	save_u_area(&proc0, (vm_offset_t)proc0paddr);

	/*
	 * Map proc0's u-area at the standard address (UADDR).
	 */
	load_u_area(&proc0);
d2154 2
a2155 2
	/* Initialize the "u-area" pages. */
	bzero((caddr_t)UADDR, UPAGES*NBPG);
d2157 1
a2157 1
	printf("leaving mvme_bootstrap()\n");
d2167 1
a2167 1
	struct consdev *cp;
d2169 3
a2171 3
	cp->cn_dev = makedev(14, 0);
	cp->cn_pri = CN_NORMAL;
	return (1);
d2176 1
a2176 1
	struct consdev *cp;
d2178 1
a2178 2
	/* Nothing to do */
	return (1);
d2183 1
a2183 1
	dev_t dev;
d2185 1
a2185 1
	return (buginchr());
d2190 2
a2191 2
	dev_t dev;
	char c;
d2193 5
a2197 3
	if (c == '\n')
		bugoutchr('\r');
	bugoutchr(c);
@


1.18.2.4
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.18.2.3 2001/04/18 16:11:37 niklas Exp $	*/
a76 1
#include <sys/extent.h>
d98 1
d100 1
d105 1
a105 1
#include "assym.h"			/* EF_EPSR, etc. */
d131 1
d173 1
a173 4

int ssir;
int want_ast;
int want_resched;
d176 1
d187 1
d191 3
d202 1
d204 3
d208 1
a208 1
struct extent *iomap_extent;
d210 1
d483 1
d485 3
d512 5
a516 1
	if ((v = (caddr_t)uvm_km_zalloc(kernel_map, round_page(sz))) == 0)
d525 1
d531 4
d557 1
d563 4
d576 1
d582 4
d596 1
d602 4
d618 1
d624 4
d643 2
a644 1
	if (uvm_map(kernel_map, (vaddr_t *) &buffers, round_page(size),
d650 8
d667 1
d679 1
a679 1
		curbufsize = PAGE_SIZE * ((i < residual) ? (base+1) : base);
d692 17
d715 1
d718 4
d730 1
d733 4
d742 1
a742 1
	 * Allocate map for external I/O
d744 1
d747 4
d754 1
a754 4
	iomap_extent = extent_create("iomap", iomapbase,
	    iomapbase + IOMAP_SIZE, M_DEVBUF, NULL, 0, EX_NOWAIT);
	if (iomap_extent == 0)
		panic("unable to allocate extent for iomap");
d756 8
d766 4
d776 1
d778 4
d783 1
a783 1
	    bufpages * PAGE_SIZE);
d823 1
d877 1
a877 1
			bufpages = physmem / 10;
d880 1
a880 1
			    BUFCACHEPERCENT / 100;
d895 2
a896 2
	if (bufpages > nbuf * MAXBSIZE / PAGE_SIZE)
		bufpages = nbuf * MAXBSIZE / PAGE_SIZE;
d903 3
d908 7
d1050 1
d1053 4
d1170 1
d1174 5
d1276 1
a1276 4

	/* Disable interrupts. */
	splhigh();

d1279 1
a1280 1
		/* If rebooting and a dump is requested, do it. */
d1283 2
a1284 3

		/* Run any shutdown hooks. */
		doshutdownhooks();
a1285 1
	doboot();
d1287 1
a1287 1
	for (;;);  /* to keep compiler happy, and me from going crazy */
d1326 1
a1326 1
	 * Don't dump on the first block
d1329 2
a1330 2
	if (dumplo < btodb(PAGE_SIZE))
		dumplo = btodb(PAGE_SIZE);
d1455 1
d1457 3
a1503 1
#ifdef DIAGNOSTIC
d1507 1
a1507 3
#endif

	for (vec = start; vec < end; vec++){
a1510 1
#ifdef DIAGNOSTIC
a1511 1
#endif
d2055 1
d2057 3
d2073 1
d2075 3
d2223 1
d2278 1
d2281 4
a2284 1
	first_addr = round_page(first_addr);
d2312 1
a2312 1
	avail_end -= round_page(MSGBUFSIZE);
d2316 1
a2316 1
	pmap_bootstrap((vm_offset_t)trunc_page((unsigned)&kernelstart) /* = loadpt */, 
d2320 1
d2325 1
d2328 5
@


1.18.2.5
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.18.2.4 2001/07/04 10:20:18 niklas Exp $	*/
a77 2
#include <sys/core.h>
#include <sys/kcore.h>
d81 3
d85 2
d88 1
a88 5
#include <machine/cmmu.h>
#include <machine/cpu.h>
#include <machine/cpu_number.h>
#include <machine/kcore.h>
#include <machine/locore.h>
a90 3
#include <machine/prom.h>
#include <machine/reg.h>
#include <machine/trap.h>
d95 4
a107 2
#include <ddb/db_extern.h>
#include <ddb/db_interface.h>
d112 1
a112 1
#define DEBUG_MSG db_printf
d114 1
a114 1
#define DEBUG_MSG printf
d124 1
a124 1
/* prototypes */
d131 1
a131 7
vm_offset_t size_memory __P((void));
int getcpuspeed __P((void));
int getscsiid __P((void));
void identifycpu __P((void));
void save_u_area __P((struct proc *, vm_offset_t));
void load_u_area __P((struct proc *));
void dumpconf __P((void));
d163 1
a163 1
#if defined(MVME187) || defined(MVME197)
d167 2
a170 4
#endif /* defined(MVME187) || defined(MVME197) */
#ifdef MVME188
volatile vm_offset_t utilva;
#endif
d177 2
d180 1
d185 1
a185 1
int   safepri = PSR_SUPERVISOR;
d206 1
d217 1
d224 1
a224 1
char  machine[] = MACHINE;	 /* cpu "architecture" */
a228 1

d249 6
d258 1
a258 1
vm_offset_t avail_start, avail_end;
d260 2
d263 5
d275 3
a277 3
void bootcnprobe __P((struct consdev *));
void bootcninit __P((struct consdev *));
void bootcnputc __P((dev_t, int));
a279 1

a280 1

d282 2
a283 2
	NULL, 
	NULL, 
d285 3
a287 6
	bootcnputc,
	bootcnpollc,
	NULL,
	makedev(14,0),
	1};

a296 1

d300 1
d305 1
a305 2
	db_machine_init();
	ddb_init();
d317 1
a317 1
size_memory()
d334 2
a335 1
		if (badwordaddr((vaddr_t)look)) {
d364 1
a364 1
getcpuspeed()
d381 1
a381 1
getscsiid()
d438 1
a438 1
cpu_initclocks()
d478 1
a478 1
	 * avail_end was pre-decremented in mvme_bootstrap() to compensate.
d480 1
d482 3
a484 2
		pmap_kenter_pa((vm_offset_t)msgbufp, 
			   avail_end + i * NBPG, VM_PROT_READ|VM_PROT_WRITE);
d490 1
a490 2
	printf(version);
	identifycpu();
d592 2
d634 3
a636 1
			pmap_kenter_pgs(curbuf, &pg, 1);
d649 3
d655 1
d658 3
d663 1
a663 1
	 * Allocate map for external I/O.
d667 3
a669 1

d672 1
a672 1
	if (iomap_extent == NULL)
d675 1
a675 1
	mb_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
d678 5
d687 15
d708 5
a717 3
	/*
	 * Configure the system.
	 */
d744 7
d799 5
d825 3
d856 2
a857 2
	tf->epsr = PSR_USER;  /* user mode, interrupts enabled, fp enabled */
/*	tf->epsr = PSR_USER | PSR_MXM;*/  /* user mode, interrupts enabled, fp enabled, MXM Mask */
d1111 1
d1123 1
a1123 1
__dead void
a1127 2
	/*NOTREACHED*/
	for (;;);		/* appease gcc */
d1130 1
a1130 1
__dead void
a1133 6
	/* If system is cold, just halt. */
	if (cold) {
		howto |= RB_HALT;
		goto haltsys;
	}

d1135 1
d1138 1
a1138 1

a1159 8
	/* If rebooting and a dump is requested, do it. */
	if (howto & RB_DUMP)
		dumpsys();

haltsys:
	/* Run any shutdown hooks. */
	doshutdownhooks();

d1163 6
a1168 1
		doboot();
d1170 2
a1172 1
	/*NOTREACHED*/
d1177 1
a1177 1
m188_reset()
a1195 1
cpu_kcore_hdr_t cpu_kcore_hdr;
a1196 7
/*
 * This is called by configure to set dumplo and dumpsize.
 * Dumps always skip the first PAGE_SIZE of disk space
 * in case there might be a disk label stored there.
 * If there is extra space, put dump at the end to
 * reduce the chance that swapping trashes it.
 */
d1200 1
a1200 13
	int nblks;	/* size of dump area */
	int maj;

	if (dumpdev == NODEV)
		return;
	maj = major(dumpdev);
	if (maj < 0 || maj >= nblkdev)
		panic("dumpconf: bad dumpdev=0x%x", dumpdev);
	if (bdevsw[maj].d_psize == NULL)
		return;
	nblks = (*bdevsw[maj].d_psize)(dumpdev);
	if (nblks <= ctod(1))
		return;
d1203 7
a1209 6

	/* mvme88k only uses a single segment. */
	cpu_kcore_hdr.ram_segs[0].start = 0;
	cpu_kcore_hdr.ram_segs[0].size = ctob(physmem);
	cpu_kcore_hdr.cputype = cputyp;

d1214 2
a1215 8
	if (dumplo < ctod(1))
		dumplo = ctod(1);

	/* Put dump at end of partition, and make it fit. */
	if (dumpsize + 1 > dtoc(nblks - dumplo))
		dumpsize = dtoc(nblks - dumplo) - 1;
	if (dumplo < nblks - ctod(dumpsize) - 1)
		dumplo = nblks - ctod(dumpsize) - 1;
a1225 12
	int maj;
	int psize;
	daddr_t blkno;		/* current block to write */
				/* dump routine */
	int (*dump) __P((dev_t, daddr_t, caddr_t, size_t));
	int pg;			/* page being dumped */
	paddr_t maddr;		/* PA being dumped */
	int error;		/* error code from (*dump)() */
	kcore_seg_t *kseg_p;
	cpu_kcore_hdr_t *chdr_p;
	char dump_hdr[dbtob(1)];	/* XXX assume hdr fits in 1 block */

a1228 2

	/* Make sure dump device is valid. */
d1231 5
a1235 1
	if (dumpsize == 0) {
d1237 1
a1237 7
		if (dumpsize == 0)
			return;
	}
	maj = major(dumpdev);
	if (dumplo < 0) {
		printf("\ndump to dev %u,%u not possible\n", maj,
		    minor(dumpdev));
d1239 1
a1239 16
	}
	dump = bdevsw[maj].d_dump;
	blkno = dumplo;

	printf("\ndumping to dev %u,%u offset %ld\n", maj,
	    minor(dumpdev), dumplo);

	/* Setup the dump header */
	kseg_p = (kcore_seg_t *)dump_hdr;
	chdr_p = (cpu_kcore_hdr_t *)&dump_hdr[ALIGN(sizeof(*kseg_p))];
	bzero(dump_hdr, sizeof(dump_hdr));

	CORE_SETMAGIC(*kseg_p, KCORE_MAGIC, MID_MACHINE, CORE_CPU);
	kseg_p->c_size = dbtob(1) - ALIGN(sizeof(*kseg_p));
	*chdr_p = cpu_kcore_hdr;

d1241 1
a1241 33
	psize = (*bdevsw[maj].d_psize)(dumpdev);
	if (psize == -1) {
		printf("area unavailable\n");
		return;
	}

	/* Dump the header. */
	error = (*dump)(dumpdev, blkno++, (caddr_t)dump_hdr, dbtob(1));
	if (error != 0)
		goto abort;

	maddr = (paddr_t)0;
	for (pg = 0; pg < dumpsize; pg++) {
#define NPGMB	(1024 * 1024 / PAGE_SIZE)
		/* print out how many MBs we have dumped */
		if (pg != 0 && (pg % NPGMB) == 0)
			printf("%d ", pg / NPGMB);
#undef NPGMB
		pmap_enter(pmap_kernel(), (vaddr_t)vmmap, maddr,
		    VM_PROT_READ, VM_PROT_READ|PMAP_WIRED);

		error = (*dump)(dumpdev, blkno, vmmap, PAGE_SIZE);
		if (error == 0) {
			maddr += PAGE_SIZE;
			blkno += btodb(PAGE_SIZE);
		} else
			break;
	}
abort:
	switch (error) {
	case 0:
		printf("succeeded\n");
		break;
a1245 1

a1248 1

a1251 1

a1254 5

	case EINTR:
		printf("aborted from console\n");
		break;

d1256 1
a1256 1
		printf("error %d\n", error);
d1268 1
a1268 1
#undef MAP_VEC /* Switching to new virtual addresses XXX smurph */
d1314 2
d1337 1
a1337 1
get_slave_stack()
d1359 1
a1359 1
void slave_pre_main()
d1368 1
a1368 1
slave_main()
d1538 1
a1538 1
			if (guarded_access(ivec[level], 4, (u_char *)&vec) == EFAULT) {
d1558 1
a1558 1
			if (guarded_access(ivec[level], 4, (u_char *)&vec) == EFAULT) {
d1577 1
a1577 1
			panic("m188_ext_int: interrupt vector 0x%x greater than 255!\nlevel = %d iack = 0x%x", 
d1621 1
a1621 1
		trap18x(T_DATAFLT, eframe);
a1746 1
#ifdef MVME187
d1749 1
a1749 1
			trap18x(T_DATAFLT, eframe);
a1753 1
#endif
a1771 25
#ifdef COMPAT_25
	/*
	 * Keep compatibility with older OpenBSD/mvme88k binaries
	 * for a while, to make transition easier.
	 */
	u_long midmag, magic;
	u_short mid;
	struct exec *execp = epp->ep_hdr;

	midmag = ntohl(execp->a_midmag);
	mid = (midmag >> 16) & 0x3ff;
	magic = midmag & 0xffff;

	midmag = mid << 16 | magic;

	switch (midmag) {
	case (OLD_MID_MACHINE << 16) | ZMAGIC:
		return exec_aout_prep_zmagic(p, epp);
	case (OLD_MID_MACHINE << 16) | NMAGIC:
		return exec_aout_prep_nmagic(p, epp);
	case (OLD_MID_MACHINE << 16) | OMAGIC:
		return exec_aout_prep_omagic(p, epp);
	}
#endif

d1777 3
a1779 3
	struct proc *p;
	void *v;
	register_t *retval;
a1780 1
#if 0
d1785 1
a1785 1
#endif
d1787 6
a1792 1
	return (ENOSYS);
d1801 7
a1807 7
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
a1808 1
	dev_t consdev;
a1814 7
	case CPU_CONSDEV:
		if (cn_tab != NULL)
			consdev = cn_tab->cn_dev;
		else
			consdev = NODEV;
		return (sysctl_rdstruct(oldp, oldlenp, newp, &consdev,
		    sizeof consdev));
d1961 1
a1961 1
spl0()
d2099 1
a2099 1
mvme_bootstrap()
d2102 1
d2104 1
a2104 1
	extern void set_tcfp __P((void));
d2106 1
a2106 1
	struct bugbrdid brdid;
d2159 2
d2164 1
d2227 1
a2227 1
void
d2233 1
d2236 1
a2236 1
void
d2241 1
d2254 1
a2254 1
	int c;
d2256 1
a2256 1
	if ((char)c == '\n')
d2258 1
a2258 1
	bugoutchr((char)c);
@


1.18.2.6
log
@Merge in -current
@
text
@d1 1
a1 1
/* $OpenBSD$	*/
d98 1
d118 1
d506 1
a506 1
		NULL, UVM_UNKNOWN_OFFSET, 0, UVM_MAPFLAG(UVM_PROT_NONE, 
d533 1
a533 1
			NULL, UVM_UNKNOWN_OFFSET, 0, UVM_MAPFLAG(UVM_PROT_NONE, 
d547 1
a547 1
			NULL, UVM_UNKNOWN_OFFSET, 0, UVM_MAPFLAG(UVM_PROT_NONE, 
d562 1
a562 1
			NULL, UVM_UNKNOWN_OFFSET, 0, UVM_MAPFLAG(UVM_PROT_NONE, 
d579 1
a579 1
			NULL, UVM_UNKNOWN_OFFSET, 0, UVM_MAPFLAG(UVM_PROT_NONE, 
d597 1
a597 1
		    NULL, UVM_UNKNOWN_OFFSET, 0,
a1081 4
	/* take a snap shot before clobbering any registers */
	if (curproc && curproc->p_addr)
		savectx(curpcb);

d1088 4
d1093 8
a1100 1
	if ((howto & RB_NOSYNC) == 0) {
d1102 1
d1105 1
a1105 2
		 * will be out of synch; adjust it now unless
		 * the system was sitting in ddb.
d1107 1
a1107 4
		if ((howto & RB_TIMEBAD) == 0)
			resettodr();
		else
			printf("WARNING: not updating battery clock\n");
@


1.18.2.7
log
@Merge in -current
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.18.2.6 2001/11/13 21:04:15 niklas Exp $	*/
a83 2
#include <machine/mmu.h>
#include <machine/board.h>
a84 1
#include <machine/bugio.h>
d192 3
a194 3
struct vm_map *exec_map = NULL;
struct vm_map *mb_map = NULL;
struct vm_map *phys_map = NULL;
d206 1
a206 1
struct vm_map *iomap_map;
d597 1
a597 1
				UVM_ADV_NORMAL, 0)))
d627 1
a627 2
			pmap_kenter_pa(curbuf, VM_PAGE_TO_PHYS(pg),
			    VM_PROT_READ|VM_PROT_WRITE);
d1414 1
a1414 1
	while (1); /* spin forever */
a2048 2
#ifdef EH_DEBUG

d2066 1
a2066 3
} 

#endif
@


1.18.2.8
log
@Merge in trunk
@
text
@d1 1
a1 1
/* $OpenBSD$	*/
d51 1
d88 1
a88 1
#include <machine/cmmu.h>		/* CMMU stuff	*/
d93 2
a97 3
#ifdef M88100
#include <machine/m88100.h>		/* DMT_VALID	*/
#endif 
a104 1
#include <mvme88k/dev/busswreg.h>
d125 1
a125 1
struct md_p md;
a140 3
void m187_ext_int __P((u_int v, struct m88100_saved_state *eframe));
void m188_ext_int __P((u_int v, struct m88100_saved_state *eframe));
void m197_ext_int __P((u_int v, struct m88100_saved_state *eframe));
d142 1
a142 1
unsigned char *volatile ivec[] = {
d159 5
a163 5
unsigned int *volatile int_mask_reg[MAX_CPUS] = {
	(unsigned int *)IEN0_REG,
	(unsigned int *)IEN1_REG,
	(unsigned int *)IEN2_REG,
	(unsigned int *)IEN3_REG
d167 8
d178 1
d196 1
a218 5

#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif

a223 1
int   bufcachepercent = BUFCACHEPERCENT;
d232 1
d251 3
a253 5
int boothowto;	/* set in locore.S */
int bootdev;	/* set in locore.S */
int cputyp;	/* set in locore.S */
int brdtyp;	/* set in locore.S */
int cpumod = 0; /* set in mvme_bootstrap() */
d285 1
a285 2
	1
};
d319 1
a319 1
	unsigned int *volatile look;
d354 1
a354 1
	if ((look > (unsigned int *)0x01FFF000) && (brdtyp == BRD_188)) {
a357 1
	
d365 1
a365 1
	struct mvmeprom_brdid brdid;
d382 1
a382 1
	struct mvmeprom_brdid brdid;
d400 2
a401 1
	printf("\nModel: Motorola MVME%x %dMhz\n", brdtyp, cpuspeed);
d413 1
a413 1
		p->p_md.md_upte[i] = *((pt_entry_t *)kvtopte((va + (i * NBPG))));
d420 1
a420 1
	pt_entry_t *t;
d425 1
a425 1
		*t = p->p_md.md_upte[i];
d442 1
a442 1
	if (md.clock_init_func != NULL) {
d446 1
a446 1
		(*md.clock_init_func)();
d448 1
a448 1
	if (md.statclock_init_func != NULL) {
d452 1
a452 1
		(*md.statclock_init_func)();
a481 1
	pmap_update(pmap_kernel());
d519 1
a519 1
	switch (brdtyp) {
d521 1
a521 15
	case BRD_187:
		/*
		 * Grab the SRAM space that we hardwired in pmap_bootstrap
		 */
		sramva = SRAM_START;
		uvm_map(kernel_map, (vaddr_t *)&sramva, SRAM_SIZE,
			NULL, UVM_UNKNOWN_OFFSET, 0, UVM_MAPFLAG(UVM_PROT_NONE, 
							     UVM_PROT_NONE,
							     UVM_INH_NONE,
							     UVM_ADV_NORMAL, 0));

		if (sramva != SRAM_START) {
			printf("sramva %x: SRAM not free\n", sramva);
			panic("bad sramva");
		}
d524 1
a524 1
	case BRD_197:
d526 1
d544 15
d574 1
a574 1
	case BRD_188:
a635 1
	pmap_update(pmap_kernel());
d661 3
d724 3
d738 1
a738 1
			    bufcachepercent / 100;
d765 3
d805 2
a806 14
	
	if (cputyp == CPU_88110) {
		/* 
		 * user mode, serialize mem, interrupts enabled, 
		 * graphics unit, fp enabled 
		 */
		tf->epsr = PSR_SRM | PSR_SFD;  
	} else {
		/* 
		 * user mode, interrupts enabled, 
		 * no graphics unit, fp enabled 
		 */
		tf->epsr = PSR_SFD | PSR_SFD2;
	}
d813 1
a813 1
	 * fetched.  mc88110 - just set exip to pack->ep_entry.
d815 1
a815 4
	if (cputyp == CPU_88110) {
		tf->exip = pack->ep_entry & ~3;
		printf("exec @@ 0x%x\n", tf->exip);
	} else {
a817 1
	}
d852 1
d895 1
a895 1
	    ((sigdebug & SDB_KSTACK) && (p->p_pid == sigpid)))
a918 2
	if (cputyp != CPU_88110) {
		/* mc88100 */
a921 6
	} else {
		/* mc88110 */
		sf.sf_sc.sc_xip = tf->exip & ~3;
		sf.sf_sc.sc_nip = tf->enip & ~3;
		sf.sf_sc.sc_fip = 0;
	}
a925 2
	if (cputyp != CPU_88110) {
		/* mc88100 */
a935 13
	} else {
		/* mc88110 */
		sf.sf_sc.sc_dsr  = tf->dsr;
		sf.sf_sc.sc_dlar = tf->dlar;
		sf.sf_sc.sc_dpar = tf->dpar;
		sf.sf_sc.sc_isr  = tf->isr;
		sf.sf_sc.sc_ilar = tf->ilar;
		sf.sf_sc.sc_ipar = tf->ipar;
		sf.sf_sc.sc_isap = tf->isap;
		sf.sf_sc.sc_dsap = tf->dsap;
		sf.sf_sc.sc_iuap = tf->iuap;
		sf.sf_sc.sc_duap = tf->duap;
	}
a962 2
	if (cputyp != CPU_88110) {
		/* mc88100 */
a964 5
	} else {
		/* mc88110 */
		tf->exip = (addr & ~3);
		tf->enip = (tf->exip + 4);
	}
d968 1
a968 1
	    ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid))
d983 3
a986 1
/* ARGSUSED */
d1031 1
a1032 2
	if (cputyp != CPU_88110) {
		/* mc88100 */
a1035 6
	} else {
		/* mc88110 */
		tf->exip = (scp->sc_xip);
		tf->enip = (scp->sc_nip);
		tf->sfip = 0;
	}
a1039 2
	if (cputyp != CPU_88110) {
		/* mc88100 */
a1049 13
	} else {
		/* mc88110 */
		tf->dsr  = scp->sc_dsr;
		tf->dlar = scp->sc_dlar;
		tf->dpar = scp->sc_dpar;
		tf->isr  = scp->sc_isr;
		tf->ilar = scp->sc_ilar;
		tf->ipar = scp->sc_ipar;
		tf->isap = scp->sc_isap;
		tf->dsap = scp->sc_dsap;
		tf->iuap = scp->sc_iuap;
		tf->duap = scp->sc_duap;
	}
a1123 1

d1325 1
a1325 1
	switch (brdtyp) {
d1327 1
a1327 1
	case BRD_187:
d1336 1
a1336 1
	case BRD_188:
d1351 1
a1351 1
		*ivec[8] = M188_IVEC;	/* supply a vector base for m188ih */
d1355 1
a1355 1
	case BRD_197:
d1369 1
a1369 1
	if (brdtyp != BRD_188) {
a1538 2
	uvmexp.intrs++;

d1560 1
a1560 1
			printf("--CPU %d halted--\n", cpu_number());
d1562 2
a1563 1
			for(;;) ;
d1585 3
a1587 4
			if (guarded_access(ivec[level], 4, (u_char *)&vec) ==
			    EFAULT) {
				panic("unable to get vector for this vmebus "
				    "interrupt (level %x)", level);
d1591 2
a1592 2
				panic("unknown onboard interrupt: mask = 0x%b",
				    1 << intbit, IST_STRING);
d1594 4
d1601 2
a1602 2
				panic("unknown hardware failure: mask = 0x%b",
				    1 << intbit, IST_STRING);
d1605 3
a1607 4
			if (guarded_access(ivec[level], 4, (u_char *)&vec) ==
			    EFAULT) {
				panic("unable to get vector for this vmebus "
				    "interrupt (level %x)", level);
d1611 2
a1612 1
				panic("vme vec timeout");
d1615 2
a1616 2
				panic("unknown vme interrupt: mask = 0x%b",
				    1 << intbit, IST_STRING);
d1619 3
a1621 3
			panic("unknown interrupt: level = %d intbit = 0x%x "
			    "mask = 0x%b",
			    level, intbit, 1 << intbit, IST_STRING);
d1624 2
a1625 3
			panic("interrupt vector 0x%x greater than 255!\n"
			    "level = %d iack = 0x%x", 
			    vec, level, ivec[level]);
d1628 1
a1628 1
		if ((intr = intr_handlers[vec]) == NULL) {
d1631 17
a1647 25
			printf("Spurious interrupt: level = %d vec = 0x%x, "
			    "intbit = %d mask = 0x%b\n",
			    level, vec, intbit, 1 << intbit, IST_STRING);
		} else {
			/*
			 * Walk through all interrupt handlers in the chain
			 * for the given vector, calling each handler in turn,
			 * till some handler returns a value != 0.
			 */
			for (ret = 0; intr; intr = intr->ih_next) {
				if (intr->ih_wantframe != 0)
					ret = (*intr->ih_fn)((void *)eframe);
				else
					ret = (*intr->ih_fn)(intr->ih_arg);
				if (ret != 0) {
					/* increment intr counter */
					intrcnt[level]++; 
					break;
				}
			}
			if (ret == 0) {
				printf("Unclaimed interrupt: level = %d "
				    "vec = 0x%x, intbit = %d mask = 0x%b\n",
				    level, vec, intbit,
				    1 << intbit, IST_STRING);
d1651 8
d1665 1
d1668 1
a1668 1
		m88100_trap(T_DATAFLT, eframe);
d1679 1
d1693 1
a1693 1
#ifdef MVME187
d1695 1
a1695 1
m187_ext_int(u_int v, struct m88100_saved_state *eframe)
d1703 2
a1704 2
	mask = *md.intr_mask;
	level = *md.intr_ipl;
d1714 2
a1715 1
		panic("mask == level, %d\n", level);
d1724 2
a1725 1
		panic("Bogons... level %x and mask %x\n", level, mask);
a1732 2
	uvmexp.intrs++;

d1738 1
a1738 1
	flush_pipeline();
d1740 2
a1741 1
		panic("Unable to get vector for this interrupt (level %x)\n", level);
d1743 3
a1745 3
	flush_pipeline();
	flush_pipeline();
	flush_pipeline();
d1753 1
a1753 1
	if ((intr = intr_handlers[vec]) == NULL) {
d1758 5
a1762 6
	} else {
		if (intr && intr->ih_ipl != level) {
			panic("Handler ipl %x not the same as level %x. "
			    "vec = 0x%x",
			    intr->ih_ipl, level, vec);
		}
d1764 5
a1768 5
		/*
		 * Walk through all interrupt handlers in the chain for the
		 * given vector, calling each handler in turn, till some handler
		 * returns a value != 0.
		 */
d1770 9
a1778 10
		for (ret = 0; intr; intr = intr->ih_next) {
			if (intr->ih_wantframe != 0)
				ret = (*intr->ih_fn)((void *)eframe);
			else
				ret = (*intr->ih_fn)(intr->ih_arg);
			if (ret != 0) {
				/* increment intr counter */
				intrcnt[level]++; 
				break;
			}
d1780 1
d1782 3
a1784 4
		if (ret == 0) {
			printf("Unclaimed interrupt (level %x and vec %x)\n",
			    level, vec);
		}
d1793 8
a1800 4
	if (eframe->dmt0 & DMT_VALID) {
		m88100_trap(T_DATAFLT, eframe);
		data_access_emulation((unsigned *)eframe);
		eframe->dmt0 &= ~DMT_VALID;
d1802 1
a1809 59
}
#endif /* MVME187 */

#ifdef MVME197
void
m197_ext_int(u_int v, struct m88100_saved_state *eframe)
{
	register u_char mask, level, src;
	register struct intrhand *intr;
	int ret;
	u_char vec;

	/* get src and mask */
	mask = *md.intr_mask;
	src = *md.intr_src;
	
	if (v == T_NON_MASK) {
		/* This is the abort switch */
		level = IPL_NMI;
		vec = BS_ABORTVEC;
	} else {
		/* get level  */
		level = *md.intr_ipl;
	}

	/*
	 * Interrupting level cannot be 0--0 doesn't produce an interrupt.
	 * Weird! XXX nivas
	 */

	if (level == 0) {
		panic("Bogons... level %x and mask %x\n", level, mask);
	}

	/* and block interrupts at level or lower */
	setipl((u_char)level);
	/* and stash it away in the trap frame */
	eframe->mask = mask;

	uvmexp.intrs++;

	if (level > 7 || (char)level < 0) {
		panic("int level (%x) is not between 0 and 7", level);
	}

	if (v != T_NON_MASK) {
		/* generate IACK and get the vector */
		flush_pipeline();
		if (guarded_access(ivec[level], 1, &vec) == EFAULT) {
			panic("Unable to get vector for this interrupt (level %x)\n", level);
		}
		flush_pipeline();
		flush_pipeline();
		flush_pipeline();
	}

	if (vec > 0xFF) {
		panic("interrupt vector %x greater than 255", vec);
	}
d1811 2
a1812 46
	enable_interrupt();

	if ((intr = intr_handlers[vec]) == NULL) {
		/* increment intr counter */
		intrcnt[M88K_SPUR_IRQ]++; 
		printf("Spurious interrupt (level %x and vec %x)\n",
		       level, vec);
	} else {
		if (intr && intr->ih_ipl != level) {
			panic("Handler ipl %x not the same as level %x. "
			    "vec = 0x%x",
			    intr->ih_ipl, level, vec);
		}

		/*
		 * Walk through all interrupt handlers in the chain for the
		 * given vector, calling each handler in turn, till some handler
		 * returns a value != 0.
		 */
		for (ret = 0; intr; intr = intr->ih_next) {
			if (intr->ih_wantframe != 0)
				ret = (*intr->ih_fn)((void *)eframe);
			else
				ret = (*intr->ih_fn)(intr->ih_arg);
			if (ret != 0) {
				/* increment intr counter */
				intrcnt[level]++; 
				break;
			}
		}

		if (ret == 0) {
			printf("Unclaimed interrupt (level %x and vec %x)\n",
			    level, vec);
		}
	}

	disable_interrupt();

	mask = eframe->mask;

	/*
	 * Restore the mask level to what it was when the interrupt
	 * was taken.
	 */
	setipl((u_char)mask);
d1814 1
a1814 1
#endif 
d2008 1
a2008 1
	struct mvmeprom_brdid brdid;
d2106 2
a2107 2
	if (cputyp == CPU_88110) {
		printf("exip %x enip %x\n", f->exip, f->enip);
d2111 2
a2112 2
#ifdef M88100
	if (f->vector == 0x3 && cputyp != CPU_88110) {
d2120 19
a2138 9
	if (longformat && cputyp != CPU_88110) {
		printf("fpsr %x fpcr %x epsr %x ssbr %x\n", 
		       f->fpsr, f->fpcr, f->epsr, f->ssbr);
		printf("fpecr %x fphs1 %x fpls1 %x fphs2 %x fpls2 %x\n", 
		       f->fpecr, f->fphs1, f->fpls1, f->fphs2, f->fpls2);
		printf("fppt %x fprh %x fprl %x fpit %x\n", 
		       f->fppt, f->fprh, f->fprl, f->fpit);
		printf("vector %d mask %x mode %x scratch1 %x cpu %x\n", 
		       f->vector, f->mask, f->mode, f->scratch1, f->cpu);
d2141 19
a2159 10
#ifdef M88110
	if (longformat && cputyp == CPU_88110) {
		printf("fpsr %x fpcr %x fpecr %x epsr %x\n", 
		       f->fpsr, f->fpcr, f->fpecr, f->epsr);
		printf("dsap %x duap %x dsr %x dlar %x dpar %x\n",
		       f->dsap, f->duap, f->dsr, f->dlar, f->dpar);
		printf("isap %x iuap %x isr %x ilar %x ipar %x\n",
		       f->isap, f->iuap, f->isr, f->ilar, f->ipar);
		printf("vector %d mask %x mode %x scratch1 %x cpu %x\n", 
		       f->vector, f->mask, f->mode, f->scratch1, f->cpu);
d2163 1
a2163 1
	if (brdtyp == BRD_188 ) {
d2166 1
a2166 1
		istr = *(int *volatile)IST_REG;
d2187 1
a2187 11
	struct mvmeprom_brdid brdid;
	
	/*
	 * Must initialize p_addr before autoconfig or
	 * the fault handler will get a NULL reference.
	 * Do this early so that we can take a data or 
	 * instruction fault and survive it. XXX smurph
	 */
	proc0.p_addr = proc0paddr;
	curproc = &proc0;
	curpcb = &proc0paddr->u_pcb;
d2190 1
a2190 1
	bzero(&md, sizeof(struct md_p));
d2194 1
a2194 1
	brdtyp = brdid.model;
d2197 2
a2198 2
	if (brdtyp == BRD_8120)
		brdtyp = BRD_187;
d2204 1
a2204 1
	switch (brdtyp) {
d2206 3
a2208 6
	case BRD_188:
		cmmu = &cmmu8820x;
		md.interrupt_func = &m188_ext_int;
		md.intr_mask = NULL;
		md.intr_ipl = NULL;
		md.intr_src = NULL;
d2217 3
a2219 6
	case BRD_187:
		cmmu = &cmmu8820x;
		md.interrupt_func = &m187_ext_int;
		md.intr_mask = (u_char *)M187_IMASK;
		md.intr_ipl = (u_char *)M187_ILEVEL;
		md.intr_src = NULL;
d2223 3
a2225 6
	case BRD_197:
		cmmu = &cmmu88110;
		md.interrupt_func = &m197_ext_int;
		md.intr_mask = (u_char *)M197_IMASK;
		md.intr_ipl = (u_char *)M197_ILEVEL;
		md.intr_src = (u_char *)M197_ISRC;
a2240 1

d2250 1
a2250 1
	if (brdtyp == BRD_188 && (boothowto & RB_MINIROOT)) {
a2263 1

d2265 1
a2265 1
	printf("MVME%x boot: memory from 0x%x to 0x%x\n", brdtyp, avail_start, avail_end);
d2270 1
d2277 8
@


1.18.2.9
log
@Merge in -current from about a week ago
@
text
@d129 16
a144 16
void m88100_Xfp_precise(void);
void m88110_Xfp_precise(void);
void setupiackvectors(void);
void regdump(struct trapframe *f);
void dumpsys(void);
void consinit(void);
vm_offset_t size_memory(void);
int getcpuspeed(void);
int getscsiid(void);
void identifycpu(void);
void save_u_area(struct proc *, vm_offset_t);
void load_u_area(struct proc *);
void dumpconf(void);
void m187_ext_int(u_int v, struct m88100_saved_state *eframe);
void m188_ext_int(u_int v, struct m88100_saved_state *eframe);
void m197_ext_int(u_int v, struct m88100_saved_state *eframe);
d225 1
a225 1
caddr_t allocsys(caddr_t);
d270 5
a274 5
void bootcnprobe(struct consdev *);
void bootcninit(struct consdev *);
void bootcnputc(dev_t, int);
int  bootcngetc(dev_t);
extern void nullcnpollc(dev_t, int);
d330 3
a332 3
	max = (void *)MAXPHYSMEM;
	for (look = (void *)Roundup(end, STRIDE); look < max;
	    look = (int *)((unsigned)look + STRIDE)) {
d1267 1
a1267 1
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
d2321 1
a2321 1
	extern void set_tcfp(void);
@


1.18.2.10
log
@Sync the SMP branch with 3.3
@
text
@d66 6
a135 1
vm_offset_t memsize187(void);
d188 1
a188 1
int   safepri = IPL_NONE;
a312 23
#ifdef MVME187
/*
 * Figure out how much memory is available, by querying the memory controllers
 */
#include <mvme88k/dev/memcreg.h>
vm_offset_t
memsize187()
{
	struct memcreg *memc;
	vm_offset_t x;

	memc = (struct memcreg *)0xfff43000;
	x = MEMC_MEMCONF_RTOB(memc->memc_memconf);

	memc = (struct memcreg *)0xfff43100;
	if (!badaddr((vm_offset_t)&memc->memc_memconf, 1))
		x += MEMC_MEMCONF_RTOB(memc->memc_memconf);

	return x;
}
#endif

#if defined(MVME188) || defined(MVME197)
d361 1
a363 1
#endif	/* defined(MVME188) || defined(MVME197) */
d403 1
a403 2
	sprintf(cpu_model, "Motorola MVME%x, %dMHz", brdtyp, cpuspeed);
	printf("\nModel: %s\n", cpu_model);
d707 9
d876 3
d993 1
a993 1
	addr = p->p_sigcode;
d1018 1
a1018 1
 * psl to gain improper privileges or to cause
d1681 1
a1681 1
			panic("interrupt vector 0x%x greater than 255!"
d1734 1
a1734 1
	setipl(eframe->mask);
d1759 2
a1760 2
	mask = *md.intr_mask & 0x07;
	level = *md.intr_ipl & 0x07;
d1770 1
a1770 1
		panic("mask == level, %d", level);
d1779 1
a1779 1
		panic("Bogons... level %x and mask %x", level, mask);
d1783 1
a1783 1
	setipl(level);
d1789 4
d1796 1
a1796 1
		panic("Unable to get vector for this interrupt (level %x)", level);
d1802 1
a1802 1
	if (vec > 0xff) {
a1854 1

d1861 1
a1861 1
	setipl(mask);
d1875 1
a1875 1
	mask = *md.intr_mask & 0x07;
d1884 1
a1884 1
		level = *md.intr_ipl & 0x07;
d1893 1
a1893 1
		panic("Bogons... level %x and mask %x", level, mask);
d1897 1
a1897 1
	setipl(level);
d1903 4
d1911 1
a1911 1
			panic("Unable to get vector for this interrupt (level %x)", level);
d1918 1
a1918 1
	if (vec > 0xff) {
d1967 1
a1967 1
	setipl(mask);
d2395 1
a2395 16
	switch (brdtyp) {
#ifdef MVME187
	case BRD_187:
		last_addr = memsize187();
		break;
#endif
#ifdef MVME188
	case BRD_188:
#endif
#ifdef MVME197
	case BRD_197:
#endif
		last_addr = size_memory();
		break;
	}
	physmem = btoc(last_addr);
@


1.18.2.11
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.18.2.10 2003/03/27 23:32:18 niklas Exp $	*/
d421 1
a421 2
	snprintf(cpu_model, sizeof cpu_model,
	    "Motorola MVME%x, %dMHz", brdtyp, cpuspeed);
@


1.18.2.12
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/* $OpenBSD$	*/
d56 2
d59 1
d66 1
d91 1
a91 1
#endif
a96 1
#ifdef MVME188
d98 1
a98 2
#endif
#ifdef MVME197
a99 1
#endif
d101 1
d117 1
a117 1
vaddr_t interrupt_stack[MAX_CPUS];
d119 1
a119 1
/* machine dependent function pointers. */
d123 2
d129 2
a130 2
vaddr_t size_memory(void);
vaddr_t memsize187(void);
d132 1
d134 1
a134 1
void save_u_area(struct proc *, vaddr_t);
d137 3
a139 3
void m187_ext_int(u_int v, struct trapframe *eframe);
void m188_ext_int(u_int v, struct trapframe *eframe);
void m197_ext_int(u_int v, struct trapframe *eframe);
d164 1
a164 1
#endif
d166 3
a168 10
#if defined(MVME187) || defined(MVME197)
volatile vaddr_t obiova;
#ifdef MVME187
volatile vaddr_t bugromva;
volatile vaddr_t sramva;
#endif
#ifdef MVME197
volatile vaddr_t flashva;
#endif
#endif
d170 1
a170 1
volatile vaddr_t utilva;
d228 13
d249 2
a250 2
int cpumod;	/* set in mvme_bootstrap() */
int cpuspeed;
d252 2
a253 2
vaddr_t first_addr;
vaddr_t last_addr;
d255 2
a256 2
vaddr_t avail_start, avail_end;
vaddr_t virtual_avail, virtual_end;
d258 1
a258 1
extern struct pcb *curpcb;
d261 2
a262 2
/*
 *  XXX this is to fake out the console routines, while
d265 6
a270 1
cons_decl(boot);
d273 4
a276 4
struct consdev bootcons = {
	NULL,
	NULL,
	bootcngetc,
d313 1
a313 1
vaddr_t
d317 1
a317 1
	vaddr_t x;
d319 1
a319 1
	memc = (struct memcreg *)MEM_CTLR;
d322 2
a323 2
	memc = (struct memcreg *)(MEM_CTLR + 0x100);
	if (!badaddr((vaddr_t)&memc->memc_memconf, 1))
d336 1
a336 1
vaddr_t
d374 5
a378 1

a388 1

d390 5
a394 8

	for (i = 0; i < 4; i++) {
		c = (unsigned char)brdid.speed[i];
		if (c == ' ')
			c = '0';
		else if (c > '9' || c < '0')
			goto fail;
		speed = speed * 10 + (c - '0');
d398 1
d400 15
a414 9
fail:
	/*
	 * If we end up here, the board information block is
	 * damaged and we can't trust it.
	 * Suppose we are running at 25MHz and hope for the best.
	 */
	printf("WARNING: Board Configuration Data invalid, "
	    "replace NVRAM and restore values\n");
	return (25);
d423 1
d431 1
a431 1
save_u_area(struct proc *p, vaddr_t va)
d433 3
a435 5
	int i;

	for (i = 0; i < UPAGES; i++) {
		p->p_md.md_upte[i] = *((pt_entry_t *)kvtopte(va));
		va += NBPG;
a441 2
	int i;
	vaddr_t va;
d444 3
a446 2
	for (i = 0, va = UADDR; i < UPAGES; i++) {
		t = kvtopte(va);
a447 1
		va += NBPG;
d449 3
a451 1
	cmmu_flush_tlb(cpu_number(), 1, UADDR, USPACE);
d458 1
a458 1
void
d461 3
d465 3
d471 3
d476 3
d484 1
a484 1
	/* function stub */
d493 1
a493 1
	vsize_t size;
d502 2
a503 2
		pmap_kenter_pa((paddr_t)msgbufp + i * NBPG,
		    avail_end + i * NBPG, VM_PROT_READ | VM_PROT_WRITE);
d530 11
a540 8
	    NULL, UVM_UNKNOWN_OFFSET, 0,
	      UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
	        UVM_ADV_NORMAL, 0));
	if (uarea_pages != UADDR)
		panic("uarea_pages %lx: UADDR not free", uarea_pages);

	/*
	 * Grab machine dependent memory spaces
a544 1
	case BRD_8120:
d550 10
a559 29
		    NULL, UVM_UNKNOWN_OFFSET, 0,
		      UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
		        UVM_ADV_NORMAL, 0));
		if (sramva != SRAM_START)
			panic("sramva %lx: SRAM not free", sramva);

		/*
		 * Grab the BUGROM space that we hardwired in pmap_bootstrap
		 */
		bugromva = BUG187_START;
		uvm_map(kernel_map, (vaddr_t *)&bugromva, BUG187_SIZE,
		    NULL, UVM_UNKNOWN_OFFSET, 0,
		      UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
		        UVM_ADV_NORMAL, 0));
		if (bugromva != BUG187_START)
			panic("bugromva %lx: BUGROM not free", bugromva);

		/*
		 * Grab the OBIO space that we hardwired in pmap_bootstrap
		 */
		obiova = OBIO_START;
		uvm_map(kernel_map, (vaddr_t *)&obiova, OBIO_SIZE,
		    NULL, UVM_UNKNOWN_OFFSET, 0,
		      UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
		        UVM_ADV_NORMAL, 0));
		if (obiova != OBIO_START)
			panic("obiova %lx: OBIO not free", obiova);
		break;
#endif
d562 2
d565 1
a565 1
		 * Grab the FLASH space that we hardwired in pmap_bootstrap
d567 1
a567 7
		flashva = FLASH_START;
		uvm_map(kernel_map, (vaddr_t *)&flashva, FLASH_SIZE,
		    NULL, UVM_UNKNOWN_OFFSET, 0,
		      UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
		        UVM_ADV_NORMAL, 0));
		if (flashva != FLASH_START)
			panic("flashva %lx: FLASH not free", flashva);
d569 10
d584 8
a591 5
		    NULL, UVM_UNKNOWN_OFFSET, 0,
		      UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
		        UVM_ADV_NORMAL, 0));
		if (obiova != OBIO_START)
			panic("obiova %lx: OBIO not free", obiova);
d593 1
a593 1
#endif
d601 8
a608 5
		    NULL, UVM_UNKNOWN_OFFSET, 0,
		      UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
		        UVM_ADV_NORMAL, 0));
		if (utilva != MVME188_UTILITY)
			panic("utilva %lx: UTILITY area not free", utilva);
d619 3
a621 2
	    NULL, UVM_UNKNOWN_OFFSET, 0, UVM_MAPFLAG(UVM_PROT_NONE,
	      UVM_PROT_NONE, UVM_INH_NONE, UVM_ADV_NORMAL, 0)))
d643 1
a643 1
		curbuf = (vaddr_t)buffers + (i * MAXBSIZE);
d652 1
a652 1
			    VM_PROT_READ | VM_PROT_WRITE);
d664 2
a665 2
	    16 * NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);

d670 1
a670 1
	    VM_PHYS_SIZE, 0, FALSE, NULL);
d672 1
a672 1
	/*
d676 1
a676 1
	    IOMAP_SIZE, 0, FALSE, NULL);
d683 1
a683 1
	printf("avail mem = %ld (%d pages)\n", ptoa(uvmexp.free), uvmexp.free);
d721 1
a721 1
	caddr_t v;
d755 2
a756 2
	    (VM_MAX_KERNEL_ADDRESS - VM_MIN_KERNEL_ADDRESS) / MAXBSIZE * 7 / 10)
		nbuf = (VM_MAX_KERNEL_ADDRESS - VM_MIN_KERNEL_ADDRESS) /
d779 1
a779 1
	struct trapframe *tf = (struct trapframe *)USER_REGS(p);
d809 1
a809 1

d811 3
a813 3
		/*
		 * user mode, serialize mem, interrupts enabled,
		 * graphics unit, fp enabled
d815 1
a815 5
		tf->tf_epsr = PSR_SRM | PSR_SFD;
		/*
		 * XXX disable OoO for now...
		 */
		tf->tf_epsr |= PSR_SER;
d817 3
a819 3
		/*
		 * user mode, interrupts enabled,
		 * no graphics unit, fp enabled
d821 1
a821 1
		tf->tf_epsr = PSR_SFD | PSR_SFD2;
d832 2
a833 4
		tf->tf_exip = pack->ep_entry & ~3;
#ifdef DEBUG
		printf("exec @@ 0x%x\n", tf->tf_exip);
#endif
d835 2
a836 2
		tf->tf_snip = pack->ep_entry & ~3;
		tf->tf_sfip = (pack->ep_entry & ~3) | FIP_V;
d838 2
a839 2
	tf->tf_r[2] = stack;
	tf->tf_r[31] = stack;
d850 1
a850 1
 * through sf_handler so... don't screw with them!
d853 6
a858 6
	int			sf_signo;	/* signo for handler */
	siginfo_t *		sf_sip;
	struct sigcontext *	sf_scp;		/* context ptr for handler */
	sig_t			sf_handler;	/* handler addr for u_sigc */
	struct sigcontext	sf_sc;		/* actual context */
	siginfo_t		sf_si;
d880 3
a882 3
	struct proc *p = curproc;
	struct trapframe *tf;
	struct sigacts *psp = p->p_sigacts;
d889 1
a889 1
	oonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d899 1
a899 1
	    (psp->ps_sigstk.ss_flags & SS_ONSTACK) == 0 &&
d903 1
a903 1
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
d905 2
a906 7
		fp = (struct sigframe *)(tf->tf_r[31] - fsize);

	/* make sure the frame is aligned on a 8 byte boundary */
	if (((vaddr_t)fp & 0x07) != 0)
		fp = (struct sigframe *)((vaddr_t)fp & ~0x07);

	if ((unsigned)fp <= USRSTACK - ctob(p->p_vmspace->vm_ssize))
d933 51
a983 3
	bcopy((const void *)&tf->tf_regs, (void *)&sf.sf_sc.sc_regs,
	    sizeof(sf.sf_sc.sc_regs));

d997 1
a997 1
	/*
d1004 2
a1005 2
		tf->tf_snip = (addr & ~3) | NIP_V;
		tf->tf_sfip = (tf->tf_snip + 4) | FIP_V;
d1008 2
a1009 2
		tf->tf_exip = (addr & ~3);
		tf->tf_enip = (tf->tf_exip + 4);
d1011 1
a1011 1
	tf->tf_r[31] = (unsigned)fp;
d1033 3
a1035 3
	struct proc *p;
	void *v;
	register_t *retval;
d1040 2
a1041 2
	struct sigcontext *scp;
	struct trapframe *tf;
d1049 1
a1049 1
	if (((vaddr_t)scp & 3) != 0 ||
d1055 15
a1069 1

d1075 50
a1124 2
	bcopy((const void *)&scp->sc_regs, (caddr_t)&tf->tf_regs,
	    sizeof(scp->sc_regs));
d1129 2
a1130 2
	if (scp->sc_onstack & SS_ONSTACK)
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
d1132 1
a1132 1
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
a1133 1

d1148 1
a1148 1
	int howto;
d1150 1
a1150 1
	/* take a snapshot before clobbering any registers */
d1196 1
a1196 1
void
d1350 1
a1350 1

d1383 1
a1383 1
	u_char *vaddr;
d1386 1
a1386 1
	extern vaddr_t iomap_mapin(paddr_t, psize_t,  boolean_t);
a1394 1
	case BRD_8120:
d1433 1
a1433 1
#endif
d1450 1
a1450 1
vaddr_t
d1453 2
a1454 3
	vaddr_t addr;

	addr = (vaddr_t)uvm_km_zalloc(kernel_map, INTSTACK_SIZE);
d1457 1
a1457 2
		panic("Cannot allocate slave stack for cpu %d",
		    cpu_number());
d1459 2
d1473 1
a1473 2
void
slave_pre_main()
d1499 1
a1499 1
#ifdef DEBUG
d1502 1
a1502 1
		panic("intr_findvec(%d,%d): bad parameters", start, end);
d1510 1
a1510 1
	printf("intr_findvec(%d,%d): no vector available\n", start, end);
d1523 1
a1523 1
	struct intrhand *intr;
d1576 1
a1576 1
	0,0,0,0,SYSCV_TIMER1,0,SYSCV_ACF,SYSCV_ABRT,
d1583 2
a1584 2
void
m188_ext_int(u_int v, struct trapframe *eframe)
d1586 4
a1589 4
	int cpu = cpu_number();
	unsigned int cur_mask;
	unsigned int level, old_spl;
	struct intrhand *intr;
d1595 1
a1595 1
	eframe->tf_mask = old_spl;
d1603 1
a1603 1
		goto out;
d1608 1
a1608 1
	/*
d1612 1
a1612 1
	 * priority.
d1618 1
a1618 1
			int i;
a1633 1
#ifdef DEBUG
a1636 1
#endif
d1639 3
a1641 11

		/*
		 * Do not enable interrupts yet if we know, from cur_mask,
		 * that we have not cleared enough conditions yet.
		 * For now, only the timer interrupt requires its condition
		 * to be cleared before interrupts are enabled.
		 */
		if ((cur_mask & DTI_BIT) == 0) {
			enable_interrupt();
		}

d1644 3
a1646 3
		/*
		 * This is tricky.  If you don't catch all the
		 * interrupts, you die. Game over. Insert coin...
d1653 5
d1677 1
a1677 2
				printf("vme vec timeout");
				break;
d1688 5
d1696 1
a1696 1
			intrcnt[M88K_SPUR_IRQ]++;
d1713 1
a1713 1
					intrcnt[level]++;
d1732 1
a1732 2
out:
	if (eframe->tf_dmt0 & DMT_VALID)
d1734 3
d1742 2
a1743 1
	setipl(eframe->tf_mask);
d1759 1
a1759 1
m187_ext_int(u_int v, struct trapframe *eframe)
d1761 2
a1762 2
	int mask, level;
	struct intrhand *intr;
a1769 1
#ifdef DIAGNOSTIC
d1789 5
a1793 1
#endif
d1806 3
a1808 2
	/* block interrupts at level or lower */
	setipl(level);
d1814 1
a1814 1
		intrcnt[M88K_SPUR_IRQ]++;
a1817 1
#ifdef DIAGNOSTIC
a1822 1
#endif
d1831 1
a1831 1
			if (intr->ih_wantframe != 0) {
d1833 1
a1833 1
			} else
d1837 1
a1837 1
				intrcnt[level]++;
d1853 2
a1854 1
	if (eframe->tf_dmt0 & DMT_VALID)
d1856 5
d1872 1
a1872 1
m197_ext_int(u_int v, struct trapframe *eframe)
d1874 2
a1875 2
	int mask, level, src;
	struct intrhand *intr;
d1882 1
a1882 1

a1891 1
#ifdef DIAGNOSTIC
d1900 5
a1904 1
#endif
d1919 3
a1921 2
	/* block interrupts at level or lower */
	setipl(level);
d1927 1
a1927 1
		intrcnt[M88K_SPUR_IRQ]++;
a1930 1
#ifdef DIAGNOSTIC
a1935 1
#endif
a1941 1

d1949 1
a1949 1
				intrcnt[level]++;
d1962 2
d1970 1
a1970 1
#endif	/* MVME197 */
d1974 2
a1975 2
	struct proc *p;
	struct exec_package *epp;
d1977 14
d1992 11
a2002 1
	return (ENOEXEC);
d2056 1
a2056 1
 * insert an element into a queue
d2063 1
a2063 1
	struct prochd *element, *head;
d2080 1
a2080 1
	struct prochd *element;
d2115 1
a2115 1
	struct proc *p;
d2117 3
a2119 3
	struct prochd *q;
	struct proc *oldlast;
	int which = p->p_priority >> 2;
d2122 1
a2122 1
		panic("setrunqueue %p", p);
d2139 3
a2141 3
	struct proc *p = vp;
	int which = p->p_priority >> 2;
	struct prochd *q;
d2144 1
a2144 1
		panic("remrq %p", p);
a2169 2
int netisr;

d2213 4
a2216 4
	struct trapframe  *f;
	caddr_t     p;
	int         flags;
	char        *s;
d2220 1
a2220 1
}
d2228 1
a2228 1
}
d2236 1
a2236 1
	struct trapframe *frame = framep;
d2250 1
a2250 1
#define R(i) f->tf_r[i]
d2263 1
a2263 1
		printf("exip %x enip %x\n", f->tf_exip, f->tf_enip);
d2265 1
a2265 2
		printf("sxip %x snip %x sfip %x\n",
		    f->tf_sxip, f->tf_snip, f->tf_sfip);
d2268 1
a2268 1
	if (f->tf_vector == 0x3 && cputyp != CPU_88110) {
d2270 4
a2273 7
		printf("dmt0 %x dmd0 %x dma0 %x\n",
		    f->tf_dmt0, f->tf_dmd0, f->tf_dma0);
		printf("dmt1 %x dmd1 %x dma1 %x\n",
		    f->tf_dmt1, f->tf_dmd1, f->tf_dma1);
		printf("dmt2 %x dmd2 %x dma2 %x\n",
		    f->tf_dmt2, f->tf_dmd2, f->tf_dma2);
		printf("fault type %d\n", (f->tf_dpfsr >> 16) & 0x7);
d2277 8
a2284 10
		printf("fpsr %x fpcr %x epsr %x ssbr %x\n",
		    f->tf_fpsr, f->tf_fpcr, f->tf_epsr, f->tf_ssbr);
		printf("fpecr %x fphs1 %x fpls1 %x fphs2 %x fpls2 %x\n",
		    f->tf_fpecr, f->tf_fphs1, f->tf_fpls1,
		    f->tf_fphs2, f->tf_fpls2);
		printf("fppt %x fprh %x fprl %x fpit %x\n",
		    f->tf_fppt, f->tf_fprh, f->tf_fprl, f->tf_fpit);
		printf("vector %d mask %x mode %x scratch1 %x cpu %x\n",
		    f->tf_vector, f->tf_mask, f->tf_mode,
		    f->tf_scratch1, f->tf_cpu);
d2286 1
a2286 1
#endif
d2289 2
a2290 2
		printf("fpsr %x fpcr %x fpecr %x epsr %x\n",
		    f->tf_fpsr, f->tf_fpcr, f->tf_fpecr, f->tf_epsr);
d2292 1
a2292 1
		    f->tf_dsap, f->tf_duap, f->tf_dsr, f->tf_dlar, f->tf_dpar);
d2294 3
a2296 4
		    f->tf_isap, f->tf_iuap, f->tf_isr, f->tf_ilar, f->tf_ipar);
		printf("vector %d mask %x mode %x scratch1 %x cpu %x\n",
		    f->tf_vector, f->tf_mask, f->tf_mode,
		    f->tf_scratch1, f->tf_cpu);
d2300 1
a2300 1
	if (brdtyp == BRD_188) {
d2305 1
a2305 1
		printf("emask = 0x%b\n", f->tf_mask, IST_STRING);
d2309 1
a2309 1
#endif
a2321 6
#ifdef MVME197
	extern struct cmmu_p cmmu88110;
#endif
#if defined(MVME187) || defined(MVME188)
	extern struct cmmu_p cmmu8820x;
#endif
d2325 1
a2325 1

d2329 1
a2329 1
	 * Do this early so that we can take a data or
d2336 1
a2336 1
	/* zero out the machine dependent function pointers */
d2343 6
a2348 2
	/*
	 * set up interrupt and fp exception handlers
a2367 1
	case BRD_8120:
a2398 1
	case BRD_8120:
a2401 1
#if defined(MVME188) || defined(MVME197)
a2409 3
#endif
	default:
		break;
d2419 1
d2421 2
a2422 9
	/*
	 * If we have more than one CPU, mention which one is the master.
	 * We will also want to spin up slave CPUs on the long run...
	 */
	switch (brdtyp) {
	case BRD_188:
		printf("CPU%d is master CPU\n", master_cpu);

#if 0
d2424 1
a2424 1
		for (i = 0; i < MAX_CPUS; i++) {
a2427 9
#endif
		break;
	case BRD_197:
		/*
		 * In the 197DP case, mention which CPU is the master
		 * there too...
		 * XXX TBD
		 */
		break;
d2429 1
a2429 1

d2439 2
a2440 2
#endif
	pmap_bootstrap((vaddr_t)trunc_page((unsigned)&kernelstart) /* = loadpt */,
d2444 1
a2444 1
	 * Tell the VM system about available physical memory.
d2451 1
a2451 1
	save_u_area(&proc0, (vaddr_t)proc0paddr);
d2462 1
a2462 1
#endif
d2466 1
a2466 1
 * Boot console routines:
@


1.18.2.13
log
@Merge with the trunk
@
text
@d251 2
a252 4
 * This is to fake out the console routines, while booting.
 * We could use directly the bugtty console, but we want to be able to
 * configure a kernel without bugtty since we do not necessarily need a
 * full-blown console driver.
d269 3
a271 3
 * Early console initialization: called early on from main, before vm init.
 * We want to stick to the BUG routines for now, and we'll switch to the
 * real console in cpu_startup().
d276 1
d278 5
a282 1
	cn_tab = &bootcons;
d376 2
a377 4
		else if (c > '9' || c < '0') {
			speed = 0;
			break;
		}
d381 1
d383 1
a383 25
	switch (brdtyp) {
#ifdef MVME187
	case BRD_187:
	case BRD_8120:
		if (speed == 25 || speed == 33)
			return speed;
		speed = 25;
		break;
#endif
#ifdef MVME188
	case BRD_188:
		if (speed == 20 || speed == 25)
			return speed;
		speed = 25;
		break;
#endif
#ifdef MVME197
	case BRD_197:
		if (speed == 40 || speed == 50)
			return speed;
		speed = 50;
		break;
#endif
	}

d385 3
a387 4
	 * If we end up here, the board information block is damaged and
	 * we can't trust it.
	 * Suppose we are running at the most common speed for our board,
	 * and hope for the best (this really only affects osiop).
d391 1
a391 1
	return speed;
d922 7
a928 2
		sigexit(p, SIGILL);
		/* NOTREACHED */
d1028 1
a1028 3
		/* (Unless the user explicitly asked for reboot.) */
		if ((howto & RB_USERREQ) == 0)
			howto |= RB_HALT;
d1063 1
a1063 1
	for (;;);
d1068 1
a1068 1
__dead void
d1073 6
a1078 14
	*(volatile u_int32_t *)IEN0_REG = 0;
	*(volatile u_int32_t *)IEN1_REG = 0;
	*(volatile u_int32_t *)IEN2_REG = 0;
	*(volatile u_int32_t *)IEN3_REG = 0;

	if ((*(volatile u_int8_t *)GLB1) & M188_SYSCONNEG) {
		/* Force only a local reset */
		*(volatile u_int8_t *)GLB1 |= M188_LRST;
	} else {
		/* Force a complete VMEbus reset */
		*(volatile u_int32_t *)GLBRES_REG = 1;
	}

	*(volatile u_int32_t *)UCSR_REG |= 0x2000;	/* clear SYSFAIL */
d1081 1
a1081 5
	*(volatile u_int32_t *)UCSR_REG |= 0x2000;	/* clear SYSFAIL */

	printf("reset failed\n");
	for (;;);
	/* NOTREACHED */
d1368 2
a1369 1
intr_findvec(int start, int end, int skip)
d1374 1
d1379 1
a1379 3
	for (vec = start; vec <= end; vec++) {
		if (vec == skip)
			continue;
d1384 1
a1384 2
	printf("intr_findvec(%d,%d,%d): no vector available\n",
	    start, end, skip);
d1410 1
a1410 2
			panic("intr_establish: there are other handlers with "
			    "vec (0x%x) at ipl %x, but you want it at %x",
d1445 2
a1446 1
const unsigned int obio_vec[32] = {
d1537 1
a1537 1
			vec = SYSCON_VECT + obio_vec[intbit];
d1543 1
a1543 1
			vec = SYSCON_VECT + obio_vec[intbit];
d1892 32
d2309 3
a2311 2
	pmap_bootstrap((vaddr_t)trunc_page((unsigned)&kernelstart));

d2317 1
a2317 1
	    atop(avail_start), atop(avail_end), VM_FREELIST_DEFAULT);
@


1.17
log
@Added to support MVME188 and MVME197
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.16 1999/09/03 18:01:30 art Exp $	*/
d1830 1
a1830 1
      ipv6intr();
@


1.16
log
@Change the pmap_enter api to pass down an argument that indicates
the access type that caused this mapping. This is to simplify pmaps
with mod/ref emulation (none for the moment) and in some cases speed
up pmap_is_{referenced,modified}.
At the same time, clean up some mappings that had too high protection.

XXX - the access type is incorrect in old vm, it's only used by uvm and MD code.
The actual use of this in pmap_enter implementations is not in this commit.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.15 1999/05/29 04:41:46 smurph Exp $	*/
d3 1
a3 1
 * Copyright (c) 1998 Steve Murphree, Jr.
d65 1
a65 1
#include <sys/msg.h>
d68 1
a68 1
#include <sys/sem.h>
d71 1
a71 1
#include <sys/shm.h>
d79 1
d82 2
a84 2
#include <machine/psl.h>
#include <machine/board.h>
d100 1
a100 1
#  include <machine/db_machdep.h>
d104 1
a104 1
#define DEBUG_MSG db_printf
d106 1
a106 1
#define DEBUG_MSG printf
d111 9
d122 9
d132 10
a141 8
	(unsigned char *)0xFFFE0003, /* not used, no such thing as int 0 */
	(unsigned char *)0xFFFE0007,
	(unsigned char *)0xFFFE000B,
	(unsigned char *)0xFFFE000F,
	(unsigned char *)0xFFFE0013,
	(unsigned char *)0xFFFE0017,
	(unsigned char *)0xFFFE001B,
	(unsigned char *)0xFFFE001F,
d143 1
d151 2
a155 3
volatile vm_offset_t vmea16va;
volatile vm_offset_t vmea32d16va;

d157 2
a158 2
int physmem;		/* available physical memory, in pages */
int cold;
d161 2
a162 2
int foodebug = 0;
int longformat = 1;
a169 1
#if 1 /*XXX_FUTURE*/
d173 2
a174 2
 * XXX none of the drivers use this at this time. IO address is mapped
 * so that pa == va. XXX nivas
d176 1
a176 1
vm_offset_t iomapbase;
d179 1
a179 2
int	   niomap;
#endif
d184 1
a184 1
int	nswbuf = 0;
d186 1
a186 1
int	nbuf = NBUF;
d188 1
a188 1
int	nbuf = 0;
d191 1
a191 1
int	bufpages = BUFPAGES;
d193 1
a193 1
int	bufpages = 0;
d198 1
a198 1
  
d202 4
a205 3
char	machine[] = "mvme88k";		/* cpu "architecture" */
char	cpu_model[120];
extern	char version[];
d208 10
a217 10
struct kernel{
	void *entry;
	void *symtab;
	void *esym;
	int   bflags;
	int   bdev;
	char *kname;
	void *smini;
	void *emini;
	void *end_load;
d221 2
a222 1
int boothowto;	/* read in kern/bootstrap */
d224 1
a224 1
int cpuspeed = 25;	/* 25 MHZ XXX should be read from NVRAM */
d227 1
a227 1
#define roundup(value, stride) (((unsigned)(value) + (stride) - 1) & ~((stride)-1))
d230 13
a242 16
vm_size_t	mem_size;
vm_size_t	rawmem_size;
vm_offset_t	first_addr = 0;
vm_offset_t	last_addr = 0;

vm_offset_t	avail_start, avail_next, avail_end;
vm_offset_t	virtual_avail, virtual_end;
vm_offset_t	pcc2consvaddr, clconsvaddr;
vm_offset_t	miniroot;

void		*end_loaded;
int		bootdev;
int		no_symbols = 1;

struct proc	*lastproc;
pcb_t		curpcb;
d244 2
a246 2
extern void *etherbuf;
extern int etherlen;
d248 14
a261 14
/* XXX this is to fake out the console routines, while booting. */
#include "bugtty.h"
#if NBUGTTY > 0
    int bugttycnprobe __P((struct consdev *));
    int bugttycninit __P((struct consdev *));
    void bugttycnputc __P((dev_t, int));
    int bugttycngetc __P((dev_t));
    extern void nullcnpollc __P((dev_t, int));
    static struct consdev bugcons =
		{ NULL, NULL, bugttycngetc, bugttycnputc,
		    nullcnpollc, makedev(14,0), 1 };
#endif /* NBUGTTY */

void	cmmu_init(void);
d270 4
a273 4
	extern struct consdev *cn_tab;
	/*
	 * Initialize the console before we print anything out.
	 */
d275 2
a276 2
	cn_tab = NULL;
	cninit();
d279 3
a281 3
        kdb_init();
        if (boothowto & RB_KDB)
                Debugger();
d293 3
a295 3
    volatile unsigned int *look;
    unsigned int *max;
    extern char *end;
d299 12
a310 12

    /*
     * count it up.
     */
    max = (void*)MAXPHYSMEM;
    for (look = (void*)Roundup(end, STRIDE); look < max;
			look = (int*)((unsigned)look + STRIDE)) {
	unsigned save;

	/* if can't access, we've reached the end */
	if (foodebug) printf("%x\n", look);
	if (badwordaddr((vm_offset_t)look)) {
d312 1
a312 1
		printf("%x\n", look);
d314 21
a334 19
		look = (int *)((int)look - STRIDE);
		break;
	}

	/*
	 * If we write a value, we expect to read the same value back.
	 * We'll do this twice, the 2nd time with the opposite bit
	 * pattern from the first, to make sure we check all bits.
	 */
	save = *look;
	if (*look = PATTERN, *look != PATTERN)
		break;
	if (*look = ~PATTERN, *look != ~PATTERN)
		break;
	*look = save;
    }

    physmem = btoc(trunc_page((unsigned)look));	/* in pages */
    return(trunc_page((unsigned)look));
d340 12
a351 12
    struct bugbrdid brdid;
    int speed = 0;
    int i, c;
    bugbrdid(&brdid);
    for (i=0; i<4; i++){
        c=(unsigned char)brdid.speed[i];
        c-= '0';
        speed *=10;
        speed +=c;
    }
    speed = speed / 100;
    return(speed);
d357 12
a368 11
    struct bugbrdid brdid;
    int scsiid = 0;
    int i, c;
    bugbrdid(&brdid);
    for (i=0; i<2; i++){
        c=(unsigned char)brdid.scsiid[i];
        c-= '0';
        scsiid *=10;
        scsiid +=c;
    }
    return(7);
d374 3
a376 3
    cpuspeed = getcpuspeed();
    sprintf(cpu_model, "Motorola MVME%x %dMhz", cputyp, cpuspeed);
    printf("\nModel: %s\n", cpu_model);
d379 1
a379 1
/* The following two functions assume UPAGES == 3 */
d381 1
a381 1
#error "UPAGES changed?"
d385 1
a385 1
#error "USPACE changed?"
d396 3
a398 3
	for (i=0; i<UPAGES; i++) {
		p->p_md.md_upte[i] = kvtopte(va + (i * NBPG))->bits;
	}
d404 10
a413 10
    pte_template_t *t;
	 
	int i; 
	for (i=0; i<UPAGES; i++) {
		t = kvtopte(UADDR + (i * NBPG));
		t->bits = p->p_md.md_upte[i];
	}
	for (i=0; i<UPAGES; i++) {
		cmmu_flush_tlb(1, UADDR + (i * NBPG), NBPG);
	}
d416 34
d453 10
a462 10
	caddr_t v;
	int sz, i;
	vm_size_t size;    
	int base, residual;
	vm_offset_t minaddr, maxaddr, uarea_pages;
	extern vm_offset_t miniroot;
	/*
	 * Initialize error message buffer (at end of core).
	 * avail_end was pre-decremented in m1x7_bootstrap().
	 */
d464 2
a465 2
	for (i = 0; i < btoc(sizeof(struct msgbuf)); i++)
		pmap_enter(kernel_pmap, (vm_offset_t)msgbufp,
d469 119
a587 1
	msgbufmapped = 1;
d589 32
a620 69
	printf(version);
	identifycpu();
	printf("real mem  = %d\n", ctob(physmem));
	
	/*
	 * Find out how much space we need, allocate it,
	 * and then give everything true virtual addresses.
	 */
	sz = (int)allocsys((caddr_t)0);
	if ((v = (caddr_t)kmem_alloc(kernel_map, round_page(sz))) == 0)
		panic("startup: no room for tables");
	if (allocsys(v) - v != sz)
		panic("startup: table size inconsistency");

	/*
	 * Grab UADDR virtual address
	 */
	
	uarea_pages = UADDR;

	vm_map_find(kernel_map, vm_object_allocate(USPACE), 0,
		(vm_offset_t *)&uarea_pages, USPACE, TRUE);

	if (uarea_pages != UADDR) {
		printf("uarea_pages %x: UADDR not free\n", uarea_pages);
		panic("bad UADDR");
	}

	/*
	 * Grab the BUGROM space that we hardwired in pmap_bootstrap
	 */

	bugromva = BUGROM_START;

	vm_map_find(kernel_map, vm_object_allocate(BUGROM_SIZE), 0,
		(vm_offset_t *)&bugromva, BUGROM_SIZE, TRUE);

	if (bugromva != BUGROM_START) {
		printf("bugromva %x: BUGROM not free\n", bugromva);
		panic("bad bugromva");
	}

	/*
	 * Grab the SRAM space that we hardwired in pmap_bootstrap
	 */

	sramva = SRAM_START;

	vm_map_find(kernel_map, vm_object_allocate(SRAM_SIZE), 0,
		(vm_offset_t *)&sramva, SRAM_SIZE, TRUE);

	if (sramva != SRAM_START) {
		printf("sramva %x: SRAM not free\n", sramva);
		panic("bad sramva");
	}

	/*
	 * Grab the OBIO space that we hardwired in pmap_bootstrap
	 */

	obiova = OBIO_START;

	vm_map_find(kernel_map, vm_object_allocate(OBIO_SIZE), 0,
		(vm_offset_t *)&obiova, OBIO_SIZE, TRUE);

	if (obiova != OBIO_START) {
		printf("obiova %x: OBIO not free\n", obiova);
		panic("bad OBIO");
	}
d622 8
a629 1
#if 0
d631 8
a638 2
	 * Grab the EXTIO space that we hardwired in pmap_bootstrap
	 */
d640 11
a650 1
	extiova = IOMAP_MAP_START;
d652 14
a665 2
	vm_map_find(kernel_map, vm_object_allocate(IOMAP_SIZE), 0,
		(vm_offset_t *)&extiova, IOMAP_SIZE, TRUE);
d667 4
a670 62
	if (extiova != IOMAP_MAP_START) {
		printf("extiova %x: EXTIO not free\n", extiova);
		panic("bad EXTIO");
	}
#endif 
	
	/*
	 * Now allocate buffers proper.  They are different than the above
	 * in that they usually occupy more virtual memory than physical.
	 */

	size = MAXBSIZE * nbuf;
	buffer_map = kmem_suballoc(kernel_map, (vm_offset_t *)&buffers,
			       &maxaddr, size, TRUE);
	minaddr = (vm_offset_t)buffers;
	if (vm_map_find(buffer_map, vm_object_allocate(size), (vm_offset_t)0,
		    (vm_offset_t *)&minaddr, size, FALSE) != KERN_SUCCESS) {
		panic("startup: cannot allocate buffers");
	}
	if ((bufpages / nbuf) >= btoc(MAXBSIZE)) {
		/* don't want to alloc more physical mem than needed */
		bufpages = btoc(MAXBSIZE) * nbuf;
	}
	base = bufpages / nbuf;
	residual = bufpages % nbuf;

	for (i = 0; i < nbuf; i++) {
		vm_size_t curbufsize;
		vm_offset_t curbuf;

		/*
		 * First <residual> buffers get (base+1) physical pages
		 * allocated for them.  The rest get (base) physical pages.
		 *
		 * The rest of each buffer occupies virtual space,
		 * but has no physical memory allocated for it.
		 */
		curbuf = (vm_offset_t)buffers + i * MAXBSIZE;
		curbufsize = CLBYTES * (i < residual ? base+1 : base);

		/* this faults in the required physical pages */
		vm_map_pageable(buffer_map, curbuf, curbuf+curbufsize, FALSE);

		vm_map_simplify(buffer_map, curbuf);
	}

	/*
	 * Allocate a submap for exec arguments.  This map effectively
	 * limits the number of processes exec'ing at any time.
	 */
	exec_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr,
			     16*NCARGS, TRUE);

	/*
	 * Allocate map for physio.
	 */

	phys_map = vm_map_create(kernel_pmap, PHYSIO_MAP_START,
		PHYSIO_MAP_START + PHYSIO_MAP_SIZE, TRUE);
	if (phys_map == NULL) {
		panic("cpu_startup: unable to create phys_map");
	}
d672 4
a675 67
#if 1 /*XXX_FUTURE*/
	iomap_map = vm_map_create(kernel_pmap, IOMAP_MAP_START,
			IOMAP_MAP_START + IOMAP_SIZE, TRUE);
	if (iomap_map == NULL) {
		panic("cpu_startup: unable to create iomap_map");
	}

	/*
	 * Allocate space from iomap for a (privately managed) pool
	 * of addresses for IO mappings.
	 */

	iomapbase = kmem_alloc_wait(iomap_map, IOMAP_SIZE);
	rminit(iomap, IOMAP_SIZE, (u_long)iomapbase, "iomap", niomap);
#endif

	/*
	 * Finally, allocate mbuf pool.  Since mclrefcnt is an off-size
	 * we use the more space efficient malloc in place of kmem_alloc.
	 */
	mclrefcnt = (char *)malloc(NMBCLUSTERS+CLBYTES/MCLBYTES,
			       M_MBUF, M_NOWAIT);
	bzero(mclrefcnt, NMBCLUSTERS+CLBYTES/MCLBYTES);
	mb_map = kmem_suballoc(kernel_map, (vm_offset_t *)&mbutl, &maxaddr,
			   VM_MBUF_SIZE, FALSE);

	/*
	 * Initialize callouts
	 */
	callfree = callout;
	for (i = 1; i < ncallout; i++)
	callout[i-1].c_next = &callout[i];
	callout[i-1].c_next = NULL;

	printf("avail mem = %d\n", ptoa(cnt.v_free_count));
	printf("using %d buffers containing %d bytes of memory\n",
	   nbuf, bufpages * CLBYTES);

#ifdef MFS
	/*
	 * Check to see if a mini-root was loaded into memory. It resides
	 * at the start of the next page just after the end of BSS.
	 */
	{
		extern void *smini;

		if (miniroot && (boothowto & RB_MINIROOT)) {
			boothowto |= RB_DFLTROOT;
			mfs_initminiroot(miniroot);
		}
	}
#endif

	/*
	 * Set up buffers, so they can be used to read disk labels.
	 */
	bufinit();

	/*
	 * Configure the system.
	 */
	nofault = NULL;

	/*
	 * zero out intr_handlers
	 */
	bzero((void *)intr_handlers, 256 * sizeof(struct intrhand *));
d677 6
a682 1
	configure();
d696 1
a696 1
	register caddr_t v;
d703 1
a703 1
	valloc(cfree, struct cblock, nclist);
d705 4
a708 1
	valloc(callout, struct callout, ncallout);
d710 1
a710 1
	valloc(shmsegs, struct shmid_ds, shminfo.shmmni);
d713 4
a716 4
	valloc(sema, struct semid_ds, seminfo.semmni);
	valloc(sem, struct sem, seminfo.semmns);
	/* This is pretty disgusting! */
	valloc(semu, int, (seminfo.semmnu * seminfo.semusz) / sizeof(int));
d719 28
a746 28
	valloc(msgpool, char, msginfo.msgmax);
	valloc(msgmaps, struct msgmap, msginfo.msgseg);
	valloc(msghdrs, struct msg, msginfo.msgtql);
	valloc(msqids, struct msqid_ds, msginfo.msgmni);
#endif

	/*
	 * Determine how many buffers to allocate (enough to
	 * hold 5% of total physical memory, but at least 16).
	 * Allocate 1/2 as many swap buffer headers as file i/o buffers.
	 */
	if (bufpages == 0)
	    if (physmem < btoc(2 * 1024 * 1024))
		bufpages = (physmem / 10) / CLSIZE;
	    else
		bufpages = (physmem / 20) / CLSIZE;
	if (nbuf == 0) {
		nbuf = bufpages;
		if (nbuf < 16)
			nbuf = 16;
	}
	if (nswbuf == 0) {
		nswbuf = (nbuf / 2) &~ 1;	/* force even */
		if (nswbuf > 256)
			nswbuf = 256;		/* sanity */
	}
	valloc(swbuf, struct buf, nswbuf);
	valloc(buf, struct buf, nbuf);
d749 5
a753 5
	/*
	 * Arbitrarily limit the number of devices mapping
	 * the IO space at a given time to NIOPMAP (= 32, default).
	 */
	valloc(iomap, struct map, niomap = NIOPMAP);
d755 1
a755 1
	return v;
d762 3
d767 4
a770 4
	struct proc *p;
	struct exec_package *pack;
	u_long stack;
	int retval[2];
d772 1
a772 1
	register struct trapframe *tf = USER_REGS(p);
d775 1
a775 1
	printf("%x - %x\n", USRSTACK - MAXSSIZ, USRSTACK);
d777 6
a782 6
	/*
	 * The syscall will ``return'' to snip; set it.
	 * argc, argv, envp are placed on the stack by copyregs.
	 * Point r2 to the stack. crt0 should extract envp from
	 * argc & argv before calling user's main.
	 */
d784 19
a802 19
	/*
	 * I don't think I need to mess with fpstate on 88k because
	 * we make sure the floating point pipeline is drained in
	 * the trap handlers. Should check on this later. XXX Nivas.
	 */

	if ((fs = p->p_md.md_fpstate) != NULL) {
		/*
		 * We hold an FPU state.  If we own *the* FPU chip state
		 * we must get rid of it, and the only way to do that is
		 * to save it.  In any case, get rid of our FPU state.
		 */
		if (p == fpproc) {
			savefpstate(fs);
			fpproc = NULL;
		}
		free((void *)fs, M_SUBPROC);
		p->p_md.md_fpstate = NULL;
	}
d804 2
a805 2
	bzero((caddr_t)tf, sizeof *tf);
	tf->epsr = 0x3f0;  /* user mode, interrupts enabled, fp enabled */
d808 13
a820 13
	/*
	 * We want to start executing at pack->ep_entry. The way to
	 * do this is force the processor to fetch from ep_entry. Set
	 * NIP to something bogus and invalid so that it will be a NOOP.
	 * And set sfip to ep_entry with valid bit on so that it will be
	 * fetched.
	 */

	tf->snip = pack->ep_entry & ~3;
	tf->sfip = (pack->ep_entry & ~3) | FIP_V;
	tf->r[2] = stack;
	tf->r[31] = stack;
	retval[1] = 0;
d824 2
a825 2
	int	ss_flags;		/* which of the following are valid */
	struct 	trapframe ss_frame;	/* original exception frame */
d833 6
a838 6
	int	sf_signo;		/* signo for handler */
	siginfo_t *sf_sip;
	struct	sigcontext *sf_scp;	/* context ptr for handler */
	sig_t	sf_handler;		/* handler addr for u_sigc */
	struct	sigcontext sf_sc;	/* actual context */
	siginfo_t sf_si;
d844 3
a846 3
#define SDB_FOLLOW	0x01
#define SDB_KSTACK	0x02
#define SDB_FPSTATE	0x04
d852 1
d855 14
a868 14
	sig_t catcher;
	int sig, mask;
	unsigned long code;
	int type;
	union sigval val;
{
	register struct proc *p = curproc;
	register struct trapframe *tf;
	register struct sigacts *psp = p->p_sigacts;
	struct sigframe *fp;
	int oonstack, fsize;
	struct sigframe sf;
	int addr;
	extern char sigcode[], esigcode[];
d872 20
a891 20
	tf = p->p_md.md_tf;
	oonstack = psp->ps_sigstk.ss_flags & SA_ONSTACK;
	/*
	 * Allocate and validate space for the signal handler
	 * context. Note that if the stack is in data space, the
	 * call to grow() is a nop, and the copyout()
	 * will fail if the process has not already allocated
	 * the space with a `brk'.
	 */
	fsize = sizeof(struct sigframe);
	if ((psp->ps_flags & SAS_ALTSTACK) &&
	    (psp->ps_sigstk.ss_flags & SA_ONSTACK) == 0 &&
	    (psp->ps_sigonstack & sigmask(sig))) {
		fp = (struct sigframe *)(psp->ps_sigstk.ss_sp +
					 psp->ps_sigstk.ss_size - fsize);
		psp->ps_sigstk.ss_flags |= SA_ONSTACK;
	} else
		fp = (struct sigframe *)(tf->r[31] - fsize);
	if ((unsigned)fp <= USRSTACK - ctob(p->p_vmspace->vm_ssize)) 
		(void)grow(p, (unsigned)fp);
d893 73
a965 73
	if ((sigdebug & SDB_FOLLOW) ||
	    (sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
		printf("sendsig(%d): sig %d ssp %x usp %x scp %x\n",
		       p->p_pid, sig, &oonstack, fp, &fp->sf_sc);
#endif
	/*
	 * Build the signal context to be used by sigreturn.
	 */
	sf.sf_signo = sig;
	sf.sf_scp = &fp->sf_sc;
	sf.sf_handler = catcher;
	sf.sf_sc.sc_onstack = oonstack;
	sf.sf_sc.sc_mask = mask;

	if (psp->ps_siginfo & sigmask(sig)) {
		sf.sf_sip = &fp->sf_si;
		initsiginfo(&sf.sf_si, sig, code, type, val);
	}


	/*
	 * Copy the whole user context into signal context that we
	 * are building.
	 */
	bcopy((caddr_t)tf->r, (caddr_t)sf.sf_sc.sc_regs,
		 sizeof(sf.sf_sc.sc_regs));
	sf.sf_sc.sc_xip = tf->sxip & ~3;
	sf.sf_sc.sc_nip = tf->snip & ~3;
	sf.sf_sc.sc_fip = tf->sfip & ~3;
	sf.sf_sc.sc_ps = tf->epsr;
	sf.sf_sc.sc_sp  = tf->r[31];
	sf.sf_sc.sc_fpsr = tf->fpsr;
	sf.sf_sc.sc_fpcr = tf->fpcr;
	sf.sf_sc.sc_ssbr = tf->ssbr;
	sf.sf_sc.sc_dmt0 = tf->dmt0;
	sf.sf_sc.sc_dmd0 = tf->dmd0;
	sf.sf_sc.sc_dma0 = tf->dma0;
	sf.sf_sc.sc_dmt1 = tf->dmt1;
	sf.sf_sc.sc_dmd1 = tf->dmd1;
	sf.sf_sc.sc_dma1 = tf->dma1;
	sf.sf_sc.sc_dmt2 = tf->dmt2;
	sf.sf_sc.sc_dmd2 = tf->dmd2;
	sf.sf_sc.sc_dma2 = tf->dma2;
	sf.sf_sc.sc_fpecr = tf->fpecr;
	sf.sf_sc.sc_fphs1 = tf->fphs1;
	sf.sf_sc.sc_fpls1 = tf->fpls1;
	sf.sf_sc.sc_fphs2 = tf->fphs2;
	sf.sf_sc.sc_fpls2 = tf->fpls2;
	sf.sf_sc.sc_fppt = tf->fppt;
	sf.sf_sc.sc_fprh = tf->fprh;
	sf.sf_sc.sc_fprl = tf->fprl;
	sf.sf_sc.sc_fpit = tf->fpit;
	if (copyout((caddr_t)&sf, (caddr_t)fp, sizeof sf)) {
		/*
		 * Process has trashed its stack; give it an illegal
		 * instruction to halt it in its tracks.
		 */
		SIGACTION(p, SIGILL) = SIG_DFL;
		sig = sigmask(SIGILL);
		p->p_sigignore &= ~sig;
		p->p_sigcatch &= ~sig;
		p->p_sigmask &= ~sig;
		psignal(p, SIGILL);
		return;
	}
	/* 
	 * Build the argument list for the signal handler.
	 * Signal trampoline code is at base of user stack.
	 */
	addr = (int)PS_STRINGS - szsigcode;
	tf->snip = (addr & ~3) | NIP_V;
	tf->sfip = (tf->snip + 4) | FIP_V;
	tf->r[31] = (unsigned)fp;
d967 3
a969 4
	if ((sigdebug & SDB_FOLLOW) ||
	    (sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
		printf("sendsig(%d): sig %d returns\n",
		       p->p_pid, sig);
d984 3
d988 11
a998 11
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_sigreturn_args /* {
		syscallarg(struct sigcontext *) sigcntxp;
	} */ *uap = v;
	register struct sigcontext *scp;
	register struct trapframe *tf;
	struct sigcontext ksc;
	int error;
d1000 1
a1000 1
	scp = (struct sigcontext *)SCARG(uap, sigcntxp);
d1002 2
a1003 2
	if (sigdebug & SDB_FOLLOW)
		printf("sigreturn: pid %d, scp %x\n", p->p_pid, scp);
d1005 10
a1014 10
	if ((int)scp & 3 || useracc((caddr_t)scp, sizeof *scp, B_WRITE) == 0 ||
		copyin((caddr_t)scp, (caddr_t)&ksc, sizeof(struct sigcontext)))
		return (EINVAL);

	tf = p->p_md.md_tf;
	scp = &ksc;
	/*
	 * xip, nip and fip must be multiples of 4.  This is all
	 * that is required; if it holds, just do it.
	 */
d1016 2
a1017 2
	if (((scp->sc_xip | scp->sc_nip | scp->sc_fip) & 3) != 0)
		return (EINVAL);
d1019 48
a1066 50
	if (((scp->sc_xip | scp->sc_nip | scp->sc_fip) & 3) != 0)
		printf("xip %x nip %x fip %x\n",
			scp->sc_xip, scp->sc_nip, scp->sc_fip);


	/*
	 * this can be improved by doing
	 *	 bcopy(sc_reg to tf, sizeof sigcontext - 2 words)
	 * XXX nivas
	 */

	bcopy((caddr_t)scp->sc_regs, (caddr_t)tf->r,
		 sizeof(scp->sc_regs));
	tf->sxip = (scp->sc_xip) | XIP_V;
	tf->snip = (scp->sc_nip) | NIP_V;
	tf->sfip = (scp->sc_fip) | FIP_V;
	tf->epsr = scp->sc_ps;
	tf->r[31] = scp->sc_sp;
	tf->fpsr = scp->sc_fpsr;
	tf->fpcr = scp->sc_fpcr;
	tf->ssbr = scp->sc_ssbr;
	tf->dmt0 = scp->sc_dmt0;
	tf->dmd0 = scp->sc_dmd0;
	tf->dma0 = scp->sc_dma0;
	tf->dmt1 = scp->sc_dmt1;
	tf->dmd1 = scp->sc_dmd1;
	tf->dma1 = scp->sc_dma1;
	tf->dmt2 = scp->sc_dmt2;
	tf->dmd2 = scp->sc_dmd2;
	tf->dma2 = scp->sc_dma2;
	tf->fpecr = scp->sc_fpecr;
	tf->fphs1 = scp->sc_fphs1;
	tf->fpls1 = scp->sc_fpls1;
	tf->fphs2 = scp->sc_fphs2;
	tf->fpls2 = scp->sc_fpls2;
	tf->fppt = scp->sc_fppt;
	tf->fprh = scp->sc_fprh;
	tf->fprl = scp->sc_fprl;
	tf->fpit = scp->sc_fpit;

	tf->epsr = scp->sc_ps;
	/*
	 * Restore the user supplied information
	 */
	if (scp->sc_onstack & 01)
		p->p_sigacts->ps_sigstk.ss_flags |= SA_ONSTACK;
	else
		p->p_sigacts->ps_sigstk.ss_flags &= ~SA_ONSTACK;
	p->p_sigmask = scp->sc_mask & ~sigcantmask;
	return (EJUSTRETURN);
d1071 2
a1072 2
	cmmu_shutdown_now();
	bugreturn();
d1077 40
a1116 1
	register int howto;
d1118 17
a1134 39
	/* take a snap shot before clobbering any registers */
	if (curproc)
		savectx(curproc->p_addr, 0);

	boothowto = howto;
	if ((howto & RB_NOSYNC) == 0 && waittime < 0) {

		extern struct proc proc0;

		/* protect against curproc->p_stats.foo refs in sync()   XXX */
		if (curproc == NULL)
			curproc = &proc0;

		waittime = 0;
		vfs_shutdown();

		/*
		 * If we've been adjusting the clock, the todr
		 * will be out of synch; adjust it now.
		 */
		resettodr();
	}
	splhigh();			/* extreme priority */
	if (howto & RB_HALT) {
		printf("halted\n\n");
		bugreturn();
	} else {
		if (howto & RB_DUMP)
			dumpsys();
		doboot();
		/*NOTREACHED*/
	}
	/*NOTREACHED*/
	while (1);  /* to keep compiler happy, and me from going crazy */
}

unsigned	dumpmag = 0x8fca0101;	/* magic number for savecore */
int	dumpsize = 0;		/* also for savecore */
long	dumplo = 0;
d1138 1
a1138 1
	int nblks;
d1140 14
a1153 14
	dumpsize = physmem;
	if (dumpdev != NODEV && bdevsw[major(dumpdev)].d_psize) {
		nblks = (*bdevsw[major(dumpdev)].d_psize)(dumpdev);
		if (dumpsize > btoc(dbtob(nblks - dumplo)))
			dumpsize = btoc(dbtob(nblks - dumplo));
		else if (dumplo == 0)
			dumplo = nblks - btodb(ctob(physmem));
	}
	/*
	 * Don't dump on the first CLBYTES (why CLBYTES?)
	 * in case the dump device includes a disk label.
	 */
	if (dumplo < btodb(CLBYTES))
		dumplo = btodb(CLBYTES);
d1163 35
a1197 36

	msgbufmapped = 0;
	if (dumpdev == NODEV)
		return;
	/*
	 * For dumps during autoconfiguration,
	 * if dump device has already configured...
	 */
	if (dumpsize == 0)
		dumpconf();
	if (dumplo < 0)
		return;
	printf("\ndumping to dev %x, offset %d\n", dumpdev, dumplo);
	printf("dump ");
	switch ((*bdevsw[major(dumpdev)].d_dump)(dumpdev)) {

	case ENXIO:
		printf("device bad\n");
		break;

	case EFAULT:
		printf("device not ready\n");
		break;

	case EINVAL:
		printf("area improper\n");
		break;

	case EIO:
		printf("i/o error\n");
		break;

	default:
		printf("succeeded\n");
		break;
	}
d1206 4
a1209 3
	register u_char *vaddr;
#ifdef XXX_FUTURE
	extern vm_offset_t iomap_mapin(vm_offset_t, vm_size_t,  boolean_t);
d1212 22
a1233 6
	/*
	 * map a page in for phys address 0xfffe0000 and set the
	 * addresses for various levels.
	 */
#ifdef XXX_FUTURE
	vaddr = (u_char *)iomap_mapin(0xfffe0000, NBPG, 1);
d1235 1
a1235 1
	vaddr = (u_char *)0xfffe0000;
d1237 39
a1275 18
#if 0
	(unsigned char *)0xFFFE0003, /* not used, no such thing as int 0 */
	(unsigned char *)0xFFFE0007,
	(unsigned char *)0xFFFE000B,
	(unsigned char *)0xFFFE000F,
	(unsigned char *)0xFFFE0013,
	(unsigned char *)0xFFFE0017,
	(unsigned char *)0xFFFE001B,
	(unsigned char *)0xFFFE001F,
#endif
	ivec[0] = vaddr + 0x03;
	ivec[1] = vaddr + 0x07;
	ivec[2] = vaddr + 0x0b;
	ivec[3] = vaddr + 0x0f;
	ivec[4] = vaddr + 0x13;
	ivec[5] = vaddr + 0x17;
	ivec[6] = vaddr + 0x1b;
	ivec[7] = vaddr + 0x1f;
d1281 4
a1284 1
 * of not conflicting with more normal users)
d1288 1
a1288 1
	int start, end;
d1290 2
a1291 2
	extern u_long *vector_list[], interrupt_handler, unknown_handler;
	int vec;
d1293 6
a1298 7
	if (start < 0 || end > 255 || start > end)
		return (-1);
	for (vec = end; vec > start; --vec)
		if (vector_list[vec] == &unknown_handler 
/*		 || vector_list[vec] == &interrupt_handler */)
			return (vec);
	return (-1);
d1302 3
a1304 4
 * Chain the interrupt handler in. But first check if the vector
 * offset chosen is legal. It either must be a badtrap (not allocated
 * for a `system' purpose), or it must be a hardtrap (ie. already
 * allocated to deal with chained interrupt handlers).
d1306 35
a1340 1
#if 0
d1342 1
a1342 26
int
intr_establish(vec, ih)
	int vec;
	struct intrhand *ih;
{
	extern u_long *vector_list[], interrupt_handler, unknown_handler;
	struct intrhand *ihx;

	if (vector_list[vec] != &interrupt_handler && vector_list[vec] != &unknown_handler) {
		printf("intr_establish: vec %d unavailable\n", vec);
		return (-1);
	}
	vector_list[vec] = &interrupt_handler;
#if DIAGNOSTIC
	printf("assigning vec %x to interrupt_handler\n", vec);
#endif
	ih->ih_next = NULL;	/* just in case */

	/* attach at tail */
	if (ihx = intr_handlers[vec]) {
		while (ihx->ih_next)
			ihx = ihx->ih_next;
		ihx->ih_next = ih;
	} else
		intr_handlers[vec] = ih;
	return (INTR_EST_SUCC);
d1345 2
a1346 1
#else
d1348 6
a1353 3
 * Insert ihand in the list of handlers at vector vec.
 * Return return different error codes for the different
 * errors and let the caller decide what to do.
d1356 10
a1365 2
int
intr_establish(int vec, struct intrhand *ihand)
d1367 132
a1498 1
	register struct intrhand *intr;
d1500 20
a1519 32
	if (vec < 0 || vec > 255) {
#if DIAGNOSTIC
		panic("intr_establish: vec (%x) not between 0 and 0xff",
			vec);
#endif /* DIAGNOSTIC */
		return (INTR_EST_BADVEC);
	}

	if (intr = intr_handlers[vec]) {
		if (intr->ih_ipl != ihand->ih_ipl) {
#if DIAGNOSTIC
			panic("intr_establish: there are other handlers with vec (%x) at ipl %x, but you want it at %x",
				intr->ih_ipl, vec, ihand->ih_ipl);
#endif /* DIAGNOSTIC */
			return (INTR_EST_BADIPL);
		}

		/*
		 * Go to the end of the chain
		 */
		while (intr->ih_next)
			intr = intr->ih_next;
	}

	ihand->ih_next = 0;

	if (intr)
		intr->ih_next = ihand;
	else
		intr_handlers[vec] = ihand;
	
	return (INTR_EST_SUCC);
d1521 2
a1522 1
#endif
d1525 1
a1525 1
 *	Device interrupt handler
d1533 1
d1535 1
a1535 1
ext_int(u_int v, struct m88100_saved_state *eframe)
d1537 91
a1627 111
	register u_char mask, level, xxxvec;
	register struct intrhand *intr;
	int ret;
	u_char vec;

	/* get level and mask */

	asm volatile("ld.b	%0,%1" : "=r" (mask) : "" (*pcc2intr_mask));
	asm volatile("ld.b	%0,%1" : "=r" (level) : "" (*pcc2intr_ipl));

	/*
	 * It is really bizarre for the mask and level to the be the same.
	 * pcc2 for 187 blocks all interrupts at and below the mask value,
	 * so we should not be getting an interrupt at the level that is
	 * already blocked. I can't explain this case XXX nivas
	 */

	if ((mask == level) && level) {
		printf("mask == level, %d\n", level);
		goto beatit;
	}

	/*
	 * Interrupting level cannot be 0--0 doesn't produce an interrupt.
	 * Weird! XXX nivas
	 */

	if (level == 0) {
		printf("Bogons... level %x and mask %x\n", level, mask);
		goto beatit;
	}

	/* and block interrupts at level or lower */
	setipl((u_char)level);
	/* and stash it away in the trap frame */
	eframe->mask = mask;
#if 0
	asm volatile("st.b	%1,%0" : "=m" (*pcc2intr_mask) :  "r" (level));
#endif
	if (level > 7 || (char)level < 0) {
		panic("int level (%x) is not between 0 and 7", level);
	}

	/* generate IACK and get the vector */

#if XXX
	asm volatile("ld.b 	%0,%1" : "=r" (vec) : "" (*ivec[level]));
	asm volatile("tb1	0, r0, 0");	
	asm volatile("tb1	0, r0, 0");	
	asm volatile("tb1	0, r0, 0");	

	asm volatile("tb1	0, r0, 0");	

	if (guarded_access(ivec[level], 1, &vec) == EFAULT) {
		printf("Unable to get vector for this interrupt (level %x)\n",
					level);
		goto out;
	}	
#endif XXX

	asm volatile("tb1	0, r0, 0");	
	if (guarded_access(ivec[level], 1, &vec) == EFAULT) {
		printf("Unable to get vector for this interrupt (level %x)\n",
					level);
		goto out;
	}
	asm volatile("tb1	0, r0, 0");	
	asm volatile("tb1	0, r0, 0");	
	asm volatile("tb1	0, r0, 0");	
	/*vec = xxxvec;*/

	if (vec > 0xFF) {
		panic("interrupt vector %x greater than 255", vec);
	}

	enable_interrupt();

	if ((intr = intr_handlers[vec]) == 0) {
		printf("Spurious interrupt (level %x and vec %x)\n",
			level, vec);
	}
	if (intr && intr->ih_ipl != level) {
		panic("Handler ipl %x not the same as level %x",
			intr->ih_ipl, level);
	}

	/*
	 * Walk through all interrupt handlers in the chain for the
	 * given vector, calling each handler in turn, till some handler
	 * returns a value != 0.
	 */

	for (ret = 0; intr; intr = intr->ih_next) {
		if (intr->ih_wantframe)
			ret = (*intr->ih_fn)(intr->ih_arg, (void *)eframe);
		else
			ret = (*intr->ih_fn)(intr->ih_arg);
		if (ret)
			break;
	}

	if (ret == 0) {
		printf("Unclaimed interrupt (level %x and vec %x)\n",
			level, vec);
	}

	/*
	 * process any remaining data access exceptions before
	 * returning to assembler
	 */
	disable_interrupt();
d1630 14
a1643 18
	if (eframe->dmt0 & DMT_VALID) {
		trap(T_DATAFLT, eframe);
		data_access_emulation(eframe);
		eframe->dmt0 &= ~DMT_VALID;
	}
	mask = eframe->mask;

	/*
	 * Restore the mask level to what it was when the interrupt
	 * was taken.
	 */
	setipl((u_char)mask);
#if 0
	asm volatile("st.b	%1,%0" : "=m" (*pcc2intr_mask) :  "r" (mask));
#endif
#if 0
	splx((u_char)mask);
#endif /* 0 */
d1646 1
a1646 1
	return;
d1648 1
d1651 2
a1652 2
	struct proc *p;
	struct exec_package *epp;
d1654 1
a1654 1
	return ENOEXEC;
d1658 16
a1673 16
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_sysarch_args /* {
		syscallarg(int) op;
		syscallarg(char *) parm;
	} */ *uap = v;
	int error = 0;

	switch((int)SCARG(uap, op)) {
	default:
		error = EINVAL;
		break;
	}
	return(error);
d1679 1
d1681 18
a1698 18
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
{

	/* all sysctl names are this level are terminal */
	if (namelen != 1)
		return (ENOTDIR);	/* overloaded */

	switch (name[0]) {
	default:
		return (EOPNOTSUPP);
	}
	/*NOTREACHED*/
d1707 1
a1707 1
	void *velement, *vhead;
d1709 7
a1715 7
	register struct prochd *element, *head;
	element = velement;
	head = vhead;
	element->ph_link = head->ph_link;
	head->ph_link = (struct proc *)element;
	element->ph_rlink = (struct proc *)head;
	((struct prochd *)(element->ph_link))->ph_rlink=(struct proc *)element;
d1724 1
a1724 1
	void *velement;
d1726 5
a1730 5
	register struct prochd *element;
	element = velement;
	((struct prochd *)(element->ph_link))->ph_rlink = element->ph_rlink;
	((struct prochd *)(element->ph_rlink))->ph_link = element->ph_link;
	element->ph_rlink = (struct proc *)0;
d1735 17
a1751 17
	const void *fromaddr;
        void *toaddr;
	size_t maxlength;
	size_t *lencopied;
{
	u_int tally;

	tally = 0;

	while (maxlength--) {
		*(u_char *)toaddr = *(u_char *)fromaddr++;
		tally++;
		if (*(u_char *)toaddr++ == 0) {
			if(lencopied) *lencopied = tally;
			return(0);
		}
	}
d1753 2
a1754 2
	if (lencopied)
		*lencopied = tally;
d1756 1
a1756 1
	return(ENAMETOOLONG);
d1761 1
a1761 1
	register struct proc *p;
d1763 12
a1774 12
	register struct prochd *q;
	register struct proc *oldlast;
	register int which = p->p_priority >> 2;

	if (p->p_back != NULL)
		panic("setrunqueue %x", p);
	q = &qs[which];
	whichqs |= 1 << which;
	p->p_forw = (struct proc *)q;
	p->p_back = oldlast = q->ph_rlink;
	q->ph_rlink = p;
	oldlast->p_forw = p;
d1783 1
a1783 1
	struct proc *vp;
d1785 12
a1796 12
	register struct proc *p = vp;
	register int which = p->p_priority >> 2;
	register struct prochd *q;

	if ((whichqs & (1 << which)) == 0)
		panic("remrq %x", p);
	p->p_forw->p_back = p->p_back;
	p->p_back->p_forw = p->p_forw;
	p->p_back = NULL;
	q = &qs[which];
	if (q->ph_link == (struct proc *)q)
		whichqs &= ~(1 << which);
d1807 1
a1807 1
	u_char *cp;
d1809 4
a1812 18
	struct bugniocall niocall;
        struct bugbrdid brdid;
	bugbrdid(&brdid);
	bcopy(&brdid.etheraddr, cp, 6);
/*
	niocall.clun = 0;
	niocall.dlun = 0;
	niocall.ci = 0;
	niocall.cd = 0;
	niocall.cid = NETCTRL_GETHDW;
	niocall.memaddr = (unsigned long)cp;
	niocall.nbytes = 6;
	bugnetctrl(&niocall);
*/

/*	if (cp[0] == '\0') {
	    strncpy(cp, cp2, 6);
	}    */
d1818 8
a1825 8
	if (netisr & (1 << NETISR_ARP)) {
		netisr &= ~(1 << NETISR_ARP);
		arpintr();
	}
	if (netisr & (1 << NETISR_IP)) {
		netisr &= ~(1 << NETISR_IP);
		ipintr();
	}
d1828 4
a1831 4
	if (netisr & (1 << NETISR_IPV6)) {
		netisr &= ~(1 << NETISR_IPV6);
		ipv6intr();
	}
d1834 4
a1837 4
	if (netisr & (1 << NETISR_ATALK)) {
		netisr &= ~(1 << NETISR_ATALK);
		atintr();
	}
d1840 4
a1843 4
	if (netisr & (1 << NETISR_NS)) {
		netisr &= ~(1 << NETISR_NS);
		nsintr();
	}
d1846 4
a1849 4
	if (netisr & (1 << NETISR_ISO)) {
		netisr &= ~(1 << NETISR_ISO);
		clnlintr();
	}
d1852 4
a1855 4
	if (netisr & (1 << NETISR_CCITT)) {
		netisr &= ~(1 << NETISR_CCITT);
		ccittintr();
	}
d1859 4
a1862 4
	if (netisr & (1 << NETISR_PPP)) {
		netisr &= ~(1 << NETISR_PPP);
		pppintr();
	}
d1866 4
a1869 4
	if (netisr & (1 << NETISR_BRIDGE)) {
		netisr &= ~(1 << NETISR_BRIDGE);
		bridgeintr();
	}
d1876 11
a1886 11
	if (ssir & SIR_NET) {
		siroff(SIR_NET);
		cnt.v_soft++;
		netintr();
	}

	if (ssir & SIR_CLOCK) {
		siroff(SIR_CLOCK);
		cnt.v_soft++;
		softclock();
	}
d1888 1
a1888 1
	return;
d1894 3
a1896 3
	int x;
	int level = 0;
	x = splsoftclock();
d1898 3
a1900 3
	if (ssir) {
		dosoftint();
	}
d1902 1
a1902 1
	setipl(0);
d1904 1
a1904 1
	return(x);
d1909 1
a1909 1
	return badaddr((vm_offset_t)addr, 4);
d1913 8
a1920 8
	struct trapframe 	*f;
	caddr_t 		p;
	int 			flags;
	char			*s;
{
	regdump(f);
	printf("proc %x flags %x type %s\n", p, flags, s);
}	
d1923 2
a1924 2
	struct trapframe	*f;
	int			flags;
d1926 2
a1927 2
	regdump(f);
}	
d1932 1
a1932 1
	struct m88100_saved_state *frame = framep;
d1935 2
a1936 2
	DEBUG_MSG("Abort Pressed\n");
	Debugger();
d1938 1
a1938 1
	DEBUG_MSG("Spurious NMI?\n");
d1945 72
a2016 46
    printf("R00-05: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	R(0),R(1),R(2),R(3),R(4),R(5));
    printf("R06-11: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	R(6),R(7),R(8),R(9),R(10),R(11));
    printf("R12-17: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	R(12),R(13),R(14),R(15),R(16),R(17));
    printf("R18-23: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	R(18),R(19),R(20),R(21),R(22),R(23));
    printf("R24-29: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	R(24),R(25),R(26),R(27),R(28),R(29));
    printf("R30-31: 0x%08x  0x%08x\n",R(30),R(31));
    printf("sxip %x snip %x sfip %x\n", f->sxip, f->snip, f->sfip);
    if (f->vector == 0x3) { /* print dmt stuff for data access fault */
	printf("dmt0 %x dmd0 %x dma0 %x\n", f->dmt0, f->dmd0, f->dma0);
	printf("dmt1 %x dmd1 %x dma1 %x\n", f->dmt1, f->dmd1, f->dma1);
	printf("dmt2 %x dmd2 %x dma2 %x\n", f->dmt2, f->dmd2, f->dma2);
    }
	if (longformat) {
		printf("fpsr %x ", f->fpsr);
		printf("fpcr %x ", f->fpcr);
		printf("epsr %x ", f->epsr);
		printf("ssbr %x\n", f->ssbr);
		printf("dmt0 %x ", f->dmt0);
		printf("dmd0 %x ", f->dmd0);
		printf("dma0 %x ", f->dma0);
		printf("dmt1 %x ", f->dmt1);
		printf("dmd1 %x ", f->dmd1);
		printf("dma1 %x ", f->dma1);
		printf("dmt2 %x ", f->dmt2);
		printf("dmd2 %x ", f->dmd2);
		printf("dma2 %x\n", f->dma2);
		printf("fpecr %x ", f->fpecr);
		printf("fphs1 %x ", f->fphs1);
		printf("fpls1 %x ", f->fpls1);
		printf("fphs2 %x ", f->fphs2);
		printf("fpls2 %x ", f->fpls2);
		printf("fppt %x ", f->fppt);
		printf("fprh %x ", f->fprh);
		printf("fprl %x ", f->fprl);
		printf("fpit %x\n", f->fpit);
		printf("vector %x ", f->vector);
		printf("mask %x ", f->mask);
		printf("mode %x ", f->mode);
		printf("scratch1 %x ", f->scratch1);
		printf("pad %x\n", f->pad);
	}
d2023 1
a2023 1
	return (db_setipl(IPL_HIGH));
d2029 1
a2029 1
	return (db_setipl(s));
d2041 1
a2041 1
m187_bootstrap(void)
d2043 9
a2051 7
    extern char version[];
    extern char *edata, *end;
    extern int cold;
    extern int kernelstart;
    extern vm_offset_t size_memory(void);
    extern struct consdev *cn_tab;
    struct bugbrdid brdid;
d2053 87
a2139 5
    cold = 1;	/* we are still booting */
#if NBUGTTY > 0
    cn_tab = &bugcons;
#endif
    buginit();
d2141 7
a2147 2
    bugbrdid(&brdid);
    cputyp = brdid.brdno;
d2149 2
a2150 1
    vm_set_page_size();
d2152 4
a2155 1
    first_addr = m88k_round_page(first_addr);
d2157 6
a2162 1
    if (!no_symbols) boothowto |= RB_KDB;
d2164 12
a2175 1
    last_addr = size_memory();
d2177 6
a2182 1
    cmmu_init();
d2184 6
a2189 5
    avail_start = first_addr;
    avail_end = last_addr;
    /*printf("%s",version);*/
    printf("M187 boot: memory from 0x%x to 0x%x\n", avail_start, avail_end);
    printf("M187 boot: howto 0x%x\n", boothowto);
d2191 10
a2200 30
    /*
     * Steal one page at the top of physical memory for msgbuf
     */
    avail_end -= PAGE_SIZE;

#if 1
    pmap_bootstrap((vm_offset_t)M88K_TRUNC_PAGE((unsigned)&kernelstart) /* = loadpt */, 
		   &avail_start, &avail_end, &virtual_avail,
		   &virtual_end);
#endif

    /*
     * Must initialize p_addr before autoconfig or
     * the fault handler will get a NULL reference.
     */
    proc0.p_addr = proc0paddr;
    curproc = &proc0;
    curpcb = &proc0paddr->u_pcb;

    /* Initialize cached PTEs for u-area mapping. */
    save_u_area(&proc0, (vm_offset_t)proc0paddr);

    /*
     * Map proc0's u-area at the standard address (UADDR).
     */
    load_u_area(&proc0);

    /* Initialize the "u-area" pages. */
    bzero((caddr_t)UADDR, UPAGES*NBPG);
    
@


1.15
log
@Added vme bus device drivers. MVME328, MVME376, MVME332
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.14 1999/05/24 23:09:05 jason Exp $	*/
d411 2
a412 1
			avail_end + i * NBPG, VM_PROT_ALL, TRUE);
@


1.14
log
@Only do basic work in the ethernet interrupt context, and queue packets to
be bridged.  Do the real work in a scheduled netisr.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.13 1999/05/22 21:22:27 weingart Exp $	*/
d131 3
d149 1
a149 1
#if 0 /*XXX_FUTURE*/
d203 1
a203 1
int cpuspeed = 33;	/* 25 MHZ XXX should be read from NVRAM */
a225 1

d227 2
d355 1
a355 1
	printf("\nModel: %s\n", cpu_model);
d359 1
a359 1
#if	UPAGES != 3
d384 1
a384 1

d389 1
a389 1
}
d484 7
d492 9
d558 1
a558 1
#if 0 /*XXX_FUTURE*/
d689 1
a689 1
#if 0 /*XXX_FUTURE*/
d1783 1
d1789 1
a1810 15

#if 0
    esym  = kflags.esym;
    boothowto = kflags.bflags;
    bootdev = kflags.bdev;
#endif /* 0 */
    
#if 0
    end_loaded = kflags.end_load;
    if (esym != NULL) {
    	end = (char *)((int)(kflags.symtab));
    } else {
    	first_addr = (vm_offset_t)&end;
    }
#endif
@


1.13
log
@Add new vm_swap code for dynamic swap.  From netbsd, munged some by me, and
others.   syscall commit pending.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.12 1999/04/11 03:26:28 smurph Exp $	*/
d1618 7
@


1.12
log
@Fix for 25 Mhz.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.11 1999/02/09 06:36:29 smurph Exp $	*/
a629 1
	valloc(swapmap, struct map, nswapmap = maxproc * 2);
@


1.11
log
@Added kernel support for user debugging.  Fixed file ID's
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.28 1995/04/19 22:37:27 smurph Exp $	*/
d86 1
d313 33
d349 2
a350 2
	/* XXX -take this one out. It can be done in m187_bootstrap() */
	strcpy(cpu_model, "Motorola M88K");
d370 4
a373 3
    p->p_md.md_upte[0] = kvtopte(va)->bits;
    p->p_md.md_upte[1] = kvtopte(va + NBPG)->bits;
    p->p_md.md_upte[2] = kvtopte(va + NBPG + NBPG)->bits;
d381 8
a388 9
    t = kvtopte(UADDR);
    t->bits = p->p_md.md_upte[0];
    t = kvtopte(UADDR + NBPG);
    t->bits = p->p_md.md_upte[1];
    t = kvtopte(UADDR + NBPG + NBPG);
    t->bits = p->p_md.md_upte[2];
    cmmu_flush_tlb(1, UADDR, NBPG);
    cmmu_flush_tlb(1, UADDR + NBPG, NBPG);
    cmmu_flush_tlb(1, UADDR + NBPG + NBPG, NBPG);
d1553 4
a1556 2
	char *cp2 = (char*) 0xFFC1F2C; /* BBRAM Ethernet hw addr */
	
a1563 1

d1565 1
@


1.10
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
@


1.9
log
@global decl for *intr() routines, plus add INET6
@
text
@d1178 1
a1178 1
		panic("intr_establish: vec (%x) not between 0 and 0xff\n",
d1187 1
a1187 1
			panic("intr_establish: there are other handlers with vec (%x) at ipl %x, but you want it at %x\n",
d1263 1
a1263 1
		panic("int level (%x) is not between 0 and 7\n", level);
d1295 1
a1295 1
		panic("interrupt vector %x greater than 255\n", vec);
d1305 1
a1305 1
		panic("Handler ipl %x not the same as level %x\n",
@


1.8
log
@Commit for the first working mvme88k port.
@
text
@d1547 6
@


1.7
log
@Add AppleTalk netisr. Only tested (indeed, only compiled) on mac68k port.
Add options NETATALK to your config to try it out.
@
text
@d2 1
d110 1
d136 2
a137 2
int longformat = 0;

d144 1
a144 1
#if XXX_FUTURE
d178 1
a178 1
char	machine[] = "MVME187";		/* cpu "architecture" */
d198 1
a198 1
int cpuspeed = 25;	/* 25 MHZ XXX should be read from NVRAM */
d225 8
a232 6
void bugttycnputc __P((dev_t, int));
int bugttycngetc __P((dev_t));
extern void nullcnpollc __P((dev_t, int));
void	cmmu_init(void);

static struct consdev bugcons =
d235 1
d237 1
a246 1

d250 1
d272 3
a274 3
    #define PATTERN   0x5a5a5a5a
    #define STRIDE    (4*1024) 	/* 4k at a time */
    #define Roundup(value, stride) (((unsigned)(value) + (stride) - 1) & ~((stride)-1))
d285 1
a285 2
	if (foodebug)
	printf("%x\n", look);
d316 1
a316 1
	printf("Model: %s\n", cpu_model);
a364 1

d503 1
a503 1
#if XXX_FUTURE
d541 15
a555 3
#if 0
	mfs_initminiroot(miniroot);
#endif /* 0 */
d635 1
a635 1
#if XXX_FUTURE
d658 3
d689 2
a690 1
	tf->epsr = 0x3f0; /* user mode, interrupts enabled, fp enabled */
d985 1
a985 1
	if (howto&RB_HALT) {
d995 1
d1087 10
a1096 1

d1108 58
d1209 1
d1518 2
a1519 1

d1525 1
a1525 1
	niocall.memaddr = (unsigned int)cp;
d1529 4
d1535 1
a1535 1
netintr()
a1602 1

d1670 3
a1672 3
		printf("fpsr %x", f->fpsr);
		printf("fpcr %x", f->fpcr);
		printf("epsr %x", f->epsr);
d1674 8
a1681 8
		printf("dmt0 %x", f->dmt0);
		printf("dmd0 %x", f->dmd0);
		printf("dma0 %x", f->dma0);
		printf("dmt1 %x", f->dmt1);
		printf("dmd1 %x", f->dmd1);
		printf("dma1 %x", f->dma1);
		printf("dmt2 %x", f->dmt2);
		printf("dmd2 %x", f->dmd2);
d1683 8
a1690 8
		printf("fpecr %x", f->fpecr);
		printf("fphs1 %x", f->fphs1);
		printf("fpls1 %x", f->fpls1);
		printf("fphs2 %x", f->fphs2);
		printf("fpls2 %x", f->fpls2);
		printf("fppt %x", f->fppt);
		printf("fprh %x", f->fprh);
		printf("fprl %x", f->fprl);
d1692 4
a1695 4
		printf("vector %x", f->vector);
		printf("mask %x", f->mask);
		printf("mode %x", f->mode);
		printf("scratch1 %x", f->scratch1);
d1731 1
a1731 1

d1733 1
a1733 1

d1758 1
a1758 2
    if (!no_symbols)
	boothowto |= RB_KDB;
d1766 1
a1766 1
    printf("%s",version);
d1768 1
d1775 1
a1778 2
#if defined(DEBUG)
    printf("returned from pmap_bootstrap\n");
d1799 1
a1799 3
#if defined(DEBUG)
    printf("returning from init\n");
#endif
@


1.6
log
@Cleanup after import. This also seems to bring up the current version.
@
text
@d1453 6
@


1.5
log
@This is a remove to get rid of the old mvme88k port which was incomplete
to replace it with a working version. The kernel compiles and works
at least.  The new version will be imported shortly.
@
text
@d2 30
a42 16
 * CARNEGIE MELLON AND OMRON ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON AND OMRON DISCLAIM ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */
/*
 * HISTORY
d51 1
a55 1
#include <sys/clist.h>
d59 1
d61 1
a61 8
#include <sys/ioctl.h>
#include <sys/tty.h>
#include <sys/mount.h>
#include <sys/user.h>
#include <sys/exec.h>
#include <sys/vnode.h>
#include <sys/sysctl.h>
#include <sys/errno.h>
d71 5
d77 1
a80 1
#include <machine/locore.h>
d99 5
a103 15
#if 0
#include <machine/m88100.h>  			/* DMT_VALID        */
#include <machine/m882xx.h>  			/* CMMU stuff       */
#include <vm/vm.h>
#include <vm/vm_kern.h>			  /* kernel_map       */
#include <sys/param.h>
#include <sys/msgbuf.h>
#include <sys/buf.h>
#include <machine/locore.h>		  /* USERMODE         */
/*
#include <machine/nvram.h>
*/
#include <sys/types.h>
#endif /* 0 */

d106 1
a106 8
static void level0_intr(int, unsigned *);
static void level1_intr(int, unsigned *);
static void level2_intr(int, unsigned *);
static void level3_intr(int, unsigned *);
static void level4_intr(int, unsigned *);
static void level5_intr(int, unsigned *);
static void level6_intr(int, unsigned *);
static void level7_intr(int, unsigned *);
d109 8
a116 7
	(unsigned char *)0xFFFE007,
	(unsigned char *)0xFFFE00B,
	(unsigned char *)0xFFFE00F,
	(unsigned char *)0xFFFE013,
	(unsigned char *)0xFFFE017,
	(unsigned char *)0xFFFE01B,
	(unsigned char *)0xFFFE01F,
d119 8
a126 11
static void (*int_handler[8])() =
{
    level0_intr,
    level1_intr,
    level2_intr,
    level3_intr,
    level4_intr,
    level5_intr,
    level6_intr,
    level7_intr,
};
a127 3
unsigned char *int_mask_level = (unsigned char *)INT_MASK_LEVEL;
unsigned char *int_pri_level = (unsigned char *)INT_PRI_LEVEL;
unsigned char *iackaddr;
d136 18
a153 3
extern char kstack[];	/* kernel stack - actually this is == UADDR */
extern char *cpu_string;
extern short exframesize[];
d180 53
a232 1
 /*
d240 1
d245 1
d265 1
a265 1
    extern char end[];
d282 1
d284 1
a288 1
#if 1
a299 1
#endif
d319 8
d346 3
a348 1
    cmmu_flush_tlb(1, UADDR, 3 * NBPG);
a350 1

d354 6
a359 6
    caddr_t v;
    int sz, i;
    vm_size_t size;    
    int base, residual;
    vm_offset_t minaddr, maxaddr, uarea_pages;
    extern vm_offset_t miniroot;
d361 24
a384 22
    /*
     * Initialize error message buffer (at end of core).
     * avail_end was pre-decremented in m1x7_init.
     */
     for (i = 0; i < btoc(sizeof(struct msgbuf)); i++)
         pmap_enter(kernel_pmap, (vm_offset_t)msgbufp,
             avail_end + i * NBPG, VM_PROT_ALL, TRUE);
     msgbufmapped = 1;

    printf(version);
    identifycpu();
    printf("real mem  = %d\n", ctob(physmem));
    
    /*
     * Find out how much space we need, allocate it,
     * and then give everything true virtual addresses.
     */
    sz = (int)allocsys((caddr_t)0);
    if ((v = (caddr_t)kmem_alloc(kernel_map, round_page(sz))) == 0)
	panic("startup: no room for tables");
    if (allocsys(v) - v != sz)
	panic("startup: table size inconsistency");
d386 3
a388 3
    /*
     * Grab UADDR virtual address
     */
d390 37
a426 1
    uarea_pages = UADDR;
d428 18
a445 2
    vm_map_find(kernel_map, vm_object_allocate(PAGE_SIZE * UPAGES), 0,
	(vm_offset_t *)&uarea_pages, PAGE_SIZE * UPAGES, TRUE);
d447 2
a448 10
    if (uarea_pages != UADDR) {
	printf("uarea_pages %x: UADDR not free\n", uarea_pages);
        panic("bad UADDR");
    }
    /*
     * Now allocate buffers proper.  They are different than the above
     * in that they usually occupy more virtual memory than physical.
     */
    size = MAXBSIZE * nbuf;
    buffer_map = kmem_suballoc(kernel_map, (vm_offset_t *)&buffers,
d450 31
a480 26
    minaddr = (vm_offset_t)buffers;
    if (vm_map_find(buffer_map, vm_object_allocate(size), (vm_offset_t)0,
		    (vm_offset_t *)&minaddr, size, FALSE) != KERN_SUCCESS)
	panic("startup: cannot allocate buffers");
    if ((bufpages / nbuf) >= btoc(MAXBSIZE)) {
	/* don't want to alloc more physical mem than needed */
	bufpages = btoc(MAXBSIZE) * nbuf;
    }
    base = bufpages / nbuf;
    residual = bufpages % nbuf;
    for (i = 0; i < nbuf; i++) {
	vm_size_t curbufsize;
	vm_offset_t curbuf;

	/*
	 * First <residual> buffers get (base+1) physical pages
	 * allocated for them.  The rest get (base) physical pages.
	 *
	 * The rest of each buffer occupies virtual space,
	 * but has no physical memory allocated for it.
	 */
	curbuf = (vm_offset_t)buffers + i * MAXBSIZE;
	curbufsize = CLBYTES * (i < residual ? base+1 : base);
	vm_map_pageable(buffer_map, curbuf, curbuf+curbufsize, FALSE);
	vm_map_simplify(buffer_map, curbuf);
    }
d482 5
a486 5
    /*
     * Allocate a submap for exec arguments.  This map effectively
     * limits the number of processes exec'ing at any time.
     */
    exec_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr,
d489 25
a513 7
    /*
     * Allocate a map for IO.
     */
    phys_map = vm_map_create(kernel_pmap, IO_SPACE_START,
			     IO_SPACE_END, TRUE);
    if (phys_map == NULL)
	panic("cpu_startup: unable to create physmap");
d515 5
a519 5
    /*
     * Finally, allocate mbuf pool.  Since mclrefcnt is an off-size
     * we use the more space efficient malloc in place of kmem_alloc.
     */
    mclrefcnt = (char *)malloc(NMBCLUSTERS+CLBYTES/MCLBYTES,
d521 2
a522 2
    bzero(mclrefcnt, NMBCLUSTERS+CLBYTES/MCLBYTES);
    mb_map = kmem_suballoc(kernel_map, (vm_offset_t *)&mbutl, &maxaddr,
d525 5
a529 5
    /*
     * Initialize callouts
     */
    callfree = callout;
    for (i = 1; i < ncallout; i++)
d531 1
a531 1
    callout[i-1].c_next = NULL;
d533 2
a534 2
    printf("avail mem = %d\n", ptoa(cnt.v_free_count));
    printf("using %d buffers containing %d bytes of memory\n",
d537 12
a548 5
    mfs_initminiroot(miniroot);
    /*
     * Set up buffers, so they can be used to read disk labels.
     */
    bufinit();
d550 4
a553 12
    /*
     * Configure the system.
     */
    nofault = NULL;
	if (boothowto & RB_CONFIG) {
#ifdef BOOT_CONFIG
		user_config();
#else
		printf("kernel does not support -c; continuing..\n");
#endif
	}
    configure();
d555 1
a555 1
    dumpconf();
d618 8
a632 1
/* ARGSUSED */
d640 1
a640 2
	register struct trapframe *tf = p->p_md.md_tf;
	register int psr;
d644 3
a646 2
	 * Set the rest of the registers to 0 except for r31 (stack pointer,
	 * built in exec()) and psr (supervisor bit).
a647 1
	psr = tf->epsr & PSR_SUPERVISOR_MODE_BIT;
d650 4
a653 4
	I don't think I need to mess with fpstate on 88k because
	we make sure the floating point pipeline is drained in
	locore.s. Should check on this later. Nivas.
	*/
d670 10
a679 1
	tf->epsr = psr;
d681 2
a682 1
	tf->sfip = tf->snip + 4;
d687 5
d693 1
a693 1
 * WARNING: code in locore.s assumes the layout shown for sf_signum
d698 1
a698 1
	int	sf_code;		/* additional info for handler */
d702 1
d717 1
a717 1
sendsig(catcher, sig, mask, code)
d721 2
a764 1
	sf.sf_code = code;
d766 1
d769 7
a779 1

d782 3
a784 3
	sf.sf_sc.sc_xip = tf->sxip;
	sf.sf_sc.sc_nip = tf->snip;
	sf.sf_sc.sc_fip = tf->sfip;
d808 1
a808 1
	if (copyout((caddr_t)&sf, (caddr_t)&fp, sizeof sf)) {
d826 2
a827 2
	tf->snip = addr & ~3;
	tf->sfip = tf->snip + 4;
d851 1
a851 1
	int *retval;
d861 1
a861 1
	scp = SCARG(uap, sigcntxp);
d866 2
a867 1
	if ((int)scp & 3 || useracc((caddr_t)scp, sizeof *scp, B_WRITE) == 0)
d869 1
d871 1
d876 1
d879 12
d893 3
a895 3
	tf->sxip = scp->sc_xip;
	tf->snip = scp->sc_nip;
	tf->sfip = scp->sc_fip;
a920 1

d928 1
a928 1
	p->p_sigmask = scp->sc_mask &~ sigcantmask;
d932 1
a932 45
void
bootsync(void)
{
	if (waittime < 0) {
		register struct buf *bp;
		int iter, nbusy;

		waittime = 0;
		(void) spl0();
		printf("syncing disks... ");
		/*
		 * Release vnodes held by texts before sync.
		 */
		if (panicstr == 0)
			vnode_pager_umount(NULL);
		sync(&proc0, (void *)NULL, (int *)NULL);

		for (iter = 0; iter < 20; iter++) {
			nbusy = 0;
			for (bp = &buf[nbuf]; --bp >= buf; )
				if ((bp->b_flags & (B_BUSY|B_INVAL)) == B_BUSY)
					nbusy++;
			if (nbusy == 0)
				break;
			printf("%d ", nbusy);
			delay(40000 * iter);
		}
		if (nbusy)
			printf("giving up\n");
		else
			printf("done\n");
		/*
		 * If we've been adjusting the clock, the todr
		 * will be out of synch; adjust it now unless
		 * the system was sitting in ddb.
		 */
		if ((howto & RB_TIMEBAD) == 0) {
			resettodr();
		} else {
			printf("WARNING: not updating battery clock\n");
		}
	}
}

doboot()
d934 1
d947 17
a963 2
	if ((howto&RB_NOSYNC) == 0)
		bootsync();
d1047 1
a1047 8
 * Return the best possible estimate of the time in the timeval
 * to which tvp points.  We do this by returning the current time
 * plus the amount of time since the last clock interrupt (clock.c:clkread).
 *
 * Check that this time is no less than any previously-reported time,
 * which could happen around the time of a clock adjustment.  Just for fun,
 * we guarantee that the time will be greater than the value obtained by a
 * previous call.
d1050 1
a1050 2
microtime(tvp)
	register struct timeval *tvp;
d1052 14
a1065 2
	int s = splhigh();
	static struct timeval lasttime;
d1067 27
a1093 5
	*tvp = time;
	tvp->tv_usec += clkread();
	while (tvp->tv_usec > 1000000) {
		tvp->tv_sec++;
		tvp->tv_usec -= 1000000;
d1095 15
a1109 5
	if (tvp->tv_sec == lasttime.tv_sec &&
	    tvp->tv_usec <= lasttime.tv_usec &&
	    (tvp->tv_usec = lasttime.tv_usec + 1) > 1000000) {
		tvp->tv_sec++;
		tvp->tv_usec -= 1000000;
d1111 9
a1119 2
	lasttime = *tvp;
	splx(s);
a1121 1
#ifdef PGINPROF
d1123 6
a1128 6
 * Return the difference (in microseconds)
 * between the  current time and a previous
 * time as represented  by the arguments.
 * If there is a pending clock interrupt
 * which has not been serviced due to high
 * ipl, return error code.
d1130 3
a1132 1
unsigned vmtime(int otime, int olbolt, int oicr)
d1134 6
a1139 3
    return ((time.tv_sec-otime)*60 + lbolt-olbolt)*16667;
}
#endif /* PGINPROF */
d1141 2
a1142 4
badwordaddr(void *addr)
{
	return badaddr((vm_offset_t)addr, 4);
}
d1144 6
a1149 5
/* returns positive if memory is not there; */
unsigned check_memory(void *addr, unsigned flag)
{
  return badaddr((vm_offset_t)addr, 1);
}
d1151 4
a1154 4
void start_clock(void)
{
	printf("Start clock\n");
}
d1156 4
a1159 5
static void
level0_intr(int level, unsigned *frame)
{
	printf("Spurious interrupt\n");
}
d1161 4
a1164 5
static void
level1_intr(int level, unsigned *frame)
{
	register char vec;
	iackaddr = ivec[level];
d1166 4
a1169 3
	/* generate IACK and get the vector */
	asm volatile ("ld.b %0,%1" : "=r" (vec) : "" (iackaddr));
}
d1171 5
a1175 5
static void
level1_intr(int level, unsigned *frame)
{
	register char vec;
	iackaddr = ivec[level];
a1177 3
	asm volatile ("ld.b %0,%1" : "=r" (vec) : "" (iackaddr));
}
#endif
d1179 25
a1203 5
static void
level2_intr(int level, unsigned *frame)
{
	iackaddr = ivec[level];
}
d1205 3
a1207 5
static void
level3_intr(int level, unsigned *frame)
{
	iackaddr = ivec[level];
}
d1209 1
a1209 5
static void
level4_intr(int level, unsigned *frame)
{
	iackaddr = ivec[level];
}
d1211 8
a1218 5
static void
level5_intr(int level, unsigned *frame)
{
	iackaddr = ivec[level];
}
d1220 5
a1224 6
static void
level6_intr(int level, unsigned *frame)
{
	register char vec;
	struct clockframe clkframe;
	iackaddr = ivec[level];
d1226 7
a1232 15
	/* generate IACK and get the vector */
	asm volatile("ld.b %0,%1" : "=r" (vec) : "" (iackaddr));
	switch (vec){
	case TIMER1IRQ:
		break;
	case TIMER2IRQ:
		/*
		 * build clockframe and pass to the clock
		 * interrupt handler
		 */
		clkframe.pc  = frame[EF_SXIP] & ~3;
		clkframe.sr  = frame[EF_EPSR];
		clkframe.ipl = frame[EF_MASK];
		clockintr(&clkframe);
		break;
a1233 1
}
d1235 4
a1238 5
static void
level7_intr(int level, unsigned *frame)
{
	iackaddr = ivec[level];
}
d1240 5
a1244 8
/*
 *	Device interrupt handler
 *
 *      when we enter, interrupts are disabled;
 *      when we leave, they should be disabled,
 *      but they need not be enabled throughout
 *      the routine.
 */
d1246 7
a1252 5
void
ext_int(unsigned vec, unsigned *eframe)
{
    register unsigned char mask, level;
    register int s;		/* XXX */
d1254 11
a1264 2
    asm volatile ("ld.b	%0,%1" : "=r" (mask) : "" (int_mask_level));
    asm volatile ("ld.b	%0,%1" : "=r" (level) : "" (int_pri_level));
d1266 2
a1267 29
    /* get the mask and stash it away in the trap frame */
    eframe[EF_MASK] = mask;
    /* and block ints level or lower */
    spln((char)mask);
    enable_interrupt();
    (*int_handler[level])(level,eframe);
    /*
     * process any remaining data access exceptions before
     * returning to assembler
     */
    disable_interrupt();
    if (eframe[EF_DMT0] && DMT_VALID)
    {
	trap(T_DATAFLT, eframe);
	data_access_emulation(eframe);
    }
    mask = eframe[EF_MASK];
    asm volatile ("st.b	%0,%1" : "=r" (mask) : "" (int_mask_level));
}

/*
 * check a word wide address.
 * write < 0 -> check for write access.
 * otherwise read.
 */
int wprobe(void *addr, unsigned int write)
{
    /* XXX only checking reads */
    return badaddr((vm_offset_t)addr, sizeof(int));
d1274 1
a1274 42
	int error = ENOEXEC;

#ifdef COMPAT_SUNOS
	extern sun_exec_aout_makecmds __P((struct proc *, struct exec_package *));
	if ((error = sun_exec_aout_makecmds(p, epp)) == 0)
		return 0;
#endif
	return error;
}

#if NOTYET
/*
 * nvram_read(BUF, ADDRESS, SIZE)
 * nvram_write(BUF, ADDRESS, SIZE)
 *
 * Read and write non-volatile RAM.
 * Only one byte from each word in the NVRAM area is accessable.
 * ADDRESS points to the virtual starting address, which is some address
 * after the nvram start (NVRAM_ADDR). SIZE refers to virtual size.
 */
void nvram_read(char *buf, vm_offset_t address, unsigned size)
{
    unsigned index = (unsigned)address - NVRAM_ADDR;
    unsigned char *source = (char*)(NVRAM_ADDR + index * 4);

    while (size-- > 0)
    {
        *buf++ = *source;
        source += 4; /* bump up to point to next readable byte */
    }
}

void nvram_write(char *buf, vm_offset_t address, unsigned size)
{
    unsigned index = (unsigned)address - NVRAM_ADDR;
    unsigned char *source = (char*)(NVRAM_ADDR + index * 4);

    while (size-- > 0)
    {
        *source = *buf++;
        source += 4; /* bump up to point to next readable byte */
    }
a1275 6
#endif /* NOTYET */

struct sysarch_args {
	int op;
	char *parms;
};
d1277 1
a1277 1
sysarch(p, uap, retval)
d1279 2
a1280 2
	register struct sysarch_args *uap;
	int *retval;
d1282 4
d1288 1
a1288 1
	switch(uap->op) {
d1323 5
a1327 2
#undef _insque
_insque(element, head)
d1329 2
a1330 1
{
d1340 5
a1344 2
#undef _remque
_remque(element)
d1346 1
a1346 1
{
d1352 6
a1357 6
#if 0
/*
 * Below written in C to allow access to debugging code
 */
copyinstr(fromaddr, toaddr, maxlength, lencopied) u_int *lencopied, maxlength;
	void *toaddr, *fromaddr;
d1359 1
a1359 1
	int c,tally;
d1362 1
d1364 3
a1366 2
		c = fubyte(fromaddr++);
		if (c == -1) {
a1367 6
			return(EFAULT);
		}
		tally++;
		*(char *)toaddr++ = (char) c;
		if (c == 0){
			if(lencopied) *lencopied = (u_int)tally;
d1371 4
a1374 1
	if(lencopied) *lencopied = (u_int)tally;
d1378 3
a1380 2
copyoutstr(fromaddr, toaddr, maxlength, lencopied) u_int *lencopied, maxlength;
	void *fromaddr, *toaddr;
d1382 13
a1394 2
	int c;
	int tally;
d1396 20
a1415 12
	tally = 0;
	while (maxlength--) {
		c = subyte(toaddr++, *(char *)fromaddr);
		if (c == -1) return(EFAULT);
		tally++;
		if (*(char *)fromaddr++ == 0){
			if(lencopied) *lencopied = tally;
			return(0);
		}
	}
	if(lencopied) *lencopied = tally;
	return(ENAMETOOLONG);
d1418 5
a1422 1
#endif /* 0 */
d1424 3
a1426 3
copystr(fromaddr, toaddr, maxlength, lencopied)
	u_int *lencopied, maxlength;
	void *fromaddr, *toaddr;
d1428 12
a1439 1
	u_int tally;
d1441 35
a1475 8
	tally = 0;
	while (maxlength--) {
		*(u_char *)toaddr = *(u_char *)fromaddr++;
		tally++;
		if (*(u_char *)toaddr++ == 0) {
			if(lencopied) *lencopied = tally;
			return(0);
		}
d1477 1
a1477 2
	if(lencopied) *lencopied = tally;
	return(ENAMETOOLONG);
d1481 1
a1481 1
putchar(char c)
d1483 13
a1495 1
	bugoutchr(c);
a1496 1
/* dummys for now */
d1498 2
a1499 1
bugsyscall()
d1501 10
a1510 1
}
d1512 1
a1512 2
mmrw()
{
d1515 1
a1515 1
netintr()
d1517 1
d1521 4
a1524 4
struct trapframe 	*f;
caddr_t 		p;
int 			flags;
char			*s;
d1531 2
a1532 2
struct trapframe	*f;
int			flags;
d1537 13
d1605 1
a1605 1
	return (db_spln(6));
d1611 1
a1611 1
	return (db_spln(s));
d1614 91
@


1.4
log
@do not call resettodr() if RB_TIMEBAD is set due to being in ddb with clock updates suspended
@
text
@@


1.3
log
@handle RB_CONFIG
@
text
@d783 2
a784 1
		 * will be out of synch; adjust it now.
d786 5
a790 1
		resettodr();
@


1.2
log
@ss_sp is correct, ss_base is not. noticed by agc@@sde.uts.amdahl.com; netbsd pr#1784
@
text
@d409 7
@


1.1
log
@moved from m88k directory
@
text
@d580 1
a580 1
		fp = (struct sigframe *)(psp->ps_sigstk.ss_base +
@


1.1.1.1
log
@Third try at importing the mvme88k port. This is a working kernel
from nivas.
Userland and compiler still need to be worked on.
Make certain what directory the import is done from.
@
text
@a1 30
 * Copyright (c) 1996 Nivas Madhur
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Nivas Madhur.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
/*
d13 16
a36 1
#include <sys/user.h>
d41 1
d45 3
d49 5
a53 2
#include <sys/msgbuf.h>
#include <sys/syscallargs.h>
a62 5
#include <sys/ioctl.h>
#include <sys/exec.h>
#include <sys/sysctl.h>
#include <sys/errno.h>
#include <net/netisr.h>
a63 1
#include <mvme88k/dev/pcctworeg.h>
d67 1
d86 15
a100 5
#if DDB
#define DEBUG_MSG db_printf
#else
#define DEBUG_MSG printf
#endif /* DDB */
d103 8
a110 1
struct intrhand *intr_handlers[256];
d113 7
a119 8
	(unsigned char *)0xFFFE0003, /* not used, no such thing as int 0 */
	(unsigned char *)0xFFFE0007,
	(unsigned char *)0xFFFE000B,
	(unsigned char *)0xFFFE000F,
	(unsigned char *)0xFFFE0013,
	(unsigned char *)0xFFFE0017,
	(unsigned char *)0xFFFE001B,
	(unsigned char *)0xFFFE001F,
d122 11
a132 8
u_char *int_mask_level = (u_char *)INT_MASK_LEVEL;
u_char *int_pri_level = (u_char *)INT_PRI_LEVEL;
u_char *iackaddr;
volatile u_char *pcc2intr_mask;
volatile u_char *pcc2intr_ipl;
volatile vm_offset_t bugromva;
volatile vm_offset_t sramva;
volatile vm_offset_t obiova;
d134 3
d145 3
a147 18
/*
 * safepri is a safe priority for sleep to set for a spin-wait
 * during autoconfiguration or after a panic.
 */
int   safepri = 0;

#if XXX_FUTURE
/*
 * iomap stuff is for managing chunks of virtual address space that
 * can be allocated to IO devices.
 * XXX none of the drivers use this at this time. IO address is mapped
 * so that pa == va. XXX nivas
 */
vm_offset_t iomapbase;
struct map *iomap;
vm_map_t   iomap_map;
int	   niomap;
#endif
d174 1
a174 53
struct bugenv bugargs;
struct kernel{
	void *entry;
	void *symtab;
	void *esym;
	int   bflags;
	int   bdev;
	char *kname;
	void *smini;
	void *emini;
	void *end_load;
}kflags;
char *esym;

int boothowto;	/* read in kern/bootstrap */
int cputyp;
int cpuspeed = 25;	/* 25 MHZ XXX should be read from NVRAM */

#ifndef roundup
#define roundup(value, stride) (((unsigned)(value) + (stride) - 1) & ~((stride)-1))
#endif /* roundup */

vm_size_t	mem_size;
vm_size_t	rawmem_size;
vm_offset_t	first_addr = 0;
vm_offset_t	last_addr = 0;

vm_offset_t	avail_start, avail_next, avail_end;
vm_offset_t	virtual_avail, virtual_end;
vm_offset_t	pcc2consvaddr, clconsvaddr;
vm_offset_t	miniroot;

void		*end_loaded;
int		bootdev;
int		no_symbols = 1;

struct proc	*lastproc;
pcb_t		curpcb;


extern struct user *proc0paddr;

/* XXX this is to fake out the console routines, while booting. */
void bugttycnputc __P((dev_t, int));
int bugttycngetc __P((dev_t));
extern void nullcnpollc __P((dev_t, int));
void	cmmu_init(void);

static struct consdev bugcons =
		{ NULL, NULL, bugttycngetc, bugttycnputc,
		    nullcnpollc, makedev(14,0), 1 };

/*
a181 1
	extern struct consdev *cn_tab;
a185 1
	cn_tab = NULL;
d205 1
a205 1
    extern char *end;
a221 1
#if defined(DEBUG)
a222 1
#endif
d227 1
d239 1
a258 8
#if	USPACE != (UPAGES * NBPG)
#error "USPACE changed?"
#endif

/*
 *	Setup u area ptes for u area double mapping.
 */

d278 1
a278 3
    cmmu_flush_tlb(1, UADDR, NBPG);
    cmmu_flush_tlb(1, UADDR + NBPG, NBPG);
    cmmu_flush_tlb(1, UADDR + NBPG + NBPG, NBPG);
d281 1
d285 6
a290 6
	caddr_t v;
	int sz, i;
	vm_size_t size;    
	int base, residual;
	vm_offset_t minaddr, maxaddr, uarea_pages;
	extern vm_offset_t miniroot;
d292 22
a313 4
	/*
	 * Initialize error message buffer (at end of core).
	 * avail_end was pre-decremented in m1x7_bootstrap().
	 */
d315 3
a317 23
	for (i = 0; i < btoc(sizeof(struct msgbuf)); i++)
		pmap_enter(kernel_pmap, (vm_offset_t)msgbufp,
			avail_end + i * NBPG, VM_PROT_ALL, TRUE);

	msgbufmapped = 1;

	printf(version);
	identifycpu();
	printf("real mem  = %d\n", ctob(physmem));
	
	/*
	 * Find out how much space we need, allocate it,
	 * and then give everything true virtual addresses.
	 */
	sz = (int)allocsys((caddr_t)0);
	if ((v = (caddr_t)kmem_alloc(kernel_map, round_page(sz))) == 0)
		panic("startup: no room for tables");
	if (allocsys(v) - v != sz)
		panic("startup: table size inconsistency");

	/*
	 * Grab UADDR virtual address
	 */
d319 1
a319 1
	uarea_pages = UADDR;
d321 2
a322 2
	vm_map_find(kernel_map, vm_object_allocate(USPACE), 0,
		(vm_offset_t *)&uarea_pages, USPACE, TRUE);
d324 10
a333 54
	if (uarea_pages != UADDR) {
		printf("uarea_pages %x: UADDR not free\n", uarea_pages);
		panic("bad UADDR");
	}

	/*
	 * Grab the BUGROM space that we hardwired in pmap_bootstrap
	 */

	bugromva = BUGROM_START;

	vm_map_find(kernel_map, vm_object_allocate(BUGROM_SIZE), 0,
		(vm_offset_t *)&bugromva, BUGROM_SIZE, TRUE);

	if (bugromva != BUGROM_START) {
		printf("bugromva %x: BUGROM not free\n", bugromva);
		panic("bad bugromva");
	}

	/*
	 * Grab the SRAM space that we hardwired in pmap_bootstrap
	 */

	sramva = SRAM_START;

	vm_map_find(kernel_map, vm_object_allocate(SRAM_SIZE), 0,
		(vm_offset_t *)&sramva, SRAM_SIZE, TRUE);

	if (sramva != SRAM_START) {
		printf("sramva %x: SRAM not free\n", sramva);
		panic("bad sramva");
	}

	/*
	 * Grab the OBIO space that we hardwired in pmap_bootstrap
	 */

	obiova = OBIO_START;

	vm_map_find(kernel_map, vm_object_allocate(OBIO_SIZE), 0,
		(vm_offset_t *)&obiova, OBIO_SIZE, TRUE);

	if (obiova != OBIO_START) {
		printf("obiova %x: OBIO not free\n", obiova);
		panic("bad OBIO");
	}

	/*
	 * Now allocate buffers proper.  They are different than the above
	 * in that they usually occupy more virtual memory than physical.
	 */

	size = MAXBSIZE * nbuf;
	buffer_map = kmem_suballoc(kernel_map, (vm_offset_t *)&buffers,
d335 26
a360 11
	minaddr = (vm_offset_t)buffers;
	if (vm_map_find(buffer_map, vm_object_allocate(size), (vm_offset_t)0,
		    (vm_offset_t *)&minaddr, size, FALSE) != KERN_SUCCESS) {
		panic("startup: cannot allocate buffers");
	}
	if ((bufpages / nbuf) >= btoc(MAXBSIZE)) {
		/* don't want to alloc more physical mem than needed */
		bufpages = btoc(MAXBSIZE) * nbuf;
	}
	base = bufpages / nbuf;
	residual = bufpages % nbuf;
d362 5
a366 25
	for (i = 0; i < nbuf; i++) {
		vm_size_t curbufsize;
		vm_offset_t curbuf;

		/*
		 * First <residual> buffers get (base+1) physical pages
		 * allocated for them.  The rest get (base) physical pages.
		 *
		 * The rest of each buffer occupies virtual space,
		 * but has no physical memory allocated for it.
		 */
		curbuf = (vm_offset_t)buffers + i * MAXBSIZE;
		curbufsize = CLBYTES * (i < residual ? base+1 : base);

		/* this faults in the required physical pages */
		vm_map_pageable(buffer_map, curbuf, curbuf+curbufsize, FALSE);

		vm_map_simplify(buffer_map, curbuf);
	}

	/*
	 * Allocate a submap for exec arguments.  This map effectively
	 * limits the number of processes exec'ing at any time.
	 */
	exec_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr,
d369 7
a375 3
	/*
	 * Allocate map for physio.
	 */
d377 5
a381 27
	phys_map = vm_map_create(kernel_pmap, PHYSIO_MAP_START,
		PHYSIO_MAP_START + PHYSIO_MAP_SIZE, TRUE);
	if (phys_map == NULL) {
		panic("cpu_startup: unable to create phys_map");
	}

#if XXX_FUTURE
	iomap_map = vm_map_create(kernel_pmap, IOMAP_MAP_START,
			IOMAP_MAP_START + IOMAP_SIZE, TRUE);
	if (iomap_map == NULL) {
		panic("cpu_startup: unable to create iomap_map");
	}

	/*
	 * Allocate space from iomap for a (privately managed) pool
	 * of addresses for IO mappings.
	 */

	iomapbase = kmem_alloc_wait(iomap_map, IOMAP_SIZE);
	rminit(iomap, IOMAP_SIZE, (u_long)iomapbase, "iomap", niomap);
#endif

	/*
	 * Finally, allocate mbuf pool.  Since mclrefcnt is an off-size
	 * we use the more space efficient malloc in place of kmem_alloc.
	 */
	mclrefcnt = (char *)malloc(NMBCLUSTERS+CLBYTES/MCLBYTES,
d383 2
a384 2
	bzero(mclrefcnt, NMBCLUSTERS+CLBYTES/MCLBYTES);
	mb_map = kmem_suballoc(kernel_map, (vm_offset_t *)&mbutl, &maxaddr,
d387 5
a391 5
	/*
	 * Initialize callouts
	 */
	callfree = callout;
	for (i = 1; i < ncallout; i++)
d393 1
a393 1
	callout[i-1].c_next = NULL;
d395 2
a396 2
	printf("avail mem = %d\n", ptoa(cnt.v_free_count));
	printf("using %d buffers containing %d bytes of memory\n",
d399 5
a403 7
#if 0
	mfs_initminiroot(miniroot);
#endif /* 0 */
	/*
	 * Set up buffers, so they can be used to read disk labels.
	 */
	bufinit();
d405 5
a409 4
	/*
	 * Configure the system.
	 */
	nofault = NULL;
d411 1
a411 6
	/*
	 * zero out intr_handlers
	 */
	bzero((void *)intr_handlers, 256 * sizeof(struct intrhand *));

	configure();
a473 8

#if XXX_FUTURE
	/*
	 * Arbitrarily limit the number of devices mapping
	 * the IO space at a given time to NIOPMAP (= 32, default).
	 */
	valloc(iomap, struct map, niomap = NIOPMAP);
#endif
d481 1
d489 2
a490 1
	register struct trapframe *tf = USER_REGS(p);
d494 2
a495 3
	 * argc, argv, envp are placed on the stack by copyregs.
	 * Point r2 to the stack. crt0 should extract envp from
	 * argc & argv before calling user's main.
d497 1
d500 4
a503 4
	 * I don't think I need to mess with fpstate on 88k because
	 * we make sure the floating point pipeline is drained in
	 * the trap handlers. Should check on this later. XXX Nivas.
	 */
d520 1
a520 10
	tf->epsr = 0x3f0; /* user mode, interrupts enabled, fp enabled */

	/*
	 * We want to start executing at pack->ep_entry. The way to
	 * do this is force the processor to fetch from ep_entry. Set
	 * NIP to something bogus and invalid so that it will be a NOOP.
	 * And set sfip to ep_entry with valid bit on so that it will be
	 * fetched.
	 */

d522 1
a522 2
	tf->sfip = (pack->ep_entry & ~3) | FIP_V;
	tf->r[2] = stack;
a526 5
struct sigstate {
	int	ss_flags;		/* which of the following are valid */
	struct 	trapframe ss_frame;	/* original exception frame */
};

d528 1
a528 1
 * WARNING: code in locore.s assumes the layout shown for sf_signo
d533 1
a533 1
	siginfo_t *sf_sip;
a536 1
	siginfo_t sf_si;
d551 1
a551 1
sendsig(catcher, sig, mask, code, type, val)
a554 2
	int type;
	union sigval val;
d580 1
a580 1
		fp = (struct sigframe *)(psp->ps_sigstk.ss_sp +
d597 1
a598 1
	sf.sf_handler = catcher;
a600 7

	if (psp->ps_siginfo & sigmask(sig)) {
		sf.sf_sip = &fp->sf_si;
		initsiginfo(&sf.sf_si, sig, code, type, val);
	}


d605 1
d608 3
a610 3
	sf.sf_sc.sc_xip = tf->sxip & ~3;
	sf.sf_sc.sc_nip = tf->snip & ~3;
	sf.sf_sc.sc_fip = tf->sfip & ~3;
d634 1
a634 1
	if (copyout((caddr_t)&sf, (caddr_t)fp, sizeof sf)) {
d652 2
a653 2
	tf->snip = (addr & ~3) | NIP_V;
	tf->sfip = (tf->snip + 4) | FIP_V;
d677 1
a677 1
	register_t *retval;
d687 1
a687 1
	scp = (struct sigcontext *)SCARG(uap, sigcntxp);
d692 1
a692 2
	if ((int)scp & 3 || useracc((caddr_t)scp, sizeof *scp, B_WRITE) == 0 ||
		copyin((caddr_t)scp, (caddr_t)&ksc, sizeof(struct sigcontext)))
a693 1

a694 1
	scp = &ksc;
a698 1
#if 0
a700 12
#endif /* 0 */
	if (((scp->sc_xip | scp->sc_nip | scp->sc_fip) & 3) != 0)
		printf("xip %x nip %x fip %x\n",
			scp->sc_xip, scp->sc_nip, scp->sc_fip);


	/*
	 * this can be improved by doing
	 *	 bcopy(sc_reg to tf, sizeof sigcontext - 2 words)
	 * XXX nivas
	 */

d703 3
a705 3
	tf->sxip = (scp->sc_xip) | XIP_V;
	tf->snip = (scp->sc_nip) | NIP_V;
	tf->sfip = (scp->sc_fip) | FIP_V;
d731 1
d739 1
a739 1
	p->p_sigmask = scp->sc_mask & ~sigcantmask;
d743 40
a782 1
_doboot()
a783 1
	cmmu_shutdown_now();
d796 2
a797 17
	if ((howto & RB_NOSYNC) == 0 && waittime < 0) {

		extern struct proc proc0;

		/* protect against curproc->p_stats.foo refs in sync()   XXX */
		if (curproc == NULL)
			curproc = &proc0;

		waittime = 0;
		vfs_shutdown();

		/*
		 * If we've been adjusting the clock, the todr
		 * will be out of synch; adjust it now.
		 */
		resettodr();
	}
d881 8
a888 1
 * fill up ivec array with interrupt response vector addresses.
d891 2
a892 1
setupiackvectors()
d894 2
a895 14
	register u_char *vaddr;
#ifdef XXX_FUTURE
	extern vm_offset_t iomap_mapin(vm_offset_t, vm_size_t,  boolean_t);
#endif

	/*
	 * map a page in for phys address 0xfffe0000 and set the
	 * addresses for various levels.
	 */
#ifdef XXX_FUTURE
	vaddr = (u_char *)iomap_mapin(0xfffe0000, NBPG, 1);
#else
	vaddr = (u_char *)0xfffe0000;
#endif
d897 5
a901 27
	ivec[0] = vaddr + 0x03;
	ivec[1] = vaddr + 0x07;
	ivec[2] = vaddr + 0x0b;
	ivec[3] = vaddr + 0x0f;
	ivec[4] = vaddr + 0x13;
	ivec[5] = vaddr + 0x17;
	ivec[6] = vaddr + 0x1b;
	ivec[7] = vaddr + 0x1f;
}

/*
 * Insert ihand in the list of handlers at vector vec.
 * Return return different error codes for the different
 * errors and let the caller decide what to do.
 */

int
intr_establish(int vec, struct intrhand *ihand)
{
	register struct intrhand *intr;

	if (vec < 0 || vec > 255) {
#if DIAGNOSTIC
		panic("intr_establish: vec (%x) not between 0 and 0xff\n",
			vec);
#endif /* DIAGNOSTIC */
		return (INTR_EST_BADVEC);
d903 5
a907 15

	if (intr = intr_handlers[vec]) {
		if (intr->ih_ipl != ihand->ih_ipl) {
#if DIAGNOSTIC
			panic("intr_establish: there are other handlers with vec (%x) at ipl %x, but you want it at %x\n",
				intr->ih_ipl, vec, ihand->ih_ipl);
#endif /* DIAGNOSTIC */
			return (INTR_EST_BADIPL);
		}

		/*
		 * Go to the end of the chain
		 */
		while (intr->ih_next)
			intr = intr->ih_next;
d909 2
a910 9

	ihand->ih_next = 0;

	if (intr)
		intr->ih_next = ihand;
	else
		intr_handlers[vec] = ihand;
	
	return (INTR_EST_SUCC);
d913 1
d915 6
a920 6
 *	Device interrupt handler
 *
 *      when we enter, interrupts are disabled;
 *      when we leave, they should be disabled,
 *      but they need not be disabled throughout
 *      the routine.
d922 5
d928 1
a928 2
void
ext_int(u_int v, struct m88100_saved_state *eframe)
d930 2
a931 4
	register u_char mask, level, xxxvec;
	register struct intrhand *intr;
	int ret;
	u_char vec;
d933 5
a937 1
	/* get level and mask */
d939 4
a942 2
	asm volatile("ld.b	%0,%1" : "=r" (mask) : "" (*pcc2intr_mask));
	asm volatile("ld.b	%0,%1" : "=r" (level) : "" (*pcc2intr_ipl));
d944 5
a948 6
	/*
	 * It is really bizarre for the mask and level to the be the same.
	 * pcc2 for 187 blocks all interrupts at and below the mask value,
	 * so we should not be getting an interrupt at the level that is
	 * already blocked. I can't explain this case XXX nivas
	 */
d950 5
a954 4
	if ((mask == level) && level) {
		printf("mask == level, %d\n", level);
		goto beatit;
	}
d956 3
a958 14
	/*
	 * Interrupting level cannot be 0--0 doesn't produce an interrupt.
	 * Weird! XXX nivas
	 */

	if (level == 0) {
		printf("Bogons... level %x and mask %x\n", level, mask);
		goto beatit;
	}

	/* and block interrupts at level or lower */
	setipl((u_char)level);
	/* and stash it away in the trap frame */
	eframe->mask = mask;
d960 5
a964 5
	asm volatile("st.b	%1,%0" : "=m" (*pcc2intr_mask) :  "r" (level));
#endif
	if (level > 7 || (char)level < 0) {
		panic("int level (%x) is not between 0 and 7\n", level);
	}
d967 3
d971 5
a975 25
#if XXX
	asm volatile("ld.b 	%0,%1" : "=r" (vec) : "" (*ivec[level]));
	asm volatile("tb1	0, r0, 0");	
	asm volatile("tb1	0, r0, 0");	
	asm volatile("tb1	0, r0, 0");	

	asm volatile("tb1	0, r0, 0");	

	if (guarded_access(ivec[level], 1, &vec) == EFAULT) {
		printf("Unable to get vector for this interrupt (level %x)\n",
					level);
		goto out;
	}	
#endif XXX

	asm volatile("tb1	0, r0, 0");	
	if (guarded_access(ivec[level], 1, &vec) == EFAULT) {
		printf("Unable to get vector for this interrupt (level %x)\n",
					level);
		goto out;
	}
	asm volatile("tb1	0, r0, 0");	
	asm volatile("tb1	0, r0, 0");	
	asm volatile("tb1	0, r0, 0");	
	/*vec = xxxvec;*/
d977 5
a981 3
	if (vec > 0xFF) {
		panic("interrupt vector %x greater than 255\n", vec);
	}
d983 5
a987 1
	enable_interrupt();
d989 5
a993 8
	if ((intr = intr_handlers[vec]) == 0) {
		printf("Spurious interrupt (level %x and vec %x)\n",
			level, vec);
	}
	if (intr && intr->ih_ipl != level) {
		panic("Handler ipl %x not the same as level %x\n",
			intr->ih_ipl, level);
	}
d995 6
a1000 5
	/*
	 * Walk through all interrupt handlers in the chain for the
	 * given vector, calling each handler in turn, till some handler
	 * returns a value != 0.
	 */
d1002 15
a1016 7
	for (ret = 0; intr; intr = intr->ih_next) {
		if (intr->ih_wantframe)
			ret = (*intr->ih_fn)(intr->ih_arg, (void *)eframe);
		else
			ret = (*intr->ih_fn)(intr->ih_arg);
		if (ret)
			break;
d1018 1
d1020 14
a1033 4
	if (ret == 0) {
		printf("Unclaimed interrupt (level %x and vec %x)\n",
			level, vec);
	}
d1035 5
a1039 5
	/*
	 * process any remaining data access exceptions before
	 * returning to assembler
	 */
	disable_interrupt();
d1041 2
a1042 7
out:
	if (eframe->dmt0 & DMT_VALID) {
		trap(T_DATAFLT, eframe);
		data_access_emulation(eframe);
		eframe->dmt0 &= ~DMT_VALID;
	}
	mask = eframe->mask;
d1044 19
a1062 11
	/*
	 * Restore the mask level to what it was when the interrupt
	 * was taken.
	 */
	setipl((u_char)mask);
#if 0
	asm volatile("st.b	%1,%0" : "=m" (*pcc2intr_mask) :  "r" (mask));
#endif
#if 0
	splx((u_char)mask);
#endif /* 0 */
d1064 9
a1072 2
beatit:
	return;
d1079 42
a1120 1
	return ENOEXEC;
d1122 6
d1129 1
a1129 1
sys_sysarch(p, v, retval)
d1131 2
a1132 2
	void *v;
	register_t *retval;
a1133 4
	struct sys_sysarch_args /* {
		syscallarg(int) op;
		syscallarg(char *) parm;
	} */ *uap = v;
d1136 1
a1136 1
	switch((int)SCARG(uap, op)) {
d1171 3
a1173 4

void
_insque(velement, vhead)
	void *velement, *vhead;
a1174 3
	register struct prochd *element, *head;
	element = velement;
	head = vhead;
d1184 3
a1186 4

void
_remque(velement)
	void *velement;
a1187 2
	register struct prochd *element;
	element = velement;
d1193 49
a1241 1
int
d1243 2
a1244 4
	const void *fromaddr;
        void *toaddr;
	size_t maxlength;
	size_t *lencopied;
a1248 1

d1257 1
a1257 4

	if (lencopied)
		*lencopied = tally;

d1262 1
a1262 24
setrunqueue(p)
	register struct proc *p;
{
	register struct prochd *q;
	register struct proc *oldlast;
	register int which = p->p_priority >> 2;

	if (p->p_back != NULL)
		panic("setrunqueue %x", p);
	q = &qs[which];
	whichqs |= 1 << which;
	p->p_forw = (struct proc *)q;
	p->p_back = oldlast = q->ph_rlink;
	q->ph_rlink = p;
	oldlast->p_forw = p;
}

/*
 * Remove process p from its run queue, which should be the one
 * indicated by its priority.  Calls should be made at splstatclock().
 */
void
remrunqueue(vp)
	struct proc *vp;
d1264 1
a1264 12
	register struct proc *p = vp;
	register int which = p->p_priority >> 2;
	register struct prochd *q;

	if ((whichqs & (1 << which)) == 0)
		panic("remrq %x", p);
	p->p_forw->p_back = p->p_back;
	p->p_back->p_forw = p->p_forw;
	p->p_back = NULL;
	q = &qs[which];
	if (q->ph_link == (struct proc *)q)
		whichqs &= ~(1 << which);
a1265 1

d1272 1
a1272 3
void
myetheraddr(cp)
	u_char *cp;
a1273 11
	struct bugniocall niocall;

	niocall.clun = 0;
	niocall.dlun = 0;
	niocall.ci = 0;
	niocall.cd = 0;
	niocall.cid = NETCTRL_GETHDW;
	niocall.memaddr = (unsigned int)cp;
	niocall.nbytes = 6;

	bugnetctrl(&niocall);
a1277 75
#ifdef INET
	if (netisr & (1 << NETISR_ARP)) {
		netisr &= ~(1 << NETISR_ARP);
		arpintr();
	}
	if (netisr & (1 << NETISR_IP)) {
		netisr &= ~(1 << NETISR_IP);
		ipintr();
	}
#endif
#ifdef NS
	if (netisr & (1 << NETISR_NS)) {
		netisr &= ~(1 << NETISR_NS);
		nsintr();
	}
#endif
#ifdef ISO
	if (netisr & (1 << NETISR_ISO)) {
		netisr &= ~(1 << NETISR_ISO);
		clnlintr();
	}
#endif
#ifdef CCITT
	if (netisr & (1 << NETISR_CCITT)) {
		netisr &= ~(1 << NETISR_CCITT);
		ccittintr();
	}
#endif
#include "ppp.h"
#if NPPP > 0
	if (netisr & (1 << NETISR_PPP)) {
		netisr &= ~(1 << NETISR_PPP);
		pppintr();
	}
#endif
}

void
dosoftint()
{
	if (ssir & SIR_NET) {
		siroff(SIR_NET);
		cnt.v_soft++;
		netintr();
	}

	if (ssir & SIR_CLOCK) {
		siroff(SIR_CLOCK);
		cnt.v_soft++;
		softclock();
	}

	return;
}

int
spl0()
{
	int x;
	int level = 0;

	x = splsoftclock();

	if (ssir) {
		dosoftint();
	}

	setipl(0);

	return(x);
}

badwordaddr(void *addr)
{
	return badaddr((vm_offset_t)addr, 4);
d1281 4
a1284 4
	struct trapframe 	*f;
	caddr_t 		p;
	int 			flags;
	char			*s;
d1291 2
a1292 2
	struct trapframe	*f;
	int			flags;
a1296 13
void
nmihand(void *framep)
{
	struct m88100_saved_state *frame = framep;

#if DDB
	DEBUG_MSG("Abort Pressed\n");
	Debugger();
#else
	DEBUG_MSG("Spurious NMI?\n");
#endif /* DDB */
}

d1352 1
a1352 1
	return (db_setipl(IPL_HIGH));
d1358 1
a1358 1
	return (db_setipl(s));
a1360 91

/*
 * Called from locore.S during boot,
 * this is the first C code that's run.
 */

void
m187_bootstrap(void)
{
    extern char version[];
    extern char *edata, *end;
    extern int cold;
    extern int kernelstart;
    extern vm_offset_t size_memory(void);
    extern struct consdev *cn_tab;
    struct bugbrdid brdid;

    cold = 1;	/* we are still booting */

    cn_tab = &bugcons;

    buginit();

    bugbrdid(&brdid);
    cputyp = brdid.brdno;

    vm_set_page_size();

#if 0
    esym  = kflags.esym;
    boothowto = kflags.bflags;
    bootdev = kflags.bdev;
#endif /* 0 */
    
#if 0
    end_loaded = kflags.end_load;
    if (esym != NULL) {
    	end = (char *)((int)(kflags.symtab));
    } else {
    	first_addr = (vm_offset_t)&end;
    }
#endif

    first_addr = m88k_round_page(first_addr);

    if (!no_symbols)
	boothowto |= RB_KDB;

    last_addr = size_memory();

    cmmu_init();

    avail_start = first_addr;
    avail_end = last_addr;
    printf("%s",version);
    printf("M187 boot: memory from 0x%x to 0x%x\n", avail_start, avail_end);

    /*
     * Steal one page at the top of physical memory for msgbuf
     */
    avail_end -= PAGE_SIZE;

    pmap_bootstrap((vm_offset_t)M88K_TRUNC_PAGE((unsigned)&kernelstart) /* = loadpt */, 
		   &avail_start, &avail_end, &virtual_avail,
		   &virtual_end);
#if defined(DEBUG)
    printf("returned from pmap_bootstrap\n");
#endif

    /*
     * Must initialize p_addr before autoconfig or
     * the fault handler will get a NULL reference.
     */
    proc0.p_addr = proc0paddr;
    curproc = &proc0;
    curpcb = &proc0paddr->u_pcb;

    /* Initialize cached PTEs for u-area mapping. */
    save_u_area(&proc0, (vm_offset_t)proc0paddr);

    /*
     * Map proc0's u-area at the standard address (UADDR).
     */
    load_u_area(&proc0);

    /* Initialize the "u-area" pages. */
    bzero((caddr_t)UADDR, UPAGES*NBPG);
#if defined(DEBUG)
    printf("returning from init\n");
#endif
}
@
