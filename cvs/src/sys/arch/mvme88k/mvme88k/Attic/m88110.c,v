head	1.84;
access;
symbols
	OPENBSD_5_5:1.83.0.4
	OPENBSD_5_5_BASE:1.83
	OPENBSD_5_4:1.79.0.2
	OPENBSD_5_4_BASE:1.79
	OPENBSD_5_3:1.78.0.2
	OPENBSD_5_3_BASE:1.78
	OPENBSD_5_2:1.76.0.4
	OPENBSD_5_2_BASE:1.76
	OPENBSD_5_1_BASE:1.76
	OPENBSD_5_1:1.76.0.2
	OPENBSD_5_0:1.74.0.2
	OPENBSD_5_0_BASE:1.74
	OPENBSD_4_9:1.73.0.2
	OPENBSD_4_9_BASE:1.73
	OPENBSD_4_8:1.65.0.2
	OPENBSD_4_8_BASE:1.65
	OPENBSD_4_7:1.63.0.2
	OPENBSD_4_7_BASE:1.63
	OPENBSD_4_6:1.63.0.4
	OPENBSD_4_6_BASE:1.63
	OPENBSD_4_5:1.62.0.4
	OPENBSD_4_5_BASE:1.62
	OPENBSD_4_4:1.58.0.4
	OPENBSD_4_4_BASE:1.58
	OPENBSD_4_3:1.58.0.2
	OPENBSD_4_3_BASE:1.58
	OPENBSD_4_2:1.38.0.4
	OPENBSD_4_2_BASE:1.38
	OPENBSD_4_1:1.38.0.2
	OPENBSD_4_1_BASE:1.38
	OPENBSD_4_0:1.37.0.2
	OPENBSD_4_0_BASE:1.37
	OPENBSD_3_9:1.35.0.2
	OPENBSD_3_9_BASE:1.35
	OPENBSD_3_8:1.21.0.2
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.18.0.4
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.2
	OPENBSD_3_6_BASE:1.18
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.6
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	SMP:1.5.0.2
	UBC_SYNC_B:1.6
	UBC:1.3.0.2
	UBC_BASE:1.3;
locks; strict;
comment	@ * @;


1.84
date	2014.03.18.22.36.36;	author miod;	state dead;
branches;
next	1.83;

1.83
date	2013.11.16.18.45.20;	author miod;	state Exp;
branches;
next	1.82;

1.82
date	2013.11.03.09.42.55;	author miod;	state Exp;
branches;
next	1.81;

1.81
date	2013.11.02.23.10.30;	author miod;	state Exp;
branches;
next	1.80;

1.80
date	2013.08.15.19.32.12;	author miod;	state Exp;
branches;
next	1.79;

1.79
date	2013.05.17.22.33.25;	author miod;	state Exp;
branches;
next	1.78;

1.78
date	2013.02.19.21.02.06;	author miod;	state Exp;
branches;
next	1.77;

1.77
date	2013.02.17.18.07.36;	author miod;	state Exp;
branches;
next	1.76;

1.76
date	2011.10.25.18.38.06;	author miod;	state Exp;
branches;
next	1.75;

1.75
date	2011.10.09.17.02.15;	author miod;	state Exp;
branches;
next	1.74;

1.74
date	2011.04.19.21.25.28;	author miod;	state Exp;
branches;
next	1.73;

1.73
date	2011.01.05.22.16.16;	author miod;	state Exp;
branches;
next	1.72;

1.72
date	2011.01.05.22.14.39;	author miod;	state Exp;
branches;
next	1.71;

1.71
date	2011.01.02.17.55.27;	author miod;	state Exp;
branches;
next	1.70;

1.70
date	2011.01.01.22.09.33;	author miod;	state Exp;
branches;
next	1.69;

1.69
date	2011.01.01.20.58.32;	author miod;	state Exp;
branches;
next	1.68;

1.68
date	2010.12.31.21.16.31;	author miod;	state Exp;
branches;
next	1.67;

1.67
date	2010.12.31.21.12.16;	author miod;	state Exp;
branches;
next	1.66;

1.66
date	2010.12.31.20.54.21;	author miod;	state Exp;
branches;
next	1.65;

1.65
date	2010.06.22.17.42.37;	author miod;	state Exp;
branches;
next	1.64;

1.64
date	2010.04.17.22.10.13;	author miod;	state Exp;
branches;
next	1.63;

1.63
date	2009.04.19.17.56.13;	author miod;	state Exp;
branches;
next	1.62;

1.62
date	2009.02.16.23.03.33;	author miod;	state Exp;
branches;
next	1.61;

1.61
date	2009.02.13.23.29.38;	author miod;	state Exp;
branches;
next	1.60;

1.60
date	2009.02.01.00.52.19;	author miod;	state Exp;
branches;
next	1.59;

1.59
date	2009.01.29.22.15.27;	author miod;	state Exp;
branches;
next	1.58;

1.58
date	2008.01.02.19.59.31;	author miod;	state Exp;
branches;
next	1.57;

1.57
date	2007.12.26.22.22.45;	author miod;	state Exp;
branches;
next	1.56;

1.56
date	2007.12.26.22.21.41;	author miod;	state Exp;
branches;
next	1.55;

1.55
date	2007.12.25.21.10.56;	author miod;	state Exp;
branches;
next	1.54;

1.54
date	2007.12.25.20.23.04;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2007.12.22.17.13.53;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2007.12.15.19.37.41;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2007.12.15.19.34.35;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2007.12.15.19.33.35;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2007.12.05.22.10.42;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2007.12.04.23.45.53;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2007.12.04.05.41.48;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2007.12.02.22.17.36;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2007.11.24.17.27.38;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2007.11.22.23.33.42;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2007.11.22.05.53.57;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2007.11.22.05.47.46;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2007.11.22.05.42.52;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2007.11.21.19.42.36;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2007.11.17.05.36.23;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2007.02.11.12.49.38;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2006.05.08.14.36.10;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2006.05.08.14.03.35;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2005.12.11.21.45.31;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2005.12.04.15.00.26;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2005.12.04.12.20.19;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2005.12.03.19.06.12;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2005.12.03.18.48.22;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2005.12.03.16.52.16;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2005.12.03.14.30.06;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2005.12.02.21.16.45;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2005.11.25.22.17.12;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2005.11.15.07.02.36;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2005.10.13.19.48.36;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2005.09.25.22.41.14;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2005.09.25.20.55.15;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2005.09.06.19.43.00;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2005.04.30.16.42.37;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2005.04.27.14.09.45;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2005.04.27.14.07.38;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2004.08.04.15.54.38;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2004.08.02.08.35.00;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2004.06.26.20.58.13;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2004.06.22.04.55.35;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2004.05.07.18.06.34;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2004.01.02.17.08.57;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2003.12.22.20.10.23;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2003.12.19.22.30.18;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.05.20.35.26;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2003.09.26.22.27.26;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2003.09.16.20.46.11;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2003.08.20.20.33.47;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.01.26.40;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.12.24.04.12.40;	author miod;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2001.12.22.09.49.39;	author smurph;	state Exp;
branches;
next	1.3;

1.3
date	2001.12.16.23.49.46;	author miod;	state dead;
branches
	1.3.2.1;
next	1.2;

1.2
date	2001.12.14.04.30.12;	author smurph;	state Exp;
branches;
next	1.1;

1.1
date	2001.12.13.08.55.52;	author smurph;	state Exp;
branches;
next	;

1.3.2.1
date	2002.01.31.22.55.19;	author niklas;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2002.06.11.03.37.11;	author art;	state Exp;
branches;
next	;

1.5.2.1
date	2002.03.28.10.36.02;	author niklas;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2004.02.19.10.49.07;	author niklas;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2004.06.05.23.09.50;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.84
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: m88110.c,v 1.83 2013/11/16 18:45:20 miod Exp $	*/

/*
 * Copyright (c) 2010, 2011, Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * Copyright (c) 1998 Steve Murphree, Jr.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Nivas Madhur.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
/*
 * Mach Operating System
 * Copyright (c) 1993-1991 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON AND OMRON ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON AND OMRON DISCLAIM ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/systm.h>

#include <uvm/uvm_extern.h>

#include <machine/asm_macro.h>
#include <machine/bugio.h>
#include <machine/cmmu.h>
#include <machine/cpu.h>
#include <machine/lock.h>
#include <machine/m88110.h>
#include <machine/m88410.h>
#include <machine/psl.h>

#include <mvme88k/dev/busswreg.h>
#include <machine/mvme197.h>

extern	void m88110_zeropage(vaddr_t);
extern	void m88110_copypage(vaddr_t, vaddr_t);

cpuid_t	m88110_init(void);
cpuid_t	m88410_init(void);
void	m88110_batc_setup(cpuid_t, apr_t);
void	m88110_setup_board_config(void);
void	m88410_setup_board_config(void);
void	m88110_cpu_configuration_print(int);
void	m88410_cpu_configuration_print(int);
void	m88110_shutdown(void);
cpuid_t	m88110_cpu_number(void);
apr_t	m88110_apr_cmode(void);
apr_t	m88410_apr_cmode(void);
apr_t	m88110_pte_cmode(void);
void	m88110_set_sapr(apr_t);
void	m88110_set_uapr(apr_t);
void	m88110_tlbis(cpuid_t, vaddr_t, pt_entry_t);
void	m88110_tlbiu(cpuid_t, vaddr_t, pt_entry_t);
void	m88110_tlbia(cpuid_t);
void	m88110_cache_wbinv(cpuid_t, paddr_t, psize_t);
void	m88410_cache_wbinv(cpuid_t, paddr_t, psize_t);
void	m88110_dcache_wb(cpuid_t, paddr_t, psize_t);
void	m88410_dcache_wb(cpuid_t, paddr_t, psize_t);
void	m88110_icache_inv(cpuid_t, paddr_t, psize_t);
void	m88410_icache_inv(cpuid_t, paddr_t, psize_t);
void	m88110_dma_cachectl(paddr_t, psize_t, int);
void	m88110_dma_cachectl_local(paddr_t, psize_t, int);
void	m88410_dma_cachectl(paddr_t, psize_t, int);
void	m88410_dma_cachectl_local(paddr_t, psize_t, int);
void	m88110_initialize_cpu(cpuid_t);
void	m88410_initialize_cpu(cpuid_t);

/*
 * This is the function table for the MC88110 built-in CMMUs without
 * external 88410.
 */
const struct cmmu_p cmmu88110 = {
	m88110_init,
	m88110_batc_setup,
	m88110_setup_board_config,
	m88110_cpu_configuration_print,
	m88110_shutdown,
	m88110_cpu_number,
	m88110_apr_cmode,
	m88110_pte_cmode,
	m88110_set_sapr,
	m88110_set_uapr,
	m88110_tlbis,
	m88110_tlbiu,
	m88110_tlbia,
	m88110_cache_wbinv,
	m88110_dcache_wb,
	m88110_icache_inv,
	m88110_dma_cachectl,
#ifdef MULTIPROCESSOR
	m88110_dma_cachectl_local,
	m88110_initialize_cpu,
#endif
};

/*
 * This is the function table for the MC88110 built-in CMMUs with
 * external 88410.
 */
const struct cmmu_p cmmu88410 = {
	m88410_init,
	m88110_batc_setup,
	m88410_setup_board_config,
	m88410_cpu_configuration_print,
	m88110_shutdown,
	m88110_cpu_number,
	m88410_apr_cmode,
	m88110_pte_cmode,
	m88110_set_sapr,
	m88110_set_uapr,
	m88110_tlbis,
	m88110_tlbiu,
	m88110_tlbia,
	m88410_cache_wbinv,
	m88410_dcache_wb,
	m88410_icache_inv,
	m88410_dma_cachectl,
#ifdef MULTIPROCESSOR
	m88410_dma_cachectl_local,
	m88410_initialize_cpu,
#endif
};

size_t mc88410_linesz[2] = { 5, 5 };		/* log2 of L2 cache line size */
size_t mc88410_cachesz[2] = { 256, 256 };	/* L2 cache size in KB */

static inline
void m88110_dbatc_set(uint, batc_t);
static inline
void m88110_ibatc_set(uint, batc_t);
void m88110_patc_clear(void);

void m88110_cmmu_wb_locked(paddr_t, psize_t);
void m88110_cmmu_wbinv_locked(paddr_t, psize_t);
void m88110_cmmu_inv_locked(paddr_t, psize_t);

static inline
void
m88110_dbatc_set(uint batno, batc_t val)
{
	set_dir(batno);
	set_dbp(val);
}

static inline
void
m88110_ibatc_set(uint batno, batc_t val)
{
	set_iir(batno);
	set_ibp(val);
}

void
m88110_patc_clear(void)
{
	uint patcno;

	for (patcno = 0; patcno < 32; patcno++) {
		set_dir(patcno << 5);
		set_dppu(0);
		set_dppl(0);

		set_iir(patcno << 5);
		set_ippu(0);
		set_ippl(0);
	}
}

void
m88110_setup_board_config(void)
{
	ncpusfound = 1;
}

void
m88410_setup_board_config(void)
{
	struct mvmeprom_brdid brdid;

	/*
	 * MVME197SP are 01-W3815B04, while MVME197DP are 01-W3815B03.
	 * If the CNFG memory has been lost and the board is a 197SP,
	 * we'll just fail to spin up the non-existing second processor.
	 */
	bzero(&brdid, sizeof(brdid));
	bugbrdid(&brdid);
	if (bcmp(brdid.pwa, "01-W3815B04", 11) == 0)
		ncpusfound = 1;
	else
		ncpusfound = 2;
}

/*
 * Should only be called after the calling cpus knows its cpu
 * number and master/slave status. Should be called first
 * by the master, before the slaves are started.
 */
void
m88110_cpu_configuration_print(int master)
{
	int pid = get_cpu_pid();
	int proctype = (pid & PID_ARN) >> ARN_SHIFT;
	int procvers = (pid & PID_VN) >> VN_SHIFT;
	int cpu = cpu_number();

	printf("cpu%d: ", cpu);
	switch (proctype) {
	default:
		printf("unknown model arch 0x%x version 0x%x",
		    proctype, procvers);
		break;
	case ARN_88110:
		printf("M88110 version 0x%x, 8K I/D caches (32b/l)", procvers);
		break;
	}
	printf("\n");
}

void
m88410_cpu_configuration_print(int master)
{
	int cpu = cpu_number();

	m88110_cpu_configuration_print(master);
	printf("cpu%d: external M88410 %dK cache controller (%db/l)\n",
	    cpu, mc88410_cachesz[cpu], 1 << mc88410_linesz[cpu]);

#ifdef MULTIPROCESSOR
	/*
	 * Mark us as allowing IPIs now.
	 */
	*(volatile u_int8_t *)(BS_BASE + BS_CPINT) = BS_CPI_ICLR | BS_CPI_IEN;
#endif
}

/*
 * CMMU initialization routine
 */
cpuid_t
m88110_init(void)
{
	cpuid_t cpu;

	cpu = m88110_cpu_number();
	m88110_initialize_cpu(cpu);
	return (cpu);
}

cpuid_t
m88410_init(void)
{
	cpuid_t cpu;

	cpu = m88110_cpu_number();
	m88410_initialize_cpu(cpu);
	return (cpu);
}

void
m88110_batc_setup(cpuid_t cpu, apr_t cmode)
{
	paddr_t s_text, e_text, s_data, e_data,	e_rodata;
	uint batcno;
	batc_t batc, proto;
	extern caddr_t kernelstart;
	extern caddr_t etext;
	extern caddr_t erodata;
	extern caddr_t end;

	proto = BATC_SO | BATC_V;
	if (cmode & CACHE_WT)
		proto |= BATC_WT;
	if (cmode & CACHE_INH)
		proto |= BATC_INH;

	s_text = round_batc((paddr_t)&kernelstart);
	s_data = e_text = round_batc((paddr_t)&etext);
	e_rodata = round_batc((paddr_t)&erodata);
#if 0 /* not until pmap makes sure kvm starts on a BATC boundary */
	e_data = round_batc((paddr_t)&end);
#else
	e_data = trunc_batc((paddr_t)&end);
#endif

	/* map s_text..e_text with IBATC */
	batcno = 0;
	while (s_text != e_text) {
		batc = (s_text >> BATC_BLKSHIFT) << BATC_VSHIFT;
		batc |= (s_text >> BATC_BLKSHIFT) << BATC_PSHIFT;
		batc |= proto;
#ifdef DEBUG
		printf("cpu%d ibat%d %p(%08x)\n", cpu, batcno, s_text, batc);
#endif
		global_ibatc[batcno] = batc;
		s_text += BATC_BLKBYTES;
		if (++batcno == BATC_MAX)
			break;
	}

	/* map e_text..e_data with DBATC */
	if (cmode & CACHE_GLOBAL)
		proto |= BATC_GLOBAL;
	batcno = 0;
	while (s_data != e_data) {
		batc = (s_data >> BATC_BLKSHIFT) << BATC_VSHIFT;
		batc |= (s_data >> BATC_BLKSHIFT) << BATC_PSHIFT;
		batc |= proto;
		if (s_data < e_rodata)
			batc |= BATC_PROT;
#if defined(MULTIPROCESSOR)	/* XXX */
		else
			break;
#endif
#ifdef DEBUG
		printf("cpu%d dbat%d %p(%08x)\n", cpu, batcno, s_data, batc);
#endif
		global_dbatc[batcno] = batc;
		s_data += BATC_BLKBYTES;
		if (++batcno == BATC_MAX)
			break;
	}

	for (batcno = 0; batcno < BATC_MAX; batcno++) {
		m88110_dbatc_set(batcno, global_dbatc[batcno]);
		m88110_ibatc_set(batcno, global_ibatc[batcno]);
	}
}

cpuid_t
m88110_cpu_number(void)
{
	u_int16_t gcsr;

	gcsr = *(volatile u_int16_t *)(BS_BASE + BS_GCSR);

	return ((gcsr & BS_GCSR_CPUID) != 0 ? 1 : 0);
}

void
m88110_initialize_cpu(cpuid_t cpu)
{
	struct cpu_info *ci;
	u_int ictl, dctl;
	int i;
#ifdef i_know_what_i_am_doing
	int procvers = (get_cpu_pid() & PID_VN) >> VN_SHIFT;
#endif

	ci = &m88k_cpus[cpu];

	/* clear BATCs */
	for (i = 0; i < 8; i++) {
		set_dir(i);
		set_dbp(0);
		set_iir(i);
		set_ibp(0);
	}

	/* clear PATCs */
	m88110_patc_clear();

	ictl = BATC_512K | CMMU_ICTL_DID | CMMU_ICTL_CEN | CMMU_ICTL_BEN;

	/*
	 * 88110 errata #10 (4.2) or #2 (5.1.1):
	 * ``Under some circumstances, the 88110 may incorrectly latch data
	 *   as it comes from the bus.
	 *   [...]
	 *   It is the data matching mechanism that may give corrupt data to
	 *   the register files.
	 *   Suggested fix: Set the Data Matching Disable bit (bit 2) of the
	 *   DCTL.  This bit is not documented in the user's manual. This bit
	 *   is only present for debug purposes and its functionality should
	 *   not be depended upon long term.''
	 *
	 * 88110 errata #5 (5.1.1):
	 * ``Setting the xmem bit in the dctl register to perform st/ld
	 *   xmems can cause the cpu to hang if a st instruction follows the
	 *   xmem.
	 *   Work-Around: do not set the xmem bit in dctl, or separate st
	 *   from xmem instructions.''
	 */
	dctl = BATC_512K | CMMU_DCTL_CEN | CMMU_DCTL_ADS;
	dctl |= CMMU_DCTL_RSVD1; /* Data Matching Disable */

	/*
	 * 88110 rev 4.2 errata #1:
	 * ``Under certain conditions involving exceptions, with branch
	 *   prediction enabled, the CPU may hang.
	 *   Suggested fix: Clear the PREN bit of the ICTL.  This will
	 *   disable branch prediction.''
	 *
	 * ...but this errata becomes...
	 *
	 * 88110 rev 5.1 errata #1:
	 * ``Under certain conditions involving exceptions, with branch
	 *   prediction enabled and decoupled loads/stores enabled, load
	 *   instructions may complete incorrectly or stores may execute
	 *   to the wrong. address.
	 *   Suggested fix: Clear the PREN bit of the ICTL or the DEN bit
	 *   of the DCTL.''
	 *
	 * Unfortunately, while it would be nice to be able to enable
	 * branch prediction on later models (which gives better
	 * performance than data cache decoupling), the CPU hang can
	 * still occur after hitting several SFU instructions in a row,
	 * something crashme is good at producing.
	 */
#ifdef i_know_what_i_am_doing
	if (procvers >= 0xf)	/* > 0xb ? */
		ictl |= CMMU_ICTL_PREN;
	else
#endif
		dctl |= CMMU_DCTL_DEN;

	mc88110_inval_inst();		/* clear instruction cache & TIC */
	mc88110_inval_data();		/* clear data cache */

	set_ictl(ictl);
	set_dctl(dctl);

	set_isr(0);
	set_dsr(0);

	ci->ci_zeropage = m88110_zeropage;
	ci->ci_copypage = m88110_copypage;
}

void
m88410_initialize_cpu(cpuid_t cpu)
{
	u_int dctl;
	uint32_t tcr1, tcr2;
	uint clkspeed, lines, linelog;

	m88110_initialize_cpu(cpu);
	dctl = get_dctl();
	dctl |= CMMU_DCTL_SEN;
	set_dctl(dctl);

	/*
	 * There does not seem to be an easy way to figure out the size of
	 * the secondary cache.  According to the 197SP/DP documentation,
	 * the L2 configuration is always 256KB and 32 bytes per line.
	 * However, the 88410 documentation mentions 512KB and 1MB as
	 * possible configurations, and there might have been some late
	 * 197SP/DP models fitted with more than 256KB of L2.
	 *
	 * Timing the invalidate operation is good enough to let us know
	 * how many cache lines are available (it will take two clock
	 * cycles per line), and the ECDM configuration register will tell
	 * us the cache line size.
	 */

	/* enable BusSwitch timer1 */
	*(volatile uint8_t *)(BS_BASE + BS_TINT1) = 0;
	*(volatile uint8_t *)(BS_BASE + BS_TCTRL1) =
	    BS_TCTRL_CEN | BS_TCTRL_COVF;
	*(volatile uint32_t *)(BS_BASE + BS_TCOMP1) = 0xffffffff;

	CMMU_LOCK;
	tcr1 = *(volatile uint32_t *)(BS_BASE + BS_TCOUNT1);
	mc88410_inv();	/* clear external data cache */
	tcr2 = *(volatile uint32_t *)(BS_BASE + BS_TCOUNT1);
	CMMU_UNLOCK;

	mc88410_linesz[cpu] = *(volatile uint8_t *)(ECDM_BASE) & 0x40 ? 6 : 5;
	clkspeed = 256 - *(volatile uint8_t *)(BS_BASE + BS_PADJUST);
	lines = ((tcr2 - tcr1) * clkspeed) >> 1;
	for (linelog = 16; linelog != 12; linelog--)
		if ((lines >> linelog) != 0) {
			mc88410_cachesz[cpu] =
			    1 << (linelog + mc88410_linesz[cpu] - 10);
			break;
		}
}

/*
 * Just before poweroff or reset....
 */
void
m88110_shutdown(void)
{
}

apr_t
m88110_apr_cmode(void)
{
	return CACHE_DFL;
}

apr_t
m88410_apr_cmode(void)
{
	return CACHE_WT;
}

apr_t
m88110_pte_cmode(void)
{
	return CACHE_WT;
}

void
m88110_set_sapr(apr_t ap)
{
	u_int ictl, dctl;

	set_icmd(CMMU_ICMD_INV_SATC);
	set_dcmd(CMMU_DCMD_INV_SATC);

	ictl = get_ictl();
	dctl = get_dctl();

	set_isap(ap);
	set_dsap(ap);

	m88110_patc_clear();

	set_icmd(CMMU_ICMD_INV_UATC);
	set_icmd(CMMU_ICMD_INV_SATC);
	set_dcmd(CMMU_DCMD_INV_UATC);
	set_dcmd(CMMU_DCMD_INV_SATC);

	/* Enable translation */
	ictl |= CMMU_ICTL_MEN | CMMU_ICTL_HTEN;
	dctl |= CMMU_DCTL_MEN | CMMU_DCTL_HTEN;
	set_ictl(ictl);
	set_dctl(dctl);
}

void
m88110_set_uapr(apr_t ap)
{
	set_iuap(ap);
	set_duap(ap);

	set_icmd(CMMU_ICMD_INV_UATC);
	set_dcmd(CMMU_DCMD_INV_UATC);

	/* We need to at least invalidate the TIC, as it is va-addressed */
	set_icmd(CMMU_ICMD_INV_TIC);
}

/*
 *	Functions that invalidate or update TLB entries.
 */

void
m88110_tlbis(cpuid_t cpu, vaddr_t va, pt_entry_t pte)
{
	uint32_t psr, isr, dsr;

#ifdef MULTIPROCESSOR
	struct cpu_info *ci = curcpu();

	if (cpu != ci->ci_cpuid) {
		m197_send_complex_ipi(CI_IPI_TLB_FLUSH_KERNEL, cpu, va, pte);
		return;
	}
#endif

	psr = get_psr();
	set_psr(psr | PSR_IND);

	/*
	 * Probe for an existing TLB entry for the given page, in both
	 * ITLB and DTLB.
	 */

	set_isar(va);
	set_dsar(va);
	set_icmd(CMMU_ICMD_PRB_SUPR);
	set_dcmd(CMMU_DCMD_PRB_SUPR);
	isr = get_isr();
	dsr = get_dsr();

	/*
	 * Update entries with the new PTE, if found.
	 */

	if (isr & CMMU_ISR_PH) {
		set_ippu((va & PATC_VA_MASK) | PATC_SO);
		set_ippl(pte);
	}
	if (dsr & CMMU_DSR_PH) {
		set_dppu((va & PATC_VA_MASK) | PATC_SO);
		set_dppl(pte);
	}

	set_psr(psr);
}

void
m88110_tlbiu(cpuid_t cpu, vaddr_t va, pt_entry_t pte)
{
	u_int32_t psr, isr, dsr;
#ifdef MULTIPROCESSOR
	struct cpu_info *ci = curcpu();

	if (cpu != ci->ci_cpuid) {
		m197_send_complex_ipi(CI_IPI_TLB_FLUSH_USER, cpu, va, pte);
		return;
	}
#endif

	psr = get_psr();
	set_psr(psr | PSR_IND);

	/*
	 * Probe for an existing TLB entry for the given page, in both
	 * ITLB and DTLB.
	 */

	set_isar(va);
	set_dsar(va);
	set_icmd(CMMU_ICMD_PRB_USER);
	set_dcmd(CMMU_DCMD_PRB_USER);
	isr = get_isr();
	dsr = get_dsr();

	/*
	 * Update entries with the new PTE, if found.
	 */

	if (isr & CMMU_ISR_PH) {
		set_ippu(va & PATC_VA_MASK);
		set_ippl(pte);
	}
	if (dsr & CMMU_DSR_PH) {
		set_dppu(va & PATC_VA_MASK);
		set_dppl(pte);
	}

	set_psr(psr);
}

void
m88110_tlbia(cpuid_t cpu)
{
	u_int32_t psr;

	psr = get_psr();
	set_psr(psr | PSR_IND);
	/* always invoked on the current processor, no need to check */
	set_icmd(CMMU_ICMD_INV_UATC);
	set_dcmd(CMMU_DCMD_INV_UATC);
	set_psr(psr);
}

/*
 *	Functions that invalidate caches.
 */

/*
 * 88110 general information #22:
 * ``Issuing a command to flush and invalidate the data cache while the
 *   dcache is disabled (CEN = 0 in dctl) will cause problems.  Do not
 *   flush a disabled data cache.  In general, there is no reason to
 *   perform this operation with the cache disabled, since it may be
 *   incoherent with the proper state of memory.  Before 5.0 the flush
 *   command was treated like a nop when the cache was disabled.  This
 *   is no longer the case.''
 *
 * Since we always enable the data cache, and no cmmu cache operation
 * will occur before we do, it is not necessary to pay attention to this.
 */

#ifdef MULTIPROCESSOR
/*
 * 88110 rev 4.2 errata #17:
 * ``A copyback initiated by a flush page/line with invalidate command,
 *   which is retried on the external bus, and is preceded by a snoop
 *   copyback before the retry cycle occurs, can be incorrectly marked
 *   as invalid, and not copied back to memory.
 *   Suggested fix: Use flush page/line followed by flush page/line with
 *   invalidate to avoid this condition.''
 *
 * This really only matters to us when running a MULTIPROCESSOR kernel
 * (otherwise there is no snooping happening), and given the intrusive
 * changes it requires, we define a specific symbol to enable the suggested
 * workaround.
 */
#define	ENABLE_88110_ERRATA_17
#endif

#define	trunc_cache_line(a)	((a) & ~(MC88110_CACHE_LINE - 1))
#define	round_cache_line(a)	trunc_cache_line((a) + MC88110_CACHE_LINE - 1)

/*
 * invalidate I$, writeback and invalidate D$
 */

void
m88110_cache_wbinv(cpuid_t cpu, paddr_t pa, psize_t size)
{
	u_int32_t psr;
	psize_t count;

	size = round_cache_line(pa + size) - trunc_cache_line(pa);
	pa = trunc_cache_line(pa);

	psr = get_psr();
	set_psr(psr | PSR_IND);

	mc88110_inval_inst();
	while (size != 0) {
		if ((pa & PAGE_MASK) == 0 && size >= PAGE_SIZE) {
#ifdef ENABLE_88110_ERRATA_17
			mc88110_wb_data_page(pa);
#endif
			mc88110_wbinv_data_page(pa);
			count = PAGE_SIZE;
		} else {
#ifdef ENABLE_88110_ERRATA_17
			mc88110_wb_data_line(pa);
#endif
			mc88110_wbinv_data_line(pa);
			count = MC88110_CACHE_LINE;
		}
		pa += count;
		size -= count;
	}

	set_psr(psr);
}

void
m88410_cache_wbinv(cpuid_t cpu, paddr_t pa, psize_t size)
{
	u_int32_t psr;
	psize_t count;
#ifdef MULTIPROCESSOR
	struct cpu_info *ci = curcpu();

	if (cpu != ci->ci_cpuid) {
		m197_send_complex_ipi(CI_IPI_CACHE_FLUSH, cpu, pa, size);
		return;
	}
#endif

	size = round_cache_line(pa + size) - trunc_cache_line(pa);
	pa = trunc_cache_line(pa);

	psr = get_psr();
	set_psr(psr | PSR_IND);

	mc88110_inval_inst();
	while (size != 0) {
		if ((pa & PAGE_MASK) == 0 && size >= PAGE_SIZE) {
#ifdef ENABLE_88110_ERRATA_17
			mc88110_wb_data_page(pa);
#endif
			mc88110_wbinv_data_page(pa);
			count = PAGE_SIZE;
		} else {
#ifdef ENABLE_88110_ERRATA_17
			mc88110_wb_data_line(pa);
#endif
			mc88110_wbinv_data_line(pa);
			count = MC88110_CACHE_LINE;
		}
		pa += count;
		size -= count;
	}

	CMMU_LOCK;
	mc88410_wb();
	CMMU_UNLOCK;

	set_psr(psr);
}

/*
 * writeback D$
 */

void
m88110_dcache_wb(cpuid_t cpu, paddr_t pa, psize_t size)
{
	u_int32_t psr;
	psize_t count;

	size = round_cache_line(pa + size) - trunc_cache_line(pa);
	pa = trunc_cache_line(pa);

	psr = get_psr();
	set_psr(psr | PSR_IND);

	while (size != 0) {
		if ((pa & PAGE_MASK) == 0 && size >= PAGE_SIZE) {
			mc88110_wb_data_page(pa);
			count = PAGE_SIZE;
		} else {
			mc88110_wb_data_line(pa);
			count = MC88110_CACHE_LINE;
		}
		pa += count;
		size -= count;
	}

	set_psr(psr);
}

void
m88410_dcache_wb(cpuid_t cpu, paddr_t pa, psize_t size)
{
	u_int32_t psr;
	psize_t count;
#ifdef MULTIPROCESSOR
	struct cpu_info *ci = curcpu();

	if (cpu != ci->ci_cpuid) {
		m197_send_complex_ipi(CI_IPI_CACHE_FLUSH, cpu, pa, size);
		return;
	}
#endif

	size = round_cache_line(pa + size) - trunc_cache_line(pa);
	pa = trunc_cache_line(pa);

	psr = get_psr();
	set_psr(psr | PSR_IND);

	while (size != 0) {
		if ((pa & PAGE_MASK) == 0 && size >= PAGE_SIZE) {
			mc88110_wb_data_page(pa);
			count = PAGE_SIZE;
		} else {
			mc88110_wb_data_line(pa);
			count = MC88110_CACHE_LINE;
		}
		pa += count;
		size -= count;
	}

	CMMU_LOCK;
	mc88410_wb();
	CMMU_UNLOCK;

	set_psr(psr);
}

/*
 * invalidate I$
 */

void
m88110_icache_inv(cpuid_t cpu, paddr_t pa, psize_t size)
{
	/* atomic so no psr games */
	mc88110_inval_inst();
}

void
m88410_icache_inv(cpuid_t cpu, paddr_t pa, psize_t size)
{
	u_int32_t psr;
#ifdef MULTIPROCESSOR
	struct cpu_info *ci = curcpu();

	if (cpu != ci->ci_cpuid) {
		m197_send_complex_ipi(CI_IPI_ICACHE_FLUSH, cpu, pa, size);
		return;
	}
#endif

	psr = get_psr();
	set_psr(psr | PSR_IND);

	mc88110_inval_inst();
	CMMU_LOCK;
	mc88410_wb();
	CMMU_UNLOCK;

	set_psr(psr);
}

/*
 * writeback D$
 */
void
m88110_cmmu_wb_locked(paddr_t pa, psize_t size)
{
	if (size <= MC88110_CACHE_LINE)
		mc88110_wb_data_line(pa);
	else
		mc88110_wb_data_page(pa);
}

/*
 * writeback and invalidate D$
 */
void
m88110_cmmu_wbinv_locked(paddr_t pa, psize_t size)
{
	if (size <= MC88110_CACHE_LINE) {
#ifdef ENABLE_88110_ERRATA_17
		mc88110_wb_data_line(pa);
#endif
		mc88110_wbinv_data_line(pa);
	} else {
#ifdef ENABLE_88110_ERRATA_17
		mc88110_wb_data_page(pa);
#endif
		mc88110_wbinv_data_page(pa);
	}
}

/*
 * invalidate D$
 */
void
m88110_cmmu_inv_locked(paddr_t pa, psize_t size)
{
	/*
	 * I'd love to do this...

	if (size <= MC88110_CACHE_LINE)
		mc88110_inval_data_line(pa);
	else
		mc88110_inval_data_page(pa);

	 * ... but there is no mc88110_inval_data_page(). Callers know
	 * this and always do this line-by-line.
	 */
	mc88110_inval_data_line(pa);
}

/*
 * High level cache handling functions (used by bus_dma).
 */

#ifdef MULTIPROCESSOR
void
m88110_dma_cachectl_local(paddr_t _pa, psize_t _size, int op)
{
	/* Obviously nothing to do. */
}
#endif

void
m88110_dma_cachectl(paddr_t _pa, psize_t _size, int op)
{
	u_int32_t psr;
	paddr_t pa;
	psize_t size, count;
	void (*flusher)(paddr_t, psize_t);
	uint8_t lines[2 * MC88110_CACHE_LINE];
	paddr_t pa1, pa2;
	psize_t sz1, sz2;

	pa = trunc_cache_line(_pa);
	size = round_cache_line(_pa + _size) - pa;
	sz1 = sz2 = 0;

	switch (op) {
	case DMA_CACHE_SYNC:
		flusher = m88110_cmmu_wb_locked;
		break;
	case DMA_CACHE_SYNC_INVAL:
		flusher = m88110_cmmu_wbinv_locked;
		break;
	default:
	case DMA_CACHE_INV:
		pa1 = pa;
		sz1 = _pa - pa1;
		pa2 = _pa + _size;
		sz2 = pa + size - pa2;
		flusher = m88110_cmmu_inv_locked;
		break;
	}

	psr = get_psr();
	set_psr(psr | PSR_IND);

	if (op != DMA_CACHE_SYNC)
		mc88110_inval_inst();
	if (flusher == m88110_cmmu_inv_locked) {
		/*
		 * Preserve the data from the incomplete cache lines about
		 * to be invalidated, if necessary.
		 */
		if (sz1 != 0)
			bcopy((void *)pa1, lines, sz1);
		if (sz2 != 0)
			bcopy((void *)pa2, lines + MC88110_CACHE_LINE, sz2);

		while (size != 0) {
			count = MC88110_CACHE_LINE;
			(*flusher)(pa, count);
			pa += count;
			size -= count;
		}

		/*
		 * Restore data from the incomplete cache lines having
		 * been invalidated, if necessary.
		 */
		if (sz1 != 0)
			bcopy(lines, (void *)pa1, sz1);
		if (sz2 != 0)
			bcopy(lines + MC88110_CACHE_LINE, (void *)pa2, sz2);
		if (sz1 != 0)
			m88110_cmmu_wbinv_locked(pa1, MC88110_CACHE_LINE);
		if (sz2 != 0) {
			pa2 = trunc_cache_line(pa2);
			m88110_cmmu_wbinv_locked(pa2, MC88110_CACHE_LINE);
		}
	} else {
		while (size != 0) {
			count = (pa & PAGE_MASK) == 0 && size >= PAGE_SIZE ?
			    PAGE_SIZE : MC88110_CACHE_LINE;
			(*flusher)(pa, count);
			pa += count;
			size -= count;
		}
	}

	set_psr(psr);
}

void
m88410_dma_cachectl_local(paddr_t _pa, psize_t _size, int op)
{
	u_int32_t psr;
	paddr_t pa;
	psize_t size, count;
	void (*flusher)(paddr_t, psize_t);
	uint8_t lines[2 * MC88110_CACHE_LINE];
	paddr_t pa1, pa2;
	psize_t sz1, sz2;

	pa = trunc_cache_line(_pa);
	size = round_cache_line(_pa + _size) - pa;
	sz1 = sz2 = 0;

	switch (op) {
	case DMA_CACHE_SYNC:
		flusher = m88110_cmmu_wb_locked;
		break;
	case DMA_CACHE_SYNC_INVAL:
		flusher = m88110_cmmu_wbinv_locked;
		break;
	default:
	case DMA_CACHE_INV:
		pa1 = pa;
		sz1 = _pa - pa1;
		pa2 = _pa + _size;
		sz2 = pa + size - pa2;
		flusher = m88110_cmmu_inv_locked;
		break;
	}

	psr = get_psr();
	set_psr(psr | PSR_IND);

	if (op != DMA_CACHE_SYNC)
		mc88110_inval_inst();
	if (flusher == m88110_cmmu_inv_locked) {
		/*
		 * Preserve the data from the incomplete cache lines about
		 * to be invalidated, if necessary.
		 */
		if (sz1 != 0)
			bcopy((void *)pa1, lines, sz1);
		if (sz2 != 0)
			bcopy((void *)pa2, lines + MC88110_CACHE_LINE, sz2);

		while (size != 0) {
			count = MC88110_CACHE_LINE;
			(*flusher)(pa, count);
			pa += count;
			size -= count;
		}

		/*
		 * Restore data from the incomplete cache lines having
		 * been invalidated, if necessary.
		 */
		if (sz1 != 0)
			bcopy(lines, (void *)pa1, sz1);
		if (sz2 != 0)
			bcopy(lines + MC88110_CACHE_LINE, (void *)pa2, sz2);
		if (sz1 != 0)
			m88110_cmmu_wbinv_locked(pa1, MC88110_CACHE_LINE);
		if (sz2 != 0) {
			pa2 = trunc_cache_line(pa2);
			m88110_cmmu_wbinv_locked(pa2, MC88110_CACHE_LINE);
		}
	} else {
		while (size != 0) {
			count = (pa & PAGE_MASK) == 0 && size >= PAGE_SIZE ?
			    PAGE_SIZE : MC88110_CACHE_LINE;
			(*flusher)(pa, count);
			pa += count;
			size -= count;
		}
	}


	CMMU_LOCK;
	if (op == DMA_CACHE_SYNC) {
		/*
		 * Enlarge the range to integral pages, to match the
		 * 88410 operation granularity.
		 */
		pa = trunc_page(_pa);
		size = trunc_page(_pa + _size) - pa;

		while (size != 0) {
			mc88410_wb_page(pa);
			pa += PAGE_SIZE;
			size -= PAGE_SIZE;
		}
	} else {
		mc88410_wbinv();
	}
	CMMU_UNLOCK;

	set_psr(psr);
}

void
m88410_dma_cachectl(paddr_t _pa, psize_t _size, int op)
{
#ifdef MULTIPROCESSOR
	paddr_t pa;
	psize_t size;
#endif

	m88410_dma_cachectl_local(_pa, _size, op);
#ifdef MULTIPROCESSOR
	/*
	 * Since snooping is enabled, all we need is to propagate invalidate
	 * requests if necessary.
	 *
	 * Note that we round the range to integral cache lines, in order
	 * to avoid trying to preserve incomplete lines - this has already
	 * been done by the cachectl_local() call above, and as long as one
	 * cpu has the correct data in its cache, it's not lost.
	 */
	if (op != DMA_CACHE_SYNC) {
		pa = trunc_cache_line(_pa);
		size = round_cache_line(_pa + _size) - pa;
		m197_broadcast_complex_ipi(CI_IPI_DMA_CACHECTL, pa, size);
	}
#endif
}
@


1.83
log
@Allow initial device mappings (from pmap_table) to be backed up by BATC.
Use this on luna88k to map the bitmap planes of the frame buffer used by
the driver. 10% speedup under X.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.82 2013/11/03 09:42:55 miod Exp $	*/
@


1.82
log
@Even saner kernel layout, so that .rodata can be batc mapped by a read-only
dbatc. Add batc mapping support for 88110 systems as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.81 2013/11/02 23:10:30 miod Exp $	*/
d184 4
a187 2
void m88110_dbatc_set(uint, uint32_t);
void m88110_ibatc_set(uint, uint32_t);
d194 1
d196 1
a196 1
m88110_dbatc_set(uint batno, uint32_t val)
d202 1
d204 1
a204 1
m88110_ibatc_set(uint batno, uint32_t val)
d321 1
a321 1
	uint32_t batc, proto;
d351 1
a351 1
		m88110_ibatc_set(batcno, batc);
d374 1
a374 1
		m88110_dbatc_set(batcno, batc);
d378 5
@


1.81
log
@Create the initial page tables in the area between the end of the firmware
data area and the kernel image, whenever possible.

On 88100/88200 systems, use BATC mappings to map the kernel text (and the
kernel data for non-MULTIPROCESSOR kernels). 88110 to follow soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.80 2013/08/15 19:32:12 miod Exp $	*/
d184 3
a186 1
void patc_clear(void);
d193 1
a193 1
patc_clear(void)
d195 15
a209 1
	int i;
d211 2
a212 2
	for (i = 0; i < 32; i++) {
		set_dir(i << 5);
d216 1
a216 1
		set_iir(i << 5);
d315 60
d408 1
a408 1
	patc_clear();
d566 1
a566 1
	patc_clear();
@


1.80
log
@Be sure to always invoke cache routines with properly rounded addresses;
the bus_dmamap_sync() bowels would sometimes use incorrectly rounded
addresses, which has been apparently harmless so far, but better be safe
than sorry.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.79 2013/05/17 22:33:25 miod Exp $	*/
d97 1
d131 1
d159 1
d294 5
@


1.79
log
@Extend cmmu routines to return the caching mode to use for page tables.

Alter the 88200-specific code to enforce cache-inhibited page tables for
extremely old 88200 versions, and to disable write-back caching on systems
where xmem instructions do not behave correctly when applied to write-back
cached addresses.

No change introduced on 88110 systems, as well as most 88100 systems; the
affected systems are 88100 systems with 88100 revision < 10 and/or 88200
revision < 7; that is, only early MVME181 and MVME188 (not 188A) systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.78 2013/02/19 21:02:06 miod Exp $	*/
d970 2
a971 1
		if (sz2 != 0)
d973 1
d1051 2
a1052 1
		if (sz2 != 0)
d1054 1
@


1.78
log
@Introduce a new cmmu method to return the preferred cache mode bits for the
kernel APR. Return write-back for every design but those involving 88410,
where write through is returned.

Apparently the use of writeback on single-processor kernels using 88410 (197SP,
197DP) has only been working by fat chance, and the last two years of uvm
changes, as well as the switch to ELF (causing kernel rodata to move `up')
exposes silent memory corruption on (88410-size) aliased addresses.
(I am guilty of not using my 197DP board much after making 197LE write-back
capable, as 197LE turned out to be faster and more stable, for I would have
noticed this earlier).

Further thought needs to happen about this. It might be possible to switch to
writeback by default again as long as bus_dma maps things write-through on
88410 designs, and perhaps with a part of the kernel mapped with a write-through
BATC, since BATC have precedence upon page tables. Right now I'm trying to get
a stable release out of the door.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.77 2013/02/17 18:07:36 miod Exp $	*/
d103 3
a105 2
apr_t	m88110_kapr_cmode(void);
apr_t	m88410_kapr_cmode(void);
d134 2
a135 1
	m88110_kapr_cmode,
d161 2
a162 1
	m88410_kapr_cmode,
d451 1
a451 1
m88110_kapr_cmode(void)
d457 7
a463 1
m88410_kapr_cmode(void)
d1095 1
a1095 1
	 * Since snooping is enabled, all we need is to propagate invalidate 
@


1.77
log
@Constify struct cmmu.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.76 2011/10/25 18:38:06 miod Exp $	*/
d103 2
d133 1
d159 1
d447 12
d1038 4
@


1.76
log
@Replace the naive 88110 tlb update code, which would always invalidate the
whole tlb (32 of 'em), with smarter `tlb probe and update with new pte if tlb
match found' code. This makes the 88110-specific pmap_update() unnecessary, as
updates are no longer aggregated to avoid the number of flushes. This also
makes tlb handling similar between 88100 and 88110, from the pmap's point of
view, so there is no need to use different routines.

No impact on 88100, no user-noticeable performance change on 88100 GENERIC,
slight improvement on 88110 GENERIC.MP.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.75 2011/10/09 17:02:15 miod Exp $	*/
d125 1
a125 1
struct cmmu_p cmmu88110 = {
d150 1
a150 1
struct cmmu_p cmmu88410 = {
@


1.75
log
@Correctly handle invalidate of partial cache lines, for the Nth time.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.74 2011/04/19 21:25:28 miod Exp $	*/
d105 3
a107 2
void	m88110_tlb_inv(cpuid_t, u_int, vaddr_t);
void	m88110_tlb_inv_all(cpuid_t);
d133 3
a135 2
	m88110_tlb_inv,
	m88110_tlb_inv_all,
d158 3
a160 2
	m88110_tlb_inv,
	m88110_tlb_inv_all,
d485 1
a485 1
 *	Functions that invalidate TLB entries.
d489 1
a489 1
m88110_tlb_inv(cpuid_t cpu, u_int kernel, vaddr_t vaddr)
d491 2
a492 1
	u_int32_t psr;
d497 1
a497 2
		m197_send_ipi(kernel ?
		    CI_IPI_TLB_FLUSH_KERNEL : CI_IPI_TLB_FLUSH_USER, cpu);
d505 67
a571 6
	if (kernel) {
		set_icmd(CMMU_ICMD_INV_SATC);
		set_dcmd(CMMU_DCMD_INV_SATC);
	} else {
		set_icmd(CMMU_ICMD_INV_UATC);
		set_dcmd(CMMU_DCMD_INV_UATC);
d578 1
a578 1
m88110_tlb_inv_all(cpuid_t cpu)
@


1.74
log
@Disable the 88110 branch prediction logic unconditionnaly on all 88110
revisions; despite what the ``official'' (yet unpublished, confidential
proprietary, will cause a tree to fall on your house if you quote it, etc)
errata says, disabling data decoupling is not enough to workaround its
malfunction in processor revisions 5.x.

Enough missing-SFU instructions (each causing a `disabled SFU' trap) in a
tight loop will eventually (but quickly) trigger the (unrecoverable, not even
by NMI) processor hang.

Of course, most such instructions are not privileged, and can be easily issued
by an evil userland process; crashme happens to be a good example of this, when
invoked with the proper settings (which are left as an exercise to the reader).

Now, can I have my hair back? Come on! Please... pretty please... with sugar on
top... people are looking at my head, you know.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.73 2011/01/05 22:16:16 miod Exp $	*/
d879 4
@


1.73
log
@Make copypage() and zeropage() per-cpu function pointers, and use a
different version on 88110, which does load allocate of
to-be-completely-overwritten cache lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.72 2011/01/05 22:14:39 miod Exp $	*/
d299 1
d301 1
d357 5
a361 7
	 * So since branch prediction appears to give better performance
	 * than data cache decoupling, and it is not known whether the
	 * problem has been understood better and thus the conditions
	 * narrowed on 5.1, or changes between 4.2 and 5.1 only restrict
	 * the conditions on which it may occur, we'll enable branch
	 * prediction on 5.1 processors and data cache decoupling on
	 * earlier versions.
d363 1
d367 1
@


1.72
log
@Now that pmap_copy_page() no longer needs to flush a couple contiguous tlb
entries, drop the count parameter to cmmu_tlb_inv(), and introduce
cmmu_tlb_inv_all() to drop all user tlb entries (to be used during context
switches).
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.71 2011/01/02 17:55:27 miod Exp $	*/
d92 3
d296 1
d301 2
d376 3
@


1.71
log
@Figure out how much L2 cache is available on 88410-blessed designs, and
report it in dmesg.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.70 2011/01/01 22:09:33 miod Exp $	*/
d102 2
a103 2
void	m88110_tlb_inv(cpuid_t, u_int, vaddr_t, u_int);
void	m88410_tlb_inv(cpuid_t, u_int, vaddr_t, u_int);
d130 1
d154 1
a473 3
/*
 *	flush any tlb
 */
d475 1
a475 1
m88110_tlb_inv(cpuid_t cpu, u_int kernel, vaddr_t vaddr, u_int count)
d499 13
@


1.70
log
@Now that we __HAVE_PMAP_DIRECT, it gets easy to simply save partial cache
lines and restore them after invalidating rounded-to-cacheline-boundary ranges.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.69 2011/01/01 20:58:32 miod Exp $	*/
a89 1
#ifdef MULTIPROCESSOR
a90 1
#endif
d163 3
d232 1
a232 1
		printf("M88110 version 0x%x, 8K I/D caches", procvers);
d241 2
d244 2
a245 2
	/* XXX how to get its size? */
	printf("cpu%d: external M88410 cache controller\n", cpu_number());
d374 2
d381 21
d403 1
d405 1
d407 10
@


1.69
log
@Better errata #17 handling logic. Only concerns MULTIPROCESSOR kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.68 2010/12/31 21:16:31 miod Exp $	*/
d4 1
a4 1
 * Copyright (c) 2010 Miodrag Vallat.
d763 3
d769 1
d773 1
a773 11
                /*
                 * If the range does not span complete cache lines,
                 * force invalidation of the incomplete lines.  The
                 * rationale behind this is that these incomplete lines
                 * will probably need to be invalidated later, and
                 * we do not want to risk having stale data in the way.
                 */
		if (pa != _pa || size != _size || size >= PAGE_SIZE)
			flusher = m88110_cmmu_wbinv_locked;
		else
			flusher = m88110_cmmu_wb_locked;
d779 5
a787 7
#ifdef ENABLE_88110_ERRATA_17
	if (flusher == m88110_cmmu_wbinv_locked) {
		pa = trunc_page(_pa);
		size = trunc_page(_pa + _size) - pa;
	}
#endif

d794 9
d809 9
d838 3
a840 1
	void (*ext_flusher)(void);
d842 3
a844 11
	if (op == DMA_CACHE_SYNC) {
		/*
		 * Enlarge the range to integral pages, to match the
		 * 88410 operation granularity.
		 */
		pa = trunc_page(_pa);
		size = trunc_page(_pa + _size) - pa;
	} else {
		pa = trunc_cache_line(_pa);
		size = round_cache_line(_pa + _size) - pa;
	}
d848 1
a848 11
                /*
                 * If the range does not span complete cache lines,
                 * force invalidation of the incomplete lines.  The
                 * rationale behind this is that these incomplete lines
                 * will probably need to be invalidated later, and
                 * we do not want to risk having stale data in the way.
                 */
		if (pa != _pa || size != _size || size >= PAGE_SIZE)
			flusher = m88110_cmmu_wbinv_locked;
		else
			flusher = m88110_cmmu_wb_locked;
a851 1
		ext_flusher = mc88410_wbinv;
d854 5
a859 5
#ifdef notyet
		ext_flusher = mc88410_inv;
#else
		ext_flusher = mc88410_wbinv;
#endif
a862 7
#ifdef ENABLE_88110_ERRATA_17
	if (flusher == m88110_cmmu_wbinv_locked) {
		pa = trunc_page(_pa);
		size = trunc_page(_pa + _size) - pa;
	}
#endif

d869 9
d884 9
d906 7
d919 1
a919 1
		(*ext_flusher)();
d927 1
a927 1
m88410_dma_cachectl(paddr_t pa, psize_t size, int op)
d929 6
a934 1
	m88410_dma_cachectl_local(pa, size, op);
d939 5
d945 3
a947 1
	if (op != DMA_CACHE_SYNC)
d949 1
@


1.68
log
@Yet another rework of the cache flushing routines. Fixes some bugs, probably
introduces new ones as well. Main highlights are:
- 88200 lines which got marked as unusable by the BUG selftests will not be
  reenabled at CMMU initialization time.
- better granularity in the 88110/88410 routines, to operate on ranges closer
  to the actual requested area, errata permitting.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.67 2010/12/31 21:12:16 miod Exp $	*/
d495 1
a495 7
 * changes it requires (see the comment about invalidates being turned
 * into flushes with invalidate in m88110_cmmu_inv_locked below), as
 * well as the small performance impact it has), we define a specific
 * symbol to enable the suggested workaround.
 *
 * Also, note that m88110_dma_cachectl() is never invoked when running on
 * a multiprocessor system, therefore does not need to implement this
a513 4
#ifdef ENABLE_88110_ERRATA_17
	size = round_page(pa + size) - trunc_page(pa);
	pa = trunc_page(pa);
#else
a515 1
#endif
d522 1
d524 2
a525 5
		mc88110_wb_data_page(pa);
		mc88110_wbinv_data_page(pa);
		count = PAGE_SIZE;
#else
		if ((pa & PAGE_MASK) == 0 && size >= PAGE_SIZE) {
d529 3
a534 1
#endif
a555 4
#ifdef ENABLE_88110_ERRATA_17
	size = round_page(pa + size) - trunc_page(pa);
	pa = trunc_page(pa);
#else
a557 1
#endif
d564 1
d566 2
a567 5
		mc88110_wb_data_page(pa);
		mc88110_wbinv_data_page(pa);
		count = PAGE_SIZE;
#else
		if ((pa & PAGE_MASK) == 0 && size >= PAGE_SIZE) {
d571 3
a576 1
#endif
d711 1
d713 2
a714 4
	mc88110_wb_data_page(pa);
	mc88110_wbinv_data_page(pa);
#else
	if (size <= MC88110_CACHE_LINE)
d716 4
a719 1
	else
d721 1
a721 1
#endif
@


1.67
log
@Introduce a new cmmu routine, for page writebacks without invalidate. Will be
used two commits from now.
@
text
@d1 17
a17 1
/*	$OpenBSD: m88110.c,v 1.66 2010/12/31 20:54:21 miod Exp $	*/
d167 3
a169 3
void m88110_cmmu_sync_cache(paddr_t, psize_t);
void m88110_cmmu_sync_inval_cache(paddr_t, psize_t);
void m88110_cmmu_inval_cache(paddr_t, psize_t);
d377 1
a377 29
#if 0
	mc88410_inval();	/* clear external data cache */
#else
	/*
	 * We can't invalidate the 88410 cache without flushing it first;
	 * this is probably due to either an error in the cpu-to-88410
	 * communication protocol, or to a bug in the '410 (but since I
	 * do not know how to get its revision, I can't tell whether this
	 * is the obscure v1 bug or not).
	 *
	 * Since we can't flush random data either, fill the secondary
	 * cache first, before flushing it.
	 *
	 * The smallest 88410 cache line is 32 bytes, and the largest size
	 * is 1MB.
	 */
	{
		vaddr_t va;
		uint32_t junk = 0;

		for (va = 0; va < 1024 * 1024; va += 32)
			junk += *(uint32_t *)va;

		/* to make sure the above loop isn't optimized away */
		mc88110_wbinv_data_page(junk & PAGE_SIZE);
	}
	mc88410_wb();
	mc88410_inval();
#endif
d496 1
a496 1
 * into flushes with invalidate in m88110_cmmu_inval_cache below), as
d511 1
a511 1
 * Flush both Instruction and Data caches
d518 9
d532 17
a548 1
	mc88110_wb_data();
d557 1
d567 8
d579 18
a596 2
	/* flush all data to avoid errata invalidate */
	mc88110_wb_data();
d710 1
a710 1
 * Sync dcache - icache is never dirty but needs to be invalidated as well.
a711 1

d713 1
a713 1
m88110_cmmu_sync_cache(paddr_t pa, psize_t size)
a714 3
#ifdef ENABLE_88110_ERRATA_17
	mc88110_wb_data_page(pa);
#else
a718 1
#endif
d721 3
d725 1
a725 1
m88110_cmmu_sync_inval_cache(paddr_t pa, psize_t size)
d738 3
d742 1
a742 1
m88110_cmmu_inval_cache(paddr_t pa, psize_t size)
d753 1
a753 2
	 * this and turn invalidates into syncs with invalidate for page
	 * or larger areas.
d783 11
a793 1
		flusher = m88110_cmmu_sync_cache;
d796 1
a796 1
		flusher = m88110_cmmu_sync_inval_cache;
d799 1
a799 4
		if (pa != _pa || size != _size || size >= PAGE_SIZE)
			flusher = m88110_cmmu_sync_inval_cache;
		else
			flusher = m88110_cmmu_inval_cache;
d803 7
d815 15
a829 8
	while (size != 0) {
		count = (pa & PAGE_MASK) == 0 && size >= PAGE_SIZE ?
		    PAGE_SIZE : MC88110_CACHE_LINE;

		(*flusher)(pa, count);

		pa += count;
		size -= count;
d836 1
a836 1
m88410_dma_cachectl_local(paddr_t pa, psize_t size, int op)
d839 2
a840 1
	psize_t count;
d844 12
d858 11
a868 4
#if 0
		flusher = m88110_cmmu_sync_cache;
		ext_flusher = mc88410_wb;
#endif
d871 1
a871 1
		flusher = m88110_cmmu_sync_inval_cache;
d875 1
a875 5
#ifdef ENABLE_88110_ERRATA_17
		flusher = m88110_cmmu_sync_inval_cache;
#else
		flusher = m88110_cmmu_inval_cache;
#endif
d877 1
a877 1
		ext_flusher = mc88410_inval;
d884 7
d894 3
a896 2
	if (op == DMA_CACHE_SYNC) {
		CMMU_LOCK;
d898 4
a901 4
			m88110_cmmu_sync_cache(pa, PAGE_SIZE);
			mc88410_wb_page(pa);
			pa += PAGE_SIZE;
			size -= PAGE_SIZE;
a902 1
		CMMU_UNLOCK;
a903 1
		mc88110_inval_inst();
a904 3
#ifdef ENABLE_88110_ERRATA_17
			count = PAGE_SIZE;
#else
a906 2
#endif

a907 1

d911 11
a921 1
		CMMU_LOCK;
a922 1
		CMMU_UNLOCK;
d924 1
d930 1
a930 1
m88410_dma_cachectl(paddr_t _pa, psize_t _size, int op)
a931 26
	paddr_t pa;
	psize_t size;

#ifdef ENABLE_88110_ERRATA_17
	pa = trunc_page(_pa);
	size = round_page(_pa + _size) - pa;

#if 0 /* not required since m88410_dma_cachectl_local() behaves identically */
	if (op == DMA_CACHE_INV)
		op = DMA_CACHE_SYNC_INVAL;
#endif
#else
	if (op == DMA_CACHE_SYNC) {
		pa = trunc_page(_pa);
		size = round_page(_pa + _size) - pa;
	} else {
		pa = trunc_cache_line(_pa);
		size = round_cache_line(_pa + _size) - pa;

		if (op == DMA_CACHE_INV) {
			if (pa != _pa || size != _size || size >= PAGE_SIZE)
				op = DMA_CACHE_SYNC_INVAL;
		}
	}
#endif

@


1.66
log
@Standardize cache handling functions and defines to use wb/wbinv/inv instead
of flush/sync/inval. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.65 2010/06/22 17:42:37 miod Exp $	*/
d92 2
d117 1
d140 1
d567 71
a637 1
 * Flush Instruction caches
@


1.65
log
@Since our caches are snooping, we only need to broadcast cache invalidates
on 88110 designs. Brings a ~8% speedup on GENERIC.MP on 197DP.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.64 2010/04/17 22:10:13 miod Exp $	*/
d88 6
a93 6
void	m88110_flush_tlb(cpuid_t, u_int, vaddr_t, u_int);
void	m88410_flush_tlb(cpuid_t, u_int, vaddr_t, u_int);
void	m88110_flush_cache(cpuid_t, paddr_t, psize_t);
void	m88410_flush_cache(cpuid_t, paddr_t, psize_t);
void	m88110_flush_inst_cache(cpuid_t, paddr_t, psize_t);
void	m88410_flush_inst_cache(cpuid_t, paddr_t, psize_t);
d113 3
a115 3
	m88110_flush_tlb,
	m88110_flush_cache,
	m88110_flush_inst_cache,
d135 3
a137 3
	m88110_flush_tlb,
	m88410_flush_cache,
	m88410_flush_inst_cache,
d381 1
a381 1
		mc88110_sync_data_page(junk & PAGE_SIZE);
d383 1
a383 1
	mc88410_flush();
d446 1
a446 1
m88110_flush_tlb(cpuid_t cpu, u_int kernel, vaddr_t vaddr, u_int count)
d523 1
a523 1
m88110_flush_cache(cpuid_t cpu, paddr_t pa, psize_t size)
d531 1
a531 1
	mc88110_flush_data();
d537 1
a537 1
m88410_flush_cache(cpuid_t cpu, paddr_t pa, psize_t size)
d554 1
a554 1
	mc88110_flush_data();
d556 1
a556 1
	mc88410_flush();
d567 1
a567 1
m88110_flush_inst_cache(cpuid_t cpu, paddr_t pa, psize_t size)
d574 1
a574 1
m88410_flush_inst_cache(cpuid_t cpu, paddr_t pa, psize_t size)
d591 1
a591 1
	mc88410_flush();
d605 1
a605 1
	mc88110_flush_data_page(pa);
d608 1
a608 1
		mc88110_flush_data_line(pa);
d610 1
a610 1
		mc88110_flush_data_page(pa);
d618 2
a619 2
	mc88110_flush_data_page(pa);
	mc88110_sync_data_page(pa);
d622 1
a622 1
		mc88110_sync_data_line(pa);
d624 1
a624 1
		mc88110_sync_data_page(pa);
d714 1
a714 1
		ext_flusher = mc88410_flush;
d719 1
a719 1
		ext_flusher = mc88410_sync;
d730 1
a730 1
		ext_flusher = mc88410_sync;
d742 1
a742 1
			mc88410_flush_page(pa);
@


1.64
log
@Work around yet another MC88110 errata, causing cache writebacks upon snooping
to sometimes fail, by only using cache operation sequences known not to
trigger the errata, at the expense of a small (barely noticeable) performance
hit.

This workaround is only enabled when compiling a MULTIPROCESSOR kernel, since
the problem will not arise when using only one processor.

This change, refined over a few months, finally makes GENERIC.MP run stably
on 197DP systems. Of course, just writing this is enough to invoke Murphy's
law and make it fail again in an even more obscure and rare way...
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.63 2009/04/19 17:56:13 miod Exp $	*/
d650 8
d801 6
a806 1
	m197_broadcast_complex_ipi(CI_IPI_DMA_CACHECTL, pa, size | op);
a808 8

#ifdef MULTIPROCESSOR
void
m88110_dma_cachectl_local(paddr_t _pa, psize_t _size, int op)
{
	/* Obviously nothing to do. */
}
#endif
@


1.63
log
@Rename max_cpus to ncpusfound and compute it regardless of option
MULTIPROCESSOR.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.62 2009/02/16 23:03:33 miod Exp $	*/
d491 24
d604 3
d611 1
d617 4
d625 1
d714 3
d718 1
d742 3
d747 1
d768 9
d789 1
@


1.62
log
@More 88110 SMP work. Contains, horribly entangled:
- dma_cachectl() split into a ``local cpu only'' and ``all cpus'', and an ipi
  to broadcast ``local dma_cachectl'' is added.
- cpu_info fields are rearranged, to have the 88100-specific information
  and the 88110-specific information overlap, and has many more 88110
  ugly things.
- more ipi handling in the 197-specific area. Since it is not possible to
  have the second processor receive any hardware interrupt (selection
  is done on a level basis via ISEL, and we definitely do not want the
  main cpu to lose interrupts), the best we can do is to inflict ourselves
  a soft interrupt for late ipi processing. It gets used for softclock and
  hardclock on the secondary processor, but since the soft interrupt
  dispatcher doesn't have an exception frame, we have to remember parts
  of it to build a fake clockframe from the soft ipi handler (ugly but
  works).

This now lets GENERIC.MP run a few userland binaries before bugs trigger.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.61 2009/02/13 23:29:38 miod Exp $	*/
d170 1
a170 1
	max_cpus = 1;
a175 1
#ifdef MULTIPROCESSOR
d186 1
a186 1
		max_cpus = 1;
d188 1
a188 5
		max_cpus = 2;
	/* XXX what about 01-W3977B QP boards??? */
#else
	max_cpus = 1;
#endif
@


1.61
log
@Allow IPIs on the secondary processors later in the bootstrap process, when
we are sure the NMI stack exists.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.60 2009/02/01 00:52:19 miod Exp $	*/
d95 1
d97 1
d118 1
d140 1
d667 1
a667 1
m88410_dma_cachectl(paddr_t _pa, psize_t _size, int op)
d670 1
a670 2
	paddr_t pa;
	psize_t size, count;
a673 3
	pa = trunc_cache_line(_pa);
	size = round_cache_line(_pa + _size) - pa;

d686 1
a686 5
		if (pa != _pa || size != _size || size >= PAGE_SIZE) {
			flusher = m88110_cmmu_sync_inval_cache;
			ext_flusher = mc88410_sync;
		} else {
			flusher = m88110_cmmu_inval_cache;
d688 1
a688 1
			ext_flusher = mc88410_inval;
d690 1
a690 1
			ext_flusher = mc88410_sync;
a691 1
		}
a698 2
		pa = trunc_page(_pa);
		size = round_page(_pa + _size) - pa;
d725 33
@


1.60
log
@Remove dma_cachectl() and rename dma_cachectl_pa() to dma_cachectl() now that
the old vs(4) code is gone.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.59 2009/01/29 22:15:27 miod Exp $	*/
d224 7
a387 7

#ifdef MULTIPROCESSOR
	/*
	 * Mark us as allowing IPIs now.
	 */
	*(volatile u_int8_t *)(BS_BASE + BS_CPINT) = BS_CPI_ICLR | BS_CPI_IEN;
#endif
@


1.59
log
@The ``flush before inval'' 88410 workaround needs to be done in
m88410_initialize_cpu() as well. Since we can't flush unknown data, just
make sure all 88410 lines are filled with valid data before flushing it.

This should fix the spurious ``197DP hangs or loops on osiop errors after
autoconf'' issue I've been seeing.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.58 2008/01/02 19:59:31 miod Exp $	*/
d94 2
a95 4
void	m88110_dma_cachectl(pmap_t, vaddr_t, vsize_t, int);
void	m88410_dma_cachectl(pmap_t, vaddr_t, vsize_t, int);
void	m88110_dma_cachectl_pa(paddr_t, psize_t, int);
void	m88410_dma_cachectl_pa(paddr_t, psize_t, int);
a114 1
	m88110_dma_cachectl_pa,
a135 1
	m88410_dma_cachectl_pa,
d619 1
a619 124
m88110_dma_cachectl(pmap_t pmap, vaddr_t _va, vsize_t _size, int op)
{
	u_int32_t psr;
	vaddr_t va;
	paddr_t pa;
	psize_t size, count;
	void (*flusher)(paddr_t, psize_t);

	va = trunc_cache_line(_va);
	size = round_cache_line(_va + _size) - va;

	switch (op) {
	case DMA_CACHE_SYNC:
		flusher = m88110_cmmu_sync_cache;
		break;
	case DMA_CACHE_SYNC_INVAL:
		flusher = m88110_cmmu_sync_inval_cache;
		break;
	default:
		if (va != _va || size != _size || size >= PAGE_SIZE)
			flusher = m88110_cmmu_sync_inval_cache;
		else
			flusher = m88110_cmmu_inval_cache;
		break;
	}

	psr = get_psr();
	set_psr(psr | PSR_IND);

	if (op != DMA_CACHE_SYNC)
		mc88110_inval_inst();
	while (size != 0) {
		count = (va & PAGE_MASK) == 0 && size >= PAGE_SIZE ?
		    PAGE_SIZE : MC88110_CACHE_LINE;

		if (pmap_extract(pmap, va, &pa) != FALSE) {
			(*flusher)(pa, count);
		}

		va += count;
		size -= count;
	}

	set_psr(psr);
}

void
m88410_dma_cachectl(pmap_t pmap, vaddr_t _va, vsize_t _size, int op)
{
	u_int32_t psr;
	vaddr_t va;
	paddr_t pa;
	psize_t size, count;
	void (*flusher)(paddr_t, psize_t);
	void (*ext_flusher)(void);

	va = trunc_cache_line(_va);
	size = round_cache_line(_va + _size) - va;

	switch (op) {
	case DMA_CACHE_SYNC:
#if 0
		flusher = m88110_cmmu_sync_cache;
		ext_flusher = mc88410_flush;
#endif
		break;
	case DMA_CACHE_SYNC_INVAL:
		flusher = m88110_cmmu_sync_inval_cache;
		ext_flusher = mc88410_sync;
		break;
	default:
		if (va != _va || size != _size || size >= PAGE_SIZE) {
			flusher = m88110_cmmu_sync_inval_cache;
			ext_flusher = mc88410_sync;
		} else {
			flusher = m88110_cmmu_inval_cache;
#ifdef notyet
			ext_flusher = mc88410_inval;
#else
			ext_flusher = mc88410_sync;
#endif
		}
		break;
	}

	psr = get_psr();
	set_psr(psr | PSR_IND);

	if (op == DMA_CACHE_SYNC) {
		va = trunc_page(_va);
		size = round_page(_va + _size) - va;
		CMMU_LOCK;
		while (size != 0) {
			if (pmap_extract(pmap, va, &pa) != FALSE) {
				m88110_cmmu_sync_cache(pa, PAGE_SIZE);
				mc88410_flush_page(pa);
			}
			va += PAGE_SIZE;
			size -= PAGE_SIZE;
		}
		CMMU_UNLOCK;
	} else {
		mc88110_inval_inst();
		while (size != 0) {
			count = (va & PAGE_MASK) == 0 && size >= PAGE_SIZE ?
			    PAGE_SIZE : MC88110_CACHE_LINE;

			if (pmap_extract(pmap, va, &pa) != FALSE) {
				(*flusher)(pa, count);
			}

			va += count;
			size -= count;
		}
		CMMU_LOCK;
		(*ext_flusher)();
		CMMU_UNLOCK;
	}

	set_psr(psr);
}

void
m88110_dma_cachectl_pa(paddr_t _pa, psize_t _size, int op)
d663 1
a663 1
m88410_dma_cachectl_pa(paddr_t _pa, psize_t _size, int op)
@


1.58
log
@Do not invalidate the 88410 cache without flushing it first; this is
probably due either to an error in the cpu-to-88410 communication protocol,
or to a bug in the '410 (but since I do not know how to get its revision,
I can't tell whether this is the obscure v1 bug or not).

This allows osiop-connected devices to work correctly on 197SP/DP boards.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.57 2007/12/26 22:22:45 miod Exp $	*/
d355 1
d357 27
@


1.57
log
@Since no cache flush/inval operation will occur before we enable D$, and
we never disable it, it is not necessary to check for D$ to be enabled
before acting. That's a few more cycles spared.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.56 2007/12/26 22:21:41 miod Exp $	*/
d671 1
d673 3
d790 1
d792 3
@


1.56
log
@Remove the last debug bit from the PSR on 88110: do not force memory accesses
instructions to be serialized (this defeats the purpose of having a superscalar
processor, and accesses to volatile variables are done with explicit memory
barriers anyway).

This brings a HUGE speedup: openssl speed -elapsed shows AES is 90% faster,
blowfish is 75% faster, and sha1 is 50% faster. Not so bad!

However, doing this increases the pressure on the processor bus, so it is
necessary to increase the processor bus timeout on 40MHz boards again (to 256
usec). ``black cat'' 50MHz boards seem to be unaffected, so they remain at
64 usec.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.55 2007/12/25 21:10:56 miod Exp $	*/
d463 3
d484 1
a484 2
	if (get_dctl() & CMMU_DCTL_CEN)
		mc88110_flush_data();
d507 1
a507 3
	if (get_dctl() & CMMU_DCTL_CEN) {
		mc88110_flush_data();
	}
a623 3
	if (!ISSET(get_dctl(), CMMU_DCTL_CEN))
		size = 0;

a681 2
		if (!ISSET(get_dctl(), CMMU_DCTL_CEN))
			size = 0;
a692 2
		if (!ISSET(get_dctl(), CMMU_DCTL_CEN))
			size = 0;
a741 3
	if (!ISSET(get_dctl(), CMMU_DCTL_CEN))
		size = 0;

a796 2
		if (!ISSET(get_dctl(), CMMU_DCTL_CEN))
			size = 0;
a805 2
		if (!ISSET(get_dctl(), CMMU_DCTL_CEN))
			size = 0;
@


1.55
log
@Tell 197SP and 197DP apart in MULTIPROCESSOR kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.54 2007/12/25 20:23:04 miod Exp $	*/
d180 1
a180 1
	 * MVME197SP are 01-W3815B03, while MVME197DP are 01-W3815B04.
d186 1
a186 1
	if (bcmp(brdid.pwa, "01-W3815B03", 11) == 0)
a266 3
#ifndef MULTIPROCESSOR
	u_int8_t btimer;
#endif
a279 14

#ifndef MULTIPROCESSOR
	/*
	 * Kernels running without snooping enabled (i.e. without
	 * CACHE_GLOBAL set in the apr in pmap.c) need increased processor
	 * bus timeout limits, or the instruction cache might not be able
	 * to fill or answer fast enough.  This is especially critical on
	 * 40MHz boards, while some 50MHz boards can run without this
	 * timeout change... but better be safe than sorry.
	 */
	btimer = *(volatile u_int8_t *)(BS_BASE + BS_BTIMER);
	btimer = (btimer & ~BS_BTIMER_PBT_MASK) | BS_BTIMER_PBT64;
	*(volatile u_int8_t *)(BS_BASE + BS_BTIMER) = btimer;
#endif
@


1.54
log
@Increase timeout on the processor bus when running without snooping enabled.
This lets 40MHz MVME197LE boards run with instruction cache enabled, and also
fixes random instruction faults occuring on the early 50MHz models.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.53 2007/12/22 17:13:53 miod Exp $	*/
d65 1
d177 14
a190 1
	max_cpus = 2;
@


1.53
log
@Enable branch prediction on MC88110 revision 5 and later, since we can
workaround errata #1 differently on these models.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.52 2007/12/15 19:37:41 miod Exp $	*/
a251 1
	extern int cpuspeed;
d253 3
d270 1
a270 2
	ictl = BATC_512K | CMMU_ICTL_DID | CMMU_ICTL_CEN | CMMU_ICTL_BEN;

d272 6
a277 12
	 * 40MHz MVME197LE boards need to run with their instruction cache
	 * disabled, otherwise they get random bus errors and the kernel
	 * eventually freezes. Unfortunately this makes them perform at
	 * about the speed of a fictitious 25MHz board with I$ enabled.
	 *
	 * This happens with version 4 and version 5 processors (reporting
	 * themselves as version 0xb and 0xf in dmesg) and BusSwitch
	 * revision 1. However, 50MHz boards with the same BusSwitch
	 * revision work nicely.
	 *
	 * (There is probably a better way to work around this problem,
	 *  but I am not aware of it -- miod)
d279 6
a284 2
	if (cpuspeed == 40)
		ictl &= ~CMMU_ICTL_CEN;
@


1.52
log
@Unconditionnaly disable the instruction cache on 40MHz MVME197LE boards,
so that they run stably. Definitely overkill and causing a severe performance
hit (they now run about as fast as a 25MHz board with I$ enabled would), but
sometimes you can't fight silicon bugs.

Other boards (i.e. 50MHz ones) are not affected.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.51 2007/12/15 19:34:35 miod Exp $	*/
d255 1
a267 7
	/*
	 * 88110 errata #1:
	 * ``Under certain conditions involving exceptions, with branch
	 *   prediction enabled, the CPU may hang.
	 *   Suggested fix: Clear the PREN bit of the ICTL.  This will
	 *   disable branch prediction.''
	 */
d308 30
@


1.51
log
@Since the 88110 can not invalidate a particular tlb entry, do not stack
invalidate tlb ipis, and turn them into simple ``handle once'' ipis.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.50 2007/12/15 19:33:35 miod Exp $	*/
d252 1
d275 17
@


1.50
log
@Move the cmmu lock back from 8820x-specific code to global, and use it on
MVME197DP to serialize 88410 operations.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.49 2007/12/05 22:10:42 miod Exp $	*/
d392 2
a393 1
		m197_send_complex_ipi(CI_IPI_TLB_FLUSH, cpu, kernel, vaddr);
@


1.49
log
@Correctly setup the seconday processor on 197DP, and get it ready to accept
IPIs.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.48 2007/12/04 23:45:53 miod Exp $	*/
d316 1
d318 1
d469 1
d471 1
d504 1
d506 1
d648 1
d657 1
d673 1
d675 1
d770 1
d777 1
d791 1
d793 1
@


1.48
log
@Work in progress SMP code for 88110 processor using the BusSwitch chip as
an IPI facility, for MVME197DP.

It's still missing a few remote cache IPIs and IPI do not seem to be reliably
triggered on remote processors at the moment (but this could be a problem
on the board I am currently testing on), at least it will boot multiuser
using only cpu0 to schedule processes.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.47 2007/12/04 05:41:48 miod Exp $	*/
d98 1
d140 1
a140 1
	m88110_initialize_cpu,
a231 1
	u_int dctl;
d234 2
a235 13
	cpu = m88110_init();
	dctl = get_dctl();
	dctl |= CMMU_DCTL_SEN;
	set_dctl(dctl);
	mc88410_inval();	/* clear external data cache */

#ifdef MULTIPROCESSOR
	/*
	 * Mark us as allowing IPIs now.
	 */
	*(volatile u_int8_t *)(BS_BASE + BS_CPINT) = BS_CPI_ICLR | BS_CPI_IEN;
#endif

d307 19
a636 3
	if (!ISSET(get_dctl(), CMMU_DCTL_CEN))
		size = 0;

d640 2
d651 2
a754 3
	if (!ISSET(get_dctl(), CMMU_DCTL_CEN))
		size = 0;

d758 2
d767 2
@


1.47
log
@Better cache routines for 88410, will only flush in pages instead of
flushing the whole secondary cache.

This does not work around the snooping errata yet, I'm trying to get
something not too ugly first.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.46 2007/12/02 22:17:36 miod Exp $	*/
d73 3
d239 8
d378 8
d442 8
d479 8
@


1.46
log
@Rework mmu initialization so that we do not actually enable translation
until cmmu_set_sapr(). Also, do not enable snooping on MVME197LE, so that
we don't have to add workarounds for snooping problems later.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.45 2007/11/24 17:27:38 miod Exp $	*/
d353 1
a353 1
	mc88110_inval_inst();
a412 1
	/* flush all data to avoid errata invalidate */
d429 1
a429 1
	if (get_dctl() & CMMU_DCTL_CEN)
d431 1
d571 1
d574 1
d597 12
a608 1
	if (op != DMA_CACHE_SYNC)
d610 7
a616 3
	while (size != 0) {
		count = (va & PAGE_MASK) == 0 && size >= PAGE_SIZE ?
		    PAGE_SIZE : MC88110_CACHE_LINE;
d618 2
a619 2
		if (pmap_extract(pmap, va, &pa) != FALSE) {
			(*flusher)(pa, count);
d621 1
a621 3

		va += count;
		size -= count;
a623 2
	(*ext_flusher)();

d688 1
d691 1
d714 10
a723 1
	if (op != DMA_CACHE_SYNC)
d725 3
a727 3
	while (size != 0) {
		count = (pa & PAGE_MASK) == 0 && size >= PAGE_SIZE ?
		    PAGE_SIZE : MC88110_CACHE_LINE;
d729 1
a729 1
		(*flusher)(pa, count);
d731 4
a734 2
		pa += count;
		size -= count;
a735 2

	(*ext_flusher)();
@


1.45
log
@Fix a stupid underscore bug in memory area computations in the cache functions,
it's amazing things didn't break.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.44 2007/11/22 23:33:42 miod Exp $	*/
a31 1

d180 1
a180 1
 * number and master/slave status . Should be called first
d208 1
d228 1
d232 3
d252 1
d273 1
a273 6
	set_ictl(BATC_512K
		 | CMMU_ICTL_DID	/* Double instruction disable */
		 | CMMU_ICTL_MEN
		 | CMMU_ICTL_CEN
		 | CMMU_ICTL_BEN
		 | CMMU_ICTL_HTEN);
d294 2
a295 7
	set_dctl(BATC_512K
		 | CMMU_DCTL_RSVD1	/* Data Matching Disable */
		 | CMMU_DCTL_MEN
		 | CMMU_DCTL_CEN
		 | CMMU_DCTL_SEN
		 | CMMU_DCTL_ADS
		 | CMMU_DCTL_HTEN);
d300 2
a301 1
	set_dcmd(CMMU_DCMD_INV_SATC);	/* invalidate ATCs */
a325 4
	/* disable translation */
	set_ictl(ictl & ~CMMU_ICTL_MEN);
	set_dctl(dctl & ~CMMU_DCTL_MEN);

d336 3
a338 1
	/* restore MMU settings */
a385 3
#define	trunc_cache_line(a)	((a) & ~(MC88110_CACHE_LINE - 1))
#define	round_cache_line(a)	trunc_cache_line((a) + MC88110_CACHE_LINE - 1)

d397 3
d469 4
a472 2
	/* flush all data to avoid errata invalidate */
	mc88110_flush_data();
d496 2
a497 2
	 * this and turn invalidates into syncs for areas larger than
	 * a page.
a520 1
		size = MC88110_CACHE_LINE;	/* leave loop after one call */
a572 1
		size = MC88110_CACHE_LINE;	/* leave loop after one call */
a627 1
		size = MC88110_CACHE_LINE;	/* leave loop after one call */
a676 1
		size = MC88110_CACHE_LINE;	/* leave loop after one call */
@


1.44
log
@Split the cmmu code routines into single 88110 (MVME197LE) and 88110+88410
combos (MVME197SP/DP), and implement supposedly smarter cache routines.

There is still room for improvement, however, cache flush operation errata
permissing.

Tested on 197LE and 197DP.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.43 2007/11/22 05:53:57 miod Exp $	*/
d520 1
a520 1
	size = round_cache_line(_va + size) - va;
d544 2
a545 1
	mc88110_inval_inst();
d572 1
a572 1
	size = round_cache_line(_va + size) - va;
d601 2
a602 1
	mc88110_inval_inst();
d629 1
a629 1
	size = round_cache_line(_pa + size) - pa;
d653 2
a654 1
	mc88110_inval_inst();
d678 1
a678 1
	size = round_cache_line(_pa + size) - pa;
d707 2
a708 1
	mc88110_inval_inst();
@


1.43
log
@Quote a few errata to explain why odd things are done in oddly ways on 88110.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.42 2007/11/22 05:47:46 miod Exp $	*/
d76 1
d78 1
d80 1
d86 1
d88 1
d90 1
d92 1
d94 1
d97 4
a100 1
/* This is the function table for the MC88110 built-in CMMUs */
d102 1
a102 1
        m88110_init,
d119 22
d142 1
d166 6
d199 1
a199 3
		printf("M88110 version 0x%x", procvers);
		if (mc88410_present())
			printf(", external M88410 cache controller");
d205 7
d225 20
d268 1
a268 1
	set_ictl(BATC_32M
d294 3
a296 3
	set_dctl(BATC_32M
                 | CMMU_DCTL_RSVD1	/* Data Matching Disable */
                 | CMMU_DCTL_MEN
a303 2
	if (mc88410_present())
		mc88410_inval();	/* clear external data cache */
a318 10
cpuid_t
m88110_cpu_number(void)
{
	u_int16_t gcsr;

	gcsr = *(volatile u_int16_t *)(BS_BASE + BS_GCSR);

	return ((gcsr & BS_GCSR_CPUID) != 0 ? 1 : 0);
}

d331 2
a332 2
	set_ictl((ictl & ~CMMU_ICTL_MEN));
	set_dctl((dctl & ~CMMU_DCTL_MEN));
a389 10
 *
 * Cache invalidates require physical addresses.  Care must be exercised when
 * using segment invalidates.  This implies that the starting physical address
 * plus the segment length should be invalidated.  A typical mistake is to
 * extract the first physical page of a segment from a virtual address, and
 * then expecting to invalidate when the pages are not physically contiguous.
 *
 * We don't push Instruction Caches prior to invalidate because they are not
 * snooped and never modified (I guess it doesn't matter then which form
 * of the command we use then).
d392 3
d396 8
a403 3
 * Care must be taken to avoid flushing the data cache when
 * the data cache is not on!  From the 0F92L Errata Documentation
 * Package, Version 1.1
d407 1
a407 3
 * XXX These routines are really suboptimal because they invalidate
 * way too much...
 * Improve them once the 197 support is really working...
a409 3
/*
 *	flush both Instruction and Data caches
 */
d419 4
a422 3
	mc88110_flush_data();
	if (mc88410_present())
		mc88410_flush();
a425 3
/*
 *	flush Instruction caches
 */
d427 1
a427 1
m88110_flush_inst_cache(cpuid_t cpu, paddr_t pa, psize_t size)
d435 5
d444 1
a444 1
 * sync dcache (and icache too)
d446 8
d455 1
a455 1
m88110_cmmu_sync_cache(paddr_t pa, psize_t size)
d463 13
a476 3
	if (mc88410_present())
		mc88410_flush();
	set_psr(psr);
d482 31
d514 23
d541 16
a556 3
	mc88110_sync_data();
	if (mc88410_present())
		mc88410_sync();
d561 1
a561 1
m88110_cmmu_inval_cache(paddr_t pa, psize_t size)
d564 29
d597 3
d601 14
a614 3
	mc88110_inval_data();
	if (mc88410_present())
		mc88410_inval();
d619 1
a619 1
m88110_dma_cachectl(pmap_t pmap, vaddr_t va, vsize_t size, int op)
d621 1
d623 2
d626 2
a627 7
	if (pmap_extract(pmap, va, &pa) == FALSE) {
#ifdef DIAGNOSTIC
		printf("cachectl: pmap_extract(%p, %p) failed\n", pmap, va);
#endif
		pa = 0;
		size = ~0;
	}
d631 2
a632 1
		m88110_cmmu_sync_cache(pa, size);
d635 1
a635 1
		m88110_cmmu_sync_inval_cache(pa, size);
d638 4
a641 5
#if 0
		m88110_cmmu_inval_cache(pa, size);
#else
		m88110_cmmu_sync_inval_cache(pa, size);
#endif
d644 19
d666 1
a666 1
m88110_dma_cachectl_pa(paddr_t pa, psize_t size, int op)
d668 9
d679 3
a681 1
		m88110_cmmu_sync_cache(pa, size);
d684 2
a685 1
		m88110_cmmu_sync_inval_cache(pa, size);
d688 7
a694 5
#if 0
		m88110_cmmu_inval_cache(pa, size);
#else
		m88110_cmmu_sync_inval_cache(pa, size);
#endif
d697 21
@


1.42
log
@Remove the cpu parameter from cmmu_set_sapr(), since it is only invoked
for the current processor. And remove now unused cmmu_flush_data_page().
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.41 2007/11/22 05:42:52 miod Exp $	*/
d196 7
a202 1
	/* Do NOT enable ICTL_PREN (branch prediction) */
d210 19
@


1.41
log
@Move the cmmu lock to 88200-specific code. 88110 MP code will use ipis
and will not require such a lock.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.40 2007/11/21 19:42:36 miod Exp $	*/
d80 1
a80 1
void	m88110_set_sapr(cpuid_t, apr_t);
a84 1
void	m88110_flush_data_page(cpuid_t, paddr_t);
a100 1
	m88110_flush_data_page,
d242 1
a242 1
m88110_set_sapr(cpuid_t cpu, apr_t ap)
a365 16
	set_psr(psr);
}

/*
 * flush data cache
 */
void
m88110_flush_data_page(cpuid_t cpu, paddr_t pa)
{
	u_int32_t psr;

	disable_interrupt(psr);

	mc88110_flush_data();
	if (mc88410_present())
		mc88410_flush();
@


1.40
log
@Better cache invalidation functions (still horribly unoptimal, but less
broken now).
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.39 2007/11/17 05:36:23 miod Exp $	*/
a247 2
	CMMU_LOCK;

a270 2

	CMMU_UNLOCK;
a275 1
	CMMU_LOCK;
a283 1
	CMMU_UNLOCK;
d298 2
a299 1
	disable_interrupt(psr);
a300 1
	CMMU_LOCK;
a307 1
	CMMU_UNLOCK;
d346 2
a347 1
	disable_interrupt(psr);
d364 2
a365 1
	disable_interrupt(psr);
d395 2
a396 1
	disable_interrupt(psr);
d410 2
a411 1
	disable_interrupt(psr);
d424 2
a425 1
	disable_interrupt(psr);
@


1.39
log
@Replace many ``unsigned'' variables with ``unsigned int'', ``u_int'' or other
appropriate types. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.38 2007/02/11 12:49:38 miod Exp $	*/
d457 1
d459 3
d477 1
d479 3
@


1.38
log
@Rework the cache handling routines again. We now try to operate on the exact
address range we've been given, rounded to cache line boundaries, instead
of being lazy and operating on pages as soon as the range was large enough.

Also, since the ranges we'll be invoked for are reasonably small, it does
not make sense to check for segment sizes - we're always smaller, really.

While there, hardcode the size in cmmu_flush_data_cache(), which becomes
cmmu_flush_data_page(), since it was always invoked for complete pages.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.37 2006/05/08 14:36:10 miod Exp $	*/
d82 1
a82 1
void	m88110_flush_tlb(cpuid_t, unsigned, vaddr_t, u_int);
d300 1
a300 1
m88110_flush_tlb(cpuid_t cpu, unsigned kernel, vaddr_t vaddr, u_int count)
@


1.37
log
@Replace gazillions of badvaddr() or badwordaddr() calls with badaddr() calls.
With a few prototype declarations shuffling, this finally allows
<machine/locore.h> to die.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.36 2006/05/08 14:03:35 miod Exp $	*/
d85 3
a87 3
void	m88110_flush_data_cache(cpuid_t, paddr_t, psize_t);
int	m88110_dma_cachectl(pmap_t, vaddr_t, vsize_t, int);
int	m88110_dma_cachectl_pa(paddr_t, psize_t, int);
d102 1
a102 1
	m88110_flush_data_cache,
d349 1
a349 1
m88110_flush_cache(cpuid_t cpu, paddr_t physaddr, psize_t size)
d366 1
a366 1
m88110_flush_inst_cache(cpuid_t cpu, paddr_t physaddr, psize_t size)
d380 1
a380 1
m88110_flush_data_cache(cpuid_t cpu, paddr_t physaddr, psize_t size)
d396 1
a396 1
m88110_cmmu_sync_cache(paddr_t physaddr, psize_t size)
d410 1
a410 1
m88110_cmmu_sync_inval_cache(paddr_t physaddr, psize_t size)
d423 1
a423 1
m88110_cmmu_inval_cache(paddr_t physaddr, psize_t size)
d436 1
a436 1
int
a459 1
	return (1);
d462 1
a462 1
int
a475 1
	return (1);
@


1.36
log
@Clean the internal m88k trap type codes; while there, simplify and
factorize the build of the VBR page betweem luna88k and mvme88k.

Tested by aoyama@@ and I.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.35 2005/12/11 21:45:31 miod Exp $	*/
a68 1
#include <machine/locore.h>
@


1.35
log
@Work in progress SMP code; mvme88k boards can spin up secondary CPUs,
kernel boots single user. Still a lot of polishing and bugfixing to do.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.34 2005/12/04 15:00:26 miod Exp $	*/
a72 1
#include <machine/trap.h>
@


1.34
log
@Let cmmu_init() now return the cpuid of the master cpu.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.33 2005/12/04 12:20:19 miod Exp $	*/
d65 1
d75 1
a75 13
cpuid_t m88110_init(void);
void m88110_setup_board_config(void);
void m88110_cpu_configuration_print(int);
void m88110_shutdown(void);
cpuid_t m88110_cpu_number(void);
void m88110_set_sapr(cpuid_t, apr_t);
void m88110_set_uapr(apr_t);
void m88110_flush_tlb(cpuid_t, unsigned, vaddr_t, u_int);
void m88110_flush_cache(cpuid_t, paddr_t, psize_t);
void m88110_flush_inst_cache(cpuid_t, paddr_t, psize_t);
void m88110_flush_data_cache(cpuid_t, paddr_t, psize_t);
int m88110_dma_cachectl(pmap_t, vaddr_t, vsize_t, int);
int m88110_dma_cachectl_pa(paddr_t, psize_t, int);
d77 16
a92 1
/* This is the function table for the mc88110 built-in CMMUs */
d107 3
d136 3
a138 1
	/* we could print something here... */
d140 1
a154 7
	static __cpu_simple_lock_t print_lock;

	CMMU_LOCK;
	if (master)
		__cpu_simple_lock_init(&print_lock);

	__cpu_simple_lock(&print_lock);
a168 3

	__cpu_simple_unlock(&print_lock);
        CMMU_UNLOCK;
d177 10
a224 2

	return (m88110_cpu_number());
a232 4
#if 0
	CMMU_LOCK;
        CMMU_UNLOCK;
#endif
a234 6
/*
 * Find out the CPU number from accessing CMMU
 * Better be at splhigh, or even better, with interrupts
 * disabled.
 */

d238 5
a242 1
	return (0);	/* XXXSMP - need to tell DP processors apart */
@


1.33
log
@Slight cmmu code cleanup; use shorter function names, remove parity_enable
and the DDB and DEBUG helpers which are of questionable usefulness, some
stylistic changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.32 2005/12/03 19:06:12 miod Exp $	*/
d74 1
a74 1
void m88110_init(void);
d156 1
a156 1
		printf("unknown model arch 0x%x version 0x%x\n",
d174 1
a174 1
void
d215 2
@


1.32
log
@Replace simplelocks with __cpu_simple_locks for cmmu and pmap locking,
for the MULTIPROCESSOR case.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.31 2005/12/03 18:48:22 miod Exp $	*/
d65 2
d68 1
a68 1
#include <machine/cmmu.h>
d71 1
a71 1
#include <machine/locore.h>
d74 1
a74 5
#ifdef DDB
#include <ddb/db_output.h>		/* db_printf()		*/
#endif

void m88110_cmmu_init(void);
d77 8
a84 9
void m88110_cmmu_shutdown_now(void);
void m88110_cmmu_parity_enable(void);
cpuid_t m88110_cmmu_cpu_number(void);
void m88110_cmmu_set_sapr(cpuid_t, apr_t);
void m88110_cmmu_set_uapr(apr_t);
void m88110_cmmu_flush_tlb(cpuid_t, unsigned, vaddr_t, u_int);
void m88110_cmmu_flush_cache(cpuid_t, paddr_t, psize_t);
void m88110_cmmu_flush_inst_cache(cpuid_t, paddr_t, psize_t);
void m88110_cmmu_flush_data_cache(cpuid_t, paddr_t, psize_t);
a86 3
void m88110_cmmu_dump_config(void);
void m88110_cmmu_show_translation(unsigned, unsigned, unsigned, int);
void m88110_show_apr(apr_t);
d90 1
a90 1
        m88110_cmmu_init,
d93 8
a100 9
	m88110_cmmu_shutdown_now,
	m88110_cmmu_parity_enable,
	m88110_cmmu_cpu_number,
	m88110_cmmu_set_sapr,
	m88110_cmmu_set_uapr,
	m88110_cmmu_flush_tlb,
	m88110_cmmu_flush_cache,
	m88110_cmmu_flush_inst_cache,
	m88110_cmmu_flush_data_cache,
a102 12
#ifdef DDB
	m88110_cmmu_dump_config,
	m88110_cmmu_show_translation,
#else
	NULL,
	NULL,
#endif
#ifdef DEBUG
        m88110_show_apr,
#else
	NULL,
#endif
a125 19
#ifdef DEBUG
void
m88110_show_apr(apr_t value)
{
	printf("table @@ 0x%x000", PG_PFNUM(value));
	if (value & CACHE_WT)
		printf(", writethrough");
	if (value & CACHE_GLOBAL)
		printf(", global");
	if (value & CACHE_INH)
		printf(", cache inhibit");
	if (value & APR_V)
		printf(", valid");
	else
		printf(", not valid");
	printf("\n");
}
#endif

d154 2
a155 1
	if (proctype != ARN_88110) {
d158 6
a163 3
		__cpu_simple_unlock(&print_lock);
		CMMU_UNLOCK;
		return;
a164 4

	printf("M88110 version 0x%x", procvers);
	if (mc88410_present())
		printf(", external M88410 cache controller");
d175 1
a175 1
m88110_cmmu_init(void)
d221 1
a221 13
m88110_cmmu_shutdown_now(void)
{
#if 0
	CMMU_LOCK;
        CMMU_UNLOCK;
#endif
}

/*
 * Enable parity
 */
void
m88110_cmmu_parity_enable(void)
d236 1
a236 1
m88110_cmmu_cpu_number(void)
d238 1
a238 1
	return (0);
d242 1
a242 1
m88110_cmmu_set_sapr(cpuid_t cpu, apr_t ap)
d244 1
a244 1
	unsigned ictl, dctl;
d276 1
a276 1
m88110_cmmu_set_uapr(apr_t ap)
d298 1
a298 1
m88110_cmmu_flush_tlb(cpuid_t cpu, unsigned kernel, vaddr_t vaddr, u_int count)
d347 1
a347 1
m88110_cmmu_flush_cache(cpuid_t cpu, paddr_t physaddr, psize_t size)
d364 1
a364 1
m88110_cmmu_flush_inst_cache(cpuid_t cpu, paddr_t physaddr, psize_t size)
d378 1
a378 1
m88110_cmmu_flush_data_cache(cpuid_t cpu, paddr_t physaddr, psize_t size)
d439 7
a445 2
	if (pmap_extract(pmap, va, &pa) == FALSE)
		return (0);	/* XXX */
a476 218

#ifdef DDB
void
m88110_cmmu_dump_config(void)
{
	/* dummy routine */
}

#undef	VEQR_ADDR
#define	VEQR_ADDR	0

/*
 * Show (for debugging) how the given CMMU translates the given ADDRESS.
 * If cmmu == -1, the data cmmu for the current cpu is used.
 */
void
m88110_cmmu_show_translation(unsigned address,
		unsigned supervisor_flag,
		unsigned verbose_flag,
		int cmmu_num)
{
	/*
	 * A virtual address is split into three fields. Two are used as
	 * indices into tables (segment and page), and one is an offset into
	 * a page of memory.
	 */
	union {
		unsigned bits;
		struct {
			unsigned segment_table_index:SDT_BITS,
			page_table_index:PDT_BITS,
			page_offset:PG_BITS;
		} field;
	} virtual_address;
	unsigned value;
	unsigned result;
	unsigned probeaddr;

	if (verbose_flag)
		db_printf("-------------------------------------------\n");

	if (supervisor_flag)
		value = get_dsap();
	else
		value = get_duap();

	/******* SEE WHAT A PROBE SAYS (if not a thread) ***********/

	set_dsar(address);
	if (supervisor_flag) {
		set_dcmd(CMMU_DCMD_PRB_SUPR);
	} else {
		set_dcmd(CMMU_DCMD_PRB_USER);
	}
	result = get_dsr();
	probeaddr = get_dsar();
	if (verbose_flag > 1)
		db_printf("probe of 0x%08x returns dsr=0x%08x\n",
			  address, result);
	if (result & CMMU_DSR_PH || result & CMMU_DSR_BH) {
		db_printf("probe of 0x%08x returns phys=0x%x",
			  address, probeaddr);
		if (result & CMMU_DSR_CP) db_printf(", copyback err");
		if (result & CMMU_DSR_BE) db_printf(", bus err");
		if (result & CMMU_DSR_TBE) db_printf(", table search bus error");
		if (result & CMMU_DSR_SU) db_printf(", sup prot");
		if (result & CMMU_DSR_WE) db_printf(", write prot");
		if (result & CMMU_DSR_PH) db_printf(", PATC");
		if (result & CMMU_DSR_BH) db_printf(", BATC");
	} else {
		db_printf("probe of 0x%08x missed the ATCs", address);
	}
	db_printf(".\n");

	/******* INTERPRET AREA DESCRIPTOR *********/
	{
		if (verbose_flag > 1) {
			db_printf(" %cAPR is 0x%08x\n",
				  supervisor_flag ? 'S' : 'U', value);
		}
		db_printf(" %cAPR: SegTbl: 0x%x000p",
			  supervisor_flag ? 'S' : 'U', PG_PFNUM(value));
		if (value & CACHE_WT)
			db_printf(", WTHRU");
		if (value & CACHE_GLOBAL)
			db_printf(", GLOBAL");
		if (value & CACHE_INH)
			db_printf(", INHIBIT");
		if (value & APR_V)
			db_printf(", VALID");
		db_printf("\n");

		/* if not valid, done now */
		if ((value & APR_V) == 0) {
			db_printf("<would report an error, valid bit not set>\n");
			return;
		}
		value &= PG_FRAME;	/* now point to seg page */
	}

	/* translate value from physical to virtual */
	if (verbose_flag)
		db_printf("[%x physical is %x virtual]\n", value, value + VEQR_ADDR);
	value += VEQR_ADDR;

	virtual_address.bits = address;

	/****** ACCESS SEGMENT TABLE AND INTERPRET SEGMENT DESCRIPTOR  *******/
	{
		sdt_entry_t sdt;
		if (verbose_flag)
			db_printf("will follow to entry %d of page at 0x%x...\n",
				  virtual_address.field.segment_table_index, value);
		value |= virtual_address.field.segment_table_index *
			 sizeof(sdt_entry_t);

		if (badwordaddr((vaddr_t)value)) {
			db_printf("ERROR: unable to access page at 0x%08x.\n", value);
			return;
		}

		sdt = *(sdt_entry_t *)value;
		if (verbose_flag > 1)
			db_printf("SEG DESC @@0x%x is 0x%08x\n", value, sdt);
		db_printf("SEG DESC @@0x%x: PgTbl: 0x%x000",
			  value, PG_PFNUM(sdt));
		if (sdt & CACHE_WT)		    db_printf(", WTHRU");
		else				    db_printf(", !wthru");
		if (sdt & SG_SO)		    db_printf(", S-PROT");
		else				    db_printf(", UserOk");
		if (sdt & CACHE_GLOBAL)		    db_printf(", GLOBAL");
		else				    db_printf(", !global");
		if (sdt & CACHE_INH)		    db_printf(", $INHIBIT");
		else				    db_printf(", $ok");
		if (sdt & SG_PROT)		    db_printf(", W-PROT");
		else				    db_printf(", WriteOk");
		if (sdt & SG_V)			    db_printf(", VALID");
		else				    db_printf(", !valid");
		db_printf(".\n");

		/* if not valid, done now */
		if (!(sdt & SG_V)) {
			db_printf("<would report an error, STD entry not valid>\n");
			return;
		}
		value = ptoa(PG_PFNUM(sdt));
	}

	/* translate value from physical to virtual */
	if (verbose_flag)
		db_printf("[%x physical is %x virtual]\n", value, value + VEQR_ADDR);
	value += VEQR_ADDR;

	/******* PAGE TABLE *********/
	{
		pt_entry_t pte;
		if (verbose_flag)
			db_printf("will follow to entry %d of page at 0x%x...\n",
				  virtual_address.field.page_table_index, value);
		value |= virtual_address.field.page_table_index *
			 sizeof(pt_entry_t);

		if (badwordaddr((vaddr_t)value)) {
			db_printf("error: unable to access page at 0x%08x.\n", value);
			return;
		}

		pte = *(pt_entry_t *)value;
		if (verbose_flag > 1)
			db_printf("PAGE DESC @@0x%x is 0x%08x.\n", value, pte);
		db_printf("PAGE DESC @@0x%x: page @@%x000",
			  value, PG_PFNUM(pte));
		if (pte & PG_W)			db_printf(", WIRE");
		else				db_printf(", !wire");
		if (pte & CACHE_WT)		db_printf(", WTHRU");
		else				db_printf(", !wthru");
		if (pte & PG_SO)		db_printf(", S-PROT");
		else				db_printf(", UserOk");
		if (pte & CACHE_GLOBAL)		db_printf(", GLOBAL");
		else				db_printf(", !global");
		if (pte & CACHE_INH)		db_printf(", $INHIBIT");
		else				db_printf(", $ok");
		if (pte & PG_M)			db_printf(", MOD");
		else				db_printf(", !mod");
		if (pte & PG_U)			db_printf(", USED");
		else				db_printf(", !used");
		if (pte & PG_PROT)		db_printf(", W-PROT");
		else				db_printf(", WriteOk");
		if (pte & PG_V)			db_printf(", VALID");
		else				db_printf(", !valid");
		db_printf(".\n");

		/* if not valid, done now */
		if (!(pte & PG_V)) {
			db_printf("<would report an error, PTE entry not valid>\n");
			return;
		}

		value = ptoa(PG_PFNUM(pte));
		if (verbose_flag)
			db_printf("will follow to byte %d of page at 0x%x...\n",
				  virtual_address.field.page_offset, value);
		value |= virtual_address.field.page_offset;

		if (badwordaddr((vaddr_t)value)) {
			db_printf("error: unable to access page at 0x%08x.\n", value);
			return;
		}
	}

	/* translate value from physical to virtual */
	if (verbose_flag)
		db_printf("[%x physical is %x virtual]\n", value, value + VEQR_ADDR);
	value += VEQR_ADDR;

	db_printf("WORD at 0x%x is 0x%08x.\n", value, *(unsigned *)value);
}
#endif /* DDB */
@


1.31
log
@Remove unused debug material.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.30 2005/12/03 16:52:16 miod Exp $	*/
a61 1
#include <sys/simplelock.h>
d65 1
d183 1
a183 1
	struct simplelock print_lock;
d187 1
a187 1
		simple_lock_init(&print_lock);
d189 1
a189 1
	simple_lock(&print_lock);
d195 2
a196 1
		simple_unlock(&print_lock);
d205 1
a205 1
	simple_unlock(&print_lock);
@


1.30
log
@Turn read_processor_identification_register() into a simple macro with a
much, much, much shorter name. It is only used to print cpu revision anyway...
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.29 2005/12/03 14:30:06 miod Exp $	*/
a60 1
#include <sys/types.h>
a71 17
#ifdef DEBUG
#define DB_CMMU		0x4000	/* MMU debug */
unsigned int debuglevel = 0;
#define dprintf(_L_,_X_) \
do { \
	if (debuglevel & (_L_)) { \
		unsigned int psr; \
		disable_interrupt(psr); \
		printf("%d: ", cpu_number()); \
		printf _X_; \
		set_psr(psr); \
	} \
} while (0)
#else
#define dprintf(_L_,_X_)
#endif

d74 1
a74 6
#define DEBUG_MSG db_printf
#define STATIC
#else
#define DEBUG_MSG printf
#define STATIC	static
#endif /* DDB */
d578 1
a578 1
		DEBUG_MSG("probe of 0x%08x returns dsr=0x%08x\n",
d581 1
a581 1
		DEBUG_MSG("probe of 0x%08x returns phys=0x%x",
d583 7
a589 7
		if (result & CMMU_DSR_CP) DEBUG_MSG(", copyback err");
		if (result & CMMU_DSR_BE) DEBUG_MSG(", bus err");
		if (result & CMMU_DSR_TBE) DEBUG_MSG(", table search bus error");
		if (result & CMMU_DSR_SU) DEBUG_MSG(", sup prot");
		if (result & CMMU_DSR_WE) DEBUG_MSG(", write prot");
		if (result & CMMU_DSR_PH) DEBUG_MSG(", PATC");
		if (result & CMMU_DSR_BH) DEBUG_MSG(", BATC");
d591 1
a591 1
		DEBUG_MSG("probe of 0x%08x missed the ATCs", address);
d593 1
a593 1
	DEBUG_MSG(".\n");
d598 1
a598 1
			DEBUG_MSG(" %cAPR is 0x%08x\n",
d601 1
a601 1
		DEBUG_MSG(" %cAPR: SegTbl: 0x%x000p",
d604 1
a604 1
			DEBUG_MSG(", WTHRU");
d606 1
a606 1
			DEBUG_MSG(", GLOBAL");
d608 1
a608 1
			DEBUG_MSG(", INHIBIT");
d610 2
a611 2
			DEBUG_MSG(", VALID");
		DEBUG_MSG("\n");
d615 1
a615 1
			DEBUG_MSG("<would report an error, valid bit not set>\n");
d623 1
a623 1
		DEBUG_MSG("[%x physical is %x virtual]\n", value, value + VEQR_ADDR);
d632 1
a632 1
			DEBUG_MSG("will follow to entry %d of page at 0x%x...\n",
d638 1
a638 1
			DEBUG_MSG("ERROR: unable to access page at 0x%08x.\n", value);
d644 2
a645 2
			DEBUG_MSG("SEG DESC @@0x%x is 0x%08x\n", value, sdt);
		DEBUG_MSG("SEG DESC @@0x%x: PgTbl: 0x%x000",
d647 13
a659 13
		if (sdt & CACHE_WT)		    DEBUG_MSG(", WTHRU");
		else				    DEBUG_MSG(", !wthru");
		if (sdt & SG_SO)		    DEBUG_MSG(", S-PROT");
		else				    DEBUG_MSG(", UserOk");
		if (sdt & CACHE_GLOBAL)		    DEBUG_MSG(", GLOBAL");
		else				    DEBUG_MSG(", !global");
		if (sdt & CACHE_INH)		    DEBUG_MSG(", $INHIBIT");
		else				    DEBUG_MSG(", $ok");
		if (sdt & SG_PROT)		    DEBUG_MSG(", W-PROT");
		else				    DEBUG_MSG(", WriteOk");
		if (sdt & SG_V)			    DEBUG_MSG(", VALID");
		else				    DEBUG_MSG(", !valid");
		DEBUG_MSG(".\n");
d663 1
a663 1
			DEBUG_MSG("<would report an error, STD entry not valid>\n");
d671 1
a671 1
		DEBUG_MSG("[%x physical is %x virtual]\n", value, value + VEQR_ADDR);
d678 1
a678 1
			DEBUG_MSG("will follow to entry %d of page at 0x%x...\n",
d684 1
a684 1
			DEBUG_MSG("error: unable to access page at 0x%08x.\n", value);
d690 2
a691 2
			DEBUG_MSG("PAGE DESC @@0x%x is 0x%08x.\n", value, pte);
		DEBUG_MSG("PAGE DESC @@0x%x: page @@%x000",
d693 19
a711 19
		if (pte & PG_W)			DEBUG_MSG(", WIRE");
		else				DEBUG_MSG(", !wire");
		if (pte & CACHE_WT)		DEBUG_MSG(", WTHRU");
		else				DEBUG_MSG(", !wthru");
		if (pte & PG_SO)		DEBUG_MSG(", S-PROT");
		else				DEBUG_MSG(", UserOk");
		if (pte & CACHE_GLOBAL)		DEBUG_MSG(", GLOBAL");
		else				DEBUG_MSG(", !global");
		if (pte & CACHE_INH)		DEBUG_MSG(", $INHIBIT");
		else				DEBUG_MSG(", $ok");
		if (pte & PG_M)			DEBUG_MSG(", MOD");
		else				DEBUG_MSG(", !mod");
		if (pte & PG_U)			DEBUG_MSG(", USED");
		else				DEBUG_MSG(", !used");
		if (pte & PG_PROT)		DEBUG_MSG(", W-PROT");
		else				DEBUG_MSG(", WriteOk");
		if (pte & PG_V)			DEBUG_MSG(", VALID");
		else				DEBUG_MSG(", !valid");
		DEBUG_MSG(".\n");
d715 1
a715 1
			DEBUG_MSG("<would report an error, PTE entry not valid>\n");
d721 1
a721 1
			DEBUG_MSG("will follow to byte %d of page at 0x%x...\n",
d726 1
a726 1
			DEBUG_MSG("error: unable to access page at 0x%08x.\n", value);
d733 1
a733 1
		DEBUG_MSG("[%x physical is %x virtual]\n", value, value + VEQR_ADDR);
d736 1
a736 1
	DEBUG_MSG("WORD at 0x%x is 0x%08x.\n", value, *(unsigned *)value);
@


1.29
log
@Switch m88k ports to __HAVE_CPUINFO. Current cpu pointer is held in SR0
on all running processors.
Tested aoyama@@ and I
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.28 2005/12/02 21:16:45 miod Exp $	*/
d202 1
a202 1
	int pid = read_processor_identification_register();
@


1.28
log
@Better choice of types for struct pmap members and cmmu functions;
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.27 2005/11/25 22:17:12 miod Exp $	*/
a191 1
	cpu_sets[0] = 1;   /* This cpu installed... */
@


1.27
log
@Let the cache synchronization and invalidation functions report whether
they caused the entire cache to be processed.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.26 2005/11/15 07:02:36 miod Exp $	*/
d104 7
a110 7
unsigned m88110_cmmu_cpu_number(void);
void m88110_cmmu_set_sapr(unsigned, unsigned);
void m88110_cmmu_set_uapr(unsigned);
void m88110_cmmu_flush_tlb(unsigned, unsigned, vaddr_t, u_int);
void m88110_cmmu_flush_cache(int, paddr_t, psize_t);
void m88110_cmmu_flush_inst_cache(int, paddr_t, psize_t);
void m88110_cmmu_flush_data_cache(int, paddr_t, psize_t);
d115 1
a115 1
void m88110_show_apr(unsigned);
d170 1
a170 1
m88110_show_apr(unsigned value)
d308 1
a308 1
unsigned
d311 1
a311 1
	return 0; /* to make compiler happy */
d315 1
a315 1
m88110_cmmu_set_sapr(unsigned cpu, unsigned ap)
d349 1
a349 1
m88110_cmmu_set_uapr(unsigned ap)
d371 1
a371 1
m88110_cmmu_flush_tlb(unsigned cpu, unsigned kernel, vaddr_t vaddr, u_int count)
d420 1
a420 1
m88110_cmmu_flush_cache(int cpu, paddr_t physaddr, psize_t size)
d437 1
a437 1
m88110_cmmu_flush_inst_cache(int cpu, paddr_t physaddr, psize_t size)
d451 1
a451 1
m88110_cmmu_flush_data_cache(int cpu, paddr_t physaddr, psize_t size)
@


1.26
log
@More typos (especially indicies -> indices), checked with jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.25 2005/10/13 19:48:36 miod Exp $	*/
d111 2
a112 2
void m88110_dma_cachectl(pmap_t, vaddr_t, vsize_t, int);
void m88110_dma_cachectl_pa(paddr_t, psize_t, int);
d507 1
a507 1
void
d513 1
a513 1
		return;	/* XXX */
d526 1
d529 1
a529 1
void
d543 1
@


1.25
log
@Merge <machine/cpu_number.h> into <machine/cpu.h>, preparing for intrusive
changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.24 2005/09/25 22:41:14 miod Exp $	*/
d566 1
a566 1
	 * indicies into tables (segment and page), and one is an offset into
@


1.24
log
@Define symbolic constants for the processor identification register fields
and use them. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.23 2005/09/25 20:55:15 miod Exp $	*/
a66 1
#include <machine/cpu_number.h>
@


1.23
log
@Change the size parameter of cmmu_flush_tlb() from bytes to pages. This makes
things easier for the callers, and allows us to inline the "fewer than 4 pages"
situation for speed.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.22 2005/09/06 19:43:00 miod Exp $	*/
d205 2
a206 2
	int proctype = (pid & 0xff00) >> 8;
	int procvers = (pid & 0xe) >> 1;
d217 1
a217 1
	if (proctype != 1) {
@


1.22
log
@Initialize max_cpus for 88110-based systems (i.e. 197 boards). Makes pmap
so much happy.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.21 2005/04/30 16:42:37 miod Exp $	*/
d108 1
a108 1
void m88110_cmmu_flush_tlb(unsigned, unsigned, vaddr_t, vsize_t);
d372 1
a372 2
m88110_cmmu_flush_tlb(unsigned cpu, unsigned kernel, vaddr_t vaddr,
    vsize_t size)
@


1.21
log
@Remove m88k_psr_type and function with utterly long names to control the psr,
and use get_psr() / set_psr() or simple macros that expand into them everywhere.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.20 2005/04/27 14:09:45 miod Exp $	*/
d192 1
@


1.20
log
@Allow userland to cause the data cache to be flushed for any arbitrary address
range in the current process, using trap #451.

This is necessary for proper gcc trampolines operation, and, later, ld.so...
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.19 2005/04/27 14:07:38 miod Exp $	*/
d77 10
a86 1
#define dprintf(_L_,_X_) { if (debuglevel & (_L_)) { unsigned int psr = disable_interrupts_return_psr(); printf("%d: ", cpu_number()); printf _X_;  set_psr(psr); } }
d374 3
a376 1
	u_int32_t psr = disable_interrupts_return_psr();
d423 3
a425 1
	u_int32_t psr = disable_interrupts_return_psr();
d440 3
a442 1
	u_int32_t psr = disable_interrupts_return_psr();
d454 3
a456 1
	u_int32_t psr = disable_interrupts_return_psr();
d470 3
a472 1
	u_int32_t psr = disable_interrupts_return_psr();
d484 3
a486 1
	u_int32_t psr = disable_interrupts_return_psr();
d497 3
a499 1
	u_int32_t psr = disable_interrupts_return_psr();
@


1.19
log
@Always include <uvm/uvm_extern.h> before <machine/cmmu.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.18 2004/08/04 15:54:38 miod Exp $	*/
d103 1
a103 1
void m88110_dma_cachectl(vaddr_t, vsize_t, int);
d486 1
a486 1
m88110_dma_cachectl(vaddr_t va, vsize_t size, int op)
d490 1
a490 1
	if (pmap_extract(pmap_kernel(), va, &pa) == FALSE)
@


1.18
log
@Completely remove BATC code. BATC on 88200 are way too small to be worth
using as part of the general pmap machinery (though they might come back
at some point to speed up I/O mappings), and we don't use the 88110 BATC
yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.17 2004/08/02 08:35:00 miod Exp $	*/
d65 2
a72 2

#include <uvm/uvm_extern.h>
@


1.17
log
@More include files cleaning:
- move MAX_CPUS constant to <machine/cpu.h>
- do not include <machine/board.h> unless needed. In fact, remove this file
  entirely on mvme88k, and include <machine/mvme*.h> on a
  compiling-for-this-board basis
- keep MAX_CMMUS constant private to the m8820x code
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.16 2004/06/26 20:58:13 miod Exp $	*/
a98 1
void m88110_cmmu_set_pair_batc_entry(unsigned, unsigned, unsigned);
a99 2
void m88110_cmmu_pmap_activate(unsigned, unsigned,
    u_int32_t i_batc[BATC_MAX], u_int32_t d_batc[BATC_MAX]);
a118 1
	m88110_cmmu_set_pair_batc_entry,
a119 1
	m88110_cmmu_pmap_activate,
d233 4
a236 1
		m88110_cmmu_set_pair_batc_entry(0, i, 0);
d345 1
d348 2
a354 21
 * Set batc entry number entry_no to value in
 * the data and instruction cache for the named CPU.
 *
 * Except for the cmmu_init, this function and m88110_cmmu_pmap_activate
 * are the only functions which may set the batc values.
 */
void
m88110_cmmu_set_pair_batc_entry(unsigned cpu, unsigned entry_no, unsigned value)
{
	CMMU_LOCK;

	set_dir(entry_no);
	set_dbp(value);

	set_iir(entry_no);
	set_ibp(value);

	CMMU_UNLOCK;
}

/*
a359 1
 *	Some functionality mimiced in m88110_cmmu_pmap_activate.
a377 26
}

/*
 * New fast stuff for pmap_activate.
 * Does what a few calls used to do.
 * Only called from pmap.c's pmap_activate().
 */
void
m88110_cmmu_pmap_activate(unsigned cpu, unsigned uapr,
    u_int32_t i_batc[BATC_MAX], u_int32_t d_batc[BATC_MAX])
{
	m88110_cmmu_set_uapr(uapr);

	/*
	for (entry_no = 0; entry_no < 8; entry_no++) {
	   m88110_cmmu_set_batc_entry(cpu, entry_no, 0, i_batc[entry_no]);
	   m88110_cmmu_set_batc_entry(cpu, entry_no, 1, d_batc[entry_no]);
	}
	*/
	/*
	 * Flush the user TLB.
	 * IF THE KERNEL WILL EVER CARE ABOUT THE BATC ENTRIES,
	 * THE SUPERVISOR TLBs SHOULD BE FLUSHED AS WELL.
	 */
	set_icmd(CMMU_ICMD_INV_UATC);
	set_dcmd(CMMU_DCMD_INV_UATC);
@


1.16
log
@When altering mmu registers, disable interrupts rather than splhigh().
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.15 2004/06/22 04:55:35 miod Exp $	*/
a64 1
#include <machine/board.h>
@


1.15
log
@Do not access [id][pl]ar registers from C code - we only care about their
values in trapframes.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.14 2004/05/07 18:06:34 miod Exp $	*/
d387 1
a387 1
	int s = splhigh();	/* XXX really disable interrupts? */
d399 1
a399 1
	splx(s);
d460 1
a460 1
	int s = splhigh();	/* XXX really disable interrupts? */
d466 1
a466 1
	splx(s);
d475 1
a475 1
	int s = splhigh();	/* XXX really disable interrupts? */
d478 1
a478 1
	splx(s);
d487 1
a487 1
	int s = splhigh();	/* XXX really disable interrupts? */
d492 1
a492 1
	splx(s);
d501 1
a501 1
	int s = splhigh();	/* XXX really disable interrupts? */
d507 1
a507 1
	splx(s);
d513 1
a513 1
	int s = splhigh();	/* XXX really disable interrupts? */
d518 1
a518 1
	splx(s);
d524 1
a524 1
	int s = splhigh();	/* XXX really disable interrupts? */
d530 1
a530 1
	splx(s);
@


1.14
log
@Introduce a new cmmu operation, cachectl_pa, similar to cachectl, but taking
a pa instead of a pmap_kernel va. The cachectl operation is now deprecated and
will disappear soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.13 2004/01/02 17:08:57 miod Exp $	*/
a268 2
	set_ilar(0);
	set_ipar(0);
a269 2
	set_dlar(0);
	set_dpar(0);
@


1.13
log
@When both cmmu_dofoo() and cmmu_remote_dofoo() exist, kill the first one,
and rename the second one to the first one, i.e. have the cmmu_dofoo()
functions always take a cpu# parameter.

No functional change, simply makes code more readable and saves a few
call frames.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.12 2003/12/22 20:10:23 miod Exp $	*/
d108 1
d130 1
d545 16
@


1.12
log
@Get rid of kvtop() usage in dma_cachectl().
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.11 2003/12/19 22:30:18 miod Exp $	*/
d98 1
a98 1
void m88110_cmmu_remote_set_sapr(unsigned, unsigned);
d101 1
a101 2
void m88110_cmmu_flush_remote_tlb(unsigned, unsigned, vaddr_t, vsize_t);
void m88110_cmmu_flush_tlb(unsigned, vaddr_t, vsize_t);
d104 3
a106 6
void m88110_cmmu_flush_remote_cache(int, paddr_t, psize_t);
void m88110_cmmu_flush_cache(paddr_t, psize_t);
void m88110_cmmu_flush_remote_inst_cache(int, paddr_t, psize_t);
void m88110_cmmu_flush_inst_cache(paddr_t, psize_t);
void m88110_cmmu_flush_remote_data_cache(int, paddr_t, psize_t);
void m88110_cmmu_flush_data_cache(paddr_t, psize_t);
d120 1
a120 1
	m88110_cmmu_remote_set_sapr,
a122 1
	m88110_cmmu_flush_remote_tlb,
a124 1
	m88110_cmmu_flush_remote_cache,
a125 1
	m88110_cmmu_flush_remote_inst_cache,
a126 1
	m88110_cmmu_flush_remote_data_cache,
d311 1
a311 1
m88110_cmmu_remote_set_sapr(unsigned cpu, unsigned ap)
d386 1
a386 1
m88110_cmmu_flush_remote_tlb(unsigned cpu, unsigned kernel, vaddr_t vaddr,
a404 11
 *	flush my personal tlb
 */
void
m88110_cmmu_flush_tlb(unsigned kernel, vaddr_t vaddr, vsize_t size)
{
	int cpu = cpu_number();

	m88110_cmmu_flush_remote_tlb(cpu, kernel, vaddr, size);
}

/*
d460 1
a460 1
m88110_cmmu_flush_remote_cache(int cpu, paddr_t physaddr, psize_t size)
a471 11
 *	flush both Instruction and Data caches
 */
void
m88110_cmmu_flush_cache(paddr_t physaddr, psize_t size)
{
	int cpu = cpu_number();

	m88110_cmmu_flush_remote_cache(cpu, physaddr, size);
}

/*
d475 1
a475 1
m88110_cmmu_flush_remote_inst_cache(int cpu, paddr_t physaddr, psize_t size)
a482 8
void
m88110_cmmu_flush_inst_cache(paddr_t physaddr, psize_t size)
{
	int cpu = cpu_number();

	m88110_cmmu_flush_remote_inst_cache(cpu, physaddr, size);
}

d487 1
a487 1
m88110_cmmu_flush_remote_data_cache(int cpu, paddr_t physaddr, psize_t size)
a494 8
}

void
m88110_cmmu_flush_data_cache(paddr_t physaddr, psize_t size)
{
	int cpu = cpu_number();

	m88110_cmmu_flush_remote_data_cache(cpu, physaddr, size);
@


1.11
log
@Pass -Wformat, and silence a few vme* debug printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.10 2003/10/05 20:35:26 miod Exp $	*/
d64 1
d73 2
d584 5
d591 1
a591 1
		m88110_cmmu_sync_cache(kvtop(va), size);
d594 1
a594 1
		m88110_cmmu_sync_inval_cache(kvtop(va), size);
d597 1
a597 1
		m88110_cmmu_inval_cache(kvtop(va), size);
@


1.10
log
@More cmmu routines cleanup:
- remove unused routines (which were mostly here for debugging anyway)
- do not include <machine/m88*.h> from <machine/cmmu.h> but rather only
  from the modules which need them
- try to simplify the MVME187 codepath in the 8820x code, whenever possible
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.9 2003/09/26 22:27:26 miod Exp $	*/
d663 2
a664 2
		DEBUG_MSG("probe of 0x%08x missed the ATCs");
}
@


1.9
log
@Death to the bitfields, this time cmmu_apr_t and batc_entry_t. In the
process, remove duplicate batc defines.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.8 2003/09/16 20:46:11 miod Exp $	*/
d67 2
d78 1
a78 1
#endif 
d89 23
a111 5
/* FORWARDS */
void patc_clear(void);
void m88110_cmmu_sync_cache(vm_offset_t physaddr, int size);
void m88110_cmmu_sync_inval_cache(vm_offset_t physaddr, int size);
void m88110_cmmu_inval_cache(vm_offset_t physaddr, int size);
a115 1
        m88110_show_apr,
a116 2
	m88110_setup_cmmu_config,
	m88110_cmmu_dump_config,
a120 2
	m88110_cmmu_get_idr,
	m88110_cmmu_set_sapr,
a122 1
	m88110_cmmu_set_batc_entry,
d135 1
a135 1
	m88110_cmmu_get_by_mode,
d137 8
a144 2
	m88110_cmmu_cache_state,
	m88110_show_cmmu_info,
d148 5
d169 1
d186 1
d188 1
a188 1
void 
d191 1
a191 8
	/* dummy routine */
	m88110_setup_cmmu_config();
}

void 
m88110_setup_cmmu_config(void)
{
	/* we can print something here... */
a194 17
void m88110_cmmu_dump_config(void)
{
	/* dummy routine */
}

#ifdef DDB
/*
 * Used by DDB for cache probe functions
 */
unsigned m88110_cmmu_get_by_mode(int cpu, int mode)
{
	CMMU_LOCK;
	CMMU_UNLOCK;
	return 0;
}
#endif

d199 2
a200 2
*/
void 
d247 1
a247 1
	
d249 1
a249 1
	set_ictl(BATC_32M 
d252 1
a252 1
		 | CMMU_ICTL_CEN 
d256 1
a256 1
	set_dctl(BATC_32M 
d259 1
a259 1
		 | CMMU_DCTL_CEN 
d262 1
a262 1
		 | CMMU_DCTL_HTEN);      
d285 1
d288 1
d292 1
a292 1
 * enable parity
d294 1
a294 1
void 
d297 1
a297 1
#ifdef	PARITY_ENABLE
d300 1
a300 1
#endif  /* PARITY_ENABLE */
d309 1
a309 1
unsigned 
a314 7
/* Needs no locking - read only registers */
unsigned
m88110_cmmu_get_idr(unsigned data)
{
	return 0; /* todo */
}

d316 1
a316 1
m88110_cmmu_set_sapr(unsigned ap)
d319 1
d334 1
a334 1
	
d336 1
a336 1
	
d341 1
a341 1
	
d345 1
a345 1
	
a349 6
m88110_cmmu_remote_set_sapr(unsigned cpu, unsigned ap)
{
	m88110_cmmu_set_sapr(ap);
}

void
d362 2
a363 2
 * Set batc entry number entry_no to value in 
 * the data or instruction cache depending on data.
d365 2
a366 3
 * Except for the cmmu_init, this function, m88110_cmmu_set_pair_batc_entry,
 * and m88110_cmmu_pmap_activate are the only functions which may set the
 * batc values.
d369 1
a369 2
m88110_cmmu_set_batc_entry(unsigned cpu, unsigned entry_no, unsigned data,
    unsigned value)
d372 7
a378 7
	if (data) {
		set_dir(entry_no);
		set_dbp(value);
	} else {
		set_iir(entry_no);
		set_ibp(value);
	}
d383 1
a383 2
 * Set batc entry number entry_no to value in 
 * the data and instruction cache for the named CPU.
a384 10
void
m88110_cmmu_set_pair_batc_entry(unsigned cpu, unsigned entry_no, unsigned value)
{
	m88110_cmmu_set_batc_entry(cpu, entry_no, 1, value);
	m88110_cmmu_set_batc_entry(cpu, entry_no, 0, value);
}

/**
 **	Functions that invalidate TLB entries.
 **/
d391 2
a392 2
m88110_cmmu_flush_remote_tlb(unsigned cpu, unsigned kernel, vm_offset_t vaddr,
    int size)
d395 1
a395 1
	
d405 1
a405 1
	
d413 1
a413 1
m88110_cmmu_flush_tlb(unsigned kernel, vm_offset_t vaddr, int size)
d446 13
a458 13
/**
 **	Functions that invalidate caches.
 **
 ** Cache invalidates require physical addresses.  Care must be exercised when
 ** using segment invalidates.  This implies that the starting physical address
 ** plus the segment length should be invalidated.  A typical mistake is to
 ** extract the first physical page of a segment from a virtual address, and
 ** then expecting to invalidate when the pages are not physically contiguous.
 **
 ** We don't push Instruction Caches prior to invalidate because they are not
 ** snooped and never modified (I guess it doesn't matter then which form
 ** of the command we use then).
 **/
d460 2
a461 2
/* 
 * Care must be taken to avoid flushing the data cache when 
d467 6
d476 1
a476 1
m88110_cmmu_flush_remote_cache(int cpu, vm_offset_t physaddr, int size)
d479 1
a479 1
	
d491 1
a491 1
m88110_cmmu_flush_cache(vm_offset_t physaddr, int size)
d494 1
a494 1
	
d502 1
a502 1
m88110_cmmu_flush_remote_inst_cache(int cpu, vm_offset_t physaddr, int size)
d511 1
a511 1
m88110_cmmu_flush_inst_cache(vm_offset_t physaddr, int size)
d520 1
a520 1
 */ 
d522 2
a523 2
m88110_cmmu_flush_remote_data_cache(int cpu, vm_offset_t physaddr, int size)
{ 
d533 2
a534 2
m88110_cmmu_flush_data_cache(vm_offset_t physaddr, int size)
{ 
d544 1
a544 1
m88110_cmmu_sync_cache(vm_offset_t physaddr, int size)
d556 1
a556 1
m88110_cmmu_sync_inval_cache(vm_offset_t physaddr, int size)
d567 1
a567 1
m88110_cmmu_inval_cache(vm_offset_t physaddr, int size)
d570 1
a570 1
	
d579 1
a579 1
m88110_dma_cachectl(vm_offset_t va, int size, int op)
d595 5
d601 2
a602 19
   #define VV_EX_UNMOD		0
   #define VV_EX_MOD		1
   #define VV_SHARED_UNMOD		2
   #define VV_INVALID		3

   #define D(UNION, LINE) \
	((LINE) == 3 ? (UNION).field.d3 : \
	 ((LINE) == 2 ? (UNION).field.d2 : \
	  ((LINE) == 1 ? (UNION).field.d1 : \
	   ((LINE) == 0 ? (UNION).field.d0 : ~0))))
   #define VV(UNION, LINE) \
	((LINE) == 3 ? (UNION).field.vv3 : \
	 ((LINE) == 2 ? (UNION).field.vv2 : \
	  ((LINE) == 1 ? (UNION).field.vv1 : \
	   ((LINE) == 0 ? (UNION).field.vv0 : ~0))))


   #undef VEQR_ADDR
   #define  VEQR_ADDR 0
d709 1
a709 1
		if (badwordaddr((vm_offset_t)value)) {
d755 1
a755 1
		if (badwordaddr((vm_offset_t)value)) {
d797 1
a797 1
		if (badwordaddr((vm_offset_t)value)) {
a808 17
}


void
m88110_cmmu_cache_state(unsigned addr, unsigned supervisor_flag)
{
#ifdef not_yet
	static char *vv_name[4] =
	{"exclu-unmod", "exclu-mod", "shared-unmod", "invalid"};
	int cmmu_num;
#endif 
}

void
m88110_show_cmmu_info(unsigned addr)
{
	m88110_cmmu_cache_state(addr, 1);
@


1.8
log
@Provide more information about the CPU/CMMU configuration in the dmesg
output. Also, if the board configuration parameter area is invalid, warn the
user and assume safe values - this is likely caused by a dead NVRAM battery.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.7 2003/08/20 20:33:47 miod Exp $	*/
d62 1
a64 1
#include <machine/cpus.h>
a86 12
/* kernel copy of PATC entries */
unsigned patc_data_u[32];
unsigned patc_data_l[32];
unsigned patc_inst_u[32];
unsigned patc_inst_l[32];

#define INST	0
#define DATA	1
#define BOTH    2
#define KERN	1
#define USER	0

a87 1
void patc_insert(unsigned upper, unsigned lower, int which);
a88 2
void patc_sync(int which);
void patc_load(int index, unsigned upper, unsigned lower, int which);
a128 52
patc_load(int index, unsigned upper, unsigned lower, int which)
{
#ifdef DEBUG
	if (index > 31)
		panic("invalid PATC index %d!", index);
#endif

	index = index << 5;
	switch (which) {
	case INST:
		set_iir(index);
		set_ippu(upper);
		set_ippl(lower);
		break;
	case DATA:
		set_dir(index);
		set_dppu(upper);
		set_dppl(lower);
		break;
#ifdef DEBUG
	default:
		panic("invalid PATC! Choose DATA or INST...");
#endif
	}
}

void
patc_sync(int which)
{
	int i;

	switch (which) {
	case BOTH:
		for (i = 0; i < 32; i++) {
			patc_load(i, patc_data_u[i], patc_data_l[i], DATA);
			patc_load(i, patc_inst_u[i], patc_inst_l[i], INST);
		}
		break;
	case INST:
		for (i = 0; i < 32; i++) {
			patc_load(i, patc_inst_u[i], patc_inst_l[i], INST);
		}
		break;
	case DATA:
		for (i = 0; i < 32; i++) {
			patc_load(i, patc_data_u[i], patc_data_l[i], DATA);
		}
		break;
	}
}

void 
d134 7
a140 37
		patc_data_u[i] = 0;
		patc_data_l[i] = 0;
		patc_inst_u[i] = 0;
		patc_inst_l[i] = 0;
	}
	patc_sync(BOTH);
}

/* implement a FIFO on the PATC entries */
void 
patc_insert(unsigned upper, unsigned lower, int which)
{
	int i;

	switch(which) {
	case INST:
		for (i = 31; i > 0; i--) {
			patc_inst_u[i] = patc_inst_u[i - 1];
			patc_inst_l[i] = patc_inst_l[i - 1];
		}
		patc_inst_u[0] = upper;
		patc_inst_l[0] = lower;
		patc_sync(INST);
		break;
	case DATA:
		for (i = 31; i > 0; i--) {
			patc_data_u[i] = patc_data_u[i - 1];
			patc_data_l[i] = patc_data_l[i - 1];
		}
		patc_data_u[0] = upper;
		patc_data_l[0] = lower;
		patc_sync(DATA);
		break;
#ifdef DEBUG
	case BOTH:
		panic("patc_insert(): can't insert both INST and DATA.");
#endif
d147 2
a148 6
	union apr_template apr_template;

	apr_template.bits = value;

	printf("table @@ 0x%x000", apr_template.field.st_base);
	if (apr_template.field.wt)
d150 1
a150 1
	if (apr_template.field.g)
d152 1
a152 1
	if (apr_template.field.ci)
d154 1
a154 1
	if (apr_template.field.te)
d447 1
a447 1
    batc_template_t i_batc[BATC_MAX], batc_template_t d_batc[BATC_MAX])
d453 2
a454 2
	   m88110_cmmu_set_batc_entry(cpu, entry_no, 0, i_batc[entry_no].bits);
	   m88110_cmmu_set_batc_entry(cpu, entry_no, 1, d_batc[entry_no].bits);
a694 2
		union apr_template apr_template;
		apr_template.bits = value;
d697 1
a697 1
				  supervisor_flag ? 'S' : 'U', apr_template.bits);
d700 10
a709 10
			  supervisor_flag ? 'S' : 'U', apr_template.field.st_base);
		if (apr_template.field.wt) DEBUG_MSG(", WTHRU");
		else			   DEBUG_MSG(", !wthru");
		if (apr_template.field.g)  DEBUG_MSG(", GLOBAL");
		else			   DEBUG_MSG(", !global");
		if (apr_template.field.ci) DEBUG_MSG(", $INHIBIT");
		else			   DEBUG_MSG(", $ok");
		if (apr_template.field.te) DEBUG_MSG(", VALID");
		else			   DEBUG_MSG(", !valid");
		DEBUG_MSG(".\n");
d712 1
a712 1
		if (apr_template.field.te == 0) {
d716 1
a716 1
		value = apr_template.field.st_base << PG_BITS; /* now point to seg page */
@


1.7
log
@A bunch of 88110 band-aid:
- the 88410 handling code is not working correctly. Check whether we are
  operating with 88410's, and only invoke these routines if necessary.
- force serial mode execution in the PSR for the moment (hopefully only
  temporary)
- disable branch prediction and data matching in the PSR, the 88110 errata
  is simply too scary about them.
- a better pipeline flush after changing the ictl control register.

These changes let 197LE (but not 197SP/DP) boot up to autoconf.
Userland process do not work at the moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.6 2002/03/14 01:26:40 millert Exp $	*/
d313 12
a324 6
	printf("Processor %d: ", cpu);
	if (proctype)
		printf("Architectural Revision 0x%x UNKNOWN CPU TYPE Version 0x%x\n",
		       proctype, procvers);
	else
		printf("M88110 Version 0x%x\n", procvers);
@


1.6
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.5 2001/12/24 04:12:40 miod Exp $	*/
a58 1
#ifdef M88110
d68 1
a68 2

#define CMMU_DEBUG 1
a99 1
unsigned batc_val(unsigned phys, unsigned virt, unsigned prot);
a106 1
int probe_mmu(vm_offset_t va, int data);
d140 1
a140 1
#endif /* end if DDB */
d146 2
a147 2
	/* sanity check!!! */
	if (index > 31) {
d149 2
a150 1
	}
d163 1
d166 1
d174 1
d177 1
a177 1
		for (i=0; i<32; i++) {
d183 1
a183 1
		for (i=0; i<32; i++) {
d188 1
a188 1
		for (i=0; i<32; i++) {
d199 2
a200 1
	for (i=0; i<32; i++) {
d214 2
a215 1
	switch(which){
d217 3
a219 3
		for (i=31; i>0; i--) {
			patc_inst_u[i] = patc_inst_u[i-1];
			patc_inst_l[i] = patc_inst_l[i-1];
d226 3
a228 3
		for (i=31; i>0; i--) {
			patc_data_u[i] = patc_data_u[i-1];
			patc_data_l[i] = patc_data_l[i-1];
d234 1
d237 1
a240 13
unsigned 
batc_val(unsigned phys, unsigned virt, unsigned prot)
{
	unsigned val = 0;
	virt = (virt >> BATC_ADDR_SHIFT);
	val |= (virt << BATC_LBA_SHIFT);
	phys = (phys >> BATC_ADDR_SHIFT);
	val |= (phys << BATC_PBA_SHIFT);
	val |= prot;
	return(val);
}


d245 1
d249 10
a258 5
	if (apr_template.field.wt) printf(", writethrough");
	if (apr_template.field.g)  printf(", global");
	if (apr_template.field.ci) printf(", cache inhibit");
	if (apr_template.field.te) printf(", valid");
	else			   printf(", not valid");
a266 1
	return;
a273 1
	return;
a278 1
   return;
d288 1
a289 1
	CMMU_UNLOCK;
a321 1
	return;
a326 2
void m88110_load_patc(int entry, vm_offset_t vaddr, vm_offset_t paddr, int kernel);

d333 1
a333 1
	for (i=0; i<8; i++) {
d336 1
d340 1
d349 1
a355 1

d358 2
a359 1
	mc88410_inval();		/* clear external data cache */
a397 1
#define ILLADDRESS	U(0x0F000000) 	/* any faulty address */
a411 32
int 
probe_mmu(vm_offset_t va, int data)
{
	unsigned result;
	if (data) {
		CMMU_LOCK;
		set_dsar((unsigned)va);
		set_dcmd(CMMU_DCMD_PRB_SUPR);
		result = get_dsr();
		CMMU_UNLOCK;
		if (result & CMMU_DSR_BH)
			return 2;
		else if (result & CMMU_DSR_PH)
			return 1;
		else
			return 0;
	} else {
		CMMU_LOCK;
		set_isar((unsigned)va);
		set_icmd(CMMU_ICMD_PRB_SUPR);
		result = get_isr();
		CMMU_UNLOCK;
		if (result & CMMU_ISR_BH)
			return 2;
		else if (result & CMMU_ISR_PH)
			return 1;
		else
			return 0;
	}
	return 0;
}

a414 3
#if 0
	int result;
#endif 
d423 4
a426 3
	/* disabel translation */
	set_ictl((ictl &~ CMMU_ICTL_MEN));
	set_dctl((dctl &~ CMMU_DCTL_MEN));
a442 1
	return;
d472 2
a473 5
m88110_cmmu_set_batc_entry(
			unsigned cpu,
			unsigned entry_no,
			unsigned data,	 /* 1 = data, 0 = instruction */
			unsigned value)	 /* the value to stuff */
a491 1
/* the value to stuff into the batc */
d506 2
a507 1
m88110_cmmu_flush_remote_tlb(unsigned cpu, unsigned kernel, vm_offset_t vaddr, int size)
d509 1
a509 1
	register int s = splhigh();
d530 2
a531 2
	int cpu;
	cpu = cpu_number();
d538 1
a538 1
 * Only called from pmap.c's _pmap_activate().
d541 2
a542 5
m88110_cmmu_pmap_activate(
		       unsigned cpu,
		       unsigned uapr,
		       batc_template_t i_batc[BATC_MAX],
		       batc_template_t d_batc[BATC_MAX])
d555 1
a555 1
	 * THE SUPERVISOR TLBs SHOULB EE FLUSHED AS WELL.
d587 1
a587 1
	register int s = splhigh();
d591 2
a592 1
	mc88410_flush();
d613 1
a613 1
	register int s = splhigh();
a618 3
/*
 *	flush Instruction caches
 */
d622 2
a623 3
	int cpu;
	
	cpu = cpu_number();
d633 1
a633 1
	register int s = splhigh();
d636 2
a637 1
	mc88410_flush();
a640 3
/*
 * flush data cache
 */ 
d644 2
a645 3
	int cpu;
	
	cpu = cpu_number();
d655 1
a655 1
	register int s = splhigh();
d659 2
a660 1
	mc88410_flush();
d667 1
a667 1
	register int s = splhigh();
d670 2
a671 1
	mc88410_sync();
d678 1
a678 1
	register int s = splhigh();
d682 2
a683 1
	mc88410_inval();
d690 2
a691 1
	if (op == DMA_CACHE_SYNC)
d693 2
a694 1
	else if (op == DMA_CACHE_SYNC_INVAL)
d696 2
a697 1
	else
d699 2
d950 1
a950 84
#endif /* end if DDB */

#define MSDTENT(addr, va)	((sdt_entry_t *)(addr + SDTIDX(va)))
#define MPDTENT(addr, va)	((sdt_entry_t *)(addr + PDTIDX(va)))
void
m88110_load_patc(int entry, vm_offset_t vaddr, vm_offset_t paddr, int kernel)
{
	unsigned long lpa, pfa, i;

	lpa = (unsigned)vaddr & 0xFFFFF000;
	if (kernel) {
		lpa |= 0x01;
	}
	pfa = (unsigned)paddr & 0xFFFFF000;
	pfa |= 0x01;
	i = entry << 5;
	set_iir(i);
	set_ippu(lpa);
	set_ippl(pfa);
	set_dir(i);
	set_dppu(lpa);
	set_dppl(lpa);
}

int 
m88110_table_search(pmap_t map, vm_offset_t virt, int write, int kernel, int data)
{
	sdt_entry_t *sdt;
	pt_entry_t  *pte;
	unsigned long lpa, i;
	static unsigned int entry_num = 0;

	if (map == (pmap_t)0)
		panic("m88110_table_search: pmap is NULL");

	sdt = SDTENT(map, virt);

	/*
	 * Check whether page table exist or not.
	 */
	if (!SDT_VALID(sdt))
		return (4); /* seg fault */

	/* OK, it's valid.  Now check permissions. */
	if (!kernel && SDT_SUP(sdt))
			return (6); /* Supervisor Violation */
	if (write && SDT_WP(sdt))
			return (7); /* Write Violation */

	pte = (pt_entry_t *)(PG_PFNUM(*(sdt_entry_t *)(sdt + SDT_ENTRIES))<<PDT_SHIFT) + PDTIDX(virt);
	/*
	 * Check whether page frame exist or not.
	 */
	if (!PDT_VALID(pte))
		return (5); /* Page Fault */

	/* OK, it's valid.  Now check permissions. */
	if (!kernel && PDT_SUP(pte))
			return (6); /* Supervisor Violation */
	if (write && PDT_WP(pte))
			return (7); /* Write Violation */
	/* If we get here, load the PATC. */
	entry_num++;
	if (entry_num > 32)
		entry_num = 0;
	lpa = (unsigned)virt & 0xFFFFF000;
	if (kernel)
		lpa |= 0x01;
	i = entry_num << 5;
	if (data) {
		set_dir(i); /* set PATC index */
		set_dppu(lpa); /* set logical address */
		set_dppl((unsigned)pte); /* set page fram address */
	} else {
		set_iir(i);
		set_ippu(lpa);
		set_ippl((unsigned)pte);
	}
	return 0;
}

#endif /* M88110 */


@


1.5
log
@- completely change the mmu segment and page table structure definitions,
to use constant bitmasks instead of bitfields.
- remove unnecessary (as long as we are not running SMP) locks on the
physsegs.
- update the pmap code to take these changes into account, and gratuitously
change several names and code paths to be closer to existing m68k pmaps. It's
a bit faster now.
- change pmap.c's usage of vm_{offset,size}_t to {p,v}{addr,size}_t.
- remove dead or unused stuff from pmap.c, fix typos, etc

Tested on 187 and 188, should not make things worse for 197.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.4 2001/12/22 09:49:39 smurph Exp $	*/
d102 9
a110 9
unsigned batc_val __P((unsigned phys, unsigned virt, unsigned prot));
void patc_insert __P((unsigned upper, unsigned lower, int which));
void patc_clear __P((void));
void patc_sync __P((int which));
void patc_load __P((int index, unsigned upper, unsigned lower, int which));
void m88110_cmmu_sync_cache __P((vm_offset_t physaddr, int size));
void m88110_cmmu_sync_inval_cache __P((vm_offset_t physaddr, int size));
void m88110_cmmu_inval_cache __P((vm_offset_t physaddr, int size));
int probe_mmu __P((vm_offset_t va, int data));
@


1.5.2.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d102 9
a110 9
unsigned batc_val(unsigned phys, unsigned virt, unsigned prot);
void patc_insert(unsigned upper, unsigned lower, int which);
void patc_clear(void);
void patc_sync(int which);
void patc_load(int index, unsigned upper, unsigned lower, int which);
void m88110_cmmu_sync_cache(vm_offset_t physaddr, int size);
void m88110_cmmu_sync_inval_cache(vm_offset_t physaddr, int size);
void m88110_cmmu_inval_cache(vm_offset_t physaddr, int size);
int probe_mmu(vm_offset_t va, int data);
@


1.5.2.2
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d59 1
a62 1
#include <sys/systm.h>
a63 1

d65 1
a67 2
#include <machine/m88110.h>
#include <machine/m88410.h>
a68 1
#include <machine/trap.h>
d70 1
a70 1
#include <uvm/uvm_extern.h>
d78 1
a78 1
#endif
d89 22
a110 19
void m88110_cmmu_init(void);
void m88110_setup_board_config(void);
void m88110_cpu_configuration_print(int);
void m88110_cmmu_shutdown_now(void);
void m88110_cmmu_parity_enable(void);
unsigned m88110_cmmu_cpu_number(void);
void m88110_cmmu_set_sapr(unsigned, unsigned);
void m88110_cmmu_set_uapr(unsigned);
void m88110_cmmu_set_pair_batc_entry(unsigned, unsigned, unsigned);
void m88110_cmmu_flush_tlb(unsigned, unsigned, vaddr_t, vsize_t);
void m88110_cmmu_pmap_activate(unsigned, unsigned,
    u_int32_t i_batc[BATC_MAX], u_int32_t d_batc[BATC_MAX]);
void m88110_cmmu_flush_cache(int, paddr_t, psize_t);
void m88110_cmmu_flush_inst_cache(int, paddr_t, psize_t);
void m88110_cmmu_flush_data_cache(int, paddr_t, psize_t);
void m88110_dma_cachectl(vaddr_t, vsize_t, int);
void m88110_cmmu_dump_config(void);
void m88110_cmmu_show_translation(unsigned, unsigned, unsigned, int);
void m88110_show_apr(unsigned);
d115 1
d117 2
d123 1
d125 1
d127 1
d129 1
d132 1
d134 1
d136 1
d140 1
a140 1
	m88110_cmmu_dump_config,
d142 3
a144 9
#else
	NULL,
	NULL,
#endif
#ifdef DEBUG
        m88110_show_apr,
#else
	NULL,
#endif
d147 23
a169 4
void patc_clear(void);
void m88110_cmmu_sync_cache(paddr_t, psize_t);
void m88110_cmmu_sync_inval_cache(paddr_t, psize_t);
void m88110_cmmu_inval_cache(paddr_t, psize_t);
d172 24
d199 8
d208 26
a233 8
	for (i = 0; i < 32; i++) {
		set_dir(i << 5);
		set_dppu(0);
		set_dppl(0);

		set_iir(i << 5);
		set_ippu(0);
		set_ippl(0);
d237 13
a249 1
#ifdef DEBUG
d253 9
a261 11
	printf("table @@ 0x%x000", PG_PFNUM(value));
	if (value & CACHE_WT)
		printf(", writethrough");
	if (value & CACHE_GLOBAL)
		printf(", global");
	if (value & CACHE_INH)
		printf(", cache inhibit");
	if (value & APR_V)
		printf(", valid");
	else
		printf(", not valid");
a263 1
#endif
d265 1
a265 1
void
d268 9
a276 1
	/* we could print something here... */
d278 1
d281 18
d303 2
a304 2
 */
void
d319 6
a324 12
	printf("cpu%d: ", cpu);
	if (proctype != 1) {
		printf("unknown model arch 0x%x version 0x%x\n",
		    proctype, procvers);
		simple_unlock(&print_lock);
		return;
	}

	printf("M88110 version 0x%x", procvers);
	if (mc88410_present())
		printf(", external M88410 cache controller");
	printf("\n");
d328 1
d334 2
d342 1
a342 1
	for (i = 0; i < 8; i++) {
a344 1

d347 2
a348 3

	/* Do NOT enable ICTL_PREN (branch prediction) */
	set_ictl(BATC_32M
d351 1
a351 1
		 | CMMU_ICTL_CEN
d355 1
a355 2
	set_dctl(BATC_32M
                 | CMMU_DCTL_RSVD1	/* Data Matching Disable */
d357 1
a357 1
		 | CMMU_DCTL_CEN
d360 2
a361 1
		 | CMMU_DCTL_HTEN);
d365 1
a365 2
	if (mc88410_present())
		mc88410_inval();	/* clear external data cache */
a382 1
#if 0
a384 1
#endif
d388 1
a388 1
 * Enable parity
d390 1
a390 1
void
d393 1
a393 1
#if 0
d396 1
a396 1
#endif
d404 1
d406 1
a406 1
unsigned
d412 39
d452 1
a452 1
m88110_cmmu_set_sapr(unsigned cpu, unsigned ap)
d454 3
a457 1

d465 3
a467 4

	/* disable translation */
	set_ictl((ictl & ~CMMU_ICTL_MEN));
	set_dctl((dctl & ~CMMU_DCTL_MEN));
d471 1
a471 1

d473 1
a473 1

d478 1
a478 1

d482 4
d487 4
a490 1
	CMMU_UNLOCK;
d506 2
a507 2
 * Set batc entry number entry_no to value in
 * the data and instruction cache for the named CPU.
d509 3
a511 2
 * Except for the cmmu_init, this function and m88110_cmmu_pmap_activate
 * are the only functions which may set the batc values.
d514 5
a518 1
m88110_cmmu_set_pair_batc_entry(unsigned cpu, unsigned entry_no, unsigned value)
d521 7
a527 7

	set_dir(entry_no);
	set_dbp(value);

	set_iir(entry_no);
	set_ibp(value);

d532 2
a533 1
 *	Functions that invalidate TLB entries.
d535 11
d552 1
a552 2
m88110_cmmu_flush_tlb(unsigned cpu, unsigned kernel, vaddr_t vaddr,
    vsize_t size)
d554 2
a555 2
	int s = splhigh();	/* XXX really disable interrupts? */

d565 3
d569 9
a577 1
	splx(s);
d583 1
a583 1
 * Only called from pmap.c's pmap_activate().
d586 5
a590 2
m88110_cmmu_pmap_activate(unsigned cpu, unsigned uapr,
    u_int32_t i_batc[BATC_MAX], u_int32_t d_batc[BATC_MAX])
d596 2
a597 2
	   m88110_cmmu_set_batc_entry(cpu, entry_no, 0, i_batc[entry_no]);
	   m88110_cmmu_set_batc_entry(cpu, entry_no, 1, d_batc[entry_no]);
d603 1
a603 1
	 * THE SUPERVISOR TLBs SHOULD BE FLUSHED AS WELL.
d609 13
a621 13
/*
 *	Functions that invalidate caches.
 *
 * Cache invalidates require physical addresses.  Care must be exercised when
 * using segment invalidates.  This implies that the starting physical address
 * plus the segment length should be invalidated.  A typical mistake is to
 * extract the first physical page of a segment from a virtual address, and
 * then expecting to invalidate when the pages are not physically contiguous.
 *
 * We don't push Instruction Caches prior to invalidate because they are not
 * snooped and never modified (I guess it doesn't matter then which form
 * of the command we use then).
 */
d623 2
a624 2
/*
 * Care must be taken to avoid flushing the data cache when
d630 1
a630 3
 * XXX These routines are really suboptimal because they invalidate
 * way too much...
 * Improve them once the 197 support is really working...
d632 10
d647 1
a647 1
m88110_cmmu_flush_cache(int cpu, paddr_t physaddr, psize_t size)
d649 3
a651 7
	int s = splhigh();	/* XXX really disable interrupts? */

	mc88110_inval_inst();
	mc88110_flush_data();
	if (mc88410_present())
		mc88410_flush();
	splx(s);
d658 1
a658 1
m88110_cmmu_flush_inst_cache(int cpu, paddr_t physaddr, psize_t size)
d660 1
a660 1
	int s = splhigh();	/* XXX really disable interrupts? */
d667 1
a667 1
 * flush data cache
d670 1
a670 1
m88110_cmmu_flush_data_cache(int cpu, paddr_t physaddr, psize_t size)
d672 13
a684 1
	int s = splhigh();	/* XXX really disable interrupts? */
d687 1
a687 2
	if (mc88410_present())
		mc88410_flush();
d692 12
d707 1
a707 1
m88110_cmmu_sync_cache(paddr_t physaddr, psize_t size)
d709 1
a709 1
	int s = splhigh();	/* XXX really disable interrupts? */
d713 1
a713 2
	if (mc88410_present())
		mc88410_flush();
d718 1
a718 1
m88110_cmmu_sync_inval_cache(paddr_t physaddr, psize_t size)
d720 1
a720 1
	int s = splhigh();	/* XXX really disable interrupts? */
d723 1
a723 2
	if (mc88410_present())
		mc88410_sync();
d728 1
a728 1
m88110_cmmu_inval_cache(paddr_t physaddr, psize_t size)
d730 2
a731 2
	int s = splhigh();	/* XXX really disable interrupts? */

d734 1
a734 2
	if (mc88410_present())
		mc88410_inval();
d739 1
a739 1
m88110_dma_cachectl(vaddr_t va, vsize_t size, int op)
d741 7
a747 1
	paddr_t pa;
d749 1
a749 2
	if (pmap_extract(pmap_kernel(), va, &pa) == FALSE)
		return;	/* XXX */
d751 15
a765 12
	switch (op) {
	case DMA_CACHE_SYNC:
		m88110_cmmu_sync_cache(pa, size);
		break;
	case DMA_CACHE_SYNC_INVAL:
		m88110_cmmu_sync_inval_cache(pa, size);
		break;
	default:
		m88110_cmmu_inval_cache(pa, size);
		break;
	}
}
a766 6
#ifdef DDB
void
m88110_cmmu_dump_config(void)
{
	/* dummy routine */
}
d768 2
a769 2
#undef	VEQR_ADDR
#define	VEQR_ADDR	0
d830 2
a831 2
		DEBUG_MSG("probe of 0x%08x missed the ATCs", address);
	}
d836 2
d840 1
a840 1
				  supervisor_flag ? 'S' : 'U', value);
d843 10
a852 10
			  supervisor_flag ? 'S' : 'U', PG_PFNUM(value));
		if (value & CACHE_WT)
			DEBUG_MSG(", WTHRU");
		if (value & CACHE_GLOBAL)
			DEBUG_MSG(", GLOBAL");
		if (value & CACHE_INH)
			DEBUG_MSG(", INHIBIT");
		if (value & APR_V)
			DEBUG_MSG(", VALID");
		DEBUG_MSG("\n");
d855 1
a855 1
		if ((value & APR_V) == 0) {
d859 1
a859 1
		value &= PG_FRAME;	/* now point to seg page */
d878 1
a878 1
		if (badwordaddr((vaddr_t)value)) {
d924 1
a924 1
		if (badwordaddr((vaddr_t)value)) {
d966 1
a966 1
		if (badwordaddr((vaddr_t)value)) {
d979 101
a1079 1
#endif /* DDB */
@


1.5.2.3
log
@Merge with the trunk
@
text
@a107 1
void m88110_dma_cachectl_pa(paddr_t, psize_t, int);
a128 1
	m88110_dma_cachectl_pa,
a542 16
	switch (op) {
	case DMA_CACHE_SYNC:
		m88110_cmmu_sync_cache(pa, size);
		break;
	case DMA_CACHE_SYNC_INVAL:
		m88110_cmmu_sync_inval_cache(pa, size);
		break;
	default:
		m88110_cmmu_inval_cache(pa, size);
		break;
	}
}

void
m88110_dma_cachectl_pa(paddr_t pa, psize_t size, int op)
{
@


1.4
log
@masive cmmu overhaul.  function pointers now control cmmu functionality
instead of case statements based on cpu type.
@
text
@d1 1
a1 1
/*	$OpenBSD: m197_cmmu.c,v 1.13 2001/12/16 23:49:46 miod Exp $	*/
d789 3
a791 3
			unsigned segment_table_index:10,
			page_table_index:10,
			page_offset:12;
d859 1
a859 1
		value = apr_template.field.st_base << 12; /* now point to seg page */
d871 1
a871 1
		union sdt_entry_template std_template;
d876 1
a876 1
			 sizeof(struct sdt_entry);
d883 1
a883 1
		std_template.bits = *(unsigned *)value;
d885 1
a885 1
			DEBUG_MSG("SEG DESC @@0x%x is 0x%08x\n", value, std_template.bits);
d887 2
a888 2
			  value, std_template.sdt_desc.table_addr);
		if (std_template.sdt_desc.wt)	    DEBUG_MSG(", WTHRU");
d890 1
a890 1
		if (std_template.sdt_desc.sup)	    DEBUG_MSG(", S-PROT");
d892 1
a892 1
		if (std_template.sdt_desc.g)	    DEBUG_MSG(", GLOBAL");
d894 1
a894 1
		if (std_template.sdt_desc.no_cache) DEBUG_MSG(", $INHIBIT");
d896 1
a896 1
		if (std_template.sdt_desc.prot)	    DEBUG_MSG(", W-PROT");
d898 1
a898 1
		if (std_template.sdt_desc.dtype)    DEBUG_MSG(", VALID");
d903 1
a903 1
		if (std_template.sdt_desc.dtype == 0) {
d907 1
a907 1
		value = std_template.sdt_desc.table_addr << 12;
d917 1
a917 1
		union pte_template pte_template;
d922 1
a922 1
			 sizeof(struct pt_entry);
a925 1

d929 1
a929 1
		pte_template.bits = *(unsigned *)value;
d931 1
a931 1
			DEBUG_MSG("PAGE DESC @@0x%x is 0x%08x.\n", value, pte_template.bits);
d933 19
a951 19
			  value, pte_template.pte.pfn);
		if (pte_template.pte.wired)    DEBUG_MSG(", WIRE");
		else			       DEBUG_MSG(", !wire");
		if (pte_template.pte.wt)       DEBUG_MSG(", WTHRU");
		else			       DEBUG_MSG(", !wthru");
		if (pte_template.pte.sup)      DEBUG_MSG(", S-PROT");
		else			       DEBUG_MSG(", UserOk");
		if (pte_template.pte.g)	       DEBUG_MSG(", GLOBAL");
		else			       DEBUG_MSG(", !global");
		if (pte_template.pte.ci)       DEBUG_MSG(", $INHIBIT");
		else			       DEBUG_MSG(", $ok");
		if (pte_template.pte.modified) DEBUG_MSG(", MOD");
		else			       DEBUG_MSG(", !mod");
		if (pte_template.pte.pg_used)  DEBUG_MSG(", USED");
		else			       DEBUG_MSG(", !used");
		if (pte_template.pte.prot)     DEBUG_MSG(", W-PROT");
		else			       DEBUG_MSG(", WriteOk");
		if (pte_template.pte.dtype)    DEBUG_MSG(", VALID");
		else			       DEBUG_MSG(", !valid");
d955 1
a955 1
		if (pte_template.pte.dtype == 0) {
d960 1
a960 1
		value = pte_template.pte.pfn << 12;
a1019 5
#define SDT_WP(sd_ptr)  ((sd_ptr)->prot != 0)
#define SDT_SUP(sd_ptr)  ((sd_ptr)->sup != 0)
#define PDT_WP(pte_ptr)  ((pte_ptr)->prot != 0)
#define PDT_SUP(pte_ptr)  ((pte_ptr)->sup != 0)

d1045 1
a1045 1
	pte = (pt_entry_t *)(((sdt + SDT_ENTRIES)->table_addr)<<PDT_SHIFT) + PDTIDX(virt);
@


1.3
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.2 2001/12/14 04:30:12 smurph Exp $	*/
d73 1
a73 1
   #define DB_CMMU		0x4000	/* MMU debug */
d75 1
a75 1
   #define dprintf(_L_,_X_) { if (debuglevel & (_L_)) { unsigned int psr = disable_interrupts_return_psr(); printf("%d: ", cpu_number()); printf _X_;  set_psr(psr); } }
d77 1
a77 1
   #define dprintf(_L_,_X_)
d171 1
a171 1
void 
d209 1
a209 1
void
d284 1
a284 1
	return;
d340 1
a340 1
	
d361 1
a361 1
	
d366 1
a366 1
	
d462 1
a462 1
	
d661 1
a661 1
	
d710 1
a710 1
	
d721 1
a721 1
	
d753 1
a753 1
   #define VV_SHARED_UNMOD	2
d831 1
a831 1
	}
d833 1
a833 1
	
d1047 1
a1047 1
		return (6); /* Supervisor Violation */
d1049 2
a1050 2
		return (7); /* Write Violation */
	
d1060 1
a1060 1
		return (6); /* Supervisor Violation */
d1062 1
a1062 1
		return (7); /* Write Violation */
d1072 2
a1073 2
		set_dir(i);	/* set PATC index */
		set_dppu(lpa);	/* set logical address */
@


1.3.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.5 2001/12/24 04:12:40 miod Exp $	*/
d73 1
a73 1
#define DB_CMMU		0x4000	/* MMU debug */
d75 1
a75 1
#define dprintf(_L_,_X_) { if (debuglevel & (_L_)) { unsigned int psr = disable_interrupts_return_psr(); printf("%d: ", cpu_number()); printf _X_;  set_psr(psr); } }
d77 1
a77 1
#define dprintf(_L_,_X_)
d171 1
a171 1
void
d209 1
a209 1
void 
d284 1
a284 1
   return;
d340 1
a340 1

d361 1
a361 1

d366 1
a366 1

d462 1
a462 1

d661 1
a661 1

d710 1
a710 1

d721 1
a721 1

d753 1
a753 1
   #define VV_SHARED_UNMOD		2
d789 3
a791 3
			unsigned segment_table_index:SDT_BITS,
			page_table_index:PDT_BITS,
			page_offset:PG_BITS;
d831 1
a831 1
}
d833 1
a833 1

d859 1
a859 1
		value = apr_template.field.st_base << PG_BITS; /* now point to seg page */
d871 1
a871 1
		sdt_entry_t sdt;
d876 1
a876 1
			 sizeof(sdt_entry_t);
d883 1
a883 1
		sdt = *(sdt_entry_t *)value;
d885 1
a885 1
			DEBUG_MSG("SEG DESC @@0x%x is 0x%08x\n", value, sdt);
d887 2
a888 2
			  value, PG_PFNUM(sdt));
		if (sdt & CACHE_WT)		    DEBUG_MSG(", WTHRU");
d890 1
a890 1
		if (sdt & SG_SO)		    DEBUG_MSG(", S-PROT");
d892 1
a892 1
		if (sdt & CACHE_GLOBAL)		    DEBUG_MSG(", GLOBAL");
d894 1
a894 1
		if (sdt & CACHE_INH)		    DEBUG_MSG(", $INHIBIT");
d896 1
a896 1
		if (sdt & SG_PROT)		    DEBUG_MSG(", W-PROT");
d898 1
a898 1
		if (sdt & SG_V)			    DEBUG_MSG(", VALID");
d903 1
a903 1
		if (!(sdt & SG_V)) {
d907 1
a907 1
		value = ptoa(PG_PFNUM(sdt));
d917 1
a917 1
		pt_entry_t pte;
d922 1
a922 1
			 sizeof(pt_entry_t);
d926 1
d930 1
a930 1
		pte = *(pt_entry_t *)value;
d932 1
a932 1
			DEBUG_MSG("PAGE DESC @@0x%x is 0x%08x.\n", value, pte);
d934 19
a952 19
			  value, PG_PFNUM(pte));
		if (pte & PG_W)			DEBUG_MSG(", WIRE");
		else				DEBUG_MSG(", !wire");
		if (pte & CACHE_WT)		DEBUG_MSG(", WTHRU");
		else				DEBUG_MSG(", !wthru");
		if (pte & PG_SO)		DEBUG_MSG(", S-PROT");
		else				DEBUG_MSG(", UserOk");
		if (pte & CACHE_GLOBAL)		DEBUG_MSG(", GLOBAL");
		else				DEBUG_MSG(", !global");
		if (pte & CACHE_INH)		DEBUG_MSG(", $INHIBIT");
		else				DEBUG_MSG(", $ok");
		if (pte & PG_M)			DEBUG_MSG(", MOD");
		else				DEBUG_MSG(", !mod");
		if (pte & PG_U)			DEBUG_MSG(", USED");
		else				DEBUG_MSG(", !used");
		if (pte & PG_PROT)		DEBUG_MSG(", W-PROT");
		else				DEBUG_MSG(", WriteOk");
		if (pte & PG_V)			DEBUG_MSG(", VALID");
		else				DEBUG_MSG(", !valid");
d956 1
a956 1
		if (!(pte & PG_V)) {
d961 1
a961 1
		value = ptoa(PG_PFNUM(pte));
d1021 5
d1047 1
a1047 1
			return (6); /* Supervisor Violation */
d1049 3
a1051 3
			return (7); /* Write Violation */

	pte = (pt_entry_t *)(PG_PFNUM(*(sdt_entry_t *)(sdt + SDT_ENTRIES))<<PDT_SHIFT) + PDTIDX(virt);
d1060 1
a1060 1
			return (6); /* Supervisor Violation */
d1062 1
a1062 1
			return (7); /* Write Violation */
d1072 2
a1073 2
		set_dir(i); /* set PATC index */
		set_dppu(lpa); /* set logical address */
@


1.3.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.3.2.1 2002/01/31 22:55:19 niklas Exp $	*/
d102 9
a110 9
unsigned batc_val(unsigned phys, unsigned virt, unsigned prot);
void patc_insert(unsigned upper, unsigned lower, int which);
void patc_clear(void);
void patc_sync(int which);
void patc_load(int index, unsigned upper, unsigned lower, int which);
void m88110_cmmu_sync_cache(vm_offset_t physaddr, int size);
void m88110_cmmu_sync_inval_cache(vm_offset_t physaddr, int size);
void m88110_cmmu_inval_cache(vm_offset_t physaddr, int size);
int probe_mmu(vm_offset_t va, int data);
@


1.2
log
@Repair MVME187 after MVME197 merge.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.1 2001/12/13 08:55:52 smurph Exp $	*/
@


1.1
log
@Support for MVME197 completed.  Fix SPL defs.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110.c,v 1.3 2000/12/28 21:21:24 smurph Exp $	*/
a122 2
	m88110_cmmu_remote_set,
	m88110_cmmu_remote_get,
a409 20
}

/**
 **	Funcitons that actually modify CMMU registers.
 **/
void
m88110_cmmu_remote_set(unsigned cpu, unsigned r, unsigned data, unsigned x)
{
	panic("m88110_cmmu_remote_set() called!\n");
}

/*
 * cmmu_cpu_lock should be held when called if read
 * the CMMU_SCR or CMMU_SAR.
 */
unsigned
m88110_cmmu_remote_get(unsigned cpu, unsigned r, unsigned data)
{
	panic("m88110_cmmu_remote_get() called!\n");
	return 0;
@

