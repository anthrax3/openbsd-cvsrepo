head	1.44;
access;
symbols
	OPENBSD_3_6:1.42.0.2
	OPENBSD_3_6_BASE:1.42
	SMP_SYNC_A:1.39
	SMP_SYNC_B:1.39
	OPENBSD_3_5:1.39.0.2
	OPENBSD_3_5_BASE:1.39
	OPENBSD_3_4:1.32.0.2
	OPENBSD_3_4_BASE:1.32
	UBC_SYNC_A:1.27
	OPENBSD_3_3:1.27.0.2
	OPENBSD_3_3_BASE:1.27
	OPENBSD_3_2:1.25.0.4
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.25.0.2
	OPENBSD_3_1_BASE:1.25
	UBC_SYNC_B:1.25
	UBC:1.17.0.2
	UBC_BASE:1.17
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.6.0.8
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.6
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.4
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	mvme88kport:1.1.1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.44
date	2004.10.01.19.00.52;	author miod;	state dead;
branches;
next	1.43;

1.43
date	2004.09.30.21.48.57;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2004.08.02.08.35.00;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2004.08.01.17.18.05;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2004.07.22.18.58.04;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2004.01.08.14.29.46;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2004.01.05.20.07.03;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2003.10.11.22.07.47;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2003.10.02.10.20.12;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2003.09.28.22.14.35;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2003.09.26.23.37.04;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2003.09.26.21.43.30;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2003.09.01.22.51.05;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2003.09.01.19.14.04;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2003.08.22.11.23.06;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2003.08.10.21.34.20;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2003.08.01.07.47.58;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2003.01.14.03.20.16;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2003.01.13.20.12.18;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2002.03.14.01.26.40;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2002.02.05.23.16.08;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2002.01.14.21.34.41;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2002.01.10.21.45.33;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2001.12.22.19.27.48;	author smurph;	state Exp;
branches;
next	1.20;

1.20
date	2001.12.22.17.57.11;	author smurph;	state Exp;
branches;
next	1.19;

1.19
date	2001.12.22.09.49.39;	author smurph;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.20.06.07.28;	author smurph;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.19.07.04.41;	author smurph;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2001.12.16.23.49.46;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.13.08.55.52;	author smurph;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.27.05.37.02;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.26.14.31.12;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.07.22.18.07;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.20.05.53.10;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.09.05.44.41;	author smurph;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.08.00.03.31;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.01.03.38.20;	author smurph;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.14.20.25.25;	author smurph;	state Exp;
branches;
next	1.6;

1.6
date	99.09.27.19.13.22;	author smurph;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	99.02.09.06.36.28;	author smurph;	state Exp;
branches;
next	1.4;

1.4
date	98.12.15.05.11.02;	author smurph;	state Exp;
branches;
next	1.3;

1.3
date	97.03.03.20.21.38;	author rahnds;	state Exp;
branches;
next	1.2;

1.2
date	97.03.03.19.08.07;	author rahnds;	state dead;
branches;
next	1.1;

1.1
date	95.10.18.12.32.25;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.03.03.19.32.16;	author rahnds;	state Exp;
branches;
next	;

1.6.4.1
date	2001.04.18.16.11.34;	author niklas;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2001.07.04.10.20.14;	author niklas;	state Exp;
branches;
next	1.6.4.3;

1.6.4.3
date	2001.10.31.03.01.19;	author nate;	state Exp;
branches;
next	1.6.4.4;

1.6.4.4
date	2001.12.05.00.39.12;	author niklas;	state Exp;
branches;
next	1.6.4.5;

1.6.4.5
date	2002.03.06.02.04.45;	author niklas;	state Exp;
branches;
next	1.6.4.6;

1.6.4.6
date	2002.03.28.10.36.02;	author niklas;	state Exp;
branches;
next	1.6.4.7;

1.6.4.7
date	2003.03.27.23.32.18;	author niklas;	state Exp;
branches;
next	1.6.4.8;

1.6.4.8
date	2004.02.19.10.49.07;	author niklas;	state Exp;
branches;
next	;

1.17.2.1
date	2002.01.31.22.55.19;	author niklas;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2002.06.11.03.37.10;	author art;	state Exp;
branches;
next	1.17.2.3;

1.17.2.3
date	2003.05.19.21.45.53;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.44
log
@More mvme88k code cleaning:
- merge locore_c_routines.c into machdep.c
- split machdep.c into really machdep.c content, and board-specific routines
  (memory sizing, early initialization, etc).

No functionnal change.
@
text
@/* $OpenBSD: locore_c_routines.c,v 1.43 2004/09/30 21:48:57 miod Exp $	*/
/*
 * Mach Operating System
 * Copyright (c) 1993-1991 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON AND OMRON ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON AND OMRON DISCLAIM ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/systm.h>

#include <machine/asm.h>		/* END_OF_VECTOR_LIST, etc.	*/
#include <machine/asm_macro.h>		/* enable/disable interrupts	*/
#include <machine/cpu_number.h>		/* cpu_number()		*/
#include <machine/locore.h>
#include <machine/prom.h>
#include <machine/trap.h>

#ifdef MVME188
#include <machine/mvme188.h>
#endif

typedef struct {
	unsigned word_one, word_two;
} m88k_exception_vector_area;

extern unsigned int *volatile int_mask_reg[MAX_CPUS]; /* in machdep.c */
extern unsigned master_cpu;      /* in cmmu.c */

void setlevel(unsigned int);
void vector_init(m88k_exception_vector_area *, unsigned *);

#define SIGSYS_MAX	501
#define SIGTRAP_MAX	510

#define EMPTY_BR	0xc0000000	/* empty "br" instruction */
#define NO_OP 		0xf4005800	/* "or r0, r0, r0" */

#define BRANCH(FROM, TO) \
	(EMPTY_BR | ((unsigned)(TO) - (unsigned)(FROM)) >> 2)

#define SET_VECTOR(NUM, VALUE) \
	do { \
		vector[NUM].word_one = NO_OP; \
		vector[NUM].word_two = BRANCH(&vector[NUM].word_two, VALUE); \
	} while (0)

/*
 * vector_init(vector, vector_init_list)
 *
 * This routine sets up the m88k vector table for the running processor.
 * It is called with a very little stack, and interrupts disabled,
 * so don't call any other functions!
 *	XXX clean this - nivas
 */
void
vector_init(m88k_exception_vector_area *vector, unsigned *vector_init_list)
{
	unsigned num;
	unsigned vec;
	extern void bugtrap(void);
	extern void m88110_bugtrap(void);

	for (num = 0; (vec = vector_init_list[num]) != END_OF_VECTOR_LIST;
	    num++) {
		if (vec != UNKNOWN_HANDLER)
			SET_VECTOR(num, vec);
	}

	/* Save BUG vector */
	bugvec[0] = vector[MVMEPROM_VECTOR].word_one;
	bugvec[1] = vector[MVMEPROM_VECTOR].word_two;

#ifdef M88110
	if (CPU_IS88110) {
		for (; num <= SIGSYS_MAX; num++)
			SET_VECTOR(num, m88110_sigsys);

		for (; num <= SIGTRAP_MAX; num++)
			SET_VECTOR(num, m88110_sigtrap);

		SET_VECTOR(450, m88110_syscall_handler);
		SET_VECTOR(MVMEPROM_VECTOR, m88110_bugtrap);
		SET_VECTOR(504, m88110_stepbpt);
		SET_VECTOR(511, m88110_userbpt);
	}
#endif
#ifdef M88100
	if (CPU_IS88100) {
		for (; num <= SIGSYS_MAX; num++)
			SET_VECTOR(num, sigsys);

		for (; num <= SIGTRAP_MAX; num++)
			SET_VECTOR(num, sigtrap);

		SET_VECTOR(450, syscall_handler);
		SET_VECTOR(MVMEPROM_VECTOR, bugtrap);
		SET_VECTOR(504, stepbpt);
		SET_VECTOR(511, userbpt);
	}
#endif

	/* GCC will by default produce explicit trap 503 for division by zero */
	SET_VECTOR(503, vector_init_list[T_ZERODIV]);

	/* Save new BUG vector */
	sysbugvec[0] = vector[MVMEPROM_VECTOR].word_one;
	sysbugvec[1] = vector[MVMEPROM_VECTOR].word_two;
}

#ifdef MVME188
#if 0
unsigned int int_mask_shadow[MAX_CPUS] = {0, 0, 0, 0};
unsigned int blocked_interrupts_mask;
#endif
unsigned int m188_curspl[MAX_CPUS] = {0, 0, 0, 0};

unsigned int int_mask_val[INT_LEVEL] = {
	MASK_LVL_0,
	MASK_LVL_1,
	MASK_LVL_2,
	MASK_LVL_3,
	MASK_LVL_4,
	MASK_LVL_5,
	MASK_LVL_6,
	MASK_LVL_7
};

/*
 * return next safe spl to reenable interrupts.
 */
unsigned int
safe_level(mask, curlevel)
	unsigned mask;
	unsigned curlevel;
{
	int i;

	for (i = curlevel; i < 8; i++)
		if (!(int_mask_val[i] & mask))
			return i;

	panic("safe_level: no safe level for mask 0x%08x level %d found",
	       mask, curlevel);
	/* NOTREACHED */
}

void
setlevel(unsigned int level)
{
	unsigned int mask;
	int cpu = cpu_number();

	mask = int_mask_val[level];

	if (cpu != master_cpu)
		mask &= SLAVE_MASK;

#if 0
	mask &= ISR_SOFTINT_EXCEPT_MASK(cpu);
	mask &= ~blocked_interrupts_mask;
#endif

	*int_mask_reg[cpu] = mask;
#if 0
	int_mask_shadow[cpu] = mask;
#endif
	m188_curspl[cpu] = level;
}

#endif  /* MVME188 */

unsigned
getipl(void)
{
	unsigned curspl;
	m88k_psr_type psr; /* processor status register */

	psr = disable_interrupts_return_psr();
	switch (brdtyp) {
#ifdef MVME188
	case BRD_188:
		curspl = m188_curspl[cpu_number()];
		break;
#endif /* MVME188 */
#if defined(MVME187) || defined(MVME197)
	case BRD_187:
	case BRD_8120:
	case BRD_197:
		curspl = *md.intr_mask & 0x07;
		break;
#endif /* defined(MVME187) || defined(MVME197) */
	}
	set_psr(psr);
	return curspl;
}

unsigned
setipl(unsigned level)
{
	unsigned curspl;
	m88k_psr_type psr; /* processor status register */

#ifdef DEBUG
	if (level > 7) {
		printf("setipl: invoked with invalid level %x\n", level);
		level &= 0x07;	/* and pray it will work */
	}
#endif

	psr = disable_interrupts_return_psr();
	switch (brdtyp) {
#ifdef MVME188
	case BRD_188:
		curspl = m188_curspl[cpu_number()];
		setlevel(level);
		break;
#endif /* MVME188 */
#if defined(MVME187) || defined(MVME197)
	case BRD_187:
	case BRD_8120:
	case BRD_197:
		curspl = *md.intr_mask & 0x07;
		*md.intr_mask = level;
		break;
#endif /* defined(MVME187) || defined(MVME197) */
	}

	flush_pipeline();

	/* The flush pipeline is required to make sure the above write gets
	 * through the data pipe and to the hardware; otherwise, the next
	 * bunch of instructions could execute at the wrong spl protection
	 */
	set_psr(psr);
	return curspl;
}

unsigned
raiseipl(unsigned level)
{
	unsigned curspl;
	m88k_psr_type psr; /* processor status register */

#ifdef DEBUG
	if (level > 7) {
		printf("raiseipl: invoked with invalid level %x\n", level);
		level &= 0x07;	/* and pray it will work */
	}
#endif

	psr = disable_interrupts_return_psr();
	switch (brdtyp) {
#ifdef MVME188
	case BRD_188:
		curspl = m188_curspl[cpu_number()];
		if (curspl < level)
			setlevel(level);
		break;
#endif /* MVME188 */
#if defined(MVME187) || defined(MVME197)
	case BRD_187:
	case BRD_8120:
	case BRD_197:
		curspl = *md.intr_mask & 0x07;
		if (curspl < level)
			*md.intr_mask = level;
		break;
#endif /* defined(MVME187) || defined(MVME197) */
	}

	flush_pipeline();

	/* The flush pipeline is required to make sure the above write gets
	 * through the data pipe and to the hardware; otherwise, the next
	 * bunch of instructions could execute at the wrong spl protection
	 */
	set_psr(psr);
	return curspl;
}

/* XXX Utterly bogus */
#if NCPUS > 1
#include <sys/simplelock.h>
void
simple_lock_init(lkp)
	struct simplelock *volatile lkp;
{
	lkp->lock_data = 0;
}

int
test_and_set(lock)
	int *volatile lock;
{
#if 0
	int oldlock = *lock;
	if (*lock == 0) {
		*lock = 1;
		return 0;
	}
#else
	return *lock;
	*lock = 1;
	return 0;
#endif
}
#endif
@


1.43
log
@Introduce sparc-like CPU_ISFOO macros, to short-circuit evaluations when
compiling for one flavour only.

This makes code slightly smaller on all m88k-based platforms (my roughly
1KB), and saves more than meets the eye on luna88k, which is m88100-based.
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.42 2004/08/02 08:35:00 miod Exp $	*/
@


1.42
log
@More include files cleaning:
- move MAX_CPUS constant to <machine/cpu.h>
- do not include <machine/board.h> unless needed. In fact, remove this file
  entirely on mvme88k, and include <machine/mvme*.h> on a
  compiling-for-this-board basis
- keep MAX_CMMUS constant private to the m8820x code
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.41 2004/08/01 17:18:05 miod Exp $	*/
a93 1
	switch (cputyp) {
d95 1
a95 1
	case CPU_88110:
d106 2
a107 2
		break;
#endif /* M88110 */
d109 1
a109 1
	case CPU_88100:
a119 2
		break;
#endif /* M88100 */
d121 1
@


1.41
log
@Move 88100 DAE code to its own file, shared between luna88k and mvme88k.
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.40 2004/07/22 18:58:04 miod Exp $	*/
a31 1
#include <machine/board.h>		/* m188 bit defines	*/
d38 4
@


1.40
log
@Do not use db_printf() to trace data access exceptions.
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.39 2004/01/08 14:29:46 miod Exp $	*/
a28 2
#include "assym.h"

a29 1
#include <sys/types.h>
a32 1
#include <machine/cmmu.h>		/* DMT_VALID		*/
a38 3
#ifdef M88100
#include <machine/m88100.h>
#endif
a46 1
/* FORWARDS */
a48 231

#ifdef M88100

/*
 *  data access emulation for M88100 exceptions
 */

#define DMT_BYTE	1
#define DMT_HALF	2
#define DMT_WORD	4

const struct {
	unsigned char    offset;
	unsigned char    size;
} dmt_en_info[16] = {
	{0, 0}, {3, DMT_BYTE}, {2, DMT_BYTE}, {2, DMT_HALF},
	{1, DMT_BYTE}, {0, 0}, {0, 0}, {0, 0},
	{0, DMT_BYTE}, {0, 0}, {0, 0}, {0, 0},
	{0, DMT_HALF}, {0, 0}, {0, 0}, {0, DMT_WORD}
};

#ifdef DATA_DEBUG
int data_access_emulation_debug = 0;
#define DAE_DEBUG(stuff) \
	do { \
		if (data_access_emulation_debug != 0) { \
			stuff; \
		} \
	} while (0)
#else
#define DAE_DEBUG(stuff)
#endif

void
dae_print(unsigned *eframe)
{
	int x;
	unsigned dmax, dmdx, dmtx;

	if (!ISSET(eframe[EF_DMT0], DMT_VALID))
		return;

	for (x = 0; x < 3; x++) {
		dmtx = eframe[EF_DMT0 + x * 3];
		if (!ISSET(dmtx, DMT_VALID))
			continue;

		dmdx = eframe[EF_DMD0 + x * 3];
		dmax = eframe[EF_DMA0 + x * 3];

		if (ISSET(dmtx, DMT_WRITE))
			printf("[DMT%d=%x: st.%c %x to %x as %d %s %s]\n",
			    x, dmtx, dmtx & DMT_DAS ? 's' : 'u', dmdx, dmax,
			    DMT_ENBITS(dmtx),
			    dmtx & DMT_DOUB1 ? "double": "not double",
			    dmtx & DMT_LOCKBAR ? "xmem": "not xmem");
		else
			printf("[DMT%d=%x: ld.%c r%d <- %x as %d %s %s]\n",
			    x, dmtx, dmtx & DMT_DAS ? 's' : 'u',
			    DMT_DREGBITS(dmtx), dmax, DMT_ENBITS(dmtx),
			    dmtx & DMT_DOUB1 ? "double": "not double",
			    dmtx & DMT_LOCKBAR ? "xmem": "not xmem");
	}
}

void
data_access_emulation(unsigned *eframe)
{
	int x;
	unsigned dmax, dmdx, dmtx;
	unsigned v, reg;

	dmtx = eframe[EF_DMT0];
	if (!ISSET(dmtx, DMT_VALID))
		return;

	for (x = 0; x < 3; x++) {
		dmtx = eframe[EF_DMT0 + x * 3];
		if (!ISSET(dmtx, DMT_VALID) || ISSET(dmtx, DMT_SKIP))
			continue;

		dmdx = eframe[EF_DMD0 + x * 3];
		dmax = eframe[EF_DMA0 + x * 3];

      DAE_DEBUG(
		if (ISSET(dmtx, DMT_WRITE))
			printf("[DMT%d=%x: st.%c %x to %x as %d %s %s]\n",
			    x, dmtx, dmtx & DMT_DAS ? 's' : 'u', dmdx, dmax,
			    DMT_ENBITS(dmtx),
			    dmtx & DMT_DOUB1 ? "double": "not double",
			    dmtx & DMT_LOCKBAR ? "xmem": "not xmem");
		else
			printf("[DMT%d=%x: ld.%c r%d <- %x as %d %s %s]\n",
			    x, dmtx, dmtx & DMT_DAS ? 's' : 'u',
			    DMT_DREGBITS(dmtx), dmax, DMT_ENBITS(dmtx),
			    dmtx & DMT_DOUB1 ? "double": "not double",
			    dmtx & DMT_LOCKBAR ? "xmem": "not xmem")
	);

		dmax += dmt_en_info[DMT_ENBITS(dmtx)].offset;
		reg = DMT_DREGBITS(dmtx);

		if (!ISSET(dmtx, DMT_LOCKBAR)) {
			/* the fault is not during an XMEM */

			if (x == 2 && ISSET(dmtx, DMT_DOUB1)) {
				/* pipeline 2 (earliest stage) for a double */

				if (ISSET(dmtx, DMT_WRITE)) {
					/*
					 * STORE DOUBLE WILL BE REINITIATED
					 * BY rte
					 */
				} else {
					/* EMULATE ld.d INSTRUCTION */
					v = do_load_word(dmax, dmtx & DMT_DAS);
					if (reg != 0)
						eframe[EF_R0 + reg] = v;
					v = do_load_word(dmax ^ 4,
					    dmtx & DMT_DAS);
					if (reg != 31)
						eframe[EF_R0 + reg + 1] = v;
				}
			} else {
				/* not pipeline #2 with a double */
				if (dmtx & DMT_WRITE) {
					switch (dmt_en_info[DMT_ENBITS(dmtx)].size) {
					case DMT_BYTE:
					DAE_DEBUG(
						printf("[byte %x -> [%x(%c)]\n",
						    dmdx & 0xff, dmax,
						    ISSET(dmtx, DMT_DAS) ? 's' : 'u')
					);
						do_store_byte(dmax, dmdx,
						    dmtx & DMT_DAS);
						break;
					case DMT_HALF:
					DAE_DEBUG(
						printf("[half %x -> [%x(%c)]\n",
						    dmdx & 0xffff, dmax,
						    ISSET(dmtx, DMT_DAS) ? 's' : 'u')
					);
						do_store_half(dmax, dmdx,
						    dmtx & DMT_DAS);
						break;
					case DMT_WORD:
					DAE_DEBUG(
						printf("[word %x -> [%x(%c)]\n",
						    dmdx, dmax,
						    ISSET(dmtx, DMT_DAS) ? 's' : 'u')
					);
						do_store_word(dmax, dmdx,
						    dmtx & DMT_DAS);
						break;
					}
				} else {
					/* else it's a read */
					switch (dmt_en_info[DMT_ENBITS(dmtx)].size) {
					case DMT_BYTE:
						v = do_load_byte(dmax,
						    dmtx & DMT_DAS);
						if (!ISSET(dmtx, DMT_SIGNED))
							v &= 0x000000ff;
						break;
					case DMT_HALF:
						v = do_load_half(dmax,
						    dmtx & DMT_DAS);
						if (!ISSET(dmtx, DMT_SIGNED))
							v &= 0x0000ffff;
						break;
					case DMT_WORD:
						v = do_load_word(dmax,
						    dmtx & DMT_DAS);
						break;
					}
					DAE_DEBUG(
						if (reg == 0)
							printf("[no write to r0 done]\n");
						else
							printf("[r%d <- %x]\n", reg, v);
					);
					if (reg != 0)
						eframe[EF_R0 + reg] = v;
				}
			}
		} else {
			/* if lockbar is set... it's part of an XMEM */
			/*
			 * According to Motorola's "General Information",
			 * the DMT_DOUB1 bit is never set in this case, as it
			 * should be.
			 * If lockbar is set (as it is if we're here) and if
			 * the write is not set, then it's the same as if DOUB1
			 * was set...
			 */
			if (!ISSET(dmtx, DMT_WRITE)) {
				if (x != 2) {
					/* RERUN xmem WITH DMD(x+1) */
					x++;
					dmdx = eframe[EF_DMD0 + x * 3];
				} else {
					/* RERUN xmem WITH DMD2 */
				}

				if (dmt_en_info[DMT_ENBITS(dmtx)].size ==
				    DMT_WORD) {
					v = do_xmem_word(dmax, dmdx,
					    dmtx & DMT_DAS);
				} else {
					v = do_xmem_byte(dmax, dmdx,
					    dmtx & DMT_DAS);
				}
				if (reg != 0)
					eframe[EF_R0 + reg] = v;
			} else {
				if (x == 0) {
					if (reg != 0)
						eframe[EF_R0 + reg] = dmdx;
					eframe[EF_SFIP] = eframe[EF_SNIP];
					eframe[EF_SNIP] = eframe[EF_SXIP];
					eframe[EF_SXIP] = 0;
					/* xmem RERUN ON rte */
					eframe[EF_DMT0] = 0;
					return;
				}
			}
		}
	}
	eframe[EF_DMT0] = 0;
}
#endif /* M88100 */
@


1.39
log
@Some splfoo() have raise-if-lower semantics; so introduce raiseipl() which
never lowers current spl value, and use it where appropriate.
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.38 2004/01/05 20:07:03 miod Exp $	*/
a46 14
#ifdef DDB
#include <ddb/db_output.h>
#endif /* DDB */

#if defined(DDB) && defined(JEFF_DEBUG)
#define DATA_DEBUG
#endif

#if DDB
#define DEBUG_MSG db_printf
#else
#define DEBUG_MSG printf
#endif /* DDB */

d186 1
a186 1
						DEBUG_MSG("[byte %x -> [%x(%c)]\n",
d195 1
a195 1
						DEBUG_MSG("[half %x -> [%x(%c)]\n",
d204 1
a204 1
						DEBUG_MSG("[word %x -> [%x(%c)]\n",
d234 1
a234 1
							DEBUG_MSG("[no write to r0 done]\n");
d236 1
a236 1
							DEBUG_MSG("[r%d <- %x]\n", reg, v);
@


1.38
log
@Stop masquerading the M8120 (no-slot MVME187) as a real MVME187, and keep
its value in brdtyp.

Compensate by checking for BRD_8120 everywhere BRD_187 was checked.
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.37 2003/10/11 22:07:47 miod Exp $	*/
d476 1
a476 1
#ifdef DIAGNOSTIC
a477 1
#ifdef DEBUG
a478 1
#endif
d497 43
@


1.37
log
@Simplify DAE debug display.
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.36 2003/10/02 10:20:12 miod Exp $	*/
d460 1
d495 1
@


1.36
log
@Fix some DAE processing logic - the kernel would incorrectly end up retrying
already processed, or unwanted, DAE in certain circumstances by mistake.
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.35 2003/09/28 22:14:35 miod Exp $	*/
d82 1
a82 1
static struct {
a93 7
static char *bytes[] =
{
   "____", "___x", "__x_", "__xx",
   "_x__", "_x_x", "_xx_", "_xxx",
   "x___", "x__x", "x_x_", "x_xx",
   "xx__", "xx_x", "xxx_", "xxxx",
};
d104 1
a104 1
void 
a108 7
	static char *bytes[] =
	{
		"____", "___x", "__x_", "__xx",
		"_x__", "_x_x", "_xx_", "_xxx",
		"x___", "x__x", "x_x_", "x_xx",
		"xx__", "xx_x", "xxx_", "xxxx",
	};
d110 1
a110 1
	if (!(eframe[EF_DMT0] & DMT_VALID))
a114 1

d122 1
a122 1
			printf("[DMT%d=%x: st.%c %x to %x as [%s] %s %s]\n",
d124 1
a124 1
			    bytes[DMT_ENBITS(dmtx)], 
d128 1
a128 1
			printf("[DMT%d=%x: ld.%c r%d <- %x as [%s] %s %s]\n",
d130 1
a130 2
			    DMT_DREGBITS(dmtx), dmax,
			    bytes[DMT_ENBITS(dmtx)], 
d146 1
a146 1
   
a148 1

d157 1
a157 1
			printf("[DMT%d=%x: st.%c %x to %x as [%s] %s %s]\n",
d159 1
a159 1
			    bytes[DMT_ENBITS(dmtx)], 
d163 1
a163 1
			printf("[DMT%d=%x: ld.%c r%d <- %x as [%s] %s %s]\n",
d165 1
a165 2
			    DMT_DREGBITS(dmtx), dmax,
			    bytes[DMT_ENBITS(dmtx)], 
d225 1
a225 1
					} 
d326 1
a326 1
void 
d391 7
a397 7
	MASK_LVL_0, 
	MASK_LVL_1, 
	MASK_LVL_2, 
	MASK_LVL_3, 
	MASK_LVL_4, 
	MASK_LVL_5, 
	MASK_LVL_6, 
d404 1
a404 1
unsigned int 
d424 1
a424 1
	int cpu = cpu_number(); 
d434 1
a434 1
#endif 
d439 1
a439 1
#endif 
d445 1
a445 1
unsigned 
d469 1
a469 1
unsigned 
d521 1
a521 1
int 
d524 1
a524 1
{   
d535 1
a535 1
#endif 
@


1.35
log
@Clean various MVME188 related routines, fixing typos and removing unnecessary
diagnostic code in the process.
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.34 2003/09/26 23:37:04 miod Exp $	*/
d160 1
a160 1
	if (!ISSET(dmtx, DMT_VALID) && !ISSET(dmtx, DMT_SKIP))
d166 1
a166 1
		if (!ISSET(dmtx, DMT_VALID) && !ISSET(dmtx, DMT_SKIP))
@


1.34
log
@Death to the bitfields, this time "struct dmt_reg" - and I think that's all.
While there, KNF data_access_exception().
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.33 2003/09/26 21:43:30 miod Exp $	*/
a443 3
	if (level > 7) {
		panic("setlevel: bad level 0x%x", level);
	}
@


1.33
log
@Typos: defintion -> definition, proccess -> process

There are more occurences hiding in binutils, lynx and afs but I am too
lazy to report them upstream at the moment.
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.32 2003/09/01 22:51:05 miod Exp $	*/
d44 1
a44 1
#include <machine/m88100.h>		/* DMT_VALID		*/
d48 1
a48 1
#include <ddb/db_output.h>		/* db_printf()		*/
a60 7
/*
 *  data access emulation for M88100 exceptions
 */
#define DMT_BYTE	1
#define DMT_HALF	2
#define DMT_WORD	4

d62 1
a62 2
   unsigned word_one,
   word_two;
d69 2
a70 1
void vector_init(m88k_exception_vector_area *vector, unsigned *vector_init_list);
d73 9
a90 1
#endif 
d101 6
a106 2
#define DAE_DEBUG(stuff) {						\
	if (data_access_emulation_debug != 0) { stuff ;}   }
a110 3
void setlevel(unsigned int);

#ifdef M88100
d114 2
a115 3
	register int x;
	register struct dmt_reg *dmtx;
	register unsigned  dmax, dmdx;
d128 1
a128 1
		dmtx = (struct dmt_reg *)&eframe[EF_DMT0+x*3];
d130 1
a130 1
		if (!dmtx->dmt_valid)
d133 2
a134 2
		dmdx = eframe[EF_DMD0+x*3];
		dmax = eframe[EF_DMA0+x*3];
d136 1
a136 1
		if (dmtx->dmt_write)
d138 4
a141 4
			       x, eframe[EF_DMT0+x*3], dmtx->dmt_das ? 's' : 'u',
			       dmdx, dmax, bytes[dmtx->dmt_en], 
			       dmtx->dmt_doub1 ? "double": "not double",
			       dmtx->dmt_lockbar ? "xmem": "not xmem");
d144 5
a148 5
			       x, eframe[EF_DMT0+x*3], dmtx->dmt_das ? 's' : 'u',
			       dmtx->dmt_dreg, dmax, bytes[dmtx->dmt_en], 
			       dmtx->dmt_doub1 ? "double": "not double",
			       dmtx->dmt_lockbar ? "xmem": "not xmem");

d155 7
a161 8
   register int x;
   register struct dmt_reg *dmtx;
   register unsigned  dmax, dmdx;
   register unsigned  v, reg;

   dmtx = (struct dmt_reg *)&eframe[EF_DMT0];
   if (!dmtx->dmt_valid && !dmtx->dmt_skip)
      return;
d163 2
a164 2
   for (x = 0; x < 3; x++) {
      dmtx = (struct dmt_reg *)&eframe[EF_DMT0+x*3];
d166 2
a167 2
      if (!dmtx->dmt_valid || dmtx->dmt_skip)	
         continue;
d169 2
a170 2
      dmdx = eframe[EF_DMD0+x*3];
      dmax = eframe[EF_DMA0+x*3];
d173 145
a317 120
               if (dmtx->dmt_write)
               DEBUG_MSG("[DMT%d=%x: st.%c %x to %x as [%s] %s %s]\n",
                         x, eframe[EF_DMT0+x*3], dmtx->dmt_das ? 's' : 'u',
                         dmdx, dmax, bytes[dmtx->dmt_en], 
                         dmtx->dmt_doub1 ? "double": "not double",
                         dmtx->dmt_lockbar ? "xmem": "not xmem");
               else
               DEBUG_MSG("[DMT%d=%x: ld.%c r%d<-%x as [%s] %s %s]\n",
                         x, eframe[EF_DMT0+x*3], dmtx->dmt_das ? 's' : 'u',
                         dmtx->dmt_dreg, dmax, bytes[dmtx->dmt_en], 
                         dmtx->dmt_doub1 ? "double": "not double",
                         dmtx->dmt_lockbar ? "xmem": "not xmem");
               )

      dmax += dmt_en_info[dmtx->dmt_en].offset;
      reg = dmtx->dmt_dreg;

      if ( ! dmtx->dmt_lockbar) {
         /* the fault is not during an XMEM */

         if (x == 2 && dmtx->dmt_doub1) {
            /* pipeline 2 (earliest stage) for a double */

            if (dmtx->dmt_write) {
               /* STORE DOUBLE WILL BE RE-INITIATED BY rte */
               
            }

            else {
               /* EMULATE ld.d INSTRUCTION */
               v = do_load_word(dmax, dmtx->dmt_das);
               if (reg != 0)
                  eframe[EF_R0 + reg] = v;
               v = do_load_word(dmax ^ 4, dmtx->dmt_das);
               if (reg != 31)
                  eframe[EF_R0 + reg + 1] = v;
            }
         } else {  /* not pipeline #2 with a double */
            if (dmtx->dmt_write) {
               switch (dmt_en_info[dmtx->dmt_en].size) {
                  case DMT_BYTE:
                     DAE_DEBUG(DEBUG_MSG("[byte %x -> [%x(%c)]\n",
                                         dmdx & 0xff, dmax, dmtx->dmt_das ? 's' : 'u'))
                     do_store_byte(dmax, dmdx, dmtx->dmt_das);
                     break;
                  case DMT_HALF:
                     DAE_DEBUG(DEBUG_MSG("[half %x -> [%x(%c)]\n",
                                         dmdx & 0xffff, dmax, dmtx->dmt_das ? 's' : 'u'))
                     do_store_half(dmax, dmdx, dmtx->dmt_das);
                     break;
                  case DMT_WORD:
                     DAE_DEBUG(DEBUG_MSG("[word %x -> [%x(%c)]\n",
                                         dmdx, dmax, dmtx->dmt_das ? 's' : 'u'))
                     do_store_word(dmax, dmdx, dmtx->dmt_das);
                     break;
               } 
            } else {  /* else it's a read */
               switch (dmt_en_info[dmtx->dmt_en].size) {
                  case DMT_BYTE:
                     v = do_load_byte(dmax, dmtx->dmt_das);
                     if (!dmtx->dmt_signed)
                        v &= 0x000000ff;
                     break;
                  case DMT_HALF:
                     v = do_load_half(dmax, dmtx->dmt_das);
                     if (!dmtx->dmt_signed)
                        v &= 0x0000ffff;
                     break;
                  case DMT_WORD:
                  default: /* 'default' just to shut up lint */
                     v = do_load_word(dmax, dmtx->dmt_das);
                     break;
               }
               if (reg == 0) {
                  DAE_DEBUG(DEBUG_MSG("[no write to r0 done]\n"));
               } else {
                  DAE_DEBUG(DEBUG_MSG("[r%d <- %x]\n", reg, v));
                  eframe[EF_R0 + reg] = v;
               }
            }
         }
      } else { /* if lockbar is set... it's part of an XMEM */
         /*
          * According to Motorola's "General Information",
          * the dmt_doub1 bit is never set in this case, as it should be.
          * They call this "general information" - I call it a f*cking bug!
          *
          * Anyway, if lockbar is set (as it is if we're here) and if
          * the write is not set, then it's the same as if doub1
          * was set...
          */
         if ( ! dmtx->dmt_write) {
            if (x != 2) {
               /* RERUN xmem WITH DMD(x+1) */
               x++;
               dmdx = eframe[EF_DMD0 + x*3];
            } else {
               /* RERUN xmem WITH DMD2 */
               
            }

            if (dmt_en_info[dmtx->dmt_en].size == DMT_WORD)
               v = do_xmem_word(dmax, dmdx, dmtx->dmt_das);
            else
               v = do_xmem_byte(dmax, dmdx, dmtx->dmt_das);
            eframe[EF_R0 + reg] = v;
         } else {
            if (x == 0) {
               eframe[EF_R0 + reg] = dmdx;
               eframe[EF_SFIP] = eframe[EF_SNIP];
               eframe[EF_SNIP] = eframe[EF_SXIP];
               eframe[EF_SXIP] = 0;
               /* xmem RERUN ON rte */
               eframe[EF_DMT0] = 0;
               return;
            }
         }
      }
   }
   eframe[EF_DMT0] = 0;
d321 5
a325 6
/*
 ***********************************************************************
 ***********************************************************************
 */
#define SIGSYS_MAX      501
#define SIGTRAP_MAX     510
d327 2
a328 2
#define EMPTY_BR	0xC0000000U      /* empty "br" instruction */
#define NO_OP 		0xf4005800U      /* "or r0, r0, r0" */
d330 5
a334 1
#define BRANCH(FROM, TO) (EMPTY_BR | ((unsigned)(TO) - (unsigned)(FROM)) >> 2)
a335 4
#define SET_VECTOR(NUM, VALUE) {                                       \
	vector[NUM].word_one = NO_OP; 	                                   \
	vector[NUM].word_two = BRANCH(&vector[NUM].word_two, VALUE);    \
}
d352 2
a353 1
	for (num = 0; (vec = vector_init_list[num]) != END_OF_VECTOR_LIST; num++) {
a355 4
		__asm__ (NOP_STRING);
		__asm__ (NOP_STRING);
		__asm__ (NOP_STRING);
		__asm__ (NOP_STRING);
d427 1
a427 1
	register int i;
d532 1
@


1.32
log
@The most harmful bugs are always so blatant it takes hours to spot them...

Correctly setup the vector table for T_SIGSYS and T_SIGTRAP traps, and
handle T_SIGSYS userland traps. This passes a complete usertrap regression
test now.
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.31 2003/09/01 19:14:04 miod Exp $	*/
d449 1
a449 1
	m88k_psr_type psr; /* proccessor status register */
d473 1
a473 1
	m88k_psr_type psr; /* proccessor status register */
@


1.31
log
@Prevent userland from invoking BUG system calls, by saving the initial BUG
trap vector contents, putting the bugtrap() stub in place, and switching
back and forth between them when the kernel needs to invoke BUG functions.
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.30 2003/08/22 11:23:06 miod Exp $	*/
d344 2
a345 2
		while (num <= SIGSYS_MAX)
			SET_VECTOR(num++, m88110_sigsys);
d347 2
a348 2
		while (num <= SIGTRAP_MAX)
			SET_VECTOR(num++, m88110_sigtrap);
d358 2
a359 2
		while (num <= SIGSYS_MAX)
			SET_VECTOR(num++, sigsys);
d361 2
a362 2
		while (num <= SIGTRAP_MAX)
			SET_VECTOR(num++, sigtrap);
@


1.30
log
@To workaround an early 88100 models problem, gcc explicitely adds checks for
division by zero in the generated code, and will trap to vector #503 in this
case.

Make sure that this vector gets handled as the regular divide-by-zero vector.
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.29 2003/08/10 21:34:20 miod Exp $	*/
d41 1
d325 2
d337 4
a343 7
		while (num < 496) {
			SET_VECTOR(num, m88110_sigsys);
			num++;
		}
		num++; /* skip 496, BUG ROM vector */
		SET_VECTOR(450, m88110_syscall_handler);

d350 2
a357 8
		while (num < 496) {
			SET_VECTOR(num, sigsys);
			num++;
		}
		num++; /* skip 496, BUG ROM vector */

		SET_VECTOR(450, syscall_handler);

d364 2
d374 4
@


1.29
log
@Do not make NBPG visible in assym.h
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.28 2003/08/01 07:47:58 miod Exp $	*/
d41 1
d307 1
a307 1
#define SET_VECTOR(NUM, to, VALUE) {                                       \
d327 1
a327 1
			SET_VECTOR(num, to, vec);
d338 1
a338 1
			SET_VECTOR(num, to, m88110_sigsys);
d342 1
a342 1
		SET_VECTOR(450, to, m88110_syscall_handler);
d345 1
a345 1
			SET_VECTOR(num++, to, m88110_sigsys);
d348 1
a348 1
			SET_VECTOR(num++, to, m88110_sigtrap);
d350 2
a351 2
		SET_VECTOR(504, to, m88110_stepbpt);
		SET_VECTOR(511, to, m88110_userbpt);
d357 1
a357 1
			SET_VECTOR(num, to, sigsys);
d362 1
a362 1
		SET_VECTOR(450, to, syscall_handler);
d365 1
a365 1
			SET_VECTOR(num++, to, sigsys);
d368 1
a368 1
			SET_VECTOR(num++, to, sigtrap);
d370 2
a371 2
		SET_VECTOR(504, to, stepbpt);
		SET_VECTOR(511, to, userbpt);
d375 3
@


1.28
log
@Compensate for the assym.h lossage, which defines NBPG for now (this will be
cleaned up soon...)
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.27 2003/01/14 03:20:16 miod Exp $	*/
a29 1
#undef	NBPG	/* gasp */
@


1.27
log
@Define exception vector tables as assembly source, with the appropriate
macros, rather than include files - no need to pollute <machine/> area...
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.26 2003/01/13 20:12:18 miod Exp $	*/
d30 1
@


1.26
log
@Clean up ipl handling: be sure to always return valid levels in getipl(),
and check input level in setipl() if DIAGNOSTIC.

Doing this pointed out an horrible bug where exception frames would refer
to the saved ipl at the time the exception was processed, but would not
save it before, and the joys of stack values would make it a correct value
90% of the time. Of course, bad things could happen when restoring the
``saved'' ipl...
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.25 2002/03/14 01:26:40 millert Exp $	*/
d325 1
a325 1
		if (vec != PREDEFINED_BY_ROM)
@


1.25
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.24 2002/02/05 23:16:08 miod Exp $	*/
a34 1
#include <machine/cpu_number.h>		/* cpu_number()		*/
d104 1
a104 4
void setlevel(int);
#ifdef DDB
void db_setlevel(int);
#endif
d378 1
a378 1
unsigned int int_mask_shadow[MAX_CPUS] = {0,0,0,0};
d381 1
a381 1
unsigned int m188_curspl[MAX_CPUS] = {0,0,0,0};
d405 1
a405 1
		if (! (int_mask_val[i] & mask))
d407 1
d414 1
a414 1
setlevel(int level)
d416 3
a418 2
	register unsigned int mask;
	register int cpu = cpu_number(); 
a428 1

a438 26
#ifdef DDB
void
db_setlevel(int level)
{
	register unsigned int mask;
	register int cpu = cpu_number(); 

	mask = int_mask_val[level];

	if (cpu != master_cpu)
		mask &= SLAVE_MASK;
#if 0
	mask &= ISR_SOFTINT_EXCEPT_MASK(cpu);

	mask &= ~blocked_interrupts_mask;
#endif 

	*int_mask_reg[cpu] = mask;
#if 0
	int_mask_shadow[cpu] = mask;
#endif 

	m188_curspl[cpu] = level;
}
#endif /* DDB */

d442 1
a442 1
spl(void)
a445 31
#ifdef MVME188
	int cpu = 0;	/* prevent warning */
#endif 
	psr = disable_interrupts_return_psr();
	switch (brdtyp) {
#ifdef MVME188
	case BRD_188:
		cpu = cpu_number();
		curspl = m188_curspl[cpu];
		break;
#endif /* MVME188 */
#if defined(MVME187) || defined(MVME197)
	case BRD_187:
	case BRD_197:
		curspl = *md.intr_mask;
		break;
#endif /* defined(MVME187) || defined(MVME197) */
	}
	set_psr(psr);
	return curspl;
}

#if DDB
unsigned 
db_spl(void)
{
	unsigned curspl;
	m88k_psr_type psr; /* proccessor status register */
#ifdef MVME188
	int cpu = 0;	/* prevent warning */
#endif 
d451 1
a451 2
		cpu = cpu_number();
		curspl = m188_curspl[cpu];
d457 1
a457 1
		curspl = *md.intr_mask;
a463 15
#endif /* DDB */

unsigned 
getipl(void)
{
	return (spl());
}

#if DDB
unsigned 
db_getipl(void)
{
	return (db_spl());
}
#endif /* DDB */
d470 2
a471 3
#ifdef MVME188
	int cpu = 0;	/* prevent warning */
#endif 
d473 4
a476 1
		level = 0;	/* XXX assume this for the time being */
d478 1
d484 1
a484 2
		cpu = cpu_number();
		curspl = m188_curspl[cpu];
d491 1
a491 39
		curspl = *md.intr_mask;
		*md.intr_mask = level;
		break;
#endif /* defined(MVME187) || defined(MVME197) */
	}

	flush_pipeline();

	/* The flush pipeline is required to make sure the above write gets
	 * through the data pipe and to the hardware; otherwise, the next
	 * bunch of instructions could execute at the wrong spl protection
	 */
	set_psr(psr);
	return curspl;
}

#ifdef DDB
unsigned 
db_setipl(unsigned level)
{
	unsigned curspl;
	m88k_psr_type psr; /* proccessor status register */
#ifdef MVME188
	int cpu = 0;	/* prevent warning */
#endif 

	psr = disable_interrupts_return_psr();
	switch (brdtyp) {
#ifdef MVME188
	case BRD_188:
		cpu = cpu_number();
		curspl = m188_curspl[cpu];
		db_setlevel(level);
		break;
#endif /* MVME188 */
#if defined(MVME187) || defined(MVME197)
	case BRD_187:
	case BRD_197:
		curspl = *md.intr_mask;
a505 1
#endif /* DDB */
@


1.24
log
@Remove dead code, simplify a panic message.
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.23 2002/01/14 21:34:41 miod Exp $	*/
d105 1
a105 1
void setlevel __P((int));
d107 1
a107 1
void db_setlevel __P((int));
@


1.23
log
@volatile police.
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.22 2002/01/10 21:45:33 miod Exp $	*/
d411 1
a411 1
	printf("safe_level: no safe level for mask 0x%08x level %d found\n",
a412 1
	panic("safe_level");
a467 13
#if 0
void
block_obio_interrupt(unsigned mask)
{
	blocked_interrupts_mask |= mask;
}

void
unblock_obio_interrupt(unsigned mask)
{
	blocked_interrupts_mask |= ~mask;
}
#endif
@


1.22
log
@Replace asm statements with stuff from asm*.h, or even simple equivalent
C statements.
As a bonus this gets rid of the incorrect gcc 2.95 warnings in machdep.c
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.21 2001/12/22 19:27:48 smurph Exp $	*/
d72 1
a72 1
extern volatile unsigned int * int_mask_reg[MAX_CPUS]; /* in machdep.c */
d638 1
a638 1
	__volatile struct simplelock *lkp;
d645 1
a645 1
	__volatile int *lock;
@


1.21
log
@Label changes and comment corrections.
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.20 2001/12/22 17:57:11 smurph Exp $	*/
d331 4
a334 4
		__asm__ ("or  r0, r0, r0");
		__asm__ ("or  r0, r0, r0");
		__asm__ ("or  r0, r0, r0");
		__asm__ ("or  r0, r0, r0");
@


1.20
log
@change function names to reflect cpu type instead of board type.
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.19 2001/12/22 09:49:39 smurph Exp $	*/
d356 1
a356 1
#endif /* MVME197 */
d376 1
a376 1
#endif /* defined(MVME187) || defined(MVME188) */
@


1.19
log
@masive cmmu overhaul.  function pointers now control cmmu functionality
instead of case statements based on cpu type.
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.18 2001/12/20 06:07:28 smurph Exp $	*/
d341 1
a341 1
			SET_VECTOR(num, to, m197_sigsys);
d345 1
a345 1
		SET_VECTOR(450, to, m197_syscall_handler);
d348 1
a348 1
			SET_VECTOR(num++, to, m197_sigsys);
d351 1
a351 1
			SET_VECTOR(num++, to, m197_sigtrap);
d353 2
a354 2
		SET_VECTOR(504, to, m197_stepbpt);
		SET_VECTOR(511, to, m197_userbpt);
@


1.18
log
@machine dependant pointer changes.
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.16 2001/12/16 23:49:46 miod Exp $	*/
d37 1
a39 2
#include <machine/mmu.h>
#include <machine/cmmu.h>		/* DMT_VALID		*/
d42 1
d44 1
a44 1
#include <machine/param.h>
@


1.17
log
@Introduce brdtyp and change what cputyp means.
@
text
@d31 1
d35 2
d40 1
a40 2
#include <machine/board.h>		/* m188 bit defines	*/
#include <machine/cmmu.h>
a74 5
#if defined(MVME187) || defined(MVME197)
extern u_char *int_mask_level;
extern u_char *int_pri_level;
#endif /* defined(MVME187) || defined(MVME197) */

d503 1
a503 1
		curspl = *int_mask_level;
d532 1
a532 1
		curspl = *int_mask_level;
d579 2
a580 2
		curspl = *int_mask_level;
		*int_mask_level = level;
d617 2
a618 2
		curspl = *int_mask_level;
		*int_mask_level = level;
@


1.17.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.23 2002/01/14 21:34:41 miod Exp $	*/
a30 1
#include <sys/param.h>
a33 3
#include <machine/cpu_number.h>		/* cpu_number()		*/
#include <machine/board.h>		/* m188 bit defines	*/
#include <machine/cmmu.h>		/* DMT_VALID		*/
d36 3
a40 1
#ifdef M88100
d42 1
a42 1
#endif
d70 1
a70 1
extern unsigned int *volatile int_mask_reg[MAX_CPUS]; /* in machdep.c */
d73 5
d334 4
a337 4
		__asm__ (NOP_STRING);
		__asm__ (NOP_STRING);
		__asm__ (NOP_STRING);
		__asm__ (NOP_STRING);
d344 1
a344 1
			SET_VECTOR(num, to, m88110_sigsys);
d348 1
a348 1
		SET_VECTOR(450, to, m88110_syscall_handler);
d351 1
a351 1
			SET_VECTOR(num++, to, m88110_sigsys);
d354 1
a354 1
			SET_VECTOR(num++, to, m88110_sigtrap);
d356 2
a357 2
		SET_VECTOR(504, to, m88110_stepbpt);
		SET_VECTOR(511, to, m88110_userbpt);
d359 1
a359 1
#endif /* M88110 */
d379 1
a379 1
#endif /* M88100 */
d506 1
a506 1
		curspl = *md.intr_mask;
d535 1
a535 1
		curspl = *md.intr_mask;
d582 2
a583 2
		curspl = *md.intr_mask;
		*md.intr_mask = level;
d620 2
a621 2
		curspl = *md.intr_mask;
		*md.intr_mask = level;
d641 1
a641 1
	struct simplelock *volatile lkp;
d648 1
a648 1
	int *volatile lock;
@


1.17.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.17.2.1 2002/01/31 22:55:19 niklas Exp $	*/
d105 1
a105 1
void setlevel(int);
d107 1
a107 1
void db_setlevel(int);
d411 1
a411 1
	panic("safe_level: no safe level for mask 0x%08x level %d found",
d413 1
d469 13
@


1.17.2.3
log
@sync
@
text
@d1 1
a1 1
/* $OpenBSD$	*/
d35 1
d105 4
a108 1
void setlevel(unsigned int);
d329 1
a329 1
		if (vec != UNKNOWN_HANDLER)
d382 1
a382 1
unsigned int int_mask_shadow[MAX_CPUS] = {0, 0, 0, 0};
d385 1
a385 1
unsigned int m188_curspl[MAX_CPUS] = {0, 0, 0, 0};
d409 1
a409 1
		if (!(int_mask_val[i] & mask))
a410 1

d417 1
a417 1
setlevel(unsigned int level)
d419 2
a420 3
	unsigned int mask;
	int cpu = cpu_number(); 

d431 1
d442 26
d471 1
a471 1
getipl(void)
d475 31
d511 2
a512 1
		curspl = m188_curspl[cpu_number()];
d518 1
a518 1
		curspl = *md.intr_mask & 0x07;
d525 15
d546 3
a548 2

#ifdef DIAGNOSTIC
d550 1
a550 4
#ifdef DEBUG
		printf("setipl: invoked with invalid level %x\n", level);
#endif
		level &= 0x07;	/* and pray it will work */
a551 1
#endif
d557 2
a558 1
		curspl = m188_curspl[cpu_number()];
d565 39
a603 1
		curspl = *md.intr_mask & 0x07;
d618 1
@


1.16
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.14 2001/11/27 05:37:02 miod Exp $	*/
d65 7
a71 1
extern volatile u_char *int_mask_level;	/* machdep.c */
d73 9
d91 1
d113 1
a113 1
#if defined(MVME187) || defined(MVME188)
a154 1
#endif /* defined(MVME187) || defined(MVME188) */
d299 1
a310 7
typedef struct {
   unsigned word_one,
   word_two;
} m88k_exception_vector_area;

void vector_init __P((m88k_exception_vector_area *, unsigned *));

d341 2
a342 2
#ifdef MVME197
	case CPU_197:
d360 2
a361 3
#if defined(MVME187) || defined(MVME188)
	case CPU_187:
	case CPU_188:
d496 1
a496 1
	switch (cputyp) {
d498 1
a498 1
	case CPU_188:
d504 2
a505 2
	case CPU_187:
	case CPU_197:
d525 1
a525 1
	switch (cputyp) {
d527 1
a527 1
	case CPU_188:
d533 2
a534 2
	case CPU_187:
	case CPU_197:
d571 1
a571 1
	switch (cputyp) {
d573 1
a573 1
	case CPU_188:
d580 2
a581 2
	case CPU_187:
	case CPU_197:
d609 1
a609 1
	switch (cputyp) {
d611 1
a611 1
	case CPU_188:
d618 2
a619 2
	case CPU_187:
	case CPU_197:
@


1.15
log
@Support for MVME197 completed.  Fix SPL defs.
@
text
@a30 1
#include <sys/param.h>
a33 3
#include <machine/cpu_number.h>		/* cpu_number()		*/
#include <machine/board.h>		/* m188 bit defines	*/
#include <machine/cmmu.h>		/* DMT_VALID		*/
d38 1
d65 1
a65 10
typedef struct {
   unsigned word_one,
   word_two;
} m88k_exception_vector_area;

extern volatile unsigned int * int_mask_reg[MAX_CPUS]; /* in machdep.c */
extern unsigned master_cpu;      /* in cmmu.c */

/* FORWARDS */
void vector_init(m88k_exception_vector_area *vector, unsigned *vector_init_list);
a66 1
#ifdef M88100
a75 1
#endif 
d97 1
a97 1
#ifdef M88100
d139 1
a283 1
#endif /* M88100 */
d295 7
d332 2
a333 2
#ifdef M88110
	case CPU_88110:
d335 1
a335 1
			SET_VECTOR(num, to, m88110_sigsys);
d339 1
a339 1
		SET_VECTOR(450, to, m88110_syscall_handler);
d342 1
a342 1
			SET_VECTOR(num++, to, m88110_sigsys);
d345 1
a345 1
			SET_VECTOR(num++, to, m88110_sigtrap);
d347 2
a348 2
		SET_VECTOR(504, to, m88110_stepbpt);
		SET_VECTOR(511, to, m88110_userbpt);
d351 3
a353 2
#ifdef M88100
	case CPU_88100:
d488 1
a488 1
	switch (brdtyp) {
d490 1
a490 1
	case BRD_188:
d496 3
a498 3
	case BRD_187:
	case BRD_197:
		curspl = *md.intr_mask;
d517 3
a519 3
	switch (brdtyp) {
   #ifdef MVME188
	case BRD_188:
d523 5
a527 5
   #endif /* MVME188 */
   #if defined(MVME187) || defined(MVME197)
	case BRD_187:
	case BRD_197:
		curspl = *md.intr_mask;
d563 1
a563 1
	switch (brdtyp) {
d565 1
a565 1
	case BRD_188:
d572 4
a575 4
	case BRD_187:
	case BRD_197:
		curspl = *md.intr_mask;
		*md.intr_mask = level;
d601 1
a601 1
	switch (brdtyp) {
d603 1
a603 1
	case BRD_188:
d610 4
a613 4
	case BRD_187:
	case BRD_197:
		curspl = *md.intr_mask;
		*md.intr_mask = level;
@


1.14
log
@Adapt to include files changes.
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.13 2001/08/26 14:31:12 miod Exp $	*/
d31 1
d35 3
a41 1
#include <machine/cmmu.h>
d68 10
a77 1
extern volatile u_char *int_mask_level;	/* machdep.c */
d79 1
d89 1
d111 1
a111 1
#if defined(MVME187) || defined(MVME188)
a152 1
#endif /* defined(MVME187) || defined(MVME188) */
d297 1
a308 7
typedef struct {
   unsigned word_one,
   word_two;
} m88k_exception_vector_area;

void vector_init __P((m88k_exception_vector_area *, unsigned *));

d339 2
a340 2
#ifdef MVME197
	case CPU_197:
d342 1
a342 1
			SET_VECTOR(num, to, m197_sigsys);
d346 1
a346 1
		SET_VECTOR(450, to, m197_syscall_handler);
d349 1
a349 1
			SET_VECTOR(num++, to, m197_sigsys);
d352 1
a352 1
			SET_VECTOR(num++, to, m197_sigtrap);
d354 2
a355 2
		SET_VECTOR(504, to, m197_stepbpt);
		SET_VECTOR(511, to, m197_userbpt);
d358 2
a359 3
#if defined(MVME187) || defined(MVME188)
	case CPU_187:
	case CPU_188:
d494 1
a494 1
	switch (cputyp) {
d496 1
a496 1
	case CPU_188:
d502 3
a504 3
	case CPU_187:
	case CPU_197:
		curspl = *int_mask_level;
d523 3
a525 3
	switch (cputyp) {
#ifdef MVME188
	case CPU_188:
d529 5
a533 5
#endif /* MVME188 */
#if defined(MVME187) || defined(MVME197)
	case CPU_187:
	case CPU_197:
		curspl = *int_mask_level;
d569 1
a569 1
	switch (cputyp) {
d571 1
a571 1
	case CPU_188:
d578 4
a581 4
	case CPU_187:
	case CPU_197:
		curspl = *int_mask_level;
		*int_mask_level = level;
d607 1
a607 1
	switch (cputyp) {
d609 1
a609 1
	case CPU_188:
d616 4
a619 4
	case CPU_187:
	case CPU_197:
		curspl = *int_mask_level;
		*int_mask_level = level;
@


1.13
log
@Add prototypes, fix compilation warnings, random style fixes.
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.12 2001/08/07 22:18:07 miod Exp $	*/
d36 1
@


1.12
log
@Sprinkle a few Holy Volatiles (tm).
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.11 2001/05/20 05:53:10 miod Exp $	*/
a27 4
/*
 * HISTORY
 *****************************************************************RCS**/
/* This file created by Omron Corporation, 1990. */
a33 4
#include <machine/param.h>
#include <machine/cpu_number.h>		/* cpu_number()		*/
#include <machine/board.h>		/* m188 bit defines	*/
#include <machine/m88100.h>		/* DMT_VALID		*/
d36 3
d40 3
d44 1
a44 1
   #include <ddb/db_output.h>		/* db_printf()		*/
a46 1

d48 1
a48 1
   #define DATA_DEBUG  1
a50 1

d52 1
a52 1
   #define DEBUG_MSG db_printf
d54 1
a54 1
   #define DEBUG_MSG printf
d64 1
a64 3
extern volatile unsigned int * int_mask_reg[MAX_CPUS]; /* in machdep.c */
extern volatile u_char *int_mask_level;   /* in machdep.c */
extern unsigned master_cpu;      /* in cmmu.c */
d69 1
a69 2
} dmt_en_info[16] =
{
d76 1
a76 1
#if DATA_DEBUG
d85 1
a85 1
   #define DAE_DEBUG(stuff) {						\
d88 6
a93 1
   #define DAE_DEBUG(stuff)
d138 1
d140 2
a141 1
void data_access_emulation(unsigned *eframe)
a282 1
#endif /* defined(MVME187) || defined(MVME188) */
d299 2
d303 1
a303 9
#if 0
   #define SET_VECTOR(NUM, to, VALUE) {                                       \
	unsigned _NUM = (unsigned)(NUM);                                   \
	unsigned _VALUE = (unsigned)(VALUE);                               \
	vector[_NUM].word_one = NO_OP; 	                                   \
	vector[_NUM].word_two = BRANCH(&vector[_NUM].word_two, _VALUE);    \
}
#else
   #define SET_VECTOR(NUM, to, VALUE) {                                       \
a306 1
#endif 
a319 8
#if defined(MVME187) || defined(MVME188)
	extern void sigsys(), sigtrap(), stepbpt(), userbpt();
	extern void syscall_handler();
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
	extern void m197_sigsys(), m197_sigtrap(), m197_stepbpt(), m197_userbpt();
	extern void m197_syscall_handler();
#endif /* MVME197 */
d324 4
a327 4
		asm ("or  r0, r0, r0");
		asm ("or  r0, r0, r0");
		asm ("or  r0, r0, r0");
		asm ("or  r0, r0, r0");
d375 1
d377 2
a379 1
unsigned int blocked_interrupts_mask;
d408 1
d463 1
d475 1
d484 1
a484 1
	int cpu = 0;
a499 2
	default:
		panic("spl: Can't determine cpu type!");
d512 1
a512 1
	int cpu = 0;
d517 1
a517 1
   #ifdef MVME188
d522 2
a523 2
   #endif /* MVME188 */
   #if defined(MVME187) || defined(MVME197)
d528 1
a528 3
   #endif /* defined(MVME187) || defined(MVME197) */
	default:
		panic("db_spl: Can't determine cpu type!");
d555 1
a555 1
	int cpu = 0;
d558 1
a558 1
		level = 0;	/* assume this for the time being */
a576 2
	default:
		panic("setipl: Can't determine cpu type!");
d596 1
a596 1
	int cpu = 0;
a614 2
	default:
		panic("db_setipl: Can't determine cpu type!");
a653 1

@


1.11
log
@assym.s -> assym.h
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.10 2001/03/09 05:44:41 smurph Exp $	*/
d69 1
a69 1
extern u_char *int_mask_level;   /* in machdep.c */
@


1.10
log
@kernel will compile with -Werror.  Added intr.h
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.9 2001/03/08 00:03:31 miod Exp $	*/
d33 2
a41 1
#include <assym.s>			/* EF_NREGS, etc.	*/
@


1.9
log
@Some warning hunting.
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.8 2001/02/01 03:38:20 smurph Exp $	*/
d410 2
a411 2
unsigned mask;
unsigned curlevel;
d493 1
d495 1
a495 1

d523 1
d525 1
d568 1
d570 1
d611 1
d613 1
d650 1
a650 1
__volatile struct simplelock *lkp;
d657 1
a657 1
__volatile int *lock;
@


1.8
log
@Major changes to get MVME188 working.  More header and code cleanups.  The
kernel is tested on MVME188A/2P256 and MVME188A/1P64.
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.7 2001/01/14 20:25:25 smurph Exp $	*/
d33 4
d43 1
a103 1
	register unsigned  v, reg;
a425 1
	m88k_psr_type psr;
a452 1
	m88k_psr_type psr;
@


1.7
log
@Complete move to UVM virtual memory system.  More header fixes.
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.6 1999/09/27 19:13:22 smurph Exp $	*/
d33 6
a38 6
#include <machine/cpu_number.h> 		/* cpu_number() */
#include <machine/board.h>          /* m188 bit defines */
#include <machine/m88100.h> 		/* DMT_VALID		*/
#include <assym.s>			 /* EF_NREGS, etc.	*/
#include <machine/asm.h>		 /* END_OF_VECTOR_LIST, etc. */
#include <machine/asm_macro.h>   /* enable/disable interrupts */
d40 1
a40 1
   #include <ddb/db_output.h>		 /* db_printf() 	*/
d67 2
a68 2
   unsigned char    offset;
   unsigned char    size;
d71 4
a74 4
   {0, 0}, {3, DMT_BYTE}, {2, DMT_BYTE}, {2, DMT_HALF},
   {1, DMT_BYTE}, {0, 0}, {0, 0}, {0, 0},
   {0, DMT_BYTE}, {0, 0}, {0, 0}, {0, 0},
   {0, DMT_HALF}, {0, 0}, {0, 0}, {0, DMT_WORD}
d92 1
d96 36
a131 11
   register int x;
   register struct dmt_reg *dmtx;
   register unsigned  dmax, dmdx;
   register unsigned  v, reg;
   static char *bytes[] =
   {
      "____", "___x", "__x_", "__xx",
      "_x__", "_x_x", "_xx_", "_xxx",
      "x___", "x__x", "x_x_", "x_xx",
      "xx__", "xx_x", "xxx_", "xxxx",
   };
d133 2
a134 24
   if (!(eframe[EF_DMT0] & DMT_VALID))
      return;

   for (x = 0; x < 3; x++) {
      dmtx = (struct dmt_reg *)&eframe[EF_DMT0+x*3];

      if (!dmtx->dmt_valid)
         continue;

      dmdx = eframe[EF_DMD0+x*3];
      dmax = eframe[EF_DMA0+x*3];

      if (dmtx->dmt_write)
         printf("[DMT%d=%x: st.%c %x to %x as [%s] %s %s]\n",
                x, eframe[EF_DMT0+x*3], dmtx->dmt_das ? 's' : 'u',
                dmdx, dmax, bytes[dmtx->dmt_en], 
                dmtx->dmt_doub1 ? "double": "not double",
                dmtx->dmt_lockbar ? "xmem": "not xmem");
      else
         printf("[DMT%d=%x: ld.%c r%d <- %x as [%s] %s %s]\n",
                x, eframe[EF_DMT0+x*3], dmtx->dmt_das ? 's' : 'u',
                dmtx->dmt_dreg, dmax, bytes[dmtx->dmt_en], 
                dmtx->dmt_doub1 ? "double": "not double",
                dmtx->dmt_lockbar ? "xmem": "not xmem");
a135 3
   }
}
#if defined(MVME187) || defined(MVME188)
d143 2
a144 1
   if (!(eframe[EF_DMT0] & DMT_VALID))
d146 1
a146 1

d150 1
a150 1
      if (!dmtx->dmt_valid)
d318 2
a319 3
void vector_init(
                m88k_exception_vector_area *vector,
                unsigned *vector_init_list)
d321 2
a322 2
   unsigned num;
   unsigned vec;
d324 2
a325 2
   extern void sigsys(), sigtrap(), stepbpt(), userbpt();
   extern void syscall_handler();
d328 2
a329 2
   extern void m197_sigsys(), m197_sigtrap(), m197_stepbpt(), m197_userbpt();
   extern void m197_syscall_handler();
a330 9
   
   for (num = 0; (vec = vector_init_list[num]) != END_OF_VECTOR_LIST; num++) {
      if (vec != PREDEFINED_BY_ROM)
         SET_VECTOR(num, to, vec);
         asm ("or  r0, r0, r0");
         asm ("or  r0, r0, r0");
         asm ("or  r0, r0, r0");
         asm ("or  r0, r0, r0");
   }
d332 10
a341 1
   switch (cputyp) {
d343 17
a359 17
   case CPU_197:
      while (num < 496){
         SET_VECTOR(num, to, m197_sigsys);
         num++;
      }
      num++; /* skip 496, BUG ROM vector */
      SET_VECTOR(450, to, m197_syscall_handler);
   
      while (num <= SIGSYS_MAX)
         SET_VECTOR(num++, to, m197_sigsys);
   
      while (num <= SIGTRAP_MAX)
         SET_VECTOR(num++, to, m197_sigtrap);
   
      SET_VECTOR(504, to, m197_stepbpt);
      SET_VECTOR(511, to, m197_userbpt);
      break;
d362 19
a380 19
   case CPU_187:
   case CPU_188:
      while (num < 496){
         SET_VECTOR(num, to, sigsys);
         num++;
      }
      num++; /* skip 496, BUG ROM vector */
   
      SET_VECTOR(450, to, syscall_handler);

      while (num <= SIGSYS_MAX)
         SET_VECTOR(num++, to, sigsys);

      while (num <= SIGTRAP_MAX)
         SET_VECTOR(num++, to, sigtrap);

      SET_VECTOR(504, to, stepbpt);
      SET_VECTOR(511, to, userbpt);
      break;
d382 1
a382 1
   }
d391 8
a398 8
   MASK_LVL_0, 
   MASK_LVL_1, 
   MASK_LVL_2, 
   MASK_LVL_3, 
   MASK_LVL_4, 
   MASK_LVL_5, 
   MASK_LVL_6, 
   MASK_LVL_7
a400 1

d409 1
a409 1
   register int i;
d411 6
a416 6
   for (i = curlevel; i < 8; i++)
      if (! (int_mask_val[i] & mask))
         return i;
   printf("safe_level: no safe level for mask 0x%08x level %d found\n",
          mask, curlevel);
   panic("safe_level");
d422 7
a428 3
   m88k_psr_type psr;
   register unsigned int mask;
   register int cpu = cpu_number(); 
d430 2
a431 1
   mask = int_mask_val[level];
d433 2
a434 2
   if (cpu != master_cpu)
      mask &= SLAVE_MASK;
d436 2
a437 1
   mask &= ISR_SOFTINT_EXCEPT_MASK(cpu);
d439 5
a443 6
   mask &= ~blocked_interrupts_mask;

   *int_mask_reg[cpu] = mask;
   int_mask_shadow[cpu] = mask;

   m188_curspl[cpu] = level;
d450 3
a452 3
   m88k_psr_type psr;
   register unsigned int mask;
   register int cpu = cpu_number(); 
d454 1
a454 1
   mask = int_mask_val[level];
d456 4
a459 2
   if (cpu != master_cpu)
      mask &= SLAVE_MASK;
d461 2
a462 1
   mask &= ISR_SOFTINT_EXCEPT_MASK(cpu);
d464 4
a467 1
   mask &= ~blocked_interrupts_mask;
d469 1
a469 4
   *int_mask_reg[cpu] = mask;
   int_mask_shadow[cpu] = mask;

   m188_curspl[cpu] = level;
d473 2
a474 1
void block_obio_interrupt(unsigned mask)
d476 1
a476 1
   blocked_interrupts_mask |= mask;
d479 2
a480 1
void unblock_obio_interrupt(unsigned mask)
d482 1
a482 1
   blocked_interrupts_mask |= ~mask;
d486 2
a487 1
unsigned spl(void)
d489 3
a491 3
   unsigned curspl;
   m88k_psr_type psr; /* proccessor status register */
   int cpu = 0;
d493 2
a494 2
   psr = disable_interrupts_return_psr();
   switch (cputyp) {
d496 4
a499 4
      case CPU_188:
         cpu = cpu_number();
         curspl = m188_curspl[cpu];
         break;
d502 4
a505 4
      case CPU_187:
      case CPU_197:
         curspl = *int_mask_level;
         break;
d507 5
a511 5
      default:
         panic("spl: Can't determine cpu type!");
   }
   set_psr(psr);
   return curspl;
d515 2
a516 1
unsigned db_spl(void)
d518 3
a520 3
   unsigned curspl;
   m88k_psr_type psr; /* proccessor status register */
   int cpu = 0;
d522 2
a523 2
   psr = disable_interrupts_return_psr();
   switch (cputyp) {
d525 4
a528 4
      case CPU_188:
         cpu = cpu_number();
         curspl = m188_curspl[cpu];
         break;
d531 4
a534 4
      case CPU_187:
      case CPU_197:
         curspl = *int_mask_level;
         break;
d536 5
a540 5
      default:
         panic("db_spl: Can't determine cpu type!");
   }
   set_psr(psr);
   return curspl;
d544 2
a545 1
unsigned getipl(void)
d547 1
a547 1
   return (spl());
d551 2
a552 1
unsigned db_getipl(void)
d554 1
a554 1
   return (db_spl());
d558 2
a559 1
unsigned setipl(unsigned level)
d561 6
a566 3
   unsigned curspl;
   m88k_psr_type psr; /* proccessor status register */
   int cpu = 0;
d568 2
a569 2
   psr = disable_interrupts_return_psr();
   switch (cputyp) {
d571 5
a575 5
      case CPU_188:
         cpu = cpu_number();
         curspl = m188_curspl[cpu];
         setlevel(level);
         break;
d578 5
a582 5
      case CPU_187:
      case CPU_197:
         curspl = *int_mask_level;
         *int_mask_level = level;
         break;
d584 12
a595 12
      default:
         panic("setipl: Can't determine cpu type!");
   }

   flush_pipeline();

   /* The flush pipeline is required to make sure the above write gets
    * through the data pipe and to the hardware; otherwise, the next
    * bunch of instructions could execute at the wrong spl protection
    */
   set_psr(psr);
   return curspl;
d599 2
a600 1
unsigned db_setipl(unsigned level)
d602 3
a604 3
   unsigned curspl;
   m88k_psr_type psr; /* proccessor status register */
   int cpu = 0;
d606 2
a607 2
   psr = disable_interrupts_return_psr();
   switch (cputyp) {
d609 5
a613 5
      case CPU_188:
         cpu = cpu_number();
         curspl = m188_curspl[cpu];
         db_setlevel(level);
         break;
d616 5
a620 5
      case CPU_187:
      case CPU_197:
         curspl = *int_mask_level;
         *int_mask_level = level;
         break;
d622 12
a633 12
      default:
         panic("db_setipl: Can't determine cpu type!");
   }

   flush_pipeline();

   /* The flush pipeline is required to make sure the above write gets
    * through the data pipe and to the hardware; otherwise, the next
    * bunch of instructions could execute at the wrong spl protection
    */
   set_psr(psr);
   return curspl;
d638 1
a638 1
   #include <sys/simplelock.h>
d643 1
a643 1
   lkp->lock_data = 0;
d646 2
a647 1
int test_and_set(lock)
d650 11
a660 10
/*
   int oldlock = *lock;
   if (*lock == 0) {
      *lock = 1;
      return 0;
   }
*/
   return *lock;
   *lock = 1;
   return 0;
d663 1
@


1.6
log
@Added to support MVME188 and MVME197
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.5 1999/02/09 06:36:28 smurph Exp $	*/
d424 1
a424 1
   register int cpu = 0; /* cpu_number(); */
d447 1
a447 1
   register int cpu = 0; /* cpu_number(); */
d486 1
a486 1
         /*cpu = cpu_number();*/
d514 1
a514 1
         /*cpu = cpu_number();*/
d554 1
a554 1
         /*cpu = cpu_number();*/
d591 1
a591 1
         /*cpu = cpu_number();*/
a641 2


@


1.6.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.10 2001/03/09 05:44:41 smurph Exp $	*/
d33 6
a38 11
#include <sys/types.h>
#include <sys/systm.h>

#include <machine/param.h>
#include <machine/cpu_number.h>		/* cpu_number()		*/
#include <machine/board.h>		/* m188 bit defines	*/
#include <machine/m88100.h>		/* DMT_VALID		*/
#include <assym.s>			/* EF_NREGS, etc.	*/
#include <machine/asm.h>		/* END_OF_VECTOR_LIST, etc.	*/
#include <machine/asm_macro.h>		/* enable/disable interrupts	*/
#include <machine/locore.h>
d40 1
a40 1
   #include <ddb/db_output.h>		/* db_printf()		*/
d67 2
a68 2
	unsigned char    offset;
	unsigned char    size;
d71 4
a74 4
	{0, 0}, {3, DMT_BYTE}, {2, DMT_BYTE}, {2, DMT_HALF},
	{1, DMT_BYTE}, {0, 0}, {0, 0}, {0, 0},
	{0, DMT_BYTE}, {0, 0}, {0, 0}, {0, 0},
	{0, DMT_HALF}, {0, 0}, {0, 0}, {0, DMT_WORD}
a91 1
#if defined(MVME187) || defined(MVME188)
d95 14
a108 35
	register int x;
	register struct dmt_reg *dmtx;
	register unsigned  dmax, dmdx;
	static char *bytes[] =
	{
		"____", "___x", "__x_", "__xx",
		"_x__", "_x_x", "_xx_", "_xxx",
		"x___", "x__x", "x_x_", "x_xx",
		"xx__", "xx_x", "xxx_", "xxxx",
	};

	if (!(eframe[EF_DMT0] & DMT_VALID))
		return;

	for (x = 0; x < 3; x++) {
		dmtx = (struct dmt_reg *)&eframe[EF_DMT0+x*3];

		if (!dmtx->dmt_valid)
			continue;

		dmdx = eframe[EF_DMD0+x*3];
		dmax = eframe[EF_DMA0+x*3];

		if (dmtx->dmt_write)
			printf("[DMT%d=%x: st.%c %x to %x as [%s] %s %s]\n",
			       x, eframe[EF_DMT0+x*3], dmtx->dmt_das ? 's' : 'u',
			       dmdx, dmax, bytes[dmtx->dmt_en], 
			       dmtx->dmt_doub1 ? "double": "not double",
			       dmtx->dmt_lockbar ? "xmem": "not xmem");
		else
			printf("[DMT%d=%x: ld.%c r%d <- %x as [%s] %s %s]\n",
			       x, eframe[EF_DMT0+x*3], dmtx->dmt_das ? 's' : 'u',
			       dmtx->dmt_dreg, dmax, bytes[dmtx->dmt_en], 
			       dmtx->dmt_doub1 ? "double": "not double",
			       dmtx->dmt_lockbar ? "xmem": "not xmem");
d110 23
a132 1
	}
d134 1
a134 1

d142 1
a142 2
   dmtx = (struct dmt_reg *)&eframe[EF_DMT0];
   if (!dmtx->dmt_valid && !dmtx->dmt_skip)
d144 1
a144 1
   
d148 1
a148 1
      if (!dmtx->dmt_valid || dmtx->dmt_skip)	
d316 3
a318 2
void 
vector_init(m88k_exception_vector_area *vector, unsigned *vector_init_list)
d320 2
a321 2
	unsigned num;
	unsigned vec;
d323 2
a324 2
	extern void sigsys(), sigtrap(), stepbpt(), userbpt();
	extern void syscall_handler();
d327 2
a328 2
	extern void m197_sigsys(), m197_sigtrap(), m197_stepbpt(), m197_userbpt();
	extern void m197_syscall_handler();
d330 9
d340 1
a340 10
	for (num = 0; (vec = vector_init_list[num]) != END_OF_VECTOR_LIST; num++) {
		if (vec != PREDEFINED_BY_ROM)
			SET_VECTOR(num, to, vec);
		asm ("or  r0, r0, r0");
		asm ("or  r0, r0, r0");
		asm ("or  r0, r0, r0");
		asm ("or  r0, r0, r0");
	}

	switch (cputyp) {
d342 17
a358 17
	case CPU_197:
		while (num < 496) {
			SET_VECTOR(num, to, m197_sigsys);
			num++;
		}
		num++; /* skip 496, BUG ROM vector */
		SET_VECTOR(450, to, m197_syscall_handler);

		while (num <= SIGSYS_MAX)
			SET_VECTOR(num++, to, m197_sigsys);

		while (num <= SIGTRAP_MAX)
			SET_VECTOR(num++, to, m197_sigtrap);

		SET_VECTOR(504, to, m197_stepbpt);
		SET_VECTOR(511, to, m197_userbpt);
		break;
d361 19
a379 19
	case CPU_187:
	case CPU_188:
		while (num < 496) {
			SET_VECTOR(num, to, sigsys);
			num++;
		}
		num++; /* skip 496, BUG ROM vector */

		SET_VECTOR(450, to, syscall_handler);

		while (num <= SIGSYS_MAX)
			SET_VECTOR(num++, to, sigsys);

		while (num <= SIGTRAP_MAX)
			SET_VECTOR(num++, to, sigtrap);

		SET_VECTOR(504, to, stepbpt);
		SET_VECTOR(511, to, userbpt);
		break;
d381 1
a381 1
	}
d390 8
a397 8
	MASK_LVL_0, 
	MASK_LVL_1, 
	MASK_LVL_2, 
	MASK_LVL_3, 
	MASK_LVL_4, 
	MASK_LVL_5, 
	MASK_LVL_6, 
	MASK_LVL_7
d400 1
d406 2
a407 2
	unsigned mask;
	unsigned curlevel;
d409 1
a409 1
	register int i;
d411 6
a416 6
	for (i = curlevel; i < 8; i++)
		if (! (int_mask_val[i] & mask))
			return i;
	printf("safe_level: no safe level for mask 0x%08x level %d found\n",
	       mask, curlevel);
	panic("safe_level");
d422 3
a424 6
	register unsigned int mask;
	register int cpu = cpu_number(); 
	if (level > 7) {
		panic("setlevel: bad level 0x%x", level);
	}
	mask = int_mask_val[level];
d426 1
a426 2
	if (cpu != master_cpu)
		mask &= SLAVE_MASK;
d428 6
a433 2
#if 0
	mask &= ISR_SOFTINT_EXCEPT_MASK(cpu);
d435 2
a436 2
	mask &= ~blocked_interrupts_mask;
#endif 
d438 1
a438 5
	*int_mask_reg[cpu] = mask;
#if 0
	int_mask_shadow[cpu] = mask;
#endif 
	m188_curspl[cpu] = level;
d445 5
a449 2
	register unsigned int mask;
	register int cpu = cpu_number(); 
d451 2
a452 1
	mask = int_mask_val[level];
d454 1
a454 4
	if (cpu != master_cpu)
		mask &= SLAVE_MASK;
#if 0
	mask &= ISR_SOFTINT_EXCEPT_MASK(cpu);
d456 1
a456 2
	mask &= ~blocked_interrupts_mask;
#endif 
d458 2
a459 4
	*int_mask_reg[cpu] = mask;
#if 0
	int_mask_shadow[cpu] = mask;
#endif 
d461 1
a461 1
	m188_curspl[cpu] = level;
d465 1
a465 2
void
block_obio_interrupt(unsigned mask)
d467 1
a467 1
	blocked_interrupts_mask |= mask;
d470 1
a470 2
void
unblock_obio_interrupt(unsigned mask)
d472 1
a472 1
	blocked_interrupts_mask |= ~mask;
d476 1
a476 2
unsigned 
spl(void)
d478 6
a483 2
	unsigned curspl;
	m88k_psr_type psr; /* proccessor status register */
d485 4
a488 9
	int cpu = 0;
#endif 
	psr = disable_interrupts_return_psr();
	switch (cputyp) {
#ifdef MVME188
	case CPU_188:
		cpu = cpu_number();
		curspl = m188_curspl[cpu];
		break;
d491 4
a494 4
	case CPU_187:
	case CPU_197:
		curspl = *int_mask_level;
		break;
d496 5
a500 5
	default:
		panic("spl: Can't determine cpu type!");
	}
	set_psr(psr);
	return curspl;
d504 1
a504 2
unsigned 
db_spl(void)
d506 3
a508 5
	unsigned curspl;
	m88k_psr_type psr; /* proccessor status register */
#ifdef MVME188
	int cpu = 0;
#endif 
d510 2
a511 2
	psr = disable_interrupts_return_psr();
	switch (cputyp) {
d513 4
a516 4
	case CPU_188:
		cpu = cpu_number();
		curspl = m188_curspl[cpu];
		break;
d519 4
a522 4
	case CPU_187:
	case CPU_197:
		curspl = *int_mask_level;
		break;
d524 5
a528 5
	default:
		panic("db_spl: Can't determine cpu type!");
	}
	set_psr(psr);
	return curspl;
d532 1
a532 2
unsigned 
getipl(void)
d534 1
a534 1
	return (spl());
d538 1
a538 2
unsigned 
db_getipl(void)
d540 1
a540 1
	return (db_spl());
d544 1
a544 2
unsigned 
setipl(unsigned level)
d546 3
a548 8
	unsigned curspl;
	m88k_psr_type psr; /* proccessor status register */
#ifdef MVME188
	int cpu = 0;
#endif 
	if (level > 7) {
		level = 0;	/* assume this for the time being */
	}
d550 2
a551 2
	psr = disable_interrupts_return_psr();
	switch (cputyp) {
d553 5
a557 5
	case CPU_188:
		cpu = cpu_number();
		curspl = m188_curspl[cpu];
		setlevel(level);
		break;
d560 5
a564 5
	case CPU_187:
	case CPU_197:
		curspl = *int_mask_level;
		*int_mask_level = level;
		break;
d566 12
a577 12
	default:
		panic("setipl: Can't determine cpu type!");
	}

	flush_pipeline();

	/* The flush pipeline is required to make sure the above write gets
	 * through the data pipe and to the hardware; otherwise, the next
	 * bunch of instructions could execute at the wrong spl protection
	 */
	set_psr(psr);
	return curspl;
d581 1
a581 2
unsigned 
db_setipl(unsigned level)
d583 3
a585 5
	unsigned curspl;
	m88k_psr_type psr; /* proccessor status register */
#ifdef MVME188
	int cpu = 0;
#endif 
d587 2
a588 2
	psr = disable_interrupts_return_psr();
	switch (cputyp) {
d590 5
a594 5
	case CPU_188:
		cpu = cpu_number();
		curspl = m188_curspl[cpu];
		db_setlevel(level);
		break;
d597 5
a601 5
	case CPU_187:
	case CPU_197:
		curspl = *int_mask_level;
		*int_mask_level = level;
		break;
d603 12
a614 12
	default:
		panic("db_setipl: Can't determine cpu type!");
	}

	flush_pipeline();

	/* The flush pipeline is required to make sure the above write gets
	 * through the data pipe and to the hardware; otherwise, the next
	 * bunch of instructions could execute at the wrong spl protection
	 */
	set_psr(psr);
	return curspl;
d619 1
a619 1
#include <sys/simplelock.h>
d622 1
a622 1
	__volatile struct simplelock *lkp;
d624 1
a624 1
	lkp->lock_data = 0;
d627 2
a628 3
int 
test_and_set(lock)
	__volatile int *lock;
d630 10
a639 11
#if 0
	int oldlock = *lock;
	if (*lock == 0) {
		*lock = 1;
		return 0;
	}
#else
	return *lock;
	*lock = 1;
	return 0;
#endif 
d642 1
@


1.6.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.6.4.1 2001/04/18 16:11:34 niklas Exp $	*/
a32 2
#include "assym.h"

d40 1
@


1.6.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.6.4.2 2001/07/04 10:20:14 niklas Exp $	*/
d28 4
d38 4
a43 3
#include <machine/board.h>		/* m188 bit defines	*/
#include <machine/cmmu.h>
#include <machine/cpu_number.h>		/* cpu_number()		*/
a44 3
#include <machine/m88100.h>		/* DMT_VALID		*/
#include <machine/param.h>

d46 1
a46 1
#include <ddb/db_output.h>		/* db_printf()		*/
d49 1
d51 1
a51 1
#define DATA_DEBUG
d54 1
d56 1
a56 1
#define DEBUG_MSG db_printf
d58 1
a58 1
#define DEBUG_MSG printf
d68 3
a70 1
extern volatile u_char *int_mask_level;	/* machdep.c */
d75 2
a76 1
} dmt_en_info[16] = {
d83 1
a83 1
#ifdef DATA_DEBUG
d92 1
a92 1
#define DAE_DEBUG(stuff) {						\
d95 1
a95 6
#define DAE_DEBUG(stuff)
#endif

void setlevel __P((int));
#ifdef DDB
void db_setlevel __P((int));
a139 1
#endif /* defined(MVME187) || defined(MVME188) */
d141 1
a141 2
void
data_access_emulation(unsigned *eframe)
d283 1
a299 2
void vector_init __P((m88k_exception_vector_area *, unsigned *));

d302 9
a310 1
#define SET_VECTOR(NUM, to, VALUE) {                                       \
d314 1
d328 8
d340 4
a343 4
		__asm__ ("or  r0, r0, r0");
		__asm__ ("or  r0, r0, r0");
		__asm__ ("or  r0, r0, r0");
		__asm__ ("or  r0, r0, r0");
a390 1
#if 0
d392 1
a393 2
#endif
unsigned int m188_curspl[MAX_CPUS] = {0,0,0,0};
a421 1
	/* NOTREACHED */
a475 1
#if 0
a486 1
#endif
d495 1
a495 1
	int cpu = 0;	/* prevent warning */
d511 2
d525 1
a525 1
	int cpu = 0;	/* prevent warning */
d530 1
a530 1
#ifdef MVME188
d535 2
a536 2
#endif /* MVME188 */
#if defined(MVME187) || defined(MVME197)
d541 3
a543 1
#endif /* defined(MVME187) || defined(MVME197) */
d570 1
a570 1
	int cpu = 0;	/* prevent warning */
d573 1
a573 1
		level = 0;	/* XXX assume this for the time being */
d592 2
d613 1
a613 1
	int cpu = 0;	/* prevent warning */
d632 2
d673 1
@


1.6.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.6.4.3 2001/10/31 03:01:19 nate Exp $	*/
a35 1
#include <machine/mmu.h>
@


1.6.4.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/* $OpenBSD$	*/
a30 1
#include <sys/param.h>
a33 3
#include <machine/cpu_number.h>		/* cpu_number()		*/
#include <machine/board.h>		/* m188 bit defines	*/
#include <machine/cmmu.h>		/* DMT_VALID		*/
d36 3
a40 1
#ifdef M88100
d42 1
a42 1
#endif
d65 1
a65 4
typedef struct {
   unsigned word_one,
   word_two;
} m88k_exception_vector_area;
a66 7
extern unsigned int *volatile int_mask_reg[MAX_CPUS]; /* in machdep.c */
extern unsigned master_cpu;      /* in cmmu.c */

/* FORWARDS */
void vector_init(m88k_exception_vector_area *vector, unsigned *vector_init_list);

#ifdef M88100
a75 1
#endif 
d97 1
a97 1
#ifdef M88100
d139 1
a283 1
#endif /* M88100 */
d295 7
d325 4
a328 4
		__asm__ (NOP_STRING);
		__asm__ (NOP_STRING);
		__asm__ (NOP_STRING);
		__asm__ (NOP_STRING);
d332 2
a333 2
#ifdef M88110
	case CPU_88110:
d335 1
a335 1
			SET_VECTOR(num, to, m88110_sigsys);
d339 1
a339 1
		SET_VECTOR(450, to, m88110_syscall_handler);
d342 1
a342 1
			SET_VECTOR(num++, to, m88110_sigsys);
d345 1
a345 1
			SET_VECTOR(num++, to, m88110_sigtrap);
d347 2
a348 2
		SET_VECTOR(504, to, m88110_stepbpt);
		SET_VECTOR(511, to, m88110_userbpt);
d350 4
a353 3
#endif /* M88110 */
#ifdef M88100
	case CPU_88100:
d371 1
a371 1
#endif /* M88100 */
d406 1
a406 1
	panic("safe_level: no safe level for mask 0x%08x level %d found",
d408 1
d464 13
d488 1
a488 1
	switch (brdtyp) {
d490 1
a490 1
	case BRD_188:
d496 3
a498 3
	case BRD_187:
	case BRD_197:
		curspl = *md.intr_mask;
d517 1
a517 1
	switch (brdtyp) {
d519 1
a519 1
	case BRD_188:
d525 3
a527 3
	case BRD_187:
	case BRD_197:
		curspl = *md.intr_mask;
d563 1
a563 1
	switch (brdtyp) {
d565 1
a565 1
	case BRD_188:
d572 4
a575 4
	case BRD_187:
	case BRD_197:
		curspl = *md.intr_mask;
		*md.intr_mask = level;
d601 1
a601 1
	switch (brdtyp) {
d603 1
a603 1
	case BRD_188:
d610 4
a613 4
	case BRD_187:
	case BRD_197:
		curspl = *md.intr_mask;
		*md.intr_mask = level;
d633 1
a633 1
	struct simplelock *volatile lkp;
d640 1
a640 1
	int *volatile lock;
@


1.6.4.6
log
@Merge in -current from about a week ago
@
text
@d105 1
a105 1
void setlevel(int);
d107 1
a107 1
void db_setlevel(int);
@


1.6.4.7
log
@Sync the SMP branch with 3.3
@
text
@d35 1
d105 4
a108 1
void setlevel(unsigned int);
d329 1
a329 1
		if (vec != UNKNOWN_HANDLER)
d382 1
a382 1
unsigned int int_mask_shadow[MAX_CPUS] = {0, 0, 0, 0};
d385 1
a385 1
unsigned int m188_curspl[MAX_CPUS] = {0, 0, 0, 0};
d409 1
a409 1
		if (!(int_mask_val[i] & mask))
a410 1

d417 1
a417 1
setlevel(unsigned int level)
d419 2
a420 3
	unsigned int mask;
	int cpu = cpu_number(); 

d431 1
d442 26
d471 1
a471 1
getipl(void)
d475 31
d511 2
a512 1
		curspl = m188_curspl[cpu_number()];
d518 1
a518 1
		curspl = *md.intr_mask & 0x07;
d525 15
d546 3
a548 2

#ifdef DIAGNOSTIC
d550 1
a550 4
#ifdef DEBUG
		printf("setipl: invoked with invalid level %x\n", level);
#endif
		level &= 0x07;	/* and pray it will work */
a551 1
#endif
d557 2
a558 1
		curspl = m188_curspl[cpu_number()];
d565 39
a603 1
		curspl = *md.intr_mask & 0x07;
d618 1
@


1.6.4.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a40 2
#include <machine/prom.h>
#include <machine/trap.h>
d42 1
a42 1
#include <machine/m88100.h>
d46 1
a46 1
#include <ddb/db_output.h>
d59 7
d67 2
a68 1
	unsigned word_one, word_two;
d75 1
a75 2
void setlevel(unsigned int);
void vector_init(m88k_exception_vector_area *, unsigned *);
d78 1
a78 10

/*
 *  data access emulation for M88100 exceptions
 */

#define DMT_BYTE	1
#define DMT_HALF	2
#define DMT_WORD	4

const struct {
d87 1
d91 9
a99 6
#define DAE_DEBUG(stuff) \
	do { \
		if (data_access_emulation_debug != 0) { \
			stuff; \
		} \
	} while (0)
d104 4
a107 1
void
d110 10
a119 2
	int x;
	unsigned dmax, dmdx, dmtx;
d121 1
a121 1
	if (!ISSET(eframe[EF_DMT0], DMT_VALID))
d125 3
a127 2
		dmtx = eframe[EF_DMT0 + x * 3];
		if (!ISSET(dmtx, DMT_VALID))
d130 2
a131 2
		dmdx = eframe[EF_DMD0 + x * 3];
		dmax = eframe[EF_DMA0 + x * 3];
d133 6
a138 6
		if (ISSET(dmtx, DMT_WRITE))
			printf("[DMT%d=%x: st.%c %x to %x as %d %s %s]\n",
			    x, dmtx, dmtx & DMT_DAS ? 's' : 'u', dmdx, dmax,
			    DMT_ENBITS(dmtx),
			    dmtx & DMT_DOUB1 ? "double": "not double",
			    dmtx & DMT_LOCKBAR ? "xmem": "not xmem");
d140 6
a145 5
			printf("[DMT%d=%x: ld.%c r%d <- %x as %d %s %s]\n",
			    x, dmtx, dmtx & DMT_DAS ? 's' : 'u',
			    DMT_DREGBITS(dmtx), dmax, DMT_ENBITS(dmtx),
			    dmtx & DMT_DOUB1 ? "double": "not double",
			    dmtx & DMT_LOCKBAR ? "xmem": "not xmem");
d152 11
a162 3
	int x;
	unsigned dmax, dmdx, dmtx;
	unsigned v, reg;
d164 2
a165 3
	dmtx = eframe[EF_DMT0];
	if (!ISSET(dmtx, DMT_VALID))
		return;
d167 2
a168 7
	for (x = 0; x < 3; x++) {
		dmtx = eframe[EF_DMT0 + x * 3];
		if (!ISSET(dmtx, DMT_VALID) || ISSET(dmtx, DMT_SKIP))
			continue;

		dmdx = eframe[EF_DMD0 + x * 3];
		dmax = eframe[EF_DMA0 + x * 3];
d171 120
a290 144
		if (ISSET(dmtx, DMT_WRITE))
			printf("[DMT%d=%x: st.%c %x to %x as %d %s %s]\n",
			    x, dmtx, dmtx & DMT_DAS ? 's' : 'u', dmdx, dmax,
			    DMT_ENBITS(dmtx),
			    dmtx & DMT_DOUB1 ? "double": "not double",
			    dmtx & DMT_LOCKBAR ? "xmem": "not xmem");
		else
			printf("[DMT%d=%x: ld.%c r%d <- %x as %d %s %s]\n",
			    x, dmtx, dmtx & DMT_DAS ? 's' : 'u',
			    DMT_DREGBITS(dmtx), dmax, DMT_ENBITS(dmtx),
			    dmtx & DMT_DOUB1 ? "double": "not double",
			    dmtx & DMT_LOCKBAR ? "xmem": "not xmem")
	);

		dmax += dmt_en_info[DMT_ENBITS(dmtx)].offset;
		reg = DMT_DREGBITS(dmtx);

		if (!ISSET(dmtx, DMT_LOCKBAR)) {
			/* the fault is not during an XMEM */

			if (x == 2 && ISSET(dmtx, DMT_DOUB1)) {
				/* pipeline 2 (earliest stage) for a double */

				if (ISSET(dmtx, DMT_WRITE)) {
					/*
					 * STORE DOUBLE WILL BE REINITIATED
					 * BY rte
					 */
				} else {
					/* EMULATE ld.d INSTRUCTION */
					v = do_load_word(dmax, dmtx & DMT_DAS);
					if (reg != 0)
						eframe[EF_R0 + reg] = v;
					v = do_load_word(dmax ^ 4,
					    dmtx & DMT_DAS);
					if (reg != 31)
						eframe[EF_R0 + reg + 1] = v;
				}
			} else {
				/* not pipeline #2 with a double */
				if (dmtx & DMT_WRITE) {
					switch (dmt_en_info[DMT_ENBITS(dmtx)].size) {
					case DMT_BYTE:
					DAE_DEBUG(
						DEBUG_MSG("[byte %x -> [%x(%c)]\n",
						    dmdx & 0xff, dmax,
						    ISSET(dmtx, DMT_DAS) ? 's' : 'u')
					);
						do_store_byte(dmax, dmdx,
						    dmtx & DMT_DAS);
						break;
					case DMT_HALF:
					DAE_DEBUG(
						DEBUG_MSG("[half %x -> [%x(%c)]\n",
						    dmdx & 0xffff, dmax,
						    ISSET(dmtx, DMT_DAS) ? 's' : 'u')
					);
						do_store_half(dmax, dmdx,
						    dmtx & DMT_DAS);
						break;
					case DMT_WORD:
					DAE_DEBUG(
						DEBUG_MSG("[word %x -> [%x(%c)]\n",
						    dmdx, dmax,
						    ISSET(dmtx, DMT_DAS) ? 's' : 'u')
					);
						do_store_word(dmax, dmdx,
						    dmtx & DMT_DAS);
						break;
					}
				} else {
					/* else it's a read */
					switch (dmt_en_info[DMT_ENBITS(dmtx)].size) {
					case DMT_BYTE:
						v = do_load_byte(dmax,
						    dmtx & DMT_DAS);
						if (!ISSET(dmtx, DMT_SIGNED))
							v &= 0x000000ff;
						break;
					case DMT_HALF:
						v = do_load_half(dmax,
						    dmtx & DMT_DAS);
						if (!ISSET(dmtx, DMT_SIGNED))
							v &= 0x0000ffff;
						break;
					case DMT_WORD:
						v = do_load_word(dmax,
						    dmtx & DMT_DAS);
						break;
					}
					DAE_DEBUG(
						if (reg == 0)
							DEBUG_MSG("[no write to r0 done]\n");
						else
							DEBUG_MSG("[r%d <- %x]\n", reg, v);
					);
					if (reg != 0)
						eframe[EF_R0 + reg] = v;
				}
			}
		} else {
			/* if lockbar is set... it's part of an XMEM */
			/*
			 * According to Motorola's "General Information",
			 * the DMT_DOUB1 bit is never set in this case, as it
			 * should be.
			 * If lockbar is set (as it is if we're here) and if
			 * the write is not set, then it's the same as if DOUB1
			 * was set...
			 */
			if (!ISSET(dmtx, DMT_WRITE)) {
				if (x != 2) {
					/* RERUN xmem WITH DMD(x+1) */
					x++;
					dmdx = eframe[EF_DMD0 + x * 3];
				} else {
					/* RERUN xmem WITH DMD2 */
				}

				if (dmt_en_info[DMT_ENBITS(dmtx)].size ==
				    DMT_WORD) {
					v = do_xmem_word(dmax, dmdx,
					    dmtx & DMT_DAS);
				} else {
					v = do_xmem_byte(dmax, dmdx,
					    dmtx & DMT_DAS);
				}
				if (reg != 0)
					eframe[EF_R0 + reg] = v;
			} else {
				if (x == 0) {
					if (reg != 0)
						eframe[EF_R0 + reg] = dmdx;
					eframe[EF_SFIP] = eframe[EF_SNIP];
					eframe[EF_SNIP] = eframe[EF_SXIP];
					eframe[EF_SXIP] = 0;
					/* xmem RERUN ON rte */
					eframe[EF_DMT0] = 0;
					return;
				}
			}
		}
	}
	eframe[EF_DMT0] = 0;
d294 6
a299 2
#define SIGSYS_MAX	501
#define SIGTRAP_MAX	510
d301 2
a302 2
#define EMPTY_BR	0xc0000000	/* empty "br" instruction */
#define NO_OP 		0xf4005800	/* "or r0, r0, r0" */
d304 1
a304 8
#define BRANCH(FROM, TO) \
	(EMPTY_BR | ((unsigned)(TO) - (unsigned)(FROM)) >> 2)

#define SET_VECTOR(NUM, VALUE) \
	do { \
		vector[NUM].word_one = NO_OP; \
		vector[NUM].word_two = BRANCH(&vector[NUM].word_two, VALUE); \
	} while (0)
d306 4
d318 1
a318 1
void
a322 2
	extern void bugtrap(void);
	extern void m88110_bugtrap(void);
d324 1
a324 2
	for (num = 0; (vec = vector_init_list[num]) != END_OF_VECTOR_LIST;
	    num++) {
d326 5
a330 1
			SET_VECTOR(num, vec);
a332 4
	/* Save BUG vector */
	bugvec[0] = vector[MVMEPROM_VECTOR].word_one;
	bugvec[1] = vector[MVMEPROM_VECTOR].word_two;

d336 6
a341 2
		for (; num <= SIGSYS_MAX; num++)
			SET_VECTOR(num, m88110_sigsys);
d343 2
a344 2
		for (; num <= SIGTRAP_MAX; num++)
			SET_VECTOR(num, m88110_sigtrap);
d346 5
a350 4
		SET_VECTOR(450, m88110_syscall_handler);
		SET_VECTOR(MVMEPROM_VECTOR, m88110_bugtrap);
		SET_VECTOR(504, m88110_stepbpt);
		SET_VECTOR(511, m88110_userbpt);
d355 7
a361 2
		for (; num <= SIGSYS_MAX; num++)
			SET_VECTOR(num, sigsys);
d363 2
a364 2
		for (; num <= SIGTRAP_MAX; num++)
			SET_VECTOR(num, sigtrap);
d366 5
a370 4
		SET_VECTOR(450, syscall_handler);
		SET_VECTOR(MVMEPROM_VECTOR, bugtrap);
		SET_VECTOR(504, stepbpt);
		SET_VECTOR(511, userbpt);
a373 7

	/* GCC will by default produce explicit trap 503 for division by zero */
	SET_VECTOR(503, vector_init_list[T_ZERODIV]);

	/* Save new BUG vector */
	sysbugvec[0] = vector[MVMEPROM_VECTOR].word_one;
	sysbugvec[1] = vector[MVMEPROM_VECTOR].word_two;
d384 7
a390 7
	MASK_LVL_0,
	MASK_LVL_1,
	MASK_LVL_2,
	MASK_LVL_3,
	MASK_LVL_4,
	MASK_LVL_5,
	MASK_LVL_6,
d397 1
a397 1
unsigned int
d402 1
a402 1
	int i;
d417 1
a417 1
	int cpu = cpu_number();
d419 3
d430 1
a430 1
#endif
d435 1
a435 1
#endif
d441 1
a441 1
unsigned
d445 1
a445 1
	m88k_psr_type psr; /* processor status register */
a455 1
	case BRD_8120:
d465 1
a465 1
unsigned
d469 1
a469 1
	m88k_psr_type psr; /* processor status register */
d471 2
a473 1
	if (level > 7) {
d475 1
a489 1
	case BRD_8120:
a506 44
unsigned
raiseipl(unsigned level)
{
	unsigned curspl;
	m88k_psr_type psr; /* processor status register */

#ifdef DEBUG
	if (level > 7) {
		printf("raiseipl: invoked with invalid level %x\n", level);
		level &= 0x07;	/* and pray it will work */
	}
#endif

	psr = disable_interrupts_return_psr();
	switch (brdtyp) {
#ifdef MVME188
	case BRD_188:
		curspl = m188_curspl[cpu_number()];
		if (curspl < level)
			setlevel(level);
		break;
#endif /* MVME188 */
#if defined(MVME187) || defined(MVME197)
	case BRD_187:
	case BRD_8120:
	case BRD_197:
		curspl = *md.intr_mask & 0x07;
		if (curspl < level)
			*md.intr_mask = level;
		break;
#endif /* defined(MVME187) || defined(MVME197) */
	}

	flush_pipeline();

	/* The flush pipeline is required to make sure the above write gets
	 * through the data pipe and to the hardware; otherwise, the next
	 * bunch of instructions could execute at the wrong spl protection
	 */
	set_psr(psr);
	return curspl;
}

/* XXX Utterly bogus */
d516 1
a516 1
int
d519 1
a519 1
{
d530 1
a530 1
#endif
@


1.5
log
@Added kernel support for user debugging.  Fixed file ID's
@
text
@d1 1
a1 1
/* $OpenBSD: locore_c_routines.c,v 1.28 1995/04/19 22:37:27 smurph Exp $	*/
d33 2
d38 1
d40 1
a40 1
  #include <ddb/db_output.h>		 /* db_printf() 	*/
d45 1
a45 1
# define DATA_DEBUG  1
d50 1
a50 1
#  define DEBUG_MSG db_printf
d52 1
a52 1
#  define DEBUG_MSG printf
d62 7
a68 4
static struct
{
    unsigned char 	offset;
    unsigned char 	size;
d71 4
a74 4
    {0, 0}, {3, DMT_BYTE}, {2, DMT_BYTE}, {2, DMT_HALF},
    {1, DMT_BYTE}, {0, 0}, {0, 0}, {0, 0},
    {0, DMT_BYTE}, {0, 0}, {0, 0}, {0, 0},
    {0, DMT_HALF}, {0, 0}, {0, 0}, {0, DMT_WORD}
d78 21
a98 1
   int data_access_emulation_debug = 0;
d101 4
a104 4
	    "____", "___x", "__x_", "__xx",
	    "_x__", "_x_x", "_xx_", "_xxx",
	    "x___", "x__x", "x_x_", "x_xx",
	    "xx__", "xx_x", "xxx_", "xxxx",
a105 6
  #define DAE_DEBUG(stuff) {						\
	if ((data_access_emulation_debug != 0) && (			\
	    data_access_emulation_debug == 0xffffffff)) { stuff ;}   }
#else
  #define DAE_DEBUG(stuff)
#endif
d107 28
d137 138
a274 157
    register int x;
    register struct dmt_reg *dmtx;
    register unsigned  dmax, dmdx;
    register unsigned  v, reg;

    if (!(eframe[EF_DMT0] & DMT_VALID))
	return;

    for (x = 0; x < 3; x++)
    {
	dmtx = (struct dmt_reg *)&eframe[EF_DMT0+x*3];

	if (!dmtx->dmt_valid)
		continue;

	dmdx = eframe[EF_DMD0+x*3];
	dmax = eframe[EF_DMA0+x*3];

	DAE_DEBUG
	(
	  if (dmtx->dmt_write)
	    DEBUG_MSG("[DMT%d=%x: st.%c %x to %x as [%s] %s %s]\n",
	      x, eframe[EF_DMT0+x*3], dmtx->dmt_das ? 's' : 'u',
	      dmdx, dmax, bytes[dmtx->dmt_en], 
	      dmtx->dmt_doub1 ? "double": "not double",
	      dmtx->dmt_lockbar ? "xmem": "not xmem");
	  else
	    DEBUG_MSG("[DMT%d=%x: ld.%c r%d<-%x as [%s] %s %s]\n",
	      x, eframe[EF_DMT0+x*3], dmtx->dmt_das ? 's' : 'u',
	      dmtx->dmt_dreg, dmax, bytes[dmtx->dmt_en], 
	      dmtx->dmt_doub1 ? "double": "not double",
	      dmtx->dmt_lockbar ? "xmem": "not xmem");
	)

	dmax += dmt_en_info[dmtx->dmt_en].offset;
	reg = dmtx->dmt_dreg;

	if ( ! dmtx->dmt_lockbar)
	{
	    /* the fault is not during an XMEM */

	    if (x == 2 && dmtx->dmt_doub1)
	    {
		/* pipeline 2 (earliest stage) for a double */

		if (dmtx->dmt_write)
		{
		    /* STORE DOUBLE WILL BE RE-INITIATED BY rte */
		}
		else
		{
		    /* EMULATE ld.d INSTRUCTION */
			v = do_load_word(dmax, dmtx->dmt_das);
			if (reg != 0)
			    eframe[EF_R0 + reg] = v;
			v = do_load_word(dmax ^ 4, dmtx->dmt_das);
			if (reg != 31)
			    eframe[EF_R0 + reg + 1] = v;
		}
	    }
	    else	 /* not pipeline #2 with a double */
	    {
		if (dmtx->dmt_write) switch (dmt_en_info[dmtx->dmt_en].size)
		{
		  case DMT_BYTE:
		    DAE_DEBUG(DEBUG_MSG("[byte %x -> [%x(%c)]\n",
			dmdx & 0xff, dmax, dmtx->dmt_das ? 's' : 'u'))
		    do_store_byte(dmax, dmdx, dmtx->dmt_das);
		    break;
		  case DMT_HALF:
		    DAE_DEBUG(DEBUG_MSG("[half %x -> [%x(%c)]\n",
			dmdx & 0xffff, dmax, dmtx->dmt_das ? 's' : 'u'))
		    do_store_half(dmax, dmdx, dmtx->dmt_das);
		    break;
		  case DMT_WORD:
		    DAE_DEBUG(DEBUG_MSG("[word %x -> [%x(%c)]\n",
			dmdx, dmax, dmtx->dmt_das ? 's' : 'u'))
		    do_store_word(dmax, dmdx, dmtx->dmt_das);
		    break;
		}
		else	/* else it's a read */
		{
		    switch (dmt_en_info[dmtx->dmt_en].size)
		    {
		      case DMT_BYTE:
			v = do_load_byte(dmax, dmtx->dmt_das);
			if (!dmtx->dmt_signed)
			    v &= 0x000000ff;
			break;
		      case DMT_HALF:
			v = do_load_half(dmax, dmtx->dmt_das);
			if (!dmtx->dmt_signed)
			    v &= 0x0000ffff;
			break;
		      case DMT_WORD:
		      default: /* 'default' just to shut up lint */
			v = do_load_word(dmax, dmtx->dmt_das);
			break;
		    }
	   	    if (reg == 0) {
			DAE_DEBUG(DEBUG_MSG("[no write to r0 done]\n"));
		    }
		    else
		    {
			DAE_DEBUG(DEBUG_MSG("[r%d <- %x]\n",
				reg, v));
			eframe[EF_R0 + reg] = v;
		    }
		}
	    }
	}
	else /* if lockbar is set... it's part of an XMEM */
	{
	    /*
	     * According to Motorola's "General Information",
	     * the dmt_doub1 bit is never set in this case, as it should be.
	     * They call this "general information" - I call it a f*cking bug!
	     *
	     * Anyway, if lockbar is set (as it is if we're here) and if
	     * the write is not set, then it's the same as if doub1
	     * was set...
	     */
	    if ( ! dmtx->dmt_write)
	    {
		if (x != 2)
		{
		    /* RERUN xmem WITH DMD(x+1) */
		    x++;
		    dmdx = eframe[EF_DMD0 + x*3];
		}
		else
		{
		    /* RERUN xmem WITH DMD2 */
		}

		if (dmt_en_info[dmtx->dmt_en].size == DMT_WORD)
		    v = do_xmem_word(dmax, dmdx, dmtx->dmt_das);
		else
		    v = do_xmem_byte(dmax, dmdx, dmtx->dmt_das);
		eframe[EF_R0 + reg] = v;
	    }
	    else
	    {
		if (x == 0)
		{
		    eframe[EF_R0 + reg] = dmdx;
		    eframe[EF_SFIP] = eframe[EF_SNIP];
		    eframe[EF_SNIP] = eframe[EF_SXIP];
		    eframe[EF_SXIP] = 0;
		    /* xmem RERUN ON rte */
		    eframe[EF_DMT0] = 0;
		    return;
		}
	    }
	}
    }
    eframe[EF_DMT0] = 0;
d276 1
d283 1
a283 1
#define SIGTRAP_MAX     511
d288 3
a290 4
typedef struct
{
	unsigned word_one,
		 word_two;
d295 2
a296 1
#define SET_VECTOR(NUM, to, VALUE) {                                       \
d302 6
a307 1

d317 154
a470 2
	m88k_exception_vector_area *vector,
	unsigned *vector_init_list)
d472 3
a474 15
    register unsigned num;
    register unsigned vec;
    extern void sigsys(), sigtrap(), stepbpt(), userbpt();
    extern void syscall_handler();

    for (num = 0; (vec = vector_init_list[num]) != END_OF_VECTOR_LIST; num++)
    {
	if (vec != PREDEFINED_BY_ROM)
	    SET_VECTOR(num, to, vec);
    }
    while (num < 496)
	SET_VECTOR(num++, to, sigsys);
    num++; /* skip 496, BUG ROM vector */

    SET_VECTOR(450, to, syscall_handler);
d476 26
a501 2
    while (num <= SIGSYS_MAX)
	SET_VECTOR(num++, to, sigsys);
d503 28
a530 2
    while (num <= SIGTRAP_MAX)
	SET_VECTOR(num++, to, sigtrap);
d532 109
a640 5
    SET_VECTOR(504, to, stepbpt);
    SET_VECTOR(511, to, userbpt);
#if 0
    vector[496].word_one = 496 * 4;
    vector[497].word_two = 497 * 4;
d642 2
a643 1
}
@


1.4
log
@Commit for the first working mvme88k port.
@
text
@d1 1
d300 1
a300 1
#if 0
d309 1
@


1.3
log
@Cleanup after import. This also seems to bring up the current version.
@
text
@d34 1
a34 1
#include <machine/locore.h>		 /* END_OF_VECTOR_LIST, etc. */
a293 1

@


1.2
log
@This is a remove to get rid of the old mvme88k port which was incomplete
to replace it with a working version. The kernel compiles and works
at least.  The new version will be imported shortly.
@
text
@a271 1

d278 1
d287 1
d298 2
a312 82

/* JEFF_DEBUG stuff */
#include <machine/asm_macro.h>

#ifdef JUNK
#define MAX_XPR_COUNT	1000
struct {
    task_t task;
    char *fmt;
    unsigned arg1;
    unsigned arg2;
} raw_xpr_data[MAX_XPR_COUNT];
unsigned volatile raw_xpr_lock = 0;
unsigned raw_xpr_index = 0;

void _raw_xpr(char *fmt, unsigned b, unsigned c, task_t t)
{
    unsigned myindex;
    m88k_psr_type psr = disable_interrupts_return_psr();
    simple_lock(&raw_xpr_lock);
    if (raw_xpr_index < (MAX_XPR_COUNT - 1)) {
        myindex = raw_xpr_index++;
    } else {
	myindex = 0;
	raw_xpr_index = 1;
    }
    simple_unlock(&raw_xpr_lock);
    set_psr(psr);

    raw_xpr_data[myindex].task = t;
    raw_xpr_data[myindex].fmt  = fmt;
    raw_xpr_data[myindex].arg1 = b;
    raw_xpr_data[myindex].arg2 = c;
}

void raw_xpr_dump(int skipcount)
{
    int i, index = raw_xpr_index + 1;

    raw_xpr_lock = 1; /* forcefully grab the lock */

    if (index >= MAX_XPR_COUNT)
	index = 0;
    else if (raw_xpr_data[index].task == 0)
	index = 0; /* hasn't wrapped yet, so start at the beginning */

    for (i = 1; i < MAX_XPR_COUNT; i++) {
	if (raw_xpr_data[index].task == 0 || raw_xpr_data[index].fmt == 0)
	    break; /* all done */
	if (skipcount-- <= 0)
	{
	    db_printf("%04d: ", i);
	    if (db_lookup_task(raw_xpr_data[index].task) < 0)
	    {
		/* task no longer valid */
		db_printf("<task %x, fmt %x, arg %x, arg %x>\n",
			raw_xpr_data[index].task,
			raw_xpr_data[index].fmt,
			raw_xpr_data[index].arg1,
			raw_xpr_data[index].arg2);
	    } else {
		char buffer[120];
		buffer[0] = '\0';
		db_read_bytes(raw_xpr_data[index].fmt,
			      sizeof(buffer),
			      buffer,
			      raw_xpr_data[index].task);
		buffer[sizeof(buffer)-2] = '\n';
		buffer[sizeof(buffer)-1] = '\0';
		
		db_printf(buffer,
			raw_xpr_data[index].arg1,
			raw_xpr_data[index].arg2);
	   }
	}
	if (++index >= MAX_XPR_COUNT)
	    index = 0;
    }
    
    raw_xpr_lock = 0;
}
#endif /* JUNK */
@


1.1
log
@moved from m88k directory
@
text
@@


1.1.1.1
log
@Third try at importing the mvme88k port. This is a working kernel
from nivas.
Userland and compiler still need to be worked on.
Make certain what directory the import is done from.
@
text
@d272 1
a278 1
 *	XXX clean this - nivas
a286 1
    extern void syscall_handler();
a296 2

    SET_VECTOR(450, to, syscall_handler);
d310 82
@
