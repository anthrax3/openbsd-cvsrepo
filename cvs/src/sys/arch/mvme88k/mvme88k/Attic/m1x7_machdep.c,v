head	1.12;
access;
symbols
	OPENBSD_5_5:1.11.0.6
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.10.0.2
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.9.0.14
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.12
	OPENBSD_5_0:1.9.0.10
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.8
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.6
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.4
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.7.0.4
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.6.0.4
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.2
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.5.0.2
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.4.0.4
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.2
	OPENBSD_4_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.12
date	2014.03.18.22.36.36;	author miod;	state dead;
branches;
next	1.11;

1.11
date	2013.05.17.22.46.28;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2013.01.05.11.20.56;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2009.03.09.19.51.18;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2009.03.04.19.35.54;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2009.02.13.23.26.51;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2007.12.04.23.45.53;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2007.05.14.16.57.43;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2006.05.02.21.43.09;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2006.04.27.20.21.19;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2006.04.27.20.19.31;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2006.04.19.22.09.40;	author miod;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: m1x7_machdep.c,v 1.11 2013/05/17 22:46:28 miod Exp $ */
/*
 * Copyright (c) 2009, 2013 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * Copyright (c) 1999 Steve Murphree, Jr.
 * Copyright (c) 1995 Theo de Raadt
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1995 Nivas Madhur
 * Copyright (c) 1994 Gordon W. Ross
 * Copyright (c) 1993 Adam Glass
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)clock.c	8.1 (Berkeley) 6/11/93
 */

/*
 * PCC 2 interval and statistic clocks driver, and reboot routine.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/mutex.h>
#include <sys/timetc.h>

#include <machine/board.h>
#include <machine/bus.h>

#include <mvme88k/dev/pcctwovar.h>
#include <mvme88k/dev/pcctworeg.h>
#include <mvme88k/dev/vme.h>

#include <mvme88k/mvme88k/clockvar.h>

int	m1x7_clockintr(void *);
int	m1x7_statintr(void *);
u_int	pcc_get_timecount(struct timecounter *);

uint32_t	pcc_refcnt;
struct mutex pcc_mutex = MUTEX_INITIALIZER(IPL_CLOCK);

struct timecounter pcc_timecounter = {
	pcc_get_timecount,
	NULL,
	0xffffffff,
	1000000,	/* 1MHz */
	"pcctwo",
	0,
	NULL
};

#define	PROF_RESET	(IPL_CLOCK | PCC2_IRQ_IEN | PCC2_IRQ_ICLR)
#define	STAT_RESET	(IPL_STATCLOCK | PCC2_IRQ_IEN | PCC2_IRQ_ICLR)

void
m1x7_init_clocks(void)
{
	int statint, minint;

#ifdef DIAGNOSTIC
	if (1000000 % hz) {
		printf("cannot get %d Hz clock; using 100 Hz\n", hz);
		hz = 100;
	}
#endif
	tick = 1000000 / hz;

	/* profclock */
	*(volatile u_int8_t *)(PCC2_BASE + PCCTWO_T1CTL) = 0;
	*(volatile u_int32_t *)(PCC2_BASE + PCCTWO_T1CMP) =
	    pcc2_timer_us2lim(tick);
	*(volatile u_int32_t *)(PCC2_BASE + PCCTWO_T1COUNT) = 0;
	*(volatile u_int8_t *)(PCC2_BASE + PCCTWO_T1CTL) =
	    PCC2_TCTL_CEN | PCC2_TCTL_COC | PCC2_TCTL_COVF;
	*(volatile u_int8_t *)(PCC2_BASE + PCCTWO_T1ICR) = PROF_RESET;

	if (stathz == 0)
		stathz = hz;
#ifdef DIAGNOSTIC
	if (1000000 % stathz) {
		printf("cannot get %d Hz statclock; using 100 Hz\n", stathz);
		stathz = 100;
	}
#endif
	profhz = stathz;		/* always */

	statint = 1000000 / stathz;
	minint = statint / 2 + 100;
	while (statvar > minint)
		statvar >>= 1;

	/* statclock */
	*(volatile u_int8_t *)(PCC2_BASE + PCCTWO_T2CTL) = 0;
	*(volatile u_int32_t *)(PCC2_BASE + PCCTWO_T2CMP) =
	    pcc2_timer_us2lim(statint);
	*(volatile u_int32_t *)(PCC2_BASE + PCCTWO_T2COUNT) = 0;
	*(volatile u_int8_t *)(PCC2_BASE + PCCTWO_T2CTL) =
	    PCC2_TCTL_CEN | PCC2_TCTL_COC | PCC2_TCTL_COVF;
	*(volatile u_int8_t *)(PCC2_BASE + PCCTWO_T2ICR) = STAT_RESET;

	statmin = statint - (statvar >> 1);

	clock_ih.ih_fn = m1x7_clockintr;
	clock_ih.ih_arg = 0;
	clock_ih.ih_wantframe = 1;
	clock_ih.ih_ipl = IPL_CLOCK;
	pcctwointr_establish(PCC2V_TIMER1, &clock_ih, "clock");

	statclock_ih.ih_fn = m1x7_statintr;
	statclock_ih.ih_arg = 0;
	statclock_ih.ih_wantframe = 1;
	statclock_ih.ih_ipl = IPL_STATCLOCK;
	pcctwointr_establish(PCC2V_TIMER2, &statclock_ih, "stat");

	tc_init(&pcc_timecounter);
}

/*
 * clockintr: ack intr and call hardclock
 */
int
m1x7_clockintr(void *eframe)
{
	uint oflow;
	uint32_t t1, t2;
	uint8_t c;

	/*
	 * Since we can not freeze the counter while reading the count
	 * and overflow registers, read them a second time; if the
	 * counter has wrapped, pick the second reading.
	 */
	mtx_enter(&pcc_mutex);
	t1 = *(volatile uint32_t *)(PCC2_BASE + PCCTWO_T1COUNT);
	c = *(volatile u_int8_t *)(PCC2_BASE + PCCTWO_T1CTL);
	t2 = *(volatile uint32_t *)(PCC2_BASE + PCCTWO_T1COUNT);
	if (t2 < t1)
		c = *(volatile u_int8_t *)(PCC2_BASE + PCCTWO_T1CTL);
	*(volatile u_int8_t *)(PCC2_BASE + PCCTWO_T1CTL) =
	    PCC2_TCTL_CEN | PCC2_TCTL_COC | PCC2_TCTL_COVF;
	*(volatile u_int8_t *)(PCC2_BASE + PCCTWO_T1ICR) = PROF_RESET;
	oflow = c >> PCC2_TCTL_OVF_SHIFT;
	pcc_refcnt += oflow * tick;
	mtx_leave(&pcc_mutex);

	while (oflow-- != 0) {
		hardclock(eframe);

#ifdef MULTIPROCESSOR
		/*
		 * Send an IPI to all other processors, so they can get their
		 * own ticks.
		 */
		m88k_broadcast_ipi(CI_IPI_HARDCLOCK);
#endif
	}

	return (1);
}

u_int
pcc_get_timecount(struct timecounter *tc)
{
	uint32_t tcr1, tcr2;
	uint8_t tctl;
	uint cnt, oflow;

	mtx_enter(&pcc_mutex);
	tcr1 = *(volatile u_int32_t *)(PCC2_BASE + PCCTWO_T1COUNT);
	tctl = *(volatile u_int8_t *)(PCC2_BASE + PCCTWO_T1CTL);
	/*
	 * Since we can not freeze the counter while reading the count
	 * and overflow registers, read it a second time; if it the
	 * counter has wrapped, pick the second reading.
	 */
	tcr2 = *(volatile u_int32_t *)(PCC2_BASE + PCCTWO_T1COUNT);
	if (tcr2 < tcr1) {
		tcr1 = tcr2;
		tctl = *(volatile u_int8_t *)(PCC2_BASE + PCCTWO_T1CTL);
	}
	cnt = pcc_refcnt;
	mtx_leave(&pcc_mutex);

	oflow = tctl >> PCC2_TCTL_OVF_SHIFT;
	while (oflow-- != 0)
		cnt += pcc2_timer_us2lim(tick);
	return cnt + tcr1;
}

int
m1x7_statintr(void *eframe)
{
	u_long newint, r, var;

	*(volatile u_int8_t *)(PCC2_BASE + PCCTWO_T2ICR) = STAT_RESET;

	/*
	 * Compute new randomized interval.  The intervals are uniformly
	 * distributed on [statint - statvar / 2, statint + statvar / 2],
	 * and therefore have mean statint, giving a stathz frequency clock.
	 */
	var = statvar;
	do {
		r = random() & (var - 1);
	} while (r == 0);
	newint = statmin + r;

	*(volatile u_int8_t *)(PCC2_BASE + PCCTWO_T2CTL) = 0;
	*(volatile u_int32_t *)(PCC2_BASE + PCCTWO_T2CMP) =
	    pcc2_timer_us2lim(newint);
	*(volatile u_int32_t *)(PCC2_BASE + PCCTWO_T2COUNT) = 0;
	*(volatile u_int8_t *)(PCC2_BASE + PCCTWO_T2ICR) = STAT_RESET;
	*(volatile u_int8_t *)(PCC2_BASE + PCCTWO_T2CTL) =
	    PCC2_TCTL_CEN | PCC2_TCTL_COC;

	statclock((struct clockframe *)eframe);

#ifdef MULTIPROCESSOR
	/*
	 * Send an IPI to all other processors as well.
	 */
	m88k_broadcast_ipi(CI_IPI_STATCLOCK);
#endif

	return (1);
}

void
m1x7_delay(int us)
{
	/*
	 * On MVME187 and MVME197, use the VMEchip for the delay clock.
	 */
	*(volatile u_int32_t *)(VME2_BASE + VME2_T1CMP) = 0xffffffff;
	*(volatile u_int32_t *)(VME2_BASE + VME2_T1COUNT) = 0;
	*(volatile u_int32_t *)(VME2_BASE + VME2_TCTL) |= VME2_TCTL1_CEN;

	while ((*(volatile u_int32_t *)(VME2_BASE + VME2_T1COUNT)) <
	    (u_int32_t)us)
		;
	*(volatile u_int32_t *)(VME2_BASE + VME2_TCTL) &= ~VME2_TCTL1_CEN;
}

/*
 * Reboot the system.
 */
void
m1x7_reboot(int howto)
{
#ifdef MVME197
	int i;
#endif

	/*
	 * Try hitting the SRST bit in VMEChip2 to reset the system.
	 */
	if (*(volatile u_int32_t *)(VME2_BASE + VME2_TCTL) & VME2_TCTL_SCON)
		*(volatile u_int32_t *)(VME2_BASE + VME2_TCTL) |=
		    VME2_TCTL_SRST;

#ifdef MVME197
	/*
	 * MVME197LE Errata #7:
	 * ``When asserting the RST bit in the VMEchip2 GCSR, the pulse
	 *   generated is too short for the BusSwitch1 to recognize
	 *   properly.''
	 */
	for (i = 0x20000000; i != 0; i--)
#endif
		*(volatile u_int32_t *)(VME2_BASE + VME2_GCSR_LM_SIG_BSCR) |=
		    VME2_GCSR_RST;
}

/*
 * Return whether we are the VME bus system controller.
 */
int
m1x7_is_syscon()
{
	return ISSET(*(volatile u_int32_t *)(VME2_BASE + VME2_TCTL),
	    VME2_TCTL_SCON);
}

int	vme2abort(void *);
struct intrhand vme2_abih;

/*
 * Setup VME bus access and return the lower interrupt number usable by VME
 * boards.
 */
u_int
m1x7_init_vme(const char *devname)
{
	u_int32_t vbr, ctl, irqen, master, master4mod;
	u_int vecbase;

	vbr = *(volatile u_int32_t *)(VME2_BASE + VME2_VBR);
	vecbase = VME2_GET_VBR1(vbr) + 0x10;
	/* Sanity check that the BUG is set up right */
	if (vecbase >= 0x100) {
		panic("Correct the VME Vector Base Register values "
		    "in the BUG settings.\n"
		    "Suggested values are 0x60 for VME Vec0 and "
		    "0x70 for VME Vec1.");
	}

	/* turn off SYSFAIL LED */
	*(volatile u_int32_t *)(VME2_BASE + VME2_TCTL) &= ~VME2_TCTL_SYSFAIL;

	/*
	 * Display the VMEChip2 decoder status.
	 */
	printf("%s: using BUG parameters\n", devname);
	ctl = *(volatile u_int32_t *)(VME2_BASE + VME2_GCSRCTL);
	if (ctl & VME2_GCSRCTL_MDEN1) {
		master = *(volatile u_int32_t *)(VME2_BASE + VME2_MASTER1);
		printf("%s: 1phys 0x%08lx-0x%08lx to VME 0x%08lx-0x%08lx\n",
		    devname, master << 16, master & 0xffff0000,
		    master << 16, master & 0xffff0000);
	}
	if (ctl & VME2_GCSRCTL_MDEN2) {
		master = *(volatile u_int32_t *)(VME2_BASE + VME2_MASTER2);
		printf("%s: 2phys 0x%08lx-0x%08lx to VME 0x%08lx-0x%08lx\n",
		    devname, master << 16, master & 0xffff0000,
		    master << 16, master & 0xffff0000);
	}
	if (ctl & VME2_GCSRCTL_MDEN3) {
		master = *(volatile u_int32_t *)(VME2_BASE + VME2_MASTER3);
		printf("%s: 3phys 0x%08lx-0x%08lx to VME 0x%08lx-0x%08lx\n",
		    devname, master << 16, master & 0xffff0000,
		    master << 16, master & 0xffff0000);
	}
	if (ctl & VME2_GCSRCTL_MDEN4) {
		master = *(volatile u_int32_t *)(VME2_BASE + VME2_MASTER4);
		master4mod =
		    *(volatile u_int32_t *)(VME2_BASE + VME2_MASTER4MOD);
		printf("%s: 4phys 0x%08lx-0x%08lx to VME 0x%08lx-0x%08lx\n",
		    devname, master << 16, master & 0xffff0000,
		    (master << 16) + (master4mod << 16),
		    (master & 0xffff0000) + (master4mod & 0xffff0000));
	}

	/*
	 * Map the VME irq levels to the cpu levels 1:1.
	 * This is rather inflexible, but much easier.
	 */
	*(volatile u_int32_t *)(VME2_BASE + VME2_IRQL4) =
	    (7 << VME2_IRQL4_VME7SHIFT) | (6 << VME2_IRQL4_VME6SHIFT) |
	    (5 << VME2_IRQL4_VME5SHIFT) | (4 << VME2_IRQL4_VME4SHIFT) |
	    (3 << VME2_IRQL4_VME3SHIFT) | (2 << VME2_IRQL4_VME2SHIFT) |
	    (1 << VME2_IRQL4_VME1SHIFT);
	printf("%s: vme to cpu irq level 1:1\n", devname);

	/* Enable the reset switch */
	*(volatile u_int32_t *)(VME2_BASE + VME2_TCTL) |= VME2_TCTL_RSWE;
	/* Set Watchdog timeout to about 1 minute */
	*(volatile u_int32_t *)(VME2_BASE + VME2_TCR) |= VME2_TCR_64S;
	/* Enable VMEChip2 Interrupts */
	*(volatile u_int32_t *)(VME2_BASE + VME2_VBR) |= VME2_IOCTL1_MIEN;

	/*
	 * Map the Software VME irq levels to the cpu level 7.
	 */
	*(volatile u_int32_t *)(VME2_BASE + VME2_IRQL3) =
	    (7 << VME2_IRQL3_SW7SHIFT) | (7 << VME2_IRQL3_SW6SHIFT) |
	    (7 << VME2_IRQL3_SW5SHIFT) | (7 << VME2_IRQL3_SW4SHIFT) |
	    (7 << VME2_IRQL3_SW3SHIFT) | (7 << VME2_IRQL3_SW2SHIFT) |
	    (7 << VME2_IRQL3_SW1SHIFT);

	/*
	 * Register abort interrupt handler.
	 */
	vme2_abih.ih_fn = vme2abort;
	vme2_abih.ih_arg = 0;
	vme2_abih.ih_wantframe = 1;
	vme2_abih.ih_ipl = IPL_NMI;
	intr_establish(0x6e, &vme2_abih, devname);

	irqen = *(volatile u_int32_t *)(VME2_BASE + VME2_IRQEN);
	irqen |= VME2_IRQ_AB;

	/*
	 * Enable ACFAIL interrupt, but disable Timer 1 interrupt - we
	 * prefer it without for delay().
	 */
	irqen = (irqen | VME2_IRQ_ACF) & ~VME2_IRQ_TIC1;
	*(volatile u_int32_t *)(VME2_BASE + VME2_IRQEN) = irqen;

	return vecbase;
}

int
m1x7_intsrc_available(u_int intsrc, int ipl)
{
	if (intsrc != INTSRC_VME)
		return ENXIO;		/* should never happen anyway */

	return 0;
}

void
m1x7_intsrc_enable(u_int intsrc, int ipl)
{
	*(volatile u_int32_t *)(VME2_BASE + VME2_IRQEN) |=
	    VME2_IRQ_VME(ipl);
}

int
vme2abort(void *frame)
{
	if ((*(volatile u_int32_t *)(VME2_BASE + VME2_IRQSTAT) &
	    VME2_IRQ_AB) == 0)
		return 0;

	*(volatile u_int32_t *)(VME2_BASE + VME2_IRQCLR) = VME2_IRQ_AB;
	nmihand(frame);

	return 1;
}
@


1.11
log
@Replace the bunch of md_* function pointers with a `struct board' containing
function pointers for all the board-specific code.

Add a bunch of `struct board' methods to cover most, if not all, of the
`per-board' logic. This allows most of the md drivers to be cleaned up and
no longer need to embed board-specific knowledge.
@
text
@d1 1
a1 1
/*	$OpenBSD: m1x7_machdep.c,v 1.10 2013/01/05 11:20:56 miod Exp $ */
@


1.10
log
@Switch m88k ports to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: m1x7_machdep.c,v 1.9 2009/03/09 19:51:18 miod Exp $ */
d3 1
a3 1
 * Copyright (c) 2009 Miodrag Vallat.
d85 1
a85 1
 * Interval and statistic clocks driver.
d95 1
d311 177
@


1.9
log
@Switch mvme88k to timecounters.
@
text
@d1 1
a1 1
/*	$OpenBSD: m1x7_machdep.c,v 1.8 2009/03/04 19:35:54 miod Exp $ */
d193 2
d196 5
d202 5
a206 2
	oflow = (*(volatile u_int8_t *)(PCC2_BASE + PCCTWO_T1CTL) &
	    PCC2_TCTL_OVF) >> PCC2_TCTL_OVF_SHIFT;
d209 2
a211 1
	*(volatile u_int8_t *)(PCC2_BASE + PCCTWO_T1ICR) = PROF_RESET;
d241 2
a242 2
	 * and overflow registers, read it a second time; if it has
	 * wrapped, pick the second reading.
d252 4
a255 5
	oflow = (tctl & PCC2_TCTL_OVF) >> PCC2_TCTL_OVF_SHIFT;
	if (oflow != 0)
		return cnt + tcr1 + oflow * tick;
	else
		return cnt + tcr1;
@


1.8
log
@When handling clock interrupts, check the overflow counter to know how many
times hardclock() needs to be invoked; fixes clock drift found on 197DP
with SMP kernels.
@
text
@d1 16
a16 1
/*	$OpenBSD: m1x7_machdep.c,v 1.7 2009/02/13 23:26:51 miod Exp $ */
d92 2
d105 14
d182 2
d194 1
d199 1
a199 1

d201 1
d216 30
@


1.7
log
@Make delay() a per-board function pointer.
@
text
@d1 1
a1 1
/*	$OpenBSD: m1x7_machdep.c,v 1.6 2007/12/04 23:45:53 miod Exp $ */
d159 7
d168 2
a169 1
	hardclock(eframe);
d172 5
a176 5
	/*
	 * Send an IPI to all other processors, so they can get their
	 * own ticks.
	 */
	m88k_broadcast_ipi(CI_IPI_HARDCLOCK);
d178 1
@


1.6
log
@Work in progress SMP code for 88110 processor using the BusSwitch chip as
an IPI facility, for MVME197DP.

It's still missing a few remote cache IPIs and IPI do not seem to be reliably
triggered on remote processors at the moment (but this could be a problem
on the board I am currently testing on), at least it will boot multiuser
using only cpu0 to schedule processes.
@
text
@d1 1
a1 1
/*	$OpenBSD: m1x7_machdep.c,v 1.5 2007/05/14 16:57:43 miod Exp $ */
d82 1
d210 16
@


1.5
log
@Register statclock() at IPL_STATCLOCK, not IPL_CLOCK (no-op since they are
the same)
@
text
@d1 1
a1 1
/*	$OpenBSD: m1x7_machdep.c,v 1.4 2006/05/02 21:43:09 miod Exp $ */
d162 8
a179 2
	statclock((struct clockframe *)eframe);

d198 10
@


1.4
log
@Wave goodbye to bugtty on mvme88k as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: m1x7_machdep.c,v 1.3 2006/04/27 20:21:19 miod Exp $ */
d89 1
a89 1
#define	STAT_RESET	(IPL_CLOCK | PCC2_IRQ_IEN | PCC2_IRQ_ICLR)
d148 1
a148 1
	statclock_ih.ih_ipl = IPL_CLOCK;
@


1.3
log
@<machine/mvme1x7.h> is not really used anymore, remove it.
@
text
@d1 1
a1 1
/*	$OpenBSD: m1x7_machdep.c,v 1.2 2006/04/27 20:19:31 miod Exp $ */
a151 5
#include "bugtty.h"
#if NBUGTTY > 0
#include <mvme88k/dev/bugttyfunc.h>
#endif

a160 3
#if NBUGTTY > 0
	bugtty_chkinput();
#endif /* NBUGTTY */
@


1.2
log
@Adjust sizes for the mandatory 1:1 mappings created in pmap_bootstrap().
Saves up to 12KB of no longer necessary page tables.
@
text
@d1 1
a1 1
/*	$OpenBSD: m1x7_machdep.c,v 1.1 2006/04/19 22:09:40 miod Exp $ */
a79 1
#include <machine/mvme1x7.h>
@


1.1
log
@Get rid of the clock device attachment - since the clock is not something
we can live without, move it into the board-dependent code. This even makes
the code slightly smaller.

clock.c is moved from dev/ to mvme88k/ and only keeps common variables and
delay().
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.45 2006/04/15 22:31:46 miod Exp $ */
d106 2
a107 2
	*(volatile u_int8_t *)(OBIO_START + PCC2_BASE + PCCTWO_T1CTL) = 0;
	*(volatile u_int32_t *)(OBIO_START + PCC2_BASE + PCCTWO_T1CMP) =
d109 2
a110 2
	*(volatile u_int32_t *)(OBIO_START + PCC2_BASE + PCCTWO_T1COUNT) = 0;
	*(volatile u_int8_t *)(OBIO_START + PCC2_BASE + PCCTWO_T1CTL) =
d112 1
a112 2
	*(volatile u_int8_t *)(OBIO_START + PCC2_BASE + PCCTWO_T1ICR) =
	    PROF_RESET;
d130 2
a131 2
	*(volatile u_int8_t *)(OBIO_START + PCC2_BASE + PCCTWO_T2CTL) = 0;
	*(volatile u_int32_t *)(OBIO_START + PCC2_BASE + PCCTWO_T2CMP) =
d133 2
a134 2
	*(volatile u_int32_t *)(OBIO_START + PCC2_BASE + PCCTWO_T2COUNT) = 0;
	*(volatile u_int8_t *)(OBIO_START + PCC2_BASE + PCCTWO_T2CTL) =
d136 1
a136 2
	*(volatile u_int8_t *)(OBIO_START + PCC2_BASE + PCCTWO_T2ICR) =
	    STAT_RESET;
d164 1
a164 2
	*(volatile u_int8_t *)(OBIO_START + PCC2_BASE + PCCTWO_T1ICR) =
	    PROF_RESET;
d179 1
a179 2
	*(volatile u_int8_t *)(OBIO_START + PCC2_BASE + PCCTWO_T2ICR) =
	    STAT_RESET;
d194 2
a195 2
	*(volatile u_int8_t *)(OBIO_START + PCC2_BASE + PCCTWO_T2CTL) = 0;
	*(volatile u_int32_t *)(OBIO_START + PCC2_BASE + PCCTWO_T2CMP) =
d197 3
a199 4
	*(volatile u_int32_t *)(OBIO_START + PCC2_BASE + PCCTWO_T2COUNT) = 0;
	*(volatile u_int8_t *)(OBIO_START + PCC2_BASE + PCCTWO_T2ICR) =
	    STAT_RESET;
	*(volatile u_int8_t *)(OBIO_START + PCC2_BASE + PCCTWO_T2CTL) =
@

