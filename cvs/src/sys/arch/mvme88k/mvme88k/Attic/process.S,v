head	1.30;
access;
symbols
	SMP_SYNC_A:1.30
	SMP_SYNC_B:1.30
	OPENBSD_3_5:1.29.0.2
	OPENBSD_3_5_BASE:1.29
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.15.0.6
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.4
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	UBC_SYNC_B:1.15
	UBC:1.14.0.2
	UBC_BASE:1.14
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.5.0.10
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.8
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.6
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.4
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	mvme88kport:1.1.1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@# @;


1.30
date	2004.04.29.14.33.27;	author miod;	state dead;
branches;
next	1.29;

1.29
date	2004.01.17.22.35.41;	author miod;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	2004.01.13.14.15.56;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2004.01.13.01.02.10;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2004.01.07.23.43.54;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2003.12.29.10.54.09;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2003.11.17.14.48.20;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2003.11.08.16.43.02;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2003.10.27.10.45.58;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2003.08.13.08.52.44;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2003.08.12.18.06.48;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2003.08.11.20.45.17;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2003.08.11.01.09.35;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2003.08.10.21.34.20;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2003.08.03.23.34.09;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.22.09.49.39;	author smurph;	state Exp;
branches;
next	1.14;

1.14
date	2001.12.16.23.49.47;	author miod;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2001.12.13.08.55.52;	author smurph;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.18.01.43.33;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.26.14.31.12;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.24.22.53.15;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.20.05.53.10;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.09.05.44.42;	author smurph;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.07.23.40.35;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.12.07.29.26;	author smurph;	state Exp;
branches;
next	1.5;

1.5
date	99.02.09.06.36.30;	author smurph;	state Exp;
branches
	1.5.6.1;
next	1.4;

1.4
date	97.05.24.03.02.32;	author rahnds;	state Exp;
branches;
next	1.3;

1.3
date	97.03.03.20.21.47;	author rahnds;	state Exp;
branches;
next	1.2;

1.2
date	97.03.03.19.08.13;	author rahnds;	state dead;
branches;
next	1.1;

1.1
date	95.10.18.12.32.32;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.03.03.19.32.23;	author rahnds;	state Exp;
branches;
next	;

1.5.6.1
date	2001.04.18.16.11.40;	author niklas;	state Exp;
branches;
next	1.5.6.2;

1.5.6.2
date	2001.07.04.10.20.21;	author niklas;	state Exp;
branches;
next	1.5.6.3;

1.5.6.3
date	2001.10.31.03.01.20;	author nate;	state Exp;
branches;
next	1.5.6.4;

1.5.6.4
date	2001.12.05.00.39.13;	author niklas;	state Exp;
branches;
next	1.5.6.5;

1.5.6.5
date	2002.03.06.02.04.45;	author niklas;	state Exp;
branches;
next	1.5.6.6;

1.5.6.6
date	2004.02.19.10.49.08;	author niklas;	state Exp;
branches;
next	1.5.6.7;

1.5.6.7
date	2004.06.05.23.09.51;	author niklas;	state dead;
branches;
next	;

1.14.2.1
date	2002.01.31.22.55.19;	author niklas;	state Exp;
branches;
next	;

1.29.2.1
date	2004.08.01.18.38.43;	author brad;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Continue factorizing m88k common code, this time files in <arch>/<arch>
which were copied verbatim from mvme88k to luna88k.

This requires backing out syntactic sugar in mvme88k kernel configuration
files which would deduct the required processor types from the board models,
as the common code only depends upon the M88100 and M88110 defines.
@
text
@/*	$OpenBSD: process.S,v 1.29 2004/01/17 22:35:41 miod Exp $	*/
/*
 * Copyright (c) 1996 Nivas Madhur
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Nivas Madhur.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include "assym.h"
#include <machine/asm.h>
#include <machine/psl.h>
#include <machine/intr.h>

	data
	align	4
ASLOCAL(swchanpanic)
	string	"switch wchan %x\0"
	align	4
ASLOCAL(swsrunpanic)
	string	"switch SRUN %x\0"
#ifdef DEBUG
	align	4
ASLOCAL(boguspsr)
	string	"Invalid PSR in idle loop 0x%x\n\0"
#endif

	text
	align	8
ASLOCAL(Lswchanpanic)
	or.u	r2, r0, hi16(_ASM_LABEL(swchanpanic))
	or	r2, r2, lo16(_ASM_LABEL(swchanpanic))
	bsr.n	_C_LABEL(panic)
	 or	r3, r0, r9

ASLOCAL(Lswsrunpanic)
	or.u	r2, r0, hi16(_ASM_LABEL(swsrunpanic))
	or	r2, r2, lo16(_ASM_LABEL(swsrunpanic))
	bsr.n	_C_LABEL(panic)
	 or	r3, r0, r9

/*
 * At exit of a process, do a cpu_switch for the last time.
 * The mapping of the pcb at p->p_addr has already been deleted,
 * and the memory for the pcb+stack has been freed.
 * The ipl is high enough to prevent the memory from being reallocated.
 * switch_exit(proc * p)
 */

ENTRY(switch_exit)
	/*
	 * Change pcb to idle u. area, i.e., set r31 to top of stack
	 * and set curpcb to point to _idle_u.  r2 contains proc *p.
	 */
	or.u	r30, r0, hi16(_C_LABEL(idle_u))
	or	r30, r30,lo16(_C_LABEL(idle_u))
	addu	r31, r30, USIZE			/* now on idle_u stack */
	or.u	r10, r0, hi16(_C_LABEL(curpcb))
	st	r30, r10,lo16(_C_LABEL(curpcb))		/* curpcb = &idle_u */
	or.u	r10, r0, hi16(_C_LABEL(curproc))
	st	r0, r10, lo16(_C_LABEL(curproc))	/* curproc = NULL */

	/* Schedule the vmspace and stack to be freed. */
	bsr.n	_C_LABEL(exit2)
	 subu	r31, r31, 48		/* allocate stack  */
	addu	r31, r31, 48		/* restore stack */
	bsr	_C_LABEL(cpu_switch)	/* goto final switch */

/*
 * cpu_switch()
 * XXX - Arg 1 is a proc pointer (curproc) but this doesn't use it.
 * XXX - how about using stack for saving spl and last proc?
 * XXX rewrite this whole mess in C nivas
 */
ENTRY(cpu_switch)

	/*
	 * Save state of previous process in its pcb.
	 */
	or.u	r2, r0, hi16(_C_LABEL(curpcb))
	ld	r2, r2, lo16(_C_LABEL(curpcb))
	st	r1, r2, PCB_PC		/* save return address */
	bsr	_ASM_LABEL(__savectx)
	/* note that we don't need to recover r1 at this point */

	or.u	r11, r0, hi16(_C_LABEL(curproc))
	ld	r2, r11, lo16(_C_LABEL(curproc))
	bcnd	eq0, r2, 1f

	bsr.n	_C_LABEL(pmap_deactivate)
	 subu	r31, r31,48
	addu    r31, r31,48
	or.u	r11, r0, hi16(_C_LABEL(curproc))

1:
	st	r0, r11, lo16(_C_LABEL(curproc))	/* curproc = NULL */

ASLOCAL(Lidleloop)

	/*
	 * Find the highest-priority queue that isn't empty,
	 * then take the first proc from that queue.
	 */

	or.u	r7, r0, hi16(_C_LABEL(whichqs))
	ld	r7, r7, lo16(_C_LABEL(whichqs))

	bcnd	ne0, r7, _ASM_LABEL(Ldoneloop)

ASLOCAL(Lloopchk)			/* if whichqs is zero, keep checking */
	bsr.n	_C_LABEL(setipl)	/* unmask all ints... */
	 or	r2, r0, IPL_NONE

	ldcr	r2, PSR
	bb0	PSR_INTERRUPT_DISABLE_BIT, r2, 1f
#ifdef DEBUG
	or	r3, r2, r0
	or.u	r2, r0, hi16(_ASM_LABEL(boguspsr))
	bsr.n	_C_LABEL(printf)
	 or	r2, r2, lo16(_ASM_LABEL(boguspsr))
	ldcr	r2, PSR
#endif
	clr	r2, r2, 1<PSR_INTERRUPT_DISABLE_BIT>	/* ...and enable them */
	stcr	r2, PSR
	FLUSH_PIPELINE
1:
	br	_ASM_LABEL(Lidleloop)

ASLOCAL(Ldoneloop)

	bsr.n	_C_LABEL(setipl)	/* disable ints */
	 or	r2, r0, IPL_HIGH

	or.u	r7, r0, hi16(_C_LABEL(whichqs))	/* reload whichqs */
	ld	r7, r7, lo16(_C_LABEL(whichqs))

	bcnd	eq0, r7, _ASM_LABEL(Lloopchk)	/* keep spinning for whichqs to be != 0 */

	xor	r6, r6, r6		/* set r6 to 0 */
1:	bb1	0,  r7, 2f		/* if rightmost bit set, done */
	extu	r7, r7, 0<1>		/* else, right shift whichqs, */
	br.n	1b			/* increment r6, and repeat */
	 addu	r6, r6, 1
2:
	or.u	r7, r0, hi16(_qs)
	or	r7, r7, lo16(_qs)

	/*
	 * Need to make
	 *	p->p_forw->p_back = p->p_back and
	 *	p->p_back->p_forw = p->p_forw where
	 *	p is q->p_forw.
	 * Remember that q->p_forw == p and p->p_back == q.
	 */

	lda.d	r8,  r7[r6]	/* r8 = &qs[ff1(whichqs)] */
	ld	r9,  r8, P_FORW	/* r8 is q, r9 is p */

	ld	r12, r9, P_FORW	/* r12 = p->p_forw */
	st	r8, r12, P_BACK	/* p->p_forw->p_back = q (p->p_back) */
	st	r12, r8, P_FORW	/* q->p_forw = p->p_forw */
	lda.d	r8,  r7[r6]	/* reload r8 with qs[ff1(whichqs)] */
	ld	r12, r8, P_FORW	/* q->p_forw */
	cmp	r12, r12, r8	/* q == q->p_forw; anyone left on queue? */
	bb1	ne,  r12, 3f	/* yes, skip clearing bit in whichqs  */

	or	r12, r0, 1	/* r12 is 1 now */
1:	bcnd	eq0, r6, 2f
	mak	r12, r12, 0<1>	/* shift left by 1 */
	br.n	1b
	 subu	r6,  r6, 1	/* keep doing this while r6 != 0 */
2:
	/*
	 * NOTE: we could have just used "mak r12, r12, r6" instead of the
	 * loop above. But that will break if NQS is made > 32. I can use
	 * preprocessor to do the right thing, but that means I have to
	 * include sys/proc.h in this file. XXX nivas
	 */
	or.u	r7,  r0, hi16(_C_LABEL(whichqs))
	ld	r8,  r7, lo16(_C_LABEL(whichqs))
	and.c	r8,  r8, r12	/* whichqs &= ~the bit */
	st	r8,  r7, lo16(_C_LABEL(whichqs))
3:
	ld	r2, r9, P_WCHAN
	bcnd	ne0, r2, _ASM_LABEL(Lswchanpanic)
	ld.b	r2, r9, P_STAT
	cmp	r2, r2, SRUN
	bb1	ne, r2, _ASM_LABEL(Lswsrunpanic)

	or.u	r11, r0, hi16(_C_LABEL(want_resched))
	st	r0, r11, lo16(_C_LABEL(want_resched))	/* clear want_resched */

	or.u	r11, r0, hi16(_C_LABEL(curproc))
	st	r9,  r11,lo16(_C_LABEL(curproc))	/* curproc = p */

	/*  r9 is curproc */
	st	r0, r9, P_BACK			/* p->p_back = 0 */
	ld	r3, r9, P_ADDR
	or.u	r10, r0, hi16(_C_LABEL(curpcb))
	st	r3, r10, lo16(_C_LABEL(curpcb))		/* curpcb = p->p_addr */

	/* pmap_activate() the process' pmap */
	or	r2, r0, r9		/* r2 = p */
	or	r14, r0, r9		/* save p in r14 */
	bsr.n	_C_LABEL(pmap_activate)
	 subu	r31, r31,48
	addu    r31, r31,48
	or	r9, r0, r14		/* restore p saved in r14 */

	or.u	r31, r0, hi16(_ASM_LABEL(intstack_end))
	or	r31,r31, lo16(_ASM_LABEL(intstack_end))
	subu	r31, r31,48
	bsr.n    _C_LABEL(load_u_area)
	 or	r2, r0, r9
	addu	r31, r31,48

	or.u	r10, r0,  hi16(_C_LABEL(curpcb))
	ld	r10, r10,  lo16(_C_LABEL(curpcb))
	/* XXX Is this correct/necessary? */
	st	r10, r14, P_ADDR	/* p->p_addr = curpcb; restore p_addr */

	/* restore from the current context */
	ld	r2, r10, PCB_FCR62
	ld	r3, r10, PCB_FCR63
	fstcr	r2, fcr62
	fstcr	r3, fcr63
	ld	r1, r10, PCB_PC
	ld	r14,r10, PCB_R14
	ld	r15,r10, PCB_R15
	ld	r16,r10, PCB_R16
	ld	r17,r10, PCB_R17
	ld	r18,r10, PCB_R18
	ld	r19,r10, PCB_R19
	ld	r20,r10, PCB_R20
	ld	r21,r10, PCB_R21
	ld	r22,r10, PCB_R22
	ld	r23,r10, PCB_R23
	ld	r24,r10, PCB_R24
	ld	r25,r10, PCB_R25
	ld	r26,r10, PCB_R26
	ld	r27,r10, PCB_R27
	ld	r28,r10, PCB_R28
	ld	r29,r10, PCB_R29
	ld	r30,r10, PCB_R30	/* restore frame pointer & stack */
	ld	r31,r10, PCB_SP

/* XXX
 * Should we postpone restoring stack till after ipl is restored?
 * The stack access could fault
 */
	subu	r31,r31,48
	st	r1, r31,36		/* save r1 on stack */
	bsr.n	_C_LABEL(setipl)
	 ld	r2, r10, PCB_IPL	/* restore interrupt mask */
	ld	r1, r31,36		/* restore r1 from stack */
	addu	r31,r31,48
	jmp.n	r1
	 or	r2, r0, 1		/* return 1 (for alternate returns) */

/*
 * savectx(pcb)
 * Update pcb, saving current processor state.
 */
ENTRY(savectx)
	/*
	 * Save preserved general register set.
	 */
	st	r1,  r2,  PCB_PC		/* save return address */
ASENTRY(__savectx)
	st	r14, r2,  PCB_R14
	st	r15, r2,  PCB_R15
	st	r16, r2,  PCB_R16
	st	r17, r2,  PCB_R17
	st	r18, r2,  PCB_R18
	st	r19, r2,  PCB_R19
	st	r20, r2,  PCB_R20
	st	r21, r2,  PCB_R21
	st	r22, r2,  PCB_R22
	st	r23, r2,  PCB_R23
	st	r24, r2,  PCB_R24
	st	r25, r2,  PCB_R25
	st	r26, r2,  PCB_R26
	st	r27, r2,  PCB_R27
	st	r28, r2,  PCB_R28
	st	r29, r2,  PCB_R29
	st	r30, r2,  PCB_R30	/* save frame pointer & stack pointer */
	st	r31, r2,  PCB_SP

	/*
	 * Get the current spl.
	 * We need to save r1 on the stack because we don't know if we were
	 * called as savectx or __savectx.
	 */
	subu	r31, r31, 40		/* allocate stack for r1 and args */
	st	r1,  r31, 32
	bsr.n	_C_LABEL(getipl)	/* get the current interrupt mask */
	 or	r14, r0,  r2
	st	r2,  r14, PCB_IPL	/* save interrupt mask */
	ld	r1,  r31, 32		/* recover return address */
	addu	r31, r31, 40		/* put stack pointer back */

	/*
	 * Save FP state.
	 */
	fldcr	r2,  fcr62
	fldcr	r3,  fcr63
	st	r2,  r14, PCB_FCR62
	jmp.n	r1
	 st	r3,  r14, PCB_FCR63
@


1.29
log
@Now that the phys_map_vaddr bug is out of the way, it's time to bring back
diffs which had been suspected of breakage while they were just helping this
bug to trigger.

Don't flush user tlb in the scheduler, since pmap_activate() will take care
of it if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.28 2004/01/13 14:15:56 miod Exp $	*/
@


1.29.2.1
log
@MFC:
Fix by miod@@

Do not trash r14 by mistake in __savectx.

ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.29 2004/01/17 22:35:41 miod Exp $	*/
a330 1
	st	r3,  r14, PCB_FCR63
d332 1
a332 1
	 ld 	r14, r14, PCB_R14	/* preserve r14 */
@


1.28
log
@Always keep the kernel stack on a 8 byte boundary...
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.27 2004/01/13 01:02:10 miod Exp $	*/
a237 10
	addu	r31, r31,48

				/* flush tlb of any user addresses */
	or	r2, r0, 0	/* 0 = user space */
	or	r3, r0, 0	/* start at addr 0 */
	subu	r31, r31,48
	/* r2 = 1 : kernel ? user, r3 = address, r4 = size */
	/* cmmu_flush_tlb(0, 0, 0xffff) */
	bsr.n	_C_LABEL(md_cmmu_flush_tlb)
	 sub	r4, r0, 1	/* flush entire va space */
@


1.27
log
@In cpu_switch(), use (almost) savectx() rather than rolling our own version.
While there, slightly optimize savectx() for speed and stack usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.26 2004/01/07 23:43:54 miod Exp $	*/
d327 1
a327 1
	subu	r31, r31, 36		/* allocate stack for r1 and args */
d333 1
a333 1
	addu	r31, r31, 36		/* put stack pointer back */
@


1.26
log
@Revert the pmap machinery to 20031228. The changes made since all produce
different subtle races, and need more tinkering until they are really safe.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.25 2003/12/29 10:54:09 miod Exp $	*/
d103 5
a107 30

	or.u	r10, r0, hi16(_C_LABEL(curpcb))
	ld	r10,r10, lo16(_C_LABEL(curpcb))
	st	r1, r10, PCB_PC
	st	r14,r10, PCB_R14
	st	r15,r10, PCB_R15
	st	r16,r10, PCB_R16
	st	r17,r10, PCB_R17
	st	r18,r10, PCB_R18
	st	r19,r10, PCB_R19
	st	r20,r10, PCB_R20
	st	r21,r10, PCB_R21
	st	r22,r10, PCB_R22
	st	r23,r10, PCB_R23
	st	r24,r10, PCB_R24
	st	r25,r10, PCB_R25
	st	r26,r10, PCB_R26
	st	r27,r10, PCB_R27
	st	r28,r10, PCB_R28
	st	r29,r10, PCB_R29
	st	r30,r10, PCB_R30	/* save frame pointer & stack pointer */
	st	r31,r10, PCB_SP
	fldcr	r2, fcr62
	fldcr	r3, fcr63
	st	r2, r10, PCB_FCR62
	st	r3, r10, PCB_FCR63

	bsr.n	_C_LABEL(getipl)
	 or	r14,r10, 0		/* save r10 in r14 */
	st	r2, r14, PCB_IPL	/* save ipl in pcb */
d298 31
a328 3
	/* get the spl mask */
	subu	r31,r31,48		/* allocate stack for r1 and args */
	st	r1,r31,36		/* save return address */
d330 11
a340 27
	 st	r2,r31,32		/* save r2 */
	ld	r1,r31,36		/* recover return address */
	ld	r10,r31,32		/* recover r2 into r10 */
	addu	r31,r31,48		/* put stack pointer back */
	st	r1, r10, PCB_PC		/* save return address */
	st	r14,r10, PCB_R14
	st	r15,r10, PCB_R15
	st	r16,r10, PCB_R16
	st	r17,r10, PCB_R17
	st	r18,r10, PCB_R18
	st	r19,r10, PCB_R19
	st	r20,r10, PCB_R20
	st	r21,r10, PCB_R21
	st	r22,r10, PCB_R22
	st	r23,r10, PCB_R23
	st	r24,r10, PCB_R24
	st	r25,r10, PCB_R25
	st	r26,r10, PCB_R26
	st	r27,r10, PCB_R27
	st	r28,r10, PCB_R28
	st	r29,r10, PCB_R29
	st	r30,r10, PCB_R30	/* save frame pointer & stack pointer */
	st	r31,r10, PCB_SP
	st	r2, r10, PCB_IPL	/* save interrupt mask */
	fldcr	r2, fcr62
	fldcr	r3, fcr63
	st	r2, r10, PCB_FCR62
d342 1
a342 1
	 st	r3, r10, PCB_FCR63
@


1.25
log
@Since pmap_activate() does a complete user tlb flush, it is not necessary
to do another one in process.S...
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.24 2003/11/17 14:48:20 miod Exp $	*/
d263 10
@


1.24
log
@Be sure to pmap_deactivate() pmaps when processes exit or are scheduled out.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.23 2003/11/08 16:43:02 miod Exp $	*/
a257 1
ASLOCAL(Lswnochg)
d264 1
a264 9
				/* flush tlb of any user addresses */
	or	r2, r0, 0	/* 0 = user space */
	or	r3, r0, 0	/* start at addr 0 */
	subu	r31, r31,48
	/* r2 = 1 : kernel ? user, r3 = address, r4 = size */
	/* cmmu_flush_tlb(0, 0, 0xffff) */
	bsr.n	_C_LABEL(md_cmmu_flush_tlb)
	 sub	r4, r0, 1		/* flush entire va space */
	addu	r31, r31,48
@


1.23
log
@Save the current floatingpoint state in the pcb.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.22 2003/10/27 10:45:58 miod Exp $	*/
d135 9
a252 1
	/* r2 = pmap, r3 = pcb, r4 = cpu number */
@


1.22
log
@Be sure to flush the entire va space in cpu_switch().
This used to work because the cmmu code is suboptimal at the moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.21 2003/08/13 08:52:44 miod Exp $	*/
d125 4
d272 5
a276 1
	ld	r1,r10,  PCB_PC
d342 3
d346 1
a346 2
	 or	r2,r0,r0

@


1.21
log
@Always force a pipeline flush after a PSR change, not before. How could
this have ever worked?
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.20 2003/08/12 18:06:48 miod Exp $	*/
d260 1
a260 2
	 or	r4, r0, 0xffff		/* cmmu_flush_tlb flushes entire tlb */
					/* for sizes > 4096		     */
@


1.20
log
@The idle loop is supposed to run with interrupts enabled, and will only
relax the interrupt mask (i.e. spl level).

However, under some unclear circumstances, it will be entered with
interrupts disabled, and thus will loop forever if no process is runnable.

Check the PSR and make sure that interrupts are enabled in this case. This
gets rid of the random freezes, although a better fix would be preferrable...
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.19 2003/08/11 20:45:17 miod Exp $	*/
d90 1
a90 2
	bsr.n	_C_LABEL(cpu_switch)	/* goto final switch */
	 or	r2, r0, r10
d106 1
a106 1
	st	r1, r10, PCB_PC		/*  save r1 in pcb */
a127 1

a130 3
	ld	r11,r11, lo16(_C_LABEL(curproc))

	or.u	r11, r0, hi16(_C_LABEL(curproc))
d147 1
a147 1
	 or	r2, r0, 0
d159 1
a160 1
	stcr	r2, PSR
@


1.19
log
@Sprinkle proper use of _C_LABEL and _ASM_LABEL in the .S files (except for
the _fp.S which are too scary at the moment). This will be necessary to
move to ELF in the future.

Use local symbols whenever possible.

Attempt to use delayed branches whenever possible.

Remove stupid or straightforward comments, some hardcoded values, and a
few unused variables or routines.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.18 2003/08/11 01:09:35 miod Exp $	*/
d45 5
d151 1
a151 1
	bsr.n	_C_LABEL(setipl)	/* enable all ints */
d154 13
@


1.18
log
@Saving or restoring the process' registers to/from the pcb was using
double load/store instructions, for speed; however, these only work if
the pcb structure is also 8 bytes aligned... which is not necessarily
true. In this case, the lossage was compensated by the data access
exception handler, which means that for every unlucky pcb operation,
the kernel was happily generating a dozen of exceptions in a row...

Stop the madness and change this to regular load/store operations.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.17 2003/08/10 21:34:20 miod Exp $	*/
d40 2
a41 2
swchanpanic:
	string	"switch wchan %x"
d43 2
a44 2
swsrunpanic:
	string	"switch SRUN %x"
d48 12
a59 11
Lswchanpanic:
	or.u	r2, r0, hi16(swchanpanic)
	or	r2, r2, lo16(swchanpanic)
	or	r3, r0, r9
	bsr	_panic

Lswsrunpanic:
	or.u	r2, r0, hi16(swsrunpanic)
	or	r2, r2, lo16(swsrunpanic)
	or	r3, r0, r9
	bsr	_panic
d73 7
a79 7
	or.u	r30, r0, hi16(_idle_u)
	or	r30, r30,lo16(_idle_u)
	addu	r31, r30, USIZE		/* now on idle_u stack */
	or.u	r10, r0, hi16(_curpcb)
	st	r30, r10,lo16(_curpcb)	/* curpcb = &idle_u */
	or.u	r10, r0, hi16(_curproc)
	st	r0, r10, lo16(_curproc)	/* curproc = NULL */
d82 2
a83 2
	bsr.n	_exit2			/* call exit2(p); */
	subu	r31, r31, 48		/* allocate stack  */
d85 2
a86 2
	bsr.n	_cpu_switch		/* goto final switch */
	or	r2, r0, r10
a87 20
#if 0
/*
 * When no processes are on the runq, switch
 * idles here watiing for something to come ready.
 */
ASGLOBAL(idle)
	or.u	r10, r0, hi16(_curproc)
	st	r0, r10, lo16(_curproc)	/* curproc = NULL */

	bsr.n	_setipl			/* unblock all interrupts */
	or	r2, r0, 0
					/* spin reading whichqs until != 0 */
1:
	or.u	r10, r0, hi16(_whichqs)
	ld	r11, r10,lo16(_whichqs)
	bcnd	eq0, r11, 1b
	bsr.n	_setipl
	or	r2, r0, IPL_HIGH	/* block all ints */
	br	Lsw1
#endif /* 0 */
d100 2
a101 2
	or.u	r10, r0, hi16(_curpcb)
	ld	r10,r10, lo16(_curpcb)
d122 2
a123 3
	or	r14,r10, 0		/* save r10 in r14 */

	bsr	_getipl
d127 2
a128 2
	or.u	r11, r0, hi16(_curproc)
	ld	r11,r11, lo16(_curproc)
d130 2
a131 2
	or.u	r11, r0, hi16(_curproc)
	st	r0, r11, lo16(_curproc)	/* curproc = NULL */
d133 1
a133 1
Lidleloop:
d140 2
a141 2
	or.u	r7, r0, hi16(_whichqs)
	ld	r7, r7, lo16(_whichqs)
d143 1
a143 1
	bcnd	ne0, r7, Ldoneloop
d145 3
a147 3
Lloopchk:				/* if whichqs is zero, keep checking */
	bsr.n	_setipl			/* enable all ints */
	or	r2, r0, 0
d149 1
a149 1
	br	Lidleloop
d151 1
a151 1
Ldoneloop:
d153 2
a154 2
	bsr.n	_setipl			/* disable ints */
	or	r2, r0, IPL_HIGH
d156 2
a157 2
	or.u	r7, r0, hi16(_whichqs)	/* reload whichqs */
	ld	r7, r7, lo16(_whichqs)
d159 1
a159 1
	bcnd	eq0, r7, Lloopchk	/* keep spinning for whichqs to be !=0*/
d165 1
a165 1
	addu	r6, r6, 1
d187 1
a187 1
	bb1	ne,  r12, Lsw2	/* yes, skip clearing bit in whichqs  */
d193 1
a193 1
	subu	r6,  r6, 1	/* keep doing this while r6 != 0 */
d201 2
a202 2
	or.u	r7,  r0, hi16(_whichqs)
	ld	r8,  r7, lo16(_whichqs)
d204 2
a205 2
	st	r8,  r7, lo16(_whichqs)	/* reset bit in whichqs */
Lsw2:
d207 1
a207 1
	bcnd	ne0, r2, Lswchanpanic
d210 1
a210 1
	bb1	ne, r2, Lswsrunpanic
d212 2
a213 2
	or.u	r11, r0, hi16(_want_resched)
	st	r0, r11, lo16(_want_resched)	/* clear want_resched */
d215 2
a216 11
	or.u	r11, r0, hi16(_curproc)
	st	r9,  r11,lo16(_curproc)		/* curproc = p */

	/* huh??? */
	or.u	r10, r0, hi16(_curpcb)
	ld	r10,r10, lo16(_curpcb)

#ifdef notyet
	cmp	r2, r2, r9
	bb1	eq, r2, Lswsameproc
#endif /* notyet */
d221 2
a222 2
	or.u	r10, r0, hi16(_curpcb)
	st	r3, r10, lo16(_curpcb)		/* curpcb = p->p_addr */
d224 1
a224 3
	/* see if pmap_activate needs to be called */
	/* _pmap_activate() now has proc * as parameter 01-11-2000 smurph */
	/* No more VM_PMAP to contend with!!!  */
a226 1
	subu	r31, r31,48
d228 2
a229 1
	bsr	_pmap_activate		/* _pmap_activate(proc *p)*/
d233 3
a235 3
Lswnochg:
	or.u	r31, r0, hi16(_intstack_end)
	or	r31,r31, lo16(_intstack_end)/* now goto a tmp stack for NMI */
d237 2
a238 2
	bsr.n    _load_u_area
	or	r2, r0, r9
d246 2
a247 2
	bsr.n	_md_cmmu_flush_tlb
	or	r4, r0, 0xffff		/* cmmu_flush_tlb flushes entire tlb */
d250 2
a251 2
	or.u	r10, r0,  hi16(_curpcb)
	ld	r10, r10,  lo16(_curpcb)
d276 4
a279 3
/* XXX should we postpone restoring stack till after ipl is restored? The
stack access could fault */
Lswsameproc:
d282 2
a283 2
	ld	r2, r10, PCB_IPL	/* restore interrupt mask */
	bsr	_setipl			/* restore ipl */
d287 1
a287 1
	or	r2, r0, 1		/* return 1 (for alternate returns) */
d297 2
a298 2
	st	r2,r31,32		/* save r2 */
	bsr	_getipl			/* get the current interrupt mask */
d323 1
a323 1
	or	r2,r0,r0
@


1.17
log
@Do not make NBPG visible in assym.h
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.16 2003/08/03 23:34:09 miod Exp $	*/
d122 18
a139 9
	st.d	r14,r10, PCB_R14
	st.d	r16,r10, PCB_R16
	st.d	r18,r10, PCB_R18
	st.d	r20,r10, PCB_R20
	st.d	r22,r10, PCB_R22
	st.d	r24,r10, PCB_R24
	st.d	r26,r10, PCB_R26
	st.d	r28,r10, PCB_R28
	st.d	r30,r10, PCB_R30	/* save frame pointer & stack pointer */
d288 18
a305 9
	ld.d	r14,r10, PCB_R14
	ld.d	r16,r10, PCB_R16
	ld.d	r18,r10, PCB_R18
	ld.d	r20,r10, PCB_R20
	ld.d	r22,r10, PCB_R22
	ld.d	r24,r10, PCB_R24
	ld.d	r26,r10, PCB_R26
	ld.d	r28,r10, PCB_R28
	ld.d	r30,r10, PCB_R30	/* restore frame pointer & stack */
d333 18
a350 9
	st.d	r14,r10, PCB_R14
	st.d	r16,r10, PCB_R16
	st.d	r18,r10, PCB_R18
	st.d	r20,r10, PCB_R20
	st.d	r22,r10, PCB_R22
	st.d	r24,r10, PCB_R24
	st.d	r26,r10, PCB_R26
	st.d	r28,r10, PCB_R28
	st.d	r30,r10, PCB_R30	/* save frame pointer and sp */
@


1.16
log
@Resistance is futile, you will be KNF'ed.
And then it will be easier to debug this mess (no functional change yet).
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.15 2001/12/22 09:49:39 smurph Exp $	*/
d74 1
a74 1
	addu	r31, r30, UPAGES * NBPG	/* now on idle_u stack */
@


1.15
log
@masive cmmu overhaul.  function pointers now control cmmu functionality
instead of case statements based on cpu type.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.14 2001/12/16 23:49:47 miod Exp $	*/
d39 1
a39 1
	align 4
d41 2
a42 2
	string  "switch wchan %x"
	align 4
d47 1
a47 1
	align 8
d49 4
a52 4
	or.u r2, r0, hi16(swchanpanic)
	or   r2, r2, lo16(swchanpanic)
	or   r3, r0, r9
	bsr  _panic
d55 4
a58 4
	or.u r2, r0, hi16(swsrunpanic)
	or   r2, r2, lo16(swsrunpanic)
	or   r3, r0, r9
	bsr  _panic
d79 1
a79 1
        
d101 1
a101 1
	ld	r11, r10,lo16(_whichqs) 
d157 1
a157 1
	bsr.n	_setipl			/* enable all ints */	
d173 1
a173 1
     1:	bb1	0,  r7, 2f		/* if rightmost bit set, done */
d177 1
a177 1
     2:
d180 1
a180 1
	
d193 2
a194 2
	st	r8, r12, P_BACK /* p->p_forw->p_back = q (p->p_back) */
	st	r12, r8, P_FORW /* q->p_forw = p->p_forw */
d196 1
a196 1
	ld	r12, r8, P_FORW /* q->p_forw */
d201 1
a201 1
      1:bcnd	eq0, r6, 2f
d205 1
a205 1
      2:
d207 1
a207 1
	 * NOTE: we could have just used "mak	r12, r12, r6" instead of the
d224 1
a224 1
	st	r0, r11, lo16(_want_resched) 	/* clear want_resched */
d228 1
a228 1
	
d243 1
a243 1
	
d251 1
a251 1
	bsr	_pmap_activate		/* _pmap_activate(proc *p)*/ 
d259 1
a259 1
	bsr.n    _load_u_area		    /* load_u_area(p) */
d262 2
a263 2
					/* flush tlb of any user addresses */
        or	r2, r0, 0	/* 0 = user space */
d278 1
a278 1
	ld	r1,r10,  PCB_PC	
@


1.14
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.12 2001/11/18 01:43:33 miod Exp $	*/
d268 1
a268 1
	bsr.n	_cmmu_flush_tlb
@


1.14.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.15 2001/12/22 09:49:39 smurph Exp $	*/
d268 1
a268 1
	bsr.n	_md_cmmu_flush_tlb
@


1.13
log
@Support for MVME197 completed.  Fix SPL defs.
@
text
@d250 1
a250 1
	/* r2 = (proc *p) */
d262 2
a263 3
	
	/* flush tlb of any user addresses */
	or	r2, r0, 0	/* 0 = user space */
d268 1
a268 1
	bsr.n	_md_cmmu_flush_tlb
a271 1
	
@


1.12
log
@Remove \n from more panic messages
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.11 2001/08/26 14:31:12 miod Exp $	*/
d250 1
a250 1
	/* r2 = pmap, r3 = pcb, r4 = cpu number */
d262 3
a264 2
					/* flush tlb of any user addresses */
        or	r2, r0, 0	/* 0 = user space */
d269 1
a269 1
	bsr.n	_cmmu_flush_tlb
d273 1
@


1.11
log
@Add prototypes, fix compilation warnings, random style fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.10 2001/08/24 22:53:15 miod Exp $	*/
a39 3
Lsw0:
	string	"cpu_switch\n"
	align 4
d41 1
a41 1
	string  "switch wchan %x\n"
d44 1
a44 1
	string	"switch SRUN %x\n"
a142 3

	or.u	r11, r0, hi16(_curpcb)
	st	r0, r11, lo16(_curpcb)	/* curpcb = NULL */
@


1.10
log
@Adapt to the <machine/asm.h> macros (only for entry points for now, because
LABEL has disappeared), and to the trap() name changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.9 2001/05/20 05:53:10 miod Exp $	*/
a143 3
	or.u	r12, r0, hi16(_lastproc)
	st	r11, r12, lo16(_lastproc)/* lastproc = curproc */

a234 5
#ifdef notyet
	or.u	r2, r0, hi16(_lastproc)
	ld	r2, r2, lo16(_lastproc)
#endif /* notyet */

@


1.9
log
@assym.s -> assym.h
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.8 2001/03/09 05:44:42 smurph Exp $	*/
d95 1
a95 1
LABEL(idle)
@


1.8
log
@kernel will compile with -Werror.  Added intr.h
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.7 2001/03/07 23:40:35 miod Exp $	*/
d33 4
a36 8
#ifndef ASSEMBLER
#define	ASSEMBLER
#endif /* ASSEMBLER */

#include "assym.s"
#include "machine/asm.h"
#include "machine/psl.h"
#include "machine/intr.h"
@


1.7
log
@Get rid of definitions of ASSEMBLER, LOCORE and such. We will get
the correct defines from the Makefile now.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.6 2001/01/12 07:29:26 smurph Exp $	*/
d33 4
d40 1
@


1.6
log
@Update vm interface to MACHIN_NEW_NONCONTIG.  Fix compile warning in pcctwo.c
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.5 1999/02/09 06:36:30 smurph Exp $	*/
a31 3
#ifndef ASSEMBLER
#define ASSEMBLER
#endif
a36 4
#ifndef NBPG
#define	NBPG 4096
#endif /* NBPG */

d340 1
@


1.5
log
@Added kernel support for user debugging.  Fixed file ID's
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.28 1995/04/19 22:37:27 smurph Exp $	*/
d73 1
d79 1
a79 1
	 * and set curpcb to point to _idle_u.
d88 6
a93 1
	bsr.n	_cpu_switch
d263 1
a263 1

d265 3
a267 6
	ld	r2, r9, P_VMSPACE	/* vmspace = p->p_vmspace */
	addu	r2, r2, VM_PMAP		/* pmap = &vmspace.vm_pmap */
#ifdef notyet 
	ld	r5, r2, PM_STCHG	/* pmap->st_changed? */
	bcnd	eq0, r5, Lswnochg	/* no, skip */
#endif /* notyet */
d270 3
a272 2
	bsr	_pmap_activate		/* pmap_activate(pmap, pcb) */
	addu	r31, r31,48
d283 2
a284 2
	or	r2, r0, 0
	or	r3, r0, 0
d286 2
@


1.5.6.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.8 2001/03/09 05:44:42 smurph Exp $	*/
a31 1

d33 2
a34 2
#define	ASSEMBLER
#endif /* ASSEMBLER */
d39 4
a42 1
#include "machine/intr.h"
a72 1
 * switch_exit(proc * p)
d78 1
a78 1
	 * and set curpcb to point to _idle_u.  r2 contains proc *p.
d87 1
a87 6
        
	/* Schedule the vmspace and stack to be freed. */
	bsr.n	_exit2			/* call exit2(p); */
	subu	r31, r31, 48		/* allocate stack  */
	addu	r31, r31, 48		/* restore stack */
	bsr.n	_cpu_switch		/* goto final switch */
d257 1
a257 1
	
d259 6
a264 3
	/* _pmap_activate() now has proc * as parameter 01-11-2000 smurph */
	/* No more VM_PMAP to contend with!!!  */
	or	r2, r0, r9		/* r2 = p */
d267 2
a268 3
	/* r2 = pmap, r3 = pcb, r4 = cpu number */
	bsr	_pmap_activate		/* _pmap_activate(proc *p)*/ 
	addu    r31, r31,48
d279 2
a280 2
        or	r2, r0, 0	/* 0 = user space */
	or	r3, r0, 0	/* start at addr 0 */
a281 2
	/* r2 = 1 : kernel ? user, r3 = address, r4 = size */
	/* cmmu_flush_tlb(0, 0, 0xffff) */
a340 1

@


1.5.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.5.6.1 2001/04/18 16:11:40 niklas Exp $	*/
d33 8
a40 4
#include "assym.h"
#include <machine/asm.h>
#include <machine/psl.h>
#include <machine/intr.h>
@


1.5.6.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.5.6.2 2001/07/04 10:20:21 niklas Exp $	*/
d95 1
a95 1
ASGLOBAL(idle)
d144 3
d238 5
@


1.5.6.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.5.6.3 2001/10/31 03:01:20 nate Exp $	*/
d40 3
d44 1
a44 1
	string  "switch wchan %x"
d47 1
a47 1
	string	"switch SRUN %x"
d146 3
@


1.5.6.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d268 1
a268 1
	bsr.n	_md_cmmu_flush_tlb
@


1.5.6.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d39 6
a44 11
	align	4
ASLOCAL(swchanpanic)
	string	"switch wchan %x\0"
	align	4
ASLOCAL(swsrunpanic)
	string	"switch SRUN %x\0"
#ifdef DEBUG
	align	4
ASLOCAL(boguspsr)
	string	"Invalid PSR in idle loop 0x%x\n\0"
#endif
d47 12
a58 13
	align	8
ASLOCAL(Lswchanpanic)
	or.u	r2, r0, hi16(_ASM_LABEL(swchanpanic))
	or	r2, r2, lo16(_ASM_LABEL(swchanpanic))
	bsr.n	_C_LABEL(panic)
	 or	r3, r0, r9

ASLOCAL(Lswsrunpanic)
	or.u	r2, r0, hi16(_ASM_LABEL(swsrunpanic))
	or	r2, r2, lo16(_ASM_LABEL(swsrunpanic))
	bsr.n	_C_LABEL(panic)
	 or	r3, r0, r9

d72 8
a79 8
	or.u	r30, r0, hi16(_C_LABEL(idle_u))
	or	r30, r30,lo16(_C_LABEL(idle_u))
	addu	r31, r30, USIZE			/* now on idle_u stack */
	or.u	r10, r0, hi16(_C_LABEL(curpcb))
	st	r30, r10,lo16(_C_LABEL(curpcb))		/* curpcb = &idle_u */
	or.u	r10, r0, hi16(_C_LABEL(curproc))
	st	r0, r10, lo16(_C_LABEL(curproc))	/* curproc = NULL */

d81 2
a82 2
	bsr.n	_C_LABEL(exit2)
	 subu	r31, r31, 48		/* allocate stack  */
d84 2
a85 1
	bsr	_C_LABEL(cpu_switch)	/* goto final switch */
d87 20
a117 9
	or.u	r2, r0, hi16(_C_LABEL(curpcb))
	ld	r2, r2, lo16(_C_LABEL(curpcb))
	st	r1, r2, PCB_PC		/* save return address */
	bsr	_ASM_LABEL(__savectx)
	/* note that we don't need to recover r1 at this point */

	or.u	r11, r0, hi16(_C_LABEL(curproc))
	ld	r2, r11, lo16(_C_LABEL(curproc))
	bcnd	eq0, r2, 1f
d119 21
a139 4
	bsr.n	_C_LABEL(pmap_deactivate)
	 subu	r31, r31,48
	addu    r31, r31,48
	or.u	r11, r0, hi16(_C_LABEL(curproc))
d141 2
a142 2
1:
	st	r0, r11, lo16(_C_LABEL(curproc))	/* curproc = NULL */
d144 1
a144 1
ASLOCAL(Lidleloop)
d151 4
a154 2
	or.u	r7, r0, hi16(_C_LABEL(whichqs))
	ld	r7, r7, lo16(_C_LABEL(whichqs))
d156 3
a158 1
	bcnd	ne0, r7, _ASM_LABEL(Ldoneloop)
d160 1
a160 18
ASLOCAL(Lloopchk)			/* if whichqs is zero, keep checking */
	bsr.n	_C_LABEL(setipl)	/* unmask all ints... */
	 or	r2, r0, IPL_NONE

	ldcr	r2, PSR
	bb0	PSR_INTERRUPT_DISABLE_BIT, r2, 1f
#ifdef DEBUG
	or	r3, r2, r0
	or.u	r2, r0, hi16(_ASM_LABEL(boguspsr))
	bsr.n	_C_LABEL(printf)
	 or	r2, r2, lo16(_ASM_LABEL(boguspsr))
	ldcr	r2, PSR
#endif
	clr	r2, r2, 1<PSR_INTERRUPT_DISABLE_BIT>	/* ...and enable them */
	stcr	r2, PSR
	FLUSH_PIPELINE
1:
	br	_ASM_LABEL(Lidleloop)
d162 1
a162 1
ASLOCAL(Ldoneloop)
d164 2
a165 2
	bsr.n	_C_LABEL(setipl)	/* disable ints */
	 or	r2, r0, IPL_HIGH
d167 2
a168 2
	or.u	r7, r0, hi16(_C_LABEL(whichqs))	/* reload whichqs */
	ld	r7, r7, lo16(_C_LABEL(whichqs))
d170 1
a170 1
	bcnd	eq0, r7, _ASM_LABEL(Lloopchk)	/* keep spinning for whichqs to be != 0 */
d173 1
a173 1
1:	bb1	0,  r7, 2f		/* if rightmost bit set, done */
d176 2
a177 2
	 addu	r6, r6, 1
2:
d180 1
a180 1

d193 2
a194 2
	st	r8, r12, P_BACK	/* p->p_forw->p_back = q (p->p_back) */
	st	r12, r8, P_FORW	/* q->p_forw = p->p_forw */
d196 1
a196 1
	ld	r12, r8, P_FORW	/* q->p_forw */
d198 1
a198 1
	bb1	ne,  r12, 3f	/* yes, skip clearing bit in whichqs  */
d201 1
a201 1
1:	bcnd	eq0, r6, 2f
d204 2
a205 2
	 subu	r6,  r6, 1	/* keep doing this while r6 != 0 */
2:
d207 1
a207 1
	 * NOTE: we could have just used "mak r12, r12, r6" instead of the
d212 2
a213 2
	or.u	r7,  r0, hi16(_C_LABEL(whichqs))
	ld	r8,  r7, lo16(_C_LABEL(whichqs))
d215 2
a216 2
	st	r8,  r7, lo16(_C_LABEL(whichqs))
3:
d218 1
a218 1
	bcnd	ne0, r2, _ASM_LABEL(Lswchanpanic)
d221 1
a221 1
	bb1	ne, r2, _ASM_LABEL(Lswsrunpanic)
d223 2
a224 2
	or.u	r11, r0, hi16(_C_LABEL(want_resched))
	st	r0, r11, lo16(_C_LABEL(want_resched))	/* clear want_resched */
d226 11
a236 2
	or.u	r11, r0, hi16(_C_LABEL(curproc))
	st	r9,  r11,lo16(_C_LABEL(curproc))	/* curproc = p */
d241 6
a246 4
	or.u	r10, r0, hi16(_C_LABEL(curpcb))
	st	r3, r10, lo16(_C_LABEL(curpcb))		/* curpcb = p->p_addr */

	/* pmap_activate() the process' pmap */
d249 3
a251 2
	bsr.n	_C_LABEL(pmap_activate)
	 subu	r31, r31,48
d255 3
a257 2
	or.u	r31, r0, hi16(_ASM_LABEL(intstack_end))
	or	r31,r31, lo16(_ASM_LABEL(intstack_end))
d259 2
a260 2
	bsr.n    _C_LABEL(load_u_area)
	 or	r2, r0, r9
d262 12
a273 3

	or.u	r10, r0,  hi16(_C_LABEL(curpcb))
	ld	r10, r10,  lo16(_C_LABEL(curpcb))
d278 14
a291 28
	ld	r2, r10, PCB_FCR62
	ld	r3, r10, PCB_FCR63
	fstcr	r2, fcr62
	fstcr	r3, fcr63
	ld	r1, r10, PCB_PC
	ld	r14,r10, PCB_R14
	ld	r15,r10, PCB_R15
	ld	r16,r10, PCB_R16
	ld	r17,r10, PCB_R17
	ld	r18,r10, PCB_R18
	ld	r19,r10, PCB_R19
	ld	r20,r10, PCB_R20
	ld	r21,r10, PCB_R21
	ld	r22,r10, PCB_R22
	ld	r23,r10, PCB_R23
	ld	r24,r10, PCB_R24
	ld	r25,r10, PCB_R25
	ld	r26,r10, PCB_R26
	ld	r27,r10, PCB_R27
	ld	r28,r10, PCB_R28
	ld	r29,r10, PCB_R29
	ld	r30,r10, PCB_R30	/* restore frame pointer & stack */
	ld	r31,r10, PCB_SP

/* XXX
 * Should we postpone restoring stack till after ipl is restored?
 * The stack access could fault
 */
d294 2
a295 2
	bsr.n	_C_LABEL(setipl)
	 ld	r2, r10, PCB_IPL	/* restore interrupt mask */
d299 1
a299 1
	 or	r2, r0, 1		/* return 1 (for alternate returns) */
d306 21
a326 23
	/*
	 * Save preserved general register set.
	 */
	st	r1,  r2,  PCB_PC		/* save return address */
ASENTRY(__savectx)
	st	r14, r2,  PCB_R14
	st	r15, r2,  PCB_R15
	st	r16, r2,  PCB_R16
	st	r17, r2,  PCB_R17
	st	r18, r2,  PCB_R18
	st	r19, r2,  PCB_R19
	st	r20, r2,  PCB_R20
	st	r21, r2,  PCB_R21
	st	r22, r2,  PCB_R22
	st	r23, r2,  PCB_R23
	st	r24, r2,  PCB_R24
	st	r25, r2,  PCB_R25
	st	r26, r2,  PCB_R26
	st	r27, r2,  PCB_R27
	st	r28, r2,  PCB_R28
	st	r29, r2,  PCB_R29
	st	r30, r2,  PCB_R30	/* save frame pointer & stack pointer */
	st	r31, r2,  PCB_SP
a327 21
	/*
	 * Get the current spl.
	 * We need to save r1 on the stack because we don't know if we were
	 * called as savectx or __savectx.
	 */
	subu	r31, r31, 40		/* allocate stack for r1 and args */
	st	r1,  r31, 32
	bsr.n	_C_LABEL(getipl)	/* get the current interrupt mask */
	 or	r14, r0,  r2
	st	r2,  r14, PCB_IPL	/* save interrupt mask */
	ld	r1,  r31, 32		/* recover return address */
	addu	r31, r31, 40		/* put stack pointer back */

	/*
	 * Save FP state.
	 */
	fldcr	r2,  fcr62
	fldcr	r3,  fcr63
	st	r2,  r14, PCB_FCR62
	jmp.n	r1
	 st	r3,  r14, PCB_FCR63
@


1.5.6.7
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.5.6.6 2004/02/19 10:49:08 niklas Exp $	*/
@


1.4
log
@mvme88k will not make release, but just as well make the source as close as
possible.
@
text
@d1 1
@


1.3
log
@Cleanup after import. This also seems to bring up the current version.
@
text
@d35 1
@


1.2
log
@This is a remove to get rid of the old mvme88k port which was incomplete
to replace it with a working version. The kernel compiles and works
at least.  The new version will be imported shortly.
@
text
@d1 31
a31 1
#ifndef ASSEMBLER /* predefined by ascpp, at least */
a34 1
#include "machine/locore.h"
d36 1
a36 1
#include "assym.s"
d48 1
a48 1
	string  "switch wchan\n"
d51 1
a51 1
	string	"switch SRUN\n"
d58 1
d64 1
d72 1
d78 5
a82 6
	or.u	r31, r0, hi16(_idle_u)
	or	r31, r31,lo16(_idle_u)
	or.u	r10, r10,hi16(_curpcb)
	or	r10, r10,lo16(_curpcb)
	st	r31, r0, r10		/* curpcb = &idle_u */
	addu	r31, r31, UPAGES * NBPG	/* now on idle_u stack */
d88 1
d97 3
a99 3
	or	r2,r0,0
	bsr	_spln			/*(void) spl0(); */
					; spin reading _whichqs until nonzero
d104 2
a105 2
	bsr.n	_spln
	or	r2,r0,6
d107 1
d112 1
d115 5
d122 17
a138 5
	st	r1, r10, 0		; save r1 in pcb
	bsr	_spl
	or.u	r10, r0, hi16(_curpcb)	; a call can clobber
	ld	r10,r10, lo16(_curpcb)  ; r10 - so reload it
	st	r2, r10, 19 * 4		; save ipl in pcb
d141 1
d143 2
a144 2
	or	r12, r12, lo16(_lastproc)
	st	r11, r12, 0		; lastproc = curproc
d146 7
a152 4
	st	r0, r11, lo16(_curproc)	; curproc = NULL
	bsr.n	_spln
	or	r2,r0,6
Lsw1:
d157 1
a157 1
	or	r6, r0, r0
d160 25
a184 4
Lswchk:
	bcnd	eq0, r7, idle
	ff1	r6, r7		; 0 <= r6 <= 31
	
d187 32
a218 15
	mak	r6, r6, 0<3>
	lda	r8, r7[r6]	; r8 = qs[ff1(whichqs)]
				; r8 is q, r9 is p
	ld	r9,  r8, P_FORW	; p = q->p_forw
	ld	r12, r9, P_FORW	; r12 is p->p_forw
	st	r12, r8, P_FORW ; q->p_forw = p->p_forw
	st	r12, r8, 0	; q = p->p_forw
	ld	r12, r9, P_BACK	; r12 is p->p_back
	st	r12, r8, P_BACK	; q->p_back = p->p_back
	lda	r8,  r7[r6]	; reload r8 with qs[ff1(whichqs)]
	ld	r12,  r8, P_FORW; q->p_forw
	cmp	r12,  r12, r8	; q == q->p_forw; anyone left on queue?
	bb1	ne,  r12, Lsw2	; no, skip
	ext	r6,  r6, 0<3>	
	add	r6,  r6, 1	; turn off the bit we looked at
d221 2
a222 2
	and.c	r8,  r8, r6	; whichqs &= ~the bit
	st	r8,  r7, lo16(_whichqs)	; reset bit in whichqs
d231 1
a231 1
	st	r0, r11, lo16(_want_resched)
d234 1
a234 1
	st	r9,  r11,lo16(_curproc)	; curproc = p
d236 1
d239 1
d241 1
d245 1
d248 1
d250 5
a254 3
	/*
	 * Save state of previous process in its pcb.
	 */
a255 26
	; r1 and ipl already saved above
	st	r14,r10,4
	st	r15,r10,2*4
	st	r16,r10,3*4
	st	r17,r10,4*4
	st	r18,r10,5*4
	st	r19,r10,6*4
	st	r20,r10,7*4
	st	r21,r10,8*4
	st	r22,r10,9*4
	st	r23,r10,10*4
	st	r24,r10,11*4
	st	r25,r10,12*4
	st	r26,r10,13*4
	st	r27,r10,14*4
	st	r28,r10,15*4
	st	r29,r10,16*4
	st	r30,r10,17*4		/* save frame pointer */
	st	r31,r10,18*4		/* save stack pointer */
					/* ipl already saved  */
	; r9 is curproc
	or.u	r10, r0, hi16(_curpcb)
	or	r10,r10, lo16(_curpcb)
	st	r0, r9, P_BACK		; p->p_back = 0
	ld	r3, r9, P_ADDR
	st	r3, r10, 0		; curpcb = p->p_addr
d257 11
a267 9
	ld	r2, r9, P_VMSPACE	; vmspace = p->p_vmspace
	addu	r2, r2, VM_PMAP		; pmap = &vmspace.vm_pmap
#if 0
	ld	r5, r2, PM_STCHG	; pmap->st_changed?
	bcnd	eq0, r5, Lswnochg	; no, skip
#endif
	or	r14, r0, r9		; save p in r14
	bsr	_pmap_activate		; pmap_activate(pmap, pcb)
	or	r9, r0, r14		; restore p saved in r14
d271 3
a273 2
	or	r31,r31, lo16(_intstack_end); now goto a tmp stack for NMI
	bsr.n    _load_u_area		; load_u_area(p)
d275 9
d286 14
a299 5
	; XXX Is this correct/necessary?
	st	r10, r14, P_ADDR	; p->p_addr = curpcb; restore p_addr
	; flush some data cache here
	
	; restore from the current context
d301 2
a302 19
	ld	r1,r10,0	
	ld	r14,r10,4
	ld	r15,r10,2*4
	ld	r16,r10,3*4
	ld	r17,r10,4*4
	ld	r18,r10,5*4
	ld	r19,r10,6*4
	ld	r20,r10,7*4
	ld	r21,r10,8*4
	ld	r22,r10,9*4
	ld	r23,r10,10*4
	ld	r24,r10,11*4
	ld	r25,r10,12*4
	ld	r26,r10,13*4
	ld	r27,r10,14*4
	ld	r28,r10,15*4
	ld	r29,r10,16*4
	ld	r30,r10,17*4		/* restore frame pointer */
	ld	r31,r10,18*4		/* restore stack pointer */
d304 6
a309 7
	ld	r2, r10,19*4		/* restore interrupt mask */
	subu	r31,r31,40
	st	r1, r31,32		; save r1 on stack
	bsr	_spln
Lcxswdone:
	ld	r1, r31,32		; restore r1 from stack
	addu	r31,r31,40
d311 1
a311 1
	or	r2, r0, 1		 ; return 1 (for alternate returns)
d319 1
a319 1
	subu	r31,r31,40		/* allocate stack for r1 and args */
d322 1
a322 1
	bsr	_spl			/* get the current interrupt mask */
d325 12
a336 21
	addu	r31,r31,40		/* put stack pointer back */
	st	r1,r10,0	/* do setjmp */ /* save return address */
	st	r14,r10,4
	st	r15,r10,2*4
	st	r16,r10,3*4
	st	r17,r10,4*4
	st	r18,r10,5*4
	st	r19,r10,6*4
	st	r20,r10,7*4
	st	r21,r10,8*4
	st	r22,r10,9*4
	st	r23,r10,10*4
	st	r24,r10,11*4
	st	r25,r10,12*4
	st	r26,r10,13*4
	st	r27,r10,14*4
	st	r28,r10,15*4
	st	r29,r10,16*4
	st	r30,r10,17*4		/* save frame pointer */
	st	r31,r10,18*4		/* save stack pointer */
	st	r2, r10,19*4		/* save interrupt mask */
@


1.1
log
@moved from m88k directory
@
text
@@


1.1.1.1
log
@Third try at importing the mvme88k port. This is a working kernel
from nivas.
Userland and compiler still need to be worked on.
Make certain what directory the import is done from.
@
text
@d1 1
a1 31
/*
 * Copyright (c) 1996 Nivas Madhur
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Nivas Madhur.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
#ifndef ASSEMBLER
d5 1
d7 1
a7 1
#include "machine/psl.h"
d19 1
a19 1
	string  "switch wchan %x\n"
d22 1
a22 1
	string	"switch SRUN %x\n"
a28 1
	or   r3, r0, r9
a33 1
	or   r3, r0, r9
a40 1

d46 6
a51 5
	or.u	r30, r0, hi16(_idle_u)
	or	r30, r30,lo16(_idle_u)
	addu	r31, r30, UPAGES * NBPG	/* now on idle_u stack */
	or.u	r10, r0, hi16(_curpcb)
	st	r30, r10,lo16(_curpcb)	/* curpcb = &idle_u */
a56 1
#if 0
d65 3
a67 3
	bsr.n	_setipl			/* unblock all interrupts */
	or	r2, r0, 0
					/* spin reading whichqs until != 0 */
d72 2
a73 2
	bsr.n	_setipl
	or	r2, r0, IPL_HIGH	/* block all ints */
a74 1
#endif /* 0 */
a78 1
 * XXX rewrite this whole mess in C nivas
a80 5

	/*
	 * Save state of previous process in its pcb.
	 */

d83 5
a87 17
	st	r1, r10, PCB_PC		/*  save r1 in pcb */
	st.d	r14,r10, PCB_R14
	st.d	r16,r10, PCB_R16
	st.d	r18,r10, PCB_R18
	st.d	r20,r10, PCB_R20
	st.d	r22,r10, PCB_R22
	st.d	r24,r10, PCB_R24
	st.d	r26,r10, PCB_R26
	st.d	r28,r10, PCB_R28
	st.d	r30,r10, PCB_R30	/* save frame pointer & stack pointer */

	or	r14,r10, 0		/* save r10 in r14 */

	bsr	_getipl

	st	r2, r14, PCB_IPL	/* save ipl in pcb */

a89 1

d91 2
a92 2
	st	r11, r12, lo16(_lastproc)/* lastproc = curproc */

d94 4
a97 7
	st	r0, r11, lo16(_curproc)	/* curproc = NULL */

	or.u	r11, r0, hi16(_curpcb)
	st	r0, r11, lo16(_curpcb)	/* curpcb = NULL */

Lidleloop:

d102 1
a102 1

d105 4
a108 25

	bcnd	ne0, r7, Ldoneloop

Lloopchk:				/* if whichqs is zero, keep checking */
	bsr.n	_setipl			/* enable all ints */	
	or	r2, r0, 0

	br	Lidleloop

Ldoneloop:

	bsr.n	_setipl			/* disable ints */
	or	r2, r0, IPL_HIGH

	or.u	r7, r0, hi16(_whichqs)	/* reload whichqs */
	ld	r7, r7, lo16(_whichqs)

	bcnd	eq0, r7, Lloopchk	/* keep spinning for whichqs to be !=0*/

	xor	r6, r6, r6		/* set r6 to 0 */
     1:	bb1	0,  r7, 2f		/* if rightmost bit set, done */
	extu	r7, r7, 0<1>		/* else, right shift whichqs, */
	br.n	1b			/* increment r6, and repeat */
	addu	r6, r6, 1
     2:
d111 15
a125 32
	
	/*
	 * Need to make
	 *	p->p_forw->p_back = p->p_back and
	 *	p->p_back->p_forw = p->p_forw where
	 *	p is q->p_forw.
	 * Remember that q->p_forw == p and p->p_back == q.
	 */

	lda.d	r8,  r7[r6]	/* r8 = &qs[ff1(whichqs)] */
	ld	r9,  r8, P_FORW	/* r8 is q, r9 is p */

	ld	r12, r9, P_FORW	/* r12 = p->p_forw */
	st	r8, r12, P_BACK /* p->p_forw->p_back = q (p->p_back) */
	st	r12, r8, P_FORW /* q->p_forw = p->p_forw */
	lda.d	r8,  r7[r6]	/* reload r8 with qs[ff1(whichqs)] */
	ld	r12, r8, P_FORW /* q->p_forw */
	cmp	r12, r12, r8	/* q == q->p_forw; anyone left on queue? */
	bb1	ne,  r12, Lsw2	/* yes, skip clearing bit in whichqs  */

	or	r12, r0, 1	/* r12 is 1 now */
      1:bcnd	eq0, r6, 2f
	mak	r12, r12, 0<1>	/* shift left by 1 */
	br.n	1b
	subu	r6,  r6, 1	/* keep doing this while r6 != 0 */
      2:
	/*
	 * NOTE: we could have just used "mak	r12, r12, r6" instead of the
	 * loop above. But that will break if NQS is made > 32. I can use
	 * preprocessor to do the right thing, but that means I have to
	 * include sys/proc.h in this file. XXX nivas
	 */
d128 2
a129 2
	and.c	r8,  r8, r12	/* whichqs &= ~the bit */
	st	r8,  r7, lo16(_whichqs)	/* reset bit in whichqs */
d138 1
a138 1
	st	r0, r11, lo16(_want_resched) 	/* clear want_resched */
d141 1
a141 1
	st	r9,  r11,lo16(_curproc)		/* curproc = p */
a142 1
#ifdef notyet
a144 1
#endif /* notyet */
a145 1
	/* huh??? */
a148 1
#ifdef notyet
a150 1
#endif /* notyet */
d152 28
a179 2
	/*  r9 is curproc */
	st	r0, r9, P_BACK			/* p->p_back = 0 */
d181 1
a181 3
	or.u	r10, r0, hi16(_curpcb)
	st	r3, r10, lo16(_curpcb)		/* curpcb = p->p_addr */

d183 9
a191 11
	ld	r2, r9, P_VMSPACE	/* vmspace = p->p_vmspace */
	addu	r2, r2, VM_PMAP		/* pmap = &vmspace.vm_pmap */
#ifdef notyet 
	ld	r5, r2, PM_STCHG	/* pmap->st_changed? */
	bcnd	eq0, r5, Lswnochg	/* no, skip */
#endif /* notyet */
	or	r14, r0, r9		/* save p in r14 */
	subu	r31, r31,48
	bsr	_pmap_activate		/* pmap_activate(pmap, pcb) */
	addu	r31, r31,48
	or	r9, r0, r14		/* restore p saved in r14 */
d195 2
a196 3
	or	r31,r31, lo16(_intstack_end)/* now goto a tmp stack for NMI */
	subu	r31, r31,48
	bsr.n    _load_u_area		    /* load_u_area(p) */
a197 9
	addu	r31, r31,48
					/* flush tlb of any user addresses */
	or	r2, r0, 0
	or	r3, r0, 0
	subu	r31, r31,48
	bsr.n	_cmmu_flush_tlb
	or	r4, r0, 0xffff		/* cmmu_flush_tlb flushes entire tlb */
					/* for sizes > 4096		     */
	addu	r31, r31,48
d200 5
a204 14
	/* XXX Is this correct/necessary? */
	st	r10, r14, P_ADDR	/* p->p_addr = curpcb; restore p_addr */

	/* restore from the current context */
	ld	r1,r10,  PCB_PC	
	ld.d	r14,r10, PCB_R14
	ld.d	r16,r10, PCB_R16
	ld.d	r18,r10, PCB_R18
	ld.d	r20,r10, PCB_R20
	ld.d	r22,r10, PCB_R22
	ld.d	r24,r10, PCB_R24
	ld.d	r26,r10, PCB_R26
	ld.d	r28,r10, PCB_R28
	ld.d	r30,r10, PCB_R30	/* restore frame pointer & stack */
d206 19
a224 2
/* XXX should we postpone restoring stack till after ipl is restored? The
stack access could fault */
d226 7
a232 6
	subu	r31,r31,48
	st	r1, r31,36		/* save r1 on stack */
	ld	r2, r10, PCB_IPL	/* restore interrupt mask */
	bsr	_setipl			/* restore ipl */
	ld	r1, r31,36		/* restore r1 from stack */
	addu	r31,r31,48
d234 1
a234 1
	or	r2, r0, 1		/* return 1 (for alternate returns) */
d242 1
a242 1
	subu	r31,r31,48		/* allocate stack for r1 and args */
d245 1
a245 1
	bsr	_getipl			/* get the current interrupt mask */
d248 21
a268 12
	addu	r31,r31,48		/* put stack pointer back */
	st	r1, r10, PCB_PC		/* save return address */
	st.d	r14,r10, PCB_R14
	st.d	r16,r10, PCB_R16
	st.d	r18,r10, PCB_R18
	st.d	r20,r10, PCB_R20
	st.d	r22,r10, PCB_R22
	st.d	r24,r10, PCB_R24
	st.d	r26,r10, PCB_R26
	st.d	r28,r10, PCB_R28
	st.d	r30,r10, PCB_R30	/* save frame pointer and sp */
	st	r2, r10, PCB_IPL	/* save interrupt mask */
@
