head	1.71;
access;
symbols
	OPENBSD_5_5:1.70.0.6
	OPENBSD_5_5_BASE:1.70
	OPENBSD_5_4:1.70.0.2
	OPENBSD_5_4_BASE:1.70
	OPENBSD_5_3:1.68.0.2
	OPENBSD_5_3_BASE:1.68
	OPENBSD_5_2:1.67.0.20
	OPENBSD_5_2_BASE:1.67
	OPENBSD_5_1_BASE:1.67
	OPENBSD_5_1:1.67.0.18
	OPENBSD_5_0:1.67.0.16
	OPENBSD_5_0_BASE:1.67
	OPENBSD_4_9:1.67.0.14
	OPENBSD_4_9_BASE:1.67
	OPENBSD_4_8:1.67.0.12
	OPENBSD_4_8_BASE:1.67
	OPENBSD_4_7:1.67.0.6
	OPENBSD_4_7_BASE:1.67
	OPENBSD_4_6:1.67.0.10
	OPENBSD_4_6_BASE:1.67
	OPENBSD_4_5:1.67.0.8
	OPENBSD_4_5_BASE:1.67
	OPENBSD_4_4:1.67.0.4
	OPENBSD_4_4_BASE:1.67
	OPENBSD_4_3:1.67.0.2
	OPENBSD_4_3_BASE:1.67
	OPENBSD_4_2:1.66.0.4
	OPENBSD_4_2_BASE:1.66
	OPENBSD_4_1:1.66.0.2
	OPENBSD_4_1_BASE:1.66
	OPENBSD_4_0:1.64.0.2
	OPENBSD_4_0_BASE:1.64
	OPENBSD_3_9:1.63.0.2
	OPENBSD_3_9_BASE:1.63
	OPENBSD_3_8:1.62.0.6
	OPENBSD_3_8_BASE:1.62
	OPENBSD_3_7:1.62.0.4
	OPENBSD_3_7_BASE:1.62
	OPENBSD_3_6:1.62.0.2
	OPENBSD_3_6_BASE:1.62
	SMP_SYNC_A:1.50
	SMP_SYNC_B:1.50
	OPENBSD_3_5:1.50.0.2
	OPENBSD_3_5_BASE:1.50
	OPENBSD_3_4:1.40.0.2
	OPENBSD_3_4_BASE:1.40
	UBC_SYNC_A:1.29
	OPENBSD_3_3:1.29.0.2
	OPENBSD_3_3_BASE:1.29
	OPENBSD_3_2:1.26.0.4
	OPENBSD_3_2_BASE:1.26
	OPENBSD_3_1:1.26.0.2
	OPENBSD_3_1_BASE:1.26
	UBC_SYNC_B:1.26
	UBC:1.25.0.2
	UBC_BASE:1.25
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_8:1.8.0.8
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.6
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.4
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	mvme88kport:1.1.1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@# @;


1.71
date	2014.03.18.22.36.36;	author miod;	state dead;
branches;
next	1.70;

1.70
date	2013.05.17.22.51.59;	author miod;	state Exp;
branches;
next	1.69;

1.69
date	2013.05.17.22.46.28;	author miod;	state Exp;
branches;
next	1.68;

1.68
date	2013.01.05.11.20.56;	author miod;	state Exp;
branches;
next	1.67;

1.67
date	2007.12.21.23.56.54;	author miod;	state Exp;
branches;
next	1.66;

1.66
date	2006.11.19.11.08.55;	author miod;	state Exp;
branches;
next	1.65;

1.65
date	2006.11.18.22.53.11;	author miod;	state Exp;
branches;
next	1.64;

1.64
date	2006.04.17.16.08.01;	author miod;	state Exp;
branches;
next	1.63;

1.63
date	2005.12.03.14.30.06;	author miod;	state Exp;
branches;
next	1.62;

1.62
date	2004.08.05.21.34.11;	author miod;	state Exp;
branches;
next	1.61;

1.61
date	2004.08.04.22.03.45;	author miod;	state Exp;
branches;
next	1.60;

1.60
date	2004.08.03.21.15.38;	author miod;	state Exp;
branches;
next	1.59;

1.59
date	2004.08.02.22.16.43;	author miod;	state Exp;
branches;
next	1.58;

1.58
date	2004.08.02.08.35.00;	author miod;	state Exp;
branches;
next	1.57;

1.57
date	2004.07.27.12.16.06;	author miod;	state Exp;
branches;
next	1.56;

1.56
date	2004.06.23.08.12.33;	author miod;	state Exp;
branches;
next	1.55;

1.55
date	2004.06.23.00.31.19;	author miod;	state Exp;
branches;
next	1.54;

1.54
date	2004.06.22.23.00.15;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2004.06.22.18.27.08;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2004.06.22.05.02.35;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2004.06.22.05.01.08;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2004.01.29.21.39.05;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2004.01.29.00.41.23;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2004.01.19.17.21.25;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2004.01.09.00.24.25;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2003.11.03.06.54.26;	author david;	state Exp;
branches;
next	1.45;

1.45
date	2003.10.09.16.30.58;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2003.10.05.21.22.02;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2003.10.05.20.31.24;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2003.09.20.13.57.37;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2003.09.17.22.22.32;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2003.09.08.20.44.52;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2003.09.07.01.49.16;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2003.09.07.01.00.29;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2003.09.06.15.07.43;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2003.09.05.20.28.36;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2003.09.05.10.03.18;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2003.09.01.20.06.02;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2003.08.21.20.45.43;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2003.08.13.08.52.44;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2003.08.11.20.45.17;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2003.08.03.23.34.09;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2003.01.14.03.20.16;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2003.01.13.20.12.18;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2002.12.14.07.42.13;	author fgsch;	state Exp;
branches;
next	1.26;

1.26
date	2001.12.22.17.57.10;	author smurph;	state Exp;
branches;
next	1.25;

1.25
date	2001.12.19.07.04.41;	author smurph;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2001.12.16.23.49.46;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2001.12.14.08.52.00;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2001.12.14.04.30.11;	author smurph;	state Exp;
branches;
next	1.21;

1.21
date	2001.12.14.02.11.45;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2001.12.14.01.37.56;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2001.12.13.08.55.51;	author smurph;	state Exp;
branches;
next	1.18;

1.18
date	2001.11.27.05.26.36;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.18.01.43.33;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2001.09.20.17.02.31;	author mpech;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.24.22.53.14;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.12.12.03.02;	author heko;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.20.05.53.09;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.09.05.44.41;	author smurph;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.07.23.40.35;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.01.03.38.19;	author smurph;	state Exp;
branches;
next	1.9;

1.9
date	2000.12.28.21.21.24;	author smurph;	state Exp;
branches;
next	1.8;

1.8
date	99.09.27.19.13.21;	author smurph;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	99.05.29.04.41.46;	author smurph;	state Exp;
branches;
next	1.6;

1.6
date	99.02.09.06.36.28;	author smurph;	state Exp;
branches;
next	1.5;

1.5
date	98.12.15.05.11.01;	author smurph;	state Exp;
branches;
next	1.4;

1.4
date	97.05.24.03.02.30;	author rahnds;	state Exp;
branches;
next	1.3;

1.3
date	97.03.03.20.21.33;	author rahnds;	state Exp;
branches;
next	1.2;

1.2
date	97.03.03.19.08.02;	author rahnds;	state dead;
branches;
next	1.1;

1.1
date	95.10.18.12.32.21;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.03.03.19.32.10;	author rahnds;	state Exp;
branches;
next	;

1.8.4.1
date	2001.04.18.16.11.32;	author niklas;	state Exp;
branches;
next	1.8.4.2;

1.8.4.2
date	2001.07.04.10.20.09;	author niklas;	state Exp;
branches;
next	1.8.4.3;

1.8.4.3
date	2001.10.31.03.01.19;	author nate;	state Exp;
branches;
next	1.8.4.4;

1.8.4.4
date	2001.12.05.00.39.12;	author niklas;	state Exp;
branches;
next	1.8.4.5;

1.8.4.5
date	2002.03.06.02.04.44;	author niklas;	state Exp;
branches;
next	1.8.4.6;

1.8.4.6
date	2003.03.27.23.32.18;	author niklas;	state Exp;
branches;
next	1.8.4.7;

1.8.4.7
date	2004.02.19.10.49.07;	author niklas;	state Exp;
branches;
next	;

1.25.2.1
date	2002.01.31.22.55.18;	author niklas;	state Exp;
branches;
next	1.25.2.2;

1.25.2.2
date	2003.05.19.21.45.53;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.71
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: eh.S,v 1.70 2013/05/17 22:51:59 miod Exp $	*/
/*
 * Copyright (c) 2006, Miodrag Vallat
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <machine/m8820x.h>

/*
 * Save Pbus fault status register from data and inst CMMU.
 *
 * Handlers are invoked with TMP, TMP2 and TMP3 available, and TMP contains
 * curcpu().
 */

#define	PFSR_SAVE \
	NOP;	/* will be changed to	br.n pfsr_handler + 4*/ \
	NOP	/* will be changed to	 first instruction of pfsr_handler */

#include <m88k/m88k/eh_common.S>

#if defined(MVME181) || defined(MVME187)
/*
 * Single-processor with 2 CMMU version (MVME181, MVME187, MVME8120)
 */

ENTRY(pfsr_save_single)
	ld	TMP2, TMP,  CI_PFSR_I0
	ld	TMP3, TMP2, %r0
	st	TMP3, %r31, EF_IPFSR
	ld	TMP2, TMP,  CI_PFSR_D0
	ld	TMP3, TMP2, %r0
	br.n	_ASM_LABEL(pfsr_done)
	 st	TMP3, %r31, EF_DPFSR
#endif

#ifdef MVME188
/*
 * MVME188 versions
 */

#include <machine/mvme188.h>

ENTRY(pfsr_save_188_quad)
	/*
	 * We're in configuration 2 (1 CPU, 8 CMMU).
	 *
	 * Reading the MVME188 error register could tell us which
	 * CMMU faulted, but it's easier to check every one until
	 * we find the first fault.
	 *
	 * If two or more CMMU faulted simultaneously, restarting from
	 * the trap will fault again, and we'll handle the remaining
	 * exceptions here.
	 *
	 * However, to be sure we don't get fooled with already-processed
	 * exceptions, we have to reset the fault status registers
	 * after reading them.
	 *
	 * XXX It will probably be worth changing this so that we can
	 * handle a bunch of CMMU faults at once in trap.c.
	 */
	or.u	TMP,  %r0,  %hi16(VME_CMMU_I0)
	ld	TMP2, TMP,  %lo16(VME_CMMU_I0) + CMMU_PFSR * 4
	extu	TMP3, TMP2, 3<16>
	bcnd.n	ne0,  TMP3, 1f
	 st	%r0,  TMP,  %lo16(VME_CMMU_I0) + CMMU_PFSR * 4
	or.u	TMP,  %r0,  %hi16(VME_CMMU_I1)
	ld	TMP2, TMP,  %lo16(VME_CMMU_I1) + CMMU_PFSR * 4
	extu	TMP3, TMP2, 3<16>
	bcnd.n	ne0,  TMP3, 1f
	 st	%r0,  TMP,  %lo16(VME_CMMU_I1) + CMMU_PFSR * 4
	or.u	TMP,  %r0,  %hi16(VME_CMMU_I2)
	ld	TMP2, TMP,  %lo16(VME_CMMU_I2) + CMMU_PFSR * 4
	extu	TMP3, TMP2, 3<16>
	bcnd.n	ne0,  TMP3, 1f
	 st	%r0,  TMP,  %lo16(VME_CMMU_I2) + CMMU_PFSR * 4
	or.u	TMP,  %r0,  %hi16(VME_CMMU_I3)
	ld	TMP2, TMP,  %lo16(VME_CMMU_I3) + CMMU_PFSR * 4
	st	%r0,  TMP,  %lo16(VME_CMMU_I3) + CMMU_PFSR * 4
1:
	st	TMP2, %r31, EF_IPFSR
	
	or.u	TMP,  %r0,  %hi16(VME_CMMU_D0)
	ld	TMP2, TMP,  %lo16(VME_CMMU_D0) + CMMU_PFSR * 4
	extu	TMP3, TMP2, 3<16>
	bcnd.n	ne0,  TMP3, 2f
	 st	%r0,  TMP,  %lo16(VME_CMMU_D0) + CMMU_PFSR * 4
	or.u	TMP,  %r0,  %hi16(VME_CMMU_D1)
	ld	TMP2, TMP,  %lo16(VME_CMMU_D1) + CMMU_PFSR * 4
	extu	TMP3, TMP2, 3<16>
	bcnd.n	ne0,  TMP3, 2f
	 st	%r0,  TMP,  %lo16(VME_CMMU_D1) + CMMU_PFSR * 4
	or.u	TMP,  %r0,  %hi16(VME_CMMU_D2)
	ld	TMP2, TMP,  %lo16(VME_CMMU_D2) + CMMU_PFSR * 4
	extu	TMP3, TMP2, 3<16>
	bcnd.n	ne0,  TMP3, 2f
	 st	%r0,  TMP,  %lo16(VME_CMMU_D2) + CMMU_PFSR * 4
	or.u	TMP,  %r0,  %hi16(VME_CMMU_D3)
	ld	TMP2, TMP,  %lo16(VME_CMMU_D3) + CMMU_PFSR * 4
	st	%r0,  TMP,  %lo16(VME_CMMU_D3) + CMMU_PFSR * 4
2:
	br.n	_ASM_LABEL(pfsr_done)
	 st	TMP2, %r31, EF_DPFSR

ENTRY(pfsr_save_188_double)
	/*
	 * 4 CMMUs per CPU. Almost as simple as the 2 CMMUs per CPU
	 * situation...
	 *
	 * However, to be sure we don't get fooled with already-processed
	 * exceptions, we have to reset the fault status registers
	 * after reading them.
	 */
	ld	TMP2, TMP,  CI_PFSR_I0
	ld	TMP3, TMP2, %r0
	extu	TMP3, TMP3, 3<16>
	bcnd	ne0,  TMP3, 1f
	st	%r0,  TMP2, %r0
	ld	TMP2, TMP,  CI_PFSR_I1
1:
	ld	TMP3, TMP2, %r0
	st	%r0,  TMP2, %r0
	st	TMP3, %r31, EF_IPFSR

	ld	TMP2, TMP,  CI_PFSR_D0
	ld	TMP3, TMP2, %r0
	extu	TMP3, TMP3, 3<16>
	bcnd	ne0,  TMP3, 2f
	st	%r0,  TMP2, %r0
	ld	TMP2, TMP,  CI_PFSR_D1
2:
	ld	TMP3, TMP2, %r0
	st	%r0,  TMP2, %r0
	br.n	_ASM_LABEL(pfsr_done)
	 st	TMP3, %r31, EF_DPFSR

ENTRY(pfsr_save_188_straight)
	/*
	 * We have the simple 2 CMMUs per CPU mapping. Pick our couple;
	 * no need to reset fault status registers in this case.
	 * This is similar to the 187/8120 code.
	 */
	ld	TMP2, TMP,  CI_PFSR_I0
	ld	TMP3, TMP2, %r0
	st	TMP3, %r31, EF_IPFSR
	ld	TMP2, TMP,  CI_PFSR_D0
	ld	TMP3, TMP2, %r0
	br.n	_ASM_LABEL(pfsr_done)
	 st	TMP3, %r31,  EF_DPFSR

#endif	/* MVME188 */
@


1.70
log
@Preliminary support for MVME180 and MVME181 boards. On-board serial ports
and VME controller are supported; tod chip isn't supported yet (coming soon).
MVME236 memory boards are not supported and won't likely be (unless I get my
hands on one).

MVME181-1 boots multiuser (slowly) with MVME328 SCSI and MVME376 Ethernet
despite only having 8MB of memory onboard.

MVME180 untested; might need tweaking to get MVME SCSI and Ethernet boards
supported.

Many thanks to Matti Nummi for lending me an MVME181 board.
@
text
@d1 1
a1 1
/*	$OpenBSD: eh.S,v 1.69 2013/05/17 22:46:28 miod Exp $	*/
@


1.69
log
@Replace the bunch of md_* function pointers with a `struct board' containing
function pointers for all the board-specific code.

Add a bunch of `struct board' methods to cover most, if not all, of the
`per-board' logic. This allows most of the md drivers to be cleaned up and
no longer need to embed board-specific knowledge.
@
text
@d1 1
a1 1
/*	$OpenBSD: eh.S,v 1.68 2013/01/05 11:20:56 miod Exp $	*/
d42 1
a42 1
#ifdef MVME187
@


1.68
log
@Switch m88k ports to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: eh.S,v 1.67 2007/12/21 23:56:54 miod Exp $	*/
d44 1
a44 1
 * Single-processor SBC version (MVME187, MVME8120)
d47 1
a47 3
#include <machine/mvme187.h>

ENTRY(pfsr_save_187)
@


1.67
log
@Change the EF_xxx constants to be real offsets within the trapframe, instead
of offsets / sizeof(register_t), and nuke the REG_OFF macro. No functional
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: eh.S,v 1.66 2006/11/19 11:08:55 miod Exp $	*/
d51 2
a52 2
	ld	TMP3, TMP2, r0
	st	TMP3, r31,  EF_IPFSR
d54 1
a54 1
	ld	TMP3, TMP2, r0
d56 1
a56 1
	 st	TMP3, r31,  EF_DPFSR
d85 2
a86 2
	or.u	TMP,  r0,   hi16(VME_CMMU_I0)
	ld	TMP2, TMP,  lo16(VME_CMMU_I0) + CMMU_PFSR * 4
d89 3
a91 3
	 st	r0,   TMP,  lo16(VME_CMMU_I0) + CMMU_PFSR * 4
	or.u	TMP,  r0,   hi16(VME_CMMU_I1)
	ld	TMP2, TMP,  lo16(VME_CMMU_I1) + CMMU_PFSR * 4
d94 3
a96 3
	 st	r0,   TMP,  lo16(VME_CMMU_I1) + CMMU_PFSR * 4
	or.u	TMP,  r0,   hi16(VME_CMMU_I2)
	ld	TMP2, TMP,  lo16(VME_CMMU_I2) + CMMU_PFSR * 4
d99 4
a102 4
	 st	r0,   TMP,  lo16(VME_CMMU_I2) + CMMU_PFSR * 4
	or.u	TMP,  r0,   hi16(VME_CMMU_I3)
	ld	TMP2, TMP,  lo16(VME_CMMU_I3) + CMMU_PFSR * 4
	st	r0,   TMP,  lo16(VME_CMMU_I3) + CMMU_PFSR * 4
d104 1
a104 1
	st	TMP2, r31,  EF_IPFSR
d106 2
a107 2
	or.u	TMP,  r0,   hi16(VME_CMMU_D0)
	ld	TMP2, TMP,  lo16(VME_CMMU_D0) + CMMU_PFSR * 4
d110 3
a112 3
	 st	r0,   TMP,  lo16(VME_CMMU_D0) + CMMU_PFSR * 4
	or.u	TMP,  r0,   hi16(VME_CMMU_D1)
	ld	TMP2, TMP,  lo16(VME_CMMU_D1) + CMMU_PFSR * 4
d115 3
a117 3
	 st	r0,   TMP,  lo16(VME_CMMU_D1) + CMMU_PFSR * 4
	or.u	TMP,  r0,   hi16(VME_CMMU_D2)
	ld	TMP2, TMP,  lo16(VME_CMMU_D2) + CMMU_PFSR * 4
d120 4
a123 4
	 st	r0,   TMP,  lo16(VME_CMMU_D2) + CMMU_PFSR * 4
	or.u	TMP,  r0,   hi16(VME_CMMU_D3)
	ld	TMP2, TMP,  lo16(VME_CMMU_D3) + CMMU_PFSR * 4
	st	r0,   TMP,  lo16(VME_CMMU_D3) + CMMU_PFSR * 4
d126 1
a126 1
	 st	TMP2, r31,  EF_DPFSR
d138 1
a138 1
	ld	TMP3, TMP2, r0
d141 1
a141 1
	st	r0,   TMP2, r0
d144 3
a146 3
	ld	TMP3, TMP2, r0
	st	r0,   TMP2, r0
	st	TMP3, r31,  EF_IPFSR
d149 1
a149 1
	ld	TMP3, TMP2, r0
d152 1
a152 1
	st	r0,   TMP2, r0
d155 2
a156 2
	ld	TMP3, TMP2, r0
	st	r0,   TMP2, r0
d158 1
a158 1
	 st	TMP3, r31,  EF_DPFSR
d167 2
a168 2
	ld	TMP3, TMP2, r0
	st	TMP3, r31,  EF_IPFSR
d170 1
a170 1
	ld	TMP3, TMP2, r0
d172 1
a172 1
	 st	TMP3, r31,  EF_DPFSR
@


1.66
log
@I completely broke pfsr_188_save_double when introducing per-cpuinfo
pfsr pointers seven months ago. This would work, but not in all fault cases;
now it does the right thing.
@
text
@d1 1
a1 1
/*	$OpenBSD: eh.S,v 1.65 2006/11/18 22:53:11 miod Exp $	*/
d52 1
a52 1
	st	TMP3, r31,  REG_OFF(EF_IPFSR)
d56 1
a56 1
	 st	TMP3, r31,  REG_OFF(EF_DPFSR)
d86 1
a86 1
	ld	TMP2, TMP,  lo16(VME_CMMU_I0) + REG_OFF(CMMU_PFSR)
d89 1
a89 1
	 st	r0,   TMP,  lo16(VME_CMMU_I0) + REG_OFF(CMMU_PFSR)
d91 1
a91 1
	ld	TMP2, TMP,  lo16(VME_CMMU_I1) + REG_OFF(CMMU_PFSR)
d94 1
a94 1
	 st	r0,   TMP,  lo16(VME_CMMU_I1) + REG_OFF(CMMU_PFSR)
d96 1
a96 1
	ld	TMP2, TMP,  lo16(VME_CMMU_I2) + REG_OFF(CMMU_PFSR)
d99 1
a99 1
	 st	r0,   TMP,  lo16(VME_CMMU_I2) + REG_OFF(CMMU_PFSR)
d101 2
a102 2
	ld	TMP2, TMP,  lo16(VME_CMMU_I3) + REG_OFF(CMMU_PFSR)
	st	r0,   TMP,  lo16(VME_CMMU_I3) + REG_OFF(CMMU_PFSR)
d104 1
a104 1
	st	TMP2, r31,  REG_OFF(EF_IPFSR)
d107 1
a107 1
	ld	TMP2, TMP,  lo16(VME_CMMU_D0) + REG_OFF(CMMU_PFSR)
d110 1
a110 1
	 st	r0,   TMP,  lo16(VME_CMMU_D0) + REG_OFF(CMMU_PFSR)
d112 1
a112 1
	ld	TMP2, TMP,  lo16(VME_CMMU_D1) + REG_OFF(CMMU_PFSR)
d115 1
a115 1
	 st	r0,   TMP,  lo16(VME_CMMU_D1) + REG_OFF(CMMU_PFSR)
d117 1
a117 1
	ld	TMP2, TMP,  lo16(VME_CMMU_D2) + REG_OFF(CMMU_PFSR)
d120 1
a120 1
	 st	r0,   TMP,  lo16(VME_CMMU_D2) + REG_OFF(CMMU_PFSR)
d122 2
a123 2
	ld	TMP2, TMP,  lo16(VME_CMMU_D3) + REG_OFF(CMMU_PFSR)
	st	r0,   TMP,  lo16(VME_CMMU_D3) + REG_OFF(CMMU_PFSR)
d126 1
a126 1
	 st	TMP2, r31,  REG_OFF(EF_DPFSR)
d146 1
a146 1
	st	TMP3, r31,  REG_OFF(EF_IPFSR)
d158 1
a158 1
	 st	TMP3, r31,  REG_OFF(EF_DPFSR)
d168 1
a168 1
	st	TMP3, r31,  REG_OFF(EF_IPFSR)
d172 1
a172 1
	 st	TMP3, r31,  REG_OFF(EF_DPFSR)
@


1.65
log
@Rework the PFSR register analysis code on mvme88k: split it into four
independent subfunctions, turn PFSR_SAVE into a couple of NOP, and replace
them early at runtime with a branch to the selected routine, which will
return to pfsr_save.
This is really better for 188 systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: eh.S,v 1.64 2006/04/17 16:08:01 miod Exp $	*/
d138 4
a141 4
	ld	TMP2, TMP2, r0
	extu	TMP3, TMP2, 3<16>
	bcnd.n	ne0,  TMP3, 1f
	 st	r0,   TMP2, r0
d143 2
a144 1
	ld	TMP2, TMP2, r0
d146 1
a146 2
1:
	st	TMP2, r31,  REG_OFF(EF_IPFSR)
d149 4
a152 4
	ld	TMP2, TMP2, r0
	extu	TMP3, TMP2, 3<16>
	bcnd.n	ne0,  TMP3, 2f
	 st	r0,   TMP2, r0
d154 2
a155 1
	ld	TMP2, TMP2, r0
a156 1
2:
d158 1
a158 1
	 st	TMP2, r31,  REG_OFF(EF_DPFSR)
@


1.64
log
@Save pointers to up to four CMMU PFSR registers into the cpu_info structure.
This allows the exception handling code to skip the PFSR address computations.

The net result is that the PFSR_SAVE code becomes much simpler and smaller,
and that all processors will now spend time in PFSR_SAVE - previously, cpu0
was favored and other processors took a bit more time.

Note that 8:1 configurations do not use these fields - but then this is a
fixed monoprocessor configuration, for which the existing code was already
doing The Right Thing.

Tested on luna88k (2:1) by aoyama@@, and on mvme88k (2:1 and 4:1) by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: eh.S,v 1.63 2005/12/03 14:30:06 miod Exp $	*/
d32 1
a32 1
 * PFSR_SAVE is invoked with TMP, TMP2 and TMP3 available, and TMP contains
d36 7
a46 1
#ifdef MVME187
a47 10
#define	PFSR_SAVE_187 \
	ld	TMP2, TMP,  CI_PFSR_I0; \
	ld	TMP3, TMP2, r0; \
	st	TMP3, r31,  REG_OFF(EF_IPFSR); \
	ld	TMP2, TMP,  CI_PFSR_D0; \
	ld	TMP3, TMP2, r0; \
	st	TMP3, r31,  REG_OFF(EF_DPFSR);
#else
#define	PFSR_SAVE_187
#endif
d49 8
a56 23
/*
 * MVME188 version (see pfsr188 below)
 */
#ifdef MVME188
#define	PFSR_SAVE_188 \
	br	_ASM_LABEL(pfsr188);
#else
#define	PFSR_SAVE_188
#endif


#if defined(MVME187) && defined(MVME188)
#define	PFSR_SAVE \
	/* check if it's a mvme188 */ \
	or.u	TMP3, r0,   hi16(_C_LABEL(brdtyp)); \
	ld	TMP2, TMP3, lo16(_C_LABEL(brdtyp)); \
	cmp	TMP3, TMP2, BRD_188; \
	bb1	eq,   TMP3, _ASM_LABEL(pfsr188); \
	PFSR_SAVE_187
#else
#define	PFSR_SAVE \
	PFSR_SAVE_188 \
	PFSR_SAVE_187
a58 2
#include <m88k/m88k/eh_common.S>

a59 1
#include <machine/mvme188.h>
d61 1
a61 5
 * Handling faults can be very tricky, as it is necessary to check all
 * the CMMUs of the faulting processor.
 *
 * This implementation tries to favor, speedwise, simple (2 CMMUs per CPU)
 * configurations over any other configuration.
a62 1
	text
d64 1
a64 6
ASLOCAL(pfsr188)
	or.u	TMP2, r0,   hi16(_C_LABEL(cmmu_shift))
	ld	TMP2, TMP2, lo16(_C_LABEL(cmmu_shift))
	cmp	TMP3, TMP2, 2
	bb1	lt,   TMP3, _ASM_LABEL(pfsr188_straight)
	bb1	eq,   TMP2, _ASM_LABEL(pfsr188_double)
d66 1
a66 1
ASLOCAL(pfsr188_quad)
d128 1
a128 1
ASLOCAL(pfsr188_double)
a136 1

d160 1
a160 1
ASLOCAL(pfsr188_straight)
d173 2
a174 1
#endif
@


1.63
log
@Switch m88k ports to __HAVE_CPUINFO. Current cpu pointer is held in SR0
on all running processors.
Tested aoyama@@ and I
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.62 2004/08/05 21:34:11 miod Exp $   */
d3 1
a3 6
 * Mach Operating System
 * Copyright (c) 1993-1991 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * Copyright (c) 1996 Nivas Madhur
 * Copyright (c) 1998 Steve Murphree, Jr.
 * All Rights Reserved.
d5 20
a24 19
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON AND OMRON ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON AND OMRON DISCLAIM ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
d31 3
d43 6
a48 6
	or.u	TMP,  r0,   hi16(SBC_CMMU_I); \
	ld	TMP2, TMP,  lo16(SBC_CMMU_I) + REG_OFF(CMMU_PFSR); \
	st	TMP2, r31,  REG_OFF(EF_IPFSR); \
	or.u	TMP,  r0,   hi16(SBC_CMMU_D); \
	ld	TMP2, TMP,  lo16(SBC_CMMU_D) + REG_OFF(CMMU_PFSR); \
	st	TMP2, r31,  REG_OFF(EF_DPFSR);
d67 4
a70 4
	or.u	TMP,  r0,   hi16(_C_LABEL(brdtyp)); \
	ld	TMP2, TMP,  lo16(_C_LABEL(brdtyp)); \
	cmp	TMP,  TMP2, BRD_188; \
	bb1	eq,   TMP,  _ASM_LABEL(pfsr188); \
d86 2
a87 3
 * This implementation tries to favor, speedwise:
 * - simple (2 CMMUs per CPU) configurations over any other configuration;
 * - faults on CPU0 over the other CPUs.
d92 4
a95 6
	or.u	TMP,  r0,   hi16(_C_LABEL(cmmu_shift))
	ld	TMP,  TMP,  lo16(_C_LABEL(cmmu_shift))
	cmp	TMP2, TMP,  2
	ldcr	TMP,  CPU
	bb1.n	lt,   TMP2, _ASM_LABEL(pfsr188_straight)
	 ld	TMP,  TMP,  CI_CPUID			/* TMP = cpu# */
a168 25
	bcnd	ne0,  TMP,  5f

	/* CPU 0 -> CMMU 0 and 1 */
	or.u	TMP,  r0,   hi16(VME_CMMU_I0)
	ld	TMP2, TMP,  lo16(VME_CMMU_I0) + REG_OFF(CMMU_PFSR)
	extu	TMP3, TMP2, 3<16>
	bcnd.n	ne0,  TMP3, 1f
	 st	r0,   TMP,  lo16(VME_CMMU_I0) + REG_OFF(CMMU_PFSR)
	or.u	TMP,  r0,   hi16(VME_CMMU_I1)
	ld	TMP2, TMP,  lo16(VME_CMMU_I1) + REG_OFF(CMMU_PFSR)
	st	r0,   TMP,  lo16(VME_CMMU_I1) + REG_OFF(CMMU_PFSR)
1:
	st	TMP2, r31,  REG_OFF(EF_IPFSR)

	or.u	TMP,  r0,   hi16(VME_CMMU_D0)
	ld	TMP2, TMP,  lo16(VME_CMMU_D0) + REG_OFF(CMMU_PFSR)
	extu	TMP3, TMP2, 3<16>
	bcnd.n	ne0,  TMP3, 2f
	 st	r0,   TMP,  lo16(VME_CMMU_D0) + REG_OFF(CMMU_PFSR)
	or.u	TMP,  r0,   hi16(VME_CMMU_D1)
	ld	TMP2, TMP,  lo16(VME_CMMU_D1) + REG_OFF(CMMU_PFSR)
	st	r0,   TMP,  lo16(VME_CMMU_D1) + REG_OFF(CMMU_PFSR)
2:
	br.n	_ASM_LABEL(pfsr_done)
	 st	TMP2, r31,  REG_OFF(EF_DPFSR)
d170 2
a171 4
5:
	/* CPU 1 -> CMMU 2 and 3 */
	or.u	TMP,  r0,   hi16(VME_CMMU_I2)
	ld	TMP2, TMP,  lo16(VME_CMMU_I2) + REG_OFF(CMMU_PFSR)
d174 4
a177 4
	 st	r0,   TMP,  lo16(VME_CMMU_I2) + REG_OFF(CMMU_PFSR)
	or.u	TMP,  r0,   hi16(VME_CMMU_I3)
	ld	TMP2, TMP,  lo16(VME_CMMU_I3) + REG_OFF(CMMU_PFSR)
	st	r0,   TMP,  lo16(VME_CMMU_I3) + REG_OFF(CMMU_PFSR)
d181 2
a182 2
	or.u	TMP,  r0,   hi16(VME_CMMU_D2)
	ld	TMP2, TMP,  lo16(VME_CMMU_D2) + REG_OFF(CMMU_PFSR)
d185 4
a188 4
	 st	r0,   TMP,  lo16(VME_CMMU_D2) + REG_OFF(CMMU_PFSR)
	or.u	TMP,  r0,   hi16(VME_CMMU_D3)
	ld	TMP2, TMP,  lo16(VME_CMMU_D3) + REG_OFF(CMMU_PFSR)
	st	r0,   TMP,  lo16(VME_CMMU_D3) + REG_OFF(CMMU_PFSR)
d197 1
d199 5
a203 29
	bcnd	eq0,  TMP,  1f	/* CPU0 */
	cmp	TMP2, TMP, 0x2
	bb1	lt,   TMP2, 2f	/* CPU1 */
	bb1	eq,   TMP2, 3f	/* CPU2 */

	/* must be CPU3 */
	or.u	TMP,  r0,   hi16(VME_CMMU_I3)
	ld	TMP2, TMP,  lo16(VME_CMMU_I3) + REG_OFF(CMMU_PFSR)
	st	TMP2, r31,  REG_OFF(EF_IPFSR)
	or.u	TMP,  r0,   hi16(VME_CMMU_D3)
	ld	TMP2, TMP,  lo16(VME_CMMU_D3) + REG_OFF(CMMU_PFSR)
	br.n	_ASM_LABEL(pfsr_done)
	 st	TMP2, r31,  REG_OFF(EF_DPFSR)
1:
	/* must be CPU0 */
	or.u	TMP,  r0,   hi16(VME_CMMU_I0)
	ld	TMP2, TMP,  lo16(VME_CMMU_I0) + REG_OFF(CMMU_PFSR)
	st	TMP2, r31,  REG_OFF(EF_IPFSR)
	or.u	TMP,  r0,   hi16(VME_CMMU_D0)
	ld	TMP2, TMP,  lo16(VME_CMMU_D0) + REG_OFF(CMMU_PFSR)
	br.n	_ASM_LABEL(pfsr_done)
	 st	TMP2, r31,  REG_OFF(EF_DPFSR)
2:
	/* must be CPU1 */
	or.u	TMP,  r0,   hi16(VME_CMMU_I1)
	ld	TMP2, TMP,  lo16(VME_CMMU_I1) + REG_OFF(CMMU_PFSR)
	st	TMP2, r31,  REG_OFF(EF_IPFSR)
	or.u	TMP,  r0,   hi16(VME_CMMU_D1)
	ld	TMP2, TMP,  lo16(VME_CMMU_D1) + REG_OFF(CMMU_PFSR)
d205 1
a205 10
	 st	TMP2, r31,  REG_OFF(EF_DPFSR)
3:
	/* must be CPU2 */
	or.u	TMP,  r0,   hi16(VME_CMMU_I2)
	ld	TMP2, TMP,  lo16(VME_CMMU_I2) + REG_OFF(CMMU_PFSR)
	st	TMP2, r31,  REG_OFF(EF_IPFSR)
	or.u	TMP,  r0,   hi16(VME_CMMU_D2)
	ld	TMP2, TMP,  lo16(VME_CMMU_D2) + REG_OFF(CMMU_PFSR)
	br.n	_ASM_LABEL(pfsr_done)
	 st	TMP2, r31,  REG_OFF(EF_DPFSR)
@


1.62
log
@Unbreak luna88k; spotted by aoyama@@
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.61 2004/08/04 22:03:45 miod Exp $   */
d97 1
d99 1
a99 1
	 extu	TMP,  FLAGS, FLAG_CPU_FIELD_WIDTH<0>	/* TMP = cpu# */
@


1.61
log
@Use the ad hoc register define to access the Pbus fault status register,
rather than an ugly 0x108.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.60 2004/08/03 21:15:38 miod Exp $   */
d30 2
@


1.60
log
@Clear CMMU fault status registers after reading them, for 4:1 and 8:1
MVME188 configurations.  Thus, we are looking at valid values when electing
the faulting CMMU.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.59 2004/08/02 22:16:43 miod Exp $   */
d43 1
a43 1
	ld	TMP2, TMP,  lo16(SBC_CMMU_I) + 0x108; \
d46 1
a46 1
	ld	TMP2, TMP,  lo16(SBC_CMMU_D) + 0x108; \
d119 1
a119 1
	ld	TMP2, TMP,  lo16(VME_CMMU_I0) + 0x108
d122 1
a122 1
	 st	r0,   TMP,  lo16(VME_CMMU_I0) + 0x108
d124 1
a124 1
	ld	TMP2, TMP,  lo16(VME_CMMU_I1) + 0x108
d127 1
a127 1
	 st	r0,   TMP,  lo16(VME_CMMU_I1) + 0x108
d129 1
a129 1
	ld	TMP2, TMP,  lo16(VME_CMMU_I2) + 0x108
d132 1
a132 1
	 st	r0,   TMP,  lo16(VME_CMMU_I2) + 0x108
d134 2
a135 2
	ld	TMP2, TMP,  lo16(VME_CMMU_I3) + 0x108
	st	r0,   TMP,  lo16(VME_CMMU_I3) + 0x108
d140 1
a140 1
	ld	TMP2, TMP,  lo16(VME_CMMU_D0) + 0x108
d143 1
a143 1
	 st	r0,   TMP,  lo16(VME_CMMU_D0) + 0x108
d145 1
a145 1
	ld	TMP2, TMP,  lo16(VME_CMMU_D1) + 0x108
d148 1
a148 1
	 st	r0,   TMP,  lo16(VME_CMMU_D1) + 0x108
d150 1
a150 1
	ld	TMP2, TMP,  lo16(VME_CMMU_D2) + 0x108
d153 1
a153 1
	 st	r0,   TMP,  lo16(VME_CMMU_D2) + 0x108
d155 2
a156 2
	ld	TMP2, TMP,  lo16(VME_CMMU_D3) + 0x108
	st	r0,   TMP,  lo16(VME_CMMU_D3) + 0x108
d174 1
a174 1
	ld	TMP2, TMP,  lo16(VME_CMMU_I0) + 0x108
d177 1
a177 1
	 st	r0,   TMP,  lo16(VME_CMMU_I0) + 0x108
d179 2
a180 2
	ld	TMP2, TMP,  lo16(VME_CMMU_I1) + 0x108
	st	r0,   TMP,  lo16(VME_CMMU_I1) + 0x108
d185 1
a185 1
	ld	TMP2, TMP,  lo16(VME_CMMU_D0) + 0x108
d188 1
a188 1
	 st	r0,   TMP,  lo16(VME_CMMU_D0) + 0x108
d190 2
a191 2
	ld	TMP2, TMP,  lo16(VME_CMMU_D1) + 0x108
	st	r0,   TMP,  lo16(VME_CMMU_D1) + 0x108
d199 1
a199 1
	ld	TMP2, TMP,  lo16(VME_CMMU_I2) + 0x108
d202 1
a202 1
	 st	r0,   TMP,  lo16(VME_CMMU_I2) + 0x108
d204 2
a205 2
	ld	TMP2, TMP,  lo16(VME_CMMU_I3) + 0x108
	st	r0,   TMP,  lo16(VME_CMMU_I3) + 0x108
d210 1
a210 1
	ld	TMP2, TMP,  lo16(VME_CMMU_D2) + 0x108
d213 1
a213 1
	 st	r0,   TMP,  lo16(VME_CMMU_D2) + 0x108
d215 2
a216 2
	ld	TMP2, TMP,  lo16(VME_CMMU_D3) + 0x108
	st	r0,   TMP,  lo16(VME_CMMU_D3) + 0x108
d233 1
a233 1
	ld	TMP2, TMP,  lo16(VME_CMMU_I3) + 0x108
d236 1
a236 1
	ld	TMP2, TMP,  lo16(VME_CMMU_D3) + 0x108
d242 1
a242 1
	ld	TMP2, TMP,  lo16(VME_CMMU_I0) + 0x108
d245 1
a245 1
	ld	TMP2, TMP,  lo16(VME_CMMU_D0) + 0x108
d251 1
a251 1
	ld	TMP2, TMP,  lo16(VME_CMMU_I1) + 0x108
d254 1
a254 1
	ld	TMP2, TMP,  lo16(VME_CMMU_D1) + 0x108
d260 1
a260 1
	ld	TMP2, TMP,  lo16(VME_CMMU_I2) + 0x108
d263 1
a263 1
	ld	TMP2, TMP,  lo16(VME_CMMU_D2) + 0x108
@


1.59
log
@On MVME188 systems with 4:1 or 8:1 CMMU pairings, make sure the exception
handling code checks the error status of the correct CMMUs and really
reports an error code.

This gets us closer to getting these modules to work, at the expense of
sanity and some code readability.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.58 2004/08/02 08:35:00 miod Exp $   */
d111 4
d120 3
a122 2
	extu	TMP,  TMP2, 3<16>
	bcnd	ne0,  TMP,  1f
d125 3
a127 2
	extu	TMP,  TMP2, 3<16>
	bcnd	ne0,  TMP,  1f
d130 3
a132 2
	extu	TMP,  TMP2, 3<16>
	bcnd	ne0,  TMP,  1f
d135 1
d141 3
a143 2
	extu	TMP,  TMP2, 3<16>
	bcnd	ne0,  TMP,  2f
d146 3
a148 2
	extu	TMP,  TMP2, 3<16>
	bcnd	ne0,  TMP,  2f
d151 3
a153 2
	extu	TMP,  TMP2, 3<16>
	bcnd	ne0,  TMP,  2f
d156 1
d165 4
d175 3
a177 2
	extu	TMP,  TMP2, 3<16>
	bcnd	ne0,  TMP,  1f
d180 1
d186 3
a188 2
	extu	TMP,  TMP2, 3<16>
	bcnd	ne0,  TMP,  2f
d191 1
d200 3
a202 2
	extu	TMP,  TMP2, 3<16>
	bcnd	ne0,  TMP,  1f
d205 1
d211 3
a213 2
	extu	TMP,  TMP2, 3<16>
	bcnd	ne0,  TMP,  2f
d216 1
d223 2
a224 1
	 * We have the simple 2 CMMUs per CPU mapping. Pick our couple.
@


1.58
log
@More include files cleaning:
- move MAX_CPUS constant to <machine/cpu.h>
- do not include <machine/board.h> unless needed. In fact, remove this file
  entirely on mvme88k, and include <machine/mvme*.h> on a
  compiling-for-this-board basis
- keep MAX_CMMUS constant private to the m8820x code
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.57 2004/07/27 12:16:06 miod Exp $   */
d35 4
a38 1
/* Single-processor SBC version (MVME187, MVME8120) */
d52 3
a54 1
/* MVME188 version */
a55 1
#include <machine/mvme188.h>
d57 1
a57 45
	extu	TMP,  FLAGS, FLAG_CPU_FIELD_WIDTH<0>;	/* TMP = cpu# */ \
	cmp	TMP2, TMP, 0x0;				/* CPU0 ? */ \
	bb1	eq,   TMP2, 1f; \
	cmp	TMP2, TMP, 0x1;				/* CPU1 ? */ \
	bb1	eq,   TMP2, 2f; \
	cmp	TMP2, TMP, 0x2;				/* CPU2 ? */ \
	bb1	eq,   TMP2, 3f; \
	br	4f; \
	/* XXX WHAT ABOUT MODULES WITH SPLIT U/S CMMUS ??? */ \
1: \
	/* must be CPU0 */ \
	or.u	TMP,  r0,   hi16(VME_CMMU_I0); \
	ld	TMP2, TMP,  lo16(VME_CMMU_I0) + 0x108; \
	st	TMP2, r31,  REG_OFF(EF_IPFSR); \
	or.u	TMP,  r0,   hi16(VME_CMMU_D0); \
	ld	TMP2, TMP,  lo16(VME_CMMU_D0) + 0x108; \
	br.n	_ASM_LABEL(pfsr_done); \
	 st	TMP2, r31,  REG_OFF(EF_DPFSR); \
2: \
	/* must be CPU1 */ \
	or.u	TMP,  r0,   hi16(VME_CMMU_I1); \
	ld	TMP2, TMP,  lo16(VME_CMMU_I1) + 0x108; \
	st	TMP2, r31,  REG_OFF(EF_IPFSR); \
	or.u	TMP,  r0,   hi16(VME_CMMU_D1); \
	ld	TMP2, TMP,  lo16(VME_CMMU_D1) + 0x108; \
	br.n	_ASM_LABEL(pfsr_done); \
	 st	TMP2, r31,  REG_OFF(EF_DPFSR); \
3: \
	/* must be CPU2 */ \
	or.u	TMP,  r0,   hi16(VME_CMMU_I2); \
	ld	TMP2, TMP,  lo16(VME_CMMU_I2) + 0x108; \
	st	TMP2, r31,  REG_OFF(EF_IPFSR); \
	or.u	TMP,  r0,   hi16(VME_CMMU_D2); \
	ld	TMP2, TMP,  lo16(VME_CMMU_D2) + 0x108; \
	br.n	_ASM_LABEL(pfsr_done); \
	 st	TMP2, r31,  REG_OFF(EF_DPFSR); \
4: \
	/* must be CPU3 */ \
	or.u	TMP,  r0,   hi16(VME_CMMU_I3); \
	ld	TMP2, TMP,  lo16(VME_CMMU_I3) + 0x108; \
	st	TMP2, r31,  REG_OFF(EF_IPFSR); \
	or.u	TMP,  r0,   hi16(VME_CMMU_D3); \
	ld	TMP2, TMP,  lo16(VME_CMMU_D3) + 0x108; \
	br.n	_ASM_LABEL(pfsr_done); \
	 st	TMP2, r31,  REG_OFF(EF_DPFSR);
d62 1
d69 2
a70 3
	bb1	ne,   TMP,  9f; \
	PFSR_SAVE_188 \
9:	PFSR_SAVE_187
d78 164
@


1.57
log
@Factorize exception handling code. The only different part between luna88k
and mvme88k is the retrieval of the CMMU fault registers.

Tested on mvme88k by myself and luna88k by aoyama@@
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.56 2004/06/23 08:12:33 miod Exp $   */
d37 1
d51 1
@


1.56
log
@Assorted night cleanups:
- only compile debug and ddb-specific code if option DEBUG or option DDB.
- shorten code path in 88100 case.
- do not enable interrupts before the C handler is called, for the 88110
  NMI trap.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.55 2004/06/23 00:31:19 miod Exp $   */
d32 1
a32 166
 * In the following discussion, references are made to:
 *    MC88100 - RISC MICROPROCESSOR USER'S MANUAL
 * (second edition). Reference in []s refer to section numbers.
 *
 * This discussion assumes that you are at least vaguely familiar with 88100
 * exception handling (chapter 6), the MACH kernel, and that you have a brain
 * (and use it while reading this).
 *
 * I also assume (and hope) that you're not offended by frequent misspellings.
 *
 * Jeffrey Friedl
 * jfriedl@@rna.ncl.omron.co.jp
 * December, 1989
 *  -------------------------------------------------------------------
 *
 * EXCEPTIONS, INTERRUPTS, and TRAPS
 * ---------------------------------
 * This is the machine exception handler.
 * In the MC88100, various "conditions" cause an exception, where
 * processing momentarily jumps here to "service" the exception,
 * and then continues where it left off.
 *
 * There are a number of different types of exceptions.
 * For example, exception #6 is the privilege violation exception which
 * is raised when the user tries to execute a supervisor-only instruction.
 *
 * Exception #1 is the interrupt exception, and is raised when an
 * outside device raises the INT line on the CPU.  This happens,
 * for example, when the clock signals that it is time for a context
 * switch, or perhaps the disk drive signaling that some operation
 * is complete.
 *
 * Traps are also exceptions.  Traps are ways for user programs to request
 * kernel operations.  For example, "tcnd eq0, r0, 128" will raise
 * exception 128, the system call exception.
 *
 *
 * SERVICING AN EXCEPTION
 * -----------------------
 * When an exception occurs, each control register is saved in its
 * respective shadow register and execution continues from the
 * appropriate exception handler.  The exception handler must
 *      - save the context from the time of the exception
 *      - service the exception
 *      - restore the context (registers, etc)
 *      - pick up from where the exception occurred.
 *
 * The context is saved on a stack. Actually, in the user_state area
 * in the PCB if the exception happens in user mode.
 *
 * Servicing the exception is usually straightforward and in fact not dealt
 * with very much here.  Usually a C routine is called to handle it.
 * For example, when a privilege exception is raised, the routine that sends
 * an "illegal instruction" signal to the offending process is called.
 *
 * When the exception has been serviced, the context is restored from the
 * stack and execution resumes from where it left off.
 *
 * In more detail:
 *
 * Saving the exception-time context.
 * ---------------------------------
 *     In saving the exception-time context, we copy the shadow and general
 * purpose registers to memory.  Since one exception may occur while
 * servicing another, the memory used to save the exception-time context may
 * not be static (i.e. the same every time).  Thus, memory on a stack is set
 * aside for the exception frame (area where the exception-time context is
 * saved). The same stack is also used when C routines are called (to
 * service the exception).
 *
 *    Each process has a stack in kernel space (called the "kernel stack",
 * short for "process's kernel stack) as well as the user space stack.  When
 * entering the kernel from user space, the kernel stack is unused.  On this
 * stack we save the exception state and (most likely call a C routine to)
 * service the exception.
 *
 * Before servicing an exception, several issues must be addressed.
 *
 * 1) When an interrupt is recognized by the hardware, the data pipeline is
 *    allowed to clear.  However, if one of these data accesses faults (bad
 *    reference, or a reference to a page which needs to be swapped in), that
 *    reference, as well as any others in the pipeline at the time (at most
 *    three total) are left there, to be taken care of by the exception
 *    handler [6.4.1].  This involves swapping in the proper page and
 *    manually doing the appropriate load or store.
 *
 *    The other (at most, two other) data accesses that might have been in
 *    the pipeline must also be manually completed (even though they may not
 *    be at fault [yes, that's a bad pun, thank you]).
 *
 * 2) If any of the (at most three) uncompleted data access in the pipeline
 *    are loads (from memory to a register), then the bit for the destination
 *    register is set in the SSBR.  Since the hardware will never complete
 *    that load (since we do it manually), the hardware will never clear that
 *    SSBR bit.  Thus, we must clear it manually.  If this isn't done, the
 *    system will hang waiting for a bit to clear that will never.
 *
 * 3) If the exception is the privilege violation exception, the bounds
 *    violation exception, or the misaligned access exception, the
 *    destination register bit in the SSBR may need to be cleared.
 *
 * 4) If the exception is one of the floating exceptions, then the
 *    destination register for that floating process won't be written,
 *    and the SSBR must be cleared explicitly.
 *
 * 5) The FPU must be enabled (as it is disabled by the exception processing
 *    hardware) and allowed to complete actions in progress. This is so
 *    so that it may be used in the servicing of any instruction.
 *    When the FPU is being restarted, operations attempting to complete
 *    may themselves fault (raising another exception).
 *
 * More on Restarting the FPU
 * --------------------------
 *   The manual [section 6.4.3.4] gives only minor mention to this
 * rather complex task.  Before the FPU is restarted all SSBR bits are
 * cleared for actions that the exception handler completes (as mentioned
 * above) so that the SSBR is clear unless there are FPU operations that
 * have not actually been completed (and hence not written to the registers).
 * Also, all control registers (at least all those that we care about) are
 * saved to the stack exception frame before the FPU is restarted (this
 * is important... the reason comes later).
 *
 * The FPU is restarted by doing an rte to a trap-not-taken (the rte
 * actually enables the fpu because we ensure that the EPSR has the
 * FPU-enable bit on; the trap-not-taken ensures anything in the FPU
 * completes by waiting until scoreboard register is clear).
 *
 * At the time the FPU is restarted (the rte to the trap-not-taken) the FPU
 * can write to ANY of the general registers.  Thus, we must make sure that
 * all general registers (r1..r31) are in their pre-exception state so that
 * when saved to the exception frame after the FPU is enabled, they properly
 * reflect any changes made by the FPU in being restarted.
 *
 * Because we can't save the pointer to the exception frame in a general
 * register during the FPU restart (it could get overwritten by the FPU!),
 * we save it in a control register, SR3, during the restart.
 *
 *
 * HOWEVER .....
 *
 * Because other uncompleted actions in the FPU may fault when the FPU is
 * restarted, a new exception may be raised during the restart. This may
 * happen recursively a number of times. Thus, during a restart, ANY register
 * whatsoever may be modified, including control registers.  Because of this
 * we must make sure that the exception handler preserves SR3 throughout
 * servicing an exception so that, if the exception had been raised during
 * an FPU restart, it is returned unmolested when control returns to the FPU
 * restart.
 *
 * Thus: if an exception is from kernel space, we MUST preserve SR3.
 * (if it from user space, no FPU-enable can be in progress and SR3 is
 *  unimportant).
 *
 * Now is a good time to recap SR1..SR3 usage:
 *   SR1 - CPU flags (exception handler flags)
 *   SR2 - generally free
 *   SR3 - free only if the exception is from user mode
 *
 * Once the FPU has been restarted, the general registers are saved to the
 * exception frame.  If the exception is not the interrupt exception,
 * interrupts are enabled and any faulted data accesses (see above) are
 * serviced.  In either case, the exception is then serviced (usually by
 * calling a C routine).  After servicing, any faulted data accesses are
 * serviced (if it had been the interrupt exception).  The context is then
 * restored and control returns to where the exception occurred.
 *
d35 9
a43 412
#include "assym.h"

#include <machine/param.h>
#include <machine/asm.h>
#include <machine/board.h>
#ifdef MVME188
#include <machine/m8820x.h>
#endif
#include <machine/trap.h>

/*
 * The exception frame as defined in "machine/pcb.h" (among other places) is
 * a bit outdated and needs to be changed. Until then, we'll define some
 * pseudo-fields there for our needs.
 *
 * EF_SR3
 *   A place to save the exception-time SR3 from just after the
 *   time when an exception is raised until just after the FPU
 *   has been restarted.  This does not necessarly conflict with
 *   the general registers (though it can if you're not careful)
 *   and so we can use a spot later used to save a general register.
 *
 * EF_FLAGS
 *   This is just the old EF_MODE. "EF_MODE" isn't a very good name.
 */
#define	EF_SR3		(EF_R0 + 5)
#define	EF_FLAGS	EF_MODE

#ifdef DEBUG
	data
	align 4
ASLOCAL(sbadcpupanic)
	string	"eh.S: bad cpu number in FLAGS\000"

	text
	align 8
ASLOCAL(Lbadcpupanic)
	subu	r31, r31, 32
	or.u	r2, r0, hi16(_ASM_LABEL(sbadcpupanic))
	bsr.n	_C_LABEL(panic)
	 or	r2, r2, lo16(_ASM_LABEL(sbadcpupanic))
	addu	r31, r31, 32
#endif

	text
	align 8

#ifdef M88110
#define SAVE_CTX \
	stcr	r31, SRX			; \
	or.u	r31, r0,  hi16(_ASM_LABEL(save_frame))	; \
	or	r31, r31, lo16(_ASM_LABEL(save_frame))	; \
	/* save old R31 and other R registers */; \
	st.d	r0 , r31, GENREG_OFF(0)		; \
	st.d	r2 , r31, GENREG_OFF(2)		; \
	st.d	r4 , r31, GENREG_OFF(4)		; \
	st.d	r6 , r31, GENREG_OFF(6)		; \
	st.d	r8 , r31, GENREG_OFF(8)		; \
	st.d	r10, r31, GENREG_OFF(10)	; \
	st.d	r12, r31, GENREG_OFF(12)	; \
	st.d	r14, r31, GENREG_OFF(14)	; \
	st.d	r16, r31, GENREG_OFF(16)	; \
	st.d	r18, r31, GENREG_OFF(18)	; \
	st.d	r20, r31, GENREG_OFF(20)	; \
	st.d	r22, r31, GENREG_OFF(22)	; \
	st.d	r24, r31, GENREG_OFF(24)	; \
	st.d	r26, r31, GENREG_OFF(26)	; \
	st.d	r28, r31, GENREG_OFF(28)	; \
	st	r30, r31, GENREG_OFF(30)	; \
	ldcr	r1,  SRX			; \
	st	r1,  r31, GENREG_OFF(31)	; \
	ldcr	r1,  EPSR			; \
	ldcr	r2,  EXIP			; \
	ldcr	r3,  ENIP			; \
	st	r1,  r31, REG_OFF(EF_EPSR)	; \
	st	r2,  r31, REG_OFF(EF_EXIP)	; \
	st	r3,  r31, REG_OFF(EF_ENIP)	; \
	ldcr	r1,  DSR			; \
	ldcr	r2,  DLAR			; \
	ldcr	r3,  DPAR			; \
	st	r1,  r31, REG_OFF(EF_DSR)	; \
	st	r2,  r31, REG_OFF(EF_DLAR)	; \
	st	r3,  r31, REG_OFF(EF_DPAR)	; \
	ldcr	r1,  ISR			; \
	ldcr	r2,  ILAR			; \
	ldcr	r3,  IPAR			; \
	st	r1,  r31, REG_OFF(EF_ISR)	; \
	st	r2,  r31, REG_OFF(EF_ILAR)	; \
	st	r3,  r31, REG_OFF(EF_IPAR)	; \
	ldcr	r1, DSAP			; \
	ldcr	r2, DUAP			; \
	st	r1,  r31, REG_OFF(EF_DSAP)	; \
	st	r2,  r31, REG_OFF(EF_DUAP)	; \
	ldcr	r1, ISAP			; \
	ldcr	r2, IUAP			; \
	st	r1,  r31, REG_OFF(EF_ISAP)	; \
	st	r2,  r31, REG_OFF(EF_IUAP)	; \
	/* Restore r1, r2, r3, and r31 */	; \
	ld	r1 , r31, GENREG_OFF(1)		; \
	ld	r2 , r31, GENREG_OFF(2)		; \
	ld	r3 , r31, GENREG_OFF(3)		; \
	ld	r31, r31, GENREG_OFF(31)
#endif

/*
 *
 * #define PREP881x0(NAME, NUM, BIT, SSBR_STUFF, FLAG_CHECK)
 *
 * This is the "exception processing preparation" common to all exception
 * processing.  It is used in the following manner:
 *
 *	ASGLOBAL(foo_handler)
 *		PREP88100("foo", 11, DEBUG_FOO_BIT, SSBR_Stuff, Precheck_Stuff)
 *		CALL(_C_LABEL(trapXXX), T_FOO_FAULT, r31)
 *		DONE88100(DEBUG_FOO_BIT)
 *
 * This defines the exception handler for the "foo" exception.
 * The arguments are:
 * NAME
 *	String for debugging (more info later)
 * NUM
 *	The exception number [see the manual, Table 6-1]
 * BIT
 *	Bit to check in eh_debug for debugging (more info later)
 * SSBR_STUFF
 *	If the exception might leave some bits in the SSBR set,
 *	this should indicate how they are cleared.
 * FLAG_PRECHECK
 *	This is for the data access exception only. See it for
 *	more info.
 *
 * What's in between PREP881x0() and DONE881x0() (usually a CALL)
 * is the actual servicing of the interrupt.  During this time, any
 * register may be used freely as they've all been saved in the
 * exception frame (which is pointed to by r31).
 */

#ifdef M88100
#define PREP88100(NAME, NUM, BIT, SSBR_STUFF, FLAG_PRECHECK) \
	xcr	FLAGS, FLAGS, SR1			; \
	FLAG_PRECHECK					; \
	/* the bsr later clobbers r1, so save now */	  \
	stcr	r1, SR2	/* r1 now free */		; \
	/* set or clear the FLAG_FROM_KERNEL bit */	  \
	ldcr	r1, EPSR				; \
	bb0.n	PSR_SUPERVISOR_MODE_BIT, r1, 1f		; \
	 clr	FLAGS, FLAGS, 1<FLAG_FROM_KERNEL>	; \
	set	FLAGS, FLAGS, 1<FLAG_FROM_KERNEL>	; \
	/* get a stack (exception frame) */		  \
1:	bsr	_ASM_LABEL(m88100_setup_phase_one)	; \
	/* TMP2 now free -- use to set EF_VECTOR */	  \
	or	TMP2, r0, NUM				; \
	st	TMP2, r31, REG_OFF(EF_VECTOR)		; \
	/* Clear any bits in the SSBR (held in TMP) */	  \
	/* SSBR_STUFF may be empty, though.         */	  \
	SSBR_STUFF					; \
	/* call setup_phase_two to restart the FPU  */	  \
	/* and to save all general registers.       */	  \
	bsr	_ASM_LABEL(m88100_setup_phase_two)	; \
	/* All general regs free -- do any debugging */	  \
	PREP_DEBUG(BIT, NAME)
#endif

#ifdef M88110
#define PREP88110(NAME, NUM, BIT, FLAG_PRECHECK) \
	SAVE_CTX					; \
	xcr	FLAGS, FLAGS, SR1			; \
	FLAG_PRECHECK					; \
	/* the bsr later clobbers r1, so save now */	; \
	stcr	r1, SR2	/* r1 now free */		; \
	/* set or clear the FLAG_FROM_KERNEL bit */	; \
	ldcr	r1, EPSR 				; \
	bb0.n	PSR_SUPERVISOR_MODE_BIT, r1, 1f 	; \
	 clr	FLAGS, FLAGS, 1<FLAG_FROM_KERNEL> 	; \
	set	FLAGS, FLAGS, 1<FLAG_FROM_KERNEL>	; \
	/* get a stack (exception frame) */		; \
1:	bsr	_ASM_LABEL(m88110_setup_phase_one)	; \
	/* TMP2 now free -- use to set EF_VECTOR */	; \
	or	TMP2, r0, NUM				; \
	st	TMP2, r31, REG_OFF(EF_VECTOR)		; \
	/* call setup_phase_two to restart the FPU  */	; \
	/* and to save all general registers.       */	; \
	bsr	_ASM_LABEL(m88110_setup_phase_two)	; \
	/* All general regs free -- do any debugging */	; \
	PREP_DEBUG(BIT, NAME)
#endif

/* Some defines for use with PREP88100() */
#define	Clear_SSBR_Dest \
	bsr	_ASM_LABEL(clear_dest_ssbr_bit)
#define	M88100_Data_Precheck \
	bb1.n	FLAG_IGNORE_DATA_EXCEPTION, FLAGS, \
	    _ASM_LABEL(m88100_ignore_data_exception)
#define	M88110_Data_Precheck \
	bb1.n	FLAG_IGNORE_DATA_EXCEPTION, FLAGS, \
	    _ASM_LABEL(m88110_ignore_data_exception)

#ifdef EH_DEBUG
/*
 * If we allow debugging, there is a variable "eh_debug"
 * in which there is a bit for each exception.  If the bit
 * is set for an exception, debugging information is printed
 * about that exception whenever it occurs.
 *
 * The bits are defined in "asm.h"
 */

ASGLOBAL(eh_debug)
	word	0x00000000

/*
 * additional pre-servicing preparation to be done when
 * debugging... check eh_debug and make the call if
 * need be.
 */
#define PREP_DEBUG(DebugNumber, Name) \
	or.u	r2, r0, hi16(_ASM_LABEL(eh_debug))	; \
	ld	r3, r2, lo16(_ASM_LABEL(eh_debug))	; \
	bb0	DebugNumber, r3, 4f			; \
	/* call MY_info(ef,SR0,flags,kind)*/		  \
	or	r2, r30, r0				; \
	ldcr	r3, SR0					; \
	ldcr	r4, SR1					; \
	or.u	r5, r0, hi16(2f)			; \
	or	r5, r5, lo16(2f)			; \
	bsr.n	_C_LABEL(MY_info)			; \
	 subu	r31, r31, 32				; \
	br.n	4f					; \
	 addu	r31, r31, 32				; \
	data						; \
2:	string Name					; \
	byte	0					; \
	align	4					; \
	text						; \
4:


/*
 * Post-servicing work to be done.
 * When debugging, check "eh_debug" and call the
 * debug routined if neeed be.
 *
 * Then, return from the interrupt handler.
 */
#define DONE88100(DebugNumber) \
	or.u	r2, r0, hi16(_ASM_LABEL(eh_debug))	; \
	ld	r3, r2, lo16(_ASM_LABEL(eh_debug))	; \
	bb0	DebugNumber, r3, 2f			; \
	ldcr	r4, SR1					; \
	CALL(_C_LABEL(MY_info_done), r31, r4)		; \
2:	br	_ASM_LABEL(m88100_return_code)
#define DONE88110(DebugNumber) \
	or.u	r2, r0, hi16(_ASM_LABEL(eh_debug))	; \
	ld	r3, r2, lo16(_ASM_LABEL(eh_debug))	; \
	bb0	DebugNumber, r3, 2f			; \
	ldcr	r4, SR1					; \
	CALL(_C_LABEL(MY_info_done), r31, r4)		; \
2:	br	_ASM_LABEL(m88110_return_code)
#else
/*
 * If not debugging, then no debug-prep to do.
 * Also, when you're done, you're done!   (no debug check).
 */
#define	PREP_DEBUG(bit, name)
#define	DONE88100(num) \
	br	_ASM_LABEL(m88100_return_code)
#define	DONE88110(num) \
	br	_ASM_LABEL(m88110_return_code)
#endif	/* EH_DEBUG */

#ifdef M88100
/*
 * MVME18x exception handlers
 */

/* unknown exception handler */
GLOBAL(unknown_handler)
	PREP88100("unknown", 0, DEBUG_UNKNOWN_BIT,,)
	CALL(_C_LABEL(m88100_trap), T_UNKNOWNFLT, r30)
	DONE88100(DEBUG_UNKNOWN_BIT)

/* interrupt exception handler */
GLOBAL(interrupt_handler)
	PREP88100("interrupt", 1, DEBUG_INTERRUPT_BIT,,)
	CALL(_C_LABEL(m88100_trap), T_INT, r30)
	DONE88100(DEBUG_INTERRUPT_BIT)

/* instruction access exception handler */
GLOBAL(instruction_access_handler)
	PREP88100("inst", 2, DEBUG_INSTRUCTION_BIT,,)
	CALL(_C_LABEL(m88100_trap), T_INSTFLT, r30)
	DONE88100(DEBUG_INSTRUCTION_BIT)

/*
 * data access exception handler --
 *  See badaddr() below for info about Data_Precheck.
 */
GLOBAL(data_exception_handler)
	PREP88100("data", 3, DEBUG_DATA_BIT,, M88100_Data_Precheck)
	/* No need to call m88100_trap(T_DATAFLT) as PREP will do this for us */
	DONE88100(DEBUG_DATA_BIT)

/* misaligned access exception handler */
GLOBAL(misaligned_handler)
	PREP88100("misalign", 4, DEBUG_MISALIGN_BIT, Clear_SSBR_Dest,)
	CALL(_C_LABEL(m88100_trap), T_MISALGNFLT, r30)
	DONE88100(DEBUG_MISALIGN_BIT)

/* unimplemented opcode exception handler */
GLOBAL(unimplemented_handler)
	PREP88100("unimp", 5, DEBUG_UNIMPLEMENTED_BIT,,)
	CALL(_C_LABEL(m88100_trap), T_ILLFLT, r30)
	DONE88100(DEBUG_UNIMPLEMENTED_BIT)

/*
 * Some versions of the chip have a bug whereby false privilege
 * violation exceptions are raised. If the valid bit in the SXIP is clear,
 * it is false.  If so, just return.  The code before PREP handles this....
 */
GLOBAL(privilege_handler)
	stcr	r1, SR2		/* hold r1 for a moment */
	ldcr	r1, SXIP	/* look at the sxip... valid bit set? */
	bb1.n	RTE_VALID_BIT, r1, 1f	/* skip over if a valid exception */
	 ldcr	r1, SR2		/* restore r1 */
	RTE
1:	PREP88100("privilege", 6, DEBUG_PRIVILEGE_BIT, Clear_SSBR_Dest,)
	CALL(_C_LABEL(m88100_trap), T_PRIVINFLT, r30)
	DONE88100(DEBUG_PRIVILEGE_BIT)

/* bounds checking exception handler */
GLOBAL(bounds_handler)
	PREP88100("bounds", 7, DEBUG_BOUNDS_BIT, Clear_SSBR_Dest,)
	CALL(_C_LABEL(m88100_trap), T_BNDFLT, r30)
	DONE88100(DEBUG_BOUNDS_BIT)

/* integer divide-by-zero exception handler */
GLOBAL(divide_handler)
	PREP88100("divide", 8, DEBUG_DIVIDE_BIT, Clear_SSBR_Dest,)
	CALL(_C_LABEL(m88100_trap), T_ZERODIV, r30)
	DONE88100(DEBUG_DIVIDE_BIT)

/* integer overflow exception handler */
GLOBAL(overflow_handler)
	PREP88100("overflow", 9, DEBUG_OVERFLOW_BIT,,)
	CALL(_C_LABEL(m88100_trap), T_OVFFLT, r30)
	DONE88100(DEBUG_OVERFLOW_BIT)

/* Floating-point precise handler */
#define	FPp_SSBR_STUFF \
	bsr	_ASM_LABEL(clear_FPp_ssbr_bit)
GLOBAL(fp_precise_handler)
	PREP88100("FPU precise", 114, DEBUG_FPp_BIT, FPp_SSBR_STUFF,)
	CALL(_ASM_LABEL(m88100_Xfp_precise), r0, r30)
	DONE88100(DEBUG_FPp_BIT)

/* Floating-point imprecise handler */
#define	FPi_SSBR_STUFF \
	bsr	_ASM_LABEL(clear_FPi_ssbr_bit)
GLOBAL(fp_imprecise_handler)
	PREP88100("FPU imprecise", 115, DEBUG_FPi_BIT, FPi_SSBR_STUFF,)
	CALL(_ASM_LABEL(Xfp_imprecise), r0, r30)
	DONE88100(DEBUG_FPi_BIT)

/* All standard system calls.  */
GLOBAL(syscall_handler)
	PREP88100("syscall", 128, DEBUG_SYSCALL_BIT,,)
	ld	r13, r30, GENREG_OFF(13)
	CALL(_C_LABEL(m88100_syscall), r13, r30)
	DONE88100(DEBUG_SYSCALL_BIT)

/* trap 496 comes here */
GLOBAL(bugtrap)
	PREP88100("bugsyscall", 496, DEBUG_BUGCALL_BIT,,)
	ld	r9, r30, GENREG_OFF(9)
	CALL(_C_LABEL(bugsyscall), r9, r30)
	DONE88100(DEBUG_BUGCALL_BIT)

GLOBAL(sigsys)
	PREP88100("sigsys", 501, DEBUG_SIGSYS_BIT,,)
	CALL(_C_LABEL(m88100_trap), T_SIGSYS, r30)
	DONE88100(DEBUG_SIGSYS_BIT)

GLOBAL(sigtrap)
	PREP88100("sigtrap", 510, DEBUG_SIGTRAP_BIT,,)
	CALL(_C_LABEL(m88100_trap), T_SIGTRAP, r30)
	DONE88100(DEBUG_SIGTRAP_BIT)

GLOBAL(stepbpt)
	PREP88100("stepbpt", 504, DEBUG_SIGTRAP_BIT,,)
	CALL(_C_LABEL(m88100_trap), T_STEPBPT, r30)
	DONE88100(DEBUG_SIGTRAP_BIT)

GLOBAL(userbpt)
	PREP88100("userbpt", 511, DEBUG_SIGTRAP_BIT,,)
	CALL(_C_LABEL(m88100_trap), T_USERBPT, r30)
	DONE88100(DEBUG_SIGTRAP_BIT)

#ifdef DDB
GLOBAL(break)
	PREP88100("break", 130, DEBUG_BREAK_BIT,,)
	CALL(_C_LABEL(m88100_trap), T_KDB_BREAK, r30)
	DONE88100(DEBUG_BREAK_BIT)

GLOBAL(trace)
	PREP88100("trace", 131, DEBUG_TRACE_BIT,,)
	CALL(_C_LABEL(m88100_trap), T_KDB_TRACE, r30)
	DONE88100(DEBUG_TRACE_BIT)

GLOBAL(entry)
	PREP88100("kdb", 132, DEBUG_KDB_BIT,,)
	CALL(_C_LABEL(m88100_trap), T_KDB_ENTRY, r30)
	DONE88100(DEBUG_KDB_BIT)
d45 1
a45 329
GLOBAL(break)
	PREP88100("break", 130, DEBUG_BREAK_BIT,,)
	CALL(_C_LABEL(m88100_trap), T_UNKNOWNFLT, r30)
	DONE88100(DEBUG_BREAK_BIT)

GLOBAL(trace)
	PREP88100("trace", 131, DEBUG_TRACE_BIT,,)
	CALL(_C_LABEL(m88100_trap), T_UNKNOWNFLT, r30)
	DONE88100(DEBUG_TRACE_BIT)

GLOBAL(entry)
	PREP88100("unknown", 132, DEBUG_KDB_BIT,,)
	CALL(_C_LABEL(m88100_trap), T_UNKNOWNFLT, r30)
	DONE88100(DEBUG_KDB_BIT)
#endif

/*
 * The error exception and reset exception handler.
 *
 * The error exception is raised when any other non-trap exception is raised
 * while shadowing is off. This is Bad News.
 *
 * The reset exception is raised when the RST signal is asserted (machine
 * is reset), the value of VBR is changed after exceptions are enabled,
 * or when a jmp, br/bsr to addr 0 (accidents do happen :-)
 * To tell the difference, you should check the value of r1 and the valid
 * bit of SXIP.
 * Upon a real reset, VBR is set to zero (0), so code must be at addr 0
 * to handle it!!!
 *
 * The shadow registers are not valid in this case (shadowing was off, if this
 * was an error exception, and may not be on, if this was a reset exception).
 * R1-R31 may be interesting though, so we'll save them.
 *
 * We'll not worry about trashing r26-29 here,
 * since they aren't generally used.
 */
GLOBAL(error_handler)
	br.n	1f
	 or	r29, r0, 10
GLOBAL(reset_handler)
	or	r29, r0, 0
1:
	/* pick up the slavestack */
	or	r26, r0,  r31	/* save old stack */
	or.u	r31, r0,  hi16(_ASM_LABEL(intstack_end))
	or	r31, r31, lo16(_ASM_LABEL(intstack_end))

#ifdef DEBUG
	/* zero the stack, so we'll know what we're lookin' at */
	or.u	r27, r0,  hi16(_C_LABEL(intstack))
	or	r27, r27, lo16(_C_LABEL(intstack))
1:	cmp	r28, r27, r31
	bb1	ge,  r28, 2f	/* branch if at the end of the stack */
	st	r0,  r0,  r27
	br.n	1b
	 addu	r27, r27, 4	/* bump up */
2:	/* stack has been cleared */
#endif

	/* ensure that stack is 8-byte aligned */
	clr	r31, r31, 3<0>	/* round down to 8-byte boundary */

	/* create exception frame on stack */
	subu	r31, r31, SIZEOF_EF	/* r31 now our E.F. */

	/* save old R31 and other R registers */
	st.d	r0 , r31, GENREG_OFF(0)
	st.d	r2 , r31, GENREG_OFF(2)
	st.d	r4 , r31, GENREG_OFF(4)
	st.d	r6 , r31, GENREG_OFF(6)
	st.d	r8 , r31, GENREG_OFF(8)
	st.d	r10, r31, GENREG_OFF(10)
	st.d	r12, r31, GENREG_OFF(12)
	st.d	r14, r31, GENREG_OFF(14)
	st.d	r16, r31, GENREG_OFF(16)
	st.d	r18, r31, GENREG_OFF(18)
	st.d	r20, r31, GENREG_OFF(20)
	st.d	r22, r31, GENREG_OFF(22)
	st.d	r24, r31, GENREG_OFF(24)
	st	r30, r31, GENREG_OFF(30)
	st	r26, r31, GENREG_OFF(31)

	/* save shadow registers (are OLD if error_handler, though) */
	ldcr	r10, EPSR
	st	r10, r31, REG_OFF(EF_EPSR)
	ldcr	r10, SXIP
	st	r10, r31, REG_OFF(EF_SXIP)
	ldcr	r10, SNIP
	st	r10, r31, REG_OFF(EF_SNIP)
	ldcr	r10, SR1
	st	r10, r31, REG_OFF(EF_MODE)
	ldcr	r10, SFIP
	st	r10, r31, REG_OFF(EF_SFIP)
	ldcr	r10, SSBR
	st	r10, r31, REG_OFF(EF_SSBR)
	stcr	r0,  SSBR	/* won't want shadow bits bothering us later */

	ldcr	r10, DMT0
	st	r10, r31, REG_OFF(EF_DMT0)
	ldcr	r11, DMD0
	st	r11, r31, REG_OFF(EF_DMD0)
	ldcr	r12, DMA0

	st	r12, r31, REG_OFF(EF_DMA0)
	ldcr	r10, DMT1
	st	r10, r31, REG_OFF(EF_DMT1)
	FLUSH_PIPELINE
	ldcr	r11, DMD1
	st 	r11, r31, REG_OFF(EF_DMD1)
	ldcr	r12, DMA1
	st	r12, r31, REG_OFF(EF_DMA1)

	ldcr	r10, DMT2
	st	r10, r31, REG_OFF(EF_DMT2)
	ldcr	r11, DMD2
	st	r11, r31, REG_OFF(EF_DMD2)
	ldcr	r12, DMA2
	st	r12, r31, REG_OFF(EF_DMA2)

	/* shove sr2 into EF_FPLS1 */
	ldcr	r10, SR2
	st	r10, r31, REG_OFF(EF_FPLS1)

	/* shove sr3 into EF_FPHS2 */
	ldcr	r10, SR3
	st	r10, r31, REG_OFF(EF_FPHS2)

	/* save error vector */
	st	r29, r31, REG_OFF(EF_VECTOR)

	/*
	 * Cheap way to enable FPU and start shadowing again.
	 */
	ldcr	r10, PSR
	clr	r10, r10, 1<PSR_FPU_DISABLE_BIT>	/* enable the FPU */
	clr	r10, r10, 1<PSR_SHADOW_FREEZE_BIT>	/* and shadowing */
	stcr	r10, PSR
	FLUSH_PIPELINE

	/* put pointer to regs into r30... r31 will become a simple stack */
	or	r30, r31, r0

	subu	r31, r31, 0x10	/* make some breathing space */
	st	r30, r31, 0x0c	/* store frame pointer on the stack */
#ifdef DDB
	st	r30, r31, 0x08	/* store again for the debugger to recognize */
	or.u	r20,  r0, hi16(0x87654321)
	or	r20, r20, lo16(0x87654321)
	st	r20, r31, 0x04
	st	r20, r31, 0x00
#endif

	CALL(_C_LABEL(error_fatal), r30, r30)

	/* turn interrupts back on */
	ldcr	r1, PSR
	clr	r1, r1, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r1, PSR
	FLUSH_PIPELINE

1:
	br	1b
	/* NOTREACHED */
#endif	/* M88100 */

/*
 * This is part of baddadr (below).
 */
#ifdef M88100
ASLOCAL(m88100_ignore_data_exception)
	/*
	 * SR1: previous FLAGS reg
	 * SR2: free
	 * SR3: must presere
	 * FLAGS: CPU status flags
	 */
	xcr	FLAGS, FLAGS, SR1	/* replace SR1, FLAGS */

	/*
	 * For more info, see badaddr() below.
	 *
	 * We just want to jump to "badaddr__return_nonzero" below.
	 *
	 * We don't worry about trashing R2 here because we're
	 * jumping back to the function badaddr() where we're allowed
	 * to blast r2..r9 as we see fit.
	 */

	/* the "+2" below is to set the VALID bit. */
	or.u	r2, r0, hi16(_ASM_LABEL(badaddr__return_nonzero) + 2)
	or	r2, r2, lo16(_ASM_LABEL(badaddr__return_nonzero) + 2)
	stcr	r2, SNIP	/* Make it the next instruction to execute */
	addu	r2, r2, 4
	stcr	r2, SFIP	/* and the next one after that, too. */
	stcr	r0, SSBR	/* make the scoreboard happy. */
	RTE
#endif /* M88100 */

#ifdef M88110
/*
 * This is part of baddadr (below).
 */
ASLOCAL(m88110_ignore_data_exception)
	/*
	 * SR1: previous FLAGS reg
	 * SR2: free
	 * SR3: must preserve
	 * FLAGS: CPU status flags
	 */
	xcr	FLAGS, FLAGS, SR1	/* replace SR1, FLAGS */

	/*
	 * For more info, see badaddr() below.
	 *
	 * We just want to jump to "badaddr__return_nonzero" below.
	 *
	 * We don't worry about trashing R2 here because we're
	 * jumping back to the function badaddr() where we're allowed
	 * to blast r2..r9 as we see fit.
	 */

	or.u	r2, r0, hi16(_ASM_LABEL(badaddr__return_nonzero))
	or	r2, r2, lo16(_ASM_LABEL(badaddr__return_nonzero))
	stcr	r2, EXIP	/* Make it the next instruction to execute */
	stcr	r0, DSR		/* Clear exception status */
	RTE
#endif /* M88110 */

/*
 * extern boolean_t badaddr(unsigned addr, unsigned len)
 *
 * Returns true (non-zero) if the given LEN bytes starting at ADDR are
 * not all currently accessible by the kernel.
 *
 * If all LEN bytes starting at ADDR are accessible, zero is returned.
 *
 * Len may be be 1, 2, or 4.
 *
 * This is implemented by setting a special flag in SR1 before trying to access
 * the given address. If a data access exception is raised, the address
 * is inaccessible. The exception handler will notice the special CPU flag
 * and not try to swap the address in. Rather, it will return to
 * "badaddr__return_nonzero" in this routine so that we may return non-zero
 * to the calling routine.
 *
 * If no fault is raised, we continue to where we return zero to the calling
 * routine (after removing the special CPU flag).
 */

GLOBAL(badaddr)
	/*
	 * Disable interrupts ... don't want a context switch while we're
	 * doing this! Also, save the old PSR in R8 to restore later.
	 */
	ldcr	r8, PSR
	set	r4, r8, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r4, PSR
	FLUSH_PIPELINE

	ldcr	r5, SR1
	set	r5, r5, 1<FLAG_IGNORE_DATA_EXCEPTION>
	/* resetting r5 to SR1 done in the delay slot below. */

	/*
	 * If it's a word we're doing, do that here. Otherwise,
	 * see if it's a halfword.....
	 */
	sub	r6,  r3, 4
	bcnd.n	ne0, r6, _ASM_LABEL(badaddr__maybe_halfword)
	 stcr	r5,  SR1
	FLUSH_PIPELINE

	/*
	 * It's a bad address if it's misaligned.
	 */
	bb1	0, r2, _ASM_LABEL(badaddr__return_nonzero)
	bb1	1, r2, _ASM_LABEL(badaddr__return_nonzero)
	/*
	 * The next line will either fault or not. If it faults, execution
	 * will go to:  data_access_handler (see above)
	 * and then to: ignore_data_exception (see above)
	 * and then to: badaddr__return_nonzero (see below)
	 * which will return to the calling function.
	 *
	 * If there is no fault, execution just continues as normal.
	 */
	ld	r5, r2, 0
	FLUSH_PIPELINE
	br.n	_ASM_LABEL(badaddr__return)
	 or	r2, r0, r0	/* indicate a zero (address not bad) return.*/

ASLOCAL(badaddr__maybe_halfword)
	/* More or less like the code for checking a word above */
	sub	r6, r3, 2
	bcnd	ne0, r6, _ASM_LABEL(badaddr__maybe_byte)

	/* it's bad if it's misaligned */
	bb1	0, r2, _ASM_LABEL(badaddr__return_nonzero)

	FLUSH_PIPELINE
	ld.h	r5, r2, 0
	FLUSH_PIPELINE
	br.n	_ASM_LABEL(badaddr__return)
	 or	r2, r0, r0

ASLOCAL(badaddr__maybe_byte)
#ifdef DEBUG
	/* More or less like the code for checking a word above */
	sub	r6, r3, 1
	bcnd	ne0, r6, _ASM_LABEL(badaddr__unknown_size)
#endif
	FLUSH_PIPELINE
	ld.b	r5, r2, 0
	FLUSH_PIPELINE
	br.n	_ASM_LABEL(badaddr__return)
	 or	r2, r0, r0
ASLOCAL(badaddr__unknown_size)
#ifdef	DEBUG
	data
1: 	string "bad length (%d) to badaddr() from 0x%x\000"
	text
	subu	r31, r31, 32
	or.u	r2, r0, hi16(1b)
	or	r2, r2, lo16(1b)
	bsr.n	_C_LABEL(panic)
	 or	r4, r0, r1
	addu	r31, r31, 32
	/*NOTREACHED*/
d48 1
a48 183
ASLOCAL(badaddr__return_nonzero)
	or	r2, r0, 1
	/* FALLTHROUGH */

ASLOCAL(badaddr__return)
	ldcr	r4, SR1
	clr	r4, r4, 1<FLAG_IGNORE_DATA_EXCEPTION>
	stcr	r4, SR1

	/*
	 * Restore the PSR to what it was before.
	 * The only difference is that we might be enabling interrupts
	 * (which we turned off above).  If interrupts were already off,
	 * we do not want to turn them on now, so we just restore from
	 * where we saved it.
	 */
	stcr	r8, PSR
	FLUSH_PIPELINE
	jmp	r1

#ifdef M88100
ASLOCAL(m88100_setup_phase_one)
	/*
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: saved copy of exception-time r1
	 * SR3: must be preserved .. may be the exception-time stack
	 * r1: return address to calling exception handler
	 * FLAGS: CPU status flags
	 *
	 * immediate goal:
	 *   Decide where we're going to put the exception frame.
	 *   Might be at the end of R31, SR3, or the process pcb.
	 */

	/* Check if we are coming in from a FPU restart exception.
	   If so, the pcb will be in SR3 */
	NOP
	xcr	r1,   r1,   SR2
	NOP
	NOP
	NOP

	bb1	FLAG_ENABLING_FPU, FLAGS, _ASM_LABEL(m88100_use_SR3_pcb)
	/* are we coming in from user mode? If so, pick up process pcb */
	bb0	FLAG_FROM_KERNEL, FLAGS, _ASM_LABEL(m88100_pickup_stack)

	/* Interrupt in kernel mode, not FPU restart */
	/*
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: return address to the calling exception handler
	 * SR3: must be preserved; may be important for other exceptions
	 * FLAGS: CPU status flags
	 *
	 * immediate goal:
	 *   We're already on the kernel stack, but not having
	 *   needed to use SR3. We can just make room on the
	 *   stack (r31) for our exception frame.
	 */
	subu	r31,  r31,  SIZEOF_EF		/* r31 now our E.F. */
	st	FLAGS,r31,  REG_OFF(EF_FLAGS)	/* save flags */
	st	r1,   r31,  GENREG_OFF(1)	/* save prev. r1 (now free)*/

	ldcr	r1,   SR3			/* save previous SR3 */
	st	r1,   r31,  REG_OFF(EF_SR3)

	addu	r1,   r31,  SIZEOF_EF		/* save previous r31 */
	br.n	_ASM_LABEL(m88100_have_pcb)
	 st 	r1,   r31,  GENREG_OFF(31)

ASLOCAL(m88100_use_SR3_pcb)
	/*
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: return address to the calling exception handler
	 * SR3: must be preserved; exception-time stack pointer
	 * FLAGS: CPU status flags
	 *
	 * immediate goal:
	 *   An exception occurred while enabling the FPU. Since r31
	 *   is the user's r31 while enabling the FPU, we had put
	 *   our pcb pointer into SR3, so make room from
	 *   there for our stack pointer.
	 *   We need to check if SR3 is the old stack pointer or the
	 *   pointer off to the user pcb. If it pointing to the user
	 *   pcb, we need to pick up the kernel stack. Otherwise
	 *   we need to allocate a frame upon it.
	 *   We look at the EPSR to see if it was from user mode
	 *   Unfortunately, we have no registers free at the moment
	 *   But we know register 0 in the pcb frame will always be
	 *   zero, so we can use it as scratch storage.
	 */
	xcr	r30,  r30,  SR3			/* r30 = old exception frame */
	st	r1,   r30,  GENREG_OFF(0)	/* free up r1 */
	ld	r1,   r30,  REG_OFF(EF_EPSR)	/* get back the epsr */
	bb0.n	PSR_SUPERVISOR_MODE_BIT, r1, 1f	/* if user mode */
	 ld	r1,   r30,  GENREG_OFF(0)	/* restore r1 */
	/* we were in kernel mode - dump frame upon the stack */
	st	r0,   r30,  GENREG_OFF(0)	/* repair old frame */
	subu	r30,  r30,  SIZEOF_EF		/* r30 now our E.F. */
	st	FLAGS,r30,  REG_OFF(EF_FLAGS)	/* save flags */
	st	r1,   r30,  GENREG_OFF(1)	/* save prev r1 (now free) */

	st	r31,  r30,  GENREG_OFF(31)	/* save previous r31 */
	or	r31,  r0,   r30			/* make r31 our pointer. */
	addu	r30,  r30,  SIZEOF_EF		/* r30 now has previous SR3 */
	st	r30,  r31,  REG_OFF(EF_SR3)	/* save previous SR3 */
	br.n	_ASM_LABEL(m88100_have_pcb)
	 xcr	r30,  r30,  SR3			/* restore r30 */
1:
	/* we took an exception while restarting the FPU from user space.
	 * Consequently, we never picked up a stack. Do so now.
	 * R1 is currently free (saved in the exception frame pointed at by
	 * r30) */
	or.u	r1,   r0,   hi16(_ASM_LABEL(kstack))
	ld	r1,   r1,   lo16(_ASM_LABEL(kstack))
	addu	r1,   r1,   USIZE-SIZEOF_EF
	st	FLAGS,r1,   REG_OFF(EF_FLAGS)	/* store flags */
	st	r31,  r1,   GENREG_OFF(31)	/* store r31 - now free */
	st	r30,  r1,   REG_OFF(EF_SR3)	/* store old SR3 (pcb) */
	or	r31,  r1,   r0			/* make r31 our exception fp */
	ld	r1,   r30,  GENREG_OFF(0)	/* restore old r1 */
	st	r0,   r30,  GENREG_OFF(0)	/* repair that frame */
	st	r1,   r31,  GENREG_OFF(1)	/* store r1 */
	br.n	_ASM_LABEL(m88100_have_pcb)
	 xcr	r30,  r30,  SR3			/* restore r30 */

ASLOCAL(m88100_pickup_stack)
	/*
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: return address to the calling exception handler
	 * SR3: free
	 * FLAGS: CPU status flags
	 *
	 * immediate goal:
	 *   Since we're servicing an exception from user mode, we
	 *   know that SR3 is free.  We use it to free up a temp.
	 *   register to be used in getting the process pcb
	 */
	stcr	r31,  SR3	/* save previous r31 */

	/* switch to the process kernel stack. */
	or.u	r31,  r0,   hi16(_C_LABEL(curpcb))
	ld	r31,  r31,  lo16(_C_LABEL(curpcb))
	addu	r31,  r31,  PCB_USER_STATE	/* point to user save area */
	st	FLAGS,r31,  REG_OFF(EF_FLAGS)	/* save flags */
	st	r1,   r31,  GENREG_OFF(1)	/* save prev. r1 (now free) */
	ldcr	r1,   SR3			/* save previous r31 */
	st	r1,   r31,  GENREG_OFF(31)
	/* FALLTHROUGH */

ASLOCAL(m88100_have_pcb)
	/*
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: return address to the calling exception handler
	 * SR3: free
	 * r1:  free
	 * FLAGS: CPU status flags
	 * r31: our exception frame
	 * Valid in the exception frame:
	 *   Exception-time r1, r31, FLAGS.
	 *   Exception SR3, if appropriate.
	 *
	 * immediate goal:
	 *   Save the shadow registers that need to be saved to
	 *   the exception frame.
	 */
	stcr	TMP, SR3	/* free up TMP, TMP2, TMP3 */
	SAVE_TMP2
	SAVE_TMP3

	/* save some exception-time registers to the exception frame */
	ldcr	TMP,  EPSR
	st	TMP,  r31,  REG_OFF(EF_EPSR)
	ldcr	TMP3, SNIP
	st	TMP3, r31,  REG_OFF(EF_SNIP)
	ldcr	TMP2, SFIP
	st	TMP2, r31,  REG_OFF(EF_SFIP)
	/* get and store the cpu number */
	extu	TMP,  FLAGS,  FLAG_CPU_FIELD_WIDTH<0>	/* TMP = cpu# */
	st	TMP,  r31,  REG_OFF(EF_CPU)

	/*
	 * Save Pbus fault status register from data and inst CMMU.
	 */
d50 63
a112 1525
#ifdef MVME187
	/* check if it's a mvme188 */
	or.u	TMP,  r0,   hi16(_C_LABEL(brdtyp))
	ld	TMP2, TMP,  lo16(_C_LABEL(brdtyp))
	cmp	TMP,  TMP2, BRD_188
	bb1	ne,   TMP,  5f
#endif

	extu	TMP,  FLAGS, FLAG_CPU_FIELD_WIDTH<0>	/* TMP = cpu# */
	cmp	TMP2, TMP, 0x0				/* CPU0 ? */
	bb1	eq,   TMP2, 1f
	cmp	TMP2, TMP, 0x1				/* CPU1 ? */
	bb1	eq,   TMP2, 2f
	cmp	TMP2, TMP, 0x2				/* CPU2 ? */
	bb1	eq,   TMP2, 3f
#ifdef DEBUG
	cmp	TMP2, TMP, 0x3				/* CPU3 ? */
	bb1	eq,   TMP2, 4f
	/* Arrrrg! bad cpu# */
	br	_ASM_LABEL(Lbadcpupanic)
#else
	br	4f
#endif
	/* XXX WHAT ABOUT MODULES WITH SPLIT U/S CMMUS ??? */
1:
	/* must be CPU0 */
	or.u	TMP,  r0,   hi16(VME_CMMU_I0)
	ld	TMP2, TMP,  lo16(VME_CMMU_I0) + 0x108
	st	TMP2, r31,  REG_OFF(EF_IPFSR)
	or.u	TMP,  r0,   hi16(VME_CMMU_D0)
	ld	TMP2, TMP,  lo16(VME_CMMU_D0) + 0x108
	st	TMP2, r31,  REG_OFF(EF_DPFSR)
	br	_ASM_LABEL(pfsr_done)
2:
	/* must be CPU1 */
	or.u	TMP,  r0,   hi16(VME_CMMU_I1)
	ld	TMP2, TMP,  lo16(VME_CMMU_I1) + 0x108
	st	TMP2, r31,  REG_OFF(EF_IPFSR)
	or.u	TMP,  r0,   hi16(VME_CMMU_D1)
	ld	TMP2, TMP,  lo16(VME_CMMU_D1) + 0x108
	st	TMP2, r31,  REG_OFF(EF_DPFSR)
	br	_ASM_LABEL(pfsr_done)
3:
	/* must be CPU2 */
	or.u	TMP,  r0,   hi16(VME_CMMU_I2)
	ld	TMP2, TMP,  lo16(VME_CMMU_I2) + 0x108
	st	TMP2, r31,  REG_OFF(EF_IPFSR)
	or.u	TMP,  r0,   hi16(VME_CMMU_D2)
	ld	TMP2, TMP,  lo16(VME_CMMU_D2) + 0x108
	st	TMP2, r31,  REG_OFF(EF_DPFSR)
	br	_ASM_LABEL(pfsr_done)
4:
	/* must be CPU3 */
	or.u	TMP,  r0,   hi16(VME_CMMU_I3)
	ld	TMP2, TMP,  lo16(VME_CMMU_I3) + 0x108
	st	TMP2, r31,  REG_OFF(EF_IPFSR)
	or.u	TMP,  r0,   hi16(VME_CMMU_D3)
	ld	TMP2, TMP,  lo16(VME_CMMU_D3) + 0x108
	st	TMP2, r31,  REG_OFF(EF_DPFSR)
	br	_ASM_LABEL(pfsr_done)
5:
#endif   /* MVME188 */
#ifdef MVME187
	/* it's a single processor SBC */
	or.u	TMP,  r0,   hi16(SBC_CMMU_I)
	ld	TMP2, TMP,  lo16(SBC_CMMU_I) + 0x108
	st	TMP2, r31,  REG_OFF(EF_IPFSR)
	or.u	TMP,  r0,   hi16(SBC_CMMU_D)
	ld	TMP2, TMP,  lo16(SBC_CMMU_D) + 0x108
	st	TMP2, r31,  REG_OFF(EF_DPFSR)
#endif

ASLOCAL(pfsr_done)
	ldcr	TMP,  SSBR
	ldcr	TMP2, SXIP
	ldcr	TMP3, DMT0
	st	TMP2, r31,  REG_OFF(EF_SXIP)

/*
 * The above shadow registers are obligatory for any and all
 * exceptions.  Now, if the data access pipeline is not clear,
 * we must save the DMx shadow registers, as well as clear
 * the appropriate SSBR bits for the destination registers of
 * loads or xmems.
 */
	bb0.n	DMT_VALID_BIT, TMP3, 8f
	 st	TMP3, r31,  REG_OFF(EF_DMT0)

	ldcr	TMP2, DMT1
	ldcr	TMP3, DMT2
	st	TMP2, r31,  REG_OFF(EF_DMT1)
	st	TMP3, r31,  REG_OFF(EF_DMT2)

	ldcr	TMP2, DMA0
	ldcr	TMP3, DMA1
	st	TMP2, r31,  REG_OFF(EF_DMA0)
	st	TMP3, r31,  REG_OFF(EF_DMA1)

	ldcr	TMP2, DMA2
	ldcr	TMP3, DMD0
	st	TMP2, r31,  REG_OFF(EF_DMA2)
	st	TMP3, r31,  REG_OFF(EF_DMD0)

	FLUSH_PIPELINE
	ldcr	TMP2, DMD1
	ldcr	TMP3, DMD2
	st	TMP2, r31,  REG_OFF(EF_DMD1)
	st	TMP3, r31,  REG_OFF(EF_DMD2)

/*
 * need to clear "appropriate" bits in the SSBR before
 * we restart the FPU
 */

	ldcr	TMP2, DMT0
	bb0.n	DMT_VALID_BIT, TMP2, 8f
	/* make sure an exception in fpu_enable will not see our DMT0 */
	 stcr	r0,   DMT0
	bb1	DMT_LOCK_BIT,  TMP2, 1f
	bb1	DMT_WRITE_BIT, TMP2, 2f
1:
	extu	TMP2, TMP2, DMT_DREG_WIDTH <DMT_DREG_OFFSET>
	set	TMP2, TMP2, 1<5>
	clr	TMP,  TMP,  TMP2
2:
	ldcr	TMP2, DMT1
	bb0	DMT_VALID_BIT, TMP2, 4f
	bb1	DMT_LOCK_BIT,  TMP2, 3f
	bb1	DMT_WRITE_BIT, TMP2, 4f
3:
	extu	TMP2, TMP2, DMT_DREG_WIDTH <DMT_DREG_OFFSET>
	set	TMP2, TMP2, 1<5>
	clr	TMP,  TMP,  TMP2
4:
	ldcr	TMP2, DMT2
	bb0	DMT_VALID_BIT, TMP2, 8f
	bb1	DMT_LOCK_BIT,  TMP2, 5f
	bb1	DMT_WRITE_BIT, TMP2, 8f
	bb1	DMT_DOUBLE_BIT,TMP2, 6f
5:
	extu	TMP2, TMP2, DMT_DREG_WIDTH <DMT_DREG_OFFSET>
	br.n	7f
	 set	TMP2, TMP2, 1<5>	/* single */
6:
	extu	TMP2, TMP2, DMT_DREG_WIDTH <DMT_DREG_OFFSET>
	set	TMP2, TMP2, 1<6>	/* double */
7:
	clr	TMP,  TMP,  TMP2
8:
	/*
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: return address to the calling exception handler
	 * SR3: saved TMP
	 * r1:  free
	 * TMP: possibly revised SSBR
	 * TMP2: free
	 * TMP3: free
	 * FLAGS: CPU status flags
	 * r31: exception frame
	 * Valid in the exception frame:
	 *   Exception-time r1, r31, FLAGS.
	 *   Exception-time TMP2, TMP3.
	 *   Exception-time espr, sfip, snip, sxip.
	 *   Dmt0.
	 *   Other data pipeline control registers, if appropriate.
	 *   Exception SR3, if appropriate.
	 */
	ldcr	r1,   SR2
	jmp	r1	/* allow the handler to clear more SSBR bits */

ASLOCAL(clear_FPi_ssbr_bit)
	/*
	 * Clear floatingpoint-imprecise ssbr bits.
	 * Also, save appropriate FPU control registers to the E.F.
	 *
	 * r1:  return address to calling exception handler
	 * TMP: (possibly) revised ssbr
	 * TMP2: free
	 * TMP3: free
	 */
	fldcr	TMP2, FPSR
	fldcr	TMP3, FPCR
	st	TMP2, r31,  REG_OFF(EF_FPSR)
	st	TMP3, r31,  REG_OFF(EF_FPCR)

	fldcr	TMP2, FPECR
	fldcr	TMP3, FPRH
	st	TMP2, r31,  REG_OFF(EF_FPECR)
	st	TMP3, r31,  REG_OFF(EF_FPRH)

	fldcr 	TMP2, FPIT
	fldcr	TMP3, FPRL
	st	TMP2, r31,  REG_OFF(EF_FPIT)
	st	TMP3, r31,  REG_OFF(EF_FPRL)

	/*
	 * We only need clear the bit in the SSBR for the
	 * 2nd reg of a double result [see section 6.8.5]
	 */
#define FPIT_SIZE_BIT   10
	bb0	FPIT_SIZE_BIT, TMP2, 1f
	extu	TMP2, TMP2, 5<0>	/* get the reg. */
	set	TMP2, TMP2, 1<6>	/* set width */
	clr	TMP,  TMP,  TMP2
1:
	jmp	r1


ASLOCAL(clear_FPp_ssbr_bit)
	/*
	 * Clear floating pont precise ssbr bits.
	 * Also, save appropriate FPU control registers to the E.F.
	 *
	 * r1:  return address to calling exception handler
	 * TMP: (possibly) revised ssbr
	 * TMP2: free
	 * TMP3: free
	 */
	fldcr	TMP2, FPSR
	fldcr	TMP3, FPCR
	st	TMP2, r31,  REG_OFF(EF_FPSR)
	st	TMP3, r31,  REG_OFF(EF_FPCR)

	fldcr	TMP3, FPECR
	st	TMP3, r31,  REG_OFF(EF_FPECR)
	fldcr	TMP2, FPHS1
	fldcr	TMP3, FPHS2
	st	TMP2, r31,  REG_OFF(EF_FPHS1)
	st	TMP3, r31,  REG_OFF(EF_FPHS2)

	fldcr	TMP2, FPLS1
	fldcr	TMP3, FPLS2
	st	TMP2, r31,  REG_OFF(EF_FPLS1)
	st	TMP3, r31,  REG_OFF(EF_FPLS2)

	fldcr	TMP2, FPPT
	st	TMP2, r31,  REG_OFF(EF_FPPT)
1:

#define FPPT_SIZE_BIT   5
	bb1.n	FPPT_SIZE_BIT, TMP2, 2f
	 extu	TMP3, TMP2, 5<0>	/* get FP operation dest reg */
	br.n	3f
	 set	TMP3, TMP3, 1<5>	/* size=1 - clear one bit for float */
2:
	set	TMP3, TMP3, 1<6>	/* size=2 - clear two bit for double */
3:
	clr	TMP,  TMP,  TMP3	/* clear bit(s) in ssbr. */
	jmp	r1


ASLOCAL(clear_dest_ssbr_bit)
	/*
	 * There are various cases where an exception can leave the
	 * destination register's bit in the SB set.
	 * Examples:
	 *   misaligned or privilege exception on a LD or XMEM
	 *   DIV or DIVU by zero.
	 *
	 * I think that if the instruction is LD.D, then two bits must
	 * be cleared.
	 *
	 * Even though there are a number of instructions/exception
	 * combinations that could fire this code up, it's only required
	 * to be run for the above cases.  However, I don't think it'll
	 * ever be a problem to run this in other cases (ST instructions,
	 * for example), so I don't bother checking.  If we had to check
	 * for every possible instruction, this code would be much larger.
	 *
	 * The only checking, then, is to see if it's a LD.D or not.
	 *
	 * At the moment....
	 *  r1:  return address to calling exception handler
	 *  TMP: (possibly) revised ssbr
	 *  TMP2: free
	 *  TMP3: free
	 */

	ldcr	TMP3, EPSR	/* going to check: user or system memory? */
	ldcr	TMP2, SXIP	/* get the instruction's address */
	bb1.n	PSR_SUPERVISOR_MODE_BIT, TMP3, 2f
	 clr	TMP2, TMP2, 2<0>	/* get rid of valid and error bits. */

	/* user space load here */
#if ERRATA__XXX_USR
	NOP
	ld.usr	TMP2,TMP2, r0	/* get the instruction itself */
	NOP
	NOP
	NOP
	br    3f
#else
	br.n  3f
	 ld.usr	TMP2,TMP2, r0	/* get the instruction itself */
#endif

2:	/* system space load here */
	ld	TMP2, TMP2, r0	/* get the instruction itself */

3:	/* now we have the instruction..... */
	/*
	 * Now see if it's a double load
	 * There are three forms of double load [IMM16, scaled, unscaled],
	 * which can be checked by matching against two templates:
	 *          -- 77776666555544443333222211110000 --
	 *   if (((instruction & 11111100000000000000000000000000) ==
	 *             00010000000000000000000000000000) ;;
	 *       ((instruction & 11111100000000001111110011100000) ==
	 *             11110100000000000001000000000000))
	 *   {
	 *      It's a load double, so
	 *      clear two SSBR bits.
	 *   } else {
	 *      It's not a load double.
	 *      Must be a load single, xmem, or st
	 *      Thus, clear one SSBR bit.
	 *   }
	 */
	/* check the first pattern for ld.d */
	extu	TMP3, TMP2, 16<16>	/* get the upper 16 bits */
	mask	TMP3, TMP3, 0xFC00	/* apply the mask */
	cmp	TMP3, TMP3, 0x1000	/* if equal, it's a load double */
	bb1	eq,   TMP3, 2f

	/* still could be -- check the second pattern for ld.d */
	/* look at the upper 16 bits first */
	extu	TMP3, TMP2, 16<16>	/* get the upper 16 bits */
	mask	TMP3, TMP3, 0xFC00	/* apply the mask */
	cmp	TMP3, TMP3, 0xF400	/* if equal, might be a load double */
	bb1	ne,   TMP3, 1f		/* not equal, must be single */

	/* now look at the lower 16 bits */
	extu	TMP3, TMP2, 16<0>	/* get the lower 16 bits */
	mask	TMP3, TMP3, 0xFCE0	/* apply the mask */
	cmp	TMP3, TMP3, 0x1000	/* if equal, it's a load double */
	bb1	eq,   TMP3, 2f

1:	/* misaligned single */
	extu	TMP2, TMP2, 5<21>	/* get the destination register */
	br.n	3f
	 set	TMP2, TMP2, 1<5>	/* set size=1 */

2:	/* misaligned double */
	extu	TMP2, TMP2, 5<21>	/* get the destination register */
	set	TMP2, TMP2, 1<6>	/* set size=2 -- clear two bits */
3:
	jmp.n	r1
	 clr	TMP,  TMP,  TMP2	/* clear bit(s) in ssbr. */

ASLOCAL(m88100_setup_phase_two)
	/*
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: free
	 * SR3: saved TMP
	 * r1:  return address to calling exception handler
	 * TMP: possibly revised SSBR
	 * TMP2: free
	 * TMP3: free
	 * FLAGS: CPU status flags
	 * r31: our exception frame
	 *    Valid in the exception frame:
	 *   Exception-time r1, r31, FLAGS.
	 *   Exception-time TMP2, TMP3.
	 *   Exception-time espr, sfip, snip, sxip.
	 *   Exception number (EF_VECTOR).
	 *   Dmt0
	 *   Other data pipeline control registers, if appropriate.
	 *   FPU control registers, if appropriate.
	 *   Exception SR3, if appropriate.
	 *
	 * immediate goal:
	 *   restore the system to the exception-time state (except
	 *   SR3 will be OUR stack pointer) so that we may resart the FPU.
	 */

	stcr	TMP,  SSBR	/* done with SSBR, TMP now free */
	RESTORE_TMP2	/* done with extra temp regs */
	RESTORE_TMP3	/* done with extra temp regs */

	/* Get the current PSR and modify for the rte to enable the FPU */
	ldcr	TMP,  PSR
	clr	TMP,  TMP,  1<PSR_FPU_DISABLE_BIT>	/* enable the FPU */
	clr	TMP,  TMP,  1<PSR_SHADOW_FREEZE_BIT>	/* and shadowing */
	stcr	TMP,  EPSR

	/* the "+2" below is to set the VALID_BIT */
	or.u	TMP,  r0,   hi16(_ASM_LABEL(m88100_fpu_enable) + 2)
	or	TMP,  TMP,  lo16(_ASM_LABEL(m88100_fpu_enable) + 2)
	stcr	TMP,  SNIP
	addu	TMP,  TMP,  4
	stcr	TMP,  SFIP

	set	FLAGS, FLAGS, 1<FLAG_ENABLING_FPU>
	xcr	FLAGS, FLAGS, SR1
	st	r1,   r31,  REG_OFF(EF_RET)	/* save the return address */
	ld	r1,   r31,  GENREG_OFF(1)	/* get original r1 */

	xcr	TMP,  r31,  SR3	/* TMP now restored. R31 now saved in SR3 */
	ld	r31,  r31,  GENREG_OFF(31)	/* get original r31 */

	/*
	 * SR1: CPU flags
	 * SR2: free
	 * SR3: pointer to our exception frame (our stack pointer)
	 * r1 through r31: original exception-time values
	 *
	 * Valid in the exception frame:
	 *   Exception-time FLAGS.
	 *   Exception-time espr, sfip, snip, sxip.
	 *   Exception number (EF_VECTOR).
	 *   Dmt0
	 *   Other data pipeline control registers, if appropriate.
	 *   FPU control registers, if appropriate.
	 *   Exception SR3, if appropriate.
	 *   Held temporarly in the exception frame:
	 *   Return address to the calling exception handler.
	 *
	 * immediate goal:
	 *   Do an RTE to restart the fpu and jump to "fpu_enable"
	 *   Another exception (or exceptions) may be raised in
	 *   this, which is why FLAG_ENABLING_FPU is set in SR1.
	 */

	RTE	/* jumps to "m88100_fpu_enable" to enable the FPU. */

ASLOCAL(m88100_fpu_enable)
	FLUSH_PIPELINE
	xcr	TMP,  TMP,  SR3			/* get E.F. pointer */
	st	r30,  TMP,  GENREG_OFF(30)	/* save previous r30, r31 */
	st	r31,  TMP,  GENREG_OFF(31)	/* save previous r30, r31 */
	or	r31,  TMP,  r0			/* transfer E.F. pointer to r31 */
	ld	TMP,  r31,  REG_OFF(EF_SR3)	/* get previous SR3 */

	/* make sure that the FLAG_ENABLING_FPU bit is off */
	xcr	FLAGS,FLAGS,SR1
	clr	FLAGS,FLAGS,1<FLAG_ENABLING_FPU>
	xcr	FLAGS,FLAGS,SR1

	xcr	TMP,  TMP,  SR3	/* replace TMP, SR3 */

	/* now save all regs to the exception frame. */
	st	r0 ,  r31,  GENREG_OFF(0)
	st	r1 ,  r31,  GENREG_OFF(1)
	st	r2 ,  r31,  GENREG_OFF(2)
	st	r3 ,  r31,  GENREG_OFF(3)
	st	r4 ,  r31,  GENREG_OFF(4)
	st	r5 ,  r31,  GENREG_OFF(5)
	st	r6 ,  r31,  GENREG_OFF(6)
	st	r7 ,  r31,  GENREG_OFF(7)
	st	r8 ,  r31,  GENREG_OFF(8)
	st	r9 ,  r31,  GENREG_OFF(9)
	st	r10,  r31,  GENREG_OFF(10)
	st	r11,  r31,  GENREG_OFF(11)
	st	r12,  r31,  GENREG_OFF(12)
	st	r13,  r31,  GENREG_OFF(13)
	st	r14,  r31,  GENREG_OFF(14)
	st	r15,  r31,  GENREG_OFF(15)
	st	r16,  r31,  GENREG_OFF(16)
	st	r17,  r31,  GENREG_OFF(17)
	st	r18,  r31,  GENREG_OFF(18)
	st	r19,  r31,  GENREG_OFF(19)
	st	r20,  r31,  GENREG_OFF(20)
	st	r21,  r31,  GENREG_OFF(21)
	st	r22,  r31,  GENREG_OFF(22)
	st	r23,  r31,  GENREG_OFF(23)
	st	r24,  r31,  GENREG_OFF(24)
	st	r25,  r31,  GENREG_OFF(25)
	st	r26,  r31,  GENREG_OFF(26)
	st	r27,  r31,  GENREG_OFF(27)
	st	r28,  r31,  GENREG_OFF(28)
	st	r29,  r31,  GENREG_OFF(29)

	/* get and save IPL */
	bsr.n	_C_LABEL(getipl)
	 subu	r31, r31, 32
	addu	r31, r31, 32
	st	r2, r31, REG_OFF(EF_MASK)

	/*
	 * SR1: free
	 * SR2: free
	 * SR3: previous exception-time SR3
	 * r1: return address to the calling exception handler
	 * r2 through r30: free
	 * r31: our exception frame
	 *
	 * Valid in the exception frame:
	 *   Exception-time r0 through r31.
	 *   Exception-time FLAGS.
	 *   Exception-time espr, sfip, snip, sxip.
	 *   Exception number (EF_VECTOR).
	 *   Dmt0
	 *   Other data pipeline control registers, if appropriate.
	 *   FPU control registers, if appropriate.
	 *   Exception SR3, if appropriate.
	 *
	 * immediate goal:
	 *   Pick up a stack if we came in from user mode.
	 *   Put a copy of the exception frame pointer into r30
	 *   Bump the stack a doubleword and write the exception frame pointer.
	 *   If not an interrupt exception, turn on interrupts and service any
	 *     outstanding data access exceptions.
	 *   Return to calling exception handler to service the exception.
	 */

	/*
	 * If it's not the interrupt exception, enable interrupts and
	 * take care of any data access exceptions......
	 */
	or	r30,  r0,   r31		/* get a copy of the e.f. pointer */
	ld	r2,   r31,  REG_OFF(EF_EPSR)
	bb1	PSR_SUPERVISOR_MODE_BIT, r2, 1f	/* if in kernel mode */

	or.u	r31,  r0,   hi16(_ASM_LABEL(kstack))
	ld	r31,  r31,  lo16(_ASM_LABEL(kstack))
	addu	r31,  r31,  USIZE	/* point at proper end */
1:

	/*
	 * here - r30 holds a pointer to the exception frame.
	 * r31 is a pointer to the kernel stack/interrupt stack.
	 */
	subu	r31,  r31,  8	/* make some breathing space */
	st	r30,  r31,  0	/* store frame pointer on the stack */
#ifdef DDB
	st	r30,  r31,  4	/* store it for the debugger to recognize */
#endif

	ld	r2,   r30,  REG_OFF(EF_VECTOR)
	bcnd.n	eq0,  r2,   8f			/* error exception */
	 ld	r14,  r30,  REG_OFF(EF_RET)

	/*
	 * Do not process possible data exceptions here if this is an interrupt.
	 * Instead, the interrupt handler will take care of this by itself.
	 */
	cmp	r3,   r2,   1			/* is an interrupt? */
	bb1.n	eq,   r3,   8f			/* skip if so */

#ifdef DDB
	 cmp	r3,   r2,   130	/* DDB break exception */
	bb1.n	eq,   r3,   8f
	 cmp	r3,   r2,   132	/* DDB entry exception */
	bb1.n	eq,   r3,   8f
#endif

	/* turn interrupts back on */
	 ldcr	r2,   PSR
	clr	r2,   r2,   1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r2,   PSR
	FLUSH_PIPELINE

	/* service any outstanding data pipeline stuff */
	ld	r3,   r30,  REG_OFF(EF_DMT0)
	bb0	DMT_VALID_BIT, r3, 8f

	/*
	 * r30 can be clobbered by calls. So stuff its value into a preserved
	 * register, say r15. R14 is in use (see return_to_... below).
	 */
	or	r15,  r0,   r30
	CALL(_C_LABEL(m88100_trap), T_DATAFLT, r15)
	or	r30,  r0,   r15

8:
	jmp	r14	/* loaded above */
#endif /* M88100 */

/*
 * proc_trampoline.
 * When a process setup by cpu_set_kpc() resumes, it will find itself in
 * proc_trampoline, with r31 pointing to a ksigframe. proc_trampoline will
 * load func and proc values from ksigframe, call the function, and on return
 * pop off the ksigframe. Then, it will load pc from the switchframe and
 * jump there.
 */

ENTRY(proc_trampoline)
	ld	r1, r31, 0		/* load func */
	ld	r2, r31, 4 		/* load proc pointer */
	jsr.n	r1
	 subu	r31, r31, 32		/* create stack space for function */
	addu	r31, r31, 32 + 8	/* stack space above + ksigframe */
	ld	r1,  r31, 0		/* load pc */
	ld	r2,  r31, 4		/* & proc pointer from switch frame */
	jsr.n	r1
	 addu	r31, r31, 8

/*
 * proc_do_uret
 * this is called as proc_do_uret(proc) from proc_trampoline(). This function
 * loads r31 with a pointer to the trap frame for the given proc and calls
 * return_code which loads all the registers and does an RTE.
 */

ENTRY(proc_do_uret)
	ld	r3,r2,P_ADDR		/* p->p_addr */
	addu	r3,r3,PCB_USER_STATE	/* p->p_addr.u_pcb.user_state */
	st	r3,r31,0		/* put it on the stack */
#if defined(M88100) && defined(M88110)
#ifdef M88110
	or.u	r2, r0, hi16(_C_LABEL(cputyp))
	ld	r3, r2, lo16(_C_LABEL(cputyp))
	cmp	r2, r3, CPU_88110
	bb1	eq, r2, _ASM_LABEL(m88110_return_code)
	/* br	_ASM_LABEL(m88100_return_code) */
#endif
#endif

	/*
	 * Regs r1-r30 are free. R31 is pointing at the word
	 * on the kernel stack where our pointer to the exception frame
	 * it stored. Reload it now.
	 *
	 * At this point, if EF_DMT0 is not zero on MC88100, then
	 * this must have been an interrupt where the fault didn't
	 * get corrected above.  We'll do that now.
	 *
	 * We load it into r14 since it is preserved across function
	 * calls, and we may have to call some routines from within here.
	 *
	 * Control is transferred here from obvious places in this file.
	 */

#ifdef M88100
ASLOCAL(m88100_return_code)
	/*
	 * if there happens to be a data fault that hasn't been serviced yet,
	 * go off and service that...
	 */

#define	FPTR	r14
	ld	FPTR, r31, 0	/* grab exception frame pointer */
	ld	r3, FPTR, REG_OFF(EF_DMT0)
	bb0	DMT_VALID_BIT, r3, _ASM_LABEL(check_ast)

	/*
	 * If it's the interrupt exception, and interrupts were
	 * initially disabled, enable interrupts again...
	 */
	ld	r2, FPTR, REG_OFF(EF_VECTOR)
	cmp	r2, r2, 1	/* is an interrupt? */
	bb1.n	ne, r2, 1f	/* if not so, skip */

	/* ...unless they were already disabled */
	 ld	r2, FPTR, REG_OFF(EF_EPSR)
	bb1.n	PSR_INTERRUPT_DISABLE_BIT, r2, 1f

	 ldcr	r2, PSR
	clr	r2, r2, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r2, PSR
	FLUSH_PIPELINE
1:

	CALL(_C_LABEL(m88100_trap), T_DATAFLT, r30)
#ifdef M88110
	br	_ASM_LABEL(check_ast)
#else
	/* FALLTHROUGH */
#endif
#endif /* M88100 */

#ifdef M88110
ASLOCAL(m88110_return_code)
#define	FPTR	r14
	ld	FPTR, r31, 0	/* grab exception frame pointer */
	/* FALLTHROUGH */
#endif /* M88110 */

/*
 *   If the saved ipl is 0, then call dosoftint() to process soft
 *   interrupts.
 *   If returning to user land, look for ASTs
 */
ASLOCAL(check_ast)
	ld	r2, FPTR, REG_OFF(EF_EPSR)	/* get pre-exception PSR */
	bb1	PSR_INTERRUPT_DISABLE_BIT, r2, 1f	/* skip if ints off */
	ld	r2, FPTR, REG_OFF(EF_MASK)	/* get pre-exception ipl */
	bcnd	ne0, r2, 1f		/* can't do softint's */

	subu	r31, r31, 32
	bsr.n	_C_LABEL(setipl)
	 or	r2, r0, IPL_SOFTCLOCK
	/* at ipl 1 now */
	bsr	_C_LABEL(dosoftint)
	/* is this needed? we are going to restore the ipl below XXX nivas */
	bsr.n	_C_LABEL(setipl)
	 or	r2, r0, IPL_NONE		/* ints are enabled */
	addu	r31, r31, 32
	/* at ipl 0 now */
1:
	ld	r2, FPTR, REG_OFF(EF_EPSR)	/* get pre-exception PSR */
	bb1	PSR_SUPERVISOR_MODE_BIT, r2, no_ast	/*skip if system mode */

	/* should assert here - not in user mode with ints off XXX nivas */
	/* get and check want_ast */
	or.u	r2, r0, hi16(_C_LABEL(want_ast))
	ld	r3, r2, lo16(_C_LABEL(want_ast))
	bcnd	eq0, r3, no_ast

	/*
	 * trap(AST,...) will service ast's.
	 */
#if defined(M88110) && defined(M88100)
	or.u	r2, r0, hi16(_C_LABEL(cputyp))
	ld	r3, r2, lo16(_C_LABEL(cputyp))
	cmp	r2, r3, CPU_88110
	bb0	eq, r2, 2f
#endif
#if defined(M88110)
	CALL(_C_LABEL(m88110_trap), T_ASTFLT, FPTR)
#endif
#if defined(M88110) && defined(M88100)
	br	no_ast
2:
#endif
#ifdef M88100
	CALL(_C_LABEL(m88100_trap), T_ASTFLT, FPTR)
#endif

ASLOCAL(no_ast)
	/* disable interrupts */
	ldcr	r1, PSR
	set	r1, r1, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r1, PSR
	FLUSH_PIPELINE

	/* now ready to return....*/
	subu	r31, r31, 32
	bsr.n	_C_LABEL(setipl)
	 ld	r2, FPTR, REG_OFF(EF_MASK)	/* get pre-exception ipl */
	addu	r31, r31, 32

	/*
	 * Transfer the frame pointer to r31, since we no longer need a stack.
	 * No page faults here, and interrupts are disabled.
	 */
	or	r31, r0,  FPTR
	/* restore r1 later */
	ld	r2 , r31, GENREG_OFF(2)
	ld	r3 , r31, GENREG_OFF(3)
	ld	r4 , r31, GENREG_OFF(4)
	ld	r5 , r31, GENREG_OFF(5)
	ld	r6 , r31, GENREG_OFF(6)
	ld	r7 , r31, GENREG_OFF(7)
	ld	r8 , r31, GENREG_OFF(8)
	ld	r9 , r31, GENREG_OFF(9)
	ld	r10, r31, GENREG_OFF(10)
	ld	r11, r31, GENREG_OFF(11)
	ld	r12, r31, GENREG_OFF(12)
	ld	r13, r31, GENREG_OFF(13)
	ld	r14, r31, GENREG_OFF(14)
	ld	r15, r31, GENREG_OFF(15)
	ld	r16, r31, GENREG_OFF(16)
	ld	r17, r31, GENREG_OFF(17)
	ld	r18, r31, GENREG_OFF(18)
	ld	r19, r31, GENREG_OFF(19)
	ld	r20, r31, GENREG_OFF(20)
	ld	r21, r31, GENREG_OFF(21)
	ld	r22, r31, GENREG_OFF(22)
	ld	r23, r31, GENREG_OFF(23)
	ld	r24, r31, GENREG_OFF(24)
	ld	r25, r31, GENREG_OFF(25)
	ld	r26, r31, GENREG_OFF(26)
	ld	r27, r31, GENREG_OFF(27)
	ld	r28, r31, GENREG_OFF(28)
	ld	r29, r31, GENREG_OFF(29)
	/* restore r1, r30, r31 later */

	/* disable shadowing */
	ldcr	r1, PSR
	set	r1, r1, 1<PSR_SHADOW_FREEZE_BIT>
	stcr	r1, PSR
	FLUSH_PIPELINE

	/* reload the control regs*/
#ifdef M88110
#ifdef M88100
	or.u	r1, r0, hi16(_C_LABEL(cputyp))
	ld	r30, r1, lo16(_C_LABEL(cputyp))
	cmp	r1, r30, CPU_88110
	bb1	ne, r1, 1f
#endif
	ld	r30, r31, REG_OFF(EF_ENIP)
	ld	r1,  r31, REG_OFF(EF_EXIP)
	stcr	r30, ENIP
	stcr	r1,  EXIP
#ifdef M88100
	br	2f
1:
#endif
#endif
#ifdef M88100
	/*
	 * RTE will cause execution to continue first with the
	 * instruction pointed to by the NIP and then the FIP;
	 * it is not necessary to restore XIP.
	 */
	stcr	r0,  SSBR
	ld	r30, r31, REG_OFF(EF_SNIP)
	ld	r1,  r31, REG_OFF(EF_SFIP)
	stcr	r30, SNIP
	stcr	r1,  SFIP
2:
#endif
	ld	r30, r31, REG_OFF(EF_EPSR)
	stcr	r30, EPSR

	/* Now restore r1, r30, and r31 */
	ld	r1,  r31, GENREG_OFF(1)
	ld	r30, r31, GENREG_OFF(30)
	ld	r31, r31, GENREG_OFF(31)

	RTE

#ifdef M88110
/*
 * MVME197 exception handlers
 */

/* unknown exception handler */
GLOBAL(m88110_unknown_handler)
	PREP88110("unknown", 0, DEBUG_UNKNOWN_BIT,)
	CALL(_C_LABEL(m88110_trap), T_UNKNOWNFLT, r30)
	DONE88110(DEBUG_UNKNOWN_BIT)

/* interrupt exception handler */
GLOBAL(m88110_interrupt_handler)
	PREP88110("interrupt", 1, DEBUG_INTERRUPT_BIT,)
	CALL(_C_LABEL(m88110_trap), T_INT, r30)
	DONE88110(DEBUG_INTERRUPT_BIT)

/* instruction access exception handler */
GLOBAL(m88110_instruction_access_handler)
	PREP88110("inst", 2, DEBUG_INSTRUCTION_BIT,)
	CALL(_C_LABEL(m88110_trap), T_INSTFLT, r30)
	DONE88110(DEBUG_INSTRUCTION_BIT)
/*
 * data access exception handler --
 *  See badaddr() below for info about Data_Precheck.
 */
GLOBAL(m88110_data_exception_handler)
	PREP88110("data", 3, DEBUG_DATA_BIT, M88110_Data_Precheck)
	CALL(_C_LABEL(m88110_trap), T_DATAFLT, r30)
	DONE88110(DEBUG_DATA_BIT)

/* misaligned access exception handler */
GLOBAL(m88110_misaligned_handler)
	PREP88110("misalign", 4, DEBUG_MISALIGN_BIT,)
	CALL(_C_LABEL(m88110_trap), T_MISALGNFLT, r30)
	DONE88110(DEBUG_MISALIGN_BIT)

/* unimplemented opcode exception handler */
GLOBAL(m88110_unimplemented_handler)
	PREP88110("unimp", 5, DEBUG_UNIMPLEMENTED_BIT,)
	CALL(_C_LABEL(m88110_trap), T_ILLFLT, r30)
	DONE88110(DEBUG_UNIMPLEMENTED_BIT)

/* privilege exception handler */
GLOBAL(m88110_privilege_handler)
	PREP88110("privilege", 6, DEBUG_PRIVILEGE_BIT,)
	CALL(_C_LABEL(m88110_trap), T_PRIVINFLT, r30)
	DONE88110(DEBUG_PRIVILEGE_BIT)

/*
 * I'm not sure what the trap(T_BNDFLT,...) does, but it doesn't send
 * a signal to the process...
 */
GLOBAL(m88110_bounds_handler)
	PREP88110("bounds", 7, DEBUG_BOUNDS_BIT,)
	CALL(_C_LABEL(m88110_trap), T_BNDFLT, r30)
	DONE88110(DEBUG_BOUNDS_BIT)

/* integer divide-by-zero exception handler */
GLOBAL(m88110_divide_handler)
	PREP88110("divide", 8, DEBUG_DIVIDE_BIT,)
	CALL(_C_LABEL(m88110_trap), T_ZERODIV, r30)
	DONE88110(DEBUG_DIVIDE_BIT)

/* integer overflow exception handler */
GLOBAL(m88110_overflow_handler)
	PREP88110("overflow", 9, DEBUG_OVERFLOW_BIT,)
	CALL(_C_LABEL(m88110_trap), T_OVFFLT, r30)
	DONE88110(DEBUG_OVERFLOW_BIT)

/* Floating-point precise handler */
GLOBAL(m88110_fp_precise_handler)
	PREP88110("FPU precise", 114, DEBUG_FPp_BIT,)
	CALL(_ASM_LABEL(m88110_Xfp_precise), r0, r30)
	DONE88110(DEBUG_FPp_BIT)

/* MVME197 non-maskable interrupt handler (ABORT button) */
GLOBAL(m88110_nonmaskable)
	PREP88110("MVME197 non-mask", 11, DEBUG_NON_MASK_BIT,)
	CALL(_C_LABEL(m88110_trap), T_NON_MASK, r30)
	DONE88110(DEBUG_NON_MASK_BIT)

/* MVME197 data MMU read miss handler */
GLOBAL(m88110_data_read_miss)
	PREP88110("MVME197 read miss", 12, DEBUG_197_READ_BIT,)
	CALL(_C_LABEL(m88110_trap), T_197_READ, r30)
	DONE88110(DEBUG_197_READ_BIT)

/* MVME197 data MMU write miss handler */
GLOBAL(m88110_data_write_miss)
	PREP88110("MVME197 write miss", 13, DEBUG_197_WRITE_BIT,)
	CALL(_C_LABEL(m88110_trap), T_197_WRITE, r30)
	DONE88110(DEBUG_197_WRITE_BIT)

/* MVME197 inst MMU ATC miss handler */
GLOBAL(m88110_inst_atc_miss)
	PREP88110("MVME197 inst miss", 14, DEBUG_197_INST_BIT,)
	CALL(_C_LABEL(m88110_trap), T_197_INST, r30)
	DONE88110(DEBUG_197_INST_BIT)

/* All standard system calls.  */
GLOBAL(m88110_syscall_handler)
	PREP88110("syscall", 128, DEBUG_SYSCALL_BIT,)
	ld	r13, r30, GENREG_OFF(13)
	CALL(_C_LABEL(m88110_syscall), r13, r30)
	DONE88110(DEBUG_SYSCALL_BIT)

/* trap 496 comes here */
GLOBAL(m88110_bugtrap)
	PREP88110("bugsyscall", 496, DEBUG_BUGCALL_BIT,)
	ld	r9,  r30, GENREG_OFF(9)
	CALL(_C_LABEL(bugsyscall), r9, r30)
	DONE88110(DEBUG_BUGCALL_BIT)

GLOBAL(m88110_sigsys)
	PREP88110("sigsys", 501, DEBUG_SIGSYS_BIT,)
	CALL(_C_LABEL(m88110_trap), T_SIGSYS, r30)
	DONE88110(DEBUG_SIGSYS_BIT)

GLOBAL(m88110_sigtrap)
	PREP88110("sigtrap", 510, DEBUG_SIGTRAP_BIT,)
	CALL(_C_LABEL(m88110_trap), T_SIGTRAP, r30)
	DONE88110(DEBUG_SIGTRAP_BIT)

GLOBAL(m88110_stepbpt)
	PREP88110("stepbpt", 504, DEBUG_SIGTRAP_BIT,)
	CALL(_C_LABEL(m88110_trap), T_STEPBPT, r30)
	DONE88110(DEBUG_SIGTRAP_BIT)

GLOBAL(m88110_userbpt)
	PREP88110("userbpt", 511, DEBUG_SIGTRAP_BIT,)
	CALL(_C_LABEL(m88110_trap), T_USERBPT, r30)
	DONE88110(DEBUG_SIGTRAP_BIT)

#ifdef DDB
GLOBAL(m88110_break)
	PREP88110("break", 130, DEBUG_BREAK_BIT,)
	CALL(_C_LABEL(m88110_trap), T_KDB_BREAK, r30)
	DONE88110(DEBUG_BREAK_BIT)

GLOBAL(m88110_trace)
	PREP88110("trace", 131, DEBUG_TRACE_BIT,)
	CALL(_C_LABEL(m88110_trap), T_KDB_TRACE, r30)
	DONE88110(DEBUG_TRACE_BIT)

GLOBAL(m88110_entry)
	PREP88110("kdb", 132, DEBUG_KDB_BIT,)
	CALL(_C_LABEL(m88110_trap), T_KDB_ENTRY, r30)
	DONE88110(DEBUG_KDB_BIT)
#else
GLOBAL(m88110_break)
	PREP88110("break", 130, DEBUG_BREAK_BIT,)
	CALL(_C_LABEL(m88110_trap), T_UNKNOWNFLT, r30)
	DONE88110(DEBUG_BREAK_BIT)

GLOBAL(m88110_trace)
	PREP88110("trace", 131, DEBUG_TRACE_BIT,)
	CALL(_C_LABEL(m88110_trap), T_UNKNOWNFLT, r30)
	DONE88110(DEBUG_TRACE_BIT)

GLOBAL(m88110_entry)
	PREP88110("unknown", 132, DEBUG_KDB_BIT,)
	CALL(_C_LABEL(m88110_trap), T_UNKNOWNFLT, r30)
	DONE88110(DEBUG_KDB_BIT)
#endif

/*
 * The error exception and reset exception handler.
 *
 * The error exception is raised when any other non-trap exception is raised
 * while shadowing is off. This is Bad News.
 *
 * The reset exception is raised when the RST signal is asserted (machine
 * is reset), the value of VBR is changed after exceptions are enabled,
 * or when a jmp, br/bsr to addr 0 (accidents do happen :-)
 * Upon a real reset, VBR is set to zero (0), so code must be at addr 0
 * to handle it!!!
 *
 * The shadow registers are not valid in this case (shadowing was off, if this
 * was an error exception, and may not be on, if this was a reset exception).
 * R1-R31 may be interesting though, so we'll save them.
 *
 * We'll not worry about trashing r26-29 here,
 * since they aren't generally used.
 */
GLOBAL(m88110_error_handler)
	br.n	1f
	 or	r29, r0, 10
GLOBAL(m88110_reset_handler)
	or	r29, r0, 0
1:
	/* pick up the slavestack */
	or	r26, r0, r31	/* save old stack */
	or.u	r31, r0,  hi16(_ASM_LABEL(intstack_end))
	or	r31, r31, lo16(_ASM_LABEL(intstack_end))

#ifdef DEBUG
	/* zero the stack, so we'll know what we're lookin' at */
	or.u	r27, r0,  hi16(_C_LABEL(intstack))
	or	r27, r27, lo16(_C_LABEL(intstack))
1:	cmp	r28, r27, r31
	bb1	ge,  r28, 2f	/* branch if at the end of the stack */
	st	r0,  r0,  r27
	br.n	1b
	 addu	r27, r27, 4	/* bump up */
2:	/* stack has been cleared */
#endif

	/* ensure that stack is 8-byte aligned */
	clr	r31, r31, 3<0>	/* round down to 8-byte boundary */

	/* create exception frame on stack */
	subu	r31, r31, SIZEOF_EF		/* r31 now our E.F. */

	/* save old R31 and other R registers */
	st.d	r0 , r31, GENREG_OFF(0)
	st.d	r2 , r31, GENREG_OFF(2)
	st.d	r4 , r31, GENREG_OFF(4)
	st.d	r6 , r31, GENREG_OFF(6)
	st.d	r8 , r31, GENREG_OFF(8)
	st.d	r10, r31, GENREG_OFF(10)
	st.d	r12, r31, GENREG_OFF(12)
	st.d	r14, r31, GENREG_OFF(14)
	st.d	r16, r31, GENREG_OFF(16)
	st.d	r18, r31, GENREG_OFF(18)
	st.d	r20, r31, GENREG_OFF(20)
	st.d	r22, r31, GENREG_OFF(22)
	st.d	r24, r31, GENREG_OFF(24)
	st	r30, r31, GENREG_OFF(30)
	st	r26, r31, GENREG_OFF(31)

	/* vector is put in SRO (either 0 or 10 at this point) */
	st	r29, r31, REG_OFF(EF_VECTOR)
	cmp	r29, r29, 0	/* is it the reset exception? */
	bb1.n	ne,  r29, 1f	/* if not, skip */

	/* save shadow registers (are OLD if error_handler, though) */
	 ldcr	r10, EPSR
	st	r10, r31, REG_OFF(EF_EPSR)
	ldcr	r10, EXIP
	st	r10, r31, REG_OFF(EF_EXIP)
	ldcr	r10, ENIP
	st	r10, r31, REG_OFF(EF_ENIP)
	ldcr	r10, DSR
	st	r10, r31, REG_OFF(EF_DSR)
	ldcr	r10, DLAR
	st	r10, r31, REG_OFF(EF_DLAR)
	ldcr	r10, DPAR
	st	r10, r31, REG_OFF(EF_DPAR)
	ldcr	r10, ISR
	st	r10, r31, REG_OFF(EF_ISR)
	ldcr	r10, ILAR
	st	r10, r31, REG_OFF(EF_ILAR)
	ldcr	r10, IPAR
	st	r10, r31, REG_OFF(EF_IPAR)
	ldcr	r10, SR1
	br.n	2f
	 st	r10, r31, REG_OFF(EF_MODE)

1:
	/* retrieve saved shadow registers for error_handler, though) */
	or.u	r30, r0,  hi16(_ASM_LABEL(save_frame))
	or	r30, r30, lo16(_ASM_LABEL(save_frame))
	ld	r10, r30, REG_OFF(EF_EPSR)
	st	r10, r31, REG_OFF(EF_EPSR)
	ld	r10, r30, REG_OFF(EF_EXIP)
	st	r10, r31, REG_OFF(EF_EXIP)
	ld	r10, r30, REG_OFF(EF_ENIP)
	st	r10, r31, REG_OFF(EF_ENIP)
	ld	r10, r30, REG_OFF(EF_DSR)
	st	r10, r31, REG_OFF(EF_DSR)
	ld	r10, r30, REG_OFF(EF_DLAR)
	st	r10, r31, REG_OFF(EF_DLAR)
	ld	r10, r30, REG_OFF(EF_DPAR)
	st	r10, r31, REG_OFF(EF_DPAR)
	ld	r10, r30, REG_OFF(EF_ISR)
	st	r10, r31, REG_OFF(EF_ISR)
	ld	r10, r30, REG_OFF(EF_ILAR)
	st	r10, r31, REG_OFF(EF_ILAR)
	ld	r10, r30, REG_OFF(EF_IPAR)
	st	r10, r31, REG_OFF(EF_IPAR)
	ld	r10, r30, REG_OFF(EF_ISAP)
	st	r10, r31, REG_OFF(EF_ISAP)
	ld	r10, r30, REG_OFF(EF_DSAP)
	st	r10, r31, REG_OFF(EF_DSAP)
	ld	r10, r30, REG_OFF(EF_IUAP)
	st	r10, r31, REG_OFF(EF_IUAP)
	ld	r10, r30, REG_OFF(EF_DUAP)
	st	r10, r31, REG_OFF(EF_DUAP)
	ldcr	r10, SR1
	st	r10, r31, REG_OFF(EF_MODE)
2:
	/* shove sr2 into EF_FPLS1 */
	ldcr	r10, SR2
	st	r10, r31, REG_OFF(EF_FPLS1)

	/* shove sr3 into EF_FPHS2 */
	ldcr	r10, SR3
	st	r10, r31, REG_OFF(EF_FPHS2)

	/*
	 * Cheap way to enable FPU and start shadowing again.
	 */
	ldcr	r10, PSR
	clr	r10, r10, 1<PSR_FPU_DISABLE_BIT>	/* enable the FPU */
	clr	r10, r10, 1<PSR_SHADOW_FREEZE_BIT>	/* and shadowing */
	stcr	r10, PSR
	FLUSH_PIPELINE

	/* put pointer to regs into r30... r31 will become a simple stack */
	or	r30, r31, r0

	subu	r31, r31, 0x10	/* make some breathing space */
	st	r30, r31, 0x0c	/* store frame pointer on the stack */
#ifdef DDB
	st	r30, r31, 0x08	/* store again for the debugger to recognize */
	or.u	r20,  r0, hi16(0x87654321)
	or	r20, r20, lo16(0x87654321)
	st	r20, r31, 0x04
	st	r20, r31, 0x00
#endif

	CALL(_C_LABEL(error_fatal), r30, r30)

	/* turn interrupts back on */
	ldcr	r1, PSR
	clr	r1, r1, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r1, PSR
	FLUSH_PIPELINE

1:
	br	1b
	/* NOTREACHED */

ASLOCAL(m88110_setup_phase_one)
	/*
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: saved copy of exception-time r1
	 * SR3: must be preserved .. may be the exception-time stack
	 * r1: return address to calling exception handler
	 * FLAGS: CPU status flags
	 *
	 * immediate goal:
	 *   Decide where we're going to put the exception frame.
	 *   Might be at the end of R31, SR3, or the process pcb.
	 */

	/* Check if we are coming in from a FPU restart exception.
	   If so, the pcb will be in SR3 */
	NOP
	xcr	r1,   r1,   SR2
	NOP
	NOP
	NOP

	bb1	FLAG_ENABLING_FPU, FLAGS, _ASM_LABEL(m88110_use_SR3_pcb)
	/* are we coming in from user mode? If so, pick up process pcb */
	bb0	FLAG_FROM_KERNEL, FLAGS, _ASM_LABEL(m88110_pickup_stack)

	/* Interrupt in kernel mode, not FPU restart */
	/*
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: return address to the calling exception handler
	 * SR3: must be preserved; may be important for other exceptions
	 * FLAGS: CPU status flags
	 *
	 * immediate goal:
	 *   We're already on the kernel stack, but not having
	 *   needed to use SR3. We can just make room on the
	 *   stack (r31) for our exception frame.
	 */
	subu	r31,  r31,  SIZEOF_EF		/* r31 now our E.F. */
	st	FLAGS,r31,  REG_OFF(EF_FLAGS)	/* save flags */
	st	r1,   r31,  GENREG_OFF(1)	/* save prev. r1 (now free) */

	ldcr	r1,   SR3			/* save previous SR3 */
	st	r1,   r31,  REG_OFF(EF_SR3)

	addu	r1,   r31,  SIZEOF_EF		/* save previous r31 */
	br.n	_ASM_LABEL(m88110_have_pcb)
	 st	r1,   r31,  GENREG_OFF(31)

ASLOCAL(m88110_use_SR3_pcb)
	/*
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: return address to the calling exception handler
	 * SR3: must be preserved; exception-time stack pointer
	 * FLAGS: CPU status flags
	 *
	 * immediate goal:
	 *   An exception occurred while enabling the FPU. Since r31 is the
	 *   user's r31 while enabling the FPU, we had put our pcb pointer
	 *   into SR3, so make room from there for our stack pointer.
	 *   We need to check if SR3 is the old stack pointer or the pointer
	 *   off to the user pcb. If it pointing to the user pcb, we need to
	 *   pick up the kernel stack. Otherwise we need to allocate a frame
	 *   upon it.
	 *   We look at the EPSR to see if it was from user mode
	 *   Unfortunately, we have no registers free at the moment, but we
	 *   know register 0 in the pcb frame will always be zero, so we can
	 *   use it as scratch storage.
	 */
#if 1
	ldcr	TMP,  PSR
	clr	TMP,  TMP,  1<PSR_FPU_DISABLE_BIT>	/* enable the FPU */
	clr	TMP,  TMP,  1<PSR_SHADOW_FREEZE_BIT>	/* and shadowing */
	stcr	TMP,  EPSR

	or.u	TMP,  r0,   hi16(_C_LABEL(m88110_error_handler))
	or	TMP,  TMP,  lo16(_C_LABEL(m88110_error_handler))
	stcr	TMP,  EXIP

	RTE
#else
	/* Testing!!! */
	xcr	r30,  r30,  SR3			/* r30 = old exception frame */
	st	r1,   r30,  GENREG_OFF(0)	/* free up r1 */
	ld	r1,   r30,  REG_OFF(EF_EPSR)	/* get back the epsr */
	bb0.n	PSR_SUPERVISOR_MODE_BIT, r1, 1f	/* if user mode */
	 ld	r1,   r30,  GENREG_OFF(0)	/* restore r1 */
	/* we were in kernel mode - dump frame upon the stack */
	st	r0,   r30,  GENREG_OFF(0)	/* repair old frame */
	subu	r30,  r30,  SIZEOF_EF		/* r30 now our E.F. */
	st	FLAGS,r30,  REG_OFF(EF_FLAGS)	/* save flags */
	st	r1,   r30,  GENREG_OFF(1)	/* save prev. r1 (now free) */

	st	r31,  r30,  GENREG_OFF(31)	/* save previous r31 */
	or	r31,  r0,   r30			/* make r31 our pointer. */
	addu	r30,  r30,  SIZEOF_EF		/* r30 now has previous SR3 */
	st	r30,  r31,  REG_OFF(EF_SR3)	/* save previous SR3 */
	br.n	_ASM_LABEL(m88110_have_pcb)
	 xcr	r30,  r30,  SR3			/* restore r30 */
1:
	/*
	 * We took an exception while restarting the FPU from user space.
	 * Consequently, we never picked up a stack. Do so now.
	 * R1 is currently free (saved in the exception frame pointed at by
	 * r30)
	 */
	or.u	r1,   r0,   hi16(_ASM_LABEL(kstack))
	ld	r1,   r1,   lo16(_ASM_LABEL(kstack))
	addu	r1,   r1,   USIZE-SIZEOF_EF
	st	FLAGS,r1,   REG_OFF(EF_FLAGS)	/* store flags */
	st	r31,  r1,   GENREG_OFF(31)	/* store r31 - now free */
	st	r30,  r1,   REG_OFF(EF_SR3)	/* store old SR3 (pcb) */
	or	r31,  r1,   r0			/* make r31 our exception fp */
	ld	r1,   r30,  GENREG_OFF(0)	/* restore old r1 */
	st	r0,   r30,  GENREG_OFF(0)	/* repair that frame */
	st	r1,   r31,  GENREG_OFF(1)	/* store r1 */
	br.n	_ASM_LABEL(m88110_have_pcb)
	 xcr	r30,  r30,  SR3			/* restore r30 */
#endif

ASLOCAL(m88110_pickup_stack)
	/*
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: return address to the calling exception handler
	 * SR3: free
	 * FLAGS: CPU status flags
	 *
	 * immediate goal:
	 *   Since we're servicing an exception from user mode, we
	 *   know that SR3 is free.  We use it to free up a temporary
	 *   register to be used in getting the process pcb.
	 */
	stcr	r31,  SR3	/* save previous r31 */

	/* switch to the process kernel stack. */
	or.u	r31,  r0,   hi16(_C_LABEL(curpcb))
	ld	r31,  r31,  lo16(_C_LABEL(curpcb))
	addu	r31,  r31,  PCB_USER_STATE	/* point to user save area */
	st	FLAGS,r31,  REG_OFF(EF_FLAGS)	/* save flags */
	st	r1,   r31,  GENREG_OFF(1)	/* save prev. r1 (now free)*/
	ldcr	r1,   SR3			/* save previous r31 */
	st	r1,   r31,  GENREG_OFF(31)
	/* FALLTHROUGH */

ASLOCAL(m88110_have_pcb)
	/*
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: return address to the calling exception handler
	 * SR3: free
	 * r1:  free
	 * FLAGS: CPU status flags
	 * r31: our exception frame
	 * Valid in the exception frame:
	 *   Exception-time r1, r31, FLAGS.
	 *   Exception SR3, if appropriate.
	 *
	 * immediate goal:
	 *   Save the shadow registers that need to be saved to
	 *   the exception frame.
	 */
	stcr	TMP, SR3	/* free up TMP, TMP2, TMP3 */
	SAVE_TMP2
	SAVE_TMP3

	/* save some exception-time registers to the exception frame */
	ldcr	TMP,  EPSR
	st	TMP,  r31,  REG_OFF(EF_EPSR)
	ldcr	TMP2, EXIP
	ldcr	TMP3, ENIP
	st	TMP2, r31,  REG_OFF(EF_EXIP)
	st	TMP3, r31,  REG_OFF(EF_ENIP)

	/* get and store the cpu number */
	extu	TMP,  FLAGS,  FLAG_CPU_FIELD_WIDTH<0>	/* TMP = cpu# */
	st	TMP,  r31,  REG_OFF(EF_CPU)

	/*
	 * Save fault status registers from CMMU.
	 */
	ldcr	TMP,  ISR
	ldcr	TMP2, ILAR
	ldcr	TMP3, IPAR
	st	TMP,  r31,  REG_OFF(EF_ISR)
	st	TMP2, r31,  REG_OFF(EF_ILAR)
	st	TMP3, r31,  REG_OFF(EF_IPAR)
	ldcr	TMP,  ISAP
	ldcr	TMP2, IUAP
	st	TMP,  r31,  REG_OFF(EF_ISAP)
	st	TMP2, r31,  REG_OFF(EF_IUAP)
	ldcr	TMP,  DSR
	ldcr	TMP2, DLAR
	ldcr	TMP3, DPAR
	st	TMP,  r31,  REG_OFF(EF_DSR)
	st	TMP2, r31,  REG_OFF(EF_DLAR)
	st	TMP3, r31,  REG_OFF(EF_DPAR)
	ldcr	TMP,  DSAP
	ldcr	TMP2, DUAP
	st	TMP,  r31,  REG_OFF(EF_DSAP)
	st	TMP2, r31,  REG_OFF(EF_DUAP)

	stcr	r0, ISR
	stcr	r0, DSR

	ldcr	r1,   SR2
	jmp	r1

ASLOCAL(m88110_setup_phase_two)
	/*
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: free
	 * SR3: saved TMP
	 * r1:  return address to calling exception handler
	 * TMP2: free
	 * TMP3: free
	 * FLAGS: CPU status flags
	 * r31: our exception frame
	 * Valid in the exception frame:
	 *   Exception-time r1, r31, FLAGS.
	 *   Exception-time TMP2, TMP3.
	 *   Exception-time espr, enip, exip.
	 *   Exception number (EF_VECTOR).
	 *   Dmt0
	 *   Other data pipeline control registers, if appropriate.
	 *   FPU control registers, if appropriate.
	 *   Exception SR3, if appropriate.
	 *
	 * immediate goal:
	 *   restore the system to the exception-time state (except SR3 will
	 *   be OUR stack pointer) so that we may resart the FPU.
	 */

	RESTORE_TMP2	/* done with extra temp regs */
	RESTORE_TMP3	/* done with extra temp regs */

	ldcr	TMP,  PSR
	clr	TMP,  TMP,  1<PSR_FPU_DISABLE_BIT>	/* enable the FPU */
	clr	TMP,  TMP,  1<PSR_SHADOW_FREEZE_BIT>	/* and shadowing */
	stcr	TMP,  EPSR

	or.u	TMP,  r0,   hi16(_ASM_LABEL(m88110_fpu_enable))
	or	TMP,  TMP,  lo16(_ASM_LABEL(m88110_fpu_enable))
	stcr	TMP,  EXIP

	set	FLAGS, FLAGS, 1<FLAG_ENABLING_FPU>
	xcr	FLAGS, FLAGS, SR1
	st	r1,   r31,  REG_OFF(EF_RET)	/* save the return address */
	ld	r1,   r31,  GENREG_OFF(1)	/* get original r1 */

	xcr	TMP,  r31, SR3	/* TMP now restored. R31 now saved in SR3 */
	ld	r31,  r31,  GENREG_OFF(31)	/* get original r31 */

	/*
	 * SR1: CPU flags
	 * SR2: free
	 * SR3: pointer to our exception frame (our stack pointer)
	 * r1 through r31: original exception-time values
	 *
	 * Valid in the exception frame:
	 *   Exception-time FLAGS.
	 *   Exception-time espr, sfip, enip, exip.
	 *   Exception number (EF_VECTOR).
	 *   Dmt0
	 *   Other data pipeline control registers, if appropriate.
	 *   FPU control registers, if appropriate.
	 *   Exception SR3, if appropriate.
	 * Held temporarily in the exception frame:
	 *   Return address to the calling exception handler.
	 *
	 * immediate goal:
	 *   Do an RTE to restart the fpu and jump to "fpu_enable"
	 *   Another exception (or exceptions) may be raised in
	 *   this, which is why FLAG_ENABLING_FPU is set in SR1.
	 */
	RTE	/* jumps to "m88110_fpu_enable" to enable the FPU. */

ASLOCAL(m88110_fpu_enable)
	FLUSH_PIPELINE

	xcr	TMP,  TMP,  SR3			/* get E.F. pointer */
	st	r30,  TMP,  GENREG_OFF(30)	/* save previous r30, r31 */
	st	r31,  TMP,  GENREG_OFF(31)	/* save previous r30, r31 */
	or	r31,  TMP,  r0			/* transfer E.F. pointer */
	ld	TMP,  r31,  REG_OFF(EF_SR3)	/* get previous SR3 */

	/* make sure that the FLAG_ENABLING_FPU bit is off */
	xcr	FLAGS,FLAGS,SR1
	clr	FLAGS,FLAGS,1<FLAG_ENABLING_FPU>
	xcr	FLAGS,FLAGS,SR1

	xcr	TMP,  TMP,  SR3	/* replace TMP, SR3 */

	/* now save all regs to the exception frame. */
	st	r0 ,  r31,  GENREG_OFF(0)
	st	r1 ,  r31,  GENREG_OFF(1)
	st	r2 ,  r31,  GENREG_OFF(2)
	st	r3 ,  r31,  GENREG_OFF(3)
	st	r4 ,  r31,  GENREG_OFF(4)
	st	r5 ,  r31,  GENREG_OFF(5)
	st	r6 ,  r31,  GENREG_OFF(6)
	st	r7 ,  r31,  GENREG_OFF(7)
	st	r8 ,  r31,  GENREG_OFF(8)
	st	r9 ,  r31,  GENREG_OFF(9)
	st	r10,  r31,  GENREG_OFF(10)
	st	r11,  r31,  GENREG_OFF(11)
	st	r12,  r31,  GENREG_OFF(12)
	st	r13,  r31,  GENREG_OFF(13)
	st	r14,  r31,  GENREG_OFF(14)
	st	r15,  r31,  GENREG_OFF(15)
	st	r16,  r31,  GENREG_OFF(16)
	st	r17,  r31,  GENREG_OFF(17)
	st	r18,  r31,  GENREG_OFF(18)
	st	r19,  r31,  GENREG_OFF(19)
	st	r20,  r31,  GENREG_OFF(20)
	st	r21,  r31,  GENREG_OFF(21)
	st	r22,  r31,  GENREG_OFF(22)
	st	r23,  r31,  GENREG_OFF(23)
	st	r24,  r31,  GENREG_OFF(24)
	st	r25,  r31,  GENREG_OFF(25)
	st	r26,  r31,  GENREG_OFF(26)
	st	r27,  r31,  GENREG_OFF(27)
	st	r28,  r31,  GENREG_OFF(28)
	st	r29,  r31,  GENREG_OFF(29)

	/* get and save IPL */
	bsr.n	_C_LABEL(getipl)
	 subu	r31, r31, 32
	addu	r31, r31, 32
	st	r2, r31, REG_OFF(EF_MASK)

	/*
	 * SR1: free
	 * SR2: free
	 * SR3: previous exception-time SR3
	 * r1: return address to the calling exception handler
	 * r2 through r30: free
	 * r31: our exception frame
	 *
	 * Valid in the exception frame:
	 *   Exception-time r0 through r31.
	 *   Exception-time FLAGS.
	 *   Exception-time espr, enip, exip.
	 *   Exception number (EF_VECTOR).
	 *   DSR
	 *   Other data pipeline control registers, if appropriate.
	 *   FPU control registers, if appropriate.
	 *   Exception SR3, if appropriate.
	 *
	 * immediate goal:
	 *   Pick up a stack if we came in from user mode.
	 *   Put a copy of the exception frame pointer into r30
	 *   Bump the stack a doubleword and write the exception frame pointer.
	 *   If not an interrupt exception, turn on interrupts and service any
	 *     outstanding data access exceptions.
	 *   Return to calling exception handler to service the exception.
	 */

	/*
	 * If it's not the interrupt exception, enable interrupts and
	 * take care of any data access exceptions......
	 */
	or	r30,  r0,   r31		/* get a copy of the e.f. pointer */
	ld	r2,   r31,  REG_OFF(EF_EPSR)
	bb1	PSR_SUPERVISOR_MODE_BIT, r2, 1f	/* if in kernel mode */

	or.u	r31,  r0,   hi16(_ASM_LABEL(kstack))
	ld	r31,  r31,  lo16(_ASM_LABEL(kstack))
	addu	r31,  r31,  USIZE		/* point at proper end */
1:

	/*
	 * here - r30 holds a pointer to the exception frame.
	 * r31 is a pointer to the kernel stack/interrupt stack.
	 */
	subu	r31,  r31,  8	/* make some breathing space */
	st	r30,  r31,  0	/* store frame pointer on the stack */
#ifdef DDB
	st	r30,  r31,  4	/* store it again for the debugger */
d115 1
a115 30
	ld	r2,   r30,  REG_OFF(EF_VECTOR)
	bcnd.n	eq0,  r2,   8f
	 ld	r14,  r30,  REG_OFF(EF_RET)	/* load return value XXX!!! */
	cmp	r3,   r2,   1	/* is an interrupt? */
	bb1.n	eq,   r3,   8f
	 cmp	r3,   r2,   11	/* or NMI? */
	bb1.n	eq,   r3,   8f

#ifdef DDB
	 cmp	r3,   r2,   130	/* DDB break exception */
	bb1.n	eq,   r3,   8f

	 cmp	r3,   r2,   132	/* DDB entry exception */
	bb1.n	eq,   r3,   8f
#endif

	/* turn interrupts back on */
	 ldcr	r2,   PSR
	clr	r2,   r2,   1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r2,   PSR
	FLUSH_PIPELINE

8:
	jmp	r14		/* loaded above */

	data
	.align 8		/* needs align 8 for ld.d/st.d */
ASLOCAL(save_frame)
	space SIZEOF_EF
#endif	/* M88110 */
@


1.55
log
@When servicing 88110 exceptions, reset dsr and isr as fast as possible.
While there, simplify badaddr() handling on 88110.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.54 2004/06/22 23:00:15 miod Exp $   */
d228 1
a235 1

d242 1
d244 1
d757 2
a758 1
	st	r30, r31, 0x0c	/* store frame pointer on the st */
d764 1
d1004 1
a1004 1
	st	r1,   r31,  GENREG_OFF(1)	/* save prev. r1 (now r1 free)*/
d1143 1
d1148 3
d1654 1
a1654 1
#endif /* DDB */
d1783 1
d1785 3
d1794 1
a1794 26

#if 0
	/*
	 * If it's the interrupt exception, enable interrupt.
	 */

	/*
	 * Is it ever possible to have interrupt exception while EPSR has
	 * it disabled? I don't think so.. XXX nivas
	 *
	 * On mc88110, you can.  The NMI interrupt. aka ABORT. XXX smurph
	 */
	ld	r2, FPTR, REG_OFF(EF_VECTOR)
	cmp	r2, r2, 1	/* Is it an interrupt? */
	bb1.n	ne, r2, 1f	/* If not, skip */

	/* ...unless they were already disabled */
	 ld	r2, FPTR, REG_OFF(EF_EPSR)
	bb1.n	PSR_INTERRUPT_DISABLE_BIT, r2, 1f

	 ldcr	r2, PSR
	clr	r2, r2, 1<PSR_INTERRUPT_DISABLE_BIT>	/* enable interrupts */
	stcr	r2, PSR
	FLUSH_PIPELINE
1:
#endif
a1910 1
	/* mc88110 needs the EXIP */
a1920 3
	st	r0, r31, REG_OFF(EF_IPFSR)
	st	r0, r31, REG_OFF(EF_DPFSR)

d1922 3
a1924 7
	 * Note: no need to restore the SXIP.
	 * When the "rte" causes execution to continue
	 * first with the instruction pointed to by the NIP
	 * and then the FIP.
	 *
	 * See MC88100 Risc Processor User's Manual, 2nd Edition,
	 * section 6.4.3.1.2-4
d1926 1
a1928 1
	stcr	r0,  SSBR
a1933 1
	ld	r1,  r31, REG_OFF(EF_MODE)
d2256 2
a2257 1
	st	r30, r31, 0x0c	/* store frame pointer on the st */
d2263 1
d2653 1
a2653 1
#endif /* DDB */
d2659 2
@


1.54
log
@During exception processing, we are not supposed to fault immediately
after re-enabling the FPU (unless exception handling code is suffering
from bugs, of course).

Should this happen, invoke the error fault handler, but at least clear
the exception state first, so that it gets a chance to run.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.53 2004/06/22 18:27:08 miod Exp $   */
d824 1
a824 1
	 * We just want to jump to "m88110_badaddr__return_nonzero" below.
d827 1
a827 1
	 * jumping back to the function badaddr() where we're allowd
d831 2
a832 2
	or.u	r2, r0, hi16(_ASM_LABEL(m88110_badaddr__return_nonzero))
	or	r2, r2, lo16(_ASM_LABEL(m88110_badaddr__return_nonzero))
d834 1
a939 9
#ifdef M88110
ASLOCAL(m88110_badaddr__return_nonzero)
	/*
	 * On mc88110, we possibly took an exception and we have to clear
	 * DSR before the rte instruction clears the EFRZ bit in the PSR.
	 */
	stcr	r0, DSR
	/* FALLTHROUGH */
#endif
d2496 3
a2572 7

	/*
	 * Now that EFRZ is cleared, we can clear DSR and ISR.
	 * This will allow other data exceptions to happen.
	 */
	stcr	r0, ISR
	stcr	r0, DSR
@


1.53
log
@Change various macro and symbol names in order to have recognizable *100*
and *110* names for processor-dependent code.

No functional change.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.52 2004/06/22 05:02:35 miod Exp $   */
d2374 10
a2383 1
	br	_C_LABEL(m88110_error_handler)
@


1.52
log
@After 88110 exception processing, do not reset the in-frame [di][lp]ar
values, they won't be put back to registers anyways...
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.51 2004/06/22 05:01:08 miod Exp $   */
d304 1
a304 1
 * #define PREP(NAME, NUM, BIT, SSBR_STUFF, FLAG_CHECK)
d306 1
a306 1
 * This is the "exception processing preparaton" common to all exception
d310 1
a310 1
 *		PREP("foo", 11, DEBUG_FOO_BIT, SSBR_Stuff, Precheck_Stuff)
d312 1
a312 1
 *		DONE(DEBUG_FOO_BIT)
d315 1
a315 1
 * The arguments ro PREP():
d329 4
a332 4
 * What's in between PREP() and DONE() (usually a CALL) is the actual
 * servicing of the interrupt.  During this time, any register may
 * be used freely as they've all been saved in the exception frame
 * (which is pointed-to by r31).
d336 1
a336 1
#define PREP(NAME, NUM, BIT, SSBR_STUFF, FLAG_PRECHECK) \
d347 1
a347 1
1:	bsr	_ASM_LABEL(setup_phase_one)		; \
d356 1
a356 1
	bsr	_ASM_LABEL(setup_phase_two)		; \
d362 1
a362 1
#define PREP2(NAME, NUM, BIT, FLAG_PRECHECK) \
d385 1
a385 1
/* Some defines for use with PREP() */
d388 1
a388 1
#define	Data_Precheck \
d390 1
a390 1
		_ASM_LABEL(ignore_data_exception)
d393 1
a393 1
		_ASM_LABEL(m88110_ignore_data_exception)
d442 1
a442 1
#define DONE(DebugNumber) \
d448 2
a449 2
2:	br	_ASM_LABEL(return_from_exception_handler)
#define DONE2(DebugNumber) \
d462 3
a464 3
#define	DONE(num) \
	br	_ASM_LABEL(return_from_exception_handler)
#define	DONE2(num) \
d475 1
a475 1
	PREP("unknown", 0, DEBUG_UNKNOWN_BIT,,)
d477 1
a477 1
	DONE(DEBUG_UNKNOWN_BIT)
d481 1
a481 1
	PREP("interrupt", 1, DEBUG_INTERRUPT_BIT,,)
d483 1
a483 1
	DONE(DEBUG_INTERRUPT_BIT)
d487 1
a487 1
	PREP("inst", 2, DEBUG_INSTRUCTION_BIT,,)
d489 1
a489 1
	DONE(DEBUG_INSTRUCTION_BIT)
d496 1
a496 1
	PREP("data", 3, DEBUG_DATA_BIT,, Data_Precheck)
d498 1
a498 1
	DONE(DEBUG_DATA_BIT)
d502 1
a502 1
	PREP("misalign", 4, DEBUG_MISALIGN_BIT, Clear_SSBR_Dest,)
d504 1
a504 1
	DONE(DEBUG_MISALIGN_BIT)
d508 1
a508 1
	PREP("unimp", 5, DEBUG_UNIMPLEMENTED_BIT,,)
d510 1
a510 1
	DONE(DEBUG_UNIMPLEMENTED_BIT)
d523 1
a523 1
1:	PREP("privilege", 6, DEBUG_PRIVILEGE_BIT, Clear_SSBR_Dest,)
d525 1
a525 1
	DONE(DEBUG_PRIVILEGE_BIT)
d529 1
a529 1
	PREP("bounds", 7, DEBUG_BOUNDS_BIT, Clear_SSBR_Dest,)
d531 1
a531 1
	DONE(DEBUG_BOUNDS_BIT)
d535 1
a535 1
	PREP("divide", 8, DEBUG_DIVIDE_BIT, Clear_SSBR_Dest,)
d537 1
a537 1
	DONE(DEBUG_DIVIDE_BIT)
d541 1
a541 1
	PREP("overflow", 9, DEBUG_OVERFLOW_BIT,,)
d543 1
a543 1
	DONE(DEBUG_OVERFLOW_BIT)
d549 1
a549 1
	PREP("FPU precise", 114, DEBUG_FPp_BIT, FPp_SSBR_STUFF,)
d551 1
a551 1
	DONE(DEBUG_FPp_BIT)
d557 1
a557 1
	PREP("FPU imprecise", 115, DEBUG_FPi_BIT, FPi_SSBR_STUFF,)
d559 1
a559 1
	DONE(DEBUG_FPi_BIT)
d563 1
a563 1
	PREP("syscall", 128, DEBUG_SYSCALL_BIT,,)
d566 1
a566 1
	DONE(DEBUG_SYSCALL_BIT)
d570 1
a570 1
	PREP("bugsyscall", 496, DEBUG_BUGCALL_BIT,,)
d573 1
a573 1
	DONE(DEBUG_BUGCALL_BIT)
d576 1
a576 1
	PREP("sigsys", 501, DEBUG_SIGSYS_BIT,,)
d578 1
a578 1
	DONE(DEBUG_SIGSYS_BIT)
d581 1
a581 1
	PREP("sigtrap", 510, DEBUG_SIGTRAP_BIT,,)
d583 1
a583 1
	DONE(DEBUG_SIGTRAP_BIT)
d586 1
a586 1
	PREP("stepbpt", 504, DEBUG_SIGTRAP_BIT,,)
d588 1
a588 1
	DONE(DEBUG_SIGTRAP_BIT)
d591 1
a591 1
	PREP("userbpt", 511, DEBUG_SIGTRAP_BIT,,)
d593 1
a593 1
	DONE(DEBUG_SIGTRAP_BIT)
d597 1
a597 1
	PREP("break", 130, DEBUG_BREAK_BIT,,)
d599 1
a599 1
	DONE(DEBUG_BREAK_BIT)
d602 1
a602 1
	PREP("trace", 131, DEBUG_TRACE_BIT,,)
d604 1
a604 1
	DONE(DEBUG_TRACE_BIT)
d607 1
a607 1
	PREP("kdb", 132, DEBUG_KDB_BIT,,)
d609 1
a609 1
	DONE(DEBUG_KDB_BIT)
d612 1
a612 1
	PREP("break", 130, DEBUG_BREAK_BIT,,)
d614 1
a614 1
	DONE(DEBUG_BREAK_BIT)
d617 1
a617 1
	PREP("trace", 131, DEBUG_TRACE_BIT,,)
d619 1
a619 1
	DONE(DEBUG_TRACE_BIT)
d622 1
a622 1
	PREP("unknown", 132, DEBUG_KDB_BIT,,)
d624 1
a624 1
	DONE(DEBUG_KDB_BIT)
d779 1
a779 1
ASLOCAL(ignore_data_exception)
d969 1
a969 1
ASLOCAL(setup_phase_one)
d979 1
a979 1
	 *   Might be at the end of R31, SR3, or the thread's pcb.
d990 3
a992 3
	bb1	FLAG_ENABLING_FPU, FLAGS, _ASM_LABEL(use_SR3_pcb)
	/* are we coming in from user mode? If so, pick up thread pcb */
	bb0	FLAG_FROM_KERNEL, FLAGS, _ASM_LABEL(pickup_stack)
d1014 1
a1014 1
	br.n	_ASM_LABEL(have_pcb)
d1017 1
a1017 1
ASLOCAL(use_SR3_pcb)
d1053 1
a1053 1
	br.n	_ASM_LABEL(have_pcb)
d1070 1
a1070 1
	br.n	_ASM_LABEL(have_pcb)
d1073 1
a1073 1
ASLOCAL(pickup_stack)
d1083 1
a1083 1
	 *   register to be used in getting the thread's pcb
d1087 1
a1087 1
	/* switch to the thread's kernel stack. */
d1097 1
a1097 1
ASLOCAL(have_pcb)
a1297 2
#endif /* M88100 */

d1477 1
a1477 3
#ifdef M88100

ASLOCAL(setup_phase_two)
d1514 3
a1516 3
	or.u	TMP,  r0,   hi16(_ASM_LABEL(fpu_enable) + 2)
	or	TMP,  TMP,  lo16(_ASM_LABEL(fpu_enable) + 2)
	stcr	TMP,  SNIP	/* jump to here fpu_enable */
d1518 1
a1518 1
	stcr	TMP,  SFIP	/* and then continue after that */
d1551 1
a1551 1
	RTE	/* jumps to "fpu_enable" on the next line to enable the FPU. */
d1553 1
a1553 1
ASLOCAL(fpu_enable)
d1720 1
a1720 2
 * return_from_exception_handler which loads all the registers and does an
 * rte.
d1733 1
a1733 1
	/* br	_ASM_LABEL(return_from_exception_handler) */
d1753 1
a1753 1
ASLOCAL(return_from_exception_handler)
d1980 1
a1980 1
	PREP2("unknown", 0, DEBUG_UNKNOWN_BIT,)
d1982 1
a1982 1
	DONE2(DEBUG_UNKNOWN_BIT)
d1986 1
a1986 1
	PREP2("interrupt", 1, DEBUG_INTERRUPT_BIT,)
d1988 1
a1988 1
	DONE2(DEBUG_INTERRUPT_BIT)
d1992 1
a1992 1
	PREP2("inst", 2, DEBUG_INSTRUCTION_BIT,)
d1994 1
a1994 1
	DONE2(DEBUG_INSTRUCTION_BIT)
d2000 1
a2000 1
	PREP2("data", 3, DEBUG_DATA_BIT, M88110_Data_Precheck)
d2002 1
a2002 1
	DONE2(DEBUG_DATA_BIT)
d2006 1
a2006 1
	PREP2("misalign", 4, DEBUG_MISALIGN_BIT,)
d2008 1
a2008 1
	DONE2(DEBUG_MISALIGN_BIT)
d2012 1
a2012 1
	PREP2("unimp", 5, DEBUG_UNIMPLEMENTED_BIT,)
d2014 1
a2014 1
	DONE2(DEBUG_UNIMPLEMENTED_BIT)
d2018 1
a2018 1
	PREP2("privilege", 6, DEBUG_PRIVILEGE_BIT,)
d2020 1
a2020 1
	DONE2(DEBUG_PRIVILEGE_BIT)
d2027 1
a2027 1
	PREP2("bounds", 7, DEBUG_BOUNDS_BIT,)
d2029 1
a2029 1
	DONE2(DEBUG_BOUNDS_BIT)
d2033 1
a2033 1
	PREP2("divide", 8, DEBUG_DIVIDE_BIT,)
d2035 1
a2035 1
	DONE2(DEBUG_DIVIDE_BIT)
d2039 1
a2039 1
	PREP2("overflow", 9, DEBUG_OVERFLOW_BIT,)
d2041 1
a2041 1
	DONE2(DEBUG_OVERFLOW_BIT)
d2045 1
a2045 1
	PREP2("FPU precise", 114, DEBUG_FPp_BIT,)
d2047 1
a2047 1
	DONE2(DEBUG_FPp_BIT)
d2051 1
a2051 1
	PREP2("MVME197 non-mask", 11, DEBUG_NON_MASK_BIT,)
d2053 1
a2053 1
	DONE2(DEBUG_NON_MASK_BIT)
d2057 1
a2057 1
	PREP2("MVME197 read miss", 12, DEBUG_197_READ_BIT,)
d2059 1
a2059 1
	DONE2(DEBUG_197_READ_BIT)
d2063 1
a2063 1
	PREP2("MVME197 write miss", 13, DEBUG_197_WRITE_BIT,)
d2065 1
a2065 1
	DONE2(DEBUG_197_WRITE_BIT)
d2069 1
a2069 1
	PREP2("MVME197 inst miss", 14, DEBUG_197_INST_BIT,)
d2071 1
a2071 1
	DONE2(DEBUG_197_INST_BIT)
d2075 1
a2075 1
	PREP2("syscall", 128, DEBUG_SYSCALL_BIT,)
d2078 1
a2078 1
	DONE2(DEBUG_SYSCALL_BIT)
d2082 1
a2082 1
	PREP2("bugsyscall", 496, DEBUG_BUGCALL_BIT,)
d2085 1
a2085 1
	DONE2(DEBUG_BUGCALL_BIT)
d2088 1
a2088 1
	PREP2("sigsys", 501, DEBUG_SIGSYS_BIT,)
d2090 1
a2090 1
	DONE2(DEBUG_SIGSYS_BIT)
d2093 1
a2093 1
	PREP2("sigtrap", 510, DEBUG_SIGTRAP_BIT,)
d2095 1
a2095 1
	DONE2(DEBUG_SIGTRAP_BIT)
d2098 1
a2098 1
	PREP2("stepbpt", 504, DEBUG_SIGTRAP_BIT,)
d2100 1
a2100 1
	DONE2(DEBUG_SIGTRAP_BIT)
d2103 1
a2103 1
	PREP2("userbpt", 511, DEBUG_SIGTRAP_BIT,)
d2105 1
a2105 1
	DONE2(DEBUG_SIGTRAP_BIT)
d2109 1
a2109 1
	PREP2("break", 130, DEBUG_BREAK_BIT,)
d2111 1
a2111 1
	DONE2(DEBUG_BREAK_BIT)
d2114 1
a2114 1
	PREP2("trace", 131, DEBUG_TRACE_BIT,)
d2116 1
a2116 1
	DONE2(DEBUG_TRACE_BIT)
d2119 1
a2119 1
	PREP2("kdb", 132, DEBUG_KDB_BIT,)
d2121 1
a2121 1
	DONE2(DEBUG_KDB_BIT)
d2124 1
a2124 1
	PREP2("break", 130, DEBUG_BREAK_BIT,)
d2126 1
a2126 1
	DONE2(DEBUG_BREAK_BIT)
d2129 1
a2129 1
	PREP2("trace", 131, DEBUG_TRACE_BIT,)
d2131 1
a2131 1
	DONE2(DEBUG_TRACE_BIT)
d2134 1
a2134 1
	PREP2("unknown", 132, DEBUG_KDB_BIT,)
d2136 1
a2136 1
	DONE2(DEBUG_KDB_BIT)
d2315 1
a2315 1
	 *   Might be at the end of R31, SR3, or the thread's pcb.
d2425 1
a2425 1
	 *   register to be used in getting the thread's pcb.
d2429 1
a2429 1
	/* switch to the thread's kernel stack. */
d2472 1
a2472 1
	 * Save Pbus fault status register from data and inst CMMU.
a2503 1
	 * TMP: possibly revised SSBR
d2533 1
a2533 1
	stcr	TMP,  EXIP	/* jump to m88110_fpu_enable upon RTE */
d2540 1
a2540 2
	ldcr	TMP, SR3
	stcr	r31, SR3	/* TMP now restored. R31 now saved in SR3 */
d2561 1
a2561 1
	 *   Do an RTE to restart the fpu and jump to "m88110_fpu_enable"
d2565 1
a2565 2
	NOP
	RTE	/* jumps to "m88110_fpu_enable" on the next line to enable the FPU. */
d2570 4
a2573 2
	/* Now we can handle another exception!!! */
	/* Now that EFRZ is cleared, we can clear these */
@


1.51
log
@On 88110, simplify enip processing:
- always fetch its value when building trapframe, it is faster than only
  doing it after checking if it will have a meaningful value.
- don't bother setting it to a safe value if we change exip to a
  non-delayslot address.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.50 2004/01/29 21:39:05 deraadt Exp $   */
a945 2
	stcr	r0, DLAR
	stcr	r0, DPAR
d2577 1
d2580 3
a2582 6
	stcr	r0, ISR				/* Clear ISR */
	stcr	r0, ILAR			/* Clear ILAR */
	stcr	r0, IPAR			/* Clear IPAR */
	stcr	r0, DSR				/* Clear DSR */
	stcr	r0, DLAR			/* Clear DLAR */
	stcr	r0, DPAR			/* Clear DPAR */
@


1.50
log
@typos; jjy2+@@pitt.edu
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.49 2004/01/29 00:41:23 miod Exp $   */
a1604 6
#ifdef JEFF_DEBUG
	/* mark beginning of frame with notable value */
	or.u	r20,  r0,   hi16(0x12345678)
	or	r20,  r20,  lo16(0x12345678)
	st	r20,  r31,  GENREG_OFF(0)
#endif
d2246 2
a2469 3
	/* if the instruction was NOT in the delay slot, ignore ENIP */
	bb0.n	0,    TMP2, 1f
	 st	TMP2, r31,  REG_OFF(EF_EXIP)
d2471 1
a2472 1
1:
d2541 1
a2541 3
	stcr	TMP,  EXIP	/* jump to here m88110_fpu_enable */
	addu	TMP,  TMP,  4
	stcr	TMP,  ENIP	/* and then continue after that */
a2630 6
#ifdef JEFF_DEBUG
	/* mark beginning of frame with notable value */
	or.u	r20,  r0,   hi16(0x12345678)
	or	r20,  r20,  lo16(0x12345678)
	st	r20,  r31,  GENREG_OFF(0)
#endif
@


1.49
log
@Correctly handle 88110 exceptions occuring in a delay slot: control must
be restored with valid EXIP+D and ENIP values in this case, unless it is
decided to skip instructions.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.48 2004/01/19 17:21:25 miod Exp $   */
d794 1
a794 1
	 * jumping back to the function badaddr() where we're allowd
d841 1
a841 1
 * not all currently accessable by the kernel.
d843 1
a843 1
 * If all LEN bytes starting at ADDR are accessable, zero is returned.
d847 1
a847 1
 * This is implementd by setting a special flag in SR1 before trying to access
d849 1
a849 1
 * is inaccessable. The exception handler will notice the special CPU flag
d1027 1
a1027 1
	 *   An exception occured while enabling the FPU. Since r31
d1304 1
a1304 1
	 * Clear floatingpont-imprecise ssbr bits.
d1549 1
a1549 1
	 *   Return address to the calling excption handler.
d2372 1
a2372 1
	 *   An exception occured while enabling the FPU. Since r31 is the
d2575 2
a2576 2
	 * Held temporarly in the exception frame:
	 *   Return address to the calling excption handler.
@


1.48
log
@Get rid of a few useless defines, as well as a few duplicated ones; and
move 8820x-only definitions to the adequate header.

Also crank MAXPHYSMEM to a more realistic value.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.47 2004/01/09 00:24:25 miod Exp $   */
d2474 1
a2474 1
	st	TMP2, r31,  REG_OFF(EF_EXIP)
d2476 1
a2476 3
	/* The instruction was NOT in the delay slot, zero ENIP. */
	 st	r0,   r31,  REG_OFF(EF_ENIP)
	/* The instruction was in the delay slot, save ENIP. */
a2479 2
	/* NO SFIP on mc88110, zero it */
	st	r0,   r31,  REG_OFF(EF_SFIP)
@


1.47
log
@Do not keep a round-robin list of the previous traps for debug purposes on
88100 anymore - it's stable well enough now...
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.46 2003/11/03 06:54:26 david Exp $   */
d202 1
d205 4
a208 2
#include <machine/param.h>		/* CPU_ and BRD_ defines */
#include <machine/trap.h>		/* for T_ defines */
@


1.46
log
@spelling fixes (in the comments)
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.45 2003/10/09 16:30:58 miod Exp $   */
a347 3
	/* TMP3 also free -- use to set last_vector */	  \
	or.u	TMP3, r0,   hi16(_C_LABEL(last_vector))	; \
	st	TMP2, TMP3, lo16(_C_LABEL(last_vector))	; \
@


1.45
log
@Minor cpp changes to let all kernels in conf/ compile.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.44 2003/10/05 21:22:02 miod Exp $   */
d764 1
a764 1
	/* turn interupts back on */
d1686 1
a1686 1
	/* turn interupts back on */
d1762 1
a1762 1
	 * Control is transfered here from obvious places in this file.
d2306 1
a2306 1
	/* turn interupts back on */
d2721 1
a2721 1
	/* turn interupts back on */
@


1.44
log
@Oops, commited from the wrong tree
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.43 2003/10/05 20:31:24 miod Exp $   */
a949 1
#ifdef M88100
a950 1
#endif
@


1.43
log
@Do not use empty No_SSBR and No_Precheck macros, but rather pass empty
arguments to PREP*() macros.

Slightly reorganize code in badaddr() - also do not make some internal labels
unnecessarily visible from outside code.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.42 2003/09/20 13:57:37 miod Exp $   */
a954 1
#endif
@


1.42
log
@Cleanup uses of intstack and interrupt_stack[] - also makes time % in top
more realistic.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.41 2003/09/17 22:22:32 miod Exp $   */
d304 1
a304 1
 * processing.  It is used in the following manor:
d307 1
a307 1
 *		PREP("foo", 11, DEBUG_FOO_BIT, No_SSBR_Stuff, No_Precheck)
a385 1
#define	No_SSBR_Stuff		/* empty */
a387 1
#define	No_Precheck		/* empty */
d475 1
a475 1
	PREP("unknown", 0, DEBUG_UNKNOWN_BIT, No_SSBR_Stuff, No_Precheck)
d481 1
a481 1
	PREP("interrupt", 1, DEBUG_INTERRUPT_BIT, No_SSBR_Stuff, No_Precheck)
d487 1
a487 1
	PREP("inst", 2, DEBUG_INSTRUCTION_BIT, No_SSBR_Stuff, No_Precheck)
d496 1
a496 1
	PREP("data", 3, DEBUG_DATA_BIT, No_SSBR_Stuff, Data_Precheck)
d502 1
a502 1
	PREP("misalign", 4, DEBUG_MISALIGN_BIT, Clear_SSBR_Dest, No_Precheck)
d508 1
a508 1
	PREP("unimp", 5, DEBUG_UNIMPLEMENTED_BIT, No_SSBR_Stuff, No_Precheck)
d523 1
a523 1
1:	PREP("privilege", 6, DEBUG_PRIVILEGE_BIT, Clear_SSBR_Dest, No_Precheck)
d529 1
a529 1
	PREP("bounds", 7, DEBUG_BOUNDS_BIT, Clear_SSBR_Dest, No_Precheck)
d535 1
a535 1
	PREP("divide", 8, DEBUG_DIVIDE_BIT, Clear_SSBR_Dest, No_Precheck)
d541 1
a541 1
	PREP("overflow", 9, DEBUG_OVERFLOW_BIT, No_SSBR_Stuff, No_Precheck)
d549 1
a549 1
	PREP("FPU precise", 114, DEBUG_FPp_BIT, FPp_SSBR_STUFF, No_Precheck)
d557 1
a557 1
	PREP("FPU imprecise", 115, DEBUG_FPi_BIT, FPi_SSBR_STUFF, No_Precheck)
d563 1
a563 1
	PREP("syscall", 128, DEBUG_SYSCALL_BIT, No_SSBR_Stuff, No_Precheck)
d570 1
a570 1
	PREP("bugsyscall", 496, DEBUG_BUGCALL_BIT, No_SSBR_Stuff, No_Precheck)
d576 1
a576 1
	PREP("sigsys", 501, DEBUG_SIGSYS_BIT, No_SSBR_Stuff, No_Precheck)
d581 1
a581 1
	PREP("sigtrap", 510, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
d586 1
a586 1
	PREP("stepbpt", 504, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
d591 1
a591 1
	PREP("userbpt", 511, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
d597 1
a597 1
	PREP("break", 130, DEBUG_BREAK_BIT, No_SSBR_Stuff, No_Precheck)
d602 1
a602 1
	PREP("trace", 131, DEBUG_TRACE_BIT, No_SSBR_Stuff, No_Precheck)
d607 1
a607 1
	PREP("kdb", 132, DEBUG_KDB_BIT, No_SSBR_Stuff, No_Precheck)
d612 1
a612 1
	PREP("break", 130, DEBUG_BREAK_BIT, No_SSBR_Stuff, No_Precheck)
d617 1
a617 1
	PREP("trace", 131, DEBUG_TRACE_BIT, No_SSBR_Stuff, No_Precheck)
d622 1
a622 1
	PREP("unknown", 132, DEBUG_KDB_BIT, No_SSBR_Stuff, No_Precheck)
d770 4
a773 3
ASLOCAL(error_loop)
	br	_ASM_LABEL(error_loop)
	/* never returns*/
d778 1
a801 1

a804 2
1:
	/* the following jumps to "badaddr__return_nonzero" in below */
d806 1
a806 1
#endif /* m88100 */
a833 3

	/* the following jumps to "m88110_badaddr__return_nonzero" below */
	NOP
d915 1
d919 1
d939 14
a952 1
ASGLOBAL(badaddr__return_nonzero)
d954 2
a955 1
	/* fall through to badaddr__return */
d957 1
a957 1
ASGLOBAL(badaddr__return)
a972 12
ASLOCAL(m88110_badaddr__return_nonzero)
	/*
	 * On mc88110, we possibly took an exception
	 * and we have to clear DSR after the rte
	 * instruction clears the EFRZ bit in
	 * the PSR.
	 */
	stcr	r0, DSR	/* Clear DSR reg on mc88110 */
	stcr	r0, DLAR	/* Clear DLAR reg on mc88110 */
	br.n	_ASM_LABEL(badaddr__return_nonzero)
	 stcr	r0, DPAR	/* Clear DPAR reg on mc88110 */

a973 1

d1996 1
a1996 1
	PREP2("unknown", 0, DEBUG_UNKNOWN_BIT, No_Precheck)
d2002 1
a2002 1
	PREP2("interrupt", 1, DEBUG_INTERRUPT_BIT, No_Precheck)
d2008 1
a2008 1
	PREP2("inst", 2, DEBUG_INSTRUCTION_BIT, No_Precheck)
d2022 1
a2022 1
	PREP2("misalign", 4, DEBUG_MISALIGN_BIT, No_Precheck)
d2028 1
a2028 1
	PREP2("unimp", 5, DEBUG_UNIMPLEMENTED_BIT, No_Precheck)
d2034 1
a2034 1
	PREP2("privilege", 6, DEBUG_PRIVILEGE_BIT, No_Precheck)
d2043 1
a2043 1
	PREP2("bounds", 7, DEBUG_BOUNDS_BIT, No_Precheck)
d2049 1
a2049 1
	PREP2("divide", 8, DEBUG_DIVIDE_BIT, No_Precheck)
d2055 1
a2055 1
	PREP2("overflow", 9, DEBUG_OVERFLOW_BIT, No_Precheck)
d2061 1
a2061 1
	PREP2("FPU precise", 114, DEBUG_FPp_BIT, No_Precheck)
d2067 1
a2067 1
	PREP2("MVME197 non-mask", 11, DEBUG_NON_MASK_BIT, No_Precheck)
d2073 1
a2073 1
	PREP2("MVME197 read miss", 12, DEBUG_197_READ_BIT, No_Precheck)
d2079 1
a2079 1
	PREP2("MVME197 write miss", 13, DEBUG_197_WRITE_BIT, No_Precheck)
d2085 1
a2085 1
	PREP2("MVME197 inst miss", 14, DEBUG_197_INST_BIT, No_Precheck)
d2091 1
a2091 1
	PREP2("syscall", 128, DEBUG_SYSCALL_BIT, No_Precheck)
d2098 1
a2098 1
	PREP2("bugsyscall", 496, DEBUG_BUGCALL_BIT, No_Precheck)
d2104 1
a2104 1
	PREP2("sigsys", 501, DEBUG_SIGSYS_BIT, No_Precheck)
d2109 1
a2109 1
	PREP2("sigtrap", 510, DEBUG_SIGTRAP_BIT, No_Precheck)
d2114 1
a2114 1
	PREP2("stepbpt", 504, DEBUG_SIGTRAP_BIT, No_Precheck)
d2119 1
a2119 1
	PREP2("userbpt", 511, DEBUG_SIGTRAP_BIT, No_Precheck)
d2125 1
a2125 1
	PREP2("break", 130, DEBUG_BREAK_BIT, No_Precheck)
d2130 1
a2130 1
	PREP2("trace", 131, DEBUG_TRACE_BIT, No_Precheck)
d2135 1
a2135 1
	PREP2("kdb", 132, DEBUG_KDB_BIT, No_Precheck)
d2140 1
a2140 1
	PREP2("break", 130, DEBUG_BREAK_BIT, No_Precheck)
d2145 1
a2145 1
	PREP2("trace", 131, DEBUG_TRACE_BIT, No_Precheck)
d2150 1
a2150 1
	PREP2("unknown", 132, DEBUG_KDB_BIT, No_Precheck)
d2315 3
a2317 3
ASLOCAL(m88110_error_loop)
	br	_ASM_LABEL(m88110_error_loop)
	/* never returns*/
@


1.41
log
@More cleaning of the exception handling code, and collateral damage:
- always give C routines invoked by the assembly code some breathing room on
  the stack
- merge error and reset exception handlers -- gets us rid of error_fault()
  and error_reset().
- remove all references to SR0 and "threads" inherited from Mach. In fact,
  we do not use SR0 at all now.
- only use double load and stores instructions when we are 200% sure we are
  accessing a correctly aligned area. I am not fond of unaligned kernel
  accesses, and forcing every pgb to be aligned on an 8 byte boundary is
  gross.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.40 2003/09/08 20:44:52 miod Exp $   */
a224 3
/* Define this to make interrupts use their own stack */
#undef	INTSTACK

a1658 13
#ifdef INTSTACK
	/*
	 * If interrupt exception, switch to interrupt stack if not
	 * already there. Else, switch to kernel stack.
	 */
	ld	r3,   r31,  REG_OFF(EF_VECTOR)
	cmp	r3,   r3,   1	/* is interrupt ? */
	bb0	eq,   r3,   2f
	or.u	r31,  r0,   hi16(_ASM_LABEL(intstack_end))
	or	r31,  r31,  lo16(_ASM_LABEL(intstack_end))
	br	3f
2:
#endif
a1661 2
#ifdef INTSTACK
	br	3f
a1662 9
	ld	r3,   r31,  REG_OFF(EF_VECTOR)
	cmp	r3,   r3,   1	/* is interrupt ? */
	bb0	eq,   r3,   3f	/* no, we will stay on kern stack */
	or.u	r31,  r0,   hi16(_ASM_LABEL(intstack_end))
	or	r31,  r31,  lo16(_ASM_LABEL(intstack_end))
3:
#else
1:
#endif
d1675 1
a1675 1
	bcnd.n	eq0,  r2,   8f			/* is error */
d1784 1
a1784 1
	 * If it's not the interrupt exception, and interrupts were
d1853 1
a1853 1
        /* is this needed? we are going to restore the ipl below XXX nivas */
a2697 13
#ifdef INTSTACK
	/*
	 * If interrupt exception, switch to interrupt stack if not
	 * already there. Else, switch to kernel stack.
	 */
	ld	r3,   r31,  REG_OFF(EF_VECTOR)
	cmp	r3,   r3,   1	/* is interrupt ? */
	bb0	eq,   r3,   2f
	or.u	r31,  r0,   hi16(_ASM_LABEL(intstack_end))
	or	r31,  r31,  lo16(_ASM_LABEL(intstack_end))
	br	3f
2:
#endif
a2700 2
#ifdef INTSTACK
	br	3f
a2701 9
	ld	r3,   r31,  REG_OFF(EF_VECTOR)
	cmp	r3,   r3,   1	/* is interrupt ? */
	bb0	eq,   r3,   3f	/* no, we will stay on kern stack */
	or.u	r31,  r0,   hi16(_ASM_LABEL(intstack_end))
	or	r31,  r31,  lo16(_ASM_LABEL(intstack_end))
3:
#else
1:
#endif
@


1.40
log
@Revert the changes reordering the data access exception processing in the
context of a regular exception. This was probably a good move, but it
eventually causes issues when uptimes grows towards infinity...

Of course, diagnosing such an issue at the same time that the disk drive
is dying and causes problems on his own, is not exactly easy...
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.39 2003/09/07 01:49:16 miod Exp $   */
a31 9
 * HISTORY
 * 1. Should get rid of SR0 reference for thread stuff.
 * 2. Make up my mind what is kstack. I think it should be p->p_addr+UPAGES.
 *    (p_addr is pointing to user struct and swapin is making sure it is
 *    updated)
 *   Whatever is kstack, its usage in this file should be revisited.
 */

/*
d185 1
a185 2
 * Now is a good time to recap SR0..SR3 usage:
 *   SR0 - Used for subroutine returns.  XXX smurph XXX2 not any more...
d237 1
d241 1
d297 2
a298 1
	ld.d	r2 , r31, GENREG_OFF(2)		; \
d422 1
a422 1
	/* call MY_info(ef,thread,flags,kind)*/		  \
d429 1
a429 1
	 subu	r31, r31, 40				; \
d431 1
a431 1
	 addu	r31, r31, 40				; \
d633 2
a634 1
 * The error exception handler.
a637 137
 * The shadow registers are not valid in this case (shadowing was off, ne).
 * R1-R31 may be interesting though, so we'll save them.
 *
 * We'll not worry about trashing r26-29 here,
 * since they aren't generally used.
 */
GLOBAL(error_handler)
	/* pick up the slavestack */
	or	r26, r0,  r31	/* save old stack */
	or.u	r31, r0,  hi16(_ASM_LABEL(intstack_end))
	or	r31, r31, lo16(_ASM_LABEL(intstack_end))

	/* zero the stack, so we'll know what we're lookin' at */
	or.u	r27, r0,  hi16(_C_LABEL(intstack))
	or	r27, r27, lo16(_C_LABEL(intstack))
1:	cmp	r28, r27, r31
	bb1	ge,  r28, 2f	/* branch if at the end of the stack */
	st	r0,  r0,  r27
	br.n	1b
	 addu	r27, r27, 4	/* bump up */
2:	/* stack has been cleared */

	/* ensure that stack is 8-byte aligned */
	clr	r31, r31, 3<0>	/* round down to 8-byte boundary */

	/* create exception frame on stack */
	subu	r31, r31, SIZEOF_EF	/* r31 now our E.F. */

	/* save old R31 and other R registers */
	st.d	r0 , r31, GENREG_OFF(0)
	st.d	r2 , r31, GENREG_OFF(2)
	st.d	r4 , r31, GENREG_OFF(4)
	st.d	r6 , r31, GENREG_OFF(6)
	st.d	r8 , r31, GENREG_OFF(8)
	st.d	r10, r31, GENREG_OFF(10)
	st.d	r12, r31, GENREG_OFF(12)
	st.d	r14, r31, GENREG_OFF(14)
	st.d	r16, r31, GENREG_OFF(16)
	st.d	r18, r31, GENREG_OFF(18)
	st.d	r20, r31, GENREG_OFF(20)
	st.d	r22, r31, GENREG_OFF(22)
	st.d	r24, r31, GENREG_OFF(24)
	st	r30, r31, GENREG_OFF(30)
	st	r26, r31, GENREG_OFF(31)

	/* save shadow registers (are OLD if error_handler, though) */
	ldcr	r10, EPSR
	st	r10, r31, REG_OFF(EF_EPSR)
	ldcr	r10, SXIP
	st	r10, r31, REG_OFF(EF_SXIP)
	ldcr	r10, SNIP
	st	r10, r31, REG_OFF(EF_SNIP)
	ldcr	r10, SR1
	st	r10, r31, REG_OFF(EF_MODE)
	ldcr	r10, SFIP
	st	r10, r31, REG_OFF(EF_SFIP)
	ldcr	r10, SSBR
	st	r10, r31, REG_OFF(EF_SSBR)
	stcr	r0,  SSBR	/* won't want shadow bits bothering us later */
	ldcr	r10, DMT0
	st	r10, r31, REG_OFF(EF_DMT0)
	ldcr	r11, DMD0
	st	r11, r31, REG_OFF(EF_DMD0)
	ldcr	r12, DMA0
	st	r12, r31, REG_OFF(EF_DMA0)
	ldcr	r10, DMT1
	st	r10, r31, REG_OFF(EF_DMT1)
	FLUSH_PIPELINE
	ldcr	r11, DMD1
	st 	r11, r31, REG_OFF(EF_DMD1)
	ldcr	r12, DMA1
	st	r12, r31, REG_OFF(EF_DMA1)

	ldcr	r10, DMT2
	st	r10, r31, REG_OFF(EF_DMT2)
	ldcr	r11, DMD2
	st	r11, r31, REG_OFF(EF_DMD2)
	ldcr	r12, DMA2
	st	r12, r31, REG_OFF(EF_DMA2)

	/* shove sr2 into EF_FPLS1 */
	ldcr	r10, SR2
	st	r10, r31, REG_OFF(EF_FPLS1)

	/* shove sr3 into EF_FPHS2 */
	ldcr	r10, SR3
	st	r10, r31, REG_OFF(EF_FPHS2)

	/* error vector is 10 */
	or	r10, r0, 10
	st	r10, r31, REG_OFF(EF_VECTOR)

#if 0 /* MVME188 */
#define	IST_REG		0xfff84040	/* interrupt status addr */
	/* check if it's a mvme188 */
	or.u	r10,  r0,   hi16(_C_LABEL(brdtyp))
	ld	r11,  r10,  lo16(_C_LABEL(brdtyp))
	cmp	r10,  r11,  BRD_188
	bb1	ne,   r10,  3f
	or.u	r10,  r0,   hi16(IST_REG)	/* interrupt status register */
	ld	r11,  r10,  lo16(IST_REG)
	st	r11,  r31,  REG_OFF(EF_MASK)	/* put in EF_MASK for regdump */
#endif /* MVME188 */
	/*
	 * Cheap way to enable FPU and start shadowing again.
	 */
3:	ldcr	r10, PSR
	clr	r10, r10, 1<PSR_FPU_DISABLE_BIT>	/* enable the FPU */
	clr	r10, r10, 1<PSR_SHADOW_FREEZE_BIT>	/* and shadowing */
	stcr	r10, PSR
	FLUSH_PIPELINE

	/* put pointer to regs into r30... r31 will become a simple stack */
	or	r30, r31, r0

	subu	r31, r31, 0x10	/* make some breathing space */
	st	r30, r31, 0x0c	/* store frame pointer on the st */
	st	r30, r31, 0x08	/* store again for the debugger to recognize */
	or.u	r20,  r0, hi16(0x87654321)
	or	r20, r20, lo16(0x87654321)
	st	r20, r31, 0x04
	st	r20, r31, 0x00

	CALL(_C_LABEL(error_fault), r30, r30)

	/* turn interupts back on */
	ldcr	r1, PSR
	clr	r1, r1, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r1, PSR
	FLUSH_PIPELINE

ASLOCAL(error_loop)
	bsr	_ASM_LABEL(error_loop)
	/* never returns*/

/*
 * The reset exception handler.
a640 1
 *
a642 1
 *
d646 3
a648 3
 * This is totaly different than _error_handler.  Shadowing might or
 * might not be on.
 * R1-R31 could tell u alot about what happend, so we'll save them.
d653 3
d657 2
d660 1
a660 1
	or	r26, r0, r31	/* save old stack */
d664 1
d674 1
d699 1
a699 1
	/* save shadow registers */
d719 1
a720 1

d744 2
a745 2
	/* error vector is zippo numero el'zeroooo */
	st	r0,  r31, REG_OFF(EF_VECTOR)
a752 1

d760 2
a761 2
	st 	r30, r31, 0x0c	/* store frame pointer on the st */
	st 	r30, r31, 0x08	/* store again for the debugger to recognize */
d767 1
a767 1
	CALL(_C_LABEL(error_reset), r30, r30)
d775 2
a776 2
ASLOCAL(error_loop2)
	bsr	_ASM_LABEL(error_loop2)
a783 1
	 * SR0: pointer to the current thread structure
a819 1
	 * SR0: pointer to the current thread structure
d937 1
d942 1
a981 1
	 * SR0: current thread (if any, null if not)
a1006 1
	 * SR0: current thread (if any, null if not)
a1029 1
	 * SR0: current thread (if any, null if not)
a1085 1
	 * SR0: current thread
a1109 1
	 * SR0: current thread
d1162 1
a1216 16
#if 0
/*
 * The following is a kludge so that
 * a core file will have a copy of
 * DMT0 so that 'sim' can display it
 * correctly.
 * After a data fault has been noticed,
 * the real EF_DTM0 is cleared, so I need
 * to throw this somewhere.
 * There's no special reason I chose this
 * register (FPIT)... it's just one of many
 * for which it causes no pain to do this.
 */
	st	TMP3, r31,  REG_OFF(EF_FPIT)
#endif

d1242 1
a1242 1
	tb1	0,    r0,   0
a1288 1
	 * SR0: current thread
a1493 1
	 * SR0: saved return address to calling exception handler
a1516 1
	/*stcr	r1, SR0*/	/* save return address */
a1543 1
	 * SR0: current thread
d1571 2
a1572 1
	st.d	r30,  TMP,  GENREG_OFF(30)	/* save previous r30, r31 */
d1584 30
a1613 15
	st.d	r0 ,  r31,  GENREG_OFF(0)
	st.d	r2 ,  r31,  GENREG_OFF(2)
	st.d	r4 ,  r31,  GENREG_OFF(4)
	st.d	r6 ,  r31,  GENREG_OFF(6)
	st.d	r8 ,  r31,  GENREG_OFF(8)
	st.d	r10,  r31,  GENREG_OFF(10)
	st.d	r12,  r31,  GENREG_OFF(12)
	st.d	r14,  r31,  GENREG_OFF(14)
	st.d	r16,  r31,  GENREG_OFF(16)
	st.d	r18,  r31,  GENREG_OFF(18)
	st.d	r20,  r31,  GENREG_OFF(20)
	st.d	r22,  r31,  GENREG_OFF(22)
	st.d	r24,  r31,  GENREG_OFF(24)
	st.d	r26,  r31,  GENREG_OFF(26)
	st.d	r28,  r31,  GENREG_OFF(28)
d1622 3
a1624 1
	bsr	_C_LABEL(getipl)
a1627 1
	 * SR0: current thread
d1719 1
a1719 1
	/* enable interrupts */
d1751 2
a1752 2
	ld	r1,r31,0	/* load func */
	ld	r2,r31,4 	/* load proc pointer */
d1754 4
a1757 4
	 subu	r31,r31,40	/* create stack space for function */
	addu	r31,r31,48	/* stack space above + ksigframe */
	ld	r1, r31,0	/* load pc */
	ld	r2, r31,4	/* & proc pointer from switch frame */
d1759 1
a1759 1
	 addu	r31,r31,8
d1811 2
a1812 2
	 * If it'not the interrupt exception, and interrupts were
	 * initially disabled, enable interrupts again.
d1816 5
a1820 1
	bb1	ne, r2, 1f	/* if not so, skip */
d1822 1
a1822 4
	/* if EPSR has interrupts disabled, skip also */
	ld	r2, FPTR, REG_OFF(EF_EPSR)
	bb1	PSR_INTERRUPT_DISABLE_BIT, r2, 1f
	ldcr	r2, PSR
d1850 5
a1854 1
	bb1	ne, r2, 1f	/* If not, skip */
d1856 1
a1856 4
	/* if EPSR has interrupts disabled, skip also */
	ld	r2, FPTR, REG_OFF(EF_EPSR)
	bb1	PSR_INTERRUPT_DISABLE_BIT, r2, 1f	/* skip if disabled */
	ldcr	r2, PSR
a1878 1
	addu	r31, r31, 32
a1880 1
	subu	r31, r31, 32
d1923 1
a1923 1
	subu	r31, r31, 40
d1926 1
a1926 1
	addu	r31, r31, 40
d1934 28
a1961 14
	ld.d	r2 , r31, GENREG_OFF(2)
	ld.d	r4 , r31, GENREG_OFF(4)
	ld.d	r6 , r31, GENREG_OFF(6)
	ld.d	r8 , r31, GENREG_OFF(8)
	ld.d	r10, r31, GENREG_OFF(10)
	ld.d	r12, r31, GENREG_OFF(12)
	ld.d	r14, r31, GENREG_OFF(14)
	ld.d	r16, r31, GENREG_OFF(16)
	ld.d	r18, r31, GENREG_OFF(18)
	ld.d	r20, r31, GENREG_OFF(20)
	ld.d	r22, r31, GENREG_OFF(22)
	ld.d	r24, r31, GENREG_OFF(24)
	ld.d	r26, r31, GENREG_OFF(26)
	ld.d	r28, r31, GENREG_OFF(28)
d1972 1
d1977 1
d1983 1
d1987 2
d2007 1
d2014 2
a2015 1
	ld.d	r30, r31, GENREG_OFF(30)
d2186 2
a2187 1
 * The error exception handler.
a2190 15
 * The shadow registers are not valid in this case (shadowing was off, ne).
 * R1-R31 may be interesting though, so we'll save them.
 *
 * We'll not worry about trashing r26-29 here,
 * since they aren't generally used.
 */
GLOBAL(m88110_error_handler)
	xcr	r2, r2, SRX
	or	r2, r0, 10
	stcr	r2,  SR0
	br.n	_C_LABEL(m88110_fatal)
	 xcr	r2, r2, SRX

/*
 * The reset exception handler.
a2193 1
 *
d2197 3
a2199 3
 * This is totaly different than error_handler.  Shadowing might or
 * might not be on.
 * R1-R31 could tell you alot about what happened, so we'll save them.
d2204 3
d2208 2
a2209 3
	stcr	r0, SR0
	/* FALLTHROUGH */
GLOBAL(m88110_fatal)
d2215 1
d2225 1
d2251 3
a2253 4
	ldcr	r10, SR0
	st	r10, r31, REG_OFF(EF_VECTOR)
	cmp	r10, r10, 0	/* is it the reset exception? */
	bb1.n	ne,  r10, 1f	/* if not, skip */
d2346 1
a2346 1
	bsr	_ASM_LABEL(m88110_error_loop)
a2350 1
	 * SR0: current thread (if any, null if not)
a2375 1
	 * SR0: current thread (if any, null if not)
a2398 1
	 * SR0: current thread (if any, null if not)
d2417 3
a2419 5
	xcr	r2, r2, SRX
	or	r2, r0, 10
	stcr	r2,  SR0
	br.n	_C_LABEL(m88110_fatal)
	 xcr	r2, r2, SRX
d2457 1
a2460 1
	 * SR0: current thread
a2484 1
	 * SR0: current thread
a2550 1
	 * SR0: saved return address to calling exception handler
a2573 1
	/*stcr	r1, SR0*/	/* save return address */
a2598 1
	 * SR0: current thread
d2626 1
a2626 1
	/* Now that EFZE is cleared, we can clear these */
d2634 2
a2635 1
	st.d	r30,  TMP,  GENREG_OFF(30)	/* save previous r30, r31 */
d2647 30
a2676 15
	st.d	r0 ,  r31,  GENREG_OFF(0)
	st.d	r2 ,  r31,  GENREG_OFF(2)
	st.d	r4 ,  r31,  GENREG_OFF(4)
	st.d	r6 ,  r31,  GENREG_OFF(6)
	st.d	r8 ,  r31,  GENREG_OFF(8)
	st.d	r10,  r31,  GENREG_OFF(10)
	st.d	r12,  r31,  GENREG_OFF(12)
	st.d	r14,  r31,  GENREG_OFF(14)
	st.d	r16,  r31,  GENREG_OFF(16)
	st.d	r18,  r31,  GENREG_OFF(18)
	st.d	r20,  r31,  GENREG_OFF(20)
	st.d	r22,  r31,  GENREG_OFF(22)
	st.d	r24,  r31,  GENREG_OFF(24)
	st.d	r26,  r31,  GENREG_OFF(26)
	st.d	r28,  r31,  GENREG_OFF(28)
d2684 6
a2690 1
	 * SR0: current thread
d2778 2
a2779 2
	/* enable interrupts */
	ldcr	r2,   PSR
d2788 1
a2788 1
	.align 8
@


1.39
log
@Narrow a conditional in non-88110 area...
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.38 2003/09/07 01:00:29 miod Exp $   */
d1865 6
d1872 2
a1873 3

	 ld	r3,   r30,  REG_OFF(EF_DMT0)
	bb0	DMT_VALID_BIT, r3, 7f
a1882 7
7:
	/* enable interrupts */
	ldcr	r2,   PSR
	clr	r2,   r2,   1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r2,   PSR
	FLUSH_PIPELINE

d1955 17
@


1.38
log
@Get rid of PREP2's SSBR parameter, since it does not have sense for 88110.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.37 2003/09/06 15:07:43 miod Exp $   */
d1287 1
a1287 1
#if defined(MVME187) || defined(MVME197)
d1344 1
a1344 1
#if defined(MVME187) || defined(MVME197)
@


1.37
log
@Large cleaning of exception handling:
- faster code paths in eh.S, especially for 88110 cpus
- do not service data access exceptions more than one time; also, be sure
  that interrupts are disabled while servicing them.
- cleanup the 88110 trap handler in the same way the 88100 flavour has been
  cleaned recently.

This spotted two bugs, which are fixed there as well:
- add systrace support to the 88110 syscall code
- add emulation support to the 88100 syscall code
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.36 2003/09/05 20:28:36 miod Exp $   */
d372 1
a372 1
#define PREP2(NAME, NUM, BIT, SSBR_STUFF, FLAG_PRECHECK) \
d2136 1
a2136 1
	PREP2("unknown", 0, DEBUG_UNKNOWN_BIT, No_SSBR_Stuff, No_Precheck)
d2142 1
a2142 1
	PREP2("interrupt", 1, DEBUG_INTERRUPT_BIT, No_SSBR_Stuff, No_Precheck)
d2148 1
a2148 1
	PREP2("inst", 2, DEBUG_INSTRUCTION_BIT, No_SSBR_Stuff, No_Precheck)
d2156 1
a2156 1
	PREP2("data", 3, DEBUG_DATA_BIT, No_SSBR_Stuff, M88110_Data_Precheck)
d2162 1
a2162 1
	PREP2("misalign", 4, DEBUG_MISALIGN_BIT, No_SSBR_Stuff, No_Precheck)
d2168 1
a2168 1
	PREP2("unimp", 5, DEBUG_UNIMPLEMENTED_BIT, No_SSBR_Stuff, No_Precheck)
d2174 1
a2174 1
	PREP2("privilege", 6, DEBUG_PRIVILEGE_BIT, No_SSBR_Stuff, No_Precheck)
d2183 1
a2183 1
	PREP2("bounds", 7, DEBUG_BOUNDS_BIT, No_SSBR_Stuff, No_Precheck)
d2189 1
a2189 1
	PREP2("divide", 8, DEBUG_DIVIDE_BIT, No_SSBR_Stuff, No_Precheck)
d2195 1
a2195 1
	PREP2("overflow", 9, DEBUG_OVERFLOW_BIT, No_SSBR_Stuff, No_Precheck)
d2201 1
a2201 1
	PREP2("FPU precise", 114, DEBUG_FPp_BIT, No_SSBR_Stuff, No_Precheck)
d2207 1
a2207 1
	PREP2("MVME197 non-mask", 11, DEBUG_NON_MASK_BIT, No_SSBR_Stuff, No_Precheck)
d2213 1
a2213 1
	PREP2("MVME197 read miss", 12, DEBUG_197_READ_BIT, No_SSBR_Stuff, No_Precheck)
d2219 1
a2219 1
	PREP2("MVME197 write miss", 13, DEBUG_197_WRITE_BIT, No_SSBR_Stuff, No_Precheck)
d2225 1
a2225 1
	PREP2("MVME197 inst miss", 14, DEBUG_197_INST_BIT, No_SSBR_Stuff, No_Precheck)
d2231 1
a2231 1
	PREP2("syscall", 128, DEBUG_SYSCALL_BIT, No_SSBR_Stuff, No_Precheck)
d2238 1
a2238 1
	PREP2("bugsyscall", 496, DEBUG_BUGCALL_BIT, No_SSBR_Stuff, No_Precheck)
d2244 1
a2244 1
	PREP2("sigsys", 501, DEBUG_SIGSYS_BIT, No_SSBR_Stuff, No_Precheck)
d2249 1
a2249 1
	PREP2("sigtrap", 510, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
d2254 1
a2254 1
	PREP2("stepbpt", 504, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
d2259 1
a2259 1
	PREP2("userbpt", 511, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
d2265 1
a2265 1
	PREP2("break", 130, DEBUG_BREAK_BIT, No_SSBR_Stuff, No_Precheck)
d2270 1
a2270 1
	PREP2("trace", 131, DEBUG_TRACE_BIT, No_SSBR_Stuff, No_Precheck)
d2275 1
a2275 1
	PREP2("kdb", 132, DEBUG_KDB_BIT, No_SSBR_Stuff, No_Precheck)
d2280 1
a2280 1
	PREP2("break", 130, DEBUG_BREAK_BIT, No_SSBR_Stuff, No_Precheck)
d2285 1
a2285 1
	PREP2("trace", 131, DEBUG_TRACE_BIT, No_SSBR_Stuff, No_Precheck)
d2290 1
a2290 1
	PREP2("unknown", 132, DEBUG_KDB_BIT, No_SSBR_Stuff, No_Precheck)
@


1.36
log
@Never enable interrupts just before processing data exceptions, but rather
afterwards... and only if this is a wise thing to do!
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.35 2003/09/05 10:03:18 miod Exp $   */
d253 1
a253 13
#define	OFF_VEC		0
#define	OFF_EPSR	4
#define	OFF_EXIP	8
#define	OFF_ENIP	12
#define	OFF_DSR		16
#define	OFF_DLAR	20
#define	OFF_DPAR	24
#define	OFF_ISR		28
#define	OFF_ILAR	32
#define	OFF_IPAR	36
#define	OFF_TMP		40


d307 1
d461 7
d476 2
a493 1
	/* interrupt_func is set in mvme_bootstrap() */
d509 1
d539 1
a539 4
/*
 * I'm not sure what the trap(T_BNDFLT,...) does, but it doesn't send
 * a signal to the process...
 */
d634 1
a634 1
	PREP("unknown", 132, DEBUG_UNKNOWN_BIT, No_SSBR_Stuff, No_Precheck)
d1287 1
d1293 1
d1344 1
d1352 1
a1684 1
#if 1
a1695 12
#else
	ldcr	TMP,  PSR
	or.u	TMP,  TMP,  0x8000	/* set supervisor mode */
	and	TMP,  TMP,  0xfff7	/* also enable shadowing */
	stcr	TMP,  EPSR
	stcr	r0,   SXIP	/* clear valid bit */
	stcr	r0,   SNIP	/* clear valid bit */
	or.u	TMP,  r0,   hi16(_ASM_LABEL(fpu_enable))
	or	TMP,  TMP,  lo16(_ASM_LABEL(fpu_enable))
	or	TMP,  TMP,  0x2	/* set the VALID_BIT and clear Exception bit */
	stcr	TMP,  SFIP	/* jump to here fpu_enable */
#endif
d1824 1
a1826 1
#ifdef INTSTACK
d1832 3
a1836 1
3:
d1850 5
d1867 2
a1868 2
	ld	r3,   r30,  REG_OFF(EF_DMT0)
	bb0	DMT_VALID_BIT, r3, 8f
d1878 1
d1880 1
a1880 1
	 ldcr	r2,   PSR
d1921 9
a1929 1
	br	_ASM_LABEL(return_from_exception_handler)
a1930 1
ASLOCAL(return_from_exception_handler)
d1936 1
a1936 1
	 * At this point, if EF_DMT0 is not zero, then
d1943 1
a1943 3
	 * control is transfered here from obvious places in this file
	 * and thread_bootstrap in luna88k/locore.c.
	 *
d1945 1
a1945 6
#ifdef M88110
	or.u	r2, r0, hi16(_C_LABEL(cputyp))
	ld	r3, r2, lo16(_C_LABEL(cputyp))
	cmp	r2, r3, CPU_88110
	bb1	eq, r2, _ASM_LABEL(m88110_return_code)
#endif
d1947 6
a1957 4
	/*
	 * if there happens to be a data fault that hasn't been serviced yet,
	 * go off and service that...
	 */
d1967 1
a1969 1
	 * If it's the data access exception, take care of it.
d1990 1
a1990 16
	br	2f	/* temp XXX smurph */
	ld	r2, FPTR, REG_OFF(EF_VECTOR)
	cmp	r2, r2, 3	/* Is it a data access exception? */
	bb1	ne, r2, 2f	/* If not, skip */

	/*
	 * if there happens to be a data fault that hasn't been serviced yet,
	 * go off and service that...
	 */
	CALL(_C_LABEL(m88110_trap), T_DATAFLT, r30)

	/* clear the dsr word in the E.F. */
	st	r0, FPTR, REG_OFF(EF_DSR)
	st	r0, FPTR, REG_OFF(EF_DLAR)
	st	r0, FPTR, REG_OFF(EF_DPAR)
2:
d2138 1
a2138 1
	DONE(DEBUG_UNKNOWN_BIT)
d2144 1
a2144 1
	DONE(DEBUG_INTERRUPT_BIT)
d2150 1
a2150 1
	DONE(DEBUG_INSTRUCTION_BIT)
d2158 1
a2158 1
	DONE(DEBUG_DATA_BIT)
d2164 1
a2164 1
	DONE(DEBUG_MISALIGN_BIT)
d2170 1
a2170 1
	DONE(DEBUG_UNIMPLEMENTED_BIT)
d2176 1
a2176 1
	DONE(DEBUG_PRIVILEGE_BIT)
d2185 1
a2185 1
	DONE(DEBUG_BOUNDS_BIT)
d2191 1
a2191 1
	DONE(DEBUG_DIVIDE_BIT)
d2197 1
a2197 1
	DONE(DEBUG_OVERFLOW_BIT)
d2203 1
a2203 1
	DONE(DEBUG_FPp_BIT)
d2209 1
a2209 1
	DONE(DEBUG_NON_MASK_BIT)
d2215 1
a2215 1
	DONE(DEBUG_197_READ_BIT)
d2221 1
a2221 1
	DONE(DEBUG_197_WRITE_BIT)
d2227 1
a2227 1
	DONE(DEBUG_197_INST_BIT)
d2234 1
a2234 1
	DONE(DEBUG_SYSCALL_BIT)
d2241 1
a2241 1
	DONE(DEBUG_BUGCALL_BIT)
d2246 1
a2246 1
	DONE(DEBUG_SIGSYS_BIT)
d2251 1
a2251 1
	DONE(DEBUG_SIGTRAP_BIT)
d2256 1
a2256 1
	DONE(DEBUG_SIGTRAP_BIT)
d2261 1
a2261 1
	DONE(DEBUG_SIGTRAP_BIT)
d2267 1
a2267 1
	DONE(DEBUG_BREAK_BIT)
d2272 1
a2272 1
	DONE(DEBUG_TRACE_BIT)
d2277 1
a2277 1
	DONE(DEBUG_KDB_BIT)
d2282 1
a2282 1
	DONE(DEBUG_BREAK_BIT)
d2287 1
a2287 1
	DONE(DEBUG_TRACE_BIT)
d2290 1
a2290 1
	PREP2("unknown", 132, DEBUG_UNKNOWN_BIT, No_SSBR_Stuff, No_Precheck)
d2292 1
a2292 1
	DONE(DEBUG_KDB_BIT)
d2851 1
a2853 1
#ifdef INTSTACK
d2859 3
d2864 1
a2864 1
3:	/*
d2889 1
a2889 1
	 ldcr	r2,   PSR
a2892 5
#if 1 /* XXX test */
	br	8f
#else
	/* service any outstanding data pipeline stuff
	   - check dsr... anything outstanding? */
a2893 18
	ld	r3,   r30,  REG_OFF(EF_DSR)
	cmp	r3,   r3,   0
	bb1	eq,   r3,   8f

/*
 * r30 can be clobbered by calls. So stuff its value into a
 * preserved register, say r15. R14 is in use (see return_to_... below).
 */
	or	r15,  r0,   r30
	CALL(_C_LABEL(m88110_trap), T_DATAFLT, r15)

	/* restore it... */
	or	r30,  r0,   r15

	/* clear the dsr word in the E.F */
	st	r0,   r30,  REG_OFF(EF_DSR)

#endif
d2895 1
a2895 1
	jmp	r14 /* loaded above */
@


1.35
log
@Do not drop the user into DDB without a really, really good reason.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.34 2003/09/01 20:06:02 miod Exp $   */
d1872 1
a1872 8
	/* enable interrupts */
	 ldcr	r2,   PSR
	clr	r2,   r2,   1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r2,   PSR
	FLUSH_PIPELINE

	/* service any outstanding data pipeline stuff
	   - check dmt0 anything outstanding? */
a1881 1

a1882 3
	CALL(_C_LABEL(data_access_emulation), r15, r0)

	/* restore it... */
d1885 5
a1889 2
	/* clear the dmt0 word in the E.F */
	st	r0,   r30,  REG_OFF(EF_DMT0)
a1957 45
#ifdef DEBUG
	/*
	 * This might happen for non-interrupts  If the user sets DMT0
	 * in an exception handler...
	 */
	ld	r2, FPTR, REG_OFF(EF_VECTOR)
	cmp	r2, r2, 1	/* is an interrupt? */
	bb1	eq, r2, 1f
	or.u	r4, r0, hi16(2f)
	or	r4, r4, lo16(2f)
#ifdef DDB
	CALL(_C_LABEL(db_printf), r4, r0)
	tb0	0, r0, 132
#endif
	br	1f
	data
2:	string "OOPS: DMT0 not zero and not interrupt.\n\000"
	align 8
	text
1:
#endif
	/*
	 * If it's the interrupt exception, enable interrupt.
	 * Take care of any data access exception...... 90/8/15 add by yama
	 */

	/*
	 * Is it ever possible to have interrupt exception while EPSR has
	 * it disabled? I don't think so.. XXX nivas
	 */
	ld	r2, FPTR, REG_OFF(EF_VECTOR)
	cmp	r2, r2, 1	/* is an interrupt? */
        bb1	ne, r2, 1f	/* If not so, skip */

	/* if EPSR has interrupts disabled, skip also */
	ld	r2, FPTR, REG_OFF(EF_EPSR)
        bb1	PSR_INTERRUPT_DISABLE_BIT, r2, 1f	/* skip if disabled */
	ldcr	r2, PSR
	clr	r2, r2, 1<PSR_INTERRUPT_DISABLE_BIT>	/* enable interrupts */
        stcr	r2, PSR
	FLUSH_PIPELINE
1:
	ld	r2, FPTR, REG_OFF(EF_DMT0)
	bb0	DMT_VALID_BIT, r2, 2f

a1962 4
	CALL(_C_LABEL(data_access_emulation), r30, r0)	/* really only 2 args */
	/* clear the dmt0 word in the E.F. */
	st	r0 , FPTR, REG_OFF(EF_DMT0)
2:
@


1.34
log
@Be sure to always provide a nonzero number in PREP() and PREP2() for software
traps not tied to a particular vector, in order to correctly process data
access faults whenever necessary, before servicing the trap.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.33 2003/08/21 20:45:43 miod Exp $   */
d1966 1
a1966 1
#if 1
@


1.33
log
@Use constants rather than hardcoded values for IPL levels.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.32 2003/08/13 08:52:44 miod Exp $   */
d593 1
a593 1
	PREP("sigsys", 0, DEBUG_SIGSYS_BIT, No_SSBR_Stuff, No_Precheck)
d598 1
a598 1
	PREP("sigtrap", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
d603 1
a603 1
	PREP("stepbpt", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
d608 1
a608 1
	PREP("userbpt", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
d2320 1
a2320 1
	PREP2("sigsys", 0, DEBUG_SIGSYS_BIT, No_SSBR_Stuff, No_Precheck)
d2325 1
a2325 1
	PREP2("sigtrap", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
d2330 1
a2330 1
	PREP2("sigtrap", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
d2335 1
a2335 1
	PREP2("sigtrap", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
@


1.32
log
@Always force a pipeline flush after a PSR change, not before. How could
this have ever worked?
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.31 2003/08/11 20:45:17 miod Exp $   */
d2082 1
a2082 1
	 or	r2,r0,1
d2089 1
a2089 1
	 or	r2,r0,0			/* ints are enabled */
@


1.31
log
@Sprinkle proper use of _C_LABEL and _ASM_LABEL in the .S files (except for
the _fp.S which are too scary at the moment). This will be necessary to
move to ELF in the future.

Use local symbols whenever possible.

Attempt to use delayed branches whenever possible.

Remove stupid or straightforward comments, some hardcoded values, and a
few unused variables or routines.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.30 2003/08/03 23:34:09 miod Exp $   */
d1020 1
a1021 1
	stcr	r4, PSR
d1106 1
a1107 1
	stcr	r8, PSR
a1875 1
#ifdef DDB
a1876 1
#endif
d2005 1
a2006 1
        stcr	r2, PSR
d2048 1
a2049 1
	stcr	r2, PSR
d2126 1
a2127 1
	stcr	r1, PSR
d2160 1
a2161 1
	stcr	r1, PSR
a2964 1
#ifdef DDB
a2965 1
#endif
@


1.30
log
@Resistance is futile, you will be KNF'ed.
And then it will be easier to debug this mess (no functional change yet).
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.29 2003/01/14 03:20:16 miod Exp $   */
d34 1
a34 1
 * 2. Make up my mind what is _kstack. I think it should be p->p_addr+UPAGES.
d37 1
a37 2
 *   Whatever is _kstack, its usage in this file should be
 *   revisited.
a215 1
#include <machine/board.h>
d240 2
a241 2
sbadcpupanic:
	string	"eh.S: bad cpu number in FLAGS"
d246 4
a249 4
Lbadcpupanic:
	or.u	r2, r0, hi16(sbadcpupanic)
	or	r2, r2, lo16(sbadcpupanic)
	bsr	_C_LABEL(panic)
d268 2
a269 2
	or.u	r31, r0,  hi16(_save_frame)	; \
	or	r31, r31, lo16(_save_frame)	; \
d357 1
a357 1
	/* the bsr later clobbers r1, so save now */	; \
d359 1
a359 1
	/* set or clear the FLAG_FROM_KERNEL bit */	; \
d364 3
a366 3
	/* get a stack (exception frame) */		; \
1:	bsr	setup_phase_one				; \
	/* TMP2 now free -- use to set EF_VECTOR */	; \
d369 5
a373 5
	/* TMP3 also free -- use to set last_vector */	; \
	or.u	TMP3, r0,   hi16(_last_vector)		; \
	st	TMP2, TMP3, lo16(_last_vector)		; \
	/* Clear any bits in the SSBR (held in TMP) */	; \
	/* SSBR_STUFF may be empty, though.         */	; \
d375 4
a378 4
	/* call setup_phase_two to restart the FPU  */	; \
	/* and to save all general registers.       */	; \
	bsr	setup_phase_two				; \
	/* All general regs free -- do any debugging */	; \
d395 1
a395 1
1:	bsr	m88110_setup_phase_one			; \
d401 1
a401 1
	bsr	m88110_setup_phase_two			; \
d409 1
a409 1
	bsr	clear_dest_ssbr_bit
d412 2
a413 1
	bb1.n	FLAG_IGNORE_DATA_EXCEPTION, FLAGS, ignore_data_exception
d415 2
a416 1
	bb1.n	FLAG_IGNORE_DATA_EXCEPTION, FLAGS, m88110_ignore_data_exception
d428 1
a428 1
GLOBAL(eh_debug)
d437 18
a454 18
	or.u	r2, r0, hi16(_eh_debug)		; \
	ld	r3, r2, lo16(_eh_debug)		; \
	bb0	DebugNumber, r3, 4f		; \
	/* call MY_info(ef,thread,flags,kind)*/	; \
	or	r2, r30, r0			; \
	ldcr	r3, SR0				; \
	ldcr	r4, SR1				; \
	or.u	r5, r0, hi16(2f)		; \
	or	r5, r5, lo16(2f)		; \
	bsr.n	_MY_info			; \
	 subu	r31, r31, 40			; \
	br.n	4f				; \
	 addu	r31, r31, 40			; \
	data					; \
2:	string Name				; \
	byte	0				; \
	align	4				; \
	text					; \
d466 6
a471 6
	or.u	r2, r0, hi16(_eh_debug)	; \
	ld	r3, r2, lo16(_eh_debug)	; \
	bb0	DebugNumber, r3, 2f	; \
	ldcr	r4, SR1			; \
	CALL(_MY_info_done, r31, r4)	; \
2:	br	return_from_exception_handler
d479 1
a479 1
	br	return_from_exception_handler
a497 1
	/*CALLP(_interrupt_func, 1, r30) */
d564 1
a564 1
	bsr	clear_FPp_ssbr_bit
d567 1
a567 1
	CALL(_m88100_Xfp_precise, r0, r30)
d572 1
a572 1
	bsr	clear_FPi_ssbr_bit
d575 1
a575 1
	CALL(_Xfp_imprecise, r0, r30)
d582 1
a582 1
	CALL(_m88100_syscall, r13, r30)	/* system call no. is in r13 */
d589 1
a589 1
	CALL(_bugsyscall, r9, r30)	/* system call no. is in r9 */
d658 2
a659 2
	or.u	r31, r0,  hi16(_intstack_end)
	or	r31, r31, lo16(_intstack_end)
d662 2
a663 2
	or.u	r27, r0,  hi16(_intstack)
	or	r27, r27, lo16(_intstack)
d744 2
a745 2
	or.u	r10,  r0,   hi16(_brdtyp)
	ld	r11,  r10,  lo16(_brdtyp)
d780 2
a781 2
GLOBAL(error_loop)
	bsr	_error_loop
d806 2
a807 2
	or.u	r31, r0,  hi16(_intstack_end)
	or	r31, r31, lo16(_intstack_end)
d810 2
a811 2
	or.u	r27, r0,  hi16(_intstack)
	or	r27, r27, lo16(_intstack)
d919 2
a920 2
GLOBAL(error_loop2)
	bsr	_error_loop2
d926 1
a926 1
ASGLOBAL(ignore_data_exception)
d947 2
a948 2
	or.u	r2, r0, hi16(badaddr__return_nonzero + 2)
	or	r2, r2, lo16(badaddr__return_nonzero + 2)
d963 1
a963 1
ASGLOBAL(m88110_ignore_data_exception)
d983 2
a984 2
	or.u	r2, r0, hi16(m88110_badaddr__return_nonzero)
	or	r2, r2, lo16(m88110_badaddr__return_nonzero)
d1032 1
a1032 1
	bcnd.n	ne0, r6, badaddr__maybe_halfword
d1039 2
a1040 2
	bb1	0, r2, badaddr__return_nonzero
	bb1	1, r2, badaddr__return_nonzero
d1052 1
a1052 1
	br.n	badaddr__return
d1055 1
a1055 1
badaddr__maybe_halfword:
d1058 1
a1058 1
	bcnd	ne0, r6, badaddr__maybe_byte
d1061 1
a1061 1
	bb1	0, r2, badaddr__return_nonzero
d1066 1
a1066 1
	br.n	badaddr__return
d1069 1
a1069 1
badaddr__maybe_byte:
d1072 1
a1072 1
	bcnd	ne0, r6, badaddr__unknown_size
d1076 1
a1076 1
	br.n	badaddr__return
d1078 1
a1078 1
badaddr__unknown_size:
d1081 1
a1081 1
1: 	string "bad length (%d) to badaddr() from 0x%x"
d1085 2
a1086 5
	or	r4, r0, r1
	bsr	_C_LABEL(printf)
	or.u	r2, r0, hi16(1b)
	or	r2, r2, lo16(1b)
	bsr	_C_LABEL(panic)
d1110 1
a1110 1
ASGLOBAL(m88110_badaddr__return_nonzero)
d1119 1
a1119 1
	br.n	badaddr__return_nonzero
d1124 1
a1124 1
ASGLOBAL(setup_phase_one)
d1134 2
a1135 2
	 *  Decide where we're going to put the exception frame.
	 *  Might be at the end of R31, SR3, or the thread's pcb.
d1146 1
a1146 1
	bb1	FLAG_ENABLING_FPU, FLAGS, use_SR3_pcb
d1148 1
a1148 1
	bb0	FLAG_FROM_KERNEL, FLAGS, pickup_stack
a1150 1
ASGLOBAL(already_on_kernel_stack)
d1171 1
a1171 1
	br.n	have_pcb
d1174 1
a1174 1
ASGLOBAL(use_SR3_pcb)
d1211 1
a1211 1
	br.n	have_pcb
d1218 2
a1219 2
	or.u	r1,   r0,   hi16(_kstack)
	ld	r1,   r1,   lo16(_kstack)
d1228 1
a1228 1
	br.n	have_pcb
d1231 1
a1231 1
ASGLOBAL(pickup_stack)
d1247 2
a1248 2
	or.u	r31,  r0,   hi16(_curpcb)
	ld	r31,  r31,  lo16(_curpcb)
d1256 1
a1256 1
ASGLOBAL(have_pcb)
d1293 2
a1294 2
	or.u	TMP,  r0,   hi16(_brdtyp)
	ld	TMP2, TMP,  lo16(_brdtyp)
d1308 1
a1308 1
	br	Lbadcpupanic
d1317 1
a1317 1
	br	pfsr_done
d1326 1
a1326 1
	br	pfsr_done
d1335 1
a1335 1
	br	pfsr_done
d1344 1
a1344 1
	br	pfsr_done
d1355 1
a1355 1
ASGLOBAL(pfsr_done)
d1384 1
a1384 1
	bb0.n	DMT_VALID_BIT, TMP3, DMT_check_finished
a1412 1
ASGLOBAL(check_DMT0)
d1414 1
a1414 1
	bb0.n	DMT_VALID_BIT, TMP2, DMT_check_finished
d1417 3
a1419 4
	bb1	DMT_LOCK_BIT,  TMP2, do_DMT0
	bb1	DMT_WRITE_BIT, TMP2, check_DMT1

ASGLOBAL(do_DMT0)
d1423 1
a1423 2

ASGLOBAL(check_DMT1)
d1425 4
a1428 5
	bb0	DMT_VALID_BIT, TMP2, check_DMT2
	bb1	DMT_LOCK_BIT,  TMP2, do_DMT1
	bb1	DMT_WRITE_BIT, TMP2, check_DMT2

ASGLOBAL(do_DMT1)
d1432 1
a1432 2

ASGLOBAL(check_DMT2)
d1434 5
a1438 6
	bb0	DMT_VALID_BIT, TMP2, DMT_check_finished
	bb1	DMT_LOCK_BIT,  TMP2, do_DMT2_single
	bb1	DMT_WRITE_BIT, TMP2, DMT_check_finished
	bb1	DMT_DOUBLE_BIT,TMP2, do_DMT2_double

ASGLOBAL(do_DMT2_single)
d1440 3
a1442 4
	br.n	1f
	 set	TMP2, TMP2, 1<5>

ASGLOBAL(do_DMT2_double)
d1444 4
a1447 4
	set	TMP2, TMP2, 1<6>
1:	clr	TMP,  TMP,  TMP2

ASGLOBAL(DMT_check_finished)
d1472 1
a1472 1
ASGLOBAL(clear_FPi_ssbr_bit)
d1502 1
a1502 1
	bb0	FPIT_SIZE_BIT, TMP2, not_double_fpi
d1506 1
a1506 2

ASGLOBAL(not_double_fpi)
d1510 1
a1510 1
ASGLOBAL(clear_FPp_ssbr_bit)
d1546 5
a1550 3
2:	set	TMP3, TMP3, 1<6>	/* size=2 - clear two bit for double */
3:	clr	TMP,  TMP,  TMP3	/* clear bit(s) in ssbr. */
4:	jmp	r1
d1553 1
a1553 1
ASGLOBAL(clear_dest_ssbr_bit)
d1585 1
a1585 1
1:	/* user space load here */
d1624 1
a1624 1
	bb1	eq,   TMP3, misaligned_double
d1631 1
a1631 1
	bb1	ne,   TMP3, misaligned_single	/* not equal, must be single */
d1637 1
a1637 1
	bb1	eq,   TMP3, misaligned_double
d1639 1
a1639 1
ASGLOBAL(misaligned_single)
d1641 1
a1641 1
	br.n	1f
d1644 1
a1644 1
ASGLOBAL(misaligned_double)
d1647 2
a1648 2

1:	jmp.n	r1
d1653 1
a1653 1
ASGLOBAL(setup_phase_two)
d1693 2
a1694 2
	or.u	TMP,  r0,   hi16(fpu_enable +2)
	or	TMP,  TMP,  lo16(fpu_enable +2)
d1705 2
a1706 2
	or.u	TMP,  r0,   hi16(fpu_enable)
	or	TMP,  TMP,  lo16(fpu_enable)
a1710 1
setup_phase_two_cont:
d1745 1
a1745 1
ASGLOBAL(fpu_enable)
d1818 4
a1826 6
#endif
	or	r30,  r0,   r31		/* get a copy of the e.f. pointer */
	ld	r2,   r31,  REG_OFF(EF_EPSR)
	bb1	PSR_SUPERVISOR_MODE_BIT, r2, 1f	/* if in kernel mode */

#ifdef INTSTACK
d1830 2
a1831 2
	or.u	r31,  r0,   hi16(_intstack_end)	/* switch to int stack */
	or	r31,  r31,  lo16(_intstack_end)
d1835 2
a1836 2
	or.u	r31,  r0,   hi16(_kstack)
	ld	r31,  r31,  lo16(_kstack)
d1844 2
a1845 2
	or.u	r31,  r0,   hi16(_intstack_end)	/* switch to int stack */
	or	r31,  r31,  lo16(_intstack_end)
d1847 3
a1849 4
	/* This label is here for debugging */
exception_handler_has_ksp:
global exception_handler_has_ksp
3:	/*
d1860 1
a1860 1
	bcnd.n	eq0,  r2,   return_to_calling_exception_handler	/* is error */
d1862 2
a1863 2
	cmp	r3,   r2,   1	/* is an interrupt? */
	bb1.n	eq,   r3,   return_to_calling_exception_handler	/* skip if so */
d1867 1
a1867 1
	bb1.n	eq,   r3,   return_to_calling_exception_handler
d1869 1
a1869 1
	bb1.n	eq,   r3,   return_to_calling_exception_handler
d1876 1
a1876 1
#ifdef     DDB
d1884 1
a1884 1
	bb0	DMT_VALID_BIT, r3, return_to_calling_exception_handler
d1893 1
a1893 1
	CALL(_data_access_emulation, r15, r0)
d1901 1
a1901 1
ASGLOBAL(return_to_calling_exception_handler)
a1923 1
	bsr	_C_LABEL(panic)
d1937 1
a1937 1
	br	return_from_exception_handler
d1939 1
a1939 1
ASGLOBAL(return_from_exception_handler)
d1960 1
a1960 1
	bb1	eq, r2, m88110_return_code
d1966 1
a1966 1
	bb0	DMT_VALID_BIT, r3, check_ast
d2022 1
a2022 1
	br	check_ast
d2280 1
a2280 1
	CALL(_m88110_Xfp_precise, r0, r30)
d2311 1
a2311 1
	CALL(_m88110_syscall, r13, r30)	/* system call no. is in r13 */
d2318 1
a2318 1
	CALL(_bugsyscall, r9, r30)	/* system call no. is in r9 */
d2400 1
a2400 1
 * This is totaly different than _error_handler.  Shadowing might or
d2402 1
a2402 1
 * R1-R31 could tell u alot about what happend, so we'll save them.
d2413 2
a2414 2
	or.u	r31, r0,  hi16(_intstack_end)
	or	r31, r31, lo16(_intstack_end)
d2417 2
a2418 2
	or.u	r27, r0,  hi16(_intstack)
	or	r27, r27, lo16(_intstack)
d2480 2
a2481 2
	or.u	r30, r0,  hi16(_save_frame)
	or	r30, r30, lo16(_save_frame)
d2537 1
a2537 1
	CALL(_error_fatal, r30, r30)
d2545 2
a2546 2
ASGLOBAL(m88110_error_loop)
	bsr	m88110_error_loop
d2549 1
a2549 1
ASGLOBAL(m88110_setup_phase_one)
d2571 1
a2571 1
	bb1	FLAG_ENABLING_FPU, FLAGS, m88110_use_SR3_pcb
d2573 1
a2573 1
	bb0	FLAG_FROM_KERNEL, FLAGS, m88110_pickup_stack
a2575 1
ASGLOBAL(m88110_already_on_kernel_stack)
d2596 1
a2596 1
	br.n	m88110_have_pcb
d2599 1
a2599 1
ASGLOBAL(m88110_use_SR3_pcb)
d2641 1
a2641 1
	br.n	m88110_have_pcb
d2650 2
a2651 2
	or.u	r1,   r0,   hi16(_kstack)
	ld	r1,   r1,   lo16(_kstack)
d2660 1
a2660 1
	br.n	m88110_have_pcb
d2663 1
a2663 1
ASGLOBAL(m88110_pickup_stack)
d2679 2
a2680 2
	or.u	r31,  r0,   hi16(_curpcb)
	ld	r31,  r31,  lo16(_curpcb)
d2688 1
a2688 1
ASGLOBAL(m88110_have_pcb)
d2755 1
a2755 1
ASGLOBAL(m88110_setup_phase_two)
d2791 3
a2793 3
	or.u	TMP,  r0,   hi16(m88110_fpu_enable)
	or	TMP,  TMP,  lo16(m88110_fpu_enable)
	stcr	TMP,  EXIP	/* jump to here fpu_enable */
d2825 1
a2825 1
	 *   Do an RTE to restart the fpu and jump to "fpu_enable"
d2830 1
a2830 1
	RTE	/* jumps to "fpu_enable" on the next line to enable the FPU. */
d2832 1
a2832 1
ASGLOBAL(m88110_fpu_enable)
d2921 2
a2922 2
	or.u	r31,  r0,   hi16(_intstack_end)	/* switch to int stack */
	or	r31,  r31,  lo16(_intstack_end)
d2926 2
a2927 2
	or.u	r31,  r0,   hi16(_kstack)
	ld	r31,  r31,  lo16(_kstack)
d2935 2
a2936 2
	or.u	r31,  r0,   hi16(_intstack_end)	/* switch to int stack */
	or	r31,  r31,  lo16(_intstack_end)
d2938 1
a2938 3
	/* This label is here for debugging */
m88110_exception_handler_has_ksp:
global m88110_exception_handler_has_ksp
d2950 1
a2950 1
	bcnd.n	eq0,  r2,   m88110_return_to_calling_exception_handler
d2953 1
a2953 1
	bb1.n	eq,   r3,   m88110_return_to_calling_exception_handler
d2957 1
a2957 1
	bb1.n	eq,   r3,   m88110_return_to_calling_exception_handler
d2960 1
a2960 1
	bb1.n	eq,   r3,   m88110_return_to_calling_exception_handler
d2967 1
a2967 1
#ifdef     DDB
d2970 3
a2972 3
#if 1 /* test */
	br	m88110_return_to_calling_exception_handler
#endif
d2978 1
a2978 1
	bb1	eq,   r3,   m88110_return_to_calling_exception_handler
d2993 2
a2994 1
ASGLOBAL(m88110_return_to_calling_exception_handler)
d2999 1
a2999 1
GLOBAL(save_frame)
@


1.29
log
@Define exception vector tables as assembly source, with the appropriate
macros, rather than include files - no need to pollute <machine/> area...
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.28 2003/01/13 20:12:18 miod Exp $   */
d34 3
a36 4
 * 2. Make up my mind what is _kstack. I think it
 *       should be p->p_addr+UPAGES. (p_addr
 *         is pointing to user struct and swapin is
 *         making sure it is updated)
d40 15
a54 19
 
 /*
 **************************************************************RCS******
 *
 *  -------------------------------------------------------------------
 * ;  In the following discussion, references are made to:             ;
 * ;          MC88100 - RISC MICROPROCESSOR USER'S MANUAL              ;
 * ;  (second edition). Reference in []s refer to section numbers.     ;
 * ;                                                                   ;
 * ;  This discussion assumes that you are at least vaguely familiar   ;
 * ;  with 88100 exception handling (chapter 6), the MACH kernel, and  ;
 * ;  that you have a brain (and use it while reading this).           ;
 * ;                                                                   ;
 * ;  I also assume (and hope) that you're not offended by             ;
 * ;  frequent misspellings.                                           ;
 * ;                                                                   ;
 * ;                       Jeffrey Friedl                              ;
 * ;            jfriedl@@rna.ncl.omron.co.jp             ;
 * ;                       December, 1989                              ;
d212 1
d215 2
a216 2
#include <machine/param.h>          /* CPU_ and BRD_ defines */
#include <machine/trap.h>           /* for T_ defines */
d224 6
a229 5
 * EF_SR3    A place to save the exception-time SR3 from just after the
 *         time when an exception is raised until just after the FPU
 *         has been restarted.  This does not necessarly conflict with
 *        the general registers (though it can if you're not careful)
 *         and so we can use a spot later used to save a general register.
d231 2
a232 1
 * EF_FLAGS  This is just the old EF_MODE. "EF_MODE" isn't a very good name.
d234 5
a238 2
#define EF_SR3         (EF_R0 + 5)
#define EF_FLAGS      EF_MODE
a239 1
#define INTSTACK	0   /* To make interupts use their own stack */
d243 2
a244 2
	string  "eh.S: bad cpu number in FLAGS"
	
d249 3
a251 3
	or.u r2, r0, hi16(sbadcpupanic)
	or   r2, r2, lo16(sbadcpupanic)
	bsr  _C_LABEL(panic)
d255 11
a265 11
#define OFF_VEC		0
#define OFF_EPSR	4
#define OFF_EXIP	8
#define OFF_ENIP	12
#define OFF_DSR		16
#define OFF_DLAR	20
#define OFF_DPAR	24
#define OFF_ISR		28
#define OFF_ILAR	32
#define OFF_IPAR	36
#define OFF_TMP		40
d268 1
a268 1
#define SAVE_CTX				; \
d317 1
a317 1
	/* Restore r1, r2, r3, and r31	*/	; \
d322 32
a353 31
/***************************************************************************
 ***************************************************************************
 **
 ** #define PREP(NAME, NUM, BIT, SSBR_STUFF, FLAG_CHECK)
 **
 ** This is the "exception processing preparaton" common to all exception
 ** processing.  It is used in the following manor:
 **
 **    ASGLOBAL(foo_handler)
 **           PREP("foo", 11, DEBUG_FOO_BIT, No_SSBR_Stuff, No_Precheck)
 **           CALL(_C_LABEL(trapXXX), T_FOO_FAULT, r31)
 **           DONE(DEBUG_FOO_BIT)
 **
 ** This defines the exception handler for the "foo" exception.
 ** The arguments ro PREP():
 **   NAME -    String for debugging (more info later)
 **   NUM  -    The exception number [see the manual, Table 6-1]
 **   BIT  -    Bit to check in eh_debug for debugging (more info later)
 **   SSBR_STUFF -
 **      If the exception might leave some bits in the SSBR set,
 **      this should indicate how they are cleared.
 **   FLAG_PRECHECK -
 **      This is for the data access exception only. See it for
 **      more info.
 **
 **
 ** What's in between PREP() and DONE() (usually a CALL) is the actual
 ** servicing of the interrupt.  During this time, any register may
 ** be used freely as they've all been saved in the exception frame
 ** (which is pointed-to by r31).
 **/
d356 1
a356 1
#define PREP(NAME, NUM, BIT, SSBR_STUFF, FLAG_PRECHECK)	; \
a358 1
							; \
d360 1
a360 1
	stcr	r1, SR2   /* r1 now free */		; \
d364 1
a364 1
	clr	FLAGS, FLAGS, 1<FLAG_FROM_KERNEL>	; \
a365 1
							; \
a367 1
							; \
a373 1
							; \
a376 1
							; \
a379 1
							; \
d382 1
a382 1
#endif /* m88100 */
d385 1
a385 1
#define PREP2(NAME, NUM, BIT, SSBR_STUFF, FLAG_PRECHECK); \
d390 1
a390 1
	stcr    r1, SR2   /* r1 now free */		; \
d392 4
a395 5
	ldcr    r1, EPSR 				; \
	bb0.n   PSR_SUPERVISOR_MODE_BIT, r1, 1f 	; \
	clr     FLAGS, FLAGS, 1<FLAG_FROM_KERNEL> 	; \
	set     FLAGS, FLAGS, 1<FLAG_FROM_KERNEL>	; \
							; \
a397 1
							; \
a400 1
							; \
a403 1
							; \
d406 1
a406 1
#endif /* M88110 */
d409 8
a416 7
#define No_SSBR_Stuff      /* empty */
#define Clear_SSBR_Dest      bsr clear_dest_ssbr_bit
#define No_Precheck      /* empty */
#define Data_Precheck \
   bb1.n   FLAG_IGNORE_DATA_EXCEPTION, FLAGS, ignore_data_exception
#define M88110_Data_Precheck \
   bb1.n   FLAG_IGNORE_DATA_EXCEPTION, FLAGS, m88110_ignore_data_exception
d419 18
a436 17
   /*
    * If we allow debugging, there is a variable "eh_debug"
    * in which there is a bit for each exception.  If the bit
    * is set for an exception, debugging information is printed
    * about that exception whenever it occurs.
    *
    * The bits are defined in "asm.h"
    */

GLOBAL(eh_debug)	word 0x00000000
   
   /*
    * additional pre-servicing preparation to be done when
    * debugging... check eh_debug and make the call if
    * need be.
    */
#define PREP_DEBUG(DebugNumber, Name)  \
d447 1
a447 1
	subu	r31, r31, 40			; \
d449 1
a449 1
	addu	r31, r31, 40			; \
d451 1
a451 1
	2: string Name				; \
d455 1
a455 1
	4:
d458 8
a465 8
   /*
    * Post-servicing work to be done.
    * When debugging, check "eh_debug" and call the
    * debug routined if neeed be.
    *
    * Then, return from the interrupt handler.
    */
#define DONE(DebugNumber)  \
d473 8
a480 7
   /*
    * If not debugging, then no debug-prep to do.
    * Also, when you're done, you're done!   (no debug check).
    */
#define PREP_DEBUG(bit, name)
#define DONE(num)      br return_from_exception_handler
#endif
d483 3
a485 3
/*#########################################################################*/
/*#### THE ACTUAL EXCEPTION HANDLER ENTRY POINTS for MVME18x ##############*/
/*#########################################################################*/
d533 4
a536 4
	stcr    r1, SR2    /* hold r1 for a moment */
	ldcr    r1, SXIP   /* look at the sxip... valid bit set? */
	bb1.n   RTE_VALID_BIT, r1, 1f /*skip over return if a valid exception*/
	ldcr    r1, SR2    /* restore r1 */
d539 1
a539 1
	CALL(_C_LABEL(m88100_trap), T_PRIVINFLT, r30) 
d564 2
a565 1
#define FPp_SSBR_STUFF bsr clear_FPp_ssbr_bit
d568 1
a568 1
	CALL(_m88100_Xfp_precise, r0, r30) /* call fp_precise(??, exception_frame)*/
d572 2
a573 1
#define FPi_SSBR_STUFF  bsr clear_FPi_ssbr_bit
d576 1
a576 1
	CALL(_Xfp_imprecise, r0, r30) /*call fp_imprecise(??,exception_frame)*/
d582 2
a583 2
	ld   r13, r30, GENREG_OFF(13)
	CALL(_m88100_syscall, r13, r30) /* system call no. is in r13 */
d589 2
a590 2
	ld   r9,  r30, GENREG_OFF(9)
	CALL(_bugsyscall, r9, r30)   /* system call no. is in r9 */
d613 1
a613 1
#if DDB
d628 1
a628 2

#else /* else not DDB */
d643 1
a643 3
#endif   /* DDB */

/*--------------------------------------------------------------------------*/
d657 2
a658 2
        /* pick up the slavestack */
	or	r26, r0, r31           /* save old stack */
d666 1
a666 1
	bb1	ge,  r28, 2f   /* branch if at the end of the stack */
d669 2
a670 2
	addu	r27, r27, 4   /* bump up */
2:   /* stack has been cleared */
d672 2
a673 2
   /* ensure that stack is 8-byte aligned */
        clr     r31, r31, 3<0>  /* round down to 8-byte boundary */
d675 2
a676 2
   /* create exception frame on stack */
        subu    r31, r31, SIZEOF_EF             /* r31 now our E.F. */
d678 15
a692 15
   /* save old R31 and other R registers */
        st.d    r0 , r31, GENREG_OFF(0)
        st.d    r2 , r31, GENREG_OFF(2)
        st.d    r4 , r31, GENREG_OFF(4)
        st.d    r6 , r31, GENREG_OFF(6)
        st.d    r8 , r31, GENREG_OFF(8)
        st.d    r10, r31, GENREG_OFF(10)
        st.d    r12, r31, GENREG_OFF(12)
        st.d    r14, r31, GENREG_OFF(14)
        st.d    r16, r31, GENREG_OFF(16)
        st.d    r18, r31, GENREG_OFF(18)
        st.d    r20, r31, GENREG_OFF(20)
        st.d    r22, r31, GENREG_OFF(22)
        st.d    r24, r31, GENREG_OFF(24)
        st      r30, r31, GENREG_OFF(30)
d694 1
a694 1
	
d708 1
a708 1
	stcr	r0,  SSBR  /* won't want shadow bits bothering us later */
d729 1
a729 1
	
d743 1
a743 1
#define IST_REG      0xfff84040	/* interrupt status addr */
d749 1
a749 1
	or.u	r10,  r0,   hi16(IST_REG) /* interrupt status register */
d751 2
a752 2
	st	r11, r31,   REG_OFF(EF_MASK) /* put in EF_MASK for regdump */ 
#endif /* MVME188 */ 
d756 4
a759 4
3:      ldcr    r10, PSR
        clr     r10, r10, 1<PSR_FPU_DISABLE_BIT>    /* enable the FPU */
        clr     r10, r10, 1<PSR_SHADOW_FREEZE_BIT>  /* also enable shadowing */
        stcr    r10, PSR  /* bang */
d765 3
a767 3
        subu	r31, r31, 0x10 /* make some breathing space */
        st	r30, r31, 0x0c /* store frame pointer on the st */
        st	r30, r31, 0x08 /* store again for the debugger to recognize */ 
d773 1
a773 1
        CALL(_C_LABEL(error_fault), r30, r30)
d775 5
a779 5
        /* TURN INTERUPTS back on */
        ldcr r1, PSR
	clr  r1, r1, 1<PSR_INTERRUPT_DISABLE_BIT>
        stcr r1, PSR
        FLUSH_PIPELINE
d781 3
a783 2
GLOBAL(error_loop) bsr _error_loop
   /* never returns*/
d787 2
a788 2
 * The reset exception is raised when the RST signal is asserted (machine 
 * is reset), the value of VBR is changed after exceptions are enabled, 
d794 2
a795 2
 * Upon a real reset, VBR is set to zero (0), so code must be at addr 0 
 * to handle it!!! 
d797 1
a797 1
 * This is totaly different than _error_handler.  Shadowing might or 
d805 2
a806 2
        /* pick up the slavestack */
	or	r26, r0, r31           /* save old stack */
d814 1
a814 1
	bb1	ge,  r28, 2f   /* branch if at the end of the stack */
d817 1
a817 1
	addu	r27, r27, 4   /* bump up */
d821 1
a821 1
	clr	r31, r31, 3<0>  /* round down to 8-byte boundary */
d824 1
a824 1
	subu	r31, r31, SIZEOF_EF             /* r31 now our E.F. */
d856 1
a856 1
	stcr	r0,  SSBR  /* won't want shadow bits bothering us later */
d894 5
a898 5
        ldcr    r10, PSR
        clr     r10, r10, 1<PSR_FPU_DISABLE_BIT>    /* enable the FPU */
        clr     r10, r10, 1<PSR_SHADOW_FREEZE_BIT>  /* also enable shadowing */
   
        stcr    r10, PSR  /* bang */
d904 3
a906 3
	subu	r31, r31, 0x10 /* make some breathing space */
	st 	r30, r31, 0x0c /* store frame pointer on the st */
	st 	r30, r31, 0x08 /* store again for the debugger to recognize */ 
d914 4
a917 4
	/* TURN INTERUPTS back on */
	ldcr r1, PSR
	clr  r1, r1, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr r1, PSR
d920 3
a922 2
GLOBAL(error_loop2) bsr _error_loop2
/* never returns*/
d928 8
a935 8
	/******************************************************\
	*  SR0: pointer to the current thread structure        *
	*  SR1: previous FLAGS reg                *
	*  SR2: free                                           *
	*  SR3: must presere                                   *
	*  FLAGS:  CPU status flags                            *
	\******************************************************/
	xcr   FLAGS, FLAGS, SR1   /* replace SR1, FLAGS */
d950 2
a951 2
	stcr	r2, SNIP   /* Make it the next instruction to execute */
	
d953 3
a955 4
	stcr	r2, SFIP   /* and the next one after that, too. */
	stcr	r0, SSBR   /* make the scoreboard happy. */
1:   

d965 8
a972 8
	/******************************************************\
	*  SR0: pointer to the current thread structure        *
	*  SR1: previous FLAGS reg                             *
	*  SR2: free                                           *
	*  SR3: must preserve                                  *
	*  FLAGS:  CPU status flags                            *
	\******************************************************/
	xcr   FLAGS, FLAGS, SR1   /* replace SR1, FLAGS */
d986 3
a988 3
	stcr	r2, EXIP   /* Make it the next instruction to execute */
	
	/* the following jumps to "m88110_badaddr__return_nonzero" below */ 
a991 1
	
d1034 1
a1034 1
	stcr	r5,  SR1
d1040 2
a1041 2
	bb1   0, r2, badaddr__return_nonzero
	bb1   1, r2, badaddr__return_nonzero
d1051 1
a1051 1
	ld   r5, r2, 0
d1053 2
a1054 2
	br.n   badaddr__return
	or   r2, r0, r0   /* indicate a zero (address not bad) return.*/
d1058 2
a1059 2
	sub   r6, r3, 2
	bcnd   ne0, r6, badaddr__maybe_byte
d1062 1
a1062 1
	bb1   0, r2, badaddr__return_nonzero
d1065 1
a1065 1
	ld.h   r5, r2, 0
d1067 2
a1068 2
	br.n   badaddr__return
	or   r2, r0, r0
d1072 2
a1073 2
	sub   r6, r3, 1
	bcnd   ne0, r6, badaddr__unknown_size
d1075 1
a1075 1
	ld.b   r5, r2, 0
d1077 2
a1078 2
	br.n   badaddr__return
	or   r2, r0, r0
d1080 1
a1080 1
#ifndef NDEBUG
d1084 7
a1090 7
	or.u   r2, r0, hi16(1b)
	or     r2, r2, lo16(1b)
	or   r4, r0, r1
	bsr   _C_LABEL(printf)
	or.u   r2, r0, hi16(1b)
	or     r2, r2, lo16(1b)
	bsr   _C_LABEL(panic)
d1095 1
a1095 1
	or   r2, r0, 1
d1099 3
a1101 3
	ldcr   r4, SR1
	clr   r4, r4, 1<FLAG_IGNORE_DATA_EXCEPTION>
	stcr   r4, SR1
d1111 2
a1112 2
	stcr   r8, PSR
	jmp     r1
d1115 2
a1116 2
	/* 
	 * On mc88110, we possibly took an exception 
d1118 2
a1119 2
	 * instruction clears the EFRZ bit in 
	 * the PSR. 
d1121 4
a1124 4
	stcr r0, DSR	/* Clear DSR reg on mc88110 */
	stcr r0, DLAR	/* Clear DLAR reg on mc88110 */
	br.n badaddr__return_nonzero
	stcr r0, DPAR	/* Clear DPAR reg on mc88110 */
d1126 1
a1126 5
/*
******************************************************************************
******************************************************************************
******************************************************************************
*/
d1128 13
a1140 1
#ifdef M88100 
a1141 15
ASGLOBAL(setup_phase_one)
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread (if any, null if not)                     *
	* SR1: saved copy of exception-time register now holding FLAGS  *
	* SR2: saved copy of exception-time r1                          *
	* SR3: must be preserved .. may be the exception-time stack     *
	* r1: return address to calling exception handler               *
	* FLAGS: CPU status flags                                       *
	***************************************************             *
	* immediate goal:                                               *
	*    Decide where we're going to put the exception frame.       *
	*   Might be at the end of R31, SR3, or the thread's            *
	*   pcb.                                                        *
	\***************************************************************/
	
d1156 15
a1170 15
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread (if any, null if not)                     *
	* SR1: saved copy of exception-time register now holding FLAGS  *
	* SR2: return address to the calling exception handler          *
	* SR3: must be preserved; may be important for other exceptions *
	* FLAGS: CPU status flags                                       *
	***************************************************             *
	* immediate goal:                                               *
	*   We're already on the kernel stack, but not having           *
	*   needed to use SR3. We can just make room on the             *
	*    stack (r31) for our exception frame.                       *
	\***************************************************************/
	subu	r31,  r31,  SIZEOF_EF            /* r31 now our E.F. */
	st	FLAGS,r31,  REG_OFF(EF_FLAGS)    /* save flags */
	st	r1,   r31,  GENREG_OFF(1)        /* save prev. r1 (now r1 free)*/
d1172 1
a1172 1
	ldcr	r1,   SR3                        /* save previous SR3 */
d1175 1
a1175 1
	addu	r1,   r31,  SIZEOF_EF            /* save previous r31 */
d1177 1
a1177 2
	st 	r1,   r31,  GENREG_OFF(31)

d1180 26
a1205 28
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread (if any, null if not)                     *
	* SR1: saved copy of exception-time register now holding FLAGS  *
	* SR2: return address to the calling exception handler          *
	* SR3: must be preserved; exception-time stack pointer          *
	* FLAGS: CPU status flags                                       *
	***************************************************             *
	* immediate goal:                                               *
	*   An exception occured while enabling the FPU. Since r31      *
	*   is the user's r31 while enabling the FPU, we had put        *
	*   our pcb pointer into SR3, so make room from                 *
	*   there for our stack pointer.                                *
	*       We need to check if SR3 is the old stack pointer or the *
	*       pointer off to the user pcb. If it pointing to the user *
	*       pcb, we need to pick up the kernel stack. Otherwise     *
	*       we need to allocate a frame upon it.                    *
	*       We look at the EPSR to see if it was from user mode     *
	*       Unfortunately, we have no registers free at the moment  *
	*       But we know register 0 in the pcb frame will always be  *
	*       zero, so we can use it as scratch storage.              *
	*                                                               *
	*                                                               *
	\***************************************************************/
	xcr	r30,  r30,  SR3                  /* r30 = old exception frame */ 
	st	r1,   r30,  GENREG_OFF(0)        /* free up r1 */
	ld	r1,   r30,  REG_OFF(EF_EPSR)     /* get back the epsr */
	bb0.n	PSR_SUPERVISOR_MODE_BIT, r1, 1f  /* if user mode */
	ld	r1,   r30,  GENREG_OFF(0)        /* restore r1 */
d1207 9
a1215 9
	st	r0,   r30,  GENREG_OFF(0)        /* repair old frame */
	subu	r30,  r30,  SIZEOF_EF            /* r30 now our E.F. */
	st	FLAGS,r30,  REG_OFF(EF_FLAGS)    /* save flags */
	st	r1,   r30,  GENREG_OFF(1)        /* save prev. r1 (now r1 free) */

	st	r31,  r30,  GENREG_OFF(31)       /* save previous r31 */
	or	r31,  r0,   r30                  /* make r31 our pointer. */ 
	addu	r30,  r30,  SIZEOF_EF            /* r30 now has previous SR3 */ 
	st	r30,  r31,  REG_OFF(EF_SR3)      /* save previous SR3 */
d1217 1
a1217 1
	xcr	r30,  r30,  SR3                  /* restore r30 */
d1226 7
a1232 7
	st	FLAGS,r1,   REG_OFF(EF_FLAGS)    /* store flags */
	st	r31,  r1,   GENREG_OFF(31)       /* store r31 - now free */ 
	st	r30,  r1,   REG_OFF(EF_SR3)      /* store old SR3 (pcb) */
	or	r31,  r1,   r0                   /* make r31 our exception frame pointer */
	ld	r1,   r30,  GENREG_OFF(0)        /* restore old r1 */
	st	r0,   r30,  GENREG_OFF(0)        /* repair that frame */
	st	r1,   r31,  GENREG_OFF(1)        /* store r1 in its proper place */ 
d1234 1
a1234 1
	xcr	r30,  r30,  SR3                  /* restore r30 */
d1237 13
a1249 13
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                          *
	* SR1: saved copy of exception-time register now holding FLAGS *
	* SR2: return address to the calling exception handler         *
	* SR3: free                                                    *
	* FLAGS: CPU status flags                                      *
	***************************************************            *
	* immediate goal:                                              *
	*    Since we're servicing an exception from user mode, we     *
	*   know that SR3 is free.  We use it to free up a temp.       *
	*   register to be used in getting the thread's pcb            *
	\***************************************************************/
	stcr	r31,  SR3      /* save previous r31 */
d1254 4
a1257 4
	addu	r31,  r31,  PCB_USER_STATE       /* point to user save area */ 
	st	FLAGS,r31,  REG_OFF(EF_FLAGS)    /* save flags */
	st	r1,   r31,  GENREG_OFF(1)        /* save prev. r1 (now r1 free)*/ 
	ldcr	r1,   SR3                        /* save previous r31 */
d1259 1
a1259 1
	/*FALLTHROUGH */
d1262 17
a1278 17
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                          *
	* SR1: saved copy of exception-time register now holding FLAGS *
	* SR2: return address to the calling exception handler         *
	* SR3: free                                                    *
	* r1:  free                                                    *
	* FLAGS: CPU status flags                                      *
	* r31: our exception frame                                     *
	* Valid in the exception frame:                                *
	*   Exception-time r1, r31, FLAGS.                             *
	*   Exception SR3, if appropriate.                             *
	***************************************************            *
	* immediate goal:                                              *
	*    Save the shadow registers that need to be saved to        *
	*   the exception frame.                                       *
	\***************************************************************/
	stcr	TMP, SR3   /* free up TMP, TMP2, TMP3 */
d1289 2
a1290 2
	/* get and store the cpu number */	
	extu	TMP,  FLAGS,  FLAG_CPU_FIELD_WIDTH<0>  /* TMP = cpu# */
d1292 1
a1292 1
   
d1302 1
a1302 1
	
d1304 1
a1304 1
	cmp	TMP2, TMP, 0x0				/* CPU0 ? */     
d1306 1
a1306 1
	cmp	TMP2, TMP, 0x1				/* CPU1 ? */     
d1308 1
a1308 1
	cmp	TMP2, TMP, 0x2				/* CPU2 ? */     
d1310 1
a1310 1
	cmp	TMP2, TMP, 0x3				/* CPU3 ? */     
d1312 2
a1313 2
	/* Arrrrg! bad cpu# */ 
	br	Lbadcpupanic				
d1350 1
a1350 1
5: 
d1352 1
a1352 1
   /* it's a single processor SBC   */  
d1365 1
a1365 1
   
d1367 12
a1378 12
   /*
    * The following is a kludge so that
    * a core file will have a copy of
    * DMT0 so that 'sim' can display it
    * correctly.
    * After a data fault has been noticed,
    * the real EF_DTM0 is cleared, so I need
    * to throw this somewhere.
    * There's no special reason I chose this
    * register (FPIT)... it's just one of many
    * for which it causes no pain to do this.
    */
d1382 7
a1388 7
   /*
    * The above shadow registers are obligatory for any and all
    * exceptions.  Now, if the data access pipeline is not clear,
    * we must save the DMx shadow registers, as well as clear
    * the appropriate SSBR bits for the destination registers of
    * loads or xmems.
    */
d1390 1
a1390 1
	st	TMP3, r31,  REG_OFF(EF_DMT0)
d1413 4
a1416 5
   /*
    *---------------------------------------------------------------
    * need to clear "appropriate" bits in the SSBR before
    * we restart the FPU
    */
d1421 2
a1422 1
	stcr	r0,   DMT0 /* so an exception at fpu_enable doesn't see our DMT0*/ 
d1452 1
a1452 1
	set	TMP2, TMP2, 1<5>
d1460 19
a1478 19
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                          *
	* SR1: saved copy of exception-time register now holding FLAGS *
	* SR2: return address to the calling exception handler         *
	* SR3: saved TMP                                               *
	* r1:  free                                                    *
	* TMP: possibly revised SSBR                                   *
	* TMP2: free                                                   *
	* TMP3: free                                                   *
	* FLAGS: CPU status flags                                      *
	* r31: exception frame                                         *
	*    Valid in the exception frame:                             *
	*   Exception-time r1, r31, FLAGS.                             *
	*   Exception-time TMP2, TMP3.                                 *
	*   Exception-time espr, sfip, snip, sxip.                     *
	*   Dmt0.                                                      *
	*   Other data pipeline control registers, if appropriate.     *
	*   Exception SR3, if appropriate.                             *
	\***************************************************************/
d1480 1
a1480 1
	jmp	r1 /* return to allow the handler to clear more SSBR bits */
d1482 1
a1482 4
#endif /* m88100 */

/************************************************************************/
/************************************************************************/
d1489 4
a1492 4
	 *  r1:  return address to calling exception handler
	 *  TMP : (possibly) revised ssbr
	 *  TMP2 : free
	 *  TMP3 : free
d1515 3
a1517 3
	extu	TMP2, TMP2, 5<0>  /* get the reg. */
	set	TMP2, TMP2, 1<6>  /* set width (width=2 will clear two bits) */ 
	clr   	TMP,  TMP,  TMP2
d1520 1
a1520 5
	jmp   r1


/************************************************************************/
/************************************************************************/
d1528 25
a1552 25
	 *  r1:  return address to calling exception handler
	 *  TMP : (possibly) revised ssbr
	 *  TMP2 : free
	 *  TMP3 : free
	 */
	fldcr TMP2, FPSR
	fldcr TMP3, FPCR
	st    TMP2, r31,  REG_OFF(EF_FPSR)
	st    TMP3, r31,  REG_OFF(EF_FPCR)
	
	fldcr TMP3, FPECR
	st    TMP3, r31,  REG_OFF(EF_FPECR)
	fldcr TMP2, FPHS1
	fldcr TMP3, FPHS2
	st    TMP2, r31,  REG_OFF(EF_FPHS1)
	st    TMP3, r31,  REG_OFF(EF_FPHS2)
	
	fldcr TMP2, FPLS1
	fldcr TMP3, FPLS2
	st    TMP2, r31,  REG_OFF(EF_FPLS1)
	st    TMP3, r31,  REG_OFF(EF_FPLS2)
	
	fldcr TMP2, FPPT
	st    TMP2, r31,  REG_OFF(EF_FPPT)
1:   
d1555 7
a1561 8
	bb1.n FPPT_SIZE_BIT, TMP2, 2f
	extu  TMP3, TMP2, 5<0> /* get FP operation dest reg */
	br.n  3f
	set   TMP3, TMP3, 1<5> /* set size=1 -- clear one bit for "float" */
2:	set   TMP3, TMP3, 1<6> /* set size=2 -- clear two bit for "double" */ 
3:	clr   TMP,  TMP,  TMP3   /* clear bit(s) in ssbr. */
4:	jmp   r1

a1562 2
/************************************************************************/
/************************************************************************/
d1586 10
a1595 10
	 *  TMP : (possibly) revised ssbr
	 *  TMP2 : free
	 *  TMP3 : free
	 */
	
	ldcr  TMP3, EPSR   /* going to check: user or system memory? */
	ldcr  TMP2, SXIP   /* get the instruction's address */
	bb1.n PSR_SUPERVISOR_MODE_BIT, TMP3, 2f
	clr   TMP2, TMP2, 2<0> /* get rid of valid and error bits. */
	
d1599 1
a1599 1
	ld.usr TMP2,TMP2, r0      /* get the instruction itself */
d1606 1
a1606 1
	ld.usr TMP2,TMP2, r0      /* get the instruction itself */
d1610 1
a1610 1
	ld    TMP2, TMP2, r0      /* get the instruction itself */
d1612 1
a1612 1
3:	/* now have the instruction..... */
d1632 5
a1636 5
	extu  TMP3, TMP2, 16<16>   /* get the upper 16 bits */
	mask  TMP3, TMP3, 0xFC00   /* apply the mask */
	cmp   TMP3, TMP3, 0x1000   /* if this is equal, it's a load double */
	bb1   eq,   TMP3, misaligned_double
	
d1639 5
a1643 5
	extu  TMP3, TMP2, 16<16>   /* get the upper 16 bits */
	mask  TMP3, TMP3, 0xFC00   /* apply the mask */
	cmp   TMP3, TMP3, 0xF400   /* if equal, it might be a load double */
	bb1   ne,   TMP3, misaligned_single /* not equal, so must be single */
	
d1645 5
a1649 5
	extu  TMP3, TMP2, 16<0>    /* get the lower 16 bits */
	mask  TMP3, TMP3, 0xFCE0   /* apply the mask */
	cmp   TMP3, TMP3, 0x1000   /* if this is equal, it's a load double */
	bb1   eq,   TMP3, misaligned_double
	
d1651 3
a1653 3
	extu  TMP2, TMP2, 5<21>    /* get the destination register */
	br.n  1f
	set   TMP2, TMP2, 1<5>     /* set size=1 */
d1656 2
a1657 5
	extu  TMP2, TMP2, 5<21>    /* get the destination register */
	set   TMP2, TMP2, 1<6>     /* set size=2 -- clear two bit for "ld.d" */

1:	jmp.n   r1
	clr   TMP,  TMP,  TMP2     /* clear bit(s) in ssbr. */
d1659 2
a1660 2
/************************************************************************/
/************************************************************************/
d1665 31
a1695 31
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: saved return address to calling exception handler        *
	* SR1: saved copy of exception-time register now holding FLAGS  *
	* SR2: free                                                     *
	* SR3: saved TMP                                                *
	* r1:  return address to calling exception handler              *
	* TMP: possibly revised SSBR                                    *
	* TMP2: free                                                    *
	* TMP3: free                                                    *
	* FLAGS: CPU status flags                                       *
	* r31: our exception frame                                      *
	*    Valid in the exception frame:                              *
	*   Exception-time r1, r31, FLAGS.                              *
	*   Exception-time TMP2, TMP3.                                  *
	*   Exception-time espr, sfip, snip, sxip.                      *
	*   Exception number (EF_VECTOR).                               *
	*   Dmt0                                                        *
	*   Other data pipeline control registers, if appropriate.      *
	*   FPU control registers, if appropriate.                      *
	*   Exception SR3, if appropriate.                              *
	***************************************************             *
	* immediate goal:                                               *
	*   restore the system to the exception-time state (except      *
	* SR3 will be OUR stack pointer) so that we may resart the FPU. *
	\***************************************************************/
	/*stcr   r1, SR0*/      /* save return address */
	
	stcr  TMP,  SSBR   /* done with SSBR, TMP now free */
	RESTORE_TMP2      /* done with extra temp regs */
	RESTORE_TMP3      /* done with extra temp regs */
	
d1698 5
a1702 5
	ldcr  TMP,  PSR
	clr   TMP,  TMP,  1<PSR_FPU_DISABLE_BIT>    /* enable the FPU */
	clr   TMP,  TMP,  1<PSR_SHADOW_FREEZE_BIT>  /* also enable shadowing */
	stcr  TMP,  EPSR
	
d1704 5
a1708 5
	or.u  TMP,  r0,   hi16(fpu_enable +2)
	or    TMP,  TMP,  lo16(fpu_enable +2)
	stcr  TMP,  SNIP      /* jump to here fpu_enable */
	addu  TMP,  TMP,  4
	stcr  TMP,  SFIP      /* and then continue after that */
d1710 10
a1719 10
	ldcr  TMP,  PSR
	or.u  TMP,  TMP,  0x8000    /* set supervisor mode */
	and   TMP,  TMP,  0xfff7    /* also enable shadowing */
	stcr  TMP,  EPSR
	stcr  r0,   SXIP       /* clear valid bit */
	stcr  r0,   SNIP       /* clear valid bit */
	or.u  TMP,  r0,   hi16(fpu_enable)
	or    TMP,  TMP,  lo16(fpu_enable)
	or    TMP,  TMP,  0x2 /* set the VALID_BIT and clear Exception bit */
	stcr  TMP,  SFIP      /* jump to here fpu_enable */
d1723 34
a1756 34
	set   FLAGS, FLAGS, 1<FLAG_ENABLING_FPU> /* note what we're doing.*/
	xcr   FLAGS, FLAGS, SR1
	st    r1,   r31,  REG_OFF(EF_RET) /* save the return address */
	ld    r1,   r31,  GENREG_OFF(1)    /* get original r1 */
	
	xcr   TMP,  r31,  SR3   /* TMP now restored. R31 now saved in SR3 */
	ld    r31,  r31,  GENREG_OFF(31) /* get original r31 */
	
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                           *
	* SR1: CPU flags                                                *
	* SR2: free                                                     *
	* SR3: pointer to our exception frame (our stack pointer)       *
	* r1 through r31: original exception-time values                *
	*                                                               *
	* Valid in the exception frame:                                 *
	*   Exception-time FLAGS.                                       *
	*   Exception-time espr, sfip, snip, sxip.                      *
	*   Exception number (EF_VECTOR).                               *
	*   Dmt0                                                        *
	*   Other data pipeline control registers, if appropriate.      *
	*   FPU control registers, if appropriate.                      *
	*   Exception SR3, if appropriate.                              *
	*   Held temporarly in the exception frame:                     *
	*   Return address to the calling excption handler.             *
	***************************************************             *
	* immediate goal:                                               *
	*   Do an RTE to restart the fpu and jump to "fpu_enable"       *
	*   Another exception (or exceptions) may be raised in          *
	*   this, which is why FLAG_ENABLING_FPU is set in SR1.         *
	\***************************************************************/
	
	RTE   /* jumps to "fpu_enable" on the next line to enable the FPU. */
	
d1759 5
a1763 5
	xcr   TMP,  TMP,  SR3               /* get E.F. pointer */
	st.d  r30,  TMP,  GENREG_OFF(30)    /* save previous r30, r31 */
	or    r31,  TMP,  r0                /* transfer E.F. pointer to r31 */
	ld    TMP,  r31,  REG_OFF(EF_SR3)   /* get previous SR3; maybe important*/
	
d1765 6
a1770 6
	xcr   FLAGS,FLAGS,SR1
	clr   FLAGS,FLAGS,1<FLAG_ENABLING_FPU>
	xcr   FLAGS,FLAGS,SR1
	
	xcr   TMP,  TMP,  SR3       /* replace TMP, SR3 */
	
d1772 15
a1786 15
	st.d  r0 ,  r31,  GENREG_OFF(0)
	st.d  r2 ,  r31,  GENREG_OFF(2)
	st.d  r4 ,  r31,  GENREG_OFF(4)
	st.d  r6 ,  r31,  GENREG_OFF(6)
	st.d  r8 ,  r31,  GENREG_OFF(8)
	st.d  r10,  r31,  GENREG_OFF(10)
	st.d  r12,  r31,  GENREG_OFF(12)
	st.d  r14,  r31,  GENREG_OFF(14)
	st.d  r16,  r31,  GENREG_OFF(16)
	st.d  r18,  r31,  GENREG_OFF(18)
	st.d  r20,  r31,  GENREG_OFF(20)
	st.d  r22,  r31,  GENREG_OFF(22)
	st.d  r24,  r31,  GENREG_OFF(24)
	st.d  r26,  r31,  GENREG_OFF(26)
	st.d  r28,  r31,  GENREG_OFF(28)
d1789 3
a1791 3
	or.u  r20,  r0,   hi16(0x12345678)
	or    r20,  r20,  lo16(0x12345678)
	st    r20,  r31,  GENREG_OFF(0)
d1797 29
a1825 32
	
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                           *
	* SR1: free                                                     *
	* SR2: free                                                     *
	* SR3: previous exception-time SR3                              *
	* r1: return address to the calling exception handler           *
	* r2 through r30: free                                          *
	* r31: our exception frame                                      *
	*                                                               *
	* Valid in the exception frame:                                 *
	*   Exception-time r0 through r31.                              *
	*   Exception-time FLAGS.                                       *
	*   Exception-time espr, sfip, snip, sxip.                      *
	*   Exception number (EF_VECTOR).                               *
	*   Dmt0                                                        *
	*   Other data pipeline control registers, if appropriate.      *
	*   FPU control registers, if appropriate.                      *
	*   Exception SR3, if appropriate.                              *
	***************************************************             *
	* immediate goal:                                               *
	*   Pick up a stack if we came in from user mode. Put           *
	*       A copy of the exception frame pointer into r30          *
	*       bump the stack a doubleword and write the exception     *
	*       frame pointer.                                          *
	*   if not an interrupt exception,                              *
	*       Turn on interrupts and service any outstanding          *
	*       data access exceptions.                                 *
	*   Return to calling exception handler to                      *
	*   service the exception.                                      *
	\***************************************************************/
	
d1830 1
a1830 1
#if INTSTACK
d1836 11
a1846 11
	or    r30,  r0,   r31		/* get a copy of the e.f. pointer */ 
	ld    r2,   r31,  REG_OFF(EF_EPSR)
	bb1   PSR_SUPERVISOR_MODE_BIT, r2, 1f  /* If in kernel mode */

#if INTSTACK
	ld    r3,   r31,  REG_OFF(EF_VECTOR)
	cmp   r3,   r3,   1      /* is interrupt ? */
	bb0   eq,   r3,   2f
	or.u  r31,  r0,   hi16(_intstack_end)   /* swith to int stack */
	or    r31,  r31,  lo16(_intstack_end)
	br    3f
d1849 4
a1852 4
	or.u  r31,  r0,   hi16(_kstack)
	ld    r31,  r31,  lo16(_kstack)
	addu  r31,  r31,  USIZE        /* point at proper end */
	br    3f
d1854 7
a1860 7
#if INTSTACK
	ld    r3,   r31,  REG_OFF(EF_VECTOR)
	cmp   r3,   r3,   1       /* is interrupt ? */
	bb0   eq,   r3,   3f      /* no, we will stay on kern stack */
	or.u  r31,  r0,   hi16(_intstack_end)   /* swith to int stack */
	or    r31,  r31,  lo16(_intstack_end)
#endif /* INTSTACK */
d1862 2
a1863 1
exception_handler_has_ksp:  global exception_handler_has_ksp
d1867 5
a1871 5
	*/
	subu  r31,  r31,  8  /* make some breathing space */
	st    r30,  r31,  0  /* store frame pointer on the stack */
#if DDB
	st    r30,  r31,  4  /* store it again for the debugger to recognize */
d1874 18
a1891 17
	ld    r2,   r30,  REG_OFF(EF_VECTOR)
	bcnd.n eq0, r2,   return_to_calling_exception_handler  /* is error */
	ld    r14,  r30,  REG_OFF(EF_RET)
	cmp   r3,   r2,   1 /* interrupt is exception #1 ;Is an interrupt? */
	bb1.n eq,   r3,   return_to_calling_exception_handler /* skip if so */

#if DDB
	cmp   r3,   r2,   130 /* DDB break exception */
	bb1.n eq,   r3,   return_to_calling_exception_handler
	cmp   r3,   r2,   132 /* DDB entry exception */
	bb1.n eq,   r3,   return_to_calling_exception_handler
#endif

	ldcr  r2,   PSR
	clr   r2,   r2,   1<PSR_INTERRUPT_DISABLE_BIT>   /* enable interrupts */
	stcr  r2,   PSR
#if     DDB
d1896 1
a1896 1
	   - check dmt0 anything outstanding?*/
d1898 2
a1899 2
	ld    r3,   r30,  REG_OFF(EF_DMT0)
	bb0   DMT_VALID_BIT, r3, return_to_calling_exception_handler
d1902 2
a1903 2
	  r30 can be clobbered by calls. So stuff its value into a
	  preserved register, say r15. R14 is in use (see return_to_... below). 
d1905 1
a1905 1
	or    r15,  r0,   r30
d1910 2
a1911 2
	/*   restore it... */
	or    r30,  r0,   r15
d1914 1
a1914 1
	st    r0,   r30,  REG_OFF(EF_DMT0)
d1917 2
a1918 3
	jmp   r14 /* loaded above */
#endif /* m88100 */

d1933 1
a1933 1
	subu	r31,r31,40	/* create stack space for function */
d1936 1
a1936 1
	ld	r2, r31,4	/* & proc pointer from switch frame */ 
d1938 1
a1938 1
	addu	r31,r31,8
d1942 1
a1942 1
 * proc_do_uret 
d1972 1
a1972 1
#ifdef M88110	
d1976 2
a1977 2
	bb1	eq, r2, m88110_return_code        
#endif 
d1979 2
a1980 2
#define FPTR    r14
	ld	FPTR, r31, 0                 /* grab exception frame pointer */ 
d1982 1
a1982 1
	bb0	DMT_VALID_BIT, r3, check_ast /*[Oh well, nothing to do here] */
d1987 1
a1987 1
	 * in an exception handler.........
d1990 1
a1990 1
	cmp	r2, r2, 1 /* interrupt is exception #1 ; Is an interrupt? */ 
d1994 1
a1994 1
#if DDB
d1998 1
a1998 1
	br 1f
d2009 1
a2009 1
	
d2014 3
a2016 3
	ld    r2, FPTR, REG_OFF(EF_VECTOR)
	cmp   r2, r2, 1   /* interrupt is exception #1 ; Is an interrupt? */
        bb1   ne, r2, 1f  /* If not so, skip */
d2019 4
a2022 4
	ld    r2, FPTR, REG_OFF(EF_EPSR)
        bb1   PSR_INTERRUPT_DISABLE_BIT, r2, 1f		/* skip if disabled */
	ldcr  r2, PSR
	clr   r2, r2, 1<PSR_INTERRUPT_DISABLE_BIT>	/* enable interrupts */
d2024 1
a2024 1
        stcr  r2, PSR
d2026 2
a2027 2
	ld    r2, FPTR, REG_OFF(EF_DMT0)
	bb0   DMT_VALID_BIT, r2, 2f
d2034 1
a2034 1
	CALL(_C_LABEL(data_access_emulation), r30, r0) /* really only 2 args */
d2036 1
a2036 1
	st   r0 , FPTR, REG_OFF(EF_DMT0)
d2038 2
a2039 2
	br   check_ast
#endif /* m88100 */
d2043 2
a2044 2
#define FPTR    r14
	ld	FPTR, r31, 0                 /* grab exception frame pointer */ 
d2054 1
a2054 1
	 * 
d2058 2
a2059 2
	cmp	r2, r2, 1   /* Is it an interrupt? */ 
	bb1	ne, r2, 1f  /* If not, skip */
d2063 1
a2063 1
	bb1	PSR_INTERRUPT_DISABLE_BIT, r2, 1f  /* skip if disabled */ 
d2065 1
a2065 1
	clr	r2, r2, 1<PSR_INTERRUPT_DISABLE_BIT>    /* enable interrupts */ 
d2069 1
a2069 1
	br 2f	/* temp XXX smurph */
d2071 2
a2072 2
	cmp	r2, r2, 3   /* Is it a data access exception? */ 
	bb1	ne, r2, 2f  /* If not, skip */
d2093 4
a2097 5
        ld      r2, FPTR, REG_OFF(EF_EPSR)   /* get pre-exception PSR */
        bb1     PSR_INTERRUPT_DISABLE_BIT, r2, 1f /* skip if ints off */
        ld      r2, FPTR, REG_OFF(EF_MASK)   /* get pre-exception ipl */
        bcnd    ne0, r2, 1f		/* can't do softint's */
        
d2099 3
a2101 3
	bsr.n   _C_LABEL(setipl)
        or      r2,r0,1
	/* at ipl 1 now */	
d2103 1
a2103 1
        bsr     _C_LABEL(dosoftint)
d2106 2
a2107 2
        bsr.n   _C_LABEL(setipl)
        or      r2,r0,0			/* ints are enabled */
d2111 2
a2112 2
        ld      r2, FPTR, REG_OFF(EF_EPSR)   /* get pre-exception PSR */
        bb1     PSR_SUPERVISOR_MODE_BIT, r2, no_ast /*skip if in system mode */
d2114 9
a2122 9
        /* should assert here - not in user mode with ints off XXX nivas */
        /* get and check want_ast */
        or.u	r2, r0, hi16(_C_LABEL(want_ast))
        ld	r3, r2, lo16(_C_LABEL(want_ast))
        bcnd	eq0, r3, no_ast

        /*
         * trap(AST,...) will service ast's.
         */
d2130 1
a2130 1
        CALL(_C_LABEL(m88110_trap), T_ASTFLT, FPTR)
d2137 1
a2137 1
        CALL(_C_LABEL(m88100_trap), T_ASTFLT, FPTR)
d2141 5
d2147 1
a2147 7
        /* disable interrupts */
        ldcr    r1, PSR                 
        set     r1, r1, 1<PSR_INTERRUPT_DISABLE_BIT>
        FLUSH_PIPELINE
        stcr    r1, PSR

        /* now ready to return....*/
d2149 2
a2150 2
	bsr.n   _C_LABEL(setipl)
	 ld	r2, FPTR, REG_OFF(EF_MASK)   /* get pre-exception ipl */
d2152 28
a2179 28
        
        /*
         * Transfer the frame pointer to r31, since we no longer need a stack.
         * No page faults here, and interrupts are disabled.
         */
        or      r31, r0,  FPTR
        /* restore r1 later */
        ld.d    r2 , r31, GENREG_OFF(2)
        ld.d    r4 , r31, GENREG_OFF(4)
        ld.d    r6 , r31, GENREG_OFF(6)
        ld.d    r8 , r31, GENREG_OFF(8)
        ld.d    r10, r31, GENREG_OFF(10)
        ld.d    r12, r31, GENREG_OFF(12)
        ld.d    r14, r31, GENREG_OFF(14)
        ld.d    r16, r31, GENREG_OFF(16)
        ld.d    r18, r31, GENREG_OFF(18)
        ld.d    r20, r31, GENREG_OFF(20)
        ld.d    r22, r31, GENREG_OFF(22)
        ld.d    r24, r31, GENREG_OFF(24)
        ld.d    r26, r31, GENREG_OFF(26)
        ld.d    r28, r31, GENREG_OFF(28)
        /* restore r1, r30, r31 later */

        /* disable shadowing */
        ldcr    r1, PSR
        set     r1, r1, 1<PSR_SHADOW_FREEZE_BIT>
        FLUSH_PIPELINE
        stcr    r1, PSR
d2183 1
a2183 1
        or.u	r1, r0, hi16(_C_LABEL(cputyp))
d2187 6
a2192 6
        /* mc88110 needs the EXIP */
	ld      r30, r31, REG_OFF(EF_ENIP)
        ld      r1,  r31, REG_OFF(EF_EXIP)
        stcr    r30, ENIP
        stcr    r1,  EXIP
	br 	2f      
d2194 33
a2226 34
#endif 
        st      r0, r31, REG_OFF(EF_IPFSR)
        st      r0, r31, REG_OFF(EF_DPFSR)

        /*
         * Note: no need to restore the SXIP.
         * When the "rte" causes execution to continue
         * first with the instruction pointed to by the NIP
         * and then the FIP.
         *
         * See MC88100 Risc Processor User's Manual, 2nd Edition,
         * section 6.4.3.1.2-4
         */
        ld      r30, r31, REG_OFF(EF_SNIP)
        ld      r1,  r31, REG_OFF(EF_SFIP)
        stcr    r0,  SSBR
        stcr    r30, SNIP
        stcr    r1,  SFIP

2:        
	ld      r30, r31, REG_OFF(EF_EPSR)
        ld      r1,  r31, REG_OFF(EF_MODE)
        stcr    r30, EPSR

        /* Now restore r1, r30, and r31 */
        ld      r1,  r31, GENREG_OFF(1)
        ld.d    r30, r31, GENREG_OFF(30)

        RTE

#ifdef M88110 	
/*#########################################################################*/
/*#### THE ACTUAL EXCEPTION HANDLER ENTRY POINTS - MVME197 ################*/
/*#########################################################################*/
d2268 1
a2268 1
	PREP2("privilege", 6, DEBUG_PRIVILEGE_BIT, No_SSBR_Stuff, No_Precheck) 
d2296 1
a2296 1
	CALL(_m88110_Xfp_precise, r0, r30) /* call fp_precise(??, exception_frame)*/
d2326 2
a2327 2
	ld   r13, r30, GENREG_OFF(13)
	CALL(_m88110_syscall, r13, r30) /* system call no. is in r13 */
d2333 2
a2334 2
	ld   r9,  r30, GENREG_OFF(9)
	CALL(_bugsyscall, r9, r30)   /* system call no. is in r9 */
d2357 1
a2357 1
#if DDB
d2372 1
a2372 1
#else /* else not DDB */
d2387 1
a2387 1
#endif   /* DDB */
a2388 2

/*--------------------------------------------------------------------------*/
d2401 1
a2401 1
	xcr	r2, r2,	SRX
d2403 1
a2403 1
	stcr	r2, 	SR0
d2405 1
a2405 1
	xcr	r2, r2,	SRX
d2409 2
a2410 2
 * The reset exception is raised when the RST signal is asserted (machine 
 * is reset), the value of VBR is changed after exceptions are enabled, 
d2413 2
a2414 2
 * Upon a real reset, VBR is set to zero (0), so code must be at addr 0 
 * to handle it!!! 
d2416 1
a2416 1
 * This is totaly different than _error_handler.  Shadowing might or 
d2424 2
a2425 2
	stcr	r0, 	SR0
	/* FALL THROUGH */
d2427 2
a2428 2
        /* pick up the slavestack */
	or	r26, r0, r31           /* save old stack */
d2436 1
a2436 1
	bb1	ge,  r28, 2f   /* branch if at the end of the stack */
d2439 1
a2439 1
	addu	r27, r27, 4   /* bump up */
d2443 1
a2443 1
        clr     r31, r31, 3<0>  /* round down to 8-byte boundary */
d2446 1
a2446 1
        subu    r31, r31, SIZEOF_EF             /* r31 now our E.F. */
d2449 14
a2462 14
        st.d    r0 , r31, GENREG_OFF(0)
        st.d    r2 , r31, GENREG_OFF(2)
        st.d    r4 , r31, GENREG_OFF(4)
        st.d    r6 , r31, GENREG_OFF(6)
        st.d    r8 , r31, GENREG_OFF(8)
        st.d    r10, r31, GENREG_OFF(10)
        st.d    r12, r31, GENREG_OFF(12)
        st.d    r14, r31, GENREG_OFF(14)
        st.d    r16, r31, GENREG_OFF(16)
        st.d    r18, r31, GENREG_OFF(18)
        st.d    r20, r31, GENREG_OFF(20)
        st.d    r22, r31, GENREG_OFF(22)
        st.d    r24, r31, GENREG_OFF(24)
        st      r30, r31, GENREG_OFF(30)
d2467 4
a2470 4
	st	r10,  r31, REG_OFF(EF_VECTOR)
	cmp	r10, r10, 0	/* Is it the reset exception? */
	bb1.n	ne,  r10, 1f	/* If not, skip. */
	
d2472 1
a2472 1
	ldcr	r10, EPSR
d2492 1
a2492 1
	st	r10, r31, REG_OFF(EF_MODE)
d2494 1
a2494 1
1:	
a2532 1
	
d2536 4
a2539 5
        ldcr    r10, PSR
        clr     r10, r10, 1<PSR_FPU_DISABLE_BIT>    /* enable the FPU */
        clr     r10, r10, 1<PSR_SHADOW_FREEZE_BIT>  /* also enable shadowing */
   
        stcr    r10, PSR  /* bang */
d2545 3
a2547 3
        subu	r31, r31, 0x10 /* make some breathing space */
        st	r30, r31, 0x0c /* store frame pointer on the st */
        st	r30, r31, 0x08 /* store again for the debugger to recognize */ 
d2552 1
a2552 1
        
d2555 5
a2559 5
        /* TURN INTERUPTS back on */
        ldcr r1, PSR
	clr  r1, r1, 1<PSR_INTERRUPT_DISABLE_BIT>
        stcr r1, PSR
        FLUSH_PIPELINE
d2562 2
a2563 2
	bsr m88110_error_loop
   /* never returns*/
d2566 13
a2578 14
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread (if any, null if not)                     *
	* SR1: saved copy of exception-time register now holding FLAGS  *
	* SR2: saved copy of exception-time r1                          *
	* SR3: must be preserved .. may be the exception-time stack     *
	* r1: return address to calling exception handler               *
	* FLAGS: CPU status flags                                       *
	***************************************************             *
	* immediate goal:                                               *
	*    Decide where we're going to put the exception frame.       *
	*   Might be at the end of R31, SR3, or the thread's            *
	*   pcb.                                                        *
	\***************************************************************/
	
d2582 1
a2582 1
	xcr   r1,   r1,   SR2
d2586 2
a2587 2
	
	bb1   FLAG_ENABLING_FPU, FLAGS, m88110_use_SR3_pcb
d2589 2
a2590 2
	bb0   FLAG_FROM_KERNEL, FLAGS, m88110_pickup_stack
	
d2593 23
a2615 24
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread (if any, null if not)                     *
	* SR1: saved copy of exception-time register now holding FLAGS  *
	* SR2: return address to the calling exception handler          *
	* SR3: must be preserved; may be important for other exceptions *
	* FLAGS: CPU status flags                                       *
	***************************************************             *
	* immediate goal:                                               *
	*   We're already on the kernel stack, but not having           *
	*   needed to use SR3. We can just make room on the             *
	*    stack (r31) for our exception frame.                       *
	\***************************************************************/
	subu  r31,  r31,  SIZEOF_EF            /* r31 now our E.F. */
	st    FLAGS,r31,  REG_OFF(EF_FLAGS)    /* save flags */
	st    r1,   r31,  GENREG_OFF(1)        /* save prev. r1 (now r1 free)*/
	
	ldcr  r1,   SR3                        /* save previous SR3 */
	st    r1,   r31,  REG_OFF(EF_SR3)
	
	addu  r1,   r31,  SIZEOF_EF            /* save previous r31 */
	br.n  m88110_have_pcb
	st    r1,   r31,  GENREG_OFF(31)
	
	
d2617 21
a2637 24
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread (if any, null if not)                     *
	* SR1: saved copy of exception-time register now holding FLAGS  *
	* SR2: return address to the calling exception handler          *
	* SR3: must be preserved; exception-time stack pointer          *
	* FLAGS: CPU status flags                                       *
	***************************************************             *
	* immediate goal:                                               *
	*   An exception occured while enabling the FPU. Since r31      *
	*   is the user's r31 while enabling the FPU, we had put        *
	*   our pcb pointer into SR3, so make room from                 *
	*   there for our stack pointer.                                *
	*       We need to check if SR3 is the old stack pointer or the *
	*       pointer off to the user pcb. If it pointing to the user *
	*       pcb, we need to pick up the kernel stack. Otherwise     *
	*       we need to allocate a frame upon it.                    *
	*       We look at the EPSR to see if it was from user mode     *
	*       Unfortunately, we have no registers free at the moment  *
	*       But we know register 0 in the pcb frame will always be  *
	*       zero, so we can use it as scratch storage.              *
	*                                                               *
	*                                                               *
	\***************************************************************/
	xcr	r2, r2,	SRX
d2639 1
a2639 1
	stcr	r2, 	SR0
d2641 1
a2641 1
	xcr	r2, r2,	SRX
d2643 5
a2647 5
	xcr   r30,  r30,  SR3                  /* r30 = old exception frame */
	st    r1,   r30,  GENREG_OFF(0)        /* free up r1 */
	ld    r1,   r30,  REG_OFF(EF_EPSR)     /* get back the epsr */
	bb0.n PSR_SUPERVISOR_MODE_BIT, r1, 1f  /* if user mode */
	ld    r1,   r30,  GENREG_OFF(0)        /* restore r1 */
d2649 11
a2659 11
	st    r0,   r30,  GENREG_OFF(0)        /* repair old frame */
	subu  r30,  r30,  SIZEOF_EF            /* r30 now our E.F. */
	st    FLAGS,r30,  REG_OFF(EF_FLAGS)    /* save flags */
	st    r1,   r30,  GENREG_OFF(1)        /* save prev. r1 (now r1 free) */
	
	st    r31,  r30,  GENREG_OFF(31)       /* save previous r31 */
	or    r31,  r0,   r30                  /* make r31 our pointer. */
	addu  r30,  r30,  SIZEOF_EF            /* r30 now has previous SR3 */
	st    r30,  r31,  REG_OFF(EF_SR3)      /* save previous SR3 */
	br.n  m88110_have_pcb
	xcr   r30,  r30,  SR3                  /* restore r30 */
d2661 2
a2662 1
	/* we took an exception while restarting the FPU from user space.
d2665 15
a2679 14
	 * r30) */
	or.u  r1,   r0,   hi16(_kstack)
	ld    r1,   r1,   lo16(_kstack)
	addu  r1,   r1,   USIZE-SIZEOF_EF
	st    FLAGS,r1,   REG_OFF(EF_FLAGS)    /* store flags */
	st    r31,  r1,   GENREG_OFF(31)       /* store r31 - now free */
	st    r30,  r1,   REG_OFF(EF_SR3)      /* store old SR3 (pcb) */
	or    r31,  r1,   r0                   /* make r31 our exception frame pointer */
	ld    r1,   r30,  GENREG_OFF(0)        /* restore old r1 */
	st    r0,   r30,  GENREG_OFF(0)        /* repair that frame */
	st    r1,   r31,  GENREG_OFF(1)        /* store r1 in its proper place */
	br.n  m88110_have_pcb
	xcr   r30,  r30,  SR3                  /* restore r30 */
	
d2681 14
a2694 14
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                          *
	* SR1: saved copy of exception-time register now holding FLAGS *
	* SR2: return address to the calling exception handler         *
	* SR3: free                                                    *
	* FLAGS: CPU status flags                                      *
	***************************************************            *
	* immediate goal:                                              *
	*    Since we're servicing an exception from user mode, we     *
	*   know that SR3 is free.  We use it to free up a temp.       *
	*   register to be used in getting the thread's pcb            *
	\***************************************************************/
	stcr  r31,  SR3      /* save previous r31 */
	
d2696 9
a2704 9
	or.u  r31,  r0,   hi16(_curpcb)
	ld    r31,  r31,  lo16(_curpcb)
	addu  r31,  r31,  PCB_USER_STATE       /* point to user save area */
	st    FLAGS,r31,  REG_OFF(EF_FLAGS)    /* save flags */
	st    r1,   r31,  GENREG_OFF(1)        /* save prev. r1 (now r1 free)*/
	ldcr  r1,   SR3                        /* save previous r31 */
	st    r1,   r31,  GENREG_OFF(31)
	/*FALLTHROUGH */
	
d2706 17
a2722 17
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                          *
	* SR1: saved copy of exception-time register now holding FLAGS *
	* SR2: return address to the calling exception handler         *
	* SR3: free                                                    *
	* r1:  free                                                    *
	* FLAGS: CPU status flags                                      *
	* r31: our exception frame                                     *
	*    Valid in the exception frame:                             *
	*   Exception-time r1, r31, FLAGS.                             *
	*   Exception SR3, if appropriate.                             *
	***************************************************            *
	* immediate goal:                                              *
	*    Save the shadow registers that need to be saved to        *
	*   the exception frame.                                       *
	\***************************************************************/
	stcr   TMP, SR3   /* free up TMP, TMP2, TMP3 */
d2725 1
a2725 1
	
d2727 5
a2731 5
	ldcr  TMP,  EPSR
	st    TMP,  r31,  REG_OFF(EF_EPSR)
	ldcr  TMP2, EXIP
	st    TMP2, r31,  REG_OFF(EF_EXIP)
	bb0.n 0,    TMP2, 1f
d2733 1
a2733 1
	st    r0,   r31,  REG_OFF(EF_ENIP)
d2735 2
a2736 2
	ldcr  TMP3, ENIP
	st    TMP3, r31,  REG_OFF(EF_ENIP)
d2739 6
a2744 6
	st    r0,   r31,  REG_OFF(EF_SFIP)
	
	/* get and store the cpu number */	
	extu  TMP,  FLAGS,  FLAG_CPU_FIELD_WIDTH<0>  /* TMP = cpu# */
	st    TMP,  r31,  REG_OFF(EF_CPU)
	
d2748 23
a2770 26
	ldcr  TMP,  ISR
	ldcr  TMP2, ILAR
	ldcr  TMP3, IPAR
	st    TMP,  r31,  REG_OFF(EF_ISR)
	st    TMP2, r31,  REG_OFF(EF_ILAR)
	st    TMP3, r31,  REG_OFF(EF_IPAR)
	ldcr  TMP,  ISAP
	ldcr  TMP2, IUAP
	st    TMP,  r31,  REG_OFF(EF_ISAP)
	st    TMP2, r31,  REG_OFF(EF_IUAP)
	ldcr  TMP,  DSR
	ldcr  TMP2, DLAR
	ldcr  TMP3, DPAR
	st    TMP,  r31,  REG_OFF(EF_DSR)
	st    TMP2, r31,  REG_OFF(EF_DLAR)
	st    TMP3, r31,  REG_OFF(EF_DPAR)
	ldcr  TMP,  DSAP
	ldcr  TMP2, DUAP
	st    TMP,  r31,  REG_OFF(EF_DSAP)
	st    TMP2, r31,  REG_OFF(EF_DUAP)
	
	ldcr  r1,   SR2
	jmp   r1 /* return */
	
/************************************************************************/
/************************************************************************/
d2773 73
a2845 73
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: saved return address to calling exception handler        *
	* SR1: saved copy of exception-time register now holding FLAGS  *
	* SR2: free                                                     *
	* SR3: saved TMP                                                *
	* r1:  return address to calling exception handler              *
	* TMP: possibly revised SSBR                                    *
	* TMP2: free                                                    *
	* TMP3: free                                                    *
	* FLAGS: CPU status flags                                       *
	* r31: our exception frame                                      *
	*    Valid in the exception frame:                              *
	*   Exception-time r1, r31, FLAGS.                              *
	*   Exception-time TMP2, TMP3.                                  *
	*   Exception-time espr, enip, exip.                            *
	*   Exception number (EF_VECTOR).                               *
	*   Dmt0                                                        *
	*   Other data pipeline control registers, if appropriate.      *
	*   FPU control registers, if appropriate.                      *
	*   Exception SR3, if appropriate.                              *
	***************************************************             *
	* immediate goal:                                               *
	*   restore the system to the exception-time state (except      *
	* SR3 will be OUR stack pointer) so that we may resart the FPU. *
	\***************************************************************/
	/*stcr   r1, SR0*/      /* save return address */
	
	RESTORE_TMP2      /* done with extra temp regs */
	RESTORE_TMP3      /* done with extra temp regs */
	
	ldcr  TMP,  PSR
	clr   TMP,  TMP,  1<PSR_FPU_DISABLE_BIT>    /* enable the FPU */
	clr   TMP,  TMP,  1<PSR_SHADOW_FREEZE_BIT>  /* also enable shadowing */
	stcr  TMP,  EPSR
	
	or.u  TMP,  r0,   hi16(m88110_fpu_enable)
	or    TMP,  TMP,  lo16(m88110_fpu_enable)
	stcr  TMP,  EXIP      /* jump to here fpu_enable */
	addu  TMP,  TMP,  4
	stcr  TMP,  ENIP      /* and then continue after that */
	
	set   FLAGS, FLAGS, 1<FLAG_ENABLING_FPU> /* note what we're doing.*/
	xcr   FLAGS, FLAGS, SR1
	st    r1,   r31,  REG_OFF(EF_RET) /* save the return address */
	ld    r1,   r31,  GENREG_OFF(1)    /* get original r1 */
	
	ldcr  TMP, SR3
	stcr  r31, SR3	/* TMP now restored. R31 now saved in SR3 */
	ld    r31,  r31,  GENREG_OFF(31) /* get original r31 */
	
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                           *
	* SR1: CPU flags                                                *
	* SR2: free                                                     *
	* SR3: pointer to our exception frame (our stack pointer)       *
	* r1 through r31: original exception-time values                *
	*                                                               *
	* Valid in the exception frame:                                 *
	*   Exception-time FLAGS.                                       *
	*   Exception-time espr, sfip, enip, exip.                      *
	*   Exception number (EF_VECTOR).                               *
	*   Dmt0                                                        *
	*   Other data pipeline control registers, if appropriate.      *
	*   FPU control registers, if appropriate.                      *
	*   Exception SR3, if appropriate.                              *
	*   Held temporarly in the exception frame:                     *
	*   Return address to the calling excption handler.             *
	***************************************************             *
	* immediate goal:                                               *
	*   Do an RTE to restart the fpu and jump to "fpu_enable"       *
	*   Another exception (or exceptions) may be raised in          *
	*   this, which is why FLAG_ENABLING_FPU is set in SR1.         *
	\***************************************************************/
d2847 2
a2848 2
	RTE   /* jumps to "fpu_enable" on the next line to enable the FPU. */
	
d2853 10
a2862 10
	stcr  r0, ISR	/* Clear ISR */
	stcr  r0, ILAR	/* Clear ILAR */
	stcr  r0, IPAR	/* Clear IPAR */
	stcr  r0, DSR	/* Clear DSR */
	stcr  r0, DLAR	/* Clear DLAR */
	stcr  r0, DPAR	/* Clear DPAR */
	xcr   TMP,  TMP,  SR3               /* get E.F. pointer */
	st.d  r30,  TMP,  GENREG_OFF(30)    /* save previous r30, r31 */
	or    r31,  TMP,  r0                /* transfer E.F. pointer to r31 */
	ld    TMP,  r31,  REG_OFF(EF_SR3)   /* get previous SR3; maybe important*/
d2865 3
a2867 3
	xcr   FLAGS,FLAGS,SR1
	clr   FLAGS,FLAGS,1<FLAG_ENABLING_FPU>
	xcr   FLAGS,FLAGS,SR1
d2869 1
a2869 1
	xcr   TMP,  TMP,  SR3       /* replace TMP, SR3 */
d2872 15
a2886 15
	st.d  r0 ,  r31,  GENREG_OFF(0)
	st.d  r2 ,  r31,  GENREG_OFF(2)
	st.d  r4 ,  r31,  GENREG_OFF(4)
	st.d  r6 ,  r31,  GENREG_OFF(6)
	st.d  r8 ,  r31,  GENREG_OFF(8)
	st.d  r10,  r31,  GENREG_OFF(10)
	st.d  r12,  r31,  GENREG_OFF(12)
	st.d  r14,  r31,  GENREG_OFF(14)
	st.d  r16,  r31,  GENREG_OFF(16)
	st.d  r18,  r31,  GENREG_OFF(18)
	st.d  r20,  r31,  GENREG_OFF(20)
	st.d  r22,  r31,  GENREG_OFF(22)
	st.d  r24,  r31,  GENREG_OFF(24)
	st.d  r26,  r31,  GENREG_OFF(26)
	st.d  r28,  r31,  GENREG_OFF(28)
d2889 33
a2921 36
	or.u  r20,  r0,   hi16(0x12345678)
	or    r20,  r20,  lo16(0x12345678)
	st    r20,  r31,  GENREG_OFF(0)
#endif
	
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                           *
	* SR1: free                                                     *
	* SR2: free                                                     *
	* SR3: previous exception-time SR3                              *
	* r1: return address to the calling exception handler           *
	* r2 through r30: free                                          *
	* r31: our exception frame                                      *
	*                                                               *
	* Valid in the exception frame:                                 *
	*   Exception-time r0 through r31.                              *
	*   Exception-time FLAGS.                                       *
	*   Exception-time espr, enip, exip.                            *
	*   Exception number (EF_VECTOR).                               *
	*   DSR                                                         *
	* Other data pipeline control registers, if appropriate.        *
	*   FPU control registers, if appropriate.                      *
	*   Exception SR3, if appropriate.                              *
	***************************************************             *
	* immediate goal:                                               *
	*   Pick up a stack if we came in from user mode. Put           *
	*       A copy of the exception frame pointer into r30          *
	*       bump the stack a doubleword and write the exception     *
	*       frame pointer.                                          *
	*   if not an interrupt exception,                              *
	*       Turn on interrupts and service any outstanding          *
	*       data access exceptions.                                 *
	*   Return to calling exception handler to                      *
	*   service the exception.                                      *
	\***************************************************************/
	
d2926 3
a2928 3
	or    r30,  r0,   r31              /* get a copy of the e.f. pointer */
	ld    r2,   r31,  REG_OFF(EF_EPSR)
	bb1   PSR_SUPERVISOR_MODE_BIT, r2, 1f  /* If in kernel mode */
d2930 1
a2930 1
#if INTSTACK
d2935 6
a2940 6
	ld    r3,   r31,  REG_OFF(EF_VECTOR)
	cmp   r3,   r3,   1      /* is interrupt ? */
	bb0   eq,   r3,   2f
	or.u  r31,  r0,   hi16(_intstack_end)   /* swith to int stack */
	or    r31,  r31,  lo16(_intstack_end)
	br    3f
d2943 4
a2946 4
	or.u  r31,  r0,   hi16(_kstack)
	ld    r31,  r31,  lo16(_kstack)
	addu  r31,  r31,  USIZE        /* point at proper end */
	br    3f
d2948 7
a2954 7
#if INTSTACK
	ld    r3,   r31,  REG_OFF(EF_VECTOR)
	cmp   r3,   r3,   1       /* is interrupt ? */
	bb0   eq,   r3,   3f      /* no, we will stay on kern stack */
	or.u  r31,  r0,   hi16(_intstack_end)   /* swith to int stack */
	or    r31,  r31,  lo16(_intstack_end)
#endif	/* INTSTACK */
d2956 2
a2957 1
m88110_exception_handler_has_ksp:  global m88110_exception_handler_has_ksp
d2962 4
a2965 4
	subu  r31,  r31,  8  /* make some breathing space */
	st    r30,  r31,  0  /* store frame pointer on the stack */
#if DDB
	st    r30,  r31,  4  /* store it again for the debugger to recognize */
d2968 19
a2986 18
	ld    r2,   r30,  REG_OFF(EF_VECTOR)
	bcnd.n eq0, r2,   m88110_return_to_calling_exception_handler  /* is error */
	ld    r14,  r30,  REG_OFF(EF_RET) /* load return value XXX!!! */
	cmp   r3,   r2,   1 /* interrupt is exception #1 ;Is an interrupt? */
	bb1.n   eq,   r3,   m88110_return_to_calling_exception_handler /* skip if so */

#if DDB
	cmp   r3,   r2,   130 /* DDB break exception */
	bb1.n eq,   r3,   m88110_return_to_calling_exception_handler

	cmp   r3,   r2,   132 /* DDB entry exception */
	bb1.n eq,   r3,   m88110_return_to_calling_exception_handler
#endif

	ldcr  r2,   PSR
	clr   r2,   r2,   1<PSR_INTERRUPT_DISABLE_BIT>   /* enable interrupts */
	stcr  r2,   PSR
#if     DDB
d2990 1
a2990 1
	br  m88110_return_to_calling_exception_handler
d2993 1
a2993 1
	   - check dsr... anything outstanding?*/
d2995 3
a2997 3
	ld    r3,   r30,  REG_OFF(EF_DSR)
	cmp   r3,   r3,   0
	bb1   eq,   r3,   m88110_return_to_calling_exception_handler
d3003 1
a3003 4
	or    r15,  r0,   r30
#if 0
	CALL(_C_LABEL(test_trap), r15, r0)
#endif   
d3006 2
a3007 2
	/*   restore it... */
	or    r30,  r0,   r15
d3010 1
a3010 1
	st    r0,   r30,  REG_OFF(EF_DSR)
d3013 2
a3014 2
	jmp   r14 /* loaded above */
	
d3018 2
a3019 2
	space SIZEOF_EF	
#endif
@


1.28
log
@Clean up ipl handling: be sure to always return valid levels in getipl(),
and check input level in setipl() if DIAGNOSTIC.

Doing this pointed out an horrible bug where exception frames would refer
to the saved ipl at the time the exception was processed, but would not
save it before, and the joys of stack values would make it a correct value
90% of the time. Of course, bad things could happen when restoring the
``saved'' ipl...
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.27 2002/12/14 07:42:13 fgsch Exp $   */
d571 1
a571 1
ASGLOBAL(fp_precise_handler)
d578 1
a578 1
ASGLOBAL(fp_imprecise_handler)
d618 1
a618 1
ASGLOBAL(break)
d623 1
a623 1
ASGLOBAL(trace)
d634 1
a634 1
ASGLOBAL(break)
d639 1
a639 1
ASGLOBAL(trace)
@


1.27
log
@handelr -> handler
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.25 2001/12/19 07:04:41 smurph Exp $   */
d368 1
a368 1
	1:	bsr	setup_phase_one			; \
d397 1
a397 1
1:	ldcr    r1, EPSR 				; \
d403 1
a403 1
	1:	bsr	m88110_setup_phase_one		; \
d1823 4
d1986 1
a1986 1
   
a1987 1
GLOBAL(return_from_main)
d2014 1
a2014 1
	bb0	DMT_VALID_BIT, r3, _check_ast /*[Oh well, nothing to do here] */
d2070 1
a2070 1
	br   _check_ast
d2124 1
a2124 1
GLOBAL(check_ast)
d2156 1
a2156 1
#ifdef M88110         
d2161 2
d2164 2
d2173 1
a2173 10
#if 0
        /* assert that ipl is 0; if going back to user, it should be 0 */

        bsr     _C_LABEL(getipl)
        bcnd    eq0, r2, 3f
        bsr     _C_LABEL(panic)
3:
#endif

ASGLOBAL(no_ast)
d2182 1
a2182 1
	ld      r2, FPTR, REG_OFF(EF_MASK)   /* get pre-exception ipl */
d2184 1
a2184 1
	subu	r31, r31, 40
a2255 1
ASGLOBAL(return_from_exception)
d2257 1
a2257 1
	
@


1.26
log
@change function names to reflect cpu type instead of board type.
@
text
@d563 1
a563 1
/* integer overflow exception handelr */
d2325 1
a2325 1
/* integer overflow exception handelr */
@


1.25
log
@Introduce brdtyp and change what cputyp means.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.24 2001/12/16 23:49:46 miod Exp $   */
d239 1
a239 2
#define INTSTACK      0   /* To make interupts use their own stack */

d251 1
a251 1
	bsr  _panic
d255 67
d391 1
a393 1
							; \
d395 1
a395 1
	stcr	r1, SR2   /* r1 now free */		; \
d397 4
a400 4
	ldcr	r1, EPSR				; \
	bb0.n	PSR_SUPERVISOR_MODE_BIT, r1, 1f		; \
	clr	FLAGS, FLAGS, 1<FLAG_FROM_KERNEL>	; \
	set	FLAGS, FLAGS, 1<FLAG_FROM_KERNEL>	; \
d403 1
a403 1
	1:	bsr	m197_setup_phase_one		; \
d411 1
a411 1
	bsr	m197_setup_phase_two			; \
d423 2
a424 2
#define M197_Data_Precheck \
   bb1.n   FLAG_IGNORE_DATA_EXCEPTION, FLAGS, m197_ignore_data_exception
a434 1
GLOBAL(eh_debug)    word 0x00000000
d436 2
d495 3
a497 3
   PREP("unknown", 0, DEBUG_UNKNOWN_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap18x), T_UNKNOWNFLT, r30)
   DONE(DEBUG_UNKNOWN_BIT)
d501 5
a505 5
   PREP("interrupt", 1, DEBUG_INTERRUPT_BIT, No_SSBR_Stuff, No_Precheck)
   /* interrupt_func is set in mvme_bootstrap() */
   CALL(_C_LABEL(trap18x), T_INT, r30)
   /*CALLP(_interrupt_func, 1, r30) */
   DONE(DEBUG_INTERRUPT_BIT)
d509 3
a511 3
   PREP("inst", 2, DEBUG_INSTRUCTION_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap18x), T_INSTFLT, r30)
   DONE(DEBUG_INSTRUCTION_BIT)
d518 2
a519 2
   PREP("data", 3, DEBUG_DATA_BIT, No_SSBR_Stuff, Data_Precheck)
   DONE(DEBUG_DATA_BIT)
d523 3
a525 3
   PREP("misalign", 4, DEBUG_MISALIGN_BIT, Clear_SSBR_Dest, No_Precheck)
   CALL(_C_LABEL(trap18x), T_MISALGNFLT, r30)
   DONE(DEBUG_MISALIGN_BIT)
d529 3
a531 3
   PREP("unimp", 5, DEBUG_UNIMPLEMENTED_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap18x), T_ILLFLT, r30)
   DONE(DEBUG_UNIMPLEMENTED_BIT)
d539 8
a546 8
   stcr    r1, SR2    /* hold r1 for a moment */
   ldcr    r1, SXIP   /* look at the sxip... valid bit set? */
   bb1.n   RTE_VALID_BIT, r1, 1f /*skip over return if a valid exception*/
   ldcr    r1, SR2    /* restore r1 */
   RTE
1: PREP("privilege", 6, DEBUG_PRIVILEGE_BIT, Clear_SSBR_Dest, No_Precheck)
   CALL(_C_LABEL(trap18x), T_PRIVINFLT, r30)
   DONE(DEBUG_PRIVILEGE_BIT)
d553 3
a555 3
   PREP("bounds", 7, DEBUG_BOUNDS_BIT, Clear_SSBR_Dest, No_Precheck)
   CALL(_C_LABEL(trap18x), T_BNDFLT, r30)
   DONE(DEBUG_BOUNDS_BIT)
d559 3
a561 3
   PREP("divide", 8, DEBUG_DIVIDE_BIT, Clear_SSBR_Dest, No_Precheck)
   CALL(_C_LABEL(trap18x), T_ZERODIV, r30)
   DONE(DEBUG_DIVIDE_BIT)
d565 3
a567 3
   PREP("overflow", 9, DEBUG_OVERFLOW_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap18x), T_OVFFLT, r30)
   DONE(DEBUG_OVERFLOW_BIT)
d572 3
a574 3
   PREP("FPU precise", 114, DEBUG_FPp_BIT, FPp_SSBR_STUFF, No_Precheck)
   CALL(_m88100_Xfp_precise, r0, r30) /* call fp_precise(??, exception_frame)*/ 
   DONE(DEBUG_FPp_BIT)
d579 3
a581 3
   PREP("FPU imprecise", 115, DEBUG_FPi_BIT, FPi_SSBR_STUFF, No_Precheck)
   CALL(_Xfp_imprecise, r0, r30) /*call fp_imprecise(??,exception_frame)*/
   DONE(DEBUG_FPi_BIT)
d585 4
a588 4
   PREP("syscall", 128, DEBUG_SYSCALL_BIT, No_SSBR_Stuff, No_Precheck)
   ld   r13, r30, GENREG_OFF(13)
   CALL(_syscall, r13, r30) /* system call no. is in r13 */
   DONE(DEBUG_SYSCALL_BIT)
d592 4
a595 4
   PREP("bugsyscall", 496, DEBUG_BUGCALL_BIT, No_SSBR_Stuff, No_Precheck)
   ld   r9,  r30, GENREG_OFF(9)
   CALL(_bugsyscall, r9, r30)   /* system call no. is in r9 */
   DONE(DEBUG_SYSCALL_BIT)
d598 3
a600 3
   PREP("sigsys", 0, DEBUG_SIGSYS_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap18x), T_SIGSYS, r30)
   DONE(DEBUG_SIGSYS_BIT)
d603 3
a605 3
   PREP("sigtrap", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap18x), T_SIGTRAP, r30)
   DONE(DEBUG_SIGTRAP_BIT)
d608 3
a610 3
   PREP("stepbpt", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap18x), T_STEPBPT, r30)
   DONE(DEBUG_SIGTRAP_BIT)
d613 3
a615 3
   PREP("userbpt", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap18x), T_USERBPT, r30)
   DONE(DEBUG_SIGTRAP_BIT)
d618 14
a631 13
   ASGLOBAL(break)
   PREP("break", 130, DEBUG_BREAK_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap18x), T_KDB_BREAK, r30)
   DONE(DEBUG_BREAK_BIT)
   ASGLOBAL(trace)
   PREP("trace", 131, DEBUG_TRACE_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap18x), T_KDB_TRACE, r30)
   DONE(DEBUG_TRACE_BIT)

   GLOBAL(entry)
   PREP("kdb", 132, DEBUG_KDB_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap18x), T_KDB_ENTRY, r30)
   DONE(DEBUG_KDB_BIT)
d634 14
a647 12
   ASGLOBAL(break)
   PREP("break", 130, DEBUG_BREAK_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap18x), T_UNKNOWNFLT, r30)
   DONE(DEBUG_BREAK_BIT)
   ASGLOBAL(trace)
   PREP("trace", 131, DEBUG_TRACE_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap18x), T_UNKNOWNFLT, r30)
   DONE(DEBUG_TRACE_BIT)
   GLOBAL(entry)
   PREP("unknown", 132, DEBUG_UNKNOWN_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap18x), T_UNKNOWNFLT, r30)
   DONE(DEBUG_KDB_BIT)
d758 1
a758 1
	st	r11, r31, REG_OFF(EF_MASK) /* put in EF_MASK for regdump */ 
d780 1
a780 1
        CALL(_error_fault, r30, r30)
d918 1
a918 1
	CALL(_error_reset, r30, r30)
d970 1
a970 1
ASGLOBAL(m197_ignore_data_exception)
d973 1
a973 1
	*  SR1: previous FLAGS reg                *
d975 1
a975 1
	*  SR3: must presere                                   *
d983 1
a983 1
	 * We just want to jump to "badaddr__return_nonzero" below.
d990 3
a992 3
	or.u	r2, r0, hi16(badaddr__return_nonzero)
	or	r2, r2, lo16(badaddr__return_nonzero)
	stcr	r2, SXIP   /* Make it the next instruction to execute */
d994 1
a994 1
	/* the following jumps to "badaddr__return_nonzero" in below */
d1022 4
a1025 4
   /*
    * Disable interrupts ... don't want a context switch while we're
    * doing this! Also, save the old PSR in R8 to restore later.
    */
d1094 1
a1094 1
	bsr   _printf
d1097 1
a1097 1
	bsr   _panic
d1121 12
d1142 16
a1157 16
   /***************** REGISTER STATUS BLOCK ***********************\
   * SR0: current thread (if any, null if not)                     *
   * SR1: saved copy of exception-time register now holding FLAGS  *
   * SR2: saved copy of exception-time r1                          *
   * SR3: must be preserved .. may be the exception-time stack     *
   * r1: return address to calling exception handler               *
   * FLAGS: CPU status flags                                       *
   ***************************************************             *
   * immediate goal:                                               *
   *    Decide where we're going to put the exception frame.       *
   *   Might be at the end of R31, SR3, or the thread's            *
   *   pcb.                                                        *
   \***************************************************************/

   /* Check if we are coming in from a FPU restart exception.
      If so, the pcb will be in SR3 */
d1165 1
a1165 1
   /* are we coming in from user mode? If so, pick up thread pcb */
d1168 1
a1168 1
   /* Interrupt in kernel mode, not FPU restart */
d1170 12
a1181 12
   /***************** REGISTER STATUS BLOCK ***********************\
   * SR0: current thread (if any, null if not)                     *
   * SR1: saved copy of exception-time register now holding FLAGS  *
   * SR2: return address to the calling exception handler          *
   * SR3: must be preserved; may be important for other exceptions *
   * FLAGS: CPU status flags                                       *
   ***************************************************             *
   * immediate goal:                                               *
   *   We're already on the kernel stack, but not having           *
   *   needed to use SR3. We can just make room on the             *
   *    stack (r31) for our exception frame.                       *
   \***************************************************************/
d1195 23
a1217 23
   /***************** REGISTER STATUS BLOCK ***********************\
   * SR0: current thread (if any, null if not)                     *
   * SR1: saved copy of exception-time register now holding FLAGS  *
   * SR2: return address to the calling exception handler          *
   * SR3: must be preserved; exception-time stack pointer          *
   * FLAGS: CPU status flags                                       *
   ***************************************************             *
   * immediate goal:                                               *
   *   An exception occurred while enabling the FPU. Since r31      *
   *   is the user's r31 while enabling the FPU, we had put        *
   *   our pcb pointer into SR3, so make room from                 *
   *   there for our stack pointer.                                *
   *       We need to check if SR3 is the old stack pointer or the *
   *       pointer off to the user pcb. If it pointing to the user *
   *       pcb, we need to pick up the kernel stack. Otherwise     *
   *       we need to allocate a frame upon it.                    *
   *       We look at the EPSR to see if it was from user mode     *
   *       Unfortunately, we have no registers free at the moment  *
   *       But we know register 0 in the pcb frame will always be  *
   *       zero, so we can use it as scratch storage.              *
   *                                                               *
   *                                                               *
   \***************************************************************/
d1223 1
a1223 1
   /* we were in kernel mode - dump frame upon the stack */
d1236 4
a1239 4
   /* we took an exception while restarting the FPU from user space.
    * Consequently, we never picked up a stack. Do so now.
    * R1 is currently free (saved in the exception frame pointed at by
    * r30) */
d1254 12
a1265 12
   /***************** REGISTER STATUS BLOCK ***********************\
   * SR0: current thread                                          *
   * SR1: saved copy of exception-time register now holding FLAGS *
   * SR2: return address to the calling exception handler         *
   * SR3: free                                                    *
   * FLAGS: CPU status flags                                      *
   ***************************************************            *
   * immediate goal:                                              *
   *    Since we're servicing an exception from user mode, we     *
   *   know that SR3 is free.  We use it to free up a temp.       *
   *   register to be used in getting the thread's pcb            *
   \***************************************************************/
d1268 1
a1268 1
   /* switch to the thread's kernel stack. */
d1276 1
a1276 1
   /*FALLTHROUGH */
d1477 19
a1495 19
   /***************** REGISTER STATUS BLOCK ***********************\
   * SR0: current thread                                          *
   * SR1: saved copy of exception-time register now holding FLAGS *
   * SR2: return address to the calling exception handler         *
   * SR3: saved TMP                                               *
   * r1:  free                                                    *
   * TMP: possibly revised SSBR                                   *
   * TMP2: free                                                   *
   * TMP3: free                                                   *
   * FLAGS: CPU status flags                                      *
   * r31: exception frame                                         *
   *    Valid in the exception frame:                             *
   *   Exception-time r1, r31, FLAGS.                             *
   *   Exception-time TMP2, TMP3.                                 *
   *   Exception-time espr, sfip, snip, sxip.                     *
   *   Dmt0.                                                      *
   *   Other data pipeline control registers, if appropriate.     *
   *   Exception SR3, if appropriate.                             *
   \***************************************************************/
d1505 9
a1513 9
   /*
    * Clear floatingpont-imprecise ssbr bits.
    * Also, save appropriate FPU control registers to the E.F.
    *
    *  r1:  return address to calling exception handler
    *  TMP : (possibly) revised ssbr
    *  TMP2 : free
    *  TMP3 : free
    */
d1529 4
a1532 4
   /*
    * We only need clear the bit in the SSBR for the
    * 2nd reg of a double result [see section 6.8.5]
    */
d1548 28
a1575 28
   /*
    * Clear floating pont precise ssbr bits.
    * Also, save appropriate FPU control registers to the E.F.
    *
    *  r1:  return address to calling exception handler
    *  TMP : (possibly) revised ssbr
    *  TMP2 : free
    *  TMP3 : free
    */
   fldcr TMP2, FPSR
   fldcr TMP3, FPCR
   st    TMP2, r31,  REG_OFF(EF_FPSR)
   st    TMP3, r31,  REG_OFF(EF_FPCR)
   
   fldcr TMP3, FPECR
   st    TMP3, r31,  REG_OFF(EF_FPECR)
   fldcr TMP2, FPHS1
   fldcr TMP3, FPHS2
   st    TMP2, r31,  REG_OFF(EF_FPHS1)
   st    TMP3, r31,  REG_OFF(EF_FPHS2)

   fldcr TMP2, FPLS1
   fldcr TMP3, FPLS2
   st    TMP2, r31,  REG_OFF(EF_FPLS1)
   st    TMP3, r31,  REG_OFF(EF_FPLS2)

   fldcr TMP2, FPPT
   st    TMP2, r31,  REG_OFF(EF_FPPT)
d1579 5
a1583 5
   bb1.n FPPT_SIZE_BIT, TMP2, 2f
   extu  TMP3, TMP2, 5<0> /* get FP operation dest reg */
   br.n  3f
   set   TMP3, TMP3, 1<5> /* set size=1 -- clear one bit for "float" */
2: set   TMP3, TMP3, 1<6> /* set size=2 -- clear two bit for "double" */
d1592 32
a1623 32
   /*
    * There are various cases where an exception can leave the
    * destination register's bit in the SB set.
    * Examples:
    *   misaligned or privilege exception on a LD or XMEM
    *   DIV or DIVU by zero.
    *
    * I think that if the instruction is LD.D, then two bits must
    * be cleared.
    *
    * Even though there are a number of instructions/exception
    * combinations that could fire this code up, it's only required
    * to be run for the above cases.  However, I don't think it'll
    * ever be a problem to run this in other cases (ST instructions,
    * for example), so I don't bother checking.  If we had to check
    * for every possible instruction, this code would be much larger.
    *
    * The only checking, then, is to see if it's a LD.D or not.
    *
    * At the moment....
    *  r1:  return address to calling exception handler
    *  TMP : (possibly) revised ssbr
    *  TMP2 : free
    *  TMP3 : free
    */
   
   ldcr  TMP3, EPSR   /* going to check: user or system memory? */
   ldcr  TMP2, SXIP   /* get the instruction's address */
   bb1.n PSR_SUPERVISOR_MODE_BIT, TMP3, 2f
   clr   TMP2, TMP2, 2<0> /* get rid of valid and error bits. */

1:  /* user space load here */
d1625 6
a1630 6
   NOP
   ld.usr TMP2,TMP2, r0      /* get the instruction itself */
   NOP
   NOP
   NOP
   br    3f
d1632 2
a1633 2
   br.n  3f
   ld.usr TMP2,TMP2, r0      /* get the instruction itself */
d1636 2
a1637 40
2: /* system space load here */
   ld    TMP2, TMP2, r0      /* get the instruction itself */

3: /* now have the instruction..... */
   /*
    * Now see if it's a double load
    * There are three forms of double load [IMM16, scaled, unscaled],
    * which can be checked by matching against two templates:
    *          -- 77776666555544443333222211110000 --
    *   if (((instruction & 11111100000000000000000000000000) ==
    *             00010000000000000000000000000000) ;;
    *       ((instruction & 11111100000000001111110011100000) ==
    *             11110100000000000001000000000000))
    *   {
    *      It's a load double, so
    *      clear two SSBR bits.
    *   } else {
    *      It's not a load double.
    *      Must be a load single, xmem, or st
    *      Thus, clear one SSBR bit.
    *   }
    */
   /* check the first pattern for ld.d */
   extu  TMP3, TMP2, 16<16>   /* get the upper 16 bits */
   mask  TMP3, TMP3, 0xFC00   /* apply the mask */
   cmp   TMP3, TMP3, 0x1000   /* if this is equal, it's a load double */
   bb1   eq,   TMP3, misaligned_double

   /* still could be -- check the second pattern for ld.d */
   /* look at the upper 16 bits first */
   extu  TMP3, TMP2, 16<16>   /* get the upper 16 bits */
   mask  TMP3, TMP3, 0xFC00   /* apply the mask */
   cmp   TMP3, TMP3, 0xF400   /* if equal, it might be a load double */
   bb1   ne,   TMP3, misaligned_single /* not equal, so must be single */

   /* now look at the lower 16 bits */
   extu  TMP3, TMP2, 16<0>    /* get the lower 16 bits */
   mask  TMP3, TMP3, 0xFCE0   /* apply the mask */
   cmp   TMP3, TMP3, 0x1000   /* if this is equal, it's a load double */
   bb1   eq,   TMP3, misaligned_double
d1639 38
d1678 3
a1680 3
   extu  TMP2, TMP2, 5<21>    /* get the destination register */
   br.n  1f
   set   TMP2, TMP2, 1<5>     /* set size=1 */
d1683 2
a1684 2
   extu  TMP2, TMP2, 5<21>    /* get the destination register */
   set   TMP2, TMP2, 1<6>     /* set size=2 -- clear two bit for "ld.d" */
d1686 2
a1687 2
1: jmp.n   r1
   clr   TMP,  TMP,  TMP2     /* clear bit(s) in ssbr. */
d1695 32
a1726 32
   /***************** REGISTER STATUS BLOCK ***********************\
   * SR0: saved return address to calling exception handler        *
   * SR1: saved copy of exception-time register now holding FLAGS  *
   * SR2: free                                                     *
   * SR3: saved TMP                                                *
   * r1:  return address to calling exception handler              *
   * TMP: possibly revised SSBR                                    *
   * TMP2: free                                                    *
   * TMP3: free                                                    *
   * FLAGS: CPU status flags                                       *
   * r31: our exception frame                                      *
   *    Valid in the exception frame:                              *
   *   Exception-time r1, r31, FLAGS.                              *
   *   Exception-time TMP2, TMP3.                                  *
   *   Exception-time espr, sfip, snip, sxip.                      *
   *   Exception number (EF_VECTOR).                               *
   *   Dmt0                                                        *
   *   Other data pipeline control registers, if appropriate.      *
   *   FPU control registers, if appropriate.                      *
   *   Exception SR3, if appropriate.                              *
   ***************************************************             *
   * immediate goal:                                               *
   *   restore the system to the exception-time state (except      *
   * SR3 will be OUR stack pointer) so that we may resart the FPU. *
   \***************************************************************/
   /*stcr   r1, SR0*/      /* save return address */
   
   stcr  TMP,  SSBR   /* done with SSBR, TMP now free */
   RESTORE_TMP2      /* done with extra temp regs */
   RESTORE_TMP3      /* done with extra temp regs */

   /* Get the current PSR and modify for the rte to enable the FPU */
d1728 11
a1738 11
   ldcr  TMP,  PSR
   clr   TMP,  TMP,  1<PSR_FPU_DISABLE_BIT>    /* enable the FPU */
   clr   TMP,  TMP,  1<PSR_SHADOW_FREEZE_BIT>  /* also enable shadowing */
   stcr  TMP,  EPSR

   /* the "+2" below is to set the VALID_BIT */
   or.u  TMP,  r0,   hi16(fpu_enable +2)
   or    TMP,  TMP,  lo16(fpu_enable +2)
   stcr  TMP,  SNIP      /* jump to here fpu_enable */
   addu  TMP,  TMP,  4
   stcr  TMP,  SFIP      /* and then continue after that */
d1740 10
a1749 10
   ldcr  TMP,  PSR
   or.u  TMP,  TMP,  0x8000    /* set supervisor mode */
   and   TMP,  TMP,  0xfff7    /* also enable shadowing */
   stcr  TMP,  EPSR
   stcr  r0,   SXIP       /* clear valid bit */
   stcr  r0,   SNIP       /* clear valid bit */
   or.u  TMP,  r0,   hi16(fpu_enable)
   or    TMP,  TMP,  lo16(fpu_enable)
   or    TMP,  TMP,  0x2 /* set the VALID_BIT and clear Exception bit */
   stcr  TMP,  SFIP      /* jump to here fpu_enable */
d1753 34
a1786 34
   set   FLAGS, FLAGS, 1<FLAG_ENABLING_FPU> /* note what we're doing.*/
   xcr   FLAGS, FLAGS, SR1
   st    r1,   r31,  REG_OFF(EF_RET) /* save the return address */
   ld    r1,   r31,  GENREG_OFF(1)    /* get original r1 */

   xcr   TMP,  r31,  SR3   /* TMP now restored. R31 now saved in SR3 */
   ld    r31,  r31,  GENREG_OFF(31) /* get original r31 */

   /***************** REGISTER STATUS BLOCK ***********************\
   * SR0: current thread                                           *
   * SR1: CPU flags                                                *
   * SR2: free                                                     *
   * SR3: pointer to our exception frame (our stack pointer)       *
   * r1 through r31: original exception-time values                *
   *                                                               *
   * Valid in the exception frame:                                 *
   *   Exception-time FLAGS.                                       *
   *   Exception-time espr, sfip, snip, sxip.                      *
   *   Exception number (EF_VECTOR).                               *
   *   Dmt0                                                        *
   *   Other data pipeline control registers, if appropriate.      *
   *   FPU control registers, if appropriate.                      *
   *   Exception SR3, if appropriate.                              *
   *   Held temporarly in the exception frame:                     *
   *   Return address to the calling excption handler.             *
   ***************************************************             *
   * immediate goal:                                               *
   *   Do an RTE to restart the fpu and jump to "fpu_enable"       *
   *   Another exception (or exceptions) may be raised in          *
   *   this, which is why FLAG_ENABLING_FPU is set in SR1.         *
   \***************************************************************/
   
   RTE   /* jumps to "fpu_enable" on the next line to enable the FPU. */

d1788 29
a1816 29
   FLUSH_PIPELINE
   xcr   TMP,  TMP,  SR3               /* get E.F. pointer */
   st.d  r30,  TMP,  GENREG_OFF(30)    /* save previous r30, r31 */
   or    r31,  TMP,  r0                /* transfer E.F. pointer to r31 */
   ld    TMP,  r31,  REG_OFF(EF_SR3)   /* get previous SR3; maybe important*/

   /* make sure that the FLAG_ENABLING_FPU bit is off */
   xcr   FLAGS,FLAGS,SR1
   clr   FLAGS,FLAGS,1<FLAG_ENABLING_FPU>
   xcr   FLAGS,FLAGS,SR1

   xcr   TMP,  TMP,  SR3       /* replace TMP, SR3 */

   /* now save all regs to the exception frame. */
   st.d  r0 ,  r31,  GENREG_OFF(0)
   st.d  r2 ,  r31,  GENREG_OFF(2)
   st.d  r4 ,  r31,  GENREG_OFF(4)
   st.d  r6 ,  r31,  GENREG_OFF(6)
   st.d  r8 ,  r31,  GENREG_OFF(8)
   st.d  r10,  r31,  GENREG_OFF(10)
   st.d  r12,  r31,  GENREG_OFF(12)
   st.d  r14,  r31,  GENREG_OFF(14)
   st.d  r16,  r31,  GENREG_OFF(16)
   st.d  r18,  r31,  GENREG_OFF(18)
   st.d  r20,  r31,  GENREG_OFF(20)
   st.d  r22,  r31,  GENREG_OFF(22)
   st.d  r24,  r31,  GENREG_OFF(24)
   st.d  r26,  r31,  GENREG_OFF(26)
   st.d  r28,  r31,  GENREG_OFF(28)
d1818 4
a1821 4
   /* mark beginning of frame with notable value */
   or.u  r20,  r0,   hi16(0x12345678)
   or    r20,  r20,  lo16(0x12345678)
   st    r20,  r31,  GENREG_OFF(0)
d1823 36
a1858 36

   /***************** REGISTER STATUS BLOCK ***********************\
   * SR0: current thread                                           *
   * SR1: free                                                     *
   * SR2: free                                                     *
   * SR3: previous exception-time SR3                              *
   * r1: return address to the calling exception handler           *
   * r2 through r30: free                                          *
   * r31: our exception frame                                      *
   *                                                               *
   * Valid in the exception frame:                                 *
   *   Exception-time r0 through r31.                              *
   *   Exception-time FLAGS.                                       *
   *   Exception-time espr, sfip, snip, sxip.                      *
   *   Exception number (EF_VECTOR).                               *
   *   Dmt0                                                        *
   *   Other data pipeline control registers, if appropriate.      *
   *   FPU control registers, if appropriate.                      *
   *   Exception SR3, if appropriate.                              *
   ***************************************************             *
   * immediate goal:                                               *
   *   Pick up a stack if we came in from user mode. Put           *
   *       A copy of the exception frame pointer into r30          *
   *       bump the stack a doubleword and write the exception     *
   *       frame pointer.                                          *
   *   if not an interrupt exception,                              *
   *       Turn on interrupts and service any outstanding          *
   *       data access exceptions.                                 *
   *   Return to calling exception handler to                      *
   *   service the exception.                                      *
   \***************************************************************/

   /*
    * If it's not the interrupt exception, enable interrupts and
    * take care of any data access exceptions......
    *
d1860 4
a1863 2
    * If interrupt exception, switch to interrupt stack if not
    * already there. Else, switch to kernel stack.
d1865 3
a1867 4
    */
   or    r30,  r0,   r31              /* get a copy of the e.f. pointer */
   ld    r2,   r31,  REG_OFF(EF_EPSR)
   bb1   PSR_SUPERVISOR_MODE_BIT, r2, 1f  /* If in kernel mode */
d1870 6
a1875 6
   ld    r3,   r31,  REG_OFF(EF_VECTOR)
   cmp   r3,   r3,   1      /* is interrupt ? */
   bb0   eq,   r3,   2f
   or.u  r31,  r0,   hi16(_intstack_end)   /* swith to int stack */
   or    r31,  r31,  lo16(_intstack_end)
   br    3f
d1878 4
a1881 4
   or.u  r31,  r0,   hi16(_kstack)
   ld    r31,  r31,  lo16(_kstack)
   addu  r31,  r31,  USIZE        /* point at proper end */
   br    3f
d1884 5
a1888 5
   ld    r3,   r31,  REG_OFF(EF_VECTOR)
   cmp   r3,   r3,   1       /* is interrupt ? */
   bb0   eq,   r3,   3f      /* no, we will stay on kern stack */
   or.u  r31,  r0,   hi16(_intstack_end)   /* swith to int stack */
   or    r31,  r31,  lo16(_intstack_end)
d1890 1
a1890 1
   /* This label is here for debugging */
d1892 6
a1897 6
3: /*
      here - r30 holds a pointer to the exception frame.
      r31 is a pointer to the kernel stack/interrupt stack.
    */
   subu  r31,  r31,  8  /* make some breathing space */
   st    r30,  r31,  0  /* store frame pointer on the stack */
d1899 1
a1899 1
   st    r30,  r31,  4  /* store it again for the debugger to recognize */
d1902 5
a1906 5
   ld    r2,   r30,  REG_OFF(EF_VECTOR)
   bcnd.n eq0, r2,   return_to_calling_exception_handler  /* is error */
   ld    r14,  r30,  REG_OFF(EF_RET)
   cmp   r3,   r2,   1 /* interrupt is exception #1 ;Is an interrupt? */
   bb1.n eq,   r3,   return_to_calling_exception_handler /* skip if so */
d1909 4
a1912 5
   cmp   r3,   r2,   130 /* DDB break exception */
   bb1.n eq,   r3,   return_to_calling_exception_handler

   cmp   r3,   r2,   132 /* DDB entry exception */
   bb1.n eq,   r3,   return_to_calling_exception_handler
d1915 3
a1917 3
   ldcr  r2,   PSR
   clr   r2,   r2,   1<PSR_INTERRUPT_DISABLE_BIT>   /* enable interrupts */
   stcr  r2,   PSR
d1919 1
a1919 1
   FLUSH_PIPELINE
d1922 2
a1923 2
   /* service any outstanding data pipeline stuff
      - check dmt0 anything outstanding?*/
d1925 2
a1926 2
   ld    r3,   r30,  REG_OFF(EF_DMT0)
   bb0   DMT_VALID_BIT, r3, return_to_calling_exception_handler
d1928 5
a1932 5
/*
   r30 can be clobbered by calls. So stuff its value into a
   preserved register, say r15. R14 is in use (see return_to_... below).
 */
   or    r15,  r0,   r30
d1934 2
a1935 2
   CALL(_C_LABEL(trap18x), T_DATAFLT, r15)
   CALL(_data_access_emulation, r15, r0)
d1937 2
a1938 2
/*   restore it... */
   or    r30,  r0,   r15
d1940 2
a1941 2
   /* clear the dmt0 word in the E.F */
   st    r0,   r30,  REG_OFF(EF_DMT0)
d1944 1
a1944 1
   jmp   r14 /* loaded above */
d1958 10
a1967 10
   ld    r1,r31,0      /* load func */
   ld    r2,r31,4      /* load proc pointer */
   jsr.n    r1
   subu    r31,r31,40      /* create stack space for function */
   addu    r31,r31,48      /* stack space above + ksigframe */
   ld   r1, r31,0      /* load pc */
   ld   r2, r31,4      /* & proc pointer from switch frame */
   jsr.n   r1
   addu   r31,r31,8
   bsr   _panic
d1978 4
a1981 4
   ld   r3,r2,P_ADDR         /* p->p_addr */
   addu   r3,r3,PCB_USER_STATE      /* p->p_addr.u_pcb.user_state */
   st   r3,r31,0         /* put it on the stack */
   br      return_from_exception_handler
d2002 2
a2003 2
	or.u	r2, r0, hi16(_cputyp)
	ld	r3, r2, lo16(_cputyp)
d2005 1
a2005 1
	bb1	eq, r2, m197_return_code
a2007 1
	/* 18x part for return_from_exception_handler() follows... */
d2014 4
a2017 4
       /*
       * This might happen for non-interrupts  If the user sets DMT0
       * in an exception handler.........
       */
d2024 1
a2024 1
	CALL(_db_printf, r4, r0)
d2034 9
a2042 9
   /*
    * If it's the interrupt exception, enable interrupt.
    * Take care of any data access exception...... 90/8/15 add by yama
    */

   /*
    * Is it ever possible to have interrupt exception while EPSR has
    * it disabled? I don't think so.. XXX nivas
    */
d2047 1
a2047 1
   /* if EPSR has interrupts disabled, skip also */
d2049 1
a2049 1
        bb1   PSR_INTERRUPT_DISABLE_BIT, r2, 1f        /* skip if disabled */
d2051 2
a2052 2
	clr   r2, r2, 1<PSR_INTERRUPT_DISABLE_BIT>    /* enable interrupts */
        FLUSH_PIPELINE
d2054 1
a2054 1
   1:
d2058 7
a2064 8
   /*
    * if there happens to be a data fault that hasn't been serviced yet,
    * go off and service that...
    */
	CALL(_C_LABEL(trap18x), T_DATAFLT, r30)
	CALL(_data_access_emulation, r30, r0)     /* really only 2 args */

   /* clear the dmt0 word in the E.F. */
d2066 1
a2066 1
   2:
d2068 2
a2069 2
#endif	/* M88100 */
	/* 197 part for return_from_exception_handler() follows... */
d2071 1
a2071 1
ASLOCAL(m197_return_code)
a2073 3
	ld	r3, FPTR, REG_OFF(EF_DSR)
	cmp	r2, r3, 0x0
	bb1	eq, r2, _check_ast /*[Oh well, nothing to do here] */
a2074 1
#if 1
d2076 2
a2077 2
	 * This might happen for non-interrupts  If the user sets DMT0
	 * in an exception handler.........
a2078 20
	ld	r2, FPTR, REG_OFF(EF_VECTOR)
	cmp	r2, r2, 1 /* interrupt is exception #1 ; Is an interrupt? */ 
	bb1	eq, r2, 1f
	or.u	r4, r0, hi16(2f)
	or	r4, r4, lo16(2f)
#if DDB
	CALL(_db_printf, r4, r0)
	tb0 0, r0, 132
#endif
	br 1f
	data
2:	string "OOPS: DSR not zero and not interrupt.\n\000"
	align 8
	text
1:
#endif
   /*
    * If it's the interrupt exception, enable interrupt.
    * Take care of any data access exception...... 90/8/15 add by yama
    */
d2080 6
a2085 4
   /*
    * Is it ever possible to have interrupt exception while EPSR has
    * it disabled? I don't think so.. XXX nivas
    */
d2087 2
a2088 2
	cmp	r2, r2, 1   /* interrupt is exception #1 ; Is an interrupt? */ 
	bb1	ne, r2, 1f  /* If not so, skip */
d2090 1
a2090 1
   /* if EPSR has interrupts disabled, skip also */
d2098 4
a2101 3
	ld	r2, FPTR, REG_OFF(EF_DSR)
	cmp	r3, r2, 0x0
	bb1	eq, r3, 2f
d2103 5
a2107 5
   /*
    * if there happens to be a data fault that hasn't been serviced yet,
    * go off and service that...
    */
	CALL(_C_LABEL(trap197), T_DATAFLT, r30)
d2109 1
a2109 1
   /* clear the dmt0 word in the E.F. */
d2111 2
d2126 1
a2126 1
        bcnd    ne0, r2, 1f           /* can't do softint's */
d2129 1
a2129 1
	bsr.n   _setipl
d2133 1
a2133 1
        bsr     _dosoftint
d2136 2
a2137 2
        bsr.n   _setipl
        or      r2,r0,0                   /* ints are enabled */
d2146 2
a2147 2
        or.u	r2, r0, hi16(_want_ast)
        ld	r3, r2, lo16(_want_ast)
d2154 2
a2155 2
	or.u	r2, r0, hi16(_cputyp)
	ld	r3, r2, lo16(_cputyp)
d2158 1
a2158 1
        CALL(_C_LABEL(trap197), T_ASTFLT, FPTR)
d2163 1
a2163 1
        CALL(_C_LABEL(trap18x), T_ASTFLT, FPTR)
d2169 1
a2169 1
        bsr     _getipl
d2171 1
a2171 1
        bsr     _panic
d2185 1
a2185 1
	bsr.n   _setipl
d2219 2
a2220 2
        or.u	r1, r0, hi16(_cputyp)
	ld	r1, r1, lo16(_cputyp)
d2224 4
a2227 4
	ld      r30, r31, REG_OFF(EF_SNIP)
        ld      r1,  r31, REG_OFF(EF_SXIP)
        stcr    r30, SNIP
        stcr    r1,  SXIP
d2229 1
a2229 1
1:	
d2267 4
a2270 4
GLOBAL(m197_unknown_handler)
   PREP2("unknown", 0, DEBUG_UNKNOWN_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap197), T_UNKNOWNFLT, r30)
   DONE(DEBUG_UNKNOWN_BIT)
d2273 4
a2276 4
GLOBAL(m197_interrupt_handler)
   PREP2("interrupt", 1, DEBUG_INTERRUPT_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_sbc_ext_int, 1, r30) 
   DONE(DEBUG_INTERRUPT_BIT)
d2279 4
a2282 5
GLOBAL(m197_instruction_access_handler)
   PREP2("inst", 2, DEBUG_INSTRUCTION_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap197), T_INSTFLT, r30)
   DONE(DEBUG_INSTRUCTION_BIT)

d2287 4
a2290 3
GLOBAL(m197_data_exception_handler)
   PREP2("data", 3, DEBUG_DATA_BIT, No_SSBR_Stuff, M197_Data_Precheck)
   DONE(DEBUG_DATA_BIT)
d2293 4
a2296 4
GLOBAL(m197_misaligned_handler)
   PREP2("misalign", 4, DEBUG_MISALIGN_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap197), T_MISALGNFLT, r30)
   DONE(DEBUG_MISALIGN_BIT)
d2299 4
a2302 4
GLOBAL(m197_unimplemented_handler)
   PREP2("unimp", 5, DEBUG_UNIMPLEMENTED_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap197), T_ILLFLT, r30)
   DONE(DEBUG_UNIMPLEMENTED_BIT)
d2305 4
a2308 4
GLOBAL(m197_privilege_handler)
   PREP2("privilege", 6, DEBUG_PRIVILEGE_BIT, No_SSBR_Stuff, No_Precheck) 
   CALL(_C_LABEL(trap197), T_PRIVINFLT, r30)
   DONE(DEBUG_PRIVILEGE_BIT)
d2314 4
a2317 4
GLOBAL(m197_bounds_handler)
   PREP2("bounds", 7, DEBUG_BOUNDS_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap197), T_BNDFLT, r30)
   DONE(DEBUG_BOUNDS_BIT)
d2320 4
a2323 4
GLOBAL(m197_divide_handler)
   PREP2("divide", 8, DEBUG_DIVIDE_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap197), T_ZERODIV, r30)
   DONE(DEBUG_DIVIDE_BIT)
d2326 4
a2329 4
GLOBAL(m197_overflow_handler)
   PREP2("overflow", 9, DEBUG_OVERFLOW_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap197), T_OVFFLT, r30)
   DONE(DEBUG_OVERFLOW_BIT)
d2332 10
a2341 10
GLOBAL(m197_fp_precise_handler)
   PREP2("FPU precise", 114, DEBUG_FPp_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_m88110_Xfp_precise, r0, r30) /* call fp_precise(??, exception_frame)*/ 
   DONE(DEBUG_FPp_BIT)

/* MVME197 non-maskable interrupt handler */
GLOBAL(m197_nonmaskable)
   PREP2("MVME197 non-mask", 11, DEBUG_NON_MASK_BIT, No_SSBR_Stuff, No_Precheck) 
   CALL(_C_LABEL(trap197), T_NON_MASK, r30)
   DONE(DEBUG_NON_MASK_BIT)
d2344 4
a2347 4
GLOBAL(m197_data_read_miss)
   PREP2("MVME197 read miss", 12, DEBUG_197_READ_BIT, No_SSBR_Stuff, No_Precheck) 
   CALL(_C_LABEL(trap197), T_197_READ, r30)
   DONE(DEBUG_197_READ_BIT)
d2350 4
a2353 4
GLOBAL(m197_data_write_miss)
   PREP2("MVME197 write miss", 13, DEBUG_197_WRITE_BIT, No_SSBR_Stuff, No_Precheck) 
   CALL(_C_LABEL(trap197), T_197_WRITE, r30)
   DONE(DEBUG_197_WRITE_BIT)
d2356 4
a2359 4
GLOBAL(m197_inst_atc_miss)
   PREP2("MVME197 inst miss", 14, DEBUG_197_INST_BIT, No_SSBR_Stuff, No_Precheck) 
   CALL(_C_LABEL(trap197), T_197_INST, r30)
   DONE(DEBUG_197_INST_BIT)
d2362 5
a2366 5
GLOBAL(m197_syscall_handler)
   PREP2("syscall", 128, DEBUG_SYSCALL_BIT, No_SSBR_Stuff, No_Precheck)
   ld   r13, r30, GENREG_OFF(13)
   CALL(_m197_syscall, r13, r30) /* system call no. is in r13 */
   DONE(DEBUG_SYSCALL_BIT)
d2369 25
a2393 25
GLOBAL(m197_bugtrap)
   PREP2("bugsyscall", 496, DEBUG_BUGCALL_BIT, No_SSBR_Stuff, No_Precheck)
   ld   r9,  r30, GENREG_OFF(9)
   CALL(_bugsyscall, r9, r30)   /* system call no. is in r9 */
   DONE(DEBUG_SYSCALL_BIT)

GLOBAL(m197_sigsys)
   PREP2("sigsys", 0, DEBUG_SIGSYS_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap197), T_SIGSYS, r30)
   DONE(DEBUG_SIGSYS_BIT)

GLOBAL(m197_sigtrap)
   PREP2("sigtrap", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap197), T_SIGTRAP, r30)
   DONE(DEBUG_SIGTRAP_BIT)

GLOBAL(m197_stepbpt)
   PREP2("sigtrap", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap197), T_STEPBPT, r30)
   DONE(DEBUG_SIGTRAP_BIT)

GLOBAL(m197_userbpt)
   PREP2("sigtrap", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap197), T_USERBPT, r30)
   DONE(DEBUG_SIGTRAP_BIT)
d2396 14
a2409 13
   GLOBAL(m197_break)
   PREP2("break", 130, DEBUG_BREAK_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap197), T_KDB_BREAK, r30)
   DONE(DEBUG_BREAK_BIT)
   GLOBAL(m197_trace)
   PREP2("trace", 131, DEBUG_TRACE_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap197), T_KDB_TRACE, r30)
   DONE(DEBUG_TRACE_BIT)
   GLOBAL(m197_entry)
   PREP2("kdb", 132, DEBUG_KDB_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap197), T_KDB_ENTRY, r30)
   DONE(DEBUG_KDB_BIT)

d2411 14
a2424 12
   GLOBAL(m197_break)
   PREP2("break", 130, DEBUG_BREAK_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap197), T_UNKNOWNFLT, r30)
   DONE(DEBUG_BREAK_BIT)
   GLOBAL(m197_trace)
   PREP2("trace", 131, DEBUG_TRACE_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap197), T_UNKNOWNFLT, r30)
   DONE(DEBUG_TRACE_BIT)
   GLOBAL(m197_entry)
   PREP2("unknown", 132, DEBUG_UNKNOWN_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap197), T_UNKNOWNFLT, r30)
   DONE(DEBUG_KDB_BIT)
d2427 1
d2440 27
a2466 1
GLOBAL(m197_error_handler)
d2480 1
a2480 1
2:   /* stack has been cleared */
d2482 1
a2482 1
   /* ensure that stack is 8-byte aligned */
d2485 1
a2485 1
   /* create exception frame on stack */
d2488 1
a2488 1
   /* save old R31 and other R registers */
d2504 6
d2514 16
a2529 4
	ldcr	r10, SXIP
	st	r10, r31, REG_OFF(EF_SXIP)
	ldcr	r10, SNIP
	st	r10, r31, REG_OFF(EF_SNIP)
d2531 1
d2534 31
a2572 2
	/* error vector is zippo numero el'zeroooo */
	st	r0,  r31, REG_OFF(EF_VECTOR)
d2594 2
a2595 2

        CALL(_error_fault, r30, r30)
d2603 2
a2604 2
ASGLOBAL(m197_error_loop)
	bsr m197_error_loop
d2607 183
a2789 79
/*
 * The reset exception handler.
 * The reset exception is raised when the RST signal is asserted (machine 
 * is reset), the value of VBR is changed after exceptions are enabled, 
 * or when a jmp, br/bsr to addr 0 (accidents do happen :-)
 *
 * To tell the difference, you should check the value of r1 and the valid
 * bit of SXIP.
 *
 * Upon a real reset, VBR is set to zero (0), so code must be at addr 0 
 * to handle it!!! 
 *
 * This is totaly different than _error_handler.  Shadowing might or 
 * might not be on.
 * R1-R31 could tell u alot about what happend, so we'll save them.
 *
 * We'll not worry about trashing r26-29 here,
 * since they aren't generally used.
 */
GLOBAL(m197_reset_handler)
        /* pick up the slavestack */
	or	r26, r0, r31           /* save old stack */
	or.u	r31, r0,  hi16(_intstack_end)
	or	r31, r31, lo16(_intstack_end)

	/* zero the stack, so we'll know what we're lookin' at */
	or.u	r27, r0,  hi16(_intstack)
	or	r27, r27, lo16(_intstack)
1:	cmp	r28, r27, r31
	bb1	ge,  r28, 2f   /* branch if at the end of the stack */
	st	r0,  r0,  r27
	br.n	1b
	addu	r27, r27, 4   /* bump up */
2:	/* stack has been cleared */

	/* ensure that stack is 8-byte aligned */
	clr	r31, r31, 3<0>  /* round down to 8-byte boundary */

	/* create exception frame on stack */
	subu	r31, r31, SIZEOF_EF             /* r31 now our E.F. */

	/* save old R31 and other R registers */
	st.d	r0 , r31, GENREG_OFF(0)
	st.d	r2 , r31, GENREG_OFF(2)
	st.d	r4 , r31, GENREG_OFF(4)
	st.d	r6 , r31, GENREG_OFF(6)
	st.d	r8 , r31, GENREG_OFF(8)
	st.d	r10, r31, GENREG_OFF(10)
	st.d	r12, r31, GENREG_OFF(12)
	st.d	r14, r31, GENREG_OFF(14)
	st.d	r16, r31, GENREG_OFF(16)
	st.d	r18, r31, GENREG_OFF(18)
	st.d	r20, r31, GENREG_OFF(20)
	st.d	r22, r31, GENREG_OFF(22)
	st.d	r24, r31, GENREG_OFF(24)
	st	r30, r31, GENREG_OFF(30)
	st	r26, r31, GENREG_OFF(31)

	/* save shadow registers */
	ldcr	r10, EPSR
	st	r10, r31, REG_OFF(EF_EPSR)
	ldcr	r10, SXIP
	st	r10, r31, REG_OFF(EF_SXIP)
	ldcr	r10, SNIP
	st	r10, r31, REG_OFF(EF_SNIP)
	ldcr	r10, SR1
	st	r10, r31, REG_OFF(EF_MODE)

	/* shove sr2 into EF_FPLS1 */
	ldcr	r10, SR2
	st	r10, r31, REG_OFF(EF_FPLS1)

	/* shove sr3 into EF_FPHS2 */
	ldcr	r10, SR3
	st	r10, r31, REG_OFF(EF_FPHS2)

	/* error vector is zippo numero el'zeroooo */ 
	st	r0,  r31, REG_OFF(EF_VECTOR)

d2791 1
a2791 1
	 * Cheap way to enable FPU and start shadowing again.
d2793 24
a2816 221
        ldcr    r10, PSR
        clr     r10, r10, 1<PSR_FPU_DISABLE_BIT>    /* enable the FPU */
        clr     r10, r10, 1<PSR_SHADOW_FREEZE_BIT>  /* also enable shadowing */
   
        stcr    r10, PSR  /* bang */
	FLUSH_PIPELINE

	/* put pointer to regs into r30... r31 will become a simple stack */
	or	r30, r31, r0

	subu	r31, r31, 0x10 /* make some breathing space */
	st 	r30, r31, 0x0c /* store frame pointer on the st */
	st 	r30, r31, 0x08 /* store again for the debugger to recognize */ 
	or.u	r20,  r0, hi16(0x87654321)
	or	r20, r20, lo16(0x87654321)
	st	r20, r31, 0x04
	st	r20, r31, 0x00

	CALL(_error_reset, r30, r30)

	/* TURN INTERUPTS back on */
	ldcr r1, PSR
	clr  r1, r1, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr r1, PSR
	FLUSH_PIPELINE

ASGLOBAL(m197_error_loop2)
	bsr m197_error_loop2
/* never returns*/


ASGLOBAL(m197_setup_phase_one)
   /***************** REGISTER STATUS BLOCK ***********************\
   * SR0: current thread (if any, null if not)                     *
   * SR1: saved copy of exception-time register now holding FLAGS  *
   * SR2: saved copy of exception-time r1                          *
   * SR3: must be preserved .. may be the exception-time stack     *
   * r1: return address to calling exception handler               *
   * FLAGS: CPU status flags                                       *
   ***************************************************             *
   * immediate goal:                                               *
   *    Decide where we're going to put the exception frame.       *
   *   Might be at the end of R31, SR3, or the thread's            *
   *   pcb.                                                        *
   \***************************************************************/

   /* Check if we are coming in from a FPU restart exception.
      If so, the pcb will be in SR3 */
   NOP
   xcr   r1,   r1,   SR2
   NOP
   NOP
   NOP

   bb1   FLAG_ENABLING_FPU, FLAGS, m197_use_SR3_pcb
   /* are we coming in from user mode? If so, pick up thread pcb */
   bb0   FLAG_FROM_KERNEL, FLAGS, m197_pickup_stack

   /* Interrupt in kernel mode, not FPU restart */
ASGLOBAL(m197_already_on_kernel_stack)
   /***************** REGISTER STATUS BLOCK ***********************\
   * SR0: current thread (if any, null if not)                     *
   * SR1: saved copy of exception-time register now holding FLAGS  *
   * SR2: return address to the calling exception handler          *
   * SR3: must be preserved; may be important for other exceptions *
   * FLAGS: CPU status flags                                       *
   ***************************************************             *
   * immediate goal:                                               *
   *   We're already on the kernel stack, but not having           *
   *   needed to use SR3. We can just make room on the             *
   *    stack (r31) for our exception frame.                       *
   \***************************************************************/
   subu  r31,  r31,  SIZEOF_EF            /* r31 now our E.F. */
   st    FLAGS,r31,  REG_OFF(EF_FLAGS)    /* save flags */
   st    r1,   r31,  GENREG_OFF(1)        /* save prev. r1 (now r1 free)*/

   ldcr  r1,   SR3                        /* save previous SR3 */
   st    r1,   r31,  REG_OFF(EF_SR3)

   addu  r1,   r31,  SIZEOF_EF            /* save previous r31 */
   br.n  m197_have_pcb
   st    r1,   r31,  GENREG_OFF(31)


ASGLOBAL(m197_use_SR3_pcb)
   /***************** REGISTER STATUS BLOCK ***********************\
   * SR0: current thread (if any, null if not)                     *
   * SR1: saved copy of exception-time register now holding FLAGS  *
   * SR2: return address to the calling exception handler          *
   * SR3: must be preserved; exception-time stack pointer          *
   * FLAGS: CPU status flags                                       *
   ***************************************************             *
   * immediate goal:                                               *
   *   An exception occurred while enabling the FPU. Since r31      *
   *   is the user's r31 while enabling the FPU, we had put        *
   *   our pcb pointer into SR3, so make room from                 *
   *   there for our stack pointer.                                *
   *       We need to check if SR3 is the old stack pointer or the *
   *       pointer off to the user pcb. If it pointing to the user *
   *       pcb, we need to pick up the kernel stack. Otherwise     *
   *       we need to allocate a frame upon it.                    *
   *       We look at the EPSR to see if it was from user mode     *
   *       Unfortunately, we have no registers free at the moment  *
   *       But we know register 0 in the pcb frame will always be  *
   *       zero, so we can use it as scratch storage.              *
   *                                                               *
   *                                                               *
   \***************************************************************/
   xcr   r30,  r30,  SR3                  /* r30 = old exception frame */
   st    r1,   r30,  GENREG_OFF(0)        /* free up r1 */
   ld    r1,   r30,  REG_OFF(EF_EPSR)     /* get back the epsr */
   bb0.n PSR_SUPERVISOR_MODE_BIT, r1, 1f  /* if user mode */
   ld    r1,   r30,  GENREG_OFF(0)        /* restore r1 */
   /* we were in kernel mode - dump frame upon the stack */
   st    r0,   r30,  GENREG_OFF(0)        /* repair old frame */
   subu  r30,  r30,  SIZEOF_EF            /* r30 now our E.F. */
   st    FLAGS,r30,  REG_OFF(EF_FLAGS)    /* save flags */
   st    r1,   r30,  GENREG_OFF(1)        /* save prev. r1 (now r1 free) */

   st    r31,  r30,  GENREG_OFF(31)       /* save previous r31 */
   or    r31,  r0,   r30                  /* make r31 our pointer. */
   addu  r30,  r30,  SIZEOF_EF            /* r30 now has previous SR3 */
   st    r30,  r31,  REG_OFF(EF_SR3)      /* save previous SR3 */
   br.n  m197_have_pcb
   xcr   r30,  r30,  SR3                  /* restore r30 */
1:
   /* we took an exception while restarting the FPU from user space.
    * Consequently, we never picked up a stack. Do so now.
    * R1 is currently free (saved in the exception frame pointed at by
    * r30) */
   or.u  r1,   r0,   hi16(_kstack)
   ld    r1,   r1,   lo16(_kstack)
   addu  r1,   r1,   USIZE-SIZEOF_EF
   st    FLAGS,r1,   REG_OFF(EF_FLAGS)    /* store flags */
   st    r31,  r1,   GENREG_OFF(31)       /* store r31 - now free */
   st    r30,  r1,   REG_OFF(EF_SR3)      /* store old SR3 (pcb) */
   or	 r31,  r1,   r0                   /* make r31 our exception frame pointer */ 
   ld    r1,   r30,  GENREG_OFF(0)        /* restore old r1 */
   st    r0,   r30,  GENREG_OFF(0)        /* repair that frame */
   st    r1,   r31,  GENREG_OFF(1)        /* store r1 in its proper place */
   br.n   m197_have_pcb
   xcr   r30,  r30,  SR3                  /* restore r30 */

ASGLOBAL(m197_pickup_stack)
   /***************** REGISTER STATUS BLOCK ***********************\
   * SR0: current thread                                          *
   * SR1: saved copy of exception-time register now holding FLAGS *
   * SR2: return address to the calling exception handler         *
   * SR3: free                                                    *
   * FLAGS: CPU status flags                                      *
   ***************************************************            *
   * immediate goal:                                              *
   *    Since we're servicing an exception from user mode, we     *
   *   know that SR3 is free.  We use it to free up a temp.       *
   *   register to be used in getting the thread's pcb            *
   \***************************************************************/
   stcr  r31,  SR3      /* save previous r31 */

   /* switch to the thread's kernel stack. */
   or.u  r31,  r0,   hi16(_curpcb)
   ld    r31,  r31,  lo16(_curpcb)
   addu  r31,  r31,  PCB_USER_STATE       /* point to user save area */
   st    FLAGS,r31,  REG_OFF(EF_FLAGS)    /* save flags */
   st    r1,   r31,  GENREG_OFF(1)        /* save prev. r1 (now r1 free)*/
   ldcr  r1,   SR3                        /* save previous r31 */
   st    r1,   r31,  GENREG_OFF(31)
   /*FALLTHROUGH */

ASGLOBAL(m197_have_pcb)
   /***************** REGISTER STATUS BLOCK ***********************\
   * SR0: current thread                                          *
   * SR1: saved copy of exception-time register now holding FLAGS *
   * SR2: return address to the calling exception handler         *
   * SR3: free                                                    *
   * r1:  free                                                    *
   * FLAGS: CPU status flags                                      *
   * r31: our exception frame                                     *
   *    Valid in the exception frame:                             *
   *   Exception-time r1, r31, FLAGS.                             *
   *   Exception SR3, if appropriate.                             *
   ***************************************************            *
   * immediate goal:                                              *
   *    Save the shadow registers that need to be saved to        *
   *   the exception frame.                                       *
   \***************************************************************/
   stcr   TMP, SR3   /* free up TMP, TMP2, TMP3 */
   SAVE_TMP2
   SAVE_TMP3

   /* save some exception-time registers to the exception frame */
   ldcr  TMP,  EPSR
   st    TMP,  r31,  REG_OFF(EF_EPSR)
   ldcr  TMP3, SNIP
   st    TMP3, r31,  REG_OFF(EF_SNIP)
   
   /*
    * Save Pbus fault status register from data and inst CMMU.
    */

   ldcr  TMP,  ISR
   ldcr  TMP2, ILAR
   ldcr  TMP3, IPAR
   st    TMP,  r31,  REG_OFF(EF_ISR)
   st    TMP2, r31,  REG_OFF(EF_ILAR)
   st    TMP3, r31,  REG_OFF(EF_IPAR)
   ldcr  TMP,  ISAP
   st    TMP,  r31,  REG_OFF(EF_DMT0) /* hack ef! */
   ldcr  TMP,  DSR
   ldcr  TMP2, DLAR
   ldcr  TMP3, DPAR
   st    TMP,  r31,  REG_OFF(EF_DSR)
   st    TMP2, r31,  REG_OFF(EF_DLAR)
   st    TMP3, r31,  REG_OFF(EF_DPAR)
   ldcr  TMP,  DSAP
   st    TMP,  r31,  REG_OFF(EF_DMT1) /* hack ef! */
   ldcr  TMP2, SXIP
   st    TMP2, r31,  REG_OFF(EF_SXIP)
   
   ldcr  r1,   SR2
   jmp   r1 /* return */

d2820 115
a2934 106
ASGLOBAL(m197_setup_phase_two)
   /***************** REGISTER STATUS BLOCK ***********************\
   * SR0: saved return address to calling exception handler        *
   * SR1: saved copy of exception-time register now holding FLAGS  *
   * SR2: free                                                     *
   * SR3: saved TMP                                                *
   * r1:  return address to calling exception handler              *
   * TMP: possibly revised SSBR                                    *
   * TMP2: free                                                    *
   * TMP3: free                                                    *
   * FLAGS: CPU status flags                                       *
   * r31: our exception frame                                      *
   *    Valid in the exception frame:                              *
   *   Exception-time r1, r31, FLAGS.                              *
   *   Exception-time TMP2, TMP3.                                  *
   *   Exception-time espr, sfip, snip, sxip.                      *
   *   Exception number (EF_VECTOR).                               *
   *   Dmt0                                                        *
   *   Other data pipeline control registers, if appropriate.      *
   *   FPU control registers, if appropriate.                      *
   *   Exception SR3, if appropriate.                              *
   ***************************************************             *
   * immediate goal:                                               *
   *   restore the system to the exception-time state (except      *
   * SR3 will be OUR stack pointer) so that we may resart the FPU. *
   \***************************************************************/
   /*stcr   r1, SR0*/      /* save return address */
   
   RESTORE_TMP2      /* done with extra temp regs */
   RESTORE_TMP3      /* done with extra temp regs */
   
   ldcr  TMP,  PSR
   clr   TMP,  TMP,  1<PSR_FPU_DISABLE_BIT>    /* enable the FPU */
   clr   TMP,  TMP,  1<PSR_SHADOW_FREEZE_BIT>  /* also enable shadowing */
   stcr  TMP,  EPSR

   or.u  TMP,  r0,   hi16(m197_fpu_enable)
   or    TMP,  TMP,  lo16(m197_fpu_enable)
   stcr  TMP,  EXIP      /* jump to here fpu_enable */
   addu  TMP,  TMP,  4
   stcr  TMP,  ENIP      /* and then continue after that */
   
   set   FLAGS, FLAGS, 1<FLAG_ENABLING_FPU> /* note what we're doing.*/
   xcr   FLAGS, FLAGS, SR1
   st    r1,   r31,  REG_OFF(EF_RET) /* save the return address */
   ld    r1,   r31,  GENREG_OFF(1)    /* get original r1 */

   xcr   TMP,  r31,  SR3   /* TMP now restored. R31 now saved in SR3 */
   ld    r31,  r31,  GENREG_OFF(31) /* get original r31 */

   /***************** REGISTER STATUS BLOCK ***********************\
   * SR0: current thread                                           *
   * SR1: CPU flags                                                *
   * SR2: free                                                     *
   * SR3: pointer to our exception frame (our stack pointer)       *
   * r1 through r31: original exception-time values                *
   *                                                               *
   * Valid in the exception frame:                                 *
   *   Exception-time FLAGS.                                       *
   *   Exception-time espr, sfip, snip, sxip.                      *
   *   Exception number (EF_VECTOR).                               *
   *   Dmt0                                                        *
   *   Other data pipeline control registers, if appropriate.      *
   *   FPU control registers, if appropriate.                      *
   *   Exception SR3, if appropriate.                              *
   *   Held temporarly in the exception frame:                     *
   *   Return address to the calling excption handler.             *
   ***************************************************             *
   * immediate goal:                                               *
   *   Do an RTE to restart the fpu and jump to "fpu_enable"       *
   *   Another exception (or exceptions) may be raised in          *
   *   this, which is why FLAG_ENABLING_FPU is set in SR1.         *
   \***************************************************************/
   NOP
   RTE   /* jumps to "fpu_enable" on the next line to enable the FPU. */

ASGLOBAL(m197_fpu_enable)
   FLUSH_PIPELINE
   xcr   TMP,  TMP,  SR3               /* get E.F. pointer */
   st.d  r30,  TMP,  GENREG_OFF(30)    /* save previous r30, r31 */
   or    r31,  TMP,  r0                /* transfer E.F. pointer to r31 */
   ld    TMP,  r31,  REG_OFF(EF_SR3)   /* get previous SR3; maybe important*/

   /* make sure that the FLAG_ENABLING_FPU bit is off */
   xcr   FLAGS,FLAGS,SR1
   clr   FLAGS,FLAGS,1<FLAG_ENABLING_FPU>
   xcr   FLAGS,FLAGS,SR1

   xcr   TMP,  TMP,  SR3       /* replace TMP, SR3 */

   /* now save all regs to the exception frame. */
   st.d  r0 ,  r31,  GENREG_OFF(0)
   st.d  r2 ,  r31,  GENREG_OFF(2)
   st.d  r4 ,  r31,  GENREG_OFF(4)
   st.d  r6 ,  r31,  GENREG_OFF(6)
   st.d  r8 ,  r31,  GENREG_OFF(8)
   st.d  r10,  r31,  GENREG_OFF(10)
   st.d  r12,  r31,  GENREG_OFF(12)
   st.d  r14,  r31,  GENREG_OFF(14)
   st.d  r16,  r31,  GENREG_OFF(16)
   st.d  r18,  r31,  GENREG_OFF(18)
   st.d  r20,  r31,  GENREG_OFF(20)
   st.d  r22,  r31,  GENREG_OFF(22)
   st.d  r24,  r31,  GENREG_OFF(24)
   st.d  r26,  r31,  GENREG_OFF(26)
   st.d  r28,  r31,  GENREG_OFF(28)
d2936 4
a2939 4
   /* mark beginning of frame with notable value */
   or.u  r20,  r0,   hi16(0x12345678)
   or    r20,  r20,  lo16(0x12345678)
   st    r20,  r31,  GENREG_OFF(0)
d2941 39
a2979 39

   /***************** REGISTER STATUS BLOCK ***********************\
   * SR0: current thread                                           *
   * SR1: free                                                     *
   * SR2: free                                                     *
   * SR3: previous exception-time SR3                              *
   * r1: return address to the calling exception handler           *
   * r2 through r30: free                                          *
   * r31: our exception frame                                      *
   *                                                               *
   * Valid in the exception frame:                                 *
   *   Exception-time r0 through r31.                              *
   *   Exception-time FLAGS.                                       *
   *   Exception-time espr, sfip, snip, sxip.                      *
   *   Exception number (EF_VECTOR).                               *
   *   Dmt0                                                        *
   *   Other data pipeline control registers, if appropriate.      *
   *   FPU control registers, if appropriate.                      *
   *   Exception SR3, if appropriate.                              *
   ***************************************************             *
   * immediate goal:                                               *
   *   Pick up a stack if we came in from user mode. Put           *
   *       A copy of the exception frame pointer into r30          *
   *       bump the stack a doubleword and write the exception     *
   *       frame pointer.                                          *
   *   if not an interrupt exception,                              *
   *       Turn on interrupts and service any outstanding          *
   *       data access exceptions.                                 *
   *   Return to calling exception handler to                      *
   *   service the exception.                                      *
   \***************************************************************/

   /*
    * If it's not the interrupt exception, enable interrupts and
    * take care of any data access exceptions......
    */
   or    r30,  r0,   r31              /* get a copy of the e.f. pointer */
   ld    r2,   r31,  REG_OFF(EF_EPSR)
   bb1   PSR_SUPERVISOR_MODE_BIT, r2, 1f  /* If in kernel mode */
d2986 6
a2991 6
   ld    r3,   r31,  REG_OFF(EF_VECTOR)
   cmp   r3,   r3,   1      /* is interrupt ? */
   bb0   eq,   r3,   2f
   or.u  r31,  r0,   hi16(_intstack_end)   /* swith to int stack */
   or    r31,  r31,  lo16(_intstack_end)
   br    3f
d2994 4
a2997 4
   or.u  r31,  r0,   hi16(_kstack)
   ld    r31,  r31,  lo16(_kstack)
   addu  r31,  r31,  USIZE        /* point at proper end */
   br    3f
d3000 14
a3013 14
   ld    r3,   r31,  REG_OFF(EF_VECTOR)
   cmp   r3,   r3,   1       /* is interrupt ? */
   bb0   eq,   r3,   3f      /* no, we will stay on kern stack */
   or.u  r31,  r0,   hi16(_intstack_end)   /* swith to int stack */
   or    r31,  r31,  lo16(_intstack_end)
#endif /* INTSTACK */
   /* This label is here for debugging */
m197_exception_handler_has_ksp:  global m197_exception_handler_has_ksp
3: /*
      here - r30 holds a pointer to the exception frame.
      r31 is a pointer to the kernel stack/interrupt stack.
    */
   subu  r31,  r31,  8  /* make some breathing space */
   st    r30,  r31,  0  /* store frame pointer on the stack */
d3015 1
a3015 1
   st    r30,  r31,  4  /* store it again for the debugger to recognize */
d3018 5
a3022 5
   ld    r2,   r30,  REG_OFF(EF_VECTOR)
   bcnd.n eq0, r2,   m197_return_to_calling_exception_handler  /* is error */
   ld    r14,  r30,  REG_OFF(EF_RET)
   cmp   r3,   r2,   1 /* interrupt is exception #1 ;Is an interrupt? */
   bb1.n eq,   r3,   m197_return_to_calling_exception_handler /* skip if so */
d3025 2
a3026 2
   cmp   r3,   r2,   130 /* DDB break exception */
   bb1.n eq,   r3,   m197_return_to_calling_exception_handler
d3028 2
a3029 2
   cmp   r3,   r2,   132 /* DDB entry exception */
   bb1.n eq,   r3,   m197_return_to_calling_exception_handler
d3032 3
a3034 3
   ldcr  r2,   PSR
   clr   r2,   r2,   1<PSR_INTERRUPT_DISABLE_BIT>   /* enable interrupts */
   stcr  r2,   PSR
d3036 4
a3039 1
   FLUSH_PIPELINE
d3041 2
d3044 3
a3046 6
   /* service any outstanding data pipeline stuff
      - check dsr... anything outstanding?*/

   ld    r3,   r30,  REG_OFF(EF_DSR)
   cmp	 r3,   r3,   0
   bb1   eq,   r3,   m197_return_to_calling_exception_handler
d3049 2
a3050 2
   r30 can be clobbered by calls. So stuff its value into a
   preserved register, say r15. R14 is in use (see return_to_... below).
d3052 5
a3056 1
   or    r15,  r0,   r30
d3058 2
a3059 1
   CALL(_C_LABEL(trap197), T_DATAFLT, r15)
d3061 2
a3062 8
/*   restore it... */
   or    r30,  r0,   r15

   /* clear the dsr word in the E.F */
   st    r0,   r30,  REG_OFF(EF_DSR)

ASGLOBAL(m197_return_to_calling_exception_handler)
   jmp   r14 /* loaded above */
d3064 7
@


1.25.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.26 2001/12/22 17:57:10 smurph Exp $   */
d239 2
a240 1
#define INTSTACK	0   /* To make interupts use their own stack */
d252 1
a252 1
	bsr  _C_LABEL(panic)
a255 67
#define OFF_VEC		0
#define OFF_EPSR	4
#define OFF_EXIP	8
#define OFF_ENIP	12
#define OFF_DSR		16
#define OFF_DLAR	20
#define OFF_DPAR	24
#define OFF_ISR		28
#define OFF_ILAR	32
#define OFF_IPAR	36
#define OFF_TMP		40


#define SAVE_CTX				; \
	stcr	r31, SRX			; \
	or.u	r31, r0,  hi16(_save_frame)	; \
	or	r31, r31, lo16(_save_frame)	; \
	/* save old R31 and other R registers */; \
	st.d	r0 , r31, GENREG_OFF(0)		; \
	st.d	r2 , r31, GENREG_OFF(2)		; \
	st.d	r4 , r31, GENREG_OFF(4)		; \
	st.d	r6 , r31, GENREG_OFF(6)		; \
	st.d	r8 , r31, GENREG_OFF(8)		; \
	st.d	r10, r31, GENREG_OFF(10)	; \
	st.d	r12, r31, GENREG_OFF(12)	; \
	st.d	r14, r31, GENREG_OFF(14)	; \
	st.d	r16, r31, GENREG_OFF(16)	; \
	st.d	r18, r31, GENREG_OFF(18)	; \
	st.d	r20, r31, GENREG_OFF(20)	; \
	st.d	r22, r31, GENREG_OFF(22)	; \
	st.d	r24, r31, GENREG_OFF(24)	; \
	st.d	r26, r31, GENREG_OFF(26)	; \
	st.d	r28, r31, GENREG_OFF(28)	; \
	st	r30, r31, GENREG_OFF(30)	; \
	ldcr	r1,  SRX			; \
	st	r1,  r31, GENREG_OFF(31)	; \
	ldcr	r1,  EPSR			; \
	ldcr	r2,  EXIP			; \
	ldcr	r3,  ENIP			; \
	st	r1,  r31, REG_OFF(EF_EPSR)	; \
	st	r2,  r31, REG_OFF(EF_EXIP)	; \
	st	r3,  r31, REG_OFF(EF_ENIP)	; \
	ldcr	r1,  DSR			; \
	ldcr	r2,  DLAR			; \
	ldcr	r3,  DPAR			; \
	st	r1,  r31, REG_OFF(EF_DSR)	; \
	st	r2,  r31, REG_OFF(EF_DLAR)	; \
	st	r3,  r31, REG_OFF(EF_DPAR)	; \
	ldcr	r1,  ISR			; \
	ldcr	r2,  ILAR			; \
	ldcr	r3,  IPAR			; \
	st	r1,  r31, REG_OFF(EF_ISR)	; \
	st	r2,  r31, REG_OFF(EF_ILAR)	; \
	st	r3,  r31, REG_OFF(EF_IPAR)	; \
	ldcr	r1, DSAP			; \
	ldcr	r2, DUAP			; \
	st	r1,  r31, REG_OFF(EF_DSAP)	; \
	st	r2,  r31, REG_OFF(EF_DUAP)	; \
	ldcr	r1, ISAP			; \
	ldcr	r2, IUAP			; \
	st	r1,  r31, REG_OFF(EF_ISAP)	; \
	st	r2,  r31, REG_OFF(EF_IUAP)	; \
	/* Restore r1, r2, r3, and r31	*/	; \
	ld	r1 , r31, GENREG_OFF(1)		; \
	ld.d	r2 , r31, GENREG_OFF(2)		; \
	ld	r31, r31, GENREG_OFF(31)

a324 1
	SAVE_CTX					; \
d327 1
d329 1
a329 1
	stcr    r1, SR2   /* r1 now free */		; \
d331 4
a334 4
1:	ldcr    r1, EPSR 				; \
	bb0.n   PSR_SUPERVISOR_MODE_BIT, r1, 1f 	; \
	clr     FLAGS, FLAGS, 1<FLAG_FROM_KERNEL> 	; \
	set     FLAGS, FLAGS, 1<FLAG_FROM_KERNEL>	; \
d337 1
a337 1
	1:	bsr	m88110_setup_phase_one		; \
d345 1
a345 1
	bsr	m88110_setup_phase_two			; \
d357 2
a358 2
#define M88110_Data_Precheck \
   bb1.n   FLAG_IGNORE_DATA_EXCEPTION, FLAGS, m88110_ignore_data_exception
d369 1
a370 2
GLOBAL(eh_debug)	word 0x00000000
   
d428 3
a430 3
	PREP("unknown", 0, DEBUG_UNKNOWN_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_UNKNOWNFLT, r30)
	DONE(DEBUG_UNKNOWN_BIT)
d434 5
a438 5
	PREP("interrupt", 1, DEBUG_INTERRUPT_BIT, No_SSBR_Stuff, No_Precheck)
	/* interrupt_func is set in mvme_bootstrap() */
	CALL(_C_LABEL(m88100_trap), T_INT, r30)
	/*CALLP(_interrupt_func, 1, r30) */
	DONE(DEBUG_INTERRUPT_BIT)
d442 3
a444 3
	PREP("inst", 2, DEBUG_INSTRUCTION_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_INSTFLT, r30)
	DONE(DEBUG_INSTRUCTION_BIT)
d451 2
a452 2
	PREP("data", 3, DEBUG_DATA_BIT, No_SSBR_Stuff, Data_Precheck)
	DONE(DEBUG_DATA_BIT)
d456 3
a458 3
	PREP("misalign", 4, DEBUG_MISALIGN_BIT, Clear_SSBR_Dest, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_MISALGNFLT, r30)
	DONE(DEBUG_MISALIGN_BIT)
d462 3
a464 3
	PREP("unimp", 5, DEBUG_UNIMPLEMENTED_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_ILLFLT, r30)
	DONE(DEBUG_UNIMPLEMENTED_BIT)
d472 8
a479 8
	stcr    r1, SR2    /* hold r1 for a moment */
	ldcr    r1, SXIP   /* look at the sxip... valid bit set? */
	bb1.n   RTE_VALID_BIT, r1, 1f /*skip over return if a valid exception*/
	ldcr    r1, SR2    /* restore r1 */
	RTE
1:	PREP("privilege", 6, DEBUG_PRIVILEGE_BIT, Clear_SSBR_Dest, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_PRIVINFLT, r30) 
	DONE(DEBUG_PRIVILEGE_BIT)
d486 3
a488 3
	PREP("bounds", 7, DEBUG_BOUNDS_BIT, Clear_SSBR_Dest, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_BNDFLT, r30)
	DONE(DEBUG_BOUNDS_BIT)
d492 3
a494 3
	PREP("divide", 8, DEBUG_DIVIDE_BIT, Clear_SSBR_Dest, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_ZERODIV, r30)
	DONE(DEBUG_DIVIDE_BIT)
d498 3
a500 3
	PREP("overflow", 9, DEBUG_OVERFLOW_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_OVFFLT, r30)
	DONE(DEBUG_OVERFLOW_BIT)
d505 3
a507 3
	PREP("FPU precise", 114, DEBUG_FPp_BIT, FPp_SSBR_STUFF, No_Precheck)
	CALL(_m88100_Xfp_precise, r0, r30) /* call fp_precise(??, exception_frame)*/
	DONE(DEBUG_FPp_BIT)
d512 3
a514 3
	PREP("FPU imprecise", 115, DEBUG_FPi_BIT, FPi_SSBR_STUFF, No_Precheck)
	CALL(_Xfp_imprecise, r0, r30) /*call fp_imprecise(??,exception_frame)*/
	DONE(DEBUG_FPi_BIT)
d518 4
a521 4
	PREP("syscall", 128, DEBUG_SYSCALL_BIT, No_SSBR_Stuff, No_Precheck)
	ld   r13, r30, GENREG_OFF(13)
	CALL(_m88100_syscall, r13, r30) /* system call no. is in r13 */
	DONE(DEBUG_SYSCALL_BIT)
d525 4
a528 4
	PREP("bugsyscall", 496, DEBUG_BUGCALL_BIT, No_SSBR_Stuff, No_Precheck)
	ld   r9,  r30, GENREG_OFF(9)
	CALL(_bugsyscall, r9, r30)   /* system call no. is in r9 */
	DONE(DEBUG_BUGCALL_BIT)
d531 3
a533 3
	PREP("sigsys", 0, DEBUG_SIGSYS_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_SIGSYS, r30)
	DONE(DEBUG_SIGSYS_BIT)
d536 3
a538 3
	PREP("sigtrap", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_SIGTRAP, r30)
	DONE(DEBUG_SIGTRAP_BIT)
d541 3
a543 3
	PREP("stepbpt", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_STEPBPT, r30)
	DONE(DEBUG_SIGTRAP_BIT)
d546 3
a548 3
	PREP("userbpt", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_USERBPT, r30)
	DONE(DEBUG_SIGTRAP_BIT)
d551 13
a563 14
ASGLOBAL(break)
	PREP("break", 130, DEBUG_BREAK_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_KDB_BREAK, r30)
	DONE(DEBUG_BREAK_BIT)

ASGLOBAL(trace)
	PREP("trace", 131, DEBUG_TRACE_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_KDB_TRACE, r30)
	DONE(DEBUG_TRACE_BIT)

GLOBAL(entry)
	PREP("kdb", 132, DEBUG_KDB_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_KDB_ENTRY, r30)
	DONE(DEBUG_KDB_BIT)
d566 12
a577 14
ASGLOBAL(break)
	PREP("break", 130, DEBUG_BREAK_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_UNKNOWNFLT, r30)
	DONE(DEBUG_BREAK_BIT)

ASGLOBAL(trace)
	PREP("trace", 131, DEBUG_TRACE_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_UNKNOWNFLT, r30)
	DONE(DEBUG_TRACE_BIT)

GLOBAL(entry)
	PREP("unknown", 132, DEBUG_UNKNOWN_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_UNKNOWNFLT, r30)
	DONE(DEBUG_KDB_BIT)
d688 1
a688 1
	st	r11, r31,   REG_OFF(EF_MASK) /* put in EF_MASK for regdump */ 
d710 1
a710 1
        CALL(_C_LABEL(error_fault), r30, r30)
d848 1
a848 1
	CALL(_C_LABEL(error_reset), r30, r30)
d900 1
a900 1
ASGLOBAL(m88110_ignore_data_exception)
d903 1
a903 1
	*  SR1: previous FLAGS reg                             *
d905 1
a905 1
	*  SR3: must preserve                                  *
d913 1
a913 1
	 * We just want to jump to "m88110_badaddr__return_nonzero" below.
d920 3
a922 3
	or.u	r2, r0, hi16(m88110_badaddr__return_nonzero)
	or	r2, r2, lo16(m88110_badaddr__return_nonzero)
	stcr	r2, EXIP   /* Make it the next instruction to execute */
d924 1
a924 1
	/* the following jumps to "m88110_badaddr__return_nonzero" below */ 
d952 4
a955 4
	/*
	 * Disable interrupts ... don't want a context switch while we're
	 * doing this! Also, save the old PSR in R8 to restore later.
	 */
d1024 1
a1024 1
	bsr   _C_LABEL(printf)
d1027 1
a1027 1
	bsr   _C_LABEL(panic)
a1050 12
ASGLOBAL(m88110_badaddr__return_nonzero)
	/* 
	 * On mc88110, we possibly took an exception 
	 * and we have to clear DSR after the rte
	 * instruction clears the EFRZ bit in 
	 * the PSR. 
	 */
	stcr r0, DSR	/* Clear DSR reg on mc88110 */
	stcr r0, DLAR	/* Clear DLAR reg on mc88110 */
	br.n badaddr__return_nonzero
	stcr r0, DPAR	/* Clear DPAR reg on mc88110 */

d1060 16
a1075 16
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread (if any, null if not)                     *
	* SR1: saved copy of exception-time register now holding FLAGS  *
	* SR2: saved copy of exception-time r1                          *
	* SR3: must be preserved .. may be the exception-time stack     *
	* r1: return address to calling exception handler               *
	* FLAGS: CPU status flags                                       *
	***************************************************             *
	* immediate goal:                                               *
	*    Decide where we're going to put the exception frame.       *
	*   Might be at the end of R31, SR3, or the thread's            *
	*   pcb.                                                        *
	\***************************************************************/
	
	/* Check if we are coming in from a FPU restart exception.
	   If so, the pcb will be in SR3 */
d1083 1
a1083 1
	/* are we coming in from user mode? If so, pick up thread pcb */
d1086 1
a1086 1
	/* Interrupt in kernel mode, not FPU restart */
d1088 12
a1099 12
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread (if any, null if not)                     *
	* SR1: saved copy of exception-time register now holding FLAGS  *
	* SR2: return address to the calling exception handler          *
	* SR3: must be preserved; may be important for other exceptions *
	* FLAGS: CPU status flags                                       *
	***************************************************             *
	* immediate goal:                                               *
	*   We're already on the kernel stack, but not having           *
	*   needed to use SR3. We can just make room on the             *
	*    stack (r31) for our exception frame.                       *
	\***************************************************************/
d1113 23
a1135 23
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread (if any, null if not)                     *
	* SR1: saved copy of exception-time register now holding FLAGS  *
	* SR2: return address to the calling exception handler          *
	* SR3: must be preserved; exception-time stack pointer          *
	* FLAGS: CPU status flags                                       *
	***************************************************             *
	* immediate goal:                                               *
	*   An exception occured while enabling the FPU. Since r31      *
	*   is the user's r31 while enabling the FPU, we had put        *
	*   our pcb pointer into SR3, so make room from                 *
	*   there for our stack pointer.                                *
	*       We need to check if SR3 is the old stack pointer or the *
	*       pointer off to the user pcb. If it pointing to the user *
	*       pcb, we need to pick up the kernel stack. Otherwise     *
	*       we need to allocate a frame upon it.                    *
	*       We look at the EPSR to see if it was from user mode     *
	*       Unfortunately, we have no registers free at the moment  *
	*       But we know register 0 in the pcb frame will always be  *
	*       zero, so we can use it as scratch storage.              *
	*                                                               *
	*                                                               *
	\***************************************************************/
d1141 1
a1141 1
	/* we were in kernel mode - dump frame upon the stack */
d1154 4
a1157 4
	/* we took an exception while restarting the FPU from user space.
	 * Consequently, we never picked up a stack. Do so now.
	 * R1 is currently free (saved in the exception frame pointed at by
	 * r30) */
d1172 12
a1183 12
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                          *
	* SR1: saved copy of exception-time register now holding FLAGS *
	* SR2: return address to the calling exception handler         *
	* SR3: free                                                    *
	* FLAGS: CPU status flags                                      *
	***************************************************            *
	* immediate goal:                                              *
	*    Since we're servicing an exception from user mode, we     *
	*   know that SR3 is free.  We use it to free up a temp.       *
	*   register to be used in getting the thread's pcb            *
	\***************************************************************/
d1186 1
a1186 1
	/* switch to the thread's kernel stack. */
d1194 1
a1194 1
	/*FALLTHROUGH */
d1395 19
a1413 19
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                          *
	* SR1: saved copy of exception-time register now holding FLAGS *
	* SR2: return address to the calling exception handler         *
	* SR3: saved TMP                                               *
	* r1:  free                                                    *
	* TMP: possibly revised SSBR                                   *
	* TMP2: free                                                   *
	* TMP3: free                                                   *
	* FLAGS: CPU status flags                                      *
	* r31: exception frame                                         *
	*    Valid in the exception frame:                             *
	*   Exception-time r1, r31, FLAGS.                             *
	*   Exception-time TMP2, TMP3.                                 *
	*   Exception-time espr, sfip, snip, sxip.                     *
	*   Dmt0.                                                      *
	*   Other data pipeline control registers, if appropriate.     *
	*   Exception SR3, if appropriate.                             *
	\***************************************************************/
d1423 9
a1431 9
	/*
	 * Clear floatingpont-imprecise ssbr bits.
	 * Also, save appropriate FPU control registers to the E.F.
	 *
	 *  r1:  return address to calling exception handler
	 *  TMP : (possibly) revised ssbr
	 *  TMP2 : free
	 *  TMP3 : free
	 */
d1447 4
a1450 4
	/*
	 * We only need clear the bit in the SSBR for the
	 * 2nd reg of a double result [see section 6.8.5]
	 */
d1466 28
a1493 28
	/*
	 * Clear floating pont precise ssbr bits.
	 * Also, save appropriate FPU control registers to the E.F.
	 *
	 *  r1:  return address to calling exception handler
	 *  TMP : (possibly) revised ssbr
	 *  TMP2 : free
	 *  TMP3 : free
	 */
	fldcr TMP2, FPSR
	fldcr TMP3, FPCR
	st    TMP2, r31,  REG_OFF(EF_FPSR)
	st    TMP3, r31,  REG_OFF(EF_FPCR)
	
	fldcr TMP3, FPECR
	st    TMP3, r31,  REG_OFF(EF_FPECR)
	fldcr TMP2, FPHS1
	fldcr TMP3, FPHS2
	st    TMP2, r31,  REG_OFF(EF_FPHS1)
	st    TMP3, r31,  REG_OFF(EF_FPHS2)
	
	fldcr TMP2, FPLS1
	fldcr TMP3, FPLS2
	st    TMP2, r31,  REG_OFF(EF_FPLS1)
	st    TMP3, r31,  REG_OFF(EF_FPLS2)
	
	fldcr TMP2, FPPT
	st    TMP2, r31,  REG_OFF(EF_FPPT)
d1497 5
a1501 5
	bb1.n FPPT_SIZE_BIT, TMP2, 2f
	extu  TMP3, TMP2, 5<0> /* get FP operation dest reg */
	br.n  3f
	set   TMP3, TMP3, 1<5> /* set size=1 -- clear one bit for "float" */
2:	set   TMP3, TMP3, 1<6> /* set size=2 -- clear two bit for "double" */ 
d1510 32
a1541 32
	/*
	 * There are various cases where an exception can leave the
	 * destination register's bit in the SB set.
	 * Examples:
	 *   misaligned or privilege exception on a LD or XMEM
	 *   DIV or DIVU by zero.
	 *
	 * I think that if the instruction is LD.D, then two bits must
	 * be cleared.
	 *
	 * Even though there are a number of instructions/exception
	 * combinations that could fire this code up, it's only required
	 * to be run for the above cases.  However, I don't think it'll
	 * ever be a problem to run this in other cases (ST instructions,
	 * for example), so I don't bother checking.  If we had to check
	 * for every possible instruction, this code would be much larger.
	 *
	 * The only checking, then, is to see if it's a LD.D or not.
	 *
	 * At the moment....
	 *  r1:  return address to calling exception handler
	 *  TMP : (possibly) revised ssbr
	 *  TMP2 : free
	 *  TMP3 : free
	 */
	
	ldcr  TMP3, EPSR   /* going to check: user or system memory? */
	ldcr  TMP2, SXIP   /* get the instruction's address */
	bb1.n PSR_SUPERVISOR_MODE_BIT, TMP3, 2f
	clr   TMP2, TMP2, 2<0> /* get rid of valid and error bits. */
	
1:	/* user space load here */
d1543 6
a1548 6
	NOP
	ld.usr TMP2,TMP2, r0      /* get the instruction itself */
	NOP
	NOP
	NOP
	br    3f
d1550 2
a1551 2
	br.n  3f
	ld.usr TMP2,TMP2, r0      /* get the instruction itself */
d1554 40
a1593 2
2:	/* system space load here */
	ld    TMP2, TMP2, r0      /* get the instruction itself */
a1594 38
3:	/* now have the instruction..... */
	/*
	 * Now see if it's a double load
	 * There are three forms of double load [IMM16, scaled, unscaled],
	 * which can be checked by matching against two templates:
	 *          -- 77776666555544443333222211110000 --
	 *   if (((instruction & 11111100000000000000000000000000) ==
	 *             00010000000000000000000000000000) ;;
	 *       ((instruction & 11111100000000001111110011100000) ==
	 *             11110100000000000001000000000000))
	 *   {
	 *      It's a load double, so
	 *      clear two SSBR bits.
	 *   } else {
	 *      It's not a load double.
	 *      Must be a load single, xmem, or st
	 *      Thus, clear one SSBR bit.
	 *   }
	 */
	/* check the first pattern for ld.d */
	extu  TMP3, TMP2, 16<16>   /* get the upper 16 bits */
	mask  TMP3, TMP3, 0xFC00   /* apply the mask */
	cmp   TMP3, TMP3, 0x1000   /* if this is equal, it's a load double */
	bb1   eq,   TMP3, misaligned_double
	
	/* still could be -- check the second pattern for ld.d */
	/* look at the upper 16 bits first */
	extu  TMP3, TMP2, 16<16>   /* get the upper 16 bits */
	mask  TMP3, TMP3, 0xFC00   /* apply the mask */
	cmp   TMP3, TMP3, 0xF400   /* if equal, it might be a load double */
	bb1   ne,   TMP3, misaligned_single /* not equal, so must be single */
	
	/* now look at the lower 16 bits */
	extu  TMP3, TMP2, 16<0>    /* get the lower 16 bits */
	mask  TMP3, TMP3, 0xFCE0   /* apply the mask */
	cmp   TMP3, TMP3, 0x1000   /* if this is equal, it's a load double */
	bb1   eq,   TMP3, misaligned_double
	
d1596 3
a1598 3
	extu  TMP2, TMP2, 5<21>    /* get the destination register */
	br.n  1f
	set   TMP2, TMP2, 1<5>     /* set size=1 */
d1601 2
a1602 2
	extu  TMP2, TMP2, 5<21>    /* get the destination register */
	set   TMP2, TMP2, 1<6>     /* set size=2 -- clear two bit for "ld.d" */
d1604 2
a1605 2
1:	jmp.n   r1
	clr   TMP,  TMP,  TMP2     /* clear bit(s) in ssbr. */
d1613 32
a1644 32
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: saved return address to calling exception handler        *
	* SR1: saved copy of exception-time register now holding FLAGS  *
	* SR2: free                                                     *
	* SR3: saved TMP                                                *
	* r1:  return address to calling exception handler              *
	* TMP: possibly revised SSBR                                    *
	* TMP2: free                                                    *
	* TMP3: free                                                    *
	* FLAGS: CPU status flags                                       *
	* r31: our exception frame                                      *
	*    Valid in the exception frame:                              *
	*   Exception-time r1, r31, FLAGS.                              *
	*   Exception-time TMP2, TMP3.                                  *
	*   Exception-time espr, sfip, snip, sxip.                      *
	*   Exception number (EF_VECTOR).                               *
	*   Dmt0                                                        *
	*   Other data pipeline control registers, if appropriate.      *
	*   FPU control registers, if appropriate.                      *
	*   Exception SR3, if appropriate.                              *
	***************************************************             *
	* immediate goal:                                               *
	*   restore the system to the exception-time state (except      *
	* SR3 will be OUR stack pointer) so that we may resart the FPU. *
	\***************************************************************/
	/*stcr   r1, SR0*/      /* save return address */
	
	stcr  TMP,  SSBR   /* done with SSBR, TMP now free */
	RESTORE_TMP2      /* done with extra temp regs */
	RESTORE_TMP3      /* done with extra temp regs */
	
	/* Get the current PSR and modify for the rte to enable the FPU */
d1646 11
a1656 11
	ldcr  TMP,  PSR
	clr   TMP,  TMP,  1<PSR_FPU_DISABLE_BIT>    /* enable the FPU */
	clr   TMP,  TMP,  1<PSR_SHADOW_FREEZE_BIT>  /* also enable shadowing */
	stcr  TMP,  EPSR
	
	/* the "+2" below is to set the VALID_BIT */
	or.u  TMP,  r0,   hi16(fpu_enable +2)
	or    TMP,  TMP,  lo16(fpu_enable +2)
	stcr  TMP,  SNIP      /* jump to here fpu_enable */
	addu  TMP,  TMP,  4
	stcr  TMP,  SFIP      /* and then continue after that */
d1658 10
a1667 10
	ldcr  TMP,  PSR
	or.u  TMP,  TMP,  0x8000    /* set supervisor mode */
	and   TMP,  TMP,  0xfff7    /* also enable shadowing */
	stcr  TMP,  EPSR
	stcr  r0,   SXIP       /* clear valid bit */
	stcr  r0,   SNIP       /* clear valid bit */
	or.u  TMP,  r0,   hi16(fpu_enable)
	or    TMP,  TMP,  lo16(fpu_enable)
	or    TMP,  TMP,  0x2 /* set the VALID_BIT and clear Exception bit */
	stcr  TMP,  SFIP      /* jump to here fpu_enable */
d1671 34
a1704 34
	set   FLAGS, FLAGS, 1<FLAG_ENABLING_FPU> /* note what we're doing.*/
	xcr   FLAGS, FLAGS, SR1
	st    r1,   r31,  REG_OFF(EF_RET) /* save the return address */
	ld    r1,   r31,  GENREG_OFF(1)    /* get original r1 */
	
	xcr   TMP,  r31,  SR3   /* TMP now restored. R31 now saved in SR3 */
	ld    r31,  r31,  GENREG_OFF(31) /* get original r31 */
	
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                           *
	* SR1: CPU flags                                                *
	* SR2: free                                                     *
	* SR3: pointer to our exception frame (our stack pointer)       *
	* r1 through r31: original exception-time values                *
	*                                                               *
	* Valid in the exception frame:                                 *
	*   Exception-time FLAGS.                                       *
	*   Exception-time espr, sfip, snip, sxip.                      *
	*   Exception number (EF_VECTOR).                               *
	*   Dmt0                                                        *
	*   Other data pipeline control registers, if appropriate.      *
	*   FPU control registers, if appropriate.                      *
	*   Exception SR3, if appropriate.                              *
	*   Held temporarly in the exception frame:                     *
	*   Return address to the calling excption handler.             *
	***************************************************             *
	* immediate goal:                                               *
	*   Do an RTE to restart the fpu and jump to "fpu_enable"       *
	*   Another exception (or exceptions) may be raised in          *
	*   this, which is why FLAG_ENABLING_FPU is set in SR1.         *
	\***************************************************************/
	
	RTE   /* jumps to "fpu_enable" on the next line to enable the FPU. */
	
d1706 29
a1734 29
	FLUSH_PIPELINE
	xcr   TMP,  TMP,  SR3               /* get E.F. pointer */
	st.d  r30,  TMP,  GENREG_OFF(30)    /* save previous r30, r31 */
	or    r31,  TMP,  r0                /* transfer E.F. pointer to r31 */
	ld    TMP,  r31,  REG_OFF(EF_SR3)   /* get previous SR3; maybe important*/
	
	/* make sure that the FLAG_ENABLING_FPU bit is off */
	xcr   FLAGS,FLAGS,SR1
	clr   FLAGS,FLAGS,1<FLAG_ENABLING_FPU>
	xcr   FLAGS,FLAGS,SR1
	
	xcr   TMP,  TMP,  SR3       /* replace TMP, SR3 */
	
	/* now save all regs to the exception frame. */
	st.d  r0 ,  r31,  GENREG_OFF(0)
	st.d  r2 ,  r31,  GENREG_OFF(2)
	st.d  r4 ,  r31,  GENREG_OFF(4)
	st.d  r6 ,  r31,  GENREG_OFF(6)
	st.d  r8 ,  r31,  GENREG_OFF(8)
	st.d  r10,  r31,  GENREG_OFF(10)
	st.d  r12,  r31,  GENREG_OFF(12)
	st.d  r14,  r31,  GENREG_OFF(14)
	st.d  r16,  r31,  GENREG_OFF(16)
	st.d  r18,  r31,  GENREG_OFF(18)
	st.d  r20,  r31,  GENREG_OFF(20)
	st.d  r22,  r31,  GENREG_OFF(22)
	st.d  r24,  r31,  GENREG_OFF(24)
	st.d  r26,  r31,  GENREG_OFF(26)
	st.d  r28,  r31,  GENREG_OFF(28)
d1736 4
a1739 4
	/* mark beginning of frame with notable value */
	or.u  r20,  r0,   hi16(0x12345678)
	or    r20,  r20,  lo16(0x12345678)
	st    r20,  r31,  GENREG_OFF(0)
d1741 36
a1776 36
	
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                           *
	* SR1: free                                                     *
	* SR2: free                                                     *
	* SR3: previous exception-time SR3                              *
	* r1: return address to the calling exception handler           *
	* r2 through r30: free                                          *
	* r31: our exception frame                                      *
	*                                                               *
	* Valid in the exception frame:                                 *
	*   Exception-time r0 through r31.                              *
	*   Exception-time FLAGS.                                       *
	*   Exception-time espr, sfip, snip, sxip.                      *
	*   Exception number (EF_VECTOR).                               *
	*   Dmt0                                                        *
	*   Other data pipeline control registers, if appropriate.      *
	*   FPU control registers, if appropriate.                      *
	*   Exception SR3, if appropriate.                              *
	***************************************************             *
	* immediate goal:                                               *
	*   Pick up a stack if we came in from user mode. Put           *
	*       A copy of the exception frame pointer into r30          *
	*       bump the stack a doubleword and write the exception     *
	*       frame pointer.                                          *
	*   if not an interrupt exception,                              *
	*       Turn on interrupts and service any outstanding          *
	*       data access exceptions.                                 *
	*   Return to calling exception handler to                      *
	*   service the exception.                                      *
	\***************************************************************/
	
	/*
	 * If it's not the interrupt exception, enable interrupts and
	 * take care of any data access exceptions......
	 */
d1778 2
a1779 4
	/*
	 * If interrupt exception, switch to interrupt stack if not
	 * already there. Else, switch to kernel stack.
	 */
d1781 4
a1784 3
	or    r30,  r0,   r31		/* get a copy of the e.f. pointer */ 
	ld    r2,   r31,  REG_OFF(EF_EPSR)
	bb1   PSR_SUPERVISOR_MODE_BIT, r2, 1f  /* If in kernel mode */
d1787 6
a1792 6
	ld    r3,   r31,  REG_OFF(EF_VECTOR)
	cmp   r3,   r3,   1      /* is interrupt ? */
	bb0   eq,   r3,   2f
	or.u  r31,  r0,   hi16(_intstack_end)   /* swith to int stack */
	or    r31,  r31,  lo16(_intstack_end)
	br    3f
d1795 4
a1798 4
	or.u  r31,  r0,   hi16(_kstack)
	ld    r31,  r31,  lo16(_kstack)
	addu  r31,  r31,  USIZE        /* point at proper end */
	br    3f
d1801 5
a1805 5
	ld    r3,   r31,  REG_OFF(EF_VECTOR)
	cmp   r3,   r3,   1       /* is interrupt ? */
	bb0   eq,   r3,   3f      /* no, we will stay on kern stack */
	or.u  r31,  r0,   hi16(_intstack_end)   /* swith to int stack */
	or    r31,  r31,  lo16(_intstack_end)
d1807 1
a1807 1
	/* This label is here for debugging */
d1809 6
a1814 6
3:	/*
	 * here - r30 holds a pointer to the exception frame.
	 * r31 is a pointer to the kernel stack/interrupt stack.
	*/
	subu  r31,  r31,  8  /* make some breathing space */
	st    r30,  r31,  0  /* store frame pointer on the stack */
d1816 1
a1816 1
	st    r30,  r31,  4  /* store it again for the debugger to recognize */
d1819 5
a1823 5
	ld    r2,   r30,  REG_OFF(EF_VECTOR)
	bcnd.n eq0, r2,   return_to_calling_exception_handler  /* is error */
	ld    r14,  r30,  REG_OFF(EF_RET)
	cmp   r3,   r2,   1 /* interrupt is exception #1 ;Is an interrupt? */
	bb1.n eq,   r3,   return_to_calling_exception_handler /* skip if so */
d1826 5
a1830 4
	cmp   r3,   r2,   130 /* DDB break exception */
	bb1.n eq,   r3,   return_to_calling_exception_handler
	cmp   r3,   r2,   132 /* DDB entry exception */
	bb1.n eq,   r3,   return_to_calling_exception_handler
d1833 3
a1835 3
	ldcr  r2,   PSR
	clr   r2,   r2,   1<PSR_INTERRUPT_DISABLE_BIT>   /* enable interrupts */
	stcr  r2,   PSR
d1837 1
a1837 1
	FLUSH_PIPELINE
d1840 2
a1841 2
	/* service any outstanding data pipeline stuff
	   - check dmt0 anything outstanding?*/
d1843 2
a1844 2
	ld    r3,   r30,  REG_OFF(EF_DMT0)
	bb0   DMT_VALID_BIT, r3, return_to_calling_exception_handler
d1846 5
a1850 5
	/*
	  r30 can be clobbered by calls. So stuff its value into a
	  preserved register, say r15. R14 is in use (see return_to_... below). 
	 */
	or    r15,  r0,   r30
d1852 2
a1853 2
	CALL(_C_LABEL(m88100_trap), T_DATAFLT, r15)
	CALL(_data_access_emulation, r15, r0)
d1855 2
a1856 2
	/*   restore it... */
	or    r30,  r0,   r15
d1858 2
a1859 2
	/* clear the dmt0 word in the E.F */
	st    r0,   r30,  REG_OFF(EF_DMT0)
d1862 1
a1862 1
	jmp   r14 /* loaded above */
d1876 10
a1885 10
	ld	r1,r31,0	/* load func */
	ld	r2,r31,4 	/* load proc pointer */
	jsr.n	r1
	subu	r31,r31,40	/* create stack space for function */
	addu	r31,r31,48	/* stack space above + ksigframe */
	ld	r1, r31,0	/* load pc */
	ld	r2, r31,4	/* & proc pointer from switch frame */ 
	jsr.n	r1
	addu	r31,r31,8
	bsr	_C_LABEL(panic)
d1896 4
a1899 4
	ld	r3,r2,P_ADDR		/* p->p_addr */
	addu	r3,r3,PCB_USER_STATE	/* p->p_addr.u_pcb.user_state */
	st	r3,r31,0		/* put it on the stack */
	br	return_from_exception_handler
d1920 2
a1921 2
	or.u	r2, r0, hi16(_C_LABEL(cputyp))
	ld	r3, r2, lo16(_C_LABEL(cputyp))
d1923 1
a1923 1
	bb1	eq, r2, m88110_return_code        
d1926 1
d1933 4
a1936 4
	/*
	 * This might happen for non-interrupts  If the user sets DMT0
	 * in an exception handler.........
	 */
d1943 1
a1943 1
	CALL(_C_LABEL(db_printf), r4, r0)
d1953 9
a1961 9
	/*
	 * If it's the interrupt exception, enable interrupt.
	 * Take care of any data access exception...... 90/8/15 add by yama
	 */
	
	/*
	 * Is it ever possible to have interrupt exception while EPSR has
	 * it disabled? I don't think so.. XXX nivas
	 */
d1966 1
a1966 1
	/* if EPSR has interrupts disabled, skip also */
d1968 1
a1968 1
        bb1   PSR_INTERRUPT_DISABLE_BIT, r2, 1f		/* skip if disabled */
d1970 2
a1971 2
	clr   r2, r2, 1<PSR_INTERRUPT_DISABLE_BIT>	/* enable interrupts */
	FLUSH_PIPELINE
d1973 1
a1973 1
1:
d1977 8
a1984 7
	/*
	 * if there happens to be a data fault that hasn't been serviced yet,
	 * go off and service that...
	 */
	CALL(_C_LABEL(m88100_trap), T_DATAFLT, r30)
	CALL(_C_LABEL(data_access_emulation), r30, r0) /* really only 2 args */
	/* clear the dmt0 word in the E.F. */
d1986 1
a1986 1
2:
d1988 2
a1989 2
#endif /* m88100 */

d1991 1
a1991 1
ASLOCAL(m88110_return_code)
d1994 3
d1998 1
d2000 2
a2001 2
	 * If it's the interrupt exception, enable interrupt.
	 * If it's the data access exception, take care of it.
d2003 20
d2024 4
a2027 6
	/*
	 * Is it ever possible to have interrupt exception while EPSR has
	 * it disabled? I don't think so.. XXX nivas
	 * 
	 * On mc88110, you can.  The NMI interrupt. aka ABORT. XXX smurph
	 */
d2029 2
a2030 2
	cmp	r2, r2, 1   /* Is it an interrupt? */ 
	bb1	ne, r2, 1f  /* If not, skip */
d2032 1
a2032 1
	/* if EPSR has interrupts disabled, skip also */
d2040 3
a2042 4
	br 2f	/* temp XXX smurph */
	ld	r2, FPTR, REG_OFF(EF_VECTOR)
	cmp	r2, r2, 3   /* Is it a data access exception? */ 
	bb1	ne, r2, 2f  /* If not, skip */
d2044 5
a2048 5
	/*
	 * if there happens to be a data fault that hasn't been serviced yet,
	 * go off and service that...
	 */
	CALL(_C_LABEL(m88110_trap), T_DATAFLT, r30)
d2050 1
a2050 1
	/* clear the dsr word in the E.F. */
a2051 2
	st	r0, FPTR, REG_OFF(EF_DLAR)
	st	r0, FPTR, REG_OFF(EF_DPAR)
d2065 1
a2065 1
        bcnd    ne0, r2, 1f		/* can't do softint's */
d2068 1
a2068 1
	bsr.n   _C_LABEL(setipl)
d2072 1
a2072 1
        bsr     _C_LABEL(dosoftint)
d2075 2
a2076 2
        bsr.n   _C_LABEL(setipl)
        or      r2,r0,0			/* ints are enabled */
d2085 2
a2086 2
        or.u	r2, r0, hi16(_C_LABEL(want_ast))
        ld	r3, r2, lo16(_C_LABEL(want_ast))
d2093 2
a2094 2
	or.u	r2, r0, hi16(_C_LABEL(cputyp))
	ld	r3, r2, lo16(_C_LABEL(cputyp))
d2097 1
a2097 1
        CALL(_C_LABEL(m88110_trap), T_ASTFLT, FPTR)
d2102 1
a2102 1
        CALL(_C_LABEL(m88100_trap), T_ASTFLT, FPTR)
d2108 1
a2108 1
        bsr     _C_LABEL(getipl)
d2110 1
a2110 1
        bsr     _C_LABEL(panic)
d2124 1
a2124 1
	bsr.n   _C_LABEL(setipl)
d2158 2
a2159 2
        or.u	r1, r0, hi16(_C_LABEL(cputyp))
	ld	r30, r1, lo16(_C_LABEL(cputyp))
d2163 4
a2166 4
	ld      r30, r31, REG_OFF(EF_ENIP)
        ld      r1,  r31, REG_OFF(EF_EXIP)
        stcr    r30, ENIP
        stcr    r1,  EXIP
d2168 1
a2168 1
1:
d2206 4
a2209 4
GLOBAL(m88110_unknown_handler)
	PREP2("unknown", 0, DEBUG_UNKNOWN_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_UNKNOWNFLT, r30)
	DONE(DEBUG_UNKNOWN_BIT)
d2212 4
a2215 4
GLOBAL(m88110_interrupt_handler)
	PREP2("interrupt", 1, DEBUG_INTERRUPT_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_INT, r30)
	DONE(DEBUG_INTERRUPT_BIT)
d2218 5
a2222 4
GLOBAL(m88110_instruction_access_handler)
	PREP2("inst", 2, DEBUG_INSTRUCTION_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_INSTFLT, r30)
	DONE(DEBUG_INSTRUCTION_BIT)
d2227 3
a2229 4
GLOBAL(m88110_data_exception_handler)
	PREP2("data", 3, DEBUG_DATA_BIT, No_SSBR_Stuff, M88110_Data_Precheck)
	CALL(_C_LABEL(m88110_trap), T_DATAFLT, r30)
	DONE(DEBUG_DATA_BIT)
d2232 4
a2235 4
GLOBAL(m88110_misaligned_handler)
	PREP2("misalign", 4, DEBUG_MISALIGN_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_MISALGNFLT, r30)
	DONE(DEBUG_MISALIGN_BIT)
d2238 4
a2241 4
GLOBAL(m88110_unimplemented_handler)
	PREP2("unimp", 5, DEBUG_UNIMPLEMENTED_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_ILLFLT, r30)
	DONE(DEBUG_UNIMPLEMENTED_BIT)
d2244 4
a2247 4
GLOBAL(m88110_privilege_handler)
	PREP2("privilege", 6, DEBUG_PRIVILEGE_BIT, No_SSBR_Stuff, No_Precheck) 
	CALL(_C_LABEL(m88110_trap), T_PRIVINFLT, r30)
	DONE(DEBUG_PRIVILEGE_BIT)
d2253 4
a2256 4
GLOBAL(m88110_bounds_handler)
	PREP2("bounds", 7, DEBUG_BOUNDS_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_BNDFLT, r30)
	DONE(DEBUG_BOUNDS_BIT)
d2259 4
a2262 4
GLOBAL(m88110_divide_handler)
	PREP2("divide", 8, DEBUG_DIVIDE_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_ZERODIV, r30)
	DONE(DEBUG_DIVIDE_BIT)
d2265 4
a2268 4
GLOBAL(m88110_overflow_handler)
	PREP2("overflow", 9, DEBUG_OVERFLOW_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_OVFFLT, r30)
	DONE(DEBUG_OVERFLOW_BIT)
d2271 10
a2280 10
GLOBAL(m88110_fp_precise_handler)
	PREP2("FPU precise", 114, DEBUG_FPp_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_m88110_Xfp_precise, r0, r30) /* call fp_precise(??, exception_frame)*/
	DONE(DEBUG_FPp_BIT)

/* MVME197 non-maskable interrupt handler (ABORT button) */
GLOBAL(m88110_nonmaskable)
	PREP2("MVME197 non-mask", 11, DEBUG_NON_MASK_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_NON_MASK, r30)
	DONE(DEBUG_NON_MASK_BIT)
d2283 4
a2286 4
GLOBAL(m88110_data_read_miss)
	PREP2("MVME197 read miss", 12, DEBUG_197_READ_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_197_READ, r30)
	DONE(DEBUG_197_READ_BIT)
d2289 4
a2292 4
GLOBAL(m88110_data_write_miss)
	PREP2("MVME197 write miss", 13, DEBUG_197_WRITE_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_197_WRITE, r30)
	DONE(DEBUG_197_WRITE_BIT)
d2295 4
a2298 4
GLOBAL(m88110_inst_atc_miss)
	PREP2("MVME197 inst miss", 14, DEBUG_197_INST_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_197_INST, r30)
	DONE(DEBUG_197_INST_BIT)
d2301 5
a2305 5
GLOBAL(m88110_syscall_handler)
	PREP2("syscall", 128, DEBUG_SYSCALL_BIT, No_SSBR_Stuff, No_Precheck)
	ld   r13, r30, GENREG_OFF(13)
	CALL(_m88110_syscall, r13, r30) /* system call no. is in r13 */
	DONE(DEBUG_SYSCALL_BIT)
d2308 25
a2332 25
GLOBAL(m88110_bugtrap)
	PREP2("bugsyscall", 496, DEBUG_BUGCALL_BIT, No_SSBR_Stuff, No_Precheck)
	ld   r9,  r30, GENREG_OFF(9)
	CALL(_bugsyscall, r9, r30)   /* system call no. is in r9 */
	DONE(DEBUG_BUGCALL_BIT)

GLOBAL(m88110_sigsys)
	PREP2("sigsys", 0, DEBUG_SIGSYS_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_SIGSYS, r30)
	DONE(DEBUG_SIGSYS_BIT)

GLOBAL(m88110_sigtrap)
	PREP2("sigtrap", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_SIGTRAP, r30)
	DONE(DEBUG_SIGTRAP_BIT)

GLOBAL(m88110_stepbpt)
	PREP2("sigtrap", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_STEPBPT, r30)
	DONE(DEBUG_SIGTRAP_BIT)

GLOBAL(m88110_userbpt)
	PREP2("sigtrap", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_USERBPT, r30)
	DONE(DEBUG_SIGTRAP_BIT)
d2335 13
a2347 14
GLOBAL(m88110_break)
	PREP2("break", 130, DEBUG_BREAK_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_KDB_BREAK, r30)
	DONE(DEBUG_BREAK_BIT)

GLOBAL(m88110_trace)
	PREP2("trace", 131, DEBUG_TRACE_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_KDB_TRACE, r30)
	DONE(DEBUG_TRACE_BIT)

GLOBAL(m88110_entry)
	PREP2("kdb", 132, DEBUG_KDB_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_KDB_ENTRY, r30)
	DONE(DEBUG_KDB_BIT)
d2349 12
a2360 14
GLOBAL(m88110_break)
	PREP2("break", 130, DEBUG_BREAK_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_UNKNOWNFLT, r30)
	DONE(DEBUG_BREAK_BIT)

GLOBAL(m88110_trace)
	PREP2("trace", 131, DEBUG_TRACE_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_UNKNOWNFLT, r30)
	DONE(DEBUG_TRACE_BIT)

GLOBAL(m88110_entry)
	PREP2("unknown", 132, DEBUG_UNKNOWN_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_UNKNOWNFLT, r30)
	DONE(DEBUG_KDB_BIT)
a2362 1

d2375 1
a2375 27
GLOBAL(m88110_error_handler)
	xcr	r2, r2,	SRX
	or	r2, r0, 10
	stcr	r2, 	SR0
	br.n	_C_LABEL(m88110_fatal)
	xcr	r2, r2,	SRX

/*
 * The reset exception handler.
 * The reset exception is raised when the RST signal is asserted (machine 
 * is reset), the value of VBR is changed after exceptions are enabled, 
 * or when a jmp, br/bsr to addr 0 (accidents do happen :-)
 *
 * Upon a real reset, VBR is set to zero (0), so code must be at addr 0 
 * to handle it!!! 
 *
 * This is totaly different than _error_handler.  Shadowing might or 
 * might not be on.
 * R1-R31 could tell u alot about what happend, so we'll save them.
 *
 * We'll not worry about trashing r26-29 here,
 * since they aren't generally used.
 */
GLOBAL(m88110_reset_handler)
	stcr	r0, 	SR0
	/* FALL THROUGH */
GLOBAL(m88110_fatal)
d2389 1
a2389 1
2:	/* stack has been cleared */
d2391 1
a2391 1
	/* ensure that stack is 8-byte aligned */
d2394 1
a2394 1
	/* create exception frame on stack */
d2397 1
a2397 1
	/* save old R31 and other R registers */
a2412 6

	/* vector is put in SRO (either 0 or 10 at this point) */
	ldcr	r10, SR0
	st	r10,  r31, REG_OFF(EF_VECTOR)
	cmp	r10, r10, 0	/* Is it the reset exception? */
	bb1.n	ne,  r10, 1f	/* If not, skip. */
d2417 4
a2420 16
	ldcr	r10, EXIP
	st	r10, r31, REG_OFF(EF_EXIP)
	ldcr	r10, ENIP
	st	r10, r31, REG_OFF(EF_ENIP)
	ldcr	r10, DSR
	st	r10, r31, REG_OFF(EF_DSR)
	ldcr	r10, DLAR
	st	r10, r31, REG_OFF(EF_DLAR)
	ldcr	r10, DPAR
	st	r10, r31, REG_OFF(EF_DPAR)
	ldcr	r10, ISR
	st	r10, r31, REG_OFF(EF_ISR)
	ldcr	r10, ILAR
	st	r10, r31, REG_OFF(EF_ILAR)
	ldcr	r10, IPAR
	st	r10, r31, REG_OFF(EF_IPAR)
a2421 1
	br.n	2f
a2423 31
1:	
	/* retrieve saved shadow registers for error_handler, though) */
	or.u	r30, r0,  hi16(_save_frame)
	or	r30, r30, lo16(_save_frame)
	ld	r10, r30, REG_OFF(EF_EPSR)
	st	r10, r31, REG_OFF(EF_EPSR)
	ld	r10, r30, REG_OFF(EF_EXIP)
	st	r10, r31, REG_OFF(EF_ENIP)
	ld	r10, r30, REG_OFF(EF_DSR)
	st	r10, r31, REG_OFF(EF_DSR)
	ld	r10, r30, REG_OFF(EF_DLAR)
	st	r10, r31, REG_OFF(EF_DLAR)
	ld	r10, r30, REG_OFF(EF_DPAR)
	st	r10, r31, REG_OFF(EF_DPAR)
	ld	r10, r30, REG_OFF(EF_ISR)
	st	r10, r31, REG_OFF(EF_ISR)
	ld	r10, r30, REG_OFF(EF_ILAR)
	st	r10, r31, REG_OFF(EF_ILAR)
	ld	r10, r30, REG_OFF(EF_IPAR)
	st	r10, r31, REG_OFF(EF_IPAR)
	ld	r10, r30, REG_OFF(EF_ISAP)
	st	r10, r31, REG_OFF(EF_ISAP)
	ld	r10, r30, REG_OFF(EF_DSAP)
	st	r10, r31, REG_OFF(EF_DSAP)
	ld	r10, r30, REG_OFF(EF_IUAP)
	st	r10, r31, REG_OFF(EF_IUAP)
	ld	r10, r30, REG_OFF(EF_DUAP)
	st	r10, r31, REG_OFF(EF_DUAP)
	ldcr	r10, SR1
	st	r10, r31, REG_OFF(EF_MODE)
2:
d2432 2
d2455 2
a2456 2
        
	CALL(_error_fatal, r30, r30)
d2464 2
a2465 2
ASGLOBAL(m88110_error_loop)
	bsr m88110_error_loop
d2468 79
a2546 183
ASGLOBAL(m88110_setup_phase_one)
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread (if any, null if not)                     *
	* SR1: saved copy of exception-time register now holding FLAGS  *
	* SR2: saved copy of exception-time r1                          *
	* SR3: must be preserved .. may be the exception-time stack     *
	* r1: return address to calling exception handler               *
	* FLAGS: CPU status flags                                       *
	***************************************************             *
	* immediate goal:                                               *
	*    Decide where we're going to put the exception frame.       *
	*   Might be at the end of R31, SR3, or the thread's            *
	*   pcb.                                                        *
	\***************************************************************/
	
	/* Check if we are coming in from a FPU restart exception.
	   If so, the pcb will be in SR3 */
	NOP
	xcr   r1,   r1,   SR2
	NOP
	NOP
	NOP
	
	bb1   FLAG_ENABLING_FPU, FLAGS, m88110_use_SR3_pcb
	/* are we coming in from user mode? If so, pick up process pcb */
	bb0   FLAG_FROM_KERNEL, FLAGS, m88110_pickup_stack
	
	/* Interrupt in kernel mode, not FPU restart */
ASGLOBAL(m88110_already_on_kernel_stack)
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread (if any, null if not)                     *
	* SR1: saved copy of exception-time register now holding FLAGS  *
	* SR2: return address to the calling exception handler          *
	* SR3: must be preserved; may be important for other exceptions *
	* FLAGS: CPU status flags                                       *
	***************************************************             *
	* immediate goal:                                               *
	*   We're already on the kernel stack, but not having           *
	*   needed to use SR3. We can just make room on the             *
	*    stack (r31) for our exception frame.                       *
	\***************************************************************/
	subu  r31,  r31,  SIZEOF_EF            /* r31 now our E.F. */
	st    FLAGS,r31,  REG_OFF(EF_FLAGS)    /* save flags */
	st    r1,   r31,  GENREG_OFF(1)        /* save prev. r1 (now r1 free)*/
	
	ldcr  r1,   SR3                        /* save previous SR3 */
	st    r1,   r31,  REG_OFF(EF_SR3)
	
	addu  r1,   r31,  SIZEOF_EF            /* save previous r31 */
	br.n  m88110_have_pcb
	st    r1,   r31,  GENREG_OFF(31)
	
	
ASGLOBAL(m88110_use_SR3_pcb)
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread (if any, null if not)                     *
	* SR1: saved copy of exception-time register now holding FLAGS  *
	* SR2: return address to the calling exception handler          *
	* SR3: must be preserved; exception-time stack pointer          *
	* FLAGS: CPU status flags                                       *
	***************************************************             *
	* immediate goal:                                               *
	*   An exception occured while enabling the FPU. Since r31      *
	*   is the user's r31 while enabling the FPU, we had put        *
	*   our pcb pointer into SR3, so make room from                 *
	*   there for our stack pointer.                                *
	*       We need to check if SR3 is the old stack pointer or the *
	*       pointer off to the user pcb. If it pointing to the user *
	*       pcb, we need to pick up the kernel stack. Otherwise     *
	*       we need to allocate a frame upon it.                    *
	*       We look at the EPSR to see if it was from user mode     *
	*       Unfortunately, we have no registers free at the moment  *
	*       But we know register 0 in the pcb frame will always be  *
	*       zero, so we can use it as scratch storage.              *
	*                                                               *
	*                                                               *
	\***************************************************************/
	xcr	r2, r2,	SRX
	or	r2, r0, 10
	stcr	r2, 	SR0
	br.n	_C_LABEL(m88110_fatal)
	xcr	r2, r2,	SRX
	/* Testing!!! */
	xcr   r30,  r30,  SR3                  /* r30 = old exception frame */
	st    r1,   r30,  GENREG_OFF(0)        /* free up r1 */
	ld    r1,   r30,  REG_OFF(EF_EPSR)     /* get back the epsr */
	bb0.n PSR_SUPERVISOR_MODE_BIT, r1, 1f  /* if user mode */
	ld    r1,   r30,  GENREG_OFF(0)        /* restore r1 */
	/* we were in kernel mode - dump frame upon the stack */
	st    r0,   r30,  GENREG_OFF(0)        /* repair old frame */
	subu  r30,  r30,  SIZEOF_EF            /* r30 now our E.F. */
	st    FLAGS,r30,  REG_OFF(EF_FLAGS)    /* save flags */
	st    r1,   r30,  GENREG_OFF(1)        /* save prev. r1 (now r1 free) */
	
	st    r31,  r30,  GENREG_OFF(31)       /* save previous r31 */
	or    r31,  r0,   r30                  /* make r31 our pointer. */
	addu  r30,  r30,  SIZEOF_EF            /* r30 now has previous SR3 */
	st    r30,  r31,  REG_OFF(EF_SR3)      /* save previous SR3 */
	br.n  m88110_have_pcb
	xcr   r30,  r30,  SR3                  /* restore r30 */
1:
	/* we took an exception while restarting the FPU from user space.
	 * Consequently, we never picked up a stack. Do so now.
	 * R1 is currently free (saved in the exception frame pointed at by
	 * r30) */
	or.u  r1,   r0,   hi16(_kstack)
	ld    r1,   r1,   lo16(_kstack)
	addu  r1,   r1,   USIZE-SIZEOF_EF
	st    FLAGS,r1,   REG_OFF(EF_FLAGS)    /* store flags */
	st    r31,  r1,   GENREG_OFF(31)       /* store r31 - now free */
	st    r30,  r1,   REG_OFF(EF_SR3)      /* store old SR3 (pcb) */
	or    r31,  r1,   r0                   /* make r31 our exception frame pointer */
	ld    r1,   r30,  GENREG_OFF(0)        /* restore old r1 */
	st    r0,   r30,  GENREG_OFF(0)        /* repair that frame */
	st    r1,   r31,  GENREG_OFF(1)        /* store r1 in its proper place */
	br.n  m88110_have_pcb
	xcr   r30,  r30,  SR3                  /* restore r30 */
	
ASGLOBAL(m88110_pickup_stack)
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                          *
	* SR1: saved copy of exception-time register now holding FLAGS *
	* SR2: return address to the calling exception handler         *
	* SR3: free                                                    *
	* FLAGS: CPU status flags                                      *
	***************************************************            *
	* immediate goal:                                              *
	*    Since we're servicing an exception from user mode, we     *
	*   know that SR3 is free.  We use it to free up a temp.       *
	*   register to be used in getting the thread's pcb            *
	\***************************************************************/
	stcr  r31,  SR3      /* save previous r31 */
	
	/* switch to the thread's kernel stack. */
	or.u  r31,  r0,   hi16(_curpcb)
	ld    r31,  r31,  lo16(_curpcb)
	addu  r31,  r31,  PCB_USER_STATE       /* point to user save area */
	st    FLAGS,r31,  REG_OFF(EF_FLAGS)    /* save flags */
	st    r1,   r31,  GENREG_OFF(1)        /* save prev. r1 (now r1 free)*/
	ldcr  r1,   SR3                        /* save previous r31 */
	st    r1,   r31,  GENREG_OFF(31)
	/*FALLTHROUGH */
	
ASGLOBAL(m88110_have_pcb)
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                          *
	* SR1: saved copy of exception-time register now holding FLAGS *
	* SR2: return address to the calling exception handler         *
	* SR3: free                                                    *
	* r1:  free                                                    *
	* FLAGS: CPU status flags                                      *
	* r31: our exception frame                                     *
	*    Valid in the exception frame:                             *
	*   Exception-time r1, r31, FLAGS.                             *
	*   Exception SR3, if appropriate.                             *
	***************************************************            *
	* immediate goal:                                              *
	*    Save the shadow registers that need to be saved to        *
	*   the exception frame.                                       *
	\***************************************************************/
	stcr   TMP, SR3   /* free up TMP, TMP2, TMP3 */
	SAVE_TMP2
	SAVE_TMP3
	
	/* save some exception-time registers to the exception frame */
	ldcr  TMP,  EPSR
	st    TMP,  r31,  REG_OFF(EF_EPSR)
	ldcr  TMP2, EXIP
	st    TMP2, r31,  REG_OFF(EF_EXIP)
	bb0.n 0,    TMP2, 1f
	/* The instruction was NOT in the delay slot, zero ENIP. */
	st    r0,   r31,  REG_OFF(EF_ENIP)
	/* The instruction was in the delay slot, save ENIP. */
	ldcr  TMP3, ENIP
	st    TMP3, r31,  REG_OFF(EF_ENIP)
1:
	/* NO SFIP on mc88110, zero it */
	st    r0,   r31,  REG_OFF(EF_SFIP)
	
	/* get and store the cpu number */	
	extu  TMP,  FLAGS,  FLAG_CPU_FIELD_WIDTH<0>  /* TMP = cpu# */
	st    TMP,  r31,  REG_OFF(EF_CPU)
	
d2548 1
a2548 1
	 * Save Pbus fault status register from data and inst CMMU.
d2550 221
a2770 24
	ldcr  TMP,  ISR
	ldcr  TMP2, ILAR
	ldcr  TMP3, IPAR
	st    TMP,  r31,  REG_OFF(EF_ISR)
	st    TMP2, r31,  REG_OFF(EF_ILAR)
	st    TMP3, r31,  REG_OFF(EF_IPAR)
	ldcr  TMP,  ISAP
	ldcr  TMP2, IUAP
	st    TMP,  r31,  REG_OFF(EF_ISAP)
	st    TMP2, r31,  REG_OFF(EF_IUAP)
	ldcr  TMP,  DSR
	ldcr  TMP2, DLAR
	ldcr  TMP3, DPAR
	st    TMP,  r31,  REG_OFF(EF_DSR)
	st    TMP2, r31,  REG_OFF(EF_DLAR)
	st    TMP3, r31,  REG_OFF(EF_DPAR)
	ldcr  TMP,  DSAP
	ldcr  TMP2, DUAP
	st    TMP,  r31,  REG_OFF(EF_DSAP)
	st    TMP2, r31,  REG_OFF(EF_DUAP)
	
	ldcr  r1,   SR2
	jmp   r1 /* return */
	
d2774 106
a2879 115
ASGLOBAL(m88110_setup_phase_two)
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: saved return address to calling exception handler        *
	* SR1: saved copy of exception-time register now holding FLAGS  *
	* SR2: free                                                     *
	* SR3: saved TMP                                                *
	* r1:  return address to calling exception handler              *
	* TMP: possibly revised SSBR                                    *
	* TMP2: free                                                    *
	* TMP3: free                                                    *
	* FLAGS: CPU status flags                                       *
	* r31: our exception frame                                      *
	*    Valid in the exception frame:                              *
	*   Exception-time r1, r31, FLAGS.                              *
	*   Exception-time TMP2, TMP3.                                  *
	*   Exception-time espr, enip, exip.                            *
	*   Exception number (EF_VECTOR).                               *
	*   Dmt0                                                        *
	*   Other data pipeline control registers, if appropriate.      *
	*   FPU control registers, if appropriate.                      *
	*   Exception SR3, if appropriate.                              *
	***************************************************             *
	* immediate goal:                                               *
	*   restore the system to the exception-time state (except      *
	* SR3 will be OUR stack pointer) so that we may resart the FPU. *
	\***************************************************************/
	/*stcr   r1, SR0*/      /* save return address */
	
	RESTORE_TMP2      /* done with extra temp regs */
	RESTORE_TMP3      /* done with extra temp regs */
	
	ldcr  TMP,  PSR
	clr   TMP,  TMP,  1<PSR_FPU_DISABLE_BIT>    /* enable the FPU */
	clr   TMP,  TMP,  1<PSR_SHADOW_FREEZE_BIT>  /* also enable shadowing */
	stcr  TMP,  EPSR
	
	or.u  TMP,  r0,   hi16(m88110_fpu_enable)
	or    TMP,  TMP,  lo16(m88110_fpu_enable)
	stcr  TMP,  EXIP      /* jump to here fpu_enable */
	addu  TMP,  TMP,  4
	stcr  TMP,  ENIP      /* and then continue after that */
	
	set   FLAGS, FLAGS, 1<FLAG_ENABLING_FPU> /* note what we're doing.*/
	xcr   FLAGS, FLAGS, SR1
	st    r1,   r31,  REG_OFF(EF_RET) /* save the return address */
	ld    r1,   r31,  GENREG_OFF(1)    /* get original r1 */
	
	ldcr  TMP, SR3
	stcr  r31, SR3	/* TMP now restored. R31 now saved in SR3 */
	ld    r31,  r31,  GENREG_OFF(31) /* get original r31 */
	
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                           *
	* SR1: CPU flags                                                *
	* SR2: free                                                     *
	* SR3: pointer to our exception frame (our stack pointer)       *
	* r1 through r31: original exception-time values                *
	*                                                               *
	* Valid in the exception frame:                                 *
	*   Exception-time FLAGS.                                       *
	*   Exception-time espr, sfip, enip, exip.                      *
	*   Exception number (EF_VECTOR).                               *
	*   Dmt0                                                        *
	*   Other data pipeline control registers, if appropriate.      *
	*   FPU control registers, if appropriate.                      *
	*   Exception SR3, if appropriate.                              *
	*   Held temporarly in the exception frame:                     *
	*   Return address to the calling excption handler.             *
	***************************************************             *
	* immediate goal:                                               *
	*   Do an RTE to restart the fpu and jump to "fpu_enable"       *
	*   Another exception (or exceptions) may be raised in          *
	*   this, which is why FLAG_ENABLING_FPU is set in SR1.         *
	\***************************************************************/
	NOP
	RTE   /* jumps to "fpu_enable" on the next line to enable the FPU. */
	
ASGLOBAL(m88110_fpu_enable)
	FLUSH_PIPELINE
	/* Now we can handle another exception!!! */
	/* Now that EFZE is cleared, we can clear these */
	stcr  r0, ISR	/* Clear ISR */
	stcr  r0, ILAR	/* Clear ILAR */
	stcr  r0, IPAR	/* Clear IPAR */
	stcr  r0, DSR	/* Clear DSR */
	stcr  r0, DLAR	/* Clear DLAR */
	stcr  r0, DPAR	/* Clear DPAR */
	xcr   TMP,  TMP,  SR3               /* get E.F. pointer */
	st.d  r30,  TMP,  GENREG_OFF(30)    /* save previous r30, r31 */
	or    r31,  TMP,  r0                /* transfer E.F. pointer to r31 */
	ld    TMP,  r31,  REG_OFF(EF_SR3)   /* get previous SR3; maybe important*/

	/* make sure that the FLAG_ENABLING_FPU bit is off */
	xcr   FLAGS,FLAGS,SR1
	clr   FLAGS,FLAGS,1<FLAG_ENABLING_FPU>
	xcr   FLAGS,FLAGS,SR1

	xcr   TMP,  TMP,  SR3       /* replace TMP, SR3 */

	/* now save all regs to the exception frame. */
	st.d  r0 ,  r31,  GENREG_OFF(0)
	st.d  r2 ,  r31,  GENREG_OFF(2)
	st.d  r4 ,  r31,  GENREG_OFF(4)
	st.d  r6 ,  r31,  GENREG_OFF(6)
	st.d  r8 ,  r31,  GENREG_OFF(8)
	st.d  r10,  r31,  GENREG_OFF(10)
	st.d  r12,  r31,  GENREG_OFF(12)
	st.d  r14,  r31,  GENREG_OFF(14)
	st.d  r16,  r31,  GENREG_OFF(16)
	st.d  r18,  r31,  GENREG_OFF(18)
	st.d  r20,  r31,  GENREG_OFF(20)
	st.d  r22,  r31,  GENREG_OFF(22)
	st.d  r24,  r31,  GENREG_OFF(24)
	st.d  r26,  r31,  GENREG_OFF(26)
	st.d  r28,  r31,  GENREG_OFF(28)
d2881 4
a2884 4
	/* mark beginning of frame with notable value */
	or.u  r20,  r0,   hi16(0x12345678)
	or    r20,  r20,  lo16(0x12345678)
	st    r20,  r31,  GENREG_OFF(0)
d2886 39
a2924 39
	
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                           *
	* SR1: free                                                     *
	* SR2: free                                                     *
	* SR3: previous exception-time SR3                              *
	* r1: return address to the calling exception handler           *
	* r2 through r30: free                                          *
	* r31: our exception frame                                      *
	*                                                               *
	* Valid in the exception frame:                                 *
	*   Exception-time r0 through r31.                              *
	*   Exception-time FLAGS.                                       *
	*   Exception-time espr, enip, exip.                            *
	*   Exception number (EF_VECTOR).                               *
	*   DSR                                                         *
	* Other data pipeline control registers, if appropriate.        *
	*   FPU control registers, if appropriate.                      *
	*   Exception SR3, if appropriate.                              *
	***************************************************             *
	* immediate goal:                                               *
	*   Pick up a stack if we came in from user mode. Put           *
	*       A copy of the exception frame pointer into r30          *
	*       bump the stack a doubleword and write the exception     *
	*       frame pointer.                                          *
	*   if not an interrupt exception,                              *
	*       Turn on interrupts and service any outstanding          *
	*       data access exceptions.                                 *
	*   Return to calling exception handler to                      *
	*   service the exception.                                      *
	\***************************************************************/
	
	/*
	 * If it's not the interrupt exception, enable interrupts and
	 * take care of any data access exceptions......
	 */
	or    r30,  r0,   r31              /* get a copy of the e.f. pointer */
	ld    r2,   r31,  REG_OFF(EF_EPSR)
	bb1   PSR_SUPERVISOR_MODE_BIT, r2, 1f  /* If in kernel mode */
d2931 6
a2936 6
	ld    r3,   r31,  REG_OFF(EF_VECTOR)
	cmp   r3,   r3,   1      /* is interrupt ? */
	bb0   eq,   r3,   2f
	or.u  r31,  r0,   hi16(_intstack_end)   /* swith to int stack */
	or    r31,  r31,  lo16(_intstack_end)
	br    3f
d2939 4
a2942 4
	or.u  r31,  r0,   hi16(_kstack)
	ld    r31,  r31,  lo16(_kstack)
	addu  r31,  r31,  USIZE        /* point at proper end */
	br    3f
d2945 14
a2958 14
	ld    r3,   r31,  REG_OFF(EF_VECTOR)
	cmp   r3,   r3,   1       /* is interrupt ? */
	bb0   eq,   r3,   3f      /* no, we will stay on kern stack */
	or.u  r31,  r0,   hi16(_intstack_end)   /* swith to int stack */
	or    r31,  r31,  lo16(_intstack_end)
#endif	/* INTSTACK */
	/* This label is here for debugging */
m88110_exception_handler_has_ksp:  global m88110_exception_handler_has_ksp
3:	/*
	 * here - r30 holds a pointer to the exception frame.
	 * r31 is a pointer to the kernel stack/interrupt stack.
	 */
	subu  r31,  r31,  8  /* make some breathing space */
	st    r30,  r31,  0  /* store frame pointer on the stack */
d2960 1
a2960 1
	st    r30,  r31,  4  /* store it again for the debugger to recognize */
d2963 5
a2967 5
	ld    r2,   r30,  REG_OFF(EF_VECTOR)
	bcnd.n eq0, r2,   m88110_return_to_calling_exception_handler  /* is error */
	ld    r14,  r30,  REG_OFF(EF_RET) /* load return value XXX!!! */
	cmp   r3,   r2,   1 /* interrupt is exception #1 ;Is an interrupt? */
	bb1.n   eq,   r3,   m88110_return_to_calling_exception_handler /* skip if so */
d2970 2
a2971 2
	cmp   r3,   r2,   130 /* DDB break exception */
	bb1.n eq,   r3,   m88110_return_to_calling_exception_handler
d2973 2
a2974 2
	cmp   r3,   r2,   132 /* DDB entry exception */
	bb1.n eq,   r3,   m88110_return_to_calling_exception_handler
d2977 3
a2979 3
	ldcr  r2,   PSR
	clr   r2,   r2,   1<PSR_INTERRUPT_DISABLE_BIT>   /* enable interrupts */
	stcr  r2,   PSR
d2981 1
a2981 1
	FLUSH_PIPELINE
a2982 5
#if 1 /* test */
	br  m88110_return_to_calling_exception_handler
#endif
	/* service any outstanding data pipeline stuff
	   - check dsr... anything outstanding?*/
d2984 6
a2989 3
	ld    r3,   r30,  REG_OFF(EF_DSR)
	cmp   r3,   r3,   0
	bb1   eq,   r3,   m88110_return_to_calling_exception_handler
d2992 2
a2993 2
 * r30 can be clobbered by calls. So stuff its value into a
 * preserved register, say r15. R14 is in use (see return_to_... below).
d2995 6
a3000 5
	or    r15,  r0,   r30
#if 0
	CALL(_C_LABEL(test_trap), r15, r0)
#endif   
	CALL(_C_LABEL(m88110_trap), T_DATAFLT, r15)
d3002 2
a3003 2
	/*   restore it... */
	or    r30,  r0,   r15
d3005 2
a3006 2
	/* clear the dsr word in the E.F */
	st    r0,   r30,  REG_OFF(EF_DSR)
a3007 7
ASGLOBAL(m88110_return_to_calling_exception_handler)
	jmp   r14 /* loaded above */
	
	data
	.align 8
GLOBAL(save_frame)
	space SIZEOF_EF	
@


1.25.2.2
log
@sync
@
text
@d1 1
a1 1
/*   $OpenBSD$   */
d368 1
a368 1
1:	bsr	setup_phase_one				; \
d397 1
a397 1
	ldcr    r1, EPSR 				; \
d403 1
a403 1
1:	bsr	m88110_setup_phase_one			; \
d563 1
a563 1
/* integer overflow exception handler */
d571 1
a571 1
GLOBAL(fp_precise_handler)
d578 1
a578 1
GLOBAL(fp_imprecise_handler)
d618 1
a618 1
GLOBAL(break)
d623 1
a623 1
GLOBAL(trace)
d634 1
a634 1
GLOBAL(break)
d639 1
a639 1
GLOBAL(trace)
a1822 4

	/* get and save IPL */
	bsr	_C_LABEL(getipl)
	st	r2, r31, REG_OFF(EF_MASK)
d1982 1
a1982 1

d1984 1
d2011 1
a2011 1
	bb0	DMT_VALID_BIT, r3, check_ast /*[Oh well, nothing to do here] */
d2067 1
a2067 1
	br   check_ast
d2121 1
a2121 1
ASLOCAL(check_ast)
d2153 1
a2153 1
#if defined(M88110) && defined(M88100)
a2157 2
#endif
#if defined(M88110)
a2158 2
#endif
#if defined(M88110) && defined(M88100)
d2166 10
a2175 1
ASLOCAL(no_ast)
d2184 2
a2186 2
	bsr.n   _C_LABEL(setipl)
	 ld	r2, FPTR, REG_OFF(EF_MASK)   /* get pre-exception ipl */
d2258 1
d2260 1
a2260 1

d2325 1
a2325 1
/* integer overflow exception handler */
@


1.24
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.18 2001/11/27 05:26:36 miod Exp $   */
d219 1
d221 1
a221 3
#ifdef MVME188
#include <machine/mvme188.h>
#endif
d288 1
a288 1
#if defined(MVME187) || defined (MVME188)
d321 1
a321 1
#endif /* defined(MVME187) || defined (MVME188) */
d323 1
a323 1
#ifdef MVME197	
a342 4
	/* Clear any bits in the SSBR (held in TMP) */	; \
	/* SSBR_STUFF may be empty, though.         */	; \
	SSBR_STUFF					; \
							; \
d349 1
a349 1
#endif /* MVME197 */
d421 1
a421 1
#if defined(MVME187) || defined (MVME188)
d682 3
a684 3
	or.u	r10,  r0,   hi16(_cputyp)
	ld	r11,  r10,  lo16(_cputyp)
	cmp	r10,  r11,  0x188
d894 1
a894 1
#endif /* defined(MVME187) || defined (MVME188) */
d896 1
a896 1
#ifdef MVME197
d927 1
a927 1
#endif /* MVME197 */
d1057 1
a1057 1
#if defined(MVME187) || defined (MVME188) 
d1233 3
a1235 3
	or.u	TMP,  r0,   hi16(_cputyp)
	ld	TMP2, TMP,  lo16(_cputyp)
	cmp	TMP,  TMP2, 0x188
d1417 1
a1417 1
#endif /* defined(MVME187) || defined (MVME188) */
d1502 2
a1503 4
3:
   clr   TMP,  TMP,  TMP3   /* clear bit(s) in ssbr. */
4: 
   jmp   r1
a1508 1

d1610 1
a1610 1
#if defined(MVME187) || defined (MVME188)
d1863 1
a1863 1
#endif /* defined(MVME187) || defined (MVME188) */
d1919 1
a1919 1
#if (defined(MVME187) || defined(MVME188)) && defined(MVME197)
d1922 1
a1922 1
	cmp	r2, r3, 0x197
d1925 1
a1925 1

a1926 1
#if defined(MVME187) || defined(MVME188)
d1988 1
a1988 1
#endif	/* defined(MVME187) || defined(MVME188) */
d1990 1
a1990 1
#ifdef MVME197
d2053 1
a2053 1
#endif /* MVME197 */
d2070 1
d2092 1
a2092 3

#if defined(MVME187) || defined(MVME188)
#if defined(MVME197)
d2095 5
a2099 2
	cmp	r2, r3, 0x197
	bb1	eq, r2, 1f
d2101 1
a2102 8
#if defined(MVME197)
	br	2f
1:
#endif
#endif
#if defined(MVME197)
        CALL(_C_LABEL(trap197), T_ASTFLT, FPTR)
2:
d2109 1
a2109 1
        bcnd    eq0, r2, 2f
d2111 1
a2111 1
2:
a2116 1

a2122 1
        
a2131 1

d2156 2
d2160 3
a2162 3
	cmp	r1, r1, 0x197
	bb0	eq, r1, 1f
        
d2169 1
a2169 1
	/* reload the control regs*/
d2200 1
a2200 1
#ifdef MVME197 	
a2363 1

a2920 5
    *
#if INTSTACK
    * If interrupt exception, switch to interrupt stack if not
    * already there. Else, switch to kernel stack.
#endif
d2927 4
@


1.23
log
@Duplicate #include line.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.22 2001/12/14 04:30:11 smurph Exp $   */
d218 1
a218 1
#include <machine/param.h>          /* CPU_ and BRD_ defines */
d220 3
a222 1
#include <machine/board.h>
d240 2
a241 1
#define INTSTACK	0   /* To make interupts use their own stack */
a256 68
#define OFF_VEC		0
#define OFF_EPSR	4
#define OFF_EXIP	8
#define OFF_ENIP	12
#define OFF_DSR		16
#define OFF_DLAR	20
#define OFF_DPAR	24
#define OFF_ISR		28
#define OFF_ILAR	32
#define OFF_IPAR	36
#define OFF_TMP		40

/* 
 * This define is used to save exception register in case of 
 * the error exception XXX smurph
 */
#define SAVE_CR(CREG, OFF)			; \
	/* free r13 */				; \
	stcr	r13, SRX			; \
	/* save address of _savereg to r13 */	; \
	or.u	r13, r0,  hi16(_savereg)	; \
	or	r13, r13, lo16(_savereg)	; \
	/* store r1 to _temp_r1	*/		; \
	st	r1,  r13, OFF_TMP		; \
	/* r1 now free */			; \
	ldcr	r1,  CREG			; \
	st	r1,  r13, OFF			; \
	/* restore r1 */			; \
	ld	r1,  r13, OFF_TMP		; \
	/* restore r13 */			; \
	ldcr	r13, SRX
	
#define SAVE_R(REG, OFF)			; \
	/* free r13 */				; \
	stcr	r13, SRX			; \
	/* save address of _savereg to r13 */	; \
	or.u	r13, r0,  hi16(_savereg)	; \
	or	r13, r13, lo16(_savereg)	; \
	/* store reg */				; \
	st	REG, r13, OFF			; \
	/* restore r13 */			; \
	ldcr	r13, SRX

#define GET_R(REG, OFF)				; \
	/* free r13 */				; \
	stcr	r13, SRX			; \
	/* save r1 to _tmpreg */		; \
	/* save address of _savereg to r13 */	; \
	or.u	r13, r0,  hi16(_savereg)	; \
	or	r13, r13, lo16(_savereg)	; \
	/* store reg */				; \
	ld	REG, r13, OFF			; \
	/* restore r13 */			; \
	ldcr	r13, SRX
   
_savereg:
			word 0x00000063	/* 0   vector */
			word 0x00000000	/* 4   EXIP */
			word 0x00000000	/* 8   ENIP */
			word 0x00000000	/* 12  DSR  */
			word 0x00000000	/* 16  DLAR */
			word 0x00000000	/* 20  DPAR */
			word 0x00000000 /* 24  ISR  */
			word 0x00000000	/* 28  ILAR */
			word 0x00000000	/* 32  IPAR */
			word 0x00000000	/* 36  EPSR */
			word 0x00000000	/* 36  TMP  */

d289 1
a289 1
#ifdef M88100
d322 1
a322 1
#endif /* m88100 */
d324 1
a324 1
#ifdef M88110
d330 1
a330 26
	stcr    r1, SR2   /* r1 now free */		; \
/*	stcr    r3, SRX					; \
	ldcr    r1, DCTL				; \
	or	r3, r0, NUM				; \
	cmp	r3, r3, 3				; \
	bb1.n   ne, r3, 1f				; \
	set     r1, r1, 1<DCTL_MEN> 			; \
	clr     r1, r1, 1<DCTL_MEN>			; \
	set     FLAGS, FLAGS, 1<FLAG_TBE> 		; \
	1:stcr	r1, DCTL				; \
	ldcr  r3, SRX 	*/				; \
	/* save exception time regs */			; \
	or	r1, r0, NUM				; \
	cmp	r1, r1, 132				; \
	bb1	eq, r1, 1f				; \
	SAVE_CR(EPSR, OFF_EPSR)				; \
	SAVE_CR(EXIP, OFF_EXIP)				; \
	SAVE_CR(ENIP, OFF_ENIP)				; \
	SAVE_CR(DSR,  OFF_DSR)				; \
	SAVE_CR(DLAR, OFF_DLAR)				; \
	SAVE_CR(DPAR, OFF_DPAR)				; \
	SAVE_CR(ISR,  OFF_ISR)				; \
	SAVE_CR(ILAR, OFF_ILAR)				; \
	SAVE_CR(IPAR, OFF_IPAR)				; \
	or	r1, r0, NUM				; \
	SAVE_R(r1, OFF_VEC)				; \
d332 4
a335 4
1:	ldcr    r1, EPSR 				; \
	bb0.n   PSR_SUPERVISOR_MODE_BIT, r1, 1f 	; \
	clr     FLAGS, FLAGS, 1<FLAG_FROM_KERNEL> 	; \
	set     FLAGS, FLAGS, 1<FLAG_FROM_KERNEL>	; \
d338 1
a338 1
	1:	bsr	m88110_setup_phase_one		; \
d344 4
d350 1
a350 1
	bsr	m88110_setup_phase_two			; \
d354 1
a354 1
#endif /* M88110 */
d362 2
a363 2
#define M88110_Data_Precheck \
   bb1.n   FLAG_IGNORE_DATA_EXCEPTION, FLAGS, m88110_ignore_data_exception
d374 1
a375 2
GLOBAL(eh_debug)	word 0x00000000
   
d426 1
a426 1
#ifdef M88100
d433 3
a435 3
	PREP("unknown", 0, DEBUG_UNKNOWN_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_m88100_trap, T_UNKNOWNFLT, r30)
	DONE(DEBUG_UNKNOWN_BIT)
d439 5
a443 5
	PREP("interrupt", 1, DEBUG_INTERRUPT_BIT, No_SSBR_Stuff, No_Precheck)
	/* interrupt_func is set in mvme_bootstrap() */
	CALL(_m88100_trap, T_INT, r30)
	/*CALLP(_interrupt_func, 1, r30) */
	DONE(DEBUG_INTERRUPT_BIT)
d447 3
a449 3
	PREP("inst", 2, DEBUG_INSTRUCTION_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_m88100_trap, T_INSTFLT, r30)
	DONE(DEBUG_INSTRUCTION_BIT)
d456 2
a457 2
	PREP("data", 3, DEBUG_DATA_BIT, No_SSBR_Stuff, Data_Precheck)
	DONE(DEBUG_DATA_BIT)
d461 3
a463 3
	PREP("misalign", 4, DEBUG_MISALIGN_BIT, Clear_SSBR_Dest, No_Precheck)
	CALL(_m88100_trap, T_MISALGNFLT, r30)
	DONE(DEBUG_MISALIGN_BIT)
d467 3
a469 3
	PREP("unimp", 5, DEBUG_UNIMPLEMENTED_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_m88100_trap, T_ILLFLT, r30)
	DONE(DEBUG_UNIMPLEMENTED_BIT)
d477 8
a484 8
	stcr    r1, SR2    /* hold r1 for a moment */
	ldcr    r1, SXIP   /* look at the sxip... valid bit set? */
	bb1.n   RTE_VALID_BIT, r1, 1f /*skip over return if a valid exception*/
	ldcr    r1, SR2    /* restore r1 */
	RTE
1:	PREP("privilege", 6, DEBUG_PRIVILEGE_BIT, Clear_SSBR_Dest, No_Precheck)
	CALL(_m88100_trap, T_PRIVINFLT, r30) 
	DONE(DEBUG_PRIVILEGE_BIT)
d491 3
a493 3
	PREP("bounds", 7, DEBUG_BOUNDS_BIT, Clear_SSBR_Dest, No_Precheck)
	CALL(_m88100_trap, T_BNDFLT, r30)
	DONE(DEBUG_BOUNDS_BIT)
d497 3
a499 3
	PREP("divide", 8, DEBUG_DIVIDE_BIT, Clear_SSBR_Dest, No_Precheck)
	CALL(_m88100_trap, T_ZERODIV, r30)
	DONE(DEBUG_DIVIDE_BIT)
d503 3
a505 3
	PREP("overflow", 9, DEBUG_OVERFLOW_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_m88100_trap, T_OVFFLT, r30)
	DONE(DEBUG_OVERFLOW_BIT)
d510 3
a512 3
	PREP("FPU precise", 114, DEBUG_FPp_BIT, FPp_SSBR_STUFF, No_Precheck)
	CALL(_m88100_Xfp_precise, r0, r30) /* call fp_precise(??, exception_frame)*/
	DONE(DEBUG_FPp_BIT)
d517 3
a519 3
	PREP("FPU imprecise", 115, DEBUG_FPi_BIT, FPi_SSBR_STUFF, No_Precheck)
	CALL(_Xfp_imprecise, r0, r30) /*call fp_imprecise(??,exception_frame)*/
	DONE(DEBUG_FPi_BIT)
d523 4
a526 4
	PREP("syscall", 128, DEBUG_SYSCALL_BIT, No_SSBR_Stuff, No_Precheck)
	ld   r13, r30, GENREG_OFF(13)
	CALL(_m88100_syscall, r13, r30) /* system call no. is in r13 */
	DONE(DEBUG_SYSCALL_BIT)
d530 4
a533 4
	PREP("bugsyscall", 496, DEBUG_BUGCALL_BIT, No_SSBR_Stuff, No_Precheck)
	ld   r9,  r30, GENREG_OFF(9)
	CALL(_bugsyscall, r9, r30)   /* system call no. is in r9 */
	DONE(DEBUG_BUGCALL_BIT)
d536 3
a538 3
	PREP("sigsys", 0, DEBUG_SIGSYS_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_m88100_trap, T_SIGSYS, r30)
	DONE(DEBUG_SIGSYS_BIT)
d541 3
a543 3
	PREP("sigtrap", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_m88100_trap, T_SIGTRAP, r30)
	DONE(DEBUG_SIGTRAP_BIT)
d546 3
a548 3
	PREP("stepbpt", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_m88100_trap, T_STEPBPT, r30)
	DONE(DEBUG_SIGTRAP_BIT)
d551 3
a553 3
	PREP("userbpt", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_m88100_trap, T_USERBPT, r30)
	DONE(DEBUG_SIGTRAP_BIT)
d556 13
a568 14
ASGLOBAL(break)
	PREP("break", 130, DEBUG_BREAK_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_m88100_trap, T_KDB_BREAK, r30)
	DONE(DEBUG_BREAK_BIT)

ASGLOBAL(trace)
	PREP("trace", 131, DEBUG_TRACE_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_m88100_trap, T_KDB_TRACE, r30)
	DONE(DEBUG_TRACE_BIT)

GLOBAL(entry)
	PREP("kdb", 132, DEBUG_KDB_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_m88100_trap, T_KDB_ENTRY, r30)
	DONE(DEBUG_KDB_BIT)
d571 12
a582 14
ASGLOBAL(break)
	PREP("break", 130, DEBUG_BREAK_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_m88100_trap, T_UNKNOWNFLT, r30)
	DONE(DEBUG_BREAK_BIT)

ASGLOBAL(trace)
	PREP("trace", 131, DEBUG_TRACE_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_m88100_trap, T_UNKNOWNFLT, r30)
	DONE(DEBUG_TRACE_BIT)

GLOBAL(entry)
	PREP("unknown", 132, DEBUG_UNKNOWN_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_m88100_trap, T_UNKNOWNFLT, r30)
	DONE(DEBUG_KDB_BIT)
d687 3
a689 3
	or.u	r10,  r0,   hi16(_brdtyp)
	ld	r11,  r10,  lo16(_brdtyp)
	cmp	r10,  r11,  BRD_188
d693 1
a693 1
	st	r11, r31,   REG_OFF(EF_MASK) /* put in EF_MASK for regdump */ 
d899 1
a899 1
#endif /* m88100 */
d901 1
a901 1
#ifdef M88110
d905 1
a905 1
ASGLOBAL(m88110_ignore_data_exception)
d908 1
a908 1
	*  SR1: previous FLAGS reg                             *
d910 1
a910 1
	*  SR3: must preserve                                  *
d918 1
a918 1
	 * We just want to jump to "m88110_badaddr__return_nonzero" below.
d925 3
a927 3
	or.u	r2, r0, hi16(m88110_badaddr__return_nonzero)
	or	r2, r2, lo16(m88110_badaddr__return_nonzero)
	stcr	r2, EXIP   /* Make it the next instruction to execute */
d929 1
a929 1
	/* the following jumps to "m88110_badaddr__return_nonzero" below */ 
d932 1
a932 1
#endif /* M88110 */
d957 4
a960 4
	/*
	 * Disable interrupts ... don't want a context switch while we're
	 * doing this! Also, save the old PSR in R8 to restore later.
	 */
a1055 12
ASGLOBAL(m88110_badaddr__return_nonzero)
	/* 
	 * On mc88110, we possibly took an exception 
	 * and we have to clear DSR after the rte
	 * instruction clears the EFRZ bit in 
	 * the PSR. 
	 */
	stcr r0, DSR	/* Clear DSR reg on mc88110 */
	stcr r0, DLAR	/* Clear DLAR reg on mc88110 */
	br.n badaddr__return_nonzero
	stcr r0, DPAR	/* Clear DPAR reg on mc88110 */

d1062 1
a1062 1
#ifdef M88100 
d1065 16
a1080 16
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread (if any, null if not)                     *
	* SR1: saved copy of exception-time register now holding FLAGS  *
	* SR2: saved copy of exception-time r1                          *
	* SR3: must be preserved .. may be the exception-time stack     *
	* r1: return address to calling exception handler               *
	* FLAGS: CPU status flags                                       *
	***************************************************             *
	* immediate goal:                                               *
	*    Decide where we're going to put the exception frame.       *
	*   Might be at the end of R31, SR3, or the thread's            *
	*   pcb.                                                        *
	\***************************************************************/
	
	/* Check if we are coming in from a FPU restart exception.
	   If so, the pcb will be in SR3 */
d1088 1
a1088 1
	/* are we coming in from user mode? If so, pick up thread pcb */
d1091 1
a1091 1
	/* Interrupt in kernel mode, not FPU restart */
d1093 12
a1104 12
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread (if any, null if not)                     *
	* SR1: saved copy of exception-time register now holding FLAGS  *
	* SR2: return address to the calling exception handler          *
	* SR3: must be preserved; may be important for other exceptions *
	* FLAGS: CPU status flags                                       *
	***************************************************             *
	* immediate goal:                                               *
	*   We're already on the kernel stack, but not having           *
	*   needed to use SR3. We can just make room on the             *
	*    stack (r31) for our exception frame.                       *
	\***************************************************************/
d1118 23
a1140 23
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread (if any, null if not)                     *
	* SR1: saved copy of exception-time register now holding FLAGS  *
	* SR2: return address to the calling exception handler          *
	* SR3: must be preserved; exception-time stack pointer          *
	* FLAGS: CPU status flags                                       *
	***************************************************             *
	* immediate goal:                                               *
	*   An exception occured while enabling the FPU. Since r31      *
	*   is the user's r31 while enabling the FPU, we had put        *
	*   our pcb pointer into SR3, so make room from                 *
	*   there for our stack pointer.                                *
	*       We need to check if SR3 is the old stack pointer or the *
	*       pointer off to the user pcb. If it pointing to the user *
	*       pcb, we need to pick up the kernel stack. Otherwise     *
	*       we need to allocate a frame upon it.                    *
	*       We look at the EPSR to see if it was from user mode     *
	*       Unfortunately, we have no registers free at the moment  *
	*       But we know register 0 in the pcb frame will always be  *
	*       zero, so we can use it as scratch storage.              *
	*                                                               *
	*                                                               *
	\***************************************************************/
d1146 1
a1146 1
	/* we were in kernel mode - dump frame upon the stack */
d1159 4
a1162 4
	/* we took an exception while restarting the FPU from user space.
	 * Consequently, we never picked up a stack. Do so now.
	 * R1 is currently free (saved in the exception frame pointed at by
	 * r30) */
d1177 12
a1188 12
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                          *
	* SR1: saved copy of exception-time register now holding FLAGS *
	* SR2: return address to the calling exception handler         *
	* SR3: free                                                    *
	* FLAGS: CPU status flags                                      *
	***************************************************            *
	* immediate goal:                                              *
	*    Since we're servicing an exception from user mode, we     *
	*   know that SR3 is free.  We use it to free up a temp.       *
	*   register to be used in getting the thread's pcb            *
	\***************************************************************/
d1191 1
a1191 1
	/* switch to the thread's kernel stack. */
d1199 1
a1199 1
	/*FALLTHROUGH */
d1238 3
a1240 3
	or.u	TMP,  r0,   hi16(_brdtyp)
	ld	TMP2, TMP,  lo16(_brdtyp)
	cmp	TMP,  TMP2, BRD_188
d1400 19
a1418 19
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                          *
	* SR1: saved copy of exception-time register now holding FLAGS *
	* SR2: return address to the calling exception handler         *
	* SR3: saved TMP                                               *
	* r1:  free                                                    *
	* TMP: possibly revised SSBR                                   *
	* TMP2: free                                                   *
	* TMP3: free                                                   *
	* FLAGS: CPU status flags                                      *
	* r31: exception frame                                         *
	*    Valid in the exception frame:                             *
	*   Exception-time r1, r31, FLAGS.                             *
	*   Exception-time TMP2, TMP3.                                 *
	*   Exception-time espr, sfip, snip, sxip.                     *
	*   Dmt0.                                                      *
	*   Other data pipeline control registers, if appropriate.     *
	*   Exception SR3, if appropriate.                             *
	\***************************************************************/
d1422 1
a1422 1
#endif /* m88100 */
d1428 9
a1436 9
	/*
	 * Clear floatingpont-imprecise ssbr bits.
	 * Also, save appropriate FPU control registers to the E.F.
	 *
	 *  r1:  return address to calling exception handler
	 *  TMP : (possibly) revised ssbr
	 *  TMP2 : free
	 *  TMP3 : free
	 */
d1452 4
a1455 4
	/*
	 * We only need clear the bit in the SSBR for the
	 * 2nd reg of a double result [see section 6.8.5]
	 */
d1471 28
a1498 28
	/*
	 * Clear floating pont precise ssbr bits.
	 * Also, save appropriate FPU control registers to the E.F.
	 *
	 *  r1:  return address to calling exception handler
	 *  TMP : (possibly) revised ssbr
	 *  TMP2 : free
	 *  TMP3 : free
	 */
	fldcr TMP2, FPSR
	fldcr TMP3, FPCR
	st    TMP2, r31,  REG_OFF(EF_FPSR)
	st    TMP3, r31,  REG_OFF(EF_FPCR)
	
	fldcr TMP3, FPECR
	st    TMP3, r31,  REG_OFF(EF_FPECR)
	fldcr TMP2, FPHS1
	fldcr TMP3, FPHS2
	st    TMP2, r31,  REG_OFF(EF_FPHS1)
	st    TMP3, r31,  REG_OFF(EF_FPHS2)
	
	fldcr TMP2, FPLS1
	fldcr TMP3, FPLS2
	st    TMP2, r31,  REG_OFF(EF_FPLS1)
	st    TMP3, r31,  REG_OFF(EF_FPLS2)
	
	fldcr TMP2, FPPT
	st    TMP2, r31,  REG_OFF(EF_FPPT)
d1502 9
a1510 7
	bb1.n FPPT_SIZE_BIT, TMP2, 2f
	extu  TMP3, TMP2, 5<0> /* get FP operation dest reg */
	br.n  3f
	set   TMP3, TMP3, 1<5> /* set size=1 -- clear one bit for "float" */
2:	set   TMP3, TMP3, 1<6> /* set size=2 -- clear two bit for "double" */ 
3:	clr   TMP,  TMP,  TMP3   /* clear bit(s) in ssbr. */
4:	jmp   r1
d1516 1
d1518 32
a1549 32
	/*
	 * There are various cases where an exception can leave the
	 * destination register's bit in the SB set.
	 * Examples:
	 *   misaligned or privilege exception on a LD or XMEM
	 *   DIV or DIVU by zero.
	 *
	 * I think that if the instruction is LD.D, then two bits must
	 * be cleared.
	 *
	 * Even though there are a number of instructions/exception
	 * combinations that could fire this code up, it's only required
	 * to be run for the above cases.  However, I don't think it'll
	 * ever be a problem to run this in other cases (ST instructions,
	 * for example), so I don't bother checking.  If we had to check
	 * for every possible instruction, this code would be much larger.
	 *
	 * The only checking, then, is to see if it's a LD.D or not.
	 *
	 * At the moment....
	 *  r1:  return address to calling exception handler
	 *  TMP : (possibly) revised ssbr
	 *  TMP2 : free
	 *  TMP3 : free
	 */
	
	ldcr  TMP3, EPSR   /* going to check: user or system memory? */
	ldcr  TMP2, SXIP   /* get the instruction's address */
	bb1.n PSR_SUPERVISOR_MODE_BIT, TMP3, 2f
	clr   TMP2, TMP2, 2<0> /* get rid of valid and error bits. */
	
1:	/* user space load here */
d1551 6
a1556 6
	NOP
	ld.usr TMP2,TMP2, r0      /* get the instruction itself */
	NOP
	NOP
	NOP
	br    3f
d1558 2
a1559 2
	br.n  3f
	ld.usr TMP2,TMP2, r0      /* get the instruction itself */
d1562 40
a1601 2
2:	/* system space load here */
	ld    TMP2, TMP2, r0      /* get the instruction itself */
a1602 38
3:	/* now have the instruction..... */
	/*
	 * Now see if it's a double load
	 * There are three forms of double load [IMM16, scaled, unscaled],
	 * which can be checked by matching against two templates:
	 *          -- 77776666555544443333222211110000 --
	 *   if (((instruction & 11111100000000000000000000000000) ==
	 *             00010000000000000000000000000000) ;;
	 *       ((instruction & 11111100000000001111110011100000) ==
	 *             11110100000000000001000000000000))
	 *   {
	 *      It's a load double, so
	 *      clear two SSBR bits.
	 *   } else {
	 *      It's not a load double.
	 *      Must be a load single, xmem, or st
	 *      Thus, clear one SSBR bit.
	 *   }
	 */
	/* check the first pattern for ld.d */
	extu  TMP3, TMP2, 16<16>   /* get the upper 16 bits */
	mask  TMP3, TMP3, 0xFC00   /* apply the mask */
	cmp   TMP3, TMP3, 0x1000   /* if this is equal, it's a load double */
	bb1   eq,   TMP3, misaligned_double
	
	/* still could be -- check the second pattern for ld.d */
	/* look at the upper 16 bits first */
	extu  TMP3, TMP2, 16<16>   /* get the upper 16 bits */
	mask  TMP3, TMP3, 0xFC00   /* apply the mask */
	cmp   TMP3, TMP3, 0xF400   /* if equal, it might be a load double */
	bb1   ne,   TMP3, misaligned_single /* not equal, so must be single */
	
	/* now look at the lower 16 bits */
	extu  TMP3, TMP2, 16<0>    /* get the lower 16 bits */
	mask  TMP3, TMP3, 0xFCE0   /* apply the mask */
	cmp   TMP3, TMP3, 0x1000   /* if this is equal, it's a load double */
	bb1   eq,   TMP3, misaligned_double
	
d1604 3
a1606 3
	extu  TMP2, TMP2, 5<21>    /* get the destination register */
	br.n  1f
	set   TMP2, TMP2, 1<5>     /* set size=1 */
d1609 2
a1610 2
	extu  TMP2, TMP2, 5<21>    /* get the destination register */
	set   TMP2, TMP2, 1<6>     /* set size=2 -- clear two bit for "ld.d" */
d1612 2
a1613 2
1:	jmp.n   r1
	clr   TMP,  TMP,  TMP2     /* clear bit(s) in ssbr. */
d1618 1
a1618 1
#ifdef M88100
d1621 32
a1652 32
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: saved return address to calling exception handler        *
	* SR1: saved copy of exception-time register now holding FLAGS  *
	* SR2: free                                                     *
	* SR3: saved TMP                                                *
	* r1:  return address to calling exception handler              *
	* TMP: possibly revised SSBR                                    *
	* TMP2: free                                                    *
	* TMP3: free                                                    *
	* FLAGS: CPU status flags                                       *
	* r31: our exception frame                                      *
	*    Valid in the exception frame:                              *
	*   Exception-time r1, r31, FLAGS.                              *
	*   Exception-time TMP2, TMP3.                                  *
	*   Exception-time espr, sfip, snip, sxip.                      *
	*   Exception number (EF_VECTOR).                               *
	*   Dmt0                                                        *
	*   Other data pipeline control registers, if appropriate.      *
	*   FPU control registers, if appropriate.                      *
	*   Exception SR3, if appropriate.                              *
	***************************************************             *
	* immediate goal:                                               *
	*   restore the system to the exception-time state (except      *
	* SR3 will be OUR stack pointer) so that we may resart the FPU. *
	\***************************************************************/
	/*stcr   r1, SR0*/      /* save return address */
	
	stcr  TMP,  SSBR   /* done with SSBR, TMP now free */
	RESTORE_TMP2      /* done with extra temp regs */
	RESTORE_TMP3      /* done with extra temp regs */
	
	/* Get the current PSR and modify for the rte to enable the FPU */
d1654 11
a1664 11
	ldcr  TMP,  PSR
	clr   TMP,  TMP,  1<PSR_FPU_DISABLE_BIT>    /* enable the FPU */
	clr   TMP,  TMP,  1<PSR_SHADOW_FREEZE_BIT>  /* also enable shadowing */
	stcr  TMP,  EPSR
	
	/* the "+2" below is to set the VALID_BIT */
	or.u  TMP,  r0,   hi16(fpu_enable +2)
	or    TMP,  TMP,  lo16(fpu_enable +2)
	stcr  TMP,  SNIP      /* jump to here fpu_enable */
	addu  TMP,  TMP,  4
	stcr  TMP,  SFIP      /* and then continue after that */
d1666 10
a1675 10
	ldcr  TMP,  PSR
	or.u  TMP,  TMP,  0x8000    /* set supervisor mode */
	and   TMP,  TMP,  0xfff7    /* also enable shadowing */
	stcr  TMP,  EPSR
	stcr  r0,   SXIP       /* clear valid bit */
	stcr  r0,   SNIP       /* clear valid bit */
	or.u  TMP,  r0,   hi16(fpu_enable)
	or    TMP,  TMP,  lo16(fpu_enable)
	or    TMP,  TMP,  0x2 /* set the VALID_BIT and clear Exception bit */
	stcr  TMP,  SFIP      /* jump to here fpu_enable */
d1679 34
a1712 34
	set   FLAGS, FLAGS, 1<FLAG_ENABLING_FPU> /* note what we're doing.*/
	xcr   FLAGS, FLAGS, SR1
	st    r1,   r31,  REG_OFF(EF_RET) /* save the return address */
	ld    r1,   r31,  GENREG_OFF(1)    /* get original r1 */
	
	xcr   TMP,  r31,  SR3   /* TMP now restored. R31 now saved in SR3 */
	ld    r31,  r31,  GENREG_OFF(31) /* get original r31 */
	
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                           *
	* SR1: CPU flags                                                *
	* SR2: free                                                     *
	* SR3: pointer to our exception frame (our stack pointer)       *
	* r1 through r31: original exception-time values                *
	*                                                               *
	* Valid in the exception frame:                                 *
	*   Exception-time FLAGS.                                       *
	*   Exception-time espr, sfip, snip, sxip.                      *
	*   Exception number (EF_VECTOR).                               *
	*   Dmt0                                                        *
	*   Other data pipeline control registers, if appropriate.      *
	*   FPU control registers, if appropriate.                      *
	*   Exception SR3, if appropriate.                              *
	*   Held temporarly in the exception frame:                     *
	*   Return address to the calling excption handler.             *
	***************************************************             *
	* immediate goal:                                               *
	*   Do an RTE to restart the fpu and jump to "fpu_enable"       *
	*   Another exception (or exceptions) may be raised in          *
	*   this, which is why FLAG_ENABLING_FPU is set in SR1.         *
	\***************************************************************/
	
	RTE   /* jumps to "fpu_enable" on the next line to enable the FPU. */
	
d1714 29
a1742 29
	FLUSH_PIPELINE
	xcr   TMP,  TMP,  SR3               /* get E.F. pointer */
	st.d  r30,  TMP,  GENREG_OFF(30)    /* save previous r30, r31 */
	or    r31,  TMP,  r0                /* transfer E.F. pointer to r31 */
	ld    TMP,  r31,  REG_OFF(EF_SR3)   /* get previous SR3; maybe important*/
	
	/* make sure that the FLAG_ENABLING_FPU bit is off */
	xcr   FLAGS,FLAGS,SR1
	clr   FLAGS,FLAGS,1<FLAG_ENABLING_FPU>
	xcr   FLAGS,FLAGS,SR1
	
	xcr   TMP,  TMP,  SR3       /* replace TMP, SR3 */
	
	/* now save all regs to the exception frame. */
	st.d  r0 ,  r31,  GENREG_OFF(0)
	st.d  r2 ,  r31,  GENREG_OFF(2)
	st.d  r4 ,  r31,  GENREG_OFF(4)
	st.d  r6 ,  r31,  GENREG_OFF(6)
	st.d  r8 ,  r31,  GENREG_OFF(8)
	st.d  r10,  r31,  GENREG_OFF(10)
	st.d  r12,  r31,  GENREG_OFF(12)
	st.d  r14,  r31,  GENREG_OFF(14)
	st.d  r16,  r31,  GENREG_OFF(16)
	st.d  r18,  r31,  GENREG_OFF(18)
	st.d  r20,  r31,  GENREG_OFF(20)
	st.d  r22,  r31,  GENREG_OFF(22)
	st.d  r24,  r31,  GENREG_OFF(24)
	st.d  r26,  r31,  GENREG_OFF(26)
	st.d  r28,  r31,  GENREG_OFF(28)
d1744 41
a1784 41
	/* mark beginning of frame with notable value */
	or.u  r20,  r0,   hi16(0x12345678)
	or    r20,  r20,  lo16(0x12345678)
	st    r20,  r31,  GENREG_OFF(0)
#endif
	
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                           *
	* SR1: free                                                     *
	* SR2: free                                                     *
	* SR3: previous exception-time SR3                              *
	* r1: return address to the calling exception handler           *
	* r2 through r30: free                                          *
	* r31: our exception frame                                      *
	*                                                               *
	* Valid in the exception frame:                                 *
	*   Exception-time r0 through r31.                              *
	*   Exception-time FLAGS.                                       *
	*   Exception-time espr, sfip, snip, sxip.                      *
	*   Exception number (EF_VECTOR).                               *
	*   Dmt0                                                        *
	*   Other data pipeline control registers, if appropriate.      *
	*   FPU control registers, if appropriate.                      *
	*   Exception SR3, if appropriate.                              *
	***************************************************             *
	* immediate goal:                                               *
	*   Pick up a stack if we came in from user mode. Put           *
	*       A copy of the exception frame pointer into r30          *
	*       bump the stack a doubleword and write the exception     *
	*       frame pointer.                                          *
	*   if not an interrupt exception,                              *
	*       Turn on interrupts and service any outstanding          *
	*       data access exceptions.                                 *
	*   Return to calling exception handler to                      *
	*   service the exception.                                      *
	\***************************************************************/
	
	/*
	 * If it's not the interrupt exception, enable interrupts and
	 * take care of any data access exceptions......
	 */
d1786 2
a1787 4
	/*
	 * If interrupt exception, switch to interrupt stack if not
	 * already there. Else, switch to kernel stack.
	 */
d1789 4
a1792 3
	or    r30,  r0,   r31		/* get a copy of the e.f. pointer */ 
	ld    r2,   r31,  REG_OFF(EF_EPSR)
	bb1   PSR_SUPERVISOR_MODE_BIT, r2, 1f  /* If in kernel mode */
d1795 6
a1800 6
	ld    r3,   r31,  REG_OFF(EF_VECTOR)
	cmp   r3,   r3,   1      /* is interrupt ? */
	bb0   eq,   r3,   2f
	or.u  r31,  r0,   hi16(_intstack_end)   /* swith to int stack */
	or    r31,  r31,  lo16(_intstack_end)
	br    3f
d1803 4
a1806 4
	or.u  r31,  r0,   hi16(_kstack)
	ld    r31,  r31,  lo16(_kstack)
	addu  r31,  r31,  USIZE        /* point at proper end */
	br    3f
d1809 5
a1813 5
	ld    r3,   r31,  REG_OFF(EF_VECTOR)
	cmp   r3,   r3,   1       /* is interrupt ? */
	bb0   eq,   r3,   3f      /* no, we will stay on kern stack */
	or.u  r31,  r0,   hi16(_intstack_end)   /* swith to int stack */
	or    r31,  r31,  lo16(_intstack_end)
d1815 1
a1815 1
	/* This label is here for debugging */
d1817 6
a1822 6
3:	/*
	 * here - r30 holds a pointer to the exception frame.
	 * r31 is a pointer to the kernel stack/interrupt stack.
	*/
	subu  r31,  r31,  8  /* make some breathing space */
	st    r30,  r31,  0  /* store frame pointer on the stack */
d1824 1
a1824 1
	st    r30,  r31,  4  /* store it again for the debugger to recognize */
d1827 5
a1831 5
	ld    r2,   r30,  REG_OFF(EF_VECTOR)
	bcnd.n eq0, r2,   return_to_calling_exception_handler  /* is error */
	ld    r14,  r30,  REG_OFF(EF_RET)
	cmp   r3,   r2,   1 /* interrupt is exception #1 ;Is an interrupt? */
	bb1.n eq,   r3,   return_to_calling_exception_handler /* skip if so */
d1834 5
a1838 4
	cmp   r3,   r2,   130 /* DDB break exception */
	bb1.n eq,   r3,   return_to_calling_exception_handler
	cmp   r3,   r2,   132 /* DDB entry exception */
	bb1.n eq,   r3,   return_to_calling_exception_handler
d1841 3
a1843 3
	ldcr  r2,   PSR
	clr   r2,   r2,   1<PSR_INTERRUPT_DISABLE_BIT>   /* enable interrupts */
	stcr  r2,   PSR
d1845 1
a1845 1
	FLUSH_PIPELINE
d1848 2
a1849 2
	/* service any outstanding data pipeline stuff
	   - check dmt0 anything outstanding?*/
d1851 2
a1852 2
	ld    r3,   r30,  REG_OFF(EF_DMT0)
	bb0   DMT_VALID_BIT, r3, return_to_calling_exception_handler
d1854 5
a1858 5
	/*
	  r30 can be clobbered by calls. So stuff its value into a
	  preserved register, say r15. R14 is in use (see return_to_... below). 
	 */
	or    r15,  r0,   r30
d1860 2
a1861 2
	CALL(_m88100_trap, T_DATAFLT, r15)
	CALL(_data_access_emulation, r15, r0)
d1863 2
a1864 2
	/*   restore it... */
	or    r30,  r0,   r15
d1866 2
a1867 2
	/* clear the dmt0 word in the E.F */
	st    r0,   r30,  REG_OFF(EF_DMT0)
d1870 2
a1871 2
	jmp   r14 /* loaded above */
#endif /* m88100 */
d1884 10
a1893 10
	ld	r1,r31,0	/* load func */
	ld	r2,r31,4 	/* load proc pointer */
	jsr.n	r1
	subu	r31,r31,40	/* create stack space for function */
	addu	r31,r31,48	/* stack space above + ksigframe */
	ld	r1, r31,0	/* load pc */
	ld	r2, r31,4	/* & proc pointer from switch frame */ 
	jsr.n	r1
	addu	r31,r31,8
	bsr	_panic
d1904 4
a1907 4
	ld	r3,r2,P_ADDR		/* p->p_addr */
	addu	r3,r3,PCB_USER_STATE	/* p->p_addr.u_pcb.user_state */
	st	r3,r31,0		/* put it on the stack */
	br	return_from_exception_handler
d1927 1
a1927 1
#ifdef M88110	
d1930 2
a1931 2
	cmp	r2, r3, CPU_88110
	bb1	eq, r2, m88110_return_code        
d1933 3
a1935 1
#ifdef M88100
d1942 4
a1945 4
	/*
	 * This might happen for non-interrupts  If the user sets DMT0
	 * in an exception handler.........
	 */
d1962 9
a1970 9
	/*
	 * If it's the interrupt exception, enable interrupt.
	 * Take care of any data access exception...... 90/8/15 add by yama
	 */
	
	/*
	 * Is it ever possible to have interrupt exception while EPSR has
	 * it disabled? I don't think so.. XXX nivas
	 */
d1975 1
a1975 1
	/* if EPSR has interrupts disabled, skip also */
d1977 1
a1977 1
        bb1   PSR_INTERRUPT_DISABLE_BIT, r2, 1f		/* skip if disabled */
d1979 2
a1980 2
	clr   r2, r2, 1<PSR_INTERRUPT_DISABLE_BIT>	/* enable interrupts */
	FLUSH_PIPELINE
d1982 1
a1982 1
1:
d1986 5
a1990 5
	/*
	 * if there happens to be a data fault that hasn't been serviced yet,
	 * go off and service that...
	 */
	CALL(_m88100_trap, T_DATAFLT, r30)
d1992 2
a1993 1
	/* clear the dmt0 word in the E.F. */
d1995 1
a1995 1
2:
d1997 4
a2000 4
#endif /* m88100 */

#ifdef M88110
ASLOCAL(m88110_return_code)
d2003 3
d2007 1
d2009 2
a2010 2
	 * If it's the interrupt exception, enable interrupt.
	 * If it's the data access exception, take care of it.
d2012 20
d2033 4
a2036 6
	/*
	 * Is it ever possible to have interrupt exception while EPSR has
	 * it disabled? I don't think so.. XXX nivas
	 * 
	 * On mc88110, you can.  The NMI interrupt. aka ABORT. XXX smurph
	 */
d2038 2
a2039 2
	cmp	r2, r2, 1   /* Is it an interrupt? */ 
	bb1	ne, r2, 1f  /* If not, skip */
d2041 1
a2041 1
	/* if EPSR has interrupts disabled, skip also */
d2049 3
a2051 3
	ld	r2, FPTR, REG_OFF(EF_VECTOR)
	cmp	r3, r2, 3   /* Is it a data access exception? */ 
	bb1	ne, r3, 2f  /* If not, skip */
d2053 5
a2057 5
	/*
	 * if there happens to be a data fault that hasn't been serviced yet,
	 * go off and service that...
	 */
	CALL(_m88110_trap, T_DATAFLT, r30)
d2059 1
a2059 1
	/* clear the dsr word in the E.F. */
a2060 2
	st	r0, FPTR, REG_OFF(EF_DLAR)
	st	r0, FPTR, REG_OFF(EF_DPAR)
d2062 1
a2062 1
#endif /* M88110 */
d2074 1
a2074 1
        bcnd    ne0, r2, 1f		/* can't do softint's */
a2078 1
	/* at ipl 1 now */	
d2084 1
a2084 1
        or      r2,r0,0			/* ints are enabled */
d2100 3
a2102 1
#ifdef M88110         
d2105 11
a2115 4
	cmp	r2, r3, CPU_88110
	bb0	eq, r2, 2f
        CALL(_m88110_trap, T_ASTFLT, FPTR)
	br	no_ast
a2117 3
#ifdef M88100
        CALL(_m88100_trap, T_ASTFLT, FPTR)
#endif
d2123 1
a2123 1
        bcnd    eq0, r2, 3f
d2125 1
a2125 1
3:
d2131 1
d2138 1
d2148 1
a2172 2
	/* reload the control regs*/
#ifdef M88110
d2174 2
a2175 2
	ld	r30, r1, lo16(_cputyp)
	cmp	r1, r30, CPU_88110
d2177 5
a2181 5
        /* mc88110 needs the EXIP */
	ld      r30, r31, REG_OFF(EF_ENIP)
        ld      r1,  r31, REG_OFF(EF_EXIP)
        stcr    r30, ENIP
        stcr    r1,  EXIP
d2183 2
a2184 2
1:
#endif 
d2215 1
a2215 1
#ifdef M88110 	
d2221 4
a2224 4
GLOBAL(m88110_unknown_handler)
	PREP2("unknown", 0, DEBUG_UNKNOWN_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_UNKNOWNFLT, r30)
	DONE(DEBUG_UNKNOWN_BIT)
d2227 4
a2230 4
GLOBAL(m88110_interrupt_handler)
	PREP2("interrupt", 1, DEBUG_INTERRUPT_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_m88110_trap, T_INT, r30)
	DONE(DEBUG_INTERRUPT_BIT)
d2233 5
a2237 4
GLOBAL(m88110_instruction_access_handler)
	PREP2("inst", 2, DEBUG_INSTRUCTION_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_m88110_trap, T_INSTFLT, r30)
	DONE(DEBUG_INSTRUCTION_BIT)
d2242 3
a2244 3
GLOBAL(m88110_data_exception_handler)
	PREP2("data", 3, DEBUG_DATA_BIT, No_SSBR_Stuff, M88110_Data_Precheck)
	DONE(DEBUG_DATA_BIT)
d2247 4
a2250 4
GLOBAL(m88110_misaligned_handler)
	PREP2("misalign", 4, DEBUG_MISALIGN_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_m88110_trap, T_MISALGNFLT, r30)
	DONE(DEBUG_MISALIGN_BIT)
d2253 4
a2256 4
GLOBAL(m88110_unimplemented_handler)
	PREP2("unimp", 5, DEBUG_UNIMPLEMENTED_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_m88110_trap, T_ILLFLT, r30)
	DONE(DEBUG_UNIMPLEMENTED_BIT)
d2259 4
a2262 4
GLOBAL(m88110_privilege_handler)
	PREP2("privilege", 6, DEBUG_PRIVILEGE_BIT, No_SSBR_Stuff, No_Precheck) 
	CALL(_m88110_trap, T_PRIVINFLT, r30)
	DONE(DEBUG_PRIVILEGE_BIT)
d2268 4
a2271 4
GLOBAL(m88110_bounds_handler)
	PREP2("bounds", 7, DEBUG_BOUNDS_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_m88110_trap, T_BNDFLT, r30)
	DONE(DEBUG_BOUNDS_BIT)
d2274 4
a2277 4
GLOBAL(m88110_divide_handler)
	PREP2("divide", 8, DEBUG_DIVIDE_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_m88110_trap, T_ZERODIV, r30)
	DONE(DEBUG_DIVIDE_BIT)
d2280 4
a2283 4
GLOBAL(m88110_overflow_handler)
	PREP2("overflow", 9, DEBUG_OVERFLOW_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_m88110_trap, T_OVFFLT, r30)
	DONE(DEBUG_OVERFLOW_BIT)
d2286 10
a2295 10
GLOBAL(m88110_fp_precise_handler)
	PREP2("FPU precise", 114, DEBUG_FPp_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_m88110_Xfp_precise, r0, r30) /* call fp_precise(??, exception_frame)*/
	DONE(DEBUG_FPp_BIT)

/* MVME197 non-maskable interrupt handler (ABORT button) */
GLOBAL(m88110_nonmaskable)
	PREP2("MVME197 non-mask", 11, DEBUG_NON_MASK_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_m88110_trap, T_NON_MASK, r30)
	DONE(DEBUG_NON_MASK_BIT)
d2298 4
a2301 4
GLOBAL(m88110_data_read_miss)
	PREP2("MVME197 read miss", 12, DEBUG_197_READ_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_m88110_trap, T_197_READ, r30)
	DONE(DEBUG_197_READ_BIT)
d2304 4
a2307 4
GLOBAL(m88110_data_write_miss)
	PREP2("MVME197 write miss", 13, DEBUG_197_WRITE_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_m88110_trap, T_197_WRITE, r30)
	DONE(DEBUG_197_WRITE_BIT)
d2310 4
a2313 4
GLOBAL(m88110_inst_atc_miss)
	PREP2("MVME197 inst miss", 14, DEBUG_197_INST_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_m88110_trap, T_197_INST, r30)
	DONE(DEBUG_197_INST_BIT)
d2316 5
a2320 5
GLOBAL(m88110_syscall_handler)
	PREP2("syscall", 128, DEBUG_SYSCALL_BIT, No_SSBR_Stuff, No_Precheck)
	ld   r13, r30, GENREG_OFF(13)
	CALL(_m88110_syscall, r13, r30) /* system call no. is in r13 */
	DONE(DEBUG_SYSCALL_BIT)
d2323 25
a2347 25
GLOBAL(m88110_bugtrap)
	PREP2("bugsyscall", 496, DEBUG_BUGCALL_BIT, No_SSBR_Stuff, No_Precheck)
	ld   r9,  r30, GENREG_OFF(9)
	CALL(_bugsyscall, r9, r30)   /* system call no. is in r9 */
	DONE(DEBUG_BUGCALL_BIT)

GLOBAL(m88110_sigsys)
	PREP2("sigsys", 0, DEBUG_SIGSYS_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_m88110_trap, T_SIGSYS, r30)
	DONE(DEBUG_SIGSYS_BIT)

GLOBAL(m88110_sigtrap)
	PREP2("sigtrap", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_m88110_trap, T_SIGTRAP, r30)
	DONE(DEBUG_SIGTRAP_BIT)

GLOBAL(m88110_stepbpt)
	PREP2("sigtrap", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_m88110_trap, T_STEPBPT, r30)
	DONE(DEBUG_SIGTRAP_BIT)

GLOBAL(m88110_userbpt)
	PREP2("sigtrap", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_m88110_trap, T_USERBPT, r30)
	DONE(DEBUG_SIGTRAP_BIT)
d2350 13
a2362 14
GLOBAL(m88110_break)
	PREP2("break", 130, DEBUG_BREAK_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_m88110_trap, T_KDB_BREAK, r30)
	DONE(DEBUG_BREAK_BIT)

GLOBAL(m88110_trace)
	PREP2("trace", 131, DEBUG_TRACE_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_m88110_trap, T_KDB_TRACE, r30)
	DONE(DEBUG_TRACE_BIT)

GLOBAL(m88110_entry)
	PREP2("kdb", 132, DEBUG_KDB_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_m88110_trap, T_KDB_ENTRY, r30)
	DONE(DEBUG_KDB_BIT)
d2364 12
a2375 14
GLOBAL(m88110_break)
	PREP2("break", 130, DEBUG_BREAK_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_m88110_trap, T_UNKNOWNFLT, r30)
	DONE(DEBUG_BREAK_BIT)

GLOBAL(m88110_trace)
	PREP2("trace", 131, DEBUG_TRACE_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_m88110_trap, T_UNKNOWNFLT, r30)
	DONE(DEBUG_TRACE_BIT)

GLOBAL(m88110_entry)
	PREP2("unknown", 132, DEBUG_UNKNOWN_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_m88110_trap, T_UNKNOWNFLT, r30)
	DONE(DEBUG_KDB_BIT)
d2378 1
a2379 1
/*--------------------------------------------------------------------------*/
d2391 1
a2391 30
GLOBAL(m88110_error_handler)
	stcr	r2,	SRX
	or	r2, r0, 10
	stcr	r2, 	SR0
	br.n	_m88110_fatal
	ldcr	r2, 	SRX

/*
 * The reset exception handler.
 * The reset exception is raised when the RST signal is asserted (machine 
 * is reset), the value of VBR is changed after exceptions are enabled, 
 * or when a jmp, br/bsr to addr 0 (accidents do happen :-)
 *
 * To tell the difference, you should check the value of r1 and the valid
 * bit of SXIP.
 *
 * Upon a real reset, VBR is set to zero (0), so code must be at addr 0 
 * to handle it!!! 
 *
 * This is totaly different than _error_handler.  Shadowing might or 
 * might not be on.
 * R1-R31 could tell u alot about what happend, so we'll save them.
 *
 * We'll not worry about trashing r26-29 here,
 * since they aren't generally used.
 */
GLOBAL(m88110_reset_handler)
	stcr	r0, 	SR0
	/* FALL THROUGH */
GLOBAL(m88110_fatal)
d2405 1
a2405 1
2:	/* stack has been cleared */
d2407 1
a2407 1
	/* ensure that stack is 8-byte aligned */
d2410 1
a2410 1
	/* create exception frame on stack */
d2413 1
a2413 1
	/* save old R31 and other R registers */
a2428 6

	/* vector is put in SRO (either 0 or 10 at this point) */
	ldcr	r10, SR0
	st	r10,  r31, REG_OFF(EF_VECTOR)
	cmp	r10, r10, 0	/* Is it the reset exception? */
	bb1.n	ne,  r10, 1f	/* If not, skip. */
d2433 4
a2436 16
	ldcr	r10, EXIP
	st	r10, r31, REG_OFF(EF_EXIP)
	ldcr	r10, ENIP
	st	r10, r31, REG_OFF(EF_ENIP)
	ldcr	r10, DSR
	st	r10, r31, REG_OFF(EF_DSR)
	ldcr	r10, DLAR
	st	r10, r31, REG_OFF(EF_DLAR)
	ldcr	r10, DPAR
	st	r10, r31, REG_OFF(EF_DPAR)
	ldcr	r10, ISR
	st	r10, r31, REG_OFF(EF_ISR)
	ldcr	r10, ILAR
	st	r10, r31, REG_OFF(EF_ILAR)
	ldcr	r10, IPAR
	st	r10, r31, REG_OFF(EF_IPAR)
a2437 1
	br.n	2f
a2439 25
1:	
	/* retrieve saved shadow registers for error_handler, though) */ 
	GET_R(r10, OFF_EPSR)
	st	r10, r31, REG_OFF(EF_EPSR)
	GET_R(r10, OFF_EXIP)
	st	r10, r31, REG_OFF(EF_EXIP)
	GET_R(r10, OFF_ENIP)
	st	r10, r31, REG_OFF(EF_ENIP)
	GET_R(r10, OFF_DSR)
	st	r10, r31, REG_OFF(EF_DSR)
	GET_R(r10, OFF_DLAR)
	st	r10, r31, REG_OFF(EF_DLAR)
	GET_R(r10, OFF_DPAR)
	st	r10, r31, REG_OFF(EF_DPAR)
	GET_R(r10, OFF_ISR)
	st	r10, r31, REG_OFF(EF_ISR)
	GET_R(r10, OFF_ILAR)
	st	r10, r31, REG_OFF(EF_ILAR)
	GET_R(r10, OFF_IPAR)
	st	r10, r31, REG_OFF(EF_IPAR)
	GET_R(r10, OFF_VEC)
	st	r10,  r31, REG_OFF(EF_VECTOR)
	ldcr	r10, SR1
	st	r10, r31, REG_OFF(EF_MODE)
2:
d2448 2
d2471 2
a2472 2
        
	CALL(_error_fatal, r30, r30)
d2480 2
a2481 2
ASGLOBAL(m88110_error_loop)
	bsr m88110_error_loop
d2484 79
a2562 177
ASGLOBAL(m88110_setup_phase_one)
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread (if any, null if not)                     *
	* SR1: saved copy of exception-time register now holding FLAGS  *
	* SR2: saved copy of exception-time r1                          *
	* SR3: must be preserved .. may be the exception-time stack     *
	* r1: return address to calling exception handler               *
	* FLAGS: CPU status flags                                       *
	***************************************************             *
	* immediate goal:                                               *
	*    Decide where we're going to put the exception frame.       *
	*   Might be at the end of R31, SR3, or the thread's            *
	*   pcb.                                                        *
	\***************************************************************/
	
	/* Check if we are coming in from a FPU restart exception.
	   If so, the pcb will be in SR3 */
	NOP
	xcr   r1,   r1,   SR2
	NOP
	NOP
	NOP
	
	bb1   FLAG_ENABLING_FPU, FLAGS, m88110_use_SR3_pcb
	/* are we coming in from user mode? If so, pick up thread pcb */
	bb0   FLAG_FROM_KERNEL, FLAGS, m88110_pickup_stack
	
	/* Interrupt in kernel mode, not FPU restart */
ASGLOBAL(m88110_already_on_kernel_stack)
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread (if any, null if not)                     *
	* SR1: saved copy of exception-time register now holding FLAGS  *
	* SR2: return address to the calling exception handler          *
	* SR3: must be preserved; may be important for other exceptions *
	* FLAGS: CPU status flags                                       *
	***************************************************             *
	* immediate goal:                                               *
	*   We're already on the kernel stack, but not having           *
	*   needed to use SR3. We can just make room on the             *
	*    stack (r31) for our exception frame.                       *
	\***************************************************************/
	subu  r31,  r31,  SIZEOF_EF            /* r31 now our E.F. */
	st    FLAGS,r31,  REG_OFF(EF_FLAGS)    /* save flags */
	st    r1,   r31,  GENREG_OFF(1)        /* save prev. r1 (now r1 free)*/
	
	ldcr  r1,   SR3                        /* save previous SR3 */
	st    r1,   r31,  REG_OFF(EF_SR3)
	
	addu  r1,   r31,  SIZEOF_EF            /* save previous r31 */
	br.n  m88110_have_pcb
	st    r1,   r31,  GENREG_OFF(31)
	
	
ASGLOBAL(m88110_use_SR3_pcb)
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread (if any, null if not)                     *
	* SR1: saved copy of exception-time register now holding FLAGS  *
	* SR2: return address to the calling exception handler          *
	* SR3: must be preserved; exception-time stack pointer          *
	* FLAGS: CPU status flags                                       *
	***************************************************             *
	* immediate goal:                                               *
	*   An exception occured while enabling the FPU. Since r31      *
	*   is the user's r31 while enabling the FPU, we had put        *
	*   our pcb pointer into SR3, so make room from                 *
	*   there for our stack pointer.                                *
	*       We need to check if SR3 is the old stack pointer or the *
	*       pointer off to the user pcb. If it pointing to the user *
	*       pcb, we need to pick up the kernel stack. Otherwise     *
	*       we need to allocate a frame upon it.                    *
	*       We look at the EPSR to see if it was from user mode     *
	*       Unfortunately, we have no registers free at the moment  *
	*       But we know register 0 in the pcb frame will always be  *
	*       zero, so we can use it as scratch storage.              *
	*                                                               *
	*                                                               *
	\***************************************************************/
	xcr   r30,  r30,  SR3                  /* r30 = old exception frame */
	st    r1,   r30,  GENREG_OFF(0)        /* free up r1 */
	ld    r1,   r30,  REG_OFF(EF_EPSR)     /* get back the epsr */
	bb0.n PSR_SUPERVISOR_MODE_BIT, r1, 1f  /* if user mode */
	ld    r1,   r30,  GENREG_OFF(0)        /* restore r1 */
	/* we were in kernel mode - dump frame upon the stack */
	st    r0,   r30,  GENREG_OFF(0)        /* repair old frame */
	subu  r30,  r30,  SIZEOF_EF            /* r30 now our E.F. */
	st    FLAGS,r30,  REG_OFF(EF_FLAGS)    /* save flags */
	st    r1,   r30,  GENREG_OFF(1)        /* save prev. r1 (now r1 free) */
	
	st    r31,  r30,  GENREG_OFF(31)       /* save previous r31 */
	or    r31,  r0,   r30                  /* make r31 our pointer. */
	addu  r30,  r30,  SIZEOF_EF            /* r30 now has previous SR3 */
	st    r30,  r31,  REG_OFF(EF_SR3)      /* save previous SR3 */
	br.n  m88110_have_pcb
	xcr   r30,  r30,  SR3                  /* restore r30 */
1:
	/* we took an exception while restarting the FPU from user space.
	 * Consequently, we never picked up a stack. Do so now.
	 * R1 is currently free (saved in the exception frame pointed at by
	 * r30) */
	or.u  r1,   r0,   hi16(_kstack)
	ld    r1,   r1,   lo16(_kstack)
	addu  r1,   r1,   USIZE-SIZEOF_EF
	st    FLAGS,r1,   REG_OFF(EF_FLAGS)    /* store flags */
	st    r31,  r1,   GENREG_OFF(31)       /* store r31 - now free */
	st    r30,  r1,   REG_OFF(EF_SR3)      /* store old SR3 (pcb) */
	or	 r31,  r1,   r0                   /* make r31 our exception frame pointer */ 
	ld    r1,   r30,  GENREG_OFF(0)        /* restore old r1 */
	st    r0,   r30,  GENREG_OFF(0)        /* repair that frame */
	st    r1,   r31,  GENREG_OFF(1)        /* store r1 in its proper place */
	br.n  m88110_have_pcb
	xcr   r30,  r30,  SR3                  /* restore r30 */
	
ASGLOBAL(m88110_pickup_stack)
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                          *
	* SR1: saved copy of exception-time register now holding FLAGS *
	* SR2: return address to the calling exception handler         *
	* SR3: free                                                    *
	* FLAGS: CPU status flags                                      *
	***************************************************            *
	* immediate goal:                                              *
	*    Since we're servicing an exception from user mode, we     *
	*   know that SR3 is free.  We use it to free up a temp.       *
	*   register to be used in getting the thread's pcb            *
	\***************************************************************/
	stcr  r31,  SR3      /* save previous r31 */
	
	/* switch to the thread's kernel stack. */
	or.u  r31,  r0,   hi16(_curpcb)
	ld    r31,  r31,  lo16(_curpcb)
	addu  r31,  r31,  PCB_USER_STATE       /* point to user save area */
	st    FLAGS,r31,  REG_OFF(EF_FLAGS)    /* save flags */
	st    r1,   r31,  GENREG_OFF(1)        /* save prev. r1 (now r1 free)*/
	ldcr  r1,   SR3                        /* save previous r31 */
	st    r1,   r31,  GENREG_OFF(31)
	/*FALLTHROUGH */
	
ASGLOBAL(m88110_have_pcb)
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                          *
	* SR1: saved copy of exception-time register now holding FLAGS *
	* SR2: return address to the calling exception handler         *
	* SR3: free                                                    *
	* r1:  free                                                    *
	* FLAGS: CPU status flags                                      *
	* r31: our exception frame                                     *
	*    Valid in the exception frame:                             *
	*   Exception-time r1, r31, FLAGS.                             *
	*   Exception SR3, if appropriate.                             *
	***************************************************            *
	* immediate goal:                                              *
	*    Save the shadow registers that need to be saved to        *
	*   the exception frame.                                       *
	\***************************************************************/
	stcr   TMP, SR3   /* free up TMP, TMP2, TMP3 */
	SAVE_TMP2
	SAVE_TMP3
	
	/* save some exception-time registers to the exception frame */
	ldcr  TMP,  EPSR
	st    TMP,  r31,  REG_OFF(EF_EPSR)
	ldcr  TMP2, EXIP
	st    TMP2, r31,  REG_OFF(EF_EXIP)
	bb0.n 0,    TMP2, 1f
	/* The instruction was NOT in the delay slot, zero ENIP. */
	st    r0,   r31,  REG_OFF(EF_ENIP)
	/* The instruction was in the delay slot, save ENIP. */
	ldcr  TMP3, ENIP
	st    TMP3, r31,  REG_OFF(EF_ENIP)
1:
	/* NO SFIP on mc88110, zero it */
	st    r0,   r31,  REG_OFF(EF_SFIP)
	
	/* get and store the cpu number */	
	extu  TMP,  FLAGS,  FLAG_CPU_FIELD_WIDTH<0>  /* TMP = cpu# */
	st    TMP,  r31,  REG_OFF(EF_CPU)
	
d2564 1
a2564 1
	 * Save Pbus fault status register from data and inst CMMU.
d2566 221
a2786 24
	ldcr  TMP,  ISR
	ldcr  TMP2, ILAR
	ldcr  TMP3, IPAR
	st    TMP,  r31,  REG_OFF(EF_ISR)
	st    TMP2, r31,  REG_OFF(EF_ILAR)
	st    TMP3, r31,  REG_OFF(EF_IPAR)
	ldcr  TMP,  ISAP
	ldcr  TMP2,  IUAP
	st    TMP,  r31,  REG_OFF(EF_ISAP)
	st    TMP2,  r31,  REG_OFF(EF_IUAP)
	ldcr  TMP,  DSR
	ldcr  TMP2, DLAR
	ldcr  TMP3, DPAR
	st    TMP,  r31,  REG_OFF(EF_DSR)
	st    TMP2, r31,  REG_OFF(EF_DLAR)
	st    TMP3, r31,  REG_OFF(EF_DPAR)
	ldcr  TMP,  DSAP
	ldcr  TMP2,  DUAP
	st    TMP,  r31,  REG_OFF(EF_DSAP)
	st    TMP2,  r31,  REG_OFF(EF_DUAP)
	
	ldcr  r1,   SR2
	jmp   r1 /* return */
	
d2790 106
a2895 115
ASGLOBAL(m88110_setup_phase_two)
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: saved return address to calling exception handler        *
	* SR1: saved copy of exception-time register now holding FLAGS  *
	* SR2: free                                                     *
	* SR3: saved TMP                                                *
	* r1:  return address to calling exception handler              *
	* TMP: possibly revised SSBR                                    *
	* TMP2: free                                                    *
	* TMP3: free                                                    *
	* FLAGS: CPU status flags                                       *
	* r31: our exception frame                                      *
	*    Valid in the exception frame:                              *
	*   Exception-time r1, r31, FLAGS.                              *
	*   Exception-time TMP2, TMP3.                                  *
	*   Exception-time espr, sfip, snip, sxip.                      *
	*   Exception number (EF_VECTOR).                               *
	*   Dmt0                                                        *
	*   Other data pipeline control registers, if appropriate.      *
	*   FPU control registers, if appropriate.                      *
	*   Exception SR3, if appropriate.                              *
	***************************************************             *
	* immediate goal:                                               *
	*   restore the system to the exception-time state (except      *
	* SR3 will be OUR stack pointer) so that we may resart the FPU. *
	\***************************************************************/
	/*stcr   r1, SR0*/      /* save return address */
	
	RESTORE_TMP2      /* done with extra temp regs */
	RESTORE_TMP3      /* done with extra temp regs */
	
	ldcr  TMP,  PSR
	clr   TMP,  TMP,  1<PSR_FPU_DISABLE_BIT>    /* enable the FPU */
	clr   TMP,  TMP,  1<PSR_SHADOW_FREEZE_BIT>  /* also enable shadowing */
	stcr  TMP,  EPSR
	
	or.u  TMP,  r0,   hi16(m88110_fpu_enable)
	or    TMP,  TMP,  lo16(m88110_fpu_enable)
	stcr  TMP,  EXIP      /* jump to here fpu_enable */
	addu  TMP,  TMP,  4
	stcr  TMP,  ENIP      /* and then continue after that */
	
	set   FLAGS, FLAGS, 1<FLAG_ENABLING_FPU> /* note what we're doing.*/
	xcr   FLAGS, FLAGS, SR1
	st    r1,   r31,  REG_OFF(EF_RET) /* save the return address */
	ld    r1,   r31,  GENREG_OFF(1)    /* get original r1 */
	
	ldcr  TMP, SR3
	stcr  r31, SR3	/* TMP now restored. R31 now saved in SR3 */
	ld    r31,  r31,  GENREG_OFF(31) /* get original r31 */
	
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                           *
	* SR1: CPU flags                                                *
	* SR2: free                                                     *
	* SR3: pointer to our exception frame (our stack pointer)       *
	* r1 through r31: original exception-time values                *
	*                                                               *
	* Valid in the exception frame:                                 *
	*   Exception-time FLAGS.                                       *
	*   Exception-time espr, sfip, enip, exip.                      *
	*   Exception number (EF_VECTOR).                               *
	*   Dmt0                                                        *
	*   Other data pipeline control registers, if appropriate.      *
	*   FPU control registers, if appropriate.                      *
	*   Exception SR3, if appropriate.                              *
	*   Held temporarly in the exception frame:                     *
	*   Return address to the calling excption handler.             *
	***************************************************             *
	* immediate goal:                                               *
	*   Do an RTE to restart the fpu and jump to "fpu_enable"       *
	*   Another exception (or exceptions) may be raised in          *
	*   this, which is why FLAG_ENABLING_FPU is set in SR1.         *
	\***************************************************************/
	NOP
	RTE   /* jumps to "fpu_enable" on the next line to enable the FPU. */
	
ASGLOBAL(m88110_fpu_enable)
	FLUSH_PIPELINE
	/* Now we can handle another exception!!! */
	/* Now that EFZE is cleared we can clear these */
	stcr  r0, ISR	/* Clear ISR */
	stcr  r0, ILAR	/* Clear ILAR */
	stcr  r0, IPAR	/* Clear IPAR */
	stcr  r0, DSR	/* Clear DSR */
	stcr  r0, DLAR	/* Clear DLAR */
	stcr  r0, DPAR	/* Clear DPAR */
	xcr   TMP,  TMP,  SR3               /* get E.F. pointer */
	st.d  r30,  TMP,  GENREG_OFF(30)    /* save previous r30, r31 */
	or    r31,  TMP,  r0                /* transfer E.F. pointer to r31 */
	ld    TMP,  r31,  REG_OFF(EF_SR3)   /* get previous SR3; maybe important*/

	/* make sure that the FLAG_ENABLING_FPU bit is off */
	xcr   FLAGS,FLAGS,SR1
	clr   FLAGS,FLAGS,1<FLAG_ENABLING_FPU>
	xcr   FLAGS,FLAGS,SR1

	xcr   TMP,  TMP,  SR3       /* replace TMP, SR3 */

	/* now save all regs to the exception frame. */
	st.d  r0 ,  r31,  GENREG_OFF(0)
	st.d  r2 ,  r31,  GENREG_OFF(2)
	st.d  r4 ,  r31,  GENREG_OFF(4)
	st.d  r6 ,  r31,  GENREG_OFF(6)
	st.d  r8 ,  r31,  GENREG_OFF(8)
	st.d  r10,  r31,  GENREG_OFF(10)
	st.d  r12,  r31,  GENREG_OFF(12)
	st.d  r14,  r31,  GENREG_OFF(14)
	st.d  r16,  r31,  GENREG_OFF(16)
	st.d  r18,  r31,  GENREG_OFF(18)
	st.d  r20,  r31,  GENREG_OFF(20)
	st.d  r22,  r31,  GENREG_OFF(22)
	st.d  r24,  r31,  GENREG_OFF(24)
	st.d  r26,  r31,  GENREG_OFF(26)
	st.d  r28,  r31,  GENREG_OFF(28)
d2897 41
a2937 41
	/* mark beginning of frame with notable value */
	or.u  r20,  r0,   hi16(0x12345678)
	or    r20,  r20,  lo16(0x12345678)
	st    r20,  r31,  GENREG_OFF(0)
#endif
	
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                           *
	* SR1: free                                                     *
	* SR2: free                                                     *
	* SR3: previous exception-time SR3                              *
	* r1: return address to the calling exception handler           *
	* r2 through r30: free                                          *
	* r31: our exception frame                                      *
	*                                                               *
	* Valid in the exception frame:                                 *
	*   Exception-time r0 through r31.                              *
	*   Exception-time FLAGS.                                       *
	*   Exception-time espr, enip, exip.                            *
	*   Exception number (EF_VECTOR).                               *
	*   DSR                                                         *
	* Other data pipeline control registers, if appropriate.        *
	*   FPU control registers, if appropriate.                      *
	*   Exception SR3, if appropriate.                              *
	***************************************************             *
	* immediate goal:                                               *
	*   Pick up a stack if we came in from user mode. Put           *
	*       A copy of the exception frame pointer into r30          *
	*       bump the stack a doubleword and write the exception     *
	*       frame pointer.                                          *
	*   if not an interrupt exception,                              *
	*       Turn on interrupts and service any outstanding          *
	*       data access exceptions.                                 *
	*   Return to calling exception handler to                      *
	*   service the exception.                                      *
	\***************************************************************/
	
	/*
	 * If it's not the interrupt exception, enable interrupts and
	 * take care of any data access exceptions......
	 */
d2939 2
a2940 4
	/*
	 * If interrupt exception, switch to interrupt stack if not
	 * already there. Else, switch to kernel stack.
	 */
d2942 4
a2945 3
	or    r30,  r0,   r31              /* get a copy of the e.f. pointer */
	ld    r2,   r31,  REG_OFF(EF_EPSR)
	bb1   PSR_SUPERVISOR_MODE_BIT, r2, 1f  /* If in kernel mode */
d2948 6
a2953 6
	ld    r3,   r31,  REG_OFF(EF_VECTOR)
	cmp   r3,   r3,   1      /* is interrupt ? */
	bb0   eq,   r3,   2f
	or.u  r31,  r0,   hi16(_intstack_end)   /* swith to int stack */
	or    r31,  r31,  lo16(_intstack_end)
	br    3f
d2956 4
a2959 4
	or.u  r31,  r0,   hi16(_kstack)
	ld    r31,  r31,  lo16(_kstack)
	addu  r31,  r31,  USIZE        /* point at proper end */
	br    3f
d2962 14
a2975 14
	ld    r3,   r31,  REG_OFF(EF_VECTOR)
	cmp   r3,   r3,   1       /* is interrupt ? */
	bb0   eq,   r3,   3f      /* no, we will stay on kern stack */
	or.u  r31,  r0,   hi16(_intstack_end)   /* swith to int stack */
	or    r31,  r31,  lo16(_intstack_end)
#endif	/* INTSTACK */
	/* This label is here for debugging */
m88110_exception_handler_has_ksp:  global m88110_exception_handler_has_ksp
3:	/*
	 * here - r30 holds a pointer to the exception frame.
	 * r31 is a pointer to the kernel stack/interrupt stack.
	 */
	subu  r31,  r31,  8  /* make some breathing space */
	st    r30,  r31,  0  /* store frame pointer on the stack */
d2977 1
a2977 1
	st    r30,  r31,  4  /* store it again for the debugger to recognize */
d2980 5
a2984 5
	ld    r2,   r30,  REG_OFF(EF_VECTOR)
	bcnd.n eq0, r2,   m88110_return_to_calling_exception_handler  /* is error */
	ld    r14,  r30,  REG_OFF(EF_RET) /* load return value XXX!!! */
	cmp   r3,   r2,   1 /* interrupt is exception #1 ;Is an interrupt? */
	bb1.n   eq,   r3,   m88110_return_to_calling_exception_handler /* skip if so */
d2987 2
a2988 2
	cmp   r3,   r2,   130 /* DDB break exception */
	bb1.n eq,   r3,   m88110_return_to_calling_exception_handler
d2990 2
a2991 2
	cmp   r3,   r2,   132 /* DDB entry exception */
	bb1.n eq,   r3,   m88110_return_to_calling_exception_handler
d2994 3
a2996 3
	ldcr  r2,   PSR
	clr   r2,   r2,   1<PSR_INTERRUPT_DISABLE_BIT>   /* enable interrupts */
	stcr  r2,   PSR
d2998 1
a2998 1
	FLUSH_PIPELINE
a2999 5
#if 1 /* test */
	br  m88110_return_to_calling_exception_handler
#endif
	/* service any outstanding data pipeline stuff
	   - check dsr... anything outstanding?*/
d3001 6
a3006 3
	ld    r3,   r30,  REG_OFF(EF_DSR)
	cmp   r3,   r3,   0
	bb1   eq,   r3,   m88110_return_to_calling_exception_handler
d3009 2
a3010 2
 * r30 can be clobbered by calls. So stuff its value into a
 * preserved register, say r15. R14 is in use (see return_to_... below).
d3012 6
a3017 5
	or    r15,  r0,   r30
#if 0
	CALL(_test_trap, r15, r0)
#endif   
	CALL(_m88110_trap, T_DATAFLT, r15)
d3019 2
a3020 2
	/*   restore it... */
	or    r30,  r0,   r15
d3022 2
a3023 2
	/* clear the dsr word in the E.F */
	st    r0,   r30,  REG_OFF(EF_DSR)
a3024 2
ASGLOBAL(m88110_return_to_calling_exception_handler)
	jmp   r14 /* loaded above */
@


1.22
log
@Repair MVME187 after MVME197 merge.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.21 2001/12/14 02:11:45 miod Exp $   */
a217 1
#include <machine/board.h>
@


1.21
log
@Even more one-liners to get the kernel to link.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.20 2001/12/14 01:37:56 miod Exp $   */
d221 1
a221 3
#ifdef MVME188
#include <machine/mvme188.h>
#endif
d571 1
a571 1
	CALL(_m88100_trap, T_PRIVINFLT, r30)
d613 1
a613 1
	CALL(_m18x_syscall, r13, r30) /* system call no. is in r13 */
@


1.20
log
@smurph you're a clown (with apologies to pefo@@).
No way you could have compiled a kernel from this.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.19 2001/12/13 08:55:51 smurph Exp $   */
d218 1
@


1.19
log
@Support for MVME197 completed.  Fix SPL defs.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.18 2001/11/27 05:26:36 miod Exp $   */
d572 2
a573 1
	CALL(_m88100_trap, T_PRIVINFLT, r30) DONE(DEBUG_PRIVILEGE_BIT)
@


1.18
log
@Move the declaration of EH_DEBUG and ERRATA__XXX_USR to the kernel
configuration files.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.17 2001/11/18 01:43:33 miod Exp $   */
d218 1
a218 1
#include <machine/board.h>
d240 1
a240 2
#define INTSTACK      0   /* To make interupts use their own stack */

d256 68
d356 1
a356 1
#if defined(MVME187) || defined (MVME188)
d389 1
a389 1
#endif /* defined(MVME187) || defined (MVME188) */
d391 1
a391 1
#ifdef MVME197	
d397 26
a422 1
	stcr	r1, SR2   /* r1 now free */		; \
d424 4
a427 4
	ldcr	r1, EPSR				; \
	bb0.n	PSR_SUPERVISOR_MODE_BIT, r1, 1f		; \
	clr	FLAGS, FLAGS, 1<FLAG_FROM_KERNEL>	; \
	set	FLAGS, FLAGS, 1<FLAG_FROM_KERNEL>	; \
d430 1
a430 1
	1:	bsr	m197_setup_phase_one		; \
a435 4
	/* Clear any bits in the SSBR (held in TMP) */	; \
	/* SSBR_STUFF may be empty, though.         */	; \
	SSBR_STUFF					; \
							; \
d438 1
a438 1
	bsr	m197_setup_phase_two			; \
d442 1
a442 1
#endif /* MVME197 */
d450 2
a451 2
#define M197_Data_Precheck \
   bb1.n   FLAG_IGNORE_DATA_EXCEPTION, FLAGS, m197_ignore_data_exception
a461 1
GLOBAL(eh_debug)    word 0x00000000
d463 2
d515 1
a515 1
#if defined(MVME187) || defined (MVME188)
d522 3
a524 3
   PREP("unknown", 0, DEBUG_UNKNOWN_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap18x), T_UNKNOWNFLT, r30)
   DONE(DEBUG_UNKNOWN_BIT)
d528 5
a532 5
   PREP("interrupt", 1, DEBUG_INTERRUPT_BIT, No_SSBR_Stuff, No_Precheck)
   /* interrupt_func is set in mvme_bootstrap() */
   CALL(_C_LABEL(trap18x), T_INT, r30)
   /*CALLP(_interrupt_func, 1, r30) */
   DONE(DEBUG_INTERRUPT_BIT)
d536 3
a538 3
   PREP("inst", 2, DEBUG_INSTRUCTION_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap18x), T_INSTFLT, r30)
   DONE(DEBUG_INSTRUCTION_BIT)
d545 2
a546 2
   PREP("data", 3, DEBUG_DATA_BIT, No_SSBR_Stuff, Data_Precheck)
   DONE(DEBUG_DATA_BIT)
d550 3
a552 3
   PREP("misalign", 4, DEBUG_MISALIGN_BIT, Clear_SSBR_Dest, No_Precheck)
   CALL(_C_LABEL(trap18x), T_MISALGNFLT, r30)
   DONE(DEBUG_MISALIGN_BIT)
d556 3
a558 3
   PREP("unimp", 5, DEBUG_UNIMPLEMENTED_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap18x), T_ILLFLT, r30)
   DONE(DEBUG_UNIMPLEMENTED_BIT)
d566 7
a572 8
   stcr    r1, SR2    /* hold r1 for a moment */
   ldcr    r1, SXIP   /* look at the sxip... valid bit set? */
   bb1.n   RTE_VALID_BIT, r1, 1f /*skip over return if a valid exception*/
   ldcr    r1, SR2    /* restore r1 */
   RTE
1: PREP("privilege", 6, DEBUG_PRIVILEGE_BIT, Clear_SSBR_Dest, No_Precheck)
   CALL(_C_LABEL(trap18x), T_PRIVINFLT, r30)
   DONE(DEBUG_PRIVILEGE_BIT)
d579 3
a581 3
   PREP("bounds", 7, DEBUG_BOUNDS_BIT, Clear_SSBR_Dest, No_Precheck)
   CALL(_C_LABEL(trap18x), T_BNDFLT, r30)
   DONE(DEBUG_BOUNDS_BIT)
d585 3
a587 3
   PREP("divide", 8, DEBUG_DIVIDE_BIT, Clear_SSBR_Dest, No_Precheck)
   CALL(_C_LABEL(trap18x), T_ZERODIV, r30)
   DONE(DEBUG_DIVIDE_BIT)
d591 3
a593 3
   PREP("overflow", 9, DEBUG_OVERFLOW_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap18x), T_OVFFLT, r30)
   DONE(DEBUG_OVERFLOW_BIT)
d598 3
a600 3
   PREP("FPU precise", 114, DEBUG_FPp_BIT, FPp_SSBR_STUFF, No_Precheck)
   CALL(_m88100_Xfp_precise, r0, r30) /* call fp_precise(??, exception_frame)*/ 
   DONE(DEBUG_FPp_BIT)
d605 3
a607 3
   PREP("FPU imprecise", 115, DEBUG_FPi_BIT, FPi_SSBR_STUFF, No_Precheck)
   CALL(_Xfp_imprecise, r0, r30) /*call fp_imprecise(??,exception_frame)*/
   DONE(DEBUG_FPi_BIT)
d611 4
a614 4
   PREP("syscall", 128, DEBUG_SYSCALL_BIT, No_SSBR_Stuff, No_Precheck)
   ld   r13, r30, GENREG_OFF(13)
   CALL(_syscall, r13, r30) /* system call no. is in r13 */
   DONE(DEBUG_SYSCALL_BIT)
d618 4
a621 4
   PREP("bugsyscall", 496, DEBUG_BUGCALL_BIT, No_SSBR_Stuff, No_Precheck)
   ld   r9,  r30, GENREG_OFF(9)
   CALL(_bugsyscall, r9, r30)   /* system call no. is in r9 */
   DONE(DEBUG_SYSCALL_BIT)
d624 3
a626 3
   PREP("sigsys", 0, DEBUG_SIGSYS_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap18x), T_SIGSYS, r30)
   DONE(DEBUG_SIGSYS_BIT)
d629 3
a631 3
   PREP("sigtrap", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap18x), T_SIGTRAP, r30)
   DONE(DEBUG_SIGTRAP_BIT)
d634 3
a636 3
   PREP("stepbpt", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap18x), T_STEPBPT, r30)
   DONE(DEBUG_SIGTRAP_BIT)
d639 3
a641 3
   PREP("userbpt", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap18x), T_USERBPT, r30)
   DONE(DEBUG_SIGTRAP_BIT)
d644 14
a657 13
   ASGLOBAL(break)
   PREP("break", 130, DEBUG_BREAK_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap18x), T_KDB_BREAK, r30)
   DONE(DEBUG_BREAK_BIT)
   ASGLOBAL(trace)
   PREP("trace", 131, DEBUG_TRACE_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap18x), T_KDB_TRACE, r30)
   DONE(DEBUG_TRACE_BIT)

   GLOBAL(entry)
   PREP("kdb", 132, DEBUG_KDB_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap18x), T_KDB_ENTRY, r30)
   DONE(DEBUG_KDB_BIT)
d660 14
a673 12
   ASGLOBAL(break)
   PREP("break", 130, DEBUG_BREAK_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap18x), T_UNKNOWNFLT, r30)
   DONE(DEBUG_BREAK_BIT)
   ASGLOBAL(trace)
   PREP("trace", 131, DEBUG_TRACE_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap18x), T_UNKNOWNFLT, r30)
   DONE(DEBUG_TRACE_BIT)
   GLOBAL(entry)
   PREP("unknown", 132, DEBUG_UNKNOWN_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap18x), T_UNKNOWNFLT, r30)
   DONE(DEBUG_KDB_BIT)
d778 3
a780 3
	or.u	r10,  r0,   hi16(_cputyp)
	ld	r11,  r10,  lo16(_cputyp)
	cmp	r10,  r11,  0x188
d784 1
a784 1
	st	r11, r31, REG_OFF(EF_MASK) /* put in EF_MASK for regdump */ 
d990 1
a990 1
#endif /* defined(MVME187) || defined (MVME188) */
d992 1
a992 1
#ifdef MVME197
d996 1
a996 1
ASGLOBAL(m197_ignore_data_exception)
d999 1
a999 1
	*  SR1: previous FLAGS reg                *
d1001 1
a1001 1
	*  SR3: must presere                                   *
d1009 1
a1009 1
	 * We just want to jump to "badaddr__return_nonzero" below.
d1016 3
a1018 3
	or.u	r2, r0, hi16(badaddr__return_nonzero)
	or	r2, r2, lo16(badaddr__return_nonzero)
	stcr	r2, SXIP   /* Make it the next instruction to execute */
d1020 1
a1020 1
	/* the following jumps to "badaddr__return_nonzero" in below */
d1023 1
a1023 1
#endif /* MVME197 */
d1048 4
a1051 4
   /*
    * Disable interrupts ... don't want a context switch while we're
    * doing this! Also, save the old PSR in R8 to restore later.
    */
d1147 12
d1165 1
a1165 1
#if defined(MVME187) || defined (MVME188) 
d1168 16
a1183 16
   /***************** REGISTER STATUS BLOCK ***********************\
   * SR0: current thread (if any, null if not)                     *
   * SR1: saved copy of exception-time register now holding FLAGS  *
   * SR2: saved copy of exception-time r1                          *
   * SR3: must be preserved .. may be the exception-time stack     *
   * r1: return address to calling exception handler               *
   * FLAGS: CPU status flags                                       *
   ***************************************************             *
   * immediate goal:                                               *
   *    Decide where we're going to put the exception frame.       *
   *   Might be at the end of R31, SR3, or the thread's            *
   *   pcb.                                                        *
   \***************************************************************/

   /* Check if we are coming in from a FPU restart exception.
      If so, the pcb will be in SR3 */
d1191 1
a1191 1
   /* are we coming in from user mode? If so, pick up thread pcb */
d1194 1
a1194 1
   /* Interrupt in kernel mode, not FPU restart */
d1196 12
a1207 12
   /***************** REGISTER STATUS BLOCK ***********************\
   * SR0: current thread (if any, null if not)                     *
   * SR1: saved copy of exception-time register now holding FLAGS  *
   * SR2: return address to the calling exception handler          *
   * SR3: must be preserved; may be important for other exceptions *
   * FLAGS: CPU status flags                                       *
   ***************************************************             *
   * immediate goal:                                               *
   *   We're already on the kernel stack, but not having           *
   *   needed to use SR3. We can just make room on the             *
   *    stack (r31) for our exception frame.                       *
   \***************************************************************/
d1221 23
a1243 23
   /***************** REGISTER STATUS BLOCK ***********************\
   * SR0: current thread (if any, null if not)                     *
   * SR1: saved copy of exception-time register now holding FLAGS  *
   * SR2: return address to the calling exception handler          *
   * SR3: must be preserved; exception-time stack pointer          *
   * FLAGS: CPU status flags                                       *
   ***************************************************             *
   * immediate goal:                                               *
   *   An exception occurred while enabling the FPU. Since r31      *
   *   is the user's r31 while enabling the FPU, we had put        *
   *   our pcb pointer into SR3, so make room from                 *
   *   there for our stack pointer.                                *
   *       We need to check if SR3 is the old stack pointer or the *
   *       pointer off to the user pcb. If it pointing to the user *
   *       pcb, we need to pick up the kernel stack. Otherwise     *
   *       we need to allocate a frame upon it.                    *
   *       We look at the EPSR to see if it was from user mode     *
   *       Unfortunately, we have no registers free at the moment  *
   *       But we know register 0 in the pcb frame will always be  *
   *       zero, so we can use it as scratch storage.              *
   *                                                               *
   *                                                               *
   \***************************************************************/
d1249 1
a1249 1
   /* we were in kernel mode - dump frame upon the stack */
d1262 4
a1265 4
   /* we took an exception while restarting the FPU from user space.
    * Consequently, we never picked up a stack. Do so now.
    * R1 is currently free (saved in the exception frame pointed at by
    * r30) */
d1280 12
a1291 12
   /***************** REGISTER STATUS BLOCK ***********************\
   * SR0: current thread                                          *
   * SR1: saved copy of exception-time register now holding FLAGS *
   * SR2: return address to the calling exception handler         *
   * SR3: free                                                    *
   * FLAGS: CPU status flags                                      *
   ***************************************************            *
   * immediate goal:                                              *
   *    Since we're servicing an exception from user mode, we     *
   *   know that SR3 is free.  We use it to free up a temp.       *
   *   register to be used in getting the thread's pcb            *
   \***************************************************************/
d1294 1
a1294 1
   /* switch to the thread's kernel stack. */
d1302 1
a1302 1
   /*FALLTHROUGH */
d1341 3
a1343 3
	or.u	TMP,  r0,   hi16(_cputyp)
	ld	TMP2, TMP,  lo16(_cputyp)
	cmp	TMP,  TMP2, 0x188
d1503 19
a1521 19
   /***************** REGISTER STATUS BLOCK ***********************\
   * SR0: current thread                                          *
   * SR1: saved copy of exception-time register now holding FLAGS *
   * SR2: return address to the calling exception handler         *
   * SR3: saved TMP                                               *
   * r1:  free                                                    *
   * TMP: possibly revised SSBR                                   *
   * TMP2: free                                                   *
   * TMP3: free                                                   *
   * FLAGS: CPU status flags                                      *
   * r31: exception frame                                         *
   *    Valid in the exception frame:                             *
   *   Exception-time r1, r31, FLAGS.                             *
   *   Exception-time TMP2, TMP3.                                 *
   *   Exception-time espr, sfip, snip, sxip.                     *
   *   Dmt0.                                                      *
   *   Other data pipeline control registers, if appropriate.     *
   *   Exception SR3, if appropriate.                             *
   \***************************************************************/
d1525 1
a1525 1
#endif /* defined(MVME187) || defined (MVME188) */
d1531 9
a1539 9
   /*
    * Clear floatingpont-imprecise ssbr bits.
    * Also, save appropriate FPU control registers to the E.F.
    *
    *  r1:  return address to calling exception handler
    *  TMP : (possibly) revised ssbr
    *  TMP2 : free
    *  TMP3 : free
    */
d1555 4
a1558 4
   /*
    * We only need clear the bit in the SSBR for the
    * 2nd reg of a double result [see section 6.8.5]
    */
d1574 28
a1601 28
   /*
    * Clear floating pont precise ssbr bits.
    * Also, save appropriate FPU control registers to the E.F.
    *
    *  r1:  return address to calling exception handler
    *  TMP : (possibly) revised ssbr
    *  TMP2 : free
    *  TMP3 : free
    */
   fldcr TMP2, FPSR
   fldcr TMP3, FPCR
   st    TMP2, r31,  REG_OFF(EF_FPSR)
   st    TMP3, r31,  REG_OFF(EF_FPCR)
   
   fldcr TMP3, FPECR
   st    TMP3, r31,  REG_OFF(EF_FPECR)
   fldcr TMP2, FPHS1
   fldcr TMP3, FPHS2
   st    TMP2, r31,  REG_OFF(EF_FPHS1)
   st    TMP3, r31,  REG_OFF(EF_FPHS2)

   fldcr TMP2, FPLS1
   fldcr TMP3, FPLS2
   st    TMP2, r31,  REG_OFF(EF_FPLS1)
   st    TMP3, r31,  REG_OFF(EF_FPLS2)

   fldcr TMP2, FPPT
   st    TMP2, r31,  REG_OFF(EF_FPPT)
d1605 7
a1611 9
   bb1.n FPPT_SIZE_BIT, TMP2, 2f
   extu  TMP3, TMP2, 5<0> /* get FP operation dest reg */
   br.n  3f
   set   TMP3, TMP3, 1<5> /* set size=1 -- clear one bit for "float" */
2: set   TMP3, TMP3, 1<6> /* set size=2 -- clear two bit for "double" */
3:
   clr   TMP,  TMP,  TMP3   /* clear bit(s) in ssbr. */
4: 
   jmp   r1
a1616 1

d1618 32
a1649 32
   /*
    * There are various cases where an exception can leave the
    * destination register's bit in the SB set.
    * Examples:
    *   misaligned or privilege exception on a LD or XMEM
    *   DIV or DIVU by zero.
    *
    * I think that if the instruction is LD.D, then two bits must
    * be cleared.
    *
    * Even though there are a number of instructions/exception
    * combinations that could fire this code up, it's only required
    * to be run for the above cases.  However, I don't think it'll
    * ever be a problem to run this in other cases (ST instructions,
    * for example), so I don't bother checking.  If we had to check
    * for every possible instruction, this code would be much larger.
    *
    * The only checking, then, is to see if it's a LD.D or not.
    *
    * At the moment....
    *  r1:  return address to calling exception handler
    *  TMP : (possibly) revised ssbr
    *  TMP2 : free
    *  TMP3 : free
    */
   
   ldcr  TMP3, EPSR   /* going to check: user or system memory? */
   ldcr  TMP2, SXIP   /* get the instruction's address */
   bb1.n PSR_SUPERVISOR_MODE_BIT, TMP3, 2f
   clr   TMP2, TMP2, 2<0> /* get rid of valid and error bits. */

1:  /* user space load here */
d1651 6
a1656 6
   NOP
   ld.usr TMP2,TMP2, r0      /* get the instruction itself */
   NOP
   NOP
   NOP
   br    3f
d1658 2
a1659 2
   br.n  3f
   ld.usr TMP2,TMP2, r0      /* get the instruction itself */
d1662 2
a1663 40
2: /* system space load here */
   ld    TMP2, TMP2, r0      /* get the instruction itself */

3: /* now have the instruction..... */
   /*
    * Now see if it's a double load
    * There are three forms of double load [IMM16, scaled, unscaled],
    * which can be checked by matching against two templates:
    *          -- 77776666555544443333222211110000 --
    *   if (((instruction & 11111100000000000000000000000000) ==
    *             00010000000000000000000000000000) ;;
    *       ((instruction & 11111100000000001111110011100000) ==
    *             11110100000000000001000000000000))
    *   {
    *      It's a load double, so
    *      clear two SSBR bits.
    *   } else {
    *      It's not a load double.
    *      Must be a load single, xmem, or st
    *      Thus, clear one SSBR bit.
    *   }
    */
   /* check the first pattern for ld.d */
   extu  TMP3, TMP2, 16<16>   /* get the upper 16 bits */
   mask  TMP3, TMP3, 0xFC00   /* apply the mask */
   cmp   TMP3, TMP3, 0x1000   /* if this is equal, it's a load double */
   bb1   eq,   TMP3, misaligned_double

   /* still could be -- check the second pattern for ld.d */
   /* look at the upper 16 bits first */
   extu  TMP3, TMP2, 16<16>   /* get the upper 16 bits */
   mask  TMP3, TMP3, 0xFC00   /* apply the mask */
   cmp   TMP3, TMP3, 0xF400   /* if equal, it might be a load double */
   bb1   ne,   TMP3, misaligned_single /* not equal, so must be single */

   /* now look at the lower 16 bits */
   extu  TMP3, TMP2, 16<0>    /* get the lower 16 bits */
   mask  TMP3, TMP3, 0xFCE0   /* apply the mask */
   cmp   TMP3, TMP3, 0x1000   /* if this is equal, it's a load double */
   bb1   eq,   TMP3, misaligned_double
d1665 38
d1704 3
a1706 3
   extu  TMP2, TMP2, 5<21>    /* get the destination register */
   br.n  1f
   set   TMP2, TMP2, 1<5>     /* set size=1 */
d1709 2
a1710 2
   extu  TMP2, TMP2, 5<21>    /* get the destination register */
   set   TMP2, TMP2, 1<6>     /* set size=2 -- clear two bit for "ld.d" */
d1712 2
a1713 2
1: jmp.n   r1
   clr   TMP,  TMP,  TMP2     /* clear bit(s) in ssbr. */
d1718 1
a1718 1
#if defined(MVME187) || defined (MVME188)
d1721 32
a1752 32
   /***************** REGISTER STATUS BLOCK ***********************\
   * SR0: saved return address to calling exception handler        *
   * SR1: saved copy of exception-time register now holding FLAGS  *
   * SR2: free                                                     *
   * SR3: saved TMP                                                *
   * r1:  return address to calling exception handler              *
   * TMP: possibly revised SSBR                                    *
   * TMP2: free                                                    *
   * TMP3: free                                                    *
   * FLAGS: CPU status flags                                       *
   * r31: our exception frame                                      *
   *    Valid in the exception frame:                              *
   *   Exception-time r1, r31, FLAGS.                              *
   *   Exception-time TMP2, TMP3.                                  *
   *   Exception-time espr, sfip, snip, sxip.                      *
   *   Exception number (EF_VECTOR).                               *
   *   Dmt0                                                        *
   *   Other data pipeline control registers, if appropriate.      *
   *   FPU control registers, if appropriate.                      *
   *   Exception SR3, if appropriate.                              *
   ***************************************************             *
   * immediate goal:                                               *
   *   restore the system to the exception-time state (except      *
   * SR3 will be OUR stack pointer) so that we may resart the FPU. *
   \***************************************************************/
   /*stcr   r1, SR0*/      /* save return address */
   
   stcr  TMP,  SSBR   /* done with SSBR, TMP now free */
   RESTORE_TMP2      /* done with extra temp regs */
   RESTORE_TMP3      /* done with extra temp regs */

   /* Get the current PSR and modify for the rte to enable the FPU */
d1754 11
a1764 11
   ldcr  TMP,  PSR
   clr   TMP,  TMP,  1<PSR_FPU_DISABLE_BIT>    /* enable the FPU */
   clr   TMP,  TMP,  1<PSR_SHADOW_FREEZE_BIT>  /* also enable shadowing */
   stcr  TMP,  EPSR

   /* the "+2" below is to set the VALID_BIT */
   or.u  TMP,  r0,   hi16(fpu_enable +2)
   or    TMP,  TMP,  lo16(fpu_enable +2)
   stcr  TMP,  SNIP      /* jump to here fpu_enable */
   addu  TMP,  TMP,  4
   stcr  TMP,  SFIP      /* and then continue after that */
d1766 10
a1775 10
   ldcr  TMP,  PSR
   or.u  TMP,  TMP,  0x8000    /* set supervisor mode */
   and   TMP,  TMP,  0xfff7    /* also enable shadowing */
   stcr  TMP,  EPSR
   stcr  r0,   SXIP       /* clear valid bit */
   stcr  r0,   SNIP       /* clear valid bit */
   or.u  TMP,  r0,   hi16(fpu_enable)
   or    TMP,  TMP,  lo16(fpu_enable)
   or    TMP,  TMP,  0x2 /* set the VALID_BIT and clear Exception bit */
   stcr  TMP,  SFIP      /* jump to here fpu_enable */
d1779 34
a1812 34
   set   FLAGS, FLAGS, 1<FLAG_ENABLING_FPU> /* note what we're doing.*/
   xcr   FLAGS, FLAGS, SR1
   st    r1,   r31,  REG_OFF(EF_RET) /* save the return address */
   ld    r1,   r31,  GENREG_OFF(1)    /* get original r1 */

   xcr   TMP,  r31,  SR3   /* TMP now restored. R31 now saved in SR3 */
   ld    r31,  r31,  GENREG_OFF(31) /* get original r31 */

   /***************** REGISTER STATUS BLOCK ***********************\
   * SR0: current thread                                           *
   * SR1: CPU flags                                                *
   * SR2: free                                                     *
   * SR3: pointer to our exception frame (our stack pointer)       *
   * r1 through r31: original exception-time values                *
   *                                                               *
   * Valid in the exception frame:                                 *
   *   Exception-time FLAGS.                                       *
   *   Exception-time espr, sfip, snip, sxip.                      *
   *   Exception number (EF_VECTOR).                               *
   *   Dmt0                                                        *
   *   Other data pipeline control registers, if appropriate.      *
   *   FPU control registers, if appropriate.                      *
   *   Exception SR3, if appropriate.                              *
   *   Held temporarly in the exception frame:                     *
   *   Return address to the calling excption handler.             *
   ***************************************************             *
   * immediate goal:                                               *
   *   Do an RTE to restart the fpu and jump to "fpu_enable"       *
   *   Another exception (or exceptions) may be raised in          *
   *   this, which is why FLAG_ENABLING_FPU is set in SR1.         *
   \***************************************************************/
   
   RTE   /* jumps to "fpu_enable" on the next line to enable the FPU. */

d1814 29
a1842 29
   FLUSH_PIPELINE
   xcr   TMP,  TMP,  SR3               /* get E.F. pointer */
   st.d  r30,  TMP,  GENREG_OFF(30)    /* save previous r30, r31 */
   or    r31,  TMP,  r0                /* transfer E.F. pointer to r31 */
   ld    TMP,  r31,  REG_OFF(EF_SR3)   /* get previous SR3; maybe important*/

   /* make sure that the FLAG_ENABLING_FPU bit is off */
   xcr   FLAGS,FLAGS,SR1
   clr   FLAGS,FLAGS,1<FLAG_ENABLING_FPU>
   xcr   FLAGS,FLAGS,SR1

   xcr   TMP,  TMP,  SR3       /* replace TMP, SR3 */

   /* now save all regs to the exception frame. */
   st.d  r0 ,  r31,  GENREG_OFF(0)
   st.d  r2 ,  r31,  GENREG_OFF(2)
   st.d  r4 ,  r31,  GENREG_OFF(4)
   st.d  r6 ,  r31,  GENREG_OFF(6)
   st.d  r8 ,  r31,  GENREG_OFF(8)
   st.d  r10,  r31,  GENREG_OFF(10)
   st.d  r12,  r31,  GENREG_OFF(12)
   st.d  r14,  r31,  GENREG_OFF(14)
   st.d  r16,  r31,  GENREG_OFF(16)
   st.d  r18,  r31,  GENREG_OFF(18)
   st.d  r20,  r31,  GENREG_OFF(20)
   st.d  r22,  r31,  GENREG_OFF(22)
   st.d  r24,  r31,  GENREG_OFF(24)
   st.d  r26,  r31,  GENREG_OFF(26)
   st.d  r28,  r31,  GENREG_OFF(28)
d1844 41
a1884 41
   /* mark beginning of frame with notable value */
   or.u  r20,  r0,   hi16(0x12345678)
   or    r20,  r20,  lo16(0x12345678)
   st    r20,  r31,  GENREG_OFF(0)
#endif

   /***************** REGISTER STATUS BLOCK ***********************\
   * SR0: current thread                                           *
   * SR1: free                                                     *
   * SR2: free                                                     *
   * SR3: previous exception-time SR3                              *
   * r1: return address to the calling exception handler           *
   * r2 through r30: free                                          *
   * r31: our exception frame                                      *
   *                                                               *
   * Valid in the exception frame:                                 *
   *   Exception-time r0 through r31.                              *
   *   Exception-time FLAGS.                                       *
   *   Exception-time espr, sfip, snip, sxip.                      *
   *   Exception number (EF_VECTOR).                               *
   *   Dmt0                                                        *
   *   Other data pipeline control registers, if appropriate.      *
   *   FPU control registers, if appropriate.                      *
   *   Exception SR3, if appropriate.                              *
   ***************************************************             *
   * immediate goal:                                               *
   *   Pick up a stack if we came in from user mode. Put           *
   *       A copy of the exception frame pointer into r30          *
   *       bump the stack a doubleword and write the exception     *
   *       frame pointer.                                          *
   *   if not an interrupt exception,                              *
   *       Turn on interrupts and service any outstanding          *
   *       data access exceptions.                                 *
   *   Return to calling exception handler to                      *
   *   service the exception.                                      *
   \***************************************************************/

   /*
    * If it's not the interrupt exception, enable interrupts and
    * take care of any data access exceptions......
    *
d1886 4
a1889 2
    * If interrupt exception, switch to interrupt stack if not
    * already there. Else, switch to kernel stack.
d1891 3
a1893 4
    */
   or    r30,  r0,   r31              /* get a copy of the e.f. pointer */
   ld    r2,   r31,  REG_OFF(EF_EPSR)
   bb1   PSR_SUPERVISOR_MODE_BIT, r2, 1f  /* If in kernel mode */
d1896 6
a1901 6
   ld    r3,   r31,  REG_OFF(EF_VECTOR)
   cmp   r3,   r3,   1      /* is interrupt ? */
   bb0   eq,   r3,   2f
   or.u  r31,  r0,   hi16(_intstack_end)   /* swith to int stack */
   or    r31,  r31,  lo16(_intstack_end)
   br    3f
d1904 4
a1907 4
   or.u  r31,  r0,   hi16(_kstack)
   ld    r31,  r31,  lo16(_kstack)
   addu  r31,  r31,  USIZE        /* point at proper end */
   br    3f
d1910 5
a1914 5
   ld    r3,   r31,  REG_OFF(EF_VECTOR)
   cmp   r3,   r3,   1       /* is interrupt ? */
   bb0   eq,   r3,   3f      /* no, we will stay on kern stack */
   or.u  r31,  r0,   hi16(_intstack_end)   /* swith to int stack */
   or    r31,  r31,  lo16(_intstack_end)
d1916 1
a1916 1
   /* This label is here for debugging */
d1918 6
a1923 6
3: /*
      here - r30 holds a pointer to the exception frame.
      r31 is a pointer to the kernel stack/interrupt stack.
    */
   subu  r31,  r31,  8  /* make some breathing space */
   st    r30,  r31,  0  /* store frame pointer on the stack */
d1925 1
a1925 1
   st    r30,  r31,  4  /* store it again for the debugger to recognize */
d1928 5
a1932 5
   ld    r2,   r30,  REG_OFF(EF_VECTOR)
   bcnd.n eq0, r2,   return_to_calling_exception_handler  /* is error */
   ld    r14,  r30,  REG_OFF(EF_RET)
   cmp   r3,   r2,   1 /* interrupt is exception #1 ;Is an interrupt? */
   bb1.n eq,   r3,   return_to_calling_exception_handler /* skip if so */
d1935 4
a1938 5
   cmp   r3,   r2,   130 /* DDB break exception */
   bb1.n eq,   r3,   return_to_calling_exception_handler

   cmp   r3,   r2,   132 /* DDB entry exception */
   bb1.n eq,   r3,   return_to_calling_exception_handler
d1941 3
a1943 3
   ldcr  r2,   PSR
   clr   r2,   r2,   1<PSR_INTERRUPT_DISABLE_BIT>   /* enable interrupts */
   stcr  r2,   PSR
d1945 1
a1945 1
   FLUSH_PIPELINE
d1948 2
a1949 2
   /* service any outstanding data pipeline stuff
      - check dmt0 anything outstanding?*/
d1951 2
a1952 2
   ld    r3,   r30,  REG_OFF(EF_DMT0)
   bb0   DMT_VALID_BIT, r3, return_to_calling_exception_handler
d1954 5
a1958 5
/*
   r30 can be clobbered by calls. So stuff its value into a
   preserved register, say r15. R14 is in use (see return_to_... below).
 */
   or    r15,  r0,   r30
d1960 2
a1961 2
   CALL(_C_LABEL(trap18x), T_DATAFLT, r15)
   CALL(_data_access_emulation, r15, r0)
d1963 2
a1964 2
/*   restore it... */
   or    r30,  r0,   r15
d1966 2
a1967 2
   /* clear the dmt0 word in the E.F */
   st    r0,   r30,  REG_OFF(EF_DMT0)
d1970 2
a1971 2
   jmp   r14 /* loaded above */
#endif /* defined(MVME187) || defined (MVME188) */
d1984 10
a1993 10
   ld    r1,r31,0      /* load func */
   ld    r2,r31,4      /* load proc pointer */
   jsr.n    r1
   subu    r31,r31,40      /* create stack space for function */
   addu    r31,r31,48      /* stack space above + ksigframe */
   ld   r1, r31,0      /* load pc */
   ld   r2, r31,4      /* & proc pointer from switch frame */
   jsr.n   r1
   addu   r31,r31,8
   bsr   _panic
d2004 4
a2007 4
   ld   r3,r2,P_ADDR         /* p->p_addr */
   addu   r3,r3,PCB_USER_STATE      /* p->p_addr.u_pcb.user_state */
   st   r3,r31,0         /* put it on the stack */
   br      return_from_exception_handler
d2027 1
a2027 1
#if (defined(MVME187) || defined(MVME188)) && defined(MVME197)
d2030 2
a2031 2
	cmp	r2, r3, 0x197
	bb1	eq, r2, m197_return_code
d2033 1
a2033 3

	/* 18x part for return_from_exception_handler() follows... */
#if defined(MVME187) || defined(MVME188)
d2040 4
a2043 4
       /*
       * This might happen for non-interrupts  If the user sets DMT0
       * in an exception handler.........
       */
d2060 9
a2068 9
   /*
    * If it's the interrupt exception, enable interrupt.
    * Take care of any data access exception...... 90/8/15 add by yama
    */

   /*
    * Is it ever possible to have interrupt exception while EPSR has
    * it disabled? I don't think so.. XXX nivas
    */
d2073 1
a2073 1
   /* if EPSR has interrupts disabled, skip also */
d2075 1
a2075 1
        bb1   PSR_INTERRUPT_DISABLE_BIT, r2, 1f        /* skip if disabled */
d2077 2
a2078 2
	clr   r2, r2, 1<PSR_INTERRUPT_DISABLE_BIT>    /* enable interrupts */
        FLUSH_PIPELINE
d2080 1
a2080 1
   1:
d2084 5
a2088 5
   /*
    * if there happens to be a data fault that hasn't been serviced yet,
    * go off and service that...
    */
	CALL(_C_LABEL(trap18x), T_DATAFLT, r30)
d2090 1
a2090 2

   /* clear the dmt0 word in the E.F. */
d2092 1
a2092 1
   2:
d2094 4
a2097 4
#endif	/* defined(MVME187) || defined(MVME188) */
	/* 197 part for return_from_exception_handler() follows... */
#ifdef MVME197
ASLOCAL(m197_return_code)
a2099 3
	ld	r3, FPTR, REG_OFF(EF_DSR)
	cmp	r2, r3, 0x0
	bb1	eq, r2, _check_ast /*[Oh well, nothing to do here] */
a2100 1
#if 1
d2102 2
a2103 2
	 * This might happen for non-interrupts  If the user sets DMT0
	 * in an exception handler.........
a2104 20
	ld	r2, FPTR, REG_OFF(EF_VECTOR)
	cmp	r2, r2, 1 /* interrupt is exception #1 ; Is an interrupt? */ 
	bb1	eq, r2, 1f
	or.u	r4, r0, hi16(2f)
	or	r4, r4, lo16(2f)
#if DDB
	CALL(_db_printf, r4, r0)
	tb0 0, r0, 132
#endif
	br 1f
	data
2:	string "OOPS: DSR not zero and not interrupt.\n\000"
	align 8
	text
1:
#endif
   /*
    * If it's the interrupt exception, enable interrupt.
    * Take care of any data access exception...... 90/8/15 add by yama
    */
d2106 6
a2111 4
   /*
    * Is it ever possible to have interrupt exception while EPSR has
    * it disabled? I don't think so.. XXX nivas
    */
d2113 2
a2114 2
	cmp	r2, r2, 1   /* interrupt is exception #1 ; Is an interrupt? */ 
	bb1	ne, r2, 1f  /* If not so, skip */
d2116 1
a2116 1
   /* if EPSR has interrupts disabled, skip also */
d2124 3
a2126 3
	ld	r2, FPTR, REG_OFF(EF_DSR)
	cmp	r3, r2, 0x0
	bb1	eq, r3, 2f
d2128 5
a2132 5
   /*
    * if there happens to be a data fault that hasn't been serviced yet,
    * go off and service that...
    */
	CALL(_C_LABEL(trap197), T_DATAFLT, r30)
d2134 1
a2134 1
   /* clear the dmt0 word in the E.F. */
d2136 2
d2139 1
a2139 1
#endif /* MVME197 */
d2151 1
a2151 1
        bcnd    ne0, r2, 1f           /* can't do softint's */
d2156 1
d2162 1
a2162 1
        or      r2,r0,0                   /* ints are enabled */
d2178 1
a2178 3

#if defined(MVME187) || defined(MVME188)
#if defined(MVME197)
d2181 5
a2185 7
	cmp	r2, r3, 0x197
	bb1	eq, r2, 1f
#endif
        CALL(_C_LABEL(trap18x), T_ASTFLT, FPTR)
#if defined(MVME197)
	br	2f
1:
d2187 2
a2188 4
#endif
#if defined(MVME197)
        CALL(_C_LABEL(trap197), T_ASTFLT, FPTR)
2:
d2195 1
a2195 1
        bcnd    eq0, r2, 2f
d2197 1
a2197 1
2:
a2202 1

a2208 1
        
a2217 1

d2242 2
d2245 2
a2246 2
	ld	r1, r1, lo16(_cputyp)
	cmp	r1, r1, 0x197
d2248 5
a2252 5
        
	ld      r30, r31, REG_OFF(EF_SNIP)
        ld      r1,  r31, REG_OFF(EF_SXIP)
        stcr    r30, SNIP
        stcr    r1,  SXIP
d2254 2
a2255 2
1:	
	/* reload the control regs*/
d2286 1
a2286 1
#ifdef MVME197 	
d2292 4
a2295 4
GLOBAL(m197_unknown_handler)
   PREP2("unknown", 0, DEBUG_UNKNOWN_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap197), T_UNKNOWNFLT, r30)
   DONE(DEBUG_UNKNOWN_BIT)
d2298 4
a2301 4
GLOBAL(m197_interrupt_handler)
   PREP2("interrupt", 1, DEBUG_INTERRUPT_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_sbc_ext_int, 1, r30) 
   DONE(DEBUG_INTERRUPT_BIT)
d2304 4
a2307 5
GLOBAL(m197_instruction_access_handler)
   PREP2("inst", 2, DEBUG_INSTRUCTION_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap197), T_INSTFLT, r30)
   DONE(DEBUG_INSTRUCTION_BIT)

d2312 3
a2314 3
GLOBAL(m197_data_exception_handler)
   PREP2("data", 3, DEBUG_DATA_BIT, No_SSBR_Stuff, M197_Data_Precheck)
   DONE(DEBUG_DATA_BIT)
d2317 4
a2320 4
GLOBAL(m197_misaligned_handler)
   PREP2("misalign", 4, DEBUG_MISALIGN_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap197), T_MISALGNFLT, r30)
   DONE(DEBUG_MISALIGN_BIT)
d2323 4
a2326 4
GLOBAL(m197_unimplemented_handler)
   PREP2("unimp", 5, DEBUG_UNIMPLEMENTED_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap197), T_ILLFLT, r30)
   DONE(DEBUG_UNIMPLEMENTED_BIT)
d2329 4
a2332 4
GLOBAL(m197_privilege_handler)
   PREP2("privilege", 6, DEBUG_PRIVILEGE_BIT, No_SSBR_Stuff, No_Precheck) 
   CALL(_C_LABEL(trap197), T_PRIVINFLT, r30)
   DONE(DEBUG_PRIVILEGE_BIT)
d2338 4
a2341 4
GLOBAL(m197_bounds_handler)
   PREP2("bounds", 7, DEBUG_BOUNDS_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap197), T_BNDFLT, r30)
   DONE(DEBUG_BOUNDS_BIT)
d2344 4
a2347 4
GLOBAL(m197_divide_handler)
   PREP2("divide", 8, DEBUG_DIVIDE_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap197), T_ZERODIV, r30)
   DONE(DEBUG_DIVIDE_BIT)
d2350 4
a2353 4
GLOBAL(m197_overflow_handler)
   PREP2("overflow", 9, DEBUG_OVERFLOW_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap197), T_OVFFLT, r30)
   DONE(DEBUG_OVERFLOW_BIT)
d2356 10
a2365 10
GLOBAL(m197_fp_precise_handler)
   PREP2("FPU precise", 114, DEBUG_FPp_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_m88110_Xfp_precise, r0, r30) /* call fp_precise(??, exception_frame)*/ 
   DONE(DEBUG_FPp_BIT)

/* MVME197 non-maskable interrupt handler */
GLOBAL(m197_nonmaskable)
   PREP2("MVME197 non-mask", 11, DEBUG_NON_MASK_BIT, No_SSBR_Stuff, No_Precheck) 
   CALL(_C_LABEL(trap197), T_NON_MASK, r30)
   DONE(DEBUG_NON_MASK_BIT)
d2368 4
a2371 4
GLOBAL(m197_data_read_miss)
   PREP2("MVME197 read miss", 12, DEBUG_197_READ_BIT, No_SSBR_Stuff, No_Precheck) 
   CALL(_C_LABEL(trap197), T_197_READ, r30)
   DONE(DEBUG_197_READ_BIT)
d2374 4
a2377 4
GLOBAL(m197_data_write_miss)
   PREP2("MVME197 write miss", 13, DEBUG_197_WRITE_BIT, No_SSBR_Stuff, No_Precheck) 
   CALL(_C_LABEL(trap197), T_197_WRITE, r30)
   DONE(DEBUG_197_WRITE_BIT)
d2380 4
a2383 4
GLOBAL(m197_inst_atc_miss)
   PREP2("MVME197 inst miss", 14, DEBUG_197_INST_BIT, No_SSBR_Stuff, No_Precheck) 
   CALL(_C_LABEL(trap197), T_197_INST, r30)
   DONE(DEBUG_197_INST_BIT)
d2386 5
a2390 5
GLOBAL(m197_syscall_handler)
   PREP2("syscall", 128, DEBUG_SYSCALL_BIT, No_SSBR_Stuff, No_Precheck)
   ld   r13, r30, GENREG_OFF(13)
   CALL(_m197_syscall, r13, r30) /* system call no. is in r13 */
   DONE(DEBUG_SYSCALL_BIT)
d2393 25
a2417 25
GLOBAL(m197_bugtrap)
   PREP2("bugsyscall", 496, DEBUG_BUGCALL_BIT, No_SSBR_Stuff, No_Precheck)
   ld   r9,  r30, GENREG_OFF(9)
   CALL(_bugsyscall, r9, r30)   /* system call no. is in r9 */
   DONE(DEBUG_SYSCALL_BIT)

GLOBAL(m197_sigsys)
   PREP2("sigsys", 0, DEBUG_SIGSYS_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap197), T_SIGSYS, r30)
   DONE(DEBUG_SIGSYS_BIT)

GLOBAL(m197_sigtrap)
   PREP2("sigtrap", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap197), T_SIGTRAP, r30)
   DONE(DEBUG_SIGTRAP_BIT)

GLOBAL(m197_stepbpt)
   PREP2("sigtrap", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap197), T_STEPBPT, r30)
   DONE(DEBUG_SIGTRAP_BIT)

GLOBAL(m197_userbpt)
   PREP2("sigtrap", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap197), T_USERBPT, r30)
   DONE(DEBUG_SIGTRAP_BIT)
d2420 14
a2433 13
   GLOBAL(m197_break)
   PREP2("break", 130, DEBUG_BREAK_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap197), T_KDB_BREAK, r30)
   DONE(DEBUG_BREAK_BIT)
   GLOBAL(m197_trace)
   PREP2("trace", 131, DEBUG_TRACE_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap197), T_KDB_TRACE, r30)
   DONE(DEBUG_TRACE_BIT)
   GLOBAL(m197_entry)
   PREP2("kdb", 132, DEBUG_KDB_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap197), T_KDB_ENTRY, r30)
   DONE(DEBUG_KDB_BIT)

d2435 14
a2448 12
   GLOBAL(m197_break)
   PREP2("break", 130, DEBUG_BREAK_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap197), T_UNKNOWNFLT, r30)
   DONE(DEBUG_BREAK_BIT)
   GLOBAL(m197_trace)
   PREP2("trace", 131, DEBUG_TRACE_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap197), T_UNKNOWNFLT, r30)
   DONE(DEBUG_TRACE_BIT)
   GLOBAL(m197_entry)
   PREP2("unknown", 132, DEBUG_UNKNOWN_BIT, No_SSBR_Stuff, No_Precheck)
   CALL(_C_LABEL(trap197), T_UNKNOWNFLT, r30)
   DONE(DEBUG_KDB_BIT)
d2451 1
a2452 1

d2464 30
a2493 1
GLOBAL(m197_error_handler)
d2507 1
a2507 1
2:   /* stack has been cleared */
d2509 1
a2509 1
   /* ensure that stack is 8-byte aligned */
d2512 1
a2512 1
   /* create exception frame on stack */
d2515 1
a2515 1
   /* save old R31 and other R registers */
d2531 6
d2541 16
a2556 4
	ldcr	r10, SXIP
	st	r10, r31, REG_OFF(EF_SXIP)
	ldcr	r10, SNIP
	st	r10, r31, REG_OFF(EF_SNIP)
d2558 1
d2561 25
a2593 2
	/* error vector is zippo numero el'zeroooo */
	st	r0,  r31, REG_OFF(EF_VECTOR)
d2615 2
a2616 2

        CALL(_error_fault, r30, r30)
d2624 2
a2625 2
ASGLOBAL(m197_error_loop)
	bsr m197_error_loop
d2628 177
a2804 79
/*
 * The reset exception handler.
 * The reset exception is raised when the RST signal is asserted (machine 
 * is reset), the value of VBR is changed after exceptions are enabled, 
 * or when a jmp, br/bsr to addr 0 (accidents do happen :-)
 *
 * To tell the difference, you should check the value of r1 and the valid
 * bit of SXIP.
 *
 * Upon a real reset, VBR is set to zero (0), so code must be at addr 0 
 * to handle it!!! 
 *
 * This is totaly different than _error_handler.  Shadowing might or 
 * might not be on.
 * R1-R31 could tell u alot about what happend, so we'll save them.
 *
 * We'll not worry about trashing r26-29 here,
 * since they aren't generally used.
 */
GLOBAL(m197_reset_handler)
        /* pick up the slavestack */
	or	r26, r0, r31           /* save old stack */
	or.u	r31, r0,  hi16(_intstack_end)
	or	r31, r31, lo16(_intstack_end)

	/* zero the stack, so we'll know what we're lookin' at */
	or.u	r27, r0,  hi16(_intstack)
	or	r27, r27, lo16(_intstack)
1:	cmp	r28, r27, r31
	bb1	ge,  r28, 2f   /* branch if at the end of the stack */
	st	r0,  r0,  r27
	br.n	1b
	addu	r27, r27, 4   /* bump up */
2:	/* stack has been cleared */

	/* ensure that stack is 8-byte aligned */
	clr	r31, r31, 3<0>  /* round down to 8-byte boundary */

	/* create exception frame on stack */
	subu	r31, r31, SIZEOF_EF             /* r31 now our E.F. */

	/* save old R31 and other R registers */
	st.d	r0 , r31, GENREG_OFF(0)
	st.d	r2 , r31, GENREG_OFF(2)
	st.d	r4 , r31, GENREG_OFF(4)
	st.d	r6 , r31, GENREG_OFF(6)
	st.d	r8 , r31, GENREG_OFF(8)
	st.d	r10, r31, GENREG_OFF(10)
	st.d	r12, r31, GENREG_OFF(12)
	st.d	r14, r31, GENREG_OFF(14)
	st.d	r16, r31, GENREG_OFF(16)
	st.d	r18, r31, GENREG_OFF(18)
	st.d	r20, r31, GENREG_OFF(20)
	st.d	r22, r31, GENREG_OFF(22)
	st.d	r24, r31, GENREG_OFF(24)
	st	r30, r31, GENREG_OFF(30)
	st	r26, r31, GENREG_OFF(31)

	/* save shadow registers */
	ldcr	r10, EPSR
	st	r10, r31, REG_OFF(EF_EPSR)
	ldcr	r10, SXIP
	st	r10, r31, REG_OFF(EF_SXIP)
	ldcr	r10, SNIP
	st	r10, r31, REG_OFF(EF_SNIP)
	ldcr	r10, SR1
	st	r10, r31, REG_OFF(EF_MODE)

	/* shove sr2 into EF_FPLS1 */
	ldcr	r10, SR2
	st	r10, r31, REG_OFF(EF_FPLS1)

	/* shove sr3 into EF_FPHS2 */
	ldcr	r10, SR3
	st	r10, r31, REG_OFF(EF_FPHS2)

	/* error vector is zippo numero el'zeroooo */ 
	st	r0,  r31, REG_OFF(EF_VECTOR)

d2806 1
a2806 1
	 * Cheap way to enable FPU and start shadowing again.
d2808 24
a2831 221
        ldcr    r10, PSR
        clr     r10, r10, 1<PSR_FPU_DISABLE_BIT>    /* enable the FPU */
        clr     r10, r10, 1<PSR_SHADOW_FREEZE_BIT>  /* also enable shadowing */
   
        stcr    r10, PSR  /* bang */
	FLUSH_PIPELINE

	/* put pointer to regs into r30... r31 will become a simple stack */
	or	r30, r31, r0

	subu	r31, r31, 0x10 /* make some breathing space */
	st 	r30, r31, 0x0c /* store frame pointer on the st */
	st 	r30, r31, 0x08 /* store again for the debugger to recognize */ 
	or.u	r20,  r0, hi16(0x87654321)
	or	r20, r20, lo16(0x87654321)
	st	r20, r31, 0x04
	st	r20, r31, 0x00

	CALL(_error_reset, r30, r30)

	/* TURN INTERUPTS back on */
	ldcr r1, PSR
	clr  r1, r1, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr r1, PSR
	FLUSH_PIPELINE

ASGLOBAL(m197_error_loop2)
	bsr m197_error_loop2
/* never returns*/


ASGLOBAL(m197_setup_phase_one)
   /***************** REGISTER STATUS BLOCK ***********************\
   * SR0: current thread (if any, null if not)                     *
   * SR1: saved copy of exception-time register now holding FLAGS  *
   * SR2: saved copy of exception-time r1                          *
   * SR3: must be preserved .. may be the exception-time stack     *
   * r1: return address to calling exception handler               *
   * FLAGS: CPU status flags                                       *
   ***************************************************             *
   * immediate goal:                                               *
   *    Decide where we're going to put the exception frame.       *
   *   Might be at the end of R31, SR3, or the thread's            *
   *   pcb.                                                        *
   \***************************************************************/

   /* Check if we are coming in from a FPU restart exception.
      If so, the pcb will be in SR3 */
   NOP
   xcr   r1,   r1,   SR2
   NOP
   NOP
   NOP

   bb1   FLAG_ENABLING_FPU, FLAGS, m197_use_SR3_pcb
   /* are we coming in from user mode? If so, pick up thread pcb */
   bb0   FLAG_FROM_KERNEL, FLAGS, m197_pickup_stack

   /* Interrupt in kernel mode, not FPU restart */
ASGLOBAL(m197_already_on_kernel_stack)
   /***************** REGISTER STATUS BLOCK ***********************\
   * SR0: current thread (if any, null if not)                     *
   * SR1: saved copy of exception-time register now holding FLAGS  *
   * SR2: return address to the calling exception handler          *
   * SR3: must be preserved; may be important for other exceptions *
   * FLAGS: CPU status flags                                       *
   ***************************************************             *
   * immediate goal:                                               *
   *   We're already on the kernel stack, but not having           *
   *   needed to use SR3. We can just make room on the             *
   *    stack (r31) for our exception frame.                       *
   \***************************************************************/
   subu  r31,  r31,  SIZEOF_EF            /* r31 now our E.F. */
   st    FLAGS,r31,  REG_OFF(EF_FLAGS)    /* save flags */
   st    r1,   r31,  GENREG_OFF(1)        /* save prev. r1 (now r1 free)*/

   ldcr  r1,   SR3                        /* save previous SR3 */
   st    r1,   r31,  REG_OFF(EF_SR3)

   addu  r1,   r31,  SIZEOF_EF            /* save previous r31 */
   br.n  m197_have_pcb
   st    r1,   r31,  GENREG_OFF(31)


ASGLOBAL(m197_use_SR3_pcb)
   /***************** REGISTER STATUS BLOCK ***********************\
   * SR0: current thread (if any, null if not)                     *
   * SR1: saved copy of exception-time register now holding FLAGS  *
   * SR2: return address to the calling exception handler          *
   * SR3: must be preserved; exception-time stack pointer          *
   * FLAGS: CPU status flags                                       *
   ***************************************************             *
   * immediate goal:                                               *
   *   An exception occurred while enabling the FPU. Since r31      *
   *   is the user's r31 while enabling the FPU, we had put        *
   *   our pcb pointer into SR3, so make room from                 *
   *   there for our stack pointer.                                *
   *       We need to check if SR3 is the old stack pointer or the *
   *       pointer off to the user pcb. If it pointing to the user *
   *       pcb, we need to pick up the kernel stack. Otherwise     *
   *       we need to allocate a frame upon it.                    *
   *       We look at the EPSR to see if it was from user mode     *
   *       Unfortunately, we have no registers free at the moment  *
   *       But we know register 0 in the pcb frame will always be  *
   *       zero, so we can use it as scratch storage.              *
   *                                                               *
   *                                                               *
   \***************************************************************/
   xcr   r30,  r30,  SR3                  /* r30 = old exception frame */
   st    r1,   r30,  GENREG_OFF(0)        /* free up r1 */
   ld    r1,   r30,  REG_OFF(EF_EPSR)     /* get back the epsr */
   bb0.n PSR_SUPERVISOR_MODE_BIT, r1, 1f  /* if user mode */
   ld    r1,   r30,  GENREG_OFF(0)        /* restore r1 */
   /* we were in kernel mode - dump frame upon the stack */
   st    r0,   r30,  GENREG_OFF(0)        /* repair old frame */
   subu  r30,  r30,  SIZEOF_EF            /* r30 now our E.F. */
   st    FLAGS,r30,  REG_OFF(EF_FLAGS)    /* save flags */
   st    r1,   r30,  GENREG_OFF(1)        /* save prev. r1 (now r1 free) */

   st    r31,  r30,  GENREG_OFF(31)       /* save previous r31 */
   or    r31,  r0,   r30                  /* make r31 our pointer. */
   addu  r30,  r30,  SIZEOF_EF            /* r30 now has previous SR3 */
   st    r30,  r31,  REG_OFF(EF_SR3)      /* save previous SR3 */
   br.n  m197_have_pcb
   xcr   r30,  r30,  SR3                  /* restore r30 */
1:
   /* we took an exception while restarting the FPU from user space.
    * Consequently, we never picked up a stack. Do so now.
    * R1 is currently free (saved in the exception frame pointed at by
    * r30) */
   or.u  r1,   r0,   hi16(_kstack)
   ld    r1,   r1,   lo16(_kstack)
   addu  r1,   r1,   USIZE-SIZEOF_EF
   st    FLAGS,r1,   REG_OFF(EF_FLAGS)    /* store flags */
   st    r31,  r1,   GENREG_OFF(31)       /* store r31 - now free */
   st    r30,  r1,   REG_OFF(EF_SR3)      /* store old SR3 (pcb) */
   or	 r31,  r1,   r0                   /* make r31 our exception frame pointer */ 
   ld    r1,   r30,  GENREG_OFF(0)        /* restore old r1 */
   st    r0,   r30,  GENREG_OFF(0)        /* repair that frame */
   st    r1,   r31,  GENREG_OFF(1)        /* store r1 in its proper place */
   br.n   m197_have_pcb
   xcr   r30,  r30,  SR3                  /* restore r30 */

ASGLOBAL(m197_pickup_stack)
   /***************** REGISTER STATUS BLOCK ***********************\
   * SR0: current thread                                          *
   * SR1: saved copy of exception-time register now holding FLAGS *
   * SR2: return address to the calling exception handler         *
   * SR3: free                                                    *
   * FLAGS: CPU status flags                                      *
   ***************************************************            *
   * immediate goal:                                              *
   *    Since we're servicing an exception from user mode, we     *
   *   know that SR3 is free.  We use it to free up a temp.       *
   *   register to be used in getting the thread's pcb            *
   \***************************************************************/
   stcr  r31,  SR3      /* save previous r31 */

   /* switch to the thread's kernel stack. */
   or.u  r31,  r0,   hi16(_curpcb)
   ld    r31,  r31,  lo16(_curpcb)
   addu  r31,  r31,  PCB_USER_STATE       /* point to user save area */
   st    FLAGS,r31,  REG_OFF(EF_FLAGS)    /* save flags */
   st    r1,   r31,  GENREG_OFF(1)        /* save prev. r1 (now r1 free)*/
   ldcr  r1,   SR3                        /* save previous r31 */
   st    r1,   r31,  GENREG_OFF(31)
   /*FALLTHROUGH */

ASGLOBAL(m197_have_pcb)
   /***************** REGISTER STATUS BLOCK ***********************\
   * SR0: current thread                                          *
   * SR1: saved copy of exception-time register now holding FLAGS *
   * SR2: return address to the calling exception handler         *
   * SR3: free                                                    *
   * r1:  free                                                    *
   * FLAGS: CPU status flags                                      *
   * r31: our exception frame                                     *
   *    Valid in the exception frame:                             *
   *   Exception-time r1, r31, FLAGS.                             *
   *   Exception SR3, if appropriate.                             *
   ***************************************************            *
   * immediate goal:                                              *
   *    Save the shadow registers that need to be saved to        *
   *   the exception frame.                                       *
   \***************************************************************/
   stcr   TMP, SR3   /* free up TMP, TMP2, TMP3 */
   SAVE_TMP2
   SAVE_TMP3

   /* save some exception-time registers to the exception frame */
   ldcr  TMP,  EPSR
   st    TMP,  r31,  REG_OFF(EF_EPSR)
   ldcr  TMP3, SNIP
   st    TMP3, r31,  REG_OFF(EF_SNIP)
   
   /*
    * Save Pbus fault status register from data and inst CMMU.
    */

   ldcr  TMP,  ISR
   ldcr  TMP2, ILAR
   ldcr  TMP3, IPAR
   st    TMP,  r31,  REG_OFF(EF_ISR)
   st    TMP2, r31,  REG_OFF(EF_ILAR)
   st    TMP3, r31,  REG_OFF(EF_IPAR)
   ldcr  TMP,  ISAP
   st    TMP,  r31,  REG_OFF(EF_DMT0) /* hack ef! */
   ldcr  TMP,  DSR
   ldcr  TMP2, DLAR
   ldcr  TMP3, DPAR
   st    TMP,  r31,  REG_OFF(EF_DSR)
   st    TMP2, r31,  REG_OFF(EF_DLAR)
   st    TMP3, r31,  REG_OFF(EF_DPAR)
   ldcr  TMP,  DSAP
   st    TMP,  r31,  REG_OFF(EF_DMT1) /* hack ef! */
   ldcr  TMP2, SXIP
   st    TMP2, r31,  REG_OFF(EF_SXIP)
   
   ldcr  r1,   SR2
   jmp   r1 /* return */

d2835 115
a2949 106
ASGLOBAL(m197_setup_phase_two)
   /***************** REGISTER STATUS BLOCK ***********************\
   * SR0: saved return address to calling exception handler        *
   * SR1: saved copy of exception-time register now holding FLAGS  *
   * SR2: free                                                     *
   * SR3: saved TMP                                                *
   * r1:  return address to calling exception handler              *
   * TMP: possibly revised SSBR                                    *
   * TMP2: free                                                    *
   * TMP3: free                                                    *
   * FLAGS: CPU status flags                                       *
   * r31: our exception frame                                      *
   *    Valid in the exception frame:                              *
   *   Exception-time r1, r31, FLAGS.                              *
   *   Exception-time TMP2, TMP3.                                  *
   *   Exception-time espr, sfip, snip, sxip.                      *
   *   Exception number (EF_VECTOR).                               *
   *   Dmt0                                                        *
   *   Other data pipeline control registers, if appropriate.      *
   *   FPU control registers, if appropriate.                      *
   *   Exception SR3, if appropriate.                              *
   ***************************************************             *
   * immediate goal:                                               *
   *   restore the system to the exception-time state (except      *
   * SR3 will be OUR stack pointer) so that we may resart the FPU. *
   \***************************************************************/
   /*stcr   r1, SR0*/      /* save return address */
   
   RESTORE_TMP2      /* done with extra temp regs */
   RESTORE_TMP3      /* done with extra temp regs */
   
   ldcr  TMP,  PSR
   clr   TMP,  TMP,  1<PSR_FPU_DISABLE_BIT>    /* enable the FPU */
   clr   TMP,  TMP,  1<PSR_SHADOW_FREEZE_BIT>  /* also enable shadowing */
   stcr  TMP,  EPSR

   or.u  TMP,  r0,   hi16(m197_fpu_enable)
   or    TMP,  TMP,  lo16(m197_fpu_enable)
   stcr  TMP,  EXIP      /* jump to here fpu_enable */
   addu  TMP,  TMP,  4
   stcr  TMP,  ENIP      /* and then continue after that */
   
   set   FLAGS, FLAGS, 1<FLAG_ENABLING_FPU> /* note what we're doing.*/
   xcr   FLAGS, FLAGS, SR1
   st    r1,   r31,  REG_OFF(EF_RET) /* save the return address */
   ld    r1,   r31,  GENREG_OFF(1)    /* get original r1 */

   xcr   TMP,  r31,  SR3   /* TMP now restored. R31 now saved in SR3 */
   ld    r31,  r31,  GENREG_OFF(31) /* get original r31 */

   /***************** REGISTER STATUS BLOCK ***********************\
   * SR0: current thread                                           *
   * SR1: CPU flags                                                *
   * SR2: free                                                     *
   * SR3: pointer to our exception frame (our stack pointer)       *
   * r1 through r31: original exception-time values                *
   *                                                               *
   * Valid in the exception frame:                                 *
   *   Exception-time FLAGS.                                       *
   *   Exception-time espr, sfip, snip, sxip.                      *
   *   Exception number (EF_VECTOR).                               *
   *   Dmt0                                                        *
   *   Other data pipeline control registers, if appropriate.      *
   *   FPU control registers, if appropriate.                      *
   *   Exception SR3, if appropriate.                              *
   *   Held temporarly in the exception frame:                     *
   *   Return address to the calling excption handler.             *
   ***************************************************             *
   * immediate goal:                                               *
   *   Do an RTE to restart the fpu and jump to "fpu_enable"       *
   *   Another exception (or exceptions) may be raised in          *
   *   this, which is why FLAG_ENABLING_FPU is set in SR1.         *
   \***************************************************************/
   NOP
   RTE   /* jumps to "fpu_enable" on the next line to enable the FPU. */

ASGLOBAL(m197_fpu_enable)
   FLUSH_PIPELINE
   xcr   TMP,  TMP,  SR3               /* get E.F. pointer */
   st.d  r30,  TMP,  GENREG_OFF(30)    /* save previous r30, r31 */
   or    r31,  TMP,  r0                /* transfer E.F. pointer to r31 */
   ld    TMP,  r31,  REG_OFF(EF_SR3)   /* get previous SR3; maybe important*/

   /* make sure that the FLAG_ENABLING_FPU bit is off */
   xcr   FLAGS,FLAGS,SR1
   clr   FLAGS,FLAGS,1<FLAG_ENABLING_FPU>
   xcr   FLAGS,FLAGS,SR1

   xcr   TMP,  TMP,  SR3       /* replace TMP, SR3 */

   /* now save all regs to the exception frame. */
   st.d  r0 ,  r31,  GENREG_OFF(0)
   st.d  r2 ,  r31,  GENREG_OFF(2)
   st.d  r4 ,  r31,  GENREG_OFF(4)
   st.d  r6 ,  r31,  GENREG_OFF(6)
   st.d  r8 ,  r31,  GENREG_OFF(8)
   st.d  r10,  r31,  GENREG_OFF(10)
   st.d  r12,  r31,  GENREG_OFF(12)
   st.d  r14,  r31,  GENREG_OFF(14)
   st.d  r16,  r31,  GENREG_OFF(16)
   st.d  r18,  r31,  GENREG_OFF(18)
   st.d  r20,  r31,  GENREG_OFF(20)
   st.d  r22,  r31,  GENREG_OFF(22)
   st.d  r24,  r31,  GENREG_OFF(24)
   st.d  r26,  r31,  GENREG_OFF(26)
   st.d  r28,  r31,  GENREG_OFF(28)
d2951 41
a2991 41
   /* mark beginning of frame with notable value */
   or.u  r20,  r0,   hi16(0x12345678)
   or    r20,  r20,  lo16(0x12345678)
   st    r20,  r31,  GENREG_OFF(0)
#endif

   /***************** REGISTER STATUS BLOCK ***********************\
   * SR0: current thread                                           *
   * SR1: free                                                     *
   * SR2: free                                                     *
   * SR3: previous exception-time SR3                              *
   * r1: return address to the calling exception handler           *
   * r2 through r30: free                                          *
   * r31: our exception frame                                      *
   *                                                               *
   * Valid in the exception frame:                                 *
   *   Exception-time r0 through r31.                              *
   *   Exception-time FLAGS.                                       *
   *   Exception-time espr, sfip, snip, sxip.                      *
   *   Exception number (EF_VECTOR).                               *
   *   Dmt0                                                        *
   *   Other data pipeline control registers, if appropriate.      *
   *   FPU control registers, if appropriate.                      *
   *   Exception SR3, if appropriate.                              *
   ***************************************************             *
   * immediate goal:                                               *
   *   Pick up a stack if we came in from user mode. Put           *
   *       A copy of the exception frame pointer into r30          *
   *       bump the stack a doubleword and write the exception     *
   *       frame pointer.                                          *
   *   if not an interrupt exception,                              *
   *       Turn on interrupts and service any outstanding          *
   *       data access exceptions.                                 *
   *   Return to calling exception handler to                      *
   *   service the exception.                                      *
   \***************************************************************/

   /*
    * If it's not the interrupt exception, enable interrupts and
    * take care of any data access exceptions......
    *
d2993 4
a2996 2
    * If interrupt exception, switch to interrupt stack if not
    * already there. Else, switch to kernel stack.
d2998 3
a3000 4
    */
   or    r30,  r0,   r31              /* get a copy of the e.f. pointer */
   ld    r2,   r31,  REG_OFF(EF_EPSR)
   bb1   PSR_SUPERVISOR_MODE_BIT, r2, 1f  /* If in kernel mode */
d3003 6
a3008 6
   ld    r3,   r31,  REG_OFF(EF_VECTOR)
   cmp   r3,   r3,   1      /* is interrupt ? */
   bb0   eq,   r3,   2f
   or.u  r31,  r0,   hi16(_intstack_end)   /* swith to int stack */
   or    r31,  r31,  lo16(_intstack_end)
   br    3f
d3011 4
a3014 4
   or.u  r31,  r0,   hi16(_kstack)
   ld    r31,  r31,  lo16(_kstack)
   addu  r31,  r31,  USIZE        /* point at proper end */
   br    3f
d3017 14
a3030 14
   ld    r3,   r31,  REG_OFF(EF_VECTOR)
   cmp   r3,   r3,   1       /* is interrupt ? */
   bb0   eq,   r3,   3f      /* no, we will stay on kern stack */
   or.u  r31,  r0,   hi16(_intstack_end)   /* swith to int stack */
   or    r31,  r31,  lo16(_intstack_end)
#endif /* INTSTACK */
   /* This label is here for debugging */
m197_exception_handler_has_ksp:  global m197_exception_handler_has_ksp
3: /*
      here - r30 holds a pointer to the exception frame.
      r31 is a pointer to the kernel stack/interrupt stack.
    */
   subu  r31,  r31,  8  /* make some breathing space */
   st    r30,  r31,  0  /* store frame pointer on the stack */
d3032 1
a3032 1
   st    r30,  r31,  4  /* store it again for the debugger to recognize */
d3035 5
a3039 5
   ld    r2,   r30,  REG_OFF(EF_VECTOR)
   bcnd.n eq0, r2,   m197_return_to_calling_exception_handler  /* is error */
   ld    r14,  r30,  REG_OFF(EF_RET)
   cmp   r3,   r2,   1 /* interrupt is exception #1 ;Is an interrupt? */
   bb1.n eq,   r3,   m197_return_to_calling_exception_handler /* skip if so */
d3042 2
a3043 2
   cmp   r3,   r2,   130 /* DDB break exception */
   bb1.n eq,   r3,   m197_return_to_calling_exception_handler
d3045 2
a3046 2
   cmp   r3,   r2,   132 /* DDB entry exception */
   bb1.n eq,   r3,   m197_return_to_calling_exception_handler
d3049 3
a3051 3
   ldcr  r2,   PSR
   clr   r2,   r2,   1<PSR_INTERRUPT_DISABLE_BIT>   /* enable interrupts */
   stcr  r2,   PSR
d3053 1
a3053 1
   FLUSH_PIPELINE
d3055 5
d3061 3
a3063 6
   /* service any outstanding data pipeline stuff
      - check dsr... anything outstanding?*/

   ld    r3,   r30,  REG_OFF(EF_DSR)
   cmp	 r3,   r3,   0
   bb1   eq,   r3,   m197_return_to_calling_exception_handler
d3066 2
a3067 2
   r30 can be clobbered by calls. So stuff its value into a
   preserved register, say r15. R14 is in use (see return_to_... below).
d3069 5
a3073 6
   or    r15,  r0,   r30

   CALL(_C_LABEL(trap197), T_DATAFLT, r15)

/*   restore it... */
   or    r30,  r0,   r15
d3075 2
a3076 2
   /* clear the dsr word in the E.F */
   st    r0,   r30,  REG_OFF(EF_DSR)
d3078 2
a3079 2
ASGLOBAL(m197_return_to_calling_exception_handler)
   jmp   r14 /* loaded above */
d3081 2
@


1.17
log
@Remove \n from more panic messages
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.16 2001/09/20 17:02:31 mpech Exp $   */
d217 2
d220 3
a222 3
#include <machine/asm.h>

#define	EH_DEBUG
@


1.16
log
@occured->occurred

idea from deraadt@@ via NetBSD
millert@@ ok
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.15 2001/08/24 22:53:14 miod Exp $   */
d243 1
a243 1
	string  "eh.S: bad cpu number in FLAGS\n"
d1022 1
a1022 1
1: 	string "bad length (%d) to badaddr() from 0x%x\n\000"
@


1.15
log
@Adapt to the <machine/asm.h> macros (only for entry points for now, because
LABEL has disappeared), and to the trap() name changes.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.14 2001/08/12 12:03:02 heko Exp $   */
d1124 1
a1124 1
   *   An exception occured while enabling the FPU. Since r31      *
d2657 1
a2657 1
   *   An exception occured while enabling the FPU. Since r31      *
@


1.14
log
@#(endif|else) foo is incorrect, make it #endif /* foo */
deraadt@@ ok
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.13 2001/05/20 05:53:09 miod Exp $   */
d220 2
d263 1
a263 1
 **    LABEL(foo_handler)
d265 1
a265 1
 **           CALL(_trap, T_FOO_FAULT, r31)
d363 1
a363 1
#if EH_DEBUG
d372 1
a372 1
LABEL(_eh_debug)    word 0x00000000
d430 1
a430 1
LABEL(_unknown_handler)
d432 1
a432 1
   CALL(_trap, T_UNKNOWNFLT, r30)
d436 1
a436 1
LABEL(_interrupt_handler)
d439 1
a439 1
   CALL(_trap, T_INT, r30)
d444 1
a444 1
LABEL(_instruction_access_handler)
d446 1
a446 1
   CALL(_trap, T_INSTFLT, r30)
d453 1
a453 1
LABEL(_data_exception_handler)
d458 1
a458 1
LABEL(_misaligned_handler)
d460 1
a460 1
   CALL(_trap, T_MISALGNFLT, r30)
d464 1
a464 1
LABEL(_unimplemented_handler)
d466 1
a466 1
   CALL(_trap, T_ILLFLT, r30)
d474 1
a474 1
LABEL(_privilege_handler)
d481 1
a481 1
   CALL(_trap, T_PRIVINFLT, r30)
d488 1
a488 1
LABEL(_bounds_handler)
d490 1
a490 1
   CALL(_trap, T_BNDFLT, r30)
d494 1
a494 1
LABEL(_divide_handler)
d496 1
a496 1
   CALL(_trap, T_ZERODIV, r30)
d500 1
a500 1
LABEL(_overflow_handler)
d502 1
a502 1
   CALL(_trap, T_OVFFLT, r30)
d507 1
a507 1
LABEL(fp_precise_handler)
d514 1
a514 1
LABEL(fp_imprecise_handler)
d520 1
a520 1
LABEL(_syscall_handler)
d527 1
a527 1
LABEL(_bugtrap)
d533 1
a533 1
LABEL(_sigsys)
d535 1
a535 1
   CALL(_trap, T_SIGSYS, r30)
d538 1
a538 1
LABEL(_sigtrap)
d540 1
a540 1
   CALL(_trap, T_SIGTRAP, r30)
d543 1
a543 1
LABEL(_stepbpt)
d545 1
a545 1
   CALL(_trap, T_STEPBPT, r30)
d548 1
a548 1
LABEL(_userbpt)
d550 1
a550 1
   CALL(_trap, T_USERBPT, r30)
d554 1
a554 1
   LABEL(break)
d556 1
a556 1
   CALL(_trap, T_KDB_BREAK, r30)
d558 1
a558 1
   LABEL(trace)
d560 1
a560 1
   CALL(_trap, T_KDB_TRACE, r30)
d563 1
a563 1
   LABEL(_entry)
d565 1
a565 1
   CALL(_trap, T_KDB_ENTRY, r30)
d569 1
a569 1
   LABEL(break)
d571 1
a571 1
   CALL(_trap, T_UNKNOWNFLT, r30)
d573 1
a573 1
   LABEL(trace)
d575 1
a575 1
   CALL(_trap, T_UNKNOWNFLT, r30)
d577 1
a577 1
   LABEL(_entry)
d579 1
a579 1
   CALL(_trap, T_UNKNOWNFLT, r30)
d596 1
a596 1
LABEL(_error_handler)
d721 1
a721 1
LABEL(_error_loop) bsr _error_loop
d743 1
a743 1
LABEL(_reset_handler)
d859 1
a859 1
LABEL(_error_loop2) bsr _error_loop2
d865 1
a865 1
_LABEL(ignore_data_exception)
d903 1
a903 1
_LABEL(m197_ignore_data_exception)
d954 1
a954 1
LABEL(_badaddr)
d1034 1
a1034 1
_LABEL(badaddr__return_nonzero)
d1038 1
a1038 1
_LABEL(badaddr__return)
d1062 1
a1062 1
LABEL(setup_phase_one)
d1090 1
a1090 1
_LABEL(already_on_kernel_stack)
d1115 1
a1115 1
_LABEL(use_SR3_pcb)
d1174 1
a1174 1
_LABEL(pickup_stack)
d1199 1
a1199 1
_LABEL(have_pcb)
d1298 1
a1298 1
_LABEL(pfsr_done)
d1357 1
a1357 1
_LABEL(check_DMT0)
d1364 1
a1364 1
_LABEL(do_DMT0)
d1369 1
a1369 1
_LABEL(check_DMT1)
d1375 1
a1375 1
_LABEL(do_DMT1)
d1380 1
a1380 1
_LABEL(check_DMT2)
d1387 1
a1387 1
_LABEL(do_DMT2_single)
d1392 1
a1392 1
_LABEL(do_DMT2_double)
d1397 1
a1397 1
_LABEL(DMT_check_finished)
d1425 1
a1425 1
_LABEL(clear_FPi_ssbr_bit)
d1460 1
a1460 1
_LABEL(not_double_fpi)
d1468 1
a1468 1
_LABEL(clear_FPp_ssbr_bit)
d1515 1
a1515 1
_LABEL(clear_dest_ssbr_bit)
d1601 1
a1601 1
_LABEL(misaligned_single)
d1606 1
a1606 1
_LABEL(misaligned_double)
d1618 1
a1618 1
LABEL(setup_phase_two)
d1711 1
a1711 1
_LABEL(fpu_enable)
d1858 1
a1858 1
   CALL(_trap, T_DATAFLT, r15)
d1867 1
a1867 1
_LABEL(return_to_calling_exception_handler)
d1907 2
a1908 2
LABEL(return_from_exception_handler)
LABEL(_return_from_main)
d1925 1
a1925 1
#ifdef MVME197	
d1931 3
a1946 1
LABEL(oops)
d1988 1
a1988 1
	CALL(_trap, T_DATAFLT, r30)
d1995 2
d1998 1
a1998 1
LABEL(m197_return_code)
a2012 1
LABEL(oops2)
d2055 1
a2055 1
	CALL(_trap2, T_DATAFLT, r30)
d2067 1
a2067 1
LABEL(_check_ast)
d2099 17
a2115 1
        CALL(_trap, T_ASTFLT, FPTR)
d2126 1
a2126 1
_LABEL(no_ast)
d2210 1
a2210 1
_LABEL(return_from_exception)
d2219 1
a2219 1
LABEL(_m197_unknown_handler)
d2221 1
a2221 1
   CALL(_trap2, T_UNKNOWNFLT, r30)
d2225 1
a2225 1
LABEL(_m197_interrupt_handler)
d2231 1
a2231 1
LABEL(_m197_instruction_access_handler)
d2233 1
a2233 1
   CALL(_trap2, T_INSTFLT, r30)
d2240 1
a2240 1
LABEL(_m197_data_exception_handler)
d2245 1
a2245 1
LABEL(_m197_misaligned_handler)
d2247 1
a2247 1
   CALL(_trap2, T_MISALGNFLT, r30)
d2251 1
a2251 1
LABEL(_m197_unimplemented_handler)
d2253 1
a2253 1
   CALL(_trap2, T_ILLFLT, r30)
d2257 1
a2257 1
LABEL(_m197_privilege_handler)
d2259 1
a2259 1
   CALL(_trap2, T_PRIVINFLT, r30)
d2266 1
a2266 1
LABEL(_m197_bounds_handler)
d2268 1
a2268 1
   CALL(_trap2, T_BNDFLT, r30)
d2272 1
a2272 1
LABEL(_m197_divide_handler)
d2274 1
a2274 1
   CALL(_trap2, T_ZERODIV, r30)
d2278 1
a2278 1
LABEL(_m197_overflow_handler)
d2280 1
a2280 1
   CALL(_trap2, T_OVFFLT, r30)
d2284 1
a2284 1
LABEL(_m197_fp_precise_handler)
d2290 1
a2290 1
LABEL(_m197_nonmaskable)
d2292 1
a2292 1
   CALL(_trap2, T_NON_MASK, r30)
d2296 1
a2296 1
LABEL(_m197_data_read_miss)
d2298 1
a2298 1
   CALL(_trap2, T_197_READ, r30)
d2302 1
a2302 1
LABEL(_m197_data_write_miss)
d2304 1
a2304 1
   CALL(_trap2, T_197_WRITE, r30)
d2308 1
a2308 1
LABEL(_m197_inst_atc_miss)
d2310 1
a2310 1
   CALL(_trap2, T_197_INST, r30)
d2314 1
a2314 1
LABEL(_m197_syscall_handler)
d2321 1
a2321 1
LABEL(_m197_bugtrap)
d2327 1
a2327 1
LABEL(_m197_sigsys)
d2329 1
a2329 1
   CALL(_trap2, T_SIGSYS, r30)
d2332 1
a2332 1
LABEL(_m197_sigtrap)
d2334 1
a2334 1
   CALL(_trap2, T_SIGTRAP, r30)
d2337 1
a2337 1
LABEL(_m197_stepbpt)
d2339 1
a2339 1
   CALL(_trap2, T_STEPBPT, r30)
d2342 1
a2342 1
LABEL(_m197_userbpt)
d2344 1
a2344 1
   CALL(_trap2, T_USERBPT, r30)
d2348 1
a2348 1
   LABEL(_m197_break)
d2350 1
a2350 1
   CALL(_trap2, T_KDB_BREAK, r30)
d2352 1
a2352 1
   LABEL(_m197_trace)
d2354 1
a2354 1
   CALL(_trap2, T_KDB_TRACE, r30)
d2356 1
a2356 1
   LABEL(_m197_entry)
d2358 1
a2358 1
   CALL(_trap2, T_KDB_ENTRY, r30)
d2362 1
a2362 1
   LABEL(_m197_break)
d2364 1
a2364 1
   CALL(_trap2, T_UNKNOWNFLT, r30)
d2366 1
a2366 1
   LABEL(_m197_trace)
d2368 1
a2368 1
   CALL(_trap2, T_UNKNOWNFLT, r30)
d2370 1
a2370 1
   LABEL(_m197_entry)
d2372 1
a2372 1
   CALL(_trap2, T_UNKNOWNFLT, r30)
d2389 1
a2389 1
LABEL(_m197_error_handler)
d2478 2
a2479 1
LABEL(m197_error_loop) bsr m197_error_loop
d2501 1
a2501 1
LABEL(_m197_reset_handler)
d2590 2
a2591 1
LABEL(m197_error_loop2) bsr m197_error_loop2
d2595 1
a2595 1
LABEL(m197_setup_phase_one)
d2623 1
a2623 1
_LABEL(m197_already_on_kernel_stack)
d2648 1
a2648 1
_LABEL(m197_use_SR3_pcb)
d2704 1
a2704 1
   br.n   have_pcb
d2707 1
a2707 1
_LABEL(m197_pickup_stack)
d2732 1
a2732 1
_LABEL(m197_have_pcb)
d2788 1
a2788 1
LABEL(m197_setup_phase_two)
d2864 1
a2864 1
_LABEL(m197_fpu_enable)
d3012 1
a3012 1
   CALL(_trap2, T_DATAFLT, r15)
d3020 1
a3020 1
_LABEL(m197_return_to_calling_exception_handler)
@


1.13
log
@assym.s -> assym.h
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.12 2001/03/09 05:44:41 smurph Exp $   */
d1821 1
a1821 1
#endif DDB
d2953 1
a2953 1
#endif DDB
@


1.12
log
@kernel will compile with -Werror.  Added intr.h
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.11 2001/03/07 23:40:35 miod Exp $   */
a214 3
#ifndef ASSEMBLER
#define	ASSEMBLER
#endif /* ASSEMBLER */
d216 1
a216 1
#include "assym.s"
@


1.11
log
@Get rid of definitions of ASSEMBLER, LOCORE and such. We will get
the correct defines from the Makefile now.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.10 2001/02/01 03:38:19 smurph Exp $   */
d215 3
d2104 1
a2104 1
        bsr     panic
@


1.10
log
@Major changes to get MVME188 working.  More header and code cleanups.  The
kernel is tested on MVME188A/2P256 and MVME188A/1P64.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.9 2000/12/28 21:21:24 smurph Exp $   */
a214 4

#ifndef ASSEMBLER
#define ASSEMBLER
#endif
@


1.9
log
@mvme88k updates to -current.  finally!
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.8 1999/09/27 19:13:21 smurph Exp $   */
d242 14
a255 2
   text
   align 8
d289 1
a289 1

d308 3
d322 1
d324 1
d354 1
d426 1
a426 1

d428 1
a428 1
/*#### THE ACTUAL EXCEPTION HANDLER ENTRY POINTS ##########################*/
d472 1
a472 1
 * Some versions of the chip have * a bug whereby false privilege
d680 3
a682 2
	/* error vector is zippo numero el'zeroooo */
	st	r0,  r31, REG_OFF(EF_VECTOR)
d684 1
a684 1
#ifdef MVME188
a897 1
	NOP
d899 3
d932 2
d1062 1
d1202 16
a1217 16
   /***************** REGISTER STATUS BLOCK ***********************\
   * SR0: current thread                                          *
   * SR1: saved copy of exception-time register now holding FLAGS *
   * SR2: return address to the calling exception handler         *
   * SR3: free                                                    *
   * r1:  free                                                    *
   * FLAGS: CPU status flags                                      *
   * r31: our exception frame                                     *
   *    Valid in the exception frame:                             *
   *   Exception-time r1, r31, FLAGS.                             *
   *   Exception SR3, if appropriate.                             *
   ***************************************************            *
   * immediate goal:                                              *
   *    Save the shadow registers that need to be saved to        *
   *   the exception frame.                                       *
   \***************************************************************/
d1222 1
a1222 1
   /* save some exception-time registers to the exception frame */
d1229 3
d1233 3
a1235 3
   /*
    * Save Pbus fault status register from data and inst CMMU.
    */
d1241 14
a1254 5
	bb1	ne,   TMP,  4f
	ldcr	TMP,  SR1
	mak	TMP,  TMP,  FLAG_CPU_FIELD_WIDTH<2> /* TMP = cpu# */
	cmp	TMP2, TMP,  0x0                     /* CPU0 ? */     
	bb1	ne,   TMP2, 1f
d1263 2
a1264 4
1:
	cmp	TMP2, TMP,  0x1                     /* CPU1 ? */     
	bb1	ne,   TMP2, 2f
   /* must be CPU1 */
d1272 2
a1273 4
2:
	cmp	TMP2, TMP,  0x2                     /* CPU2 ? */     
	bb1	ne,   TMP2, 3f
   /* must be CPU2 */
d1281 2
a1282 2
3:
   /* must be CPU3 */
d1290 1
a1290 1
4: 
d1422 2
d1618 1
a1618 1

d1871 1
d2059 1
a2065 1
#endif /* MVME197 */
d2072 3
a2074 1
        bsr.n   _setipl
d2076 1
d2079 1
d2082 2
a2083 1
                    /* at ipl 0 now */
d2119 6
a2124 1

a2129 3
        ld      r2, FPTR, REG_OFF(EF_MASK)   /* get pre-exception ipl */
        bsr     _setipl

d2842 1
a2842 1
   
d3004 1
a3004 2
#endif 
	
@


1.8
log
@Added to support MVME188 and MVME197
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.7 1999/05/29 04:41:46 smurph Exp $   */
d1876 17
a1892 16
   /*
    * Regs r1-r30 are free. R31 is pointing at the word
         * on the kernel stack where our pointer to the exception frame
         * it stored. Reload it now.
     *
    * At this point, if EF_DMT0 is not zero, then
    * this must have been an interrupt where the fault didn't
    * get corrected above.  We'll do that now.
    *
    * We load it into r14 since it is preserved across function
    * calls, and we may have to call some routines from within here.
    *
    * control is transfered here from obvious places in this file
         * and thread_bootstrap in luna88k/locore.c.
    *
    */
d1897 1
a1897 1

d1960 1
a1960 1

d2030 1
a2030 1

@


1.8.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.12 2001/03/09 05:44:41 smurph Exp $   */
d215 1
d217 2
a218 2
#define	ASSEMBLER
#endif /* ASSEMBLER */
d242 2
a243 14
	data
	align 4
sbadcpupanic:
	string  "eh.S: bad cpu number in FLAGS\n"
	
	text
	align 8

Lbadcpupanic:
	or.u r2, r0, hi16(sbadcpupanic)
	or   r2, r2, lo16(sbadcpupanic)
	bsr  _panic

	align 8
d277 1
a277 1
#if defined(MVME187) || defined (MVME188)
a295 3
	/* TMP3 also free -- use to set last_vector */	; \
	or.u	TMP3, r0,   hi16(_last_vector)		; \
	st	TMP2, TMP3, lo16(_last_vector)		; \
a306 1
#endif /* defined(MVME187) || defined (MVME188) */
a307 1
#ifdef MVME197	
a336 1
#endif /* MVME197 */
d408 1
a408 1
#if defined(MVME187) || defined (MVME188)
d410 1
a410 1
/*#### THE ACTUAL EXCEPTION HANDLER ENTRY POINTS for MVME18x ##############*/
d454 1
a454 1
 * Some versions of the chip have a bug whereby false privilege
d662 2
a663 3
	/* error vector is 10 */
	or	r10, r0, 10
	st	r10, r31, REG_OFF(EF_VECTOR)
d665 1
a665 1
#if 0 /* MVME188 */
d879 1
a880 3
#endif /* defined(MVME187) || defined (MVME188) */

#ifdef MVME197
a910 2
#endif /* MVME197 */
	
a1038 1
#if defined(MVME187) || defined (MVME188) 
d1178 16
a1193 16
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                          *
	* SR1: saved copy of exception-time register now holding FLAGS *
	* SR2: return address to the calling exception handler         *
	* SR3: free                                                    *
	* r1:  free                                                    *
	* FLAGS: CPU status flags                                      *
	* r31: our exception frame                                     *
	* Valid in the exception frame:                                *
	*   Exception-time r1, r31, FLAGS.                             *
	*   Exception SR3, if appropriate.                             *
	***************************************************            *
	* immediate goal:                                              *
	*    Save the shadow registers that need to be saved to        *
	*   the exception frame.                                       *
	\***************************************************************/
d1198 1
a1198 1
	/* save some exception-time registers to the exception frame */
a1204 3
	/* get and store the cpu number */	
	extu	TMP,  FLAGS,  FLAG_CPU_FIELD_WIDTH<0>  /* TMP = cpu# */
	st	TMP,  r31,  REG_OFF(EF_CPU)
d1206 3
a1208 3
	/*
	 * Save Pbus fault status register from data and inst CMMU.
	 */
d1214 5
a1218 14
	bb1	ne,   TMP,  5f
	
	extu	TMP,  FLAGS, FLAG_CPU_FIELD_WIDTH<0>	/* TMP = cpu# */
	cmp	TMP2, TMP, 0x0				/* CPU0 ? */     
	bb1	eq,   TMP2, 1f
	cmp	TMP2, TMP, 0x1				/* CPU1 ? */     
	bb1	eq,   TMP2, 2f
	cmp	TMP2, TMP, 0x2				/* CPU2 ? */     
	bb1	eq,   TMP2, 3f
	cmp	TMP2, TMP, 0x3				/* CPU3 ? */     
	bb1	eq,   TMP2, 4f
	/* Arrrrg! bad cpu# */ 
	br	Lbadcpupanic				
1:
d1227 4
a1230 2
2:
	/* must be CPU1 */
d1238 4
a1241 2
3:
	/* must be CPU2 */
d1249 2
a1250 2
4:
	/* must be CPU3 */
d1258 1
a1258 1
5: 
a1389 2
#endif /* defined(MVME187) || defined (MVME188) */

d1584 1
a1584 1
#if defined(MVME187) || defined (MVME188)
a1836 1
#endif /* defined(MVME187) || defined (MVME188) */
d1876 16
a1891 17
	/*
	 * Regs r1-r30 are free. R31 is pointing at the word
	 * on the kernel stack where our pointer to the exception frame
	 * it stored. Reload it now.
	 *
	 * At this point, if EF_DMT0 is not zero, then
	 * this must have been an interrupt where the fault didn't
	 * get corrected above.  We'll do that now.
	 *
	 * We load it into r14 since it is preserved across function
	 * calls, and we may have to call some routines from within here.
	 *
	 * control is transfered here from obvious places in this file
	 * and thread_bootstrap in luna88k/locore.c.
	 *
	 */
#ifdef MVME197	
d1896 1
a1896 1
#endif 
d1959 1
a1959 1
#ifdef MVME197
a2022 1
#endif /* MVME197 */
d2029 1
d2036 1
a2036 3
        
	subu	r31, r31, 32
	bsr.n   _setipl
a2037 1
	addu	r31, r31, 32
a2039 1
	subu	r31, r31, 32
d2042 1
a2042 2
	addu	r31, r31, 32
	/* at ipl 0 now */
d2064 1
a2064 1
        bsr     _panic
d2078 1
a2078 6
        
	ld      r2, FPTR, REG_OFF(EF_MASK)   /* get pre-exception ipl */
	bsr.n   _setipl
	subu	r31, r31, 40
	addu	r31, r31, 40
        
d2084 3
d2799 1
a2799 1
   NOP
d2961 2
a2962 1
#endif
@


1.8.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.8.4.1 2001/04/18 16:11:32 niklas Exp $   */
d215 3
d219 1
a219 1
#include "assym.h"
@


1.8.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.8.4.2 2001/07/04 10:20:09 niklas Exp $   */
a219 2
#define	EH_DEBUG

d261 1
a261 1
 **    ASGLOBAL(foo_handler)
d263 1
a263 1
 **           CALL(_C_LABEL(trapXXX), T_FOO_FAULT, r31)
d361 1
a361 1
#ifdef EH_DEBUG
d370 1
a370 1
GLOBAL(eh_debug)    word 0x00000000
d428 1
a428 1
GLOBAL(unknown_handler)
d430 1
a430 1
   CALL(_C_LABEL(trap18x), T_UNKNOWNFLT, r30)
d434 1
a434 1
GLOBAL(interrupt_handler)
d437 1
a437 1
   CALL(_C_LABEL(trap18x), T_INT, r30)
d442 1
a442 1
GLOBAL(instruction_access_handler)
d444 1
a444 1
   CALL(_C_LABEL(trap18x), T_INSTFLT, r30)
d451 1
a451 1
GLOBAL(data_exception_handler)
d456 1
a456 1
GLOBAL(misaligned_handler)
d458 1
a458 1
   CALL(_C_LABEL(trap18x), T_MISALGNFLT, r30)
d462 1
a462 1
GLOBAL(unimplemented_handler)
d464 1
a464 1
   CALL(_C_LABEL(trap18x), T_ILLFLT, r30)
d472 1
a472 1
GLOBAL(privilege_handler)
d479 1
a479 1
   CALL(_C_LABEL(trap18x), T_PRIVINFLT, r30)
d486 1
a486 1
GLOBAL(bounds_handler)
d488 1
a488 1
   CALL(_C_LABEL(trap18x), T_BNDFLT, r30)
d492 1
a492 1
GLOBAL(divide_handler)
d494 1
a494 1
   CALL(_C_LABEL(trap18x), T_ZERODIV, r30)
d498 1
a498 1
GLOBAL(overflow_handler)
d500 1
a500 1
   CALL(_C_LABEL(trap18x), T_OVFFLT, r30)
d505 1
a505 1
ASGLOBAL(fp_precise_handler)
d512 1
a512 1
ASGLOBAL(fp_imprecise_handler)
d518 1
a518 1
GLOBAL(syscall_handler)
d525 1
a525 1
GLOBAL(bugtrap)
d531 1
a531 1
GLOBAL(sigsys)
d533 1
a533 1
   CALL(_C_LABEL(trap18x), T_SIGSYS, r30)
d536 1
a536 1
GLOBAL(sigtrap)
d538 1
a538 1
   CALL(_C_LABEL(trap18x), T_SIGTRAP, r30)
d541 1
a541 1
GLOBAL(stepbpt)
d543 1
a543 1
   CALL(_C_LABEL(trap18x), T_STEPBPT, r30)
d546 1
a546 1
GLOBAL(userbpt)
d548 1
a548 1
   CALL(_C_LABEL(trap18x), T_USERBPT, r30)
d552 1
a552 1
   ASGLOBAL(break)
d554 1
a554 1
   CALL(_C_LABEL(trap18x), T_KDB_BREAK, r30)
d556 1
a556 1
   ASGLOBAL(trace)
d558 1
a558 1
   CALL(_C_LABEL(trap18x), T_KDB_TRACE, r30)
d561 1
a561 1
   GLOBAL(entry)
d563 1
a563 1
   CALL(_C_LABEL(trap18x), T_KDB_ENTRY, r30)
d567 1
a567 1
   ASGLOBAL(break)
d569 1
a569 1
   CALL(_C_LABEL(trap18x), T_UNKNOWNFLT, r30)
d571 1
a571 1
   ASGLOBAL(trace)
d573 1
a573 1
   CALL(_C_LABEL(trap18x), T_UNKNOWNFLT, r30)
d575 1
a575 1
   GLOBAL(entry)
d577 1
a577 1
   CALL(_C_LABEL(trap18x), T_UNKNOWNFLT, r30)
d594 1
a594 1
GLOBAL(error_handler)
d719 1
a719 1
GLOBAL(error_loop) bsr _error_loop
d741 1
a741 1
GLOBAL(reset_handler)
d857 1
a857 1
GLOBAL(error_loop2) bsr _error_loop2
d863 1
a863 1
ASGLOBAL(ignore_data_exception)
d901 1
a901 1
ASGLOBAL(m197_ignore_data_exception)
d952 1
a952 1
GLOBAL(badaddr)
d1032 1
a1032 1
ASGLOBAL(badaddr__return_nonzero)
d1036 1
a1036 1
ASGLOBAL(badaddr__return)
d1060 1
a1060 1
ASGLOBAL(setup_phase_one)
d1088 1
a1088 1
ASGLOBAL(already_on_kernel_stack)
d1113 1
a1113 1
ASGLOBAL(use_SR3_pcb)
d1122 1
a1122 1
   *   An exception occurred while enabling the FPU. Since r31      *
d1172 1
a1172 1
ASGLOBAL(pickup_stack)
d1197 1
a1197 1
ASGLOBAL(have_pcb)
d1296 1
a1296 1
ASGLOBAL(pfsr_done)
d1355 1
a1355 1
ASGLOBAL(check_DMT0)
d1362 1
a1362 1
ASGLOBAL(do_DMT0)
d1367 1
a1367 1
ASGLOBAL(check_DMT1)
d1373 1
a1373 1
ASGLOBAL(do_DMT1)
d1378 1
a1378 1
ASGLOBAL(check_DMT2)
d1385 1
a1385 1
ASGLOBAL(do_DMT2_single)
d1390 1
a1390 1
ASGLOBAL(do_DMT2_double)
d1395 1
a1395 1
ASGLOBAL(DMT_check_finished)
d1423 1
a1423 1
ASGLOBAL(clear_FPi_ssbr_bit)
d1458 1
a1458 1
ASGLOBAL(not_double_fpi)
d1466 1
a1466 1
ASGLOBAL(clear_FPp_ssbr_bit)
d1513 1
a1513 1
ASGLOBAL(clear_dest_ssbr_bit)
d1599 1
a1599 1
ASGLOBAL(misaligned_single)
d1604 1
a1604 1
ASGLOBAL(misaligned_double)
d1616 1
a1616 1
ASGLOBAL(setup_phase_two)
d1709 1
a1709 1
ASGLOBAL(fpu_enable)
d1821 1
a1821 1
#endif /* DDB */
d1856 1
a1856 1
   CALL(_C_LABEL(trap18x), T_DATAFLT, r15)
d1865 1
a1865 1
ASGLOBAL(return_to_calling_exception_handler)
d1905 2
a1906 2
ASGLOBAL(return_from_exception_handler)
GLOBAL(return_from_main)
d1923 1
a1923 1
#if (defined(MVME187) || defined(MVME188)) && defined(MVME197)
a1928 3

	/* 18x part for return_from_exception_handler() follows... */
#if defined(MVME187) || defined(MVME188)
d1942 1
d1984 1
a1984 1
	CALL(_C_LABEL(trap18x), T_DATAFLT, r30)
a1990 2
#endif	/* defined(MVME187) || defined(MVME188) */
	/* 197 part for return_from_exception_handler() follows... */
d1992 1
a1992 1
ASLOCAL(m197_return_code)
d2007 1
d2050 1
a2050 1
	CALL(_C_LABEL(trap197), T_DATAFLT, r30)
d2062 1
a2062 1
GLOBAL(check_ast)
d2094 1
a2094 17
#if defined(MVME187) || defined(MVME188)
#if defined(MVME197)
	or.u	r2, r0, hi16(_cputyp)
	ld	r3, r2, lo16(_cputyp)
	cmp	r2, r3, 0x197
	bb1	eq, r2, 1f
#endif
        CALL(_C_LABEL(trap18x), T_ASTFLT, FPTR)
#if defined(MVME197)
	br	2f
1:
#endif
#endif
#if defined(MVME197)
        CALL(_C_LABEL(trap197), T_ASTFLT, FPTR)
2:
#endif
d2105 1
a2105 1
ASGLOBAL(no_ast)
d2189 1
a2189 1
ASGLOBAL(return_from_exception)
d2198 1
a2198 1
GLOBAL(m197_unknown_handler)
d2200 1
a2200 1
   CALL(_C_LABEL(trap197), T_UNKNOWNFLT, r30)
d2204 1
a2204 1
GLOBAL(m197_interrupt_handler)
d2210 1
a2210 1
GLOBAL(m197_instruction_access_handler)
d2212 1
a2212 1
   CALL(_C_LABEL(trap197), T_INSTFLT, r30)
d2219 1
a2219 1
GLOBAL(m197_data_exception_handler)
d2224 1
a2224 1
GLOBAL(m197_misaligned_handler)
d2226 1
a2226 1
   CALL(_C_LABEL(trap197), T_MISALGNFLT, r30)
d2230 1
a2230 1
GLOBAL(m197_unimplemented_handler)
d2232 1
a2232 1
   CALL(_C_LABEL(trap197), T_ILLFLT, r30)
d2236 1
a2236 1
GLOBAL(m197_privilege_handler)
d2238 1
a2238 1
   CALL(_C_LABEL(trap197), T_PRIVINFLT, r30)
d2245 1
a2245 1
GLOBAL(m197_bounds_handler)
d2247 1
a2247 1
   CALL(_C_LABEL(trap197), T_BNDFLT, r30)
d2251 1
a2251 1
GLOBAL(m197_divide_handler)
d2253 1
a2253 1
   CALL(_C_LABEL(trap197), T_ZERODIV, r30)
d2257 1
a2257 1
GLOBAL(m197_overflow_handler)
d2259 1
a2259 1
   CALL(_C_LABEL(trap197), T_OVFFLT, r30)
d2263 1
a2263 1
GLOBAL(m197_fp_precise_handler)
d2269 1
a2269 1
GLOBAL(m197_nonmaskable)
d2271 1
a2271 1
   CALL(_C_LABEL(trap197), T_NON_MASK, r30)
d2275 1
a2275 1
GLOBAL(m197_data_read_miss)
d2277 1
a2277 1
   CALL(_C_LABEL(trap197), T_197_READ, r30)
d2281 1
a2281 1
GLOBAL(m197_data_write_miss)
d2283 1
a2283 1
   CALL(_C_LABEL(trap197), T_197_WRITE, r30)
d2287 1
a2287 1
GLOBAL(m197_inst_atc_miss)
d2289 1
a2289 1
   CALL(_C_LABEL(trap197), T_197_INST, r30)
d2293 1
a2293 1
GLOBAL(m197_syscall_handler)
d2300 1
a2300 1
GLOBAL(m197_bugtrap)
d2306 1
a2306 1
GLOBAL(m197_sigsys)
d2308 1
a2308 1
   CALL(_C_LABEL(trap197), T_SIGSYS, r30)
d2311 1
a2311 1
GLOBAL(m197_sigtrap)
d2313 1
a2313 1
   CALL(_C_LABEL(trap197), T_SIGTRAP, r30)
d2316 1
a2316 1
GLOBAL(m197_stepbpt)
d2318 1
a2318 1
   CALL(_C_LABEL(trap197), T_STEPBPT, r30)
d2321 1
a2321 1
GLOBAL(m197_userbpt)
d2323 1
a2323 1
   CALL(_C_LABEL(trap197), T_USERBPT, r30)
d2327 1
a2327 1
   GLOBAL(m197_break)
d2329 1
a2329 1
   CALL(_C_LABEL(trap197), T_KDB_BREAK, r30)
d2331 1
a2331 1
   GLOBAL(m197_trace)
d2333 1
a2333 1
   CALL(_C_LABEL(trap197), T_KDB_TRACE, r30)
d2335 1
a2335 1
   GLOBAL(m197_entry)
d2337 1
a2337 1
   CALL(_C_LABEL(trap197), T_KDB_ENTRY, r30)
d2341 1
a2341 1
   GLOBAL(m197_break)
d2343 1
a2343 1
   CALL(_C_LABEL(trap197), T_UNKNOWNFLT, r30)
d2345 1
a2345 1
   GLOBAL(m197_trace)
d2347 1
a2347 1
   CALL(_C_LABEL(trap197), T_UNKNOWNFLT, r30)
d2349 1
a2349 1
   GLOBAL(m197_entry)
d2351 1
a2351 1
   CALL(_C_LABEL(trap197), T_UNKNOWNFLT, r30)
d2368 1
a2368 1
GLOBAL(m197_error_handler)
d2457 1
a2457 2
ASGLOBAL(m197_error_loop)
	bsr m197_error_loop
d2479 1
a2479 1
GLOBAL(m197_reset_handler)
d2568 1
a2568 2
ASGLOBAL(m197_error_loop2)
	bsr m197_error_loop2
d2572 1
a2572 1
ASGLOBAL(m197_setup_phase_one)
d2600 1
a2600 1
ASGLOBAL(m197_already_on_kernel_stack)
d2625 1
a2625 1
ASGLOBAL(m197_use_SR3_pcb)
d2634 1
a2634 1
   *   An exception occurred while enabling the FPU. Since r31      *
d2681 1
a2681 1
   br.n   m197_have_pcb
d2684 1
a2684 1
ASGLOBAL(m197_pickup_stack)
d2709 1
a2709 1
ASGLOBAL(m197_have_pcb)
d2765 1
a2765 1
ASGLOBAL(m197_setup_phase_two)
d2841 1
a2841 1
ASGLOBAL(m197_fpu_enable)
d2953 1
a2953 1
#endif /* DDB */
d2989 1
a2989 1
   CALL(_C_LABEL(trap197), T_DATAFLT, r15)
d2997 1
a2997 1
ASGLOBAL(m197_return_to_calling_exception_handler)
@


1.8.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*   $OpenBSD: eh.S,v 1.8.4.3 2001/10/31 03:01:19 nate Exp $   */
d217 1
d219 2
a220 5
#include <machine/board.h>
#include <machine/trap.h>           /* for T_ defines */
#ifdef MVME188
#include <machine/mvme188.h>
#endif
d243 1
a243 1
	string  "eh.S: bad cpu number in FLAGS"
d1022 1
a1022 1
1: 	string "bad length (%d) to badaddr() from 0x%x"
@


1.8.4.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/*   $OpenBSD$   */
a218 1
#include <machine/param.h>          /* CPU_ and BRD_ defines */
d220 3
a222 1
#include <machine/board.h>
d240 2
a241 1
#define INTSTACK	0   /* To make interupts use their own stack */
d253 1
a253 1
	bsr  _C_LABEL(panic)
a256 67
#define OFF_VEC		0
#define OFF_EPSR	4
#define OFF_EXIP	8
#define OFF_ENIP	12
#define OFF_DSR		16
#define OFF_DLAR	20
#define OFF_DPAR	24
#define OFF_ISR		28
#define OFF_ILAR	32
#define OFF_IPAR	36
#define OFF_TMP		40


#define SAVE_CTX				; \
	stcr	r31, SRX			; \
	or.u	r31, r0,  hi16(_save_frame)	; \
	or	r31, r31, lo16(_save_frame)	; \
	/* save old R31 and other R registers */; \
	st.d	r0 , r31, GENREG_OFF(0)		; \
	st.d	r2 , r31, GENREG_OFF(2)		; \
	st.d	r4 , r31, GENREG_OFF(4)		; \
	st.d	r6 , r31, GENREG_OFF(6)		; \
	st.d	r8 , r31, GENREG_OFF(8)		; \
	st.d	r10, r31, GENREG_OFF(10)	; \
	st.d	r12, r31, GENREG_OFF(12)	; \
	st.d	r14, r31, GENREG_OFF(14)	; \
	st.d	r16, r31, GENREG_OFF(16)	; \
	st.d	r18, r31, GENREG_OFF(18)	; \
	st.d	r20, r31, GENREG_OFF(20)	; \
	st.d	r22, r31, GENREG_OFF(22)	; \
	st.d	r24, r31, GENREG_OFF(24)	; \
	st.d	r26, r31, GENREG_OFF(26)	; \
	st.d	r28, r31, GENREG_OFF(28)	; \
	st	r30, r31, GENREG_OFF(30)	; \
	ldcr	r1,  SRX			; \
	st	r1,  r31, GENREG_OFF(31)	; \
	ldcr	r1,  EPSR			; \
	ldcr	r2,  EXIP			; \
	ldcr	r3,  ENIP			; \
	st	r1,  r31, REG_OFF(EF_EPSR)	; \
	st	r2,  r31, REG_OFF(EF_EXIP)	; \
	st	r3,  r31, REG_OFF(EF_ENIP)	; \
	ldcr	r1,  DSR			; \
	ldcr	r2,  DLAR			; \
	ldcr	r3,  DPAR			; \
	st	r1,  r31, REG_OFF(EF_DSR)	; \
	st	r2,  r31, REG_OFF(EF_DLAR)	; \
	st	r3,  r31, REG_OFF(EF_DPAR)	; \
	ldcr	r1,  ISR			; \
	ldcr	r2,  ILAR			; \
	ldcr	r3,  IPAR			; \
	st	r1,  r31, REG_OFF(EF_ISR)	; \
	st	r2,  r31, REG_OFF(EF_ILAR)	; \
	st	r3,  r31, REG_OFF(EF_IPAR)	; \
	ldcr	r1, DSAP			; \
	ldcr	r2, DUAP			; \
	st	r1,  r31, REG_OFF(EF_DSAP)	; \
	st	r2,  r31, REG_OFF(EF_DUAP)	; \
	ldcr	r1, ISAP			; \
	ldcr	r2, IUAP			; \
	st	r1,  r31, REG_OFF(EF_ISAP)	; \
	st	r2,  r31, REG_OFF(EF_IUAP)	; \
	/* Restore r1, r2, r3, and r31	*/	; \
	ld	r1 , r31, GENREG_OFF(1)		; \
	ld.d	r2 , r31, GENREG_OFF(2)		; \
	ld	r31, r31, GENREG_OFF(31)

d289 1
a289 1
#ifdef M88100
d322 1
a322 1
#endif /* m88100 */
d324 1
a324 1
#ifdef M88110
a325 1
	SAVE_CTX					; \
d328 1
d330 1
a330 1
	stcr    r1, SR2   /* r1 now free */		; \
d332 4
a335 4
1:	ldcr    r1, EPSR 				; \
	bb0.n   PSR_SUPERVISOR_MODE_BIT, r1, 1f 	; \
	clr     FLAGS, FLAGS, 1<FLAG_FROM_KERNEL> 	; \
	set     FLAGS, FLAGS, 1<FLAG_FROM_KERNEL>	; \
d338 1
a338 1
	1:	bsr	m88110_setup_phase_one		; \
d344 4
d350 1
a350 1
	bsr	m88110_setup_phase_two			; \
d354 1
a354 1
#endif /* M88110 */
d362 2
a363 2
#define M88110_Data_Precheck \
   bb1.n   FLAG_IGNORE_DATA_EXCEPTION, FLAGS, m88110_ignore_data_exception
d374 1
a375 2
GLOBAL(eh_debug)	word 0x00000000
   
d426 1
a426 1
#ifdef M88100
d433 3
a435 3
	PREP("unknown", 0, DEBUG_UNKNOWN_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_UNKNOWNFLT, r30)
	DONE(DEBUG_UNKNOWN_BIT)
d439 5
a443 5
	PREP("interrupt", 1, DEBUG_INTERRUPT_BIT, No_SSBR_Stuff, No_Precheck)
	/* interrupt_func is set in mvme_bootstrap() */
	CALL(_C_LABEL(m88100_trap), T_INT, r30)
	/*CALLP(_interrupt_func, 1, r30) */
	DONE(DEBUG_INTERRUPT_BIT)
d447 3
a449 3
	PREP("inst", 2, DEBUG_INSTRUCTION_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_INSTFLT, r30)
	DONE(DEBUG_INSTRUCTION_BIT)
d456 2
a457 2
	PREP("data", 3, DEBUG_DATA_BIT, No_SSBR_Stuff, Data_Precheck)
	DONE(DEBUG_DATA_BIT)
d461 3
a463 3
	PREP("misalign", 4, DEBUG_MISALIGN_BIT, Clear_SSBR_Dest, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_MISALGNFLT, r30)
	DONE(DEBUG_MISALIGN_BIT)
d467 3
a469 3
	PREP("unimp", 5, DEBUG_UNIMPLEMENTED_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_ILLFLT, r30)
	DONE(DEBUG_UNIMPLEMENTED_BIT)
d477 8
a484 8
	stcr    r1, SR2    /* hold r1 for a moment */
	ldcr    r1, SXIP   /* look at the sxip... valid bit set? */
	bb1.n   RTE_VALID_BIT, r1, 1f /*skip over return if a valid exception*/
	ldcr    r1, SR2    /* restore r1 */
	RTE
1:	PREP("privilege", 6, DEBUG_PRIVILEGE_BIT, Clear_SSBR_Dest, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_PRIVINFLT, r30) 
	DONE(DEBUG_PRIVILEGE_BIT)
d491 3
a493 3
	PREP("bounds", 7, DEBUG_BOUNDS_BIT, Clear_SSBR_Dest, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_BNDFLT, r30)
	DONE(DEBUG_BOUNDS_BIT)
d497 3
a499 3
	PREP("divide", 8, DEBUG_DIVIDE_BIT, Clear_SSBR_Dest, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_ZERODIV, r30)
	DONE(DEBUG_DIVIDE_BIT)
d503 3
a505 3
	PREP("overflow", 9, DEBUG_OVERFLOW_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_OVFFLT, r30)
	DONE(DEBUG_OVERFLOW_BIT)
d510 3
a512 3
	PREP("FPU precise", 114, DEBUG_FPp_BIT, FPp_SSBR_STUFF, No_Precheck)
	CALL(_m88100_Xfp_precise, r0, r30) /* call fp_precise(??, exception_frame)*/
	DONE(DEBUG_FPp_BIT)
d517 3
a519 3
	PREP("FPU imprecise", 115, DEBUG_FPi_BIT, FPi_SSBR_STUFF, No_Precheck)
	CALL(_Xfp_imprecise, r0, r30) /*call fp_imprecise(??,exception_frame)*/
	DONE(DEBUG_FPi_BIT)
d523 4
a526 4
	PREP("syscall", 128, DEBUG_SYSCALL_BIT, No_SSBR_Stuff, No_Precheck)
	ld   r13, r30, GENREG_OFF(13)
	CALL(_m88100_syscall, r13, r30) /* system call no. is in r13 */
	DONE(DEBUG_SYSCALL_BIT)
d530 4
a533 4
	PREP("bugsyscall", 496, DEBUG_BUGCALL_BIT, No_SSBR_Stuff, No_Precheck)
	ld   r9,  r30, GENREG_OFF(9)
	CALL(_bugsyscall, r9, r30)   /* system call no. is in r9 */
	DONE(DEBUG_BUGCALL_BIT)
d536 3
a538 3
	PREP("sigsys", 0, DEBUG_SIGSYS_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_SIGSYS, r30)
	DONE(DEBUG_SIGSYS_BIT)
d541 3
a543 3
	PREP("sigtrap", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_SIGTRAP, r30)
	DONE(DEBUG_SIGTRAP_BIT)
d546 3
a548 3
	PREP("stepbpt", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_STEPBPT, r30)
	DONE(DEBUG_SIGTRAP_BIT)
d551 3
a553 3
	PREP("userbpt", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_USERBPT, r30)
	DONE(DEBUG_SIGTRAP_BIT)
d556 13
a568 14
ASGLOBAL(break)
	PREP("break", 130, DEBUG_BREAK_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_KDB_BREAK, r30)
	DONE(DEBUG_BREAK_BIT)

ASGLOBAL(trace)
	PREP("trace", 131, DEBUG_TRACE_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_KDB_TRACE, r30)
	DONE(DEBUG_TRACE_BIT)

GLOBAL(entry)
	PREP("kdb", 132, DEBUG_KDB_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_KDB_ENTRY, r30)
	DONE(DEBUG_KDB_BIT)
d571 12
a582 14
ASGLOBAL(break)
	PREP("break", 130, DEBUG_BREAK_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_UNKNOWNFLT, r30)
	DONE(DEBUG_BREAK_BIT)

ASGLOBAL(trace)
	PREP("trace", 131, DEBUG_TRACE_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_UNKNOWNFLT, r30)
	DONE(DEBUG_TRACE_BIT)

GLOBAL(entry)
	PREP("unknown", 132, DEBUG_UNKNOWN_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88100_trap), T_UNKNOWNFLT, r30)
	DONE(DEBUG_KDB_BIT)
d687 3
a689 3
	or.u	r10,  r0,   hi16(_brdtyp)
	ld	r11,  r10,  lo16(_brdtyp)
	cmp	r10,  r11,  BRD_188
d693 1
a693 1
	st	r11, r31,   REG_OFF(EF_MASK) /* put in EF_MASK for regdump */ 
d715 1
a715 1
        CALL(_C_LABEL(error_fault), r30, r30)
d853 1
a853 1
	CALL(_C_LABEL(error_reset), r30, r30)
d899 1
a899 1
#endif /* m88100 */
d901 1
a901 1
#ifdef M88110
d905 1
a905 1
ASGLOBAL(m88110_ignore_data_exception)
d908 1
a908 1
	*  SR1: previous FLAGS reg                             *
d910 1
a910 1
	*  SR3: must preserve                                  *
d918 1
a918 1
	 * We just want to jump to "m88110_badaddr__return_nonzero" below.
d925 3
a927 3
	or.u	r2, r0, hi16(m88110_badaddr__return_nonzero)
	or	r2, r2, lo16(m88110_badaddr__return_nonzero)
	stcr	r2, EXIP   /* Make it the next instruction to execute */
d929 1
a929 1
	/* the following jumps to "m88110_badaddr__return_nonzero" below */ 
d932 1
a932 1
#endif /* M88110 */
d957 4
a960 4
	/*
	 * Disable interrupts ... don't want a context switch while we're
	 * doing this! Also, save the old PSR in R8 to restore later.
	 */
d1029 1
a1029 1
	bsr   _C_LABEL(printf)
d1032 1
a1032 1
	bsr   _C_LABEL(panic)
a1055 12
ASGLOBAL(m88110_badaddr__return_nonzero)
	/* 
	 * On mc88110, we possibly took an exception 
	 * and we have to clear DSR after the rte
	 * instruction clears the EFRZ bit in 
	 * the PSR. 
	 */
	stcr r0, DSR	/* Clear DSR reg on mc88110 */
	stcr r0, DLAR	/* Clear DLAR reg on mc88110 */
	br.n badaddr__return_nonzero
	stcr r0, DPAR	/* Clear DPAR reg on mc88110 */

d1062 1
a1062 1
#ifdef M88100 
d1065 16
a1080 16
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread (if any, null if not)                     *
	* SR1: saved copy of exception-time register now holding FLAGS  *
	* SR2: saved copy of exception-time r1                          *
	* SR3: must be preserved .. may be the exception-time stack     *
	* r1: return address to calling exception handler               *
	* FLAGS: CPU status flags                                       *
	***************************************************             *
	* immediate goal:                                               *
	*    Decide where we're going to put the exception frame.       *
	*   Might be at the end of R31, SR3, or the thread's            *
	*   pcb.                                                        *
	\***************************************************************/
	
	/* Check if we are coming in from a FPU restart exception.
	   If so, the pcb will be in SR3 */
d1088 1
a1088 1
	/* are we coming in from user mode? If so, pick up thread pcb */
d1091 1
a1091 1
	/* Interrupt in kernel mode, not FPU restart */
d1093 12
a1104 12
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread (if any, null if not)                     *
	* SR1: saved copy of exception-time register now holding FLAGS  *
	* SR2: return address to the calling exception handler          *
	* SR3: must be preserved; may be important for other exceptions *
	* FLAGS: CPU status flags                                       *
	***************************************************             *
	* immediate goal:                                               *
	*   We're already on the kernel stack, but not having           *
	*   needed to use SR3. We can just make room on the             *
	*    stack (r31) for our exception frame.                       *
	\***************************************************************/
d1118 23
a1140 23
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread (if any, null if not)                     *
	* SR1: saved copy of exception-time register now holding FLAGS  *
	* SR2: return address to the calling exception handler          *
	* SR3: must be preserved; exception-time stack pointer          *
	* FLAGS: CPU status flags                                       *
	***************************************************             *
	* immediate goal:                                               *
	*   An exception occured while enabling the FPU. Since r31      *
	*   is the user's r31 while enabling the FPU, we had put        *
	*   our pcb pointer into SR3, so make room from                 *
	*   there for our stack pointer.                                *
	*       We need to check if SR3 is the old stack pointer or the *
	*       pointer off to the user pcb. If it pointing to the user *
	*       pcb, we need to pick up the kernel stack. Otherwise     *
	*       we need to allocate a frame upon it.                    *
	*       We look at the EPSR to see if it was from user mode     *
	*       Unfortunately, we have no registers free at the moment  *
	*       But we know register 0 in the pcb frame will always be  *
	*       zero, so we can use it as scratch storage.              *
	*                                                               *
	*                                                               *
	\***************************************************************/
d1146 1
a1146 1
	/* we were in kernel mode - dump frame upon the stack */
d1159 4
a1162 4
	/* we took an exception while restarting the FPU from user space.
	 * Consequently, we never picked up a stack. Do so now.
	 * R1 is currently free (saved in the exception frame pointed at by
	 * r30) */
d1177 12
a1188 12
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                          *
	* SR1: saved copy of exception-time register now holding FLAGS *
	* SR2: return address to the calling exception handler         *
	* SR3: free                                                    *
	* FLAGS: CPU status flags                                      *
	***************************************************            *
	* immediate goal:                                              *
	*    Since we're servicing an exception from user mode, we     *
	*   know that SR3 is free.  We use it to free up a temp.       *
	*   register to be used in getting the thread's pcb            *
	\***************************************************************/
d1191 1
a1191 1
	/* switch to the thread's kernel stack. */
d1199 1
a1199 1
	/*FALLTHROUGH */
d1238 3
a1240 3
	or.u	TMP,  r0,   hi16(_brdtyp)
	ld	TMP2, TMP,  lo16(_brdtyp)
	cmp	TMP,  TMP2, BRD_188
d1400 19
a1418 19
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                          *
	* SR1: saved copy of exception-time register now holding FLAGS *
	* SR2: return address to the calling exception handler         *
	* SR3: saved TMP                                               *
	* r1:  free                                                    *
	* TMP: possibly revised SSBR                                   *
	* TMP2: free                                                   *
	* TMP3: free                                                   *
	* FLAGS: CPU status flags                                      *
	* r31: exception frame                                         *
	*    Valid in the exception frame:                             *
	*   Exception-time r1, r31, FLAGS.                             *
	*   Exception-time TMP2, TMP3.                                 *
	*   Exception-time espr, sfip, snip, sxip.                     *
	*   Dmt0.                                                      *
	*   Other data pipeline control registers, if appropriate.     *
	*   Exception SR3, if appropriate.                             *
	\***************************************************************/
d1422 1
a1422 1
#endif /* m88100 */
d1428 9
a1436 9
	/*
	 * Clear floatingpont-imprecise ssbr bits.
	 * Also, save appropriate FPU control registers to the E.F.
	 *
	 *  r1:  return address to calling exception handler
	 *  TMP : (possibly) revised ssbr
	 *  TMP2 : free
	 *  TMP3 : free
	 */
d1452 4
a1455 4
	/*
	 * We only need clear the bit in the SSBR for the
	 * 2nd reg of a double result [see section 6.8.5]
	 */
d1471 28
a1498 28
	/*
	 * Clear floating pont precise ssbr bits.
	 * Also, save appropriate FPU control registers to the E.F.
	 *
	 *  r1:  return address to calling exception handler
	 *  TMP : (possibly) revised ssbr
	 *  TMP2 : free
	 *  TMP3 : free
	 */
	fldcr TMP2, FPSR
	fldcr TMP3, FPCR
	st    TMP2, r31,  REG_OFF(EF_FPSR)
	st    TMP3, r31,  REG_OFF(EF_FPCR)
	
	fldcr TMP3, FPECR
	st    TMP3, r31,  REG_OFF(EF_FPECR)
	fldcr TMP2, FPHS1
	fldcr TMP3, FPHS2
	st    TMP2, r31,  REG_OFF(EF_FPHS1)
	st    TMP3, r31,  REG_OFF(EF_FPHS2)
	
	fldcr TMP2, FPLS1
	fldcr TMP3, FPLS2
	st    TMP2, r31,  REG_OFF(EF_FPLS1)
	st    TMP3, r31,  REG_OFF(EF_FPLS2)
	
	fldcr TMP2, FPPT
	st    TMP2, r31,  REG_OFF(EF_FPPT)
d1502 9
a1510 7
	bb1.n FPPT_SIZE_BIT, TMP2, 2f
	extu  TMP3, TMP2, 5<0> /* get FP operation dest reg */
	br.n  3f
	set   TMP3, TMP3, 1<5> /* set size=1 -- clear one bit for "float" */
2:	set   TMP3, TMP3, 1<6> /* set size=2 -- clear two bit for "double" */ 
3:	clr   TMP,  TMP,  TMP3   /* clear bit(s) in ssbr. */
4:	jmp   r1
d1516 1
d1518 32
a1549 32
	/*
	 * There are various cases where an exception can leave the
	 * destination register's bit in the SB set.
	 * Examples:
	 *   misaligned or privilege exception on a LD or XMEM
	 *   DIV or DIVU by zero.
	 *
	 * I think that if the instruction is LD.D, then two bits must
	 * be cleared.
	 *
	 * Even though there are a number of instructions/exception
	 * combinations that could fire this code up, it's only required
	 * to be run for the above cases.  However, I don't think it'll
	 * ever be a problem to run this in other cases (ST instructions,
	 * for example), so I don't bother checking.  If we had to check
	 * for every possible instruction, this code would be much larger.
	 *
	 * The only checking, then, is to see if it's a LD.D or not.
	 *
	 * At the moment....
	 *  r1:  return address to calling exception handler
	 *  TMP : (possibly) revised ssbr
	 *  TMP2 : free
	 *  TMP3 : free
	 */
	
	ldcr  TMP3, EPSR   /* going to check: user or system memory? */
	ldcr  TMP2, SXIP   /* get the instruction's address */
	bb1.n PSR_SUPERVISOR_MODE_BIT, TMP3, 2f
	clr   TMP2, TMP2, 2<0> /* get rid of valid and error bits. */
	
1:	/* user space load here */
d1551 6
a1556 6
	NOP
	ld.usr TMP2,TMP2, r0      /* get the instruction itself */
	NOP
	NOP
	NOP
	br    3f
d1558 2
a1559 2
	br.n  3f
	ld.usr TMP2,TMP2, r0      /* get the instruction itself */
d1562 40
a1601 2
2:	/* system space load here */
	ld    TMP2, TMP2, r0      /* get the instruction itself */
a1602 38
3:	/* now have the instruction..... */
	/*
	 * Now see if it's a double load
	 * There are three forms of double load [IMM16, scaled, unscaled],
	 * which can be checked by matching against two templates:
	 *          -- 77776666555544443333222211110000 --
	 *   if (((instruction & 11111100000000000000000000000000) ==
	 *             00010000000000000000000000000000) ;;
	 *       ((instruction & 11111100000000001111110011100000) ==
	 *             11110100000000000001000000000000))
	 *   {
	 *      It's a load double, so
	 *      clear two SSBR bits.
	 *   } else {
	 *      It's not a load double.
	 *      Must be a load single, xmem, or st
	 *      Thus, clear one SSBR bit.
	 *   }
	 */
	/* check the first pattern for ld.d */
	extu  TMP3, TMP2, 16<16>   /* get the upper 16 bits */
	mask  TMP3, TMP3, 0xFC00   /* apply the mask */
	cmp   TMP3, TMP3, 0x1000   /* if this is equal, it's a load double */
	bb1   eq,   TMP3, misaligned_double
	
	/* still could be -- check the second pattern for ld.d */
	/* look at the upper 16 bits first */
	extu  TMP3, TMP2, 16<16>   /* get the upper 16 bits */
	mask  TMP3, TMP3, 0xFC00   /* apply the mask */
	cmp   TMP3, TMP3, 0xF400   /* if equal, it might be a load double */
	bb1   ne,   TMP3, misaligned_single /* not equal, so must be single */
	
	/* now look at the lower 16 bits */
	extu  TMP3, TMP2, 16<0>    /* get the lower 16 bits */
	mask  TMP3, TMP3, 0xFCE0   /* apply the mask */
	cmp   TMP3, TMP3, 0x1000   /* if this is equal, it's a load double */
	bb1   eq,   TMP3, misaligned_double
	
d1604 3
a1606 3
	extu  TMP2, TMP2, 5<21>    /* get the destination register */
	br.n  1f
	set   TMP2, TMP2, 1<5>     /* set size=1 */
d1609 2
a1610 2
	extu  TMP2, TMP2, 5<21>    /* get the destination register */
	set   TMP2, TMP2, 1<6>     /* set size=2 -- clear two bit for "ld.d" */
d1612 2
a1613 2
1:	jmp.n   r1
	clr   TMP,  TMP,  TMP2     /* clear bit(s) in ssbr. */
d1618 1
a1618 1
#ifdef M88100
d1621 32
a1652 32
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: saved return address to calling exception handler        *
	* SR1: saved copy of exception-time register now holding FLAGS  *
	* SR2: free                                                     *
	* SR3: saved TMP                                                *
	* r1:  return address to calling exception handler              *
	* TMP: possibly revised SSBR                                    *
	* TMP2: free                                                    *
	* TMP3: free                                                    *
	* FLAGS: CPU status flags                                       *
	* r31: our exception frame                                      *
	*    Valid in the exception frame:                              *
	*   Exception-time r1, r31, FLAGS.                              *
	*   Exception-time TMP2, TMP3.                                  *
	*   Exception-time espr, sfip, snip, sxip.                      *
	*   Exception number (EF_VECTOR).                               *
	*   Dmt0                                                        *
	*   Other data pipeline control registers, if appropriate.      *
	*   FPU control registers, if appropriate.                      *
	*   Exception SR3, if appropriate.                              *
	***************************************************             *
	* immediate goal:                                               *
	*   restore the system to the exception-time state (except      *
	* SR3 will be OUR stack pointer) so that we may resart the FPU. *
	\***************************************************************/
	/*stcr   r1, SR0*/      /* save return address */
	
	stcr  TMP,  SSBR   /* done with SSBR, TMP now free */
	RESTORE_TMP2      /* done with extra temp regs */
	RESTORE_TMP3      /* done with extra temp regs */
	
	/* Get the current PSR and modify for the rte to enable the FPU */
d1654 11
a1664 11
	ldcr  TMP,  PSR
	clr   TMP,  TMP,  1<PSR_FPU_DISABLE_BIT>    /* enable the FPU */
	clr   TMP,  TMP,  1<PSR_SHADOW_FREEZE_BIT>  /* also enable shadowing */
	stcr  TMP,  EPSR
	
	/* the "+2" below is to set the VALID_BIT */
	or.u  TMP,  r0,   hi16(fpu_enable +2)
	or    TMP,  TMP,  lo16(fpu_enable +2)
	stcr  TMP,  SNIP      /* jump to here fpu_enable */
	addu  TMP,  TMP,  4
	stcr  TMP,  SFIP      /* and then continue after that */
d1666 10
a1675 10
	ldcr  TMP,  PSR
	or.u  TMP,  TMP,  0x8000    /* set supervisor mode */
	and   TMP,  TMP,  0xfff7    /* also enable shadowing */
	stcr  TMP,  EPSR
	stcr  r0,   SXIP       /* clear valid bit */
	stcr  r0,   SNIP       /* clear valid bit */
	or.u  TMP,  r0,   hi16(fpu_enable)
	or    TMP,  TMP,  lo16(fpu_enable)
	or    TMP,  TMP,  0x2 /* set the VALID_BIT and clear Exception bit */
	stcr  TMP,  SFIP      /* jump to here fpu_enable */
d1679 34
a1712 34
	set   FLAGS, FLAGS, 1<FLAG_ENABLING_FPU> /* note what we're doing.*/
	xcr   FLAGS, FLAGS, SR1
	st    r1,   r31,  REG_OFF(EF_RET) /* save the return address */
	ld    r1,   r31,  GENREG_OFF(1)    /* get original r1 */
	
	xcr   TMP,  r31,  SR3   /* TMP now restored. R31 now saved in SR3 */
	ld    r31,  r31,  GENREG_OFF(31) /* get original r31 */
	
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                           *
	* SR1: CPU flags                                                *
	* SR2: free                                                     *
	* SR3: pointer to our exception frame (our stack pointer)       *
	* r1 through r31: original exception-time values                *
	*                                                               *
	* Valid in the exception frame:                                 *
	*   Exception-time FLAGS.                                       *
	*   Exception-time espr, sfip, snip, sxip.                      *
	*   Exception number (EF_VECTOR).                               *
	*   Dmt0                                                        *
	*   Other data pipeline control registers, if appropriate.      *
	*   FPU control registers, if appropriate.                      *
	*   Exception SR3, if appropriate.                              *
	*   Held temporarly in the exception frame:                     *
	*   Return address to the calling excption handler.             *
	***************************************************             *
	* immediate goal:                                               *
	*   Do an RTE to restart the fpu and jump to "fpu_enable"       *
	*   Another exception (or exceptions) may be raised in          *
	*   this, which is why FLAG_ENABLING_FPU is set in SR1.         *
	\***************************************************************/
	
	RTE   /* jumps to "fpu_enable" on the next line to enable the FPU. */
	
d1714 29
a1742 29
	FLUSH_PIPELINE
	xcr   TMP,  TMP,  SR3               /* get E.F. pointer */
	st.d  r30,  TMP,  GENREG_OFF(30)    /* save previous r30, r31 */
	or    r31,  TMP,  r0                /* transfer E.F. pointer to r31 */
	ld    TMP,  r31,  REG_OFF(EF_SR3)   /* get previous SR3; maybe important*/
	
	/* make sure that the FLAG_ENABLING_FPU bit is off */
	xcr   FLAGS,FLAGS,SR1
	clr   FLAGS,FLAGS,1<FLAG_ENABLING_FPU>
	xcr   FLAGS,FLAGS,SR1
	
	xcr   TMP,  TMP,  SR3       /* replace TMP, SR3 */
	
	/* now save all regs to the exception frame. */
	st.d  r0 ,  r31,  GENREG_OFF(0)
	st.d  r2 ,  r31,  GENREG_OFF(2)
	st.d  r4 ,  r31,  GENREG_OFF(4)
	st.d  r6 ,  r31,  GENREG_OFF(6)
	st.d  r8 ,  r31,  GENREG_OFF(8)
	st.d  r10,  r31,  GENREG_OFF(10)
	st.d  r12,  r31,  GENREG_OFF(12)
	st.d  r14,  r31,  GENREG_OFF(14)
	st.d  r16,  r31,  GENREG_OFF(16)
	st.d  r18,  r31,  GENREG_OFF(18)
	st.d  r20,  r31,  GENREG_OFF(20)
	st.d  r22,  r31,  GENREG_OFF(22)
	st.d  r24,  r31,  GENREG_OFF(24)
	st.d  r26,  r31,  GENREG_OFF(26)
	st.d  r28,  r31,  GENREG_OFF(28)
d1744 4
a1747 4
	/* mark beginning of frame with notable value */
	or.u  r20,  r0,   hi16(0x12345678)
	or    r20,  r20,  lo16(0x12345678)
	st    r20,  r31,  GENREG_OFF(0)
d1749 36
a1784 36
	
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                           *
	* SR1: free                                                     *
	* SR2: free                                                     *
	* SR3: previous exception-time SR3                              *
	* r1: return address to the calling exception handler           *
	* r2 through r30: free                                          *
	* r31: our exception frame                                      *
	*                                                               *
	* Valid in the exception frame:                                 *
	*   Exception-time r0 through r31.                              *
	*   Exception-time FLAGS.                                       *
	*   Exception-time espr, sfip, snip, sxip.                      *
	*   Exception number (EF_VECTOR).                               *
	*   Dmt0                                                        *
	*   Other data pipeline control registers, if appropriate.      *
	*   FPU control registers, if appropriate.                      *
	*   Exception SR3, if appropriate.                              *
	***************************************************             *
	* immediate goal:                                               *
	*   Pick up a stack if we came in from user mode. Put           *
	*       A copy of the exception frame pointer into r30          *
	*       bump the stack a doubleword and write the exception     *
	*       frame pointer.                                          *
	*   if not an interrupt exception,                              *
	*       Turn on interrupts and service any outstanding          *
	*       data access exceptions.                                 *
	*   Return to calling exception handler to                      *
	*   service the exception.                                      *
	\***************************************************************/
	
	/*
	 * If it's not the interrupt exception, enable interrupts and
	 * take care of any data access exceptions......
	 */
d1786 2
a1787 4
	/*
	 * If interrupt exception, switch to interrupt stack if not
	 * already there. Else, switch to kernel stack.
	 */
d1789 4
a1792 3
	or    r30,  r0,   r31		/* get a copy of the e.f. pointer */ 
	ld    r2,   r31,  REG_OFF(EF_EPSR)
	bb1   PSR_SUPERVISOR_MODE_BIT, r2, 1f  /* If in kernel mode */
d1795 6
a1800 6
	ld    r3,   r31,  REG_OFF(EF_VECTOR)
	cmp   r3,   r3,   1      /* is interrupt ? */
	bb0   eq,   r3,   2f
	or.u  r31,  r0,   hi16(_intstack_end)   /* swith to int stack */
	or    r31,  r31,  lo16(_intstack_end)
	br    3f
d1803 4
a1806 4
	or.u  r31,  r0,   hi16(_kstack)
	ld    r31,  r31,  lo16(_kstack)
	addu  r31,  r31,  USIZE        /* point at proper end */
	br    3f
d1809 5
a1813 5
	ld    r3,   r31,  REG_OFF(EF_VECTOR)
	cmp   r3,   r3,   1       /* is interrupt ? */
	bb0   eq,   r3,   3f      /* no, we will stay on kern stack */
	or.u  r31,  r0,   hi16(_intstack_end)   /* swith to int stack */
	or    r31,  r31,  lo16(_intstack_end)
d1815 1
a1815 1
	/* This label is here for debugging */
d1817 6
a1822 6
3:	/*
	 * here - r30 holds a pointer to the exception frame.
	 * r31 is a pointer to the kernel stack/interrupt stack.
	*/
	subu  r31,  r31,  8  /* make some breathing space */
	st    r30,  r31,  0  /* store frame pointer on the stack */
d1824 1
a1824 1
	st    r30,  r31,  4  /* store it again for the debugger to recognize */
d1827 5
a1831 5
	ld    r2,   r30,  REG_OFF(EF_VECTOR)
	bcnd.n eq0, r2,   return_to_calling_exception_handler  /* is error */
	ld    r14,  r30,  REG_OFF(EF_RET)
	cmp   r3,   r2,   1 /* interrupt is exception #1 ;Is an interrupt? */
	bb1.n eq,   r3,   return_to_calling_exception_handler /* skip if so */
d1834 5
a1838 4
	cmp   r3,   r2,   130 /* DDB break exception */
	bb1.n eq,   r3,   return_to_calling_exception_handler
	cmp   r3,   r2,   132 /* DDB entry exception */
	bb1.n eq,   r3,   return_to_calling_exception_handler
d1841 3
a1843 3
	ldcr  r2,   PSR
	clr   r2,   r2,   1<PSR_INTERRUPT_DISABLE_BIT>   /* enable interrupts */
	stcr  r2,   PSR
d1845 1
a1845 1
	FLUSH_PIPELINE
d1848 2
a1849 2
	/* service any outstanding data pipeline stuff
	   - check dmt0 anything outstanding?*/
d1851 2
a1852 2
	ld    r3,   r30,  REG_OFF(EF_DMT0)
	bb0   DMT_VALID_BIT, r3, return_to_calling_exception_handler
d1854 5
a1858 5
	/*
	  r30 can be clobbered by calls. So stuff its value into a
	  preserved register, say r15. R14 is in use (see return_to_... below). 
	 */
	or    r15,  r0,   r30
d1860 2
a1861 2
	CALL(_C_LABEL(m88100_trap), T_DATAFLT, r15)
	CALL(_data_access_emulation, r15, r0)
d1863 2
a1864 2
	/*   restore it... */
	or    r30,  r0,   r15
d1866 2
a1867 2
	/* clear the dmt0 word in the E.F */
	st    r0,   r30,  REG_OFF(EF_DMT0)
d1870 2
a1871 2
	jmp   r14 /* loaded above */
#endif /* m88100 */
d1884 10
a1893 10
	ld	r1,r31,0	/* load func */
	ld	r2,r31,4 	/* load proc pointer */
	jsr.n	r1
	subu	r31,r31,40	/* create stack space for function */
	addu	r31,r31,48	/* stack space above + ksigframe */
	ld	r1, r31,0	/* load pc */
	ld	r2, r31,4	/* & proc pointer from switch frame */ 
	jsr.n	r1
	addu	r31,r31,8
	bsr	_C_LABEL(panic)
d1904 4
a1907 4
	ld	r3,r2,P_ADDR		/* p->p_addr */
	addu	r3,r3,PCB_USER_STATE	/* p->p_addr.u_pcb.user_state */
	st	r3,r31,0		/* put it on the stack */
	br	return_from_exception_handler
d1927 5
a1931 5
#ifdef M88110	
	or.u	r2, r0, hi16(_C_LABEL(cputyp))
	ld	r3, r2, lo16(_C_LABEL(cputyp))
	cmp	r2, r3, CPU_88110
	bb1	eq, r2, m88110_return_code        
d1933 3
a1935 1
#ifdef M88100
d1942 4
a1945 4
	/*
	 * This might happen for non-interrupts  If the user sets DMT0
	 * in an exception handler.........
	 */
d1952 1
a1952 1
	CALL(_C_LABEL(db_printf), r4, r0)
d1962 9
a1970 9
	/*
	 * If it's the interrupt exception, enable interrupt.
	 * Take care of any data access exception...... 90/8/15 add by yama
	 */
	
	/*
	 * Is it ever possible to have interrupt exception while EPSR has
	 * it disabled? I don't think so.. XXX nivas
	 */
d1975 1
a1975 1
	/* if EPSR has interrupts disabled, skip also */
d1977 1
a1977 1
        bb1   PSR_INTERRUPT_DISABLE_BIT, r2, 1f		/* skip if disabled */
d1979 2
a1980 2
	clr   r2, r2, 1<PSR_INTERRUPT_DISABLE_BIT>	/* enable interrupts */
	FLUSH_PIPELINE
d1982 1
a1982 1
1:
d1986 8
a1993 7
	/*
	 * if there happens to be a data fault that hasn't been serviced yet,
	 * go off and service that...
	 */
	CALL(_C_LABEL(m88100_trap), T_DATAFLT, r30)
	CALL(_C_LABEL(data_access_emulation), r30, r0) /* really only 2 args */
	/* clear the dmt0 word in the E.F. */
d1995 1
a1995 1
2:
d1997 4
a2000 4
#endif /* m88100 */

#ifdef M88110
ASLOCAL(m88110_return_code)
d2003 3
d2007 1
d2009 2
a2010 2
	 * If it's the interrupt exception, enable interrupt.
	 * If it's the data access exception, take care of it.
d2012 20
d2033 4
a2036 6
	/*
	 * Is it ever possible to have interrupt exception while EPSR has
	 * it disabled? I don't think so.. XXX nivas
	 * 
	 * On mc88110, you can.  The NMI interrupt. aka ABORT. XXX smurph
	 */
d2038 2
a2039 2
	cmp	r2, r2, 1   /* Is it an interrupt? */ 
	bb1	ne, r2, 1f  /* If not, skip */
d2041 1
a2041 1
	/* if EPSR has interrupts disabled, skip also */
d2049 3
a2051 4
	br 2f	/* temp XXX smurph */
	ld	r2, FPTR, REG_OFF(EF_VECTOR)
	cmp	r2, r2, 3   /* Is it a data access exception? */ 
	bb1	ne, r2, 2f  /* If not, skip */
d2053 5
a2057 5
	/*
	 * if there happens to be a data fault that hasn't been serviced yet,
	 * go off and service that...
	 */
	CALL(_C_LABEL(m88110_trap), T_DATAFLT, r30)
d2059 1
a2059 1
	/* clear the dsr word in the E.F. */
a2060 2
	st	r0, FPTR, REG_OFF(EF_DLAR)
	st	r0, FPTR, REG_OFF(EF_DPAR)
d2062 1
a2062 1
#endif /* M88110 */
d2074 1
a2074 1
        bcnd    ne0, r2, 1f		/* can't do softint's */
d2077 1
a2077 1
	bsr.n   _C_LABEL(setipl)
a2078 1
	/* at ipl 1 now */	
d2080 1
a2080 1
        bsr     _C_LABEL(dosoftint)
d2083 2
a2084 2
        bsr.n   _C_LABEL(setipl)
        or      r2,r0,0			/* ints are enabled */
d2093 2
a2094 2
        or.u	r2, r0, hi16(_C_LABEL(want_ast))
        ld	r3, r2, lo16(_C_LABEL(want_ast))
d2100 16
a2115 7
#ifdef M88110         
	or.u	r2, r0, hi16(_C_LABEL(cputyp))
	ld	r3, r2, lo16(_C_LABEL(cputyp))
	cmp	r2, r3, CPU_88110
	bb0	eq, r2, 2f
        CALL(_C_LABEL(m88110_trap), T_ASTFLT, FPTR)
	br	no_ast
a2117 3
#ifdef M88100
        CALL(_C_LABEL(m88100_trap), T_ASTFLT, FPTR)
#endif
d2122 4
a2125 4
        bsr     _C_LABEL(getipl)
        bcnd    eq0, r2, 3f
        bsr     _C_LABEL(panic)
3:
d2131 1
d2138 1
d2140 1
a2140 1
	bsr.n   _C_LABEL(setipl)
d2148 1
d2173 11
a2184 13
#ifdef M88110
        or.u	r1, r0, hi16(_C_LABEL(cputyp))
	ld	r30, r1, lo16(_C_LABEL(cputyp))
	cmp	r1, r30, CPU_88110
	bb1	ne, r1, 1f
        /* mc88110 needs the EXIP */
	ld      r30, r31, REG_OFF(EF_ENIP)
        ld      r1,  r31, REG_OFF(EF_EXIP)
        stcr    r30, ENIP
        stcr    r1,  EXIP
	br 	2f      
1:
#endif 
d2215 1
a2215 1
#ifdef M88110 	
d2221 4
a2224 4
GLOBAL(m88110_unknown_handler)
	PREP2("unknown", 0, DEBUG_UNKNOWN_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_UNKNOWNFLT, r30)
	DONE(DEBUG_UNKNOWN_BIT)
d2227 4
a2230 4
GLOBAL(m88110_interrupt_handler)
	PREP2("interrupt", 1, DEBUG_INTERRUPT_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_INT, r30)
	DONE(DEBUG_INTERRUPT_BIT)
d2233 5
a2237 4
GLOBAL(m88110_instruction_access_handler)
	PREP2("inst", 2, DEBUG_INSTRUCTION_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_INSTFLT, r30)
	DONE(DEBUG_INSTRUCTION_BIT)
d2242 3
a2244 4
GLOBAL(m88110_data_exception_handler)
	PREP2("data", 3, DEBUG_DATA_BIT, No_SSBR_Stuff, M88110_Data_Precheck)
	CALL(_C_LABEL(m88110_trap), T_DATAFLT, r30)
	DONE(DEBUG_DATA_BIT)
d2247 4
a2250 4
GLOBAL(m88110_misaligned_handler)
	PREP2("misalign", 4, DEBUG_MISALIGN_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_MISALGNFLT, r30)
	DONE(DEBUG_MISALIGN_BIT)
d2253 4
a2256 4
GLOBAL(m88110_unimplemented_handler)
	PREP2("unimp", 5, DEBUG_UNIMPLEMENTED_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_ILLFLT, r30)
	DONE(DEBUG_UNIMPLEMENTED_BIT)
d2259 4
a2262 4
GLOBAL(m88110_privilege_handler)
	PREP2("privilege", 6, DEBUG_PRIVILEGE_BIT, No_SSBR_Stuff, No_Precheck) 
	CALL(_C_LABEL(m88110_trap), T_PRIVINFLT, r30)
	DONE(DEBUG_PRIVILEGE_BIT)
d2268 4
a2271 4
GLOBAL(m88110_bounds_handler)
	PREP2("bounds", 7, DEBUG_BOUNDS_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_BNDFLT, r30)
	DONE(DEBUG_BOUNDS_BIT)
d2274 4
a2277 4
GLOBAL(m88110_divide_handler)
	PREP2("divide", 8, DEBUG_DIVIDE_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_ZERODIV, r30)
	DONE(DEBUG_DIVIDE_BIT)
d2280 4
a2283 4
GLOBAL(m88110_overflow_handler)
	PREP2("overflow", 9, DEBUG_OVERFLOW_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_OVFFLT, r30)
	DONE(DEBUG_OVERFLOW_BIT)
d2286 10
a2295 10
GLOBAL(m88110_fp_precise_handler)
	PREP2("FPU precise", 114, DEBUG_FPp_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_m88110_Xfp_precise, r0, r30) /* call fp_precise(??, exception_frame)*/
	DONE(DEBUG_FPp_BIT)

/* MVME197 non-maskable interrupt handler (ABORT button) */
GLOBAL(m88110_nonmaskable)
	PREP2("MVME197 non-mask", 11, DEBUG_NON_MASK_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_NON_MASK, r30)
	DONE(DEBUG_NON_MASK_BIT)
d2298 4
a2301 4
GLOBAL(m88110_data_read_miss)
	PREP2("MVME197 read miss", 12, DEBUG_197_READ_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_197_READ, r30)
	DONE(DEBUG_197_READ_BIT)
d2304 4
a2307 4
GLOBAL(m88110_data_write_miss)
	PREP2("MVME197 write miss", 13, DEBUG_197_WRITE_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_197_WRITE, r30)
	DONE(DEBUG_197_WRITE_BIT)
d2310 4
a2313 4
GLOBAL(m88110_inst_atc_miss)
	PREP2("MVME197 inst miss", 14, DEBUG_197_INST_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_197_INST, r30)
	DONE(DEBUG_197_INST_BIT)
d2316 5
a2320 5
GLOBAL(m88110_syscall_handler)
	PREP2("syscall", 128, DEBUG_SYSCALL_BIT, No_SSBR_Stuff, No_Precheck)
	ld   r13, r30, GENREG_OFF(13)
	CALL(_m88110_syscall, r13, r30) /* system call no. is in r13 */
	DONE(DEBUG_SYSCALL_BIT)
d2323 25
a2347 25
GLOBAL(m88110_bugtrap)
	PREP2("bugsyscall", 496, DEBUG_BUGCALL_BIT, No_SSBR_Stuff, No_Precheck)
	ld   r9,  r30, GENREG_OFF(9)
	CALL(_bugsyscall, r9, r30)   /* system call no. is in r9 */
	DONE(DEBUG_BUGCALL_BIT)

GLOBAL(m88110_sigsys)
	PREP2("sigsys", 0, DEBUG_SIGSYS_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_SIGSYS, r30)
	DONE(DEBUG_SIGSYS_BIT)

GLOBAL(m88110_sigtrap)
	PREP2("sigtrap", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_SIGTRAP, r30)
	DONE(DEBUG_SIGTRAP_BIT)

GLOBAL(m88110_stepbpt)
	PREP2("sigtrap", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_STEPBPT, r30)
	DONE(DEBUG_SIGTRAP_BIT)

GLOBAL(m88110_userbpt)
	PREP2("sigtrap", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_USERBPT, r30)
	DONE(DEBUG_SIGTRAP_BIT)
d2350 13
a2362 14
GLOBAL(m88110_break)
	PREP2("break", 130, DEBUG_BREAK_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_KDB_BREAK, r30)
	DONE(DEBUG_BREAK_BIT)

GLOBAL(m88110_trace)
	PREP2("trace", 131, DEBUG_TRACE_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_KDB_TRACE, r30)
	DONE(DEBUG_TRACE_BIT)

GLOBAL(m88110_entry)
	PREP2("kdb", 132, DEBUG_KDB_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_KDB_ENTRY, r30)
	DONE(DEBUG_KDB_BIT)
d2364 12
a2375 14
GLOBAL(m88110_break)
	PREP2("break", 130, DEBUG_BREAK_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_UNKNOWNFLT, r30)
	DONE(DEBUG_BREAK_BIT)

GLOBAL(m88110_trace)
	PREP2("trace", 131, DEBUG_TRACE_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_UNKNOWNFLT, r30)
	DONE(DEBUG_TRACE_BIT)

GLOBAL(m88110_entry)
	PREP2("unknown", 132, DEBUG_UNKNOWN_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_C_LABEL(m88110_trap), T_UNKNOWNFLT, r30)
	DONE(DEBUG_KDB_BIT)
d2378 1
a2379 1
/*--------------------------------------------------------------------------*/
d2391 1
a2391 27
GLOBAL(m88110_error_handler)
	xcr	r2, r2,	SRX
	or	r2, r0, 10
	stcr	r2, 	SR0
	br.n	_C_LABEL(m88110_fatal)
	xcr	r2, r2,	SRX

/*
 * The reset exception handler.
 * The reset exception is raised when the RST signal is asserted (machine 
 * is reset), the value of VBR is changed after exceptions are enabled, 
 * or when a jmp, br/bsr to addr 0 (accidents do happen :-)
 *
 * Upon a real reset, VBR is set to zero (0), so code must be at addr 0 
 * to handle it!!! 
 *
 * This is totaly different than _error_handler.  Shadowing might or 
 * might not be on.
 * R1-R31 could tell u alot about what happend, so we'll save them.
 *
 * We'll not worry about trashing r26-29 here,
 * since they aren't generally used.
 */
GLOBAL(m88110_reset_handler)
	stcr	r0, 	SR0
	/* FALL THROUGH */
GLOBAL(m88110_fatal)
d2405 1
a2405 1
2:	/* stack has been cleared */
d2407 1
a2407 1
	/* ensure that stack is 8-byte aligned */
d2410 1
a2410 1
	/* create exception frame on stack */
d2413 1
a2413 1
	/* save old R31 and other R registers */
a2428 6

	/* vector is put in SRO (either 0 or 10 at this point) */
	ldcr	r10, SR0
	st	r10,  r31, REG_OFF(EF_VECTOR)
	cmp	r10, r10, 0	/* Is it the reset exception? */
	bb1.n	ne,  r10, 1f	/* If not, skip. */
d2433 4
a2436 16
	ldcr	r10, EXIP
	st	r10, r31, REG_OFF(EF_EXIP)
	ldcr	r10, ENIP
	st	r10, r31, REG_OFF(EF_ENIP)
	ldcr	r10, DSR
	st	r10, r31, REG_OFF(EF_DSR)
	ldcr	r10, DLAR
	st	r10, r31, REG_OFF(EF_DLAR)
	ldcr	r10, DPAR
	st	r10, r31, REG_OFF(EF_DPAR)
	ldcr	r10, ISR
	st	r10, r31, REG_OFF(EF_ISR)
	ldcr	r10, ILAR
	st	r10, r31, REG_OFF(EF_ILAR)
	ldcr	r10, IPAR
	st	r10, r31, REG_OFF(EF_IPAR)
a2437 1
	br.n	2f
a2439 31
1:	
	/* retrieve saved shadow registers for error_handler, though) */
	or.u	r30, r0,  hi16(_save_frame)
	or	r30, r30, lo16(_save_frame)
	ld	r10, r30, REG_OFF(EF_EPSR)
	st	r10, r31, REG_OFF(EF_EPSR)
	ld	r10, r30, REG_OFF(EF_EXIP)
	st	r10, r31, REG_OFF(EF_ENIP)
	ld	r10, r30, REG_OFF(EF_DSR)
	st	r10, r31, REG_OFF(EF_DSR)
	ld	r10, r30, REG_OFF(EF_DLAR)
	st	r10, r31, REG_OFF(EF_DLAR)
	ld	r10, r30, REG_OFF(EF_DPAR)
	st	r10, r31, REG_OFF(EF_DPAR)
	ld	r10, r30, REG_OFF(EF_ISR)
	st	r10, r31, REG_OFF(EF_ISR)
	ld	r10, r30, REG_OFF(EF_ILAR)
	st	r10, r31, REG_OFF(EF_ILAR)
	ld	r10, r30, REG_OFF(EF_IPAR)
	st	r10, r31, REG_OFF(EF_IPAR)
	ld	r10, r30, REG_OFF(EF_ISAP)
	st	r10, r31, REG_OFF(EF_ISAP)
	ld	r10, r30, REG_OFF(EF_DSAP)
	st	r10, r31, REG_OFF(EF_DSAP)
	ld	r10, r30, REG_OFF(EF_IUAP)
	st	r10, r31, REG_OFF(EF_IUAP)
	ld	r10, r30, REG_OFF(EF_DUAP)
	st	r10, r31, REG_OFF(EF_DUAP)
	ldcr	r10, SR1
	st	r10, r31, REG_OFF(EF_MODE)
2:
d2448 2
d2471 2
a2472 2
        
	CALL(_error_fatal, r30, r30)
d2480 2
a2481 2
ASGLOBAL(m88110_error_loop)
	bsr m88110_error_loop
d2484 79
a2562 183
ASGLOBAL(m88110_setup_phase_one)
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread (if any, null if not)                     *
	* SR1: saved copy of exception-time register now holding FLAGS  *
	* SR2: saved copy of exception-time r1                          *
	* SR3: must be preserved .. may be the exception-time stack     *
	* r1: return address to calling exception handler               *
	* FLAGS: CPU status flags                                       *
	***************************************************             *
	* immediate goal:                                               *
	*    Decide where we're going to put the exception frame.       *
	*   Might be at the end of R31, SR3, or the thread's            *
	*   pcb.                                                        *
	\***************************************************************/
	
	/* Check if we are coming in from a FPU restart exception.
	   If so, the pcb will be in SR3 */
	NOP
	xcr   r1,   r1,   SR2
	NOP
	NOP
	NOP
	
	bb1   FLAG_ENABLING_FPU, FLAGS, m88110_use_SR3_pcb
	/* are we coming in from user mode? If so, pick up process pcb */
	bb0   FLAG_FROM_KERNEL, FLAGS, m88110_pickup_stack
	
	/* Interrupt in kernel mode, not FPU restart */
ASGLOBAL(m88110_already_on_kernel_stack)
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread (if any, null if not)                     *
	* SR1: saved copy of exception-time register now holding FLAGS  *
	* SR2: return address to the calling exception handler          *
	* SR3: must be preserved; may be important for other exceptions *
	* FLAGS: CPU status flags                                       *
	***************************************************             *
	* immediate goal:                                               *
	*   We're already on the kernel stack, but not having           *
	*   needed to use SR3. We can just make room on the             *
	*    stack (r31) for our exception frame.                       *
	\***************************************************************/
	subu  r31,  r31,  SIZEOF_EF            /* r31 now our E.F. */
	st    FLAGS,r31,  REG_OFF(EF_FLAGS)    /* save flags */
	st    r1,   r31,  GENREG_OFF(1)        /* save prev. r1 (now r1 free)*/
	
	ldcr  r1,   SR3                        /* save previous SR3 */
	st    r1,   r31,  REG_OFF(EF_SR3)
	
	addu  r1,   r31,  SIZEOF_EF            /* save previous r31 */
	br.n  m88110_have_pcb
	st    r1,   r31,  GENREG_OFF(31)
	
	
ASGLOBAL(m88110_use_SR3_pcb)
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread (if any, null if not)                     *
	* SR1: saved copy of exception-time register now holding FLAGS  *
	* SR2: return address to the calling exception handler          *
	* SR3: must be preserved; exception-time stack pointer          *
	* FLAGS: CPU status flags                                       *
	***************************************************             *
	* immediate goal:                                               *
	*   An exception occured while enabling the FPU. Since r31      *
	*   is the user's r31 while enabling the FPU, we had put        *
	*   our pcb pointer into SR3, so make room from                 *
	*   there for our stack pointer.                                *
	*       We need to check if SR3 is the old stack pointer or the *
	*       pointer off to the user pcb. If it pointing to the user *
	*       pcb, we need to pick up the kernel stack. Otherwise     *
	*       we need to allocate a frame upon it.                    *
	*       We look at the EPSR to see if it was from user mode     *
	*       Unfortunately, we have no registers free at the moment  *
	*       But we know register 0 in the pcb frame will always be  *
	*       zero, so we can use it as scratch storage.              *
	*                                                               *
	*                                                               *
	\***************************************************************/
	xcr	r2, r2,	SRX
	or	r2, r0, 10
	stcr	r2, 	SR0
	br.n	_C_LABEL(m88110_fatal)
	xcr	r2, r2,	SRX
	/* Testing!!! */
	xcr   r30,  r30,  SR3                  /* r30 = old exception frame */
	st    r1,   r30,  GENREG_OFF(0)        /* free up r1 */
	ld    r1,   r30,  REG_OFF(EF_EPSR)     /* get back the epsr */
	bb0.n PSR_SUPERVISOR_MODE_BIT, r1, 1f  /* if user mode */
	ld    r1,   r30,  GENREG_OFF(0)        /* restore r1 */
	/* we were in kernel mode - dump frame upon the stack */
	st    r0,   r30,  GENREG_OFF(0)        /* repair old frame */
	subu  r30,  r30,  SIZEOF_EF            /* r30 now our E.F. */
	st    FLAGS,r30,  REG_OFF(EF_FLAGS)    /* save flags */
	st    r1,   r30,  GENREG_OFF(1)        /* save prev. r1 (now r1 free) */
	
	st    r31,  r30,  GENREG_OFF(31)       /* save previous r31 */
	or    r31,  r0,   r30                  /* make r31 our pointer. */
	addu  r30,  r30,  SIZEOF_EF            /* r30 now has previous SR3 */
	st    r30,  r31,  REG_OFF(EF_SR3)      /* save previous SR3 */
	br.n  m88110_have_pcb
	xcr   r30,  r30,  SR3                  /* restore r30 */
1:
	/* we took an exception while restarting the FPU from user space.
	 * Consequently, we never picked up a stack. Do so now.
	 * R1 is currently free (saved in the exception frame pointed at by
	 * r30) */
	or.u  r1,   r0,   hi16(_kstack)
	ld    r1,   r1,   lo16(_kstack)
	addu  r1,   r1,   USIZE-SIZEOF_EF
	st    FLAGS,r1,   REG_OFF(EF_FLAGS)    /* store flags */
	st    r31,  r1,   GENREG_OFF(31)       /* store r31 - now free */
	st    r30,  r1,   REG_OFF(EF_SR3)      /* store old SR3 (pcb) */
	or    r31,  r1,   r0                   /* make r31 our exception frame pointer */
	ld    r1,   r30,  GENREG_OFF(0)        /* restore old r1 */
	st    r0,   r30,  GENREG_OFF(0)        /* repair that frame */
	st    r1,   r31,  GENREG_OFF(1)        /* store r1 in its proper place */
	br.n  m88110_have_pcb
	xcr   r30,  r30,  SR3                  /* restore r30 */
	
ASGLOBAL(m88110_pickup_stack)
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                          *
	* SR1: saved copy of exception-time register now holding FLAGS *
	* SR2: return address to the calling exception handler         *
	* SR3: free                                                    *
	* FLAGS: CPU status flags                                      *
	***************************************************            *
	* immediate goal:                                              *
	*    Since we're servicing an exception from user mode, we     *
	*   know that SR3 is free.  We use it to free up a temp.       *
	*   register to be used in getting the thread's pcb            *
	\***************************************************************/
	stcr  r31,  SR3      /* save previous r31 */
	
	/* switch to the thread's kernel stack. */
	or.u  r31,  r0,   hi16(_curpcb)
	ld    r31,  r31,  lo16(_curpcb)
	addu  r31,  r31,  PCB_USER_STATE       /* point to user save area */
	st    FLAGS,r31,  REG_OFF(EF_FLAGS)    /* save flags */
	st    r1,   r31,  GENREG_OFF(1)        /* save prev. r1 (now r1 free)*/
	ldcr  r1,   SR3                        /* save previous r31 */
	st    r1,   r31,  GENREG_OFF(31)
	/*FALLTHROUGH */
	
ASGLOBAL(m88110_have_pcb)
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                          *
	* SR1: saved copy of exception-time register now holding FLAGS *
	* SR2: return address to the calling exception handler         *
	* SR3: free                                                    *
	* r1:  free                                                    *
	* FLAGS: CPU status flags                                      *
	* r31: our exception frame                                     *
	*    Valid in the exception frame:                             *
	*   Exception-time r1, r31, FLAGS.                             *
	*   Exception SR3, if appropriate.                             *
	***************************************************            *
	* immediate goal:                                              *
	*    Save the shadow registers that need to be saved to        *
	*   the exception frame.                                       *
	\***************************************************************/
	stcr   TMP, SR3   /* free up TMP, TMP2, TMP3 */
	SAVE_TMP2
	SAVE_TMP3
	
	/* save some exception-time registers to the exception frame */
	ldcr  TMP,  EPSR
	st    TMP,  r31,  REG_OFF(EF_EPSR)
	ldcr  TMP2, EXIP
	st    TMP2, r31,  REG_OFF(EF_EXIP)
	bb0.n 0,    TMP2, 1f
	/* The instruction was NOT in the delay slot, zero ENIP. */
	st    r0,   r31,  REG_OFF(EF_ENIP)
	/* The instruction was in the delay slot, save ENIP. */
	ldcr  TMP3, ENIP
	st    TMP3, r31,  REG_OFF(EF_ENIP)
1:
	/* NO SFIP on mc88110, zero it */
	st    r0,   r31,  REG_OFF(EF_SFIP)
	
	/* get and store the cpu number */	
	extu  TMP,  FLAGS,  FLAG_CPU_FIELD_WIDTH<0>  /* TMP = cpu# */
	st    TMP,  r31,  REG_OFF(EF_CPU)
	
d2564 1
a2564 1
	 * Save Pbus fault status register from data and inst CMMU.
d2566 221
a2786 24
	ldcr  TMP,  ISR
	ldcr  TMP2, ILAR
	ldcr  TMP3, IPAR
	st    TMP,  r31,  REG_OFF(EF_ISR)
	st    TMP2, r31,  REG_OFF(EF_ILAR)
	st    TMP3, r31,  REG_OFF(EF_IPAR)
	ldcr  TMP,  ISAP
	ldcr  TMP2, IUAP
	st    TMP,  r31,  REG_OFF(EF_ISAP)
	st    TMP2, r31,  REG_OFF(EF_IUAP)
	ldcr  TMP,  DSR
	ldcr  TMP2, DLAR
	ldcr  TMP3, DPAR
	st    TMP,  r31,  REG_OFF(EF_DSR)
	st    TMP2, r31,  REG_OFF(EF_DLAR)
	st    TMP3, r31,  REG_OFF(EF_DPAR)
	ldcr  TMP,  DSAP
	ldcr  TMP2, DUAP
	st    TMP,  r31,  REG_OFF(EF_DSAP)
	st    TMP2, r31,  REG_OFF(EF_DUAP)
	
	ldcr  r1,   SR2
	jmp   r1 /* return */
	
d2790 106
a2895 115
ASGLOBAL(m88110_setup_phase_two)
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: saved return address to calling exception handler        *
	* SR1: saved copy of exception-time register now holding FLAGS  *
	* SR2: free                                                     *
	* SR3: saved TMP                                                *
	* r1:  return address to calling exception handler              *
	* TMP: possibly revised SSBR                                    *
	* TMP2: free                                                    *
	* TMP3: free                                                    *
	* FLAGS: CPU status flags                                       *
	* r31: our exception frame                                      *
	*    Valid in the exception frame:                              *
	*   Exception-time r1, r31, FLAGS.                              *
	*   Exception-time TMP2, TMP3.                                  *
	*   Exception-time espr, enip, exip.                            *
	*   Exception number (EF_VECTOR).                               *
	*   Dmt0                                                        *
	*   Other data pipeline control registers, if appropriate.      *
	*   FPU control registers, if appropriate.                      *
	*   Exception SR3, if appropriate.                              *
	***************************************************             *
	* immediate goal:                                               *
	*   restore the system to the exception-time state (except      *
	* SR3 will be OUR stack pointer) so that we may resart the FPU. *
	\***************************************************************/
	/*stcr   r1, SR0*/      /* save return address */
	
	RESTORE_TMP2      /* done with extra temp regs */
	RESTORE_TMP3      /* done with extra temp regs */
	
	ldcr  TMP,  PSR
	clr   TMP,  TMP,  1<PSR_FPU_DISABLE_BIT>    /* enable the FPU */
	clr   TMP,  TMP,  1<PSR_SHADOW_FREEZE_BIT>  /* also enable shadowing */
	stcr  TMP,  EPSR
	
	or.u  TMP,  r0,   hi16(m88110_fpu_enable)
	or    TMP,  TMP,  lo16(m88110_fpu_enable)
	stcr  TMP,  EXIP      /* jump to here fpu_enable */
	addu  TMP,  TMP,  4
	stcr  TMP,  ENIP      /* and then continue after that */
	
	set   FLAGS, FLAGS, 1<FLAG_ENABLING_FPU> /* note what we're doing.*/
	xcr   FLAGS, FLAGS, SR1
	st    r1,   r31,  REG_OFF(EF_RET) /* save the return address */
	ld    r1,   r31,  GENREG_OFF(1)    /* get original r1 */
	
	ldcr  TMP, SR3
	stcr  r31, SR3	/* TMP now restored. R31 now saved in SR3 */
	ld    r31,  r31,  GENREG_OFF(31) /* get original r31 */
	
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                           *
	* SR1: CPU flags                                                *
	* SR2: free                                                     *
	* SR3: pointer to our exception frame (our stack pointer)       *
	* r1 through r31: original exception-time values                *
	*                                                               *
	* Valid in the exception frame:                                 *
	*   Exception-time FLAGS.                                       *
	*   Exception-time espr, sfip, enip, exip.                      *
	*   Exception number (EF_VECTOR).                               *
	*   Dmt0                                                        *
	*   Other data pipeline control registers, if appropriate.      *
	*   FPU control registers, if appropriate.                      *
	*   Exception SR3, if appropriate.                              *
	*   Held temporarly in the exception frame:                     *
	*   Return address to the calling excption handler.             *
	***************************************************             *
	* immediate goal:                                               *
	*   Do an RTE to restart the fpu and jump to "fpu_enable"       *
	*   Another exception (or exceptions) may be raised in          *
	*   this, which is why FLAG_ENABLING_FPU is set in SR1.         *
	\***************************************************************/
	NOP
	RTE   /* jumps to "fpu_enable" on the next line to enable the FPU. */
	
ASGLOBAL(m88110_fpu_enable)
	FLUSH_PIPELINE
	/* Now we can handle another exception!!! */
	/* Now that EFZE is cleared, we can clear these */
	stcr  r0, ISR	/* Clear ISR */
	stcr  r0, ILAR	/* Clear ILAR */
	stcr  r0, IPAR	/* Clear IPAR */
	stcr  r0, DSR	/* Clear DSR */
	stcr  r0, DLAR	/* Clear DLAR */
	stcr  r0, DPAR	/* Clear DPAR */
	xcr   TMP,  TMP,  SR3               /* get E.F. pointer */
	st.d  r30,  TMP,  GENREG_OFF(30)    /* save previous r30, r31 */
	or    r31,  TMP,  r0                /* transfer E.F. pointer to r31 */
	ld    TMP,  r31,  REG_OFF(EF_SR3)   /* get previous SR3; maybe important*/

	/* make sure that the FLAG_ENABLING_FPU bit is off */
	xcr   FLAGS,FLAGS,SR1
	clr   FLAGS,FLAGS,1<FLAG_ENABLING_FPU>
	xcr   FLAGS,FLAGS,SR1

	xcr   TMP,  TMP,  SR3       /* replace TMP, SR3 */

	/* now save all regs to the exception frame. */
	st.d  r0 ,  r31,  GENREG_OFF(0)
	st.d  r2 ,  r31,  GENREG_OFF(2)
	st.d  r4 ,  r31,  GENREG_OFF(4)
	st.d  r6 ,  r31,  GENREG_OFF(6)
	st.d  r8 ,  r31,  GENREG_OFF(8)
	st.d  r10,  r31,  GENREG_OFF(10)
	st.d  r12,  r31,  GENREG_OFF(12)
	st.d  r14,  r31,  GENREG_OFF(14)
	st.d  r16,  r31,  GENREG_OFF(16)
	st.d  r18,  r31,  GENREG_OFF(18)
	st.d  r20,  r31,  GENREG_OFF(20)
	st.d  r22,  r31,  GENREG_OFF(22)
	st.d  r24,  r31,  GENREG_OFF(24)
	st.d  r26,  r31,  GENREG_OFF(26)
	st.d  r28,  r31,  GENREG_OFF(28)
d2897 4
a2900 4
	/* mark beginning of frame with notable value */
	or.u  r20,  r0,   hi16(0x12345678)
	or    r20,  r20,  lo16(0x12345678)
	st    r20,  r31,  GENREG_OFF(0)
d2902 44
a2945 39
	
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread                                           *
	* SR1: free                                                     *
	* SR2: free                                                     *
	* SR3: previous exception-time SR3                              *
	* r1: return address to the calling exception handler           *
	* r2 through r30: free                                          *
	* r31: our exception frame                                      *
	*                                                               *
	* Valid in the exception frame:                                 *
	*   Exception-time r0 through r31.                              *
	*   Exception-time FLAGS.                                       *
	*   Exception-time espr, enip, exip.                            *
	*   Exception number (EF_VECTOR).                               *
	*   DSR                                                         *
	* Other data pipeline control registers, if appropriate.        *
	*   FPU control registers, if appropriate.                      *
	*   Exception SR3, if appropriate.                              *
	***************************************************             *
	* immediate goal:                                               *
	*   Pick up a stack if we came in from user mode. Put           *
	*       A copy of the exception frame pointer into r30          *
	*       bump the stack a doubleword and write the exception     *
	*       frame pointer.                                          *
	*   if not an interrupt exception,                              *
	*       Turn on interrupts and service any outstanding          *
	*       data access exceptions.                                 *
	*   Return to calling exception handler to                      *
	*   service the exception.                                      *
	\***************************************************************/
	
	/*
	 * If it's not the interrupt exception, enable interrupts and
	 * take care of any data access exceptions......
	 */
	or    r30,  r0,   r31              /* get a copy of the e.f. pointer */
	ld    r2,   r31,  REG_OFF(EF_EPSR)
	bb1   PSR_SUPERVISOR_MODE_BIT, r2, 1f  /* If in kernel mode */
d2948 6
a2953 10
	/*
	 * If interrupt exception, switch to interrupt stack if not
	 * already there. Else, switch to kernel stack.
	 */
	ld    r3,   r31,  REG_OFF(EF_VECTOR)
	cmp   r3,   r3,   1      /* is interrupt ? */
	bb0   eq,   r3,   2f
	or.u  r31,  r0,   hi16(_intstack_end)   /* swith to int stack */
	or    r31,  r31,  lo16(_intstack_end)
	br    3f
d2956 4
a2959 4
	or.u  r31,  r0,   hi16(_kstack)
	ld    r31,  r31,  lo16(_kstack)
	addu  r31,  r31,  USIZE        /* point at proper end */
	br    3f
d2962 14
a2975 14
	ld    r3,   r31,  REG_OFF(EF_VECTOR)
	cmp   r3,   r3,   1       /* is interrupt ? */
	bb0   eq,   r3,   3f      /* no, we will stay on kern stack */
	or.u  r31,  r0,   hi16(_intstack_end)   /* swith to int stack */
	or    r31,  r31,  lo16(_intstack_end)
#endif	/* INTSTACK */
	/* This label is here for debugging */
m88110_exception_handler_has_ksp:  global m88110_exception_handler_has_ksp
3:	/*
	 * here - r30 holds a pointer to the exception frame.
	 * r31 is a pointer to the kernel stack/interrupt stack.
	 */
	subu  r31,  r31,  8  /* make some breathing space */
	st    r30,  r31,  0  /* store frame pointer on the stack */
d2977 1
a2977 1
	st    r30,  r31,  4  /* store it again for the debugger to recognize */
d2980 5
a2984 5
	ld    r2,   r30,  REG_OFF(EF_VECTOR)
	bcnd.n eq0, r2,   m88110_return_to_calling_exception_handler  /* is error */
	ld    r14,  r30,  REG_OFF(EF_RET) /* load return value XXX!!! */
	cmp   r3,   r2,   1 /* interrupt is exception #1 ;Is an interrupt? */
	bb1.n   eq,   r3,   m88110_return_to_calling_exception_handler /* skip if so */
d2987 2
a2988 2
	cmp   r3,   r2,   130 /* DDB break exception */
	bb1.n eq,   r3,   m88110_return_to_calling_exception_handler
d2990 2
a2991 2
	cmp   r3,   r2,   132 /* DDB entry exception */
	bb1.n eq,   r3,   m88110_return_to_calling_exception_handler
d2994 3
a2996 3
	ldcr  r2,   PSR
	clr   r2,   r2,   1<PSR_INTERRUPT_DISABLE_BIT>   /* enable interrupts */
	stcr  r2,   PSR
d2998 1
a2998 1
	FLUSH_PIPELINE
a2999 5
#if 1 /* test */
	br  m88110_return_to_calling_exception_handler
#endif
	/* service any outstanding data pipeline stuff
	   - check dsr... anything outstanding?*/
d3001 6
a3006 3
	ld    r3,   r30,  REG_OFF(EF_DSR)
	cmp   r3,   r3,   0
	bb1   eq,   r3,   m88110_return_to_calling_exception_handler
d3009 2
a3010 2
 * r30 can be clobbered by calls. So stuff its value into a
 * preserved register, say r15. R14 is in use (see return_to_... below).
d3012 6
a3017 5
	or    r15,  r0,   r30
#if 0
	CALL(_C_LABEL(test_trap), r15, r0)
#endif   
	CALL(_C_LABEL(m88110_trap), T_DATAFLT, r15)
d3019 2
a3020 2
	/*   restore it... */
	or    r30,  r0,   r15
d3022 2
a3023 2
	/* clear the dsr word in the E.F */
	st    r0,   r30,  REG_OFF(EF_DSR)
a3024 7
ASGLOBAL(m88110_return_to_calling_exception_handler)
	jmp   r14 /* loaded above */
	
	data
	.align 8
GLOBAL(save_frame)
	space SIZEOF_EF	
@


1.8.4.6
log
@Sync the SMP branch with 3.3
@
text
@d368 1
a368 1
1:	bsr	setup_phase_one				; \
d397 1
a397 1
	ldcr    r1, EPSR 				; \
d403 1
a403 1
1:	bsr	m88110_setup_phase_one			; \
d563 1
a563 1
/* integer overflow exception handler */
d571 1
a571 1
GLOBAL(fp_precise_handler)
d578 1
a578 1
GLOBAL(fp_imprecise_handler)
d618 1
a618 1
GLOBAL(break)
d623 1
a623 1
GLOBAL(trace)
d634 1
a634 1
GLOBAL(break)
d639 1
a639 1
GLOBAL(trace)
a1822 4

	/* get and save IPL */
	bsr	_C_LABEL(getipl)
	st	r2, r31, REG_OFF(EF_MASK)
d1982 1
a1982 1

d1984 1
d2011 1
a2011 1
	bb0	DMT_VALID_BIT, r3, check_ast /*[Oh well, nothing to do here] */
d2067 1
a2067 1
	br   check_ast
d2121 1
a2121 1
ASLOCAL(check_ast)
d2153 1
a2153 1
#if defined(M88110) && defined(M88100)
a2157 2
#endif
#if defined(M88110)
a2158 2
#endif
#if defined(M88110) && defined(M88100)
d2166 10
a2175 1
ASLOCAL(no_ast)
d2184 2
a2186 2
	bsr.n   _C_LABEL(setipl)
	 ld	r2, FPTR, REG_OFF(EF_MASK)   /* get pre-exception ipl */
d2258 1
d2260 1
a2260 1

d2325 1
a2325 1
/* integer overflow exception handler */
@


1.8.4.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d32 28
a59 13
 * In the following discussion, references are made to:
 *    MC88100 - RISC MICROPROCESSOR USER'S MANUAL
 * (second edition). Reference in []s refer to section numbers.
 *
 * This discussion assumes that you are at least vaguely familiar with 88100
 * exception handling (chapter 6), the MACH kernel, and that you have a brain
 * (and use it while reading this).
 *
 * I also assume (and hope) that you're not offended by frequent misspellings.
 *
 * Jeffrey Friedl
 * jfriedl@@rna.ncl.omron.co.jp
 * December, 1989
d200 2
a201 1
 * Now is a good time to recap SR1..SR3 usage:
a216 2

#include <machine/param.h>
d219 3
a221 4
#ifdef MVME188
#include <machine/m8820x.h>
#endif
#include <machine/trap.h>
d228 5
a232 6
 * EF_SR3
 *   A place to save the exception-time SR3 from just after the
 *   time when an exception is raised until just after the FPU
 *   has been restarted.  This does not necessarly conflict with
 *   the general registers (though it can if you're not careful)
 *   and so we can use a spot later used to save a general register.
d234 1
a234 2
 * EF_FLAGS
 *   This is just the old EF_MODE. "EF_MODE" isn't a very good name.
d236 2
a237 2
#define	EF_SR3		(EF_R0 + 5)
#define	EF_FLAGS	EF_MODE
d239 1
d242 3
a244 3
ASLOCAL(sbadcpupanic)
	string	"eh.S: bad cpu number in FLAGS\000"

d248 4
a251 6
ASLOCAL(Lbadcpupanic)
	subu	r31, r31, 32
	or.u	r2, r0, hi16(_ASM_LABEL(sbadcpupanic))
	bsr.n	_C_LABEL(panic)
	 or	r2, r2, lo16(_ASM_LABEL(sbadcpupanic))
	addu	r31, r31, 32
d255 14
a268 2
#ifdef M88110
#define SAVE_CTX \
d270 2
a271 2
	or.u	r31, r0,  hi16(_ASM_LABEL(save_frame))	; \
	or	r31, r31, lo16(_ASM_LABEL(save_frame))	; \
d317 1
a317 1
	/* Restore r1, r2, r3, and r31 */	; \
d319 1
a319 2
	ld	r2 , r31, GENREG_OFF(2)		; \
	ld	r3 , r31, GENREG_OFF(3)		; \
a320 1
#endif
d322 31
a352 32
/*
 *
 * #define PREP(NAME, NUM, BIT, SSBR_STUFF, FLAG_CHECK)
 *
 * This is the "exception processing preparaton" common to all exception
 * processing.  It is used in the following manner:
 *
 *	ASGLOBAL(foo_handler)
 *		PREP("foo", 11, DEBUG_FOO_BIT, SSBR_Stuff, Precheck_Stuff)
 *		CALL(_C_LABEL(trapXXX), T_FOO_FAULT, r31)
 *		DONE(DEBUG_FOO_BIT)
 *
 * This defines the exception handler for the "foo" exception.
 * The arguments ro PREP():
 * NAME
 *	String for debugging (more info later)
 * NUM
 *	The exception number [see the manual, Table 6-1]
 * BIT
 *	Bit to check in eh_debug for debugging (more info later)
 * SSBR_STUFF
 *	If the exception might leave some bits in the SSBR set,
 *	this should indicate how they are cleared.
 * FLAG_PRECHECK
 *	This is for the data access exception only. See it for
 *	more info.
 *
 * What's in between PREP() and DONE() (usually a CALL) is the actual
 * servicing of the interrupt.  During this time, any register may
 * be used freely as they've all been saved in the exception frame
 * (which is pointed-to by r31).
 */
d355 1
a355 1
#define PREP(NAME, NUM, BIT, SSBR_STUFF, FLAG_PRECHECK) \
d358 4
a361 3
	/* the bsr later clobbers r1, so save now */	  \
	stcr	r1, SR2	/* r1 now free */		; \
	/* set or clear the FLAG_FROM_KERNEL bit */	  \
d364 1
a364 1
	 clr	FLAGS, FLAGS, 1<FLAG_FROM_KERNEL>	; \
d366 5
a370 3
	/* get a stack (exception frame) */		  \
1:	bsr	_ASM_LABEL(setup_phase_one)		; \
	/* TMP2 now free -- use to set EF_VECTOR */	  \
d373 6
a378 2
	/* Clear any bits in the SSBR (held in TMP) */	  \
	/* SSBR_STUFF may be empty, though.         */	  \
d380 6
a385 4
	/* call setup_phase_two to restart the FPU  */	  \
	/* and to save all general registers.       */	  \
	bsr	_ASM_LABEL(setup_phase_two)		; \
	/* All general regs free -- do any debugging */	  \
d387 1
a387 1
#endif
d390 1
a390 1
#define PREP2(NAME, NUM, BIT, FLAG_PRECHECK) \
d395 1
a395 1
	stcr	r1, SR2	/* r1 now free */		; \
d397 5
a401 4
	ldcr	r1, EPSR 				; \
	bb0.n	PSR_SUPERVISOR_MODE_BIT, r1, 1f 	; \
	 clr	FLAGS, FLAGS, 1<FLAG_FROM_KERNEL> 	; \
	set	FLAGS, FLAGS, 1<FLAG_FROM_KERNEL>	; \
d403 2
a404 1
1:	bsr	_ASM_LABEL(m88110_setup_phase_one)	; \
d408 1
d411 2
a412 1
	bsr	_ASM_LABEL(m88110_setup_phase_two)	; \
d415 1
a415 1
#endif
d418 7
a424 8
#define	Clear_SSBR_Dest \
	bsr	_ASM_LABEL(clear_dest_ssbr_bit)
#define	Data_Precheck \
	bb1.n	FLAG_IGNORE_DATA_EXCEPTION, FLAGS, \
		_ASM_LABEL(ignore_data_exception)
#define	M88110_Data_Precheck \
	bb1.n	FLAG_IGNORE_DATA_EXCEPTION, FLAGS, \
		_ASM_LABEL(m88110_ignore_data_exception)
d427 52
a478 60
/*
 * If we allow debugging, there is a variable "eh_debug"
 * in which there is a bit for each exception.  If the bit
 * is set for an exception, debugging information is printed
 * about that exception whenever it occurs.
 *
 * The bits are defined in "asm.h"
 */

ASGLOBAL(eh_debug)
	word	0x00000000

/*
 * additional pre-servicing preparation to be done when
 * debugging... check eh_debug and make the call if
 * need be.
 */
#define PREP_DEBUG(DebugNumber, Name) \
	or.u	r2, r0, hi16(_ASM_LABEL(eh_debug))	; \
	ld	r3, r2, lo16(_ASM_LABEL(eh_debug))	; \
	bb0	DebugNumber, r3, 4f			; \
	/* call MY_info(ef,SR0,flags,kind)*/		  \
	or	r2, r30, r0				; \
	ldcr	r3, SR0					; \
	ldcr	r4, SR1					; \
	or.u	r5, r0, hi16(2f)			; \
	or	r5, r5, lo16(2f)			; \
	bsr.n	_C_LABEL(MY_info)			; \
	 subu	r31, r31, 32				; \
	br.n	4f					; \
	 addu	r31, r31, 32				; \
	data						; \
2:	string Name					; \
	byte	0					; \
	align	4					; \
	text						; \
4:


/*
 * Post-servicing work to be done.
 * When debugging, check "eh_debug" and call the
 * debug routined if neeed be.
 *
 * Then, return from the interrupt handler.
 */
#define DONE(DebugNumber) \
	or.u	r2, r0, hi16(_ASM_LABEL(eh_debug))	; \
	ld	r3, r2, lo16(_ASM_LABEL(eh_debug))	; \
	bb0	DebugNumber, r3, 2f			; \
	ldcr	r4, SR1					; \
	CALL(_C_LABEL(MY_info_done), r31, r4)		; \
2:	br	_ASM_LABEL(return_from_exception_handler)
#define DONE2(DebugNumber) \
	or.u	r2, r0, hi16(_ASM_LABEL(eh_debug))	; \
	ld	r3, r2, lo16(_ASM_LABEL(eh_debug))	; \
	bb0	DebugNumber, r3, 2f			; \
	ldcr	r4, SR1					; \
	CALL(_C_LABEL(MY_info_done), r31, r4)		; \
2:	br	_ASM_LABEL(m88110_return_code)
d480 7
a486 10
/*
 * If not debugging, then no debug-prep to do.
 * Also, when you're done, you're done!   (no debug check).
 */
#define	PREP_DEBUG(bit, name)
#define	DONE(num) \
	br	_ASM_LABEL(return_from_exception_handler)
#define	DONE2(num) \
	br	_ASM_LABEL(m88110_return_code)
#endif	/* EH_DEBUG */
d489 3
a491 3
/*
 * MVME18x exception handlers
 */
d495 1
a495 1
	PREP("unknown", 0, DEBUG_UNKNOWN_BIT,,)
d501 2
a502 1
	PREP("interrupt", 1, DEBUG_INTERRUPT_BIT,,)
d504 1
d509 1
a509 1
	PREP("inst", 2, DEBUG_INSTRUCTION_BIT,,)
d518 1
a518 2
	PREP("data", 3, DEBUG_DATA_BIT,, Data_Precheck)
	/* No need to call m88100_trap(T_DATAFLT) as PREP will do this for us */
d523 1
a523 1
	PREP("misalign", 4, DEBUG_MISALIGN_BIT, Clear_SSBR_Dest,)
d529 1
a529 1
	PREP("unimp", 5, DEBUG_UNIMPLEMENTED_BIT,,)
d539 4
a542 4
	stcr	r1, SR2		/* hold r1 for a moment */
	ldcr	r1, SXIP	/* look at the sxip... valid bit set? */
	bb1.n	RTE_VALID_BIT, r1, 1f	/* skip over if a valid exception */
	 ldcr	r1, SR2		/* restore r1 */
d544 2
a545 2
1:	PREP("privilege", 6, DEBUG_PRIVILEGE_BIT, Clear_SSBR_Dest,)
	CALL(_C_LABEL(m88100_trap), T_PRIVINFLT, r30)
d548 4
a551 1
/* bounds checking exception handler */
d553 1
a553 1
	PREP("bounds", 7, DEBUG_BOUNDS_BIT, Clear_SSBR_Dest,)
d559 1
a559 1
	PREP("divide", 8, DEBUG_DIVIDE_BIT, Clear_SSBR_Dest,)
d565 1
a565 1
	PREP("overflow", 9, DEBUG_OVERFLOW_BIT,,)
d570 1
a570 2
#define	FPp_SSBR_STUFF \
	bsr	_ASM_LABEL(clear_FPp_ssbr_bit)
d572 2
a573 2
	PREP("FPU precise", 114, DEBUG_FPp_BIT, FPp_SSBR_STUFF,)
	CALL(_ASM_LABEL(m88100_Xfp_precise), r0, r30)
d577 1
a577 2
#define	FPi_SSBR_STUFF \
	bsr	_ASM_LABEL(clear_FPi_ssbr_bit)
d579 2
a580 2
	PREP("FPU imprecise", 115, DEBUG_FPi_BIT, FPi_SSBR_STUFF,)
	CALL(_ASM_LABEL(Xfp_imprecise), r0, r30)
d585 3
a587 3
	PREP("syscall", 128, DEBUG_SYSCALL_BIT,,)
	ld	r13, r30, GENREG_OFF(13)
	CALL(_C_LABEL(m88100_syscall), r13, r30)
d592 3
a594 3
	PREP("bugsyscall", 496, DEBUG_BUGCALL_BIT,,)
	ld	r9, r30, GENREG_OFF(9)
	CALL(_C_LABEL(bugsyscall), r9, r30)
d598 1
a598 1
	PREP("sigsys", 501, DEBUG_SIGSYS_BIT,,)
d603 1
a603 1
	PREP("sigtrap", 510, DEBUG_SIGTRAP_BIT,,)
d608 1
a608 1
	PREP("stepbpt", 504, DEBUG_SIGTRAP_BIT,,)
d613 1
a613 1
	PREP("userbpt", 511, DEBUG_SIGTRAP_BIT,,)
d617 1
a617 1
#ifdef DDB
d619 1
a619 1
	PREP("break", 130, DEBUG_BREAK_BIT,,)
d624 1
a624 1
	PREP("trace", 131, DEBUG_TRACE_BIT,,)
d629 1
a629 1
	PREP("kdb", 132, DEBUG_KDB_BIT,,)
d632 2
a633 1
#else
d635 1
a635 1
	PREP("break", 130, DEBUG_BREAK_BIT,,)
d640 1
a640 1
	PREP("trace", 131, DEBUG_TRACE_BIT,,)
d645 1
a645 1
	PREP("unknown", 132, DEBUG_KDB_BIT,,)
d648 3
a650 1
#endif
d653 1
a653 2
 * The error exception and reset exception handler.
 *
d657 138
a794 2
 * The reset exception is raised when the RST signal is asserted (machine
 * is reset), the value of VBR is changed after exceptions are enabled,
d796 1
a798 2
 * Upon a real reset, VBR is set to zero (0), so code must be at addr 0
 * to handle it!!!
d800 6
a805 3
 * The shadow registers are not valid in this case (shadowing was off, if this
 * was an error exception, and may not be on, if this was a reset exception).
 * R1-R31 may be interesting though, so we'll save them.
a809 3
GLOBAL(error_handler)
	br.n	1f
	 or	r29, r0, 10
d811 4
a814 6
	or	r29, r0, 0
1:
	/* pick up the slavestack */
	or	r26, r0,  r31	/* save old stack */
	or.u	r31, r0,  hi16(_ASM_LABEL(intstack_end))
	or	r31, r31, lo16(_ASM_LABEL(intstack_end))
a815 1
#ifdef DEBUG
d817 2
a818 2
	or.u	r27, r0,  hi16(_C_LABEL(intstack))
	or	r27, r27, lo16(_C_LABEL(intstack))
d820 1
a820 1
	bb1	ge,  r28, 2f	/* branch if at the end of the stack */
d823 1
a823 1
	 addu	r27, r27, 4	/* bump up */
a824 1
#endif
d827 1
a827 1
	clr	r31, r31, 3<0>	/* round down to 8-byte boundary */
d830 1
a830 1
	subu	r31, r31, SIZEOF_EF	/* r31 now our E.F. */
d849 1
a849 1
	/* save shadow registers (are OLD if error_handler, though) */
d862 1
a862 1
	stcr	r0,  SSBR	/* won't want shadow bits bothering us later */
d869 1
a870 1
	st	r12, r31, REG_OFF(EF_DMA0)
d894 2
a895 2
	/* save error vector */
	st	r29, r31, REG_OFF(EF_VECTOR)
d900 5
a904 4
	ldcr	r10, PSR
	clr	r10, r10, 1<PSR_FPU_DISABLE_BIT>	/* enable the FPU */
	clr	r10, r10, 1<PSR_SHADOW_FREEZE_BIT>	/* and shadowing */
	stcr	r10, PSR
d910 3
a912 3
	subu	r31, r31, 0x10	/* make some breathing space */
	st	r30, r31, 0x0c	/* store frame pointer on the st */
	st	r30, r31, 0x08	/* store again for the debugger to recognize */
d918 1
a918 1
	CALL(_C_LABEL(error_fatal), r30, r30)
d920 4
a923 4
	/* turn interrupts back on */
	ldcr	r1, PSR
	clr	r1, r1, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r1, PSR
d926 2
a927 4
1:
	br	1b
	/* NOTREACHED */
#endif	/* M88100 */
d932 9
a940 9
#ifdef M88100
ASLOCAL(ignore_data_exception)
	/*
	 * SR1: previous FLAGS reg
	 * SR2: free
	 * SR3: must presere
	 * FLAGS: CPU status flags
	 */
	xcr	FLAGS, FLAGS, SR1	/* replace SR1, FLAGS */
d948 1
a948 1
	 * jumping back to the function badaddr() where we're allowed
d953 4
a956 3
	or.u	r2, r0, hi16(_ASM_LABEL(badaddr__return_nonzero) + 2)
	or	r2, r2, lo16(_ASM_LABEL(badaddr__return_nonzero) + 2)
	stcr	r2, SNIP	/* Make it the next instruction to execute */
d958 5
a962 2
	stcr	r2, SFIP	/* and the next one after that, too. */
	stcr	r0, SSBR	/* make the scoreboard happy. */
d964 1
a964 1
#endif /* M88100 */
d970 9
a978 8
ASLOCAL(m88110_ignore_data_exception)
	/*
	 * SR1: previous FLAGS reg
	 * SR2: free
	 * SR3: must preserve
	 * FLAGS: CPU status flags
	 */
	xcr	FLAGS, FLAGS, SR1	/* replace SR1, FLAGS */
d990 6
a995 3
	or.u	r2, r0, hi16(_ASM_LABEL(m88110_badaddr__return_nonzero))
	or	r2, r2, lo16(_ASM_LABEL(m88110_badaddr__return_nonzero))
	stcr	r2, EXIP	/* Make it the next instruction to execute */
d998 1
d1004 1
a1004 1
 * not all currently accessible by the kernel.
d1006 1
a1006 1
 * If all LEN bytes starting at ADDR are accessible, zero is returned.
d1010 1
a1010 1
 * This is implemented by setting a special flag in SR1 before trying to access
d1012 1
a1012 1
 * is inaccessible. The exception handler will notice the special CPU flag
d1028 1
a1029 1
	FLUSH_PIPELINE
d1040 2
a1041 2
	bcnd.n	ne0, r6, _ASM_LABEL(badaddr__maybe_halfword)
	 stcr	r5,  SR1
d1047 2
a1048 2
	bb1	0, r2, _ASM_LABEL(badaddr__return_nonzero)
	bb1	1, r2, _ASM_LABEL(badaddr__return_nonzero)
d1058 1
a1058 1
	ld	r5, r2, 0
d1060 2
a1061 2
	br.n	_ASM_LABEL(badaddr__return)
	 or	r2, r0, r0	/* indicate a zero (address not bad) return.*/
d1063 1
a1063 1
ASLOCAL(badaddr__maybe_halfword)
d1065 2
a1066 2
	sub	r6, r3, 2
	bcnd	ne0, r6, _ASM_LABEL(badaddr__maybe_byte)
d1069 1
a1069 1
	bb1	0, r2, _ASM_LABEL(badaddr__return_nonzero)
d1072 1
a1072 1
	ld.h	r5, r2, 0
d1074 2
a1075 2
	br.n	_ASM_LABEL(badaddr__return)
	 or	r2, r0, r0
d1077 1
a1077 2
ASLOCAL(badaddr__maybe_byte)
#ifdef DEBUG
d1079 2
a1080 3
	sub	r6, r3, 1
	bcnd	ne0, r6, _ASM_LABEL(badaddr__unknown_size)
#endif
d1082 1
a1082 1
	ld.b	r5, r2, 0
d1084 4
a1087 4
	br.n	_ASM_LABEL(badaddr__return)
	 or	r2, r0, r0
ASLOCAL(badaddr__unknown_size)
#ifdef	DEBUG
d1089 1
a1089 1
1: 	string "bad length (%d) to badaddr() from 0x%x\000"
d1091 7
a1097 6
	subu	r31, r31, 32
	or.u	r2, r0, hi16(1b)
	or	r2, r2, lo16(1b)
	bsr.n	_C_LABEL(panic)
	 or	r4, r0, r1
	addu	r31, r31, 32
d1101 8
a1108 19
#ifdef M88110
ASLOCAL(m88110_badaddr__return_nonzero)
	/*
	 * On mc88110, we possibly took an exception and we have to clear
	 * DSR before the rte instruction clears the EFRZ bit in the PSR.
	 */
	stcr	r0, DSR
	stcr	r0, DLAR
	stcr	r0, DPAR
	/* FALLTHROUGH */
#endif
ASLOCAL(badaddr__return_nonzero)
	or	r2, r0, 1
	/* FALLTHROUGH */

ASLOCAL(badaddr__return)
	ldcr	r4, SR1
	clr	r4, r4, 1<FLAG_IGNORE_DATA_EXCEPTION>
	stcr	r4, SR1
a1116 1
	stcr	r8, PSR
d1118 2
a1119 15
	jmp	r1

#ifdef M88100
ASLOCAL(setup_phase_one)
	/*
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: saved copy of exception-time r1
	 * SR3: must be preserved .. may be the exception-time stack
	 * r1: return address to calling exception handler
	 * FLAGS: CPU status flags
	 *
	 * immediate goal:
	 *   Decide where we're going to put the exception frame.
	 *   Might be at the end of R31, SR3, or the thread's pcb.
	 */
d1121 35
d1164 1
a1164 1
	bb1	FLAG_ENABLING_FPU, FLAGS, _ASM_LABEL(use_SR3_pcb)
d1166 1
a1166 1
	bb0	FLAG_FROM_KERNEL, FLAGS, _ASM_LABEL(pickup_stack)
d1169 16
a1184 14
	/*
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: return address to the calling exception handler
	 * SR3: must be preserved; may be important for other exceptions
	 * FLAGS: CPU status flags
	 *
	 * immediate goal:
	 *   We're already on the kernel stack, but not having
	 *   needed to use SR3. We can just make room on the
	 *   stack (r31) for our exception frame.
	 */
	subu	r31,  r31,  SIZEOF_EF		/* r31 now our E.F. */
	st	FLAGS,r31,  REG_OFF(EF_FLAGS)	/* save flags */
	st	r1,   r31,  GENREG_OFF(1)	/* save prev. r1 (now r1 free)*/
d1186 1
a1186 1
	ldcr	r1,   SR3			/* save previous SR3 */
d1189 34
a1222 30
	addu	r1,   r31,  SIZEOF_EF		/* save previous r31 */
	br.n	_ASM_LABEL(have_pcb)
	 st 	r1,   r31,  GENREG_OFF(31)

ASLOCAL(use_SR3_pcb)
	/*
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: return address to the calling exception handler
	 * SR3: must be preserved; exception-time stack pointer
	 * FLAGS: CPU status flags
	 *
	 * immediate goal:
	 *   An exception occurred while enabling the FPU. Since r31
	 *   is the user's r31 while enabling the FPU, we had put
	 *   our pcb pointer into SR3, so make room from
	 *   there for our stack pointer.
	 *   We need to check if SR3 is the old stack pointer or the
	 *   pointer off to the user pcb. If it pointing to the user
	 *   pcb, we need to pick up the kernel stack. Otherwise
	 *   we need to allocate a frame upon it.
	 *   We look at the EPSR to see if it was from user mode
	 *   Unfortunately, we have no registers free at the moment
	 *   But we know register 0 in the pcb frame will always be
	 *   zero, so we can use it as scratch storage.
	 */
	xcr	r30,  r30,  SR3			/* r30 = old exception frame */
	st	r1,   r30,  GENREG_OFF(0)	/* free up r1 */
	ld	r1,   r30,  REG_OFF(EF_EPSR)	/* get back the epsr */
	bb0.n	PSR_SUPERVISOR_MODE_BIT, r1, 1f	/* if user mode */
	 ld	r1,   r30,  GENREG_OFF(0)	/* restore r1 */
d1224 11
a1234 11
	st	r0,   r30,  GENREG_OFF(0)	/* repair old frame */
	subu	r30,  r30,  SIZEOF_EF		/* r30 now our E.F. */
	st	FLAGS,r30,  REG_OFF(EF_FLAGS)	/* save flags */
	st	r1,   r30,  GENREG_OFF(1)	/* save prev r1 (now free) */

	st	r31,  r30,  GENREG_OFF(31)	/* save previous r31 */
	or	r31,  r0,   r30			/* make r31 our pointer. */
	addu	r30,  r30,  SIZEOF_EF		/* r30 now has previous SR3 */
	st	r30,  r31,  REG_OFF(EF_SR3)	/* save previous SR3 */
	br.n	_ASM_LABEL(have_pcb)
	 xcr	r30,  r30,  SR3			/* restore r30 */
d1240 2
a1241 2
	or.u	r1,   r0,   hi16(_ASM_LABEL(kstack))
	ld	r1,   r1,   lo16(_ASM_LABEL(kstack))
d1243 24
a1266 23
	st	FLAGS,r1,   REG_OFF(EF_FLAGS)	/* store flags */
	st	r31,  r1,   GENREG_OFF(31)	/* store r31 - now free */
	st	r30,  r1,   REG_OFF(EF_SR3)	/* store old SR3 (pcb) */
	or	r31,  r1,   r0			/* make r31 our exception fp */
	ld	r1,   r30,  GENREG_OFF(0)	/* restore old r1 */
	st	r0,   r30,  GENREG_OFF(0)	/* repair that frame */
	st	r1,   r31,  GENREG_OFF(1)	/* store r1 */
	br.n	_ASM_LABEL(have_pcb)
	 xcr	r30,  r30,  SR3			/* restore r30 */

ASLOCAL(pickup_stack)
	/*
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: return address to the calling exception handler
	 * SR3: free
	 * FLAGS: CPU status flags
	 *
	 * immediate goal:
	 *   Since we're servicing an exception from user mode, we
	 *   know that SR3 is free.  We use it to free up a temp.
	 *   register to be used in getting the thread's pcb
	 */
	stcr	r31,  SR3	/* save previous r31 */
d1269 6
a1274 6
	or.u	r31,  r0,   hi16(_C_LABEL(curpcb))
	ld	r31,  r31,  lo16(_C_LABEL(curpcb))
	addu	r31,  r31,  PCB_USER_STATE	/* point to user save area */
	st	FLAGS,r31,  REG_OFF(EF_FLAGS)	/* save flags */
	st	r1,   r31,  GENREG_OFF(1)	/* save prev. r1 (now free) */
	ldcr	r1,   SR3			/* save previous r31 */
d1276 1
a1276 1
	/* FALLTHROUGH */
d1278 18
a1295 17
ASLOCAL(have_pcb)
	/*
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: return address to the calling exception handler
	 * SR3: free
	 * r1:  free
	 * FLAGS: CPU status flags
	 * r31: our exception frame
	 * Valid in the exception frame:
	 *   Exception-time r1, r31, FLAGS.
	 *   Exception SR3, if appropriate.
	 *
	 * immediate goal:
	 *   Save the shadow registers that need to be saved to
	 *   the exception frame.
	 */
	stcr	TMP, SR3	/* free up TMP, TMP2, TMP3 */
d1306 2
a1307 2
	/* get and store the cpu number */
	extu	TMP,  FLAGS,  FLAG_CPU_FIELD_WIDTH<0>	/* TMP = cpu# */
d1309 1
a1309 1

a1313 1
#ifdef MVME187
d1315 2
a1316 2
	or.u	TMP,  r0,   hi16(_C_LABEL(brdtyp))
	ld	TMP2, TMP,  lo16(_C_LABEL(brdtyp))
d1319 1
a1319 2
#endif

d1321 1
a1321 1
	cmp	TMP2, TMP, 0x0				/* CPU0 ? */
d1323 1
a1323 1
	cmp	TMP2, TMP, 0x1				/* CPU1 ? */
d1325 1
a1325 1
	cmp	TMP2, TMP, 0x2				/* CPU2 ? */
d1327 1
a1327 1
	cmp	TMP2, TMP, 0x3				/* CPU3 ? */
d1329 2
a1330 3
	/* Arrrrg! bad cpu# */
	br	_ASM_LABEL(Lbadcpupanic)
	/* XXX WHAT ABOUT MODULES WITH SPLIT U/S CMMUS ??? */
d1339 1
a1339 1
	br	_ASM_LABEL(pfsr_done)
d1348 1
a1348 1
	br	_ASM_LABEL(pfsr_done)
d1357 1
a1357 1
	br	_ASM_LABEL(pfsr_done)
d1366 2
a1367 2
	br	_ASM_LABEL(pfsr_done)
5:
d1369 1
a1369 2
#ifdef MVME187
	/* it's a single processor SBC */
a1375 1
#endif
d1377 1
a1377 1
ASLOCAL(pfsr_done)
d1382 26
a1407 10

/*
 * The above shadow registers are obligatory for any and all
 * exceptions.  Now, if the data access pipeline is not clear,
 * we must save the DMx shadow registers, as well as clear
 * the appropriate SSBR bits for the destination registers of
 * loads or xmems.
 */
	bb0.n	DMT_VALID_BIT, TMP3, 8f
	 st	TMP3, r31,  REG_OFF(EF_DMT0)
d1424 1
a1424 1
	FLUSH_PIPELINE
d1430 5
a1434 4
/*
 * need to clear "appropriate" bits in the SSBR before
 * we restart the FPU
 */
d1436 1
d1438 6
a1443 6
	bb0.n	DMT_VALID_BIT, TMP2, 8f
	/* make sure an exception in fpu_enable will not see our DMT0 */
	 stcr	r0,   DMT0
	bb1	DMT_LOCK_BIT,  TMP2, 1f
	bb1	DMT_WRITE_BIT, TMP2, 2f
1:
d1447 2
a1448 1
2:
d1450 5
a1454 4
	bb0	DMT_VALID_BIT, TMP2, 4f
	bb1	DMT_LOCK_BIT,  TMP2, 3f
	bb1	DMT_WRITE_BIT, TMP2, 4f
3:
d1458 2
a1459 1
4:
d1461 6
a1466 5
	bb0	DMT_VALID_BIT, TMP2, 8f
	bb1	DMT_LOCK_BIT,  TMP2, 5f
	bb1	DMT_WRITE_BIT, TMP2, 8f
	bb1	DMT_DOUBLE_BIT,TMP2, 6f
5:
d1468 4
a1471 3
	br.n	7f
	 set	TMP2, TMP2, 1<5>	/* single */
6:
d1473 23
a1495 22
	set	TMP2, TMP2, 1<6>	/* double */
7:
	clr	TMP,  TMP,  TMP2
8:
	/*
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: return address to the calling exception handler
	 * SR3: saved TMP
	 * r1:  free
	 * TMP: possibly revised SSBR
	 * TMP2: free
	 * TMP3: free
	 * FLAGS: CPU status flags
	 * r31: exception frame
	 * Valid in the exception frame:
	 *   Exception-time r1, r31, FLAGS.
	 *   Exception-time TMP2, TMP3.
	 *   Exception-time espr, sfip, snip, sxip.
	 *   Dmt0.
	 *   Other data pipeline control registers, if appropriate.
	 *   Exception SR3, if appropriate.
	 */
d1497 1
a1497 1
	jmp	r1	/* allow the handler to clear more SSBR bits */
d1499 1
a1499 1
#endif /* M88100 */
d1501 4
a1504 1
ASLOCAL(clear_FPi_ssbr_bit)
d1506 1
a1506 1
	 * Clear floatingpoint-imprecise ssbr bits.
d1509 4
a1512 4
	 * r1:  return address to calling exception handler
	 * TMP: (possibly) revised ssbr
	 * TMP2: free
	 * TMP3: free
d1534 11
a1544 6
	bb0	FPIT_SIZE_BIT, TMP2, 1f
	extu	TMP2, TMP2, 5<0>	/* get the reg. */
	set	TMP2, TMP2, 1<6>	/* set width */
	clr	TMP,  TMP,  TMP2
1:
	jmp	r1
d1547 1
a1547 1
ASLOCAL(clear_FPp_ssbr_bit)
d1552 25
a1576 9
	 * r1:  return address to calling exception handler
	 * TMP: (possibly) revised ssbr
	 * TMP2: free
	 * TMP3: free
	 */
	fldcr	TMP2, FPSR
	fldcr	TMP3, FPCR
	st	TMP2, r31,  REG_OFF(EF_FPSR)
	st	TMP3, r31,  REG_OFF(EF_FPCR)
d1578 8
a1585 11
	fldcr	TMP3, FPECR
	st	TMP3, r31,  REG_OFF(EF_FPECR)
	fldcr	TMP2, FPHS1
	fldcr	TMP3, FPHS2
	st	TMP2, r31,  REG_OFF(EF_FPHS1)
	st	TMP3, r31,  REG_OFF(EF_FPHS2)

	fldcr	TMP2, FPLS1
	fldcr	TMP3, FPLS2
	st	TMP2, r31,  REG_OFF(EF_FPLS1)
	st	TMP3, r31,  REG_OFF(EF_FPLS2)
a1586 14
	fldcr	TMP2, FPPT
	st	TMP2, r31,  REG_OFF(EF_FPPT)
1:

#define FPPT_SIZE_BIT   5
	bb1.n	FPPT_SIZE_BIT, TMP2, 2f
	 extu	TMP3, TMP2, 5<0>	/* get FP operation dest reg */
	br.n	3f
	 set	TMP3, TMP3, 1<5>	/* size=1 - clear one bit for float */
2:
	set	TMP3, TMP3, 1<6>	/* size=2 - clear two bit for double */
3:
	clr	TMP,  TMP,  TMP3	/* clear bit(s) in ssbr. */
	jmp	r1
d1588 2
d1591 1
a1591 1
ASLOCAL(clear_dest_ssbr_bit)
d1613 11
a1623 11
	 *  TMP: (possibly) revised ssbr
	 *  TMP2: free
	 *  TMP3: free
	 */

	ldcr	TMP3, EPSR	/* going to check: user or system memory? */
	ldcr	TMP2, SXIP	/* get the instruction's address */
	bb1.n	PSR_SUPERVISOR_MODE_BIT, TMP3, 2f
	 clr	TMP2, TMP2, 2<0>	/* get rid of valid and error bits. */

	/* user space load here */
d1626 1
a1626 1
	ld.usr	TMP2,TMP2, r0	/* get the instruction itself */
d1633 1
a1633 1
	 ld.usr	TMP2,TMP2, r0	/* get the instruction itself */
d1637 1
a1637 1
	ld	TMP2, TMP2, r0	/* get the instruction itself */
d1639 1
a1639 1
3:	/* now we have the instruction..... */
d1659 5
a1663 5
	extu	TMP3, TMP2, 16<16>	/* get the upper 16 bits */
	mask	TMP3, TMP3, 0xFC00	/* apply the mask */
	cmp	TMP3, TMP3, 0x1000	/* if equal, it's a load double */
	bb1	eq,   TMP3, 2f

d1666 5
a1670 5
	extu	TMP3, TMP2, 16<16>	/* get the upper 16 bits */
	mask	TMP3, TMP3, 0xFC00	/* apply the mask */
	cmp	TMP3, TMP3, 0xF400	/* if equal, might be a load double */
	bb1	ne,   TMP3, 1f		/* not equal, must be single */

d1672 13
a1684 16
	extu	TMP3, TMP2, 16<0>	/* get the lower 16 bits */
	mask	TMP3, TMP3, 0xFCE0	/* apply the mask */
	cmp	TMP3, TMP3, 0x1000	/* if equal, it's a load double */
	bb1	eq,   TMP3, 2f

1:	/* misaligned single */
	extu	TMP2, TMP2, 5<21>	/* get the destination register */
	br.n	3f
	 set	TMP2, TMP2, 1<5>	/* set size=1 */

2:	/* misaligned double */
	extu	TMP2, TMP2, 5<21>	/* get the destination register */
	set	TMP2, TMP2, 1<6>	/* set size=2 -- clear two bits */
3:
	jmp.n	r1
	 clr	TMP,  TMP,  TMP2	/* clear bit(s) in ssbr. */
d1686 2
a1687 1
#ifdef M88100
d1689 2
a1690 25
ASLOCAL(setup_phase_two)
	/*
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: free
	 * SR3: saved TMP
	 * r1:  return address to calling exception handler
	 * TMP: possibly revised SSBR
	 * TMP2: free
	 * TMP3: free
	 * FLAGS: CPU status flags
	 * r31: our exception frame
	 *    Valid in the exception frame:
	 *   Exception-time r1, r31, FLAGS.
	 *   Exception-time TMP2, TMP3.
	 *   Exception-time espr, sfip, snip, sxip.
	 *   Exception number (EF_VECTOR).
	 *   Dmt0
	 *   Other data pipeline control registers, if appropriate.
	 *   FPU control registers, if appropriate.
	 *   Exception SR3, if appropriate.
	 *
	 * immediate goal:
	 *   restore the system to the exception-time state (except
	 *   SR3 will be OUR stack pointer) so that we may resart the FPU.
	 */
d1692 1
a1692 3
	stcr	TMP,  SSBR	/* done with SSBR, TMP now free */
	RESTORE_TMP2	/* done with extra temp regs */
	RESTORE_TMP3	/* done with extra temp regs */
d1694 32
d1727 6
a1732 5
	ldcr	TMP,  PSR
	clr	TMP,  TMP,  1<PSR_FPU_DISABLE_BIT>	/* enable the FPU */
	clr	TMP,  TMP,  1<PSR_SHADOW_FREEZE_BIT>	/* and shadowing */
	stcr	TMP,  EPSR

d1734 60
a1793 47
	or.u	TMP,  r0,   hi16(_ASM_LABEL(fpu_enable) + 2)
	or	TMP,  TMP,  lo16(_ASM_LABEL(fpu_enable) + 2)
	stcr	TMP,  SNIP	/* jump to here fpu_enable */
	addu	TMP,  TMP,  4
	stcr	TMP,  SFIP	/* and then continue after that */

	set	FLAGS, FLAGS, 1<FLAG_ENABLING_FPU>
	xcr	FLAGS, FLAGS, SR1
	st	r1,   r31,  REG_OFF(EF_RET)	/* save the return address */
	ld	r1,   r31,  GENREG_OFF(1)	/* get original r1 */

	xcr	TMP,  r31,  SR3	/* TMP now restored. R31 now saved in SR3 */
	ld	r31,  r31,  GENREG_OFF(31)	/* get original r31 */

	/*
	 * SR1: CPU flags
	 * SR2: free
	 * SR3: pointer to our exception frame (our stack pointer)
	 * r1 through r31: original exception-time values
	 *
	 * Valid in the exception frame:
	 *   Exception-time FLAGS.
	 *   Exception-time espr, sfip, snip, sxip.
	 *   Exception number (EF_VECTOR).
	 *   Dmt0
	 *   Other data pipeline control registers, if appropriate.
	 *   FPU control registers, if appropriate.
	 *   Exception SR3, if appropriate.
	 *   Held temporarly in the exception frame:
	 *   Return address to the calling exception handler.
	 *
	 * immediate goal:
	 *   Do an RTE to restart the fpu and jump to "fpu_enable"
	 *   Another exception (or exceptions) may be raised in
	 *   this, which is why FLAG_ENABLING_FPU is set in SR1.
	 */

	RTE	/* jumps to "fpu_enable" on the next line to enable the FPU. */

ASLOCAL(fpu_enable)
	FLUSH_PIPELINE
	xcr	TMP,  TMP,  SR3			/* get E.F. pointer */
	st	r30,  TMP,  GENREG_OFF(30)	/* save previous r30, r31 */
	st	r31,  TMP,  GENREG_OFF(31)	/* save previous r30, r31 */
	or	r31,  TMP,  r0			/* transfer E.F. pointer to r31 */
	ld	TMP,  r31,  REG_OFF(EF_SR3)	/* get previous SR3 */

d1795 6
a1800 6
	xcr	FLAGS,FLAGS,SR1
	clr	FLAGS,FLAGS,1<FLAG_ENABLING_FPU>
	xcr	FLAGS,FLAGS,SR1

	xcr	TMP,  TMP,  SR3	/* replace TMP, SR3 */

d1802 15
a1816 30
	st	r0 ,  r31,  GENREG_OFF(0)
	st	r1 ,  r31,  GENREG_OFF(1)
	st	r2 ,  r31,  GENREG_OFF(2)
	st	r3 ,  r31,  GENREG_OFF(3)
	st	r4 ,  r31,  GENREG_OFF(4)
	st	r5 ,  r31,  GENREG_OFF(5)
	st	r6 ,  r31,  GENREG_OFF(6)
	st	r7 ,  r31,  GENREG_OFF(7)
	st	r8 ,  r31,  GENREG_OFF(8)
	st	r9 ,  r31,  GENREG_OFF(9)
	st	r10,  r31,  GENREG_OFF(10)
	st	r11,  r31,  GENREG_OFF(11)
	st	r12,  r31,  GENREG_OFF(12)
	st	r13,  r31,  GENREG_OFF(13)
	st	r14,  r31,  GENREG_OFF(14)
	st	r15,  r31,  GENREG_OFF(15)
	st	r16,  r31,  GENREG_OFF(16)
	st	r17,  r31,  GENREG_OFF(17)
	st	r18,  r31,  GENREG_OFF(18)
	st	r19,  r31,  GENREG_OFF(19)
	st	r20,  r31,  GENREG_OFF(20)
	st	r21,  r31,  GENREG_OFF(21)
	st	r22,  r31,  GENREG_OFF(22)
	st	r23,  r31,  GENREG_OFF(23)
	st	r24,  r31,  GENREG_OFF(24)
	st	r25,  r31,  GENREG_OFF(25)
	st	r26,  r31,  GENREG_OFF(26)
	st	r27,  r31,  GENREG_OFF(27)
	st	r28,  r31,  GENREG_OFF(28)
	st	r29,  r31,  GENREG_OFF(29)
d1819 3
a1821 3
	or.u	r20,  r0,   hi16(0x12345678)
	or	r20,  r20,  lo16(0x12345678)
	st	r20,  r31,  GENREG_OFF(0)
d1825 1
a1825 3
	bsr.n	_C_LABEL(getipl)
	 subu	r31, r31, 32
	addu	r31, r31, 32
d1827 32
a1858 1

d1860 2
a1861 24
	 * SR1: free
	 * SR2: free
	 * SR3: previous exception-time SR3
	 * r1: return address to the calling exception handler
	 * r2 through r30: free
	 * r31: our exception frame
	 *
	 * Valid in the exception frame:
	 *   Exception-time r0 through r31.
	 *   Exception-time FLAGS.
	 *   Exception-time espr, sfip, snip, sxip.
	 *   Exception number (EF_VECTOR).
	 *   Dmt0
	 *   Other data pipeline control registers, if appropriate.
	 *   FPU control registers, if appropriate.
	 *   Exception SR3, if appropriate.
	 *
	 * immediate goal:
	 *   Pick up a stack if we came in from user mode.
	 *   Put a copy of the exception frame pointer into r30
	 *   Bump the stack a doubleword and write the exception frame pointer.
	 *   If not an interrupt exception, turn on interrupts and service any
	 *     outstanding data access exceptions.
	 *   Return to calling exception handler to service the exception.
d1863 1
a1863 1

d1865 2
a1866 2
	 * If it's not the interrupt exception, enable interrupts and
	 * take care of any data access exceptions......
d1868 18
a1885 7
	or	r30,  r0,   r31		/* get a copy of the e.f. pointer */
	ld	r2,   r31,  REG_OFF(EF_EPSR)
	bb1	PSR_SUPERVISOR_MODE_BIT, r2, 1f	/* if in kernel mode */

	or.u	r31,  r0,   hi16(_ASM_LABEL(kstack))
	ld	r31,  r31,  lo16(_ASM_LABEL(kstack))
	addu	r31,  r31,  USIZE	/* point at proper end */
d1887 10
a1896 2

	/*
d1899 5
a1903 5
	 */
	subu	r31,  r31,  8	/* make some breathing space */
	st	r30,  r31,  0	/* store frame pointer on the stack */
#ifdef DDB
	st	r30,  r31,  4	/* store it for the debugger to recognize */
d1906 5
a1910 3
	ld	r2,   r30,  REG_OFF(EF_VECTOR)
	bcnd.n	eq0,  r2,   8f			/* error exception */
	 ld	r14,  r30,  REG_OFF(EF_RET)
d1912 6
a1917 6
	/*
	 * Do not process possible data exceptions here if this is an interrupt.
	 * Instead, the interrupt handler will take care of this by itself.
	 */
	cmp	r3,   r2,   1			/* is an interrupt? */
	bb1.n	eq,   r3,   8f			/* skip if so */
d1919 5
a1923 5
#ifdef DDB
	 cmp	r3,   r2,   130	/* DDB break exception */
	bb1.n	eq,   r3,   8f
	 cmp	r3,   r2,   132	/* DDB entry exception */
	bb1.n	eq,   r3,   8f
d1926 2
a1927 5
	/* turn interrupts back on */
	 ldcr	r2,   PSR
	clr	r2,   r2,   1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r2,   PSR
	FLUSH_PIPELINE
d1929 2
a1930 3
	/* service any outstanding data pipeline stuff */
	ld	r3,   r30,  REG_OFF(EF_DMT0)
	bb0	DMT_VALID_BIT, r3, 8f
d1933 2
a1934 2
	 * r30 can be clobbered by calls. So stuff its value into a preserved
	 * register, say r15. R14 is in use (see return_to_... below).
d1936 2
a1937 1
	or	r15,  r0,   r30
d1939 11
a1949 1
	or	r30,  r0,   r15
a1950 3
8:
	jmp	r14	/* loaded above */
#endif /* M88100 */
d1962 2
a1963 2
	ld	r1, r31, 0		/* load func */
	ld	r2, r31, 4 		/* load proc pointer */
d1965 4
a1968 4
	 subu	r31, r31, 32		/* create stack space for function */
	addu	r31, r31, 32 + 8	/* stack space above + ksigframe */
	ld	r1,  r31, 0		/* load pc */
	ld	r2,  r31, 4		/* & proc pointer from switch frame */
d1970 2
a1971 1
	 addu	r31, r31, 8
d1974 1
a1974 1
 * proc_do_uret
d1985 1
a1985 9
#if defined(M88100) && defined(M88110)
#ifdef M88110
	or.u	r2, r0, hi16(_C_LABEL(cputyp))
	ld	r3, r2, lo16(_C_LABEL(cputyp))
	cmp	r2, r3, CPU_88110
	bb1	eq, r2, _ASM_LABEL(m88110_return_code)
	/* br	_ASM_LABEL(return_from_exception_handler) */
#endif
#endif
d1987 1
d1993 1
a1993 1
	 * At this point, if EF_DMT0 is not zero on MC88100, then
d2000 3
a2002 1
	 * Control is transferred here from obvious places in this file.
d2004 6
a2009 1

d2011 2
a2012 8
ASLOCAL(return_from_exception_handler)
	/*
	 * if there happens to be a data fault that hasn't been serviced yet,
	 * go off and service that...
	 */

#define	FPTR	r14
	ld	FPTR, r31, 0	/* grab exception frame pointer */
d2014 1
a2014 1
	bb0	DMT_VALID_BIT, r3, _ASM_LABEL(check_ast)
d2016 1
d2018 2
a2019 2
	 * If it's the interrupt exception, and interrupts were
	 * initially disabled, enable interrupts again...
d2022 33
a2054 10
	cmp	r2, r2, 1	/* is an interrupt? */
	bb1.n	ne, r2, 1f	/* if not so, skip */

	/* ...unless they were already disabled */
	 ld	r2, FPTR, REG_OFF(EF_EPSR)
	bb1.n	PSR_INTERRUPT_DISABLE_BIT, r2, 1f

	 ldcr	r2, PSR
	clr	r2, r2, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r2, PSR
d2056 1
d2058 2
d2061 4
d2066 6
a2071 2
	br	_ASM_LABEL(check_ast)
#endif /* M88100 */
d2075 2
a2076 2
#define	FPTR	r14
	ld	FPTR, r31, 0	/* grab exception frame pointer */
a2077 1
#if 0
d2080 1
d2086 1
a2086 1
	 *
d2090 2
a2091 2
	cmp	r2, r2, 1	/* Is it an interrupt? */
	bb1.n	ne, r2, 1f	/* If not, skip */
d2093 6
a2098 6
	/* ...unless they were already disabled */
	 ld	r2, FPTR, REG_OFF(EF_EPSR)
	bb1.n	PSR_INTERRUPT_DISABLE_BIT, r2, 1f

	 ldcr	r2, PSR
	clr	r2, r2, 1<PSR_INTERRUPT_DISABLE_BIT>	/* enable interrupts */
a2099 1
	FLUSH_PIPELINE
d2101 16
a2116 1
#endif
a2124 4
	ld	r2, FPTR, REG_OFF(EF_EPSR)	/* get pre-exception PSR */
	bb1	PSR_INTERRUPT_DISABLE_BIT, r2, 1f	/* skip if ints off */
	ld	r2, FPTR, REG_OFF(EF_MASK)	/* get pre-exception ipl */
	bcnd	ne0, r2, 1f		/* can't do softint's */
d2126 5
d2132 9
a2140 7
	bsr.n	_C_LABEL(setipl)
	 or	r2, r0, IPL_SOFTCLOCK
	/* at ipl 1 now */
	bsr	_C_LABEL(dosoftint)
	/* is this needed? we are going to restore the ipl below XXX nivas */
	bsr.n	_C_LABEL(setipl)
	 or	r2, r0, IPL_NONE		/* ints are enabled */
d2144 2
a2145 2
	ld	r2, FPTR, REG_OFF(EF_EPSR)	/* get pre-exception PSR */
	bb1	PSR_SUPERVISOR_MODE_BIT, r2, no_ast	/*skip if system mode */
d2147 9
a2155 9
	/* should assert here - not in user mode with ints off XXX nivas */
	/* get and check want_ast */
	or.u	r2, r0, hi16(_C_LABEL(want_ast))
	ld	r3, r2, lo16(_C_LABEL(want_ast))
	bcnd	eq0, r3, no_ast

	/*
	 * trap(AST,...) will service ast's.
	 */
d2163 1
a2163 1
	CALL(_C_LABEL(m88110_trap), T_ASTFLT, FPTR)
d2170 1
a2170 1
	CALL(_C_LABEL(m88100_trap), T_ASTFLT, FPTR)
a2173 5
	/* disable interrupts */
	ldcr	r1, PSR
	set	r1, r1, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r1, PSR
	FLUSH_PIPELINE
d2175 39
a2213 47
	/* now ready to return....*/
	subu	r31, r31, 32
	bsr.n	_C_LABEL(setipl)
	 ld	r2, FPTR, REG_OFF(EF_MASK)	/* get pre-exception ipl */
	addu	r31, r31, 32

	/*
	 * Transfer the frame pointer to r31, since we no longer need a stack.
	 * No page faults here, and interrupts are disabled.
	 */
	or	r31, r0,  FPTR
	/* restore r1 later */
	ld	r2 , r31, GENREG_OFF(2)
	ld	r3 , r31, GENREG_OFF(3)
	ld	r4 , r31, GENREG_OFF(4)
	ld	r5 , r31, GENREG_OFF(5)
	ld	r6 , r31, GENREG_OFF(6)
	ld	r7 , r31, GENREG_OFF(7)
	ld	r8 , r31, GENREG_OFF(8)
	ld	r9 , r31, GENREG_OFF(9)
	ld	r10, r31, GENREG_OFF(10)
	ld	r11, r31, GENREG_OFF(11)
	ld	r12, r31, GENREG_OFF(12)
	ld	r13, r31, GENREG_OFF(13)
	ld	r14, r31, GENREG_OFF(14)
	ld	r15, r31, GENREG_OFF(15)
	ld	r16, r31, GENREG_OFF(16)
	ld	r17, r31, GENREG_OFF(17)
	ld	r18, r31, GENREG_OFF(18)
	ld	r19, r31, GENREG_OFF(19)
	ld	r20, r31, GENREG_OFF(20)
	ld	r21, r31, GENREG_OFF(21)
	ld	r22, r31, GENREG_OFF(22)
	ld	r23, r31, GENREG_OFF(23)
	ld	r24, r31, GENREG_OFF(24)
	ld	r25, r31, GENREG_OFF(25)
	ld	r26, r31, GENREG_OFF(26)
	ld	r27, r31, GENREG_OFF(27)
	ld	r28, r31, GENREG_OFF(28)
	ld	r29, r31, GENREG_OFF(29)
	/* restore r1, r30, r31 later */

	/* disable shadowing */
	ldcr	r1, PSR
	set	r1, r1, 1<PSR_SHADOW_FREEZE_BIT>
	stcr	r1, PSR
	FLUSH_PIPELINE
d2217 1
a2217 2
#ifdef M88100
	or.u	r1, r0, hi16(_C_LABEL(cputyp))
d2221 6
a2226 8
#endif
	/* mc88110 needs the EXIP */
	ld	r30, r31, REG_OFF(EF_ENIP)
	ld	r1,  r31, REG_OFF(EF_EXIP)
	stcr	r30, ENIP
	stcr	r1,  EXIP
#ifdef M88100
	br	2f
d2228 34
a2261 37
#endif
#endif
#ifdef M88100
	st	r0, r31, REG_OFF(EF_IPFSR)
	st	r0, r31, REG_OFF(EF_DPFSR)

	/*
	 * Note: no need to restore the SXIP.
	 * When the "rte" causes execution to continue
	 * first with the instruction pointed to by the NIP
	 * and then the FIP.
	 *
	 * See MC88100 Risc Processor User's Manual, 2nd Edition,
	 * section 6.4.3.1.2-4
	 */
	ld	r30, r31, REG_OFF(EF_SNIP)
	ld	r1,  r31, REG_OFF(EF_SFIP)
	stcr	r0,  SSBR
	stcr	r30, SNIP
	stcr	r1,  SFIP
2:
#endif
	ld	r30, r31, REG_OFF(EF_EPSR)
	ld	r1,  r31, REG_OFF(EF_MODE)
	stcr	r30, EPSR

	/* Now restore r1, r30, and r31 */
	ld	r1,  r31, GENREG_OFF(1)
	ld	r30, r31, GENREG_OFF(30)
	ld	r31, r31, GENREG_OFF(31)

	RTE

#ifdef M88110
/*
 * MVME197 exception handlers
 */
d2265 1
a2265 1
	PREP2("unknown", 0, DEBUG_UNKNOWN_BIT,)
d2267 1
a2267 1
	DONE2(DEBUG_UNKNOWN_BIT)
d2271 1
a2271 1
	PREP2("interrupt", 1, DEBUG_INTERRUPT_BIT,)
d2273 1
a2273 1
	DONE2(DEBUG_INTERRUPT_BIT)
d2277 1
a2277 1
	PREP2("inst", 2, DEBUG_INSTRUCTION_BIT,)
d2279 1
a2279 1
	DONE2(DEBUG_INSTRUCTION_BIT)
d2285 1
a2285 1
	PREP2("data", 3, DEBUG_DATA_BIT, M88110_Data_Precheck)
d2287 1
a2287 1
	DONE2(DEBUG_DATA_BIT)
d2291 1
a2291 1
	PREP2("misalign", 4, DEBUG_MISALIGN_BIT,)
d2293 1
a2293 1
	DONE2(DEBUG_MISALIGN_BIT)
d2297 1
a2297 1
	PREP2("unimp", 5, DEBUG_UNIMPLEMENTED_BIT,)
d2299 1
a2299 1
	DONE2(DEBUG_UNIMPLEMENTED_BIT)
d2303 1
a2303 1
	PREP2("privilege", 6, DEBUG_PRIVILEGE_BIT,)
d2305 1
a2305 1
	DONE2(DEBUG_PRIVILEGE_BIT)
d2312 1
a2312 1
	PREP2("bounds", 7, DEBUG_BOUNDS_BIT,)
d2314 1
a2314 1
	DONE2(DEBUG_BOUNDS_BIT)
d2318 1
a2318 1
	PREP2("divide", 8, DEBUG_DIVIDE_BIT,)
d2320 1
a2320 1
	DONE2(DEBUG_DIVIDE_BIT)
d2324 1
a2324 1
	PREP2("overflow", 9, DEBUG_OVERFLOW_BIT,)
d2326 1
a2326 1
	DONE2(DEBUG_OVERFLOW_BIT)
d2330 3
a2332 3
	PREP2("FPU precise", 114, DEBUG_FPp_BIT,)
	CALL(_ASM_LABEL(m88110_Xfp_precise), r0, r30)
	DONE2(DEBUG_FPp_BIT)
d2336 1
a2336 1
	PREP2("MVME197 non-mask", 11, DEBUG_NON_MASK_BIT,)
d2338 1
a2338 1
	DONE2(DEBUG_NON_MASK_BIT)
d2342 1
a2342 1
	PREP2("MVME197 read miss", 12, DEBUG_197_READ_BIT,)
d2344 1
a2344 1
	DONE2(DEBUG_197_READ_BIT)
d2348 1
a2348 1
	PREP2("MVME197 write miss", 13, DEBUG_197_WRITE_BIT,)
d2350 1
a2350 1
	DONE2(DEBUG_197_WRITE_BIT)
d2354 1
a2354 1
	PREP2("MVME197 inst miss", 14, DEBUG_197_INST_BIT,)
d2356 1
a2356 1
	DONE2(DEBUG_197_INST_BIT)
d2360 4
a2363 4
	PREP2("syscall", 128, DEBUG_SYSCALL_BIT,)
	ld	r13, r30, GENREG_OFF(13)
	CALL(_C_LABEL(m88110_syscall), r13, r30)
	DONE2(DEBUG_SYSCALL_BIT)
d2367 4
a2370 4
	PREP2("bugsyscall", 496, DEBUG_BUGCALL_BIT,)
	ld	r9,  r30, GENREG_OFF(9)
	CALL(_C_LABEL(bugsyscall), r9, r30)
	DONE2(DEBUG_BUGCALL_BIT)
d2373 1
a2373 1
	PREP2("sigsys", 501, DEBUG_SIGSYS_BIT,)
d2375 1
a2375 1
	DONE2(DEBUG_SIGSYS_BIT)
d2378 1
a2378 1
	PREP2("sigtrap", 510, DEBUG_SIGTRAP_BIT,)
d2380 1
a2380 1
	DONE2(DEBUG_SIGTRAP_BIT)
d2383 1
a2383 1
	PREP2("stepbpt", 504, DEBUG_SIGTRAP_BIT,)
d2385 1
a2385 1
	DONE2(DEBUG_SIGTRAP_BIT)
d2388 1
a2388 1
	PREP2("userbpt", 511, DEBUG_SIGTRAP_BIT,)
d2390 1
a2390 1
	DONE2(DEBUG_SIGTRAP_BIT)
d2392 1
a2392 1
#ifdef DDB
d2394 1
a2394 1
	PREP2("break", 130, DEBUG_BREAK_BIT,)
d2396 1
a2396 1
	DONE2(DEBUG_BREAK_BIT)
d2399 1
a2399 1
	PREP2("trace", 131, DEBUG_TRACE_BIT,)
d2401 1
a2401 1
	DONE2(DEBUG_TRACE_BIT)
d2404 1
a2404 1
	PREP2("kdb", 132, DEBUG_KDB_BIT,)
d2406 2
a2407 2
	DONE2(DEBUG_KDB_BIT)
#else
d2409 1
a2409 1
	PREP2("break", 130, DEBUG_BREAK_BIT,)
d2411 1
a2411 1
	DONE2(DEBUG_BREAK_BIT)
d2414 1
a2414 1
	PREP2("trace", 131, DEBUG_TRACE_BIT,)
d2416 1
a2416 1
	DONE2(DEBUG_TRACE_BIT)
d2419 1
a2419 1
	PREP2("unknown", 132, DEBUG_KDB_BIT,)
d2421 3
a2423 2
	DONE2(DEBUG_KDB_BIT)
#endif
d2425 1
d2427 1
a2427 2
 * The error exception and reset exception handler.
 *
d2431 17
a2447 2
 * The reset exception is raised when the RST signal is asserted (machine
 * is reset), the value of VBR is changed after exceptions are enabled,
a2448 2
 * Upon a real reset, VBR is set to zero (0), so code must be at addr 0
 * to handle it!!!
d2450 6
a2455 3
 * The shadow registers are not valid in this case (shadowing was off, if this
 * was an error exception, and may not be on, if this was a reset exception).
 * R1-R31 may be interesting though, so we'll save them.
a2459 3
GLOBAL(m88110_error_handler)
	br.n	1f
	 or	r29, r0, 10
d2461 7
a2467 6
	or	r29, r0, 0
1:
	/* pick up the slavestack */
	or	r26, r0, r31	/* save old stack */
	or.u	r31, r0,  hi16(_ASM_LABEL(intstack_end))
	or	r31, r31, lo16(_ASM_LABEL(intstack_end))
a2468 1
#ifdef DEBUG
d2470 2
a2471 2
	or.u	r27, r0,  hi16(_C_LABEL(intstack))
	or	r27, r27, lo16(_C_LABEL(intstack))
d2473 1
a2473 1
	bb1	ge,  r28, 2f	/* branch if at the end of the stack */
d2476 1
a2476 1
	 addu	r27, r27, 4	/* bump up */
a2477 1
#endif
d2480 1
a2480 1
	clr	r31, r31, 3<0>	/* round down to 8-byte boundary */
d2483 1
a2483 1
	subu	r31, r31, SIZEOF_EF		/* r31 now our E.F. */
d2486 14
a2499 14
	st.d	r0 , r31, GENREG_OFF(0)
	st.d	r2 , r31, GENREG_OFF(2)
	st.d	r4 , r31, GENREG_OFF(4)
	st.d	r6 , r31, GENREG_OFF(6)
	st.d	r8 , r31, GENREG_OFF(8)
	st.d	r10, r31, GENREG_OFF(10)
	st.d	r12, r31, GENREG_OFF(12)
	st.d	r14, r31, GENREG_OFF(14)
	st.d	r16, r31, GENREG_OFF(16)
	st.d	r18, r31, GENREG_OFF(18)
	st.d	r20, r31, GENREG_OFF(20)
	st.d	r22, r31, GENREG_OFF(22)
	st.d	r24, r31, GENREG_OFF(24)
	st	r30, r31, GENREG_OFF(30)
d2503 5
a2507 4
	st	r29, r31, REG_OFF(EF_VECTOR)
	cmp	r29, r29, 0	/* is it the reset exception? */
	bb1.n	ne,  r29, 1f	/* if not, skip */

d2509 1
a2509 1
	 ldcr	r10, EPSR
d2529 1
a2529 1
	 st	r10, r31, REG_OFF(EF_MODE)
d2531 1
a2531 1
1:
d2533 2
a2534 2
	or.u	r30, r0,  hi16(_ASM_LABEL(save_frame))
	or	r30, r30, lo16(_ASM_LABEL(save_frame))
d2570 1
d2574 5
a2578 4
	ldcr	r10, PSR
	clr	r10, r10, 1<PSR_FPU_DISABLE_BIT>	/* enable the FPU */
	clr	r10, r10, 1<PSR_SHADOW_FREEZE_BIT>	/* and shadowing */
	stcr	r10, PSR
d2584 3
a2586 3
	subu	r31, r31, 0x10	/* make some breathing space */
	st	r30, r31, 0x0c	/* store frame pointer on the st */
	st	r30, r31, 0x08	/* store again for the debugger to recognize */
d2591 2
d2594 25
a2618 25
	CALL(_C_LABEL(error_fatal), r30, r30)

	/* turn interrupts back on */
	ldcr	r1, PSR
	clr	r1, r1, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r1, PSR
	FLUSH_PIPELINE

1:
	br	1b
	/* NOTREACHED */

ASLOCAL(m88110_setup_phase_one)
	/*
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: saved copy of exception-time r1
	 * SR3: must be preserved .. may be the exception-time stack
	 * r1: return address to calling exception handler
	 * FLAGS: CPU status flags
	 *
	 * immediate goal:
	 *   Decide where we're going to put the exception frame.
	 *   Might be at the end of R31, SR3, or the thread's pcb.
	 */

d2622 1
a2622 1
	xcr	r1,   r1,   SR2
d2626 2
a2627 2

	bb1	FLAG_ENABLING_FPU, FLAGS, _ASM_LABEL(m88110_use_SR3_pcb)
d2629 2
a2630 2
	bb0	FLAG_FROM_KERNEL, FLAGS, _ASM_LABEL(m88110_pickup_stack)

d2632 54
a2685 45
	/*
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: return address to the calling exception handler
	 * SR3: must be preserved; may be important for other exceptions
	 * FLAGS: CPU status flags
	 *
	 * immediate goal:
	 *   We're already on the kernel stack, but not having
	 *   needed to use SR3. We can just make room on the
	 *   stack (r31) for our exception frame.
	 */
	subu	r31,  r31,  SIZEOF_EF		/* r31 now our E.F. */
	st	FLAGS,r31,  REG_OFF(EF_FLAGS)	/* save flags */
	st	r1,   r31,  GENREG_OFF(1)	/* save prev. r1 (now free) */

	ldcr	r1,   SR3			/* save previous SR3 */
	st	r1,   r31,  REG_OFF(EF_SR3)

	addu	r1,   r31,  SIZEOF_EF		/* save previous r31 */
	br.n	_ASM_LABEL(m88110_have_pcb)
	 st	r1,   r31,  GENREG_OFF(31)

ASLOCAL(m88110_use_SR3_pcb)
	/*
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: return address to the calling exception handler
	 * SR3: must be preserved; exception-time stack pointer
	 * FLAGS: CPU status flags
	 *
	 * immediate goal:
	 *   An exception occurred while enabling the FPU. Since r31 is the
	 *   user's r31 while enabling the FPU, we had put our pcb pointer
	 *   into SR3, so make room from there for our stack pointer.
	 *   We need to check if SR3 is the old stack pointer or the pointer
	 *   off to the user pcb. If it pointing to the user pcb, we need to
	 *   pick up the kernel stack. Otherwise we need to allocate a frame
	 *   upon it.
	 *   We look at the EPSR to see if it was from user mode
	 *   Unfortunately, we have no registers free at the moment, but we
	 *   know register 0 in the pcb frame will always be zero, so we can
	 *   use it as scratch storage.
	 */
#if 1
	br	_C_LABEL(m88110_error_handler)
#else
d2687 5
a2691 5
	xcr	r30,  r30,  SR3			/* r30 = old exception frame */
	st	r1,   r30,  GENREG_OFF(0)	/* free up r1 */
	ld	r1,   r30,  REG_OFF(EF_EPSR)	/* get back the epsr */
	bb0.n	PSR_SUPERVISOR_MODE_BIT, r1, 1f	/* if user mode */
	 ld	r1,   r30,  GENREG_OFF(0)	/* restore r1 */
d2693 11
a2703 11
	st	r0,   r30,  GENREG_OFF(0)	/* repair old frame */
	subu	r30,  r30,  SIZEOF_EF		/* r30 now our E.F. */
	st	FLAGS,r30,  REG_OFF(EF_FLAGS)	/* save flags */
	st	r1,   r30,  GENREG_OFF(1)	/* save prev. r1 (now free) */

	st	r31,  r30,  GENREG_OFF(31)	/* save previous r31 */
	or	r31,  r0,   r30			/* make r31 our pointer. */
	addu	r30,  r30,  SIZEOF_EF		/* r30 now has previous SR3 */
	st	r30,  r31,  REG_OFF(EF_SR3)	/* save previous SR3 */
	br.n	_ASM_LABEL(m88110_have_pcb)
	 xcr	r30,  r30,  SR3			/* restore r30 */
d2705 1
a2705 2
	/*
	 * We took an exception while restarting the FPU from user space.
d2708 29
a2736 30
	 * r30)
	 */
	or.u	r1,   r0,   hi16(_ASM_LABEL(kstack))
	ld	r1,   r1,   lo16(_ASM_LABEL(kstack))
	addu	r1,   r1,   USIZE-SIZEOF_EF
	st	FLAGS,r1,   REG_OFF(EF_FLAGS)	/* store flags */
	st	r31,  r1,   GENREG_OFF(31)	/* store r31 - now free */
	st	r30,  r1,   REG_OFF(EF_SR3)	/* store old SR3 (pcb) */
	or	r31,  r1,   r0			/* make r31 our exception fp */
	ld	r1,   r30,  GENREG_OFF(0)	/* restore old r1 */
	st	r0,   r30,  GENREG_OFF(0)	/* repair that frame */
	st	r1,   r31,  GENREG_OFF(1)	/* store r1 */
	br.n	_ASM_LABEL(m88110_have_pcb)
	 xcr	r30,  r30,  SR3			/* restore r30 */
#endif

ASLOCAL(m88110_pickup_stack)
	/*
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: return address to the calling exception handler
	 * SR3: free
	 * FLAGS: CPU status flags
	 *
	 * immediate goal:
	 *   Since we're servicing an exception from user mode, we
	 *   know that SR3 is free.  We use it to free up a temporary
	 *   register to be used in getting the thread's pcb.
	 */
	stcr	r31,  SR3	/* save previous r31 */

d2738 27
a2764 26
	or.u	r31,  r0,   hi16(_C_LABEL(curpcb))
	ld	r31,  r31,  lo16(_C_LABEL(curpcb))
	addu	r31,  r31,  PCB_USER_STATE	/* point to user save area */
	st	FLAGS,r31,  REG_OFF(EF_FLAGS)	/* save flags */
	st	r1,   r31,  GENREG_OFF(1)	/* save prev. r1 (now free)*/
	ldcr	r1,   SR3			/* save previous r31 */
	st	r1,   r31,  GENREG_OFF(31)
	/* FALLTHROUGH */

ASLOCAL(m88110_have_pcb)
	/*
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: return address to the calling exception handler
	 * SR3: free
	 * r1:  free
	 * FLAGS: CPU status flags
	 * r31: our exception frame
	 * Valid in the exception frame:
	 *   Exception-time r1, r31, FLAGS.
	 *   Exception SR3, if appropriate.
	 *
	 * immediate goal:
	 *   Save the shadow registers that need to be saved to
	 *   the exception frame.
	 */
	stcr	TMP, SR3	/* free up TMP, TMP2, TMP3 */
d2767 1
a2767 1

d2769 10
a2778 8
	ldcr	TMP,  EPSR
	st	TMP,  r31,  REG_OFF(EF_EPSR)
	ldcr	TMP2, EXIP
	/* if the instruction was NOT in the delay slot, ignore ENIP */
	bb0.n	0,    TMP2, 1f
	 st	TMP2, r31,  REG_OFF(EF_EXIP)
	ldcr	TMP3, ENIP
	st	TMP3, r31,  REG_OFF(EF_ENIP)
d2780 7
a2786 5

	/* get and store the cpu number */
	extu	TMP,  FLAGS,  FLAG_CPU_FIELD_WIDTH<0>	/* TMP = cpu# */
	st	TMP,  r31,  REG_OFF(EF_CPU)

d2790 101
a2890 95
	ldcr	TMP,  ISR
	ldcr	TMP2, ILAR
	ldcr	TMP3, IPAR
	st	TMP,  r31,  REG_OFF(EF_ISR)
	st	TMP2, r31,  REG_OFF(EF_ILAR)
	st	TMP3, r31,  REG_OFF(EF_IPAR)
	ldcr	TMP,  ISAP
	ldcr	TMP2, IUAP
	st	TMP,  r31,  REG_OFF(EF_ISAP)
	st	TMP2, r31,  REG_OFF(EF_IUAP)
	ldcr	TMP,  DSR
	ldcr	TMP2, DLAR
	ldcr	TMP3, DPAR
	st	TMP,  r31,  REG_OFF(EF_DSR)
	st	TMP2, r31,  REG_OFF(EF_DLAR)
	st	TMP3, r31,  REG_OFF(EF_DPAR)
	ldcr	TMP,  DSAP
	ldcr	TMP2, DUAP
	st	TMP,  r31,  REG_OFF(EF_DSAP)
	st	TMP2, r31,  REG_OFF(EF_DUAP)

	ldcr	r1,   SR2
	jmp	r1

ASLOCAL(m88110_setup_phase_two)
	/*
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: free
	 * SR3: saved TMP
	 * r1:  return address to calling exception handler
	 * TMP: possibly revised SSBR
	 * TMP2: free
	 * TMP3: free
	 * FLAGS: CPU status flags
	 * r31: our exception frame
	 * Valid in the exception frame:
	 *   Exception-time r1, r31, FLAGS.
	 *   Exception-time TMP2, TMP3.
	 *   Exception-time espr, enip, exip.
	 *   Exception number (EF_VECTOR).
	 *   Dmt0
	 *   Other data pipeline control registers, if appropriate.
	 *   FPU control registers, if appropriate.
	 *   Exception SR3, if appropriate.
	 *
	 * immediate goal:
	 *   restore the system to the exception-time state (except SR3 will
	 *   be OUR stack pointer) so that we may resart the FPU.
	 */

	RESTORE_TMP2	/* done with extra temp regs */
	RESTORE_TMP3	/* done with extra temp regs */

	ldcr	TMP,  PSR
	clr	TMP,  TMP,  1<PSR_FPU_DISABLE_BIT>	/* enable the FPU */
	clr	TMP,  TMP,  1<PSR_SHADOW_FREEZE_BIT>	/* and shadowing */
	stcr	TMP,  EPSR

	or.u	TMP,  r0,   hi16(_ASM_LABEL(m88110_fpu_enable))
	or	TMP,  TMP,  lo16(_ASM_LABEL(m88110_fpu_enable))
	stcr	TMP,  EXIP	/* jump to here m88110_fpu_enable */
	addu	TMP,  TMP,  4
	stcr	TMP,  ENIP	/* and then continue after that */

	set	FLAGS, FLAGS, 1<FLAG_ENABLING_FPU>
	xcr	FLAGS, FLAGS, SR1
	st	r1,   r31,  REG_OFF(EF_RET)	/* save the return address */
	ld	r1,   r31,  GENREG_OFF(1)	/* get original r1 */

	ldcr	TMP, SR3
	stcr	r31, SR3	/* TMP now restored. R31 now saved in SR3 */
	ld	r31,  r31,  GENREG_OFF(31)	/* get original r31 */

	/*
	 * SR1: CPU flags
	 * SR2: free
	 * SR3: pointer to our exception frame (our stack pointer)
	 * r1 through r31: original exception-time values
	 *
	 * Valid in the exception frame:
	 *   Exception-time FLAGS.
	 *   Exception-time espr, sfip, enip, exip.
	 *   Exception number (EF_VECTOR).
	 *   Dmt0
	 *   Other data pipeline control registers, if appropriate.
	 *   FPU control registers, if appropriate.
	 *   Exception SR3, if appropriate.
	 * Held temporarily in the exception frame:
	 *   Return address to the calling exception handler.
	 *
	 * immediate goal:
	 *   Do an RTE to restart the fpu and jump to "m88110_fpu_enable"
	 *   Another exception (or exceptions) may be raised in
	 *   this, which is why FLAG_ENABLING_FPU is set in SR1.
	 */
d2892 3
a2894 3
	RTE	/* jumps to "m88110_fpu_enable" on the next line to enable the FPU. */

ASLOCAL(m88110_fpu_enable)
d2897 11
a2907 12
	/* Now that EFRZ is cleared, we can clear these */
	stcr	r0, ISR				/* Clear ISR */
	stcr	r0, ILAR			/* Clear ILAR */
	stcr	r0, IPAR			/* Clear IPAR */
	stcr	r0, DSR				/* Clear DSR */
	stcr	r0, DLAR			/* Clear DLAR */
	stcr	r0, DPAR			/* Clear DPAR */
	xcr	TMP,  TMP,  SR3			/* get E.F. pointer */
	st	r30,  TMP,  GENREG_OFF(30)	/* save previous r30, r31 */
	st	r31,  TMP,  GENREG_OFF(31)	/* save previous r30, r31 */
	or	r31,  TMP,  r0			/* transfer E.F. pointer */
	ld	TMP,  r31,  REG_OFF(EF_SR3)	/* get previous SR3 */
d2910 3
a2912 3
	xcr	FLAGS,FLAGS,SR1
	clr	FLAGS,FLAGS,1<FLAG_ENABLING_FPU>
	xcr	FLAGS,FLAGS,SR1
d2914 1
a2914 1
	xcr	TMP,  TMP,  SR3	/* replace TMP, SR3 */
d2917 15
a2931 30
	st	r0 ,  r31,  GENREG_OFF(0)
	st	r1 ,  r31,  GENREG_OFF(1)
	st	r2 ,  r31,  GENREG_OFF(2)
	st	r3 ,  r31,  GENREG_OFF(3)
	st	r4 ,  r31,  GENREG_OFF(4)
	st	r5 ,  r31,  GENREG_OFF(5)
	st	r6 ,  r31,  GENREG_OFF(6)
	st	r7 ,  r31,  GENREG_OFF(7)
	st	r8 ,  r31,  GENREG_OFF(8)
	st	r9 ,  r31,  GENREG_OFF(9)
	st	r10,  r31,  GENREG_OFF(10)
	st	r11,  r31,  GENREG_OFF(11)
	st	r12,  r31,  GENREG_OFF(12)
	st	r13,  r31,  GENREG_OFF(13)
	st	r14,  r31,  GENREG_OFF(14)
	st	r15,  r31,  GENREG_OFF(15)
	st	r16,  r31,  GENREG_OFF(16)
	st	r17,  r31,  GENREG_OFF(17)
	st	r18,  r31,  GENREG_OFF(18)
	st	r19,  r31,  GENREG_OFF(19)
	st	r20,  r31,  GENREG_OFF(20)
	st	r21,  r31,  GENREG_OFF(21)
	st	r22,  r31,  GENREG_OFF(22)
	st	r23,  r31,  GENREG_OFF(23)
	st	r24,  r31,  GENREG_OFF(24)
	st	r25,  r31,  GENREG_OFF(25)
	st	r26,  r31,  GENREG_OFF(26)
	st	r27,  r31,  GENREG_OFF(27)
	st	r28,  r31,  GENREG_OFF(28)
	st	r29,  r31,  GENREG_OFF(29)
d2934 36
a2969 38
	or.u	r20,  r0,   hi16(0x12345678)
	or	r20,  r20,  lo16(0x12345678)
	st	r20,  r31,  GENREG_OFF(0)
#endif

	/* get and save IPL */
	bsr.n	_C_LABEL(getipl)
	 subu	r31, r31, 32
	addu	r31, r31, 32
	st	r2, r31, REG_OFF(EF_MASK)

	/*
	 * SR1: free
	 * SR2: free
	 * SR3: previous exception-time SR3
	 * r1: return address to the calling exception handler
	 * r2 through r30: free
	 * r31: our exception frame
	 *
	 * Valid in the exception frame:
	 *   Exception-time r0 through r31.
	 *   Exception-time FLAGS.
	 *   Exception-time espr, enip, exip.
	 *   Exception number (EF_VECTOR).
	 *   DSR
	 *   Other data pipeline control registers, if appropriate.
	 *   FPU control registers, if appropriate.
	 *   Exception SR3, if appropriate.
	 *
	 * immediate goal:
	 *   Pick up a stack if we came in from user mode.
	 *   Put a copy of the exception frame pointer into r30
	 *   Bump the stack a doubleword and write the exception frame pointer.
	 *   If not an interrupt exception, turn on interrupts and service any
	 *     outstanding data access exceptions.
	 *   Return to calling exception handler to service the exception.
	 */

d2974 21
a2994 7
	or	r30,  r0,   r31		/* get a copy of the e.f. pointer */
	ld	r2,   r31,  REG_OFF(EF_EPSR)
	bb1	PSR_SUPERVISOR_MODE_BIT, r2, 1f	/* if in kernel mode */

	or.u	r31,  r0,   hi16(_ASM_LABEL(kstack))
	ld	r31,  r31,  lo16(_ASM_LABEL(kstack))
	addu	r31,  r31,  USIZE		/* point at proper end */
d2996 10
a3005 2

	/*
d3009 4
a3012 4
	subu	r31,  r31,  8	/* make some breathing space */
	st	r30,  r31,  0	/* store frame pointer on the stack */
#ifdef DDB
	st	r30,  r31,  4	/* store it again for the debugger */
d3015 18
a3032 18
	ld	r2,   r30,  REG_OFF(EF_VECTOR)
	bcnd.n	eq0,  r2,   8f
	 ld	r14,  r30,  REG_OFF(EF_RET)	/* load return value XXX!!! */
	cmp	r3,   r2,   1	/* is an interrupt? */
	bb1.n	eq,   r3,   8f

#ifdef DDB
	 cmp	r3,   r2,   130	/* DDB break exception */
	bb1.n	eq,   r3,   8f

	 cmp	r3,   r2,   132	/* DDB entry exception */
	bb1.n	eq,   r3,   8f
#endif

	/* turn interrupts back on */
	 ldcr	r2,   PSR
	clr	r2,   r2,   1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r2,   PSR
d3034 6
d3041 3
a3043 2
8:
	jmp	r14		/* loaded above */
d3045 19
d3065 4
a3068 4
	.align 8		/* needs align 8 for ld.d/st.d */
ASLOCAL(save_frame)
	space SIZEOF_EF
#endif	/* M88110 */
@


1.7
log
@Added vme bus device drivers. MVME328, MVME376, MVME332
@
text
@d1 1
a1 1
/*	$OpenBSD: eh.S,v 1.6 1999/02/09 06:36:28 smurph Exp $	*/
d35 5
a39 5
 * 		should be p->p_addr+UPAGES. (p_addr
 *			is pointing to user struct and swapin is
 *			making sure it is updated)
 *	Whatever is _kstack, its usage in this file should be
 *	revisited.
d58 1
a58 1
 * ;			   jfriedl@@rna.ncl.omron.co.jp		       ;
d117 1
a117 1
 * 	Each process has a stack in kernel space (called the "kernel stack",
d160 1
a160 1
 *	The manual [section 6.4.3.4] gives only minor mention to this
d221 1
a221 1
#include <machine/trap.h>        	/* for T_ defines */
d230 4
a233 4
 * 	     time when an exception is raised until just after the FPU
 * 	     has been restarted.  This does not necessarly conflict with
 *	     the general registers (though it can if you're not careful)
 * 	     and so we can use a spot later used to save a general register.
d237 2
a238 2
#define EF_SR3			(EF_R0 + 5)
#define EF_FLAGS		EF_MODE
d240 1
a240 1
#define FLAG_FROM_KERNEL	8	/* this should be in asm.h */
d242 2
a243 4
#define INTSTACK		0	/* To make interupts use their own stack */

	text
	align 8
d253 1
a253 1
 ** 	LABEL(foo_handler)
d260 9
a268 9
 **	NAME - 	String for debugging (more info later)
 **	NUM  - 	The exception number [see the manual, Table 6-1]
 **	BIT  - 	Bit to check in eh_debug for debugging (more info later)
 **	SSBR_STUFF -
 **		If the exception might leave some bits in the SSBR set,
 **		this should indicate how they are cleared.
 **	FLAG_PRECHECK -
 **		This is for the data access exception only. See it for
 **		more info.
d277 60
a336 45
/* This define can replace the xcr instruction XXX smurph */
#define XCR(DR, SR, CR)			; \
		stcr	r13, 	SR0	; \
		or      r13, r0, SR     ; \
                ldcr	DR, CR		; \
		stcr	r13, CR		; \
		ldcr	r13, SR0

/* This define can be used to debug sub routine returns XXX smurph*/
#define STORE_R1(varname)					; \
		stcr	r13, 	SR0	/* r13 now free */	; \
		/* save r1 to memory location varname */	; \
		or.u	r13, r0,  hi16(varname)			; \
		st	r1,  r13, lo16(varname)			; \
		ldcr	r13, SR0	/* retore r13   */	

#define PREP(NAME, NUM, BIT, SSBR_STUFF, FLAG_PRECHECK)		; \
		xcr FLAGS, FLAGS, SR1			; \
		FLAG_PRECHECK					; \
		 						; \
		/* the bsr later clobbers r1, so save now */	; \
		stcr	r1, SR2	/* r1 now free */		; \
		/* set or clear the FLAG_FROM_KERNEL bit */	; \
		ldcr	r1, EPSR				; \
		bb0.n	PSR_SUPERVISOR_MODE_BIT, r1, 1f		; \
		clr	FLAGS, FLAGS, 1<FLAG_FROM_KERNEL>	; \
		set	FLAGS, FLAGS, 1<FLAG_FROM_KERNEL>	; \
								; \
		/* get a stack (exception frame) */		; \
		1:	bsr	setup_phase_one			; \
								; \
		/* TMP2 now free -- use to set EF_VECTOR */	; \
		or	TMP2, r0, NUM				; \
		st	TMP2, r31, REG_OFF(EF_VECTOR)		; \
								; \
		/* Clear any bits in the SSBR (held in TMP) */	; \
		/* SSBR_STUFF may be empty, though.         */	; \
		SSBR_STUFF					; \
								; \
		/* call setup_phase_two to restart the FPU  */  ; \
		/* and to save all general registers.	    */ 	; \
		bsr	setup_phase_two				; \
								; \
		/* All general regs free -- do any debugging */	; \
		PREP_DEBUG(BIT, NAME)
d339 3
a341 3
#define No_SSBR_Stuff		/* empty */
#define Clear_SSBR_Dest		bsr clear_dest_ssbr_bit
#define No_Precheck		/* empty */
d343 3
a345 1
	bb1.n   FLAG_IGNORE_DATA_EXCEPTION, FLAGS, ignore_data_exception
d348 51
a398 51
	/*
	 * If we allow debugging, there is a variable "eh_debug"
	 * in which there is a bit for each exception.  If the bit
	 * is set for an exception, debugging information is printed
	 * about that exception whenever it occurs.
	 *
	 * The bits are defined in "asm.h"
	 */
	LABEL(_eh_debug) 	word 0x00000000

	/*
	 * additional pre-servicing preparation to be done when
	 * debugging... check eh_debug and make the call if
	 * need be.
	 */
	#define PREP_DEBUG(DebugNumber, Name)  \
		or.u	r2, r0, hi16(_eh_debug)		; \
		ld  	r3, r2, lo16(_eh_debug)		; \
		bb0	DebugNumber, r3, 4f		; \
		/* call MY_info(ef,thread,flags,kind)*/ ; \
		or	r2, r30, r0			; \
		ldcr	r3, SR0				; \
		ldcr	r4, SR1				; \
		or.u	r5, r0, hi16(2f)		; \
		or	r5, r5, lo16(2f)		; \
		bsr.n	_MY_info			; \
		subu	r31, r31, 40			; \
		br.n	4f				; \
		addu	r31, r31, 40			; \
		data					; \
	     2: string Name				; \
		byte 0					; \
		align 4					; \
		text					; \
	     4:


	/*
	 * Post-servicing work to be done.
	 * When debugging, check "eh_debug" and call the
	 * debug routined if neeed be.
	 *
	 * Then, return from the interrupt handler.
	 */
	#define DONE(DebugNumber)  \
		or.u	r2, r0, hi16(_eh_debug)		; \
		ld  	r3, r2, lo16(_eh_debug)		; \
		bb0	DebugNumber, r3, 2f		; \
		ldcr	r4, SR1				; \
		CALL(_MY_info_done, r31, r4)		; \
		2: br	return_from_exception_handler
d400 6
a405 6
	/*
	 * If not debugging, then no debug-prep to do.
	 * Also, when you're done, you're done!	(no debug check).
	 */
	#define PREP_DEBUG(bit, name)
	#define DONE(num)		br return_from_exception_handler
d415 3
a417 3
	PREP("unknown", 0, DEBUG_UNKNOWN_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_trap, T_UNKNOWNFLT, r30)
	DONE(DEBUG_UNKNOWN_BIT)
d421 5
a425 3
	PREP("interrupt", 1, DEBUG_INTERRUPT_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_ext_int, 1, r30)
	DONE(DEBUG_INTERRUPT_BIT)
d429 3
a431 17
	PREP("inst", 2, DEBUG_INSTRUCTION_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_trap, T_INSTFLT, r30)
#if 0
	/* done in trap now */
	/*
	 * Now, to retry the instruction.
	 * Copy the SNIP to the SFIP, clearing the E bit.
	 * Copy the SXIP to the SNIP, clearing the E bit.
	 */
	ld	r1, r30, REG_OFF(EF_SNIP)
	ld	r2, r30, REG_OFF(EF_SXIP)
	clr	r1, r1, 1<RTE_ERROR_BIT>
	clr	r2, r2, 1<RTE_ERROR_BIT>
	st	r1, r30, REG_OFF(EF_SFIP)
	st	r2, r30, REG_OFF(EF_SNIP)
#endif /* 0 */
	DONE(DEBUG_INSTRUCTION_BIT)
d438 2
a439 2
	PREP("data", 3, DEBUG_DATA_BIT, No_SSBR_Stuff, Data_Precheck)
	DONE(DEBUG_DATA_BIT)
d443 3
a445 3
	PREP("misalign", 4, DEBUG_MISALIGN_BIT, Clear_SSBR_Dest, No_Precheck)
	CALL(_trap, T_MISALGNFLT, r30)
	DONE(DEBUG_MISALIGN_BIT)
d449 3
a451 3
	PREP("unimp", 5, DEBUG_UNIMPLEMENTED_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_trap, T_ILLFLT, r30)
	DONE(DEBUG_UNIMPLEMENTED_BIT)
d459 8
a466 8
	stcr    r1, SR2 	/* hold r1 for a moment */
	ldcr    r1, SXIP	/* look at the sxip... valid bit set? */
	bb1.n   RTE_VALID_BIT, r1, 1f /*skip over return if a valid exception*/
	ldcr    r1, SR2 	/* restore r1 */
	RTE
    1:  PREP("privilege", 6, DEBUG_PRIVILEGE_BIT, Clear_SSBR_Dest, No_Precheck)
	CALL(_trap, T_PRIVINFLT, r30)
	DONE(DEBUG_PRIVILEGE_BIT)
d473 3
a475 3
	PREP("bounds", 7, DEBUG_BOUNDS_BIT, Clear_SSBR_Dest, No_Precheck)
	CALL(_trap, T_BNDFLT, r30)
	DONE(DEBUG_BOUNDS_BIT)
d479 3
a481 3
	PREP("divide", 8, DEBUG_DIVIDE_BIT, Clear_SSBR_Dest, No_Precheck)
	CALL(_trap, T_ZERODIV, r30)
	DONE(DEBUG_DIVIDE_BIT)
d485 3
a487 3
	PREP("overflow", 9, DEBUG_OVERFLOW_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_trap, T_OVFFLT, r30)
	DONE(DEBUG_OVERFLOW_BIT)
d492 3
a494 3
	PREP("FPU precise", 114, DEBUG_FPp_BIT, FPp_SSBR_STUFF, No_Precheck)
	CALL(_Xfp_precise, r0, r30) /* call fp_precise(??, exception_frame)*/
	DONE(DEBUG_FPp_BIT)
d499 3
a501 3
	PREP("FPU imprecise", 115, DEBUG_FPi_BIT, FPi_SSBR_STUFF, No_Precheck)
	CALL(_Xfp_imprecise, r0, r30) /*call fp_imprecise(??,exception_frame)*/
	DONE(DEBUG_FPi_BIT)
d505 4
a508 4
	PREP("syscall", 128, DEBUG_SYSCALL_BIT, No_SSBR_Stuff, No_Precheck)
	ld	r13, r30, GENREG_OFF(13)
	CALL(_syscall, r13, r30) /* system call no. is in r13 */
	DONE(DEBUG_SYSCALL_BIT)
d512 4
a515 4
	PREP("bugsyscall", 496, DEBUG_BUGCALL_BIT, No_SSBR_Stuff, No_Precheck)
	ld	r9,  r30, GENREG_OFF(9)
	CALL(_bugsyscall, r9, r30)	/* system call no. is in r9 */
	DONE(DEBUG_SYSCALL_BIT)
d518 3
a520 3
	PREP("sigsys", 0, DEBUG_SIGSYS_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_trap, T_SIGSYS, r30)
	DONE(DEBUG_SIGSYS_BIT)
d523 3
a525 3
	PREP("sigtrap", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_trap, T_SIGTRAP, r30)
	DONE(DEBUG_SIGTRAP_BIT)
d528 3
a530 3
	PREP("sigtrap", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_trap, T_STEPBPT, r30)
	DONE(DEBUG_SIGTRAP_BIT)
d533 3
a535 3
	PREP("sigtrap", 0, DEBUG_SIGTRAP_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_trap, T_USERBPT, r30)
	DONE(DEBUG_SIGTRAP_BIT)
d539 3
a541 3
	PREP("break", 130, DEBUG_BREAK_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_trap, T_KDB_BREAK, r30)
	DONE(DEBUG_BREAK_BIT)
d543 3
a545 3
	PREP("trace", 131, DEBUG_TRACE_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_trap, T_KDB_TRACE, r30)
	DONE(DEBUG_TRACE_BIT)
d548 3
a550 3
	PREP("kdb", 132, DEBUG_KDB_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_trap, T_KDB_ENTRY, r30)
	DONE(DEBUG_KDB_BIT)
d554 3
a556 3
	PREP("break", 130, DEBUG_BREAK_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_trap, T_UNKNOWNFLT, r30)
	DONE(DEBUG_BREAK_BIT)
d558 3
a560 3
	PREP("trace", 131, DEBUG_TRACE_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_trap, T_UNKNOWNFLT, r30)
	DONE(DEBUG_TRACE_BIT)
d562 4
a565 5
	PREP("unknown", 132, DEBUG_UNKNOWN_BIT, No_SSBR_Stuff, No_Precheck)
	CALL(_trap, T_UNKNOWNFLT, r30)
	DONE(DEBUG_KDB_BIT)
#endif	/* DDB */

d583 2
a584 2
        or.u	r31, r0,  hi16(_intstack_end)
        or	r31, r31, lo16(_intstack_end)
d587 8
a594 8
        or.u	r27, r0,  hi16(_intstack)
        or	r27, r27, lo16(_intstack)
   1:	cmp	r28, r27, r31
	bb1      ge, r28,  2f   /* branch if at the end of the stack */
	st	 r0,  r0, r27
	br.n     1b
	addu    r27, r27,   4   /* bump up */
   2:   /* stack has been cleared */
d596 1
a596 1
	/* ensure that stack is 8-byte aligned */
d599 1
a599 1
	/* create exception frame on stack */
d602 1
a602 1
	/* save old R31 and other R registers */
d618 4
a621 2

	/* save shadow registers (are OLD, though) */
d624 4
a629 2
	ldcr	r10, SNIP
	st	r10, r31, REG_OFF(EF_SNIP)
d632 1
a632 3
	ldcr	r10, EPSR
	st	r10, r31, REG_OFF(EF_EPSR)

a638 1

d641 1
a641 1
	tb1	0, r0, 0
d643 1
a643 1
	st	r11, r31, REG_OFF(EF_DMD1)
d653 1
a653 4

	ldcr	r10, SR1
	st	r10, r31, REG_OFF(EF_MODE)

d665 11
a675 2
	stcr	r0,  SSBR  /* won't want shadow bits bothering us later */

d679 1
a679 1
        ldcr    r10, PSR
a681 1
	
d688 5
a692 5
        subu    r31, r31, 0x10 /* make some breathing space */
        st      r30, r31, 0x0c /* store frame pointer on the st */
        st      r30, r31, 0x08 /* store again for the debugger to recognize */
	or.u    r20,  r0, hi16(0x87654321)
	or      r20, r20, lo16(0x87654321)
d700 1
a700 1
   	clr  r1, r1, 1<PSR_INTERRUPT_DISABLE_BIT>
d705 1
a705 9
	/* never returns*/

/*
 *----------------------------------------------------------------------------
 *----------------------------------------------------------------------------
 *----------------------------------------------------------------------------
 */

/*--------------------------------------------------------------------------*/
d729 2
a730 2
        or.u	r31, r0,  hi16(_intstack_end)
        or	r31, r31, lo16(_intstack_end)
d733 8
a740 8
        or.u	r27, r0,  hi16(_intstack)
        or	r27, r27, lo16(_intstack)
   1:	cmp	r28, r27, r31
	bb1      ge, r28,  2f   /* branch if at the end of the stack */
	st	 r0,  r0, r27
	br.n     1b
	addu    r27, r27,   4   /* bump up */
   2:   /* stack has been cleared */
d743 1
a743 1
        clr     r31, r31, 3<0>  /* round down to 8-byte boundary */
d746 1
a746 1
        subu    r31, r31, SIZEOF_EF             /* r31 now our E.F. */
d749 14
a762 14
        st.d    r0 , r31, GENREG_OFF(0)
        st.d    r2 , r31, GENREG_OFF(2)
        st.d    r4 , r31, GENREG_OFF(4)
        st.d    r6 , r31, GENREG_OFF(6)
        st.d    r8 , r31, GENREG_OFF(8)
        st.d    r10, r31, GENREG_OFF(10)
        st.d    r12, r31, GENREG_OFF(12)
        st.d    r14, r31, GENREG_OFF(14)
        st.d    r16, r31, GENREG_OFF(16)
        st.d    r18, r31, GENREG_OFF(18)
        st.d    r20, r31, GENREG_OFF(20)
        st.d    r22, r31, GENREG_OFF(22)
        st.d    r24, r31, GENREG_OFF(24)
        st      r30, r31, GENREG_OFF(30)
d766 2
d770 4
a775 2
	ldcr	r10, SNIP
	st	r10, r31, REG_OFF(EF_SNIP)
d778 1
a778 2
	ldcr	r10, EPSR
	st	r10, r31, REG_OFF(EF_EPSR)
d789 1
a789 1
	tb1	0, r0, 0
d791 1
a791 1
	st	r11, r31, REG_OFF(EF_DMD1)
a801 3
	ldcr	r10, SR1
	st	r10, r31, REG_OFF(EF_MODE)

a812 2
	stcr	r0,  SSBR  /* won't want shadow bits bothering us later */

d819 1
a819 1
	
d826 5
a830 5
        subu    r31, r31, 0x10 /* make some breathing space */
        st      r30, r31, 0x0c /* store frame pointer on the st */
        st      r30, r31, 0x08 /* store again for the debugger to recognize */
	or.u    r20,  r0, hi16(0x87654321)
	or      r20, r20, lo16(0x87654321)
d836 5
a840 5
        /* TURN INTERUPTS back on */
        ldcr r1, PSR
   	clr  r1, r1, 1<PSR_INTERRUPT_DISABLE_BIT>
        stcr r1, PSR
        FLUSH_PIPELINE
d843 1
a843 5
	/* never returns*/

/*
 *----------------------------------------------------------------------------
*/
d851 1
a851 1
	*  SR1: previous FLAGS reg			       *
d856 1
a856 1
 	xcr	FLAGS, FLAGS, SR1	/* replace SR1, FLAGS */
d870 3
a872 2
	or  	r2, r2, lo16(badaddr__return_nonzero + 2)
	stcr	r2, SNIP	/* Make it the next instruction to execute */
d874 29
a902 2
	stcr	r2, SFIP	/* and the next one after that, too. */
	stcr	r0, SSBR	/* make the scoreboard happy. */
d904 6
a909 1
 	/* the following jumps to "badaddr__return_nonzero" in below */
d934 4
a937 4
	/*
	 * Disable interrupts ... don't want a context switch while we're
	 * doing this! Also, save the old PSR in R8 to restore later.
	 */
d951 1
a951 1
	sub	r6, r3, 4
d953 1
a953 1
	stcr	r5, SR1
d959 2
a960 2
	bb1	0, r2, badaddr__return_nonzero
	bb1	1, r2, badaddr__return_nonzero
d967 1
a967 1
 	 *
d970 1
a970 1
	ld	r5, r2, 0
d972 2
a973 2
	br.n	badaddr__return
	or	r2, r0, r0	/* indicate a zero (address not bad) return.*/
d975 1
a975 1
    badaddr__maybe_halfword:
d977 2
a978 2
	sub	r6, r3, 2
	bcnd	ne0, r6, badaddr__maybe_byte
d981 1
a981 1
	bb1	0, r2, badaddr__return_nonzero
d984 1
a984 1
	ld.h	r5, r2, 0
d986 2
a987 2
	br.n	badaddr__return
	or	r2, r0, r0
d989 1
a989 1
    badaddr__maybe_byte:
d991 2
a992 2
	sub	r6, r3, 1
	bcnd	ne0, r6, badaddr__unknown_size
d994 1
a994 1
	ld.b	r5, r2, 0
d996 3
a998 3
	br.n	badaddr__return
	or	r2, r0, r0
    badaddr__unknown_size:
d1001 1
a1001 1
	  1: string "bad length (%d) to badaddr() from 0x%x\n\000"
d1003 7
a1009 7
	or.u	r2, r0, hi16(1b)
	or  	r2, r2, lo16(1b)
	or	r4, r0, r1
	bsr	_printf
	or.u	r2, r0, hi16(1b)
	or  	r2, r2, lo16(1b)
	bsr	_panic
d1014 1
a1014 1
	or	r2, r0, 1
d1018 3
a1020 3
	ldcr	r4, SR1
	clr	r4, r4, 1<FLAG_IGNORE_DATA_EXCEPTION>
	stcr	r4, SR1
d1030 2
a1031 3
	stcr	r8, PSR
	jmp  	r1

d1041 13
a1053 13
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread (if any, null if not)			*
	* SR1: saved copy of exception-time register now holding FLAGS	*
	* SR2: saved copy of exception-time r1				*
	* SR3: must be preserved .. may be the exception-time stack	*
	* r1: return address to calling exception handler		*
	* FLAGS: CPU status flags					*
	***************************************************		*
	* immediate goal:						*
	* 	Decide where we're going to put the exception frame.	*
	*	Might be at the end of R31, SR3, or the thread's	*
	*	pcb.	          					*
	\***************************************************************/
d1055 2
a1056 2
        /* Check if we are coming in from a FPU restart exception.
           If so, the pcb will be in SR3 */
d1058 1
a1058 2
	xcr	r1, r1, SR2
	/*xcr	r1, r1, SR2*/
d1064 1
a1064 2
	/*xcr	r1, r1, SR0*/
        /* are we coming in from user mode? If so, pick up thread pcb */
d1067 17
a1083 17
        /* Interrupt in kernel mode, not FPU restart */
    _LABEL(already_on_kernel_stack)
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread (if any, null if not)			*
	* SR1: saved copy of exception-time register now holding FLAGS	*
	* SR2: return address to the calling exception handler		*
	* SR3: must be preserved; may be important for other exceptions	*
	* FLAGS: CPU status flags					*
	***************************************************		*
	* immediate goal:						*
	*	We're already on the kernel stack, but not having	*
	*	needed to use SR3. We can just make room on the		*
	* 	stack (r31) for our exception frame.			*
	\***************************************************************/
	subu	r31, r31, SIZEOF_EF	      /* r31 now our E.F. */
	st	FLAGS, r31, REG_OFF(EF_FLAGS) /* save flags */
	st	r1, r31, GENREG_OFF(1)	      /* save prev. r1 (now r1 free)*/
d1085 2
a1086 2
	ldcr	r1, SR3				/* save previous SR3 */
	st	r1, r31, REG_OFF(EF_SR3)
d1088 1
a1088 1
	addu	r1, r31, SIZEOF_EF		/* save previous r31 */
d1090 1
a1090 1
	st	r1, r31, GENREG_OFF(31)
d1093 39
a1131 39
    _LABEL(use_SR3_pcb)
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread (if any, null if not)			*
	* SR1: saved copy of exception-time register now holding FLAGS	*
	* SR2: return address to the calling exception handler		*
	* SR3: must be preserved; exception-time stack pointer		*
	* FLAGS: CPU status flags					*
	***************************************************		*
	* immediate goal:						*
	*	An exception occured while enabling the FPU. Since r31	*
	*	is the user's r31 while enabling the FPU, we had put	*
	*	our pcb pointer into SR3, so make room from       	*
	*	there for our stack pointer.				*
	*       We need to check if SR3 is the old stack pointer or the *
        *       pointer off to the user pcb. If it pointing to the user *
        *       pcb, we need to pick up the kernel stack. Otherwise     *
        *       we need to allocate a frame upon it.                    *
        *       We look at the EPSR to see if it was from user mode     *
        *       Unfortunately, we have no registers free at the moment  *
        *       But we know register 0 in the pcb frame will always be  *
        *       zero, so we can use it as scratch storage.              *
        *                                                               *
        *                                                               *
	\***************************************************************/
	xcr	r30, r30, SR3			/* r30 = old exception frame */
        st      r1,  r30, GENREG_OFF(0)         /* free up r1 */
        ld      r1,  r30, REG_OFF(EF_EPSR)      /* get back the epsr */
        bb0.n     PSR_SUPERVISOR_MODE_BIT, r1, 1f /* if user mode */
        ld      r1,  r30, GENREG_OFF(0)         /* restore r1 */
        /* we were in kernel mode - dump frame upon the stack */
	st      r0,  r30, GENREG_OFF(0)         /* repair old frame */
	subu	r30, r30, SIZEOF_EF		/* r30 now our E.F. */
	st	FLAGS, r30, REG_OFF(EF_FLAGS)	/* save flags */
	st	r1, r30, GENREG_OFF(1)	    /* save prev. r1 (now r1 free) */

	st	r31, r30, GENREG_OFF(31)	/* save previous r31 */
	or	r31, r0, r30			/* make r31 our pointer. */
	addu	r30, r30, SIZEOF_EF		/* r30 now has previous SR3 */
	st	r30, r31, REG_OFF(EF_SR3)	/* save previous SR3 */
d1133 16
a1148 16
	xcr	r30, r30, SR3			/* restore r30 */
       1:
         /* we took an exception while restarting the FPU from user space.
            Consequently, we never picked up a stack. Do so now.
	    R1 is currently free (saved in the exception frame pointed at by
	    r30) */
	or.u	r1, r0, hi16(_kstack)
	ld	r1, r1, lo16(_kstack)
        addu	r1, r1, USIZE-SIZEOF_EF
	st	FLAGS, r1, REG_OFF(EF_FLAGS)    /* store flags */
	st	r31, r1,   GENREG_OFF(31)       /* store r31 - now free */
        st      r30, r1,   REG_OFF(EF_SR3)      /* store old SR3 (pcb) */
     	or	r31, r1, r0 	/* make r31 our exception frame pointer */
	ld	r1,  r30, GENREG_OFF(0)         /* restore old r1 */
        st	r0,  r30, GENREG_OFF(0)         /* repair that frame */
	st	r1,  r31, GENREG_OFF(1)	   /* store r1 in its proper place */
d1150 1
a1150 1
	xcr	r30, r30, SR3			/* restore r30 */
d1152 43
a1194 43
    _LABEL(pickup_stack)
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread 						*
	* SR1: saved copy of exception-time register now holding FLAGS	*
	* SR2: return address to the calling exception handler		*
	* SR3: free							*
	* FLAGS: CPU status flags					*
	***************************************************		*
	* immediate goal:						*
	* 	Since we're servicing an exception from user mode, we	*
	*	know that SR3 is free.  We use it to free up a temp.	*
	*	register to be used in getting the thread's pcb         *
	\***************************************************************/
	stcr	r31, SR3		/* save previous r31 */

	/* switch to the thread's kernel stack. */
	or.u	r31, r0,  hi16(_curpcb)
	ld	r31, r31, lo16(_curpcb)
     	addu	r31, r31, PCB_USER_STATE	/* point to user save area */
	st	FLAGS, r31, REG_OFF(EF_FLAGS)	/* save flags */
	st	r1, r31, GENREG_OFF(1)		/* save prev. r1 (now r1 free)*/
	ldcr	r1, SR3				/* save previous r31 */
	st	r1, r31, GENREG_OFF(31)
	/*FALLTHROUGH */

    _LABEL(have_pcb)
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread 						*
	* SR1: saved copy of exception-time register now holding FLAGS	*
	* SR2: return address to the calling exception handler		*
	* SR3: free							*
	* r1:  free							*
	* FLAGS: CPU status flags					*
	* r31: our exception frame   					*
	*    Valid in the exception frame:				*
	*	Exception-time r1, r31, FLAGS.	 			*
	*	Exception SR3, if appropriate.				*
	***************************************************		*
	* immediate goal:						*
	* 	Save the shadow registers that need to be saved to	*
	*	the exception frame.					*
	\***************************************************************/
	stcr	TMP, SR3	/* free up TMP, TMP2, TMP3 */
d1198 5
a1202 2
	/* save some exception-time registers to the exception frame */
	ldcr	TMP, EPSR
d1204 63
a1266 8
	ldcr	TMP3, SNIP
	st	TMP, r31, REG_OFF(EF_EPSR)
	st	TMP2, r31, REG_OFF(EF_SFIP)
	st	TMP3, r31, REG_OFF(EF_SNIP)

	/*
	 * Save Pbus fault status register from data and inst CMMU.
	 */
d1268 2
a1269 8
	or.u	TMP, r0, hi16(CMMU_I)
	ld	TMP2, TMP, lo16(CMMU_I) + 0x108
	st	TMP2, r31, REG_OFF(EF_IPFSR)
	or.u	TMP, r0, hi16(CMMU_D)
	ld	TMP2, TMP, lo16(CMMU_D) + 0x108
	st	TMP2, r31, REG_OFF(EF_DPFSR)

	ldcr	TMP, SSBR
d1272 2
a1273 2
	st	TMP2, r31, REG_OFF(EF_SXIP)

d1275 13
a1287 13
	/*
	 * The following is a kludge so that
	 * a core file will have a copy of
	 * DMT0 so that 'sim' can display it
	 * correctly.
	 * After a data fault has been noticed,
	 * the real EF_DTM0 is cleared, so I need
	 * to throw this somewhere.
	 * There's no special reason I chose this
	 * register (FPIT)... it's just one of many
	 * for which it causes no pain to do this.
	 */
	st TMP3, r31, REG_OFF(EF_FPIT)
d1290 7
a1296 7
	/*
	 * The above shadow registers are obligatory for any and all
	 * exceptions.  Now, if the data access pipeline is not clear,
	 * we must save the DMx shadow registers, as well as clear
	 * the appropriate SSBR bits for the destination registers of
	 * loads or xmems.
	 */
d1298 1
a1298 1
	st	TMP3, r31, REG_OFF(EF_DMT0)
d1302 2
a1303 2
	st	TMP2, r31, REG_OFF(EF_DMT1)
	st	TMP3, r31, REG_OFF(EF_DMT2)
d1307 2
a1308 2
	st	TMP2, r31, REG_OFF(EF_DMA0)
	st	TMP3, r31, REG_OFF(EF_DMA1)
d1312 2
a1313 2
	st	TMP2, r31, REG_OFF(EF_DMA2)
	st	TMP3, r31, REG_OFF(EF_DMD0)
d1315 1
a1315 1
	tb1	0,r0,0
d1318 2
a1319 8
	st	TMP2, r31, REG_OFF(EF_DMD1)
	st	TMP3, r31, REG_OFF(EF_DMD2)

	/*
         *---------------------------------------------------------------
	 * need to clear "appropriate" bits in the SSBR before
	 * we restart the FPU
	 */
d1321 5
d1327 1
a1327 1
    _LABEL(check_DMT0)
d1330 1
a1330 1
	stcr	r0, DMT0 /* so an exception at fpu_enable doesn't see our DMT0*/
d1333 2
a1334 1
        _LABEL(do_DMT0)
d1337 1
a1337 1
	clr	TMP, TMP, TMP2
d1339 1
a1339 1
    _LABEL(check_DMT1)
d1344 2
a1345 1
        _LABEL(do_DMT1)
d1348 1
a1348 1
	clr	TMP, TMP, TMP2
d1350 1
a1350 1
    _LABEL(check_DMT2)
d1356 2
a1357 1
        _LABEL(do_DMT2_single)
d1361 2
a1362 1
	_LABEL(do_DMT2_double)
d1365 1
a1365 1
1:	clr	TMP, TMP, TMP2
d1367 21
a1387 21
    _LABEL(DMT_check_finished)
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread 						*
	* SR1: saved copy of exception-time register now holding FLAGS	*
	* SR2: return address to the calling exception handler		*
	* SR3: saved TMP						*
	* r1:  free							*
	* TMP: possibly revised SSBR					*
	* TMP2: free							*
	* TMP3: free							*
	* FLAGS: CPU status flags					*
	* r31: exception frame						*
	*    Valid in the exception frame:				*
	*	Exception-time r1, r31, FLAGS.	 			*
	*	Exception-time TMP2, TMP3.				*
	*	Exception-time espr, sfip, snip, sxip.			*
	*	Dmt0.							*
	*	Other data pipeline control registers, if appropriate.	*
	*	Exception SR3, if appropriate.				*
	\***************************************************************/
	ldcr	r1, SR2
d1393 11
a1403 11
    _LABEL(clear_FPi_ssbr_bit)
	/*
	 * Clear floatingpont-imprecise ssbr bits.
	 * Also, save appropriate FPU control registers to the E.F.
	 *
	 *  r1:  return address to calling exception handler
         *  TMP : (possibly) revised ssbr
         *  TMP2 : free
         *  TMP3 : free
	 */
 	fldcr	TMP2, FPSR
d1405 2
a1406 2
	st	TMP2, r31, REG_OFF(EF_FPSR)
	st	TMP3, r31, REG_OFF(EF_FPCR)
d1408 1
a1408 1
 	fldcr	TMP2, FPECR
d1410 2
a1411 7
	st	TMP2, r31, REG_OFF(EF_FPECR)
	st	TMP3, r31, REG_OFF(EF_FPRH)

	fldcr	TMP2, FPIT
 	fldcr	TMP3, FPRL
	st	TMP2, r31, REG_OFF(EF_FPIT)
	st	TMP3, r31, REG_OFF(EF_FPRL)
d1413 10
a1422 5
	/*
	 * We only need clear the bit in the SSBR for the
	 * 2nd reg of a double result [see section 6.8.5]
	 */
	#define FPIT_SIZE_BIT	10
d1425 2
a1426 2
	set	TMP2, TMP2, 1<6>  /* set width (width=2 will clear two bits) */
	clr	TMP, TMP, TMP2
d1428 2
a1429 2
       _LABEL(not_double_fpi)
	jmp	r1
d1436 41
a1476 39
    _LABEL(clear_FPp_ssbr_bit)
	/*
	 * Clear floating pont precise ssbr bits.
	 * Also, save appropriate FPU control registers to the E.F.
	 *
	 *  r1:  return address to calling exception handler
         *  TMP : (possibly) revised ssbr
         *  TMP2 : free
         *  TMP3 : free
	 */
 	fldcr	TMP2, FPSR
	fldcr	TMP3, FPCR
	st	TMP2, r31, REG_OFF(EF_FPSR)
	st	TMP3, r31, REG_OFF(EF_FPCR)

 	fldcr	TMP2, FPHS1
	fldcr	TMP3, FPHS2
	st	TMP2, r31, REG_OFF(EF_FPHS1)
	st	TMP3, r31, REG_OFF(EF_FPHS2)

 	fldcr	TMP2, FPLS1
	fldcr	TMP3, FPLS2
	st	TMP2, r31, REG_OFF(EF_FPLS1)
	st	TMP3, r31, REG_OFF(EF_FPLS2)

 	fldcr	TMP2, FPPT
	fldcr	TMP3, FPECR
	st	TMP2, r31, REG_OFF(EF_FPPT)
	st	TMP3, r31, REG_OFF(EF_FPECR)

	#define 	FPPT_SIZE_BIT	5
	bb1.n	FPPT_SIZE_BIT, TMP2, 1f
	extu	TMP3, TMP2, 5<0> /* get FP operation dest reg */
	br.n	2f
	set	TMP3, TMP3, 1<5> /* set size=1 -- clear one bit for "float" */
     1: set	TMP3, TMP3, 1<6> /* set size=2 -- clear two bit for "double" */
     2:
	clr	TMP, TMP, TMP3	/* clear bit(s) in ssbr. */
	jmp	r1
d1483 31
a1513 30
    _LABEL(clear_dest_ssbr_bit)
	/*
	 * There are various cases where an exception can leave the
	 * destination register's bit in the SB set.
	 * Examples:
	 *	misaligned or privilege exception on a LD or XMEM
	 *	DIV or DIVU by zero.
 	 *
 	 * I think that if the instruction is LD.D, then two bits must
	 * be cleared.
 	 *
	 * Even though there are a number of instructions/exception
	 * combinations that could fire this code up, it's only required
	 * to be run for the above cases.  However, I don't think it'll
	 * ever be a problem to run this in other cases (ST instructions,
	 * for example), so I don't bother checking.  If we had to check
	 * for every possible instruction, this code would be much larger.
 	 *
	 * The only checking, then, is to see if it's a LD.D or not.
	 *
	 * At the moment....
	 *  r1:  return address to calling exception handler
         *  TMP : (possibly) revised ssbr
         *  TMP2 : free
         *  TMP3 : free
	 */
	ldcr	TMP3, EPSR	/* going to check: user or system memory? */
	ldcr	TMP2, SXIP	/* get the instruction's address */
	bb1.n	PSR_SUPERVISOR_MODE_BIT, TMP3, 2f
	clr	TMP2, TMP2, 2<0> /* get rid of valid and error bits. */
d1515 1
a1515 1
    1:  /* user space load here */
d1517 6
a1522 6
	NOP
	ld.usr	TMP2, TMP2, r0		/* get the instruction itself */
	NOP
	NOP
	NOP
	br	3f
d1524 2
a1525 2
	br.n	3f
	ld.usr	TMP2, TMP2, r0		/* get the instruction itself */
d1528 2
a1529 2
    2:  /* system space load here */
	ld	TMP2, TMP2, r0		/* get the instruction itself */
d1531 46
a1576 39
    3:  /* now have the instruction..... */
	/*
	 * Now see if it's a double load
	 * There are three forms of double load [IMM16, scaled, unscaled],
	 * which can be checked by matching against two templates:
	 *			 -- 77776666555544443333222211110000 --
	 *	if (((instruction & 11111100000000000000000000000000) ==
	 *			    00010000000000000000000000000000) ;;
	 *	    ((instruction & 11111100000000001111110011100000) ==
	 *			    11110100000000000001000000000000))
	 *	{
	 *		It's a load double, so
	 *		clear two SSBR bits.
	 *	}
	 *	else
	 *	{
	 *		It's not a load double.
	 *		Must be a load single, xmem, or st
	 *		Thus, clear one SSBR bit.
	 *	}
	 */
	/* check the first pattern for ld.d */
	extu	TMP3, TMP2, 16<16>	/* get the upper 16 bits */
	mask	TMP3, TMP3, 0xFC00	/* apply the mask */
	cmp	TMP3, TMP3, 0x1000  /* if this is equal, it's a load double */
	bb1	eq,   TMP3, misaligned_double

	/* still could be -- check the second pattern for ld.d */
	/* look at the upper 16 bits first */
	extu	TMP3, TMP2, 16<16>  /* get the upper 16 bits */
	mask	TMP3, TMP3, 0xFC00  /* apply the mask */
	cmp	TMP3, TMP3, 0xF400  /* if equal, it might be a load double */
	bb1	ne,   TMP3, misaligned_single /* not equal, so must be single */

	/* now look at the lower 16 bits */
	extu	TMP3, TMP2, 16<0>    /* get the lower 16 bits */
	mask	TMP3, TMP3, 0xFCE0   /* apply the mask */
	cmp	TMP3, TMP3, 0x1000   /* if this is equal, it's a load double */
	bb1	eq,   TMP3, misaligned_double
d1578 2
a1579 11
      _LABEL(misaligned_single)
	extu	TMP2, TMP2, 5<21>	/* get the destination register */
	br.n	1f
        set	TMP2, TMP2, 1<5>	/* set size=1 */

      _LABEL(misaligned_double)
	extu	TMP2, TMP2, 5<21>  /* get the destination register */
        set	TMP2, TMP2, 1<6>   /* set size=2 -- clear two bit for "ld.d" */

     1: jmp.n	r1
	clr	TMP, TMP, TMP2	/* clear bit(s) in ssbr. */
d1586 31
a1616 30
  LABEL(setup_phase_two)
	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: saved return address to calling exception handler 	*
	* SR1: saved copy of exception-time register now holding FLAGS	*
	* SR2: free							*
	* SR3: saved TMP						*
	* r1:  return address to calling exception handler 		*
	* TMP: possibly revised SSBR					*
	* TMP2: free							*
	* TMP3: free							*
	* FLAGS: CPU status flags					*
	* r31: our exception frame					*
	*    Valid in the exception frame:				*
	*	Exception-time r1, r31, FLAGS.	 			*
	*	Exception-time TMP2, TMP3.				*
	*	Exception-time espr, sfip, snip, sxip.			*
	*	Exception number (EF_VECTOR).				*
	*	Dmt0							*
	*	Other data pipeline control registers, if appropriate.	*
	*	FPU control registers, if appropriate.			*
	*	Exception SR3, if appropriate.				*
	***************************************************		*
	* immediate goal:						*
	*	restore the system to the exception-time state (except	*
	* SR3 will be OUR stack pointer) so that we may resart the FPU.	*
	\***************************************************************/
	/*stcr	r1, SR0*/		/* save return address */
    	stcr	TMP, SSBR	/* done with SSBR, TMP now free */
	RESTORE_TMP2		/* done with extra temp regs */
	RESTORE_TMP3		/* done with extra temp regs */
d1618 1
a1618 1
	/* Get the current PSR and modify for the rte to enable the FPU */
d1620 11
a1630 11
	ldcr	TMP, PSR
	clr	TMP, TMP, 1<PSR_FPU_DISABLE_BIT>    /* enable the FPU */
        clr	TMP, TMP, 1<PSR_SHADOW_FREEZE_BIT>  /* also enable shadowing */
	stcr	TMP, EPSR

	/* the "+2" below is to set the VALID_BIT */
	or.u	TMP, r0, hi16(fpu_enable +2)
	or	TMP, TMP, lo16(fpu_enable +2)
	stcr	TMP, SNIP		/* jump to here fpu_enable */
	addu	TMP, TMP, 4
	stcr	TMP, SFIP		/* and then continue after that */
d1632 10
a1641 10
	ldcr	TMP, PSR
	or.u	TMP, TMP, 0x8000    /* set supervisor mode */
        and	TMP, TMP, 0xfff7    /* also enable shadowing */
	stcr	TMP, EPSR
	stcr	r0, SXIP	    /* clear valid bit */
	stcr	r0, SNIP	    /* clear valid bit */
	or.u	TMP, r0, hi16(fpu_enable)
	or	TMP, TMP, lo16(fpu_enable)
	or	TMP, TMP, 0x2 /* set the VALID_BIT and clear Exception bit */
	stcr	TMP, SFIP		/* jump to here fpu_enable */
a1642 48
	
	set	FLAGS, FLAGS, 1<FLAG_ENABLING_FPU> /* note what we're doing.*/
	xcr	FLAGS, FLAGS, SR1
	st	r1, r31, REG_OFF(EF_RET) /* save the return address */
	ld	r1, r31, GENREG_OFF(1)	 /* get original r1 */

	xcr	TMP, r31, SR3	/* TMP now restored. R31 now saved in SR3 */
	ld	r31, r31, GENREG_OFF(31) /* get original r31 */

	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread 						*
	* SR1: CPU flags						*
	* SR2: free							*
	* SR3: pointer to our exception frame (our stack pointer)	*
	* r1 through r31: original exception-time values		*
	*								*
	*    Valid in the exception frame:				*
	*	Exception-time FLAGS.	 				*
	*	Exception-time espr, sfip, snip, sxip.			*
	*	Exception number (EF_VECTOR).				*
	*	Dmt0							*
	*	Other data pipeline control registers, if appropriate.	*
	*	FPU control registers, if appropriate.			*
	*	Exception SR3, if appropriate.				*
	*   Held temporarly in the exception frame:			*
	*	Return address to the calling excption handler.		*
	***************************************************		*
	* immediate goal:						*
	*	Do an RTE to restart the fpu and jump to "fpu_enable"	*
	*	Another exception (or exceptions) may be raised in	*
	*	this, which is why FLAG_ENABLING_FPU is set in SR1.	*
	\***************************************************************/
	
	RTE	/* jumps to "fpu_enable" on the next line to enable the FPU. */

  _LABEL(fpu_enable)
	FLUSH_PIPELINE
	xcr	TMP, TMP, SR3		 /* get E.F. pointer */
	st.d	r30, TMP, GENREG_OFF(30) /* save previous r30, r31 */
	or	r31, TMP, r0		 /* transfer E.F. pointer to r31 */
	ld	TMP, r31, REG_OFF(EF_SR3)/* get previous SR3; maybe important*/

	/* make sure that the FLAG_ENABLING_FPU bit is off */
	xcr	FLAGS, FLAGS, SR1
	clr	FLAGS, FLAGS, 1<FLAG_ENABLING_FPU>
	xcr	FLAGS, FLAGS, SR1

	xcr	TMP, TMP, SR3		 /* replace TMP, SR3 */
d1644 65
a1708 16
	/* now save all regs to the exception frame. */
	st.d	r0 , r31, GENREG_OFF(0)
	st.d	r2 , r31, GENREG_OFF(2)
	st.d	r4 , r31, GENREG_OFF(4)
	st.d	r6 , r31, GENREG_OFF(6)
	st.d	r8 , r31, GENREG_OFF(8)
	st.d	r10, r31, GENREG_OFF(10)
	st.d	r12, r31, GENREG_OFF(12)
	st.d	r14, r31, GENREG_OFF(14)
	st.d	r16, r31, GENREG_OFF(16)
	st.d	r18, r31, GENREG_OFF(18)
	st.d	r20, r31, GENREG_OFF(20)
	st.d	r22, r31, GENREG_OFF(22)
	st.d	r24, r31, GENREG_OFF(24)
	st.d	r26, r31, GENREG_OFF(26)
	st.d	r28, r31, GENREG_OFF(28)
d1710 5
a1714 36
	/* mark beginning of frame with notable value */
	or.u r20,  r0, hi16(0x12345678)
	or   r20, r20, lo16(0x12345678)
	st   r20, r31, GENREG_OFF(0)
#endif

	/***************** REGISTER STATUS BLOCK ***********************\
	* SR0: current thread 						*
	* SR1: free							*
	* SR2: free							*
	* SR3: previous exception-time SR3				*
	* r1: return address to the calling exception handler		*
	* r2 through r30: free						*
	* r31: our exception frame  					*
	*								*
	*    Valid in the exception frame:				*
	*	Exception-time r0 through r31.				*
	*	Exception-time FLAGS.	 				*
	*	Exception-time espr, sfip, snip, sxip.			*
	*	Exception number (EF_VECTOR).				*
	*	Dmt0							*
	*	Other data pipeline control registers, if appropriate.	*
	*	FPU control registers, if appropriate.			*
	*	Exception SR3, if appropriate.				*
	***************************************************		*
	* immediate goal:						*
        *	Pick up a stack if we came in from user mode. Put	*
        *       A copy of the exception frame pointer into r30          *
        *       bump the stack a doubleword and write the exception     *
        *       frame pointer.                                          *
	*	if not an interrupt exception,				*
	*	    Turn on interrupts and service any outstanding	*
	*	    data access exceptions.				*
	*	Return to calling exception handler to			*
	*	service the exception.					*
	\***************************************************************/
d1716 35
a1750 4
	/*
	 * If it's not the interrupt exception, enable interrupts and
	 * take care of any data access exceptions......
	 *
d1752 2
a1753 2
	 * If interrupt exception, switch to interrupt stack if not
	 * already there. Else, switch to kernel stack.
d1755 4
a1758 4
	 */
	or	r30, r0, r31              /* get a copy of the e.f. pointer */
        ld	r2,  r31, REG_OFF(EF_EPSR)
  	bb1	PSR_SUPERVISOR_MODE_BIT, r2, 1f  /* If in kernel mode */
d1761 7
a1767 7
	ld	r3,  r31, REG_OFF(EF_VECTOR)
	cmp	r3,  r3, 1		/* is interrupt ? */
	bb0	eq,  r3, 2f
	or.u	r31, r0,  hi16(_intstack_end)	/* swith to int stack */
	or	r31, r31, lo16(_intstack_end)
	br	3f
  2:
d1769 5
a1773 5
	or.u	r31, r0,  hi16(_kstack)
	ld	r31, r31, lo16(_kstack)
	addu	r31, r31, USIZE        /* point at proper end */
	br	3f
  1:
d1775 5
a1779 5
	ld	r3,  r31, REG_OFF(EF_VECTOR)
	cmp	r3,  r3, 1		/* is interrupt ? */
	bb0	eq,  r3, 3f		/* no, we will stay on kern stack */
	or.u	r31, r0,  hi16(_intstack_end)	/* swith to int stack */
	or	r31, r31, lo16(_intstack_end)
d1781 8
a1788 8
 /* This label is here for debugging */
 exception_handler_has_ksp:  global exception_handler_has_ksp
  3:    /*
           here - r30 holds a pointer to the exception frame.
           r31 is a pointer to the kernel stack/interrupt stack.
        */
  	subu	r31, r31, 8  /* make some breathing space */
	st	r30, r31, 0  /* store frame pointer on the stack */
d1790 1
a1790 1
  	st	r30, r31, 4  /* store it again for the debugger to recognize */
d1793 5
a1797 5
	ld	r2, r30, REG_OFF(EF_VECTOR)
        bcnd.n  eq0, r2, return_to_calling_exception_handler  /* is error */
        ld	r14, r30, REG_OFF(EF_RET)
	cmp	r3, r2, 1 /* interrupt is exception #1 ;Is an interrupt? */
	bb1.n	eq, r3, return_to_calling_exception_handler /* skip if so */
d1800 2
a1801 2
	cmp    	r3, r2, 130 /* DDB break exception */
        bb1.n   eq, r3, return_to_calling_exception_handler
d1803 2
a1804 2
        cmp     r3, r2, 132 /* DDB entry exception */
        bb1.n   eq, r3, return_to_calling_exception_handler
d1807 3
a1809 3
	ldcr    r2, PSR
 	clr	r2, r2, 1<PSR_INTERRUPT_DISABLE_BIT>	/* enable interrupts */
 	stcr	r2, PSR
d1811 1
a1811 1
  	FLUSH_PIPELINE
d1814 2
a1815 2
	/* service any outstanding data pipeline stuff
	   - check dmt0 anything outstanding?*/
d1817 2
a1818 2
	ld	r3, r30, REG_OFF(EF_DMT0)
	bb0	DMT_VALID_BIT, r3, return_to_calling_exception_handler
d1821 2
a1822 2
        r30 can be clobbered by calls. So stuff its value into a
        preserved register, say r15. R14 is in use (see return_to_... below).
d1824 1
a1824 1
	or 	r15, r0, r30
d1826 2
a1827 2
	CALL(_trap, T_DATAFLT, r15)
	CALL(_data_access_emulation, r15, r0)
d1829 2
a1830 2
/*	restore it... */
	or	r30, r0, r15
d1832 2
a1833 2
	/* clear the dmt0 word in the E.F */
	st	r0, r30, REG_OFF(EF_DMT0)
d1835 2
a1836 2
    _LABEL(return_to_calling_exception_handler)
	jmp	r14 /* loaded above */
d1849 10
a1858 10
	ld 	r1,r31,0		/* load func */
	ld 	r2,r31,4		/* load proc pointer */
	jsr.n 	r1
	subu 	r31,r31,40		/* create stack space for function */
	addu 	r31,r31,48		/* stack space above + ksigframe */
	ld	r1, r31,0		/* load pc */
	ld	r2, r31,4		/* & proc pointer from switch frame */
	jsr.n	r1
	addu	r31,r31,8
	bsr	_panic
d1869 5
a1873 5
	ld	r3,r2,P_ADDR			/* p->p_addr */
	addu	r3,r3,PCB_USER_STATE		/* p->p_addr.u_pcb.user_state */
	st	r3,r31,0			/* put it on the stack */
	br      return_from_exception_handler
	
d1876 2
a1877 2
	/*
	 * Regs r1-r30 are free. R31 is pointing at the word
d1880 9
a1888 9
 	 *
	 * At this point, if EF_DMT0 is not zero, then
	 * this must have been an interrupt where the fault didn't
	 * get corrected above.  We'll do that now.
	 *
	 * We load it into r14 since it is preserved across function
	 * calls, and we may have to call some routines from within here.
	 *
	 * control is transfered here from obvious places in this file
d1890 7
a1896 2
	 *
	 */
d1898 1
a1898 1
	ld	FPTR, r31, 0                 /* grab exception frame pointer */
d1903 10
a1912 10
	    /*
	    * This might happen for non-interrupts  If the user sets DMT0
	    * in an exception handler.........
	    */
	    ld 	r2, FPTR, REG_OFF(EF_VECTOR)
	    cmp	r2, r2, 1 /* interrupt is exception #1 ; Is an interrupt? */
	    bb1	eq, r2, 1f
	    LABEL(oops)
	    or.u	r4, r0, hi16(2f)
	    or		r4, r4, lo16(2f)
d1914 2
a1915 2
	    CALL(_db_printf, r4, r0)
     	    tb0 0, r0, 132
d1917 6
a1922 6
            br 1f
		data
		2:  string "OOPS: DMT0 not zero and not interrupt.\n\000"
		    align 8
		text
       1:
d1924 18
a1941 18
	/*
	 * If it's the interrupt exception, enable interrupt.
	 * Take care of any data access exception...... 90/8/15 add by yama
	 */

	/*
	 * Is it ever possible to have interrupt exception while EPSR has
	 * it disabled? I don't think so.. XXX nivas
	 */
	ld	r2, FPTR, REG_OFF(EF_VECTOR)
	cmp	r2, r2, 1   /* interrupt is exception #1 ; Is an interrupt? */
        bb1	ne, r2, 1f  /* If not so, skip */

        /* if EPSR has interrupts disabled, skip also */
	ld      r2, FPTR, REG_OFF(EF_EPSR)
        bb1	PSR_INTERRUPT_DISABLE_BIT, r2, 1f        /* skip if disabled */
	ldcr    r2, PSR
 	clr	r2, r2, 1<PSR_INTERRUPT_DISABLE_BIT>	 /* enable interrupts */
d1943 1
a1943 1
        stcr	r2, PSR
d1945 2
a1946 2
	ld	r2, FPTR, REG_OFF(EF_DMT0)
	bb0	DMT_VALID_BIT, r2, 2f
d1948 4
a1951 4
	/*
	 * if there happens to be a data fault that hasn't been serviced yet,
	 * go off and service that...
	 */
d1955 2
a1956 2
	/* clear the dmt0 word in the E.F. */
	st	r0 , FPTR, REG_OFF(EF_DMT0)
d1958 65
d2025 3
a2027 3
 *	If the saved ipl is 0, then call dosoftint() to process soft
 *	interrupts.
 *	If returning to user land, look for ASTs
d2032 24
a2055 24
	ld	r2, FPTR, REG_OFF(EF_EPSR)   /* get pre-exception PSR */
        bb1	PSR_INTERRUPT_DISABLE_BIT, r2, 1f /* skip if ints off */
	ld	r2, FPTR, REG_OFF(EF_MASK)   /* get pre-exception ipl */
	bcnd	ne0, r2, 1f		     /* can't do softint's */
	bsr.n	_setipl
	or	r2,r0,1
	bsr	_dosoftint
	/* is this needed? we are going to restore the ipl below XXX nivas */
	bsr.n	_setipl
	or	r2,r0,0		     	     /* ints are enabled */
					     /* at ipl 0 now */
      1:
	ld	r2, FPTR, REG_OFF(EF_EPSR)   /* get pre-exception PSR */
     	bb1	PSR_SUPERVISOR_MODE_BIT, r2, no_ast /*skip if in system mode */

	/* should assert here - not in user mode with ints off XXX nivas */
	/* get and check want_ast */
	or.u	r2, r0, hi16(_want_ast)
	ld	r3, r2, lo16(_want_ast)
	bcnd	eq0, r3, no_ast

	/*
	 * trap(AST,...) will service ast's.
	 */
d2060 1
a2060 1
	/* assert that ipl is 0; if going back to user, it should be 0 */
d2062 4
a2065 4
	bsr	_getipl
	bcnd	eq0, r2, 2f
	bsr	panic
      2:
d2070 8
a2077 1
	/* disable interrupts */
d2079 29
a2107 2
	ldcr	r1, PSR				     
	set	r1, r1, 1<PSR_INTERRUPT_DISABLE_BIT>
d2109 241
a2349 1
	stcr	r1, PSR
d2351 26
a2376 1
	 /* now ready to return....*/
d2378 19
a2396 29
    /*
     * Transfer the frame pointer to r31, since we no longer need a stack.
     * No page faults here, and interrupts are disabled.
     */

	ld	r2, FPTR, REG_OFF(EF_MASK)   /* get pre-exception ipl */
	bsr	_setipl

        or	r31, r0,  FPTR
	/* restore r1 later */
	ld.d	r2 , r31, GENREG_OFF(2)
	ld.d	r4 , r31, GENREG_OFF(4)
	ld.d	r6 , r31, GENREG_OFF(6)
	ld.d	r8 , r31, GENREG_OFF(8)
	ld.d	r10, r31, GENREG_OFF(10)
	ld.d	r12, r31, GENREG_OFF(12)
	ld.d	r14, r31, GENREG_OFF(14)
	ld.d	r16, r31, GENREG_OFF(16)
	ld.d	r18, r31, GENREG_OFF(18)
	ld.d	r20, r31, GENREG_OFF(20)
	ld.d	r22, r31, GENREG_OFF(22)
	ld.d	r24, r31, GENREG_OFF(24)
	ld.d	r26, r31, GENREG_OFF(26)
	ld.d	r28, r31, GENREG_OFF(28)
	/* restore r1, r30, r31 later */

	/* disable shadowing */
	ldcr	r1, PSR
	set	r1, r1, 1<PSR_SHADOW_FREEZE_BIT>
a2397 1
	stcr	r1, PSR
d2399 100
a2498 3
	/* reload the control regs*/
	st	r0,r31, REG_OFF(EF_IPFSR)
	st	r0,r31, REG_OFF(EF_DPFSR)
d2501 1
a2501 7
	 * Note: no need to restore the SXIP.
	 * When the "rte" causes execution to continue
	 * first with the instruction pointed to by the NIP
	 * and then the FIP.
	 *
	 * See MC88100 Risc Processor User's Manual, 2nd Edition,
	 * section 6.4.3.1.2-4
d2503 9
a2511 13
	ld	r30, r31, REG_OFF(EF_SNIP)
	ld	r1, r31, REG_OFF(EF_SFIP)
	stcr	r0, SSBR
	stcr	r30, SNIP
	stcr	r1, SFIP

	ld	r30, r31, REG_OFF(EF_EPSR)
	ld	r1,  r31, REG_OFF(EF_MODE)
	stcr	r30, EPSR

	/* Now restore r1, r30, and r31 */
	ld	r1,  r31, GENREG_OFF(1)
	ld.d	r30, r31, GENREG_OFF(30)
d2513 450
a2962 2
    _LABEL(return_from_exception)
	RTE
@


1.6
log
@Added kernel support for user debugging.  Fixed file ID's
@
text
@d1 1
a1 1
/*	$OpenBSD: eh.S,v 1.28 1995/04/19 22:37:27 smurph Exp $	*/
d242 2
d1669 1
a1669 1
#if notyet
d1678 1
a1678 1
#if notyet
d1692 1
a1692 1
#if notyet
d1698 1
a1698 1
#endif /* notyet */
@


1.5
log
@Commit for the first working mvme88k port.
@
text
@d1 1
@


1.4
log
@mvme88k will not make release, but just as well make the source as close as
possible.
@
text
@d6 1
d29 1
d200 1
a200 1
 *   SR0 - 
d239 1
a239 1
#define FLAG_FROM_KERNEL	8	/* this should be in locore.h */
d275 17
d293 1
a293 1
		xcr	FLAGS, FLAGS, SR1			; \
a297 1
								; \
d305 1
a305 1
	1:	bsr	setup_phase_one			; \
a321 3
#undef  EH_DEBUG
#define EH_DEBUG 1

d336 1
a336 1
	 * The bits are defined in "locore.h"
d396 1
a396 1
LABEL(unknown_handler)
d402 1
a402 1
LABEL(interrupt_handler)
d408 1
a408 1
LABEL(instruction_access_handler)
d431 1
a431 1
LABEL(data_exception_handler)
d436 1
a436 1
LABEL(misaligned_handler)
d442 1
a442 1
LABEL(unimplemented_handler)
d452 1
a452 1
LABEL(privilege_handler)
d466 1
a466 1
LABEL(bounds_handler)
d472 1
a472 1
LABEL(divide_handler)
d478 1
a478 1
LABEL(overflow_handler)
d540 2
a541 1
   LABEL(entry)
d545 1
d555 1
a555 1
   LABEL(entry)
d575 1
a575 1
LABEL(error_handler)
d692 1
d702 145
d1028 1
a1028 1
	bb1.n	FLAG_ENABLING_FPU, FLAGS, use_SR3_pcb
d1030 7
d1090 1
a1090 1
	xcr 	r30, r30, SR3			/* r30 = old exception frame */
d1505 1
a1505 1
	* SR0: current thread 						*
d1529 2
a1530 1
	stcr	TMP, SSBR	/* done with SSBR, TMP now free */
d1535 1
d1542 2
a1543 2
	or.u	TMP, r0, hi16(fpu_enable + 2)
	or	TMP, TMP, lo16(fpu_enable + 2)
d1547 13
a1559 1

d1591 1
@


1.3
log
@Cleanup after import. This also seems to bring up the current version.
@
text
@d217 1
@


1.2
log
@This is a remove to get rid of the old mvme88k port which was incomplete
to replace it with a working version. The kernel compiles and works
at least.  The new version will be imported shortly.
@
text
@d5 1
d43 14
a56 14
 * |  In the following discussion, references are made to:             |
 * |          MC88100 - RISC MICROPROCESSOR USER'S MANUAL              |
 * |  (second edition). Reference in []s refer to section numbers.     |
 * |                                                                   |
 * |  This discussion assumes that you are at least vaguely familiar   |
 * |  with 88100 exception handling (chapter 6), the MACH kernel, and  |
 * |  that you have a brain (and use it while reading this).           |
 * |                                                                   |
 * |  I also assume (and hope) that you're not offended by             |
 * |  frequent misspellings.                                           |
 * |                                                                   |
 * |                       Jeffrey Friedl                              |
 * |			   jfriedl@@rna.ncl.omron.co.jp		       |
 * |                       December, 1989                              |
d213 2
a214 2
#ifndef ASSEMBLER /* predefined by ascpp, at least */
#define ASSEMBLER /* this is required for some of the include files */
a216 1
#include <assym.s>   	  		/* for PCB_KSP, etc */
a217 1
#include <machine/locore.h>		/* lots of stuff */
a219 10
#ifndef PCB_USER
#define PCB_USER 0
#endif
#ifndef NBPG
#define	NBPG 4096
#endif /* NBPG */
#ifndef USIZE
#define USIZE (UPAGES * NBPG) 
#endif /* USIZE */

d221 1
a221 1
 * The exception frame as defined in "luna/m88k.h" (among other places) is
d272 29
a300 29
#define PREP(NAME, NUM, BIT, SSBR_STUFF, FLAG_PRECHECK)		NEWLINE \
		xcr	FLAGS, FLAGS, SR1			NEWLINE \
		FLAG_PRECHECK					NEWLINE \
		 						NEWLINE \
		/* the bsr later clobbers r1, so save now */	NEWLINE \
		stcr	r1, SR2	/* r1 now free */		NEWLINE \
								NEWLINE \
		/* set or clear the FLAG_FROM_KERNEL bit */	NEWLINE \
		ldcr	r1, EPSR				NEWLINE \
		bb0.n	PSR_SUPERVISOR_MODE_BIT, r1, 1f		NEWLINE \
		clr	FLAGS, FLAGS, 1<FLAG_FROM_KERNEL>	NEWLINE \
		set	FLAGS, FLAGS, 1<FLAG_FROM_KERNEL>	NEWLINE \
								NEWLINE \
		/* get a stack (exception frame) */		NEWLINE \
	1:	bsr	setup_phase_one			NEWLINE \
								NEWLINE \
		/* TMP2 now free -- use to set EF_VECTOR */	NEWLINE \
		or	TMP2, r0, NUM				NEWLINE \
		st	TMP2, r31, REG_OFF(EF_VECTOR)		NEWLINE \
								NEWLINE \
		/* Clear any bits in the SSBR (held in TMP) */	NEWLINE \
		/* SSBR_STUFF may be empty, though.         */	NEWLINE \
		SSBR_STUFF					NEWLINE \
								NEWLINE \
		/* call setup_phase_two to restart the FPU  */  NEWLINE \
		/* and to save all general registers.	    */ 	NEWLINE \
		bsr	setup_phase_two				NEWLINE \
								NEWLINE \
		/* All general regs free -- do any debugging */	NEWLINE \
d322 1
a322 2
/*	LABEL(_eh_debug) 	word 0x00000000 */
	LABEL(_eh_debug) 	word 0xFFFFFFFF
d330 18
a347 18
		or.u	r2, r0, hi16(_eh_debug)		NEWLINE \
		ld  	r3, r2, lo16(_eh_debug)		NEWLINE \
		bb0	DebugNumber, r3, 4f		NEWLINE \
		/* call MY_info(ef,thread,flags,kind)*/ NEWLINE \
		or	r2, r30, r0			NEWLINE \
		ldcr	r3, SR0				NEWLINE \
		ldcr	r4, SR1				NEWLINE \
		or.u	r5, r0, hi16(2f)		NEWLINE \
		or	r5, r5, lo16(2f)		NEWLINE \
		bsr.n	_MY_info			NEWLINE \
		subu	r31, r31, 40			NEWLINE \
		br.n	4f				NEWLINE \
		addu	r31, r31, 40			NEWLINE \
		data					NEWLINE \
	     2: string Name				NEWLINE \
		byte 0					NEWLINE \
		align 4					NEWLINE \
		text					NEWLINE \
d359 5
a363 5
		or.u	r2, r0, hi16(_eh_debug)		NEWLINE \
		ld  	r3, r2, lo16(_eh_debug)		NEWLINE \
		bb0	DebugNumber, r3, 2f		NEWLINE \
		ldcr	r4, SR1				NEWLINE \
		CALL(_MY_info_done, r31, r4)		NEWLINE \
d482 1
a482 1
LABEL(syscall_handler)
d570 1
a570 1
	addu    r28, r27,   4   /* bump up */
d617 1
d972 1
a972 1
     	addu	r31, r31, PCB_USER		/* point to user save area */
d1008 11
d1065 1
d1282 1
a1282 1
	 *			    00010000000000000000000000000000) ||
d1480 1
d1483 1
d1489 1
d1497 1
d1503 1
d1509 1
d1568 20
d1590 5
a1594 3
 * ##########################################################################
 * ##########################################################################
 * ##########################################################################
d1597 6
d1644 1
a1644 1
		    align 4
d1652 5
d1683 6
a1690 21
	ldcr	r1, PSR				     /* get current PSR */
	set	r1, r1, 1<PSR_INTERRUPT_DISABLE_BIT> /* set for disable intr. */
	stcr	r1, PSR				     /* install new PSR */
	FLUSH_PIPELINE

	/*
	 *
	 * This code (including a bit above) is more or less:
	 *
	 *    check_ast:
	 *
	 *	Disable interrupts
	 *	if (exception was from user mode && want_ast)
	 *	{
	 *	    trap(AST, frame)
	 *	    goto check_ast
	 *	}
	 *
	 * We want to service AST's only if returning to user space.
	 */

d1692 13
a1704 1
	bb1	PSR_SUPERVISOR_MODE_BIT, r2, no_ast /*skip if in system mode */
d1706 1
d1711 15
a1725 9
					/*
					 * trap(AST,...) will service
					 * software interrupts and 
					 * network interrupts
					 */
        CALL(_trap, T_ASTFLT, FPTR) 	/* enter with interrupts disabled */
        subu	r31, r31, 40		/* return with interrupts enabled */
        addu    r31, r31, 40
	br	_check_ast		/* and check again..... */
d1729 8
a1736 1
  /* now ready to return....*/
d1743 3
d1747 1
a1747 3


/* restore r1 later */
d1764 1
a1764 2

	/* disable shadowing (interrupts already disabled above) */
d1771 2
a1798 4

/***********************************************************************/
/***********************************************************************/
/***********************************************************************/
@


1.1
log
@moved from m88k directory
@
text
@@


1.1.1.1
log
@Third try at importing the mvme88k port. This is a working kernel
from nivas.
Userland and compiler still need to be worked on.
Make certain what directory the import is done from.
@
text
@a4 1
 * Copyright (c) 1996 Nivas Madhur
d42 14
a55 14
 * ;  In the following discussion, references are made to:             ;
 * ;          MC88100 - RISC MICROPROCESSOR USER'S MANUAL              ;
 * ;  (second edition). Reference in []s refer to section numbers.     ;
 * ;                                                                   ;
 * ;  This discussion assumes that you are at least vaguely familiar   ;
 * ;  with 88100 exception handling (chapter 6), the MACH kernel, and  ;
 * ;  that you have a brain (and use it while reading this).           ;
 * ;                                                                   ;
 * ;  I also assume (and hope) that you're not offended by             ;
 * ;  frequent misspellings.                                           ;
 * ;                                                                   ;
 * ;                       Jeffrey Friedl                              ;
 * ;			   jfriedl@@rna.ncl.omron.co.jp		       ;
 * ;                       December, 1989                              ;
d212 2
a213 2
#ifndef ASSEMBLER
#define ASSEMBLER
d216 1
d218 1
d221 10
d232 1
a232 1
 * The exception frame as defined in "machine/pcb.h" (among other places) is
d283 29
a311 29
#define PREP(NAME, NUM, BIT, SSBR_STUFF, FLAG_PRECHECK)		; \
		xcr	FLAGS, FLAGS, SR1			; \
		FLAG_PRECHECK					; \
		 						; \
		/* the bsr later clobbers r1, so save now */	; \
		stcr	r1, SR2	/* r1 now free */		; \
								; \
		/* set or clear the FLAG_FROM_KERNEL bit */	; \
		ldcr	r1, EPSR				; \
		bb0.n	PSR_SUPERVISOR_MODE_BIT, r1, 1f		; \
		clr	FLAGS, FLAGS, 1<FLAG_FROM_KERNEL>	; \
		set	FLAGS, FLAGS, 1<FLAG_FROM_KERNEL>	; \
								; \
		/* get a stack (exception frame) */		; \
	1:	bsr	setup_phase_one			; \
								; \
		/* TMP2 now free -- use to set EF_VECTOR */	; \
		or	TMP2, r0, NUM				; \
		st	TMP2, r31, REG_OFF(EF_VECTOR)		; \
								; \
		/* Clear any bits in the SSBR (held in TMP) */	; \
		/* SSBR_STUFF may be empty, though.         */	; \
		SSBR_STUFF					; \
								; \
		/* call setup_phase_two to restart the FPU  */  ; \
		/* and to save all general registers.	    */ 	; \
		bsr	setup_phase_two				; \
								; \
		/* All general regs free -- do any debugging */	; \
d333 2
a334 1
	LABEL(_eh_debug) 	word 0x00000000
d342 18
a359 18
		or.u	r2, r0, hi16(_eh_debug)		; \
		ld  	r3, r2, lo16(_eh_debug)		; \
		bb0	DebugNumber, r3, 4f		; \
		/* call MY_info(ef,thread,flags,kind)*/ ; \
		or	r2, r30, r0			; \
		ldcr	r3, SR0				; \
		ldcr	r4, SR1				; \
		or.u	r5, r0, hi16(2f)		; \
		or	r5, r5, lo16(2f)		; \
		bsr.n	_MY_info			; \
		subu	r31, r31, 40			; \
		br.n	4f				; \
		addu	r31, r31, 40			; \
		data					; \
	     2: string Name				; \
		byte 0					; \
		align 4					; \
		text					; \
d371 5
a375 5
		or.u	r2, r0, hi16(_eh_debug)		; \
		ld  	r3, r2, lo16(_eh_debug)		; \
		bb0	DebugNumber, r3, 2f		; \
		ldcr	r4, SR1				; \
		CALL(_MY_info_done, r31, r4)		; \
d494 1
a494 1
LABEL(_syscall_handler)
d582 1
a582 1
	addu    r27, r27,   4   /* bump up */
a628 1
	tb1	0, r0, 0
d983 1
a983 1
     	addu	r31, r31, PCB_USER_STATE	/* point to user save area */
a1018 11
	/*
	 * Save Pbus fault status register from data and inst CMMU.
	 */

	or.u	TMP, r0, hi16(CMMU_I)
	ld	TMP2, TMP, lo16(CMMU_I) + 0x108
	st	TMP2, r31, REG_OFF(EF_IPFSR)
	or.u	TMP, r0, hi16(CMMU_D)
	ld	TMP2, TMP, lo16(CMMU_D) + 0x108
	st	TMP2, r31, REG_OFF(EF_DPFSR)

a1064 1
	tb1	0,r0,0
d1281 1
a1281 1
	 *			    00010000000000000000000000000000) ;;
a1478 1
#if notyet
a1480 1
#endif
a1485 1
#if notyet
a1492 1
#endif
a1497 1
#if notyet
a1502 1
#endif /* notyet */
a1560 20
/*
 * proc_trampoline.
 * When a process setup by cpu_set_kpc() resumes, it will find itself in
 * proc_trampoline, with r31 pointing to a ksigframe. proc_trampoline will
 * load func and proc values from ksigframe, call the function, and on return
 * pop off the ksigframe. Then, it will load pc from the switchframe and
 * jump there.
 */

ENTRY(proc_trampoline)
	ld 	r1,r31,0		/* load func */
	ld 	r2,r31,4		/* load proc pointer */
	jsr.n 	r1
	subu 	r31,r31,40		/* create stack space for function */
	addu 	r31,r31,48		/* stack space above + ksigframe */
	ld	r1, r31,0		/* load pc */
	ld	r2, r31,4		/* & proc pointer from switch frame */
	jsr.n	r1
	addu	r31,r31,8
	bsr	_panic
d1563 3
a1565 5
 * proc_do_uret 
 * this is called as proc_do_uret(proc) from proc_trampoline(). This function
 * loads r31 with a pointer to the trap frame for the given proc and calls
 * return_from_exception_handler which loads all the registers and does an
 * rte.
a1567 6
ENTRY(proc_do_uret)
	ld	r3,r2,P_ADDR			/* p->p_addr */
	addu	r3,r3,PCB_USER_STATE		/* p->p_addr.u_pcb.user_state */
	st	r3,r31,0			/* put it on the stack */
	br      return_from_exception_handler
	
d1609 1
a1609 1
		    align 8
a1616 5

	/*
	 * Is it ever possible to have interrupt exception while EPSR has
	 * it disabled? I don't think so.. XXX nivas
	 */
d1643 6
a1648 5
/*
 *	If the saved ipl is 0, then call dosoftint() to process soft
 *	interrupts.
 *	If returning to user land, look for ASTs
 */
d1650 15
a1664 1
LABEL(_check_ast)
d1667 1
a1667 13
        bb1	PSR_INTERRUPT_DISABLE_BIT, r2, 1f /* skip if ints off */
	ld	r2, FPTR, REG_OFF(EF_MASK)   /* get pre-exception ipl */
	bcnd	ne0, r2, 1f		     /* can't do softint's */
	bsr.n	_setipl
	or	r2,r0,1
	bsr	_dosoftint
	/* is this needed? we are going to restore the ipl below XXX nivas */
	bsr.n	_setipl
	or	r2,r0,0		     	     /* ints are enabled */
					     /* at ipl 0 now */
      1:
	ld	r2, FPTR, REG_OFF(EF_EPSR)   /* get pre-exception PSR */
     	bb1	PSR_SUPERVISOR_MODE_BIT, r2, no_ast /*skip if in system mode */
a1668 1
	/* should assert here - not in user mode with ints off XXX nivas */
d1673 9
a1681 15

	/*
	 * trap(AST,...) will service ast's.
	 */

        CALL(_trap, T_ASTFLT, FPTR)

#if 0
	/* assert that ipl is 0; if going back to user, it should be 0 */

	bsr	_getipl
	bcnd	eq0, r2, 2f
	bsr	panic
      2:
#endif
d1685 1
a1685 8
	/* disable interrupts */

	ldcr	r1, PSR				     
	set	r1, r1, 1<PSR_INTERRUPT_DISABLE_BIT>
        FLUSH_PIPELINE
	stcr	r1, PSR

	 /* now ready to return....*/
d1692 2
a1693 2
	ld	r2, FPTR, REG_OFF(EF_MASK)   /* get pre-exception ipl */
	bsr	_setipl
d1695 1
a1695 2
        or	r31, r0,  FPTR
	/* restore r1 later */
d1712 2
a1713 1
	/* disable shadowing */
a1719 2
	st	r0,r31, REG_OFF(EF_IPFSR)
	st	r0,r31, REG_OFF(EF_DPFSR)
d1746 4
@
