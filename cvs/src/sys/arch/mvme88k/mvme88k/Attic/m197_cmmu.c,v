head	1.14;
access;
symbols
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	UBC_SYNC_A:1.14
	UBC_SYNC_B:1.14
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SMP:1.1.0.4
	SMP_BASE:1.1
	kame_19991208:1.1
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.14
date	2001.12.22.09.49.39;	author smurph;	state dead;
branches;
next	1.13;

1.13
date	2001.12.16.23.49.46;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.13.08.55.52;	author smurph;	state dead;
branches;
next	1.11;

1.11
date	2001.11.27.05.37.02;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.28.20.46.42;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.31.01.52.22;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.26.14.31.12;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.24.22.49.18;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.24.19.26.15;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.11.01.55.55;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.07.22.12.31;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.28.21.21.24;	author smurph;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.03.00.54.53;	author todd;	state Exp;
branches;
next	1.1;

1.1
date	99.09.27.19.13.22;	author smurph;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2000.03.24.09.08.18;	author niklas;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2001.04.18.16.11.35;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2001.10.31.03.01.19;	author nate;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2001.12.05.00.39.12;	author niklas;	state Exp;
branches;
next	1.1.4.5;

1.1.4.5
date	2002.03.06.02.04.45;	author niklas;	state dead;
branches;
next	;


desc
@@


1.14
log
@masive cmmu overhaul.  function pointers now control cmmu functionality
instead of case statements based on cpu type.
@
text
@/*	$OpenBSD: m197_cmmu.c,v 1.13 2001/12/16 23:49:46 miod Exp $	*/
/*
 * Copyright (c) 1998 Steve Murphree, Jr.
 * Copyright (c) 1996 Nivas Madhur
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Nivas Madhur.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/*
 * Mach Operating System
 * Copyright (c) 1993-1991 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON AND OMRON ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON AND OMRON DISCLAIM ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */
#include <sys/param.h>
#include <sys/types.h>
#include <sys/simplelock.h>

#include <machine/board.h>
#include <machine/cpus.h>
#include <machine/cpu_number.h>
#include <machine/locore.h>
#include <machine/m88110.h>
#include <machine/m88110_mmu.h>

#ifdef DDB
#include <ddb/db_output.h>
#endif

#ifdef DEBUG
#define DB_CMMU		0x4000	/* MMU debug */
unsigned int debuglevel = 0;
#define dprintf(_L_,_X_) { if (debuglevel & (_L_)) { unsigned int psr = disable_interrupts_return_psr(); printf("%d: ", cpu_number()); printf _X_;  set_psr(psr); } }
#else
#define dprintf(_L_,_X_)
#endif 

#undef	SHADOW_BATC		/* don't use BATCs for now XXX nivas */

/*
 * CMMU(cpu,data) Is the cmmu struct for the named cpu's indicated cmmu.
 * REGS(cpu,data) is the actual register structure.
 */

#define CMMU(cpu, data) cpu_cmmu[(cpu)].pair[(data)?DATA_CMMU:INST_CMMU]
#define REGS(cpu, data) (*CMMU(cpu, data)->cmmu_regs)

/* prototypes */
void m197_cmmu_store __P((int, int, unsigned));
int m197_cmmu_alive __P((int));
unsigned m197_cmmu_get __P((int, int));
void m197_cmmu_set __P((int, unsigned, int, int, int, int, vm_offset_t));
int probe_mmu __P((vm_offset_t, int));
void m197_cmmu_sync_cache __P((vm_offset_t, int));
void m197_cmmu_sync_inval_cache __P((vm_offset_t, int));
void m197_cmmu_inval_cache __P((vm_offset_t, int));

/* 
 * This lock protects the cmmu SAR and SCR's; other ports 
 * can be accessed without locking it 
 *
 * May be used from "db_interface.c".
 */

#ifdef CMMU_DEBUG
void
m197_show_apr(unsigned value)
{
	union apr_template apr_template;
	apr_template.bits = value;

	printf("table @@ 0x%x000", apr_template.field.st_base);
	if (apr_template.field.wt) printf(", writethrough");
	if (apr_template.field.g)  printf(", global");
	if (apr_template.field.ci) printf(", cache inhibit");
	if (apr_template.field.te) printf(", valid");
	else			   printf(", not valid");
	printf("\n");
}

void
m197_show_sctr(unsigned value)
{
	union {
		unsigned bits;
		struct {
			unsigned :16,
			pe: 1,
			se: 1,
			pr: 1,
			:13;
		} fields;
	} sctr; 
	sctr.bits = value;
	printf("%spe, %sse %spr]\n",
	       sctr.fields.pe ? "" : "!",
	       sctr.fields.se ? "" : "!",
	       sctr.fields.pr ? "" : "!");
}
#endif

void 
m197_setup_board_config(void)
{
	/* dummy routine */
	m197_setup_cmmu_config();
	return;
}

void 
m197_setup_cmmu_config(void)
{
	/* we can print something here... */
	cpu_sets[0] = 1;   /* This cpu installed... */
	return;
}

void m197_cmmu_dump_config(void)
{
	/* dummy routine */
	return;
}

void
m197_cmmu_store(int mmu, int reg, unsigned val)
{
}

int 
m197_cmmu_alive(int mmu)
{
   return 1;
}

unsigned 
m197_cmmu_get(int mmu, int reg)
{
   return 0;
}

/*
 * This function is called by the MMU module and pokes values
 * into the CMMU's registers.
 */
void 
m197_cmmu_set(int reg, unsigned val, int flags,
              int num, int mode, int access, vm_offset_t addr)
{
   return;
}

#ifdef DDB
/*
 * Used by DDB for cache probe functions
 */
unsigned m197_cmmu_get_by_mode(int cpu, int mode)
{
	return 0;
}
#endif

/*
 * Should only be called after the calling cpus knows its cpu
 * number and master/slave status . Should be called first
 * by the master, before the slaves are started.
*/
void 
m197_cpu_configuration_print(int master)
{
	int pid = read_processor_identification_register();
	int proctype = (pid & 0xff00) >> 8;
	int procvers = (pid & 0xe) >> 1;
	int cpu = cpu_number();
	struct simplelock print_lock;

	if (master)
		simple_lock_init(&print_lock);

	simple_lock(&print_lock);

	printf("Processor %d: ", cpu);
	if (proctype)
		printf("Architectural Revision 0x%x UNKNOWN CPU TYPE Version 0x%x\n",
		       proctype, procvers);
	else
		printf("M88110 Version 0x%x\n", procvers);

	simple_unlock(&print_lock);
	return;
}

/*
 * CMMU initialization routine
 */
void m197_load_patc(int entry, vm_offset_t vaddr, vm_offset_t paddr, int kernel);

void
m197_cmmu_init(void)
{
	int i;
	unsigned tmp;
	extern void *kernel_sdt;
	unsigned lba, pba, value;

	/* clear BATCs */
	for (i=0; i<8; i++) {
		m197_cmmu_set_pair_batc_entry(0, i, 0);
	}
	/* clear PATCs */
	for (i=0; i<32; i++) {
		m197_load_patc(i, 0, 0, 0);
	}
	set_ictl(CMMU_ICTL_DID	       /* Double instruction disable */
		 | CMMU_ICTL_MEN
		 | CMMU_ICTL_HTEN);


	set_dctl(CMMU_DCTL_MEN
		 | CMMU_DCTL_HTEN);      

	set_icmd(CMMU_ICMD_INV_ITIC);  /* clear instruction cache */
	set_dcmd(CMMU_DCMD_INV_ALL);   /* clear data cache */

	tmp = (0x00000 << 12) |	/* segment table base address */
	      AREA_D_WT |	/* write through */
	      AREA_D_G  |	/* global */
	      ! AREA_D_TE ;	/* not translation enable */

	set_isap(tmp);
	set_dsap(tmp);

	set_isr(0);
	set_ilar(0);
	set_ipar(0);
	set_dsr(0);
	set_dlar(0);
	set_dpar(0);

	lba = pba = (unsigned)&kernel_sdt;
	lba &= ~0x7FFFF;
	pba = pba >> 13;
	pba &= ~0x3F;
	value = lba | pba | 0x20 | 0x01;

	m197_cmmu_set_pair_batc_entry(0, 0, value);

}

/*
 * Just before poweroff or reset....
 */
void
m197_cmmu_shutdown_now(void)
{
}

/*
 * enable parity
 */
void 
m197_cmmu_parity_enable(void)
{
#ifdef	PARITY_ENABLE
#endif  /* PARITY_ENABLE */
}

/*
 * Find out the CPU number from accessing CMMU
 * Better be at splhigh, or even better, with interrupts
 * disabled.
 */
#define ILLADDRESS	U(0x0F000000) 	/* any faulty address */

unsigned 
m197_cmmu_cpu_number(void)
{
	return 0; /* to make compiler happy */
}

/**
 **	Functions that actually modify CMMU registers.
 **/
void
m197_cmmu_remote_set(unsigned cpu, unsigned r, unsigned data, unsigned x)
{
	panic("m197_cmmu_remote_set() called!");
}

/*
 * cmmu_cpu_lock should be held when called if read
 * the CMMU_SCR or CMMU_SAR.
 */
unsigned
m197_cmmu_remote_get(unsigned cpu, unsigned r, unsigned data)
{
	panic("m197_cmmu_remote_get() called!");
	return 0;
}

/* Needs no locking - read only registers */
unsigned
m197_cmmu_get_idr(unsigned data)
{
	return 0; /* todo */
}

int 
probe_mmu(vm_offset_t va, int data)
{
	unsigned result;
	if (data) {
		set_dsar((unsigned)va);
		set_dcmd(CMMU_DCMD_PRB_SUPR);
		result = get_dsr();
		if (result & CMMU_DSR_PH)
			return 1;
		else
			return 0;
	} else {
		set_isar((unsigned)va);
		set_icmd(CMMU_ICMD_PRB_SUPR);
		result = get_isr();
		if (result & CMMU_ISR_BH)
			return 2;
		else if (result & CMMU_ISR_PH)
			return 1;
		else
			return 0;
	}
	return 0;
}

void
m197_cmmu_set_sapr(unsigned ap)
{
	int result;
	set_icmd(CMMU_ICMD_INV_SATC);
	set_dcmd(CMMU_DCMD_INV_SATC);
	/* load an entry pointing to seg table into PATC */
	/* Don't forget to set it valid */

	m197_load_patc(0, (vm_offset_t)ap, (vm_offset_t)(ap | 0x1), 1);
	if (!(result = probe_mmu((vm_offset_t) ap, 1))) {
		printf("Didn't make it!!!!\n");
		return;
	} else {
		if (result == 2)
			printf("area pointer is in BATC.\n");
		if (result == 1)
			printf("area pointer is in PATC.\n");
	}

	set_isap(ap);
	set_dsap(ap);
}

void
m197_cmmu_remote_set_sapr(unsigned cpu, unsigned ap)
{
	m197_cmmu_set_sapr(ap);
}

void
m197_cmmu_set_uapr(unsigned ap)
{
	set_iuap(ap);
	set_duap(ap);
}

/*
 * Set batc entry number entry_no to value in 
 * the data or instruction cache depending on data.
 *
 * Except for the cmmu_init, this function, m197_cmmu_set_pair_batc_entry,
 * and m197_cmmu_pmap_activate are the only functions which may set the
 * batc values.
 */
void
m197_cmmu_set_batc_entry(
			unsigned cpu,
			unsigned entry_no,
			unsigned data,	 /* 1 = data, 0 = instruction */
			unsigned value)	 /* the value to stuff */
{
	if (data) {
		set_dir(entry_no);
		set_dbp(value);
	} else {
		set_iir(entry_no);
		set_ibp(value);
	}
}

/*
 * Set batc entry number entry_no to value in 
 * the data and instruction cache for the named CPU.
 */
void
m197_cmmu_set_pair_batc_entry(unsigned cpu, unsigned entry_no, unsigned value)
/* the value to stuff into the batc */
{
	m197_cmmu_set_batc_entry(cpu, entry_no, 1, value);
	m197_cmmu_set_batc_entry(cpu, entry_no, 0, value);
}

/**
 **	Functions that invalidate TLB entries.
 **/

/*
 *	flush any tlb
 *	Some functionality mimiced in m197_cmmu_pmap_activate.
 */
void
m197_cmmu_flush_remote_tlb(unsigned cpu, unsigned kernel, vm_offset_t vaddr, int size)
{
	register int s = splhigh();
	if (kernel) {
		set_icmd(CMMU_ICMD_INV_SATC);
		set_dcmd(CMMU_DCMD_INV_SATC);
	} else {
		set_icmd(CMMU_ICMD_INV_UATC);
		set_dcmd(CMMU_DCMD_INV_UATC);
	}
	splx(s);
}

/*
 *	flush my personal tlb
 */
void
m197_cmmu_flush_tlb(unsigned kernel, vm_offset_t vaddr, int size)
{
	int cpu;
	cpu = cpu_number();
	m197_cmmu_flush_remote_tlb(cpu, kernel, vaddr, size);
}

/*
 * New fast stuff for pmap_activate.
 * Does what a few calls used to do.
 * Only called from pmap.c's _pmap_activate().
 */
void
m197_cmmu_pmap_activate(
		       unsigned cpu,
		       unsigned uapr,
		       batc_template_t i_batc[BATC_MAX],
		       batc_template_t d_batc[BATC_MAX])
{
	/* int entry_no;*/

	m197_cmmu_set_uapr(uapr);

	/*
	for (entry_no = 0; entry_no < 8; entry_no++) {
	   m197_cmmu_set_batc_entry(cpu, entry_no, 0, i_batc[entry_no].bits);
	   m197_cmmu_set_batc_entry(cpu, entry_no, 1, d_batc[entry_no].bits);
	}
	*/
	/*
	 * Flush the user TLB.
	 * IF THE KERNEL WILL EVER CARE ABOUT THE BATC ENTRIES,
	 * THE SUPERVISOR TLBs SHOULB EE FLUSHED AS WELL.
	 */
	set_icmd(CMMU_ICMD_INV_UATC);
	set_dcmd(CMMU_DCMD_INV_UATC);
}

/**
 **	Functions that invalidate caches.
 **
 ** Cache invalidates require physical addresses.  Care must be exercised when
 ** using segment invalidates.  This implies that the starting physical address
 ** plus the segment length should be invalidated.  A typical mistake is to
 ** extract the first physical page of a segment from a virtual address, and
 ** then expecting to invalidate when the pages are not physically contiguous.
 **
 ** We don't push Instruction Caches prior to invalidate because they are not
 ** snooped and never modified (I guess it doesn't matter then which form
 ** of the command we use then).
 **/
/*
 *	flush both Instruction and Data caches
 */
void
m197_cmmu_flush_remote_cache(int cpu, vm_offset_t physaddr, int size)
{
	register int s = splhigh();
	set_icmd(CMMU_ICMD_INV_ITIC);
	set_dcmd(CMMU_DCMD_FLUSH_ALL_INV);
	splx(s);
}

/*
 *	flush both Instruction and Data caches
 */
void
m197_cmmu_flush_cache(vm_offset_t physaddr, int size)
{
	int cpu = cpu_number();
	m197_cmmu_flush_remote_cache(cpu, physaddr, size);
}

/*
 *	flush Instruction caches
 */
void
m197_cmmu_flush_remote_inst_cache(int cpu, vm_offset_t physaddr, int size)
{
	register int s = splhigh();

	set_icmd(CMMU_ICMD_INV_ITIC);

	splx(s);
}

/*
 *	flush Instruction caches
 */
void
m197_cmmu_flush_inst_cache(vm_offset_t physaddr, int size)
{
	int cpu;
	cpu = cpu_number();
	m197_cmmu_flush_remote_inst_cache(cpu, physaddr, size);
}

/*
 * flush data cache
 */ 
void
m197_cmmu_flush_remote_data_cache(int cpu, vm_offset_t physaddr, int size)
{ 
	register int s = splhigh();
	set_dcmd(CMMU_DCMD_FLUSH_ALL_INV);
	splx(s);
}

/*
 * flush data cache
 */ 
void
m197_cmmu_flush_data_cache(vm_offset_t physaddr, int size)
{ 
	int cpu;
	cpu = cpu_number();
	m197_cmmu_flush_remote_data_cache(cpu, physaddr, size);
}

/*
 * sync dcache (and icache too)
 */
void
m197_cmmu_sync_cache(vm_offset_t physaddr, int size)
{
	register int s = splhigh();
	int cpu;
	cpu = cpu_number(); 
	/* set_mmureg(CMMU_ICTL, CMMU_ICMD_INV_TIC); */
	set_dcmd(CMMU_DCMD_FLUSH_ALL);

	splx(s);
}

void
m197_cmmu_sync_inval_cache(vm_offset_t physaddr, int size)
{
	register int s = splhigh();
	int cpu;
	cpu = cpu_number();

	set_dcmd(CMMU_DCMD_FLUSH_ALL_INV);
	splx(s);
}

void
m197_cmmu_inval_cache(vm_offset_t physaddr, int size)
{
	register int s = splhigh();
	int cpu;
	cpu = cpu_number();
	set_icmd(CMMU_ICMD_INV_ITIC);
	set_dcmd(CMMU_DCMD_INV_ALL);
	splx(s);
}

void
m197_dma_cachectl(vm_offset_t va, int size, int op)
{
	if (op == DMA_CACHE_SYNC)
		m197_cmmu_sync_cache(kvtop(va), size);
	else if (op == DMA_CACHE_SYNC_INVAL)
		m197_cmmu_sync_inval_cache(kvtop(va), size);
	else
		m197_cmmu_inval_cache(kvtop(va), size);
}

#ifdef DDB

   #define VV_EX_UNMOD		0
   #define VV_EX_MOD		1
   #define VV_SHARED_UNMOD		2
   #define VV_INVALID		3

   #define D(UNION, LINE) \
	((LINE) == 3 ? (UNION).field.d3 : \
	 ((LINE) == 2 ? (UNION).field.d2 : \
	  ((LINE) == 1 ? (UNION).field.d1 : \
	   ((LINE) == 0 ? (UNION).field.d0 : ~0))))
   #define VV(UNION, LINE) \
	((LINE) == 3 ? (UNION).field.vv3 : \
	 ((LINE) == 2 ? (UNION).field.vv2 : \
	  ((LINE) == 1 ? (UNION).field.vv1 : \
	   ((LINE) == 0 ? (UNION).field.vv0 : ~0))))


   #undef VEQR_ADDR
   #define  VEQR_ADDR 0

/*
 * Show (for debugging) how the given CMMU translates the given ADDRESS.
 * If cmmu == -1, the data cmmu for the current cpu is used.
 */
void
m197_cmmu_show_translation(unsigned address,
		unsigned supervisor_flag,
		unsigned verbose_flag,
		int cmmu_num)
{
	/*
	 * A virtual address is split into three fields. Two are used as
	 * indicies into tables (segment and page), and one is an offset into
	 * a page of memory.
	 */
	/*
	union {
		unsigned bits;
		struct {
			unsigned segment_table_index:10,
			page_table_index:10,
			page_offset:12;
		} field;
	} virtual_address;
	*/

#ifdef DDB
	if (verbose_flag)
		db_printf("-------------------------------------------\n");
#endif
}


void
m197_cmmu_cache_state(unsigned addr, unsigned supervisor_flag)
{
	/*
	static char *vv_name[4] =
	{"exclu-unmod", "exclu-mod", "shared-unmod", "invalid"};
	*/
}

void
m197_show_cmmu_info(unsigned addr)
{
	m197_cmmu_cache_state(addr, 1);
}
#endif /* end if DDB */

#define MSDTENT(addr, va)	((sdt_entry_t *)(addr + SDTIDX(va)))
#define MPDTENT(addr, va)	((sdt_entry_t *)(addr + PDTIDX(va)))
void
m197_load_patc(int entry, vm_offset_t vaddr, vm_offset_t paddr, int kernel)
{
	unsigned lpa, pfa, i;

	lpa = (unsigned)vaddr & 0xFFFFF000;
	if (kernel) {
		lpa |= 0x01;
	}
	pfa = (unsigned)paddr;
	i = entry << 5;
	set_iir(i);
	set_ippu(lpa);
	set_ippl(pfa);
	set_dir(i);
	set_dppu(lpa);
	set_dppl(lpa);
}

#define SDT_WP(sd_ptr)  ((sd_ptr)->prot != 0)
#define SDT_SUP(sd_ptr)  ((sd_ptr)->sup != 0)
#define PDT_WP(pte_ptr)  ((pte_ptr)->prot != 0)
#define PDT_SUP(pte_ptr)  ((pte_ptr)->sup != 0)

int 
m197_table_search(pmap_t map, vm_offset_t virt, int write, int kernel, int data)
{
	sdt_entry_t *sdt;
	pt_entry_t  *pte;
	unsigned lpa, i;
	static int entry_num = 0;

	if (map == (pmap_t)0)
		panic("m197_table_search: pmap is NULL");

	sdt = SDTENT(map, virt);

	/*
	 * Check whether page table exist or not.
	 */
	if (!SDT_VALID(sdt))
		return (4); /* seg fault */

	/* OK, it's valid.  Now check permissions. */
	if (!kernel)
		if (SDT_SUP(sdt))
			return (6); /* Supervisor Violation */
	if (write)
		if (SDT_WP(sdt))
			return (7); /* Write Violation */

	pte = (pt_entry_t *)(((sdt + SDT_ENTRIES)->table_addr)<<PDT_SHIFT) + PDTIDX(virt);

	/*
	 * Check whether page frame exist or not.
	 */
	if (!PDT_VALID(pte))
		return (5); /* Page Fault */

	/* OK, it's valid.  Now check permissions. */
	if (!kernel)
		if (PDT_SUP(sdt))
			return (6); /* Supervisor Violation */
	if (write)
		if (PDT_WP(sdt))
			return (7); /* Write Violation */
	/* If we get here, load the PATC. */
	if (entry_num > 32)
		entry_num = 0;
	lpa = (unsigned)virt & 0xFFFFF000;
	if (kernel)
		lpa |= 0x01;
	i = entry_num << 5;
	if (data) {
		set_dir(i); /* set PATC index */
		set_dppu(lpa); /* set logical address */
		set_dppl((unsigned)pte); /* set page fram address */
	} else {
		set_iir(i);
		set_ippu(lpa);
		set_ippl((unsigned)pte);
	}
	return 0;
}
@


1.13
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: m197_cmmu.c,v 1.11 2001/11/27 05:37:02 miod Exp $	*/
@


1.12
log
@Support for MVME197 completed.  Fix SPL defs.
@
text
@@


1.11
log
@Adapt to include files changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: m197_cmmu.c,v 1.10 2001/09/28 20:46:42 miod Exp $	*/
@


1.10
log
@Typos of the day.
@
text
@d1 1
a1 1
/*	$OpenBSD: m197_cmmu.c,v 1.9 2001/08/31 01:52:22 miod Exp $	*/
d69 1
@


1.9
log
@Assorted changes to really let non-DDB kernels (such as the future RAMDISK,
hint, hint) compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: m197_cmmu.c,v 1.8 2001/08/26 14:31:12 miod Exp $	*/
d325 1
a325 1
 **	Funcitons that actually modify CMMU registers.
a326 3
#if !DDB
static
#endif
a336 3
#if !DDB
static
#endif
@


1.8
log
@Add prototypes, fix compilation warnings, random style fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: m197_cmmu.c,v 1.7 2001/08/24 22:49:18 miod Exp $	*/
a73 2
#define CMMU_DEBUG 1

a92 4
#ifdef CMMU_DEBUG
void m197_show_apr __P((unsigned));
void m197_show_sctr __P((unsigned));
#endif
a93 2
void m197_setup_cmmu_config __P((void));
void m197_setup_board_config __P((void));
a100 3
void m197_cmmu_show_translation __P((unsigned, unsigned, unsigned, int));
void m197_show_cmmu_info __P((unsigned));
void m197_cmmu_cache_state __P((unsigned, unsigned));
@


1.7
log
@Correct execution flow in m197_table_search().
@
text
@d1 1
a1 1
/*	$OpenBSD: m197_cmmu.c,v 1.6 2001/08/24 19:26:15 miod Exp $	*/
d63 1
d67 1
d70 4
d77 1
a77 1
   #define DB_CMMU		0x4000	/* MMU debug */
d79 1
a79 1
   #define dprintf(_L_,_X_) { if (debuglevel & (_L_)) { unsigned int psr = disable_interrupts_return_psr(); printf("%d: ", cpu_number()); printf _X_;  set_psr(psr); } }
d81 1
a81 1
   #define dprintf(_L_,_X_)
d83 1
d94 19
a119 4
/* FORWARDS */
void m197_setup_cmmu_config(void);
void m197_setup_board_config(void);

d179 1
a179 2
/* To be implemented as a macro for speedup - XXX-smurph */
static void 
d193 1
a193 2
   unsigned val;
   return val;
d228 1
a228 1
	int mmu, cpu = cpu_number();
a258 1
	init_done = 0;
a309 3
	unsigned tmp;
	unsigned cmmu_num;

d478 1
a478 1
	register s = splhigh();
d512 1
a512 1
	int entry_no;
d550 1
a550 1
	register s = splhigh();
d572 1
a572 1
	register s = splhigh();
d596 1
a596 1
	register s = splhigh();
d618 1
a618 1
	register s = splhigh();
d630 1
a630 1
	register s = splhigh();
d641 1
a641 1
	register s = splhigh();
a651 1
	int count;
d697 1
d706 1
a706 1
	unsigned value;
d708 1
d711 1
a711 1

d718 1
d721 1
a721 1
	int cmmu_num;
a726 1
	int cmmu_num;
d762 2
a763 2
	unsigned lpa, pfa, i;
	static entry_num = 0;
@


1.6
log
@No newline at the end of panic messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: m197_cmmu.c,v 1.5 2001/08/11 01:55:55 miod Exp $	*/
d767 2
a768 2
		else
			pte = (pt_entry_t *)(((sdt + SDT_ENTRIES)->table_addr)<<PDT_SHIFT) + PDTIDX(virt);
d782 1
a782 1
		/* If we get here, load the PATC. */
@


1.5
log
@Include files serve a purpose. Move lots of extern statements from
foo_cmmu.c to cmmu.h ; also don't check for 197 in m18x_cmmu.c, as this
code is 18x specific.
@
text
@d1 1
a1 1
/*	$OpenBSD: m197_cmmu.c,v 1.4 2001/08/07 22:12:31 miod Exp $	*/
d328 1
a328 1
	panic("m197_cmmu_remote_set() called!\n");
d341 1
a341 1
	panic("m197_cmmu_remote_get() called!\n");
@


1.4
log
@Make config(8) choose which source files to exclude, from the kernel
configuration file options, rather than putting ugly preprocessor
statements and compile empty files.
@
text
@d1 1
a1 1
/*	$OpenBSD: m197_cmmu.c,v 1.3 2000/12/28 21:21:24 smurph Exp $	*/
a92 7

extern unsigned cache_policy;
extern unsigned cpu_sets[];
extern unsigned number_cpus;
extern unsigned master_cpu;
extern int      cpu_cmmu_ratio;
int init_done;
@


1.3
log
@mvme88k updates to -current.  finally!
@
text
@d1 1
a1 1
/*	$OpenBSD: m197_cmmu.c,v 1.2 2000/03/03 00:54:53 todd Exp $	*/
a59 2
#ifdef MVME197

a97 1
extern int      max_cpus, max_cmmus;
a806 4

#endif /* MVME197 */


@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD: m197_cmmu.c,v 1.1 1999/09/27 19:13:22 smurph Exp $	*/
d112 2
a113 2
   union apr_template apr_template;
   apr_template.bits = value;
d115 7
a121 7
   printf("table @@ 0x%x000", apr_template.field.st_base);
   if (apr_template.field.wt) printf(", writethrough");
   if (apr_template.field.g)  printf(", global");
   if (apr_template.field.ci) printf(", cache inhibit");
   if (apr_template.field.te) printf(", valid");
   else                       printf(", not valid");
   printf("\n");
d127 15
a141 15
   union {
      unsigned bits;
      struct {
         unsigned :16,
         pe: 1,
         se: 1,
         pr: 1,
         :13;
      } fields;
   } sctr; 
   sctr.bits = value;
   printf("%spe, %sse %spr]\n",
          sctr.fields.pe ? "" : "!",
          sctr.fields.se ? "" : "!",
          sctr.fields.pr ? "" : "!");
d148 3
a150 3
   /* dummy routine */
   m197_setup_cmmu_config();
   return;
d156 3
a158 3
   /* we can print something here... */
   cpu_sets[0] = 1;   /* This cpu installed... */
   return;
d163 2
a164 2
   /* dummy routine */
   return;
d173 2
a174 1
int m197_cmmu_alive(int mmu)
d179 2
a180 1
unsigned m197_cmmu_get(int mmu, int reg)
d190 2
a191 1
void m197_cmmu_set(int reg, unsigned val, int flags,
d203 1
a203 1
   return 0;
d212 2
a213 1
void m197_cpu_configuration_print(int master)
d215 20
a234 20
   int pid = read_processor_identification_register();
   int proctype = (pid & 0xff00) >> 8;
   int procvers = (pid & 0xe) >> 1;
   int mmu, cpu = cpu_number();
   struct simplelock print_lock;

   if (master)
      simple_lock_init(&print_lock);

   simple_lock(&print_lock);

   printf("Processor %d: ", cpu);
   if (proctype)
      printf("Architectural Revision 0x%x UNKNOWN CPU TYPE Version 0x%x\n",
             proctype, procvers);
   else
      printf("M88110 Version 0x%x\n", procvers);
   
   simple_unlock(&print_lock);
   return;
d245 48
a292 48
   int i;
   unsigned tmp;
   extern void *kernel_sdt;
   unsigned lba, pba, value;
   init_done = 0;

   /* clear BATCs */
   for (i=0; i<8; i++) {
      m197_cmmu_set_pair_batc_entry(0, i, 0);
   }
   /* clear PATCs */
   for (i=0; i<32; i++) {
      m197_load_patc(i, 0, 0, 0);
   }
   set_ictl(CMMU_ICTL_DID         /* Double instruction disable */
            | CMMU_ICTL_MEN
            | CMMU_ICTL_HTEN);
            

   set_dctl(CMMU_DCTL_MEN
            | CMMU_DCTL_HTEN);      

   set_icmd(CMMU_ICMD_INV_ITIC);  /* clear instruction cache */
   set_dcmd(CMMU_DCMD_INV_ALL);   /* clear data cache */

   tmp = (0x00000 << 12) | /* segment table base address */
      AREA_D_WT |       /* write through */
      AREA_D_G  |       /* global */
      ! AREA_D_TE ;     /* not translation enable */
   
   set_isap(tmp);
   set_dsap(tmp);

   set_isr(0);
   set_ilar(0);
   set_ipar(0);
   set_dsr(0);
   set_dlar(0);
   set_dpar(0);
   
   lba = pba = (unsigned)&kernel_sdt;
   lba &= ~0x7FFFF;
   pba = pba >> 13;
   pba &= ~0x3F;
   value = lba | pba | 0x20 | 0x01;
   
   m197_cmmu_set_pair_batc_entry(0, 0, value);
 
a294 1

d301 2
a302 2
   unsigned tmp;
   unsigned cmmu_num;
d309 2
a310 1
void m197_cmmu_parity_enable(void)
d323 2
a324 1
unsigned m197_cmmu_cpu_number(void)
d326 1
a326 1
   return 0; /* to make compiler happy */
d338 1
a338 1
   panic("m197_cmmu_remote_set() called!\n");
d351 2
a352 2
   panic("m197_cmmu_remote_get() called!\n");
   return 0;
d359 1
a359 1
   return 0; /* todo */
d365 21
a385 21
   unsigned result;
   if (data) {
      set_dsar((unsigned)va);
      set_dcmd(CMMU_DCMD_PRB_SUPR);
      result = get_dsr();
      if (result & CMMU_DSR_PH) 
         return 1;
      else
         return 0;
   } else {
      set_isar((unsigned)va);
      set_icmd(CMMU_ICMD_PRB_SUPR);
      result = get_isr();
      if (result & CMMU_ISR_BH) 
         return 2;
      else if (result & CMMU_ISR_PH) 
         return 1;
      else
         return 0;
   }
   return 0;
d391 19
a409 19
   int result;
   set_icmd(CMMU_ICMD_INV_SATC);
   set_dcmd(CMMU_DCMD_INV_SATC);
   /* load an entry pointing to seg table into PATC */
   /* Don't forget to set it valid */
   
   m197_load_patc(0, (vm_offset_t)ap, (vm_offset_t)(ap | 0x1), 1);
   if(!(result = probe_mmu((vm_offset_t) ap, 1))){
      printf("Didn't make it!!!!\n");
      return;
   } else {
      if (result == 2)
         printf("area pointer is in BATC.\n");
      if (result == 1)
         printf("area pointer is in PATC.\n");
   }
   
   set_isap(ap);
   set_dsap(ap);
d415 1
a415 1
   m197_cmmu_set_sapr(ap);
d421 2
a422 2
   set_iuap(ap);
   set_duap(ap);
d435 12
a446 12
                   unsigned cpu,
                   unsigned entry_no,
                   unsigned data,   /* 1 = data, 0 = instruction */
                   unsigned value)  /* the value to stuff */
{
   if (data) {
      set_dir(entry_no);
      set_dbp(value);
   } else {
      set_iir(entry_no);
      set_ibp(value);
   }
d457 2
a458 2
   m197_cmmu_set_batc_entry(cpu, entry_no, 1, value);
   m197_cmmu_set_batc_entry(cpu, entry_no, 0, value);
d472 9
a480 9
   register s = splhigh();
   if (kernel) {
      set_icmd(CMMU_ICMD_INV_SATC);
      set_dcmd(CMMU_DCMD_INV_SATC);
   } else {
      set_icmd(CMMU_ICMD_INV_UATC);
      set_dcmd(CMMU_DCMD_INV_UATC);
   }
   splx(s);
d489 3
a491 3
   int cpu;
   cpu = cpu_number();
   m197_cmmu_flush_remote_tlb(cpu, kernel, vaddr, size);
d501 22
a522 22
                  unsigned cpu,
                  unsigned uapr,
                  batc_template_t i_batc[BATC_MAX],
                  batc_template_t d_batc[BATC_MAX])
{
   int entry_no;

   m197_cmmu_set_uapr(uapr);

   /*
   for (entry_no = 0; entry_no < 8; entry_no++) {
      m197_cmmu_set_batc_entry(cpu, entry_no, 0, i_batc[entry_no].bits);
      m197_cmmu_set_batc_entry(cpu, entry_no, 1, d_batc[entry_no].bits);
   }
   */
   /*
    * Flush the user TLB.
    * IF THE KERNEL WILL EVER CARE ABOUT THE BATC ENTRIES,
    * THE SUPERVISOR TLBs SHOULB EE FLUSHED AS WELL.
    */
   set_icmd(CMMU_ICMD_INV_UATC);
   set_dcmd(CMMU_DCMD_INV_UATC);
d544 4
a547 4
   register s = splhigh();
   set_icmd(CMMU_ICMD_INV_ITIC);
   set_dcmd(CMMU_DCMD_FLUSH_ALL_INV);
   splx(s);
d556 2
a557 2
   int cpu = cpu_number();
   m197_cmmu_flush_remote_cache(cpu, physaddr, size);
d566 3
a568 3
   register s = splhigh();
   
   set_icmd(CMMU_ICMD_INV_ITIC);
d570 1
a570 1
   splx(s);
d579 3
a581 3
   int cpu;
   cpu = cpu_number();
   m197_cmmu_flush_remote_inst_cache(cpu, physaddr, size);
d590 3
a592 3
   register s = splhigh();
   set_dcmd(CMMU_DCMD_FLUSH_ALL_INV);
   splx(s);
d601 3
a603 3
   int cpu;
   cpu = cpu_number();
   m197_cmmu_flush_remote_data_cache(cpu, physaddr, size);
d612 5
a616 5
   register s = splhigh();
   int cpu;
   cpu = cpu_number();
   /* set_mmureg(CMMU_ICTL, CMMU_ICMD_INV_TIC); */ 
   set_dcmd(CMMU_DCMD_FLUSH_ALL);
d618 1
a618 1
   splx(s);
d624 3
a626 3
   register s = splhigh();
   int cpu;
   cpu = cpu_number();
d628 2
a629 2
   set_dcmd(CMMU_DCMD_FLUSH_ALL_INV);
   splx(s);
d635 6
a640 6
   register s = splhigh();
   int cpu;
   cpu = cpu_number();
   set_icmd(CMMU_ICMD_INV_ITIC);
   set_dcmd(CMMU_DCMD_INV_ALL);
   splx(s);
d646 7
a652 7
   int count;
   if (op == DMA_CACHE_SYNC)
      m197_cmmu_sync_cache(kvtop(va), size);
   else if (op == DMA_CACHE_SYNC_INVAL)
      m197_cmmu_sync_inval_cache(kvtop(va), size);
   else
      m197_cmmu_inval_cache(kvtop(va), size);
d682 19
a700 20
m197_cmmu_show_translation(
                     unsigned address,
                     unsigned supervisor_flag,
                     unsigned verbose_flag,
                     int cmmu_num)
{
   /*
    * A virtual address is split into three fields. Two are used as
    * indicies into tables (segment and page), and one is an offset into
    * a page of memory.
    */
   union {
      unsigned bits;
      struct {
         unsigned segment_table_index:10,
         page_table_index:10,
         page_offset:12;
      } field;
   } virtual_address;
   unsigned value;
d702 2
a703 2
   if (verbose_flag)
      db_printf("-------------------------------------------\n");
d711 3
a713 3
   static char *vv_name[4] =
   {"exclu-unmod", "exclu-mod", "shared-unmod", "invalid"};
   int cmmu_num;
d719 2
a720 2
   int cmmu_num;
   m197_cmmu_cache_state(addr, 1);
d729 14
a742 14
   unsigned lpa, pfa, i;
   
   lpa = (unsigned)vaddr & 0xFFFFF000;
   if (kernel) {
      lpa |= 0x01;
   }
   pfa = (unsigned)paddr;
   i = entry << 5;
   set_iir(i);
   set_ippu(lpa);
   set_ippl(pfa);
   set_dir(i);
   set_dppu(lpa);
   set_dppl(lpa);
d753 56
a808 56
   sdt_entry_t *sdt;
   pt_entry_t  *pte;
   unsigned lpa, pfa, i;
   static entry_num = 0;

   if (map == (pmap_t)0)
      panic("m197_table_search: pmap is NULL");

   sdt = SDTENT(map, virt);

   /*
    * Check whether page table exist or not.
    */
   if (!SDT_VALID(sdt))
      return (4); /* seg fault */
   
   /* OK, it's valid.  Now check permissions. */
   if (!kernel)
      if (SDT_SUP(sdt))
         return (6); /* Supervisor Violation */
   if (write)
      if (SDT_WP(sdt))
         return (7); /* Write Violation */
   
   else
   pte = (pt_entry_t *)(((sdt + SDT_ENTRIES)->table_addr)<<PDT_SHIFT) + PDTIDX(virt);
   /*
    * Check whether page frame exist or not.
    */
   if (!PDT_VALID(pte))
      return (5); /* Page Fault */
   
   /* OK, it's valid.  Now check permissions. */
   if (!kernel)
      if (PDT_SUP(sdt))
         return (6); /* Supervisor Violation */
   if (write)
      if (PDT_WP(sdt))
         return (7); /* Write Violation */
   /* If we get here, load the PATC. */
   if (entry_num > 32) 
      entry_num = 0;
   lpa = (unsigned)virt & 0xFFFFF000;
   if (kernel) 
      lpa |= 0x01;
   i = entry_num << 5;
   if (data) {
      set_dir(i); /* set PATC index */
      set_dppu(lpa); /* set logical address */
      set_dppl((unsigned)pte); /* set page fram address */
   } else {
      set_iir(i);
      set_ippu(lpa);
      set_ippl((unsigned)pte);
   }
   return 0;
@


1.1
log
@Added to support MVME188 and MVME197
@
text
@d1 1
a31 1
 *	$Id: cmmu.c,v 1.4 1998/12/15 05:11:01 smurph Exp $
@


1.1.4.1
log
@Sync with -current
@
text
@a0 1
/*	$OpenBSD$	*/
d31 1
@


1.1.4.2
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: m197_cmmu.c,v 1.3 2000/12/28 21:21:24 smurph Exp $	*/
d112 2
a113 2
	union apr_template apr_template;
	apr_template.bits = value;
d115 7
a121 7
	printf("table @@ 0x%x000", apr_template.field.st_base);
	if (apr_template.field.wt) printf(", writethrough");
	if (apr_template.field.g)  printf(", global");
	if (apr_template.field.ci) printf(", cache inhibit");
	if (apr_template.field.te) printf(", valid");
	else			   printf(", not valid");
	printf("\n");
d127 15
a141 15
	union {
		unsigned bits;
		struct {
			unsigned :16,
			pe: 1,
			se: 1,
			pr: 1,
			:13;
		} fields;
	} sctr; 
	sctr.bits = value;
	printf("%spe, %sse %spr]\n",
	       sctr.fields.pe ? "" : "!",
	       sctr.fields.se ? "" : "!",
	       sctr.fields.pr ? "" : "!");
d148 3
a150 3
	/* dummy routine */
	m197_setup_cmmu_config();
	return;
d156 3
a158 3
	/* we can print something here... */
	cpu_sets[0] = 1;   /* This cpu installed... */
	return;
d163 2
a164 2
	/* dummy routine */
	return;
d173 1
a173 2
int 
m197_cmmu_alive(int mmu)
d178 1
a178 2
unsigned 
m197_cmmu_get(int mmu, int reg)
d188 1
a188 2
void 
m197_cmmu_set(int reg, unsigned val, int flags,
d200 1
a200 1
	return 0;
d209 1
a209 2
void 
m197_cpu_configuration_print(int master)
d211 20
a230 20
	int pid = read_processor_identification_register();
	int proctype = (pid & 0xff00) >> 8;
	int procvers = (pid & 0xe) >> 1;
	int mmu, cpu = cpu_number();
	struct simplelock print_lock;

	if (master)
		simple_lock_init(&print_lock);

	simple_lock(&print_lock);

	printf("Processor %d: ", cpu);
	if (proctype)
		printf("Architectural Revision 0x%x UNKNOWN CPU TYPE Version 0x%x\n",
		       proctype, procvers);
	else
		printf("M88110 Version 0x%x\n", procvers);

	simple_unlock(&print_lock);
	return;
d241 49
a289 47
	int i;
	unsigned tmp;
	extern void *kernel_sdt;
	unsigned lba, pba, value;
	init_done = 0;

	/* clear BATCs */
	for (i=0; i<8; i++) {
		m197_cmmu_set_pair_batc_entry(0, i, 0);
	}
	/* clear PATCs */
	for (i=0; i<32; i++) {
		m197_load_patc(i, 0, 0, 0);
	}
	set_ictl(CMMU_ICTL_DID	       /* Double instruction disable */
		 | CMMU_ICTL_MEN
		 | CMMU_ICTL_HTEN);


	set_dctl(CMMU_DCTL_MEN
		 | CMMU_DCTL_HTEN);      

	set_icmd(CMMU_ICMD_INV_ITIC);  /* clear instruction cache */
	set_dcmd(CMMU_DCMD_INV_ALL);   /* clear data cache */

	tmp = (0x00000 << 12) |	/* segment table base address */
	      AREA_D_WT |	/* write through */
	      AREA_D_G  |	/* global */
	      ! AREA_D_TE ;	/* not translation enable */

	set_isap(tmp);
	set_dsap(tmp);

	set_isr(0);
	set_ilar(0);
	set_ipar(0);
	set_dsr(0);
	set_dlar(0);
	set_dpar(0);

	lba = pba = (unsigned)&kernel_sdt;
	lba &= ~0x7FFFF;
	pba = pba >> 13;
	pba &= ~0x3F;
	value = lba | pba | 0x20 | 0x01;

	m197_cmmu_set_pair_batc_entry(0, 0, value);
a290 1
}
d298 2
a299 2
	unsigned tmp;
	unsigned cmmu_num;
d306 1
a306 2
void 
m197_cmmu_parity_enable(void)
d319 1
a319 2
unsigned 
m197_cmmu_cpu_number(void)
d321 1
a321 1
	return 0; /* to make compiler happy */
d333 1
a333 1
	panic("m197_cmmu_remote_set() called!\n");
d346 2
a347 2
	panic("m197_cmmu_remote_get() called!\n");
	return 0;
d354 1
a354 1
	return 0; /* todo */
d360 21
a380 21
	unsigned result;
	if (data) {
		set_dsar((unsigned)va);
		set_dcmd(CMMU_DCMD_PRB_SUPR);
		result = get_dsr();
		if (result & CMMU_DSR_PH)
			return 1;
		else
			return 0;
	} else {
		set_isar((unsigned)va);
		set_icmd(CMMU_ICMD_PRB_SUPR);
		result = get_isr();
		if (result & CMMU_ISR_BH)
			return 2;
		else if (result & CMMU_ISR_PH)
			return 1;
		else
			return 0;
	}
	return 0;
d386 19
a404 19
	int result;
	set_icmd(CMMU_ICMD_INV_SATC);
	set_dcmd(CMMU_DCMD_INV_SATC);
	/* load an entry pointing to seg table into PATC */
	/* Don't forget to set it valid */

	m197_load_patc(0, (vm_offset_t)ap, (vm_offset_t)(ap | 0x1), 1);
	if (!(result = probe_mmu((vm_offset_t) ap, 1))) {
		printf("Didn't make it!!!!\n");
		return;
	} else {
		if (result == 2)
			printf("area pointer is in BATC.\n");
		if (result == 1)
			printf("area pointer is in PATC.\n");
	}

	set_isap(ap);
	set_dsap(ap);
d410 1
a410 1
	m197_cmmu_set_sapr(ap);
d416 2
a417 2
	set_iuap(ap);
	set_duap(ap);
d430 12
a441 12
			unsigned cpu,
			unsigned entry_no,
			unsigned data,	 /* 1 = data, 0 = instruction */
			unsigned value)	 /* the value to stuff */
{
	if (data) {
		set_dir(entry_no);
		set_dbp(value);
	} else {
		set_iir(entry_no);
		set_ibp(value);
	}
d452 2
a453 2
	m197_cmmu_set_batc_entry(cpu, entry_no, 1, value);
	m197_cmmu_set_batc_entry(cpu, entry_no, 0, value);
d467 9
a475 9
	register s = splhigh();
	if (kernel) {
		set_icmd(CMMU_ICMD_INV_SATC);
		set_dcmd(CMMU_DCMD_INV_SATC);
	} else {
		set_icmd(CMMU_ICMD_INV_UATC);
		set_dcmd(CMMU_DCMD_INV_UATC);
	}
	splx(s);
d484 3
a486 3
	int cpu;
	cpu = cpu_number();
	m197_cmmu_flush_remote_tlb(cpu, kernel, vaddr, size);
d496 22
a517 22
		       unsigned cpu,
		       unsigned uapr,
		       batc_template_t i_batc[BATC_MAX],
		       batc_template_t d_batc[BATC_MAX])
{
	int entry_no;

	m197_cmmu_set_uapr(uapr);

	/*
	for (entry_no = 0; entry_no < 8; entry_no++) {
	   m197_cmmu_set_batc_entry(cpu, entry_no, 0, i_batc[entry_no].bits);
	   m197_cmmu_set_batc_entry(cpu, entry_no, 1, d_batc[entry_no].bits);
	}
	*/
	/*
	 * Flush the user TLB.
	 * IF THE KERNEL WILL EVER CARE ABOUT THE BATC ENTRIES,
	 * THE SUPERVISOR TLBs SHOULB EE FLUSHED AS WELL.
	 */
	set_icmd(CMMU_ICMD_INV_UATC);
	set_dcmd(CMMU_DCMD_INV_UATC);
d539 4
a542 4
	register s = splhigh();
	set_icmd(CMMU_ICMD_INV_ITIC);
	set_dcmd(CMMU_DCMD_FLUSH_ALL_INV);
	splx(s);
d551 2
a552 2
	int cpu = cpu_number();
	m197_cmmu_flush_remote_cache(cpu, physaddr, size);
d561 3
a563 3
	register s = splhigh();

	set_icmd(CMMU_ICMD_INV_ITIC);
d565 1
a565 1
	splx(s);
d574 3
a576 3
	int cpu;
	cpu = cpu_number();
	m197_cmmu_flush_remote_inst_cache(cpu, physaddr, size);
d585 3
a587 3
	register s = splhigh();
	set_dcmd(CMMU_DCMD_FLUSH_ALL_INV);
	splx(s);
d596 3
a598 3
	int cpu;
	cpu = cpu_number();
	m197_cmmu_flush_remote_data_cache(cpu, physaddr, size);
d607 5
a611 5
	register s = splhigh();
	int cpu;
	cpu = cpu_number(); 
	/* set_mmureg(CMMU_ICTL, CMMU_ICMD_INV_TIC); */
	set_dcmd(CMMU_DCMD_FLUSH_ALL);
d613 1
a613 1
	splx(s);
d619 3
a621 3
	register s = splhigh();
	int cpu;
	cpu = cpu_number();
d623 2
a624 2
	set_dcmd(CMMU_DCMD_FLUSH_ALL_INV);
	splx(s);
d630 6
a635 6
	register s = splhigh();
	int cpu;
	cpu = cpu_number();
	set_icmd(CMMU_ICMD_INV_ITIC);
	set_dcmd(CMMU_DCMD_INV_ALL);
	splx(s);
d641 7
a647 7
	int count;
	if (op == DMA_CACHE_SYNC)
		m197_cmmu_sync_cache(kvtop(va), size);
	else if (op == DMA_CACHE_SYNC_INVAL)
		m197_cmmu_sync_inval_cache(kvtop(va), size);
	else
		m197_cmmu_inval_cache(kvtop(va), size);
d677 20
a696 19
m197_cmmu_show_translation(unsigned address,
		unsigned supervisor_flag,
		unsigned verbose_flag,
		int cmmu_num)
{
	/*
	 * A virtual address is split into three fields. Two are used as
	 * indicies into tables (segment and page), and one is an offset into
	 * a page of memory.
	 */
	union {
		unsigned bits;
		struct {
			unsigned segment_table_index:10,
			page_table_index:10,
			page_offset:12;
		} field;
	} virtual_address;
	unsigned value;
d698 2
a699 2
	if (verbose_flag)
		db_printf("-------------------------------------------\n");
d707 3
a709 3
	static char *vv_name[4] =
	{"exclu-unmod", "exclu-mod", "shared-unmod", "invalid"};
	int cmmu_num;
d715 2
a716 2
	int cmmu_num;
	m197_cmmu_cache_state(addr, 1);
d725 14
a738 14
	unsigned lpa, pfa, i;

	lpa = (unsigned)vaddr & 0xFFFFF000;
	if (kernel) {
		lpa |= 0x01;
	}
	pfa = (unsigned)paddr;
	i = entry << 5;
	set_iir(i);
	set_ippu(lpa);
	set_ippl(pfa);
	set_dir(i);
	set_dppu(lpa);
	set_dppl(lpa);
d749 56
a804 56
	sdt_entry_t *sdt;
	pt_entry_t  *pte;
	unsigned lpa, pfa, i;
	static entry_num = 0;

	if (map == (pmap_t)0)
		panic("m197_table_search: pmap is NULL");

	sdt = SDTENT(map, virt);

	/*
	 * Check whether page table exist or not.
	 */
	if (!SDT_VALID(sdt))
		return (4); /* seg fault */

	/* OK, it's valid.  Now check permissions. */
	if (!kernel)
		if (SDT_SUP(sdt))
			return (6); /* Supervisor Violation */
	if (write)
		if (SDT_WP(sdt))
			return (7); /* Write Violation */

		else
			pte = (pt_entry_t *)(((sdt + SDT_ENTRIES)->table_addr)<<PDT_SHIFT) + PDTIDX(virt);
	/*
	 * Check whether page frame exist or not.
	 */
	if (!PDT_VALID(pte))
		return (5); /* Page Fault */

	/* OK, it's valid.  Now check permissions. */
	if (!kernel)
		if (PDT_SUP(sdt))
			return (6); /* Supervisor Violation */
	if (write)
		if (PDT_WP(sdt))
			return (7); /* Write Violation */
		/* If we get here, load the PATC. */
	if (entry_num > 32)
		entry_num = 0;
	lpa = (unsigned)virt & 0xFFFFF000;
	if (kernel)
		lpa |= 0x01;
	i = entry_num << 5;
	if (data) {
		set_dir(i); /* set PATC index */
		set_dppu(lpa); /* set logical address */
		set_dppl((unsigned)pte); /* set page fram address */
	} else {
		set_iir(i);
		set_ippu(lpa);
		set_ippl((unsigned)pte);
	}
	return 0;
@


1.1.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: m197_cmmu.c,v 1.1.4.2 2001/04/18 16:11:35 niklas Exp $	*/
d60 2
a64 1

a67 1
#include <machine/locore.h>
d70 1
a70 3
#ifdef DDB
#include <ddb/db_output.h>
#endif
d73 1
a73 1
#define DB_CMMU		0x4000	/* MMU debug */
d75 1
a75 1
#define dprintf(_L_,_X_) { if (debuglevel & (_L_)) { unsigned int psr = disable_interrupts_return_psr(); printf("%d: ", cpu_number()); printf _X_;  set_psr(psr); } }
d77 1
a77 1
#define dprintf(_L_,_X_)
a78 1

a88 10
/* prototypes */
void m197_cmmu_store __P((int, int, unsigned));
int m197_cmmu_alive __P((int));
unsigned m197_cmmu_get __P((int, int));
void m197_cmmu_set __P((int, unsigned, int, int, int, int, vm_offset_t));
int probe_mmu __P((vm_offset_t, int));
void m197_cmmu_sync_cache __P((vm_offset_t, int));
void m197_cmmu_sync_inval_cache __P((vm_offset_t, int));
void m197_cmmu_inval_cache __P((vm_offset_t, int));

d96 12
d167 2
a168 1
void
d182 2
a183 1
   return 0;
d218 1
a218 1
	int cpu = cpu_number();
d249 1
d301 3
d330 1
a330 1
 **	Functions that actually modify CMMU registers.
d332 3
d338 1
a338 1
	panic("m197_cmmu_remote_set() called!");
d345 3
d351 1
a351 1
	panic("m197_cmmu_remote_get() called!");
d472 1
a472 1
	register int s = splhigh();
d506 1
a506 1
	/* int entry_no;*/
d544 1
a544 1
	register int s = splhigh();
d566 1
a566 1
	register int s = splhigh();
d590 1
a590 1
	register int s = splhigh();
d612 1
a612 1
	register int s = splhigh();
d624 1
a624 1
	register int s = splhigh();
d635 1
a635 1
	register int s = splhigh();
d646 1
a691 1
	/*
d700 1
a700 1
	*/
a701 1
#ifdef DDB
d704 1
a704 1
#endif
a710 1
	/*
d713 1
a713 1
	*/
d719 1
d755 2
a756 2
	unsigned lpa, i;
	static int entry_num = 0;
d777 2
a778 2
	pte = (pt_entry_t *)(((sdt + SDT_ENTRIES)->table_addr)<<PDT_SHIFT) + PDTIDX(virt);

d792 1
a792 1
	/* If we get here, load the PATC. */
d810 4
@


1.1.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: m197_cmmu.c,v 1.1.4.3 2001/10/31 03:01:19 nate Exp $	*/
a68 1
#include <machine/m88110_mmu.h>
@


1.1.4.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: m197_cmmu.c,v 1.1.4.4 2001/12/05 00:39:12 niklas Exp $	*/
@


