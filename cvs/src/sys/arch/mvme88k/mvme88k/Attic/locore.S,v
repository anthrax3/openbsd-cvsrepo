head	1.73;
access;
symbols
	OPENBSD_5_5:1.72.0.6
	OPENBSD_5_5_BASE:1.72
	OPENBSD_5_4:1.72.0.2
	OPENBSD_5_4_BASE:1.72
	OPENBSD_5_3:1.70.0.2
	OPENBSD_5_3_BASE:1.70
	OPENBSD_5_2:1.69.0.4
	OPENBSD_5_2_BASE:1.69
	OPENBSD_5_1_BASE:1.69
	OPENBSD_5_1:1.69.0.2
	OPENBSD_5_0:1.67.0.4
	OPENBSD_5_0_BASE:1.67
	OPENBSD_4_9:1.67.0.2
	OPENBSD_4_9_BASE:1.67
	OPENBSD_4_8:1.66.0.4
	OPENBSD_4_8_BASE:1.66
	OPENBSD_4_7:1.66.0.2
	OPENBSD_4_7_BASE:1.66
	OPENBSD_4_6:1.65.0.6
	OPENBSD_4_6_BASE:1.65
	OPENBSD_4_5:1.65.0.4
	OPENBSD_4_5_BASE:1.65
	OPENBSD_4_4:1.61.0.4
	OPENBSD_4_4_BASE:1.61
	OPENBSD_4_3:1.61.0.2
	OPENBSD_4_3_BASE:1.61
	OPENBSD_4_2:1.49.0.6
	OPENBSD_4_2_BASE:1.49
	OPENBSD_4_1:1.49.0.4
	OPENBSD_4_1_BASE:1.49
	OPENBSD_4_0:1.49.0.2
	OPENBSD_4_0_BASE:1.49
	OPENBSD_3_9:1.46.0.2
	OPENBSD_3_9_BASE:1.46
	OPENBSD_3_8:1.41.0.4
	OPENBSD_3_8_BASE:1.41
	OPENBSD_3_7:1.41.0.2
	OPENBSD_3_7_BASE:1.41
	OPENBSD_3_6:1.38.0.2
	OPENBSD_3_6_BASE:1.38
	SMP_SYNC_A:1.35
	SMP_SYNC_B:1.35
	OPENBSD_3_5:1.35.0.2
	OPENBSD_3_5_BASE:1.35
	OPENBSD_3_4:1.30.0.2
	OPENBSD_3_4_BASE:1.30
	UBC_SYNC_A:1.26
	OPENBSD_3_3:1.26.0.2
	OPENBSD_3_3_BASE:1.26
	OPENBSD_3_2:1.25.0.4
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.25.0.2
	OPENBSD_3_1_BASE:1.25
	UBC_SYNC_B:1.25
	UBC:1.23.0.2
	UBC_BASE:1.23
	OPENBSD_3_0:1.20.0.2
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_8:1.9.0.8
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.6
	OPENBSD_2_7_BASE:1.9
	SMP:1.9.0.4
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.5.0.8
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	mvme88kport:1.1.1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@# @;


1.73
date	2014.03.18.22.36.36;	author miod;	state dead;
branches;
next	1.72;

1.72
date	2013.05.17.22.46.28;	author miod;	state Exp;
branches;
next	1.71;

1.71
date	2013.05.17.22.38.25;	author miod;	state Exp;
branches;
next	1.70;

1.70
date	2013.01.05.11.20.56;	author miod;	state Exp;
branches;
next	1.69;

1.69
date	2011.11.19.20.40.10;	author miod;	state Exp;
branches;
next	1.68;

1.68
date	2011.10.09.17.01.34;	author miod;	state Exp;
branches;
next	1.67;

1.67
date	2010.12.23.20.05.08;	author miod;	state Exp;
branches;
next	1.66;

1.66
date	2009.09.20.19.17.47;	author miod;	state Exp;
branches;
next	1.65;

1.65
date	2009.02.21.18.37.48;	author miod;	state Exp;
branches;
next	1.64;

1.64
date	2009.02.21.18.35.22;	author miod;	state Exp;
branches;
next	1.63;

1.63
date	2009.02.08.21.40.58;	author miod;	state Exp;
branches;
next	1.62;

1.62
date	2008.10.30.22.06.59;	author miod;	state Exp;
branches;
next	1.61;

1.61
date	2007.12.22.17.14.39;	author miod;	state Exp;
branches;
next	1.60;

1.60
date	2007.12.20.21.14.07;	author miod;	state Exp;
branches;
next	1.59;

1.59
date	2007.12.09.19.57.51;	author miod;	state Exp;
branches;
next	1.58;

1.58
date	2007.12.05.22.12.30;	author miod;	state Exp;
branches;
next	1.57;

1.57
date	2007.12.04.23.43.54;	author miod;	state Exp;
branches;
next	1.56;

1.56
date	2007.12.02.21.33.23;	author miod;	state Exp;
branches;
next	1.55;

1.55
date	2007.12.02.21.28.40;	author miod;	state Exp;
branches;
next	1.54;

1.54
date	2007.11.15.21.23.16;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2007.11.14.23.12.46;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2007.11.06.21.42.56;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2007.10.28.19.45.52;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2007.10.10.15.53.52;	author art;	state Exp;
branches;
next	1.49;

1.49
date	2006.05.08.14.03.35;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2006.05.06.22.16.28;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2006.04.18.22.08.05;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2005.12.11.21.45.31;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2005.12.03.18.20.51;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2005.12.03.14.30.06;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2005.10.12.19.32.19;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2005.10.12.19.05.44;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2004.12.24.22.50.30;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2004.11.09.21.50.01;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2004.10.01.20.20.36;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2004.08.25.08.00.08;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2004.08.09.20.52.11;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2004.07.02.14.40.22;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2004.01.01.01.11.10;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2003.11.03.06.54.26;	author david;	state Exp;
branches;
next	1.33;

1.33
date	2003.10.15.17.48.36;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2003.10.15.17.22.31;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2003.09.20.13.57.37;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2003.08.20.20.33.47;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2003.08.13.08.52.44;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2003.08.11.20.45.17;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2003.08.03.23.34.09;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2003.01.14.03.20.16;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2001.12.22.19.27.48;	author smurph;	state Exp;
branches;
next	1.24;

1.24
date	2001.12.22.19.15.40;	author smurph;	state Exp;
branches;
next	1.23;

1.23
date	2001.12.19.07.04.41;	author smurph;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2001.12.16.23.49.46;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2001.12.13.08.55.52;	author smurph;	state Exp;
branches;
next	1.20;

1.20
date	2001.08.31.01.41.33;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2001.08.24.22.53.14;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2001.08.15.21.27.20;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.14.21.30.45;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.20.05.53.09;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2001.04.29.19.00.02;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.12.22.56.17;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2001.03.09.05.44.41;	author smurph;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.07.23.40.35;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.12.08.16.24;	author smurph;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.01.03.38.20;	author smurph;	state Exp;
branches;
next	1.9;

1.9
date	99.09.27.19.13.22;	author smurph;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	99.05.29.04.41.46;	author smurph;	state Exp;
branches;
next	1.7;

1.7
date	99.02.09.06.36.28;	author smurph;	state Exp;
branches;
next	1.6;

1.6
date	98.12.15.05.11.01;	author smurph;	state Exp;
branches;
next	1.5;

1.5
date	97.05.24.03.02.30;	author rahnds;	state Exp;
branches;
next	1.4;

1.4
date	97.03.03.20.21.36;	author rahnds;	state Exp;
branches;
next	1.3;

1.3
date	97.03.03.19.08.05;	author rahnds;	state dead;
branches;
next	1.2;

1.2
date	97.02.15.17.40.26;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.12.32.23;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.03.03.19.32.17;	author rahnds;	state Exp;
branches;
next	;

1.9.4.1
date	2001.04.18.16.11.33;	author niklas;	state Exp;
branches;
next	1.9.4.2;

1.9.4.2
date	2001.07.04.10.20.12;	author niklas;	state Exp;
branches;
next	1.9.4.3;

1.9.4.3
date	2001.10.31.03.01.19;	author nate;	state Exp;
branches;
next	1.9.4.4;

1.9.4.4
date	2002.03.06.02.04.45;	author niklas;	state Exp;
branches;
next	1.9.4.5;

1.9.4.5
date	2003.03.27.23.32.18;	author niklas;	state Exp;
branches;
next	1.9.4.6;

1.9.4.6
date	2004.02.19.10.49.07;	author niklas;	state Exp;
branches;
next	;

1.23.2.1
date	2002.01.31.22.55.19;	author niklas;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	2003.05.19.21.45.53;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.73
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: locore.S,v 1.72 2013/05/17 22:46:28 miod Exp $	*/
/*
 * Copyright (c) 2005, Miodrag Vallat.
 * Copyright (c) 1998 Steve Murphree, Jr.
 * Copyright (c) 1996 Nivas Madhur
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Nivas Madhur.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
/*
 * Mach Operating System
 * Copyright (c) 1993-1991 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON AND OMRON ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON AND OMRON DISCLAIM ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include "assym.h"
#include "ksyms.h"

#include <machine/asm.h>
#include <machine/m88100.h>
#include <machine/param.h>
#include <machine/psl.h>
#include <machine/trap.h>
#include <machine/vmparam.h>

/*
 * The memory looks like:
 *   0x00000 - 0x01000	trap vectors
 *   0x01000 - 0x10000	first 64k used by BUG
 *   0x10000 == start	Boot loader jumps here. (for now, this can
 *			handle only NMAGIC - screwy linker)
 */
	.text

GLOBAL(kernelstart)
GLOBAL(kernel_text)
ASGLOBAL(__start)
	/*
	 * A few identical jump instructions to make sure the pipeline is
	 * in a good state. Probably overkill, but it's cheap.
	 */
	br	_ASM_LABEL(main_start)
	br	_ASM_LABEL(main_start)
	br	_ASM_LABEL(main_start)
	br	_ASM_LABEL(main_start)

	/*
	 * Room for the kernel (post-autoconf) VBR page.
	 * Note this page is in kernel text, in order to be write-protected
	 * by pmap_bootstrap().
	 */
#ifdef __ELF__
	.space	PAGE_SIZE - 4 * 4
#else
	.space	PAGE_SIZE - 4 * 4 - 0x20
#endif

#ifdef M88100
	/*
	 * The 88100 may execute the first instruction of the next trap
	 * handler, as documented in its Errata. Processing trap #511
	 * would then fall into the next page, unless the address computation
	 * wraps, or software traps are exempt from the issue - the Errata
	 * does not provide more detail.
	 * Although the MVME BUG does not add an extra NOP after its VBR page,
	 * it is cheap to add an extra NOP for safety.
	 */
	NOP
#endif

	/*
	 * Startup code for main processor.
	 */
ASLOCAL(main_start)
	/*
	 * Save the arguments passed by the boot loader
	 * 	r2 boot flags
	 *	r3 boot controller physical address
	 *	r4 esym (if applicable)
	 *	r5 start of miniroot (unused)
	 *	r6 end of miniroot (unused)
	 *	r7 ((Clun << 8) | Dlun): encoded bootdev
	 *	r8 board type (0x187, 0x188, 0x197)
	 */
/*
 * (*entry)(flag, bugargs.ctrl_addr, cp, kernel.smini,kernel.emini,
 *  bootdev, brdtyp);
 */
	or.u	%r13, %r0,  %hi16(_C_LABEL(boothowto))
	st	%r2,  %r13, %lo16(_C_LABEL(boothowto))
	or.u	%r13, %r0,  %hi16(_C_LABEL(bootaddr))
	st	%r3,  %r13, %lo16(_C_LABEL(bootaddr))
	or.u	%r13, %r0,  %hi16(_C_LABEL(first_addr))
	st	%r4,  %r13, %lo16(_C_LABEL(first_addr))
#if defined(DDB) || NKSYMS > 0
	or.u	%r13, %r0,  %hi16(_C_LABEL(esym))
	st	%r4,  %r13, %lo16(_C_LABEL(esym))
#endif
	or.u	%r13, %r0,  %hi16(_C_LABEL(bootdev))
	st	%r7,  %r13, %lo16(_C_LABEL(bootdev))
	or.u	%r13, %r0,  %hi16(_C_LABEL(brdtyp))
	st	%r8,  %r13, %lo16(_C_LABEL(brdtyp))

	/* set cputyp */
	ldcr	%r1,  PID
	extu	%r8,  %r1, 8<8>
	or.u	%r13, %r0,  %hi16(_C_LABEL(cputyp))

	bsr.n	_ASM_LABEL(setup_psr)
	 st	%r8,  %r13, %lo16(_C_LABEL(cputyp))

#ifdef MULTIPROCESSOR
	/*
	 * Have curcpu() point at the dummy cpuinfo structure,
	 * and initialize cr17.
	 * This is necessary for early spl*() usage, as well as
	 * mutex diagnostic code.
	 */
	or.u	%r11, %r0,  %hi16(_C_LABEL(dummy_cpu))
	or	%r11, %r11, %lo16(_C_LABEL(dummy_cpu))
	stcr	%r11, CPU

	/*
	 * MVME BUG idles all secondary MPUs upon startup, so at this point
	 * we do not have to compete with them.
	 */
#endif	/* MULTIPROCESSOR */

	/* Switch to startup stack */
	or.u	%r31, %r0,  %hi16(_ASM_LABEL(initstack_end))
	or	%r31, %r31, %lo16(_ASM_LABEL(initstack_end))

	/* ...and to our exception vectors */
#ifdef M88110
#ifdef M88100
	cmp	%r2, %r8, CPU_88110
	bb1	ne, %r2, 1f	/* if it's a 'mc88110, use different vectors */
#endif
	or.u	%r3, %r0, %hi16(_C_LABEL(m88110_vector_list))
	br.n	2f
	 or	%r3, %r3, %lo16(_C_LABEL(m88110_vector_list))
1:
#endif /* M88110 */
#ifdef M88100
	or.u	%r3, %r0, %hi16(_C_LABEL(vector_list))
	or	%r3, %r3, %lo16(_C_LABEL(vector_list))
#endif /* M88100 */
2:
	bsr.n	_C_LABEL(mvme88k_vector_init)
	 ldcr	%r2, VBR

#ifdef MULTIPROCESSOR
	bsr	_C_LABEL(atomic_init)
#endif

	/*
	 * mvme_bootstrap(), among other things, clears proc0's u area.
	 * We are still using the interrupt stack here, thus we are not
	 * affected...
	 */
	bsr	_C_LABEL(mvme_bootstrap)

	/*
	 * ...and we can switch to the u area stack now.
	 */
	ldcr	%r10, CPU
	ld	%r2,  %r10, CI_CURPCB

	/* call main() - no arguments although main() still defines one */
	bsr.n	_C_LABEL(main)
	 addu	%r31, %r2, USPACE

#ifdef MULTIPROCESSOR

	/*
	 * Startup code for secondary processors.
	 * Some of these initializations are very close to main_start; refer
	 * to the comments there for details.
	 */
GLOBAL(secondary_start)
	or.u	%r31, %r0,  %hi16(_ASM_LABEL(slavestack_end))
	bsr.n	_ASM_LABEL(setup_psr)
	 or	%r31, %r31, %lo16(_ASM_LABEL(slavestack_end))

	or.u	%r3,  %r0,  %hi16(_C_LABEL(kernel_vbr))
	ld	%r2,  %r3,  %lo16(_C_LABEL(kernel_vbr))
	stcr	%r2,  VBR
	FLUSH_PIPELINE

	/*
	 * Have curcpu() point at the dummy cpuinfo structure,
	 * and initialize cr17.
	 * This is necessary for early spl*() usage, as well as
	 * mutex diagnostic code.
	 */
	or.u	%r11, %r0,  %hi16(_C_LABEL(dummy_cpu))
	or	%r11, %r11, %lo16(_C_LABEL(dummy_cpu))
	st	%r0,  %r11, CI_FLAGS		/* reset CIF_PRIMARY */
	stcr	%r11, CPU

	/*
	 * While holding the cpu_mutex, the secondary cpu can use the slavestack
	 * to call secondary_pre_main() to determine its cpu number.
	 * After that, however, it should allocate its own stack and switch
	 * to it.
	 */

	bsr	_C_LABEL(secondary_pre_main)	/* set cpu number */

	ldcr	%r1, CPU
	st	%r2,  %r1, CI_CURPCB	/* save stack as curpcb for traps */

	bsr.n	_C_LABEL(secondary_main)
	 addu	%r31, %r2, USPACE		/* switch to startup stack */

#endif	/* MULTIPROCESSOR */

/*
 * Reset code trampoline.
 */
GLOBAL(doboot)
	/*
	 * Switch to interrupt stack and call _doboot to take care of
	 * going to BUG. Need to do this since _doboot turns off the
	 * the MMU and we need to be on a 1-to-1 mapped stack so that
	 * further calls don't get data access exceptions.
	 */
	or.u	%r31, %r0,  %hi16(_ASM_LABEL(initstack_end))
	bsr.n	_C_LABEL(_doboot)
	 or	%r31, %r31, %lo16(_ASM_LABEL(initstack_end))
	/*NOTREACHED*/

/* 
 * void dumb_delay(int us)
 *
 * The processor loops (busy waits) for the given number of microseconds:
 * Thus, delay(1000000) will delay for one second.
 * (originally from Mach 2.5) 
 */
GLOBAL(dumb_delay)
	bcnd	eq0, %r2, 2f
	or.u	%r3, %r0, %hi16(_C_LABEL(dumb_delay_const))
	ld	%r3, %r3, %lo16(_C_LABEL(dumb_delay_const))
	mul	%r4, %r2, %r3
	subu	%r4, %r4, 4	/* overhead of these instructions */

	/* now loop for the given number of cycles */
1: 
	bcnd.n	gt0, %r4, 1b
	 subu	%r4, %r4, 2	/* two cycles per iteration */
2:
	jmp	%r1

/*****************************************************************************/

	.data
	.balign	PAGE_SIZE
GLOBAL(kernel_sdt)		/* SDT (segment descriptor table */
	.space	0x2000		/* 8K - 4K phys, 4K virt*/

	.balign	PAGE_SIZE
ASGLOBAL(initstack)
	.space	USPACE
ASGLOBAL(initstack_end)

#ifdef MULTIPROCESSOR
	.space	PAGE_SIZE	/* 4K, small, interim stack */
ASLOCAL(slavestack_end)
#endif

/*
 * Process 0's u.
 * Should be page aligned.
 */
	.balign	PAGE_SIZE
ASLOCAL(u0)
	.space	USPACE

GLOBAL(proc0paddr)
	.word	_ASM_LABEL(u0)	/*  KVA of proc0 uarea */

#if defined(DDB) || NKSYMS > 0
GLOBAL(esym)
	.word 	0
#endif /* DDB || NKSYMS > 0 */
@


1.72
log
@Replace the bunch of md_* function pointers with a `struct board' containing
function pointers for all the board-specific code.

Add a bunch of `struct board' methods to cover most, if not all, of the
`per-board' logic. This allows most of the md drivers to be cleaned up and
no longer need to embed board-specific knowledge.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.71 2013/05/17 22:38:25 miod Exp $	*/
@


1.71
log
@Split inittodr/resettodr code from actual tod routines, to allow for
multiple tod routines in the near future.

Use the mi clock_ymdhms_to_secs and clock_secs_to_ymdhms routines.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.70 2013/01/05 11:20:56 miod Exp $	*/
d157 1
d164 2
a165 2
	or.u	%r11, %r0,  %hi16(_ASM_LABEL(dummy_cpu))
	or	%r11, %r11, %lo16(_ASM_LABEL(dummy_cpu))
a167 1
#ifdef MULTIPROCESSOR
d241 2
a242 2
	or.u	%r11, %r0,  %hi16(_ASM_LABEL(dummy_cpu))
	or	%r11, %r11, %lo16(_ASM_LABEL(dummy_cpu))
a260 8
	/*
	 * Dummy mp_atomic_begin() and mp_atomic_end() routine, so that
	 * we can interact with ddb if things go wrong very early during
	 * bootstrap. Of course this should never happen (-:
	 */
ASLOCAL(dummy_mplock)
	jmp	%r1

d264 1
a264 2
 * Reset code.
 * Should be rewritten in C eventually.
a266 19
#ifdef MVME188
	/* check if it's a mvme188 */
	or.u	%r4, %r0, %hi16(_C_LABEL(brdtyp))
	ld	%r3, %r4, %lo16(_C_LABEL(brdtyp))
	cmp	%r4, %r3, BRD_188
	bb1	ne, %r4, 1f
	bsr	_C_LABEL(m188_reset)
	br	8f
1:
#endif	/* MVME188 */
	/*
	 * Try hitting the SRST bit in VMEchip2 to reset the system.
	 */
	or.u	%r3, %r0, 0xfff4
	ld	%r4, %r3, 0x0060	/* read offset (LCSR + 0x60) */
	bb0.n	30, %r4, 1f		/* if not SYSCON, don't SYSRST */
	 set	%r4, %r4, 1<23>		/* set SYSRST bit - bit 23 */
	st	%r4, %r3, 0x0060	/* and store it back  */
1:
d268 1
a268 21
	 * MVME197LE Errata #7:
	 * ``When asserting the RST bit in the VMEchip2 GCSR, the pulse
	 *   generated is too short for the BusSwitch1 to recognize
	 *   properly.''
	 */
#ifdef MVME197
	or.u	%r2, %r0, %hi16(0x20000)
#endif
	ld	%r4, %r3, 0x0104		/* try local reset, then... */
	set	%r4, %r4, 1<7>
	st	%r4, %r3, 0x0104
#ifdef MVME197
	bcnd.n	ne0,%r2, 1b		/* ...for a while */
	 subu	%r2, %r2, 1
#endif

	/*
	 * We will be here if the reset above failed. In this case,
	 * we will try to return to bug.
	 *
	 * Switch to interrupt stack and call _doboot to take care
a272 2

8:
a325 16

/* Dummy cpuinfo structure, for cpu_number() to work early. */
ASLOCAL(dummy_cpu)
	.word	3 /* CIF_ALIVE | CIF_PRIMARY */	/* ci_flags */
	.word	0				/* ci_curproc */
	.word	0				/* ci_curpcb */
	.word	0				/* ci_curpmap */
	.word	0				/* ci_cpuid */
#ifdef MULTIPROCESSOR
	.word	_ASM_LABEL(dummy_mplock)	/* ci_mp_atomic_begin */
	.word	_ASM_LABEL(dummy_mplock)	/* ci_mp_atomic_end */
#else
	.word	0
	.word	0
#endif	/* MULTIPROCESSOR */
	.space	CPU_INFO_SIZEOF - 7 * 4
@


1.70
log
@Switch m88k ports to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.69 2011/11/19 20:40:10 miod Exp $	*/
a327 5
/*
 * MVME188 specific support routines
 */

#ifdef MVME188
d329 1
a329 1
 * void m188_delay(int us)
d335 1
a335 1
GLOBAL(m188_delay)
d337 2
a338 2
	or.u	%r3, %r0, %hi16(_C_LABEL(m188_delay_const))
	ld	%r3, %r3, %lo16(_C_LABEL(m188_delay_const))
a347 1
#endif
@


1.69
log
@Make sure %cr17 points to a valid cpu_info struct before attempting to do the
first few printfs (which happen before we have figured out which exact cpu
we are running on). Found the hard way by aoyama@@ on luna88k, and we probably
have just been lucky on other platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.68 2011/10/09 17:01:34 miod Exp $	*/
d78 1
a78 1
	text
d82 1
a82 1
ASGLOBAL(start)
d93 1
a93 3
	 * Room for the kernel (post-autoconf) VBR page. This is allocating
	 * a bit too much (since kernel_text starts after the a.out header),
	 * but it's a waste we can afford.
d98 1
a98 1
	space	PAGE_SIZE - 4 * 4
d100 1
a100 1
	space	PAGE_SIZE - 4 * 4 - 0x20
d134 6
a139 6
	or.u	r13, r0,  hi16(_C_LABEL(boothowto))
	st	r2,  r13, lo16(_C_LABEL(boothowto))
	or.u	r13, r0,  hi16(_C_LABEL(bootaddr))
	st	r3,  r13, lo16(_C_LABEL(bootaddr))
	or.u	r13, r0,  hi16(_C_LABEL(first_addr))
	st	r4,  r13, lo16(_C_LABEL(first_addr))
d141 2
a142 2
	or.u	r13, r0,  hi16(_C_LABEL(esym))
	st	r4,  r13, lo16(_C_LABEL(esym))
d144 4
a147 4
	or.u	r13, r0,  hi16(_C_LABEL(bootdev))
	st	r7,  r13, lo16(_C_LABEL(bootdev))
	or.u	r13, r0,  hi16(_C_LABEL(brdtyp))
	st	r8,  r13, lo16(_C_LABEL(brdtyp))
d150 3
a152 3
	ldcr	r1,  PID
	extu	r8,  r1, 8<8>
	or.u	r13, r0,  hi16(_C_LABEL(cputyp))
d155 1
a155 1
	 st	r8,  r13, lo16(_C_LABEL(cputyp))
d163 3
a165 3
	or.u	r11, r0,  hi16(_ASM_LABEL(dummy_cpu))
	or	r11, r11, lo16(_ASM_LABEL(dummy_cpu))
	stcr	r11, CPU
d175 2
a176 2
	or.u	r31, r0,  hi16(_ASM_LABEL(initstack_end))
	or	r31, r31, lo16(_ASM_LABEL(initstack_end))
d181 2
a182 2
	cmp	r2, r8, CPU_88110
	bb1	ne, r2, 1f	/* if it's a 'mc88110, use different vectors */
d184 1
a184 1
	or.u	r3, r0, hi16(_C_LABEL(m88110_vector_list))
d186 1
a186 1
	 or	r3, r3, lo16(_C_LABEL(m88110_vector_list))
d190 2
a191 2
	or.u	r3, r0, hi16(_C_LABEL(vector_list))
	or	r3, r3, lo16(_C_LABEL(vector_list))
d195 1
a195 1
	 ldcr	r2, VBR
d211 2
a212 2
	ldcr	r10, CPU
	ld	r2,  r10, CI_CURPCB
d216 1
a216 1
	 addu	r31, r2, USPACE
d226 1
a226 1
	or.u	r31, r0,  hi16(_ASM_LABEL(slavestack_end))
d228 1
a228 1
	 or	r31, r31, lo16(_ASM_LABEL(slavestack_end))
d230 3
a232 3
	or.u	r3,  r0,  hi16(_C_LABEL(kernel_vbr))
	ld	r2,  r3,  lo16(_C_LABEL(kernel_vbr))
	stcr	r2,  VBR
d241 4
a244 4
	or.u	r11, r0,  hi16(_ASM_LABEL(dummy_cpu))
	or	r11, r11, lo16(_ASM_LABEL(dummy_cpu))
	st	r0,  r11, CI_FLAGS		/* reset CIF_PRIMARY */
	stcr	r11, CPU
d255 2
a256 2
	ldcr	r1, CPU
	st	r2,  r1, CI_CURPCB	/* save stack as curpcb for traps */
d259 1
a259 1
	 addu	r31, r2, USPACE			/* switch to startup stack */
d267 1
a267 1
	jmp	r1
d278 4
a281 4
	or.u	r4, r0, hi16(_C_LABEL(brdtyp))
	ld	r3, r4, lo16(_C_LABEL(brdtyp))
	cmp	r4, r3, BRD_188
	bb1	ne, r4, 1f
d289 5
a293 5
	or.u	r3, r0, 0xfff4
	ld	r4, r3, 0x0060		/* read offset (LCSR + 0x60) */
	bb0.n	30, r4, 1f		/* if not SYSCON, don't SYSRST */
	 set	r4, r4, 1<23>		/* set SYSRST bit - bit 23 */
	st	r4, r3, 0x0060		/* and store it back  */
d302 1
a302 1
	or.u	r2, r0, hi16(0x20000)
d304 3
a306 3
	ld	r4, r3, 0x0104		/* try local reset, then... */
	set	r4, r4, 1<7>
	st	r4, r3, 0x0104
d308 2
a309 2
	bcnd.n	ne0,r2, 1b		/* ...for a while */
	 subu	r2, r2, 1
d323 1
a323 1
	or.u	r31, r0,  hi16(_ASM_LABEL(initstack_end))
d325 1
a325 1
	 or	r31, r31, lo16(_ASM_LABEL(initstack_end))
d341 5
a345 5
	bcnd	eq0, r2, 2f
	or.u	r3, r0, hi16(_C_LABEL(m188_delay_const))
	ld	r3, r3, lo16(_C_LABEL(m188_delay_const))
	mul	r4, r2, r3
	subu	r4, r4, 4	/* overhead of these instructions */
d349 2
a350 2
	bcnd.n	gt0, r4, 1b
	 subu	r4, r4, 2	/* two cycles per iteration */
d352 1
a352 1
	jmp	r1
d357 2
a358 2
	data
	.align	PAGE_SIZE
d360 1
a360 1
	space	0x2000		/* 8K - 4K phys, 4K virt*/
d362 1
a362 1
	.align	PAGE_SIZE
d364 1
a364 1
	space	USPACE
d368 1
a368 1
	space	PAGE_SIZE	/* 4K, small, interim stack */
d376 1
a376 1
	.align	PAGE_SIZE
d378 1
a378 1
	space	USPACE
d381 1
a381 1
	word	_ASM_LABEL(u0)	/*  KVA of proc0 uarea */
d385 5
a389 5
	word	3 /* CIF_ALIVE | CIF_PRIMARY */	/* ci_flags */
	word	0				/* ci_curproc */
	word	0				/* ci_curpcb */
	word	0				/* ci_curpmap */
	word	0				/* ci_cpuid */
d391 2
a392 2
	word	_ASM_LABEL(dummy_mplock)	/* ci_mp_atomic_begin */
	word	_ASM_LABEL(dummy_mplock)	/* ci_mp_atomic_end */
d394 2
a395 2
	word	0
	word	0
d397 1
a397 1
	space	CPU_INFO_SIZEOF - 7 * 4
d401 1
a401 1
	word 	0
@


1.68
log
@Rework secondary processor initialization. cmmu initialization is now
performed much earlier in the processor startup.
No visible change, paves the way for the much important diff three commits
from here.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.67 2010/12/23 20:05:08 miod Exp $	*/
a158 1
#ifdef MULTIPROCESSOR
d161 3
a163 3
	 * so that cpu_number() does not dereference random memory.
	 * This is necessary for early spl usage, despite the fact that
	 * interrupts are disabled...
d169 1
d239 3
a241 3
	 * so that cpu_number() does not dereference random memory.
	 * This is necessary for early spl usage, despite the fact that
	 * interrupts are disabled...
a384 1
#ifdef MULTIPROCESSOR
d392 1
d395 4
a398 1

a399 1
#endif	/* MULTIPROCESSOR */
@


1.67
log
@The exception vector page on m88k systems has always been the same page as
the one used by the firmware, which (at least on mvme88k) is at address zero.

This is unfortunate, since this means that NULL pointer dereferences in the
kernel are not caught, and writes cause havoc.

This behaviour was necessary to be able to use the PROM system call interface
during early bootstrap, without having to disassemble the VBR page and
update branches - which use pc-relative displacement - if we were to use
a different VBR address.

On mvme88k, change this and actually set up two VBR pages: one, over the PROM
page (except for the system call vectors), and another one in the kernel
image (which will be mapped read-only). We'll run with the PROM page until
the end of autoconf, and then switch to the kernel one, and unmap all the
PROM below it.

As a bonus, the final kernel page can use optimized data access fault
handlers, which do not have to check for faults caused by badaddr(), since
badaddr() is only used during device probe on buses which do not support
hotplug.

There are a few infrastructure collateral damage on aviion and luna88k, but
these ports do not change their behaviour yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.66 2009/09/20 19:17:47 miod Exp $	*/
a117 1

d232 4
a235 4
	/*
	 * We expect secondary processors to start running with the same 
	 * VBR value as the primary one.
	 */
d245 1
@


1.66
log
@Sync dummy_cpu layout with current struct cpu_info.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.65 2009/02/21 18:37:48 miod Exp $	*/
d93 27
a155 1
	st	r8,  r13, lo16(_C_LABEL(cputyp))
d157 2
a158 4
	bsr	_ASM_LABEL(setup_psr)

	stcr	r0,  VBR	/* set Vector Base Register to 0, ALWAYS! */
	FLUSH_PIPELINE
d181 1
d200 4
d230 2
a231 1
	or	r31, r31, lo16(_ASM_LABEL(slavestack_end))
d233 4
a236 4
	bsr	_ASM_LABEL(setup_psr)

	stcr	r0,  VBR	/* set Vector Base Register to 0, ALWAYS! */
	FLUSH_PIPELINE
d381 1
@


1.65
log
@Move part of the mp lock logic into per-cpu callbacks; on MVME197DP we need
to disable NMI sources in addition to interrupt sources, and we can not
use a quick sequence with shadowing frozen as done for atomic ops.

This lets GENERIC.MP boot multiuser on MVME197DP boards, and is so far stable
enough to be able to recompile a kernel from scratch (with make -j2).
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.64 2009/02/21 18:35:22 miod Exp $	*/
d360 1
d365 1
a365 1
	space	CPU_INFO_SIZEOF - 6 * 4
@


1.64
log
@Get rid of 88110 nmi stacks. This was a good idea, but I outsmarted myself
since it was intended to service NMI occuring in user mode, and we could
end up invoking preempt() and have another cpu start using this stack,
with interesting results.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.63 2009/02/08 21:40:58 miod Exp $	*/
d233 8
d361 4
a364 1
	space	CPU_INFO_SIZEOF - 4 * 4
@


1.63
log
@On 88110 processors, use a separate stack to handle NMI; these can occur
while we are switching pcbs and all sort of bad things could happen.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.62 2008/10/30 22:06:59 miod Exp $	*/
a329 5

#ifdef M88110
GLOBAL(nmi_stack)		/* NMI stack for the boot processor */
	space	USPACE
#endif
@


1.62
log
@Give the dummy struct cpu_info used for secondary processor early bootstrap,
the size of a full blown struct cpu_info, instead of the first few fields.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.61 2007/12/22 17:14:39 miod Exp $	*/
d330 5
@


1.61
log
@Move initial PSR initialization to a separate routine, instead of duplicating
it five times.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.60 2007/12/20 21:14:07 miod Exp $	*/
d353 1
@


1.60
log
@Do not wait for the end of the universe if delay(0).
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.59 2007/12/09 19:57:51 miod Exp $	*/
d131 1
a131 37
	/*
	 * CPU Initialization
	 *
	 * I use r11 and r22 here because they're easy to not
	 * get mixed up -- r10, for example, looks too similar
	 * to r0 when not being careful....
	 *
	 * Ensure that the PSR is as we like:
	 *	supervisor mode
	 *	big-endian byte ordering
	 *	concurrent operation allowed
	 *	carry bit clear (I don't think we really care about this)
	 *	FPU enabled
	 *	misaligned access raises an exception
	 *	interrupts disabled
	 *	shadow registers frozen
	 *
	 * The manual says not to disable interrupts and freeze shadowing
	 * at the same time because interrupts are not actually disabled
	 * until after the next instruction. Well, if an interrupt
	 * occurs now, we're in deep trouble anyway, so I'm going to do
	 * the two together.
	 *
	 * Upon a reset (or poweron, I guess), the PSR indicates:
	 *   supervisor mode
	 *   interrupts, shadowing, FPU, misaligned exception: all disabled
	 *
	 * We'll just construct our own turning on what we want.
	 *
	 *	jfriedl@@omron.co.jp
	 */

	cmp	r2, r8, CPU_88110
	bb1	eq, r2, 1f	/* if it's a 'mc88110, skip SSBR */
	stcr	r0, SSBR	/* clear this for later */
1:
	stcr	r0, SR1		/* clear the CPU flags */
a132 7
	set	r11, r0,  1<PSR_SUPERVISOR_MODE_BIT>
	set	r11, r11, 1<PSR_INTERRUPT_DISABLE_BIT>
	set	r11, r11, 1<PSR_GRAPHICS_DISABLE_BIT>
	clr	r11, r11, 1<PSR_SERIAL_MODE_BIT>
	set	r11, r11, 1<PSR_SERIALIZE_BIT>
	stcr	r11, PSR
	FLUSH_PIPELINE
d203 1
a203 2
	ldcr	r1, PID
	extu	r8,  r1, 8<8>
a204 13
	cmp	r2, r8, CPU_88110
	bb1	eq, r2, 1f
	stcr	r0, SSBR
1:
	stcr	r0, SR1

	set	r11, r0,  1<PSR_SUPERVISOR_MODE_BIT>
	set	r11, r11, 1<PSR_INTERRUPT_DISABLE_BIT>
	set	r11, r11, 1<PSR_GRAPHICS_DISABLE_BIT>
	clr	r11, r11, 1<PSR_SERIAL_MODE_BIT>
	set	r11, r11, 1<PSR_SERIALIZE_BIT>
	stcr	r11, PSR
	FLUSH_PIPELINE
@


1.59
log
@I honestly do not remember what 88110 errata convinced me to disable
out-of-order (superscalar) execution on these processors.

Since OoO brings a nice 50% to 250% speedup (as shown by ``openssl speed''),
it is definitely worth enabling.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.58 2007/12/05 22:12:30 miod Exp $	*/
d362 3
a364 2
	or.u	r3, r0, hi16(_cpuspeed)
	ld	r3, r3, lo16(_cpuspeed)
d372 1
a372 1

@


1.58
log
@Make the CPU_88100 and CPU_88110 constants match the architectural number
field from the processor identification register; this allows .S code which
needs to decide on the cpu type at runtime to check quicker, without needing
to access memory. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.57 2007/12/04 23:43:54 miod Exp $	*/
a171 6
	/*
	 * XXX On 88110 processors, force serial instruction execution for now.
	 * Situation where OoO would break will be hopefully taken care of in
	 * the near future -- miod
	 */
#if 0
a172 3
#else
	set	r11, r11, 1<PSR_SERIAL_MODE_BIT>
#endif
a257 6
	/*
	 * XXX On 88110 processors, force serial instruction execution for now.
	 * Situation where OoO would break will be hopefully taken care of in
	 * the near future -- miod
	 */
#if 0
a258 3
#else
	set	r11, r11, 1<PSR_SERIAL_MODE_BIT>
#endif
@


1.57
log
@Correctly set the stack pointer of a secondary processor to the end
of its initialization stack. Oops.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.56 2007/12/02 21:33:23 miod Exp $	*/
d127 2
a128 10
	extu	r2,  r1, 8<8>
	bcnd.n	eq0, r2, 1f
	 or.u	r13, r0,  hi16(_C_LABEL(cputyp))
	or.u	r8,  r0,  hi16(CPU_88110)
	br.n	2f
	 or	r8,  r8,  lo16(CPU_88110)
1:
	or.u	r8,  r0,  hi16(CPU_88100)
	or	r8,  r8,  lo16(CPU_88100)
2:
d163 1
a163 1
	cmp	r2, r8, CPU_88110	/* r8 contains cputyp */
d211 1
a211 1
	cmp	r2, r8, CPU_88110 /* r8 contains cputyp */
d238 1
a238 1
	ld	r31, r10, CI_CURPCB
d242 1
a242 12
	 addu	r31, r31, USPACE

	or.u	r2, r0, hi16(_ASM_LABEL(main_panic))
	bsr.n	_C_LABEL(panic)
	 or	r2, r2, lo16(_ASM_LABEL(main_panic))

	data
	.align	4
ASLOCAL(main_panic)
	string	"main() returned\0"
	text
	.align	8
d255 2
a256 2
	or.u	r13, r0,  hi16(_C_LABEL(cputyp))
	ld	r8,  r13, lo16(_C_LABEL(cputyp))
@


1.56
log
@Add a workaround for the MVME197LE reset issue when not system controller.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.55 2007/12/02 21:28:40 miod Exp $	*/
d320 4
d325 1
a325 1
	 or	r31, r2, r0			/* switch to startup stack */
@


1.55
log
@Do not pass UPAGES and USPACE (under the name USIZE) in assym.h, code which
needs it includes <machine/param.h> already.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.54 2007/11/15 21:23:16 miod Exp $	*/
d349 10
a358 1
	ld	r4, r3, 0x0104		/* try local reset, then */
d361 4
@


1.54
log
@Stop referring the initial kernel stack as the ``interrupt stack''. It's
been years since it has last been used for that purpose, so name it the
initialization/startup stack.

While there, do not store the initialization stack in cpu_info, and have
secondary_pre_main() return its value so that the bootstrap code does not
need to fetch it from cpu_info.

This might be reconsidered when the startup stacks will be freed after they
are not used anymore, but there are more things to do first.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.53 2007/11/14 23:12:46 miod Exp $	*/
d250 1
a250 1
	 addu	r31, r31, USIZE
d404 1
a404 1
	space	USIZE
d418 1
a418 1
	space	USIZE
@


1.53
log
@Merge the ci_alive and ci_primary boolean values of struct cpu_info into
a single ci_flags bitfield.

Also, set_cpu_number() will no longer set CIF_PRIMARY on the primary processor,
it's up to the initialization code to do this.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.52 2007/11/06 21:42:56 miod Exp $	*/
d213 3
a215 3
	/* Switch to interrupt stack */
	or.u	r31, r0,  hi16(_ASM_LABEL(intstack_end))
	or	r31, r31, lo16(_ASM_LABEL(intstack_end))
a319 3

	ldcr	r2, CPU
	ld	r3, r2, CI_INIT_STACK
d321 1
a321 1
	 addu	r31, r3, USIZE			/* switch to startup stack */
d364 1
a364 1
	or.u	r31, r0,  hi16(_ASM_LABEL(intstack_end))
d366 1
a366 1
	 or	r31, r31, lo16(_ASM_LABEL(intstack_end))
d403 1
a403 1
ASGLOBAL(intstack)
d405 1
a405 1
ASGLOBAL(intstack_end)
@


1.52
log
@Remove the now unused idle_u, and call the secondary processors startup
stack a startup stack.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.51 2007/10/28 19:45:52 miod Exp $	*/
d428 4
a431 4
	word	1	/* ci_alive */
	word	0	/* ci_curproc */
	word	0	/* ci_curpcb */
	word	0	/* ci_cpuid */
@


1.51
log
@Start secondary processors synchronously. This only wins us a nicer dmesg
output, and nothing else.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.50 2007/10/10 15:53:52 art Exp $	*/
d322 1
a322 1
	ld	r3, r2, CI_IDLE_PCB
d324 1
a324 1
	 addu	r31, r3, USIZE			/* switch to idle stack */
a413 8

/*
 * Main processor's idle pcb and stack.
 * Should be page aligned.
 */
	.align	PAGE_SIZE
GLOBAL(idle_u)
	space	USIZE
@


1.50
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.49 2006/05/08 14:03:35 miod Exp $	*/
a311 23
	/*
	 * Since there may be more than one secondary MPU, compete with them
	 * to initialize safely.
	 */
	or.u	r11, r0,  hi16(_C_LABEL(cpu_mutex))
	or	r11, r11, lo16(_C_LABEL(cpu_mutex))
1:
	or	r22, r0,  1
	xmem	r22, r11, r0		/* If r22 gets 0, we have the lock... */
	bcnd	eq0, r22, 4f		/* ...but if not, we must wait */
2:
	/* just watch the lock until it looks clear */
	ld	r22, r11, r0
	bcnd	eq0, r22, 1b
	/* since we can be here with caches off, add a few nops to
	   keep the bus from getting overloaded */
	or	r2,  r0,  lo16(1000)
3:
	subu	r2,  r2,  1
	bcnd	ne0, r2,  3b
	br	1b
4:
	
@


1.49
log
@Clean the internal m88k trap type codes; while there, simplify and
factorize the build of the VBR page betweem luna88k and mvme88k.

Tested by aoyama@@ and I.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.48 2006/05/06 22:16:28 miod Exp $	*/
a347 8

	/*
	 * At this point, the CPU has been correctly initialized and has
	 * identified itself on the console.
	 * All it needs now is to jump to the idle loop and wait for work to
	 * be offered.
	 */
	br	_ASM_LABEL(cpu_switch_idle)
@


1.48
log
@Decide whether we are running on 88100 or 88110 upon the processor
identification register value, rather than upon the MVME board number.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.47 2006/04/18 22:08:05 miod Exp $	*/
d232 1
a232 1
	bsr.n	_C_LABEL(vector_init)
@


1.47
log
@Bring back a kernel_text symbol, config -e needs it.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.46 2005/12/11 21:45:31 miod Exp $	*/
d126 7
a132 5
	cmp	r2,  r8, BRD_197	/* r8 contains brdtyp */
	bb1	ne, r2, 1f	/* if it's a '197, CPU is 88110 */
	or.u	r13, r0,  hi16(CPU_88110)
	or	r8,  r13, lo16(CPU_88110)
	br	2f
d134 2
a135 2
	or.u	r13, r0,  hi16(CPU_88100)
	or	r8,  r13, lo16(CPU_88100)
a136 1
	or.u	r13, r0,  hi16(_C_LABEL(cputyp))
@


1.46
log
@Work in progress SMP code; mvme88k boards can spin up secondary CPUs,
kernel boots single user. Still a lot of polishing and bugfixing to do.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.45 2005/12/03 18:20:51 miod Exp $	*/
d81 1
@


1.45
log
@intstack does not need to be visible from C code anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.44 2005/12/03 14:30:06 miod Exp $	*/
d3 1
a63 2
#include <sys/errno.h>

a64 1
#include <machine/trap.h>
d66 1
d68 1
a68 1
#include <machine/param.h>
a80 2
GLOBAL(kernel_text)
GLOBAL(start)
a81 6
	br	_C_LABEL(start_text)
	br	_C_LABEL(start_text)
	br	_C_LABEL(start_text)
	br	_C_LABEL(start_text)

GLOBAL(doboot)
d83 2
a84 1
	 * Try hitting the SRST bit in VMEchip2 to reset the system.
d86 18
a103 50
#ifdef MVME188
	/* check if it's a mvme188 */
	or.u	r4, r0, hi16(_C_LABEL(brdtyp))
	ld	r3, r4, lo16(_C_LABEL(brdtyp))
	cmp	r4, r3, BRD_188
	bb1	ne, r4, 1f
	bsr	_C_LABEL(m188_reset)
	br	8f
1:
#endif	/* MVME188 */
	or.u	r3, r0, 0xfff4
	ld	r4, r3, 0x0060		/* read offset (LCSR + 0x60) */
	bb0.n	30, r4, 1f		/* if not SYSCON, don't SYSRST */
	 set	r4, r4, 1<23>		/* set SYSRST bit - bit 23 */
	st	r4, r3, 0x0060		/* and store it back  */
1:
	ld	r4, r3, 0x0104		/* try local reset, then */
	set	r4, r4, 1<7>
	st	r4, r3, 0x0104

	/*
	 * We will be here if the reset above failed. In this case,
	 * we will try to return to bug.
	 *
	 * Switch to interrupt stack and call _doboot to take care
	 * going to BUG. Need to do this since _doboot turns off the
	 * the MMU and we need to be on a 1-to-1 mapped stack so that
	 * further calls don't get data access exceptions.
	 */

	/* Should we use idle_u instead? XXX nivas */
8:
	or.u	r31, r0,  hi16(_ASM_LABEL(intstack_end))
	or	r31, r31, lo16(_ASM_LABEL(intstack_end))
	clr	r31, r31, 3<0>	/* round down to 8-byte boundary */

	bsr	_C_LABEL(_doboot)
	/*NOTREACHED*/

	/* This is the *real* start upon poweron or reset */
GLOBAL(start_text)
	/*
	 * Args passed by boot loader
	 * 	r2 howto
	 *	r3 boot controller address
	 *	r4 esym
	 *	r5 start of mini
	 *	r6 end miniroot
	 *	r7 ((Clun << 8) ; Dlun & FF) -> bootdev
	 *	r8 cpu type (0x187, 0x188, 0x197)
d124 1
a124 1
	/* set _cputyp */
d140 1
a140 4
	 * Every CPU starts from here..
	 * (well, from 'start' above, which just jumps here).
	 *
	 * I use r11 and r22 here 'cause they're easy to not
a192 2
	cmp	r2, r8, CPU_88110	/* r8 contains cputyp */
	bb1	eq, r2, _ASM_LABEL(master_start) /* if it's a '197, skip */
d194 1
a194 9
#if 0
	/* clear BSS. Boot loader might have already done this... */
	or.u	r2, r0, hi16(_C_LABEL(edata))
	or	r2, r2, lo16(_C_LABEL(edata))
	or.u	r4, r0, hi16(_C_LABEL(end))
	or	r4, r4, lo16(_C_LABEL(end))
	bsr.n	_bzero		/* bzero(edata, end-edata) */
	 subu	r3, r4, r2
#endif
d196 4
a199 27
	 * First time to count how many CPUs to attach
	 */
	or.u	r11, r0,  hi16(_ASM_LABEL(initialized_cpu_lock))
	or	r11, r11, lo16(_ASM_LABEL(initialized_cpu_lock))
1:
	FLUSH_PIPELINE
	or	r22, r0,  1
	xmem	r22, r11, r0	/* If r22 gets 0, we have the lock.. */
	bcnd	eq0, r22, 3f	/* ..but if not, we must wait */
2:
	/* just watch the lock until it looks clear */
	ld	r22, r11, r0
	bcnd	eq0, r22, 1b
	br	2b		/* looks clear -- try to grab */
3:
	FLUSH_PIPELINE
	or.u	r11, r0,  hi16(_ASM_LABEL(initialized_cpus))
	ld	r22, r11, lo16(_ASM_LABEL(initialized_cpus))
	add	r23, r22, 1
	st	r23, r11, lo16(_ASM_LABEL(initialized_cpus))

	or.u	r11, r0,  hi16(_ASM_LABEL(initialized_cpu_lock))
	st	r0,  r11, lo16(_ASM_LABEL(initialized_cpu_lock))
	/*
	 * Now we view with any other processors to see who's the master.
	 * We first try to obtain a lock to see who's allowed
	 * to check/set the master lock.
d201 3
a203 25
	or.u	r11, r0,  hi16(_ASM_LABEL(inter_processor_lock))
	or	r11, r11, lo16(_ASM_LABEL(inter_processor_lock))
1:
	FLUSH_PIPELINE
	or	r22, r0,  1
	xmem	r22, r11, r0		/* If r22 gets 0, we have the lock.. */
	bcnd	eq0, r22, 4f		/* ..but if not, we must wait */
2:
	/* just watch the lock until it looks clear */
	ld	r22, r11, r0
	bcnd	ne0, r22, 2b
	/* since we can be here with caches off, add a few nops to
	   keep the bus from getting overloaded */
	or	r2, r0, lo16(1000)
3:
	subu	r2, r2, 1
	bcnd	eq0, r2, 3b
	br	1b			/* looks clear -- try to grab */
4:
	/* now try to grab the master_processor_chosen prize */
	FLUSH_PIPELINE
	or.u	r11, r0,  hi16(_ASM_LABEL(master_processor_chosen))
	or	r11, r11, lo16(_ASM_LABEL(master_processor_chosen))
	or	r22, r0,  1
	xmem	r22, r11, r0
d206 2
a207 7
	 * If r22 is not clear we're a slave,
	 * otherwise we're first and the master.
	 *
	 * Note that we haven't released the interprocessor lock....
	 * We'll do that when we're ready for another CPU to go.
	 * (if we're the master, we'll do that in master_start below.
	 *  if we're a slave, we'll do it in slave_start below).
d209 1
a209 2
	bcnd	ne0, r22, _ASM_LABEL(slave_start)
	/* fall through to master start if that's appropriate */
d211 1
a211 4
ASLOCAL(master_start)
	/*
	 * Switch to interrupt stack
	 */
a244 1
	addu	r31, r31, USIZE
d247 2
a248 1
	bsr	_C_LABEL(main)
d261 2
a262 4
/*
 *	slave CPUs starts here
 */
ASLOCAL(slave_start)
d264 3
a266 4
	 * While holding the inter_processor_lock, the slave cpu can use
	 * the slavestack to call slave_pre_main and determine its cpu number.
	 * After that, however, it should switch over to the interrupt stack
	 * associated with its cpu.
d268 1
a268 2

	/* r31 <-- slavestack */
d272 27
a298 2
	bsr.n	_C_LABEL(slave_pre_main)	/* set cpu number */
	 clr	r31, r31, 3<0>	/* round down to 8-byte boundary */
d300 9
a308 2
	bsr	_C_LABEL(get_slave_stack)
	addu	r31, r2, INTSTACK_SIZE
d311 2
a312 3
	 * SR1 now contains our cpu number. We can now release the
	 * inter_processor_lock, as we are done with the slavestack.
	 * We also have an interrupt stack
d314 27
d342 12
a353 2
	or.u	r10, r0, hi16(_ASM_LABEL(inter_processor_lock))
	st	r0, r10, lo16(_ASM_LABEL(inter_processor_lock))
d355 1
a355 1
	br	_C_LABEL(slave_main)	/* does not return */
d357 43
a399 6
GLOBAL(spin_cpu)
	or.u	r3,   r0,  hi16(_C_LABEL(start_text))
	or	r3,   r3,  lo16(_C_LABEL(start_text))
	or	r9,   r0,  0x100		/* .FORKMPU */
	tb0	0,    r0,  0x200-16		/* call 188Bug */
	jmp	r1
d438 2
a439 1
ASGLOBAL(slavestack)
d441 2
a442 1
ASGLOBAL(slavestack_end)
d445 1
a445 6
 * When a process exits and its u. area goes away, we set curpcb to point
 * to this `u.', leaving us with something to use for an interrupt stack,
 * and letting all the register save code have a pcb_uw to examine.
 * This is also carefully arranged (to come just before u0, so that
 * process 0's kernel stack can quietly overrun into it during bootup, if
 * we feel like doing that).
d454 1
a454 2
 *
 * This must be page aligned
d462 8
a469 14
GLOBAL(ret_addr)
	word 0
/* XMEM spin lock -- to count CPUs */
ASLOCAL(initialized_cpu_lock)
	word 0
/* CPU counter to initialize */
ASLOCAL(initialized_cpus)
	word 0
/* The first processor that XMEMs this becomes the master */
ASLOCAL(master_processor_chosen)
	word 0
/* XMEM spin lock -- controls access to master_processor_chosen */
ASLOCAL(inter_processor_lock)
	word 0
@


1.44
log
@Switch m88k ports to __HAVE_CPUINFO. Current cpu pointer is held in SR0
on all running processors.
Tested aoyama@@ and I
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.43 2005/10/12 19:32:19 miod Exp $	*/
d436 1
a436 1
	.align NBPG
d440 2
a441 2
	.align NBPG
GLOBAL(intstack)
d445 1
a445 1
	space	NBPG		/* 4K, small, interim stack */
d457 1
a457 1
	.align NBPG
d466 1
a466 1
	.align	NBPG
d468 1
a468 1
	space	UPAGES * NBPG
@


1.43
log
@Move sigcode to the m88k-agnostic location. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.42 2005/10/12 19:05:44 miod Exp $	*/
d200 1
a200 1
	 * occurs now, we're in deep   anyway, so I'm going to do
d205 1
a205 1
	 *   interrupts, shadowing, FPU, missaligned exception: all disabled
a215 1
	stcr	r0, SR0		/* clear "current thread" */
a320 1
	clr	r31, r31, 3<0>	/* round down to 8-byte boundary */
d350 2
a351 2
	or.u	r10, r0, hi16(_C_LABEL(curpcb))
	ld	r31, r10,lo16(_C_LABEL(curpcb))
a417 6
 * 
 * REGISTER USAGE:
 *  IN	r1   - return address
 *  IN	r2   - number of microseconds
 *	r3   - cpu speed in MHz
 *	r4   - number of cycles to delay
d442 1
a442 1
	space	INTSTACK_SIZE	/* 16K, just to be safe */
d459 1
a459 1
	space	UPAGES * NBPG
d469 2
d486 1
a490 14
GLOBAL(proc0paddr)
	word	_ASM_LABEL(u0)	/*  KVA of proc0 uarea */

/*
 * curpcb points to the current pcb (and hence u. area).
 * Initially this is the special one.
 */
/*
 * pcb is composed of kernel state + user state
 * I may have to change curpcb to u0 + PCB_USER based on what
 * other parts expect XXX nivas
 */
GLOBAL(curpcb)
	word	_ASM_LABEL(u0)	/* curpcb = &u0 */
@


1.42
log
@Stop mapping the u area at fixed UADDR in addition to its actual va.
While there, attempt to clean and comment stack usage in the kernel.
No functional change.

From the m88k SMP tree; help&test martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.41 2004/12/24 22:50:30 miod Exp $	*/
a509 28

/*
 * Trampoline code. Gets copied to the top of
 * user stack in exec.
 */
GLOBAL(sigcode)			/* r31 points to sigframe */
	ld	r3, r31, 4	/* siginfo_t* */
	ld	r4, r31, 8	/* sigcontext* */
	ld	r5, r31, 12	/* handler */
	jsr.n	r5
	 ld	r2, r31, 0	/* signo */
	ld	r2, r31, 8	/* sigcontext* */
	or	r13,  r0, SYS_sigreturn
	tb0	0, r0, 128	/* syscall trap, calling sigreturn */
	NOP			| failure return
#if 0
	NOP			| success return
#endif
	/* sigreturn will not return unless it fails */
	or	r13, r0, SYS_exit
	tb0	0, r0, 128	/* syscall trap, exit */
	/*
	 * this never returns, but we need to provide fetchable instructions
	 * for the 88100 pipeline.
	 */
	NOP
	NOP
GLOBAL(esigcode)
@


1.41
log
@{e,}intr{cnt,names} bye-bye.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.40 2004/11/09 21:50:01 miod Exp $	*/
a318 1
	 * Use idle_u's stack instead?
d342 5
a346 1
	/* still on int stack */
d350 1
a350 2
	 * we now know our cpu number, so we
	 * can set interrupt_stack[cpu_number()] = intstack
d352 10
a361 2
	ldcr	r10, SR1
	extu	r10, r10, FLAG_CPU_FIELD_WIDTH<0>	/* r10 <-- CPU# */
d363 6
a368 18
	/* figure interrupt_stack[cpu_number()] */
	or.u	r11,  r0, hi16(_C_LABEL(interrupt_stack))
	or	r11, r11, lo16(_C_LABEL(interrupt_stack))
	or.u	r12, r0,  hi16(_C_LABEL(intstack))
	or	r12, r12, lo16(_C_LABEL(intstack))
	st	r12, r11 [r10]

	/* switch to proc0 uarea */
	or.u	r10, r0, hi16(UADDR)
	or	r31, r10,lo16(UADDR)
	addu	r31, r31, USIZE - 8

	/* make the call: main() */
	or.u	r2, r0, hi16(UADDR)
	or	r2, r2,lo16(UADDR)
	bsr.n	_C_LABEL(main)
	 addu	r2, r2, USIZE - 8
	bsr	_C_LABEL(panic)
a477 3
/* UPAGES get mapped to kstack */
ASGLOBAL(kstack)
	word	UADDR
@


1.40
log
@Kill guarded_access() - the way we map OBIO, there is no need for special
treatement of interrupt vectors variables, a simple read will do.

While there, speed up the interrupt handlers a bit:
- remove old debug code or only compile it if option DEBUG.
- use short circuits for setipl() if we know interrupts are disabled at
  this point: there is no need playing with the psr in these cases.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.39 2004/10/01 20:20:36 miod Exp $	*/
a542 20

/* interrupt counters */
GLOBAL(intrnames)
	string	"spur\0"
	string	"lev1\0"
	string	"lev2\0"
	string	"lev3\0"
	string	"lev4\0"
	string	"lev5\0"
	string	"lev6\0"
	string	"lev7\0"
	string	"clk\0"
	string	"sclk\0"
	string	"pclk\0"
	string	"nmi\0"
GLOBAL(eintrnames)
	.align	8
GLOBAL(intrcnt)
	word	0,0,0,0,0,0,0,0,0,0,0,0
GLOBAL(eintrcnt)
@


1.39
log
@guarded_access() is really only used by the MVME188 interrupt engine, so
do not provide it on luna88k. Makes trap() slightly faster on non-MVME188
kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.38 2004/08/25 08:00:08 miod Exp $	*/
a415 1

a440 40

/*
 * int guarded_access(volatile u_int8_t *, unsigned, u_int8_t *)
 *
 * Necessary for interrupt vector retrieval - it could cause a bus error!
 */
GLOBAL(guarded_access_start)
ENTRY(guarded_access)
	cmp	 r9,r3,4
	bb1	 eq,r9,@@L145
	cmp	 r9,r3,2
	bb1	 eq,r9,@@L144
	cmp	 r9,r3,1
	bb1	 eq,r9,@@L143
	br	 _C_LABEL(guarded_access_bad)
@@L143:
	ld.b	 r9,r0,r2
	tb1	0, r0, 0
	st.b	 r9,r0,r4
	br	 @@L142
@@L144:
	ld.h	 r9,r0,r2
	tb1	0, r0, 0
	st.h	 r9,r0,r4
	br	 @@L142
@@L145:
	ld	 r9,r0,r2
	tb1	0, r0, 0
	st	 r9,r0,r4
	br	 @@L142

GLOBAL(guarded_access_bad)
	jmp.n	 r1
	 or	 r2,r0,EFAULT

@@L142:
	jmp.n	 r1
	 or	 r2,r0,0
GLOBAL(guarded_access_end)

@


1.38
log
@Use a simpler delay() routine for MVME188, from Mach via Luna88k
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.37 2004/08/09 20:52:11 miod Exp $	*/
d63 2
d411 4
d416 1
d442 40
@


1.37
log
@Take advantage of the recent ABI change to use less stack space and do
less stack pointer manipulation; the kernel needs to be compiled by an
up-to-date compiler now, or a tree will fall on your house.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.36 2004/07/02 14:40:22 miod Exp $	*/
d408 28
@


1.36
log
@Make page-aligned variable contiguous. Saves almost one page of data.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.35 2004/01/01 01:11:10 miod Exp $	*/
d342 1
a342 3
	bsr.n	_C_LABEL(mvme_bootstrap)
	 subu	r31, r31, 40
	addu	r31, r31, 40
d366 2
a367 4
	addu	r2, r2, USIZE - 8
	subu	r31, r31, 40
	bsr	_C_LABEL(main)
	addu	r31, r31, 40
a383 1
	clr	r31, r31, 3<0>	/* round down to 8-byte boundary */
d386 1
a386 1
	 subu	r31, r31, 48    		/* allocate frame */
d400 1
a400 2
	br.n	_C_LABEL(slave_main)	/* does not return */
	 subu	r31, r31, 40		/* allocate frame */
a486 1
	ld	r2, r31, 0	/* signo */
d491 2
a492 3
	 subu	r31, r31, 40	/* give some stack space */
	addu	r31, r31, 40	/* restore old sp value  */
	ld	r2,  r31, 8	/* sigcontext* */
@


1.35
log
@Some typos just never die (here controler vs controller).
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.34 2003/11/03 06:54:26 david Exp $	*/
d418 3
a420 17
	.align 4096		/* SDT (segment descriptor table */
GLOBAL(kernel_sdt)
	space	(0x2000)	/* 8K - 4K phys, 4K virt*/
GLOBAL(ret_addr)
	word 0
ASLOCAL(initialized_cpu_lock)
	/* XMEM spin lock -- to count CPUs */
	word 0
ASLOCAL(initialized_cpus)
	/* CPU counter to initialize */
	word 0
ASLOCAL(master_processor_chosen)
	/* The first processor that XMEMs this becomes the master */
	word 0
ASLOCAL(inter_processor_lock)
	/* XMEM spin lock -- controls access to master_processor_chosen */
	word 0
d422 1
a422 1
	.align 4096
d424 1
a424 1
	space (INTSTACK_SIZE)	/* 16K, just to be safe */
d427 1
a427 1
	space (NBPG)		/* 4K, small, interim stack */
d439 1
a439 1
	.align 4096
d448 1
a448 1
	.align	4096
d452 1
a452 4
/*
 * UPAGES get mapped to kstack
 */

d455 14
a468 1

a472 6

GLOBAL(intiobase)
	word	0		| KVA of base of internal IO space
GLOBAL(intiolimit)
	word	0		| KVA of end of internal IO space

@


1.34
log
@spelling fixes (in the comments)
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.33 2003/10/15 17:48:36 miod Exp $	*/
d136 1
a136 1
	 *	r3 boot controler address
@


1.33
log
@Better reset code, even.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.31 2003/09/20 13:57:37 miod Exp $	*/
d196 1
a196 1
	 * at the same time because interupts are not actually disabled
@


1.32
log
@Do not assert SYSRST on 1x7 boards, if we are not a SYSCON, or unexpected
collateral damage will happen.
@
text
@d108 4
@


1.31
log
@Cleanup uses of intstack and interrupt_stack[] - also makes time % in top
more realistic.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.30 2003/08/20 20:33:47 miod Exp $	*/
d102 6
a107 5
	or.u	r3,r0, 0xfff4
	ld	r4,r3, 0x0060		/* read offset (LCSR +0x60) */
	set	r4,r4,1<23>		/* set SYSRST bit - bit 23 */
	st	r4,r3, 0x0060		/* and store it back  */

d509 4
a512 2
	or	r0, r0, 0
	or	r0, r0, 0
d516 6
a521 2
	or	r0, r0, 0
	or	r0, r0, 0
@


1.30
log
@A bunch of 88110 band-aid:
- the 88410 handling code is not working correctly. Check whether we are
  operating with 88410's, and only invoke these routines if necessary.
- force serial mode execution in the PSR for the moment (hopefully only
  temporary)
- disable branch prediction and data matching in the PSR, the 88110 errata
  is simply too scary about them.
- a better pipeline flush after changing the ictl control register.

These changes let 197LE (but not 197SP/DP) boot up to autoconf.
Userland process do not work at the moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.29 2003/08/13 08:52:44 miod Exp $	*/
d68 1
a68 1
#include <machine/vmparam.h>	/* INTSTACK_SIZE */
d389 1
a389 1
	addu	r31, r2, INTSTACK_SIZE + 4096
d433 1
a433 1
	space (4 * NBPG)	/* 16K, just to be safe */
@


1.29
log
@Always force a pipeline flush after a PSR change, not before. How could
this have ever worked?
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.28 2003/08/11 20:45:17 miod Exp $	*/
d215 10
a224 1
/*	set	r11, r11, 1<PSR_SERIAL_MODE_BIT> */
@


1.28
log
@Sprinkle proper use of _C_LABEL and _ASM_LABEL in the .S files (except for
the _fp.S which are too scary at the moment). This will be necessary to
move to ELF in the future.

Use local symbols whenever possible.

Attempt to use delayed branches whenever possible.

Remove stupid or straightforward comments, some hardcoded values, and a
few unused variables or routines.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.27 2003/08/03 23:34:09 miod Exp $	*/
d218 1
@


1.27
log
@Resistance is futile, you will be KNF'ed.
And then it will be easier to debug this mess (no functional change yet).
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.26 2003/01/14 03:20:16 miod Exp $	*/
d99 2
a100 1
	br	m188_doboot_fail
a101 1
1:
d118 3
a120 3
m188_doboot_fail:
	or.u	r31, r0,  hi16(_intstack_end)
	or	r31, r31, lo16(_intstack_end)
d142 6
a147 6
	or.u	r13, r0,  hi16(_boothowto)
	st	r2,  r13, lo16(_boothowto)
	or.u	r13, r0,  hi16(_bootaddr)
	st	r3,  r13, lo16(_bootaddr)
	or.u	r13, r0,  hi16(_first_addr)
	st	r4,  r13, lo16(_first_addr)
d149 2
a150 2
	or.u	r13, r0,  hi16(_esym)
	st	r4,  r13, lo16(_esym)
d152 4
a155 4
	or.u	r13, r0,  hi16(_bootdev)
	st	r7,  r13, lo16(_bootdev)
	or.u	r13, r0,  hi16(_brdtyp)
	st	r8,  r13, lo16(_brdtyp)
d161 1
a161 1
	or	r8,  r13, lo16(CPU_88110)	/* r8 contains 0x110 */
d165 1
a165 1
	or	r8,  r13, lo16(CPU_88100)	/* r8 contains 0x100 */
d167 2
a168 2
	or.u	r13, r0,  hi16(_cputyp)
	st	r8,  r13, lo16(_cputyp)		/* r8 contains cputyp */
d221 1
a221 1
	bb1	eq, r2, master_start	/* if it's a '197, skip */
d225 4
a228 4
	or.u	r2, r0, hi16(_edata)
	or	r2, r2, lo16(_edata)
	or.u	r4, r0, hi16(_end)
	or	r4, r4, lo16(_end)
d235 3
a237 3
	or.u	r11, r0,  hi16(initialized_cpu_lock)
	or	r11, r11, lo16(initialized_cpu_lock)
ASGLOBAL(check_init_lock)
d240 3
a242 4
	xmem	r22, r11, r0		/* If r22 gets 0, we have the lock.. */
	bcnd	eq0, r22, have_init_lock	/* ..but if not, we must wait */

ASGLOBAL(wait_for_init_lock)
d245 3
a247 4
	bcnd	eq0, r22, check_init_lock
	br	wait_for_init_lock	/* looks clear -- try to grab */

ASGLOBAL(have_init_lock)
d249 2
a250 2
	or.u	r11, r0,  hi16(_initialized_cpus)
	ld	r22, r11, lo16(_initialized_cpus)
d252 1
a252 1
	st	r23, r11, lo16(_initialized_cpus)
d254 2
a255 2
	or.u	r11, r0,  hi16(initialized_cpu_lock)
	st	r0,  r11, lo16(initialized_cpu_lock)
d261 3
a263 3
	or.u	r11, r0,  hi16(_inter_processor_lock)
	or	r11, r11, lo16(_inter_processor_lock)
ASGLOBAL(check_ip_lock)
d267 2
a268 2
	bcnd	eq0, r22, have_ip_lock		/* ..but if not, we must wait */
ASGLOBAL(wait_for_ip_lock)
d271 1
a271 1
	bcnd	ne0, r22, wait_for_ip_lock
d275 1
a275 1
ASGLOBAL(ip_loop)
d277 3
a279 4
	bcnd	eq0, r2, ip_loop
	br	check_ip_lock		/* looks clear -- try to grab */

ASGLOBAL(have_ip_lock)
d282 2
a283 2
	or.u	r11, r0,  hi16(master_processor_chosen)
	or	r11, r11, lo16(master_processor_chosen)
d296 1
a296 1
	bcnd	ne0, r22, slave_start
d299 1
a299 1
ASGLOBAL(master_start)
d304 2
a305 2
	or.u	r31, r0,  hi16(_intstack_end)
	or	r31, r31, lo16(_intstack_end)
d309 1
d312 5
a316 5
	or.u	r3, r0, hi16(_m88110_vector_list)
	or	r3, r3, lo16(_m88110_vector_list)
	bsr.n	_vector_init
	 ldcr	r2, VBR
	br	2f
a317 1
1:
d319 2
a320 8
	/*
	 * Want to make the call:
	 * 	vector_init(VBR, vector_list)
	 */
	or.u	r3, r0, hi16(_vector_list)
	or	r3, r3, lo16(_vector_list)
	bsr.n	_vector_init
	 ldcr	r2, VBR
d323 3
d327 1
a327 1
	bsr.n	_mvme_bootstrap
d333 1
a333 1
	 * can set interrupt_stack[cpu_number()] = _intstack
d339 4
a342 4
	or.u	r11,  r0, hi16(_interrupt_stack)
	or	r11, r11, lo16(_interrupt_stack)
	or.u	r12, r0,  hi16(_intstack)
	or	r12, r12,  lo16(_intstack)
d355 1
a355 1
	bsr	_main
d357 1
a357 1
	bsr	_panic
d362 1
a362 1
ASGLOBAL(slave_start)
d371 2
a372 2
	or.u	r31, r0, hi16(_slavestack_end)
	or	r31, r31, lo16(_slavestack_end)
d375 2
a376 2
	bsr.n	_slave_pre_main /* set cpu number */
	 subu	r31, r31, 48    /* allocate frame */
d378 1
a378 1
	bsr	_get_slave_stack
d387 2
a388 2
	or.u	r10, r0, hi16(_inter_processor_lock)
	st	r0, r10, lo16(_inter_processor_lock)
d390 2
a391 2
	br.n	_slave_main     /* does not return */
	 subu	r31, r31, 40    /* allocate frame */
d394 2
a395 2
	or.u	r3,   r0,  hi16(_start_text)
	or	r3,   r3,  lo16(_start_text)
d404 1
a404 2
	global _kernel_sdt
_kernel_sdt:
d406 1
a406 2
	global _ret_addr
_ret_addr:
d408 1
a408 4
	global _msgsw
_msgsw:
	word 0 			/* Bits here turn on/off debugging somewhere */
ASGLOBAL(initialized_cpu_lock)
d411 1
a411 1
GLOBAL(initialized_cpus)
d414 1
a414 1
ASGLOBAL(master_processor_chosen)
d417 1
a417 1
GLOBAL(inter_processor_lock)
d422 1
a422 2
	global	_intstack, _intstack_end, _slavestack, _slavestack_end
_intstack:
d424 2
a425 2
_intstack_end:
_slavestack:
d427 1
a427 1
_slavestack_end:
d439 1
a439 2
	global	_idle_u
_idle_u:
d448 2
a449 3
	global	_u0
_u0:	space	UPAGES * NBPG
estack0:
d455 1
a455 2
	global	_kstack
_kstack:
d459 1
a459 2
	global	_esym
_esym:
d463 1
a463 2
	global	_intiobase, _intiolimit
_intiobase:
d465 1
a465 1
_intiolimit:
d468 2
a469 3
	global	_proc0paddr	/* move to C code */
_proc0paddr:
	word	_u0		/*  KVA of proc0 uarea */
d472 1
a472 1
 * _curpcb points to the current pcb (and hence u. area).
d480 2
a481 2
	global	_curpcb	/* move to C code */
_curpcb:	word	_u0	/* curpcb = &u0 */
d487 1
a487 2
	global	_sigcode
_sigcode:			/* r31 points to sigframe */
d505 1
a505 2
	global	_esigcode
_esigcode:
d508 1
a508 2
	global	_intrcnt,_eintrcnt,_intrnames,_eintrnames
_intrnames:
d521 1
a521 1
_eintrnames:
d523 1
a523 1
_intrcnt:
d525 1
a525 1
_eintrcnt:
@


1.26
log
@Define exception vector tables as assembly source, with the appropriate
macros, rather than include files - no need to pollute <machine/> area...
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.25 2001/12/22 19:27:48 smurph Exp $	*/
d68 1
a68 3
#include <machine/vmparam.h>      /* INTSTACK_SIZE */

/***********************************************************************/
d72 5
a76 6
 *   0x00000 - 0x01000   : trap vectors
 *   0x01000 - 0x10000	 : first 64k used by BUG
 *   0x10000 == start    : Boot loader jumps here. (for now, this can
 *					handle only NMAGIC - screwy linker)
 *
 ***********************************************************************/
d90 1
a90 1
	 *	Try hitting the SRST bit in VMEchip2 to reset the system.
d101 1
a101 1
1:	
d104 1
a104 1
	set	r4,r4,1<23>		/* set SYSRST bit - bit 23 */	
d108 2
a109 2
	 *	We will be here if the reset above failed. In this case,
	 *	we will try to return to bug.
d111 4
a114 4
	 *	Switch to interrupt stack and call _doboot to take care
	 *	going to BUG. Need to do this since _doboot turns off the
	 *	the MMU and we need to be on a 1-to-1 mapped stack so that
	 *	further calls don't get data access exceptions.
d126 2
a127 2
/**************************************************************************/
GLOBAL(start_text)	/* This is the *real* start upon poweron or reset */
d139 3
a141 3
 *	(*entry)(flag, bugargs.ctrl_addr, cp, kernel.smini, 
 *               kernel.emini, bootdev, brdtyp); 
 */ 
d156 1
a156 1
	
d158 4
a161 4
	cmp     r2,  r8, BRD_197	/* r8 contains brdtyp */
        bb1     ne, r2, 1f	/* if it's a '197, CPU is 88110 */ 
	or.u    r13, r0,  hi16(CPU_88110) 
	or	r8,  r13, lo16(CPU_88110)/* r8 contains 0x110 */
d163 4
a166 4
1:	
	or.u    r13, r0,  hi16(CPU_88100) 
	or	r8,  r13, lo16(CPU_88100)/* r8 contains 0x100 */
2:	
d168 2
a169 2
	st	r8,  r13, lo16(_cputyp) /* r8 contains cputyp */
	
d204 3
a206 3
        
	cmp     r2, r8, CPU_88110 /* r8 contains cputyp */
        bb1     eq, r2, 1f      /* if it's a 'mc88110, skip SSBR */
d211 1
a211 1
	
d218 1
a218 1
	stcr	r0,  VBR     /* set Vector Base Register to 0, ALWAYS! */
d220 3
a222 3
        cmp     r2, r8, CPU_88110 /* r8 contains cputyp */
	bb1	eq, r2, master_start	/* if it's a '197, skip to master_start */
	
d230 1
a230 1
	subu	r3, r4, r2
d240 2
a241 2
	xmem    r22, r11, r0	  	/* If r22 gets 0, we have the lock.. */
	bcnd	eq0, r22, have_init_lock/* ..but if not, we must wait */
d259 2
a260 2
 	 * Now we vie with any other processors to see who's the master.
 	 * We first try to obtain a lock to see who's allowed
d268 2
a269 2
	xmem	r22, r11, r0            /* If r22 gets 0, we have the lock.. */ 
	bcnd	eq0, r22, have_ip_lock  /* ..but if not, we must wait */
d274 2
a275 2
	/* since we can be here with caches off, add a few nops to 
	keep the bus from getting overloaded */
d280 1
a280 1
	br	check_ip_lock           /* looks clear -- try to grab */
d313 1
a313 1
	bb1	ne, r2, 1f	/* if it's a 'mc88110, use different vectors */ 
d317 1
a317 1
	ldcr	r2, VBR
d329 1
a329 1
	ldcr	r2, VBR		
d331 1
a331 1
2:	
d334 1
a334 1
	subu	r31, r31, 40
d336 3
a338 2
	
	/* we now know our cpu number, so we
d341 3
a343 3
	ldcr  	r10, SR1
	extu   	r10, r10, FLAG_CPU_FIELD_WIDTH<0>    /* r10 <-- CPU# */
	
d345 1
a345 1
	or.u	r11,  r0, hi16(_interrupt_stack)  
d365 1
a365 1
/***********************************************************************
d369 6
a374 5
	/* while holding the inter_processor_lock, the slave cpu
	   can find use the slavestack to call slave_pre_main and
	   determine its cpu number. After that, however, it should
	   switch over to the interrupt stack associated with its
           cpu */
d382 1
a382 1
	subu	r31, r31, 48    /* allocate frame */
d387 5
a391 3
	/* SR1 now contains our cpu number. We can now release
	   the inter_processor_lock, as we are done with the 
	   slavestack.  We also have an interrupt stack  */
d394 1
a394 1
	st	r0, r10, lo16(_inter_processor_lock)	
d397 2
a398 2
	subu	r31, r31, 40    /* allocate frame */
	
d400 1
a400 1
        or.u	r3,   r0,  hi16(_start_text)
d404 2
a405 2
        jmp     r1
        
d409 1
a409 1
	.align 4096		  /* SDT (segment descriptor table */
d411 2
a412 2
_kernel_sdt:	
	space	(0x2000)	  /* 8K - 4K phys, 4K virt*/
d418 1
a418 1
	word 0 			 /* Bits here turn on/off debugging somewhere */
d420 1
a420 1
   /* XMEM spin lock -- to count CPUs */
d423 1
a423 1
   /* CPU counter to initialize */
d426 1
a426 1
   /* The first processor that XMEMs this becomes the master */
d429 1
a429 1
   /* XMEM spin lock -- controls access to master_processor_chosen */
d431 1
a431 1
	
d438 1
a438 1
	space (NBPG)      /* 4K, small, interim stack */
d506 1
a506 2
_sigcode:
				/* r31 points to sigframe */
d512 1
a512 1
	subu	r31, r31, 40	/* give some stack space */
a546 2


@


1.25
log
@Label changes and comment corrections.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.23 2001/12/19 07:04:41 smurph Exp $	*/
a407 16
#ifdef M88100
	.align 4096		  /* VBR points to page aligned list */
	global _vector_list, _vector_list_end
_vector_list:     		  /* references memory BELOW this line */
#include "machine/exception_vectors.h"
_vector_list_end:
	word END_OF_VECTOR_LIST
#endif /* M88100 */
#ifdef M88110
	.align 4096		  /* VBR points to page aligned list */
	global _m88110_vector_list, _m88110_vector_list_end
_m88110_vector_list:   		  /* references memory BELOW this line */ 
#include "machine/exception_vectors2.h"
_m88110_vector_list_end:
	word END_OF_VECTOR_LIST
#endif /* M88110 */	
@


1.24
log
@Bring in PSR bit definitions.
@
text
@d317 2
a318 2
	or.u	r3, r0, hi16(_m197_vector_list)
	or	r3, r3, lo16(_m197_vector_list)
d418 2
a419 2
	global _m197_vector_list, _m197_vector_list_end
_m197_vector_list:   		  /* references memory BELOW this line */ 
d421 1
a421 1
_m197_vector_list_end:
@


1.23
log
@Introduce brdtyp and change what cputyp means.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.22 2001/12/16 23:49:46 miod Exp $	*/
d217 3
a219 3
	set	r11, r11, 1<4>
	set	r11, r11, 1<29>
	set	r11, r11, 1<25>
@


1.23.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.25 2001/12/22 19:27:48 smurph Exp $	*/
d217 3
a219 3
	set	r11, r11, 1<PSR_GRAPHICS_DISABLE_BIT>
/*	set	r11, r11, 1<PSR_SERIAL_MODE_BIT> */
	set	r11, r11, 1<PSR_SERIALIZE_BIT>
d317 2
a318 2
	or.u	r3, r0, hi16(_m88110_vector_list)
	or	r3, r3, lo16(_m88110_vector_list)
d418 2
a419 2
	global _m88110_vector_list, _m88110_vector_list_end
_m88110_vector_list:   		  /* references memory BELOW this line */ 
d421 1
a421 1
_m88110_vector_list_end:
@


1.23.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d408 16
@


1.22
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.20 2001/08/31 01:41:33 miod Exp $	*/
d97 3
a99 3
	or.u	r4, r0, hi16(_C_LABEL(cputyp))
	ld	r3, r4, lo16(_C_LABEL(cputyp))
	cmp	r4, r3, 0x188
d143 1
a143 1
 *               kernel.emini, bootdev, cputyp); 
d157 13
d171 1
a171 1
	st	r8,  r13, lo16(_cputyp)
d207 3
a209 2
	cmp	r2, r8, 0x197	/* r8 contains cputyp */
	bb1	eq, r2, 1f	/* if it's a '197, skip SSBR */
d223 1
a223 1
	cmp	r2, r8, 0x197	/* r8 contains cputyp */
d225 1
d314 3
a316 3
#ifdef MVME197
	cmp	r2, r8, 0x197	/* r8 contains cputyp */
	bb1	ne, r2, 1f	/* if it's a '197, use different vectors */ 
d322 1
a322 1
#endif /* MVME197 */
d324 1
a324 1
#if defined(MVME187) || defined(MVME188)	
d333 1
a333 1
#endif /* defined(MVME187) || defined(MVME188) */
d408 1
a409 1
#if defined(MVME187) || defined(MVME188)	
d415 3
a417 2
#endif /* defined(MVME187) || defined(MVME188) */	
#ifdef MVME197	
d419 1
a419 1
_m197_vector_list:     		  /* references memory BELOW this line */
d423 1
a423 1
#endif /* MVME197 */	
@


1.21
log
@Support for MVME197 completed.  Fix SPL defs.
@
text
@d65 1
d97 3
a99 3
	or.u	r4, r0, hi16(_C_LABEL(brdtyp))
	ld	r3, r4, lo16(_C_LABEL(brdtyp))
	cmp	r4, r3, BRD_188
d143 1
a143 1
 *               kernel.emini, bootdev, brdtyp); 
a156 13
	or.u	r13, r0,  hi16(_brdtyp)
	st	r8,  r13, lo16(_brdtyp)
	
	/* set _cputyp */
	cmp     r2,  r8, BRD_197	/* r8 contains brdtyp */
        bb1     ne, r2, 1f	/* if it's a '197, CPU is 88110 */ 
	or.u    r13, r0,  hi16(CPU_88110) 
	or	r8,  r13, lo16(CPU_88110)/* r8 contains 0x110 */
	br	2f
1:	
	or.u    r13, r0,  hi16(CPU_88100) 
	or	r8,  r13, lo16(CPU_88100)/* r8 contains 0x100 */
2:	
d158 1
a158 1
	st	r8,  r13, lo16(_cputyp) /* r8 contains cputyp */
d194 3
a196 4
        
	cmp     r2, r8, CPU_88110 /* r8 contains cputyp */
        bb1     eq, r2, 1f      /* if it's a 'mc88110, skip SSBR */
        stcr    r0, SSBR        /* clear this for later */
d198 2
a199 11
        stcr    r0, SR0         /* clear "current thread" */
        stcr    r0, SR1         /* clear the CPU flags */
        
        set     r11, r0,  1<PSR_SUPERVISOR_MODE_BIT>
        set     r11, r11, 1<PSR_INTERRUPT_DISABLE_BIT>
        set     r11, r11, 1<PSR_SERIALIZE_BIT>
        stcr    r11, PSR
        stcr    r0,  VBR     /* set Vector Base Register to 0, ALWAYS! */
        FLUSH_PIPELINE
        cmp     r2, r8, CPU_88110 /* r8 contains cputyp */
        bb1     eq, r2, master_start    /* if it's a '197, skip to master_start */
d201 10
d299 5
a303 5
#ifdef M88110
	cmp	r2, r8, CPU_88110 /* r8 contains cputyp */
	bb1	ne, r2, 1f	/* if it's a 'mc88110, use different vectors */ 
	or.u	r3, r0, hi16(_m88110_vector_list)
	or	r3, r3, lo16(_m88110_vector_list)
d307 1
a307 1
#endif /* M88110 */
d309 1
a309 1
#ifdef M88100
d318 1
a318 1
#endif /* M88100 */
a392 1
#ifdef M88100
d394 1
d400 4
a403 5
#endif /* M88100 */
#ifdef M88110
	.align 4096		  /* VBR points to page aligned list */
	global _m88110_vector_list, _m88110_vector_list_end
_m88110_vector_list:   		  /* references memory BELOW this line */
d405 1
a405 1
_m88110_vector_list_end:
d407 1
a407 1
#endif /* M88110 */	
d547 1
@


1.20
log
@Oops, finish removing variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.19 2001/08/24 22:53:14 miod Exp $	*/
a64 1
#include <machine/m88100.h>
d96 3
a98 3
	or.u	r4, r0, hi16(_C_LABEL(cputyp))
	ld	r3, r4, lo16(_C_LABEL(cputyp))
	cmp	r4, r3, 0x188
d142 1
a142 1
 *               kernel.emini, bootdev, cputyp); 
d156 13
d170 1
a170 1
	st	r8,  r13, lo16(_cputyp)
d206 4
a209 3
	cmp	r2, r8, 0x197	/* r8 contains cputyp */
	bb1	eq, r2, 1f	/* if it's a '197, skip SSBR */
	stcr	r0, SSBR	/* clear this for later */
d211 11
a221 2
	stcr	r0, SR0		/* clear "current thread" */
	stcr	r0, SR1		/* clear the CPU flags */
a222 10
	set	r11, r0,  1<PSR_SUPERVISOR_MODE_BIT>
	set	r11, r11, 1<PSR_INTERRUPT_DISABLE_BIT>
	set	r11, r11, 1<4>
	set	r11, r11, 1<29>
	set	r11, r11, 1<25>
	stcr	r11, PSR
	stcr	r0,  VBR     /* set Vector Base Register to 0, ALWAYS! */
	FLUSH_PIPELINE
	cmp	r2, r8, 0x197	/* r8 contains cputyp */
	bb1	eq, r2, master_start	/* if it's a '197, skip to master_start */
d311 5
a315 5
#ifdef MVME197
	cmp	r2, r8, 0x197	/* r8 contains cputyp */
	bb1	ne, r2, 1f	/* if it's a '197, use different vectors */ 
	or.u	r3, r0, hi16(_m197_vector_list)
	or	r3, r3, lo16(_m197_vector_list)
d319 1
a319 1
#endif /* MVME197 */
d321 1
a321 1
#if defined(MVME187) || defined(MVME188)	
d330 1
a330 1
#endif /* defined(MVME187) || defined(MVME188) */
d405 1
a406 1
#if defined(MVME187) || defined(MVME188)	
d412 5
a416 4
#endif /* defined(MVME187) || defined(MVME188) */	
#ifdef MVME197	
	global _m197_vector_list, _m197_vector_list_end
_m197_vector_list:     		  /* references memory BELOW this line */
d418 1
a418 1
_m197_vector_list_end:
d420 1
a420 1
#endif /* MVME197 */	
a559 1

@


1.19
log
@Adapt to the <machine/asm.h> macros (only for entry points for now, because
LABEL has disappeared), and to the trap() name changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.18 2001/08/15 21:27:20 miod Exp $	*/
a154 2
	or.u	r13, r0,  hi16(_miniroot)
	st	r5,  r13, lo16(_miniroot)
@


1.18
log
@More 197 support breakage.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.17 2001/06/14 21:30:45 miod Exp $	*/
a71 4
#ifndef UADDR
#define	UADDR		0xEEE00000	/* address of u */
#endif /* UADDR */

d82 8
a89 8
LABEL(_kernelstart)
LABEL(_kernel_text)
LABEL(_start)
LABEL(start)
	br	_start_text
	br	_start_text
	br	_start_text
	br	_start_text
d91 1
a91 1
ENTRY(doboot)
d97 2
a98 2
	or.u	r4, r0, hi16(_cputyp)
	ld	r3, r4, lo16(_cputyp)
d101 1
a101 1
	bsr	_m188_reset
d114 2
a115 2
	 *	Switch to interrupt stack and call __doboot to take care
	 *	going to BUG. Need to do this since __doboot turns off the
d126 1
a126 1
	bsr	__doboot
d130 1
a130 1
LABEL(_start_text)	/* This is the *real* start upon poweron or reset */
d227 1
a227 1
_LABEL(check_init_lock)
d233 1
a233 1
_LABEL(wait_for_init_lock)
d239 1
a239 1
_LABEL(have_init_lock)
d255 1
a255 1
_LABEL(check_ip_lock)
d260 1
a260 1
_LABEL(wait_for_ip_lock)
d267 1
a267 1
_LABEL(ip_loop)
d272 1
a272 1
_LABEL(have_ip_lock)
d292 1
a292 1
_LABEL(master_start)
d357 1
a357 1
_LABEL(slave_start)
d385 1
a385 1
_LABEL(_spin_cpu)
d420 1
a420 1
_LABEL(initialized_cpu_lock)
d423 1
a423 1
LABEL(_initialized_cpus)
d426 1
a426 1
_LABEL(master_processor_chosen)
d429 1
a429 1
LABEL(_inter_processor_lock)
@


1.17
log
@Big cleanup of VM issues:
o get rid of m88k_foo macros when there is an mi foo macro
o remove the ability, for the pmap module, to handle a native mmu page
  size different from the vm module page size. This allows some
  optimizations in pmap.c
o remove dead stuff from <machine/vmparam.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.16 2001/05/20 05:53:09 miod Exp $	*/
d400 1
a401 1
#if defined(MVME187) || defined(MVME188)	
d408 1
a408 1
	global _vector_list, _vector_list_end
@


1.16
log
@assym.s -> assym.h
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.15 2001/04/29 19:00:02 miod Exp $	*/
d62 1
d67 1
d143 1
a143 1
	 *	r8 cpu type (0x187, 0x188, 1x197)
@


1.15
log
@Replace resource maps with extents, and cleanup associated variables.
Idea from art's todolist, art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.14 2001/03/12 22:56:17 miod Exp $	*/
d60 1
a60 5
#ifndef ASSEMBLER
#define	ASSEMBLER
#endif /* ASSEMBLER */

#include "assym.s"
@


1.14
log
@/dev/ksyms support.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.13 2001/03/09 05:44:41 smurph Exp $	*/
d486 1
a486 1
	global	_intiobase, _intiolimit, _extiobase
a490 2
_extiobase:
	word	0		| KVA of base of external IO space
@


1.13
log
@kernel will compile with -Werror.  Added intr.h
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.12 2001/03/07 23:40:35 miod Exp $	*/
d65 6
a70 5
#include "machine/asm.h"
#include "machine/trap.h"
#include "machine/m88100.h"
#include "machine/psl.h"
#include "machine/vmparam.h"      /* INTSTACK_SIZE */
d157 1
d160 1
d480 1
a480 1
#ifdef DDB
d484 1
a484 1
#endif /* DDB */
@


1.12
log
@Get rid of definitions of ASSEMBLER, LOCORE and such. We will get
the correct defines from the Makefile now.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.11 2001/02/12 08:16:24 smurph Exp $	*/
d59 4
@


1.11
log
@correct buginstat(), statclock now working for '188, systat vmstat now works,
serial driver for '188 working better.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.10 2001/02/01 03:38:20 smurph Exp $	*/
a58 4

#ifndef ASSEMBLER
#define ASSEMBLER
#endif
@


1.10
log
@Major changes to get MVME188 working.  More header and code cleanups.  The
kernel is tested on MVME188A/2P256 and MVME188A/1P64.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.9 1999/09/27 19:13:22 smurph Exp $	*/
d533 23
@


1.9
log
@Added to support MVME188 and MVME197
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.8 1999/05/29 04:41:46 smurph Exp $	*/
d334 1
a334 1
	mak   	r10, r10, FLAG_CPU_FIELD_WIDTH<0>    /* r10 <-- CPU# */
a412 4
	.align 4096		  /* Vector table is a page aligned list */
LABEL(_vector_table)		  /* new vector table location, was addr 0 */
	space	(0x1000)	  /* 16K */
	
@


1.9.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.14 2001/03/12 22:56:17 miod Exp $	*/
d61 2
a62 2
#define	ASSEMBLER
#endif /* ASSEMBLER */
d65 5
a69 6
#include "ksyms.h"
#include <machine/asm.h>
#include <machine/trap.h>
#include <machine/m88100.h>
#include <machine/psl.h>
#include <machine/vmparam.h>      /* INTSTACK_SIZE */
a155 1
#if defined(DDB) || NKSYMS > 0
a157 1
#endif
d334 1
a334 1
	extu   	r10, r10, FLAG_CPU_FIELD_WIDTH<0>    /* r10 <-- CPU# */
d413 4
d481 1
a481 1
#if defined(DDB) || NKSYMS > 0
d485 1
a485 1
#endif /* DDB || NKSYMS > 0 */
a536 23

/* interrupt counters */
	global	_intrcnt,_eintrcnt,_intrnames,_eintrnames
_intrnames:
	string	"spur\0"
	string	"lev1\0"
	string	"lev2\0"
	string	"lev3\0"
	string	"lev4\0"
	string	"lev5\0"
	string	"lev6\0"
	string	"lev7\0"
	string	"clk\0"
	string	"sclk\0"
	string	"pclk\0"
	string	"nmi\0"
_eintrnames:
	.align	8
_intrcnt:
	word	0,0,0,0,0,0,0,0,0,0,0,0
_eintrcnt:


@


1.9.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.9.4.1 2001/04/18 16:11:33 niklas Exp $	*/
d60 5
a64 1
#include "assym.h"
a65 1

a69 1
#include <machine/param.h>
d145 1
a145 1
	 *	r8 cpu type (0x187, 0x188, 0x197)
d486 1
a486 1
	global	_intiobase, _intiolimit
d491 2
@


1.9.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.9.4.2 2001/07/04 10:20:12 niklas Exp $	*/
d72 4
d86 8
a93 8
GLOBAL(kernelstart)
GLOBAL(kernel_text)
GLOBAL(start)
ASGLOBAL(start)
	br	_C_LABEL(start_text)
	br	_C_LABEL(start_text)
	br	_C_LABEL(start_text)
	br	_C_LABEL(start_text)
d95 1
a95 1
GLOBAL(doboot)
d101 2
a102 2
	or.u	r4, r0, hi16(_C_LABEL(cputyp))
	ld	r3, r4, lo16(_C_LABEL(cputyp))
d105 1
a105 1
	bsr	_C_LABEL(m188_reset)
d118 2
a119 2
	 *	Switch to interrupt stack and call _doboot to take care
	 *	going to BUG. Need to do this since _doboot turns off the
d130 1
a130 1
	bsr	_C_LABEL(_doboot)
d134 1
a134 1
GLOBAL(start_text)	/* This is the *real* start upon poweron or reset */
d159 2
d231 1
a231 1
ASGLOBAL(check_init_lock)
d237 1
a237 1
ASGLOBAL(wait_for_init_lock)
d243 1
a243 1
ASGLOBAL(have_init_lock)
d259 1
a259 1
ASGLOBAL(check_ip_lock)
d264 1
a264 1
ASGLOBAL(wait_for_ip_lock)
d271 1
a271 1
ASGLOBAL(ip_loop)
d276 1
a276 1
ASGLOBAL(have_ip_lock)
d296 1
a296 1
ASGLOBAL(master_start)
d361 1
a361 1
ASGLOBAL(slave_start)
d389 1
a389 1
GLOBAL(spin_cpu)
d400 1
a401 1
	global _vector_list, _vector_list_end
d408 1
a408 1
	global _m197_vector_list, _m197_vector_list_end
d424 1
a424 1
ASGLOBAL(initialized_cpu_lock)
d427 1
a427 1
GLOBAL(initialized_cpus)
d430 1
a430 1
ASGLOBAL(master_processor_chosen)
d433 1
a433 1
GLOBAL(inter_processor_lock)
@


1.9.4.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d97 3
a99 3
	or.u	r4, r0, hi16(_C_LABEL(brdtyp))
	ld	r3, r4, lo16(_C_LABEL(brdtyp))
	cmp	r4, r3, BRD_188
d143 1
a143 1
 *               kernel.emini, bootdev, brdtyp); 
a156 13
	or.u	r13, r0,  hi16(_brdtyp)
	st	r8,  r13, lo16(_brdtyp)
	
	/* set _cputyp */
	cmp     r2,  r8, BRD_197	/* r8 contains brdtyp */
        bb1     ne, r2, 1f	/* if it's a '197, CPU is 88110 */ 
	or.u    r13, r0,  hi16(CPU_88110) 
	or	r8,  r13, lo16(CPU_88110)/* r8 contains 0x110 */
	br	2f
1:	
	or.u    r13, r0,  hi16(CPU_88100) 
	or	r8,  r13, lo16(CPU_88100)/* r8 contains 0x100 */
2:	
d158 1
a158 1
	st	r8,  r13, lo16(_cputyp) /* r8 contains cputyp */
d194 2
a195 3
        
	cmp     r2, r8, CPU_88110 /* r8 contains cputyp */
        bb1     eq, r2, 1f      /* if it's a 'mc88110, skip SSBR */
d203 3
a205 3
	set	r11, r11, 1<PSR_GRAPHICS_DISABLE_BIT>
/*	set	r11, r11, 1<PSR_SERIAL_MODE_BIT> */
	set	r11, r11, 1<PSR_SERIALIZE_BIT>
d209 1
a209 1
        cmp     r2, r8, CPU_88110 /* r8 contains cputyp */
a210 1
	
d299 5
a303 5
#ifdef M88110
	cmp	r2, r8, CPU_88110 /* r8 contains cputyp */
	bb1	ne, r2, 1f	/* if it's a 'mc88110, use different vectors */ 
	or.u	r3, r0, hi16(_m88110_vector_list)
	or	r3, r3, lo16(_m88110_vector_list)
d307 1
a307 1
#endif /* M88110 */
d309 1
a309 1
#ifdef M88100
d318 1
a318 1
#endif /* M88100 */
a392 1
#ifdef M88100
d394 1
d400 4
a403 5
#endif /* M88100 */
#ifdef M88110
	.align 4096		  /* VBR points to page aligned list */
	global _m88110_vector_list, _m88110_vector_list_end
_m88110_vector_list:   		  /* references memory BELOW this line */ 
d405 1
a405 1
_m88110_vector_list_end:
d407 1
a407 1
#endif /* M88110 */	
@


1.9.4.5
log
@Sync the SMP branch with 3.3
@
text
@d408 16
@


1.9.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d68 3
a70 1
#include <machine/vmparam.h>
d74 6
a79 5
 *   0x00000 - 0x01000	trap vectors
 *   0x01000 - 0x10000	first 64k used by BUG
 *   0x10000 == start	Boot loader jumps here. (for now, this can
 *			handle only NMAGIC - screwy linker)
 */
d93 1
a93 1
	 * Try hitting the SRST bit in VMEchip2 to reset the system.
d102 1
a102 2
	br	8f
1:
d104 5
a108 9
	or.u	r3, r0, 0xfff4
	ld	r4, r3, 0x0060		/* read offset (LCSR + 0x60) */
	bb0.n	30, r4, 1f		/* if not SYSCON, don't SYSRST */
	 set	r4, r4, 1<23>		/* set SYSRST bit - bit 23 */
	st	r4, r3, 0x0060		/* and store it back  */
1:
	ld	r4, r3, 0x0104		/* try local reset, then */
	set	r4, r4, 1<7>
	st	r4, r3, 0x0104
d111 2
a112 2
	 * We will be here if the reset above failed. In this case,
	 * we will try to return to bug.
d114 4
a117 4
	 * Switch to interrupt stack and call _doboot to take care
	 * going to BUG. Need to do this since _doboot turns off the
	 * the MMU and we need to be on a 1-to-1 mapped stack so that
	 * further calls don't get data access exceptions.
d121 3
a123 3
8:
	or.u	r31, r0,  hi16(_ASM_LABEL(intstack_end))
	or	r31, r31, lo16(_ASM_LABEL(intstack_end))
d129 2
a130 2
	/* This is the *real* start upon poweron or reset */
GLOBAL(start_text)
d134 1
a134 1
	 *	r3 boot controller address
d142 9
a150 9
 * (*entry)(flag, bugargs.ctrl_addr, cp, kernel.smini,kernel.emini,
 *  bootdev, brdtyp);
 */
	or.u	r13, r0,  hi16(_C_LABEL(boothowto))
	st	r2,  r13, lo16(_C_LABEL(boothowto))
	or.u	r13, r0,  hi16(_C_LABEL(bootaddr))
	st	r3,  r13, lo16(_C_LABEL(bootaddr))
	or.u	r13, r0,  hi16(_C_LABEL(first_addr))
	st	r4,  r13, lo16(_C_LABEL(first_addr))
d152 2
a153 2
	or.u	r13, r0,  hi16(_C_LABEL(esym))
	st	r4,  r13, lo16(_C_LABEL(esym))
d155 5
a159 5
	or.u	r13, r0,  hi16(_C_LABEL(bootdev))
	st	r7,  r13, lo16(_C_LABEL(bootdev))
	or.u	r13, r0,  hi16(_C_LABEL(brdtyp))
	st	r8,  r13, lo16(_C_LABEL(brdtyp))

d161 4
a164 4
	cmp	r2,  r8, BRD_197	/* r8 contains brdtyp */
	bb1	ne, r2, 1f	/* if it's a '197, CPU is 88110 */
	or.u	r13, r0,  hi16(CPU_88110)
	or	r8,  r13, lo16(CPU_88110)
d166 7
a172 7
1:
	or.u	r13, r0,  hi16(CPU_88100)
	or	r8,  r13, lo16(CPU_88100)
2:
	or.u	r13, r0,  hi16(_C_LABEL(cputyp))
	st	r8,  r13, lo16(_C_LABEL(cputyp))

d194 1
a194 1
	 * at the same time because interrupts are not actually disabled
d207 3
a209 3

	cmp	r2, r8, CPU_88110	/* r8 contains cputyp */
	bb1	eq, r2, 1f	/* if it's a 'mc88110, skip SSBR */
d214 1
a214 1

d218 1
a218 10
	/*
	 * XXX On 88110 processors, force serial instruction execution for now.
	 * Situation where OoO would break will be hopefully taken care of in
	 * the near future -- miod
	 */
#if 0
	clr	r11, r11, 1<PSR_SERIAL_MODE_BIT>
#else
	set	r11, r11, 1<PSR_SERIAL_MODE_BIT>
#endif
d221 1
d223 3
a225 5
	stcr	r0,  VBR	/* set Vector Base Register to 0, ALWAYS! */
	FLUSH_PIPELINE
	cmp	r2, r8, CPU_88110	/* r8 contains cputyp */
	bb1	eq, r2, _ASM_LABEL(master_start) /* if it's a '197, skip */

d228 4
a231 4
	or.u	r2, r0, hi16(_C_LABEL(edata))
	or	r2, r2, lo16(_C_LABEL(edata))
	or.u	r4, r0, hi16(_C_LABEL(end))
	or	r4, r4, lo16(_C_LABEL(end))
d233 1
a233 1
	 subu	r3, r4, r2
d238 3
a240 3
	or.u	r11, r0,  hi16(_ASM_LABEL(initialized_cpu_lock))
	or	r11, r11, lo16(_ASM_LABEL(initialized_cpu_lock))
1:
d243 4
a246 3
	xmem	r22, r11, r0	/* If r22 gets 0, we have the lock.. */
	bcnd	eq0, r22, 3f	/* ..but if not, we must wait */
2:
d249 4
a252 3
	bcnd	eq0, r22, 1b
	br	2b		/* looks clear -- try to grab */
3:
d254 2
a255 2
	or.u	r11, r0,  hi16(_ASM_LABEL(initialized_cpus))
	ld	r22, r11, lo16(_ASM_LABEL(initialized_cpus))
d257 1
a257 1
	st	r23, r11, lo16(_ASM_LABEL(initialized_cpus))
d259 2
a260 2
	or.u	r11, r0,  hi16(_ASM_LABEL(initialized_cpu_lock))
	st	r0,  r11, lo16(_ASM_LABEL(initialized_cpu_lock))
d262 2
a263 2
	 * Now we view with any other processors to see who's the master.
	 * We first try to obtain a lock to see who's allowed
d266 3
a268 3
	or.u	r11, r0,  hi16(_ASM_LABEL(inter_processor_lock))
	or	r11, r11, lo16(_ASM_LABEL(inter_processor_lock))
1:
d271 3
a273 3
	xmem	r22, r11, r0		/* If r22 gets 0, we have the lock.. */
	bcnd	eq0, r22, 4f		/* ..but if not, we must wait */
2:
d276 3
a278 3
	bcnd	ne0, r22, 2b
	/* since we can be here with caches off, add a few nops to
	   keep the bus from getting overloaded */
d280 1
a280 1
3:
d282 4
a285 3
	bcnd	eq0, r2, 3b
	br	1b			/* looks clear -- try to grab */
4:
d288 2
a289 2
	or.u	r11, r0,  hi16(_ASM_LABEL(master_processor_chosen))
	or	r11, r11, lo16(_ASM_LABEL(master_processor_chosen))
d302 1
a302 1
	bcnd	ne0, r22, _ASM_LABEL(slave_start)
d305 1
a305 1
ASLOCAL(master_start)
d310 2
a311 2
	or.u	r31, r0,  hi16(_ASM_LABEL(intstack_end))
	or	r31, r31, lo16(_ASM_LABEL(intstack_end))
a314 1
#ifdef M88100
d316 7
a322 5
	bb1	ne, r2, 1f	/* if it's a 'mc88110, use different vectors */
#endif
	or.u	r3, r0, hi16(_C_LABEL(m88110_vector_list))
	br.n	2f
	 or	r3, r3, lo16(_C_LABEL(m88110_vector_list))
a323 1
#endif /* M88110 */
d325 8
a332 2
	or.u	r3, r0, hi16(_C_LABEL(vector_list))
	or	r3, r3, lo16(_C_LABEL(vector_list))
d334 1
a334 4
2:
	bsr.n	_C_LABEL(vector_init)
	 ldcr	r2, VBR

d336 2
a337 2
	bsr.n	_C_LABEL(mvme_bootstrap)
	 subu	r31, r31, 40
d339 7
a345 8

	/*
	 * we now know our cpu number, so we
	 * can set interrupt_stack[cpu_number()] = intstack
	 */
	ldcr	r10, SR1
	extu	r10, r10, FLAG_CPU_FIELD_WIDTH<0>	/* r10 <-- CPU# */

d347 4
a350 4
	or.u	r11,  r0, hi16(_C_LABEL(interrupt_stack))
	or	r11, r11, lo16(_C_LABEL(interrupt_stack))
	or.u	r12, r0,  hi16(_C_LABEL(intstack))
	or	r12, r12, lo16(_C_LABEL(intstack))
d363 1
a363 1
	bsr	_C_LABEL(main)
d365 1
a365 1
	bsr	_C_LABEL(panic)
d367 1
a367 1
/*
d370 6
a375 7
ASLOCAL(slave_start)
	/*
	 * While holding the inter_processor_lock, the slave cpu can use
	 * the slavestack to call slave_pre_main and determine its cpu number.
	 * After that, however, it should switch over to the interrupt stack
	 * associated with its cpu.
	 */
d378 2
a379 2
	or.u	r31, r0,  hi16(_ASM_LABEL(slavestack_end))
	or	r31, r31, lo16(_ASM_LABEL(slavestack_end))
d382 2
a383 5
	bsr.n	_C_LABEL(slave_pre_main)	/* set cpu number */
	 subu	r31, r31, 48    		/* allocate frame */

	bsr	_C_LABEL(get_slave_stack)
	addu	r31, r2, INTSTACK_SIZE
d385 2
a386 11
	/*
	 * SR1 now contains our cpu number. We can now release the
	 * inter_processor_lock, as we are done with the slavestack.
	 * We also have an interrupt stack
	 */

	or.u	r10, r0, hi16(_ASM_LABEL(inter_processor_lock))
	st	r0, r10, lo16(_ASM_LABEL(inter_processor_lock))

	br.n	_C_LABEL(slave_main)	/* does not return */
	 subu	r31, r31, 40		/* allocate frame */
d388 10
d399 2
a400 2
	or.u	r3,   r0,  hi16(_C_LABEL(start_text))
	or	r3,   r3,  lo16(_C_LABEL(start_text))
d403 2
a404 2
	jmp	r1

d408 6
a413 4
	.align 4096		/* SDT (segment descriptor table */
GLOBAL(kernel_sdt)
	space	(0x2000)	/* 8K - 4K phys, 4K virt*/
GLOBAL(ret_addr)
d415 5
a419 2
ASLOCAL(initialized_cpu_lock)
	/* XMEM spin lock -- to count CPUs */
d421 2
a422 2
ASLOCAL(initialized_cpus)
	/* CPU counter to initialize */
d424 2
a425 2
ASLOCAL(master_processor_chosen)
	/* The first processor that XMEMs this becomes the master */
d427 2
a428 2
ASLOCAL(inter_processor_lock)
	/* XMEM spin lock -- controls access to master_processor_chosen */
d430 1
a430 1

d432 7
a438 6
GLOBAL(intstack)
	space (INTSTACK_SIZE)	/* 16K, just to be safe */
ASGLOBAL(intstack_end)
ASGLOBAL(slavestack)
	space (NBPG)		/* 4K, small, interim stack */
ASGLOBAL(slavestack_end)
d450 2
a451 1
GLOBAL(idle_u)
d460 3
a462 2
ASLOCAL(u0)
	space	UPAGES * NBPG
d468 2
a469 1
ASGLOBAL(kstack)
d473 2
a474 1
GLOBAL(esym)
d478 2
a479 1
GLOBAL(intiobase)
d481 1
a481 1
GLOBAL(intiolimit)
d484 3
a486 2
GLOBAL(proc0paddr)
	word	_ASM_LABEL(u0)	/*  KVA of proc0 uarea */
d489 1
a489 1
 * curpcb points to the current pcb (and hence u. area).
d497 2
a498 2
GLOBAL(curpcb)
	word	_ASM_LABEL(u0)	/* curpcb = &u0 */
d504 3
a506 1
GLOBAL(sigcode)			/* r31 points to sigframe */
d512 1
a512 1
	 subu	r31, r31, 40	/* give some stack space */
d517 2
a518 4
	NOP			| failure return
#if 0
	NOP			| success return
#endif
d522 4
a525 7
	/*
	 * this never returns, but we need to provide fetchable instructions
	 * for the 88100 pipeline.
	 */
	NOP
	NOP
GLOBAL(esigcode)
d528 2
a529 1
GLOBAL(intrnames)
d542 1
a542 1
GLOBAL(eintrnames)
d544 1
a544 1
GLOBAL(intrcnt)
d546 3
a548 1
GLOBAL(eintrcnt)
@


1.8
log
@Added vme bus device drivers. MVME328, MVME376, MVME332
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.7 1999/02/09 06:36:28 smurph Exp $	*/
d92 3
a94 7
#if 0
	.align 4096		  /* VBR points to page aligned list */
    LABEL(_vector_list)	  /* references memory BELOW this line */
	#include "machine/exception_vectors.h"
	word	END_OF_VECTOR_LIST

#endif
d100 10
d126 1
a135 22
#ifdef OLD_BOOT_LOADER
	/*
	 * Args passed by boot loader
	 * 	r2 howto
	 *	r3 first_addr (first available address)
	 *	r4 ((Clun << 8) ; Dlun & FF) -> bootdev
	 *	r5 esym
	 *	r6 miniroot
	 */
	or.u	r13, r0,  hi16(_boothowto)
	st	r2,  r13, lo16(_boothowto)
	or.u	r13, r0,  hi16(_first_addr)
	st	r3,  r13, lo16(_first_addr)
#if 0
	or.u	r13, r0,  hi16(_bootdev)
	st	r4,  r13, lo16(_bootdev)
#endif
	or.u	r13, r0,  hi16(_esym)
	st	r5,  r13, lo16(_esym)
	or.u	r13, r0,  hi16(_miniroot)
	st	r6,  r13, lo16(_miniroot)
#else /* OLD_BOOT_LOADER */
d143 2
d146 4
d160 5
a164 1
#endif /* OLD_BOOT_LOADER */
d199 2
d202 1
a202 1
#if 0
d205 1
a205 10
#define PSR_SHADOW_FREEZE_BIT		 0
#define PSR_INTERRUPT_DISABLE_BIT	 1
#define PSR_FPU_DISABLE_BIT		 3
#define PSR_BIG_ENDIAN_MODE		30
#define PSR_SUPERVISOR_MODE_BIT		31
	set     r11, r11, 1<PSR_SHADOW_FREEZE_BIT>
	set     r11, r11, 1<PSR_FPU_DISABLE_BIT>
#endif
#define PSR_MXM_DISABLE_BIT		 2

d208 3
a210 1
	set	r11, r11, 1<PSR_MXM_DISABLE_BIT> /* a cheat! for now... */
d212 70
a281 1
        FLUSH_PIPELINE
d283 11
a293 7
#if 0
	or.u	r11, r0,  hi16(_vector_table)
	or	r11, r11, lo16(_vector_table)
	stcr	r11, VBR
#else
	stcr	r0, VBR
#endif /* 0 */
d295 1
d304 11
d323 2
a324 11
	
#if 0
	/* clear BSS. Boot loader might have already done this... */
	or.u	r2, r0, hi16(_edata)
	or	r2, r2, lo16(_edata)
	or.u	r4, r0, hi16(_end)
	or	r4, r4, lo16(_end)
	bsr.n	_bzero		/* bzero(edata, end-edata) */
	subu	r3, r4, r2
#endif

d326 1
a326 1
	bsr.n	_m187_bootstrap
d330 13
a343 1
	
a347 19
	/*
	 * Block clock interrupts for now. There is a problem with
	 * clock interrupts when the first clock interrupt is received.
	 * Hardclock() sees the base priority to be 0 and drops IPL to
	 * splsofclock() before calling softclock(). This opens up other
	 * clock interrupts to be received before the first one is ever
	 * finished. Also, the first entry on calltodo list is stuck for
	 * ever. As a work around, I will set the IPL to softclock so
	 * that the CLKF_BASEPRI() check in hardclock() will return false.
	 * XXX nivas
	 */
	 
#if XXX
	bsr.n	_setipl
	or	r2, r0, IPL_SOFTCLOCK
	bsr	_enable_interrupt
	bsr.n	_setipl
	or	r2, r0, IPL_HIGH
#endif
d357 38
d399 3
a401 1
LABEL(_vector_list)		  /* references memory BELOW this line */
d403 10
a412 2
	word	END_OF_VECTOR_LIST

d415 6
a420 1
	space	(0x1000)	/* 16K */
d427 13
d441 1
a441 2
	global	_intstack
	global	_intstack_end
d443 1
a443 1
	space	(4 * NBPG)	/* 16K, just to be safe*/
d445 3
@


1.7
log
@Added kernel support for user debugging.  Fixed file ID's
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.28 1995/04/19 22:37:27 smurph Exp $	*/
d216 2
d220 1
d319 1
a319 1
	space	(4 * NBPG)	/* 16K */
@


1.6
log
@Commit for the first working mvme88k port.
@
text
@d1 1
@


1.5
log
@mvme88k will not make release, but just as well make the source as close as
possible.
@
text
@d2 1
d93 1
a93 1
    _LABEL(vector_list)	  /* references memory BELOW this line */
a96 2
    _LABEL(_msgsw)
	word 0 /* Bits here turn on/off debugging somewhere. */
d153 1
a153 1
	 *	r3 not used
d160 2
a161 4
#if 0
	or.u	r13, r0,  hi16(_bootdev)
	st	r3,  r13, lo16(_bootdev)
#endif
d204 11
a214 1

d219 1
a219 1
	/* shadowing, FPU, misalgined access exception: all enabled now.*/
d221 2
a222 2
	or.u	r11, r0,  hi16(_vector_list)
	or	r11, r11, lo16(_vector_list)
d224 2
a226 1
	stcr	r0, VBR
d278 1
a278 1
#if XXXX
d286 3
a288 1
	bsr.n	_main
d290 1
d298 1
a298 2
	global _vector_list
_vector_list:			  /* references memory BELOW this line */
d302 6
d327 1
d337 1
a338 1
	align	4096
d355 8
@


1.4
log
@Cleanup after import. This also seems to bring up the current version.
@
text
@d62 1
d64 1
a65 1
#include "machine/trap.h"
d86 1
d299 1
a299 1
	space	4 * NBPG	/* 16K */
@


1.3
log
@This is a remove to get rid of the old mvme88k port which was incomplete
to replace it with a working version. The kernel compiles and works
at least.  The new version will be imported shortly.
@
text
@d2 30
d58 1
a58 6
/* $RCSfile: locore.S,v $ --  asm boot routines
 *
 **********************************************************************
 *****************************************************************RCS**/

#ifndef ASSEMBLER /* predefined by ascpp, at least */
d62 1
a62 1
#include "machine/locore.h"
d65 1
a65 2
#include "machine/asm.h"
#include "machine/board.h"	/* lots of stuff (OBIO_PIO*, SYSV_BASE, etc)*/
a66 1
#include "assym.s"
a69 10
/*
 *  Arrange for the include file version number to appear directly in
 *  the namelist.
 */
global	_INCLUDE_VERSION
def	_INCLUDE_VERSION, INCLUDE_VERSION
#ifndef NBPG
#define	NBPG 4096
#endif /* NBPG */

d71 1
a71 1
#define	UADDR		0xFFEE0000	/* address of u */
d73 1
a73 3
#ifndef USIZE
#define USIZE (UPAGES * NBPG) 
#endif /* USIZE */
a83 1
LABEL(_kernel_text)
d89 1
a89 1
	.align 4096		  ; VBR points to page aligned list
a96 3
/*
 * Do a dump. Called by auto-restart.
 */
d98 25
a122 4
	global	_dumpsys
LABEL(_doadump)
	bsr	_dumpsys
	bsr	_doboot	
d127 1
d132 1
a132 1
	 *	r4 ((Clun << 8) | Dlun & FF) -> bootdev
d148 22
a169 1

a205 1
	/* XXX We can use SR0-SR3 for any purpose */
d209 1
a217 6
/************************************************************************/

#if defined(RAW_PRINTF) && RAW_PRINTF
	bsr  replace_mayput_with_rawputchar
#endif

d219 2
a220 1
	 * switch to interrupt stack
d230 1
a230 1
	or.u	r3, r0,  hi16(_vector_list)
d254 1
a254 1
	addu	r31, r31, USIZE
d256 19
d279 1
a279 1
	br	_return_from_main
d284 1
a284 1
	.align 4096		  ; VBR points to page aligned list
d286 2
a287 2
_vector_list:			  ; references memory BELOW this line
	#include "machine/exception_vectors.h"
d292 1
a292 1
	word 0 			 ;Bits here turn on/off debugging somewhere.
d348 1
a348 1
 * other parts expect XXX
d361 1
a361 1
	ld	r3, r31, 4	/* code */
d363 4
a366 5
	or	r5, r0, 0	/* addr = 0 for now */
	ld	r6, r31, 12	/* handler */
	jsr.n	r6
	addu	r31, r31, 40
	subu	r31, r31, 40
d368 1
a368 1
	or	r9,  r0, SYS_sigreturn
d373 1
a373 1
	or	r9, r0, SYS_exit
a378 182

#if 0
/*
 *	thread_bootstrap:
 *
 *	Bootstrap a new thread using the thread state that has been
 *	placed on the stack.  Our fp has been set up for us, we only need
 *	to fix up a few things in the saved frame, then get into
 *	usermode.
 */
ENTRY(thread_bootstrap)
        /* 
	 * Here r31 should point to the place on our stack which
	 * contains a pointer to our exception frame.
	 */	
#if DDB
        ENTRY_ASM
#endif
	br      return_from_exception_handler

/*
 *	save_context
 */
ENTRY(save_context)
	subu	r31,r31,40		/* allocate stack for r1 and args */
	st	r1,r31,36		/* save return address */
	bsr	_spl			/* get the current interrupt mask */
	ld	r1,r31,36		/* recover return address */
	addu	r31,r31,40		/* put stack pointer back */
	ldcr	r10,SR0			/* r10 <- current_thread() */
	ld	r10,r10,THREAD_PCB	/* r10 <- pcb */
#if (PCB_KERNEL!=0)
     	addu	r10, r10, PCB_KERNEL    /* point to kernel save region */
#endif
	st	r1,r10,0	/* do setjmp */ /* save return address */
	st	r14,r10,4
	st	r15,r10,2*4
	st	r16,r10,3*4
	st	r17,r10,4*4
	st	r18,r10,5*4
	st	r19,r10,6*4
	st	r20,r10,7*4
	st	r21,r10,8*4
	st	r22,r10,9*4
	st	r23,r10,10*4
	st	r24,r10,11*4
	st	r25,r10,12*4
        /* In principle, registers 26-29 are never manipulated in the
           kernel. Maybe we can skip saving them? */
	st	r26,r10,13*4
	st	r27,r10,14*4
	st	r28,r10,15*4
	st	r29,r10,16*4
	st	r30,r10,17*4		/* save frame pointer */
	st	r31,r10,18*4		/* save stack pointer */
	st	r2,r10,19*4		/* save interrupt mask */
       /* we need to switch to the interrupt stack here */
	or.u	r31, r0, hi16(_intstack)
	or	r31, r31, lo16(_intstack)
        addu    r31, r31, INTSTACK_SIZE             /* end of stack */
	clr	r31, r31, 3<0>	/* round down to 8-byte boundary */
	jmp.n	r1
	or	r2,r0,r0
#endif /* 0 */

/* ------------------------------------------------------------------------ */
/*
 * unsigned measure_pause(volatile int *flag)
 *
 * Count cycles executed until *flag becomes nonzero.
 * Return the number of cycles counted.
 */
ENTRY(measure_pause)
	/* R2 is pointer to flag */
	def GRANULAIRTY, 10000

	or	r3, r0, 1	/* r3 is my counter, this is the first */

    measure_pause_outer_loop:
	or	r4, r0, GRANULAIRTY

    measure_pause_inner_loop:
	/*
	 * Execute a tight loop of a known number of cycles.
	 * This assumes, of course, that the instruction cache is on.
	 * This loop takes two cycles per iteration.
	 */
	bcnd.n	ne0, r4, measure_pause_inner_loop
	subu	r4, r4, 1


	/*
	 * Now add the number of cycles done above (plus the overhead
	 * of the outer loop) to the total count.
	 * Also, check the *flag and exit the outer loop if it's non-zero.
	 *
	 * The overhead is really unknown because it's not known how
	 * the memory system will tread the access to *flag, so we just
	 * take a guess.
	 */
	ld	r4, r2, r0			/* get the flag */
	addu	r3, r3, (GRANULAIRTY * 2 + 10)	/* account for the cost */
	bcnd	eq0, r4, measure_pause_outer_loop /* continue or exit the loop*/

	jmp.n	r1
	or	r2, r3, r0	/* pass count back */

/*
 * void delay_in_microseconds(int count)
 *
 * The processor loops (busy waits) for the given number of microseconds:
 * Thus, delay_in_microseconds(1000000) will delay for one second.
 *
 * REGISTER USAGE:
 *  IN  r1   - return address
 *  IN  r2   - (signed int) number of microseconds
 *      r3   - (float) number of microseconds
 *      r4/5 - (double) number of cycles per microsecond
 *      r6   - (float) number of cycles to delay
 *	r7   - (signed) number of cycles to delay
 */
ENTRY(delay_in_microseconds)
ENTRY(delay)
	flt.ss	 r3, r2	    /* convert microseconds from signed int to float */
	or.u	 r4, r0, hi16(_cycles_per_microsecond)
	ld.d	 r4, r4, lo16(_cycles_per_microsecond)
	fmul.ssd r6, r3, r4 /* convert microseconds to cycles */
	int.ss   r7, r6	    /* convert cycles from float to signed int */
	subu	 r7, r7, 25 /* subtract for overhead of above instruction */

	/* now loop for the given number of cycles */
    pause_loop:
	bcnd.n	gt0, r7, pause_loop
	subu	r7, r7, 2	/* two cycles per iteration */

	jmp	r1 /* return */

#if 0
/*
 * void switch_to_shutdown_context(thread_t thread,
 *				   void (*routine)(processor_t),
 *				   processor_t processor)
 *
 * saves the kernel context of the thread,
 * switches to the interrupt stack,
 * continues the thread (with thread_dispatch),
 * then runs routine on the interrupt stack.
 *
 */
  
ENTRY(switch_to_shutdown_context)
/* call save_context to save the thread state */
     	subu 	r31, r31, 40
	or      r25, r3, r0    /* save arguments */
	or	r24, r4, r0     
     	bsr.n 	_save_context
	st	r1, r31, 36
     	addu 	r31, r31, 40
	ldcr	r10, SR0			/* r10 <- current_thread() */
	st      r31, r10, THREAD_KERNEL_STACK   /* save stack pointer */      
	st	r0,  r10, THREAD_SWAP_FUNC      /* null continuation */
        ldcr	r11, SR1
	mak	r11, r11, FLAG_CPU_FIELD_WIDTH<0> /* r1 = cpu # */
	or	r12, r12, lo16(_interrupt_stack)
	ld	r31, r12 [r11]
        addu    r31, r31, INTSTACK_SIZE             /* end of stack */
	clr	r31, r31, 3<0>	/* round down to 8-byte boundary */
        /* save the thread; switched to the interrupt stack; now call thread
	   dispatch to get rid of this thread */
	or	r2, r10, r0      
	bsr.n	_thread_dispatch
     	subu 	r31, r31, 40
  	/* call the continuation routine */
  	jsr.n	r25
	or	r2, r24, r0
        /* panic if here */
        or.u	r2, r0, hi16(1f)
	bsr.n	_panic
	or	r2, r2, lo16(1f)
1:
  	string "switch_to_shutdown_context"
#endif /* 0 */
@


1.2
log
@add kernel_text symbol (just like other archs)
@
text
@@


1.1
log
@moved from m88k directory
@
text
@d73 1
@


1.1.1.1
log
@Third try at importing the mvme88k port. This is a working kernel
from nivas.
Userland and compiler still need to be worked on.
Make certain what directory the import is done from.
@
text
@a1 30
 * Copyright (c) 1996 Nivas Madhur
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Nivas Madhur.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
/*
d28 6
a33 1
#ifndef ASSEMBLER
d37 1
a37 1
#include "machine/asm.h"
d40 2
a41 1
#include "machine/psl.h"
d43 1
d47 10
d58 1
a58 1
#define	UADDR		0xEEE00000	/* address of u */
d60 3
a62 1

d78 1
a78 1
	.align 4096		  /* VBR points to page aligned list */
d86 3
d90 4
a93 25
ENTRY(doboot)
	/*
	 *	Try hitting the SRST bit in VMEchip2 to reset the system.
	 */
	or.u	r3,r0, 0xfff4
	ld	r4,r3, 0x0060		/* read offset (LCSR +0x60) */
	set	r4,r4,1<23>		/* set SYSRST bit - bit 23 */	
	st	r4,r3, 0x0060		/* and store it back  */

	/*
	 *	We will be here if the reset above failed. In this case,
	 *	we will try to return to bug.
	 *
	 *	Switch to interrupt stack and call __doboot to take care
	 *	going to BUG. Need to do this since __doboot turns off the
	 *	the MMU and we need to be on a 1-to-1 mapped stack so that
	 *	further calls don't get data access exceptions.
	 */

	/* Should we use idle_u instead? XXX nivas */
	or.u	r31, r0,  hi16(_intstack_end)
	or	r31, r31, lo16(_intstack_end)
	clr	r31, r31, 3<0>	/* round down to 8-byte boundary */

	bsr	__doboot
a97 1
#ifdef OLD_BOOT_LOADER
d102 1
a102 1
	 *	r4 ((Clun << 8) ; Dlun & FF) -> bootdev
d118 1
a118 22
#else /* OLD_BOOT_LOADER */
	/*
	 * Args passed by boot loader
	 * 	r2 howto
	 *	r3 not used
	 *	r4 esym
	 *	r5 start of mini
	 *	r6 end miniroot
	 */
	or.u	r13, r0,  hi16(_boothowto)
	st	r2,  r13, lo16(_boothowto)
#if 0
	or.u	r13, r0,  hi16(_bootdev)
	st	r3,  r13, lo16(_bootdev)
#endif
	or.u	r13, r0,  hi16(_first_addr)
	st	r4,  r13, lo16(_first_addr)
	or.u	r13, r0,  hi16(_esym)
	st	r4,  r13, lo16(_esym)
	or.u	r13, r0,  hi16(_miniroot)
	st	r5,  r13, lo16(_miniroot)
#endif /* OLD_BOOT_LOADER */
d155 1
a158 1
        FLUSH_PIPELINE
d167 6
d174 1
a174 2
	 * Switch to interrupt stack
	 * Use idle_u's stack instead?
d184 1
a184 1
	or.u	r3, r0, hi16(_vector_list)
d208 1
a208 1
	addu	r31, r31, USIZE - 8
a209 19
	/*
	 * Block clock interrupts for now. There is a problem with
	 * clock interrupts when the first clock interrupt is received.
	 * Hardclock() sees the base priority to be 0 and drops IPL to
	 * splsofclock() before calling softclock(). This opens up other
	 * clock interrupts to be received before the first one is ever
	 * finished. Also, the first entry on calltodo list is stuck for
	 * ever. As a work around, I will set the IPL to softclock so
	 * that the CLKF_BASEPRI() check in hardclock() will return false.
	 * XXX nivas
	 */
	 
#if XXXX
	bsr.n	_setipl
	or	r2, r0, IPL_SOFTCLOCK
	bsr	_enable_interrupt
	bsr.n	_setipl
	or	r2, r0, IPL_HIGH
#endif
d214 1
a214 1
	bsr	_panic
d219 1
a219 1
	.align 4096		  /* VBR points to page aligned list */
d221 2
a222 2
_vector_list:			  /* references memory BELOW this line */
#include "machine/exception_vectors.h"
d227 1
a227 1
	word 0 			 /* Bits here turn on/off debugging somewhere */
d283 1
a283 1
 * other parts expect XXX nivas
d296 1
a296 1
	ld	r3, r31, 4	/* siginfo_t* */
d298 5
a302 4
	ld	r5, r31, 12	/* handler */
	jsr.n	r5
	subu	r31, r31, 40	/* give some stack space */
	addu	r31, r31, 40	/* restore old sp value  */
d304 1
a304 1
	or	r13,  r0, SYS_sigreturn
d309 1
a309 1
	or	r13, r0, SYS_exit
d315 182
@
