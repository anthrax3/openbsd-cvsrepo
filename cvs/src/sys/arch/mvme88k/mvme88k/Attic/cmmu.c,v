head	1.28;
access;
symbols
	SMP_SYNC_A:1.28
	SMP_SYNC_B:1.28
	OPENBSD_3_5:1.27.0.2
	OPENBSD_3_5_BASE:1.27
	OPENBSD_3_4:1.20.0.8
	OPENBSD_3_4_BASE:1.20
	UBC_SYNC_A:1.20
	OPENBSD_3_3:1.20.0.6
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.20.0.4
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.20.0.2
	OPENBSD_3_1_BASE:1.20
	UBC_SYNC_B:1.20
	UBC:1.17.0.2
	UBC_BASE:1.17
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.6.0.4
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	SMP:1.5.0.4
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	mvme88kport:1.1.1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.28
date	2004.04.29.14.33.27;	author miod;	state dead;
branches;
next	1.27;

1.27
date	2004.01.20.14.35.54;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2004.01.17.22.35.41;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2004.01.09.00.23.08;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2004.01.07.23.43.54;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2003.12.29.10.54.09;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2003.10.05.20.27.47;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2003.09.16.20.52.22;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2002.03.14.01.26.39;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2001.12.22.09.49.39;	author smurph;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.22.07.35.43;	author smurph;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.19.07.04.41;	author smurph;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2001.12.16.23.49.46;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.13.08.55.51;	author smurph;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.27.05.37.02;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2001.09.28.20.46.42;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.26.14.31.12;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.21.22.19.50;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.18.01.52.30;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.09.05.44.41;	author smurph;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.08.00.03.30;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2001.02.01.03.38.19;	author smurph;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.03.00.54.53;	author todd;	state Exp;
branches;
next	1.5;

1.5
date	99.09.27.19.13.21;	author smurph;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	98.12.15.05.11.01;	author smurph;	state Exp;
branches;
next	1.3;

1.3
date	97.03.03.20.21.30;	author rahnds;	state Exp;
branches;
next	1.2;

1.2
date	97.03.03.19.07.59;	author rahnds;	state dead;
branches;
next	1.1;

1.1
date	95.10.18.12.32.19;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.03.03.19.32.22;	author rahnds;	state Exp;
branches;
next	;

1.5.4.1
date	2000.03.24.09.08.17;	author niklas;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2001.04.18.16.11.29;	author niklas;	state Exp;
branches;
next	1.5.4.3;

1.5.4.3
date	2001.07.04.10.20.07;	author niklas;	state Exp;
branches;
next	1.5.4.4;

1.5.4.4
date	2001.10.31.03.01.19;	author nate;	state Exp;
branches;
next	1.5.4.5;

1.5.4.5
date	2001.12.05.00.39.12;	author niklas;	state Exp;
branches;
next	1.5.4.6;

1.5.4.6
date	2002.03.06.02.04.44;	author niklas;	state Exp;
branches;
next	1.5.4.7;

1.5.4.7
date	2002.03.28.10.36.02;	author niklas;	state Exp;
branches;
next	1.5.4.8;

1.5.4.8
date	2004.02.19.10.49.07;	author niklas;	state Exp;
branches;
next	1.5.4.9;

1.5.4.9
date	2004.06.05.23.09.50;	author niklas;	state dead;
branches;
next	;

1.17.2.1
date	2002.01.31.22.55.18;	author niklas;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2002.06.11.03.37.10;	author art;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Continue factorizing m88k common code, this time files in <arch>/<arch>
which were copied verbatim from mvme88k to luna88k.

This requires backing out syntactic sugar in mvme88k kernel configuration
files which would deduct the required processor types from the board models,
as the common code only depends upon the M88100 and M88110 defines.
@
text
@/*	$OpenBSD: cmmu.c,v 1.27 2004/01/20 14:35:54 miod Exp $	*/
/*
 * Copyright (c) 1998 Steve Murphree, Jr.
 * Copyright (c) 1996 Nivas Madhur
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Nivas Madhur.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
/*
 * Mach Operating System
 * Copyright (c) 1993-1991 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON AND OMRON ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON AND OMRON DISCLAIM ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/types.h>
#include <sys/simplelock.h>
#include <machine/cmmu.h>
#include <machine/cpu_number.h>

/*
 * This lock protects the cmmu SAR and SCR's; other ports
 * can be accessed without locking it.
 *
 * May be used from "db_interface.c".
 */
struct simplelock cmmu_cpu_lock;

unsigned cpu_sets[MAX_CPUS];
unsigned master_cpu = 0;
int      max_cpus, max_cmmus;

struct cmmu_p *cmmu;
@


1.27
log
@Use shifts and logical arithmetic, rather than multiplications and integer
arithmetic, when computing cmmu numbers.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.c,v 1.26 2004/01/17 22:35:41 miod Exp $	*/
@


1.26
log
@Now that the phys_map_vaddr bug is out of the way, it's time to bring back
diffs which had been suspected of breakage while they were just helping this
bug to trigger.

Don't flush user tlb in the scheduler, since pmap_activate() will take care
of it if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.c,v 1.25 2004/01/09 00:23:08 miod Exp $	*/
a76 1
int      cpu_cmmu_ratio;
@


1.25
log
@Do not define new m8820x specific constants for what are common cache and
apr validity constants, really.

And get rid of the old cache_policy debug trick.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.c,v 1.24 2004/01/07 23:43:54 miod Exp $	*/
a79 9

void md_cmmu_flush_tlb(unsigned kernel, vaddr_t vaddr, int size);

/* This is here so that process.S doesn't have to decide the CPU type */
void
md_cmmu_flush_tlb(unsigned kernel, vaddr_t vaddr, int size)
{
	cmmu_flush_tlb(cpu_number(), kernel, vaddr, size);
}
@


1.24
log
@Revert the pmap machinery to 20031228. The changes made since all produce
different subtle races, and need more tinkering until they are really safe.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.c,v 1.23 2003/12/29 10:54:09 miod Exp $	*/
a73 1
unsigned cache_policy = /*CACHE_INH*/ 0;
@


1.23
log
@Since pmap_activate() does a complete user tlb flush, it is not necessary
to do another one in process.S...
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.c,v 1.22 2003/10/05 20:27:47 miod Exp $	*/
d81 9
@


1.22
log
@Kill vm_offset_t and vm_size_t, in favor of the [pv]addr_t and [pv]size_t
typedefs.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.c,v 1.21 2003/09/16 20:52:22 miod Exp $	*/
a80 9

void md_cmmu_flush_tlb(unsigned kernel, vaddr_t vaddr, int size);

/* This is here so that process.S doesn't have to decide the CPU type */
void
md_cmmu_flush_tlb(unsigned kernel, vaddr_t vaddr, int size)
{
	cmmu_flush_tlb(kernel, vaddr, size);
}
@


1.21
log
@Remove unused material from include files, as well as the annoying U() macro
which is only used to obfuscate things.

Doing this points out that the BUG memory is not at the same address on
187 and 197 (the 197 BUG is inside obio), so provide distinct constants,
and treat 187 and 197 slightly differently in pmap_bootstrap(). However, we
now need to map the 197 flash memory as well...

While there, simplify and constify pmap_table_build() and its associated data.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.c,v 1.20 2002/03/14 01:26:39 millert Exp $	*/
d66 3
a68 3
/* 
 * This lock protects the cmmu SAR and SCR's; other ports 
 * can be accessed without locking it 
d73 1
d82 1
a82 1
void md_cmmu_flush_tlb(unsigned kernel, vm_offset_t vaddr, int size);
d85 2
a86 2
void 
md_cmmu_flush_tlb(unsigned kernel, vm_offset_t vaddr, int size)
a89 1

@


1.20
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.c,v 1.19 2001/12/22 09:49:39 smurph Exp $	*/
a63 1
#include <machine/cpus.h>
a74 1
unsigned number_cpus = 0;
@


1.19
log
@masive cmmu overhaul.  function pointers now control cmmu functionality
instead of case statements based on cpu type.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.c,v 1.18 2001/12/22 07:35:43 smurph Exp $	*/
d83 1
a83 1
void md_cmmu_flush_tlb __P((unsigned kernel, vm_offset_t vaddr, int size));
@


1.18
log
@rename m882xx.h to m8820x.h
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.c,v 1.16 2001/12/16 23:49:46 miod Exp $	*/
a62 3

#include <machine/mmu.h>
#include <machine/board.h>
a65 6
#ifdef M88100
#include <machine/m8820x.h>
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef M88110
#include <machine/m88110.h>
#endif /* MVME197 */
a73 4

#define CMMU_LOCK   simple_lock(&cmmu_cpu_lock)
#define CMMU_UNLOCK simple_unlock(&cmmu_cpu_lock)

d81 1
a81 91
#ifdef CMMU_DEBUG
void
show_apr(unsigned value)
{
	switch (cputyp) {
#ifdef M88100
	case CPU_88100:
		m18x_show_apr(value);
		break;
#endif
#ifdef M88110
	case CPU_88110:
		m197_show_apr(value);
		break;
#endif 
	}
}

void
show_sctr(unsigned value)
{
	switch (cputyp) {
#ifdef M88100
	case CPU_88100:
		m18x_show_sctr(value);
		break;
#endif
#ifdef M88110
	case CPU_88110:
		m197_show_sctr(value);
		break;
#endif 
	}
}
#endif /* CMMU_DEBUG */

void 
setup_board_config(void)
{
	switch (cputyp) {
#ifdef M88100
	case CPU_88100:
		m18x_setup_board_config();
		break;
#endif
#ifdef M88110
	case CPU_88110:
		m197_setup_board_config();
		break;
#endif 
	}
}

void 
setup_cmmu_config(void)
{
	int cpu;

	for (cpu = 0; cpu < MAX_CPUS; cpu++)
		cpu_sets[cpu] = 0;

	switch (cputyp) {
#ifdef M88100
	case CPU_88100:
		m18x_setup_cmmu_config();
		break;
#endif
#ifdef M88110
	case CPU_88110:
		m197_setup_cmmu_config();
		break;
#endif 
	}
}

void 
cmmu_dump_config(void)
{
	switch (cputyp) {
#ifdef M88100
	case CPU_88100:
		m18x_cmmu_dump_config();
		break;
#endif
#ifdef M88110
	case CPU_88110:
		m197_cmmu_dump_config();
		break;
#endif 
	}
}
d83 1
a83 25
#ifdef DDB
/*
 * Used by DDB for cache probe functions
 */
unsigned 
cmmu_get_by_mode(int cpu, int mode)
{
	unsigned retval;
	CMMU_LOCK;
	switch (cputyp) {
#ifdef M88100
	case CPU_88100:
		retval = m18x_cmmu_get_by_mode(cpu, mode);
		break;
#endif
#ifdef M88110
	case CPU_88110:
		retval = m197_cmmu_get_by_mode(cpu, mode);
		break;
#endif 
	}
	CMMU_UNLOCK;
	return retval;
}
#endif
d85 1
a85 5
/*
 * Should only be called after the calling cpus knows its cpu
 * number and master/slave status . Should be called first
 * by the master, before the slaves are started.
*/
d87 1
a87 333
cpu_configuration_print(int master)
{
	CMMU_LOCK;
	switch (cputyp) {
#ifdef M88100
	case CPU_88100:
		m18x_cpu_configuration_print(master);
		break;
#endif
#ifdef M88110
	case CPU_88110:
		m197_cpu_configuration_print(master);
		break;
#endif 
	}
	CMMU_UNLOCK;
}

/*
 * CMMU initialization routine
 */
void 
cmmu_init(void)
{
	/* init the lock */
	simple_lock_init(&cmmu_cpu_lock);

	switch (cputyp) {
#ifdef M88100
	case CPU_88100:
		m18x_cmmu_init();
		break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef M88110
	case CPU_88110:
		m197_cmmu_init();
		break;
#endif /* MVME197 */
	}
}

/*
 * Just before poweroff or reset....
 */
void
cmmu_shutdown_now(void)
{
	CMMU_LOCK;
	switch (cputyp) {
#ifdef M88100
	case CPU_88100:
		m18x_cmmu_shutdown_now();
		break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef M88110
	case CPU_88110:
		m197_cmmu_shutdown_now();
		break;
#endif /* MVME197 */
	}
	CMMU_UNLOCK;
}

#define PARITY_ENABLE

/*
 * enable parity
 */
void 
cmmu_parity_enable(void)
{
#ifdef PARITY_ENABLE
	CMMU_LOCK;
	switch (cputyp) {
#ifdef M88100
	case CPU_88100:
		m18x_cmmu_parity_enable();
		break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef M88110
	case CPU_88110:
		m197_cmmu_parity_enable();
		break;
#endif /* MVME197 */
	}
	CMMU_UNLOCK;
#endif  /* PARITY_ENABLE */
}

/*
 * Find out the CPU number from accessing CMMU
 * Better be at splhigh, or even better, with interrupts
 * disabled.
 */
unsigned 
cmmu_cpu_number(void)
{
	unsigned retval;
	CMMU_LOCK;
	switch (cputyp) {
#ifdef M88100
	case CPU_88100:
		retval = m18x_cmmu_cpu_number();
		break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef M88110
	case CPU_88110:
		retval = m197_cmmu_cpu_number();
		break;
#endif /* MVME197 */
	}
	CMMU_UNLOCK;
	return retval;
}

/**
 **	Functions that actually modify CMMU registers.
 **/

void
cmmu_remote_set(unsigned cpu, unsigned r, unsigned data, unsigned x)
{
	CMMU_LOCK;
	switch (cputyp) {
#ifdef M88100
	case CPU_88100:
		m18x_cmmu_remote_set(cpu, r, data, x);
		break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef M88110
	case CPU_88110:
		m197_cmmu_remote_set(cpu, r, data, x);
		break;
#endif /* MVME197 */
	}
	CMMU_UNLOCK;
}

/*
 * cmmu_cpu_lock should be held when called if read
 * the CMMU_SCR or CMMU_SAR.
 */
unsigned
cmmu_remote_get(unsigned cpu, unsigned r, unsigned data)
{
	unsigned retval;
	CMMU_LOCK;
	switch (cputyp) {
#ifdef M88100
	case CPU_88100:
		retval = m18x_cmmu_remote_get(cpu, r, data);
		break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef M88110
	case CPU_88110:
		retval = m197_cmmu_remote_get(cpu, r, data);
		break;
#endif /* MVME197 */
	}
	CMMU_UNLOCK;
	return retval;
}

/* Needs no locking - read only registers */
unsigned
cmmu_get_idr(unsigned data)
{
	unsigned retval;
	CMMU_LOCK;
	switch (cputyp) {
#ifdef M88100
	case CPU_88100:
		retval = m18x_cmmu_get_idr(data);
		break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef M88110
	case CPU_88110:
		retval = m197_cmmu_get_idr(data);
		break;
#endif /* MVME197 */
	}
	CMMU_UNLOCK;
	return retval;
}

void
cmmu_set_sapr(unsigned ap)
{
	CMMU_LOCK;
	switch (cputyp) {
#ifdef M88100
	case CPU_88100:
		m18x_cmmu_set_sapr(ap);
		break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef M88110
	case CPU_88110:
		m197_cmmu_set_sapr(ap);
		break;
#endif /* MVME197 */
	}
	CMMU_UNLOCK;
}

void
cmmu_remote_set_sapr(unsigned cpu, unsigned ap)
{
	CMMU_LOCK;
	switch (cputyp) {
#ifdef M88100
	case CPU_88100:
		m18x_cmmu_remote_set_sapr(cpu, ap);
		break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef M88110
	case CPU_88110:
		m197_cmmu_remote_set_sapr(cpu, ap);
		break;
#endif /* MVME197 */
	}
	CMMU_UNLOCK;
}

void
cmmu_set_uapr(unsigned ap)
{
	register int s = splhigh();
	CMMU_LOCK;
	switch (cputyp) {
#ifdef M88100
	case CPU_88100:
		m18x_cmmu_set_uapr(ap);
		break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef M88110
	case CPU_88110:
		m197_cmmu_set_uapr(ap);
		break;
#endif /* MVME197 */
	}
	CMMU_UNLOCK;
	splx(s);
}

/*
 * Set batc entry number entry_no to value in 
 * the data or instruction cache depending on data.
 *
 * Except for the cmmu_init, this function, cmmu_set_pair_batc_entry,
 * and cmmu_pmap_activate are the only functions which may set the
 * batc values.
 */
void
cmmu_set_batc_entry(
                   unsigned cpu,
                   unsigned entry_no,
                   unsigned data,   /* 1 = data, 0 = instruction */
                   unsigned value)  /* the value to stuff into the batc */
{
	CMMU_LOCK;
	switch (cputyp) {
#ifdef M88100
	case CPU_88100:
		m18x_cmmu_set_batc_entry(cpu, entry_no, data, value);
		break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef M88110
	case CPU_88110:
		m197_cmmu_set_batc_entry(cpu, entry_no, data, value);
		break;
#endif /* MVME197 */
	}
	CMMU_UNLOCK;
}

/*
 * Set batc entry number entry_no to value in 
 * the data and instruction cache for the named CPU.
 */
void
cmmu_set_pair_batc_entry(
                        unsigned cpu,
                        unsigned entry_no,
                        unsigned value)  /* the value to stuff into the batc */
{
	CMMU_LOCK;
	switch (cputyp) {
#ifdef M88100
	case CPU_88100:
		m18x_cmmu_set_pair_batc_entry(cpu, entry_no, value);
		break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef M88110
	case CPU_88110:
		m197_cmmu_set_pair_batc_entry(cpu, entry_no, value);
		break;
#endif /* MVME197 */
	}
	CMMU_UNLOCK;
}

/**
 **	Functions that invalidate TLB entries.
 **/

/*
 *	flush any tlb
 *	Some functionality mimiced in cmmu_pmap_activate.
 */
void
cmmu_flush_remote_tlb(unsigned cpu, unsigned kernel, vm_offset_t vaddr, int size)
{
	CMMU_LOCK;
	switch (cputyp) {
#ifdef M88100
	case CPU_88100:
		m18x_cmmu_flush_remote_tlb(cpu, kernel, vaddr, size);
		break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef M88110
	case CPU_88110:
		m197_cmmu_flush_remote_tlb(cpu, kernel, vaddr, size);
		break;
#endif /* MVME197 */
	}
	CMMU_UNLOCK;
}

/*
 *	flush my personal tlb
 */
void
cmmu_flush_tlb(unsigned kernel, vm_offset_t vaddr, int size)
d89 1
a89 3
	int cpu;
	cpu = cpu_number();
	cmmu_flush_remote_tlb(cpu, kernel, vaddr, size);
a91 285
/*
 * New fast stuff for pmap_activate.
 * Does what a few calls used to do.
 * Only called from pmap.c's _pmap_activate().
 */
void
cmmu_pmap_activate(
		  unsigned cpu,
		  unsigned uapr,
		  batc_template_t i_batc[BATC_MAX],
		  batc_template_t d_batc[BATC_MAX])
{
	register int s = splhigh();
	CMMU_LOCK;
	switch (cputyp) {
#ifdef M88100
	case CPU_88100:
		m18x_cmmu_pmap_activate(cpu, uapr, i_batc, d_batc);
		break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef M88110
	case CPU_88110:
		m197_cmmu_pmap_activate(cpu, uapr, i_batc, d_batc);
		break;
#endif /* MVME197 */
	}
	CMMU_UNLOCK;
	splx(s);
}

/**
 **	Functions that invalidate caches.
 **
 ** Cache invalidates require physical addresses.  Care must be exercised when
 ** using segment invalidates.  This implies that the starting physical address
 ** plus the segment length should be invalidated.  A typical mistake is to
 ** extract the first physical page of a segment from a virtual address, and
 ** then expecting to invalidate when the pages are not physically contiguous.
 **
 ** We don't push Instruction Caches prior to invalidate because they are not
 ** snooped and never modified (I guess it doesn't matter then which form
 ** of the command we use then).
 **/
/*
 *	flush both Instruction and Data caches
 */
void
cmmu_flush_remote_cache(int cpu, vm_offset_t physaddr, int size)
{
	CMMU_LOCK;
	switch (cputyp) {
#ifdef M88100
	case CPU_88100:
		m18x_cmmu_flush_remote_cache(cpu, physaddr, size);
		break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef M88110
	case CPU_88110:
		m197_cmmu_flush_remote_cache(cpu, physaddr, size);
		break;
#endif /* MVME197 */
	}
	CMMU_UNLOCK;
}

/*
 *	flush both Instruction and Data caches
 */
void
cmmu_flush_cache(vm_offset_t physaddr, int size)
{
	int cpu = cpu_number();
	cmmu_flush_remote_cache(cpu, physaddr, size);
}

/*
 *	flush Instruction caches
 */
void
cmmu_flush_remote_inst_cache(int cpu, vm_offset_t physaddr, int size)
{
	CMMU_LOCK;
	switch (cputyp) {
#ifdef M88100
	case CPU_88100:
		m18x_cmmu_flush_remote_inst_cache(cpu, physaddr, size);
		break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef M88110
	case CPU_88110:
		m197_cmmu_flush_remote_inst_cache(cpu, physaddr, size);
		break;
#endif /* MVME197 */
	}
	CMMU_UNLOCK;
}

/*
 *	flush Instruction caches
 */
void
cmmu_flush_inst_cache(vm_offset_t physaddr, int size)
{
	int cpu;
	cpu = cpu_number();
	cmmu_flush_remote_inst_cache(cpu, physaddr, size);
}

void
cmmu_flush_remote_data_cache(int cpu, vm_offset_t physaddr, int size)
{ 
	CMMU_LOCK;
	switch (cputyp) {
#ifdef M88100
	case CPU_88100:
		m18x_cmmu_flush_remote_data_cache(cpu, physaddr, size);
		break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef M88110
	case CPU_88110:
		m197_cmmu_flush_remote_data_cache(cpu, physaddr, size);
		break;
#endif /* MVME197 */
	}
	CMMU_UNLOCK;
}

/*
 * flush data cache
 */ 
void
cmmu_flush_data_cache(vm_offset_t physaddr, int size)
{ 
	int cpu;
	cpu = cpu_number();
	cmmu_flush_remote_data_cache(cpu, physaddr, size);
}

#if 0
/*
 * sync dcache (and icache too)
 */
void
cmmu_sync_cache(vm_offset_t physaddr, int size)
{
	CMMU_LOCK;
	switch (cputyp) {
#ifdef M88100
	case CPU_88100:
		m18x_cmmu_sync_cache(physaddr, size);
		break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef M88110
	case CPU_88110:
		m197_cmmu_sync_cache(physaddr, size);
		break;
#endif /* MVME197 */
	}
	CMMU_UNLOCK;
}

void
cmmu_sync_inval_cache(vm_offset_t physaddr, int size)
{
	CMMU_LOCK;
	switch (cputyp) {
#ifdef M88100
	case CPU_88100:
		m18x_cmmu_sync_inval_cache(physaddr, size);
		break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef M88110
	case CPU_88110:
		m197_cmmu_sync_inval_cache(physaddr, size);
		break;
#endif /* MVME197 */
	}
	CMMU_UNLOCK;
}

void
cmmu_inval_cache(vm_offset_t physaddr, int size)
{
	CMMU_LOCK;
	switch (cputyp) {
#ifdef M88100
	case CPU_88100:
		m18x_cmmu_inval_cache(physaddr, size);
		break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef M88110
	case CPU_88110:
		m197_cmmu_inval_cache(physaddr, size);
		break;
#endif /* MVME197 */
	}
	CMMU_UNLOCK;
}
#endif

void
dma_cachectl(vm_offset_t va, int size, int op)
{
	CMMU_LOCK;
	switch (cputyp) {
#ifdef M88100
	case CPU_88100:
		m18x_dma_cachectl(va, size, op);
		break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef M88110
	case CPU_88110:
		m197_dma_cachectl(va, size, op);
		break;
#endif /* MVME197 */
	}
	CMMU_UNLOCK;
}

#ifdef DDB

/*
 * Show (for debugging) how the given CMMU translates the given ADDRESS.
 * If cmmu == -1, the data cmmu for the current cpu is used.
 */
void
cmmu_show_translation(
                     unsigned address,
                     unsigned supervisor_flag,
                     unsigned verbose_flag,
                     int cmmu_num)
{
	CMMU_LOCK;
	switch (cputyp) {
#ifdef M88100
	case CPU_88100:
		m18x_cmmu_show_translation(address, supervisor_flag, 
					   verbose_flag, cmmu_num);
		break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef M88110
	case CPU_88110:
		m197_cmmu_show_translation(address, supervisor_flag, 
					   verbose_flag, cmmu_num);
		break;
#endif /* MVME197 */
	}
	CMMU_UNLOCK;
}


void
cmmu_cache_state(unsigned addr, unsigned supervisor_flag)
{
	switch (cputyp) {
#ifdef M88100
	case CPU_88100:
		m18x_cmmu_cache_state(addr, supervisor_flag);
		break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef M88110
	case CPU_88110:
		m197_cmmu_cache_state(addr, supervisor_flag);
		break;
#endif /* MVME197 */
	}
}

void
show_cmmu_info(unsigned addr)
{
	switch (cputyp) {
#ifdef M88100
	case CPU_88100:
		m18x_show_cmmu_info(addr);
		break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef M88110
	case CPU_88110:
		m197_show_cmmu_info(addr);
		break;
#endif /* MVME197 */
	}
}
#endif /* end if DDB */
@


1.17
log
@Introduce brdtyp and change what cputyp means.
@
text
@d70 1
a70 1
#include <machine/m882xx.h>
@


1.17.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.c,v 1.19 2001/12/22 09:49:39 smurph Exp $	*/
d63 3
d69 6
d83 4
d94 91
a184 1
struct cmmu_p *cmmu;
d186 25
a210 1
void md_cmmu_flush_tlb __P((unsigned kernel, vm_offset_t vaddr, int size));
d212 5
a216 1
/* This is here so that process.S doesn't have to decide the CPU type */
d218 333
a550 1
md_cmmu_flush_tlb(unsigned kernel, vm_offset_t vaddr, int size)
d552 3
a554 1
	cmmu_flush_tlb(kernel, vaddr, size);
d557 285
@


1.17.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.c,v 1.17.2.1 2002/01/31 22:55:18 niklas Exp $	*/
d83 1
a83 1
void md_cmmu_flush_tlb(unsigned kernel, vm_offset_t vaddr, int size);
@


1.16
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.c,v 1.14 2001/11/27 05:37:02 miod Exp $	*/
d69 1
a69 1
#if defined(MVME187) || defined(MVME188)
d72 1
a72 1
#ifdef MVME197
d98 5
a102 6
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_show_apr(value);
      break;
d104 4
a107 4
#ifdef MVME197
   case CPU_197:
      m197_show_apr(value);
      break;
d109 1
a109 1
   }
d115 5
a119 6
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_show_sctr(value);
      break;
d121 4
a124 4
#ifdef MVME197
   case CPU_197:
      m197_show_sctr(value);
      break;
d126 1
a126 1
   }
d133 5
a137 6
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_setup_board_config();
      break;
d139 4
a142 4
#ifdef MVME197
   case CPU_197:
      m197_setup_board_config();
      break;
d144 1
a144 1
   }
d156 2
a157 3
#if defined(MVME187) || defined(MVME188)
	case CPU_187:
	case CPU_188:
d161 2
a162 2
#ifdef MVME197
	case CPU_197:
d172 5
a176 6
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_cmmu_dump_config();
      break;
d178 4
a181 4
#ifdef MVME197
   case CPU_197:
      m197_cmmu_dump_config();
      break;
d183 1
a183 1
   }
d193 7
a199 8
   unsigned retval;
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      retval = m18x_cmmu_get_by_mode(cpu, mode);
      break;
d201 4
a204 4
#ifdef MVME197
   case CPU_197:
      retval = m197_cmmu_get_by_mode(cpu, mode);
      break;
d206 3
a208 3
   }
   CMMU_UNLOCK;
   return retval;
d220 6
a225 7
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_cpu_configuration_print(master);
      break;
d227 4
a230 4
#ifdef MVME197
   case CPU_197:
      m197_cpu_configuration_print(master);
      break;
d232 2
a233 2
   }
   CMMU_UNLOCK;
d246 2
a247 3
#if defined(MVME187) || defined(MVME188)
	case CPU_187:
	case CPU_188:
d251 2
a252 2
#ifdef MVME197
	case CPU_197:
d265 11
a275 12
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_cmmu_shutdown_now();
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      m197_cmmu_shutdown_now();
      break;
d277 2
a278 2
   }
   CMMU_UNLOCK;
d290 11
a300 12
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_cmmu_parity_enable();
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      m197_cmmu_parity_enable();
      break;
d302 2
a303 2
   }
   CMMU_UNLOCK;
d315 16
a330 17
   unsigned retval;
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      retval = m18x_cmmu_cpu_number();
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      retval = m197_cmmu_cpu_number();
      break;
#endif /* MVME197 */
   }
   CMMU_UNLOCK;
   return retval;
d340 11
a350 12
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_cmmu_remote_set(cpu, r, data, x);
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      m197_cmmu_remote_set(cpu, r, data, x);
      break;
d352 2
a353 2
   }
   CMMU_UNLOCK;
d363 16
a378 17
   unsigned retval;
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      retval = m18x_cmmu_remote_get(cpu, r, data);
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      retval = m197_cmmu_remote_get(cpu, r, data);
      break;
#endif /* MVME197 */
   }
   CMMU_UNLOCK;
   return retval;
d385 16
a400 17
   unsigned retval;
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      retval = m18x_cmmu_get_idr(data);
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      retval = m197_cmmu_get_idr(data);
      break;
#endif /* MVME197 */
   }
   CMMU_UNLOCK;
   return retval;
d406 11
a416 12
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_cmmu_set_sapr(ap);
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      m197_cmmu_set_sapr(ap);
      break;
d418 2
a419 2
   }
   CMMU_UNLOCK;
d425 11
a435 12
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_cmmu_remote_set_sapr(cpu, ap);
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      m197_cmmu_remote_set_sapr(cpu, ap);
      break;
d437 2
a438 2
   }
   CMMU_UNLOCK;
d447 2
a448 3
#if defined(MVME187) || defined(MVME188)
	case CPU_187:
	case CPU_188:
d452 2
a453 2
#ifdef MVME197
	case CPU_197:
d477 11
a487 12
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_cmmu_set_batc_entry(cpu, entry_no, data, value);
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      m197_cmmu_set_batc_entry(cpu, entry_no, data, value);
      break;
d489 2
a490 2
   }
   CMMU_UNLOCK;
d503 11
a513 12
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_cmmu_set_pair_batc_entry(cpu, entry_no, value);
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      m197_cmmu_set_pair_batc_entry(cpu, entry_no, value);
      break;
d515 2
a516 2
   }
   CMMU_UNLOCK;
d530 11
a540 12
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_cmmu_flush_remote_tlb(cpu, kernel, vaddr, size);
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      m197_cmmu_flush_remote_tlb(cpu, kernel, vaddr, size);
      break;
d542 2
a543 2
   }
   CMMU_UNLOCK;
d552 3
a554 3
   int cpu;
   cpu = cpu_number();
   cmmu_flush_remote_tlb(cpu, kernel, vaddr, size);
d572 2
a573 3
#if defined(MVME187) || defined(MVME188)
	case CPU_187:
	case CPU_188:
d577 2
a578 2
#ifdef MVME197
	case CPU_197:
d606 11
a616 12
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_cmmu_flush_remote_cache(cpu, physaddr, size);
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      m197_cmmu_flush_remote_cache(cpu, physaddr, size);
      break;
d618 2
a619 2
   }
   CMMU_UNLOCK;
d628 2
a629 2
   int cpu = cpu_number();
   cmmu_flush_remote_cache(cpu, physaddr, size);
d638 11
a648 12
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_cmmu_flush_remote_inst_cache(cpu, physaddr, size);
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      m197_cmmu_flush_remote_inst_cache(cpu, physaddr, size);
      break;
d650 2
a651 2
   }
   CMMU_UNLOCK;
d660 3
a662 3
   int cpu;
   cpu = cpu_number();
   cmmu_flush_remote_inst_cache(cpu, physaddr, size);
d668 11
a678 12
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_cmmu_flush_remote_data_cache(cpu, physaddr, size);
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      m197_cmmu_flush_remote_data_cache(cpu, physaddr, size);
      break;
d680 2
a681 2
   }
   CMMU_UNLOCK;
d690 3
a692 3
   int cpu;
   cpu = cpu_number();
   cmmu_flush_remote_data_cache(cpu, physaddr, size);
d702 11
a712 12
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_cmmu_sync_cache(physaddr, size);
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      m197_cmmu_sync_cache(physaddr, size);
      break;
d714 2
a715 2
   }
   CMMU_UNLOCK;
d721 11
a731 12
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_cmmu_sync_inval_cache(physaddr, size);
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      m197_cmmu_sync_inval_cache(physaddr, size);
      break;
d733 2
a734 2
   }
   CMMU_UNLOCK;
d740 11
a750 12
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_cmmu_inval_cache(physaddr, size);
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      m197_cmmu_inval_cache(physaddr, size);
      break;
d752 2
a753 2
   }
   CMMU_UNLOCK;
d760 11
a770 12
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_dma_cachectl(va, size, op);
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      m197_dma_cachectl(va, size, op);
      break;
d772 2
a773 2
   }
   CMMU_UNLOCK;
d789 13
a801 14
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_cmmu_show_translation(address, supervisor_flag, 
                                 verbose_flag, cmmu_num);
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      m197_cmmu_show_translation(address, supervisor_flag, 
                                 verbose_flag, cmmu_num);
      break;
d803 2
a804 2
   }
   CMMU_UNLOCK;
d811 10
a820 11
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_cmmu_cache_state(addr, supervisor_flag);
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      m197_cmmu_cache_state(addr, supervisor_flag);
      break;
d822 1
a822 1
   }
d828 10
a837 11
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_show_cmmu_info(addr);
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      m197_show_cmmu_info(addr);
      break;
d839 1
a839 1
   }
@


1.15
log
@Support for MVME197 completed.  Fix SPL defs.
@
text
@d63 3
d69 6
d83 4
d94 172
a265 1
struct cmmu_p *cmmu;
d267 24
a290 1
void md_cmmu_flush_tlb __P((unsigned kernel, vm_offset_t vaddr, int size));
d292 3
a294 1
/* This is here so that process.S doesn't have to decide the CPU type */
d296 1
a296 1
md_cmmu_flush_tlb(unsigned kernel, vm_offset_t vaddr, int size)
d298 17
a314 1
	cmmu_flush_tlb(kernel, vaddr, size);
d317 556
@


1.14
log
@Adapt to include files changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.c,v 1.13 2001/09/28 20:46:42 miod Exp $	*/
a62 3

#include <machine/mmu.h>
#include <machine/board.h>
a65 6
#if defined(MVME187) || defined(MVME188)
#include <machine/m882xx.h>
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
#include <machine/m88110.h>
#endif /* MVME197 */
a73 4

#define CMMU_LOCK   simple_lock(&cmmu_cpu_lock)
#define CMMU_UNLOCK simple_unlock(&cmmu_cpu_lock)

d81 1
a81 96
#ifdef CMMU_DEBUG
void
show_apr(unsigned value)
{
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_show_apr(value);
      break;
#endif
#ifdef MVME197
   case CPU_197:
      m197_show_apr(value);
      break;
#endif 
   }
}

void
show_sctr(unsigned value)
{
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_show_sctr(value);
      break;
#endif
#ifdef MVME197
   case CPU_197:
      m197_show_sctr(value);
      break;
#endif 
   }
}
#endif /* CMMU_DEBUG */

void 
setup_board_config(void)
{
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_setup_board_config();
      break;
#endif
#ifdef MVME197
   case CPU_197:
      m197_setup_board_config();
      break;
#endif 
   }
}

void 
setup_cmmu_config(void)
{
	int cpu;

	for (cpu = 0; cpu < MAX_CPUS; cpu++)
		cpu_sets[cpu] = 0;

	switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
	case CPU_187:
	case CPU_188:
		m18x_setup_cmmu_config();
		break;
#endif
#ifdef MVME197
	case CPU_197:
		m197_setup_cmmu_config();
		break;
#endif 
	}
}

void 
cmmu_dump_config(void)
{
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_cmmu_dump_config();
      break;
#endif
#ifdef MVME197
   case CPU_197:
      m197_cmmu_dump_config();
      break;
#endif 
   }
}
d83 1
a83 26
#ifdef DDB
/*
 * Used by DDB for cache probe functions
 */
unsigned 
cmmu_get_by_mode(int cpu, int mode)
{
   unsigned retval;
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      retval = m18x_cmmu_get_by_mode(cpu, mode);
      break;
#endif
#ifdef MVME197
   case CPU_197:
      retval = m197_cmmu_get_by_mode(cpu, mode);
      break;
#endif 
   }
   CMMU_UNLOCK;
   return retval;
}
#endif
d85 1
a85 5
/*
 * Should only be called after the calling cpus knows its cpu
 * number and master/slave status . Should be called first
 * by the master, before the slaves are started.
*/
d87 1
a87 347
cpu_configuration_print(int master)
{
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_cpu_configuration_print(master);
      break;
#endif
#ifdef MVME197
   case CPU_197:
      m197_cpu_configuration_print(master);
      break;
#endif 
   }
   CMMU_UNLOCK;
}

/*
 * CMMU initialization routine
 */
void 
cmmu_init(void)
{
	/* init the lock */
	simple_lock_init(&cmmu_cpu_lock);

	switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
	case CPU_187:
	case CPU_188:
		m18x_cmmu_init();
		break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
	case CPU_197:
		m197_cmmu_init();
		break;
#endif /* MVME197 */
	}
}

/*
 * Just before poweroff or reset....
 */
void
cmmu_shutdown_now(void)
{
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_cmmu_shutdown_now();
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      m197_cmmu_shutdown_now();
      break;
#endif /* MVME197 */
   }
   CMMU_UNLOCK;
}

#define PARITY_ENABLE

/*
 * enable parity
 */
void 
cmmu_parity_enable(void)
{
#ifdef PARITY_ENABLE
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_cmmu_parity_enable();
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      m197_cmmu_parity_enable();
      break;
#endif /* MVME197 */
   }
   CMMU_UNLOCK;
#endif  /* PARITY_ENABLE */
}

/*
 * Find out the CPU number from accessing CMMU
 * Better be at splhigh, or even better, with interrupts
 * disabled.
 */
unsigned 
cmmu_cpu_number(void)
{
   unsigned retval;
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      retval = m18x_cmmu_cpu_number();
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      retval = m197_cmmu_cpu_number();
      break;
#endif /* MVME197 */
   }
   CMMU_UNLOCK;
   return retval;
}

/**
 **	Functions that actually modify CMMU registers.
 **/

void
cmmu_remote_set(unsigned cpu, unsigned r, unsigned data, unsigned x)
{
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_cmmu_remote_set(cpu, r, data, x);
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      m197_cmmu_remote_set(cpu, r, data, x);
      break;
#endif /* MVME197 */
   }
   CMMU_UNLOCK;
}

/*
 * cmmu_cpu_lock should be held when called if read
 * the CMMU_SCR or CMMU_SAR.
 */
unsigned
cmmu_remote_get(unsigned cpu, unsigned r, unsigned data)
{
   unsigned retval;
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      retval = m18x_cmmu_remote_get(cpu, r, data);
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      retval = m197_cmmu_remote_get(cpu, r, data);
      break;
#endif /* MVME197 */
   }
   CMMU_UNLOCK;
   return retval;
}

/* Needs no locking - read only registers */
unsigned
cmmu_get_idr(unsigned data)
{
   unsigned retval;
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      retval = m18x_cmmu_get_idr(data);
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      retval = m197_cmmu_get_idr(data);
      break;
#endif /* MVME197 */
   }
   CMMU_UNLOCK;
   return retval;
}

void
cmmu_set_sapr(unsigned ap)
{
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_cmmu_set_sapr(ap);
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      m197_cmmu_set_sapr(ap);
      break;
#endif /* MVME197 */
   }
   CMMU_UNLOCK;
}

void
cmmu_remote_set_sapr(unsigned cpu, unsigned ap)
{
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_cmmu_remote_set_sapr(cpu, ap);
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      m197_cmmu_remote_set_sapr(cpu, ap);
      break;
#endif /* MVME197 */
   }
   CMMU_UNLOCK;
}

void
cmmu_set_uapr(unsigned ap)
{
	register int s = splhigh();
	CMMU_LOCK;
	switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
	case CPU_187:
	case CPU_188:
		m18x_cmmu_set_uapr(ap);
		break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
	case CPU_197:
		m197_cmmu_set_uapr(ap);
		break;
#endif /* MVME197 */
	}
	CMMU_UNLOCK;
	splx(s);
}

/*
 * Set batc entry number entry_no to value in 
 * the data or instruction cache depending on data.
 *
 * Except for the cmmu_init, this function, cmmu_set_pair_batc_entry,
 * and cmmu_pmap_activate are the only functions which may set the
 * batc values.
 */
void
cmmu_set_batc_entry(
                   unsigned cpu,
                   unsigned entry_no,
                   unsigned data,   /* 1 = data, 0 = instruction */
                   unsigned value)  /* the value to stuff into the batc */
{
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_cmmu_set_batc_entry(cpu, entry_no, data, value);
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      m197_cmmu_set_batc_entry(cpu, entry_no, data, value);
      break;
#endif /* MVME197 */
   }
   CMMU_UNLOCK;
}

/*
 * Set batc entry number entry_no to value in 
 * the data and instruction cache for the named CPU.
 */
void
cmmu_set_pair_batc_entry(
                        unsigned cpu,
                        unsigned entry_no,
                        unsigned value)  /* the value to stuff into the batc */
{
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_cmmu_set_pair_batc_entry(cpu, entry_no, value);
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      m197_cmmu_set_pair_batc_entry(cpu, entry_no, value);
      break;
#endif /* MVME197 */
   }
   CMMU_UNLOCK;
}

/**
 **	Functions that invalidate TLB entries.
 **/

/*
 *	flush any tlb
 *	Some functionality mimiced in cmmu_pmap_activate.
 */
void
cmmu_flush_remote_tlb(unsigned cpu, unsigned kernel, vm_offset_t vaddr, int size)
{
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_cmmu_flush_remote_tlb(cpu, kernel, vaddr, size);
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      m197_cmmu_flush_remote_tlb(cpu, kernel, vaddr, size);
      break;
#endif /* MVME197 */
   }
   CMMU_UNLOCK;
}

/*
 *	flush my personal tlb
 */
void
cmmu_flush_tlb(unsigned kernel, vm_offset_t vaddr, int size)
d89 1
a89 3
   int cpu;
   cpu = cpu_number();
   cmmu_flush_remote_tlb(cpu, kernel, vaddr, size);
a91 296
/*
 * New fast stuff for pmap_activate.
 * Does what a few calls used to do.
 * Only called from pmap.c's _pmap_activate().
 */
void
cmmu_pmap_activate(
		  unsigned cpu,
		  unsigned uapr,
		  batc_template_t i_batc[BATC_MAX],
		  batc_template_t d_batc[BATC_MAX])
{
	register int s = splhigh();
	CMMU_LOCK;
	switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
	case CPU_187:
	case CPU_188:
		m18x_cmmu_pmap_activate(cpu, uapr, i_batc, d_batc);
		break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
	case CPU_197:
		m197_cmmu_pmap_activate(cpu, uapr, i_batc, d_batc);
		break;
#endif /* MVME197 */
	}
	CMMU_UNLOCK;
	splx(s);
}

/**
 **	Functions that invalidate caches.
 **
 ** Cache invalidates require physical addresses.  Care must be exercised when
 ** using segment invalidates.  This implies that the starting physical address
 ** plus the segment length should be invalidated.  A typical mistake is to
 ** extract the first physical page of a segment from a virtual address, and
 ** then expecting to invalidate when the pages are not physically contiguous.
 **
 ** We don't push Instruction Caches prior to invalidate because they are not
 ** snooped and never modified (I guess it doesn't matter then which form
 ** of the command we use then).
 **/
/*
 *	flush both Instruction and Data caches
 */
void
cmmu_flush_remote_cache(int cpu, vm_offset_t physaddr, int size)
{
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_cmmu_flush_remote_cache(cpu, physaddr, size);
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      m197_cmmu_flush_remote_cache(cpu, physaddr, size);
      break;
#endif /* MVME197 */
   }
   CMMU_UNLOCK;
}

/*
 *	flush both Instruction and Data caches
 */
void
cmmu_flush_cache(vm_offset_t physaddr, int size)
{
   int cpu = cpu_number();
   cmmu_flush_remote_cache(cpu, physaddr, size);
}

/*
 *	flush Instruction caches
 */
void
cmmu_flush_remote_inst_cache(int cpu, vm_offset_t physaddr, int size)
{
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_cmmu_flush_remote_inst_cache(cpu, physaddr, size);
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      m197_cmmu_flush_remote_inst_cache(cpu, physaddr, size);
      break;
#endif /* MVME197 */
   }
   CMMU_UNLOCK;
}

/*
 *	flush Instruction caches
 */
void
cmmu_flush_inst_cache(vm_offset_t physaddr, int size)
{
   int cpu;
   cpu = cpu_number();
   cmmu_flush_remote_inst_cache(cpu, physaddr, size);
}

void
cmmu_flush_remote_data_cache(int cpu, vm_offset_t physaddr, int size)
{ 
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_cmmu_flush_remote_data_cache(cpu, physaddr, size);
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      m197_cmmu_flush_remote_data_cache(cpu, physaddr, size);
      break;
#endif /* MVME197 */
   }
   CMMU_UNLOCK;
}

/*
 * flush data cache
 */ 
void
cmmu_flush_data_cache(vm_offset_t physaddr, int size)
{ 
   int cpu;
   cpu = cpu_number();
   cmmu_flush_remote_data_cache(cpu, physaddr, size);
}

#if 0
/*
 * sync dcache (and icache too)
 */
void
cmmu_sync_cache(vm_offset_t physaddr, int size)
{
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_cmmu_sync_cache(physaddr, size);
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      m197_cmmu_sync_cache(physaddr, size);
      break;
#endif /* MVME197 */
   }
   CMMU_UNLOCK;
}

void
cmmu_sync_inval_cache(vm_offset_t physaddr, int size)
{
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_cmmu_sync_inval_cache(physaddr, size);
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      m197_cmmu_sync_inval_cache(physaddr, size);
      break;
#endif /* MVME197 */
   }
   CMMU_UNLOCK;
}

void
cmmu_inval_cache(vm_offset_t physaddr, int size)
{
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_cmmu_inval_cache(physaddr, size);
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      m197_cmmu_inval_cache(physaddr, size);
      break;
#endif /* MVME197 */
   }
   CMMU_UNLOCK;
}
#endif

void
dma_cachectl(vm_offset_t va, int size, int op)
{
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_dma_cachectl(va, size, op);
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      m197_dma_cachectl(va, size, op);
      break;
#endif /* MVME197 */
   }
   CMMU_UNLOCK;
}

#ifdef DDB

/*
 * Show (for debugging) how the given CMMU translates the given ADDRESS.
 * If cmmu == -1, the data cmmu for the current cpu is used.
 */
void
cmmu_show_translation(
                     unsigned address,
                     unsigned supervisor_flag,
                     unsigned verbose_flag,
                     int cmmu_num)
{
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_cmmu_show_translation(address, supervisor_flag, 
                                 verbose_flag, cmmu_num);
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      m197_cmmu_show_translation(address, supervisor_flag, 
                                 verbose_flag, cmmu_num);
      break;
#endif /* MVME197 */
   }
   CMMU_UNLOCK;
}


void
cmmu_cache_state(unsigned addr, unsigned supervisor_flag)
{
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_cmmu_cache_state(addr, supervisor_flag);
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      m197_cmmu_cache_state(addr, supervisor_flag);
      break;
#endif /* MVME197 */
   }
}

void
show_cmmu_info(unsigned addr)
{
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_show_cmmu_info(addr);
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      m197_show_cmmu_info(addr);
      break;
#endif /* MVME197 */
   }
}
#endif /* end if DDB */
@


1.13
log
@Typos of the day.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.c,v 1.12 2001/08/26 14:31:12 miod Exp $	*/
d64 1
@


1.12
log
@Add prototypes, fix compilation warnings, random style fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.c,v 1.11 2001/05/21 22:19:50 miod Exp $	*/
d344 1
a344 1
 **	Funcitons that actually modify CMMU registers.
d722 1
a722 1
static void
d742 1
a742 1
static void
d762 1
a762 1
static void
@


1.11
log
@Correctly position the #if's wrt the locking macros...
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.c,v 1.10 2001/03/18 01:52:30 miod Exp $	*/
d63 1
d65 1
a67 1
#include <machine/cmmu.h>
a89 1
int      vme188_config;
@


1.10
log
@Initialize all the cpu_sets array, not just the first max_cpus entries.

This fixes the "ff1(users) == 21" panic when re-pmap_enter()ing the
kernel_map, if option DIAGNOSTIC is set, and your kernel is configured
for more cpus that you have on your board.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.c,v 1.9 2001/03/09 05:44:41 smurph Exp $	*/
d312 1
a313 1
   CMMU_UNLOCK;
@


1.9
log
@kernel will compile with -Werror.  Added intr.h
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.c,v 1.8 2001/03/08 00:03:30 miod Exp $	*/
d152 6
a157 1
   switch (cputyp) {
d159 4
a162 4
   case CPU_187:
   case CPU_188:
      m18x_setup_cmmu_config();
      break;
d165 3
a167 3
   case CPU_197:
      m197_setup_cmmu_config();
      break;
d169 1
a169 1
   }
d297 1
a297 1
#ifdef	PARITY_ENABLE
a346 3
#if !DDB
static
#endif
a370 3
#if !DDB
static
#endif
d803 1
a803 1
#if DDB
@


1.8
log
@Some warning hunting.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.c,v 1.7 2001/02/01 03:38:19 smurph Exp $	*/
d93 1
d129 1
@


1.7
log
@Major changes to get MVME188 working.  More header and code cleanups.  The
kernel is tested on MVME188A/2P256 and MVME188A/1P64.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.c,v 1.6 2000/03/03 00:54:53 todd Exp $	*/
a162 1
   return;
a180 1
   return;
a232 1
   return;
a256 1
	return;
a279 1
   return;
a306 1
   return;
a360 1
   return;
a432 1
   return;
a452 1
   return;
d458 1
a458 1
	register s = splhigh();
a474 1
	return;
a506 1
   return;
a533 1
   return;
a561 1
   return;
d587 1
a587 1
	register s = splhigh();
a603 1
	return;
a639 1
   return;
a672 1
   return;
a703 1
   return;
d717 1
a738 1
   return;
a758 1
   return;
a778 1
   return;
d780 1
a799 1
   return;
a831 1
   return;
a850 1
   return;
a868 1
   return;
@


1.6
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.c,v 1.5 1999/09/27 19:13:21 smurph Exp $	*/
d244 2
a245 2
   /* init the lock */
   simple_lock_init(&cmmu_cpu_lock);
d247 1
a247 1
   switch (cputyp) {
d249 4
a252 4
   case CPU_187:
   case CPU_188:
      m18x_cmmu_init();
      break;
d255 3
a257 3
   case CPU_197:
      m197_cmmu_init();
      break;
d259 2
a260 2
   }
   return;
d467 18
a484 16
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_cmmu_set_uapr(ap);
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      m197_cmmu_set_uapr(ap);
      break;
#endif /* MVME197 */
   }
   CMMU_UNLOCK;
   return;
d595 23
a617 21
                  unsigned cpu,
                  unsigned uapr,
                  batc_template_t i_batc[BATC_MAX],
                  batc_template_t d_batc[BATC_MAX])
{
   CMMU_LOCK;
   switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
   case CPU_187:
   case CPU_188:
      m18x_cmmu_pmap_activate(cpu, uapr, i_batc, d_batc);
      break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
   case CPU_197:
      m197_cmmu_pmap_activate(cpu, uapr, i_batc, d_batc);
      break;
#endif /* MVME197 */
   }
   CMMU_UNLOCK;
   return;
@


1.5
log
@Added to support MVME188 and MVME197
@
text
@d1 1
a31 1
 *	$Id: cmmu.c,v 1.4 1998/12/15 05:11:01 smurph Exp $
@


1.5.4.1
log
@Sync with -current
@
text
@a0 1
/*	$OpenBSD$	*/
d31 1
@


1.5.4.2
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.c,v 1.10 2001/03/18 01:52:30 miod Exp $	*/
a92 1
#ifdef CMMU_DEBUG
a127 1
#endif /* CMMU_DEBUG */
d150 1
a150 6
	int cpu;

	for (cpu = 0; cpu < MAX_CPUS; cpu++)
		cpu_sets[cpu] = 0;

	switch (cputyp) {
d152 4
a155 4
	case CPU_187:
	case CPU_188:
		m18x_setup_cmmu_config();
		break;
d158 3
a160 3
	case CPU_197:
		m197_setup_cmmu_config();
		break;
d162 2
a163 1
	}
d182 1
d235 1
d244 2
a245 2
	/* init the lock */
	simple_lock_init(&cmmu_cpu_lock);
d247 1
a247 1
	switch (cputyp) {
d249 4
a252 4
	case CPU_187:
	case CPU_188:
		m18x_cmmu_init();
		break;
d255 3
a257 3
	case CPU_197:
		m197_cmmu_init();
		break;
d259 2
a260 1
	}
d284 1
d295 1
a295 1
#ifdef PARITY_ENABLE
d312 1
d346 3
d367 1
d374 3
d440 1
d461 1
d467 16
a482 17
	register int s = splhigh();
	CMMU_LOCK;
	switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
	case CPU_187:
	case CPU_188:
		m18x_cmmu_set_uapr(ap);
		break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
	case CPU_197:
		m197_cmmu_set_uapr(ap);
		break;
#endif /* MVME197 */
	}
	CMMU_UNLOCK;
	splx(s);
d515 1
d543 1
d572 1
d593 21
a613 22
		  unsigned cpu,
		  unsigned uapr,
		  batc_template_t i_batc[BATC_MAX],
		  batc_template_t d_batc[BATC_MAX])
{
	register int s = splhigh();
	CMMU_LOCK;
	switch (cputyp) {
#if defined(MVME187) || defined(MVME188)
	case CPU_187:
	case CPU_188:
		m18x_cmmu_pmap_activate(cpu, uapr, i_batc, d_batc);
		break;
#endif /* defined(MVME187) || defined(MVME188) */
#ifdef MVME197
	case CPU_197:
		m197_cmmu_pmap_activate(cpu, uapr, i_batc, d_batc);
		break;
#endif /* MVME197 */
	}
	CMMU_UNLOCK;
	splx(s);
d650 1
d684 1
d716 1
a729 1
#if 0
d751 1
d772 1
d793 1
a794 1
#endif
d814 1
d817 1
a817 1
#ifdef DDB
d847 1
d867 1
d886 1
@


1.5.4.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.c,v 1.5.4.2 2001/04/18 16:11:29 niklas Exp $	*/
d312 1
a313 1
#endif  /* PARITY_ENABLE */
@


1.5.4.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.c,v 1.5.4.3 2001/07/04 10:20:07 niklas Exp $	*/
a62 1

a63 1
#include <machine/cmmu.h>
d66 1
d89 1
d344 1
a344 1
 **	Functions that actually modify CMMU registers.
d722 1
a722 1
void
d742 1
a742 1
void
d762 1
a762 1
void
@


1.5.4.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.c,v 1.5.4.4 2001/10/31 03:01:19 nate Exp $	*/
a63 1
#include <machine/mmu.h>
@


1.5.4.6
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d63 3
d69 6
d83 4
d94 96
a189 1
struct cmmu_p *cmmu;
d191 26
a216 1
void md_cmmu_flush_tlb __P((unsigned kernel, vm_offset_t vaddr, int size));
d218 5
a222 1
/* This is here so that process.S doesn't have to decide the CPU type */
d224 347
a570 1
md_cmmu_flush_tlb(unsigned kernel, vm_offset_t vaddr, int size)
d572 3
a574 1
	cmmu_flush_tlb(kernel, vaddr, size);
d577 296
@


1.5.4.7
log
@Merge in -current from about a week ago
@
text
@d83 1
a83 1
void md_cmmu_flush_tlb(unsigned kernel, vm_offset_t vaddr, int size);
@


1.5.4.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d64 1
d67 3
a69 3
/*
 * This lock protects the cmmu SAR and SCR's; other ports
 * can be accessed without locking it.
d74 1
a74 1

d76 1
d79 1
d82 10
@


1.5.4.9
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.c,v 1.5.4.8 2004/02/19 10:49:07 niklas Exp $	*/
@


1.4
log
@Commit for the first working mvme88k port.
@
text
@d31 1
a31 1
 *	$Id: cmmu.c,v 1.3 1997/03/03 20:21:30 rahnds Exp $
d62 1
d65 3
d69 10
a78 65

/* On some versions of 88200, page size flushes don't work. I am using
 * sledge hammer approach till I find for sure which ones are bad XXX nivas */
#define BROKEN_MMU_MASK	
#define CMMU_DEBUG 1

#if defined(MVME187)
#undef SNOOP_ENABLE
#else
#define	SNOOP_ENABLE
#endif	/* defined(MVME187)

#undef	SHADOW_BATC		/* don't use BATCs for now XXX nivas */

struct cmmu_regs
{
    /* base + $000 */ volatile unsigned idr;
    /* base + $004 */ volatile unsigned scr;
    /* base + $008 */ volatile unsigned ssr;
    /* base + $00C */ volatile unsigned sar;
    /*             */ unsigned padding1[0x3D];
    /* base + $104 */ volatile unsigned sctr;
    /* base + $108 */ volatile unsigned pfSTATUSr;
    /* base + $10C */ volatile unsigned pfADDRr;
    /*             */ unsigned padding2[0x3C];
    /* base + $200 */ volatile unsigned sapr;
    /* base + $204 */ volatile unsigned uapr;
    /*             */ unsigned padding3[0x7E];
    /* base + $400 */ volatile unsigned bwp[8];
    /*             */ unsigned padding4[0xF8];
    /* base + $800 */ volatile unsigned cdp[4];
    /*             */ unsigned padding5[0x0C];
    /* base + $840 */ volatile unsigned ctp[4];
    /*             */ unsigned padding6[0x0C];
    /* base + $880 */ volatile unsigned cssp;

    /* The rest for the 88204 */
    #define cssp0 cssp
    /*             */ unsigned padding7[0x03];
    /* base + $890 */ volatile unsigned cssp1;
    /*             */ unsigned padding8[0x03];
    /* base + $8A0 */ volatile unsigned cssp2;
    /*             */ unsigned padding9[0x03];
    /* base + $8B0 */ volatile unsigned cssp3;
};

static struct cmmu {
	struct cmmu_regs *cmmu_regs; 	/* CMMU "base" area */
	unsigned char  cmmu_cpu;	/* cpu number it is attached to */
	unsigned char  which;	 	/* either INST_CMMU || DATA_CMMU */
	unsigned char  cmmu_alive;
#define CMMU_DEAD	0		/* This cmmu not there */
#define CMMU_AVAILABLE	1		/* It's there, but which cpu's? */
#define CMMU_MARRIED	2		/* Know which cpu it belongs to. */
#if SHADOW_BATC
	unsigned batc[8];
#endif
	unsigned char  pad;
} cmmu[MAX_CMMUS] = {
    {(void *)CMMU_I, 0, 0, 0, 0},
    {(void *)CMMU_D, 0, 1, 0, 0},
};

/*
 * We rely upon and use INST_CMMU == 0 and DATA_CMMU == 1
d80 1
a80 6
#if INST_CMMU != 0 || DATA_CMMU != 1
	error("ack gag barf!");
#endif
struct cpu_cmmu {
    struct cmmu *pair[2];
} cpu_cmmu[1];
d82 2
a83 6
/*
 * CMMU(cpu,data) Is the cmmu struct for the named cpu's indicated cmmu.
 * REGS(cpu,data) is the actual register structure.
 */
#define CMMU(cpu, data) cpu_cmmu[(cpu)].pair[(data)?DATA_CMMU:INST_CMMU]
#define REGS(cpu, data) (*CMMU(cpu, data)->cmmu_regs)
d86 6
a92 1
#ifdef CMMU_DEBUG
d96 13
a108 10
	union apr_template apr_template;
	apr_template.bits = value;

	printf("table @@ 0x%x000", apr_template.field.st_base);
	if (apr_template.field.wt) printf(", writethrough");
	if (apr_template.field.g)  printf(", global");
	if (apr_template.field.ci) printf(", cache inhibit");
	if (apr_template.field.te) printf(", valid");
	else                       printf(", not valid");
	printf("\n");
d114 122
a235 15
    union {
	unsigned bits;
	struct {
	   unsigned :16,
		  pe: 1,
		  se: 1,
		  pr: 1,
		    :13;
	} fields;
    } sctr; 
    sctr.bits = value;
    printf("%spe, %sse %spr]\n",
	sctr.fields.pe ? "" : "!",
	sctr.fields.se ? "" : "!",
	sctr.fields.pr ? "" : "!");
a236 1
#endif
d241 1
a241 1
void
d244 17
a260 165
	unsigned tmp, cmmu_num;
	union cpupid id;
	int cpu;

	cpu_cmmu[0].pair[INST_CMMU] = cpu_cmmu[0].pair[DATA_CMMU] = 0;

	for (cmmu_num = 0; cmmu_num < MAX_CMMUS; cmmu_num++) {
		if (!badwordaddr((vm_offset_t)cmmu[cmmu_num].cmmu_regs)) {
			id.cpupid = cmmu[cmmu_num].cmmu_regs->idr;
			if (id.m88200.type != M88200 && id.m88200.type !=M88204)
				continue;
			cmmu[cmmu_num].cmmu_alive = CMMU_AVAILABLE;

			cpu_cmmu[cmmu[cmmu_num].cmmu_cpu].pair[cmmu[cmmu_num].which] =
				&cmmu[cmmu_num];

			/*
			 * Reset cache data....
			 * as per M88200 Manual (2nd Ed.) section 3.11.
			 */
			for (tmp = 0; tmp < 255; tmp++) {
				cmmu[cmmu_num].cmmu_regs->sar = tmp << 4;
				cmmu[cmmu_num].cmmu_regs->cssp = 0x3f0ff000;
			}

			/* 88204 has additional cache to clear */
			if(id.m88200.type == M88204)
			{
				for (tmp = 0; tmp < 255; tmp++) {
					cmmu[cmmu_num].cmmu_regs->sar =
								tmp<<4;
					cmmu[cmmu_num].cmmu_regs->cssp1 =
								0x3f0ff000;
				}
				for (tmp = 0; tmp < 255; tmp++) {
					cmmu[cmmu_num].cmmu_regs->sar =
								tmp<<4;
					cmmu[cmmu_num].cmmu_regs->cssp2 =
								0x3f0ff000;
				}
				for (tmp = 0; tmp < 255; tmp++) {
					cmmu[cmmu_num].cmmu_regs->sar =
								tmp<<4;
					cmmu[cmmu_num].cmmu_regs->cssp3 =									 0x3f0ff000;
				}
			}

			/*
			 * Set the SCTR, SAPR, and UAPR to some known state
			 * (I don't trust the reset to do it).
			 */
			tmp =
				! CMMU_SCTR_PE |   /* not parity enable */
				! CMMU_SCTR_SE |   /* not snoop enable */
				! CMMU_SCTR_PR ;   /*not priority arbitration */
	    		cmmu[cmmu_num].cmmu_regs->sctr = tmp;

			tmp =
				(0x00000 << 12) |/*segment table base address */
				AREA_D_WT |	/* write through */
				AREA_D_G  |	/* global */
				AREA_D_CI |	/* cache inhibit */
				! AREA_D_TE ;	/* not translation enable */

			cmmu[cmmu_num].cmmu_regs->sapr =
			cmmu[cmmu_num].cmmu_regs->uapr = tmp;
		
#if SHADOW_BATC
			cmmu[cmmu_num].batc[0] =
			cmmu[cmmu_num].batc[1] =
			cmmu[cmmu_num].batc[2] =
			cmmu[cmmu_num].batc[3] =
			cmmu[cmmu_num].batc[4] =
			cmmu[cmmu_num].batc[5] =
			cmmu[cmmu_num].batc[6] =
			cmmu[cmmu_num].batc[7] = 0;
#endif
			cmmu[cmmu_num].cmmu_regs->bwp[0] = 
			cmmu[cmmu_num].cmmu_regs->bwp[1] = 
			cmmu[cmmu_num].cmmu_regs->bwp[2] = 
			cmmu[cmmu_num].cmmu_regs->bwp[3] = 
			cmmu[cmmu_num].cmmu_regs->bwp[4] = 
			cmmu[cmmu_num].cmmu_regs->bwp[5] = 
			cmmu[cmmu_num].cmmu_regs->bwp[6] = 
			cmmu[cmmu_num].cmmu_regs->bwp[7] = 0;

			cmmu[cmmu_num].cmmu_regs->scr =CMMU_FLUSH_CACHE_INV_ALL;
			cmmu[cmmu_num].cmmu_regs->scr = CMMU_FLUSH_SUPER_ALL;
			cmmu[cmmu_num].cmmu_regs->scr = CMMU_FLUSH_USER_ALL;
		}
	}

	/*
	 * Now that we know which CMMUs are there, let's report on which
	 * CPU/CMMU sets seem complete (hopefully all)
	 */
	for (cpu = 0; cpu < MAX_CPUS; cpu++)
	{
		if (cpu_cmmu[cpu].pair[INST_CMMU] && cpu_cmmu[cpu].pair[DATA_CMMU])
		{
			if(id.m88200.type == M88204)
				printf("CPU%d is attached with MC88204 CMMU\n",
									cpu);
			else
				printf("CPU%d is attached with MC88200 CMMU\n",
									cpu);
		}
		else if (cpu_cmmu[cpu].pair[INST_CMMU])
		{
			printf("CPU%d data CMMU is not working.\n", cpu);
			panic("cmmu-data");
		}
		else if (cpu_cmmu[cpu].pair[DATA_CMMU])
		{
			printf("CPU%d instruction CMMU is not working.\n", cpu);
			panic("cmmu");
		}
	}

#if SNOOP_ENABLE
	/*
	 * Enable snooping... MVME187 doesn't support snooping. The
	 * processor will, but the processor is not going to see the cache
	 * accesses going on the 040 local bus. XXX nivas
	 */
	for (cpu = 0; cpu < MAX_CPUS; cpu++)
	{
		/*
		 * Enable snooping.
		 * We enable it for instruction cmmus as well so that we can
		 * have breakpoints, etc, and modify code.
		 */
		tmp =
		    ! CMMU_SCTR_PE |   /* not parity enable */
		      CMMU_SCTR_SE |   /* snoop enable */
		    ! CMMU_SCTR_PR ;   /* not priority arbitration */

		REGS(cpu, DATA_CMMU).sctr = tmp;
		REGS(cpu, INST_CMMU).sctr = tmp;
		REGS(cpu, DATA_CMMU).scr  = CMMU_FLUSH_SUPER_ALL;
		REGS(cpu, INST_CMMU).scr  = CMMU_FLUSH_SUPER_ALL;
	}

#endif /* SNOOP_ENABLE */

	/*
	 * Turn on some cache.
	 */
	for (cpu = 0; cpu < MAX_CPUS; cpu++)
	{
		/*
		 * Enable some caching for the instruction stream.
		 * Can't cache data yet 'cause device addresses can never
		 * be cached, and we don't have those no-caching zones
		 * set up yet....
		 */
		tmp =
		    (0x00000 << 12) |	/* segment table base address */
			  AREA_D_WT |	/* write through */
			  AREA_D_G  |	/* global */
			  AREA_D_CI |	/* cache inhibit */
			! AREA_D_TE ;	/* not translation enable */
		REGS(cpu, INST_CMMU).sapr = tmp;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_SUPER_ALL;
	}
d269 71
a339 27
	unsigned tmp;
	unsigned cmmu_num;

	/*
	 * Now set some state as we like...
	 */
	for (cmmu_num = 0; cmmu_num < MAX_CMMUS; cmmu_num++)
	{
		tmp =
		! CMMU_SCTR_PE |   /* parity enable */
#if SNOOP_ENABLE
		! CMMU_SCTR_SE |   /* snoop enable */
#endif /* SNOOP_ENABLE */
		! CMMU_SCTR_PR ;   /* priority arbitration */

		cmmu[cmmu_num].cmmu_regs->sctr = tmp;

		tmp = 
			(0x00000 << 12) |  /* segment table base address */
			! AREA_D_WT |      /* write through */
			! AREA_D_G  |      /* global */
			  AREA_D_CI |      /* cache inhibit */
			! AREA_D_TE ;      /* translation disable */
		
		cmmu[cmmu_num].cmmu_regs->sapr = tmp;
		cmmu[cmmu_num].cmmu_regs->uapr = tmp;
	}
d352 16
a367 1
	*(volatile unsigned *)(r + (char*)&REGS(cpu,data)) = x;
d373 1
a373 1
**/
d380 17
a396 1
	return (*(volatile unsigned *)(r + (char*)&REGS(cpu,data)));
d403 17
a419 1
	return REGS(0,data).idr;
d425 16
a440 7
	int cpu = 0;

	if (cache_policy & CACHE_INH)
		ap |= AREA_D_CI;

	REGS(cpu, INST_CMMU).sapr = ap;
	REGS(cpu, DATA_CMMU).sapr = ap;
d446 16
a461 5
	if (cache_policy & CACHE_INH)
		ap |= AREA_D_CI;

	REGS(cpu, INST_CMMU).sapr = ap;
	REGS(cpu, DATA_CMMU).sapr = ap;
d467 16
a482 5
	int cpu = 0;

	/* this functionality also mimiced in cmmu_pmap_activate() */
	REGS(cpu, INST_CMMU).uapr = ap;
	REGS(cpu, DATA_CMMU).uapr = ap;
d495 21
a515 14
     unsigned cpu,
     unsigned entry_no,
     unsigned data,   /* 1 = data, 0 = instruction */
     unsigned value)  /* the value to stuff into the batc */
{

	REGS(cpu,data).bwp[entry_no] = value;
#if SHADOW_BATC
	CMMU(cpu,data)->batc[entry_no] = value;
#endif
#if 0 /* was for debugging piece (peace?) of mind */
	REGS(cpu,data).scr = CMMU_FLUSH_SUPER_ALL;
	REGS(cpu,data).scr = CMMU_FLUSH_USER_ALL;
#endif
d524 20
a543 20
     unsigned cpu,
     unsigned entry_no,
     unsigned value)  /* the value to stuff into the batc */
{

	REGS(cpu,DATA_CMMU).bwp[entry_no] = value;
#if SHADOW_BATC
	CMMU(cpu,DATA_CMMU)->batc[entry_no] = value;
#endif
	REGS(cpu,INST_CMMU).bwp[entry_no] = value;
#if SHADOW_BATC
	CMMU(cpu,INST_CMMU)->batc[entry_no] = value;
#endif

#if 0  /* was for debugging piece (peace?) of mind */
	REGS(cpu,INST_CMMU).scr = CMMU_FLUSH_SUPER_ALL;
	REGS(cpu,INST_CMMU).scr = CMMU_FLUSH_USER_ALL;
	REGS(cpu,DATA_CMMU).scr = CMMU_FLUSH_SUPER_ALL;
	REGS(cpu,DATA_CMMU).scr = CMMU_FLUSH_USER_ALL;
#endif
d557 16
a572 17
	register s = splhigh();
    
	if ((unsigned)size > M88K_PGBYTES) 
	{
		REGS(cpu, INST_CMMU).scr =
		REGS(cpu, DATA_CMMU).scr =
			kernel ? CMMU_FLUSH_SUPER_ALL : CMMU_FLUSH_USER_ALL;
	}
	else /* a page or smaller */
	{
		REGS(cpu, INST_CMMU).sar = (unsigned)vaddr;
		REGS(cpu, DATA_CMMU).sar = (unsigned)vaddr;
		REGS(cpu, INST_CMMU).scr =
		REGS(cpu, DATA_CMMU).scr =
			kernel ? CMMU_FLUSH_SUPER_PAGE : CMMU_FLUSH_USER_PAGE;
	}
	splx(s);
d581 3
a583 1
	cmmu_flush_remote_tlb(0, kernel, vaddr, size);
d593 21
a613 27
    unsigned cpu,
    unsigned uapr,
    batc_template_t i_batc[BATC_MAX],
    batc_template_t d_batc[BATC_MAX])
{
	int entry_no;

	/* the following is from cmmu_set_uapr */
	REGS(cpu, INST_CMMU).uapr = uapr;
	REGS(cpu, DATA_CMMU).uapr = uapr;

	for (entry_no = 0; entry_no < BATC_MAX; entry_no++) {
		REGS(cpu,INST_CMMU).bwp[entry_no] = i_batc[entry_no].bits;
		REGS(cpu,DATA_CMMU).bwp[entry_no] = d_batc[entry_no].bits;
#if SHADOW_BATC
		CMMU(cpu,INST_CMMU)->batc[entry_no] = i_batc[entry_no].bits;
		CMMU(cpu,DATA_CMMU)->batc[entry_no] = d_batc[entry_no].bits;
#endif
	}

	/*
	 * Flush the user TLB.
	 * IF THE KERNEL WILL EVER CARE ABOUT THE BATC ENTRIES,
	 * THE SUPERVISOR TLBs SHOULB EE FLUSHED AS WELL.
	 */
	REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_USER_ALL;
	REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_USER_ALL;
d635 16
a650 32
	register s = splhigh();

#if !defined(BROKEN_MMU_MASK)

	if (size < 0 || size > NBSG ) {
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
	}
	else if (size <= 16) {
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_LINE;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_LINE;
	}
	else if (size <= NBPG) {
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_PAGE;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_PAGE;
	}
	else {
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_SEGMENT;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_SEGMENT;
	}

#else
	REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
	REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
#endif /* !BROKEN_MMU_MASK */
	splx(s);
d659 2
a660 1
	cmmu_flush_remote_cache(0, physaddr, size);
d669 16
a684 23
	register s = splhigh();

#if !defined(BROKEN_MMU_MASK)
	if (size < 0 || size > NBSG ) {
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
	}
	else if (size <= 16) {
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_LINE;
	}
	else if (size <= NBPG) {
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_PAGE;
	}
	else {
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_SEGMENT;
	}
#else
	REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
#endif /* !BROKEN_MMU_MASK */

	splx(s);
d693 3
a695 1
	cmmu_flush_remote_inst_cache(0, physaddr, size);
d701 16
a716 23
	register s = splhigh();

#if !defined(BROKEN_MMU_MASK)
	if (size < 0 || size > NBSG ) {
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
	}
	else if (size <= 16) {
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_LINE;
	}
	else if (size <= NBPG) {
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_PAGE;
	}
	else {
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_SEGMENT;
	}
#else
	REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
#endif /* !BROKEN_MMU_MASK */
    
    splx(s);
d725 3
a727 1
	cmmu_flush_remote_data_cache(0, physaddr, size);
d736 16
a751 30
	register s = splhigh();

#if !defined(BROKEN_MMU_MASK)
	if (size < 0 || size > NBSG ) {
		REGS(0, INST_CMMU).scr = CMMU_FLUSH_CACHE_CB_ALL;
		REGS(0, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CB_ALL;
	}
	else if (size <= 16) {
		REGS(0, INST_CMMU).sar = (unsigned)physaddr;
		REGS(0, INST_CMMU).scr = CMMU_FLUSH_CACHE_CB_LINE;
		REGS(0, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(0, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CB_LINE;
	}
	else if (size <= NBPG) {
		REGS(0, INST_CMMU).sar = (unsigned)physaddr;
		REGS(0, INST_CMMU).scr = CMMU_FLUSH_CACHE_CB_PAGE;
		REGS(0, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(0, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CB_PAGE;
	}
	else {
		REGS(0, INST_CMMU).sar = (unsigned)physaddr;
		REGS(0, INST_CMMU).scr = CMMU_FLUSH_CACHE_CB_SEGMENT;
		REGS(0, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(0, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CB_SEGMENT;
	}
#else
	REGS(0, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CB_ALL;
	REGS(0, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CB_ALL;
#endif /* !BROKEN_MMU_MASK */
	splx(s);
d757 16
a772 31
	register s = splhigh();

#if !defined(BROKEN_MMU_MASK)
	if (size < 0 || size > NBSG ) {
		REGS(0, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
		REGS(0, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
	}
	else if (size <= 16) {
		REGS(0, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(0, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_LINE;
		REGS(0, INST_CMMU).sar = (unsigned)physaddr;
		REGS(0, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_LINE;
	}
	else if (size <= NBPG) {
		REGS(0, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(0, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_PAGE;
		REGS(0, INST_CMMU).sar = (unsigned)physaddr;
		REGS(0, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_PAGE;
	}
	else {
		REGS(0, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(0, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_SEGMENT;
		REGS(0, INST_CMMU).sar = (unsigned)physaddr;
		REGS(0, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_SEGMENT;
	}

#else
	REGS(0, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
	REGS(0, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
#endif /* !BROKEN_MMU_MASK */
	splx(s);
d778 16
a793 31
	register s = splhigh();

#if !defined(BROKEN_MMU_MASK)
	if (size < 0 || size > NBSG ) {
		REGS(0, DATA_CMMU).scr = CMMU_FLUSH_CACHE_INV_ALL;
		REGS(0, INST_CMMU).scr = CMMU_FLUSH_CACHE_INV_ALL;
	}
	else if (size <= 16) {
		REGS(0, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(0, DATA_CMMU).scr = CMMU_FLUSH_CACHE_INV_LINE;
		REGS(0, INST_CMMU).sar = (unsigned)physaddr;
		REGS(0, INST_CMMU).scr = CMMU_FLUSH_CACHE_INV_LINE;
	}
	else if (size <= NBPG) {
		REGS(0, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(0, DATA_CMMU).scr = CMMU_FLUSH_CACHE_INV_PAGE;
		REGS(0, INST_CMMU).sar = (unsigned)physaddr;
		REGS(0, INST_CMMU).scr = CMMU_FLUSH_CACHE_INV_PAGE;
	}
	else {
		REGS(0, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(0, DATA_CMMU).scr = CMMU_FLUSH_CACHE_INV_SEGMENT;
		REGS(0, INST_CMMU).sar = (unsigned)physaddr;
		REGS(0, INST_CMMU).scr = CMMU_FLUSH_CACHE_INV_SEGMENT;
	}
#else
	REGS(0, DATA_CMMU).scr = CMMU_FLUSH_CACHE_INV_ALL;
	REGS(0, INST_CMMU).scr = CMMU_FLUSH_CACHE_INV_ALL;
#endif /* !BROKEN_MMU_MASK */

	splx(s);
d799 16
a814 29
	int count;
	
#if !defined(BROKEN_MMU_MASK)
	while (size) {

		count = NBPG - ((int)va & PGOFSET);

		if (size < count)
			count = size;

		if (op == DMA_CACHE_SYNC)
			cmmu_sync_cache(kvtop(va), count);
		else if (op == DMA_CACHE_SYNC_INVAL)
			cmmu_sync_inval_cache(kvtop(va), count);
		else
			cmmu_inval_cache(kvtop(va), count);

		va = (vm_offset_t)((int)va + count);
		size -= count;
	}
#else

	if (op == DMA_CACHE_SYNC)
		cmmu_sync_cache(kvtop(va), size);
	else if (op == DMA_CACHE_SYNC_INVAL)
		cmmu_sync_inval_cache(kvtop(va), size);
	else
		cmmu_inval_cache(kvtop(va), size);
#endif /* !BROKEN_MMU_MASK */
a817 71
union ssr {
    unsigned bits;
    struct {
	unsigned  :16,
		ce:1,
		be:1,
		  :4,
		wt:1,
		sp:1,
		 g:1,
		ci:1,
		  :1,
		 m:1,
		 u:1,
		wp:1,
		bh:1,
		 v:1;
    } field;
};

union cssp {
    unsigned bits;
    struct {
	unsigned   : 2,
		  l: 6,
		 d3: 1,
		 d2: 1,
		 d1: 1,
		 d0: 1,
		vv3: 2,
		vv2: 2,
		vv1: 2,
		vv0: 2,
		   :12;
    } field;
};

union batcu {
    unsigned bits;
    struct {              /* block address translation register */
	unsigned int
	    lba:13,            /* logical block address */
	    pba:13,            /* physical block address */
	    s:1,               /* supervisor */
	    wt:4,              /* write through */
	    g:1,               /* global */
	    ci:1,              /* cache inhibit */
	    wp:1,              /* write protect */
	    v:1;               /* valid */
    } field;
};

#define VV_EX_UNMOD		0
#define VV_EX_MOD		1
#define VV_SHARED_UNMOD		2
#define VV_INVALID		3

#define D(UNION, LINE) \
	((LINE) == 3 ? (UNION).field.d3 : \
	 ((LINE) == 2 ? (UNION).field.d2 : \
	  ((LINE) == 1 ? (UNION).field.d1 : \
	   ((LINE) == 0 ? (UNION).field.d0 : ~0))))
#define VV(UNION, LINE) \
	((LINE) == 3 ? (UNION).field.vv3 : \
	 ((LINE) == 2 ? (UNION).field.vv2 : \
	  ((LINE) == 1 ? (UNION).field.vv1 : \
	   ((LINE) == 0 ? (UNION).field.vv0 : ~0))))
	

#undef VEQR_ADDR
#define  VEQR_ADDR 0
d825 23
a847 335
    unsigned address,
    unsigned supervisor_flag,
    unsigned verbose_flag,
    int cmmu_num)
{
    /*
     * A virtual address is split into three fields. Two are used as
     * indicies into tables (segment and page), and one is an offset into
     * a page of memory.
     */
    union {
	unsigned bits;
	struct {
	    unsigned segment_table_index:10,
		     page_table_index:10,
		     page_offset:12;
	} field;
    } virtual_address;
    unsigned value;

    if (verbose_flag)
        db_printf("-------------------------------------------\n");


    /****** ACCESS PROPER CMMU or THREAD ***********/
#if 0 /* no thread */
    if (thread != 0)
    {
	/* the following tidbit from _pmap_activate in m88k/pmap.c */
	register apr_template_t apr_data;
	supervisor_flag = 0;	/* thread implies user */

	if (thread->task == 0) {
	    db_printf("[thread %x has empty task pointer]\n", thread);
	    return;
	} else if (thread->task->map == 0) {
	    db_printf("[thread/task %x/%x has empty map pointer]\n",
		thread, thread->task);
	    return;
	} else if (thread->task->map->pmap == 0) {
	    db_printf("[thread/task/map %x/%x/%x has empty pmap pointer]\n",
		thread, thread->task, thread->task->map);
	    return;
	}
	if (thread->task->map->pmap->lock.lock_data) {
	    db_printf("[Warning: thread %x's task %x's map %x's "
	      "pmap %x is locked]\n", thread, thread->task,
		thread->task->map, thread->task->map->pmap);
	}
        apr_data.bits = 0;
        apr_data.field.st_base = M88K_BTOP(thread->task->map->pmap->sdt_paddr);
        apr_data.field.wt = 0;
        apr_data.field.g  = 1;
        apr_data.field.ci = 0;
        apr_data.field.te = 1;
	value = apr_data.bits;
        if (verbose_flag) {
	    db_printf("[thread %x task %x map %x pmap %x UAPR is %x]\n",
		thread, thread->task, thread->task->map,
		thread->task->map->pmap, value);
	}
    }
    else
#endif /* 0 */
    {
	if (cmmu_num == -1)
	{
	    if (cpu_cmmu[0].pair[DATA_CMMU] == 0)
	    {
		db_printf("ack! can't figure my own data cmmu number.\n");
		return;
	    }
	    cmmu_num = cpu_cmmu[0].pair[DATA_CMMU] - cmmu;
	    if (verbose_flag)
		db_printf("The data cmmu for cpu#%d is cmmu#%d.\n",
		   0, cmmu_num);
	}
	else if (cmmu_num < 0 || cmmu_num >= MAX_CMMUS)
	{
	    db_printf("invalid cpu number [%d]... must be in range [0..%d]\n",
		    cmmu_num, MAX_CMMUS - 1);
	    return;
	}

	if (cmmu[cmmu_num].cmmu_alive == 0)
	{
	    db_printf("warning: cmmu %d is not alive.\n", cmmu_num);
	    #if 0
	    return;
	    #endif
	}

	if (!verbose_flag)
	{
	    if (!(cmmu[cmmu_num].cmmu_regs->sctr & CMMU_SCTR_SE))
		db_printf("WARNING: snooping not enabled for CMMU#%d.\n",
		    cmmu_num);
	}
	else
	{
	    int i;
	    for (i=0; i<MAX_CMMUS; i++)
		if ((i == cmmu_num || cmmu[i].cmmu_alive) &&
		    (verbose_flag>1 || !(cmmu[i].cmmu_regs->sctr&CMMU_SCTR_SE)))
		{
		    db_printf("CMMU#%d (cpu %d %s) snooping %s\n", i,
			cmmu[i].cmmu_cpu, cmmu[i].which ? "data" : "inst",
			(cmmu[i].cmmu_regs->sctr & CMMU_SCTR_SE) ? "on":"OFF");
		}
	}

	if (supervisor_flag)
	    value = cmmu[cmmu_num].cmmu_regs->sapr;
	else
	    value = cmmu[cmmu_num].cmmu_regs->uapr;

    }

    /******* LOOK AT THE BATC ** (if not a thread) **************/
#if 0
#if SHADOW_BATC
    if (thread == 0)
    {
	int i;
	union batcu batc;
	for (i = 0; i < 8; i++) {
	    batc.bits = cmmu[cmmu_num].batc[i];
	    if (batc.field.v == 0) {
		if (verbose_flag>1)
		    db_printf("cmmu #%d batc[%d] invalid.\n", cmmu_num, i);
	    } else {
		db_printf("cmmu#%d batc[%d] v%08x p%08x", cmmu_num, i,
			batc.field.lba << 18, batc.field.pba);
		if (batc.field.s)  db_printf(", supervisor");
		if (batc.field.wt) db_printf(", wt.th");
		if (batc.field.g)  db_printf(", global");
		if (batc.field.ci) db_printf(", cache inhibit");
		if (batc.field.wp) db_printf(", write protect");
	    }
	}
    }
#endif
#endif /* 0 */

    /******* SEE WHAT A PROBE SAYS (if not a thread) ***********/ 
#if 0
    if (thread == 0)
#endif /* 0 */
    {
 	union ssr ssr;
	struct cmmu_regs *cmmu_regs = cmmu[cmmu_num].cmmu_regs;
	cmmu_regs->sar = address;
	cmmu_regs->scr = supervisor_flag ? CMMU_PROBE_SUPER : CMMU_PROBE_USER;
	ssr.bits = cmmu_regs->ssr;
        if (verbose_flag > 1)
	    db_printf("probe of 0x%08x returns ssr=0x%08x\n",
		address, ssr.bits);
	if (ssr.field.v)
	    db_printf("PROBE of 0x%08x returns phys=0x%x",
		address, cmmu_regs->sar);
	else
	    db_printf("PROBE fault at 0x%x", cmmu_regs->pfADDRr);
	if (ssr.field.ce) db_printf(", copyback err");
	if (ssr.field.be) db_printf(", bus err");
	if (ssr.field.wt) db_printf(", writethrough");
	if (ssr.field.sp) db_printf(", sup prot");
	if (ssr.field.g)  db_printf(", global");
	if (ssr.field.ci) db_printf(", cache inhibit");
	if (ssr.field.m)  db_printf(", modified");
	if (ssr.field.u)  db_printf(", used");
	if (ssr.field.wp) db_printf(", write prot");
	if (ssr.field.bh) db_printf(", BATC");
	db_printf(".\n");
    }

    /******* INTERPRET AREA DESCRIPTOR *********/
    {
	union apr_template apr_template;
	apr_template.bits = value;
        if (verbose_flag > 1) {
		db_printf("CMMU#%d", cmmu_num);
#if 0
	    if (thread == 0)
		db_printf("CMMU#%d", cmmu_num);
	    else
		db_printf("THREAD %x", thread);
#endif /* 0 */
	    db_printf(" %cAPR is 0x%08x\n",
		supervisor_flag ? 'S' : 'U', apr_template.bits);
	}
	db_printf("CMMU#%d", cmmu_num);
#if 0
	if (thread == 0)
	    db_printf("CMMU#%d", cmmu_num);
	else
	    db_printf("THREAD %x", thread);
#endif /* 0 /
	db_printf(" %cAPR: SegTbl: 0x%x000p",
	    supervisor_flag ? 'S' : 'U', apr_template.field.st_base);
	if (apr_template.field.wt) db_printf(", WTHRU");
	else                       db_printf(", !wthru");
	if (apr_template.field.g)  db_printf(", GLOBAL");
	else                       db_printf(", !global");
	if (apr_template.field.ci) db_printf(", $INHIBIT");
	else                       db_printf(", $ok");
	if (apr_template.field.te) db_printf(", VALID");
	else                       db_printf(", !valid");
	db_printf(".\n");

	/* if not valid, done now */
	if (apr_template.field.te == 0) {
	    db_printf("<would report an error, valid bit not set>\n");
	    return;
	}

	value = apr_template.field.st_base << 12; /* now point to seg page */
    }

    /* translate value from physical to virtual */
    if (verbose_flag)
	db_printf("[%x physical is %x virtual]\n", value, value + VEQR_ADDR);
    value += VEQR_ADDR;

    virtual_address.bits = address;
 
    /****** ACCESS SEGMENT TABLE AND INTERPRET SEGMENT DESCRIPTOR  *******/
    {
	union sdt_entry_template std_template;
	if (verbose_flag)
	    db_printf("will follow to entry %d of page at 0x%x...\n",
		virtual_address.field.segment_table_index, value);
	value |= virtual_address.field.segment_table_index *
		 sizeof(struct sdt_entry);

	if (badwordaddr(value)) {
	    db_printf("ERROR: unable to access page at 0x%08x.\n", value);
	    return;
	}

	std_template.bits = *(unsigned *)value;
        if (verbose_flag > 1)
	    db_printf("SEG DESC @@0x%x is 0x%08x\n", value, std_template.bits);
	db_printf("SEG DESC @@0x%x: PgTbl: 0x%x000",
	    value, std_template.sdt_desc.table_addr);
	if (std_template.sdt_desc.wt)       db_printf(", WTHRU");
	else                                db_printf(", !wthru");
	if (std_template.sdt_desc.sup)      db_printf(", S-PROT");
	else                                db_printf(", UserOk");
	if (std_template.sdt_desc.g)        db_printf(", GLOBAL");
	else                                db_printf(", !global");
	if (std_template.sdt_desc.no_cache) db_printf(", $INHIBIT");
	else                                db_printf(", $ok");
	if (std_template.sdt_desc.prot)     db_printf(", W-PROT");
	else                                db_printf(", WriteOk");
	if (std_template.sdt_desc.dtype)    db_printf(", VALID");
	else                                db_printf(", !valid");
	db_printf(".\n");

	/* if not valid, done now */
	if (std_template.sdt_desc.dtype == 0) {
	    db_printf("<would report an error, STD entry not valid>\n");
	    return;
	}

	value = std_template.sdt_desc.table_addr << 12;
    }

    /* translate value from physical to virtual */
    if (verbose_flag)
	db_printf("[%x physical is %x virtual]\n", value, value + VEQR_ADDR);
    value += VEQR_ADDR;

    /******* PAGE TABLE *********/
    {
	union pte_template pte_template;
	if (verbose_flag)
	    db_printf("will follow to entry %d of page at 0x%x...\n",
		virtual_address.field.page_table_index, value);
	value |= virtual_address.field.page_table_index *
		sizeof(struct pt_entry);

	if (badwordaddr(value)) {
	    db_printf("error: unable to access page at 0x%08x.\n", value);
	    return;
	}

	pte_template.bits = *(unsigned *)value;
	if (verbose_flag > 1)
	    db_printf("PAGE DESC @@0x%x is 0x%08x.\n", value, pte_template.bits);
	db_printf("PAGE DESC @@0x%x: page @@%x000",
		value, pte_template.pte.pfn);
	if (pte_template.pte.wired)    db_printf(", WIRE");
	else                           db_printf(", !wire");
	if (pte_template.pte.wt)       db_printf(", WTHRU");
	else                           db_printf(", !wthru");
	if (pte_template.pte.sup)      db_printf(", S-PROT");
	else                           db_printf(", UserOk");
	if (pte_template.pte.g)        db_printf(", GLOBAL");
	else                           db_printf(", !global");
	if (pte_template.pte.ci)       db_printf(", $INHIBIT");
	else                           db_printf(", $ok");
	if (pte_template.pte.modified) db_printf(", MOD");
	else                           db_printf(", !mod");
	if (pte_template.pte.pg_used)  db_printf(", USED");
	else                           db_printf(", !used");
	if (pte_template.pte.prot)     db_printf(", W-PROT");
	else                           db_printf(", WriteOk");
	if (pte_template.pte.dtype)    db_printf(", VALID");
	else                           db_printf(", !valid");
	db_printf(".\n");

	/* if not valid, done now */
	if (pte_template.pte.dtype == 0) {
	    db_printf("<would report an error, PTE entry not valid>\n");
	    return;
	}
	
	value = pte_template.pte.pfn << 12;
	if (verbose_flag)
	    db_printf("will follow to byte %d of page at 0x%x...\n",
		virtual_address.field.page_offset, value);
	value |= virtual_address.field.page_offset;

	if (badwordaddr(value)) {
	    db_printf("error: unable to access page at 0x%08x.\n", value);
	    return;
	}
    }

    /* translate value from physical to virtual */
    if (verbose_flag)
	db_printf("[%x physical is %x virtual]\n", value, value + VEQR_ADDR);
    value += VEQR_ADDR;

    db_printf("WORD at 0x%x is 0x%08x.\n", value, *(unsigned *)value);
d854 14
a867 52
    static char *vv_name[4] =
	{"exclu-unmod", "exclu-mod", "shared-unmod", "invalid"};
    int cmmu_num;
    for (cmmu_num = 0; cmmu_num < MAX_CMMUS; cmmu_num++)
    {
	union ssr ssr;
	union cssp cssp;
	struct cmmu_regs *R;
	unsigned tag, line;
	if (!cmmu[cmmu_num].cmmu_alive)
	    continue;
	R = cmmu[cmmu_num].cmmu_regs;
	db_printf("cmmu #%d %s cmmu for cpu %d.\n", cmmu_num,
	    cmmu[cmmu_num].which ? "data" : "inst", 
	    cmmu[cmmu_num].cmmu_cpu);
	R->sar = addr;
	R->scr = supervisor_flag ? CMMU_PROBE_SUPER : CMMU_PROBE_USER;

	ssr.bits = R->ssr;
	if (!ssr.field.v) {
	    db_printf("PROBE of 0x%08x faults.\n",addr);
	    continue;
	}
	db_printf("PROBE of 0x%08x returns phys=0x%x", addr, R->sar);

	tag = R->sar & ~0xfff;
	cssp.bits = R->cssp;

	/* check to see if any of the tags for the set match the address */
	for (line = 0; line < 4; line++)
	{
	    if (VV(cssp, line) == VV_INVALID)
	    {
		db_printf("line %d invalid.\n", line);
		continue; /* line is invalid */
	    }
	    if (D(cssp, line))
	    {
		db_printf("line %d disabled.\n", line);
		continue; /* line is disabled */
	    }

	    if ((R->ctp[line] & ~0xfff) != tag)
	    {
		db_printf("line %d address tag is %x.\n", line,
			(R->ctp[line] & ~0xfff));
		continue;
	    }
	    db_printf("found in line %d as %08x (%s).\n",
		line, R->cdp[line], vv_name[VV(cssp, line)]);
        }
    }
d873 14
a886 10
    int cmmu_num;
    cmmu_cache_state(addr, 1);

    for (cmmu_num = 0; cmmu_num < MAX_CMMUS; cmmu_num++)
	if (cmmu[cmmu_num].cmmu_alive) {
	    db_printf("cmmu #%d %s cmmu for cpu %d: ", cmmu_num,
		cmmu[cmmu_num].which ? "data" : "inst", 
		cmmu[cmmu_num].cmmu_cpu);
	    cmmu_show_translation(addr, 1, 0, cmmu_num);
	}
@


1.3
log
@Cleanup after import. This also seems to bring up the current version.
@
text
@d2 1
d31 1
a31 1
 *	$Id: cmmu.c,v 1.1.1.1 1997/03/03 19:32:22 rahnds Exp $
d69 2
d154 1
a154 1
	_printf("table @@ 0x%x000", apr_template.field.st_base);
d160 1
a160 1
	printf("]\n");
@


1.2
log
@This is a remove to get rid of the old mvme88k port which was incomplete
to replace it with a working version. The kernel compiles and works
at least.  The new version will be imported shortly.
@
text
@d2 31
a57 3
/*
 * HISTORY
 */
d59 5
d65 8
a72 2
#define SNOOP_ENABLE
#define SHADOW_BATC 0
d74 1
a74 3
#ifndef NBPG
#define NBPG 4096
#endif /* NBPG */
a105 6






a107 10

#include <sys/param.h>
#include <sys/types.h>
#include <machine/board.h>
#include <machine/cpus.h>
#if 0
#include <vm/pmap.h>
#endif


d109 8
a116 8
    struct cmmu_regs *cmmu_regs; /* CMMU "base" area */
    unsigned char  cmmu_cpu;	 /* cpu number it is attached to */
    unsigned char  which;	 /* either INST_CMMU || DATA_CMMU */
    unsigned char  cmmu_alive;
	#define CMMU_DEAD	0	/* This cmmu not there */
	#define CMMU_AVAILABLE	1	/* It's there, but which cpu's? */
	#define CMMU_MARRIED	2	/* Know which cpu it belongs to. */
    #if SHADOW_BATC
d118 2
a119 2
    #endif
    unsigned char  pad;
a124 1
#include <machine/m882xx.h>
d142 1
a142 1
unsigned cache_policy = 0;
d145 2
a146 1
void show_apr(unsigned value)
d148 10
a157 9
    union apr_template apr_template;
    apr_template.bits = value;
    _printf("table @@ 0x%x000", apr_template.field.st_base);
    if (apr_template.field.wt) printf(", writethrough");
    if (apr_template.field.g)  printf(", global");
    if (apr_template.field.ci) printf(", cache inhibit");
    if (apr_template.field.te) printf(", valid");
    else                       printf(", not valid");
    printf("]\n");
d160 2
a161 1
void show_sctr(unsigned value)
d184 2
a185 1
void cmmu_init(void)
d187 91
a277 12
    unsigned tmp, cmmu_num;
    union cpupid id;
    int cpu;

    cpu_cmmu[0].pair[INST_CMMU] = cpu_cmmu[0].pair[DATA_CMMU] = 0;

    for (cmmu_num = 0; cmmu_num < MAX_CMMUS; cmmu_num++) {
	if (!wprobe((vm_offset_t)cmmu[cmmu_num].cmmu_regs, -1)) {
	    id.cpupid = cmmu[cmmu_num].cmmu_regs->idr;
	    if (id.m88200.type != M88200 && id.m88200.type != M88204)
		continue;
	    cmmu[cmmu_num].cmmu_alive = CMMU_AVAILABLE;
d279 14
a292 18
	    cpu_cmmu[cmmu[cmmu_num].cmmu_cpu].pair[cmmu[cmmu_num].which] =
		&cmmu[cmmu_num];

	    /*
	     * Reset cache data....
	     * as per M88200 Manual (2nd Ed.) section 3.11.
	     */
	    for (tmp = 0; tmp < 255; tmp++) {
		cmmu[cmmu_num].cmmu_regs->sar = tmp << 4;
		cmmu[cmmu_num].cmmu_regs->cssp = 0x3f0ff000;
	    }

	    /* 88204 has additional cache to clear */
	    if(id.m88200.type == M88204)
	    {
		for (tmp = 0; tmp < 255; tmp++) {
		    cmmu[cmmu_num].cmmu_regs->sar = tmp<<4;
		    cmmu[cmmu_num].cmmu_regs->cssp1 = 0x3f0ff000;
d294 4
a297 3
		for (tmp = 0; tmp < 255; tmp++) {
		    cmmu[cmmu_num].cmmu_regs->sar = tmp<<4;
		    cmmu[cmmu_num].cmmu_regs->cssp2 = 0x3f0ff000;
d299 4
a302 3
		for (tmp = 0; tmp < 255; tmp++) {
		    cmmu[cmmu_num].cmmu_regs->sar = tmp<<4;
		    cmmu[cmmu_num].cmmu_regs->cssp3 = 0x3f0ff000;
a303 43
	    }

	    /*
	     * Set the SCTR, SAPR, and UAPR to some known state
	     * (I don't trust the reset to do it).
	     */
	    tmp =
		! CMMU_SCTR_PE |   /* not parity enable */
		! CMMU_SCTR_SE |   /* not snoop enable */
		! CMMU_SCTR_PR ;   /* not priority arbitration */
	    cmmu[cmmu_num].cmmu_regs->sctr = tmp;

	    tmp =
		(0x00000 << 12) |	/* segment table base address */
		      AREA_D_WT |	/* write through */
	              AREA_D_G  |	/* global */
	              AREA_D_CI |	/* cache inhibit */
	            ! AREA_D_TE ;	/* not translation enable */
	    cmmu[cmmu_num].cmmu_regs->sapr =
	    cmmu[cmmu_num].cmmu_regs->uapr = tmp;

	
#if SHADOW_BATC
	    cmmu[cmmu_num].batc[0] =
	    cmmu[cmmu_num].batc[1] =
	    cmmu[cmmu_num].batc[2] =
	    cmmu[cmmu_num].batc[3] =
	    cmmu[cmmu_num].batc[4] =
	    cmmu[cmmu_num].batc[5] =
	    cmmu[cmmu_num].batc[6] =
	    cmmu[cmmu_num].batc[7] = 0;
#endif
	    cmmu[cmmu_num].cmmu_regs->bwp[0] = 
	    cmmu[cmmu_num].cmmu_regs->bwp[1] = 
	    cmmu[cmmu_num].cmmu_regs->bwp[2] = 
	    cmmu[cmmu_num].cmmu_regs->bwp[3] = 
	    cmmu[cmmu_num].cmmu_regs->bwp[4] = 
	    cmmu[cmmu_num].cmmu_regs->bwp[5] = 
	    cmmu[cmmu_num].cmmu_regs->bwp[6] = 
	    cmmu[cmmu_num].cmmu_regs->bwp[7] = 0;
	    cmmu[cmmu_num].cmmu_regs->scr = CMMU_FLUSH_CACHE_INV_ALL;
	    cmmu[cmmu_num].cmmu_regs->scr = CMMU_FLUSH_SUPER_ALL;
	    cmmu[cmmu_num].cmmu_regs->scr = CMMU_FLUSH_USER_ALL;
a304 1
    }
d306 7
a312 25
    /*
     * Now that we know which CMMUs are there, let's report on which
     * CPU/CMMU sets seem complete (hopefully all)
     */
    for (cpu = 0; cpu < MAX_CPUS; cpu++)
    {
	if (cpu_cmmu[cpu].pair[INST_CMMU] && cpu_cmmu[cpu].pair[DATA_CMMU])
	{
	    if(id.m88200.type == M88204)
		printf("CPU%d is attached with MC88204 CMMU\n", cpu);
	    else
		printf("CPU%d is attached with MC88200 CMMU\n", cpu);

	}
	else if (cpu_cmmu[cpu].pair[INST_CMMU])
	{
		printf("CPU%d data CMMU is not working.\n", cpu);
		panic("cmmu-data");
	}
	else if (cpu_cmmu[cpu].pair[DATA_CMMU])
	{
	    printf("CPU%d instruction CMMU is not working.\n", cpu);
	    panic("cmmu");
	}
	else
d314 14
a328 1
    }
d330 1
a330 19
    /*
     * Enable snooping...
     */
    for (cpu = 0; cpu < MAX_CPUS; cpu++)
    {
	/*
	 * Enable snooping.
	 * We enable it for instruction cmmus as well so that we can have
	 * breakpoints, etc, and modify code.
	 */
	tmp =
	    ! CMMU_SCTR_PE |   /* not parity enable */
	      CMMU_SCTR_SE |   /* snoop enable */
	    ! CMMU_SCTR_PR ;   /* not priority arbitration */
	REGS(cpu, DATA_CMMU).sctr = tmp;
	REGS(cpu, INST_CMMU).sctr = tmp;
	REGS(cpu, DATA_CMMU).scr  = CMMU_FLUSH_SUPER_ALL;
	REGS(cpu, INST_CMMU).scr  = CMMU_FLUSH_SUPER_ALL;
    }
a331 5
    /*
     * Turn on some cache.
     */
    for (cpu = 0; cpu < MAX_CPUS; cpu++)
    {
d333 1
a333 4
	 * Enable some caching for the instruction stream.
	 * Can't cache data yet 'cause device addresses can never
	 * be cached, and we don't have those no-caching zones
	 * set up yet....
d335 17
a351 9
	tmp =
	    (0x00000 << 12) |	/* segment table base address */
		  AREA_D_WT |	/* write through */
		  AREA_D_G  |	/* global */
		  AREA_D_CI |	/* cache inhibit */
		! AREA_D_TE ;	/* not translation enable */
	REGS(cpu, INST_CMMU).sapr = tmp;
	REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_SUPER_ALL;
    }
d357 2
a358 1
void cmmu_shutdown_now(void)
d360 2
a361 3
#if 0 /* was trying to fix a reboot problem... doesn't seem to help */
    unsigned tmp;
    unsigned cmmu_num;
d363 4
a366 55
    /*
     * Now set some state as we like...
     */
    for (cmmu_num = 0; cmmu_num < MAX_CMMUS; cmmu_num++)
    {
	tmp =
	    ! CMMU_SCTR_PE |   /* parity enable */
	    ! CMMU_SCTR_SE |   /* snoop enable */
	    ! CMMU_SCTR_PR ;   /* priority arbitration */
	cmmu[cmmu_num].cmmu_regs->sctr = tmp;


	tmp = 
	    (0x00000 << 12) |  /* segment table base address */
	    ! AREA_D_WT |      /* write through */
	    ! AREA_D_G  |      /* global */
	      AREA_D_CI |      /* cache inhibit */
	    ! AREA_D_TE ;      /* translation enable */
	cmmu[cmmu_num].cmmu_regs->sapr = tmp;
	cmmu[cmmu_num].cmmu_regs->uapr = tmp;
    }
#endif
}


/*
 * enable parity
 */
void cmmu_parity_enable(void)
{
#ifdef	PARITY_ENABLE
    register int cmmu_num;

    for (cmmu_num = 0; cmmu_num < MAX_CMMUS; cmmu_num++) {
	if (cmmu[cmmu_num].cmmu_alive != CMMU_DEAD) {
	    cmmu[cmmu_num].cmmu_regs->sctr |= CMMU_SCTR_PE;
	}
    }
#endif	PARITY_ENABLE
}

/*
 * Find out the CPU number from accessing CMMU
 * Better be at splhigh, or even better, with interrupts
 * disabled.
 */
unsigned cmmu_cpu_number(void)
{
    register unsigned cmmu_no;
    int i;

    for (i=0; i < 10; i++)
    {
	/* clear CMMU p-bus status registers */
	for (cmmu_no = 0; cmmu_no < MAX_CMMUS; cmmu_no++) 
d368 18
a385 3
	    if (cmmu[cmmu_no].cmmu_alive == CMMU_AVAILABLE &&
	        cmmu[cmmu_no].which == DATA_CMMU) 
		    cmmu[cmmu_no].cmmu_regs->pfSTATUSr = 0;
a386 24

	/* access faulting address */
	badwordaddr((void *)ILLADDRESS);

	/* check which CMMU reporting the fault  */
	for (cmmu_no = 0; cmmu_no < MAX_CMMUS; cmmu_no++) 
	{
	    if (cmmu[cmmu_no].cmmu_alive == CMMU_AVAILABLE &&
	        cmmu[cmmu_no].which == DATA_CMMU &&
		cmmu[cmmu_no].cmmu_regs->pfSTATUSr & 0x70000)
	    {
		if (cmmu[cmmu_no].cmmu_regs->pfSTATUSr & 0x70000)
		{
		    cmmu[cmmu_no].cmmu_regs->pfSTATUSr = 0; /* to be clean */
		    cmmu[cmmu_no].cmmu_alive = CMMU_MARRIED;
		    return cmmu[cmmu_no].cmmu_cpu;
		}
	    }
	}
    }
printf("at cmmu.c line %d.\n", __LINE__);

    panic("could not determine my cpu number");
    return 0; /* to make compiler happy */
d396 2
a397 1
void cmmu_remote_set(unsigned cpu, unsigned r, unsigned data, unsigned x)
d399 1
a399 1
    *(volatile unsigned *)(r + (char*)&REGS(cpu,data)) = x;
d409 2
a410 1
unsigned cmmu_remote_get(unsigned cpu, unsigned r, unsigned data)
d412 1
a412 1
    return *(volatile unsigned *)(r + (char*)&REGS(cpu,data));
d416 2
a417 1
unsigned cmmu_get_idr(unsigned data)
d419 1
a419 1
    return REGS(0,data).idr;
d422 2
a423 1
void cmmu_set_sapr(unsigned ap)
d425 4
a428 3
    int cpu = 0;
    if (cache_policy & CACHE_INH)
	ap |= AREA_D_CI;
d430 2
a431 2
    REGS(cpu, INST_CMMU).sapr = ap;
    REGS(cpu, DATA_CMMU).sapr = ap;
d434 2
a435 1
void cmmu_remote_set_sapr(unsigned cpu, unsigned ap)
d437 5
a441 4
    if (cache_policy & CACHE_INH)
	ap |= AREA_D_CI;
    REGS(cpu, INST_CMMU).sapr = ap;
    REGS(cpu, DATA_CMMU).sapr = ap;
d444 2
a445 1
void cmmu_set_uapr(unsigned ap)
d447 5
a451 4
    int cpu = 0;
    /* this functionality also mimiced in cmmu_pmap_activate() */
    REGS(cpu, INST_CMMU).uapr = ap;
    REGS(cpu, DATA_CMMU).uapr = ap;
d462 2
a463 1
void cmmu_set_batc_entry(
d470 2
a471 2
    REGS(cpu,data).bwp[entry_no] = value;
    #if SHADOW_BATC
d473 1
a473 1
    #endif
d475 2
a476 2
    REGS(cpu,data).scr = CMMU_FLUSH_SUPER_ALL;
    REGS(cpu,data).scr = CMMU_FLUSH_USER_ALL;
a477 1

d484 2
a485 1
void cmmu_set_pair_batc_entry(
d491 2
a492 2
    REGS(cpu,DATA_CMMU).bwp[entry_no] = value;
    #if SHADOW_BATC
d494 3
a496 3
    #endif
    REGS(cpu,INST_CMMU).bwp[entry_no] = value;
    #if SHADOW_BATC
d498 1
a498 1
    #endif
d501 4
a504 4
    REGS(cpu,INST_CMMU).scr = CMMU_FLUSH_SUPER_ALL;
    REGS(cpu,INST_CMMU).scr = CMMU_FLUSH_USER_ALL;
    REGS(cpu,DATA_CMMU).scr = CMMU_FLUSH_SUPER_ALL;
    REGS(cpu,DATA_CMMU).scr = CMMU_FLUSH_USER_ALL;
a505 1

d516 2
a517 5
void cmmu_flush_remote_tlb(
    unsigned cpu,
    unsigned kernel,
    vm_offset_t vaddr,
    int size)
d519 1
a519 1
    register s = splhigh();
d521 15
a535 16
    if ((unsigned)size > M88K_PGBYTES) 
      {
	REGS(cpu, INST_CMMU).scr =
	REGS(cpu, DATA_CMMU).scr =
	    kernel ? CMMU_FLUSH_SUPER_ALL : CMMU_FLUSH_USER_ALL;
      }
    else /* a page or smaller */
      {
	REGS(cpu, INST_CMMU).sar = (unsigned)vaddr;
	REGS(cpu, DATA_CMMU).sar = (unsigned)vaddr;

	REGS(cpu, INST_CMMU).scr =
	REGS(cpu, DATA_CMMU).scr =
	    kernel ? CMMU_FLUSH_SUPER_PAGE : CMMU_FLUSH_USER_PAGE;
    }
    splx(s);
d541 2
a542 1
void cmmu_flush_tlb(unsigned kernel, vm_offset_t vaddr, int size)
d544 1
a544 1
    cmmu_flush_remote_tlb(0, kernel, vaddr, size);
a546 1

d552 2
a553 1
void cmmu_pmap_activate(
d559 1
a559 1
    int entry_no;
d561 12
a572 12
    /* the following is from cmmu_set_uapr */
    REGS(cpu, INST_CMMU).uapr = uapr;
    REGS(cpu, DATA_CMMU).uapr = uapr;

    for (entry_no = 0; entry_no < BATC_MAX; entry_no++) {
	REGS(cpu,INST_CMMU).bwp[entry_no] = i_batc[entry_no].bits;
	REGS(cpu,DATA_CMMU).bwp[entry_no] = d_batc[entry_no].bits;
	#if SHADOW_BATC
	    CMMU(cpu,INST_CMMU)->batc[entry_no] = i_batc[entry_no].bits;
	    CMMU(cpu,DATA_CMMU)->batc[entry_no] = d_batc[entry_no].bits;
	#endif
    }
d574 7
a580 7
    /*
     * Flush the user TLB.
     * IF THE KERNEL WILL EVER CARE ABOUT THE BATC ENTRIES,
     * THE SUPERVISOR TLBs SHOULB EE FLUSHED AS WELL.
     */
    REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_USER_ALL;
    REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_USER_ALL;
d599 2
a600 1
void cmmu_flush_remote_cache(int cpu, vm_offset_t physaddr, int size)
d602 1
a602 1
    register s = splhigh();
d604 24
d629 1
a629 1
    if (size < 0 || size > NBSG ) {
d632 2
a633 22
    }
    else if (size <= 16) {
	REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
	REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
	REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_LINE;
	REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_LINE;
    }
    else if (size <= NBPG) {
	REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
	REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
	REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_PAGE;
	REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_PAGE;
    }
    else {
	REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
	REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
	REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_SEGMENT;
	REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_SEGMENT;
    }


    splx(s);
d639 2
a640 1
void cmmu_flush_cache(vm_offset_t physaddr, int size)
d642 1
a642 1
    cmmu_flush_remote_cache(0, physaddr, size);
d648 2
a649 1
void cmmu_flush_remote_inst_cache(int cpu, vm_offset_t physaddr, int size)
d651 1
a651 1
    register s = splhigh();
d653 17
a669 2

    if (size < 0 || size > NBSG ) {
d671 1
a671 13
    }
    else if (size <= 16) {
	REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
	REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_LINE;
    }
    else if (size <= NBPG) {
	REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
	REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_PAGE;
    }
    else {
	REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
	REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_SEGMENT;
    }
d673 1
a673 2

    splx(s);
d679 2
a680 1
void cmmu_flush_inst_cache(vm_offset_t physaddr, int size)
d682 1
a682 1
    cmmu_flush_remote_inst_cache(0, physaddr, size);
d685 2
a686 1
void cmmu_flush_remote_data_cache(int cpu, vm_offset_t physaddr, int size)
d688 1
a688 1
    register s = splhigh();
d690 17
a706 2

    if (size < 0 || size > NBSG ) {
d708 1
a708 14
    }
    else if (size <= 16) {
	REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
	REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_LINE;
    }
    else if (size <= NBPG) {
	REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
	REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_PAGE;
    }
    else {
	REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
	REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_SEGMENT;
    }

d716 2
a717 1
void cmmu_flush_data_cache(vm_offset_t physaddr, int size)
d719 111
a829 1
    cmmu_flush_remote_data_cache(0, physaddr, size);
d832 33
a865 1
#if 0
d936 3
d943 2
a944 1
void cmmu_show_translation(
d970 1
d1006 4
a1009 1
    } else {
d1064 2
a1065 1
    #if SHADOW_BATC
d1086 2
a1087 1
    #endif
d1090 1
d1092 1
d1125 2
d1131 1
d1135 2
d1141 1
d1283 2
a1284 1
void cmmu_cache_state(unsigned addr, unsigned supervisor_flag)
d1340 2
a1341 1
void show_cmmu_info(unsigned addr)
a1354 1
#endif /* 0 */
@


1.1
log
@moved from m88k directory
@
text
@@


1.1.1.1
log
@Third try at importing the mvme88k port. This is a working kernel
from nivas.
Userland and compiler still need to be worked on.
Make certain what directory the import is done from.
@
text
@a1 31
 * Copyright (c) 1996 Nivas Madhur
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Nivas Madhur.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *	$Id: autoconf.c,v 1.3 1996/08/02 02:44:11 build Exp build $
 */
/*
d27 3
a30 5
#include <sys/param.h>
#include <sys/types.h>
#include <machine/board.h>
#include <machine/cpus.h>
#include <machine/m882xx.h>
d32 2
a33 8
/* On some versions of 88200, page size flushes don't work. I am using
 * sledge hammer approach till I find for sure which ones are bad XXX nivas */
#define BROKEN_MMU_MASK	
#if defined(MVME187)
#undef SNOOP_ENABLE
#else
#define	SNOOP_ENABLE
#endif	/* defined(MVME187)
d35 3
a37 1
#undef	SHADOW_BATC		/* don't use BATCs for now XXX nivas */
d69 6
d77 10
d88 8
a95 8
	struct cmmu_regs *cmmu_regs; 	/* CMMU "base" area */
	unsigned char  cmmu_cpu;	/* cpu number it is attached to */
	unsigned char  which;	 	/* either INST_CMMU || DATA_CMMU */
	unsigned char  cmmu_alive;
#define CMMU_DEAD	0		/* This cmmu not there */
#define CMMU_AVAILABLE	1		/* It's there, but which cpu's? */
#define CMMU_MARRIED	2		/* Know which cpu it belongs to. */
#if SHADOW_BATC
d97 2
a98 2
#endif
	unsigned char  pad;
d104 1
d122 1
a122 1
unsigned cache_policy = /*CACHE_INH*/ 0;
d125 1
a125 2
void
show_apr(unsigned value)
d127 9
a135 10
	union apr_template apr_template;
	apr_template.bits = value;

	_printf("table @@ 0x%x000", apr_template.field.st_base);
	if (apr_template.field.wt) printf(", writethrough");
	if (apr_template.field.g)  printf(", global");
	if (apr_template.field.ci) printf(", cache inhibit");
	if (apr_template.field.te) printf(", valid");
	else                       printf(", not valid");
	printf("]\n");
d138 1
a138 2
void
show_sctr(unsigned value)
d161 1
a161 2
void
cmmu_init(void)
d163 62
a224 67
	unsigned tmp, cmmu_num;
	union cpupid id;
	int cpu;

	cpu_cmmu[0].pair[INST_CMMU] = cpu_cmmu[0].pair[DATA_CMMU] = 0;

	for (cmmu_num = 0; cmmu_num < MAX_CMMUS; cmmu_num++) {
		if (!badwordaddr((vm_offset_t)cmmu[cmmu_num].cmmu_regs)) {
			id.cpupid = cmmu[cmmu_num].cmmu_regs->idr;
			if (id.m88200.type != M88200 && id.m88200.type !=M88204)
				continue;
			cmmu[cmmu_num].cmmu_alive = CMMU_AVAILABLE;

			cpu_cmmu[cmmu[cmmu_num].cmmu_cpu].pair[cmmu[cmmu_num].which] =
				&cmmu[cmmu_num];

			/*
			 * Reset cache data....
			 * as per M88200 Manual (2nd Ed.) section 3.11.
			 */
			for (tmp = 0; tmp < 255; tmp++) {
				cmmu[cmmu_num].cmmu_regs->sar = tmp << 4;
				cmmu[cmmu_num].cmmu_regs->cssp = 0x3f0ff000;
			}

			/* 88204 has additional cache to clear */
			if(id.m88200.type == M88204)
			{
				for (tmp = 0; tmp < 255; tmp++) {
					cmmu[cmmu_num].cmmu_regs->sar =
								tmp<<4;
					cmmu[cmmu_num].cmmu_regs->cssp1 =
								0x3f0ff000;
				}
				for (tmp = 0; tmp < 255; tmp++) {
					cmmu[cmmu_num].cmmu_regs->sar =
								tmp<<4;
					cmmu[cmmu_num].cmmu_regs->cssp2 =
								0x3f0ff000;
				}
				for (tmp = 0; tmp < 255; tmp++) {
					cmmu[cmmu_num].cmmu_regs->sar =
								tmp<<4;
					cmmu[cmmu_num].cmmu_regs->cssp3 =									 0x3f0ff000;
				}
			}

			/*
			 * Set the SCTR, SAPR, and UAPR to some known state
			 * (I don't trust the reset to do it).
			 */
			tmp =
				! CMMU_SCTR_PE |   /* not parity enable */
				! CMMU_SCTR_SE |   /* not snoop enable */
				! CMMU_SCTR_PR ;   /*not priority arbitration */
	    		cmmu[cmmu_num].cmmu_regs->sctr = tmp;

			tmp =
				(0x00000 << 12) |/*segment table base address */
				AREA_D_WT |	/* write through */
				AREA_D_G  |	/* global */
				AREA_D_CI |	/* cache inhibit */
				! AREA_D_TE ;	/* not translation enable */

			cmmu[cmmu_num].cmmu_regs->sapr =
			cmmu[cmmu_num].cmmu_regs->uapr = tmp;
		
d226 8
a233 8
			cmmu[cmmu_num].batc[0] =
			cmmu[cmmu_num].batc[1] =
			cmmu[cmmu_num].batc[2] =
			cmmu[cmmu_num].batc[3] =
			cmmu[cmmu_num].batc[4] =
			cmmu[cmmu_num].batc[5] =
			cmmu[cmmu_num].batc[6] =
			cmmu[cmmu_num].batc[7] = 0;
d235 11
a245 13
			cmmu[cmmu_num].cmmu_regs->bwp[0] = 
			cmmu[cmmu_num].cmmu_regs->bwp[1] = 
			cmmu[cmmu_num].cmmu_regs->bwp[2] = 
			cmmu[cmmu_num].cmmu_regs->bwp[3] = 
			cmmu[cmmu_num].cmmu_regs->bwp[4] = 
			cmmu[cmmu_num].cmmu_regs->bwp[5] = 
			cmmu[cmmu_num].cmmu_regs->bwp[6] = 
			cmmu[cmmu_num].cmmu_regs->bwp[7] = 0;

			cmmu[cmmu_num].cmmu_regs->scr =CMMU_FLUSH_CACHE_INV_ALL;
			cmmu[cmmu_num].cmmu_regs->scr = CMMU_FLUSH_SUPER_ALL;
			cmmu[cmmu_num].cmmu_regs->scr = CMMU_FLUSH_USER_ALL;
		}
d247 14
d262 12
a273 5
	/*
	 * Now that we know which CMMUs are there, let's report on which
	 * CPU/CMMU sets seem complete (hopefully all)
	 */
	for (cpu = 0; cpu < MAX_CPUS; cpu++)
a274 19
		if (cpu_cmmu[cpu].pair[INST_CMMU] && cpu_cmmu[cpu].pair[DATA_CMMU])
		{
			if(id.m88200.type == M88204)
				printf("CPU%d is attached with MC88204 CMMU\n",
									cpu);
			else
				printf("CPU%d is attached with MC88200 CMMU\n",
									cpu);
		}
		else if (cpu_cmmu[cpu].pair[INST_CMMU])
		{
			printf("CPU%d data CMMU is not working.\n", cpu);
			panic("cmmu-data");
		}
		else if (cpu_cmmu[cpu].pair[DATA_CMMU])
		{
			printf("CPU%d instruction CMMU is not working.\n", cpu);
			panic("cmmu");
		}
d276 1
d278 5
a282 1
#if SNOOP_ENABLE
d284 3
a286 3
	 * Enable snooping... MVME187 doesn't support snooping. The
	 * processor will, but the processor is not going to see the cache
	 * accesses going on the 040 local bus. XXX nivas
d288 9
a296 19
	for (cpu = 0; cpu < MAX_CPUS; cpu++)
	{
		/*
		 * Enable snooping.
		 * We enable it for instruction cmmus as well so that we can
		 * have breakpoints, etc, and modify code.
		 */
		tmp =
		    ! CMMU_SCTR_PE |   /* not parity enable */
		      CMMU_SCTR_SE |   /* snoop enable */
		    ! CMMU_SCTR_PR ;   /* not priority arbitration */

		REGS(cpu, DATA_CMMU).sctr = tmp;
		REGS(cpu, INST_CMMU).sctr = tmp;
		REGS(cpu, DATA_CMMU).scr  = CMMU_FLUSH_SUPER_ALL;
		REGS(cpu, INST_CMMU).scr  = CMMU_FLUSH_SUPER_ALL;
	}

#endif /* SNOOP_ENABLE */
d298 5
d304 4
a307 1
	 * Turn on some cache.
d309 56
a364 16
	for (cpu = 0; cpu < MAX_CPUS; cpu++)
	{
		/*
		 * Enable some caching for the instruction stream.
		 * Can't cache data yet 'cause device addresses can never
		 * be cached, and we don't have those no-caching zones
		 * set up yet....
		 */
		tmp =
		    (0x00000 << 12) |	/* segment table base address */
			  AREA_D_WT |	/* write through */
			  AREA_D_G  |	/* global */
			  AREA_D_CI |	/* cache inhibit */
			! AREA_D_TE ;	/* not translation enable */
		REGS(cpu, INST_CMMU).sapr = tmp;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_SUPER_ALL;
d366 2
d371 3
a373 1
 * Just before poweroff or reset....
d375 1
a375 2
void
cmmu_shutdown_now(void)
d377 2
a378 2
	unsigned tmp;
	unsigned cmmu_num;
d380 15
a394 4
	/*
	 * Now set some state as we like...
	 */
	for (cmmu_num = 0; cmmu_num < MAX_CMMUS; cmmu_num++)
d396 11
a406 18
		tmp =
		! CMMU_SCTR_PE |   /* parity enable */
#if SNOOP_ENABLE
		! CMMU_SCTR_SE |   /* snoop enable */
#endif /* SNOOP_ENABLE */
		! CMMU_SCTR_PR ;   /* priority arbitration */

		cmmu[cmmu_num].cmmu_regs->sctr = tmp;

		tmp = 
			(0x00000 << 12) |  /* segment table base address */
			! AREA_D_WT |      /* write through */
			! AREA_D_G  |      /* global */
			  AREA_D_CI |      /* cache inhibit */
			! AREA_D_TE ;      /* translation disable */
		
		cmmu[cmmu_num].cmmu_regs->sapr = tmp;
		cmmu[cmmu_num].cmmu_regs->uapr = tmp;
d408 5
d422 1
a422 2
void
cmmu_remote_set(unsigned cpu, unsigned r, unsigned data, unsigned x)
d424 1
a424 1
	*(volatile unsigned *)(r + (char*)&REGS(cpu,data)) = x;
d434 1
a434 2
unsigned
cmmu_remote_get(unsigned cpu, unsigned r, unsigned data)
d436 1
a436 1
	return (*(volatile unsigned *)(r + (char*)&REGS(cpu,data)));
d440 1
a440 2
unsigned
cmmu_get_idr(unsigned data)
d442 1
a442 1
	return REGS(0,data).idr;
d445 1
a445 2
void
cmmu_set_sapr(unsigned ap)
d447 3
a449 4
	int cpu = 0;

	if (cache_policy & CACHE_INH)
		ap |= AREA_D_CI;
d451 2
a452 2
	REGS(cpu, INST_CMMU).sapr = ap;
	REGS(cpu, DATA_CMMU).sapr = ap;
d455 1
a455 2
void
cmmu_remote_set_sapr(unsigned cpu, unsigned ap)
d457 4
a460 5
	if (cache_policy & CACHE_INH)
		ap |= AREA_D_CI;

	REGS(cpu, INST_CMMU).sapr = ap;
	REGS(cpu, DATA_CMMU).sapr = ap;
d463 1
a463 2
void
cmmu_set_uapr(unsigned ap)
d465 4
a468 5
	int cpu = 0;

	/* this functionality also mimiced in cmmu_pmap_activate() */
	REGS(cpu, INST_CMMU).uapr = ap;
	REGS(cpu, DATA_CMMU).uapr = ap;
d479 1
a479 2
void
cmmu_set_batc_entry(
d486 2
a487 2
	REGS(cpu,data).bwp[entry_no] = value;
#if SHADOW_BATC
d489 1
a489 1
#endif
d491 2
a492 2
	REGS(cpu,data).scr = CMMU_FLUSH_SUPER_ALL;
	REGS(cpu,data).scr = CMMU_FLUSH_USER_ALL;
d494 1
d501 1
a501 2
void
cmmu_set_pair_batc_entry(
d507 2
a508 2
	REGS(cpu,DATA_CMMU).bwp[entry_no] = value;
#if SHADOW_BATC
d510 3
a512 3
#endif
	REGS(cpu,INST_CMMU).bwp[entry_no] = value;
#if SHADOW_BATC
d514 1
a514 1
#endif
d517 4
a520 4
	REGS(cpu,INST_CMMU).scr = CMMU_FLUSH_SUPER_ALL;
	REGS(cpu,INST_CMMU).scr = CMMU_FLUSH_USER_ALL;
	REGS(cpu,DATA_CMMU).scr = CMMU_FLUSH_SUPER_ALL;
	REGS(cpu,DATA_CMMU).scr = CMMU_FLUSH_USER_ALL;
d522 1
d533 5
a537 2
void
cmmu_flush_remote_tlb(unsigned cpu, unsigned kernel, vm_offset_t vaddr, int size)
d539 1
a539 1
	register s = splhigh();
d541 16
a556 15
	if ((unsigned)size > M88K_PGBYTES) 
	{
		REGS(cpu, INST_CMMU).scr =
		REGS(cpu, DATA_CMMU).scr =
			kernel ? CMMU_FLUSH_SUPER_ALL : CMMU_FLUSH_USER_ALL;
	}
	else /* a page or smaller */
	{
		REGS(cpu, INST_CMMU).sar = (unsigned)vaddr;
		REGS(cpu, DATA_CMMU).sar = (unsigned)vaddr;
		REGS(cpu, INST_CMMU).scr =
		REGS(cpu, DATA_CMMU).scr =
			kernel ? CMMU_FLUSH_SUPER_PAGE : CMMU_FLUSH_USER_PAGE;
	}
	splx(s);
d562 1
a562 2
void
cmmu_flush_tlb(unsigned kernel, vm_offset_t vaddr, int size)
d564 1
a564 1
	cmmu_flush_remote_tlb(0, kernel, vaddr, size);
d567 1
d573 1
a573 2
void
cmmu_pmap_activate(
d579 1
a579 1
	int entry_no;
d581 12
a592 12
	/* the following is from cmmu_set_uapr */
	REGS(cpu, INST_CMMU).uapr = uapr;
	REGS(cpu, DATA_CMMU).uapr = uapr;

	for (entry_no = 0; entry_no < BATC_MAX; entry_no++) {
		REGS(cpu,INST_CMMU).bwp[entry_no] = i_batc[entry_no].bits;
		REGS(cpu,DATA_CMMU).bwp[entry_no] = d_batc[entry_no].bits;
#if SHADOW_BATC
		CMMU(cpu,INST_CMMU)->batc[entry_no] = i_batc[entry_no].bits;
		CMMU(cpu,DATA_CMMU)->batc[entry_no] = d_batc[entry_no].bits;
#endif
	}
d594 7
a600 7
	/*
	 * Flush the user TLB.
	 * IF THE KERNEL WILL EVER CARE ABOUT THE BATC ENTRIES,
	 * THE SUPERVISOR TLBs SHOULB EE FLUSHED AS WELL.
	 */
	REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_USER_ALL;
	REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_USER_ALL;
d619 1
a619 2
void
cmmu_flush_remote_cache(int cpu, vm_offset_t physaddr, int size)
d621 1
a621 1
	register s = splhigh();
a622 24
#if !defined(BROKEN_MMU_MASK)

	if (size < 0 || size > NBSG ) {
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
	}
	else if (size <= 16) {
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_LINE;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_LINE;
	}
	else if (size <= NBPG) {
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_PAGE;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_PAGE;
	}
	else {
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_SEGMENT;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_SEGMENT;
	}
d624 1
a624 1
#else
d627 22
a648 2
#endif /* !BROKEN_MMU_MASK */
	splx(s);
d654 1
a654 2
void
cmmu_flush_cache(vm_offset_t physaddr, int size)
d656 1
a656 1
	cmmu_flush_remote_cache(0, physaddr, size);
d662 1
a662 2
void
cmmu_flush_remote_inst_cache(int cpu, vm_offset_t physaddr, int size)
d664 2
a665 1
	register s = splhigh();
d667 1
a667 17
#if !defined(BROKEN_MMU_MASK)
	if (size < 0 || size > NBSG ) {
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
	}
	else if (size <= 16) {
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_LINE;
	}
	else if (size <= NBPG) {
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_PAGE;
	}
	else {
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_SEGMENT;
	}
#else
d669 13
a681 1
#endif /* !BROKEN_MMU_MASK */
d683 2
a684 1
	splx(s);
d690 1
a690 2
void
cmmu_flush_inst_cache(vm_offset_t physaddr, int size)
d692 1
a692 1
	cmmu_flush_remote_inst_cache(0, physaddr, size);
d695 1
a695 2
void
cmmu_flush_remote_data_cache(int cpu, vm_offset_t physaddr, int size)
d697 2
a698 1
	register s = splhigh();
d700 1
a700 17
#if !defined(BROKEN_MMU_MASK)
	if (size < 0 || size > NBSG ) {
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
	}
	else if (size <= 16) {
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_LINE;
	}
	else if (size <= NBPG) {
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_PAGE;
	}
	else {
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_SEGMENT;
	}
#else
d702 14
a715 1
#endif /* !BROKEN_MMU_MASK */
d723 1
a723 2
void
cmmu_flush_data_cache(vm_offset_t physaddr, int size)
d725 1
a725 1
	cmmu_flush_remote_data_cache(0, physaddr, size);
a727 143
/*
 * sync dcache (and icache too)
 */
static void
cmmu_sync_cache(vm_offset_t physaddr, int size)
{
	register s = splhigh();

#if !defined(BROKEN_MMU_MASK)
	if (size < 0 || size > NBSG ) {
		REGS(0, INST_CMMU).scr = CMMU_FLUSH_CACHE_CB_ALL;
		REGS(0, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CB_ALL;
	}
	else if (size <= 16) {
		REGS(0, INST_CMMU).sar = (unsigned)physaddr;
		REGS(0, INST_CMMU).scr = CMMU_FLUSH_CACHE_CB_LINE;
		REGS(0, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(0, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CB_LINE;
	}
	else if (size <= NBPG) {
		REGS(0, INST_CMMU).sar = (unsigned)physaddr;
		REGS(0, INST_CMMU).scr = CMMU_FLUSH_CACHE_CB_PAGE;
		REGS(0, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(0, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CB_PAGE;
	}
	else {
		REGS(0, INST_CMMU).sar = (unsigned)physaddr;
		REGS(0, INST_CMMU).scr = CMMU_FLUSH_CACHE_CB_SEGMENT;
		REGS(0, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(0, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CB_SEGMENT;
	}
#else
	REGS(0, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CB_ALL;
	REGS(0, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CB_ALL;
#endif /* !BROKEN_MMU_MASK */
	splx(s);
}

static void
cmmu_sync_inval_cache(vm_offset_t physaddr, int size)
{
	register s = splhigh();

#if !defined(BROKEN_MMU_MASK)
	if (size < 0 || size > NBSG ) {
		REGS(0, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
		REGS(0, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
	}
	else if (size <= 16) {
		REGS(0, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(0, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_LINE;
		REGS(0, INST_CMMU).sar = (unsigned)physaddr;
		REGS(0, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_LINE;
	}
	else if (size <= NBPG) {
		REGS(0, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(0, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_PAGE;
		REGS(0, INST_CMMU).sar = (unsigned)physaddr;
		REGS(0, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_PAGE;
	}
	else {
		REGS(0, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(0, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_SEGMENT;
		REGS(0, INST_CMMU).sar = (unsigned)physaddr;
		REGS(0, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_SEGMENT;
	}

#else
	REGS(0, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
	REGS(0, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
#endif /* !BROKEN_MMU_MASK */
	splx(s);
}

static void
cmmu_inval_cache(vm_offset_t physaddr, int size)
{
	register s = splhigh();

#if !defined(BROKEN_MMU_MASK)
	if (size < 0 || size > NBSG ) {
		REGS(0, DATA_CMMU).scr = CMMU_FLUSH_CACHE_INV_ALL;
		REGS(0, INST_CMMU).scr = CMMU_FLUSH_CACHE_INV_ALL;
	}
	else if (size <= 16) {
		REGS(0, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(0, DATA_CMMU).scr = CMMU_FLUSH_CACHE_INV_LINE;
		REGS(0, INST_CMMU).sar = (unsigned)physaddr;
		REGS(0, INST_CMMU).scr = CMMU_FLUSH_CACHE_INV_LINE;
	}
	else if (size <= NBPG) {
		REGS(0, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(0, DATA_CMMU).scr = CMMU_FLUSH_CACHE_INV_PAGE;
		REGS(0, INST_CMMU).sar = (unsigned)physaddr;
		REGS(0, INST_CMMU).scr = CMMU_FLUSH_CACHE_INV_PAGE;
	}
	else {
		REGS(0, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(0, DATA_CMMU).scr = CMMU_FLUSH_CACHE_INV_SEGMENT;
		REGS(0, INST_CMMU).sar = (unsigned)physaddr;
		REGS(0, INST_CMMU).scr = CMMU_FLUSH_CACHE_INV_SEGMENT;
	}
#else
	REGS(0, DATA_CMMU).scr = CMMU_FLUSH_CACHE_INV_ALL;
	REGS(0, INST_CMMU).scr = CMMU_FLUSH_CACHE_INV_ALL;
#endif /* !BROKEN_MMU_MASK */

	splx(s);
}

void
dma_cachectl(vm_offset_t va, int size, int op)
{
	int count;
	
#if !defined(BROKEN_MMU_MASK)
	while (size) {

		count = NBPG - ((int)va & PGOFSET);

		if (size < count)
			count = size;

		if (op == DMA_CACHE_SYNC)
			cmmu_sync_cache(kvtop(va), count);
		else if (op == DMA_CACHE_SYNC_INVAL)
			cmmu_sync_inval_cache(kvtop(va), count);
		else
			cmmu_inval_cache(kvtop(va), count);

		va = (vm_offset_t)((int)va + count);
		size -= count;
	}
#else

	if (op == DMA_CACHE_SYNC)
		cmmu_sync_cache(kvtop(va), size);
	else if (op == DMA_CACHE_SYNC_INVAL)
		cmmu_sync_inval_cache(kvtop(va), size);
	else
		cmmu_inval_cache(kvtop(va), size);
#endif /* !BROKEN_MMU_MASK */
}
d729 1
a799 3
#undef VEQR_ADDR
#define  VEQR_ADDR 0

d804 1
a804 2
void
cmmu_show_translation(
a829 1
#if 0 /* no thread */
d865 1
a865 4
    }
    else
#endif /* 0 */
    {
d920 1
a920 2
#if 0
#if SHADOW_BATC
d941 1
a941 2
#endif
#endif /* 0 */
a943 1
#if 0
a944 1
#endif /* 0 */
a976 2
		db_printf("CMMU#%d", cmmu_num);
#if 0
a980 1
#endif /* 0 */
a983 2
	db_printf("CMMU#%d", cmmu_num);
#if 0
a987 1
#endif /* 0 /
d1129 1
a1129 2
void
cmmu_cache_state(unsigned addr, unsigned supervisor_flag)
d1185 1
a1185 2
void
show_cmmu_info(unsigned addr)
d1199 1
@
