head	1.19;
access;
symbols
	SMP_SYNC_A:1.19
	SMP_SYNC_B:1.19
	UBC_SYNC_A:1.19
	UBC_SYNC_B:1.19
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SMP:1.1.0.4
	SMP_BASE:1.1
	kame_19991208:1.1
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.19
date	2001.12.22.09.49.39;	author smurph;	state dead;
branches;
next	1.18;

1.18
date	2001.12.22.07.35.43;	author smurph;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.19.07.04.41;	author smurph;	state Exp;
branches;
next	1.16;

1.16
date	2001.12.16.23.49.46;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.13.08.55.52;	author smurph;	state dead;
branches;
next	1.14;

1.14
date	2001.08.31.01.52.22;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.26.14.31.12;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.24.22.48.26;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.24.19.26.15;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.11.01.55.55;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.14.21.30.45;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.18.01.49.39;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.09.05.44.41;	author smurph;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.08.00.03.31;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2001.02.01.03.38.20;	author smurph;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.12.07.29.26;	author smurph;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.28.21.21.24;	author smurph;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.03.00.54.53;	author todd;	state Exp;
branches;
next	1.1;

1.1
date	99.09.27.19.13.22;	author smurph;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2000.03.24.09.08.17;	author niklas;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2001.04.18.16.11.35;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2001.07.04.10.20.15;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2001.10.31.03.01.19;	author nate;	state Exp;
branches;
next	1.1.4.5;

1.1.4.5
date	2002.03.06.02.04.45;	author niklas;	state dead;
branches;
next	;


desc
@@


1.19
log
@masive cmmu overhaul.  function pointers now control cmmu functionality
instead of case statements based on cpu type.
@
text
@/*	$OpenBSD: m18x_cmmu.c,v 1.18 2001/12/22 07:35:43 smurph Exp $	*/
/*
 * Copyright (c) 1998 Steve Murphree, Jr.
 * Copyright (c) 1996 Nivas Madhur
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Nivas Madhur.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/*
 * Mach Operating System
 * Copyright (c) 1993-1991 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON AND OMRON ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON AND OMRON DISCLAIM ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/types.h>
#include <sys/systm.h>
#include <sys/simplelock.h>

#include <machine/asm_macro.h>
#include <machine/board.h>
#include <machine/cpus.h>
#include <machine/cpu_number.h>
#include <machine/locore.h>
#include <machine/m8820x.h>

#ifdef DDB
#include <ddb/db_output.h>		/* db_printf()		*/
#endif /* DDB */

#ifdef DDB
#define DEBUG_MSG db_printf
#else
#define DEBUG_MSG printf
#endif /* DDB */

/* On some versions of 88200, page size flushes don't work. I am using
 * sledge hammer approach till I find for sure which ones are bad XXX nivas */
#define BROKEN_MMU_MASK	
#define CMMU_DEBUG

#ifdef DEBUG
#define DB_CMMU	0x4000	/* MMU debug */
unsigned int m18x_debuglevel = 0;
#define dprintf(_L_,_X_) \
	do { \
		if (m18x_debuglevel & (_L_)) { \
			unsigned int psr = disable_interrupts_return_psr(); \
			printf("%d: ", cpu_number()); \
			printf _X_;  \
			set_psr(psr); \
		} \
	} while (0)
#else
#define dprintf(_L_,_X_) do { } while (0)
#endif 
#undef	SHADOW_BATC		/* don't use BATCs for now XXX nivas */

struct cmmu_regs {
   /* base + $000 */volatile unsigned idr; 
   /* base + $004 */volatile unsigned scr; 
   /* base + $008 */volatile unsigned ssr; 
   /* base + $00C */volatile unsigned sar; 
   /*             */unsigned padding1[0x3D]; 
   /* base + $104 */volatile unsigned sctr; 
   /* base + $108 */volatile unsigned pfSTATUSr; 
   /* base + $10C */volatile unsigned pfADDRr; 
   /*             */unsigned padding2[0x3C]; 
   /* base + $200 */volatile unsigned sapr; 
   /* base + $204 */volatile unsigned uapr; 
   /*             */unsigned padding3[0x7E]; 
   /* base + $400 */volatile unsigned bwp[8]; 
   /*             */unsigned padding4[0xF8]; 
   /* base + $800 */volatile unsigned cdp[4]; 
   /*             */unsigned padding5[0x0C]; 
   /* base + $840 */volatile unsigned ctp[4]; 
   /*             */unsigned padding6[0x0C]; 
   /* base + $880 */volatile unsigned cssp;

   /* The rest for the 88204 */
#define cssp0 cssp
   /*             */ unsigned padding7[0x03]; 
   /* base + $890 */volatile unsigned cssp1; 
   /*             */unsigned padding8[0x03]; 
   /* base + $8A0 */volatile unsigned cssp2; 
   /*             */unsigned padding9[0x03]; 
   /* base + $8B0 */volatile unsigned cssp3;
};

struct cmmu {
	struct cmmu_regs *cmmu_regs;	/* CMMU "base" area */
	unsigned char  cmmu_cpu;	/* cpu number it is attached to */
	unsigned char  which;		/* either INST_CMMU || DATA_CMMU */
	unsigned char  cmmu_access;	/* either CMMU_ACS_{SUPER,USER,BOTH} */
	unsigned char  cmmu_alive;
#define CMMU_DEAD	0		/* This cmmu not there */
#define CMMU_AVAILABLE	1		/* It's there, but which cpu's? */
#define CMMU_ALIVE	1		/* It's there. */
#define CMMU_MARRIED	2		/* Know which cpu it belongs to. */
	vm_offset_t    cmmu_addr;	/* address range */
	vm_offset_t    cmmu_addr_mask;	/* address mask */
	int            cmmu_addr_match;	/* return value of address comparison */
#ifdef SHADOW_BATC
	unsigned batc[8];
#endif
}; 
/*
 * We rely upon and use INST_CMMU == 0 and DATA_CMMU == 1
 */
#if INST_CMMU != 0 || DATA_CMMU != 1
error("ack gag barf!");
#endif

/*
 * CMMU(cpu,data) Is the cmmu struct for the named cpu's indicated cmmu.
 * REGS(cpu,data) is the actual register structure.
 */

#define CMMU(cpu, data) cpu_cmmu[(cpu)].pair[(data)?DATA_CMMU:INST_CMMU]
#define REGS(cpu, data) (*CMMU(cpu, data)->cmmu_regs)

/* 
 * This lock protects the cmmu SAR and SCR's; other ports 
 * can be accessed without locking it 
 *
 * May be used from "db_interface.c".
 */

int      vme188_config;

/* prototypes */
void m18x_setup_cmmu_config __P((void));
void m18x_setup_board_config __P((void));
#if defined(CMMU_DEBUG)
void m18x_show_apr __P((unsigned value));
void m18x_show_sctr __P((unsigned value));
#endif
unsigned m18x_cmmu_get __P((int mmu, int reg));
void m18x_cmmu_set __P((int reg, unsigned val, int flags, int num,
    int mode, int access, vm_offset_t addr));
void m18x_cmmu_sync_cache __P((vm_offset_t physaddr, int size));
void m18x_cmmu_sync_inval_cache __P((vm_offset_t physaddr, int size));
void m18x_cmmu_inval_cache __P((vm_offset_t physaddr, int size));
int m18x_cmmu_alive __P((int));
void m18x_cmmu_store __P((int, int, unsigned));

#ifdef CMMU_DEBUG
void
m18x_show_apr(value)
	unsigned value;
{
	union apr_template apr_template;
	apr_template.bits = value;

	printf("table @@ 0x%x000", apr_template.field.st_base);
	if (apr_template.field.wt) printf(", writethrough");
	if (apr_template.field.g)  printf(", global");
	if (apr_template.field.ci) printf(", cache inhibit");
	if (apr_template.field.te) printf(", valid");
	else			   printf(", not valid");
	printf("\n");
}

void
m18x_show_sctr(value)
	unsigned value;
{
	union {
		unsigned bits;
		struct {
			unsigned :16,
			pe: 1,
			se: 1,
			pr: 1,
			:13;
		} fields;
	} sctr; 
	sctr.bits = value;
	printf("%spe, %sse %spr]\n",
	       sctr.fields.pe ? "" : "!",
	       sctr.fields.se ? "" : "!",
	       sctr.fields.pr ? "" : "!");
}
#endif

/*----------------------------------------------------------------
 * The cmmu.c module was initially designed for the Omron Luna 88K
 * layout consisting of 4 CPUs with 2 CMMUs each, one for data
 * and one for instructions.
 *
 * Trying to support a few more board configurations for the
 * Motorola MVME188 we have these layouts:
 *
 *  - config 0: 4 CPUs, 8 CMMUs
 *  - config 1: 2 CPUs, 8 CMMUs
 *  - config 2: 1 CPUs, 8 CMMUs
 *  - config 5: 2 CPUs, 4 CMMUs
 *  - config 6: 1 CPU,  4 CMMUs
 *  - config A: 1 CPU,  2 CMMUs
 *
 * We use these splitup schemas:
 *  - split between data and instructions (always enabled)
 *  - split between user/spv (and A14 in config 2)
 *  - split because of A12 (and A14 in config 2)
 *  - one SRAM supervisor, other rest
 *  - one whole SRAM, other rest
 *
 * The main problem is to find the right suited CMMU for a given
 * CPU number at those configurations.
 *                                         em, 10.5.94
 *
 * WARNING: the code was never tested on a uniprocessor
 * system. All effort was made to support these configuration
 * but the kernel never ran on such a system.
 *
 *					   em, 12.7.94
 */

/*
 * This structure describes the CMMU per CPU split strategies
 * used for data and instruction CMMUs.
 */
struct cmmu_strategy {
	int inst;
	int data;
} cpu_cmmu_strategy[] = {
	/*     inst                 data */
	{ CMMU_SPLIT_SPV,      CMMU_SPLIT_SPV},	 /* CPU 0 */
	{ CMMU_SPLIT_SPV,      CMMU_SPLIT_SPV},	 /* CPU 1 */
	{ CMMU_SPLIT_ADDRESS,  CMMU_SPLIT_ADDRESS}, /* CPU 2 */
	{ CMMU_SPLIT_ADDRESS,  CMMU_SPLIT_ADDRESS}  /* CPU 3 */
};

/*
 * The following list of structs describe the different
 * MVME188 configurations which are supported by this module.
 */
struct board_config {
	int supported;
	int ncpus;
	int ncmmus;
} bd_config[] = {
	/* sup, CPU MMU */
	{  1,  4,  8}, /* 4P128 - 4P512 */
	{  1,  2,  8}, /* 2P128 - 2P512 */
	{  1,  1,  8}, /* 1P128 - 1P512 */
	{  0, -1, -1},
	{  0, -1, -1},
	{  1,  2,  4}, /* 2P64  - 2P256 */
	{  1,  1,  4}, /* 1P64  - 1P256 */
	{  0, -1, -1},
	{  0, -1, -1},
	{  0, -1, -1},
	{  1,  1,  2}, /* 1P32  - 1P128 */
	{  0, -1, -1},
	{  0, -1, -1},
	{  0, -1, -1},
	{  0, -1, -1},
	{  0, -1, -1}
};

/*
 * Structure for accessing MMUS properly.
 */

struct cmmu cmmu[MAX_CMMUS] = {
	/* addr    cpu       mode           access
      alive   addr mask */
	{(void *)VME_CMMU_I0, -1, INST_CMMU, CMMU_ACS_BOTH, 
		CMMU_DEAD, 0, 0},                                 
	{(void *)VME_CMMU_D0, -1, DATA_CMMU, CMMU_ACS_BOTH,       
		CMMU_DEAD, 0, 0},                                 
	{(void *)VME_CMMU_I1, -1, INST_CMMU, CMMU_ACS_BOTH,       
		CMMU_DEAD, 0, 0},                                 
	{(void *)VME_CMMU_D1, -1, DATA_CMMU, CMMU_ACS_BOTH,       
		CMMU_DEAD, 0, 0},                                 
	{(void *)VME_CMMU_I2, -1, INST_CMMU, CMMU_ACS_BOTH,
		CMMU_DEAD, 0, 0},
	{(void *)VME_CMMU_D2, -1, DATA_CMMU, CMMU_ACS_BOTH,
		CMMU_DEAD, 0, 0},
	{(void *)VME_CMMU_I3, -1, INST_CMMU, CMMU_ACS_BOTH,
		CMMU_DEAD, 0, 0},
	{(void *)VME_CMMU_D3, -1, DATA_CMMU, CMMU_ACS_BOTH,
		CMMU_DEAD, 0, 0}
};

struct cpu_cmmu {
	struct cmmu *pair[2];
} cpu_cmmu[MAX_CPUS];

void 
m18x_setup_board_config()
{
	volatile unsigned long *whoami;

	master_cpu = 0;	/* temp to get things going */
	switch (brdtyp) {
#ifdef MVME187
	case BRD_187:
		vme188_config = 10; /* There is no WHOAMI reg on MVME1x7 - fake it... */
		cmmu[0].cmmu_regs = (void *)SBC_CMMU_I;
		cmmu[0].cmmu_cpu = 0;
		cmmu[1].cmmu_regs = (void *)SBC_CMMU_D;
		cmmu[1].cmmu_cpu = 0;
		cmmu[2].cmmu_regs = (void *)NULL;
		cmmu[3].cmmu_regs = (void *)NULL;
		cmmu[4].cmmu_regs = (void *)NULL;
		cmmu[5].cmmu_regs = (void *)NULL;
		cmmu[6].cmmu_regs = (void *)NULL;
		cmmu[7].cmmu_regs = (void *)NULL;
		max_cpus = 1;
		max_cmmus = 2;
		break;
#endif /* defined(MVME187) */
#ifdef MVME188
	case BRD_188:
		whoami = (volatile unsigned long *)MVME188_WHOAMI;
		vme188_config = (*whoami & 0xf0) >> 4;
		dprintf(DB_CMMU,("m18x_setup_board_config: WHOAMI @@ 0x%08x holds value 0x%08x vme188_config = %d\n",
				 whoami, *whoami, vme188_config));
		max_cpus = bd_config[vme188_config].ncpus;
		max_cmmus = bd_config[vme188_config].ncmmus;
		break;
#endif /* MVME188 */
	}
	cpu_cmmu_ratio = max_cmmus / max_cpus;
	switch (bd_config[vme188_config].supported) {
	case 0:
		printf("MVME%x board configuration #%X: %d CPUs %d CMMUs\n", cputyp, 
		       vme188_config, max_cpus, max_cmmus);
		panic("This configuration is not supported - go and get another OS.");
		/* NOTREACHED */
		break;
	case 1:
		printf("MVME%x board configuration #%X: %d CPUs %d CMMUs\n", cputyp,
		       vme188_config, max_cpus, max_cmmus);
		m18x_setup_cmmu_config();
		break;
	default:
		panic("UNKNOWN MVME%x board configuration: WHOAMI = 0x%02x", cputyp, *whoami);
		/* NOTREACHED */
		break;
	}
	return;
}

/*
 * This routine sets up the CPU/CMMU tables used in the
 * motorola/m88k/m88100/cmmu.c module.
 */
void 
m18x_setup_cmmu_config()
{
	register int num, cmmu_num;
#ifdef MVME188
	register int val1, val2;
	volatile unsigned long *pcnfa;
	volatile unsigned long *pcnfb;
#endif 

	dprintf(DB_CMMU,("m18x_setup_cmmu_config: initializing with %d CPU(s) and %d CMMU(s)\n",
			 max_cpus, max_cmmus));

	/*
	 * Probe for available MMUs
	 */
	for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++)
		if (!badwordaddr((vm_offset_t)cmmu[cmmu_num].cmmu_regs)) {
			union cpupid id;

			id.cpupid = cmmu[cmmu_num].cmmu_regs->idr;
			if (id.m88200.type != M88200_ID && id.m88200.type != M88204_ID) {
				printf("WARNING: non M8820x circuit found at CMMU address 0x%08x\n",
				       cmmu[cmmu_num].cmmu_regs);
				continue;
			}
			cmmu[cmmu_num].cmmu_alive = CMMU_ALIVE;
			dprintf(DB_CMMU,("m18x_setup_cmmu_config: CMMU %d found at 0x%08x\n",
					 cmmu_num, cmmu[cmmu_num].cmmu_regs));
		}

		/*
		 * Now that we know which CMMUs are there, let's report on which
		 * CPU/CMMU sets seem complete (hopefully all)
		 */
	for (num = 0; num < max_cpus; num++) {
		register int i;
		union cpupid id;

		for (i = 0; i < cpu_cmmu_ratio; i++) {
			dprintf(DB_CMMU,("cmmu_init: testing CMMU %d for CPU %d\n",
					 num*cpu_cmmu_ratio+i, num));
			if (!m18x_cmmu_alive(num*cpu_cmmu_ratio + i)) {
				printf("CMMU %d attached to CPU %d is not working\n");
				panic("m18x_setup_cmmu_config");
			}
		}
		cpu_sets[num] = 1;   /* This cpu installed... */
		id.cpupid = cmmu[num*cpu_cmmu_ratio].cmmu_regs->idr;

		if (id.m88200.type == M88204_ID)
			printf("CPU%d is attached with %d MC88204 CMMUs\n",
			       num, cpu_cmmu_ratio);
		else
			printf("CPU%d is attached with %d MC88200 CMMUs\n",
			       num, cpu_cmmu_ratio);
	}

	for (num = 0; num < max_cpus; num++) {
		cpu_cmmu_strategy[num].inst &= CMMU_SPLIT_MASK;
		cpu_cmmu_strategy[num].data &= CMMU_SPLIT_MASK;
		dprintf(DB_CMMU,("m18x_setup_cmmu_config: CPU %d inst strat %d data strat %d\n",
				 num, cpu_cmmu_strategy[num].inst, cpu_cmmu_strategy[num].data));
	}

	switch (vme188_config) {
	/*
	 * These configurations have hardwired CPU/CMMU configurations.
	 */
	case CONFIG_0:
	case CONFIG_5:
	case CONFIG_A:
		dprintf(DB_CMMU,("m18x_setup_cmmu_config: resetting strategies\n"));
		for (num = 0; num < max_cpus; num++)
			cpu_cmmu_strategy[num].inst = cpu_cmmu_strategy[num].data =
						      CMMU_SPLIT_ADDRESS;
		break;
#ifdef MVME188
	/*
	 * Configure CPU/CMMU strategy into PCNFA and PCNFB board registers.
	 */
	case CONFIG_1:
		pcnfa = (volatile unsigned long *)MVME188_PCNFA;
		pcnfb = (volatile unsigned long *)MVME188_PCNFB;
		val1 = (cpu_cmmu_strategy[0].inst << 2) | cpu_cmmu_strategy[0].data;
		val2 = (cpu_cmmu_strategy[1].inst << 2) | cpu_cmmu_strategy[1].data;
		*pcnfa = val1;
		*pcnfb = val2;
		dprintf(DB_CMMU,("m18x_setup_cmmu_config: 2P128: PCNFA = 0x%x, PCNFB = 0x%x\n", val1, val2));
		break;
	case CONFIG_2:
		pcnfa = (volatile unsigned long *)MVME188_PCNFA;
		pcnfb = (volatile unsigned long *)MVME188_PCNFB;
		val1 = (cpu_cmmu_strategy[0].inst << 2) | cpu_cmmu_strategy[0].inst;
		val2 = (cpu_cmmu_strategy[0].data << 2) | cpu_cmmu_strategy[0].data;
		*pcnfa = val1;
		*pcnfb = val2;
		dprintf(DB_CMMU,("m18x_setup_cmmu_config: 1P128: PCNFA = 0x%x, PCNFB = 0x%x\n", val1, val2));
		break;
	case CONFIG_6:
		pcnfa = (volatile unsigned long *)MVME188_PCNFA;
		val1 = (cpu_cmmu_strategy[0].inst << 2) | cpu_cmmu_strategy[0].data;
		*pcnfa = val1;
		dprintf(DB_CMMU,("m18x_setup_cmmu_config: 1P64: PCNFA = 0x%x\n", val1));
		break;
#endif /* MVME188 */
	default:
		panic("m18x_setup_cmmu_config");
		break;
	}

#ifdef MVME188
	dprintf(DB_CMMU,("m18x_setup_cmmu_config: PCNFA = 0x%x, PCNFB = 0x%x\n", *pcnfa, *pcnfb));
#endif /* MVME188 */

	/*
	 * Calculate the CMMU<->CPU connections
	 */
	for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++) {
		cmmu[cmmu_num].cmmu_cpu =
		(int) (((float) cmmu_num) * ((float) max_cpus) / ((float) max_cmmus));
		dprintf(DB_CMMU,("m18x_setup_cmmu_config: CMMU %d connected with CPU %d\n",
				 cmmu_num, cmmu[cmmu_num].cmmu_cpu));
	}

	/*
	 * Now set cmmu[].cmmu_access and addr
	 */
	for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++) {
		/*
		 * We don't set up anything for the hardwired configurations.
		 */
		if (cpu_cmmu_ratio == 2) {
			cmmu[cmmu_num].cmmu_addr =
			cmmu[cmmu_num].cmmu_addr_mask = 0;
			cmmu[cmmu_num].cmmu_addr_match = 1;
			cmmu[cmmu_num].cmmu_access = CMMU_ACS_BOTH;
			continue;
		}

		/*
		 * First we set the address/mask pairs for the exact address
		 * matches.
		 */
		switch ((cmmu[cmmu_num].which == INST_CMMU) ?
			cpu_cmmu_strategy[cmmu[cmmu_num].cmmu_cpu].inst :
			cpu_cmmu_strategy[cmmu[cmmu_num].cmmu_cpu].data) {
		case CMMU_SPLIT_ADDRESS:
			cmmu[cmmu_num].cmmu_addr = ((cmmu_num & 0x2) ^ 0x2) << 11;
			cmmu[cmmu_num].cmmu_addr_mask = CMMU_A12_MASK;
			cmmu[cmmu_num].cmmu_addr_match = 1;
			break;
		case CMMU_SPLIT_SPV:
			cmmu[cmmu_num].cmmu_addr =
			cmmu[cmmu_num].cmmu_addr_mask = 0;
			cmmu[cmmu_num].cmmu_addr_match = 1;
			break;
		case CMMU_SPLIT_SRAM_ALL:
			cmmu[cmmu_num].cmmu_addr = CMMU_SRAM;
			cmmu[cmmu_num].cmmu_addr_mask = CMMU_SRAM_MASK;
			cmmu[cmmu_num].cmmu_addr_match = (cmmu_num & 0x2) ? 1 : 0;
			break;
		case CMMU_SPLIT_SRAM_SPV:
			if (cmmu_num & 0x2) {
				cmmu[cmmu_num].cmmu_addr = CMMU_SRAM;
				cmmu[cmmu_num].cmmu_addr_mask = CMMU_SRAM_MASK;
			} else {
				cmmu[cmmu_num].cmmu_addr =
				cmmu[cmmu_num].cmmu_addr_mask = 0;
			}
			cmmu[cmmu_num].cmmu_addr_match = 1;
			break;
		}

		/*
		 * For MVME188 single processors, we've got to look at A14.
		 * This bit splits the CMMUs independent of the enabled strategy.
		 *
		 * NOT TESTED!!! - em
		 */
		if (cpu_cmmu_ratio > 4) {
			cmmu[cmmu_num].cmmu_addr |= ((cmmu_num & 0x4) ^ 0x4) << 12;
			cmmu[cmmu_num].cmmu_addr_mask |= CMMU_A14_MASK;
		}

		/*
		 * Next we cope with the various access modes.
		 */
		switch ((cmmu[cmmu_num].which == INST_CMMU) ?
			cpu_cmmu_strategy[cmmu[cmmu_num].cmmu_cpu].inst :
			cpu_cmmu_strategy[cmmu[cmmu_num].cmmu_cpu].data) {
		case CMMU_SPLIT_SPV:
			cmmu[cmmu_num].cmmu_access =
			(cmmu_num & 0x2 ) ? CMMU_ACS_USER : CMMU_ACS_SUPER;
			break;
		case CMMU_SPLIT_SRAM_SPV:
			cmmu[cmmu_num].cmmu_access =
			(cmmu_num & 0x2 ) ? CMMU_ACS_SUPER : CMMU_ACS_BOTH;
			break;
		default:
			cmmu[cmmu_num].cmmu_access = CMMU_ACS_BOTH;
			break;
		}
	}
	return;
}

#ifdef MVME188
static char *cmmu_strat_string[] = {
	"address split ",
	"user/spv split",
	"spv SRAM split",
	"all SRAM split"
};
#endif 

void 
m18x_cmmu_dump_config()
{
#ifdef MVME188
	volatile unsigned long *pcnfa;
	volatile unsigned long *pcnfb;
	register int cmmu_num;
#endif /* MVME188 */

	DEBUG_MSG("Current CPU/CMMU configuration:\n\n");

	switch (brdtyp) {
#ifdef MVME187
	case BRD_187:
		DEBUG_MSG("VME1x7 split mode\n\n");
#endif /* defined(MVME187) */
#ifdef MVME188
	case BRD_188:
		pcnfa = (volatile unsigned long *)MVME188_PCNFA;
		pcnfb = (volatile unsigned long *)MVME188_PCNFB;
		DEBUG_MSG("VME188 address decoder: PCNFA = 0x%1x, PCNFB = 0x%1x\n\n", *pcnfa & 0xf, *pcnfb & 0xf);
		for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++) {
			DEBUG_MSG("CMMU #%d: %s CMMU for CPU %d:\n Strategy: %s\n %s access addr 0x%08x mask 0x%08x match %s\n",
				  cmmu_num,
				  (cmmu[cmmu_num].which == INST_CMMU) ? "inst" : "data",
				  cmmu[cmmu_num].cmmu_cpu,
				  cmmu_strat_string[(cmmu[cmmu_num].which == INST_CMMU) ?
						    cpu_cmmu_strategy[cmmu[cmmu_num].cmmu_cpu].inst :
						    cpu_cmmu_strategy[cmmu[cmmu_num].cmmu_cpu].data],
				  (cmmu[cmmu_num].cmmu_access == CMMU_ACS_BOTH) ?   "User and spv" :
				  ((cmmu[cmmu_num].cmmu_access == CMMU_ACS_USER) ? "User        " :
				   "Supervisor  "),
				  cmmu[cmmu_num].cmmu_addr,
				  cmmu[cmmu_num].cmmu_addr_mask,
				  cmmu[cmmu_num].cmmu_addr_match ? "TRUE" : "FALSE");
		}
#endif /* MVME188 */
	}
}

/* To be implemented as a macro for speedup - XXX-em */
void
m18x_cmmu_store(mmu, reg, val)
	int mmu, reg;
	unsigned val;
{
	*(volatile unsigned *)(reg + (char *)(cmmu[mmu].cmmu_regs)) = val;
}

int 
m18x_cmmu_alive(mmu)
	int mmu;
{
	return (cmmu[mmu].cmmu_alive == CMMU_ALIVE);
}

unsigned 
m18x_cmmu_get(mmu, reg)
	int mmu, reg;
{
	return *(volatile unsigned *)(reg + (char*)(cmmu[mmu].cmmu_regs));
}

/*
 * This function is called by the MMU module and pokes values
 * into the CMMU's registers.
 */
void 
m18x_cmmu_set(reg, val, flags, num, mode, access, addr)
	int reg;
	unsigned val;
	int flags, num, mode, access;
	vm_offset_t addr;
{
	register int mmu;

	if (flags & NUM_CMMU) {
		/*
		 * Special case: user supplied CMMU number directly as argument.
		 * Simply store the value away.
		 */
		/* assert(num < max_cmmus); */
		m18x_cmmu_store(num, reg, val);
		return;
	}

	/*
	 * We scan all CMMUs to find the matching ones and store the
	 * values there.
	 */
	for (mmu = num*cpu_cmmu_ratio; mmu < (num+1)*cpu_cmmu_ratio; mmu++) {
		if (((flags & MODE_VAL)) &&
		    (cmmu[mmu].which != mode))
			continue;
		if (((flags & ACCESS_VAL)) &&
		    (cmmu[mmu].cmmu_access != access) &&
		    (cmmu[mmu].cmmu_access != CMMU_ACS_BOTH))
			continue;
		if (flags & ADDR_VAL) {
			if (((addr & cmmu[mmu].cmmu_addr_mask) == cmmu[mmu].cmmu_addr)
			    != cmmu[mmu].cmmu_addr_match) {
				continue;
			}
		}
		m18x_cmmu_store(mmu, reg, val);
	}
}

#ifdef DDB
/*
 * Used by DDB for cache probe functions
 */
unsigned 
m18x_cmmu_get_by_mode(cpu, mode)
	int cpu, mode;
{
	register int mmu;

	for (mmu = cpu*cpu_cmmu_ratio; mmu < (cpu+1)*cpu_cmmu_ratio; mmu++)
		if (cmmu[mmu].which == mode)
			return mmu;
	printf("can't figure out first %s CMMU for CPU %d\n",
	       (mode == DATA_CMMU) ? "data" : "instruction", cpu);
	panic("m18x_cmmu_get_by_mode");
	/* NOTREACHED */
	return(0);
}
#endif

static char *mmutypes[8] = {
	"Unknown (0)",
	"Unknown (1)",
	"Unknown (2)",
	"Unknown (3)",
	"Unknown (4)",
	"M88200 (16K)",
	"M88204 (64K)",
	"Unknown (7)"
};

/*
 * Should only be called after the calling cpus knows its cpu
 * number and master/slave status . Should be called first
 * by the master, before the slaves are started.
*/
void 
m18x_cpu_configuration_print(master)
	int master;
{
	int pid = read_processor_identification_register();
	int proctype = (pid & 0xff00) >> 8;
	int procvers = (pid & 0xe) >> 1;
	int mmu, cpu = cpu_number();
	struct simplelock print_lock;

	if (master)
		simple_lock_init(&print_lock);

	simple_lock(&print_lock);

	printf("Processor %d: ", cpu);
	if (proctype)
		printf("Architectural Revision 0x%x UNKNOWN CPU TYPE Version 0x%x\n",
		       proctype, procvers);
	else
		printf("M88100 Version 0x%x\n", procvers);

#ifndef ERRATA__XXX_USR
	if (procvers < 2)
		printf("WARNING: M88100 bug workaround code not enabled!!!\n");
#endif

	for (mmu = cpu*cpu_cmmu_ratio; mmu < (cpu+1)*cpu_cmmu_ratio; mmu++) {
		int idr = m18x_cmmu_get(mmu, CMMU_IDR);
		int mmuid = (0xe00000 & idr)>>21;

		printf(" %s %s Cache: ",
		       (cmmu[mmu].cmmu_access == CMMU_ACS_BOTH) ?  "Spv and User" :
		       ((cmmu[mmu].cmmu_access == CMMU_ACS_USER) ? "User        " :
			"Supervisor  "),
		       (cmmu[mmu].which == INST_CMMU) ?   "Instruction" :
		       "Data       ");
		if (mmutypes[mmuid][0] == 'U')
			printf("Type 0x%x ", mmuid);
		else
			printf("%s ", mmutypes[mmuid]);
		printf("Version 0x%x\n", (idr & 0x1f0000)>>16);
	}
	printf  (" Configured as %s and started\n", master ? "master" : "slave");

	simple_unlock(&print_lock);
}

/*
 * CMMU initialization routine
 */
void
m18x_cmmu_init()
{
	unsigned tmp, cmmu_num;
	union cpupid id;
	int cpu;

	for (cpu = 0; cpu < max_cpus; cpu++) {
		cpu_cmmu[cpu].pair[INST_CMMU] = cpu_cmmu[cpu].pair[DATA_CMMU] = 0;
	}

	for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++){
		if (m18x_cmmu_alive(cmmu_num)) {
			id.cpupid = cmmu[cmmu_num].cmmu_regs->idr;

			cpu_cmmu[cmmu[cmmu_num].cmmu_cpu].pair[cmmu[cmmu_num].which] =
			&cmmu[cmmu_num];
			/*
			 * Reset cache data....
			 * as per M88200 Manual (2nd Ed.) section 3.11.
			 */
			for (tmp = 0; tmp < 255; tmp++) {
				cmmu[cmmu_num].cmmu_regs->sar = tmp << 4;
				cmmu[cmmu_num].cmmu_regs->cssp = 0x3f0ff000;
			}

			/* 88204 has additional cache to clear */
			if (id.m88200.type == M88204_ID) {
				for (tmp = 0; tmp < 255; tmp++) {
					cmmu[cmmu_num].cmmu_regs->sar = tmp<<4;
					cmmu[cmmu_num].cmmu_regs->cssp1 = 0x3f0ff000;
				}
				for (tmp = 0; tmp < 255; tmp++) {
					cmmu[cmmu_num].cmmu_regs->sar = tmp<<4;
					cmmu[cmmu_num].cmmu_regs->cssp2 = 0x3f0ff000;
				}
				for (tmp = 0; tmp < 255; tmp++) {
					cmmu[cmmu_num].cmmu_regs->sar = tmp<<4;
					cmmu[cmmu_num].cmmu_regs->cssp3 = 0x3f0ff000;
				}
			}

			/*
			 * Set the SCTR, SAPR, and UAPR to some known state
			 * (I don't trust the reset to do it).
			 */
			tmp =
			! CMMU_SCTR_PE |   /* not parity enable */
			! CMMU_SCTR_SE | /* not snoop enable */
			! CMMU_SCTR_PR ;  /* not priority arbitration */
			cmmu[cmmu_num].cmmu_regs->sctr = tmp;

			tmp =
			(0x00000 << 12) |  /* segment table base address */
			AREA_D_WT |	 /* write through */
			AREA_D_G  | /* global */
			AREA_D_CI | /* cache inhibit */
			! AREA_D_TE ;	/* not translation enable */
			cmmu[cmmu_num].cmmu_regs->sapr =
			cmmu[cmmu_num].cmmu_regs->uapr = tmp;


#ifdef SHADOW_BATC
			cmmu[cmmu_num].batc[0] =
			cmmu[cmmu_num].batc[1] =
			cmmu[cmmu_num].batc[2] =
			cmmu[cmmu_num].batc[3] =
			cmmu[cmmu_num].batc[4] =
			cmmu[cmmu_num].batc[5] =
			cmmu[cmmu_num].batc[6] =
			cmmu[cmmu_num].batc[7] = 0;
#endif
			cmmu[cmmu_num].cmmu_regs->bwp[0] = 
			cmmu[cmmu_num].cmmu_regs->bwp[1] = 
			cmmu[cmmu_num].cmmu_regs->bwp[2] = 
			cmmu[cmmu_num].cmmu_regs->bwp[3] = 
			cmmu[cmmu_num].cmmu_regs->bwp[4] = 
			cmmu[cmmu_num].cmmu_regs->bwp[5] = 
			cmmu[cmmu_num].cmmu_regs->bwp[6] = 
			cmmu[cmmu_num].cmmu_regs->bwp[7] = 0;
			cmmu[cmmu_num].cmmu_regs->scr = CMMU_FLUSH_CACHE_INV_ALL;
			cmmu[cmmu_num].cmmu_regs->scr = CMMU_FLUSH_SUPER_ALL;
			cmmu[cmmu_num].cmmu_regs->scr = CMMU_FLUSH_USER_ALL;
		}
	}
	/*
	 * Enable snooping...
	 */
	for (cpu = 0; cpu < max_cpus; cpu++) {
		if (!cpu_sets[cpu])
			continue;

		/*
		 * Enable snooping.
		 * We enable it for instruction cmmus as well so that we can have
		 * breakpoints, etc, and modify code.
		 */
		if (brdtyp == BRD_188) {
			tmp =
			! CMMU_SCTR_PE |  /* not parity enable */
			CMMU_SCTR_SE |	/* snoop enable */
			! CMMU_SCTR_PR ;  /* not priority arbitration */
		} else {
			tmp =
			! CMMU_SCTR_PE |  /* not parity enable */
			! CMMU_SCTR_PR ;  /* not priority arbitration */
		}
		m18x_cmmu_set(CMMU_SCTR, tmp, 0, cpu, DATA_CMMU, 0, 0);
		m18x_cmmu_set(CMMU_SCTR, tmp, 0, cpu, INST_CMMU, 0, 0);

		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_SUPER_ALL, ACCESS_VAL,
			      cpu, DATA_CMMU, CMMU_ACS_SUPER, 0);
		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_SUPER_ALL, ACCESS_VAL,
			      cpu, INST_CMMU, CMMU_ACS_SUPER, 0);
	}

	/*
	 * Turn on some cache.
	 */
	for (cpu = 0; cpu < max_cpus; cpu++) {
		if (!cpu_sets[cpu])
			continue;
		/*
		 * Enable some caching for the instruction stream.
		 * Can't cache data yet 'cause device addresses can never
		 * be cached, and we don't have those no-caching zones
		 * set up yet....
		 */
		tmp =
		(0x00000 << 12) | /* segment table base address */
		AREA_D_WT |	  /* write through */
		AREA_D_G  |	  /* global */
		AREA_D_CI |	  /* cache inhibit */
		! AREA_D_TE ;	  /* not translation enable */
		/*
		REGS(cpu, INST_CMMU).sapr = tmp;
		*/
		m18x_cmmu_set(CMMU_SAPR, tmp, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);

		/*
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_SUPER_ALL;
		*/
		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_SUPER_ALL, ACCESS_VAL|MODE_VAL,
			      cpu, DATA_CMMU, CMMU_ACS_SUPER, 0);
	}
}

/*
 * Just before poweroff or reset....
 */
void
m18x_cmmu_shutdown_now()
{
	unsigned tmp;
	unsigned cmmu_num;

	/*
	 * Now set some state as we like...
	 */
	for (cmmu_num = 0; cmmu_num < MAX_CMMUS; cmmu_num++) {
		if (brdtyp == BRD_188) {
			tmp =
			! CMMU_SCTR_PE |   /* parity enable */
			! CMMU_SCTR_SE |   /* snoop enable */
			! CMMU_SCTR_PR ;   /* priority arbitration */
		} else {
			tmp =
			! CMMU_SCTR_PE |   /* parity enable */
			! CMMU_SCTR_PR ;   /* priority arbitration */
		}

		cmmu[cmmu_num].cmmu_regs->sctr = tmp;

		tmp = 
		(0x00000 << 12) |  /* segment table base address */
		! AREA_D_WT |	   /* write through */
		! AREA_D_G  |	   /* global */
		AREA_D_CI |	   /* cache inhibit */
		! AREA_D_TE ;	   /* translation disable */

		cmmu[cmmu_num].cmmu_regs->sapr = tmp;
		cmmu[cmmu_num].cmmu_regs->uapr = tmp;
	}
}

#define PARITY_ENABLE
/*
 * enable parity
 */
void 
m18x_cmmu_parity_enable()
{
#ifdef PARITY_ENABLE
	register int cmmu_num;

	for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++) {
		if (m18x_cmmu_alive(cmmu_num)) {
			register unsigned val1 = 
				m18x_cmmu_get(cmmu_num, CMMU_SCTR);

			/*
			cmmu[cmmu_num].cmmu_regs->sctr |= CMMU_SCTR_PE;
			*/
			m18x_cmmu_set(CMMU_SCTR, val1 | CMMU_SCTR_PE, 
				      NUM_CMMU, cmmu_num, 0, 0, 0);
		}
	}
#endif  /* PARITY_ENABLE */
}

/*
 * Find out the CPU number from accessing CMMU
 * Better be at splhigh, or even better, with interrupts
 * disabled.
 */
#define ILLADDRESS	U(0x0F000000) 	/* any faulty address */

unsigned 
m18x_cmmu_cpu_number()
{
	register unsigned cmmu_no;
	int i;


	for (i=0; i < 10; i++) {
		/* clear CMMU p-bus status registers */
		for (cmmu_no = 0; cmmu_no < MAX_CMMUS; cmmu_no++) {
			if (cmmu[cmmu_no].cmmu_alive == CMMU_AVAILABLE &&
			    cmmu[cmmu_no].which == DATA_CMMU)
				cmmu[cmmu_no].cmmu_regs->pfSTATUSr = 0;
		}

		/* access faulting address */
		badwordaddr((vm_offset_t)ILLADDRESS);

		/* check which CMMU reporting the fault  */
		for (cmmu_no = 0; cmmu_no < MAX_CMMUS; cmmu_no++) {
			if (cmmu[cmmu_no].cmmu_alive == CMMU_AVAILABLE &&
			    cmmu[cmmu_no].which == DATA_CMMU &&
			    cmmu[cmmu_no].cmmu_regs->pfSTATUSr & 0x70000) {
				if (cmmu[cmmu_no].cmmu_regs->pfSTATUSr & 0x70000) {
					cmmu[cmmu_no].cmmu_regs->pfSTATUSr = 0;	/* to be clean */
					cmmu[cmmu_no].cmmu_alive = CMMU_MARRIED;
					return cmmu[cmmu_no].cmmu_cpu;
				}
			}
		}
	}
	panic("m18x_cmmu_cpu_number: could not determine my cpu number");
	return 0; /* to make compiler happy */
}

/*
 * Functions that actually modify CMMU registers.
 */

void
m18x_cmmu_remote_set(cpu, r, data, x)
	unsigned cpu, r, data, x;
{
	*(volatile unsigned *)(r + (char*)&REGS(cpu,data)) = x;
}

/*
 * cmmu_cpu_lock should be held when called if read
 * the CMMU_SCR or CMMU_SAR.
 */
unsigned
m18x_cmmu_remote_get(cpu, r, data)
	unsigned cpu, r, data;
{
	return (*(volatile unsigned *)(r + (char*)&REGS(cpu,data)));
}

/* Needs no locking - read only registers */
unsigned
m18x_cmmu_get_idr(data)
	unsigned data;
{
	int cpu;
	cpu = cpu_number();
	return REGS(cpu,data).idr;
}

void
m18x_cmmu_set_sapr(ap)
	unsigned ap;
{
	int cpu;
	cpu = cpu_number();

	if (cache_policy & CACHE_INH)
		ap |= AREA_D_CI;
	/*
	REGS(cpu, INST_CMMU).sapr = ap;
	REGS(cpu, DATA_CMMU).sapr = ap;
	*/
	m18x_cmmu_set(CMMU_SAPR, ap, ACCESS_VAL,
		      cpu, 0, CMMU_ACS_SUPER, 0);
}

void
m18x_cmmu_remote_set_sapr(cpu, ap)
	unsigned cpu, ap;
{
	if (cache_policy & CACHE_INH)
		ap |= AREA_D_CI;

	/*
	REGS(cpu, INST_CMMU).sapr = ap;
	REGS(cpu, DATA_CMMU).sapr = ap;
	*/
	m18x_cmmu_set(CMMU_SAPR, ap, ACCESS_VAL,
		      cpu, 0, CMMU_ACS_SUPER, 0);
}

void
m18x_cmmu_set_uapr(ap)
	unsigned ap;
{
	int cpu;
	cpu = cpu_number();

	/* this functionality also mimiced in m18x_cmmu_pmap_activate() */
	/*
	REGS(cpu, INST_CMMU).uapr = ap;
	REGS(cpu, DATA_CMMU).uapr = ap;
	*/
	m18x_cmmu_set(CMMU_UAPR, ap, ACCESS_VAL,
		      cpu, 0, CMMU_ACS_USER, 0);
}

/*
 * Set batc entry number entry_no to value in 
 * the data or instruction cache depending on data.
 *
 * Except for the cmmu_init, this function, m18x_cmmu_set_pair_batc_entry,
 * and m18x_cmmu_pmap_activate are the only functions which may set the
 * batc values.
 */
void
m18x_cmmu_set_batc_entry(cpu, entry_no, data, value)
	unsigned cpu, entry_no;
	unsigned data;	/* 1 = data, 0 = instruction */
	unsigned value;	/* the value to stuff into the batc */
{
	/*
	REGS(cpu,data).bwp[entry_no] = value;
	*/
	m18x_cmmu_set(CMMU_BWP(entry_no), value, MODE_VAL|ACCESS_VAL,
		      cpu, data, CMMU_ACS_USER, 0);
#ifdef SHADOW_BATC
	CMMU(cpu,data)->batc[entry_no] = value;
#endif
#if 0 /* was for debugging piece (peace?) of mind */
	REGS(cpu,data).scr = CMMU_FLUSH_SUPER_ALL;
	REGS(cpu,data).scr = CMMU_FLUSH_USER_ALL;
#endif
}

/*
 * Set batc entry number entry_no to value in 
 * the data and instruction cache for the named CPU.
 */
void
m18x_cmmu_set_pair_batc_entry(cpu, entry_no, value)
	unsigned cpu, entry_no;
	unsigned value;	/* the value to stuff into the batc */
{

	/*
	REGS(cpu,DATA_CMMU).bwp[entry_no] = value;
	*/
	m18x_cmmu_set(CMMU_BWP(entry_no), value, MODE_VAL|ACCESS_VAL,
		      cpu, DATA_CMMU, CMMU_ACS_USER, 0);
#ifdef SHADOW_BATC
	CMMU(cpu,DATA_CMMU)->batc[entry_no] = value;
#endif
	/*
	REGS(cpu,INST_CMMU).bwp[entry_no] = value;
	*/
	m18x_cmmu_set(CMMU_BWP(entry_no), value, MODE_VAL|ACCESS_VAL,
		      cpu, INST_CMMU, CMMU_ACS_USER, 0);
#ifdef SHADOW_BATC
	CMMU(cpu,INST_CMMU)->batc[entry_no] = value;
#endif

#if 0  /* was for debugging piece (peace?) of mind */
	REGS(cpu,INST_CMMU).scr = CMMU_FLUSH_SUPER_ALL;
	REGS(cpu,INST_CMMU).scr = CMMU_FLUSH_USER_ALL;
	REGS(cpu,DATA_CMMU).scr = CMMU_FLUSH_SUPER_ALL;
	REGS(cpu,DATA_CMMU).scr = CMMU_FLUSH_USER_ALL;
#endif
}

/*
 * Functions that invalidate TLB entries.
 */

/*
 *	flush any tlb
 *	Some functionality mimiced in m18x_cmmu_pmap_activate.
 */
void
m18x_cmmu_flush_remote_tlb(cpu, kernel, vaddr, size)
	unsigned cpu, kernel;
	vm_offset_t vaddr;
	int size;
{
	register int s = splhigh();

	if (cpu > max_cpus) {
		cpu = cpu_number();
	}

	if ((unsigned)size > PAGE_SIZE) {
		/*
		REGS(cpu, INST_CMMU).scr =
		REGS(cpu, DATA_CMMU).scr =
		kernel ? CMMU_FLUSH_SUPER_ALL : CMMU_FLUSH_USER_ALL;
		    */

		m18x_cmmu_set(CMMU_SCR, kernel ? CMMU_FLUSH_SUPER_ALL : CMMU_FLUSH_USER_ALL, ACCESS_VAL,
			      cpu, 0, kernel ? CMMU_ACS_SUPER : CMMU_ACS_USER, 0);
	} else { /* a page or smaller */
		/*
		REGS(cpu, INST_CMMU).sar = (unsigned)vaddr;
		REGS(cpu, DATA_CMMU).sar = (unsigned)vaddr;
		*/
		m18x_cmmu_set(CMMU_SAR, vaddr, ADDR_VAL|ACCESS_VAL,
			      cpu, 0, kernel ? CMMU_ACS_SUPER : CMMU_ACS_USER, vaddr);

		/*
		REGS(cpu, INST_CMMU).scr =
		REGS(cpu, DATA_CMMU).scr =
		kernel ? CMMU_FLUSH_SUPER_PAGE : CMMU_FLUSH_USER_PAGE;
		    */
		m18x_cmmu_set(CMMU_SCR, kernel ? CMMU_FLUSH_SUPER_PAGE : CMMU_FLUSH_USER_PAGE, ADDR_VAL|ACCESS_VAL,
			      cpu, 0, kernel ? CMMU_ACS_SUPER : CMMU_ACS_USER, vaddr);
	}

	splx(s);
}

/*
 *	flush my personal tlb
 */
void
m18x_cmmu_flush_tlb(kernel, vaddr, size)
	unsigned kernel;
	vm_offset_t vaddr;
	int size;
{
	int cpu;
	cpu = cpu_number();
	m18x_cmmu_flush_remote_tlb(cpu, kernel, vaddr, size);
}

/*
 * New fast stuff for pmap_activate.
 * Does what a few calls used to do.
 * Only called from pmap.c's _pmap_activate().
 */
void
m18x_cmmu_pmap_activate(cpu, uapr, i_batc, d_batc)
	unsigned cpu, uapr;
	batc_template_t i_batc[BATC_MAX];
	batc_template_t d_batc[BATC_MAX];
{
	int entry_no;


	/* the following is from m18x_cmmu_set_uapr */
	/*
	REGS(cpu, INST_CMMU).uapr = uapr;
	REGS(cpu, DATA_CMMU).uapr = uapr;
	*/
	m18x_cmmu_set(CMMU_UAPR, uapr, ACCESS_VAL,
		      cpu, 0, CMMU_ACS_USER, 0);

	for (entry_no = 0; entry_no < BATC_MAX; entry_no++) {
		/*
		REGS(cpu,INST_CMMU).bwp[entry_no] = i_batc[entry_no].bits;
		REGS(cpu,DATA_CMMU).bwp[entry_no] = d_batc[entry_no].bits;
		*/
		m18x_cmmu_set(CMMU_BWP(entry_no), i_batc[entry_no].bits, MODE_VAL|ACCESS_VAL,
			      cpu, INST_CMMU, CMMU_ACS_USER, 0);
		m18x_cmmu_set(CMMU_BWP(entry_no), d_batc[entry_no].bits, MODE_VAL|ACCESS_VAL,
			      cpu, DATA_CMMU, CMMU_ACS_USER, 0);
#ifdef SHADOW_BATC
		CMMU(cpu,INST_CMMU)->batc[entry_no] = i_batc[entry_no].bits;
		CMMU(cpu,DATA_CMMU)->batc[entry_no] = d_batc[entry_no].bits;
#endif
	}


	/*
	 * Flush the user TLB.
	 * IF THE KERNEL WILL EVER CARE ABOUT THE BATC ENTRIES,
	 * THE SUPERVISOR TLBs SHOULB EE FLUSHED AS WELL.
	 */
	/*
	REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_USER_ALL;
	REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_USER_ALL;
	*/
	m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_USER_ALL, ACCESS_VAL,
		      cpu, 0, CMMU_ACS_USER, 0);
}

/*
 * Functions that invalidate caches.
 *
 * Cache invalidates require physical addresses.  Care must be exercised when
 * using segment invalidates.  This implies that the starting physical address
 * plus the segment length should be invalidated.  A typical mistake is to
 * extract the first physical page of a segment from a virtual address, and
 * then expecting to invalidate when the pages are not physically contiguous.
 *
 * We don't push Instruction Caches prior to invalidate because they are not
 * snooped and never modified (I guess it doesn't matter then which form
 * of the command we use then).
 */

/*
 *	flush both Instruction and Data caches
 */
void
m18x_cmmu_flush_remote_cache(cpu, physaddr, size)
	int cpu;
	vm_offset_t physaddr;
	int size;
{
	register int s = splhigh();


#if !defined(BROKEN_MMU_MASK)

	if (size < 0 || size > NBSG ) {
		/*
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
		*/
		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, 0,
			      cpu, 0, 0, 0);
	} else if (size <= 16) {
		/*
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, ADDR_VAL,
			      cpu, 0, 0, (unsigned)physaddr);
		/*
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_LINE;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_LINE;
		*/
		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_LINE , ADDR_VAL,
			      cpu, 0, 0, (unsigned)physaddr);
	} else if (size <= NBPG) {
		/*
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, ADDR_VAL,
			      cpu, 0, 0, (unsigned)physaddr);
		/*
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_PAGE;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_PAGE;
		*/
		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_PAGE , ADDR_VAL,
			      cpu, 0, 0, (unsigned)physaddr);
	} else {
		/*
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, 0,
			      cpu, 0, 0, 0);
		/*
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_SEGMENT;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_SEGMENT;
		*/
		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_SEGMENT, 0,
			      cpu, 0, 0, 0);
	}

#else
	/*
	REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
	REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
	*/
	m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, 0,
		      cpu, 0, 0, 0);
#endif /* !BROKEN_MMU_MASK */
	splx(s);
}

/*
 *	flush both Instruction and Data caches
 */
void
m18x_cmmu_flush_cache(physaddr, size)
	vm_offset_t physaddr;
	int size;
{
	int cpu = cpu_number();
	m18x_cmmu_flush_remote_cache(cpu, physaddr, size);
}

/*
 *	flush Instruction caches
 */
void
m18x_cmmu_flush_remote_inst_cache(cpu, physaddr, size)
	int cpu;
	vm_offset_t physaddr;
	int size;
{
	register int s = splhigh();



#if !defined(BROKEN_MMU_MASK)
	if (size < 0 || size > NBSG ) {
		/*
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
		*/
		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
	} else if (size <= 16) {

		/*
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		/*
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_LINE;
		*/
		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_LINE, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
	} else if (size <= NBPG) {
		/*
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		/*
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_PAGE;
		*/
		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_PAGE, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
	} else {
		/*
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
		/*
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_SEGMENT;
		*/
		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_SEGMENT, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
	}
#else
	/*
	REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
	*/
	m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, MODE_VAL,
		      cpu, INST_CMMU, 0, 0);
#endif /* !BROKEN_MMU_MASK */

	splx(s);
}

/*
 *	flush Instruction caches
 */
void
m18x_cmmu_flush_inst_cache(physaddr, size)
	vm_offset_t physaddr;
	int size;
{
	int cpu;
	cpu = cpu_number();
	m18x_cmmu_flush_remote_inst_cache(cpu, physaddr, size);
}

void
m18x_cmmu_flush_remote_data_cache(cpu, physaddr, size)
	int cpu;
	vm_offset_t physaddr;
	int size;
{
	register int s = splhigh();

#if !defined(BROKEN_MMU_MASK)
	if (size < 0 || size > NBSG ) {

		/*
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
		*/
		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
	} else if (size <= 16) {
		/*
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_LINE;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_LINE, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);

	} else if (size <= NBPG) {
		/*
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_PAGE;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_PAGE, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
	} else {
		/*
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_SEGMENT;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_SEGMENT, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
	}
#else
	/*
	REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
	*/
	m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, MODE_VAL,
		      cpu, DATA_CMMU, 0, 0);
#endif /* !BROKEN_MMU_MASK */
	splx(s);
}

/*
 * flush data cache
 */ 
void
m18x_cmmu_flush_data_cache(physaddr, size)
	vm_offset_t physaddr;
	int size;
{ 
	int cpu;
	cpu = cpu_number();
	m18x_cmmu_flush_remote_data_cache(cpu, physaddr, size);
}

/*
 * sync dcache (and icache too)
 */
void
m18x_cmmu_sync_cache(physaddr, size)
	vm_offset_t physaddr;
	int size;
{
	register int s = splhigh();
	int cpu;
	cpu = cpu_number();

#if !defined(BROKEN_MMU_MASK)
	if (size < 0 || size > NBSG ) {
		/*
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CB_ALL;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CB_ALL;
		*/
		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CB_ALL, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CB_ALL, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
	} else if (size <= 16) {
		/*
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CB_LINE;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_LINE, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
		/*
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CB_LINE;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_LINE, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
	} else if (size <= NBPG) {
		/*
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CB_PAGE;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_PAGE, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
		/*
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CB_PAGE;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_PAGE, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
	} else {
		/*
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CB_SEGMENT;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_SEGMENT, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
		/*
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CB_SEGMENT;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_SEGMENT, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
	}
#else
	/*
	REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CB_ALL;
	REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CB_ALL;
	*/
	m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CB_ALL, MODE_VAL,
		      cpu, DATA_CMMU, 0, 0);
	m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CB_ALL, MODE_VAL,
		      cpu, INST_CMMU, 0, 0);
#endif /* !BROKEN_MMU_MASK */
	splx(s);
}

void 
m18x_cmmu_sync_inval_cache(physaddr, size)
	vm_offset_t physaddr;
	int size;
{
	register int s = splhigh();
	int cpu;
	cpu = cpu_number();

#if !defined(BROKEN_MMU_MASK)
	if (size < 0 || size > NBSG ) {
		/*
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
		*/
		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
	} else if (size <= 16) {
		/*
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_LINE;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_LINE, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
		/*
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_LINE;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_LINE, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
	} else if (size <= NBPG) {
		/*
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_PAGE;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_PAGE, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
		/*
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_PAGE;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_PAGE, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
	} else {
		/*
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_SEGMENT;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_SEGMENT, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
		/*
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_SEGMENT;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_SEGMENT, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
	}

#else
	/*
	REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
	REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
	*/
	m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, MODE_VAL,
		      cpu, DATA_CMMU, 0, 0);
	m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, MODE_VAL,
		      cpu, INST_CMMU, 0, 0);
#endif /* !BROKEN_MMU_MASK */
	splx(s);
}

void
m18x_cmmu_inval_cache(physaddr, size)
	vm_offset_t physaddr;
	int size;
{
	register int s = splhigh();
	int cpu;
	cpu = cpu_number();

#if !defined(BROKEN_MMU_MASK)
	if (size < 0 || size > NBSG ) {
		/*
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_INV_ALL;
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_INV_ALL;
		*/
		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_INV_ALL, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_INV_ALL, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
	} else if (size <= 16) {
		/*
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_INV_LINE;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_LINE, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
		/*
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_INV_LINE;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_LINE, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
	} else if (size <= NBPG) {
		/*
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_INV_PAGE;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_PAGE, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
		/*
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_INV_PAGE;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_PAGE, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
	} else {
		/*
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_INV_SEGMENT;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_SEGMENT, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
		/*
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_INV_SEGMENT;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_SEGMENT, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
	}
#else
	/*
	REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_INV_ALL;
	REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_INV_ALL;
	*/
	m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_INV_ALL, MODE_VAL,
		      cpu, DATA_CMMU, 0, 0);
	m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_INV_ALL, MODE_VAL,
		      cpu, INST_CMMU, 0, 0);
#endif /* !BROKEN_MMU_MASK */

	splx(s);
}

void
m18x_dma_cachectl(va, size, op)
	vm_offset_t va;
	int size, op;
{
#if !defined(BROKEN_MMU_MASK)
	int count;

	while (size) {
		count = NBPG - ((int)va & PGOFSET);

		if (size < count)
			count = size;

		if (op == DMA_CACHE_SYNC)
			m18x_cmmu_sync_cache(kvtop(va), count);
		else if (op == DMA_CACHE_SYNC_INVAL)
			m18x_cmmu_sync_inval_cache(kvtop(va), count);
		else
			m18x_cmmu_inval_cache(kvtop(va), count);

		va = (vm_offset_t)((int)va + count);
		size -= count;
	}
#else

	if (op == DMA_CACHE_SYNC)
		m18x_cmmu_sync_cache(kvtop(va), size);
	else if (op == DMA_CACHE_SYNC_INVAL)
		m18x_cmmu_sync_inval_cache(kvtop(va), size);
	else
		m18x_cmmu_inval_cache(kvtop(va), size);
#endif /* !BROKEN_MMU_MASK */
}

#ifdef DDB
union ssr {
   unsigned bits;
   struct {
      unsigned  :16,
      ce:1,
      be:1,
      :4,
      wt:1,
      sp:1,
      g:1,
      ci:1,
      :1,
      m:1,
      u:1,
      wp:1,
      bh:1,
      v:1;
   } field;
};

union cssp {
   unsigned bits;
   struct {
      unsigned   : 2,
      l: 6,
      d3: 1,
      d2: 1,
      d1: 1,
      d0: 1,
      vv3: 2,
      vv2: 2,
      vv1: 2,
      vv0: 2,
      :12;
   } field;
};

union batcu {
   unsigned bits;
   struct {              /* block address translation register */
      unsigned int
      lba:13,            /* logical block address */
      pba:13,            /* physical block address */
      s:1,               /* supervisor */
      wt:4,              /* write through */
      g:1,               /* global */
      ci:1,              /* cache inhibit */
      wp:1,              /* write protect */
      v:1;               /* valid */
   } field;
};

   #define VV_EX_UNMOD		0
   #define VV_EX_MOD		1
   #define VV_SHARED_UNMOD		2
   #define VV_INVALID		3

   #define D(UNION, LINE) \
	((LINE) == 3 ? (UNION).field.d3 : \
	 ((LINE) == 2 ? (UNION).field.d2 : \
	  ((LINE) == 1 ? (UNION).field.d1 : \
	   ((LINE) == 0 ? (UNION).field.d0 : ~0))))
   #define VV(UNION, LINE) \
	((LINE) == 3 ? (UNION).field.vv3 : \
	 ((LINE) == 2 ? (UNION).field.vv2 : \
	  ((LINE) == 1 ? (UNION).field.vv1 : \
	   ((LINE) == 0 ? (UNION).field.vv0 : ~0))))

   #undef VEQR_ADDR
   #define  VEQR_ADDR 0
/*
 * Show (for debugging) how the given CMMU translates the given ADDRESS.
 * If cmmu == -1, the data cmmu for the current cpu is used.
 */
void
m18x_cmmu_show_translation(address, supervisor_flag, verbose_flag, cmmu_num)
	unsigned address, supervisor_flag, verbose_flag;
	int cmmu_num;
{
	/*
	 * A virtual address is split into three fields. Two are used as
	 * indicies into tables (segment and page), and one is an offset into
	 * a page of memory.
	 */
	union {
		unsigned bits;
		struct {
			unsigned segment_table_index:10,
			page_table_index:10,
			page_offset:12;
		} field;
	} virtual_address;
	unsigned value;

	if (verbose_flag)
		DEBUG_MSG("-------------------------------------------\n");



	/****** ACCESS PROPER CMMU or THREAD ***********/
#if 0 /* no thread */
	if (thread != 0) {
		/* the following tidbit from _pmap_activate in m88k/pmap.c */
		register apr_template_t apr_data;
		supervisor_flag = 0; /* thread implies user */

		if (thread->task == 0) {
			DEBUG_MSG("[thread %x has empty task pointer]\n", thread);
			return;
		} else if (thread->task->map == 0) {
			DEBUG_MSG("[thread/task %x/%x has empty map pointer]\n",
				  thread, thread->task);
			return;
		} else if (thread->task->map->pmap == 0) {
			DEBUG_MSG("[thread/task/map %x/%x/%x has empty pmap pointer]\n",
				  thread, thread->task, thread->task->map);
			return;
		}
		if (thread->task->map->pmap->lock.lock_data) {
			DEBUG_MSG("[Warning: thread %x's task %x's map %x's "
				  "pmap %x is locked]\n", thread, thread->task,
				  thread->task->map, thread->task->map->pmap);
		}
		apr_data.bits = 0;
		apr_data.field.st_base = atop(thread->task->map->pmap->sdt_paddr);
		apr_data.field.wt = 0;
		apr_data.field.g  = 1;
		apr_data.field.ci = 0;
		apr_data.field.te = 1;
		value = apr_data.bits;
		if (verbose_flag) {
			DEBUG_MSG("[thread %x task %x map %x pmap %x UAPR is %x]\n",
				  thread, thread->task, thread->task->map,
				  thread->task->map->pmap, value);
		}
	} else
#endif /* 0 */
	{
		if (cmmu_num == -1) {
			int cpu = cpu_number();
			if (cpu_cmmu[cpu].pair[DATA_CMMU] == 0) {
				DEBUG_MSG("ack! can't figure my own data cmmu number.\n");
				return;
			}
			cmmu_num = cpu_cmmu[cpu].pair[DATA_CMMU] - cmmu;
			if (verbose_flag)
				DEBUG_MSG("The data cmmu for cpu#%d is cmmu#%d.\n",
					  0, cmmu_num);
		} else if (cmmu_num < 0 || cmmu_num >= MAX_CMMUS) {
			DEBUG_MSG("invalid cpu number [%d]... must be in range [0..%d]\n",
				  cmmu_num, MAX_CMMUS - 1);

			return;
		}

		if (cmmu[cmmu_num].cmmu_alive == 0) {
			DEBUG_MSG("warning: cmmu %d is not alive.\n", cmmu_num);
#if 0
			return;
#endif
		}

		if (!verbose_flag) {
			if (!(cmmu[cmmu_num].cmmu_regs->sctr & CMMU_SCTR_SE))
				DEBUG_MSG("WARNING: snooping not enabled for CMMU#%d.\n",
					  cmmu_num);
		} else {
			int i;
			for (i=0; i<MAX_CMMUS; i++)
				if ((i == cmmu_num || cmmu[i].cmmu_alive) &&
				    (verbose_flag>1 || !(cmmu[i].cmmu_regs->sctr&CMMU_SCTR_SE))) {
					DEBUG_MSG("CMMU#%d (cpu %d %s) snooping %s\n", i,
						  cmmu[i].cmmu_cpu, cmmu[i].which ? "data" : "inst",
						  (cmmu[i].cmmu_regs->sctr & CMMU_SCTR_SE) ? "on":"OFF");
				}
		}

		if (supervisor_flag)
			value = cmmu[cmmu_num].cmmu_regs->sapr;
		else
			value = cmmu[cmmu_num].cmmu_regs->uapr;

	}

	/******* LOOK AT THE BATC ** (if not a thread) **************/
#if 0
#ifdef SHADOW_BATC
	if (thread == 0) {
		int i;
		union batcu batc;
		for (i = 0; i < 8; i++) {
			batc.bits = cmmu[cmmu_num].batc[i];
			if (batc.field.v == 0) {
				if (verbose_flag>1)
					DEBUG_MSG("cmmu #%d batc[%d] invalid.\n", cmmu_num, i);
			} else {
				DEBUG_MSG("cmmu#%d batc[%d] v%08x p%08x", cmmu_num, i,
					  batc.field.lba << 18, batc.field.pba);
				if (batc.field.s)  DEBUG_MSG(", supervisor");
				if (batc.field.wt) DEBUG_MSG(", wt.th");
				if (batc.field.g)  DEBUG_MSG(", global");
				if (batc.field.ci) DEBUG_MSG(", cache inhibit");
				if (batc.field.wp) DEBUG_MSG(", write protect");
			}
		}
	}
#endif	/* SHADOW_BATC */
#endif	/* 0 */

	/******* SEE WHAT A PROBE SAYS (if not a thread) ***********/
#if 0
	if (thread == 0)
#endif /* 0 */
	{
		union ssr ssr;
		struct cmmu_regs *cmmu_regs = cmmu[cmmu_num].cmmu_regs;
		cmmu_regs->sar = address;
		cmmu_regs->scr = supervisor_flag ? CMMU_PROBE_SUPER : CMMU_PROBE_USER;
		ssr.bits = cmmu_regs->ssr;
		if (verbose_flag > 1)
			DEBUG_MSG("probe of 0x%08x returns ssr=0x%08x\n",
				  address, ssr.bits);
		if (ssr.field.v)
			DEBUG_MSG("PROBE of 0x%08x returns phys=0x%x",
				  address, cmmu_regs->sar);
		else
			DEBUG_MSG("PROBE fault at 0x%x", cmmu_regs->pfADDRr);
		if (ssr.field.ce) DEBUG_MSG(", copyback err");
		if (ssr.field.be) DEBUG_MSG(", bus err");
		if (ssr.field.wt) DEBUG_MSG(", writethrough");
		if (ssr.field.sp) DEBUG_MSG(", sup prot");
		if (ssr.field.g)  DEBUG_MSG(", global");
		if (ssr.field.ci) DEBUG_MSG(", cache inhibit");
		if (ssr.field.m)  DEBUG_MSG(", modified");
		if (ssr.field.u)  DEBUG_MSG(", used");
		if (ssr.field.wp) DEBUG_MSG(", write prot");
		if (ssr.field.bh) DEBUG_MSG(", BATC");
		DEBUG_MSG(".\n");
	}

	/******* INTERPRET AREA DESCRIPTOR *********/
	{
		union apr_template apr_template;
		apr_template.bits = value;
		if (verbose_flag > 1) {
			DEBUG_MSG("CMMU#%d", cmmu_num);
#if 0
			if (thread == 0)
				DEBUG_MSG("CMMU#%d", cmmu_num);
			else
				DEBUG_MSG("THREAD %x", thread);
#endif /* 0 */
			DEBUG_MSG(" %cAPR is 0x%08x\n",
				  supervisor_flag ? 'S' : 'U', apr_template.bits);
		}
		DEBUG_MSG("CMMU#%d", cmmu_num);
#if 0
		if (thread == 0)
			DEBUG_MSG("CMMU#%d", cmmu_num);
		else
			DEBUG_MSG("THREAD %x", thread);
#endif /* 0 */
		DEBUG_MSG(" %cAPR: SegTbl: 0x%x000p",
			  supervisor_flag ? 'S' : 'U', apr_template.field.st_base);
		if (apr_template.field.wt) DEBUG_MSG(", WTHRU");
		else			   DEBUG_MSG(", !wthru");
		if (apr_template.field.g)  DEBUG_MSG(", GLOBAL");
		else			   DEBUG_MSG(", !global");
		if (apr_template.field.ci) DEBUG_MSG(", $INHIBIT");
		else			   DEBUG_MSG(", $ok");
		if (apr_template.field.te) DEBUG_MSG(", VALID");
		else			   DEBUG_MSG(", !valid");
		DEBUG_MSG(".\n");

		/* if not valid, done now */
		if (apr_template.field.te == 0) {
			DEBUG_MSG("<would report an error, valid bit not set>\n");

			return;
		}

		value = apr_template.field.st_base << 12; /* now point to seg page */
	}

	/* translate value from physical to virtual */
	if (verbose_flag)
		DEBUG_MSG("[%x physical is %x virtual]\n", value, value + VEQR_ADDR);
	value += VEQR_ADDR;

	virtual_address.bits = address;

	/****** ACCESS SEGMENT TABLE AND INTERPRET SEGMENT DESCRIPTOR  *******/
	{
		union sdt_entry_template std_template;
		if (verbose_flag)
			DEBUG_MSG("will follow to entry %d of page at 0x%x...\n",
				  virtual_address.field.segment_table_index, value);
		value |= virtual_address.field.segment_table_index *
			 sizeof(struct sdt_entry);

		if (badwordaddr((vm_offset_t)value)) {
			DEBUG_MSG("ERROR: unable to access page at 0x%08x.\n", value);

			return;
		}

		std_template.bits = *(unsigned *)value;
		if (verbose_flag > 1)
			DEBUG_MSG("SEG DESC @@0x%x is 0x%08x\n", value, std_template.bits);
		DEBUG_MSG("SEG DESC @@0x%x: PgTbl: 0x%x000",
			  value, std_template.sdt_desc.table_addr);
		if (std_template.sdt_desc.wt)	    DEBUG_MSG(", WTHRU");
		else				    DEBUG_MSG(", !wthru");
		if (std_template.sdt_desc.sup)	    DEBUG_MSG(", S-PROT");
		else				    DEBUG_MSG(", UserOk");
		if (std_template.sdt_desc.g)	    DEBUG_MSG(", GLOBAL");
		else				    DEBUG_MSG(", !global");
		if (std_template.sdt_desc.no_cache) DEBUG_MSG(", $INHIBIT");
		else				    DEBUG_MSG(", $ok");
		if (std_template.sdt_desc.prot)	    DEBUG_MSG(", W-PROT");
		else				    DEBUG_MSG(", WriteOk");
		if (std_template.sdt_desc.dtype)    DEBUG_MSG(", VALID");
		else				    DEBUG_MSG(", !valid");
		DEBUG_MSG(".\n");

		/* if not valid, done now */
		if (std_template.sdt_desc.dtype == 0) {
			DEBUG_MSG("<would report an error, STD entry not valid>\n");

			return;
		}

		value = std_template.sdt_desc.table_addr << 12;
	}

	/* translate value from physical to virtual */
	if (verbose_flag)
		DEBUG_MSG("[%x physical is %x virtual]\n", value, value + VEQR_ADDR);
	value += VEQR_ADDR;

	/******* PAGE TABLE *********/
	{
		union pte_template pte_template;
		if (verbose_flag)
			DEBUG_MSG("will follow to entry %d of page at 0x%x...\n",
				  virtual_address.field.page_table_index, value);
		value |= virtual_address.field.page_table_index *
			 sizeof(struct pt_entry);

		if (badwordaddr((vm_offset_t)value)) {
			DEBUG_MSG("error: unable to access page at 0x%08x.\n", value);

			return;
		}

		pte_template.bits = *(unsigned *)value;
		if (verbose_flag > 1)
			DEBUG_MSG("PAGE DESC @@0x%x is 0x%08x.\n", value, pte_template.bits);
		DEBUG_MSG("PAGE DESC @@0x%x: page @@%x000",
			  value, pte_template.pte.pfn);
		if (pte_template.pte.wired)    DEBUG_MSG(", WIRE");
		else			       DEBUG_MSG(", !wire");
		if (pte_template.pte.wt)       DEBUG_MSG(", WTHRU");
		else			       DEBUG_MSG(", !wthru");
		if (pte_template.pte.sup)      DEBUG_MSG(", S-PROT");
		else			       DEBUG_MSG(", UserOk");
		if (pte_template.pte.g)	       DEBUG_MSG(", GLOBAL");
		else			       DEBUG_MSG(", !global");
		if (pte_template.pte.ci)       DEBUG_MSG(", $INHIBIT");
		else			       DEBUG_MSG(", $ok");
		if (pte_template.pte.modified) DEBUG_MSG(", MOD");
		else			       DEBUG_MSG(", !mod");
		if (pte_template.pte.pg_used)  DEBUG_MSG(", USED");
		else			       DEBUG_MSG(", !used");
		if (pte_template.pte.prot)     DEBUG_MSG(", W-PROT");
		else			       DEBUG_MSG(", WriteOk");
		if (pte_template.pte.dtype)    DEBUG_MSG(", VALID");
		else			       DEBUG_MSG(", !valid");
		DEBUG_MSG(".\n");

		/* if not valid, done now */
		if (pte_template.pte.dtype == 0) {
			DEBUG_MSG("<would report an error, PTE entry not valid>\n");

			return;
		}

		value = pte_template.pte.pfn << 12;
		if (verbose_flag)
			DEBUG_MSG("will follow to byte %d of page at 0x%x...\n",
				  virtual_address.field.page_offset, value);
		value |= virtual_address.field.page_offset;

		if (badwordaddr((vm_offset_t)value)) {
			DEBUG_MSG("error: unable to access page at 0x%08x.\n", value);

			return;
		}
	}

	/* translate value from physical to virtual */
	if (verbose_flag)
		DEBUG_MSG("[%x physical is %x virtual]\n", value, value + VEQR_ADDR);
	value += VEQR_ADDR;

	DEBUG_MSG("WORD at 0x%x is 0x%08x.\n", value, *(unsigned *)value);

}

void
m18x_cmmu_cache_state(addr, supervisor_flag)
	unsigned addr, supervisor_flag;
{
	static char *vv_name[4] =
	{"exclu-unmod", "exclu-mod", "shared-unmod", "invalid"};
	int cmmu_num;

	for (cmmu_num = 0; cmmu_num < MAX_CMMUS; cmmu_num++) {
		union ssr ssr;
		union cssp cssp;
		struct cmmu_regs *R;
		unsigned tag, line;
		if (!cmmu[cmmu_num].cmmu_alive)
			continue;
		R = cmmu[cmmu_num].cmmu_regs;
		DEBUG_MSG("cmmu #%d %s cmmu for cpu %d.\n", cmmu_num,
			  cmmu[cmmu_num].which ? "data" : "inst", 
			  cmmu[cmmu_num].cmmu_cpu);
		R->sar = addr;
		R->scr = supervisor_flag ? CMMU_PROBE_SUPER : CMMU_PROBE_USER;

		ssr.bits = R->ssr;
		if (!ssr.field.v) {
			DEBUG_MSG("PROBE of 0x%08x faults.\n",addr);
			continue;
		}
		DEBUG_MSG("PROBE of 0x%08x returns phys=0x%x", addr, R->sar);

		tag = R->sar & ~0xfff;
		cssp.bits = R->cssp;

		/* check to see if any of the tags for the set match the address */
		for (line = 0; line < 4; line++) {
			if (VV(cssp, line) == VV_INVALID) {
				DEBUG_MSG("line %d invalid.\n", line);
				continue; /* line is invalid */
			}
			if (D(cssp, line)) {
				DEBUG_MSG("line %d disabled.\n", line);
				continue; /* line is disabled */
			}

			if ((R->ctp[line] & ~0xfff) != tag) {
				DEBUG_MSG("line %d address tag is %x.\n", line,
					  (R->ctp[line] & ~0xfff));
				continue;
			}
			DEBUG_MSG("found in line %d as %08x (%s).\n",
				  line, R->cdp[line], vv_name[VV(cssp, line)]);
		}
	}

}

void
m18x_show_cmmu_info(addr)
	unsigned addr;
{
	int cmmu_num;
	m18x_cmmu_cache_state(addr, 1);

	for (cmmu_num = 0; cmmu_num < MAX_CMMUS; cmmu_num++)
		if (cmmu[cmmu_num].cmmu_alive) {
			DEBUG_MSG("cmmu #%d %s cmmu for cpu %d: ", cmmu_num,
				  cmmu[cmmu_num].which ? "data" : "inst", 
				  cmmu[cmmu_num].cmmu_cpu);
			m18x_cmmu_show_translation(addr, 1, 0, cmmu_num);
		}
}

#endif /* DDB */
@


1.18
log
@rename m882xx.h to m8820x.h
@
text
@d1 1
a1 1
/*	$OpenBSD: m18x_cmmu.c,v 1.16 2001/12/16 23:49:46 miod Exp $	*/
@


1.17
log
@Introduce brdtyp and change what cputyp means.
@
text
@d71 1
a71 1
#include <machine/m882xx.h>
@


1.16
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: m18x_cmmu.c,v 1.14 2001/08/31 01:52:22 miod Exp $	*/
d343 1
a343 1
	switch (cputyp) {
d345 1
a345 1
	case CPU_187:
d362 1
a362 1
	case CPU_188:
d418 1
a418 1
			if (id.m88200.type != M88200 && id.m88200.type != M88204) {
d447 1
a447 1
		if (id.m88200.type == M88204)
d624 1
a624 1
	switch (cputyp) {
d626 1
a626 1
	case CPU_187:
d630 1
a630 1
	case CPU_188:
d836 1
a836 1
			if (id.m88200.type == M88204) {
d906 1
a906 1
		if (cputyp == CPU_188) {
d970 1
a970 1
		if (cputyp == CPU_188) {
@


1.15
log
@Support for MVME197 completed.  Fix SPL defs.
@
text
@@


1.14
log
@Assorted changes to really let non-DDB kernels (such as the future RAMDISK,
hint, hint) compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: m18x_cmmu.c,v 1.13 2001/08/26 14:31:12 miod Exp $	*/
@


1.13
log
@Add prototypes, fix compilation warnings, random style fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: m18x_cmmu.c,v 1.12 2001/08/24 22:48:26 miod Exp $	*/
a2321 2
#endif /* DDB */

d2337 2
@


1.12
log
@Grandma always told me, initialize your variables before you print their
values, you damn kid!
@
text
@d1 1
a1 1
/*	$OpenBSD: m18x_cmmu.c,v 1.11 2001/08/24 19:26:15 miod Exp $	*/
d190 2
d288 1
a288 2
} bd_config[] =
{
d312 1
a312 2
struct cmmu cmmu[MAX_CMMUS] =
{
a370 2
	default:
		panic("m18x_setup_board_config: Unknown CPU type.");
a649 2
	default:
		DEBUG_MSG("Unknown CPU\n\n");
d654 1
a654 1
static void 
d659 1
a659 1
	*(volatile unsigned *)(reg + (char*)(cmmu[mmu].cmmu_regs)) = val;
@


1.11
log
@No newline at the end of panic messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: m18x_cmmu.c,v 1.10 2001/08/11 01:55:55 miod Exp $	*/
a632 1
		DEBUG_MSG("VME188 address decoder: PCNFA = 0x%1x, PCNFB = 0x%1x\n\n", *pcnfa & 0xf, *pcnfb & 0xf);
d635 1
@


1.10
log
@Include files serve a purpose. Move lots of extern statements from
foo_cmmu.c to cmmu.h ; also don't check for 197 in m18x_cmmu.c, as this
code is 18x specific.
@
text
@d1 1
a1 1
/*	$OpenBSD: m18x_cmmu.c,v 1.9 2001/06/14 21:30:45 miod Exp $	*/
d379 1
a379 1
		panic("This configuration is not supported - go and get another OS.\n");
d388 1
a388 1
		panic("UNKNOWN MVME%x board configuration: WHOAMI = 0x%02x\n", cputyp, *whoami);
@


1.9
log
@Big cleanup of VM issues:
o get rid of m88k_foo macros when there is an mi foo macro
o remove the ability, for the pmap module, to handle a native mmu page
  size different from the vm module page size. This allows some
  optimizations in pmap.c
o remove dead stuff from <machine/vmparam.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: m18x_cmmu.c,v 1.8 2001/03/18 01:49:39 miod Exp $	*/
a174 7
extern unsigned cache_policy;
extern unsigned cpu_sets[];
extern unsigned number_cpus;
extern unsigned master_cpu;
extern int      max_cpus, max_cmmus;
extern int      cpu_cmmu_ratio;

a345 5
#endif
#ifdef MVME197
	case CPU_197:
#endif
#if defined(MVME187) || defined(MVME197)
d360 1
a360 1
#endif /* defined(MVME187) || defined(MVME197) */
a628 5
#endif
#ifdef MVME197
	case CPU_197:
#endif
#if defined(MVME187) || defined(MVME197)
d630 1
a630 1
#endif /* defined(MVME187) || defined(MVME197) */
@


1.8
log
@Remove badwordaddr() prototype, cleanup, #if -> #ifdef police.
@
text
@d1 1
a1 1
/*	$OpenBSD: m18x_cmmu.c,v 1.7 2001/03/09 05:44:41 smurph Exp $	*/
d1246 1
a1246 1
	if ((unsigned)size > M88K_PGBYTES) {
d2003 1
a2003 1
		apr_data.field.st_base = M88K_BTOP(thread->task->map->pmap->sdt_paddr);
@


1.7
log
@kernel will compile with -Werror.  Added intr.h
@
text
@d1 1
a1 1
/*	$OpenBSD: m18x_cmmu.c,v 1.6 2001/03/08 00:03:31 miod Exp $	*/
d65 1
d73 2
a74 2
#if DDB
   #include <ddb/db_output.h>		/* db_printf()		*/
d77 2
a78 2
#if DDB
   #define DEBUG_MSG db_printf
d80 1
a80 1
   #define DEBUG_MSG printf
d86 1
a86 1
#define CMMU_DEBUG 1
d89 1
a89 1
   #define DB_CMMU	0x4000	/* MMU debug */
d91 9
a99 1
   #define dprintf(_L_,_X_) { if (m18x_debuglevel & (_L_)) { unsigned int psr = disable_interrupts_return_psr(); printf("%d: ", cpu_number()); printf _X_;  set_psr(psr); } }
d101 1
a101 1
   #define dprintf(_L_,_X_)
a104 2
int badwordaddr __P((void *addr));

d149 1
a149 1
#if SHADOW_BATC
d184 13
a196 3
/* FORWARDS */
void m18x_setup_cmmu_config(void);
void m18x_setup_board_config(void);
d200 2
a201 1
m18x_show_apr(unsigned value)
d216 2
a217 1
m18x_show_sctr(unsigned value)
d345 1
a345 1
m18x_setup_board_config(void)
d412 1
a412 1
m18x_setup_cmmu_config(void)
d428 1
a428 1
		if (!badwordaddr((void *)cmmu[cmmu_num].cmmu_regs)) {
d628 1
a628 1
m18x_cmmu_dump_config(void)
d676 3
a678 1
m18x_cmmu_store(int mmu, int reg, unsigned val)
d684 2
a685 1
m18x_cmmu_alive(int mmu)
d691 2
a692 1
m18x_cmmu_get(int mmu, int reg)
d702 5
a706 2
m18x_cmmu_set(int reg, unsigned val, int flags,
	      int num, int mode, int access, vm_offset_t addr)
d747 2
a748 1
m18x_cmmu_get_by_mode(int cpu, int mode)
d780 2
a781 1
m18x_cpu_configuration_print(int master)
d801 1
a801 1
#if ERRATA__XXX_USR == 0
d831 1
a831 1
m18x_cmmu_init(void)
d892 1
a892 1
#if SHADOW_BATC
d982 1
a982 1
m18x_cmmu_shutdown_now(void)
d1021 1
a1021 1
m18x_cmmu_parity_enable(void)
d1023 1
a1023 1
#ifdef	PARITY_ENABLE
d1049 1
a1049 1
m18x_cmmu_cpu_number(void)
d1064 1
a1064 1
		badwordaddr((void *)ILLADDRESS);
d1083 3
a1085 3
/**
 **	Funcitons that actually modify CMMU registers.
 **/
a1086 3
#if !DDB
static
#endif
d1088 2
a1089 1
m18x_cmmu_remote_set(unsigned cpu, unsigned r, unsigned data, unsigned x)
a1097 3
#if !DDB
static
#endif
d1099 2
a1100 1
m18x_cmmu_remote_get(unsigned cpu, unsigned r, unsigned data)
d1107 2
a1108 1
m18x_cmmu_get_idr(unsigned data)
d1116 2
a1117 1
m18x_cmmu_set_sapr(unsigned ap)
d1133 2
a1134 1
m18x_cmmu_remote_set_sapr(unsigned cpu, unsigned ap)
d1148 2
a1149 1
m18x_cmmu_set_uapr(unsigned ap)
d1172 4
a1175 4
m18x_cmmu_set_batc_entry(unsigned cpu,
			 unsigned entry_no,
			 unsigned data,	  /* 1 = data, 0 = instruction */
			 unsigned value)  /* the value to stuff into the batc */
d1182 1
a1182 1
#if SHADOW_BATC
d1196 3
a1198 3
m18x_cmmu_set_pair_batc_entry(unsigned cpu, 
			      unsigned entry_no,
			      unsigned value)  /* the value to stuff into the batc */
d1206 1
a1206 1
#if SHADOW_BATC
d1214 1
a1214 1
#if SHADOW_BATC
d1226 3
a1228 3
/**
 **	Functions that invalidate TLB entries.
 **/
d1235 4
a1238 1
m18x_cmmu_flush_remote_tlb(unsigned cpu, unsigned kernel, vm_offset_t vaddr, int size)
d1279 4
a1282 1
m18x_cmmu_flush_tlb(unsigned kernel, vm_offset_t vaddr, int size)
d1295 4
a1298 4
m18x_cmmu_pmap_activate(unsigned cpu,
			unsigned uapr,
			batc_template_t i_batc[BATC_MAX],
			batc_template_t d_batc[BATC_MAX])
d1320 1
a1320 1
#if SHADOW_BATC
d1340 14
a1353 13
/**
 **	Functions that invalidate caches.
 **
 ** Cache invalidates require physical addresses.  Care must be exercised when
 ** using segment invalidates.  This implies that the starting physical address
 ** plus the segment length should be invalidated.  A typical mistake is to
 ** extract the first physical page of a segment from a virtual address, and
 ** then expecting to invalidate when the pages are not physically contiguous.
 **
 ** We don't push Instruction Caches prior to invalidate because they are not
 ** snooped and never modified (I guess it doesn't matter then which form
 ** of the command we use then).
 **/
d1358 4
a1361 1
m18x_cmmu_flush_remote_cache(int cpu, vm_offset_t physaddr, int size)
d1431 3
a1433 1
m18x_cmmu_flush_cache(vm_offset_t physaddr, int size)
d1443 4
a1446 1
m18x_cmmu_flush_remote_inst_cache(int cpu, vm_offset_t physaddr, int size)
d1509 3
a1511 1
m18x_cmmu_flush_inst_cache(vm_offset_t physaddr, int size)
d1519 5
a1523 2
m18x_cmmu_flush_remote_data_cache(int cpu, vm_offset_t physaddr, int size)
{ 
d1577 3
a1579 1
m18x_cmmu_flush_data_cache(vm_offset_t physaddr, int size)
d1590 3
a1592 1
m18x_cmmu_sync_cache(vm_offset_t physaddr, int size)
d1673 4
a1676 2
void
m18x_cmmu_sync_inval_cache(vm_offset_t physaddr, int size)
d1759 3
a1761 1
m18x_cmmu_inval_cache(vm_offset_t physaddr, int size)
d1844 3
a1846 1
m18x_dma_cachectl(vm_offset_t va, int size, int op)
d1878 1
a1878 1
#if DDB
d1954 3
a1956 5
m18x_cmmu_show_translation(
                     unsigned address,
                     unsigned supervisor_flag,
                     unsigned verbose_flag,
                     int cmmu_num)
d2065 1
a2065 1
#if SHADOW_BATC
d2179 1
a2179 1
		if (badwordaddr((void *)value)) {
d2228 1
a2228 1
		if (badwordaddr((void *)value)) {
d2272 1
a2272 1
		if (badwordaddr((void *)value)) {
d2289 2
a2290 1
m18x_cmmu_cache_state(unsigned addr, unsigned supervisor_flag)
d2343 2
d2346 2
a2347 2
#endif /* end if DDB */
m18x_show_cmmu_info(unsigned addr)
@


1.6
log
@Some warning hunting.
@
text
@d1 1
a1 1
/*	$OpenBSD: m18x_cmmu.c,v 1.5 2001/02/01 03:38:20 smurph Exp $	*/
d63 1
d69 1
d72 10
d96 2
d395 3
d400 1
a400 2

	register int num, cmmu_num, val1, val2;
d409 1
a409 1
		if (!badwordaddr((vm_offset_t)cmmu[cmmu_num].cmmu_regs)) {
d599 1
d606 1
d611 1
a611 1

d615 1
d617 1
a617 3
	if (cputyp != CPU_188) return;

	db_printf("Current CPU/CMMU configuration:\n\n");
d627 1
a627 1
		db_printf("VME1x7 split mode\n\n");
d631 1
a631 1
		db_printf("VME188 address decoder: PCNFA = 0x%1x, PCNFB = 0x%1x\n\n", *pcnfa & 0xf, *pcnfb & 0xf);
d635 1
a635 1
			db_printf("CMMU #%d: %s CMMU for CPU %d:\n Strategy: %s\n %s access addr 0x%08x mask 0x%08x match %s\n",
d651 1
a651 1
		db_printf("Unknown CPU\n\n");
d732 1
d1918 1
a1918 1
		db_printf("-------------------------------------------\n");
d1930 1
a1930 1
			db_printf("[thread %x has empty task pointer]\n", thread);
d1933 1
a1933 1
			db_printf("[thread/task %x/%x has empty map pointer]\n",
d1937 1
a1937 1
			db_printf("[thread/task/map %x/%x/%x has empty pmap pointer]\n",
d1942 1
a1942 1
			db_printf("[Warning: thread %x's task %x's map %x's "
d1954 1
a1954 1
			db_printf("[thread %x task %x map %x pmap %x UAPR is %x]\n",
d1964 1
a1964 1
				db_printf("ack! can't figure my own data cmmu number.\n");
d1969 1
a1969 1
				db_printf("The data cmmu for cpu#%d is cmmu#%d.\n",
d1972 1
a1972 1
			db_printf("invalid cpu number [%d]... must be in range [0..%d]\n",
d1979 1
a1979 1
			db_printf("warning: cmmu %d is not alive.\n", cmmu_num);
d1987 1
a1987 1
				db_printf("WARNING: snooping not enabled for CMMU#%d.\n",
d1994 1
a1994 1
					db_printf("CMMU#%d (cpu %d %s) snooping %s\n", i,
d2017 1
a2017 1
					db_printf("cmmu #%d batc[%d] invalid.\n", cmmu_num, i);
d2019 1
a2019 1
				db_printf("cmmu#%d batc[%d] v%08x p%08x", cmmu_num, i,
d2021 5
a2025 5
				if (batc.field.s)  db_printf(", supervisor");
				if (batc.field.wt) db_printf(", wt.th");
				if (batc.field.g)  db_printf(", global");
				if (batc.field.ci) db_printf(", cache inhibit");
				if (batc.field.wp) db_printf(", write protect");
d2043 1
a2043 1
			db_printf("probe of 0x%08x returns ssr=0x%08x\n",
d2046 1
a2046 1
			db_printf("PROBE of 0x%08x returns phys=0x%x",
d2049 12
a2060 12
			db_printf("PROBE fault at 0x%x", cmmu_regs->pfADDRr);
		if (ssr.field.ce) db_printf(", copyback err");
		if (ssr.field.be) db_printf(", bus err");
		if (ssr.field.wt) db_printf(", writethrough");
		if (ssr.field.sp) db_printf(", sup prot");
		if (ssr.field.g)  db_printf(", global");
		if (ssr.field.ci) db_printf(", cache inhibit");
		if (ssr.field.m)  db_printf(", modified");
		if (ssr.field.u)  db_printf(", used");
		if (ssr.field.wp) db_printf(", write prot");
		if (ssr.field.bh) db_printf(", BATC");
		db_printf(".\n");
d2068 1
a2068 1
			db_printf("CMMU#%d", cmmu_num);
d2071 1
a2071 1
				db_printf("CMMU#%d", cmmu_num);
d2073 1
a2073 1
				db_printf("THREAD %x", thread);
d2075 1
a2075 1
			db_printf(" %cAPR is 0x%08x\n",
d2078 1
a2078 1
		db_printf("CMMU#%d", cmmu_num);
d2081 1
a2081 1
			db_printf("CMMU#%d", cmmu_num);
d2083 1
a2083 1
			db_printf("THREAD %x", thread);
d2085 1
a2085 1
		db_printf(" %cAPR: SegTbl: 0x%x000p",
d2087 9
a2095 9
		if (apr_template.field.wt) db_printf(", WTHRU");
		else			   db_printf(", !wthru");
		if (apr_template.field.g)  db_printf(", GLOBAL");
		else			   db_printf(", !global");
		if (apr_template.field.ci) db_printf(", $INHIBIT");
		else			   db_printf(", $ok");
		if (apr_template.field.te) db_printf(", VALID");
		else			   db_printf(", !valid");
		db_printf(".\n");
d2099 1
a2099 1
			db_printf("<would report an error, valid bit not set>\n");
d2109 1
a2109 1
		db_printf("[%x physical is %x virtual]\n", value, value + VEQR_ADDR);
d2118 1
a2118 1
			db_printf("will follow to entry %d of page at 0x%x...\n",
d2123 2
a2124 2
		if (badwordaddr(value)) {
			db_printf("ERROR: unable to access page at 0x%08x.\n", value);
d2131 2
a2132 2
			db_printf("SEG DESC @@0x%x is 0x%08x\n", value, std_template.bits);
		db_printf("SEG DESC @@0x%x: PgTbl: 0x%x000",
d2134 13
a2146 13
		if (std_template.sdt_desc.wt)	    db_printf(", WTHRU");
		else				    db_printf(", !wthru");
		if (std_template.sdt_desc.sup)	    db_printf(", S-PROT");
		else				    db_printf(", UserOk");
		if (std_template.sdt_desc.g)	    db_printf(", GLOBAL");
		else				    db_printf(", !global");
		if (std_template.sdt_desc.no_cache) db_printf(", $INHIBIT");
		else				    db_printf(", $ok");
		if (std_template.sdt_desc.prot)	    db_printf(", W-PROT");
		else				    db_printf(", WriteOk");
		if (std_template.sdt_desc.dtype)    db_printf(", VALID");
		else				    db_printf(", !valid");
		db_printf(".\n");
d2150 1
a2150 1
			db_printf("<would report an error, STD entry not valid>\n");
d2160 1
a2160 1
		db_printf("[%x physical is %x virtual]\n", value, value + VEQR_ADDR);
d2167 1
a2167 1
			db_printf("will follow to entry %d of page at 0x%x...\n",
d2172 2
a2173 2
		if (badwordaddr(value)) {
			db_printf("error: unable to access page at 0x%08x.\n", value);
d2180 2
a2181 2
			db_printf("PAGE DESC @@0x%x is 0x%08x.\n", value, pte_template.bits);
		db_printf("PAGE DESC @@0x%x: page @@%x000",
d2183 19
a2201 19
		if (pte_template.pte.wired)    db_printf(", WIRE");
		else			       db_printf(", !wire");
		if (pte_template.pte.wt)       db_printf(", WTHRU");
		else			       db_printf(", !wthru");
		if (pte_template.pte.sup)      db_printf(", S-PROT");
		else			       db_printf(", UserOk");
		if (pte_template.pte.g)	       db_printf(", GLOBAL");
		else			       db_printf(", !global");
		if (pte_template.pte.ci)       db_printf(", $INHIBIT");
		else			       db_printf(", $ok");
		if (pte_template.pte.modified) db_printf(", MOD");
		else			       db_printf(", !mod");
		if (pte_template.pte.pg_used)  db_printf(", USED");
		else			       db_printf(", !used");
		if (pte_template.pte.prot)     db_printf(", W-PROT");
		else			       db_printf(", WriteOk");
		if (pte_template.pte.dtype)    db_printf(", VALID");
		else			       db_printf(", !valid");
		db_printf(".\n");
d2205 1
a2205 1
			db_printf("<would report an error, PTE entry not valid>\n");
d2212 1
a2212 1
			db_printf("will follow to byte %d of page at 0x%x...\n",
d2216 2
a2217 2
		if (badwordaddr(value)) {
			db_printf("error: unable to access page at 0x%08x.\n", value);
d2225 1
a2225 1
		db_printf("[%x physical is %x virtual]\n", value, value + VEQR_ADDR);
d2228 1
a2228 1
	db_printf("WORD at 0x%x is 0x%08x.\n", value, *(unsigned *)value);
d2247 1
a2247 1
		db_printf("cmmu #%d %s cmmu for cpu %d.\n", cmmu_num,
d2255 1
a2255 1
			db_printf("PROBE of 0x%08x faults.\n",addr);
d2258 1
a2258 1
		db_printf("PROBE of 0x%08x returns phys=0x%x", addr, R->sar);
d2266 1
a2266 1
				db_printf("line %d invalid.\n", line);
d2270 1
a2270 1
				db_printf("line %d disabled.\n", line);
d2275 1
a2275 1
				db_printf("line %d address tag is %x.\n", line,
d2279 1
a2279 1
			db_printf("found in line %d as %08x (%s).\n",
d2295 1
a2295 1
			db_printf("cmmu #%d %s cmmu for cpu %d: ", cmmu_num,
@


1.5
log
@Major changes to get MVME188 working.  More header and code cleanups.  The
kernel is tested on MVME188A/2P256 and MVME188A/1P64.
@
text
@d1 1
a1 1
/*	$OpenBSD: m18x_cmmu.c,v 1.4 2001/01/12 07:29:26 smurph Exp $	*/
d714 1
d1191 1
a1191 1
	register s = splhigh();
d1307 1
a1307 1
	register s = splhigh();
d1387 1
a1387 1
	register s = splhigh();
d1458 1
a1458 1
	register s = splhigh();
d1524 1
a1524 1
	register s = splhigh();
d1606 1
a1606 1
	register s = splhigh();
d1689 1
a1689 1
	register s = splhigh();
d1772 1
a1774 1
#if !defined(BROKEN_MMU_MASK)
@


1.4
log
@Update vm interface to MACHIN_NEW_NONCONTIG.  Fix compile warning in pcctwo.c
@
text
@d1 1
a1 1
/*	$OpenBSD: m18x_cmmu.c,v 1.3 2000/12/28 21:21:24 smurph Exp $	*/
d76 3
a78 3
   #define DB_CMMU		0x4000	/* MMU debug */
unsigned int debuglevel = 0;
   #define dprintf(_L_,_X_) { if (debuglevel & (_L_)) { unsigned int psr = disable_interrupts_return_psr(); printf("%d: ", cpu_number()); printf _X_;  set_psr(psr); } }
d266 2
a267 2
	{ -1, -1, -1},
	{ -1, -1, -1},
d270 3
a272 3
	{ -1, -1, -1},
	{ -1, -1, -1},
	{ -1, -1, -1},
d274 5
a278 5
	{ -1, -1, -1},
	{ -1, -1, -1},
	{ -1, -1, -1},
	{ -1, -1, -1},
	{ -1, -1, -1}
d289 2
a290 2
	{(void *)VME_CMMU_I0, -1, INST_CMMU, CMMU_ACS_BOTH,       
		CMMU_DEAD,      0, 0},                                 
d292 1
a292 1
		CMMU_DEAD,      0, 0},                                 
d294 1
a294 1
		CMMU_DEAD,      0, 0},                                 
d296 1
a296 1
		CMMU_DEAD,      0, 0},                                 
d298 1
a298 1
		CMMU_DEAD,      0, 0},
d300 1
a300 1
		CMMU_DEAD,      0, 0},
d302 1
a302 1
		CMMU_DEAD,      0, 0},
d304 1
a304 1
		CMMU_DEAD,      0, 0}
d344 2
a345 2
		dprintf(DB_CMMU,("m18x_setup_board_config: WHOAMI @@ 0x%08x holds value 0x%08x\n",
				 whoami, *whoami));
d794 1
a794 1
	for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++)
d867 4
a870 4

		/*
		 * Enable snooping...
		 */
a1869 1

a1871 1

d1943 2
a1944 1
			if (cpu_cmmu[0].pair[DATA_CMMU] == 0) {
d1948 1
a1948 1
			cmmu_num = cpu_cmmu[0].pair[DATA_CMMU] - cmmu;
@


1.3
log
@mvme88k updates to -current.  finally!
@
text
@d1 1
a1 1
/*	$OpenBSD: m18x_cmmu.c,v 1.2 2000/03/03 00:54:53 todd Exp $	*/
d64 1
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD: m18x_cmmu.c,v 1.1 1999/09/27 19:13:22 smurph Exp $	*/
d84 1
a84 2
   /* base + $000 */
   volatile unsigned idr; 
d115 12
a126 12
   struct cmmu_regs *cmmu_regs;    /* CMMU "base" area */
   unsigned char  cmmu_cpu;        /* cpu number it is attached to */
   unsigned char  which;           /* either INST_CMMU || DATA_CMMU */
   unsigned char  cmmu_access;     /* either CMMU_ACS_{SUPER,USER,BOTH} */
   unsigned char  cmmu_alive;
#define CMMU_DEAD	0		           /* This cmmu not there */
#define CMMU_AVAILABLE	1		     /* It's there, but which cpu's? */
#define CMMU_ALIVE 1               /* It's there. */
#define CMMU_MARRIED	2		        /* Know which cpu it belongs to. */
   vm_offset_t    cmmu_addr;       /* address range */
   vm_offset_t    cmmu_addr_mask;  /* address mask */
   int            cmmu_addr_match; /* return value of address comparison */
d128 1
a128 1
   unsigned batc[8];
d170 2
a171 2
   union apr_template apr_template;
   apr_template.bits = value;
d173 7
a179 7
   printf("table @@ 0x%x000", apr_template.field.st_base);
   if (apr_template.field.wt) printf(", writethrough");
   if (apr_template.field.g)  printf(", global");
   if (apr_template.field.ci) printf(", cache inhibit");
   if (apr_template.field.te) printf(", valid");
   else                       printf(", not valid");
   printf("\n");
d185 15
a199 15
   union {
      unsigned bits;
      struct {
         unsigned :16,
         pe: 1,
         se: 1,
         pr: 1,
         :13;
      } fields;
   } sctr; 
   sctr.bits = value;
   printf("%spe, %sse %spr]\n",
          sctr.fields.pe ? "" : "!",
          sctr.fields.se ? "" : "!",
          sctr.fields.pr ? "" : "!");
d203 1
a203 3
/*----------------------------------------------------------------*/

/*
d241 2
a242 2
   int inst;
   int data;
d244 5
a248 5
   /*     inst                 data */
   { CMMU_SPLIT_SPV,      CMMU_SPLIT_SPV},  /* CPU 0 */
   { CMMU_SPLIT_SPV,      CMMU_SPLIT_SPV},  /* CPU 1 */
   { CMMU_SPLIT_ADDRESS,  CMMU_SPLIT_ADDRESS}, /* CPU 2 */
   { CMMU_SPLIT_ADDRESS,  CMMU_SPLIT_ADDRESS}  /* CPU 3 */
d256 3
a258 3
   int supported;
   int ncpus;
   int ncmmus;
d261 17
a277 17
   /* sup, CPU MMU */
   {  1,  4,  8}, /* 4P128 - 4P512 */
   {  1,  2,  8}, /* 2P128 - 2P512 */
   {  1,  1,  8}, /* 1P128 - 1P512 */
   { -1, -1, -1},
   { -1, -1, -1},
   {  1,  2,  4}, /* 2P64  - 2P256 */
   {  1,  1,  4}, /* 1P64  - 1P256 */
   { -1, -1, -1},
   { -1, -1, -1},
   { -1, -1, -1},
   {  1,  1,  2}, /* 1P32  - 1P128 */
   { -1, -1, -1},
   { -1, -1, -1},
   { -1, -1, -1},
   { -1, -1, -1},
   { -1, -1, -1}
d286 18
a303 18
   /* addr    cpu       mode           access
 alive   addr mask */
   {(void *)VME_CMMU_I0, -1, INST_CMMU, CMMU_ACS_BOTH,       
      CMMU_DEAD,      0, 0},                                 
   {(void *)VME_CMMU_D0, -1, DATA_CMMU, CMMU_ACS_BOTH,       
      CMMU_DEAD,      0, 0},                                 
   {(void *)VME_CMMU_I1, -1, INST_CMMU, CMMU_ACS_BOTH,       
      CMMU_DEAD,      0, 0},                                 
   {(void *)VME_CMMU_D1, -1, DATA_CMMU, CMMU_ACS_BOTH,       
      CMMU_DEAD,      0, 0},                                 
   {(void *)VME_CMMU_I2, -1, INST_CMMU, CMMU_ACS_BOTH,
      CMMU_DEAD,      0, 0},
   {(void *)VME_CMMU_D2, -1, DATA_CMMU, CMMU_ACS_BOTH,
      CMMU_DEAD,      0, 0},
   {(void *)VME_CMMU_I3, -1, INST_CMMU, CMMU_ACS_BOTH,
      CMMU_DEAD,      0, 0},
   {(void *)VME_CMMU_D3, -1, DATA_CMMU, CMMU_ACS_BOTH,
      CMMU_DEAD,      0, 0}
d307 1
a307 1
   struct cmmu *pair[2];
d313 1
a313 1
   volatile unsigned long *whoami;
d315 56
a370 48
   master_cpu = 0; /* temp to get things going */
   switch (cputyp) {
      case CPU_187:
      case CPU_197:
         vme188_config = 10; /* There is no WHOAMI reg on MVME1x7 - fake it... */
         cmmu[0].cmmu_regs = (void *)SBC_CMMU_I;
         cmmu[0].cmmu_cpu = 0;
         cmmu[1].cmmu_regs = (void *)SBC_CMMU_D;
         cmmu[1].cmmu_cpu = 0;
         cmmu[2].cmmu_regs = (void *)NULL;
         cmmu[3].cmmu_regs = (void *)NULL;
         cmmu[4].cmmu_regs = (void *)NULL;
         cmmu[5].cmmu_regs = (void *)NULL;
         cmmu[6].cmmu_regs = (void *)NULL;
         cmmu[7].cmmu_regs = (void *)NULL;
         max_cpus = 1;
         max_cmmus = 2;
         break;
      case CPU_188:
         whoami = (volatile unsigned long *)MVME188_WHOAMI;
         vme188_config = (*whoami & 0xf0) >> 4;
         dprintf(DB_CMMU,("m18x_setup_board_config: WHOAMI @@ 0x%08x holds value 0x%08x\n",
                          whoami, *whoami));
         max_cpus = bd_config[vme188_config].ncpus;
         max_cmmus = bd_config[vme188_config].ncmmus;
         break;
      default:
         panic("m18x_setup_board_config: Unknown CPU type.");
   }
   cpu_cmmu_ratio = max_cmmus / max_cpus;
   switch (bd_config[vme188_config].supported) {
      case 0:
         printf("MVME%x board configuration #%X: %d CPUs %d CMMUs\n", cputyp, 
                vme188_config, max_cpus, max_cmmus);
         panic("This configuration is not supported - go and get another OS.\n");
         /* NOTREACHED */
         break;
      case 1:
         printf("MVME%x board configuration #%X: %d CPUs %d CMMUs\n", cputyp,
                vme188_config, max_cpus, max_cmmus);
         m18x_setup_cmmu_config();
         break;
      default:
         panic("UNKNOWN MVME%x board configuration: WHOAMI = 0x%02x\n", cputyp, *whoami);
         /* NOTREACHED */
         break;
   }
   return;
d380 2
a381 2
   volatile unsigned long *pcnfa;
   volatile unsigned long *pcnfb;
d383 1
a383 1
   register int num, cmmu_num, val1, val2;
d385 2
a386 2
   dprintf(DB_CMMU,("m18x_setup_cmmu_config: initializing with %d CPU(s) and %d CMMU(s)\n",
                    max_cpus, max_cmmus));
d388 192
a579 188
   /*
    * Probe for available MMUs
    */
   for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++)
      if (!badwordaddr((vm_offset_t)cmmu[cmmu_num].cmmu_regs)) {
         union cpupid id;

         id.cpupid = cmmu[cmmu_num].cmmu_regs->idr;
         if (id.m88200.type != M88200 && id.m88200.type != M88204) {
            printf("WARNING: non M8820x circuit found at CMMU address 0x%08x\n",
                   cmmu[cmmu_num].cmmu_regs);
            continue;
         }
         cmmu[cmmu_num].cmmu_alive = CMMU_ALIVE;
         dprintf(DB_CMMU,("m18x_setup_cmmu_config: CMMU %d found at 0x%08x\n",
                          cmmu_num, cmmu[cmmu_num].cmmu_regs));
      }

      /*
       * Now that we know which CMMUs are there, let's report on which
       * CPU/CMMU sets seem complete (hopefully all)
       */
   for (num = 0; num < max_cpus; num++) {
      register int i;
      union cpupid id;

      for (i = 0; i < cpu_cmmu_ratio; i++) {
         dprintf(DB_CMMU,("cmmu_init: testing CMMU %d for CPU %d\n",
                          num*cpu_cmmu_ratio+i, num));
         if (!m18x_cmmu_alive(num*cpu_cmmu_ratio + i)) {
            printf("CMMU %d attached to CPU %d is not working\n");
            panic("m18x_setup_cmmu_config");
         }
      }
      cpu_sets[num] = 1;   /* This cpu installed... */
      id.cpupid = cmmu[num*cpu_cmmu_ratio].cmmu_regs->idr;

      if (id.m88200.type == M88204)
         printf("CPU%d is attached with %d MC88204 CMMUs\n",
                num, cpu_cmmu_ratio);
      else
         printf("CPU%d is attached with %d MC88200 CMMUs\n",
                num, cpu_cmmu_ratio);
   }

   for (num = 0; num < max_cpus; num++) {
      cpu_cmmu_strategy[num].inst &= CMMU_SPLIT_MASK;
      cpu_cmmu_strategy[num].data &= CMMU_SPLIT_MASK;
      dprintf(DB_CMMU,("m18x_setup_cmmu_config: CPU %d inst strat %d data strat %d\n",
                       num, cpu_cmmu_strategy[num].inst, cpu_cmmu_strategy[num].data));
   }

   switch (vme188_config) {
      /*
       * These configurations have hardwired CPU/CMMU configurations.
       */
      case CONFIG_0:
      case CONFIG_5:
      case CONFIG_A:
         dprintf(DB_CMMU,("m18x_setup_cmmu_config: resetting strategies\n"));
         for (num = 0; num < max_cpus; num++)
            cpu_cmmu_strategy[num].inst = cpu_cmmu_strategy[num].data =
                                          CMMU_SPLIT_ADDRESS;
         break;
         /*
          * Configure CPU/CMMU strategy into PCNFA and PCNFB board registers.
          */
      case CONFIG_1:
         pcnfa = (volatile unsigned long *)MVME188_PCNFA;
         pcnfb = (volatile unsigned long *)MVME188_PCNFB;
         val1 = (cpu_cmmu_strategy[0].inst << 2) | cpu_cmmu_strategy[0].data;
         val2 = (cpu_cmmu_strategy[1].inst << 2) | cpu_cmmu_strategy[1].data;
         *pcnfa = val1;
         *pcnfb = val2;
         dprintf(DB_CMMU,("m18x_setup_cmmu_config: 2P128: PCNFA = 0x%x, PCNFB = 0x%x\n", val1, val2));
         break;
      case CONFIG_2:
         pcnfa = (volatile unsigned long *)MVME188_PCNFA;
         pcnfb = (volatile unsigned long *)MVME188_PCNFB;
         val1 = (cpu_cmmu_strategy[0].inst << 2) | cpu_cmmu_strategy[0].inst;
         val2 = (cpu_cmmu_strategy[0].data << 2) | cpu_cmmu_strategy[0].data;
         *pcnfa = val1;
         *pcnfb = val2;
         dprintf(DB_CMMU,("m18x_setup_cmmu_config: 1P128: PCNFA = 0x%x, PCNFB = 0x%x\n", val1, val2));
         break;
      case CONFIG_6:
         pcnfa = (volatile unsigned long *)MVME188_PCNFA;
         val1 = (cpu_cmmu_strategy[0].inst << 2) | cpu_cmmu_strategy[0].data;
         *pcnfa = val1;
         dprintf(DB_CMMU,("m18x_setup_cmmu_config: 1P64: PCNFA = 0x%x\n", val1));
         break;
      default:
         panic("m18x_setup_cmmu_config");
         break;
   }

   dprintf(DB_CMMU,("m18x_setup_cmmu_config: PCNFA = 0x%x, PCNFB = 0x%x\n", *pcnfa, *pcnfb));

   /*
    * Calculate the CMMU<->CPU connections
    */
   for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++) {
      cmmu[cmmu_num].cmmu_cpu =
      (int) (((float) cmmu_num) * ((float) max_cpus) / ((float) max_cmmus));
      dprintf(DB_CMMU,("m18x_setup_cmmu_config: CMMU %d connected with CPU %d\n",
                       cmmu_num, cmmu[cmmu_num].cmmu_cpu));
   }

   /*
    * Now set cmmu[].cmmu_access and addr
    */
   for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++) {
      /*
       * We don't set up anything for the hardwired configurations.
       */
      if (cpu_cmmu_ratio == 2) {
         cmmu[cmmu_num].cmmu_addr =
         cmmu[cmmu_num].cmmu_addr_mask = 0;
         cmmu[cmmu_num].cmmu_addr_match = 1;
         cmmu[cmmu_num].cmmu_access = CMMU_ACS_BOTH;
         continue;
      }

      /*
       * First we set the address/mask pairs for the exact address
       * matches.
       */
      switch ((cmmu[cmmu_num].which == INST_CMMU) ?
              cpu_cmmu_strategy[cmmu[cmmu_num].cmmu_cpu].inst :
              cpu_cmmu_strategy[cmmu[cmmu_num].cmmu_cpu].data) {
         case CMMU_SPLIT_ADDRESS:
            cmmu[cmmu_num].cmmu_addr = ((cmmu_num & 0x2) ^ 0x2) << 11;
            cmmu[cmmu_num].cmmu_addr_mask = CMMU_A12_MASK;
            cmmu[cmmu_num].cmmu_addr_match = 1;
            break;
         case CMMU_SPLIT_SPV:
            cmmu[cmmu_num].cmmu_addr =
            cmmu[cmmu_num].cmmu_addr_mask = 0;
            cmmu[cmmu_num].cmmu_addr_match = 1;
            break;
         case CMMU_SPLIT_SRAM_ALL:
            cmmu[cmmu_num].cmmu_addr = CMMU_SRAM;
            cmmu[cmmu_num].cmmu_addr_mask = CMMU_SRAM_MASK;
            cmmu[cmmu_num].cmmu_addr_match = (cmmu_num & 0x2) ? 1 : 0;
            break;
         case CMMU_SPLIT_SRAM_SPV:
            if (cmmu_num & 0x2) {
               cmmu[cmmu_num].cmmu_addr = CMMU_SRAM;
               cmmu[cmmu_num].cmmu_addr_mask = CMMU_SRAM_MASK;
            } else {
               cmmu[cmmu_num].cmmu_addr =
               cmmu[cmmu_num].cmmu_addr_mask = 0;
            }
            cmmu[cmmu_num].cmmu_addr_match = 1;
            break;
      }

      /*
       * For MVME188 single processors, we've got to look at A14.
       * This bit splits the CMMUs independent of the enabled strategy.
       *
       * NOT TESTED!!! - em
       */
      if (cpu_cmmu_ratio > 4) {
         cmmu[cmmu_num].cmmu_addr |= ((cmmu_num & 0x4) ^ 0x4) << 12;
         cmmu[cmmu_num].cmmu_addr_mask |= CMMU_A14_MASK;
      }

      /*
       * Next we cope with the various access modes.
       */
      switch ((cmmu[cmmu_num].which == INST_CMMU) ?
              cpu_cmmu_strategy[cmmu[cmmu_num].cmmu_cpu].inst :
              cpu_cmmu_strategy[cmmu[cmmu_num].cmmu_cpu].data) {
         case CMMU_SPLIT_SPV:
            cmmu[cmmu_num].cmmu_access =
            (cmmu_num & 0x2 ) ? CMMU_ACS_USER : CMMU_ACS_SUPER;
            break;
         case CMMU_SPLIT_SRAM_SPV:
            cmmu[cmmu_num].cmmu_access =
            (cmmu_num & 0x2 ) ? CMMU_ACS_SUPER : CMMU_ACS_BOTH;
            break;
         default:
            cmmu[cmmu_num].cmmu_access = CMMU_ACS_BOTH;
            break;
      }
   }
   return;
d583 4
a586 4
   "address split ",
   "user/spv split",
   "spv SRAM split",
   "all SRAM split"
d589 2
a590 1
void m18x_cmmu_dump_config(void)
d593 42
a634 26
   volatile unsigned long *pcnfa;
   volatile unsigned long *pcnfb;
   register int cmmu_num;

   if (cputyp != CPU_188) return;

   db_printf("Current CPU/CMMU configuration:\n\n");

   db_printf("VME188 address decoder: PCNFA = 0x%1x, PCNFB = 0x%1x\n\n", *pcnfa & 0xf, *pcnfb & 0xf);
   pcnfa = (volatile unsigned long *)MVME188_PCNFA;
   pcnfb = (volatile unsigned long *)MVME188_PCNFB;
   for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++) {
      db_printf("CMMU #%d: %s CMMU for CPU %d:\n Strategy: %s\n %s access addr 0x%08x mask 0x%08x match %s\n",
                cmmu_num,
                (cmmu[cmmu_num].which == INST_CMMU) ? "inst" : "data",
                cmmu[cmmu_num].cmmu_cpu,
                cmmu_strat_string[(cmmu[cmmu_num].which == INST_CMMU) ?
                                  cpu_cmmu_strategy[cmmu[cmmu_num].cmmu_cpu].inst :
                                  cpu_cmmu_strategy[cmmu[cmmu_num].cmmu_cpu].data],
                (cmmu[cmmu_num].cmmu_access == CMMU_ACS_BOTH) ?   "User and spv" :
                ((cmmu[cmmu_num].cmmu_access == CMMU_ACS_USER) ? "User        " :
                 "Supervisor  "),
                cmmu[cmmu_num].cmmu_addr,
                cmmu[cmmu_num].cmmu_addr_mask,
                cmmu[cmmu_num].cmmu_addr_match ? "TRUE" : "FALSE");
   }
d641 1
a641 1
   *(volatile unsigned *)(reg + (char*)(cmmu[mmu].cmmu_regs)) = val;
d644 2
a645 1
int m18x_cmmu_alive(int mmu)
d647 1
a647 1
   return (cmmu[mmu].cmmu_alive == CMMU_ALIVE);
d650 2
a651 1
unsigned m18x_cmmu_get(int mmu, int reg)
d653 1
a653 1
   return *(volatile unsigned *)(reg + (char*)(cmmu[mmu].cmmu_regs));
d660 3
a662 2
void m18x_cmmu_set(int reg, unsigned val, int flags,
              int num, int mode, int access, vm_offset_t addr)
d664 1
a664 1
   register int mmu;
d666 30
a695 30
   if (flags & NUM_CMMU) {
      /*
       * Special case: user supplied CMMU number directly as argument.
       * Simply store the value away.
       */
      /* assert(num < max_cmmus); */
      m18x_cmmu_store(num, reg, val);
      return;
   }

   /*
    * We scan all CMMUs to find the matching ones and store the
    * values there.
    */
   for (mmu = num*cpu_cmmu_ratio; mmu < (num+1)*cpu_cmmu_ratio; mmu++) {
      if (((flags & MODE_VAL)) &&
          (cmmu[mmu].which != mode))
         continue;
      if (((flags & ACCESS_VAL)) &&
          (cmmu[mmu].cmmu_access != access) &&
          (cmmu[mmu].cmmu_access != CMMU_ACS_BOTH))
         continue;
      if (flags & ADDR_VAL) {
         if (((addr & cmmu[mmu].cmmu_addr_mask) == cmmu[mmu].cmmu_addr)
             != cmmu[mmu].cmmu_addr_match) {
            continue;
         }
      }
      m18x_cmmu_store(mmu, reg, val);
   }
d702 2
a703 1
unsigned m18x_cmmu_get_by_mode(int cpu, int mode)
d705 1
a705 1
   register int mmu;
d707 6
a712 6
   for (mmu = cpu*cpu_cmmu_ratio; mmu < (cpu+1)*cpu_cmmu_ratio; mmu++)
      if (cmmu[mmu].which == mode)
         return mmu;
   printf("can't figure out first %s CMMU for CPU %d\n",
          (mode == DATA_CMMU) ? "data" : "instruction", cpu);
   panic("m18x_cmmu_get_by_mode");
d717 8
a724 8
   "Unknown (0)",
   "Unknown (1)",
   "Unknown (2)",
   "Unknown (3)",
   "Unknown (4)",
   "M88200 (16K)",
   "M88204 (64K)",
   "Unknown (7)"
d732 2
a733 1
void m18x_cpu_configuration_print(int master)
d735 17
a751 17
   int pid = read_processor_identification_register();
   int proctype = (pid & 0xff00) >> 8;
   int procvers = (pid & 0xe) >> 1;
   int mmu, cpu = cpu_number();
   struct simplelock print_lock;

   if (master)
      simple_lock_init(&print_lock);

   simple_lock(&print_lock);

   printf("Processor %d: ", cpu);
   if (proctype)
      printf("Architectural Revision 0x%x UNKNOWN CPU TYPE Version 0x%x\n",
             proctype, procvers);
   else
      printf("M88100 Version 0x%x\n", procvers);
d754 2
a755 2
   if (procvers < 2)
      printf("WARNING: M88100 bug workaround code not enabled!!!\n");
d758 17
a774 17
   for (mmu = cpu*cpu_cmmu_ratio; mmu < (cpu+1)*cpu_cmmu_ratio; mmu++) {
      int idr = m18x_cmmu_get(mmu, CMMU_IDR);
      int mmuid = (0xe00000 & idr)>>21;

      printf(" %s %s Cache: ",
             (cmmu[mmu].cmmu_access == CMMU_ACS_BOTH) ?  "Spv and User" :
             ((cmmu[mmu].cmmu_access == CMMU_ACS_USER) ? "User        " :
              "Supervisor  "),
             (cmmu[mmu].which == INST_CMMU) ?   "Instruction" :
             "Data       ");
      if (mmutypes[mmuid][0] == 'U')
         printf("Type 0x%x ", mmuid);
      else
         printf("%s ", mmutypes[mmuid]);
      printf("Version 0x%x\n", (idr & 0x1f0000)>>16);
   }
   printf  (" Configured as %s and started\n", master ? "master" : "slave");
d776 1
a776 1
   simple_unlock(&print_lock);
d785 57
a841 57
   unsigned tmp, cmmu_num;
   union cpupid id;
   int cpu;

   for (cpu = 0; cpu < max_cpus; cpu++) {
      cpu_cmmu[cpu].pair[INST_CMMU] = cpu_cmmu[cpu].pair[DATA_CMMU] = 0;
   }

   for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++)
      if (m18x_cmmu_alive(cmmu_num)) {
         id.cpupid = cmmu[cmmu_num].cmmu_regs->idr;
			
         cpu_cmmu[cmmu[cmmu_num].cmmu_cpu].pair[cmmu[cmmu_num].which] =
				&cmmu[cmmu_num];
         /*
          * Reset cache data....
          * as per M88200 Manual (2nd Ed.) section 3.11.
          */
         for (tmp = 0; tmp < 255; tmp++) {
            cmmu[cmmu_num].cmmu_regs->sar = tmp << 4;
            cmmu[cmmu_num].cmmu_regs->cssp = 0x3f0ff000;
         }

         /* 88204 has additional cache to clear */
         if (id.m88200.type == M88204) {
            for (tmp = 0; tmp < 255; tmp++) {
               cmmu[cmmu_num].cmmu_regs->sar = tmp<<4;
               cmmu[cmmu_num].cmmu_regs->cssp1 = 0x3f0ff000;
            }
            for (tmp = 0; tmp < 255; tmp++) {
               cmmu[cmmu_num].cmmu_regs->sar = tmp<<4;
               cmmu[cmmu_num].cmmu_regs->cssp2 = 0x3f0ff000;
            }
            for (tmp = 0; tmp < 255; tmp++) {
               cmmu[cmmu_num].cmmu_regs->sar = tmp<<4;
               cmmu[cmmu_num].cmmu_regs->cssp3 = 0x3f0ff000;
            }
         }

         /*
          * Set the SCTR, SAPR, and UAPR to some known state
          * (I don't trust the reset to do it).
          */
         tmp =
         ! CMMU_SCTR_PE |   /* not parity enable */
         ! CMMU_SCTR_SE | /* not snoop enable */
         ! CMMU_SCTR_PR ;  /* not priority arbitration */
         cmmu[cmmu_num].cmmu_regs->sctr = tmp;

         tmp =
         (0x00000 << 12) |  /* segment table base address */
         AREA_D_WT |      /* write through */
         AREA_D_G  | /* global */
         AREA_D_CI | /* cache inhibit */
         ! AREA_D_TE ;   /* not translation enable */
         cmmu[cmmu_num].cmmu_regs->sapr =
         cmmu[cmmu_num].cmmu_regs->uapr = tmp;
d845 8
a852 8
         cmmu[cmmu_num].batc[0] =
         cmmu[cmmu_num].batc[1] =
         cmmu[cmmu_num].batc[2] =
         cmmu[cmmu_num].batc[3] =
         cmmu[cmmu_num].batc[4] =
         cmmu[cmmu_num].batc[5] =
         cmmu[cmmu_num].batc[6] =
         cmmu[cmmu_num].batc[7] = 0;
d854 74
a927 74
         cmmu[cmmu_num].cmmu_regs->bwp[0] = 
         cmmu[cmmu_num].cmmu_regs->bwp[1] = 
         cmmu[cmmu_num].cmmu_regs->bwp[2] = 
         cmmu[cmmu_num].cmmu_regs->bwp[3] = 
         cmmu[cmmu_num].cmmu_regs->bwp[4] = 
         cmmu[cmmu_num].cmmu_regs->bwp[5] = 
         cmmu[cmmu_num].cmmu_regs->bwp[6] = 
         cmmu[cmmu_num].cmmu_regs->bwp[7] = 0;
         cmmu[cmmu_num].cmmu_regs->scr = CMMU_FLUSH_CACHE_INV_ALL;
         cmmu[cmmu_num].cmmu_regs->scr = CMMU_FLUSH_SUPER_ALL;
         cmmu[cmmu_num].cmmu_regs->scr = CMMU_FLUSH_USER_ALL;
      }

      /*
       * Enable snooping...
       */
   for (cpu = 0; cpu < max_cpus; cpu++) {
      if (!cpu_sets[cpu])
         continue;

      /*
       * Enable snooping.
       * We enable it for instruction cmmus as well so that we can have
       * breakpoints, etc, and modify code.
       */
      if (cputyp == CPU_188) {
         tmp =
         ! CMMU_SCTR_PE |  /* not parity enable */
         CMMU_SCTR_SE |  /* snoop enable */
         ! CMMU_SCTR_PR ;  /* not priority arbitration */
      } else {
         tmp =
         ! CMMU_SCTR_PE |  /* not parity enable */
         ! CMMU_SCTR_PR ;  /* not priority arbitration */
      }
      m18x_cmmu_set(CMMU_SCTR, tmp, 0, cpu, DATA_CMMU, 0, 0);
      m18x_cmmu_set(CMMU_SCTR, tmp, 0, cpu, INST_CMMU, 0, 0);

      m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_SUPER_ALL, ACCESS_VAL,
               cpu, DATA_CMMU, CMMU_ACS_SUPER, 0);
      m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_SUPER_ALL, ACCESS_VAL,
               cpu, INST_CMMU, CMMU_ACS_SUPER, 0);
   }

   /*
    * Turn on some cache.
    */
   for (cpu = 0; cpu < max_cpus; cpu++) {
      if (!cpu_sets[cpu])
         continue;
      /*
       * Enable some caching for the instruction stream.
       * Can't cache data yet 'cause device addresses can never
       * be cached, and we don't have those no-caching zones
       * set up yet....
       */
      tmp =
      (0x00000 << 12) | /* segment table base address */
      AREA_D_WT |       /* write through */
      AREA_D_G  |       /* global */
      AREA_D_CI |       /* cache inhibit */
      ! AREA_D_TE ;     /* not translation enable */
      /*
      REGS(cpu, INST_CMMU).sapr = tmp;
      */
      m18x_cmmu_set(CMMU_SAPR, tmp, MODE_VAL,
               cpu, INST_CMMU, 0, 0);

      /*
      REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_SUPER_ALL;
      */
      m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_SUPER_ALL, ACCESS_VAL|MODE_VAL,
               cpu, DATA_CMMU, CMMU_ACS_SUPER, 0);
   }
a929 1

d936 2
a937 2
   unsigned tmp;
   unsigned cmmu_num;
d939 27
a965 27
   /*
    * Now set some state as we like...
    */
   for (cmmu_num = 0; cmmu_num < MAX_CMMUS; cmmu_num++) {
      if (cputyp == CPU_188) {
         tmp =
         ! CMMU_SCTR_PE |   /* parity enable */
         ! CMMU_SCTR_SE |   /* snoop enable */
         ! CMMU_SCTR_PR ;   /* priority arbitration */
      } else {
         tmp =
         ! CMMU_SCTR_PE |   /* parity enable */
         ! CMMU_SCTR_PR ;   /* priority arbitration */
      }

      cmmu[cmmu_num].cmmu_regs->sctr = tmp;

      tmp = 
      (0x00000 << 12) |  /* segment table base address */
      ! AREA_D_WT |      /* write through */
      ! AREA_D_G  |      /* global */
      AREA_D_CI |        /* cache inhibit */
      ! AREA_D_TE ;      /* translation disable */

      cmmu[cmmu_num].cmmu_regs->sapr = tmp;
      cmmu[cmmu_num].cmmu_regs->uapr = tmp;
   }
d972 2
a973 1
void m18x_cmmu_parity_enable(void)
d976 1
a976 1
   register int cmmu_num;
d978 12
a989 11
   for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++) {
      if (m18x_cmmu_alive(cmmu_num)) {
         register unsigned val1 = m18x_cmmu_get(cmmu_num, CMMU_SCTR);

         /*
         cmmu[cmmu_num].cmmu_regs->sctr |= CMMU_SCTR_PE;
         */
         m18x_cmmu_set(CMMU_SCTR, val1 | CMMU_SCTR_PE, NUM_CMMU,
                  cmmu_num, 0, 0, 0);
      }
   }
d1000 2
a1001 1
unsigned m18x_cmmu_cpu_number(void)
d1003 2
a1004 2
   register unsigned cmmu_no;
   int i;
d1007 26
a1032 26
   for (i=0; i < 10; i++) {
      /* clear CMMU p-bus status registers */
      for (cmmu_no = 0; cmmu_no < MAX_CMMUS; cmmu_no++) {
         if (cmmu[cmmu_no].cmmu_alive == CMMU_AVAILABLE &&
             cmmu[cmmu_no].which == DATA_CMMU)
            cmmu[cmmu_no].cmmu_regs->pfSTATUSr = 0;
      }

      /* access faulting address */
      badwordaddr((void *)ILLADDRESS);

      /* check which CMMU reporting the fault  */
      for (cmmu_no = 0; cmmu_no < MAX_CMMUS; cmmu_no++) {
         if (cmmu[cmmu_no].cmmu_alive == CMMU_AVAILABLE &&
             cmmu[cmmu_no].which == DATA_CMMU &&
             cmmu[cmmu_no].cmmu_regs->pfSTATUSr & 0x70000) {
            if (cmmu[cmmu_no].cmmu_regs->pfSTATUSr & 0x70000) {
               cmmu[cmmu_no].cmmu_regs->pfSTATUSr = 0; /* to be clean */
               cmmu[cmmu_no].cmmu_alive = CMMU_MARRIED;
               return cmmu[cmmu_no].cmmu_cpu;
            }
         }
      }
   }
   panic("m18x_cmmu_cpu_number: could not determine my cpu number");
   return 0; /* to make compiler happy */
d1045 1
a1045 1
   *(volatile unsigned *)(r + (char*)&REGS(cpu,data)) = x;
d1058 1
a1058 1
   return (*(volatile unsigned *)(r + (char*)&REGS(cpu,data)));
d1065 3
a1067 3
   int cpu;
   cpu = cpu_number();
   return REGS(cpu,data).idr;
d1073 2
a1074 2
   int cpu;
   cpu = cpu_number();
d1076 8
a1083 8
   if (cache_policy & CACHE_INH)
      ap |= AREA_D_CI;
   /*
  REGS(cpu, INST_CMMU).sapr = ap;
  REGS(cpu, DATA_CMMU).sapr = ap;
   */
   m18x_cmmu_set(CMMU_SAPR, ap, ACCESS_VAL,
            cpu, 0, CMMU_ACS_SUPER, 0);
d1089 2
a1090 2
   if (cache_policy & CACHE_INH)
      ap |= AREA_D_CI;
d1092 6
a1097 6
   /*
  REGS(cpu, INST_CMMU).sapr = ap;
  REGS(cpu, DATA_CMMU).sapr = ap;
   */
   m18x_cmmu_set(CMMU_SAPR, ap, ACCESS_VAL,
            cpu, 0, CMMU_ACS_SUPER, 0);
d1103 2
a1104 2
   int cpu;
   cpu = cpu_number();
d1106 7
a1112 7
   /* this functionality also mimiced in m18x_cmmu_pmap_activate() */
   /*
  REGS(cpu, INST_CMMU).uapr = ap;
  REGS(cpu, DATA_CMMU).uapr = ap;
   */
   m18x_cmmu_set(CMMU_UAPR, ap, ACCESS_VAL,
            cpu, 0, CMMU_ACS_USER, 0);
d1124 10
a1133 11
m18x_cmmu_set_batc_entry(
                   unsigned cpu,
                   unsigned entry_no,
                   unsigned data,   /* 1 = data, 0 = instruction */
                   unsigned value)  /* the value to stuff into the batc */
{
   /*
   REGS(cpu,data).bwp[entry_no] = value;
   */
   m18x_cmmu_set(CMMU_BWP(entry_no), value, MODE_VAL|ACCESS_VAL,
            cpu, data, CMMU_ACS_USER, 0);
d1135 1
a1135 1
   CMMU(cpu,data)->batc[entry_no] = value;
d1138 2
a1139 2
   REGS(cpu,data).scr = CMMU_FLUSH_SUPER_ALL;
   REGS(cpu,data).scr = CMMU_FLUSH_USER_ALL;
d1148 3
a1150 4
m18x_cmmu_set_pair_batc_entry(
                        unsigned cpu,
                        unsigned entry_no,
                        unsigned value)  /* the value to stuff into the batc */
d1153 5
a1157 5
   /*
   REGS(cpu,DATA_CMMU).bwp[entry_no] = value;
   */
   m18x_cmmu_set(CMMU_BWP(entry_no), value, MODE_VAL|ACCESS_VAL,
            cpu, DATA_CMMU, CMMU_ACS_USER, 0);
d1159 1
a1159 1
   CMMU(cpu,DATA_CMMU)->batc[entry_no] = value;
d1161 5
a1165 5
   /*
   REGS(cpu,INST_CMMU).bwp[entry_no] = value;
   */
   m18x_cmmu_set(CMMU_BWP(entry_no), value, MODE_VAL|ACCESS_VAL,
            cpu, INST_CMMU, CMMU_ACS_USER, 0);
d1167 1
a1167 1
   CMMU(cpu,INST_CMMU)->batc[entry_no] = value;
d1171 4
a1174 4
   REGS(cpu,INST_CMMU).scr = CMMU_FLUSH_SUPER_ALL;
   REGS(cpu,INST_CMMU).scr = CMMU_FLUSH_USER_ALL;
   REGS(cpu,DATA_CMMU).scr = CMMU_FLUSH_SUPER_ALL;
   REGS(cpu,DATA_CMMU).scr = CMMU_FLUSH_USER_ALL;
d1189 31
a1219 1
   register s = splhigh();
d1221 1
a1221 33
   if (cpu > max_cpus) {
      cpu = cpu_number();
   }

   if ((unsigned)size > M88K_PGBYTES) {
      /*
      REGS(cpu, INST_CMMU).scr =
      REGS(cpu, DATA_CMMU).scr =
      kernel ? CMMU_FLUSH_SUPER_ALL : CMMU_FLUSH_USER_ALL;
          */

      m18x_cmmu_set(CMMU_SCR, kernel ? CMMU_FLUSH_SUPER_ALL : CMMU_FLUSH_USER_ALL, ACCESS_VAL,
               cpu, 0, kernel ? CMMU_ACS_SUPER : CMMU_ACS_USER, 0);
   } else { /* a page or smaller */


      /*
      REGS(cpu, INST_CMMU).sar = (unsigned)vaddr;
      REGS(cpu, DATA_CMMU).sar = (unsigned)vaddr;
      */
      m18x_cmmu_set(CMMU_SAR, vaddr, ADDR_VAL|ACCESS_VAL,
               cpu, 0, kernel ? CMMU_ACS_SUPER : CMMU_ACS_USER, vaddr);

      /*
      REGS(cpu, INST_CMMU).scr =
      REGS(cpu, DATA_CMMU).scr =
      kernel ? CMMU_FLUSH_SUPER_PAGE : CMMU_FLUSH_USER_PAGE;
          */
      m18x_cmmu_set(CMMU_SCR, kernel ? CMMU_FLUSH_SUPER_PAGE : CMMU_FLUSH_USER_PAGE, ADDR_VAL|ACCESS_VAL,
               cpu, 0, kernel ? CMMU_ACS_SUPER : CMMU_ACS_USER, vaddr);
   }
   
   splx(s);
d1230 3
a1232 3
   int cpu;
   cpu = cpu_number();
   m18x_cmmu_flush_remote_tlb(cpu, kernel, vaddr, size);
d1241 25
a1265 26
m18x_cmmu_pmap_activate(
                  unsigned cpu,
                  unsigned uapr,
                  batc_template_t i_batc[BATC_MAX],
                  batc_template_t d_batc[BATC_MAX])
{
   int entry_no;


   /* the following is from m18x_cmmu_set_uapr */
   /*
   REGS(cpu, INST_CMMU).uapr = uapr;
   REGS(cpu, DATA_CMMU).uapr = uapr;
   */
   m18x_cmmu_set(CMMU_UAPR, uapr, ACCESS_VAL,
            cpu, 0, CMMU_ACS_USER, 0);

   for (entry_no = 0; entry_no < BATC_MAX; entry_no++) {
      /*
      REGS(cpu,INST_CMMU).bwp[entry_no] = i_batc[entry_no].bits;
      REGS(cpu,DATA_CMMU).bwp[entry_no] = d_batc[entry_no].bits;
      */
      m18x_cmmu_set(CMMU_BWP(entry_no), i_batc[entry_no].bits, MODE_VAL|ACCESS_VAL,
               cpu, INST_CMMU, CMMU_ACS_USER, 0);
      m18x_cmmu_set(CMMU_BWP(entry_no), d_batc[entry_no].bits, MODE_VAL|ACCESS_VAL,
               cpu, DATA_CMMU, CMMU_ACS_USER, 0);
d1267 2
a1268 2
      CMMU(cpu,INST_CMMU)->batc[entry_no] = i_batc[entry_no].bits;
      CMMU(cpu,DATA_CMMU)->batc[entry_no] = d_batc[entry_no].bits;
d1270 1
a1270 2
   }
   
d1272 12
a1283 11
   /*
    * Flush the user TLB.
    * IF THE KERNEL WILL EVER CARE ABOUT THE BATC ENTRIES,
    * THE SUPERVISOR TLBs SHOULB EE FLUSHED AS WELL.
    */
   /*
   REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_USER_ALL;
   REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_USER_ALL;
   */
   m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_USER_ALL, ACCESS_VAL,
            cpu, 0, CMMU_ACS_USER, 0);
d1305 1
a1305 1
   register s = splhigh();
d1310 47
a1356 53
   if (size < 0 || size > NBSG ) {


      /*
         REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
         REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
      */
      m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, 0,
               cpu, 0, 0, 0);
   } else if (size <= 16) {


      /*
         REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
         REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
      */
      m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, ADDR_VAL,
               cpu, 0, 0, (unsigned)physaddr);
      /*
         REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_LINE;
         REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_LINE;
      */
      m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_LINE , ADDR_VAL,
               cpu, 0, 0, (unsigned)physaddr);
   } else if (size <= NBPG) {


      /*
         REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
         REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
      */
      m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, ADDR_VAL,
               cpu, 0, 0, (unsigned)physaddr);
      /*
         REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_PAGE;
         REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_PAGE;
      */
      m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_PAGE , ADDR_VAL,
               cpu, 0, 0, (unsigned)physaddr);
   } else {
      /*
         REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
         REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
      */
      m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, 0,
               cpu, 0, 0, 0);
      /*
         REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_SEGMENT;
         REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_SEGMENT;
      */
      m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_SEGMENT, 0,
               cpu, 0, 0, 0);
   }
d1359 6
a1364 6
   /*
   REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
   REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
   */
   m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, 0,
            cpu, 0, 0, 0);
d1366 1
a1366 3

   
   splx(s);
d1375 2
a1376 2
   int cpu = cpu_number();
   m18x_cmmu_flush_remote_cache(cpu, physaddr, size);
d1385 1
a1385 1
   register s = splhigh();
d1390 41
a1430 41
   if (size < 0 || size > NBSG ) {
      /*
         REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
      */
      m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, MODE_VAL,
               cpu, INST_CMMU, 0, 0);
   } else if (size <= 16) {

      /*
         REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
      */
      m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
               cpu, INST_CMMU, 0, (unsigned)physaddr);
      /*
         REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_LINE;
      */
      m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_LINE, MODE_VAL|ADDR_VAL,
               cpu, INST_CMMU, 0, (unsigned)physaddr);
   } else if (size <= NBPG) {
      /*
         REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
      */
      m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
               cpu, INST_CMMU, 0, (unsigned)physaddr);
      /*
         REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_PAGE;
      */
      m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_PAGE, MODE_VAL|ADDR_VAL,
               cpu, INST_CMMU, 0, (unsigned)physaddr);
   } else {
      /*
         REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
      */
      m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL,
               cpu, INST_CMMU, 0, 0);
      /*
         REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_SEGMENT;
      */
      m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_SEGMENT, MODE_VAL,
               cpu, INST_CMMU, 0, 0);
   }
d1432 5
a1436 5
   /*
   REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
   */
   m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, MODE_VAL,
            cpu, INST_CMMU, 0, 0);
d1438 2
a1439 2
   
   splx(s);
d1448 3
a1450 3
   int cpu;
   cpu = cpu_number();
   m18x_cmmu_flush_remote_inst_cache(cpu, physaddr, size);
d1456 1
a1456 3
   register s = splhigh();


d1459 1
a1459 1
   if (size < 0 || size > NBSG ) {
d1461 34
a1494 34
      /*
         REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
      */
      m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, MODE_VAL,
               cpu, DATA_CMMU, 0, 0);
   } else if (size <= 16) {
      /*
      REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
      REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_LINE;
      */
      m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
               cpu, DATA_CMMU, 0, (unsigned)physaddr);
      m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_LINE, MODE_VAL|ADDR_VAL,
               cpu, DATA_CMMU, 0, (unsigned)physaddr);

   } else if (size <= NBPG) {
      /*
      REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
      REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_PAGE;
      */
      m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
               cpu, DATA_CMMU, 0, (unsigned)physaddr);
      m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_PAGE, MODE_VAL|ADDR_VAL,
               cpu, DATA_CMMU, 0, (unsigned)physaddr);
   } else {
      /*
      REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
      REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_SEGMENT;
      */
      m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL,
               cpu, DATA_CMMU, 0, 0);
      m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_SEGMENT, MODE_VAL,
               cpu, DATA_CMMU, 0, 0);
   }
d1496 5
a1500 5
   /*
   REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
   */
   m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, MODE_VAL,
            cpu, DATA_CMMU, 0, 0);
d1502 1
a1502 4

   

   splx(s);
d1511 3
a1513 3
   int cpu;
   cpu = cpu_number();
   m18x_cmmu_flush_remote_data_cache(cpu, physaddr, size);
d1522 3
a1524 5
   register s = splhigh();
   int cpu;
   cpu = cpu_number();


d1527 61
a1587 61
   if (size < 0 || size > NBSG ) {
      /*
      REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CB_ALL;
      REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CB_ALL;
      */
      m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CB_ALL, MODE_VAL,
               cpu, DATA_CMMU, 0, 0);
      m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CB_ALL, MODE_VAL,
               cpu, INST_CMMU, 0, 0);
   } else if (size <= 16) {
      /*
      REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
      REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CB_LINE;
      */
      m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
               cpu, INST_CMMU, 0, (unsigned)physaddr);
      m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_LINE, MODE_VAL,
               cpu, INST_CMMU, 0, 0);
      /*
      REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
      REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CB_LINE;
      */
      m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
               cpu, DATA_CMMU, 0, (unsigned)physaddr);
      m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_LINE, MODE_VAL,
               cpu, DATA_CMMU, 0, 0);
   } else if (size <= NBPG) {
      /*
      REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
      REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CB_PAGE;
      */
      m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
               cpu, INST_CMMU, 0, (unsigned)physaddr);
      m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_PAGE, MODE_VAL,
               cpu, INST_CMMU, 0, 0);
      /*
      REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
      REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CB_PAGE;
      */
      m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
               cpu, DATA_CMMU, 0, (unsigned)physaddr);
      m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_PAGE, MODE_VAL,
               cpu, DATA_CMMU, 0, 0);
   } else {
      /*
      REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
      REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CB_SEGMENT;
      */
      m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
               cpu, INST_CMMU, 0, (unsigned)physaddr);
      m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_SEGMENT, MODE_VAL,
               cpu, INST_CMMU, 0, 0);
      /*
      REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
      REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CB_SEGMENT;
      */
      m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
               cpu, DATA_CMMU, 0, (unsigned)physaddr);
      m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_SEGMENT, MODE_VAL,
               cpu, DATA_CMMU, 0, 0);
   }
d1589 8
a1596 8
   /*
   REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CB_ALL;
   REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CB_ALL;
   */
   m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CB_ALL, MODE_VAL,
            cpu, DATA_CMMU, 0, 0);
   m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CB_ALL, MODE_VAL,
            cpu, INST_CMMU, 0, 0);
d1598 1
a1598 4

   

   splx(s);
d1604 3
a1606 5
   register s = splhigh();
   int cpu;
   cpu = cpu_number();


d1609 61
a1669 61
   if (size < 0 || size > NBSG ) {
      /*
      REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
      REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
      */
      m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, MODE_VAL,
               cpu, DATA_CMMU, 0, 0);
      m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, MODE_VAL,
               cpu, INST_CMMU, 0, 0);
   } else if (size <= 16) {
      /*
      REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
      REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_LINE;
      */
      m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
               cpu, INST_CMMU, 0, (unsigned)physaddr);
      m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_LINE, MODE_VAL,
               cpu, INST_CMMU, 0, 0);
      /*
      REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
      REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_LINE;
      */
      m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
               cpu, DATA_CMMU, 0, (unsigned)physaddr);
      m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_LINE, MODE_VAL,
               cpu, DATA_CMMU, 0, 0);
   } else if (size <= NBPG) {
      /*
      REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
      REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_PAGE;
      */
      m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
               cpu, INST_CMMU, 0, (unsigned)physaddr);
      m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_PAGE, MODE_VAL,
               cpu, INST_CMMU, 0, 0);
      /*
      REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
      REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_PAGE;
      */
      m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
               cpu, DATA_CMMU, 0, (unsigned)physaddr);
      m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_PAGE, MODE_VAL,
               cpu, DATA_CMMU, 0, 0);
   } else {
      /*
      REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
      REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_SEGMENT;
      */
      m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
               cpu, INST_CMMU, 0, (unsigned)physaddr);
      m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_SEGMENT, MODE_VAL,
               cpu, INST_CMMU, 0, 0);
      /*
      REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
      REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_SEGMENT;
      */
      m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
               cpu, DATA_CMMU, 0, (unsigned)physaddr);
      m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_SEGMENT, MODE_VAL,
               cpu, DATA_CMMU, 0, 0);
   }
d1672 8
a1679 8
   /*
   REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
   REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
   */
   m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, MODE_VAL,
            cpu, DATA_CMMU, 0, 0);
   m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, MODE_VAL,
            cpu, INST_CMMU, 0, 0);
d1681 1
a1681 4

   

   splx(s);
d1687 3
a1689 5
   register s = splhigh();
   int cpu;
   cpu = cpu_number();


d1692 61
a1752 61
   if (size < 0 || size > NBSG ) {
      /*
      REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_INV_ALL;
      REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_INV_ALL;
      */
      m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_INV_ALL, MODE_VAL,
               cpu, DATA_CMMU, 0, 0);
      m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_INV_ALL, MODE_VAL,
               cpu, INST_CMMU, 0, 0);
   } else if (size <= 16) {
      /*
      REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
      REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_INV_LINE;
      */
      m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
               cpu, INST_CMMU, 0, (unsigned)physaddr);
      m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_LINE, MODE_VAL,
               cpu, INST_CMMU, 0, 0);
      /*
      REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
      REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_INV_LINE;
      */
      m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
               cpu, DATA_CMMU, 0, (unsigned)physaddr);
      m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_LINE, MODE_VAL,
               cpu, DATA_CMMU, 0, 0);
   } else if (size <= NBPG) {
      /*
      REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
      REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_INV_PAGE;
      */
      m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
               cpu, INST_CMMU, 0, (unsigned)physaddr);
      m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_PAGE, MODE_VAL,
               cpu, INST_CMMU, 0, 0);
      /*
      REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
      REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_INV_PAGE;
      */
      m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
               cpu, DATA_CMMU, 0, (unsigned)physaddr);
      m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_PAGE, MODE_VAL,
               cpu, DATA_CMMU, 0, 0);
   } else {
      /*
      REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
      REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_INV_SEGMENT;
      */
      m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
               cpu, INST_CMMU, 0, (unsigned)physaddr);
      m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_SEGMENT, MODE_VAL,
               cpu, INST_CMMU, 0, 0);
      /*
      REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
      REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_INV_SEGMENT;
      */
      m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
               cpu, DATA_CMMU, 0, (unsigned)physaddr);
      m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_SEGMENT, MODE_VAL,
               cpu, DATA_CMMU, 0, 0);
   }
d1754 8
a1761 8
   /*
   REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_INV_ALL;
   REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_INV_ALL;
   */
   m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_INV_ALL, MODE_VAL,
            cpu, DATA_CMMU, 0, 0);
   m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_INV_ALL, MODE_VAL,
            cpu, INST_CMMU, 0, 0);
d1764 1
a1764 3
   

   splx(s);
d1770 1
a1770 1
   int count;
d1773 2
a1774 1
   while (size) {
d1776 2
a1777 1
      count = NBPG - ((int)va & PGOFSET);
d1779 10
a1788 13
      if (size < count)
         count = size;

      if (op == DMA_CACHE_SYNC)
         m18x_cmmu_sync_cache(kvtop(va), count);
      else if (op == DMA_CACHE_SYNC_INVAL)
         m18x_cmmu_sync_inval_cache(kvtop(va), count);
      else
         m18x_cmmu_inval_cache(kvtop(va), count);

      va = (vm_offset_t)((int)va + count);
      size -= count;
   }
d1791 6
a1796 6
   if (op == DMA_CACHE_SYNC)
      m18x_cmmu_sync_cache(kvtop(va), size);
   else if (op == DMA_CACHE_SYNC_INVAL)
      m18x_cmmu_sync_inval_cache(kvtop(va), size);
   else
      m18x_cmmu_inval_cache(kvtop(va), size);
d1884 326
a2209 325
   /*
    * A virtual address is split into three fields. Two are used as
    * indicies into tables (segment and page), and one is an offset into
    * a page of memory.
    */
   union {
      unsigned bits;
      struct {
         unsigned segment_table_index:10,
         page_table_index:10,
         page_offset:12;
      } field;
   } virtual_address;
   unsigned value;

   if (verbose_flag)
      db_printf("-------------------------------------------\n");



   /****** ACCESS PROPER CMMU or THREAD ***********/
   #if 0 /* no thread */
   if (thread != 0) {
      /* the following tidbit from _pmap_activate in m88k/pmap.c */
      register apr_template_t apr_data;
      supervisor_flag = 0; /* thread implies user */

      if (thread->task == 0) {
         db_printf("[thread %x has empty task pointer]\n", thread);
         return;
      } else if (thread->task->map == 0) {
         db_printf("[thread/task %x/%x has empty map pointer]\n",
                   thread, thread->task);
         return;
      } else if (thread->task->map->pmap == 0) {
         db_printf("[thread/task/map %x/%x/%x has empty pmap pointer]\n",
                   thread, thread->task, thread->task->map);
         return;
      }
      if (thread->task->map->pmap->lock.lock_data) {
         db_printf("[Warning: thread %x's task %x's map %x's "
                   "pmap %x is locked]\n", thread, thread->task,
                   thread->task->map, thread->task->map->pmap);
      }
      apr_data.bits = 0;
      apr_data.field.st_base = M88K_BTOP(thread->task->map->pmap->sdt_paddr);
      apr_data.field.wt = 0;
      apr_data.field.g  = 1;
      apr_data.field.ci = 0;
      apr_data.field.te = 1;
      value = apr_data.bits;
      if (verbose_flag) {
         db_printf("[thread %x task %x map %x pmap %x UAPR is %x]\n",
                   thread, thread->task, thread->task->map,
                   thread->task->map->pmap, value);
      }
   } else
   #endif /* 0 */
   {
      if (cmmu_num == -1) {
         if (cpu_cmmu[0].pair[DATA_CMMU] == 0) {
            db_printf("ack! can't figure my own data cmmu number.\n");
            return;
         }
         cmmu_num = cpu_cmmu[0].pair[DATA_CMMU] - cmmu;
         if (verbose_flag)
            db_printf("The data cmmu for cpu#%d is cmmu#%d.\n",
                      0, cmmu_num);
      } else if (cmmu_num < 0 || cmmu_num >= MAX_CMMUS) {
         db_printf("invalid cpu number [%d]... must be in range [0..%d]\n",
                   cmmu_num, MAX_CMMUS - 1);
         
         return;
      }

      if (cmmu[cmmu_num].cmmu_alive == 0) {
         db_printf("warning: cmmu %d is not alive.\n", cmmu_num);
   #if 0
         
         return;
   #endif
      }

      if (!verbose_flag) {
         if (!(cmmu[cmmu_num].cmmu_regs->sctr & CMMU_SCTR_SE))
            db_printf("WARNING: snooping not enabled for CMMU#%d.\n",
                      cmmu_num);
      } else {
         int i;
         for (i=0; i<MAX_CMMUS; i++)
            if ((i == cmmu_num || cmmu[i].cmmu_alive) &&
                (verbose_flag>1 || !(cmmu[i].cmmu_regs->sctr&CMMU_SCTR_SE))) {
               db_printf("CMMU#%d (cpu %d %s) snooping %s\n", i,
                         cmmu[i].cmmu_cpu, cmmu[i].which ? "data" : "inst",
                         (cmmu[i].cmmu_regs->sctr & CMMU_SCTR_SE) ? "on":"OFF");
            }
      }

      if (supervisor_flag)
         value = cmmu[cmmu_num].cmmu_regs->sapr;
      else
         value = cmmu[cmmu_num].cmmu_regs->uapr;

   }

   /******* LOOK AT THE BATC ** (if not a thread) **************/
   #if 0
      #if SHADOW_BATC
   if (thread == 0) {
      int i;
      union batcu batc;
      for (i = 0; i < 8; i++) {
         batc.bits = cmmu[cmmu_num].batc[i];
         if (batc.field.v == 0) {
            if (verbose_flag>1)
               db_printf("cmmu #%d batc[%d] invalid.\n", cmmu_num, i);
         } else {
            db_printf("cmmu#%d batc[%d] v%08x p%08x", cmmu_num, i,
                      batc.field.lba << 18, batc.field.pba);
            if (batc.field.s)  db_printf(", supervisor");
            if (batc.field.wt) db_printf(", wt.th");
            if (batc.field.g)  db_printf(", global");
            if (batc.field.ci) db_printf(", cache inhibit");
            if (batc.field.wp) db_printf(", write protect");
         }
      }
   }
      #endif
   #endif /* 0 */

   /******* SEE WHAT A PROBE SAYS (if not a thread) ***********/
   #if 0
   if (thread == 0)
   #endif /* 0 */
   {
      union ssr ssr;
      struct cmmu_regs *cmmu_regs = cmmu[cmmu_num].cmmu_regs;
      cmmu_regs->sar = address;
      cmmu_regs->scr = supervisor_flag ? CMMU_PROBE_SUPER : CMMU_PROBE_USER;
      ssr.bits = cmmu_regs->ssr;
      if (verbose_flag > 1)
         db_printf("probe of 0x%08x returns ssr=0x%08x\n",
                   address, ssr.bits);
      if (ssr.field.v)
         db_printf("PROBE of 0x%08x returns phys=0x%x",
                   address, cmmu_regs->sar);
      else
         db_printf("PROBE fault at 0x%x", cmmu_regs->pfADDRr);
      if (ssr.field.ce) db_printf(", copyback err");
      if (ssr.field.be) db_printf(", bus err");
      if (ssr.field.wt) db_printf(", writethrough");
      if (ssr.field.sp) db_printf(", sup prot");
      if (ssr.field.g)  db_printf(", global");
      if (ssr.field.ci) db_printf(", cache inhibit");
      if (ssr.field.m)  db_printf(", modified");
      if (ssr.field.u)  db_printf(", used");
      if (ssr.field.wp) db_printf(", write prot");
      if (ssr.field.bh) db_printf(", BATC");
      db_printf(".\n");
   }

   /******* INTERPRET AREA DESCRIPTOR *********/
   {
      union apr_template apr_template;
      apr_template.bits = value;
      if (verbose_flag > 1) {
         db_printf("CMMU#%d", cmmu_num);
   #if 0
         if (thread == 0)
            db_printf("CMMU#%d", cmmu_num);
         else
            db_printf("THREAD %x", thread);
   #endif /* 0 */
         db_printf(" %cAPR is 0x%08x\n",
                   supervisor_flag ? 'S' : 'U', apr_template.bits);
      }
      db_printf("CMMU#%d", cmmu_num);
   #if 0
      if (thread == 0)
         db_printf("CMMU#%d", cmmu_num);
      else
         db_printf("THREAD %x", thread);
   #endif /* 0 */
      db_printf(" %cAPR: SegTbl: 0x%x000p",
                supervisor_flag ? 'S' : 'U', apr_template.field.st_base);
      if (apr_template.field.wt) db_printf(", WTHRU");
      else                       db_printf(", !wthru");
      if (apr_template.field.g)  db_printf(", GLOBAL");
      else                       db_printf(", !global");
      if (apr_template.field.ci) db_printf(", $INHIBIT");
      else                       db_printf(", $ok");
      if (apr_template.field.te) db_printf(", VALID");
      else                       db_printf(", !valid");
      db_printf(".\n");

      /* if not valid, done now */
      if (apr_template.field.te == 0) {
         db_printf("<would report an error, valid bit not set>\n");
         
         return;
      }

      value = apr_template.field.st_base << 12; /* now point to seg page */
   }

   /* translate value from physical to virtual */
   if (verbose_flag)
      db_printf("[%x physical is %x virtual]\n", value, value + VEQR_ADDR);
   value += VEQR_ADDR;

   virtual_address.bits = address;

   /****** ACCESS SEGMENT TABLE AND INTERPRET SEGMENT DESCRIPTOR  *******/
   {
      union sdt_entry_template std_template;
      if (verbose_flag)
         db_printf("will follow to entry %d of page at 0x%x...\n",
                   virtual_address.field.segment_table_index, value);
      value |= virtual_address.field.segment_table_index *
               sizeof(struct sdt_entry);

      if (badwordaddr(value)) {
         db_printf("ERROR: unable to access page at 0x%08x.\n", value);
         
         return;
      }

      std_template.bits = *(unsigned *)value;
      if (verbose_flag > 1)
         db_printf("SEG DESC @@0x%x is 0x%08x\n", value, std_template.bits);
      db_printf("SEG DESC @@0x%x: PgTbl: 0x%x000",
                value, std_template.sdt_desc.table_addr);
      if (std_template.sdt_desc.wt)       db_printf(", WTHRU");
      else                                db_printf(", !wthru");
      if (std_template.sdt_desc.sup)      db_printf(", S-PROT");
      else                                db_printf(", UserOk");
      if (std_template.sdt_desc.g)        db_printf(", GLOBAL");
      else                                db_printf(", !global");
      if (std_template.sdt_desc.no_cache) db_printf(", $INHIBIT");
      else                                db_printf(", $ok");
      if (std_template.sdt_desc.prot)     db_printf(", W-PROT");
      else                                db_printf(", WriteOk");
      if (std_template.sdt_desc.dtype)    db_printf(", VALID");
      else                                db_printf(", !valid");
      db_printf(".\n");

      /* if not valid, done now */
      if (std_template.sdt_desc.dtype == 0) {
         db_printf("<would report an error, STD entry not valid>\n");
         
         return;
      }

      value = std_template.sdt_desc.table_addr << 12;
   }

   /* translate value from physical to virtual */
   if (verbose_flag)
      db_printf("[%x physical is %x virtual]\n", value, value + VEQR_ADDR);
   value += VEQR_ADDR;

   /******* PAGE TABLE *********/
   {
      union pte_template pte_template;
      if (verbose_flag)
         db_printf("will follow to entry %d of page at 0x%x...\n",
                   virtual_address.field.page_table_index, value);
      value |= virtual_address.field.page_table_index *
               sizeof(struct pt_entry);

      if (badwordaddr(value)) {
         db_printf("error: unable to access page at 0x%08x.\n", value);
         
         return;
      }

      pte_template.bits = *(unsigned *)value;
      if (verbose_flag > 1)
         db_printf("PAGE DESC @@0x%x is 0x%08x.\n", value, pte_template.bits);
      db_printf("PAGE DESC @@0x%x: page @@%x000",
                value, pte_template.pte.pfn);
      if (pte_template.pte.wired)    db_printf(", WIRE");
      else                           db_printf(", !wire");
      if (pte_template.pte.wt)       db_printf(", WTHRU");
      else                           db_printf(", !wthru");
      if (pte_template.pte.sup)      db_printf(", S-PROT");
      else                           db_printf(", UserOk");
      if (pte_template.pte.g)        db_printf(", GLOBAL");
      else                           db_printf(", !global");
      if (pte_template.pte.ci)       db_printf(", $INHIBIT");
      else                           db_printf(", $ok");
      if (pte_template.pte.modified) db_printf(", MOD");
      else                           db_printf(", !mod");
      if (pte_template.pte.pg_used)  db_printf(", USED");
      else                           db_printf(", !used");
      if (pte_template.pte.prot)     db_printf(", W-PROT");
      else                           db_printf(", WriteOk");
      if (pte_template.pte.dtype)    db_printf(", VALID");
      else                           db_printf(", !valid");
      db_printf(".\n");

      /* if not valid, done now */
      if (pte_template.pte.dtype == 0) {
         db_printf("<would report an error, PTE entry not valid>\n");
         
         return;
      }

      value = pte_template.pte.pfn << 12;
      if (verbose_flag)
         db_printf("will follow to byte %d of page at 0x%x...\n",
                   virtual_address.field.page_offset, value);
      value |= virtual_address.field.page_offset;

      if (badwordaddr(value)) {
         db_printf("error: unable to access page at 0x%08x.\n", value);
         
         return;
      }
   }

   /* translate value from physical to virtual */
   if (verbose_flag)
      db_printf("[%x physical is %x virtual]\n", value, value + VEQR_ADDR);
   value += VEQR_ADDR;
a2210 2
   db_printf("WORD at 0x%x is 0x%08x.\n", value, *(unsigned *)value);
   
a2212 1

d2216 49
a2264 49
   static char *vv_name[4] =
   {"exclu-unmod", "exclu-mod", "shared-unmod", "invalid"};
   int cmmu_num;

   for (cmmu_num = 0; cmmu_num < MAX_CMMUS; cmmu_num++) {
      union ssr ssr;
      union cssp cssp;
      struct cmmu_regs *R;
      unsigned tag, line;
      if (!cmmu[cmmu_num].cmmu_alive)
         continue;
      R = cmmu[cmmu_num].cmmu_regs;
      db_printf("cmmu #%d %s cmmu for cpu %d.\n", cmmu_num,
                cmmu[cmmu_num].which ? "data" : "inst", 
                cmmu[cmmu_num].cmmu_cpu);
      R->sar = addr;
      R->scr = supervisor_flag ? CMMU_PROBE_SUPER : CMMU_PROBE_USER;

      ssr.bits = R->ssr;
      if (!ssr.field.v) {
         db_printf("PROBE of 0x%08x faults.\n",addr);
         continue;
      }
      db_printf("PROBE of 0x%08x returns phys=0x%x", addr, R->sar);

      tag = R->sar & ~0xfff;
      cssp.bits = R->cssp;

      /* check to see if any of the tags for the set match the address */
      for (line = 0; line < 4; line++) {
         if (VV(cssp, line) == VV_INVALID) {
            db_printf("line %d invalid.\n", line);
            continue; /* line is invalid */
         }
         if (D(cssp, line)) {
            db_printf("line %d disabled.\n", line);
            continue; /* line is disabled */
         }

         if ((R->ctp[line] & ~0xfff) != tag) {
            db_printf("line %d address tag is %x.\n", line,
                      (R->ctp[line] & ~0xfff));
            continue;
         }
         db_printf("found in line %d as %08x (%s).\n",
                   line, R->cdp[line], vv_name[VV(cssp, line)]);
      }
   }
   
d2268 1
d2271 2
a2272 2
   int cmmu_num;
   m18x_cmmu_cache_state(addr, 1);
d2274 7
a2280 7
   for (cmmu_num = 0; cmmu_num < MAX_CMMUS; cmmu_num++)
      if (cmmu[cmmu_num].cmmu_alive) {
         db_printf("cmmu #%d %s cmmu for cpu %d: ", cmmu_num,
                   cmmu[cmmu_num].which ? "data" : "inst", 
                   cmmu[cmmu_num].cmmu_cpu);
         m18x_cmmu_show_translation(addr, 1, 0, cmmu_num);
      }
a2281 1
#endif /* end if DDB */
@


1.1
log
@Added to support MVME188 and MVME197
@
text
@d1 1
a31 1
 *	$Id: cmmu.c,v 1.4 1998/12/15 05:11:01 smurph Exp $
@


1.1.4.1
log
@Sync with -current
@
text
@a0 1
/*	$OpenBSD$	*/
d31 1
@


1.1.4.2
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: m18x_cmmu.c,v 1.8 2001/03/18 01:49:39 miod Exp $	*/
a62 1
#include <sys/systm.h>
a63 2

#include <machine/asm_macro.h>
a66 1
#include <machine/locore.h>
a68 10
#ifdef DDB
#include <ddb/db_output.h>		/* db_printf()		*/
#endif /* DDB */

#ifdef DDB
#define DEBUG_MSG db_printf
#else
#define DEBUG_MSG printf
#endif /* DDB */

d72 1
a72 1
#define CMMU_DEBUG
d75 3
a77 11
#define DB_CMMU	0x4000	/* MMU debug */
unsigned int m18x_debuglevel = 0;
#define dprintf(_L_,_X_) \
	do { \
		if (m18x_debuglevel & (_L_)) { \
			unsigned int psr = disable_interrupts_return_psr(); \
			printf("%d: ", cpu_number()); \
			printf _X_;  \
			set_psr(psr); \
		} \
	} while (0)
d79 1
a79 1
#define dprintf(_L_,_X_) do { } while (0)
d84 2
a85 1
   /* base + $000 */volatile unsigned idr; 
d116 14
a129 14
	struct cmmu_regs *cmmu_regs;	/* CMMU "base" area */
	unsigned char  cmmu_cpu;	/* cpu number it is attached to */
	unsigned char  which;		/* either INST_CMMU || DATA_CMMU */
	unsigned char  cmmu_access;	/* either CMMU_ACS_{SUPER,USER,BOTH} */
	unsigned char  cmmu_alive;
#define CMMU_DEAD	0		/* This cmmu not there */
#define CMMU_AVAILABLE	1		/* It's there, but which cpu's? */
#define CMMU_ALIVE	1		/* It's there. */
#define CMMU_MARRIED	2		/* Know which cpu it belongs to. */
	vm_offset_t    cmmu_addr;	/* address range */
	vm_offset_t    cmmu_addr_mask;	/* address mask */
	int            cmmu_addr_match;	/* return value of address comparison */
#ifdef SHADOW_BATC
	unsigned batc[8];
d163 3
a165 13
/* prototypes */
void m18x_setup_cmmu_config __P((void));
void m18x_setup_board_config __P((void));
#if defined(CMMU_DEBUG)
void m18x_show_apr __P((unsigned value));
void m18x_show_sctr __P((unsigned value));
#endif
unsigned m18x_cmmu_get __P((int mmu, int reg));
void m18x_cmmu_set __P((int reg, unsigned val, int flags, int num,
    int mode, int access, vm_offset_t addr));
void m18x_cmmu_sync_cache __P((vm_offset_t physaddr, int size));
void m18x_cmmu_sync_inval_cache __P((vm_offset_t physaddr, int size));
void m18x_cmmu_inval_cache __P((vm_offset_t physaddr, int size));
d169 1
a169 2
m18x_show_apr(value)
	unsigned value;
d171 2
a172 2
	union apr_template apr_template;
	apr_template.bits = value;
d174 7
a180 7
	printf("table @@ 0x%x000", apr_template.field.st_base);
	if (apr_template.field.wt) printf(", writethrough");
	if (apr_template.field.g)  printf(", global");
	if (apr_template.field.ci) printf(", cache inhibit");
	if (apr_template.field.te) printf(", valid");
	else			   printf(", not valid");
	printf("\n");
d184 17
a200 18
m18x_show_sctr(value)
	unsigned value;
{
	union {
		unsigned bits;
		struct {
			unsigned :16,
			pe: 1,
			se: 1,
			pr: 1,
			:13;
		} fields;
	} sctr; 
	sctr.bits = value;
	printf("%spe, %sse %spr]\n",
	       sctr.fields.pe ? "" : "!",
	       sctr.fields.se ? "" : "!",
	       sctr.fields.pr ? "" : "!");
d204 3
a206 1
/*----------------------------------------------------------------
d244 2
a245 2
	int inst;
	int data;
d247 5
a251 5
	/*     inst                 data */
	{ CMMU_SPLIT_SPV,      CMMU_SPLIT_SPV},	 /* CPU 0 */
	{ CMMU_SPLIT_SPV,      CMMU_SPLIT_SPV},	 /* CPU 1 */
	{ CMMU_SPLIT_ADDRESS,  CMMU_SPLIT_ADDRESS}, /* CPU 2 */
	{ CMMU_SPLIT_ADDRESS,  CMMU_SPLIT_ADDRESS}  /* CPU 3 */
d259 3
a261 3
	int supported;
	int ncpus;
	int ncmmus;
d264 17
a280 17
	/* sup, CPU MMU */
	{  1,  4,  8}, /* 4P128 - 4P512 */
	{  1,  2,  8}, /* 2P128 - 2P512 */
	{  1,  1,  8}, /* 1P128 - 1P512 */
	{  0, -1, -1},
	{  0, -1, -1},
	{  1,  2,  4}, /* 2P64  - 2P256 */
	{  1,  1,  4}, /* 1P64  - 1P256 */
	{  0, -1, -1},
	{  0, -1, -1},
	{  0, -1, -1},
	{  1,  1,  2}, /* 1P32  - 1P128 */
	{  0, -1, -1},
	{  0, -1, -1},
	{  0, -1, -1},
	{  0, -1, -1},
	{  0, -1, -1}
d289 18
a306 18
	/* addr    cpu       mode           access
      alive   addr mask */
	{(void *)VME_CMMU_I0, -1, INST_CMMU, CMMU_ACS_BOTH, 
		CMMU_DEAD, 0, 0},                                 
	{(void *)VME_CMMU_D0, -1, DATA_CMMU, CMMU_ACS_BOTH,       
		CMMU_DEAD, 0, 0},                                 
	{(void *)VME_CMMU_I1, -1, INST_CMMU, CMMU_ACS_BOTH,       
		CMMU_DEAD, 0, 0},                                 
	{(void *)VME_CMMU_D1, -1, DATA_CMMU, CMMU_ACS_BOTH,       
		CMMU_DEAD, 0, 0},                                 
	{(void *)VME_CMMU_I2, -1, INST_CMMU, CMMU_ACS_BOTH,
		CMMU_DEAD, 0, 0},
	{(void *)VME_CMMU_D2, -1, DATA_CMMU, CMMU_ACS_BOTH,
		CMMU_DEAD, 0, 0},
	{(void *)VME_CMMU_I3, -1, INST_CMMU, CMMU_ACS_BOTH,
		CMMU_DEAD, 0, 0},
	{(void *)VME_CMMU_D3, -1, DATA_CMMU, CMMU_ACS_BOTH,
		CMMU_DEAD, 0, 0}
d310 1
a310 1
	struct cmmu *pair[2];
d314 1
a314 1
m18x_setup_board_config()
d316 1
a316 1
	volatile unsigned long *whoami;
d318 48
a365 56
	master_cpu = 0;	/* temp to get things going */
	switch (cputyp) {
#ifdef MVME187
	case CPU_187:
#endif
#ifdef MVME197
	case CPU_197:
#endif
#if defined(MVME187) || defined(MVME197)
		vme188_config = 10; /* There is no WHOAMI reg on MVME1x7 - fake it... */
		cmmu[0].cmmu_regs = (void *)SBC_CMMU_I;
		cmmu[0].cmmu_cpu = 0;
		cmmu[1].cmmu_regs = (void *)SBC_CMMU_D;
		cmmu[1].cmmu_cpu = 0;
		cmmu[2].cmmu_regs = (void *)NULL;
		cmmu[3].cmmu_regs = (void *)NULL;
		cmmu[4].cmmu_regs = (void *)NULL;
		cmmu[5].cmmu_regs = (void *)NULL;
		cmmu[6].cmmu_regs = (void *)NULL;
		cmmu[7].cmmu_regs = (void *)NULL;
		max_cpus = 1;
		max_cmmus = 2;
		break;
#endif /* defined(MVME187) || defined(MVME197) */
#ifdef MVME188
	case CPU_188:
		whoami = (volatile unsigned long *)MVME188_WHOAMI;
		vme188_config = (*whoami & 0xf0) >> 4;
		dprintf(DB_CMMU,("m18x_setup_board_config: WHOAMI @@ 0x%08x holds value 0x%08x vme188_config = %d\n",
				 whoami, *whoami, vme188_config));
		max_cpus = bd_config[vme188_config].ncpus;
		max_cmmus = bd_config[vme188_config].ncmmus;
		break;
#endif /* MVME188 */
	default:
		panic("m18x_setup_board_config: Unknown CPU type.");
	}
	cpu_cmmu_ratio = max_cmmus / max_cpus;
	switch (bd_config[vme188_config].supported) {
	case 0:
		printf("MVME%x board configuration #%X: %d CPUs %d CMMUs\n", cputyp, 
		       vme188_config, max_cpus, max_cmmus);
		panic("This configuration is not supported - go and get another OS.\n");
		/* NOTREACHED */
		break;
	case 1:
		printf("MVME%x board configuration #%X: %d CPUs %d CMMUs\n", cputyp,
		       vme188_config, max_cpus, max_cmmus);
		m18x_setup_cmmu_config();
		break;
	default:
		panic("UNKNOWN MVME%x board configuration: WHOAMI = 0x%02x\n", cputyp, *whoami);
		/* NOTREACHED */
		break;
	}
	return;
d373 1
a373 1
m18x_setup_cmmu_config()
d375 2
a376 6
	register int num, cmmu_num;
#ifdef MVME188
	register int val1, val2;
	volatile unsigned long *pcnfa;
	volatile unsigned long *pcnfb;
#endif 
d378 1
a378 2
	dprintf(DB_CMMU,("m18x_setup_cmmu_config: initializing with %d CPU(s) and %d CMMU(s)\n",
			 max_cpus, max_cmmus));
d380 191
a570 192
	/*
	 * Probe for available MMUs
	 */
	for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++)
		if (!badwordaddr((vm_offset_t)cmmu[cmmu_num].cmmu_regs)) {
			union cpupid id;

			id.cpupid = cmmu[cmmu_num].cmmu_regs->idr;
			if (id.m88200.type != M88200 && id.m88200.type != M88204) {
				printf("WARNING: non M8820x circuit found at CMMU address 0x%08x\n",
				       cmmu[cmmu_num].cmmu_regs);
				continue;
			}
			cmmu[cmmu_num].cmmu_alive = CMMU_ALIVE;
			dprintf(DB_CMMU,("m18x_setup_cmmu_config: CMMU %d found at 0x%08x\n",
					 cmmu_num, cmmu[cmmu_num].cmmu_regs));
		}

		/*
		 * Now that we know which CMMUs are there, let's report on which
		 * CPU/CMMU sets seem complete (hopefully all)
		 */
	for (num = 0; num < max_cpus; num++) {
		register int i;
		union cpupid id;

		for (i = 0; i < cpu_cmmu_ratio; i++) {
			dprintf(DB_CMMU,("cmmu_init: testing CMMU %d for CPU %d\n",
					 num*cpu_cmmu_ratio+i, num));
			if (!m18x_cmmu_alive(num*cpu_cmmu_ratio + i)) {
				printf("CMMU %d attached to CPU %d is not working\n");
				panic("m18x_setup_cmmu_config");
			}
		}
		cpu_sets[num] = 1;   /* This cpu installed... */
		id.cpupid = cmmu[num*cpu_cmmu_ratio].cmmu_regs->idr;

		if (id.m88200.type == M88204)
			printf("CPU%d is attached with %d MC88204 CMMUs\n",
			       num, cpu_cmmu_ratio);
		else
			printf("CPU%d is attached with %d MC88200 CMMUs\n",
			       num, cpu_cmmu_ratio);
	}

	for (num = 0; num < max_cpus; num++) {
		cpu_cmmu_strategy[num].inst &= CMMU_SPLIT_MASK;
		cpu_cmmu_strategy[num].data &= CMMU_SPLIT_MASK;
		dprintf(DB_CMMU,("m18x_setup_cmmu_config: CPU %d inst strat %d data strat %d\n",
				 num, cpu_cmmu_strategy[num].inst, cpu_cmmu_strategy[num].data));
	}

	switch (vme188_config) {
	/*
	 * These configurations have hardwired CPU/CMMU configurations.
	 */
	case CONFIG_0:
	case CONFIG_5:
	case CONFIG_A:
		dprintf(DB_CMMU,("m18x_setup_cmmu_config: resetting strategies\n"));
		for (num = 0; num < max_cpus; num++)
			cpu_cmmu_strategy[num].inst = cpu_cmmu_strategy[num].data =
						      CMMU_SPLIT_ADDRESS;
		break;
#ifdef MVME188
	/*
	 * Configure CPU/CMMU strategy into PCNFA and PCNFB board registers.
	 */
	case CONFIG_1:
		pcnfa = (volatile unsigned long *)MVME188_PCNFA;
		pcnfb = (volatile unsigned long *)MVME188_PCNFB;
		val1 = (cpu_cmmu_strategy[0].inst << 2) | cpu_cmmu_strategy[0].data;
		val2 = (cpu_cmmu_strategy[1].inst << 2) | cpu_cmmu_strategy[1].data;
		*pcnfa = val1;
		*pcnfb = val2;
		dprintf(DB_CMMU,("m18x_setup_cmmu_config: 2P128: PCNFA = 0x%x, PCNFB = 0x%x\n", val1, val2));
		break;
	case CONFIG_2:
		pcnfa = (volatile unsigned long *)MVME188_PCNFA;
		pcnfb = (volatile unsigned long *)MVME188_PCNFB;
		val1 = (cpu_cmmu_strategy[0].inst << 2) | cpu_cmmu_strategy[0].inst;
		val2 = (cpu_cmmu_strategy[0].data << 2) | cpu_cmmu_strategy[0].data;
		*pcnfa = val1;
		*pcnfb = val2;
		dprintf(DB_CMMU,("m18x_setup_cmmu_config: 1P128: PCNFA = 0x%x, PCNFB = 0x%x\n", val1, val2));
		break;
	case CONFIG_6:
		pcnfa = (volatile unsigned long *)MVME188_PCNFA;
		val1 = (cpu_cmmu_strategy[0].inst << 2) | cpu_cmmu_strategy[0].data;
		*pcnfa = val1;
		dprintf(DB_CMMU,("m18x_setup_cmmu_config: 1P64: PCNFA = 0x%x\n", val1));
		break;
#endif /* MVME188 */
	default:
		panic("m18x_setup_cmmu_config");
		break;
	}

#ifdef MVME188
	dprintf(DB_CMMU,("m18x_setup_cmmu_config: PCNFA = 0x%x, PCNFB = 0x%x\n", *pcnfa, *pcnfb));
#endif /* MVME188 */

	/*
	 * Calculate the CMMU<->CPU connections
	 */
	for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++) {
		cmmu[cmmu_num].cmmu_cpu =
		(int) (((float) cmmu_num) * ((float) max_cpus) / ((float) max_cmmus));
		dprintf(DB_CMMU,("m18x_setup_cmmu_config: CMMU %d connected with CPU %d\n",
				 cmmu_num, cmmu[cmmu_num].cmmu_cpu));
	}

	/*
	 * Now set cmmu[].cmmu_access and addr
	 */
	for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++) {
		/*
		 * We don't set up anything for the hardwired configurations.
		 */
		if (cpu_cmmu_ratio == 2) {
			cmmu[cmmu_num].cmmu_addr =
			cmmu[cmmu_num].cmmu_addr_mask = 0;
			cmmu[cmmu_num].cmmu_addr_match = 1;
			cmmu[cmmu_num].cmmu_access = CMMU_ACS_BOTH;
			continue;
		}

		/*
		 * First we set the address/mask pairs for the exact address
		 * matches.
		 */
		switch ((cmmu[cmmu_num].which == INST_CMMU) ?
			cpu_cmmu_strategy[cmmu[cmmu_num].cmmu_cpu].inst :
			cpu_cmmu_strategy[cmmu[cmmu_num].cmmu_cpu].data) {
		case CMMU_SPLIT_ADDRESS:
			cmmu[cmmu_num].cmmu_addr = ((cmmu_num & 0x2) ^ 0x2) << 11;
			cmmu[cmmu_num].cmmu_addr_mask = CMMU_A12_MASK;
			cmmu[cmmu_num].cmmu_addr_match = 1;
			break;
		case CMMU_SPLIT_SPV:
			cmmu[cmmu_num].cmmu_addr =
			cmmu[cmmu_num].cmmu_addr_mask = 0;
			cmmu[cmmu_num].cmmu_addr_match = 1;
			break;
		case CMMU_SPLIT_SRAM_ALL:
			cmmu[cmmu_num].cmmu_addr = CMMU_SRAM;
			cmmu[cmmu_num].cmmu_addr_mask = CMMU_SRAM_MASK;
			cmmu[cmmu_num].cmmu_addr_match = (cmmu_num & 0x2) ? 1 : 0;
			break;
		case CMMU_SPLIT_SRAM_SPV:
			if (cmmu_num & 0x2) {
				cmmu[cmmu_num].cmmu_addr = CMMU_SRAM;
				cmmu[cmmu_num].cmmu_addr_mask = CMMU_SRAM_MASK;
			} else {
				cmmu[cmmu_num].cmmu_addr =
				cmmu[cmmu_num].cmmu_addr_mask = 0;
			}
			cmmu[cmmu_num].cmmu_addr_match = 1;
			break;
		}

		/*
		 * For MVME188 single processors, we've got to look at A14.
		 * This bit splits the CMMUs independent of the enabled strategy.
		 *
		 * NOT TESTED!!! - em
		 */
		if (cpu_cmmu_ratio > 4) {
			cmmu[cmmu_num].cmmu_addr |= ((cmmu_num & 0x4) ^ 0x4) << 12;
			cmmu[cmmu_num].cmmu_addr_mask |= CMMU_A14_MASK;
		}

		/*
		 * Next we cope with the various access modes.
		 */
		switch ((cmmu[cmmu_num].which == INST_CMMU) ?
			cpu_cmmu_strategy[cmmu[cmmu_num].cmmu_cpu].inst :
			cpu_cmmu_strategy[cmmu[cmmu_num].cmmu_cpu].data) {
		case CMMU_SPLIT_SPV:
			cmmu[cmmu_num].cmmu_access =
			(cmmu_num & 0x2 ) ? CMMU_ACS_USER : CMMU_ACS_SUPER;
			break;
		case CMMU_SPLIT_SRAM_SPV:
			cmmu[cmmu_num].cmmu_access =
			(cmmu_num & 0x2 ) ? CMMU_ACS_SUPER : CMMU_ACS_BOTH;
			break;
		default:
			cmmu[cmmu_num].cmmu_access = CMMU_ACS_BOTH;
			break;
		}
	}
	return;
a572 1
#ifdef MVME188
d574 4
a577 4
	"address split ",
	"user/spv split",
	"spv SRAM split",
	"all SRAM split"
a578 1
#endif 
d580 1
a580 2
void 
m18x_cmmu_dump_config()
d582 27
a608 42
#ifdef MVME188
	volatile unsigned long *pcnfa;
	volatile unsigned long *pcnfb;
	register int cmmu_num;
#endif /* MVME188 */

	DEBUG_MSG("Current CPU/CMMU configuration:\n\n");

	switch (cputyp) {
#ifdef MVME187
	case CPU_187:
#endif
#ifdef MVME197
	case CPU_197:
#endif
#if defined(MVME187) || defined(MVME197)
		DEBUG_MSG("VME1x7 split mode\n\n");
#endif /* defined(MVME187) || defined(MVME197) */
#ifdef MVME188
	case CPU_188:
		DEBUG_MSG("VME188 address decoder: PCNFA = 0x%1x, PCNFB = 0x%1x\n\n", *pcnfa & 0xf, *pcnfb & 0xf);
		pcnfa = (volatile unsigned long *)MVME188_PCNFA;
		pcnfb = (volatile unsigned long *)MVME188_PCNFB;
		for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++) {
			DEBUG_MSG("CMMU #%d: %s CMMU for CPU %d:\n Strategy: %s\n %s access addr 0x%08x mask 0x%08x match %s\n",
				  cmmu_num,
				  (cmmu[cmmu_num].which == INST_CMMU) ? "inst" : "data",
				  cmmu[cmmu_num].cmmu_cpu,
				  cmmu_strat_string[(cmmu[cmmu_num].which == INST_CMMU) ?
						    cpu_cmmu_strategy[cmmu[cmmu_num].cmmu_cpu].inst :
						    cpu_cmmu_strategy[cmmu[cmmu_num].cmmu_cpu].data],
				  (cmmu[cmmu_num].cmmu_access == CMMU_ACS_BOTH) ?   "User and spv" :
				  ((cmmu[cmmu_num].cmmu_access == CMMU_ACS_USER) ? "User        " :
				   "Supervisor  "),
				  cmmu[cmmu_num].cmmu_addr,
				  cmmu[cmmu_num].cmmu_addr_mask,
				  cmmu[cmmu_num].cmmu_addr_match ? "TRUE" : "FALSE");
		}
#endif /* MVME188 */
	default:
		DEBUG_MSG("Unknown CPU\n\n");
	}
d613 1
a613 3
m18x_cmmu_store(mmu, reg, val)
	int mmu, reg;
	unsigned val;
d615 1
a615 1
	*(volatile unsigned *)(reg + (char*)(cmmu[mmu].cmmu_regs)) = val;
d618 1
a618 3
int 
m18x_cmmu_alive(mmu)
	int mmu;
d620 1
a620 1
	return (cmmu[mmu].cmmu_alive == CMMU_ALIVE);
d623 1
a623 3
unsigned 
m18x_cmmu_get(mmu, reg)
	int mmu, reg;
d625 1
a625 1
	return *(volatile unsigned *)(reg + (char*)(cmmu[mmu].cmmu_regs));
d632 35
a666 39
void 
m18x_cmmu_set(reg, val, flags, num, mode, access, addr)
	int reg;
	unsigned val;
	int flags, num, mode, access;
	vm_offset_t addr;
{
	register int mmu;

	if (flags & NUM_CMMU) {
		/*
		 * Special case: user supplied CMMU number directly as argument.
		 * Simply store the value away.
		 */
		/* assert(num < max_cmmus); */
		m18x_cmmu_store(num, reg, val);
		return;
	}

	/*
	 * We scan all CMMUs to find the matching ones and store the
	 * values there.
	 */
	for (mmu = num*cpu_cmmu_ratio; mmu < (num+1)*cpu_cmmu_ratio; mmu++) {
		if (((flags & MODE_VAL)) &&
		    (cmmu[mmu].which != mode))
			continue;
		if (((flags & ACCESS_VAL)) &&
		    (cmmu[mmu].cmmu_access != access) &&
		    (cmmu[mmu].cmmu_access != CMMU_ACS_BOTH))
			continue;
		if (flags & ADDR_VAL) {
			if (((addr & cmmu[mmu].cmmu_addr_mask) == cmmu[mmu].cmmu_addr)
			    != cmmu[mmu].cmmu_addr_match) {
				continue;
			}
		}
		m18x_cmmu_store(mmu, reg, val);
	}
d673 10
a682 14
unsigned 
m18x_cmmu_get_by_mode(cpu, mode)
	int cpu, mode;
{
	register int mmu;

	for (mmu = cpu*cpu_cmmu_ratio; mmu < (cpu+1)*cpu_cmmu_ratio; mmu++)
		if (cmmu[mmu].which == mode)
			return mmu;
	printf("can't figure out first %s CMMU for CPU %d\n",
	       (mode == DATA_CMMU) ? "data" : "instruction", cpu);
	panic("m18x_cmmu_get_by_mode");
	/* NOTREACHED */
	return(0);
d687 8
a694 8
	"Unknown (0)",
	"Unknown (1)",
	"Unknown (2)",
	"Unknown (3)",
	"Unknown (4)",
	"M88200 (16K)",
	"M88204 (64K)",
	"Unknown (7)"
d702 1
a702 3
void 
m18x_cpu_configuration_print(master)
	int master;
d704 21
a724 21
	int pid = read_processor_identification_register();
	int proctype = (pid & 0xff00) >> 8;
	int procvers = (pid & 0xe) >> 1;
	int mmu, cpu = cpu_number();
	struct simplelock print_lock;

	if (master)
		simple_lock_init(&print_lock);

	simple_lock(&print_lock);

	printf("Processor %d: ", cpu);
	if (proctype)
		printf("Architectural Revision 0x%x UNKNOWN CPU TYPE Version 0x%x\n",
		       proctype, procvers);
	else
		printf("M88100 Version 0x%x\n", procvers);

#ifndef ERRATA__XXX_USR
	if (procvers < 2)
		printf("WARNING: M88100 bug workaround code not enabled!!!\n");
d727 17
a743 17
	for (mmu = cpu*cpu_cmmu_ratio; mmu < (cpu+1)*cpu_cmmu_ratio; mmu++) {
		int idr = m18x_cmmu_get(mmu, CMMU_IDR);
		int mmuid = (0xe00000 & idr)>>21;

		printf(" %s %s Cache: ",
		       (cmmu[mmu].cmmu_access == CMMU_ACS_BOTH) ?  "Spv and User" :
		       ((cmmu[mmu].cmmu_access == CMMU_ACS_USER) ? "User        " :
			"Supervisor  "),
		       (cmmu[mmu].which == INST_CMMU) ?   "Instruction" :
		       "Data       ");
		if (mmutypes[mmuid][0] == 'U')
			printf("Type 0x%x ", mmuid);
		else
			printf("%s ", mmutypes[mmuid]);
		printf("Version 0x%x\n", (idr & 0x1f0000)>>16);
	}
	printf  (" Configured as %s and started\n", master ? "master" : "slave");
d745 1
a745 1
	simple_unlock(&print_lock);
d752 1
a752 1
m18x_cmmu_init()
d754 68
a821 68
	unsigned tmp, cmmu_num;
	union cpupid id;
	int cpu;

	for (cpu = 0; cpu < max_cpus; cpu++) {
		cpu_cmmu[cpu].pair[INST_CMMU] = cpu_cmmu[cpu].pair[DATA_CMMU] = 0;
	}

	for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++){
		if (m18x_cmmu_alive(cmmu_num)) {
			id.cpupid = cmmu[cmmu_num].cmmu_regs->idr;

			cpu_cmmu[cmmu[cmmu_num].cmmu_cpu].pair[cmmu[cmmu_num].which] =
			&cmmu[cmmu_num];
			/*
			 * Reset cache data....
			 * as per M88200 Manual (2nd Ed.) section 3.11.
			 */
			for (tmp = 0; tmp < 255; tmp++) {
				cmmu[cmmu_num].cmmu_regs->sar = tmp << 4;
				cmmu[cmmu_num].cmmu_regs->cssp = 0x3f0ff000;
			}

			/* 88204 has additional cache to clear */
			if (id.m88200.type == M88204) {
				for (tmp = 0; tmp < 255; tmp++) {
					cmmu[cmmu_num].cmmu_regs->sar = tmp<<4;
					cmmu[cmmu_num].cmmu_regs->cssp1 = 0x3f0ff000;
				}
				for (tmp = 0; tmp < 255; tmp++) {
					cmmu[cmmu_num].cmmu_regs->sar = tmp<<4;
					cmmu[cmmu_num].cmmu_regs->cssp2 = 0x3f0ff000;
				}
				for (tmp = 0; tmp < 255; tmp++) {
					cmmu[cmmu_num].cmmu_regs->sar = tmp<<4;
					cmmu[cmmu_num].cmmu_regs->cssp3 = 0x3f0ff000;
				}
			}

			/*
			 * Set the SCTR, SAPR, and UAPR to some known state
			 * (I don't trust the reset to do it).
			 */
			tmp =
			! CMMU_SCTR_PE |   /* not parity enable */
			! CMMU_SCTR_SE | /* not snoop enable */
			! CMMU_SCTR_PR ;  /* not priority arbitration */
			cmmu[cmmu_num].cmmu_regs->sctr = tmp;

			tmp =
			(0x00000 << 12) |  /* segment table base address */
			AREA_D_WT |	 /* write through */
			AREA_D_G  | /* global */
			AREA_D_CI | /* cache inhibit */
			! AREA_D_TE ;	/* not translation enable */
			cmmu[cmmu_num].cmmu_regs->sapr =
			cmmu[cmmu_num].cmmu_regs->uapr = tmp;


#ifdef SHADOW_BATC
			cmmu[cmmu_num].batc[0] =
			cmmu[cmmu_num].batc[1] =
			cmmu[cmmu_num].batc[2] =
			cmmu[cmmu_num].batc[3] =
			cmmu[cmmu_num].batc[4] =
			cmmu[cmmu_num].batc[5] =
			cmmu[cmmu_num].batc[6] =
			cmmu[cmmu_num].batc[7] = 0;
d823 74
a896 74
			cmmu[cmmu_num].cmmu_regs->bwp[0] = 
			cmmu[cmmu_num].cmmu_regs->bwp[1] = 
			cmmu[cmmu_num].cmmu_regs->bwp[2] = 
			cmmu[cmmu_num].cmmu_regs->bwp[3] = 
			cmmu[cmmu_num].cmmu_regs->bwp[4] = 
			cmmu[cmmu_num].cmmu_regs->bwp[5] = 
			cmmu[cmmu_num].cmmu_regs->bwp[6] = 
			cmmu[cmmu_num].cmmu_regs->bwp[7] = 0;
			cmmu[cmmu_num].cmmu_regs->scr = CMMU_FLUSH_CACHE_INV_ALL;
			cmmu[cmmu_num].cmmu_regs->scr = CMMU_FLUSH_SUPER_ALL;
			cmmu[cmmu_num].cmmu_regs->scr = CMMU_FLUSH_USER_ALL;
		}
	}
	/*
	 * Enable snooping...
	 */
	for (cpu = 0; cpu < max_cpus; cpu++) {
		if (!cpu_sets[cpu])
			continue;

		/*
		 * Enable snooping.
		 * We enable it for instruction cmmus as well so that we can have
		 * breakpoints, etc, and modify code.
		 */
		if (cputyp == CPU_188) {
			tmp =
			! CMMU_SCTR_PE |  /* not parity enable */
			CMMU_SCTR_SE |	/* snoop enable */
			! CMMU_SCTR_PR ;  /* not priority arbitration */
		} else {
			tmp =
			! CMMU_SCTR_PE |  /* not parity enable */
			! CMMU_SCTR_PR ;  /* not priority arbitration */
		}
		m18x_cmmu_set(CMMU_SCTR, tmp, 0, cpu, DATA_CMMU, 0, 0);
		m18x_cmmu_set(CMMU_SCTR, tmp, 0, cpu, INST_CMMU, 0, 0);

		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_SUPER_ALL, ACCESS_VAL,
			      cpu, DATA_CMMU, CMMU_ACS_SUPER, 0);
		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_SUPER_ALL, ACCESS_VAL,
			      cpu, INST_CMMU, CMMU_ACS_SUPER, 0);
	}

	/*
	 * Turn on some cache.
	 */
	for (cpu = 0; cpu < max_cpus; cpu++) {
		if (!cpu_sets[cpu])
			continue;
		/*
		 * Enable some caching for the instruction stream.
		 * Can't cache data yet 'cause device addresses can never
		 * be cached, and we don't have those no-caching zones
		 * set up yet....
		 */
		tmp =
		(0x00000 << 12) | /* segment table base address */
		AREA_D_WT |	  /* write through */
		AREA_D_G  |	  /* global */
		AREA_D_CI |	  /* cache inhibit */
		! AREA_D_TE ;	  /* not translation enable */
		/*
		REGS(cpu, INST_CMMU).sapr = tmp;
		*/
		m18x_cmmu_set(CMMU_SAPR, tmp, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);

		/*
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_SUPER_ALL;
		*/
		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_SUPER_ALL, ACCESS_VAL|MODE_VAL,
			      cpu, DATA_CMMU, CMMU_ACS_SUPER, 0);
	}
d899 1
d904 1
a904 1
m18x_cmmu_shutdown_now()
d906 2
a907 2
	unsigned tmp;
	unsigned cmmu_num;
d909 27
a935 27
	/*
	 * Now set some state as we like...
	 */
	for (cmmu_num = 0; cmmu_num < MAX_CMMUS; cmmu_num++) {
		if (cputyp == CPU_188) {
			tmp =
			! CMMU_SCTR_PE |   /* parity enable */
			! CMMU_SCTR_SE |   /* snoop enable */
			! CMMU_SCTR_PR ;   /* priority arbitration */
		} else {
			tmp =
			! CMMU_SCTR_PE |   /* parity enable */
			! CMMU_SCTR_PR ;   /* priority arbitration */
		}

		cmmu[cmmu_num].cmmu_regs->sctr = tmp;

		tmp = 
		(0x00000 << 12) |  /* segment table base address */
		! AREA_D_WT |	   /* write through */
		! AREA_D_G  |	   /* global */
		AREA_D_CI |	   /* cache inhibit */
		! AREA_D_TE ;	   /* translation disable */

		cmmu[cmmu_num].cmmu_regs->sapr = tmp;
		cmmu[cmmu_num].cmmu_regs->uapr = tmp;
	}
d942 1
a942 2
void 
m18x_cmmu_parity_enable()
d944 2
a945 2
#ifdef PARITY_ENABLE
	register int cmmu_num;
d947 11
a957 12
	for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++) {
		if (m18x_cmmu_alive(cmmu_num)) {
			register unsigned val1 = 
				m18x_cmmu_get(cmmu_num, CMMU_SCTR);

			/*
			cmmu[cmmu_num].cmmu_regs->sctr |= CMMU_SCTR_PE;
			*/
			m18x_cmmu_set(CMMU_SCTR, val1 | CMMU_SCTR_PE, 
				      NUM_CMMU, cmmu_num, 0, 0, 0);
		}
	}
d968 1
a968 2
unsigned 
m18x_cmmu_cpu_number()
d970 2
a971 2
	register unsigned cmmu_no;
	int i;
d974 31
a1004 31
	for (i=0; i < 10; i++) {
		/* clear CMMU p-bus status registers */
		for (cmmu_no = 0; cmmu_no < MAX_CMMUS; cmmu_no++) {
			if (cmmu[cmmu_no].cmmu_alive == CMMU_AVAILABLE &&
			    cmmu[cmmu_no].which == DATA_CMMU)
				cmmu[cmmu_no].cmmu_regs->pfSTATUSr = 0;
		}

		/* access faulting address */
		badwordaddr((vm_offset_t)ILLADDRESS);

		/* check which CMMU reporting the fault  */
		for (cmmu_no = 0; cmmu_no < MAX_CMMUS; cmmu_no++) {
			if (cmmu[cmmu_no].cmmu_alive == CMMU_AVAILABLE &&
			    cmmu[cmmu_no].which == DATA_CMMU &&
			    cmmu[cmmu_no].cmmu_regs->pfSTATUSr & 0x70000) {
				if (cmmu[cmmu_no].cmmu_regs->pfSTATUSr & 0x70000) {
					cmmu[cmmu_no].cmmu_regs->pfSTATUSr = 0;	/* to be clean */
					cmmu[cmmu_no].cmmu_alive = CMMU_MARRIED;
					return cmmu[cmmu_no].cmmu_cpu;
				}
			}
		}
	}
	panic("m18x_cmmu_cpu_number: could not determine my cpu number");
	return 0; /* to make compiler happy */
}

/*
 * Functions that actually modify CMMU registers.
 */
d1006 3
d1010 1
a1010 2
m18x_cmmu_remote_set(cpu, r, data, x)
	unsigned cpu, r, data, x;
d1012 1
a1012 1
	*(volatile unsigned *)(r + (char*)&REGS(cpu,data)) = x;
d1019 3
d1023 1
a1023 2
m18x_cmmu_remote_get(cpu, r, data)
	unsigned cpu, r, data;
d1025 1
a1025 1
	return (*(volatile unsigned *)(r + (char*)&REGS(cpu,data)));
d1030 1
a1030 2
m18x_cmmu_get_idr(data)
	unsigned data;
d1032 3
a1034 3
	int cpu;
	cpu = cpu_number();
	return REGS(cpu,data).idr;
d1038 1
a1038 2
m18x_cmmu_set_sapr(ap)
	unsigned ap;
d1040 2
a1041 2
	int cpu;
	cpu = cpu_number();
d1043 8
a1050 8
	if (cache_policy & CACHE_INH)
		ap |= AREA_D_CI;
	/*
	REGS(cpu, INST_CMMU).sapr = ap;
	REGS(cpu, DATA_CMMU).sapr = ap;
	*/
	m18x_cmmu_set(CMMU_SAPR, ap, ACCESS_VAL,
		      cpu, 0, CMMU_ACS_SUPER, 0);
d1054 1
a1054 2
m18x_cmmu_remote_set_sapr(cpu, ap)
	unsigned cpu, ap;
d1056 2
a1057 2
	if (cache_policy & CACHE_INH)
		ap |= AREA_D_CI;
d1059 6
a1064 6
	/*
	REGS(cpu, INST_CMMU).sapr = ap;
	REGS(cpu, DATA_CMMU).sapr = ap;
	*/
	m18x_cmmu_set(CMMU_SAPR, ap, ACCESS_VAL,
		      cpu, 0, CMMU_ACS_SUPER, 0);
d1068 1
a1068 2
m18x_cmmu_set_uapr(ap)
	unsigned ap;
d1070 2
a1071 2
	int cpu;
	cpu = cpu_number();
d1073 7
a1079 7
	/* this functionality also mimiced in m18x_cmmu_pmap_activate() */
	/*
	REGS(cpu, INST_CMMU).uapr = ap;
	REGS(cpu, DATA_CMMU).uapr = ap;
	*/
	m18x_cmmu_set(CMMU_UAPR, ap, ACCESS_VAL,
		      cpu, 0, CMMU_ACS_USER, 0);
d1091 13
a1103 12
m18x_cmmu_set_batc_entry(cpu, entry_no, data, value)
	unsigned cpu, entry_no;
	unsigned data;	/* 1 = data, 0 = instruction */
	unsigned value;	/* the value to stuff into the batc */
{
	/*
	REGS(cpu,data).bwp[entry_no] = value;
	*/
	m18x_cmmu_set(CMMU_BWP(entry_no), value, MODE_VAL|ACCESS_VAL,
		      cpu, data, CMMU_ACS_USER, 0);
#ifdef SHADOW_BATC
	CMMU(cpu,data)->batc[entry_no] = value;
d1106 2
a1107 2
	REGS(cpu,data).scr = CMMU_FLUSH_SUPER_ALL;
	REGS(cpu,data).scr = CMMU_FLUSH_USER_ALL;
d1116 4
a1119 3
m18x_cmmu_set_pair_batc_entry(cpu, entry_no, value)
	unsigned cpu, entry_no;
	unsigned value;	/* the value to stuff into the batc */
d1122 7
a1128 7
	/*
	REGS(cpu,DATA_CMMU).bwp[entry_no] = value;
	*/
	m18x_cmmu_set(CMMU_BWP(entry_no), value, MODE_VAL|ACCESS_VAL,
		      cpu, DATA_CMMU, CMMU_ACS_USER, 0);
#ifdef SHADOW_BATC
	CMMU(cpu,DATA_CMMU)->batc[entry_no] = value;
d1130 7
a1136 7
	/*
	REGS(cpu,INST_CMMU).bwp[entry_no] = value;
	*/
	m18x_cmmu_set(CMMU_BWP(entry_no), value, MODE_VAL|ACCESS_VAL,
		      cpu, INST_CMMU, CMMU_ACS_USER, 0);
#ifdef SHADOW_BATC
	CMMU(cpu,INST_CMMU)->batc[entry_no] = value;
d1140 4
a1143 4
	REGS(cpu,INST_CMMU).scr = CMMU_FLUSH_SUPER_ALL;
	REGS(cpu,INST_CMMU).scr = CMMU_FLUSH_USER_ALL;
	REGS(cpu,DATA_CMMU).scr = CMMU_FLUSH_SUPER_ALL;
	REGS(cpu,DATA_CMMU).scr = CMMU_FLUSH_USER_ALL;
d1147 3
a1149 3
/*
 * Functions that invalidate TLB entries.
 */
d1156 3
a1158 36
m18x_cmmu_flush_remote_tlb(cpu, kernel, vaddr, size)
	unsigned cpu, kernel;
	vm_offset_t vaddr;
	int size;
{
	register int s = splhigh();

	if (cpu > max_cpus) {
		cpu = cpu_number();
	}

	if ((unsigned)size > M88K_PGBYTES) {
		/*
		REGS(cpu, INST_CMMU).scr =
		REGS(cpu, DATA_CMMU).scr =
		kernel ? CMMU_FLUSH_SUPER_ALL : CMMU_FLUSH_USER_ALL;
		    */

		m18x_cmmu_set(CMMU_SCR, kernel ? CMMU_FLUSH_SUPER_ALL : CMMU_FLUSH_USER_ALL, ACCESS_VAL,
			      cpu, 0, kernel ? CMMU_ACS_SUPER : CMMU_ACS_USER, 0);
	} else { /* a page or smaller */
		/*
		REGS(cpu, INST_CMMU).sar = (unsigned)vaddr;
		REGS(cpu, DATA_CMMU).sar = (unsigned)vaddr;
		*/
		m18x_cmmu_set(CMMU_SAR, vaddr, ADDR_VAL|ACCESS_VAL,
			      cpu, 0, kernel ? CMMU_ACS_SUPER : CMMU_ACS_USER, vaddr);

		/*
		REGS(cpu, INST_CMMU).scr =
		REGS(cpu, DATA_CMMU).scr =
		kernel ? CMMU_FLUSH_SUPER_PAGE : CMMU_FLUSH_USER_PAGE;
		    */
		m18x_cmmu_set(CMMU_SCR, kernel ? CMMU_FLUSH_SUPER_PAGE : CMMU_FLUSH_USER_PAGE, ADDR_VAL|ACCESS_VAL,
			      cpu, 0, kernel ? CMMU_ACS_SUPER : CMMU_ACS_USER, vaddr);
	}
d1160 33
a1192 1
	splx(s);
d1199 5
a1203 8
m18x_cmmu_flush_tlb(kernel, vaddr, size)
	unsigned kernel;
	vm_offset_t vaddr;
	int size;
{
	int cpu;
	cpu = cpu_number();
	m18x_cmmu_flush_remote_tlb(cpu, kernel, vaddr, size);
d1212 29
a1240 28
m18x_cmmu_pmap_activate(cpu, uapr, i_batc, d_batc)
	unsigned cpu, uapr;
	batc_template_t i_batc[BATC_MAX];
	batc_template_t d_batc[BATC_MAX];
{
	int entry_no;


	/* the following is from m18x_cmmu_set_uapr */
	/*
	REGS(cpu, INST_CMMU).uapr = uapr;
	REGS(cpu, DATA_CMMU).uapr = uapr;
	*/
	m18x_cmmu_set(CMMU_UAPR, uapr, ACCESS_VAL,
		      cpu, 0, CMMU_ACS_USER, 0);

	for (entry_no = 0; entry_no < BATC_MAX; entry_no++) {
		/*
		REGS(cpu,INST_CMMU).bwp[entry_no] = i_batc[entry_no].bits;
		REGS(cpu,DATA_CMMU).bwp[entry_no] = d_batc[entry_no].bits;
		*/
		m18x_cmmu_set(CMMU_BWP(entry_no), i_batc[entry_no].bits, MODE_VAL|ACCESS_VAL,
			      cpu, INST_CMMU, CMMU_ACS_USER, 0);
		m18x_cmmu_set(CMMU_BWP(entry_no), d_batc[entry_no].bits, MODE_VAL|ACCESS_VAL,
			      cpu, DATA_CMMU, CMMU_ACS_USER, 0);
#ifdef SHADOW_BATC
		CMMU(cpu,INST_CMMU)->batc[entry_no] = i_batc[entry_no].bits;
		CMMU(cpu,DATA_CMMU)->batc[entry_no] = d_batc[entry_no].bits;
d1242 2
a1243 29
	}


	/*
	 * Flush the user TLB.
	 * IF THE KERNEL WILL EVER CARE ABOUT THE BATC ENTRIES,
	 * THE SUPERVISOR TLBs SHOULB EE FLUSHED AS WELL.
	 */
	/*
	REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_USER_ALL;
	REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_USER_ALL;
	*/
	m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_USER_ALL, ACCESS_VAL,
		      cpu, 0, CMMU_ACS_USER, 0);
}

/*
 * Functions that invalidate caches.
 *
 * Cache invalidates require physical addresses.  Care must be exercised when
 * using segment invalidates.  This implies that the starting physical address
 * plus the segment length should be invalidated.  A typical mistake is to
 * extract the first physical page of a segment from a virtual address, and
 * then expecting to invalidate when the pages are not physically contiguous.
 *
 * We don't push Instruction Caches prior to invalidate because they are not
 * snooped and never modified (I guess it doesn't matter then which form
 * of the command we use then).
 */
d1245 26
d1275 1
a1275 4
m18x_cmmu_flush_remote_cache(cpu, physaddr, size)
	int cpu;
	vm_offset_t physaddr;
	int size;
d1277 1
a1277 1
	register int s = splhigh();
d1282 53
a1334 47
	if (size < 0 || size > NBSG ) {
		/*
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
		*/
		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, 0,
			      cpu, 0, 0, 0);
	} else if (size <= 16) {
		/*
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, ADDR_VAL,
			      cpu, 0, 0, (unsigned)physaddr);
		/*
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_LINE;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_LINE;
		*/
		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_LINE , ADDR_VAL,
			      cpu, 0, 0, (unsigned)physaddr);
	} else if (size <= NBPG) {
		/*
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, ADDR_VAL,
			      cpu, 0, 0, (unsigned)physaddr);
		/*
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_PAGE;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_PAGE;
		*/
		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_PAGE , ADDR_VAL,
			      cpu, 0, 0, (unsigned)physaddr);
	} else {
		/*
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, 0,
			      cpu, 0, 0, 0);
		/*
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_SEGMENT;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_SEGMENT;
		*/
		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_SEGMENT, 0,
			      cpu, 0, 0, 0);
	}
d1337 6
a1342 6
	/*
	REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
	REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
	*/
	m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, 0,
		      cpu, 0, 0, 0);
d1344 3
a1346 1
	splx(s);
d1353 1
a1353 3
m18x_cmmu_flush_cache(physaddr, size)
	vm_offset_t physaddr;
	int size;
d1355 2
a1356 2
	int cpu = cpu_number();
	m18x_cmmu_flush_remote_cache(cpu, physaddr, size);
d1363 1
a1363 4
m18x_cmmu_flush_remote_inst_cache(cpu, physaddr, size)
	int cpu;
	vm_offset_t physaddr;
	int size;
d1365 1
a1365 1
	register int s = splhigh();
d1370 41
a1410 41
	if (size < 0 || size > NBSG ) {
		/*
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
		*/
		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
	} else if (size <= 16) {

		/*
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		/*
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_LINE;
		*/
		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_LINE, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
	} else if (size <= NBPG) {
		/*
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		/*
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_PAGE;
		*/
		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_PAGE, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
	} else {
		/*
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
		/*
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_SEGMENT;
		*/
		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_SEGMENT, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
	}
d1412 5
a1416 5
	/*
	REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
	*/
	m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, MODE_VAL,
		      cpu, INST_CMMU, 0, 0);
d1418 2
a1419 2

	splx(s);
d1426 1
a1426 3
m18x_cmmu_flush_inst_cache(physaddr, size)
	vm_offset_t physaddr;
	int size;
d1428 3
a1430 3
	int cpu;
	cpu = cpu_number();
	m18x_cmmu_flush_remote_inst_cache(cpu, physaddr, size);
d1434 5
a1438 6
m18x_cmmu_flush_remote_data_cache(cpu, physaddr, size)
	int cpu;
	vm_offset_t physaddr;
	int size;
{
	register int s = splhigh();
d1441 1
a1441 1
	if (size < 0 || size > NBSG ) {
d1443 34
a1476 34
		/*
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
		*/
		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
	} else if (size <= 16) {
		/*
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_LINE;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_LINE, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);

	} else if (size <= NBPG) {
		/*
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_PAGE;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_PAGE, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
	} else {
		/*
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_SEGMENT;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_SEGMENT, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
	}
d1478 5
a1482 5
	/*
	REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
	*/
	m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, MODE_VAL,
		      cpu, DATA_CMMU, 0, 0);
d1484 4
a1487 1
	splx(s);
d1494 1
a1494 3
m18x_cmmu_flush_data_cache(physaddr, size)
	vm_offset_t physaddr;
	int size;
d1496 3
a1498 3
	int cpu;
	cpu = cpu_number();
	m18x_cmmu_flush_remote_data_cache(cpu, physaddr, size);
d1505 7
a1511 7
m18x_cmmu_sync_cache(physaddr, size)
	vm_offset_t physaddr;
	int size;
{
	register int s = splhigh();
	int cpu;
	cpu = cpu_number();
d1514 61
a1574 61
	if (size < 0 || size > NBSG ) {
		/*
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CB_ALL;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CB_ALL;
		*/
		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CB_ALL, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CB_ALL, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
	} else if (size <= 16) {
		/*
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CB_LINE;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_LINE, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
		/*
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CB_LINE;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_LINE, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
	} else if (size <= NBPG) {
		/*
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CB_PAGE;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_PAGE, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
		/*
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CB_PAGE;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_PAGE, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
	} else {
		/*
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CB_SEGMENT;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_SEGMENT, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
		/*
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CB_SEGMENT;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_SEGMENT, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
	}
d1576 8
a1583 8
	/*
	REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CB_ALL;
	REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CB_ALL;
	*/
	m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CB_ALL, MODE_VAL,
		      cpu, DATA_CMMU, 0, 0);
	m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CB_ALL, MODE_VAL,
		      cpu, INST_CMMU, 0, 0);
d1585 4
a1588 1
	splx(s);
d1591 8
a1598 8
void 
m18x_cmmu_sync_inval_cache(physaddr, size)
	vm_offset_t physaddr;
	int size;
{
	register int s = splhigh();
	int cpu;
	cpu = cpu_number();
d1601 61
a1661 61
	if (size < 0 || size > NBSG ) {
		/*
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
		*/
		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
	} else if (size <= 16) {
		/*
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_LINE;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_LINE, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
		/*
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_LINE;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_LINE, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
	} else if (size <= NBPG) {
		/*
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_PAGE;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_PAGE, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
		/*
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_PAGE;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_PAGE, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
	} else {
		/*
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_SEGMENT;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_SEGMENT, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
		/*
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_SEGMENT;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_SEGMENT, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
	}
d1664 8
a1671 8
	/*
	REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
	REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_CBI_ALL;
	*/
	m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, MODE_VAL,
		      cpu, DATA_CMMU, 0, 0);
	m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, MODE_VAL,
		      cpu, INST_CMMU, 0, 0);
d1673 4
a1676 1
	splx(s);
d1680 1
a1680 3
m18x_cmmu_inval_cache(physaddr, size)
	vm_offset_t physaddr;
	int size;
d1682 5
a1686 3
	register int s = splhigh();
	int cpu;
	cpu = cpu_number();
d1689 61
a1749 61
	if (size < 0 || size > NBSG ) {
		/*
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_INV_ALL;
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_INV_ALL;
		*/
		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_INV_ALL, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
		m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_INV_ALL, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
	} else if (size <= 16) {
		/*
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_INV_LINE;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_LINE, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
		/*
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_INV_LINE;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_LINE, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
	} else if (size <= NBPG) {
		/*
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_INV_PAGE;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_PAGE, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
		/*
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_INV_PAGE;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_PAGE, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
	} else {
		/*
		REGS(cpu, DATA_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_INV_SEGMENT;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_SEGMENT, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
		/*
		REGS(cpu, INST_CMMU).sar = (unsigned)physaddr;
		REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_INV_SEGMENT;
		*/
		m18x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m18x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_SEGMENT, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
	}
d1751 8
a1758 8
	/*
	REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_CACHE_INV_ALL;
	REGS(cpu, INST_CMMU).scr = CMMU_FLUSH_CACHE_INV_ALL;
	*/
	m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_INV_ALL, MODE_VAL,
		      cpu, DATA_CMMU, 0, 0);
	m18x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_INV_ALL, MODE_VAL,
		      cpu, INST_CMMU, 0, 0);
d1761 3
a1763 1
	splx(s);
d1767 1
a1767 3
m18x_dma_cachectl(va, size, op)
	vm_offset_t va;
	int size, op;
d1769 2
d1772 1
a1772 1
	int count;
d1774 1
a1774 2
	while (size) {
		count = NBPG - ((int)va & PGOFSET);
d1776 2
a1777 2
		if (size < count)
			count = size;
d1779 10
a1788 10
		if (op == DMA_CACHE_SYNC)
			m18x_cmmu_sync_cache(kvtop(va), count);
		else if (op == DMA_CACHE_SYNC_INVAL)
			m18x_cmmu_sync_inval_cache(kvtop(va), count);
		else
			m18x_cmmu_inval_cache(kvtop(va), count);

		va = (vm_offset_t)((int)va + count);
		size -= count;
	}
d1791 6
a1796 6
	if (op == DMA_CACHE_SYNC)
		m18x_cmmu_sync_cache(kvtop(va), size);
	else if (op == DMA_CACHE_SYNC_INVAL)
		m18x_cmmu_sync_inval_cache(kvtop(va), size);
	else
		m18x_cmmu_inval_cache(kvtop(va), size);
d1800 1
a1800 1
#ifdef DDB
d1869 1
d1872 1
d1878 404
a2281 405
m18x_cmmu_show_translation(address, supervisor_flag, verbose_flag, cmmu_num)
	unsigned address, supervisor_flag, verbose_flag;
	int cmmu_num;
{
	/*
	 * A virtual address is split into three fields. Two are used as
	 * indicies into tables (segment and page), and one is an offset into
	 * a page of memory.
	 */
	union {
		unsigned bits;
		struct {
			unsigned segment_table_index:10,
			page_table_index:10,
			page_offset:12;
		} field;
	} virtual_address;
	unsigned value;

	if (verbose_flag)
		DEBUG_MSG("-------------------------------------------\n");



	/****** ACCESS PROPER CMMU or THREAD ***********/
#if 0 /* no thread */
	if (thread != 0) {
		/* the following tidbit from _pmap_activate in m88k/pmap.c */
		register apr_template_t apr_data;
		supervisor_flag = 0; /* thread implies user */

		if (thread->task == 0) {
			DEBUG_MSG("[thread %x has empty task pointer]\n", thread);
			return;
		} else if (thread->task->map == 0) {
			DEBUG_MSG("[thread/task %x/%x has empty map pointer]\n",
				  thread, thread->task);
			return;
		} else if (thread->task->map->pmap == 0) {
			DEBUG_MSG("[thread/task/map %x/%x/%x has empty pmap pointer]\n",
				  thread, thread->task, thread->task->map);
			return;
		}
		if (thread->task->map->pmap->lock.lock_data) {
			DEBUG_MSG("[Warning: thread %x's task %x's map %x's "
				  "pmap %x is locked]\n", thread, thread->task,
				  thread->task->map, thread->task->map->pmap);
		}
		apr_data.bits = 0;
		apr_data.field.st_base = M88K_BTOP(thread->task->map->pmap->sdt_paddr);
		apr_data.field.wt = 0;
		apr_data.field.g  = 1;
		apr_data.field.ci = 0;
		apr_data.field.te = 1;
		value = apr_data.bits;
		if (verbose_flag) {
			DEBUG_MSG("[thread %x task %x map %x pmap %x UAPR is %x]\n",
				  thread, thread->task, thread->task->map,
				  thread->task->map->pmap, value);
		}
	} else
#endif /* 0 */
	{
		if (cmmu_num == -1) {
			int cpu = cpu_number();
			if (cpu_cmmu[cpu].pair[DATA_CMMU] == 0) {
				DEBUG_MSG("ack! can't figure my own data cmmu number.\n");
				return;
			}
			cmmu_num = cpu_cmmu[cpu].pair[DATA_CMMU] - cmmu;
			if (verbose_flag)
				DEBUG_MSG("The data cmmu for cpu#%d is cmmu#%d.\n",
					  0, cmmu_num);
		} else if (cmmu_num < 0 || cmmu_num >= MAX_CMMUS) {
			DEBUG_MSG("invalid cpu number [%d]... must be in range [0..%d]\n",
				  cmmu_num, MAX_CMMUS - 1);

			return;
		}

		if (cmmu[cmmu_num].cmmu_alive == 0) {
			DEBUG_MSG("warning: cmmu %d is not alive.\n", cmmu_num);
#if 0
			return;
#endif
		}

		if (!verbose_flag) {
			if (!(cmmu[cmmu_num].cmmu_regs->sctr & CMMU_SCTR_SE))
				DEBUG_MSG("WARNING: snooping not enabled for CMMU#%d.\n",
					  cmmu_num);
		} else {
			int i;
			for (i=0; i<MAX_CMMUS; i++)
				if ((i == cmmu_num || cmmu[i].cmmu_alive) &&
				    (verbose_flag>1 || !(cmmu[i].cmmu_regs->sctr&CMMU_SCTR_SE))) {
					DEBUG_MSG("CMMU#%d (cpu %d %s) snooping %s\n", i,
						  cmmu[i].cmmu_cpu, cmmu[i].which ? "data" : "inst",
						  (cmmu[i].cmmu_regs->sctr & CMMU_SCTR_SE) ? "on":"OFF");
				}
		}

		if (supervisor_flag)
			value = cmmu[cmmu_num].cmmu_regs->sapr;
		else
			value = cmmu[cmmu_num].cmmu_regs->uapr;

	}

	/******* LOOK AT THE BATC ** (if not a thread) **************/
#if 0
#ifdef SHADOW_BATC
	if (thread == 0) {
		int i;
		union batcu batc;
		for (i = 0; i < 8; i++) {
			batc.bits = cmmu[cmmu_num].batc[i];
			if (batc.field.v == 0) {
				if (verbose_flag>1)
					DEBUG_MSG("cmmu #%d batc[%d] invalid.\n", cmmu_num, i);
			} else {
				DEBUG_MSG("cmmu#%d batc[%d] v%08x p%08x", cmmu_num, i,
					  batc.field.lba << 18, batc.field.pba);
				if (batc.field.s)  DEBUG_MSG(", supervisor");
				if (batc.field.wt) DEBUG_MSG(", wt.th");
				if (batc.field.g)  DEBUG_MSG(", global");
				if (batc.field.ci) DEBUG_MSG(", cache inhibit");
				if (batc.field.wp) DEBUG_MSG(", write protect");
			}
		}
	}
#endif	/* SHADOW_BATC */
#endif	/* 0 */

	/******* SEE WHAT A PROBE SAYS (if not a thread) ***********/
#if 0
	if (thread == 0)
#endif /* 0 */
	{
		union ssr ssr;
		struct cmmu_regs *cmmu_regs = cmmu[cmmu_num].cmmu_regs;
		cmmu_regs->sar = address;
		cmmu_regs->scr = supervisor_flag ? CMMU_PROBE_SUPER : CMMU_PROBE_USER;
		ssr.bits = cmmu_regs->ssr;
		if (verbose_flag > 1)
			DEBUG_MSG("probe of 0x%08x returns ssr=0x%08x\n",
				  address, ssr.bits);
		if (ssr.field.v)
			DEBUG_MSG("PROBE of 0x%08x returns phys=0x%x",
				  address, cmmu_regs->sar);
		else
			DEBUG_MSG("PROBE fault at 0x%x", cmmu_regs->pfADDRr);
		if (ssr.field.ce) DEBUG_MSG(", copyback err");
		if (ssr.field.be) DEBUG_MSG(", bus err");
		if (ssr.field.wt) DEBUG_MSG(", writethrough");
		if (ssr.field.sp) DEBUG_MSG(", sup prot");
		if (ssr.field.g)  DEBUG_MSG(", global");
		if (ssr.field.ci) DEBUG_MSG(", cache inhibit");
		if (ssr.field.m)  DEBUG_MSG(", modified");
		if (ssr.field.u)  DEBUG_MSG(", used");
		if (ssr.field.wp) DEBUG_MSG(", write prot");
		if (ssr.field.bh) DEBUG_MSG(", BATC");
		DEBUG_MSG(".\n");
	}

	/******* INTERPRET AREA DESCRIPTOR *********/
	{
		union apr_template apr_template;
		apr_template.bits = value;
		if (verbose_flag > 1) {
			DEBUG_MSG("CMMU#%d", cmmu_num);
#if 0
			if (thread == 0)
				DEBUG_MSG("CMMU#%d", cmmu_num);
			else
				DEBUG_MSG("THREAD %x", thread);
#endif /* 0 */
			DEBUG_MSG(" %cAPR is 0x%08x\n",
				  supervisor_flag ? 'S' : 'U', apr_template.bits);
		}
		DEBUG_MSG("CMMU#%d", cmmu_num);
#if 0
		if (thread == 0)
			DEBUG_MSG("CMMU#%d", cmmu_num);
		else
			DEBUG_MSG("THREAD %x", thread);
#endif /* 0 */
		DEBUG_MSG(" %cAPR: SegTbl: 0x%x000p",
			  supervisor_flag ? 'S' : 'U', apr_template.field.st_base);
		if (apr_template.field.wt) DEBUG_MSG(", WTHRU");
		else			   DEBUG_MSG(", !wthru");
		if (apr_template.field.g)  DEBUG_MSG(", GLOBAL");
		else			   DEBUG_MSG(", !global");
		if (apr_template.field.ci) DEBUG_MSG(", $INHIBIT");
		else			   DEBUG_MSG(", $ok");
		if (apr_template.field.te) DEBUG_MSG(", VALID");
		else			   DEBUG_MSG(", !valid");
		DEBUG_MSG(".\n");

		/* if not valid, done now */
		if (apr_template.field.te == 0) {
			DEBUG_MSG("<would report an error, valid bit not set>\n");

			return;
		}

		value = apr_template.field.st_base << 12; /* now point to seg page */
	}

	/* translate value from physical to virtual */
	if (verbose_flag)
		DEBUG_MSG("[%x physical is %x virtual]\n", value, value + VEQR_ADDR);
	value += VEQR_ADDR;

	virtual_address.bits = address;

	/****** ACCESS SEGMENT TABLE AND INTERPRET SEGMENT DESCRIPTOR  *******/
	{
		union sdt_entry_template std_template;
		if (verbose_flag)
			DEBUG_MSG("will follow to entry %d of page at 0x%x...\n",
				  virtual_address.field.segment_table_index, value);
		value |= virtual_address.field.segment_table_index *
			 sizeof(struct sdt_entry);

		if (badwordaddr((vm_offset_t)value)) {
			DEBUG_MSG("ERROR: unable to access page at 0x%08x.\n", value);

			return;
		}

		std_template.bits = *(unsigned *)value;
		if (verbose_flag > 1)
			DEBUG_MSG("SEG DESC @@0x%x is 0x%08x\n", value, std_template.bits);
		DEBUG_MSG("SEG DESC @@0x%x: PgTbl: 0x%x000",
			  value, std_template.sdt_desc.table_addr);
		if (std_template.sdt_desc.wt)	    DEBUG_MSG(", WTHRU");
		else				    DEBUG_MSG(", !wthru");
		if (std_template.sdt_desc.sup)	    DEBUG_MSG(", S-PROT");
		else				    DEBUG_MSG(", UserOk");
		if (std_template.sdt_desc.g)	    DEBUG_MSG(", GLOBAL");
		else				    DEBUG_MSG(", !global");
		if (std_template.sdt_desc.no_cache) DEBUG_MSG(", $INHIBIT");
		else				    DEBUG_MSG(", $ok");
		if (std_template.sdt_desc.prot)	    DEBUG_MSG(", W-PROT");
		else				    DEBUG_MSG(", WriteOk");
		if (std_template.sdt_desc.dtype)    DEBUG_MSG(", VALID");
		else				    DEBUG_MSG(", !valid");
		DEBUG_MSG(".\n");

		/* if not valid, done now */
		if (std_template.sdt_desc.dtype == 0) {
			DEBUG_MSG("<would report an error, STD entry not valid>\n");

			return;
		}

		value = std_template.sdt_desc.table_addr << 12;
	}

	/* translate value from physical to virtual */
	if (verbose_flag)
		DEBUG_MSG("[%x physical is %x virtual]\n", value, value + VEQR_ADDR);
	value += VEQR_ADDR;

	/******* PAGE TABLE *********/
	{
		union pte_template pte_template;
		if (verbose_flag)
			DEBUG_MSG("will follow to entry %d of page at 0x%x...\n",
				  virtual_address.field.page_table_index, value);
		value |= virtual_address.field.page_table_index *
			 sizeof(struct pt_entry);

		if (badwordaddr((vm_offset_t)value)) {
			DEBUG_MSG("error: unable to access page at 0x%08x.\n", value);

			return;
		}

		pte_template.bits = *(unsigned *)value;
		if (verbose_flag > 1)
			DEBUG_MSG("PAGE DESC @@0x%x is 0x%08x.\n", value, pte_template.bits);
		DEBUG_MSG("PAGE DESC @@0x%x: page @@%x000",
			  value, pte_template.pte.pfn);
		if (pte_template.pte.wired)    DEBUG_MSG(", WIRE");
		else			       DEBUG_MSG(", !wire");
		if (pte_template.pte.wt)       DEBUG_MSG(", WTHRU");
		else			       DEBUG_MSG(", !wthru");
		if (pte_template.pte.sup)      DEBUG_MSG(", S-PROT");
		else			       DEBUG_MSG(", UserOk");
		if (pte_template.pte.g)	       DEBUG_MSG(", GLOBAL");
		else			       DEBUG_MSG(", !global");
		if (pte_template.pte.ci)       DEBUG_MSG(", $INHIBIT");
		else			       DEBUG_MSG(", $ok");
		if (pte_template.pte.modified) DEBUG_MSG(", MOD");
		else			       DEBUG_MSG(", !mod");
		if (pte_template.pte.pg_used)  DEBUG_MSG(", USED");
		else			       DEBUG_MSG(", !used");
		if (pte_template.pte.prot)     DEBUG_MSG(", W-PROT");
		else			       DEBUG_MSG(", WriteOk");
		if (pte_template.pte.dtype)    DEBUG_MSG(", VALID");
		else			       DEBUG_MSG(", !valid");
		DEBUG_MSG(".\n");

		/* if not valid, done now */
		if (pte_template.pte.dtype == 0) {
			DEBUG_MSG("<would report an error, PTE entry not valid>\n");

			return;
		}

		value = pte_template.pte.pfn << 12;
		if (verbose_flag)
			DEBUG_MSG("will follow to byte %d of page at 0x%x...\n",
				  virtual_address.field.page_offset, value);
		value |= virtual_address.field.page_offset;

		if (badwordaddr((vm_offset_t)value)) {
			DEBUG_MSG("error: unable to access page at 0x%08x.\n", value);

			return;
		}
	}

	/* translate value from physical to virtual */
	if (verbose_flag)
		DEBUG_MSG("[%x physical is %x virtual]\n", value, value + VEQR_ADDR);
	value += VEQR_ADDR;

	DEBUG_MSG("WORD at 0x%x is 0x%08x.\n", value, *(unsigned *)value);

}

void
m18x_cmmu_cache_state(addr, supervisor_flag)
	unsigned addr, supervisor_flag;
{
	static char *vv_name[4] =
	{"exclu-unmod", "exclu-mod", "shared-unmod", "invalid"};
	int cmmu_num;

	for (cmmu_num = 0; cmmu_num < MAX_CMMUS; cmmu_num++) {
		union ssr ssr;
		union cssp cssp;
		struct cmmu_regs *R;
		unsigned tag, line;
		if (!cmmu[cmmu_num].cmmu_alive)
			continue;
		R = cmmu[cmmu_num].cmmu_regs;
		DEBUG_MSG("cmmu #%d %s cmmu for cpu %d.\n", cmmu_num,
			  cmmu[cmmu_num].which ? "data" : "inst", 
			  cmmu[cmmu_num].cmmu_cpu);
		R->sar = addr;
		R->scr = supervisor_flag ? CMMU_PROBE_SUPER : CMMU_PROBE_USER;

		ssr.bits = R->ssr;
		if (!ssr.field.v) {
			DEBUG_MSG("PROBE of 0x%08x faults.\n",addr);
			continue;
		}
		DEBUG_MSG("PROBE of 0x%08x returns phys=0x%x", addr, R->sar);

		tag = R->sar & ~0xfff;
		cssp.bits = R->cssp;

		/* check to see if any of the tags for the set match the address */
		for (line = 0; line < 4; line++) {
			if (VV(cssp, line) == VV_INVALID) {
				DEBUG_MSG("line %d invalid.\n", line);
				continue; /* line is invalid */
			}
			if (D(cssp, line)) {
				DEBUG_MSG("line %d disabled.\n", line);
				continue; /* line is disabled */
			}

			if ((R->ctp[line] & ~0xfff) != tag) {
				DEBUG_MSG("line %d address tag is %x.\n", line,
					  (R->ctp[line] & ~0xfff));
				continue;
			}
			DEBUG_MSG("found in line %d as %08x (%s).\n",
				  line, R->cdp[line], vv_name[VV(cssp, line)]);
		}
	}

}

#endif /* DDB */

void
m18x_show_cmmu_info(addr)
	unsigned addr;
{
	int cmmu_num;
	m18x_cmmu_cache_state(addr, 1);

	for (cmmu_num = 0; cmmu_num < MAX_CMMUS; cmmu_num++)
		if (cmmu[cmmu_num].cmmu_alive) {
			DEBUG_MSG("cmmu #%d %s cmmu for cpu %d: ", cmmu_num,
				  cmmu[cmmu_num].which ? "data" : "inst", 
				  cmmu[cmmu_num].cmmu_cpu);
			m18x_cmmu_show_translation(addr, 1, 0, cmmu_num);
		}
d2283 1
@


1.1.4.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: m18x_cmmu.c,v 1.1.4.2 2001/04/18 16:11:35 niklas Exp $	*/
d1246 1
a1246 1
	if ((unsigned)size > PAGE_SIZE) {
d2003 1
a2003 1
		apr_data.field.st_base = atop(thread->task->map->pmap->sdt_paddr);
@


1.1.4.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: m18x_cmmu.c,v 1.1.4.3 2001/07/04 10:20:15 niklas Exp $	*/
d175 7
a196 2
int m18x_cmmu_alive __P((int));
void m18x_cmmu_store __P((int, int, unsigned));
d293 2
a294 1
} bd_config[] = {
d318 2
a319 1
struct cmmu cmmu[MAX_CMMUS] = {
d353 5
d372 1
a372 1
#endif /* defined(MVME187) */
d383 2
d391 1
a391 1
		panic("This configuration is not supported - go and get another OS.");
d400 1
a400 1
		panic("UNKNOWN MVME%x board configuration: WHOAMI = 0x%02x", cputyp, *whoami);
d641 5
d647 1
a647 1
#endif /* defined(MVME187) */
d650 1
a652 1
		DEBUG_MSG("VME188 address decoder: PCNFA = 0x%1x, PCNFB = 0x%1x\n\n", *pcnfa & 0xf, *pcnfb & 0xf);
d669 2
d675 1
a675 1
void
d680 1
a680 1
	*(volatile unsigned *)(reg + (char *)(cmmu[mmu].cmmu_regs)) = val;
d2343 2
a2359 2

#endif /* DDB */
@


1.1.4.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: m18x_cmmu.c,v 1.1.4.4 2001/10/31 03:01:19 nate Exp $	*/
@


