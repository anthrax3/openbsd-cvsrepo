head	1.58;
access;
symbols
	OPENBSD_5_5:1.57.0.6
	OPENBSD_5_5_BASE:1.57
	OPENBSD_5_4:1.57.0.2
	OPENBSD_5_4_BASE:1.57
	OPENBSD_5_3:1.55.0.2
	OPENBSD_5_3_BASE:1.55
	OPENBSD_5_2:1.54.0.8
	OPENBSD_5_2_BASE:1.54
	OPENBSD_5_1_BASE:1.54
	OPENBSD_5_1:1.54.0.6
	OPENBSD_5_0:1.54.0.4
	OPENBSD_5_0_BASE:1.54
	OPENBSD_4_9:1.54.0.2
	OPENBSD_4_9_BASE:1.54
	OPENBSD_4_8:1.53.0.6
	OPENBSD_4_8_BASE:1.53
	OPENBSD_4_7:1.53.0.2
	OPENBSD_4_7_BASE:1.53
	OPENBSD_4_6:1.53.0.4
	OPENBSD_4_6_BASE:1.53
	OPENBSD_4_5:1.50.0.4
	OPENBSD_4_5_BASE:1.50
	OPENBSD_4_4:1.44.0.4
	OPENBSD_4_4_BASE:1.44
	OPENBSD_4_3:1.44.0.2
	OPENBSD_4_3_BASE:1.44
	OPENBSD_4_2:1.32.0.2
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.24.0.2
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.22.0.2
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.12.0.2
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.8.0.2
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5;
locks; strict;
comment	@ * @;


1.58
date	2014.03.18.22.36.36;	author miod;	state dead;
branches;
next	1.57;

1.57
date	2013.06.11.21.06.31;	author miod;	state Exp;
branches;
next	1.56;

1.56
date	2013.05.17.22.46.28;	author miod;	state Exp;
branches;
next	1.55;

1.55
date	2013.02.17.18.07.36;	author miod;	state Exp;
branches;
next	1.54;

1.54
date	2010.12.31.21.38.08;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2009.03.15.20.39.53;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2009.03.09.19.51.18;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2009.03.08.16.03.06;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2009.02.21.18.37.48;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2009.02.20.23.35.11;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2009.02.16.23.03.33;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2009.02.16.22.55.03;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2009.02.13.23.26.51;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2008.11.27.21.43.03;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2007.12.27.23.17.55;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2007.11.17.05.37.53;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2007.11.17.05.36.23;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2007.11.17.05.32.05;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2007.11.14.23.14.14;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2007.11.14.17.54.25;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2007.11.12.21.00.22;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2007.11.12.19.59.07;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2007.11.11.21.17.35;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2007.11.11.13.06.58;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2007.11.09.22.50.48;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2007.10.29.19.57.48;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2007.05.19.20.50.06;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2007.05.19.20.33.50;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2007.05.19.17.03.49;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2007.05.18.16.38.29;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2007.05.14.17.00.40;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2007.05.14.16.57.43;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2007.05.12.20.02.14;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2007.03.22.18.52.39;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2006.11.20.21.51.33;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2006.11.20.21.25.15;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2006.05.08.14.36.10;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2006.05.07.15.40.16;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2006.05.06.22.17.20;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2006.05.02.21.43.09;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2006.04.19.22.09.40;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2006.04.19.19.54.21;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2006.04.19.19.41.26;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2006.04.17.18.26.28;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2006.04.15.15.45.24;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2006.04.13.21.16.17;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2005.12.04.14.58.43;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.03.14.30.06;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2005.10.13.19.48.36;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2005.09.06.19.41.28;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2005.05.01.09.55.49;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2005.04.30.16.42.37;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2005.04.27.14.07.38;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2004.12.24.22.50.30;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2004.11.09.21.50.01;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2004.11.09.12.01.19;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2004.11.08.16.39.31;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2004.10.01.19.00.52;	author miod;	state Exp;
branches;
next	;


desc
@@


1.58
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: m188_machdep.c,v 1.57 2013/06/11 21:06:31 miod Exp $	*/
/*
 * Copyright (c) 2009, 2013 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * Copyright (c) 1998, 1999, 2000, 2001 Steve Murphree, Jr.
 * Copyright (c) 1996 Nivas Madhur
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Nivas Madhur.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
/*
 * Copyright (c) 1999 Steve Murphree, Jr.
 * Copyright (c) 1995 Theo de Raadt
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1995 Nivas Madhur
 * Copyright (c) 1994 Gordon W. Ross
 * Copyright (c) 1993 Adam Glass
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)clock.c	8.1 (Berkeley) 6/11/93
 */
/*
 * Mach Operating System
 * Copyright (c) 1993-1991 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 */

/*
 * MVME188 support routines
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/errno.h>
#include <sys/timetc.h>

#include <uvm/uvm_extern.h>

#include <machine/asm_macro.h>
#include <machine/board.h>
#include <machine/cmmu.h>
#include <machine/cpu.h>
#include <machine/pmap_table.h>
#include <machine/prom.h>
#include <machine/reg.h>
#include <machine/trap.h>

#include <machine/m88100.h>
#include <machine/m8820x.h>
#include <machine/mvme188.h>

#include <mvme88k/mvme88k/clockvar.h>
#include <dev/ic/mc68681reg.h>
#include <dev/ic/z8536reg.h>

#ifdef MULTIPROCESSOR
#include <machine/db_machdep.h>
#endif

const struct pmap_table m188_pmap_table[] = {
	{ MVME188_EPROM,	MVME188_EPROM_SIZE, UVM_PROT_RW, CACHE_INH },
#if 0	/* mapped by the hardcoded BATC entries */
	{ MVME188_UTILITY,	MVME188_UTILITY_SIZE, UVM_PROT_RW, CACHE_INH },
#endif
	{ 0, 0xffffffff, 0, 0 },
};

const struct board board_mvme188 = {
	.bootstrap = m188_bootstrap,
	.memsize = m188_memsize,
	.cpuspeed = m188_cpuspeed,
	.reboot = m188_reboot,
	.is_syscon = m188_is_syscon,
	.intr = m188_intr,
	.nmi = NULL,
	.nmi_wrapup = NULL,
	.getipl = m188_getipl,
	.setipl = m188_setipl,
	.raiseipl = m188_raiseipl,
	.intsrc_available = m188_intsrc_available,
	.intsrc_enable = m188_intsrc_enable,
	.intsrc_disable = m188_intsrc_disable,
	.intsrc_establish = m188_intsrc_establish,
	.intsrc_disestablish = m188_intsrc_disestablish,
	.init_clocks = m188_init_clocks,
	.delay = dumb_delay,
	.init_vme = m188_init_vme,
#ifdef MULTIPROCESSOR
	.send_ipi = m188_send_ipi,
	.smp_setup = m88100_smp_setup,
#endif
	.ptable = m188_pmap_table,
	.cmmu = &cmmu8820x
};

u_int	m188_safe_level(u_int, u_int);

void	m188_clock_ipi_handler(struct trapframe *);
void	m188_ipi_handler(struct trapframe *);
void	m188_send_ipi(int, cpuid_t);

/*
 * Copy of the interrupt enable register for each CPU.
 */
u_int32_t int_mask_reg[] = { 0, 0, 0, 0 };

u_int m188_curspl[] = { IPL_HIGH, IPL_HIGH, IPL_HIGH, IPL_HIGH };

#ifdef MULTIPROCESSOR
/*
 * Interrupts allowed on secondary processors.
 */
#define	SLAVE_MASK	0
#endif

/*
 * The MVME188 interrupt arbiter has 25 orthogonal interrupt sources.
 * We fold this model in the 8-level spl model this port uses, enforcing
 * priorities manually with the interrupt masks.
 */

intrhand_t syscon_intr_handlers[INTSRC_VME];

void
m188_bootstrap()
{
	int i;

	/* clear and disable all interrupts */
	*(volatile u_int32_t *)MVME188_IENALL = 0;

	for (i = 0; i < INTSRC_VME; i++)
		SLIST_INIT(&syscon_intr_handlers[i]);
}

/*
 * Figure out how much memory is available, by querying the MBus registers.
 *
 * For every 4MB segment, ask the MBus address decoder which device claimed
 * the range. Since memory is packed at low addresses, we will hit all memory
 * boards in order until reaching either a VME space or a non-claimed space.
 *
 * As a safety measure, we never check for more than 512MB - the 188 can
 * only have up to 4 memory boards, which theoretically can not be larger
 * than 128MB, and I am not aware of third-party larger memory boards.
 */
vaddr_t
m188_memsize()
{
	u_int pgnum;
	int32_t rmad;

#define	MVME188_MAX_MEMORY	((4 * 128) / 4)	/* 4 128MB boards */
	for (pgnum = 0; pgnum <	MVME188_MAX_MEMORY; pgnum++) {
		*(volatile int32_t *)MVME188_RMAD = (pgnum << 22);
		rmad = *(volatile int32_t *)MVME188_RMAD;

		if (rmad & 0x04)	/* not a memory board */
			break;
	}

	return (pgnum << 22);
}

/*
 * Return the processor speed in MHz.
 */
int
m188_cpuspeed(const struct mvmeprom_brdid *brdid)
{
	int speed;
	int i;
	u_int c;

	/*
	 * If BUG version prior to 5.x, there is no CNFG block and speed
	 * can be found in the environment.
	 * XXX We don't process ENV data yet - assume 20MHz in this case.
	 */
	if ((u_int)brdid->rev < 0x50) {
		return 20;
	}

	speed = 0;
	for (i = 0; i < 4; i++) {
		c = (u_int)brdid->speed[i];
		if (c == ' ')
			c = '0';
		else if (c > '9' || c < '0') {
			speed = 0;
			break;
		}
		speed = speed * 10 + (c - '0');
	}
	speed = speed / 100;

	if (speed == 20 || speed == 25)
		return speed;

        /*
	 * If we end up here, the board information block is damaged and
	 * we can't trust it.
	 * Suppose we are running at the most common speed for our board,
	 * and hope for the best (this really only affects osiop, which
	 * doesn't exist on 188).
	 */
        printf("WARNING: Board Configuration Data invalid, "
	    "replace NVRAM and restore values\n");

	return 25;
}

/*
 * Reboot the system.
 */
void
m188_reboot(int howto)
{
	volatile int cnt;

	/* clear and disable all interrupts */
	*(volatile u_int32_t *)MVME188_IENALL = 0;

	if ((*(volatile u_int8_t *)MVME188_GLOBAL1) & M188_SYSCON) {
		/* Force a complete VMEbus reset */
		*(volatile u_int32_t *)MVME188_GLBRES = 1;
	} else {
		/* Force only a local reset */
		*(volatile u_int8_t *)MVME188_GLOBAL1 |= M188_LRST;
	}

	*(volatile u_int32_t *)MVME188_UCSR |= 0x2000;	/* clear SYSFAIL */
	for (cnt = 0; cnt < 5*1024*1024; cnt++)
		;
	*(volatile u_int32_t *)MVME188_UCSR |= 0x2000;	/* clear SYSFAIL */

	printf("Reset failed\n");
}

/*
 * Return whether we are the VME bus system controller.
 */
int
m188_is_syscon()
{
	return ISSET(*(volatile u_int8_t *)MVME188_GLOBAL1, M188_SYSCON);
}

/*
 * Return the next ipl >= ``curlevel'' at which we can reenable interrupts
 * while keeping ``mask'' masked.
 */
u_int
m188_safe_level(u_int mask, u_int curlevel)
{
	int i;

#ifdef MULTIPROCESSOR
	if (mask & CLOCK_IPI_MASK)
		curlevel = max(IPL_CLOCK, curlevel);
	mask &= ~(IPI_MASK | CLOCK_IPI_MASK);
#endif
	for (i = curlevel; i < NIPLS; i++)
		if ((int_mask_val[i] & mask) == 0)
			return (i);

	return (NIPLS - 1);
}

/*
 * Provide the interrupt source for a give interrupt status bit.
 */
const u_int m188_vec[32] = {
	0,		/* SWI0 */
	0,		/* SWI1 */
	0,		/* SWI2 */
	0,		/* SWI3 */
	INTSRC_VME,	/* VME1 */
	0,
	INTSRC_VME,	/* VME2 */
	0,		/* SIGLPI */
	0,		/* LMI */
	0,
	INTSRC_VME,	/* VME3 */
	0,
	INTSRC_VME,	/* VME4 */
	0,
	INTSRC_VME,	/* VME5 */
	0,
	0,		/* SIGHPI */
	INTSRC_DUART,	/* DI */
	0,
	INTSRC_VME,	/* VME6 */
	INTSRC_SYSFAIL,	/* SF */
	INTSRC_CIO,	/* CIOI */
	0,
	INTSRC_VME,	/* VME7 */
	0,		/* SWI4 */
	0,		/* SWI5 */
	0,		/* SWI6 */
	0,		/* SWI7 */
	INTSRC_DTIMER,	/* DTI */
	0,		/* ARBTO */
	INTSRC_ACFAIL,	/* ACF */
	INTSRC_ABORT	/* ABORT */
};

/*
 * Device interrupt handler for MVME188
 */

#define VME_VECTOR_MASK		0x1ff 	/* mask into VIACK register */
#define VME_BERR_MASK		0x100 	/* timeout during VME IACK cycle */

void
m188_intr(struct trapframe *eframe)
{
#ifdef MULTIPROCESSOR
	struct cpu_info *ci = curcpu();
	u_int cpu = ci->ci_cpuid;
#else
	u_int cpu = cpu_number();
#endif
	u_int32_t cur_mask, ign_mask;
	u_int level, old_spl;
	struct intrhand *intr;
	intrhand_t *list;
	int ret, intbit;
	vaddr_t ivec;
	u_int intsrc, vec;
	int unmasked = 0;
	int warn;
#ifdef DIAGNOSTIC
	static int problems = 0;
#endif

	cur_mask = ISR_GET_CURRENT_MASK(cpu);
	ign_mask = 0;
	old_spl = eframe->tf_mask;

	if (cur_mask == 0) {
		/*
		 * Spurious interrupts - may be caused by debug output clearing
		 * DUART interrupts.
		 */
#ifdef MULTIPROCESSOR
		if (cpu != master_cpu) {
			if (++problems >= 10) {
				printf("cpu%d: interrupt pin won't clear, "
				    "disabling processor\n", cpu);
				cpu_emergency_disable();
				/* NOTREACHED */
			}
		}
#endif
		flush_pipeline();
		goto out;
	}

	uvmexp.intrs++;

#ifdef MULTIPROCESSOR
	/*
	 * Handle unmaskable IPIs immediately, so that we can reenable
	 * interrupts before further processing. We rely on the interrupt
	 * mask to make sure that if we get an IPI, it's really for us
	 * and no other processor.
	 */
	if (cur_mask & IPI_MASK) {
		m188_ipi_handler(eframe);
		cur_mask &= ~IPI_MASK;
		if (cur_mask == 0)
			goto out;
	}
#endif

#ifdef MULTIPROCESSOR
	if (old_spl < IPL_SCHED)
		__mp_lock(&kernel_lock);
#endif

	/*
	 * We want to service all interrupts marked in the IST register
	 * They are all valid because the mask would have prevented them
	 * from being generated otherwise.  We will service them in order of
	 * priority.
	 */
	do {
		level = m188_safe_level(cur_mask, old_spl);
		m188_setipl(level);

		if (unmasked == 0) {
			set_psr(get_psr() & ~PSR_IND);
			unmasked = 1;
		}

#ifdef MULTIPROCESSOR
		/*
		 * Handle pending maskable IPIs first.
		 */
		if (cur_mask & CLOCK_IPI_MASK) {
			m188_clock_ipi_handler(eframe);
			cur_mask &= ~CLOCK_IPI_MASK;
			if (cur_mask == 0)
				break;
		}
#endif

		/* find the first bit set in the current mask */
		warn = 0;
		intbit = ff1(cur_mask);
		intsrc = m188_vec[intbit];

		if (intsrc == 0)
			panic("%s: unexpected interrupt source (bit %d), "
			    "level %d, mask 0x%b",
			    __func__, intbit, level, cur_mask, IST_STRING);

		if (intsrc == INTSRC_VME) {
			ivec = MVME188_VIRQLV + (level << 2);
			vec = *(volatile u_int32_t *)ivec & VME_VECTOR_MASK;
			if (vec & VME_BERR_MASK) {
				/*
				 * If only one VME interrupt is registered
				 * with this IPL, we can reasonably safely
				 * assume that this is our vector.
				 */
				vec = vmevec_hints[level];
				if (vec == (u_int)-1) {
					printf("%s: timeout getting VME "
					    "interrupt vector, "
					    "level %d, mask 0x%b\n",
					    __func__, level,
					   cur_mask, IST_STRING); 
					ign_mask |=  1 << intbit;
					continue;
				}
			}
			list = &intr_handlers[vec];
		} else {
			list = &syscon_intr_handlers[intsrc];
		}

		if (SLIST_EMPTY(list)) {
			warn = 1;
		} else {
			/*
			 * Walk through all interrupt handlers in the chain
			 * for the given vector, calling each handler in turn,
			 * till some handler returns a value != 0.
			 */
			ret = 0;
			SLIST_FOREACH(intr, list, ih_link) {
				if (intr->ih_wantframe != 0)
					ret = (*intr->ih_fn)((void *)eframe);
				else
					ret = (*intr->ih_fn)(intr->ih_arg);
				if (ret != 0) {
					intr->ih_count.ec_count++;
					break;
				}
			}
			if (ret == 0)
				warn = 2;
		}

		if (warn != 0) {
			ign_mask |= 1 << intbit;

			if (intsrc == INTSRC_VME)
				printf("%s: %s VME interrupt, "
				    "level %d, vec 0x%x, mask 0x%b\n",
				    __func__,
				    warn == 1 ? "spurious" : "unclaimed",
				    level, vec, cur_mask, IST_STRING);
			else
				printf("%s: %s interrupt, "
				    "level %d, bit %d, mask 0x%b\n",
				    __func__,
				    warn == 1 ? "spurious" : "unclaimed",
				    level, intbit, cur_mask, IST_STRING);
		}
	} while (((cur_mask = ISR_GET_CURRENT_MASK(cpu)) & ~ign_mask &
	    ~IPI_MASK) != 0);

#ifdef DIAGNOSTIC
	if (ign_mask != 0) {
		if (++problems >= 10)
			panic("%s: broken interrupt behaviour", __func__);
	} else
		problems = 0;
#endif

#ifdef MULTIPROCESSOR
	if (old_spl < IPL_SCHED)
		__mp_unlock(&kernel_lock);
#endif

out:
	/*
	 * process any remaining data access exceptions before
	 * returning to assembler
	 */
	if (eframe->tf_dmt0 & DMT_VALID)
		m88100_trap(T_DATAFLT, eframe);

	/*
	 * Disable interrupts before returning to assembler, the spl will
	 * be restored later.
	 */
	set_psr(get_psr() | PSR_IND);
}

u_int
m188_getipl(void)
{
	return m188_curspl[cpu_number()];
}

u_int
m188_setipl(u_int level)
{
	u_int curspl, mask, psr;
#ifdef MULTIPROCESSOR
	struct cpu_info *ci = curcpu();
	int cpu = ci->ci_cpuid;
#else
	int cpu = cpu_number();
#endif

	psr = get_psr();
	set_psr(psr | PSR_IND);

	curspl = m188_curspl[cpu];

	mask = int_mask_val[level];
#ifdef MULTIPROCESSOR
	if (cpu != master_cpu)
		mask &= SLAVE_MASK;
	mask |= SWI_IPI_MASK(cpu);
	if (level < IPL_CLOCK)
		mask |= SWI_CLOCK_IPI_MASK(cpu);
#endif

	m188_curspl[cpu] = level;
	*(u_int32_t *)MVME188_IEN(cpu) = int_mask_reg[cpu] = mask;
	/*
	 * We do not flush the pipeline here, because interrupts are disabled,
	 * and set_psr() will synchronize the pipeline.
	 */
	set_psr(psr);

	return curspl;
}

u_int
m188_raiseipl(u_int level)
{
	u_int mask, curspl, psr;
#ifdef MULTIPROCESSOR
	struct cpu_info *ci = curcpu();
	int cpu = ci->ci_cpuid;
#else
	int cpu = cpu_number();
#endif

	psr = get_psr();
	set_psr(psr | PSR_IND);

	curspl = m188_curspl[cpu];
	if (curspl < level) {
		mask = int_mask_val[level];
#ifdef MULTIPROCESSOR
		if (cpu != master_cpu)
			mask &= SLAVE_MASK;
		mask |= SWI_IPI_MASK(cpu);
		if (level < IPL_CLOCK)
			mask |= SWI_CLOCK_IPI_MASK(cpu);
#endif

		m188_curspl[cpu] = level;
		*(u_int32_t *)MVME188_IEN(cpu) = int_mask_reg[cpu] = mask;
	}
	/*
	 * We do not flush the pipeline here, because interrupts are disabled,
	 * and set_psr() will synchronize the pipeline.
	 */
	set_psr(psr);

	return curspl;
}

#ifdef MULTIPROCESSOR

void
m188_send_ipi(int ipi, cpuid_t cpu)
{
	struct cpu_info *ci = &m88k_cpus[cpu];
	u_int32_t bits = 0;

	if (ci->ci_ipi & ipi)
		return;

	atomic_setbits_int(&ci->ci_ipi, ipi);
	if (ipi & ~(CI_IPI_HARDCLOCK | CI_IPI_STATCLOCK))
		bits |= SWI_IPI_BIT(cpu);
	if (ipi & (CI_IPI_HARDCLOCK | CI_IPI_STATCLOCK))
		bits |= SWI_CLOCK_IPI_BIT(cpu);
	*(volatile u_int32_t *)MVME188_SETSWI = bits;
}

/*
 * Process inter-processor interrupts.
 */

/*
 * Unmaskable IPIs - those are processed with interrupts disabled,
 * and no lock held.
 */
void
m188_ipi_handler(struct trapframe *eframe)
{
	struct cpu_info *ci = curcpu();
	int ipi = ci->ci_ipi & (CI_IPI_DDB | CI_IPI_NOTIFY);

	*(volatile u_int32_t *)MVME188_CLRSWI = SWI_IPI_BIT(ci->ci_cpuid);
	atomic_clearbits_int(&ci->ci_ipi, ipi);

	if (ipi & CI_IPI_DDB) {
#ifdef DDB
		/*
		 * Another processor has entered DDB. Spin on the ddb lock
		 * until it is done.
		 */
		extern struct __mp_lock ddb_mp_lock;

		__mp_lock(&ddb_mp_lock);
		__mp_unlock(&ddb_mp_lock);

		/*
		 * If ddb is hoping to us, it's our turn to enter ddb now.
		 */
		if (ci->ci_cpuid == ddb_mp_nextcpu)
			Debugger();
#endif
	}
	if (ipi & CI_IPI_NOTIFY) {
		/* nothing to do */
	}
}

/*
 * Maskable IPIs
 */
void
m188_clock_ipi_handler(struct trapframe *eframe)
{
	struct cpu_info *ci = curcpu();
	int ipi = ci->ci_ipi & (CI_IPI_HARDCLOCK | CI_IPI_STATCLOCK);

	/* clear clock ipi interrupt */
	*(volatile u_int32_t *)MVME188_CLRSWI = SWI_CLOCK_IPI_BIT(ci->ci_cpuid);
	atomic_clearbits_int(&ci->ci_ipi, ipi);

	if (ipi & CI_IPI_HARDCLOCK)
		hardclock((struct clockframe *)eframe);
	if (ipi & CI_IPI_STATCLOCK)
		statclock((struct clockframe *)eframe);
}

#endif

/* Interrupt masks per logical interrupt source */
const u_int32_t m188_intsrc[] = {
	0,
	IRQ_ABORT,
	IRQ_ACF,
	IRQ_SF,
	0,
	IRQ_CIOI,
	IRQ_DTI,
	IRQ_DI,

	IRQ_VME1,
	IRQ_VME2,
	IRQ_VME3,
	IRQ_VME4,
	IRQ_VME5,
	IRQ_VME6,
	IRQ_VME7
};

int
m188_intsrc_available(u_int intsrc, int ipl)
{
	if (intsrc == INTSRC_VME)
		return 0;

	if (m188_intsrc[intsrc] == 0)
		return ENXIO;

	return 0;
}

void
m188_intsrc_enable(u_int intsrc, int ipl)
{
	u_int32_t psr;
	u_int32_t intmask;
	int i;

	if (intsrc == INTSRC_VME)
		intmask = m188_intsrc[INTSRC_VME + (ipl - 1)];
	else
		intmask = m188_intsrc[intsrc];

	psr = get_psr();
	set_psr(psr | PSR_IND);

	for (i = IPL_NONE; i < ipl; i++)
		int_mask_val[i] |= intmask;

	setipl(getipl());
	set_psr(psr);
}

void
m188_intsrc_disable(u_int intsrc, int ipl)
{
	u_int32_t psr;
	u_int32_t intmask;
	int i;

	if (intsrc == INTSRC_VME)
		intmask = m188_intsrc[INTSRC_VME + (ipl - 1)];
	else
		intmask = m188_intsrc[intsrc];

	psr = get_psr();
	set_psr(psr | PSR_IND);

	for (i = 0; i < NIPLS; i++)
		int_mask_val[i] &= ~intmask;

	setipl(getipl());
	set_psr(psr);
}

int
m188_intsrc_establish(u_int intsrc, struct intrhand *ih, const char *name)
{
	intrhand_t *list;

#ifdef DIAGNOSTIC
	if (intsrc == INTSRC_VME)
		return EINVAL;
#endif

	list = &syscon_intr_handlers[intsrc];
	if (!SLIST_EMPTY(list)) {
#ifdef DIAGNOSTIC
		printf("%s: interrupt source %u already registered\n",
		    __func__, intsrc);
#endif
		return EINVAL;
	}

	if (m188_intsrc_available(intsrc, ih->ih_ipl) != 0)
		return EINVAL;

	evcount_attach(&ih->ih_count, name, &ih->ih_ipl);
	SLIST_INSERT_HEAD(list, ih, ih_link);
	m188_intsrc_enable(intsrc, ih->ih_ipl);

	return 0;
}

void
m188_intsrc_disestablish(u_int intsrc, struct intrhand *ih)
{
	intrhand_t *list;

#ifdef DIAGNOSTIC
	if (intsrc == INTSRC_VME)
		return;
#endif

	list = &syscon_intr_handlers[intsrc];
	evcount_detach(&ih->ih_count);
	SLIST_REMOVE(list, ih, intrhand, ih_link);

	m188_intsrc_disable(intsrc, ih->ih_ipl);
}

/*
 * Clock routines
 */

/*
 * Notes on the MVME188 clock usage:
 *
 * We have two sources for timers:
 * - two counter/timers in the DUART (MC68681/MC68692)
 * - three counter/timers in the Zilog Z8536
 *
 * However:
 * - Z8536 CT#3 is reserved as a watchdog device; and its input is
 *   user-controllable with jumpers on the SYSCON board, so we can't
 *   really use it.
 * - When using the Z8536 in timer mode, it _seems_ like it resets at
 *   0xffff instead of the initial count value...
 * - Despite having per-counter programmable interrupt vectors, the
 *   SYSCON logic forces fixed vectors for the DUART and the Z8536 timer
 *   interrupts.
 * - The DUART timers keep counting down from 0xffff even after
 *   interrupting, and need to be manually stopped, then restarted, to
 *   resume counting down the initial count value.
 *
 * Also, while the Z8536 has a very reliable 4MHz clock source, the
 * 3.6864MHz clock source of the DUART timers does not seem to be precise
 * enough (and is apparently slowed down when there are four processors).
 *
 * As a result, clock is run on a Z8536 counter, kept in counter mode and
 * retriggered every interrupt, while statclock is run on a DUART counter,
 * but in practice runs at an average 96Hz instead of the expected 100Hz.
 *
 * It should be possible to run statclock on the Z8536 counter #2, but
 * this would make interrupt handling more tricky, in the case both
 * counters interrupt at the same time...
 */

#define	DART_REG(x)	((volatile uint8_t *)(DART_BASE | ((x) << 2) | 0x03))

void	m188_cio_init(u_int);
u_int	read_cio(int);
void	write_cio(int, u_int);

int	m188_clockintr(void *);
int	m188_calibrateintr(void *);
int	m188_statintr(void *);
u_int	m188_cio_get_timecount(struct timecounter *);

volatile int	m188_calibrate_phase = 0;

uint32_t	cio_step;
uint32_t	cio_refcnt;
uint32_t	cio_lastcnt;

struct mutex cio_mutex = MUTEX_INITIALIZER(IPL_CLOCK);

struct timecounter m188_cio_timecounter = {
	m188_cio_get_timecount,
	NULL,
	0xffffffff,
	0,
	"cio",
	0,
	NULL
};

void
m188_init_clocks(void)
{
	int statint, minint;
	u_int iter, divisor;
	u_int32_t psr;

	psr = get_psr();
	set_psr(psr | PSR_IND);

#ifdef DIAGNOSTIC
	if (1000000 % hz) {
		printf("cannot get %d Hz clock; using 100 Hz\n", hz);
		hz = 100;
	}
#endif
	tick = 1000000 / hz;

	m188_cio_init(tick);

	if (stathz == 0)
		stathz = hz;
#ifdef DIAGNOSTIC
	if (1000000 % stathz) {
		printf("cannot get %d Hz statclock; using 100 Hz\n", stathz);
		stathz = 100;
	}
#endif
	profhz = stathz;		/* always */

	/*
	 * The DUART runs at 3.6864 MHz, CT#1 will run in PCLK/16 mode.
	 */
	statint = (3686400 / 16) / stathz;
	minint = statint / 2 + 100;
	while (statvar > minint)
		statvar >>= 1;
	statmin = statint - (statvar >> 1);

	/* clear the counter/timer output OP3 while we program the DART */
	*DART_REG(DART_OPCR) = DART_OPCR_OP3;
	/* do the stop counter/timer command */
	(void)*DART_REG(DART_CTSTOP);
	/* set counter/timer to counter mode, PCLK/16 */
	*DART_REG(DART_ACR) = DART_ACR_CT_COUNTER_CLK_16 | DART_ACR_BRG_SET_1;
	*DART_REG(DART_CTUR) = statint >> 8;
	*DART_REG(DART_CTLR) = statint & 0xff;
	/* give the start counter/timer command */
	(void)*DART_REG(DART_CTSTART);
	/* set the counter/timer output OP3 */
	*DART_REG(DART_OPCR) = DART_OPCR_CT_OUTPUT;

	statclock_ih.ih_fn = m188_statintr;
	statclock_ih.ih_arg = 0;
	statclock_ih.ih_wantframe = 1;
	statclock_ih.ih_ipl = IPL_STATCLOCK;
	platform->intsrc_establish(INTSRC_DTIMER, &statclock_ih, "stat");

	/*
	 * Calibrate delay const.
	 */
	clock_ih.ih_fn = m188_calibrateintr;
	clock_ih.ih_arg = 0;
	clock_ih.ih_wantframe = 1;
	clock_ih.ih_ipl = IPL_CLOCK;
	platform->intsrc_establish(INTSRC_CIO, &clock_ih, "clock");

	dumb_delay_const = 1;
	set_psr(psr);
	while (m188_calibrate_phase == 0)
		;

	iter = 0;
	while (m188_calibrate_phase == 1) {
		delay(10000);
		iter++;
	}

	divisor = 1000000 / 10000;
	dumb_delay_const = (iter * hz + divisor - 1) / divisor;

	set_psr(psr | PSR_IND);

	platform->intsrc_disestablish(INTSRC_CIO, &clock_ih);
	clock_ih.ih_fn = m188_clockintr;
	platform->intsrc_establish(INTSRC_CIO, &clock_ih, "clock");

	set_psr(psr);

	tc_init(&m188_cio_timecounter);
}

int
m188_calibrateintr(void *eframe)
{
	/* no need to grab the mutex, only one processor is running for now */
	/* ack the interrupt */
	write_cio(ZCIO_CT1CS, ZCIO_CTCS_GCB | ZCIO_CTCS_C_IP); 

	m188_calibrate_phase++;

	return (1);
}

int
m188_clockintr(void *eframe)
{
	mtx_enter(&cio_mutex);
	/* ack the interrupt */
	write_cio(ZCIO_CT1CS, ZCIO_CTCS_GCB | ZCIO_CTCS_C_IP); 
	cio_refcnt += cio_step;
	mtx_leave(&cio_mutex);

	hardclock(eframe);

#ifdef MULTIPROCESSOR
	/*
	 * Send an IPI to all other processors, so they can get their
	 * own ticks.
	 */
	m88k_broadcast_ipi(CI_IPI_HARDCLOCK);
#endif

	return (1);
}

int
m188_statintr(void *eframe)
{
	u_long newint, r, var;

	/* stop counter and acknowledge interrupt */
	(void)*DART_REG(DART_CTSTOP);
	(void)*DART_REG(DART_ISR);

	/*
	 * Compute new randomized interval.  The intervals are
	 * uniformly distributed on
	 * [statint - statvar / 2, statint + statvar / 2],
	 * and therefore have mean statint, giving a stathz
	 * frequency clock.
	 */
	var = statvar;
	do {
		r = random() & (var - 1);
	} while (r == 0);
	newint = statmin + r;

	/* setup new value and restart counter */
	*DART_REG(DART_CTUR) = newint >> 8;
	*DART_REG(DART_CTLR) = newint & 0xff;
	(void)*DART_REG(DART_CTSTART);

	statclock((struct clockframe *)eframe);

#ifdef MULTIPROCESSOR
	/*
	 * Send an IPI to all other processors as well.
	 */
	m88k_broadcast_ipi(CI_IPI_STATCLOCK);
#endif

	return (1);
}

/* Write CIO register */
void
write_cio(int reg, u_int val)
{
	volatile int i;
	volatile u_int32_t *cio_ctrl = (volatile u_int32_t *)CIO_CTRL;

	i = *cio_ctrl;				/* goto state 1 */
	*cio_ctrl = 0;				/* take CIO out of RESET */
	i = *cio_ctrl;				/* reset CIO state machine */

	*cio_ctrl = (reg & 0xff);		/* select register */
	*cio_ctrl = (val & 0xff);		/* write the value */
}

/* Read CIO register */
u_int
read_cio(int reg)
{
	int c;
	volatile int i;
	volatile u_int32_t *cio_ctrl = (volatile u_int32_t *)CIO_CTRL;

	/* select register */
	*cio_ctrl = (reg & 0xff);
	/* delay for a short time to allow 8536 to settle */
	for (i = 0; i < 100; i++)
		;
	/* read the value */
	c = *cio_ctrl;
	return (c & 0xff);
}

/*
 * Initialize the CTC (8536)
 * Only the counter/timers are used - the IO ports are un-comitted.
 */
void
m188_cio_init(u_int period)
{
	volatile int i;

	/* Start by forcing chip into known state */
	read_cio(ZCIO_MIC);
	write_cio(ZCIO_MIC, ZCIO_MIC_RESET);	/* Reset the CTC */
	for (i = 0; i < 1000; i++)	 	/* Loop to delay */
		;

	/* Clear reset and start init seq. */
	write_cio(ZCIO_MIC, 0x00);

	/* Wait for chip to come ready */
	while ((read_cio(ZCIO_MIC) & ZCIO_MIC_RJA) == 0)
		;

	/* Initialize the 8536 for real */
	write_cio(ZCIO_MIC,
	    ZCIO_MIC_MIE /* | ZCIO_MIC_NV */ | ZCIO_MIC_RJA | ZCIO_MIC_DLC);
	write_cio(ZCIO_CT1MD, ZCIO_CTMD_CSC);	/* Continuous count */
	write_cio(ZCIO_PBDIR, 0xff);		/* set port B to input */

	period <<= 1;	/* CT#1 runs at PCLK/2, hence 2MHz */
	write_cio(ZCIO_CT1TCM, period >> 8);
	write_cio(ZCIO_CT1TCL, period);
	/* enable counter #1 */
	write_cio(ZCIO_MCC, ZCIO_MCC_CT1E | ZCIO_MCC_PBE);
	write_cio(ZCIO_CT1CS, ZCIO_CTCS_GCB | ZCIO_CTCS_TCB | ZCIO_CTCS_S_IE);

	cio_step = period;
	m188_cio_timecounter.tc_frequency = (u_int64_t)cio_step * hz;
}

u_int
m188_cio_get_timecount(struct timecounter *tc)
{
	u_int cmsb, clsb, counter, curcnt;

	/*
	 * The CIO counter is free running, but by setting the
	 * RCC bit in its control register, we can read a frozen
	 * value of the counter.
	 * The counter will automatically unfreeze after reading
	 * its LSB.
	 */

	mtx_enter(&cio_mutex);
	write_cio(ZCIO_CT1CS, ZCIO_CTCS_GCB | ZCIO_CTCS_RCC);
	cmsb = read_cio(ZCIO_CT1CCM);
	clsb = read_cio(ZCIO_CT1CCL);
	curcnt = cio_refcnt;

	counter = (cmsb << 8) | clsb;
#if 0	/* this will never happen unless the period itself is 65536 */
	if (counter == 0)
		counter = 65536;
#endif

	/*
	 * The counter counts down from its initialization value to 1.
	 */
	counter = cio_step - counter;

	curcnt += counter;
	if (curcnt < cio_lastcnt)
		curcnt += cio_step;

	cio_lastcnt = curcnt;
	mtx_leave(&cio_mutex);
	return curcnt;
}

/*
 * Setup VME bus access and return the lower interrupt number usable by VME
 * boards.
 */
u_int
m188_init_vme(const char *devname)
{
	u_int32_t ucsr;

	/*
	 * Force a reasonable timeout for VME data transfers.
	 * We can not disable this, this would cause autoconf to hang
	 * on the first missing device we'll probe.
	 */
	ucsr = *(volatile u_int32_t*)MVME188_UCSR;
	ucsr = (ucsr & ~VTOSELBITS) | VTO128US;
	*(volatile u_int32_t *)MVME188_UCSR = ucsr;

	return 0;	/* all vectors available */
}
@


1.57
log
@switch mvme88k to the MI dart(4) code. Tested on MVME181 and MVME188.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.56 2013/05/17 22:46:28 miod Exp $	*/
@


1.56
log
@Replace the bunch of md_* function pointers with a `struct board' containing
function pointers for all the board-specific code.

Add a bunch of `struct board' methods to cover most, if not all, of the
`per-board' logic. This allows most of the md drivers to be cleaned up and
no longer need to embed board-specific knowledge.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.55 2013/02/17 18:07:36 miod Exp $	*/
d153 2
a155 1
#include <mvme88k/mvme88k/clockvar.h>
a899 17
void	m188_cio_init(u_int);
u_int	read_cio(int);
void	write_cio(int, u_int);

int	m188_clockintr(void *);
int	m188_calibrateintr(void *);
int	m188_statintr(void *);
u_int	m188_cio_get_timecount(struct timecounter *);

volatile int	m188_calibrate_phase = 0;

uint32_t	cio_step;
uint32_t	cio_refcnt;
uint32_t	cio_lastcnt;

struct mutex cio_mutex = MUTEX_INITIALIZER(IPL_CLOCK);

d921 2
a922 1
 * 3.6864MHz clock source of the DUART timers does not seem to be correct.
d933 18
a950 8
#define	DART_ISR		0xfff82017	/* interrupt status */
#define	DART_IVR		0xfff82033	/* interrupt vector */
#define	DART_STARTC		0xfff8203b	/* start counter cmd */
#define	DART_STOPC		0xfff8203f	/* stop counter cmd */
#define	DART_ACR		0xfff82013	/* auxiliary control */
#define	DART_CTUR		0xfff8201b	/* counter/timer MSB */
#define	DART_CTLR		0xfff8201f	/* counter/timer LSB */
#define	DART_OPCR		0xfff82037	/* output port config*/
a964 1
	volatile u_int8_t imr;
d1002 1
a1002 1
	*(volatile u_int8_t *)DART_OPCR = 0x00;
d1004 1
a1004 1
	imr = *(volatile u_int8_t *)DART_STOPC;
d1006 5
a1010 3
	*(volatile u_int8_t *)DART_ACR = 0x30;
	*(volatile u_int8_t *)DART_CTUR = (statint >> 8);
	*(volatile u_int8_t *)DART_CTLR = (statint & 0xff);
d1012 1
a1012 3
	*(volatile u_int8_t *)DART_OPCR = 0x04;
	/* give the start counter/timer command */
	imr = *(volatile u_int8_t *)DART_STARTC;
a1090 1
	volatile u_int8_t tmp;
d1094 2
a1095 2
	tmp = *(volatile u_int8_t *)DART_STOPC;
	tmp = *(volatile u_int8_t *)DART_ISR;
d1111 3
a1113 3
	*(volatile u_int8_t *)DART_CTUR = (newint >> 8);
	*(volatile u_int8_t *)DART_CTLR = (newint & 0xff);
	tmp = *(volatile u_int8_t *)DART_STARTC;
@


1.55
log
@Constify struct cmmu.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.54 2010/12/31 21:38:08 miod Exp $	*/
d3 1
a3 1
 * Copyright (c) 2009 Miodrag Vallat.
d128 4
d141 1
d144 2
d150 1
a152 1
#include <mvme88k/dev/sysconvar.h>
d160 37
a196 2
void	m188_reset(void);
u_int	safe_level(u_int, u_int);
a197 1
void	m188_bootstrap(void);
a198 3
void	m188_ext_int(struct trapframe *);
u_int	m188_getipl(void);
void	m188_init_clocks(void);
a199 2
vaddr_t	m188_memsize(void);
u_int	m188_raiseipl(u_int);
a200 7
u_int	m188_setipl(u_int);

/*
 * The MVME188 interrupt arbiter has 25 orthogonal interrupt sources.
 * We fold this model in the 8-level spl model this port uses, enforcing
 * priorities manually with the interrupt masks.
 */
a208 5
/*
 * Interrupt masks, one per IPL level.
 */
u_int32_t int_mask_val[NIPLS];

d217 20
d265 5
a269 2
void
m188_bootstrap()
d271 3
a273 1
	extern const struct cmmu_p cmmu8820x;
d275 34
a308 13
	cmmu = &cmmu8820x;
	md_interrupt_func_ptr = m188_ext_int;
	md_getipl = m188_getipl;
	md_setipl = m188_setipl;
	md_raiseipl = m188_raiseipl;
	md_init_clocks = m188_init_clocks;
#ifdef MULTIPROCESSOR
	md_send_ipi = m188_send_ipi;
#endif
	md_delay = m188_delay;
#ifdef MULTIPROCESSOR
	md_smp_setup = m88100_smp_setup;
#endif
d310 1
a310 2
	/* clear and disable all interrupts */
	*(volatile u_int32_t *)MVME188_IENALL = 0;
d313 3
d317 1
a317 1
m188_reset()
d337 10
a346 1
	printf("reset failed\n");
d354 1
a354 1
safe_level(u_int mask, u_int curlevel)
a369 159
u_int
m188_getipl(void)
{
	return m188_curspl[cpu_number()];
}

u_int
m188_setipl(u_int level)
{
	u_int curspl, mask, psr;
#ifdef MULTIPROCESSOR
	struct cpu_info *ci = curcpu();
	int cpu = ci->ci_cpuid;
#else
	int cpu = cpu_number();
#endif

	psr = get_psr();
	set_psr(psr | PSR_IND);

	curspl = m188_curspl[cpu];

	mask = int_mask_val[level];
#ifdef MULTIPROCESSOR
	if (cpu != master_cpu)
		mask &= SLAVE_MASK;
	mask |= SWI_IPI_MASK(cpu);
	if (level < IPL_CLOCK)
		mask |= SWI_CLOCK_IPI_MASK(cpu);
#endif

	m188_curspl[cpu] = level;
	*(u_int32_t *)MVME188_IEN(cpu) = int_mask_reg[cpu] = mask;
	/*
	 * We do not flush the pipeline here, because interrupts are disabled,
	 * and set_psr() will synchronize the pipeline.
	 */
	set_psr(psr);

	return curspl;
}

u_int
m188_raiseipl(u_int level)
{
	u_int mask, curspl, psr;
#ifdef MULTIPROCESSOR
	struct cpu_info *ci = curcpu();
	int cpu = ci->ci_cpuid;
#else
	int cpu = cpu_number();
#endif

	psr = get_psr();
	set_psr(psr | PSR_IND);

	curspl = m188_curspl[cpu];
	if (curspl < level) {
		mask = int_mask_val[level];
#ifdef MULTIPROCESSOR
		if (cpu != master_cpu)
			mask &= SLAVE_MASK;
		mask |= SWI_IPI_MASK(cpu);
		if (level < IPL_CLOCK)
			mask |= SWI_CLOCK_IPI_MASK(cpu);
#endif

		m188_curspl[cpu] = level;
		*(u_int32_t *)MVME188_IEN(cpu) = int_mask_reg[cpu] = mask;
	}
	/*
	 * We do not flush the pipeline here, because interrupts are disabled,
	 * and set_psr() will synchronize the pipeline.
	 */
	set_psr(psr);

	return curspl;
}

#ifdef MULTIPROCESSOR

void
m188_send_ipi(int ipi, cpuid_t cpu)
{
	struct cpu_info *ci = &m88k_cpus[cpu];
	u_int32_t bits = 0;

	if (ci->ci_ipi & ipi)
		return;

	atomic_setbits_int(&ci->ci_ipi, ipi);
	if (ipi & ~(CI_IPI_HARDCLOCK | CI_IPI_STATCLOCK))
		bits |= SWI_IPI_BIT(cpu);
	if (ipi & (CI_IPI_HARDCLOCK | CI_IPI_STATCLOCK))
		bits |= SWI_CLOCK_IPI_BIT(cpu);
	*(volatile u_int32_t *)MVME188_SETSWI = bits;
}

/*
 * Process inter-processor interrupts.
 */

/*
 * Unmaskable IPIs - those are processed with interrupts disabled,
 * and no lock held.
 */
void
m188_ipi_handler(struct trapframe *eframe)
{
	struct cpu_info *ci = curcpu();
	int ipi = ci->ci_ipi & (CI_IPI_DDB | CI_IPI_NOTIFY);

	*(volatile u_int32_t *)MVME188_CLRSWI = SWI_IPI_BIT(ci->ci_cpuid);
	atomic_clearbits_int(&ci->ci_ipi, ipi);

	if (ipi & CI_IPI_DDB) {
#ifdef DDB
		/*
		 * Another processor has entered DDB. Spin on the ddb lock
		 * until it is done.
		 */
		extern struct __mp_lock ddb_mp_lock;

		__mp_lock(&ddb_mp_lock);
		__mp_unlock(&ddb_mp_lock);

		/*
		 * If ddb is hoping to us, it's our turn to enter ddb now.
		 */
		if (ci->ci_cpuid == ddb_mp_nextcpu)
			Debugger();
#endif
	}
	if (ipi & CI_IPI_NOTIFY) {
		/* nothing to do */
	}
}

/*
 * Maskable IPIs
 */
void
m188_clock_ipi_handler(struct trapframe *eframe)
{
	struct cpu_info *ci = curcpu();
	int ipi = ci->ci_ipi & (CI_IPI_HARDCLOCK | CI_IPI_STATCLOCK);

	/* clear clock ipi interrupt */
	*(volatile u_int32_t *)MVME188_CLRSWI = SWI_CLOCK_IPI_BIT(ci->ci_cpuid);
	atomic_clearbits_int(&ci->ci_ipi, ipi);

	if (ipi & CI_IPI_HARDCLOCK)
		hardclock((struct clockframe *)eframe);
	if (ipi & CI_IPI_STATCLOCK)
		statclock((struct clockframe *)eframe);
}

#endif

d373 1
a373 1
const u_int obio_vec[32] = {
d416 1
a416 1
m188_ext_int(struct trapframe *eframe)
d489 1
a489 1
		level = safe_level(cur_mask, old_spl);
d512 1
a512 1
		intsrc = obio_vec[intbit];
d541 1
a541 1
			list = &sysconintr_handlers[intsrc];
d614 281
a909 3
/* multiplication factor for delay() */
u_int	m188_delay_const = 25;		/* no MVME188 is faster than 25MHz */

d1024 1
a1024 1
	sysconintr_establish(INTSRC_DTIMER, &statclock_ih, "stat");
d1033 1
a1033 1
	sysconintr_establish(INTSRC_CIO, &clock_ih, "clock");
d1035 1
a1035 1
	m188_delay_const = 1;
d1047 1
a1047 1
	m188_delay_const = (iter * hz + divisor - 1) / divisor;
d1051 1
a1051 1
	sysconintr_disestablish(INTSRC_CIO, &clock_ih);
d1053 1
a1053 1
	sysconintr_establish(INTSRC_CIO, &clock_ih, "clock");
d1139 1
a1139 1
	volatile u_int32_t * cio_ctrl = (volatile u_int32_t *)CIO_CTRL;
d1155 1
a1155 1
	volatile u_int32_t * cio_ctrl = (volatile u_int32_t *)CIO_CTRL;
d1243 21
@


1.54
log
@Massive overhauling of the m88k pmap, though I can't pretend it's a new pmap
since a large part of the structures and logic remains.

Since m88k has separate supervisor/user spaces, we can map physical memory 1:1
in supervisor space, and have the kernel virtual address space start from the
end of physical memory.

This allows us to switch to __HAVE_PMAP_DIRECT. And to get rid of the double
mapped sdt, since now their virtual and physical addresses will always match.

The upper bound of the kernel virtual memory space is now platform dependent,
until the code which relies upon some hardware devices being mapped 1:1 in
supervisor mode is updated to no longer require this (this is mainly a PITA on
luna88k, where onboard devices start at 0x40000000, leaving only 1GB of KVA at
the moment - still much better than the previous 512MB).

Tested on mvme88k only (187, 188, 197LE, 197DP). Other platforms ought to
work, aviion will be checked shortly and fixed if necessary. No known
OpenBSD/luna88k system in working condition at the moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.53 2009/03/15 20:39:53 miod Exp $	*/
d224 1
a224 1
	extern struct cmmu_p cmmu8820x;
@


1.53
log
@Generic softinterrupt support for m88k based platforms, adapted from arm
with different locking mechanism. 88110 soft ipi are replaced with an
ipi callback which is checked upon return from exception (it can not be kept
as a softintr, as the generic softinterrupt code doesn't have per-cpu
pending softintr queues).
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.52 2009/03/09 19:51:18 miod Exp $	*/
a165 1
void	m188_startup(void);
a218 5
}

void
m188_startup()
{
@


1.52
log
@Switch mvme88k to timecounters.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.51 2009/03/08 16:03:06 miod Exp $	*/
a165 1
void	m188_soft_ipi(void);
a239 1
	md_soft_ipi = m188_soft_ipi;
a449 6
}

void
m188_soft_ipi()
{
	/* this function is not used on MVME188 */
@


1.51
log
@Move more z8536 defines from MVME188 specific code to the MI header and use it.
@
text
@d1 16
a16 1
/*	$OpenBSD: m188_machdep.c,v 1.50 2009/02/21 18:37:48 miod Exp $	*/
d132 1
d717 1
d724 5
a728 12
#if defined(MULTIPROCESSOR) && 0
#include <machine/lock.h>
__cpu_simple_lock_t m188_cio_lock;

#define	CIO_LOCK_INIT()	__cpu_simple_lock_init(&m188_cio_lock)
#define	CIO_LOCK()	__cpu_simple_lock(&m188_cio_lock)
#define	CIO_UNLOCK()	__cpu_simple_unlock(&m188_cio_lock)
#else
#define	CIO_LOCK_INIT()	do { } while (0)
#define	CIO_LOCK()	do { } while (0)
#define	CIO_UNLOCK()	do { } while (0)
#endif
d771 10
a791 2
	CIO_LOCK_INIT();

d870 2
d877 1
a877 1
	CIO_LOCK();
a879 3
	/* restart counter */
	write_cio(ZCIO_CT1CS, ZCIO_CTCS_GCB | ZCIO_CTCS_TCB | ZCIO_CTCS_S_IE);
	CIO_UNLOCK();
d889 1
a889 1
	CIO_LOCK();
d892 2
a893 3
	/* restart counter */
	write_cio(ZCIO_CT1CS, ZCIO_CTCS_GCB | ZCIO_CTCS_TCB | ZCIO_CTCS_S_IE);
	CIO_UNLOCK();
d1015 42
@


1.50
log
@Move part of the mp lock logic into per-cpu callbacks; on MVME197DP we need
to disable NMI sources in addition to interrupt sources, and we can not
use a quick sequence with shadowing frozen as done for atomic ops.

This lets GENERIC.MP boot multiuser on MVME197DP boards, and is so far stable
enough to be able to recompile a kernel from scratch (with make -j2).
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.49 2009/02/20 23:35:11 miod Exp $	*/
d130 1
d858 2
a859 2
	write_cio(CIO_CSR1, CIO_GCB | CIO_CIP);  /* Ack the interrupt */

d861 1
a861 1
	write_cio(CIO_CSR1, CIO_GCB | CIO_TCB | CIO_IE);
d873 2
a874 2
	write_cio(CIO_CSR1, CIO_GCB | CIO_CIP);  /* Ack the interrupt */

d876 1
a876 1
	write_cio(CIO_CSR1, CIO_GCB | CIO_TCB | CIO_IE);
d975 2
a976 2
	read_cio(CIO_MICR);
	write_cio(CIO_MICR, CIO_MICR_RESET);	/* Reset the CTC */
d981 1
a981 1
	write_cio(CIO_MICR, 0x00);
d984 1
a984 1
	while ((read_cio(CIO_MICR) & CIO_MICR_RJA) == 0)
d988 4
a991 4
	write_cio(CIO_MICR,
	    CIO_MICR_MIE /* | CIO_MICR_NV */ | CIO_MICR_RJA | CIO_MICR_DLC);
	write_cio(CIO_CTMS1, CIO_CTMS_CSC);	/* Continuous count */
	write_cio(CIO_PDCB, 0xff);		/* set port B to input */
d994 2
a995 2
	write_cio(CIO_CT1MSB, period >> 8);
	write_cio(CIO_CT1LSB, period);
d997 2
a998 2
	write_cio(CIO_MCCR, CIO_MCCR_CT1E | CIO_MCCR_PBE);
	write_cio(CIO_CSR1, CIO_GCB | CIO_TCB | CIO_IE);
@


1.49
log
@When looping to process external interrupts, do not complain (and panic)
if another processors sends us an IPI, it will get handled later.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.48 2009/02/16 23:03:33 miod Exp $	*/
d227 3
@


1.48
log
@More 88110 SMP work. Contains, horribly entangled:
- dma_cachectl() split into a ``local cpu only'' and ``all cpus'', and an ipi
  to broadcast ``local dma_cachectl'' is added.
- cpu_info fields are rearranged, to have the 88100-specific information
  and the 88110-specific information overlap, and has many more 88110
  ugly things.
- more ipi handling in the 197-specific area. Since it is not possible to
  have the second processor receive any hardware interrupt (selection
  is done on a level basis via ISEL, and we definitely do not want the
  main cpu to lose interrupts), the best we can do is to inflict ourselves
  a soft interrupt for late ipi processing. It gets used for softclock and
  hardclock on the secondary processor, but since the soft interrupt
  dispatcher doesn't have an exception frame, we have to remember parts
  of it to build a fake clockframe from the soft ipi handler (ugly but
  works).

This now lets GENERIC.MP run a few userland binaries before bugs trigger.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.47 2009/02/16 22:55:03 miod Exp $	*/
d655 2
a656 1
	} while (((cur_mask = ISR_GET_CURRENT_MASK(cpu)) & ~ign_mask) != 0);
@


1.47
log
@Since NMI are now handled separately, remove the ``interrupt type'' argument
from interrupt() and related function pointers.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.46 2009/02/13 23:26:51 miod Exp $	*/
d149 1
d224 1
d432 6
@


1.46
log
@Make delay() a per-board function pointer.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.45 2008/11/27 21:43:03 miod Exp $	*/
d141 1
a141 1
void	m188_ext_int(u_int, struct trapframe *);
d480 1
a480 1
m188_ext_int(u_int v, struct trapframe *eframe)
@


1.45
log
@It turns out Motorola manufactured ECC 128MB memory boards for MVME188
assemblies, so allow up to 512MB of memory on MVME188 systems. Thanks maz
for the 128MB board!
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.44 2007/12/27 23:17:55 miod Exp $	*/
d224 1
@


1.44
log
@Make the mvme188 interrupt handling closer to the aviion interrupt handling:
non-VME syscon interrupt sources will now use their own intrhand array,
and interrupt sources will be enabled in the arbiter as interrupt handlers
are registered. This allows VME devices to use the whole 256 interrupts range.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.43 2007/11/17 05:37:53 miod Exp $	*/
d183 1
a183 1
 * As a safety measure, we never check for more than 256MB - the 188 can
d185 1
a185 1
 * than 64MB, and I am not aware of third-party larger memory boards.
d193 1
a193 1
#define	MVME188_MAX_MEMORY	((4 * 64) / 4)	/* 4 64MB boards */
@


1.43
log
@The initial ipl on luna/mvme188 like interrupt arbiters is IPL_HIGH, not
IPL_NONE; fixes a false splassert warning on boot.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.42 2007/11/17 05:36:23 miod Exp $	*/
d129 1
a129 1
#include <mvme88k/dev/sysconreg.h>
d165 1
a165 1
 * external interrupt masks per spl.
d167 8
a174 10
const u_int32_t int_mask_val[INT_LEVEL] = {
	MASK_LVL_0,
	MASK_LVL_1,
	MASK_LVL_2,
	MASK_LVL_3,
	MASK_LVL_4,
	MASK_LVL_5,
	MASK_LVL_6,
	MASK_LVL_7
};
a226 3

	/* supply a vector base for m188ih */
	*(volatile u_int8_t *)MVME188_VIRQV = M188_IVEC;
d267 1
a267 1
	for (i = curlevel; i < INT_LEVEL; i++)
d271 1
a271 1
	return (INT_LEVEL - 1);
d299 1
a299 1
		mask &= ~SLAVE_MASK;
d335 1
a335 1
			mask &= ~SLAVE_MASK;
d434 1
a434 6
 * Device interrupt handler for MVME188
 */

/*
 * Hard coded vector table for onboard devices and hardware failure
 * interrupts.
d441 1
a441 1
	0,		/* VME1 */
d443 3
a445 3
	0,		/* VME2 */
	0,		/* SIGLPI */	/* no vector, but always masked */
	0,		/* LMI */	/* no vector, but always masked */
d447 1
a447 1
	0,		/* VME3 */
d449 1
a449 1
	0,		/* VME4 */
d451 1
a451 1
	0,		/* VME5 */
d453 2
a454 2
	0,		/* SIGHPI */	/* no vector, but always masked */
	SYSCV_SCC,	/* DI */
d456 3
a458 3
	0,		/* VME6 */
	SYSCV_SYSF,	/* SF */
	SYSCV_TIMER2,	/* CIOI */
d460 1
a460 1
	0,		/* VME7 */
d465 4
a468 4
	SYSCV_TIMER1,	/* DTI */
	0,		/* ARBTO */	/* no vector, but always masked */
	SYSCV_ACF,	/* ACF */
	SYSCV_ABRT	/* ABORT */
d471 4
d493 1
a493 1
	u_int vec;
d495 1
d572 9
a580 1
		/* generate IACK and get the vector */
d582 1
a582 16
		intbit = ff1(cur_mask);
		if (OBIO_INTERRUPT_MASK & (1 << intbit)) {
			vec = obio_vec[intbit];
			if (vec == 0) {
				panic("unknown onboard interrupt: mask = 0x%b",
				    1 << intbit, IST_STRING);
			}
			vec += SYSCON_VECT;
		} else if (HW_FAILURE_MASK & (1 << intbit)) {
			vec = obio_vec[intbit];
			if (vec == 0) {
				panic("unknown hardware failure: mask = 0x%b",
				    1 << intbit, IST_STRING);
			}
			vec += SYSCON_VECT;
		} else if (VME_INTERRUPT_MASK & (1 << intbit)) {
d587 3
a589 11
				 * This could be a self-inflicted interrupt.
				 * Except that we never write to VIRQV, so
				 * such things do not happen.

				u_int src = 0x07 &
				    *(volatile u_int32_t *)MVME188_VIRQLV;
				if (src == 0)
					vec = 0xff &
					    *(volatile u_int32_t *)MVME188_VIRQV;
				else

d591 9
a599 17
				{
					/*
					 * If only one VME interrupt is
					 * registered with this IPL,
					 * we can reasonably safely
					 * assume that this is our vector.
					 */
					vec = vmevec_hints[level];
					if (vec == (u_int)-1) {
						printf("%s: timeout getting VME"
						    " interrupt vector, "
						    "level %d, mask 0x%b\n",
						    __func__, level,
						   cur_mask, IST_STRING); 
						ign_mask |=  1 << intbit;
						continue;
					}
d602 1
a602 5
			if (vec == 0) {
				panic("%s: invalid VME interrupt vector, "
				    "level %d, mask 0x%b",
				    __func__, level, cur_mask, IST_STRING);
			}
d604 1
a604 3
			panic("%s: unexpected interrupt source, "
			    "level %d, mask 0x%b",
			    __func__, level, cur_mask, IST_STRING);
a606 1
		list = &intr_handlers[vec];
d608 1
a608 4
			printf("%s: spurious interrupt, "
			    "level %d, vec 0x%x, mask 0x%b\n",
			    __func__, level, vec, cur_mask, IST_STRING);
			ign_mask |=  1 << intbit;
d626 9
a634 2
			if (ret == 0) {
				printf("%s: unclaimed interrupt, "
d636 9
a644 4
				    __func__, level, vec, cur_mask, IST_STRING);
				ign_mask |=  1 << intbit;
				continue;
			}
d685 1
d688 5
d752 5
a790 2
	/* set interrupt vec */
	*(volatile u_int8_t *)DART_IVR = SYSCON_VECT + SYSCV_TIMER1;
d802 10
a811 1
	clock_ih.ih_fn = m188_clockintr;
d815 15
a829 1
	sysconintr_establish(SYSCV_TIMER2, &clock_ih, "clock");
d831 22
a852 5
	statclock_ih.ih_fn = m188_statintr;
	statclock_ih.ih_arg = 0;
	statclock_ih.ih_wantframe = 1;
	statclock_ih.ih_ipl = IPL_STATCLOCK;
	sysconintr_establish(SYSCV_TIMER1, &statclock_ih, "stat");
@


1.42
log
@Replace many ``unsigned'' variables with ``unsigned int'', ``u_int'' or other
appropriate types. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.41 2007/11/17 05:32:05 miod Exp $	*/
d162 1
a162 1
u_int m188_curspl[] = { IPL_NONE, IPL_NONE, IPL_NONE, IPL_NONE };
@


1.41
log
@Rework {get,set,raise}ipl() to minimize psr modification, especially on
boards such as mvme1[89]7 where spl changes can be atomic.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.40 2007/11/14 23:14:14 miod Exp $	*/
d160 1
a160 1
unsigned int int_mask_reg[] = { 0, 0, 0, 0 };
d167 1
a167 1
const unsigned int int_mask_val[INT_LEVEL] = {
d192 1
a192 1
	unsigned int pgnum;
d446 1
a446 1
const unsigned int obio_vec[32] = {
d493 1
a493 1
	unsigned int cur_mask, ign_mask;
d706 1
a706 1
void	m188_cio_init(unsigned);
d933 1
a933 1
m188_cio_init(unsigned period)
@


1.40
log
@No need to check whether we are the primary processor in m188_{clock,stat}intr,
since the corresponding interrupt source is enabled on the primary processor
only.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.39 2007/11/14 17:54:25 miod Exp $	*/
d162 1
a162 1
unsigned int m188_curspl[] = { IPL_NONE, IPL_NONE, IPL_NONE, IPL_NONE};
d259 2
a260 1
 * return next safe spl to reenable interrupts.
d310 1
d312 4
a315 2
	m188_curspl[cpu] = level;

d346 1
a347 1
		m188_curspl[cpu] = level;
d349 4
a352 1

d494 1
a494 1
	unsigned int level, old_spl;
@


1.39
log
@Let ``machine cpu #'' hop to the given cpu.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.38 2007/11/12 21:00:22 miod Exp $	*/
d842 1
a842 2
	if (CPU_IS_PRIMARY(curcpu()))
		m88k_broadcast_ipi(CI_IPI_HARDCLOCK);
d882 1
a882 2
	if (CPU_IS_PRIMARY(curcpu()))
		m88k_broadcast_ipi(CI_IPI_STATCLOCK);
@


1.38
log
@Restart clock before invoking hardclock() and statclock(), otherwise they
drift in MP kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.37 2007/11/12 19:59:07 miod Exp $	*/
d130 1
d132 3
a134 1
#include <mvme88k/mvme88k/clockvar.h>
d382 1
a382 1
	int ipi = ci->ci_ipi;
d385 1
d397 6
a407 2

	atomic_clearbits_int(&ci->ci_ipi, CI_IPI_DDB | CI_IPI_NOTIFY);
d417 1
a417 1
	int ipi = ci->ci_ipi;
d421 1
a426 2

	atomic_clearbits_int(&ci->ci_ipi, CI_IPI_HARDCLOCK | CI_IPI_STATCLOCK);
@


1.37
log
@Split handling of unmaskable vs maskable ipi to make the core simpler,
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.36 2007/11/11 21:17:35 miod Exp $	*/
a823 2
	hardclock(eframe);

d828 2
a851 2
	statclock((struct clockframe *)eframe);

d869 2
@


1.36
log
@Rework ipi handling to delay acking the maskable ipi interrupt, so that it
gets handled like a real hardware interrupt (which it is supposed to mimic
anyway).
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.35 2007/11/11 13:06:58 miod Exp $	*/
d137 1
d141 1
a141 1
void	m188_ipi_handler(struct trapframe *, int *);
d354 1
d361 1
a361 1
		*(volatile u_int32_t *)MVME188_SETSWI = SWI_IPI_BIT(cpu);
d363 2
a364 1
		*(volatile u_int32_t *)MVME188_SETSWI = SWI_CLOCK_IPI_BIT(cpu);
d370 5
d376 1
a376 1
m188_ipi_handler(struct trapframe *eframe, int *mask)
a379 1
	int s;
d381 1
a381 1
	*mask &= ~IPI_MASK;
a390 1
		s = m188_raiseipl(IPL_HIGH);			/* splhigh */
a392 1
		m188_setipl(s);					/* splx */
d399 19
a417 16
	if (ipi & (CI_IPI_HARDCLOCK | CI_IPI_STATCLOCK)) {
		if (eframe->tf_mask < IPL_CLOCK) {
			/* clear clock ipi interrupt */
			*(volatile u_int32_t *)MVME188_CLRSWI =
			    SWI_CLOCK_IPI_BIT(ci->ci_cpuid);
			*mask &= ~CLOCK_IPI_MASK;

			if (ipi & CI_IPI_HARDCLOCK)
				hardclock((struct clockframe *)eframe);
			if (ipi & CI_IPI_STATCLOCK)
				statclock((struct clockframe *)eframe);
		} else {
			/* leave them pending */
			ipi &= ~(CI_IPI_HARDCLOCK | CI_IPI_STATCLOCK);
		}
	}
d419 1
a419 1
	atomic_clearbits_int(&ci->ci_ipi, ipi);
a516 5
	if (old_spl < IPL_SCHED)
		__mp_lock(&kernel_lock);
#endif

#ifdef MULTIPROCESSOR
d518 1
a518 1
	 * Clear unmaskable IPIs immediately, so that we can reenable
d523 11
a533 2
	if (cur_mask & IPI_MASK)
		*(volatile u_int32_t *)MVME188_CLRSWI = SWI_IPI_BIT(cpu);
d553 1
a553 1
		 * Handle pending IPIs first.
d555 3
a557 2
		if (cur_mask & (IPI_MASK | CLOCK_IPI_MASK)) {
			m188_ipi_handler(eframe, &cur_mask);
@


1.35
log
@Use two software interrupt sources per processor for IPIs, instead of only
one, so that we can have maskable and unmaskable IPIs. Make the clock ipis
maskable, and masked at IPL_CLOCK and above. This allows us to get rid
of the retrig hack in setipl().
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.34 2007/11/09 22:50:48 miod Exp $	*/
d134 1
a134 1
u_int	safe_level(u_int mask, u_int curlevel);
d140 1
a140 1
void	m188_ipi_handler(struct trapframe *);
d263 2
d368 1
a368 1
m188_ipi_handler(struct trapframe *eframe)
a371 2
	int retrig = 0;
	int old_spl = eframe->tf_mask;
d374 2
d393 12
a404 15
	if (ipi & CI_IPI_HARDCLOCK) {
		if (old_spl < IPL_CLOCK) {
			s = m188_raiseipl(IPL_CLOCK);		/* splclock */
			hardclock((struct clockframe *)eframe);
			m188_setipl(s);				/* splx */
		} else {
			ipi &= ~CI_IPI_HARDCLOCK;	/* leave it pending */
			retrig |= CI_IPI_HARDCLOCK;
		}
	}
	if (ipi & CI_IPI_STATCLOCK) {
		if (old_spl < IPL_STATCLOCK) {
			s = m188_raiseipl(IPL_STATCLOCK);	/* splclock */
			statclock((struct clockframe *)eframe);
			m188_setipl(s);				/* splx */
d406 2
a407 2
			ipi &= ~CI_IPI_STATCLOCK;	/* leave it pending */
			retrig |= CI_IPI_STATCLOCK;
a410 7
	/*
	 * Retrigger the clock ipi if they could not be serviced yet.
	 */
	if (retrig != 0)
		*(volatile u_int32_t *)MVME188_SETSWI =
		    SWI_CLOCK_IPI_BIT(ci->ci_cpuid);

d467 1
a467 1
	int cpu = ci->ci_cpuid;
d469 1
a469 1
	int cpu = cpu_number();
a486 5
#ifdef MULTIPROCESSOR
	if (old_spl < IPL_SCHED)
		__mp_lock(&kernel_lock);
#endif

d509 5
d515 4
a518 4
	 * Clear IPIs immediately, so that we can re enable interrupts
	 * before further processing. We rely on the interrupt mask to
	 * make sure that if we get an IPI, it's really for us and no
	 * other processor.
d520 2
a521 5
	if (cur_mask & (IPI_MASK | CLOCK_IPI_MASK)) {
		*(volatile u_int32_t *)MVME188_CLRSWI =
		    SWI_IPI_BIT(cpu) | SWI_CLOCK_IPI_BIT(cpu);
		cur_mask &= ~(IPI_MASK | CLOCK_IPI_MASK);
	}
d537 1
d540 5
a544 5
			/*
			 * Handle IPIs first.
			 */
			m188_ipi_handler(eframe);

d547 1
a548 1
		}
d655 5
a672 5

#ifdef MULTIPROCESSOR
	if (old_spl < IPL_SCHED)
		__mp_unlock(&kernel_lock);
#endif
@


1.34
log
@Be more careful when handling ipis:
- only process the pending ipis once per external interrupt, at the beginning.
- use the ipl we were at when the interrupt occured, not the ipl at which
  we enabled interrupts again, in order to decide whether we can run hardclock
  or statclock.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.33 2007/10/29 19:57:48 miod Exp $	*/
d263 1
a263 1
	mask &= ~IPI_MASK;
d281 1
a281 1
	u_int curspl, mask;
d289 3
d298 3
a300 1
	mask |= IPI_BIT(cpu);
d306 1
a306 9
#ifdef MULTIPROCESSOR
	/*
	 * If we have pending IPIs and we are lowering the spl, inflict
	 * ourselves an IPI trap so that we have a chance to process this
	 * now.
	 */
	if (level < curspl && ci->ci_ipi != 0 && ci->ci_intrdepth <= 1)
		*(volatile u_int32_t *)MVME188_SETSWI = IPI_BIT(cpu);
#endif
d314 1
a314 1
	u_int mask, curspl;
d322 3
d331 3
a333 1
		mask |= IPI_BIT(cpu);
d340 2
d356 4
a359 1
	*(volatile u_int32_t *)MVME188_SETSWI = IPI_BIT(cpu);
d370 1
d396 1
a396 1
		} else
d398 2
d406 1
a406 1
		} else
d408 2
d412 7
d473 1
a473 1
#ifdef MULTIPPROCESSOR
d525 2
a526 2
	 * make sure that if we get an IPI, it's really for us and
	 * no other processor.
d528 4
a531 3
	if (cur_mask & IPI_MASK) {
		*(volatile u_int32_t *)MVME188_CLRSWI = cur_mask & IPI_MASK;
		cur_mask &= ~IPI_MASK;
@


1.33
log
@When a secondary cpu gets its interrupt pin stuck, be sure to savectx
and put the process it was running back on the run queue (unless this was
the idle proc).
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.32 2007/05/19 20:50:06 miod Exp $	*/
d158 1
a158 1
unsigned int m188_curspl[] = {0, 0, 0, 0};
d337 1
d356 1
a356 2
 * Process inter-processor interrupts. Note that interrupts are disabled
 * when this function is invoked.
d363 2
a364 1
	int spl = m188_curspl[ci->ci_cpuid];
d373 2
d377 1
d384 2
a385 2
		if (spl < IPL_CLOCK) {
			m188_setipl(IPL_CLOCK);
d387 1
a387 1
			m188_setipl(spl);
d392 2
a393 2
		if (spl < IPL_STATCLOCK) {
			m188_setipl(IPL_STATCLOCK);
d395 1
a395 1
			m188_setipl(spl);
a527 1
		}
d530 4
a533 4
		/*
		 * Handle IPIs first.
		 */
		m188_ipi_handler(eframe);
d535 2
a536 2
		if (cur_mask == 0)
			break;
d538 1
@


1.32
log
@Oops, get the ``disabling cpu'' message correct.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.31 2007/05/19 20:33:50 miod Exp $	*/
d487 2
a488 2
				set_psr(get_psr() | PSR_IND);
				for (;;) ;
@


1.31
log
@Force other processors to spin when one is in ddb.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.30 2007/05/19 17:03:49 miod Exp $	*/
d486 1
a486 1
				    "disabling processor\n");
@


1.30
log
@Try reducing the number of IPIs, by only reinflicting them to us if we are
lowering the spl.

Also, warn and halt in tracks if the interrupt pin of a secondary cpu never
clears (found the hard way in one of the 2P256 modules here), since there is
nothing better we can do.

Last, do not attempt to handle VME interrupts on secondary processors yes
(this confuses the bus, since both processors will perform a VME interrupt
acknowledge sequence, but only one will succeed).

This lets processes correctly run on all the available processors in
single-user mode, but there are still issues to sort out.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.29 2007/05/18 16:38:29 miod Exp $	*/
d365 11
@


1.29
log
@More work in IPI processing: actual processing is now done with interrupts
enabled, and is delayed if the current spl is not high enough; setipl() and
raiseipl() will retrigger an IPI interrupt if there are any pending IPIs.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.28 2007/05/14 17:00:40 miod Exp $	*/
d154 1
a154 1
 * interrupt status register for each CPU.
d156 1
a156 6
unsigned int *volatile int_mask_reg[] = {
	(unsigned int *)MVME188_IEN0,
	(unsigned int *)MVME188_IEN1,
	(unsigned int *)MVME188_IEN2,
	(unsigned int *)MVME188_IEN3
};
d281 1
a281 1
	u_int mask, curspl;
d298 1
a298 1
	*int_mask_reg[cpu] = mask;
d302 6
a307 2
	/* need to resend myself the pending ipis */
	if (ci->ci_ipi != 0)
d334 1
a334 1
		*int_mask_reg[cpu] = mask;
a335 6

#ifdef MULTIPROCESSOR
		/* need to resend myself the pending ipis */
		if (ci->ci_ipi != 0)
			*(volatile u_int32_t *)MVME188_SETSWI = IPI_BIT(cpu);
#endif
d347 3
d439 4
d444 1
d471 10
d485 2
d494 1
a494 1
	if (IPI_MASK & cur_mask) {
d496 1
a498 1
	uvmexp.intrs++;
d507 1
a507 1
		level = safe_level(cur_mask & ~IPI_MASK, old_spl);
d509 1
d519 1
a519 2
		if (IPI_MASK & cur_mask) {
			cur_mask &= ~IPI_MASK;
d521 3
a523 1
			m188_ipi_handler(eframe);
a524 4
			if (cur_mask == 0)
				break;
		}
#endif
a526 7
		/*
		 * This is tricky.  If you don't catch all the
		 * interrupts, you die. Game over. Insert coin...
		 * XXX smurph
		 */

		/* find the first bit set in the current mask */
@


1.28
log
@Work in progress IPI mechanism, currently only implemented on MVME188, to
send clock ticks to secondary processors.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.27 2007/05/14 16:57:43 miod Exp $	*/
d287 4
d292 1
d306 6
d319 4
d324 1
d337 6
d366 2
d369 1
a369 2
	if (ci->ci_ipi & CI_IPI_NOTIFY) {
		atomic_clearbits_int(&ci->ci_ipi, CI_IPI_NOTIFY);
d372 7
a378 3
	if (ci->ci_ipi & CI_IPI_HARDCLOCK) {
		atomic_clearbits_int(&ci->ci_ipi, CI_IPI_HARDCLOCK);
		hardclock((struct clockframe *)eframe);
d380 7
a386 3
	if (ci->ci_ipi & CI_IPI_STATCLOCK) {
		atomic_clearbits_int(&ci->ci_ipi, CI_IPI_STATCLOCK);
		statclock((struct clockframe *)eframe);
d388 2
d474 11
d494 7
d503 1
a503 3
		 * Check for IPIs first. We rely on the interrupt mask to
		 * make sure that if we get an IPI, it's really for us and
		 * no other processor.
a505 2
			*(volatile u_int32_t *)MVME188_CLRSWI =
			    cur_mask & IPI_MASK;
a513 14
		level = safe_level(cur_mask, old_spl);
		m188_setipl(level);

		/*
		 * Do not enable interrupts yet if we know, from cur_mask,
		 * that we have not cleared enough conditions yet.
		 * For now, only the timer interrupt requires its condition
		 * to be cleared before interrupts are enabled.
		 */
		if (unmasked == 0 && (cur_mask & IRQ_DTI) == 0) {
			set_psr(get_psr() & ~PSR_IND);
			unmasked = 1;
		}

d812 18
d831 4
a834 4
	if (CPU_IS_PRIMARY(curcpu())) {
		/*
		 * Send an IPI to all other processors as well.
		 */
a835 22
#endif

		/*
		 * Compute new randomized interval.  The intervals are
		 * uniformly distributed on
		 * [statint - statvar / 2, statint + statvar / 2],
		 * and therefore have mean statint, giving a stathz
		 * frequency clock.
		 */
		var = statvar;
		do {
			r = random() & (var - 1);
		} while (r == 0);
		newint = statmin + r;

		/* setup new value and restart counter */
		*(volatile u_int8_t *)DART_CTUR = (newint >> 8);
		*(volatile u_int8_t *)DART_CTLR = (newint & 0xff);
		tmp = *(volatile u_int8_t *)DART_STARTC;

#ifdef MULTIPROCESSOR
	}
@


1.27
log
@Register statclock() at IPL_STATCLOCK, not IPL_CLOCK (no-op since they are
the same)
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.26 2007/05/12 20:02:14 miod Exp $	*/
d140 1
d143 1
d224 3
d267 3
d295 1
d316 1
d325 36
d425 1
a425 2
	old_spl = m188_curspl[cpu];
	eframe->tf_mask = old_spl;
d428 1
a428 1
	if (eframe->tf_mask < IPL_SCHED)
d450 10
a459 1
		level = safe_level(cur_mask, old_spl);
d461 1
a461 3
#ifdef DIAGNOSTIC
		if (level != IPL_ABORT && level <= old_spl) {
			int i;
d463 2
a464 12
			printf("safe level %d <= old level %d\n", level, old_spl);
			printf("cur_mask = 0x%b\n", cur_mask, IST_STRING);
			for (i = 0; i < 4; i++)
				printf("IEN%d = 0x%b  ", i, *int_mask_reg[i], IST_STRING);
			printf("\nCPU0 spl %d  CPU1 spl %d  CPU2 spl %d  CPU3 spl %d\n",
			       m188_curspl[0], m188_curspl[1],
			       m188_curspl[2], m188_curspl[3]);
			for (i = 0; i < INT_LEVEL; i++)
				printf("int_mask[%d] = 0x%08x\n", i, int_mask_val[i]);
			printf("--CPU %d halted--\n", cpu_number());
			m188_setipl(IPL_ABORT);
			for(;;) ;
d467 1
a467 1

d608 1
a608 1
	if (eframe->tf_mask < IPL_SCHED)
d624 12
a635 4
struct simplelock m188_cio_lock;

#define	CIO_LOCK	simple_lock(&m188_cio_lock)
#define	CIO_UNLOCK	simple_unlock(&m188_cio_lock)
d684 1
a684 1
	simple_lock_init(&m188_cio_lock);
d746 1
a746 1
	CIO_LOCK;
d753 10
a762 1
	CIO_UNLOCK;
d779 29
a807 15
	/*
	 * Compute new randomized interval.  The intervals are uniformly
	 * distributed on [statint - statvar / 2, statint + statvar / 2],
	 * and therefore have mean statint, giving a stathz frequency clock.
	 */
	var = statvar;
	do {
		r = random() & (var - 1);
	} while (r == 0);
	newint = statmin + r;

	/* setup new value and restart counter */
	*(volatile u_int8_t *)DART_CTUR = (newint >> 8);
	*(volatile u_int8_t *)DART_CTLR = (newint & 0xff);
	tmp = *(volatile u_int8_t *)DART_STARTC;
a815 1
	int s;
a818 3
	s = splclock();
	CIO_LOCK;

a824 3

	CIO_UNLOCK;
	splx(s);
d831 1
a831 1
	int c, s;
a834 3
	s = splclock();
	CIO_LOCK;

a841 2
	CIO_UNLOCK;
	splx(s);
a853 2
	CIO_LOCK;

a878 2

	CIO_UNLOCK;
@


1.26
log
@Change the 88100 interrupt handlers to process DAEs with interrupts enabled,
as done for DAEs not occuring during interrupts.

Remove the check for unprocessed DAE on return from trap() in eh_common.S,
since this can't happen. As a result, the return-from-trap code becomes
identical on 88100 and 88110 systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.25 2007/03/22 18:52:39 miod Exp $	*/
d689 1
a689 1
	statclock_ih.ih_ipl = IPL_CLOCK;
@


1.25
log
@When registering VME interrupts, maintain a direct ipl->vector table, as long
as no more than one interrupt is registered for a given level.

Then, if the VME interrupt vector reading cycle fails on the 188 interrupt
arbiter, we can use this table as a hint if it has a valid entry, since
we know on which ipl line the interrupt occured.

This basically silences the
m188_ext_int: timeout getting VME interrupt vector, level 3, mask 0x400<IRQ3>
occasional messages appearing when the MVME376 is overloaded.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.24 2006/11/20 21:51:33 miod Exp $	*/
d551 1
a555 2
	set_psr(get_psr() | PSR_IND);
out:
d560 2
a561 2
	 * Restore the mask level to what it was when the interrupt
	 * was taken.
d563 1
a563 1
	m188_setipl(eframe->tf_mask);
@


1.24
log
@Hold the kernel lock when processing low IPL interrupts; one more step towards
stable MULTIPROCESSOR kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.23 2006/11/20 21:25:15 miod Exp $	*/
d481 16
a496 7
					printf("%s: timeout getting VME "
					    "interrupt vector, "
					    "level %d, mask 0x%b\n",
					    __func__, level,
					   cur_mask, IST_STRING); 
					ign_mask |=  1 << intbit;
					continue;
@


1.23
log
@Directly invoke m188_setipl() instead of setipl() in the external interrupt
handler.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.22 2006/05/08 14:36:10 miod Exp $	*/
d382 5
d556 5
@


1.22
log
@Replace gazillions of badvaddr() or badwordaddr() calls with badaddr() calls.
With a few prototype declarations shuffling, this finally allows
<machine/locore.h> to die.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.21 2006/05/07 15:40:16 miod Exp $	*/
d416 1
a416 1
			setipl(IPL_ABORT);
d421 1
a421 1
		setipl(level);
@


1.21
log
@Do not panic on MVME188 if the abort switch is pressed while we are at ipl 7
(fallout from always enabling the abort switch).
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.20 2006/05/06 22:17:20 miod Exp $	*/
a122 1
#include <machine/locore.h>
@


1.20
log
@Sync VM games on startup with earlier pmap_table[] cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.19 2006/05/02 21:43:09 miod Exp $	*/
d404 1
a404 1
		if (old_spl >= level) {
@


1.19
log
@Wave goodbye to bugtty on mvme88k as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.18 2006/04/19 22:09:40 miod Exp $	*/
a177 2
vaddr_t utilva;

a209 10
	/*
	 * Grab the UTIL space that we hardwired in pmap_bootstrap().
	 */
	utilva = MVME188_UTILITY;
	uvm_map(kernel_map, (vaddr_t *)&utilva, MVME188_UTILITY_SIZE,
	    NULL, UVM_UNKNOWN_OFFSET, 0,
	      UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
	        UVM_ADV_NORMAL, 0));
	if (utilva != MVME188_UTILITY)
		panic("utilva %lx: UTILITY area not free", utilva);
@


1.18
log
@Get rid of the clock device attachment - since the clock is not something
we can live without, move it into the board-dependent code. This even makes
the code slightly smaller.

clock.c is moved from dev/ to mvme88k/ and only keeps common variables and
delay().
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.17 2006/04/19 19:54:21 miod Exp $	*/
a687 5
#include "bugtty.h"
#if NBUGTTY > 0
#include <mvme88k/dev/bugttyfunc.h>
#endif

a694 3
#if NBUGTTY > 0
	bugtty_chkinput();
#endif /* NBUGTTY */
@


1.17
log
@Count spurious interrupt as part of the alarming interrupt issues as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.16 2006/04/19 19:41:26 miod Exp $	*/
d34 66
d132 2
d140 1
d230 5
a234 4
	md_interrupt_func_ptr = &m188_ext_int;
	md_getipl = &m188_getipl;
	md_setipl = &m188_setipl;
	md_raiseipl = &m188_raiseipl;
d564 261
@


1.16
log
@Better diagnostic messages in the MVME188 interrupt handler; also no need
to register an interrupt handler for the SYSCON board interrupts anymore,
as we never trigger it.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.15 2006/04/17 18:26:28 miod Exp $	*/
d444 1
@


1.15
log
@Better constant names for the MVME188 GCSR set.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.14 2006/04/15 15:45:24 miod Exp $	*/
a208 1
	/* NOTREACHED since int_mask_val[INT_LEVEL - 1] is zero */
d308 1
a308 1
	unsigned int cur_mask;
d316 3
d321 1
a363 6
#ifdef DEBUG
		if (level > 7 || (int)level < 0) {
			panic("int level (%x) is not between 0 and 7", level);
		}
#endif

d405 22
a426 3
				printf("VME vec timeout, vec = %x, mask = 0x%b\n",
				    vec, 1 << intbit, IST_STRING);
				continue;
d429 3
a431 2
				panic("unknown vme interrupt: mask = 0x%b",
				    1 << intbit, IST_STRING);
d434 3
a436 3
			panic("unknown interrupt: level = %d intbit = 0x%x "
			    "mask = 0x%b",
			    level, intbit, 1 << intbit, IST_STRING);
d441 3
a443 3
			printf("Spurious interrupt: level = %d vec = 0x%x, "
			    "intbit = %d mask = 0x%b\n",
			    level, vec, intbit, 1 << intbit, IST_STRING);
d462 5
a466 5
				printf("Unclaimed interrupt: level = %d "
				    "vec = 0x%x, intbit = %d mask = 0x%b\n",
				    level, vec, intbit,
				    1 << intbit, IST_STRING);
				break;
d469 9
a477 1
	} while ((cur_mask = ISR_GET_CURRENT_MASK(cpu)) != 0);
@


1.14
log
@Clean up <machine/mvme188.h> out of duplicate defines, sort them by relevance,
add more comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.13 2006/04/13 21:16:17 miod Exp $	*/
d181 1
a181 1
	if ((*(volatile u_int8_t *)GLB1) & M188_SYSCON) {
d186 1
a186 1
		*(volatile u_int8_t *)GLB1 |= M188_LRST;
@


1.13
log
@Drop the ivec[] interrupt acknowledge address array, compute the address
itself in the interrupt dispatcher instead of accessing the array: this
computation is of similar complexity, so why bother adding a memory
indirection. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.12 2005/12/04 14:58:43 miod Exp $	*/
d78 7
a84 2
 * *int_mask_reg[CPU]
 * Points to the hardware interrupt status register for each CPU.
d87 4
a90 4
	(unsigned int *)IEN0_REG,
	(unsigned int *)IEN1_REG,
	(unsigned int *)IEN2_REG,
	(unsigned int *)IEN3_REG
d95 4
a98 1
unsigned int int_mask_val[INT_LEVEL] = {
d130 2
a131 2
		*(volatile int32_t *)RMAD_REG = (pgnum << 22);
		rmad = *(volatile int32_t *)RMAD_REG;
d167 1
a167 4
	*(volatile u_int32_t *)IEN0_REG = 0;
	*(volatile u_int32_t *)IEN1_REG = 0;
	*(volatile u_int32_t *)IEN2_REG = 0;
	*(volatile u_int32_t *)IEN3_REG = 0;
d179 1
a179 4
	*(volatile u_int32_t *)IEN0_REG = 0;
	*(volatile u_int32_t *)IEN1_REG = 0;
	*(volatile u_int32_t *)IEN2_REG = 0;
	*(volatile u_int32_t *)IEN3_REG = 0;
d183 1
a183 1
		*(volatile u_int32_t *)GLBRES_REG = 1;
d189 1
a189 1
	*(volatile u_int32_t *)UCSR_REG |= 0x2000;	/* clear SYSFAIL */
d192 1
a192 1
	*(volatile u_int32_t *)UCSR_REG |= 0x2000;	/* clear SYSFAIL */
d206 2
a207 2
		if (!(int_mask_val[i] & mask))
			return i;
d209 2
a210 3
	panic("safe_level: no safe level for mask 0x%08x level %d found",
	       mask, curlevel);
	/* NOTREACHED */
d230 1
a230 1
		mask &= SLAVE_MASK;
d250 1
a250 1
			mask &= SLAVE_MASK;
d263 4
a266 1
/* Hard coded vector table for onboard devices. */
d268 32
a299 4
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
        0, SYSCV_SCC, 0, 0, SYSCV_SYSF, SYSCV_TIMER2, 0, 0,
	0, 0, 0, 0, SYSCV_TIMER1, 0, SYSCV_ACF, SYSCV_ABRT
d302 2
a303 3
#define GET_MASK(cpu, val)	*int_mask_reg[cpu] & (val)
#define VME_VECTOR_MASK		0x1ff 		/* mask into VIACK register */
#define VME_BERR_MASK		0x100 		/* timeout during VME IACK cycle */
d375 1
a375 1
		if (unmasked == 0 && (cur_mask & DTI_BIT) == 0) {
@


1.12
log
@In the 188 interrupt handler, only fiddle with the PSR once in the main loop.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.11 2005/12/03 14:30:06 miod Exp $	*/
a74 1
void	m188_setupiackvectors(void);
d163 3
a195 20
 * fill up ivec array with interrupt response vector addresses.
 */
void
m188_setupiackvectors()
{
	u_int8_t *vaddr = (u_int8_t *)M188_IACK;

	ivec[0] = vaddr;	/* We dont use level 0 */
	ivec[1] = vaddr + 0x04;
	ivec[2] = vaddr + 0x08;
	ivec[3] = vaddr + 0x0c;
	ivec[4] = vaddr + 0x10;
	ivec[5] = vaddr + 0x14;
	ivec[6] = vaddr + 0x18;
	ivec[7] = vaddr + 0x1c;
	ivec[8] = vaddr + 0x20;	/* for self inflicted interrupts */
	*ivec[8] = M188_IVEC;	/* supply a vector base for m188ih */
}

/*
d283 1
d374 2
a375 1
			vec = *(u_int32_t *)ivec[level] & VME_VECTOR_MASK;
@


1.11
log
@Switch m88k ports to __HAVE_CPUINFO. Current cpu pointer is held in SR0
on all running processors.
Tested aoyama@@ and I
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.10 2005/10/13 19:48:36 miod Exp $	*/
d160 4
a163 4
	*int_mask_reg[0] = 0;
	*int_mask_reg[1] = 0;
	*int_mask_reg[2] = 0;
	*int_mask_reg[3] = 0;
d171 1
d221 1
a221 1
	for (i = curlevel; i < 8; i++)
d302 1
d328 1
d339 1
a339 1
			for (i = 0; i < 8; i++)
d345 1
d361 1
a361 1
		if ((cur_mask & DTI_BIT) == 0) {
d363 1
d377 1
a377 1
			vec = SYSCON_VECT + obio_vec[intbit];
d382 1
d384 1
a384 1
			vec = SYSCON_VECT + obio_vec[intbit];
d389 1
@


1.10
log
@Merge <machine/cpu_number.h> into <machine/cpu.h>, preparing for intrusive
changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.9 2005/09/06 19:41:28 miod Exp $	*/
d244 1
d247 1
d264 1
d267 1
@


1.9
log
@Do not depend on MAX_CPUS being 4.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.8 2005/05/01 09:55:49 miod Exp $	*/
a56 1
#include <machine/cpu_number.h>
@


1.8
log
@Bring raise-only semantics to splsoft* on m68k and m88k, as done elsewhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.7 2005/04/30 16:42:37 miod Exp $	*/
d83 1
a83 1
unsigned int *volatile int_mask_reg[MAX_CPUS] = {
d90 1
a90 1
unsigned int m188_curspl[MAX_CPUS] = {0, 0, 0, 0};
@


1.7
log
@Remove m88k_psr_type and function with utterly long names to control the psr,
and use get_psr() / set_psr() or simple macros that expand into them everywhere.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.6 2005/04/27 14:07:38 miod Exp $	*/
d336 1
a336 1
			spl7();
@


1.6
log
@Always include <uvm/uvm_extern.h> before <machine/cmmu.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.5 2004/12/24 22:50:30 miod Exp $	*/
d355 1
a355 1
			enable_interrupt();
d433 1
a433 1
	disable_interrupt();
@


1.5
log
@{e,}intr{cnt,names} bye-bye.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.4 2004/11/09 21:50:01 miod Exp $	*/
d52 2
a63 2

#include <uvm/uvm_extern.h>
@


1.4
log
@Kill guarded_access() - the way we map OBIO, there is no need for special
treatement of interrupt vectors variables, a simple read will do.

While there, speed up the interrupt handlers a bit:
- remove old debug code or only compile it if option DEBUG.
- use short circuits for setipl() if we know interrupts are disabled at
  this point: there is no need playing with the psr in these cases.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.3 2004/11/09 12:01:19 miod Exp $	*/
a398 2
			/* increment intr counter */
			intrcnt[M88K_SPUR_IRQ]++;
a414 1
					intrcnt[level]++;
@


1.3
log
@Split {get,set,raise}ipl() into per-board implementations.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.2 2004/11/08 16:39:31 miod Exp $	*/
d297 1
a297 1
	unsigned vec;
d381 1
a381 6
			if (guarded_access(ivec[level], 4, (u_char *)&vec) ==
			    EFAULT) {
				panic("unable to get vector for this vmebus "
				    "interrupt (level %x)", level);
			}
			vec &= VME_VECTOR_MASK;
d385 1
a385 1
				break;
d445 1
a445 1
	setipl(eframe->tf_mask);
@


1.2
log
@Kill struct md_p, which was really only necessary for mvme88k; on
luna88k it disappears completely, while mvme88k keeps 3 global variables,
one of them scheduled to disappear very soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: m188_machdep.c,v 1.1 2004/10/01 19:00:52 miod Exp $	*/
a68 1
void	setlevel(unsigned int);
d72 1
d74 2
d156 3
d230 8
a237 2
void
setlevel(unsigned int level)
d239 1
a239 1
	unsigned int mask;
d242 2
a244 1

d250 20
@


1.1
log
@More mvme88k code cleaning:
- merge locore_c_routines.c into machdep.c
- split machdep.c into really machdep.c content, and board-specific routines
  (memory sizing, early initialization, etc).

No functionnal change.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d153 1
a153 4
	md.interrupt_func = &m188_ext_int;
	md.intr_mask = NULL;
	md.intr_ipl = NULL;
	md.intr_src = NULL;
@

