head	1.54;
access;
symbols
	OPENBSD_5_5:1.53.0.6
	OPENBSD_5_5_BASE:1.53
	OPENBSD_5_4:1.53.0.2
	OPENBSD_5_4_BASE:1.53
	OPENBSD_5_3:1.51.0.6
	OPENBSD_5_3_BASE:1.51
	OPENBSD_5_2:1.51.0.4
	OPENBSD_5_2_BASE:1.51
	OPENBSD_5_1_BASE:1.51
	OPENBSD_5_1:1.51.0.2
	OPENBSD_5_0:1.50.0.10
	OPENBSD_5_0_BASE:1.50
	OPENBSD_4_9:1.50.0.8
	OPENBSD_4_9_BASE:1.50
	OPENBSD_4_8:1.50.0.6
	OPENBSD_4_8_BASE:1.50
	OPENBSD_4_7:1.50.0.2
	OPENBSD_4_7_BASE:1.50
	OPENBSD_4_6:1.50.0.4
	OPENBSD_4_6_BASE:1.50
	OPENBSD_4_5:1.49.0.8
	OPENBSD_4_5_BASE:1.49
	OPENBSD_4_4:1.49.0.4
	OPENBSD_4_4_BASE:1.49
	OPENBSD_4_3:1.49.0.2
	OPENBSD_4_3_BASE:1.49
	OPENBSD_4_2:1.47.0.4
	OPENBSD_4_2_BASE:1.47
	OPENBSD_4_1:1.47.0.2
	OPENBSD_4_1_BASE:1.47
	OPENBSD_4_0:1.46.0.2
	OPENBSD_4_0_BASE:1.46
	OPENBSD_3_9:1.45.0.2
	OPENBSD_3_9_BASE:1.45
	OPENBSD_3_8:1.41.0.2
	OPENBSD_3_8_BASE:1.41
	OPENBSD_3_7:1.40.0.2
	OPENBSD_3_7_BASE:1.40
	OPENBSD_3_6:1.39.0.2
	OPENBSD_3_6_BASE:1.39
	SMP_SYNC_A:1.32
	SMP_SYNC_B:1.32
	OPENBSD_3_5:1.31.0.2
	OPENBSD_3_5_BASE:1.31
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.6
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.4
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	SMP:1.12.0.2
	UBC_SYNC_B:1.14
	UBC:1.8.0.2
	UBC_BASE:1.8;
locks; strict;
comment	@ * @;


1.54
date	2014.03.18.22.36.36;	author miod;	state dead;
branches;
next	1.53;

1.53
date	2013.05.17.22.51.59;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2013.05.17.22.46.28;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2011.10.09.17.01.34;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2009.04.19.17.56.13;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2007.11.17.05.36.23;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2007.11.17.05.33.40;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2006.11.18.22.53.11;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2006.05.08.14.36.10;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2005.12.04.12.20.19;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2005.12.03.14.30.06;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2005.12.02.21.16.45;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2005.10.13.19.48.37;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2005.04.27.14.07.38;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2004.09.30.21.46.38;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2004.08.06.13.23.49;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2004.08.04.15.54.38;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2004.08.04.13.16.14;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2004.08.04.09.08.37;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2004.08.03.21.24.43;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2004.08.02.08.35.00;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2004.07.31.13.38.32;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2004.05.07.18.06.35;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2004.01.20.14.35.54;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2004.01.19.16.57.06;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2004.01.14.20.46.02;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2004.01.09.00.23.08;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2004.01.05.20.07.03;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2004.01.02.17.08.57;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2003.12.22.20.10.23;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2003.12.19.22.30.18;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2003.10.11.22.46.25;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2003.10.08.13.26.12;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2003.10.05.20.35.26;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2003.10.05.19.29.15;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2003.09.26.22.27.26;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2003.09.16.20.53.41;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2003.09.16.20.46.11;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2003.08.21.20.45.43;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2003.08.09.21.19.59;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.03.15.57;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.26.40;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.01.14.21.34.41;	author miod;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2001.12.24.17.18.39;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.24.04.12.40;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.22.09.49.39;	author smurph;	state Exp;
branches;
next	1.8;

1.8
date	2001.12.16.23.49.46;	author miod;	state dead;
branches
	1.8.2.1;
next	1.7;

1.7
date	2001.12.14.08.55.45;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2001.12.14.04.30.12;	author smurph;	state Exp;
branches;
next	1.5;

1.5
date	2001.12.14.02.00.56;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2001.12.14.01.52.36;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2001.12.14.01.33.50;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2001.12.13.19.59.17;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2001.12.13.08.55.52;	author smurph;	state Exp;
branches;
next	;

1.8.2.1
date	2002.01.31.22.55.19;	author niklas;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2002.06.11.03.37.11;	author art;	state Exp;
branches;
next	;

1.12.2.1
date	2002.03.28.10.36.02;	author niklas;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2004.02.19.10.49.08;	author niklas;	state Exp;
branches;
next	1.12.2.3;

1.12.2.3
date	2004.06.05.23.09.50;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.54
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: m8820x.c,v 1.53 2013/05/17 22:51:59 miod Exp $	*/
/*
 * Copyright (c) 2004, Miodrag Vallat.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>

#include <uvm/uvm_extern.h>

#include <machine/asm_macro.h>
#include <machine/cpu.h>

#include <machine/cmmu.h>
#include <machine/m8820x.h>
#ifdef MVME181
#include <machine/mvme181.h>
#endif
#ifdef MVME187
#include <machine/mvme187.h>
#endif
#ifdef MVME188
#include <machine/mvme188.h>
#endif

#ifdef MVME188
/*
 * There are 6 possible MVME188 HYPERmodule configurations:
 *  - config 0: 4 CPUs, 8 CMMUs
 *  - config 1: 2 CPUs, 8 CMMUs
 *  - config 2: 1 CPUs, 8 CMMUs
 *  - config 5: 2 CPUs, 4 CMMUs
 *  - config 6: 1 CPU,  4 CMMUs
 *  - config A: 1 CPU,  2 CMMUs (similar in operation to MVME187)
 * which can exist either with MC88200 or MC88204 CMMUs.
 */
const struct board_config {
	int ncpus;
	int ncmmus;
	u_int32_t *pfsr;
} bd_config[16] = {
	{ 4, 8, pfsr_save_188_straight },	/* 4P128 - 4P512 */
	{ 2, 8, pfsr_save_188_double },		/* 2P128 - 2P512 */
	{ 1, 8, pfsr_save_188_quad },		/* 1P128 - 1P512 */
	{ 0, 0, NULL },
	{ 0, 0, NULL },
	{ 2, 4, pfsr_save_188_straight },	/* 2P64  - 2P256 */
	{ 1, 4, pfsr_save_188_double },		/* 1P64  - 1P256 */
	{ 0, 0, NULL },
	{ 0, 0, NULL },
	{ 0, 0, NULL },
	{ 1, 2, pfsr_save_188_straight },	/* 1P32  - 1P128 */
	{ 0, 0, NULL },
	{ 0, 0, NULL },
	{ 0, 0, NULL },
	{ 0, 0, NULL },
	{ 0, 0, NULL }
};
#endif

/*
 * This routine sets up the CPU/CMMU configuration.
 */
void
m8820x_setup_board_config()
{
	extern u_int32_t pfsr_save[];
	int num;
	u_int32_t *m8820x_pfsr;
#ifdef MVME188
	u_int32_t whoami;
	int vme188_config;
	struct m8820x_cmmu *cmmu;
	int cmmu_num;
#endif

	switch (brdtyp) {
#ifdef MVME181
	case BRD_180:
	case BRD_181:
#ifdef MVME188
		/* There is no WHOAMI reg on MVME181 - fake it... */
		vme188_config = 0x0a;
#endif
		m8820x_cmmu[0].cmmu_regs = (void *)M181_CMMU_I;
		m8820x_cmmu[1].cmmu_regs = (void *)M181_CMMU_D;
		ncpusfound = 1;
		max_cmmus = 2;
		cmmu_shift = 1;
		m8820x_pfsr = pfsr_save_single;
		break;
#endif	/* MVME181 */
#ifdef MVME187
	case BRD_187:
	case BRD_8120:
#ifdef MVME188
		/* There is no WHOAMI reg on MVME187 - fake it... */
		vme188_config = 0x0a;
#endif
		m8820x_cmmu[0].cmmu_regs = (void *)SBC_CMMU_I;
		m8820x_cmmu[1].cmmu_regs = (void *)SBC_CMMU_D;
		ncpusfound = 1;
		max_cmmus = 2;
		cmmu_shift = 1;
		m8820x_pfsr = pfsr_save_single;
		break;
#endif /* MVME187 */
#ifdef MVME188
	case BRD_188:
		whoami = *(volatile u_int32_t *)MVME188_WHOAMI;
		vme188_config = (whoami & 0xf0) >> 4;
		m8820x_cmmu[0].cmmu_regs = (void *)VME_CMMU_I0;
		m8820x_cmmu[1].cmmu_regs = (void *)VME_CMMU_D0;
		m8820x_cmmu[2].cmmu_regs = (void *)VME_CMMU_I1;
		m8820x_cmmu[3].cmmu_regs = (void *)VME_CMMU_D1;
		m8820x_cmmu[4].cmmu_regs = (void *)VME_CMMU_I2;
		m8820x_cmmu[5].cmmu_regs = (void *)VME_CMMU_D2;
		m8820x_cmmu[6].cmmu_regs = (void *)VME_CMMU_I3;
		m8820x_cmmu[7].cmmu_regs = (void *)VME_CMMU_D3;
		ncpusfound = bd_config[vme188_config].ncpus;
		max_cmmus = bd_config[vme188_config].ncmmus;
		m8820x_pfsr = bd_config[vme188_config].pfsr;
		cmmu_shift = ff1(max_cmmus / ncpusfound);
		break;
#endif /* MVME188 */
	}

#ifdef MVME188
	if (bd_config[vme188_config].ncpus != 0) {
		/* 181 and 187 have a fixed configuration, don't print it */
		if (brdtyp == BRD_188) {
			printf("MVME188 board configuration #%X "
			    "(%d CPUs %d CMMUs)\n",
			    vme188_config, ncpusfound, max_cmmus);
		}
	} else {
		panic("unrecognized MVME%x board configuration #%X",
		    brdtyp, vme188_config);
	}
#endif

	/*
	 * Patch the exception handling code to invoke the correct pfsr
	 * analysis chunk.
	 */
	pfsr_save[0] = 0xc4000000 |
	    (((vaddr_t)m8820x_pfsr + 4 - (vaddr_t)pfsr_save) >> 2);
	pfsr_save[1] = m8820x_pfsr[0];

#ifdef DEBUG
	/*
	 * Check CMMU type
	 */
	for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++) {
		volatile u_int32_t *cr = m8820x_cmmu[cmmu_num].cmmu_regs;
		if (badaddr((vaddr_t)cr, 4) == 0) {
			int type;

			type = CMMU_TYPE(cr[CMMU_IDR]);
			if (type != M88200_ID && type != M88204_ID) {
				printf("WARNING: non M8820x circuit found "
				    "at CMMU address %p\n", cr);
				continue;	/* will probably die quickly */
			}
		}
	}
#endif

	/*
	 * Now that we know which CMMUs are there, report every association
	 */
	for (num = 0; num < ncpusfound; num++) {
		int type;

		type = CMMU_TYPE(m8820x_cmmu[num << cmmu_shift].
		    cmmu_regs[CMMU_IDR]);

		printf("CPU%d is associated to %d MC8820%c CMMUs\n",
		    num, 1 << cmmu_shift, type == M88204_ID ? '4' : '0');
	}


#ifdef MVME188
	/*
	 * Systems with more than 2 CMMUs per CPU use programmable split
	 * schemes, through PCNFA (for code CMMUs) and PCNFB (for data CMMUs)
	 * configuration registers.
	 *
	 * The following schemes are available:
	 * - split on A12 address bit (A14 for 88204)
	 * - split on supervisor/user access
	 * - split on SRAM/non-SRAM addresses, with either supervisor-only or
	 *   all access to SRAM.
	 *
	 * Configuration 6, with 4 CMMUs par CPU, also allows a split on A14
	 * address bit (A16 for 88204).
	 *
	 * Setup the default A12/A14 scheme here. We should theoretically only
	 * set the PCNFA and PCNFB on configurations 1, 2 and 6, since the
	 * other ones do not have P bus decoders.
	 * However, is it safe to write them anyways - the values will be
	 * discarded. Just don't do this on a 187...
	 */
	if (brdtyp == BRD_188) {
		*(volatile u_int32_t *)MVME188_PCNFA = 0;
		*(volatile u_int32_t *)MVME188_PCNFB = 0;
	}

	/*
	 * Now set up addressing limits
	 */
	for (cmmu_num = 0, cmmu = m8820x_cmmu; cmmu_num < max_cmmus;
	    cmmu_num++, cmmu++) {
		num = cmmu_num >> 1;	/* CPU view of the CMMU */

		switch (cmmu_shift) {
		case 3:
			/*
			 * A14 split (configuration 2 only).
			 * CMMU numbers 0 and 1 match on A14 set,
			 *              2 and 3 on A14 clear
			 */
			cmmu->cmmu_addr |= (num < 2 ? CMMU_A14_MASK : 0);
			cmmu->cmmu_addr_mask |= CMMU_A14_MASK;
			/* FALLTHROUGH */

		case 2:
			/*
			 * A12 split.
			 * CMMU numbers 0 and 2 match on A12 set,
			 *              1 and 3 on A12 clear.
			 */
			cmmu->cmmu_addr |= (num & 1 ? 0 : CMMU_A12_MASK);
			cmmu->cmmu_addr_mask |= CMMU_A12_MASK;
			break;

		case 1:
			/*
			 * We don't need to set up anything for the hardwired
			 * configurations.
			 */
			cmmu->cmmu_addr = 0;
			cmmu->cmmu_addr_mask = 0;
			break;
		}

		/*
		 * If these CMMUs are 88204, these splitting address lines
		 * need to be shifted two bits.
		 */
		if (CMMU_TYPE(cmmu->cmmu_regs[CMMU_IDR]) == M88204_ID) {
			cmmu->cmmu_addr <<= 2;
			cmmu->cmmu_addr_mask <<= 2;
		}
	}
#endif
}

/*
 * Find out the CPU number from accessing CMMU.
 * On MVME181 and MVME187, there is only one CPU, so this is trivial.
 * On MVME188, we access the WHOAMI register, which is in data space;
 * its value will let us know which data CMMU has been used to perform
 * the read, and we can reliably compute the CPU number from it.
 */
cpuid_t
m8820x_cpu_number()
{
#ifdef MVME188
	u_int32_t whoami;
	cpuid_t cpu;
#endif

#if defined(MVME181) || defined(MVME187)
#ifdef MVME188
	if (brdtyp != BRD_188)
#endif
		return 0;
#endif

#ifdef MVME188
	whoami = *(volatile u_int32_t *)MVME188_WHOAMI;
	switch ((whoami & 0xf0) >> 4) {
	/* 2 CMMU per CPU multiprocessor modules */
	case 0:
	case 5:
		for (cpu = 0; cpu < 4; cpu++)
			if (whoami & (1 << cpu))
				return cpu;
		break;
	/* 4 CMMU per CPU dual processor modules */
	case 1:
		for (cpu = 0; cpu < 4; cpu++)
			if (whoami & (1 << cpu))
				return cpu >> 1;
		break;
	/* single processor modules */
	case 2:
	case 6:
	case 0x0a:
		return 0;
	}
	panic("can't figure out cpu number from whoami register %x", whoami);
#endif
}
@


1.53
log
@Preliminary support for MVME180 and MVME181 boards. On-board serial ports
and VME controller are supported; tod chip isn't supported yet (coming soon).
MVME236 memory boards are not supported and won't likely be (unless I get my
hands on one).

MVME181-1 boots multiuser (slowly) with MVME328 SCSI and MVME376 Ethernet
despite only having 8MB of memory onboard.

MVME180 untested; might need tweaking to get MVME SCSI and Ethernet boards
supported.

Many thanks to Matti Nummi for lending me an MVME181 board.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.52 2013/05/17 22:46:28 miod Exp $	*/
@


1.52
log
@Replace the bunch of md_* function pointers with a `struct board' containing
function pointers for all the board-specific code.

Add a bunch of `struct board' methods to cover most, if not all, of the
`per-board' logic. This allows most of the md drivers to be cleaned up and
no longer need to embed board-specific knowledge.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.51 2011/10/09 17:01:34 miod Exp $	*/
d37 3
d99 15
d151 1
a151 1
		/* 187 has a fixed configuration, no need to print it */
d282 1
a282 1
 * On MVME187, there is only one CPU, so this is trivial.
d295 1
a295 1
#ifdef MVME187
@


1.51
log
@Rework secondary processor initialization. cmmu initialization is now
performed much earlier in the processor startup.
No visible change, paves the way for the much important diff three commits
from here.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.50 2009/04/19 17:56:13 miod Exp $	*/
d108 1
a108 1
		m8820x_pfsr = pfsr_save_187;
@


1.50
log
@Rename max_cpus to ncpusfound and compute it regardless of option
MULTIPROCESSOR.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.49 2007/11/17 05:36:23 miod Exp $	*/
a86 1
	int vme188_config;
d90 1
d99 1
d102 1
@


1.49
log
@Replace many ``unsigned'' variables with ``unsigned int'', ``u_int'' or other
appropriate types. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.48 2007/11/17 05:33:40 miod Exp $	*/
d103 1
a103 1
		max_cpus = 1;
d121 1
a121 1
		max_cpus = bd_config[vme188_config].ncpus;
d124 1
a124 1
		cmmu_shift = ff1(max_cmmus / max_cpus);
d135 1
a135 1
			    vme188_config, max_cpus, max_cmmus);
d173 1
a173 1
	for (num = 0; num < max_cpus; num++) {
@


1.48
log
@Add some preprocessor magic to let M187 and M188 kernels compile again.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.47 2006/11/18 22:53:11 miod Exp $	*/
d156 1
a156 1
		volatile unsigned *cr = m8820x_cmmu[cmmu_num].cmmu_regs;
d206 2
a207 2
		*(volatile unsigned long *)MVME188_PCNFA = 0;
		*(volatile unsigned long *)MVME188_PCNFB = 0;
@


1.47
log
@Rework the PFSR register analysis code on mvme88k: split it into four
independent subfunctions, turn PFSR_SAVE into a couple of NOP, and replace
them early at runtime with a branch to the selected routine, which will
return to pfsr_save.
This is really better for 188 systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.46 2006/05/08 14:36:10 miod Exp $	*/
d86 1
a86 2
	struct m8820x_cmmu *cmmu;
	int num, cmmu_num;
d91 2
d276 1
d278 1
@


1.46
log
@Replace gazillions of badvaddr() or badwordaddr() calls with badaddr() calls.
With a few prototype declarations shuffling, this finally allows
<machine/locore.h> to die.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.45 2005/12/04 12:20:19 miod Exp $	*/
d58 1
d60 16
a75 16
	{ 4, 8 },	/* 4P128 - 4P512 */
	{ 2, 8 },	/* 2P128 - 2P512 */
	{ 1, 8 },	/* 1P128 - 1P512 */
	{ 0, 0 },
	{ 0, 0 },
	{ 2, 4 },	/* 2P64  - 2P256 */
	{ 1, 4 },	/* 1P64  - 1P256 */
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 1, 2 },	/* 1P32  - 1P128 */
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 }
d85 1
d89 1
d105 1
d122 1
d141 8
@


1.45
log
@Slight cmmu code cleanup; use shorter function names, remove parity_enable
and the DDB and DEBUG helpers which are of questionable usefulness, some
stylistic changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.44 2005/12/03 14:30:06 miod Exp $	*/
a33 3
#ifdef DEBUG
#include <machine/locore.h>
#endif
d143 1
a143 1
		if (badwordaddr((vaddr_t)cr) == 0) {
@


1.44
log
@Switch m88k ports to __HAVE_CPUINFO. Current cpu pointer is held in SR0
on all running processors.
Tested aoyama@@ and I
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.43 2005/12/02 21:16:45 miod Exp $	*/
d33 1
d257 1
a257 1
m8820x_cmmu_cpu_number()
d261 1
a261 1
	unsigned int cpu;
@


1.43
log
@Better choice of types for struct pmap members and cmmu functions;
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.42 2005/10/13 19:48:37 miod Exp $	*/
a92 1
	master_cpu = 0;	/* temp to get things going */
a163 1
		cpu_sets[num] = 1;   /* This cpu installed... */
@


1.42
log
@Merge <machine/cpu_number.h> into <machine/cpu.h>, preparing for intrusive
changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.41 2005/04/27 14:07:38 miod Exp $	*/
d257 1
a257 1
unsigned
@


1.41
log
@Always include <uvm/uvm_extern.h> before <machine/cmmu.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.40 2004/09/30 21:46:38 miod Exp $	*/
a32 1
#include <machine/cpu_number.h>
@


1.40
log
@Closer to reality comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.39 2004/08/06 13:23:49 miod Exp $	*/
d29 2
@


1.39
log
@Merge Luna88k and mvme88k M88200 management code. Features:
- simpler structures (no more redundant or easily computable information).
- split scheme configuration (for 4:1 and 8:1 designs) is only compiled in
  if necessary (read: only on a mvme88k kernel configured for MVME188 support),
  which speeds up CMMU operations on the Luna88k.
- will not enable bus snopping on a monoprocessor system.

Tested on Luna88k-2, MVME187 and various MVME188 by aoyama@@ and I.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.38 2004/08/04 15:54:38 miod Exp $	*/
d186 1
a186 1
	 * address bit.
d188 1
a188 1
	 * Setup the default A12/A14 split here. We should theoretically only
@


1.38
log
@Completely remove BATC code. BATC on 88200 are way too small to be worth
using as part of the general pmap machinery (though they might come back
at some point to speed up I/O mappings), and we don't use the 88110 BATC
yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.37 2004/08/04 13:16:14 miod Exp $	*/
a25 57
/*
 * Copyright (c) 2001 Steve Murphree, Jr.
 * Copyright (c) 1996 Nivas Madhur
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Nivas Madhur.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
/*
 * Mach Operating System
 * Copyright (c) 1993-1991 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON AND OMRON ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON AND OMRON DISCLAIM ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */
a28 1
#include <sys/simplelock.h>
d32 1
d34 1
d45 1
a45 62
#include <uvm/uvm_extern.h>

#ifdef DDB
#include <ddb/db_output.h>		/* db_printf()		*/
#endif

/*
 * On some versions of the 88200, page size flushes don't work. I am using
 * sledge hammer approach till I find for sure which ones are bad XXX nivas
 */
#define BROKEN_MMU_MASK

u_int max_cmmus;

void m8820x_cmmu_init(void);
void m8820x_setup_board_config(void);
void m8820x_cpu_configuration_print(int);
void m8820x_cmmu_shutdown_now(void);
void m8820x_cmmu_parity_enable(void);
unsigned m8820x_cmmu_cpu_number(void);
void m8820x_cmmu_set_sapr(unsigned, unsigned);
void m8820x_cmmu_set_uapr(unsigned);
void m8820x_cmmu_flush_tlb(unsigned, unsigned, vaddr_t, vsize_t);
void m8820x_cmmu_flush_cache(int, paddr_t, psize_t);
void m8820x_cmmu_flush_inst_cache(int, paddr_t, psize_t);
void m8820x_cmmu_flush_data_cache(int, paddr_t, psize_t);
void m8820x_dma_cachectl(vaddr_t, vsize_t, int);
void m8820x_dma_cachectl_pa(paddr_t, psize_t, int);
void m8820x_cmmu_dump_config(void);
void m8820x_cmmu_show_translation(unsigned, unsigned, unsigned, int);
void m8820x_show_apr(unsigned);

/* This is the function table for the mc8820x CMMUs */
struct cmmu_p cmmu8820x = {
	m8820x_cmmu_init,
	m8820x_setup_board_config,
	m8820x_cpu_configuration_print,
	m8820x_cmmu_shutdown_now,
	m8820x_cmmu_parity_enable,
	m8820x_cmmu_cpu_number,
	m8820x_cmmu_set_sapr,
	m8820x_cmmu_set_uapr,
	m8820x_cmmu_flush_tlb,
	m8820x_cmmu_flush_cache,
	m8820x_cmmu_flush_inst_cache,
	m8820x_cmmu_flush_data_cache,
	m8820x_dma_cachectl,
	m8820x_dma_cachectl_pa,
#ifdef DDB
	m8820x_cmmu_dump_config,
	m8820x_cmmu_show_translation,
#else
	NULL,
	NULL,
#endif
#ifdef DEBUG
	m8820x_show_apr,
#else
	NULL,
#endif
};

d53 1
a53 1
 *  - config A: 1 CPU,  2 CMMUs
a54 61
 *
 * Systems with more than 2 CMMUs per CPU use programmable split schemes,
 * through PCNFA (for code CMMUs) and PCNFB (for data CMMUs) configuration
 * registers.
 *
 * The following schemes are available:
 * - split on A12 address bit (A14 for 88204)
 * - split on supervisor/user access
 * - split on SRAM/non-SRAM addresses, with either supervisor-only or all
 *   access to SRAM.
 *
 * Configuration 6, with 4 CMMUs par CPU, also forces a split on A14 address
 * bit.
 *
 * Under OpenBSD, we will only split on A12 and A14 address bits, since we
 * do not want to waste CMMU resources on the SRAM, and user/supervisor
 * splits seem less efficient.
 *
 * The really nasty part of this choice is in the exception handling code,
 * when it needs to get error information from up to 4 CMMUs. See eh.S for
 * the gory details.
 */

/*
 * CMMU kernel information
 */
struct m8820x_cmmu {
	volatile u_int32_t *cmmu_regs;	/* CMMU "base" area */
	unsigned int	cmmu_cpu;	/* cpu number it is attached to */
	unsigned int	cmmu_type;
#define	NO_CMMU	0x00
#define	INST_CMMU	0x01
#define	DATA_CMMU	0x02
	vaddr_t		cmmu_addr;	/* address range */
	vaddr_t		cmmu_addr_mask;	/* address mask */
};

/*
 * Structure for accessing MMUS properly
 */

#define MAX_CMMUS	(2 * MAX_CPUS)		/* maximum cmmus on the board */

struct m8820x_cmmu m8820x_cmmu[MAX_CMMUS] = {
	/* address, cpu, mode, addr, mask */
	{ NULL, -1, INST_CMMU, 0, 0 },
	{ NULL, -1, DATA_CMMU, 0, 0 },
	{ NULL, -1, INST_CMMU, 0, 0 },
	{ NULL, -1, DATA_CMMU, 0, 0 },
	{ NULL, -1, INST_CMMU, 0, 0 },
	{ NULL, -1, DATA_CMMU, 0, 0 },
	{ NULL, -1, INST_CMMU, 0, 0 },
	{ NULL, -1, DATA_CMMU, 0, 0 }
};

unsigned int cmmu_shift;

#ifdef MVME188
/*
 * The following list describes the different MVME188 configurations
 * which are supported by this code.
a78 28
/* local prototypes */
void m8820x_cmmu_set(int, unsigned, int, int, int, vaddr_t);
void m8820x_cmmu_wait(int);
void m8820x_cmmu_sync_cache(paddr_t, psize_t);
void m8820x_cmmu_sync_inval_cache(paddr_t, psize_t);
void m8820x_cmmu_inval_cache(paddr_t, psize_t);

/* Flags passed to m8820x_cmmu_set() */
#define MODE_VAL		0x01
#define ADDR_VAL		0x02

#ifdef DEBUG
void
m8820x_show_apr(unsigned value)
{
	printf("table @@ 0x%x000", PG_PFNUM(value));
	if (value & CACHE_WT)
		printf(", writethrough");
	if (value & CACHE_GLOBAL)
		printf(", global");
	if (value & CACHE_INH)
		printf(", cache inhibit");
	if (value & APR_V)
		printf(", valid");
	printf("\n");
}
#endif

d85 1
a85 1
	volatile unsigned *cr;
d89 1
a89 1
	u_int32_t *volatile whoami;
a99 1
		m8820x_cmmu[0].cmmu_cpu = 0;
d101 3
a103 7
		m8820x_cmmu[1].cmmu_cpu = 0;
		m8820x_cmmu[2].cmmu_regs = (void *)NULL;
		m8820x_cmmu[3].cmmu_regs = (void *)NULL;
		m8820x_cmmu[4].cmmu_regs = (void *)NULL;
		m8820x_cmmu[5].cmmu_regs = (void *)NULL;
		m8820x_cmmu[6].cmmu_regs = (void *)NULL;
		m8820x_cmmu[7].cmmu_regs = (void *)NULL;
d108 2
a109 2
		whoami = (u_int32_t *volatile)MVME188_WHOAMI;
		vme188_config = (*whoami & 0xf0) >> 4;
d118 3
a124 5
	max_cpus = bd_config[vme188_config].ncpus;
	max_cmmus = bd_config[vme188_config].ncmmus;

	cmmu_shift = ff1(max_cmmus / max_cpus);

d126 1
a126 1
	if (bd_config[vme188_config].ncpus > 0) {
d139 1
a139 1
#ifdef DIAGNOSTIC
d141 1
a141 1
	 * Probe for available MMUs
d144 1
a144 1
		cr = m8820x_cmmu[cmmu_num].cmmu_regs;
d154 1
a154 2
		} else
			m8820x_cmmu[cmmu_num].cmmu_type = NO_CMMU;
d159 1
a159 2
	 * Now that we know which CMMUs are there, let's report on which
	 * CPU/CMMU sets seem complete (hopefully all)
d168 1
a168 1
		printf("CPU%d is attached with %d MC8820%c CMMUs\n",
d175 16
a190 3
	 * Configure CPU/CMMU strategy into PCNFA and PCNFB board registers.
	 * We should theoretically only set these on configurations 1, 2
	 * and 6, since the other ones do not have P bus decoders.
a197 9
#endif

	/*
	 * Calculate the CMMU<->CPU connections
	 */
	for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++) {
		m8820x_cmmu[cmmu_num].cmmu_cpu =
		    (cmmu_num * max_cpus) / max_cmmus;
	}
d202 2
a203 1
	for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++) {
d213 2
a214 3
			m8820x_cmmu[cmmu_num].cmmu_addr |=
			    (num < 2 ? CMMU_A14_MASK : 0);
			m8820x_cmmu[cmmu_num].cmmu_addr_mask |= CMMU_A14_MASK;
d223 2
a224 3
			m8820x_cmmu[cmmu_num].cmmu_addr |=
			    (num & 1 ? 0 : CMMU_A12_MASK);
			m8820x_cmmu[cmmu_num].cmmu_addr_mask |= CMMU_A12_MASK;
d232 2
a233 2
			m8820x_cmmu[cmmu_num].cmmu_addr = 0;
			m8820x_cmmu[cmmu_num].cmmu_addr_mask = 0;
d241 3
a243 4
		if (CMMU_TYPE(m8820x_cmmu[cmmu_num].cmmu_regs[CMMU_IDR]) ==
		    M88204_ID) {
			m8820x_cmmu[cmmu_num].cmmu_addr <<= 2;
			m8820x_cmmu[cmmu_num].cmmu_addr_mask <<= 2;
a245 12
}

#ifdef DDB
void
m8820x_cmmu_dump_config()
{
#ifdef MVME188
	int cmmu_num;

#ifdef MVME187
	if (brdtyp != BRD_188)
		return;
a246 296

	db_printf("Current CPU/CMMU configuration:\n");
	for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++) {
		db_printf("CMMU #%d: %s CMMU for CPU %d:\n addr 0x%08lx mask 0x%08lx\n",
		  cmmu_num,
		  (m8820x_cmmu[cmmu_num].cmmu_type == INST_CMMU) ? "inst" : "data",
		  m8820x_cmmu[cmmu_num].cmmu_cpu,
		  m8820x_cmmu[cmmu_num].cmmu_addr,
		  m8820x_cmmu[cmmu_num].cmmu_addr_mask);
	}
#endif /* MVME188 */
}
#endif	/* DDB */

/*
 * This function is called by the MMU module and pokes values
 * into the CMMU's registers.
 */
void
m8820x_cmmu_set(int reg, unsigned val, int flags, int cpu, int mode,
    vaddr_t addr)
{
	int mmu;

	/*
	 * We scan all CMMUs to find the matching ones and store the
	 * values there.
	 */
	for (mmu = cpu << cmmu_shift;
	    mmu < (cpu + 1) << cmmu_shift; mmu++) {
		if ((flags & MODE_VAL) != 0) {
			if (m8820x_cmmu[mmu].cmmu_type != mode)
				continue;
		}
#ifdef MVME188
		if ((flags & ADDR_VAL) != 0) {
			if (m8820x_cmmu[mmu].cmmu_addr_mask != 0 &&
			    (addr & m8820x_cmmu[mmu].cmmu_addr_mask) !=
			     m8820x_cmmu[mmu].cmmu_addr)
				continue;
		}
#endif
		m8820x_cmmu[mmu].cmmu_regs[reg] = val;
	}
}

/*
 * Force a read from the CMMU status register, thereby forcing execution to
 * stop until all pending CMMU operations are finished.
 * This is used by the various cache invalidation functions.
 */
void
m8820x_cmmu_wait(int cpu)
{
	int mmu;

	/*
	 * We scan all related CMMUs and read their status register.
	 */
	for (mmu = cpu << cmmu_shift;
	    mmu < (cpu + 1) << cmmu_shift; mmu++) {
#ifdef DEBUG
		if (m8820x_cmmu[mmu].cmmu_regs[CMMU_SSR] & CMMU_SSR_BE) {
			panic("cache flush failed!");
		}
#else
		/* force the read access, but do not issue this statement... */
		__asm__ __volatile__ ("|or r0, r0, %0" ::
		    "r" (m8820x_cmmu[mmu].cmmu_regs[CMMU_SSR]));
#endif
	}
}

const char *mmutypes[8] = {
	"Unknown (0)",
	"Unknown (1)",
	"Unknown (2)",
	"Unknown (3)",
	"Unknown (4)",
	"M88200 (16K)",
	"M88204 (64K)",
	"Unknown (7)"
};

/*
 * Should only be called after the calling cpus knows its cpu
 * number and master/slave status . Should be called first
 * by the master, before the slaves are started.
*/
void
m8820x_cpu_configuration_print(int master)
{
	int pid = read_processor_identification_register();
	int proctype = (pid & 0xff00) >> 8;
	int procvers = (pid & 0xe) >> 1;
	int mmu, cpu = cpu_number();
	struct simplelock print_lock;

	if (master)
		simple_lock_init(&print_lock);

	simple_lock(&print_lock);

	printf("cpu%d: ", cpu);
	if (proctype != 0) {
		printf("unknown model arch 0x%x rev 0x%x\n",
		    proctype, procvers);
		simple_unlock(&print_lock);
		return;
	}

	printf("M88100 rev 0x%x", procvers);
#if 0	/* not useful yet */
#ifdef MVME188
	if (brdtyp == BRD_188)
		printf(", %s", master ? "master" : "slave");
#endif
#endif
	printf(", %d CMMU", 1 << cmmu_shift);

	for (mmu = cpu << cmmu_shift; mmu < (cpu + 1) << cmmu_shift;
	    mmu++) {
		int idr = m8820x_cmmu[mmu].cmmu_regs[CMMU_IDR];
		int mmuid = CMMU_TYPE(idr);

		if (mmu % 2 == 0)
			printf("\ncpu%d: ", cpu);
		else
			printf(", ");

		if (mmutypes[mmuid][0] == 'U')
			printf("unknown model id 0x%x", mmuid);
		else
			printf("%s", mmutypes[mmuid]);
		printf(" rev 0x%x, %scache",
		    CMMU_VERSION(idr),
		    m8820x_cmmu[mmu].cmmu_type == INST_CMMU ? "I" : "D");
	}
	printf("\n");

#ifndef ERRATA__XXX_USR
	{
		static int errata_warn = 0;

		if (proctype != 0 && procvers < 2) {
			if (!errata_warn++)
				printf("WARNING: M88100 bug workaround code "
				    "not enabled.\nPlease recompile the kernel "
				    "with option ERRATA__XXX_USR !\n");
		}
	}
#endif

	simple_unlock(&print_lock);
}

/*
 * CMMU initialization routine
 */
void
m8820x_cmmu_init()
{
	unsigned int line, cmmu_num;
	int cssp, cpu, type;
	u_int32_t apr;
	volatile unsigned *cr;

	for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++) {
		if (m8820x_cmmu[cmmu_num].cmmu_type != NO_CMMU) {
			cr = m8820x_cmmu[cmmu_num].cmmu_regs;
			type = CMMU_TYPE(cr[CMMU_IDR]);

			/*
			 * Reset cache
			 */
			for (cssp = type == M88204_ID ? 3 : 0;
			    cssp >= 0; cssp--)
				for (line = 0; line <= 255; line++) {
					cr[CMMU_SAR] =
					    line << MC88200_CACHE_SHIFT;
					cr[CMMU_CSSP(cssp)] =
					    CMMU_CSSP_L5 | CMMU_CSSP_L4 |
					    CMMU_CSSP_L3 | CMMU_CSSP_L2 |
					    CMMU_CSSP_L1 | CMMU_CSSP_L0 |
					    CMMU_CSSP_VV(3, CMMU_VV_INVALID) |
					    CMMU_CSSP_VV(2, CMMU_VV_INVALID) |
					    CMMU_CSSP_VV(1, CMMU_VV_INVALID) |
					    CMMU_CSSP_VV(0, CMMU_VV_INVALID);
				}

			/*
			 * Set the SCTR, SAPR, and UAPR to some known state
			 */
			cr[CMMU_SCTR] &=
			    ~(CMMU_SCTR_PE | CMMU_SCTR_SE | CMMU_SCTR_PR);
			cr[CMMU_SAPR] = cr[CMMU_UAPR] =
			    ((0x00000 << PG_BITS) | CACHE_WT | CACHE_GLOBAL |
			    CACHE_INH) & ~APR_V;

			cr[CMMU_BWP0] = cr[CMMU_BWP1] =
			cr[CMMU_BWP2] = cr[CMMU_BWP3] =
			cr[CMMU_BWP4] = cr[CMMU_BWP5] =
			cr[CMMU_BWP6] = cr[CMMU_BWP7] = 0;
			cr[CMMU_SCR] = CMMU_FLUSH_CACHE_INV_ALL;
			__asm__ __volatile__ ("|or r0, r0, %0" ::
			    "r" (cr[CMMU_SSR]));
			cr[CMMU_SCR] = CMMU_FLUSH_SUPER_ALL;
			cr[CMMU_SCR] = CMMU_FLUSH_USER_ALL;
		}
	}

	/*
	 * Enable snooping on MVME188 only.
	 * Snooping is enabled for instruction cmmus as well so that
	 * we can share breakpoints.
	 */
#ifdef MVME188
	if (brdtyp == BRD_188) {
		for (cpu = 0; cpu < max_cpus; cpu++) {
			if (cpu_sets[cpu] == 0)
				continue;

			m8820x_cmmu_set(CMMU_SCTR, CMMU_SCTR_SE, MODE_VAL, cpu,
			    DATA_CMMU, 0);
			m8820x_cmmu_set(CMMU_SCTR, CMMU_SCTR_SE, MODE_VAL, cpu,
			    INST_CMMU, 0);

			m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_SUPER_ALL,
			    0, cpu, 0, 0);
			m8820x_cmmu_wait(cpu);
			/* Icache gets flushed just below */
		}
	}
#endif

	/*
	 * Enable instruction cache.
	 * Data cache can not be enabled at this point, because some device
	 * addresses can never be cached, and the no-caching zones are not
	 * set up yet.
	 */
	for (cpu = 0; cpu < max_cpus; cpu++) {
		if (cpu_sets[cpu] == 0)
			continue;

		apr = ((0x00000 << PG_BITS) | CACHE_WT | CACHE_GLOBAL)
		    & ~(CACHE_INH | APR_V);

		m8820x_cmmu_set(CMMU_SAPR, apr, MODE_VAL, cpu, INST_CMMU, 0);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_SUPER_ALL,
		    0, cpu, 0, 0);
		m8820x_cmmu_wait(cpu);
	}
}

/*
 * Just before poweroff or reset....
 */
void
m8820x_cmmu_shutdown_now()
{
	unsigned cmmu_num;
	volatile unsigned *cr;

	CMMU_LOCK;
	for (cmmu_num = 0; cmmu_num < MAX_CMMUS; cmmu_num++)
		if (m8820x_cmmu[cmmu_num].cmmu_type != NO_CMMU) {
			cr = m8820x_cmmu[cmmu_num].cmmu_regs;

			cr[CMMU_SCTR] &=
			    ~(CMMU_SCTR_PE | CMMU_SCTR_SE | CMMU_SCTR_PR);
			cr[CMMU_SAPR] = cr[CMMU_UAPR] =
			    ((0x00000 << PG_BITS) | CACHE_INH) &
			    ~(CACHE_WT | CACHE_GLOBAL | APR_V);
		}
	CMMU_UNLOCK;
}

/*
 * enable parity
 */
void
m8820x_cmmu_parity_enable()
{
	unsigned cmmu_num;
	volatile unsigned *cr;

	CMMU_LOCK;

	for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++)
		if (m8820x_cmmu[cmmu_num].cmmu_type != NO_CMMU) {
			cr = m8820x_cmmu[cmmu_num].cmmu_regs;
			cr[CMMU_SCTR] |= CMMU_SCTR_PE;
		}

	CMMU_UNLOCK;
a293 710

void
m8820x_cmmu_set_sapr(unsigned cpu, unsigned ap)
{
	CMMU_LOCK;
	m8820x_cmmu_set(CMMU_SAPR, ap, 0, cpu, 0, 0);
	CMMU_UNLOCK;
}

void
m8820x_cmmu_set_uapr(unsigned ap)
{
	int s = splhigh();
	int cpu = cpu_number();

	CMMU_LOCK;
	m8820x_cmmu_set(CMMU_UAPR, ap, 0, cpu, 0, 0);
	CMMU_UNLOCK;
	splx(s);
}

/*
 * Functions that invalidate TLB entries.
 */

/*
 *	flush any tlb
 */
void
m8820x_cmmu_flush_tlb(unsigned cpu, unsigned kernel, vaddr_t vaddr,
    vsize_t size)
{
	int s = splhigh();

	CMMU_LOCK;

	/*
	 * Since segment operations are horribly expensive, don't
	 * do any here. Invalidations of up to three pages are performed
	 * as page invalidations, otherwise the entire tlb is flushed.
	 *
	 * Note that this code relies upon size being a multiple of
	 * a page and vaddr being page-aligned.
	 */
	if (size == PAGE_SIZE) {	/* most frequent situation */
		m8820x_cmmu_set(CMMU_SAR, vaddr,
		    ADDR_VAL, cpu, 0, vaddr);
		m8820x_cmmu_set(CMMU_SCR,
		    kernel ? CMMU_FLUSH_SUPER_PAGE : CMMU_FLUSH_USER_PAGE,
		    ADDR_VAL, cpu, 0, vaddr);
	} else if (size > 3 * PAGE_SIZE) {
		m8820x_cmmu_set(CMMU_SCR,
		    kernel ? CMMU_FLUSH_SUPER_ALL : CMMU_FLUSH_USER_ALL,
		    0, cpu, 0, 0);
	} else
	while (size != 0) {
		m8820x_cmmu_set(CMMU_SAR, vaddr,
		    ADDR_VAL, cpu, 0, vaddr);
		m8820x_cmmu_set(CMMU_SCR,
		    kernel ? CMMU_FLUSH_SUPER_PAGE : CMMU_FLUSH_USER_PAGE,
		    ADDR_VAL, cpu, 0, vaddr);

		size -= PAGE_SIZE;
		vaddr += PAGE_SIZE;
	}

	CMMU_UNLOCK;
	splx(s);
}

/*
 * Functions that invalidate caches.
 *
 * Cache invalidates require physical addresses.  Care must be exercised when
 * using segment invalidates.  This implies that the starting physical address
 * plus the segment length should be invalidated.  A typical mistake is to
 * extract the first physical page of a segment from a virtual address, and
 * then expecting to invalidate when the pages are not physically contiguous.
 *
 * We don't push Instruction Caches prior to invalidate because they are not
 * snooped and never modified (I guess it doesn't matter then which form
 * of the command we use then).
 */

/*
 *	flush both Instruction and Data caches
 */
void
m8820x_cmmu_flush_cache(int cpu, paddr_t physaddr, psize_t size)
{
	int s = splhigh();
	CMMU_LOCK;

#if !defined(BROKEN_MMU_MASK)
	if (size > NBSG) {
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, 0,
		    cpu, 0, 0);
	} else if (size <= MC88200_CACHE_LINE) {
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, ADDR_VAL,
		    cpu, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_LINE, ADDR_VAL,
		    cpu, 0, (unsigned)physaddr);
	} else if (size <= NBPG) {
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, ADDR_VAL,
		    cpu, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_PAGE, ADDR_VAL,
		    cpu, 0, (unsigned)physaddr);
	} else {
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, 0,
		    cpu, 0, 0);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_SEGMENT, 0,
		    cpu, 0, 0);
	}
#else
	m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, 0, cpu, 0, 0);
#endif /* !BROKEN_MMU_MASK */

	m8820x_cmmu_wait(cpu);

	CMMU_UNLOCK;
	splx(s);
}

/*
 *	flush Instruction caches
 */
void
m8820x_cmmu_flush_inst_cache(int cpu, paddr_t physaddr, psize_t size)
{
	int s = splhigh();
	CMMU_LOCK;

#if !defined(BROKEN_MMU_MASK)
	if (size > NBSG) {
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, MODE_VAL,
		    cpu, INST_CMMU, 0);
	} else if (size <= MC88200_CACHE_LINE) {
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_LINE,
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, (unsigned)physaddr);
	} else if (size <= NBPG) {
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_PAGE,
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, (unsigned)physaddr);
	} else {
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL, cpu, INST_CMMU, 0);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_SEGMENT,
		    MODE_VAL, cpu, INST_CMMU, 0);
	}
#else
	m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, MODE_VAL,
	    cpu, INST_CMMU, 0);
#endif /* !BROKEN_MMU_MASK */

	m8820x_cmmu_wait(cpu);

	CMMU_UNLOCK;
	splx(s);
}

void
m8820x_cmmu_flush_data_cache(int cpu, paddr_t physaddr, psize_t size)
{
	int s = splhigh();
	CMMU_LOCK;

#if !defined(BROKEN_MMU_MASK)
	if (size > NBSG) {
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, MODE_VAL,
		    cpu, DATA_CMMU, 0);
	} else if (size <= MC88200_CACHE_LINE) {
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_LINE,
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, (unsigned)physaddr);
	} else if (size <= NBPG) {
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_PAGE,
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, (unsigned)physaddr);
	} else {
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL, cpu, DATA_CMMU, 0);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_SEGMENT,
		    MODE_VAL, cpu, DATA_CMMU, 0);
	}
#else
	m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, MODE_VAL,
	    cpu, DATA_CMMU, 0);
#endif /* !BROKEN_MMU_MASK */

	m8820x_cmmu_wait(cpu);

	CMMU_UNLOCK;
	splx(s);
}

/*
 * sync dcache (and icache too)
 */
void
m8820x_cmmu_sync_cache(paddr_t physaddr, psize_t size)
{
	int s = splhigh();
	int cpu = cpu_number();

	CMMU_LOCK;

#if !defined(BROKEN_MMU_MASK)
	if (size > NBSG) {
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CB_ALL, MODE_VAL,
		    cpu, DATA_CMMU, 0);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CB_ALL, MODE_VAL,
		    cpu, INST_CMMU, 0);
	} else if (size <= MC88200_CACHE_LINE) {
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_LINE,
		    MODE_VAL, cpu, INST_CMMU, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_LINE,
		    MODE_VAL, cpu, DATA_CMMU, 0);
	} else if (size <= NBPG) {
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_PAGE,
		    MODE_VAL, cpu, INST_CMMU, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_PAGE,
		    MODE_VAL, cpu, DATA_CMMU, 0);
	} else {
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_SEGMENT,
		    MODE_VAL, cpu, INST_CMMU, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_SEGMENT,
		    MODE_VAL, cpu, DATA_CMMU, 0);
	}
#else
	m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CB_ALL, MODE_VAL,
	    cpu, DATA_CMMU, 0);
	m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CB_ALL, MODE_VAL,
	    cpu, INST_CMMU, 0);
#endif /* !BROKEN_MMU_MASK */

	m8820x_cmmu_wait(cpu);

	CMMU_UNLOCK;
	splx(s);
}

void
m8820x_cmmu_sync_inval_cache(paddr_t physaddr, psize_t size)
{
	int s = splhigh();
	int cpu = cpu_number();

	CMMU_LOCK;

#if !defined(BROKEN_MMU_MASK)
	if (size > NBSG) {
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, MODE_VAL,
		    cpu, DATA_CMMU, 0);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, MODE_VAL,
		    cpu, INST_CMMU, 0);
	} else if (size <= MC88200_CACHE_LINE) {
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_LINE,
		    MODE_VAL, cpu, INST_CMMU, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_LINE,
		    MODE_VAL, cpu, DATA_CMMU, 0);
	} else if (size <= NBPG) {
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_PAGE,
		    MODE_VAL, cpu, INST_CMMU, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_PAGE,
		    MODE_VAL, cpu, DATA_CMMU, 0);
	} else {
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_SEGMENT,
		    MODE_VAL, cpu, INST_CMMU, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_SEGMENT,
		    MODE_VAL, cpu, DATA_CMMU, 0);
	}
#else
	m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, MODE_VAL,
	    cpu, DATA_CMMU, 0);
	m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, MODE_VAL,
	    cpu, INST_CMMU, 0);
#endif /* !BROKEN_MMU_MASK */

	m8820x_cmmu_wait(cpu);

	CMMU_UNLOCK;
	splx(s);
}

void
m8820x_cmmu_inval_cache(paddr_t physaddr, psize_t size)
{
	int s = splhigh();
	int cpu = cpu_number();

	CMMU_LOCK;

#if !defined(BROKEN_MMU_MASK)
	if (size > NBSG) {
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_INV_ALL, MODE_VAL,
		    cpu, DATA_CMMU, 0);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_INV_ALL, MODE_VAL,
		    cpu, INST_CMMU, 0);
	} else if (size <= MC88200_CACHE_LINE) {
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_LINE,
		    MODE_VAL, cpu, INST_CMMU, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_LINE,
		    MODE_VAL, cpu, DATA_CMMU, 0);
	} else if (size <= NBPG) {
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_PAGE,
		    MODE_VAL, cpu, INST_CMMU, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_PAGE,
		    MODE_VAL, cpu, DATA_CMMU, 0);
	} else {
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_SEGMENT,
		    MODE_VAL, cpu, INST_CMMU, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_SEGMENT,
		    MODE_VAL, cpu, DATA_CMMU, 0);
	}
#else
	m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_INV_ALL, MODE_VAL,
	    cpu, DATA_CMMU, 0);
	m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_INV_ALL, MODE_VAL,
	    cpu, INST_CMMU, 0);
#endif /* !BROKEN_MMU_MASK */

	m8820x_cmmu_wait(cpu);

	CMMU_UNLOCK;
	splx(s);
}

void
m8820x_dma_cachectl(vaddr_t va, vsize_t size, int op)
{
	paddr_t pa;
#if !defined(BROKEN_MMU_MASK)
	psize_t count;

	while (size != 0) {
		count = NBPG - (va & PGOFSET);

		if (size < count)
			count = size;

		if (pmap_extract(pmap_kernel(), va, &pa) != FALSE) {
			switch (op) {
			case DMA_CACHE_SYNC:
				m8820x_cmmu_sync_cache(pa, count);
				break;
			case DMA_CACHE_SYNC_INVAL:
				m8820x_cmmu_sync_inval_cache(pa, count);
				break;
			default:
				m8820x_cmmu_inval_cache(pa, count);
				break;
			}
		}

		va += count;
		size -= count;
	}
#else
	/* XXX This assumes the space is also physically contiguous */
	if (pmap_extract(pmap_kernel(), va, &pa) != FALSE) {
		switch (op) {
		case DMA_CACHE_SYNC:
			m8820x_cmmu_sync_cache(pa, size);
			break;
		case DMA_CACHE_SYNC_INVAL:
			m8820x_cmmu_sync_inval_cache(pa, size);
			break;
		default:
			m8820x_cmmu_inval_cache(pa, size);
			break;
		}
	}
#endif /* !BROKEN_MMU_MASK */
}

void
m8820x_dma_cachectl_pa(paddr_t pa, psize_t size, int op)
{
#if !defined(BROKEN_MMU_MASK)
	psize_t count;

	while (size != 0) {
		count = NBPG - (va & PGOFSET);

		if (size < count)
			count = size;

		switch (op) {
		case DMA_CACHE_SYNC:
			m8820x_cmmu_sync_cache(pa, count);
			break;
		case DMA_CACHE_SYNC_INVAL:
			m8820x_cmmu_sync_inval_cache(pa, count);
			break;
		default:
			m8820x_cmmu_inval_cache(pa, count);
			break;
		}

		pa += count;
		size -= count;
	}
#else
	switch (op) {
	case DMA_CACHE_SYNC:
		m8820x_cmmu_sync_cache(pa, size);
		break;
	case DMA_CACHE_SYNC_INVAL:
		m8820x_cmmu_sync_inval_cache(pa, size);
		break;
	default:
		m8820x_cmmu_inval_cache(pa, size);
		break;
	}
#endif /* !BROKEN_MMU_MASK */
}

#ifdef DDB
/*
 * Show (for debugging) how the current CPU translates the given ADDRESS
 * (as DATA).
 */
void
m8820x_cmmu_show_translation(unsigned address, unsigned supervisor_flag,
    unsigned verbose_flag, int unused __attribute__ ((unused)))
{
	int cpu = cpu_number();
	vaddr_t va = address;
	int cmmu_num;
	u_int32_t value;

	/*
	 * Find the correct data CMMU.
	 */
	for (cmmu_num = cpu << cmmu_shift;
	    cmmu_num < (cpu + 1) << cmmu_shift; cmmu_num++) {
		if (m8820x_cmmu[cmmu_num].cmmu_type != DATA_CMMU)
			continue;
		if (m8820x_cmmu[cmmu_num].cmmu_addr_mask == 0 ||
		    (va & m8820x_cmmu[cmmu_num].cmmu_addr_mask) ==
		     m8820x_cmmu[cmmu_num].cmmu_addr)
			break;
	}
	if (cmmu_num == (cpu + 1) << cmmu_shift) {
		db_printf("No matching cmmu for VA %08x\n", address);
		return;
	}

	if (verbose_flag != 0)
		db_printf("VA %08x is managed by CMMU#%d.\n",
		    address, cmmu_num);

	/*
	 * Perform some sanity checks.
	 */
	if (verbose_flag == 0) {
		if ((m8820x_cmmu[cmmu_num].cmmu_regs[CMMU_SCTR] &
		    CMMU_SCTR_SE) == 0)
			db_printf("WARNING: snooping not enabled for CMMU#%d.\n",
			    cmmu_num);
	} else {
		int i;

		for (i = 0; i < max_cmmus; i++)
			if (m8820x_cmmu[i].cmmu_type != NO_CMMU &&
			    (verbose_flag > 1 ||
			     (m8820x_cmmu[i].cmmu_regs[CMMU_SCTR] &
			      CMMU_SCTR_SE) == 0)) {
				db_printf("CMMU#%d (cpu %d %s) snooping %s\n",
				    i, m8820x_cmmu[i].cmmu_cpu,
				    m8820x_cmmu[i].cmmu_type ? "data" : "inst",
				    (m8820x_cmmu[i].cmmu_regs[CMMU_SCTR] &
				     CMMU_SCTR_SE) ? "on":"OFF");
			}
	}

	/*
	 * Ask for a CMMU probe and report its result.
	 */
	{
		volatile unsigned *cmmu_regs = m8820x_cmmu[cmmu_num].cmmu_regs;
		u_int32_t ssr;

		cmmu_regs[CMMU_SAR] = address;
		cmmu_regs[CMMU_SCR] =
		    supervisor_flag ? CMMU_PROBE_SUPER : CMMU_PROBE_USER;
		ssr = cmmu_regs[CMMU_SSR];

		switch (verbose_flag) {
		case 2:
			db_printf("probe of 0x%08x returns ssr=0x%08x\n",
			    address, ssr);
			/* FALLTHROUGH */
		case 1:
			if (ssr & CMMU_SSR_V)
				db_printf("PROBE of 0x%08x returns phys=0x%x",
				    address, cmmu_regs[CMMU_SAR]);
			else
				db_printf("PROBE fault at 0x%x",
				    cmmu_regs[CMMU_PFAR]);
			if (ssr & CMMU_SSR_CE)
				db_printf(", copyback err");
			if (ssr & CMMU_SSR_BE)
				db_printf(", bus err");
			if (ssr & CACHE_WT)
				db_printf(", writethrough");
			if (ssr & CMMU_SSR_SO)
				db_printf(", sup prot");
			if (ssr & CACHE_GLOBAL)
				db_printf(", global");
			if (ssr & CACHE_INH)
				db_printf(", cache inhibit");
			if (ssr & CMMU_SSR_M)
				db_printf(", modified");
			if (ssr & CMMU_SSR_U)
				db_printf(", used");
			if (ssr & CMMU_SSR_PROT)
				db_printf(", write prot");
			if (ssr & CMMU_SSR_BH)
				db_printf(", BATC");
			db_printf(".\n");
			break;
		}
	}

	/*
	 * Interpret area descriptor.
	 */

	if (supervisor_flag)
		value = m8820x_cmmu[cmmu_num].cmmu_regs[CMMU_SAPR];
	else
		value = m8820x_cmmu[cmmu_num].cmmu_regs[CMMU_UAPR];

	switch (verbose_flag) {
	case 2:
		db_printf("CMMU#%d", cmmu_num);
		db_printf(" %cAPR is 0x%08x\n",
		    supervisor_flag ? 'S' : 'U', value);
		/* FALLTHROUGH */
	case 1:
		db_printf("CMMU#%d", cmmu_num);
		db_printf(" %cAPR: SegTbl: 0x%x000p",
		    supervisor_flag ? 'S' : 'U', PG_PFNUM(value));
		if (value & CACHE_WT)
			db_printf(", WTHRU");
		if (value & CACHE_GLOBAL)
			db_printf(", GLOBAL");
		if (value & CACHE_INH)
			db_printf(", INHIBIT");
		if (value & APR_V)
			db_printf(", VALID");
		db_printf("\n");
		break;
	}

	if ((value & APR_V) == 0) {
		db_printf("VA 0x%08x -> apr 0x%08x not valid\n", va, value);
		return;
	}

	value &= PG_FRAME;	/* now point to seg page */

	/*
	 * Walk segment and page tables to find our page.
	 */
	{
		sdt_entry_t sdt;

		if (verbose_flag)
			db_printf("will follow to entry %d of page at 0x%x...\n",
			    SDTIDX(va), value);
		value |= SDTIDX(va) * sizeof(sdt_entry_t);

		if (badwordaddr((vaddr_t)value)) {
			db_printf("VA 0x%08x -> segment table @@0x%08x not accessible\n",
			    va, value);
			return;
		}

		sdt = *(sdt_entry_t *)value;
		switch (verbose_flag) {
		case 2:
			db_printf("SEG DESC @@0x%x is 0x%08x\n", value, sdt);
			/* FALLTHROUGH */
		case 1:
			db_printf("SEG DESC @@0x%x: PgTbl: 0x%x000",
			    value, PG_PFNUM(sdt));
			if (sdt & CACHE_WT)
				db_printf(", WTHRU");
			if (sdt & SG_SO)
				db_printf(", S-PROT");
			if (sdt & CACHE_GLOBAL)
				db_printf(", GLOBAL");
			if (sdt & CACHE_INH)
				db_printf(", $INHIBIT");
			if (sdt & SG_PROT)
				db_printf(", W-PROT");
			if (sdt & SG_V)
				db_printf(", VALID");
			db_printf(".\n");
			break;
		}

		if ((sdt & SG_V) == 0) {
			db_printf("VA 0x%08x -> segment entry 0x%8x @@0x%08x not valid\n",
			    va, sdt, value);
			return;
		}

		value = ptoa(PG_PFNUM(sdt));
	}

	{
		pt_entry_t pte;

		if (verbose_flag)
			db_printf("will follow to entry %d of page at 0x%x...\n",
			    PDTIDX(va), value);
		value |= PDTIDX(va) * sizeof(pt_entry_t);

		if (badwordaddr((vaddr_t)value)) {
			db_printf("VA 0x%08x -> page table entry @@0x%08x not accessible\n",
			    va, value);
			return;
		}

		pte = *(pt_entry_t *)value;
		switch (verbose_flag) {
		case 2:
			db_printf("PAGE DESC @@0x%x is 0x%08x.\n", value, pte);
			/* FALLTHROUGH */
		case 1:
			db_printf("PAGE DESC @@0x%x: page @@%x000",
			    value, PG_PFNUM(pte));
			if (pte & PG_W)
				db_printf(", WIRE");
			if (pte & CACHE_WT)
				db_printf(", WTHRU");
			if (pte & PG_SO)
				db_printf(", S-PROT");
			if (pte & CACHE_GLOBAL)
				db_printf(", GLOBAL");
			if (pte & CACHE_INH)
				db_printf(", $INHIBIT");
			if (pte & PG_M)
				db_printf(", MOD");
			if (pte & PG_U)
				db_printf(", USED");
			if (pte & PG_PROT)
				db_printf(", W-PROT");
			if (pte & PG_V)
				db_printf(", VALID");
			db_printf(".\n");
			break;
		}

		if ((pte & PG_V) == 0) {
			db_printf("VA 0x%08x -> page table entry 0x%08x @@0x%08x not valid\n",
			    va, pte, value);
			return;
		}

		value = ptoa(PG_PFNUM(pte)) | (va & PAGE_MASK);
	}

	db_printf("VA 0x%08x -> PA 0x%08x\n", va, value);
}
#endif /* DDB */
@


1.37
log
@More cleaning:
- a really working and simpler ddb "machine translate" helper.
- get rid of the remains of the BATC code, which would not work as is on
  4:1 and 8:1 boards.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.35 2004/08/03 21:24:43 miod Exp $	*/
a122 1
void m8820x_cmmu_set_pair_batc_entry(unsigned, unsigned, unsigned);
a123 2
void m8820x_cmmu_pmap_activate(unsigned, unsigned,
    u_int32_t i_batc[BATC_MAX], u_int32_t d_batc[BATC_MAX]);
a142 1
	m8820x_cmmu_set_pair_batc_entry,
a143 1
	m8820x_cmmu_pmap_activate,
a830 1
	/* this functionality also mimiced in m8820x_cmmu_pmap_activate() */
a836 18
 * Set batc entry number entry_no to value in
 * the data and instruction cache for the named CPU.
 *
 * Except for the cmmu_init, this function and m8820x_cmmu_pmap_activate
 * are the only functions which may set the batc values.
 */
void
m8820x_cmmu_set_pair_batc_entry(unsigned cpu, unsigned entry_no, unsigned value)
{
	CMMU_LOCK;

	m8820x_cmmu_set(CMMU_BWP(entry_no), value, MODE_VAL, cpu, DATA_CMMU, 0);
	m8820x_cmmu_set(CMMU_BWP(entry_no), value, MODE_VAL, cpu, INST_CMMU, 0);

	CMMU_UNLOCK;
}

/*
a841 1
 *	Some functionality mimiced in m8820x_cmmu_pmap_activate.
a882 33
}

/*
 * New fast stuff for pmap_activate.
 * Does what a few calls used to do.
 * Only called from pmap_activate().
 */
void
m8820x_cmmu_pmap_activate(unsigned cpu, unsigned uapr, u_int32_t i_batc[],
    u_int32_t d_batc[])
{
	int entry_no;

	CMMU_LOCK;

	/* the following is from m8820x_cmmu_set_uapr */
	m8820x_cmmu_set(CMMU_UAPR, uapr, 0, cpu, 0, 0);

	for (entry_no = 0; entry_no < BATC_MAX; entry_no++) {
		m8820x_cmmu_set(CMMU_BWP(entry_no), i_batc[entry_no],
		    MODE_VAL, cpu, INST_CMMU, 0);
		m8820x_cmmu_set(CMMU_BWP(entry_no), d_batc[entry_no],
		    MODE_VAL, cpu, DATA_CMMU, 0);
	}

	/*
	 * Flush the user TLB.
	 * IF THE KERNEL WILL EVER CARE ABOUT THE BATC ENTRIES,
	 * THE SUPERVISOR TLBs SHOULD BE FLUSHED AS WELL.
	 */
	m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_USER_ALL, 0, cpu, 0, 0);

	CMMU_UNLOCK;
@


1.36
log
@KNF and a spanking in the ddb helper code.
@
text
@a112 2
#undef	SHADOW_BATC		/* don't use BATCs for now XXX nivas */

a211 3
#ifdef SHADOW_BATC
	unsigned batc[BATC_MAX];
#endif
a213 5
#ifdef SHADOW_BATC
/* CMMU(cpu,data) is the cmmu struct for the named cpu's indicated cmmu.  */
#define CMMU(cpu, data) cpu_cmmu[(cpu)].pair[(data) ? DATA_CMMU : INST_CMMU]
#endif

a231 4
struct cpu_cmmu {
	struct m8820x_cmmu *pair[2];
} cpu_cmmu[MAX_CPUS];

a643 5
	for (cpu = 0; cpu < max_cpus; cpu++) {
		cpu_cmmu[cpu].pair[INST_CMMU] = 0;
		cpu_cmmu[cpu].pair[DATA_CMMU] = 0;
	}

a648 4
			cpu_cmmu[m8820x_cmmu[cmmu_num].cmmu_cpu].
			  pair[m8820x_cmmu[cmmu_num].cmmu_type] =
			    &m8820x_cmmu[cmmu_num];

a675 10
#ifdef SHADOW_BATC
			m8820x_cmmu[cmmu_num].batc[0] =
			m8820x_cmmu[cmmu_num].batc[1] =
			m8820x_cmmu[cmmu_num].batc[2] =
			m8820x_cmmu[cmmu_num].batc[3] =
			m8820x_cmmu[cmmu_num].batc[4] =
			m8820x_cmmu[cmmu_num].batc[5] =
			m8820x_cmmu[cmmu_num].batc[6] =
			m8820x_cmmu[cmmu_num].batc[7] = 0;
#endif
a854 3
#ifdef SHADOW_BATC
	CMMU(cpu,DATA_CMMU)->batc[entry_no] = value;
#endif
a855 3
#ifdef SHADOW_BATC
	CMMU(cpu,INST_CMMU)->batc[entry_no] = value;
#endif
a930 4
#ifdef SHADOW_BATC
		CMMU(cpu,INST_CMMU)->batc[entry_no] = i_batc[entry_no];
		CMMU(cpu,DATA_CMMU)->batc[entry_no] = d_batc[entry_no];
#endif
d1333 2
a1334 4
 * Show (for debugging) how the given CMMU translates the given ADDRESS.
 * If cmmu == -1, the data cmmu for the current cpu is used.
 *
 * XXX this cmmu == -1 case does not work correctly on 4:1 and 8:1 systems.
d1338 1
a1338 1
    unsigned verbose_flag, int cmmu_num)
d1340 3
a1342 6
	/*
	 * A virtual address is split into three fields. Two are used as
	 * indicies into tables (segment and page), and one is an offset into
	 * a page of memory.
	 */
	vaddr_t va;
d1346 1
a1346 1
	 * Find the correct CMMU if necessary...
d1348 11
a1358 15
	if (cmmu_num == -1) {
		int cpu = cpu_number();

		if (cpu_cmmu[cpu].pair[DATA_CMMU] == 0) {
			db_printf("ack! can't figure my own data cmmu number.\n");
			return;
		}
		cmmu_num = cpu_cmmu[cpu].pair[DATA_CMMU] - m8820x_cmmu;
		if (verbose_flag)
			db_printf("The data cmmu for cpu#%d is cmmu#%d.\n",
			    0, cmmu_num);
	} else if (cmmu_num < 0 || cmmu_num >= max_cmmus) {
		db_printf("invalid cpu number [%d]... must be in range [0..%d]\n",
		    cmmu_num, max_cmmus - 1);

d1362 4
a1368 5
	if (m8820x_cmmu[cmmu_num].cmmu_type == NO_CMMU) {
		db_printf("warning: cmmu %d is not alive.\n", cmmu_num);
		return;
	}

d1378 1
a1378 2
			if ((i == cmmu_num ||
			     m8820x_cmmu[i].cmmu_type != NO_CMMU) &&
a1389 38
	if (supervisor_flag)
		value = m8820x_cmmu[cmmu_num].cmmu_regs[CMMU_SAPR];
	else
		value = m8820x_cmmu[cmmu_num].cmmu_regs[CMMU_UAPR];

#ifdef SHADOW_BATC
	/*
	 * Check for a valid BATC translation.
	 */
	{
		int i;
		u_int32_t batc;
		for (i = 0; i < 8; i++) {
			batc = m8820x_cmmu[cmmu_num].batc[i];
			if ((batc & BATC_V) == 0) {
				if (verbose_flag > 1)
					db_printf("cmmu #%d batc[%d] invalid.\n",
					    cmmu_num, i);
			} else {
				db_printf("cmmu#%d batc[%d] v%08x p%08x",
				    cmmu_num, i,
				    ((batc >> BATC_VSHIFT) & BATC_BLKMASK),
				    ((batc >> BATC_PSHIFT) & BATC_BLKMASK));
				if (batc & BATC_SO)
					db_printf(", supervisor");
				if (batc & BATC_WT)
					db_printf(", wt.th");
				if (batc & BATC_GLOBAL)
					db_printf(", global");
				if (batc & BATC_INH)
					db_printf(", cache inhibit");
				if (batc & BATC_PROT)
					db_printf(", write protect");
			}
		}
	}
#endif	/* SHADOW_BATC */

d1402 2
a1403 1
		if (verbose_flag > 1)
d1406 31
a1436 26
		if (ssr & CMMU_SSR_V)
			db_printf("PROBE of 0x%08x returns phys=0x%x",
			    address, cmmu_regs[CMMU_SAR]);
		else
			db_printf("PROBE fault at 0x%x", cmmu_regs[CMMU_PFAR]);
		if (ssr & CMMU_SSR_CE)
			db_printf(", copyback err");
		if (ssr & CMMU_SSR_BE)
			db_printf(", bus err");
		if (ssr & CACHE_WT)
			db_printf(", writethrough");
		if (ssr & CMMU_SSR_SO)
			db_printf(", sup prot");
		if (ssr & CACHE_GLOBAL)
			db_printf(", global");
		if (ssr & CACHE_INH)
			db_printf(", cache inhibit");
		if (ssr & CMMU_SSR_M)
			db_printf(", modified");
		if (ssr & CMMU_SSR_U)
			db_printf(", used");
		if (ssr & CMMU_SSR_PROT)
			db_printf(", write prot");
		if (ssr & CMMU_SSR_BH)
			db_printf(", BATC");
		db_printf(".\n");
d1442 13
a1454 6
	{
		if (verbose_flag > 1) {
			db_printf("CMMU#%d", cmmu_num);
			db_printf(" %cAPR is 0x%08x\n",
				  supervisor_flag ? 'S' : 'U', value);
		}
d1457 1
a1457 1
			  supervisor_flag ? 'S' : 'U', PG_PFNUM(value));
d1467 2
d1470 3
a1472 8
		/* if not valid, done now */
		if ((value & APR_V) == 0) {
			db_printf("<would report an error, valid bit not set>\n");

			return;
		}

		value &= PG_FRAME;	/* now point to seg page */
d1475 1
a1475 1
	va = address;
d1489 2
a1490 1
			db_printf("ERROR: unable to access page at 0x%08x.\n", value);
d1495 2
a1496 1
		if (verbose_flag > 1)
d1498 19
a1516 15
		db_printf("SEG DESC @@0x%x: PgTbl: 0x%x000",
		    value, PG_PFNUM(sdt));
		if (sdt & CACHE_WT)
			db_printf(", WTHRU");
		if (sdt & SG_SO)
			db_printf(", S-PROT");
		if (sdt & CACHE_GLOBAL)
			db_printf(", GLOBAL");
		if (sdt & CACHE_INH)
			db_printf(", $INHIBIT");
		if (sdt & SG_PROT)
			db_printf(", W-PROT");
		if (sdt & SG_V)
			db_printf(", VALID");
		db_printf(".\n");
a1517 1
		/* if not valid, done now */
d1519 2
a1520 1
			db_printf("<would report an error, STD entry not valid>\n");
d1536 2
a1537 2
			db_printf("error: unable to access page at 0x%08x.\n", value);

d1542 2
a1543 1
		if (verbose_flag > 1)
d1545 25
a1569 21
		db_printf("PAGE DESC @@0x%x: page @@%x000",
			  value, PG_PFNUM(pte));
		if (pte & PG_W)
			db_printf(", WIRE");
		if (pte & CACHE_WT)
			db_printf(", WTHRU");
		if (pte & PG_SO)
			db_printf(", S-PROT");
		if (pte & CACHE_GLOBAL)
			db_printf(", GLOBAL");
		if (pte & CACHE_INH)
			db_printf(", $INHIBIT");
		if (pte & PG_M)
			db_printf(", MOD");
		if (pte & PG_U)
			db_printf(", USED");
		if (pte & PG_PROT)
			db_printf(", W-PROT");
		if (pte & PG_V)
			db_printf(", VALID");
		db_printf(".\n");
a1570 1
		/* if not valid, done now */
d1572 2
a1573 1
			db_printf("<would report an error, PTE entry not valid>\n");
d1577 1
a1577 10
		value = ptoa(PG_PFNUM(pte));
		if (verbose_flag)
			db_printf("will follow to byte %d of page at 0x%x...\n",
			    va & PAGE_MASK, value);
		value |= (va & PAGE_MASK);

		if (badwordaddr((vaddr_t)value)) {
			db_printf("error: unable to access page at 0x%08x.\n", value);
			return;
		}
d1580 1
a1580 1
	db_printf("WORD at 0x%x is 0x%08x.\n", value, *(unsigned *)value);
@


1.35
log
@Overhaul of the MVME188 logic:
- change the split CMMU strategy from splitting on user/supervisor, then
  A14/A14*, to A12/A12*, then A14/A14*. I believe this arrangment, being
  more symmetrical, uses the extra CMMUs better.
- correctly handle 88204 - they will split on A14 and A16 instead of A12
  and A14.
- fix the addressing logic, when we need to know if a specific CMMU manages
  a certain address, or not. Code is even smaller now!
- since the strategy choice makes user/supervisor distinction obsolete,
  remove the associated logic in m8820x_cmmu_set().

We now run multiuser on a 2P128 (4:1 88200) HYPERmodule. All 4:1 configurations
should work; 8:1 configurations (1P128 with 88200, and 1P512) could not been
tested due to lack of such hardware.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.34 2004/08/02 08:35:00 miod Exp $	*/
d194 2
a195 2
 * do not want to waste CMMU resources on the SRAM, and our supervisor
 * address space does not have A31 set.
d289 1
a289 2
m8820x_show_apr(value)
	unsigned value;
a480 1

a484 2
	unsigned long *volatile pcnfa;
	unsigned long *volatile pcnfb;
a492 4
	pcnfa = (unsigned long *volatile)MVME188_PCNFA;
	pcnfb = (unsigned long *volatile)MVME188_PCNFB;
	db_printf("VME188 address decoder: PCNFA = 0x%1lx, PCNFB = 0x%1lx\n\n",
	    *pcnfa & 0xf, *pcnfb & 0xf);
d510 2
a511 5
m8820x_cmmu_set(reg, val, flags, cpu, mode, addr)
	int reg;
	unsigned val;
	int flags, cpu, mode;
	vaddr_t addr;
d525 1
d532 1
d581 1
a581 2
m8820x_cpu_configuration_print(master)
	int master;
d855 1
a855 2
m8820x_cmmu_set_sapr(cpu, ap)
	unsigned cpu, ap;
d863 1
a863 2
m8820x_cmmu_set_uapr(ap)
	unsigned ap;
d883 1
a883 3
m8820x_cmmu_set_pair_batc_entry(cpu, entry_no, value)
	unsigned cpu, entry_no;
	unsigned value;	/* the value to stuff into the batc */
d955 2
a956 4
m8820x_cmmu_pmap_activate(cpu, uapr, i_batc, d_batc)
	unsigned cpu, uapr;
	u_int32_t i_batc[BATC_MAX];
	u_int32_t d_batc[BATC_MAX];
a1374 70
union ssr {
   unsigned bits;
   struct {
      unsigned  :16,
      ce:1,
      be:1,
      :4,
      wt:1,
      sp:1,
      g:1,
      ci:1,
      :1,
      m:1,
      u:1,
      wp:1,
      bh:1,
      v:1;
   } field;
};

union cssp {
   unsigned bits;
   struct {
      unsigned   : 2,
      l: 6,
      d3: 1,
      d2: 1,
      d1: 1,
      d0: 1,
      vv3: 2,
      vv2: 2,
      vv1: 2,
      vv0: 2,
      :12;
   } field;
};

union batcu {
   unsigned bits;
   struct {              /* block address translation register */
      unsigned int
      lba:13,            /* logical block address */
      pba:13,            /* physical block address */
      s:1,               /* supervisor */
      wt:4,              /* write through */
      g:1,               /* global */
      ci:1,              /* cache inhibit */
      wp:1,              /* write protect */
      v:1;               /* valid */
   } field;
};

   #define VV_EX_UNMOD		0
   #define VV_EX_MOD		1
   #define VV_SHARED_UNMOD		2
   #define VV_INVALID		3

   #define D(UNION, LINE) \
	((LINE) == 3 ? (UNION).field.d3 : \
	 ((LINE) == 2 ? (UNION).field.d2 : \
	  ((LINE) == 1 ? (UNION).field.d1 : \
	   ((LINE) == 0 ? (UNION).field.d0 : ~0))))
   #define VV(UNION, LINE) \
	((LINE) == 3 ? (UNION).field.vv3 : \
	 ((LINE) == 2 ? (UNION).field.vv2 : \
	  ((LINE) == 1 ? (UNION).field.vv1 : \
	   ((LINE) == 0 ? (UNION).field.vv0 : ~0))))

   #undef VEQR_ADDR
   #define  VEQR_ADDR 0
d1378 2
d1382 2
a1383 3
m8820x_cmmu_show_translation(address, supervisor_flag, verbose_flag, cmmu_num)
	unsigned address, supervisor_flag, verbose_flag;
	int cmmu_num;
d1390 1
a1390 8
	union {
		unsigned bits;
		struct {
			unsigned segment_table_index:SDT_BITS,
			page_table_index:PDT_BITS,
			page_offset:PG_BITS;
		} field;
	} virtual_address;
d1393 3
a1395 6
	if (verbose_flag)
		db_printf("-------------------------------------------\n");



	/****** ACCESS PROPER CMMU or THREAD ***********/
d1398 1
d1406 2
a1407 2
				  0, cmmu_num);
	} else if (cmmu_num < 0 || cmmu_num >= MAX_CMMUS) {
d1409 1
a1409 1
			  cmmu_num, MAX_CMMUS - 1);
d1414 3
d1422 3
a1424 2
	if (!verbose_flag) {
		if (!(m8820x_cmmu[cmmu_num].cmmu_regs[CMMU_SCTR] & CMMU_SCTR_SE))
d1426 1
a1426 1
				  cmmu_num);
d1429 12
a1440 6
		for (i = 0; i < MAX_CMMUS; i++)
			if ((i == cmmu_num || m8820x_cmmu[i].cmmu_type != NO_CMMU) &&
			    (verbose_flag > 1 || !(m8820x_cmmu[i].cmmu_regs[CMMU_SCTR] & CMMU_SCTR_SE))) {
				db_printf("CMMU#%d (cpu %d %s) snooping %s\n", i,
					  m8820x_cmmu[i].cmmu_cpu, m8820x_cmmu[i].cmmu_type ? "data" : "inst",
					  (m8820x_cmmu[i].cmmu_regs[CMMU_SCTR] & CMMU_SCTR_SE) ? "on":"OFF");
d1450 3
d1455 1
a1455 1
		union batcu batc;
d1457 5
a1461 4
			batc.bits = m8820x_cmmu[cmmu_num].batc[i];
			if (batc.field.v == 0) {
				if (verbose_flag>1)
					db_printf("cmmu #%d batc[%d] invalid.\n", cmmu_num, i);
d1463 14
a1476 7
				db_printf("cmmu#%d batc[%d] v%08x p%08x", cmmu_num, i,
					  batc.field.lba << 18, batc.field.pba);
				if (batc.field.s)  db_printf(", supervisor");
				if (batc.field.wt) db_printf(", wt.th");
				if (batc.field.g)  db_printf(", global");
				if (batc.field.ci) db_printf(", cache inhibit");
				if (batc.field.wp) db_printf(", write protect");
d1482 3
a1484 1
	/******* SEE WHAT A PROBE SAYS (if not a thread) ***********/
a1485 1
		union ssr ssr;
d1487 2
d1490 4
a1493 2
		cmmu_regs[CMMU_SCR] = supervisor_flag ? CMMU_PROBE_SUPER : CMMU_PROBE_USER;
		ssr.bits = cmmu_regs[CMMU_SSR];
d1496 2
a1497 2
				  address, ssr.bits);
		if (ssr.field.v)
d1499 1
a1499 1
				  address, cmmu_regs[CMMU_SAR]);
d1502 20
a1521 10
		if (ssr.field.ce) db_printf(", copyback err");
		if (ssr.field.be) db_printf(", bus err");
		if (ssr.field.wt) db_printf(", writethrough");
		if (ssr.field.sp) db_printf(", sup prot");
		if (ssr.field.g)  db_printf(", global");
		if (ssr.field.ci) db_printf(", cache inhibit");
		if (ssr.field.m)  db_printf(", modified");
		if (ssr.field.u)  db_printf(", used");
		if (ssr.field.wp) db_printf(", write prot");
		if (ssr.field.bh) db_printf(", BATC");
d1525 3
a1527 1
	/******* INTERPRET AREA DESCRIPTOR *********/
d1557 1
a1557 4
	/* translate value from physical to virtual */
	if (verbose_flag)
		db_printf("[%x physical is %x virtual]\n", value, value + VEQR_ADDR);
	value += VEQR_ADDR;
d1559 3
a1561 3
	virtual_address.bits = address;

	/****** ACCESS SEGMENT TABLE AND INTERPRET SEGMENT DESCRIPTOR  *******/
d1564 1
d1567 2
a1568 3
				  virtual_address.field.segment_table_index, value);
		value |= virtual_address.field.segment_table_index *
			 sizeof(sdt_entry_t);
d1579 13
a1591 13
			  value, PG_PFNUM(sdt));
		if (sdt & CACHE_WT)		    db_printf(", WTHRU");
		else				    db_printf(", !wthru");
		if (sdt & SG_SO)		    db_printf(", S-PROT");
		else				    db_printf(", UserOk");
		if (sdt & CACHE_GLOBAL)		    db_printf(", GLOBAL");
		else				    db_printf(", !global");
		if (sdt & CACHE_INH)		    db_printf(", $INHIBIT");
		else				    db_printf(", $ok");
		if (sdt & SG_PROT)		    db_printf(", W-PROT");
		else				    db_printf(", WriteOk");
		if (sdt & SG_V)			    db_printf(", VALID");
		else				    db_printf(", !valid");
d1595 1
a1595 1
		if (!(sdt & SG_V)) {
a1602 6
	/* translate value from physical to virtual */
	if (verbose_flag)
		db_printf("[%x physical is %x virtual]\n", value, value + VEQR_ADDR);
	value += VEQR_ADDR;

	/******* PAGE TABLE *********/
d1605 1
d1608 2
a1609 3
				  virtual_address.field.page_table_index, value);
		value |= virtual_address.field.page_table_index *
			 sizeof(pt_entry_t);
d1622 18
a1639 18
		if (pte & PG_W)			db_printf(", WIRE");
		else				db_printf(", !wire");
		if (pte & CACHE_WT)		db_printf(", WTHRU");
		else				db_printf(", !wthru");
		if (pte & PG_SO)		db_printf(", S-PROT");
		else				db_printf(", UserOk");
		if (pte & CACHE_GLOBAL)		db_printf(", GLOBAL");
		else				db_printf(", !global");
		if (pte & CACHE_INH)		db_printf(", $INHIBIT");
		else				db_printf(", $ok");
		if (pte & PG_M)			db_printf(", MOD");
		else				db_printf(", !mod");
		if (pte & PG_U)			db_printf(", USED");
		else				db_printf(", !used");
		if (pte & PG_PROT)		db_printf(", W-PROT");
		else				db_printf(", WriteOk");
		if (pte & PG_V)			db_printf(", VALID");
		else				db_printf(", !valid");
d1643 1
a1643 1
		if (!(pte & PG_V)) {
d1651 2
a1652 2
				  virtual_address.field.page_offset, value);
		value |= virtual_address.field.page_offset;
a1659 5
	/* translate value from physical to virtual */
	if (verbose_flag)
		db_printf("[%x physical is %x virtual]\n", value, value + VEQR_ADDR);
	value += VEQR_ADDR;

a1660 1

@


1.34
log
@More include files cleaning:
- move MAX_CPUS constant to <machine/cpu.h>
- do not include <machine/board.h> unless needed. In fact, remove this file
  entirely on mvme88k, and include <machine/mvme*.h> on a
  compiling-for-this-board basis
- keep MAX_CMMUS constant private to the m8820x code
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.33 2004/07/31 13:38:32 miod Exp $	*/
a93 1
#include <machine/mvme188.h>		/* VME_CMMU_ */
d97 3
d105 1
a105 1
#endif /* DDB */
d115 1
a115 14
#ifdef DEBUG
unsigned int m8820x_debuglevel;
#define dprintf(_X_) \
	do { \
		if (m8820x_debuglevel != 0) { \
			unsigned int psr = disable_interrupts_return_psr(); \
			printf("%d: ", cpu_number()); \
			printf _X_;  \
			set_psr(psr); \
		} \
	} while (0)
#else
#define dprintf(_X_) do { } while (0)
#endif
d171 1
a171 6
 * This code was initially designed for the Omron Luna 88K layout consisting
 * of up to 4 CPUs with 2 CMMUs each, one for data and one for instructions.
 *
 * Trying to support a few more board configurations for the
 * Motorola MVME188, we have the following layouts:
 *
d178 5
d184 5
a188 6
 * We use these splitup schemes:
 *  - split between data and instructions (always enabled)
 *  - split between user/spv (and A14 in config 2)
 *  - split because of A12 (and A14 in config 2)
 *  - one SRAM supervisor, other rest
 *  - one whole SRAM, other rest
d190 10
a199 3
 * The main problem is to find the right suited CMMU for a given
 * CPU number at those configurations.
 *                                         em, 10.5.94
d206 1
a206 1
	unsigned *volatile cmmu_regs;	/* CMMU "base" area */
d209 3
a211 10
#define	INST_CMMU	0
#define	DATA_CMMU	1
	unsigned int	cmmu_access;
#define	CMMU_ACS_USER	0
#define	CMMU_ACS_SUPER	1
#define	CMMU_ACS_BOTH	2
	unsigned int	cmmu_alive;
#define CMMU_DEAD	0		/* This cmmu is not there */
#define CMMU_AVAILABLE	1		/* It's there, but which cpu's? */
#define CMMU_MARRIED	2		/* Know which cpu it belongs to. */
a213 1
	int		cmmu_addr_match;/* return value of address comparison */
d230 10
a239 11
struct m8820x_cmmu m8820x_cmmu[MAX_CMMUS] =
{
	/* address, cpu, mode, access, alive, addr, mask */
	{(unsigned *volatile)VME_CMMU_I0, -1, INST_CMMU, CMMU_ACS_BOTH, CMMU_DEAD, 0, 0},
	{(unsigned *volatile)VME_CMMU_D0, -1, DATA_CMMU, CMMU_ACS_BOTH, CMMU_DEAD, 0, 0},
	{(unsigned *volatile)VME_CMMU_I1, -1, INST_CMMU, CMMU_ACS_BOTH, CMMU_DEAD, 0, 0},
	{(unsigned *volatile)VME_CMMU_D1, -1, DATA_CMMU, CMMU_ACS_BOTH, CMMU_DEAD, 0, 0},
	{(unsigned *volatile)VME_CMMU_I2, -1, INST_CMMU, CMMU_ACS_BOTH, CMMU_DEAD, 0, 0},
	{(unsigned *volatile)VME_CMMU_D2, -1, DATA_CMMU, CMMU_ACS_BOTH, CMMU_DEAD, 0, 0},
	{(unsigned *volatile)VME_CMMU_I3, -1, INST_CMMU, CMMU_ACS_BOTH, CMMU_DEAD, 0, 0},
	{(unsigned *volatile)VME_CMMU_D3, -1, DATA_CMMU, CMMU_ACS_BOTH, CMMU_DEAD, 0, 0}
a245 22
/*
 * CMMU per CPU split strategies
 */

#define	CMMU_SPLIT_ADDRESS	0x00
#define	CMMU_SPLIT_SPV		0x01
#define	CMMU_SPLIT_SRAM_SPV	0x02
#define	CMMU_SPLIT_SRAM_ALL	0x03

#define	CMMU_SPLIT_MASK		0x03

struct cmmu_strategy {
	int inst;
	int data;
} cpu_cmmu_strategy[] = {
	/*     inst                 data */
	{ CMMU_SPLIT_SPV,      CMMU_SPLIT_SPV}, 	/* CPU 0 */
	{ CMMU_SPLIT_SPV,      CMMU_SPLIT_SPV}, 	/* CPU 1 */
	{ CMMU_SPLIT_ADDRESS,  CMMU_SPLIT_ADDRESS},	/* CPU 2 */
	{ CMMU_SPLIT_ADDRESS,  CMMU_SPLIT_ADDRESS}	/* CPU 3 */
};

d256 1
a256 1
} bd_config[] = {
d277 1
a277 1
void m8820x_cmmu_set(int, unsigned, int, int, int, int, vaddr_t);
d285 1
a285 2
#define ACCESS_VAL		0x02
#define ADDR_VAL		0x04
d311 1
a313 1
	unsigned *volatile cr;
a314 1
	int val1, val2;
a315 2
	unsigned long *volatile pcnfa;
	unsigned long *volatile pcnfb;
d324 1
a324 1
		vme188_config = 10;
a334 2
		max_cpus = 1;
		max_cmmus = 2;
d341 8
a348 4
		dprintf(("m8820x_setup_board_config: WHOAMI @@ 0x%08x holds value 0x%08x vme188_config = %d\n",
				 whoami, *whoami, vme188_config));
		max_cpus = bd_config[vme188_config].ncpus;
		max_cmmus = bd_config[vme188_config].ncmmus;
d353 3
d372 1
a381 1
#ifdef DIAGNOSTIC
d387 3
a390 5
			m8820x_cmmu[cmmu_num].cmmu_alive = CMMU_AVAILABLE;
			dprintf(("m8820x_setup_cmmu_config: CMMU %d found at %p\n",
			    cmmu_num, cr));
		}
	}
d397 1
a397 1
		int i, type;
a398 11
		for (i = 0; i < (1 << cmmu_shift); i++) {
			dprintf(("cmmu_init: testing CMMU %d for CPU %d\n",
			    (num << cmmu_shift) | i, num));
#ifdef DIAGNOSTIC
			if (m8820x_cmmu[(num << cmmu_shift) | i].cmmu_alive == CMMU_DEAD) {
				printf("CMMU %d attached to CPU %d is not working\n",
				    (num << cmmu_shift) | i, num);
				continue;	/* will probably die quickly */
			}
#endif
		}
d403 2
a404 2
		printf("CPU%d is attached with %d MC%x CMMUs\n",
		    num, 1 << cmmu_shift, type == M88204_ID ? 0x88204 : 0x88200);
a406 6
	for (num = 0; num < max_cpus; num++) {
		cpu_cmmu_strategy[num].inst &= CMMU_SPLIT_MASK;
		cpu_cmmu_strategy[num].data &= CMMU_SPLIT_MASK;
		dprintf(("m8820x_setup_cmmu_config: CPU %d inst strat %d data strat %d\n",
		    num, cpu_cmmu_strategy[num].inst, cpu_cmmu_strategy[num].data));
	}
a407 14
	switch (vme188_config) {
	/*
	 * These configurations have hardwired CPU/CMMU configurations.
	 */
#ifdef MVME188
	case 0x00:
	case 0x05:
#endif
	case 0x0a:
		dprintf(("m8820x_setup_cmmu_config: resetting strategies\n"));
		for (num = 0; num < max_cpus; num++)
			cpu_cmmu_strategy[num].inst = CMMU_SPLIT_ADDRESS;
			cpu_cmmu_strategy[num].data = CMMU_SPLIT_ADDRESS;
		break;
d411 4
d416 3
a418 33
	case 0x01:
		pcnfa = (unsigned long *volatile)MVME188_PCNFA;
		pcnfb = (unsigned long *volatile)MVME188_PCNFB;
		val1 = (cpu_cmmu_strategy[0].inst << 2) |
		    cpu_cmmu_strategy[0].data;
		val2 = (cpu_cmmu_strategy[1].inst << 2) |
		    cpu_cmmu_strategy[1].data;
		*pcnfa = val1;
		*pcnfb = val2;
		dprintf(("m8820x_setup_cmmu_config: 2P128: PCNFA = 0x%x, PCNFB = 0x%x\n", val1, val2));
		break;
	case 0x02:
		pcnfa = (unsigned long *volatile)MVME188_PCNFA;
		pcnfb = (unsigned long *volatile)MVME188_PCNFB;
		val1 = (cpu_cmmu_strategy[0].inst << 2) |
		    cpu_cmmu_strategy[0].inst;
		val2 = (cpu_cmmu_strategy[0].data << 2) |
		    cpu_cmmu_strategy[0].data;
		*pcnfa = val1;
		*pcnfb = val2;
		dprintf(("m8820x_setup_cmmu_config: 1P128: PCNFA = 0x%x, PCNFB = 0x%x\n", val1, val2));
		break;
	case 0x06:
		pcnfa = (unsigned long *volatile)MVME188_PCNFA;
		val1 = (cpu_cmmu_strategy[0].inst << 2) |
		    cpu_cmmu_strategy[0].data;
		*pcnfa = val1;
		dprintf(("m8820x_setup_cmmu_config: 1P64: PCNFA = 0x%x\n", val1));
		break;
#endif /* MVME188 */
	default:
		panic("m8820x_setup_cmmu_config: unsupported configuration");
		break;
d420 1
a420 4

#ifdef MVME188
	dprintf(("m8820x_setup_cmmu_config: PCNFA = 0x%x, PCNFB = 0x%x\n", *pcnfa, *pcnfb));
#endif /* MVME188 */
a427 2
		dprintf(("m8820x_setup_cmmu_config: CMMU %d connected with CPU %d\n",
		    cmmu_num, m8820x_cmmu[cmmu_num].cmmu_cpu));
d431 1
a431 1
	 * Now set m8820x_cmmu[].cmmu_access and addr
d434 13
a446 10
		/*
		 * We don't set up anything for the hardwired configurations.
		 */
		if (cmmu_shift == 1) {
			m8820x_cmmu[cmmu_num].cmmu_addr = 0;
			m8820x_cmmu[cmmu_num].cmmu_addr_mask = 0;
			m8820x_cmmu[cmmu_num].cmmu_addr_match = 1;
			m8820x_cmmu[cmmu_num].cmmu_access = CMMU_ACS_BOTH;
			continue;
		}
d448 9
a456 12
		/*
		 * First we set the address/mask pairs for the exact address
		 * matches.
		 */
		switch ((m8820x_cmmu[cmmu_num].cmmu_type == INST_CMMU) ?
		    cpu_cmmu_strategy[m8820x_cmmu[cmmu_num].cmmu_cpu].inst :
		    cpu_cmmu_strategy[m8820x_cmmu[cmmu_num].cmmu_cpu].data) {
		case CMMU_SPLIT_ADDRESS:
			m8820x_cmmu[cmmu_num].cmmu_addr =
			    ((cmmu_num & 0x2) ^ 0x2) << 11;
			m8820x_cmmu[cmmu_num].cmmu_addr_mask = CMMU_A12_MASK;
			m8820x_cmmu[cmmu_num].cmmu_addr_match = 1;
d458 6
a463 1
		case CMMU_SPLIT_SPV:
a465 1
			m8820x_cmmu[cmmu_num].cmmu_addr_match = 1;
a466 27
		case CMMU_SPLIT_SRAM_ALL:
			m8820x_cmmu[cmmu_num].cmmu_addr = CMMU_SRAM;
			m8820x_cmmu[cmmu_num].cmmu_addr_mask = CMMU_SRAM_MASK;
			m8820x_cmmu[cmmu_num].cmmu_addr_match =
			    (cmmu_num & 0x2) ? 1 : 0;
			break;
		case CMMU_SPLIT_SRAM_SPV:
			if (cmmu_num & 0x2) {
				m8820x_cmmu[cmmu_num].cmmu_addr = CMMU_SRAM;
				m8820x_cmmu[cmmu_num].cmmu_addr_mask =
				    CMMU_SRAM_MASK;
			} else {
				m8820x_cmmu[cmmu_num].cmmu_addr = 0;
				m8820x_cmmu[cmmu_num].cmmu_addr_mask = 0;
			}
			m8820x_cmmu[cmmu_num].cmmu_addr_match = 1;
			break;
		}

		/*
		 * For MVME188 single processors, we've got to look at A14.
		 * This bit splits the CMMUs independent of the enabled strategy
		 */
		if (cmmu_shift >= 2) {
			m8820x_cmmu[cmmu_num].cmmu_addr |=
			    ((cmmu_num & 0x4) ^ 0x4) << 12;
			m8820x_cmmu[cmmu_num].cmmu_addr_mask |= CMMU_A14_MASK;
d470 2
a471 1
		 * Next we cope with the various access modes.
d473 4
a476 14
		switch ((m8820x_cmmu[cmmu_num].cmmu_type == INST_CMMU) ?
		    cpu_cmmu_strategy[m8820x_cmmu[cmmu_num].cmmu_cpu].inst :
		    cpu_cmmu_strategy[m8820x_cmmu[cmmu_num].cmmu_cpu].data) {
		case CMMU_SPLIT_SPV:
			m8820x_cmmu[cmmu_num].cmmu_access =
			    (cmmu_num & 0x2) ? CMMU_ACS_USER : CMMU_ACS_SUPER;
			break;
		case CMMU_SPLIT_SRAM_SPV:
			m8820x_cmmu[cmmu_num].cmmu_access =
			    (cmmu_num & 0x2) ? CMMU_ACS_SUPER : CMMU_ACS_BOTH;
			break;
		default:
			m8820x_cmmu[cmmu_num].cmmu_access = CMMU_ACS_BOTH;
			break;
a482 9
#ifdef MVME188
const char *cmmu_strat_string[] = {
	"address split ",
	"user/spv split",
	"spv SRAM split",
	"all SRAM split"
};
#endif

d502 1
a502 1
		db_printf("CMMU #%d: %s CMMU for CPU %d:\n Strategy: %s\n %s access addr 0x%08lx mask 0x%08lx match %s\n",
a505 6
		  cmmu_strat_string[(m8820x_cmmu[cmmu_num].cmmu_type == INST_CMMU) ?
		    cpu_cmmu_strategy[m8820x_cmmu[cmmu_num].cmmu_cpu].inst :
		    cpu_cmmu_strategy[m8820x_cmmu[cmmu_num].cmmu_cpu].data],
		  (m8820x_cmmu[cmmu_num].cmmu_access == CMMU_ACS_BOTH) ?   "User and spv" :
		  ((m8820x_cmmu[cmmu_num].cmmu_access == CMMU_ACS_USER) ? "User        " :
		   "Supervisor  "),
d507 1
a507 2
		  m8820x_cmmu[cmmu_num].cmmu_addr_mask,
		  m8820x_cmmu[cmmu_num].cmmu_addr_match ? "TRUE" : "FALSE");
d518 1
a518 1
m8820x_cmmu_set(reg, val, flags, num, mode, access, addr)
d521 1
a521 1
	int flags, num, mode, access;
d530 10
a539 12
	for (mmu = num << cmmu_shift;
	    mmu < (num + 1) << cmmu_shift; mmu++) {
		if (((flags & MODE_VAL)) &&
		    (m8820x_cmmu[mmu].cmmu_type != mode))
			continue;
		if (((flags & ACCESS_VAL)) &&
		    (m8820x_cmmu[mmu].cmmu_access != access) &&
		    (m8820x_cmmu[mmu].cmmu_access != CMMU_ACS_BOTH))
			continue;
		if (flags & ADDR_VAL) {
			if (((addr & m8820x_cmmu[mmu].cmmu_addr_mask) == m8820x_cmmu[mmu].cmmu_addr)
			    != m8820x_cmmu[mmu].cmmu_addr_match) {
a540 1
			}
a624 1
		int access = m8820x_cmmu[mmu].cmmu_access;
d635 1
a635 1
		printf(" rev 0x%x, %s %scache",
a636 2
		    access == CMMU_ACS_BOTH ? "global" :
		    (access == CMMU_ACS_USER ? "user" : "sup"),
d666 1
a666 1
	unsigned *volatile cr;
d674 1
a674 1
		if (m8820x_cmmu[cmmu_num].cmmu_alive != CMMU_DEAD) {
d743 1
a743 1
			    DATA_CMMU, 0, 0);
d745 1
a745 1
			    INST_CMMU, 0, 0);
d748 1
a748 1
			    ACCESS_VAL, cpu, 0, CMMU_ACS_SUPER, 0);
d768 1
a768 1
		m8820x_cmmu_set(CMMU_SAPR, apr, MODE_VAL, cpu, INST_CMMU, 0, 0);
d770 1
a770 1
		    ACCESS_VAL, cpu, 0, CMMU_ACS_SUPER, 0);
d782 1
a782 1
	unsigned *volatile cr;
d786 1
a786 1
		if (m8820x_cmmu[cmmu_num].cmmu_alive != CMMU_DEAD) {
d805 1
a805 1
	unsigned *volatile cr;
d810 1
a810 1
		if (m8820x_cmmu[cmmu_num].cmmu_alive != CMMU_DEAD) {
d839 1
a839 1
	whoami = *(u_int32_t *volatile)MVME188_WHOAMI;
d869 1
a869 1
	m8820x_cmmu_set(CMMU_SAPR, ap, ACCESS_VAL, cpu, 0, CMMU_ACS_SUPER, 0);
d882 1
a882 1
	m8820x_cmmu_set(CMMU_UAPR, ap, ACCESS_VAL, cpu, 0, CMMU_ACS_USER, 0);
d901 1
a901 2
	m8820x_cmmu_set(CMMU_BWP(entry_no), value, MODE_VAL | ACCESS_VAL,
	    cpu, DATA_CMMU, CMMU_ACS_USER, 0);
d905 1
a905 2
	m8820x_cmmu_set(CMMU_BWP(entry_no), value, MODE_VAL | ACCESS_VAL,
	    cpu, INST_CMMU, CMMU_ACS_USER, 0);
d939 1
a939 2
		    ADDR_VAL | ACCESS_VAL, cpu, 0,
		    kernel ? CMMU_ACS_SUPER : CMMU_ACS_USER, vaddr);
d942 1
a942 2
		    ADDR_VAL | ACCESS_VAL, cpu, 0,
		    kernel ? CMMU_ACS_SUPER : CMMU_ACS_USER, vaddr);
d946 1
a946 2
		    ACCESS_VAL, cpu, 0,
		    kernel ? CMMU_ACS_SUPER : CMMU_ACS_USER, 0);
d950 1
a950 2
		    ADDR_VAL | ACCESS_VAL, cpu, 0,
		    kernel ? CMMU_ACS_SUPER : CMMU_ACS_USER, vaddr);
d953 1
a953 2
		    ADDR_VAL | ACCESS_VAL, cpu, 0,
		    kernel ? CMMU_ACS_SUPER : CMMU_ACS_USER, vaddr);
d979 1
a979 2
	m8820x_cmmu_set(CMMU_UAPR, uapr, ACCESS_VAL,
		      cpu, 0, CMMU_ACS_USER, 0);
d983 1
a983 1
		    MODE_VAL | ACCESS_VAL, cpu, INST_CMMU, CMMU_ACS_USER, 0);
d985 1
a985 1
		    MODE_VAL | ACCESS_VAL, cpu, DATA_CMMU, CMMU_ACS_USER, 0);
d997 1
a997 2
	m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_USER_ALL, ACCESS_VAL,
	    cpu, 0, CMMU_ACS_USER, 0);
d1028 1
a1028 1
		    cpu, 0, 0, 0);
d1031 1
a1031 1
		    cpu, 0, 0, (unsigned)physaddr);
d1033 1
a1033 1
		    cpu, 0, 0, (unsigned)physaddr);
d1036 1
a1036 1
		    cpu, 0, 0, (unsigned)physaddr);
d1038 1
a1038 1
		    cpu, 0, 0, (unsigned)physaddr);
d1041 1
a1041 1
		    cpu, 0, 0, 0);
d1043 1
a1043 1
		    cpu, 0, 0, 0);
d1046 1
a1046 2
	m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_ALL, 0,
	    cpu, 0, 0, 0);
d1067 1
a1067 1
		    cpu, INST_CMMU, 0, 0);
d1070 1
a1070 1
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, 0, (unsigned)physaddr);
d1072 1
a1072 1
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, 0, (unsigned)physaddr);
d1075 1
a1075 1
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, 0, (unsigned)physaddr);
d1077 1
a1077 1
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, 0, (unsigned)physaddr);
d1080 1
a1080 1
		    MODE_VAL, cpu, INST_CMMU, 0, 0);
d1082 1
a1082 1
		    MODE_VAL, cpu, INST_CMMU, 0, 0);
d1086 1
a1086 1
	    cpu, INST_CMMU, 0, 0);
d1104 1
a1104 1
		    cpu, DATA_CMMU, 0, 0);
d1107 1
a1107 1
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, 0, (unsigned)physaddr);
d1109 1
a1109 1
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, 0, (unsigned)physaddr);
d1112 1
a1112 1
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, 0, (unsigned)physaddr);
d1114 1
a1114 1
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, 0, (unsigned)physaddr);
d1117 1
a1117 1
		    MODE_VAL, cpu, DATA_CMMU, 0, 0);
d1119 1
a1119 1
		    MODE_VAL, cpu, DATA_CMMU, 0, 0);
d1123 1
a1123 1
	    cpu, DATA_CMMU, 0, 0);
d1146 1
a1146 1
		    cpu, DATA_CMMU, 0, 0);
d1148 1
a1148 1
		    cpu, INST_CMMU, 0, 0);
d1151 1
a1151 1
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, 0, (unsigned)physaddr);
d1153 1
a1153 1
		    MODE_VAL, cpu, INST_CMMU, 0, 0);
d1155 1
a1155 1
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, 0, (unsigned)physaddr);
d1157 1
a1157 1
		    MODE_VAL, cpu, DATA_CMMU, 0, 0);
d1160 1
a1160 1
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, 0, (unsigned)physaddr);
d1162 1
a1162 1
		    MODE_VAL, cpu, INST_CMMU, 0, 0);
d1164 1
a1164 1
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, 0, (unsigned)physaddr);
d1166 1
a1166 1
		    MODE_VAL, cpu, DATA_CMMU, 0, 0);
d1169 1
a1169 1
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, 0, (unsigned)physaddr);
d1171 1
a1171 1
		    MODE_VAL, cpu, INST_CMMU, 0, 0);
d1173 1
a1173 1
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, 0, (unsigned)physaddr);
d1175 1
a1175 1
		    MODE_VAL, cpu, DATA_CMMU, 0, 0);
d1179 1
a1179 1
	    cpu, DATA_CMMU, 0, 0);
d1181 1
a1181 1
	    cpu, INST_CMMU, 0, 0);
d1201 1
a1201 1
		    cpu, DATA_CMMU, 0, 0);
d1203 1
a1203 1
		    cpu, INST_CMMU, 0, 0);
d1206 1
a1206 1
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, 0, (unsigned)physaddr);
d1208 1
a1208 1
		    MODE_VAL, cpu, INST_CMMU, 0, 0);
d1210 1
a1210 1
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, 0, (unsigned)physaddr);
d1212 1
a1212 1
		    MODE_VAL, cpu, DATA_CMMU, 0, 0);
d1215 1
a1215 1
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, 0, (unsigned)physaddr);
d1217 1
a1217 1
		    MODE_VAL, cpu, INST_CMMU, 0, 0);
d1219 1
a1219 1
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, 0, (unsigned)physaddr);
d1221 1
a1221 1
		    MODE_VAL, cpu, DATA_CMMU, 0, 0);
d1224 1
a1224 1
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, 0, (unsigned)physaddr);
d1226 1
a1226 1
		    MODE_VAL, cpu, INST_CMMU, 0, 0);
d1228 1
a1228 1
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, 0, (unsigned)physaddr);
d1230 1
a1230 1
		    MODE_VAL, cpu, DATA_CMMU, 0, 0);
d1234 1
a1234 1
	    cpu, DATA_CMMU, 0, 0);
d1236 1
a1236 1
	    cpu, INST_CMMU, 0, 0);
d1256 1
a1256 1
		    cpu, DATA_CMMU, 0, 0);
d1258 1
a1258 1
		    cpu, INST_CMMU, 0, 0);
d1261 1
a1261 1
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, 0, (unsigned)physaddr);
d1263 1
a1263 1
		    MODE_VAL, cpu, INST_CMMU, 0, 0);
d1265 1
a1265 1
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, 0, (unsigned)physaddr);
d1267 1
a1267 1
		    MODE_VAL, cpu, DATA_CMMU, 0, 0);
d1270 1
a1270 1
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, 0, (unsigned)physaddr);
d1272 1
a1272 1
		    MODE_VAL, cpu, INST_CMMU, 0, 0);
d1274 1
a1274 1
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, 0, (unsigned)physaddr);
d1276 1
a1276 1
		    MODE_VAL, cpu, DATA_CMMU, 0, 0);
d1279 1
a1279 1
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, 0, (unsigned)physaddr);
d1281 1
a1281 1
		    MODE_VAL, cpu, INST_CMMU, 0, 0);
d1283 1
a1283 1
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, 0, (unsigned)physaddr);
d1285 1
a1285 1
		    MODE_VAL, cpu, DATA_CMMU, 0, 0);
d1289 1
a1289 1
	    cpu, DATA_CMMU, 0, 0);
d1291 1
a1291 1
	    cpu, INST_CMMU, 0, 0);
d1508 1
a1508 1
	if (m8820x_cmmu[cmmu_num].cmmu_alive == CMMU_DEAD) {
a1509 1
#if 0
a1510 1
#endif
d1520 1
a1520 1
			if ((i == cmmu_num || m8820x_cmmu[i].cmmu_alive != CMMU_DEAD) &&
d1558 1
a1558 1
		unsigned *volatile cmmu_regs = m8820x_cmmu[cmmu_num].cmmu_regs;
@


1.33
log
@To know our cpu number, it is much easier and safer to check through which
CMMU we accessed the WHOAMI register, rather than cause a CMMU fault and
check which CMMU reported the fault.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.32 2004/05/07 18:06:35 miod Exp $	*/
a88 1
#include <machine/board.h>
d94 4
d240 2
@


1.32
log
@Introduce a new cmmu operation, cachectl_pa, similar to cachectl, but taking
a pa instead of a pmap_kernel va. The cachectl operation is now deprecated and
will disappear soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.31 2004/01/20 14:35:54 miod Exp $	*/
d397 2
a398 3
		panic("unsupported MVME%x board configuration "
		    "#%X (%d CPUs %d CMMUs)",
		    brdtyp, vme188_config, max_cpus, max_cmmus);
d967 5
a971 3
 * Find out the CPU number from accessing CMMU
 * Better be at splhigh, or even better, with interrupts
 * disabled.
a972 2
#define ILLADDRESS	0x0f000000 	/* any faulty address */

d976 4
a979 2
	unsigned cmmu_no;
	int i, cpu;
d981 4
a984 1
	CMMU_LOCK;
d986 8
a993 22
	for (i = 0; i < 10; i++) {
		/* clear CMMU p-bus status registers */
		for (cmmu_no = 0; cmmu_no < MAX_CMMUS; cmmu_no++) {
			if (m8820x_cmmu[cmmu_no].cmmu_alive == CMMU_AVAILABLE &&
			    m8820x_cmmu[cmmu_no].cmmu_type == DATA_CMMU)
				m8820x_cmmu[cmmu_no].cmmu_regs[CMMU_PFSR] = 0;
		}

		/* access faulting address */
		badwordaddr((vaddr_t)ILLADDRESS);

		/* check which CMMU reporting the fault  */
		for (cmmu_no = 0; cmmu_no < MAX_CMMUS; cmmu_no++) {
			if (m8820x_cmmu[cmmu_no].cmmu_alive == CMMU_AVAILABLE &&
			    m8820x_cmmu[cmmu_no].cmmu_type == DATA_CMMU &&
			    CMMU_PFSR_FAULT(m8820x_cmmu[cmmu_no].
			      cmmu_regs[CMMU_PFSR]) != CMMU_PFSR_SUCCESS) {
				/* clean register, just in case... */
				m8820x_cmmu[cmmu_no].cmmu_regs[CMMU_PFSR] = 0;
				m8820x_cmmu[cmmu_no].cmmu_alive = CMMU_MARRIED;
				cpu = m8820x_cmmu[cmmu_no].cmmu_cpu;
				CMMU_UNLOCK;
d995 12
a1006 2
			}
		}
d1008 2
a1009 3
	CMMU_UNLOCK;

	panic("m8820x_cmmu_cpu_number: could not determine my cpu number");
@


1.31
log
@Use shifts and logical arithmetic, rather than multiplications and integer
arithmetic, when computing cmmu numbers.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.30 2004/01/19 16:57:06 miod Exp $	*/
d141 1
d163 1
d1503 42
@


1.30
log
@The pessimistic tlb handling change turned out to be one more instance of
the phys_map_vaddr bug.

So switch back to regular tlb invalidations, and optimize the two or three
page invalidation situation.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.29 2004/01/14 20:46:02 miod Exp $	*/
d275 2
d384 1
a384 1
	cpu_cmmu_ratio = max_cmmus / max_cpus;
d430 1
a430 1
		for (i = 0; i < cpu_cmmu_ratio; i++) {
d432 1
a432 1
			    num * cpu_cmmu_ratio + i, num));
d434 1
a434 1
			if (m8820x_cmmu[num * cpu_cmmu_ratio + i].cmmu_alive == CMMU_DEAD) {
d436 1
a436 1
				    num * cpu_cmmu_ratio + i, num);
d442 1
a442 1
		type = CMMU_TYPE(m8820x_cmmu[num * cpu_cmmu_ratio].
d446 1
a446 1
		    num, cpu_cmmu_ratio, type == M88204_ID ? 0x88204 : 0x88200);
d530 1
a530 1
		if (cpu_cmmu_ratio == 2) {
d579 1
a579 1
		if (cpu_cmmu_ratio >= 4) {	/* XXX only handles 1P128!!! */
d671 2
a672 2
	for (mmu = num * cpu_cmmu_ratio;
	    mmu < (num + 1) * cpu_cmmu_ratio; mmu++) {
d703 2
a704 2
	for (mmu = cpu * cpu_cmmu_ratio;
	    mmu < (cpu + 1) * cpu_cmmu_ratio; mmu++) {
d763 1
a763 1
	printf(", %d CMMU", cpu_cmmu_ratio);
d765 1
a765 1
	for (mmu = cpu * cpu_cmmu_ratio; mmu < (cpu + 1) * cpu_cmmu_ratio;
d771 1
a771 1
		if ((mmu - cpu * cpu_cmmu_ratio) % 2 == 0)
@


1.29
log
@Some MC8820x operation cleaning:
- define more constants and macros for readability. Especially cache
  initialization suddently becomes more readable.
- after every flush operation, wait for the operation to complete by
  accessing the status register, before returning.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.28 2004/01/09 00:23:08 miod Exp $	*/
d879 1
a879 1
	 * we can have breakpoints, modify code, etc.
d887 1
a887 1
			m8820x_cmmu_set(CMMU_SCTR, CMMU_SCTR_SE, 0, cpu,
d889 1
a889 1
			m8820x_cmmu_set(CMMU_SCTR, CMMU_SCTR_SE, 0, cpu,
d893 1
a893 1
			    ACCESS_VAL, cpu, DATA_CMMU, CMMU_ACS_SUPER, 0);
d1076 17
a1092 2
#if !defined(BROKEN_MMU_MASK)
	if (size > PAGE_SIZE) {
d1097 2
a1098 2
	} else {
		/* a page or smaller */
d1106 3
a1109 6
#else
	m8820x_cmmu_set(CMMU_SCR,
	    kernel ? CMMU_FLUSH_SUPER_ALL : CMMU_FLUSH_USER_ALL,
	    ACCESS_VAL, cpu, 0,
	    kernel ? CMMU_ACS_SUPER : CMMU_ACS_USER, 0);
#endif
d1148 1
a1148 1
	 * THE SUPERVISOR TLBs SHOULB EE FLUSHED AS WELL.
a1167 2
 *
 * XXX miod WHAT? Above comment seems 200% bogus wrt snooping!
@


1.28
log
@Do not define new m8820x specific constants for what are common cache and
apr validity constants, really.

And get rid of the old cache_policy debug trick.
@
text
@d1 25
a25 1
/*	$OpenBSD: m8820x.c,v 1.27 2004/01/05 20:07:03 miod Exp $	*/
a56 1

a84 1
#include <sys/types.h>
d111 1
a111 2
#define DB_CMMU	0x4000	/* MMU debug */
unsigned int m8820x_debuglevel = 0;
d114 1
a114 1
		if (m8820x_debuglevel & DB_CMMU) { \
d176 25
a200 30
struct cmmu_regs {
   /* base + $000 */volatile unsigned idr;
   /* base + $004 */volatile unsigned scr;
   /* base + $008 */volatile unsigned ssr;
   /* base + $00C */volatile unsigned sar;
   /*             */unsigned padding1[0x3D];
   /* base + $104 */volatile unsigned sctr;
   /* base + $108 */volatile unsigned pfSTATUSr;
   /* base + $10C */volatile unsigned pfADDRr;
   /*             */unsigned padding2[0x3C];
   /* base + $200 */volatile unsigned sapr;
   /* base + $204 */volatile unsigned uapr;
   /*             */unsigned padding3[0x7E];
   /* base + $400 */volatile unsigned bwp[8];
   /*             */unsigned padding4[0xF8];
   /* base + $800 */volatile unsigned cdp[4];
   /*             */unsigned padding5[0x0C];
   /* base + $840 */volatile unsigned ctp[4];
   /*             */unsigned padding6[0x0C];
   /* base + $880 */volatile unsigned cssp;

   /* The rest for the 88204 */
#define cssp0 cssp
   /*             */ unsigned padding7[0x03];
   /* base + $890 */volatile unsigned cssp1;
   /*             */unsigned padding8[0x03];
   /* base + $8A0 */volatile unsigned cssp2;
   /*             */unsigned padding9[0x03];
   /* base + $8B0 */volatile unsigned cssp3;
};
d202 3
d206 10
a215 5
	struct cmmu_regs *cmmu_regs;	/* CMMU "base" area */
	unsigned char	cmmu_cpu;	/* cpu number it is attached to */
	unsigned char	which;		/* either INST_CMMU || DATA_CMMU */
	unsigned char	cmmu_access;	/* either CMMU_ACS_{SUPER,USER,BOTH} */
	unsigned char	cmmu_alive;
d227 26
d254 1
a254 1
 * We rely upon and use INST_CMMU == 0 and DATA_CMMU == 1
a255 3
#if INST_CMMU != 0 || DATA_CMMU != 1
error("ack gag barf!");
#endif
d257 44
a300 3
#ifdef SHADOW_BATC
/* CMMU(cpu,data) is the cmmu struct for the named cpu's indicated cmmu.  */
#define CMMU(cpu, data) cpu_cmmu[(cpu)].pair[(data)?DATA_CMMU:INST_CMMU]
d305 1
a314 10
#define	m8820x_cmmu_store(mmu, reg, val) \
	*(unsigned *volatile)((reg) + (char *)(m8820x_cmmu[(mmu)].cmmu_regs)) =\
	    (val)

#define m8820x_cmmu_get(mmu, reg) \
	*(unsigned *volatile)(reg + (char *)(m8820x_cmmu[mmu].cmmu_regs))

#define m8820x_cmmu_alive(mmu) \
	(m8820x_cmmu[mmu].cmmu_alive != CMMU_DEAD)

a332 99
/*----------------------------------------------------------------
 * The cmmu.c module was initially designed for the Omron Luna 88K
 * layout consisting of 4 CPUs with 2 CMMUs each, one for data
 * and one for instructions.
 *
 * Trying to support a few more board configurations for the
 * Motorola MVME188 we have these layouts:
 *
 *  - config 0: 4 CPUs, 8 CMMUs
 *  - config 1: 2 CPUs, 8 CMMUs
 *  - config 2: 1 CPUs, 8 CMMUs
 *  - config 5: 2 CPUs, 4 CMMUs
 *  - config 6: 1 CPU,  4 CMMUs
 *  - config A: 1 CPU,  2 CMMUs
 *
 * We use these splitup schemas:
 *  - split between data and instructions (always enabled)
 *  - split between user/spv (and A14 in config 2)
 *  - split because of A12 (and A14 in config 2)
 *  - one SRAM supervisor, other rest
 *  - one whole SRAM, other rest
 *
 * The main problem is to find the right suited CMMU for a given
 * CPU number at those configurations.
 *                                         em, 10.5.94
 *
 * WARNING: the code was never tested on a uniprocessor
 * system. All effort was made to support these configuration
 * but the kernel never ran on such a system.
 *
 *					   em, 12.7.94
 */

/*
 * This structure describes the CMMU per CPU split strategies
 * used for data and instruction CMMUs.
 */
struct cmmu_strategy {
	int inst;
	int data;
} cpu_cmmu_strategy[] = {
	/*     inst                 data */
	{ CMMU_SPLIT_SPV,      CMMU_SPLIT_SPV},	 /* CPU 0 */
	{ CMMU_SPLIT_SPV,      CMMU_SPLIT_SPV},	 /* CPU 1 */
	{ CMMU_SPLIT_ADDRESS,  CMMU_SPLIT_ADDRESS}, /* CPU 2 */
	{ CMMU_SPLIT_ADDRESS,  CMMU_SPLIT_ADDRESS}  /* CPU 3 */
};

#ifdef MVME188
/*
 * The following list of structs describe the different
 * MVME188 configurations which are supported by this module.
 */
const struct board_config {
	int supported;
	int ncpus;
	int ncmmus;
} bd_config[] = {
	/* sup, CPU MMU */
	{  1,  4,  8}, /* 4P128 - 4P512 */
	{  1,  2,  8}, /* 2P128 - 2P512 */
	{  1,  1,  8}, /* 1P128 - 1P512 */
	{  0, -1, -1},
	{  0, -1, -1},
	{  1,  2,  4}, /* 2P64  - 2P256 */
	{  1,  1,  4}, /* 1P64  - 1P256 */
	{  0, -1, -1},
	{  0, -1, -1},
	{  0, -1, -1},
	{  1,  1,  2}, /* 1P32  - 1P128 */
	{  0, -1, -1},
	{  0, -1, -1},
	{  0, -1, -1},
	{  0, -1, -1},
	{  0, -1, -1}
};
#endif

/*
 * Structure for accessing MMUS properly.
 */

struct m8820x_cmmu m8820x_cmmu[MAX_CMMUS] =
{
	/* address, cpu, mode, access, alive, addr, mask */
	{(struct cmmu_regs *)VME_CMMU_I0, -1, INST_CMMU, CMMU_ACS_BOTH, CMMU_DEAD, 0, 0},
	{(struct cmmu_regs *)VME_CMMU_D0, -1, DATA_CMMU, CMMU_ACS_BOTH, CMMU_DEAD, 0, 0},
	{(struct cmmu_regs *)VME_CMMU_I1, -1, INST_CMMU, CMMU_ACS_BOTH, CMMU_DEAD, 0, 0},
	{(struct cmmu_regs *)VME_CMMU_D1, -1, DATA_CMMU, CMMU_ACS_BOTH, CMMU_DEAD, 0, 0},
	{(struct cmmu_regs *)VME_CMMU_I2, -1, INST_CMMU, CMMU_ACS_BOTH, CMMU_DEAD, 0, 0},
	{(struct cmmu_regs *)VME_CMMU_D2, -1, DATA_CMMU, CMMU_ACS_BOTH, CMMU_DEAD, 0, 0},
	{(struct cmmu_regs *)VME_CMMU_I3, -1, INST_CMMU, CMMU_ACS_BOTH, CMMU_DEAD, 0, 0},
	{(struct cmmu_regs *)VME_CMMU_D3, -1, DATA_CMMU, CMMU_ACS_BOTH, CMMU_DEAD, 0, 0}
};

struct cpu_cmmu {
	struct m8820x_cmmu *pair[2];
} cpu_cmmu[MAX_CPUS];

d341 1
a341 1
	struct cmmu_regs *cr;
d385 1
a385 1
	if (bd_config[vme188_config].supported) {
d404 1
a404 1
		if (!badwordaddr((vaddr_t)cr)) {
d407 1
a407 1
			type = CMMU_TYPE(cr->idr);
d432 1
a432 1
			if (!m8820x_cmmu_alive(num * cpu_cmmu_ratio + i)) {
d441 1
a441 1
		    cmmu_regs->idr);
d451 1
a451 1
				 num, cpu_cmmu_strategy[num].inst, cpu_cmmu_strategy[num].data));
d459 2
a460 2
	case CONFIG_0:
	case CONFIG_5:
d462 1
a462 1
	case CONFIG_A:
d472 1
a472 1
	case CONFIG_1:
d483 1
a483 1
	case CONFIG_2:
d494 1
a494 1
	case CONFIG_6:
d516 1
a516 1
		(cmmu_num * max_cpus) / max_cmmus;
d540 1
a540 1
		switch ((m8820x_cmmu[cmmu_num].which == INST_CMMU) ?
a575 2
		 *
		 * NOT TESTED!!! - em
d577 1
a577 1
		if (cpu_cmmu_ratio > 4) {	/* XXX only handles 1P128!!! */
d586 1
a586 1
		switch ((m8820x_cmmu[cmmu_num].which == INST_CMMU) ?
d591 1
a591 1
			    (cmmu_num & 0x2 ) ? CMMU_ACS_USER : CMMU_ACS_SUPER;
d595 1
a595 1
			    (cmmu_num & 0x2 ) ? CMMU_ACS_SUPER : CMMU_ACS_BOTH;
d636 1
a636 1
		  (m8820x_cmmu[cmmu_num].which == INST_CMMU) ? "inst" : "data",
d638 1
a638 1
		  cmmu_strat_string[(m8820x_cmmu[cmmu_num].which == INST_CMMU) ?
d672 1
a672 1
		    (m8820x_cmmu[mmu].which != mode))
d684 28
a711 1
		m8820x_cmmu_store(mmu, reg, val);
d765 1
a765 1
		int idr = m8820x_cmmu_get(mmu, CMMU_IDR);
d779 1
a779 1
		    (idr & 0x1f0000) >> 16,
d782 1
a782 1
		    m8820x_cmmu[mmu].which == INST_CMMU ? "I" : "D");
d808 4
a811 3
	unsigned tmp, cmmu_num;
	int cpu, type;
	struct cmmu_regs *cr;
d819 1
a819 1
		if (m8820x_cmmu_alive(cmmu_num)) {
d821 1
a821 1
			type = CMMU_TYPE(cr->idr);
d823 2
a824 1
			cpu_cmmu[m8820x_cmmu[cmmu_num].cmmu_cpu].pair[m8820x_cmmu[cmmu_num].which] =
d828 1
a828 2
			 * Reset cache data....
			 * as per M88200 Manual (2nd Ed.) section 3.11.
d830 13
a842 18
			for (tmp = 0; tmp < 255; tmp++) {
				cr->sar = tmp << 4;
				cr->cssp = 0x3f0ff000;
			}

			/* 88204 has additional cache to clear */
			if (type == M88204_ID) {
				for (tmp = 0; tmp < 255; tmp++) {
					cr->sar = tmp << 4;
					cr->cssp1 = 0x3f0ff000;
				}
				for (tmp = 0; tmp < 255; tmp++) {
					cr->sar = tmp << 4;
					cr->cssp2 = 0x3f0ff000;
				}
				for (tmp = 0; tmp < 255; tmp++) {
					cr->sar = tmp << 4;
					cr->cssp3 = 0x3f0ff000;
a843 1
			}
d848 1
a848 1
			cr->sctr &=
d850 1
a850 1
			cr->sapr = cr->uapr =
d864 9
a872 5
			cr->bwp[0] = cr->bwp[1] = cr->bwp[2] = cr->bwp[3] =
			cr->bwp[4] = cr->bwp[5] = cr->bwp[6] = cr->bwp[7] = 0;
			cr->scr = CMMU_FLUSH_CACHE_INV_ALL;
			cr->scr = CMMU_FLUSH_SUPER_ALL;
			cr->scr = CMMU_FLUSH_USER_ALL;
a875 1
#ifdef MVME188
d881 1
d884 1
a884 1
			if (!cpu_sets[cpu])
d894 1
d907 1
a907 1
		if (!cpu_sets[cpu])
d910 1
a910 1
		tmp = ((0x00000 << PG_BITS) | CACHE_WT | CACHE_GLOBAL)
d913 1
a913 1
		m8820x_cmmu_set(CMMU_SAPR, tmp, MODE_VAL, cpu, INST_CMMU, 0, 0);
d916 1
d927 1
a927 1
	struct cmmu_regs *cr;
d931 1
a931 1
		if (m8820x_cmmu_alive(cmmu_num)) {
d934 1
a934 1
			cr->sctr &=
d936 1
a936 1
			cr->sapr = cr->uapr =
d950 1
a950 1
	struct cmmu_regs *cr;
d955 1
a955 1
		if (m8820x_cmmu_alive(cmmu_num)) {
d957 1
a957 2

			cr->sctr |= CMMU_SCTR_PE;
d968 1
a968 1
#define ILLADDRESS	0x0F000000 	/* any faulty address */
d982 2
a983 2
			    m8820x_cmmu[cmmu_no].which == DATA_CMMU)
				m8820x_cmmu[cmmu_no].cmmu_regs->pfSTATUSr = 0;
d992 3
a994 3
			    m8820x_cmmu[cmmu_no].which == DATA_CMMU &&
			    ((m8820x_cmmu[cmmu_no].cmmu_regs->pfSTATUSr >> 16) &
			    0x7) != 0) {
d996 1
a996 1
				m8820x_cmmu[cmmu_no].cmmu_regs->pfSTATUSr = 0;
d1173 1
a1173 1
	} else if (size <= 16) {
d1194 2
d1213 1
a1213 1
	} else if (size <= 16) {
d1234 2
d1250 1
a1250 1
	} else if (size <= 16) {
d1271 2
d1294 1
a1294 1
	} else if (size <= 16) {
d1329 2
d1349 1
a1349 1
	} else if (size <= 16) {
d1384 2
d1404 1
a1404 1
	} else if (size <= 16) {
d1439 2
d1611 1
a1611 1
	if (m8820x_cmmu[cmmu_num].cmmu_alive == 0) {
d1619 1
a1619 1
		if (!(m8820x_cmmu[cmmu_num].cmmu_regs->sctr & CMMU_SCTR_SE))
d1624 3
a1626 3
		for (i=0; i<MAX_CMMUS; i++)
			if ((i == cmmu_num || m8820x_cmmu[i].cmmu_alive) &&
			    (verbose_flag>1 || !(m8820x_cmmu[i].cmmu_regs->sctr&CMMU_SCTR_SE))) {
d1628 2
a1629 2
					  m8820x_cmmu[i].cmmu_cpu, m8820x_cmmu[i].which ? "data" : "inst",
					  (m8820x_cmmu[i].cmmu_regs->sctr & CMMU_SCTR_SE) ? "on":"OFF");
d1634 1
a1634 1
		value = m8820x_cmmu[cmmu_num].cmmu_regs->sapr;
d1636 1
a1636 1
		value = m8820x_cmmu[cmmu_num].cmmu_regs->uapr;
d1663 4
a1666 4
		struct cmmu_regs *cmmu_regs = m8820x_cmmu[cmmu_num].cmmu_regs;
		cmmu_regs->sar = address;
		cmmu_regs->scr = supervisor_flag ? CMMU_PROBE_SUPER : CMMU_PROBE_USER;
		ssr.bits = cmmu_regs->ssr;
d1672 1
a1672 1
				  address, cmmu_regs->sar);
d1674 1
a1674 1
			db_printf("PROBE fault at 0x%x", cmmu_regs->pfADDRr);
@


1.27
log
@Stop masquerading the M8120 (no-slot MVME187) as a real MVME187, and keep
its value in brdtyp.

Compensate by checking for BRD_8120 everywhere BRD_187 was checked.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.26 2004/01/02 17:08:57 miod Exp $	*/
d851 2
a852 2
			    ((0x00000 << PG_BITS) | AREA_D_WT | AREA_D_G |
			    AREA_D_CI) & ~AREA_D_TE;
d905 2
a906 2
		tmp = ((0x00000 << PG_BITS) | AREA_D_WT | AREA_D_G)
		    & ~(AREA_D_CI | AREA_D_TE);
d931 2
a932 2
			    ((0x00000 << PG_BITS) | AREA_D_CI) &
			    ~(AREA_D_WT | AREA_D_G | AREA_D_TE);
a1008 2
	if (cache_policy & CACHE_INH)
		ap |= AREA_D_CI;
@


1.26
log
@When both cmmu_dofoo() and cmmu_remote_dofoo() exist, kill the first one,
and rename the second one to the first one, i.e. have the cmmu_dofoo()
functions always take a cpu# parameter.

No functional change, simply makes code more readable and saves a few
call frames.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.25 2003/12/22 20:10:23 miod Exp $	*/
d373 1
@


1.25
log
@Get rid of kvtop() usage in dma_cachectl().
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.24 2003/12/19 22:30:18 miod Exp $	*/
d110 1
a110 1
void m8820x_cmmu_remote_set_sapr(unsigned, unsigned);
d113 1
a113 2
void m8820x_cmmu_flush_remote_tlb(unsigned, unsigned, vaddr_t, vsize_t);
void m8820x_cmmu_flush_tlb(unsigned, vaddr_t, vsize_t);
d116 3
a118 6
void m8820x_cmmu_flush_remote_cache(int, paddr_t, psize_t);
void m8820x_cmmu_flush_cache(paddr_t, psize_t);
void m8820x_cmmu_flush_remote_inst_cache(int, paddr_t, psize_t);
void m8820x_cmmu_flush_inst_cache(paddr_t, psize_t);
void m8820x_cmmu_flush_remote_data_cache(int, paddr_t, psize_t);
void m8820x_cmmu_flush_data_cache(paddr_t, psize_t);
d132 1
a132 1
	m8820x_cmmu_remote_set_sapr,
a134 1
	m8820x_cmmu_flush_remote_tlb,
a136 1
	m8820x_cmmu_flush_remote_cache,
a137 1
	m8820x_cmmu_flush_remote_inst_cache,
a138 1
	m8820x_cmmu_flush_remote_data_cache,
d1004 1
a1004 1
m8820x_cmmu_remote_set_sapr(cpu, ap)
d1065 1
a1065 1
m8820x_cmmu_flush_remote_tlb(unsigned cpu, unsigned kernel, vaddr_t vaddr,
a1099 10
 *	flush my personal tlb
 */
void
m8820x_cmmu_flush_tlb(unsigned kernel, vaddr_t vaddr, vsize_t size)
{
	int cpu = cpu_number();
	m8820x_cmmu_flush_remote_tlb(cpu, kernel, vaddr, size);
}

/*
d1160 1
a1160 1
m8820x_cmmu_flush_remote_cache(int cpu, paddr_t physaddr, psize_t size)
a1194 10
 *	flush both Instruction and Data caches
 */
void
m8820x_cmmu_flush_cache(paddr_t physaddr, psize_t size)
{
	int cpu = cpu_number();
	m8820x_cmmu_flush_remote_cache(cpu, physaddr, size);
}

/*
d1198 1
a1198 1
m8820x_cmmu_flush_remote_inst_cache(int cpu, paddr_t physaddr, psize_t size)
a1231 10
/*
 *	flush Instruction caches
 */
void
m8820x_cmmu_flush_inst_cache(paddr_t physaddr, psize_t size)
{
	int cpu = cpu_number();
	m8820x_cmmu_flush_remote_inst_cache(cpu, physaddr, size);
}

d1233 1
a1233 1
m8820x_cmmu_flush_remote_data_cache(int cpu, paddr_t physaddr, psize_t size)
a1264 10
}

/*
 * flush data cache
 */
void
m8820x_cmmu_flush_data_cache(paddr_t physaddr, psize_t size)
{
	int cpu = cpu_number();
	m8820x_cmmu_flush_remote_data_cache(cpu, physaddr, size);
@


1.24
log
@Pass -Wformat, and silence a few vme* debug printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.23 2003/10/11 22:46:25 miod Exp $	*/
d74 2
d1480 1
d1490 20
d1512 1
a1512 1
			m8820x_cmmu_sync_cache(kvtop(va), count);
d1515 1
a1515 1
			m8820x_cmmu_sync_inval_cache(kvtop(va), count);
d1518 1
a1518 1
			m8820x_cmmu_inval_cache(kvtop(va), count);
a1520 15

		va += count;
		size -= count;
	}
#else
	switch (op) {
	case DMA_CACHE_SYNC:
		m8820x_cmmu_sync_cache(kvtop(va), size);
		break;
	case DMA_CACHE_SYNC_INVAL:
		m8820x_cmmu_sync_inval_cache(kvtop(va), size);
		break;
	default:
		m8820x_cmmu_inval_cache(kvtop(va), size);
		break;
@


1.23
log
@Get rid of "union cpupid"; makes <machine/cpus.h> disappear as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.22 2003/10/08 13:26:12 miod Exp $	*/
d658 1
a658 1
	db_printf("VME188 address decoder: PCNFA = 0x%1x, PCNFB = 0x%1x\n\n",
d661 1
a661 1
		db_printf("CMMU #%d: %s CMMU for CPU %d:\n Strategy: %s\n %s access addr 0x%08x mask 0x%08x match %s\n",
@


1.22
log
@Nivas had identified an 88200 specific bug, where flushes of a page or a
segment would sometimes not work correctly, and he added a brutal workaround
leading to non-optimal, but safe, cache handling.

The problem affects 88200 rev 7 and 9, and is believed to affect all
88200 revisions (although 88204 seems to be unaffected).

Unfortunately, this problem not only affects cache flushes, but also tlb
invalidations. So add a similar workaround in cmmu_flush_remote_tlb().
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.21 2003/10/05 20:35:26 miod Exp $	*/
a67 1
#include <machine/cpus.h>
d430 1
a430 1
			union cpupid id;
d432 1
a432 1
			id.cpupid = cr->idr;
d434 1
a434 2
			if (id.m88200.type != M88200_ID &&
			    id.m88200.type != M88204_ID) {
d451 1
a451 2
		int i;
		union cpupid id;
d465 2
a466 1
		id.cpupid = m8820x_cmmu[num * cpu_cmmu_ratio].cmmu_regs->idr;
d469 1
a469 2
		    num, cpu_cmmu_ratio,
		    id.m88200.type == M88204_ID ? 0x88204 : 0x88200);
d766 1
a766 1
		int mmuid = (0xe00000 & idr) >> 21;
d809 1
a809 2
	union cpupid id;
	int cpu;
d820 1
a820 1
			id.cpupid = cr->idr;
d835 1
a835 1
			if (id.m88200.type == M88204_ID) {
@


1.21
log
@More cmmu routines cleanup:
- remove unused routines (which were mostly here for debugging anyway)
- do not include <machine/m88*.h> from <machine/cmmu.h> but rather only
  from the modules which need them
- try to simplify the MVME187 codepath in the 8820x code, whenever possible
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.19 2003/09/26 22:27:26 miod Exp $	*/
d1082 1
d1098 6
@


1.20
log
@Despite what the comments say, the instruction cache has never been turned on,
since day one. It's never too late to fix it...
@
text
@d73 1
a76 3
#define DEBUG_MSG db_printf
#else
#define DEBUG_MSG printf
d79 5
d85 1
a85 3
/* On some versions of 88200, page size flushes don't work. I am using
 * sledge hammer approach till I find for sure which ones are bad XXX nivas */
#define BROKEN_MMU_MASK	
d90 1
a90 1
#define dprintf(_L_,_X_) \
d92 1
a92 1
		if (m8820x_debuglevel & (_L_)) { \
d100 26
a125 3
#define dprintf(_L_,_X_) do { } while (0)
#endif 
#undef	SHADOW_BATC		/* don't use BATCs for now XXX nivas */
a129 1
	m8820x_show_apr,
a130 2
	m8820x_setup_cmmu_config,
	m8820x_cmmu_dump_config,
a134 2
	m8820x_cmmu_get_idr,
	m8820x_cmmu_set_sapr,
a136 1
	m8820x_cmmu_set_batc_entry,
d149 1
a149 1
	m8820x_cmmu_get_by_mode,
d151 9
a159 3
	m8820x_cmmu_cache_state,
	m8820x_show_cmmu_info,
#endif /* end if DDB */
d163 18
a180 18
   /* base + $000 */volatile unsigned idr; 
   /* base + $004 */volatile unsigned scr; 
   /* base + $008 */volatile unsigned ssr; 
   /* base + $00C */volatile unsigned sar; 
   /*             */unsigned padding1[0x3D]; 
   /* base + $104 */volatile unsigned sctr; 
   /* base + $108 */volatile unsigned pfSTATUSr; 
   /* base + $10C */volatile unsigned pfADDRr; 
   /*             */unsigned padding2[0x3C]; 
   /* base + $200 */volatile unsigned sapr; 
   /* base + $204 */volatile unsigned uapr; 
   /*             */unsigned padding3[0x7E]; 
   /* base + $400 */volatile unsigned bwp[8]; 
   /*             */unsigned padding4[0xF8]; 
   /* base + $800 */volatile unsigned cdp[4]; 
   /*             */unsigned padding5[0x0C]; 
   /* base + $840 */volatile unsigned ctp[4]; 
   /*             */unsigned padding6[0x0C]; 
d185 5
a189 5
   /*             */ unsigned padding7[0x03]; 
   /* base + $890 */volatile unsigned cssp1; 
   /*             */unsigned padding8[0x03]; 
   /* base + $8A0 */volatile unsigned cssp2; 
   /*             */unsigned padding9[0x03]; 
d195 5
a199 5
	unsigned char  cmmu_cpu;	/* cpu number it is attached to */
	unsigned char  which;		/* either INST_CMMU || DATA_CMMU */
	unsigned char  cmmu_access;	/* either CMMU_ACS_{SUPER,USER,BOTH} */
	unsigned char  cmmu_alive;
#define CMMU_DEAD	0		/* This cmmu not there */
a200 1
#define CMMU_ALIVE	1		/* It's there. */
d202 3
a204 3
	vm_offset_t    cmmu_addr;	/* address range */
	vm_offset_t    cmmu_addr_mask;	/* address mask */
	int            cmmu_addr_match;	/* return value of address comparison */
d206 1
a206 1
	unsigned batc[8];
d208 2
a209 1
}; 
d217 2
a218 5
/*
 * CMMU(cpu,data) Is the cmmu struct for the named cpu's indicated cmmu.
 * REGS(cpu,data) is the actual register structure.
 */

d220 1
a220 1
#define REGS(cpu, data) (*CMMU(cpu, data)->cmmu_regs)
d222 14
a235 6
/* 
 * This lock protects the cmmu SAR and SCR's; other ports 
 * can be accessed without locking it 
 *
 * May be used from "db_interface.c".
 */
d237 2
a238 1
int      vme188_config;
d240 2
a241 8
/* local prototypes */
unsigned m8820x_cmmu_get(int mmu, int reg);
void m8820x_cmmu_store(int, int, unsigned);
void m8820x_cmmu_set(int, unsigned, int, int, int, int, vm_offset_t);
void m8820x_cmmu_sync_cache(vm_offset_t, int);
void m8820x_cmmu_sync_inval_cache(vm_offset_t, int);
void m8820x_cmmu_inval_cache(vm_offset_t, int);
int m8820x_cmmu_alive(int);
d243 1
d259 1
d309 1
d314 1
a314 1
struct board_config {
d318 1
a318 2
} bd_config[] =
{
d337 1
d345 9
a353 18
	/* addr    cpu       mode           access
      alive   addr mask */
	{(void *)VME_CMMU_I0, -1, INST_CMMU, CMMU_ACS_BOTH, 
		CMMU_DEAD, 0, 0},                                 
	{(void *)VME_CMMU_D0, -1, DATA_CMMU, CMMU_ACS_BOTH,       
		CMMU_DEAD, 0, 0},                                 
	{(void *)VME_CMMU_I1, -1, INST_CMMU, CMMU_ACS_BOTH,       
		CMMU_DEAD, 0, 0},                                 
	{(void *)VME_CMMU_D1, -1, DATA_CMMU, CMMU_ACS_BOTH,       
		CMMU_DEAD, 0, 0},                                 
	{(void *)VME_CMMU_I2, -1, INST_CMMU, CMMU_ACS_BOTH,
		CMMU_DEAD, 0, 0},
	{(void *)VME_CMMU_D2, -1, DATA_CMMU, CMMU_ACS_BOTH,
		CMMU_DEAD, 0, 0},
	{(void *)VME_CMMU_I3, -1, INST_CMMU, CMMU_ACS_BOTH,
		CMMU_DEAD, 0, 0},
	{(void *)VME_CMMU_D3, -1, DATA_CMMU, CMMU_ACS_BOTH,
		CMMU_DEAD, 0, 0}
d360 4
a363 1
void 
d366 9
a374 1
	unsigned long *volatile whoami;
d380 2
a381 1
		vme188_config = 10; /* There is no WHOAMI reg on MVME187 - fake it... */
d398 1
a398 1
		whoami = (unsigned long *volatile)MVME188_WHOAMI;
d400 1
a400 1
		dprintf(DB_CMMU,("m8820x_setup_board_config: WHOAMI @@ 0x%08x holds value 0x%08x vme188_config = %d\n",
d407 1
d409 2
a417 1
		m8820x_setup_cmmu_config();
d423 1
a423 18
}

/*
 * This routine sets up the CPU/CMMU tables used in the
 * motorola/m88k/m88100/cmmu.c module.
 */
void 
m8820x_setup_cmmu_config()
{
	register int num, cmmu_num;
#ifdef MVME188
	register int val1, val2;
	unsigned long *volatile pcnfa;
	unsigned long *volatile pcnfb;
#endif 

	dprintf(DB_CMMU,("m8820x_setup_cmmu_config: initializing with %d CPU(s) and %d CMMU(s)\n",
			 max_cpus, max_cmmus));
d428 3
a430 2
	for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++)
		if (!badwordaddr((vm_offset_t)m8820x_cmmu[cmmu_num].cmmu_regs)) {
d433 2
a434 1
			id.cpupid = m8820x_cmmu[cmmu_num].cmmu_regs->idr;
d437 3
a439 3
				printf("WARNING: non M8820x circuit found at CMMU address 0x%08x\n",
				       m8820x_cmmu[cmmu_num].cmmu_regs);
				continue;
d441 4
a444 3
			m8820x_cmmu[cmmu_num].cmmu_alive = CMMU_ALIVE;
			dprintf(DB_CMMU,("m8820x_setup_cmmu_config: CMMU %d found at 0x%08x\n",
					 cmmu_num, m8820x_cmmu[cmmu_num].cmmu_regs));
d446 1
d448 4
a451 4
		/*
		 * Now that we know which CMMUs are there, let's report on which
		 * CPU/CMMU sets seem complete (hopefully all)
		 */
d453 1
a453 1
		register int i;
d457 4
a460 3
			dprintf(DB_CMMU,("cmmu_init: testing CMMU %d for CPU %d\n",
					 num*cpu_cmmu_ratio+i, num));
			if (!m8820x_cmmu_alive(num*cpu_cmmu_ratio + i)) {
d462 2
a463 2
					 num*cpu_cmmu_ratio+i, num);
				panic("m8820x_setup_cmmu_config");
d465 1
d468 1
a468 1
		id.cpupid = m8820x_cmmu[num*cpu_cmmu_ratio].cmmu_regs->idr;
d470 3
a472 6
		if (id.m88200.type == M88204_ID)
			printf("CPU%d is attached with %d MC88204 CMMUs\n",
			       num, cpu_cmmu_ratio);
		else
			printf("CPU%d is attached with %d MC88200 CMMUs\n",
			       num, cpu_cmmu_ratio);
d478 1
a478 1
		dprintf(DB_CMMU,("m8820x_setup_cmmu_config: CPU %d inst strat %d data strat %d\n",
d486 1
d489 1
d491 1
a491 1
		dprintf(DB_CMMU,("m8820x_setup_cmmu_config: resetting strategies\n"));
d493 2
a494 2
			cpu_cmmu_strategy[num].inst = cpu_cmmu_strategy[num].data =
						      CMMU_SPLIT_ADDRESS;
d503 4
a506 2
		val1 = (cpu_cmmu_strategy[0].inst << 2) | cpu_cmmu_strategy[0].data;
		val2 = (cpu_cmmu_strategy[1].inst << 2) | cpu_cmmu_strategy[1].data;
d509 1
a509 1
		dprintf(DB_CMMU,("m8820x_setup_cmmu_config: 2P128: PCNFA = 0x%x, PCNFB = 0x%x\n", val1, val2));
d514 4
a517 2
		val1 = (cpu_cmmu_strategy[0].inst << 2) | cpu_cmmu_strategy[0].inst;
		val2 = (cpu_cmmu_strategy[0].data << 2) | cpu_cmmu_strategy[0].data;
d520 1
a520 1
		dprintf(DB_CMMU,("m8820x_setup_cmmu_config: 1P128: PCNFA = 0x%x, PCNFB = 0x%x\n", val1, val2));
d524 2
a525 1
		val1 = (cpu_cmmu_strategy[0].inst << 2) | cpu_cmmu_strategy[0].data;
d527 1
a527 1
		dprintf(DB_CMMU,("m8820x_setup_cmmu_config: 1P64: PCNFA = 0x%x\n", val1));
d531 1
a531 1
		panic("m8820x_setup_cmmu_config");
d536 1
a536 1
	dprintf(DB_CMMU,("m8820x_setup_cmmu_config: PCNFA = 0x%x, PCNFB = 0x%x\n", *pcnfa, *pcnfb));
d544 3
a546 3
		(int) (((float) cmmu_num) * ((float) max_cpus) / ((float) max_cmmus));
		dprintf(DB_CMMU,("m8820x_setup_cmmu_config: CMMU %d connected with CPU %d\n",
				 cmmu_num, m8820x_cmmu[cmmu_num].cmmu_cpu));
d557 1
a557 1
			m8820x_cmmu[cmmu_num].cmmu_addr =
d569 2
a570 2
			cpu_cmmu_strategy[m8820x_cmmu[cmmu_num].cmmu_cpu].inst :
			cpu_cmmu_strategy[m8820x_cmmu[cmmu_num].cmmu_cpu].data) {
d572 2
a573 1
			m8820x_cmmu[cmmu_num].cmmu_addr = ((cmmu_num & 0x2) ^ 0x2) << 11;
d578 1
a578 1
			m8820x_cmmu[cmmu_num].cmmu_addr =
d585 2
a586 1
			m8820x_cmmu[cmmu_num].cmmu_addr_match = (cmmu_num & 0x2) ? 1 : 0;
d591 2
a592 1
				m8820x_cmmu[cmmu_num].cmmu_addr_mask = CMMU_SRAM_MASK;
d594 1
a594 1
				m8820x_cmmu[cmmu_num].cmmu_addr =
d603 1
a603 1
		 * This bit splits the CMMUs independent of the enabled strategy.
d607 3
a609 2
		if (cpu_cmmu_ratio > 4) {
			m8820x_cmmu[cmmu_num].cmmu_addr |= ((cmmu_num & 0x4) ^ 0x4) << 12;
d617 2
a618 2
			cpu_cmmu_strategy[m8820x_cmmu[cmmu_num].cmmu_cpu].inst :
			cpu_cmmu_strategy[m8820x_cmmu[cmmu_num].cmmu_cpu].data) {
d621 1
a621 1
			(cmmu_num & 0x2 ) ? CMMU_ACS_USER : CMMU_ACS_SUPER;
d625 1
a625 1
			(cmmu_num & 0x2 ) ? CMMU_ACS_SUPER : CMMU_ACS_BOTH;
d634 2
d637 1
a637 1
static char *cmmu_strat_string[] = {
d643 1
a643 1
#endif 
d645 1
a645 1
void 
d651 1
a651 2
	register int cmmu_num;
#endif /* MVME188 */
d653 4
a656 1
	DEBUG_MSG("Current CPU/CMMU configuration:\n\n");
d658 20
a677 25
	switch (brdtyp) {
#ifdef MVME187
	case BRD_187:
		DEBUG_MSG("VME1x7 split mode\n\n");
#endif /* MVME187 */
#ifdef MVME188
	case BRD_188:
		pcnfa = (unsigned long *volatile)MVME188_PCNFA;
		pcnfb = (unsigned long *volatile)MVME188_PCNFB;
		DEBUG_MSG("VME188 address decoder: PCNFA = 0x%1x, PCNFB = 0x%1x\n\n", *pcnfa & 0xf, *pcnfb & 0xf);
		for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++) {
			DEBUG_MSG("CMMU #%d: %s CMMU for CPU %d:\n Strategy: %s\n %s access addr 0x%08x mask 0x%08x match %s\n",
				  cmmu_num,
				  (m8820x_cmmu[cmmu_num].which == INST_CMMU) ? "inst" : "data",
				  m8820x_cmmu[cmmu_num].cmmu_cpu,
				  cmmu_strat_string[(m8820x_cmmu[cmmu_num].which == INST_CMMU) ?
						    cpu_cmmu_strategy[m8820x_cmmu[cmmu_num].cmmu_cpu].inst :
						    cpu_cmmu_strategy[m8820x_cmmu[cmmu_num].cmmu_cpu].data],
				  (m8820x_cmmu[cmmu_num].cmmu_access == CMMU_ACS_BOTH) ?   "User and spv" :
				  ((m8820x_cmmu[cmmu_num].cmmu_access == CMMU_ACS_USER) ? "User        " :
				   "Supervisor  "),
				  m8820x_cmmu[cmmu_num].cmmu_addr,
				  m8820x_cmmu[cmmu_num].cmmu_addr_mask,
				  m8820x_cmmu[cmmu_num].cmmu_addr_match ? "TRUE" : "FALSE");
		}
a678 24
	}
}

/* To be implemented as a macro for speedup - XXX-em */
void
m8820x_cmmu_store(mmu, reg, val)
	int mmu, reg;
	unsigned val;
{
	*(unsigned *volatile)(reg + (char *)(m8820x_cmmu[mmu].cmmu_regs)) = val;
}

int 
m8820x_cmmu_alive(mmu)
	int mmu;
{
	return (m8820x_cmmu[mmu].cmmu_alive == CMMU_ALIVE);
}

unsigned 
m8820x_cmmu_get(mmu, reg)
	int mmu, reg;
{
	return *(unsigned *volatile)(reg + (char *)(m8820x_cmmu[mmu].cmmu_regs));
d680 1
d686 1
a686 1
void 
d691 1
a691 1
	vm_offset_t addr;
d693 1
a693 11
	register int mmu;

	if (flags & NUM_CMMU) {
		/*
		 * Special case: user supplied CMMU number directly as argument.
		 * Simply store the value away.
		 */
		/* assert(num < max_cmmus); */
		m8820x_cmmu_store(num, reg, val);
		return;
	}
d699 2
a700 1
	for (mmu = num*cpu_cmmu_ratio; mmu < (num+1)*cpu_cmmu_ratio; mmu++) {
d718 1
a718 22
#ifdef DDB
/*
 * Used by DDB for cache probe functions
 */
unsigned 
m8820x_cmmu_get_by_mode(cpu, mode)
	int cpu, mode;
{
	register int mmu;

	for (mmu = cpu*cpu_cmmu_ratio; mmu < (cpu+1)*cpu_cmmu_ratio; mmu++)
		if (m8820x_cmmu[mmu].which == mode)
			return mmu;
	printf("can't figure out first %s CMMU for CPU %d\n",
	       (mode == DATA_CMMU) ? "data" : "instruction", cpu);
	panic("m8820x_cmmu_get_by_mode");
	/* NOTREACHED */
	return(0);
}
#endif

static char *mmutypes[8] = {
d734 1
a734 1
void 
d759 1
d763 1
d769 1
a769 1
		int mmuid = (0xe00000 & idr)>>21;
d814 1
d817 2
a818 1
		cpu_cmmu[cpu].pair[INST_CMMU] = cpu_cmmu[cpu].pair[DATA_CMMU] = 0;
d821 1
a821 1
	for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++){
d823 2
a824 1
			id.cpupid = m8820x_cmmu[cmmu_num].cmmu_regs->idr;
d827 2
a828 1
			&m8820x_cmmu[cmmu_num];
d834 2
a835 2
				m8820x_cmmu[cmmu_num].cmmu_regs->sar = tmp << 4;
				m8820x_cmmu[cmmu_num].cmmu_regs->cssp = 0x3f0ff000;
d841 2
a842 2
					m8820x_cmmu[cmmu_num].cmmu_regs->sar = tmp<<4;
					m8820x_cmmu[cmmu_num].cmmu_regs->cssp1 = 0x3f0ff000;
d845 2
a846 2
					m8820x_cmmu[cmmu_num].cmmu_regs->sar = tmp<<4;
					m8820x_cmmu[cmmu_num].cmmu_regs->cssp2 = 0x3f0ff000;
d849 2
a850 2
					m8820x_cmmu[cmmu_num].cmmu_regs->sar = tmp<<4;
					m8820x_cmmu[cmmu_num].cmmu_regs->cssp3 = 0x3f0ff000;
a855 1
			 * (I don't trust the reset to do it).
d857 4
a860 7
			tmp = 0 & ~(
			    CMMU_SCTR_PE |   /* not parity enable */
			    CMMU_SCTR_SE | /* not snoop enable */
			    CMMU_SCTR_PR);  /* not priority arbitration */
			m8820x_cmmu[cmmu_num].cmmu_regs->sctr = tmp;

			tmp = ((0x00000 << PG_BITS) | AREA_D_WT | AREA_D_G |
a861 3
			m8820x_cmmu[cmmu_num].cmmu_regs->sapr =
			m8820x_cmmu[cmmu_num].cmmu_regs->uapr = tmp;

d873 5
a877 11
			m8820x_cmmu[cmmu_num].cmmu_regs->bwp[0] = 
			m8820x_cmmu[cmmu_num].cmmu_regs->bwp[1] = 
			m8820x_cmmu[cmmu_num].cmmu_regs->bwp[2] = 
			m8820x_cmmu[cmmu_num].cmmu_regs->bwp[3] = 
			m8820x_cmmu[cmmu_num].cmmu_regs->bwp[4] = 
			m8820x_cmmu[cmmu_num].cmmu_regs->bwp[5] = 
			m8820x_cmmu[cmmu_num].cmmu_regs->bwp[6] = 
			m8820x_cmmu[cmmu_num].cmmu_regs->bwp[7] = 0;
			m8820x_cmmu[cmmu_num].cmmu_regs->scr = CMMU_FLUSH_CACHE_INV_ALL;
			m8820x_cmmu[cmmu_num].cmmu_regs->scr = CMMU_FLUSH_SUPER_ALL;
			m8820x_cmmu[cmmu_num].cmmu_regs->scr = CMMU_FLUSH_USER_ALL;
d880 2
d883 3
a885 1
	 * Enable snooping...
d887 4
a890 3
	for (cpu = 0; cpu < max_cpus; cpu++) {
		if (!cpu_sets[cpu])
			continue;
d892 9
a900 17
		/*
		 * Enable snooping.
		 * We enable it for instruction cmmus as well so that we can have
		 * breakpoints, etc, and modify code.
		 */
		if (brdtyp == BRD_188) {
			tmp = CMMU_SCTR_SE & ~(CMMU_SCTR_PE | CMMU_SCTR_PR);
		} else {
			tmp = 0 & ~(CMMU_SCTR_PE | CMMU_SCTR_PR);
		}
		m8820x_cmmu_set(CMMU_SCTR, tmp, 0, cpu, DATA_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SCTR, tmp, 0, cpu, INST_CMMU, 0, 0);

		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_SUPER_ALL, ACCESS_VAL,
			      cpu, DATA_CMMU, CMMU_ACS_SUPER, 0);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_SUPER_ALL, ACCESS_VAL,
			      cpu, INST_CMMU, CMMU_ACS_SUPER, 0);
d902 1
d905 4
a908 1
	 * Turn on some cache.
d913 1
a913 6
		/*
		 * Enable some caching for the instruction stream.
		 * Can't cache data yet 'cause device addresses can never
		 * be cached, and we don't have those no-caching zones
		 * set up yet....
		 */
a915 2
		m8820x_cmmu_set(CMMU_SAPR, tmp, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
d917 3
a919 2
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_SUPER_ALL, ACCESS_VAL|MODE_VAL,
			      cpu, DATA_CMMU, CMMU_ACS_SUPER, 0);
a928 1
	unsigned tmp;
d930 1
d933 9
a941 8
	/*
	 * Now set some state as we like...
	 */
	for (cmmu_num = 0; cmmu_num < MAX_CMMUS; cmmu_num++) {
		if (brdtyp == BRD_188) {
			tmp = 0 & ~(CMMU_SCTR_PE | CMMU_SCTR_SE | CMMU_SCTR_PR);
		} else {
			tmp = 0 & ~(CMMU_SCTR_PE | CMMU_SCTR_PR);
a942 9

		m8820x_cmmu[cmmu_num].cmmu_regs->sctr = tmp;

		tmp = ((0x00000 << PG_BITS) | AREA_D_CI) &
		    ~(AREA_D_WT | AREA_D_G | AREA_D_TE);

		m8820x_cmmu[cmmu_num].cmmu_regs->sapr = tmp;
		m8820x_cmmu[cmmu_num].cmmu_regs->uapr = tmp;
	}
a945 1
#define PARITY_ENABLE
d949 1
a949 1
void 
d952 3
a954 2
#ifdef PARITY_ENABLE
	register int cmmu_num;
d957 1
a957 1
	for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++) {
d959 1
a959 2
			register unsigned val1 = 
				m8820x_cmmu_get(cmmu_num, CMMU_SCTR);
d961 1
a961 5
			/*
			m8820x_cmmu[cmmu_num].cmmu_regs->sctr |= CMMU_SCTR_PE;
			*/
			m8820x_cmmu_set(CMMU_SCTR, val1 | CMMU_SCTR_PE, 
				      NUM_CMMU, cmmu_num, 0, 0, 0);
d963 1
a963 1
	}
a964 1
#endif  /* PARITY_ENABLE */
d974 1
a974 1
unsigned 
d977 2
a978 2
	register unsigned cmmu_no;
	int i;
d982 1
a982 1
	for (i=0; i < 10; i++) {
d991 1
a991 1
		badwordaddr((vm_offset_t)ILLADDRESS);
d997 8
a1004 6
			    m8820x_cmmu[cmmu_no].cmmu_regs->pfSTATUSr & 0x70000) {
				if (m8820x_cmmu[cmmu_no].cmmu_regs->pfSTATUSr & 0x70000) {
					m8820x_cmmu[cmmu_no].cmmu_regs->pfSTATUSr = 0;	/* to be clean */
					m8820x_cmmu[cmmu_no].cmmu_alive = CMMU_MARRIED;
					return m8820x_cmmu[cmmu_no].cmmu_cpu;
				}
a1007 1
	panic("m8820x_cmmu_cpu_number: could not determine my cpu number");
a1008 2
	return 0; /* to make compiler happy */
}
d1010 1
a1010 23
/* Needs no locking - read only registers */
unsigned
m8820x_cmmu_get_idr(data)
	unsigned data;
{
	int cpu;
	cpu = cpu_number();
	return REGS(cpu,data).idr;
}

void
m8820x_cmmu_set_sapr(ap)
	unsigned ap;
{
	int cpu;
	cpu = cpu_number();

	CMMU_LOCK;
	if (cache_policy & CACHE_INH)
		ap |= AREA_D_CI;
	m8820x_cmmu_set(CMMU_SAPR, ap, ACCESS_VAL,
		      cpu, 0, CMMU_ACS_SUPER, 0);
	CMMU_UNLOCK;
d1020 1
a1020 2
	m8820x_cmmu_set(CMMU_SAPR, ap, ACCESS_VAL,
		      cpu, 0, CMMU_ACS_SUPER, 0);
d1028 2
a1029 4
	register int s = splhigh();
	int cpu;
	
	cpu = cpu_number();
d1033 1
a1033 2
	m8820x_cmmu_set(CMMU_UAPR, ap, ACCESS_VAL,
		      cpu, 0, CMMU_ACS_USER, 0);
d1039 2
a1040 2
 * Set batc entry number entry_no to value in 
 * the data or instruction cache depending on data.
d1042 2
a1043 3
 * Except for the cmmu_init, this function, m8820x_cmmu_set_pair_batc_entry,
 * and m8820x_cmmu_pmap_activate are the only functions which may set the
 * batc values.
d1046 1
a1046 1
m8820x_cmmu_set_batc_entry(cpu, entry_no, data, value)
a1047 1
	unsigned data;	/* 1 = data, 0 = instruction */
a1050 7
	m8820x_cmmu_set(CMMU_BWP(entry_no), value, MODE_VAL|ACCESS_VAL,
		      cpu, data, CMMU_ACS_USER, 0);
#ifdef SHADOW_BATC
	CMMU(cpu,data)->batc[entry_no] = value;
#endif
	CMMU_UNLOCK;
}
d1052 2
a1053 12
/*
 * Set batc entry number entry_no to value in 
 * the data and instruction cache for the named CPU.
 */
void
m8820x_cmmu_set_pair_batc_entry(cpu, entry_no, value)
	unsigned cpu, entry_no;
	unsigned value;	/* the value to stuff into the batc */
{
	CMMU_LOCK;
	m8820x_cmmu_set(CMMU_BWP(entry_no), value, MODE_VAL|ACCESS_VAL,
		      cpu, DATA_CMMU, CMMU_ACS_USER, 0);
d1057 2
a1058 2
	m8820x_cmmu_set(CMMU_BWP(entry_no), value, MODE_VAL|ACCESS_VAL,
		      cpu, INST_CMMU, CMMU_ACS_USER, 0);
d1075 2
a1076 4
m8820x_cmmu_flush_remote_tlb(cpu, kernel, vaddr, size)
	unsigned cpu, kernel;
	vm_offset_t vaddr;
	int size;
d1078 2
a1079 1
	register int s = splhigh();
d1082 14
a1095 2
	if (cpu > max_cpus) {
		cpu = cpu_number();
a1097 9
	if ((unsigned)size > PAGE_SIZE) {
		m8820x_cmmu_set(CMMU_SCR, kernel ? CMMU_FLUSH_SUPER_ALL : CMMU_FLUSH_USER_ALL, ACCESS_VAL,
			      cpu, 0, kernel ? CMMU_ACS_SUPER : CMMU_ACS_USER, 0);
	} else { /* a page or smaller */
		m8820x_cmmu_set(CMMU_SAR, vaddr, ADDR_VAL|ACCESS_VAL,
			      cpu, 0, kernel ? CMMU_ACS_SUPER : CMMU_ACS_USER, vaddr);
		m8820x_cmmu_set(CMMU_SCR, kernel ? CMMU_FLUSH_SUPER_PAGE : CMMU_FLUSH_USER_PAGE, ADDR_VAL|ACCESS_VAL,
			      cpu, 0, kernel ? CMMU_ACS_SUPER : CMMU_ACS_USER, vaddr);
	}
d1106 1
a1106 4
m8820x_cmmu_flush_tlb(kernel, vaddr, size)
	unsigned kernel;
	vm_offset_t vaddr;
	int size;
d1108 1
a1108 2
	int cpu;
	cpu = cpu_number();
d1115 1
a1115 1
 * Only called from pmap.c's _pmap_activate().
d1124 1
d1148 2
a1149 1
		      cpu, 0, CMMU_ACS_USER, 0);
d1165 2
d1173 1
a1173 4
m8820x_cmmu_flush_remote_cache(cpu, physaddr, size)
	int cpu;
	vm_offset_t physaddr;
	int size;
d1175 1
a1175 1
	register int s = splhigh();
d1179 1
a1179 2

	if (size < 0 || size > NBSG ) {
d1181 1
a1181 1
			      cpu, 0, 0, 0);
d1184 3
a1186 3
			      cpu, 0, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_LINE , ADDR_VAL,
			      cpu, 0, 0, (unsigned)physaddr);
d1189 3
a1191 3
			      cpu, 0, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_PAGE , ADDR_VAL,
			      cpu, 0, 0, (unsigned)physaddr);
d1194 1
a1194 1
			      cpu, 0, 0, 0);
d1196 1
a1196 1
			      cpu, 0, 0, 0);
a1197 1

d1200 1
a1200 1
		      cpu, 0, 0, 0);
d1202 1
d1211 1
a1211 3
m8820x_cmmu_flush_cache(physaddr, size)
	vm_offset_t physaddr;
	int size;
d1221 1
a1221 4
m8820x_cmmu_flush_remote_inst_cache(cpu, physaddr, size)
	int cpu;
	vm_offset_t physaddr;
	int size;
d1223 1
a1223 1
	register int s = splhigh();
d1227 1
a1227 1
	if (size < 0 || size > NBSG ) {
d1229 1
a1229 1
			      cpu, INST_CMMU, 0, 0);
d1231 4
a1234 5

		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_LINE, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
d1236 4
a1239 4
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_PAGE, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
d1241 4
a1244 4
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_SEGMENT, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
d1248 1
a1248 1
		      cpu, INST_CMMU, 0, 0);
d1259 1
a1259 3
m8820x_cmmu_flush_inst_cache(physaddr, size)
	vm_offset_t physaddr;
	int size;
d1261 1
a1261 2
	int cpu;
	cpu = cpu_number();
d1266 1
a1266 4
m8820x_cmmu_flush_remote_data_cache(cpu, physaddr, size)
	int cpu;
	vm_offset_t physaddr;
	int size;
d1268 1
a1268 1
	register int s = splhigh();
d1272 1
a1272 2
	if (size < 0 || size > NBSG ) {

d1274 1
a1274 1
			      cpu, DATA_CMMU, 0, 0);
d1276 4
a1279 5
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_LINE, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);

d1281 4
a1284 4
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_PAGE, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
d1286 4
a1289 4
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_SEGMENT, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
d1293 1
a1293 1
		      cpu, DATA_CMMU, 0, 0);
d1295 1
d1302 1
a1302 1
 */ 
d1304 3
a1306 6
m8820x_cmmu_flush_data_cache(physaddr, size)
	vm_offset_t physaddr;
	int size;
{ 
	int cpu;
	cpu = cpu_number();
d1314 1
a1314 3
m8820x_cmmu_sync_cache(physaddr, size)
	vm_offset_t physaddr;
	int size;
d1316 3
a1318 3
	register int s = splhigh();
	int cpu;
	
a1319 1
	cpu = cpu_number();
d1322 1
a1322 1
	if (size < 0 || size > NBSG ) {
d1324 1
a1324 1
			      cpu, DATA_CMMU, 0, 0);
d1326 1
a1326 1
			      cpu, INST_CMMU, 0, 0);
d1328 8
a1335 8
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_LINE, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_LINE, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
d1337 8
a1344 8
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_PAGE, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_PAGE, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
d1346 8
a1353 8
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_SEGMENT, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_SEGMENT, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
d1357 1
a1357 1
		      cpu, DATA_CMMU, 0, 0);
d1359 1
a1359 1
		      cpu, INST_CMMU, 0, 0);
d1361 2
a1363 1
	CMMU_UNLOCK;
d1366 2
a1367 4
void 
m8820x_cmmu_sync_inval_cache(physaddr, size)
	vm_offset_t physaddr;
	int size;
d1369 3
a1371 3
	register int s = splhigh();
	int cpu;
	cpu = cpu_number();
d1375 1
a1375 1
	if (size < 0 || size > NBSG ) {
d1377 1
a1377 1
			      cpu, DATA_CMMU, 0, 0);
d1379 1
a1379 1
			      cpu, INST_CMMU, 0, 0);
d1381 8
a1388 8
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_LINE, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_LINE, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
d1390 8
a1397 8
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_PAGE, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_PAGE, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
d1399 8
a1406 8
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_SEGMENT, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_SEGMENT, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
a1407 1

d1410 1
a1410 1
		      cpu, DATA_CMMU, 0, 0);
d1412 1
a1412 1
		      cpu, INST_CMMU, 0, 0);
d1414 1
d1420 1
a1420 3
m8820x_cmmu_inval_cache(physaddr, size)
	vm_offset_t physaddr;
	int size;
d1422 3
a1424 3
	register int s = splhigh();
	int cpu;
	cpu = cpu_number();
d1428 1
a1428 1
	if (size < 0 || size > NBSG ) {
d1430 1
a1430 1
			      cpu, DATA_CMMU, 0, 0);
d1432 1
a1432 1
			      cpu, INST_CMMU, 0, 0);
d1434 8
a1441 8
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_LINE, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_LINE, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
d1443 8
a1450 8
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_PAGE, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_PAGE, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
d1452 8
a1459 8
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_SEGMENT, MODE_VAL,
			      cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr, MODE_VAL|ADDR_VAL,
			      cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_SEGMENT, MODE_VAL,
			      cpu, DATA_CMMU, 0, 0);
d1463 1
a1463 1
		      cpu, DATA_CMMU, 0, 0);
d1465 1
a1465 1
		      cpu, INST_CMMU, 0, 0);
d1467 1
d1473 1
a1473 3
m8820x_dma_cachectl(va, size, op)
	vm_offset_t va;
	int size, op;
d1476 1
a1476 1
	int count;
d1478 2
a1479 2
	while (size) {
		count = NBPG - ((int)va & PGOFSET);
d1484 2
a1485 1
		if (op == DMA_CACHE_SYNC)
d1487 2
a1488 1
		else if (op == DMA_CACHE_SYNC_INVAL)
d1490 2
a1491 1
		else
d1493 2
d1496 1
a1496 1
		va = (vm_offset_t)((int)va + count);
d1500 2
a1501 2

	if (op == DMA_CACHE_SYNC)
d1503 2
a1504 1
	else if (op == DMA_CACHE_SYNC_INVAL)
d1506 2
a1507 1
	else
d1509 2
d1610 1
a1610 1
		DEBUG_MSG("-------------------------------------------\n");
d1615 4
a1618 15
#if 0 /* no thread */
	if (thread != 0) {
		/* the following tidbit from pmap_activate() */
		supervisor_flag = 0; /* thread implies user */

		if (thread->task == 0) {
			DEBUG_MSG("[thread %x has empty task pointer]\n", thread);
			return;
		} else if (thread->task->map == 0) {
			DEBUG_MSG("[thread/task %x/%x has empty map pointer]\n",
				  thread, thread->task);
			return;
		} else if (thread->task->map->pmap == 0) {
			DEBUG_MSG("[thread/task/map %x/%x/%x has empty pmap pointer]\n",
				  thread, thread->task, thread->task->map);
d1621 7
a1627 28
		if (thread->task->map->pmap->lock.lock_data) {
			DEBUG_MSG("[Warning: thread %x's task %x's map %x's "
				  "pmap %x is locked]\n", thread, thread->task,
				  thread->task->map, thread->task->map->pmap);
		}
		value = CACHE_GLOBAL | APR_V |
		    (atop(thread->task->map->pmap->sdt_paddr) << PG_SHIFT);
		if (verbose_flag) {
			DEBUG_MSG("[thread %x task %x map %x pmap %x UAPR is %x]\n",
				  thread, thread->task, thread->task->map,
				  thread->task->map->pmap, value);
		}
	} else
#endif /* 0 */
	{
		if (cmmu_num == -1) {
			int cpu = cpu_number();
			if (cpu_cmmu[cpu].pair[DATA_CMMU] == 0) {
				DEBUG_MSG("ack! can't figure my own data cmmu number.\n");
				return;
			}
			cmmu_num = cpu_cmmu[cpu].pair[DATA_CMMU] - m8820x_cmmu;
			if (verbose_flag)
				DEBUG_MSG("The data cmmu for cpu#%d is cmmu#%d.\n",
					  0, cmmu_num);
		} else if (cmmu_num < 0 || cmmu_num >= MAX_CMMUS) {
			DEBUG_MSG("invalid cpu number [%d]... must be in range [0..%d]\n",
				  cmmu_num, MAX_CMMUS - 1);
d1629 2
a1630 2
			return;
		}
d1632 2
a1633 2
		if (m8820x_cmmu[cmmu_num].cmmu_alive == 0) {
			DEBUG_MSG("warning: cmmu %d is not alive.\n", cmmu_num);
d1635 1
a1635 1
			return;
d1637 1
a1637 1
		}
d1639 14
a1652 14
		if (!verbose_flag) {
			if (!(m8820x_cmmu[cmmu_num].cmmu_regs->sctr & CMMU_SCTR_SE))
				DEBUG_MSG("WARNING: snooping not enabled for CMMU#%d.\n",
					  cmmu_num);
		} else {
			int i;
			for (i=0; i<MAX_CMMUS; i++)
				if ((i == cmmu_num || m8820x_cmmu[i].cmmu_alive) &&
				    (verbose_flag>1 || !(m8820x_cmmu[i].cmmu_regs->sctr&CMMU_SCTR_SE))) {
					DEBUG_MSG("CMMU#%d (cpu %d %s) snooping %s\n", i,
						  m8820x_cmmu[i].cmmu_cpu, m8820x_cmmu[i].which ? "data" : "inst",
						  (m8820x_cmmu[i].cmmu_regs->sctr & CMMU_SCTR_SE) ? "on":"OFF");
				}
		}
d1654 4
a1657 6
		if (supervisor_flag)
			value = m8820x_cmmu[cmmu_num].cmmu_regs->sapr;
		else
			value = m8820x_cmmu[cmmu_num].cmmu_regs->uapr;

	}
a1658 2
	/******* LOOK AT THE BATC ** (if not a thread) **************/
#if 0
d1660 1
a1660 1
	if (thread == 0) {
d1667 1
a1667 1
					DEBUG_MSG("cmmu #%d batc[%d] invalid.\n", cmmu_num, i);
d1669 1
a1669 1
				DEBUG_MSG("cmmu#%d batc[%d] v%08x p%08x", cmmu_num, i,
d1671 5
a1675 5
				if (batc.field.s)  DEBUG_MSG(", supervisor");
				if (batc.field.wt) DEBUG_MSG(", wt.th");
				if (batc.field.g)  DEBUG_MSG(", global");
				if (batc.field.ci) DEBUG_MSG(", cache inhibit");
				if (batc.field.wp) DEBUG_MSG(", write protect");
a1679 1
#endif	/* 0 */
a1681 3
#if 0
	if (thread == 0)
#endif /* 0 */
d1689 1
a1689 1
			DEBUG_MSG("probe of 0x%08x returns ssr=0x%08x\n",
d1692 1
a1692 1
			DEBUG_MSG("PROBE of 0x%08x returns phys=0x%x",
d1695 12
a1706 12
			DEBUG_MSG("PROBE fault at 0x%x", cmmu_regs->pfADDRr);
		if (ssr.field.ce) DEBUG_MSG(", copyback err");
		if (ssr.field.be) DEBUG_MSG(", bus err");
		if (ssr.field.wt) DEBUG_MSG(", writethrough");
		if (ssr.field.sp) DEBUG_MSG(", sup prot");
		if (ssr.field.g)  DEBUG_MSG(", global");
		if (ssr.field.ci) DEBUG_MSG(", cache inhibit");
		if (ssr.field.m)  DEBUG_MSG(", modified");
		if (ssr.field.u)  DEBUG_MSG(", used");
		if (ssr.field.wp) DEBUG_MSG(", write prot");
		if (ssr.field.bh) DEBUG_MSG(", BATC");
		DEBUG_MSG(".\n");
d1712 2
a1713 8
			DEBUG_MSG("CMMU#%d", cmmu_num);
#if 0
			if (thread == 0)
				DEBUG_MSG("CMMU#%d", cmmu_num);
			else
				DEBUG_MSG("THREAD %x", thread);
#endif /* 0 */
			DEBUG_MSG(" %cAPR is 0x%08x\n",
d1716 2
a1717 8
		DEBUG_MSG("CMMU#%d", cmmu_num);
#if 0
		if (thread == 0)
			DEBUG_MSG("CMMU#%d", cmmu_num);
		else
			DEBUG_MSG("THREAD %x", thread);
#endif /* 0 */
		DEBUG_MSG(" %cAPR: SegTbl: 0x%x000p",
d1720 1
a1720 1
			DEBUG_MSG(", WTHRU");
d1722 1
a1722 1
			DEBUG_MSG(", GLOBAL");
d1724 1
a1724 1
			DEBUG_MSG(", INHIBIT");
d1726 2
a1727 2
			DEBUG_MSG(", VALID");
		DEBUG_MSG("\n");
d1731 1
a1731 1
			DEBUG_MSG("<would report an error, valid bit not set>\n");
d1741 1
a1741 1
		DEBUG_MSG("[%x physical is %x virtual]\n", value, value + VEQR_ADDR);
d1750 1
a1750 1
			DEBUG_MSG("will follow to entry %d of page at 0x%x...\n",
d1755 2
a1756 2
		if (badwordaddr((vm_offset_t)value)) {
			DEBUG_MSG("ERROR: unable to access page at 0x%08x.\n", value);
d1762 2
a1763 2
			DEBUG_MSG("SEG DESC @@0x%x is 0x%08x\n", value, sdt);
		DEBUG_MSG("SEG DESC @@0x%x: PgTbl: 0x%x000",
d1765 13
a1777 13
		if (sdt & CACHE_WT)		    DEBUG_MSG(", WTHRU");
		else				    DEBUG_MSG(", !wthru");
		if (sdt & SG_SO)		    DEBUG_MSG(", S-PROT");
		else				    DEBUG_MSG(", UserOk");
		if (sdt & CACHE_GLOBAL)		    DEBUG_MSG(", GLOBAL");
		else				    DEBUG_MSG(", !global");
		if (sdt & CACHE_INH)		    DEBUG_MSG(", $INHIBIT");
		else				    DEBUG_MSG(", $ok");
		if (sdt & SG_PROT)		    DEBUG_MSG(", W-PROT");
		else				    DEBUG_MSG(", WriteOk");
		if (sdt & SG_V)			    DEBUG_MSG(", VALID");
		else				    DEBUG_MSG(", !valid");
		DEBUG_MSG(".\n");
d1781 1
a1781 1
			DEBUG_MSG("<would report an error, STD entry not valid>\n");
d1790 1
a1790 1
		DEBUG_MSG("[%x physical is %x virtual]\n", value, value + VEQR_ADDR);
d1797 1
a1797 1
			DEBUG_MSG("will follow to entry %d of page at 0x%x...\n",
d1802 2
a1803 2
		if (badwordaddr((vm_offset_t)value)) {
			DEBUG_MSG("error: unable to access page at 0x%08x.\n", value);
d1810 2
a1811 2
			DEBUG_MSG("PAGE DESC @@0x%x is 0x%08x.\n", value, pte);
		DEBUG_MSG("PAGE DESC @@0x%x: page @@%x000",
d1813 19
a1831 19
		if (pte & PG_W)			DEBUG_MSG(", WIRE");
		else				DEBUG_MSG(", !wire");
		if (pte & CACHE_WT)		DEBUG_MSG(", WTHRU");
		else				DEBUG_MSG(", !wthru");
		if (pte & PG_SO)		DEBUG_MSG(", S-PROT");
		else				DEBUG_MSG(", UserOk");
		if (pte & CACHE_GLOBAL)		DEBUG_MSG(", GLOBAL");
		else				DEBUG_MSG(", !global");
		if (pte & CACHE_INH)		DEBUG_MSG(", $INHIBIT");
		else				DEBUG_MSG(", $ok");
		if (pte & PG_M)			DEBUG_MSG(", MOD");
		else				DEBUG_MSG(", !mod");
		if (pte & PG_U)			DEBUG_MSG(", USED");
		else				DEBUG_MSG(", !used");
		if (pte & PG_PROT)		DEBUG_MSG(", W-PROT");
		else				DEBUG_MSG(", WriteOk");
		if (pte & PG_V)			DEBUG_MSG(", VALID");
		else				DEBUG_MSG(", !valid");
		DEBUG_MSG(".\n");
d1835 1
a1835 1
			DEBUG_MSG("<would report an error, PTE entry not valid>\n");
d1841 1
a1841 1
			DEBUG_MSG("will follow to byte %d of page at 0x%x...\n",
d1845 2
a1846 2
		if (badwordaddr((vm_offset_t)value)) {
			DEBUG_MSG("error: unable to access page at 0x%08x.\n", value);
d1853 1
a1853 1
		DEBUG_MSG("[%x physical is %x virtual]\n", value, value + VEQR_ADDR);
d1856 1
a1856 56
	DEBUG_MSG("WORD at 0x%x is 0x%08x.\n", value, *(unsigned *)value);

}

void
m8820x_cmmu_cache_state(addr, supervisor_flag)
	unsigned addr, supervisor_flag;
{
	static char *vv_name[4] =
	{"exclu-unmod", "exclu-mod", "shared-unmod", "invalid"};
	int cmmu_num;

	for (cmmu_num = 0; cmmu_num < MAX_CMMUS; cmmu_num++) {
		union ssr ssr;
		union cssp cssp;
		struct cmmu_regs *R;
		unsigned tag, line;
		if (!m8820x_cmmu[cmmu_num].cmmu_alive)
			continue;
		R = m8820x_cmmu[cmmu_num].cmmu_regs;
		DEBUG_MSG("cmmu #%d %s cmmu for cpu %d.\n", cmmu_num,
			  m8820x_cmmu[cmmu_num].which ? "data" : "inst", 
			  m8820x_cmmu[cmmu_num].cmmu_cpu);
		R->sar = addr;
		R->scr = supervisor_flag ? CMMU_PROBE_SUPER : CMMU_PROBE_USER;

		ssr.bits = R->ssr;
		if (!ssr.field.v) {
			DEBUG_MSG("PROBE of 0x%08x faults.\n",addr);
			continue;
		}
		DEBUG_MSG("PROBE of 0x%08x returns phys=0x%x", addr, R->sar);

		tag = R->sar & ~0xfff;
		cssp.bits = R->cssp;

		/* check to see if any of the tags for the set match the address */
		for (line = 0; line < 4; line++) {
			if (VV(cssp, line) == VV_INVALID) {
				DEBUG_MSG("line %d invalid.\n", line);
				continue; /* line is invalid */
			}
			if (D(cssp, line)) {
				DEBUG_MSG("line %d disabled.\n", line);
				continue; /* line is disabled */
			}

			if ((R->ctp[line] & ~0xfff) != tag) {
				DEBUG_MSG("line %d address tag is %x.\n", line,
					  (R->ctp[line] & ~0xfff));
				continue;
			}
			DEBUG_MSG("found in line %d as %08x (%s).\n",
				  line, R->cdp[line], vv_name[VV(cssp, line)]);
		}
	}
a1858 17

void
m8820x_show_cmmu_info(addr)
	unsigned addr;
{
	int cmmu_num;
	m8820x_cmmu_cache_state(addr, 1);

	for (cmmu_num = 0; cmmu_num < MAX_CMMUS; cmmu_num++)
		if (m8820x_cmmu[cmmu_num].cmmu_alive) {
			DEBUG_MSG("cmmu #%d %s cmmu for cpu %d: ", cmmu_num,
				  m8820x_cmmu[cmmu_num].which ? "data" : "inst", 
				  m8820x_cmmu[cmmu_num].cmmu_cpu);
			m8820x_cmmu_show_translation(addr, 1, 0, cmmu_num);
		}
}

@


1.19
log
@Death to the bitfields, this time cmmu_apr_t and batc_entry_t. In the
process, remove duplicate batc defines.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.18 2003/09/16 20:53:41 miod Exp $	*/
d950 2
a951 2
		tmp = ((0x00000 << PG_BITS) | AREA_D_WT | AREA_D_G | AREA_D_CI)
		    & ~AREA_D_TE;
@


1.18
log
@Do not use | !FOO to mention undesirable flags, but rather & ~FOO - hopefully
this had no side effects...
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.17 2003/09/16 20:46:11 miod Exp $	*/
d223 9
a231 9
	union apr_template apr_template;
	apr_template.bits = value;

	printf("table @@ 0x%x000", apr_template.field.st_base);
	if (apr_template.field.wt) printf(", writethrough");
	if (apr_template.field.g)  printf(", global");
	if (apr_template.field.ci) printf(", cache inhibit");
	if (apr_template.field.te) printf(", valid");
	else			   printf(", not valid");
d1219 2
a1220 2
	batc_template_t i_batc[BATC_MAX];
	batc_template_t d_batc[BATC_MAX];
d1230 4
a1233 4
		m8820x_cmmu_set(CMMU_BWP(entry_no), i_batc[entry_no].bits, MODE_VAL|ACCESS_VAL,
			      cpu, INST_CMMU, CMMU_ACS_USER, 0);
		m8820x_cmmu_set(CMMU_BWP(entry_no), d_batc[entry_no].bits, MODE_VAL|ACCESS_VAL,
			      cpu, DATA_CMMU, CMMU_ACS_USER, 0);
d1235 2
a1236 2
		CMMU(cpu,INST_CMMU)->batc[entry_no] = i_batc[entry_no].bits;
		CMMU(cpu,DATA_CMMU)->batc[entry_no] = d_batc[entry_no].bits;
d1720 1
a1720 1
	unsigned value;
d1730 1
a1730 2
		/* the following tidbit from _pmap_activate in m88k/pmap.c */
		register apr_template_t apr_data;
d1750 2
a1751 7
		apr_data.bits = 0;
		apr_data.field.st_base = atop(thread->task->map->pmap->sdt_paddr);
		apr_data.field.wt = 0;
		apr_data.field.g  = 1;
		apr_data.field.ci = 0;
		apr_data.field.te = 1;
		value = apr_data.bits;
a1863 2
		union apr_template apr_template;
		apr_template.bits = value;
d1873 1
a1873 1
				  supervisor_flag ? 'S' : 'U', apr_template.bits);
d1883 10
a1892 10
			  supervisor_flag ? 'S' : 'U', apr_template.field.st_base);
		if (apr_template.field.wt) DEBUG_MSG(", WTHRU");
		else			   DEBUG_MSG(", !wthru");
		if (apr_template.field.g)  DEBUG_MSG(", GLOBAL");
		else			   DEBUG_MSG(", !global");
		if (apr_template.field.ci) DEBUG_MSG(", $INHIBIT");
		else			   DEBUG_MSG(", $ok");
		if (apr_template.field.te) DEBUG_MSG(", VALID");
		else			   DEBUG_MSG(", !valid");
		DEBUG_MSG(".\n");
d1895 1
a1895 1
		if (apr_template.field.te == 0) {
d1901 1
a1901 1
		value = apr_template.field.st_base << PG_BITS; /* now point to seg page */
@


1.17
log
@Provide more information about the CPU/CMMU configuration in the dmesg
output. Also, if the board configuration parameter area is invalid, warn the
user and assume safe values - this is likely caused by a dead NVRAM battery.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.16 2003/08/21 20:45:43 miod Exp $	*/
d877 4
a880 4
			tmp =
			! CMMU_SCTR_PE |   /* not parity enable */
			! CMMU_SCTR_SE | /* not snoop enable */
			! CMMU_SCTR_PR ;  /* not priority arbitration */
d883 2
a884 6
			tmp =
			(0x00000 << PG_BITS) |  /* segment table base address */
			AREA_D_WT |	 /* write through */
			AREA_D_G  | /* global */
			AREA_D_CI | /* cache inhibit */
			! AREA_D_TE ;	/* not translation enable */
d925 1
a925 4
			tmp =
			! CMMU_SCTR_PE |  /* not parity enable */
			CMMU_SCTR_SE |	/* snoop enable */
			! CMMU_SCTR_PR ;  /* not priority arbitration */
d927 1
a927 3
			tmp =
			! CMMU_SCTR_PE |  /* not parity enable */
			! CMMU_SCTR_PR ;  /* not priority arbitration */
d950 2
a951 9
		tmp =
		(0x00000 << PG_BITS) | /* segment table base address */
		AREA_D_WT |	  /* write through */
		AREA_D_G  |	  /* global */
		AREA_D_CI |	  /* cache inhibit */
		! AREA_D_TE ;	  /* not translation enable */
		/*
		REGS(cpu, INST_CMMU).sapr = tmp;
		*/
a954 3
		/*
		REGS(cpu, DATA_CMMU).scr = CMMU_FLUSH_SUPER_ALL;
		*/
d975 1
a975 4
			tmp =
			! CMMU_SCTR_PE |   /* parity enable */
			! CMMU_SCTR_SE |   /* snoop enable */
			! CMMU_SCTR_PR ;   /* priority arbitration */
d977 1
a977 3
			tmp =
			! CMMU_SCTR_PE |   /* parity enable */
			! CMMU_SCTR_PR ;   /* priority arbitration */
d982 2
a983 6
		tmp = 
		(0x00000 << PG_BITS) |  /* segment table base address */
		! AREA_D_WT |	   /* write through */
		! AREA_D_G  |	   /* global */
		AREA_D_CI |	   /* cache inhibit */
		! AREA_D_TE ;	   /* translation disable */
d1023 1
a1023 1
#define ILLADDRESS	U(0x0F000000) 	/* any faulty address */
a1061 21
#if 0
/*
 * Functions that actually modify CMMU registers.
 */
void
m8820x_cmmu_remote_set(unsigned cpu, unsigned r, unsigned data, unsigned x)
{
	*(unsigned *volatile)(r + (char *)&REGS(cpu,data)) = x;
}

/*
 * cmmu_cpu_lock should be held when called if read
 * the CMMU_SCR or CMMU_SAR.
 */
unsigned
m8820x_cmmu_remote_get(unsigned cpu, unsigned r, unsigned data)
{
	return (*(unsigned *volatile)(r + (char *)&REGS(cpu,data)));
}
#endif 

a1135 4
#if 0 /* was for debugging piece (peace?) of mind */
	REGS(cpu,data).scr = CMMU_FLUSH_SUPER_ALL;
	REGS(cpu,data).scr = CMMU_FLUSH_USER_ALL;
#endif
a1159 6
#if 0  /* was for debugging piece (peace?) of mind */
	REGS(cpu,INST_CMMU).scr = CMMU_FLUSH_SUPER_ALL;
	REGS(cpu,INST_CMMU).scr = CMMU_FLUSH_USER_ALL;
	REGS(cpu,DATA_CMMU).scr = CMMU_FLUSH_SUPER_ALL;
	REGS(cpu,DATA_CMMU).scr = CMMU_FLUSH_USER_ALL;
#endif
@


1.16
log
@Be less verbose in the MVME187 probe, as its CMMU configuration is known
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.15 2003/08/09 21:19:59 miod Exp $	*/
d774 7
a780 6
	printf("Processor %d: ", cpu);
	if (proctype)
		printf("Architectural Revision 0x%x UNKNOWN CPU TYPE Version 0x%x\n",
		       proctype, procvers);
	else
		printf("M88100 Version 0x%x\n", procvers);
d782 4
a785 3
#ifndef ERRATA__XXX_USR
	if (procvers < 2)
		printf("WARNING: M88100 bug workaround code not enabled!!!\n");
d787 1
d789 2
a790 1
	for (mmu = cpu*cpu_cmmu_ratio; mmu < (cpu+1)*cpu_cmmu_ratio; mmu++) {
d793 6
a799 6
		printf(" %s %s Cache: ",
		       (m8820x_cmmu[mmu].cmmu_access == CMMU_ACS_BOTH) ?  "Spv and User" :
		       ((m8820x_cmmu[mmu].cmmu_access == CMMU_ACS_USER) ? "User        " :
			"Supervisor  "),
		       (m8820x_cmmu[mmu].which == INST_CMMU) ?   "Instruction" :
		       "Data       ");
d801 1
a801 1
			printf("Type 0x%x ", mmuid);
d803 19
a821 2
			printf("%s ", mmutypes[mmuid]);
		printf("Version 0x%x\n", (idr & 0x1f0000)>>16);
d823 1
a823 1
	printf  (" Configured as %s and started\n", master ? "master" : "slave");
@


1.15
log
@New RAMDISK configuration, inspired by the mvme68k one; and the associated
fixes to get the kernel to compile without option DDB and without
option DIAGNOSTIC.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.14 2002/03/14 03:15:57 millert Exp $	*/
a59 1
#ifdef M88100
d378 7
a384 10
	switch (bd_config[vme188_config].supported) {
	case 0:
		printf("MVME%x board configuration #%X: %d CPUs %d CMMUs\n", brdtyp, 
		       vme188_config, max_cpus, max_cmmus);
		panic("This configuration is not supported - go and get another OS.");
		/* NOTREACHED */
		break;
	case 1:
		printf("MVME%x board configuration #%X: %d CPUs %d CMMUs\n", brdtyp,
		       vme188_config, max_cpus, max_cmmus);
d386 4
a389 5
		break;
	default:
		panic("UNKNOWN MVME%x board configuration: WHOAMI = 0x%02x", brdtyp, *whoami);
		/* NOTREACHED */
		break;
a390 1
	return;
a602 1
	return;
a2142 1
#endif /* M88100 */
@


1.14
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.13 2002/03/14 01:26:40 millert Exp $	*/
a2132 2
#endif /* DDB */

d2149 1
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.12 2002/01/14 21:34:41 miod Exp $	*/
d667 1
a667 1
	*(unsigned *volatile)(reg + (char*)(m8820x_cmmu[mmu].cmmu_regs)) = val;
d681 1
a681 1
	return *(unsigned *volatile)(reg + (char*)(m8820x_cmmu[mmu].cmmu_regs));
d1083 1
a1083 1
	*(unsigned *volatile)(r + (char*)&REGS(cpu,data)) = x;
d1093 1
a1093 1
	return (*(unsigned *volatile)(r + (char*)&REGS(cpu,data)));
@


1.12
log
@volatile police.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.11 2001/12/24 17:18:39 miod Exp $	*/
d212 7
a218 7
unsigned m8820x_cmmu_get __P((int mmu, int reg));
void m8820x_cmmu_store __P((int, int, unsigned));
void m8820x_cmmu_set __P((int, unsigned, int, int, int, int, vm_offset_t));
void m8820x_cmmu_sync_cache __P((vm_offset_t, int));
void m8820x_cmmu_sync_inval_cache __P((vm_offset_t, int));
void m8820x_cmmu_inval_cache __P((vm_offset_t, int));
int m8820x_cmmu_alive __P((int));
@


1.12.2.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d212 7
a218 7
unsigned m8820x_cmmu_get(int mmu, int reg);
void m8820x_cmmu_store(int, int, unsigned);
void m8820x_cmmu_set(int, unsigned, int, int, int, int, vm_offset_t);
void m8820x_cmmu_sync_cache(vm_offset_t, int);
void m8820x_cmmu_sync_inval_cache(vm_offset_t, int);
void m8820x_cmmu_inval_cache(vm_offset_t, int);
int m8820x_cmmu_alive(int);
d667 1
a667 1
	*(unsigned *volatile)(reg + (char *)(m8820x_cmmu[mmu].cmmu_regs)) = val;
d681 1
a681 1
	return *(unsigned *volatile)(reg + (char *)(m8820x_cmmu[mmu].cmmu_regs));
d1083 1
a1083 1
	*(unsigned *volatile)(r + (char *)&REGS(cpu,data)) = x;
d1093 1
a1093 1
	return (*(unsigned *volatile)(r + (char *)&REGS(cpu,data)));
@


1.12.2.2
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a2 24
 * Copyright (c) 2004, Miodrag Vallat.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*
d33 1
d60 1
d63 1
d69 1
a73 3
#include <machine/m8820x.h>

#include <uvm/uvm_extern.h>
d77 3
a81 5
/*
 * On some versions of the 88200, page size flushes don't work. I am using
 * sledge hammer approach till I find for sure which ones are bad XXX nivas
 */
#define BROKEN_MMU_MASK
d83 3
a85 1
#undef	SHADOW_BATC		/* don't use BATCs for now XXX nivas */
d88 3
a90 2
unsigned int m8820x_debuglevel;
#define dprintf(_X_) \
d92 1
a92 1
		if (m8820x_debuglevel != 0) { \
d100 3
a102 22
#define dprintf(_X_) do { } while (0)
#endif

void m8820x_cmmu_init(void);
void m8820x_setup_board_config(void);
void m8820x_cpu_configuration_print(int);
void m8820x_cmmu_shutdown_now(void);
void m8820x_cmmu_parity_enable(void);
unsigned m8820x_cmmu_cpu_number(void);
void m8820x_cmmu_set_sapr(unsigned, unsigned);
void m8820x_cmmu_set_uapr(unsigned);
void m8820x_cmmu_set_pair_batc_entry(unsigned, unsigned, unsigned);
void m8820x_cmmu_flush_tlb(unsigned, unsigned, vaddr_t, vsize_t);
void m8820x_cmmu_pmap_activate(unsigned, unsigned,
    u_int32_t i_batc[BATC_MAX], u_int32_t d_batc[BATC_MAX]);
void m8820x_cmmu_flush_cache(int, paddr_t, psize_t);
void m8820x_cmmu_flush_inst_cache(int, paddr_t, psize_t);
void m8820x_cmmu_flush_data_cache(int, paddr_t, psize_t);
void m8820x_dma_cachectl(vaddr_t, vsize_t, int);
void m8820x_cmmu_dump_config(void);
void m8820x_cmmu_show_translation(unsigned, unsigned, unsigned, int);
void m8820x_show_apr(unsigned);
d107 1
d109 2
d115 1
d117 1
d119 1
d121 1
d124 1
d126 1
d128 1
d132 1
a132 1
	m8820x_cmmu_dump_config,
d134 51
a184 3
#else
	NULL,
	NULL,
d186 6
a191 4
#ifdef DEBUG
	m8820x_show_apr,
#else
	NULL,
a192 1
};
d195 45
a239 2
 * This code was initially designed for the Omron Luna 88K layout consisting
 * of up to 4 CPUs with 2 CMMUs each, one for data and one for instructions.
d242 1
a242 1
 * Motorola MVME188, we have the following layouts:
d251 1
a251 1
 * We use these splitup schemes:
d261 6
d270 2
a271 52
 * CMMU kernel information
 */
struct m8820x_cmmu {
	unsigned *volatile cmmu_regs;	/* CMMU "base" area */
	unsigned int	cmmu_cpu;	/* cpu number it is attached to */
	unsigned int	cmmu_type;
#define	INST_CMMU	0
#define	DATA_CMMU	1
	unsigned int	cmmu_access;
#define	CMMU_ACS_USER	0
#define	CMMU_ACS_SUPER	1
#define	CMMU_ACS_BOTH	2
	unsigned int	cmmu_alive;
#define CMMU_DEAD	0		/* This cmmu is not there */
#define CMMU_AVAILABLE	1		/* It's there, but which cpu's? */
#define CMMU_MARRIED	2		/* Know which cpu it belongs to. */
	vaddr_t		cmmu_addr;	/* address range */
	vaddr_t		cmmu_addr_mask;	/* address mask */
	int		cmmu_addr_match;/* return value of address comparison */
#ifdef SHADOW_BATC
	unsigned batc[BATC_MAX];
#endif
};

#ifdef SHADOW_BATC
/* CMMU(cpu,data) is the cmmu struct for the named cpu's indicated cmmu.  */
#define CMMU(cpu, data) cpu_cmmu[(cpu)].pair[(data) ? DATA_CMMU : INST_CMMU]
#endif

/*
 * Structure for accessing MMUS properly
 */

struct m8820x_cmmu m8820x_cmmu[MAX_CMMUS] =
{
	/* address, cpu, mode, access, alive, addr, mask */
	{(unsigned *volatile)VME_CMMU_I0, -1, INST_CMMU, CMMU_ACS_BOTH, CMMU_DEAD, 0, 0},
	{(unsigned *volatile)VME_CMMU_D0, -1, DATA_CMMU, CMMU_ACS_BOTH, CMMU_DEAD, 0, 0},
	{(unsigned *volatile)VME_CMMU_I1, -1, INST_CMMU, CMMU_ACS_BOTH, CMMU_DEAD, 0, 0},
	{(unsigned *volatile)VME_CMMU_D1, -1, DATA_CMMU, CMMU_ACS_BOTH, CMMU_DEAD, 0, 0},
	{(unsigned *volatile)VME_CMMU_I2, -1, INST_CMMU, CMMU_ACS_BOTH, CMMU_DEAD, 0, 0},
	{(unsigned *volatile)VME_CMMU_D2, -1, DATA_CMMU, CMMU_ACS_BOTH, CMMU_DEAD, 0, 0},
	{(unsigned *volatile)VME_CMMU_I3, -1, INST_CMMU, CMMU_ACS_BOTH, CMMU_DEAD, 0, 0},
	{(unsigned *volatile)VME_CMMU_D3, -1, DATA_CMMU, CMMU_ACS_BOTH, CMMU_DEAD, 0, 0}
};

struct cpu_cmmu {
	struct m8820x_cmmu *pair[2];
} cpu_cmmu[MAX_CPUS];

/*
 * CMMU per CPU split strategies
a272 8

#define	CMMU_SPLIT_ADDRESS	0x00
#define	CMMU_SPLIT_SPV		0x01
#define	CMMU_SPLIT_SRAM_SPV	0x02
#define	CMMU_SPLIT_SRAM_ALL	0x03

#define	CMMU_SPLIT_MASK		0x03

d278 4
a281 4
	{ CMMU_SPLIT_SPV,      CMMU_SPLIT_SPV}, 	/* CPU 0 */
	{ CMMU_SPLIT_SPV,      CMMU_SPLIT_SPV}, 	/* CPU 1 */
	{ CMMU_SPLIT_ADDRESS,  CMMU_SPLIT_ADDRESS},	/* CPU 2 */
	{ CMMU_SPLIT_ADDRESS,  CMMU_SPLIT_ADDRESS}	/* CPU 3 */
a283 3
unsigned int cmmu_shift;

#ifdef MVME188
d285 2
a286 2
 * The following list describes the different MVME188 configurations
 * which are supported by this code.
d288 2
a289 1
const struct board_config {
d292 19
a310 17
} bd_config[] = {
	{ 4, 8 },	/* 4P128 - 4P512 */
	{ 2, 8 },	/* 2P128 - 2P512 */
	{ 1, 8 },	/* 1P128 - 1P512 */
	{ 0, 0 },
	{ 0, 0 },
	{ 2, 4 },	/* 2P64  - 2P256 */
	{ 1, 4 },	/* 1P64  - 1P256 */
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 1, 2 },	/* 1P32  - 1P128 */
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 }
a311 1
#endif
d313 3
a315 11
/* local prototypes */
void m8820x_cmmu_set(int, unsigned, int, int, int, int, vaddr_t);
void m8820x_cmmu_wait(int);
void m8820x_cmmu_sync_cache(paddr_t, psize_t);
void m8820x_cmmu_sync_inval_cache(paddr_t, psize_t);
void m8820x_cmmu_inval_cache(paddr_t, psize_t);

/* Flags passed to m8820x_cmmu_set() */
#define MODE_VAL		0x01
#define ACCESS_VAL		0x02
#define ADDR_VAL		0x04
d317 1
a317 4
#ifdef DEBUG
void
m8820x_show_apr(value)
	unsigned value;
d319 23
a341 12
	printf("table @@ 0x%x000", PG_PFNUM(value));
	if (value & CACHE_WT)
		printf(", writethrough");
	if (value & CACHE_GLOBAL)
		printf(", global");
	if (value & CACHE_INH)
		printf(", cache inhibit");
	if (value & APR_V)
		printf(", valid");
	printf("\n");
}
#endif
d343 1
a343 4
/*
 * This routine sets up the CPU/CMMU configuration.
 */
void
d346 1
a346 9
	int num, cmmu_num;
	int vme188_config;
	unsigned *volatile cr;
#ifdef MVME188
	int val1, val2;
	u_int32_t *volatile whoami;
	unsigned long *volatile pcnfa;
	unsigned long *volatile pcnfb;
#endif
d352 1
a352 3
	case BRD_8120:
		/* There is no WHOAMI reg on MVME187 - fake it... */
		vme188_config = 10;
d369 1
a369 1
		whoami = (u_int32_t *volatile)MVME188_WHOAMI;
d371 1
a371 1
		dprintf(("m8820x_setup_board_config: WHOAMI @@ 0x%08x holds value 0x%08x vme188_config = %d\n",
d378 20
d399 13
a411 1
	cmmu_shift = ff1(max_cmmus / max_cpus);
d413 2
a414 14
#ifdef MVME188
	if (bd_config[vme188_config].ncpus > 0) {
		/* 187 has a fixed configuration, no need to print it */
		if (brdtyp == BRD_188) {
			printf("MVME188 board configuration #%X "
			    "(%d CPUs %d CMMUs)\n",
			    vme188_config, max_cpus, max_cmmus);
		}
	} else {
		panic("unsupported MVME%x board configuration "
		    "#%X (%d CPUs %d CMMUs)",
		    brdtyp, vme188_config, max_cpus, max_cmmus);
	}
#endif
d419 10
a428 11
	for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++) {
		cr = m8820x_cmmu[cmmu_num].cmmu_regs;
		if (badwordaddr((vaddr_t)cr) == 0) {
			int type;

			type = CMMU_TYPE(cr[CMMU_IDR]);
#ifdef DIAGNOSTIC
			if (type != M88200_ID && type != M88204_ID) {
				printf("WARNING: non M8820x circuit found "
				    "at CMMU address %p\n", cr);
				continue;	/* will probably die quickly */
d430 3
a432 4
#endif
			m8820x_cmmu[cmmu_num].cmmu_alive = CMMU_AVAILABLE;
			dprintf(("m8820x_setup_cmmu_config: CMMU %d found at %p\n",
			    cmmu_num, cr));
a433 1
	}
d435 4
a438 4
	/*
	 * Now that we know which CMMUs are there, let's report on which
	 * CPU/CMMU sets seem complete (hopefully all)
	 */
d440 2
a441 1
		int i, type;
d443 4
a446 5
		for (i = 0; i < (1 << cmmu_shift); i++) {
			dprintf(("cmmu_init: testing CMMU %d for CPU %d\n",
			    (num << cmmu_shift) | i, num));
#ifdef DIAGNOSTIC
			if (m8820x_cmmu[(num << cmmu_shift) | i].cmmu_alive == CMMU_DEAD) {
d448 2
a449 2
				    (num << cmmu_shift) | i, num);
				continue;	/* will probably die quickly */
a450 1
#endif
d453 1
a453 2
		type = CMMU_TYPE(m8820x_cmmu[num << cmmu_shift].
		    cmmu_regs[CMMU_IDR]);
d455 6
a460 2
		printf("CPU%d is attached with %d MC%x CMMUs\n",
		    num, 1 << cmmu_shift, type == M88204_ID ? 0x88204 : 0x88200);
d466 2
a467 2
		dprintf(("m8820x_setup_cmmu_config: CPU %d inst strat %d data strat %d\n",
		    num, cpu_cmmu_strategy[num].inst, cpu_cmmu_strategy[num].data));
d474 4
a477 6
#ifdef MVME188
	case 0x00:
	case 0x05:
#endif
	case 0x0a:
		dprintf(("m8820x_setup_cmmu_config: resetting strategies\n"));
d479 2
a480 2
			cpu_cmmu_strategy[num].inst = CMMU_SPLIT_ADDRESS;
			cpu_cmmu_strategy[num].data = CMMU_SPLIT_ADDRESS;
d486 1
a486 1
	case 0x01:
d489 2
a490 4
		val1 = (cpu_cmmu_strategy[0].inst << 2) |
		    cpu_cmmu_strategy[0].data;
		val2 = (cpu_cmmu_strategy[1].inst << 2) |
		    cpu_cmmu_strategy[1].data;
d493 1
a493 1
		dprintf(("m8820x_setup_cmmu_config: 2P128: PCNFA = 0x%x, PCNFB = 0x%x\n", val1, val2));
d495 1
a495 1
	case 0x02:
d498 2
a499 4
		val1 = (cpu_cmmu_strategy[0].inst << 2) |
		    cpu_cmmu_strategy[0].inst;
		val2 = (cpu_cmmu_strategy[0].data << 2) |
		    cpu_cmmu_strategy[0].data;
d502 1
a502 1
		dprintf(("m8820x_setup_cmmu_config: 1P128: PCNFA = 0x%x, PCNFB = 0x%x\n", val1, val2));
d504 1
a504 1
	case 0x06:
d506 1
a506 2
		val1 = (cpu_cmmu_strategy[0].inst << 2) |
		    cpu_cmmu_strategy[0].data;
d508 1
a508 1
		dprintf(("m8820x_setup_cmmu_config: 1P64: PCNFA = 0x%x\n", val1));
d512 1
a512 1
		panic("m8820x_setup_cmmu_config: unsupported configuration");
d517 1
a517 1
	dprintf(("m8820x_setup_cmmu_config: PCNFA = 0x%x, PCNFB = 0x%x\n", *pcnfa, *pcnfb));
d525 3
a527 3
		    (cmmu_num * max_cpus) / max_cmmus;
		dprintf(("m8820x_setup_cmmu_config: CMMU %d connected with CPU %d\n",
		    cmmu_num, m8820x_cmmu[cmmu_num].cmmu_cpu));
d537 2
a538 2
		if (cmmu_shift == 1) {
			m8820x_cmmu[cmmu_num].cmmu_addr = 0;
d549 3
a551 3
		switch ((m8820x_cmmu[cmmu_num].cmmu_type == INST_CMMU) ?
		    cpu_cmmu_strategy[m8820x_cmmu[cmmu_num].cmmu_cpu].inst :
		    cpu_cmmu_strategy[m8820x_cmmu[cmmu_num].cmmu_cpu].data) {
d553 1
a553 2
			m8820x_cmmu[cmmu_num].cmmu_addr =
			    ((cmmu_num & 0x2) ^ 0x2) << 11;
d558 1
a558 1
			m8820x_cmmu[cmmu_num].cmmu_addr = 0;
d565 1
a565 2
			m8820x_cmmu[cmmu_num].cmmu_addr_match =
			    (cmmu_num & 0x2) ? 1 : 0;
d570 1
a570 2
				m8820x_cmmu[cmmu_num].cmmu_addr_mask =
				    CMMU_SRAM_MASK;
d572 1
a572 1
				m8820x_cmmu[cmmu_num].cmmu_addr = 0;
d581 3
a583 1
		 * This bit splits the CMMUs independent of the enabled strategy
d585 2
a586 3
		if (cmmu_shift >= 2) {
			m8820x_cmmu[cmmu_num].cmmu_addr |=
			    ((cmmu_num & 0x4) ^ 0x4) << 12;
d593 3
a595 3
		switch ((m8820x_cmmu[cmmu_num].cmmu_type == INST_CMMU) ?
		    cpu_cmmu_strategy[m8820x_cmmu[cmmu_num].cmmu_cpu].inst :
		    cpu_cmmu_strategy[m8820x_cmmu[cmmu_num].cmmu_cpu].data) {
d598 1
a598 1
			    (cmmu_num & 0x2) ? CMMU_ACS_USER : CMMU_ACS_SUPER;
d602 1
a602 1
			    (cmmu_num & 0x2) ? CMMU_ACS_SUPER : CMMU_ACS_BOTH;
d609 1
a611 2
#ifdef DDB

d613 1
a613 1
const char *cmmu_strat_string[] = {
d619 1
a619 1
#endif
d621 1
a621 1
void
d627 4
a630 1
	int cmmu_num;
d632 1
d634 42
a675 3
	if (brdtyp != BRD_188)
		return;
#endif
d677 5
a681 21
	db_printf("Current CPU/CMMU configuration:\n");
	pcnfa = (unsigned long *volatile)MVME188_PCNFA;
	pcnfb = (unsigned long *volatile)MVME188_PCNFB;
	db_printf("VME188 address decoder: PCNFA = 0x%1lx, PCNFB = 0x%1lx\n\n",
	    *pcnfa & 0xf, *pcnfb & 0xf);
	for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++) {
		db_printf("CMMU #%d: %s CMMU for CPU %d:\n Strategy: %s\n %s access addr 0x%08lx mask 0x%08lx match %s\n",
		  cmmu_num,
		  (m8820x_cmmu[cmmu_num].cmmu_type == INST_CMMU) ? "inst" : "data",
		  m8820x_cmmu[cmmu_num].cmmu_cpu,
		  cmmu_strat_string[(m8820x_cmmu[cmmu_num].cmmu_type == INST_CMMU) ?
		    cpu_cmmu_strategy[m8820x_cmmu[cmmu_num].cmmu_cpu].inst :
		    cpu_cmmu_strategy[m8820x_cmmu[cmmu_num].cmmu_cpu].data],
		  (m8820x_cmmu[cmmu_num].cmmu_access == CMMU_ACS_BOTH) ?   "User and spv" :
		  ((m8820x_cmmu[cmmu_num].cmmu_access == CMMU_ACS_USER) ? "User        " :
		   "Supervisor  "),
		  m8820x_cmmu[cmmu_num].cmmu_addr,
		  m8820x_cmmu[cmmu_num].cmmu_addr_mask,
		  m8820x_cmmu[cmmu_num].cmmu_addr_match ? "TRUE" : "FALSE");
	}
#endif /* MVME188 */
a682 1
#endif	/* DDB */
d688 1
a688 1
void
d693 1
a693 1
	vaddr_t addr;
d695 11
a705 1
	int mmu;
d711 1
a711 2
	for (mmu = num << cmmu_shift;
	    mmu < (num + 1) << cmmu_shift; mmu++) {
d713 1
a713 1
		    (m8820x_cmmu[mmu].cmmu_type != mode))
d725 1
a725 1
		m8820x_cmmu[mmu].cmmu_regs[reg] = val;
d729 1
d731 1
a731 3
 * Force a read from the CMMU status register, thereby forcing execution to
 * stop until all pending CMMU operations are finished.
 * This is used by the various cache invalidation functions.
d733 3
a735 2
void
m8820x_cmmu_wait(int cpu)
d737 1
a737 1
	int mmu;
d739 9
a747 13
	/*
	 * We scan all related CMMUs and read their status register.
	 */
	for (mmu = cpu << cmmu_shift;
	    mmu < (cpu + 1) << cmmu_shift; mmu++) {
#ifdef DEBUG
		if (m8820x_cmmu[mmu].cmmu_regs[CMMU_SSR] & CMMU_SSR_BE) {
			panic("cache flush failed!");
		}
#else
		/* force the read access, but do not issue this statement... */
		__asm__ __volatile__ ("|or r0, r0, %0" ::
		    "r" (m8820x_cmmu[mmu].cmmu_regs[CMMU_SSR]));
a748 2
	}
}
d750 1
a750 1
const char *mmutypes[8] = {
d766 1
a766 1
void
d781 6
a786 7
	printf("cpu%d: ", cpu);
	if (proctype != 0) {
		printf("unknown model arch 0x%x rev 0x%x\n",
		    proctype, procvers);
		simple_unlock(&print_lock);
		return;
	}
d788 3
a790 6
	printf("M88100 rev 0x%x", procvers);
#if 0	/* not useful yet */
#ifdef MVME188
	if (brdtyp == BRD_188)
		printf(", %s", master ? "master" : "slave");
#endif
a791 12
	printf(", %d CMMU", 1 << cmmu_shift);

	for (mmu = cpu << cmmu_shift; mmu < (cpu + 1) << cmmu_shift;
	    mmu++) {
		int idr = m8820x_cmmu[mmu].cmmu_regs[CMMU_IDR];
		int mmuid = CMMU_TYPE(idr);
		int access = m8820x_cmmu[mmu].cmmu_access;

		if (mmu % 2 == 0)
			printf("\ncpu%d: ", cpu);
		else
			printf(", ");
d793 10
d804 1
a804 1
			printf("unknown model id 0x%x", mmuid);
d806 2
a807 6
			printf("%s", mmutypes[mmuid]);
		printf(" rev 0x%x, %s %scache",
		    CMMU_VERSION(idr),
		    access == CMMU_ACS_BOTH ? "global" :
		    (access == CMMU_ACS_USER ? "user" : "sup"),
		    m8820x_cmmu[mmu].cmmu_type == INST_CMMU ? "I" : "D");
d809 1
a809 14
	printf("\n");

#ifndef ERRATA__XXX_USR
	{
		static int errata_warn = 0;

		if (proctype != 0 && procvers < 2) {
			if (!errata_warn++)
				printf("WARNING: M88100 bug workaround code "
				    "not enabled.\nPlease recompile the kernel "
				    "with option ERRATA__XXX_USR !\n");
		}
	}
#endif
d820 3
a822 4
	unsigned int line, cmmu_num;
	int cssp, cpu, type;
	u_int32_t apr;
	unsigned *volatile cr;
d825 1
a825 2
		cpu_cmmu[cpu].pair[INST_CMMU] = 0;
		cpu_cmmu[cpu].pair[DATA_CMMU] = 0;
d828 3
a830 8
	for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++) {
		if (m8820x_cmmu[cmmu_num].cmmu_alive != CMMU_DEAD) {
			cr = m8820x_cmmu[cmmu_num].cmmu_regs;
			type = CMMU_TYPE(cr[CMMU_IDR]);

			cpu_cmmu[m8820x_cmmu[cmmu_num].cmmu_cpu].
			  pair[m8820x_cmmu[cmmu_num].cmmu_type] =
			    &m8820x_cmmu[cmmu_num];
d832 2
d835 2
a836 1
			 * Reset cache
d838 10
a847 13
			for (cssp = type == M88204_ID ? 3 : 0;
			    cssp >= 0; cssp--)
				for (line = 0; line <= 255; line++) {
					cr[CMMU_SAR] =
					    line << MC88200_CACHE_SHIFT;
					cr[CMMU_CSSP(cssp)] =
					    CMMU_CSSP_L5 | CMMU_CSSP_L4 |
					    CMMU_CSSP_L3 | CMMU_CSSP_L2 |
					    CMMU_CSSP_L1 | CMMU_CSSP_L0 |
					    CMMU_CSSP_VV(3, CMMU_VV_INVALID) |
					    CMMU_CSSP_VV(2, CMMU_VV_INVALID) |
					    CMMU_CSSP_VV(1, CMMU_VV_INVALID) |
					    CMMU_CSSP_VV(0, CMMU_VV_INVALID);
d849 9
d861 1
d863 15
a877 5
			cr[CMMU_SCTR] &=
			    ~(CMMU_SCTR_PE | CMMU_SCTR_SE | CMMU_SCTR_PR);
			cr[CMMU_SAPR] = cr[CMMU_UAPR] =
			    ((0x00000 << PG_BITS) | CACHE_WT | CACHE_GLOBAL |
			    CACHE_INH) & ~APR_V;
d889 11
a899 9
			cr[CMMU_BWP0] = cr[CMMU_BWP1] =
			cr[CMMU_BWP2] = cr[CMMU_BWP3] =
			cr[CMMU_BWP4] = cr[CMMU_BWP5] =
			cr[CMMU_BWP6] = cr[CMMU_BWP7] = 0;
			cr[CMMU_SCR] = CMMU_FLUSH_CACHE_INV_ALL;
			__asm__ __volatile__ ("|or r0, r0, %0" ::
			    "r" (cr[CMMU_SSR]));
			cr[CMMU_SCR] = CMMU_FLUSH_SUPER_ALL;
			cr[CMMU_SCR] = CMMU_FLUSH_USER_ALL;
a901 1

d903 1
a903 3
	 * Enable snooping on MVME188 only.
	 * Snooping is enabled for instruction cmmus as well so that
	 * we can share breakpoints.
d905 3
a907 5
#ifdef MVME188
	if (brdtyp == BRD_188) {
		for (cpu = 0; cpu < max_cpus; cpu++) {
			if (cpu_sets[cpu] == 0)
				continue;
d909 22
a930 10
			m8820x_cmmu_set(CMMU_SCTR, CMMU_SCTR_SE, MODE_VAL, cpu,
			    DATA_CMMU, 0, 0);
			m8820x_cmmu_set(CMMU_SCTR, CMMU_SCTR_SE, MODE_VAL, cpu,
			    INST_CMMU, 0, 0);

			m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_SUPER_ALL,
			    ACCESS_VAL, cpu, 0, CMMU_ACS_SUPER, 0);
			m8820x_cmmu_wait(cpu);
			/* Icache gets flushed just below */
		}
a931 1
#endif
d934 1
a934 4
	 * Enable instruction cache.
	 * Data cache can not be enabled at this point, because some device
	 * addresses can never be cached, and the no-caching zones are not
	 * set up yet.
d937 1
a937 1
		if (cpu_sets[cpu] == 0)
d939 17
d957 5
a961 7
		apr = ((0x00000 << PG_BITS) | CACHE_WT | CACHE_GLOBAL)
		    & ~(CACHE_INH | APR_V);

		m8820x_cmmu_set(CMMU_SAPR, apr, MODE_VAL, cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_SUPER_ALL,
		    ACCESS_VAL, cpu, 0, CMMU_ACS_SUPER, 0);
		m8820x_cmmu_wait(cpu);
d971 1
a972 1
	unsigned *volatile cr;
d975 23
a997 3
	for (cmmu_num = 0; cmmu_num < MAX_CMMUS; cmmu_num++)
		if (m8820x_cmmu[cmmu_num].cmmu_alive != CMMU_DEAD) {
			cr = m8820x_cmmu[cmmu_num].cmmu_regs;
d999 3
a1001 6
			cr[CMMU_SCTR] &=
			    ~(CMMU_SCTR_PE | CMMU_SCTR_SE | CMMU_SCTR_PR);
			cr[CMMU_SAPR] = cr[CMMU_UAPR] =
			    ((0x00000 << PG_BITS) | CACHE_INH) &
			    ~(CACHE_WT | CACHE_GLOBAL | APR_V);
		}
d1005 1
d1009 1
a1009 1
void
d1012 3
a1014 2
	unsigned cmmu_num;
	unsigned *volatile cr;
d1016 4
a1019 1
	CMMU_LOCK;
d1021 5
a1025 4
	for (cmmu_num = 0; cmmu_num < max_cmmus; cmmu_num++)
		if (m8820x_cmmu[cmmu_num].cmmu_alive != CMMU_DEAD) {
			cr = m8820x_cmmu[cmmu_num].cmmu_regs;
			cr[CMMU_SCTR] |= CMMU_SCTR_PE;
d1027 1
a1027 1

d1029 1
d1037 1
a1037 1
#define ILLADDRESS	0x0f000000 	/* any faulty address */
d1039 1
a1039 1
unsigned
d1042 2
a1043 2
	unsigned cmmu_no;
	int i, cpu;
d1047 1
a1047 1
	for (i = 0; i < 10; i++) {
d1051 2
a1052 2
			    m8820x_cmmu[cmmu_no].cmmu_type == DATA_CMMU)
				m8820x_cmmu[cmmu_no].cmmu_regs[CMMU_PFSR] = 0;
d1056 1
a1056 1
		badwordaddr((vaddr_t)ILLADDRESS);
d1061 7
a1067 9
			    m8820x_cmmu[cmmu_no].cmmu_type == DATA_CMMU &&
			    CMMU_PFSR_FAULT(m8820x_cmmu[cmmu_no].
			      cmmu_regs[CMMU_PFSR]) != CMMU_PFSR_SUCCESS) {
				/* clean register, just in case... */
				m8820x_cmmu[cmmu_no].cmmu_regs[CMMU_PFSR] = 0;
				m8820x_cmmu[cmmu_no].cmmu_alive = CMMU_MARRIED;
				cpu = m8820x_cmmu[cmmu_no].cmmu_cpu;
				CMMU_UNLOCK;
				return cpu;
d1071 1
d1073 33
d1107 13
a1119 1
	panic("m8820x_cmmu_cpu_number: could not determine my cpu number");
d1123 1
a1123 1
m8820x_cmmu_set_sapr(cpu, ap)
d1127 4
a1130 1
	m8820x_cmmu_set(CMMU_SAPR, ap, ACCESS_VAL, cpu, 0, CMMU_ACS_SUPER, 0);
d1138 4
a1141 2
	int s = splhigh();
	int cpu = cpu_number();
d1145 2
a1146 1
	m8820x_cmmu_set(CMMU_UAPR, ap, ACCESS_VAL, cpu, 0, CMMU_ACS_USER, 0);
d1152 28
a1179 1
 * Set batc entry number entry_no to value in
a1180 3
 *
 * Except for the cmmu_init, this function and m8820x_cmmu_pmap_activate
 * are the only functions which may set the batc values.
d1188 2
a1189 3

	m8820x_cmmu_set(CMMU_BWP(entry_no), value, MODE_VAL | ACCESS_VAL,
	    cpu, DATA_CMMU, CMMU_ACS_USER, 0);
d1193 2
a1194 2
	m8820x_cmmu_set(CMMU_BWP(entry_no), value, MODE_VAL | ACCESS_VAL,
	    cpu, INST_CMMU, CMMU_ACS_USER, 0);
d1199 6
d1217 4
a1220 2
m8820x_cmmu_flush_tlb(unsigned cpu, unsigned kernel, vaddr_t vaddr,
    vsize_t size)
d1222 1
a1222 2
	int s = splhigh();

d1225 3
a1227 30
	/*
	 * Since segment operations are horribly expensive, don't
	 * do any here. Invalidations of up to three pages are performed
	 * as page invalidations, otherwise the entire tlb is flushed.
	 *
	 * Note that this code relies upon size being a multiple of
	 * a page and vaddr being page-aligned.
	 */
	if (size == PAGE_SIZE) {	/* most frequent situation */
		m8820x_cmmu_set(CMMU_SAR, vaddr,
		    ADDR_VAL | ACCESS_VAL, cpu, 0,
		    kernel ? CMMU_ACS_SUPER : CMMU_ACS_USER, vaddr);
		m8820x_cmmu_set(CMMU_SCR,
		    kernel ? CMMU_FLUSH_SUPER_PAGE : CMMU_FLUSH_USER_PAGE,
		    ADDR_VAL | ACCESS_VAL, cpu, 0,
		    kernel ? CMMU_ACS_SUPER : CMMU_ACS_USER, vaddr);
	} else if (size > 3 * PAGE_SIZE) {
		m8820x_cmmu_set(CMMU_SCR,
		    kernel ? CMMU_FLUSH_SUPER_ALL : CMMU_FLUSH_USER_ALL,
		    ACCESS_VAL, cpu, 0,
		    kernel ? CMMU_ACS_SUPER : CMMU_ACS_USER, 0);
	} else
	while (size != 0) {
		m8820x_cmmu_set(CMMU_SAR, vaddr,
		    ADDR_VAL | ACCESS_VAL, cpu, 0,
		    kernel ? CMMU_ACS_SUPER : CMMU_ACS_USER, vaddr);
		m8820x_cmmu_set(CMMU_SCR,
		    kernel ? CMMU_FLUSH_SUPER_PAGE : CMMU_FLUSH_USER_PAGE,
		    ADDR_VAL | ACCESS_VAL, cpu, 0,
		    kernel ? CMMU_ACS_SUPER : CMMU_ACS_USER, vaddr);
d1229 8
a1236 2
		size -= PAGE_SIZE;
		vaddr += PAGE_SIZE;
a1237 1

d1243 14
d1259 1
a1259 1
 * Only called from pmap_activate().
d1264 2
a1265 2
	u_int32_t i_batc[BATC_MAX];
	u_int32_t d_batc[BATC_MAX];
a1267 1

d1275 4
a1278 4
		m8820x_cmmu_set(CMMU_BWP(entry_no), i_batc[entry_no],
		    MODE_VAL | ACCESS_VAL, cpu, INST_CMMU, CMMU_ACS_USER, 0);
		m8820x_cmmu_set(CMMU_BWP(entry_no), d_batc[entry_no],
		    MODE_VAL | ACCESS_VAL, cpu, DATA_CMMU, CMMU_ACS_USER, 0);
d1280 2
a1281 2
		CMMU(cpu,INST_CMMU)->batc[entry_no] = i_batc[entry_no];
		CMMU(cpu,DATA_CMMU)->batc[entry_no] = d_batc[entry_no];
d1288 1
a1288 1
	 * THE SUPERVISOR TLBs SHOULD BE FLUSHED AS WELL.
d1291 1
a1291 2
	    cpu, 0, CMMU_ACS_USER, 0);

d1313 4
a1316 1
m8820x_cmmu_flush_cache(int cpu, paddr_t physaddr, psize_t size)
d1318 1
a1318 1
	int s = splhigh();
d1322 2
a1323 1
	if (size > NBSG) {
d1325 2
a1326 2
		    cpu, 0, 0, 0);
	} else if (size <= MC88200_CACHE_LINE) {
d1328 3
a1330 3
		    cpu, 0, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_LINE, ADDR_VAL,
		    cpu, 0, 0, (unsigned)physaddr);
d1333 3
a1335 3
		    cpu, 0, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_PAGE, ADDR_VAL,
		    cpu, 0, 0, (unsigned)physaddr);
d1338 1
a1338 1
		    cpu, 0, 0, 0);
d1340 1
a1340 1
		    cpu, 0, 0, 0);
d1342 1
d1345 1
a1345 1
	    cpu, 0, 0, 0);
a1346 3

	m8820x_cmmu_wait(cpu);

d1352 12
d1367 4
a1370 1
m8820x_cmmu_flush_inst_cache(int cpu, paddr_t physaddr, psize_t size)
d1372 1
a1372 1
	int s = splhigh();
d1376 1
a1376 1
	if (size > NBSG) {
d1378 7
a1384 6
		    cpu, INST_CMMU, 0, 0);
	} else if (size <= MC88200_CACHE_LINE) {
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_LINE,
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, 0, (unsigned)physaddr);
d1386 4
a1389 4
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_PAGE,
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, 0, (unsigned)physaddr);
d1391 4
a1394 4
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL, cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_SEGMENT,
		    MODE_VAL, cpu, INST_CMMU, 0, 0);
d1398 1
a1398 1
	    cpu, INST_CMMU, 0, 0);
a1400 2
	m8820x_cmmu_wait(cpu);

d1405 13
d1419 4
a1422 1
m8820x_cmmu_flush_data_cache(int cpu, paddr_t physaddr, psize_t size)
d1424 1
a1424 1
	int s = splhigh();
d1428 2
a1429 1
	if (size > NBSG) {
d1431 7
a1437 6
		    cpu, DATA_CMMU, 0, 0);
	} else if (size <= MC88200_CACHE_LINE) {
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_LINE,
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, 0, (unsigned)physaddr);
d1439 4
a1442 4
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_PAGE,
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, 0, (unsigned)physaddr);
d1444 4
a1447 4
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL, cpu, DATA_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SCR, CMMU_FLUSH_CACHE_CBI_SEGMENT,
		    MODE_VAL, cpu, DATA_CMMU, 0, 0);
d1451 1
a1451 1
	    cpu, DATA_CMMU, 0, 0);
a1452 3

	m8820x_cmmu_wait(cpu);

d1458 13
d1474 7
a1480 5
m8820x_cmmu_sync_cache(paddr_t physaddr, psize_t size)
{
	int s = splhigh();
	int cpu = cpu_number();

d1482 1
d1485 1
a1485 1
	if (size > NBSG) {
d1487 1
a1487 1
		    cpu, DATA_CMMU, 0, 0);
d1489 10
a1498 10
		    cpu, INST_CMMU, 0, 0);
	} else if (size <= MC88200_CACHE_LINE) {
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_LINE,
		    MODE_VAL, cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_LINE,
		    MODE_VAL, cpu, DATA_CMMU, 0, 0);
d1500 8
a1507 8
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_PAGE,
		    MODE_VAL, cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_PAGE,
		    MODE_VAL, cpu, DATA_CMMU, 0, 0);
d1509 8
a1516 8
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_SEGMENT,
		    MODE_VAL, cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CB_SEGMENT,
		    MODE_VAL, cpu, DATA_CMMU, 0, 0);
d1520 1
a1520 1
	    cpu, DATA_CMMU, 0, 0);
d1522 1
a1522 1
	    cpu, INST_CMMU, 0, 0);
d1524 1
a1524 3

	m8820x_cmmu_wait(cpu);

a1525 1
	splx(s);
d1528 8
a1535 6
void
m8820x_cmmu_sync_inval_cache(paddr_t physaddr, psize_t size)
{
	int s = splhigh();
	int cpu = cpu_number();

d1539 1
a1539 1
	if (size > NBSG) {
d1541 1
a1541 1
		    cpu, DATA_CMMU, 0, 0);
d1543 10
a1552 10
		    cpu, INST_CMMU, 0, 0);
	} else if (size <= MC88200_CACHE_LINE) {
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_LINE,
		    MODE_VAL, cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_LINE,
		    MODE_VAL, cpu, DATA_CMMU, 0, 0);
d1554 8
a1561 8
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_PAGE,
		    MODE_VAL, cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_PAGE,
		    MODE_VAL, cpu, DATA_CMMU, 0, 0);
d1563 8
a1570 8
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_SEGMENT,
		    MODE_VAL, cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_CBI_SEGMENT,
		    MODE_VAL, cpu, DATA_CMMU, 0, 0);
d1572 1
d1575 1
a1575 1
	    cpu, DATA_CMMU, 0, 0);
d1577 1
a1577 1
	    cpu, INST_CMMU, 0, 0);
a1578 3

	m8820x_cmmu_wait(cpu);

d1584 7
a1590 5
m8820x_cmmu_inval_cache(paddr_t physaddr, psize_t size)
{
	int s = splhigh();
	int cpu = cpu_number();

d1594 1
a1594 1
	if (size > NBSG) {
d1596 1
a1596 1
		    cpu, DATA_CMMU, 0, 0);
d1598 10
a1607 10
		    cpu, INST_CMMU, 0, 0);
	} else if (size <= MC88200_CACHE_LINE) {
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_LINE,
		    MODE_VAL, cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_LINE,
		    MODE_VAL, cpu, DATA_CMMU, 0, 0);
d1609 8
a1616 8
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_PAGE,
		    MODE_VAL, cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_PAGE,
		    MODE_VAL, cpu, DATA_CMMU, 0, 0);
d1618 8
a1625 8
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, INST_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_SEGMENT,
		    MODE_VAL, cpu, INST_CMMU, 0, 0);
		m8820x_cmmu_set(CMMU_SAR, (unsigned)physaddr,
		    MODE_VAL | ADDR_VAL, cpu, DATA_CMMU, 0, (unsigned)physaddr);
		m8820x_cmmu_set(CMMU_SAR, CMMU_FLUSH_CACHE_INV_SEGMENT,
		    MODE_VAL, cpu, DATA_CMMU, 0, 0);
d1629 1
a1629 1
	    cpu, DATA_CMMU, 0, 0);
d1631 1
a1631 1
	    cpu, INST_CMMU, 0, 0);
a1632 3

	m8820x_cmmu_wait(cpu);

d1638 3
a1640 1
m8820x_dma_cachectl(vaddr_t va, vsize_t size, int op)
a1641 1
	paddr_t pa;
d1643 1
a1643 1
	psize_t count;
d1645 2
a1646 2
	while (size != 0) {
		count = NBPG - (va & PGOFSET);
d1651 6
a1656 13
		if (pmap_extract(pmap_kernel(), va, &pa) != FALSE) {
			switch (op) {
			case DMA_CACHE_SYNC:
				m8820x_cmmu_sync_cache(pa, count);
				break;
			case DMA_CACHE_SYNC_INVAL:
				m8820x_cmmu_sync_inval_cache(pa, count);
				break;
			default:
				m8820x_cmmu_inval_cache(pa, count);
				break;
			}
		}
d1658 1
a1658 1
		va += count;
d1662 7
a1668 14
	/* XXX This assumes the space is also physically contiguous */
	if (pmap_extract(pmap_kernel(), va, &pa) != FALSE) {
		switch (op) {
		case DMA_CACHE_SYNC:
			m8820x_cmmu_sync_cache(pa, size);
			break;
		case DMA_CACHE_SYNC_INVAL:
			m8820x_cmmu_sync_inval_cache(pa, size);
			break;
		default:
			m8820x_cmmu_inval_cache(pa, size);
			break;
		}
	}
d1765 1
a1765 1
	u_int32_t value;
d1768 1
a1768 1
		db_printf("-------------------------------------------\n");
d1773 16
a1788 4
	if (cmmu_num == -1) {
		int cpu = cpu_number();
		if (cpu_cmmu[cpu].pair[DATA_CMMU] == 0) {
			db_printf("ack! can't figure my own data cmmu number.\n");
d1791 33
a1823 7
		cmmu_num = cpu_cmmu[cpu].pair[DATA_CMMU] - m8820x_cmmu;
		if (verbose_flag)
			db_printf("The data cmmu for cpu#%d is cmmu#%d.\n",
				  0, cmmu_num);
	} else if (cmmu_num < 0 || cmmu_num >= MAX_CMMUS) {
		db_printf("invalid cpu number [%d]... must be in range [0..%d]\n",
			  cmmu_num, MAX_CMMUS - 1);
d1825 2
a1826 2
		return;
	}
d1828 2
a1829 2
	if (m8820x_cmmu[cmmu_num].cmmu_alive == CMMU_DEAD) {
		db_printf("warning: cmmu %d is not alive.\n", cmmu_num);
d1831 1
a1831 1
		return;
d1833 21
a1853 1
	}
a1854 13
	if (!verbose_flag) {
		if (!(m8820x_cmmu[cmmu_num].cmmu_regs[CMMU_SCTR] & CMMU_SCTR_SE))
			db_printf("WARNING: snooping not enabled for CMMU#%d.\n",
				  cmmu_num);
	} else {
		int i;
		for (i = 0; i < MAX_CMMUS; i++)
			if ((i == cmmu_num || m8820x_cmmu[i].cmmu_alive != CMMU_DEAD) &&
			    (verbose_flag > 1 || !(m8820x_cmmu[i].cmmu_regs[CMMU_SCTR] & CMMU_SCTR_SE))) {
				db_printf("CMMU#%d (cpu %d %s) snooping %s\n", i,
					  m8820x_cmmu[i].cmmu_cpu, m8820x_cmmu[i].cmmu_type ? "data" : "inst",
					  (m8820x_cmmu[i].cmmu_regs[CMMU_SCTR] & CMMU_SCTR_SE) ? "on":"OFF");
			}
d1857 2
a1858 5
	if (supervisor_flag)
		value = m8820x_cmmu[cmmu_num].cmmu_regs[CMMU_SAPR];
	else
		value = m8820x_cmmu[cmmu_num].cmmu_regs[CMMU_UAPR];

d1860 1
a1860 1
	{
d1867 1
a1867 1
					db_printf("cmmu #%d batc[%d] invalid.\n", cmmu_num, i);
d1869 1
a1869 1
				db_printf("cmmu#%d batc[%d] v%08x p%08x", cmmu_num, i,
d1871 5
a1875 5
				if (batc.field.s)  db_printf(", supervisor");
				if (batc.field.wt) db_printf(", wt.th");
				if (batc.field.g)  db_printf(", global");
				if (batc.field.ci) db_printf(", cache inhibit");
				if (batc.field.wp) db_printf(", write protect");
d1880 1
d1883 3
d1888 4
a1891 4
		unsigned *volatile cmmu_regs = m8820x_cmmu[cmmu_num].cmmu_regs;
		cmmu_regs[CMMU_SAR] = address;
		cmmu_regs[CMMU_SCR] = supervisor_flag ? CMMU_PROBE_SUPER : CMMU_PROBE_USER;
		ssr.bits = cmmu_regs[CMMU_SSR];
d1893 1
a1893 1
			db_printf("probe of 0x%08x returns ssr=0x%08x\n",
d1896 2
a1897 2
			db_printf("PROBE of 0x%08x returns phys=0x%x",
				  address, cmmu_regs[CMMU_SAR]);
d1899 12
a1910 12
			db_printf("PROBE fault at 0x%x", cmmu_regs[CMMU_PFAR]);
		if (ssr.field.ce) db_printf(", copyback err");
		if (ssr.field.be) db_printf(", bus err");
		if (ssr.field.wt) db_printf(", writethrough");
		if (ssr.field.sp) db_printf(", sup prot");
		if (ssr.field.g)  db_printf(", global");
		if (ssr.field.ci) db_printf(", cache inhibit");
		if (ssr.field.m)  db_printf(", modified");
		if (ssr.field.u)  db_printf(", used");
		if (ssr.field.wp) db_printf(", write prot");
		if (ssr.field.bh) db_printf(", BATC");
		db_printf(".\n");
d1915 2
d1918 28
a1945 16
			db_printf("CMMU#%d", cmmu_num);
			db_printf(" %cAPR is 0x%08x\n",
				  supervisor_flag ? 'S' : 'U', value);
		}
		db_printf("CMMU#%d", cmmu_num);
		db_printf(" %cAPR: SegTbl: 0x%x000p",
			  supervisor_flag ? 'S' : 'U', PG_PFNUM(value));
		if (value & CACHE_WT)
			db_printf(", WTHRU");
		if (value & CACHE_GLOBAL)
			db_printf(", GLOBAL");
		if (value & CACHE_INH)
			db_printf(", INHIBIT");
		if (value & APR_V)
			db_printf(", VALID");
		db_printf("\n");
d1948 2
a1949 2
		if ((value & APR_V) == 0) {
			db_printf("<would report an error, valid bit not set>\n");
d1954 1
a1954 1
		value &= PG_FRAME;	/* now point to seg page */
d1959 1
a1959 1
		db_printf("[%x physical is %x virtual]\n", value, value + VEQR_ADDR);
d1968 1
a1968 1
			db_printf("will follow to entry %d of page at 0x%x...\n",
d1973 2
a1974 2
		if (badwordaddr((vaddr_t)value)) {
			db_printf("ERROR: unable to access page at 0x%08x.\n", value);
d1980 2
a1981 2
			db_printf("SEG DESC @@0x%x is 0x%08x\n", value, sdt);
		db_printf("SEG DESC @@0x%x: PgTbl: 0x%x000",
d1983 13
a1995 13
		if (sdt & CACHE_WT)		    db_printf(", WTHRU");
		else				    db_printf(", !wthru");
		if (sdt & SG_SO)		    db_printf(", S-PROT");
		else				    db_printf(", UserOk");
		if (sdt & CACHE_GLOBAL)		    db_printf(", GLOBAL");
		else				    db_printf(", !global");
		if (sdt & CACHE_INH)		    db_printf(", $INHIBIT");
		else				    db_printf(", $ok");
		if (sdt & SG_PROT)		    db_printf(", W-PROT");
		else				    db_printf(", WriteOk");
		if (sdt & SG_V)			    db_printf(", VALID");
		else				    db_printf(", !valid");
		db_printf(".\n");
d1999 1
a1999 1
			db_printf("<would report an error, STD entry not valid>\n");
d2008 1
a2008 1
		db_printf("[%x physical is %x virtual]\n", value, value + VEQR_ADDR);
d2015 1
a2015 1
			db_printf("will follow to entry %d of page at 0x%x...\n",
d2020 2
a2021 2
		if (badwordaddr((vaddr_t)value)) {
			db_printf("error: unable to access page at 0x%08x.\n", value);
d2028 2
a2029 2
			db_printf("PAGE DESC @@0x%x is 0x%08x.\n", value, pte);
		db_printf("PAGE DESC @@0x%x: page @@%x000",
d2031 19
a2049 19
		if (pte & PG_W)			db_printf(", WIRE");
		else				db_printf(", !wire");
		if (pte & CACHE_WT)		db_printf(", WTHRU");
		else				db_printf(", !wthru");
		if (pte & PG_SO)		db_printf(", S-PROT");
		else				db_printf(", UserOk");
		if (pte & CACHE_GLOBAL)		db_printf(", GLOBAL");
		else				db_printf(", !global");
		if (pte & CACHE_INH)		db_printf(", $INHIBIT");
		else				db_printf(", $ok");
		if (pte & PG_M)			db_printf(", MOD");
		else				db_printf(", !mod");
		if (pte & PG_U)			db_printf(", USED");
		else				db_printf(", !used");
		if (pte & PG_PROT)		db_printf(", W-PROT");
		else				db_printf(", WriteOk");
		if (pte & PG_V)			db_printf(", VALID");
		else				db_printf(", !valid");
		db_printf(".\n");
d2053 1
a2053 1
			db_printf("<would report an error, PTE entry not valid>\n");
d2059 1
a2059 1
			db_printf("will follow to byte %d of page at 0x%x...\n",
d2063 2
a2064 2
		if (badwordaddr((vaddr_t)value)) {
			db_printf("error: unable to access page at 0x%08x.\n", value);
d2071 1
a2071 1
		db_printf("[%x physical is %x virtual]\n", value, value + VEQR_ADDR);
d2074 56
a2129 1
	db_printf("WORD at 0x%x is 0x%08x.\n", value, *(unsigned *)value);
d2132 1
d2134 18
@


1.12.2.3
log
@Merge with the trunk
@
text
@a140 1
void m8820x_dma_cachectl_pa(paddr_t, psize_t, int);
a161 1
	m8820x_dma_cachectl_pa,
a1500 42
	}
#endif /* !BROKEN_MMU_MASK */
}

void
m8820x_dma_cachectl_pa(paddr_t pa, psize_t size, int op)
{
#if !defined(BROKEN_MMU_MASK)
	psize_t count;

	while (size != 0) {
		count = NBPG - (va & PGOFSET);

		if (size < count)
			count = size;

		switch (op) {
		case DMA_CACHE_SYNC:
			m8820x_cmmu_sync_cache(pa, count);
			break;
		case DMA_CACHE_SYNC_INVAL:
			m8820x_cmmu_sync_inval_cache(pa, count);
			break;
		default:
			m8820x_cmmu_inval_cache(pa, count);
			break;
		}

		pa += count;
		size -= count;
	}
#else
	switch (op) {
	case DMA_CACHE_SYNC:
		m8820x_cmmu_sync_cache(pa, size);
		break;
	case DMA_CACHE_SYNC_INVAL:
		m8820x_cmmu_sync_inval_cache(pa, size);
		break;
	default:
		m8820x_cmmu_inval_cache(pa, size);
		break;
@


1.11
log
@More brdtyp vs cputyp replacements.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.10 2001/12/24 04:12:40 miod Exp $	*/
d346 1
a346 1
	volatile unsigned long *whoami;
d369 1
a369 1
		whoami = (volatile unsigned long *)MVME188_WHOAMI;
d409 2
a410 2
	volatile unsigned long *pcnfa;
	volatile unsigned long *pcnfb;
d487 2
a488 2
		pcnfa = (volatile unsigned long *)MVME188_PCNFA;
		pcnfb = (volatile unsigned long *)MVME188_PCNFB;
d496 2
a497 2
		pcnfa = (volatile unsigned long *)MVME188_PCNFA;
		pcnfb = (volatile unsigned long *)MVME188_PCNFB;
d505 1
a505 1
		pcnfa = (volatile unsigned long *)MVME188_PCNFA;
d625 2
a626 2
	volatile unsigned long *pcnfa;
	volatile unsigned long *pcnfb;
d639 2
a640 2
		pcnfa = (volatile unsigned long *)MVME188_PCNFA;
		pcnfb = (volatile unsigned long *)MVME188_PCNFB;
d667 1
a667 1
	*(volatile unsigned *)(reg + (char*)(m8820x_cmmu[mmu].cmmu_regs)) = val;
d681 1
a681 1
	return *(volatile unsigned *)(reg + (char*)(m8820x_cmmu[mmu].cmmu_regs));
d1083 1
a1083 1
	*(volatile unsigned *)(r + (char*)&REGS(cpu,data)) = x;
d1093 1
a1093 1
	return (*(volatile unsigned *)(r + (char*)&REGS(cpu,data)));
@


1.10
log
@- completely change the mmu segment and page table structure definitions,
to use constant bitmasks instead of bitfields.
- remove unnecessary (as long as we are not running SMP) locks on the
physsegs.
- update the pmap code to take these changes into account, and gratuitously
change several names and code paths to be closer to existing m68k pmaps. It's
a bit faster now.
- change pmap.c's usage of vm_{offset,size}_t to {p,v}{addr,size}_t.
- remove dead or unused stuff from pmap.c, fix typos, etc

Tested on 187 and 188, should not make things worse for 197.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.9 2001/12/22 09:49:39 smurph Exp $	*/
d381 1
a381 1
		printf("MVME%x board configuration #%X: %d CPUs %d CMMUs\n", cputyp, 
d387 1
a387 1
		printf("MVME%x board configuration #%X: %d CPUs %d CMMUs\n", cputyp,
d392 1
a392 1
		panic("UNKNOWN MVME%x board configuration: WHOAMI = 0x%02x", cputyp, *whoami);
@


1.9
log
@masive cmmu overhaul.  function pointers now control cmmu functionality
instead of case statements based on cpu type.
@
text
@d1 1
a1 1
/*	$OpenBSD: m18x_cmmu.c,v 1.18 2001/12/22 07:35:43 smurph Exp $	*/
d447 2
a448 1
				printf("CMMU %d attached to CPU %d is not working\n");
d870 1
a870 1
			(0x00000 << 12) |  /* segment table base address */
d946 1
a946 1
		(0x00000 << 12) | /* segment table base address */
d993 1
a993 1
		(0x00000 << 12) |  /* segment table base address */
d1760 3
a1762 3
			unsigned segment_table_index:10,
			page_table_index:10,
			page_offset:12;
d1954 1
a1954 1
		value = apr_template.field.st_base << 12; /* now point to seg page */
d1966 1
a1966 1
		union sdt_entry_template std_template;
d1971 1
a1971 1
			 sizeof(struct sdt_entry);
a1974 1

d1978 1
a1978 1
		std_template.bits = *(unsigned *)value;
d1980 1
a1980 1
			DEBUG_MSG("SEG DESC @@0x%x is 0x%08x\n", value, std_template.bits);
d1982 2
a1983 2
			  value, std_template.sdt_desc.table_addr);
		if (std_template.sdt_desc.wt)	    DEBUG_MSG(", WTHRU");
d1985 1
a1985 1
		if (std_template.sdt_desc.sup)	    DEBUG_MSG(", S-PROT");
d1987 1
a1987 1
		if (std_template.sdt_desc.g)	    DEBUG_MSG(", GLOBAL");
d1989 1
a1989 1
		if (std_template.sdt_desc.no_cache) DEBUG_MSG(", $INHIBIT");
d1991 1
a1991 1
		if (std_template.sdt_desc.prot)	    DEBUG_MSG(", W-PROT");
d1993 1
a1993 1
		if (std_template.sdt_desc.dtype)    DEBUG_MSG(", VALID");
d1998 1
a1998 1
		if (std_template.sdt_desc.dtype == 0) {
a1999 1

d2003 1
a2003 1
		value = std_template.sdt_desc.table_addr << 12;
d2013 1
a2013 1
		union pte_template pte_template;
d2018 1
a2018 1
			 sizeof(struct pt_entry);
d2026 1
a2026 1
		pte_template.bits = *(unsigned *)value;
d2028 1
a2028 1
			DEBUG_MSG("PAGE DESC @@0x%x is 0x%08x.\n", value, pte_template.bits);
d2030 19
a2048 19
			  value, pte_template.pte.pfn);
		if (pte_template.pte.wired)    DEBUG_MSG(", WIRE");
		else			       DEBUG_MSG(", !wire");
		if (pte_template.pte.wt)       DEBUG_MSG(", WTHRU");
		else			       DEBUG_MSG(", !wthru");
		if (pte_template.pte.sup)      DEBUG_MSG(", S-PROT");
		else			       DEBUG_MSG(", UserOk");
		if (pte_template.pte.g)	       DEBUG_MSG(", GLOBAL");
		else			       DEBUG_MSG(", !global");
		if (pte_template.pte.ci)       DEBUG_MSG(", $INHIBIT");
		else			       DEBUG_MSG(", $ok");
		if (pte_template.pte.modified) DEBUG_MSG(", MOD");
		else			       DEBUG_MSG(", !mod");
		if (pte_template.pte.pg_used)  DEBUG_MSG(", USED");
		else			       DEBUG_MSG(", !used");
		if (pte_template.pte.prot)     DEBUG_MSG(", W-PROT");
		else			       DEBUG_MSG(", WriteOk");
		if (pte_template.pte.dtype)    DEBUG_MSG(", VALID");
		else			       DEBUG_MSG(", !valid");
d2052 1
a2052 1
		if (pte_template.pte.dtype == 0) {
a2053 1

d2057 1
a2057 1
		value = pte_template.pte.pfn << 12;
a2064 1

@


1.8
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.7 2001/12/14 08:55:45 miod Exp $	*/
d162 1
a162 1
   /*             */unsigned padding7[0x03]; 
a376 2
	default:
		panic("m8820x_setup_board_config: Unknown CPU type.");
d383 1
a383 1
		panic("This configuration is not supported - go and get another OS.\n");
d392 1
a392 1
		panic("UNKNOWN MVME%x board configuration: WHOAMI = 0x%02x\n", cputyp, *whoami);
d612 1
a612 1
char *cmmu_strat_string[] = {
a637 1
		DEBUG_MSG("VME188 address decoder: PCNFA = 0x%1x, PCNFB = 0x%1x\n\n", *pcnfa & 0xf, *pcnfb & 0xf);
d640 1
a656 2
	default:
		DEBUG_MSG("Unknown CPU\n\n");
d661 1
a661 1
void 
d749 1
a749 1
char *mmutypes[8] = {
d1043 1
a1043 1
	
d1075 1
d1079 16
d1141 1
a1141 1
	
@


1.8.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.12 2002/01/14 21:34:41 miod Exp $	*/
d162 1
a162 1
   /*             */ unsigned padding7[0x03]; 
d346 1
a346 1
	unsigned long *volatile whoami;
d369 1
a369 1
		whoami = (unsigned long *volatile)MVME188_WHOAMI;
d377 2
d383 1
a383 1
		printf("MVME%x board configuration #%X: %d CPUs %d CMMUs\n", brdtyp, 
d385 1
a385 1
		panic("This configuration is not supported - go and get another OS.");
d389 1
a389 1
		printf("MVME%x board configuration #%X: %d CPUs %d CMMUs\n", brdtyp,
d394 1
a394 1
		panic("UNKNOWN MVME%x board configuration: WHOAMI = 0x%02x", brdtyp, *whoami);
d411 2
a412 2
	unsigned long *volatile pcnfa;
	unsigned long *volatile pcnfb;
d449 1
a449 2
				printf("CMMU %d attached to CPU %d is not working\n",
					 num*cpu_cmmu_ratio+i, num);
d488 2
a489 2
		pcnfa = (unsigned long *volatile)MVME188_PCNFA;
		pcnfb = (unsigned long *volatile)MVME188_PCNFB;
d497 2
a498 2
		pcnfa = (unsigned long *volatile)MVME188_PCNFA;
		pcnfb = (unsigned long *volatile)MVME188_PCNFB;
d506 1
a506 1
		pcnfa = (unsigned long *volatile)MVME188_PCNFA;
d614 1
a614 1
static char *cmmu_strat_string[] = {
d626 2
a627 2
	unsigned long *volatile pcnfa;
	unsigned long *volatile pcnfb;
a639 2
		pcnfa = (unsigned long *volatile)MVME188_PCNFA;
		pcnfb = (unsigned long *volatile)MVME188_PCNFB;
d641 2
d659 2
d665 1
a665 1
void
d670 1
a670 1
	*(unsigned *volatile)(reg + (char*)(m8820x_cmmu[mmu].cmmu_regs)) = val;
d684 1
a684 1
	return *(unsigned *volatile)(reg + (char*)(m8820x_cmmu[mmu].cmmu_regs));
d753 1
a753 1
static char *mmutypes[8] = {
d873 1
a873 1
			(0x00000 << PG_BITS) |  /* segment table base address */
d949 1
a949 1
		(0x00000 << PG_BITS) | /* segment table base address */
d996 1
a996 1
		(0x00000 << PG_BITS) |  /* segment table base address */
d1047 1
a1047 1

a1078 1
#if 0
a1081 16
void
m8820x_cmmu_remote_set(unsigned cpu, unsigned r, unsigned data, unsigned x)
{
	*(unsigned *volatile)(r + (char*)&REGS(cpu,data)) = x;
}

/*
 * cmmu_cpu_lock should be held when called if read
 * the CMMU_SCR or CMMU_SAR.
 */
unsigned
m8820x_cmmu_remote_get(unsigned cpu, unsigned r, unsigned data)
{
	return (*(unsigned *volatile)(r + (char*)&REGS(cpu,data)));
}
#endif 
d1128 1
a1128 1

d1746 3
a1748 3
			unsigned segment_table_index:SDT_BITS,
			page_table_index:PDT_BITS,
			page_offset:PG_BITS;
d1940 1
a1940 1
		value = apr_template.field.st_base << PG_BITS; /* now point to seg page */
d1952 1
a1952 1
		sdt_entry_t sdt;
d1957 1
a1957 1
			 sizeof(sdt_entry_t);
d1961 1
d1965 1
a1965 1
		sdt = *(sdt_entry_t *)value;
d1967 1
a1967 1
			DEBUG_MSG("SEG DESC @@0x%x is 0x%08x\n", value, sdt);
d1969 2
a1970 2
			  value, PG_PFNUM(sdt));
		if (sdt & CACHE_WT)		    DEBUG_MSG(", WTHRU");
d1972 1
a1972 1
		if (sdt & SG_SO)		    DEBUG_MSG(", S-PROT");
d1974 1
a1974 1
		if (sdt & CACHE_GLOBAL)		    DEBUG_MSG(", GLOBAL");
d1976 1
a1976 1
		if (sdt & CACHE_INH)		    DEBUG_MSG(", $INHIBIT");
d1978 1
a1978 1
		if (sdt & SG_PROT)		    DEBUG_MSG(", W-PROT");
d1980 1
a1980 1
		if (sdt & SG_V)			    DEBUG_MSG(", VALID");
d1985 1
a1985 1
		if (!(sdt & SG_V)) {
d1987 1
d1991 1
a1991 1
		value = ptoa(PG_PFNUM(sdt));
d2001 1
a2001 1
		pt_entry_t pte;
d2006 1
a2006 1
			 sizeof(pt_entry_t);
d2014 1
a2014 1
		pte = *(pt_entry_t *)value;
d2016 1
a2016 1
			DEBUG_MSG("PAGE DESC @@0x%x is 0x%08x.\n", value, pte);
d2018 19
a2036 19
			  value, PG_PFNUM(pte));
		if (pte & PG_W)			DEBUG_MSG(", WIRE");
		else				DEBUG_MSG(", !wire");
		if (pte & CACHE_WT)		DEBUG_MSG(", WTHRU");
		else				DEBUG_MSG(", !wthru");
		if (pte & PG_SO)		DEBUG_MSG(", S-PROT");
		else				DEBUG_MSG(", UserOk");
		if (pte & CACHE_GLOBAL)		DEBUG_MSG(", GLOBAL");
		else				DEBUG_MSG(", !global");
		if (pte & CACHE_INH)		DEBUG_MSG(", $INHIBIT");
		else				DEBUG_MSG(", $ok");
		if (pte & PG_M)			DEBUG_MSG(", MOD");
		else				DEBUG_MSG(", !mod");
		if (pte & PG_U)			DEBUG_MSG(", USED");
		else				DEBUG_MSG(", !used");
		if (pte & PG_PROT)		DEBUG_MSG(", W-PROT");
		else				DEBUG_MSG(", WriteOk");
		if (pte & PG_V)			DEBUG_MSG(", VALID");
		else				DEBUG_MSG(", !valid");
d2040 1
a2040 1
		if (!(pte & PG_V)) {
d2042 1
d2046 1
a2046 1
		value = ptoa(PG_PFNUM(pte));
d2054 1
@


1.8.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.8.2.1 2002/01/31 22:55:19 niklas Exp $	*/
d212 7
a218 7
unsigned m8820x_cmmu_get(int mmu, int reg);
void m8820x_cmmu_store(int, int, unsigned);
void m8820x_cmmu_set(int, unsigned, int, int, int, int, vm_offset_t);
void m8820x_cmmu_sync_cache(vm_offset_t, int);
void m8820x_cmmu_sync_inval_cache(vm_offset_t, int);
void m8820x_cmmu_inval_cache(vm_offset_t, int);
int m8820x_cmmu_alive(int);
d667 1
a667 1
	*(unsigned *volatile)(reg + (char *)(m8820x_cmmu[mmu].cmmu_regs)) = val;
d681 1
a681 1
	return *(unsigned *volatile)(reg + (char *)(m8820x_cmmu[mmu].cmmu_regs));
d1083 1
a1083 1
	*(unsigned *volatile)(r + (char *)&REGS(cpu,data)) = x;
d1093 1
a1093 1
	return (*(unsigned *volatile)(r + (char *)&REGS(cpu,data)));
@


1.7
log
@Remove cmmu_remote_[gs]et() here too, then...
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.6 2001/12/14 04:30:12 smurph Exp $	*/
@


1.6
log
@Repair MVME187 after MVME197 merge.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.5 2001/12/14 02:00:56 miod Exp $	*/
a1081 15
void
m8820x_cmmu_remote_set(unsigned cpu, unsigned r, unsigned data, unsigned x)
{
	*(volatile unsigned *)(r + (char*)&REGS(cpu,data)) = x;
}

/*
 * cmmu_cpu_lock should be held when called if read
 * the CMMU_SCR or CMMU_SAR.
 */
unsigned
m8820x_cmmu_remote_get(unsigned cpu, unsigned r, unsigned data)
{
	return (*(volatile unsigned *)(r + (char*)&REGS(cpu,data)));
}
@


1.5
log
@Fill the M88100 blanks...
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.4 2001/12/14 01:52:36 miod Exp $	*/
d82 1
a114 2
	m8820x_cmmu_remote_set,
	m8820x_cmmu_remote_get,
@


1.4
log
@This one was way too tricky at (almost) 3am. Now GENERIC enters the link phase.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.3 2001/12/14 01:33:50 miod Exp $	*/
d1083 15
@


1.3
log
@Uncle miod had a GENERIC mvme88k and he wanted the kernel to compile, eieio...
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.2 2001/12/13 19:59:17 miod Exp $	*/
d1804 1
a1804 1
			cmmu_num = cpu_cmmu[cpu].pair[DATA_CMMU] - cmmu;
@


1.2
log
@Steve, please pay attention to warnings.
cpp namespace pollution is BAD.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.1 2001/12/13 08:55:52 smurph Exp $	*/
a77 1
#define STATIC
a79 1
#define STATIC	static
d136 1
a136 1
	m8820x_show_cmmu_info;
d210 1
a210 1
STATIC int      vme188_config;
d213 7
a219 7
STATIC unsigned m8820x_cmmu_get __P((int mmu, int reg));
STATIC void m8820x_cmmu_store __P((int, int, unsigned));
STATIC void m8820x_cmmu_set __P((int, unsigned, int, int, int, int, vm_offset_t));
STATIC void m8820x_cmmu_sync_cache __P((vm_offset_t, int));
STATIC void m8820x_cmmu_sync_inval_cache __P((vm_offset_t, int));
STATIC void m8820x_cmmu_inval_cache __P((vm_offset_t, int));
STATIC int m8820x_cmmu_alive __P((int));
d350 1
a350 1
	switch (cputyp) {
d352 1
a352 1
	case CPU_187:
d369 1
a369 1
	case CPU_188:
d615 1
a615 1
static char *cmmu_strat_string[] = {
d634 1
a634 1
	switch (cputyp) {
d636 1
a636 1
	case CPU_187:
d640 1
a640 1
	case CPU_188:
d666 1
a666 1
STATIC void 
d674 1
a674 1
STATIC int 
d681 1
a681 1
STATIC unsigned 
d692 1
a692 1
STATIC void 
d754 1
a754 1
static char *mmutypes[8] = {
d918 1
a918 1
		if (cputyp == CPU_188) {
d983 1
a983 1
		if (cputyp == CPU_188) {
d1347 1
a1347 1
	m8820x__cmmu_flush_remote_cache(cpu, physaddr, size);
d1460 1
a1460 1
static void
d1515 1
a1515 1
static void 
d1570 1
a1570 1
static void
@


1.1
log
@Support for MVME197 completed.  Fix SPL defs.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.9 2001/06/14 21:30:45 miod Exp $	*/
d429 2
a430 1
			if (id.m88200.type != M88200 && id.m88200.type != M88204) {
d459 1
a459 1
		if (id.m88200.type == M88204)
d850 1
a850 1
			if (id.m88200.type == M88204) {
@

