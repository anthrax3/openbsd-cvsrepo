head	1.73;
access;
symbols
	SMP_SYNC_A:1.73
	SMP_SYNC_B:1.73
	OPENBSD_3_5:1.72.0.2
	OPENBSD_3_5_BASE:1.72
	OPENBSD_3_4:1.49.0.2
	OPENBSD_3_4_BASE:1.49
	UBC_SYNC_A:1.39
	OPENBSD_3_3:1.39.0.2
	OPENBSD_3_3_BASE:1.39
	OPENBSD_3_2:1.36.0.2
	OPENBSD_3_2_BASE:1.36
	OPENBSD_3_1:1.35.0.2
	OPENBSD_3_1_BASE:1.35
	UBC_SYNC_B:1.36
	UBC:1.29.0.2
	UBC_BASE:1.29
	OPENBSD_3_0:1.23.0.2
	OPENBSD_3_0_BASE:1.23
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.8.0.6
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.4
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	mvme88kport:1.1.1.1
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.73
date	2004.04.29.14.33.27;	author miod;	state dead;
branches;
next	1.72;

1.72
date	2004.01.29.21.39.05;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	2004.01.29.00.41.23;	author miod;	state Exp;
branches;
next	1.70;

1.70
date	2004.01.20.14.34.40;	author miod;	state Exp;
branches;
next	1.69;

1.69
date	2004.01.14.20.46.02;	author miod;	state Exp;
branches;
next	1.68;

1.68
date	2004.01.12.21.33.15;	author miod;	state Exp;
branches;
next	1.67;

1.67
date	2004.01.12.07.46.17;	author miod;	state Exp;
branches;
next	1.66;

1.66
date	2004.01.11.23.52.47;	author miod;	state Exp;
branches;
next	1.65;

1.65
date	2004.01.09.11.03.39;	author miod;	state Exp;
branches;
next	1.64;

1.64
date	2004.01.09.00.24.25;	author miod;	state Exp;
branches;
next	1.63;

1.63
date	2004.01.02.23.45.03;	author miod;	state Exp;
branches;
next	1.62;

1.62
date	2003.12.24.15.30.13;	author miod;	state Exp;
branches;
next	1.61;

1.61
date	2003.12.23.23.36.44;	author miod;	state Exp;
branches;
next	1.60;

1.60
date	2003.12.23.00.40.02;	author miod;	state Exp;
branches;
next	1.59;

1.59
date	2003.12.19.22.30.18;	author miod;	state Exp;
branches;
next	1.58;

1.58
date	2003.11.14.19.05.34;	author miod;	state Exp;
branches;
next	1.57;

1.57
date	2003.10.27.10.46.44;	author miod;	state Exp;
branches;
next	1.56;

1.56
date	2003.10.23.19.06.54;	author miod;	state Exp;
branches;
next	1.55;

1.55
date	2003.10.09.16.30.58;	author miod;	state Exp;
branches;
next	1.54;

1.54
date	2003.10.05.20.27.47;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2003.10.02.10.20.12;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2003.09.26.19.04.30;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2003.09.17.22.22.32;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2003.09.16.20.49.05;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2003.09.06.15.07.43;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2003.09.04.18.14.46;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2003.09.03.20.18.18;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2003.09.03.14.48.57;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2003.09.03.01.15.56;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2003.09.02.20.57.21;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2003.09.02.10.35.53;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2003.09.01.22.51.05;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2003.09.01.18.22.30;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2003.08.09.21.19.59;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2003.01.13.20.12.18;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2003.01.09.22.27.10;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2003.01.03.23.17.43;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2002.05.16.21.11.16;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2002.03.26.01.00.27;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2002.03.14.01.26.40;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2001.12.24.04.12.40;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2001.12.22.17.57.11;	author smurph;	state Exp;
branches;
next	1.31;

1.31
date	2001.12.22.10.34.32;	author smurph;	state Exp;
branches;
next	1.30;

1.30
date	2001.12.20.06.07.28;	author smurph;	state Exp;
branches;
next	1.29;

1.29
date	2001.12.16.23.49.47;	author miod;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	2001.12.13.08.55.52;	author smurph;	state Exp;
branches;
next	1.27;

1.27
date	2001.11.28.16.13.29;	author art;	state Exp;
branches;
next	1.26;

1.26
date	2001.11.28.13.47.39;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2001.11.07.22.32.29;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2001.11.06.19.53.15;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2001.09.19.20.50.57;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2001.09.14.14.58.44;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2001.08.31.01.52.22;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2001.08.31.01.06.29;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2001.08.26.14.31.12;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2001.08.24.22.52.22;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.27.04.29.21;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.05.20.56.47;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2001.03.12.23.00.40;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.09.05.44.42;	author smurph;	state Exp;
branches;
next	1.13;

1.13
date	2001.03.08.00.03.31;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.01.03.38.22;	author smurph;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.13.05.19.00;	author smurph;	state Exp;
branches;
next	1.10;

1.10
date	2000.11.10.18.15.40;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.08.22.25.21;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	99.09.27.19.13.24;	author smurph;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	99.05.29.04.41.47;	author smurph;	state Exp;
branches;
next	1.6;

1.6
date	99.02.09.06.36.30;	author smurph;	state Exp;
branches;
next	1.5;

1.5
date	98.12.15.05.11.03;	author smurph;	state Exp;
branches;
next	1.4;

1.4
date	97.03.03.20.21.53;	author rahnds;	state Exp;
branches;
next	1.3;

1.3
date	97.03.03.19.08.17;	author rahnds;	state dead;
branches;
next	1.2;

1.2
date	96.01.12.16.45.16;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.12.32.35;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.03.03.19.32.12;	author rahnds;	state Exp;
branches;
next	;

1.8.4.1
date	2001.04.18.16.11.40;	author niklas;	state Exp;
branches;
next	1.8.4.2;

1.8.4.2
date	2001.07.04.10.20.23;	author niklas;	state Exp;
branches;
next	1.8.4.3;

1.8.4.3
date	2001.10.31.03.01.20;	author nate;	state Exp;
branches;
next	1.8.4.4;

1.8.4.4
date	2001.11.13.21.04.15;	author niklas;	state Exp;
branches;
next	1.8.4.5;

1.8.4.5
date	2001.12.05.00.39.13;	author niklas;	state Exp;
branches;
next	1.8.4.6;

1.8.4.6
date	2002.03.06.02.04.45;	author niklas;	state Exp;
branches;
next	1.8.4.7;

1.8.4.7
date	2002.03.28.10.36.03;	author niklas;	state Exp;
branches;
next	1.8.4.8;

1.8.4.8
date	2003.03.27.23.32.19;	author niklas;	state Exp;
branches;
next	1.8.4.9;

1.8.4.9
date	2004.02.19.10.49.08;	author niklas;	state Exp;
branches;
next	1.8.4.10;

1.8.4.10
date	2004.06.05.23.09.51;	author niklas;	state dead;
branches;
next	;

1.29.2.1
date	2002.01.31.22.55.19;	author niklas;	state Exp;
branches;
next	1.29.2.2;

1.29.2.2
date	2002.06.11.03.37.11;	author art;	state Exp;
branches;
next	1.29.2.3;

1.29.2.3
date	2003.05.19.21.45.53;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.73
log
@Continue factorizing m88k common code, this time files in <arch>/<arch>
which were copied verbatim from mvme88k to luna88k.

This requires backing out syntactic sugar in mvme88k kernel configuration
files which would deduct the required processor types from the board models,
as the common code only depends upon the M88100 and M88110 defines.
@
text
@/*	$OpenBSD: trap.c,v 1.72 2004/01/29 21:39:05 deraadt Exp $	*/
/*
 * Copyright (c) 1998 Steve Murphree, Jr.
 * Copyright (c) 1996 Nivas Madhur
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Nivas Madhur.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
/*
 * Mach Operating System
 * Copyright (c) 1991 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/user.h>
#include <sys/syscall.h>
#include <sys/systm.h>
#include <sys/ktrace.h>

#include "systrace.h"
#include <dev/systrace.h>

#include <uvm/uvm_extern.h>

#include <machine/asm_macro.h>   /* enable/disable interrupts */
#include <machine/cpu.h>
#include <machine/locore.h>
#ifdef M88100
#include <machine/m88100.h>		/* DMT_xxx */
#include <machine/m8820x.h>		/* CMMU_PFSR_xxx */
#endif
#ifdef M88110
#include <machine/m88110.h>
#endif
#include <machine/pcb.h>		/* FIP_E, etc. */
#include <machine/psl.h>		/* FIP_E, etc. */
#include <machine/trap.h>

#include <machine/db_machdep.h>
#ifdef DDB
#include <ddb/db_output.h>		/* db_printf()		*/
#endif /* DDB */
#define SSBREAKPOINT (0xF000D1F8U) /* Single Step Breakpoint */

#ifdef DDB
#define DEBUG_MSG(x) db_printf x
#else
#define DEBUG_MSG(x)
#endif /* DDB */

#define USERMODE(PSR)   (((PSR) & PSR_MODE) == 0)
#define SYSTEMMODE(PSR) (((PSR) & PSR_MODE) != 0)

/* sigh */
extern int procfs_domem(struct proc *, struct proc *, void *, struct uio *);

__dead void panictrap(int, struct trapframe *);
__dead void error_fatal(struct trapframe *);

extern void regdump(struct trapframe *f);

const char *trap_type[] = {
	"Reset",
	"Interrupt Exception",
	"Instruction Access",
	"Data Access Exception",
	"Misaligned Access",
	"Unimplemented Opcode",
	"Privilege Violation"
	"Bounds Check Violation",
	"Illegal Integer Divide",
	"Integer Overflow",
	"Error Exception",
	"Non-Maskable Exception",
};
const int trap_types = sizeof trap_type / sizeof trap_type[0];

const char *pbus_exception_type[] = {
	"Success (No Fault)",
	"unknown 1",
	"unknown 2",
	"Bus Error",
	"Segment Fault",
	"Page Fault",
	"Supervisor Violation",
	"Write Violation",
};

static inline void
userret(struct proc *p, struct trapframe *frame, u_quad_t oticks)
{
	int sig;

	/* take pending signals */
	while ((sig = CURSIG(p)) != 0)
		postsig(sig);
	p->p_priority = p->p_usrpri;

	if (want_resched) {
		/*
		 * We're being preempted.
		 */
		preempt(NULL);
		while ((sig = CURSIG(p)) != 0)
			postsig(sig);
	}

	/*
	 * If profiling, charge recent system time to the trapped pc.
	 */
	if (p->p_flag & P_PROFIL) {
		extern int psratio;

		addupc_task(p, frame->tf_sxip & XIP_ADDR,
		    (int)(p->p_sticks - oticks) * psratio);
	}
	curpriority = p->p_priority;
}

__dead void
panictrap(int type, struct trapframe *frame)
{
#ifdef DDB
	static int panicing = 0;

	if (panicing++ == 0) {
		switch (cputyp) {
#ifdef M88100
		case CPU_88100:
			if (type == 2) {
				/* instruction exception */
				db_printf("\nInstr access fault (%s) v = %x, "
				    "frame %p\n",
				    pbus_exception_type[
				      CMMU_PFSR_FAULT(frame->tf_ipfsr)],
				    frame->tf_sxip & XIP_ADDR, frame);
			} else if (type == 3) {
				/* data access exception */
				db_printf("\nData access fault (%s) v = %x, "
				    "frame %p\n",
				    pbus_exception_type[
				      CMMU_PFSR_FAULT(frame->tf_dpfsr)],
				    frame->tf_sxip & XIP_ADDR, frame);
			} else
				db_printf("\nTrap type %d, v = %x, frame %p\n",
				    type, frame->tf_sxip & XIP_ADDR, frame);
			break;
#endif
#ifdef M88110
		case CPU_88110:
			db_printf("\nTrap type %d, v = %x, frame %p\n",
			    type, frame->tf_exip, frame);
			break;
#endif
		}
		regdump(frame);
	}
#endif
	if ((u_int)type < trap_types)
		panic(trap_type[type]);
	else
		panic("trap %d", type);
	/*NOTREACHED*/
}

#ifdef M88100
void
m88100_trap(unsigned type, struct trapframe *frame)
{
	struct proc *p;
	u_quad_t sticks = 0;
	struct vm_map *map;
	vaddr_t va;
	vm_prot_t ftype;
	int fault_type, pbus_type;
	u_long fault_code;
	unsigned nss, fault_addr;
	struct vmspace *vm;
	union sigval sv;
	int result;
#ifdef DDB
	int s;
#endif
	int sig = 0;

	extern struct vm_map *kernel_map;
	extern caddr_t guarded_access_start;
	extern caddr_t guarded_access_end;
	extern caddr_t guarded_access_bad;

	uvmexp.traps++;
	if ((p = curproc) == NULL)
		p = &proc0;

	if (USERMODE(frame->tf_epsr)) {
		sticks = p->p_sticks;
		type += T_USER;
		p->p_md.md_tf = frame;	/* for ptrace/signals */
	}
	fault_type = 0;
	fault_code = 0;
	fault_addr = frame->tf_sxip & XIP_ADDR;

	switch (type) {
	default:
		panictrap(frame->tf_vector, frame);
		break;
		/*NOTREACHED*/

#if defined(DDB)
	case T_KDB_BREAK:
		s = splhigh();
		db_enable_interrupt();
		ddb_break_trap(T_KDB_BREAK, (db_regs_t*)frame);
		db_disable_interrupt();
		splx(s);
		return;
	case T_KDB_ENTRY:
		s = splhigh();
		db_enable_interrupt();
		ddb_entry_trap(T_KDB_ENTRY, (db_regs_t*)frame);
		db_disable_interrupt();
		splx(s);
		return;
#endif /* DDB */
	case T_ILLFLT:
		DEBUG_MSG(("Unimplemented opcode!\n"));
		panictrap(frame->tf_vector, frame);
		break;
	case T_INT:
	case T_INT+T_USER:
		/* This function pointer is set in machdep.c
		   It calls m188_ext_int or sbc_ext_int depending
		   on the value of brdtyp - smurph */
		(*md.interrupt_func)(T_INT, frame);
		return;

	case T_MISALGNFLT:
		DEBUG_MSG(("kernel misaligned "
			  "access exception @@ 0x%08x\n", frame->tf_sxip));
		panictrap(frame->tf_vector, frame);
		break;

	case T_INSTFLT:
		/* kernel mode instruction access fault.
		 * Should never, never happen for a non-paged kernel.
		 */
#ifdef TRAPDEBUG
		pbus_type = CMMU_PFSR_FAULT(frame->tf_ipfsr);
		printf("Kernel Instruction fault #%d (%s) v = 0x%x, frame 0x%x cpu %d\n",
		    pbus_type, pbus_exception_type[pbus_type],
		    fault_addr, frame, frame->tf_cpu);
#endif
		panictrap(frame->tf_vector, frame);
		break;

	case T_DATAFLT:
		/* kernel mode data fault */

		/* data fault on the user address? */
		if ((frame->tf_dmt0 & DMT_DAS) == 0) {
			type = T_DATAFLT + T_USER;
			goto user_fault;
		}

		fault_addr = frame->tf_dma0;
		if (frame->tf_dmt0 & (DMT_WRITE|DMT_LOCKBAR)) {
			ftype = VM_PROT_READ|VM_PROT_WRITE;
			fault_code = VM_PROT_WRITE;
		} else {
			ftype = VM_PROT_READ;
			fault_code = VM_PROT_READ;
		}

		va = trunc_page((vaddr_t)fault_addr);
		if (va == 0) {
			panic("trap: bad kernel access at %x", fault_addr);
		}

		vm = p->p_vmspace;
		map = kernel_map;

		pbus_type = CMMU_PFSR_FAULT(frame->tf_dpfsr);
#ifdef TRAPDEBUG
		printf("Kernel Data access fault #%d (%s) v = 0x%x, frame 0x%x cpu %d\n",
		    pbus_type, pbus_exception_type[pbus_type],
		    fault_addr, frame, frame->tf_cpu);
#endif

		switch (pbus_type) {
		case CMMU_PFSR_BERROR:
			/*
		 	 * If it is a guarded access, bus error is OK.
		 	 */
			if ((frame->tf_sxip & XIP_ADDR) >=
			      (unsigned)&guarded_access_start &&
			    (frame->tf_sxip & XIP_ADDR) <=
			      (unsigned)&guarded_access_end) {
				frame->tf_snip =
				  ((unsigned)&guarded_access_bad    ) | NIP_V;
				frame->tf_sfip =
				  ((unsigned)&guarded_access_bad + 4) | FIP_V;
				frame->tf_sxip = 0;
				/* We sort of resolved the fault ourselves
				 * because we know where it came from
				 * [guarded_access()]. But we must still think
				 * about the other possible transactions in
				 * dmt1 & dmt2.  Mark dmt0 so that
				 * data_access_emulation skips it.  XXX smurph
				 */
				frame->tf_dmt0 |= DMT_SKIP;
				data_access_emulation((unsigned *)frame);
				frame->tf_dpfsr = 0;
				frame->tf_dmt0 = 0;
				return;
			}
			break;
		case CMMU_PFSR_SUCCESS:
			/*
			 * The fault was resolved. Call data_access_emulation
			 * to drain the data unit pipe line and reset dmt0
			 * so that trap won't get called again.
			 */
			data_access_emulation((unsigned *)frame);
			frame->tf_dpfsr = 0;
			frame->tf_dmt0 = 0;
			return;
		case CMMU_PFSR_SFAULT:
		case CMMU_PFSR_PFAULT:
			result = uvm_fault(map, va, VM_FAULT_INVALID, ftype);
			if (result == 0) {
				/*
				 * We could resolve the fault. Call
				 * data_access_emulation to drain the data
				 * unit pipe line and reset dmt0 so that trap
				 * won't get called again.
				 */
				data_access_emulation((unsigned *)frame);
				frame->tf_dpfsr = 0;
				frame->tf_dmt0 = 0;
				return;
			}
			break;
		}
#ifdef TRAPDEBUG
		printf("PBUS Fault %d (%s) va = 0x%x\n", pbus_type,
		    pbus_exception_type[pbus_type], va);
#endif
		panictrap(frame->tf_vector, frame);
		/* NOTREACHED */
	case T_INSTFLT+T_USER:
		/* User mode instruction access fault */
		/* FALLTHROUGH */
	case T_DATAFLT+T_USER:
user_fault:
		if (type == T_INSTFLT + T_USER) {
			pbus_type = CMMU_PFSR_FAULT(frame->tf_ipfsr);
#ifdef TRAPDEBUG
			printf("User Instruction fault #%d (%s) v = 0x%x, frame 0x%x cpu %d\n",
			    pbus_type, pbus_exception_type[pbus_type],
			    fault_addr, frame, frame->tf_cpu);
#endif
		} else {
			fault_addr = frame->tf_dma0;
			pbus_type = CMMU_PFSR_FAULT(frame->tf_dpfsr);
#ifdef TRAPDEBUG
			printf("User Data access fault #%d (%s) v = 0x%x, frame 0x%x cpu %d\n",
			    pbus_type, pbus_exception_type[pbus_type],
			    fault_addr, frame, frame->tf_cpu);
#endif
		}

		if (frame->tf_dmt0 & (DMT_WRITE | DMT_LOCKBAR)) {
			ftype = VM_PROT_READ | VM_PROT_WRITE;
			fault_code = VM_PROT_WRITE;
		} else {
			ftype = VM_PROT_READ;
			fault_code = VM_PROT_READ;
		}

		va = trunc_page((vaddr_t)fault_addr);

		vm = p->p_vmspace;
		map = &vm->vm_map;

		/* Call uvm_fault() to resolve non-bus error faults */
		switch (pbus_type) {
		case CMMU_PFSR_SUCCESS:
			result = 0;
			break;
		case CMMU_PFSR_BERROR:
			result = EACCES;
			break;
		default:
			result = uvm_fault(map, va, VM_FAULT_INVALID, ftype);
			if (result == EACCES)
				result = EFAULT;
			break;
		}

		if ((caddr_t)va >= vm->vm_maxsaddr) {
			if (result == 0) {
				nss = btoc(USRSTACK - va);/* XXX check this */
				if (nss > vm->vm_ssize)
					vm->vm_ssize = nss;
			}
		}

		/*
		 * This could be a fault caused in copyin*()
		 * while accessing user space.
		 */
		if (result != 0 && p->p_addr->u_pcb.pcb_onfault != NULL) {
			frame->tf_snip = p->p_addr->u_pcb.pcb_onfault | NIP_V;
			frame->tf_sfip = (p->p_addr->u_pcb.pcb_onfault + 4) | FIP_V;
			frame->tf_sxip = 0;
			/*
			 * Continue as if the fault had been resolved, but
			 * do not try to complete the faulting access.
			 */
			frame->tf_dmt0 |= DMT_SKIP;
			result = 0;
		}

		if (result == 0) {
			if (type == T_DATAFLT+T_USER) {
				/*
			 	 * We could resolve the fault. Call
			 	 * data_access_emulation to drain the data unit
			 	 * pipe line and reset dmt0 so that trap won't
			 	 * get called again.
			 	 */
				data_access_emulation((unsigned *)frame);
				frame->tf_dpfsr = 0;
				frame->tf_dmt0 = 0;
			} else {
				/*
				 * back up SXIP, SNIP,
				 * clearing the Error bit
				 */
				frame->tf_sfip = frame->tf_snip & ~FIP_E;
				frame->tf_snip = frame->tf_sxip & ~NIP_E;
				frame->tf_ipfsr = 0;
			}
		} else {
			sig = result == EACCES ? SIGBUS : SIGSEGV;
			fault_type = result == EACCES ?
			    BUS_ADRERR : SEGV_MAPERR;
		}
		break;
	case T_MISALGNFLT+T_USER:
		sig = SIGBUS;
		fault_type = BUS_ADRALN;
		break;
	case T_PRIVINFLT+T_USER:
	case T_ILLFLT+T_USER:
#ifndef DDB
	case T_KDB_BREAK:
	case T_KDB_ENTRY:
#endif
	case T_KDB_BREAK+T_USER:
	case T_KDB_ENTRY+T_USER:
	case T_KDB_TRACE:
	case T_KDB_TRACE+T_USER:
		sig = SIGILL;
		break;
	case T_BNDFLT+T_USER:
		sig = SIGFPE;
		break;
	case T_ZERODIV+T_USER:
		sig = SIGFPE;
		fault_type = FPE_INTDIV;
		break;
	case T_OVFFLT+T_USER:
		sig = SIGFPE;
		fault_type = FPE_INTOVF;
		break;
	case T_FPEPFLT+T_USER:
	case T_FPEIFLT+T_USER:
		sig = SIGFPE;
		break;
	case T_SIGSYS+T_USER:
		sig = SIGSYS;
		break;
	case T_SIGTRAP+T_USER:
		sig = SIGTRAP;
		fault_type = TRAP_TRACE;
		break;
	case T_STEPBPT+T_USER:
		/*
		 * This trap is used by the kernel to support single-step
		 * debugging (although any user could generate this trap
		 * which should probably be handled differently). When a
		 * process is continued by a debugger with the PT_STEP
		 * function of ptrace (single step), the kernel inserts
		 * one or two breakpoints in the user process so that only
		 * one instruction (or two in the case of a delayed branch)
		 * is executed.  When this breakpoint is hit, we get the
		 * T_STEPBPT trap.
		 */
		{
			unsigned va;
			unsigned instr;
			struct uio uio;
			struct iovec iov;
			unsigned pc = PC_REGS(&frame->tf_regs);

			/* read break instruction */
			copyin((caddr_t)pc, &instr, sizeof(unsigned));
#if 0
			printf("trap: %s (%d) breakpoint %x at %x: (adr %x ins %x)\n",
			       p->p_comm, p->p_pid, instr, pc,
			       p->p_md.md_ss_addr, p->p_md.md_ss_instr); /* XXX */
#endif
			/* check and see if we got here by accident */
			if ((p->p_md.md_ss_addr != pc &&
			     p->p_md.md_ss_taken_addr != pc) ||
			    instr != SSBREAKPOINT) {
				sig = SIGTRAP;
				fault_type = TRAP_TRACE;
				break;
			}
			/* restore original instruction and clear BP  */
			instr = p->p_md.md_ss_instr;
			va = p->p_md.md_ss_addr;
			if (va != 0) {
				iov.iov_base = (caddr_t)&instr;
				iov.iov_len = sizeof(int);
				uio.uio_iov = &iov;
				uio.uio_iovcnt = 1;
				uio.uio_offset = (off_t)va;
				uio.uio_resid = sizeof(int);
				uio.uio_segflg = UIO_SYSSPACE;
				uio.uio_rw = UIO_WRITE;
				uio.uio_procp = curproc;
				procfs_domem(p, p, NULL, &uio);
			}

			/* branch taken instruction */
			instr = p->p_md.md_ss_taken_instr;
			va = p->p_md.md_ss_taken_addr;
			if (instr != 0) {
				iov.iov_base = (caddr_t)&instr;
				iov.iov_len = sizeof(int);
				uio.uio_iov = &iov;
				uio.uio_iovcnt = 1;
				uio.uio_offset = (off_t)va;
				uio.uio_resid = sizeof(int);
				uio.uio_segflg = UIO_SYSSPACE;
				uio.uio_rw = UIO_WRITE;
				uio.uio_procp = curproc;
				procfs_domem(p, p, NULL, &uio);
			}
#if 1
			frame->tf_sfip = frame->tf_snip;    /* set up next FIP */
			frame->tf_snip = pc;    /* set up next NIP */
			frame->tf_snip |= 2;	  /* set valid bit   */
#endif
			p->p_md.md_ss_addr = 0;
			p->p_md.md_ss_instr = 0;
			p->p_md.md_ss_taken_addr = 0;
			p->p_md.md_ss_taken_instr = 0;
			sig = SIGTRAP;
			fault_type = TRAP_BRKPT;
		}
		break;

	case T_USERBPT+T_USER:
		/*
		 * This trap is meant to be used by debuggers to implement
		 * breakpoint debugging.  When we get this trap, we just
		 * return a signal which gets caught by the debugger.
		 */
		frame->tf_sfip = frame->tf_snip;    /* set up the next FIP */
		frame->tf_snip = frame->tf_sxip;    /* set up the next NIP */
		sig = SIGTRAP;
		fault_type = TRAP_BRKPT;
		break;

	case T_ASTFLT+T_USER:
		uvmexp.softs++;
		want_ast = 0;
		if (p->p_flag & P_OWEUPC) {
			p->p_flag &= ~P_OWEUPC;
			ADDUPROF(p);
		}
		break;
	}

	/*
	 * If trap from supervisor mode, just return
	 */
	if (type < T_USER)
		return;

	if (sig) {
		sv.sival_int = fault_addr;
		trapsignal(p, sig, fault_code, fault_type, sv);
		/*
		 * don't want multiple faults - we are going to
		 * deliver signal.
		 */
		frame->tf_dmt0 = 0;
		frame->tf_ipfsr = frame->tf_dpfsr = 0;
	}

	userret(p, frame, sticks);
}
#endif /* m88100 */

#ifdef M88110
void
m88110_trap(unsigned type, struct trapframe *frame)
{
	struct proc *p;
	u_quad_t sticks = 0;
	struct vm_map *map;
	vaddr_t va;
	vm_prot_t ftype;
	int fault_type;
	u_long fault_code;
	unsigned nss, fault_addr;
	struct vmspace *vm;
	union sigval sv;
	int result;
#ifdef DDB
        int s; /* IPL */
#endif
	int sig = 0;
	pt_entry_t *pte;

	extern struct vm_map *kernel_map;
	extern unsigned guarded_access_start;
	extern unsigned guarded_access_end;
	extern unsigned guarded_access_bad;
	extern pt_entry_t *pmap_pte(pmap_t, vaddr_t);

	uvmexp.traps++;
	if ((p = curproc) == NULL)
		p = &proc0;

	if (USERMODE(frame->tf_epsr)) {
		sticks = p->p_sticks;
		type += T_USER;
		p->p_md.md_tf = frame;	/* for ptrace/signals */
	}
	fault_type = 0;
	fault_code = 0;
	fault_addr = frame->tf_exip & XIP_ADDR;

	switch (type) {
	default:
		panictrap(frame->tf_vector, frame);
		break;
		/*NOTREACHED*/

	case T_197_READ+T_USER:
	case T_197_READ:
		DEBUG_MSG(("DMMU read miss: Hardware Table Searches should be enabled!\n"));
		panictrap(frame->tf_vector, frame);
		break;
		/*NOTREACHED*/
	case T_197_WRITE+T_USER:
	case T_197_WRITE:
		DEBUG_MSG(("DMMU write miss: Hardware Table Searches should be enabled!\n"));
		panictrap(frame->tf_vector, frame);
		break;
		/*NOTREACHED*/
	case T_197_INST+T_USER:
	case T_197_INST:
		DEBUG_MSG(("IMMU miss: Hardware Table Searches should be enabled!\n"));
		panictrap(frame->tf_vector, frame);
		break;
		/*NOTREACHED*/
#ifdef DDB
	case T_KDB_TRACE:
		s = splhigh();
		db_enable_interrupt();
		ddb_break_trap(T_KDB_TRACE, (db_regs_t*)frame);
		db_disable_interrupt();
		splx(s);
		return;
	case T_KDB_BREAK:
		s = splhigh();
		db_enable_interrupt();
		ddb_break_trap(T_KDB_BREAK, (db_regs_t*)frame);
		db_disable_interrupt();
		splx(s);
		return;
	case T_KDB_ENTRY:
		s = splhigh();
		db_enable_interrupt();
		ddb_entry_trap(T_KDB_ENTRY, (db_regs_t*)frame);
		db_disable_interrupt();
		/* skip one instruction */
		if (frame->tf_exip & 1)
			frame->tf_exip = frame->tf_enip;
		else
			frame->tf_exip += 4;
		frame->tf_enip = 0;
		splx(s);
		return;
#if 0
	case T_ILLFLT:
		s = splhigh();
		db_enable_interrupt();
		ddb_error_trap(type == T_ILLFLT ? "unimplemented opcode" :
		       "error fault", (db_regs_t*)frame);
		db_disable_interrupt();
		splx(s);
		return;
#endif /* 0 */
#endif /* DDB */
	case T_ILLFLT:
		DEBUG_MSG(("Unimplemented opcode!\n"));
		panictrap(frame->tf_vector, frame);
		break;
	case T_NON_MASK:
	case T_NON_MASK+T_USER:
		/* This function pointer is set in machdep.c
		   It calls m197_ext_int - smurph */
		(*md.interrupt_func)(T_NON_MASK, frame);
		return;
	case T_INT:
	case T_INT+T_USER:
		(*md.interrupt_func)(T_INT, frame);
		return;
	case T_MISALGNFLT:
		DEBUG_MSG(("kernel mode misaligned "
			  "access exception @@ 0x%08x\n", frame->tf_exip));
		panictrap(frame->tf_vector, frame);
		break;
		/*NOTREACHED*/

	case T_INSTFLT:
		/* kernel mode instruction access fault.
		 * Should never, never happen for a non-paged kernel.
		 */
#ifdef TRAPDEBUG
		printf("Kernel Instruction fault exip %x isr %x ilar %x\n",
		    frame->tf_exip, frame->tf_isr, frame->tf_ilar);
#endif
		panictrap(frame->tf_vector, frame);
		break;
		/*NOTREACHED*/

	case T_DATAFLT:
		/* kernel mode data fault */

		/* data fault on the user address? */
		if ((frame->tf_dsr & CMMU_DSR_SU) == 0) {
			type = T_DATAFLT + T_USER;
			goto m88110_user_fault;
		}

#ifdef TRAPDEBUG
		printf("Kernel Data access fault exip %x dsr %x dlar %x\n",
		    frame->tf_exip, frame->tf_dsr, frame->tf_dlar);
#endif

		fault_addr = frame->tf_dlar;
		if (frame->tf_dsr & CMMU_DSR_RW) {
			ftype = VM_PROT_READ;
			fault_code = VM_PROT_READ;
		} else {
			ftype = VM_PROT_READ|VM_PROT_WRITE;
			fault_code = VM_PROT_WRITE;
		}

		va = trunc_page((vaddr_t)fault_addr);
		if (va == 0) {
			panic("trap: bad kernel access at %x", fault_addr);
		}

		vm = p->p_vmspace;
		map = kernel_map;

		if (frame->tf_dsr & CMMU_DSR_BE) {
			/*
			 * If it is a guarded access, bus error is OK.
			 */
			if ((frame->tf_exip & XIP_ADDR) >=
			      (unsigned)&guarded_access_start &&
			    (frame->tf_exip & XIP_ADDR) <=
			      (unsigned)&guarded_access_end) {
				frame->tf_exip = (unsigned)&guarded_access_bad;
				frame->tf_enip = 0;
				return;
			}
		}
		if (frame->tf_dsr & (CMMU_DSR_SI | CMMU_DSR_PI)) {
			frame->tf_dsr &= ~CMMU_DSR_WE;	/* undefined */
			/*
			 * On a segment or a page fault, call uvm_fault() to
			 * resolve the fault.
			 */
			result = uvm_fault(map, va, VM_FAULT_INVALID, ftype);
			if (result == 0)
				return;
		}
		if (frame->tf_dsr & CMMU_DSR_WE) {	/* write fault  */
			/*
			 * This could be a write protection fault or an
			 * exception to set the used and modified bits
			 * in the pte. Basically, if we got a write error,
			 * then we already have a pte entry that faulted
			 * in from a previous seg fault or page fault.
			 * Get the pte and check the status of the
			 * modified and valid bits to determine if this
			 * indeed a real write fault.  XXX smurph
			 */
			pte = pmap_pte(map->pmap, va);
			if (pte == PT_ENTRY_NULL)
				panic("NULL pte on write fault??");
			if (!(*pte & PG_M) && !(*pte & PG_RO)) {
				/* Set modified bit and try the write again. */
#ifdef TRAPDEBUG
				printf("Corrected kernel write fault, map %x pte %x\n",
				    map->pmap, *pte);
#endif
				*pte |= PG_M;
				return;
#if 1	/* shouldn't happen */
			} else {
				/* must be a real wp fault */
#ifdef TRAPDEBUG
				printf("Uncorrected kernel write fault, map %x pte %x\n",
				    map->pmap, *pte);
#endif
				result = uvm_fault(map, va, VM_FAULT_INVALID, ftype);
				if (result == 0)
					return;
#endif
			}
		}
		panictrap(frame->tf_vector, frame);
		/* NOTREACHED */
	case T_INSTFLT+T_USER:
		/* User mode instruction access fault */
		/* FALLTHROUGH */
	case T_DATAFLT+T_USER:
m88110_user_fault:
		if (type == T_INSTFLT+T_USER) {
			ftype = VM_PROT_READ;
			fault_code = VM_PROT_READ;
#ifdef TRAPDEBUG
			printf("User Instruction fault exip %x isr %x ilar %x\n",
			    frame->tf_exip, frame->tf_isr, frame->tf_ilar);
#endif
		} else {
			fault_addr = frame->tf_dlar;
			if (frame->tf_dsr & CMMU_DSR_RW) {
				ftype = VM_PROT_READ;
				fault_code = VM_PROT_READ;
			} else {
				ftype = VM_PROT_READ|VM_PROT_WRITE;
				fault_code = VM_PROT_WRITE;
			}
#ifdef TRAPDEBUG
			printf("User Data access fault exip %x dsr %x dlar %x\n",
			    frame->tf_exip, frame->tf_dsr, frame->tf_dlar);
#endif
		}

		va = trunc_page((vaddr_t)fault_addr);

		vm = p->p_vmspace;
		map = &vm->vm_map;

		/*
		 * Call uvm_fault() to resolve non-bus error faults
		 * whenever possible.
		 */
		if (type == T_DATAFLT+T_USER) {
			/* data faults */
			if (frame->tf_dsr & CMMU_DSR_BE) {
				/* bus error */
				result = EACCES;
			} else
			if (frame->tf_dsr & (CMMU_DSR_SI | CMMU_DSR_PI)) {
				/* segment or page fault */
				result = uvm_fault(map, va, VM_FAULT_INVALID, ftype);
				if (result == EACCES)
					result = EFAULT;
			} else
			if (frame->tf_dsr & (CMMU_DSR_CP | CMMU_DSR_WA)) {
				/* copyback or write allocate error */
				result = 0;
			} else
			if (frame->tf_dsr & CMMU_DSR_WE) {
				/* write fault  */
				/* This could be a write protection fault or an
				 * exception to set the used and modified bits
				 * in the pte. Basically, if we got a write
				 * error, then we already have a pte entry that
				 * faulted in from a previous seg fault or page
				 * fault.
				 * Get the pte and check the status of the
				 * modified and valid bits to determine if this
				 * indeed a real write fault.  XXX smurph
				 */
				pte = pmap_pte(vm_map_pmap(map), va);
#ifdef DEBUG
				if (pte == PT_ENTRY_NULL)
					panic("NULL pte on write fault??");
#endif
				if (!(*pte & PG_M) && !(*pte & PG_RO)) {
					/*
					 * Set modified bit and try the
					 * write again.
					 */
#ifdef TRAPDEBUG
					printf("Corrected userland write fault, map %x pte %x\n",
					    map->pmap, *pte);
#endif
					*pte |= PG_M;
					/*
					 * invalidate ATCs to force
					 * table search
					 */
					set_dcmd(CMMU_DCMD_INV_UATC);
					return;
				} else {
					/* must be a real wp fault */
#ifdef TRAPDEBUG
					printf("Uncorrected userland write fault, map %x pte %x\n",
					    map->pmap, *pte);
#endif
					result = uvm_fault(map, va, VM_FAULT_INVALID, ftype);
					if (result == EACCES)
						result = EFAULT;
				}
			} else {
#ifdef TRAPDEBUG
				printf("Unexpected Data access fault dsr %x\n",
				    frame->tf_dsr);
#endif
				panictrap(frame->tf_vector, frame);
			}
		} else {
			/* instruction faults */
			if (frame->tf_isr &
			    (CMMU_ISR_BE | CMMU_ISR_SP | CMMU_ISR_TBE)) {
				/* bus error, supervisor protection */
				result = EACCES;
			} else
			if (frame->tf_isr & (CMMU_ISR_SI | CMMU_ISR_PI)) {
				/* segment or page fault */
				result = uvm_fault(map, va, VM_FAULT_INVALID, ftype);
				if (result == EACCES)
					result = EFAULT;
			} else {
#ifdef TRAPDEBUG
				printf("Unexpected Instruction fault isr %x\n",
				    frame->tf_isr);
#endif
				panictrap(frame->tf_vector, frame);
			}
		}

		if ((caddr_t)va >= vm->vm_maxsaddr) {
			if (result == 0) {
				nss = btoc(USRSTACK - va);/* XXX check this */
				if (nss > vm->vm_ssize)
					vm->vm_ssize = nss;
			}
		}

		/*
		 * This could be a fault caused in copyin*()
		 * while accessing user space.
		 */
		if (result != 0 && p->p_addr->u_pcb.pcb_onfault != NULL) {
			frame->tf_exip = p->p_addr->u_pcb.pcb_onfault;
			frame->tf_enip = 0;
			frame->tf_dsr = frame->tf_isr = 0;
			/*
			 * Continue as if the fault had been resolved.
			 */
			result = 0;
		}

		if (result != 0) {
			sig = result == EACCES ? SIGBUS : SIGSEGV;
			fault_type = result == EACCES ?
			    BUS_ADRERR : SEGV_MAPERR;
		}
		break;
	case T_MISALGNFLT+T_USER:
		sig = SIGBUS;
		fault_type = BUS_ADRALN;
		break;
	case T_PRIVINFLT+T_USER:
	case T_ILLFLT+T_USER:
#ifndef DDB
	case T_KDB_BREAK:
	case T_KDB_ENTRY:
	case T_KDB_TRACE:
#endif
	case T_KDB_BREAK+T_USER:
	case T_KDB_ENTRY+T_USER:
	case T_KDB_TRACE+T_USER:
		sig = SIGILL;
		break;
	case T_BNDFLT+T_USER:
		sig = SIGFPE;
		break;
	case T_ZERODIV+T_USER:
		sig = SIGFPE;
		fault_type = FPE_INTDIV;
		break;
	case T_OVFFLT+T_USER:
		sig = SIGFPE;
		fault_type = FPE_INTOVF;
		break;
	case T_FPEPFLT+T_USER:
	case T_FPEIFLT+T_USER:
		sig = SIGFPE;
		break;
	case T_SIGSYS+T_USER:
		sig = SIGSYS;
		break;
	case T_SIGTRAP+T_USER:
		sig = SIGTRAP;
		fault_type = TRAP_TRACE;
		break;
	case T_STEPBPT+T_USER:
		/*
		 * This trap is used by the kernel to support single-step
		 * debugging (although any user could generate this trap
		 * which should probably be handled differently). When a
		 * process is continued by a debugger with the PT_STEP
		 * function of ptrace (single step), the kernel inserts
		 * one or two breakpoints in the user process so that only
		 * one instruction (or two in the case of a delayed branch)
		 * is executed.  When this breakpoint is hit, we get the
		 * T_STEPBPT trap.
		 */
		{
			unsigned instr;
			struct uio uio;
			struct iovec iov;
			unsigned pc = PC_REGS(&frame->tf_regs);

			/* read break instruction */
			copyin((caddr_t)pc, &instr, sizeof(unsigned));
#if 0
			printf("trap: %s (%d) breakpoint %x at %x: (adr %x ins %x)\n",
			       p->p_comm, p->p_pid, instr, pc,
			       p->p_md.md_ss_addr, p->p_md.md_ss_instr); /* XXX */
#endif
			/* check and see if we got here by accident */
#ifdef notyet
			if (p->p_md.md_ss_addr != pc || instr != SSBREAKPOINT) {
				sig = SIGTRAP;
				fault_type = TRAP_TRACE;
				break;
			}
#endif
			/* restore original instruction and clear BP  */
			/*sig = suiword((caddr_t)pc, p->p_md.md_ss_instr);*/
			instr = p->p_md.md_ss_instr;
			if (instr != 0) {
				iov.iov_base = (caddr_t)&instr;
				iov.iov_len = sizeof(int);
				uio.uio_iov = &iov;
				uio.uio_iovcnt = 1;
				uio.uio_offset = (off_t)pc;
				uio.uio_resid = sizeof(int);
				uio.uio_segflg = UIO_SYSSPACE;
				uio.uio_rw = UIO_WRITE;
				uio.uio_procp = curproc;
			}

			p->p_md.md_ss_addr = 0;
			sig = SIGTRAP;
			fault_type = TRAP_BRKPT;
			break;
		}
	case T_USERBPT+T_USER:
		/*
		 * This trap is meant to be used by debuggers to implement
		 * breakpoint debugging.  When we get this trap, we just
		 * return a signal which gets caught by the debugger.
		 */
		sig = SIGTRAP;
		fault_type = TRAP_BRKPT;
		break;

	case T_ASTFLT+T_USER:
		uvmexp.softs++;
		want_ast = 0;
		if (p->p_flag & P_OWEUPC) {
			p->p_flag &= ~P_OWEUPC;
			ADDUPROF(p);
		}
		break;
	}

	/*
	 * If trap from supervisor mode, just return
	 */
	if (type < T_USER)
		return;

	if (sig) {
		sv.sival_int = fault_addr;
		trapsignal(p, sig, fault_code, fault_type, sv);
		/*
		 * don't want multiple faults - we are going to
		 * deliver signal.
		 */
		frame->tf_dsr = frame->tf_isr = 0;
	}

	userret(p, frame, sticks);
}
#endif /* MVME197 */

__dead void
error_fatal(struct trapframe *frame)
{
#ifdef DDB
	switch (frame->tf_vector) {
	case 0:
		db_printf("\n[RESET EXCEPTION (Really Bad News[tm]) frame %8p]\n", frame);
		db_printf("This is usually caused by a branch to a NULL function pointer.\n");
		db_printf("e.g. jump to address 0.  Use the debugger trace command to track it down.\n");
		break;
	default:
		db_printf("\n[ERROR EXCEPTION (Bad News[tm]) frame %p]\n", frame);
		db_printf("This is usually an exception within an exception.  The trap\n");
		db_printf("frame shadow registers you are about to see are invalid.\n");
		db_printf("(read totally useless)  But R1 to R31 might be interesting.\n");
		break;
	}
	regdump((struct trapframe*)frame);
#endif /* DDB */
	panic("unrecoverable exception %d", frame->tf_vector);
}

#ifdef M88100
void
m88100_syscall(register_t code, struct trapframe *tf)
{
	int i, nsys, nap;
	struct sysent *callp;
	struct proc *p;
	int error;
	register_t args[11], rval[2], *ap;
	u_quad_t sticks;
#ifdef DIAGNOSTIC
	extern struct pcb *curpcb;
#endif

	uvmexp.syscalls++;

	p = curproc;

	callp = p->p_emul->e_sysent;
	nsys  = p->p_emul->e_nsysent;

#ifdef DIAGNOSTIC
	if (USERMODE(tf->tf_epsr) == 0)
		panic("syscall");
	if (curpcb != &p->p_addr->u_pcb)
		panic("syscall curpcb/ppcb");
	if (tf != (struct trapframe *)&curpcb->user_state)
		panic("syscall trapframe");
#endif

	sticks = p->p_sticks;
	p->p_md.md_tf = tf;

	/*
	 * For 88k, all the arguments are passed in the registers (r2-r12)
	 * For syscall (and __syscall), r2 (and r3) has the actual code.
	 * __syscall  takes a quad syscall number, so that other
	 * arguments are at their natural alignments.
	 */
	ap = &tf->tf_r[2];
	nap = 11; /* r2-r12 */

	switch (code) {
	case SYS_syscall:
		code = *ap++;
		nap--;
		break;
	case SYS___syscall:
		if (callp != sysent)
			break;
		code = ap[_QUAD_LOWWORD];
		ap += 2;
		nap -= 2;
		break;
	}

	/* Callp currently points to syscall, which returns ENOSYS. */
	if (code < 0 || code >= nsys)
		callp += p->p_emul->e_nosys;
	else {
		callp += code;
		i = callp->sy_argsize / sizeof(register_t);
		if (i > nap)
			panic("syscall nargs");
		/*
		 * just copy them; syscall stub made sure all the
		 * args are moved from user stack to registers.
		 */
		bcopy((caddr_t)ap, (caddr_t)args, i * sizeof(register_t));
	}

#ifdef SYSCALL_DEBUG
	scdebug_call(p, code, args);
#endif
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSCALL))
		ktrsyscall(p, code, callp->sy_argsize, args);
#endif
	rval[0] = 0;
	rval[1] = 0;
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE))
		error = systrace_redirect(code, p, args, rval);
	else
#endif
		error = (*callp->sy_call)(p, args, rval);
	/*
	 * system call will look like:
	 *	 ld r10, r31, 32; r10,r11,r12 might be garbage.
	 *	 ld r11, r31, 36
	 *	 ld r12, r31, 40
	 *	 or r13, r0, <code>
	 *       tb0 0, r0, <128> <- sxip
	 *	 br err 	  <- snip
	 *       jmp r1 	  <- sfip
	 *  err: or.u r3, r0, hi16(errno)
	 *	 st r2, r3, lo16(errno)
	 *	 subu r2, r0, 1
	 *	 jmp r1
	 *
	 * So, when we take syscall trap, sxip/snip/sfip will be as
	 * shown above.
	 * Given this,
	 * 1. If the system call returned 0, need to skip nip.
	 *	nip = fip, fip += 4
	 *    (doesn't matter what fip + 4 will be but we will never
	 *    execute this since jmp r1 at nip will change the execution flow.)
	 * 2. If the system call returned an errno > 0, plug the value
	 *    in r2, and leave nip and fip unchanged. This will have us
	 *    executing "br err" on return to user space.
	 * 3. If the system call code returned ERESTART,
	 *    we need to rexecute the trap instruction. Back up the pipe
	 *    line.
	 *     fip = nip, nip = xip
	 * 4. If the system call returned EJUSTRETURN, don't need to adjust
	 *    any pointers.
	 */

	switch (error) {
	case 0:
		/*
		 * If fork succeeded and we are the child, our stack
		 * has moved and the pointer tf is no longer valid,
		 * and p is wrong.  Compute the new trapframe pointer.
		 * (The trap frame invariably resides at the
		 * tippity-top of the u. area.)
		 */
		p = curproc;
		tf = (struct trapframe *)USER_REGS(p);
		tf->tf_r[2] = rval[0];
		tf->tf_r[3] = rval[1];
		tf->tf_epsr &= ~PSR_C;
		tf->tf_snip = tf->tf_sfip & ~NIP_E;
		tf->tf_sfip = tf->tf_snip + 4;
		break;
	case ERESTART:
		/*
		 * If (error == ERESTART), back up the pipe line. This
		 * will end up reexecuting the trap.
		 */
		tf->tf_epsr &= ~PSR_C;
		tf->tf_sfip = tf->tf_snip & ~FIP_E;
		tf->tf_snip = tf->tf_sxip & ~NIP_E;
		break;
	case EJUSTRETURN:
		/* if (error == EJUSTRETURN), leave the ip's alone */
		tf->tf_epsr &= ~PSR_C;
		break;
	default:
		/* error != ERESTART && error != EJUSTRETURN*/
		if (p->p_emul->e_errno)
			error = p->p_emul->e_errno[error];
		tf->tf_r[2] = error;
		tf->tf_epsr |= PSR_C;   /* fail */
		tf->tf_snip = tf->tf_snip & ~NIP_E;
		tf->tf_sfip = tf->tf_sfip & ~FIP_E;
		break;
	}
#ifdef SYSCALL_DEBUG
	scdebug_ret(p, code, error, rval);
#endif
	userret(p, tf, sticks);
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET))
		ktrsysret(p, code, error, rval[0]);
#endif
}
#endif /* M88100 */

#ifdef M88110
/* Instruction pointers operate differently on mc88110 */
void
m88110_syscall(register_t code, struct trapframe *tf)
{
	int i, nsys, nap;
	struct sysent *callp;
	struct proc *p;
	int error;
	register_t args[11], rval[2], *ap;
	u_quad_t sticks;
#ifdef DIAGNOSTIC
	extern struct pcb *curpcb;
#endif

	uvmexp.syscalls++;

	p = curproc;

	callp = p->p_emul->e_sysent;
	nsys  = p->p_emul->e_nsysent;

#ifdef DIAGNOSTIC
	if (USERMODE(tf->tf_epsr) == 0)
		panic("syscall");
	if (curpcb != &p->p_addr->u_pcb)
		panic("syscall curpcb/ppcb");
	if (tf != (struct trapframe *)&curpcb->user_state)
		panic("syscall trapframe");
#endif

	sticks = p->p_sticks;
	p->p_md.md_tf = tf;

	/*
	 * For 88k, all the arguments are passed in the registers (r2-r12)
	 * For syscall (and __syscall), r2 (and r3) has the actual code.
	 * __syscall  takes a quad syscall number, so that other
	 * arguments are at their natural alignments.
	 */
	ap = &tf->tf_r[2];
	nap = 11;	/* r2-r12 */

	switch (code) {
	case SYS_syscall:
		code = *ap++;
		nap--;
		break;
	case SYS___syscall:
		if (callp != sysent)
			break;
		code = ap[_QUAD_LOWWORD];
		ap += 2;
		nap -= 2;
		break;
	}

	/* Callp currently points to syscall, which returns ENOSYS. */
	if (code < 0 || code >= nsys)
		callp += p->p_emul->e_nosys;
	else {
		callp += code;
		i = callp->sy_argsize / sizeof(register_t);
		if (i > nap)
			panic("syscall nargs");
		/*
		 * just copy them; syscall stub made sure all the
		 * args are moved from user stack to registers.
		 */
		bcopy((caddr_t)ap, (caddr_t)args, i * sizeof(register_t));
	}
#ifdef SYSCALL_DEBUG
	scdebug_call(p, code, args);
#endif
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSCALL))
		ktrsyscall(p, code, callp->sy_argsize, args);
#endif
	rval[0] = 0;
	rval[1] = 0;
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE))
		error = systrace_redirect(code, p, args, rval);
	else
#endif
		error = (*callp->sy_call)(p, args, rval);
	/*
	 * system call will look like:
	 *	 ld r10, r31, 32; r10,r11,r12 might be garbage.
	 *	 ld r11, r31, 36
	 *	 ld r12, r31, 40
	 *	 or r13, r0, <code>
	 *       tb0 0, r0, <128> <- exip
	 *	 br err 	  <- enip
	 *       jmp r1
	 *  err: or.u r3, r0, hi16(errno)
	 *	 st r2, r3, lo16(errno)
	 *	 subu r2, r0, 1
	 *	 jmp r1
	 *
	 * So, when we take syscall trap, exip/enip will be as
	 * shown above.
	 * Given this,
	 * 1. If the system call returned 0, need to jmp r1.
	 *	   exip += 8
	 * 2. If the system call returned an errno > 0, increment
	 *    exip += 4 and plug the value in r2. This will have us
	 *    executing "br err" on return to user space.
	 * 3. If the system call code returned ERESTART,
	 *    we need to rexecute the trap instruction. leave exip as is.
	 * 4. If the system call returned EJUSTRETURN, just return.
	 *    exip += 4
	 */

	switch (error) {
	case 0:
		/*
		 * If fork succeeded and we are the child, our stack
		 * has moved and the pointer tf is no longer valid,
		 * and p is wrong.  Compute the new trapframe pointer.
		 * (The trap frame invariably resides at the
		 * tippity-top of the u. area.)
		 */
		p = curproc;
		tf = (struct trapframe *)USER_REGS(p);
		tf->tf_r[2] = rval[0];
		tf->tf_r[3] = rval[1];
		tf->tf_epsr &= ~PSR_C;
		/* skip two instructions */
		if (tf->tf_exip & 1)
			tf->tf_exip = tf->tf_enip + 4;
		else
			tf->tf_exip += 4 + 4;
		tf->tf_enip = 0;
		break;
	case ERESTART:
		/*
		 * Reexecute the trap.
		 * exip is already at the trap instruction, so
		 * there is nothing to do.
		 */
		tf->tf_epsr &= ~PSR_C;
		break;
	case EJUSTRETURN:
		tf->tf_epsr &= ~PSR_C;
		/* skip one instruction */
		if (tf->tf_exip & 1)
			tf->tf_exip = tf->tf_enip;
		else
			tf->tf_exip += 4;
		tf->tf_enip = 0;
		break;
	default:
		if (p->p_emul->e_errno)
			error = p->p_emul->e_errno[error];
		tf->tf_r[2] = error;
		tf->tf_epsr |= PSR_C;   /* fail */
		/* skip one instruction */
		if (tf->tf_exip & 1)
			tf->tf_exip = tf->tf_enip;
		else
			tf->tf_exip += 4;
		tf->tf_enip = 0;
		break;
	}

#ifdef SYSCALL_DEBUG
	scdebug_ret(p, code, error, rval);
#endif
	userret(p, tf, sticks);
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET))
		ktrsysret(p, code, error, rval[0]);
#endif
}
#endif	/* MVME197 */

/*
 * Set up return-value registers as fork() libc stub expects,
 * and do normal return-to-user-mode stuff.
 */
void
child_return(arg)
	void *arg;
{
	struct proc *p = arg;
	struct trapframe *tf;

	tf = (struct trapframe *)USER_REGS(p);
	tf->tf_r[2] = 0;
	tf->tf_r[3] = 0;
	tf->tf_epsr &= ~PSR_C;
	if (cputyp != CPU_88110) {
		tf->tf_snip = tf->tf_sfip & XIP_ADDR;
		tf->tf_sfip = tf->tf_snip + 4;
	} else {
		/* skip two instructions */
		if (tf->tf_exip & 1)
			tf->tf_exip = tf->tf_enip + 4;
		else
			tf->tf_exip += 4 + 4;
		tf->tf_enip = 0;
	}

	userret(p, tf, p->p_sticks);
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET))
		ktrsysret(p, SYS_fork, 0, 0);
#endif
}

#ifdef PTRACE

/*
 * User Single Step Debugging Support
 */

#include <sys/ptrace.h>

unsigned ss_get_value(struct proc *, unsigned, int);
int ss_put_value(struct proc *, unsigned, unsigned, int);
unsigned ss_branch_taken(unsigned, unsigned,
    unsigned (*func)(unsigned int, struct reg *), struct reg *);
unsigned int ss_getreg_val(unsigned int, struct reg *);
int ss_inst_branch(unsigned);
int ss_inst_delayed(unsigned);
unsigned ss_next_instr_address(struct proc *, unsigned, unsigned);

unsigned
ss_get_value(struct proc *p, unsigned addr, int size)
{
	struct uio uio;
	struct iovec iov;
	unsigned value;

	iov.iov_base = (caddr_t)&value;
	iov.iov_len = size;
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1;
	uio.uio_offset = (off_t)addr;
	uio.uio_resid = size;
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_READ;
	uio.uio_procp = curproc;
	procfs_domem(curproc, p, NULL, &uio);
	return value;
}

int
ss_put_value(struct proc *p, unsigned addr, unsigned value, int size)
{
	struct uio uio;
	struct iovec iov;

	iov.iov_base = (caddr_t)&value;
	iov.iov_len = size;
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1;
	uio.uio_offset = (off_t)addr;
	uio.uio_resid = size;
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_WRITE;
	uio.uio_procp = curproc;
	return procfs_domem(curproc, p, NULL, &uio);
}

/*
 * ss_branch_taken(instruction, program counter, func, func_data)
 *
 * instruction will be a control flow instruction location at address pc.
 * Branch taken is supposed to return the address to which the instruction
 * would jump if the branch is taken. Func can be used to get the current
 * register values when invoked with a register number and func_data as
 * arguments.
 *
 * If the instruction is not a control flow instruction, panic.
 */
unsigned
ss_branch_taken(unsigned inst, unsigned pc,
    unsigned (*func)(unsigned int, struct reg *), struct reg *func_data)
{
	/* check if br/bsr */
	if ((inst & 0xf0000000) == 0xc0000000) {
		/* signed 26 bit pc relative displacement, shift left two bits */
		inst = (inst & 0x03ffffff) << 2;
		/* check if sign extension is needed */
		if (inst & 0x08000000)
			inst |= 0xf0000000;
		return (pc + inst);
	}

	/* check if bb0/bb1/bcnd case */
	switch (inst & 0xf8000000) {
	case 0xd0000000: /* bb0 */
	case 0xd8000000: /* bb1 */
	case 0xe8000000: /* bcnd */
		/* signed 16 bit pc relative displacement, shift left two bits */
		inst = (inst & 0x0000ffff) << 2;
		/* check if sign extension is needed */
		if (inst & 0x00020000)
			inst |= 0xfffc0000;
		return (pc + inst);
	}

	/* check jmp/jsr case */
	/* check bits 5-31, skipping 10 & 11 */
	if ((inst & 0xfffff3e0) == 0xf400c000)
		return (*func)(inst & 0x1f, func_data);	 /* the register value */

	/* can't happen */
	return (0);
}

/*
 * ss_getreg_val - handed a register number and an exception frame.
 *              Returns the value of the register in the specified
 *              frame. Only makes sense for general registers.
 */
unsigned int
ss_getreg_val(unsigned int regno, struct reg *regs)
{
	return (regno == 0 ? 0 : regs->r[regno]);
}

int
ss_inst_branch(unsigned ins)
{
	/* check high five bits */

	switch (ins >> (32 - 5)) {
	case 0x18: /* br */
	case 0x1a: /* bb0 */
	case 0x1b: /* bb1 */
	case 0x1d: /* bcnd */
		return TRUE;
		break;
	case 0x1e: /* could be jmp */
		if ((ins & 0xfffffbe0) == 0xf400c000)
			return TRUE;
	}

	return FALSE;
}

/* ss_inst_delayed - this instruction is followed by a delay slot. Could be
   br.n, bsr.n bb0.n, bb1.n, bcnd.n or jmp.n or jsr.n */

int
ss_inst_delayed(unsigned ins)
{
	/* check the br, bsr, bb0, bb1, bcnd cases */
	switch ((ins & 0xfc000000) >> (32 - 6)) {
	case 0x31: /* br */
	case 0x33: /* bsr */
	case 0x35: /* bb0 */
	case 0x37: /* bb1 */
	case 0x3b: /* bcnd */
		return TRUE;
	}

	/* check the jmp, jsr cases */
	/* mask out bits 0-4, bit 11 */
	return ((ins & 0xfffff7e0) == 0xf400c400) ? TRUE : FALSE;
}

unsigned
ss_next_instr_address(struct proc *p, unsigned pc, unsigned delay_slot)
{
	if (delay_slot == 0)
		return (pc + 4);
	else {
		if (ss_inst_delayed(ss_get_value(p, pc, sizeof(int))))
			return (pc + 4);
		else
			return pc;
	}
}

int
cpu_singlestep(p)
	struct proc *p;
{
	struct reg *sstf = USER_REGS(p);
	unsigned pc, brpc;
	int bpinstr = SSBREAKPOINT;
	unsigned curinstr;

	pc = PC_REGS(sstf);
	/*
	 * User was stopped at pc, e.g. the instruction
	 * at pc was not executed.
	 * Fetch what's at the current location.
	 */
	curinstr = ss_get_value(p, pc, sizeof(int));

	/* compute next address after current location */
	if (curinstr != 0) {
		if (ss_inst_branch(curinstr) ||
		    inst_call(curinstr) || inst_return(curinstr)) {
			brpc = ss_branch_taken(curinstr, pc, ss_getreg_val, sstf);
			if (brpc != pc) {   /* self-branches are hopeless */
				p->p_md.md_ss_taken_addr = brpc;
				p->p_md.md_ss_taken_instr =
				    ss_get_value(p, brpc, sizeof(int));
				/* Store breakpoint instruction at the
				   "next" location now. */
				if (ss_put_value(p, brpc, bpinstr,
				    sizeof(int)) != 0)
					return (EFAULT);
			}
		}
		pc = ss_next_instr_address(p, pc, 0);
	} else {
		pc = PC_REGS(sstf) + 4;
	}

	if (p->p_md.md_ss_addr != NULL) {
		return (EFAULT);
	}

	p->p_md.md_ss_addr = pc;

	/* Fetch what's at the "next" location. */
	p->p_md.md_ss_instr = ss_get_value(p, pc, sizeof(int));

	/* Store breakpoint instruction at the "next" location now. */
	if (ss_put_value(p, pc, bpinstr, sizeof(int)) != 0)
		return (EFAULT);

	return (0);
}

#endif	/* PTRACE */

#ifdef DIAGNOSTIC
void
splassert_check(int wantipl, const char *func)
{
	int oldipl;

	/*
	 * This will raise the spl if too low,
	 * in a feeble attempt to reduce further damage.
	 */
	oldipl = raiseipl(wantipl);

	if (oldipl < wantipl) {
		splassert_fail(wantipl, oldipl, func);
	}
}
#endif
@


1.72
log
@typos; jjy2+@@pitt.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.71 2004/01/29 00:41:23 miod Exp $	*/
@


1.71
log
@Correctly handle 88110 exceptions occuring in a delay slot: control must
be restored with valid EXIP+D and ENIP values in this case, unless it is
decided to skip instructions.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.70 2004/01/20 14:34:40 miod Exp $	*/
d1170 1
a1170 1
		db_printf("(read totaly useless)  But R1 to R31 might be interesting.\n");
@


1.70
log
@Better debugging information, only available if option TRAPDEBUG (which you
don't want. honest. really).
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.69 2004/01/14 20:46:02 miod Exp $	*/
d731 2
a732 1
		if (frame->tf_enip) {
d734 1
a734 1
		} else {
d736 1
a736 1
		}
d823 1
d1011 1
d1475 6
a1480 2
		tf->tf_exip += 4 + 4;
		tf->tf_exip &= XIP_ADDR;
d1492 6
a1497 2
		tf->tf_exip += 4;
		tf->tf_exip &= XIP_ADDR;
d1504 6
a1509 2
		tf->tf_exip += 4;
		tf->tf_exip &= XIP_ADDR;
d1543 6
a1548 2
		tf->tf_exip += 4 + 4;
		tf->tf_exip &= XIP_ADDR;
@


1.69
log
@Some MC8820x operation cleaning:
- define more constants and macros for readability. Especially cache
  initialization suddently becomes more readable.
- after every flush operation, wait for the operation to complete by
  accessing the status register, before returning.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.68 2004/01/12 21:33:15 miod Exp $	*/
d284 6
a289 2
		DEBUG_MSG(("kernel mode instruction "
			  "page fault @@ 0x%08x\n", frame->tf_sxip));
d320 1
a320 1
#ifdef DEBUG
d322 2
a323 2
		       pbus_type, pbus_exception_type[pbus_type],
		       fault_addr, frame, frame->tf_cpu);
d381 3
a383 3
#ifdef DEBUG
		printf ("PBUS Fault %d (%s) va = 0x%x\n", pbus_type,
			pbus_exception_type[pbus_type], va);
d394 5
d402 5
a407 5
#ifdef DEBUG
		printf("User Data access fault #%d (%s) v = 0x%x, frame 0x%x cpu %d\n",
		       pbus_type, pbus_exception_type[pbus_type],
		       fault_addr, frame, frame->tf_cpu);
#endif
d774 4
a777 2
		DEBUG_MSG(("kernel mode instruction "
			  "page fault @@ 0x%08x\n", frame->tf_exip));
d791 5
d851 4
d860 3
a862 3
#ifdef DEBUG
				printf("Kernel Write protect???? pte %x\n",
				    *pte);
d880 4
d893 4
a918 4
#ifdef DEBUG
				if (result != 0)
					printf("Data Access Error @@ 0x%x\n", va);
#endif
d937 1
d940 1
d946 4
d959 3
a961 3
#ifdef DEBUG
					printf("Write protect???? pte %x\n",
					    *pte);
d968 2
a969 2
#ifdef DEBUG
				printf("unexpected data fault dsr %x\n",
d972 1
a972 3
				result = uvm_fault(map, va, VM_FAULT_INVALID, ftype);
				if (result == EACCES)
					result = EFAULT;
d987 2
a988 2
#ifdef DEBUG
				printf("unexpected instr fault dsr %x\n",
d991 1
a991 3
				result = uvm_fault(map, va, VM_FAULT_INVALID, ftype);
				if (result == EACCES)
					result = EFAULT;
a1401 3
#ifdef DEBUG
	printf("syscall code is %d\n", code);
#endif
@


1.68
log
@Shrink the reg structure, for it to only contain registers (eh), and make
the remaining fielhs only available in struct trapframe.

This has the additional benefit of preventing smarty-pants from altering
the frame a bit too easily from ddb, at the expense of a few ugly casts in
ddb.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.67 2004/01/12 07:46:17 miod Exp $	*/
d170 2
a171 1
				    pbus_exception_type[(frame->tf_ipfsr >> 16) & 0x7],
d177 2
a178 1
				    pbus_exception_type[(frame->tf_dpfsr >> 16) & 0x7],
d315 1
a315 1
		pbus_type = (frame->tf_dpfsr >> 16) & 0x07;
d389 1
a389 1
			pbus_type = (frame->tf_ipfsr >> 16) & 0x07;
d392 1
a392 1
			pbus_type = (frame->tf_dpfsr >> 16) & 0x07;
@


1.67
log
@Get rid of that ugly m88100_saved_state structure, use trapframe everywhere
instead.

Allow struct reg and struct trapframe to live different lives and grow
separately. Righty now they are still the same, and code expects a trapframe
to always start with a struct reg. This may change...
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.66 2004/01/11 23:52:47 miod Exp $	*/
d531 1
a531 1
			unsigned pc = PC_REGS((struct reg *)frame);
d1048 1
a1048 1
			unsigned pc = PC_REGS((struct reg *)frame);
@


1.66
log
@Mark more code as dependent upon option PTRACE, and slight cleaning while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.65 2004/01/09 11:03:39 miod Exp $	*/
d93 2
a94 2
__dead void panictrap(int, struct m88100_saved_state *);
__dead void error_fatal(struct m88100_saved_state *);
d126 1
a126 1
userret(struct proc *p, struct m88100_saved_state *frame, u_quad_t oticks)
d150 1
a150 1
		addupc_task(p, frame->sxip & XIP_ADDR,
d157 1
a157 1
panictrap(int type, struct m88100_saved_state *frame)
d170 2
a171 2
				    pbus_exception_type[(frame->ipfsr >> 16) & 0x7],
				    frame->sxip & XIP_ADDR, frame);
d176 2
a177 2
				    pbus_exception_type[(frame->dpfsr >> 16) & 0x7],
				    frame->sxip & XIP_ADDR, frame);
d180 1
a180 1
				    type, frame->sxip & XIP_ADDR, frame);
d186 1
a186 1
			    type, frame->exip, frame);
d202 1
a202 1
m88100_trap(unsigned type, struct m88100_saved_state *frame)
d229 1
a229 1
	if (USERMODE(frame->epsr)) {
d236 1
a236 1
	fault_addr = frame->sxip & XIP_ADDR;
d240 1
a240 1
		panictrap(frame->vector, frame);
d262 1
a262 1
		panictrap(frame->vector, frame);
d274 2
a275 2
			  "access exception @@ 0x%08x\n", frame->sxip));
		panictrap(frame->vector, frame);
d283 2
a284 2
			  "page fault @@ 0x%08x\n", frame->sxip));
		panictrap(frame->vector, frame);
d291 1
a291 1
		if ((frame->dmt0 & DMT_DAS) == 0) {
d296 2
a297 2
		fault_addr = frame->dma0;
		if (frame->dmt0 & (DMT_WRITE|DMT_LOCKBAR)) {
d313 1
a313 1
		pbus_type = (frame->dpfsr >> 16) & 0x07;
d317 1
a317 1
		       fault_addr, frame, frame->cpu);
d325 1
a325 1
			if ((frame->sxip & XIP_ADDR) >=
d327 1
a327 1
			    (frame->sxip & XIP_ADDR) <=
d329 1
a329 1
				frame->snip =
d331 1
a331 1
				frame->sfip =
d333 1
a333 1
				frame->sxip = 0;
d341 1
a341 1
				frame->dmt0 |= DMT_SKIP;
d343 2
a344 2
				frame->dpfsr = 0;
				frame->dmt0 = 0;
d355 2
a356 2
			frame->dpfsr = 0;
			frame->dmt0 = 0;
d369 2
a370 2
				frame->dpfsr = 0;
				frame->dmt0 = 0;
d379 1
a379 1
		panictrap(frame->vector, frame);
d387 1
a387 1
			pbus_type = (frame->ipfsr >> 16) & 0x07;
d389 2
a390 2
			fault_addr = frame->dma0;
			pbus_type = (frame->dpfsr >> 16) & 0x07;
d395 1
a395 1
		       fault_addr, frame, frame->cpu);
d398 1
a398 1
		if (frame->dmt0 & (DMT_WRITE | DMT_LOCKBAR)) {
d439 3
a441 3
			frame->snip = p->p_addr->u_pcb.pcb_onfault | NIP_V;
			frame->sfip = (p->p_addr->u_pcb.pcb_onfault + 4) | FIP_V;
			frame->sxip = 0;
d446 1
a446 1
			frame->dmt0 |= DMT_SKIP;
d459 2
a460 2
				frame->dpfsr = 0;
				frame->dmt0 = 0;
d466 3
a468 3
				frame->sfip = frame->snip & ~FIP_E;
				frame->snip = frame->sxip & ~NIP_E;
				frame->ipfsr = 0;
d531 1
a531 1
			unsigned pc = PC_REGS(frame);
d580 3
a582 3
			frame->sfip = frame->snip;    /* set up next FIP */
			frame->snip = pc;    /* set up next NIP */
			frame->snip |= 2;	  /* set valid bit   */
d599 2
a600 2
		frame->sfip = frame->snip;    /* set up the next FIP */
		frame->snip = frame->sxip;    /* set up the next NIP */
d628 2
a629 2
		frame->dmt0 = 0;
		frame->ipfsr = frame->dpfsr = 0;
d638 1
a638 1
m88110_trap(unsigned type, struct m88100_saved_state *frame)
d667 1
a667 1
	if (USERMODE(frame->epsr)) {
d674 1
a674 1
	fault_addr = frame->exip & XIP_ADDR;
d678 1
a678 1
		panictrap(frame->vector, frame);
d685 1
a685 1
		panictrap(frame->vector, frame);
d691 1
a691 1
		panictrap(frame->vector, frame);
d697 1
a697 1
		panictrap(frame->vector, frame);
d720 2
a721 2
		if (frame->enip) {
			frame->exip = frame->enip;
d723 1
a723 1
			frame->exip += 4;
d740 1
a740 1
		panictrap(frame->vector, frame);
d754 2
a755 2
			  "access exception @@ 0x%08x\n", frame->exip));
		panictrap(frame->vector, frame);
d764 2
a765 2
			  "page fault @@ 0x%08x\n", frame->exip));
		panictrap(frame->vector, frame);
d773 1
a773 1
		if ((frame->dsr & CMMU_DSR_SU) == 0) {
d778 2
a779 2
		fault_addr = frame->dlar;
		if (frame->dsr & CMMU_DSR_RW) {
d795 1
a795 1
		if (frame->dsr & CMMU_DSR_BE) {
d799 1
a799 1
			if ((frame->exip & XIP_ADDR) >=
d801 1
a801 1
			    (frame->exip & XIP_ADDR) <=
d803 1
a803 1
				frame->exip = (unsigned)&guarded_access_bad;
d807 2
a808 2
		if (frame->dsr & (CMMU_DSR_SI | CMMU_DSR_PI)) {
			frame->dsr &= ~CMMU_DSR_WE;	/* undefined */
d817 1
a817 1
		if (frame->dsr & CMMU_DSR_WE) {	/* write fault  */
d848 1
a848 1
		panictrap(frame->vector, frame);
d859 2
a860 2
			fault_addr = frame->dlar;
			if (frame->dsr & CMMU_DSR_RW) {
d880 1
a880 1
			if (frame->dsr & CMMU_DSR_BE) {
d884 1
a884 1
			if (frame->dsr & (CMMU_DSR_SI | CMMU_DSR_PI)) {
d894 1
a894 1
			if (frame->dsr & (CMMU_DSR_CP | CMMU_DSR_WA)) {
d898 1
a898 1
			if (frame->dsr & CMMU_DSR_WE) {
d938 1
a938 1
				    frame->dsr);
d946 1
a946 1
			if (frame->isr &
d951 1
a951 1
			if (frame->isr & (CMMU_ISR_SI | CMMU_ISR_PI)) {
d959 1
a959 1
				    frame->isr);
d980 2
a981 2
			frame->exip = p->p_addr->u_pcb.pcb_onfault;
			frame->dsr = frame->isr = 0;
d1048 1
a1048 1
			unsigned pc = PC_REGS(frame);
d1118 1
a1118 1
		frame->dsr = frame->isr = 0;
d1126 1
a1126 1
error_fatal(struct m88100_saved_state *frame)
d1129 1
a1129 1
	switch (frame->vector) {
d1144 1
a1144 1
	panic("unrecoverable exception %d", frame->vector);
d1149 1
a1149 1
m88100_syscall(register_t code, struct m88100_saved_state *tf)
d1169 1
a1169 1
	if (USERMODE(tf->epsr) == 0)
d1186 1
a1186 1
	ap = &tf->r[2];
d1275 6
a1280 6
		tf = USER_REGS(p);
		tf->r[2] = rval[0];
		tf->r[3] = rval[1];
		tf->epsr &= ~PSR_C;
		tf->snip = tf->sfip & ~NIP_E;
		tf->sfip = tf->snip + 4;
d1287 3
a1289 3
		tf->epsr &= ~PSR_C;
		tf->sfip = tf->snip & ~FIP_E;
		tf->snip = tf->sxip & ~NIP_E;
d1293 1
a1293 1
		tf->epsr &= ~PSR_C;
d1299 4
a1302 4
		tf->r[2] = error;
		tf->epsr |= PSR_C;   /* fail */
		tf->snip = tf->snip & ~NIP_E;
		tf->sfip = tf->sfip & ~FIP_E;
d1319 1
a1319 1
m88110_syscall(register_t code, struct m88100_saved_state *tf)
d1339 1
a1339 1
	if (USERMODE(tf->epsr) == 0)
d1356 1
a1356 1
	ap = &tf->r[2];
d1443 6
a1448 6
		tf = USER_REGS(p);
		tf->r[2] = rval[0];
		tf->r[3] = rval[1];
		tf->epsr &= ~PSR_C;
		tf->exip += 4 + 4;
		tf->exip &= XIP_ADDR;
d1456 1
a1456 1
		tf->epsr &= ~PSR_C;
d1459 3
a1461 3
		tf->epsr &= ~PSR_C;
		tf->exip += 4;
		tf->exip &= XIP_ADDR;
d1466 4
a1469 4
		tf->r[2] = error;
		tf->epsr |= PSR_C;   /* fail */
		tf->exip += 4;
		tf->exip &= XIP_ADDR;
d1495 4
a1498 4
	tf = USER_REGS(p);
	tf->r[2] = 0;
	tf->r[3] = 0;
	tf->epsr &= ~PSR_C;
d1500 2
a1501 2
		tf->snip = tf->sfip & XIP_ADDR;
		tf->sfip = tf->snip + 4;
d1503 2
a1504 2
		tf->exip += 4 + 4;
		tf->exip &= XIP_ADDR;
d1525 2
a1526 2
    unsigned (*func)(unsigned int, struct trapframe *), struct trapframe *);
unsigned int ss_getreg_val(unsigned int, struct trapframe *);
d1582 1
a1582 1
    unsigned (*func)(unsigned int, struct trapframe *), struct trapframe *func_data)
d1622 1
a1622 1
ss_getreg_val(unsigned int regno, struct trapframe *tf)
d1624 1
a1624 1
	return (regno == 0 ? 0 : tf->r[regno]);
d1685 1
a1685 1
	struct trapframe *sstf = USER_REGS(p);
@


1.65
log
@Constify trap names, and a few cleanings to the trap() functions.

While there, use raisespl() in splassert to win a few cycles when the
check fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.64 2004/01/09 00:24:25 miod Exp $	*/
d93 3
a96 1
__dead void error_fatal(struct m88100_saved_state *frame);
d1514 16
a1529 3
/************************************\
* User Single Step Debugging Support *
\************************************/
a1555 1
	int i;
d1566 1
a1566 2
	i = procfs_domem(curproc, p, NULL, &uio);
	return i;
d1581 2
a1582 5
ss_branch_taken(
	       unsigned inst,
	       unsigned pc,
	       unsigned (*func)(unsigned int, struct trapframe *),
	       struct trapframe *func_data)  /* 'opaque' */
a1583 1

d1585 1
a1585 1
	if ((inst & 0xf0000000U) == 0xc0000000U) {
d1587 1
a1587 1
		inst = (inst & 0x03ffffffU)<<2;
d1589 3
a1591 3
		if (inst & 0x08000000U)
			inst |= 0xf0000000U;
		return pc + inst;
d1595 4
a1598 4
	switch ((inst & 0xf8000000U)) {
	case 0xd0000000U: /* bb0 */
	case 0xd8000000U: /* bb1 */
	case 0xe8000000U: /* bcnd */
d1600 1
a1600 1
		inst = (inst & 0x0000ffffU)<<2;
d1602 3
a1604 3
		if (inst & 0x00020000U)
			inst |= 0xfffc0000U;
		return pc + inst;
d1609 1
a1609 1
	if ((inst & 0xfffff3e0U) == 0xf400c000U)
d1612 2
a1613 1
	return 0; /* keeps compiler happy */
d1621 2
a1622 2
unsigned
ss_getreg_val(unsigned regno, struct trapframe *tf)
d1624 1
a1624 8
	if (regno == 0)
		return 0;
	else if (regno < 31)
		return tf->r[regno];
	else {
		panic("bad register number to ss_getreg_val.");
		return 0;/*to make compiler happy */
	}
d1632 1
a1632 1
	switch (ins >> (32-5)) {
d1640 1
a1640 1
		if ((ins & 0xfffffbe0U) == 0xf400c000U)
d1654 1
a1654 1
	switch ((ins & 0xfc000000U)>>(32-6)) {
d1665 1
a1665 1
	return ((ins & 0xfffff7e0U) == 0xf400c400U) ? TRUE : FALSE;
d1672 1
a1672 1
		return pc + 4;
d1675 1
a1675 1
			return pc + 4;
a1686 1
	int i;
d1700 2
a1701 1
		if (ss_inst_branch(curinstr) || inst_call(curinstr) || inst_return(curinstr)) {
a1703 4
#if 0
				printf("SS %s (%d): next taken breakpoint set at %x\n",
				       p->p_comm, p->p_pid, brpc);
#endif
d1705 7
a1711 4
				p->p_md.md_ss_taken_instr = ss_get_value(p, brpc, sizeof(int));
				/* Store breakpoint instruction at the "next" location now. */
				i = ss_put_value(p, brpc, bpinstr, sizeof(int));
				if (i < 0) return (EFAULT);
a1714 4
#if 0
		printf("SS %s (%d): next breakpoint set at %x\n",
		       p->p_comm, p->p_pid, pc);
#endif
a1716 4
#if 0
		printf("SS %s (%d): next breakpoint set at %x\n",
		       p->p_comm, p->p_pid, pc);
#endif
d1719 1
a1719 5
	if (p->p_md.md_ss_addr) {
#if 0
		printf("SS %s (%d): breakpoint already set at %x (va %x)\n",
		       p->p_comm, p->p_pid, p->p_md.md_ss_addr, pc); /* XXX */
#endif
d1729 2
a1730 1
	i = ss_put_value(p, pc, bpinstr, sizeof(int));
a1731 1
	if (i < 0) return (EFAULT);
d1734 2
@


1.64
log
@Do not keep a round-robin list of the previous traps for debug purposes on
88100 anymore - it's stable well enough now...
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.63 2004/01/02 23:45:03 miod Exp $	*/
a80 6
#define TRAPTRACE

#if defined(TRAPTRACE)
unsigned traptrace = 0;
#endif

d96 1
a96 1
char  *trap_type[] = {
d110 1
d112 1
a112 1
char  *pbus_exception_type[] = {
a122 2
int   trap_types = sizeof trap_type / sizeof trap_type[0];

a216 1
	unsigned pc = PC_REGS(frame);  /* get program counter (sxip) */
d529 1
a652 1
	unsigned pc = PC_REGS(frame);  /* get program counter (exip) */
a664 10
#ifdef DEBUG
	if (type != T_INT && type != T_ASTFLT
#ifdef DDB
	    && type != T_KDB_ENTRY
#endif
	   ) {
		printf("m88110_trap: %d %s\n", type, frame->vector < trap_types ? trap_type[frame->vector] : "unknown");
	}
#endif

d1046 1
a1120 1

a1314 1

d1680 1
a1680 1
register struct proc *p;
d1682 1
a1682 1
	struct trapframe *sstf = USER_REGS(p); /*p->p_md.md_tf;*/
a1744 1

d1751 5
a1755 1
	oldipl = getipl();
a1758 5
		/*
		 * If the splassert_ctl is set to not panic, raise the ipl
		 * in a feeble attempt to reduce damage.
		 */
		setipl(wantipl);
@


1.63
log
@MC88110 errata states that, for instruction faults, in case of bus error
trap class, the value of the page fault and segment fault bits are
undefined; so check for bus error first.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.62 2003/12/24 15:30:13 miod Exp $	*/
d168 27
a194 12
		if (type == 2 && cputyp == CPU_88100) {
			/* instruction exception */
			db_printf("\nInstr access fault (%s) v = %x, frame %p\n",
				  pbus_exception_type[(frame->ipfsr >> 16) & 0x7],
				  frame->sxip & XIP_ADDR, frame);
		} else if (type == 3 && cputyp == CPU_88100) {
			/* data access exception */
			db_printf("\nData access fault (%s) v = %x, frame %p\n",
				  pbus_exception_type[(frame->dpfsr >> 16) & 0x7],
				  frame->sxip & XIP_ADDR, frame);
		} else
			db_printf("\ntrap type %d, v = %x, frame %p\n", type, frame->sxip & XIP_ADDR, frame);
a205 3
unsigned last_trap[4] = {0,0,0,0};
unsigned last_vector = 0;

a230 6
	if (type != last_trap[3]) {
		last_trap[0] = last_trap[1];
		last_trap[1] = last_trap[2];
		last_trap[2] = last_trap[3];
		last_trap[3] = type;
	}
a1158 5
#ifdef M88100
	db_printf("trap trace %d -> %d -> %d -> %d  ", last_trap[0], last_trap[1], last_trap[2], last_trap[3]);
	db_printf("last exception vector = %d\n", last_vector);
#endif
	Debugger();
@


1.62
log
@Since we have real bus error faults, and handle them as such, always treat
uvm_fault() returning EACCES as a segmentation fault rather than a bus
error, whatever address the fault is at.

As a result, this correctly delivers SIGSEGV, rather than SIGBUS, when
attempting to write to a page with only PROT_READ permissions.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.61 2003/12/23 23:36:44 miod Exp $	*/
d956 5
a965 5
			} else
			if (frame->isr &
			    (CMMU_ISR_BE | CMMU_ISR_SP | CMMU_ISR_TBE)) {
				/* bus error, supervisor protection */
				result = EACCES;
@


1.61
log
@Data access faults occuring inside copyin() or copyinstr() would get
treated as usermode traps, because they reference a user space address.
However, the tests for pcb_onfault being set were only present in the
kernelmode traps handling.

Since pcb_onfault is only set in those functions, move the associated
recovery code from the kernelmode part to the usermode part, and only
attempt to jump to pcb_onfault() if the access could not be resolved
by uvm_fault() earlier.

This lets things like setlogin(NULL) correctly return EFAULT, rather
than killing the process with SIGSEGV, and incidentally lets sendmail
in a non-default configuration run.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.60 2003/12/23 00:40:02 miod Exp $	*/
d421 2
d431 1
a431 2
			} else if (result == EACCES)
				result = EFAULT;
d897 2
d942 2
d951 2
d959 2
d972 2
d982 1
a982 2
			} else if (result == EACCES)
				result = EFAULT;
@


1.60
log
@Simplify the syscall() routines. Also put a really meaningful limit to the
number of syscall arguments, and enforce it correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.59 2003/12/19 22:30:18 miod Exp $	*/
d379 2
a380 22
		/*
		 * if still the fault is not resolved ...
		 */
		if (p->p_addr->u_pcb.pcb_onfault == 0)
			panictrap(frame->vector, frame);

		frame->snip =
		    ((unsigned)p->p_addr->u_pcb.pcb_onfault    ) | FIP_V;
		frame->sfip =
		    ((unsigned)p->p_addr->u_pcb.pcb_onfault + 4) | FIP_V;
		frame->sxip = 0;
		/* We sort of resolved the fault ourselves because
		 * we know where it came from [copyxxx()]
		 * But we must still think about the other possible
		 * transactions in dmt1 & dmt2.  Mark dmt0 so that
		 * data_access_emulation skips it. XXX smurph
		 */
		frame->dmt0 |= DMT_SKIP;
		data_access_emulation((unsigned *)frame);
		frame->dpfsr = 0;
		frame->dmt0 = 0;
		return;
d433 16
d472 1
a472 1
				BUS_ADRERR : SEGV_MAPERR;
d857 2
a858 9

		/*
		 * if still the fault is not resolved ...
		 */
		if (!p->p_addr->u_pcb.pcb_onfault)
			panictrap(frame->vector, frame);

		frame->exip = ((unsigned)p->p_addr->u_pcb.pcb_onfault);
		return;
d973 13
@


1.59
log
@Pass -Wformat, and silence a few vme* debug printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.58 2003/11/14 19:05:34 miod Exp $	*/
d1154 3
a1156 3
	register int i, nsys, *ap, nap;
	register struct sysent *callp;
	register struct proc *p;
d1158 1
a1158 4
	struct args {
		int i[8];
	} args;
	int rval[2];
d1190 1
a1190 1
	nap = 6;
d1212 1
a1212 1
		if (i > 8)
d1218 1
a1218 1
		bcopy((caddr_t)ap, (caddr_t)args.i, i * sizeof(register_t));
d1220 1
d1222 1
a1222 1
	scdebug_call(p, code, args.i);
d1226 1
a1226 1
		ktrsyscall(p, code, callp->sy_argsize, args.i);
d1232 1
a1232 1
		error = systrace_redirect(code, p, &args, rval);
d1235 1
a1235 1
		error = (*callp->sy_call)(p, &args, rval);
d1325 3
a1327 3
	register int i, nsys, *ap, nap;
	register struct sysent *callp;
	register struct proc *p;
d1329 1
a1329 4
	struct args {
		int i[8];
	} args;
	int rval[2];
d1361 1
a1361 1
	nap = 6;
d1386 1
a1386 1
		if (i > 8)
d1392 1
a1392 1
		bcopy((caddr_t)ap, (caddr_t)args.i, i * sizeof(register_t));
d1395 1
a1395 1
	scdebug_call(p, code, args.i);
d1399 1
a1399 1
		ktrsyscall(p, code, callp->sy_argsize, args.i);
d1405 1
a1405 1
		error = systrace_redirect(code, p, &args, rval);
d1408 1
a1408 1
		error = (*callp->sy_call)(p, &args, rval);
@


1.58
log
@the the; rohee@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.57 2003/10/27 10:46:44 miod Exp $	*/
d170 1
a170 1
			db_printf("\nInstr access fault (%s) v = %x, frame %x\n",
d175 1
a175 1
			db_printf("\nData access fault (%s) v = %x, frame %x\n",
d179 1
a179 1
			db_printf("\ntrap type %d, v = %x, frame %x\n", type, frame->sxip & XIP_ADDR, frame);
d1129 1
a1129 1
		db_printf("\n[RESET EXCEPTION (Really Bad News[tm]) frame 0x%08x]\n", frame);
d1134 1
a1134 1
		db_printf("\n[ERROR EXCEPTION (Bad News[tm]) frame 0x%08x]\n", frame);
@


1.57
log
@Be sure to always have a valid faulting address when we send a signal
to a process.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.56 2003/10/23 19:06:54 miod Exp $	*/
d467 1
a467 1
				 * clearing the the Error bit
@


1.56
log
@Correctly recover from bus error during guarded_access() on 88110.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.55 2003/10/09 16:30:58 miod Exp $	*/
a232 2
		fault_type = 0;
		fault_code = 0;
d234 4
d406 1
a406 2
		if (type == T_INSTFLT+T_USER) {
			fault_addr = frame->sxip & XIP_ADDR;
a683 2
		fault_type = 0;
		fault_code = 0;
d685 4
d821 1
a875 1
			fault_addr = frame->exip & XIP_ADDR;
@


1.55
log
@Minor cpp changes to let all kernels in conf/ compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.54 2003/10/05 20:27:47 miod Exp $	*/
d651 1
a654 1
	int result;
d662 1
d714 1
a714 1
		ddb_break_trap(T_KDB_TRACE,(db_regs_t*)frame);
d721 1
a721 1
		ddb_break_trap(T_KDB_BREAK,(db_regs_t*)frame);
d728 1
a728 1
		ddb_entry_trap(T_KDB_ENTRY,(db_regs_t*)frame);
d813 1
@


1.54
log
@Kill vm_offset_t and vm_size_t, in favor of the [pv]addr_t and [pv]size_t
typedefs.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.53 2003/10/02 10:20:12 miod Exp $	*/
d207 4
a210 1
	int result, s;
@


1.53
log
@Fix some DAE processing logic - the kernel would incorrectly end up retrying
already processed, or unwanted, DAE in certain circumstances by mistake.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.52 2003/09/26 19:04:30 miod Exp $	*/
a61 1
#include <machine/bugio.h>		/* bugreturn() */
d65 2
a66 2
#include <machine/m88100.h>
#include <machine/m8820x.h>
d87 2
a88 2
#if DDB
#define DEBUG_MSG db_printf
d90 1
a90 1
#define DEBUG_MSG printf
d100 1
a100 1
void error_fatal(struct m88100_saved_state *frame);
d155 1
a155 1
		addupc_task(p, frame->sxip & ~3,
d161 1
a161 1
void
d164 1
d170 1
a170 1
			DEBUG_MSG("\nInstr access fault (%s) v = %x, frame %x\n",
d172 1
a172 1
				  frame->sxip & ~3, frame);
d175 1
a175 1
			DEBUG_MSG("\nData access fault (%s) v = %x, frame %x\n",
d177 1
a177 1
				  frame->sxip & ~3, frame);
d179 1
a179 1
			DEBUG_MSG("\ntrap type %d, v = %x, frame %x\n", type, frame->sxip & ~3, frame);
d182 1
d185 2
a186 1
	panic("trap");
d200 1
a200 1
	vm_offset_t va;
d207 1
a207 1
	int result;
d212 3
a214 3
	extern unsigned guarded_access_start;
	extern unsigned guarded_access_end;
	extern unsigned guarded_access_bad;
d236 1
d241 6
a246 8
		{
			int s = splhigh();
			db_enable_interrupt();
			ddb_break_trap(T_KDB_BREAK,(db_regs_t*)frame);
			db_disable_interrupt();
			splx(s);
			return;
		}
d248 6
a253 21
		{
			int s = splhigh();
			db_enable_interrupt();
			ddb_entry_trap(T_KDB_ENTRY,(db_regs_t*)frame);
			db_disable_interrupt();
			splx(s);
			return;
		}

#if 0
	case T_ILLFLT:
		{
			int s = splhigh();
			db_enable_interrupt();
			ddb_error_trap(type == T_ILLFLT ? "unimplemented opcode" :
				       "error fault", (db_regs_t*)frame);
			db_disable_interrupt();
			splx(s);
			return;
		}
#endif /* 0 */
d256 1
a256 1
		DEBUG_MSG("Unimplemented opcode!\n");
d261 1
a261 1
		/* This function pointer is set in machdep.c 
d268 2
a269 2
		DEBUG_MSG("kernel misaligned "
			  "access exception @@ 0x%08x\n", frame->sxip);
d277 2
a278 2
		DEBUG_MSG("kernel mode instruction "
			  "page fault @@ 0x%08x\n", frame->sxip);
d300 1
a300 1
		va = trunc_page((vm_offset_t)fault_addr);
d313 1
a313 1
#endif 
d320 1
a320 1
			if ((frame->sxip & ~3) >=
d322 1
a322 1
			    (frame->sxip & ~3) <=
d345 3
a347 3
			 * The fault was resolved. Call data_access_emulation 
			 * to drain the data unit pipe line and reset dmt0 
			 * so that trap won't get called again. 
d355 1
a355 1
			result = uvm_fault(map, va, 0, ftype);
d385 1
a385 1
		/* We sort of resolved the fault ourselves because 
d387 2
a388 2
		 * But we must still think about the other possible 
		 * transactions in dmt1 & dmt2.  Mark dmt0 so that 
d412 1
a412 1
#endif 
d414 2
a415 2
		if (frame->dmt0 & (DMT_WRITE|DMT_LOCKBAR)) {
			ftype = VM_PROT_READ|VM_PROT_WRITE;
d422 1
a422 1
		va = trunc_page((vm_offset_t)fault_addr);
d436 1
a436 1
			result = uvm_fault(map, va, 0, ftype);
d539 1
a539 1
			if ((p->p_md.md_ss_addr != pc && 
d551 1
a551 1
				iov.iov_len = sizeof(int); 
d553 1
a553 1
				uio.uio_iovcnt = 1; 
d567 1
a567 1
				iov.iov_len = sizeof(int); 
d569 1
a569 1
				uio.uio_iovcnt = 1; 
d622 1
a622 1
		/*		
d641 1
a641 1
	vm_offset_t va;
d659 1
a659 1
	extern pt_entry_t *pmap_pte(pmap_t, vm_offset_t);
d685 1
d687 1
d690 1
a690 1
		DEBUG_MSG("DMMU read miss: Hardware Table Searches should be enabled!\n");
d692 1
d696 1
a696 1
		DEBUG_MSG("DMMU write miss: Hardware Table Searches should be enabled!\n");
d698 1
d702 1
a702 1
		DEBUG_MSG("IMMU miss: Hardware Table Searches should be enabled!\n");
d704 1
d745 1
a745 1
		DEBUG_MSG("Unimplemented opcode!\n");
d750 1
a750 1
		/* This function pointer is set in machdep.c 
d759 2
a760 2
		DEBUG_MSG("kernel mode misaligned "
			  "access exception @@ 0x%08x\n", frame->exip);
d762 1
d769 2
a770 2
		DEBUG_MSG("kernel mode instruction "
			  "page fault @@ 0x%08x\n", frame->exip);
d772 1
d793 1
a793 1
		va = trunc_page((vm_offset_t)fault_addr);
d805 1
a805 1
			if ((frame->exip & ~3) >=
d807 1
a807 1
			    (frame->exip & ~3) <=
d817 1
a817 1
			result = uvm_fault(map, va, 0, ftype);
d823 1
a823 1
			 * This could be a write protection fault or an 
d825 2
a826 2
			 * in the pte. Basically, if we got a write error, 
			 * then we already have a pte entry that faulted 
d828 2
a829 2
			 * Get the pte and check the status of the 
			 * modified and valid bits to determine if this 
d846 1
a846 1
				result = uvm_fault(map, va, 0, ftype);
d881 1
a881 1
		va = trunc_page((vm_offset_t)fault_addr);
d898 1
a898 1
				result = uvm_fault(map, va, 0, ftype);
d910 1
a910 1
				/* This could be a write protection fault or an 
d916 2
a917 2
				 * Get the pte and check the status of the 
				 * modified and valid bits to determine if this 
d941 1
a941 1
					result = uvm_fault(map, va, 0, ftype);
d948 1
a948 1
				result = uvm_fault(map, va, 0, ftype);
d954 1
a954 1
				result = uvm_fault(map, va, 0, ftype);
d965 1
a965 1
				result = uvm_fault(map, va, 0, ftype);
d1053 1
a1053 1
#endif 
d1059 1
a1059 1
				iov.iov_len = sizeof(int); 
d1061 1
a1061 1
				uio.uio_iovcnt = 1; 
d1103 1
a1103 1
		/*		
d1115 1
a1115 1
void
d1118 1
d1121 3
a1123 3
		DEBUG_MSG("\n[RESET EXCEPTION (Really Bad News[tm]) frame 0x%08x]\n", frame);
		DEBUG_MSG("This is usually caused by a branch to a NULL function pointer.\n");
		DEBUG_MSG("e.g. jump to address 0.  Use the debugger trace command to track it down.\n");
d1126 4
a1129 4
		DEBUG_MSG("\n[ERROR EXCEPTION (Bad News[tm]) frame 0x%08x]\n", frame);
		DEBUG_MSG("This is usually an exception within an exception.  The trap\n");
		DEBUG_MSG("frame shadow registers you are about to see are invalid.\n");
		DEBUG_MSG("(read totaly useless)  But R1 to R31 might be interesting.\n");
d1134 3
a1136 6
	DEBUG_MSG("trap trace %d -> %d -> %d -> %d  ", last_trap[0], last_trap[1], last_trap[2], last_trap[3]);
	DEBUG_MSG("last exception vector = %d\n", last_vector);
#endif 
#if DDB 
	Debugger();
	DEBUG_MSG("You really can't restart after exception %d!\n", frame->vector);
d1139 1
a1139 2
	bugreturn();  /* This gets us to Bug instead of a loop forever */

d1241 1
a1241 1
	 *	 subu r2, r0, 1 
d1417 1
a1417 1
	 *	 subu r2, r0, 1 
d1425 1
a1425 1
	 * 2. If the system call returned an errno > 0, increment 
d1449 1
a1449 1
		tf->exip &= ~3;
d1462 1
a1462 1
		tf->exip &= ~3;
d1470 1
a1470 1
		tf->exip &= ~3;
d1501 1
a1501 1
		tf->snip = tf->sfip & ~3;
d1505 1
a1505 1
		tf->exip &= ~3;
d1519 1
a1519 1
unsigned 
d1527 1
a1527 1
	iov.iov_len = size; 
d1529 1
a1529 1
	uio.uio_iovcnt = 1; 
d1539 1
a1539 1
int 
d1547 1
a1547 1
	iov.iov_len = size; 
d1549 1
a1549 1
	uio.uio_iovcnt = 1; 
d1705 1
a1705 1
				printf("SS %s (%d): next taken breakpoint set at %x\n", 
d1707 1
a1707 1
#endif 
d1717 1
a1717 1
		printf("SS %s (%d): next breakpoint set at %x\n", 
d1719 1
a1719 1
#endif 
d1723 1
a1723 1
		printf("SS %s (%d): next breakpoint set at %x\n", 
d1725 1
a1725 1
#endif 
@


1.52
log
@Death to bitfields, this time "struct psr".
Also clean <machine/psl.h> contents while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.51 2003/09/17 22:22:32 miod Exp $	*/
d350 1
a350 1
				frame->dmt0 = DMT_SKIP;
a361 1
			 * For inst faults, back up the pipe line.
d375 1
a375 2
				 * won't get called again. For inst faults,
				 * back up the pipe line.
d405 1
a405 1
		frame->dmt0 = DMT_SKIP;
a1445 3
#ifdef DEBUG
		printf("syscall success!\n");
#endif
a1461 3
#ifdef DEBUG
		printf("syscall restart!\n");
#endif
a1469 3
#ifdef DEBUG
		printf("syscall just return!\n");
#endif
a1474 4
#ifdef DEBUG
		printf("syscall error %d!\n", error);
#endif
		/* error != ERESTART && error != EJUSTRETURN*/
@


1.51
log
@More cleaning of the exception handling code, and collateral damage:
- always give C routines invoked by the assembly code some breathing room on
  the stack
- merge error and reset exception handlers -- gets us rid of error_fault()
  and error_reset().
- remove all references to SR0 and "threads" inherited from Mach. In fact,
  we do not use SR0 at all now.
- only use double load and stores instructions when we are 200% sure we are
  accessing a correctly aligned area. I am not fond of unaligned kernel
  accesses, and forcing every pgb to be aligned on an 8 byte boundary is
  gross.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.50 2003/09/16 20:49:05 miod Exp $	*/
d94 2
a95 2
#define USERMODE(PSR)   (((struct psr*)&(PSR))->psr_mode == 0)
#define SYSTEMMODE(PSR) (((struct psr*)&(PSR))->psr_mode != 0)
@


1.50
log
@Clean <machine/db_machdep.h> of unused material. Also, let this file be
includable even without option DDB, in which case it will only define
the PC_REGS(), inst_return() and inst_call() macros; this removes the need
to declare them a second time in trap.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.49 2003/09/06 15:07:43 miod Exp $	*/
a101 2
void error_fault(struct m88100_saved_state *frame);
void error_reset(struct m88100_saved_state *frame);
a1124 8
test_trap(struct m88100_saved_state *frame)
{
	DEBUG_MSG("\n[test_trap (Good News[tm]) frame 0x%08x]\n", frame);
	regdump((struct trapframe*)frame);
	bugreturn();
}

void
a1140 17
#if DDB 
	Debugger();
	DEBUG_MSG("You really can't restart after exception %d!\n", frame->vector);
	Debugger();
#endif /* DDB */
	bugreturn();  /* This gets us to Bug instead of a loop forever */

}

void
error_fault(struct m88100_saved_state *frame)
{
	DEBUG_MSG("\n[ERROR EXCEPTION (Bad News[tm]) frame 0x%08x]\n", frame);
	DEBUG_MSG("This is usually an exception within an exception.  The trap\n");
	DEBUG_MSG("frame shadow registers you are about to see are invalid.\n");
	DEBUG_MSG("(read totaly useless)  But R1 to R31 might be interesting.\n");
	regdump((struct trapframe*)frame);
d1147 1
a1147 1
	DEBUG_MSG("You really can't restart after an error exception!\n");
a1150 1
}
a1151 12
void
error_reset(struct m88100_saved_state *frame) 
{
	DEBUG_MSG("\n[RESET EXCEPTION (Really Bad News[tm]) frame 0x%08x]\n", frame);
	DEBUG_MSG("This is usually caused by a branch to a NULL function pointer.\n");
	DEBUG_MSG("e.g. jump to address 0.  Use the debugger trace command to track it down.\n");
#if DDB 
	Debugger();
	DEBUG_MSG("It's useless to restart after a reset exception! You might as well reboot.\n");
	Debugger();
#endif /* DDB */
	bugreturn();  /* This gets us to Bug instead of a loop forever */
@


1.49
log
@Large cleaning of exception handling:
- faster code paths in eh.S, especially for 88110 cpus
- do not service data access exceptions more than one time; also, be sure
  that interrupts are disabled while servicing them.
- cleanup the 88110 trap handler in the same way the 88100 flavour has been
  cleaned recently.

This spotted two bugs, which are fixed there as well:
- add systrace support to the 88110 syscall code
- add emulation support to the 88100 syscall code
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.48 2003/09/04 18:14:46 miod Exp $	*/
d76 1
a77 1
#include <machine/db_machdep.h>
a78 11
#else 
   #define PC_REGS(regs) cputyp == CPU_88110 ? (regs->exip & ~3) :\
           ((regs->sxip & 2) ?  regs->sxip & ~3 : \
	(regs->snip & 2 ? regs->snip & ~3 : regs->sfip & ~3))

#define inst_return(I) (((I)&0xfffffbffU) == 0xf400c001U ? TRUE : FALSE)
#define inst_call(I) ({ unsigned i = (I); \
	   ((((i) & 0xf8000000U) == 0xc8000000U || /*bsr*/ \
      ((i) & 0xfffffbe0U) == 0xf400c800U)   /*jsr*/ \
	   ? TRUE : FALSE) \
      ;})
d544 1
a544 1
			register unsigned va;
a548 3
			/* compute address of break instruction */
			va = pc;

a1045 1
			register unsigned va;
a1048 3

			/* compute address of break instruction */
			va = pc;
@


1.48
log
@What I blamed on a specific CMMU fault pecularity turned out to be, in fact,
a nice bug preventing signals to be delivered to process faulting in some
conditions...
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.47 2003/09/03 20:18:18 miod Exp $	*/
d181 2
a182 2
		if (cputyp != CPU_88110) {
		if (type == 2) {  /* instruction exception */
d186 2
a187 1
		} else if (type == 3) {	/* data access exception */
a192 1
		}
a204 1
/*ARGSUSED*/
d282 4
a317 5
		/*
		 * If the faulting address is in user space, handle it in
		 * the context of the user process. Else, use kernel map.
		 */

d427 1
a427 1
		/* FALLTHRU */
a664 1
unsigned v_fault = 0;
a666 1
/*ARGSUSED*/
d683 1
a683 1
	int result = 0;  /* Assume Success */
a685 1
	unsigned user = 0, data = 0;
d687 1
a693 1

d696 2
a697 1
#if 1
a712 1
		user = 1;
a713 1
	
d756 1
a756 1
                               frame->exip += 4;
d802 9
a810 16
		/*
		 * If the faulting address is in user space, handle it in
		 * the context of the user process. Else, use kernel map.
		 */
		if (type == T_DATAFLT) {
			fault_addr = frame->dlar;
			if (frame->dsr & CMMU_DSR_RW) {
				ftype = VM_PROT_READ;
				fault_code = VM_PROT_READ;
			} else {
				ftype = VM_PROT_READ|VM_PROT_WRITE;
				fault_code = VM_PROT_WRITE;
			}
			data = 1;
		} else {
			fault_addr = frame->exip & XIP_ADDR;
d813 3
d819 4
d824 1
a824 1
		map = &vm->vm_map;
d826 9
a834 4
		/* data fault on a kernel address... */
		if (type == T_DATAFLT) {
			if (frame->dsr & CMMU_DSR_SU) {
				map = kernel_map;
d837 8
a844 5

		/* data fault on the user address */
		if (type == T_DATAFLT && (frame->dsr & CMMU_DSR_SU) == 0) {
			type = T_DATAFLT + T_USER;
			goto m88110_user_fault;
d846 3
a848 24

		/*
		 *	If it is a guarded access, bus error is OK.
		 */

		if ((frame->dsr & CMMU_DSR_BE) &&     /* bus error */
		    (frame->exip & ~3) >= (unsigned)&guarded_access_start &&
		    (frame->exip & ~3) <= (unsigned)&guarded_access_end) {
			return;
		}
		/*
		 *	On a segment or a page fault, call vm_fault() to resolve
		 *	the fault.
		 */
		if (type == T_DATAFLT) {
			if ((frame->dsr & CMMU_DSR_SI)	      /* seg fault  */
			    || (frame->dsr & CMMU_DSR_PI)) { /* page fault */
				result = uvm_fault(map, va, 0, ftype);
				if (result == 0) {
					return;
				}
			}
			if (frame->dsr & CMMU_DSR_WE) { /* write fault  */
			/* This could be a write protection fault or an 
d850 1
a850 1
			 * in the pte.  Basicly, if we got a write error, 
d857 14
a870 12
				pte = pmap_pte(map->pmap, va);
				if (pte == PT_ENTRY_NULL)
					panic("NULL pte on write fault??");
				if (!(*pte & PG_M) && !(*pte & PG_RO)) {
					/* Set modified bit and try the write again. */
					*pte |= PG_M;
					return;
				}
			}
		} else {
			if ((frame->isr & CMMU_ISR_SI)	      /* seg fault  */
			    || (frame->isr & CMMU_ISR_PI)) { /* page fault */
d872 1
a872 1
				if (result == 0) {
d874 1
a874 1
				}
d877 1
d888 1
a888 1
		/*FALLTHRU*/
d911 4
a914 1
		/* Call vm_fault() to resolve non-bus error faults */
d916 7
a922 3

			if (frame->dsr & (CMMU_DSR_SI |   /* seg fault  */
					  CMMU_DSR_PI)) { /* page fault */
d924 2
a925 1
				if (result != 0) {
d927 4
a930 6
				}
				v_fault++;
			} else if (frame->dsr & CMMU_DSR_BE) {	/* bus error */
				result = EFAULT;
			} else if ((frame->dsr & CMMU_DSR_CP)
				   || (frame->dsr & CMMU_DSR_WA)) {
d932 13
a944 10
			} else if (frame->dsr & CMMU_DSR_WE) {	/* write fault  */
			/* This could be a write protection fault or an 
			 * exception to set the used and modified bits
			 * in the pte.  Basicly, if we got a write error, 
			 * then we already have a pte entry that faulted 
			 * in from a previous seg fault or page fault.
			 * Get the pte and check the status of the 
			 * modified and valid bits to determine if this 
			 * indeed a real write fault.  XXX smurph
			 */
d948 5
a952 2
				if (!(*pte & PG_M) && !(*pte & PG_PROT)) {
					/* Set modified bit and try the write again. */
d954 4
a957 1
					/* invalidate ATCs to force table search */
d961 5
a965 2
					/* This must be a real write protection fault */
					printf("Write protect???? mod = %d, wp = %d\n", !!(*pte & PG_M), !!(*pte & PG_PROT));
d968 6
d976 3
a978 2
			if ((frame->isr & CMMU_ISR_SI)	      /* seg fault  */
			    || (frame->isr & CMMU_ISR_PI)) { /* page fault */
d980 4
a983 4
				v_fault++;
			} else if ((frame->isr & CMMU_ISR_BE)
				   || (frame->isr & CMMU_ISR_SP)
				   || (frame->isr & CMMU_ISR_TBE)) { /* bus error */
d985 6
a1003 5
#ifdef smurph_debug
			printf("Access failed! result = %d\n\n", result);
			frame->mode = v_fault;
			regdump(frame);
			Debugger();
d1005 2
a1006 2
			fault_type = result == EACCES ? BUS_ADRERR : SEGV_MAPERR;
#endif		
a1058 5
#if 0
		frame->sfip = frame->snip;    /* set up next FIP */
		frame->snip = frame->sxip;    /* set up next NIP */
		break;
#endif
d1070 1
a1070 1
#if 1
d1086 1
a1086 4
			if (instr == 0) {
				printf("Warning: can't restore instruction at %x: %x\n",
				       p->p_md.md_ss_addr, p->p_md.md_ss_instr);
			} else {
d1122 1
d1126 1
a1126 1
	if (SYSTEMMODE(frame->epsr))
d1136 1
a1136 2
		frame->dsr = 0;
		frame->isr = 0;
d1138 1
d1364 2
d1445 1
d1447 1
d1470 6
a1475 1
	error = (*callp->sy_call)(p, &args, rval);
d1506 1
d1508 1
d1521 1
a1521 1
		tf->exip += 8; 
d1525 1
d1527 1
d1536 1
d1538 1
a1538 1
		/* if (error == EJUSTRETURN) */
d1544 1
d1546 1
d1587 1
a1587 1
		tf->exip += 8;
d1812 1
d1815 1
@


1.47
log
@I'm walking on very, very thin ice here. Still trying to get the ``special''
DAE to pass; the first fix was too brutal, the second one too shy; this third
one is apparently just in the middle to make everything happy so far...
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.46 2003/09/03 14:48:57 miod Exp $	*/
a467 1
			frame->ipfsr = frame->dpfsr = 0;
d498 1
a500 19
			/*
			 * XXX
			 * Page faults for addresses in page zero _SEEM TO BE_
			 * special.
			 * For some reason, we will keep faulting with the same
			 * cause when the interrupts get enabled, later in the
			 * exception process, and eventually eat all the
			 * interrupt stack in a recursive DAE.
			 * Since accesses to this page will always result in a
			 * SIGSEGV, we can safely clear the DAE condition here.
			 *
			 * (behaviour experienced on MVME187C)
			 */
			if (va == 0 && type == (T_DATAFLT + T_USER) &&
			    SYSTEMMODE(frame->epsr)) {
				frame->dpfsr = 0;
				frame->dmt0 = 0;
			}

d650 1
a650 1
	if (SYSTEMMODE(frame->epsr))
d661 1
a661 1
		frame->dpfsr = 0;
@


1.46
log
@Use symbolic constants for pbus fault codes.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.45 2003/09/03 01:15:56 miod Exp $	*/
a459 1
#if 0
a462 1
#endif
a514 1
			    pbus_type == CMMU_PFSR_PFAULT &&
@


1.45
log
@Be more cautious in the previous fix - we don't want to skip valid data access
exceptions by mistake.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.44 2003/09/02 20:57:21 miod Exp $	*/
d67 1
d345 1
a345 1
		case 3:	/* bus error */
d372 1
a372 1
		case 0: /* no fault */
d383 2
a384 2
		case 4:	/* seg fault */
		case 5:	/* page fault */
d461 1
a461 1
		case 0:
d465 1
a465 1
		case 3:
d517 2
a518 1
			    pbus_type == 5 && SYSTEMMODE(frame->epsr)) {
@


1.44
log
@User mode page faults for page zero require special treatment to prevent
a recursive DAE.

Scientists say this is proof that there's a ``strange attractor'' in the
m88k processors. What is certain, though, is that the processors'
documentation contains black holes.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.43 2003/09/02 10:35:53 miod Exp $	*/
a453 18
		/*
		 * XXX
		 * Page faults for addresses in page zero _SEEM TO BE_ special.
		 * For some reason, we will keep faulting with the same
		 * cause when the interrupts get enabled, later in the
		 * exception process, and eventually eat all the interrupt
		 * stack in a recursive DAE.
		 * Since accesses to this page will always result in a
		 * SIGSEGV, we can safely clear the DAE condition here.
		 *
		 * (behaviour experienced on MVME187C)
		 */
		if (va == 0) {
			frame->dpfsr = 0;
			frame->dmt0 = 0;
			result = EFAULT;
		}

d459 1
d463 1
d502 20
a521 1
			sig = result == EACCES ?  SIGBUS : SIGSEGV;
@


1.43
log
@Cleanup and simplify data and instruction fault trap handling for 88100.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.42 2003/09/01 22:51:05 miod Exp $	*/
d453 18
@


1.42
log
@The most harmful bugs are always so blatant it takes hours to spot them...

Correctly setup the vector table for T_SIGSYS and T_SIGTRAP traps, and
handle T_SIGSYS userland traps. This passes a complete usertrap regression
test now.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.41 2003/09/01 18:22:30 miod Exp $	*/
d213 1
a213 1
	int fault_type;
d218 1
a218 1
	int result = 0;  
d307 7
d319 4
a322 9
		if (type == T_DATAFLT) {
			fault_addr = frame->dma0;
			if (frame->dmt0 & (DMT_WRITE|DMT_LOCKBAR)) {
				ftype = VM_PROT_READ|VM_PROT_WRITE;
				fault_code = VM_PROT_WRITE;
			} else {
				ftype = VM_PROT_READ;
				fault_code = VM_PROT_READ;
			}
a323 1
			fault_addr = frame->sxip & XIP_ADDR;
d329 3
d334 1
a334 1
		map = &vm->vm_map;
d336 4
a339 13
		/* data fault on a kernel address... */
		if (frame->dmt0 & DMT_DAS)
			map = kernel_map;

		/* data fault on the user address */
		if (type == T_DATAFLT && (frame->dmt0 & DMT_DAS) == 0) {
			type = T_DATAFLT + T_USER;
			goto user_fault;
		}
#if 0
		printf("\nKernel Data access fault #%d (%s) v = 0x%x, frame 0x%x cpu %d\n",
		       ((frame->dpfsr >> 16) & 0x7),
		       pbus_exception_type[(frame->dpfsr >> 16) & 0x7],
d342 30
a371 27
		/*
		 * If it is a guarded access, bus error is OK.
		 */
		if ((frame->dpfsr >> 16 & 0x7) == 0x3 &&     /* bus error */
		    (frame->sxip & ~3) >= (unsigned)&guarded_access_start &&
		    (frame->sxip & ~3) <= (unsigned)&guarded_access_end) {

			frame->snip = ((unsigned)&guarded_access_bad    ) | NIP_V;
			frame->sfip = ((unsigned)&guarded_access_bad + 4) | FIP_V;
			frame->sxip = 0;
			/* We sort of resolved the fault ourselves because 
			 * we know where it came from.  [gaurded_assess()]
			 * But we must still think about the other possible 
			 * transactions in dmt1 & dmt2.  Mark dmt0 so that 
			 * data_access_emulation skips it.  XXX smurph
			 */
			frame->dmt0 = DMT_SKIP;
			frame->dpfsr = 0;
                        data_access_emulation((unsigned *)frame);
                        /* so data_access_emulation doesn't get called again. */
			frame->dmt0 = 0;
			return;
		}
		/*
		 *	On a no fault, just return.
		 */
		if ((frame->dpfsr >> 16 & 0x7) == 0x0) {     /* no fault  */
d378 6
a383 26
				if (type == T_DATAFLT) {
					/*
					printf("calling data_access_emulation()\n");
					*/
					data_access_emulation((unsigned *)frame);
					frame->dmt0 = 0;
					frame->dpfsr = 0;
				} else {
					frame->sfip = frame->snip & ~FIP_E;
					frame->snip = frame->sxip & ~NIP_E;
				}
				return;
		}

		/*
		 *	On a segment or a page fault, call vm_fault() to resolve
		 *	the fault.
		 */
		if ((unsigned)map & 3) {
			printf("map is not word aligned! 0x%x\n", map);
#ifdef DDB
			Debugger();
#endif
		}
		if ((frame->dpfsr >> 16 & 0x7) == 0x4	     /* seg fault  */
		    || (frame->dpfsr >> 16 & 0x7) == 0x5) {  /* page fault */
d386 10
a395 17
			/*
			 * We could resolve the fault. Call
			 * data_access_emulation to drain the data unit pipe
			 * line and reset dmt0 so that trap won't get called
			 * again. For inst faults, back up the pipe line.
			 */
				if (type == T_DATAFLT) {
					/*
					printf("calling data_access_emulation()\n");
					*/
					data_access_emulation((unsigned *)frame);
					frame->dmt0 = 0;
					frame->dpfsr = 0;
				} else {
					frame->sfip = frame->snip & ~FIP_E;
					frame->snip = frame->sxip & ~NIP_E;
				}
d398 1
d400 4
a403 4
		/*
		printf ("PBUS Fault %d (%s) va = 0x%x\n", ((frame->dpfsr >> 16) & 0x7), 
			pbus_exception_type[(frame->dpfsr >> 16) & 0x7], va);
		*/
d407 1
a407 1
		if (!p->p_addr->u_pcb.pcb_onfault)
d410 4
a413 2
		frame->snip = ((unsigned)p->p_addr->u_pcb.pcb_onfault    ) | FIP_V;
		frame->sfip = ((unsigned)p->p_addr->u_pcb.pcb_onfault + 4) | FIP_V;
d416 1
a416 1
		 * we know where it came from.  [fuwintr() or suwintr()]
d422 1
a423 2
		data_access_emulation((unsigned *)frame);
		/* so data_access_emulation doesn't get called again. */
d430 1
a430 1
		user_fault:
d433 1
d436 1
d438 1
a438 1
#if 0
d440 1
a440 2
		       ((frame->dpfsr >> 16) & 0x7),
		       pbus_exception_type[(frame->dpfsr >> 16) & 0x7],
d456 10
a465 9
		if ((unsigned)map & 3) {
			printf("map is not word aligned! 0x%x\n", map);
#ifdef DDB
			Debugger();
#endif
		}
		/* Call vm_fault() to resolve non-bus error faults */
		if ((frame->ipfsr >> 16 & 0x7) != 0x3 &&
		    (frame->dpfsr >> 16 & 0x7) != 0x3) {
d468 1
d482 6
a487 6
			/*
			 * We could resolve the fault. Call
			 * data_access_emulation to drain the data unit
			 * pipe line and reset dmt0 so that trap won't
			 * get called again.
			 */
d489 1
a490 1
				frame->dpfsr = 0;
d492 4
a495 1
			/* back up SXIP, SNIP clearing the the Error bit */
d500 1
a500 2
			sig = result == EACCES ?
				SIGBUS : SIGSEGV;
@


1.41
log
@Do not let userland programs enter DDB at will - it's a BAD thing.

Also, fix a logic error in m88100_syscall() which prevented ERESTART and
EJUSTRETURN to be returned (gasp!)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.40 2003/08/09 21:19:59 miod Exp $	*/
d558 3
d1050 3
@


1.40
log
@New RAMDISK configuration, inspired by the mvme68k one; and the associated
fixes to get the kernel to compile without option DDB and without
option DIAGNOSTIC.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.39 2003/01/13 20:12:18 miod Exp $	*/
a250 2
		/*FALLTHRU*/
	case T_KDB_BREAK+T_USER:
a259 2
		/*FALLTHRU*/
	case T_KDB_ENTRY+T_USER:
d533 8
a765 2
		/*FALLTHRU*/
	case T_KDB_BREAK+T_USER:
a772 2
		/*FALLTHRU*/
	case T_KDB_ENTRY+T_USER:
d1023 8
d1344 2
a1345 1
	if (error == 0) {
d1360 2
a1361 7
	} else if (error > 0) {
		/* error != ERESTART && error != EJUSTRETURN*/
		tf->r[2] = error;
		tf->epsr |= PSR_C;   /* fail */
		tf->snip = tf->snip & ~NIP_E;
		tf->sfip = tf->sfip & ~FIP_E;
	} else if (error == ERESTART) {
d1369 2
a1370 1
	} else {
d1373 8
d1395 1
a1395 1
/* Instruction pointers opperate differently on mc88110 */
@


1.39
log
@Clean up ipl handling: be sure to always return valid levels in getipl(),
and check input level in setipl() if DIAGNOSTIC.

Doing this pointed out an horrible bug where exception frames would refer
to the saved ipl at the time the exception was processed, but would not
save it before, and the joys of stack values would make it a correct value
90% of the time. Of course, bad things could happen when restoring the
``saved'' ipl...
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.38 2003/01/09 22:27:10 miod Exp $	*/
d698 1
d700 1
d716 5
a720 1
	if (type != T_INT && type != T_ASTFLT && type != T_KDB_ENTRY ) {
d753 1
a753 1
   #if defined(DDB)
d1229 1
d1231 1
d1395 1
d1397 1
@


1.38
log
@Remove fetch(9) and store(9) functions from the kernel, and replace the few
remaining instances of them with appropriate copy(9) usage.

ok art@@, tested on all arches unless my memory is non-ECC
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.37 2003/01/03 23:17:43 miod Exp $	*/
d254 1
a254 1
			int s = db_splhigh();
d258 1
a258 1
			db_splx(s);
d265 1
a265 1
			int s = db_splhigh();
d269 1
a269 1
			db_splx(s);
d276 1
a276 1
			int s = db_splhigh();
d281 1
a281 1
			db_splx(s);
d749 1
a749 2
		frame->mask = spl(); /* get current spl for reg dump */
		s = db_splhigh();
d753 1
a753 1
		db_splx(s);
d758 6
a763 7
		frame->mask = spl(); /* get current spl for reg dump */
		s = db_splhigh();
			db_enable_interrupt();
			ddb_break_trap(T_KDB_BREAK,(db_regs_t*)frame);
			db_disable_interrupt();
			db_splx(s);
			return;
d767 4
a770 5
		frame->mask = spl(); /* get current spl for reg dump */
		s = db_splhigh();
			db_enable_interrupt();
			ddb_entry_trap(T_KDB_ENTRY,(db_regs_t*)frame);
			db_disable_interrupt();
d776 2
a777 2
			db_splx(s);
			return;
d780 7
a786 9
		{
			int s = db_splhigh();
			db_enable_interrupt();
			ddb_error_trap(type == T_ILLFLT ? "unimplemented opcode" :
				       "error fault", (db_regs_t*)frame);
			db_disable_interrupt();
			db_splx(s);
			return;
		}
d1809 1
a1809 1
	oldipl = spl();
@


1.37
log
@splassert support for m88k
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.36 2002/05/16 21:11:16 miod Exp $	*/
a339 13
		/* 
		 * We don't want to call vm_fault() if it is fuwintr() or
		 * suwintr(). These routines are for copying from interrupt
		 * context and vm_fault() can potentially sleep. You may
		 * wonder if it isn't bad karma for an interrupt handler to	
		 * touch the current process. Indeed it is, but clock interrupt
		 * does it while doing profiling. It is OK in that context.
		 */

		if (p->p_addr->u_pcb.pcb_onfault == (int)fubail ||
		    p->p_addr->u_pcb.pcb_onfault == (int)subail)
			goto outtahere;

a441 1
outtahere:
d580 1
a580 1
			instr = fuiword((caddr_t)pc);
a855 13
		/* 
		 * We don't want to call vm_fault() if it is fuwintr() or
		 * suwintr(). These routines are for copying from interrupt
		 * context and vm_fault() can potentially sleep. You may
		 * wonder if it isn't bad karma for an interrupt handler to	
		 * touch the current process. Indeed it is, but clock interrupt
		 * does it while doing profiling. It is OK in that context.
		 */

		if (p->p_addr->u_pcb.pcb_onfault == (int)fubail ||
		    p->p_addr->u_pcb.pcb_onfault == (int)subail)
			goto m88110_outtahere;

a916 1
m88110_outtahere:
d1070 1
a1070 1
			instr = fuiword((caddr_t)pc);
@


1.36
log
@Add systrace support to all the remaining architectures.

Tested by various people on various platforms, I'm willing to fix any
breakage this causes.

ok niels@@ deraadt@@ and mickey@@ (after his comments were applied)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.35 2002/03/26 01:00:27 miod Exp $	*/
d1835 19
@


1.35
log
@Honor psratio for addupc_task(), as other arches do.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.34 2002/03/14 01:26:40 millert Exp $	*/
d56 3
d1323 6
a1328 1
	error = (*callp->sy_call)(p, &args, rval);
@


1.34
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.33 2001/12/24 04:12:40 miod Exp $	*/
d162 6
a167 2
	if (p->p_flag & P_PROFIL)
		addupc_task(p, frame->sxip & ~3,(int)(p->p_sticks - oticks));
@


1.33
log
@- completely change the mmu segment and page table structure definitions,
to use constant bitmasks instead of bitfields.
- remove unnecessary (as long as we are not running SMP) locks on the
physsegs.
- update the pmap code to take these changes into account, and gratuitously
change several names and code paths to be closer to existing m68k pmaps. It's
a bit faster now.
- change pmap.c's usage of vm_{offset,size}_t to {p,v}{addr,size}_t.
- remove dead or unused stuff from pmap.c, fix typos, etc

Tested on 187 and 188, should not make things worse for 197.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.32 2001/12/22 17:57:11 smurph Exp $	*/
d105 1
a105 1
extern int procfs_domem __P((struct proc *, struct proc *, void *, struct uio *));
d107 4
a110 4
extern void regdump __P((struct trapframe *f));
void error_fatal __P((struct m88100_saved_state *frame));
void error_fault __P((struct m88100_saved_state *frame));
void error_reset __P((struct m88100_saved_state *frame));
d714 1
a714 1
	extern pt_entry_t *pmap_pte __P((pmap_t, vm_offset_t));
@


1.32
log
@change function names to reflect cpu type instead of board type.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.31 2001/12/22 10:34:32 smurph Exp $	*/
d916 1
a916 1
				if (!pte->modified && !pte->prot) {
d918 1
a918 1
					pte->modified = 1; 
d993 1
a993 1
				if (!pte->modified && !pte->prot) {
d995 1
a995 1
					pte->modified = 1;
d1001 1
a1001 1
					printf("Write protect???? mod = %d, wp = %d\n", pte->modified, pte->prot);
@


1.31
log
@mc88110 modifications.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.30 2001/12/20 06:07:28 smurph Exp $	*/
d199 1
a199 1
trap18x(unsigned type, struct m88100_saved_state *frame)
d688 1
d693 1
a693 1
trap197(unsigned type, struct m88100_saved_state *frame)
d720 5
d1009 1
d1027 1
a1027 1
#if 0
a1033 2
#else
			result = 0;
d1238 1
a1238 1
syscall(register_t code, struct m88100_saved_state *tf)
d1397 1
a1397 1
m197_syscall(register_t code, struct m88100_saved_state *tf)
d1453 1
a1453 1

@


1.30
log
@machine dependant pointer changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.29 2001/12/16 23:49:47 miod Exp $	*/
d60 1
a60 1
#include <machine/cpu.h>		/* DMT_VALID, etc. */
d63 1
a63 1
#include <machine/m88100.h>		/* DMT_VALID, etc. */
d66 1
a66 1
#include <machine/m88110.h>		/* DMT_VALID, etc. */
d76 2
a77 1
#define PC_REGS(regs) ((regs->sxip & 2) ?  regs->sxip & ~3 : \
d79 1
d108 3
d124 1
d173 1
d184 1
d193 1
a193 1
#if defined(MVME187) || defined(MVME188)
d211 1
a211 1
	int result;
d283 1
a283 1
		   on the value of cputyp - smurph */
d364 1
a364 1
			frame->snip = ((unsigned)&guarded_access_bad    ) | FIP_V;
d687 1
a687 1
#endif /* defined(MVME187) || defined(MVME188) */
d689 1
a689 1
#ifdef MVME197
d704 2
a705 1
	int result;
d707 3
a709 3
	unsigned pc = PC_REGS(frame);  /* get program counter (sxip) */
	unsigned user = 0, write = 0, data = 0;

d713 1
d726 1
d728 1
a728 1
	printf("m197_trap 0x%x ", type);
a733 1
		user = 1;
d735 3
a737 33
		va = (vm_offset_t) frame->dlar;
		/* if it was a user read, handle in context of the user */
		if ((frame->dsr & CMMU_DSR_SU) && !user) {
			map = kernel_map;
		} else {
			vm = p->p_vmspace;
			map = &vm->vm_map;
		}
		result = m197_table_search(map->pmap, va, CMMU_READ, user, CMMU_DATA);
		if (result) {
			switch (result) {
			case 4:	/* Seg Fault */
				frame->dsr |= CMMU_DSR_SI | CMMU_DSR_RW;
				break;
			case 5:	/* Page Fault */
				frame->dsr |= CMMU_DSR_PI | CMMU_DSR_RW;
				break;
			case 6:	/* Supervisor Violation */
				frame->dsr |= CMMU_DSR_SP | CMMU_DSR_RW;
				break;
			}
			/* table search failed and we are going to report a data fault */
			if (user) {
				type = T_DATAFLT+T_USER;
				goto m197_user_fault;
			} else {
				type = T_DATAFLT;
				goto m197_data_fault;
			}
		} else {
			return;	/* PATC sucessfully loaded */
		}
		break;      
a738 1
		user = 1;
d740 3
a742 36
		/* if it was a user read, handle in context of the user */
		if ((frame->dsr & CMMU_DSR_SU) && !user) {
			map = kernel_map;
		} else {
			vm = p->p_vmspace;
			map = &vm->vm_map;
		}
		va = (vm_offset_t) frame->dlar;
		result = m197_table_search(map->pmap, va, CMMU_WRITE, user, CMMU_DATA);
		if (result) {
			switch (result) {
			case 4:	/* Seg Fault */
				frame->dsr |= CMMU_DSR_SI;
				break;
			case 5:	/* Page Fault */
				frame->dsr |= CMMU_DSR_PI;
				break;
			case 6:	/* Supervisor Violation */
				frame->dsr |= CMMU_DSR_SP;
				break;
			case 7:	/* Write Violation */
				frame->dsr |= CMMU_DSR_WE;
				break;
			}
			/* table search failed and we are going to report a data fault */
			if (user) {
				type = T_DATAFLT+T_USER;
				goto m197_user_fault;
			} else {
				type = T_DATAFLT;
				goto m197_data_fault;
			}
		} else {
			return;	/* PATC sucessfully loaded */
		}
		break;      
a743 1
		user = 1;
d745 3
a747 33
		/* if it was a user read, handle in context of the user */
		if ((frame->isr & CMMU_ISR_SU) && !user) {
			map = kernel_map;
		} else {
			vm = p->p_vmspace;
			map = &vm->vm_map;
		}
		va = (vm_offset_t) frame->sxip;
		result = m197_table_search(map->pmap, va, CMMU_READ, user, CMMU_INST);
		if (result) {
			switch (result) {
			case 4:	/* Seg Fault */
				frame->isr |= CMMU_ISR_SI;
				break;
			case 5:	/* Page Fault */
				frame->isr |= CMMU_ISR_PI;
				break;
			case 6:	/* Supervisor Violation */
				frame->isr |= CMMU_ISR_SP;
				break;
			}
			/* table search failed and we are going to report a data fault */
			if (user) {
				type = T_INSTFLT+T_USER;
				goto m197_user_fault;
			} else {
				type = T_INSTFLT;
				goto m197_inst_fault;
			}
		} else {
			return;	/* PATC sucessfully loaded */
		}
		break;      
d749 8
d760 2
a761 2
		{
			int s = db_splhigh();
a766 1
		}
d770 2
a771 2
		{
			int s = db_splhigh();
d775 5
a781 2
		}

d796 1
a796 2
		DEBUG_MSG("test trap "
			  "page fault @@ 0x%08x\n", frame->sxip);
d799 10
a808 1

d810 2
a811 2
		DEBUG_MSG("kernel misaligned "
			  "access exception @@ 0x%08x\n", frame->sxip);
d813 1
a813 1
		break;
a815 1
		m197_inst_fault:
d820 1
a820 1
			  "page fault @@ 0x%08x\n", frame->sxip);
d822 1
a822 1
		break;
a829 1
		m197_data_fault:
a837 1
				write = 1;
d841 1
a841 1
			fault_addr = frame->sxip & XIP_ADDR;
d868 1
a868 1
			goto m197_outtahere;
d873 1
a873 1
			goto m197_user_fault;
d881 2
a882 2
		    (frame->sxip & ~3) >= (unsigned)&guarded_access_start &&
		    (frame->sxip & ~3) <= (unsigned)&guarded_access_end) {
a884 1

a888 6
		result = m197_table_search(map->pmap, va, write, 1, data);
#ifdef todo         
		switch (result) {
		case :
		}
#endif
d897 19
d931 2
a932 2
		m197_outtahere:
		frame->sxip = ((unsigned)p->p_addr->u_pcb.pcb_onfault);
d938 1
a938 1
		m197_user_fault:
d940 1
a940 1
			fault_addr = frame->sxip & XIP_ADDR;
a958 1

d961 3
a963 2
			if ((frame->dsr & CMMU_DSR_SI)	      /* seg fault  */
			    || (frame->dsr & CMMU_DSR_PI)) { /* page fault */
d965 27
a991 1
				if (result == 0) {
d993 4
d1003 4
a1006 3
				if (result == 0) {
					return;
				}
d1020 5
d1026 4
a1029 4
			fault_type = result == EACCES ? BUS_ADRERR
				     : SEGV_MAPERR;
		} else {
			return;
a1117 3
			frame->sfip = frame->snip;    /* set up next FIP */
			frame->snip = frame->sxip;    /* set up next NIP */
			frame->snip |= 2;	  /* set valid bit   */
a1128 2
		frame->sfip = frame->snip;    /* set up the next FIP */
		frame->snip = frame->sxip;    /* set up the next NIP */
d1156 1
d1172 26
d1205 1
a1205 1
#if defined(MVME187) || defined(MVME188)
d1231 1
a1288 1

d1318 3
a1320 3
	 *       tb0 0, r0, <128> <- xip
	 *	 br err 	  <- nip
	 *       jmp r1 	  <- fip
d1357 1
a1357 1
		tf->snip = tf->sfip & ~FIP_E;
d1371 1
a1371 1
		tf->sfip = tf->snip & ~NIP_E;
d1386 3
a1389 1
#ifdef MVME197
d1478 2
a1479 2
	 *       tb0 0, r0, <128> <- sxip
	 *	 br err 	  <- snip
d1486 1
a1486 1
	 * So, when we take syscall trap, sxip/snip will be as
d1490 1
a1490 1
	 *	   sxip += 8
d1492 1
a1492 1
	 *    sxip += 4 and plug the value in r2. This will have us
d1495 1
a1495 1
	 *    we need to rexecute the trap instruction. leave xip as is.
d1497 1
a1497 1
	 *    sxip += 8
d1500 3
a1502 1
	if (error == 0) {
d1515 5
a1519 9
		tf->sxip += 8;
		tf->sxip &= ~3;
	} else if (error > 0) {
		/* error != ERESTART && error != EJUSTRETURN*/
		tf->r[2] = error;
		tf->epsr |= PSR_C;   /* fail */
		tf->sxip += 4;
		tf->sxip &= ~3;
	} else if (error == ERESTART) {
d1521 3
a1523 2
		 * If (error == ERESTART), back up the pipe line. This
		 * will end up reexecuting the trap.
d1526 3
a1528 1
	} else {
d1531 13
a1543 2
		tf->sxip += 8; 
		tf->sxip &= ~3;
d1545 1
d1572 1
a1572 7
#ifdef MVME197
	if (cputyp == CPU_197) {
		tf->sxip += 8;
		tf->sxip &= ~3;
	} else
#endif
	{
d1575 3
@


1.29
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.27 2001/11/28 16:13:29 art Exp $	*/
d62 1
d64 2
a65 1
#ifdef MVME197
d276 1
a276 1
		(*mdfp.interrupt_func)(T_INT, frame);
@


1.29.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.33 2001/12/24 04:12:40 miod Exp $	*/
d60 1
a60 1
#include <machine/cpu.h>
d62 3
a64 5
#ifdef M88100
#include <machine/m88100.h>
#endif
#ifdef M88110
#include <machine/m88110.h>
d74 1
a74 2
   #define PC_REGS(regs) cputyp == CPU_88110 ? (regs->exip & ~3) :\
           ((regs->sxip & 2) ?  regs->sxip & ~3 : \
a75 1

a103 3
void error_fatal __P((struct m88100_saved_state *frame));
void error_fault __P((struct m88100_saved_state *frame));
void error_reset __P((struct m88100_saved_state *frame));
a116 1
	"Non-Maskable Exception",
a164 1
		if (cputyp != CPU_88110) {
a174 1
		}
d183 1
a183 1
#ifdef M88100
d189 1
a189 1
m88100_trap(unsigned type, struct m88100_saved_state *frame)
d201 1
a201 1
	int result = 0;  
d273 2
a274 2
		   on the value of brdtyp - smurph */
		(*md.interrupt_func)(T_INT, frame);
d354 1
a354 1
			frame->snip = ((unsigned)&guarded_access_bad    ) | NIP_V;
d677 1
a677 2
#endif /* m88100 */
unsigned v_fault = 0;
d679 1
a679 1
#ifdef M88110
d682 1
a682 1
m88110_trap(unsigned type, struct m88100_saved_state *frame)
d694 1
a694 2
        int s; /* IPL */
	int result = 0;  /* Assume Success */
d696 3
a698 3
	unsigned pc = PC_REGS(frame);  /* get program counter (exip) */
	unsigned user = 0, data = 0;
	pt_entry_t *pte;
a701 1
	extern pt_entry_t *pmap_pte __P((pmap_t, vm_offset_t));
a706 5
#if 1
	if (type != T_INT && type != T_ASTFLT && type != T_KDB_ENTRY ) {
		printf("m88110_trap: %d %s\n", type, frame->vector < trap_types ? trap_type[frame->vector] : "unknown");
	}
#endif
a713 1
		user = 1;
d715 1
a715 1
	
d721 1
d723 33
a755 3
		DEBUG_MSG("DMMU read miss: Hardware Table Searches should be enabled!\n");
		panictrap(frame->vector, frame);
		/*NOTREACHED*/
d757 1
d759 36
a794 3
		DEBUG_MSG("DMMU write miss: Hardware Table Searches should be enabled!\n");
		panictrap(frame->vector, frame);
		/*NOTREACHED*/
d796 1
d798 33
a830 3
		DEBUG_MSG("IMMU miss: Hardware Table Searches should be enabled!\n");
		panictrap(frame->vector, frame);
		/*NOTREACHED*/
a831 8
	case T_KDB_TRACE:
		frame->mask = spl(); /* get current spl for reg dump */
		s = db_splhigh();
		db_enable_interrupt();
		ddb_break_trap(T_KDB_TRACE,(db_regs_t*)frame);
		db_disable_interrupt();
		db_splx(s);
		return;
d835 2
a836 2
		frame->mask = spl(); /* get current spl for reg dump */
		s = db_splhigh();
d842 1
d846 2
a847 2
		frame->mask = spl(); /* get current spl for reg dump */
		s = db_splhigh();
a850 5
		if (frame->enip) {
			frame->exip = frame->enip;
		} else {
                               frame->exip += 4;
		}
d853 2
d869 2
a870 1
		DEBUG_MSG("Unimplemented opcode!\n");
d873 1
a873 10
	case T_NON_MASK:
	case T_NON_MASK+T_USER:
		/* This function pointer is set in machdep.c 
		   It calls m197_ext_int - smurph */
		(*md.interrupt_func)(T_NON_MASK, frame);
		return;
	case T_INT:
	case T_INT+T_USER:
		(*md.interrupt_func)(T_INT, frame);
		return;
d875 2
a876 2
		DEBUG_MSG("kernel mode misaligned "
			  "access exception @@ 0x%08x\n", frame->exip);
d878 1
a878 1
		/*NOTREACHED*/
d881 1
d886 1
a886 1
			  "page fault @@ 0x%08x\n", frame->exip);
d888 1
a888 1
		/*NOTREACHED*/
d896 1
d905 1
d909 1
a909 1
			fault_addr = frame->exip & XIP_ADDR;
d936 1
a936 1
			goto m88110_outtahere;
d941 1
a941 1
			goto m88110_user_fault;
d949 2
a950 2
		    (frame->exip & ~3) >= (unsigned)&guarded_access_start &&
		    (frame->exip & ~3) <= (unsigned)&guarded_access_end) {
d953 1
d958 6
a971 19
			if (frame->dsr & CMMU_DSR_WE) { /* write fault  */
			/* This could be a write protection fault or an 
			 * exception to set the used and modified bits
			 * in the pte.  Basicly, if we got a write error, 
			 * then we already have a pte entry that faulted 
			 * in from a previous seg fault or page fault.
			 * Get the pte and check the status of the 
			 * modified and valid bits to determine if this 
			 * indeed a real write fault.  XXX smurph
			 */
				pte = pmap_pte(map->pmap, va);
				if (pte == PT_ENTRY_NULL)
					panic("NULL pte on write fault??");
				if (!(*pte & PG_M) && !(*pte & PG_RO)) {
					/* Set modified bit and try the write again. */
					*pte |= PG_M;
					return;
				}
			}
d987 2
a988 2
m88110_outtahere:
		frame->exip = ((unsigned)p->p_addr->u_pcb.pcb_onfault);
d994 1
a994 1
m88110_user_fault:
d996 1
a996 1
			fault_addr = frame->exip & XIP_ADDR;
d1015 1
d1018 2
a1019 3

			if (frame->dsr & (CMMU_DSR_SI |   /* seg fault  */
					  CMMU_DSR_PI)) { /* page fault */
d1021 1
a1021 27
				if (result != 0) {
					printf("Data Access Error @@ 0x%x\n", va);
				}
				v_fault++;
			} else if (frame->dsr & CMMU_DSR_BE) {	/* bus error */
				result = EFAULT;
			} else if ((frame->dsr & CMMU_DSR_CP)
				   || (frame->dsr & CMMU_DSR_WA)) {
				result = 0;
			} else if (frame->dsr & CMMU_DSR_WE) {	/* write fault  */
			/* This could be a write protection fault or an 
			 * exception to set the used and modified bits
			 * in the pte.  Basicly, if we got a write error, 
			 * then we already have a pte entry that faulted 
			 * in from a previous seg fault or page fault.
			 * Get the pte and check the status of the 
			 * modified and valid bits to determine if this 
			 * indeed a real write fault.  XXX smurph
			 */
				pte = pmap_pte(vm_map_pmap(map), va);
				if (pte == PT_ENTRY_NULL)
					panic("NULL pte on write fault??");
				if (!(*pte & PG_M) && !(*pte & PG_PROT)) {
					/* Set modified bit and try the write again. */
					*pte |= PG_M;
					/* invalidate ATCs to force table search */
					set_dcmd(CMMU_DCMD_INV_UATC);
a1022 4
				} else {
					/* This must be a real write protection fault */
					printf("Write protect???? mod = %d, wp = %d\n", !!(*pte & PG_M), !!(*pte & PG_PROT));
					result = uvm_fault(map, va, 0, ftype);
d1029 3
a1031 5
				v_fault++;
			} else if ((frame->isr & CMMU_ISR_BE)
				   || (frame->isr & CMMU_ISR_SP)
				   || (frame->isr & CMMU_ISR_TBE)) { /* bus error */
				result = EACCES;
a1044 5
#ifdef smurph_debug
			printf("Access failed! result = %d\n\n", result);
			frame->mode = v_fault;
			regdump(frame);
			Debugger();
d1046 4
a1049 2
			fault_type = result == EACCES ? BUS_ADRERR : SEGV_MAPERR;
#endif		
d1138 3
d1152 2
a1180 1
		frame->isr = 0;
a1195 26
error_fatal(struct m88100_saved_state *frame)
{
	switch (frame->vector) {
	case 0:
		DEBUG_MSG("\n[RESET EXCEPTION (Really Bad News[tm]) frame 0x%08x]\n", frame);
		DEBUG_MSG("This is usually caused by a branch to a NULL function pointer.\n");
		DEBUG_MSG("e.g. jump to address 0.  Use the debugger trace command to track it down.\n");
		break;
	default:
		DEBUG_MSG("\n[ERROR EXCEPTION (Bad News[tm]) frame 0x%08x]\n", frame);
		DEBUG_MSG("This is usually an exception within an exception.  The trap\n");
		DEBUG_MSG("frame shadow registers you are about to see are invalid.\n");
		DEBUG_MSG("(read totaly useless)  But R1 to R31 might be interesting.\n");
		break;
	}
	regdump((struct trapframe*)frame);
#if DDB 
	Debugger();
	DEBUG_MSG("You really can't restart after exception %d!\n", frame->vector);
	Debugger();
#endif /* DDB */
	bugreturn();  /* This gets us to Bug instead of a loop forever */

}

void
d1203 1
a1203 1
#ifdef M88100
a1228 1
#ifdef M88100
d1230 1
a1230 1
m88100_syscall(register_t code, struct m88100_saved_state *tf)
d1286 1
d1316 3
a1318 3
	 *       tb0 0, r0, <128> <- sxip
	 *	 br err 	  <- snip
	 *       jmp r1 	  <- sfip
d1355 1
a1355 1
		tf->snip = tf->sfip & ~NIP_E;
d1369 1
a1369 1
		tf->sfip = tf->snip & ~FIP_E;
a1383 3
#endif /* M88100 */

#ifdef M88110
d1385 1
d1388 1
a1388 1
m88110_syscall(register_t code, struct m88100_saved_state *tf)
d1444 1
a1444 1
	printf("syscall code is %d\n", code);
d1474 2
a1475 2
	 *       tb0 0, r0, <128> <- exip
	 *	 br err 	  <- enip
d1482 1
a1482 1
	 * So, when we take syscall trap, exip/enip will be as
d1486 1
a1486 1
	 *	   exip += 8
d1488 1
a1488 1
	 *    exip += 4 and plug the value in r2. This will have us
d1491 1
a1491 1
	 *    we need to rexecute the trap instruction. leave exip as is.
d1493 1
a1493 1
	 *    exip += 4
d1496 1
a1496 3
	switch (error) {
	case 0:
		printf("syscall success!\n");
d1509 9
a1517 5
		tf->exip += 8; 
		tf->exip &= ~3;
		break;
	case ERESTART:
		printf("syscall restart!\n");
d1519 2
a1520 3
		 * Reexecute the trap.
		 * exip is already at the trap instruction, so
		 * there is nothing to do.
d1523 1
a1523 3
		break;
	case EJUSTRETURN:
		printf("syscall just return!\n");
d1526 2
a1527 13
		tf->exip += 4;
		tf->exip &= ~3;
		break;
	default:
		printf("syscall error %d!\n", error);
		/* error != ERESTART && error != EJUSTRETURN*/
		if (p->p_emul->e_errno)
			error = p->p_emul->e_errno[error];
		tf->r[2] = error;
		tf->epsr |= PSR_C;   /* fail */
		tf->exip += 4;
		tf->exip &= ~3;
		break;
a1528 1

d1555 7
a1561 1
	if (cputyp != CPU_88110) {
a1563 3
	} else {
		tf->exip += 8;
		tf->exip &= ~3;
@


1.29.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.29.2.1 2002/01/31 22:55:19 niklas Exp $	*/
a55 3
#include "systrace.h"
#include <dev/systrace.h>

d105 1
a105 1
extern int procfs_domem(struct proc *, struct proc *, void *, struct uio *);
d107 4
a110 4
extern void regdump(struct trapframe *f);
void error_fatal(struct m88100_saved_state *frame);
void error_fault(struct m88100_saved_state *frame);
void error_reset(struct m88100_saved_state *frame);
d162 2
a163 6
	if (p->p_flag & P_PROFIL) {
		extern int psratio;

		addupc_task(p, frame->sxip & ~3,
		    (int)(p->p_sticks - oticks) * psratio);
	}
d714 1
a714 1
	extern pt_entry_t *pmap_pte(pmap_t, vm_offset_t);
d1316 1
a1316 6
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE))
		error = systrace_redirect(code, p, &args, rval);
	else
#endif
		error = (*callp->sy_call)(p, &args, rval);
@


1.29.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d254 1
a254 1
			int s = splhigh();
d258 1
a258 1
			splx(s);
d265 1
a265 1
			int s = splhigh();
d269 1
a269 1
			splx(s);
d276 1
a276 1
			int s = splhigh();
d281 1
a281 1
			splx(s);
d340 13
d455 1
d594 1
a594 1
			copyin((caddr_t)pc, &instr, sizeof(unsigned));
d763 2
a764 1
		s = splhigh();
d768 1
a768 1
		splx(s);
d773 7
a779 6
		s = splhigh();
		db_enable_interrupt();
		ddb_break_trap(T_KDB_BREAK,(db_regs_t*)frame);
		db_disable_interrupt();
		splx(s);
		return;
d783 5
a787 4
		s = splhigh();
		db_enable_interrupt();
		ddb_entry_trap(T_KDB_ENTRY,(db_regs_t*)frame);
		db_disable_interrupt();
d793 2
a794 2
		splx(s);
		return;
d797 9
a805 7
		s = splhigh();
		db_enable_interrupt();
		ddb_error_trap(type == T_ILLFLT ? "unimplemented opcode" :
		       "error fault", (db_regs_t*)frame);
		db_disable_interrupt();
		splx(s);
		return;
d870 13
d944 1
d1098 1
a1098 1
			copyin((caddr_t)pc, &instr, sizeof(unsigned));
a1834 19

#ifdef DIAGNOSTIC
void
splassert_check(int wantipl, const char *func)
{
	int oldipl;

	oldipl = getipl();

	if (oldipl < wantipl) {
		splassert_fail(wantipl, oldipl, func);
		/*
		 * If the splassert_ctl is set to not panic, raise the ipl
		 * in a feeble attempt to reduce damage.
		 */
		setipl(wantipl);
	}
}
#endif
@


1.28
log
@Support for MVME197 completed.  Fix SPL defs.
@
text
@d60 1
a60 2
#include <machine/cpu.h>
#include <machine/asm_macro.h>   /* enable/disable interrupts */
d62 3
a64 5
#ifdef M88100
#include <machine/m88100.h>
#endif 
#ifdef M88110
#include <machine/m88110.h>
d74 4
a77 6
   #define PC_REGS(regs) cputyp == CPU_88110 ? (regs->exip & ~3) :\
           ((regs->sxip & 2) ?  regs->sxip & ~3 : \
           (regs->snip & 2 ? regs->snip & ~3 : regs->sfip & ~3))

   #define inst_return(I) (((I)&0xfffffbffU) == 0xf400c001U ? TRUE : FALSE)
   #define inst_call(I) ({ unsigned i = (I); \
a103 3
void error_fatal __P((struct m88100_saved_state *frame));
void error_fault __P((struct m88100_saved_state *frame));
void error_reset __P((struct m88100_saved_state *frame));
d165 10
a174 12
		if (cputyp != CPU_88110) {
			if (type == 2) {  /* instruction exception */
				DEBUG_MSG("\nInstr access fault (%s) v = %x, frame %x\n",
					  pbus_exception_type[(frame->ipfsr >> 16) & 0x7],
					  frame->sxip & ~3, frame);
			} else if (type == 3) {	/* data access exception */
				DEBUG_MSG("\nData access fault (%s) v = %x, frame %x\n",
					  pbus_exception_type[(frame->dpfsr >> 16) & 0x7],
					  frame->sxip & ~3, frame);
			} else
				DEBUG_MSG("\ntrap type %d, v = %x, frame %x\n", type, frame->sxip & ~3, frame);
		}
d183 1
a183 1
#ifdef M88100
d189 1
a189 1
m88100_trap(unsigned type, struct m88100_saved_state *frame)
d201 1
a201 1
	int result = 0;  
d273 2
a274 2
		   on the value of brdtyp - smurph */
		(*md.interrupt_func)(T_INT, frame);
d354 1
a354 1
			frame->snip = ((unsigned)&guarded_access_bad    ) | NIP_V;
d458 1
a458 1
user_fault:
d677 1
a677 2
#endif /* m88100 */
unsigned v_fault = 0;
d679 1
a679 1
#ifdef M88110
d682 1
a682 1
m88110_trap(unsigned type, struct m88100_saved_state *frame)
d694 1
a694 2
        int s; /* IPL */
	int result = 0;  /* Assume Success */
d696 3
a698 3
	unsigned pc = PC_REGS(frame);  /* get program counter (exip) */
	unsigned user = 0, data = 0;
	pt_entry_t *pte;
a701 1
	extern pt_entry_t *pmap_pte __P((pmap_t, vm_offset_t));
d707 1
a707 6
#if 0
	if (type != T_INT) {
		printf("m88110_trap 0x%x ", type);
	}
#endif
	
a713 1
		user = 1;
d715 1
a715 1
	
d721 1
d723 33
a755 3
		DEBUG_MSG("DMMU read miss: Hardware Table Searches should be enabled!\n");
		panictrap(frame->vector, frame);
		/*NOTREACHED*/
d757 1
d759 36
a794 3
		DEBUG_MSG("DMMU write miss: Hardware Table Searches should be enabled!\n");
		panictrap(frame->vector, frame);
		/*NOTREACHED*/
d796 1
d798 34
a831 12
		DEBUG_MSG("IMMU miss: Hardware Table Searches should be enabled!\n");
		panictrap(frame->vector, frame);
		/*NOTREACHED*/
#if defined(DDB)
	case T_KDB_TRACE:
		frame->mask = spl(); /* get current spl for reg dump */
		s = db_splhigh();
		db_enable_interrupt();
		ddb_break_trap(T_KDB_TRACE,(db_regs_t*)frame);
		db_disable_interrupt();
		db_splx(s);
		return;
d835 8
a842 7
		frame->mask = spl(); /* get current spl for reg dump */
		s = db_splhigh();
		db_enable_interrupt();
		ddb_break_trap(T_KDB_BREAK,(db_regs_t*)frame);
		db_disable_interrupt();
		db_splx(s);
		return;
d846 7
a852 9
		frame->mask = spl(); /* get current spl for reg dump */
		s = db_splhigh();
		db_enable_interrupt();
		ddb_entry_trap(T_KDB_ENTRY,(db_regs_t*)frame);
		db_disable_interrupt();
		if (frame->enip) {
			frame->exip = frame->enip;
		} else {
                               frame->exip += 4;
d854 1
a854 2
		db_splx(s);
		return;
d869 2
a870 1
		DEBUG_MSG("Unimplemented opcode!\n");
d873 1
a873 10
	case T_NON_MASK:
	case T_NON_MASK+T_USER:
		/* This function pointer is set in machdep.c 
		   It calls m197_ext_int - smurph */
		(*md.interrupt_func)(T_NON_MASK, frame);
		return;
	case T_INT:
	case T_INT+T_USER:
		(*md.interrupt_func)(T_INT, frame);
		return;
d876 1
a876 1
			  "access exception @@ 0x%08x\n", frame->exip);
d878 1
a878 1
		/*NOTREACHED*/
d881 1
d886 1
a886 1
			  "page fault @@ 0x%08x\n", frame->exip);
d888 1
a888 1
		/*NOTREACHED*/
d896 1
d905 1
d909 1
a909 1
			fault_addr = frame->exip & XIP_ADDR;
d913 1
a913 1
		
d917 1
a917 1
		
d936 1
a936 1
			goto m88110_outtahere;
d941 1
a941 1
			goto m88110_user_fault;
d945 1
a945 1
		 * If it is a guarded access, bus error is OK.
d949 2
a950 2
		    (frame->exip & ~3) >= (unsigned)&guarded_access_start &&
		    (frame->exip & ~3) <= (unsigned)&guarded_access_end) {
d953 1
d955 2
a956 2
		 * On a segment or a page fault, call vm_fault() to resolve
		 * the fault.
d958 6
a971 19
			if (frame->dsr & CMMU_DSR_WE) { /* write fault  */
			/* This could be a write protection fault or an 
			 * exception to set the used and modified bits
			 * in the pte.  Basicly, if we got a write error, 
			 * then we already have a pte entry that faulted 
			 * in from a previous seg fault or page fault.
			 * Get the pte and check the status of the 
			 * modified and valid bits to determine if this 
			 * indeed a real write fault.  XXX smurph
			 */
				pte = pmap_pte(map->pmap, va);
				if (pte == PT_ENTRY_NULL)
					panic("NULL pte on write fault??");
				if (!pte->modified && !pte->prot) {
					/* Set modified bit and try the write again. */
					pte->modified = 1; 
					return;
				}
			}
d987 2
a988 2
m88110_outtahere:
		frame->exip = ((unsigned)p->p_addr->u_pcb.pcb_onfault);
d994 1
a994 1
m88110_user_fault:
d996 1
a996 1
			fault_addr = frame->exip & XIP_ADDR;
d1015 1
d1018 2
a1019 3

			if (frame->dsr & (CMMU_DSR_SI |   /* seg fault  */
					  CMMU_DSR_PI)) { /* page fault */
d1021 1
a1021 22
				v_fault++;
			} else if (frame->dsr & CMMU_DSR_BE) {	/* bus error */
				result = EFAULT;
			} else if ((frame->dsr & CMMU_DSR_CP)
				   || (frame->dsr & CMMU_DSR_WA)) {
				result = 0;
			} else if (frame->dsr & CMMU_DSR_WE) {	/* write fault  */
			/* This could be a write protection fault or an 
			 * exception to set the used and modified bits
			 * in the pte.  Basicly, if we got a write error, 
			 * then we already have a pte entry that faulted 
			 * in from a previous seg fault or page fault.
			 * Get the pte and check the status of the 
			 * modified and valid bits to determine if this 
			 * indeed a real write fault.  XXX smurph
			 */
				pte = pmap_pte(map->pmap, va);
				if (pte == PT_ENTRY_NULL)
					panic("NULL pte on write fault??");
				if (!pte->modified && !pte->prot) {
					/* Set modified bit and try the write again. */
					pte->modified = 1; 
a1022 3
				} else {
					/* This must be a real write protection fault */
					result = uvm_fault(map, va, 0, ftype);
d1026 1
a1026 1
			if ((frame->isr & CMMU_ISR_SI)	     /* seg fault  */
d1029 3
a1031 5
				v_fault++;
			} else if ((frame->isr & CMMU_ISR_BE)
				   || (frame->isr & CMMU_ISR_SP)
				   || (frame->isr & CMMU_ISR_TBE)) { /* bus error */
				result = EACCES;
d1034 1
a1034 1
		
a1044 6
#ifdef DEBUG
			printf("Access failed! result = %d\n");
			frame->mode = v_fault;
			regdump(frame);
			Debugger();
#endif 
d1046 4
a1049 1
			fault_type = result == EACCES ? BUS_ADRERR : SEGV_MAPERR;
d1138 3
d1152 2
a1180 1
		frame->isr = 0;
a1195 26
error_fatal(struct m88100_saved_state *frame)
{
	switch (frame->vector) {
	case 0:
		DEBUG_MSG("\n[RESET EXCEPTION (Really Bad News[tm]) frame 0x%08x]\n", frame);
		DEBUG_MSG("This is usually caused by a branch to a NULL function pointer.\n");
		DEBUG_MSG("e.g. jump to address 0.  Use the debugger trace command to track it down.\n");
		break;
	default:
		DEBUG_MSG("\n[ERROR EXCEPTION (Bad News[tm]) frame 0x%08x]\n", frame);
		DEBUG_MSG("This is usually an exception within an exception.  The trap\n");
		DEBUG_MSG("frame shadow registers you are about to see are invalid.\n");
		DEBUG_MSG("(read totaly useless)  But R1 to R31 might be interesting.\n");
		break;
	}
	regdump((struct trapframe*)frame);
#if DDB 
	Debugger();
	DEBUG_MSG("You really can't restart after exception %d!\n", frame->vector);
	Debugger();
#endif /* DDB */
	bugreturn();  /* This gets us to Bug instead of a loop forever */

}

void
d1203 1
a1203 1
#ifdef M88100
a1228 1
#ifdef M88100
d1230 1
a1230 1
m88100_syscall(register_t code, struct m88100_saved_state *tf)
d1316 3
a1318 3
	 *       tb0 0, r0, <128> <- sxip
	 *	 br err 	  <- snip
	 *       jmp r1 	  <- sfip
d1355 1
a1355 1
		tf->snip = tf->sfip & ~NIP_E;
d1369 1
a1369 1
		tf->sfip = tf->snip & ~FIP_E;
a1383 1
#endif /* M88100 */
d1385 1
a1385 1
#ifdef M88110
d1388 1
a1388 1
m88110_syscall(register_t code, struct m88100_saved_state *tf)
d1474 3
a1476 3
	 *       tb0 0, r0, <128> <- exip
	 *	 br err 	  <- enip
	 *       jmp r1           
d1482 1
a1482 1
	 * So, when we take syscall trap, exip/enip will be as
d1486 1
a1486 1
	 *	   exip += 8
d1488 1
a1488 1
	 *    exip += 4 and plug the value in r2. This will have us
d1491 1
a1491 1
	 *    we need to rexecute the trap instruction. leave exip as is.
d1493 1
a1493 1
	 *    exip += 4
a1496 1
		printf("syscall success!\n");
d1509 2
a1510 2
		tf->exip += 8; 
		tf->exip &= ~3;
a1511 1
		printf("syscall error %d!\n", error);
d1515 2
a1516 2
		tf->exip += 4;
		tf->exip &= ~3;
a1517 1
		printf("syscall restart!\n");
d1519 2
a1520 1
		 * If (error == ERESTART), reexecute the trap.
d1522 1
a1522 1
                tf->epsr &= ~PSR_C;
a1523 1
		printf("syscall just return!\n");
d1526 2
a1527 2
		tf->exip += 4;
		tf->exip &= ~3;
d1555 7
a1561 1
	if (cputyp != CPU_88110) {
a1563 3
	} else {
		tf->exip += 8;
		tf->exip &= ~3;
@


1.27
log
@zap some typedefs.
vm_map_t -> struct vm_map *
vm_map_entry_t -> struct vm_map_entry *
simple_lock_data_t -> struct simplelock

(uvm not done yet, coming in the next commit)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.26 2001/11/28 13:47:39 art Exp $	*/
d60 2
a61 1
#include <machine/cpu.h>		/* DMT_VALID, etc. */
d63 5
a67 3
#include <machine/m88100.h>		/* DMT_VALID, etc. */
#ifdef MVME197
#include <machine/m88110.h>		/* DMT_VALID, etc. */
d77 6
a82 4
#define PC_REGS(regs) ((regs->sxip & 2) ?  regs->sxip & ~3 : \
	(regs->snip & 2 ? regs->snip & ~3 : regs->sfip & ~3))
#define inst_return(I) (((I)&0xfffffbffU) == 0xf400c001U ? TRUE : FALSE)
#define inst_call(I) ({ unsigned i = (I); \
d109 3
d173 12
a184 10
		if (type == 2) {  /* instruction exception */
			DEBUG_MSG("\nInstr access fault (%s) v = %x, frame %x\n",
				  pbus_exception_type[(frame->ipfsr >> 16) & 0x7],
				  frame->sxip & ~3, frame);
		} else if (type == 3) {	/* data access exception */
			DEBUG_MSG("\nData access fault (%s) v = %x, frame %x\n",
				  pbus_exception_type[(frame->dpfsr >> 16) & 0x7],
				  frame->sxip & ~3, frame);
		} else
			DEBUG_MSG("\ntrap type %d, v = %x, frame %x\n", type, frame->sxip & ~3, frame);
d193 1
a193 1
#if defined(MVME187) || defined(MVME188)
d199 1
a199 1
trap18x(unsigned type, struct m88100_saved_state *frame)
d211 1
a211 1
	int result;
d283 2
a284 2
		   on the value of cputyp - smurph */
		(*mdfp.interrupt_func)(T_INT, frame);
d364 1
a364 1
			frame->snip = ((unsigned)&guarded_access_bad    ) | FIP_V;
d468 1
a468 1
		user_fault:
d687 2
a688 1
#endif /* defined(MVME187) || defined(MVME188) */
d690 1
a690 1
#ifdef MVME197
d693 1
a693 1
trap197(unsigned type, struct m88100_saved_state *frame)
d705 2
a706 1
	int result;
d708 3
a710 3
	unsigned pc = PC_REGS(frame);  /* get program counter (sxip) */
	unsigned user = 0, write = 0, data = 0;

d714 1
d720 6
a725 1

d732 1
d734 1
a734 1
	printf("m197_trap 0x%x ", type);
a739 1
		user = 1;
d741 3
a743 33
		va = (vm_offset_t) frame->dlar;
		/* if it was a user read, handle in context of the user */
		if ((frame->dsr & CMMU_DSR_SU) && !user) {
			map = kernel_map;
		} else {
			vm = p->p_vmspace;
			map = &vm->vm_map;
		}
		result = m197_table_search(map->pmap, va, CMMU_READ, user, CMMU_DATA);
		if (result) {
			switch (result) {
			case 4:	/* Seg Fault */
				frame->dsr |= CMMU_DSR_SI | CMMU_DSR_RW;
				break;
			case 5:	/* Page Fault */
				frame->dsr |= CMMU_DSR_PI | CMMU_DSR_RW;
				break;
			case 6:	/* Supervisor Violation */
				frame->dsr |= CMMU_DSR_SP | CMMU_DSR_RW;
				break;
			}
			/* table search failed and we are going to report a data fault */
			if (user) {
				type = T_DATAFLT+T_USER;
				goto m197_user_fault;
			} else {
				type = T_DATAFLT;
				goto m197_data_fault;
			}
		} else {
			return;	/* PATC sucessfully loaded */
		}
		break;      
a744 1
		user = 1;
d746 3
a748 36
		/* if it was a user read, handle in context of the user */
		if ((frame->dsr & CMMU_DSR_SU) && !user) {
			map = kernel_map;
		} else {
			vm = p->p_vmspace;
			map = &vm->vm_map;
		}
		va = (vm_offset_t) frame->dlar;
		result = m197_table_search(map->pmap, va, CMMU_WRITE, user, CMMU_DATA);
		if (result) {
			switch (result) {
			case 4:	/* Seg Fault */
				frame->dsr |= CMMU_DSR_SI;
				break;
			case 5:	/* Page Fault */
				frame->dsr |= CMMU_DSR_PI;
				break;
			case 6:	/* Supervisor Violation */
				frame->dsr |= CMMU_DSR_SP;
				break;
			case 7:	/* Write Violation */
				frame->dsr |= CMMU_DSR_WE;
				break;
			}
			/* table search failed and we are going to report a data fault */
			if (user) {
				type = T_DATAFLT+T_USER;
				goto m197_user_fault;
			} else {
				type = T_DATAFLT;
				goto m197_data_fault;
			}
		} else {
			return;	/* PATC sucessfully loaded */
		}
		break;      
a749 1
		user = 1;
d751 12
a762 34
		/* if it was a user read, handle in context of the user */
		if ((frame->isr & CMMU_ISR_SU) && !user) {
			map = kernel_map;
		} else {
			vm = p->p_vmspace;
			map = &vm->vm_map;
		}
		va = (vm_offset_t) frame->sxip;
		result = m197_table_search(map->pmap, va, CMMU_READ, user, CMMU_INST);
		if (result) {
			switch (result) {
			case 4:	/* Seg Fault */
				frame->isr |= CMMU_ISR_SI;
				break;
			case 5:	/* Page Fault */
				frame->isr |= CMMU_ISR_PI;
				break;
			case 6:	/* Supervisor Violation */
				frame->isr |= CMMU_ISR_SP;
				break;
			}
			/* table search failed and we are going to report a data fault */
			if (user) {
				type = T_INSTFLT+T_USER;
				goto m197_user_fault;
			} else {
				type = T_INSTFLT;
				goto m197_inst_fault;
			}
		} else {
			return;	/* PATC sucessfully loaded */
		}
		break;      
   #if defined(DDB)
d766 7
a772 8
		{
			int s = db_splhigh();
			db_enable_interrupt();
			ddb_break_trap(T_KDB_BREAK,(db_regs_t*)frame);
			db_disable_interrupt();
			db_splx(s);
			return;
		}
d776 9
a784 7
		{
			int s = db_splhigh();
			db_enable_interrupt();
			ddb_entry_trap(T_KDB_ENTRY,(db_regs_t*)frame);
			db_disable_interrupt();
			db_splx(s);
			return;
d786 2
a787 1

d802 1
a802 2
		DEBUG_MSG("test trap "
			  "page fault @@ 0x%08x\n", frame->sxip);
d805 10
a814 1

d817 1
a817 1
			  "access exception @@ 0x%08x\n", frame->sxip);
d819 1
a819 1
		break;
a821 1
		m197_inst_fault:
d826 1
a826 1
			  "page fault @@ 0x%08x\n", frame->sxip);
d828 1
a828 1
		break;
a835 1
		m197_data_fault:
a843 1
				write = 1;
d847 1
a847 1
			fault_addr = frame->sxip & XIP_ADDR;
d851 1
a851 1

d855 1
a855 1

d874 1
a874 1
			goto m197_outtahere;
d879 1
a879 1
			goto m197_user_fault;
d883 1
a883 1
		 *	If it is a guarded access, bus error is OK.
d887 2
a888 2
		    (frame->sxip & ~3) >= (unsigned)&guarded_access_start &&
		    (frame->sxip & ~3) <= (unsigned)&guarded_access_end) {
a890 1

d892 2
a893 2
		 *	On a segment or a page fault, call vm_fault() to resolve
		 *	the fault.
a894 6
		result = m197_table_search(map->pmap, va, write, 1, data);
#ifdef todo         
		switch (result) {
		case :
		}
#endif
d903 19
d937 2
a938 2
		m197_outtahere:
		frame->sxip = ((unsigned)p->p_addr->u_pcb.pcb_onfault);
d944 1
a944 1
		m197_user_fault:
d946 1
a946 1
			fault_addr = frame->sxip & XIP_ADDR;
a964 1

d967 3
a969 2
			if ((frame->dsr & CMMU_DSR_SI)	      /* seg fault  */
			    || (frame->dsr & CMMU_DSR_PI)) { /* page fault */
d971 22
a992 1
				if (result == 0) {
d994 3
d1000 1
a1000 1
			if ((frame->isr & CMMU_ISR_SI)	      /* seg fault  */
d1003 5
a1007 3
				if (result == 0) {
					return;
				}
d1010 1
a1010 1

d1021 6
d1028 1
a1028 4
			fault_type = result == EACCES ? BUS_ADRERR
				     : SEGV_MAPERR;
		} else {
			return;
a1116 3
			frame->sfip = frame->snip;    /* set up next FIP */
			frame->snip = frame->sxip;    /* set up next NIP */
			frame->snip |= 2;	  /* set valid bit   */
a1127 2
		frame->sfip = frame->snip;    /* set up the next FIP */
		frame->snip = frame->sxip;    /* set up the next NIP */
d1155 1
d1171 26
d1204 1
a1204 1
#if defined(MVME187) || defined(MVME188)
d1230 1
d1232 1
a1232 1
syscall(register_t code, struct m88100_saved_state *tf)
d1318 3
a1320 3
	 *       tb0 0, r0, <128> <- xip
	 *	 br err 	  <- nip
	 *       jmp r1 	  <- fip
d1357 1
a1357 1
		tf->snip = tf->sfip & ~FIP_E;
d1371 1
a1371 1
		tf->sfip = tf->snip & ~NIP_E;
d1386 1
d1388 1
a1388 1
#ifdef MVME197
d1391 1
a1391 1
m197_syscall(register_t code, struct m88100_saved_state *tf)
d1477 3
a1479 3
	 *       tb0 0, r0, <128> <- sxip
	 *	 br err 	  <- snip
	 *       jmp r1
d1485 1
a1485 1
	 * So, when we take syscall trap, sxip/snip will be as
d1489 1
a1489 1
	 *	   sxip += 8
d1491 1
a1491 1
	 *    sxip += 4 and plug the value in r2. This will have us
d1494 1
a1494 1
	 *    we need to rexecute the trap instruction. leave xip as is.
d1496 1
a1496 1
	 *    sxip += 8
d1500 1
d1513 2
a1514 2
		tf->sxip += 8;
		tf->sxip &= ~3;
d1516 1
d1520 2
a1521 2
		tf->sxip += 4;
		tf->sxip &= ~3;
d1523 1
d1525 1
a1525 2
		 * If (error == ERESTART), back up the pipe line. This
		 * will end up reexecuting the trap.
d1527 1
a1527 1
		tf->epsr &= ~PSR_C;
d1529 1
d1532 2
a1533 2
		tf->sxip += 8; 
		tf->sxip &= ~3;
d1561 1
a1561 7
#ifdef MVME197
	if (cputyp == CPU_197) {
		tf->sxip += 8;
		tf->sxip &= ~3;
	} else
#endif
	{
d1564 3
@


1.26
log
@Sync in more uvm changes from NetBSD.
This time we're getting rid of KERN_* and VM_PAGER_* error codes and
use errnos instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.25 2001/11/07 22:32:29 miod Exp $	*/
d193 1
a193 1
	vm_map_t map;
d205 1
a205 1
	extern vm_map_t kernel_map;
d686 1
a686 1
	vm_map_t map;
d699 1
a699 1
	extern vm_map_t kernel_map;
@


1.25
log
@Let those compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.24 2001/11/06 19:53:15 miod Exp $	*/
d407 1
a407 1
			if (result == KERN_SUCCESS) {
d497 1
a497 1
			if (result == KERN_SUCCESS) {
d501 2
a502 2
			} else if (result == KERN_PROTECTION_FAILURE)
				result = KERN_INVALID_ADDRESS;
d505 1
a505 1
		if (result == KERN_SUCCESS) {
d522 1
a522 1
			sig = result == KERN_PROTECTION_FAILURE ? 
d524 1
a524 1
			fault_type = result == KERN_PROTECTION_FAILURE ? 
d968 1
a968 1
				if (result == KERN_SUCCESS) {
d976 1
a976 1
				if (result == KERN_SUCCESS) {
d1021 1
a1021 1
				if (result == KERN_SUCCESS) {
d1029 1
a1029 1
				if (result == KERN_SUCCESS) {
d1036 1
a1036 1
			if (result == KERN_SUCCESS) {
d1040 2
a1041 2
			} else if (result == KERN_PROTECTION_FAILURE)
				result = KERN_INVALID_ADDRESS;
d1044 3
a1046 3
		if (result != KERN_SUCCESS) {
			sig = result == KERN_PROTECTION_FAILURE ? SIGBUS : SIGSEGV;
			fault_type = result == KERN_PROTECTION_FAILURE ? BUS_ADRERR
@


1.24
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.23 2001/09/19 20:50:57 mickey Exp $	*/
d1545 2
a1546 1
child_return(struct proc *p)
d1548 1
d1555 7
a1561 1
	if (cputyp != CPU_197) {
a1563 3
	} else {
		tf->sxip += 8;
		tf->sxip &= ~3;
@


1.23
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.22 2001/09/14 14:58:44 art Exp $	*/
a54 2

#include <vm/vm.h>
@


1.22
log
@simplify userret
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.21 2001/08/31 01:52:22 miod Exp $	*/
a56 1
#include <vm/vm_kern.h>			/* kernel_map */
@


1.21
log
@Assorted changes to really let non-DDB kernels (such as the future RAMDISK,
hint, hint) compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.20 2001/08/31 01:06:29 miod Exp $	*/
a138 1
	int s;
d147 1
a147 6
		 * Since we are curproc, clock will normally just change
		 * our priority without moving us from one queue to another
		 * (since the running process is not on a queue.)
		 * If that happened after we put ourselves on the run queue
		 * but before we switched, we might not be on the queue
		 * indicated by our priority.
d149 1
a149 5
		s = splstatclock();
		setrunqueue(p);
		p->p_stats->p_ru.ru_nivcsw++;
		mi_switch();
		(void) splx(s);
@


1.20
log
@There's no point having a Debugger() clone here.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.19 2001/08/26 14:31:12 miod Exp $	*/
d413 1
d415 1
d498 1
d500 1
@


1.19
log
@Add prototypes, fix compilation warnings, random style fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.18 2001/08/24 22:52:22 miod Exp $	*/
d1217 1
a1217 1
	gimmeabreak();
d1219 1
a1219 1
	gimmeabreak();
d1231 1
a1231 1
	gimmeabreak();
d1233 1
a1233 1
	gimmeabreak();
@


1.18
log
@Rename the trap() symbols with more insightful names. This forces us
to check all trap() invocations in the sources and fix them, thus
improving the chances of 197-kernels to live.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.17 2001/06/27 04:29:21 art Exp $	*/
d104 1
a104 1
extern int procfs_domem __P((struct proc *, struct proc *, struct pfsnode *pfsp, struct uio *uio));
@


1.17
log
@rip old vm
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.16 2001/05/05 20:56:47 art Exp $	*/
a48 3
#include <vm/vm.h>
#include <vm/vm_kern.h>			/* kernel_map */
#include <uvm/uvm_extern.h>
d53 1
d55 7
d64 1
a64 1
#include <machine/asm_macro.h>   /* enable/disable interrupts */
d69 2
a70 1
#include <machine/locore.h>
a71 4
#include <machine/psl.h>		/* FIP_E, etc. */
#include <machine/pcb.h>		/* FIP_E, etc. */

#include <sys/systm.h>
d73 3
a75 3
#if (DDB)
   #include <machine/db_machdep.h>
   #include <ddb/db_output.h>		/* db_printf()		*/
d77 1
a77 1
   #define PC_REGS(regs) ((regs->sxip & 2) ?  regs->sxip & ~3 : \
d79 2
a80 2
   #define inst_return(I) (((I)&0xfffffbffU) == 0xf400c001U ? TRUE : FALSE)
   #define inst_call(I) ({ unsigned i = (I); \
a84 1

d89 1
d95 1
a95 1
   #define DEBUG_MSG db_printf
d97 1
a97 1
   #define DEBUG_MSG printf
d103 2
a104 1
/* XXX MAJOR CLEANUP REQUIRED TO PORT TO BSD */
a105 1
extern int procfs_domem();
d202 1
a202 1
trap(unsigned type, struct m88100_saved_state *frame)
a218 1
	extern int fubail(), subail();
d687 2
a689 1
#ifdef MVME197
d691 1
a691 1
trap2(unsigned type, struct m88100_saved_state *frame)
a702 1
	int su = 0;
d706 1
a706 1
	unsigned dsr, isr, user = 0, write = 0, data = 0;
a708 1
	extern int fubail(), subail();
a710 1
	extern unsigned guarded_access_bad;
a1193 6
void
test_trap2(int num, int m197)
{
	DEBUG_MSG("\n[test_trap (Good News[tm]) m197 = %d, vec = %d]\n", m197, num);
	bugreturn();
}
d1807 1
@


1.16
log
@Get rid of CLSIZE and all related stuff.
CLSIZE -> 1
CLBYTES -> PAGE_SIZE
OLOFSET -> PAGE_MASK
etc.
At the same time some archs needed some cleaning in vmparam.h so that
goes in at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.15 2001/03/12 23:00:40 miod Exp $	*/
a50 1
#if defined(UVM)
a51 1
#endif
a227 1
#if defined(UVM)
a228 3
#else
	cnt.v_trap++;
#endif
a415 1
#if defined(UVM)
a416 3
#else
			result = vm_fault(map, va, ftype, FALSE); 
#endif
a499 1
#if defined(UVM)
a500 3
#else
			result = vm_fault(map, va, ftype, FALSE); 
#endif
a656 1
#if defined(UVM)
a657 3
#else
		cnt.v_soft++;
#endif
a712 1
#if defined(UVM)
a713 3
#else
	cnt.v_trap++;
#endif
a976 1
#if defined(UVM)
a977 3
#else
				result = vm_fault(map, va, ftype, FALSE); 
#endif
a984 1
#if defined(UVM)
a985 3
#else
				result = vm_fault(map, va, ftype, FALSE); 
#endif
a1029 1
#if defined(UVM)
a1030 3
#else
				result = vm_fault(map, va, ftype, FALSE); 
#endif
a1037 1
#if defined(UVM)
a1038 3
#else
				result = vm_fault(map, va, ftype, FALSE); 
#endif
a1168 1
#if defined(UVM)
a1169 3
#else
		cnt.v_soft++;
#endif
a1258 1
#if defined(UVM)
a1259 3
#else
	cnt.v_syscall++;
#endif
a1416 1
#if defined(UVM)
a1417 3
#else
	cnt.v_syscall++;
#endif
@


1.15
log
@Remove dead code related to soft interrupts.
While there, fix a typo in a panic message.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.14 2001/03/09 05:44:42 smurph Exp $	*/
d520 1
a520 1
				nss = clrnd(btoc(USRSTACK - va));/* XXX check this */
d1085 1
a1085 1
				nss = clrnd(btoc(USRSTACK - va));/* XXX check this */
@


1.14
log
@kernel will compile with -Werror.  Added intr.h
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.13 2001/03/08 00:03:31 miod Exp $	*/
a132 5
#define NSIR	8
void (*sir_routines[NSIR])();
void *sir_args[NSIR];
u_char next_sir;

d296 1
a296 1
		DEBUG_MSG("kernel misalgined "
d907 1
a907 1
		DEBUG_MSG("kernel misalgined "
a1235 1
#endif /* MVME197 */
d1243 1
d1447 1
d1604 1
a1631 28
}

/*
 * Allocation routines for software interrupts.
 */
u_long
allocate_sir(proc, arg)
	void (*proc)();
	void *arg;
{
	int bit;

	if (next_sir >= NSIR)
		panic("allocate_sir: none left");
	bit = next_sir++;
	sir_routines[bit] = proc;
	sir_args[bit] = arg;
	return (1 << bit);
}

void
init_sir()
{
	extern void netintr();

	sir_routines[0] = netintr;
	sir_routines[1] = softclock;
	next_sir = 2;
@


1.13
log
@Some warning hunting.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.12 2001/02/01 03:38:22 smurph Exp $	*/
d59 1
d66 1
d75 1
d105 3
d388 1
a388 1
                        data_access_emulation(frame);
d407 1
a407 1
					data_access_emulation(frame);
d443 1
a443 1
					data_access_emulation(frame);
d475 1
a475 1
		data_access_emulation(frame);
d540 1
a540 1
				data_access_emulation(frame);
d1642 2
a1643 2
void (*proc)();
void *arg;
d1777 1
a1777 1
boolean_t
d1800 1
a1800 1
boolean_t
@


1.12
log
@Major changes to get MVME188 working.  More header and code cleanups.  The
kernel is tested on MVME188A/2P256 and MVME188A/1P64.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.11 2001/01/13 05:19:00 smurph Exp $	*/
a126 1
extern ret_addr;
a212 1
	int su = 0;
d1286 1
d1292 1
a1292 1
	int error, new;
d1447 1
d1453 1
a1453 1
	int error, new;
a1828 1
	register unsigned va;
a1833 3
	unsigned inst;
	struct uio uio;
	struct iovec iov;
@


1.11
log
@Booting kernel with MACHINE_NEW_NONCONTIG.  UVM code added but not working.
New stand config.  Lots of header fixes.  Can now cross-compile i386->m88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.10 2000/11/10 18:15:40 art Exp $	*/
d103 11
a113 11
   "Reset",
   "Interrupt Exception",
   "Instruction Access",
   "Data Access Exception",
   "Misaligned Access",
   "Unimplemented Opcode",
   "Privilege Violation"
   "Bounds Check Violation",
   "Illegal Integer Divide",
   "Integer Overflow",
   "Error Exception",
d117 8
a124 8
   "Success (No Fault)",
   "unknown 1",
   "unknown 2",
   "Bus Error",
   "Segment Fault",
   "Page Fault",
   "Supervisor Violation",
   "Write Violation",
d126 1
d138 2
a139 32
   int sig;
   int s;

   /* take pending signals */
   while ((sig = CURSIG(p)) != 0)
      postsig(sig);
   p->p_priority = p->p_usrpri;

   if (want_resched) {
      /*
       * Since we are curproc, clock will normally just change
       * our priority without moving us from one queue to another
       * (since the running process is not on a queue.)
       * If that happened after we put ourselves on the run queue
       * but before we switched, we might not be on the queue
       * indicated by our priority.
       */
      s = splstatclock();
      setrunqueue(p);
      p->p_stats->p_ru.ru_nivcsw++;
      mi_switch();
      (void) splx(s);
      while ((sig = CURSIG(p)) != 0)
         postsig(sig);
   }

   /*
    * If profiling, charge recent system time to the trapped pc.
    */
   if (p->p_flag & P_PROFIL)
      addupc_task(p, frame->sxip & ~3,
                  (int)(p->p_sticks - oticks));
d141 29
a169 1
   curpriority = p->p_priority;
d175 1
a175 1
   static int panicing = 0;
d177 17
a193 17
   if (panicing++ == 0) {
      if (type == 2) {  /* instruction exception */
         DEBUG_MSG("\nInstr access fault (%s) v = %x, frame %x\n",
                pbus_exception_type[(frame->ipfsr >> 16) & 0x7],
                frame->sxip & ~3, frame);
      } else if (type == 3) { /* data access exception */
         DEBUG_MSG("\nData access fault (%s) v = %x, frame %x\n",
                pbus_exception_type[(frame->dpfsr >> 16) & 0x7],
                frame->sxip & ~3, frame);
      } else
         DEBUG_MSG("\ntrap type %d, v = %x, frame %x\n", type, frame->sxip & ~3, frame);
      regdump(frame);
   }
   if ((u_int)type < trap_types)
      panic(trap_type[type]);
   panic("trap");
   /*NOTREACHED*/
a195 1

d198 2
d204 27
a230 27
   struct proc *p;
   u_quad_t sticks = 0;
   vm_map_t map;
   vm_offset_t va;
   vm_prot_t ftype;
   int fault_type;
   u_long fault_code;
   unsigned nss, fault_addr;
   struct vmspace *vm;
   union sigval sv;
   int su = 0;
   int result;
   int sig = 0;
   unsigned pc = PC_REGS(frame);  /* get program counter (sxip) */

   extern vm_map_t kernel_map;
   extern int fubail(), subail();
   extern unsigned guarded_access_start;
   extern unsigned guarded_access_end;
   extern unsigned guarded_access_bad;

   if (type != last_trap[3]) {
      last_trap[0] = last_trap[1];
      last_trap[1] = last_trap[2];
      last_trap[2] = last_trap[3];
      last_trap[3] = type;
   }
d232 1
a232 1
   uvmexp.traps++;
d234 1
a234 1
   cnt.v_trap++;
d236 2
a237 2
   if ((p = curproc) == NULL)
      p = &proc0;
d239 11
a249 12
   if (USERMODE(frame->epsr)) {
      sticks = p->p_sticks;
      type += T_USER;
      p->p_md.md_tf = frame;  /* for ptrace/signals */
      fault_type = 0;
      fault_code = 0;
   }
/*   printf("trap 0x%x ", type); */
   switch (type) {
      default:
         panictrap(frame->vector, frame);
         /*NOTREACHED*/
d252 35
a286 35
      case T_KDB_BREAK:
         /*FALLTHRU*/
      case T_KDB_BREAK+T_USER:
         {
            int s = db_splhigh();
            db_enable_interrupt();
            ddb_break_trap(T_KDB_BREAK,(db_regs_t*)frame);
            db_disable_interrupt();
            db_splx(s);
            return;
         }
      case T_KDB_ENTRY:
         /*FALLTHRU*/
      case T_KDB_ENTRY+T_USER:
         {
            int s = db_splhigh();
            db_enable_interrupt();
            ddb_entry_trap(T_KDB_ENTRY,(db_regs_t*)frame);
            db_disable_interrupt();
            db_splx(s);
            return;
         }

   #if 0
      case T_ILLFLT:
         {
            int s = db_splhigh();
            db_enable_interrupt();
            ddb_error_trap(type == T_ILLFLT ? "unimplemented opcode" :
                           "error fault", (db_regs_t*)frame);
            db_disable_interrupt();
            db_splx(s);
            return;
         }
   #endif /* 0 */
d288 135
a422 95
      case T_INT:
      case T_INT+T_USER:
         /* This function pointer is set in machdep.c 
            It calls m188_ext_int or sbc_ext_int depending
            on the value of cputyp - smurph */
         (*mdfp.interrupt_func)(T_INT, frame);
         return;

      case T_MISALGNFLT:
         DEBUG_MSG("kernel misalgined "
                   "access exception @@ 0x%08x\n", frame->sxip);
         panictrap(frame->vector, frame);
         break;

      case T_INSTFLT:
         /* kernel mode instruction access fault.
          * Should never, never happen for a non-paged kernel.
          */
         DEBUG_MSG("kernel mode instruction "
                   "page fault @@ 0x%08x\n", frame->sxip);
         panictrap(frame->vector, frame);
         break;

      case T_DATAFLT:
         /* kernel mode data fault */
         /*
          * If the faulting address is in user space, handle it in
          * the context of the user process. Else, use kernel map.
          */

         if (type == T_DATAFLT) {
            fault_addr = frame->dma0;
            if (frame->dmt0 & (DMT_WRITE|DMT_LOCKBAR)) {
               ftype = VM_PROT_READ|VM_PROT_WRITE;
               fault_code = VM_PROT_WRITE;
            } else {
               ftype = VM_PROT_READ;
               fault_code = VM_PROT_READ;
            }
         } else {
            fault_addr = frame->sxip & XIP_ADDR;
            ftype = VM_PROT_READ;
            fault_code = VM_PROT_READ;
         }

         va = trunc_page((vm_offset_t)fault_addr);

         vm = p->p_vmspace;
         map = &vm->vm_map;

         /* data fault on a kernel address... */
         if (frame->dmt0 & DMT_DAS)
            map = kernel_map;

         /* 
          * We don't want to call vm_fault() if it is fuwintr() or
          * suwintr(). These routines are for copying from interrupt
          * context and vm_fault() can potentially sleep. You may
          * wonder if it isn't bad karma for an interrupt handler to	
          * touch the current process. Indeed it is, but clock interrupt
          * does it while doing profiling. It is OK in that context.
          */

         if (p->p_addr->u_pcb.pcb_onfault == (int)fubail ||
             p->p_addr->u_pcb.pcb_onfault == (int)subail)
            goto outtahere;

         /* data fault on the user address */
         if (type == T_DATAFLT && (frame->dmt0 & DMT_DAS) == 0) {
            type = T_DATAFLT + T_USER;
            goto user_fault;
         }

         /*
          *	If it is a guarded access, bus error is OK.
          */

         if ((frame->dpfsr >> 16 & 0x7) == 0x3 &&     /* bus error */
             (frame->sxip & ~3) >= (unsigned)&guarded_access_start &&
             (frame->sxip & ~3) <= (unsigned)&guarded_access_end) {

            frame->snip = ((unsigned)&guarded_access_bad    ) | FIP_V;
            frame->sfip = ((unsigned)&guarded_access_bad + 4) | FIP_V;
            frame->sxip = 0;
            frame->dmt0 = 0;/* XXX what about other trans. in data unit */
            frame->dpfsr = 0;
            return;
         }

         /*
          *	On a segment or a page fault, call vm_fault() to resolve
          *	the fault.
          */
         if ((frame->dpfsr >> 16 & 0x7) == 0x4        /* seg fault  */
             || (frame->dpfsr >> 16 & 0x7) == 0x5) { /* page fault */
d424 1
a424 1
            result = uvm_fault(map, va, 0, ftype);
d426 1
a426 1
            result = vm_fault(map, va, ftype, FALSE); 
d428 63
d492 19
a510 76
            
            /*
            printf("vm_fault(map 0x%x, va 0x%x, ftype 0x%x, FALSE) -> %d (%s)\n", 
                   map, va, ftype, result,
                   result ? "KERN_INVALID_ADDRESS" : "KERN_SUCCESS");
            */                   
            if (result == KERN_SUCCESS) {
               /*
                * We could resolve the fault. Call
                * data_access_emulation to drain the data unit pipe
                * line and reset dmt0 so that trap won't get called
                * again. For inst faults, back up the pipe line.
                */
               if (type == T_DATAFLT) {
                  /*
                  printf("calling data_access_emulation()\n");
                  */
                  data_access_emulation(frame);
                  frame->dmt0 = 0;
                  frame->dpfsr = 0;
               } else {
                  frame->sfip = frame->snip & ~FIP_E;
                  frame->snip = frame->sxip & ~NIP_E;
               }
               return;
            }
         }
         /*
         printf ("PBUS Fault %d (%s) va = 0x%x\n", ((frame->dpfsr >> 16) & 0x7), 
                 pbus_exception_type[(frame->dpfsr >> 16) & 0x7], va);
         */
         /*
          * if still the fault is not resolved ...
          */
         if (!p->p_addr->u_pcb.pcb_onfault)
            panictrap(frame->vector, frame);

         outtahere:
         frame->snip = ((unsigned)p->p_addr->u_pcb.pcb_onfault    ) | FIP_V;
         frame->sfip = ((unsigned)p->p_addr->u_pcb.pcb_onfault + 4) | FIP_V;
         frame->sxip = 0;
         frame->dmt0 = 0;  /* XXX what about other trans. in data unit */
         frame->dpfsr = 0;
         return;
      case T_INSTFLT+T_USER:
         /* User mode instruction access fault */
         /*FALLTHRU*/
      case T_DATAFLT+T_USER:
         user_fault:
/*         printf("\nUser Data access fault (%s) v = %x, frame %x\n",
                pbus_exception_type[(frame->dpfsr >> 16) & 0x7],
                frame->sxip & ~3, frame);
*/

         if (type == T_INSTFLT+T_USER) {
            fault_addr = frame->sxip & XIP_ADDR;
         } else {
            fault_addr = frame->dma0;
         }

         if (frame->dmt0 & (DMT_WRITE|DMT_LOCKBAR)) {
            ftype = VM_PROT_READ|VM_PROT_WRITE;
            fault_code = VM_PROT_WRITE;
         } else {
            ftype = VM_PROT_READ;
            fault_code = VM_PROT_READ;
         }

         va = trunc_page((vm_offset_t)fault_addr);

         vm = p->p_vmspace;
         map = &vm->vm_map;

         /* Call vm_fault() to resolve non-bus error faults */
         if ((frame->ipfsr >> 16 & 0x7) != 0x3 &&
             (frame->dpfsr >> 16 & 0x7) != 0x3) {
d512 1
a512 1
            result = uvm_fault(map, va, 0, ftype);
d514 1
a514 1
            result = vm_fault(map, va, ftype, FALSE); 
d516 2
a517 98
            frame->ipfsr = frame->dpfsr = 0;
            /*
            printf("vm_fault(map 0x%x, va 0x%x, ftype 0x%x, FALSE) -> %d (%s)\n", 
                   map, va, ftype, result,
                   result ? "KERN_INVALID_ADDRESS" : "KERN_SUCCESS");
            */
         }

         if ((caddr_t)va >= vm->vm_maxsaddr) {
            if (result == KERN_SUCCESS) {
               nss = clrnd(btoc(USRSTACK - va));/* XXX check this */
               if (nss > vm->vm_ssize)
                  vm->vm_ssize = nss;
            } else if (result == KERN_PROTECTION_FAILURE)
               result = KERN_INVALID_ADDRESS;
         }

         if (result == KERN_SUCCESS) {
            if (type == T_DATAFLT+T_USER) {
               /*
               printf("calling data_access_emulation()\n");
               */
               /*
                * We could resolve the fault. Call
                * data_access_emulation to drain the data unit
                * pipe line and reset dmt0 so that trap won't
                * get called again.
                */
               data_access_emulation(frame);
               frame->dmt0 = 0;
               frame->dpfsr = 0;
            } else {
               /* back up SXIP, SNIP clearing the the Error bit */
               frame->sfip = frame->snip & ~FIP_E;
               frame->snip = frame->sxip & ~NIP_E;
            }
         } else {
            sig = result == KERN_PROTECTION_FAILURE ? SIGBUS : SIGSEGV;
            fault_type = result == KERN_PROTECTION_FAILURE ? BUS_ADRERR
                         : SEGV_MAPERR;
         }
         /*
         printf("sig == %d, fault_type == %d\n", sig, fault_type);
         */
         break;

      case T_MISALGNFLT+T_USER:
/*	DEBUG_MSG("T_MISALGNFLT\n");*/
         sig = SIGBUS;
         fault_type = BUS_ADRALN;
/*	panictrap(fault_type, frame);*/
         break;

      case T_PRIVINFLT+T_USER:
      case T_ILLFLT+T_USER:
         sig = SIGILL;
         break;

      case T_BNDFLT+T_USER:
         sig = SIGFPE;
         break;
      case T_ZERODIV+T_USER:
         sig = SIGFPE;
         fault_type = FPE_INTDIV;
         break;
      case T_OVFFLT+T_USER:
         sig = SIGFPE;
         fault_type = FPE_INTOVF;
         break;

      case T_FPEPFLT+T_USER:
      case T_FPEIFLT+T_USER:
         sig = SIGFPE;
         break;

      case T_SIGTRAP+T_USER:
         sig = SIGTRAP;
         fault_type = TRAP_TRACE;
         break;

      case T_STEPBPT+T_USER:
         /*
          * This trap is used by the kernel to support single-step
          * debugging (although any user could generate this trap
          * which should probably be handled differently). When a
          * process is continued by a debugger with the PT_STEP
          * function of ptrace (single step), the kernel inserts
          * one or two breakpoints in the user process so that only
          * one instruction (or two in the case of a delayed branch)
          * is executed.  When this breakpoint is hit, we get the
          * T_STEPBPT trap.
          */
         
         {
            register unsigned va;
            unsigned instr;
            struct uio uio;
            struct iovec iov;
d519 79
a597 2
            /* compute address of break instruction */
            va = pc;
d599 2
a600 2
            /* read break instruction */
            instr = fuiword((caddr_t)pc);
d602 43
a644 43
            printf("trap: %s (%d) breakpoint %x at %x: (adr %x ins %x)\n",
                   p->p_comm, p->p_pid, instr, pc,
                   p->p_md.md_ss_addr, p->p_md.md_ss_instr); /* XXX */
#endif
            /* check and see if we got here by accident */
            if ((p->p_md.md_ss_addr != pc && 
                p->p_md.md_ss_taken_addr != pc) ||
                instr != SSBREAKPOINT) {
               sig = SIGTRAP;
               fault_type = TRAP_TRACE;
               break;
            }
            /* restore original instruction and clear BP  */
            instr = p->p_md.md_ss_instr;
            va = p->p_md.md_ss_addr;
            if (va != 0) {
               iov.iov_base = (caddr_t)&instr;
               iov.iov_len = sizeof(int); 
               uio.uio_iov = &iov;
               uio.uio_iovcnt = 1; 
               uio.uio_offset = (off_t)va;
               uio.uio_resid = sizeof(int);
               uio.uio_segflg = UIO_SYSSPACE;
               uio.uio_rw = UIO_WRITE;
               uio.uio_procp = curproc;
               procfs_domem(p, p, NULL, &uio);
            }
            
            /* branch taken instruction */
            instr = p->p_md.md_ss_taken_instr;
            va = p->p_md.md_ss_taken_addr;
            if (instr != 0) {
               iov.iov_base = (caddr_t)&instr;
               iov.iov_len = sizeof(int); 
               uio.uio_iov = &iov;
               uio.uio_iovcnt = 1; 
               uio.uio_offset = (off_t)va;
               uio.uio_resid = sizeof(int);
               uio.uio_segflg = UIO_SYSSPACE;
               uio.uio_rw = UIO_WRITE;
               uio.uio_procp = curproc;
               procfs_domem(p, p, NULL, &uio);
            }
d646 24
a669 24
            frame->sfip = frame->snip;    /* set up next FIP */
            frame->snip = pc;    /* set up next NIP */
            frame->snip |= 2;         /* set valid bit   */
#endif
            p->p_md.md_ss_addr = 0;
            p->p_md.md_ss_instr = 0;
            p->p_md.md_ss_taken_addr = 0;
            p->p_md.md_ss_taken_instr = 0;
            sig = SIGTRAP;
            fault_type = TRAP_BRKPT;
         }
         break;

      case T_USERBPT+T_USER:
         /*
          * This trap is meant to be used by debuggers to implement
          * breakpoint debugging.  When we get this trap, we just
          * return a signal which gets caught by the debugger.
          */
         frame->sfip = frame->snip;    /* set up the next FIP */
         frame->snip = frame->sxip;    /* set up the next NIP */
         sig = SIGTRAP;
         fault_type = TRAP_BRKPT;
         break;
d671 1
a671 1
      case T_ASTFLT+T_USER:
d673 1
a673 1
         uvmexp.softs++;
d675 1
a675 1
         cnt.v_soft++;
d677 24
a700 24
         want_ast = 0;
         if (p->p_flag & P_OWEUPC) {
            p->p_flag &= ~P_OWEUPC;
            ADDUPROF(p);
         }
         break;
   }

   /*
    * If trap from supervisor mode, just return
    */
   if (SYSTEMMODE(frame->epsr))
      return;

   if (sig) {
      sv.sival_int = fault_addr;
      trapsignal(p, sig, fault_code, fault_type, sv);
      /*		
       * don't want multiple faults - we are going to
       * deliver signal.
       */
      frame->dmt0 = 0;
      frame->dpfsr = 0;
   }
d702 1
a702 1
   userret(p, frame, sticks);
d710 21
a730 21
   struct proc *p;
   u_quad_t sticks = 0;
   vm_map_t map;
   vm_offset_t va;
   vm_prot_t ftype;
   int fault_type;
   u_long fault_code;
   unsigned nss, fault_addr;
   struct vmspace *vm;
   union sigval sv;
   int su = 0;
   int result;
   int sig = 0;
   unsigned pc = PC_REGS(frame);  /* get program counter (sxip) */
   unsigned dsr, isr, user = 0, write = 0, data = 0;

   extern vm_map_t kernel_map;
   extern int fubail(), subail();
   extern unsigned guarded_access_start;
   extern unsigned guarded_access_end;
   extern unsigned guarded_access_bad;
d733 1
a733 1
   uvmexp.traps++;
d735 1
a735 1
   cnt.v_trap++;
d737 127
a863 127
   
   if ((p = curproc) == NULL)
      p = &proc0;

   if (USERMODE(frame->epsr)) {
      sticks = p->p_sticks;
      type += T_USER;
      p->p_md.md_tf = frame;  /* for ptrace/signals */
      fault_type = 0;
      fault_code = 0;
   }
   printf("m197_trap 0x%x ", type);
   switch (type) {
      default:
         panictrap(frame->vector, frame);
         /*NOTREACHED*/
      case T_197_READ+T_USER:
         user = 1;
      case T_197_READ:
         va = (vm_offset_t) frame->dlar;
         /* if it was a user read, handle in context of the user */
         if ((frame->dsr & CMMU_DSR_SU) && !user) {
            map = kernel_map;
         } else {
            vm = p->p_vmspace;
            map = &vm->vm_map;
         }
         result = m197_table_search(map->pmap, va, CMMU_READ, user, CMMU_DATA);
         if (result) {
            switch (result) {
               case 4: /* Seg Fault */
                  frame->dsr |= CMMU_DSR_SI | CMMU_DSR_RW;
                  break;
               case 5: /* Page Fault */
                  frame->dsr |= CMMU_DSR_PI | CMMU_DSR_RW;
                  break;
               case 6: /* Supervisor Violation */
                  frame->dsr |= CMMU_DSR_SP | CMMU_DSR_RW;
                  break;
            }
            /* table search failed and we are going to report a data fault */
            if (user) {
               type = T_DATAFLT+T_USER;
               goto m197_user_fault;
            } else {
               type = T_DATAFLT;
               goto m197_data_fault;
            }
         } else {
            return; /* PATC sucessfully loaded */
         }
         break;      
      case T_197_WRITE+T_USER:
         user = 1;
      case T_197_WRITE:
         /* if it was a user read, handle in context of the user */
         if ((frame->dsr & CMMU_DSR_SU) && !user) {
            map = kernel_map;
         } else {
            vm = p->p_vmspace;
            map = &vm->vm_map;
         }
         va = (vm_offset_t) frame->dlar;
         result = m197_table_search(map->pmap, va, CMMU_WRITE, user, CMMU_DATA);
         if (result) {
            switch (result) {
               case 4: /* Seg Fault */
                  frame->dsr |= CMMU_DSR_SI;
                  break;
               case 5: /* Page Fault */
                  frame->dsr |= CMMU_DSR_PI;
                  break;
               case 6: /* Supervisor Violation */
                  frame->dsr |= CMMU_DSR_SP;
                  break;
               case 7: /* Write Violation */
                  frame->dsr |= CMMU_DSR_WE;
                  break;
            }
            /* table search failed and we are going to report a data fault */
            if (user) {
               type = T_DATAFLT+T_USER;
               goto m197_user_fault;
            } else {
               type = T_DATAFLT;
               goto m197_data_fault;
            }
         } else {
            return; /* PATC sucessfully loaded */
         }
         break;      
      case T_197_INST+T_USER:
         user = 1;
      case T_197_INST:
         /* if it was a user read, handle in context of the user */
         if ((frame->isr & CMMU_ISR_SU) && !user) {
            map = kernel_map;
         } else {
            vm = p->p_vmspace;
            map = &vm->vm_map;
         }
         va = (vm_offset_t) frame->sxip;
         result = m197_table_search(map->pmap, va, CMMU_READ, user, CMMU_INST);
         if (result) {
            switch (result) {
               case 4: /* Seg Fault */
                  frame->isr |= CMMU_ISR_SI;
                  break;
               case 5: /* Page Fault */
                  frame->isr |= CMMU_ISR_PI;
                  break;
               case 6: /* Supervisor Violation */
                  frame->isr |= CMMU_ISR_SP;
                  break;
            }
            /* table search failed and we are going to report a data fault */
            if (user) {
               type = T_INSTFLT+T_USER;
               goto m197_user_fault;
            } else {
               type = T_INSTFLT;
               goto m197_inst_fault;
            }
         } else {
            return; /* PATC sucessfully loaded */
         }
         break;      
d865 135
a999 135
      case T_KDB_BREAK:
         /*FALLTHRU*/
      case T_KDB_BREAK+T_USER:
         {
            int s = db_splhigh();
            db_enable_interrupt();
            ddb_break_trap(T_KDB_BREAK,(db_regs_t*)frame);
            db_disable_interrupt();
            db_splx(s);
            return;
         }
      case T_KDB_ENTRY:
         /*FALLTHRU*/
      case T_KDB_ENTRY+T_USER:
         {
            int s = db_splhigh();
            db_enable_interrupt();
            ddb_entry_trap(T_KDB_ENTRY,(db_regs_t*)frame);
            db_disable_interrupt();
            db_splx(s);
            return;
         }

      #if 0
      case T_ILLFLT:
         {
            int s = db_splhigh();
            db_enable_interrupt();
            ddb_error_trap(type == T_ILLFLT ? "unimplemented opcode" :
                           "error fault", (db_regs_t*)frame);
            db_disable_interrupt();
            db_splx(s);
            return;
         }
      #endif /* 0 */
   #endif /* DDB */
      case T_ILLFLT:
         DEBUG_MSG("test trap "
                   "page fault @@ 0x%08x\n", frame->sxip);
         panictrap(frame->vector, frame);
		break;

      case T_MISALGNFLT:
         DEBUG_MSG("kernel misalgined "
                   "access exception @@ 0x%08x\n", frame->sxip);
         panictrap(frame->vector, frame);
         break;

      case T_INSTFLT:
m197_inst_fault:
         /* kernel mode instruction access fault.
          * Should never, never happen for a non-paged kernel.
          */
         DEBUG_MSG("kernel mode instruction "
                   "page fault @@ 0x%08x\n", frame->sxip);
         panictrap(frame->vector, frame);
         break;

      case T_DATAFLT:
         /* kernel mode data fault */
         /*
          * If the faulting address is in user space, handle it in
          * the context of the user process. Else, use kernel map.
          */
m197_data_fault:
         if (type == T_DATAFLT) {
            fault_addr = frame->dlar;
            if (frame->dsr & CMMU_DSR_RW) {
               ftype = VM_PROT_READ;
               fault_code = VM_PROT_READ;
            } else {
               ftype = VM_PROT_READ|VM_PROT_WRITE;
               fault_code = VM_PROT_WRITE;
               write = 1;
            }
            data = 1;
         } else {
            fault_addr = frame->sxip & XIP_ADDR;
            ftype = VM_PROT_READ;
            fault_code = VM_PROT_READ;
         }

         va = trunc_page((vm_offset_t)fault_addr);
         vm = p->p_vmspace;
         map = &vm->vm_map;

         /* data fault on a kernel address... */
         if (type == T_DATAFLT) {
            if (frame->dsr & CMMU_DSR_SU) {
               map = kernel_map;
            }
         }

         /* 
          * We don't want to call vm_fault() if it is fuwintr() or
          * suwintr(). These routines are for copying from interrupt
          * context and vm_fault() can potentially sleep. You may
          * wonder if it isn't bad karma for an interrupt handler to	
          * touch the current process. Indeed it is, but clock interrupt
          * does it while doing profiling. It is OK in that context.
          */

         if (p->p_addr->u_pcb.pcb_onfault == (int)fubail ||
             p->p_addr->u_pcb.pcb_onfault == (int)subail)
            goto m197_outtahere;

         /* data fault on the user address */
         if (type == T_DATAFLT && (frame->dsr & CMMU_DSR_SU) == 0) {
            type = T_DATAFLT + T_USER;
            goto m197_user_fault;
         }

         /*
          *	If it is a guarded access, bus error is OK.
          */

         if ((frame->dsr & CMMU_DSR_BE) &&     /* bus error */
             (frame->sxip & ~3) >= (unsigned)&guarded_access_start &&
             (frame->sxip & ~3) <= (unsigned)&guarded_access_end) {
            return;
         }

         /*
          *	On a segment or a page fault, call vm_fault() to resolve
          *	the fault.
          */
         result = m197_table_search(map->pmap, va, write, 1, data);
/* todo         
         switch (result) {
         case :
         }
*/         
         if (type == T_DATAFLT) {
            if ((frame->dsr & CMMU_DSR_SI)        /* seg fault  */
                || (frame->dsr & CMMU_DSR_PI)) { /* page fault */
d1001 1
a1001 1
               result = uvm_fault(map, va, 0, ftype);
d1003 1
a1003 1
               result = vm_fault(map, va, ftype, FALSE); 
d1005 7
a1011 7
               if (result == KERN_SUCCESS) {
                  return;
               }
            }
         } else {
            if ((frame->isr & CMMU_ISR_SI)        /* seg fault  */
                || (frame->isr & CMMU_ISR_PI)) { /* page fault */
d1013 1
a1013 1
               result = uvm_fault(map, va, 0, ftype);
d1015 1
a1015 1
               result = vm_fault(map, va, ftype, FALSE); 
d1017 44
a1060 53
               if (result == KERN_SUCCESS) {
                  return;
               }
            }
         }

         /*
         printf ("PBUS Fault %d (%s) va = 0x%x\n", ((frame->dpfsr >> 16) & 0x7), 
                 pbus_exception_type[(frame->dpfsr >> 16) & 0x7], va);
         */
         /*
          * if still the fault is not resolved ...
          */
         if (!p->p_addr->u_pcb.pcb_onfault)
            panictrap(frame->vector, frame);

m197_outtahere:
         frame->sxip = ((unsigned)p->p_addr->u_pcb.pcb_onfault);
         return;
      case T_INSTFLT+T_USER:
         /* User mode instruction access fault */
         /*FALLTHRU*/
      case T_DATAFLT+T_USER:
m197_user_fault:
/*         printf("\nUser Data access fault (%s) v = %x, frame %x\n",
                pbus_exception_type[(frame->dpfsr >> 16) & 0x7],
                frame->sxip & ~3, frame);
*/

         if (type == T_INSTFLT+T_USER) {
            fault_addr = frame->sxip & XIP_ADDR;
            ftype = VM_PROT_READ;
            fault_code = VM_PROT_READ;
         } else {
            fault_addr = frame->dlar;
            if (frame->dsr & CMMU_DSR_RW) {
               ftype = VM_PROT_READ;
               fault_code = VM_PROT_READ;
            } else {
               ftype = VM_PROT_READ|VM_PROT_WRITE;
               fault_code = VM_PROT_WRITE;
            }
         }

         va = trunc_page((vm_offset_t)fault_addr);

         vm = p->p_vmspace;
         map = &vm->vm_map;

         /* Call vm_fault() to resolve non-bus error faults */
         if (type == T_DATAFLT+T_USER) {
            if ((frame->dsr & CMMU_DSR_SI)        /* seg fault  */
                || (frame->dsr & CMMU_DSR_PI)) { /* page fault */
d1062 1
a1062 1
               result = uvm_fault(map, va, 0, ftype);
d1064 1
a1064 1
               result = vm_fault(map, va, ftype, FALSE); 
d1066 7
a1072 7
               if (result == KERN_SUCCESS) {
                  return;
               }
            }
         } else {
            if ((frame->isr & CMMU_ISR_SI)        /* seg fault  */
                || (frame->isr & CMMU_ISR_PI)) { /* page fault */
d1074 1
a1074 1
               result = uvm_fault(map, va, 0, ftype);
d1076 1
a1076 1
               result = vm_fault(map, va, ftype, FALSE); 
d1078 128
a1205 140
               if (result == KERN_SUCCESS) {
                  return;
               }
            }
         }

         if ((caddr_t)va >= vm->vm_maxsaddr) {
            if (result == KERN_SUCCESS) {
               nss = clrnd(btoc(USRSTACK - va));/* XXX check this */
               if (nss > vm->vm_ssize)
                  vm->vm_ssize = nss;
            } else if (result == KERN_PROTECTION_FAILURE)
               result = KERN_INVALID_ADDRESS;
         }

         if (result != KERN_SUCCESS) {
            sig = result == KERN_PROTECTION_FAILURE ? SIGBUS : SIGSEGV;
            fault_type = result == KERN_PROTECTION_FAILURE ? BUS_ADRERR
                         : SEGV_MAPERR;
         } else {
            return;
         }
         /*
         printf("sig == %d, fault_type == %d\n", sig, fault_type);
         */
         break;

      case T_MISALGNFLT+T_USER:
/*	DEBUG_MSG("T_MISALGNFLT\n");*/
         sig = SIGBUS;
         fault_type = BUS_ADRALN;
/*	panictrap(fault_type, frame);*/
         break;

      case T_PRIVINFLT+T_USER:
      case T_ILLFLT+T_USER:
         sig = SIGILL;
         break;

      case T_BNDFLT+T_USER:
         sig = SIGFPE;
         break;
      case T_ZERODIV+T_USER:
         sig = SIGFPE;
         fault_type = FPE_INTDIV;
         break;
      case T_OVFFLT+T_USER:
         sig = SIGFPE;
         fault_type = FPE_INTOVF;
         break;

      case T_FPEPFLT+T_USER:
      case T_FPEIFLT+T_USER:
         sig = SIGFPE;
         break;

      case T_SIGTRAP+T_USER:
         sig = SIGTRAP;
         fault_type = TRAP_TRACE;
         break;

      case T_STEPBPT+T_USER:
         /*
          * This trap is used by the kernel to support single-step
          * debugging (although any user could generate this trap
          * which should probably be handled differently). When a
          * process is continued by a debugger with the PT_STEP
          * function of ptrace (single step), the kernel inserts
          * one or two breakpoints in the user process so that only
          * one instruction (or two in the case of a delayed branch)
          * is executed.  When this breakpoint is hit, we get the
          * T_STEPBPT trap.
          */
   #if 0
         frame->sfip = frame->snip;    /* set up next FIP */
         frame->snip = frame->sxip;    /* set up next NIP */
         break;
   #endif
         {
            register unsigned va;
            unsigned instr;
            struct uio uio;
            struct iovec iov;

            /* compute address of break instruction */
            va = pc;

            /* read break instruction */
            instr = fuiword((caddr_t)pc);
   #if 1
            printf("trap: %s (%d) breakpoint %x at %x: (adr %x ins %x)\n",
                   p->p_comm, p->p_pid, instr, pc,
                   p->p_md.md_ss_addr, p->p_md.md_ss_instr); /* XXX */
   #endif
            /* check and see if we got here by accident */
/*
   if (p->p_md.md_ss_addr != pc || instr != SSBREAKPOINT) {
      sig = SIGTRAP;
      fault_type = TRAP_TRACE;
      break;
   }
*/
            /* restore original instruction and clear BP  */
            /*sig = suiword((caddr_t)pc, p->p_md.md_ss_instr);*/
            instr = p->p_md.md_ss_instr;
            if (instr == 0) {
               printf("Warning: can't restore instruction at %x: %x\n",
                      p->p_md.md_ss_addr, p->p_md.md_ss_instr);
            } else {
               iov.iov_base = (caddr_t)&instr;
               iov.iov_len = sizeof(int); 
               uio.uio_iov = &iov;
               uio.uio_iovcnt = 1; 
               uio.uio_offset = (off_t)pc;
               uio.uio_resid = sizeof(int);
               uio.uio_segflg = UIO_SYSSPACE;
               uio.uio_rw = UIO_WRITE;
               uio.uio_procp = curproc;
            }

            frame->sfip = frame->snip;    /* set up next FIP */
            frame->snip = frame->sxip;    /* set up next NIP */
            frame->snip |= 2;         /* set valid bit   */
            p->p_md.md_ss_addr = 0;
            sig = SIGTRAP;
            fault_type = TRAP_BRKPT;
            break;
         }

      case T_USERBPT+T_USER:
         /*
          * This trap is meant to be used by debuggers to implement
          * breakpoint debugging.  When we get this trap, we just
          * return a signal which gets caught by the debugger.
          */
         frame->sfip = frame->snip;    /* set up the next FIP */
         frame->snip = frame->sxip;    /* set up the next NIP */
         sig = SIGTRAP;
         fault_type = TRAP_BRKPT;
         break;
d1207 1
a1207 1
      case T_ASTFLT+T_USER:
d1209 1
a1209 1
         uvmexp.softs++;
d1211 1
a1211 1
         cnt.v_soft++;
d1213 23
a1235 24
         want_ast = 0;
         if (p->p_flag & P_OWEUPC) {
            p->p_flag &= ~P_OWEUPC;
            ADDUPROF(p);
         }
         break;
   }

   /*
    * If trap from supervisor mode, just return
    */
   if (SYSTEMMODE(frame->epsr))
      return;

   if (sig) {
      sv.sival_int = fault_addr;
      trapsignal(p, sig, fault_code, fault_type, sv);
      /*		
       * don't want multiple faults - we are going to
       * deliver signal.
       */
      frame->dsr = 0;
   }
   userret(p, frame, sticks);
d1238 1
d1242 2
a1243 2
   DEBUG_MSG("\n[test_trap (Good News[tm]) m197 = %d, vec = %d]\n", m197, num);
   bugreturn();
d1249 3
a1251 3
   DEBUG_MSG("\n[test_trap (Good News[tm]) frame 0x%08x]\n", frame);
   regdump((struct trapframe*)frame);
   bugreturn();
d1253 1
d1257 9
a1265 3
   DEBUG_MSG("\n[ERROR EXCEPTION (Bad News[tm]) frame 0x%08x]\n", frame);
   regdump((struct trapframe*)frame);
   DEBUG_MSG("trap trace %x -> %x -> %x -> %x\n", last_trap[0], last_trap[1], last_trap[2], last_trap[3]);
d1267 3
a1269 3
   gimmeabreak();
   DEBUG_MSG("[you really can't restart after an error exception.]\n");
   gimmeabreak();
d1271 1
a1271 1
   bugreturn();  /* This gets us to Bug instead of a loop forever */
d1277 3
a1279 4
   DEBUG_MSG("\n[RESET EXCEPTION (Really Bad News[tm]) frame 0x%08x]\n", frame);
   DEBUG_MSG("This is usually caused by a branch to a NULL function pointer.\n");
   DEBUG_MSG("Use the debugger trace command to track it down.\n");

d1281 3
a1283 3
   gimmeabreak();
   DEBUG_MSG("[It's useless to restart after a reset exception. You might as well reboot.]\n");
   gimmeabreak();
d1285 1
a1285 1
   bugreturn();  /* This gets us to Bug instead of a loop forever */
d1290 10
a1299 10
   register int i, nsys, *ap, nap;
   register struct sysent *callp;
   register struct proc *p;
   int error, new;
   struct args {
      int i[8];
   } args;
   int rval[2];
   u_quad_t sticks;
   extern struct pcb *curpcb;
d1302 1
a1302 1
   uvmexp.syscalls++;
d1304 1
a1304 1
   cnt.v_syscall++;
d1307 1
a1307 1
   p = curproc;
d1309 2
a1310 2
   callp = p->p_emul->e_sysent;
   nsys  = p->p_emul->e_nsysent;
d1313 49
a1361 49
   if (USERMODE(tf->epsr) == 0)
      panic("syscall");
   if (curpcb != &p->p_addr->u_pcb)
      panic("syscall curpcb/ppcb");
   if (tf != (struct trapframe *)&curpcb->user_state)
      panic("syscall trapframe");
#endif

   sticks = p->p_sticks;
   p->p_md.md_tf = tf;

   /*
    * For 88k, all the arguments are passed in the registers (r2-r12)
    * For syscall (and __syscall), r2 (and r3) has the actual code.
    * __syscall  takes a quad syscall number, so that other
    * arguments are at their natural alignments.
    */
   ap = &tf->r[2];
   nap = 6;

   switch (code) {
      case SYS_syscall:
         code = *ap++;
         nap--;
         break;
      case SYS___syscall:
         if (callp != sysent)
            break;
         code = ap[_QUAD_LOWWORD];
         ap += 2;
         nap -= 2;
         break;
   }

   /* Callp currently points to syscall, which returns ENOSYS. */

   if (code < 0 || code >= nsys)
      callp += p->p_emul->e_nosys;
   else {
      callp += code;
      i = callp->sy_argsize / sizeof(register_t);
      if (i > 8)
         panic("syscall nargs");
      /*
       * just copy them; syscall stub made sure all the
       * args are moved from user stack to registers.
       */
      bcopy((caddr_t)ap, (caddr_t)args.i, i * sizeof(register_t));
   }
d1363 1
a1363 1
   scdebug_call(p, code, args.i);
d1366 2
a1367 2
   if (KTRPOINT(p, KTR_SYSCALL))
      ktrsyscall(p, code, callp->sy_argsize, args.i);
d1369 68
a1436 68
   rval[0] = 0;
   rval[1] = 0;
   error = (*callp->sy_call)(p, &args, rval);
   /*
    * system call will look like:
    *	 ld r10, r31, 32; r10,r11,r12 might be garbage.
    *	 ld r11, r31, 36
    *	 ld r12, r31, 40
    *	 or r13, r0, <code>
    *       tb0 0, r0, <128> <- xip
    *	 br err 	  <- nip
    *       jmp r1 	  <- fip
    *  err: or.u r3, r0, hi16(errno)
    *	 st r2, r3, lo16(errno)
    *	 subu r2, r0, 1 
    *	 jmp r1
    *
    * So, when we take syscall trap, sxip/snip/sfip will be as
    * shown above.
    * Given this,
    * 1. If the system call returned 0, need to skip nip.
    *	nip = fip, fip += 4
    *    (doesn't matter what fip + 4 will be but we will never
    *    execute this since jmp r1 at nip will change the execution flow.)
    * 2. If the system call returned an errno > 0, plug the value
    *    in r2, and leave nip and fip unchanged. This will have us
    *    executing "br err" on return to user space.
    * 3. If the system call code returned ERESTART,
    *    we need to rexecute the trap instruction. Back up the pipe
    *    line.
    *     fip = nip, nip = xip
    * 4. If the system call returned EJUSTRETURN, don't need to adjust
    *    any pointers.
    */

   if (error == 0) {
      /*
       * If fork succeeded and we are the child, our stack
       * has moved and the pointer tf is no longer valid,
       * and p is wrong.  Compute the new trapframe pointer.
       * (The trap frame invariably resides at the
       * tippity-top of the u. area.)
       */
      p = curproc;
      tf = USER_REGS(p);
      tf->r[2] = rval[0];
      tf->r[3] = rval[1];
      tf->epsr &= ~PSR_C;
      tf->snip = tf->sfip & ~FIP_E;
      tf->sfip = tf->snip + 4;
   } else if (error > 0) {
      /* error != ERESTART && error != EJUSTRETURN*/
      tf->r[2] = error;
      tf->epsr |= PSR_C;   /* fail */
      tf->snip = tf->snip & ~NIP_E;
      tf->sfip = tf->sfip & ~FIP_E;
   } else if (error == ERESTART) {
      /*
       * If (error == ERESTART), back up the pipe line. This
       * will end up reexecuting the trap.
       */
      tf->epsr &= ~PSR_C;
      tf->sfip = tf->snip & ~NIP_E;
      tf->snip = tf->sxip & ~NIP_E;
   } else {
      /* if (error == EJUSTRETURN), leave the ip's alone */
      tf->epsr &= ~PSR_C;
   }
d1438 1
a1438 1
   scdebug_ret(p, code, error, rval);
d1440 1
a1440 1
   userret(p, tf, sticks);
d1442 2
a1443 2
   if (KTRPOINT(p, KTR_SYSRET))
      ktrsysret(p, code, error, rval[0]);
d1450 10
a1459 10
   register int i, nsys, *ap, nap;
   register struct sysent *callp;
   register struct proc *p;
   int error, new;
   struct args {
      int i[8];
   } args;
   int rval[2];
   u_quad_t sticks;
   extern struct pcb *curpcb;
d1462 1
a1462 1
   uvmexp.syscalls++;
d1464 1
a1464 1
   cnt.v_syscall++;
d1467 1
a1467 1
   p = curproc;
d1469 2
a1470 2
   callp = p->p_emul->e_sysent;
   nsys  = p->p_emul->e_nsysent;
d1473 49
a1521 49
   if (USERMODE(tf->epsr) == 0)
      panic("syscall");
   if (curpcb != &p->p_addr->u_pcb)
      panic("syscall curpcb/ppcb");
   if (tf != (struct trapframe *)&curpcb->user_state)
      panic("syscall trapframe");
#endif

   sticks = p->p_sticks;
   p->p_md.md_tf = tf;

   /*
    * For 88k, all the arguments are passed in the registers (r2-r12)
    * For syscall (and __syscall), r2 (and r3) has the actual code.
    * __syscall  takes a quad syscall number, so that other
    * arguments are at their natural alignments.
    */
   ap = &tf->r[2];
   nap = 6;

   switch (code) {
      case SYS_syscall:
         code = *ap++;
         nap--;
         break;
      case SYS___syscall:
         if (callp != sysent)
            break;
         code = ap[_QUAD_LOWWORD];
         ap += 2;
         nap -= 2;
         break;
   }

   /* Callp currently points to syscall, which returns ENOSYS. */

   if (code < 0 || code >= nsys)
      callp += p->p_emul->e_nosys;
   else {
      callp += code;
      i = callp->sy_argsize / sizeof(register_t);
      if (i > 8)
         panic("syscall nargs");
      /*
       * just copy them; syscall stub made sure all the
       * args are moved from user stack to registers.
       */
      bcopy((caddr_t)ap, (caddr_t)args.i, i * sizeof(register_t));
   }
d1523 1
a1523 1
   scdebug_call(p, code, args.i);
d1526 2
a1527 2
   if (KTRPOINT(p, KTR_SYSCALL))
      ktrsyscall(p, code, callp->sy_argsize, args.i);
d1529 64
a1592 64
   rval[0] = 0;
   rval[1] = 0;
   error = (*callp->sy_call)(p, &args, rval);
   /*
    * system call will look like:
    *	 ld r10, r31, 32; r10,r11,r12 might be garbage.
    *	 ld r11, r31, 36
    *	 ld r12, r31, 40
    *	 or r13, r0, <code>
    *       tb0 0, r0, <128> <- sxip
    *	 br err 	  <- snip
    *       jmp r1
    *  err: or.u r3, r0, hi16(errno)
    *	 st r2, r3, lo16(errno)
    *	 subu r2, r0, 1 
    *	 jmp r1
    *
    * So, when we take syscall trap, sxip/snip will be as
    * shown above.
    * Given this,
    * 1. If the system call returned 0, need to jmp r1.
    *	   sxip += 8
    * 2. If the system call returned an errno > 0, increment 
    *    sxip += 4 and plug the value in r2. This will have us
    *    executing "br err" on return to user space.
    * 3. If the system call code returned ERESTART,
    *    we need to rexecute the trap instruction. leave xip as is.
    * 4. If the system call returned EJUSTRETURN, just return.
    *    sxip += 8
    */

   if (error == 0) {
      /*
       * If fork succeeded and we are the child, our stack
       * has moved and the pointer tf is no longer valid,
       * and p is wrong.  Compute the new trapframe pointer.
       * (The trap frame invariably resides at the
       * tippity-top of the u. area.)
       */
      p = curproc;
      tf = USER_REGS(p);
      tf->r[2] = rval[0];
      tf->r[3] = rval[1];
      tf->epsr &= ~PSR_C;
      tf->sxip += 8;
      tf->sxip &= ~3;
   } else if (error > 0) {
      /* error != ERESTART && error != EJUSTRETURN*/
      tf->r[2] = error;
      tf->epsr |= PSR_C;   /* fail */
      tf->sxip += 4;
      tf->sxip &= ~3;
   } else if (error == ERESTART) {
      /*
       * If (error == ERESTART), back up the pipe line. This
       * will end up reexecuting the trap.
       */
      tf->epsr &= ~PSR_C;
   } else {
      /* if (error == EJUSTRETURN) */
      tf->epsr &= ~PSR_C;
      tf->sxip += 8; 
      tf->sxip &= ~3;
   }
d1594 1
a1594 1
   scdebug_ret(p, code, error, rval);
d1596 1
a1596 1
   userret(p, tf, sticks);
d1598 2
a1599 2
   if (KTRPOINT(p, KTR_SYSRET))
      ktrsysret(p, code, error, rval[0]);
d1610 1
a1610 1
   struct trapframe *tf;
d1612 11
a1622 11
   tf = USER_REGS(p);
   tf->r[2] = 0;
   tf->r[3] = 0;
   tf->epsr &= ~PSR_C;
   if (cputyp != CPU_197) {
      tf->snip = tf->sfip & ~3;
      tf->sfip = tf->snip + 4;
   } else {
      tf->sxip += 8;
      tf->sxip &= ~3;
   }
d1624 1
a1624 1
   userret(p, tf, p->p_sticks);
d1626 2
a1627 2
   if (KTRPOINT(p, KTR_SYSRET))
      ktrsysret(p, SYS_fork, 0, 0);
d1639 1
a1639 1
   int bit;
d1641 6
a1646 6
   if (next_sir >= NSIR)
      panic("allocate_sir: none left");
   bit = next_sir++;
   sir_routines[bit] = proc;
   sir_args[bit] = arg;
   return (1 << bit);
d1652 1
a1652 1
   extern void netintr();
d1654 3
a1656 3
   sir_routines[0] = netintr;
   sir_routines[1] = softclock;
   next_sir = 2;
a1658 1

d1666 15
a1680 15
   struct uio uio;
   struct iovec iov;
   unsigned value;

   iov.iov_base = (caddr_t)&value;
   iov.iov_len = size; 
   uio.uio_iov = &iov;
   uio.uio_iovcnt = 1; 
   uio.uio_offset = (off_t)addr;
   uio.uio_resid = size;
   uio.uio_segflg = UIO_SYSSPACE;
   uio.uio_rw = UIO_READ;
   uio.uio_procp = curproc;
   procfs_domem(curproc, p, NULL, &uio);
   return value;
d1686 15
a1700 15
   struct uio uio;
   struct iovec iov;
   int i;

   iov.iov_base = (caddr_t)&value;
   iov.iov_len = size; 
   uio.uio_iov = &iov;
   uio.uio_iovcnt = 1; 
   uio.uio_offset = (off_t)addr;
   uio.uio_resid = size;
   uio.uio_segflg = UIO_SYSSPACE;
   uio.uio_rw = UIO_WRITE;
   uio.uio_procp = curproc;
   i = procfs_domem(curproc, p, NULL, &uio);
   return i;
d1716 33
a1748 33
               unsigned inst,
               unsigned pc,
               unsigned (*func)(unsigned int, struct trapframe *),
               struct trapframe *func_data)  /* 'opaque' */
{

   /* check if br/bsr */
   if ((inst & 0xf0000000U) == 0xc0000000U) {
      /* signed 26 bit pc relative displacement, shift left two bits */
      inst = (inst & 0x03ffffffU)<<2;
      /* check if sign extension is needed */
      if (inst & 0x08000000U)
         inst |= 0xf0000000U;
      return pc + inst;
   }

   /* check if bb0/bb1/bcnd case */
   switch ((inst & 0xf8000000U)) {
      case 0xd0000000U: /* bb0 */
      case 0xd8000000U: /* bb1 */
      case 0xe8000000U: /* bcnd */
         /* signed 16 bit pc relative displacement, shift left two bits */
         inst = (inst & 0x0000ffffU)<<2;
         /* check if sign extension is needed */
         if (inst & 0x00020000U)
            inst |= 0xfffc0000U;
         return pc + inst;
   }

   /* check jmp/jsr case */
   /* check bits 5-31, skipping 10 & 11 */
   if ((inst & 0xfffff3e0U) == 0xf400c000U)
      return (*func)(inst & 0x1f, func_data);  /* the register value */
d1750 1
a1750 1
   return 0; /* keeps compiler happy */
d1761 8
a1768 8
   if (regno == 0)
      return 0;
   else if (regno < 31)
      return tf->r[regno];
   else {
      panic("bad register number to ss_getreg_val.");
      return 0;/*to make compiler happy */
   }
d1774 13
a1786 14
  /* check high five bits */
 
  switch (ins >> (32-5))
    {
    case 0x18: /* br */
    case 0x1a: /* bb0 */
    case 0x1b: /* bb1 */
    case 0x1d: /* bcnd */
      return TRUE;
      break;
    case 0x1e: /* could be jmp */
      if ((ins & 0xfffffbe0U) == 0xf400c000U)
	return TRUE;
    }
d1788 1
a1788 1
  return FALSE;
a1790 1

d1797 13
a1809 14
  /* check the br, bsr, bb0, bb1, bcnd cases */
  switch ((ins & 0xfc000000U)>>(32-6))
    {
    case 0x31: /* br */
    case 0x33: /* bsr */
    case 0x35: /* bb0 */
    case 0x37: /* bb1 */
    case 0x3b: /* bcnd */
      return TRUE;
    }

 /* check the jmp, jsr cases */
 /* mask out bits 0-4, bit 11 */
  return ((ins & 0xfffff7e0U) == 0xf400c400U) ? TRUE : FALSE;
d1815 8
a1822 9
    if (delay_slot == 0)
	return pc + 4;
    else
    {
	if (ss_inst_delayed(ss_get_value(p, pc, sizeof(int))))
	   return pc + 4;
	else
	   return pc;
    }
d1829 23
a1851 23
   register unsigned va;
   struct trapframe *sstf = USER_REGS(p); /*p->p_md.md_tf;*/
   unsigned pc, brpc;
   int i;
   int bpinstr = SSBREAKPOINT;
   unsigned curinstr;
   unsigned inst;
   struct uio uio;
   struct iovec iov;

   pc = PC_REGS(sstf);
   /*
    * User was stopped at pc, e.g. the instruction
    * at pc was not executed.
    * Fetch what's at the current location.
    */
   curinstr = ss_get_value(p, pc, sizeof(int));

   /* compute next address after current location */
   if (curinstr != 0) {
   	if (ss_inst_branch(curinstr) || inst_call(curinstr) || inst_return(curinstr)) {
   	    brpc = ss_branch_taken(curinstr, pc, ss_getreg_val, sstf);
   	    if (brpc != pc) {	/* self-branches are hopeless */
d1853 2
a1854 2
             printf("SS %s (%d): next taken breakpoint set at %x\n", 
                    p->p_comm, p->p_pid, brpc);
d1856 8
a1863 8
   		     p->p_md.md_ss_taken_addr = brpc;
   		     p->p_md.md_ss_taken_instr = ss_get_value(p, brpc, sizeof(int));
              /* Store breakpoint instruction at the "next" location now. */
              i = ss_put_value(p, brpc, bpinstr, sizeof(int));
              if (i < 0) return (EFAULT);
   	    }
   	}
   	pc = ss_next_instr_address(p, pc, 0);
d1865 2
a1866 2
      printf("SS %s (%d): next breakpoint set at %x\n", 
             p->p_comm, p->p_pid, pc);
d1868 2
a1869 2
   } else {
      pc = PC_REGS(sstf) + 4;
d1871 2
a1872 2
      printf("SS %s (%d): next breakpoint set at %x\n", 
             p->p_comm, p->p_pid, pc);
d1874 7
a1880 9
   }
   
   if (p->p_md.md_ss_addr) {
      printf("SS %s (%d): breakpoint already set at %x (va %x)\n",
             p->p_comm, p->p_pid, p->p_md.md_ss_addr, pc); /* XXX */
      return (EFAULT);
   }

   p->p_md.md_ss_addr = pc;
d1882 1
a1882 2
   /* Fetch what's at the "next" location. */
   p->p_md.md_ss_instr = ss_get_value(p, pc, sizeof(int));
d1884 2
a1885 2
   /* Store breakpoint instruction at the "next" location now. */
   i = ss_put_value(p, pc, bpinstr, sizeof(int));
d1887 5
a1891 2
   if (i < 0) return (EFAULT);
   return (0);
a1892 1

@


1.10
log
@Change the ktrace interface functions from taking the trace vnode to taking the
traced proc. The vnode is in the proc and all functions need the proc.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.9 2000/06/08 22:25:21 niklas Exp $	*/
d51 3
a53 1

d109 1
a109 1
   "Privileg Violation",
d231 3
d235 1
d384 3
d388 3
d466 3
a468 1

d470 1
d646 5
d706 3
d710 2
d879 1
d974 3
d978 1
d986 3
d990 1
d1044 3
d1048 1
d1056 3
d1060 1
d1203 5
d1290 3
d1294 1
d1450 3
d1454 1
@


1.9
log
@Add explicit inclusions of signalvar.h to files actually using syms defined
there but relying on an indirect inclusion
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.9 2000/06/08 21:12:05 niklas Exp $	*/
d1305 1
a1305 1
      ktrsyscall(p->p_tracep, code, callp->sy_argsize, args.i);
d1381 1
a1381 1
      ktrsysret(p->p_tracep, code, error, rval[0]);
d1461 1
a1461 1
      ktrsyscall(p->p_tracep, code, callp->sy_argsize, args.i);
d1533 1
a1533 1
      ktrsysret(p->p_tracep, code, error, rval[0]);
d1561 1
a1561 1
      ktrsysret(p->p_tracep, SYS_fork, 0, 0);
@


1.8
log
@Added to support MVME188 and MVME197
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.7 1999/05/29 04:41:47 smurph Exp $	*/
d53 1
@


1.8.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.15 2001/03/12 23:00:40 miod Exp $	*/
d51 1
a51 3
#if defined(UVM)
#include <uvm/uvm_extern.h>
#endif
a52 1
#include <sys/signalvar.h>
a55 1
#include <machine/bugio.h>		/* bugreturn() */
a61 1
#include <machine/locore.h>
a69 1
   #include <ddb/db_output.h>		/* db_printf()		*/
a98 3
extern int procfs_domem();
extern void regdump __P((struct trapframe *f));

d100 11
a110 11
	"Reset",
	"Interrupt Exception",
	"Instruction Access",
	"Data Access Exception",
	"Misaligned Access",
	"Unimplemented Opcode",
	"Privilege Violation"
	"Bounds Check Violation",
	"Illegal Integer Divide",
	"Integer Overflow",
	"Error Exception",
d114 8
a121 8
	"Success (No Fault)",
	"unknown 1",
	"unknown 2",
	"Bus Error",
	"Segment Fault",
	"Page Fault",
	"Supervisor Violation",
	"Write Violation",
d123 5
d134 2
a135 2
	int sig;
	int s;
d137 31
a167 29
	/* take pending signals */
	while ((sig = CURSIG(p)) != 0)
		postsig(sig);
	p->p_priority = p->p_usrpri;

	if (want_resched) {
		/*
		 * Since we are curproc, clock will normally just change
		 * our priority without moving us from one queue to another
		 * (since the running process is not on a queue.)
		 * If that happened after we put ourselves on the run queue
		 * but before we switched, we might not be on the queue
		 * indicated by our priority.
		 */
		s = splstatclock();
		setrunqueue(p);
		p->p_stats->p_ru.ru_nivcsw++;
		mi_switch();
		(void) splx(s);
		while ((sig = CURSIG(p)) != 0)
			postsig(sig);
	}

	/*
	 * If profiling, charge recent system time to the trapped pc.
	 */
	if (p->p_flag & P_PROFIL)
		addupc_task(p, frame->sxip & ~3,(int)(p->p_sticks - oticks));
	curpriority = p->p_priority;
d173 1
a173 1
	static int panicing = 0;
d175 17
a191 17
	if (panicing++ == 0) {
		if (type == 2) {  /* instruction exception */
			DEBUG_MSG("\nInstr access fault (%s) v = %x, frame %x\n",
				  pbus_exception_type[(frame->ipfsr >> 16) & 0x7],
				  frame->sxip & ~3, frame);
		} else if (type == 3) {	/* data access exception */
			DEBUG_MSG("\nData access fault (%s) v = %x, frame %x\n",
				  pbus_exception_type[(frame->dpfsr >> 16) & 0x7],
				  frame->sxip & ~3, frame);
		} else
			DEBUG_MSG("\ntrap type %d, v = %x, frame %x\n", type, frame->sxip & ~3, frame);
		regdump(frame);
	}
	if ((u_int)type < trap_types)
		panic(trap_type[type]);
	panic("trap");
	/*NOTREACHED*/
d194 1
a196 2
unsigned last_vector = 0;

d201 43
a243 45
	struct proc *p;
	u_quad_t sticks = 0;
	vm_map_t map;
	vm_offset_t va;
	vm_prot_t ftype;
	int fault_type;
	u_long fault_code;
	unsigned nss, fault_addr;
	struct vmspace *vm;
	union sigval sv;
	int result;
	int sig = 0;
	unsigned pc = PC_REGS(frame);  /* get program counter (sxip) */

	extern vm_map_t kernel_map;
	extern int fubail(), subail();
	extern unsigned guarded_access_start;
	extern unsigned guarded_access_end;
	extern unsigned guarded_access_bad;

	if (type != last_trap[3]) {
		last_trap[0] = last_trap[1];
		last_trap[1] = last_trap[2];
		last_trap[2] = last_trap[3];
		last_trap[3] = type;
	}
#if defined(UVM)
	uvmexp.traps++;
#else
	cnt.v_trap++;
#endif
	if ((p = curproc) == NULL)
		p = &proc0;

	if (USERMODE(frame->epsr)) {
		sticks = p->p_sticks;
		type += T_USER;
		p->p_md.md_tf = frame;	/* for ptrace/signals */
		fault_type = 0;
		fault_code = 0;
	}
	switch (type) {
	default:
		panictrap(frame->vector, frame);
		/*NOTREACHED*/
d246 35
a280 35
	case T_KDB_BREAK:
		/*FALLTHRU*/
	case T_KDB_BREAK+T_USER:
		{
			int s = db_splhigh();
			db_enable_interrupt();
			ddb_break_trap(T_KDB_BREAK,(db_regs_t*)frame);
			db_disable_interrupt();
			db_splx(s);
			return;
		}
	case T_KDB_ENTRY:
		/*FALLTHRU*/
	case T_KDB_ENTRY+T_USER:
		{
			int s = db_splhigh();
			db_enable_interrupt();
			ddb_entry_trap(T_KDB_ENTRY,(db_regs_t*)frame);
			db_disable_interrupt();
			db_splx(s);
			return;
		}

#if 0
	case T_ILLFLT:
		{
			int s = db_splhigh();
			db_enable_interrupt();
			ddb_error_trap(type == T_ILLFLT ? "unimplemented opcode" :
				       "error fault", (db_regs_t*)frame);
			db_disable_interrupt();
			db_splx(s);
			return;
		}
#endif /* 0 */
d282 271
a552 307
	case T_INT:
	case T_INT+T_USER:
		/* This function pointer is set in machdep.c 
		   It calls m188_ext_int or sbc_ext_int depending
		   on the value of cputyp - smurph */
		(*mdfp.interrupt_func)(T_INT, frame);
		return;

	case T_MISALGNFLT:
		DEBUG_MSG("kernel misaligned "
			  "access exception @@ 0x%08x\n", frame->sxip);
		panictrap(frame->vector, frame);
		break;

	case T_INSTFLT:
		/* kernel mode instruction access fault.
		 * Should never, never happen for a non-paged kernel.
		 */
		DEBUG_MSG("kernel mode instruction "
			  "page fault @@ 0x%08x\n", frame->sxip);
		panictrap(frame->vector, frame);
		break;

	case T_DATAFLT:
		/* kernel mode data fault */
		/*
		 * If the faulting address is in user space, handle it in
		 * the context of the user process. Else, use kernel map.
		 */

		if (type == T_DATAFLT) {
			fault_addr = frame->dma0;
			if (frame->dmt0 & (DMT_WRITE|DMT_LOCKBAR)) {
				ftype = VM_PROT_READ|VM_PROT_WRITE;
				fault_code = VM_PROT_WRITE;
			} else {
				ftype = VM_PROT_READ;
				fault_code = VM_PROT_READ;
			}
		} else {
			fault_addr = frame->sxip & XIP_ADDR;
			ftype = VM_PROT_READ;
			fault_code = VM_PROT_READ;
		}

		va = trunc_page((vm_offset_t)fault_addr);

		vm = p->p_vmspace;
		map = &vm->vm_map;

		/* data fault on a kernel address... */
		if (frame->dmt0 & DMT_DAS)
			map = kernel_map;

		/* 
		 * We don't want to call vm_fault() if it is fuwintr() or
		 * suwintr(). These routines are for copying from interrupt
		 * context and vm_fault() can potentially sleep. You may
		 * wonder if it isn't bad karma for an interrupt handler to	
		 * touch the current process. Indeed it is, but clock interrupt
		 * does it while doing profiling. It is OK in that context.
		 */

		if (p->p_addr->u_pcb.pcb_onfault == (int)fubail ||
		    p->p_addr->u_pcb.pcb_onfault == (int)subail)
			goto outtahere;

		/* data fault on the user address */
		if (type == T_DATAFLT && (frame->dmt0 & DMT_DAS) == 0) {
			type = T_DATAFLT + T_USER;
			goto user_fault;
		}
#if 0
		printf("\nKernel Data access fault #%d (%s) v = 0x%x, frame 0x%x cpu %d\n",
		       ((frame->dpfsr >> 16) & 0x7),
		       pbus_exception_type[(frame->dpfsr >> 16) & 0x7],
		       fault_addr, frame, frame->cpu);
#endif 
		/*
		 * If it is a guarded access, bus error is OK.
		 */
		if ((frame->dpfsr >> 16 & 0x7) == 0x3 &&     /* bus error */
		    (frame->sxip & ~3) >= (unsigned)&guarded_access_start &&
		    (frame->sxip & ~3) <= (unsigned)&guarded_access_end) {

			frame->snip = ((unsigned)&guarded_access_bad    ) | FIP_V;
			frame->sfip = ((unsigned)&guarded_access_bad + 4) | FIP_V;
			frame->sxip = 0;
			/* We sort of resolved the fault ourselves because 
			 * we know where it came from.  [gaurded_assess()]
			 * But we must still think about the other possible 
			 * transactions in dmt1 & dmt2.  Mark dmt0 so that 
			 * data_access_emulation skips it.  XXX smurph
			 */
			frame->dmt0 = DMT_SKIP;
			frame->dpfsr = 0;
                        data_access_emulation((unsigned *)frame);
                        /* so data_access_emulation doesn't get called again. */
			frame->dmt0 = 0;
			return;
		}
		/*
		 *	On a no fault, just return.
		 */
		if ((frame->dpfsr >> 16 & 0x7) == 0x0) {     /* no fault  */
			/*
			 * The fault was resolved. Call data_access_emulation 
			 * to drain the data unit pipe line and reset dmt0 
			 * so that trap won't get called again. 
			 * For inst faults, back up the pipe line.
			 */
				if (type == T_DATAFLT) {
					/*
					printf("calling data_access_emulation()\n");
					*/
					data_access_emulation((unsigned *)frame);
					frame->dmt0 = 0;
					frame->dpfsr = 0;
				} else {
					frame->sfip = frame->snip & ~FIP_E;
					frame->snip = frame->sxip & ~NIP_E;
				}
				return;
		}

		/*
		 *	On a segment or a page fault, call vm_fault() to resolve
		 *	the fault.
		 */
		if ((unsigned)map & 3) {
			printf("map is not word aligned! 0x%x\n", map);
			Debugger();
		}
		if ((frame->dpfsr >> 16 & 0x7) == 0x4	     /* seg fault  */
		    || (frame->dpfsr >> 16 & 0x7) == 0x5) {  /* page fault */
#if defined(UVM)
			result = uvm_fault(map, va, 0, ftype);
#else
			result = vm_fault(map, va, ftype, FALSE); 
#endif
			if (result == KERN_SUCCESS) {
			/*
			 * We could resolve the fault. Call
			 * data_access_emulation to drain the data unit pipe
			 * line and reset dmt0 so that trap won't get called
			 * again. For inst faults, back up the pipe line.
			 */
				if (type == T_DATAFLT) {
					/*
					printf("calling data_access_emulation()\n");
					*/
					data_access_emulation((unsigned *)frame);
					frame->dmt0 = 0;
					frame->dpfsr = 0;
				} else {
					frame->sfip = frame->snip & ~FIP_E;
					frame->snip = frame->sxip & ~NIP_E;
				}
				return;
			}
		}
		/*
		printf ("PBUS Fault %d (%s) va = 0x%x\n", ((frame->dpfsr >> 16) & 0x7), 
			pbus_exception_type[(frame->dpfsr >> 16) & 0x7], va);
		*/
		/*
		 * if still the fault is not resolved ...
		 */
		if (!p->p_addr->u_pcb.pcb_onfault)
			panictrap(frame->vector, frame);

outtahere:
		frame->snip = ((unsigned)p->p_addr->u_pcb.pcb_onfault    ) | FIP_V;
		frame->sfip = ((unsigned)p->p_addr->u_pcb.pcb_onfault + 4) | FIP_V;
		frame->sxip = 0;
		/* We sort of resolved the fault ourselves because 
		 * we know where it came from.  [fuwintr() or suwintr()]
		 * But we must still think about the other possible 
		 * transactions in dmt1 & dmt2.  Mark dmt0 so that 
		 * data_access_emulation skips it. XXX smurph
		 */
		frame->dmt0 = DMT_SKIP;
		frame->dpfsr = 0;
		data_access_emulation((unsigned *)frame);
		/* so data_access_emulation doesn't get called again. */
		frame->dmt0 = 0;
		return;
	case T_INSTFLT+T_USER:
		/* User mode instruction access fault */
		/* FALLTHRU */
	case T_DATAFLT+T_USER:
		user_fault:
		if (type == T_INSTFLT+T_USER) {
			fault_addr = frame->sxip & XIP_ADDR;
		} else {
			fault_addr = frame->dma0;
		}
#if 0
		printf("User Data access fault #%d (%s) v = 0x%x, frame 0x%x cpu %d\n",
		       ((frame->dpfsr >> 16) & 0x7),
		       pbus_exception_type[(frame->dpfsr >> 16) & 0x7],
		       fault_addr, frame, frame->cpu);
#endif 

		if (frame->dmt0 & (DMT_WRITE|DMT_LOCKBAR)) {
			ftype = VM_PROT_READ|VM_PROT_WRITE;
			fault_code = VM_PROT_WRITE;
		} else {
			ftype = VM_PROT_READ;
			fault_code = VM_PROT_READ;
		}

		va = trunc_page((vm_offset_t)fault_addr);

		vm = p->p_vmspace;
		map = &vm->vm_map;
		if ((unsigned)map & 3) {
			printf("map is not word aligned! 0x%x\n", map);
			Debugger();
		}
		/* Call vm_fault() to resolve non-bus error faults */
		if ((frame->ipfsr >> 16 & 0x7) != 0x3 &&
		    (frame->dpfsr >> 16 & 0x7) != 0x3) {
#if defined(UVM)
			result = uvm_fault(map, va, 0, ftype);
#else
			result = vm_fault(map, va, ftype, FALSE); 
#endif
			frame->ipfsr = frame->dpfsr = 0;
		}

		if ((caddr_t)va >= vm->vm_maxsaddr) {
			if (result == KERN_SUCCESS) {
				nss = clrnd(btoc(USRSTACK - va));/* XXX check this */
				if (nss > vm->vm_ssize)
					vm->vm_ssize = nss;
			} else if (result == KERN_PROTECTION_FAILURE)
				result = KERN_INVALID_ADDRESS;
		}

		if (result == KERN_SUCCESS) {
			if (type == T_DATAFLT+T_USER) {
			/*
			 * We could resolve the fault. Call
			 * data_access_emulation to drain the data unit
			 * pipe line and reset dmt0 so that trap won't
			 * get called again.
			 */
				data_access_emulation((unsigned *)frame);
				frame->dmt0 = 0;
				frame->dpfsr = 0;
			} else {
			/* back up SXIP, SNIP clearing the the Error bit */
				frame->sfip = frame->snip & ~FIP_E;
				frame->snip = frame->sxip & ~NIP_E;
			}
		} else {
			sig = result == KERN_PROTECTION_FAILURE ? 
				SIGBUS : SIGSEGV;
			fault_type = result == KERN_PROTECTION_FAILURE ? 
				BUS_ADRERR : SEGV_MAPERR;
		}
		break;
	case T_MISALGNFLT+T_USER:
		sig = SIGBUS;
		fault_type = BUS_ADRALN;
		break;
	case T_PRIVINFLT+T_USER:
	case T_ILLFLT+T_USER:
		sig = SIGILL;
		break;
	case T_BNDFLT+T_USER:
		sig = SIGFPE;
		break;
	case T_ZERODIV+T_USER:
		sig = SIGFPE;
		fault_type = FPE_INTDIV;
		break;
	case T_OVFFLT+T_USER:
		sig = SIGFPE;
		fault_type = FPE_INTOVF;
		break;
	case T_FPEPFLT+T_USER:
	case T_FPEIFLT+T_USER:
		sig = SIGFPE;
		break;
	case T_SIGTRAP+T_USER:
		sig = SIGTRAP;
		fault_type = TRAP_TRACE;
		break;
	case T_STEPBPT+T_USER:
		/*
		 * This trap is used by the kernel to support single-step
		 * debugging (although any user could generate this trap
		 * which should probably be handled differently). When a
		 * process is continued by a debugger with the PT_STEP
		 * function of ptrace (single step), the kernel inserts
		 * one or two breakpoints in the user process so that only
		 * one instruction (or two in the case of a delayed branch)
		 * is executed.  When this breakpoint is hit, we get the
		 * T_STEPBPT trap.
		 */
		{
			register unsigned va;
			unsigned instr;
			struct uio uio;
			struct iovec iov;
d554 2
a555 2
			/* compute address of break instruction */
			va = pc;
d557 2
a558 2
			/* read break instruction */
			instr = fuiword((caddr_t)pc);
d560 43
a602 43
			printf("trap: %s (%d) breakpoint %x at %x: (adr %x ins %x)\n",
			       p->p_comm, p->p_pid, instr, pc,
			       p->p_md.md_ss_addr, p->p_md.md_ss_instr); /* XXX */
#endif
			/* check and see if we got here by accident */
			if ((p->p_md.md_ss_addr != pc && 
			     p->p_md.md_ss_taken_addr != pc) ||
			    instr != SSBREAKPOINT) {
				sig = SIGTRAP;
				fault_type = TRAP_TRACE;
				break;
			}
			/* restore original instruction and clear BP  */
			instr = p->p_md.md_ss_instr;
			va = p->p_md.md_ss_addr;
			if (va != 0) {
				iov.iov_base = (caddr_t)&instr;
				iov.iov_len = sizeof(int); 
				uio.uio_iov = &iov;
				uio.uio_iovcnt = 1; 
				uio.uio_offset = (off_t)va;
				uio.uio_resid = sizeof(int);
				uio.uio_segflg = UIO_SYSSPACE;
				uio.uio_rw = UIO_WRITE;
				uio.uio_procp = curproc;
				procfs_domem(p, p, NULL, &uio);
			}

			/* branch taken instruction */
			instr = p->p_md.md_ss_taken_instr;
			va = p->p_md.md_ss_taken_addr;
			if (instr != 0) {
				iov.iov_base = (caddr_t)&instr;
				iov.iov_len = sizeof(int); 
				uio.uio_iov = &iov;
				uio.uio_iovcnt = 1; 
				uio.uio_offset = (off_t)va;
				uio.uio_resid = sizeof(int);
				uio.uio_segflg = UIO_SYSSPACE;
				uio.uio_rw = UIO_WRITE;
				uio.uio_procp = curproc;
				procfs_domem(p, p, NULL, &uio);
			}
d604 50
a653 55
			frame->sfip = frame->snip;    /* set up next FIP */
			frame->snip = pc;    /* set up next NIP */
			frame->snip |= 2;	  /* set valid bit   */
#endif
			p->p_md.md_ss_addr = 0;
			p->p_md.md_ss_instr = 0;
			p->p_md.md_ss_taken_addr = 0;
			p->p_md.md_ss_taken_instr = 0;
			sig = SIGTRAP;
			fault_type = TRAP_BRKPT;
		}
		break;

	case T_USERBPT+T_USER:
		/*
		 * This trap is meant to be used by debuggers to implement
		 * breakpoint debugging.  When we get this trap, we just
		 * return a signal which gets caught by the debugger.
		 */
		frame->sfip = frame->snip;    /* set up the next FIP */
		frame->snip = frame->sxip;    /* set up the next NIP */
		sig = SIGTRAP;
		fault_type = TRAP_BRKPT;
		break;

	case T_ASTFLT+T_USER:
#if defined(UVM)
		uvmexp.softs++;
#else
		cnt.v_soft++;
#endif
		want_ast = 0;
		if (p->p_flag & P_OWEUPC) {
			p->p_flag &= ~P_OWEUPC;
			ADDUPROF(p);
		}
		break;
	}

	/*
	 * If trap from supervisor mode, just return
	 */
	if (SYSTEMMODE(frame->epsr))
		return;

	if (sig) {
		sv.sival_int = fault_addr;
		trapsignal(p, sig, fault_code, fault_type, sv);
		/*		
		 * don't want multiple faults - we are going to
		 * deliver signal.
		 */
		frame->dmt0 = 0;
		frame->dpfsr = 0;
	}
d655 1
a655 1
	userret(p, frame, sticks);
d663 149
a811 154
	struct proc *p;
	u_quad_t sticks = 0;
	vm_map_t map;
	vm_offset_t va;
	vm_prot_t ftype;
	int fault_type;
	u_long fault_code;
	unsigned nss, fault_addr;
	struct vmspace *vm;
	union sigval sv;
	int su = 0;
	int result;
	int sig = 0;
	unsigned pc = PC_REGS(frame);  /* get program counter (sxip) */
	unsigned dsr, isr, user = 0, write = 0, data = 0;

	extern vm_map_t kernel_map;
	extern int fubail(), subail();
	extern unsigned guarded_access_start;
	extern unsigned guarded_access_end;
	extern unsigned guarded_access_bad;

#if defined(UVM)
	uvmexp.traps++;
#else
	cnt.v_trap++;
#endif

	if ((p = curproc) == NULL)
		p = &proc0;

	if (USERMODE(frame->epsr)) {
		sticks = p->p_sticks;
		type += T_USER;
		p->p_md.md_tf = frame;	/* for ptrace/signals */
		fault_type = 0;
		fault_code = 0;
	}
	printf("m197_trap 0x%x ", type);
	switch (type) {
	default:
		panictrap(frame->vector, frame);
		/*NOTREACHED*/
	case T_197_READ+T_USER:
		user = 1;
	case T_197_READ:
		va = (vm_offset_t) frame->dlar;
		/* if it was a user read, handle in context of the user */
		if ((frame->dsr & CMMU_DSR_SU) && !user) {
			map = kernel_map;
		} else {
			vm = p->p_vmspace;
			map = &vm->vm_map;
		}
		result = m197_table_search(map->pmap, va, CMMU_READ, user, CMMU_DATA);
		if (result) {
			switch (result) {
			case 4:	/* Seg Fault */
				frame->dsr |= CMMU_DSR_SI | CMMU_DSR_RW;
				break;
			case 5:	/* Page Fault */
				frame->dsr |= CMMU_DSR_PI | CMMU_DSR_RW;
				break;
			case 6:	/* Supervisor Violation */
				frame->dsr |= CMMU_DSR_SP | CMMU_DSR_RW;
				break;
			}
			/* table search failed and we are going to report a data fault */
			if (user) {
				type = T_DATAFLT+T_USER;
				goto m197_user_fault;
			} else {
				type = T_DATAFLT;
				goto m197_data_fault;
			}
		} else {
			return;	/* PATC sucessfully loaded */
		}
		break;      
	case T_197_WRITE+T_USER:
		user = 1;
	case T_197_WRITE:
		/* if it was a user read, handle in context of the user */
		if ((frame->dsr & CMMU_DSR_SU) && !user) {
			map = kernel_map;
		} else {
			vm = p->p_vmspace;
			map = &vm->vm_map;
		}
		va = (vm_offset_t) frame->dlar;
		result = m197_table_search(map->pmap, va, CMMU_WRITE, user, CMMU_DATA);
		if (result) {
			switch (result) {
			case 4:	/* Seg Fault */
				frame->dsr |= CMMU_DSR_SI;
				break;
			case 5:	/* Page Fault */
				frame->dsr |= CMMU_DSR_PI;
				break;
			case 6:	/* Supervisor Violation */
				frame->dsr |= CMMU_DSR_SP;
				break;
			case 7:	/* Write Violation */
				frame->dsr |= CMMU_DSR_WE;
				break;
			}
			/* table search failed and we are going to report a data fault */
			if (user) {
				type = T_DATAFLT+T_USER;
				goto m197_user_fault;
			} else {
				type = T_DATAFLT;
				goto m197_data_fault;
			}
		} else {
			return;	/* PATC sucessfully loaded */
		}
		break;      
	case T_197_INST+T_USER:
		user = 1;
	case T_197_INST:
		/* if it was a user read, handle in context of the user */
		if ((frame->isr & CMMU_ISR_SU) && !user) {
			map = kernel_map;
		} else {
			vm = p->p_vmspace;
			map = &vm->vm_map;
		}
		va = (vm_offset_t) frame->sxip;
		result = m197_table_search(map->pmap, va, CMMU_READ, user, CMMU_INST);
		if (result) {
			switch (result) {
			case 4:	/* Seg Fault */
				frame->isr |= CMMU_ISR_SI;
				break;
			case 5:	/* Page Fault */
				frame->isr |= CMMU_ISR_PI;
				break;
			case 6:	/* Supervisor Violation */
				frame->isr |= CMMU_ISR_SP;
				break;
			}
			/* table search failed and we are going to report a data fault */
			if (user) {
				type = T_INSTFLT+T_USER;
				goto m197_user_fault;
			} else {
				type = T_INSTFLT;
				goto m197_inst_fault;
			}
		} else {
			return;	/* PATC sucessfully loaded */
		}
		break;      
d813 371
a1183 371
	case T_KDB_BREAK:
		/*FALLTHRU*/
	case T_KDB_BREAK+T_USER:
		{
			int s = db_splhigh();
			db_enable_interrupt();
			ddb_break_trap(T_KDB_BREAK,(db_regs_t*)frame);
			db_disable_interrupt();
			db_splx(s);
			return;
		}
	case T_KDB_ENTRY:
		/*FALLTHRU*/
	case T_KDB_ENTRY+T_USER:
		{
			int s = db_splhigh();
			db_enable_interrupt();
			ddb_entry_trap(T_KDB_ENTRY,(db_regs_t*)frame);
			db_disable_interrupt();
			db_splx(s);
			return;
		}

#if 0
	case T_ILLFLT:
		{
			int s = db_splhigh();
			db_enable_interrupt();
			ddb_error_trap(type == T_ILLFLT ? "unimplemented opcode" :
				       "error fault", (db_regs_t*)frame);
			db_disable_interrupt();
			db_splx(s);
			return;
		}
#endif /* 0 */
#endif /* DDB */
	case T_ILLFLT:
		DEBUG_MSG("test trap "
			  "page fault @@ 0x%08x\n", frame->sxip);
		panictrap(frame->vector, frame);
		break;

	case T_MISALGNFLT:
		DEBUG_MSG("kernel misaligned "
			  "access exception @@ 0x%08x\n", frame->sxip);
		panictrap(frame->vector, frame);
		break;

	case T_INSTFLT:
		m197_inst_fault:
		/* kernel mode instruction access fault.
		 * Should never, never happen for a non-paged kernel.
		 */
		DEBUG_MSG("kernel mode instruction "
			  "page fault @@ 0x%08x\n", frame->sxip);
		panictrap(frame->vector, frame);
		break;

	case T_DATAFLT:
		/* kernel mode data fault */
		/*
		 * If the faulting address is in user space, handle it in
		 * the context of the user process. Else, use kernel map.
		 */
		m197_data_fault:
		if (type == T_DATAFLT) {
			fault_addr = frame->dlar;
			if (frame->dsr & CMMU_DSR_RW) {
				ftype = VM_PROT_READ;
				fault_code = VM_PROT_READ;
			} else {
				ftype = VM_PROT_READ|VM_PROT_WRITE;
				fault_code = VM_PROT_WRITE;
				write = 1;
			}
			data = 1;
		} else {
			fault_addr = frame->sxip & XIP_ADDR;
			ftype = VM_PROT_READ;
			fault_code = VM_PROT_READ;
		}

		va = trunc_page((vm_offset_t)fault_addr);
		vm = p->p_vmspace;
		map = &vm->vm_map;

		/* data fault on a kernel address... */
		if (type == T_DATAFLT) {
			if (frame->dsr & CMMU_DSR_SU) {
				map = kernel_map;
			}
		}

		/* 
		 * We don't want to call vm_fault() if it is fuwintr() or
		 * suwintr(). These routines are for copying from interrupt
		 * context and vm_fault() can potentially sleep. You may
		 * wonder if it isn't bad karma for an interrupt handler to	
		 * touch the current process. Indeed it is, but clock interrupt
		 * does it while doing profiling. It is OK in that context.
		 */

		if (p->p_addr->u_pcb.pcb_onfault == (int)fubail ||
		    p->p_addr->u_pcb.pcb_onfault == (int)subail)
			goto m197_outtahere;

		/* data fault on the user address */
		if (type == T_DATAFLT && (frame->dsr & CMMU_DSR_SU) == 0) {
			type = T_DATAFLT + T_USER;
			goto m197_user_fault;
		}

		/*
		 *	If it is a guarded access, bus error is OK.
		 */

		if ((frame->dsr & CMMU_DSR_BE) &&     /* bus error */
		    (frame->sxip & ~3) >= (unsigned)&guarded_access_start &&
		    (frame->sxip & ~3) <= (unsigned)&guarded_access_end) {
			return;
		}

		/*
		 *	On a segment or a page fault, call vm_fault() to resolve
		 *	the fault.
		 */
		result = m197_table_search(map->pmap, va, write, 1, data);
#ifdef todo         
		switch (result) {
		case :
		}
#endif
		if (type == T_DATAFLT) {
			if ((frame->dsr & CMMU_DSR_SI)	      /* seg fault  */
			    || (frame->dsr & CMMU_DSR_PI)) { /* page fault */
#if defined(UVM)
				result = uvm_fault(map, va, 0, ftype);
#else
				result = vm_fault(map, va, ftype, FALSE); 
#endif
				if (result == KERN_SUCCESS) {
					return;
				}
			}
		} else {
			if ((frame->isr & CMMU_ISR_SI)	      /* seg fault  */
			    || (frame->isr & CMMU_ISR_PI)) { /* page fault */
#if defined(UVM)
				result = uvm_fault(map, va, 0, ftype);
#else
				result = vm_fault(map, va, ftype, FALSE); 
#endif
				if (result == KERN_SUCCESS) {
					return;
				}
			}
		}
		/*
		 * if still the fault is not resolved ...
		 */
		if (!p->p_addr->u_pcb.pcb_onfault)
			panictrap(frame->vector, frame);

		m197_outtahere:
		frame->sxip = ((unsigned)p->p_addr->u_pcb.pcb_onfault);
		return;
	case T_INSTFLT+T_USER:
		/* User mode instruction access fault */
		/*FALLTHRU*/
	case T_DATAFLT+T_USER:
		m197_user_fault:
		if (type == T_INSTFLT+T_USER) {
			fault_addr = frame->sxip & XIP_ADDR;
			ftype = VM_PROT_READ;
			fault_code = VM_PROT_READ;
		} else {
			fault_addr = frame->dlar;
			if (frame->dsr & CMMU_DSR_RW) {
				ftype = VM_PROT_READ;
				fault_code = VM_PROT_READ;
			} else {
				ftype = VM_PROT_READ|VM_PROT_WRITE;
				fault_code = VM_PROT_WRITE;
			}
		}

		va = trunc_page((vm_offset_t)fault_addr);

		vm = p->p_vmspace;
		map = &vm->vm_map;


		/* Call vm_fault() to resolve non-bus error faults */
		if (type == T_DATAFLT+T_USER) {
			if ((frame->dsr & CMMU_DSR_SI)	      /* seg fault  */
			    || (frame->dsr & CMMU_DSR_PI)) { /* page fault */
#if defined(UVM)
				result = uvm_fault(map, va, 0, ftype);
#else
				result = vm_fault(map, va, ftype, FALSE); 
#endif
				if (result == KERN_SUCCESS) {
					return;
				}
			}
		} else {
			if ((frame->isr & CMMU_ISR_SI)	      /* seg fault  */
			    || (frame->isr & CMMU_ISR_PI)) { /* page fault */
#if defined(UVM)
				result = uvm_fault(map, va, 0, ftype);
#else
				result = vm_fault(map, va, ftype, FALSE); 
#endif
				if (result == KERN_SUCCESS) {
					return;
				}
			}
		}

		if ((caddr_t)va >= vm->vm_maxsaddr) {
			if (result == KERN_SUCCESS) {
				nss = clrnd(btoc(USRSTACK - va));/* XXX check this */
				if (nss > vm->vm_ssize)
					vm->vm_ssize = nss;
			} else if (result == KERN_PROTECTION_FAILURE)
				result = KERN_INVALID_ADDRESS;
		}

		if (result != KERN_SUCCESS) {
			sig = result == KERN_PROTECTION_FAILURE ? SIGBUS : SIGSEGV;
			fault_type = result == KERN_PROTECTION_FAILURE ? BUS_ADRERR
				     : SEGV_MAPERR;
		} else {
			return;
		}
		break;
	case T_MISALGNFLT+T_USER:
		sig = SIGBUS;
		fault_type = BUS_ADRALN;
		break;
	case T_PRIVINFLT+T_USER:
	case T_ILLFLT+T_USER:
		sig = SIGILL;
		break;
	case T_BNDFLT+T_USER:
		sig = SIGFPE;
		break;
	case T_ZERODIV+T_USER:
		sig = SIGFPE;
		fault_type = FPE_INTDIV;
		break;
	case T_OVFFLT+T_USER:
		sig = SIGFPE;
		fault_type = FPE_INTOVF;
		break;
	case T_FPEPFLT+T_USER:
	case T_FPEIFLT+T_USER:
		sig = SIGFPE;
		break;
	case T_SIGTRAP+T_USER:
		sig = SIGTRAP;
		fault_type = TRAP_TRACE;
		break;
	case T_STEPBPT+T_USER:
		/*
		 * This trap is used by the kernel to support single-step
		 * debugging (although any user could generate this trap
		 * which should probably be handled differently). When a
		 * process is continued by a debugger with the PT_STEP
		 * function of ptrace (single step), the kernel inserts
		 * one or two breakpoints in the user process so that only
		 * one instruction (or two in the case of a delayed branch)
		 * is executed.  When this breakpoint is hit, we get the
		 * T_STEPBPT trap.
		 */
#if 0
		frame->sfip = frame->snip;    /* set up next FIP */
		frame->snip = frame->sxip;    /* set up next NIP */
		break;
#endif
		{
			register unsigned va;
			unsigned instr;
			struct uio uio;
			struct iovec iov;

			/* compute address of break instruction */
			va = pc;

			/* read break instruction */
			instr = fuiword((caddr_t)pc);
#if 1
			printf("trap: %s (%d) breakpoint %x at %x: (adr %x ins %x)\n",
			       p->p_comm, p->p_pid, instr, pc,
			       p->p_md.md_ss_addr, p->p_md.md_ss_instr); /* XXX */
#endif
			/* check and see if we got here by accident */
#ifdef notyet
			if (p->p_md.md_ss_addr != pc || instr != SSBREAKPOINT) {
				sig = SIGTRAP;
				fault_type = TRAP_TRACE;
				break;
			}
#endif 
			/* restore original instruction and clear BP  */
			/*sig = suiword((caddr_t)pc, p->p_md.md_ss_instr);*/
			instr = p->p_md.md_ss_instr;
			if (instr == 0) {
				printf("Warning: can't restore instruction at %x: %x\n",
				       p->p_md.md_ss_addr, p->p_md.md_ss_instr);
			} else {
				iov.iov_base = (caddr_t)&instr;
				iov.iov_len = sizeof(int); 
				uio.uio_iov = &iov;
				uio.uio_iovcnt = 1; 
				uio.uio_offset = (off_t)pc;
				uio.uio_resid = sizeof(int);
				uio.uio_segflg = UIO_SYSSPACE;
				uio.uio_rw = UIO_WRITE;
				uio.uio_procp = curproc;
			}

			frame->sfip = frame->snip;    /* set up next FIP */
			frame->snip = frame->sxip;    /* set up next NIP */
			frame->snip |= 2;	  /* set valid bit   */
			p->p_md.md_ss_addr = 0;
			sig = SIGTRAP;
			fault_type = TRAP_BRKPT;
			break;
		}
	case T_USERBPT+T_USER:
		/*
		 * This trap is meant to be used by debuggers to implement
		 * breakpoint debugging.  When we get this trap, we just
		 * return a signal which gets caught by the debugger.
		 */
		frame->sfip = frame->snip;    /* set up the next FIP */
		frame->snip = frame->sxip;    /* set up the next NIP */
		sig = SIGTRAP;
		fault_type = TRAP_BRKPT;
		break;

	case T_ASTFLT+T_USER:
#if defined(UVM)
		uvmexp.softs++;
#else
		cnt.v_soft++;
#endif
		want_ast = 0;
		if (p->p_flag & P_OWEUPC) {
			p->p_flag &= ~P_OWEUPC;
			ADDUPROF(p);
		}
		break;
	}
	/*
	 * If trap from supervisor mode, just return
	 */
	if (SYSTEMMODE(frame->epsr))
		return;

	if (sig) {
		sv.sival_int = fault_addr;
		trapsignal(p, sig, fault_code, fault_type, sv);
		/*		
		 * don't want multiple faults - we are going to
		 * deliver signal.
		 */
		frame->dsr = 0;
	}
	userret(p, frame, sticks);
d1185 1
a1185 1

d1189 2
a1190 2
	DEBUG_MSG("\n[test_trap (Good News[tm]) m197 = %d, vec = %d]\n", m197, num);
	bugreturn();
a1191 1
#endif /* MVME197 */
d1196 3
a1198 3
	DEBUG_MSG("\n[test_trap (Good News[tm]) frame 0x%08x]\n", frame);
	regdump((struct trapframe*)frame);
	bugreturn();
a1199 1

d1203 3
a1205 9
	DEBUG_MSG("\n[ERROR EXCEPTION (Bad News[tm]) frame 0x%08x]\n", frame);
	DEBUG_MSG("This is usually an exception within an exception.  The trap\n");
	DEBUG_MSG("frame shadow registers you are about to see are invalid.\n");
	DEBUG_MSG("(read totaly useless)  But R1 to R31 might be interesting.\n");
	regdump((struct trapframe*)frame);
#if defined(MVME187) || defined(MVME188)
	DEBUG_MSG("trap trace %d -> %d -> %d -> %d  ", last_trap[0], last_trap[1], last_trap[2], last_trap[3]);
	DEBUG_MSG("last exception vector = %d\n", last_vector);
#endif 
d1207 3
a1209 3
	gimmeabreak();
	DEBUG_MSG("You really can't restart after an error exception!\n");
	gimmeabreak();
d1211 1
a1211 1
	bugreturn();  /* This gets us to Bug instead of a loop forever */
d1217 4
a1220 3
	DEBUG_MSG("\n[RESET EXCEPTION (Really Bad News[tm]) frame 0x%08x]\n", frame);
	DEBUG_MSG("This is usually caused by a branch to a NULL function pointer.\n");
	DEBUG_MSG("e.g. jump to address 0.  Use the debugger trace command to track it down.\n");
d1222 3
a1224 3
	gimmeabreak();
	DEBUG_MSG("It's useless to restart after a reset exception! You might as well reboot.\n");
	gimmeabreak();
d1226 1
a1226 1
	bugreturn();  /* This gets us to Bug instead of a loop forever */
a1228 1
void
d1231 10
a1240 10
	register int i, nsys, *ap, nap;
	register struct sysent *callp;
	register struct proc *p;
	int error;
	struct args {
		int i[8];
	} args;
	int rval[2];
	u_quad_t sticks;
	extern struct pcb *curpcb;
d1242 1
a1242 5
#if defined(UVM)
	uvmexp.syscalls++;
#else
	cnt.v_syscall++;
#endif
d1244 1
a1244 1
	p = curproc;
d1246 2
a1247 2
	callp = p->p_emul->e_sysent;
	nsys  = p->p_emul->e_nsysent;
d1250 49
a1298 49
	if (USERMODE(tf->epsr) == 0)
		panic("syscall");
	if (curpcb != &p->p_addr->u_pcb)
		panic("syscall curpcb/ppcb");
	if (tf != (struct trapframe *)&curpcb->user_state)
		panic("syscall trapframe");
#endif

	sticks = p->p_sticks;
	p->p_md.md_tf = tf;

	/*
	 * For 88k, all the arguments are passed in the registers (r2-r12)
	 * For syscall (and __syscall), r2 (and r3) has the actual code.
	 * __syscall  takes a quad syscall number, so that other
	 * arguments are at their natural alignments.
	 */
	ap = &tf->r[2];
	nap = 6;

	switch (code) {
	case SYS_syscall:
		code = *ap++;
		nap--;
		break;
	case SYS___syscall:
		if (callp != sysent)
			break;
		code = ap[_QUAD_LOWWORD];
		ap += 2;
		nap -= 2;
		break;
	}

	/* Callp currently points to syscall, which returns ENOSYS. */

	if (code < 0 || code >= nsys)
		callp += p->p_emul->e_nosys;
	else {
		callp += code;
		i = callp->sy_argsize / sizeof(register_t);
		if (i > 8)
			panic("syscall nargs");
		/*
		 * just copy them; syscall stub made sure all the
		 * args are moved from user stack to registers.
		 */
		bcopy((caddr_t)ap, (caddr_t)args.i, i * sizeof(register_t));
	}
d1300 1
a1300 1
	scdebug_call(p, code, args.i);
d1303 2
a1304 2
	if (KTRPOINT(p, KTR_SYSCALL))
		ktrsyscall(p, code, callp->sy_argsize, args.i);
d1306 68
a1373 68
	rval[0] = 0;
	rval[1] = 0;
	error = (*callp->sy_call)(p, &args, rval);
	/*
	 * system call will look like:
	 *	 ld r10, r31, 32; r10,r11,r12 might be garbage.
	 *	 ld r11, r31, 36
	 *	 ld r12, r31, 40
	 *	 or r13, r0, <code>
	 *       tb0 0, r0, <128> <- xip
	 *	 br err 	  <- nip
	 *       jmp r1 	  <- fip
	 *  err: or.u r3, r0, hi16(errno)
	 *	 st r2, r3, lo16(errno)
	 *	 subu r2, r0, 1 
	 *	 jmp r1
	 *
	 * So, when we take syscall trap, sxip/snip/sfip will be as
	 * shown above.
	 * Given this,
	 * 1. If the system call returned 0, need to skip nip.
	 *	nip = fip, fip += 4
	 *    (doesn't matter what fip + 4 will be but we will never
	 *    execute this since jmp r1 at nip will change the execution flow.)
	 * 2. If the system call returned an errno > 0, plug the value
	 *    in r2, and leave nip and fip unchanged. This will have us
	 *    executing "br err" on return to user space.
	 * 3. If the system call code returned ERESTART,
	 *    we need to rexecute the trap instruction. Back up the pipe
	 *    line.
	 *     fip = nip, nip = xip
	 * 4. If the system call returned EJUSTRETURN, don't need to adjust
	 *    any pointers.
	 */

	if (error == 0) {
		/*
		 * If fork succeeded and we are the child, our stack
		 * has moved and the pointer tf is no longer valid,
		 * and p is wrong.  Compute the new trapframe pointer.
		 * (The trap frame invariably resides at the
		 * tippity-top of the u. area.)
		 */
		p = curproc;
		tf = USER_REGS(p);
		tf->r[2] = rval[0];
		tf->r[3] = rval[1];
		tf->epsr &= ~PSR_C;
		tf->snip = tf->sfip & ~FIP_E;
		tf->sfip = tf->snip + 4;
	} else if (error > 0) {
		/* error != ERESTART && error != EJUSTRETURN*/
		tf->r[2] = error;
		tf->epsr |= PSR_C;   /* fail */
		tf->snip = tf->snip & ~NIP_E;
		tf->sfip = tf->sfip & ~FIP_E;
	} else if (error == ERESTART) {
		/*
		 * If (error == ERESTART), back up the pipe line. This
		 * will end up reexecuting the trap.
		 */
		tf->epsr &= ~PSR_C;
		tf->sfip = tf->snip & ~NIP_E;
		tf->snip = tf->sxip & ~NIP_E;
	} else {
		/* if (error == EJUSTRETURN), leave the ip's alone */
		tf->epsr &= ~PSR_C;
	}
d1375 1
a1375 1
	scdebug_ret(p, code, error, rval);
d1377 1
a1377 1
	userret(p, tf, sticks);
d1379 2
a1380 2
	if (KTRPOINT(p, KTR_SYSRET))
		ktrsysret(p, code, error, rval[0]);
a1383 1
#ifdef MVME197
a1384 1
void
d1387 10
a1396 10
	register int i, nsys, *ap, nap;
	register struct sysent *callp;
	register struct proc *p;
	int error;
	struct args {
		int i[8];
	} args;
	int rval[2];
	u_quad_t sticks;
	extern struct pcb *curpcb;
d1398 1
a1398 5
#if defined(UVM)
	uvmexp.syscalls++;
#else
	cnt.v_syscall++;
#endif
d1400 1
a1400 1
	p = curproc;
d1402 2
a1403 2
	callp = p->p_emul->e_sysent;
	nsys  = p->p_emul->e_nsysent;
d1406 49
a1454 49
	if (USERMODE(tf->epsr) == 0)
		panic("syscall");
	if (curpcb != &p->p_addr->u_pcb)
		panic("syscall curpcb/ppcb");
	if (tf != (struct trapframe *)&curpcb->user_state)
		panic("syscall trapframe");
#endif

	sticks = p->p_sticks;
	p->p_md.md_tf = tf;

	/*
	 * For 88k, all the arguments are passed in the registers (r2-r12)
	 * For syscall (and __syscall), r2 (and r3) has the actual code.
	 * __syscall  takes a quad syscall number, so that other
	 * arguments are at their natural alignments.
	 */
	ap = &tf->r[2];
	nap = 6;

	switch (code) {
	case SYS_syscall:
		code = *ap++;
		nap--;
		break;
	case SYS___syscall:
		if (callp != sysent)
			break;
		code = ap[_QUAD_LOWWORD];
		ap += 2;
		nap -= 2;
		break;
	}

	/* Callp currently points to syscall, which returns ENOSYS. */

	if (code < 0 || code >= nsys)
		callp += p->p_emul->e_nosys;
	else {
		callp += code;
		i = callp->sy_argsize / sizeof(register_t);
		if (i > 8)
			panic("syscall nargs");
		/*
		 * just copy them; syscall stub made sure all the
		 * args are moved from user stack to registers.
		 */
		bcopy((caddr_t)ap, (caddr_t)args.i, i * sizeof(register_t));
	}
d1456 1
a1456 1
	scdebug_call(p, code, args.i);
d1459 2
a1460 2
	if (KTRPOINT(p, KTR_SYSCALL))
		ktrsyscall(p, code, callp->sy_argsize, args.i);
d1462 64
a1525 64
	rval[0] = 0;
	rval[1] = 0;
	error = (*callp->sy_call)(p, &args, rval);
	/*
	 * system call will look like:
	 *	 ld r10, r31, 32; r10,r11,r12 might be garbage.
	 *	 ld r11, r31, 36
	 *	 ld r12, r31, 40
	 *	 or r13, r0, <code>
	 *       tb0 0, r0, <128> <- sxip
	 *	 br err 	  <- snip
	 *       jmp r1
	 *  err: or.u r3, r0, hi16(errno)
	 *	 st r2, r3, lo16(errno)
	 *	 subu r2, r0, 1 
	 *	 jmp r1
	 *
	 * So, when we take syscall trap, sxip/snip will be as
	 * shown above.
	 * Given this,
	 * 1. If the system call returned 0, need to jmp r1.
	 *	   sxip += 8
	 * 2. If the system call returned an errno > 0, increment 
	 *    sxip += 4 and plug the value in r2. This will have us
	 *    executing "br err" on return to user space.
	 * 3. If the system call code returned ERESTART,
	 *    we need to rexecute the trap instruction. leave xip as is.
	 * 4. If the system call returned EJUSTRETURN, just return.
	 *    sxip += 8
	 */

	if (error == 0) {
		/*
		 * If fork succeeded and we are the child, our stack
		 * has moved and the pointer tf is no longer valid,
		 * and p is wrong.  Compute the new trapframe pointer.
		 * (The trap frame invariably resides at the
		 * tippity-top of the u. area.)
		 */
		p = curproc;
		tf = USER_REGS(p);
		tf->r[2] = rval[0];
		tf->r[3] = rval[1];
		tf->epsr &= ~PSR_C;
		tf->sxip += 8;
		tf->sxip &= ~3;
	} else if (error > 0) {
		/* error != ERESTART && error != EJUSTRETURN*/
		tf->r[2] = error;
		tf->epsr |= PSR_C;   /* fail */
		tf->sxip += 4;
		tf->sxip &= ~3;
	} else if (error == ERESTART) {
		/*
		 * If (error == ERESTART), back up the pipe line. This
		 * will end up reexecuting the trap.
		 */
		tf->epsr &= ~PSR_C;
	} else {
		/* if (error == EJUSTRETURN) */
		tf->epsr &= ~PSR_C;
		tf->sxip += 8; 
		tf->sxip &= ~3;
	}
d1527 1
a1527 1
	scdebug_ret(p, code, error, rval);
d1529 1
a1529 1
	userret(p, tf, sticks);
d1531 2
a1532 2
	if (KTRPOINT(p, KTR_SYSRET))
		ktrsysret(p, code, error, rval[0]);
a1534 1
#endif	/* MVME197 */
d1543 1
a1543 1
	struct trapframe *tf;
d1545 11
a1555 11
	tf = USER_REGS(p);
	tf->r[2] = 0;
	tf->r[3] = 0;
	tf->epsr &= ~PSR_C;
	if (cputyp != CPU_197) {
		tf->snip = tf->sfip & ~3;
		tf->sfip = tf->snip + 4;
	} else {
		tf->sxip += 8;
		tf->sxip &= ~3;
	}
d1557 1
a1557 1
	userret(p, tf, p->p_sticks);
d1559 2
a1560 2
	if (KTRPOINT(p, KTR_SYSRET))
		ktrsysret(p, SYS_fork, 0, 0);
d1564 29
d1600 15
a1614 15
	struct uio uio;
	struct iovec iov;
	unsigned value;

	iov.iov_base = (caddr_t)&value;
	iov.iov_len = size; 
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1; 
	uio.uio_offset = (off_t)addr;
	uio.uio_resid = size;
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_READ;
	uio.uio_procp = curproc;
	procfs_domem(curproc, p, NULL, &uio);
	return value;
d1620 15
a1634 15
	struct uio uio;
	struct iovec iov;
	int i;

	iov.iov_base = (caddr_t)&value;
	iov.iov_len = size; 
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1; 
	uio.uio_offset = (off_t)addr;
	uio.uio_resid = size;
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_WRITE;
	uio.uio_procp = curproc;
	i = procfs_domem(curproc, p, NULL, &uio);
	return i;
d1650 5
a1654 33
	       unsigned inst,
	       unsigned pc,
	       unsigned (*func)(unsigned int, struct trapframe *),
	       struct trapframe *func_data)  /* 'opaque' */
{

	/* check if br/bsr */
	if ((inst & 0xf0000000U) == 0xc0000000U) {
		/* signed 26 bit pc relative displacement, shift left two bits */
		inst = (inst & 0x03ffffffU)<<2;
		/* check if sign extension is needed */
		if (inst & 0x08000000U)
			inst |= 0xf0000000U;
		return pc + inst;
	}

	/* check if bb0/bb1/bcnd case */
	switch ((inst & 0xf8000000U)) {
	case 0xd0000000U: /* bb0 */
	case 0xd8000000U: /* bb1 */
	case 0xe8000000U: /* bcnd */
		/* signed 16 bit pc relative displacement, shift left two bits */
		inst = (inst & 0x0000ffffU)<<2;
		/* check if sign extension is needed */
		if (inst & 0x00020000U)
			inst |= 0xfffc0000U;
		return pc + inst;
	}

	/* check jmp/jsr case */
	/* check bits 5-31, skipping 10 & 11 */
	if ((inst & 0xfffff3e0U) == 0xf400c000U)
		return (*func)(inst & 0x1f, func_data);	 /* the register value */
d1656 29
a1684 1
	return 0; /* keeps compiler happy */
d1695 8
a1702 8
	if (regno == 0)
		return 0;
	else if (regno < 31)
		return tf->r[regno];
	else {
		panic("bad register number to ss_getreg_val.");
		return 0;/*to make compiler happy */
	}
d1705 1
a1705 1
int
d1708 14
a1721 1
	/* check high five bits */
d1723 2
a1724 11
	switch (ins >> (32-5)) {
	case 0x18: /* br */
	case 0x1a: /* bb0 */
	case 0x1b: /* bb1 */
	case 0x1d: /* bcnd */
		return TRUE;
		break;
	case 0x1e: /* could be jmp */
		if ((ins & 0xfffffbe0U) == 0xf400c000U)
			return TRUE;
	}
a1725 2
	return FALSE;
}
d1730 1
a1730 1
int
d1733 14
a1746 13
	/* check the br, bsr, bb0, bb1, bcnd cases */
	switch ((ins & 0xfc000000U)>>(32-6)) {
	case 0x31: /* br */
	case 0x33: /* bsr */
	case 0x35: /* bb0 */
	case 0x37: /* bb1 */
	case 0x3b: /* bcnd */
		return TRUE;
	}

	/* check the jmp, jsr cases */
	/* mask out bits 0-4, bit 11 */
	return ((ins & 0xfffff7e0U) == 0xf400c400U) ? TRUE : FALSE;
d1752 9
a1760 8
	if (delay_slot == 0)
		return pc + 4;
	else {
		if (ss_inst_delayed(ss_get_value(p, pc, sizeof(int))))
			return pc + 4;
		else
			return pc;
	}
d1767 23
a1789 19
	struct trapframe *sstf = USER_REGS(p); /*p->p_md.md_tf;*/
	unsigned pc, brpc;
	int i;
	int bpinstr = SSBREAKPOINT;
	unsigned curinstr;

	pc = PC_REGS(sstf);
	/*
	 * User was stopped at pc, e.g. the instruction
	 * at pc was not executed.
	 * Fetch what's at the current location.
	 */
	curinstr = ss_get_value(p, pc, sizeof(int));

	/* compute next address after current location */
	if (curinstr != 0) {
		if (ss_inst_branch(curinstr) || inst_call(curinstr) || inst_return(curinstr)) {
			brpc = ss_branch_taken(curinstr, pc, ss_getreg_val, sstf);
			if (brpc != pc) {   /* self-branches are hopeless */
d1791 2
a1792 2
				printf("SS %s (%d): next taken breakpoint set at %x\n", 
				       p->p_comm, p->p_pid, brpc);
d1794 8
a1801 8
				p->p_md.md_ss_taken_addr = brpc;
				p->p_md.md_ss_taken_instr = ss_get_value(p, brpc, sizeof(int));
				/* Store breakpoint instruction at the "next" location now. */
				i = ss_put_value(p, brpc, bpinstr, sizeof(int));
				if (i < 0) return (EFAULT);
			}
		}
		pc = ss_next_instr_address(p, pc, 0);
d1803 2
a1804 2
		printf("SS %s (%d): next breakpoint set at %x\n", 
		       p->p_comm, p->p_pid, pc);
d1806 2
a1807 2
	} else {
		pc = PC_REGS(sstf) + 4;
d1809 2
a1810 2
		printf("SS %s (%d): next breakpoint set at %x\n", 
		       p->p_comm, p->p_pid, pc);
d1812 9
a1820 1
	}
d1822 2
a1823 5
	if (p->p_md.md_ss_addr) {
		printf("SS %s (%d): breakpoint already set at %x (va %x)\n",
		       p->p_comm, p->p_pid, p->p_md.md_ss_addr, pc); /* XXX */
		return (EFAULT);
	}
d1825 2
a1826 1
	p->p_md.md_ss_addr = pc;
d1828 3
a1830 2
	/* Fetch what's at the "next" location. */
	p->p_md.md_ss_instr = ss_get_value(p, pc, sizeof(int));
a1831 6
	/* Store breakpoint instruction at the "next" location now. */
	i = ss_put_value(p, pc, bpinstr, sizeof(int));

	if (i < 0) return (EFAULT);
	return (0);
}
@


1.8.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.8.4.1 2001/04/18 16:11:40 niklas Exp $	*/
d51 1
d53 1
d230 1
d232 3
d422 1
d424 3
d510 1
d512 3
d520 1
a520 1
				nss = btoc(USRSTACK - va);/* XXX check this */
d671 1
d673 3
d731 1
d733 3
d999 1
d1001 3
d1011 1
d1013 3
d1060 1
d1062 3
d1072 1
d1074 3
d1085 1
a1085 1
				nss = btoc(USRSTACK - va);/* XXX check this */
d1207 1
d1209 3
d1301 1
d1303 3
d1463 1
d1465 3
@


1.8.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.8.4.2 2001/07/04 10:20:23 niklas Exp $	*/
d49 3
a55 1
#include <sys/systm.h>
a56 6

#include <vm/vm.h>

#include <uvm/uvm_extern.h>

#include <machine/asm_macro.h>   /* enable/disable interrupts */
d59 1
a59 1
#include <machine/locore.h>
d64 3
a67 2
#include <machine/psl.h>		/* FIP_E, etc. */
#include <machine/trap.h>
d69 5
a73 3
#ifdef DDB
#include <machine/db_machdep.h>
#include <ddb/db_output.h>		/* db_printf()		*/
d75 1
a75 1
#define PC_REGS(regs) ((regs->sxip & 2) ?  regs->sxip & ~3 : \
d77 2
a78 2
#define inst_return(I) (((I)&0xfffffbffU) == 0xf400c001U ? TRUE : FALSE)
#define inst_call(I) ({ unsigned i = (I); \
d83 1
a87 1

d93 1
a93 1
#define DEBUG_MSG db_printf
d95 1
a95 1
#define DEBUG_MSG printf
d101 1
a101 2
/* sigh */
extern int procfs_domem __P((struct proc *, struct proc *, void *, struct uio *));
d103 1
d137 1
d146 12
a157 3
		 * We're being preempted.
		 */
		preempt(NULL);
d200 1
a200 1
trap18x(unsigned type, struct m88100_saved_state *frame)
d217 1
a411 1
#ifdef DDB
a412 1
#endif
a494 1
#ifdef DDB
a495 1
#endif
d686 1
a686 1

a687 1
/*ARGSUSED*/
d689 1
a689 1
trap197(unsigned type, struct m88100_saved_state *frame)
d701 1
d705 1
a705 1
	unsigned user = 0, write = 0, data = 0;
d708 1
d711 1
d1195 6
d1224 1
a1224 1
	Debugger();
d1226 1
a1226 1
	Debugger();
d1238 1
a1238 1
	Debugger();
d1240 1
a1240 1
	Debugger();
a1813 1

@


1.8.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d56 2
d1547 1
a1547 2
child_return(arg)
	void *arg;
a1548 1
	struct proc *p = arg;
d1555 4
a1558 2
#ifdef MVME197
	if (cputyp == CPU_197) {
a1560 5
	} else
#endif
	{
		tf->snip = tf->sfip & ~3;
		tf->sfip = tf->snip + 4;
@


1.8.4.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.8.4.4 2001/11/13 21:04:15 niklas Exp $	*/
d193 1
a193 1
	struct vm_map *map;
d205 1
a205 1
	extern struct vm_map *kernel_map;
d407 1
a407 1
			if (result == 0) {
d497 1
a497 1
			if (result == 0) {
d501 2
a502 2
			} else if (result == EACCES)
				result = EFAULT;
d505 1
a505 1
		if (result == 0) {
d522 1
a522 1
			sig = result == EACCES ?
d524 1
a524 1
			fault_type = result == EACCES ?
d686 1
a686 1
	struct vm_map *map;
d699 1
a699 1
	extern struct vm_map *kernel_map;
d968 1
a968 1
				if (result == 0) {
d976 1
a976 1
				if (result == 0) {
d1021 1
a1021 1
				if (result == 0) {
d1029 1
a1029 1
				if (result == 0) {
d1036 1
a1036 1
			if (result == 0) {
d1040 2
a1041 2
			} else if (result == EACCES)
				result = EFAULT;
d1044 3
a1046 3
		if (result != 0) {
			sig = result == EACCES ? SIGBUS : SIGSEGV;
			fault_type = result == EACCES ? BUS_ADRERR
@


1.8.4.6
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d60 1
a60 1
#include <machine/cpu.h>
d62 3
a64 5
#ifdef M88100
#include <machine/m88100.h>
#endif
#ifdef M88110
#include <machine/m88110.h>
d74 1
a74 2
   #define PC_REGS(regs) cputyp == CPU_88110 ? (regs->exip & ~3) :\
           ((regs->sxip & 2) ?  regs->sxip & ~3 : \
a75 1

a103 3
void error_fatal __P((struct m88100_saved_state *frame));
void error_fault __P((struct m88100_saved_state *frame));
void error_reset __P((struct m88100_saved_state *frame));
a116 1
	"Non-Maskable Exception",
a164 1
		if (cputyp != CPU_88110) {
a174 1
		}
d183 1
a183 1
#ifdef M88100
d189 1
a189 1
m88100_trap(unsigned type, struct m88100_saved_state *frame)
d201 1
a201 1
	int result = 0;  
d273 2
a274 2
		   on the value of brdtyp - smurph */
		(*md.interrupt_func)(T_INT, frame);
d354 1
a354 1
			frame->snip = ((unsigned)&guarded_access_bad    ) | NIP_V;
d677 1
a677 2
#endif /* m88100 */
unsigned v_fault = 0;
d679 1
a679 1
#ifdef M88110
d682 1
a682 1
m88110_trap(unsigned type, struct m88100_saved_state *frame)
d694 1
a694 2
        int s; /* IPL */
	int result = 0;  /* Assume Success */
d696 3
a698 3
	unsigned pc = PC_REGS(frame);  /* get program counter (exip) */
	unsigned user = 0, data = 0;
	pt_entry_t *pte;
a701 1
	extern pt_entry_t *pmap_pte __P((pmap_t, vm_offset_t));
a706 5
#if 1
	if (type != T_INT && type != T_ASTFLT && type != T_KDB_ENTRY ) {
		printf("m88110_trap: %d %s\n", type, frame->vector < trap_types ? trap_type[frame->vector] : "unknown");
	}
#endif
a713 1
		user = 1;
d715 1
a715 1
	
d721 1
d723 33
a755 3
		DEBUG_MSG("DMMU read miss: Hardware Table Searches should be enabled!\n");
		panictrap(frame->vector, frame);
		/*NOTREACHED*/
d757 1
d759 36
a794 3
		DEBUG_MSG("DMMU write miss: Hardware Table Searches should be enabled!\n");
		panictrap(frame->vector, frame);
		/*NOTREACHED*/
d796 1
d798 33
a830 3
		DEBUG_MSG("IMMU miss: Hardware Table Searches should be enabled!\n");
		panictrap(frame->vector, frame);
		/*NOTREACHED*/
a831 8
	case T_KDB_TRACE:
		frame->mask = spl(); /* get current spl for reg dump */
		s = db_splhigh();
		db_enable_interrupt();
		ddb_break_trap(T_KDB_TRACE,(db_regs_t*)frame);
		db_disable_interrupt();
		db_splx(s);
		return;
d835 2
a836 2
		frame->mask = spl(); /* get current spl for reg dump */
		s = db_splhigh();
d842 1
d846 2
a847 2
		frame->mask = spl(); /* get current spl for reg dump */
		s = db_splhigh();
a850 5
		if (frame->enip) {
			frame->exip = frame->enip;
		} else {
                               frame->exip += 4;
		}
d853 2
d869 2
a870 1
		DEBUG_MSG("Unimplemented opcode!\n");
d873 1
a873 10
	case T_NON_MASK:
	case T_NON_MASK+T_USER:
		/* This function pointer is set in machdep.c 
		   It calls m197_ext_int - smurph */
		(*md.interrupt_func)(T_NON_MASK, frame);
		return;
	case T_INT:
	case T_INT+T_USER:
		(*md.interrupt_func)(T_INT, frame);
		return;
d875 2
a876 2
		DEBUG_MSG("kernel mode misaligned "
			  "access exception @@ 0x%08x\n", frame->exip);
d878 1
a878 1
		/*NOTREACHED*/
d881 1
d886 1
a886 1
			  "page fault @@ 0x%08x\n", frame->exip);
d888 1
a888 1
		/*NOTREACHED*/
d896 1
d905 1
d909 1
a909 1
			fault_addr = frame->exip & XIP_ADDR;
d936 1
a936 1
			goto m88110_outtahere;
d941 1
a941 1
			goto m88110_user_fault;
d949 2
a950 2
		    (frame->exip & ~3) >= (unsigned)&guarded_access_start &&
		    (frame->exip & ~3) <= (unsigned)&guarded_access_end) {
d953 1
d958 6
a971 19
			if (frame->dsr & CMMU_DSR_WE) { /* write fault  */
			/* This could be a write protection fault or an 
			 * exception to set the used and modified bits
			 * in the pte.  Basicly, if we got a write error, 
			 * then we already have a pte entry that faulted 
			 * in from a previous seg fault or page fault.
			 * Get the pte and check the status of the 
			 * modified and valid bits to determine if this 
			 * indeed a real write fault.  XXX smurph
			 */
				pte = pmap_pte(map->pmap, va);
				if (pte == PT_ENTRY_NULL)
					panic("NULL pte on write fault??");
				if (!(*pte & PG_M) && !(*pte & PG_RO)) {
					/* Set modified bit and try the write again. */
					*pte |= PG_M;
					return;
				}
			}
d987 2
a988 2
m88110_outtahere:
		frame->exip = ((unsigned)p->p_addr->u_pcb.pcb_onfault);
d994 1
a994 1
m88110_user_fault:
d996 1
a996 1
			fault_addr = frame->exip & XIP_ADDR;
d1015 1
d1018 2
a1019 3

			if (frame->dsr & (CMMU_DSR_SI |   /* seg fault  */
					  CMMU_DSR_PI)) { /* page fault */
d1021 1
a1021 27
				if (result != 0) {
					printf("Data Access Error @@ 0x%x\n", va);
				}
				v_fault++;
			} else if (frame->dsr & CMMU_DSR_BE) {	/* bus error */
				result = EFAULT;
			} else if ((frame->dsr & CMMU_DSR_CP)
				   || (frame->dsr & CMMU_DSR_WA)) {
				result = 0;
			} else if (frame->dsr & CMMU_DSR_WE) {	/* write fault  */
			/* This could be a write protection fault or an 
			 * exception to set the used and modified bits
			 * in the pte.  Basicly, if we got a write error, 
			 * then we already have a pte entry that faulted 
			 * in from a previous seg fault or page fault.
			 * Get the pte and check the status of the 
			 * modified and valid bits to determine if this 
			 * indeed a real write fault.  XXX smurph
			 */
				pte = pmap_pte(vm_map_pmap(map), va);
				if (pte == PT_ENTRY_NULL)
					panic("NULL pte on write fault??");
				if (!(*pte & PG_M) && !(*pte & PG_PROT)) {
					/* Set modified bit and try the write again. */
					*pte |= PG_M;
					/* invalidate ATCs to force table search */
					set_dcmd(CMMU_DCMD_INV_UATC);
a1022 4
				} else {
					/* This must be a real write protection fault */
					printf("Write protect???? mod = %d, wp = %d\n", !!(*pte & PG_M), !!(*pte & PG_PROT));
					result = uvm_fault(map, va, 0, ftype);
d1029 3
a1031 5
				v_fault++;
			} else if ((frame->isr & CMMU_ISR_BE)
				   || (frame->isr & CMMU_ISR_SP)
				   || (frame->isr & CMMU_ISR_TBE)) { /* bus error */
				result = EACCES;
a1044 5
#ifdef smurph_debug
			printf("Access failed! result = %d\n\n", result);
			frame->mode = v_fault;
			regdump(frame);
			Debugger();
d1046 4
a1049 2
			fault_type = result == EACCES ? BUS_ADRERR : SEGV_MAPERR;
#endif		
d1138 3
d1152 2
a1180 1
		frame->isr = 0;
a1195 26
error_fatal(struct m88100_saved_state *frame)
{
	switch (frame->vector) {
	case 0:
		DEBUG_MSG("\n[RESET EXCEPTION (Really Bad News[tm]) frame 0x%08x]\n", frame);
		DEBUG_MSG("This is usually caused by a branch to a NULL function pointer.\n");
		DEBUG_MSG("e.g. jump to address 0.  Use the debugger trace command to track it down.\n");
		break;
	default:
		DEBUG_MSG("\n[ERROR EXCEPTION (Bad News[tm]) frame 0x%08x]\n", frame);
		DEBUG_MSG("This is usually an exception within an exception.  The trap\n");
		DEBUG_MSG("frame shadow registers you are about to see are invalid.\n");
		DEBUG_MSG("(read totaly useless)  But R1 to R31 might be interesting.\n");
		break;
	}
	regdump((struct trapframe*)frame);
#if DDB 
	Debugger();
	DEBUG_MSG("You really can't restart after exception %d!\n", frame->vector);
	Debugger();
#endif /* DDB */
	bugreturn();  /* This gets us to Bug instead of a loop forever */

}

void
d1203 1
a1203 1
#ifdef M88100
a1228 1
#ifdef M88100
d1230 1
a1230 1
m88100_syscall(register_t code, struct m88100_saved_state *tf)
d1286 1
d1316 3
a1318 3
	 *       tb0 0, r0, <128> <- sxip
	 *	 br err 	  <- snip
	 *       jmp r1 	  <- sfip
d1355 1
a1355 1
		tf->snip = tf->sfip & ~NIP_E;
d1369 1
a1369 1
		tf->sfip = tf->snip & ~FIP_E;
a1383 3
#endif /* M88100 */

#ifdef M88110
d1385 1
d1388 1
a1388 1
m88110_syscall(register_t code, struct m88100_saved_state *tf)
d1444 1
a1444 1
	printf("syscall code is %d\n", code);
d1474 2
a1475 2
	 *       tb0 0, r0, <128> <- exip
	 *	 br err 	  <- enip
d1482 1
a1482 1
	 * So, when we take syscall trap, exip/enip will be as
d1486 1
a1486 1
	 *	   exip += 8
d1488 1
a1488 1
	 *    exip += 4 and plug the value in r2. This will have us
d1491 1
a1491 1
	 *    we need to rexecute the trap instruction. leave exip as is.
d1493 1
a1493 1
	 *    exip += 4
d1496 1
a1496 3
	switch (error) {
	case 0:
		printf("syscall success!\n");
d1509 9
a1517 5
		tf->exip += 8; 
		tf->exip &= ~3;
		break;
	case ERESTART:
		printf("syscall restart!\n");
d1519 2
a1520 3
		 * Reexecute the trap.
		 * exip is already at the trap instruction, so
		 * there is nothing to do.
d1523 1
a1523 3
		break;
	case EJUSTRETURN:
		printf("syscall just return!\n");
d1526 2
a1527 13
		tf->exip += 4;
		tf->exip &= ~3;
		break;
	default:
		printf("syscall error %d!\n", error);
		/* error != ERESTART && error != EJUSTRETURN*/
		if (p->p_emul->e_errno)
			error = p->p_emul->e_errno[error];
		tf->r[2] = error;
		tf->epsr |= PSR_C;   /* fail */
		tf->exip += 4;
		tf->exip &= ~3;
		break;
a1528 1

d1555 7
a1561 1
	if (cputyp != CPU_88110) {
a1563 3
	} else {
		tf->exip += 8;
		tf->exip &= ~3;
@


1.8.4.7
log
@Merge in -current from about a week ago
@
text
@d105 1
a105 1
extern int procfs_domem(struct proc *, struct proc *, void *, struct uio *);
d107 4
a110 4
extern void regdump(struct trapframe *f);
void error_fatal(struct m88100_saved_state *frame);
void error_fault(struct m88100_saved_state *frame);
void error_reset(struct m88100_saved_state *frame);
d714 1
a714 1
	extern pt_entry_t *pmap_pte(pmap_t, vm_offset_t);
@


1.8.4.8
log
@Sync the SMP branch with 3.3
@
text
@a55 3
#include "systrace.h"
#include <dev/systrace.h>

d162 2
a163 6
	if (p->p_flag & P_PROFIL) {
		extern int psratio;

		addupc_task(p, frame->sxip & ~3,
		    (int)(p->p_sticks - oticks) * psratio);
	}
d247 1
a247 1
			int s = splhigh();
d251 1
a251 1
			splx(s);
d258 1
a258 1
			int s = splhigh();
d262 1
a262 1
			splx(s);
d269 1
a269 1
			int s = splhigh();
d274 1
a274 1
			splx(s);
d333 13
d448 1
d587 1
a587 1
			copyin((caddr_t)pc, &instr, sizeof(unsigned));
d756 2
a757 1
		s = splhigh();
d761 1
a761 1
		splx(s);
d766 7
a772 6
		s = splhigh();
		db_enable_interrupt();
		ddb_break_trap(T_KDB_BREAK,(db_regs_t*)frame);
		db_disable_interrupt();
		splx(s);
		return;
d776 5
a780 4
		s = splhigh();
		db_enable_interrupt();
		ddb_entry_trap(T_KDB_ENTRY,(db_regs_t*)frame);
		db_disable_interrupt();
d786 2
a787 2
		splx(s);
		return;
d790 9
a798 7
		s = splhigh();
		db_enable_interrupt();
		ddb_error_trap(type == T_ILLFLT ? "unimplemented opcode" :
		       "error fault", (db_regs_t*)frame);
		db_disable_interrupt();
		splx(s);
		return;
d863 13
d937 1
d1091 1
a1091 1
			copyin((caddr_t)pc, &instr, sizeof(unsigned));
d1316 1
a1316 6
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE))
		error = systrace_redirect(code, p, &args, rval);
	else
#endif
		error = (*callp->sy_call)(p, &args, rval);
a1822 19

#ifdef DIAGNOSTIC
void
splassert_check(int wantipl, const char *func)
{
	int oldipl;

	oldipl = getipl();

	if (oldipl < wantipl) {
		splassert_fail(wantipl, oldipl, func);
		/*
		 * If the splassert_ctl is set to not panic, raise the ipl
		 * in a feeble attempt to reduce damage.
		 */
		setipl(wantipl);
	}
}
#endif
@


1.8.4.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d62 1
d66 1
a66 2
#include <machine/m88100.h>		/* DMT_xxx */
#include <machine/m8820x.h>		/* CMMU_PFSR_xxx */
d75 1
a76 1
#ifdef DDB
d78 11
d92 8
a99 2
#ifdef DDB
#define DEBUG_MSG(x) db_printf x
d101 1
a101 1
#define DEBUG_MSG(x)
d104 2
a105 2
#define USERMODE(PSR)   (((PSR) & PSR_MODE) == 0)
#define SYSTEMMODE(PSR) (((PSR) & PSR_MODE) != 0)
a109 3
__dead void panictrap(int, struct trapframe *);
__dead void error_fatal(struct trapframe *);

d111 3
d115 1
a115 1
const char *trap_type[] = {
a128 1
const int trap_types = sizeof trap_type / sizeof trap_type[0];
d130 1
a130 1
const char *pbus_exception_type[] = {
d141 2
d144 1
a144 1
userret(struct proc *p, struct trapframe *frame, u_quad_t oticks)
d168 1
a168 1
		addupc_task(p, frame->tf_sxip & XIP_ADDR,
d174 2
a175 2
__dead void
panictrap(int type, struct trapframe *frame)
a176 1
#ifdef DDB
d180 11
a190 28
		switch (cputyp) {
#ifdef M88100
		case CPU_88100:
			if (type == 2) {
				/* instruction exception */
				db_printf("\nInstr access fault (%s) v = %x, "
				    "frame %p\n",
				    pbus_exception_type[
				      CMMU_PFSR_FAULT(frame->tf_ipfsr)],
				    frame->tf_sxip & XIP_ADDR, frame);
			} else if (type == 3) {
				/* data access exception */
				db_printf("\nData access fault (%s) v = %x, "
				    "frame %p\n",
				    pbus_exception_type[
				      CMMU_PFSR_FAULT(frame->tf_dpfsr)],
				    frame->tf_sxip & XIP_ADDR, frame);
			} else
				db_printf("\nTrap type %d, v = %x, frame %p\n",
				    type, frame->tf_sxip & XIP_ADDR, frame);
			break;
#endif
#ifdef M88110
		case CPU_88110:
			db_printf("\nTrap type %d, v = %x, frame %p\n",
			    type, frame->tf_exip, frame);
			break;
#endif
a193 1
#endif
d196 1
a196 2
	else
		panic("trap %d", type);
d201 4
d206 1
a206 1
m88100_trap(unsigned type, struct trapframe *frame)
d211 1
a211 1
	vaddr_t va;
d213 1
a213 1
	int fault_type, pbus_type;
d218 1
a218 4
	int result;
#ifdef DDB
	int s;
#endif
d220 1
d223 3
a225 3
	extern caddr_t guarded_access_start;
	extern caddr_t guarded_access_end;
	extern caddr_t guarded_access_bad;
d227 6
d237 1
a237 1
	if (USERMODE(frame->tf_epsr)) {
d241 2
a243 4
	fault_type = 0;
	fault_code = 0;
	fault_addr = frame->tf_sxip & XIP_ADDR;

d246 1
a246 2
		panictrap(frame->tf_vector, frame);
		break;
d251 10
a260 6
		s = splhigh();
		db_enable_interrupt();
		ddb_break_trap(T_KDB_BREAK, (db_regs_t*)frame);
		db_disable_interrupt();
		splx(s);
		return;
d262 23
a284 6
		s = splhigh();
		db_enable_interrupt();
		ddb_entry_trap(T_KDB_ENTRY, (db_regs_t*)frame);
		db_disable_interrupt();
		splx(s);
		return;
a285 4
	case T_ILLFLT:
		DEBUG_MSG(("Unimplemented opcode!\n"));
		panictrap(frame->tf_vector, frame);
		break;
d288 1
a288 1
		/* This function pointer is set in machdep.c
d295 3
a297 3
		DEBUG_MSG(("kernel misaligned "
			  "access exception @@ 0x%08x\n", frame->tf_sxip));
		panictrap(frame->tf_vector, frame);
d304 3
a306 7
#ifdef TRAPDEBUG
		pbus_type = CMMU_PFSR_FAULT(frame->tf_ipfsr);
		printf("Kernel Instruction fault #%d (%s) v = 0x%x, frame 0x%x cpu %d\n",
		    pbus_type, pbus_exception_type[pbus_type],
		    fault_addr, frame, frame->tf_cpu);
#endif
		panictrap(frame->tf_vector, frame);
d311 4
d316 9
a324 10
		/* data fault on the user address? */
		if ((frame->tf_dmt0 & DMT_DAS) == 0) {
			type = T_DATAFLT + T_USER;
			goto user_fault;
		}

		fault_addr = frame->tf_dma0;
		if (frame->tf_dmt0 & (DMT_WRITE|DMT_LOCKBAR)) {
			ftype = VM_PROT_READ|VM_PROT_WRITE;
			fault_code = VM_PROT_WRITE;
d326 1
d331 1
a331 4
		va = trunc_page((vaddr_t)fault_addr);
		if (va == 0) {
			panic("trap: bad kernel access at %x", fault_addr);
		}
d334 1
a334 1
		map = kernel_map;
d336 3
a338 6
		pbus_type = CMMU_PFSR_FAULT(frame->tf_dpfsr);
#ifdef TRAPDEBUG
		printf("Kernel Data access fault #%d (%s) v = 0x%x, frame 0x%x cpu %d\n",
		    pbus_type, pbus_exception_type[pbus_type],
		    fault_addr, frame, frame->tf_cpu);
#endif
d340 38
a377 2
		switch (pbus_type) {
		case CMMU_PFSR_BERROR:
d379 16
a394 22
		 	 * If it is a guarded access, bus error is OK.
		 	 */
			if ((frame->tf_sxip & XIP_ADDR) >=
			      (unsigned)&guarded_access_start &&
			    (frame->tf_sxip & XIP_ADDR) <=
			      (unsigned)&guarded_access_end) {
				frame->tf_snip =
				  ((unsigned)&guarded_access_bad    ) | NIP_V;
				frame->tf_sfip =
				  ((unsigned)&guarded_access_bad + 4) | FIP_V;
				frame->tf_sxip = 0;
				/* We sort of resolved the fault ourselves
				 * because we know where it came from
				 * [guarded_access()]. But we must still think
				 * about the other possible transactions in
				 * dmt1 & dmt2.  Mark dmt0 so that
				 * data_access_emulation skips it.  XXX smurph
				 */
				frame->tf_dmt0 |= DMT_SKIP;
				data_access_emulation((unsigned *)frame);
				frame->tf_dpfsr = 0;
				frame->tf_dmt0 = 0;
d396 16
a411 3
			}
			break;
		case CMMU_PFSR_SUCCESS:
d413 4
a416 3
			 * The fault was resolved. Call data_access_emulation
			 * to drain the data unit pipe line and reset dmt0
			 * so that trap won't get called again.
d418 11
a428 17
			data_access_emulation((unsigned *)frame);
			frame->tf_dpfsr = 0;
			frame->tf_dmt0 = 0;
			return;
		case CMMU_PFSR_SFAULT:
		case CMMU_PFSR_PFAULT:
			result = uvm_fault(map, va, VM_FAULT_INVALID, ftype);
			if (result == 0) {
				/*
				 * We could resolve the fault. Call
				 * data_access_emulation to drain the data
				 * unit pipe line and reset dmt0 so that trap
				 * won't get called again.
				 */
				data_access_emulation((unsigned *)frame);
				frame->tf_dpfsr = 0;
				frame->tf_dmt0 = 0;
a430 1
			break;
d432 25
a456 6
#ifdef TRAPDEBUG
		printf("PBUS Fault %d (%s) va = 0x%x\n", pbus_type,
		    pbus_exception_type[pbus_type], va);
#endif
		panictrap(frame->tf_vector, frame);
		/* NOTREACHED */
d459 1
a459 1
		/* FALLTHROUGH */
d461 3
a463 8
user_fault:
		if (type == T_INSTFLT + T_USER) {
			pbus_type = CMMU_PFSR_FAULT(frame->tf_ipfsr);
#ifdef TRAPDEBUG
			printf("User Instruction fault #%d (%s) v = 0x%x, frame 0x%x cpu %d\n",
			    pbus_type, pbus_exception_type[pbus_type],
			    fault_addr, frame, frame->tf_cpu);
#endif
d465 1
a465 7
			fault_addr = frame->tf_dma0;
			pbus_type = CMMU_PFSR_FAULT(frame->tf_dpfsr);
#ifdef TRAPDEBUG
			printf("User Data access fault #%d (%s) v = 0x%x, frame 0x%x cpu %d\n",
			    pbus_type, pbus_exception_type[pbus_type],
			    fault_addr, frame, frame->tf_cpu);
#endif
d467 6
d474 2
a475 2
		if (frame->tf_dmt0 & (DMT_WRITE | DMT_LOCKBAR)) {
			ftype = VM_PROT_READ | VM_PROT_WRITE;
d482 1
a482 1
		va = trunc_page((vaddr_t)fault_addr);
d486 11
a496 14

		/* Call uvm_fault() to resolve non-bus error faults */
		switch (pbus_type) {
		case CMMU_PFSR_SUCCESS:
			result = 0;
			break;
		case CMMU_PFSR_BERROR:
			result = EACCES;
			break;
		default:
			result = uvm_fault(map, va, VM_FAULT_INVALID, ftype);
			if (result == EACCES)
				result = EFAULT;
			break;
d504 2
a505 1
			}
d508 2
a509 8
		/*
		 * This could be a fault caused in copyin*()
		 * while accessing user space.
		 */
		if (result != 0 && p->p_addr->u_pcb.pcb_onfault != NULL) {
			frame->tf_snip = p->p_addr->u_pcb.pcb_onfault | NIP_V;
			frame->tf_sfip = (p->p_addr->u_pcb.pcb_onfault + 4) | FIP_V;
			frame->tf_sxip = 0;
d511 4
a514 2
			 * Continue as if the fault had been resolved, but
			 * do not try to complete the faulting access.
a515 12
			frame->tf_dmt0 |= DMT_SKIP;
			result = 0;
		}

		if (result == 0) {
			if (type == T_DATAFLT+T_USER) {
				/*
			 	 * We could resolve the fault. Call
			 	 * data_access_emulation to drain the data unit
			 	 * pipe line and reset dmt0 so that trap won't
			 	 * get called again.
			 	 */
d517 2
a518 2
				frame->tf_dpfsr = 0;
				frame->tf_dmt0 = 0;
d520 3
a522 7
				/*
				 * back up SXIP, SNIP,
				 * clearing the Error bit
				 */
				frame->tf_sfip = frame->tf_snip & ~FIP_E;
				frame->tf_snip = frame->tf_sxip & ~NIP_E;
				frame->tf_ipfsr = 0;
d525 2
a526 1
			sig = result == EACCES ? SIGBUS : SIGSEGV;
d528 1
a528 1
			    BUS_ADRERR : SEGV_MAPERR;
a536 8
#ifndef DDB
	case T_KDB_BREAK:
	case T_KDB_ENTRY:
#endif
	case T_KDB_BREAK+T_USER:
	case T_KDB_ENTRY+T_USER:
	case T_KDB_TRACE:
	case T_KDB_TRACE+T_USER:
a553 3
	case T_SIGSYS+T_USER:
		sig = SIGSYS;
		break;
d571 1
a571 1
			unsigned va;
d575 3
a577 1
			unsigned pc = PC_REGS(&frame->tf_regs);
d587 1
a587 1
			if ((p->p_md.md_ss_addr != pc &&
d599 1
a599 1
				iov.iov_len = sizeof(int);
d601 1
a601 1
				uio.uio_iovcnt = 1;
d615 1
a615 1
				iov.iov_len = sizeof(int);
d617 1
a617 1
				uio.uio_iovcnt = 1;
d626 3
a628 3
			frame->tf_sfip = frame->tf_snip;    /* set up next FIP */
			frame->tf_snip = pc;    /* set up next NIP */
			frame->tf_snip |= 2;	  /* set valid bit   */
d645 2
a646 2
		frame->tf_sfip = frame->tf_snip;    /* set up the next FIP */
		frame->tf_snip = frame->tf_sxip;    /* set up the next NIP */
d664 1
a664 1
	if (type < T_USER)
d670 1
a670 1
		/*
d674 2
a675 2
		frame->tf_dmt0 = 0;
		frame->tf_ipfsr = frame->tf_dpfsr = 0;
d681 1
d684 1
d686 1
a686 1
m88110_trap(unsigned type, struct trapframe *frame)
d691 1
a691 1
	vaddr_t va;
a697 2
	int result;
#ifdef DDB
d699 1
a699 1
#endif
d701 2
a703 1

d707 1
a707 2
	extern unsigned guarded_access_bad;
	extern pt_entry_t *pmap_pte(pmap_t, vaddr_t);
d710 1
d713 5
d719 1
a719 1
	if (USERMODE(frame->tf_epsr)) {
d723 3
d727 1
a727 4
	fault_type = 0;
	fault_code = 0;
	fault_addr = frame->tf_exip & XIP_ADDR;

d730 1
a730 2
		panictrap(frame->tf_vector, frame);
		break;
a731 1

d734 2
a735 3
		DEBUG_MSG(("DMMU read miss: Hardware Table Searches should be enabled!\n"));
		panictrap(frame->tf_vector, frame);
		break;
d739 2
a740 3
		DEBUG_MSG(("DMMU write miss: Hardware Table Searches should be enabled!\n"));
		panictrap(frame->tf_vector, frame);
		break;
d744 2
a745 3
		DEBUG_MSG(("IMMU miss: Hardware Table Searches should be enabled!\n"));
		panictrap(frame->tf_vector, frame);
		break;
d747 1
a747 1
#ifdef DDB
d751 1
a751 1
		ddb_break_trap(T_KDB_TRACE, (db_regs_t*)frame);
d756 2
d760 1
a760 1
		ddb_break_trap(T_KDB_BREAK, (db_regs_t*)frame);
d765 2
d769 1
a769 1
		ddb_entry_trap(T_KDB_ENTRY, (db_regs_t*)frame);
d771 5
a775 6
		/* skip one instruction */
		if (frame->tf_exip & 1)
			frame->tf_exip = frame->tf_enip;
		else
			frame->tf_exip += 4;
		frame->tf_enip = 0;
d790 2
a791 2
		DEBUG_MSG(("Unimplemented opcode!\n"));
		panictrap(frame->tf_vector, frame);
d795 1
a795 1
		/* This function pointer is set in machdep.c
d804 3
a806 4
		DEBUG_MSG(("kernel mode misaligned "
			  "access exception @@ 0x%08x\n", frame->tf_exip));
		panictrap(frame->tf_vector, frame);
		break;
d813 3
a815 6
#ifdef TRAPDEBUG
		printf("Kernel Instruction fault exip %x isr %x ilar %x\n",
		    frame->tf_exip, frame->tf_isr, frame->tf_ilar);
#endif
		panictrap(frame->tf_vector, frame);
		break;
d820 18
a837 5

		/* data fault on the user address? */
		if ((frame->tf_dsr & CMMU_DSR_SU) == 0) {
			type = T_DATAFLT + T_USER;
			goto m88110_user_fault;
d840 3
a842 4
#ifdef TRAPDEBUG
		printf("Kernel Data access fault exip %x dsr %x dlar %x\n",
		    frame->tf_exip, frame->tf_dsr, frame->tf_dlar);
#endif
d844 5
a848 7
		fault_addr = frame->tf_dlar;
		if (frame->tf_dsr & CMMU_DSR_RW) {
			ftype = VM_PROT_READ;
			fault_code = VM_PROT_READ;
		} else {
			ftype = VM_PROT_READ|VM_PROT_WRITE;
			fault_code = VM_PROT_WRITE;
d851 4
a854 3
		va = trunc_page((vaddr_t)fault_addr);
		if (va == 0) {
			panic("trap: bad kernel access at %x", fault_addr);
d857 3
a859 2
		vm = p->p_vmspace;
		map = kernel_map;
d861 16
a876 11
		if (frame->tf_dsr & CMMU_DSR_BE) {
			/*
			 * If it is a guarded access, bus error is OK.
			 */
			if ((frame->tf_exip & XIP_ADDR) >=
			      (unsigned)&guarded_access_start &&
			    (frame->tf_exip & XIP_ADDR) <=
			      (unsigned)&guarded_access_end) {
				frame->tf_exip = (unsigned)&guarded_access_bad;
				frame->tf_enip = 0;
				return;
d878 2
a879 14
		}
		if (frame->tf_dsr & (CMMU_DSR_SI | CMMU_DSR_PI)) {
			frame->tf_dsr &= ~CMMU_DSR_WE;	/* undefined */
			/*
			 * On a segment or a page fault, call uvm_fault() to
			 * resolve the fault.
			 */
			result = uvm_fault(map, va, VM_FAULT_INVALID, ftype);
			if (result == 0)
				return;
		}
		if (frame->tf_dsr & CMMU_DSR_WE) {	/* write fault  */
			/*
			 * This could be a write protection fault or an
d881 2
a882 2
			 * in the pte. Basically, if we got a write error,
			 * then we already have a pte entry that faulted
d884 2
a885 2
			 * Get the pte and check the status of the
			 * modified and valid bits to determine if this
d888 14
a901 20
			pte = pmap_pte(map->pmap, va);
			if (pte == PT_ENTRY_NULL)
				panic("NULL pte on write fault??");
			if (!(*pte & PG_M) && !(*pte & PG_RO)) {
				/* Set modified bit and try the write again. */
#ifdef TRAPDEBUG
				printf("Corrected kernel write fault, map %x pte %x\n",
				    map->pmap, *pte);
#endif
				*pte |= PG_M;
				return;
#if 1	/* shouldn't happen */
			} else {
				/* must be a real wp fault */
#ifdef TRAPDEBUG
				printf("Uncorrected kernel write fault, map %x pte %x\n",
				    map->pmap, *pte);
#endif
				result = uvm_fault(map, va, VM_FAULT_INVALID, ftype);
				if (result == 0)
d903 1
a903 1
#endif
d906 8
a913 2
		panictrap(frame->tf_vector, frame);
		/* NOTREACHED */
d916 1
a916 1
		/* FALLTHROUGH */
d920 1
a922 4
#ifdef TRAPDEBUG
			printf("User Instruction fault exip %x isr %x ilar %x\n",
			    frame->tf_exip, frame->tf_isr, frame->tf_ilar);
#endif
d924 2
a925 2
			fault_addr = frame->tf_dlar;
			if (frame->tf_dsr & CMMU_DSR_RW) {
a931 4
#ifdef TRAPDEBUG
			printf("User Data access fault exip %x dsr %x dlar %x\n",
			    frame->tf_exip, frame->tf_dsr, frame->tf_dlar);
#endif
d934 1
a934 1
		va = trunc_page((vaddr_t)fault_addr);
d939 1
a939 4
		/*
		 * Call uvm_fault() to resolve non-bus error faults
		 * whenever possible.
		 */
d941 12
a952 13
			/* data faults */
			if (frame->tf_dsr & CMMU_DSR_BE) {
				/* bus error */
				result = EACCES;
			} else
			if (frame->tf_dsr & (CMMU_DSR_SI | CMMU_DSR_PI)) {
				/* segment or page fault */
				result = uvm_fault(map, va, VM_FAULT_INVALID, ftype);
				if (result == EACCES)
					result = EFAULT;
			} else
			if (frame->tf_dsr & (CMMU_DSR_CP | CMMU_DSR_WA)) {
				/* copyback or write allocate error */
d954 10
a963 13
			} else
			if (frame->tf_dsr & CMMU_DSR_WE) {
				/* write fault  */
				/* This could be a write protection fault or an
				 * exception to set the used and modified bits
				 * in the pte. Basically, if we got a write
				 * error, then we already have a pte entry that
				 * faulted in from a previous seg fault or page
				 * fault.
				 * Get the pte and check the status of the
				 * modified and valid bits to determine if this
				 * indeed a real write fault.  XXX smurph
				 */
a964 1
#ifdef DEBUG
d967 2
a968 10
#endif
				if (!(*pte & PG_M) && !(*pte & PG_RO)) {
					/*
					 * Set modified bit and try the
					 * write again.
					 */
#ifdef TRAPDEBUG
					printf("Corrected userland write fault, map %x pte %x\n",
					    map->pmap, *pte);
#endif
d970 1
a970 4
					/*
					 * invalidate ATCs to force
					 * table search
					 */
d974 3
a976 8
					/* must be a real wp fault */
#ifdef TRAPDEBUG
					printf("Uncorrected userland write fault, map %x pte %x\n",
					    map->pmap, *pte);
#endif
					result = uvm_fault(map, va, VM_FAULT_INVALID, ftype);
					if (result == EACCES)
						result = EFAULT;
a977 6
			} else {
#ifdef TRAPDEBUG
				printf("Unexpected Data access fault dsr %x\n",
				    frame->tf_dsr);
#endif
				panictrap(frame->tf_vector, frame);
d980 7
a986 4
			/* instruction faults */
			if (frame->tf_isr &
			    (CMMU_ISR_BE | CMMU_ISR_SP | CMMU_ISR_TBE)) {
				/* bus error, supervisor protection */
a987 12
			} else
			if (frame->tf_isr & (CMMU_ISR_SI | CMMU_ISR_PI)) {
				/* segment or page fault */
				result = uvm_fault(map, va, VM_FAULT_INVALID, ftype);
				if (result == EACCES)
					result = EFAULT;
			} else {
#ifdef TRAPDEBUG
				printf("Unexpected Instruction fault isr %x\n",
				    frame->tf_isr);
#endif
				panictrap(frame->tf_vector, frame);
d996 2
a997 15
			}
		}

		/*
		 * This could be a fault caused in copyin*()
		 * while accessing user space.
		 */
		if (result != 0 && p->p_addr->u_pcb.pcb_onfault != NULL) {
			frame->tf_exip = p->p_addr->u_pcb.pcb_onfault;
			frame->tf_enip = 0;
			frame->tf_dsr = frame->tf_isr = 0;
			/*
			 * Continue as if the fault had been resolved.
			 */
			result = 0;
d1001 5
d1007 2
a1008 2
			fault_type = result == EACCES ?
			    BUS_ADRERR : SEGV_MAPERR;
a1016 8
#ifndef DDB
	case T_KDB_BREAK:
	case T_KDB_ENTRY:
	case T_KDB_TRACE:
#endif
	case T_KDB_BREAK+T_USER:
	case T_KDB_ENTRY+T_USER:
	case T_KDB_TRACE+T_USER:
a1033 3
	case T_SIGSYS+T_USER:
		sig = SIGSYS;
		break;
d1050 5
d1056 1
d1060 3
a1062 1
			unsigned pc = PC_REGS(&frame->tf_regs);
d1066 1
a1066 1
#if 0
d1078 1
a1078 1
#endif
d1082 4
a1085 1
			if (instr != 0) {
d1087 1
a1087 1
				iov.iov_len = sizeof(int);
d1089 1
a1089 1
				uio.uio_iovcnt = 1;
a1120 1

d1124 1
a1124 1
	if (type < T_USER)
d1130 1
a1130 1
		/*
d1134 2
a1135 1
		frame->tf_dsr = frame->tf_isr = 0;
a1136 1

d1139 1
d1142 10
a1151 2
__dead void
error_fatal(struct trapframe *frame)
d1153 1
a1153 2
#ifdef DDB
	switch (frame->tf_vector) {
d1155 3
a1157 3
		db_printf("\n[RESET EXCEPTION (Really Bad News[tm]) frame %8p]\n", frame);
		db_printf("This is usually caused by a branch to a NULL function pointer.\n");
		db_printf("e.g. jump to address 0.  Use the debugger trace command to track it down.\n");
d1160 4
a1163 4
		db_printf("\n[ERROR EXCEPTION (Bad News[tm]) frame %p]\n", frame);
		db_printf("This is usually an exception within an exception.  The trap\n");
		db_printf("frame shadow registers you are about to see are invalid.\n");
		db_printf("(read totally useless)  But R1 to R31 might be interesting.\n");
d1167 39
d1207 1
a1207 1
	panic("unrecoverable exception %d", frame->tf_vector);
d1212 1
a1212 1
m88100_syscall(register_t code, struct trapframe *tf)
d1214 3
a1216 3
	int i, nsys, nap;
	struct sysent *callp;
	struct proc *p;
d1218 4
a1221 1
	register_t args[11], rval[2], *ap;
a1222 1
#ifdef DIAGNOSTIC
a1223 1
#endif
d1233 1
a1233 1
	if (USERMODE(tf->tf_epsr) == 0)
d1250 2
a1251 2
	ap = &tf->tf_r[2];
	nap = 11; /* r2-r12 */
d1273 1
a1273 1
		if (i > nap)
d1279 1
a1279 1
		bcopy((caddr_t)ap, (caddr_t)args, i * sizeof(register_t));
a1280 1

d1282 1
a1282 1
	scdebug_call(p, code, args);
d1286 1
a1286 1
		ktrsyscall(p, code, callp->sy_argsize, args);
d1292 1
a1292 1
		error = systrace_redirect(code, p, args, rval);
d1295 1
a1295 1
		error = (*callp->sy_call)(p, args, rval);
d1307 1
a1307 1
	 *	 subu r2, r0, 1
d1328 1
a1328 2
	switch (error) {
	case 0:
d1337 13
a1349 8
		tf = (struct trapframe *)USER_REGS(p);
		tf->tf_r[2] = rval[0];
		tf->tf_r[3] = rval[1];
		tf->tf_epsr &= ~PSR_C;
		tf->tf_snip = tf->tf_sfip & ~NIP_E;
		tf->tf_sfip = tf->tf_snip + 4;
		break;
	case ERESTART:
d1354 4
a1357 5
		tf->tf_epsr &= ~PSR_C;
		tf->tf_sfip = tf->tf_snip & ~FIP_E;
		tf->tf_snip = tf->tf_sxip & ~NIP_E;
		break;
	case EJUSTRETURN:
d1359 1
a1359 11
		tf->tf_epsr &= ~PSR_C;
		break;
	default:
		/* error != ERESTART && error != EJUSTRETURN*/
		if (p->p_emul->e_errno)
			error = p->p_emul->e_errno[error];
		tf->tf_r[2] = error;
		tf->tf_epsr |= PSR_C;   /* fail */
		tf->tf_snip = tf->tf_snip & ~NIP_E;
		tf->tf_sfip = tf->tf_sfip & ~FIP_E;
		break;
d1373 2
a1374 1
/* Instruction pointers operate differently on mc88110 */
d1376 1
a1376 1
m88110_syscall(register_t code, struct trapframe *tf)
d1378 3
a1380 3
	int i, nsys, nap;
	struct sysent *callp;
	struct proc *p;
d1382 4
a1385 1
	register_t args[11], rval[2], *ap;
a1386 1
#ifdef DIAGNOSTIC
a1387 1
#endif
d1397 1
a1397 1
	if (USERMODE(tf->tf_epsr) == 0)
d1414 2
a1415 2
	ap = &tf->tf_r[2];
	nap = 11;	/* r2-r12 */
d1432 1
d1438 1
a1438 1
		if (i > nap)
d1444 1
a1444 1
		bcopy((caddr_t)ap, (caddr_t)args, i * sizeof(register_t));
d1447 1
a1447 1
	scdebug_call(p, code, args);
d1451 1
a1451 1
		ktrsyscall(p, code, callp->sy_argsize, args);
d1455 1
a1455 6
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE))
		error = systrace_redirect(code, p, args, rval);
	else
#endif
		error = (*callp->sy_call)(p, args, rval);
d1467 1
a1467 1
	 *	 subu r2, r0, 1
d1475 1
a1475 1
	 * 2. If the system call returned an errno > 0, increment
d1486 1
d1495 6
a1500 10
		tf = (struct trapframe *)USER_REGS(p);
		tf->tf_r[2] = rval[0];
		tf->tf_r[3] = rval[1];
		tf->tf_epsr &= ~PSR_C;
		/* skip two instructions */
		if (tf->tf_exip & 1)
			tf->tf_exip = tf->tf_enip + 4;
		else
			tf->tf_exip += 4 + 4;
		tf->tf_enip = 0;
d1503 1
d1509 1
a1509 1
		tf->tf_epsr &= ~PSR_C;
d1512 5
a1516 7
		tf->tf_epsr &= ~PSR_C;
		/* skip one instruction */
		if (tf->tf_exip & 1)
			tf->tf_exip = tf->tf_enip;
		else
			tf->tf_exip += 4;
		tf->tf_enip = 0;
d1519 2
d1523 4
a1526 8
		tf->tf_r[2] = error;
		tf->tf_epsr |= PSR_C;   /* fail */
		/* skip one instruction */
		if (tf->tf_exip & 1)
			tf->tf_exip = tf->tf_enip;
		else
			tf->tf_exip += 4;
		tf->tf_enip = 0;
d1552 4
a1555 4
	tf = (struct trapframe *)USER_REGS(p);
	tf->tf_r[2] = 0;
	tf->tf_r[3] = 0;
	tf->tf_epsr &= ~PSR_C;
d1557 2
a1558 2
		tf->tf_snip = tf->tf_sfip & XIP_ADDR;
		tf->tf_sfip = tf->tf_snip + 4;
d1560 2
a1561 6
		/* skip two instructions */
		if (tf->tf_exip & 1)
			tf->tf_exip = tf->tf_enip + 4;
		else
			tf->tf_exip += 4 + 4;
		tf->tf_enip = 0;
d1571 3
a1573 16
#ifdef PTRACE

/*
 * User Single Step Debugging Support
 */

#include <sys/ptrace.h>

unsigned ss_get_value(struct proc *, unsigned, int);
int ss_put_value(struct proc *, unsigned, unsigned, int);
unsigned ss_branch_taken(unsigned, unsigned,
    unsigned (*func)(unsigned int, struct reg *), struct reg *);
unsigned int ss_getreg_val(unsigned int, struct reg *);
int ss_inst_branch(unsigned);
int ss_inst_delayed(unsigned);
unsigned ss_next_instr_address(struct proc *, unsigned, unsigned);
d1575 1
a1575 1
unsigned
d1583 1
a1583 1
	iov.iov_len = size;
d1585 1
a1585 1
	uio.uio_iovcnt = 1;
d1595 1
a1595 1
int
d1600 1
d1603 1
a1603 1
	iov.iov_len = size;
d1605 1
a1605 1
	uio.uio_iovcnt = 1;
d1611 2
a1612 1
	return procfs_domem(curproc, p, NULL, &uio);
d1627 5
a1631 2
ss_branch_taken(unsigned inst, unsigned pc,
    unsigned (*func)(unsigned int, struct reg *), struct reg *func_data)
d1633 1
d1635 1
a1635 1
	if ((inst & 0xf0000000) == 0xc0000000) {
d1637 1
a1637 1
		inst = (inst & 0x03ffffff) << 2;
d1639 3
a1641 3
		if (inst & 0x08000000)
			inst |= 0xf0000000;
		return (pc + inst);
d1645 4
a1648 4
	switch (inst & 0xf8000000) {
	case 0xd0000000: /* bb0 */
	case 0xd8000000: /* bb1 */
	case 0xe8000000: /* bcnd */
d1650 1
a1650 1
		inst = (inst & 0x0000ffff) << 2;
d1652 3
a1654 3
		if (inst & 0x00020000)
			inst |= 0xfffc0000;
		return (pc + inst);
d1659 1
a1659 1
	if ((inst & 0xfffff3e0) == 0xf400c000)
d1662 1
a1662 2
	/* can't happen */
	return (0);
d1670 2
a1671 2
unsigned int
ss_getreg_val(unsigned int regno, struct reg *regs)
d1673 8
a1680 1
	return (regno == 0 ? 0 : regs->r[regno]);
d1688 1
a1688 1
	switch (ins >> (32 - 5)) {
d1696 1
a1696 1
		if ((ins & 0xfffffbe0) == 0xf400c000)
d1710 1
a1710 1
	switch ((ins & 0xfc000000) >> (32 - 6)) {
d1721 1
a1721 1
	return ((ins & 0xfffff7e0) == 0xf400c400) ? TRUE : FALSE;
d1728 1
a1728 1
		return (pc + 4);
d1731 1
a1731 1
			return (pc + 4);
d1739 1
a1739 1
	struct proc *p;
d1741 1
a1741 1
	struct reg *sstf = USER_REGS(p);
d1743 1
d1757 1
a1757 2
		if (ss_inst_branch(curinstr) ||
		    inst_call(curinstr) || inst_return(curinstr)) {
d1760 4
d1765 4
a1768 7
				p->p_md.md_ss_taken_instr =
				    ss_get_value(p, brpc, sizeof(int));
				/* Store breakpoint instruction at the
				   "next" location now. */
				if (ss_put_value(p, brpc, bpinstr,
				    sizeof(int)) != 0)
					return (EFAULT);
d1772 4
d1778 4
d1784 3
a1786 1
	if (p->p_md.md_ss_addr != NULL) {
d1796 1
a1796 2
	if (ss_put_value(p, pc, bpinstr, sizeof(int)) != 0)
		return (EFAULT);
d1798 1
a1801 1
#endif	/* PTRACE */
d1809 1
a1809 5
	/*
	 * This will raise the spl if too low,
	 * in a feeble attempt to reduce further damage.
	 */
	oldipl = raiseipl(wantipl);
d1813 5
@


1.8.4.10
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.8.4.9 2004/02/19 10:49:08 niklas Exp $	*/
@


1.7
log
@Added vme bus device drivers. MVME328, MVME376, MVME332
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.6 1999/02/09 06:36:30 smurph Exp $	*/
d57 1
d59 3
d69 1
a69 1
#include <machine/db_machdep.h>
d71 1
a71 1
#define PC_REGS(regs) ((regs->sxip & 2) ?  regs->sxip & ~3 : \
d73 7
d81 1
a81 1
#define BREAKPOINT (0xF000D1F8U) /* Single Step Breakpoint */
d89 1
a89 1
#define DEBUG_MSG db_printf
d91 1
a91 1
#define DEBUG_MSG printf
d99 12
a110 12
char	*trap_type[] = {
	"Reset",
	"Interrupt Exception",
	"Instruction Access",
	"Data Access Exception",
	"Misaligned Access",
	"Unimplemented Opcode",
	"Privileg Violation",
	"Bounds Check Violation",
	"Illegal Integer Divide",
	"Integer Overflow",
	"Error Exception",
d113 9
a121 9
char	*pbus_exception_type[] = {
	"Success (No Fault)",
	"",
	"",
	"Bus Error",
	"Segment Fault",
	"Page Fault",
	"Supervisor Violation",
	"Write Violation",
d129 1
a129 1
int	trap_types = sizeof trap_type / sizeof trap_type[0];
d134 2
a135 2
	int sig;
	int s;
d137 29
a165 29
	/* take pending signals */
	while ((sig = CURSIG(p)) != 0)
		postsig(sig);
	p->p_priority = p->p_usrpri;

	if (want_resched) {
		/*
		 * Since we are curproc, clock will normally just change
		 * our priority without moving us from one queue to another
		 * (since the running process is not on a queue.)
		 * If that happened after we put ourselves on the run queue
		 * but before we switched, we might not be on the queue
		 * indicated by our priority.
		 */
		s = splstatclock();
		setrunqueue(p);
		p->p_stats->p_ru.ru_nivcsw++;
		mi_switch();
		(void) splx(s);
		while ((sig = CURSIG(p)) != 0)
			postsig(sig);
	}

	/*
	 * If profiling, charge recent system time to the trapped pc.
	 */
	if (p->p_flag & P_PROFIL)
		addupc_task(p, frame->sxip & ~3,
			 (int)(p->p_sticks - oticks));
d167 1
a167 1
	curpriority = p->p_priority;
d173 1
a173 1
	static int panicing = 0;
d175 17
a191 17
	if (panicing++ == 0) {
		if (type == 2) {	/* instruction exception */
			printf("Instr access fault (%s) v = %x, frame %x\n",
				pbus_exception_type[(frame->ipfsr >> 16) & 0x7],
				frame->sxip & ~3, frame);
		} else if (type == 3) {	/* data access exception */
			printf("Data access fault (%s) v = %x, frame %x\n",
				pbus_exception_type[(frame->dpfsr >> 16) & 0x7],
				frame->sxip & ~3, frame);
		} else
			printf("trap type %d, v = %x, frame %x\n", type, frame->sxip & ~3, frame);
		regdump(frame);
	}
	if ((u_int)type < trap_types)
		panic(trap_type[type]);
	panic("trap");
	/*NOTREACHED*/
d194 3
d201 43
a243 37
    struct proc *p;
    u_quad_t sticks = 0;
    vm_map_t map;
    vm_offset_t va;
    vm_prot_t ftype;
    int fault_type;
    u_long fault_code;
    unsigned nss, fault_addr;
    struct vmspace *vm;
    union sigval sv;
    int result;
    int sig = 0;
    unsigned pc = PC_REGS(frame);  /* get program counter (sxip) */

    extern vm_map_t kernel_map;
    extern int fubail(), subail();
    extern unsigned guarded_access_start;
    extern unsigned guarded_access_end;
    extern unsigned guarded_access_bad;

    cnt.v_trap++;
    if ((p = curproc) == NULL)
	p = &proc0;

    if (USERMODE(frame->epsr)) {
	sticks = p->p_sticks;
	type += T_USER;
	p->p_md.md_tf = frame;	/* for ptrace/signals */
	fault_type = 0;
	fault_code = 0;
    }

    switch(type)
    {
    default:
	panictrap(frame->vector, frame);
	/*NOTREACHED*/
d246 35
a280 35
    case T_KDB_BREAK:
	/*FALLTHRU*/
    case T_KDB_BREAK+T_USER:
    {
        int s = db_splhigh();
	db_enable_interrupt();
        ddb_break_trap(T_KDB_BREAK,(db_regs_t*)frame);
	db_disable_interrupt();
        db_splx(s);
        return;
    }
    case T_KDB_ENTRY:
	/*FALLTHRU*/
    case T_KDB_ENTRY+T_USER:
    {
        int s = db_splhigh();
	db_enable_interrupt();
        ddb_entry_trap(T_KDB_ENTRY,(db_regs_t*)frame);
	db_disable_interrupt();
        db_splx(s);
        return;
    }

#if 0
    case T_ILLFLT:
    {
        int s = db_splhigh();
	db_enable_interrupt();
        ddb_error_trap(type == T_ILLFLT ? "unimplemented opcode" :
            "error fault", (db_regs_t*)frame);
	db_disable_interrupt();
        db_splx(s);
        return;
    }
#endif /* 0 */
d282 148
d431 69
a499 69
    case T_MISALGNFLT:
        DEBUG_MSG("kernel misalgined "
		"access exception @@ 0x%08x\n", frame->sxip);
	panictrap(frame->vector, frame);
	break;

    case T_INSTFLT:
	/* kernel mode instruction access fault.
	 * Should never, never happen for a non-paged kernel.
	 */
        DEBUG_MSG("kernel mode instruction "
		"page fault @@ 0x%08x\n", frame->sxip);
	panictrap(frame->vector, frame);
	break;

    case T_DATAFLT:
	/* kernel mode data fault */
	/*
	 * If the faulting address is in user space, handle it in
	 * the context of the user process. Else, use kernel map.
	 */

	if (type == T_DATAFLT) {
		fault_addr = frame->dma0;
		if (frame->dmt0 & (DMT_WRITE|DMT_LOCKBAR)) {
		    ftype = VM_PROT_READ|VM_PROT_WRITE;
		    fault_code = VM_PROT_WRITE;
		} else {
		    ftype = VM_PROT_READ;
		    fault_code = VM_PROT_READ;
		}
	} else {
		fault_addr = frame->sxip & XIP_ADDR;
		ftype = VM_PROT_READ;
		fault_code = VM_PROT_READ;
	}

	va = trunc_page((vm_offset_t)fault_addr);

	vm = p->p_vmspace;
	map = &vm->vm_map;

	/* data fault on a kernel address... */
	if (frame->dmt0 & DMT_DAS)
		map = kernel_map;

	/* 
	 * We don't want to call vm_fault() if it is fuwintr() or
	 * suwintr(). These routines are for copying from interrupt
	 * context and vm_fault() can potentially sleep. You may
	 * wonder if it isn't bad karma for an interrupt handler to	
	 * touch the current process. Indeed it is, but clock interrupt
	 * does it while doing profiling. It is OK in that context.
	 */

	if (p->p_addr->u_pcb.pcb_onfault == (int)fubail ||
		p->p_addr->u_pcb.pcb_onfault == (int)subail)
		goto outtahere;

	/* data fault on the user address */
	if (type == T_DATAFLT && (frame->dmt0 & DMT_DAS) == 0)
	{
		type = T_DATAFLT + T_USER;
		goto user_fault;
	}

	/*
	 *	If it is a guarded access, bus error is OK.
	 */
d501 6
a506 8
	if ((frame->dpfsr >> 16 & 0x7) == 0x3) {
#ifdef DIAGNOSTIC 
#if DDB
		printf("sxip %x dpfsr %x\n", frame->sxip, frame->dpfsr);
		gimmeabreak();
#endif
#endif
	}
d508 45
a552 79
	if ((frame->dpfsr >> 16 & 0x7) == 0x3 && 		/* bus error */
		(frame->sxip & ~3) >= (unsigned)&guarded_access_start &&
		(frame->sxip & ~3) <= (unsigned)&guarded_access_end) {

		frame->snip = ((unsigned)&guarded_access_bad    ) | FIP_V;
		frame->sfip = ((unsigned)&guarded_access_bad + 4) | FIP_V;
		frame->sxip = 0;
		frame->dmt0 = 0;/* XXX what about other trans. in data unit */
		frame->dpfsr = 0;
		return;
	}
	/*
	 *	On a segment or a page fault, call vm_fault() to resolve
	 *	the fault.
	 */

	if ((frame->dpfsr >> 16 & 0x7) == 0x4 			/* seg fault */
			|| (frame->dpfsr >> 16 & 0x7) == 0x5) { /* page fault */
		result = vm_fault(map, va, ftype, FALSE); 

		if (result == KERN_SUCCESS) {
			/*
			 * We could resolve the fault. Call
			 * data_access_emulation to drain the data unit pipe
			 * line and reset dmt0 so that trap won't get called
			 * again. For inst faults, back up the pipe line.
			 */
			if (type == T_DATAFLT) {
			    data_access_emulation(frame);
			    frame->dmt0 = 0;
			    frame->dpfsr = 0;
			} else {
			    frame->sfip = frame->snip & ~FIP_E;
			    frame->snip = frame->sxip & ~NIP_E;
			}	
			return;
		}
	}

	/*
	 * if still the fault is not resolved ...
	 */
	if (!p->p_addr->u_pcb.pcb_onfault)
		panictrap(frame->vector, frame);

    outtahere:
	frame->snip = ((unsigned)p->p_addr->u_pcb.pcb_onfault    ) | FIP_V;
	frame->sfip = ((unsigned)p->p_addr->u_pcb.pcb_onfault + 4) | FIP_V;
	frame->sxip = 0;
	frame->dmt0 = 0;	/* XXX what about other trans. in data unit */
	frame->dpfsr = 0;
	return;

    case T_INSTFLT+T_USER:
	/* User mode instruction access fault */
	/*FALLTHRU*/
    case T_DATAFLT+T_USER:
    user_fault:

	if (type == T_INSTFLT+T_USER){
		fault_addr = frame->sxip & XIP_ADDR;
	}else{
		fault_addr = frame->dma0;
	}
	
	if (frame->dmt0 & (DMT_WRITE|DMT_LOCKBAR)) {
	    ftype = VM_PROT_READ|VM_PROT_WRITE;
	    fault_code = VM_PROT_WRITE;
	} else {
	    ftype = VM_PROT_READ;
	    fault_code = VM_PROT_READ;
	}

	va = trunc_page((vm_offset_t)fault_addr);

	vm = p->p_vmspace;
	map = &vm->vm_map;

	/* Call vm_fault() to resolve non-bus error faults */
d554 2
a555 2
	if ((frame->ipfsr >> 16 & 0x7) != 0x3 &&
		(frame->dpfsr >> 16 & 0x7) != 0x3) {
d557 97
a653 2
		result = vm_fault(map, va, ftype, FALSE); 
		frame->ipfsr = frame->dpfsr = 0;
d655 328
a982 2
/*	printf("vm_fault(%x, %x, %x, 0) -> %x\n",
	       map, va, ftype, result);
a983 1
	}
d985 59
a1043 30
	if ((caddr_t)va >= vm->vm_maxsaddr) {
		if (result == KERN_SUCCESS) {
			nss = clrnd(btoc(USRSTACK - va));/* XXX check this */
			if (nss > vm->vm_ssize)
				vm->vm_ssize = nss;
		} else if (result == KERN_PROTECTION_FAILURE)
			result = KERN_INVALID_ADDRESS;
	}

        if (result == KERN_SUCCESS) {
		if (type == T_DATAFLT+T_USER) {
			/*
			 * We could resolve the fault. Call
			 * data_access_emulation to drain the data unit
			 * pipe line and reset dmt0 so that trap won't
			 * get called again.
			 */
			data_access_emulation(frame);
			frame->dmt0 = 0;
			frame->dpfsr = 0;
		} else {
		    /* back up SXIP, SNIP clearing the the Error bit */
		    frame->sfip = frame->snip & ~FIP_E;
		    frame->snip = frame->sxip & ~NIP_E;
		}
	} else {
		sig = result == KERN_PROTECTION_FAILURE ? SIGBUS : SIGSEGV;
		fault_type = result == KERN_PROTECTION_FAILURE ? BUS_ADRERR
					: SEGV_MAPERR;
	}
d1045 1
a1045 3
	break;

    case T_MISALGNFLT+T_USER:
d1047 2
a1048 2
	sig = SIGBUS;
	fault_type = BUS_ADRALN;
d1050 1
a1050 51
	break;

    case T_PRIVINFLT+T_USER:
    case T_ILLFLT+T_USER:
	sig = SIGILL;
	break;

    case T_BNDFLT+T_USER:
	sig = SIGFPE;
	break;
    case T_ZERODIV+T_USER:
	sig = SIGFPE;
	fault_type = FPE_INTDIV;
	break;
    case T_OVFFLT+T_USER:
	sig = SIGFPE;
	fault_type = FPE_INTOVF;
	break;

    case T_FPEPFLT+T_USER:
    case T_FPEIFLT+T_USER:
	sig = SIGFPE;
	break;

    case T_SIGTRAP+T_USER:
	sig = SIGTRAP;
	fault_type = TRAP_TRACE;
	break;

    case T_STEPBPT+T_USER:
	/*
	 * This trap is used by the kernel to support single-step
	 * debugging (although any user could generate this trap
	 * which should probably be handled differently). When a
	 * process is continued by a debugger with the PT_STEP
	 * function of ptrace (single step), the kernel inserts
	 * one or two breakpoints in the user process so that only
	 * one instruction (or two in the case of a delayed branch)
	 * is executed.  When this breakpoint is hit, we get the
	 * T_STEPBPT trap.
	 */
#if 0
	frame->sfip = frame->snip;    /* set up next FIP */
	frame->snip = frame->sxip;    /* set up next NIP */
	break;
#endif
    {
	register unsigned va;
	unsigned instr;
	struct uio uio;
	struct iovec iov;
d1052 61
a1112 11
	/* compute address of break instruction */
	va = pc;

	/* read break instruction */
	instr = fuiword((caddr_t)pc);
#if 1
	printf("trap: %s (%d) breakpoint %x at %x: (adr %x ins %x)\n",
		p->p_comm, p->p_pid, instr, pc,
		p->p_md.md_ss_addr, p->p_md.md_ss_instr); /* XXX */
#endif
	/* check and see if we got here by accident */
d1114 5
a1118 5
	if (p->p_md.md_ss_addr != pc || instr != BREAKPOINT) {
		sig = SIGTRAP;
		fault_type = TRAP_TRACE;
		break;
	}
d1120 71
a1190 67
	/* restore original instruction and clear BP  */
	/*sig = suiword((caddr_t)pc, p->p_md.md_ss_instr);*/
	instr = p->p_md.md_ss_instr;
	if (instr == 0){
		printf("Warning: can't restore instruction at %x: %x\n",
			p->p_md.md_ss_addr, p->p_md.md_ss_instr);
	} else {
		iov.iov_base = (caddr_t)&instr;
		iov.iov_len = sizeof(int); 
		uio.uio_iov = &iov;
		uio.uio_iovcnt = 1; 
		uio.uio_offset = (off_t)pc;
		uio.uio_resid = sizeof(int);
		uio.uio_segflg = UIO_SYSSPACE;
		uio.uio_rw = UIO_WRITE;
		uio.uio_procp = curproc;
	}

	frame->sfip = frame->snip;    /* set up next FIP */
	frame->snip = frame->sxip;    /* set up next NIP */
	frame->snip |= 2;	      /* set valid bit   */	    	
	p->p_md.md_ss_addr = 0;
	sig = SIGTRAP;
	fault_type = TRAP_BRKPT;
	break;
    }

    case T_USERBPT+T_USER:
	/*
	 * This trap is meant to be used by debuggers to implement
	 * breakpoint debugging.  When we get this trap, we just
	 * return a signal which gets caught by the debugger.
	 */
	frame->sfip = frame->snip;    /* set up the next FIP */
	frame->snip = frame->sxip;    /* set up the next NIP */
	sig = SIGTRAP;
	fault_type = TRAP_BRKPT;
	break;

    case T_ASTFLT+T_USER:
	want_ast = 0;
	if (p->p_flag & P_OWEUPC) {
		p->p_flag &= ~P_OWEUPC;
		ADDUPROF(p);
	}
	break;
    }

    /*
     * If trap from supervisor mode, just return
     */
    if (SYSTEMMODE(frame->epsr))
	 return;

    if (sig) {
/*	trapsignal(p, sig, fault_code, fault_type, (caddr_t)fault_addr); */
	sv.sival_int = fault_addr;
	trapsignal(p, sig, fault_code, fault_type, sv);
	/*		
         * don't want multiple faults - we are going to
	 * deliver signal.
	 */
	frame->dmt0 = 0;
	frame->dpfsr = 0;
    }

    userret(p, frame, sticks);
d1196 3
a1198 3
    DEBUG_MSG("\n[test_trap (Good News[tm]) frame 0x%08x]\n", frame);
    regdump((struct trapframe*)frame);
    bugreturn();
d1203 3
a1205 2
    DEBUG_MSG("\n[ERROR FAULT (Bad News[tm]) frame 0x%08x]\n", frame);

d1207 3
a1209 3
    gimmeabreak();
    DEBUG_MSG("[you really can't restart after an error fault.]\n");
    gimmeabreak();
d1211 1
a1211 1
    bugreturn();  /* This gets us to Bug instead of a loop forever */
d1217 3
a1219 1
    DEBUG_MSG("\n[ERROR RESET (Really Bad News[tm]) frame 0x%08x]\n", frame);
d1222 3
a1224 3
    gimmeabreak();
    DEBUG_MSG("[It's useless to restart after an error reset. You might as well reboot.]\n");
    gimmeabreak();
d1226 1
a1226 1
    bugreturn();  /* This gets us to Bug instead of a loop forever */
d1231 10
a1240 10
	register int i, nsys, *ap, nap;
	register struct sysent *callp;
	register struct proc *p;
	int error, new;
	struct args {
		int i[8];
	} args;
	int rval[2];
	u_quad_t sticks;
	extern struct pcb *curpcb;
d1242 1
a1242 1
	cnt.v_syscall++;
d1244 1
a1244 1
	p = curproc;
d1246 2
a1247 2
	callp = p->p_emul->e_sysent;
	nsys  = p->p_emul->e_nsysent;
d1250 55
a1304 6
	if (USERMODE(tf->epsr) == 0)
		panic("syscall");
	if (curpcb != &p->p_addr->u_pcb)
		panic("syscall curpcb/ppcb");
	if (tf != (struct trapframe *)&curpcb->user_state)
		panic("syscall trapframe");
d1306 91
d1398 1
a1398 2
	sticks = p->p_sticks;
	p->p_md.md_tf = tf;
d1400 1
a1400 22
	/*
	 * For 88k, all the arguments are passed in the registers (r2-r12)
	 * For syscall (and __syscall), r2 (and r3) has the actual code.
	 * __syscall  takes a quad syscall number, so that other
	 * arguments are at their natural alignments.
	 */
	ap = &tf->r[2];
	nap = 6;

	switch (code) {
	case SYS_syscall:
		code = *ap++;
		nap--;
		break;
	case SYS___syscall:
		if (callp != sysent)
			break;
		code = ap[_QUAD_LOWWORD];
		ap += 2;
		nap -= 2;
		break;
	}
d1402 53
a1454 15
	/* Callp currently points to syscall, which returns ENOSYS. */
 
	if (code < 0 || code >= nsys)
		callp += p->p_emul->e_nosys;
	else {
		callp += code;
		i = callp->sy_argsize / sizeof(register_t);
		if (i > 8)
			panic("syscall nargs");
		/*
		 * just copy them; syscall stub made sure all the
		 * args are moved from user stack to registers.
		 */
		bcopy((caddr_t)ap, (caddr_t)args.i, i * sizeof(register_t));
	}
d1456 1
a1456 1
	scdebug_call(p, code, args.i);
d1459 2
a1460 2
	if (KTRPOINT(p, KTR_SYSCALL))
		ktrsyscall(p->p_tracep, code, callp->sy_argsize, args.i);
d1462 64
a1525 68
	rval[0] = 0;
	rval[1] = 0;
	error = (*callp->sy_call)(p, &args, rval);
	/*
	 * system call will look like:
	 *	 ld r10, r31, 32; r10,r11,r12 might be garbage.
	 *	 ld r11, r31, 36
	 *	 ld r12, r31, 40
	 *	 or r13, r0, <code>
	 *       tb0 0, r0, <128> <- xip
	 *	 br err 	  <- nip
	 *       jmp r1 	  <- fip
	 *  err: or.u r3, r0, hi16(errno)
	 *	 st r2, r3, lo16(errno)
	 *	 subu r2, r0, 1 
	 *	 jmp r1
	 *
	 * So, when we take syscall trap, sxip/snip/sfip will be as
	 * shown above.
	 * Given this,
	 * 1. If the system call returned 0, need to skip nip.
	 *	nip = fip, fip += 4
	 *    (doesn't matter what fip + 4 will be but we will never
	 *    execute this since jmp r1 at nip will change the execution flow.)
	 * 2. If the system call returned an errno > 0, plug the value
	 *    in r2, and leave nip and fip unchanged. This will have us
	 *    executing "br err" on return to user space.
	 * 3. If the system call code returned ERESTART,
	 *    we need to rexecute the trap instruction. Back up the pipe
	 *    line.
	 *     fip = nip, nip = xip
	 * 4. If the system call returned EJUSTRETURN, don't need to adjust
	 *    any pointers.
	 */

	if (error == 0) {
		/*
		 * If fork succeeded and we are the child, our stack
		 * has moved and the pointer tf is no longer valid,
		 * and p is wrong.  Compute the new trapframe pointer.
		 * (The trap frame invariably resides at the
		 * tippity-top of the u. area.)
		 */
		p = curproc;
		tf = USER_REGS(p);
		tf->r[2] = rval[0];
		tf->r[3] = rval[1];
		tf->epsr &= ~PSR_C;
		tf->snip = tf->sfip & ~FIP_E;
		tf->sfip = tf->snip + 4;
	} else if (error > 0) {
		/* error != ERESTART && error != EJUSTRETURN*/
		tf->r[2] = error;
		tf->epsr |= PSR_C;	/* fail */
		tf->snip = tf->snip & ~NIP_E;
		tf->sfip = tf->sfip & ~FIP_E;
	} else if (error == ERESTART) {
		/*
		 * If (error == ERESTART), back up the pipe line. This
		 * will end up reexecuting the trap.
		 */
		tf->epsr &= ~PSR_C;
		tf->sfip = tf->snip & ~NIP_E;
		tf->snip = tf->sxip & ~NIP_E;
	} else {
		/* if (error == EJUSTRETURN), leave the ip's alone */
		tf->epsr &= ~PSR_C;
	}
d1527 1
a1527 1
	scdebug_ret(p, code, error, rval);
d1529 1
a1529 1
	userret(p, tf, sticks);
d1531 2
a1532 2
	if (KTRPOINT(p, KTR_SYSRET))
		ktrsysret(p->p_tracep, code, error, rval[0]);
d1543 1
a1543 1
	struct trapframe *tf;
d1545 11
a1555 6
	tf = USER_REGS(p);
	tf->r[2] = 0;
	tf->r[3] = 0;
	tf->epsr &= ~PSR_C;
	tf->snip = tf->sfip & ~3;
	tf->sfip = tf->snip + 4;
d1557 1
a1557 1
	userret(p, tf, p->p_sticks);
d1559 2
a1560 2
	if (KTRPOINT(p, KTR_SYSRET))
		ktrsysret(p->p_tracep, SYS_fork, 0, 0);
d1569 2
a1570 2
	void (*proc)();
	void *arg;
d1572 1
a1572 1
	int bit;
d1574 6
a1579 6
	if (next_sir >= NSIR)
		panic("allocate_sir: none left");
	bit = next_sir++;
	sir_routines[bit] = proc;
	sir_args[bit] = arg;
	return (1 << bit);
d1585 1
a1585 1
	extern void netintr();
d1587 3
a1589 3
	sir_routines[0] = netintr;
	sir_routines[1] = softclock;
	next_sir = 2;
d1597 2
a1598 8
/*
 * Read bytes from address space for debugger.
 */
void
ss_read_bytes(addr, size, data)
	unsigned     	addr;
	register int    size;
	register char   *data;
d1600 15
a1614 7
    register char	*src;

    src = (char *)addr;

    while(--size >= 0) {
	*data++ = *src++;
    }
d1617 2
a1618 2
unsigned 
ss_get_value(unsigned addr, int size, int is_signed)
d1620 15
a1634 14
	char data[sizeof(unsigned)];
	unsigned value, extend;
	int i;

	ss_read_bytes(addr, size, data);

	value = 0;
	extend = (~(db_expr_t)0) << (size * 8 - 1);
	for (i = 0; i < size; i++)
		value = (value << 8) + (data[i] & 0xFF);
	    
	if (size < sizeof(unsigned) && is_signed && (value & extend))
		value |= extend;
	return (value);
a1636 1

d1650 4
a1653 4
    unsigned inst,
    unsigned pc,
    unsigned (*func)(unsigned int, struct trapframe *),
    struct trapframe *func_data)  /* 'opaque' */
d1656 2
a1657 3
  /* check if br/bsr */
  if ((inst & 0xf0000000U) == 0xc0000000U)
    {
d1662 1
a1662 15
	inst |= 0xf0000000U;
      return pc + inst;
    }

  /* check if bb0/bb1/bcnd case */
  switch ((inst & 0xf8000000U))
    {
    case 0xd0000000U: /* bb0 */
    case 0xd8000000U: /* bb1 */
    case 0xe8000000U: /* bcnd */
      /* signed 16 bit pc relative displacement, shift left two bits */
      inst = (inst & 0x0000ffffU)<<2;
      /* check if sign extension is needed */
      if (inst & 0x00020000U)
	inst |= 0xfffc0000U;
d1664 1
a1664 1
    }
d1666 17
a1682 4
  /* check jmp/jsr case */
  /* check bits 5-31, skipping 10 & 11 */
  if ((inst & 0xfffff3e0U) == 0xf400c000U)
    return (*func)(inst & 0x1f, func_data);  /* the register value */
d1684 1
a1684 1
  return 0; /* keeps compiler happy */
d1695 47
a1741 7
    if (regno == 0)
	return 0;
    else if (regno < 31)
	return tf->r[regno];
    else {
	panic("bad register number to ss_getreg_val.");
	return 0;/*to make compiler happy */
d1743 4
d1749 2
a1750 2
unsigned 
ss_get_next_addr(struct trapframe *regs)
d1752 9
a1760 8
    unsigned inst;
    unsigned pc = PC_REGS(regs);
    unsigned addr = 0;
    
    inst = ss_get_value(pc, sizeof(int), FALSE);
    addr = ss_branch_taken(inst, pc, ss_getreg_val, regs);
    if (addr) return(addr);
    return(pc + 4);
d1765 1
a1765 1
	register struct proc *p;
d1767 60
a1826 67
	register unsigned va;
	struct trapframe *sstf = p->p_md.md_tf;
	int i;

	int bpinstr = BREAKPOINT;
	int curinstr;
	struct uio uio;
	struct iovec iov;

	/*
	 * Fetch what's at the current location.
	 */
	iov.iov_base = (caddr_t)&curinstr;
	iov.iov_len = sizeof(int); 
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1; 
	uio.uio_offset = (off_t)sstf->sxip;
	uio.uio_resid = sizeof(int);
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_READ;
	uio.uio_procp = curproc;
	procfs_domem(curproc, p, NULL, &uio);

	/* compute next address after current location */
	if(curinstr != 0) {
		va = ss_get_next_addr(sstf);
		printf("SS %s (%d): next breakpoint set at %x\n", 
			p->p_comm, p->p_pid, va);
	}
	else {
		va = PC_REGS(sstf) + 4;
	}
	if (p->p_md.md_ss_addr) {
		printf("SS %s (%d): breakpoint already set at %x (va %x)\n",
			p->p_comm, p->p_pid, p->p_md.md_ss_addr, va); /* XXX */
		return (EFAULT);
	}
	
	p->p_md.md_ss_addr = va;

	/*
	 * Fetch what's at the current location.
	 */
	iov.iov_base = (caddr_t)&p->p_md.md_ss_instr;
	iov.iov_len = sizeof(int); 
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1; 
	uio.uio_offset = (off_t)va;
	uio.uio_resid = sizeof(int);
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_READ;
	uio.uio_procp = curproc;
	procfs_domem(curproc, p, NULL, &uio);

	/*
	 * Store breakpoint instruction at the "next" location now.
	 */
	iov.iov_base = (caddr_t)&bpinstr;
	iov.iov_len = sizeof(int); 
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1; 
	uio.uio_offset = (off_t)va;
	uio.uio_resid = sizeof(int);
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_WRITE;
	uio.uio_procp = curproc;
	i = procfs_domem(curproc, p, NULL, &uio);
d1828 2
a1829 2
	if (i < 0) return (EFAULT);
	return (0);
@


1.6
log
@Added kernel support for user debugging.  Fixed file ID's
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.28 1995/04/19 22:37:27 smurph Exp $	*/
d60 1
d66 3
d70 1
d199 1
d401 1
a401 1
	if (type == T_INSTFLT+T_USER)
d403 1
a403 1
	else
d405 2
a406 1

d512 47
d561 4
d566 1
d848 203
@


1.5
log
@Commit for the first working mvme88k port.
@
text
@d1 1
a514 1

@


1.4
log
@Cleanup after import. This also seems to bring up the current version.
@
text
@d2 1
d47 1
a50 1
#include <sys/param.h>
d106 5
d190 1
d328 1
d332 1
d420 3
a424 1

d459 1
d462 1
d537 4
a540 2
	trapsignal(p, sig, fault_code, fault_type, (caddr_t)fault_addr);
	/*
d552 7
d562 2
a563 1
#if DDB
d568 14
d760 28
@


1.3
log
@This is a remove to get rid of the old mvme88k port which was incomplete
to replace it with a working version. The kernel compiles and works
at least.  The new version will be imported shortly.
@
text
@d2 30
d33 1
a33 1
 * Copyright (c) 1993-1991 Carnegie Mellon University
a42 13
 * CARNEGIE MELLON AND OMRON ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON AND OMRON DISCLAIM ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
a64 2
int stop_on_user_memory_error = 0;

a75 5
#ifdef JEFF_DEBUG
# undef  DEBUG_MSG
# define DEBUG_MSG raw_printf
#endif

d95 11
d112 1
a118 8
	if (want_ast) {
		want_ast = 0;
		if (p->p_flag & P_OWEUPC) {
			p->p_flag &= ~P_OWEUPC;
			ADDUPROF(p);
		}
	}

d128 1
a128 1
		(void) splstatclock();
d132 1
a132 1
		(void) spl0();
d151 1
d153 10
a162 1
		printf("trap type %d, v = %x, frame %x\n", type, frame->sxip & ~3, frame);
d180 2
d189 3
d201 2
d217 1
a217 1
        db_enable_interrupt(); /* turn interrupts on */
d219 1
a219 1
        db_disable_interrupt(); /* shut them back off */
d228 1
a228 1
        db_enable_interrupt(); /* turn interrupts on */
d230 1
a230 1
        db_disable_interrupt(); /* shut them back off */
d239 1
a239 1
        db_enable_interrupt(); /* turn interrupts on */
d242 1
a242 1
        db_disable_interrupt(); /* shut them back off */
d256 2
a257 4
	/* kernel mode instruction access fault */
	/* XXX I think this should be illegal, but not sure. Will leave
	 * the way it is for now. Should never,never happen for a non-paged
	 * kernel
d259 5
a263 1
	/*FALLTHRU*/
d267 1
a267 1
	 * if the faulting address is in user space, handle it in
d273 1
a273 1
		if (frame->dmt0 & (DMT_WRITE|DMT_LOCKBAR))
d275 2
a276 1
		else
d278 2
d283 1
d291 2
a292 2
	/* if instruction fault or data fault on a kernel address... */
	if ((type == T_INSTFLT) || (frame->dmt0 & DMT_DAS))
d294 1
a294 1
	
d298 4
a301 1
	 * context and vm_fault() can potentially sleep.
d308 10
a317 1
	result = vm_fault(map, va, ftype, FALSE); 
d319 16
a334 14
        if (result == KERN_SUCCESS) {
		/*
		 * We could resolve the fault. Call data_access_emulation
		 * to drain the data unit pipe line and reset dmt0 so that
		 * trap won't get called again. For inst faults, back up
		 * the pipe line.
		 */
		if (type == T_DATAFLT) {
		    data_access_emulation(frame);
		    frame->dmt0 = 0;
		} else {
		    frame->sfip = frame->snip & ~FIP_E;
		    frame->snip = frame->sxip & ~NIP_E;
		}	
d337 4
d342 22
a363 3
	/* XXX Is this right? */
	if (type == T_DATAFLT && (frame->dmt0 & DMT_DAS) == 0)
		goto user_fault;
d376 1
d384 1
a384 1
	sig = SIGILL;
d389 2
a390 1
	if (frame->dmt0 & (DMT_WRITE|DMT_LOCKBAR))
d392 2
a393 1
	else
d395 2
d403 10
a412 1
	result = vm_fault(map, va, ftype, FALSE); 
d416 1
a416 1
			nss = clrnd(USRSTACK - va);/* XXX check this */
d433 1
d440 3
a442 1
		sig = result == SIGSEGV;
d449 1
d458 2
d461 3
d465 2
a466 1
	sig = SIGBUS;
a473 20
    case T_ASTFLT+T_USER:
	want_ast = 0;
	(void) spl0();
	if (ssir & SIR_NET) {
		siroff(SIR_NET);
		cnt.v_soft++;
		netintr();
	}
	if (ssir & SIR_CLOCK) {
		siroff(SIR_CLOCK);
		cnt.v_soft++;
		/* XXXX softclock(&frame.f_stackadj); */
		softclock();
	}
	if (p->p_flag & P_OWEUPC) {
		p->p_flag &= ~P_OWEUPC;
		ADDUPROF(p);
	}
	break;

d475 2
d504 2
d508 7
d524 1
a524 1
	trapsignal(p, sig, frame->vector);
d530 1
d536 2
a537 1
void error_fault(struct m88100_saved_state *frame)
d547 1
a547 1
syscall(u_int code, struct m88100_saved_state *tf)
d562 2
a566 1
	p = curproc;
d572 1
a572 1
	if (tf != (struct trapframe *)((caddr_t)curpcb))
d608 1
a608 1
		i = callp->sy_narg;
d615 1
a615 1
		bcopy((caddr_t)ap, (caddr_t)args.i, i * 4);
d617 3
d622 1
a622 1
		ktrsyscall(p->p_tracep, code, callp->sy_narg, args.i);
d625 1
a625 1
	rval[1] = 0;	/* doesn't seem to be used any where */
d651 1
a651 1
	 * 3. If the system call code returned ERESTART or EJUSTRETURN,
d655 2
d669 2
a670 1
		tf->r[2] = 0;
d672 1
a672 1
		tf->snip = tf->sfip & ~3;
d674 2
a675 2
	} else if (error > 0 /*error != ERESTART && error != EJUSTRETURN*/) {
bad:
d678 10
a687 2
		tf->snip = tf->snip & ~3;
		tf->sfip = tf->sfip & ~3;
d689 2
a690 4
	/* if (error == ERESTART || error == EJUSTRETURN) 
		back up the pipe line */
		tf->sfip = tf->snip & ~3;
		tf->snip = tf->sxip & ~3;
d692 3
a701 2
#if     MACH_PCSAMPLE > 0
#include "mach_pcsample.h"
d703 2
a704 1
 * return saved state for interrupted user thread
d706 2
a707 2
unsigned interrupted_pc(p)
proc *p;
d709 14
a722 4
    struct m88100_saved_state *frame = &p->pcb->user_state;
    unsigned sxip = frame->sxip;
    unsigned PC = sxip & ~3; /* clear lower bits which are flags... */
    return PC;
a723 1
#endif  /* MACH_PCSAMPLE > 0*/
@


1.2
log
@SIGBUS is an alignment fault. SIGSEGV is an access violation
@
text
@@


1.1
log
@moved from m88k directory
@
text
@d351 1
a351 1
		sig = result == KERN_PROTECTION_FAILURE ? SIGBUS : SIGSEGV;
@


1.1.1.1
log
@Third try at importing the mvme88k port. This is a working kernel
from nivas.
Userland and compiler still need to be worked on.
Make certain what directory the import is done from.
@
text
@a1 30
 * Copyright (c) 1996 Nivas Madhur
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Nivas Madhur.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
/*
d3 1
a3 1
 * Copyright (c) 1991 Carnegie Mellon University
d13 13
d48 2
d61 5
a84 11
char	*pbus_exception_type[] = {
	"Success (No Fault)",
	"",
	"",
	"Bus Error",
	"Segment Fault",
	"Page Fault",
	"Supervisor Violation",
	"Write Violation",
};

a90 1
	int s;
d97 8
d114 1
a114 1
		s = splstatclock();
d118 1
a118 1
		(void) splx(s);
a136 1

d138 1
a138 10
		if (type == 2) {	/* instruction exception */
			printf("Instr access fault (%s) v = %x, frame %x\n",
				pbus_exception_type[(frame->ipfsr >> 16) & 0x7],
				frame->sxip & ~3, frame);
		} else if (type == 3) {	/* data access exception */
			printf("Data access fault (%s) v = %x, frame %x\n",
				pbus_exception_type[(frame->dpfsr >> 16) & 0x7],
				frame->sxip & ~3, frame);
		} else
			printf("trap type %d, v = %x, frame %x\n", type, frame->sxip & ~3, frame);
a155 2
    int fault_type;
    u_long fault_code;
a162 3
    extern unsigned guarded_access_start;
    extern unsigned guarded_access_end;
    extern unsigned guarded_access_bad;
a171 2
	fault_type = 0;
	fault_code = 0;
d186 1
a186 1
	db_enable_interrupt();
d188 1
a188 1
	db_disable_interrupt();
d197 1
a197 1
	db_enable_interrupt();
d199 1
a199 1
	db_disable_interrupt();
d208 1
a208 1
	db_enable_interrupt();
d211 1
a211 1
	db_disable_interrupt();
d225 4
a228 2
	/* kernel mode instruction access fault.
	 * Should never, never happen for a non-paged kernel.
d230 1
a230 5
        DEBUG_MSG("kernel mode instruction "
		"page fault @@ 0x%08x\n", frame->sxip);
	panictrap(frame->vector, frame);
	break;

d234 1
a234 1
	 * If the faulting address is in user space, handle it in
d240 1
a240 1
		if (frame->dmt0 & (DMT_WRITE|DMT_LOCKBAR)) {
d242 1
a242 2
		    fault_code = VM_PROT_WRITE;
		} else {
a243 2
		    fault_code = VM_PROT_READ;
		}
a246 1
		fault_code = VM_PROT_READ;
d254 2
a255 2
	/* data fault on a kernel address... */
	if (frame->dmt0 & DMT_DAS)
d257 1
a257 1

d261 1
a261 4
	 * context and vm_fault() can potentially sleep. You may
	 * wonder if it isn't bad karma for an interrupt handler to	
	 * touch the current process. Indeed it is, but clock interrupt
	 * does it while doing profiling. It is OK in that context.
d268 1
a268 10
	/* data fault on the user address */
	if (type == T_DATAFLT && (frame->dmt0 & DMT_DAS) == 0)
	{
		type = T_DATAFLT + T_USER;
		goto user_fault;
	}

	/*
	 *	If it is a guarded access, bus error is OK.
	 */
d270 14
a283 16
	if ((frame->dpfsr >> 16 & 0x7) == 0x3) {
#ifdef DIAGNOSTIC 
		printf("sxip %x dpfsr %x\n", frame->sxip, frame->dpfsr);
		gimmeabreak();
#endif
	}

	if ((frame->dpfsr >> 16 & 0x7) == 0x3 && 		/* bus error */
		(frame->sxip & ~3) >= (unsigned)&guarded_access_start &&
		(frame->sxip & ~3) <= (unsigned)&guarded_access_end) {

		frame->snip = ((unsigned)&guarded_access_bad    ) | FIP_V;
		frame->sfip = ((unsigned)&guarded_access_bad + 4) | FIP_V;
		frame->sxip = 0;
		frame->dmt0 = 0;/* XXX what about other trans. in data unit */
		frame->dpfsr = 0;
a285 4
	/*
	 *	On a segment or a page fault, call vm_fault() to resolve
	 *	the fault.
	 */
d287 3
a289 22
	if ((frame->dpfsr >> 16 & 0x7) == 0x4 			/* seg fault */
			|| (frame->dpfsr >> 16 & 0x7) == 0x5) { /* page fault */
		result = vm_fault(map, va, ftype, FALSE); 

		if (result == KERN_SUCCESS) {
			/*
			 * We could resolve the fault. Call
			 * data_access_emulation to drain the data unit pipe
			 * line and reset dmt0 so that trap won't get called
			 * again. For inst faults, back up the pipe line.
			 */
			if (type == T_DATAFLT) {
			    data_access_emulation(frame);
			    frame->dmt0 = 0;
			    frame->dpfsr = 0;
			} else {
			    frame->sfip = frame->snip & ~FIP_E;
			    frame->snip = frame->sxip & ~NIP_E;
			}	
			return;
		}
	}
a301 1
	frame->dpfsr = 0;
d309 1
a309 1

d314 1
a314 2

	if (frame->dmt0 & (DMT_WRITE|DMT_LOCKBAR)) {
d316 1
a316 2
	    fault_code = VM_PROT_WRITE;
	} else {
a317 2
	    fault_code = VM_PROT_READ;
	}
d324 1
a324 10
	/* Call vm_fault() to resolve non-bus error faults */

	if ((frame->ipfsr >> 16 & 0x7) != 0x3 &&
		(frame->dpfsr >> 16 & 0x7) != 0x3) {

		result = vm_fault(map, va, ftype, FALSE); 
		frame->ipfsr = frame->dpfsr = 0;

	}

d328 1
a328 1
			nss = clrnd(btoc(USRSTACK - va));/* XXX check this */
a344 1
			frame->dpfsr = 0;
a351 2
		fault_type = result == KERN_PROTECTION_FAILURE ? BUS_ADRERR
					: SEGV_MAPERR;
a357 1
	fault_type = BUS_ADRALN;
a365 2
	sig = SIGFPE;
	break;
a366 3
	sig = SIGFPE;
	fault_type = FPE_INTDIV;
	break;
d368 1
a368 2
	sig = SIGFPE;
	fault_type = FPE_INTOVF;
d376 20
a396 2
	sig = SIGTRAP;
	fault_type = TRAP_TRACE;
a423 2
	sig = SIGTRAP;
	fault_type = TRAP_BRKPT;
a425 7
    case T_ASTFLT+T_USER:
	want_ast = 0;
	if (p->p_flag & P_OWEUPC) {
		p->p_flag &= ~P_OWEUPC;
		ADDUPROF(p);
	}
	break;
d435 1
a435 1
	trapsignal(p, sig, fault_code, fault_type, (caddr_t)fault_addr);
a440 1
	frame->dpfsr = 0;
d446 1
a446 2
void
error_fault(struct m88100_saved_state *frame)
d456 1
a456 1
syscall(register_t code, struct m88100_saved_state *tf)
a470 2
	p = curproc;

d474 1
d480 1
a480 1
	if (tf != (struct trapframe *)&curpcb->user_state)
d516 1
a516 1
		i = callp->sy_argsize / sizeof(register_t);
d523 1
a523 1
		bcopy((caddr_t)ap, (caddr_t)args.i, i * sizeof(register_t));
a524 3
#ifdef SYSCALL_DEBUG
	scdebug_call(p, code, args.i);
#endif
d527 1
a527 1
		ktrsyscall(p->p_tracep, code, callp->sy_argsize, args.i);
d530 1
a530 1
	rval[1] = 0;
d556 1
a556 1
	 * 3. If the system call code returned ERESTART,
a559 2
	 * 4. If the system call returned EJUSTRETURN, don't need to adjust
	 *    any pointers.
d572 1
a572 2
		tf->r[2] = rval[0];
		tf->r[3] = rval[1];
d574 1
a574 1
		tf->snip = tf->sfip & ~FIP_E;
d576 2
a577 2
	} else if (error > 0) {
		/* error != ERESTART && error != EJUSTRETURN*/
d580 2
a581 10
		tf->snip = tf->snip & ~NIP_E;
		tf->sfip = tf->sfip & ~FIP_E;
	} else if (error == ERESTART) {
		/*
		 * If (error == ERESTART), back up the pipe line. This
		 * will end up reexecuting the trap.
		 */
		tf->epsr &= ~PSR_C;
		tf->sfip = tf->snip & ~NIP_E;
		tf->snip = tf->sxip & ~NIP_E;
d583 4
a586 2
		/* if (error == EJUSTRETURN), leave the ip's alone */
		tf->epsr &= ~PSR_C;
a587 3
#ifdef SYSCALL_DEBUG
	scdebug_ret(p, code, error, rval);
#endif
d595 2
d598 1
a598 2
 * Set up return-value registers as fork() libc stub expects,
 * and do normal return-to-user-mode stuff.
d600 2
a601 2
void
child_return(struct proc *p)
d603 4
a606 14
	struct trapframe *tf;

	tf = USER_REGS(p);
	tf->r[2] = 0;
	tf->r[3] = 0;
	tf->epsr &= ~PSR_C;
	tf->snip = tf->sfip & ~3;
	tf->sfip = tf->snip + 4;

	userret(p, tf, p->p_sticks);
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET))
		ktrsysret(p->p_tracep, SYS_fork, 0, 0);
#endif
d608 1
@
