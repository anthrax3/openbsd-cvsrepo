head	1.17;
access;
symbols
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.14.0.22
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.20
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.18
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.16
	OPENBSD_5_0:1.14.0.14
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.12
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.10
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.6
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.8
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.4
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.2
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.13.0.8
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.6
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.4
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.11.0.6
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.4
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.10.0.4
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.8
	UBC:1.7.0.4
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.4.0.8
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.6
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.4
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.17
date	2014.03.18.22.36.37;	author miod;	state dead;
branches;
next	1.16;

1.16
date	2014.02.20.20.34.27;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2014.01.04.10.49.21;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2008.03.31.22.14.43;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2006.05.17.06.21.34;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2006.05.16.22.51.30;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2004.11.11.21.44.42;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2004.01.01.01.11.12;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.02.23.27.52;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.03.15.58;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.04.08.09.30;	author niklas;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	2001.06.29.21.53.35;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.13.05.19.01;	author smurph;	state Exp;
branches;
next	1.4;

1.4
date	99.09.27.19.30.01;	author smurph;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	98.12.15.06.32.34;	author smurph;	state Exp;
branches;
next	1.2;

1.2
date	98.08.22.08.12.42;	author smurph;	state Exp;
branches;
next	1.1;

1.1
date	98.08.22.08.08.10;	author smurph;	state Exp;
branches;
next	;

1.4.4.1
date	2001.04.18.16.11.51;	author niklas;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2001.07.04.10.20.27;	author niklas;	state Exp;
branches;
next	1.4.4.3;

1.4.4.3
date	2001.10.31.03.01.20;	author nate;	state Exp;
branches;
next	1.4.4.4;

1.4.4.4
date	2002.03.28.10.36.03;	author niklas;	state Exp;
branches;
next	1.4.4.5;

1.4.4.5
date	2003.06.07.11.13.17;	author ho;	state Exp;
branches;
next	1.4.4.6;

1.4.4.6
date	2004.02.19.10.49.09;	author niklas;	state Exp;
branches;
next	;

1.7.4.1
date	2002.06.11.03.37.11;	author art;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: exec_mvme.c,v 1.16 2014/02/20 20:34:27 miod Exp $	*/


/*-
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * 	@@(#)boot.c	8.1 (Berkeley) 6/10/93
 */

#include <sys/param.h>
#include <sys/reboot.h>
#include <machine/prom.h>

#include "stand.h"
#include "libsa.h"

#include <lib/libsa/loadfile.h>

char   rnddata[BOOTRANDOM_MAX];		/* set by bootsd only */

/*ARGSUSED*/
void
exec_mvme(file, flag)
	char    *file;
	int     flag;
{
	u_long marks[MARK_MAX];
	int options;
	int rc;
	void (*entry)(int, int, int, int, int, int, int);
	int bootdev;
	struct mvmeprom_brdid *id;

	id = mvmeprom_brdid();
	options = LOAD_KERNEL | COUNT_KERNEL;
	if ((flag & RB_NOSYM) != 0)
		options &= ~(LOAD_SYM | COUNT_SYM);

	marks[MARK_START] = 0;
	rc = loadfile(file, marks, options);
	if (rc != 0)
		return;

	printf("Start @@ 0x%lx\n", marks[MARK_START]);
	printf("Controller Address 0x%x\n", bugargs.ctrl_addr);
	if (flag & RB_HALT)
		_rtt();

	bootdev = (bugargs.ctrl_lun << 8) | (bugargs.dev_lun & 0xFF);
	entry = (void(*)(int, int, int, int, int, int, int))marks[MARK_START];
	(*entry)(flag, bugargs.ctrl_addr, marks[MARK_END], marks[MARK_SYM],
	    0, bootdev, id->model);

	printf("exec: kernel returned!\n");
	return;
}
@


1.16
log
@Support for /etc/random.seed in bootsd (disk-only boot blocks)
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_mvme.c,v 1.15 2014/01/04 10:49:21 miod Exp $	*/
@


1.15
log
@Add rnddata[] placeholders to make these boot blocks build again.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_mvme.c,v 1.14 2008/03/31 22:14:43 miod Exp $	*/
d44 1
a44 1
char   rnddata[BOOTRANDOM_MAX];		/* XXX dummy */
@


1.14
log
@Switch bootloaders to mi loadfile().
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_mvme.c,v 1.13 2006/05/17 06:21:34 miod Exp $	*/
d43 2
@


1.13
log
@Delay board type retrieval.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_mvme.c,v 1.12 2006/05/16 22:51:30 miod Exp $	*/
a37 1
#include <a.out.h>
d42 1
a42 11
struct kernel {
	void    *entry;
	void    *symtab;
	void    *esym;
	int     bflags;
	int     bdev;
	char    *kname;
	void    *smini;
	void    *emini;
	u_int   end_loaded;
} kernel;
d50 4
a53 7
	char *loadaddr;
	int io;
	struct exec x;
	int cc, magic;
	void (*entry)();
	char *cp;
	int *ip;
d58 7
a64 7

#ifdef DEBUG
	printf("exec_mvme: file=%s flag=0x%x cputyp=%x\n", file, flag, id->model);
#endif

	io = open(file, 0);
	if (io < 0)
d67 1
a67 113
	/*
	 * Read in the exec header, and validate it.
	 */
	if (read(io, (char *)&x, sizeof(x)) != sizeof(x))
		goto shread;

	if (N_BADMAG(x)) {
		errno = EFTYPE;
		goto closeout;
	}

	/*
	 * note: on the mvme ports, the kernel is linked in such a way that
	 * its entry point is the first item in .text, and thus a_entry can
	 * be used to determine both the load address and the entry point.
	 * (also note that we make use of the fact that the kernel will live
	 *  in a VA == PA range of memory ... otherwise we would take
	 *  loadaddr as a parameter and let the kernel relocate itself!)
	 *
	 * note that ZMAGIC files included the a.out header in the text area
	 * so we must mask that off (has no effect on the other formats)
	 */
	loadaddr = (void *)(x.a_entry & ~sizeof(x));

	cp = loadaddr;
	magic = N_GETMAGIC(x);
	if (magic == ZMAGIC)
		cp += sizeof(x);
	entry = (void (*)())cp;

	/*
	 * Leave a copy of the exec header before the text.
	 * The sun3 kernel uses this to verify that the
	 * symbols were loaded by this boot program.
	 */
	bcopy(&x, cp - sizeof(x), sizeof(x));

	/*
	 * Read in the text segment.
	 */
	printf("%d", x.a_text);
	cc = x.a_text;
	if (magic == ZMAGIC)
		cc = cc - sizeof(x); /* a.out header part of text in zmagic */
	if (read(io, cp, cc) != cc)
		goto shread;
	cp += cc;

	/*
	 * NMAGIC may have a gap between text and data.
	 */
	if (magic == NMAGIC) {
		register int mask = N_PAGSIZ(x) - 1;
		while ((int)cp & mask)
			*cp++ = 0;
	}

	/*
	 * Read in the data segment.
	 */
	printf("+%d", x.a_data);
	if (read(io, cp, x.a_data) != x.a_data)
		goto shread;
	cp += x.a_data;

	/*
	 * Zero out the BSS section.
	 * (Kernel doesn't care, but do it anyway.)
	 */
	printf("+%d", x.a_bss);
	cc = x.a_bss;
	while ((int)cp & 3) {
		*cp++ = 0;
		--cc;
	}
	ip = (int *)cp;
	cp += cc;
	while ((char *)ip < cp)
		*ip++ = 0;

	/*
	 * Read in the symbol table and strings.
	 * (Always set the symtab size word.)
	 */
	*ip++ = x.a_syms;
	cp = (char *) ip;

	if (x.a_syms > 0 && (flag & RB_NOSYM) == 0) {

		/* Symbol table and string table length word. */
		cc = x.a_syms;
		printf("+[%d", cc);
		cc += sizeof(int);	/* strtab length too */
		if (read(io, cp, cc) != cc)
			goto shread;
		cp += x.a_syms;
		ip = (int *)cp;		/* points to strtab length */
		cp += sizeof(int);

		/* String table.  Length word includes itself. */
		cc = *ip;
		printf("+%d]", cc);
		cc -= sizeof(int);
		if (cc <= 0)
			goto shread;
		if (read(io, cp, cc) != cc)
			goto shread;
		cp += cc;
	}
	printf("=0x%lx\n", cp - loadaddr);
	close(io);

	printf("Start @@ 0x%x\n", (int)entry);
d73 3
a76 1
	(*entry)(flag, bugargs.ctrl_addr, cp, kernel.smini, kernel.emini, bootdev, id->model);
a77 7
	return;

shread:
	printf("exec: short read\n");
	errno = EIO;
closeout:
	close(io);
@


1.12
log
@Cleanup of mvme88k standalone code, with rewritten startup code with
fewer assembly statements and much less magic, a few display artefacts
removed, and private definitions moved out of the main prom.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_mvme.c,v 1.11 2004/11/11 21:44:42 miod Exp $	*/
d69 3
d74 1
a74 1
	printf("exec_mvme: file=%s flag=0x%x cputyp=%x\n", file, flag, bugargs.cputyp);
d200 1
a200 1
	(*entry)(flag, bugargs.ctrl_addr, cp, kernel.smini, kernel.emini, bootdev, bugargs.cputyp);
@


1.11
log
@Typos
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_mvme.c,v 1.10 2004/01/01 01:11:12 miod Exp $	*/
d62 1
a62 1
	register int io;
d66 2
a67 2
	register char *cp;
	register int *ip;
d90 2
a91 2
	 * note: on the mvme ports, the kernel is linked in such a way that 
	 * its entry point is the first item in .text, and thus a_entry can 
d94 1
a94 1
	 *  in a VA == PA range of memory ... otherwise we would take 
d187 1
a187 1
	printf("=0x%x\n", cp - loadaddr);
d192 2
a193 1
	if (flag & RB_HALT) mvmeprom_return();
@


1.10
log
@Some typos just never die (here controler vs controller).
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_mvme.c,v 1.9 2003/06/02 23:27:52 millert Exp $	*/
d98 1
a98 1
	 * so we must mask that off (has no effect on the other formats
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_mvme.c,v 1.8 2002/03/14 03:15:58 millert Exp $	*/
d190 2
a191 2
	printf("Start @@ 0x%x ...\n", (int)entry);
	printf("Controler Address @@ %x ...\n", bugargs.ctrl_addr);
@


1.8
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_mvme.c,v 1.7 2001/07/04 08:09:30 niklas Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.7
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d157 1
a157 1
	ip = (int*)cp;
d159 1
a159 1
	while ((char*)ip < cp)
d167 1
a167 1
	cp = (char*) ip;
d178 1
a178 1
		ip = (int*)cp;		/* points to strtab length */
@


1.7.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_mvme.c,v 1.7 2001/07/04 08:09:30 niklas Exp $	*/
d157 1
a157 1
	ip = (int *)cp;
d159 1
a159 1
	while ((char *)ip < cp)
d167 1
a167 1
	cp = (char *) ip;
d178 1
a178 1
		ip = (int *)cp;		/* points to strtab length */
@


1.6
log
@Some cleaning. Remove unused boot options, don't declare extra RB_FOO
symbols with fancy values. Get rid of some debug code, too.
@
text
@d1 2
@


1.5
log
@Booting kernel with MACHINE_NEW_NONCONTIG.  UVM code added but not working.
New stand config.  Lots of header fixes.  Can now cross-compile i386->m88k.
@
text
@a56 5
#define RB_NOSYM 0x400
#define RB_MULTI 0x4000
#define RB_EXTRA 0x8000
#define RB_ASKKERN 0x0010  /* ask kernel name  */

d60 2
a61 2
char    *file;
int     flag;
a69 1
	int n;
d72 3
a74 3
	if (flag & RB_EXTRA) {
		printf("exec_mvme: file=%s flag=0x%x cputyp=%x\n", file, flag, bugargs.cputyp);
	}
a102 7
	n = x.a_text + x.a_data + x.a_bss + x.a_syms + sizeof(int);

	/* debugging stuff for netboot
	printf("hex load address range 0x%x to 0x%x\n", loadaddr, loadaddr+n);
	printf("dec load address range %ld to %ld\n", loadaddr, loadaddr+n);
	bzero((void *)loadaddr, n);
	*/
d198 1
a198 1
	(*entry)(flag,  bugargs.ctrl_addr, cp, kernel.smini, kernel.emini, bootdev, bugargs.cputyp);
d202 1
a202 1
	shread:
d205 1
a205 1
	closeout:
@


1.4
log
@changed loader load address.
@
text
@d46 9
a54 9
	void	*entry;
	void	*symtab;
	void	*esym;
	int	bflags;
	int	bdev;
	char	*kname;
	void	*smini;
	void	*emini;
	u_int	end_loaded;
d65 2
a66 2
	char	*file;
	int	flag;
d76 1
a76 1
   int bootdev;
d78 3
a80 3
   if (flag & RB_EXTRA) {
   	printf("exec_mvme: file=%s flag=0x%x cputyp=%x\n", file, flag, bugargs.cputyp);
   }
d110 1
a110 1
	
d116 1
a116 1
	
d135 1
a135 1
	if (magic == ZMAGIC) 
d189 1
a189 1
		ip = (int*)cp;  	/* points to strtab length */
d208 1
a208 1
    
d211 1
a211 1
   (*entry)(flag,	bugargs.ctrl_addr, cp, kernel.smini, kernel.emini, bootdev, bugargs.cputyp);
d215 1
a215 1
shread:
d218 1
a218 1
closeout:
@


1.4.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d46 9
a54 9
	void    *entry;
	void    *symtab;
	void    *esym;
	int     bflags;
	int     bdev;
	char    *kname;
	void    *smini;
	void    *emini;
	u_int   end_loaded;
d65 2
a66 2
char    *file;
int     flag;
d76 1
a76 1
	int bootdev;
d78 3
a80 3
	if (flag & RB_EXTRA) {
		printf("exec_mvme: file=%s flag=0x%x cputyp=%x\n", file, flag, bugargs.cputyp);
	}
d110 1
a110 1

d116 1
a116 1

d135 1
a135 1
	if (magic == ZMAGIC)
d189 1
a189 1
		ip = (int*)cp;		/* points to strtab length */
d208 1
a208 1

d211 1
a211 1
	(*entry)(flag,  bugargs.ctrl_addr, cp, kernel.smini, kernel.emini, bootdev, bugargs.cputyp);
d215 1
a215 1
	shread:
d218 1
a218 1
	closeout:
@


1.4.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d57 5
d65 2
a66 2
	char    *file;
	int     flag;
d75 1
d78 3
a80 3
#ifdef DEBUG
	printf("exec_mvme: file=%s flag=0x%x cputyp=%x\n", file, flag, bugargs.cputyp);
#endif
d109 7
d211 1
a211 1
	(*entry)(flag, bugargs.ctrl_addr, cp, kernel.smini, kernel.emini, bootdev, bugargs.cputyp);
d215 1
a215 1
shread:
d218 1
a218 1
closeout:
@


1.4.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@a0 2
/*	$OpenBSD$	*/

@


1.4.4.4
log
@Merge in -current from about a week ago
@
text
@d157 1
a157 1
	ip = (int *)cp;
d159 1
a159 1
	while ((char *)ip < cp)
d167 1
a167 1
	cp = (char *) ip;
d178 1
a178 1
		ip = (int *)cp;		/* points to strtab length */
@


1.4.4.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_mvme.c,v 1.4.4.4 2002/03/28 10:36:03 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.4.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d190 2
a191 2
	printf("Start @@ 0x%x\n", (int)entry);
	printf("Controller Address 0x%x\n", bugargs.ctrl_addr);
@


1.3
log
@This fixed a number of things.  A serious bug in bugcrt.c's initial stack
among other things.
@
text
@d58 4
d76 1
d78 3
a80 3
#ifdef	DEBUG
	printf("exec_mvme: file=%s flag=0x%x\n", file, flag);
#endif
d209 3
a211 2
/*	(addr)(flag, 0, kernel.esym, kernel.smini, kernel.emini);*/
	(*entry)(flag, 	bugargs.ctrl_addr, cp, kernel.smini, kernel.emini);
@


1.2
log
@New libsa.
@
text
@d71 1
d86 1
d104 8
a111 1

d201 3
@


1.1
log
@New libsa.
@
text
@a0 1
/*	$NetBSD: exec_sun.c,v 1.5 1996/01/29 23:41:06 gwr Exp $ */
@

