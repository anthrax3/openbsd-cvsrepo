head	1.9;
access;
symbols
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.7.0.26
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.24
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.22
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.20
	OPENBSD_5_0:1.7.0.18
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.16
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.14
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.10
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.12
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.8
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.6
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.4
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.2
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.6.0.4
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.5.0.6
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.4
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.4.0.6
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	UBC_SYNC_A:1.3
	OPENBSD_3_3:1.3.0.24
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.22
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.20
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.3
	UBC:1.3.0.18
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.16
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.14
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.12
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.10
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.8
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.6
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.4
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.1.1.1.0.6
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.4
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.2
	OPENBSD_2_1_BASE:1.1.1.1
	mvme88kport:1.1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2014.03.18.22.36.37;	author miod;	state dead;
branches;
next	1.8;

1.8
date	2014.02.23.12.30.15;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2007.06.17.00.28.57;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.18.06.11.16;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2004.12.27.15.23.46;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.01.17.00.37;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	98.08.22.08.52.56;	author smurph;	state Exp;
branches
	1.3.8.1;
next	1.2;

1.2
date	98.08.18.04.10.03;	author smurph;	state Exp;
branches;
next	1.1;

1.1
date	97.03.03.19.30.42;	author rahnds;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.03.03.19.30.42;	author rahnds;	state Exp;
branches;
next	;

1.3.8.1
date	2003.06.07.11.13.18;	author ho;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: wrtvid.c,v 1.8 2014/02/23 12:30:15 jsg Exp $ */

/*
 * Copyright (c) 1995 Dale Rahn <drahn@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/disklabel.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void	copy_exe(int, int);
void	swabcfg(struct mvmedisklabel *);
void	swabvid(struct mvmedisklabel *);

int
main(argc, argv)
	int argc;
	char **argv;
{
	struct mvmedisklabel *pcpul;
	struct stat stat;
	int exe_file;
	int tape_vid;
	int tape_exe;
	unsigned int exe_addr;
	char *filename;
	char fileext[256];

	if (argc == 1)
		filename = "a.out";
	else
		filename = argv[1];

	exe_file = open(filename, O_RDONLY,0444);
	if (exe_file == -1) {
		perror(filename);
		exit(2);
	}
	snprintf(fileext, sizeof fileext, "%c%cboot", filename[4], filename[5]);
	tape_vid = open(fileext, O_WRONLY|O_CREAT|O_TRUNC, 0644);
	snprintf(fileext, sizeof fileext, "boot%c%c", filename[4], filename[5]);
	tape_exe = open(fileext, O_WRONLY|O_CREAT|O_TRUNC,0644);

	pcpul = (struct mvmedisklabel *)malloc(sizeof(struct mvmedisklabel));
	bzero(pcpul, sizeof(struct mvmedisklabel));

	pcpul->version = 1;
	memcpy(pcpul->vid_id, "M88K", sizeof pcpul->vid_id);

	fstat(exe_file, &stat);
	/* size in 256 byte blocks round up after a.out header removed */

	if (filename[5] == 't' ) {
		pcpul->vid_oss = 1;
	}else {
		pcpul->vid_oss = 2;
	}
	pcpul->vid_osl = (((stat.st_size -0x20) +511) / 512) *2;

	lseek(exe_file, 0x14, SEEK_SET);
	read(exe_file, &exe_addr, 4);

	/* check this, it may not work in both endian. */
	/* No, it doesn't.  Use a big endian machine for now. SPM */
	
	{
		union {
			struct s {
				unsigned short s1;
				unsigned short s2;
			} s;
			unsigned long l;
		} a;
		a.l = exe_addr;
		pcpul->vid_osa_u = a.s.s1;
		pcpul->vid_osa_l = a.s.s2;

	}
	pcpul->vid_cas = 1;
	pcpul->vid_cal = 1;
	/* do not want to write past end of structure, not null terminated */
	strncpy(pcpul->vid_mot, "MOTOROLA", 8);

	if (BYTE_ORDER != BIG_ENDIAN)
		swabvid(pcpul);

	pcpul->cfg_rec = 0x100;
	pcpul->cfg_psm = 0x200;

	if (BYTE_ORDER != BIG_ENDIAN)
		swabcfg(pcpul);

	write(tape_vid, pcpul, sizeof(struct mvmedisklabel));

	free(pcpul);

	copy_exe(exe_file, tape_exe);
	close(exe_file);
	close(tape_vid);
	close(tape_exe);
	return (0);
}

#define BUF_SIZ 512
void
copy_exe(exe_file, tape_exe)
	int exe_file, tape_exe;
{
	char buf[BUF_SIZ];
	int cnt = 0;

	lseek (exe_file, 0x20, SEEK_SET);
	while (BUF_SIZ == (cnt = read(exe_file, buf, BUF_SIZ))) {
		write(tape_exe, buf, cnt);
	}
	bzero(&buf[cnt], BUF_SIZ-cnt);
	write(tape_exe, buf, BUF_SIZ);
}

void
swabvid(pcpul)
	struct mvmedisklabel *pcpul;
{
	swap32(pcpul->vid_oss);
	swap16(pcpul->vid_osl);
#if 0
	swap16(pcpul->vid_osa_u);
	swap16(pcpul->vid_osa_l);
#endif
	swap32(pcpul->vid_cas);
}

void
swabcfg(pcpul)
	struct mvmedisklabel *pcpul;
{
	swap16(pcpul->cfg_atm);
	swap16(pcpul->cfg_prm);
	swap16(pcpul->cfg_atm);
	swap16(pcpul->cfg_rec);
	swap16(pcpul->cfg_trk);
	swap16(pcpul->cfg_psm);
	swap16(pcpul->cfg_shd);
	swap16(pcpul->cfg_pcom);
	swap16(pcpul->cfg_rwcc);
	swap16(pcpul->cfg_ecc);
	swap16(pcpul->cfg_eatm);
	swap16(pcpul->cfg_eprm);
	swap16(pcpul->cfg_eatw);
	swap16(pcpul->cfg_rsvc1);
	swap16(pcpul->cfg_rsvc2);
}
@


1.8
log
@fix a memory leak
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wrtvid.c,v 1.7 2007/06/17 00:28:57 deraadt Exp $ */
@


1.7
log
@amd64/stand
@
text
@d1 1
a1 1
/*	$OpenBSD: wrtvid.c,v 1.6 2006/05/18 06:11:16 miod Exp $ */
d126 1
a126 1
	char *buf;
a127 2

	buf = (char *)malloc(BUF_SIZ);
@


1.6
log
@Use standard swap16() and swap32() functions instead of abusing <db.h> to get
similar M_xx_SWAP().
@
text
@d1 1
a1 1
/*	$OpenBSD: wrtvid.c,v 1.5 2004/12/27 15:23:46 drahn Exp $ */
d19 3
a26 8
#include <sys/stat.h>
#include <sys/types.h>

#include "disklabel.h" 	
/* disklabel.h is in current dir because of my
   cross-compile env.  if <machine/disklabel.h>
   is newer, copy it here.
*/
d29 2
a30 2
void	swabcfg(struct cpu_disklabel *);
void	swabvid(struct cpu_disklabel *);
d37 1
a37 1
	struct cpu_disklabel *pcpul;
d61 2
a62 2
	pcpul = (struct cpu_disklabel *)malloc(sizeof(struct cpu_disklabel));
	bzero(pcpul, sizeof(struct cpu_disklabel));
d110 1
a110 1
	write(tape_vid, pcpul, sizeof(struct cpu_disklabel));
d141 1
a141 1
	struct cpu_disklabel *pcpul;
d154 1
a154 1
	struct cpu_disklabel *pcpul;
@


1.5
log
@Finally put copyrights on files I wrote _long_ ago. prodded by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wrtvid.c,v 1.4 2003/06/01 17:00:37 deraadt Exp $ */
d19 1
a19 2
#include <sys/types.h>
#include <sys/stat.h>
a20 1
#include <unistd.h>
d22 5
a26 2
#define __DBINTERFACE_PRIVATE
#include <db.h>
d28 1
a28 1
/* disklabel.h is in current dir because of my 
d33 5
a47 2
	unsigned short exe_addr_u;
	unsigned short exe_addr_l;
a49 1
	char filebase[256];
d127 1
d144 1
d148 7
a154 7
	M_32_SWAP(pcpul->vid_oss);
	M_16_SWAP(pcpul->vid_osl);
	/*
	M_16_SWAP(pcpul->vid_osa_u);
	M_16_SWAP(pcpul->vid_osa_l);
	*/
	M_32_SWAP(pcpul->vid_cas);
d157 1
d161 15
a175 15
	M_16_SWAP(pcpul->cfg_atm);
	M_16_SWAP(pcpul->cfg_prm);
	M_16_SWAP(pcpul->cfg_atm);
	M_16_SWAP(pcpul->cfg_rec);
	M_16_SWAP(pcpul->cfg_trk);
	M_16_SWAP(pcpul->cfg_psm);
	M_16_SWAP(pcpul->cfg_shd);
	M_16_SWAP(pcpul->cfg_pcom);
	M_16_SWAP(pcpul->cfg_rwcc);
	M_16_SWAP(pcpul->cfg_ecc);
	M_16_SWAP(pcpul->cfg_eatm);
	M_16_SWAP(pcpul->cfg_eprm);
	M_16_SWAP(pcpul->cfg_eatw);
	M_16_SWAP(pcpul->cfg_rsvc1);
	M_16_SWAP(pcpul->cfg_rsvc2);
@


1.4
log
@strcpy/strcat/sprintf removal in all bootblocks.  various testing by
various people.  outside of some messy things in src/gnu, only one
thing in the main tree now violates this rule: bind
@
text
@d1 18
a18 1
/*	$OpenBSD: wrtvid.c,v 1.3 1998/08/22 08:52:56 smurph Exp $ */
@


1.3
log
@Fixed command line args.  VID Volume ID is now M88K.
@
text
@d1 1
a1 1
/*	$OpenBSD:	$ */
d41 1
a41 1
	sprintf(fileext, "%c%cboot", filename[4], filename[5]);
d43 1
a43 1
	sprintf(fileext, "boot%c%c", filename[4], filename[5]);
d50 1
a50 1
	strcpy(pcpul->vid_id, "M88K");
@


1.3.8.1
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: wrtvid.c,v 1.3 1998/08/22 08:52:56 smurph Exp $ */
d41 1
a41 1
	snprintf(fileext, sizeof fileext, "%c%cboot", filename[4], filename[5]);
d43 1
a43 1
	snprintf(fileext, sizeof fileext, "boot%c%c", filename[4], filename[5]);
d50 1
a50 1
	memcpy(pcpul->vid_id, "M88K", sizeof pcpul->vid_id);
@


1.2
log
@Changed volume id to m88k. Fixed command line args.
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d8 5
a12 1
#include <machine/disklabel.h>
d30 1
a30 1
	if (argc == 0)
d49 1
a49 1
	strcpy(pcpul->vid_id, "NBSD");
d65 2
@


1.1.1.1
log
@Third try at importing the mvme88k port. This is a working kernel
from nivas.
Userland and compiler still need to be worked on.
Make certain what directory the import is done from.
@
text
@@
