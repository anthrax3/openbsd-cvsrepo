head	1.4;
access;
symbols
	OPENBSD_5_5:1.3.0.6
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.2
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.0.18
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.16
	OPENBSD_5_0:1.1.0.14
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.12
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.10
	OPENBSD_4_8_BASE:1.1
	OPENBSD_4_7:1.1.0.6
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.8
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.4
	OPENBSD_4_5_BASE:1.1
	OPENBSD_4_4:1.1.0.2
	OPENBSD_4_4_BASE:1.1;
locks; strict;
comment	@# @;


1.4
date	2014.03.18.22.36.36;	author miod;	state dead;
branches;
next	1.3;

1.3
date	2013.05.12.10.43.45;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2013.01.05.11.20.56;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2008.04.02.21.53.18;	author miod;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: crt0.S,v 1.3 2013/05/12 10:43:45 miod Exp $	*/

/*
 * Copyright (c) 2008 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#define	_KERNEL
#define	_LOCORE
#include <machine/asm.h>

	.text

ASGLOBAL(__start)
#ifdef	LOAD_FROM_VID
	/*
	 * Binaries loaded *from disk* by the BUG start with two special words.
	 *
	 * The first word contains the initial stack address, and the second
	 * word contains the initial instruction pointer.
	 *
	 * If the initial instruction pointer is below the address the file was
	 * loaded at (which is found in the VID block or in the NIOT settings),
	 * it is interpreted as an offset within the loaded image.
	 *
	 * Note that installboot() will program the entry point address in the
	 * VID block, which needs to point to these magic words, therefore we
	 * set the bootxx entry point here.
	 */
	.long	_ASM_LABEL(__start)
	.long	_ASM_LABEL(real_start) - _ASM_LABEL(__start)

#endif	/* LOAD_FROM_VID */

#ifdef	LOAD_FROM_BOOTXX
	/*
	 * bootxx runs the second-stage binary at its entry + 8, in case
	 * it contains the special two words.
	 */
	NOP
	NOP
#endif

#ifdef SREC
	/*
	 * Get the address of real_start in %r6, as if we had been loaded
	 * as a regular boot block.
	 */
	bsr.n	_ASM_LABEL(real_start)
	 or	%r6, %r0, %r1
#endif

ASLOCAL(real_start)
	/*
	 * Registers on entry, unless loaded from S-Records:
	 * r2	boot device lun
	 * r3	boot controller lun
	 * r4	cold/warm boot mode (`IPL\01')
	 * r5	boot controller address
	 * r6	entry point of loaded program (i.e. address of __start)
	 * r7	disk boot: address of media configuration block, zero if none
	 *	net boot: boot information packet address
	 * r8	start of command line (loaded file if netboot)
	 * r9	end of command line
	 * r10	net boot: start of optional argument
	 * r11	net boot: end of optional argument
	 * r12	net boot: bit 0 set if autoboot
	 * r31	stack, as setup above
	 */

#if defined(LOAD_FROM_BOOTXX) || defined(NETBOOT) || defined(SREC)

	/*
	 * We first relocate ourselves to our preferred address.
	 * This helps netbooting if the NIOT address (defaulting to
	 * 001f0000) does not match ours, or if we are loaded by an
	 * old stage1 at the wrong address.
	 */

	or.u	%r20, %r0,  %hi16(_ASM_LABEL(real_start))
	or	%r20, %r20, %lo16(_ASM_LABEL(real_start))
	cmp	%r21, %r6,  %r20
	bb1	eq,   %r21, reloc_done

	or.u	%r22, %r0,  %hi16(_C_LABEL(end))
	or	%r22, %r22, %lo16(_C_LABEL(end))

	bb1.n	lt,   %r21, reloc_down
	 or	%r25, %r0,  %r6

	/*
	 * Relocate from r25 to r20, moving up
	 */
reloc_up:
	ld	%r24, %r25, %r0
	st	%r24, %r20, %r0
	add	%r20, %r20, 4
	cmp	%r21, %r20, %r22
	bb1.n	ne,   %r21, reloc_up
	 add	%r25, %r25, 4
	br	reloc_done

	/*
	 * Relocate from r25 to r20, moving down
	 */
reloc_down:
	subu	%r26, %r22, %r20	/* end - __start */
	addu	%r25, %r25, %r26
1:
	subu	%r25, %r25, 4
	ld	%r24, %r25, %r0
	subu	%r22, %r22, 4
	st	%r24, %r22, %r0
	cmp	%r21, %r20, %r22
	bb1	ne,   %r21, 1b

reloc_done:
	or.u	%r20, %r0,  %hi16(_ASM_LABEL(__start_relocated))
	or	%r20, %r20, %lo16(_ASM_LABEL(__start_relocated))
	jmp.n	%r20
	 or	%r6,  %r20, %r0	/* for stack initialization below */

ASLOCAL(__start_relocated)

#endif	/* LOAD_FROM_BOOTXX || NETBOOT || SREC */

	/*
	 * Clear BSS.
	 */
	or.u	%r20, %r0,  %hi16(_C_LABEL(edata))
	or	%r20, %r20, %lo16(_C_LABEL(edata))
	or.u	%r22, %r0,  %hi16(_C_LABEL(end))
	or	%r22, %r22, %lo16(_C_LABEL(end))
1:	st	%r0,  %r20, %r0
	add	%r20, %r20, 4
	cmp	%r21, %r20, %r22
	bb1	ne,   %r21, 1b

	/*
	 * Setup our stack - it might not have been set up correctly.
	 * We'll use the memory below text as stack, aligned to 0x10
	 * bytes.
	 */
	clr	%r31, %r6,  4<0>

#ifndef SREC

	/*
	 * Save our arguments so that all registers are available to
	 * C code.
	 */
	or.u	%r20, %r0,  %hi16(_C_LABEL(bugargs))
	or	%r20, %r20, %lo16(_C_LABEL(bugargs))

	st	%r2,  %r20, 0x00		/* dev_lun */
	st	%r3,  %r20, 0x04		/* ctrl_lun */
	st	%r4,  %r20, 0x08		/* flags */
	st	%r5,  %r20, 0x0c		/* ctrl_addr */
	st	%r6,  %r20, 0x10		/* entry */
	st	%r7,  %r20, 0x14		/* conf_blk */
#ifdef	NETBOOT
	st	%r10, %r20, 0x18		/* arg_start */
	st	%r11, %r20, 0x1c		/* arg_end */
#else
	st	%r8,  %r20, 0x18		/* arg_start */
	st	%r9,  %r20, 0x1c		/* arg_end */
#endif	/* NETBOOT */

	/*
	 * NUL-terminate arg_end, if it is not.
	 */
#ifdef	NETBOOT
	st.b	%r0,  %r11, %r0
#else
	st.b	%r0,  %r9,  %r0
#endif

#endif	/* !SREC */

	/*
	 * PSR when booted from the BUG has SFU1..SFU7 disabled.
	 * Enable SFU1 (the FPU) for the C code to be able to use it
	 * if necessary.
	 */
	ldcr	%r20, PSR
	clr	%r20, %r20, 1<PSR_FPU_DISABLE_BIT>
	stcr	%r20, PSR
	NOP
	
	bsr	_C_LABEL(main)
	bsr	_C_LABEL(_rtt)
1:	br	1b

	.data
GLOBAL(bugargs)
	.space	4			/* dev_lun */
	.space	4			/* ctrl_lun */
	.space	4			/* flags */
	.space	4			/* ctrl_addr */
	.space	4			/* entry */
	.space	4			/* conf_blk */
	.space	4			/* arg_start */
	.space	4			/* arg_end */
@


1.3
log
@S-Records boot code for mvme88k, finally. Allows a kernel to be loaded from
network, using either the on-board interface (on MVME187 and MVME197) or
any MVME376.

While there, add MVME376 support to netboot.
@
text
@d1 1
a1 1
/*	$OpenBSD: crt0.S,v 1.2 2013/01/05 11:20:56 miod Exp $	*/
@


1.2
log
@Switch m88k ports to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: crt0.S,v 1.1 2008/04/02 21:53:18 miod Exp $	*/
d26 1
a26 1
#ifdef	STAGE1
d44 1
a44 1
#endif	/* STAGE1 */
d46 1
a46 1
#ifdef	STAGE2
d55 9
d66 1
a66 1
	 * Registers on entry:
d82 1
a82 1
#if defined(STAGE2) || defined(NETBOOT)
d136 1
a136 1
#endif	/* STAGE2 || NETBOOT */
d157 2
d188 2
@


1.1
log
@Rewrite the startup code for the mvme88k bootblocks, once again. Some of
them (especially the netboot ones) will now self-relocate, which makes
BUG configuration much simpler.

WARNING: for disk-based systems, you need to update bootxx and bootsd at the
same time. New bootsd will not run when loaded from an older bootxx.
This doesn't matter much since you need both with installboot.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d23 1
a23 1
	text
d25 1
a26 2

ASLOCAL(image)
d36 4
d41 2
a42 2
	.long	_ASM_LABEL(image) - 0x10
	.long	_ASM_LABEL(start) - _ASM_LABEL(image)
d55 1
a55 1
ASGLOBAL(start)
d62 1
a62 1
	 * r6	entry point of loaded program (i.e. address of start)
d82 4
a85 4
	or.u	r20, r0,  hi16(_ASM_LABEL(start))
	or	r20, r20, lo16(_ASM_LABEL(start))
	cmp	r21, r6,  r20
	bb1	eq,  r21, reloc_done
d87 2
a88 2
	or.u	r22, r0,  hi16(_C_LABEL(end))
	or	r22, r22, lo16(_C_LABEL(end))
d90 2
a91 2
	bb1.n	lt,  r21, reloc_down
	 or	r25, r0,  r6
d97 6
a102 6
	ld	r24, r25, r0
	st	r24, r20, r0
	add	r20, r20, 4
	cmp	r21, r20, r22
	bb1.n	ne,  r21, reloc_up
	 add	r25, r25, 4
d109 2
a110 2
	subu	r26, r22, r20	/* _end - start */
	addu	r25, r25, r26
d112 6
a117 6
	subu	r25, r25, 4
	ld	r24, r25, r0
	subu	r22, r22, 4
	st	r24, r22, r0
	cmp	r21, r20, r22
	bb1	ne,  r21, 1b
d120 4
a123 4
	or.u	r20, r0,  hi16(_ASM_LABEL(start_relocated))
	or	r20, r20, lo16(_ASM_LABEL(start_relocated))
	jmp.n	r20
	 or	r6,  r20, r0	/* for stack initialization below */
d125 1
a125 1
ASLOCAL(start_relocated)
d132 8
a139 8
	or.u	r20, r0,  hi16(_C_LABEL(edata))
	or	r20, r20, lo16(_C_LABEL(edata))
	or.u	r22, r0,  hi16(_C_LABEL(end))
	or	r22, r22, lo16(_C_LABEL(end))
1:	st	r0,  r20, r0
	add	r20, r20, 4
	cmp	r21, r20, r22
	bb1	ne,  r21, 1b
d146 1
a146 1
	clr	r31, r6,  4<0>
d152 2
a153 2
	or.u	r20, r0,  hi16(_C_LABEL(bugargs))
	or	r20, r20, lo16(_C_LABEL(bugargs))
d155 6
a160 6
	st	r2,  r20, 0x00		/* dev_lun */
	st	r3,  r20, 0x04		/* ctrl_lun */
	st	r4,  r20, 0x08		/* flags */
	st	r5,  r20, 0x0c		/* ctrl_addr */
	st	r6,  r20, 0x10		/* entry */
	st	r7,  r20, 0x14		/* conf_blk */
d162 2
a163 2
	st	r10, r20, 0x18		/* arg_start */
	st	r11, r20, 0x1c		/* arg_end */
d165 2
a166 2
	st	r8,  r20, 0x18		/* arg_start */
	st	r9,  r20, 0x1c		/* arg_end */
d173 1
a173 1
	st.b	r0,  r11, r0
d175 1
a175 1
	st.b	r0,  r9,  r0
d183 3
a185 3
	ldcr	r20, PSR
	clr	r20, r20, 1<PSR_FPU_DISABLE_BIT>
	stcr	r20, PSR
d192 1
a192 1
	data
@

