head	1.10;
access;
symbols
	OPENBSD_5_5:1.9.0.6
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.7.0.18
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.16
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.14
	OPENBSD_5_0:1.7.0.12
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.10
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.8
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.4
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.6.0.10
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.8
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.6
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.4
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.5.0.12
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.10
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.8
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.4.0.6
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.4
	UBC:1.3.0.16
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.14
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.12
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.10
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.8
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.6
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.4
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.1.1.1.0.6
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.4
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.2
	OPENBSD_2_1_BASE:1.1.1.1
	mvme88kport:1.1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2014.03.18.22.36.37;	author miod;	state dead;
branches;
next	1.9;

1.9
date	2013.05.12.21.00.56;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2013.05.12.10.43.45;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.18.21.49.11;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.16.22.52.26;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.04.16.36.15;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.01.26.40;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.01.11.05.11.46;	author millert;	state Exp;
branches
	1.3.6.1
	1.3.16.1;
next	1.2;

1.2
date	98.08.22.08.38.02;	author smurph;	state Exp;
branches;
next	1.1;

1.1
date	97.03.03.19.30.37;	author rahnds;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.03.03.19.30.37;	author rahnds;	state Exp;
branches;
next	;

1.3.6.1
date	2002.03.28.10.36.03;	author niklas;	state Exp;
branches;
next	1.3.6.2;

1.3.6.2
date	2003.06.07.11.13.17;	author ho;	state Exp;
branches;
next	;

1.3.16.1
date	2002.06.11.03.37.11;	author art;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: if_le.c,v 1.9 2013/05/12 21:00:56 miod Exp $ */

/*
 * Copyright (c) 1995 Theo de Raadt
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * Copyright (c) 1993 Adam Glass
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Adam Glass.
 * 4. The name of the Author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Adam Glass ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*-
 * Copyright (c) 1982, 1992, 1993
 *      The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *      @@(#)if_le.c     8.2 (Berkeley) 10/30/93
 */

#include <sys/param.h>
#include <sys/types.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>

#include <machine/prom.h>

#include "stand.h"
#include "libsa.h"
#include "netif.h"
#include "config.h"

#include "if_lereg.h"

int     le_debug = 0;

void le_wrcsr(u_int16_t, u_int16_t);
u_int16_t le_rdcsr(u_int16_t);
void le_end(struct netif *);
void le_error(struct netif *, const char *, u_int16_t);
int le_get(struct iodesc *, void *, size_t, time_t);
void le_init(struct iodesc *, void *);
int le_match(struct netif *, void *);
int le_poll(struct iodesc *, void *, int);
int le_probe(struct netif *, void *);
int le_put(struct iodesc *, void *, size_t);
void le_reset(struct netif *, u_char *);

struct netif_driver le_driver = {
	"le",			/* netif_bname */
	le_match,		/* match */
	le_probe,		/* probe */
	le_init,		/* init */
	le_get,			/* get */
	le_put,			/* put */
	le_end,			/* end */
	NULL,			/* netif_ifs - will be filled later */
	0,			/* netif_nifs - will be filled later */
};

struct {
	struct lereg1 *sc_r1;	/* LANCE registers */
	struct vlereg1 *sc_vr1;	/* MVME376 registers */
	struct lereg2 *sc_r2;	/* RAM */
	int     next_rmd;
	int     next_tmd;
} le_softc;

int
le_match(struct netif *nif, void *machdep_hint)
{
	const char *name = machdep_hint;

	if (name == NULL) {
		if (le_config[nif->nif_unit].clun == bugargs.ctrl_lun ||
		    (int)bugargs.ctrl_lun < 0)
			return 1;
	} else {
		if (bcmp(le_driver.netif_bname, name, 2) == 0) {
			if (nif->nif_unit == name[2] - '0')
				return 1;
		}
	}

	return 0;
}

int
le_probe(struct netif *nif, void *machdep_hint)
{
	return 0;
}

void
le_wrcsr(u_int16_t port, u_int16_t val)
{
	if (le_softc.sc_r1 != NULL) {
		le_softc.sc_r1->ler1_rap = port;
		le_softc.sc_r1->ler1_rdp = val;
	} else {
		le_softc.sc_vr1->ler1_rap = port;
		le_softc.sc_vr1->ler1_rdp = val;
	}
}

u_int16_t
le_rdcsr(u_int16_t port)
{
	u_int16_t val;

	if (le_softc.sc_r1 != NULL) {
		le_softc.sc_r1->ler1_rap = port;
		val = le_softc.sc_r1->ler1_rdp;
	} else {
		le_softc.sc_vr1->ler1_rap = port;
		val = le_softc.sc_vr1->ler1_rdp;
	}
	return (val);
}

void
le_error(struct netif *nif, const char *str, u_int16_t stat)
{
	struct netif_driver *drv = nif->nif_driver;

	if (stat & LE_C0_BABL)
		panic("le%d: been babbling, found by '%s'", nif->nif_unit, str);
	if (stat & LE_C0_CERR) {
		drv->netif_ifs[nif->nif_unit].dif_stats->collision_error++;
		le_wrcsr(LE_CSR0, LE_C0_CERR);
	}
	if (stat & LE_C0_MISS) {
		drv->netif_ifs[nif->nif_unit].dif_stats->missed++;
		le_wrcsr(LE_CSR0, LE_C0_MISS);
	}
	if (stat & LE_C0_MERR) {
		panic("le%d: memory error in '%s'", nif->nif_unit, str);
	}
}

void
le_reset(struct netif *nif, u_char *myea)
{
	struct lereg2 *ler2 = le_softc.sc_r2;
	unsigned int a;
	int     timo = 100000, i;
	u_int16_t stat;

	if (le_debug)
		printf("le%d: le_reset called\n", nif->nif_unit);
	
	if (le_softc.sc_vr1 != NULL) {
		le_softc.sc_vr1->ler1_csr = 0;
		CDELAY;
		le_softc.sc_vr1->ler1_csr = HW_RS | 0x0f;
	}
	le_wrcsr(LE_CSR0, LE_C0_STOP);

	bzero(ler2, sizeof(*ler2));

	ler2->ler2_mode = LE_MODE_NORMAL;
	ler2->ler2_padr[0] = myea[1];
	ler2->ler2_padr[1] = myea[0];
	ler2->ler2_padr[2] = myea[3];
	ler2->ler2_padr[3] = myea[2];
	ler2->ler2_padr[4] = myea[5];
	ler2->ler2_padr[5] = myea[4];

	ler2->ler2_ladrf0 = 0;
	ler2->ler2_ladrf1 = 0;

	a = (u_int)ler2->ler2_rmd;
	ler2->ler2_rlen = LE_RLEN | LE_ADDR_HIGH(a);
	ler2->ler2_rdra = LE_ADDR_LOW(a);

	a = (u_int)ler2->ler2_tmd;
	ler2->ler2_tlen = LE_TLEN | LE_ADDR_HIGH(a);
	ler2->ler2_tdra = LE_ADDR_LOW(a);

	a = (u_int)ler2;
	le_wrcsr(LE_CSR1, LE_ADDR_LOW(a));
	le_wrcsr(LE_CSR2, LE_ADDR_HIGH(a));

	for (i = 0; i < LERBUF; i++) {
		a = (u_int)&ler2->ler2_rbuf[i];
		ler2->ler2_rmd[i].rmd0 = LE_ADDR_LOW(a);
		ler2->ler2_rmd[i].rmd1_bits = LE_R1_OWN;
		ler2->ler2_rmd[i].rmd1_hadr = LE_ADDR_HIGH(a);
		ler2->ler2_rmd[i].rmd2 = -LEMTU;
		ler2->ler2_rmd[i].rmd3 = 0;
	}
	for (i = 0; i < LETBUF; i++) {
		a = (u_int)&ler2->ler2_tbuf[i];
		ler2->ler2_tmd[i].tmd0 = LE_ADDR_LOW(a);
		ler2->ler2_tmd[i].tmd1_bits = 0;
		ler2->ler2_tmd[i].tmd1_hadr = LE_ADDR_HIGH(a);
		ler2->ler2_tmd[i].tmd2 = 0;
		ler2->ler2_tmd[i].tmd3 = 0;
	}

	le_wrcsr(LE_CSR3, LE_C3_BSWP);

	le_wrcsr(LE_CSR0, LE_C0_INIT);
	do {
		stat = le_rdcsr(LE_CSR0);
		if (--timo == 0) {
			printf("le%d: init timeout, stat = 0x%x\n",
			    nif->nif_unit, stat);
			break;
		}
	} while ((stat & LE_C0_IDON) == 0);

	le_wrcsr(LE_CSR0, LE_C0_IDON);
	le_softc.next_rmd = 0;
	le_softc.next_tmd = 0;
	le_wrcsr(LE_CSR0, LE_C0_STRT);
}

int
le_poll(struct iodesc *desc, void *pkt, int len)
{
	struct netif *nif = desc->io_netif;
	struct lereg2 *ler2 = le_softc.sc_r2;
	unsigned int a;
	int     length;
	struct lermd *rmd;
	u_int16_t stat;

	stat = le_rdcsr(LE_CSR0);
	if ((stat & LE_C0_RINT) != 0)
		le_wrcsr(LE_CSR0, LE_C0_RINT);
	rmd = &ler2->ler2_rmd[le_softc.next_rmd];
	if (rmd->rmd1_bits & LE_R1_OWN) {
		return (0);
	}
	if (stat & LE_C0_ERR)
		le_error(nif, "le_poll", stat);
	if (rmd->rmd1_bits & LE_R1_ERR) {
		printf("le%d_poll: rmd status 0x%x\n",
		    nif->nif_unit, rmd->rmd1_bits);
		length = 0;
		goto cleanup;
	}
	if ((rmd->rmd1_bits & (LE_R1_STP | LE_R1_ENP)) !=
	    (LE_R1_STP | LE_R1_ENP))
		panic("le_poll: chained packet");

	length = rmd->rmd3;
	if (length >= LEMTU) {
		length = 0;
		panic("csr0 when bad things happen: %x", stat);
		goto cleanup;
	}
	if (!length)
		goto cleanup;
	length -= 4;
	if (length > 0) {

		/*
	         * if buffer is smaller than the packet truncate it.
	         * (is this wise?)
	         */
		if (length > len)
			length = len;

		bcopy((void *)&ler2->ler2_rbuf[le_softc.next_rmd], pkt, length);
	}
cleanup:
	a = (u_int)&ler2->ler2_rbuf[le_softc.next_rmd];
	rmd->rmd0 = LE_ADDR_LOW(a);
	rmd->rmd1_hadr = LE_ADDR_HIGH(a);
	rmd->rmd2 = -LEMTU;
	le_softc.next_rmd =
	    (le_softc.next_rmd == (LERBUF - 1)) ? 0 : (le_softc.next_rmd + 1);
	rmd->rmd1_bits = LE_R1_OWN;
	return length;
}

int
le_put(struct iodesc *desc, void *pkt, size_t len)
{
	struct netif *nif = desc->io_netif;
	struct netif_driver *drv = nif->nif_driver;
	volatile struct lereg2 *ler2 = le_softc.sc_r2;
	volatile struct letmd *tmd;
	int     timo = 100000;
	unsigned int a;
	u_int16_t stat;

	stat = le_rdcsr(LE_CSR0);
	if (stat & LE_C0_ERR)
		le_error(nif, "le_put(way before xmit)", stat);
	tmd = &ler2->ler2_tmd[le_softc.next_tmd];
	while (tmd->tmd1_bits & LE_T1_OWN) {
		printf("le%d: output buffer busy\n", nif->nif_unit);
	}
	bcopy(pkt, (void *)ler2->ler2_tbuf[le_softc.next_tmd], len);
	if (len < 64)
		tmd->tmd2 = -64;
	else
		tmd->tmd2 = -len;
	tmd->tmd3 = 0;
	stat = le_rdcsr(LE_CSR0);
	if (stat & LE_C0_ERR)
		le_error(nif, "le_put(before xmit)", stat);
	tmd->tmd1_bits = LE_T1_STP | LE_T1_ENP | LE_T1_OWN;
	a = (u_int)&ler2->ler2_tbuf[le_softc.next_tmd];
	tmd->tmd0 = LE_ADDR_LOW(a);
	tmd->tmd1_hadr = LE_ADDR_HIGH(a);
	le_wrcsr(LE_CSR0, LE_C0_TDMD);
	stat = le_rdcsr(LE_CSR0);
	if (stat & LE_C0_ERR)
		le_error(nif, "le_put(after xmit)", stat);
	do {
		stat = le_rdcsr(LE_CSR0);
		if (--timo == 0) {
			printf("le%d: transmit timeout, stat = 0x%x\n",
			    nif->nif_unit, stat);
			if (stat & LE_C0_ERR)
				le_error(nif, "le_put(timeout)", stat);
			break;
		}
	} while ((stat & LE_C0_TINT) == 0);
	le_wrcsr(LE_CSR0, LE_C0_TINT);
	stat = le_rdcsr(LE_CSR0);
	if (stat & LE_C0_ERR) {
		if ((stat &
		     (LE_C0_BABL | LE_C0_CERR | LE_C0_MISS | LE_C0_MERR)) !=
		    LE_C0_CERR)
			printf("le_put: xmit error, buf %d\n",
			    le_softc.next_tmd);
		le_error(nif, "le_put(xmit error)", stat);
	}
	le_softc.next_tmd = 0;
/*	(le_softc.next_tmd == (LETBUF - 1)) ? 0 : le_softc.next_tmd + 1;*/
	if (tmd->tmd1_bits & LE_T1_DEF)
		drv->netif_ifs[nif->nif_unit].dif_stats->deferred++;
	if (tmd->tmd1_bits & LE_T1_ONE)
		drv->netif_ifs[nif->nif_unit].dif_stats->collisions++;
	if (tmd->tmd1_bits & LE_T1_MORE)
		drv->netif_ifs[nif->nif_unit].dif_stats->collisions += 2;
	if (tmd->tmd1_bits & LE_T1_ERR) {
		printf("le%d: transmit error, error = 0x%x\n",
		    nif->nif_unit, tmd->tmd3);
		return -1;
	}
	if (le_debug) {
		printf("le%d: le_put() successful: sent %d\n",
		    nif->nif_unit, len);
		printf("le%d: le_put(): tmd1_bits: %x tmd3: %x\n",
		    nif->nif_unit,
		    (unsigned int) tmd->tmd1_bits,
		    (unsigned int) tmd->tmd3);
	}
	return len;
}

int
le_get(struct iodesc *desc, void *pkt, size_t len, time_t timeout)
{
	time_t  t;
	int     cc;

	t = getsecs();
	cc = 0;
	while (((getsecs() - t) < timeout) && !cc) {
		cc = le_poll(desc, pkt, len);
	}
	return cc;
}
/*
 * init le device.   return 0 on failure, 1 if ok.
 */
void
le_init(struct iodesc *desc, void *machdep_hint)
{
	struct netif *nif = desc->io_netif;

	if (le_debug)
		printf("le%d: le_init called\n", nif->nif_unit);
	bcopy(le_config[nif->nif_unit].eaddr, desc->myea, 6);
	bzero(&le_softc, sizeof(le_softc));
	/* no on-board le on mvme88k */
	le_softc.sc_r1 = NULL;
	le_softc.sc_vr1 = (struct vlereg1 *)le_config[nif->nif_unit].phys_addr;
	if (le_config[nif->nif_unit].buf_size != 0) {
		le_softc.sc_r2 =
		    (struct lereg2 *)le_config[nif->nif_unit].buf_addr;
	} else {
		le_softc.sc_r2 = (struct lereg2 *)(HEAP_START - LEMEMSIZE);
	}
	le_reset(nif, desc->myea);
#if 0
	printf("device: %s%d attached to %s\n", nif->nif_driver->netif_bname,
	    nif->nif_unit, ether_sprintf(desc->myea));
#endif
	bugargs.ctrl_lun = le_config[nif->nif_unit].clun;
	bugargs.dev_lun = 0;
	bugargs.ctrl_addr = le_config[nif->nif_unit].phys_addr;
}

void
le_end(struct netif *nif)
{
	if (le_debug)
		printf("le%d: le_end called\n", nif->nif_unit);
	le_wrcsr(LE_CSR0, LE_C0_STOP);
}

void nvram_cmd(struct vlereg1 *, u_char, u_short);
u_int16_t nvram_read(struct vlereg1 *, u_char);

/* send command to the nvram controller */
void
nvram_cmd(struct vlereg1 *reg1, u_char cmd, u_short addr)
{
	int i;

	for (i = 0; i < 8; i++) {
		reg1->ler1_ear = ((cmd | (addr << 1)) >> i); 
		CDELAY; 
	} 
}

/* read nvram one bit at a time */
u_int16_t
nvram_read(struct vlereg1 *reg1, u_char nvram_addr)
{
	u_short val = 0, mask = 0x04000;
	u_int16_t wbit;

	ENABLE_NVRAM(reg1->ler1_csr);
	nvram_cmd(reg1, NVRAM_RCL, 0);
	DISABLE_NVRAM(reg1->ler1_csr);
	CDELAY;
	ENABLE_NVRAM(reg1->ler1_csr);
	nvram_cmd(reg1, NVRAM_READ, nvram_addr);
	for (wbit = 0; wbit < 15; wbit++) {
		if (reg1->ler1_ear & 0x01)
			val |= mask;
		else
			val &= ~mask;
		mask = mask >> 1;
		CDELAY;
	}
	if (reg1->ler1_ear & 0x01)
		val |= 0x8000;
	else
		val &= 0x7fff;
	CDELAY;
	DISABLE_NVRAM(reg1->ler1_csr);
	return (val);
}

void
le_read_etheraddr(u_int phys_addr, u_char *enaddr)
{
	struct vlereg1 *reg1 = (struct vlereg1 *)phys_addr;
	u_int16_t ival[3];
	int i;

	for (i = 0; i < 3; i++) {
		ival[i] = nvram_read(reg1, i);
	}
	memcpy(enaddr, &ival[0], 6);
}
@


1.9
log
@Make sboot really match its documented behaviour when booting without an
interface name.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.8 2013/05/12 10:43:45 miod Exp $ */
@


1.8
log
@S-Records boot code for mvme88k, finally. Allows a kernel to be loaded from
network, using either the on-board interface (on MVME187 and MVME197) or
any MVME376.

While there, add MVME376 support to netboot.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.7 2009/01/18 21:49:11 miod Exp $ */
d142 2
a143 1
		if (le_config[nif->nif_unit].clun == bugargs.ctrl_lun)
@


1.7
log
@Define HEAP_START so that we can use space below it for ethernet buffers;
this prevents if_ie buffers from possibly overwriting the stack.
Crank bootloader versions.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.6 2006/05/16 22:52:26 miod Exp $ */
d56 30
d104 2
d107 1
a107 1
void le_error(struct netif *, char *, volatile struct lereg1 *);
a115 10
struct netif_stats le_stats;

struct netif_dif le0_dif = {
	0,			/* unit */
	1,			/* nsel */
	&le_stats,
	0,
	0,
};

d124 2
a125 9
	&le0_dif,		/* netif_ifs */
	1,			/* netif_nifs */
};

struct le_configuration {
	unsigned int phys_addr;
	int     used;
} le_config[] = {
	{ LANCE_REG_ADDR, 0 }
a127 2
int     nle_config = sizeof(le_config) / (sizeof(le_config[0]));

d130 1
d134 1
a134 1
}       le_softc;
d137 12
a148 17
le_match(nif, machdep_hint)
	struct netif *nif;
	void   *machdep_hint;
{
	char   *name;
	int     i, val = 0;

	name = machdep_hint;
	if (name && !bcmp(le_driver.netif_bname, name, 2))
		val += 10;
	for (i = 0; i < nle_config; i++) {
		if (le_config[i].used)
			continue;
		if (le_debug)
			printf("le%d: le_match --> %d\n", i, val + 1);
		le_config[i].used++;
		return val + 1;
d150 1
a150 2
	if (le_debug)
		printf("le%d: le_match --> 0\n", i);
d155 1
a155 3
le_probe(nif, machdep_hint)
	struct netif *nif;
	void   *machdep_hint;
d157 2
d160 16
a175 3
	/* the set unit is the current unit */
	if (le_debug)
		printf("le%d: le_probe called\n", nif->nif_unit);
d177 8
a184 1
	return 1;
d188 1
a188 4
le_error(nif, str, ler1)
	struct netif *nif;
	char   *str;
	volatile struct lereg1 *ler1;
d190 3
a192 2
	/* ler1->ler1_rap = LE_CSRO done in caller */
	if (ler1->ler1_rdp & LE_C0_BABL)
d194 10
a203 11
	if (ler1->ler1_rdp & LE_C0_CERR) {
		le_stats.collision_error++;
		ler1->ler1_rdp = LE_C0_CERR;
	}
	if (ler1->ler1_rdp & LE_C0_MISS) {
		le_stats.missed++;
		ler1->ler1_rdp = LE_C0_MISS;
	}
	if (ler1->ler1_rdp & LE_C0_MERR) {
		printf("le%d: memory error in '%s'\n", nif->nif_unit, str);
		panic("memory error");
d208 1
a208 3
le_reset(nif, myea)
	struct netif *nif;
	u_char *myea;
a209 1
	struct lereg1 *ler1 = le_softc.sc_r1;
d212 2
a213 1
	int     timo = 100000, stat, i;
d217 7
a223 2
	ler1->ler1_rap = LE_CSR0;
	ler1->ler1_rdp = LE_C0_STOP;	/* do nothing until we are finished */
a234 1

d238 11
a248 13
	a = (u_int) ler2->ler2_rmd;
	ler2->ler2_rlen = LE_RLEN | (a >> 16);
	ler2->ler2_rdra = a & LE_ADDR_LOW_MASK;

	a = (u_int) ler2->ler2_tmd;
	ler2->ler2_tlen = LE_TLEN | (a >> 16);
	ler2->ler2_tdra = a & LE_ADDR_LOW_MASK;

	ler1->ler1_rap = LE_CSR1;
	a = (u_int) ler2;
	ler1->ler1_rdp = a & LE_ADDR_LOW_MASK;
	ler1->ler1_rap = LE_CSR2;
	ler1->ler1_rdp = a >> 16;
d251 2
a252 2
		a = (u_int) & ler2->ler2_rbuf[i];
		ler2->ler2_rmd[i].rmd0 = a & LE_ADDR_LOW_MASK;
d254 1
a254 1
		ler2->ler2_rmd[i].rmd1_hadr = a >> 16;
d259 2
a260 2
		a = (u_int) & ler2->ler2_tbuf[i];
		ler2->ler2_tmd[i].tmd0 = a & LE_ADDR_LOW_MASK;
d262 1
a262 1
		ler2->ler2_tmd[i].tmd1_hadr = a >> 16;
d267 1
a267 2
	ler1->ler1_rap = LE_CSR3;
	ler1->ler1_rdp = LE_C3_BSWP;
d269 1
a269 2
	ler1->ler1_rap = LE_CSR0;
	ler1->ler1_rdp = LE_C0_INIT;
d271 1
a276 1
		stat = ler1->ler1_rdp;
d279 1
a279 1
	ler1->ler1_rdp = LE_C0_IDON;
d282 1
a282 2
	ler1->ler1_rap = LE_CSR0;
	ler1->ler1_rdp = LE_C0_STRT;
d286 1
a286 4
le_poll(desc, pkt, len)
	struct iodesc *desc;
	void   *pkt;
	int     len;
d288 1
a288 1
	struct lereg1 *ler1 = le_softc.sc_r1;
d293 1
d295 3
a297 4

	ler1->ler1_rap = LE_CSR0;
	if ((ler1->ler1_rdp & LE_C0_RINT) != 0)
		ler1->ler1_rdp = LE_C0_RINT;
d302 2
a303 2
	if (ler1->ler1_rdp & LE_C0_ERR)
		le_error(desc->io_netif, "le_poll", ler1);
d305 2
a306 2
		printf("le%d_poll: rmd status 0x%x\n", desc->io_netif->nif_unit,
		    rmd->rmd1_bits);
d310 2
a311 1
	if ((rmd->rmd1_bits & (LE_R1_STP | LE_R1_ENP)) != (LE_R1_STP | LE_R1_ENP))
d317 1
a317 1
		panic("csr0 when bad things happen: %x", ler1->ler1_rdp);
d335 3
a337 3
	a = (u_int) & ler2->ler2_rbuf[le_softc.next_rmd];
	rmd->rmd0 = a & LE_ADDR_LOW_MASK;
	rmd->rmd1_hadr = a >> 16;
d346 1
a346 4
le_put(desc, pkt, len)
	struct	iodesc *desc;
	void	*pkt;
	size_t	len;
d348 2
a349 1
	volatile struct lereg1 *ler1 = le_softc.sc_r1;
d352 1
a352 1
	int     timo = 100000, stat, i;
d354 1
d356 3
a358 3
	ler1->ler1_rap = LE_CSR0;
	if (ler1->ler1_rdp & LE_C0_ERR)
		le_error(desc->io_netif, "le_put(way before xmit)", ler1);
d361 1
a361 1
		printf("le%d: output buffer busy\n", desc->io_netif->nif_unit);
d369 3
a371 2
	if (ler1->ler1_rdp & LE_C0_ERR)
		le_error(desc->io_netif, "le_put(before xmit)", ler1);
d373 7
a379 6
	a = (u_int) & ler2->ler2_tbuf[le_softc.next_tmd];
	tmd->tmd0 = a & LE_ADDR_LOW_MASK;
	tmd->tmd1_hadr = a >> 16;
	ler1->ler1_rdp = LE_C0_TDMD;
	if (ler1->ler1_rdp & LE_C0_ERR)
		le_error(desc->io_netif, "le_put(after xmit)", ler1);
d381 1
d384 3
a386 3
			    desc->io_netif->nif_unit, stat);
			if (ler1->ler1_rdp & LE_C0_ERR)
				le_error(desc->io_netif, "le_put(timeout)", ler1);
a388 1
		stat = ler1->ler1_rdp;
d390 5
a394 4
	ler1->ler1_rdp = LE_C0_TINT;
	if (ler1->ler1_rdp & LE_C0_ERR) {
		if ((ler1->ler1_rdp & (LE_C0_BABL | LE_C0_CERR | LE_C0_MISS |
		    LE_C0_MERR)) !=
d396 3
a398 2
			printf("le_put: xmit error, buf %d\n", le_softc.next_tmd);
		le_error(desc->io_netif, "le_put(xmit error)", ler1);
d403 1
a403 1
		le_stats.deferred++;
d405 1
a405 1
		le_stats.collisions++;
d407 1
a407 1
		le_stats.collisions += 2;
d409 2
a410 2
		printf("le%d: transmit error, error = 0x%x\n", desc->io_netif->nif_unit,
		    tmd->tmd3);
d415 1
a415 1
		    desc->io_netif->nif_unit, len);
d417 1
a417 1
		    desc->io_netif->nif_unit,
d425 1
a425 5
le_get(desc, pkt, len, timeout)
	struct	iodesc *desc;
	void	*pkt;
	size_t	len;
	time_t	timeout;
d441 1
a441 3
le_init(desc, machdep_hint)
	struct iodesc *desc;
	void   *machdep_hint;
d446 2
a447 2
		printf("le%d: le_init called\n", desc->io_netif->nif_unit);
	machdep_common_ether(desc->myea);
d449 11
a459 4
	le_softc.sc_r1 =
	    (struct lereg1 *) le_config[desc->io_netif->nif_unit].phys_addr;
	le_softc.sc_r2 = (struct lereg2 *)(HEAP_START - LEMEMSIZE);
	le_reset(desc->io_netif, desc->myea);
d462 4
d469 1
a469 2
le_end(nif)
	struct netif *nif;
a470 2
	struct lereg1 *ler1 = le_softc.sc_r1;

d473 59
a531 2
	ler1->ler1_rap = LE_CSR0;
	ler1->ler1_rdp = LE_C0_STOP;
@


1.6
log
@Nuke whitespace at EOL
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.5 2003/06/04 16:36:15 deraadt Exp $ */
a425 1
	u_long eram = 4*1024*1024;
d434 1
a434 1
	le_softc.sc_r2 = (struct lereg2 *) (eram - (1024 * 1024));
@


1.5
log
@more term 3 & 4 from various developers, with permission of course
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.4 2002/03/14 01:26:40 millert Exp $ */
d5 1
a5 1
 * 
@


1.4
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.3 1999/01/11 05:11:46 millert Exp $ */
a13 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Theo de Raadt for Willowglen Singapore.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.3
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.2 1998/08/22 08:38:02 smurph Exp $ */
d80 9
a88 9
void le_end __P((struct netif *));
void le_error __P((struct netif *, char *, volatile struct lereg1 *));
int le_get __P((struct iodesc *, void *, size_t, time_t));
void le_init __P((struct iodesc *, void *));
int le_match __P((struct netif *, void *));
int le_poll __P((struct iodesc *, void *, int));
int le_probe __P((struct netif *, void *));
int le_put __P((struct iodesc *, void *, size_t));
void le_reset __P((struct netif *, u_char *));
@


1.3.16.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.3 1999/01/11 05:11:46 millert Exp $ */
d80 9
a88 9
void le_end(struct netif *);
void le_error(struct netif *, char *, volatile struct lereg1 *);
int le_get(struct iodesc *, void *, size_t, time_t);
void le_init(struct iodesc *, void *);
int le_match(struct netif *, void *);
int le_poll(struct iodesc *, void *, int);
int le_probe(struct netif *, void *);
int le_put(struct iodesc *, void *, size_t);
void le_reset(struct netif *, u_char *);
@


1.3.6.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d80 9
a88 9
void le_end(struct netif *);
void le_error(struct netif *, char *, volatile struct lereg1 *);
int le_get(struct iodesc *, void *, size_t, time_t);
void le_init(struct iodesc *, void *);
int le_match(struct netif *, void *);
int le_poll(struct iodesc *, void *, int);
int le_probe(struct netif *, void *);
int le_put(struct iodesc *, void *, size_t);
void le_reset(struct netif *, u_char *);
@


1.3.6.2
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.3.6.1 2002/03/28 10:36:03 niklas Exp $ */
d14 6
@


1.2
log
@working netboot.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.6 1996/05/16 02:55:37 chuck Exp $ */
d173 1
a173 1
		panic("le%d: been babbling, found by '%s'\n", nif->nif_unit, str);
d298 1
a298 1
		panic("le_poll: chained packet\n");
d303 1
a303 1
		panic("csr0 when bad things happen: %x\n", ler1->ler1_rdp);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$Id: if_le.c,v 1.4 1995/12/26 17:44:43 deraadt Exp $ */
d69 2
d72 1
a134 1
	extern int cputyp;
a135 2
	if (cputyp != CPU_147)
		return (0);
a156 1
	extern int cputyp;
a161 2
	if (cputyp == CPU_147)
		return 0;
@


1.1.1.1
log
@Third try at importing the mvme88k port. This is a working kernel
from nivas.
Userland and compiler still need to be worked on.
Make certain what directory the import is done from.
@
text
@@
