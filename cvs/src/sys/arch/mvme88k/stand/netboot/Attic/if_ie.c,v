head	1.12;
access;
symbols
	OPENBSD_5_5:1.11.0.6
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.9.0.18
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.16
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.14
	OPENBSD_5_0:1.9.0.12
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.10
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.8
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.4
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.7.0.12
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.10
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.8
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.6
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.4
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.5
	UBC:1.4.0.16
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.14
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.12
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.10
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.8
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.6
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.4
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.1.1.1.0.6
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.4
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.2
	OPENBSD_2_1_BASE:1.1.1.1
	mvme88kport:1.1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2014.03.18.22.36.37;	author miod;	state dead;
branches;
next	1.11;

1.11
date	2013.05.12.21.00.56;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2013.05.12.10.43.45;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2009.01.18.21.49.11;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.16.22.52.09;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.04.16.36.15;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2003.01.28.01.37.52;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.14.01.26.40;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	99.01.11.05.11.46;	author millert;	state Exp;
branches
	1.4.6.1
	1.4.16.1;
next	1.3;

1.3
date	98.12.15.06.32.35;	author smurph;	state Exp;
branches;
next	1.2;

1.2
date	98.08.22.08.38.00;	author smurph;	state Exp;
branches;
next	1.1;

1.1
date	97.03.03.19.30.38;	author rahnds;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.03.03.19.30.38;	author rahnds;	state Exp;
branches;
next	;

1.4.6.1
date	2002.03.28.10.36.03;	author niklas;	state Exp;
branches;
next	1.4.6.2;

1.4.6.2
date	2003.03.27.23.32.19;	author niklas;	state Exp;
branches;
next	1.4.6.3;

1.4.6.3
date	2003.06.07.11.13.17;	author ho;	state Exp;
branches;
next	;

1.4.16.1
date	2002.06.11.03.37.11;	author art;	state Exp;
branches;
next	1.4.16.2;

1.4.16.2
date	2003.05.19.21.45.53;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: if_ie.c,v 1.11 2013/05/12 21:00:56 miod Exp $ */

/*
 * Copyright (c) 1995 Theo de Raadt
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/types.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>

#define ETHER_MIN_LEN   64
#define ETHER_MAX_LEN   1518
#define ETHER_CRC_LEN	4

#define NTXBUF	1
#define NRXBUF	16
#define IE_RBUF_SIZE	ETHER_MAX_LEN

#include <machine/prom.h>

#include "stand.h"
#include "libsa.h"
#include "netif.h"
#include "config.h"
#include "net.h"

#include "i82586.h"

int     ie_debug = 0;

void ie_stop(struct netif *);
void ie_end(struct netif *);
int ie_get(struct iodesc *, void *, size_t, time_t);
void ie_init(struct iodesc *, void *);
int ie_match(struct netif *, void *);
int ie_poll(struct iodesc *, void *, int);
int ie_probe(struct netif *, void *);
int ie_put(struct iodesc *, void *, size_t);
void ie_reset(struct netif *, u_char *);

struct netif_driver ie_driver = {
	"ie",			/* netif_bname */
	ie_match,		/* match */
	ie_probe,		/* probe */
	ie_init,		/* init */
	ie_get,			/* get */
	ie_put,			/* put */
	ie_end,			/* end */
	NULL,			/* netif_ifs - will be filled later */
	0,			/* netif_nifs - will be filled later */
};

struct {
	struct iereg *sc_reg;	/* IE registers */
	struct iemem *sc_mem;	/* RAM */
} ie_softc;

int
ie_match(struct netif *nif, void *machdep_hint)
{
	const char *name = machdep_hint;

	if (name == NULL) {
		if (ie_config[nif->nif_unit].clun == bugargs.ctrl_lun ||
		    (int)bugargs.ctrl_lun < 0)
			return 1;
	} else {
		if (bcmp(ie_driver.netif_bname, name, 2) == 0) {
			if (nif->nif_unit == name[2] - '0')
				return 1;
		}
	}

	return 0;
}

int
ie_probe(struct netif *nif, void *machdep_hint)
{
	return 0;
}

void
ieack(volatile struct iereg *ier, struct iemem *iem)
{
	/* ack the `interrupt' */
	iem->im_scb.ie_command = iem->im_scb.ie_status & IE_ST_WHENCE;
	ier->ie_attention = 1;	/* chan attention! */
	while (iem->im_scb.ie_command)
		;
}

void
ie_reset(struct netif *nif, u_char *myea)
{
	volatile struct iereg *ier = ie_softc.sc_reg;
	struct iemem *iem = ie_softc.sc_mem;
	int     timo = 10000, i;
	volatile int t;
	u_int   a;

	if (ie_debug)
		printf("ie%d: ie_reset called\n", nif->nif_unit);

	/*printf("ier %x iem %x\n", ier, iem);*/

	*(u_char *)0xfff4202a = 0x40;

	bzero(iem, sizeof(*iem));
	iem->im_scp.scp_sysbus = 0;
	iem->im_scp.scp_iscp_low = (int) &iem->im_iscp & 0xffff;
	iem->im_scp.scp_iscp_high = (int) &iem->im_iscp >> 16;

	iem->im_iscp.iscp_scboffset = (int) &iem->im_scb - (int) iem;
	iem->im_iscp.iscp_busy = 1;
	iem->im_iscp.iscp_base_low = (int) iem & 0xffff;
	iem->im_iscp.iscp_base_high = (int) iem >> 16;

	/*
	 * completely and utterly unlike what i expected, the
	 * "write" order is:
	 * 1st:	d15-d0 -> high address
	 * 2nd:	d31-d16 -> low address
	 */

	/* reset chip */
	a = IE_PORT_RESET;
	ier->ie_porthigh = a & 0xffff;
	t = 0;
	t = 1;
	ier->ie_portlow = a >> 16;
	for (t = timo; t--;)
		;

	/* set new SCP pointer */
	a = (int) &iem->im_scp | IE_PORT_NEWSCP;
	ier->ie_porthigh = a & 0xffff;
	t = 0;
	t = 1;
	ier->ie_portlow = a >> 16;
	for (t = timo; t--;)
		;

	ier->ie_attention = 1;	/* chan attention! */
	for (t = timo * 10; t--;)
		;

	/* send CONFIGURE command */
	iem->im_scb.ie_command = IE_CU_START;
	iem->im_scb.ie_command_list = (int) &iem->im_cc - (int) iem;
	iem->im_cc.com.ie_cmd_status = 0;
	iem->im_cc.com.ie_cmd_cmd = IE_CMD_CONFIG | IE_CMD_LAST;
	iem->im_cc.com.ie_cmd_link = 0xffff;
	iem->im_cc.ie_config_count = 0x0c;
	iem->im_cc.ie_fifo = 8;
	iem->im_cc.ie_save_bad = 0x40;
	iem->im_cc.ie_addr_len = 0x2e;
	iem->im_cc.ie_priority = 0;
	iem->im_cc.ie_ifs = 0x60;
	iem->im_cc.ie_slot_low = 0;
	iem->im_cc.ie_slot_high = 0xf2;
	iem->im_cc.ie_promisc = 0;
	iem->im_cc.ie_crs_cdt = 0;
	iem->im_cc.ie_min_len = 64;
	iem->im_cc.ie_junk = 0xff;

	ier->ie_attention = 1;	/* chan attention! */
	for (t = timo * 10; t--;)
		;

	ieack(ier, iem);

	/*printf("ic %x\n", &iem->im_ic);*/
	/* send IASETUP command */
	iem->im_scb.ie_command = IE_CU_START;
	iem->im_scb.ie_command_list = (int) &iem->im_ic - (int) iem;
	iem->im_ic.com.ie_cmd_status = 0;
	iem->im_ic.com.ie_cmd_cmd = IE_CMD_IASETUP | IE_CMD_LAST;
	iem->im_ic.com.ie_cmd_link = 0xffff;
	bcopy(myea, (void *)&iem->im_ic.ie_address, sizeof iem->im_ic.ie_address);

	ier->ie_attention = 1;	/* chan attention! */
	for (t = timo * 10; t--;)
		;

	ieack(ier, iem);

	/* setup buffers */

	for (i = 0; i < NRXBUF; i++) {
		iem->im_rfd[i].ie_fd_next = (int) &iem->im_rfd[(i+1) % NRXBUF] -
		    (int) iem;
		iem->im_rbd[i].ie_rbd_next = (int) &iem->im_rbd[(i+1) % NRXBUF] -
		    (int) iem;
		a = (int) &iem->im_rxbuf[i * IE_RBUF_SIZE];
		iem->im_rbd[i].ie_rbd_buffer_low = a & 0xffff;
		iem->im_rbd[i].ie_rbd_buffer_high = a >> 16;
		iem->im_rbd[i].ie_rbd_length = IE_RBUF_SIZE;
	}
	iem->im_rfd[NRXBUF-1].ie_fd_last |= IE_FD_LAST;
	iem->im_rbd[NRXBUF-1].ie_rbd_length |= IE_RBD_LAST;
	iem->im_rfd[0].ie_fd_buf_desc = (int) &iem->im_rbd[0] - (int) iem;

	/*printf("rfd[0] %x rbd[0] %x buf[0] %x\n", &iem->im_rfd, &iem->im_rbd,
	    &iem->im_rxbuf);*/

	/* send receiver start command */
	iem->im_scb.ie_command = IE_RU_START;
	iem->im_scb.ie_command_list = 0;
	iem->im_scb.ie_recv_list = (int) &iem->im_rfd[0] - (int) iem;
	ier->ie_attention = 1;	/* chan attention! */
	while (iem->im_scb.ie_command)
		;

	ieack(ier, iem);
}

int
ie_poll(struct iodesc *desc, void *pkt, int len)
{
	volatile struct iereg *ier = ie_softc.sc_reg;
	struct iemem *iem = ie_softc.sc_mem;
	static int slot;
	int     length = 0;
	u_short status;

	status = iem->im_rfd[slot].ie_fd_status;
	if (status & IE_FD_BUSY)
		return (0);

	/* printf("slot %d: %x\n", slot, status); */
	if ((status & (IE_FD_COMPLETE | IE_FD_OK)) ==
	    (IE_FD_COMPLETE | IE_FD_OK)) {
		if (status & IE_FD_OK) {
			length = iem->im_rbd[slot].ie_rbd_actual & 0x3fff;
			if (length > len)
				length = len;
			bcopy((void *)&iem->im_rxbuf[slot * IE_RBUF_SIZE],
			    pkt, length);

			iem->im_rfd[slot].ie_fd_status = 0;
			iem->im_rfd[slot].ie_fd_last |= IE_FD_LAST;
			iem->im_rfd[(slot+NRXBUF-1)%NRXBUF].ie_fd_last &=
			    ~IE_FD_LAST;
			iem->im_rbd[slot].ie_rbd_actual = 0;
			iem->im_rbd[slot].ie_rbd_length |= IE_RBD_LAST;
			iem->im_rbd[(slot+NRXBUF-1)%NRXBUF].ie_rbd_length &=
			    ~IE_RBD_LAST;
			/*printf("S%d\n", slot);*/

		} else {
			printf("shit\n");
		}
		slot++;
		/* should move descriptor onto end of queue... */
	}
	if ((iem->im_scb.ie_status & IE_RU_READY) == 0) {
		printf("RR\n");

		for (slot = 0; slot < NRXBUF; slot++) {
			iem->im_rbd[slot].ie_rbd_length &= ~IE_RBD_LAST;
			iem->im_rfd[slot].ie_fd_last &= ~IE_FD_LAST;
		}
		iem->im_rbd[NRXBUF-1].ie_rbd_length |= IE_RBD_LAST;
		iem->im_rfd[NRXBUF-1].ie_fd_last |= IE_FD_LAST;

		iem->im_rfd[0].ie_fd_buf_desc = (int)&iem->im_rbd[0] - (int)iem;

		iem->im_scb.ie_command = IE_RU_START;
		iem->im_scb.ie_command_list = 0;
		iem->im_scb.ie_recv_list = (int)&iem->im_rfd[0] - (int)iem;
		ier->ie_attention = 1;	/* chan attention! */
		while (iem->im_scb.ie_command)
			;
		slot = 0;
	}
	slot = slot % NRXBUF;
	return (length);
}

int
ie_put(struct iodesc *desc, void *pkt, size_t len)
{
	volatile struct iereg *ier = ie_softc.sc_reg;
	struct iemem *iem = ie_softc.sc_mem;
	u_char *p = pkt;
	u_int   a;
	int     xx = 0;

	/* send transmit command */

	while (iem->im_scb.ie_command)
		;

	/* copy data */
	bcopy(p, (void *)&iem->im_txbuf[xx], len);

	if (len < ETHER_MIN_LEN - ETHER_CRC_LEN) {
		bzero((char *)&iem->im_txbuf[xx] + len,
		    ETHER_MIN_LEN - ETHER_CRC_LEN - len);
		len = ETHER_MIN_LEN - ETHER_CRC_LEN;
	}

	/* build transmit descriptor */
	iem->im_xd[xx].ie_xmit_flags = len | IE_XMIT_LAST;
	iem->im_xd[xx].ie_xmit_next = 0xffff;
	a = (int) &iem->im_txbuf[xx];
	iem->im_xd[xx].ie_xmit_buf_low = a & 0xffff;
	iem->im_xd[xx].ie_xmit_buf_high = a >> 16;

	/* transmit command */
	iem->im_xc[xx].com.ie_cmd_status = 0;
	iem->im_xc[xx].com.ie_cmd_cmd = IE_CMD_XMIT | IE_CMD_LAST;
	iem->im_xc[xx].com.ie_cmd_link = 0xffff;
	iem->im_xc[xx].ie_xmit_desc = (int) &iem->im_xd[xx] - (int) iem;
	iem->im_xc[xx].ie_xmit_length = len;
	bcopy(p, (void *)&iem->im_xc[xx].ie_xmit_addr,
	    sizeof iem->im_xc[xx].ie_xmit_addr);

	iem->im_scb.ie_command = IE_CU_START;
	iem->im_scb.ie_command_list = (int) &iem->im_xc[xx] - (int) iem;

	ier->ie_attention = 1;	/* chan attention! */

	if (ie_debug) {
		printf("ie%d: send %ld to %x:%x:%x:%x:%x:%x\n",
		    desc->io_netif->nif_unit, len,
		    p[0], p[1], p[2], p[3], p[4], p[5]);
	}
	return (len);
}

int
ie_get(struct iodesc *desc, void *pkt, size_t len, time_t timeout)
{
	time_t  t;
	int     cc;

	t = getsecs();
	cc = 0;
	while (((getsecs() - t) < timeout) && !cc) {
		cc = ie_poll(desc, pkt, len);
	}
	return (cc);
}
/*
 * init ie device.   return 0 on failure, 1 if ok.
 */
void
ie_init(struct iodesc *desc, void *machdep_hint)
{
	struct netif *nif = desc->io_netif;

	if (ie_debug)
		printf("ie%d: ie_init called\n", nif->nif_unit);
	bcopy(ie_config[nif->nif_unit].eaddr, desc->myea, 6);
	bzero(&ie_softc, sizeof(ie_softc));
	ie_softc.sc_reg = (struct iereg *) ie_config[nif->nif_unit].phys_addr;
	/* use 64KB below HEAP as buffers */
	ie_softc.sc_mem = (struct iemem *)(HEAP_START - 0x10000);
	ie_reset(nif, desc->myea);
#if 0
	printf("device: %s%d attached to %s\n", nif->nif_driver->netif_bname,
	    nif->nif_unit, ether_sprintf(desc->myea));
#endif
	bugargs.ctrl_lun = ie_config[nif->nif_unit].clun;
	bugargs.dev_lun = 0;
	bugargs.ctrl_addr = ie_config[nif->nif_unit].phys_addr;
}

void
ie_stop(struct netif *nif)
{
	volatile struct iereg *ier = ie_softc.sc_reg;
	struct iemem *iem = ie_softc.sc_mem;
	int     timo = 10000;
	volatile int t;
	u_int   a;

	iem->im_iscp.iscp_busy = 1;
	/* reset chip */
	a = IE_PORT_RESET;
	ier->ie_porthigh = a & 0xffff;
	t = 0;
	t = 1;
	ier->ie_portlow = a >> 16;
	for (t = timo; t--;)
		;

	/* reset chip again */
	a = IE_PORT_RESET;
	ier->ie_porthigh = a & 0xffff;
	t = 0;
	t = 1;
	ier->ie_portlow = a >> 16;
	for (t = timo; t--;)
		;

	/*printf("status %x busy %x\n", iem->im_scb.ie_status,
	    iem->im_iscp.iscp_busy);*/
}

void
ie_end(struct netif *nif)
{
	if (ie_debug)
		printf("ie%d: ie_end called\n", nif->nif_unit);

	ie_stop(nif);
}
@


1.11
log
@Make sboot really match its documented behaviour when booting without an
interface name.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.10 2013/05/12 10:43:45 miod Exp $ */
@


1.10
log
@S-Records boot code for mvme88k, finally. Allows a kernel to be loaded from
network, using either the on-board interface (on MVME187 and MVME197) or
any MVME376.

While there, add MVME376 support to netboot.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.9 2009/01/18 21:49:11 miod Exp $ */
d87 2
a88 1
		if (ie_config[nif->nif_unit].clun == bugargs.ctrl_lun)
@


1.9
log
@Define HEAP_START so that we can use space below it for ethernet buffers;
this prevents if_ie buffers from possibly overwriting the stack.
Crank bootloader versions.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.8 2006/05/16 22:52:09 miod Exp $ */
a50 1
#include "if_iereg.h"
a55 1
void ie_error(struct netif *, char *, volatile struct iereg *);
a62 11
extern void machdep_common_ether(u_char *);

struct netif_stats ie_stats;

struct netif_dif ie0_dif = {
	0,			/* unit */
	1,			/* nsel */
	&ie_stats,
	0,
	0,
};
d72 2
a73 9
	&ie0_dif,		/* netif_ifs */
	1,			/* netif_nifs */
};

struct ie_configuration {
	u_int   phys_addr;
	int     used;
} ie_config[] = {
	{ INTEL_REG_ADDR, 0 }
a75 2
int     nie_config = sizeof(ie_config) / (sizeof(ie_config[0]));

d79 1
a79 1
}       ie_softc;
d82 1
a82 3
ie_match(nif, machdep_hint)
	struct netif *nif;
	void   *machdep_hint;
d84 1
a84 2
	char   *name;
	int     i, val = 0;
d86 8
a93 10
	name = machdep_hint;
	if (name && !bcmp(ie_driver.netif_bname, name, 2))
		val += 10;
	for (i = 0; i < nie_config; i++) {
		if (ie_config[i].used)
			continue;
		if (ie_debug)
			printf("ie%d: ie_match --> %d\n", i, val + 1);
		ie_config[i].used++;
		return (val + 1);
d95 2
a96 3
	if (ie_debug)
		printf("ie%d: ie_match --> 0\n", i);
	return (0);
d100 1
a100 17
ie_probe(nif, machdep_hint)
	struct netif *nif;
	void   *machdep_hint;
{

	/* the set unit is the current unit */
	if (ie_debug)
		printf("ie%d: ie_probe called\n", nif->nif_unit);
	return (0);
/*	return (1);*/
}

void
ie_error(nif, str, ier)
	struct netif *nif;
	char   *str;
	volatile struct iereg *ier;
d102 1
a102 1
	panic("ie%d: unknown error", nif->nif_unit);
d106 1
a106 3
ieack(ier, iem)
	volatile struct iereg *ier;
	struct iemem *iem;
d116 1
a116 3
ie_reset(nif, myea)
	struct netif *nif;
	u_char *myea;
d241 1
a241 4
ie_poll(desc, pkt, len)
	struct iodesc *desc;
	void   *pkt;
	int     len;
d254 2
a255 1
	if ((status & (IE_FD_COMPLETE | IE_FD_OK)) == (IE_FD_COMPLETE | IE_FD_OK)) {
d304 1
a304 4
ie_put(desc, pkt, len)
	struct	iodesc *desc;
	void	*pkt;
	size_t	len;
d356 1
a356 5
ie_get(desc, pkt, len, timeout)
	struct	iodesc *desc;
	void	*pkt;
	size_t	len;
	time_t	timeout;
d372 1
a372 3
ie_init(desc, machdep_hint)
	struct iodesc *desc;
	void   *machdep_hint;
d377 2
a378 2
		printf("ie%d: ie_init called\n", desc->io_netif->nif_unit);
	machdep_common_ether(desc->myea);
d380 1
a380 2
	ie_softc.sc_reg =
	    (struct iereg *) ie_config[desc->io_netif->nif_unit].phys_addr;
d383 2
a384 1
	ie_reset(desc->io_netif, desc->myea);
d387 4
d394 1
a394 2
ie_stop(nif)
	struct netif *nif;
d426 1
a426 2
ie_end(nif)
	struct netif *nif;
a431 2

	/* *(u_char *) 0xfff42002 = 0; */
@


1.8
log
@Make standalone binaries compile with -Wall -Werror
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.7 2003/06/04 16:36:15 deraadt Exp $ */
a299 1
	asm(".word	0xf518\n");
d441 2
a442 1
	ie_softc.sc_mem = (struct iemem *) 0xae0000;
@


1.7
log
@more term 3 & 4 from various developers, with permission of course
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.6 2003/01/28 01:37:52 jason Exp $ */
d5 1
a5 1
 * 
d48 1
d65 1
d149 1
d168 1
a168 1
	int     timo = 10000, stat, i;
a295 1
	u_char *p = pkt;
a297 1
	u_int   a;
a362 2
	int     timo = 10000, stat, i;
	volatile int t;
d402 1
a402 1
		printf("ie%d: send %d to %x:%x:%x:%x:%x:%x\n",
@


1.6
log
@pad < minimal length packets with 0's; based on netbsd; tested by miod
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.5 2002/03/14 01:26:40 millert Exp $ */
a13 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Theo de Raadt for Willowglen Singapore.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.5
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.4 1999/01/11 05:11:46 millert Exp $ */
d42 1
d381 5
a385 1
	len = MAX(len, ETHER_MIN_LEN);
@


1.4
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.3 1998/12/15 06:32:35 smurph Exp $ */
d59 10
a68 10
void ie_stop __P((struct netif *));
void ie_end __P((struct netif *));
void ie_error __P((struct netif *, char *, volatile struct iereg *));
int ie_get __P((struct iodesc *, void *, size_t, time_t));
void ie_init __P((struct iodesc *, void *));
int ie_match __P((struct netif *, void *));
int ie_poll __P((struct iodesc *, void *, int));
int ie_probe __P((struct netif *, void *));
int ie_put __P((struct iodesc *, void *, size_t));
void ie_reset __P((struct netif *, u_char *));
@


1.4.16.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.4 1999/01/11 05:11:46 millert Exp $ */
d59 10
a68 10
void ie_stop(struct netif *);
void ie_end(struct netif *);
void ie_error(struct netif *, char *, volatile struct iereg *);
int ie_get(struct iodesc *, void *, size_t, time_t);
void ie_init(struct iodesc *, void *);
int ie_match(struct netif *, void *);
int ie_poll(struct iodesc *, void *, int);
int ie_probe(struct netif *, void *);
int ie_put(struct iodesc *, void *, size_t);
void ie_reset(struct netif *, u_char *);
@


1.4.16.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a41 1
#define ETHER_CRC_LEN	4
d380 1
a380 5
	if (len < ETHER_MIN_LEN - ETHER_CRC_LEN) {
		bzero((char *)&iem->im_txbuf[xx] + len,
		    ETHER_MIN_LEN - ETHER_CRC_LEN - len);
		len = ETHER_MIN_LEN - ETHER_CRC_LEN;
	}
@


1.4.6.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d59 10
a68 10
void ie_stop(struct netif *);
void ie_end(struct netif *);
void ie_error(struct netif *, char *, volatile struct iereg *);
int ie_get(struct iodesc *, void *, size_t, time_t);
void ie_init(struct iodesc *, void *);
int ie_match(struct netif *, void *);
int ie_poll(struct iodesc *, void *, int);
int ie_probe(struct netif *, void *);
int ie_put(struct iodesc *, void *, size_t);
void ie_reset(struct netif *, u_char *);
@


1.4.6.2
log
@Sync the SMP branch with 3.3
@
text
@a41 1
#define ETHER_CRC_LEN	4
d380 1
a380 5
	if (len < ETHER_MIN_LEN - ETHER_CRC_LEN) {
		bzero((char *)&iem->im_txbuf[xx] + len,
		    ETHER_MIN_LEN - ETHER_CRC_LEN - len);
		len = ETHER_MIN_LEN - ETHER_CRC_LEN;
	}
@


1.4.6.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.4.6.2 2003/03/27 23:32:19 niklas Exp $ */
d14 6
@


1.3
log
@This fixed a number of things.  A serious bug in bugcrt.c's initial stack
among other things.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.2 1998/08/22 08:38:00 smurph Exp $ */
d149 1
a149 1
	panic("ie%d: unknown error\n", nif->nif_unit);
@


1.2
log
@working netboot.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.5 1996/05/16 02:55:36 chuck Exp $ */
d444 1
a444 1
	ie_softc.sc_mem = (struct iemem *) 0x1e0000;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$Id: if_ie.c,v 1.3 1995/11/07 08:51:00 deraadt Exp $ */
d47 2
d50 1
a112 1
	extern int cputyp;
a113 2
	if (cputyp == CPU_147)
		return (0);
a134 1
	extern int cputyp;
d139 2
a140 4

	if (cputyp != CPU_147)
		return (0);
	return (1);
@


1.1.1.1
log
@Third try at importing the mvme88k port. This is a working kernel
from nivas.
Userland and compiler still need to be worked on.
Make certain what directory the import is done from.
@
text
@@
