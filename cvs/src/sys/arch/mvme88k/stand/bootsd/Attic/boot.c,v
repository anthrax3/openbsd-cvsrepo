head	1.11;
access;
symbols
	OPENBSD_5_5:1.10.0.4
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.9.0.4
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.2
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.8.0.26
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.24
	OPENBSD_5_0:1.8.0.22
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.20
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.18
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.14
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.16
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.12
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.7.0.12
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.10
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.8
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.6
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.4
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.10
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.8
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.6
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.6
	UBC:1.6.0.4
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.4.0.8
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.6
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.4
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.1.1.1.0.6
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.4
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.2
	OPENBSD_2_1_BASE:1.1.1.1
	mvme88kport:1.1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2014.03.18.22.36.36;	author miod;	state dead;
branches;
next	1.10;

1.10
date	2014.02.20.20.34.27;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2013.01.05.11.20.56;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.16.22.52.09;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.02.23.27.52;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.29.21.53.28;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.13.05.19.00;	author smurph;	state Exp;
branches;
next	1.4;

1.4
date	99.09.27.19.29.59;	author smurph;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	98.12.15.06.32.33;	author smurph;	state Exp;
branches;
next	1.2;

1.2
date	98.08.22.07.17.18;	author smurph;	state Exp;
branches;
next	1.1;

1.1
date	97.03.03.19.30.29;	author rahnds;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.03.03.19.30.29;	author rahnds;	state Exp;
branches;
next	;

1.4.4.1
date	2001.04.18.16.11.45;	author niklas;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2001.07.04.10.20.26;	author niklas;	state Exp;
branches;
next	1.4.4.3;

1.4.4.3
date	2003.06.07.11.13.17;	author ho;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: boot.c,v 1.10 2014/02/20 20:34:27 miod Exp $ */
/*	$NetBSD: boot.c,v 1.2 1995/09/23 03:42:52 gwr Exp $ */

/*-
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * 	@@(#)boot.c	8.1 (Berkeley) 6/10/93
 */

#include <sys/param.h>
#include <sys/reboot.h>
#include <sys/stat.h>
#define _KERNEL
#include <sys/fcntl.h>
#undef _KERNEL

#include <machine/prom.h>

#include "stand.h"
#include "libsa.h"

int loadrandom(const char *, char *, size_t);

int debug;
int errno;
extern const char *version;
extern char rnddata[BOOTRANDOM_MAX];
char	line[80];

int
main()
{
	char *cp, *file;
	int	flag, ret;
	int	ask = 0;
	int	rnd_loaded = 0;

	printf(">> OpenBSD/mvme88k bootsd [%s]\n", version);

	ret = parse_args(&file, &flag);

	for (;;) {
		if (ask) {
			printf("boot: ");
			gets(line);
			if (line[0]) {
				bugargs.arg_start = line;
				cp = line;
				while (cp < (line + sizeof(line) -1) && *cp)
					cp++;
				bugargs.arg_end = cp;
				ret = parse_args(&file, &flag);
			}
		}
		if (ret) {
			printf("boot: -q returning to MVME-Bug\n");
			break;
		}

		if (rnd_loaded == 0)
			rnd_loaded = loadrandom(BOOTRANDOM, rnddata,
			    sizeof(rnddata));

		exec_mvme(file, flag);
		printf("boot: %s: %s\n", file, strerror(errno));
		ask = 1;
	}
	return (0);
}

int
loadrandom(const char *name, char *buf, size_t buflen)
{
	struct stat sb;
	int fd;
	int rc = 0;

	fd = open(name, O_RDONLY);
	if (fd == -1) {
		if (errno != EPERM)
			printf("cannot open %s: %s\n", name, strerror(errno));
		return 0;
	}
	if (fstat(fd, &sb) == -1 || sb.st_uid != 0 || !S_ISREG(sb.st_mode) ||
	    (sb.st_mode & (S_IWOTH|S_IROTH)))
		goto fail;
	(void) read(fd, buf, buflen);
	rc = 1;
fail:
	close(fd);
	return rc;
}
@


1.10
log
@Support for /etc/random.seed in bootsd (disk-only boot blocks)
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.12 2012/12/31 21:35:32 miod Exp $ */
@


1.9
log
@Switch m88k ports to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.8 2006/05/16 22:52:09 miod Exp $ */
d37 4
d47 2
d52 2
a53 1
char    line[80];
d59 3
a61 2
	int flag, ret;
	int ask = 0;
d66 1
d84 5
d94 23
@


1.8
log
@Make standalone binaries compile with -Wall -Werror
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.7 2003/06/02 23:27:52 millert Exp $ */
d45 1
a45 1
extern char *version;
@


1.7
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.6 2001/06/29 21:53:28 miod Exp $ */
d52 2
a53 2
	int     io, flag, ret;
	int     ask = 0;
d55 1
a55 1
	printf("\n>> OpenBSD/mvme88k bootsd [%s]\n", version);
@


1.6
log
@Some cleaning. Remove unused boot options, don't declare extra RB_FOO
symbols with fancy values. Get rid of some debug code, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.5 2001/01/13 05:19:00 smurph Exp $ */
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.5
log
@Booting kernel with MACHINE_NEW_NONCONTIG.  UVM code added but not working.
New stand config.  Lots of header fixes.  Can now cross-compile i386->m88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.4 1999/09/27 19:29:59 smurph Exp $ */
a46 5
#define RB_NOSYM 0x400
#define RB_MULTI 0x4000
#define RB_EXTRA 0x8000
#define RB_ASKKERN 0x0010  /* ask kernel name  */

a61 3
	if (flag & RB_ASKKERN) {
		ask = 1;
	}
@


1.4
log
@changed loader load address.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.3 1998/12/15 06:32:33 smurph Exp $ */
d55 1
a55 1
char	line[80];
d61 2
a62 2
	int	io, flag, ret;
	int	ask = 0;
d67 3
a69 3
   if (flag & RB_ASKKERN) {
      ask = 1;
   }
d91 1
a91 1
	return(0);
@


1.4.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.5 2001/01/13 05:19:00 smurph Exp $ */
d55 1
a55 1
char    line[80];
d61 2
a62 2
	int     io, flag, ret;
	int     ask = 0;
d67 3
a69 3
	if (flag & RB_ASKKERN) {
		ask = 1;
	}
d91 1
a91 1
	return (0);
@


1.4.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.4.4.1 2001/04/18 16:11:45 niklas Exp $ */
d47 5
d67 3
@


1.4.4.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.4.4.2 2001/07/04 10:20:26 niklas Exp $ */
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.3
log
@This fixed a number of things.  A serious bug in bugcrt.c's initial stack
among other things.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.2 1998/08/22 07:17:18 smurph Exp $ */
d47 5
d64 1
a64 1
	printf("\n>> OpenBSD MVME%x bootsd [%s]\n", bugargs.cputyp, version);
d67 3
a69 1

@


1.2
log
@Changed bootsd to work with bootxx bootblocks.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.10 1997/04/22 16:01:19 gvf Exp $ */
d59 1
a59 1
	printf(">> OpenBSD MVME%x bootsd [%s]\n", bugargs.cputyp, version);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$Id: boot.c,v 1.5 1995/12/06 10:54:55 deraadt Exp $ */
a4 29
 * Copyright (c) 1995 Theo de Raadt
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Theo de Raadt for Willowglen Singapore.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
d36 1
a36 1
 * from: @@(#)boot.c	8.1 (Berkeley) 6/10/93
a39 1
#include <sys/types.h>
d41 1
a41 1
#include <a.out.h>
d43 1
d45 1
a45 3

void copyunix __P((int io, char *addr));
void parse_args __P((void));
d48 3
a50 27
int netif_debug;
#define RB_NOSYM 0x400

/*
 * Boot device is derived from ROM provided information.
 */
extern char	*version;
u_long		esym;
char		*strtab;
int		strtablen;
#if 0
struct nlist  *nlp, *enlp;
#endif

struct kernel {
	void	*entry;
	void	*symtab;
	void	*esym;
	int	bflags;
	int	bdev;
	char	*kname;
	void	*smini;
	void	*emini;
	u_int	end_loaded;
} kernel;

extern struct mvmeprom_args bugargs;
d55 20
a74 88
	struct exec x;
	char *file;
	void *addr;
	int io, i;

	printf(">> OpenBSD sdboot [%s]\n", version);

	parse_args();
	file = kernel.kname;

	io = open(file, 0);
	if (io < 0) {
		printf("Can't open %s: %s\n", file, strerror(errno));
		mvmeprom_return();
	}
	i = read(io, (char *)&x, sizeof(x));
	if (i != sizeof(x) || N_BADMAG(x)) {
		printf("Bad format\n");
		return (0);
	}
	/* Make load address start of page which containes "start" */
	addr = (void *)(x.a_entry & ~0x0FFF);
	lseek(io, 0, SEEK_SET);

	printf("load %s to 0x%x\n", file, addr);
	copyunix(io, addr);
	return (0);
}

/*ARGSUSED*/
void
copyunix(io, addr)
	int io;
	char *addr;
{
	void (*entry)() = (void (*)())addr;
	struct exec x;
	int i, cnt;

	i = read(io, (char *)&x, sizeof(x));
	if (i != sizeof(x) || N_BADMAG(x)) {
		printf("Bad format\n");
		return;
	}

	printf("%x", x.a_text);
	if (N_GETMAGIC(x) == ZMAGIC) {
		kernel.entry = entry = (void *)x.a_entry;
		lseek(io, 0, SEEK_SET);
	}
	if (read(io, (char *)addr, x.a_text) != x.a_text)
		goto shread;
	addr += x.a_text;
	if (N_GETMAGIC(x) == NMAGIC)
		while ((int)addr & CLOFSET)
			*addr++ = 0;
	printf("+%x", x.a_data);
	if (read(io, addr, x.a_data) != x.a_data)
		goto shread;
	addr += x.a_data;
	printf("+%x", x.a_bss);
	for (i = 0; i < x.a_bss; i++)
		*addr++ = 0;
	if (x.a_syms != 0 && !(kernel.bflags & RB_NOSYM)) {
		bcopy(&x.a_syms, addr, sizeof(x.a_syms));
		addr += sizeof(x.a_syms);
#if 0
		nlp = (struct nlist *)addr;
#endif
		printf("+[%x+", x.a_syms);
		if (read(io, addr, x.a_syms) != x.a_syms)
			goto shread;
		addr += x.a_syms;
#if 0
		enlp = (struct nlist *)(strtab = addr);
#endif

		if (read(io, &strtablen, sizeof(int)) != sizeof(int))
			goto shread;

		bcopy(&strtablen, addr, sizeof(int));
		if (i = strtablen) {
			i -= sizeof(int);
			addr += sizeof(int);
			cnt = read(io, addr, i);
			if (cnt != i)
				printf("symwarn"); /* goto shread; */
			addr += i;
d76 2
a77 17
		printf("%x]", i);
		esym = KERNBASE +
			(((int)addr + sizeof(int) - 1) & ~(sizeof(int) - 1));
		kernel.symtab = (void *) x.a_syms;
		kernel.esym = addr;
	} else {
		kernel.symtab = 0;
		kernel.esym = 0;
	}

#if 0
	while (nlp < enlp) {
		register int strx = nlp->n_un.n_strx;
		if (strx > strtablen)
			continue;
		if (strcmp(strtab+strx, "_esym") == 0) {
			*(int*)(nlp->n_value - KERNBASE) = esym;
d80 3
a82 82
		nlp++;
	}
#endif

	kernel.bdev = 0;
	kernel.end_loaded = (u_int)addr;
	kernel.smini = 0;
	kernel.emini = 0;
	kernel.kname = 0;

	printf("=%x\n", (u_int)addr - (u_int)entry);	/* XXX wrong? */

#if 0
printf("entry %x\n",kernel.entry);
printf("symtab %x\n",kernel.symtab);
printf("esym %x\n",kernel.esym);
printf("bflags %x\n",kernel.bflags);
printf("bdev %x\n",kernel.bdev);
printf("kname %x\n",kernel.kname);
printf("smini %x\n",kernel.smini);
printf("emini %x\n",kernel.emini);
printf("end_loaded %x\n",kernel.end_loaded);
#endif

	printf("start at 0x%x\n", (int)entry);
	if (((u_long)entry &0xf) == 0x2) {
		(entry)(&bugargs, &kernel);
	} else {
		/* is type fixing anything like price fixing? */
		typedef (* kernel_start) __P((int, int, void *,void *, void *));
		kernel_start addr; 
		addr = (void *)entry;
		(addr)(kernel.bflags, 0, kernel.esym, kernel.smini, kernel.emini);
	}
	return;

shread:
	printf("short read\n");
}

struct flags {
	char c;
	short bit;
} bf[] = {
	{ 'a', RB_ASKNAME },
	{ 'b', RB_HALT },
	{ 'y', RB_NOSYM },
	{ 'd', RB_KDB },
	{ 'm', RB_MINIROOT },
	{ 'r', RB_DFLTROOT },
	{ 's', RB_SINGLE },
};

void
parse_args()
{
	char *name = "/netbsd", *ptr;
	int i, howto = 0;
	char c;

	if (bugargs.arg_start != bugargs.arg_end) {
		ptr = bugargs.arg_start;
		while (c = *ptr) {
			while (c == ' ')
				c = *++ptr;
			if (c == '\0')
				return;
			if (c != '-') {
				name = ptr;
				while ((c = *++ptr) && c != ' ')
					;
				if (c)
					*ptr++ = 0;
				continue;
			}
			while ((c = *++ptr) && c != ' ') {
				for (i = 0; i < sizeof(bf)/sizeof(bf[0]); i++)
					if (bf[i].c == c) {
						howto |= bf[i].bit;
					}
			}
		}
d84 1
a84 2
	kernel.bflags = howto;
	kernel.kname = name;
@


1.1.1.1
log
@Third try at importing the mvme88k port. This is a working kernel
from nivas.
Userland and compiler still need to be worked on.
Make certain what directory the import is done from.
@
text
@@
