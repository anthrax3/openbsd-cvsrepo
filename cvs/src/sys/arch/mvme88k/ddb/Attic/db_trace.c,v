head	1.28;
access;
symbols
	SMP_SYNC_A:1.27
	SMP_SYNC_B:1.27
	OPENBSD_3_5:1.27.0.2
	OPENBSD_3_5_BASE:1.27
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	UBC_SYNC_A:1.17
	OPENBSD_3_3:1.17.0.2
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.16
	UBC:1.11.0.2
	UBC_BASE:1.11
	OPENBSD_3_0:1.8.0.4
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.5.0.10
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.8
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.6
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.4
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	mvme88kport:1.1.1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	first_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.28
date	2004.06.19.18.28.37;	author miod;	state dead;
branches;
next	1.27;

1.27
date	2004.01.29.21.39.05;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2004.01.13.18.40.47;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2004.01.12.21.33.10;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2004.01.12.07.46.14;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2004.01.07.17.52.30;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2004.01.07.16.22.17;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2003.12.21.13.23.32;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2003.12.19.22.30.17;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2003.10.05.20.23.52;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2003.08.06.21.08.06;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.12.09.00.45.37;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.18.09.49.17;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.16.13.01.41;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.03.15.57;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.26.38;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.22.08.31.04;	author smurph;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.16.23.49.46;	author miod;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2001.12.13.08.55.51;	author smurph;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.27.05.36.10;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.16.00.10.55;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.09.05.44.38;	author smurph;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.08.00.02.18;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	99.02.09.06.36.25;	author smurph;	state Exp;
branches
	1.5.6.1;
next	1.4;

1.4
date	97.03.21.02.10.44;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	97.03.03.20.20.36;	author rahnds;	state Exp;
branches;
next	1.2;

1.2
date	97.03.03.19.07.08;	author rahnds;	state dead;
branches;
next	1.1;

1.1
date	95.10.18.10.54.28;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.10.54.28;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.03.03.19.31.58;	author rahnds;	state Exp;
branches;
next	;

1.5.6.1
date	2001.04.18.16.10.51;	author niklas;	state Exp;
branches;
next	1.5.6.2;

1.5.6.2
date	2001.12.05.00.39.12;	author niklas;	state Exp;
branches;
next	1.5.6.3;

1.5.6.3
date	2002.03.06.01.08.05;	author niklas;	state Exp;
branches;
next	1.5.6.4;

1.5.6.4
date	2002.03.28.10.36.02;	author niklas;	state Exp;
branches;
next	1.5.6.5;

1.5.6.5
date	2003.03.27.23.32.17;	author niklas;	state Exp;
branches;
next	1.5.6.6;

1.5.6.6
date	2004.02.19.10.49.06;	author niklas;	state Exp;
branches;
next	;

1.11.2.1
date	2002.01.31.22.55.17;	author niklas;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2002.06.11.03.37.09;	author art;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2003.05.19.21.45.52;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Share common ddb files accross m88k platforms.
@
text
@/*	$OpenBSD: db_trace.c,v 1.27 2004/01/29 21:39:05 deraadt Exp $	*/
/*
 * Mach Operating System
 * Copyright (c) 1993-1991 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON AND OMRON ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON AND OMRON DISCLAIM ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/systm.h>

#include <machine/db_machdep.h>
#include <machine/locore.h>

#include <ddb/db_variables.h>	/* db_variable, DB_VAR_GET, etc.  */
#include <ddb/db_output.h>	/* db_printf                      */
#include <ddb/db_sym.h>		/* DB_STGY_PROC, etc.             */
#include <ddb/db_command.h>	/* db_recover                     */
#include <ddb/db_access.h>
#include <ddb/db_interface.h>

union instruction {
	unsigned rawbits;

	struct {
		unsigned int    : 5;
		unsigned int   n: 1;
		signed int   d26:26;
	} br;

	struct {
		unsigned int      : 4;
		unsigned int isbb1: 1;	/* isbb1==0 means bb0, isbb1==1 means bb1 */
		unsigned int   n  : 1;
		unsigned int  b5  : 5;
		unsigned int  s1  : 5;
		signed   int  d16 :16;
	} bb; /* bcnd too, except "isbb1" makes no sense for bcnd */

	struct {
		unsigned int      : 6;
		unsigned int  b5  : 5;
		unsigned int  s1  : 5;
		unsigned int      : 7;
		unsigned int vec9 : 9;
	} tb; /* tcnd too */

	struct {
		unsigned int      :21;
		unsigned int    n : 1;
		unsigned int      : 5;
		unsigned int   s2 : 5;
	} jump;	/* jmp, jsr */

	struct {
		unsigned int      : 6;
		unsigned int    d : 5;
		unsigned int   s1 : 5;
		unsigned int  i16 :16;
	} diatic;   /* general reg/reg/i16 instructions */

	struct {
		unsigned int      : 6;
		unsigned int    d : 5;
		unsigned int   s1 : 5;
		unsigned int      :11;
		unsigned int   s2 : 5;
	} triatic;  /* general reg/reg/reg instructions */

};

static inline unsigned br_dest(unsigned addr, union instruction inst)
{
	return addr + inst.br.d26 * 4;
}


#define TRACE_DEBUG	/* undefine to disable debugging */

int frame_is_sane(db_regs_t *regs, int);
char *m88k_exception_name(unsigned vector);
unsigned db_trace_get_val(vaddr_t addr, unsigned *ptr);

/*
 * Some macros to tell if the given text is the instruction.
 */
#define JMPN_R1(I)	    ( (I) == 0xf400c401U)	/* jmp.n   r1 */
#define JMP_R1(I)	    ( (I) == 0xf400c001U)	/* jmp     r1 */

/* gets the IMM16 value from an instruction */
#define IMM16VAL(I)	    (((union instruction)(I)).diatic.i16)

/* subu r31, r31, IMM */
#define SUBU_R31_R31_IMM(I) (((I) & 0xffff0000U) == 0x67ff0000U)

/* st r1, r31, IMM */
#define ST_R1_R31_IMM(I)    (((I) & 0xffff0000U) == 0x243f0000U)

static int trace_flags;
#define TRACE_DEBUG_FLAG		0x01
#define TRACE_SHOWCALLPRESERVED_FLAG	0x02
#define TRACE_SHOWADDRESS_FLAG		0x04
#define TRACE_SHOWFRAME_FLAG		0x08
#define TRACE_USER_FLAG			0x10

#ifdef TRACE_DEBUG
  #define DEBUGGING_ON (trace_flags & TRACE_DEBUG_FLAG)
#endif

#ifndef TRACE_DEBUG
  #define SHOW_INSTRUCTION(Addr, Inst, Note) 	{ /*nothing*/ }
#else
  #define SHOW_INSTRUCTION(Addr, Inst, Note) if (DEBUGGING_ON) { 	\
    db_printf("%s0x%x: (0x%08x) ", Note, (unsigned)(Addr), (Inst));	\
    m88k_print_instruction((unsigned)(Addr), (Inst));			\
    db_printf("\n");					\
  }
#endif

extern label_t *db_recover;

/*
 * m88k trace/register state interface for ddb.
 */

/* lifted from mips */
static int
db_setf_regs(struct db_variable      *vp,
	db_expr_t		*valuep,
	int			op)		/* read/write */
{
	int   *regp = (int *) ((char *) DDB_REGS + (int) (vp->valuep));

	if (op == DB_VAR_GET)
		*valuep = *regp;
	else if (op == DB_VAR_SET)
		*regp = *valuep;

	return (0); /* silence warning */
}

#define N(s, x)  {s, (long *)&(((db_regs_t *) 0)->x), db_setf_regs}

struct db_variable db_regs[] = {
	N("r1", r[1]),     N("r2", r[2]),    N("r3", r[3]),    N("r4", r[4]),
	N("r5", r[5]),     N("r6", r[6]),    N("r7", r[7]),    N("r8", r[8]),
	N("r9", r[9]),     N("r10", r[10]),  N("r11", r[11]),  N("r12", r[12]),
	N("r13", r[13]),   N("r14", r[14]),  N("r15", r[15]),  N("r16", r[16]),
	N("r17", r[17]),   N("r18", r[18]),  N("r19", r[19]),  N("r20", r[20]),
	N("r21", r[21]),   N("r22", r[22]),  N("r23", r[23]),  N("r24", r[24]),
	N("r25", r[25]),   N("r26", r[26]),  N("r27", r[27]),  N("r28", r[28]),
	N("r29", r[29]),   N("r30", r[30]),  N("r31", r[31]),  N("epsr", epsr),
	N("sxip", sxip),   N("snip", snip),  N("sfip", sfip),  N("ssbr", ssbr),
	N("dmt0", dmt0),   N("dmd0", dmd0),  N("dma0", dma0),  N("dmt1", dmt1),
	N("dmd1", dmd1),   N("dma1", dma1),  N("dmt2", dmt2),  N("dmd2", dmd2),
	N("dma2", dma2),   N("fpecr", fpecr),N("fphs1", fphs1),N("fpls1", fpls1),
	N("fphs2", fphs2), N("fpls2", fpls2),N("fppt", fppt),  N("fprh", fprh),
	N("fprl", fprl),   N("fpit", fpit),  N("fpsr", fpsr),  N("fpcr", fpcr),
};
#undef N

struct db_variable *db_eregs = db_regs + sizeof(db_regs)/sizeof(db_regs[0]);


#define TRASHES    0x001	/* clobbers instruction field D */
#define STORE      0x002	/* does a store to S1+IMM16 */
#define LOAD       0x004	/* does a load from S1+IMM16 */
#define DOUBLE     0x008	/* double-register */
#define FLOW_CTRL  0x010	/* flow-control instruction */
#define DELAYED    0x020	/* delayed flow control */
#define JSR	   0x040	/* flow-control is a jsr[.n] */
#define BSR	   0x080	/* flow-control is a bsr[.n] */

/*
 * Given a word of instruction text, return some flags about that
 * instruction (flags defined above).
 */
static unsigned
m88k_instruction_info(unsigned instruction)
{
	static const struct {
		unsigned mask, value, flags;
	} *ptr, control[] = {
		/* runs in the same order as 2nd Ed 88100 manual Table 3-14 */
		{ 0xf0000000U, 0x00000000U, /* xmem */     TRASHES | STORE | LOAD},
		{ 0xec000000U, 0x00000000U, /* ld.d */     TRASHES | LOAD | DOUBLE},
		{ 0xe0000000U, 0x00000000U, /* load */     TRASHES | LOAD},
		{ 0xfc000000U, 0x20000000U, /* st.d */     STORE | DOUBLE},
		{ 0xf0000000U, 0x20000000U, /* store */    STORE},
		{ 0xc0000000U, 0x40000000U, /* arith */    TRASHES},
		{ 0xfc004000U, 0x80004000U, /* ld cr */    TRASHES},
		{ 0xfc004000U, 0x80000000U, /* st cr */    0},
		{ 0xfc008060U, 0x84000000U, /* f */        TRASHES},
		{ 0xfc008060U, 0x84000020U, /* f.d */      TRASHES | DOUBLE},
		{ 0xfc000000U, 0xcc000000U, /* bsr.n */    FLOW_CTRL | DELAYED | BSR},
		{ 0xfc000000U, 0xc8000000U, /* bsr */      FLOW_CTRL | BSR},
		{ 0xe4000000U, 0xc4000000U, /* br/bb.n */  FLOW_CTRL | DELAYED},
		{ 0xe4000000U, 0xc0000000U, /* br/bb */    FLOW_CTRL},
		{ 0xfc000000U, 0xec000000U, /* bcnd.n */   FLOW_CTRL | DELAYED},
		{ 0xfc000000U, 0xe8000000U, /* bcnd */     FLOW_CTRL},
		{ 0xfc00c000U, 0xf0008000U, /* bits */     TRASHES},
		{ 0xfc00c000U, 0xf000c000U, /* trap */     0},
		{ 0xfc00f0e0U, 0xf4002000U, /* st */       0},
		{ 0xfc00cce0U, 0xf4000000U, /* ld.d */     TRASHES | DOUBLE},
		{ 0xfc00c0e0U, 0xf4000000U, /* ld */       TRASHES},
		{ 0xfc00c0e0U, 0xf4004000U, /* arith */    TRASHES},
		{ 0xfc00c3e0U, 0xf4008000U, /* bits */     TRASHES},
		{ 0xfc00ffe0U, 0xf400cc00U, /* jsr.n */    FLOW_CTRL | DELAYED | JSR},
		{ 0xfc00ffe0U, 0xf400c800U, /* jsr */      FLOW_CTRL | JSR},
		{ 0xfc00ffe0U, 0xf400c400U, /* jmp.n */    FLOW_CTRL | DELAYED},
		{ 0xfc00ffe0U, 0xf400c000U, /* jmp */      FLOW_CTRL},
		{ 0xfc00fbe0U, 0xf400e800U, /* ff */       TRASHES},
		{ 0xfc00ffe0U, 0xf400f800U, /* tbnd */     0},
		{ 0xfc00ffe0U, 0xf400fc00U, /* rte */      FLOW_CTRL},
		{ 0xfc000000U, 0xf8000000U, /* tbnd */     0},
	};
#define ctrl_count (sizeof(control)/sizeof(control[0]))
	for (ptr = &control[0]; ptr < &control[ctrl_count]; ptr++)
		if ((instruction & ptr->mask) == ptr->value)
			return ptr->flags;
	SHOW_INSTRUCTION(0, instruction, "bad m88k_instruction_info");
	return 0;
}

static int
hex_value_needs_0x(unsigned value)
{
	int i;
	unsigned last = 0;
	unsigned char c;
	unsigned have_a_hex_digit = 0;

	if (value <= 9)
		return 0;

	for (i = 0; i < 8; i++) {
		c = value & 0xf;
		value >>= 4;
		if (c)
			last = c;
		if (c > 9)
			have_a_hex_digit = 1;
	}
	if (have_a_hex_digit == 0)
		return 1;
	if (last > 9)
		return 1;
	return 0;
}

/*
 * returns
 *   1 if regs seems to be a reasonable kernel exception frame.
 *   2 if regs seems to be a reasonable user exception frame
 * 	(in the current task).
 *   0 if this looks like neither.
 */
int
frame_is_sane(db_regs_t *regs, int quiet)
{
	/* no good if we can't read the whole frame */
	if (badwordaddr((vaddr_t)regs) || badwordaddr((vaddr_t)&regs->fpit)) {
		if (quiet == 0)
			db_printf("[WARNING: frame at %p : unreadable]\n", regs);
		return 0;
	}

	/* r0 must be 0 (obviously) */
	if (regs->r[0] != 0) {
		if (quiet == 0)
			db_printf("[WARNING: frame at %p : r[0] != 0]\n", regs);
		return 0;
	}

	/* stack sanity ... r31 must be nonzero, and must be word aligned */
	if (regs->r[31] == 0 || (regs->r[31] & 3) != 0) {
		if (quiet == 0)
			db_printf("[WARNING: frame at %p : r[31] == 0 or not word aligned]\n", regs);
		return 0;
	}

	if (cputyp != CPU_88110) {
		/* sxip is reasonable */
#if 0
		if ((regs->sxip & 1) == 1)
			return 0;
#endif
		/* snip is reasonable */
		if ((regs->snip & 3) != 2)
			return 0;
		/* sfip is reasonable */
		if ((regs->sfip & 3) != 2)
			return 0;
	}

	/* epsr sanity */
	if ((regs->epsr & PSR_MODE)) { /* kernel mode */
		if (regs->epsr & PSR_BO)
			return 0;
		return 1;
	}
	if (!(regs->epsr & PSR_MODE)) {	/* user mode */
		if (regs->epsr & PSR_BO)
			return 0;
		return 2;
	}
	if (quiet == 0)
		db_printf("[WARNING: not an exception frame?]\n");
	return 0;
}

char *
m88k_exception_name(unsigned vector)
{
	switch (vector) {
	default:
	case   0: return "Reset";
	case   1: return "Interrupt";
	case   2: return "Instruction Access Exception";
	case   3: return "Data Access Exception";
	case   4: return "Misaligned Access Exception";
	case   5: return "Unimplemented Opcode Exception";
	case   6: return "Privilege Violation";
	case   7: return "Bounds Check";
	case   8: return "Integer Divide Exception";
	case   9: return "Integer Overflow Exception";
	case  10: return "Error Exception";
	case  11: return "Non Maskable Interrupt";
	case 114: return "FPU precise";
	case 115: return "FPU imprecise";
	case DDB_ENTRY_BKPT_NO:
		return "ddb break";
	case DDB_ENTRY_TRACE_NO:
		return "ddb trace";
	case DDB_ENTRY_TRAP_NO:
		return "ddb trap";
	case 451: return "Syscall";
	}
}

/*
 * Read a word at address addr.
 * Return 1 if was able to read, 0 otherwise.
 */
unsigned
db_trace_get_val(vaddr_t addr, unsigned *ptr)
{
	label_t db_jmpbuf;
	label_t *prev = db_recover;

	if (setjmp((db_recover = &db_jmpbuf)) != 0) {
		db_recover = prev;
		return 0;
	} else {
		db_read_bytes(addr, 4, (char *)ptr);
		db_recover = prev;
		return 1;
	}
}

#define FIRST_CALLPRESERVED_REG 14
#define LAST_CALLPRESERVED_REG  29
#define FIRST_ARG_REG       2
#define LAST_ARG_REG        9
#define RETURN_VAL_REG           1

static unsigned global_saved_list = 0x0; /* one bit per register */
static unsigned local_saved_list  = 0x0; /* one bit per register */
static unsigned trashed_list      = 0x0; /* one bit per register */
static unsigned saved_reg[32];		 /* one value per register */

#define reg_bit(reg) (1<<((reg)%32))

static void
save_reg(int reg, unsigned value)
{
#ifdef TRACE_DEBUG
	if (DEBUGGING_ON) db_printf("save_reg(%d, %x)\n", reg, value);
#endif
	if (trashed_list & reg_bit(reg)) {
#ifdef TRACE_DEBUG
		if (DEBUGGING_ON) db_printf("<trashed>\n");
#endif
		return;	/* don't save trashed registers */
	}
	saved_reg[(reg%32)] = value;
	global_saved_list |= reg_bit(reg);
	local_saved_list  |= reg_bit(reg);
}

#define mark_reg_trashed(reg)	(trashed_list |= reg_bit(reg))

#define have_global_reg(reg) (global_saved_list & (1<<(reg)))
#define have_local_reg(reg)  (local_saved_list & (1<<(reg)))

#define clear_local_saved_regs()  { local_saved_list = trashed_list =      0; }
#define clear_global_saved_regs() { local_saved_list = global_saved_list = 0; }

#define saved_reg_value(reg) (saved_reg[(reg)])

/*
 * Show any arguments that we might have been able to determine.
 */
static void
print_args(void)
{
	int reg, last_arg;

	/* find the highest argument register saved */
	for (last_arg = LAST_ARG_REG; last_arg >= FIRST_ARG_REG; last_arg--)
		if (have_local_reg(last_arg))
			break;
	if (last_arg < FIRST_ARG_REG)
		return;	/* none were saved */

	db_printf("(");

	/* print each one, up to the highest */
	for (reg = FIRST_ARG_REG; /*nothing */; reg++) {
		if (!have_local_reg(reg))
			db_printf("?");
		else {
			unsigned value = saved_reg_value(reg);
			db_printf("%s%x", hex_value_needs_0x(value) ?
				  "0x" : "", value);
		}
		if (reg == last_arg)
			break;
		else
			db_printf(", ");
	}
	db_printf(")");
}


#define JUMP_SOURCE_IS_BAD		0
#define JUMP_SOURCE_IS_OK		1
#define JUMP_SOURCE_IS_UNLIKELY		2

/*
 * Give an address to where we return, and an address to where we'd jumped,
 * Decided if it all makes sense.
 *
 * Gcc sometimes optimized something like
 *	if (condition)
 *		func1();
 *	else
 *		OtherStuff...
 * to
 *	bcnd   !condition  mark
 *	bsr.n  func1
 *	or     r1, r0, mark2
 *    mark:
 *	OtherStuff...
 *    mark2:
 *
 * So RETURN_TO will be MARK2, even though we really did branch via
 * 'bsr.n func1', so this makes it difficult to be certaian about being
 * wrong.
 */
static int
is_jump_source_ok(unsigned return_to, unsigned jump_to)
{
	unsigned flags;
	union instruction instruction;

	/*
	 * Delayed branches are most common... look two instructions before
	 * where we were going to return to to see if it's a delayed branch.
	 */
	if (!db_trace_get_val(return_to - 8, &instruction.rawbits))
		return JUMP_SOURCE_IS_BAD;
	flags = m88k_instruction_info(instruction.rawbits);

	if ((flags & FLOW_CTRL) && (flags & DELAYED) && (flags & (JSR|BSR))) {
		if (flags & JSR)
			return JUMP_SOURCE_IS_OK; /* have to assume it's correct */
		/* calculate the offset */
		if (br_dest(return_to - 8, instruction) == jump_to)
			return JUMP_SOURCE_IS_OK; /* exactamundo! */
		else
			return JUMP_SOURCE_IS_UNLIKELY;	/* seems wrong */
	}

	/*
	 * Try again, looking for a non-delayed jump one back.
	 */
	if (!db_trace_get_val(return_to - 4, &instruction.rawbits))
		return JUMP_SOURCE_IS_BAD;
	flags = m88k_instruction_info(instruction.rawbits);

	if ((flags & FLOW_CTRL) && !(flags & DELAYED) && (flags & (JSR|BSR))) {
		if (flags & JSR)
			return JUMP_SOURCE_IS_OK; /* have to assume it's correct */
		/* calculate the offset */
		if (br_dest(return_to - 4, instruction) == jump_to)
			return JUMP_SOURCE_IS_OK; /* exactamundo! */
		else
			return JUMP_SOURCE_IS_UNLIKELY;	/* seems wrong */
	}

	return JUMP_SOURCE_IS_UNLIKELY;
}

static char *note = 0;
static int next_address_likely_wrong = 0;

/* How much slop we expect in the stack trace */
#define FRAME_PLAY 8

/*
 *  Stack decode -
 *	unsigned addr;    program counter
 *	unsigned *stack; IN/OUT stack pointer
 *
 * 	given an address within a function and a stack pointer,
 *	try to find the function from which this one was called
 *	and the stack pointer for that function.
 *
 *	The return value is zero (if we get confused) or
 *	we determine that the return address has not yet
 *	been saved (early in the function prologue). Otherwise
 *	the return value is the address from which this function
 *	was called.
 *
 *	Note that even is zero is returned (the second case) the
 *	stack pointer can be adjusted.
 *
 */
static int
stack_decode(db_addr_t addr, unsigned *stack, int (*pr)(const char *, ...))
{
	db_sym_t proc;
	db_expr_t offset_from_proc;
	unsigned instructions_to_search;
	db_addr_t check_addr;
	db_addr_t function_addr;    /* start of function */
	unsigned r31 = *stack;	    /* the r31 of the function */
	unsigned inst;		    /* text of an instruction */
	unsigned ret_addr;	    /* address to which we return */
	unsigned tried_to_save_r1 = 0;

#ifdef TRACE_DEBUG
	if (DEBUGGING_ON)
		(*pr)("\n>>>stack_decode(addr=%x, stack=%x)\n",
			  addr, *stack);
#endif

	/* get what we hope will be the db_sym_t for the function name */
	proc = db_search_symbol(addr, DB_STGY_PROC, &offset_from_proc);
	if (offset_from_proc == addr) /* i.e. no symbol found */
		proc = DB_SYM_NULL;

	/*
	 * Somehow, find the start of this function.
	 * If we found a symbol above, it'll have the address.
	 * Otherwise, we've got to search for it....
	 */
	if (proc != DB_SYM_NULL) {
		char *names;
		db_symbol_values(proc, &names, &function_addr);
		if (names == 0)
			return 0;
#ifdef TRACE_DEBUG
		if (DEBUGGING_ON) (*pr)("name %s address 0x%x\n",
					    names, function_addr);
#endif
	} else {
		int instructions_to_check = 400;
		/*
		 * hmm - unable to find symbol. Search back
		 * looking for a function prolog.
		 */
		for (check_addr = addr; instructions_to_check-- > 0; check_addr -= 4) {
			if (!db_trace_get_val(check_addr, &inst))
				break;

			if (SUBU_R31_R31_IMM(inst)) {
#if 0
				/*
				 * If the next instruction is "st r1, r31, ####"
				 * then we can feel safe we have the start of
				 * a function.
				 */
				if (!db_trace_get_val(check_addr + 4, &inst))
					continue;
				if (ST_R1_R31_IMM(instr))
					break; /* success */
#else
				/*
				 * Latest GCC optimizer is just too good... the store
				 * of r1 might come much later... so we'll have to
				 * settle for just the "subr r31, r31, ###" to mark
				 * the start....
				 */
				break;
#endif
			}
			/*
			 * if we come across a [jmp r1] or [jmp.n r1] assume we have hit
			 * the previous functions epilogue and stop our search.
			 * Since we know we would have hit the "subr r31, r31" if it was
			 * right in front of us, we know this doesn't have one so
			 * we just return failure....
			 */
			if (JMP_R1(inst) || JMPN_R1(inst)) {
#ifdef TRACE_DEBUG
				if (DEBUGGING_ON)
					(*pr)("ran into a [jmp r1] at %x (addr=%x)\n",
						  check_addr, addr);
#endif
				return 0;
			}
		}
		if (instructions_to_check < 0) {
#ifdef TRACE_DEBUG
			if (DEBUGGING_ON)
				(*pr)("couldn't find func start (addr=%x)\n", addr);
#endif
			return 0; /* bummer, couldn't find it */
		}
		function_addr = check_addr;
	}

	/*
	 * We now know the start of the function (function_addr).
	 * If we're stopped right there, or if it's not a
	 *		subu r31, r31, ####
	 * then we're done.
	 */
	if (addr == function_addr) {
#ifdef TRACE_DEBUG
		if (DEBUGGING_ON) (*pr)("at start of func\n");
#endif
		return 0;
	}
	if (!db_trace_get_val(function_addr, &inst)) {
#ifdef TRACE_DEBUG
		if (DEBUGGING_ON) (*pr)("couldn't read %x at line %d\n",
					    function_addr, __LINE__);
#endif
		return 0;
	}
	SHOW_INSTRUCTION(function_addr, inst, "start of function: ");
	if (!SUBU_R31_R31_IMM(inst)) {
#ifdef TRACE_DEBUG
		if (DEBUGGING_ON) (*pr)("<not subu,r31,r31,imm>\n");
#endif
		return 0;
	}

	/* add the size of this frame to the stack (for the next frame) */
	*stack += IMM16VAL(inst);

	/*
	 * Search from the beginning of the function (funstart) to where we are
	 * in the function (addr) looking to see what kind of registers have
	 * been saved on the stack.
	 *
	 * We'll stop looking before we get to ADDR if we hit a branch.
	 */
	clear_local_saved_regs();
	check_addr = function_addr + 4;	/* we know the first inst isn't a store */

	for (instructions_to_search = (addr - check_addr)/sizeof(long);
	    instructions_to_search-- > 0;
	    check_addr += 4) {
		union instruction instruction;
		unsigned flags;

		/* read the instruction */
		if (!db_trace_get_val(check_addr, &instruction.rawbits)) {
#ifdef TRACE_DEBUG
			if (DEBUGGING_ON) (*pr)("couldn't read %x at line %d\n",
						    check_addr, __LINE__);
#endif
			break;
		}

		SHOW_INSTRUCTION(check_addr, instruction.rawbits, "prolog: ");

		/* find out the particulars about this instruction */
		flags = m88k_instruction_info(instruction.rawbits);

		/* if a store to something off the stack pointer, note the value */
		if ((flags & STORE) && instruction.diatic.s1 ==	/*stack pointer*/31) {
			unsigned value;
			if (!have_local_reg(instruction.diatic.d)) {
				if (instruction.diatic.d == 1)
					tried_to_save_r1 = r31 + instruction.diatic.i16 ;
				if (db_trace_get_val(r31 + instruction.diatic.i16, &value))
					save_reg(instruction.diatic.d, value);
			}
			if ((flags & DOUBLE) && !have_local_reg(instruction.diatic.d + 1)) {
				if (instruction.diatic.d == 0)
					tried_to_save_r1 = r31+instruction.diatic.i16 +4;
				if (db_trace_get_val(r31+instruction.diatic.i16 +4, &value))
					save_reg(instruction.diatic.d + 1, value);
			}
		}

		/* if an inst that kills D (and maybe D+1), note that */
		if (flags & TRASHES) {
			mark_reg_trashed(instruction.diatic.d);
			if (flags & DOUBLE)
				mark_reg_trashed(instruction.diatic.d + 1);
		}

		/* if a flow control instruction, stop now (or next if delayed) */
		if ((flags & FLOW_CTRL) && instructions_to_search != 0)
			instructions_to_search = (flags & DELAYED) ? 1 : 0;
	}

	/*
	 * If we didn't save r1 at some point, we're hosed.
	 */
	if (!have_local_reg(1)) {
		if (tried_to_save_r1) {
			(*pr)("    <return value of next fcn unreadable in %08x>\n",
				  tried_to_save_r1);
		}
#ifdef TRACE_DEBUG
		if (DEBUGGING_ON) (*pr)("didn't save r1\n");
#endif
		return 0;
	}

	ret_addr = saved_reg_value(1);

#ifdef TRACE_DEBUG
	if (DEBUGGING_ON)
		(*pr)("Return value is = %x, function_addr is %x.\n",
			  ret_addr, function_addr);
#endif

	/*
	 * In support of this, continuation.s puts the low bit on the
	 * return address for continuations (the return address will never
	 * be used, so it's ok to do anything you want to it).
	 */
	if (ret_addr & 1) {
		note = "<<can not trace past a continuation>>";
		ret_addr = 0;
	} else if (ret_addr != 0x00) {
		switch (is_jump_source_ok(ret_addr, function_addr)) {
		case JUMP_SOURCE_IS_OK:
			break; /* excellent */

		case JUMP_SOURCE_IS_BAD:
#ifdef TRACE_DEBUG
			if (DEBUGGING_ON) (*pr)("jump is bad\n");
#endif
			return 0; /* bummer */

		case JUMP_SOURCE_IS_UNLIKELY:
			next_address_likely_wrong = 1;
			break;
		}
	}

	return ret_addr;
}

static void
db_stack_trace_cmd2(db_regs_t *regs, int (*pr)(const char *, ...))
{
	unsigned stack;
	unsigned depth=1;
	unsigned where;
	unsigned ft;
	unsigned pair[2];
	int i;

	/*
	 * Frame_is_sane returns:
	 *   1 if regs seems to be a reasonable kernel exception frame.
	 *   2 if regs seems to be a reasonable user exception frame
	 *      (in the current task).
	 *   0 if this looks like neither.
	 */
	if ((ft = frame_is_sane(regs, 1)) == 0) {
		(*pr)("Register frame 0x%x is suspicious; skipping trace\n", regs);
		return;
	}

	/* if user space and no user space trace specified, puke */
	if (ft == 2 && !(trace_flags & TRACE_USER_FLAG))
		return;

	/* fetch address */
	/* use sxip if valid, otherwise try snip or sfip */
	if (cputyp == CPU_88110) {
		where = regs->exip & ~3;
	} else {
		where = ((regs->sxip & 2) ? regs->sxip :
			 ((regs->snip & 2) ? regs->snip :
			  regs->sfip) ) & ~3;
	}
	stack = regs->r[31];
	(*pr)("stack base = 0x%x\n", stack);
	(*pr)("(0) "); /*depth of trace */
	if (trace_flags & TRACE_SHOWADDRESS_FLAG)
		(*pr)("%08x ", where);
	db_printsym(where, DB_STGY_PROC, pr);
	clear_global_saved_regs();

	/* see if this routine had a stack frame */
	if ((where=stack_decode(where, &stack, pr))==0) {
		where = regs->r[1];
		(*pr)("(stackless)");
	} else {
		print_args();
		if (trace_flags & TRACE_SHOWFRAME_FLAG)
			(*pr)(" [frame 0x%x]", stack);
	}
	(*pr)("\n");
	if (note) {
		(*pr)("   %s\n", note);
		note = 0;
	}

	do {
		/*
		 * If requested, show preserved registers at the time
		 * the next-shown call was made. Only registers known to have
		 * changed from the last exception frame are shown, as others
		 * can be gotten at by looking at the exception frame.
		 */
		if (trace_flags & TRACE_SHOWCALLPRESERVED_FLAG) {
			int r, title_printed = 0;

			for (r = FIRST_CALLPRESERVED_REG; r<=LAST_CALLPRESERVED_REG; r++) {
				if (have_global_reg(r)) {
					unsigned value = saved_reg_value(r);
					if (title_printed == 0) {
						title_printed = 1;
						(*pr)("[in next func:");
					}
					if (value == 0)
						(*pr)(" r%d", r);
					else if (value <= 9)
						(*pr)(" r%d=%x", r, value);
					else
						(*pr)(" r%d=x%x", r, value);
				}
			}
			if (title_printed)
				(*pr)("]\n");
		}

		(*pr)("(%d)%c", depth++, next_address_likely_wrong ? '?':' ');
		next_address_likely_wrong = 0;

		if (trace_flags & TRACE_SHOWADDRESS_FLAG)
			(*pr)("%08x ", where);
		db_printsym(where, DB_STGY_PROC, pr);
		where = stack_decode(where, &stack, pr);
		print_args();
		if (trace_flags & TRACE_SHOWFRAME_FLAG)
			(*pr)(" [frame 0x%x]", stack);
		(*pr)("\n");
		if (note) {
			(*pr)("   %s\n", note);
			note = 0;
		}
	} while (where);

	/* try to trace back over trap/exception */

	stack &= ~7; /* double word aligned */
	/* take last top of stack, and try to find an exception frame near it */

	i = FRAME_PLAY;

#ifdef TRACE_DEBUG
	if (DEBUGGING_ON)
		(*pr)("(searching for exception frame at 0x%x)\n", stack);
#endif

	while (i) {
		/*
		 * On the stack, a pointer to the exception frame is written
		 * in two adjacent words. In the case of a fault from the kernel,
		 * this should point to the frame right above them:
		 *
		 * Exception Frame Top
		 * ..
		 * Exception Frame Bottom  <-- frame addr
		 * frame addr
		 * frame addr		<-- stack pointer
		 *
		 * In the case of a fault from user mode, the top of stack
		 * will just have the address of the frame
		 * replicated twice.
		 *
		 * frame addr		<-- top of stack
		 * frame addr
		 *
		 * Here we are just looking for kernel exception frames.
		 */

		if (badwordaddr((vaddr_t)stack) ||
		    badwordaddr((vaddr_t)(stack+4)))
			break;

		db_read_bytes((vaddr_t)stack, 2*sizeof(int), (char *)pair);

		/* the pairs should match and equal stack+8 */
		if (pair[0] == pair[1]) {
			if (pair[0] != stack+8) {
				/*
				if (!badwordaddr((vaddr_t)pair[0]) && (pair[0]!=0))
				(*pr)("stack_trace:found pair 0x%x but != to stack+8\n",
				pair[0]);
				*/
			}

			else if (frame_is_sane((db_regs_t*)pair[0], 1) != 0) {
				struct trapframe *frame =
				    (struct trapframe *)pair[0];

				(*pr)("-------------- %s [EF: 0x%x] -------------\n",
				    m88k_exception_name(frame->tf_vector),
				    frame);
				db_stack_trace_cmd2(&frame->tf_regs, pr);
				return;
			}
#ifdef TRACE_DEBUG
			else if (DEBUGGING_ON)
				(*pr)("pair matched, but frame at 0x%x looks insane\n",
					  stack+8);
#endif
		}
		stack += 8;
		i--;
	}

	/*
	 * If we go here, crawling back on the stack failed to find us
	 * a previous exception frame. Look for a user frame pointer
	 * pointed to by a word 8 bytes off of the top of the stack
	 * if the "u" option was specified.
	 */
	if (trace_flags & TRACE_USER_FLAG) {
		struct trapframe *user;

		/* Make sure we are back on the right page */
		stack -= 4*FRAME_PLAY;
		stack = stack & ~(KERNEL_STACK_SIZE-1);	/* point to the bottom */
		stack += KERNEL_STACK_SIZE - 8;

		if (badwordaddr((vaddr_t)stack) ||
		    badwordaddr((vaddr_t)stack))
			return;

		db_read_bytes((vaddr_t)stack, 2*sizeof(int), (char *)pair);
		if (pair[0] != pair[1])
			return;

		/* have a hit */
		user = *((struct trapframe **)stack);

		if (frame_is_sane(&user->tf_regs, 1) == 2) {
			(*pr)("---------------- %s [EF : 0x%x] -------------\n",
			    m88k_exception_name(user->tf_vector), user);
			db_stack_trace_cmd2(&user->tf_regs, pr);
		}
	}
}

/*
 * stack trace - needs a pointer to a m88k saved state.
 *
 * If argument f is given, the stack pointer of each call frame is
 * printed.
 */
void
db_stack_trace_print(db_expr_t addr,
		   int have_addr,
		   db_expr_t count,
		   char *modif,
		   int (*pr)(const char *, ...))
{
	enum {
		Default, Stack, Frame
	} style = Default;
	db_regs_t frame;
	db_regs_t *regs;
	union {
		db_regs_t *frame;
		db_expr_t num;
	} arg;

	arg.num = addr;

	trace_flags = 0; /* flags will be set via modifers */

	while (modif && *modif) {
		switch (*modif++) {
		case 'd':
#ifdef TRACE_DEBUG
			trace_flags |= TRACE_DEBUG_FLAG;
#else
			db_printtf("<debug trace not compiled in, ignoring>\n");
#endif
			break;

		case 's': style = Stack  ; break;
		case 'f': style = Frame  ; break;
		case 'p': trace_flags |= TRACE_SHOWCALLPRESERVED_FLAG; break;
		case 'a': trace_flags |= TRACE_SHOWADDRESS_FLAG; break;
		case 'F': trace_flags |= TRACE_SHOWFRAME_FLAG; break;
		case 'u': trace_flags |= TRACE_USER_FLAG; break;
		default:
			(*pr)("unknown trace modifier [%c]\n", modif[-1]);
			/*FALLTHROUGH*/
		case 'h':
			(*pr)("usage: trace/[MODIFIER]  [ARG]\n");
			(*pr)("  u = include user trace\n");
			(*pr)("  F = print stack frames\n");
			(*pr)("  a = show return addresses\n");
			(*pr)("  p = show call-preserved registers\n");
			(*pr)("  s = ARG is a stack pointer\n");
			(*pr)("  f = ARG is a frame pointer\n");
#ifdef TRACE_DEBUG
			(*pr)("  d = trace-debugging output\n");
#endif
			return;
		}
	}

	if (!have_addr && style != Default) {
		(*pr)("expecting argument with /s or /f\n");
		return;
	}
	if (have_addr && style == Default)
		style = Frame;

	switch (style) {
	case Default:
		regs = DDB_REGS;
		break;
	case Frame:
		regs = arg.frame;
		break;
	case Stack:
		{
			unsigned val1, val2, sxip;
			unsigned ptr;
			bzero((void *)&frame, sizeof(frame));
#define REASONABLE_FRAME_DISTANCE 2048

			/*
			 * We've got to find the top of a stack frame so we can get both
			 * a PC and and real SP.
			 */
			for (ptr = arg.num;/**/; ptr += 4) {
				/* Read a word from the named stack */
				if (db_trace_get_val(ptr, &val1) == 0) {
					(*pr)("can't read from %x, aborting.\n", ptr);
					return;
				}

				/*
				 * See if it's a frame pointer.... if so it will be larger than
				 * the address it was taken from (i.e. point back up the stack)
				 * and we'll be able to read where it points.
				 */
				if (val1 <= ptr ||
				    (val1 & 3)  ||
				    val1 > (ptr + REASONABLE_FRAME_DISTANCE))
					continue;

				/* peek at the next word to see if it could be a return address */
				if (db_trace_get_val(ptr, &sxip) == 0) {
					(*pr)("can't read from %x, aborting.\n", ptr);
					return;
				}
				if (sxip == 0 || !db_trace_get_val(sxip, &val2))
					continue;

				if (db_trace_get_val(val1, &val2) == 0) {
					(*pr)("can't read from %x, aborting.\n", val1);
					continue;
				}

				/*
				 * The value we've just read will be either another frame pointer,
				 * or the start of another exception frame.
				 */
				if (
#ifdef JEFF_DEBUG
				   val2 == 0
#else
				   val2 == 0x12345678
#endif
				   && db_trace_get_val(val1-4, &val2) && val2 == val1
				   && db_trace_get_val(val1-8, &val2) && val2 == val1) {
					/* we've found a frame, so the stack must have been good */
					(*pr)("%x looks like a frame, accepting %x\n",val1,ptr);
					break;
				}

				if (val2 > val1 && (val2 & 3) == 0) {
					/* well, looks close enough to be another frame pointer */
					(*pr)("*%x = %x looks like a stack frame pointer, accepting %x\n", val1, val2, ptr);
					break;
				}
			}
                        frame.r[31] = ptr;
			frame.epsr = 0x800003f0U;
			if (cputyp != CPU_88110) {
				frame.sxip = sxip | 2;
				frame.snip = frame.sxip + 4;
				frame.sfip = frame.snip + 4;
			}
			(*pr)("[r31=%x, %sxip=%x]\n", frame.r[31],
				  cputyp == CPU_88110 ? "e" : "s", frame.sxip);
			regs = &frame;
		}
	}
	db_stack_trace_cmd2(regs, pr);
}
@


1.27
log
@typos; jjy2+@@pitt.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.26 2004/01/13 18:40:47 miod Exp $	*/
@


1.26
log
@Let frame_is_sane() be quiet on demand, then fix and enable again frame search.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.25 2004/01/12 21:33:10 miod Exp $	*/
d802 1
a802 1
		(*pr)("Register frame 0x%x is suspicous; skipping trace\n", regs);
@


1.25
log
@Shrink the reg structure, for it to only contain registers (eh), and make
the remaining fielhs only available in struct trapframe.

This has the additional benefit of preventing smarty-pants from altering
the frame a bit too easily from ddb, at the expense of a few ugly casts in
ddb.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.24 2004/01/12 07:46:14 miod Exp $	*/
d100 1
a100 1
int frame_is_sane(db_regs_t *regs);
d279 1
a279 1
frame_is_sane(db_regs_t *regs)
d283 2
a284 1
		db_printf("[WARNING: frame at %p : unreadable]\n", regs);
a287 2
#ifndef DIAGNOSTIC
	/* disabled for now  -- see fpu_enable in luna88k/eh.s */
d290 2
a291 1
		db_printf("[WARNING: frame at %p : r[0] != 0]\n", regs);
a293 1
#endif
d295 1
a295 1
	/* stack sanity ... r31 must be nonzero, but must be word aligned */
d297 2
a298 1
		db_printf("[WARNING: frame at %p : r[31] == 0 or not word aligned]\n", regs);
d319 1
a319 2
			db_printf("[WARNING: byte order in kernel frame at %p "
				  "is little-endian!]\n", regs);
d324 1
a324 2
			db_printf("[WARNING: byte order in user frame at %p "
				  "is little-endian!]\n", regs);
d327 2
a328 1
	db_printf("[WARNING: not an exception frame?]\n");
d801 1
a801 1
	if (ft = frame_is_sane(regs), ft == 0) {
d938 1
a938 1
			else if (frame_is_sane((db_regs_t*)pair[0])) {
d983 1
a983 1
		if (frame_is_sane(&user->tf_regs) == 2) {
@


1.24
log
@Get rid of that ugly m88100_saved_state structure, use trapframe everywhere
instead.

Allow struct reg and struct trapframe to live different lives and grow
separately. Righty now they are still the same, and code expects a trapframe
to always start with a struct reg. This may change...
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.23 2004/01/07 17:52:30 miod Exp $	*/
a178 3
	N("mask", mask), /* interrupt mask */
	N("mode", mode), /* interrupt mode */
	N("exvc", vector), /* exception vector */
d282 1
a282 1
	if (badwordaddr((vaddr_t)regs) || badwordaddr((vaddr_t)&regs->mode)) {
d940 2
a941 2
				db_regs_t *frame = (db_regs_t *) pair[0];
				char *cause = m88k_exception_name(frame -> vector);
d944 3
a946 2
					  cause, frame);
				db_stack_trace_cmd2(frame, pr);
d966 1
a966 1
		db_regs_t *user;
d982 1
a982 1
		user = *((db_regs_t **) stack);
d984 1
a984 1
		if (frame_is_sane(user) == 2) {
d986 2
a987 2
				  m88k_exception_name(user->vector), user);
			db_stack_trace_cmd2(user, pr);
@


1.23
log
@Constify, remove db_task_name() Mach leftover, and fix an hilarious typo
in db_interface.c comments while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.22 2004/01/07 16:22:17 miod Exp $	*/
d1010 1
a1010 1
	db_regs_t frame; /* a m88100_saved_state */
@


1.22
log
@Remove duplicate definitions with MI ddb headers, and fix db_stack_trace_print
prototype in the process.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.21 2003/12/21 13:23:32 miod Exp $	*/
d119 1
a119 1
static int trace_flags = 0;
d204 1
a204 1
	static struct {
a1146 1

@


1.21
log
@Switch db_expr_t from int to long, per consistency with other platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.20 2003/12/19 22:30:17 miod Exp $	*/
d32 1
a32 1
#include <machine/db_machdep.h> /* lots of stuff                  */
d40 1
a102 2
void db_stack_trace_print(db_regs_t *addr, int have_addr,
    db_expr_t count, char *modif, int (*pr)(const char *, ...));
d141 1
a141 1
extern int quiet_db_read_bytes;
a373 3
	boolean_t old_quiet_db_read_bytes = quiet_db_read_bytes;

	quiet_db_read_bytes = 1;
a376 1
		quiet_db_read_bytes = old_quiet_db_read_bytes;
a380 1
		quiet_db_read_bytes = old_quiet_db_read_bytes;
a384 1

d1001 1
a1001 1
db_stack_trace_print(db_regs_t *addr,
d1014 1
a1014 1
		unsigned num;
d1016 2
a1017 1
	arg.frame = addr;
@


1.20
log
@Pass -Wformat, and silence a few vme* debug printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.19 2003/10/05 20:23:52 miod Exp $	*/
d562 1
a562 1
stack_decode(unsigned addr, unsigned *stack, int (*pr)(const char *, ...))
d565 1
a565 1
	unsigned offset_from_proc;
d567 2
a568 2
	unsigned check_addr;
	unsigned function_addr;	    /* start of function */
@


1.19
log
@Correct db_{read,write}_bytes prototypes and use the official ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.18 2003/08/06 21:08:06 millert Exp $	*/
d287 1
a287 1
		db_printf("[WARNING: frame at 0x%x : unreadable]\n", regs);
d295 1
a295 1
		db_printf("[WARNING: frame at 0x%x : r[0] != 0]\n", regs);
d302 1
a302 1
		db_printf("[WARNING: frame at 0x%x : r[31] == 0 or not word aligned]\n", regs);
d323 1
a323 1
			db_printf("[WARNING: byte order in kernel frame at %x "
d329 1
a329 1
			db_printf("[WARNING: byte order in user frame at %x "
d1015 1
a1015 1
		Default, Stack, Proc, Frame
a1020 1
		struct proc *proc;
d1066 1
a1066 1
		style = Proc;
a1073 2
		break;
	case Proc:
@


1.18
log
@Remove some double semicolons (hmm, do two semis equal a maxi?).
I've skipped the GNU stuff for now.  From Patrick Latifi.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.17 2002/12/09 00:45:37 millert Exp $	*/
d39 1
a98 1
extern void db_read_bytes(vm_offset_t addr, int size, char *data);
d101 1
a101 1
unsigned db_trace_get_val(vm_offset_t addr, unsigned *ptr);
d153 1
a153 1
	register int   *regp = (int *) ((char *) DDB_REGS + (int) (vp->valuep));
d254 1
a254 1
	unsigned char c; 
d286 1
a286 1
	if (badwordaddr((vm_offset_t)regs) || badwordaddr((vm_offset_t)&regs->mode)) {
d371 1
a371 1
db_trace_get_val(vm_offset_t addr, unsigned *ptr)
d455 1
a455 1
			db_printf("%s%x", hex_value_needs_0x(value) ? 
d496 1
a496 1
	union instruction instruction; 
d933 2
a934 2
		if (badwordaddr((vm_offset_t)stack) ||
		    badwordaddr((vm_offset_t)(stack+4)))
d937 1
a937 1
		db_read_bytes((vm_offset_t)stack, 2*sizeof(int), (char *)pair);
d943 1
a943 1
				if (!badwordaddr((vm_offset_t)pair[0]) && (pair[0]!=0))
a946 1
				
d982 2
a983 2
		if (badwordaddr((vm_offset_t)stack) ||
		    badwordaddr((vm_offset_t)stack))
d986 1
a986 1
		db_read_bytes((vm_offset_t)stack, 2*sizeof(int), (char *)pair);
@


1.17
log
@From Andrushock, s/sucess/success/g
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.16 2002/05/18 09:49:17 art Exp $	*/
d787 1
a787 1
			next_address_likely_wrong = 1;;
@


1.16
log
@Rename the MD db_stack_trace_cmd to db_stack_trace_print. Add an argument
that specifies which printf funciton it should use. Implement
db_stack_trace_cmd in MI code.

Thanks to miod@@ for all the tests.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.15 2002/05/16 13:01:41 art Exp $	*/
d619 1
a619 1
					break; /* sucess */
@


1.15
log
@Add a an argument to db_printsym that specifies the printf function
we'll use for printing the information.
miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.14 2002/03/14 03:15:57 millert Exp $	*/
d102 2
a103 2
void db_stack_trace_cmd(db_regs_t *addr, int have_addr,
			     db_expr_t count, char *modif);
d562 1
a562 1
stack_decode(unsigned addr, unsigned *stack)
d576 1
a576 1
		db_printf("\n>>>stack_decode(addr=%x, stack=%x)\n",
d596 1
a596 1
		if (DEBUGGING_ON) db_printf("name %s address 0x%x\n",
d640 1
a640 1
					db_printf("ran into a [jmp r1] at %x (addr=%x)\n",
d649 1
a649 1
				db_printf("couldn't find func start (addr=%x)\n", addr);
d664 1
a664 1
		if (DEBUGGING_ON) db_printf("at start of func\n");
d670 1
a670 1
		if (DEBUGGING_ON) db_printf("couldn't read %x at line %d\n",
d678 1
a678 1
		if (DEBUGGING_ON) db_printf("<not subu,r31,r31,imm>\n");
d705 1
a705 1
			if (DEBUGGING_ON) db_printf("couldn't read %x at line %d\n",
d750 1
a750 1
			db_printf("    <return value of next fcn unreadable in %08x>\n",
d754 1
a754 1
		if (DEBUGGING_ON) db_printf("didn't save r1\n");
d763 1
a763 1
		db_printf("Return value is = %x, function_addr is %x.\n",
d782 1
a782 1
			if (DEBUGGING_ON) db_printf("jump is bad\n");
d796 1
a796 1
db_stack_trace_cmd2(db_regs_t *regs)
d813 1
a813 1
		db_printf("Register frame 0x%x is suspicous; skipping trace\n", regs);
d831 2
a832 2
	db_printf("stack base = 0x%x\n", stack);
	db_printf("(0) "); /*depth of trace */
d834 2
a835 2
		db_printf("%08x ", where);
	db_printsym(where, DB_STGY_PROC, db_printf);
d839 1
a839 1
	if ((where=stack_decode(where, &stack))==0) {
d841 1
a841 1
		db_printf("(stackless)");
d845 1
a845 1
			db_printf(" [frame 0x%x]", stack);
d847 1
a847 1
	db_printf("\n");
d849 1
a849 1
		db_printf("   %s\n", note);
d868 1
a868 1
						db_printf("[in next func:");
d871 1
a871 1
						db_printf(" r%d", r);
d873 1
a873 1
						db_printf(" r%d=%x", r, value);
d875 1
a875 1
						db_printf(" r%d=x%x", r, value);
d879 1
a879 1
				db_printf("]\n");
d882 1
a882 1
		db_printf("(%d)%c", depth++, next_address_likely_wrong ? '?':' ');
d886 3
a888 3
			db_printf("%08x ", where);
		db_printsym(where, DB_STGY_PROC, db_printf);
		where = stack_decode(where, &stack);
d891 2
a892 2
			db_printf(" [frame 0x%x]", stack);
		db_printf("\n");
d894 1
a894 1
			db_printf("   %s\n", note);
d908 1
a908 1
		db_printf("(searching for exception frame at 0x%x)\n", stack);
d944 1
a944 1
				db_printf("stack_trace:found pair 0x%x but != to stack+8\n",
d954 1
a954 1
				db_printf("-------------- %s [EF: 0x%x] -------------\n",
d956 1
a956 1
				db_stack_trace_cmd2(frame);
d961 1
a961 1
				db_printf("pair matched, but frame at 0x%x looks insane\n",
d995 1
a995 1
			db_printf("---------------- %s [EF : 0x%x] -------------\n",
d997 1
a997 1
			db_stack_trace_cmd2(user);
d1009 1
a1009 1
db_stack_trace_cmd(db_regs_t *addr,
d1012 2
a1013 1
		   char *modif)
d1046 1
a1046 1
			db_printf("unknown trace modifier [%c]\n", modif[-1]);
d1049 7
a1055 7
			db_printf("usage: trace/[MODIFIER]  [ARG]\n");
			db_printf("  u = include user trace\n");
			db_printf("  F = print stack frames\n");
			db_printf("  a = show return addresses\n");
			db_printf("  p = show call-preserved registers\n");
			db_printf("  s = ARG is a stack pointer\n");
			db_printf("  f = ARG is a frame pointer\n");
d1057 1
a1057 1
			db_printf("  d = trace-debugging output\n");
d1064 1
a1064 1
		db_printf("expecting argument with /s or /f\n");
d1093 1
a1093 1
					db_printf("can't read from %x, aborting.\n", ptr);
d1109 1
a1109 1
					db_printf("can't read from %x, aborting.\n", ptr);
d1116 1
a1116 1
					db_printf("can't read from %x, aborting.\n", val1);
d1133 1
a1133 1
					db_printf("%x looks like a frame, accepting %x\n",val1,ptr);
d1139 1
a1139 1
					db_printf("*%x = %x looks like a stack frame pointer, accepting %x\n", val1, val2, ptr);
d1150 1
a1150 1
			db_printf("[r31=%x, %sxip=%x]\n", frame.r[31],
d1155 1
a1155 1
	db_stack_trace_cmd2(regs);
@


1.14
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.13 2002/03/14 01:26:38 millert Exp $	*/
d835 1
a835 1
	db_printsym(where, DB_STGY_PROC);
d887 1
a887 1
		db_printsym(where, DB_STGY_PROC);
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.12 2001/12/22 08:31:04 smurph Exp $	*/
d384 1
a384 1
		db_read_bytes(addr, 4, (char*)ptr);
d937 1
a937 1
		db_read_bytes((vm_offset_t)stack, 2*sizeof(int), (char*)pair);
d987 1
a987 1
		db_read_bytes((vm_offset_t)stack, 2*sizeof(int), (char*)pair);
d1082 1
a1082 1
			bzero((void*)&frame, sizeof(frame));
@


1.12
log
@mc88110 support in ddb.  Bring in bit definitions.
We can support hardware sstep for mc88110 and
software sstep for mc88100.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.11 2001/12/16 23:49:46 miod Exp $	*/
d98 6
a103 6
extern void db_read_bytes __P((vm_offset_t addr, int size, char *data));
int frame_is_sane __P((db_regs_t *regs));
char *m88k_exception_name __P((unsigned vector));
unsigned db_trace_get_val __P((vm_offset_t addr, unsigned *ptr));
void db_stack_trace_cmd __P((db_regs_t *addr, int have_addr,
			     db_expr_t count, char *modif));
@


1.11
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.9 2001/11/27 05:36:10 miod Exp $	*/
d41 1
a41 1
    unsigned rawbits;
d43 44
a86 44
    struct {
	unsigned int    : 5;
	unsigned int   n: 1;
	signed int   d26:26;
    } br;

    struct {
	unsigned int      : 4;
	unsigned int isbb1: 1;	/* isbb1==0 means bb0, isbb1==1 means bb1 */
	unsigned int   n  : 1;
	unsigned int  b5  : 5;
	unsigned int  s1  : 5;
	signed   int  d16 :16;
    } bb; /* bcnd too, except "isbb1" makes no sense for bcnd */

    struct {
	unsigned int      : 6;
	unsigned int  b5  : 5;
	unsigned int  s1  : 5;
	unsigned int      : 7;
	unsigned int vec9 : 9;
    } tb; /* tcnd too */

    struct {
	unsigned int      :21;
	unsigned int    n : 1;
	unsigned int      : 5;
	unsigned int   s2 : 5;
    } jump; /* jmp, jsr */

    struct {
	unsigned int      : 6;
        unsigned int    d : 5;
        unsigned int   s1 : 5;
        unsigned int  i16 :16;
    } diatic;	/* general reg/reg/i16 instructions */

    struct {
	unsigned int      : 6;
        unsigned int    d : 5;
        unsigned int   s1 : 5;
        unsigned int      :11;
        unsigned int   s2 : 5;
    } triatic;  /* general reg/reg/reg instructions */
d92 1
a92 1
    return addr + inst.br.d26 * 4;
d103 1
a103 1
    db_expr_t count, char *modif));
d149 1
a149 2
db_setf_regs(
	struct db_variable	*vp,
d153 1
a153 1
    register int   *regp = (int *) ((char *) DDB_REGS + (int) (vp->valuep));
d155 4
a158 4
    if (op == DB_VAR_GET)
	*valuep = *regp;
    else if (op == DB_VAR_SET)
	*regp = *valuep;
d160 1
a160 1
    return (0);	/* silence warning */
d166 17
a182 17
    N("r1", r[1]),     N("r2", r[2]), 	 N("r3", r[3]),	   N("r4", r[4]),
    N("r5", r[5]),     N("r6", r[6]), 	 N("r7", r[7]),	   N("r8", r[8]),
    N("r9", r[9]),     N("r10", r[10]),  N("r11", r[11]),  N("r12", r[12]),
    N("r13", r[13]),   N("r14", r[14]),  N("r15", r[15]),  N("r16", r[16]),
    N("r17", r[17]),   N("r18", r[18]),  N("r19", r[19]),  N("r20", r[20]),
    N("r21", r[21]),   N("r22", r[22]),  N("r23", r[23]),  N("r24", r[24]),
    N("r25", r[25]),   N("r26", r[26]),  N("r27", r[27]),  N("r28", r[28]),
    N("r29", r[29]),   N("r30", r[30]),  N("r31", r[31]),  N("epsr", epsr),
    N("sxip", sxip),   N("snip", snip),  N("sfip", sfip),  N("ssbr", ssbr),
    N("dmt0", dmt0),   N("dmd0", dmd0),  N("dma0", dma0),  N("dmt1", dmt1),
    N("dmd1", dmd1),   N("dma1", dma1),  N("dmt2", dmt2),  N("dmd2", dmd2),
    N("dma2", dma2),   N("fpecr", fpecr),N("fphs1", fphs1),N("fpls1", fpls1),
    N("fphs2", fphs2), N("fpls2", fpls2),N("fppt", fppt),  N("fprh", fprh),
    N("fprl", fprl),   N("fpit", fpit),  N("fpsr", fpsr),  N("fpcr", fpcr),
    N("mask", mask), /* interrupt mask */
    N("mode", mode), /* interrupt mode */
    N("exvc", vector), /* exception vector */
d205 42
a246 41
   static struct { unsigned mask, value, flags; } *ptr, control[] =
   {
      /* runs in the same order as 2nd Ed 88100 manual Table 3-14 */
     { 0xf0000000U, 0x00000000U, /* xmem */     TRASHES | STORE | LOAD    },
     { 0xec000000U, 0x00000000U, /* ld.d */     TRASHES | LOAD | DOUBLE   },
     { 0xe0000000U, 0x00000000U, /* load */     TRASHES | LOAD            },
     { 0xfc000000U, 0x20000000U, /* st.d */     STORE | DOUBLE            },
     { 0xf0000000U, 0x20000000U, /* store */    STORE                     },
     { 0xc0000000U, 0x40000000U, /* arith */    TRASHES                   },
     { 0xfc004000U, 0x80004000U, /* ld cr */    TRASHES                   },
     { 0xfc004000U, 0x80000000U, /* st cr */    0                         },
     { 0xfc008060U, 0x84000000U, /* f */        TRASHES                   },
     { 0xfc008060U, 0x84000020U, /* f.d */      TRASHES | DOUBLE          },
     { 0xfc000000U, 0xcc000000U, /* bsr.n */    FLOW_CTRL | DELAYED | BSR },
     { 0xfc000000U, 0xc8000000U, /* bsr */      FLOW_CTRL | BSR           },
     { 0xe4000000U, 0xc4000000U, /* br/bb.n */  FLOW_CTRL | DELAYED       },
     { 0xe4000000U, 0xc0000000U, /* br/bb */    FLOW_CTRL                 },
     { 0xfc000000U, 0xec000000U, /* bcnd.n */   FLOW_CTRL | DELAYED       },
     { 0xfc000000U, 0xe8000000U, /* bcnd */     FLOW_CTRL                 },
     { 0xfc00c000U, 0xf0008000U, /* bits */     TRASHES                   },
     { 0xfc00c000U, 0xf000c000U, /* trap */     0                         },
     { 0xfc00f0e0U, 0xf4002000U, /* st */       0                         },
     { 0xfc00cce0U, 0xf4000000U, /* ld.d */     TRASHES | DOUBLE          },
     { 0xfc00c0e0U, 0xf4000000U, /* ld */       TRASHES                   },
     { 0xfc00c0e0U, 0xf4004000U, /* arith */    TRASHES                   },
     { 0xfc00c3e0U, 0xf4008000U, /* bits */     TRASHES                   },
     { 0xfc00ffe0U, 0xf400cc00U, /* jsr.n */    FLOW_CTRL | DELAYED | JSR },
     { 0xfc00ffe0U, 0xf400c800U, /* jsr */      FLOW_CTRL | JSR           },
     { 0xfc00ffe0U, 0xf400c400U, /* jmp.n */    FLOW_CTRL | DELAYED       },
     { 0xfc00ffe0U, 0xf400c000U, /* jmp */      FLOW_CTRL                 },
     { 0xfc00fbe0U, 0xf400e800U, /* ff */       TRASHES                   },
     { 0xfc00ffe0U, 0xf400f800U, /* tbnd */     0                         },
     { 0xfc00ffe0U, 0xf400fc00U, /* rte */      FLOW_CTRL                 },
     { 0xfc000000U, 0xf8000000U, /* tbnd */     0                         },
    };
    #define ctrl_count (sizeof(control)/sizeof(control[0]))
    for (ptr = &control[0]; ptr < &control[ctrl_count]; ptr++)
	if ((instruction & ptr->mask) == ptr->value)
	    return ptr->flags;
    SHOW_INSTRUCTION(0, instruction, "bad m88k_instruction_info");
    return 0;
d252 7
a258 4
    int i;
    unsigned last = 0;
    unsigned char c; 
    unsigned have_a_hex_digit = 0;
d260 12
a271 1
    if (value <= 9)
a272 14

    for (i = 0; i < 8; i++) {
	c = value & 0xf;
	value >>= 4;
	if (c)
	    last = c;
	if (c > 9)
	    have_a_hex_digit = 1;
    }
    if (have_a_hex_digit == 0)
	return 1;
    if (last > 9)
	return 1;
    return 0;
a274 1

d285 5
a289 3
    /* no good if we can't read the whole frame */
    if (badwordaddr((vm_offset_t)regs) || badwordaddr((vm_offset_t)&regs->mode))
	return 0;
d292 6
a297 4
    /* disabled for now  -- see fpu_enable in mvme88k/eh.s */
    /* r0 must be 0 (obviously) */
    if (regs->r[0] != 0)
	return 0;
d300 5
a304 3
    /* stack sanity ... r31 must be nonzero, but must be word aligned */
    if (regs->r[31] == 0 || (regs->r[31] & 3) != 0)
	return 0;
d306 2
a307 1
    /* sxip is reasonable */
d309 2
a310 2
    if ((regs->sxip & 1) == 1)
	return 0;
d312 22
a333 5
    /* snip is reasonable */
    if ((regs->snip & 3) != 2)
	return 0;
    /* sfip is reasonable */
    if ((regs->sfip & 3) != 2)
a334 17

    /* epsr sanity */
    if ((regs->epsr & 0x8FFFFFF5U) == 0x800003f0U) /* kernel mode */
    {
	if (regs->epsr & 0x40000000) 
	  db_printf("[WARNING: byte order in kernel frame at %x "
		    "is little-endian!]\n", regs);
	return 1;
    }
    if ((regs->epsr & 0x8FFFFFFFU) == 0x000003f0U) /* user mode */
    {
	if (regs->epsr & 0x40000000) 
	  db_printf("[WARNING: byte order in user frame at %x "
		    "is little-endian!]\n", regs);
	return 2;
    }
    return 0;
d340 1
a340 1
	switch  (vector) {
d353 1
d363 1
a363 1
    }
d373 16
a388 16
    label_t db_jmpbuf;
    label_t *prev = db_recover;
    boolean_t old_quiet_db_read_bytes = quiet_db_read_bytes;

    quiet_db_read_bytes = 1;

    if (setjmp((db_recover = &db_jmpbuf)) != 0) {
	db_recover = prev;
        quiet_db_read_bytes = old_quiet_db_read_bytes;
	return 0;
    } else {
	db_read_bytes(addr, 4, (char*)ptr);
	db_recover = prev;
        quiet_db_read_bytes = old_quiet_db_read_bytes;
	return 1;
    }
d408 1
a408 1
    #ifdef TRACE_DEBUG
d410 10
a419 10
    #endif
    if (trashed_list & reg_bit(reg)) {
	#ifdef TRACE_DEBUG
	    if (DEBUGGING_ON) db_printf("<trashed>\n");
	#endif
	return; /* don't save trashed registers */
    }
    saved_reg[(reg%32)] = value;
    global_saved_list |= reg_bit(reg);
    local_saved_list  |= reg_bit(reg);
d438 1
a438 1
    int reg, last_arg;
d440 24
a463 24
    /* find the highest argument register saved */
    for (last_arg = LAST_ARG_REG; last_arg >= FIRST_ARG_REG; last_arg--)
	if (have_local_reg(last_arg))
	    break;
    if (last_arg < FIRST_ARG_REG)
	return; /* none were saved */

    db_printf("(");

    /* print each one, up to the highest */
    for (reg = FIRST_ARG_REG; /*nothing */; reg++)
    {
	if (!have_local_reg(reg))
	    db_printf("?");
	else {
	    unsigned value = saved_reg_value(reg);
	    db_printf("%s%x", hex_value_needs_0x(value)  ? "0x" : "", value);
	}
	if (reg == last_arg)
	    break;
	else
	    db_printf(", ");
    }
    db_printf(")");
d495 27
a521 2
    unsigned flags;
    union instruction instruction; 
d523 9
a531 34
    /*
     * Delayed branches are most common... look two instructions before
     * where we were going to return to to see if it's a delayed branch.
     */
    if (!db_trace_get_val(return_to - 8, &instruction.rawbits))
	return JUMP_SOURCE_IS_BAD;
    flags = m88k_instruction_info(instruction.rawbits);

    if ((flags & FLOW_CTRL) && (flags & DELAYED) && (flags & (JSR|BSR))) {
	if (flags & JSR)
	    return JUMP_SOURCE_IS_OK; /* have to assume it's correct */
	/* calculate the offset */
	if (br_dest(return_to - 8, instruction) == jump_to)
	    return JUMP_SOURCE_IS_OK; /* exactamundo! */
	else
	    return JUMP_SOURCE_IS_UNLIKELY; /* seems wrong */
    }

    /*
     * Try again, looking for a non-delayed jump one back.
     */
    if (!db_trace_get_val(return_to - 4, &instruction.rawbits))
	return JUMP_SOURCE_IS_BAD;
    flags = m88k_instruction_info(instruction.rawbits);

    if ((flags & FLOW_CTRL) && !(flags & DELAYED) && (flags & (JSR|BSR))) {
	if (flags & JSR)
	    return JUMP_SOURCE_IS_OK; /* have to assume it's correct */
	/* calculate the offset */
	if (br_dest(return_to - 4, instruction) == jump_to)
	    return JUMP_SOURCE_IS_OK; /* exactamundo! */
	else
	    return JUMP_SOURCE_IS_UNLIKELY; /* seems wrong */
    }
d533 1
a533 1
    return JUMP_SOURCE_IS_UNLIKELY;
d564 21
a584 40
    db_sym_t proc;
    unsigned offset_from_proc;
    unsigned instructions_to_search;
    unsigned check_addr;
    unsigned function_addr;	/* start of function */
    unsigned r31 = *stack;	/* the r31 of the function */
    unsigned inst;		/* text of an instruction */
    unsigned ret_addr;		/* address to which we return */
    unsigned tried_to_save_r1 = 0;

    #ifdef TRACE_DEBUG
      if (DEBUGGING_ON)
	db_printf("\n>>>stack_decode(addr=%x, stack=%x)\n",
		addr, *stack);
    #endif

      /* get what we hope will be the db_sym_t for the function name */
    proc = db_search_symbol(addr, DB_STGY_PROC, &offset_from_proc);
    if (offset_from_proc == addr) /* i.e. no symbol found */
	proc = DB_SYM_NULL;

    /*
     * Somehow, find the start of this function.
     * If we found a symbol above, it'll have the address.
     * Otherwise, we've got to search for it....
     */
    if (proc != DB_SYM_NULL)
    {
	char *names;
	db_symbol_values(proc, &names, &function_addr);
	if (names == 0)
	    return 0;
	#ifdef TRACE_DEBUG
	    if (DEBUGGING_ON) db_printf("name %s address 0x%x\n",
		names, function_addr);
	#endif
    }
    else
    {
	int instructions_to_check = 400;
d586 3
a588 2
	 * hmm - unable to find symbol. Search back
	 * looking for a function prolog.
d590 65
a654 4
	for (check_addr = addr; instructions_to_check-- > 0; check_addr -= 4)
	{
	    if (!db_trace_get_val(check_addr, &inst))
		break;
d656 24
a679 35
	    if (SUBU_R31_R31_IMM(inst))
	    {
		#if 0
		    /*
		     * If the next instruction is "st r1, r31, ####"
		     * then we can feel safe we have the start of
		     * a function.
		     */
		    if (!db_trace_get_val(check_addr + 4, &inst))
			continue;
		    if (ST_R1_R31_IMM(instr))
			break; /* sucess */
		#else
		    /*
		     * Latest GCC optimizer is just too good... the store
		     * of r1 might come much later... so we'll have to
		     * settle for just the "subr r31, r31, ###" to mark
		     * the start....
		     */
		     break;
		#endif
	    }
	    /*
	     * if we come across a [jmp r1] or [jmp.n r1] assume we have hit
	     * the previous functions epilogue and stop our search.
	     * Since we know we would have hit the "subr r31, r31" if it was
	     * right in front of us, we know this doesn't have one so
	     * we just return failure....
	     */
	    if (JMP_R1(inst) || JMPN_R1(inst)) {
		#ifdef TRACE_DEBUG
		    if (DEBUGGING_ON)
			db_printf("ran into a [jmp r1] at %x (addr=%x)\n",
				check_addr, addr);
		#endif
a680 1
	    }
a681 36
	if (instructions_to_check < 0) {
	    #ifdef TRACE_DEBUG
		if (DEBUGGING_ON)
		    db_printf("couldn't find func start (addr=%x)\n", addr);
	    #endif
	    return 0; /* bummer, couldn't find it */
	}
	function_addr = check_addr;
    }

    /*
     * We now know the start of the function (function_addr).
     * If we're stopped right there, or if it's not a
     *		subu r31, r31, ####
     * then we're done.
     */
    if (addr == function_addr) {
	#ifdef TRACE_DEBUG
	    if (DEBUGGING_ON) db_printf("at start of func\n");
	#endif
	return 0;
    }
    if (!db_trace_get_val(function_addr, &inst)) {
	#ifdef TRACE_DEBUG
	    if (DEBUGGING_ON) db_printf("couldn't read %x at line %d\n",
		function_addr, __LINE__);
	#endif
	return 0;
    }
    SHOW_INSTRUCTION(function_addr, inst, "start of function: ");
    if (!SUBU_R31_R31_IMM(inst)) {
	#ifdef TRACE_DEBUG
	    if (DEBUGGING_ON) db_printf("<not subu,r31,r31,imm>\n");
	#endif
	return 0;
    }
d683 49
a731 2
    /* add the size of this frame to the stack (for the next frame) */
    *stack += IMM16VAL(inst);
d733 6
a738 16
    /*
     * Search from the beginning of the function (funstart) to where we are
     * in the function (addr) looking to see what kind of registers have
     * been saved on the stack.
     *
     * We'll stop looking before we get to ADDR if we hit a branch.
     */
    clear_local_saved_regs();
    check_addr = function_addr + 4; /* we know the first inst isn't a store */

    for (instructions_to_search = (addr - check_addr)/sizeof(long);
	instructions_to_search-- > 0;
	check_addr += 4)
    {
 	union instruction instruction;
	unsigned flags;
d740 3
a742 7
	/* read the instruction */
        if (!db_trace_get_val(check_addr, &instruction.rawbits)) {
	    #ifdef TRACE_DEBUG
		if (DEBUGGING_ON) db_printf("couldn't read %x at line %d\n",
		    check_addr, __LINE__);
	    #endif
            break;
d745 13
a757 1
	SHOW_INSTRUCTION(check_addr, instruction.rawbits, "prolog: ");
d759 1
a759 2
	/* find out the particulars about this instruction */
	flags = m88k_instruction_info(instruction.rawbits);
d761 5
a765 43
	/* if a store to something off the stack pointer, note the value */
	if ((flags & STORE) && instruction.diatic.s1 == /*stack pointer*/31)
	{
	    unsigned value;
	    if (!have_local_reg(instruction.diatic.d)) {
		if (instruction.diatic.d == 1)
			tried_to_save_r1 = r31 + instruction.diatic.i16 ;
		if (db_trace_get_val(r31 + instruction.diatic.i16, &value))
		    save_reg(instruction.diatic.d, value);
	    }
	    if ((flags & DOUBLE) && !have_local_reg(instruction.diatic.d + 1)) {
		if (instruction.diatic.d == 0)
		    tried_to_save_r1 = r31+instruction.diatic.i16 +4;
		if (db_trace_get_val(r31+instruction.diatic.i16 +4, &value))
		    save_reg(instruction.diatic.d + 1, value);
	    }
	}

	/* if an inst that kills D (and maybe D+1), note that */
	if (flags & TRASHES) {
	    mark_reg_trashed(instruction.diatic.d);
	    if (flags & DOUBLE)
	        mark_reg_trashed(instruction.diatic.d + 1);
	}

	/* if a flow control instruction, stop now (or next if delayed) */
	if ((flags & FLOW_CTRL) && instructions_to_search != 0)
	    instructions_to_search = (flags & DELAYED) ? 1 : 0;
    }

    /*
     * If we didn't save r1 at some point, we're hosed.
     */
    if (!have_local_reg(1)) {
	if (tried_to_save_r1) {
	    db_printf("    <return value of next fcn unreadable in %08x>\n",
		tried_to_save_r1);
	}
	#ifdef TRACE_DEBUG
	    if (DEBUGGING_ON) db_printf("didn't save r1\n");
	#endif
	return 0;
    }
d767 12
a778 1
    ret_addr = saved_reg_value(1);
d780 5
a784 24
    #ifdef TRACE_DEBUG
    if (DEBUGGING_ON)
	db_printf("Return value is = %x, function_addr is %x.\n",
	    ret_addr, function_addr);
    #endif

    /*
     * In support of this, continuation.s puts the low bit on the
     * return address for continuations (the return address will never
     * be used, so it's ok to do anything you want to it).
     */
    if (ret_addr & 1) {
	note = "<<can not trace past a continuation>>";
	ret_addr = 0;
    } else if (ret_addr != 0x00) {
	switch(is_jump_source_ok(ret_addr, function_addr)) {
	  case JUMP_SOURCE_IS_OK:
		break; /* excellent */

	  case JUMP_SOURCE_IS_BAD:
		#ifdef TRACE_DEBUG
		    if (DEBUGGING_ON) db_printf("jump is bad\n");
		#endif
		return 0; /* bummer */
d786 4
a789 3
	  case JUMP_SOURCE_IS_UNLIKELY:
		next_address_likely_wrong = 1;;
		break;
a790 1
    }
d792 1
a792 1
    return ret_addr;
d798 6
a803 54
    unsigned stack;
    unsigned depth=1;
    unsigned where;
    unsigned ft;
    unsigned pair[2];
    int i;

    /*
     * Frame_is_sane returns:
     *   1 if regs seems to be a reasonable kernel exception frame.
     *   2 if regs seems to be a reasonable user exception frame
     *      (in the current task).
     *   0 if this looks like neither.
     */
    if (ft = frame_is_sane(regs), ft == 0)
    {
	db_printf("Register frame 0x%x is suspicous; skipping trace\n", regs);
	return;
    }

    /* if user space and no user space trace specified, puke */
    if (ft == 2 && !(trace_flags & TRACE_USER_FLAG))
	return;

    /* fetch address */
    /* use sxip if valid, otherwise try snip or sfip */
    where = ((regs->sxip & 2) ? regs->sxip :
	    ((regs->snip & 2) ? regs->snip :
	      regs->sfip) ) & ~3;
    stack = regs->r[31];
    db_printf("stack base = 0x%x\n", stack);
    db_printf("(0) "); /*depth of trace */
    if (trace_flags & TRACE_SHOWADDRESS_FLAG)
	db_printf("%08x ", where);
    db_printsym(where, DB_STGY_PROC);
    clear_global_saved_regs();

    /* see if this routine had a stack frame */
    if ((where=stack_decode(where, &stack))==0)
    {
	where = regs->r[1];
	db_printf("(stackless)");
    }
    else
    {
	print_args();
	if (trace_flags & TRACE_SHOWFRAME_FLAG)
	    db_printf(" [frame 0x%x]", stack);
    }
    db_printf("\n");
    if (note) {
	db_printf("   %s\n", note);
	note = 0;
    }
a804 2
    do
    {
d806 5
a810 4
	 * If requested, show preserved registers at the time
	 * the next-shown call was made. Only registers known to have
	 * changed from the last exception frame are shown, as others
	 * can be gotten at by looking at the exception frame.
d812 3
a814 21
	if (trace_flags & TRACE_SHOWCALLPRESERVED_FLAG)
	{
	    int r, title_printed = 0;

	    for (r = FIRST_CALLPRESERVED_REG; r<=LAST_CALLPRESERVED_REG; r++) {
		if (have_global_reg(r)) {
		    unsigned value = saved_reg_value(r);
		    if (title_printed == 0) {
		       title_printed = 1;
		       db_printf("[in next func:");
		    }
		    if (value == 0)
			db_printf(" r%d", r);
		    else if (value <= 9)
			db_printf(" r%d=%x", r, value);
		    else
			db_printf(" r%d=x%x", r, value);
		}
	    }
	    if (title_printed)
		db_printf("]\n");
d817 3
a819 2
	db_printf("(%d)%c", depth++, next_address_likely_wrong ? '?':' ');
	next_address_likely_wrong = 0;
d821 12
d834 1
a834 1
	    db_printf("%08x ", where);
d836 11
a846 4
	where = stack_decode(where, &stack);
	print_args();
	if (trace_flags & TRACE_SHOWFRAME_FLAG)
	    db_printf(" [frame 0x%x]", stack);
d849 2
a850 2
	    db_printf("   %s\n", note);
	    note = 0;
a851 1
    } while (where);
d853 47
a899 1
    /* try to trace back over trap/exception */
d901 2
a902 2
    stack &= ~7; /* double word aligned */
    /* take last top of stack, and try to find an exception frame near it */
d904 1
a904 1
    i = FRAME_PLAY;
d906 1
a906 1
    #ifdef TRACE_DEBUG
d908 60
a967 2
	    db_printf("(searching for exception frame at 0x%x)\n", stack);
    #endif
a968 2
    while (i)
    {
d970 4
a973 18
	 * On the stack, a pointer to the exception frame is written
	 * in two adjacent words. In the case of a fault from the kernel,
	 * this should point to the frame right above them:
	 *
	 * Exception Frame Top
	 * ..
	 * Exception Frame Bottom  <-- frame addr
	 * frame addr
	 * frame addr		<-- stack pointer
	 *
	 * In the case of a fault from user mode, the top of stack
	 * will just have the address of the frame
	 * replicated twice.
	 *
	 * frame addr		<-- top of stack
	 * frame addr
	 *
	 * Here we are just looking for kernel exception frames.
d975 2
d978 21
a998 68
	if (badwordaddr((vm_offset_t)stack) ||
	    badwordaddr((vm_offset_t)(stack+4)))
		    break;

	db_read_bytes((vm_offset_t)stack, 2*sizeof(int), (char*)pair);

	/* the pairs should match and equal stack+8 */
	if (pair[0] == pair[1])
	{
	    if (pair[0] != stack+8)
	    {
		/*
		if (!badwordaddr((vm_offset_t)pair[0]) && (pair[0]!=0))
		db_printf("stack_trace:found pair 0x%x but != to stack+8\n",
		pair[0]);
		*/
	    }
	    else if (frame_is_sane((db_regs_t*)pair[0]))
	    {
		db_regs_t *frame = (db_regs_t *) pair[0];
		char *cause = m88k_exception_name(frame -> vector);

		db_printf("-------------- %s [EF: 0x%x] -------------\n",
		      cause, frame);
		db_stack_trace_cmd2(frame);
		return;
	    }
	    #ifdef TRACE_DEBUG
		else if (DEBUGGING_ON)
		    db_printf("pair matched, but frame at 0x%x looks insane\n",
			stack+8);
	    #endif
	}
	stack += 8;
	i--;
    }

    /*
     * If we go here, crawling back on the stack failed to find us
     * a previous exception frame. Look for a user frame pointer
     * pointed to by a word 8 bytes off of the top of the stack
     * if the "u" option was specified.
     */
    if (trace_flags & TRACE_USER_FLAG)
    {
	db_regs_t *user;

	/* Make sure we are back on the right page */
	stack -= 4*FRAME_PLAY;
	stack = stack & ~(KERNEL_STACK_SIZE-1); /* point to the bottom */
	stack += KERNEL_STACK_SIZE - 8;

	if (badwordaddr((vm_offset_t)stack) ||
	    badwordaddr((vm_offset_t)stack))
		    return;

	db_read_bytes((vm_offset_t)stack, 2*sizeof(int), (char*)pair);
	if (pair[0] != pair[1])
	    return;

	/* have a hit */
	user = *((db_regs_t **) stack);

	if (frame_is_sane(user) == 2)
	{
	    db_printf("---------------- %s [EF : 0x%x] -------------\n",
		m88k_exception_name(user->vector), user);
	    db_stack_trace_cmd2(user);
a999 1
    }
d1009 4
a1012 5
db_stack_trace_cmd(
    db_regs_t *addr,
    int have_addr,
    db_expr_t count,
    char *modif)
d1014 47
a1060 73
    enum { Default, Stack, Proc, Frame } style = Default;
    db_regs_t frame; /* a m88100_saved_state */
    db_regs_t *regs;
    union {
	db_regs_t *frame;
	struct proc *proc;
	unsigned num;
    } arg;
    arg.frame = addr;

    trace_flags = 0; /* flags will be set via modifers */

    while (modif && *modif) {
	 switch (*modif++)
    	 {
	  case 'd':
	    #ifdef TRACE_DEBUG
		trace_flags |= TRACE_DEBUG_FLAG;
	    #else
		db_printtf("<debug trace not compiled in, ignoring>\n");
	    #endif
	    break;

	  case 's': style = Stack  ; break;
	  case 'f': style = Frame  ; break;
	  case 'p': trace_flags |= TRACE_SHOWCALLPRESERVED_FLAG; break;
	  case 'a': trace_flags |= TRACE_SHOWADDRESS_FLAG; break;
	  case 'F': trace_flags |= TRACE_SHOWFRAME_FLAG; break;
	  case 'u': trace_flags |= TRACE_USER_FLAG; break;
	  default:
	    db_printf("unknown trace modifier [%c]\n", modif[-1]);
	    /*FALLTHROUGH*/
	  case 'h':
	    db_printf("usage: trace/[MODIFIER]  [ARG]\n");
	    db_printf("  u = include user trace\n");
	    db_printf("  F = print stack frames\n");
	    db_printf("  a = show return addresses\n");
	    db_printf("  p = show call-preserved registers\n");
	    db_printf("  s = ARG is a stack pointer\n");
	    db_printf("  f = ARG is a frame pointer\n");
	    #ifdef TRACE_DEBUG
		db_printf("  d = trace-debugging output\n");
	    #endif
	    return;
	}
    }

    if (!have_addr && style != Default) {
	db_printf("expecting argument with /s or /f\n");
	return;
    }
    if (have_addr && style == Default)
	style = Proc;

    switch(style)
    {
      case Default:
	regs = DDB_REGS;
	break;

      case Frame:
	regs = arg.frame;
	break;
      
      case Proc:
        break;
      
      case Stack:
      {
	unsigned val1, val2, sxip;
	unsigned ptr;
	bzero((void*)&frame, sizeof(frame));
	#define REASONABLE_FRAME_DISTANCE 2048
d1062 2
a1063 8
	/*
	 * We've got to find the top of a stack frame so we can get both
	 * a PC and and real SP.
	 */
	for (ptr = arg.num;/**/; ptr += 4) {
	    /* Read a word from the named stack */
	    if (db_trace_get_val(ptr, &val1) == 0) {
		db_printf("can't read from %x, aborting.\n", ptr);
d1065 3
a1067 1
	    }
d1069 8
a1076 44
	    /*
	     * See if it's a frame pointer.... if so it will be larger than
	     * the address it was taken from (i.e. point back up the stack)
	     * and we'll be able to read where it points.
	     */
	    if (val1 <= ptr ||
		(val1 & 3)  ||
		val1 > (ptr + REASONABLE_FRAME_DISTANCE))
		    continue;

	    /* peek at the next word to see if it could be a return address */
	    if (db_trace_get_val(ptr, &sxip) == 0) {
		db_printf("can't read from %x, aborting.\n", ptr);
		return;
	    }
	    if (sxip == 0 || !db_trace_get_val(sxip, &val2))
		continue;

	    if (db_trace_get_val(val1, &val2) == 0) {
		db_printf("can't read from %x, aborting.\n", val1);
		continue;
	    }

	    /*
	     * The value we've just read will be either another frame pointer,
	     * or the start of another exception frame.
	     */
	    if (
		#ifdef JEFF_DEBUG
		    val2 == 0
		#else
		    val2 == 0x12345678
		#endif
	        && db_trace_get_val(val1-4, &val2) && val2 == val1
	        && db_trace_get_val(val1-8, &val2) && val2 == val1)
	    {
		    /* we've found a frame, so the stack must have been good */
		    db_printf("%x looks like a frame, accepting %x\n",val1,ptr);
		    break;
	    }

	    if (val2 > val1 && (val2 & 3) == 0) {
		/* well, looks close enough to be another frame pointer */
		db_printf("*%x = %x looks like a stack frame pointer, accepting %x\n", val1, val2, ptr);
d1078 75
a1152 1
	    }
d1154 2
a1156 12
	frame.r[31] = ptr;
	frame.epsr = 0x800003f0U;
	frame.sxip = sxip | 2;
	frame.snip = frame.sxip + 4;
	frame.sfip = frame.snip + 4;
	db_printf("[r31=%x, sxip=%x]\n", frame.r[31], frame.sxip);
	regs = &frame;
      }
    }

    db_stack_trace_cmd2(regs);
}
@


1.11.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.12 2001/12/22 08:31:04 smurph Exp $	*/
d41 1
a41 1
	unsigned rawbits;
d43 44
a86 44
	struct {
		unsigned int    : 5;
		unsigned int   n: 1;
		signed int   d26:26;
	} br;

	struct {
		unsigned int      : 4;
		unsigned int isbb1: 1;	/* isbb1==0 means bb0, isbb1==1 means bb1 */
		unsigned int   n  : 1;
		unsigned int  b5  : 5;
		unsigned int  s1  : 5;
		signed   int  d16 :16;
	} bb; /* bcnd too, except "isbb1" makes no sense for bcnd */

	struct {
		unsigned int      : 6;
		unsigned int  b5  : 5;
		unsigned int  s1  : 5;
		unsigned int      : 7;
		unsigned int vec9 : 9;
	} tb; /* tcnd too */

	struct {
		unsigned int      :21;
		unsigned int    n : 1;
		unsigned int      : 5;
		unsigned int   s2 : 5;
	} jump;	/* jmp, jsr */

	struct {
		unsigned int      : 6;
		unsigned int    d : 5;
		unsigned int   s1 : 5;
		unsigned int  i16 :16;
	} diatic;   /* general reg/reg/i16 instructions */

	struct {
		unsigned int      : 6;
		unsigned int    d : 5;
		unsigned int   s1 : 5;
		unsigned int      :11;
		unsigned int   s2 : 5;
	} triatic;  /* general reg/reg/reg instructions */
d92 1
a92 1
	return addr + inst.br.d26 * 4;
d103 1
a103 1
			     db_expr_t count, char *modif));
d149 2
a150 1
db_setf_regs(struct db_variable      *vp,
d154 1
a154 1
	register int   *regp = (int *) ((char *) DDB_REGS + (int) (vp->valuep));
d156 4
a159 4
	if (op == DB_VAR_GET)
		*valuep = *regp;
	else if (op == DB_VAR_SET)
		*regp = *valuep;
d161 1
a161 1
	return (0); /* silence warning */
d167 17
a183 17
	N("r1", r[1]),     N("r2", r[2]),    N("r3", r[3]),    N("r4", r[4]),
	N("r5", r[5]),     N("r6", r[6]),    N("r7", r[7]),    N("r8", r[8]),
	N("r9", r[9]),     N("r10", r[10]),  N("r11", r[11]),  N("r12", r[12]),
	N("r13", r[13]),   N("r14", r[14]),  N("r15", r[15]),  N("r16", r[16]),
	N("r17", r[17]),   N("r18", r[18]),  N("r19", r[19]),  N("r20", r[20]),
	N("r21", r[21]),   N("r22", r[22]),  N("r23", r[23]),  N("r24", r[24]),
	N("r25", r[25]),   N("r26", r[26]),  N("r27", r[27]),  N("r28", r[28]),
	N("r29", r[29]),   N("r30", r[30]),  N("r31", r[31]),  N("epsr", epsr),
	N("sxip", sxip),   N("snip", snip),  N("sfip", sfip),  N("ssbr", ssbr),
	N("dmt0", dmt0),   N("dmd0", dmd0),  N("dma0", dma0),  N("dmt1", dmt1),
	N("dmd1", dmd1),   N("dma1", dma1),  N("dmt2", dmt2),  N("dmd2", dmd2),
	N("dma2", dma2),   N("fpecr", fpecr),N("fphs1", fphs1),N("fpls1", fpls1),
	N("fphs2", fphs2), N("fpls2", fpls2),N("fppt", fppt),  N("fprh", fprh),
	N("fprl", fprl),   N("fpit", fpit),  N("fpsr", fpsr),  N("fpcr", fpcr),
	N("mask", mask), /* interrupt mask */
	N("mode", mode), /* interrupt mode */
	N("exvc", vector), /* exception vector */
d206 41
a246 42
	static struct {
		unsigned mask, value, flags;
	} *ptr, control[] = {
		/* runs in the same order as 2nd Ed 88100 manual Table 3-14 */
		{ 0xf0000000U, 0x00000000U, /* xmem */     TRASHES | STORE | LOAD},
		{ 0xec000000U, 0x00000000U, /* ld.d */     TRASHES | LOAD | DOUBLE},
		{ 0xe0000000U, 0x00000000U, /* load */     TRASHES | LOAD},
		{ 0xfc000000U, 0x20000000U, /* st.d */     STORE | DOUBLE},
		{ 0xf0000000U, 0x20000000U, /* store */    STORE},
		{ 0xc0000000U, 0x40000000U, /* arith */    TRASHES},
		{ 0xfc004000U, 0x80004000U, /* ld cr */    TRASHES},
		{ 0xfc004000U, 0x80000000U, /* st cr */    0},
		{ 0xfc008060U, 0x84000000U, /* f */        TRASHES},
		{ 0xfc008060U, 0x84000020U, /* f.d */      TRASHES | DOUBLE},
		{ 0xfc000000U, 0xcc000000U, /* bsr.n */    FLOW_CTRL | DELAYED | BSR},
		{ 0xfc000000U, 0xc8000000U, /* bsr */      FLOW_CTRL | BSR},
		{ 0xe4000000U, 0xc4000000U, /* br/bb.n */  FLOW_CTRL | DELAYED},
		{ 0xe4000000U, 0xc0000000U, /* br/bb */    FLOW_CTRL},
		{ 0xfc000000U, 0xec000000U, /* bcnd.n */   FLOW_CTRL | DELAYED},
		{ 0xfc000000U, 0xe8000000U, /* bcnd */     FLOW_CTRL},
		{ 0xfc00c000U, 0xf0008000U, /* bits */     TRASHES},
		{ 0xfc00c000U, 0xf000c000U, /* trap */     0},
		{ 0xfc00f0e0U, 0xf4002000U, /* st */       0},
		{ 0xfc00cce0U, 0xf4000000U, /* ld.d */     TRASHES | DOUBLE},
		{ 0xfc00c0e0U, 0xf4000000U, /* ld */       TRASHES},
		{ 0xfc00c0e0U, 0xf4004000U, /* arith */    TRASHES},
		{ 0xfc00c3e0U, 0xf4008000U, /* bits */     TRASHES},
		{ 0xfc00ffe0U, 0xf400cc00U, /* jsr.n */    FLOW_CTRL | DELAYED | JSR},
		{ 0xfc00ffe0U, 0xf400c800U, /* jsr */      FLOW_CTRL | JSR},
		{ 0xfc00ffe0U, 0xf400c400U, /* jmp.n */    FLOW_CTRL | DELAYED},
		{ 0xfc00ffe0U, 0xf400c000U, /* jmp */      FLOW_CTRL},
		{ 0xfc00fbe0U, 0xf400e800U, /* ff */       TRASHES},
		{ 0xfc00ffe0U, 0xf400f800U, /* tbnd */     0},
		{ 0xfc00ffe0U, 0xf400fc00U, /* rte */      FLOW_CTRL},
		{ 0xfc000000U, 0xf8000000U, /* tbnd */     0},
	};
#define ctrl_count (sizeof(control)/sizeof(control[0]))
	for (ptr = &control[0]; ptr < &control[ctrl_count]; ptr++)
		if ((instruction & ptr->mask) == ptr->value)
			return ptr->flags;
	SHOW_INSTRUCTION(0, instruction, "bad m88k_instruction_info");
	return 0;
d252 4
a255 4
	int i;
	unsigned last = 0;
	unsigned char c; 
	unsigned have_a_hex_digit = 0;
d257 2
a258 2
	if (value <= 9)
		return 0;
d260 13
a272 13
	for (i = 0; i < 8; i++) {
		c = value & 0xf;
		value >>= 4;
		if (c)
			last = c;
		if (c > 9)
			have_a_hex_digit = 1;
	}
	if (have_a_hex_digit == 0)
		return 1;
	if (last > 9)
		return 1;
	return 0;
d275 1
d286 3
a288 5
	/* no good if we can't read the whole frame */
	if (badwordaddr((vm_offset_t)regs) || badwordaddr((vm_offset_t)&regs->mode)) {
		db_printf("[WARNING: frame at 0x%x : unreadable]\n", regs);
		return 0;
	}
d291 4
a294 6
	/* disabled for now  -- see fpu_enable in luna88k/eh.s */
	/* r0 must be 0 (obviously) */
	if (regs->r[0] != 0) {
		db_printf("[WARNING: frame at 0x%x : r[0] != 0]\n", regs);
		return 0;
	}
d297 3
a299 5
	/* stack sanity ... r31 must be nonzero, but must be word aligned */
	if (regs->r[31] == 0 || (regs->r[31] & 3) != 0) {
		db_printf("[WARNING: frame at 0x%x : r[31] == 0 or not word aligned]\n", regs);
		return 0;
	}
d301 1
a301 2
	if (cputyp != CPU_88110) {
		/* sxip is reasonable */
d303 2
a304 2
		if ((regs->sxip & 1) == 1)
			return 0;
d306 6
a311 7
		/* snip is reasonable */
		if ((regs->snip & 3) != 2)
			return 0;
		/* sfip is reasonable */
		if ((regs->sfip & 3) != 2)
			return 0;
	}
d313 16
a328 15
	/* epsr sanity */
	if ((regs->epsr & PSR_MODE)) { /* kernel mode */
		if (regs->epsr & PSR_BO)
			db_printf("[WARNING: byte order in kernel frame at %x "
				  "is little-endian!]\n", regs);
		return 1;
	}
	if (!(regs->epsr & PSR_MODE)) {	/* user mode */
		if (regs->epsr & PSR_BO)
			db_printf("[WARNING: byte order in user frame at %x "
				  "is little-endian!]\n", regs);
		return 2;
	}
	db_printf("[WARNING: not an exception frame?]\n");
	return 0;
d334 1
a334 1
	switch (vector) {
a346 1
	case  11: return "Non Maskable Interrupt";
d356 1
a356 1
	}
d366 16
a381 16
	label_t db_jmpbuf;
	label_t *prev = db_recover;
	boolean_t old_quiet_db_read_bytes = quiet_db_read_bytes;

	quiet_db_read_bytes = 1;

	if (setjmp((db_recover = &db_jmpbuf)) != 0) {
		db_recover = prev;
		quiet_db_read_bytes = old_quiet_db_read_bytes;
		return 0;
	} else {
		db_read_bytes(addr, 4, (char*)ptr);
		db_recover = prev;
		quiet_db_read_bytes = old_quiet_db_read_bytes;
		return 1;
	}
d401 1
a401 1
#ifdef TRACE_DEBUG
d403 10
a412 10
#endif
	if (trashed_list & reg_bit(reg)) {
#ifdef TRACE_DEBUG
		if (DEBUGGING_ON) db_printf("<trashed>\n");
#endif
		return;	/* don't save trashed registers */
	}
	saved_reg[(reg%32)] = value;
	global_saved_list |= reg_bit(reg);
	local_saved_list  |= reg_bit(reg);
d431 1
a431 1
	int reg, last_arg;
d433 24
a456 24
	/* find the highest argument register saved */
	for (last_arg = LAST_ARG_REG; last_arg >= FIRST_ARG_REG; last_arg--)
		if (have_local_reg(last_arg))
			break;
	if (last_arg < FIRST_ARG_REG)
		return;	/* none were saved */

	db_printf("(");

	/* print each one, up to the highest */
	for (reg = FIRST_ARG_REG; /*nothing */; reg++) {
		if (!have_local_reg(reg))
			db_printf("?");
		else {
			unsigned value = saved_reg_value(reg);
			db_printf("%s%x", hex_value_needs_0x(value) ? 
				  "0x" : "", value);
		}
		if (reg == last_arg)
			break;
		else
			db_printf(", ");
	}
	db_printf(")");
d488 2
a489 27
	unsigned flags;
	union instruction instruction; 

	/*
	 * Delayed branches are most common... look two instructions before
	 * where we were going to return to to see if it's a delayed branch.
	 */
	if (!db_trace_get_val(return_to - 8, &instruction.rawbits))
		return JUMP_SOURCE_IS_BAD;
	flags = m88k_instruction_info(instruction.rawbits);

	if ((flags & FLOW_CTRL) && (flags & DELAYED) && (flags & (JSR|BSR))) {
		if (flags & JSR)
			return JUMP_SOURCE_IS_OK; /* have to assume it's correct */
		/* calculate the offset */
		if (br_dest(return_to - 8, instruction) == jump_to)
			return JUMP_SOURCE_IS_OK; /* exactamundo! */
		else
			return JUMP_SOURCE_IS_UNLIKELY;	/* seems wrong */
	}

	/*
	 * Try again, looking for a non-delayed jump one back.
	 */
	if (!db_trace_get_val(return_to - 4, &instruction.rawbits))
		return JUMP_SOURCE_IS_BAD;
	flags = m88k_instruction_info(instruction.rawbits);
d491 34
a524 9
	if ((flags & FLOW_CTRL) && !(flags & DELAYED) && (flags & (JSR|BSR))) {
		if (flags & JSR)
			return JUMP_SOURCE_IS_OK; /* have to assume it's correct */
		/* calculate the offset */
		if (br_dest(return_to - 4, instruction) == jump_to)
			return JUMP_SOURCE_IS_OK; /* exactamundo! */
		else
			return JUMP_SOURCE_IS_UNLIKELY;	/* seems wrong */
	}
d526 1
a526 1
	return JUMP_SOURCE_IS_UNLIKELY;
d557 40
a596 21
	db_sym_t proc;
	unsigned offset_from_proc;
	unsigned instructions_to_search;
	unsigned check_addr;
	unsigned function_addr;	    /* start of function */
	unsigned r31 = *stack;	    /* the r31 of the function */
	unsigned inst;		    /* text of an instruction */
	unsigned ret_addr;	    /* address to which we return */
	unsigned tried_to_save_r1 = 0;

#ifdef TRACE_DEBUG
	if (DEBUGGING_ON)
		db_printf("\n>>>stack_decode(addr=%x, stack=%x)\n",
			  addr, *stack);
#endif

	/* get what we hope will be the db_sym_t for the function name */
	proc = db_search_symbol(addr, DB_STGY_PROC, &offset_from_proc);
	if (offset_from_proc == addr) /* i.e. no symbol found */
		proc = DB_SYM_NULL;

d598 2
a599 3
	 * Somehow, find the start of this function.
	 * If we found a symbol above, it'll have the address.
	 * Otherwise, we've got to search for it....
d601 4
a604 18
	if (proc != DB_SYM_NULL) {
		char *names;
		db_symbol_values(proc, &names, &function_addr);
		if (names == 0)
			return 0;
#ifdef TRACE_DEBUG
		if (DEBUGGING_ON) db_printf("name %s address 0x%x\n",
					    names, function_addr);
#endif
	} else {
		int instructions_to_check = 400;
		/*
		 * hmm - unable to find symbol. Search back
		 * looking for a function prolog.
		 */
		for (check_addr = addr; instructions_to_check-- > 0; check_addr -= 4) {
			if (!db_trace_get_val(check_addr, &inst))
				break;
d606 35
a640 71
			if (SUBU_R31_R31_IMM(inst)) {
#if 0
				/*
				 * If the next instruction is "st r1, r31, ####"
				 * then we can feel safe we have the start of
				 * a function.
				 */
				if (!db_trace_get_val(check_addr + 4, &inst))
					continue;
				if (ST_R1_R31_IMM(instr))
					break; /* sucess */
#else
				/*
				 * Latest GCC optimizer is just too good... the store
				 * of r1 might come much later... so we'll have to
				 * settle for just the "subr r31, r31, ###" to mark
				 * the start....
				 */
				break;
#endif
			}
			/*
			 * if we come across a [jmp r1] or [jmp.n r1] assume we have hit
			 * the previous functions epilogue and stop our search.
			 * Since we know we would have hit the "subr r31, r31" if it was
			 * right in front of us, we know this doesn't have one so
			 * we just return failure....
			 */
			if (JMP_R1(inst) || JMPN_R1(inst)) {
#ifdef TRACE_DEBUG
				if (DEBUGGING_ON)
					db_printf("ran into a [jmp r1] at %x (addr=%x)\n",
						  check_addr, addr);
#endif
				return 0;
			}
		}
		if (instructions_to_check < 0) {
#ifdef TRACE_DEBUG
			if (DEBUGGING_ON)
				db_printf("couldn't find func start (addr=%x)\n", addr);
#endif
			return 0; /* bummer, couldn't find it */
		}
		function_addr = check_addr;
	}

	/*
	 * We now know the start of the function (function_addr).
	 * If we're stopped right there, or if it's not a
	 *		subu r31, r31, ####
	 * then we're done.
	 */
	if (addr == function_addr) {
#ifdef TRACE_DEBUG
		if (DEBUGGING_ON) db_printf("at start of func\n");
#endif
		return 0;
	}
	if (!db_trace_get_val(function_addr, &inst)) {
#ifdef TRACE_DEBUG
		if (DEBUGGING_ON) db_printf("couldn't read %x at line %d\n",
					    function_addr, __LINE__);
#endif
		return 0;
	}
	SHOW_INSTRUCTION(function_addr, inst, "start of function: ");
	if (!SUBU_R31_R31_IMM(inst)) {
#ifdef TRACE_DEBUG
		if (DEBUGGING_ON) db_printf("<not subu,r31,r31,imm>\n");
#endif
d642 1
d644 36
d681 2
a682 2
	/* add the size of this frame to the stack (for the next frame) */
	*stack += IMM16VAL(inst);
d684 16
a699 9
	/*
	 * Search from the beginning of the function (funstart) to where we are
	 * in the function (addr) looking to see what kind of registers have
	 * been saved on the stack.
	 *
	 * We'll stop looking before we get to ADDR if we hit a branch.
	 */
	clear_local_saved_regs();
	check_addr = function_addr + 4;	/* we know the first inst isn't a store */
d701 7
a707 47
	for (instructions_to_search = (addr - check_addr)/sizeof(long);
	    instructions_to_search-- > 0;
	    check_addr += 4) {
		union instruction instruction;
		unsigned flags;

		/* read the instruction */
		if (!db_trace_get_val(check_addr, &instruction.rawbits)) {
#ifdef TRACE_DEBUG
			if (DEBUGGING_ON) db_printf("couldn't read %x at line %d\n",
						    check_addr, __LINE__);
#endif
			break;
		}

		SHOW_INSTRUCTION(check_addr, instruction.rawbits, "prolog: ");

		/* find out the particulars about this instruction */
		flags = m88k_instruction_info(instruction.rawbits);

		/* if a store to something off the stack pointer, note the value */
		if ((flags & STORE) && instruction.diatic.s1 ==	/*stack pointer*/31) {
			unsigned value;
			if (!have_local_reg(instruction.diatic.d)) {
				if (instruction.diatic.d == 1)
					tried_to_save_r1 = r31 + instruction.diatic.i16 ;
				if (db_trace_get_val(r31 + instruction.diatic.i16, &value))
					save_reg(instruction.diatic.d, value);
			}
			if ((flags & DOUBLE) && !have_local_reg(instruction.diatic.d + 1)) {
				if (instruction.diatic.d == 0)
					tried_to_save_r1 = r31+instruction.diatic.i16 +4;
				if (db_trace_get_val(r31+instruction.diatic.i16 +4, &value))
					save_reg(instruction.diatic.d + 1, value);
			}
		}

		/* if an inst that kills D (and maybe D+1), note that */
		if (flags & TRASHES) {
			mark_reg_trashed(instruction.diatic.d);
			if (flags & DOUBLE)
				mark_reg_trashed(instruction.diatic.d + 1);
		}

		/* if a flow control instruction, stop now (or next if delayed) */
		if ((flags & FLOW_CTRL) && instructions_to_search != 0)
			instructions_to_search = (flags & DELAYED) ? 1 : 0;
d710 1
a710 13
	/*
	 * If we didn't save r1 at some point, we're hosed.
	 */
	if (!have_local_reg(1)) {
		if (tried_to_save_r1) {
			db_printf("    <return value of next fcn unreadable in %08x>\n",
				  tried_to_save_r1);
		}
#ifdef TRACE_DEBUG
		if (DEBUGGING_ON) db_printf("didn't save r1\n");
#endif
		return 0;
	}
d712 2
a713 1
	ret_addr = saved_reg_value(1);
d715 43
a757 5
#ifdef TRACE_DEBUG
	if (DEBUGGING_ON)
		db_printf("Return value is = %x, function_addr is %x.\n",
			  ret_addr, function_addr);
#endif
d759 1
a759 12
	/*
	 * In support of this, continuation.s puts the low bit on the
	 * return address for continuations (the return address will never
	 * be used, so it's ok to do anything you want to it).
	 */
	if (ret_addr & 1) {
		note = "<<can not trace past a continuation>>";
		ret_addr = 0;
	} else if (ret_addr != 0x00) {
		switch (is_jump_source_ok(ret_addr, function_addr)) {
		case JUMP_SOURCE_IS_OK:
			break; /* excellent */
d761 24
a784 5
		case JUMP_SOURCE_IS_BAD:
#ifdef TRACE_DEBUG
			if (DEBUGGING_ON) db_printf("jump is bad\n");
#endif
			return 0; /* bummer */
d786 3
a788 4
		case JUMP_SOURCE_IS_UNLIKELY:
			next_address_likely_wrong = 1;;
			break;
		}
d790 1
d792 1
a792 1
	return ret_addr;
d798 54
a851 6
	unsigned stack;
	unsigned depth=1;
	unsigned where;
	unsigned ft;
	unsigned pair[2];
	int i;
d853 2
d856 4
a859 5
	 * Frame_is_sane returns:
	 *   1 if regs seems to be a reasonable kernel exception frame.
	 *   2 if regs seems to be a reasonable user exception frame
	 *      (in the current task).
	 *   0 if this looks like neither.
d861 21
a881 3
	if (ft = frame_is_sane(regs), ft == 0) {
		db_printf("Register frame 0x%x is suspicous; skipping trace\n", regs);
		return;
d884 2
a885 3
	/* if user space and no user space trace specified, puke */
	if (ft == 2 && !(trace_flags & TRACE_USER_FLAG))
		return;
a886 12
	/* fetch address */
	/* use sxip if valid, otherwise try snip or sfip */
	if (cputyp == CPU_88110) {
		where = regs->exip & ~3;
	} else {
		where = ((regs->sxip & 2) ? regs->sxip :
			 ((regs->snip & 2) ? regs->snip :
			  regs->sfip) ) & ~3;
	}
	stack = regs->r[31];
	db_printf("stack base = 0x%x\n", stack);
	db_printf("(0) "); /*depth of trace */
d888 1
a888 1
		db_printf("%08x ", where);
d890 4
a893 11
	clear_global_saved_regs();

	/* see if this routine had a stack frame */
	if ((where=stack_decode(where, &stack))==0) {
		where = regs->r[1];
		db_printf("(stackless)");
	} else {
		print_args();
		if (trace_flags & TRACE_SHOWFRAME_FLAG)
			db_printf(" [frame 0x%x]", stack);
	}
d896 2
a897 2
		db_printf("   %s\n", note);
		note = 0;
d899 1
d901 1
a901 47
	do {
		/*
		 * If requested, show preserved registers at the time
		 * the next-shown call was made. Only registers known to have
		 * changed from the last exception frame are shown, as others
		 * can be gotten at by looking at the exception frame.
		 */
		if (trace_flags & TRACE_SHOWCALLPRESERVED_FLAG) {
			int r, title_printed = 0;

			for (r = FIRST_CALLPRESERVED_REG; r<=LAST_CALLPRESERVED_REG; r++) {
				if (have_global_reg(r)) {
					unsigned value = saved_reg_value(r);
					if (title_printed == 0) {
						title_printed = 1;
						db_printf("[in next func:");
					}
					if (value == 0)
						db_printf(" r%d", r);
					else if (value <= 9)
						db_printf(" r%d=%x", r, value);
					else
						db_printf(" r%d=x%x", r, value);
				}
			}
			if (title_printed)
				db_printf("]\n");
		}

		db_printf("(%d)%c", depth++, next_address_likely_wrong ? '?':' ');
		next_address_likely_wrong = 0;

		if (trace_flags & TRACE_SHOWADDRESS_FLAG)
			db_printf("%08x ", where);
		db_printsym(where, DB_STGY_PROC);
		where = stack_decode(where, &stack);
		print_args();
		if (trace_flags & TRACE_SHOWFRAME_FLAG)
			db_printf(" [frame 0x%x]", stack);
		db_printf("\n");
		if (note) {
			db_printf("   %s\n", note);
			note = 0;
		}
	} while (where);

	/* try to trace back over trap/exception */
d903 2
a904 2
	stack &= ~7; /* double word aligned */
	/* take last top of stack, and try to find an exception frame near it */
d906 1
a906 1
	i = FRAME_PLAY;
d908 1
a908 1
#ifdef TRACE_DEBUG
d910 2
a911 60
		db_printf("(searching for exception frame at 0x%x)\n", stack);
#endif

	while (i) {
		/*
		 * On the stack, a pointer to the exception frame is written
		 * in two adjacent words. In the case of a fault from the kernel,
		 * this should point to the frame right above them:
		 *
		 * Exception Frame Top
		 * ..
		 * Exception Frame Bottom  <-- frame addr
		 * frame addr
		 * frame addr		<-- stack pointer
		 *
		 * In the case of a fault from user mode, the top of stack
		 * will just have the address of the frame
		 * replicated twice.
		 *
		 * frame addr		<-- top of stack
		 * frame addr
		 *
		 * Here we are just looking for kernel exception frames.
		 */

		if (badwordaddr((vm_offset_t)stack) ||
		    badwordaddr((vm_offset_t)(stack+4)))
			break;

		db_read_bytes((vm_offset_t)stack, 2*sizeof(int), (char*)pair);

		/* the pairs should match and equal stack+8 */
		if (pair[0] == pair[1]) {
			if (pair[0] != stack+8) {
				/*
				if (!badwordaddr((vm_offset_t)pair[0]) && (pair[0]!=0))
				db_printf("stack_trace:found pair 0x%x but != to stack+8\n",
				pair[0]);
				*/
				
			}

			else if (frame_is_sane((db_regs_t*)pair[0])) {
				db_regs_t *frame = (db_regs_t *) pair[0];
				char *cause = m88k_exception_name(frame -> vector);

				db_printf("-------------- %s [EF: 0x%x] -------------\n",
					  cause, frame);
				db_stack_trace_cmd2(frame);
				return;
			}
#ifdef TRACE_DEBUG
			else if (DEBUGGING_ON)
				db_printf("pair matched, but frame at 0x%x looks insane\n",
					  stack+8);
#endif
		}
		stack += 8;
		i--;
	}
d913 2
d916 18
a933 4
	 * If we go here, crawling back on the stack failed to find us
	 * a previous exception frame. Look for a user frame pointer
	 * pointed to by a word 8 bytes off of the top of the stack
	 * if the "u" option was specified.
a934 2
	if (trace_flags & TRACE_USER_FLAG) {
		db_regs_t *user;
d936 68
a1003 21
		/* Make sure we are back on the right page */
		stack -= 4*FRAME_PLAY;
		stack = stack & ~(KERNEL_STACK_SIZE-1);	/* point to the bottom */
		stack += KERNEL_STACK_SIZE - 8;

		if (badwordaddr((vm_offset_t)stack) ||
		    badwordaddr((vm_offset_t)stack))
			return;

		db_read_bytes((vm_offset_t)stack, 2*sizeof(int), (char*)pair);
		if (pair[0] != pair[1])
			return;

		/* have a hit */
		user = *((db_regs_t **) stack);

		if (frame_is_sane(user) == 2) {
			db_printf("---------------- %s [EF : 0x%x] -------------\n",
				  m88k_exception_name(user->vector), user);
			db_stack_trace_cmd2(user);
		}
d1005 1
d1015 5
a1019 4
db_stack_trace_cmd(db_regs_t *addr,
		   int have_addr,
		   db_expr_t count,
		   char *modif)
d1021 73
a1093 23
	enum {
		Default, Stack, Proc, Frame
	} style = Default;
	db_regs_t frame; /* a m88100_saved_state */
	db_regs_t *regs;
	union {
		db_regs_t *frame;
		struct proc *proc;
		unsigned num;
	} arg;
	arg.frame = addr;

	trace_flags = 0; /* flags will be set via modifers */

	while (modif && *modif) {
		switch (*modif++) {
		case 'd':
#ifdef TRACE_DEBUG
			trace_flags |= TRACE_DEBUG_FLAG;
#else
			db_printtf("<debug trace not compiled in, ignoring>\n");
#endif
			break;
d1095 10
a1104 23
		case 's': style = Stack  ; break;
		case 'f': style = Frame  ; break;
		case 'p': trace_flags |= TRACE_SHOWCALLPRESERVED_FLAG; break;
		case 'a': trace_flags |= TRACE_SHOWADDRESS_FLAG; break;
		case 'F': trace_flags |= TRACE_SHOWFRAME_FLAG; break;
		case 'u': trace_flags |= TRACE_USER_FLAG; break;
		default:
			db_printf("unknown trace modifier [%c]\n", modif[-1]);
			/*FALLTHROUGH*/
		case 'h':
			db_printf("usage: trace/[MODIFIER]  [ARG]\n");
			db_printf("  u = include user trace\n");
			db_printf("  F = print stack frames\n");
			db_printf("  a = show return addresses\n");
			db_printf("  p = show call-preserved registers\n");
			db_printf("  s = ARG is a stack pointer\n");
			db_printf("  f = ARG is a frame pointer\n");
#ifdef TRACE_DEBUG
			db_printf("  d = trace-debugging output\n");
#endif
			return;
		}
	}
d1106 13
a1118 2
	if (!have_addr && style != Default) {
		db_printf("expecting argument with /s or /f\n");
d1120 32
a1152 2
	if (have_addr && style == Default)
		style = Proc;
d1154 11
a1164 86
	switch (style) {
	case Default:
		regs = DDB_REGS;
		break;
	case Frame:
		regs = arg.frame;
		break;
	case Proc:
		break;
	case Stack:
		{
			unsigned val1, val2, sxip;
			unsigned ptr;
			bzero((void*)&frame, sizeof(frame));
#define REASONABLE_FRAME_DISTANCE 2048

			/*
			 * We've got to find the top of a stack frame so we can get both
			 * a PC and and real SP.
			 */
			for (ptr = arg.num;/**/; ptr += 4) {
				/* Read a word from the named stack */
				if (db_trace_get_val(ptr, &val1) == 0) {
					db_printf("can't read from %x, aborting.\n", ptr);
					return;
				}

				/*
				 * See if it's a frame pointer.... if so it will be larger than
				 * the address it was taken from (i.e. point back up the stack)
				 * and we'll be able to read where it points.
				 */
				if (val1 <= ptr ||
				    (val1 & 3)  ||
				    val1 > (ptr + REASONABLE_FRAME_DISTANCE))
					continue;

				/* peek at the next word to see if it could be a return address */
				if (db_trace_get_val(ptr, &sxip) == 0) {
					db_printf("can't read from %x, aborting.\n", ptr);
					return;
				}
				if (sxip == 0 || !db_trace_get_val(sxip, &val2))
					continue;

				if (db_trace_get_val(val1, &val2) == 0) {
					db_printf("can't read from %x, aborting.\n", val1);
					continue;
				}

				/*
				 * The value we've just read will be either another frame pointer,
				 * or the start of another exception frame.
				 */
				if (
#ifdef JEFF_DEBUG
				   val2 == 0
#else
				   val2 == 0x12345678
#endif
				   && db_trace_get_val(val1-4, &val2) && val2 == val1
				   && db_trace_get_val(val1-8, &val2) && val2 == val1) {
					/* we've found a frame, so the stack must have been good */
					db_printf("%x looks like a frame, accepting %x\n",val1,ptr);
					break;
				}

				if (val2 > val1 && (val2 & 3) == 0) {
					/* well, looks close enough to be another frame pointer */
					db_printf("*%x = %x looks like a stack frame pointer, accepting %x\n", val1, val2, ptr);
					break;
				}
			}
                        frame.r[31] = ptr;
			frame.epsr = 0x800003f0U;
			if (cputyp != CPU_88110) {
				frame.sxip = sxip | 2;
				frame.snip = frame.sxip + 4;
				frame.sfip = frame.snip + 4;
			}
			db_printf("[r31=%x, %sxip=%x]\n", frame.r[31],
				  cputyp == CPU_88110 ? "e" : "s", frame.sxip);
			regs = &frame;
		}
	}
	db_stack_trace_cmd2(regs);
a1165 1

@


1.11.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.11.2.1 2002/01/31 22:55:17 niklas Exp $	*/
d98 6
a103 6
extern void db_read_bytes(vm_offset_t addr, int size, char *data);
int frame_is_sane(db_regs_t *regs);
char *m88k_exception_name(unsigned vector);
unsigned db_trace_get_val(vm_offset_t addr, unsigned *ptr);
void db_stack_trace_print(db_regs_t *addr, int have_addr,
    db_expr_t count, char *modif, int (*pr)(const char *, ...));
d384 1
a384 1
		db_read_bytes(addr, 4, (char *)ptr);
d562 1
a562 1
stack_decode(unsigned addr, unsigned *stack, int (*pr)(const char *, ...))
d576 1
a576 1
		(*pr)("\n>>>stack_decode(addr=%x, stack=%x)\n",
d596 1
a596 1
		if (DEBUGGING_ON) (*pr)("name %s address 0x%x\n",
d640 1
a640 1
					(*pr)("ran into a [jmp r1] at %x (addr=%x)\n",
d649 1
a649 1
				(*pr)("couldn't find func start (addr=%x)\n", addr);
d664 1
a664 1
		if (DEBUGGING_ON) (*pr)("at start of func\n");
d670 1
a670 1
		if (DEBUGGING_ON) (*pr)("couldn't read %x at line %d\n",
d678 1
a678 1
		if (DEBUGGING_ON) (*pr)("<not subu,r31,r31,imm>\n");
d705 1
a705 1
			if (DEBUGGING_ON) (*pr)("couldn't read %x at line %d\n",
d750 1
a750 1
			(*pr)("    <return value of next fcn unreadable in %08x>\n",
d754 1
a754 1
		if (DEBUGGING_ON) (*pr)("didn't save r1\n");
d763 1
a763 1
		(*pr)("Return value is = %x, function_addr is %x.\n",
d782 1
a782 1
			if (DEBUGGING_ON) (*pr)("jump is bad\n");
d796 1
a796 1
db_stack_trace_cmd2(db_regs_t *regs, int (*pr)(const char *, ...))
d813 1
a813 1
		(*pr)("Register frame 0x%x is suspicous; skipping trace\n", regs);
d831 2
a832 2
	(*pr)("stack base = 0x%x\n", stack);
	(*pr)("(0) "); /*depth of trace */
d834 2
a835 2
		(*pr)("%08x ", where);
	db_printsym(where, DB_STGY_PROC, pr);
d839 1
a839 1
	if ((where=stack_decode(where, &stack, pr))==0) {
d841 1
a841 1
		(*pr)("(stackless)");
d845 1
a845 1
			(*pr)(" [frame 0x%x]", stack);
d847 1
a847 1
	(*pr)("\n");
d849 1
a849 1
		(*pr)("   %s\n", note);
d868 1
a868 1
						(*pr)("[in next func:");
d871 1
a871 1
						(*pr)(" r%d", r);
d873 1
a873 1
						(*pr)(" r%d=%x", r, value);
d875 1
a875 1
						(*pr)(" r%d=x%x", r, value);
d879 1
a879 1
				(*pr)("]\n");
d882 1
a882 1
		(*pr)("(%d)%c", depth++, next_address_likely_wrong ? '?':' ');
d886 3
a888 3
			(*pr)("%08x ", where);
		db_printsym(where, DB_STGY_PROC, pr);
		where = stack_decode(where, &stack, pr);
d891 2
a892 2
			(*pr)(" [frame 0x%x]", stack);
		(*pr)("\n");
d894 1
a894 1
			(*pr)("   %s\n", note);
d908 1
a908 1
		(*pr)("(searching for exception frame at 0x%x)\n", stack);
d937 1
a937 1
		db_read_bytes((vm_offset_t)stack, 2*sizeof(int), (char *)pair);
d944 1
a944 1
				(*pr)("stack_trace:found pair 0x%x but != to stack+8\n",
d954 1
a954 1
				(*pr)("-------------- %s [EF: 0x%x] -------------\n",
d956 1
a956 1
				db_stack_trace_cmd2(frame, pr);
d961 1
a961 1
				(*pr)("pair matched, but frame at 0x%x looks insane\n",
d987 1
a987 1
		db_read_bytes((vm_offset_t)stack, 2*sizeof(int), (char *)pair);
d995 1
a995 1
			(*pr)("---------------- %s [EF : 0x%x] -------------\n",
d997 1
a997 1
			db_stack_trace_cmd2(user, pr);
d1009 1
a1009 1
db_stack_trace_print(db_regs_t *addr,
d1012 1
a1012 2
		   char *modif,
		   int (*pr)(const char *, ...))
d1045 1
a1045 1
			(*pr)("unknown trace modifier [%c]\n", modif[-1]);
d1048 7
a1054 7
			(*pr)("usage: trace/[MODIFIER]  [ARG]\n");
			(*pr)("  u = include user trace\n");
			(*pr)("  F = print stack frames\n");
			(*pr)("  a = show return addresses\n");
			(*pr)("  p = show call-preserved registers\n");
			(*pr)("  s = ARG is a stack pointer\n");
			(*pr)("  f = ARG is a frame pointer\n");
d1056 1
a1056 1
			(*pr)("  d = trace-debugging output\n");
d1063 1
a1063 1
		(*pr)("expecting argument with /s or /f\n");
d1082 1
a1082 1
			bzero((void *)&frame, sizeof(frame));
d1092 1
a1092 1
					(*pr)("can't read from %x, aborting.\n", ptr);
d1108 1
a1108 1
					(*pr)("can't read from %x, aborting.\n", ptr);
d1115 1
a1115 1
					(*pr)("can't read from %x, aborting.\n", val1);
d1132 1
a1132 1
					(*pr)("%x looks like a frame, accepting %x\n",val1,ptr);
d1138 1
a1138 1
					(*pr)("*%x = %x looks like a stack frame pointer, accepting %x\n", val1, val2, ptr);
d1149 1
a1149 1
			(*pr)("[r31=%x, %sxip=%x]\n", frame.r[31],
d1154 1
a1154 1
	db_stack_trace_cmd2(regs, pr);
@


1.11.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d619 1
a619 1
					break; /* success */
@


1.10
log
@Support for MVME197 completed.  Fix SPL defs.
@
text
@d41 1
a41 1
	unsigned rawbits;
d43 44
a86 44
	struct {
		unsigned int    : 5;
		unsigned int   n: 1;
		signed int   d26:26;
	} br;

	struct {
		unsigned int      : 4;
		unsigned int isbb1: 1;	/* isbb1==0 means bb0, isbb1==1 means bb1 */
		unsigned int   n  : 1;
		unsigned int  b5  : 5;
		unsigned int  s1  : 5;
		signed   int  d16 :16;
	} bb; /* bcnd too, except "isbb1" makes no sense for bcnd */

	struct {
		unsigned int      : 6;
		unsigned int  b5  : 5;
		unsigned int  s1  : 5;
		unsigned int      : 7;
		unsigned int vec9 : 9;
	} tb; /* tcnd too */

	struct {
		unsigned int      :21;
		unsigned int    n : 1;
		unsigned int      : 5;
		unsigned int   s2 : 5;
	} jump;	/* jmp, jsr */

	struct {
		unsigned int      : 6;
		unsigned int    d : 5;
		unsigned int   s1 : 5;
		unsigned int  i16 :16;
	} diatic;   /* general reg/reg/i16 instructions */

	struct {
		unsigned int      : 6;
		unsigned int    d : 5;
		unsigned int   s1 : 5;
		unsigned int      :11;
		unsigned int   s2 : 5;
	} triatic;  /* general reg/reg/reg instructions */
d103 1
a103 1
			     db_expr_t count, char *modif));
d149 4
a152 3
db_setf_regs(struct db_variable      *vp,
	     db_expr_t               *valuep,
	     int                     op)		    /* read/write */
d154 1
a154 1
	register int   *regp = (int *) ((char *) DDB_REGS + (int) (vp->valuep));
d156 4
a159 4
	if (op == DB_VAR_GET)
		*valuep = *regp;
	else if (op == DB_VAR_SET)
		*regp = *valuep;
d161 1
a161 1
	return (0); /* silence warning */
d167 17
a183 17
	N("r1", r[1]),     N("r2", r[2]),    N("r3", r[3]),    N("r4", r[4]),
	N("r5", r[5]),     N("r6", r[6]),    N("r7", r[7]),    N("r8", r[8]),
	N("r9", r[9]),     N("r10", r[10]),  N("r11", r[11]),  N("r12", r[12]),
	N("r13", r[13]),   N("r14", r[14]),  N("r15", r[15]),  N("r16", r[16]),
	N("r17", r[17]),   N("r18", r[18]),  N("r19", r[19]),  N("r20", r[20]),
	N("r21", r[21]),   N("r22", r[22]),  N("r23", r[23]),  N("r24", r[24]),
	N("r25", r[25]),   N("r26", r[26]),  N("r27", r[27]),  N("r28", r[28]),
	N("r29", r[29]),   N("r30", r[30]),  N("r31", r[31]),  N("epsr", epsr),
	N("sxip", sxip),   N("snip", snip),  N("sfip", sfip),  N("ssbr", ssbr),
	N("dmt0", dmt0),   N("dmd0", dmd0),  N("dma0", dma0),  N("dmt1", dmt1),
	N("dmd1", dmd1),   N("dma1", dma1),  N("dmt2", dmt2),  N("dmd2", dmd2),
	N("dma2", dma2),   N("fpecr", fpecr),N("fphs1", fphs1),N("fpls1", fpls1),
	N("fphs2", fphs2), N("fpls2", fpls2),N("fppt", fppt),  N("fprh", fprh),
	N("fprl", fprl),   N("fpit", fpit),  N("fpsr", fpsr),  N("fpcr", fpcr),
	N("mask", mask), /* interrupt mask */
	N("mode", mode), /* interrupt mode */
	N("exvc", vector), /* exception vector */
d206 35
a240 36
	static struct {
		unsigned mask, value, flags;
	} *ptr, control[] = {
		/* runs in the same order as 2nd Ed 88100 manual Table 3-14 */
		{ 0xf0000000U, 0x00000000U, /* xmem */     TRASHES | STORE | LOAD},
		{ 0xec000000U, 0x00000000U, /* ld.d */     TRASHES | LOAD | DOUBLE},
		{ 0xe0000000U, 0x00000000U, /* load */     TRASHES | LOAD},
		{ 0xfc000000U, 0x20000000U, /* st.d */     STORE | DOUBLE},
		{ 0xf0000000U, 0x20000000U, /* store */    STORE},
		{ 0xc0000000U, 0x40000000U, /* arith */    TRASHES},
		{ 0xfc004000U, 0x80004000U, /* ld cr */    TRASHES},
		{ 0xfc004000U, 0x80000000U, /* st cr */    0},
		{ 0xfc008060U, 0x84000000U, /* f */        TRASHES},
		{ 0xfc008060U, 0x84000020U, /* f.d */      TRASHES | DOUBLE},
		{ 0xfc000000U, 0xcc000000U, /* bsr.n */    FLOW_CTRL | DELAYED | BSR},
		{ 0xfc000000U, 0xc8000000U, /* bsr */      FLOW_CTRL | BSR},
		{ 0xe4000000U, 0xc4000000U, /* br/bb.n */  FLOW_CTRL | DELAYED},
		{ 0xe4000000U, 0xc0000000U, /* br/bb */    FLOW_CTRL},
		{ 0xfc000000U, 0xec000000U, /* bcnd.n */   FLOW_CTRL | DELAYED},
		{ 0xfc000000U, 0xe8000000U, /* bcnd */     FLOW_CTRL},
		{ 0xfc00c000U, 0xf0008000U, /* bits */     TRASHES},
		{ 0xfc00c000U, 0xf000c000U, /* trap */     0},
		{ 0xfc00f0e0U, 0xf4002000U, /* st */       0},
		{ 0xfc00cce0U, 0xf4000000U, /* ld.d */     TRASHES | DOUBLE},
		{ 0xfc00c0e0U, 0xf4000000U, /* ld */       TRASHES},
		{ 0xfc00c0e0U, 0xf4004000U, /* arith */    TRASHES},
		{ 0xfc00c3e0U, 0xf4008000U, /* bits */     TRASHES},
		{ 0xfc00ffe0U, 0xf400cc00U, /* jsr.n */    FLOW_CTRL | DELAYED | JSR},
		{ 0xfc00ffe0U, 0xf400c800U, /* jsr */      FLOW_CTRL | JSR},
		{ 0xfc00ffe0U, 0xf400c400U, /* jmp.n */    FLOW_CTRL | DELAYED},
		{ 0xfc00ffe0U, 0xf400c000U, /* jmp */      FLOW_CTRL},
		{ 0xfc00fbe0U, 0xf400e800U, /* ff */       TRASHES},
		{ 0xfc00ffe0U, 0xf400f800U, /* tbnd */     0},
		{ 0xfc00ffe0U, 0xf400fc00U, /* rte */      FLOW_CTRL},
		{ 0xfc000000U, 0xf8000000U, /* tbnd */     0},
	};
d242 5
a246 5
	for (ptr = &control[0]; ptr < &control[ctrl_count]; ptr++)
		if ((instruction & ptr->mask) == ptr->value)
			return ptr->flags;
	SHOW_INSTRUCTION(0, instruction, "bad m88k_instruction_info");
	return 0;
d252 4
a255 4
	int i;
	unsigned last = 0;
	unsigned char c; 
	unsigned have_a_hex_digit = 0;
d257 2
a258 2
	if (value <= 9)
		return 0;
d260 13
a272 13
	for (i = 0; i < 8; i++) {
		c = value & 0xf;
		value >>= 4;
		if (c)
			last = c;
		if (c > 9)
			have_a_hex_digit = 1;
	}
	if (have_a_hex_digit == 0)
		return 1;
	if (last > 9)
		return 1;
	return 0;
d275 1
d286 3
a288 5
	/* no good if we can't read the whole frame */
	if (badwordaddr((vm_offset_t)regs) || badwordaddr((vm_offset_t)&regs->mode)){
		db_printf("[WARNING: frame at 0x%x : unreadable]\n", regs);
		return 0;
	}
d291 4
a294 6
	/* disabled for now  -- see fpu_enable in luna88k/eh.s */
	/* r0 must be 0 (obviously) */
	if (regs->r[0] != 0){
		db_printf("[WARNING: frame at 0x%x : r[0] != 0]\n", regs);
		return 0;
	}
d297 3
a299 5
	/* stack sanity ... r31 must be nonzero, but must be word aligned */
	if (regs->r[31] == 0 || (regs->r[31] & 3) != 0) {
		db_printf("[WARNING: frame at 0x%x : r[31] == 0 or not word aligned]\n", regs);
		return 0;
	}
d301 1
a301 2
	if (cputyp != CPU_88110) {
		/* sxip is reasonable */
d303 2
a304 2
		if ((regs->sxip & 1) == 1)
			return 0;
d306 6
a311 7
		/* snip is reasonable */
		if ((regs->snip & 3) != 2)
			return 0;
		/* sfip is reasonable */
		if ((regs->sfip & 3) != 2)
			return 0;
	}
d313 16
a328 15
	/* epsr sanity */
	if ((regs->epsr & PSR_MODE)) { /* kernel mode */
		if (regs->epsr & PSR_BO)
			db_printf("[WARNING: byte order in kernel frame at %x "
				  "is little-endian!]\n", regs);
		return 1;
	}
	if (!(regs->epsr & PSR_MODE)) { /* user mode */
		if (regs->epsr & PSR_BO)
			db_printf("[WARNING: byte order in user frame at %x "
				  "is little-endian!]\n", regs);
		return 2;
	}
	db_printf("[WARNING: not an exception frame?]\n");
	return 0;
d334 1
a334 1
	switch (vector) {
a346 1
	case  11: return "Non Maskable Interrupt";
d356 1
a356 1
	}
d366 16
a381 16
	label_t db_jmpbuf;
	label_t *prev = db_recover;
	boolean_t old_quiet_db_read_bytes = quiet_db_read_bytes;

	quiet_db_read_bytes = 1;

	if (setjmp((db_recover = &db_jmpbuf)) != 0) {
		db_recover = prev;
		quiet_db_read_bytes = old_quiet_db_read_bytes;
		return 0;
	} else {
		db_read_bytes(addr, 4, (char*)ptr);
		db_recover = prev;
		quiet_db_read_bytes = old_quiet_db_read_bytes;
		return 1;
	}
d385 5
a389 5
#define FIRST_CALLPRESERVED_REG	14
#define LAST_CALLPRESERVED_REG	29
#define FIRST_ARG_REG		2
#define LAST_ARG_REG		9
#define RETURN_VAL_REG		1
d404 1
a404 1
	if (trashed_list & reg_bit(reg)) {
d406 1
a406 1
		if (DEBUGGING_ON) db_printf("<trashed>\n");
d408 5
a412 5
		return;	/* don't save trashed registers */
	}
	saved_reg[(reg%32)] = value;
	global_saved_list |= reg_bit(reg);
	local_saved_list  |= reg_bit(reg);
d431 1
a431 1
	int reg, last_arg;
d433 24
a456 23
	/* find the highest argument register saved */
	for (last_arg = LAST_ARG_REG; last_arg >= FIRST_ARG_REG; last_arg--)
		if (have_local_reg(last_arg))
			break;
	if (last_arg < FIRST_ARG_REG)
		return;	/* none were saved */

	db_printf("(");

	/* print each one, up to the highest */
	for (reg = FIRST_ARG_REG; /*nothing */; reg++) {
		if (!have_local_reg(reg))
			db_printf("?");
		else {
			unsigned value = saved_reg_value(reg);
			db_printf("%s%x", hex_value_needs_0x(value)  ? "0x" : "", value);
		}
		if (reg == last_arg)
			break;
		else
			db_printf(", ");
	}
	db_printf(")");
d488 2
a489 10
	unsigned flags;
	union instruction instruction; 

	/*
	 * Delayed branches are most common... look two instructions before
	 * where we were going to return to to see if it's a delayed branch.
	 */
	if (!db_trace_get_val(return_to - 8, &instruction.rawbits))
		return JUMP_SOURCE_IS_BAD;
	flags = m88k_instruction_info(instruction.rawbits);
d491 34
a524 16
	if ((flags & FLOW_CTRL) && (flags & DELAYED) && (flags & (JSR|BSR))) {
		if (flags & JSR)
			return JUMP_SOURCE_IS_OK; /* have to assume it's correct */
		/* calculate the offset */
		if (br_dest(return_to - 8, instruction) == jump_to)
			return JUMP_SOURCE_IS_OK; /* exactamundo! */
		else
			return JUMP_SOURCE_IS_UNLIKELY;	/* seems wrong */
	}

	/*
	 * Try again, looking for a non-delayed jump one back.
	 */
	if (!db_trace_get_val(return_to - 4, &instruction.rawbits))
		return JUMP_SOURCE_IS_BAD;
	flags = m88k_instruction_info(instruction.rawbits);
d526 1
a526 11
	if ((flags & FLOW_CTRL) && !(flags & DELAYED) && (flags & (JSR|BSR))) {
		if (flags & JSR)
			return JUMP_SOURCE_IS_OK; /* have to assume it's correct */
		/* calculate the offset */
		if (br_dest(return_to - 4, instruction) == jump_to)
			return JUMP_SOURCE_IS_OK; /* exactamundo! */
		else
			return JUMP_SOURCE_IS_UNLIKELY;	/* seems wrong */
	}

	return JUMP_SOURCE_IS_UNLIKELY;
d557 9
a565 9
	db_sym_t proc;
	unsigned offset_from_proc;
	unsigned instructions_to_search;
	unsigned check_addr;
	unsigned function_addr;	    /* start of function */
	unsigned r31 = *stack;	    /* the r31 of the function */
	unsigned inst;		    /* text of an instruction */
	unsigned ret_addr;	    /* address to which we return */
	unsigned tried_to_save_r1 = 0;
d568 3
a570 3
	if (DEBUGGING_ON)
		db_printf("\n>>>stack_decode(addr=%x, stack=%x)\n",
			  addr, *stack);
d573 24
a596 5
	/* get what we hope will be the db_sym_t for the function name */
	proc = db_search_symbol(addr, DB_STGY_PROC, &offset_from_proc);
	if (offset_from_proc == addr) /* i.e. no symbol found */
		proc = DB_SYM_NULL;

d598 2
a599 3
	 * Somehow, find the start of this function.
	 * If we found a symbol above, it'll have the address.
	 * Otherwise, we've got to search for it....
d601 4
a604 18
	if (proc != DB_SYM_NULL) {
		char *names;
		db_symbol_values(proc, &names, &function_addr);
		if (names == 0)
			return 0;
	#ifdef TRACE_DEBUG
		if (DEBUGGING_ON) db_printf("name %s address 0x%x\n",
					    names, function_addr);
	#endif
	} else {
		int instructions_to_check = 400;
		/*
		 * hmm - unable to find symbol. Search back
		 * looking for a function prolog.
		 */
		for (check_addr = addr; instructions_to_check-- > 0; check_addr -= 4) {
			if (!db_trace_get_val(check_addr, &inst))
				break;
d606 2
a607 1
			if (SUBU_R31_R31_IMM(inst)) {
d609 9
a617 9
				/*
				 * If the next instruction is "st r1, r31, ####"
				 * then we can feel safe we have the start of
				 * a function.
				 */
				if (!db_trace_get_val(check_addr + 4, &inst))
					continue;
				if (ST_R1_R31_IMM(instr))
					break; /* sucess */
d619 7
a625 7
				/*
				 * Latest GCC optimizer is just too good... the store
				 * of r1 might come much later... so we'll have to
				 * settle for just the "subr r31, r31, ###" to mark
				 * the start....
				 */
				break;
d627 9
a635 9
			}
			/*
			 * if we come across a [jmp r1] or [jmp.n r1] assume we have hit
			 * the previous functions epilogue and stop our search.
			 * Since we know we would have hit the "subr r31, r31" if it was
			 * right in front of us, we know this doesn't have one so
			 * we just return failure....
			 */
			if (JMP_R1(inst) || JMPN_R1(inst)) {
d637 3
a639 3
				if (DEBUGGING_ON)
					db_printf("ran into a [jmp r1] at %x (addr=%x)\n",
						  check_addr, addr);
d641 4
a644 4
				return 0;
			}
		}
		if (instructions_to_check < 0) {
d646 2
a647 2
			if (DEBUGGING_ON)
				db_printf("couldn't find func start (addr=%x)\n", addr);
d649 1
a649 3
			return 0; /* bummer, couldn't find it */
		}
		function_addr = check_addr;
d651 2
d654 7
a660 7
	/*
	 * We now know the start of the function (function_addr).
	 * If we're stopped right there, or if it's not a
	 *		subu r31, r31, ####
	 * then we're done.
	 */
	if (addr == function_addr) {
d662 1
a662 1
		if (DEBUGGING_ON) db_printf("at start of func\n");
d664 3
a666 3
		return 0;
	}
	if (!db_trace_get_val(function_addr, &inst)) {
d668 2
a669 2
		if (DEBUGGING_ON) db_printf("couldn't read %x at line %d\n",
					    function_addr, __LINE__);
d671 4
a674 4
		return 0;
	}
	SHOW_INSTRUCTION(function_addr, inst, "start of function: ");
	if (!SUBU_R31_R31_IMM(inst)) {
d676 1
a676 1
		if (DEBUGGING_ON) db_printf("<not subu,r31,r31,imm>\n");
d678 2
a679 2
		return 0;
	}
d681 2
a682 2
	/* add the size of this frame to the stack (for the next frame) */
	*stack += IMM16VAL(inst);
d684 16
a699 15
	/*
	 * Search from the beginning of the function (funstart) to where we are
	 * in the function (addr) looking to see what kind of registers have
	 * been saved on the stack.
	 *
	 * We'll stop looking before we get to ADDR if we hit a branch.
	 */
	clear_local_saved_regs();
	check_addr = function_addr + 4;	/* we know the first inst isn't a store */

	for (instructions_to_search = (addr - check_addr)/sizeof(long);
	    instructions_to_search-- > 0;
	    check_addr += 4) {
		union instruction instruction;
		unsigned flags;
d701 2
a702 2
		/* read the instruction */
		if (!db_trace_get_val(check_addr, &instruction.rawbits)) {
d704 2
a705 2
			if (DEBUGGING_ON) db_printf("couldn't read %x at line %d\n",
						    check_addr, __LINE__);
d707 2
a708 2
			break;
		}
d710 1
a710 1
		SHOW_INSTRUCTION(check_addr, instruction.rawbits, "prolog: ");
d712 2
a713 19
		/* find out the particulars about this instruction */
		flags = m88k_instruction_info(instruction.rawbits);

		/* if a store to something off the stack pointer, note the value */
		if ((flags & STORE) && instruction.diatic.s1 ==	/*stack pointer*/31) {
			unsigned value;
			if (!have_local_reg(instruction.diatic.d)) {
				if (instruction.diatic.d == 1)
					tried_to_save_r1 = r31 + instruction.diatic.i16 ;
				if (db_trace_get_val(r31 + instruction.diatic.i16, &value))
					save_reg(instruction.diatic.d, value);
			}
			if ((flags & DOUBLE) && !have_local_reg(instruction.diatic.d + 1)) {
				if (instruction.diatic.d == 0)
					tried_to_save_r1 = r31+instruction.diatic.i16 +4;
				if (db_trace_get_val(r31+instruction.diatic.i16 +4, &value))
					save_reg(instruction.diatic.d + 1, value);
			}
		}
d715 37
a751 10
		/* if an inst that kills D (and maybe D+1), note that */
		if (flags & TRASHES) {
			mark_reg_trashed(instruction.diatic.d);
			if (flags & DOUBLE)
				mark_reg_trashed(instruction.diatic.d + 1);
		}

		/* if a flow control instruction, stop now (or next if delayed) */
		if ((flags & FLOW_CTRL) && instructions_to_search != 0)
			instructions_to_search = (flags & DELAYED) ? 1 : 0;
a752 9

	/*
	 * If we didn't save r1 at some point, we're hosed.
	 */
	if (!have_local_reg(1)) {
		if (tried_to_save_r1) {
			db_printf("    <return value of next fcn unreadable in %08x>\n",
				  tried_to_save_r1);
		}
d754 1
a754 1
		if (DEBUGGING_ON) db_printf("didn't save r1\n");
d756 2
a757 2
		return 0;
	}
d759 1
a759 1
	ret_addr = saved_reg_value(1);
d762 3
a764 3
	if (DEBUGGING_ON)
		db_printf("Return value is = %x, function_addr is %x.\n",
			  ret_addr, function_addr);
d767 12
a778 12
	/*
	 * In support of this, continuation.s puts the low bit on the
	 * return address for continuations (the return address will never
	 * be used, so it's ok to do anything you want to it).
	 */
	if (ret_addr & 1) {
		note = "<<can not trace past a continuation>>";
		ret_addr = 0;
	} else if (ret_addr != 0x00) {
		switch (is_jump_source_ok(ret_addr, function_addr)) {
		case JUMP_SOURCE_IS_OK:
			break; /* excellent */
d780 1
a780 1
		case JUMP_SOURCE_IS_BAD:
d782 1
a782 1
			if (DEBUGGING_ON) db_printf("jump is bad\n");
d784 1
a784 1
			return 0; /* bummer */
d786 3
a788 4
		case JUMP_SOURCE_IS_UNLIKELY:
			next_address_likely_wrong = 1;;
			break;
		}
d790 1
d792 1
a792 1
	return ret_addr;
d798 54
a851 6
	unsigned stack;
	unsigned depth=1;
	unsigned where;
	unsigned ft;
	unsigned pair[2];
	int i;
d853 2
d856 4
a859 5
	 * Frame_is_sane returns:
	 *   1 if regs seems to be a reasonable kernel exception frame.
	 *   2 if regs seems to be a reasonable user exception frame
	 *      (in the current task).
	 *   0 if this looks like neither.
d861 21
a881 3
	if (ft = frame_is_sane(regs), ft == 0) {
		db_printf("Register frame 0x%x is suspicous; skipping trace\n", regs);
		return;
d884 2
a885 3
	/* if user space and no user space trace specified, puke */
	if (ft == 2 && !(trace_flags & TRACE_USER_FLAG))
		return;
a886 12
	/* fetch address */
	/* use sxip if valid, otherwise try snip or sfip */
	if (cputyp == CPU_88110) {
		where = regs->exip & ~3;
	} else {
		where = ((regs->sxip & 2) ? regs->sxip :
			 ((regs->snip & 2) ? regs->snip :
			  regs->sfip) ) & ~3;
	}
	stack = regs->r[31];
	db_printf("stack base = 0x%x\n", stack);
	db_printf("(0) "); /*depth of trace */
d888 1
a888 1
		db_printf("%08x ", where);
d890 4
a893 11
	clear_global_saved_regs();

	/* see if this routine had a stack frame */
	if ((where=stack_decode(where, &stack))==0) {
		where = regs->r[1];
		db_printf("(stackless)");
	} else {
		print_args();
		if (trace_flags & TRACE_SHOWFRAME_FLAG)
			db_printf(" [frame 0x%x]", stack);
	}
d896 2
a897 2
		db_printf("   %s\n", note);
		note = 0;
d899 1
d901 1
a901 47
	do {
		/*
		 * If requested, show preserved registers at the time
		 * the next-shown call was made. Only registers known to have
		 * changed from the last exception frame are shown, as others
		 * can be gotten at by looking at the exception frame.
		 */
		if (trace_flags & TRACE_SHOWCALLPRESERVED_FLAG) {
			int r, title_printed = 0;

			for (r = FIRST_CALLPRESERVED_REG; r<=LAST_CALLPRESERVED_REG; r++) {
				if (have_global_reg(r)) {
					unsigned value = saved_reg_value(r);
					if (title_printed == 0) {
						title_printed = 1;
						db_printf("[in next func:");
					}
					if (value == 0)
						db_printf(" r%d", r);
					else if (value <= 9)
						db_printf(" r%d=%x", r, value);
					else
						db_printf(" r%d=x%x", r, value);
				}
			}
			if (title_printed)
				db_printf("]\n");
		}

		db_printf("(%d)%c", depth++, next_address_likely_wrong ? '?':' ');
		next_address_likely_wrong = 0;

		if (trace_flags & TRACE_SHOWADDRESS_FLAG)
			db_printf("%08x ", where);
		db_printsym(where, DB_STGY_PROC);
		where = stack_decode(where, &stack);
		print_args();
		if (trace_flags & TRACE_SHOWFRAME_FLAG)
			db_printf(" [frame 0x%x]", stack);
		db_printf("\n");
		if (note) {
			db_printf("   %s\n", note);
			note = 0;
		}
	} while (where);

	/* try to trace back over trap/exception */
d903 2
a904 2
	stack &= ~7; /* double word aligned */
	/* take last top of stack, and try to find an exception frame near it */
d906 1
a906 1
	i = FRAME_PLAY;
d910 1
a910 1
		db_printf("(searching for exception frame at 0x%x)\n", stack);
d913 34
a946 1
	while (i) {
d948 15
a962 44
		 * On the stack, a pointer to the exception frame is written
		 * in two adjacent words. In the case of a fault from the kernel,
		 * this should point to the frame right above them:
		 *
		 * Exception Frame Top
		 * ..
		 * Exception Frame Bottom  <-- frame addr
		 * frame addr
		 * frame addr		<-- stack pointer
		 *
		 * In the case of a fault from user mode, the top of stack
		 * will just have the address of the frame
		 * replicated twice.
		 *
		 * frame addr		<-- top of stack
		 * frame addr
		 *
		 * Here we are just looking for kernel exception frames.
		 */

		if (badwordaddr((vm_offset_t)stack) ||
		    badwordaddr((vm_offset_t)(stack+4)))
			break;

		db_read_bytes((vm_offset_t)stack, 2*sizeof(int), (char*)pair);

		/* the pairs should match and equal stack+8 */
		if (pair[0] == pair[1]) {
			if (pair[0] != stack+8) {
				/*
				if (!badwordaddr((vm_offset_t)pair[0]) && (pair[0]!=0))
				db_printf("stack_trace:found pair 0x%x but != to stack+8\n",
				pair[0]);
				*/
				
			} else if (frame_is_sane((db_regs_t*)pair[0])) {
				db_regs_t *frame = (db_regs_t *) pair[0];
				char *cause = m88k_exception_name(frame -> vector);

				db_printf("-------------- %s [EF: 0x%x] -------------\n",
					  cause, frame);
				db_stack_trace_cmd2(frame);
				return;
			}
d964 3
a966 3
			else if (DEBUGGING_ON)
				db_printf("pair matched, but frame at 0x%x looks insane\n",
					  stack+8);
a967 3
		}
		stack += 8;
		i--;
d969 35
a1003 31

	/*
	 * If we go here, crawling back on the stack failed to find us
	 * a previous exception frame. Look for a user frame pointer
	 * pointed to by a word 8 bytes off of the top of the stack
	 * if the "u" option was specified.
	 */
	if (trace_flags & TRACE_USER_FLAG) {
		db_regs_t *user;

		/* Make sure we are back on the right page */
		stack -= 4*FRAME_PLAY;
		stack = stack & ~(KERNEL_STACK_SIZE-1);	/* point to the bottom */
		stack += KERNEL_STACK_SIZE - 8;

		if (badwordaddr((vm_offset_t)stack) ||
		    badwordaddr((vm_offset_t)stack))
			return;

		db_read_bytes((vm_offset_t)stack, 2*sizeof(int), (char*)pair);
		if (pair[0] != pair[1])
			return;

		/* have a hit */
		user = *((db_regs_t **) stack);

		if (frame_is_sane(user) == 2) {
			db_printf("---------------- %s [EF : 0x%x] -------------\n",
				  m88k_exception_name(user->vector), user);
			db_stack_trace_cmd2(user);
		}
d1005 1
d1016 4
a1019 4
		  db_regs_t *addr,
		  int have_addr,
		  db_expr_t count,
		  char *modif)
d1021 16
a1036 17
	enum {
		Default, Stack, Proc, Frame
	} style = Default;
	db_regs_t frame; /* a m88100_saved_state */
	db_regs_t *regs;
	union {
		db_regs_t *frame;
		struct proc *proc;
		unsigned num;
	} arg;
	arg.frame = addr;

	trace_flags = 0; /* flags will be set via modifers */

	while (modif && *modif) {
		switch (*modif++) {
		case 'd':
d1038 1
a1038 1
			trace_flags |= TRACE_DEBUG_FLAG;
d1040 1
a1040 1
			db_printtf("<debug trace not compiled in, ignoring>\n");
d1042 1
a1042 1
			break;
d1044 17
a1060 17
		case 's': style = Stack  ; break;
		case 'f': style = Frame  ; break;
		case 'p': trace_flags |= TRACE_SHOWCALLPRESERVED_FLAG; break;
		case 'a': trace_flags |= TRACE_SHOWADDRESS_FLAG; break;
		case 'F': trace_flags |= TRACE_SHOWFRAME_FLAG; break;
		case 'u': trace_flags |= TRACE_USER_FLAG; break;
		default:
			db_printf("unknown trace modifier [%c]\n", modif[-1]);
			/*FALLTHROUGH*/
		case 'h':
			db_printf("usage: trace/[MODIFIER]  [ARG]\n");
			db_printf("  u = include user trace\n");
			db_printf("  F = print stack frames\n");
			db_printf("  a = show return addresses\n");
			db_printf("  p = show call-preserved registers\n");
			db_printf("  s = ARG is a stack pointer\n");
			db_printf("  f = ARG is a frame pointer\n");
d1062 1
a1062 1
			db_printf("  d = trace-debugging output\n");
d1064 1
a1064 2
			return;
		}
d1066 28
d1095 8
a1102 2
	if (!have_addr && style != Default) {
		db_printf("expecting argument with /s or /f\n");
d1104 1
a1104 3
	}
	if (have_addr && style == Default)
		style = Proc;
d1106 28
a1133 58
	switch (style) {
	case Default:
		regs = DDB_REGS;
		break;

	case Frame:
		regs = arg.frame;
		break;

	case Proc:
		break;

	case Stack:
		{
			unsigned val1, val2, sxip;
			unsigned ptr;
			bzero((void*)&frame, sizeof(frame));
	#define REASONABLE_FRAME_DISTANCE 2048

			/*
			 * We've got to find the top of a stack frame so we can get both
			 * a PC and and real SP.
			 */
			for (ptr = arg.num;/**/; ptr += 4) {
				/* Read a word from the named stack */
				if (db_trace_get_val(ptr, &val1) == 0) {
					db_printf("can't read from %x, aborting.\n", ptr);
					return;
				}

				/*
				 * See if it's a frame pointer.... if so it will be larger than
				 * the address it was taken from (i.e. point back up the stack)
				 * and we'll be able to read where it points.
				 */
				if (val1 <= ptr ||
				    (val1 & 3)  ||
				    val1 > (ptr + REASONABLE_FRAME_DISTANCE))
					continue;

				/* peek at the next word to see if it could be a return address */
				if (db_trace_get_val(ptr, &sxip) == 0) {
					db_printf("can't read from %x, aborting.\n", ptr);
					return;
				}
				if (sxip == 0 || !db_trace_get_val(sxip, &val2))
					continue;

				if (db_trace_get_val(val1, &val2) == 0) {
					db_printf("can't read from %x, aborting.\n", val1);
					continue;
				}

				/*
				 * The value we've just read will be either another frame pointer,
				 * or the start of another exception frame.
				 */
				if (
d1135 1
a1135 1
				   val2 == 0
d1137 1
a1137 1
				   val2 == 0x12345678
d1139 13
a1151 22
				   && db_trace_get_val(val1-4, &val2) && val2 == val1
				   && db_trace_get_val(val1-8, &val2) && val2 == val1) {
					/* we've found a frame, so the stack must have been good */
					db_printf("%x looks like a frame, accepting %x\n",val1,ptr);
					break;
				}

				if (val2 > val1 && (val2 & 3) == 0) {
					/* well, looks close enough to be another frame pointer */
					db_printf("*%x = %x looks like a stack frame pointer, accepting %x\n", val1, val2, ptr);
					break;
				}
			}

			frame.r[31] = ptr;
			frame.epsr = 0x800003f0U;
			frame.sxip = sxip | 2;
			frame.snip = frame.sxip + 4;
			frame.sfip = frame.snip + 4;
			db_printf("[r31=%x, sxip=%x]\n", frame.r[31], frame.sxip);
			regs = &frame;
		}
d1154 11
a1164 1
	db_stack_trace_cmd2(regs);
a1165 1

@


1.9
log
@Use symbolic constants to identify ddb traps.
Fix a comment as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.8 2001/03/16 00:10:55 miod Exp $	*/
d41 1
a41 1
    unsigned rawbits;
d43 44
a86 44
    struct {
	unsigned int    : 5;
	unsigned int   n: 1;
	signed int   d26:26;
    } br;

    struct {
	unsigned int      : 4;
	unsigned int isbb1: 1;	/* isbb1==0 means bb0, isbb1==1 means bb1 */
	unsigned int   n  : 1;
	unsigned int  b5  : 5;
	unsigned int  s1  : 5;
	signed   int  d16 :16;
    } bb; /* bcnd too, except "isbb1" makes no sense for bcnd */

    struct {
	unsigned int      : 6;
	unsigned int  b5  : 5;
	unsigned int  s1  : 5;
	unsigned int      : 7;
	unsigned int vec9 : 9;
    } tb; /* tcnd too */

    struct {
	unsigned int      :21;
	unsigned int    n : 1;
	unsigned int      : 5;
	unsigned int   s2 : 5;
    } jump; /* jmp, jsr */

    struct {
	unsigned int      : 6;
        unsigned int    d : 5;
        unsigned int   s1 : 5;
        unsigned int  i16 :16;
    } diatic;	/* general reg/reg/i16 instructions */

    struct {
	unsigned int      : 6;
        unsigned int    d : 5;
        unsigned int   s1 : 5;
        unsigned int      :11;
        unsigned int   s2 : 5;
    } triatic;  /* general reg/reg/reg instructions */
d103 1
a103 1
    db_expr_t count, char *modif));
d149 3
a151 4
db_setf_regs(
	struct db_variable	*vp,
	db_expr_t		*valuep,
	int			op)		/* read/write */
d153 1
a153 1
    register int   *regp = (int *) ((char *) DDB_REGS + (int) (vp->valuep));
d155 4
a158 4
    if (op == DB_VAR_GET)
	*valuep = *regp;
    else if (op == DB_VAR_SET)
	*regp = *valuep;
d160 1
a160 1
    return (0);	/* silence warning */
d166 17
a182 17
    N("r1", r[1]),     N("r2", r[2]), 	 N("r3", r[3]),	   N("r4", r[4]),
    N("r5", r[5]),     N("r6", r[6]), 	 N("r7", r[7]),	   N("r8", r[8]),
    N("r9", r[9]),     N("r10", r[10]),  N("r11", r[11]),  N("r12", r[12]),
    N("r13", r[13]),   N("r14", r[14]),  N("r15", r[15]),  N("r16", r[16]),
    N("r17", r[17]),   N("r18", r[18]),  N("r19", r[19]),  N("r20", r[20]),
    N("r21", r[21]),   N("r22", r[22]),  N("r23", r[23]),  N("r24", r[24]),
    N("r25", r[25]),   N("r26", r[26]),  N("r27", r[27]),  N("r28", r[28]),
    N("r29", r[29]),   N("r30", r[30]),  N("r31", r[31]),  N("epsr", epsr),
    N("sxip", sxip),   N("snip", snip),  N("sfip", sfip),  N("ssbr", ssbr),
    N("dmt0", dmt0),   N("dmd0", dmd0),  N("dma0", dma0),  N("dmt1", dmt1),
    N("dmd1", dmd1),   N("dma1", dma1),  N("dmt2", dmt2),  N("dmd2", dmd2),
    N("dma2", dma2),   N("fpecr", fpecr),N("fphs1", fphs1),N("fpls1", fpls1),
    N("fphs2", fphs2), N("fpls2", fpls2),N("fppt", fppt),  N("fprh", fprh),
    N("fprl", fprl),   N("fpit", fpit),  N("fpsr", fpsr),  N("fpcr", fpcr),
    N("mask", mask), /* interrupt mask */
    N("mode", mode), /* interrupt mode */
    N("exvc", vector), /* exception vector */
d205 36
a240 35
   static struct { unsigned mask, value, flags; } *ptr, control[] =
   {
      /* runs in the same order as 2nd Ed 88100 manual Table 3-14 */
     { 0xf0000000U, 0x00000000U, /* xmem */     TRASHES | STORE | LOAD    },
     { 0xec000000U, 0x00000000U, /* ld.d */     TRASHES | LOAD | DOUBLE   },
     { 0xe0000000U, 0x00000000U, /* load */     TRASHES | LOAD            },
     { 0xfc000000U, 0x20000000U, /* st.d */     STORE | DOUBLE            },
     { 0xf0000000U, 0x20000000U, /* store */    STORE                     },
     { 0xc0000000U, 0x40000000U, /* arith */    TRASHES                   },
     { 0xfc004000U, 0x80004000U, /* ld cr */    TRASHES                   },
     { 0xfc004000U, 0x80000000U, /* st cr */    0                         },
     { 0xfc008060U, 0x84000000U, /* f */        TRASHES                   },
     { 0xfc008060U, 0x84000020U, /* f.d */      TRASHES | DOUBLE          },
     { 0xfc000000U, 0xcc000000U, /* bsr.n */    FLOW_CTRL | DELAYED | BSR },
     { 0xfc000000U, 0xc8000000U, /* bsr */      FLOW_CTRL | BSR           },
     { 0xe4000000U, 0xc4000000U, /* br/bb.n */  FLOW_CTRL | DELAYED       },
     { 0xe4000000U, 0xc0000000U, /* br/bb */    FLOW_CTRL                 },
     { 0xfc000000U, 0xec000000U, /* bcnd.n */   FLOW_CTRL | DELAYED       },
     { 0xfc000000U, 0xe8000000U, /* bcnd */     FLOW_CTRL                 },
     { 0xfc00c000U, 0xf0008000U, /* bits */     TRASHES                   },
     { 0xfc00c000U, 0xf000c000U, /* trap */     0                         },
     { 0xfc00f0e0U, 0xf4002000U, /* st */       0                         },
     { 0xfc00cce0U, 0xf4000000U, /* ld.d */     TRASHES | DOUBLE          },
     { 0xfc00c0e0U, 0xf4000000U, /* ld */       TRASHES                   },
     { 0xfc00c0e0U, 0xf4004000U, /* arith */    TRASHES                   },
     { 0xfc00c3e0U, 0xf4008000U, /* bits */     TRASHES                   },
     { 0xfc00ffe0U, 0xf400cc00U, /* jsr.n */    FLOW_CTRL | DELAYED | JSR },
     { 0xfc00ffe0U, 0xf400c800U, /* jsr */      FLOW_CTRL | JSR           },
     { 0xfc00ffe0U, 0xf400c400U, /* jmp.n */    FLOW_CTRL | DELAYED       },
     { 0xfc00ffe0U, 0xf400c000U, /* jmp */      FLOW_CTRL                 },
     { 0xfc00fbe0U, 0xf400e800U, /* ff */       TRASHES                   },
     { 0xfc00ffe0U, 0xf400f800U, /* tbnd */     0                         },
     { 0xfc00ffe0U, 0xf400fc00U, /* rte */      FLOW_CTRL                 },
     { 0xfc000000U, 0xf8000000U, /* tbnd */     0                         },
    };
d242 5
a246 5
    for (ptr = &control[0]; ptr < &control[ctrl_count]; ptr++)
	if ((instruction & ptr->mask) == ptr->value)
	    return ptr->flags;
    SHOW_INSTRUCTION(0, instruction, "bad m88k_instruction_info");
    return 0;
d252 7
a258 4
    int i;
    unsigned last = 0;
    unsigned char c; 
    unsigned have_a_hex_digit = 0;
d260 12
a271 1
    if (value <= 9)
a272 14

    for (i = 0; i < 8; i++) {
	c = value & 0xf;
	value >>= 4;
	if (c)
	    last = c;
	if (c > 9)
	    have_a_hex_digit = 1;
    }
    if (have_a_hex_digit == 0)
	return 1;
    if (last > 9)
	return 1;
    return 0;
a274 1

d285 5
a289 3
    /* no good if we can't read the whole frame */
    if (badwordaddr((vm_offset_t)regs) || badwordaddr((vm_offset_t)&regs->mode))
	return 0;
d292 6
a297 4
    /* disabled for now  -- see fpu_enable in mvme88k/eh.s */
    /* r0 must be 0 (obviously) */
    if (regs->r[0] != 0)
	return 0;
d300 5
a304 3
    /* stack sanity ... r31 must be nonzero, but must be word aligned */
    if (regs->r[31] == 0 || (regs->r[31] & 3) != 0)
	return 0;
d306 2
a307 1
    /* sxip is reasonable */
d309 2
a310 2
    if ((regs->sxip & 1) == 1)
	return 0;
d312 22
a333 2
    /* snip is reasonable */
    if ((regs->snip & 3) != 2)
a334 20
    /* sfip is reasonable */
    if ((regs->sfip & 3) != 2)
	return 0;

    /* epsr sanity */
    if ((regs->epsr & 0x8FFFFFF5U) == 0x800003f0U) /* kernel mode */
    {
	if (regs->epsr & 0x40000000) 
	  db_printf("[WARNING: byte order in kernel frame at %x "
		    "is little-endian!]\n", regs);
	return 1;
    }
    if ((regs->epsr & 0x8FFFFFFFU) == 0x000003f0U) /* user mode */
    {
	if (regs->epsr & 0x40000000) 
	  db_printf("[WARNING: byte order in user frame at %x "
		    "is little-endian!]\n", regs);
	return 2;
    }
    return 0;
d340 1
a340 1
	switch  (vector) {
d353 1
d363 1
a363 1
    }
d373 16
a388 16
    label_t db_jmpbuf;
    label_t *prev = db_recover;
    boolean_t old_quiet_db_read_bytes = quiet_db_read_bytes;

    quiet_db_read_bytes = 1;

    if (setjmp((db_recover = &db_jmpbuf)) != 0) {
	db_recover = prev;
        quiet_db_read_bytes = old_quiet_db_read_bytes;
	return 0;
    } else {
	db_read_bytes(addr, 4, (char*)ptr);
	db_recover = prev;
        quiet_db_read_bytes = old_quiet_db_read_bytes;
	return 1;
    }
d392 5
a396 5
#define FIRST_CALLPRESERVED_REG 14
#define LAST_CALLPRESERVED_REG  29
#define FIRST_ARG_REG       2
#define LAST_ARG_REG        9
#define RETURN_VAL_REG           1
d411 1
a411 1
    if (trashed_list & reg_bit(reg)) {
d413 1
a413 1
	    if (DEBUGGING_ON) db_printf("<trashed>\n");
d415 5
a419 5
	return; /* don't save trashed registers */
    }
    saved_reg[(reg%32)] = value;
    global_saved_list |= reg_bit(reg);
    local_saved_list  |= reg_bit(reg);
d438 1
a438 1
    int reg, last_arg;
d440 23
a462 24
    /* find the highest argument register saved */
    for (last_arg = LAST_ARG_REG; last_arg >= FIRST_ARG_REG; last_arg--)
	if (have_local_reg(last_arg))
	    break;
    if (last_arg < FIRST_ARG_REG)
	return; /* none were saved */

    db_printf("(");

    /* print each one, up to the highest */
    for (reg = FIRST_ARG_REG; /*nothing */; reg++)
    {
	if (!have_local_reg(reg))
	    db_printf("?");
	else {
	    unsigned value = saved_reg_value(reg);
	    db_printf("%s%x", hex_value_needs_0x(value)  ? "0x" : "", value);
	}
	if (reg == last_arg)
	    break;
	else
	    db_printf(", ");
    }
    db_printf(")");
d494 10
a503 2
    unsigned flags;
    union instruction instruction; 
d505 16
a520 34
    /*
     * Delayed branches are most common... look two instructions before
     * where we were going to return to to see if it's a delayed branch.
     */
    if (!db_trace_get_val(return_to - 8, &instruction.rawbits))
	return JUMP_SOURCE_IS_BAD;
    flags = m88k_instruction_info(instruction.rawbits);

    if ((flags & FLOW_CTRL) && (flags & DELAYED) && (flags & (JSR|BSR))) {
	if (flags & JSR)
	    return JUMP_SOURCE_IS_OK; /* have to assume it's correct */
	/* calculate the offset */
	if (br_dest(return_to - 8, instruction) == jump_to)
	    return JUMP_SOURCE_IS_OK; /* exactamundo! */
	else
	    return JUMP_SOURCE_IS_UNLIKELY; /* seems wrong */
    }

    /*
     * Try again, looking for a non-delayed jump one back.
     */
    if (!db_trace_get_val(return_to - 4, &instruction.rawbits))
	return JUMP_SOURCE_IS_BAD;
    flags = m88k_instruction_info(instruction.rawbits);

    if ((flags & FLOW_CTRL) && !(flags & DELAYED) && (flags & (JSR|BSR))) {
	if (flags & JSR)
	    return JUMP_SOURCE_IS_OK; /* have to assume it's correct */
	/* calculate the offset */
	if (br_dest(return_to - 4, instruction) == jump_to)
	    return JUMP_SOURCE_IS_OK; /* exactamundo! */
	else
	    return JUMP_SOURCE_IS_UNLIKELY; /* seems wrong */
    }
d522 11
a532 1
    return JUMP_SOURCE_IS_UNLIKELY;
d563 9
a571 9
    db_sym_t proc;
    unsigned offset_from_proc;
    unsigned instructions_to_search;
    unsigned check_addr;
    unsigned function_addr;	/* start of function */
    unsigned r31 = *stack;	/* the r31 of the function */
    unsigned inst;		/* text of an instruction */
    unsigned ret_addr;		/* address to which we return */
    unsigned tried_to_save_r1 = 0;
d574 3
a576 3
      if (DEBUGGING_ON)
	db_printf("\n>>>stack_decode(addr=%x, stack=%x)\n",
		addr, *stack);
d579 15
a593 16
      /* get what we hope will be the db_sym_t for the function name */
    proc = db_search_symbol(addr, DB_STGY_PROC, &offset_from_proc);
    if (offset_from_proc == addr) /* i.e. no symbol found */
	proc = DB_SYM_NULL;

    /*
     * Somehow, find the start of this function.
     * If we found a symbol above, it'll have the address.
     * Otherwise, we've got to search for it....
     */
    if (proc != DB_SYM_NULL)
    {
	char *names;
	db_symbol_values(proc, &names, &function_addr);
	if (names == 0)
	    return 0;
d595 2
a596 2
	    if (DEBUGGING_ON) db_printf("name %s address 0x%x\n",
		names, function_addr);
d598 9
a606 12
    }
    else
    {
	int instructions_to_check = 400;
	/*
	 * hmm - unable to find symbol. Search back
	 * looking for a function prolog.
	 */
	for (check_addr = addr; instructions_to_check-- > 0; check_addr -= 4)
	{
	    if (!db_trace_get_val(check_addr, &inst))
		break;
d608 1
a608 2
	    if (SUBU_R31_R31_IMM(inst))
	    {
d610 9
a618 9
		    /*
		     * If the next instruction is "st r1, r31, ####"
		     * then we can feel safe we have the start of
		     * a function.
		     */
		    if (!db_trace_get_val(check_addr + 4, &inst))
			continue;
		    if (ST_R1_R31_IMM(instr))
			break; /* sucess */
d620 7
a626 7
		    /*
		     * Latest GCC optimizer is just too good... the store
		     * of r1 might come much later... so we'll have to
		     * settle for just the "subr r31, r31, ###" to mark
		     * the start....
		     */
		     break;
d628 9
a636 9
	    }
	    /*
	     * if we come across a [jmp r1] or [jmp.n r1] assume we have hit
	     * the previous functions epilogue and stop our search.
	     * Since we know we would have hit the "subr r31, r31" if it was
	     * right in front of us, we know this doesn't have one so
	     * we just return failure....
	     */
	    if (JMP_R1(inst) || JMPN_R1(inst)) {
d638 3
a640 3
		    if (DEBUGGING_ON)
			db_printf("ran into a [jmp r1] at %x (addr=%x)\n",
				check_addr, addr);
d642 4
a645 4
		return 0;
	    }
	}
	if (instructions_to_check < 0) {
d647 2
a648 2
		if (DEBUGGING_ON)
		    db_printf("couldn't find func start (addr=%x)\n", addr);
d650 3
a652 1
	    return 0; /* bummer, couldn't find it */
a653 2
	function_addr = check_addr;
    }
d655 7
a661 7
    /*
     * We now know the start of the function (function_addr).
     * If we're stopped right there, or if it's not a
     *		subu r31, r31, ####
     * then we're done.
     */
    if (addr == function_addr) {
d663 1
a663 1
	    if (DEBUGGING_ON) db_printf("at start of func\n");
d665 3
a667 3
	return 0;
    }
    if (!db_trace_get_val(function_addr, &inst)) {
d669 2
a670 2
	    if (DEBUGGING_ON) db_printf("couldn't read %x at line %d\n",
		function_addr, __LINE__);
d672 4
a675 4
	return 0;
    }
    SHOW_INSTRUCTION(function_addr, inst, "start of function: ");
    if (!SUBU_R31_R31_IMM(inst)) {
d677 1
a677 1
	    if (DEBUGGING_ON) db_printf("<not subu,r31,r31,imm>\n");
d679 2
a680 2
	return 0;
    }
d682 2
a683 2
    /* add the size of this frame to the stack (for the next frame) */
    *stack += IMM16VAL(inst);
d685 15
a699 16
    /*
     * Search from the beginning of the function (funstart) to where we are
     * in the function (addr) looking to see what kind of registers have
     * been saved on the stack.
     *
     * We'll stop looking before we get to ADDR if we hit a branch.
     */
    clear_local_saved_regs();
    check_addr = function_addr + 4; /* we know the first inst isn't a store */

    for (instructions_to_search = (addr - check_addr)/sizeof(long);
	instructions_to_search-- > 0;
	check_addr += 4)
    {
 	union instruction instruction;
	unsigned flags;
d701 2
a702 2
	/* read the instruction */
        if (!db_trace_get_val(check_addr, &instruction.rawbits)) {
d704 2
a705 2
		if (DEBUGGING_ON) db_printf("couldn't read %x at line %d\n",
		    check_addr, __LINE__);
d707 7
a713 2
            break;
	}
d715 16
a730 1
	SHOW_INSTRUCTION(check_addr, instruction.rawbits, "prolog: ");
d732 6
a737 2
	/* find out the particulars about this instruction */
	flags = m88k_instruction_info(instruction.rawbits);
d739 3
a741 37
	/* if a store to something off the stack pointer, note the value */
	if ((flags & STORE) && instruction.diatic.s1 == /*stack pointer*/31)
	{
	    unsigned value;
	    if (!have_local_reg(instruction.diatic.d)) {
		if (instruction.diatic.d == 1)
			tried_to_save_r1 = r31 + instruction.diatic.i16 ;
		if (db_trace_get_val(r31 + instruction.diatic.i16, &value))
		    save_reg(instruction.diatic.d, value);
	    }
	    if ((flags & DOUBLE) && !have_local_reg(instruction.diatic.d + 1)) {
		if (instruction.diatic.d == 0)
		    tried_to_save_r1 = r31+instruction.diatic.i16 +4;
		if (db_trace_get_val(r31+instruction.diatic.i16 +4, &value))
		    save_reg(instruction.diatic.d + 1, value);
	    }
	}

	/* if an inst that kills D (and maybe D+1), note that */
	if (flags & TRASHES) {
	    mark_reg_trashed(instruction.diatic.d);
	    if (flags & DOUBLE)
	        mark_reg_trashed(instruction.diatic.d + 1);
	}

	/* if a flow control instruction, stop now (or next if delayed) */
	if ((flags & FLOW_CTRL) && instructions_to_search != 0)
	    instructions_to_search = (flags & DELAYED) ? 1 : 0;
    }

    /*
     * If we didn't save r1 at some point, we're hosed.
     */
    if (!have_local_reg(1)) {
	if (tried_to_save_r1) {
	    db_printf("    <return value of next fcn unreadable in %08x>\n",
		tried_to_save_r1);
d743 9
d753 1
a753 1
	    if (DEBUGGING_ON) db_printf("didn't save r1\n");
d755 2
a756 2
	return 0;
    }
d758 1
a758 1
    ret_addr = saved_reg_value(1);
d761 3
a763 3
    if (DEBUGGING_ON)
	db_printf("Return value is = %x, function_addr is %x.\n",
	    ret_addr, function_addr);
d766 12
a777 12
    /*
     * In support of this, continuation.s puts the low bit on the
     * return address for continuations (the return address will never
     * be used, so it's ok to do anything you want to it).
     */
    if (ret_addr & 1) {
	note = "<<can not trace past a continuation>>";
	ret_addr = 0;
    } else if (ret_addr != 0x00) {
	switch(is_jump_source_ok(ret_addr, function_addr)) {
	  case JUMP_SOURCE_IS_OK:
		break; /* excellent */
d779 1
a779 1
	  case JUMP_SOURCE_IS_BAD:
d781 1
a781 1
		    if (DEBUGGING_ON) db_printf("jump is bad\n");
d783 1
a783 1
		return 0; /* bummer */
d785 4
a788 3
	  case JUMP_SOURCE_IS_UNLIKELY:
		next_address_likely_wrong = 1;;
		break;
a789 1
    }
d791 1
a791 1
    return ret_addr;
d797 6
a802 54
    unsigned stack;
    unsigned depth=1;
    unsigned where;
    unsigned ft;
    unsigned pair[2];
    int i;

    /*
     * Frame_is_sane returns:
     *   1 if regs seems to be a reasonable kernel exception frame.
     *   2 if regs seems to be a reasonable user exception frame
     *      (in the current task).
     *   0 if this looks like neither.
     */
    if (ft = frame_is_sane(regs), ft == 0)
    {
	db_printf("Register frame 0x%x is suspicous; skipping trace\n", regs);
	return;
    }

    /* if user space and no user space trace specified, puke */
    if (ft == 2 && !(trace_flags & TRACE_USER_FLAG))
	return;

    /* fetch address */
    /* use sxip if valid, otherwise try snip or sfip */
    where = ((regs->sxip & 2) ? regs->sxip :
	    ((regs->snip & 2) ? regs->snip :
	      regs->sfip) ) & ~3;
    stack = regs->r[31];
    db_printf("stack base = 0x%x\n", stack);
    db_printf("(0) "); /*depth of trace */
    if (trace_flags & TRACE_SHOWADDRESS_FLAG)
	db_printf("%08x ", where);
    db_printsym(where, DB_STGY_PROC);
    clear_global_saved_regs();

    /* see if this routine had a stack frame */
    if ((where=stack_decode(where, &stack))==0)
    {
	where = regs->r[1];
	db_printf("(stackless)");
    }
    else
    {
	print_args();
	if (trace_flags & TRACE_SHOWFRAME_FLAG)
	    db_printf(" [frame 0x%x]", stack);
    }
    db_printf("\n");
    if (note) {
	db_printf("   %s\n", note);
	note = 0;
    }
a803 2
    do
    {
d805 5
a809 4
	 * If requested, show preserved registers at the time
	 * the next-shown call was made. Only registers known to have
	 * changed from the last exception frame are shown, as others
	 * can be gotten at by looking at the exception frame.
d811 3
a813 21
	if (trace_flags & TRACE_SHOWCALLPRESERVED_FLAG)
	{
	    int r, title_printed = 0;

	    for (r = FIRST_CALLPRESERVED_REG; r<=LAST_CALLPRESERVED_REG; r++) {
		if (have_global_reg(r)) {
		    unsigned value = saved_reg_value(r);
		    if (title_printed == 0) {
		       title_printed = 1;
		       db_printf("[in next func:");
		    }
		    if (value == 0)
			db_printf(" r%d", r);
		    else if (value <= 9)
			db_printf(" r%d=%x", r, value);
		    else
			db_printf(" r%d=x%x", r, value);
		}
	    }
	    if (title_printed)
		db_printf("]\n");
d816 3
a818 2
	db_printf("(%d)%c", depth++, next_address_likely_wrong ? '?':' ');
	next_address_likely_wrong = 0;
d820 12
d833 1
a833 1
	    db_printf("%08x ", where);
d835 11
a845 4
	where = stack_decode(where, &stack);
	print_args();
	if (trace_flags & TRACE_SHOWFRAME_FLAG)
	    db_printf(" [frame 0x%x]", stack);
d848 2
a849 2
	    db_printf("   %s\n", note);
	    note = 0;
a850 1
    } while (where);
d852 47
a898 1
    /* try to trace back over trap/exception */
d900 2
a901 2
    stack &= ~7; /* double word aligned */
    /* take last top of stack, and try to find an exception frame near it */
d903 1
a903 1
    i = FRAME_PLAY;
d907 1
a907 1
	    db_printf("(searching for exception frame at 0x%x)\n", stack);
d910 1
a910 34
    while (i)
    {
	/*
	 * On the stack, a pointer to the exception frame is written
	 * in two adjacent words. In the case of a fault from the kernel,
	 * this should point to the frame right above them:
	 *
	 * Exception Frame Top
	 * ..
	 * Exception Frame Bottom  <-- frame addr
	 * frame addr
	 * frame addr		<-- stack pointer
	 *
	 * In the case of a fault from user mode, the top of stack
	 * will just have the address of the frame
	 * replicated twice.
	 *
	 * frame addr		<-- top of stack
	 * frame addr
	 *
	 * Here we are just looking for kernel exception frames.
	 */

	if (badwordaddr((vm_offset_t)stack) ||
	    badwordaddr((vm_offset_t)(stack+4)))
		    break;

	db_read_bytes((vm_offset_t)stack, 2*sizeof(int), (char*)pair);

	/* the pairs should match and equal stack+8 */
	if (pair[0] == pair[1])
	{
	    if (pair[0] != stack+8)
	    {
d912 44
a955 15
		if (!badwordaddr((vm_offset_t)pair[0]) && (pair[0]!=0))
		db_printf("stack_trace:found pair 0x%x but != to stack+8\n",
		pair[0]);
		*/
	    }
	    else if (frame_is_sane((db_regs_t*)pair[0]))
	    {
		db_regs_t *frame = (db_regs_t *) pair[0];
		char *cause = m88k_exception_name(frame -> vector);

		db_printf("-------------- %s [EF: 0x%x] -------------\n",
		      cause, frame);
		db_stack_trace_cmd2(frame);
		return;
	    }
d957 3
a959 3
		else if (DEBUGGING_ON)
		    db_printf("pair matched, but frame at 0x%x looks insane\n",
			stack+8);
d961 3
d965 31
a995 35
	stack += 8;
	i--;
    }

    /*
     * If we go here, crawling back on the stack failed to find us
     * a previous exception frame. Look for a user frame pointer
     * pointed to by a word 8 bytes off of the top of the stack
     * if the "u" option was specified.
     */
    if (trace_flags & TRACE_USER_FLAG)
    {
	db_regs_t *user;

	/* Make sure we are back on the right page */
	stack -= 4*FRAME_PLAY;
	stack = stack & ~(KERNEL_STACK_SIZE-1); /* point to the bottom */
	stack += KERNEL_STACK_SIZE - 8;

	if (badwordaddr((vm_offset_t)stack) ||
	    badwordaddr((vm_offset_t)stack))
		    return;

	db_read_bytes((vm_offset_t)stack, 2*sizeof(int), (char*)pair);
	if (pair[0] != pair[1])
	    return;

	/* have a hit */
	user = *((db_regs_t **) stack);

	if (frame_is_sane(user) == 2)
	{
	    db_printf("---------------- %s [EF : 0x%x] -------------\n",
		m88k_exception_name(user->vector), user);
	    db_stack_trace_cmd2(user);
a996 1
    }
d1007 4
a1010 4
    db_regs_t *addr,
    int have_addr,
    db_expr_t count,
    char *modif)
d1012 17
a1028 16
    enum { Default, Stack, Proc, Frame } style = Default;
    db_regs_t frame; /* a m88100_saved_state */
    db_regs_t *regs;
    union {
	db_regs_t *frame;
	struct proc *proc;
	unsigned num;
    } arg;
    arg.frame = addr;

    trace_flags = 0; /* flags will be set via modifers */

    while (modif && *modif) {
	 switch (*modif++)
    	 {
	  case 'd':
d1030 1
a1030 1
		trace_flags |= TRACE_DEBUG_FLAG;
d1032 1
a1032 1
		db_printtf("<debug trace not compiled in, ignoring>\n");
d1034 1
a1034 1
	    break;
d1036 17
a1052 17
	  case 's': style = Stack  ; break;
	  case 'f': style = Frame  ; break;
	  case 'p': trace_flags |= TRACE_SHOWCALLPRESERVED_FLAG; break;
	  case 'a': trace_flags |= TRACE_SHOWADDRESS_FLAG; break;
	  case 'F': trace_flags |= TRACE_SHOWFRAME_FLAG; break;
	  case 'u': trace_flags |= TRACE_USER_FLAG; break;
	  default:
	    db_printf("unknown trace modifier [%c]\n", modif[-1]);
	    /*FALLTHROUGH*/
	  case 'h':
	    db_printf("usage: trace/[MODIFIER]  [ARG]\n");
	    db_printf("  u = include user trace\n");
	    db_printf("  F = print stack frames\n");
	    db_printf("  a = show return addresses\n");
	    db_printf("  p = show call-preserved registers\n");
	    db_printf("  s = ARG is a stack pointer\n");
	    db_printf("  f = ARG is a frame pointer\n");
d1054 1
a1054 1
		db_printf("  d = trace-debugging output\n");
d1056 2
a1057 1
	    return;
a1058 1
    }
d1060 24
a1083 25
    if (!have_addr && style != Default) {
	db_printf("expecting argument with /s or /f\n");
	return;
    }
    if (have_addr && style == Default)
	style = Proc;

    switch(style)
    {
      case Default:
	regs = DDB_REGS;
	break;

      case Frame:
	regs = arg.frame;
	break;
      
      case Proc:
        break;
      
      case Stack:
      {
	unsigned val1, val2, sxip;
	unsigned ptr;
	bzero((void*)&frame, sizeof(frame));
d1086 39
a1124 39
	/*
	 * We've got to find the top of a stack frame so we can get both
	 * a PC and and real SP.
	 */
	for (ptr = arg.num;/**/; ptr += 4) {
	    /* Read a word from the named stack */
	    if (db_trace_get_val(ptr, &val1) == 0) {
		db_printf("can't read from %x, aborting.\n", ptr);
		return;
	    }

	    /*
	     * See if it's a frame pointer.... if so it will be larger than
	     * the address it was taken from (i.e. point back up the stack)
	     * and we'll be able to read where it points.
	     */
	    if (val1 <= ptr ||
		(val1 & 3)  ||
		val1 > (ptr + REASONABLE_FRAME_DISTANCE))
		    continue;

	    /* peek at the next word to see if it could be a return address */
	    if (db_trace_get_val(ptr, &sxip) == 0) {
		db_printf("can't read from %x, aborting.\n", ptr);
		return;
	    }
	    if (sxip == 0 || !db_trace_get_val(sxip, &val2))
		continue;

	    if (db_trace_get_val(val1, &val2) == 0) {
		db_printf("can't read from %x, aborting.\n", val1);
		continue;
	    }

	    /*
	     * The value we've just read will be either another frame pointer,
	     * or the start of another exception frame.
	     */
	    if (
d1126 1
a1126 1
		    val2 == 0
d1128 1
a1128 1
		    val2 == 0x12345678
d1130 22
a1151 13
	        && db_trace_get_val(val1-4, &val2) && val2 == val1
	        && db_trace_get_val(val1-8, &val2) && val2 == val1)
	    {
		    /* we've found a frame, so the stack must have been good */
		    db_printf("%x looks like a frame, accepting %x\n",val1,ptr);
		    break;
	    }

	    if (val2 > val1 && (val2 & 3) == 0) {
		/* well, looks close enough to be another frame pointer */
		db_printf("*%x = %x looks like a stack frame pointer, accepting %x\n", val1, val2, ptr);
		break;
	    }
d1154 2
a1155 9
	frame.r[31] = ptr;
	frame.epsr = 0x800003f0U;
	frame.sxip = sxip | 2;
	frame.snip = frame.sxip + 4;
	frame.sfip = frame.snip + 4;
	db_printf("[r31=%x, sxip=%x]\n", frame.r[31], frame.sxip);
	regs = &frame;
      }
    }
a1156 2
    db_stack_trace_cmd2(regs);
}
@


1.8
log
@Cleanup, get badwordaddr() from <machine/locore.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.7 2001/03/09 05:44:38 smurph Exp $	*/
d291 1
a291 1
    /* disabled for now  -- see fpu_enable in luna88k/eh.s */
d334 1
a334 2
    switch  (vector)
    {
d349 6
a354 3
	case 130: return "Ddb break";
	case 131: return "Ddb trace";
	case 132: return "Ddb trap";
@


1.7
log
@kernel will compile with -Werror.  Added intr.h
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.6 2001/03/08 00:02:18 miod Exp $	*/
d29 11
d98 6
a103 7
#include <sys/param.h>
#include <sys/systm.h>
#include <machine/db_machdep.h> /* lots of stuff                  */
#include <ddb/db_variables.h>	/* db_variable, DB_VAR_GET, etc.  */
#include <ddb/db_output.h>	/* db_printf                      */
#include <ddb/db_sym.h>		/* DB_STGY_PROC, etc.             */
#include <ddb/db_command.h>	/* db_recover                     */
a104 3
extern int badwordaddr();
extern int m88k_print_instruction __P((unsigned iadr, long inst));
extern void db_read_bytes();
d331 2
a332 2
char
*m88k_exception_name(unsigned vector)
d375 1
a375 1
	db_read_bytes((char*)addr, 4, (char*)ptr);
d938 1
a938 1
	db_read_bytes((char*)stack, 2*sizeof(int), (char*)pair);
d990 1
a990 1
	db_read_bytes((char*)stack, 2*sizeof(int), (char*)pair);
@


1.6
log
@Some warning hunting.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.5 1999/02/09 06:36:25 smurph Exp $	*/
d87 2
d95 3
d363 1
a363 1
    if (setjmp(*(db_recover = &db_jmpbuf)) != 0) {
d1075 4
a1078 1

d1150 1
a1150 1
db_printf("[r31=%x, sxip=%x]\n", frame.r[31], frame.sxip);
@


1.5
log
@Added kernel support for user debugging.  Fixed file ID's
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.28 1995/04/19 22:37:27 smurph Exp $	*/
d108 1
a108 1
static trace_flags = 0;
d148 2
@


1.5.6.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.8 2001/03/16 00:10:55 miod Exp $	*/
a28 11
#include <sys/param.h>
#include <sys/systm.h>

#include <machine/db_machdep.h> /* lots of stuff                  */
#include <machine/locore.h>

#include <ddb/db_variables.h>	/* db_variable, DB_VAR_GET, etc.  */
#include <ddb/db_output.h>	/* db_printf                      */
#include <ddb/db_sym.h>		/* DB_STGY_PROC, etc.             */
#include <ddb/db_command.h>	/* db_recover                     */

d87 5
a91 6
extern void db_read_bytes __P((vm_offset_t addr, int size, char *data));
int frame_is_sane __P((db_regs_t *regs));
char *m88k_exception_name __P((unsigned vector));
unsigned db_trace_get_val __P((vm_offset_t addr, unsigned *ptr));
void db_stack_trace_cmd __P((db_regs_t *addr, int have_addr,
    db_expr_t count, char *modif));
d108 1
a108 1
static int trace_flags = 0;
a147 2

    return (0);	/* silence warning */
d317 2
a318 2
char *
m88k_exception_name(unsigned vector)
d356 1
a356 1
    if (setjmp((db_recover = &db_jmpbuf)) != 0) {
d361 1
a361 1
	db_read_bytes(addr, 4, (char*)ptr);
d924 1
a924 1
	db_read_bytes((vm_offset_t)stack, 2*sizeof(int), (char*)pair);
d976 1
a976 1
	db_read_bytes((vm_offset_t)stack, 2*sizeof(int), (char*)pair);
d1068 1
a1068 4
      
      case Proc:
        break;
      
d1140 1
a1140 1
	db_printf("[r31=%x, sxip=%x]\n", frame.r[31], frame.sxip);
@


1.5.6.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.5.6.1 2001/04/18 16:10:51 niklas Exp $	*/
d291 1
a291 1
    /* disabled for now  -- see fpu_enable in mvme88k/eh.s */
d334 2
a335 1
	switch  (vector) {
d350 3
a352 6
	case DDB_ENTRY_BKPT_NO:
		return "ddb break";
	case DDB_ENTRY_TRACE_NO:
		return "ddb trace";
	case DDB_ENTRY_TRAP_NO:
		return "ddb trap";
@


1.5.6.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d41 1
a41 1
	unsigned rawbits;
d43 44
a86 44
	struct {
		unsigned int    : 5;
		unsigned int   n: 1;
		signed int   d26:26;
	} br;

	struct {
		unsigned int      : 4;
		unsigned int isbb1: 1;	/* isbb1==0 means bb0, isbb1==1 means bb1 */
		unsigned int   n  : 1;
		unsigned int  b5  : 5;
		unsigned int  s1  : 5;
		signed   int  d16 :16;
	} bb; /* bcnd too, except "isbb1" makes no sense for bcnd */

	struct {
		unsigned int      : 6;
		unsigned int  b5  : 5;
		unsigned int  s1  : 5;
		unsigned int      : 7;
		unsigned int vec9 : 9;
	} tb; /* tcnd too */

	struct {
		unsigned int      :21;
		unsigned int    n : 1;
		unsigned int      : 5;
		unsigned int   s2 : 5;
	} jump;	/* jmp, jsr */

	struct {
		unsigned int      : 6;
		unsigned int    d : 5;
		unsigned int   s1 : 5;
		unsigned int  i16 :16;
	} diatic;   /* general reg/reg/i16 instructions */

	struct {
		unsigned int      : 6;
		unsigned int    d : 5;
		unsigned int   s1 : 5;
		unsigned int      :11;
		unsigned int   s2 : 5;
	} triatic;  /* general reg/reg/reg instructions */
d92 1
a92 1
	return addr + inst.br.d26 * 4;
d103 1
a103 1
			     db_expr_t count, char *modif));
d149 2
a150 1
db_setf_regs(struct db_variable      *vp,
d154 1
a154 1
	register int   *regp = (int *) ((char *) DDB_REGS + (int) (vp->valuep));
d156 4
a159 4
	if (op == DB_VAR_GET)
		*valuep = *regp;
	else if (op == DB_VAR_SET)
		*regp = *valuep;
d161 1
a161 1
	return (0); /* silence warning */
d167 17
a183 17
	N("r1", r[1]),     N("r2", r[2]),    N("r3", r[3]),    N("r4", r[4]),
	N("r5", r[5]),     N("r6", r[6]),    N("r7", r[7]),    N("r8", r[8]),
	N("r9", r[9]),     N("r10", r[10]),  N("r11", r[11]),  N("r12", r[12]),
	N("r13", r[13]),   N("r14", r[14]),  N("r15", r[15]),  N("r16", r[16]),
	N("r17", r[17]),   N("r18", r[18]),  N("r19", r[19]),  N("r20", r[20]),
	N("r21", r[21]),   N("r22", r[22]),  N("r23", r[23]),  N("r24", r[24]),
	N("r25", r[25]),   N("r26", r[26]),  N("r27", r[27]),  N("r28", r[28]),
	N("r29", r[29]),   N("r30", r[30]),  N("r31", r[31]),  N("epsr", epsr),
	N("sxip", sxip),   N("snip", snip),  N("sfip", sfip),  N("ssbr", ssbr),
	N("dmt0", dmt0),   N("dmd0", dmd0),  N("dma0", dma0),  N("dmt1", dmt1),
	N("dmd1", dmd1),   N("dma1", dma1),  N("dmt2", dmt2),  N("dmd2", dmd2),
	N("dma2", dma2),   N("fpecr", fpecr),N("fphs1", fphs1),N("fpls1", fpls1),
	N("fphs2", fphs2), N("fpls2", fpls2),N("fppt", fppt),  N("fprh", fprh),
	N("fprl", fprl),   N("fpit", fpit),  N("fpsr", fpsr),  N("fpcr", fpcr),
	N("mask", mask), /* interrupt mask */
	N("mode", mode), /* interrupt mode */
	N("exvc", vector), /* exception vector */
d206 41
a246 42
	static struct {
		unsigned mask, value, flags;
	} *ptr, control[] = {
		/* runs in the same order as 2nd Ed 88100 manual Table 3-14 */
		{ 0xf0000000U, 0x00000000U, /* xmem */     TRASHES | STORE | LOAD},
		{ 0xec000000U, 0x00000000U, /* ld.d */     TRASHES | LOAD | DOUBLE},
		{ 0xe0000000U, 0x00000000U, /* load */     TRASHES | LOAD},
		{ 0xfc000000U, 0x20000000U, /* st.d */     STORE | DOUBLE},
		{ 0xf0000000U, 0x20000000U, /* store */    STORE},
		{ 0xc0000000U, 0x40000000U, /* arith */    TRASHES},
		{ 0xfc004000U, 0x80004000U, /* ld cr */    TRASHES},
		{ 0xfc004000U, 0x80000000U, /* st cr */    0},
		{ 0xfc008060U, 0x84000000U, /* f */        TRASHES},
		{ 0xfc008060U, 0x84000020U, /* f.d */      TRASHES | DOUBLE},
		{ 0xfc000000U, 0xcc000000U, /* bsr.n */    FLOW_CTRL | DELAYED | BSR},
		{ 0xfc000000U, 0xc8000000U, /* bsr */      FLOW_CTRL | BSR},
		{ 0xe4000000U, 0xc4000000U, /* br/bb.n */  FLOW_CTRL | DELAYED},
		{ 0xe4000000U, 0xc0000000U, /* br/bb */    FLOW_CTRL},
		{ 0xfc000000U, 0xec000000U, /* bcnd.n */   FLOW_CTRL | DELAYED},
		{ 0xfc000000U, 0xe8000000U, /* bcnd */     FLOW_CTRL},
		{ 0xfc00c000U, 0xf0008000U, /* bits */     TRASHES},
		{ 0xfc00c000U, 0xf000c000U, /* trap */     0},
		{ 0xfc00f0e0U, 0xf4002000U, /* st */       0},
		{ 0xfc00cce0U, 0xf4000000U, /* ld.d */     TRASHES | DOUBLE},
		{ 0xfc00c0e0U, 0xf4000000U, /* ld */       TRASHES},
		{ 0xfc00c0e0U, 0xf4004000U, /* arith */    TRASHES},
		{ 0xfc00c3e0U, 0xf4008000U, /* bits */     TRASHES},
		{ 0xfc00ffe0U, 0xf400cc00U, /* jsr.n */    FLOW_CTRL | DELAYED | JSR},
		{ 0xfc00ffe0U, 0xf400c800U, /* jsr */      FLOW_CTRL | JSR},
		{ 0xfc00ffe0U, 0xf400c400U, /* jmp.n */    FLOW_CTRL | DELAYED},
		{ 0xfc00ffe0U, 0xf400c000U, /* jmp */      FLOW_CTRL},
		{ 0xfc00fbe0U, 0xf400e800U, /* ff */       TRASHES},
		{ 0xfc00ffe0U, 0xf400f800U, /* tbnd */     0},
		{ 0xfc00ffe0U, 0xf400fc00U, /* rte */      FLOW_CTRL},
		{ 0xfc000000U, 0xf8000000U, /* tbnd */     0},
	};
#define ctrl_count (sizeof(control)/sizeof(control[0]))
	for (ptr = &control[0]; ptr < &control[ctrl_count]; ptr++)
		if ((instruction & ptr->mask) == ptr->value)
			return ptr->flags;
	SHOW_INSTRUCTION(0, instruction, "bad m88k_instruction_info");
	return 0;
d252 4
a255 4
	int i;
	unsigned last = 0;
	unsigned char c; 
	unsigned have_a_hex_digit = 0;
d257 2
a258 2
	if (value <= 9)
		return 0;
d260 13
a272 13
	for (i = 0; i < 8; i++) {
		c = value & 0xf;
		value >>= 4;
		if (c)
			last = c;
		if (c > 9)
			have_a_hex_digit = 1;
	}
	if (have_a_hex_digit == 0)
		return 1;
	if (last > 9)
		return 1;
	return 0;
d275 1
d286 3
a288 5
	/* no good if we can't read the whole frame */
	if (badwordaddr((vm_offset_t)regs) || badwordaddr((vm_offset_t)&regs->mode)) {
		db_printf("[WARNING: frame at 0x%x : unreadable]\n", regs);
		return 0;
	}
d291 4
a294 6
	/* disabled for now  -- see fpu_enable in luna88k/eh.s */
	/* r0 must be 0 (obviously) */
	if (regs->r[0] != 0) {
		db_printf("[WARNING: frame at 0x%x : r[0] != 0]\n", regs);
		return 0;
	}
d297 3
a299 5
	/* stack sanity ... r31 must be nonzero, but must be word aligned */
	if (regs->r[31] == 0 || (regs->r[31] & 3) != 0) {
		db_printf("[WARNING: frame at 0x%x : r[31] == 0 or not word aligned]\n", regs);
		return 0;
	}
d301 1
a301 2
	if (cputyp != CPU_88110) {
		/* sxip is reasonable */
d303 2
a304 2
		if ((regs->sxip & 1) == 1)
			return 0;
d306 6
a311 7
		/* snip is reasonable */
		if ((regs->snip & 3) != 2)
			return 0;
		/* sfip is reasonable */
		if ((regs->sfip & 3) != 2)
			return 0;
	}
d313 16
a328 15
	/* epsr sanity */
	if ((regs->epsr & PSR_MODE)) { /* kernel mode */
		if (regs->epsr & PSR_BO)
			db_printf("[WARNING: byte order in kernel frame at %x "
				  "is little-endian!]\n", regs);
		return 1;
	}
	if (!(regs->epsr & PSR_MODE)) {	/* user mode */
		if (regs->epsr & PSR_BO)
			db_printf("[WARNING: byte order in user frame at %x "
				  "is little-endian!]\n", regs);
		return 2;
	}
	db_printf("[WARNING: not an exception frame?]\n");
	return 0;
d334 1
a334 1
	switch (vector) {
a346 1
	case  11: return "Non Maskable Interrupt";
d356 1
a356 1
	}
d366 16
a381 16
	label_t db_jmpbuf;
	label_t *prev = db_recover;
	boolean_t old_quiet_db_read_bytes = quiet_db_read_bytes;

	quiet_db_read_bytes = 1;

	if (setjmp((db_recover = &db_jmpbuf)) != 0) {
		db_recover = prev;
		quiet_db_read_bytes = old_quiet_db_read_bytes;
		return 0;
	} else {
		db_read_bytes(addr, 4, (char*)ptr);
		db_recover = prev;
		quiet_db_read_bytes = old_quiet_db_read_bytes;
		return 1;
	}
d401 1
a401 1
#ifdef TRACE_DEBUG
d403 10
a412 10
#endif
	if (trashed_list & reg_bit(reg)) {
#ifdef TRACE_DEBUG
		if (DEBUGGING_ON) db_printf("<trashed>\n");
#endif
		return;	/* don't save trashed registers */
	}
	saved_reg[(reg%32)] = value;
	global_saved_list |= reg_bit(reg);
	local_saved_list  |= reg_bit(reg);
d431 1
a431 1
	int reg, last_arg;
d433 24
a456 24
	/* find the highest argument register saved */
	for (last_arg = LAST_ARG_REG; last_arg >= FIRST_ARG_REG; last_arg--)
		if (have_local_reg(last_arg))
			break;
	if (last_arg < FIRST_ARG_REG)
		return;	/* none were saved */

	db_printf("(");

	/* print each one, up to the highest */
	for (reg = FIRST_ARG_REG; /*nothing */; reg++) {
		if (!have_local_reg(reg))
			db_printf("?");
		else {
			unsigned value = saved_reg_value(reg);
			db_printf("%s%x", hex_value_needs_0x(value) ? 
				  "0x" : "", value);
		}
		if (reg == last_arg)
			break;
		else
			db_printf(", ");
	}
	db_printf(")");
d488 2
a489 27
	unsigned flags;
	union instruction instruction; 

	/*
	 * Delayed branches are most common... look two instructions before
	 * where we were going to return to to see if it's a delayed branch.
	 */
	if (!db_trace_get_val(return_to - 8, &instruction.rawbits))
		return JUMP_SOURCE_IS_BAD;
	flags = m88k_instruction_info(instruction.rawbits);

	if ((flags & FLOW_CTRL) && (flags & DELAYED) && (flags & (JSR|BSR))) {
		if (flags & JSR)
			return JUMP_SOURCE_IS_OK; /* have to assume it's correct */
		/* calculate the offset */
		if (br_dest(return_to - 8, instruction) == jump_to)
			return JUMP_SOURCE_IS_OK; /* exactamundo! */
		else
			return JUMP_SOURCE_IS_UNLIKELY;	/* seems wrong */
	}

	/*
	 * Try again, looking for a non-delayed jump one back.
	 */
	if (!db_trace_get_val(return_to - 4, &instruction.rawbits))
		return JUMP_SOURCE_IS_BAD;
	flags = m88k_instruction_info(instruction.rawbits);
d491 34
a524 9
	if ((flags & FLOW_CTRL) && !(flags & DELAYED) && (flags & (JSR|BSR))) {
		if (flags & JSR)
			return JUMP_SOURCE_IS_OK; /* have to assume it's correct */
		/* calculate the offset */
		if (br_dest(return_to - 4, instruction) == jump_to)
			return JUMP_SOURCE_IS_OK; /* exactamundo! */
		else
			return JUMP_SOURCE_IS_UNLIKELY;	/* seems wrong */
	}
d526 1
a526 1
	return JUMP_SOURCE_IS_UNLIKELY;
d557 40
a596 21
	db_sym_t proc;
	unsigned offset_from_proc;
	unsigned instructions_to_search;
	unsigned check_addr;
	unsigned function_addr;	    /* start of function */
	unsigned r31 = *stack;	    /* the r31 of the function */
	unsigned inst;		    /* text of an instruction */
	unsigned ret_addr;	    /* address to which we return */
	unsigned tried_to_save_r1 = 0;

#ifdef TRACE_DEBUG
	if (DEBUGGING_ON)
		db_printf("\n>>>stack_decode(addr=%x, stack=%x)\n",
			  addr, *stack);
#endif

	/* get what we hope will be the db_sym_t for the function name */
	proc = db_search_symbol(addr, DB_STGY_PROC, &offset_from_proc);
	if (offset_from_proc == addr) /* i.e. no symbol found */
		proc = DB_SYM_NULL;

d598 2
a599 3
	 * Somehow, find the start of this function.
	 * If we found a symbol above, it'll have the address.
	 * Otherwise, we've got to search for it....
d601 4
a604 18
	if (proc != DB_SYM_NULL) {
		char *names;
		db_symbol_values(proc, &names, &function_addr);
		if (names == 0)
			return 0;
#ifdef TRACE_DEBUG
		if (DEBUGGING_ON) db_printf("name %s address 0x%x\n",
					    names, function_addr);
#endif
	} else {
		int instructions_to_check = 400;
		/*
		 * hmm - unable to find symbol. Search back
		 * looking for a function prolog.
		 */
		for (check_addr = addr; instructions_to_check-- > 0; check_addr -= 4) {
			if (!db_trace_get_val(check_addr, &inst))
				break;
d606 35
a640 71
			if (SUBU_R31_R31_IMM(inst)) {
#if 0
				/*
				 * If the next instruction is "st r1, r31, ####"
				 * then we can feel safe we have the start of
				 * a function.
				 */
				if (!db_trace_get_val(check_addr + 4, &inst))
					continue;
				if (ST_R1_R31_IMM(instr))
					break; /* sucess */
#else
				/*
				 * Latest GCC optimizer is just too good... the store
				 * of r1 might come much later... so we'll have to
				 * settle for just the "subr r31, r31, ###" to mark
				 * the start....
				 */
				break;
#endif
			}
			/*
			 * if we come across a [jmp r1] or [jmp.n r1] assume we have hit
			 * the previous functions epilogue and stop our search.
			 * Since we know we would have hit the "subr r31, r31" if it was
			 * right in front of us, we know this doesn't have one so
			 * we just return failure....
			 */
			if (JMP_R1(inst) || JMPN_R1(inst)) {
#ifdef TRACE_DEBUG
				if (DEBUGGING_ON)
					db_printf("ran into a [jmp r1] at %x (addr=%x)\n",
						  check_addr, addr);
#endif
				return 0;
			}
		}
		if (instructions_to_check < 0) {
#ifdef TRACE_DEBUG
			if (DEBUGGING_ON)
				db_printf("couldn't find func start (addr=%x)\n", addr);
#endif
			return 0; /* bummer, couldn't find it */
		}
		function_addr = check_addr;
	}

	/*
	 * We now know the start of the function (function_addr).
	 * If we're stopped right there, or if it's not a
	 *		subu r31, r31, ####
	 * then we're done.
	 */
	if (addr == function_addr) {
#ifdef TRACE_DEBUG
		if (DEBUGGING_ON) db_printf("at start of func\n");
#endif
		return 0;
	}
	if (!db_trace_get_val(function_addr, &inst)) {
#ifdef TRACE_DEBUG
		if (DEBUGGING_ON) db_printf("couldn't read %x at line %d\n",
					    function_addr, __LINE__);
#endif
		return 0;
	}
	SHOW_INSTRUCTION(function_addr, inst, "start of function: ");
	if (!SUBU_R31_R31_IMM(inst)) {
#ifdef TRACE_DEBUG
		if (DEBUGGING_ON) db_printf("<not subu,r31,r31,imm>\n");
#endif
d642 1
d644 36
d681 2
a682 2
	/* add the size of this frame to the stack (for the next frame) */
	*stack += IMM16VAL(inst);
d684 16
a699 9
	/*
	 * Search from the beginning of the function (funstart) to where we are
	 * in the function (addr) looking to see what kind of registers have
	 * been saved on the stack.
	 *
	 * We'll stop looking before we get to ADDR if we hit a branch.
	 */
	clear_local_saved_regs();
	check_addr = function_addr + 4;	/* we know the first inst isn't a store */
d701 7
a707 47
	for (instructions_to_search = (addr - check_addr)/sizeof(long);
	    instructions_to_search-- > 0;
	    check_addr += 4) {
		union instruction instruction;
		unsigned flags;

		/* read the instruction */
		if (!db_trace_get_val(check_addr, &instruction.rawbits)) {
#ifdef TRACE_DEBUG
			if (DEBUGGING_ON) db_printf("couldn't read %x at line %d\n",
						    check_addr, __LINE__);
#endif
			break;
		}

		SHOW_INSTRUCTION(check_addr, instruction.rawbits, "prolog: ");

		/* find out the particulars about this instruction */
		flags = m88k_instruction_info(instruction.rawbits);

		/* if a store to something off the stack pointer, note the value */
		if ((flags & STORE) && instruction.diatic.s1 ==	/*stack pointer*/31) {
			unsigned value;
			if (!have_local_reg(instruction.diatic.d)) {
				if (instruction.diatic.d == 1)
					tried_to_save_r1 = r31 + instruction.diatic.i16 ;
				if (db_trace_get_val(r31 + instruction.diatic.i16, &value))
					save_reg(instruction.diatic.d, value);
			}
			if ((flags & DOUBLE) && !have_local_reg(instruction.diatic.d + 1)) {
				if (instruction.diatic.d == 0)
					tried_to_save_r1 = r31+instruction.diatic.i16 +4;
				if (db_trace_get_val(r31+instruction.diatic.i16 +4, &value))
					save_reg(instruction.diatic.d + 1, value);
			}
		}

		/* if an inst that kills D (and maybe D+1), note that */
		if (flags & TRASHES) {
			mark_reg_trashed(instruction.diatic.d);
			if (flags & DOUBLE)
				mark_reg_trashed(instruction.diatic.d + 1);
		}

		/* if a flow control instruction, stop now (or next if delayed) */
		if ((flags & FLOW_CTRL) && instructions_to_search != 0)
			instructions_to_search = (flags & DELAYED) ? 1 : 0;
d710 1
a710 13
	/*
	 * If we didn't save r1 at some point, we're hosed.
	 */
	if (!have_local_reg(1)) {
		if (tried_to_save_r1) {
			db_printf("    <return value of next fcn unreadable in %08x>\n",
				  tried_to_save_r1);
		}
#ifdef TRACE_DEBUG
		if (DEBUGGING_ON) db_printf("didn't save r1\n");
#endif
		return 0;
	}
d712 2
a713 1
	ret_addr = saved_reg_value(1);
d715 43
a757 5
#ifdef TRACE_DEBUG
	if (DEBUGGING_ON)
		db_printf("Return value is = %x, function_addr is %x.\n",
			  ret_addr, function_addr);
#endif
d759 1
a759 12
	/*
	 * In support of this, continuation.s puts the low bit on the
	 * return address for continuations (the return address will never
	 * be used, so it's ok to do anything you want to it).
	 */
	if (ret_addr & 1) {
		note = "<<can not trace past a continuation>>";
		ret_addr = 0;
	} else if (ret_addr != 0x00) {
		switch (is_jump_source_ok(ret_addr, function_addr)) {
		case JUMP_SOURCE_IS_OK:
			break; /* excellent */
d761 24
a784 5
		case JUMP_SOURCE_IS_BAD:
#ifdef TRACE_DEBUG
			if (DEBUGGING_ON) db_printf("jump is bad\n");
#endif
			return 0; /* bummer */
d786 3
a788 4
		case JUMP_SOURCE_IS_UNLIKELY:
			next_address_likely_wrong = 1;;
			break;
		}
d790 1
d792 1
a792 1
	return ret_addr;
d798 54
a851 6
	unsigned stack;
	unsigned depth=1;
	unsigned where;
	unsigned ft;
	unsigned pair[2];
	int i;
d853 2
d856 4
a859 5
	 * Frame_is_sane returns:
	 *   1 if regs seems to be a reasonable kernel exception frame.
	 *   2 if regs seems to be a reasonable user exception frame
	 *      (in the current task).
	 *   0 if this looks like neither.
d861 21
a881 3
	if (ft = frame_is_sane(regs), ft == 0) {
		db_printf("Register frame 0x%x is suspicous; skipping trace\n", regs);
		return;
d884 2
a885 3
	/* if user space and no user space trace specified, puke */
	if (ft == 2 && !(trace_flags & TRACE_USER_FLAG))
		return;
a886 12
	/* fetch address */
	/* use sxip if valid, otherwise try snip or sfip */
	if (cputyp == CPU_88110) {
		where = regs->exip & ~3;
	} else {
		where = ((regs->sxip & 2) ? regs->sxip :
			 ((regs->snip & 2) ? regs->snip :
			  regs->sfip) ) & ~3;
	}
	stack = regs->r[31];
	db_printf("stack base = 0x%x\n", stack);
	db_printf("(0) "); /*depth of trace */
d888 1
a888 1
		db_printf("%08x ", where);
d890 4
a893 11
	clear_global_saved_regs();

	/* see if this routine had a stack frame */
	if ((where=stack_decode(where, &stack))==0) {
		where = regs->r[1];
		db_printf("(stackless)");
	} else {
		print_args();
		if (trace_flags & TRACE_SHOWFRAME_FLAG)
			db_printf(" [frame 0x%x]", stack);
	}
d896 2
a897 2
		db_printf("   %s\n", note);
		note = 0;
d899 1
d901 1
a901 47
	do {
		/*
		 * If requested, show preserved registers at the time
		 * the next-shown call was made. Only registers known to have
		 * changed from the last exception frame are shown, as others
		 * can be gotten at by looking at the exception frame.
		 */
		if (trace_flags & TRACE_SHOWCALLPRESERVED_FLAG) {
			int r, title_printed = 0;

			for (r = FIRST_CALLPRESERVED_REG; r<=LAST_CALLPRESERVED_REG; r++) {
				if (have_global_reg(r)) {
					unsigned value = saved_reg_value(r);
					if (title_printed == 0) {
						title_printed = 1;
						db_printf("[in next func:");
					}
					if (value == 0)
						db_printf(" r%d", r);
					else if (value <= 9)
						db_printf(" r%d=%x", r, value);
					else
						db_printf(" r%d=x%x", r, value);
				}
			}
			if (title_printed)
				db_printf("]\n");
		}

		db_printf("(%d)%c", depth++, next_address_likely_wrong ? '?':' ');
		next_address_likely_wrong = 0;

		if (trace_flags & TRACE_SHOWADDRESS_FLAG)
			db_printf("%08x ", where);
		db_printsym(where, DB_STGY_PROC);
		where = stack_decode(where, &stack);
		print_args();
		if (trace_flags & TRACE_SHOWFRAME_FLAG)
			db_printf(" [frame 0x%x]", stack);
		db_printf("\n");
		if (note) {
			db_printf("   %s\n", note);
			note = 0;
		}
	} while (where);

	/* try to trace back over trap/exception */
d903 2
a904 2
	stack &= ~7; /* double word aligned */
	/* take last top of stack, and try to find an exception frame near it */
d906 1
a906 1
	i = FRAME_PLAY;
d908 1
a908 1
#ifdef TRACE_DEBUG
d910 2
a911 60
		db_printf("(searching for exception frame at 0x%x)\n", stack);
#endif

	while (i) {
		/*
		 * On the stack, a pointer to the exception frame is written
		 * in two adjacent words. In the case of a fault from the kernel,
		 * this should point to the frame right above them:
		 *
		 * Exception Frame Top
		 * ..
		 * Exception Frame Bottom  <-- frame addr
		 * frame addr
		 * frame addr		<-- stack pointer
		 *
		 * In the case of a fault from user mode, the top of stack
		 * will just have the address of the frame
		 * replicated twice.
		 *
		 * frame addr		<-- top of stack
		 * frame addr
		 *
		 * Here we are just looking for kernel exception frames.
		 */

		if (badwordaddr((vm_offset_t)stack) ||
		    badwordaddr((vm_offset_t)(stack+4)))
			break;

		db_read_bytes((vm_offset_t)stack, 2*sizeof(int), (char*)pair);

		/* the pairs should match and equal stack+8 */
		if (pair[0] == pair[1]) {
			if (pair[0] != stack+8) {
				/*
				if (!badwordaddr((vm_offset_t)pair[0]) && (pair[0]!=0))
				db_printf("stack_trace:found pair 0x%x but != to stack+8\n",
				pair[0]);
				*/
				
			}

			else if (frame_is_sane((db_regs_t*)pair[0])) {
				db_regs_t *frame = (db_regs_t *) pair[0];
				char *cause = m88k_exception_name(frame -> vector);

				db_printf("-------------- %s [EF: 0x%x] -------------\n",
					  cause, frame);
				db_stack_trace_cmd2(frame);
				return;
			}
#ifdef TRACE_DEBUG
			else if (DEBUGGING_ON)
				db_printf("pair matched, but frame at 0x%x looks insane\n",
					  stack+8);
#endif
		}
		stack += 8;
		i--;
	}
d913 2
d916 18
a933 4
	 * If we go here, crawling back on the stack failed to find us
	 * a previous exception frame. Look for a user frame pointer
	 * pointed to by a word 8 bytes off of the top of the stack
	 * if the "u" option was specified.
a934 2
	if (trace_flags & TRACE_USER_FLAG) {
		db_regs_t *user;
d936 68
a1003 21
		/* Make sure we are back on the right page */
		stack -= 4*FRAME_PLAY;
		stack = stack & ~(KERNEL_STACK_SIZE-1);	/* point to the bottom */
		stack += KERNEL_STACK_SIZE - 8;

		if (badwordaddr((vm_offset_t)stack) ||
		    badwordaddr((vm_offset_t)stack))
			return;

		db_read_bytes((vm_offset_t)stack, 2*sizeof(int), (char*)pair);
		if (pair[0] != pair[1])
			return;

		/* have a hit */
		user = *((db_regs_t **) stack);

		if (frame_is_sane(user) == 2) {
			db_printf("---------------- %s [EF : 0x%x] -------------\n",
				  m88k_exception_name(user->vector), user);
			db_stack_trace_cmd2(user);
		}
d1005 1
d1015 5
a1019 4
db_stack_trace_cmd(db_regs_t *addr,
		   int have_addr,
		   db_expr_t count,
		   char *modif)
d1021 73
a1093 23
	enum {
		Default, Stack, Proc, Frame
	} style = Default;
	db_regs_t frame; /* a m88100_saved_state */
	db_regs_t *regs;
	union {
		db_regs_t *frame;
		struct proc *proc;
		unsigned num;
	} arg;
	arg.frame = addr;

	trace_flags = 0; /* flags will be set via modifers */

	while (modif && *modif) {
		switch (*modif++) {
		case 'd':
#ifdef TRACE_DEBUG
			trace_flags |= TRACE_DEBUG_FLAG;
#else
			db_printtf("<debug trace not compiled in, ignoring>\n");
#endif
			break;
d1095 10
a1104 23
		case 's': style = Stack  ; break;
		case 'f': style = Frame  ; break;
		case 'p': trace_flags |= TRACE_SHOWCALLPRESERVED_FLAG; break;
		case 'a': trace_flags |= TRACE_SHOWADDRESS_FLAG; break;
		case 'F': trace_flags |= TRACE_SHOWFRAME_FLAG; break;
		case 'u': trace_flags |= TRACE_USER_FLAG; break;
		default:
			db_printf("unknown trace modifier [%c]\n", modif[-1]);
			/*FALLTHROUGH*/
		case 'h':
			db_printf("usage: trace/[MODIFIER]  [ARG]\n");
			db_printf("  u = include user trace\n");
			db_printf("  F = print stack frames\n");
			db_printf("  a = show return addresses\n");
			db_printf("  p = show call-preserved registers\n");
			db_printf("  s = ARG is a stack pointer\n");
			db_printf("  f = ARG is a frame pointer\n");
#ifdef TRACE_DEBUG
			db_printf("  d = trace-debugging output\n");
#endif
			return;
		}
	}
d1106 13
a1118 2
	if (!have_addr && style != Default) {
		db_printf("expecting argument with /s or /f\n");
d1120 32
a1152 2
	if (have_addr && style == Default)
		style = Proc;
d1154 11
a1164 86
	switch (style) {
	case Default:
		regs = DDB_REGS;
		break;
	case Frame:
		regs = arg.frame;
		break;
	case Proc:
		break;
	case Stack:
		{
			unsigned val1, val2, sxip;
			unsigned ptr;
			bzero((void*)&frame, sizeof(frame));
#define REASONABLE_FRAME_DISTANCE 2048

			/*
			 * We've got to find the top of a stack frame so we can get both
			 * a PC and and real SP.
			 */
			for (ptr = arg.num;/**/; ptr += 4) {
				/* Read a word from the named stack */
				if (db_trace_get_val(ptr, &val1) == 0) {
					db_printf("can't read from %x, aborting.\n", ptr);
					return;
				}

				/*
				 * See if it's a frame pointer.... if so it will be larger than
				 * the address it was taken from (i.e. point back up the stack)
				 * and we'll be able to read where it points.
				 */
				if (val1 <= ptr ||
				    (val1 & 3)  ||
				    val1 > (ptr + REASONABLE_FRAME_DISTANCE))
					continue;

				/* peek at the next word to see if it could be a return address */
				if (db_trace_get_val(ptr, &sxip) == 0) {
					db_printf("can't read from %x, aborting.\n", ptr);
					return;
				}
				if (sxip == 0 || !db_trace_get_val(sxip, &val2))
					continue;

				if (db_trace_get_val(val1, &val2) == 0) {
					db_printf("can't read from %x, aborting.\n", val1);
					continue;
				}

				/*
				 * The value we've just read will be either another frame pointer,
				 * or the start of another exception frame.
				 */
				if (
#ifdef JEFF_DEBUG
				   val2 == 0
#else
				   val2 == 0x12345678
#endif
				   && db_trace_get_val(val1-4, &val2) && val2 == val1
				   && db_trace_get_val(val1-8, &val2) && val2 == val1) {
					/* we've found a frame, so the stack must have been good */
					db_printf("%x looks like a frame, accepting %x\n",val1,ptr);
					break;
				}

				if (val2 > val1 && (val2 & 3) == 0) {
					/* well, looks close enough to be another frame pointer */
					db_printf("*%x = %x looks like a stack frame pointer, accepting %x\n", val1, val2, ptr);
					break;
				}
			}
                        frame.r[31] = ptr;
			frame.epsr = 0x800003f0U;
			if (cputyp != CPU_88110) {
				frame.sxip = sxip | 2;
				frame.snip = frame.sxip + 4;
				frame.sfip = frame.snip + 4;
			}
			db_printf("[r31=%x, %sxip=%x]\n", frame.r[31],
				  cputyp == CPU_88110 ? "e" : "s", frame.sxip);
			regs = &frame;
		}
	}
	db_stack_trace_cmd2(regs);
a1165 1

@


1.5.6.4
log
@Merge in -current from about a week ago
@
text
@d98 6
a103 6
extern void db_read_bytes(vm_offset_t addr, int size, char *data);
int frame_is_sane(db_regs_t *regs);
char *m88k_exception_name(unsigned vector);
unsigned db_trace_get_val(vm_offset_t addr, unsigned *ptr);
void db_stack_trace_cmd(db_regs_t *addr, int have_addr,
			     db_expr_t count, char *modif);
d384 1
a384 1
		db_read_bytes(addr, 4, (char *)ptr);
d937 1
a937 1
		db_read_bytes((vm_offset_t)stack, 2*sizeof(int), (char *)pair);
d987 1
a987 1
		db_read_bytes((vm_offset_t)stack, 2*sizeof(int), (char *)pair);
d1082 1
a1082 1
			bzero((void *)&frame, sizeof(frame));
@


1.5.6.5
log
@Sync the SMP branch with 3.3
@
text
@d102 2
a103 2
void db_stack_trace_print(db_regs_t *addr, int have_addr,
    db_expr_t count, char *modif, int (*pr)(const char *, ...));
d562 1
a562 1
stack_decode(unsigned addr, unsigned *stack, int (*pr)(const char *, ...))
d576 1
a576 1
		(*pr)("\n>>>stack_decode(addr=%x, stack=%x)\n",
d596 1
a596 1
		if (DEBUGGING_ON) (*pr)("name %s address 0x%x\n",
d619 1
a619 1
					break; /* success */
d640 1
a640 1
					(*pr)("ran into a [jmp r1] at %x (addr=%x)\n",
d649 1
a649 1
				(*pr)("couldn't find func start (addr=%x)\n", addr);
d664 1
a664 1
		if (DEBUGGING_ON) (*pr)("at start of func\n");
d670 1
a670 1
		if (DEBUGGING_ON) (*pr)("couldn't read %x at line %d\n",
d678 1
a678 1
		if (DEBUGGING_ON) (*pr)("<not subu,r31,r31,imm>\n");
d705 1
a705 1
			if (DEBUGGING_ON) (*pr)("couldn't read %x at line %d\n",
d750 1
a750 1
			(*pr)("    <return value of next fcn unreadable in %08x>\n",
d754 1
a754 1
		if (DEBUGGING_ON) (*pr)("didn't save r1\n");
d763 1
a763 1
		(*pr)("Return value is = %x, function_addr is %x.\n",
d782 1
a782 1
			if (DEBUGGING_ON) (*pr)("jump is bad\n");
d796 1
a796 1
db_stack_trace_cmd2(db_regs_t *regs, int (*pr)(const char *, ...))
d813 1
a813 1
		(*pr)("Register frame 0x%x is suspicous; skipping trace\n", regs);
d831 2
a832 2
	(*pr)("stack base = 0x%x\n", stack);
	(*pr)("(0) "); /*depth of trace */
d834 2
a835 2
		(*pr)("%08x ", where);
	db_printsym(where, DB_STGY_PROC, pr);
d839 1
a839 1
	if ((where=stack_decode(where, &stack, pr))==0) {
d841 1
a841 1
		(*pr)("(stackless)");
d845 1
a845 1
			(*pr)(" [frame 0x%x]", stack);
d847 1
a847 1
	(*pr)("\n");
d849 1
a849 1
		(*pr)("   %s\n", note);
d868 1
a868 1
						(*pr)("[in next func:");
d871 1
a871 1
						(*pr)(" r%d", r);
d873 1
a873 1
						(*pr)(" r%d=%x", r, value);
d875 1
a875 1
						(*pr)(" r%d=x%x", r, value);
d879 1
a879 1
				(*pr)("]\n");
d882 1
a882 1
		(*pr)("(%d)%c", depth++, next_address_likely_wrong ? '?':' ');
d886 3
a888 3
			(*pr)("%08x ", where);
		db_printsym(where, DB_STGY_PROC, pr);
		where = stack_decode(where, &stack, pr);
d891 2
a892 2
			(*pr)(" [frame 0x%x]", stack);
		(*pr)("\n");
d894 1
a894 1
			(*pr)("   %s\n", note);
d908 1
a908 1
		(*pr)("(searching for exception frame at 0x%x)\n", stack);
d944 1
a944 1
				(*pr)("stack_trace:found pair 0x%x but != to stack+8\n",
d954 1
a954 1
				(*pr)("-------------- %s [EF: 0x%x] -------------\n",
d956 1
a956 1
				db_stack_trace_cmd2(frame, pr);
d961 1
a961 1
				(*pr)("pair matched, but frame at 0x%x looks insane\n",
d995 1
a995 1
			(*pr)("---------------- %s [EF : 0x%x] -------------\n",
d997 1
a997 1
			db_stack_trace_cmd2(user, pr);
d1009 1
a1009 1
db_stack_trace_print(db_regs_t *addr,
d1012 1
a1012 2
		   char *modif,
		   int (*pr)(const char *, ...))
d1045 1
a1045 1
			(*pr)("unknown trace modifier [%c]\n", modif[-1]);
d1048 7
a1054 7
			(*pr)("usage: trace/[MODIFIER]  [ARG]\n");
			(*pr)("  u = include user trace\n");
			(*pr)("  F = print stack frames\n");
			(*pr)("  a = show return addresses\n");
			(*pr)("  p = show call-preserved registers\n");
			(*pr)("  s = ARG is a stack pointer\n");
			(*pr)("  f = ARG is a frame pointer\n");
d1056 1
a1056 1
			(*pr)("  d = trace-debugging output\n");
d1063 1
a1063 1
		(*pr)("expecting argument with /s or /f\n");
d1092 1
a1092 1
					(*pr)("can't read from %x, aborting.\n", ptr);
d1108 1
a1108 1
					(*pr)("can't read from %x, aborting.\n", ptr);
d1115 1
a1115 1
					(*pr)("can't read from %x, aborting.\n", val1);
d1132 1
a1132 1
					(*pr)("%x looks like a frame, accepting %x\n",val1,ptr);
d1138 1
a1138 1
					(*pr)("*%x = %x looks like a stack frame pointer, accepting %x\n", val1, val2, ptr);
d1149 1
a1149 1
			(*pr)("[r31=%x, %sxip=%x]\n", frame.r[31],
d1154 1
a1154 1
	db_stack_trace_cmd2(regs, pr);
@


1.5.6.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d32 1
a32 1
#include <machine/db_machdep.h>
a38 2
#include <ddb/db_access.h>
#include <ddb/db_interface.h>
d98 2
a99 1
int frame_is_sane(db_regs_t *regs, int);
d101 3
a103 1
unsigned db_trace_get_val(vaddr_t addr, unsigned *ptr);
d120 1
a120 1
static int trace_flags;
d142 1
a142 1

d153 1
a153 1
	int   *regp = (int *) ((char *) DDB_REGS + (int) (vp->valuep));
d180 3
d205 1
a205 1
	static const struct {
d254 1
a254 1
	unsigned char c;
d283 1
a283 1
frame_is_sane(db_regs_t *regs, int quiet)
d286 2
a287 3
	if (badwordaddr((vaddr_t)regs) || badwordaddr((vaddr_t)&regs->fpit)) {
		if (quiet == 0)
			db_printf("[WARNING: frame at %p : unreadable]\n", regs);
d291 2
d295 1
a295 2
		if (quiet == 0)
			db_printf("[WARNING: frame at %p : r[0] != 0]\n", regs);
d298 1
d300 1
a300 1
	/* stack sanity ... r31 must be nonzero, and must be word aligned */
d302 1
a302 2
		if (quiet == 0)
			db_printf("[WARNING: frame at %p : r[31] == 0 or not word aligned]\n", regs);
d323 2
a324 1
			return 0;
d329 2
a330 1
			return 0;
d333 1
a333 2
	if (quiet == 0)
		db_printf("[WARNING: not an exception frame?]\n");
d371 1
a371 1
db_trace_get_val(vaddr_t addr, unsigned *ptr)
d375 3
d381 1
d386 1
d391 1
d455 1
a455 1
			db_printf("%s%x", hex_value_needs_0x(value) ?
d496 1
a496 1
	union instruction instruction;
d562 1
a562 1
stack_decode(db_addr_t addr, unsigned *stack, int (*pr)(const char *, ...))
d565 1
a565 1
	db_expr_t offset_from_proc;
d567 2
a568 2
	db_addr_t check_addr;
	db_addr_t function_addr;    /* start of function */
d787 1
a787 1
			next_address_likely_wrong = 1;
d812 2
a813 2
	if ((ft = frame_is_sane(regs, 1)) == 0) {
		(*pr)("Register frame 0x%x is suspicious; skipping trace\n", regs);
d933 2
a934 2
		if (badwordaddr((vaddr_t)stack) ||
		    badwordaddr((vaddr_t)(stack+4)))
d937 1
a937 1
		db_read_bytes((vaddr_t)stack, 2*sizeof(int), (char *)pair);
d943 1
a943 1
				if (!badwordaddr((vaddr_t)pair[0]) && (pair[0]!=0))
d947 1
d950 3
a952 3
			else if (frame_is_sane((db_regs_t*)pair[0], 1) != 0) {
				struct trapframe *frame =
				    (struct trapframe *)pair[0];
d955 2
a956 3
				    m88k_exception_name(frame->tf_vector),
				    frame);
				db_stack_trace_cmd2(&frame->tf_regs, pr);
d976 1
a976 1
		struct trapframe *user;
d983 2
a984 2
		if (badwordaddr((vaddr_t)stack) ||
		    badwordaddr((vaddr_t)stack))
d987 1
a987 1
		db_read_bytes((vaddr_t)stack, 2*sizeof(int), (char *)pair);
d992 1
a992 1
		user = *((struct trapframe **)stack);
d994 1
a994 1
		if (frame_is_sane(&user->tf_regs, 1) == 2) {
d996 2
a997 2
			    m88k_exception_name(user->tf_vector), user);
			db_stack_trace_cmd2(&user->tf_regs, pr);
d1009 1
a1009 1
db_stack_trace_print(db_expr_t addr,
d1016 1
a1016 1
		Default, Stack, Frame
d1018 1
a1018 1
	db_regs_t frame;
d1022 2
a1023 1
		db_expr_t num;
d1025 1
a1025 2

	arg.num = addr;
d1068 1
a1068 1
		style = Frame;
d1077 2
d1157 1
@


1.4
log
@Yet more DDB type correctness
@
text
@d1 1
@


1.3
log
@Cleanup after import. This also seems to bring up the current version.
@
text
@d149 1
a149 1
#define N(s, x)  {s, (int *)&(((db_regs_t *) 0)->x), db_setf_regs}
@


1.2
log
@This is a remove to get rid of the old mvme88k port which was incomplete
to replace it with a working version. The kernel compiles and works
at least.  The new version will be imported shortly.
@
text
@d29 1
a29 1
	unsigned rawbits;
d31 44
a74 46
	struct {
		unsigned int:5;
		unsigned int n:1;
		signed int d26:26;
	}       br;

	struct {
		unsigned int:4;
		unsigned int isbb1:1;	/* isbb1==0 means bb0, isbb1==1 means
					 * bb1 */
		unsigned int n:1;
		unsigned int b5:5;
		unsigned int s1:5;
		signed int d16:16;
	}       bb;		/* bcnd too, except "isbb1" makes no sense for
				 * bcnd */

	struct {
		unsigned int:6;
		unsigned int b5:5;
		unsigned int s1:5;
		unsigned int:7;
		unsigned int vec9:9;
	}       tb;		/* tcnd too */

	struct {
		unsigned int:21;
		unsigned int n:1;
		unsigned int:5;
		unsigned int s2:5;
	}       jump;		/* jmp, jsr */

	struct {
		unsigned int:6;
		unsigned int d:5;
		unsigned int s1:5;
		unsigned int i16:16;
	}       diatic;		/* general reg/reg/i16 instructions */

	struct {
		unsigned int:6;
		unsigned int d:5;
		unsigned int s1:5;
		unsigned int:11;
		unsigned int s2:5;
	}       triatic;	/* general reg/reg/reg instructions */
d78 1
a78 2
static inline unsigned 
br_dest(unsigned addr, union instruction inst)
d80 1
a80 1
	return addr + inst.br.d26 * 4;
d84 1
a84 1
#define TRACE_DEBUG		/* undefine to disable debugging */
d86 1
a86 2
#include <machine/db_machdep.h>	/* lots of stuff                  */
#include <setjmp.h>		/* jmp_buf, etc.                */
d107 1
a107 1
static  trace_flags = 0;
d115 1
a115 1
#define DEBUGGING_ON (trace_flags & TRACE_DEBUG_FLAG)
d119 1
a119 1
#define SHOW_INSTRUCTION(Addr, Inst, Note) 	{ /*nothing*/ }
d121 1
a121 1
#define SHOW_INSTRUCTION(Addr, Inst, Note) if (DEBUGGING_ON) { 	\
d128 1
a128 1
extern jmp_buf *db_recover;
d137 5
a141 5
    struct db_variable * vp,
    db_expr_t * valuep,
    int op)
{				/* read/write */
	register int *regp = (int *) ((char *) DDB_REGS + (int) (vp->valuep));
d143 4
a146 5
	if (op == DB_VAR_GET)
		*valuep = *regp;
	else
		if (op == DB_VAR_SET)
			*regp = *valuep;
d148 1
d152 17
a168 17
	N("r1", r[1]), N("r2", r[2]), N("r3", r[3]), N("r4", r[4]),
	N("r5", r[5]), N("r6", r[6]), N("r7", r[7]), N("r8", r[8]),
	N("r9", r[9]), N("r10", r[10]), N("r11", r[11]), N("r12", r[12]),
	N("r13", r[13]), N("r14", r[14]), N("r15", r[15]), N("r16", r[16]),
	N("r17", r[17]), N("r18", r[18]), N("r19", r[19]), N("r20", r[20]),
	N("r21", r[21]), N("r22", r[22]), N("r23", r[23]), N("r24", r[24]),
	N("r25", r[25]), N("r26", r[26]), N("r27", r[27]), N("r28", r[28]),
	N("r29", r[29]), N("r30", r[30]), N("r31", r[31]), N("epsr", epsr),
	N("sxip", sxip), N("snip", snip), N("sfip", sfip), N("ssbr", ssbr),
	N("dmt0", dmt0), N("dmd0", dmd0), N("dma0", dma0), N("dmt1", dmt1),
	N("dmd1", dmd1), N("dma1", dma1), N("dmt2", dmt2), N("dmd2", dmd2),
	N("dma2", dma2), N("fpecr", fpecr), N("fphs1", fphs1), N("fpls1", fpls1),
	N("fphs2", fphs2), N("fpls2", fpls2), N("fppt", fppt), N("fprh", fprh),
	N("fprl", fprl), N("fpit", fpit), N("fpsr", fpsr), N("fpcr", fpcr),
	N("mask", mask),	/* interrupt mask */
	N("mode", mode),	/* interrupt mode */
	N("exvc", vector),	/* exception vector */
d172 1
a172 1
struct db_variable *db_eregs = db_regs + sizeof(db_regs) / sizeof(db_regs[0]);
d191 41
a231 105
	static struct {
		unsigned mask, value, flags;
	}      *ptr, control[] =
	{
		/* runs in the same order as 2nd Ed 88100 manual Table 3-14 */
		{
			0xf0000000 U, 0x00000000 U, /* xmem */ TRASHES | STORE | LOAD
		}      ,
		{
			0xec000000 U, 0x00000000 U, /* ld.d */ TRASHES | LOAD | DOUBLE
		}      ,
		{
			0xe0000000 U, 0x00000000 U, /* load */ TRASHES | LOAD
		}      ,
		{
			0xfc000000 U, 0x20000000 U, /* st.d */ STORE | DOUBLE
		}      ,
		{
			0xf0000000 U, 0x20000000 U, /* store */ STORE
		}      ,
		{
			0xc0000000 U, 0x40000000 U, /* arith */ TRASHES
		}      ,
		{
			0xfc004000 U, 0x80004000 U, /* ld cr */ TRASHES
		}      ,
		{
			0xfc004000 U, 0x80000000 U, /* st cr */ 0
		}      ,
		{
			0xfc008060 U, 0x84000000 U, /* f */ TRASHES
		}      ,
		{
			0xfc008060 U, 0x84000020 U, /* f.d */ TRASHES | DOUBLE
		}      ,
		{
			0xfc000000 U, 0xcc000000 U, /* bsr.n */ FLOW_CTRL | DELAYED | BSR
		}      ,
		{
			0xfc000000 U, 0xc8000000 U, /* bsr */ FLOW_CTRL | BSR
		}      ,
		{
			0xe4000000 U, 0xc4000000 U, /* br/bb.n */ FLOW_CTRL | DELAYED
		}      ,
		{
			0xe4000000 U, 0xc0000000 U, /* br/bb */ FLOW_CTRL
		}      ,
		{
			0xfc000000 U, 0xec000000 U, /* bcnd.n */ FLOW_CTRL | DELAYED
		}      ,
		{
			0xfc000000 U, 0xe8000000 U, /* bcnd */ FLOW_CTRL
		}      ,
		{
			0xfc00c000 U, 0xf0008000 U, /* bits */ TRASHES
		}      ,
		{
			0xfc00c000 U, 0xf000c000 U, /* trap */ 0
		}      ,
		{
			0xfc00f0e0 U, 0xf4002000 U, /* st */ 0
		}      ,
		{
			0xfc00cce0 U, 0xf4000000 U, /* ld.d */ TRASHES | DOUBLE
		}      ,
		{
			0xfc00c0e0 U, 0xf4000000 U, /* ld */ TRASHES
		}      ,
		{
			0xfc00c0e0 U, 0xf4004000 U, /* arith */ TRASHES
		}      ,
		{
			0xfc00c3e0 U, 0xf4008000 U, /* bits */ TRASHES
		}      ,
		{
			0xfc00ffe0 U, 0xf400cc00 U, /* jsr.n */ FLOW_CTRL | DELAYED | JSR
		}      ,
		{
			0xfc00ffe0 U, 0xf400c800 U, /* jsr */ FLOW_CTRL | JSR
		}      ,
		{
			0xfc00ffe0 U, 0xf400c400 U, /* jmp.n */ FLOW_CTRL | DELAYED
		}      ,
		{
			0xfc00ffe0 U, 0xf400c000 U, /* jmp */ FLOW_CTRL
		}      ,
		{
			0xfc00fbe0 U, 0xf400e800 U, /* ff */ TRASHES
		}      ,
		{
			0xfc00ffe0 U, 0xf400f800 U, /* tbnd */ 0
		}      ,
		{
			0xfc00ffe0 U, 0xf400fc00 U, /* rte */ FLOW_CTRL
		}      ,
		{
			0xfc000000 U, 0xf8000000 U, /* tbnd */ 0
		}      ,
	};
#define ctrl_count (sizeof(control)/sizeof(control[0]))
	for (ptr = &control[0]; ptr < &control[ctrl_count]; ptr++)
		if ((instruction & ptr->mask) == ptr->value)
			return ptr->flags;
	SHOW_INSTRUCTION(0, instruction, "bad m88k_instruction_info");
	return 0;
d237 4
a240 4
	int     i;
	unsigned last = 0;
	unsigned char c;
	unsigned have_a_hex_digit = 0;
d242 2
a243 2
	if (value <= 9)
		return 0;
d245 13
a257 13
	for (i = 0; i < 8; i++) {
		c = value & 0xf;
		value >>= 4;
		if (c)
			last = c;
		if (c > 9)
			have_a_hex_digit = 1;
	}
	if (have_a_hex_digit == 0)
		return 1;
	if (last > 9)
		return 1;
	return 0;
d269 1
a269 1
frame_is_sane(db_regs_t * regs)
d271 3
a273 3
	/* no good if we can't read the whole frame */
	if (badwordaddr((vm_offset_t) regs) || badwordaddr((vm_offset_t) & regs->mode))
		return 0;
d276 4
a279 4
	/* disabled for now  -- see fpu_enable in luna88k/eh.s */
	/* r0 must be 0 (obviously) */
	if (regs->r[0] != 0)
		return 0;
d282 3
a284 3
	/* stack sanity ... r31 must be nonzero, but must be word aligned */
	if (regs->r[31] == 0 || (regs->r[31] & 3) != 0)
		return 0;
d286 1
a286 1
	/* sxip is reasonable */
d288 2
a289 2
	if ((regs->sxip & 1) == 1)
		return 0;
d291 6
a296 6
	/* snip is reasonable */
	if ((regs->snip & 3) != 2)
		return 0;
	/* sfip is reasonable */
	if ((regs->sfip & 3) != 2)
		return 0;
d298 16
a313 14
	/* epsr sanity */
	if ((regs->epsr & 0x8FFFFFF5 U) == 0x800003f0 U) {	/* kernel mode */
		if (regs->epsr & 0x40000000)
			db_printf("[WARNING: byte order in kernel frame at %x "
			    "is little-endian!]\n", regs);
		return 1;
	}
	if ((regs->epsr & 0x8FFFFFFF U) == 0x000003f0 U) {	/* user mode */
		if (regs->epsr & 0x40000000)
			db_printf("[WARNING: byte order in user frame at %x "
			    "is little-endian!]\n", regs);
		return 2;
	}
	return 0;
d317 1
a317 2
       *
m88k_exception_name(unsigned vector)
d319 21
a339 36
	switch (vector) {
		default:
		case 0:return "Reset";
	case 1:
		return "Interrupt";
	case 2:
		return "Instruction Access Exception";
	case 3:
		return "Data Access Exception";
	case 4:
		return "Misaligned Access Exception";
	case 5:
		return "Unimplemented Opcode Exception";
	case 6:
		return "Privilege Violation";
	case 7:
		return "Bounds Check";
	case 8:
		return "Integer Divide Exception";
	case 9:
		return "Integer Overflow Exception";
	case 10:
		return "Error Exception";
	case 114:
		return "FPU precise";
	case 115:
		return "FPU imprecise";
	case 130:
		return "Ddb break";
	case 131:
		return "Ddb trace";
	case 132:
		return "Ddb trap";
	case 451:
		return "Syscall";
	}
d341 1
d349 16
a364 16
	jmp_buf db_jmpbuf;
	jmp_buf *prev = db_recover;
	boolean_t old_quiet_db_read_bytes = quiet_db_read_bytes;

	quiet_db_read_bytes = 1;

	if (setjmp(*(db_recover = &db_jmpbuf)) != 0) {
		db_recover = prev;
		quiet_db_read_bytes = old_quiet_db_read_bytes;
		return 0;
	} else {
		db_read_bytes((char *) addr, 4, (char *) ptr);
		db_recover = prev;
		quiet_db_read_bytes = old_quiet_db_read_bytes;
		return 1;
	}
d374 4
a377 4
static unsigned global_saved_list = 0x0;	/* one bit per register */
static unsigned local_saved_list = 0x0;	/* one bit per register */
static unsigned trashed_list = 0x0;	/* one bit per register */
static unsigned saved_reg[32];	/* one value per register */
d384 12
a395 14
#ifdef TRACE_DEBUG
	if (DEBUGGING_ON)
		db_printf("save_reg(%d, %x)\n", reg, value);
#endif
	if (trashed_list & reg_bit(reg)) {
#ifdef TRACE_DEBUG
		if (DEBUGGING_ON)
			db_printf("<trashed>\n");
#endif
		return;		/* don't save trashed registers */
	}
	saved_reg[(reg % 32)] = value;
	global_saved_list |= reg_bit(reg);
	local_saved_list |= reg_bit(reg);
d397 1
d414 1
a414 1
	int     reg, last_arg;
d416 17
a432 21
	/* find the highest argument register saved */
	for (last_arg = LAST_ARG_REG; last_arg >= FIRST_ARG_REG; last_arg--)
		if (have_local_reg(last_arg))
			break;
	if (last_arg < FIRST_ARG_REG)
		return;		/* none were saved */

	db_printf("(");

	/* print each one, up to the highest */
	for (reg = FIRST_ARG_REG; /* nothing */ ; reg++) {
		if (!have_local_reg(reg))
			db_printf("?");
		else {
			unsigned value = saved_reg_value(reg);
			db_printf("%s%x", hex_value_needs_0x(value) ? "0x" : "", value);
		}
		if (reg == last_arg)
			break;
		else
			db_printf(", ");
d434 6
a439 1
	db_printf(")");
d471 2
a472 2
	unsigned flags;
	union instruction instruction;
d474 17
a490 7
	/*
         * Delayed branches are most common... look two instructions before
         * where we were going to return to to see if it's a delayed branch.
         */
	if (!db_trace_get_val(return_to - 8, &instruction.rawbits))
		return JUMP_SOURCE_IS_BAD;
	flags = m88k_instruction_info(instruction.rawbits);
d492 16
a507 16
	if ((flags & FLOW_CTRL) && (flags & DELAYED) && (flags & (JSR | BSR))) {
		if (flags & JSR)
			return JUMP_SOURCE_IS_OK;	/* have to assume it's
							 * correct */
		/* calculate the offset */
		if (br_dest(return_to - 8, instruction) == jump_to)
			return JUMP_SOURCE_IS_OK;	/* exactamundo! */
		else
			return JUMP_SOURCE_IS_UNLIKELY;	/* seems wrong */
	}
	/*
         * Try again, looking for a non-delayed jump one back.
         */
	if (!db_trace_get_val(return_to - 4, &instruction.rawbits))
		return JUMP_SOURCE_IS_BAD;
	flags = m88k_instruction_info(instruction.rawbits);
d509 1
a509 11
	if ((flags & FLOW_CTRL) && !(flags & DELAYED) && (flags & (JSR | BSR))) {
		if (flags & JSR)
			return JUMP_SOURCE_IS_OK;	/* have to assume it's
							 * correct */
		/* calculate the offset */
		if (br_dest(return_to - 4, instruction) == jump_to)
			return JUMP_SOURCE_IS_OK;	/* exactamundo! */
		else
			return JUMP_SOURCE_IS_UNLIKELY;	/* seems wrong */
	}
	return JUMP_SOURCE_IS_UNLIKELY;
d540 40
a579 21
	db_sym_t proc;
	unsigned offset_from_proc;
	unsigned instructions_to_search;
	unsigned check_addr;
	unsigned function_addr;	/* start of function */
	unsigned r31 = *stack;	/* the r31 of the function */
	unsigned inst;		/* text of an instruction */
	unsigned ret_addr;	/* address to which we return */
	unsigned tried_to_save_r1 = 0;

#ifdef TRACE_DEBUG
	if (DEBUGGING_ON)
		db_printf("\n>>>stack_decode(addr=%x, stack=%x)\n",
		    addr, *stack);
#endif

	/* get what we hope will be the db_sym_t for the function name */
	proc = db_search_symbol(addr, DB_STGY_PROC, &offset_from_proc);
	if (offset_from_proc == addr)	/* i.e. no symbol found */
		proc = DB_SYM_NULL;

d581 7
a587 23
         * Somehow, find the start of this function.
         * If we found a symbol above, it'll have the address.
         * Otherwise, we've got to search for it....
         */
	if (proc != DB_SYM_NULL) {
		char   *names;
		db_symbol_values(proc, &names, &function_addr);
		if (names == 0)
			return 0;
#ifdef TRACE_DEBUG
		if (DEBUGGING_ON)
			db_printf("name %s address 0x%x\n",
			    names, function_addr);
#endif
	} else {
		int     instructions_to_check = 400;
		/*
		 * hmm - unable to find symbol. Search back
		 * looking for a function prolog.
		 */
		for (check_addr = addr; instructions_to_check-- > 0; check_addr -= 4) {
			if (!db_trace_get_val(check_addr, &inst))
				break;
d589 35
a623 58
			if (SUBU_R31_R31_IMM(inst)) {
#if 0
				/*
			         * If the next instruction is "st r1, r31, ####"
			         * then we can feel safe we have the start of
			         * a function.
			         */
				if (!db_trace_get_val(check_addr + 4, &inst))
					continue;
				if (ST_R1_R31_IMM(instr))
					break;	/* sucess */
#else
				/*
			         * Latest GCC optimizer is just too good... the store
			         * of r1 might come much later... so we'll have to
			         * settle for just the "subr r31, r31, ###" to mark
			         * the start....
			         */
				break;
#endif
			}
			/*
		         * if we come across a [jmp r1] or [jmp.n r1] assume we have hit
		         * the previous functions epilogue and stop our search.
		         * Since we know we would have hit the "subr r31, r31" if it was
		         * right in front of us, we know this doesn't have one so
		         * we just return failure....
		         */
			if (JMP_R1(inst) || JMPN_R1(inst)) {
#ifdef TRACE_DEBUG
				if (DEBUGGING_ON)
					db_printf("ran into a [jmp r1] at %x (addr=%x)\n",
					    check_addr, addr);
#endif
				return 0;
			}
		}
		if (instructions_to_check < 0) {
#ifdef TRACE_DEBUG
			if (DEBUGGING_ON)
				db_printf("couldn't find func start (addr=%x)\n", addr);
#endif
			return 0;	/* bummer, couldn't find it */
		}
		function_addr = check_addr;
	}

	/*
         * We now know the start of the function (function_addr).
         * If we're stopped right there, or if it's not a
         *		subu r31, r31, ####
         * then we're done.
         */
	if (addr == function_addr) {
#ifdef TRACE_DEBUG
		if (DEBUGGING_ON)
			db_printf("at start of func\n");
#endif
d625 1
d627 2
a628 2
	if (!db_trace_get_val(function_addr, &inst)) {
#ifdef TRACE_DEBUG
d630 36
a665 15
			db_printf("couldn't read %x at line %d\n",
			    function_addr, __LINE__);
#endif
		return 0;
	}
	SHOW_INSTRUCTION(function_addr, inst, "start of function: ");
	if (!SUBU_R31_R31_IMM(inst)) {
#ifdef TRACE_DEBUG
		if (DEBUGGING_ON)
			db_printf("<not subu,r31,r31,imm>\n");
#endif
		return 0;
	}
	/* add the size of this frame to the stack (for the next frame) */
	*stack += IMM16VAL(inst);
d667 16
a682 16
	/*
         * Search from the beginning of the function (funstart) to where we are
         * in the function (addr) looking to see what kind of registers have
         * been saved on the stack.
         *
         * We'll stop looking before we get to ADDR if we hit a branch.
         */
	clear_local_saved_regs();
	check_addr = function_addr + 4;	/* we know the first inst isn't a
					 * store */

	for (instructions_to_search = (addr - check_addr) / sizeof(long);
	    instructions_to_search-- > 0;
	    check_addr += 4) {
		union instruction instruction;
		unsigned flags;
d684 8
a691 10
		/* read the instruction */
		if (!db_trace_get_val(check_addr, &instruction.rawbits)) {
#ifdef TRACE_DEBUG
			if (DEBUGGING_ON)
				db_printf("couldn't read %x at line %d\n",
				    check_addr, __LINE__);
#endif
			break;
		}
		SHOW_INSTRUCTION(check_addr, instruction.rawbits, "prolog: ");
d693 1
a693 2
		/* find out the particulars about this instruction */
		flags = m88k_instruction_info(instruction.rawbits);
d695 2
a696 28
		/* if a store to something off the stack pointer, note the
		 * value */
		if ((flags & STORE) && instruction.diatic.s1 == /* stack pointer */ 31) {
			unsigned value;
			if (!have_local_reg(instruction.diatic.d)) {
				if (instruction.diatic.d == 1)
					tried_to_save_r1 = r31 + instruction.diatic.i16;
				if (db_trace_get_val(r31 + instruction.diatic.i16, &value))
					save_reg(instruction.diatic.d, value);
			}
			if ((flags & DOUBLE) && !have_local_reg(instruction.diatic.d + 1)) {
				if (instruction.diatic.d == 0)
					tried_to_save_r1 = r31 + instruction.diatic.i16 + 4;
				if (db_trace_get_val(r31 + instruction.diatic.i16 + 4, &value))
					save_reg(instruction.diatic.d + 1, value);
			}
		}
		/* if an inst that kills D (and maybe D+1), note that */
		if (flags & TRASHES) {
			mark_reg_trashed(instruction.diatic.d);
			if (flags & DOUBLE)
				mark_reg_trashed(instruction.diatic.d + 1);
		}
		/* if a flow control instruction, stop now (or next if
		 * delayed) */
		if ((flags & FLOW_CTRL) && instructions_to_search != 0)
			instructions_to_search = (flags & DELAYED) ? 1 : 0;
	}
d698 43
a740 15
	/*
         * If we didn't save r1 at some point, we're hosed.
         */
	if (!have_local_reg(1)) {
		if (tried_to_save_r1) {
			db_printf("    <return value of next fcn unreadable in %08x>\n",
			    tried_to_save_r1);
		}
#ifdef TRACE_DEBUG
		if (DEBUGGING_ON)
			db_printf("didn't save r1\n");
#endif
		return 0;
	}
	ret_addr = saved_reg_value(1);
d742 1
a742 5
#ifdef TRACE_DEBUG
	if (DEBUGGING_ON)
		db_printf("Return value is = %x, function_addr is %x.\n",
		    ret_addr, function_addr);
#endif
d744 24
a767 13
	/*
         * In support of this, continuation.s puts the low bit on the
         * return address for continuations (the return address will never
         * be used, so it's ok to do anything you want to it).
         */
	if (ret_addr & 1) {
		note = "<<can not trace past a continuation>>";
		ret_addr = 0;
	} else
		if (ret_addr != 0x00) {
			switch (is_jump_source_ok(ret_addr, function_addr)) {
			case JUMP_SOURCE_IS_OK:
				break;	/* excellent */
d769 5
a773 6
			case JUMP_SOURCE_IS_BAD:
#ifdef TRACE_DEBUG
				if (DEBUGGING_ON)
					db_printf("jump is bad\n");
#endif
				return 0;	/* bummer */
d775 1
a775 6
			case JUMP_SOURCE_IS_UNLIKELY:
				next_address_likely_wrong = 1;;
				break;
			}
		}
	return ret_addr;
d779 1
a779 1
db_stack_trace_cmd2(db_regs_t * regs)
d781 54
a834 6
	unsigned stack;
	unsigned depth = 1;
	unsigned where;
	unsigned ft;
	unsigned pair[2];
	int     i;
d836 2
d839 26
a864 9
         * Frame_is_sane returns:
         *   1 if regs seems to be a reasonable kernel exception frame.
         *   2 if regs seems to be a reasonable user exception frame
         *      (in the current task).
         *   0 if this looks like neither.
         */
	if (ft = frame_is_sane(regs), ft == 0) {
		db_printf("Register frame 0x%x is suspicous; skipping trace\n", regs);
		return;
a865 3
	/* if user space and no user space trace specified, puke */
	if (ft == 2 && !(trace_flags & TRACE_USER_FLAG))
		return;
d867 3
a869 8
	/* fetch address */
	/* use sxip if valid, otherwise try snip or sfip */
	where = ((regs->sxip & 2) ? regs->sxip :
	    ((regs->snip & 2) ? regs->snip :
		regs->sfip)) & ~3;
	stack = regs->r[31];
	db_printf("stack base = 0x%x\n", stack);
	db_printf("(0) ");	/* depth of trace */
d871 1
a871 1
		db_printf("%08x ", where);
d873 4
a876 11
	clear_global_saved_regs();

	/* see if this routine had a stack frame */
	if ((where = stack_decode(where, &stack)) == 0) {
		where = regs->r[1];
		db_printf("(stackless)");
	} else {
		print_args();
		if (trace_flags & TRACE_SHOWFRAME_FLAG)
			db_printf(" [frame 0x%x]", stack);
	}
d879 2
a880 2
		db_printf("   %s\n", note);
		note = 0;
d882 3
a884 31
	do {
		/*
		 * If requested, show preserved registers at the time
		 * the next-shown call was made. Only registers known to have
		 * changed from the last exception frame are shown, as others
		 * can be gotten at by looking at the exception frame.
		 */
		if (trace_flags & TRACE_SHOWCALLPRESERVED_FLAG) {
			int     r, title_printed = 0;

			for (r = FIRST_CALLPRESERVED_REG; r <= LAST_CALLPRESERVED_REG; r++) {
				if (have_global_reg(r)) {
					unsigned value = saved_reg_value(r);
					if (title_printed == 0) {
						title_printed = 1;
						db_printf("[in next func:");
					}
					if (value == 0)
						db_printf(" r%d", r);
					else
						if (value <= 9)
							db_printf(" r%d=%x", r, value);
						else
							db_printf(" r%d=x%x", r, value);
				}
			}
			if (title_printed)
				db_printf("]\n");
		}
		db_printf("(%d)%c", depth++, next_address_likely_wrong ? '?' : ' ');
		next_address_likely_wrong = 0;
d886 2
a887 13
		if (trace_flags & TRACE_SHOWADDRESS_FLAG)
			db_printf("%08x ", where);
		db_printsym(where, DB_STGY_PROC);
		where = stack_decode(where, &stack);
		print_args();
		if (trace_flags & TRACE_SHOWFRAME_FLAG)
			db_printf(" [frame 0x%x]", stack);
		db_printf("\n");
		if (note) {
			db_printf("   %s\n", note);
			note = 0;
		}
	} while (where);
d889 1
a889 1
	/* try to trace back over trap/exception */
d891 4
a894 2
	stack &= ~7;		/* double word aligned */
	/* take last top of stack, and try to find an exception frame near it */
d896 26
a921 1
	i = FRAME_PLAY;
d923 1
a923 4
#ifdef TRACE_DEBUG
	if (DEBUGGING_ON)
		db_printf("(searching for exception frame at 0x%x)\n", stack);
#endif
d925 5
a929 1
	while (i) {
d931 50
a980 54
		 * On the stack, a pointer to the exception frame is written
		 * in two adjacent words. In the case of a fault from the kernel,
		 * this should point to the frame right above them:
		 *
		 * Exception Frame Top
		 * ..
		 * Exception Frame Bottom  <-- frame addr
		 * frame addr
		 * frame addr		<-- stack pointer
		 *
		 * In the case of a fault from user mode, the top of stack
		 * will just have the address of the frame
		 * replicated twice.
		 *
		 * frame addr		<-- top of stack
		 * frame addr
		 *
		 * Here we are just looking for kernel exception frames.
		 */

		if (badwordaddr((vm_offset_t) stack) ||
		    badwordaddr((vm_offset_t) (stack + 4)))
			break;

		db_read_bytes((char *) stack, 2 * sizeof(int), (char *) pair);

		/* the pairs should match and equal stack+8 */
		if (pair[0] == pair[1]) {
			if (pair[0] != stack + 8) {
				/*
				if (!badwordaddr((vm_offset_t)pair[0]) && (pair[0]!=0))
				db_printf("stack_trace:found pair 0x%x but != to stack+8\n",
				pair[0]);
				*/
			} else
				if (frame_is_sane((db_regs_t *) pair[0])) {
					db_regs_t *frame = (db_regs_t *) pair[0];
					char   *cause = m88k_exception_name(frame->vector);

					db_printf("-------------- %s [EF: 0x%x] -------------\n",
					    cause, frame);
					db_stack_trace_cmd2(frame);
					return;
				}
#ifdef TRACE_DEBUG
				else
					if (DEBUGGING_ON)
						db_printf("pair matched, but frame at 0x%x looks insane\n",
						    stack + 8);
#endif
		}
		stack += 8;
		i--;
	}
d982 5
a986 30
	/*
         * If we go here, crawling back on the stack failed to find us
         * a previous exception frame. Look for a user frame pointer
         * pointed to by a word 8 bytes off of the top of the stack
         * if the "u" option was specified.
         */
	if (trace_flags & TRACE_USER_FLAG) {
		db_regs_t *user;

		/* Make sure we are back on the right page */
		stack -= 4 * FRAME_PLAY;
		stack = stack & ~(KERNEL_STACK_SIZE - 1);	/* point to the bottom */
		stack += KERNEL_STACK_SIZE - 8;

		if (badwordaddr((vm_offset_t) stack) ||
		    badwordaddr((vm_offset_t) stack))
			return;

		db_read_bytes((char *) stack, 2 * sizeof(int), (char *) pair);
		if (pair[0] != pair[1])
			return;

		/* have a hit */
		user = *((db_regs_t **) stack);

		if (frame_is_sane(user) == 2) {
			db_printf("---------------- %s [EF : 0x%x] -------------\n",
			    m88k_exception_name(user->vector), user);
			db_stack_trace_cmd2(user);
		}
d988 1
d990 1
d999 1
a999 1
    db_regs_t * addr,
d1004 70
a1073 23
	enum {
		Default, Stack, Proc, Frame
	}       style = Default;
	db_regs_t frame;	/* a m88100_saved_state */
	db_regs_t *regs;
	union {
		db_regs_t *frame;
		struct proc *proc;
		unsigned num;
	}       arg;
	arg.frame = addr;

	trace_flags = 0;	/* flags will be set via modifers */

	while (modif && *modif) {
		switch (*modif++) {
		case 'd':
#ifdef TRACE_DEBUG
			trace_flags |= TRACE_DEBUG_FLAG;
#else
			db_printtf("<debug trace not compiled in, ignoring>\n");
#endif
			break;
d1075 10
a1084 35
		case 's':
			style = Stack;
			break;
		case 'f':
			style = Frame;
			break;
		case 'p':
			trace_flags |= TRACE_SHOWCALLPRESERVED_FLAG;
			break;
		case 'a':
			trace_flags |= TRACE_SHOWADDRESS_FLAG;
			break;
		case 'F':
			trace_flags |= TRACE_SHOWFRAME_FLAG;
			break;
		case 'u':
			trace_flags |= TRACE_USER_FLAG;
			break;
		default:
			db_printf("unknown trace modifier [%c]\n", modif[-1]);
			/* FALLTHROUGH */
		case 'h':
			db_printf("usage: trace/[MODIFIER]  [ARG]\n");
			db_printf("  u = include user trace\n");
			db_printf("  F = print stack frames\n");
			db_printf("  a = show return addresses\n");
			db_printf("  p = show call-preserved registers\n");
			db_printf("  s = ARG is a stack pointer\n");
			db_printf("  f = ARG is a frame pointer\n");
#ifdef TRACE_DEBUG
			db_printf("  d = trace-debugging output\n");
#endif
			return;
		}
	}
d1086 13
a1098 2
	if (!have_addr && style != Default) {
		db_printf("expecting argument with /s or /f\n");
d1100 32
a1132 11
	if (have_addr && style == Default)
		style = Proc;

	switch (style) {
	case Default:
		regs = DDB_REGS;
		break;

	case Frame:
		regs = arg.frame;
		break;
d1134 9
a1142 74
	case Stack:
		{
			unsigned val1, val2, sxip;
			unsigned ptr;
			bzero((void *) &frame, sizeof(frame));
#define REASONABLE_FRAME_DISTANCE 2048

			/*
			 * We've got to find the top of a stack frame so we can get both
			 * a PC and and real SP.
			 */
			for (ptr = arg.num; /**/ ; ptr += 4) {
				/* Read a word from the named stack */
				if (db_trace_get_val(ptr, &val1) == 0) {
					db_printf("can't read from %x, aborting.\n", ptr);
					return;
				}
				/*
			         * See if it's a frame pointer.... if so it will be larger than
			         * the address it was taken from (i.e. point back up the stack)
			         * and we'll be able to read where it points.
			         */
				if (val1 <= ptr ||
				    (val1 & 3) ||
				    val1 > (ptr + REASONABLE_FRAME_DISTANCE))
					continue;

				/* peek at the next word to see if it could be
				 * a return address */
				if (db_trace_get_val(ptr, &sxip) == 0) {
					db_printf("can't read from %x, aborting.\n", ptr);
					return;
				}
				if (sxip == 0 || !db_trace_get_val(sxip, &val2))
					continue;

				if (db_trace_get_val(val1, &val2) == 0) {
					db_printf("can't read from %x, aborting.\n", val1);
					continue;
				}
				/*
			         * The value we've just read will be either another frame pointer,
			         * or the start of another exception frame.
			         */
				if (
#ifdef JEFF_DEBUG
				    val2 == 0
#else
				    val2 == 0x12345678
#endif
				    && db_trace_get_val(val1 - 4, &val2) && val2 == val1
				    && db_trace_get_val(val1 - 8, &val2) && val2 == val1) {
					/* we've found a frame, so the stack
					 * must have been good */
					db_printf("%x looks like a frame, accepting %x\n", val1, ptr);
					break;
				}
				if (val2 > val1 && (val2 & 3) == 0) {
					/* well, looks close enough to be
					 * another frame pointer */
					db_printf("*%x = %x looks like a stack frame pointer, accepting %x\n", val1, val2, ptr);
					break;
				}
			}

			frame.r[31] = ptr;
			frame.epsr = 0x800003f0 U;
			frame.sxip = sxip | 2;
			frame.snip = frame.sxip + 4;
			frame.sfip = frame.snip + 4;
			db_printf("[r31=%x, sxip=%x]\n", frame.r[31], frame.sxip);
			regs = &frame;
		}
	}
d1144 1
a1144 1
	db_stack_trace_cmd2(regs);
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@initial 88k import; code by nivas and based on mach luna88k
@
text
@@


1.1.1.2
log
@Third try at importing the mvme88k port. This is a working kernel
from nivas.
Userland and compiler still need to be worked on.
Make certain what directory the import is done from.
@
text
@d29 1
a29 1
    unsigned rawbits;
d31 46
a76 44
    struct {
	unsigned int    : 5;
	unsigned int   n: 1;
	signed int   d26:26;
    } br;

    struct {
	unsigned int      : 4;
	unsigned int isbb1: 1;	/* isbb1==0 means bb0, isbb1==1 means bb1 */
	unsigned int   n  : 1;
	unsigned int  b5  : 5;
	unsigned int  s1  : 5;
	signed   int  d16 :16;
    } bb; /* bcnd too, except "isbb1" makes no sense for bcnd */

    struct {
	unsigned int      : 6;
	unsigned int  b5  : 5;
	unsigned int  s1  : 5;
	unsigned int      : 7;
	unsigned int vec9 : 9;
    } tb; /* tcnd too */

    struct {
	unsigned int      :21;
	unsigned int    n : 1;
	unsigned int      : 5;
	unsigned int   s2 : 5;
    } jump; /* jmp, jsr */

    struct {
	unsigned int      : 6;
        unsigned int    d : 5;
        unsigned int   s1 : 5;
        unsigned int  i16 :16;
    } diatic;	/* general reg/reg/i16 instructions */

    struct {
	unsigned int      : 6;
        unsigned int    d : 5;
        unsigned int   s1 : 5;
        unsigned int      :11;
        unsigned int   s2 : 5;
    } triatic;  /* general reg/reg/reg instructions */
d80 2
a81 1
static inline unsigned br_dest(unsigned addr, union instruction inst)
d83 1
a83 1
    return addr + inst.br.d26 * 4;
d87 1
a87 1
#define TRACE_DEBUG	/* undefine to disable debugging */
d89 2
a90 1
#include <machine/db_machdep.h> /* lots of stuff                  */
d111 1
a111 1
static trace_flags = 0;
d119 1
a119 1
  #define DEBUGGING_ON (trace_flags & TRACE_DEBUG_FLAG)
d123 1
a123 1
  #define SHOW_INSTRUCTION(Addr, Inst, Note) 	{ /*nothing*/ }
d125 1
a125 1
  #define SHOW_INSTRUCTION(Addr, Inst, Note) if (DEBUGGING_ON) { 	\
d132 1
a132 1
extern label_t *db_recover;
d141 5
a145 5
	struct db_variable	*vp,
	db_expr_t		*valuep,
	int			op)		/* read/write */
{
    register int   *regp = (int *) ((char *) DDB_REGS + (int) (vp->valuep));
d147 5
a151 4
    if (op == DB_VAR_GET)
	*valuep = *regp;
    else if (op == DB_VAR_SET)
	*regp = *valuep;
a152 1

d156 17
a172 17
    N("r1", r[1]),     N("r2", r[2]), 	 N("r3", r[3]),	   N("r4", r[4]),
    N("r5", r[5]),     N("r6", r[6]), 	 N("r7", r[7]),	   N("r8", r[8]),
    N("r9", r[9]),     N("r10", r[10]),  N("r11", r[11]),  N("r12", r[12]),
    N("r13", r[13]),   N("r14", r[14]),  N("r15", r[15]),  N("r16", r[16]),
    N("r17", r[17]),   N("r18", r[18]),  N("r19", r[19]),  N("r20", r[20]),
    N("r21", r[21]),   N("r22", r[22]),  N("r23", r[23]),  N("r24", r[24]),
    N("r25", r[25]),   N("r26", r[26]),  N("r27", r[27]),  N("r28", r[28]),
    N("r29", r[29]),   N("r30", r[30]),  N("r31", r[31]),  N("epsr", epsr),
    N("sxip", sxip),   N("snip", snip),  N("sfip", sfip),  N("ssbr", ssbr),
    N("dmt0", dmt0),   N("dmd0", dmd0),  N("dma0", dma0),  N("dmt1", dmt1),
    N("dmd1", dmd1),   N("dma1", dma1),  N("dmt2", dmt2),  N("dmd2", dmd2),
    N("dma2", dma2),   N("fpecr", fpecr),N("fphs1", fphs1),N("fpls1", fpls1),
    N("fphs2", fphs2), N("fpls2", fpls2),N("fppt", fppt),  N("fprh", fprh),
    N("fprl", fprl),   N("fpit", fpit),  N("fpsr", fpsr),  N("fpcr", fpcr),
    N("mask", mask), /* interrupt mask */
    N("mode", mode), /* interrupt mode */
    N("exvc", vector), /* exception vector */
d176 1
a176 1
struct db_variable *db_eregs = db_regs + sizeof(db_regs)/sizeof(db_regs[0]);
d195 105
a299 41
   static struct { unsigned mask, value, flags; } *ptr, control[] =
   {
      /* runs in the same order as 2nd Ed 88100 manual Table 3-14 */
     { 0xf0000000U, 0x00000000U, /* xmem */     TRASHES | STORE | LOAD    },
     { 0xec000000U, 0x00000000U, /* ld.d */     TRASHES | LOAD | DOUBLE   },
     { 0xe0000000U, 0x00000000U, /* load */     TRASHES | LOAD            },
     { 0xfc000000U, 0x20000000U, /* st.d */     STORE | DOUBLE            },
     { 0xf0000000U, 0x20000000U, /* store */    STORE                     },
     { 0xc0000000U, 0x40000000U, /* arith */    TRASHES                   },
     { 0xfc004000U, 0x80004000U, /* ld cr */    TRASHES                   },
     { 0xfc004000U, 0x80000000U, /* st cr */    0                         },
     { 0xfc008060U, 0x84000000U, /* f */        TRASHES                   },
     { 0xfc008060U, 0x84000020U, /* f.d */      TRASHES | DOUBLE          },
     { 0xfc000000U, 0xcc000000U, /* bsr.n */    FLOW_CTRL | DELAYED | BSR },
     { 0xfc000000U, 0xc8000000U, /* bsr */      FLOW_CTRL | BSR           },
     { 0xe4000000U, 0xc4000000U, /* br/bb.n */  FLOW_CTRL | DELAYED       },
     { 0xe4000000U, 0xc0000000U, /* br/bb */    FLOW_CTRL                 },
     { 0xfc000000U, 0xec000000U, /* bcnd.n */   FLOW_CTRL | DELAYED       },
     { 0xfc000000U, 0xe8000000U, /* bcnd */     FLOW_CTRL                 },
     { 0xfc00c000U, 0xf0008000U, /* bits */     TRASHES                   },
     { 0xfc00c000U, 0xf000c000U, /* trap */     0                         },
     { 0xfc00f0e0U, 0xf4002000U, /* st */       0                         },
     { 0xfc00cce0U, 0xf4000000U, /* ld.d */     TRASHES | DOUBLE          },
     { 0xfc00c0e0U, 0xf4000000U, /* ld */       TRASHES                   },
     { 0xfc00c0e0U, 0xf4004000U, /* arith */    TRASHES                   },
     { 0xfc00c3e0U, 0xf4008000U, /* bits */     TRASHES                   },
     { 0xfc00ffe0U, 0xf400cc00U, /* jsr.n */    FLOW_CTRL | DELAYED | JSR },
     { 0xfc00ffe0U, 0xf400c800U, /* jsr */      FLOW_CTRL | JSR           },
     { 0xfc00ffe0U, 0xf400c400U, /* jmp.n */    FLOW_CTRL | DELAYED       },
     { 0xfc00ffe0U, 0xf400c000U, /* jmp */      FLOW_CTRL                 },
     { 0xfc00fbe0U, 0xf400e800U, /* ff */       TRASHES                   },
     { 0xfc00ffe0U, 0xf400f800U, /* tbnd */     0                         },
     { 0xfc00ffe0U, 0xf400fc00U, /* rte */      FLOW_CTRL                 },
     { 0xfc000000U, 0xf8000000U, /* tbnd */     0                         },
    };
    #define ctrl_count (sizeof(control)/sizeof(control[0]))
    for (ptr = &control[0]; ptr < &control[ctrl_count]; ptr++)
	if ((instruction & ptr->mask) == ptr->value)
	    return ptr->flags;
    SHOW_INSTRUCTION(0, instruction, "bad m88k_instruction_info");
    return 0;
d305 4
a308 4
    int i;
    unsigned last = 0;
    unsigned char c; 
    unsigned have_a_hex_digit = 0;
d310 15
a324 1
    if (value <= 9)
a325 14

    for (i = 0; i < 8; i++) {
	c = value & 0xf;
	value >>= 4;
	if (c)
	    last = c;
	if (c > 9)
	    have_a_hex_digit = 1;
    }
    if (have_a_hex_digit == 0)
	return 1;
    if (last > 9)
	return 1;
    return 0;
d337 1
a337 1
frame_is_sane(db_regs_t *regs)
d339 3
a341 3
    /* no good if we can't read the whole frame */
    if (badwordaddr((vm_offset_t)regs) || badwordaddr((vm_offset_t)&regs->mode))
	return 0;
d344 4
a347 4
    /* disabled for now  -- see fpu_enable in luna88k/eh.s */
    /* r0 must be 0 (obviously) */
    if (regs->r[0] != 0)
	return 0;
d350 3
a352 3
    /* stack sanity ... r31 must be nonzero, but must be word aligned */
    if (regs->r[31] == 0 || (regs->r[31] & 3) != 0)
	return 0;
d354 1
a354 1
    /* sxip is reasonable */
d356 2
a357 2
    if ((regs->sxip & 1) == 1)
	return 0;
d359 20
a378 5
    /* snip is reasonable */
    if ((regs->snip & 3) != 2)
	return 0;
    /* sfip is reasonable */
    if ((regs->sfip & 3) != 2)
a379 17

    /* epsr sanity */
    if ((regs->epsr & 0x8FFFFFF5U) == 0x800003f0U) /* kernel mode */
    {
	if (regs->epsr & 0x40000000) 
	  db_printf("[WARNING: byte order in kernel frame at %x "
		    "is little-endian!]\n", regs);
	return 1;
    }
    if ((regs->epsr & 0x8FFFFFFFU) == 0x000003f0U) /* user mode */
    {
	if (regs->epsr & 0x40000000) 
	  db_printf("[WARNING: byte order in user frame at %x "
		    "is little-endian!]\n", regs);
	return 2;
    }
    return 0;
d383 2
a384 1
*m88k_exception_name(unsigned vector)
d386 36
a421 21
    switch  (vector)
    {
	default:
	case   0: return "Reset";
	case   1: return "Interrupt";
	case   2: return "Instruction Access Exception";
	case   3: return "Data Access Exception";
	case   4: return "Misaligned Access Exception";
	case   5: return "Unimplemented Opcode Exception";
	case   6: return "Privilege Violation";
	case   7: return "Bounds Check";
	case   8: return "Integer Divide Exception";
	case   9: return "Integer Overflow Exception";
	case  10: return "Error Exception";
	case 114: return "FPU precise";
	case 115: return "FPU imprecise";
	case 130: return "Ddb break";
	case 131: return "Ddb trace";
	case 132: return "Ddb trap";
	case 451: return "Syscall";
    }
a422 1

d430 16
a445 16
    label_t db_jmpbuf;
    label_t *prev = db_recover;
    boolean_t old_quiet_db_read_bytes = quiet_db_read_bytes;

    quiet_db_read_bytes = 1;

    if (setjmp(*(db_recover = &db_jmpbuf)) != 0) {
	db_recover = prev;
        quiet_db_read_bytes = old_quiet_db_read_bytes;
	return 0;
    } else {
	db_read_bytes((char*)addr, 4, (char*)ptr);
	db_recover = prev;
        quiet_db_read_bytes = old_quiet_db_read_bytes;
	return 1;
    }
d455 4
a458 4
static unsigned global_saved_list = 0x0; /* one bit per register */
static unsigned local_saved_list  = 0x0; /* one bit per register */
static unsigned trashed_list      = 0x0; /* one bit per register */
static unsigned saved_reg[32];		 /* one value per register */
d465 14
a478 12
    #ifdef TRACE_DEBUG
	if (DEBUGGING_ON) db_printf("save_reg(%d, %x)\n", reg, value);
    #endif
    if (trashed_list & reg_bit(reg)) {
	#ifdef TRACE_DEBUG
	    if (DEBUGGING_ON) db_printf("<trashed>\n");
	#endif
	return; /* don't save trashed registers */
    }
    saved_reg[(reg%32)] = value;
    global_saved_list |= reg_bit(reg);
    local_saved_list  |= reg_bit(reg);
a479 1

d496 1
a496 1
    int reg, last_arg;
d498 21
a518 17
    /* find the highest argument register saved */
    for (last_arg = LAST_ARG_REG; last_arg >= FIRST_ARG_REG; last_arg--)
	if (have_local_reg(last_arg))
	    break;
    if (last_arg < FIRST_ARG_REG)
	return; /* none were saved */

    db_printf("(");

    /* print each one, up to the highest */
    for (reg = FIRST_ARG_REG; /*nothing */; reg++)
    {
	if (!have_local_reg(reg))
	    db_printf("?");
	else {
	    unsigned value = saved_reg_value(reg);
	    db_printf("%s%x", hex_value_needs_0x(value)  ? "0x" : "", value);
d520 1
a520 6
	if (reg == last_arg)
	    break;
	else
	    db_printf(", ");
    }
    db_printf(")");
d552 2
a553 2
    unsigned flags;
    union instruction instruction; 
d555 7
a561 17
    /*
     * Delayed branches are most common... look two instructions before
     * where we were going to return to to see if it's a delayed branch.
     */
    if (!db_trace_get_val(return_to - 8, &instruction.rawbits))
	return JUMP_SOURCE_IS_BAD;
    flags = m88k_instruction_info(instruction.rawbits);

    if ((flags & FLOW_CTRL) && (flags & DELAYED) && (flags & (JSR|BSR))) {
	if (flags & JSR)
	    return JUMP_SOURCE_IS_OK; /* have to assume it's correct */
	/* calculate the offset */
	if (br_dest(return_to - 8, instruction) == jump_to)
	    return JUMP_SOURCE_IS_OK; /* exactamundo! */
	else
	    return JUMP_SOURCE_IS_UNLIKELY; /* seems wrong */
    }
d563 16
a578 16
    /*
     * Try again, looking for a non-delayed jump one back.
     */
    if (!db_trace_get_val(return_to - 4, &instruction.rawbits))
	return JUMP_SOURCE_IS_BAD;
    flags = m88k_instruction_info(instruction.rawbits);

    if ((flags & FLOW_CTRL) && !(flags & DELAYED) && (flags & (JSR|BSR))) {
	if (flags & JSR)
	    return JUMP_SOURCE_IS_OK; /* have to assume it's correct */
	/* calculate the offset */
	if (br_dest(return_to - 4, instruction) == jump_to)
	    return JUMP_SOURCE_IS_OK; /* exactamundo! */
	else
	    return JUMP_SOURCE_IS_UNLIKELY; /* seems wrong */
    }
d580 11
a590 1
    return JUMP_SOURCE_IS_UNLIKELY;
d621 21
a641 40
    db_sym_t proc;
    unsigned offset_from_proc;
    unsigned instructions_to_search;
    unsigned check_addr;
    unsigned function_addr;	/* start of function */
    unsigned r31 = *stack;	/* the r31 of the function */
    unsigned inst;		/* text of an instruction */
    unsigned ret_addr;		/* address to which we return */
    unsigned tried_to_save_r1 = 0;

    #ifdef TRACE_DEBUG
      if (DEBUGGING_ON)
	db_printf("\n>>>stack_decode(addr=%x, stack=%x)\n",
		addr, *stack);
    #endif

      /* get what we hope will be the db_sym_t for the function name */
    proc = db_search_symbol(addr, DB_STGY_PROC, &offset_from_proc);
    if (offset_from_proc == addr) /* i.e. no symbol found */
	proc = DB_SYM_NULL;

    /*
     * Somehow, find the start of this function.
     * If we found a symbol above, it'll have the address.
     * Otherwise, we've got to search for it....
     */
    if (proc != DB_SYM_NULL)
    {
	char *names;
	db_symbol_values(proc, &names, &function_addr);
	if (names == 0)
	    return 0;
	#ifdef TRACE_DEBUG
	    if (DEBUGGING_ON) db_printf("name %s address 0x%x\n",
		names, function_addr);
	#endif
    }
    else
    {
	int instructions_to_check = 400;
d643 70
a712 7
	 * hmm - unable to find symbol. Search back
	 * looking for a function prolog.
	 */
	for (check_addr = addr; instructions_to_check-- > 0; check_addr -= 4)
	{
	    if (!db_trace_get_val(check_addr, &inst))
		break;
d714 19
a732 35
	    if (SUBU_R31_R31_IMM(inst))
	    {
		#if 0
		    /*
		     * If the next instruction is "st r1, r31, ####"
		     * then we can feel safe we have the start of
		     * a function.
		     */
		    if (!db_trace_get_val(check_addr + 4, &inst))
			continue;
		    if (ST_R1_R31_IMM(instr))
			break; /* sucess */
		#else
		    /*
		     * Latest GCC optimizer is just too good... the store
		     * of r1 might come much later... so we'll have to
		     * settle for just the "subr r31, r31, ###" to mark
		     * the start....
		     */
		     break;
		#endif
	    }
	    /*
	     * if we come across a [jmp r1] or [jmp.n r1] assume we have hit
	     * the previous functions epilogue and stop our search.
	     * Since we know we would have hit the "subr r31, r31" if it was
	     * right in front of us, we know this doesn't have one so
	     * we just return failure....
	     */
	    if (JMP_R1(inst) || JMPN_R1(inst)) {
		#ifdef TRACE_DEBUG
		    if (DEBUGGING_ON)
			db_printf("ran into a [jmp r1] at %x (addr=%x)\n",
				check_addr, addr);
		#endif
a733 1
	    }
d735 3
a737 2
	if (instructions_to_check < 0) {
	    #ifdef TRACE_DEBUG
d739 23
a761 33
		    db_printf("couldn't find func start (addr=%x)\n", addr);
	    #endif
	    return 0; /* bummer, couldn't find it */
	}
	function_addr = check_addr;
    }

    /*
     * We now know the start of the function (function_addr).
     * If we're stopped right there, or if it's not a
     *		subu r31, r31, ####
     * then we're done.
     */
    if (addr == function_addr) {
	#ifdef TRACE_DEBUG
	    if (DEBUGGING_ON) db_printf("at start of func\n");
	#endif
	return 0;
    }
    if (!db_trace_get_val(function_addr, &inst)) {
	#ifdef TRACE_DEBUG
	    if (DEBUGGING_ON) db_printf("couldn't read %x at line %d\n",
		function_addr, __LINE__);
	#endif
	return 0;
    }
    SHOW_INSTRUCTION(function_addr, inst, "start of function: ");
    if (!SUBU_R31_R31_IMM(inst)) {
	#ifdef TRACE_DEBUG
	    if (DEBUGGING_ON) db_printf("<not subu,r31,r31,imm>\n");
	#endif
	return 0;
    }
d763 10
a772 2
    /* add the size of this frame to the stack (for the next frame) */
    *stack += IMM16VAL(inst);
d774 2
a775 16
    /*
     * Search from the beginning of the function (funstart) to where we are
     * in the function (addr) looking to see what kind of registers have
     * been saved on the stack.
     *
     * We'll stop looking before we get to ADDR if we hit a branch.
     */
    clear_local_saved_regs();
    check_addr = function_addr + 4; /* we know the first inst isn't a store */

    for (instructions_to_search = (addr - check_addr)/sizeof(long);
	instructions_to_search-- > 0;
	check_addr += 4)
    {
 	union instruction instruction;
	unsigned flags;
d777 27
a803 7
	/* read the instruction */
        if (!db_trace_get_val(check_addr, &instruction.rawbits)) {
	    #ifdef TRACE_DEBUG
		if (DEBUGGING_ON) db_printf("couldn't read %x at line %d\n",
		    check_addr, __LINE__);
	    #endif
            break;
d806 15
a820 1
	SHOW_INSTRUCTION(check_addr, instruction.rawbits, "prolog: ");
d822 5
a826 2
	/* find out the particulars about this instruction */
	flags = m88k_instruction_info(instruction.rawbits);
d828 13
a840 43
	/* if a store to something off the stack pointer, note the value */
	if ((flags & STORE) && instruction.diatic.s1 == /*stack pointer*/31)
	{
	    unsigned value;
	    if (!have_local_reg(instruction.diatic.d)) {
		if (instruction.diatic.d == 1)
			tried_to_save_r1 = r31 + instruction.diatic.i16 ;
		if (db_trace_get_val(r31 + instruction.diatic.i16, &value))
		    save_reg(instruction.diatic.d, value);
	    }
	    if ((flags & DOUBLE) && !have_local_reg(instruction.diatic.d + 1)) {
		if (instruction.diatic.d == 0)
		    tried_to_save_r1 = r31+instruction.diatic.i16 +4;
		if (db_trace_get_val(r31+instruction.diatic.i16 +4, &value))
		    save_reg(instruction.diatic.d + 1, value);
	    }
	}

	/* if an inst that kills D (and maybe D+1), note that */
	if (flags & TRASHES) {
	    mark_reg_trashed(instruction.diatic.d);
	    if (flags & DOUBLE)
	        mark_reg_trashed(instruction.diatic.d + 1);
	}

	/* if a flow control instruction, stop now (or next if delayed) */
	if ((flags & FLOW_CTRL) && instructions_to_search != 0)
	    instructions_to_search = (flags & DELAYED) ? 1 : 0;
    }

    /*
     * If we didn't save r1 at some point, we're hosed.
     */
    if (!have_local_reg(1)) {
	if (tried_to_save_r1) {
	    db_printf("    <return value of next fcn unreadable in %08x>\n",
		tried_to_save_r1);
	}
	#ifdef TRACE_DEBUG
	    if (DEBUGGING_ON) db_printf("didn't save r1\n");
	#endif
	return 0;
    }
d842 6
a847 1
    ret_addr = saved_reg_value(1);
d849 6
a854 32
    #ifdef TRACE_DEBUG
    if (DEBUGGING_ON)
	db_printf("Return value is = %x, function_addr is %x.\n",
	    ret_addr, function_addr);
    #endif

    /*
     * In support of this, continuation.s puts the low bit on the
     * return address for continuations (the return address will never
     * be used, so it's ok to do anything you want to it).
     */
    if (ret_addr & 1) {
	note = "<<can not trace past a continuation>>";
	ret_addr = 0;
    } else if (ret_addr != 0x00) {
	switch(is_jump_source_ok(ret_addr, function_addr)) {
	  case JUMP_SOURCE_IS_OK:
		break; /* excellent */

	  case JUMP_SOURCE_IS_BAD:
		#ifdef TRACE_DEBUG
		    if (DEBUGGING_ON) db_printf("jump is bad\n");
		#endif
		return 0; /* bummer */

	  case JUMP_SOURCE_IS_UNLIKELY:
		next_address_likely_wrong = 1;;
		break;
	}
    }

    return ret_addr;
d858 1
a858 1
db_stack_trace_cmd2(db_regs_t *regs)
d860 6
a865 54
    unsigned stack;
    unsigned depth=1;
    unsigned where;
    unsigned ft;
    unsigned pair[2];
    int i;

    /*
     * Frame_is_sane returns:
     *   1 if regs seems to be a reasonable kernel exception frame.
     *   2 if regs seems to be a reasonable user exception frame
     *      (in the current task).
     *   0 if this looks like neither.
     */
    if (ft = frame_is_sane(regs), ft == 0)
    {
	db_printf("Register frame 0x%x is suspicous; skipping trace\n", regs);
	return;
    }

    /* if user space and no user space trace specified, puke */
    if (ft == 2 && !(trace_flags & TRACE_USER_FLAG))
	return;

    /* fetch address */
    /* use sxip if valid, otherwise try snip or sfip */
    where = ((regs->sxip & 2) ? regs->sxip :
	    ((regs->snip & 2) ? regs->snip :
	      regs->sfip) ) & ~3;
    stack = regs->r[31];
    db_printf("stack base = 0x%x\n", stack);
    db_printf("(0) "); /*depth of trace */
    if (trace_flags & TRACE_SHOWADDRESS_FLAG)
	db_printf("%08x ", where);
    db_printsym(where, DB_STGY_PROC);
    clear_global_saved_regs();

    /* see if this routine had a stack frame */
    if ((where=stack_decode(where, &stack))==0)
    {
	where = regs->r[1];
	db_printf("(stackless)");
    }
    else
    {
	print_args();
	if (trace_flags & TRACE_SHOWFRAME_FLAG)
	    db_printf(" [frame 0x%x]", stack);
    }
    db_printf("\n");
    if (note) {
	db_printf("   %s\n", note);
	note = 0;
    }
a866 2
    do
    {
d868 9
a876 26
	 * If requested, show preserved registers at the time
	 * the next-shown call was made. Only registers known to have
	 * changed from the last exception frame are shown, as others
	 * can be gotten at by looking at the exception frame.
	 */
	if (trace_flags & TRACE_SHOWCALLPRESERVED_FLAG)
	{
	    int r, title_printed = 0;

	    for (r = FIRST_CALLPRESERVED_REG; r<=LAST_CALLPRESERVED_REG; r++) {
		if (have_global_reg(r)) {
		    unsigned value = saved_reg_value(r);
		    if (title_printed == 0) {
		       title_printed = 1;
		       db_printf("[in next func:");
		    }
		    if (value == 0)
			db_printf(" r%d", r);
		    else if (value <= 9)
			db_printf(" r%d=%x", r, value);
		    else
			db_printf(" r%d=x%x", r, value);
		}
	    }
	    if (title_printed)
		db_printf("]\n");
d878 3
d882 8
a889 3
	db_printf("(%d)%c", depth++, next_address_likely_wrong ? '?':' ');
	next_address_likely_wrong = 0;

d891 1
a891 1
	    db_printf("%08x ", where);
d893 11
a903 4
	where = stack_decode(where, &stack);
	print_args();
	if (trace_flags & TRACE_SHOWFRAME_FLAG)
	    db_printf(" [frame 0x%x]", stack);
d906 2
a907 2
	    db_printf("   %s\n", note);
	    note = 0;
d909 31
a939 1
    } while (where);
d941 13
a953 1
    /* try to trace back over trap/exception */
d955 1
a955 2
    stack &= ~7; /* double word aligned */
    /* take last top of stack, and try to find an exception frame near it */
d957 2
a958 1
    i = FRAME_PLAY;
d960 3
a962 1
    #ifdef TRACE_DEBUG
d964 2
a965 29
	    db_printf("(searching for exception frame at 0x%x)\n", stack);
    #endif

    while (i)
    {
	/*
	 * On the stack, a pointer to the exception frame is written
	 * in two adjacent words. In the case of a fault from the kernel,
	 * this should point to the frame right above them:
	 *
	 * Exception Frame Top
	 * ..
	 * Exception Frame Bottom  <-- frame addr
	 * frame addr
	 * frame addr		<-- stack pointer
	 *
	 * In the case of a fault from user mode, the top of stack
	 * will just have the address of the frame
	 * replicated twice.
	 *
	 * frame addr		<-- top of stack
	 * frame addr
	 *
	 * Here we are just looking for kernel exception frames.
	 */

	if (badwordaddr((vm_offset_t)stack) ||
	    badwordaddr((vm_offset_t)(stack+4)))
		    break;
d967 1
a967 7
	db_read_bytes((char*)stack, 2*sizeof(int), (char*)pair);

	/* the pairs should match and equal stack+8 */
	if (pair[0] == pair[1])
	{
	    if (pair[0] != stack+8)
	    {
d969 54
a1022 47
		if (!badwordaddr((vm_offset_t)pair[0]) && (pair[0]!=0))
		db_printf("stack_trace:found pair 0x%x but != to stack+8\n",
		pair[0]);
		*/
	    }
	    else if (frame_is_sane((db_regs_t*)pair[0]))
	    {
		db_regs_t *frame = (db_regs_t *) pair[0];
		char *cause = m88k_exception_name(frame -> vector);

		db_printf("-------------- %s [EF: 0x%x] -------------\n",
		      cause, frame);
		db_stack_trace_cmd2(frame);
		return;
	    }
	    #ifdef TRACE_DEBUG
		else if (DEBUGGING_ON)
		    db_printf("pair matched, but frame at 0x%x looks insane\n",
			stack+8);
	    #endif
	}
	stack += 8;
	i--;
    }

    /*
     * If we go here, crawling back on the stack failed to find us
     * a previous exception frame. Look for a user frame pointer
     * pointed to by a word 8 bytes off of the top of the stack
     * if the "u" option was specified.
     */
    if (trace_flags & TRACE_USER_FLAG)
    {
	db_regs_t *user;

	/* Make sure we are back on the right page */
	stack -= 4*FRAME_PLAY;
	stack = stack & ~(KERNEL_STACK_SIZE-1); /* point to the bottom */
	stack += KERNEL_STACK_SIZE - 8;

	if (badwordaddr((vm_offset_t)stack) ||
	    badwordaddr((vm_offset_t)stack))
		    return;

	db_read_bytes((char*)stack, 2*sizeof(int), (char*)pair);
	if (pair[0] != pair[1])
	    return;
d1024 30
a1053 8
	/* have a hit */
	user = *((db_regs_t **) stack);

	if (frame_is_sane(user) == 2)
	{
	    db_printf("---------------- %s [EF : 0x%x] -------------\n",
		m88k_exception_name(user->vector), user);
	    db_stack_trace_cmd2(user);
a1054 1
    }
a1055 1

d1064 1
a1064 1
    db_regs_t *addr,
d1069 59
a1127 70
    enum { Default, Stack, Proc, Frame } style = Default;
    db_regs_t frame; /* a m88100_saved_state */
    db_regs_t *regs;
    union {
	db_regs_t *frame;
	struct proc *proc;
	unsigned num;
    } arg;
    arg.frame = addr;

    trace_flags = 0; /* flags will be set via modifers */

    while (modif && *modif) {
	 switch (*modif++)
    	 {
	  case 'd':
	    #ifdef TRACE_DEBUG
		trace_flags |= TRACE_DEBUG_FLAG;
	    #else
		db_printtf("<debug trace not compiled in, ignoring>\n");
	    #endif
	    break;

	  case 's': style = Stack  ; break;
	  case 'f': style = Frame  ; break;
	  case 'p': trace_flags |= TRACE_SHOWCALLPRESERVED_FLAG; break;
	  case 'a': trace_flags |= TRACE_SHOWADDRESS_FLAG; break;
	  case 'F': trace_flags |= TRACE_SHOWFRAME_FLAG; break;
	  case 'u': trace_flags |= TRACE_USER_FLAG; break;
	  default:
	    db_printf("unknown trace modifier [%c]\n", modif[-1]);
	    /*FALLTHROUGH*/
	  case 'h':
	    db_printf("usage: trace/[MODIFIER]  [ARG]\n");
	    db_printf("  u = include user trace\n");
	    db_printf("  F = print stack frames\n");
	    db_printf("  a = show return addresses\n");
	    db_printf("  p = show call-preserved registers\n");
	    db_printf("  s = ARG is a stack pointer\n");
	    db_printf("  f = ARG is a frame pointer\n");
	    #ifdef TRACE_DEBUG
		db_printf("  d = trace-debugging output\n");
	    #endif
	    return;
	}
    }

    if (!have_addr && style != Default) {
	db_printf("expecting argument with /s or /f\n");
	return;
    }
    if (have_addr && style == Default)
	style = Proc;

    switch(style)
    {
      case Default:
	regs = DDB_REGS;
	break;

      case Frame:
	regs = arg.frame;
	break;

      case Stack:
      {
	unsigned val1, val2, sxip;
	unsigned ptr;
	bzero((void*)&frame, sizeof(frame));
	#define REASONABLE_FRAME_DISTANCE 2048
d1129 2
a1130 8
	/*
	 * We've got to find the top of a stack frame so we can get both
	 * a PC and and real SP.
	 */
	for (ptr = arg.num;/**/; ptr += 4) {
	    /* Read a word from the named stack */
	    if (db_trace_get_val(ptr, &val1) == 0) {
		db_printf("can't read from %x, aborting.\n", ptr);
d1132 3
a1134 1
	    }
d1136 7
a1142 44
	    /*
	     * See if it's a frame pointer.... if so it will be larger than
	     * the address it was taken from (i.e. point back up the stack)
	     * and we'll be able to read where it points.
	     */
	    if (val1 <= ptr ||
		(val1 & 3)  ||
		val1 > (ptr + REASONABLE_FRAME_DISTANCE))
		    continue;

	    /* peek at the next word to see if it could be a return address */
	    if (db_trace_get_val(ptr, &sxip) == 0) {
		db_printf("can't read from %x, aborting.\n", ptr);
		return;
	    }
	    if (sxip == 0 || !db_trace_get_val(sxip, &val2))
		continue;

	    if (db_trace_get_val(val1, &val2) == 0) {
		db_printf("can't read from %x, aborting.\n", val1);
		continue;
	    }

	    /*
	     * The value we've just read will be either another frame pointer,
	     * or the start of another exception frame.
	     */
	    if (
		#ifdef JEFF_DEBUG
		    val2 == 0
		#else
		    val2 == 0x12345678
		#endif
	        && db_trace_get_val(val1-4, &val2) && val2 == val1
	        && db_trace_get_val(val1-8, &val2) && val2 == val1)
	    {
		    /* we've found a frame, so the stack must have been good */
		    db_printf("%x looks like a frame, accepting %x\n",val1,ptr);
		    break;
	    }

	    if (val2 > val1 && (val2 & 3) == 0) {
		/* well, looks close enough to be another frame pointer */
		db_printf("*%x = %x looks like a stack frame pointer, accepting %x\n", val1, val2, ptr);
d1144 74
a1217 1
	    }
d1220 1
a1220 11
	frame.r[31] = ptr;
	frame.epsr = 0x800003f0U;
	frame.sxip = sxip | 2;
	frame.snip = frame.sxip + 4;
	frame.sfip = frame.snip + 4;
db_printf("[r31=%x, sxip=%x]\n", frame.r[31], frame.sxip);
	regs = &frame;
      }
    }

    db_stack_trace_cmd2(regs);
@
