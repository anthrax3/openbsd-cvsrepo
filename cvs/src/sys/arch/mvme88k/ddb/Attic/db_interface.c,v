head	1.47;
access;
symbols
	OPENBSD_3_8:1.44.0.2
	OPENBSD_3_8_BASE:1.44
	OPENBSD_3_7:1.43.0.2
	OPENBSD_3_7_BASE:1.43
	OPENBSD_3_6:1.42.0.4
	OPENBSD_3_6_BASE:1.42
	SMP_SYNC_A:1.42
	SMP_SYNC_B:1.42
	OPENBSD_3_5:1.42.0.2
	OPENBSD_3_5_BASE:1.42
	OPENBSD_3_4:1.26.0.8
	OPENBSD_3_4_BASE:1.26
	UBC_SYNC_A:1.26
	OPENBSD_3_3:1.26.0.6
	OPENBSD_3_3_BASE:1.26
	OPENBSD_3_2:1.26.0.4
	OPENBSD_3_2_BASE:1.26
	OPENBSD_3_1:1.26.0.2
	OPENBSD_3_1_BASE:1.26
	UBC_SYNC_B:1.26
	UBC:1.21.0.2
	UBC_BASE:1.21
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.4.0.10
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.8
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.6
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.4
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	mvme88kport:1.1.1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	first_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.47
date	2005.10.24.19.28.29;	author miod;	state dead;
branches;
next	1.46;

1.46
date	2005.10.18.05.53.47;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2005.10.13.19.48.34;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2005.04.30.16.44.11;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2004.09.30.21.48.56;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2004.01.23.17.26.02;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2004.01.14.20.45.59;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2004.01.13.18.40.47;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2004.01.12.21.33.10;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2004.01.12.07.46.14;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2004.01.09.11.03.36;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2004.01.07.17.52.30;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2004.01.07.16.22.17;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2004.01.02.17.08.55;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2003.12.21.13.23.32;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2003.12.19.22.30.17;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2003.11.07.10.16.45;	author jmc;	state Exp;
branches;
next	1.30;

1.30
date	2003.10.05.22.20.28;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2003.10.05.20.23.52;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2003.10.03.21.46.24;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2003.09.16.20.49.03;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2002.03.14.03.15.56;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2002.03.14.01.26.38;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2001.12.22.09.49.39;	author smurph;	state Exp;
branches;
next	1.23;

1.23
date	2001.12.22.08.31.04;	author smurph;	state Exp;
branches;
next	1.22;

1.22
date	2001.12.22.07.35.43;	author smurph;	state Exp;
branches;
next	1.21;

1.21
date	2001.12.16.23.49.46;	author miod;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2001.12.14.04.30.11;	author smurph;	state Exp;
branches;
next	1.19;

1.19
date	2001.12.13.08.55.51;	author smurph;	state Exp;
branches;
next	1.18;

1.18
date	2001.11.27.05.37.00;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.09.00.12.15;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.06.19.53.15;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2001.09.23.02.52.02;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.20.17.02.31;	author mpech;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.31.01.06.26;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.26.02.37.00;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.24.22.45.42;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.01.22.43.43;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.08.08.09.11;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.16.00.01.51;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.09.05.44.37;	author smurph;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.08.00.02.18;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2001.02.01.03.38.12;	author smurph;	state Exp;
branches;
next	1.4;

1.4
date	99.02.09.06.36.24;	author smurph;	state Exp;
branches
	1.4.6.1;
next	1.3;

1.3
date	97.03.03.20.20.34;	author rahnds;	state Exp;
branches;
next	1.2;

1.2
date	97.03.03.19.07.06;	author rahnds;	state dead;
branches;
next	1.1;

1.1
date	95.10.18.10.54.28;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.10.54.28;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.03.03.19.31.56;	author rahnds;	state Exp;
branches;
next	;

1.4.6.1
date	2001.04.18.16.10.51;	author niklas;	state Exp;
branches;
next	1.4.6.2;

1.4.6.2
date	2001.07.04.10.19.52;	author niklas;	state Exp;
branches;
next	1.4.6.3;

1.4.6.3
date	2001.10.31.03.01.18;	author nate;	state Exp;
branches;
next	1.4.6.4;

1.4.6.4
date	2001.11.13.21.04.14;	author niklas;	state Exp;
branches;
next	1.4.6.5;

1.4.6.5
date	2001.12.05.00.39.12;	author niklas;	state Exp;
branches;
next	1.4.6.6;

1.4.6.6
date	2002.03.06.01.08.05;	author niklas;	state Exp;
branches;
next	1.4.6.7;

1.4.6.7
date	2002.03.28.10.36.02;	author niklas;	state Exp;
branches;
next	1.4.6.8;

1.4.6.8
date	2004.02.19.10.49.06;	author niklas;	state Exp;
branches;
next	;

1.21.2.1
date	2002.01.31.22.55.17;	author niklas;	state Exp;
branches;
next	1.21.2.2;

1.21.2.2
date	2002.06.11.03.37.09;	author art;	state Exp;
branches;
next	;


desc
@@


1.47
log
@Factorize db_interface code between luna88k and mvme88k, removing dead code
in the process; the arch-agnostic code keeps the ability for a specific
machine to define its own machine commands, such as "machine prom" for
mvme88k, in addition to the ``regular'' m88k machine commands.
@
text
@/*	$OpenBSD: db_interface.c,v 1.46 2005/10/18 05:53:47 miod Exp $	*/
/*
 * Mach Operating System
 * Copyright (c) 1993-1991 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON AND OMRON ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON AND OMRON DISCLAIM ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*
 * m88k interface to ddb debugger
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/reboot.h>

#include <uvm/uvm_extern.h>

#include <machine/asm_macro.h>		/* flush_pipeline()	*/
#include <machine/cmmu.h>		/* CMMU defs		*/
#include <machine/trap.h>		/* current_thread()	*/
#include <machine/db_machdep.h>		/* local ddb stuff	*/
#include <machine/bugio.h>		/* bug routines		*/
#include <machine/locore.h>
#ifdef M88100
#include <machine/m88100.h>
#include <machine/m8820x.h>
#endif

#include <ddb/db_access.h>
#include <ddb/db_command.h>
#include <ddb/db_extern.h>
#include <ddb/db_interface.h>
#include <ddb/db_output.h>
#include <ddb/db_sym.h>

extern label_t *db_recover;
extern unsigned db_trace_get_val(vaddr_t, unsigned *);
extern int frame_is_sane(db_regs_t *, int);
extern void cnpollc(int);
void kdbprinttrap(int, int);

void m88k_db_trap(int, struct trapframe *);
int ddb_nmi_trap(int, db_regs_t *);
void ddb_error_trap(char *, db_regs_t *);
void db_putc(int);
int db_getc(void);
int m88k_dmx_print(unsigned, unsigned, unsigned, unsigned);
void m88k_db_pause(unsigned);
void m88k_db_print_frame(db_expr_t, int, db_expr_t, char *);
void m88k_db_registers(db_expr_t, int, db_expr_t, char *);
void m88k_db_where(db_expr_t, int, db_expr_t, char *);
void m88k_db_frame_search(db_expr_t, int, db_expr_t, char *);
void m88k_db_iflush(db_expr_t, int, db_expr_t, char *);
void m88k_db_dflush(db_expr_t, int, db_expr_t, char *);
void m88k_db_peek(db_expr_t, int, db_expr_t, char *);
void m88k_db_noise(db_expr_t, int, db_expr_t, char *);
void m88k_db_translate(db_expr_t, int, db_expr_t, char *);
void m88k_db_cmmucfg(db_expr_t, int, db_expr_t, char *);
void m88k_db_prom_cmd(db_expr_t, int, db_expr_t, char *);

int 	db_active;
int 	db_noisy;

db_regs_t	ddb_regs;

/*
 *
 * If you really feel like understanding the following procedure and
 * macros, see pages 6-22 to 6-30 (Section 6.7.3) of
 *
 * MC88100 RISC Microprocessor User's Manual Second Edition
 * (Motorola Order: MC88100UM/AD REV 1)
 *
 * and ERRATA-5 (6-23, 6-24, 6-24) of
 *
 * Errata to MC88100 User's Manual Second Edition MC88100UM/AD Rev 1
 * (Oct 2, 1990)
 * (Motorola Order: MC88100UMAD/AD)
 *
 */

#ifdef M88100
/* macros for decoding dmt registers */

/*
 * return 1 if the printing of the next stage should be suppressed
 */
int
m88k_dmx_print(t, d, a, no)
	unsigned t, d, a, no;
{
	static const unsigned addr_mod[16] = {
		0, 3, 2, 2, 1, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0
	};
	static const char *mode[16]  = {
		"?", ".b", ".b", ".h", ".b", "?", "?", "?",
		".b", "?", "?" , "?" , ".h" , "?", "?", ""
	};
	static const unsigned mask[16] = {
		0, 0xff, 0xff00, 0xffff,
		0xff0000, 0, 0, 0,
		0xff000000, 0, 0, 0,
		0xffff0000, 0, 0, 0xffffffff
	};
	static const unsigned shift[16] = {
		0,  0, 8, 0, 16, 0, 0, 0,
		24, 0, 0, 0, 16, 0, 0, 0
	};
	int reg = DMT_DREGBITS(t);

	if (ISSET(t, DMT_LOCKBAR)) {
		db_printf("xmem%s%s r%d(0x%x) <-> mem(0x%x),",
			  DMT_ENBITS(t) == 0x0f ? "" : ".bu", ISSET(t, DMT_DAS) ? "" : ".usr", reg,
			  (((t)>>2 & 0xf) == 0xf) ? d : (d & 0xff), a);
		return 1;
	} else {
		if (DMT_ENBITS(t) == 0xf) {
			/* full or double word */
			if (ISSET(t, DMT_WRITE)) {
				if (ISSET(t, DMT_DOUB1) && no == 2)
					db_printf("st.d%s -> mem(0x%x) (** restart sxip **)",
						  ISSET(t, DMT_DAS) ? "" : ".usr", a);
				else
					db_printf("st%s (0x%x) -> mem(0x%x)",
						  ISSET(t, DMT_DAS) ? "" : ".usr", d, a);
			} else {
				/* load */
				if (ISSET(t, DMT_DOUB1) && no == 2)
					db_printf("ld.d%s r%d <- mem(0x%x), r%d <- mem(0x%x)",
						  ISSET(t, DMT_DAS) ? "" : ".usr", reg, a, reg+1, a+4);
				else
					db_printf("ld%s r%d <- mem(0x%x)",
						  ISSET(t, DMT_DAS) ? "" : ".usr", reg, a);
			}
		} else {
			/* fractional word - check if load or store */
			a += addr_mod[DMT_ENBITS(t)];
			if (ISSET(t, DMT_WRITE))
				db_printf("st%s%s (0x%x) -> mem(0x%x)",
					  mode[DMT_ENBITS(t)], ISSET(t, DMT_DAS) ? "" : ".usr",
					  (d & mask[DMT_ENBITS(t)]) >> shift[DMT_ENBITS(t)], a);
			else
				db_printf("ld%s%s%s r%d <- mem(0x%x)",
				    mode[DMT_ENBITS(t)],
				    ISSET(t, DMT_SIGNED) ? "" : "u",
				    ISSET(t, DMT_DAS) ? "" : ".usr", reg, a);
		}
	}
	return 0;
}
#endif	/* M88100 */

void
m88k_db_print_frame(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	struct trapframe *s = (struct trapframe *)addr;
	char *name;
	db_expr_t offset;
#ifdef M88100
	int suppress1 = 0, suppress2 = 0;
#endif
	int c, force = 0, help = 0;

	if (!have_addr) {
		db_printf("requires address of frame\n");
		help = 1;
	}

	while (modif && *modif) {
		switch (c = *modif++, c) {
		case 'f':
			force = 1;
			break;
		case 'h':
			help = 1;
			break;
		default:
			db_printf("unknown modifier [%c]\n", c);
			help = 1;
			break;
		}
	}

	if (help) {
		db_printf("usage: mach frame/[f] ADDRESS\n");
		db_printf("  /f force printing of insane frames.\n");
		return;
	}

	if (badwordaddr((vaddr_t)s) ||
	    badwordaddr((vaddr_t)(&((db_regs_t*)s)->fpit))) {
		db_printf("frame at %8p is unreadable\n", s);
		return;
	}

	if (frame_is_sane((db_regs_t *)s, 0) == 0) {	/* see db_trace.c */
		if (force == 0)
			return;
	}

#define R(i) s->tf_r[i]
#define IPMASK(x) ((x) &  ~(3))
	db_printf("R00-05: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
		  R(0), R(1), R(2), R(3), R(4), R(5));
	db_printf("R06-11: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
		  R(6), R(7), R(8), R(9), R(10), R(11));
	db_printf("R12-17: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
		  R(12), R(13), R(14), R(15), R(16), R(17));
	db_printf("R18-23: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
		  R(18), R(19), R(20), R(21), R(22), R(23));
	db_printf("R24-29: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
		  R(24), R(25), R(26), R(27), R(28), R(29));
	db_printf("R30-31: 0x%08x  0x%08x\n", R(30), R(31));

	db_printf("%cxip: 0x%08x ",
	    CPU_IS88110 ? 'e' : 's', s->tf_sxip & XIP_ADDR);
	db_find_xtrn_sym_and_offset((db_addr_t)IPMASK(s->tf_sxip),
	    &name, &offset);
	if (name != NULL && (unsigned)offset <= db_maxoff)
		db_printf("%s+0x%08x", name, (unsigned)offset);
	db_printf("\n");

	if (s->tf_snip != s->tf_sxip + 4) {
		db_printf("%cnip: 0x%08x ",
		    CPU_IS88110 ? 'e' : 's', s->tf_snip);
		db_find_xtrn_sym_and_offset((db_addr_t)IPMASK(s->tf_snip),
		    &name, &offset);
		if (name != NULL && (unsigned)offset <= db_maxoff)
			db_printf("%s+0x%08x", name, (unsigned)offset);
		db_printf("\n");
	}

#ifdef M88100
	if (CPU_IS88100) {
		if (s->tf_sfip != s->tf_snip + 4) {
			db_printf("sfip: 0x%08x ", s->tf_sfip);
			db_find_xtrn_sym_and_offset((db_addr_t)IPMASK(s->tf_sfip),
			    &name, &offset);
			if (name != NULL && (unsigned)offset <= db_maxoff)
				db_printf("%s+0x%08x", name, (unsigned)offset);
			db_printf("\n");
		}
	}
#endif
#ifdef M88110
	if (CPU_IS88110) {
		db_printf("fpsr: 0x%08x fpcr: 0x%08x fpecr: 0x%08x\n",
			  s->tf_fpsr, s->tf_fpcr, s->tf_fpecr);
		db_printf("dsap 0x%08x duap 0x%08x dsr 0x%08x dlar 0x%08x dpar 0x%08x\n",
			  s->tf_dsap, s->tf_duap, s->tf_dsr, s->tf_dlar, s->tf_dpar);
		db_printf("isap 0x%08x iuap 0x%08x isr 0x%08x ilar 0x%08x ipar 0x%08x\n",
			  s->tf_isap, s->tf_iuap, s->tf_isr, s->tf_ilar, s->tf_ipar);
	}
#endif

	db_printf("epsr: 0x%08x                current process: %p\n",
		  s->tf_epsr, curproc);
	db_printf("vector: 0x%02x                    interrupt mask: 0x%08x\n",
		  s->tf_vector, s->tf_mask);

	/*
	 * If the vector indicates trap, instead of an exception or
	 * interrupt, skip the check of dmt and fp regs.
	 *
	 * Interrupt and exceptions are vectored at 0-10 and 114-127.
	 */

	if (!(s->tf_vector <= 10 || (114 <= s->tf_vector && s->tf_vector <= 127))) {
		db_printf("\n");
		return;
	}

#ifdef M88100
	if (CPU_IS88100) {
		if (s->tf_vector == /*data*/3 || s->tf_dmt0 & DMT_VALID) {
			db_printf("dmt,d,a0: 0x%08x  0x%08x  0x%08x ",
			    s->tf_dmt0, s->tf_dmd0, s->tf_dma0);
			db_find_xtrn_sym_and_offset((db_addr_t)s->tf_dma0, &name, &offset);
			if (name != NULL && (unsigned)offset <= db_maxoff)
				db_printf("%s+0x%08x", name, (unsigned)offset);
			db_printf("\n          ");

			suppress1 = m88k_dmx_print(s->tf_dmt0, s->tf_dmd0, s->tf_dma0, 0);
			db_printf("\n");

			if ((s->tf_dmt1 & DMT_VALID) && (!suppress1)) {
				db_printf("dmt,d,a1: 0x%08x  0x%08x  0x%08x ",
				    s->tf_dmt1, s->tf_dmd1, s->tf_dma1);
				db_find_xtrn_sym_and_offset((db_addr_t)s->tf_dma1,
				    &name, &offset);
				if (name != NULL &&
				    (unsigned)offset <= db_maxoff)
					db_printf("%s+0x%08x", name, (unsigned)offset);
				db_printf("\n          ");
				suppress2 = m88k_dmx_print(s->tf_dmt1, s->tf_dmd1, s->tf_dma1, 1);
				db_printf("\n");

				if ((s->tf_dmt2 & DMT_VALID) && (!suppress2)) {
					db_printf("dmt,d,a2: 0x%08x  0x%08x  0x%08x ",
						  s->tf_dmt2, s->tf_dmd2, s->tf_dma2);
					db_find_xtrn_sym_and_offset((db_addr_t)s->tf_dma2,
								    &name, &offset);
					if (name != 0 && (unsigned)offset <= db_maxoff)
						db_printf("%s+0x%08x", name, (unsigned)offset);
					db_printf("\n          ");
					m88k_dmx_print(s->tf_dmt2, s->tf_dmd2, s->tf_dma2, 2);
					db_printf("\n");
				}
			}

			db_printf("fault code %d\n",
			    CMMU_PFSR_FAULT(s->tf_dpfsr));
		}
	}
#endif	/* M88100 */

	if (s->tf_fpecr & 255) { /* floating point error occurred */
		db_printf("fpecr: 0x%08x fpsr: 0x%08x fpcr: 0x%08x\n",
			  s->tf_fpecr, s->tf_fpsr, s->tf_fpcr);
#ifdef M88100
		if (CPU_IS88100) {
			db_printf("fcr1-4: 0x%08x  0x%08x  0x%08x  0x%08x\n",
				  s->tf_fphs1, s->tf_fpls1, s->tf_fphs2, s->tf_fpls2);
			db_printf("fcr5-8: 0x%08x  0x%08x  0x%08x  0x%08x\n",
				  s->tf_fppt, s->tf_fprh, s->tf_fprl, s->tf_fpit);
		}
#endif
	}
	db_printf("\n");
}

void
m88k_db_registers(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	m88k_db_print_frame((db_expr_t)DDB_REGS, TRUE, 0, modif);
}

/*
 * pause for 2*ticks many cycles
 */
void
m88k_db_pause(ticks)
	unsigned volatile ticks;
{
	while (ticks)
		ticks -= 1;
}

/*
 * m88k_db_trap - field a TRACE or BPT trap
 * Note that only the tf_regs part of the frame is valid - some ddb routines
 * invoke this function with a promoted struct reg!
 */
void
m88k_db_trap(type, frame)
	int type;
	struct trapframe *frame;
{

	if (get_psr() & PSR_IND)
		db_printf("WARNING: entered debugger with interrupts disabled\n");

	switch(type) {
	case T_KDB_BREAK:
	case T_KDB_TRACE:
	case T_KDB_ENTRY:
		break;
	case -1:
		break;
	default:
		kdbprinttrap(type, 0);
		if (db_recover != 0) {
			db_error("Caught exception in ddb.\n");
			/*NOTREACHED*/
		}
	}

	ddb_regs = frame->tf_regs;

	db_active++;
	cnpollc(TRUE);
	db_trap(type, 0);
	cnpollc(FALSE);
	db_active--;

	frame->tf_regs = ddb_regs;
}

extern const char *trap_type[];
extern const int trap_types;

/*
 * Print trap reason.
 */
void
kdbprinttrap(type, code)
	int type, code;
{
	printf("kernel: ");
	if (type >= trap_types || type < 0)
		printf("type %d", type);
	else
		printf("%s", trap_type[type]);
	printf(" trap\n");
}

void
Debugger()
{
	asm (ENTRY_ASM); /* entry trap */
	/* ends up at ddb_entry_trap below */
}

/* fielded a non maskable interrupt */
int
ddb_nmi_trap(level, eframe)
	int level;
	db_regs_t *eframe;
{
	if (db_noisy)
		db_printf("kernel: nmi interrupt\n");
	m88k_db_trap(T_KDB_ENTRY, (struct trapframe *)eframe);

	return 0;
}

/*
 * When the below routine is entered interrupts should be on
 * but spl should be high
 *
 * The following routine is for breakpoint and watchpoint entry.
 */

/* breakpoint/watchpoint entry */
int
ddb_break_trap(type, eframe)
	int type;
	db_regs_t *eframe;
{
	m88k_db_trap(type, (struct trapframe *)eframe);

	if (type == T_KDB_BREAK) {
		/*
		 * back up an instruction and retry the instruction
		 * at the breakpoint address.  mc88110's exip reg
		 * already has the address of the exception instruction.
		 */
		if (CPU_IS88100) {
			eframe->sfip = eframe->snip;
			eframe->snip = eframe->sxip;
		}
	}

	return 0;
}

/* enter at splhigh */
int
ddb_entry_trap(level, eframe)
	int level;
	db_regs_t *eframe;
{
	m88k_db_trap(T_KDB_ENTRY, (struct trapframe *)eframe);

	return 0;
}

/*
 * When the below routine is entered interrupts should be on
 * but spl should be high
 */
/* error trap - unreturnable */
void
ddb_error_trap(error, regs)
	char *error;
	db_regs_t *regs;
{
	db_printf("KERNEL:  terminal error [%s]\n", error);
	db_printf("KERNEL:  Exiting debugger will cause abort to rom\n");
	db_printf("at 0x%x ", regs->sxip & XIP_ADDR);
	db_printf("dmt0 0x%x dma0 0x%x", regs->dmt0, regs->dma0);
	m88k_db_pause(1000000);
	m88k_db_trap(T_KDB_BREAK, (struct trapframe *)regs);
}

/*
 * Read bytes from kernel address space for debugger.
 */
void
db_read_bytes(db_addr_t addr, size_t size, char *data)
{
	char *src;

	src = (char *)addr;

	while(size-- > 0) {
		*data++ = *src++;
	}
}

/*
 * Write bytes to kernel address space for debugger.
 * This should make a text page writable to be able
 * to plant a break point (right now text is mapped with
 * write access in pmap_bootstrap()). XXX nivas
 */
void
db_write_bytes(db_addr_t addr, size_t size, char *data)
{
	char *dst;
	paddr_t physaddr;
	psize_t psize = size;

	dst = (char *)addr;

	while (size-- > 0) {
		*dst++ = *data++;
	}
	/* XXX test return value */
	pmap_extract(pmap_kernel(), (vaddr_t)addr, &physaddr);
	cmmu_flush_cache(cpu_number(), physaddr, psize);
}

/* to print a character to the console */
void
db_putc(c)
	int c;
{
	bugoutchr(c & 0xff);
}

/* to peek at the console; returns -1 if no character is there */
int
db_getc()
{
	if (buginstat())
		return (buginchr());
	else
		return -1;
}

/* display where all the cpus are stopped at */
void
m88k_db_where(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	char *name;
	db_expr_t offset;
	db_addr_t l;

	l = PC_REGS(DDB_REGS); /* clear low bits */

	db_find_xtrn_sym_and_offset(l, &name, &offset);
	if (name && (unsigned)offset <= db_maxoff)
		db_printf("stopped at 0x%lx  (%s+0x%x)\n", l, name, offset);
	else
		db_printf("stopped at 0x%lx\n", l);
}

/*
 * Walk back a stack, looking for exception frames.
 * These frames are recognized by the routine frame_is_sane. Frames
 * only start with zero, so we only call frame_is_sane if the
 * current address contains zero.
 *
 * If addr is given, it is assumed to an address on the stack to be
 * searched. Otherwise, r31 of the current cpu is used.
 */
void
m88k_db_frame_search(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	if (have_addr)
		addr &= ~3; /* round to word */
	else
		addr = (DDB_REGS->r[31]);

	/* walk back up stack until 8k boundry, looking for 0 */
	while (addr & ((8 * 1024) - 1)) {
		if (frame_is_sane((db_regs_t *)addr, 1) != 0)
			db_printf("frame found at 0x%x\n", addr);
		addr += 4;
	}

	db_printf("(Walked back until 0x%x)\n",addr);
}

/* flush icache */
void
m88k_db_iflush(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	addr = 0;
#ifdef may_be_removed
	cmmu_remote_set(addr, CMMU_SCR, 0, CMMU_FLUSH_CACHE_CBI_ALL);
#endif
}

/* flush dcache */

void
m88k_db_dflush(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	addr = 0;
#ifdef may_be_removed
	cmmu_remote_set(addr, CMMU_SCR, 1, CMMU_FLUSH_CACHE_CBI_ALL);
#endif
}

/* probe my cache */
void
m88k_db_peek(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
#ifdef may_be_removed
	int pa12;
	int valmask;

	pa12 = addr & ~((1<<12) -1);

	/* probe dcache */
	cmmu_remote_set(0, CMMU_SAR, 1, addr);

	valmask = cmmu_remote_get(0, CMMU_CSSP, 1);
	db_printf("dcache valmask 0x%x\n", (unsigned)valmask);
	db_printf("dcache tag ports 0x%x 0x%x 0x%x 0x%x\n",
		  (unsigned)cmmu_remote_get(0, CMMU_CTP0, 1),
		  (unsigned)cmmu_remote_get(0, CMMU_CTP1, 1),
		  (unsigned)cmmu_remote_get(0, CMMU_CTP2, 1),
		  (unsigned)cmmu_remote_get(0, CMMU_CTP3, 1));

	/* probe icache */
	cmmu_remote_set(0, CMMU_SAR, 0, addr);

	valmask = cmmu_remote_get(0, CMMU_CSSP, 0);
	db_printf("icache valmask 0x%x\n", (unsigned)valmask);
	db_printf("icache tag ports 0x%x 0x%x 0x%x 0x%x\n",
		  (unsigned)cmmu_remote_get(0, CMMU_CTP0, 0),
		  (unsigned)cmmu_remote_get(0, CMMU_CTP1, 0),
		  (unsigned)cmmu_remote_get(0, CMMU_CTP2, 0),
		  (unsigned)cmmu_remote_get(0, CMMU_CTP3, 0));
#endif
}


/*
 * control how much info the debugger prints about itself
 */
void
m88k_db_noise(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	if (!have_addr) {
		/* if off make noisy; if noisy or very noisy turn off */
		if (db_noisy) {
			db_printf("changing debugger status from %s to quiet\n",
				  db_noisy == 1 ? "noisy" :
				  db_noisy == 2 ? "very noisy" : "violent");
			db_noisy = 0;
		} else {
			db_printf("changing debugger status from quiet to noisy\n");
			db_noisy = 1;
		}
	} else if (addr < 0 || addr > 3)
		db_printf("invalid noise level to m88k_db_noisy; should be 0, 1, 2, or 3\n");
	else {
		db_noisy = addr;
		db_printf("debugger noise level set to %s\n",
			  db_noisy == 0 ? "quiet" :
			  (db_noisy == 1 ? "noisy" :
			   db_noisy==2 ? "very noisy" : "violent"));
	}
}

/*
 * See how a virtual address translates.
 * Must have an address.
 */
void
m88k_db_translate(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	char c;
	int verbose_flag = 0;
	int supervisor_flag = 1;
	int wanthelp = 0;

	if (!have_addr)
		wanthelp = 1;
	else {
		while (c = *modif++, c != 0) {
			switch (c) {
			default:
				db_printf("bad modifier [%c]\n", c);
				wanthelp = 1;
				break;
			case 'h':
				wanthelp = 1;
				break;
			case 'v':
				verbose_flag++;
				break;
			case 's':
				supervisor_flag = 1;
				break;
			case 'u':
				supervisor_flag = 0;
				break;
			}
		}
	}

	if (wanthelp) {
		db_printf("usage: translate[/vvsu] address\n");
		db_printf("flags: v - be verbose (vv - be very verbose)\n");
		db_printf("       s - use cmmu's supervisor area pointer (default)\n");
		db_printf("       u - use cmmu's user area pointer\n");
		return;
	}
	cmmu_show_translation(addr, supervisor_flag, verbose_flag, -1);
}

void
m88k_db_cmmucfg(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	if (modif != NULL && *modif != 0) {
		db_printf("usage: mach cmmucfg\n");
	return;
	}

	cmmu_dump_config();
}

void
m88k_db_prom_cmd(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	doboot();
}

/************************/
/* COMMAND TABLE / INIT */
/************************/

struct db_command m88k_cache_cmds[] = {
	{ "iflush",	m88k_db_iflush,	0,	NULL },
	{ "dflush",	m88k_db_dflush,	0,	NULL },
	{ "peek",	m88k_db_peek,	0,	NULL },
	{ NULL,		NULL,		0,	NULL }
};

struct db_command db_machine_cmds[] = {
	{ "cache",	NULL,			0,	m88k_cache_cmds },
	{ "frame",	m88k_db_print_frame,	0,	NULL },
	{ "regs",	m88k_db_registers,	0,	NULL },
	{ "noise",	m88k_db_noise,		0,	NULL },
	{ "searchframe",m88k_db_frame_search,	0,	NULL },
	{ "translate",	m88k_db_translate,	0,	NULL },
	{ "cmmucfg",	m88k_db_cmmucfg,	0,	NULL },
	{ "where",	m88k_db_where,		0,	NULL },
	{ "prom",	m88k_db_prom_cmd,	0,	NULL },
	{ NULL,		NULL,			0,	NULL }
};

void
db_machine_init()
{
	db_machine_commands_install(db_machine_cmds);
}
@


1.46
log
@Use PSR_IND rather than recomputing it from PSR_INTERRUPT_DISABLE_BIT;
spotted by martin.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.45 2005/10/13 19:48:34 miod Exp $	*/
@


1.45
log
@Merge <machine/cpu_number.h> into <machine/cpu.h>, preparing for intrusive
changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.44 2005/04/30 16:44:11 miod Exp $	*/
d391 1
a391 1
	if (get_psr() & (1 << PSR_INTERRUPT_DISABLE_BIT))
@


1.44
log
@Use [XNF]IP_ADDR constants rather than their numeric values.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.43 2004/09/30 21:48:56 miod Exp $	*/
a45 1
#include <machine/cpu_number.h>
@


1.43
log
@Introduce sparc-like CPU_ISFOO macros, to short-circuit evaluations when
compiling for one flavour only.

This makes code slightly smaller on all m88k-based platforms (my roughly
1KB), and saves more than meets the eye on luna88k, which is m88100-based.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.42 2004/01/23 17:26:02 miod Exp $	*/
d244 1
a244 1
	    CPU_IS88110 ? 'e' : 's', s->tf_sxip & ~3);
@


1.42
log
@Get rid of a few (mostly DDB related) unused defines and macros.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.41 2004/01/14 20:45:59 miod Exp $	*/
d244 1
a244 1
	    cputyp == CPU_88110 ? 'e' : 's', s->tf_sxip & ~3);
d253 1
a253 1
		    cputyp == CPU_88110 ? 'e' : 's', s->tf_snip);
d261 2
a262 1
	if (cputyp != CPU_88110) {
d271 4
a274 1
	} else {
d282 1
d302 1
a302 1
	if (cputyp != CPU_88110) {
d349 1
a349 1
		if (cputyp != CPU_88110) {
d480 3
a482 3
		if (cputyp != CPU_88110) {
		eframe->sfip = eframe->snip;
		eframe->snip = eframe->sxip;
@


1.41
log
@Some MC8820x operation cleaning:
- define more constants and macros for readability. Especially cache
  initialization suddently becomes more readable.
- after every flush operation, wait for the operation to complete by
  accessing the status register, before returning.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.40 2004/01/13 18:40:47 miod Exp $	*/
d387 1
a387 1
	if (db_are_interrupts_disabled())
@


1.40
log
@Let frame_is_sane() be quiet on demand, then fix and enable again frame search.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.39 2004/01/12 21:33:10 miod Exp $	*/
d47 1
d49 2
d187 1
d189 1
d334 2
a335 2
			db_printf("fault code %d dpfsr %x\n",
			    (s->tf_dpfsr >> 16) & 0x07, s->tf_dpfsr);
@


1.39
log
@Shrink the reg structure, for it to only contain registers (eh), and make
the remaining fielhs only available in struct trapframe.

This has the additional benefit of preventing smarty-pants from altering
the frame a bit too easily from ddb, at the expense of a few ugly casts in
ddb.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.38 2004/01/12 07:46:14 miod Exp $	*/
d58 1
a58 1
extern int frame_is_sane(db_regs_t *);
d219 2
a220 7
	if (!frame_is_sane((db_regs_t *)s)) {  /* see db_trace.c */
		db_printf("frame seems insane (");

		if (force)
			db_printf("forging ahead anyway...)\n");
		else {
			db_printf("use /f to force)\n");
a221 1
		}
a600 3
#if 1
	db_printf("sorry, frame search currently disabled.\n");
#else
d608 2
a609 4
		int i;
		db_read_bytes(addr, 4, &i);
		if (i == 0 && frame_is_sane((db_regs_t *)i))
			db_printf("frame found at 0x%x\n", i);
a613 1
#endif
@


1.38
log
@Get rid of that ugly m88100_saved_state structure, use trapframe everywhere
instead.

Allow struct reg and struct trapframe to live different lives and grow
separately. Righty now they are still the same, and code expects a trapframe
to always start with a struct reg. This may change...
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.37 2004/01/09 11:03:36 miod Exp $	*/
d214 1
a214 1
	    badwordaddr((vaddr_t)(&((db_regs_t*)s)->mode))) {
d378 3
a380 1
 *  m88k_db_trap - field a TRACE or BPT trap
d383 1
a383 1
m88k_db_trap(type, regs)
d385 1
a385 1
	struct trapframe *regs;
a386 6
#if 0
	int i;

	if ((i = db_spl()) != 7)
		db_printf("WARNING: spl is not high in m88k_db_trap (spl=%x)\n", i);
#endif /* 0 */
a391 1

d406 1
a406 1
	ddb_regs = *((struct reg *)regs);
d414 1
a414 5
	*((struct reg *)regs) = ddb_regs;

#if 0
	(void) spl7();
#endif
d508 1
a508 1
	db_printf("at 0x%x ", regs->sxip & ~3);
@


1.37
log
@Constify trap names, and a few cleanings to the trap() functions.

While there, use raisespl() in splassert to win a few cycles when the
check fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.36 2004/01/07 17:52:30 miod Exp $	*/
d62 1
a62 1
void m88k_db_trap(int, struct m88100_saved_state *);
d181 1
a181 1
	struct m88100_saved_state *s = (struct m88100_saved_state *)addr;
d230 1
a230 1
#define R(i) s->r[i]
d245 2
a246 2
	    cputyp == CPU_88110 ? 'e' : 's', s->sxip & ~3);
	db_find_xtrn_sym_and_offset((db_addr_t)IPMASK(s->sxip),
d252 1
a252 1
	if (s->snip != s->sxip + 4) {
d254 2
a255 2
		    cputyp == CPU_88110 ? 'e' : 's', s->snip);
		db_find_xtrn_sym_and_offset((db_addr_t)IPMASK(s->snip),
d263 3
a265 3
		if (s->sfip != s->snip + 4) {
			db_printf("sfip: 0x%08x ", s->sfip);
			db_find_xtrn_sym_and_offset((db_addr_t)IPMASK(s->sfip),
d273 1
a273 1
			  s->fpsr, s->fpcr, s->fpecr);
d275 1
a275 1
			  s->dsap, s->duap, s->dsr, s->dlar, s->dpar);
d277 1
a277 1
			  s->isap, s->iuap, s->isr, s->ilar, s->ipar);
d281 1
a281 1
		  s->epsr, curproc);
d283 1
a283 1
		  s->vector, s->mask);
d292 1
a292 1
	if (!(s->vector <= 10 || (114 <= s->vector && s->vector <= 127))) {
d299 1
a299 1
		if (s->vector == /*data*/3 || s->dmt0 & DMT_VALID) {
d301 2
a302 2
			    s->dmt0, s->dmd0, s->dma0);
			db_find_xtrn_sym_and_offset((db_addr_t)s->dma0, &name, &offset);
d307 1
a307 1
			suppress1 = m88k_dmx_print(s->dmt0, s->dmd0, s->dma0, 0);
d310 1
a310 1
			if ((s->dmt1 & DMT_VALID) && (!suppress1)) {
d312 2
a313 2
				    s->dmt1, s->dmd1, s->dma1);
				db_find_xtrn_sym_and_offset((db_addr_t)s->dma1,
d319 1
a319 1
				suppress2 = m88k_dmx_print(s->dmt1, s->dmd1, s->dma1, 1);
d322 1
a322 1
				if ((s->dmt2 & DMT_VALID) && (!suppress2)) {
d324 2
a325 2
						  s->dmt2, s->dmd2, s->dma2);
					db_find_xtrn_sym_and_offset((db_addr_t)s->dma2,
d330 1
a330 1
					m88k_dmx_print(s->dmt2, s->dmd2, s->dma2, 2);
d336 1
a336 1
			    (s->dpfsr >> 16) & 0x07, s->dpfsr);
d341 1
a341 1
	if (s->fpecr & 255) { /* floating point error occurred */
d343 1
a343 1
			  s->fpecr, s->fpsr, s->fpcr);
d347 1
a347 1
				  s->fphs1, s->fpls1, s->fphs2, s->fpls2);
d349 1
a349 1
				  s->fppt, s->fprh, s->fprl, s->fpit);
d383 1
a383 1
	struct m88100_saved_state *regs;
d411 1
a411 1
	ddb_regs = *regs;
d419 1
a419 1
	*regs = ddb_regs;
d459 1
a459 1
	m88k_db_trap(T_KDB_ENTRY, eframe);
d477 1
a477 1
	m88k_db_trap(type, eframe);
d500 1
a500 1
	m88k_db_trap(T_KDB_ENTRY, eframe);
d511 1
a511 1
ddb_error_trap(error, eframe)
d513 1
a513 1
	db_regs_t *eframe;
d517 2
a518 2
	db_printf("at 0x%x ", eframe->sxip & ~3);
	db_printf("dmt0 0x%x dma0 0x%x", eframe->dmt0, eframe->dma0);
d520 1
a520 1
	m88k_db_trap(T_KDB_BREAK, eframe);
a586 1
	struct m88100_saved_state *s;
d591 1
a591 3
	s = DDB_REGS;

	l = PC_REGS(s); /* clear low bits */
@


1.36
log
@Constify, remove db_task_name() Mach leftover, and fix an hilarious typo
in db_interface.c comments while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.35 2004/01/07 16:22:17 miod Exp $	*/
d426 2
a427 2
extern char *trap_type[];
extern int trap_types;
@


1.35
log
@Remove duplicate definitions with MI ddb headers, and fix db_stack_trace_print
prototype in the process.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.34 2004/01/02 17:08:55 miod Exp $	*/
a66 2
void cpu_interrupt_to_db(int);
char *db_task_name(void);
d91 1
a91 1
 * MC881000 RISC Microprocessor User's Manual Second Edition
d102 1
d112 1
a112 1
	static unsigned addr_mod[16] = {
d116 1
a116 1
	static char *mode[16]  = {
d120 1
a120 1
	static unsigned mask[16] = {
d126 1
a126 1
	static unsigned shift[16] = {
d172 1
d297 1
d339 1
d344 1
d351 1
a805 5
void cpu_interrupt_to_db(cpu_no)
	int cpu_no;
{
}

d820 5
a824 6
struct db_command m88k_cache_cmds[] =
{
	{ "iflush",    m88k_db_iflush, 0, 0},
	{ "dflush",    m88k_db_dflush, 0, 0},
	{ "peek",      m88k_db_peek, 0, 0},
	{ (char *) 0,}
d827 11
a837 12
struct db_command db_machine_cmds[] =
{
	{"cache",           0,                      0, m88k_cache_cmds},
	{"frame",           m88k_db_print_frame,    0, 0},
	{"regs",            m88k_db_registers,      0, 0},
	{"noise",           m88k_db_noise,          0, 0},
	{"searchframe",     m88k_db_frame_search,   0, 0},
	{"translate",       m88k_db_translate,      0, 0},
	{"cmmucfg",         m88k_db_cmmucfg,        0, 0},
	{"where",           m88k_db_where,          0, 0},
	{"prom",            m88k_db_prom_cmd,       0, 0},
	{(char  *) 0,}
a839 3
/*
 * Called from "m88k/m1x7_init.c"
 */
a844 55

/*
 * Attempt to figure out the UX name of the task.
 * This is kludgy at best... we can't even be sure the task is a UX task...
 */
#define TOP_OF_USER_STACK USRSTACK
#define MAX_DISTANCE_TO_LOOK (1024 * 10)

#define DB_TASK_NAME_LEN 50

char *
db_task_name()
{
	static unsigned buffer[(DB_TASK_NAME_LEN + 5) / sizeof(unsigned)];
	vaddr_t ptr = (vaddr_t)(TOP_OF_USER_STACK - 4);
	vaddr_t limit = ptr - MAX_DISTANCE_TO_LOOK;
	unsigned word;
	int i;

	/* skip zeros at the end */
	while (ptr > limit &&
	       (i = db_trace_get_val(ptr, &word)) && (word == 0)) {
		ptr -= 4; /* continue looking for a non-null word */
	}

	if (ptr <= limit) {
		db_printf("bad name at line %d\n", __LINE__);
		return "<couldn't find 1>";
	} else if (i != 1) {
		return "<nostack>";
	}

	/* skip looking for null before all the text */
	while (ptr > limit &&
	       (i = db_trace_get_val(ptr, &word)) && (word != 0)) {
		ptr -= 4; /* continue looking for a null word */
	}

	if (ptr <= limit) {
		db_printf("bad name at line %d\n", __LINE__);
		return "<couldn't find 2>";
	} else if (i != 1) {
		db_printf("bad name read of %lx at line %d\n", ptr, __LINE__);
		return "<bad read 2>";
	}

	ptr += 4; /* go back to the non-null word after this one */

	for (i = 0; i < sizeof(buffer); i++, ptr += 4) {
		buffer[i] = 0; /* just in case it's not read */
		db_trace_get_val(ptr, &buffer[i]);
	}
	return (char *)buffer;
}

@


1.34
log
@When both cmmu_dofoo() and cmmu_remote_dofoo() exist, kill the first one,
and rename the second one to the first one, i.e. have the cmmu_dofoo()
functions always take a cpu# parameter.

No functional change, simply makes code more readable and saves a few
call frames.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.33 2003/12/21 13:23:32 miod Exp $	*/
a56 1
extern unsigned int db_maxoff;
d83 2
a84 3
int 	db_active = 0;
int 	db_noisy = 0;
int	quiet_db_read_bytes = 0;
@


1.33
log
@Switch db_expr_t from int to long, per consistency with other platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.32 2003/12/19 22:30:17 miod Exp $	*/
d556 1
a556 1
	cmmu_flush_cache(physaddr, psize);
@


1.32
log
@Pass -Wformat, and silence a few vme* debug printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.31 2003/11/07 10:16:45 jmc Exp $	*/
d358 1
a358 1
	int count;
@


1.31
log
@adress -> address, and a few more; all from Jonathon Gray;

(mvme68k/mvme88k) vs.c and (vax) if_le.c ok miod@@
isakmpd ones ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.30 2003/10/05 22:20:28 miod Exp $	*/
d217 1
a217 1
		db_printf("frame at 0x%08x is unreadable\n", s);
d282 1
a282 1
	db_printf("epsr: 0x%08x                current process: 0x%x\n",
d513 1
a513 1
	db_printf("KERNEL:  terminal error [%s]\n",(int)error);
d587 2
a588 2
	int *offset;
	int l;
d594 1
a594 1
	db_find_xtrn_sym_and_offset((db_addr_t) l,&name, (db_expr_t*)&offset);
d596 1
a596 1
		db_printf("stopped at 0x%x  (%s+0x%x)\n", l, name, offset);
d598 1
a598 1
		db_printf("stopped at 0x%x\n", l);
d895 1
a895 1
		db_printf("bad name read of %x at line %d\n", ptr, __LINE__);
@


1.30
log
@Bang head against wall, unbreak ddb, do not collect $2000, and go to sleep.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.29 2003/10/05 20:23:52 miod Exp $	*/
d481 1
a481 1
		 * already has the adress of the exception instruction.
@


1.29
log
@Correct db_{read,write}_bytes prototypes and use the official ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.28 2003/10/03 21:46:24 miod Exp $	*/
d531 1
a531 1
	while(--size >= 0) {
d551 1
a551 1
	while (--size >= 0) {
@


1.28
log
@Use the commen DMT constants, and try to provide at least as many information
in "machine frame" than regdump() does.

XXX this whole ddb/ directory needs a huge KNF spanking, badly
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.27 2003/09/16 20:49:03 miod Exp $	*/
d45 1
a45 1
#include <machine/locore.h>		 
d49 1
d58 1
a58 1
extern unsigned db_trace_get_val(vm_offset_t addr, unsigned *ptr);
d61 1
a61 1
void kdbprinttrap(int type, int code);
d63 4
a66 6
void m88k_db_trap(int type, struct m88100_saved_state *regs);
int ddb_nmi_trap(int level, db_regs_t *eframe);
void ddb_error_trap(char *error, db_regs_t *eframe);
void db_read_bytes(vm_offset_t addr, int size, char *data);
void db_write_bytes(char *addr, int size, char *data);
void db_putc(int c);
d68 1
a68 1
void cpu_interrupt_to_db(int cpu_no);
d215 2
a216 2
	if (badwordaddr((vm_offset_t)s) ||
	    badwordaddr((vm_offset_t)(&((db_regs_t*)s)->mode))) {
d381 1
a381 1
	register struct m88100_saved_state *regs;
d394 1
a394 1
    
d408 1
a408 1
    
d410 1
a410 1
    
d433 1
a433 1
{       
d436 2
a437 2
		printf("type %d", type); 
	else    
d440 1
a440 1
}       
d480 1
a480 1
		 * at the breakpoint address.  mc88110's exip reg 
d525 1
a525 4
db_read_bytes(addr, size, data)
	vm_offset_t     addr;
	register int    size;
	register char   *data;
d527 1
a527 1
	register char	*src;
d543 5
a547 8
db_write_bytes(addr, size, data)
	char *addr;
	int size;
	char *data;
{
	register char *dst;
	vm_offset_t physaddr;
	int i = size;
d550 1
a550 1
	
d552 1
a552 4
#if 0
		db_printf("byte %x\n", *data);
#endif
		*dst++ = *data++;    
d554 3
a556 2
	pmap_extract(pmap_kernel(), (vm_offset_t)addr, &physaddr);
	cmmu_flush_cache(physaddr, i); 
d649 1
a649 1
#endif 
d664 1
a664 1
#endif 
d702 1
a702 1
#endif 
d760 1
a760 1
				db_printf("bad modifier [%c]\n", c); 
d867 2
a868 2
	unsigned ptr = (vm_offset_t)(TOP_OF_USER_STACK - 4);
	unsigned limit = ptr - MAX_DISTANCE_TO_LOOK;
d874 1
a874 1
	       (i = db_trace_get_val((vm_offset_t)ptr, &word)) && (word == 0)) {
d903 1
a903 1
		db_trace_get_val((vm_offset_t)ptr, &buffer[i]);
@


1.27
log
@Clean <machine/db_machdep.h> of unused material. Also, let this file be
includable even without option DDB, in which case it will only define
the PC_REGS(), inst_return() and inst_call() macros; this removes the need
to declare them a second time in trap.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.26 2002/03/14 03:15:56 millert Exp $	*/
d47 1
a88 4
/************************/
/* 	DB_REGISTERS ****/
/************************/

a108 9
#define XMEM(x)  ((x) & (1<<12))
#define XMEM_MODE(x) ((((x)>>2 & 0xf) == 0xf) ? "" : ".bu")
#define MODE(x) ((x)>>2 & 0xf)
#define DOUB(x) ((x) & (1<<13))
#define SIGN(x) ((x) & (1<<6))
#define DAS(x) (((x) & (1<<14)) ? "" : ".usr")
#define REG(x) (((x)>>7) & 0x1f)
#define STORE(x) ((x) & 0x2)

d110 1
a110 1
 * return 1 if the printing of the next stage should be surpressed
d122 1
a122 1
		".b", ".h", "?" , "?" , "?" , "?", "?", ""
d125 4
a128 4
		0,           0xff,        0xff00,     0xffff,
		0xff0000,    0,           0,          0,
		0xff000000U, 0xffff0000U, 0,          0,
		0,           0,           0,          0xffffffffU
d132 1
a132 1
		24, 16, 0, 0,  0, 0, 0, 0
d134 1
a134 1
	int reg = REG(t);
d136 1
a136 1
	if (XMEM(t)) {
d138 1
a138 1
			  XMEM_MODE(t), DAS(t), reg,
d142 1
a142 1
		if (MODE(t) == 0xf) {
d144 2
a145 2
			if (STORE(t)) {
				if (DOUB(t) && no == 2)
d147 1
a147 1
						  DAS(t), a);
d150 1
a150 1
						  DAS(t), d, a);
d153 1
a153 1
				if (DOUB(t) && no == 2)
d155 1
a155 1
						  DAS(t), reg, a, reg+1, a+4);
d158 1
a158 1
						  DAS(t), reg, a);
d162 2
a163 2
			a += addr_mod[MODE(t)];
			if (STORE(t))
d165 2
a166 2
					  mode[MODE(t)], DAS(t),
					  (d & mask[MODE(t)]) >> shift[MODE(t)], a);
d169 3
a171 2
					  mode[MODE(t)], SIGN(t) ? "" : "u",
					  DAS(t), reg, a);
d187 1
a187 1
	int surpress1 = 0, surpress2 = 0;
d247 2
a248 1
	db_printf("%sxip: 0x%08x ", cputyp == CPU_88110 ? "e" : "s", s->sxip & ~3);
d250 2
a251 2
				    &name, &offset);
	if (name != 0 && (unsigned)offset <= db_maxoff)
d256 2
a257 1
		db_printf("%snip: 0x%08x ", cputyp == CPU_88110 ? "e" : "s", s->snip);
d259 2
a260 2
					    &name, &offset);
		if (name != 0 && (unsigned)offset <= db_maxoff)
d269 2
a270 2
						    &name, &offset);
			if (name != 0 && (unsigned)offset <= db_maxoff)
d301 1
a301 1
		if (s->vector == /*data*/3 || s->dmt0 & 1) {
d303 1
a303 1
				  s->dmt0, s->dmd0, s->dma0);
d305 1
a305 1
			if (name != 0 && (unsigned)offset <= db_maxoff)
d308 2
a309 1
			surpress1 = m88k_dmx_print(s->dmt0|0x01, s->dmd0, s->dma0, 0);
d312 1
a312 1
			if ((s->dmt1 & 1) && (!surpress1)) {
d314 1
a314 1
					  s->dmt1, s->dmd1, s->dma1);
d316 3
a318 2
							    &name, &offset);
				if (name != 0 && (unsigned)offset <= db_maxoff)
d321 1
a321 1
				surpress2 = m88k_dmx_print(s->dmt1, s->dmd1, s->dma1, 1);
d324 1
a324 1
				if ((s->dmt2 & 1) && (!surpress2)) {
d336 3
a363 4

/************************/
/* PAUSE ****************/
/************************/
@


1.26
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.25 2002/03/14 01:26:38 millert Exp $	*/
d464 2
a465 1
	NOISY(db_printf("kernel: nmi interrupt\n");)
d609 1
a609 1
	l = m88k_pc(s); /* clear low bits */
@


1.25
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.24 2001/12/22 09:49:39 smurph Exp $	*/
d921 1
a921 1
	return (char*)buffer;
@


1.24
log
@masive cmmu overhaul.  function pointers now control cmmu functionality
instead of case statements based on cpu type.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.22 2001/12/22 07:35:43 smurph Exp $	*/
d57 26
a82 26
extern int frame_is_sane __P((db_regs_t *));
extern void cnpollc __P((int));
void kdbprinttrap __P((int type, int code));

void m88k_db_trap __P((int type, struct m88100_saved_state *regs));
int ddb_nmi_trap __P((int level, db_regs_t *eframe));
void ddb_error_trap __P((char *error, db_regs_t *eframe));
void db_read_bytes __P((vm_offset_t addr, int size, char *data));
void db_write_bytes __P((char *addr, int size, char *data));
void db_putc __P((int c));
int db_getc __P((void));
void cpu_interrupt_to_db __P((int cpu_no));
char *db_task_name __P((void));
int m88k_dmx_print __P((unsigned, unsigned, unsigned, unsigned));
void m88k_db_pause __P((unsigned));
void m88k_db_print_frame __P((db_expr_t, int, db_expr_t, char *));
void m88k_db_registers __P((db_expr_t, int, db_expr_t, char *));
void m88k_db_where __P((db_expr_t, int, db_expr_t, char *));
void m88k_db_frame_search __P((db_expr_t, int, db_expr_t, char *));
void m88k_db_iflush __P((db_expr_t, int, db_expr_t, char *));
void m88k_db_dflush __P((db_expr_t, int, db_expr_t, char *));
void m88k_db_peek __P((db_expr_t, int, db_expr_t, char *));
void m88k_db_noise __P((db_expr_t, int, db_expr_t, char *));
void m88k_db_translate __P((db_expr_t, int, db_expr_t, char *));
void m88k_db_cmmucfg __P((db_expr_t, int, db_expr_t, char *));
void m88k_db_prom_cmd __P((db_expr_t, int, db_expr_t, char *));
@


1.23
log
@mc88110 support in ddb.  Bring in bit definitions.
We can support hardware sstep for mc88110 and
software sstep for mc88100.
@
text
@d41 1
a41 1
#include <machine/m8820x.h>		/* CMMU defs		*/
a45 1
#include <machine/mmu.h>
d663 1
d665 1
d678 1
d680 1
d691 1
d718 1
@


1.22
log
@rename m882xx.h to m8820x.h
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.21 2001/12/16 23:49:46 miod Exp $	*/
d40 5
a44 4
#include <machine/m8820x.h>		 /* CMMU defs		        */
#include <machine/trap.h>		 /* current_thread()            */
#include <machine/db_machdep.h>		 /* local ddb stuff             */
#include <machine/bugio.h>		 /* bug routines 		*/
d74 1
d130 2
a131 2
	    0, 3, 2, 2, 1, 0, 0, 0,
	    0, 0, 0, 0, 0, 0, 0, 0
d134 2
a135 2
	    "?", ".b", ".b", ".h", ".b", "?", "?", "?",
	    ".b", ".h", "?" , "?" , "?" , "?", "?", ""
d138 4
a141 4
	    0,           0xff,        0xff00,     0xffff,
	    0xff0000,    0,           0,          0,
	    0xff000000U, 0xffff0000U, 0,          0,
	    0,           0,           0,          0xffffffffU
d144 2
a145 2
	    0,  0, 8, 0, 16, 0, 0, 0,
	    24, 16, 0, 0,  0, 0, 0, 0
d151 2
a152 2
		    XMEM_MODE(t), DAS(t), reg,
		    (((t)>>2 & 0xf) == 0xf) ? d : (d & 0xff), a);
d160 1
a160 1
					    DAS(t), a);
d163 1
a163 1
					    DAS(t), d, a);
d168 1
a168 1
					    DAS(t), reg, a, reg+1, a+4);
d171 1
a171 1
					    DAS(t), reg, a);
d178 2
a179 2
				    mode[MODE(t)], DAS(t),
				    (d & mask[MODE(t)]) >> shift[MODE(t)], a);
d182 2
a183 2
				    mode[MODE(t)], SIGN(t) ? "" : "u",
				    DAS(t), reg, a);
d248 1
a248 1
	    R(0), R(1), R(2), R(3), R(4), R(5));
d250 1
a250 1
	    R(6), R(7), R(8), R(9), R(10), R(11));
d252 1
a252 1
	    R(12), R(13), R(14), R(15), R(16), R(17));
d254 1
a254 1
	    R(18), R(19), R(20), R(21), R(22), R(23));
d256 1
a256 1
	    R(24), R(25), R(26), R(27), R(28), R(29));
d259 1
a259 1
	db_printf("sxip: 0x%08x ", s->sxip & ~3);
d261 1
a261 1
	    &name, &offset);
d267 1
a267 1
		db_printf("snip: 0x%08x ", s->snip);
d269 1
a269 1
		    &name, &offset);
d275 16
a290 7
	if (s->sfip != s->snip + 4) {
		db_printf("sfip: 0x%08x ", s->sfip);
		db_find_xtrn_sym_and_offset((db_addr_t)IPMASK(s->sfip),
		    &name, &offset);
		if (name != 0 && (unsigned)offset <= db_maxoff)
			db_printf("%s+0x%08x", name, (unsigned)offset);
		db_printf("\n");
d293 2
d296 1
a296 3
	    s->vector, s->mask);
	db_printf("epsr: 0x%08x                current process: 0x%x\n",
	    s->epsr, curproc);
d306 1
a306 1
		db_printf("\n\n");
d310 5
a314 15
	if (s->vector == /*data*/3 || s->dmt0 & 1) {
		db_printf("dmt,d,a0: 0x%08x  0x%08x  0x%08x ",
		    s->dmt0, s->dmd0, s->dma0);
		db_find_xtrn_sym_and_offset((db_addr_t)s->dma0, &name, &offset);
		if (name != 0 && (unsigned)offset <= db_maxoff)
			db_printf("%s+0x%08x", name, (unsigned)offset);
		db_printf("\n          ");
		surpress1 = m88k_dmx_print(s->dmt0|0x01, s->dmd0, s->dma0, 0);
		db_printf("\n");

		if ((s->dmt1 & 1) && (!surpress1)) {
			db_printf("dmt,d,a1: 0x%08x  0x%08x  0x%08x ",
			    s->dmt1, s->dmd1, s->dma1);
			db_find_xtrn_sym_and_offset((db_addr_t)s->dma1,
			    &name, &offset);
d318 1
a318 1
			surpress2 = m88k_dmx_print(s->dmt1, s->dmd1, s->dma1, 1);
d321 5
a325 5
			if ((s->dmt2 & 1) && (!surpress2)) {
				db_printf("dmt,d,a2: 0x%08x  0x%08x  0x%08x ",
				    s->dmt2, s->dmd2, s->dma2);
				db_find_xtrn_sym_and_offset((db_addr_t)s->dma2,
				    &name, &offset);
d329 1
a329 1
				m88k_dmx_print(s->dmt2, s->dmd2, s->dma2, 2);
d331 12
d349 7
a355 5
		    s->fpecr, s->fpsr, s->fpcr);
		db_printf("fcr1-4: 0x%08x  0x%08x  0x%08x  0x%08x\n",
		    s->fphs1, s->fpls1, s->fphs2, s->fpls2);
		db_printf("fcr5-8: 0x%08x  0x%08x  0x%08x  0x%08x\n",
		    s->fppt, s->fprh, s->fprl, s->fpit);
d357 11
a367 1
	db_printf("\n\n");
d489 2
a490 1
		 * at the breakpoint address
d492 1
d495 1
d699 4
a702 4
	    (unsigned)cmmu_remote_get(0, CMMU_CTP0, 1),
	    (unsigned)cmmu_remote_get(0, CMMU_CTP1, 1),
	    (unsigned)cmmu_remote_get(0, CMMU_CTP2, 1),
	    (unsigned)cmmu_remote_get(0, CMMU_CTP3, 1));
d710 4
a713 4
	    (unsigned)cmmu_remote_get(0, CMMU_CTP0, 0),
	    (unsigned)cmmu_remote_get(0, CMMU_CTP1, 0),
	    (unsigned)cmmu_remote_get(0, CMMU_CTP2, 0),
	    (unsigned)cmmu_remote_get(0, CMMU_CTP3, 0));
d731 3
a733 3
			    db_noisy == 1 ? "noisy" :
			    db_noisy == 2 ? "very noisy" : "violent");
			    db_noisy = 0;
d743 3
a745 3
		    db_noisy == 0 ? "quiet" :
		    (db_noisy == 1 ? "noisy" :
		        db_noisy==2 ? "very noisy" : "violent"));
d836 4
a839 4
    { "iflush",    m88k_db_iflush, 0, 0},
    { "dflush",    m88k_db_dflush, 0, 0},
    { "peek",      m88k_db_peek, 0, 0},
    { (char *) 0,}
d844 10
a853 9
    {"cache",		0,			0, m88k_cache_cmds},
    {"frame",		m88k_db_print_frame,	0, 0},
    {"noise",		m88k_db_noise,		0, 0},
    {"searchframe",	m88k_db_frame_search,	0, 0},
    {"translate",	m88k_db_translate,      0, 0},
    {"cmmucfg",		m88k_db_cmmucfg,        0, 0},
    {"where",		m88k_db_where,		0, 0},
    {"prom",		m88k_db_prom_cmd,	0, 0},
    {(char  *) 0,}
d885 1
a885 1
	    (i = db_trace_get_val((vm_offset_t)ptr, &word)) && (word == 0)) {
d898 1
a898 1
	    (i = db_trace_get_val(ptr, &word)) && (word != 0)) {
d901 1
a901 1
    
d918 1
@


1.21
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.18 2001/11/27 05:37:00 miod Exp $	*/
d40 1
a40 1
#include <machine/m882xx.h>		 /* CMMU defs		        */
@


1.21.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.24 2001/12/22 09:49:39 smurph Exp $	*/
d40 4
a43 5
#include <machine/asm_macro.h>		/* flush_pipeline()	*/
#include <machine/cmmu.h>		/* CMMU defs		*/
#include <machine/trap.h>		/* current_thread()	*/
#include <machine/db_machdep.h>		/* local ddb stuff	*/
#include <machine/bugio.h>		/* bug routines		*/
d45 1
a72 1
void m88k_db_registers __P((db_expr_t, int, db_expr_t, char *));
d128 2
a129 2
		0, 3, 2, 2, 1, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0
d132 2
a133 2
		"?", ".b", ".b", ".h", ".b", "?", "?", "?",
		".b", ".h", "?" , "?" , "?" , "?", "?", ""
d136 4
a139 4
		0,           0xff,        0xff00,     0xffff,
		0xff0000,    0,           0,          0,
		0xff000000U, 0xffff0000U, 0,          0,
		0,           0,           0,          0xffffffffU
d142 2
a143 2
		0,  0, 8, 0, 16, 0, 0, 0,
		24, 16, 0, 0,  0, 0, 0, 0
d149 2
a150 2
			  XMEM_MODE(t), DAS(t), reg,
			  (((t)>>2 & 0xf) == 0xf) ? d : (d & 0xff), a);
d158 1
a158 1
						  DAS(t), a);
d161 1
a161 1
						  DAS(t), d, a);
d166 1
a166 1
						  DAS(t), reg, a, reg+1, a+4);
d169 1
a169 1
						  DAS(t), reg, a);
d176 2
a177 2
					  mode[MODE(t)], DAS(t),
					  (d & mask[MODE(t)]) >> shift[MODE(t)], a);
d180 2
a181 2
					  mode[MODE(t)], SIGN(t) ? "" : "u",
					  DAS(t), reg, a);
d246 1
a246 1
		  R(0), R(1), R(2), R(3), R(4), R(5));
d248 1
a248 1
		  R(6), R(7), R(8), R(9), R(10), R(11));
d250 1
a250 1
		  R(12), R(13), R(14), R(15), R(16), R(17));
d252 1
a252 1
		  R(18), R(19), R(20), R(21), R(22), R(23));
d254 1
a254 1
		  R(24), R(25), R(26), R(27), R(28), R(29));
d257 1
a257 1
	db_printf("%sxip: 0x%08x ", cputyp == CPU_88110 ? "e" : "s", s->sxip & ~3);
d259 1
a259 1
				    &name, &offset);
d265 1
a265 1
		db_printf("%snip: 0x%08x ", cputyp == CPU_88110 ? "e" : "s", s->snip);
d267 1
a267 1
					    &name, &offset);
d273 7
a279 16
	if (cputyp != CPU_88110) {
		if (s->sfip != s->snip + 4) {
			db_printf("sfip: 0x%08x ", s->sfip);
			db_find_xtrn_sym_and_offset((db_addr_t)IPMASK(s->sfip),
						    &name, &offset);
			if (name != 0 && (unsigned)offset <= db_maxoff)
				db_printf("%s+0x%08x", name, (unsigned)offset);
			db_printf("\n");
		}
	} else {
		db_printf("fpsr: 0x%08x fpcr: 0x%08x fpecr: 0x%08x\n",
			  s->fpsr, s->fpcr, s->fpecr);
		db_printf("dsap 0x%08x duap 0x%08x dsr 0x%08x dlar 0x%08x dpar 0x%08x\n",
			  s->dsap, s->duap, s->dsr, s->dlar, s->dpar);
		db_printf("isap 0x%08x iuap 0x%08x isr 0x%08x ilar 0x%08x ipar 0x%08x\n",
			  s->isap, s->iuap, s->isr, s->ilar, s->ipar);
d282 2
d285 1
a285 3
		  s->epsr, curproc);
	db_printf("vector: 0x%02x                    interrupt mask: 0x%08x\n",
		  s->vector, s->mask);
d295 1
a295 1
		db_printf("\n");
d299 15
a313 5
	if (cputyp != CPU_88110) {
		if (s->vector == /*data*/3 || s->dmt0 & 1) {
			db_printf("dmt,d,a0: 0x%08x  0x%08x  0x%08x ",
				  s->dmt0, s->dmd0, s->dma0);
			db_find_xtrn_sym_and_offset((db_addr_t)s->dma0, &name, &offset);
d317 1
a317 1
			surpress1 = m88k_dmx_print(s->dmt0|0x01, s->dmd0, s->dma0, 0);
d320 5
a324 5
			if ((s->dmt1 & 1) && (!surpress1)) {
				db_printf("dmt,d,a1: 0x%08x  0x%08x  0x%08x ",
					  s->dmt1, s->dmd1, s->dma1);
				db_find_xtrn_sym_and_offset((db_addr_t)s->dma1,
							    &name, &offset);
d328 1
a328 1
				surpress2 = m88k_dmx_print(s->dmt1, s->dmd1, s->dma1, 1);
a329 12

				if ((s->dmt2 & 1) && (!surpress2)) {
					db_printf("dmt,d,a2: 0x%08x  0x%08x  0x%08x ",
						  s->dmt2, s->dmd2, s->dma2);
					db_find_xtrn_sym_and_offset((db_addr_t)s->dma2,
								    &name, &offset);
					if (name != 0 && (unsigned)offset <= db_maxoff)
						db_printf("%s+0x%08x", name, (unsigned)offset);
					db_printf("\n          ");
					m88k_dmx_print(s->dmt2, s->dmd2, s->dma2, 2);
					db_printf("\n");
				}
d336 5
a340 7
			  s->fpecr, s->fpsr, s->fpcr);
		if (cputyp != CPU_88110) {
			db_printf("fcr1-4: 0x%08x  0x%08x  0x%08x  0x%08x\n",
				  s->fphs1, s->fpls1, s->fphs2, s->fpls2);
			db_printf("fcr5-8: 0x%08x  0x%08x  0x%08x  0x%08x\n",
				  s->fppt, s->fprh, s->fprl, s->fpit);
		}
d342 1
a342 11
	db_printf("\n");
}

void
m88k_db_registers(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	int count;
	char *modif;
{
	m88k_db_print_frame((db_expr_t)DDB_REGS, TRUE, 0, modif);
d464 1
a464 2
		 * at the breakpoint address.  mc88110's exip reg 
		 * already has the adress of the exception instruction.
a465 1
		if (cputyp != CPU_88110) {
a467 1
		}
a635 1
#ifdef may_be_removed
a636 1
#endif 
a648 1
#ifdef may_be_removed
a649 1
#endif 
a659 1
#ifdef may_be_removed
d671 4
a674 4
		  (unsigned)cmmu_remote_get(0, CMMU_CTP0, 1),
		  (unsigned)cmmu_remote_get(0, CMMU_CTP1, 1),
		  (unsigned)cmmu_remote_get(0, CMMU_CTP2, 1),
		  (unsigned)cmmu_remote_get(0, CMMU_CTP3, 1));
d682 4
a685 5
		  (unsigned)cmmu_remote_get(0, CMMU_CTP0, 0),
		  (unsigned)cmmu_remote_get(0, CMMU_CTP1, 0),
		  (unsigned)cmmu_remote_get(0, CMMU_CTP2, 0),
		  (unsigned)cmmu_remote_get(0, CMMU_CTP3, 0));
#endif 
d703 3
a705 3
				  db_noisy == 1 ? "noisy" :
				  db_noisy == 2 ? "very noisy" : "violent");
			db_noisy = 0;
d715 3
a717 3
			  db_noisy == 0 ? "quiet" :
			  (db_noisy == 1 ? "noisy" :
			   db_noisy==2 ? "very noisy" : "violent"));
d808 4
a811 4
	{ "iflush",    m88k_db_iflush, 0, 0},
	{ "dflush",    m88k_db_dflush, 0, 0},
	{ "peek",      m88k_db_peek, 0, 0},
	{ (char *) 0,}
d816 9
a824 10
	{"cache",           0,                      0, m88k_cache_cmds},
	{"frame",           m88k_db_print_frame,    0, 0},
	{"regs",            m88k_db_registers,      0, 0},
	{"noise",           m88k_db_noise,          0, 0},
	{"searchframe",     m88k_db_frame_search,   0, 0},
	{"translate",       m88k_db_translate,      0, 0},
	{"cmmucfg",         m88k_db_cmmucfg,        0, 0},
	{"where",           m88k_db_where,          0, 0},
	{"prom",            m88k_db_prom_cmd,       0, 0},
	{(char  *) 0,}
d856 1
a856 1
	       (i = db_trace_get_val((vm_offset_t)ptr, &word)) && (word == 0)) {
d869 1
a869 1
	       (i = db_trace_get_val(ptr, &word)) && (word != 0)) {
d872 1
a872 1

a888 1

@


1.21.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.21.2.1 2002/01/31 22:55:17 niklas Exp $	*/
d57 26
a82 26
extern int frame_is_sane(db_regs_t *);
extern void cnpollc(int);
void kdbprinttrap(int type, int code);

void m88k_db_trap(int type, struct m88100_saved_state *regs);
int ddb_nmi_trap(int level, db_regs_t *eframe);
void ddb_error_trap(char *error, db_regs_t *eframe);
void db_read_bytes(vm_offset_t addr, int size, char *data);
void db_write_bytes(char *addr, int size, char *data);
void db_putc(int c);
int db_getc(void);
void cpu_interrupt_to_db(int cpu_no);
char *db_task_name(void);
int m88k_dmx_print(unsigned, unsigned, unsigned, unsigned);
void m88k_db_pause(unsigned);
void m88k_db_print_frame(db_expr_t, int, db_expr_t, char *);
void m88k_db_registers(db_expr_t, int, db_expr_t, char *);
void m88k_db_where(db_expr_t, int, db_expr_t, char *);
void m88k_db_frame_search(db_expr_t, int, db_expr_t, char *);
void m88k_db_iflush(db_expr_t, int, db_expr_t, char *);
void m88k_db_dflush(db_expr_t, int, db_expr_t, char *);
void m88k_db_peek(db_expr_t, int, db_expr_t, char *);
void m88k_db_noise(db_expr_t, int, db_expr_t, char *);
void m88k_db_translate(db_expr_t, int, db_expr_t, char *);
void m88k_db_cmmucfg(db_expr_t, int, db_expr_t, char *);
void m88k_db_prom_cmd(db_expr_t, int, db_expr_t, char *);
d921 1
a921 1
	return (char *)buffer;
@


1.20
log
@Repair MVME187 after MVME197 merge.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.19 2001/12/13 08:55:51 smurph Exp $	*/
d40 4
a43 4
#include <machine/asm_macro.h>		/* flush_pipeline()	*/
#include <machine/trap.h>		/* current_thread()	*/
#include <machine/db_machdep.h>		/* local ddb stuff	*/
#include <machine/bugio.h>		/* bug routines		*/
d45 1
a45 2
#include <machine/cmmu.h>		/* CMMU defs		*/
#include <machine/m8820x.h>		/* temporary unitl I can do M88100 defs	*/
a72 1
void m88k_db_registers __P((db_expr_t, int, db_expr_t, char *));
d257 1
a257 1
	db_printf("%sxip: 0x%08x ", cputyp == CPU_88110 ? "e" : "s", s->sxip & ~3);
d265 1
a265 1
		db_printf("%snip: 0x%08x ", cputyp == CPU_88110 ? "e" : "s", s->snip);
d272 8
a279 17
	
	if (cputyp != CPU_88110) {
		if (s->sfip != s->snip + 4) {
			db_printf("sfip: 0x%08x ", s->sfip);
			db_find_xtrn_sym_and_offset((db_addr_t)IPMASK(s->sfip),
			    &name, &offset);
			if (name != 0 && (unsigned)offset <= db_maxoff)
				db_printf("%s+0x%08x", name, (unsigned)offset);
			db_printf("\n");
		}
	} else {
		db_printf("fpsr: 0x%08x fpcr: 0x%08x fpecr: 0x%08x\n",
			  s->fpsr, s->fpcr, s->fpecr);
		db_printf("dsap 0x%08x duap 0x%08x dsr 0x%08x dlar 0x%08x dpar 0x%08x\n",
			  s->dsap, s->duap, s->dsr, s->dlar, s->dpar);
		db_printf("isap 0x%08x iuap 0x%08x isr 0x%08x ilar 0x%08x ipar 0x%08x\n",
			  s->isap, s->iuap, s->isr, s->ilar, s->ipar);
d282 2
a285 2
	db_printf("vector: 0x%02x                     interrupt mask: 0x%08x\n",
	    s->vector, s->mask);
d295 1
a295 1
		db_printf("\n");
d299 15
a313 5
	if (cputyp != CPU_88110) {
		if (s->vector == /*data*/3 || s->dmt0 & 1) {
			db_printf("dmt,d,a0: 0x%08x  0x%08x  0x%08x ",
			    s->dmt0, s->dmd0, s->dma0);
			db_find_xtrn_sym_and_offset((db_addr_t)s->dma0, &name, &offset);
d317 1
a317 1
			surpress1 = m88k_dmx_print(s->dmt0|0x01, s->dmd0, s->dma0, 0);
d319 5
a323 5
	
			if ((s->dmt1 & 1) && (!surpress1)) {
				db_printf("dmt,d,a1: 0x%08x  0x%08x  0x%08x ",
				    s->dmt1, s->dmd1, s->dma1);
				db_find_xtrn_sym_and_offset((db_addr_t)s->dma1,
d328 1
a328 1
				surpress2 = m88k_dmx_print(s->dmt1, s->dmd1, s->dma1, 1);
a329 12
	
				if ((s->dmt2 & 1) && (!surpress2)) {
					db_printf("dmt,d,a2: 0x%08x  0x%08x  0x%08x ",
					    s->dmt2, s->dmd2, s->dma2);
					db_find_xtrn_sym_and_offset((db_addr_t)s->dma2,
					    &name, &offset);
					if (name != 0 && (unsigned)offset <= db_maxoff)
						db_printf("%s+0x%08x", name, (unsigned)offset);
					db_printf("\n          ");
					m88k_dmx_print(s->dmt2, s->dmd2, s->dma2, 2);
					db_printf("\n");
				}
d333 1
a333 1
	
d337 4
a340 6
		if (cputyp != CPU_88110) {
			db_printf("fcr1-4: 0x%08x  0x%08x  0x%08x  0x%08x\n",
			    s->fphs1, s->fpls1, s->fphs2, s->fpls2);
			db_printf("fcr5-8: 0x%08x  0x%08x  0x%08x  0x%08x\n",
			    s->fppt, s->fprh, s->fprl, s->fpit);
		}
d342 1
a342 11
	db_printf("\n");
}

void
m88k_db_registers(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	int count;
	char *modif;
{
	m88k_db_print_frame((db_expr_t)DDB_REGS, TRUE, 0, modif);
d464 1
a464 2
		 * at the breakpoint address.  mc88110's exip reg 
		 * already has the adress of the exception instruction.
d466 2
a467 4
		if (cputyp != CPU_88110) {
			eframe->sfip = eframe->snip;
			eframe->snip = eframe->sxip;
		}
d581 1
a581 4
	if (cputyp == CPU_88110)
		l = s->exip & ~3;
	else 
		l = m88k_pc(s); /* clear low bits */
d636 1
a636 1
        cmmu_flush_inst_cache(addr, -1);
d649 1
a649 2
	
	cmmu_flush_cache(addr, -1);
a659 1
#if 0
a685 1
#endif 
a817 1
    {"regs",		m88k_db_registers,	0, 0},
@


1.19
log
@Support for MVME197 completed.  Fix SPL defs.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.18 2001/11/27 05:37:00 miod Exp $	*/
d667 1
a667 1
	cmmu_remote_set(addr, CMMU_SCR, 0, CMMU_FLUSH_CACHE_CBI_ALL);
d680 2
a681 1
	cmmu_remote_set(addr, CMMU_SCR, 1, CMMU_FLUSH_CACHE_CBI_ALL);
d692 1
d719 1
@


1.18
log
@Adapt to include files changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.17 2001/11/09 00:12:15 miod Exp $	*/
d40 4
a43 4
#include <machine/m882xx.h>		 /* CMMU defs		        */
#include <machine/trap.h>		 /* current_thread()            */
#include <machine/db_machdep.h>		 /* local ddb stuff             */
#include <machine/bugio.h>		 /* bug routines 		*/
d45 2
a46 1
#include <machine/mmu.h>
d74 1
d259 1
a259 1
	db_printf("sxip: 0x%08x ", s->sxip & ~3);
d267 1
a267 1
		db_printf("snip: 0x%08x ", s->snip);
d274 17
a290 8

	if (s->sfip != s->snip + 4) {
		db_printf("sfip: 0x%08x ", s->sfip);
		db_find_xtrn_sym_and_offset((db_addr_t)IPMASK(s->sfip),
		    &name, &offset);
		if (name != 0 && (unsigned)offset <= db_maxoff)
			db_printf("%s+0x%08x", name, (unsigned)offset);
		db_printf("\n");
a292 2
	db_printf("vector: 0x%02x                    interrupt mask: 0x%08x\n",
	    s->vector, s->mask);
d295 2
d306 1
a306 1
		db_printf("\n\n");
d310 5
a314 15
	if (s->vector == /*data*/3 || s->dmt0 & 1) {
		db_printf("dmt,d,a0: 0x%08x  0x%08x  0x%08x ",
		    s->dmt0, s->dmd0, s->dma0);
		db_find_xtrn_sym_and_offset((db_addr_t)s->dma0, &name, &offset);
		if (name != 0 && (unsigned)offset <= db_maxoff)
			db_printf("%s+0x%08x", name, (unsigned)offset);
		db_printf("\n          ");
		surpress1 = m88k_dmx_print(s->dmt0|0x01, s->dmd0, s->dma0, 0);
		db_printf("\n");

		if ((s->dmt1 & 1) && (!surpress1)) {
			db_printf("dmt,d,a1: 0x%08x  0x%08x  0x%08x ",
			    s->dmt1, s->dmd1, s->dma1);
			db_find_xtrn_sym_and_offset((db_addr_t)s->dma1,
			    &name, &offset);
d318 1
a318 1
			surpress2 = m88k_dmx_print(s->dmt1, s->dmd1, s->dma1, 1);
d320 5
a324 5

			if ((s->dmt2 & 1) && (!surpress2)) {
				db_printf("dmt,d,a2: 0x%08x  0x%08x  0x%08x ",
				    s->dmt2, s->dmd2, s->dma2);
				db_find_xtrn_sym_and_offset((db_addr_t)s->dma2,
d329 1
a329 1
				m88k_dmx_print(s->dmt2, s->dmd2, s->dma2, 2);
d331 12
d346 1
a346 1

d350 6
a355 4
		db_printf("fcr1-4: 0x%08x  0x%08x  0x%08x  0x%08x\n",
		    s->fphs1, s->fpls1, s->fphs2, s->fpls2);
		db_printf("fcr5-8: 0x%08x  0x%08x  0x%08x  0x%08x\n",
		    s->fppt, s->fprh, s->fprl, s->fpit);
d357 11
a367 1
	db_printf("\n\n");
d489 2
a490 1
		 * at the breakpoint address
d492 4
a495 2
		eframe->sfip = eframe->snip;
		eframe->snip = eframe->sxip;
d609 4
a612 1
	l = m88k_pc(s); /* clear low bits */
d849 1
@


1.17
log
@Ouch, more variables declarations in .h files lacking ``extern'' safety
belts.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.16 2001/11/06 19:53:15 miod Exp $	*/
d43 1
a43 1
#include <machine/bug.h>		 /* bug routines 		*/
@


1.16
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.15 2001/09/23 02:52:02 miod Exp $	*/
d90 2
@


1.15
log
@rename kdb_init() to db_machine_init().
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.14 2001/09/20 17:02:31 mpech Exp $	*/
d38 1
a38 1
#include <vm/vm.h>
@


1.14
log
@occured->occurred

idea from deraadt@@ via NetBSD
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.13 2001/08/31 01:06:26 miod Exp $	*/
d50 1
a59 1
void kdb_init __P((void));
d542 1
a542 1
	pmap_extract(kernel_pmap, (vm_offset_t)addr, &physaddr);
d829 1
a829 1
kdb_init()
a831 3
	ddb_init();

	db_printf("ddb enabled\n");
@


1.13
log
@There's no point having a Debugger() clone here.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.12 2001/08/26 02:37:00 miod Exp $	*/
d332 1
a332 1
	if (s->fpecr & 255) { /* floating point error occured */
@


1.12
log
@Add prototypes, fix compilation warnings, random style fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.11 2001/08/24 22:45:42 miod Exp $	*/
a426 8
{
	asm (ENTRY_ASM); /* entry trap */
	/* ends up at ddb_entry_trap below */
}

/* gimmeabreak - drop execute the ENTRY trap */
void
gimmeabreak()
@


1.11
log
@Get rid of the ugly db_printf() wrappers, as well as of the
``machine registers'' command, which prints nothing more than
``show registers''.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.10 2001/07/01 22:43:43 miod Exp $	*/
d70 12
d189 1
a189 1
	int count;
d799 5
a803 1
m88k_db_prom_cmd(void)
@


1.10
log
@Enable the ``machine foo'' commands under ddb.
Add a ``machine prom'' command, which returns to the BUG, like mvme68k has.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.9 2001/06/08 08:09:11 art Exp $	*/
a75 27
/* PRINTING *************/
/************************/

static void
m88k_db_str(str)
	char *str;
{
	db_printf(str);
}

static void
m88k_db_str1(str, arg1)
	char *str;
	int arg1;
{
	db_printf(str, arg1);
}

static void
m88k_db_str2(str, arg1, arg2)
	char *str;
	int arg1, arg2;
{
	db_printf(str, arg1, arg2);
}

/************************/
d109 1
a109 1
static int
d173 1
a173 1
static void
a330 15
static void
m88k_db_registers(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	int count;
	char *modif;
{
	if (modif != NULL && *modif != 0) {
		db_printf("usage: mach regs\n");
		return;
	}

	m88k_db_print_frame((db_expr_t)DDB_REGS, TRUE, 0, 0);
}

d338 1
a338 1
static void
d358 1
a358 1
		m88k_db_str1("WARNING: spl is not high in m88k_db_trap (spl=%x)\n", i);
d362 1
a362 1
		m88k_db_str("WARNING: entered debugger with interrupts disabled\n");
d434 1
a434 1
	NOISY(m88k_db_str("kernel: nmi interrupt\n");)
d488 4
a491 4
	m88k_db_str1("KERNEL:  terminal error [%s]\n",(int)error);
	m88k_db_str ("KERNEL:  Exiting debugger will cause abort to rom\n");
	m88k_db_str1("at 0x%x ", eframe->sxip & ~3);
	m88k_db_str2("dmt0 0x%x dma0 0x%x", eframe->dmt0, eframe->dma0);
d561 1
a561 1
static void
d593 1
a593 1
static void
d622 1
a622 1
static void
d635 1
a635 1
static void
d647 1
a647 1
static void
d686 1
a686 1
static void
d719 1
a719 1
static void
d766 1
a766 1
static void
d796 1
a796 1
static struct db_command m88k_cache_cmds[] =
a808 1
    {"regs",		m88k_db_registers,	0, 0},
@


1.9
log
@Change the paddr_t pmap_extract(struct pmap *, vaddr_t) interface to
boolean_t pmap_extract(struct pmap *, vaddr_t, paddr_t *).
Matches NetBSD. Tested by various people on various platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.8 2001/03/16 00:01:51 miod Exp $	*/
d828 5
d856 1
a865 1
#ifdef DB_MACHINE_COMMANDS
a866 1
#endif
@


1.8
log
@KNF, warning hunting.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.7 2001/03/09 05:44:37 smurph Exp $	*/
d580 1
a580 1
	physaddr = pmap_extract(kernel_pmap, (vm_offset_t)addr);
@


1.7
log
@kernel will compile with -Werror.  Added intr.h
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.6 2001/03/08 00:02:18 miod Exp $	*/
a54 1
extern int db_are_interrupts_disabled();
d56 1
a56 2
extern int frame_is_sane();
extern int badwordaddr();
d61 9
d80 2
a81 1
m88k_db_str(char *str)
d83 1
a83 1
    db_printf(str);
d87 3
a89 1
m88k_db_str1(char *str, int arg1)
d91 1
a91 1
    db_printf(str, arg1);
d95 3
a97 1
m88k_db_str2(char *str, int arg1, int arg2)
d99 1
a99 1
    db_printf(str, arg1, arg2);
d137 2
a138 1
m88k_dmx_print(unsigned t, unsigned d, unsigned a, unsigned no)
d140 25
a164 33
    static unsigned addr_mod[16] = { 0, 3, 2, 2, 1, 0, 0, 0,
				     0, 0, 0, 0, 0, 0, 0, 0};
    static char *mode[16]  = { "?", ".b", ".b", ".h", ".b", "?", "?", "?",
			      ".b", ".h", "?" , "?" , "?" , "?", "?", ""};
    static unsigned mask[16] = { 0,           0xff,        0xff00,     0xffff,
				 0xff0000,    0,           0,          0,
				 0xff000000U, 0xffff0000U, 0,          0,
				 0,           0,           0,    0xffffffffU};
    static unsigned shift[16] = { 0,  0, 8, 0, 16, 0, 0, 0,
				 24, 16, 0, 0,  0, 0, 0, 0};
    int reg = REG(t);

    if (XMEM(t)) {
	db_printf("xmem%s%s r%d(0x%x) <-> mem(0x%x),",
	    XMEM_MODE(t), DAS(t), reg,
	    (((t)>>2 & 0xf) == 0xf) ? d : (d & 0xff), a );
	return 1;
    } else {
	if (MODE(t) == 0xf) {
	    /* full or double word */
	    if (STORE(t)) {
		if (DOUB(t) && no == 2)
		    db_printf("st.d%s -> mem(0x%x) (** restart sxip **)",
			DAS(t), a);
		else
		    db_printf("st%s (0x%x) -> mem(0x%x)", DAS(t), d, a);
	    } else { /* load */
		if (DOUB(t) && no == 2)
		    db_printf("ld.d%s r%d <- mem(0x%x), r%d <- mem(0x%x)",
			DAS(t), reg, a, reg+1, a+4);
		else
		    db_printf("ld%s r%d <- mem(0x%x)",  DAS(t), reg, a);
	    }
d166 32
a197 11
	    /* fractional word - check if load or store */
	    a += addr_mod[MODE(t)];
	    if (STORE(t))
		db_printf("st%s%s (0x%x) -> mem(0x%x)", mode[MODE(t)], DAS(t),
		(d & mask[MODE(t)]) >> shift[MODE(t)], a);
	    else
		db_printf("ld%s%s%s r%d <- mem(0x%x)",
		mode[MODE(t)], SIGN(t) ? "" : "u", DAS(t), reg, a);
	}
    }
    return 0;
d201 43
a243 29
m88k_db_print_frame(db_expr_t addr, int have_addr, int count, char *modif)
{
    struct m88100_saved_state *s = (struct m88100_saved_state *)addr;
    char *name;
    db_expr_t offset;
    int surpress1 = 0, surpress2 = 0;
    int c, force = 0, help = 0;

    if (!have_addr) {
	db_printf("requires address of frame\n");
	help = 1;
    }

    while (modif && *modif) {
   	switch (c = *modif++, c) {
	case 'f': force = 1; break;
	case 'h': help = 1; break;
        default:
	    db_printf("unknown modifier [%c]\n", c);
	    help = 1;
	    break;
    	}
    }

    if (help) {
	db_printf("usage: mach frame/[f] ADDRESS\n");
	db_printf("  /f force printing of insane frames.\n");
	return;
    }
d245 2
a246 9
    if (badwordaddr((vm_offset_t)s) ||
	badwordaddr((vm_offset_t)(&((db_regs_t*)s)->mode))) {
	    db_printf("frame at 0x%08x is unreadable\n", s);
	    return;
    }

    if (!frame_is_sane(s))  /* see db_trace.c */
    {
	db_printf("frame seems insane (");
d248 6
a253 5
	if (force)
	    db_printf("forging ahead anyway...)\n");
	else {
	    db_printf("use /f to force)\n");
	    return;
a254 1
    }
d258 17
a274 31
    db_printf("R00-05: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	R(0),R(1),R(2),R(3),R(4),R(5));
    db_printf("R06-11: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	R(6),R(7),R(8),R(9),R(10),R(11));
    db_printf("R12-17: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	R(12),R(13),R(14),R(15),R(16),R(17));
    db_printf("R18-23: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	R(18),R(19),R(20),R(21),R(22),R(23));
    db_printf("R24-29: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	R(24),R(25),R(26),R(27),R(28),R(29));
    db_printf("R30-31: 0x%08x  0x%08x\n",R(30),R(31));

    db_printf("sxip: 0x%08x ",s->sxip & ~3);
    db_find_xtrn_sym_and_offset((db_addr_t) IPMASK(s->sxip),&name,&offset);
    if (name!= 0 && (unsigned)offset <= db_maxoff)
	db_printf("%s+0x%08x",name,(unsigned)offset);
    db_printf("\n");
    if (s->snip != s->sxip+4)
    {
	db_printf("snip: 0x%08x ",s->snip);
	db_find_xtrn_sym_and_offset((db_addr_t) IPMASK(s->snip),&name,&offset);
	if (name!= 0 && (unsigned)offset <= db_maxoff)
	    db_printf("%s+0x%08x",name,(unsigned)offset);
	db_printf("\n");
    }
    if (s->sfip != s->snip+4)
    {
	db_printf("sfip: 0x%08x ",s->sfip);
	db_find_xtrn_sym_and_offset((db_addr_t) IPMASK(s->sfip),&name,&offset);
	if (name!= 0 && (unsigned)offset <= db_maxoff)
	    db_printf("%s+0x%08x",name,(unsigned)offset);
a275 1
    }
d277 8
a284 11
    db_printf("vector: 0x%02x                    interrupt mask: 0x%08x\n",
	s->vector, s->mask);
    db_printf("epsr: 0x%08x                current process: 0x%x\n",
	s->epsr, curproc);

    /*
     * If the vector indicates trap, instead of an exception or
     * interrupt, skip the check of dmt and fp regs.
     *
     * Interrupt and exceptions are vectored at 0-10 and 114-127.
     */
d286 8
a293 5
    if (!(s->vector <= 10 || (114 <= s->vector && s->vector <= 127)))
    {
	db_printf("\n\n");
	return;
    }
d295 16
a310 9
    if (s->vector == /*data*/3 || s->dmt0 & 1)
    {
	db_printf("dmt,d,a0: 0x%08x  0x%08x  0x%08x ",s->dmt0,s->dmd0,s->dma0);
	db_find_xtrn_sym_and_offset((db_addr_t) s->dma0,&name,&offset);
	if (name!= 0 && (unsigned)offset <= db_maxoff)
	    db_printf("%s+0x%08x",name,(unsigned)offset);
	db_printf("\n          ");
	surpress1 = m88k_dmx_print(s->dmt0|0x01, s->dmd0, s->dma0, 0);
	db_printf("\n");
d312 6
a317 16
	if ((s->dmt1 & 1) && (!surpress1))
	{
	    db_printf("dmt,d,a1: 0x%08x  0x%08x  0x%08x ",s->dmt1, s->dmd1,s->dma1);
	    db_find_xtrn_sym_and_offset((db_addr_t) s->dma1,&name,&offset);
	    if (name!= 0 && (unsigned)offset <= db_maxoff)
		db_printf("%s+0x%08x",name,(unsigned)offset);
	    db_printf("\n          ");
	    surpress2 = m88k_dmx_print(s->dmt1, s->dmd1, s->dma1, 1);
	    db_printf("\n");

	    if ((s->dmt2 & 1) && (!surpress2))
	    {
		db_printf("dmt,d,a2: 0x%08x  0x%08x  0x%08x ",s->dmt2, s->dmd2,s->dma2);
		db_find_xtrn_sym_and_offset((db_addr_t) s->dma2,&name,&offset);
		if (name!= 0 && (unsigned)offset <= db_maxoff)
		    db_printf("%s+0x%08x",name,(unsigned)offset);
d319 1
a319 1
		(void) m88k_dmx_print(s->dmt2, s->dmd2, s->dma2, 2);
d321 24
a344 1
	    }
a345 1
    }
d347 9
a355 10
    if (s->fpecr & 255) /* floating point error occured */
    {
	db_printf("fpecr: 0x%08x fpsr: 0x%08x fpcr: 0x%08x\n",
	    s->fpecr,s->fpsr,s->fpcr);
	db_printf("fcr1-4: 0x%08x  0x%08x  0x%08x  0x%08x\n",
	    s->fphs1, s->fpls1, s->fphs2, s->fpls2);
	db_printf("fcr5-8: 0x%08x  0x%08x  0x%08x  0x%08x\n",
	    s->fppt,  s->fprh,  s->fprl,  s->fpit);
    }
    db_printf("\n\n");
d359 10
a368 6
m88k_db_registers(db_expr_t addr, int have_addr, int count, char *modif)
{
    if (modif && *modif) {
	db_printf("usage: mach regs\n");
	return;
    }
d370 1
a370 2
    m88k_db_print_frame((db_expr_t)DDB_REGS, TRUE,0,0);
    return;
d381 2
a382 1
m88k_db_pause(unsigned volatile ticks)
d384 2
a385 3
    while (ticks)
	ticks -= 1;
    return;
d392 3
a394 3
m88k_db_trap(
    int type,
    register struct m88100_saved_state *regs)
a395 1

d397 1
a397 1
    int i;
d399 2
a400 2
    if ((i = db_spl()) != 7)
	m88k_db_str1("WARNING: spl is not high in m88k_db_trap (spl=%x)\n", i);
d403 2
a404 2
    if (db_are_interrupts_disabled())
	m88k_db_str("WARNING: entered debugger with interrupts disabled\n");
d406 1
a406 1
    switch(type) {
d408 13
a420 13
    case T_KDB_BREAK:
    case T_KDB_TRACE:
    case T_KDB_ENTRY:
    	break;
    case -1:
    	break;
    default:
    	kdbprinttrap(type, 0);
    	if (db_recover != 0) {
    		db_error("Caught exception in ddb.\n");
    		/*NOTREACHED*/
    	}
    }
d422 1
a422 1
    ddb_regs = *regs;
d424 5
a428 5
    db_active++;
    cnpollc(TRUE);
    db_trap(type, 0);
    cnpollc(FALSE);
    db_active--;
d430 1
a430 1
    *regs = ddb_regs;
d433 1
a433 1
    (void) spl7();
a434 1
    return;
d456 1
a456 1
Debugger(void)
d458 2
a459 2
    asm (ENTRY_ASM); /* entry trap */
    /* ends up at ddb_entry_trap below */
d464 1
a464 1
gimmeabreak(void)
d466 2
a467 2
    asm (ENTRY_ASM); /* entry trap */
    /* ends up at ddb_entry_trap below */
d472 3
a474 1
ddb_nmi_trap(int level, db_regs_t *eframe)
d476 2
a477 2
    NOISY(m88k_db_str("kernel: nmi interrupt\n");)
    m88k_db_trap(T_KDB_ENTRY, eframe);
d479 1
a479 1
    return 0;
d491 14
a504 10
ddb_break_trap(int type, db_regs_t *eframe)
{
    m88k_db_trap(type, eframe);

    if (type == T_KDB_BREAK) {
	/* back up an instruction and retry the instruction at the
	   breakpoint address */
	eframe->sfip = eframe->snip;
	eframe->snip = eframe->sxip;
    }
d506 1
a506 1
    return 0;
d511 3
a513 1
ddb_entry_trap(int level, db_regs_t *eframe)
d515 1
a515 1
    m88k_db_trap(T_KDB_ENTRY, eframe);
d517 1
a517 1
    return 0;
d526 10
a535 9
ddb_error_trap(char *error, db_regs_t *eframe)
{

    m88k_db_str1("KERNEL:  terminal error [%s]\n",(int)error);
    m88k_db_str ("KERNEL:  Exiting debugger will cause abort to rom\n");
    m88k_db_str1("at 0x%x ", eframe->sxip & ~3);
    m88k_db_str2("dmt0 0x%x dma0 0x%x", eframe->dmt0, eframe->dma0);
    m88k_db_pause(1000000);
    m88k_db_trap(T_KDB_BREAK, eframe);
d547 1
a547 1
    register char	*src;
d549 1
a549 1
    src = (char *)addr;
d551 3
a553 3
    while(--size >= 0) {
	*data++ = *src++;
    }
d563 8
a570 2
db_write_bytes(char *addr, int size, char *data)
{
d572 1
a572 5
    register char	*dst;
    int i = size;
    vm_offset_t physaddr;

    dst = (char *)addr;
d574 1
a574 1
    while(--size >= 0) {
d576 6
a581 6
    	db_printf("byte %x\n", *data);
#endif /* 0 */
	*dst++ = *data++;    
    }
    physaddr = pmap_extract(kernel_pmap, (vm_offset_t)addr);
    cmmu_flush_cache(physaddr, i); 
d586 2
a587 1
db_putc(int c)
d589 1
a589 1
    bugoutchr(c & 0xff);
d594 1
a594 1
db_getc(void)
d596 4
a599 4
    if (buginstat())
	return (buginchr());
    else
	return -1;
d604 20
a623 17
m88k_db_where(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
    struct m88100_saved_state *s;
    char *name;
    int *offset;
    int l;

    s = DDB_REGS;

    l = m88k_pc(s); /* clear low bits */

    db_find_xtrn_sym_and_offset((db_addr_t) l,&name, (db_expr_t*)&offset);
    if (name && (unsigned)offset <= db_maxoff)
	db_printf("stopped at 0x%x  (%s+0x%x)\n",
	    l, name, offset);
    else
	db_printf("stopped at 0x%x\n", l);
d636 5
a640 1
m88k_db_frame_search(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
d643 1
a643 1
    db_printf("sorry, frame search currently disabled.\n");
d645 13
a657 14
    if (have_addr)
	addr &= ~3; /* round to word */
    else
	addr = (DDB_REGS -> r[31]);

    /* walk back up stack until 8k boundry, looking for 0 */
    while (addr & ((8*1024)-1))
    {
	int i;
	db_read_bytes(addr, 4, &i);
	if (i == 0 && frame_is_sane(i))
	    db_printf("frame found at 0x%x\n", i);
	addr += 4;
    }
d659 1
a659 1
    db_printf("(Walked back until 0x%x)\n",addr);
d665 5
a669 1
m88k_db_iflush(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
d671 2
a672 2
    addr = 0;
    cmmu_remote_set(addr, CMMU_SCR, 0, CMMU_FLUSH_CACHE_CBI_ALL);
d678 5
a682 1
m88k_db_dflush(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
d684 2
a685 3
    addr = 0;

    cmmu_remote_set(addr, CMMU_SCR, 1, CMMU_FLUSH_CACHE_CBI_ALL);
d690 32
a721 29
m88k_db_peek(db_expr_t addr, int have_addr, int count, char *modif)
{
    int pa12;
    int valmask;

    pa12 = addr & ~((1<<12) -1);

    /* probe dcache */
    cmmu_remote_set(0, CMMU_SAR, 1, addr);

    valmask = cmmu_remote_get(0, CMMU_CSSP, 1);
    db_printf("dcache valmask 0x%x\n", (unsigned)valmask);
    db_printf("dcache tag ports 0x%x 0x%x 0x%x 0x%x\n",
    (unsigned)cmmu_remote_get(0, CMMU_CTP0, 1),
    (unsigned)cmmu_remote_get(0, CMMU_CTP1, 1),
    (unsigned)cmmu_remote_get(0, CMMU_CTP2, 1),
    (unsigned)cmmu_remote_get(0, CMMU_CTP3, 1));

    /* probe icache */
    cmmu_remote_set(0, CMMU_SAR, 0, addr);

    valmask = cmmu_remote_get(0, CMMU_CSSP, 0);
    db_printf("icache valmask 0x%x\n", (unsigned)valmask);
    db_printf("icache tag ports 0x%x 0x%x 0x%x 0x%x\n",
    (unsigned)cmmu_remote_get(0, CMMU_CTP0, 0),
    (unsigned)cmmu_remote_get(0, CMMU_CTP1, 0),
    (unsigned)cmmu_remote_get(0, CMMU_CTP2, 0),
    (unsigned)cmmu_remote_get(0, CMMU_CTP3, 0));

d729 25
a753 28
m88k_db_noise(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
    if (!have_addr)
    {
	/* if off make noisy; if noisy or very noisy turn off */
	if (db_noisy)
	{
	    db_printf("changing debugger status from %s to quiet\n",
		db_noisy == 1 ? "noisy" :
		db_noisy == 2 ? "very noisy" : "violent");
	    db_noisy = 0;
	}
	else
	{
	    db_printf("changing debugger status from quiet to noisy\n");
	    db_noisy = 1;
	}
    }
    else
	if (addr < 0 || addr > 3)
	    db_printf("invalid noise level to m88k_db_noisy; should be 0, 1, 2, or 3\n");
	else
	{
	    db_noisy = addr;
	    db_printf("debugger noise level set to %s\n",
		db_noisy == 0 ? "quiet" :
		(db_noisy == 1 ? "noisy" :
		db_noisy==2 ? "very noisy" : "violent"));
d762 12
a773 14
m88k_db_translate(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
#if 1
    char c;
    int verbose_flag = 0;
    int supervisor_flag = 1;
    int wanthelp = 0;
    if (!have_addr)
	wanthelp = 1;
    else {
        while (c = *modif++, c != 0) {
	    switch (c) {
            default:
		db_printf("bad modifier [%c]\n", c); 
d775 29
a803 14
		break;
            case 'h':
		wanthelp = 1;
		break;
            case 'v':
		verbose_flag++;
		break;
            case 's':
		supervisor_flag = 1;
		break;
            case 'u':
		supervisor_flag = 0;
		break;
    	    }
d805 1
a805 11
    }
    if (wanthelp) {
	db_printf("usage: translate[/vvsu] address\n");
	db_printf("flags: v - be verbose (vv - be very verbose)\n");
	db_printf("       s - use cmmu's supervisor area pointer (default)\n");
	db_printf("       u - use cmmu's user area pointer\n");
	return;
    }
    cmmu_show_translation(addr, supervisor_flag, verbose_flag, -1);
#endif
    return;
d809 5
a813 1
m88k_db_cmmucfg(db_expr_t addr, int have_addr, int count, char *modif)
d815 2
a816 2
    if (modif && *modif) {
	db_printf("usage: mach cmmucfg\n");
d818 1
a818 1
    }
d820 1
a820 2
    cmmu_dump_config();
    return;
d823 4
a826 2
void cpu_interrupt_to_db(int cpu_no)
{}
d858 1
a858 1
kdb_init(void)
d861 1
a861 1
    db_machine_commands_install(db_machine_cmds);
d863 1
a863 1
    ddb_init();
d865 1
a865 1
    db_printf("ddb enabled\n");
d877 2
a878 2
char
*db_task_name()
d880 24
a903 28
    static unsigned buffer[(DB_TASK_NAME_LEN + 5)/sizeof(unsigned)];
    unsigned ptr = (vm_offset_t)(TOP_OF_USER_STACK - 4);
    unsigned limit = ptr - MAX_DISTANCE_TO_LOOK;
    unsigned word;
    int i;

    /* skip zeros at the end */
    while (ptr > limit &&
	   (i = db_trace_get_val((vm_offset_t)ptr, &word))
	   && (word == 0))
    {
	ptr -= 4; /* continue looking for a non-null word */
    }

    if (ptr <= limit) {
	db_printf("bad name at line %d\n", __LINE__);
	return "<couldn't find 1>";
    } else if (i != 1) {
 	return "<nostack>";
    }

    /* skip looking for null before all the text */
    while (ptr > limit
	&&(i = db_trace_get_val(ptr, &word))
    	&& (word != 0))
    {
	ptr -= 4; /* continue looking for a null word */
    }
d905 15
a919 16
    if (ptr <= limit) {
	db_printf("bad name at line %d\n", __LINE__);
	return "<couldn't find 2>";
    } else if (i != 1) {
	db_printf("bad name read of %x "
	          "at line %d\n", ptr, __LINE__);
 	return "<bad read 2>";
    }

    ptr += 4; /* go back to the non-null word after this one */

    for (i = 0; i < sizeof(buffer); i++, ptr+=4) {
	buffer[i] = 0; /* just in case it's not read */
	db_trace_get_val((vm_offset_t)ptr, &buffer[i]);
    }
    return (char*)buffer;
@


1.6
log
@Some warning hunting.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.5 2001/02/01 03:38:12 smurph Exp $	*/
d34 1
a36 1
#include <sys/systm.h> /* just for boothowto --eichin */
d44 1
d49 2
d55 8
d397 1
a397 1
    return(1);
d406 1
@


1.5
log
@Major changes to get MVME188 working.  More header and code cleanups.  The
kernel is tested on MVME188A/2P256 and MVME188A/1P64.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.4 1999/02/09 06:36:24 smurph Exp $	*/
a56 12
/*
 * Received keyboard interrupt sequence.
 */
kdb_kintr(regs)
        register struct m88100_saved_state *regs;
{
        if (db_active == 0 && (boothowto & RB_KDB)) {
                printf("\n\nkernel: keyboard interrupt\n");
                m88k_db_trap(-1, regs);
        }
}

d80 1
a80 1
/* DB_REGISTERS ****/
d128 1
a128 2
    if (XMEM(t))
    {
d133 2
a134 5
    }
    else
    {
	if (MODE(t) == 0xf)
	{
d136 1
a136 1
	    if (STORE(t))
d142 1
a142 1
	    else /* load */
d148 2
a149 3
	}
	else
	{
d341 1
a341 1

d347 1
a349 1
#if 0
d396 2
a397 2
	int	type, code;
{
d400 2
a401 2
		printf("type %d", type);
	else
d404 1
a404 1
}
a510 1
    pte_template_t 	*pte;
a547 1
    int i;
@


1.4
log
@Added kernel support for user debugging.  Fixed file ID's
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.28 1995/04/19 22:37:27 smurph Exp $	*/
d45 1
d709 1
a709 1
#if 0
a713 1

d745 12
d758 2
a759 2
    cmmu_show_translation(addr, supervisor_flag, verbose_flag);
#endif /* 0 */
d786 1
@


1.4.6.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.8 2001/03/16 00:01:51 miod Exp $	*/
a33 1
#include <sys/systm.h>
d36 1
a43 1
#include <machine/locore.h>		 
a44 1
#include <machine/cpu_number.h>
a46 2
#include <ddb/db_extern.h>
#include <ddb/db_output.h>
a50 15
extern unsigned db_trace_get_val(vm_offset_t addr, unsigned *ptr);
extern int frame_is_sane __P((db_regs_t *));
extern void cnpollc __P((int));
void kdbprinttrap __P((int type, int code));
void kdb_init __P((void));

void m88k_db_trap __P((int type, struct m88100_saved_state *regs));
int ddb_nmi_trap __P((int level, db_regs_t *eframe));
void ddb_error_trap __P((char *error, db_regs_t *eframe));
void db_read_bytes __P((vm_offset_t addr, int size, char *data));
void db_write_bytes __P((char *addr, int size, char *data));
void db_putc __P((int c));
int db_getc __P((void));
void cpu_interrupt_to_db __P((int cpu_no));
char *db_task_name __P((void));
d56 12
d73 1
a73 2
m88k_db_str(str)
	char *str;
d75 1
a75 1
	db_printf(str);
d79 1
a79 3
m88k_db_str1(str, arg1)
	char *str;
	int arg1;
d81 1
a81 1
	db_printf(str, arg1);
d85 1
a85 3
m88k_db_str2(str, arg1, arg2)
	char *str;
	int arg1, arg2;
d87 1
a87 1
	db_printf(str, arg1, arg2);
d91 1
a91 1
/* 	DB_REGISTERS ****/
d125 1
a125 2
m88k_dmx_print(t, d, a, no)
	unsigned t, d, a, no;
d127 36
a162 56
	static unsigned addr_mod[16] = {
	    0, 3, 2, 2, 1, 0, 0, 0,
	    0, 0, 0, 0, 0, 0, 0, 0
	};
	static char *mode[16]  = {
	    "?", ".b", ".b", ".h", ".b", "?", "?", "?",
	    ".b", ".h", "?" , "?" , "?" , "?", "?", ""
	};
	static unsigned mask[16] = {
	    0,           0xff,        0xff00,     0xffff,
	    0xff0000,    0,           0,          0,
	    0xff000000U, 0xffff0000U, 0,          0,
	    0,           0,           0,          0xffffffffU
	};
	static unsigned shift[16] = {
	    0,  0, 8, 0, 16, 0, 0, 0,
	    24, 16, 0, 0,  0, 0, 0, 0
	};
	int reg = REG(t);

	if (XMEM(t)) {
		db_printf("xmem%s%s r%d(0x%x) <-> mem(0x%x),",
		    XMEM_MODE(t), DAS(t), reg,
		    (((t)>>2 & 0xf) == 0xf) ? d : (d & 0xff), a);
		return 1;
	} else {
		if (MODE(t) == 0xf) {
			/* full or double word */
			if (STORE(t)) {
				if (DOUB(t) && no == 2)
					db_printf("st.d%s -> mem(0x%x) (** restart sxip **)",
					    DAS(t), a);
				else
					db_printf("st%s (0x%x) -> mem(0x%x)",
					    DAS(t), d, a);
			} else {
				/* load */
				if (DOUB(t) && no == 2)
					db_printf("ld.d%s r%d <- mem(0x%x), r%d <- mem(0x%x)",
					    DAS(t), reg, a, reg+1, a+4);
				else
					db_printf("ld%s r%d <- mem(0x%x)",
					    DAS(t), reg, a);
			}
		} else {
			/* fractional word - check if load or store */
			a += addr_mod[MODE(t)];
			if (STORE(t))
				db_printf("st%s%s (0x%x) -> mem(0x%x)",
				    mode[MODE(t)], DAS(t),
				    (d & mask[MODE(t)]) >> shift[MODE(t)], a);
			else
				db_printf("ld%s%s%s r%d <- mem(0x%x)",
				    mode[MODE(t)], SIGN(t) ? "" : "u",
				    DAS(t), reg, a);
		}
d164 13
a176 1
	return 0;
d180 29
a208 11
m88k_db_print_frame(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	int count;
	char *modif;
{
	struct m88100_saved_state *s = (struct m88100_saved_state *)addr;
	char *name;
	db_expr_t offset;
	int surpress1 = 0, surpress2 = 0;
	int c, force = 0, help = 0;
d210 9
a218 4
	if (!have_addr) {
		db_printf("requires address of frame\n");
		help = 1;
	}
d220 5
a224 36
	while (modif && *modif) {
		switch (c = *modif++, c) {
		case 'f':
			force = 1;
			break;
		case 'h':
			help = 1;
			break;
		default:
			db_printf("unknown modifier [%c]\n", c);
			help = 1;
			break;
		}
	}

	if (help) {
		db_printf("usage: mach frame/[f] ADDRESS\n");
		db_printf("  /f force printing of insane frames.\n");
		return;
	}

	if (badwordaddr((vm_offset_t)s) ||
	    badwordaddr((vm_offset_t)(&((db_regs_t*)s)->mode))) {
		db_printf("frame at 0x%08x is unreadable\n", s);
		return;
	}

	if (!frame_is_sane((db_regs_t *)s)) {  /* see db_trace.c */
		db_printf("frame seems insane (");

		if (force)
			db_printf("forging ahead anyway...)\n");
		else {
			db_printf("use /f to force)\n");
			return;
		}
d226 1
d230 23
a252 17
	db_printf("R00-05: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	    R(0), R(1), R(2), R(3), R(4), R(5));
	db_printf("R06-11: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	    R(6), R(7), R(8), R(9), R(10), R(11));
	db_printf("R12-17: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	    R(12), R(13), R(14), R(15), R(16), R(17));
	db_printf("R18-23: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	    R(18), R(19), R(20), R(21), R(22), R(23));
	db_printf("R24-29: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	    R(24), R(25), R(26), R(27), R(28), R(29));
	db_printf("R30-31: 0x%08x  0x%08x\n", R(30), R(31));

	db_printf("sxip: 0x%08x ", s->sxip & ~3);
	db_find_xtrn_sym_and_offset((db_addr_t)IPMASK(s->sxip),
	    &name, &offset);
	if (name != 0 && (unsigned)offset <= db_maxoff)
		db_printf("%s+0x%08x", name, (unsigned)offset);
d254 9
d264 11
a274 8
	if (s->snip != s->sxip + 4) {
		db_printf("snip: 0x%08x ", s->snip);
		db_find_xtrn_sym_and_offset((db_addr_t)IPMASK(s->snip),
		    &name, &offset);
		if (name != 0 && (unsigned)offset <= db_maxoff)
			db_printf("%s+0x%08x", name, (unsigned)offset);
		db_printf("\n");
	}
d276 5
a280 8
	if (s->sfip != s->snip + 4) {
		db_printf("sfip: 0x%08x ", s->sfip);
		db_find_xtrn_sym_and_offset((db_addr_t)IPMASK(s->sfip),
		    &name, &offset);
		if (name != 0 && (unsigned)offset <= db_maxoff)
			db_printf("%s+0x%08x", name, (unsigned)offset);
		db_printf("\n");
	}
d282 9
a290 16
	db_printf("vector: 0x%02x                    interrupt mask: 0x%08x\n",
	    s->vector, s->mask);
	db_printf("epsr: 0x%08x                current process: 0x%x\n",
	    s->epsr, curproc);

	/*
	 * If the vector indicates trap, instead of an exception or
	 * interrupt, skip the check of dmt and fp regs.
	 *
	 * Interrupt and exceptions are vectored at 0-10 and 114-127.
	 */

	if (!(s->vector <= 10 || (114 <= s->vector && s->vector <= 127))) {
		db_printf("\n\n");
		return;
	}
d292 16
a307 6
	if (s->vector == /*data*/3 || s->dmt0 & 1) {
		db_printf("dmt,d,a0: 0x%08x  0x%08x  0x%08x ",
		    s->dmt0, s->dmd0, s->dma0);
		db_find_xtrn_sym_and_offset((db_addr_t)s->dma0, &name, &offset);
		if (name != 0 && (unsigned)offset <= db_maxoff)
			db_printf("%s+0x%08x", name, (unsigned)offset);
d309 1
a309 1
		surpress1 = m88k_dmx_print(s->dmt0|0x01, s->dmd0, s->dma0, 0);
d311 1
a311 24

		if ((s->dmt1 & 1) && (!surpress1)) {
			db_printf("dmt,d,a1: 0x%08x  0x%08x  0x%08x ",
			    s->dmt1, s->dmd1, s->dma1);
			db_find_xtrn_sym_and_offset((db_addr_t)s->dma1,
			    &name, &offset);
			if (name != 0 && (unsigned)offset <= db_maxoff)
				db_printf("%s+0x%08x", name, (unsigned)offset);
			db_printf("\n          ");
			surpress2 = m88k_dmx_print(s->dmt1, s->dmd1, s->dma1, 1);
			db_printf("\n");

			if ((s->dmt2 & 1) && (!surpress2)) {
				db_printf("dmt,d,a2: 0x%08x  0x%08x  0x%08x ",
				    s->dmt2, s->dmd2, s->dma2);
				db_find_xtrn_sym_and_offset((db_addr_t)s->dma2,
				    &name, &offset);
				if (name != 0 && (unsigned)offset <= db_maxoff)
					db_printf("%s+0x%08x", name, (unsigned)offset);
				db_printf("\n          ");
				m88k_dmx_print(s->dmt2, s->dmd2, s->dma2, 2);
				db_printf("\n");
			}
		}
d313 1
d315 10
a324 9
	if (s->fpecr & 255) { /* floating point error occured */
		db_printf("fpecr: 0x%08x fpsr: 0x%08x fpcr: 0x%08x\n",
		    s->fpecr, s->fpsr, s->fpcr);
		db_printf("fcr1-4: 0x%08x  0x%08x  0x%08x  0x%08x\n",
		    s->fphs1, s->fpls1, s->fphs2, s->fpls2);
		db_printf("fcr5-8: 0x%08x  0x%08x  0x%08x  0x%08x\n",
		    s->fppt, s->fprh, s->fprl, s->fpit);
	}
	db_printf("\n\n");
d328 6
a333 10
m88k_db_registers(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	int count;
	char *modif;
{
	if (modif != NULL && *modif != 0) {
		db_printf("usage: mach regs\n");
		return;
	}
d335 2
a336 1
	m88k_db_print_frame((db_expr_t)DDB_REGS, TRUE, 0, 0);
d347 1
a347 2
m88k_db_pause(ticks)
	unsigned volatile ticks;
d349 3
a351 2
	while (ticks)
		ticks -= 1;
d357 4
a360 4
void
m88k_db_trap(type, regs)
	int type;
	register struct m88100_saved_state *regs;
d362 3
d366 2
a367 4
	int i;

	if ((i = db_spl()) != 7)
		m88k_db_str1("WARNING: spl is not high in m88k_db_trap (spl=%x)\n", i);
d370 2
a371 2
	if (db_are_interrupts_disabled())
		m88k_db_str("WARNING: entered debugger with interrupts disabled\n");
d373 1
a373 1
	switch(type) {
d375 13
a387 13
	case T_KDB_BREAK:
	case T_KDB_TRACE:
	case T_KDB_ENTRY:
		break;
	case -1:
		break;
	default:
		kdbprinttrap(type, 0);
		if (db_recover != 0) {
			db_error("Caught exception in ddb.\n");
			/*NOTREACHED*/
		}
	}
d389 1
a389 1
	ddb_regs = *regs;
d391 5
a395 5
	db_active++;
	cnpollc(TRUE);
	db_trap(type, 0);
	cnpollc(FALSE);
	db_active--;
d397 1
a397 1
	*regs = ddb_regs;
d400 1
a400 1
	(void) spl7();
d402 1
a410 1
void
d412 2
a413 2
	int type, code;
{       
d416 2
a417 2
		printf("type %d", type); 
	else    
d420 1
a420 1
}       
d423 1
a423 1
Debugger()
d425 2
a426 2
	asm (ENTRY_ASM); /* entry trap */
	/* ends up at ddb_entry_trap below */
d431 1
a431 1
gimmeabreak()
d433 2
a434 2
	asm (ENTRY_ASM); /* entry trap */
	/* ends up at ddb_entry_trap below */
d439 1
a439 3
ddb_nmi_trap(level, eframe)
	int level;
	db_regs_t *eframe;
d441 2
a442 2
	NOISY(m88k_db_str("kernel: nmi interrupt\n");)
	m88k_db_trap(T_KDB_ENTRY, eframe);
d444 1
a444 1
	return 0;
d456 10
a465 14
ddb_break_trap(type, eframe)
	int type;
	db_regs_t *eframe;
{
	m88k_db_trap(type, eframe);

	if (type == T_KDB_BREAK) {
		/*
		 * back up an instruction and retry the instruction
		 * at the breakpoint address
		 */
		eframe->sfip = eframe->snip;
		eframe->snip = eframe->sxip;
	}
d467 1
a467 1
	return 0;
d472 1
a472 3
ddb_entry_trap(level, eframe)
	int level;
	db_regs_t *eframe;
d474 1
a474 1
	m88k_db_trap(T_KDB_ENTRY, eframe);
d476 1
a476 1
	return 0;
d485 9
a493 10
ddb_error_trap(error, eframe)
	char *error;
	db_regs_t *eframe;
{
	m88k_db_str1("KERNEL:  terminal error [%s]\n",(int)error);
	m88k_db_str ("KERNEL:  Exiting debugger will cause abort to rom\n");
	m88k_db_str1("at 0x%x ", eframe->sxip & ~3);
	m88k_db_str2("dmt0 0x%x dma0 0x%x", eframe->dmt0, eframe->dma0);
	m88k_db_pause(1000000);
	m88k_db_trap(T_KDB_BREAK, eframe);
d505 1
a505 1
	register char	*src;
d507 1
a507 1
	src = (char *)addr;
d509 3
a511 3
	while(--size >= 0) {
		*data++ = *src++;
	}
d521 2
a522 8
db_write_bytes(addr, size, data)
	char *addr;
	int size;
	char *data;
{
	register char *dst;
	vm_offset_t physaddr;
	int i = size;
d524 6
a529 1
	dst = (char *)addr;
d531 1
a531 1
	while (--size >= 0) {
d533 6
a538 6
		db_printf("byte %x\n", *data);
#endif
		*dst++ = *data++;    
	}
	physaddr = pmap_extract(kernel_pmap, (vm_offset_t)addr);
	cmmu_flush_cache(physaddr, i); 
d543 1
a543 2
db_putc(c)
	int c;
d545 1
a545 1
	bugoutchr(c & 0xff);
d550 1
a550 1
db_getc()
d552 4
a555 4
	if (buginstat())
		return (buginchr());
	else
		return -1;
d560 18
a577 20
m88k_db_where(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	struct m88100_saved_state *s;
	char *name;
	int *offset;
	int l;

	s = DDB_REGS;

	l = m88k_pc(s); /* clear low bits */

	db_find_xtrn_sym_and_offset((db_addr_t) l,&name, (db_expr_t*)&offset);
	if (name && (unsigned)offset <= db_maxoff)
		db_printf("stopped at 0x%x  (%s+0x%x)\n", l, name, offset);
	else
		db_printf("stopped at 0x%x\n", l);
d590 1
a590 5
m88k_db_frame_search(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
d593 1
a593 1
	db_printf("sorry, frame search currently disabled.\n");
d595 14
a608 13
	if (have_addr)
		addr &= ~3; /* round to word */
	else
		addr = (DDB_REGS->r[31]);

	/* walk back up stack until 8k boundry, looking for 0 */
	while (addr & ((8 * 1024) - 1)) {
		int i;
		db_read_bytes(addr, 4, &i);
		if (i == 0 && frame_is_sane((db_regs_t *)i))
			db_printf("frame found at 0x%x\n", i);
		addr += 4;
	}
d610 1
a610 1
	db_printf("(Walked back until 0x%x)\n",addr);
d616 1
a616 5
m88k_db_iflush(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
d618 2
a619 2
	addr = 0;
	cmmu_remote_set(addr, CMMU_SCR, 0, CMMU_FLUSH_CACHE_CBI_ALL);
d625 1
a625 5
m88k_db_dflush(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
d627 3
a629 2
	addr = 0;
	cmmu_remote_set(addr, CMMU_SCR, 1, CMMU_FLUSH_CACHE_CBI_ALL);
d634 29
a662 32
m88k_db_peek(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	int pa12;
	int valmask;

	pa12 = addr & ~((1<<12) -1);

	/* probe dcache */
	cmmu_remote_set(0, CMMU_SAR, 1, addr);

	valmask = cmmu_remote_get(0, CMMU_CSSP, 1);
	db_printf("dcache valmask 0x%x\n", (unsigned)valmask);
	db_printf("dcache tag ports 0x%x 0x%x 0x%x 0x%x\n",
	    (unsigned)cmmu_remote_get(0, CMMU_CTP0, 1),
	    (unsigned)cmmu_remote_get(0, CMMU_CTP1, 1),
	    (unsigned)cmmu_remote_get(0, CMMU_CTP2, 1),
	    (unsigned)cmmu_remote_get(0, CMMU_CTP3, 1));

	/* probe icache */
	cmmu_remote_set(0, CMMU_SAR, 0, addr);

	valmask = cmmu_remote_get(0, CMMU_CSSP, 0);
	db_printf("icache valmask 0x%x\n", (unsigned)valmask);
	db_printf("icache tag ports 0x%x 0x%x 0x%x 0x%x\n",
	    (unsigned)cmmu_remote_get(0, CMMU_CTP0, 0),
	    (unsigned)cmmu_remote_get(0, CMMU_CTP1, 0),
	    (unsigned)cmmu_remote_get(0, CMMU_CTP2, 0),
	    (unsigned)cmmu_remote_get(0, CMMU_CTP3, 0));
d670 28
a697 25
m88k_db_noise(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	if (!have_addr) {
		/* if off make noisy; if noisy or very noisy turn off */
		if (db_noisy) {
			db_printf("changing debugger status from %s to quiet\n",
			    db_noisy == 1 ? "noisy" :
			    db_noisy == 2 ? "very noisy" : "violent");
			    db_noisy = 0;
		} else {
			db_printf("changing debugger status from quiet to noisy\n");
			db_noisy = 1;
		}
	} else if (addr < 0 || addr > 3)
		db_printf("invalid noise level to m88k_db_noisy; should be 0, 1, 2, or 3\n");
	else {
		db_noisy = addr;
		db_printf("debugger noise level set to %s\n",
		    db_noisy == 0 ? "quiet" :
		    (db_noisy == 1 ? "noisy" :
		        db_noisy==2 ? "very noisy" : "violent"));
d706 18
a723 12
m88k_db_translate(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	char c;
	int verbose_flag = 0;
	int supervisor_flag = 1;
	int wanthelp = 0;

	if (!have_addr)
d725 11
a735 29
	else {
		while (c = *modif++, c != 0) {
			switch (c) {
			default:
				db_printf("bad modifier [%c]\n", c); 
				wanthelp = 1;
				break;
			case 'h':
				wanthelp = 1;
				break;
			case 'v':
				verbose_flag++;
				break;
			case 's':
				supervisor_flag = 1;
				break;
			case 'u':
				supervisor_flag = 0;
				break;
			}
		}
	}

	if (wanthelp) {
		db_printf("usage: translate[/vvsu] address\n");
		db_printf("flags: v - be verbose (vv - be very verbose)\n");
		db_printf("       s - use cmmu's supervisor area pointer (default)\n");
		db_printf("       u - use cmmu's user area pointer\n");
		return;
d737 6
a742 12
	cmmu_show_translation(addr, supervisor_flag, verbose_flag, -1);
}

static void
m88k_db_cmmucfg(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	if (modif != NULL && *modif != 0) {
		db_printf("usage: mach cmmucfg\n");
d744 1
a744 1
	}
d746 2
a747 1
	cmmu_dump_config();
d750 2
a751 4
void cpu_interrupt_to_db(cpu_no)
	int cpu_no;
{
}
a773 1
    {"cmmucfg",		m88k_db_cmmucfg,        0, 0},
d782 1
a782 1
kdb_init()
d785 1
a785 1
	db_machine_commands_install(db_machine_cmds);
d787 1
a787 1
	ddb_init();
d789 1
a789 1
	db_printf("ddb enabled\n");
d801 2
a802 2
char *
db_task_name()
d804 28
a831 24
	static unsigned buffer[(DB_TASK_NAME_LEN + 5) / sizeof(unsigned)];
	unsigned ptr = (vm_offset_t)(TOP_OF_USER_STACK - 4);
	unsigned limit = ptr - MAX_DISTANCE_TO_LOOK;
	unsigned word;
	int i;

	/* skip zeros at the end */
	while (ptr > limit &&
	    (i = db_trace_get_val((vm_offset_t)ptr, &word)) && (word == 0)) {
		ptr -= 4; /* continue looking for a non-null word */
	}

	if (ptr <= limit) {
		db_printf("bad name at line %d\n", __LINE__);
		return "<couldn't find 1>";
	} else if (i != 1) {
		return "<nostack>";
	}

	/* skip looking for null before all the text */
	while (ptr > limit &&
	    (i = db_trace_get_val(ptr, &word)) && (word != 0)) {
		ptr -= 4; /* continue looking for a null word */
	}
d833 16
a848 15
	if (ptr <= limit) {
		db_printf("bad name at line %d\n", __LINE__);
		return "<couldn't find 2>";
	} else if (i != 1) {
		db_printf("bad name read of %x at line %d\n", ptr, __LINE__);
		return "<bad read 2>";
	}

	ptr += 4; /* go back to the non-null word after this one */

	for (i = 0; i < sizeof(buffer); i++, ptr += 4) {
		buffer[i] = 0; /* just in case it's not read */
		db_trace_get_val((vm_offset_t)ptr, &buffer[i]);
	}
	return (char*)buffer;
@


1.4.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.4.6.1 2001/04/18 16:10:51 niklas Exp $	*/
d580 1
a580 1
	pmap_extract(kernel_pmap, (vm_offset_t)addr, &physaddr);
a827 5
void
m88k_db_prom_cmd(void)
{
	doboot();
}
a850 1
    {"prom",		m88k_db_prom_cmd,	0, 0},
d860 1
d862 1
@


1.4.6.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.4.6.2 2001/07/04 10:19:52 niklas Exp $	*/
a49 1
#include <ddb/db_interface.h>
d59 1
a69 12
int m88k_dmx_print __P((unsigned, unsigned, unsigned, unsigned));
void m88k_db_pause __P((unsigned));
void m88k_db_print_frame __P((db_expr_t, int, db_expr_t, char *));
void m88k_db_where __P((db_expr_t, int, db_expr_t, char *));
void m88k_db_frame_search __P((db_expr_t, int, db_expr_t, char *));
void m88k_db_iflush __P((db_expr_t, int, db_expr_t, char *));
void m88k_db_dflush __P((db_expr_t, int, db_expr_t, char *));
void m88k_db_peek __P((db_expr_t, int, db_expr_t, char *));
void m88k_db_noise __P((db_expr_t, int, db_expr_t, char *));
void m88k_db_translate __P((db_expr_t, int, db_expr_t, char *));
void m88k_db_cmmucfg __P((db_expr_t, int, db_expr_t, char *));
void m88k_db_prom_cmd __P((db_expr_t, int, db_expr_t, char *));
d76 27
d136 1
a136 1
int
d200 1
a200 1
void
d204 1
a204 1
	db_expr_t count;
d347 1
a347 1
	if (s->fpecr & 255) { /* floating point error occurred */
d358 15
d380 1
a380 1
void
d400 1
a400 1
		db_printf("WARNING: spl is not high in m88k_db_trap (spl=%x)\n", i);
d404 1
a404 1
		db_printf("WARNING: entered debugger with interrupts disabled\n");
d462 8
d476 1
a476 1
	NOISY(db_printf("kernel: nmi interrupt\n");)
d530 4
a533 4
	db_printf("KERNEL:  terminal error [%s]\n",(int)error);
	db_printf("KERNEL:  Exiting debugger will cause abort to rom\n");
	db_printf("at 0x%x ", eframe->sxip & ~3);
	db_printf("dmt0 0x%x dma0 0x%x", eframe->dmt0, eframe->dma0);
d580 1
a580 1
	pmap_extract(pmap_kernel(), (vm_offset_t)addr, &physaddr);
d603 1
a603 1
void
d635 1
a635 1
void
d664 1
a664 1
void
d677 1
a677 1
void
d689 1
a689 1
void
d728 1
a728 1
void
d761 1
a761 1
void
d808 1
a808 1
void
d829 1
a829 5
m88k_db_prom_cmd(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
d838 1
a838 1
struct db_command m88k_cache_cmds[] =
d851 1
d864 1
a864 1
db_machine_init()
d867 3
@


1.4.6.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d38 1
a38 1
#include <uvm/uvm_extern.h>
a89 2

db_regs_t	ddb_regs;
@


1.4.6.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.4.6.4 2001/11/13 21:04:14 niklas Exp $	*/
d43 1
a43 1
#include <machine/bugio.h>		 /* bug routines 		*/
@


1.4.6.6
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d40 4
a43 5
#include <machine/asm_macro.h>		/* flush_pipeline()	*/
#include <machine/cmmu.h>		/* CMMU defs		*/
#include <machine/trap.h>		/* current_thread()	*/
#include <machine/db_machdep.h>		/* local ddb stuff	*/
#include <machine/bugio.h>		/* bug routines		*/
d45 1
a72 1
void m88k_db_registers __P((db_expr_t, int, db_expr_t, char *));
d128 2
a129 2
		0, 3, 2, 2, 1, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0
d132 2
a133 2
		"?", ".b", ".b", ".h", ".b", "?", "?", "?",
		".b", ".h", "?" , "?" , "?" , "?", "?", ""
d136 4
a139 4
		0,           0xff,        0xff00,     0xffff,
		0xff0000,    0,           0,          0,
		0xff000000U, 0xffff0000U, 0,          0,
		0,           0,           0,          0xffffffffU
d142 2
a143 2
		0,  0, 8, 0, 16, 0, 0, 0,
		24, 16, 0, 0,  0, 0, 0, 0
d149 2
a150 2
			  XMEM_MODE(t), DAS(t), reg,
			  (((t)>>2 & 0xf) == 0xf) ? d : (d & 0xff), a);
d158 1
a158 1
						  DAS(t), a);
d161 1
a161 1
						  DAS(t), d, a);
d166 1
a166 1
						  DAS(t), reg, a, reg+1, a+4);
d169 1
a169 1
						  DAS(t), reg, a);
d176 2
a177 2
					  mode[MODE(t)], DAS(t),
					  (d & mask[MODE(t)]) >> shift[MODE(t)], a);
d180 2
a181 2
					  mode[MODE(t)], SIGN(t) ? "" : "u",
					  DAS(t), reg, a);
d246 1
a246 1
		  R(0), R(1), R(2), R(3), R(4), R(5));
d248 1
a248 1
		  R(6), R(7), R(8), R(9), R(10), R(11));
d250 1
a250 1
		  R(12), R(13), R(14), R(15), R(16), R(17));
d252 1
a252 1
		  R(18), R(19), R(20), R(21), R(22), R(23));
d254 1
a254 1
		  R(24), R(25), R(26), R(27), R(28), R(29));
d257 1
a257 1
	db_printf("%sxip: 0x%08x ", cputyp == CPU_88110 ? "e" : "s", s->sxip & ~3);
d259 1
a259 1
				    &name, &offset);
d265 1
a265 1
		db_printf("%snip: 0x%08x ", cputyp == CPU_88110 ? "e" : "s", s->snip);
d267 1
a267 1
					    &name, &offset);
d273 7
a279 16
	if (cputyp != CPU_88110) {
		if (s->sfip != s->snip + 4) {
			db_printf("sfip: 0x%08x ", s->sfip);
			db_find_xtrn_sym_and_offset((db_addr_t)IPMASK(s->sfip),
						    &name, &offset);
			if (name != 0 && (unsigned)offset <= db_maxoff)
				db_printf("%s+0x%08x", name, (unsigned)offset);
			db_printf("\n");
		}
	} else {
		db_printf("fpsr: 0x%08x fpcr: 0x%08x fpecr: 0x%08x\n",
			  s->fpsr, s->fpcr, s->fpecr);
		db_printf("dsap 0x%08x duap 0x%08x dsr 0x%08x dlar 0x%08x dpar 0x%08x\n",
			  s->dsap, s->duap, s->dsr, s->dlar, s->dpar);
		db_printf("isap 0x%08x iuap 0x%08x isr 0x%08x ilar 0x%08x ipar 0x%08x\n",
			  s->isap, s->iuap, s->isr, s->ilar, s->ipar);
d282 2
d285 1
a285 3
		  s->epsr, curproc);
	db_printf("vector: 0x%02x                    interrupt mask: 0x%08x\n",
		  s->vector, s->mask);
d295 1
a295 1
		db_printf("\n");
d299 15
a313 5
	if (cputyp != CPU_88110) {
		if (s->vector == /*data*/3 || s->dmt0 & 1) {
			db_printf("dmt,d,a0: 0x%08x  0x%08x  0x%08x ",
				  s->dmt0, s->dmd0, s->dma0);
			db_find_xtrn_sym_and_offset((db_addr_t)s->dma0, &name, &offset);
d317 1
a317 1
			surpress1 = m88k_dmx_print(s->dmt0|0x01, s->dmd0, s->dma0, 0);
d320 5
a324 5
			if ((s->dmt1 & 1) && (!surpress1)) {
				db_printf("dmt,d,a1: 0x%08x  0x%08x  0x%08x ",
					  s->dmt1, s->dmd1, s->dma1);
				db_find_xtrn_sym_and_offset((db_addr_t)s->dma1,
							    &name, &offset);
d328 1
a328 1
				surpress2 = m88k_dmx_print(s->dmt1, s->dmd1, s->dma1, 1);
a329 12

				if ((s->dmt2 & 1) && (!surpress2)) {
					db_printf("dmt,d,a2: 0x%08x  0x%08x  0x%08x ",
						  s->dmt2, s->dmd2, s->dma2);
					db_find_xtrn_sym_and_offset((db_addr_t)s->dma2,
								    &name, &offset);
					if (name != 0 && (unsigned)offset <= db_maxoff)
						db_printf("%s+0x%08x", name, (unsigned)offset);
					db_printf("\n          ");
					m88k_dmx_print(s->dmt2, s->dmd2, s->dma2, 2);
					db_printf("\n");
				}
d336 5
a340 7
			  s->fpecr, s->fpsr, s->fpcr);
		if (cputyp != CPU_88110) {
			db_printf("fcr1-4: 0x%08x  0x%08x  0x%08x  0x%08x\n",
				  s->fphs1, s->fpls1, s->fphs2, s->fpls2);
			db_printf("fcr5-8: 0x%08x  0x%08x  0x%08x  0x%08x\n",
				  s->fppt, s->fprh, s->fprl, s->fpit);
		}
d342 1
a342 11
	db_printf("\n");
}

void
m88k_db_registers(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	int count;
	char *modif;
{
	m88k_db_print_frame((db_expr_t)DDB_REGS, TRUE, 0, modif);
d464 1
a464 2
		 * at the breakpoint address.  mc88110's exip reg 
		 * already has the adress of the exception instruction.
a465 1
		if (cputyp != CPU_88110) {
a467 1
		}
a635 1
#ifdef may_be_removed
a636 1
#endif 
a648 1
#ifdef may_be_removed
a649 1
#endif 
a659 1
#ifdef may_be_removed
d671 4
a674 4
		  (unsigned)cmmu_remote_get(0, CMMU_CTP0, 1),
		  (unsigned)cmmu_remote_get(0, CMMU_CTP1, 1),
		  (unsigned)cmmu_remote_get(0, CMMU_CTP2, 1),
		  (unsigned)cmmu_remote_get(0, CMMU_CTP3, 1));
d682 4
a685 5
		  (unsigned)cmmu_remote_get(0, CMMU_CTP0, 0),
		  (unsigned)cmmu_remote_get(0, CMMU_CTP1, 0),
		  (unsigned)cmmu_remote_get(0, CMMU_CTP2, 0),
		  (unsigned)cmmu_remote_get(0, CMMU_CTP3, 0));
#endif 
d703 3
a705 3
				  db_noisy == 1 ? "noisy" :
				  db_noisy == 2 ? "very noisy" : "violent");
			db_noisy = 0;
d715 3
a717 3
			  db_noisy == 0 ? "quiet" :
			  (db_noisy == 1 ? "noisy" :
			   db_noisy==2 ? "very noisy" : "violent"));
d808 4
a811 4
	{ "iflush",    m88k_db_iflush, 0, 0},
	{ "dflush",    m88k_db_dflush, 0, 0},
	{ "peek",      m88k_db_peek, 0, 0},
	{ (char *) 0,}
d816 9
a824 10
	{"cache",           0,                      0, m88k_cache_cmds},
	{"frame",           m88k_db_print_frame,    0, 0},
	{"regs",            m88k_db_registers,      0, 0},
	{"noise",           m88k_db_noise,          0, 0},
	{"searchframe",     m88k_db_frame_search,   0, 0},
	{"translate",       m88k_db_translate,      0, 0},
	{"cmmucfg",         m88k_db_cmmucfg,        0, 0},
	{"where",           m88k_db_where,          0, 0},
	{"prom",            m88k_db_prom_cmd,       0, 0},
	{(char  *) 0,}
d856 1
a856 1
	       (i = db_trace_get_val((vm_offset_t)ptr, &word)) && (word == 0)) {
d869 1
a869 1
	       (i = db_trace_get_val(ptr, &word)) && (word != 0)) {
d872 1
a872 1

a888 1

@


1.4.6.7
log
@Merge in -current from about a week ago
@
text
@d57 26
a82 26
extern int frame_is_sane(db_regs_t *);
extern void cnpollc(int);
void kdbprinttrap(int type, int code);

void m88k_db_trap(int type, struct m88100_saved_state *regs);
int ddb_nmi_trap(int level, db_regs_t *eframe);
void ddb_error_trap(char *error, db_regs_t *eframe);
void db_read_bytes(vm_offset_t addr, int size, char *data);
void db_write_bytes(char *addr, int size, char *data);
void db_putc(int c);
int db_getc(void);
void cpu_interrupt_to_db(int cpu_no);
char *db_task_name(void);
int m88k_dmx_print(unsigned, unsigned, unsigned, unsigned);
void m88k_db_pause(unsigned);
void m88k_db_print_frame(db_expr_t, int, db_expr_t, char *);
void m88k_db_registers(db_expr_t, int, db_expr_t, char *);
void m88k_db_where(db_expr_t, int, db_expr_t, char *);
void m88k_db_frame_search(db_expr_t, int, db_expr_t, char *);
void m88k_db_iflush(db_expr_t, int, db_expr_t, char *);
void m88k_db_dflush(db_expr_t, int, db_expr_t, char *);
void m88k_db_peek(db_expr_t, int, db_expr_t, char *);
void m88k_db_noise(db_expr_t, int, db_expr_t, char *);
void m88k_db_translate(db_expr_t, int, db_expr_t, char *);
void m88k_db_cmmucfg(db_expr_t, int, db_expr_t, char *);
void m88k_db_prom_cmd(db_expr_t, int, db_expr_t, char *);
d921 1
a921 1
	return (char *)buffer;
@


1.4.6.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d45 1
a45 1
#include <machine/locore.h>
a46 4
#ifdef M88100
#include <machine/m88100.h>
#include <machine/m8820x.h>
#endif
a47 1
#include <ddb/db_access.h>
d55 3
a57 2
extern unsigned db_trace_get_val(vaddr_t, unsigned *);
extern int frame_is_sane(db_regs_t *, int);
d59 1
a59 1
void kdbprinttrap(int, int);
d61 6
a66 4
void m88k_db_trap(int, struct trapframe *);
int ddb_nmi_trap(int, db_regs_t *);
void ddb_error_trap(char *, db_regs_t *);
void db_putc(int);
d68 2
d84 7
a90 2
int 	db_active;
int 	db_noisy;
d99 1
a99 1
 * MC88100 RISC Microprocessor User's Manual Second Edition
a109 1
#ifdef M88100
d112 9
d122 1
a122 1
 * return 1 if the printing of the next stage should be suppressed
d128 1
a128 1
	static const unsigned addr_mod[16] = {
d132 1
a132 1
	static const char *mode[16]  = {
d134 1
a134 1
		".b", "?", "?" , "?" , ".h" , "?", "?", ""
d136 5
a140 5
	static const unsigned mask[16] = {
		0, 0xff, 0xff00, 0xffff,
		0xff0000, 0, 0, 0,
		0xff000000, 0, 0, 0,
		0xffff0000, 0, 0, 0xffffffff
d142 1
a142 1
	static const unsigned shift[16] = {
d144 1
a144 1
		24, 0, 0, 0, 16, 0, 0, 0
d146 1
a146 1
	int reg = DMT_DREGBITS(t);
d148 1
a148 1
	if (ISSET(t, DMT_LOCKBAR)) {
d150 1
a150 1
			  DMT_ENBITS(t) == 0x0f ? "" : ".bu", ISSET(t, DMT_DAS) ? "" : ".usr", reg,
d154 1
a154 1
		if (DMT_ENBITS(t) == 0xf) {
d156 2
a157 2
			if (ISSET(t, DMT_WRITE)) {
				if (ISSET(t, DMT_DOUB1) && no == 2)
d159 1
a159 1
						  ISSET(t, DMT_DAS) ? "" : ".usr", a);
d162 1
a162 1
						  ISSET(t, DMT_DAS) ? "" : ".usr", d, a);
d165 1
a165 1
				if (ISSET(t, DMT_DOUB1) && no == 2)
d167 1
a167 1
						  ISSET(t, DMT_DAS) ? "" : ".usr", reg, a, reg+1, a+4);
d170 1
a170 1
						  ISSET(t, DMT_DAS) ? "" : ".usr", reg, a);
d174 2
a175 2
			a += addr_mod[DMT_ENBITS(t)];
			if (ISSET(t, DMT_WRITE))
d177 2
a178 2
					  mode[DMT_ENBITS(t)], ISSET(t, DMT_DAS) ? "" : ".usr",
					  (d & mask[DMT_ENBITS(t)]) >> shift[DMT_ENBITS(t)], a);
d181 2
a182 3
				    mode[DMT_ENBITS(t)],
				    ISSET(t, DMT_SIGNED) ? "" : "u",
				    ISSET(t, DMT_DAS) ? "" : ".usr", reg, a);
a186 1
#endif	/* M88100 */
d195 1
a195 1
	struct trapframe *s = (struct trapframe *)addr;
d198 1
a198 3
#ifdef M88100
	int suppress1 = 0, suppress2 = 0;
#endif
d227 3
a229 3
	if (badwordaddr((vaddr_t)s) ||
	    badwordaddr((vaddr_t)(&((db_regs_t*)s)->fpit))) {
		db_printf("frame at %8p is unreadable\n", s);
d233 7
a239 2
	if (frame_is_sane((db_regs_t *)s, 0) == 0) {	/* see db_trace.c */
		if (force == 0)
d241 1
d244 1
a244 1
#define R(i) s->tf_r[i]
d258 4
a261 5
	db_printf("%cxip: 0x%08x ",
	    cputyp == CPU_88110 ? 'e' : 's', s->tf_sxip & ~3);
	db_find_xtrn_sym_and_offset((db_addr_t)IPMASK(s->tf_sxip),
	    &name, &offset);
	if (name != NULL && (unsigned)offset <= db_maxoff)
d265 5
a269 6
	if (s->tf_snip != s->tf_sxip + 4) {
		db_printf("%cnip: 0x%08x ",
		    cputyp == CPU_88110 ? 'e' : 's', s->tf_snip);
		db_find_xtrn_sym_and_offset((db_addr_t)IPMASK(s->tf_snip),
		    &name, &offset);
		if (name != NULL && (unsigned)offset <= db_maxoff)
d275 5
a279 5
		if (s->tf_sfip != s->tf_snip + 4) {
			db_printf("sfip: 0x%08x ", s->tf_sfip);
			db_find_xtrn_sym_and_offset((db_addr_t)IPMASK(s->tf_sfip),
			    &name, &offset);
			if (name != NULL && (unsigned)offset <= db_maxoff)
d285 1
a285 1
			  s->tf_fpsr, s->tf_fpcr, s->tf_fpecr);
d287 1
a287 1
			  s->tf_dsap, s->tf_duap, s->tf_dsr, s->tf_dlar, s->tf_dpar);
d289 1
a289 1
			  s->tf_isap, s->tf_iuap, s->tf_isr, s->tf_ilar, s->tf_ipar);
d292 2
a293 2
	db_printf("epsr: 0x%08x                current process: %p\n",
		  s->tf_epsr, curproc);
d295 1
a295 1
		  s->tf_vector, s->tf_mask);
d304 1
a304 1
	if (!(s->tf_vector <= 10 || (114 <= s->tf_vector && s->tf_vector <= 127))) {
a308 1
#ifdef M88100
d310 1
a310 1
		if (s->tf_vector == /*data*/3 || s->tf_dmt0 & DMT_VALID) {
d312 3
a314 3
			    s->tf_dmt0, s->tf_dmd0, s->tf_dma0);
			db_find_xtrn_sym_and_offset((db_addr_t)s->tf_dma0, &name, &offset);
			if (name != NULL && (unsigned)offset <= db_maxoff)
d317 1
a317 2

			suppress1 = m88k_dmx_print(s->tf_dmt0, s->tf_dmd0, s->tf_dma0, 0);
d320 1
a320 1
			if ((s->tf_dmt1 & DMT_VALID) && (!suppress1)) {
d322 4
a325 5
				    s->tf_dmt1, s->tf_dmd1, s->tf_dma1);
				db_find_xtrn_sym_and_offset((db_addr_t)s->tf_dma1,
				    &name, &offset);
				if (name != NULL &&
				    (unsigned)offset <= db_maxoff)
d328 1
a328 1
				suppress2 = m88k_dmx_print(s->tf_dmt1, s->tf_dmd1, s->tf_dma1, 1);
d331 1
a331 1
				if ((s->tf_dmt2 & DMT_VALID) && (!suppress2)) {
d333 2
a334 2
						  s->tf_dmt2, s->tf_dmd2, s->tf_dma2);
					db_find_xtrn_sym_and_offset((db_addr_t)s->tf_dma2,
d339 1
a339 1
					m88k_dmx_print(s->tf_dmt2, s->tf_dmd2, s->tf_dma2, 2);
a342 3

			db_printf("fault code %d\n",
			    CMMU_PFSR_FAULT(s->tf_dpfsr));
a344 1
#endif	/* M88100 */
d346 1
a346 1
	if (s->tf_fpecr & 255) { /* floating point error occurred */
d348 1
a348 2
			  s->tf_fpecr, s->tf_fpsr, s->tf_fpcr);
#ifdef M88100
d351 1
a351 1
				  s->tf_fphs1, s->tf_fpls1, s->tf_fphs2, s->tf_fpls2);
d353 1
a353 1
				  s->tf_fppt, s->tf_fprh, s->tf_fprl, s->tf_fpit);
a354 1
#endif
d363 1
a363 1
	db_expr_t count;
d369 4
d385 1
a385 3
 * m88k_db_trap - field a TRACE or BPT trap
 * Note that only the tf_regs part of the frame is valid - some ddb routines
 * invoke this function with a promoted struct reg!
d388 1
a388 1
m88k_db_trap(type, frame)
d390 1
a390 1
	struct trapframe *frame;
d392 6
d399 1
a399 1
	if (get_psr() & (1 << PSR_INTERRUPT_DISABLE_BIT))
d403 1
d417 3
a419 3

	ddb_regs = frame->tf_regs;

d426 5
a430 1
	frame->tf_regs = ddb_regs;
d433 2
a434 2
extern const char *trap_type[];
extern const int trap_types;
d442 1
a442 1
{
d445 2
a446 2
		printf("type %d", type);
	else
d449 1
a449 1
}
d464 2
a465 3
	if (db_noisy)
		db_printf("kernel: nmi interrupt\n");
	m88k_db_trap(T_KDB_ENTRY, (struct trapframe *)eframe);
d483 1
a483 1
	m88k_db_trap(type, (struct trapframe *)eframe);
d488 2
a489 2
		 * at the breakpoint address.  mc88110's exip reg
		 * already has the address of the exception instruction.
d506 1
a506 1
	m88k_db_trap(T_KDB_ENTRY, (struct trapframe *)eframe);
d517 1
a517 1
ddb_error_trap(error, regs)
d519 1
a519 1
	db_regs_t *regs;
d521 1
a521 1
	db_printf("KERNEL:  terminal error [%s]\n", error);
d523 2
a524 2
	db_printf("at 0x%x ", regs->sxip & XIP_ADDR);
	db_printf("dmt0 0x%x dma0 0x%x", regs->dmt0, regs->dma0);
d526 1
a526 1
	m88k_db_trap(T_KDB_BREAK, (struct trapframe *)regs);
d533 4
a536 1
db_read_bytes(db_addr_t addr, size_t size, char *data)
d538 1
a538 1
	char *src;
d542 1
a542 1
	while(size-- > 0) {
d554 8
a561 5
db_write_bytes(db_addr_t addr, size_t size, char *data)
{
	char *dst;
	paddr_t physaddr;
	psize_t psize = size;
d564 6
a569 3

	while (size-- > 0) {
		*dst++ = *data++;
d571 2
a572 3
	/* XXX test return value */
	pmap_extract(pmap_kernel(), (vaddr_t)addr, &physaddr);
	cmmu_flush_cache(cpu_number(), physaddr, psize);
d601 1
d603 4
a606 2
	db_expr_t offset;
	db_addr_t l;
d608 1
a608 1
	l = PC_REGS(DDB_REGS); /* clear low bits */
d610 1
a610 1
	db_find_xtrn_sym_and_offset(l, &name, &offset);
d612 1
a612 1
		db_printf("stopped at 0x%lx  (%s+0x%x)\n", l, name, offset);
d614 1
a614 1
		db_printf("stopped at 0x%lx\n", l);
d633 3
d643 4
a646 2
		if (frame_is_sane((db_regs_t *)addr, 1) != 0)
			db_printf("frame found at 0x%x\n", addr);
d651 1
d665 1
a665 1
#endif
d680 1
a680 1
#endif
d718 1
a718 1
#endif
d776 1
a776 1
				db_printf("bad modifier [%c]\n", c);
d820 5
d839 6
a844 5
struct db_command m88k_cache_cmds[] = {
	{ "iflush",	m88k_db_iflush,	0,	NULL },
	{ "dflush",	m88k_db_dflush,	0,	NULL },
	{ "peek",	m88k_db_peek,	0,	NULL },
	{ NULL,		NULL,		0,	NULL }
d847 12
a858 11
struct db_command db_machine_cmds[] = {
	{ "cache",	NULL,			0,	m88k_cache_cmds },
	{ "frame",	m88k_db_print_frame,	0,	NULL },
	{ "regs",	m88k_db_registers,	0,	NULL },
	{ "noise",	m88k_db_noise,		0,	NULL },
	{ "searchframe",m88k_db_frame_search,	0,	NULL },
	{ "translate",	m88k_db_translate,	0,	NULL },
	{ "cmmucfg",	m88k_db_cmmucfg,	0,	NULL },
	{ "where",	m88k_db_where,		0,	NULL },
	{ "prom",	m88k_db_prom_cmd,	0,	NULL },
	{ NULL,		NULL,			0,	NULL }
d861 3
d869 55
@


1.3
log
@Cleanup after import. This also seems to bring up the current version.
@
text
@d1 1
@


1.2
log
@This is a remove to get rid of the old mvme88k port which was incomplete
to replace it with a working version. The kernel compiles and works
at least.  The new version will be imported shortly.
@
text
@d35 1
a35 2
#include <sys/systm.h>		/* just for boothowto --eichin */
#include <setjmp.h>
d39 4
a42 4
#include <machine/m882xx.h>	/* CMMU defs		        */
#include <machine/trap.h>	/* current_thread()            */
#include <machine/db_machdep.h>	/* local ddb stuff             */
#include <machine/bug.h>	/* bug routines 		 */
d48 1
a48 1
extern jmp_buf *db_recover;
d51 3
a53 3
int     db_active = 0;
int     db_noisy = 0;
int     quiet_db_read_bytes = 0;
d59 1
a59 1
	register struct m88100_saved_state *regs;
d61 4
a64 4
	if (db_active == 0 && (boothowto & RB_KDB)) {
		printf("\n\nkernel: keyboard interrupt\n");
		m88k_db_trap(-1, regs);
	}
d66 1
d74 1
a74 1
	db_printf(str);
d80 1
a80 1
	db_printf(str, arg1);
d86 1
a86 1
	db_printf(str, arg1, arg2);
d88 1
d126 36
a161 42
	static unsigned addr_mod[16] = {0, 3, 2, 2, 1, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0};
	static char *mode[16] = {"?", ".b", ".b", ".h", ".b", "?", "?", "?",
	".b", ".h", "?", "?", "?", "?", "?", ""};
	static unsigned mask[16] = {0, 0xff, 0xff00, 0xffff,
		0xff0000, 0, 0, 0,
		0xff000000 U, 0xffff0000 U, 0, 0,
	0, 0, 0, 0xffffffff U};
	static unsigned shift[16] = {0, 0, 8, 0, 16, 0, 0, 0,
	24, 16, 0, 0, 0, 0, 0, 0};
	int     reg = REG(t);

	if (XMEM(t)) {
		db_printf("xmem%s%s r%d(0x%x) <-> mem(0x%x),",
		    XMEM_MODE(t), DAS(t), reg,
		    (((t) >> 2 & 0xf) == 0xf) ? d : (d & 0xff), a);
		return 1;
	} else {
		if (MODE(t) == 0xf) {
			/* full or double word */
			if (STORE(t))
				if (DOUB(t) && no == 2)
					db_printf("st.d%s -> mem(0x%x) (** restart sxip **)",
					    DAS(t), a);
				else
					db_printf("st%s (0x%x) -> mem(0x%x)", DAS(t), d, a);
			else	/* load */
				if (DOUB(t) && no == 2)
					db_printf("ld.d%s r%d <- mem(0x%x), r%d <- mem(0x%x)",
					    DAS(t), reg, a, reg + 1, a + 4);
				else
					db_printf("ld%s r%d <- mem(0x%x)", DAS(t), reg, a);
		} else {
			/* fractional word - check if load or store */
			a += addr_mod[MODE(t)];
			if (STORE(t))
				db_printf("st%s%s (0x%x) -> mem(0x%x)", mode[MODE(t)], DAS(t),
				    (d & mask[MODE(t)]) >> shift[MODE(t)], a);
			else
				db_printf("ld%s%s%s r%d <- mem(0x%x)",
				    mode[MODE(t)], SIGN(t) ? "" : "u", DAS(t), reg, a);
		}
d163 13
a175 1
	return 0;
d179 29
a207 11
m88k_db_print_frame(
    db_expr_t addr,
    boolean_t have_addr,
    int count,
    char *modif)
{
	struct m88100_saved_state *s = (struct m88100_saved_state *) addr;
	char   *name;
	db_expr_t offset;
	int     surpress1 = 0, surpress2 = 0;
	int     c, force = 0, help = 0;
d209 9
a217 18
	if (!have_addr) {
		db_printf("requires address of frame\n");
		help = 1;
	}
	while (modif && *modif) {
		switch (c = *modif++, c) {
		case 'f':
			force = 1;
			break;
		case 'h':
			help = 1;
			break;
		default:
			db_printf("unknown modifier [%c]\n", c);
			help = 1;
			break;
		}
	}
d219 5
a223 4
	if (help) {
		db_printf("usage: mach frame/[f] ADDRESS\n");
		db_printf("  /f force printing of insane frames.\n");
		return;
d225 1
a225 7
	if (badwordaddr((vm_offset_t) s) ||
	    badwordaddr((vm_offset_t) (&((db_regs_t *) s)->mode))) {
		db_printf("frame at 0x%08x is unreadable\n", s);
		return;
	}
	if (!frame_is_sane(s)) {/* see db_trace.c */
		db_printf("frame seems insane (");
a226 7
		if (force)
			db_printf("forging ahead anyway...)\n");
		else {
			db_printf("use /f to force)\n");
			return;
		}
	}
d229 23
a251 16
	db_printf("R00-05: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	    R(0), R(1), R(2), R(3), R(4), R(5));
	db_printf("R06-11: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	    R(6), R(7), R(8), R(9), R(10), R(11));
	db_printf("R12-17: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	    R(12), R(13), R(14), R(15), R(16), R(17));
	db_printf("R18-23: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	    R(18), R(19), R(20), R(21), R(22), R(23));
	db_printf("R24-29: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	    R(24), R(25), R(26), R(27), R(28), R(29));
	db_printf("R30-31: 0x%08x  0x%08x\n", R(30), R(31));

	db_printf("sxip: 0x%08x ", s->sxip);
	db_find_xtrn_sym_and_offset((db_addr_t) IPMASK(s->sxip), &name, &offset);
	if (name != 0 && (unsigned) offset <= db_maxoff)
		db_printf("%s+0x%08x", name, (unsigned) offset);
d253 56
a308 12
	if (s->snip != s->sxip + 4) {
		db_printf("snip: 0x%08x ", s->snip);
		db_find_xtrn_sym_and_offset((db_addr_t) IPMASK(s->snip), &name, &offset);
		if (name != 0 && (unsigned) offset <= db_maxoff)
			db_printf("%s+0x%08x", name, (unsigned) offset);
		db_printf("\n");
	}
	if (s->sfip != s->snip + 4) {
		db_printf("sfip: 0x%08x ", s->sfip);
		db_find_xtrn_sym_and_offset((db_addr_t) IPMASK(s->sfip), &name, &offset);
		if (name != 0 && (unsigned) offset <= db_maxoff)
			db_printf("%s+0x%08x", name, (unsigned) offset);
d310 1
d312 1
a312 24
	db_printf("vector: 0x%02x                    interrupt mask: 0x%08x\n",
	    s->vector, s->mask >> 8);
	db_printf("epsr: 0x%08x                current process: 0x%x\n",
	    s->epsr, curproc);

	/*
         * If the vector indicates trap, instead of an exception or
         * interrupt, skip the check of dmt and fp regs.
         *
         * Interrupt and exceptions are vectored at 0-10 and 114-127.
         */

	if (!(s->vector <= 10 || (114 <= s->vector && s->vector <= 127))) {
		db_printf("\n\n");
		return;
	}
	if (s->vector == /* data */ 3 || s->dmt0 & 1) {
		db_printf("dmt,d,a0: 0x%08x  0x%08x  0x%08x ", s->dmt0, s->dmd0, s->dma0);
		db_find_xtrn_sym_and_offset((db_addr_t) s->dma0, &name, &offset);
		if (name != 0 && (unsigned) offset <= db_maxoff)
			db_printf("%s+0x%08x", name, (unsigned) offset);
		db_printf("\n          ");
		surpress1 = m88k_dmx_print(s->dmt0 | 0x01, s->dmd0, s->dma0, 0);
		db_printf("\n");
d314 10
a323 29
		if ((s->dmt1 & 1) && (!surpress1)) {
			db_printf("dmt,d,a1: 0x%08x  0x%08x  0x%08x ", s->dmt1, s->dmd1, s->dma1);
			db_find_xtrn_sym_and_offset((db_addr_t) s->dma1, &name, &offset);
			if (name != 0 && (unsigned) offset <= db_maxoff)
				db_printf("%s+0x%08x", name, (unsigned) offset);
			db_printf("\n          ");
			surpress2 = m88k_dmx_print(s->dmt1, s->dmd1, s->dma1, 1);
			db_printf("\n");

			if ((s->dmt2 & 1) && (!surpress2)) {
				db_printf("dmt,d,a2: 0x%08x  0x%08x  0x%08x ", s->dmt2, s->dmd2, s->dma2);
				db_find_xtrn_sym_and_offset((db_addr_t) s->dma2, &name, &offset);
				if (name != 0 && (unsigned) offset <= db_maxoff)
					db_printf("%s+0x%08x", name, (unsigned) offset);
				db_printf("\n          ");
				(void) m88k_dmx_print(s->dmt2, s->dmd2, s->dma2, 2);
				db_printf("\n");
			}
		}
	}
	if (s->fpecr & 255) {	/* floating point error occured */
		db_printf("fpecr: 0x%08x fpsr: 0x%08x fpcr: 0x%08x\n",
		    s->fpecr, s->fpsr, s->fpcr);
		db_printf("fcr1-4: 0x%08x  0x%08x  0x%08x  0x%08x\n",
		    s->fphs1, s->fpls1, s->fphs2, s->fpls2);
		db_printf("fcr5-8: 0x%08x  0x%08x  0x%08x  0x%08x\n",
		    s->fppt, s->fprh, s->fprl, s->fpit);
	}
	db_printf("\n\n");
d327 4
a330 11
m88k_db_registers(
    db_expr_t addr,
    boolean_t have_addr,
    int count,
    char *modif)
{
	if (modif && *modif) {
		db_printf("usage: mach regs\n");
		return;
	}
	m88k_db_print_frame((db_expr_t) DDB_REGS, TRUE, 0, 0);
d332 4
d337 1
d348 3
a350 3
	while (ticks)
		ticks -= 1;
	return;
d352 1
d359 1
a359 1
    register struct m88100_saved_state * regs)
d362 1
a362 1
	int     i;
d365 30
a394 30
	if ((i = db_spl()) != 7)
		m88k_db_str1("WARNING: spl is not high in m88k_db_trap (spl=%x)\n", i);
#endif				/* 0 */

	if (db_are_interrupts_disabled())
		m88k_db_str("WARNING: entered debugger with interrupts disabled\n");

	switch (type) {

	case T_KDB_BREAK:
	case T_KDB_TRACE:
	case T_KDB_ENTRY:
		break;
	case -1:
		break;
	default:
		kdbprinttrap(type, 0);
		if (db_recover != 0) {
			db_error("Caught exception in ddb.\n");
			/* NOTREACHED */
		}
	}

	ddb_regs = *regs;

	db_active++;
	cnpollc(TRUE);
	db_trap(type, 0);
	cnpollc(FALSE);
	db_active--;
d396 1
a396 1
	*regs = ddb_regs;
d399 1
a399 1
	(void) spl7();
d401 1
a401 1
	return (1);
d411 1
a411 1
	int     type, code;
d421 2
a422 2
int
Debugger()
d424 2
a425 2
	asm(ENTRY_ASM);		/* entry trap */
	/* ends up at ddb_entry_trap below */
d432 2
a433 2
	asm(ENTRY_ASM);		/* entry trap */
	/* ends up at ddb_entry_trap below */
d438 1
a438 1
ddb_nmi_trap(int level, db_regs_t * eframe)
d440 4
a443 3
	NOISY(m88k_db_str("kernel: nmi interrupt\n");)
	    m88k_db_trap(T_KDB_ENTRY, eframe);
	return 0;
d455 12
a466 13
ddb_break_trap(type, eframe)
	int type;
	db_regs_t *eframe;
{
	m88k_db_trap(type, eframe);

	if (type == T_KDB_BREAK) {
		/* back up an instruction and retry the instruction at the
		 * breakpoint address */
		eframe->sfip = eframe->snip;
		eframe->snip = eframe->sxip;
	}
	return 0;
d471 1
a471 3
ddb_entry_trap(level, eframe)
	int level;
	db_regs_t *eframe;
d473 3
a475 2
	m88k_db_trap(T_KDB_ENTRY, eframe);
	return 0;
d484 9
a492 10
ddb_error_trap(error, eframe)
	char *error;
	db_regs_t *eframe;
{
	m88k_db_str1("KERNEL:  terminal error [%s]\n", (int) error);
	m88k_db_str("KERNEL:  Exiting debugger will cause abort to rom\n");
	m88k_db_str1("at 0x%x ", eframe->sxip & ~3);
	m88k_db_str2("dmt0 0x%x dma0 0x%x", eframe->dmt0, eframe->dma0);
	m88k_db_pause(1000000);
	m88k_db_trap(T_KDB_BREAK, eframe);
d500 3
a502 3
	vm_offset_t addr;
	register int size;
	register char *data;
d504 1
a504 1
	register char *src;
d506 1
a506 1
	src = (char *) addr;
d508 3
a510 2
	while (--size >= 0)
		*data++ = *src++;
d520 1
a520 4
db_write_bytes(addr, size, data)
	char *addr;
	int size;
	char *data;
d523 4
a526 6
	register char *dst;
	int     i = size;
	vm_offset_t physaddr;
	pte_template_t *pte;

	dst = (char *) addr;
d528 3
a530 1
	while (--size >= 0) {
d532 6
a537 6
		db_printf("byte %x\n", *data);
#endif				/* 0 */
		*dst++ = *data++;
	}
	physaddr = pmap_extract(kernel_pmap, (vm_offset_t) addr);
	cmmu_flush_cache(physaddr, i);
d544 1
a544 1
	bugoutchr(c & 0xff);
d551 4
a554 4
	if (buginstat())
		return (buginchr());
	else
		return -1;
d559 1
a559 1
m88k_db_where(void)
d561 16
a576 16
	struct m88100_saved_state *s;
	char   *name;
	int    *offset;
	int     i;
	int     l;

	s = DDB_REGS;

	l = m88k_pc(s);		/* clear low bits */

	db_find_xtrn_sym_and_offset((db_addr_t) l, &name, (db_expr_t *) & offset);
	if (name && (unsigned) offset <= db_maxoff)
		db_printf("stopped at 0x%x  (%s+0x%x)\n",
		    l, name, offset);
	else
		db_printf("stopped at 0x%x\n", l);
d589 1
a589 1
m88k_db_frame_search(db_expr_t addr, boolean_t have_addr)
d592 1
a592 1
	db_printf("sorry, frame search currently disabled.\n");
d594 14
a607 13
	if (have_addr)
		addr &= ~3;	/* round to word */
	else
		addr = (DDB_REGS->r[31]);

	/* walk back up stack until 8k boundry, looking for 0 */
	while (addr & ((8 * 1024) - 1)) {
		int     i;
		db_read_bytes(addr, 4, &i);
		if (i == 0 && frame_is_sane(i))
			db_printf("frame found at 0x%x\n", i);
		addr += 4;
	}
d609 1
a609 1
	db_printf("(Walked back until 0x%x)\n", addr);
d612 1
d615 1
a615 1
m88k_db_iflush(db_expr_t addr, boolean_t have_addr)
d617 2
a618 2
	addr = 0;
	cmmu_remote_set(addr, CMMU_SCR, 0, CMMU_FLUSH_CACHE_CBI_ALL);
d620 1
d624 1
a624 1
m88k_db_dflush(db_expr_t addr, boolean_t have_addr)
d626 1
a626 1
	addr = 0;
d628 1
a628 1
	cmmu_remote_set(addr, CMMU_SCR, 1, CMMU_FLUSH_CACHE_CBI_ALL);
d630 1
d633 28
a660 32
m88k_db_peek(
    db_expr_t addr,
    boolean_t have_addr,
    int count,
    char *modif)
{
	int     pa12;
	int     valmask;

	pa12 = addr & ~((1 << 12) - 1);

	/* probe dcache */
	cmmu_remote_set(0, CMMU_SAR, 1, addr);

	valmask = cmmu_remote_get(0, CMMU_CSSP, 1);
	db_printf("dcache valmask 0x%x\n", (unsigned) valmask);
	db_printf("dcache tag ports 0x%x 0x%x 0x%x 0x%x\n",
	    (unsigned) cmmu_remote_get(0, CMMU_CTP0, 1),
	    (unsigned) cmmu_remote_get(0, CMMU_CTP1, 1),
	    (unsigned) cmmu_remote_get(0, CMMU_CTP2, 1),
	    (unsigned) cmmu_remote_get(0, CMMU_CTP3, 1));

	/* probe icache */
	cmmu_remote_set(0, CMMU_SAR, 0, addr);

	valmask = cmmu_remote_get(0, CMMU_CSSP, 0);
	db_printf("icache valmask 0x%x\n", (unsigned) valmask);
	db_printf("icache tag ports 0x%x 0x%x 0x%x 0x%x\n",
	    (unsigned) cmmu_remote_get(0, CMMU_CTP0, 0),
	    (unsigned) cmmu_remote_get(0, CMMU_CTP1, 0),
	    (unsigned) cmmu_remote_get(0, CMMU_CTP2, 0),
	    (unsigned) cmmu_remote_get(0, CMMU_CTP3, 0));
d669 1
a669 1
m88k_db_noise(db_expr_t addr, boolean_t have_addr)
d671 27
a697 21
	if (!have_addr) {
		/* if off make noisy; if noisy or very noisy turn off */
		if (db_noisy) {
			db_printf("changing debugger status from %s to quiet\n",
			    db_noisy == 1 ? "noisy" :
			    db_noisy == 2 ? "very noisy" : "violent");
			db_noisy = 0;
		} else {
			db_printf("changing debugger status from quiet to noisy\n");
			db_noisy = 1;
		}
	} else
		if (addr < 0 || addr > 3)
			db_printf("invalid noise level to m88k_db_noisy; should be 0, 1, 2, or 3\n");
		else {
			db_noisy = addr;
			db_printf("debugger noise level set to %s\n",
			    db_noisy == 0 ? "quiet" :
			    (db_noisy == 1 ? "noisy" :
				db_noisy == 2 ? "very noisy" : "violent"));
		}
d699 1
d705 1
a705 5
m88k_db_translate(
    db_expr_t addr,
    boolean_t have_addr,
    unsigned count,
    char *modif)
d708 15
a722 6
	char    c;
	int     verbose_flag = 0;
	int     supervisor_flag = 1;
	int     wanthelp = 0;

	if (!have_addr)
d724 11
a734 21
	else {
		while (c = *modif++, c != 0) {
			switch (c) {
			default:
				db_printf("bad modifier [%c]\n", c);
				wanthelp = 1;
				break;
			case 'h':
				wanthelp = 1;
				break;
			case 'v':
				verbose_flag++;
				break;
			case 's':
				supervisor_flag = 1;
				break;
			case 'u':
				supervisor_flag = 0;
				break;
			}
		}
d736 11
a746 9
	if (wanthelp) {
		db_printf("usage: translate[/vvsu] address\n");
		db_printf("flags: v - be verbose (vv - be very verbose)\n");
		db_printf("       s - use cmmu's supervisor area pointer (default)\n");
		db_printf("       u - use cmmu's user area pointer\n");
		return;
	}
	cmmu_show_translation(addr, supervisor_flag, verbose_flag);
#endif				/* 0 */
d749 2
a750 4
void 
cpu_interrupt_to_db(int cpu_no)
{
}
d759 4
a762 4
	{"iflush", m88k_db_iflush, 0, 0},
	{"dflush", m88k_db_dflush, 0, 0},
	{"peek", m88k_db_peek, 0, 0},
	{(char *) 0,}
d767 8
a774 8
	{"cache", 0, 0, m88k_cache_cmds},
	{"frame", m88k_db_print_frame, 0, 0},
	{"noise", m88k_db_noise, 0, 0},
	{"regs", m88k_db_registers, 0, 0},
	{"searchframe", m88k_db_frame_search, 0, 0},
	{"translate", m88k_db_translate, 0, 0},
	{"where", m88k_db_where, 0, 0},
	{(char *) 0,}
d776 1
d784 1
a784 1
	db_machine_commands_install(db_machine_cmds);
d786 1
a786 1
	ddb_init();
d788 1
a788 1
	db_printf("ddb enabled\n");
d790 1
d801 1
a801 2
       *
db_task_name()
d803 45
a847 43
	static unsigned buffer[(DB_TASK_NAME_LEN + 5) / sizeof(unsigned)];
	unsigned ptr = (vm_offset_t) (TOP_OF_USER_STACK - 4);
	unsigned limit = ptr - MAX_DISTANCE_TO_LOOK;
	unsigned word;
	int     i;

	/* skip zeros at the end */
	while (ptr > limit &&
	    (i = db_trace_get_val((vm_offset_t) ptr, &word))
	    && (word == 0)) {
		ptr -= 4;	/* continue looking for a non-null word */
	}

	if (ptr <= limit) {
		db_printf("bad name at line %d\n", __LINE__);
		return "<couldn't find 1>";
	} else
		if (i != 1) {
			return "<nostack>";
		}
	/* skip looking for null before all the text */
	while (ptr > limit
	    && (i = db_trace_get_val(ptr, &word))
	    && (word != 0)) {
		ptr -= 4;	/* continue looking for a null word */
	}

	if (ptr <= limit) {
		db_printf("bad name at line %d\n", __LINE__);
		return "<couldn't find 2>";
	} else
		if (i != 1) {
			db_printf("bad name read of %x "
			    "at line %d\n", ptr, __LINE__);
			return "<bad read 2>";
		}
	ptr += 4;		/* go back to the non-null word after this one */

	for (i = 0; i < sizeof(buffer); i++, ptr += 4) {
		buffer[i] = 0;	/* just in case it's not read */
		db_trace_get_val((vm_offset_t) ptr, &buffer[i]);
	}
	return (char *) buffer;
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@initial 88k import; code by nivas and based on mach luna88k
@
text
@@


1.1.1.2
log
@Third try at importing the mvme88k port. This is a working kernel
from nivas.
Userland and compiler still need to be worked on.
Make certain what directory the import is done from.
@
text
@d35 2
a36 1
#include <sys/systm.h> /* just for boothowto --eichin */
d40 4
a43 4
#include <machine/m882xx.h>		 /* CMMU defs		        */
#include <machine/trap.h>		 /* current_thread()            */
#include <machine/db_machdep.h>		 /* local ddb stuff             */
#include <machine/bug.h>		 /* bug routines 		*/
d49 1
a49 1
extern label_t *db_recover;
d52 3
a54 3
int 	db_active = 0;
int 	db_noisy = 0;
int	quiet_db_read_bytes = 0;
d60 1
a60 1
        register struct m88100_saved_state *regs;
d62 4
a65 4
        if (db_active == 0 && (boothowto & RB_KDB)) {
                printf("\n\nkernel: keyboard interrupt\n");
                m88k_db_trap(-1, regs);
        }
a66 1

d74 1
a74 1
    db_printf(str);
d80 1
a80 1
    db_printf(str, arg1);
d86 1
a86 1
    db_printf(str, arg1, arg2);
a87 1

d125 42
a166 36
    static unsigned addr_mod[16] = { 0, 3, 2, 2, 1, 0, 0, 0,
				     0, 0, 0, 0, 0, 0, 0, 0};
    static char *mode[16]  = { "?", ".b", ".b", ".h", ".b", "?", "?", "?",
			      ".b", ".h", "?" , "?" , "?" , "?", "?", ""};
    static unsigned mask[16] = { 0,           0xff,        0xff00,     0xffff,
				 0xff0000,    0,           0,          0,
				 0xff000000U, 0xffff0000U, 0,          0,
				 0,           0,           0,    0xffffffffU};
    static unsigned shift[16] = { 0,  0, 8, 0, 16, 0, 0, 0,
				 24, 16, 0, 0,  0, 0, 0, 0};
    int reg = REG(t);

    if (XMEM(t))
    {
	db_printf("xmem%s%s r%d(0x%x) <-> mem(0x%x),",
	    XMEM_MODE(t), DAS(t), reg,
	    (((t)>>2 & 0xf) == 0xf) ? d : (d & 0xff), a );
	return 1;
    }
    else
    {
	if (MODE(t) == 0xf)
	{
	    /* full or double word */
	    if (STORE(t))
		if (DOUB(t) && no == 2)
		    db_printf("st.d%s -> mem(0x%x) (** restart sxip **)",
			DAS(t), a);
		else
		    db_printf("st%s (0x%x) -> mem(0x%x)", DAS(t), d, a);
	    else /* load */
		if (DOUB(t) && no == 2)
		    db_printf("ld.d%s r%d <- mem(0x%x), r%d <- mem(0x%x)",
			DAS(t), reg, a, reg+1, a+4);
		else
		    db_printf("ld%s r%d <- mem(0x%x)",  DAS(t), reg, a);
d168 1
a168 13
	else
	{
	    /* fractional word - check if load or store */
	    a += addr_mod[MODE(t)];
	    if (STORE(t))
		db_printf("st%s%s (0x%x) -> mem(0x%x)", mode[MODE(t)], DAS(t),
		(d & mask[MODE(t)]) >> shift[MODE(t)], a);
	    else
		db_printf("ld%s%s%s r%d <- mem(0x%x)",
		mode[MODE(t)], SIGN(t) ? "" : "u", DAS(t), reg, a);
	}
    }
    return 0;
d172 11
a182 29
m88k_db_print_frame(db_expr_t addr, int have_addr, int count, char *modif)
{
    struct m88100_saved_state *s = (struct m88100_saved_state *)addr;
    char *name;
    db_expr_t offset;
    int surpress1 = 0, surpress2 = 0;
    int c, force = 0, help = 0;

    if (!have_addr) {
	db_printf("requires address of frame\n");
	help = 1;
    }

    while (modif && *modif) {
   	switch (c = *modif++, c) {
	case 'f': force = 1; break;
	case 'h': help = 1; break;
        default:
	    db_printf("unknown modifier [%c]\n", c);
	    help = 1;
	    break;
    	}
    }

    if (help) {
	db_printf("usage: mach frame/[f] ADDRESS\n");
	db_printf("  /f force printing of insane frames.\n");
	return;
    }
d184 18
a201 9
    if (badwordaddr((vm_offset_t)s) ||
	badwordaddr((vm_offset_t)(&((db_regs_t*)s)->mode))) {
	    db_printf("frame at 0x%08x is unreadable\n", s);
	    return;
    }

    if (!frame_is_sane(s))  /* see db_trace.c */
    {
	db_printf("frame seems insane (");
d203 9
a211 5
	if (force)
	    db_printf("forging ahead anyway...)\n");
	else {
	    db_printf("use /f to force)\n");
	    return;
d213 2
a214 1
    }
d216 7
d225 16
a240 23
    db_printf("R00-05: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	R(0),R(1),R(2),R(3),R(4),R(5));
    db_printf("R06-11: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	R(6),R(7),R(8),R(9),R(10),R(11));
    db_printf("R12-17: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	R(12),R(13),R(14),R(15),R(16),R(17));
    db_printf("R18-23: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	R(18),R(19),R(20),R(21),R(22),R(23));
    db_printf("R24-29: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	R(24),R(25),R(26),R(27),R(28),R(29));
    db_printf("R30-31: 0x%08x  0x%08x\n",R(30),R(31));

    db_printf("sxip: 0x%08x ",s->sxip & ~3);
    db_find_xtrn_sym_and_offset((db_addr_t) IPMASK(s->sxip),&name,&offset);
    if (name!= 0 && (unsigned)offset <= db_maxoff)
	db_printf("%s+0x%08x",name,(unsigned)offset);
    db_printf("\n");
    if (s->snip != s->sxip+4)
    {
	db_printf("snip: 0x%08x ",s->snip);
	db_find_xtrn_sym_and_offset((db_addr_t) IPMASK(s->snip),&name,&offset);
	if (name!= 0 && (unsigned)offset <= db_maxoff)
	    db_printf("%s+0x%08x",name,(unsigned)offset);
d242 35
a276 54
    }
    if (s->sfip != s->snip+4)
    {
	db_printf("sfip: 0x%08x ",s->sfip);
	db_find_xtrn_sym_and_offset((db_addr_t) IPMASK(s->sfip),&name,&offset);
	if (name!= 0 && (unsigned)offset <= db_maxoff)
	    db_printf("%s+0x%08x",name,(unsigned)offset);
	db_printf("\n");
    }

    db_printf("vector: 0x%02x                    interrupt mask: 0x%08x\n",
	s->vector, s->mask);
    db_printf("epsr: 0x%08x                current process: 0x%x\n",
	s->epsr, curproc);

    /*
     * If the vector indicates trap, instead of an exception or
     * interrupt, skip the check of dmt and fp regs.
     *
     * Interrupt and exceptions are vectored at 0-10 and 114-127.
     */

    if (!(s->vector <= 10 || (114 <= s->vector && s->vector <= 127)))
    {
	db_printf("\n\n");
	return;
    }

    if (s->vector == /*data*/3 || s->dmt0 & 1)
    {
	db_printf("dmt,d,a0: 0x%08x  0x%08x  0x%08x ",s->dmt0,s->dmd0,s->dma0);
	db_find_xtrn_sym_and_offset((db_addr_t) s->dma0,&name,&offset);
	if (name!= 0 && (unsigned)offset <= db_maxoff)
	    db_printf("%s+0x%08x",name,(unsigned)offset);
	db_printf("\n          ");
	surpress1 = m88k_dmx_print(s->dmt0|0x01, s->dmd0, s->dma0, 0);
	db_printf("\n");

	if ((s->dmt1 & 1) && (!surpress1))
	{
	    db_printf("dmt,d,a1: 0x%08x  0x%08x  0x%08x ",s->dmt1, s->dmd1,s->dma1);
	    db_find_xtrn_sym_and_offset((db_addr_t) s->dma1,&name,&offset);
	    if (name!= 0 && (unsigned)offset <= db_maxoff)
		db_printf("%s+0x%08x",name,(unsigned)offset);
	    db_printf("\n          ");
	    surpress2 = m88k_dmx_print(s->dmt1, s->dmd1, s->dma1, 1);
	    db_printf("\n");

	    if ((s->dmt2 & 1) && (!surpress2))
	    {
		db_printf("dmt,d,a2: 0x%08x  0x%08x  0x%08x ",s->dmt2, s->dmd2,s->dma2);
		db_find_xtrn_sym_and_offset((db_addr_t) s->dma2,&name,&offset);
		if (name!= 0 && (unsigned)offset <= db_maxoff)
		    db_printf("%s+0x%08x",name,(unsigned)offset);
d278 1
a278 1
		(void) m88k_dmx_print(s->dmt2, s->dmd2, s->dma2, 2);
d280 20
a299 1
	    }
d301 9
a309 12
    }

    if (s->fpecr & 255) /* floating point error occured */
    {
	db_printf("fpecr: 0x%08x fpsr: 0x%08x fpcr: 0x%08x\n",
	    s->fpecr,s->fpsr,s->fpcr);
	db_printf("fcr1-4: 0x%08x  0x%08x  0x%08x  0x%08x\n",
	    s->fphs1, s->fpls1, s->fphs2, s->fpls2);
	db_printf("fcr5-8: 0x%08x  0x%08x  0x%08x  0x%08x\n",
	    s->fppt,  s->fprh,  s->fprl,  s->fpit);
    }
    db_printf("\n\n");
d313 11
a323 4
m88k_db_registers(db_expr_t addr, int have_addr, int count, char *modif)
{
    if (modif && *modif) {
	db_printf("usage: mach regs\n");
a324 4
    }

    m88k_db_print_frame((db_expr_t)DDB_REGS, TRUE,0,0);
    return;
a325 1

d336 3
a338 3
    while (ticks)
	ticks -= 1;
    return;
a339 1

d346 1
a346 1
    register struct m88100_saved_state *regs)
d349 1
a349 1
    int i;
d352 30
a381 30
    if ((i = db_spl()) != 7)
	m88k_db_str1("WARNING: spl is not high in m88k_db_trap (spl=%x)\n", i);
#endif /* 0 */

    if (db_are_interrupts_disabled())
	m88k_db_str("WARNING: entered debugger with interrupts disabled\n");

    switch(type) {
    
    case T_KDB_BREAK:
    case T_KDB_TRACE:
    case T_KDB_ENTRY:
    	break;
    case -1:
    	break;
    default:
    	kdbprinttrap(type, 0);
    	if (db_recover != 0) {
    		db_error("Caught exception in ddb.\n");
    		/*NOTREACHED*/
    	}
    }
    
    ddb_regs = *regs;
    
    db_active++;
    cnpollc(TRUE);
    db_trap(type, 0);
    cnpollc(FALSE);
    db_active--;
d383 1
a383 1
    *regs = ddb_regs;
d386 1
a386 1
    (void) spl7();
d388 1
a388 1
    return(1);
d398 1
a398 1
	int	type, code;
d408 2
a409 2
void
Debugger(void)
d411 2
a412 2
    asm (ENTRY_ASM); /* entry trap */
    /* ends up at ddb_entry_trap below */
d419 2
a420 2
    asm (ENTRY_ASM); /* entry trap */
    /* ends up at ddb_entry_trap below */
d425 1
a425 1
ddb_nmi_trap(int level, db_regs_t *eframe)
d427 3
a429 4
    NOISY(m88k_db_str("kernel: nmi interrupt\n");)
    m88k_db_trap(T_KDB_ENTRY, eframe);

    return 0;
d441 13
a453 12
ddb_break_trap(int type, db_regs_t *eframe)
{
    m88k_db_trap(type, eframe);

    if (type == T_KDB_BREAK) {
	/* back up an instruction and retry the instruction at the
	   breakpoint address */
	eframe->sfip = eframe->snip;
	eframe->snip = eframe->sxip;
    }

    return 0;
d458 3
a460 1
ddb_entry_trap(int level, db_regs_t *eframe)
d462 2
a463 3
    m88k_db_trap(T_KDB_ENTRY, eframe);

    return 0;
d472 10
a481 9
ddb_error_trap(char *error, db_regs_t *eframe)
{

    m88k_db_str1("KERNEL:  terminal error [%s]\n",(int)error);
    m88k_db_str ("KERNEL:  Exiting debugger will cause abort to rom\n");
    m88k_db_str1("at 0x%x ", eframe->sxip & ~3);
    m88k_db_str2("dmt0 0x%x dma0 0x%x", eframe->dmt0, eframe->dma0);
    m88k_db_pause(1000000);
    m88k_db_trap(T_KDB_BREAK, eframe);
d489 3
a491 3
	vm_offset_t     addr;
	register int    size;
	register char   *data;
d493 1
a493 1
    register char	*src;
d495 1
a495 1
    src = (char *)addr;
d497 2
a498 3
    while(--size >= 0) {
	*data++ = *src++;
    }
d508 4
a511 1
db_write_bytes(char *addr, int size, char *data)
d514 6
a519 4
    register char	*dst;
    int i = size;
    vm_offset_t physaddr;
    pte_template_t 	*pte;
d521 1
a521 3
    dst = (char *)addr;
	
    while(--size >= 0) {
d523 6
a528 6
    	db_printf("byte %x\n", *data);
#endif /* 0 */
	*dst++ = *data++;    
    }
    physaddr = pmap_extract(kernel_pmap, (vm_offset_t)addr);
    cmmu_flush_cache(physaddr, i); 
d535 1
a535 1
    bugoutchr(c & 0xff);
d542 4
a545 4
    if (buginstat())
	return (buginchr());
    else
	return -1;
d550 1
a550 1
m88k_db_where(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
d552 16
a567 16
    struct m88100_saved_state *s;
    char *name;
    int *offset;
    int i;
    int l;

    s = DDB_REGS;

    l = m88k_pc(s); /* clear low bits */

    db_find_xtrn_sym_and_offset((db_addr_t) l,&name, (db_expr_t*)&offset);
    if (name && (unsigned)offset <= db_maxoff)
	db_printf("stopped at 0x%x  (%s+0x%x)\n",
	    l, name, offset);
    else
	db_printf("stopped at 0x%x\n", l);
d580 1
a580 1
m88k_db_frame_search(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
d583 1
a583 1
    db_printf("sorry, frame search currently disabled.\n");
d585 13
a597 14
    if (have_addr)
	addr &= ~3; /* round to word */
    else
	addr = (DDB_REGS -> r[31]);

    /* walk back up stack until 8k boundry, looking for 0 */
    while (addr & ((8*1024)-1))
    {
	int i;
	db_read_bytes(addr, 4, &i);
	if (i == 0 && frame_is_sane(i))
	    db_printf("frame found at 0x%x\n", i);
	addr += 4;
    }
d599 1
a599 1
    db_printf("(Walked back until 0x%x)\n",addr);
a601 1

d604 1
a604 1
m88k_db_iflush(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
d606 2
a607 2
    addr = 0;
    cmmu_remote_set(addr, CMMU_SCR, 0, CMMU_FLUSH_CACHE_CBI_ALL);
a608 1

d612 1
a612 1
m88k_db_dflush(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
d614 1
a614 1
    addr = 0;
d616 1
a616 1
    cmmu_remote_set(addr, CMMU_SCR, 1, CMMU_FLUSH_CACHE_CBI_ALL);
a617 1

d620 32
a651 28
m88k_db_peek(db_expr_t addr, int have_addr, int count, char *modif)
{
    int pa12;
    int valmask;

    pa12 = addr & ~((1<<12) -1);

    /* probe dcache */
    cmmu_remote_set(0, CMMU_SAR, 1, addr);

    valmask = cmmu_remote_get(0, CMMU_CSSP, 1);
    db_printf("dcache valmask 0x%x\n", (unsigned)valmask);
    db_printf("dcache tag ports 0x%x 0x%x 0x%x 0x%x\n",
    (unsigned)cmmu_remote_get(0, CMMU_CTP0, 1),
    (unsigned)cmmu_remote_get(0, CMMU_CTP1, 1),
    (unsigned)cmmu_remote_get(0, CMMU_CTP2, 1),
    (unsigned)cmmu_remote_get(0, CMMU_CTP3, 1));

    /* probe icache */
    cmmu_remote_set(0, CMMU_SAR, 0, addr);

    valmask = cmmu_remote_get(0, CMMU_CSSP, 0);
    db_printf("icache valmask 0x%x\n", (unsigned)valmask);
    db_printf("icache tag ports 0x%x 0x%x 0x%x 0x%x\n",
    (unsigned)cmmu_remote_get(0, CMMU_CTP0, 0),
    (unsigned)cmmu_remote_get(0, CMMU_CTP1, 0),
    (unsigned)cmmu_remote_get(0, CMMU_CTP2, 0),
    (unsigned)cmmu_remote_get(0, CMMU_CTP3, 0));
d660 1
a660 1
m88k_db_noise(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
d662 21
a682 27
    if (!have_addr)
    {
	/* if off make noisy; if noisy or very noisy turn off */
	if (db_noisy)
	{
	    db_printf("changing debugger status from %s to quiet\n",
		db_noisy == 1 ? "noisy" :
		db_noisy == 2 ? "very noisy" : "violent");
	    db_noisy = 0;
	}
	else
	{
	    db_printf("changing debugger status from quiet to noisy\n");
	    db_noisy = 1;
	}
    }
    else
	if (addr < 0 || addr > 3)
	    db_printf("invalid noise level to m88k_db_noisy; should be 0, 1, 2, or 3\n");
	else
	{
	    db_noisy = addr;
	    db_printf("debugger noise level set to %s\n",
		db_noisy == 0 ? "quiet" :
		(db_noisy == 1 ? "noisy" :
		db_noisy==2 ? "very noisy" : "violent"));
	}
a683 1

d689 5
a693 1
m88k_db_translate(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
d696 6
a701 12
    char c;
    int verbose_flag = 0;
    int supervisor_flag = 1;
    int wanthelp = 0;

    if (!have_addr)
	wanthelp = 1;
    else {
        while (c = *modif++, c != 0) {
	    switch (c) {
            default:
		db_printf("bad modifier [%c]\n", c); 
d703 28
a730 14
		break;
            case 'h':
		wanthelp = 1;
		break;
            case 'v':
		verbose_flag++;
		break;
            case 's':
		supervisor_flag = 1;
		break;
            case 'u':
		supervisor_flag = 0;
		break;
    	    }
d732 3
a734 8
    }
    if (wanthelp) {
	db_printf("usage: translate[/vvsu] address\n");
	db_printf("flags: v - be verbose (vv - be very verbose)\n");
	db_printf("       s - use cmmu's supervisor area pointer (default)\n");
	db_printf("       u - use cmmu's user area pointer\n");
	return;
    }
d736 3
a738 2
    cmmu_show_translation(addr, supervisor_flag, verbose_flag);
#endif /* 0 */
a740 3
void cpu_interrupt_to_db(int cpu_no)
{}

d748 4
a751 4
    { "iflush",    m88k_db_iflush, 0, 0},
    { "dflush",    m88k_db_dflush, 0, 0},
    { "peek",      m88k_db_peek, 0, 0},
    { (char *) 0,}
d756 8
a763 8
    {"cache",		0,			0, m88k_cache_cmds},
    {"frame",		m88k_db_print_frame,	0, 0},
    {"noise",		m88k_db_noise,		0, 0},
    {"regs",		m88k_db_registers,	0, 0},
    {"searchframe",	m88k_db_frame_search,	0, 0},
    {"translate",	m88k_db_translate,      0, 0},
    {"where",		m88k_db_where,		0, 0},
    {(char  *) 0,}
a764 1

d772 1
a772 1
    db_machine_commands_install(db_machine_cmds);
d774 1
a774 1
    ddb_init();
d776 1
a776 1
    db_printf("ddb enabled\n");
a777 1

d788 2
a789 1
*db_task_name()
d791 43
a833 45
    static unsigned buffer[(DB_TASK_NAME_LEN + 5)/sizeof(unsigned)];
    unsigned ptr = (vm_offset_t)(TOP_OF_USER_STACK - 4);
    unsigned limit = ptr - MAX_DISTANCE_TO_LOOK;
    unsigned word;
    int i;

    /* skip zeros at the end */
    while (ptr > limit &&
	   (i = db_trace_get_val((vm_offset_t)ptr, &word))
	   && (word == 0))
    {
	ptr -= 4; /* continue looking for a non-null word */
    }

    if (ptr <= limit) {
	db_printf("bad name at line %d\n", __LINE__);
	return "<couldn't find 1>";
    } else if (i != 1) {
 	return "<nostack>";
    }

    /* skip looking for null before all the text */
    while (ptr > limit
	&&(i = db_trace_get_val(ptr, &word))
    	&& (word != 0))
    {
	ptr -= 4; /* continue looking for a null word */
    }
    
    if (ptr <= limit) {
	db_printf("bad name at line %d\n", __LINE__);
	return "<couldn't find 2>";
    } else if (i != 1) {
	db_printf("bad name read of %x "
	          "at line %d\n", ptr, __LINE__);
 	return "<bad read 2>";
    }

    ptr += 4; /* go back to the non-null word after this one */

    for (i = 0; i < sizeof(buffer); i++, ptr+=4) {
	buffer[i] = 0; /* just in case it's not read */
	db_trace_get_val((vm_offset_t)ptr, &buffer[i]);
    }
    return (char*)buffer;
@
