head	1.14;
access;
symbols
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.11.0.6
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.11
	UBC:1.8.0.2
	UBC_BASE:1.8
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.4.0.10
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.8
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.6
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.4
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	mvme88kport:1.1.1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	first_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2004.06.19.18.28.37;	author miod;	state dead;
branches;
next	1.13;

1.13
date	2004.01.07.17.52.30;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2003.10.05.20.25.06;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.16.13.01.41;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.01.26.38;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.22.08.31.04;	author smurph;	state Exp;
branches;
next	1.8;

1.8
date	2001.12.16.23.49.46;	author miod;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2001.12.13.08.55.51;	author smurph;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.26.02.37.00;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.08.00.02.17;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	99.02.09.06.36.24;	author smurph;	state Exp;
branches
	1.4.6.1;
next	1.3;

1.3
date	97.03.03.20.20.33;	author rahnds;	state Exp;
branches;
next	1.2;

1.2
date	97.03.03.19.07.04;	author rahnds;	state dead;
branches;
next	1.1;

1.1
date	95.10.18.10.54.28;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.10.54.28;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.03.03.19.31.54;	author rahnds;	state Exp;
branches;
next	;

1.4.6.1
date	2001.04.18.16.10.50;	author niklas;	state Exp;
branches;
next	1.4.6.2;

1.4.6.2
date	2001.10.31.03.01.18;	author nate;	state Exp;
branches;
next	1.4.6.3;

1.4.6.3
date	2002.03.06.01.08.05;	author niklas;	state Exp;
branches;
next	1.4.6.4;

1.4.6.4
date	2002.03.28.10.36.02;	author niklas;	state Exp;
branches;
next	1.4.6.5;

1.4.6.5
date	2003.03.27.23.32.17;	author niklas;	state Exp;
branches;
next	1.4.6.6;

1.4.6.6
date	2004.02.19.10.49.06;	author niklas;	state Exp;
branches;
next	;

1.8.2.1
date	2002.01.31.22.55.17;	author niklas;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2002.06.11.03.37.09;	author art;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Share common ddb files accross m88k platforms.
@
text
@/*	$OpenBSD: db_disasm.c,v 1.13 2004/01/07 17:52:30 miod Exp $	*/
/*
 * Mach Operating System
 * Copyright (c) 1993-1991 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON AND OMRON ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON AND OMRON DISCLAIM ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*
 * m88k disassembler for use in ddb
 */

#include <sys/param.h>		/* cputyp and friends */
#include <sys/types.h>

#include <machine/db_machdep.h>

#include <ddb/db_sym.h>		/* DB_STGY_PROC, db_printsym() */
#include <ddb/db_access.h>	/* db_get_value() */
#include <ddb/db_output.h>	/* db_printf() */
#include <ddb/db_interface.h>

static const char *instwidth[4] = {
	".d", "  ", ".h", ".b"
};

static const char *condname[6] = {
	"gt0 ", "eq0 ", "ge0 ", "lt0 ", "ne0 ", "le0 "
};

static const char *m88100_ctrlreg[64] = {
	"cr0(PID)   ",
	"cr1(PSR)   ",
	"cr2(EPSR)  ",
	"cr3(SSBR)  ",
	"cr4(SXIP)  ",
	"cr5(SNIP)  ",
	"cr6(SFIP)  ",
	"cr7(VBR)   ",
	"cr8(DMT0)  ",
	"cr9(DMD0)  ",
	"cr10(DMA0) ",
	"cr11(DMT1) ",
	"cr12(DMD1) ",
	"cr13(DMA1) ",
	"cr14(DMT2) ",
	"cr15(DMD2) ",
	"cr16(DMA2) ",
	"cr17(SR0)  ",
	"cr18(SR1)  ",
	"cr19(SR2)  ",
	"cr20(SR3)  ",
	"fcr0(FPECR)",
	"fcr1(FPHS1)",
	"fcr2(FPLS1)",
	"fcr3(FPHS2)",
	"fcr4(FPLS2)",
	"fcr5(FPPT) ",
	"fcr6(FPRH) ",
	"fcr7(FPRL) ",
	"fcr8(FPIT) ",
	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
	"fcr62(FPSR)",
	"fcr63(FPCR)"
};

static const char *m88110_ctrlreg[64] = {
	"cr0(PID)   ",
	"cr1(PSR)   ",
	"cr2(EPSR)  ",
	NULL,
	"cr4(EXIP)  ",
	"cr5(ENIP)  ",
	NULL,
	"cr7(VBR)   ",
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	"cr14(RES1) ",
	"cr15(RES2) ",
	"cr16(SR0)  ",
	"cr17(SR1)  ",
	"cr18(SR2)  ",
	"cr19(SR3)  ",
	"cr20(SR4)  ",
	"fcr0(FPECR)",
	NULL,
	NULL,
	NULL,
	"cr25(ICMD) ",
	"cr26(ICTL) ",
	"cr27(ISAR) ",
	"cr28(ISAP) ",
	"cr29(IUAP) ",
	"cr30(IIR)  ",
	"cr31(IBP)  ",
	"cr32(IPPU) ",
	"cr33(IPPL) ",
	"cr34(ISR)  ",
	"cr35(ILAR) ",
	"cr36(IPAR) ",
	NULL,
	NULL,
	NULL,
	"cr40(DCMD) ",
	"cr41(DCTL) ",
	"cr42(DSAR) ",
	"cr43(DSAP) ",
	"cr44(DUAP) ",
	"cr45(DIR)  ",
	"cr46(DBP)  ",
	"cr47(DPPU) ",
	"cr48(DPPL) ",
	"cr49(DSR)  ",
	"cr50(DLAR) ",
	"cr51(DPAR) ",
	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
	NULL, NULL,
	"fcr62(FPSR)",
	"fcr63(FPCR)"
};

#define printval(x) \
	do { \
		if ((x) < 0) \
			db_printf("-0x%X", -(x)); \
		else \
			db_printf("0x%X", (x));	\
	} while (0)

/* prototypes */
void oimmed(int, const char *, long);
void ctrlregs(int, const char *, long);
void printsod(int);
void sindou(int, const char *, long);
void jump(int, const char *, long);
void instset(int, const char *, long);
void symofset(int, int, int);
void obranch(int, const char *, long);
void brcond(int, const char *, long);
void otrap(int, const char *, long);
void obit(int, const char *, long);
void bitman(int, const char *, long);
void immem(int, const char *, long);
void nimmem(int, const char *, long);
void lognim(int, const char *, long);
void onimmed(int, const char *, long);

/* Handlers immediate integer arithmetic instructions */
void
oimmed(int inst, const char  *opcode, long iadr)
{
	int Linst = inst & 0177777;
	int Hinst = inst >> 16;
	int H6inst = Hinst >> 10;
	int rs1 = Hinst & 037;
	int rd = ( Hinst >> 5 ) & 037;

	if (( H6inst > 017 ) && ( H6inst < 030 ) && ( H6inst & 01) == 1 )
		db_printf("\t%s.u",opcode);
	else {
		db_printf("\t%s",opcode);
		db_printf("  ");
	}
	db_printf("\t\tr%-3d,r%-3d,", rd, rs1);
	printval(Linst);
}


/* Handles instructions dealing with control registers */
void
ctrlregs(int inst, const char *opcode, long iadr)
{
	int L6inst = (inst >> 11) & 037;
	int creg = (inst >> 5) & 077;
	int rd = (inst >> 21) & 037;
	int rs1 = (inst >> 16) & 037;

	db_printf("\t%s",opcode);

	if ( L6inst == 010 || L6inst == 011 )
		db_printf("\t\tr%-3d,%s", rd,
			  cputyp == CPU_88100 ? m88100_ctrlreg[creg] : m88110_ctrlreg[creg]);
	else if ( L6inst == 020 || L6inst == 021 )
		db_printf("\t\tr%-3d,%s", rs1,
			  cputyp == CPU_88100 ? m88100_ctrlreg[creg] : m88110_ctrlreg[creg]);
	else
		db_printf("\t\tr%-3d,r%-3d,%s", rd, rs1,
			  cputyp == CPU_88100 ? m88100_ctrlreg[creg] : m88110_ctrlreg[creg]);
}


void
printsod(int t)
{
	if ( t == 0 )
		db_printf("s");
	else
		db_printf("d");
}

/* Handles floating point instructions */
void
sindou(int inst, const char *opcode, long iadr)
{
	int rs2 = inst & 037;
	int td = ( inst >> 5 ) & 03;
	int t2 = ( inst >> 7 ) & 03;
	int t1 = ( inst >> 9 ) & 03;
	int rs1 = ( inst >> 16 ) & 037;
	int rd = ( inst >> 21 ) & 037;
	int checkbits  = ( inst >> 11 ) & 037;

	db_printf("\t%s.",opcode);
	printsod(td);
	if (( checkbits > 010 && checkbits < 014 ) || ( checkbits == 04 )) {
		printsod(t2);
		db_printf(" ");
		if ( checkbits == 012 || checkbits == 013 )
			db_printf("\t\tr%-3d,r%-3d", rd, rs2);
		else
			db_printf("\t\tr%-3d,r%-3d", rd, rs2);
	} else {
		printsod(t1);printsod(t2);
		db_printf("\t\tr%-3d,r%-3d,r%-3d", rd, rs1, rs2);
	}
}


void
jump(int inst, const char *opcode, long iadr)
{
	int rs2 = inst & 037;
	int Nbit = ( inst >> 10 ) & 01;

	db_printf("\t%s",opcode);
	if ( Nbit == 1 )
		db_printf(".n");
	else
		db_printf("  ");
	db_printf("\t\tr%-3d",rs2);
}


/* Handles ff1, ff0, tbnd and rte instructions */
void
instset(int inst, const char *opcode, long iadr)
{
	int rs2 = inst & 037;
	int rs1 = ( inst >> 16 ) & 037;
	int rd = ( inst >> 21 ) & 037;
	int checkbits = ( inst >> 10 ) & 077;
	int H6inst = ( inst >> 26 ) & 077;

	db_printf("\t%s",opcode);
	if ( H6inst == 076 ) {
		db_printf("\t\tr%-3d,",rs1);
		printval(inst & 0177777);
	} else if (( checkbits == 072 ) || ( checkbits == 073 ))
		db_printf("\t\tr%-3d,r%-3d", rd, rs2);
	else if ( checkbits == 076 )
		db_printf("\t\tr%-3d,r%-3d",rs1,rs2);
}

void
symofset(int  disp, int  bit, int iadr)
{
	long addr;

	if ( disp & (1 << (bit-1)) ) {
		/* negative value */
		addr = iadr + ((disp << 2) | (~0 << bit));
	} else {
		addr = iadr + (disp << 2);
	}
	db_printsym(addr,DB_STGY_PROC, db_printf);
	return;
}

void
obranch(int inst, const char *opcode, long iadr)
{
	int cond = ( inst >> 26 ) & 01;
	int disp = inst &0377777777;

	if ( cond == 0 ) {
		db_printf("\t%s\t\t",opcode);
		symofset(disp, 26, iadr);
	} else {
		db_printf("\t%s.n\t\t",opcode);
		symofset(disp, 26, iadr);
	}
}


/* Handles branch on conditions instructions */
void
brcond(int inst, const char *opcode, long iadr)
{
	int cond = ( inst >> 26 ) & 1;
	int match = ( inst >> 21 ) & 037;
	int rs = ( inst >> 16 ) & 037;
	int disp = ( inst & 0177777 );

	if ( cond == 0 )
		db_printf("\t%s\t\t", opcode);
	else
		db_printf("\t%s.n\t\t", opcode);
	if ( ( ( inst >> 27 ) & 03 ) == 1 )
		switch (match) {
		case 1 : db_printf("%s,", condname[0]); break;
		case 2 : db_printf("%s,", condname[1]); break;
		case 3 : db_printf("%s,", condname[2]); break;
		case 12: db_printf("%s,", condname[3]); break;
		case 13: db_printf("%s,", condname[4]); break;
		case 14: db_printf("%s,", condname[5]); break;
		default: printval(match);
			db_printf(",");
		} else {
		printval(match);
		db_printf(",");
	}

	db_printf("r%-3d,", rs);
	symofset(disp, 16, iadr);
}


void
otrap(int inst, const char *opcode, long iadr)
{
	int vecno = inst & 0777;
	int match = ( inst >> 21 ) & 037;
	int rs = ( inst >> 16 ) & 037;

	db_printf("\t%s\t",opcode);
	if ( ( ( inst >> 12 ) & 017 ) == 0xe )
		switch (match) {
		case 1 : db_printf("%s,", condname[0]);break;
		case 2 : db_printf("%s,", condname[1]);break;
		case 3 : db_printf("%s,", condname[2]);break;
		case 12: db_printf("%s,", condname[3]);break;
		case 13: db_printf("%s,", condname[4]);break;
		case 14: db_printf("%s,", condname[5]);break;
		default: printval(match);
			db_printf(",");
		} else {
		printval(match);
		db_printf(",");
	}
	db_printf("\tr%-3d,", rs);
	printval(vecno);
}


/* Handles 10 bit immediate bit field operations */
void
obit(int inst, const char *opcode, long iadr)
{
	int rs = ( inst >> 16 ) & 037;
	int rd = ( inst >> 21 ) & 037;
	int width = ( inst >> 5 ) & 037;
	int offset = ( inst & 037 );

	db_printf("\t%s\t\tr%-3d,r%-3d,", opcode, rd, rs);
	if ( ( ( inst >> 10 ) & 077 ) == 052 ) {
		db_printf("<");
		printval(offset);
		db_printf(">");
	} else {
		printval(width);
		db_printf("<");
		printval(offset);
		db_printf(">");
	}
}


/* Handles triadic mode bit field instructions */
void
bitman(int inst, const char *opcode, long iadr)
{

	int rs1 = ( inst >> 16 ) & 037;
	int rd  = ( inst >> 21 ) & 037;
	int rs2 = inst & 037;

	db_printf("\t%s\t\tr%-3d,r%-3d,r%-3d", opcode, rd, rs1, rs2);
}


/* Handles immediate load/store/exchange instructions */
void
immem(int inst, const char *opcode, long iadr)
{
	int immed  = inst & 0xFFFF;
	int rd     = (inst >> 21) & 037;
	int rs     = (inst >> 16) & 037;
	int st_lda = (inst >> 28) & 03;
	int aryno  = (inst >> 26) & 03;
	char c = ' ';

	if (!st_lda) {
		if ((aryno == 0) || (aryno == 01))
			opcode = "xmem";
		else
			opcode = "ld";
		if (aryno == 0)
			aryno = 03;
		if (!(aryno == 01))
			c = 'u';
	} else
		if (st_lda == 01)
		opcode = "ld";

	db_printf("\t%s%s%c\t\tr%-3d,r%-3d,", opcode, instwidth[aryno],
		  c, rd, rs);
	printval(immed);
}


/* Handles triadic mode load/store/exchange instructions */
void
nimmem(int inst, const char *opcode, long iadr)
{
	int scaled  = (inst >> 9) & 01;
	int rd      = (inst >> 21) & 037;
	int rs1     = (inst >> 16) & 037;
	int rs2     = inst & 037;
	int st_lda  = (inst >> 12) & 03;
	int aryno   = (inst >> 10) & 03;
	int user_bit = 0;
	int signed_fg  = 1;
	char *user           = "    ";
	char c = ' ';

	if (!st_lda) {
		if ((aryno == 0) || (aryno == 01))
			opcode = "xmem";
		else
			opcode = "ld";
		if (aryno == 0)
			aryno = 03;
		if (!(aryno == 01)) {
			c = 'u';
			signed_fg = 0;
		}
	} else
		if (st_lda == 01)
		opcode = "ld";

	if (!(st_lda == 03)) {
		user_bit = (inst >> 8) & 01;
		if (user_bit)
			user = ".usr";
	}

	if (user_bit && signed_fg && (aryno == 01)) {
		if (st_lda)
			db_printf("\t%s%s\tr%-3d,r%-3d", opcode,
				  user, rd, rs1);
		else
			db_printf("\t%s%s\tr%-3d,r%-3d", opcode,
				  user, rd, rs1);
	} else
		if (user_bit && signed_fg)
		db_printf("\t%s%s%s\tr%-3d,r%-3d", opcode,
			  instwidth[aryno], user, rd, rs1);
	else
		db_printf("\t%s%s%c%s\tr%-3d,r%-3d", opcode,
			  instwidth[aryno], c, user, rd, rs1);

	if (scaled)
		db_printf("[r%-3d]", rs2);
	else
		db_printf(",r%-3d", rs2);
}


/* Handles triadic mode logical instructions */
void
lognim(int inst, const char *opcode, long iadr)
{
	int rd   = (inst >> 21) & 037;
	int rs1  = (inst >> 16) & 037;
	int rs2  = inst & 037;
	int complemt = (inst >> 10) & 01;
	char *c = "  ";

	if (complemt)
		c = ".c";

	db_printf("\t%s%s\t\tr%-3d,r%-3d,r%-3d", opcode, c, rd, rs1, rs2);
}


/* Handles triadic mode arithmetic instructions */
void
onimmed(int inst, const char *opcode, long iadr)
{
	int rd   = (inst >> 21) & 037;
	int rs1  = (inst >> 16) & 037;
	int rs2  = inst & 037;
	int carry = (inst >> 8) & 03;
	int nochar = (inst >> 10) & 07;
	int nodecode = (inst >> 11) & 01;
	char *tab, *c ;

	if (nochar > 02)
		tab = "\t\t";
	else
		tab = "\t";

	if (!nodecode) {
		if (carry == 01)
			c = ".co ";
		else
			if (carry == 02)
			c = ".ci ";
		else
			if (carry == 03)
			c = ".cio";
		else
			c = "    ";
	} else
		c = "    ";

	db_printf("\t%s%s%sr%-3d,r%-3d,r%-3d", opcode, c,
		  tab, rd, rs1, rs2);
}

static const struct opdesc {
	unsigned mask, match;
	void (*opfun)(int, const char *, long);
	const char *farg;
} opdecode[] = {

	/* ORDER IS IMPORTANT BELOW */

	{   0xF0000000U, 0x00000000U, immem, NULL},
	{   0xF0000000U, 0x10000000U, immem, NULL},
	{   0xF0000000U, 0x20000000U, immem, "st"},
	{   0xF0000000U, 0x30000000U, immem, "lda"},

	{   0xF8000000U, 0x40000000U, oimmed, "and"},
	{   0xF8000000U, 0x48000000U, oimmed, "mask"},
	{   0xF8000000U, 0x50000000U, oimmed, "xor"},
	{   0xF8000000U, 0x58000000U, oimmed, "or"},
	{   0xFC000000U, 0x60000000U, oimmed, "addu"},
	{   0xFC000000U, 0x64000000U, oimmed, "subu"},
	{   0xFC000000U, 0x68000000U, oimmed, "divu"},
	{   0xFC000000U, 0x6C000000U, oimmed, "mul"},
	{   0xFC000000U, 0x70000000U, oimmed, "add"},
	{   0xFC000000U, 0x74000000U, oimmed, "sub"},
	{   0xFC000000U, 0x78000000U, oimmed, "div"},
	{   0xFC000000U, 0x7C000000U, oimmed, "cmp"},

	{   0xFC00F800U, 0x80004000U, ctrlregs, "ldcr"},
	{   0xFC00F800U, 0x80004800U, ctrlregs, "fldcr"},
	{   0xFC00F800U, 0x80008000U, ctrlregs, "stcr"},
	{   0xFC00F800U, 0x80008800U, ctrlregs, "fstcr"},
	{   0xFC00F800U, 0x8000C000U, ctrlregs, "xcr"},
	{   0xFC00F800U, 0x8000C800U, ctrlregs, "fxcr"},

	{   0xFC00F800U, 0x84000000U, sindou, "fmul"},
	{   0xFC1FFF80U, 0x84002000U, sindou, "flt"},
	{   0xFC00F800U, 0x84002800U, sindou, "fadd"},
	{   0xFC00F800U, 0x84003000U, sindou, "fsub"},
	{   0xFC00F860U, 0x84003800U, sindou, "fcmp"},
	{   0xFC1FFE60U, 0x84004800U, sindou, "int"},
	{   0xFC1FFE60U, 0x84005000U, sindou, "nint"},
	{   0xFC1FFE60U, 0x84005800U, sindou, "trnc"},
	{   0xFC00F800U, 0x84007000U, sindou, "fdiv"},

	{   0xF8000000U, 0xC0000000U, obranch, "br"},
	{   0xF8000000U, 0xC8000000U, obranch, "bsr"},

	{   0xF8000000U, 0xD0000000U, brcond, "bb0"},
	{   0xF8000000U, 0xD8000000U, brcond, "bb1"},
	{   0xF8000000U, 0xE8000000U, brcond, "bcnd"},

	{   0xFC00FC00U, 0xF0008000U, obit, "clr"},
	{   0xFC00FC00U, 0xF0008800U, obit, "set"},
	{   0xFC00FC00U, 0xF0009000U, obit, "ext"},
	{   0xFC00FC00U, 0xF0009800U, obit, "extu"},
	{   0xFC00FC00U, 0xF000A000U, obit, "mak"},
	{   0xFC00FC00U, 0xF000A800U, obit, "rot"},

	{   0xFC00FE00U, 0xF000D000U, otrap, "tb0"},
	{   0xFC00FE00U, 0xF000D800U, otrap, "tb1"},
	{   0xFC00FE00U, 0xF000E800U, otrap, "tcnd"},

	{   0xFC00F2E0U, 0xF4000000U, nimmem, NULL},
	{   0xFC00F2E0U, 0xF4000200U, nimmem, NULL},
	{   0xFC00F2E0U, 0xF4001000U, nimmem, NULL},
	{   0xFC00F2E0U, 0xF4001200U, nimmem, NULL},
	{   0xFC00F2E0U, 0xF4002000U, nimmem, "st"},
	{   0xFC00F2E0U, 0xF4002200U, nimmem, "st"},
	{   0xFC00F2E0U, 0xF4003000U, nimmem, "lda"},
	{   0xFC00F2E0U, 0xF4003200U, nimmem, "lda"},

	{   0xFC00FBE0U, 0xF4004000U, lognim, "and"},
	{   0xFC00FBE0U, 0xF4005000U, lognim, "xor"},
	{   0xFC00FBE0U, 0xF4005800U, lognim, "or"},

	{   0xFC00FCE0U, 0xF4006000U, onimmed, "addu"},
	{   0xFC00FCE0U, 0xF4006400U, onimmed, "subu"},
	{   0xFC00FCE0U, 0xF4006800U, onimmed, "divu"},
	{   0xFC00FCE0U, 0xF4006C00U, onimmed, "mul"},
	{   0xFC00FCE0U, 0xF4007000U, onimmed, "add"},
	{   0xFC00FCE0U, 0xF4007400U, onimmed, "sub"},
	{   0xFC00FCE0U, 0xF4007800U, onimmed, "div"},
	{   0xFC00FCE0U, 0xF4007C00U, onimmed, "cmp"},

	{   0xFC00FFE0U, 0xF4008000U, bitman, "clr"},
	{   0xFC00FFE0U, 0xF4008800U, bitman, "set"},
	{   0xFC00FFE0U, 0xF4009000U, bitman, "ext"},
	{   0xFC00FFE0U, 0xF4009800U, bitman, "extu"},
	{   0xFC00FFE0U, 0xF400A000U, bitman, "mak"},
	{   0xFC00FFE0U, 0xF400A800U, bitman, "rot"},

	{   0xFC00FBE0U, 0xF400C000U, jump, "jmp"},
	{   0xFC00FBE0U, 0xF400C800U, jump, "jsr"},

	{   0xFC00FFE0U, 0xF400E800U, instset, "ff1"},
	{   0xFC00FFE0U, 0xF400EC00U, instset, "ff0"},
	{   0xFC00FFE0U, 0xF400F800U, instset, "tbnd"},
	{   0xFC00FFE0U, 0xF400FC00U, instset, "rte"},
	{   0xFC000000U, 0xF8000000U, instset, "tbnd"},
	{   0, 0, NULL, NULL}
};

static const char *badop = "\t???";

int
m88k_print_instruction(unsigned iadr, long inst)
{
	const struct opdesc *p;

	/* this messes up "orb" instructions ever so slightly, */
	/* but keeps us in sync between routines... */
	if (inst == 0) {
		db_printf ("\t.word 0");
	} else {
		for (p = opdecode; p->mask; p++)
			if ((inst & p->mask) == p->match) {
				(*p->opfun) (inst, p->farg, iadr);
				break;
			}
		if (!p->mask)
			db_printf (badop);
	}

	return iadr+4;
}

db_addr_t
db_disasm(db_addr_t loc, boolean_t altfmt)
{
	m88k_print_instruction(loc, db_get_value(loc, 4, FALSE));
	db_printf ("\n");
	return loc+4;
}
@


1.13
log
@Constify, remove db_task_name() Mach leftover, and fix an hilarious typo
in db_interface.c comments while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.12 2003/10/05 20:25:06 miod Exp $	*/
@


1.12
log
@De-register
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.11 2002/05/16 13:01:41 art Exp $	*/
d43 1
a43 1
static char *instwidth[4] = {
d47 1
a47 1
static char *condname[6] = {
d51 1
a51 1
static char *m88100_ctrlreg[64] = {
d82 4
a85 1
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
d90 1
a90 1
static char *m88110_ctrlreg[64] = {
d94 1
a94 1
	0,
d97 1
a97 1
	0,
d99 6
a104 6
	0,
	0,
	0,
	0,
	0,
	0,
d113 3
a115 3
	0,
	0,
	0,
d128 3
a130 1
	0,0,0,
d143 2
a144 1
	0,0,0,0,0,0,0,0,0,0,
d158 2
a159 2
void oimmed(int, char *, long);
void ctrlregs(int, char *, long);
d161 3
a163 3
void sindou(int, char *, long);
void jump(int, char *, long);
void instset(int, char *, long);
d165 9
a173 9
void obranch(int, char *, long);
void brcond(int, char *, long);
void otrap(int, char *, long);
void obit(int, char *, long);
void bitman(int, char *, long);
void immem(int, char *, long);
void nimmem(int, char *, long);
void lognim(int, char *, long);
void onimmed(int, char *, long);
d177 1
a177 1
oimmed(int inst, char  *opcode, long iadr)
d198 1
a198 1
ctrlregs(int inst, char *opcode, long iadr)
d230 1
a230 1
sindou(int inst, char *opcode, long iadr)
d257 1
a257 1
jump(int inst, char *opcode, long iadr)
d273 1
a273 1
instset(int inst, char *opcode, long iadr)
d307 1
a307 1
obranch(int inst, char *opcode, long iadr)
d324 1
a324 1
brcond(int inst, char *opcode, long iadr)
d356 1
a356 1
otrap(int inst, char *opcode, long iadr)
d384 1
a384 1
obit(int inst, char *opcode, long iadr)
d407 1
a407 1
bitman(int inst, char *opcode, long iadr)
d420 1
a420 1
immem(int inst, char *opcode, long iadr)
d450 1
a450 1
nimmem(int inst, char *opcode, long iadr)
d508 1
a508 1
lognim(int inst, char *opcode, long iadr)
d525 1
a525 1
onimmed(int inst, char *opcode, long iadr)
d558 1
a558 1
static struct opdesc {
d560 2
a561 2
	void (*opfun)(int, char *, long);
	char *farg;
d566 2
a567 2
	{   0xF0000000U, 0x00000000U, immem, 0,},
	{   0xF0000000U, 0x10000000U, immem, 0,},
d619 4
a622 4
	{   0xFC00F2E0U, 0xF4000000U, nimmem, 0,},
	{   0xFC00F2E0U, 0xF4000200U, nimmem, 0,},
	{   0xFC00F2E0U, 0xF4001000U, nimmem, 0,},
	{   0xFC00F2E0U, 0xF4001200U, nimmem, 0,},
d656 1
a656 1
	{   0,0,0,0}
d659 1
a659 1
static char *badop = "\t???";
d664 1
a664 1
	struct opdesc *p;
@


1.11
log
@Add a an argument to db_printsym that specifies the printf function
we'll use for printing the information.
miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.10 2002/03/14 01:26:38 millert Exp $	*/
d49 1
a49 1
};  
d167 1
a167 1
void onimmed(int, char *, long);      
d173 5
a177 5
	register int Linst = inst & 0177777;
	register int Hinst = inst >> 16;
	register int H6inst = Hinst >> 10;
	register int rs1 = Hinst & 037;
	register int rd = ( Hinst >> 5 ) & 037;
d194 4
a197 4
	register int L6inst = (inst >> 11) & 037;
	register int creg = (inst >> 5) & 077;
	register int rd = (inst >> 21) & 037;
	register int rs1 = (inst >> 16) & 037;
d202 1
a202 1
		db_printf("\t\tr%-3d,%s", rd, 
d205 1
a205 1
		db_printf("\t\tr%-3d,%s", rs1, 
d226 7
a232 7
	register int rs2 = inst & 037;
	register int td = ( inst >> 5 ) & 03;
	register int t2 = ( inst >> 7 ) & 03;
	register int t1 = ( inst >> 9 ) & 03;
	register int rs1 = ( inst >> 16 ) & 037;
	register int rd = ( inst >> 21 ) & 037;
	register int checkbits  = ( inst >> 11 ) & 037;
d253 2
a254 2
	register int rs2 = inst & 037;
	register int Nbit = ( inst >> 10 ) & 01;
d265 1
a265 1
/* Handles ff1, ff0, tbnd and rte instructions */ 
d269 5
a273 5
	register int rs2 = inst & 037;
	register int rs1 = ( inst >> 16 ) & 037;
	register int rd = ( inst >> 21 ) & 037;
	register int checkbits = ( inst >> 10 ) & 077;
	register int H6inst = ( inst >> 26 ) & 077;
d337 1
a337 1
		default: printval(match); 
d383 1
a383 1
	int offset = ( inst & 037 );  
d385 1
a385 1
	db_printf("\t%s\t\tr%-3d,r%-3d,", opcode, rd, rs); 
d387 3
a389 3
		db_printf("<"); 
		printval(offset); 
		db_printf(">"); 
d416 5
a420 5
	register int immed  = inst & 0xFFFF;
	register int rd     = (inst >> 21) & 037;
	register int rs     = (inst >> 16) & 037;
	register int st_lda = (inst >> 28) & 03;
	register int aryno  = (inst >> 26) & 03;
d436 1
a436 1
	db_printf("\t%s%s%c\t\tr%-3d,r%-3d,", opcode, instwidth[aryno], 
d446 7
a452 7
	register int scaled  = (inst >> 9) & 01;
	register int rd      = (inst >> 21) & 037;
	register int rs1     = (inst >> 16) & 037;
	register int rs2     = inst & 037;
	register int st_lda  = (inst >> 12) & 03;
	register int aryno   = (inst >> 10) & 03;
	register int user_bit = 0;
d487 1
a487 1
		db_printf("\t%s%s%s\tr%-3d,r%-3d", opcode, 
d490 1
a490 1
		db_printf("\t%s%s%c%s\tr%-3d,r%-3d", opcode, 
d504 4
a507 4
	register int rd   = (inst >> 21) & 037;
	register int rs1  = (inst >> 16) & 037;
	register int rs2  = inst & 037;
	register int complemt = (inst >> 10) & 01;
d521 6
a526 6
	register int rd   = (inst >> 21) & 037;
	register int rs1  = (inst >> 16) & 037;
	register int rs2  = inst & 037;
	register int carry = (inst >> 8) & 03;
	register int nochar = (inst >> 10) & 07;
	register int nodecode = (inst >> 11) & 01;
d658 1
a658 1
	register struct opdesc *p;
@


1.10
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.9 2001/12/22 08:31:04 smurph Exp $	*/
d296 1
a296 1
	db_printsym(addr,DB_STGY_PROC);
@


1.9
log
@mc88110 support in ddb.  Bring in bit definitions.
We can support hardware sstep for mc88110 and
software sstep for mc88100.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.8 2001/12/16 23:49:46 miod Exp $	*/
d152 16
a167 16
void oimmed __P((int, char *, long));
void ctrlregs __P((int, char *, long));
void printsod __P((int));
void sindou __P((int, char *, long));
void jump __P((int, char *, long));
void instset __P((int, char *, long));
void symofset __P((int, int, int));
void obranch __P((int, char *, long));
void brcond __P((int, char *, long));
void otrap __P((int, char *, long));
void obit __P((int, char *, long));
void bitman __P((int, char *, long));
void immem __P((int, char *, long));
void nimmem __P((int, char *, long));
void lognim __P((int, char *, long));
void onimmed __P((int, char *, long));      
d554 1
a554 1
	void (*opfun) __P((int, char *, long));
@


1.8
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.6 2001/08/26 02:37:00 miod Exp $	*/
d33 1
d51 1
a51 1
static char *ctrlreg[64] = {
d87 56
d167 1
a167 1
void onimmed __P((int, char *, long));
d169 1
a169 1
/* Handlers immediate integer arithmetic instructions */      
d173 14
a186 14
  register int Linst = inst & 0177777;
  register int Hinst = inst >> 16;
  register int H6inst = Hinst >> 10;
  register int rs1 = Hinst & 037;
  register int rd = ( Hinst >> 5 ) & 037;

  if (( H6inst > 017 ) && ( H6inst < 030 ) && ( H6inst & 01) == 1 ) 
    db_printf("\t%s.u",opcode);
  else {
    db_printf("\t%s",opcode);
    db_printf("  ");
  }
  db_printf("\t\tr%-3d,r%-3d,", rd, rs1);
  printval(Linst);
d194 16
a209 13
  register int L6inst = (inst >> 11) & 037;
  register int creg = (inst >> 5) & 077;
  register int rd = (inst >> 21) & 037;
  register int rs1 = (inst >> 16) & 037;
  
  db_printf("\t%s",opcode);
  
  if ( L6inst == 010 || L6inst == 011 )
    db_printf("\t\tr%-3d,%s", rd, ctrlreg[creg]);
  else if ( L6inst == 020 || L6inst == 021 )
    db_printf("\t\tr%-3d,%s", rs1, ctrlreg[creg]);
  else
    db_printf("\t\tr%-3d,r%-3d,%s", rd, rs1, ctrlreg[creg]);
d216 4
a219 4
  if ( t == 0 ) 
    db_printf("s");
  else
    db_printf("d");
d226 21
a246 22
  register int rs2 = inst & 037;
  register int td = ( inst >> 5 ) & 03;
  register int t2 = ( inst >> 7 ) & 03;
  register int t1 = ( inst >> 9 ) & 03;
  register int rs1 = ( inst >> 16 ) & 037;
  register int rd = ( inst >> 21 ) & 037;
  register int checkbits  = ( inst >> 11 ) & 037;
  
  db_printf("\t%s.",opcode);
  printsod(td);
  if (( checkbits > 010 && checkbits < 014 ) || ( checkbits == 04 )) {
    printsod(t2);
    db_printf(" ");
    if ( checkbits == 012 || checkbits == 013 )
      db_printf("\t\tr%-3d,r%-3d", rd, rs2);
    else
      db_printf("\t\tr%-3d,r%-3d", rd, rs2);
  }
  else{
    printsod(t1);printsod(t2);
    db_printf("\t\tr%-3d,r%-3d,r%-3d", rd, rs1, rs2);
  }
d253 9
a261 9
  register int rs2 = inst & 037;
  register int Nbit = ( inst >> 10 ) & 01;
  
  db_printf("\t%s",opcode);
  if ( Nbit == 1 )
    db_printf(".n");
  else
    db_printf("  ");
  db_printf("\t\tr%-3d",rs2);
d269 14
a282 15
  register int rs2 = inst & 037;
  register int rs1 = ( inst >> 16 ) & 037;
  register int rd = ( inst >> 21 ) & 037;
  register int checkbits = ( inst >> 10 ) & 077;
  register int H6inst = ( inst >> 26 ) & 077;
  
  db_printf("\t%s",opcode);
  if ( H6inst == 076 ) {
    db_printf("\t\tr%-3d,",rs1);
    printval(inst & 0177777);
  }
  else if (( checkbits == 072 ) || ( checkbits == 073 ))
    db_printf("\t\tr%-3d,r%-3d", rd, rs2);
  else if ( checkbits == 076 )
    db_printf("\t\tr%-3d,r%-3d",rs1,rs2);
d288 1
a288 1
  long addr;
d290 8
a297 9
  if ( disp & (1 << (bit-1)) ) {
    /* negative value */
    addr = iadr + ((disp << 2) | (~0 << bit));
  }
  else {
    addr = iadr + (disp << 2);
  }
  db_printsym(addr,DB_STGY_PROC);
  return;
d303 10
a312 11
  int cond = ( inst >> 26 ) & 01;
  int disp = inst &0377777777;
  
  if ( cond == 0 ) {
    db_printf("\t%s\t\t",opcode);
    symofset(disp, 26, iadr);
  }
  else {
    db_printf("\t%s.n\t\t",opcode);
    symofset(disp, 26, iadr);
  }
d320 4
a323 24
  int cond = ( inst >> 26 ) & 1;
  int match = ( inst >> 21 ) & 037;
  int rs = ( inst >> 16 ) & 037;
  int disp = ( inst & 0177777 );
  
  if ( cond == 0 )
    db_printf("\t%s\t\t", opcode); 
  else
    db_printf("\t%s.n\t\t", opcode);
  if ( ( ( inst >> 27 ) & 03 ) == 1 )
    switch (match) {
    case 1 : db_printf("%s,", condname[0]); break;
    case 2 : db_printf("%s,", condname[1]); break;
    case 3 : db_printf("%s,", condname[2]); break;
    case 12: db_printf("%s,", condname[3]); break;
    case 13: db_printf("%s,", condname[4]); break;
    case 14: db_printf("%s,", condname[5]); break;
    default: printval(match); 
      db_printf(",");
    }
  else {
    printval(match);
    db_printf(",");
  }
d325 21
a345 2
  db_printf("r%-3d,", rs);
  symofset(disp, 16, iadr);
d352 21
a372 22
  int vecno = inst & 0777;
  int match = ( inst >> 21 ) & 037;
  int rs = ( inst >> 16 ) & 037;
  
  db_printf("\t%s\t",opcode);
  if ( ( ( inst >> 12 ) & 017 ) == 0xe )
    switch (match) {
    case 1 : db_printf("%s,", condname[0]);break;
    case 2 : db_printf("%s,", condname[1]);break;
    case 3 : db_printf("%s,", condname[2]);break;
    case 12: db_printf("%s,", condname[3]);break;
    case 13: db_printf("%s,", condname[4]);break;
    case 14: db_printf("%s,", condname[5]);break;
    default: printval(match);
      db_printf(",");
    }
  else {
    printval(match);
    db_printf(",");
  }
  db_printf("\tr%-3d,", rs);
  printval(vecno);
d380 16
a395 18
  int rs = ( inst >> 16 ) & 037;
  int rd = ( inst >> 21 ) & 037;
  int width = ( inst >> 5 ) & 037;
  int offset = ( inst & 037 );  
  
  db_printf("\t%s\t\tr%-3d,r%-3d,", opcode, rd, rs); 
  if ( ( ( inst >> 10 ) & 077 ) == 052 ) {
    db_printf("<"); 
    printval(offset); 
    db_printf(">"); 
  }
  else
    {
      printval(width);
      db_printf("<");
      printval(offset);
      db_printf(">");
    }
d403 6
a408 6
  
  int rs1 = ( inst >> 16 ) & 037;
  int rd  = ( inst >> 21 ) & 037;
  int rs2 = inst & 037;
  
  db_printf("\t%s\t\tr%-3d,r%-3d,r%-3d", opcode, rd, rs1, rs2);
d416 23
a438 24
  register int immed  = inst & 0xFFFF;
  register int rd     = (inst >> 21) & 037;
  register int rs     = (inst >> 16) & 037;
  register int st_lda = (inst >> 28) & 03;
  register int aryno  = (inst >> 26) & 03;
  char c = ' ';
  
  if (!st_lda)	{
    if ((aryno == 0) || (aryno == 01))
      opcode = "xmem";
    else
      opcode = "ld";
    if (aryno == 0)
      aryno = 03;
    if (!(aryno == 01))
      c = 'u';
  }
  else
    if (st_lda == 01)
      opcode = "ld";
  
  db_printf("\t%s%s%c\t\tr%-3d,r%-3d,", opcode, instwidth[aryno], 
	    c, rd, rs);
  printval(immed);
d446 51
a496 53
  register int scaled  = (inst >> 9) & 01;
  register int rd      = (inst >> 21) & 037;
  register int rs1     = (inst >> 16) & 037;
  register int rs2     = inst & 037;
  register int st_lda  = (inst >> 12) & 03;
  register int aryno   = (inst >> 10) & 03;
  register int user_bit = 0;
  int signed_fg  = 1;
  char *user           = "    ";
  char c = ' ';
  
  if (!st_lda)	{
    if ((aryno == 0) || (aryno == 01))
      opcode = "xmem";
    else
      opcode = "ld";
    if (aryno == 0)
      aryno = 03;
    if (!(aryno == 01))	{
      c = 'u';
      signed_fg = 0;
    }
  }
  else
    if (st_lda == 01)
      opcode = "ld";
  
  if (!(st_lda == 03))	{
    user_bit = (inst >> 8) & 01;
    if (user_bit)
      user = ".usr";
  }
  
  if (user_bit && signed_fg && (aryno == 01)) {
    if (st_lda)
      db_printf("\t%s%s\tr%-3d,r%-3d", opcode,
		user, rd, rs1);
    else
      db_printf("\t%s%s\tr%-3d,r%-3d", opcode,
		user, rd, rs1);
  }	
  else	
    if (user_bit && signed_fg)
      db_printf("\t%s%s%s\tr%-3d,r%-3d", opcode, 
		instwidth[aryno], user, rd, rs1);
    else
      db_printf("\t%s%s%c%s\tr%-3d,r%-3d", opcode, 
		instwidth[aryno], c, user, rd, rs1);
  
  if (scaled)
    db_printf("[r%-3d]", rs2);
  else
    db_printf(",r%-3d", rs2);
d504 10
a513 10
  register int rd   = (inst >> 21) & 037;
  register int rs1  = (inst >> 16) & 037;
  register int rs2  = inst & 037;
  register int complemt = (inst >> 10) & 01;
  char *c = "  ";
  
  if (complemt)
    c = ".c";
  
  db_printf("\t%s%s\t\tr%-3d,r%-3d,r%-3d", opcode, c, rd, rs1, rs2);
d521 10
a530 22
  register int rd   = (inst >> 21) & 037;
  register int rs1  = (inst >> 16) & 037;
  register int rs2  = inst & 037;
  register int carry = (inst >> 8) & 03;
  register int nochar = (inst >> 10) & 07;
  register int nodecode = (inst >> 11) & 01;
  char *tab, *c ;
  
  if (nochar > 02)
    tab = "\t\t";
  else
    tab = "\t";
  
  if (!nodecode) {
    if (carry == 01)
      c = ".co ";
    else
      if (carry == 02)
	c = ".ci ";
      else
	if (carry == 03)
	  c = ".cio";
d532 18
a549 7
	  c = "    ";
  }
  else
    c = "    ";
  
  db_printf("\t%s%s%sr%-3d,r%-3d,r%-3d", opcode, c,
	    tab, rd, rs1, rs2);
d553 3
a555 3
    unsigned mask, match;
    void (*opfun) __P((int, char *, long));
    char *farg;
d558 1
a558 1
    /* ORDER IS IMPORTANT BELOW */
d560 91
a650 91
    {	0xF0000000U, 0x00000000U, immem, 0,		},
    {	0xF0000000U, 0x10000000U, immem, 0,		},
    {	0xF0000000U, 0x20000000U, immem, "st"		},
    {	0xF0000000U, 0x30000000U, immem, "lda"		},

    {	0xF8000000U, 0x40000000U, oimmed, "and" 	},
    {	0xF8000000U, 0x48000000U, oimmed, "mask" 	},
    {	0xF8000000U, 0x50000000U, oimmed, "xor" 	},
    {	0xF8000000U, 0x58000000U, oimmed, "or" 		},
    {	0xFC000000U, 0x60000000U, oimmed, "addu" 	},
    {	0xFC000000U, 0x64000000U, oimmed, "subu" 	},
    {	0xFC000000U, 0x68000000U, oimmed, "divu" 	},
    {	0xFC000000U, 0x6C000000U, oimmed, "mul" 	},
    {	0xFC000000U, 0x70000000U, oimmed, "add" 	},
    {	0xFC000000U, 0x74000000U, oimmed, "sub" 	},
    {	0xFC000000U, 0x78000000U, oimmed, "div" 	},
    {	0xFC000000U, 0x7C000000U, oimmed, "cmp" 	},

    {	0xFC00F800U, 0x80004000U, ctrlregs, "ldcr" 	},
    {	0xFC00F800U, 0x80004800U, ctrlregs, "fldcr" 	},
    {	0xFC00F800U, 0x80008000U, ctrlregs, "stcr" 	},
    {	0xFC00F800U, 0x80008800U, ctrlregs, "fstcr" 	},
    {	0xFC00F800U, 0x8000C000U, ctrlregs, "xcr" 	},
    {	0xFC00F800U, 0x8000C800U, ctrlregs, "fxcr" 	},

    {	0xFC00F800U, 0x84000000U, sindou, "fmul" 	},
    {	0xFC1FFF80U, 0x84002000U, sindou, "flt" 	},
    {	0xFC00F800U, 0x84002800U, sindou, "fadd" 	},
    {	0xFC00F800U, 0x84003000U, sindou, "fsub" 	},
    {	0xFC00F860U, 0x84003800U, sindou, "fcmp" 	},
    {	0xFC1FFE60U, 0x84004800U, sindou, "int" 	},
    {	0xFC1FFE60U, 0x84005000U, sindou, "nint" 	},
    {	0xFC1FFE60U, 0x84005800U, sindou, "trnc" 	},
    {	0xFC00F800U, 0x84007000U, sindou, "fdiv" 	},

    {	0xF8000000U, 0xC0000000U, obranch, "br" 	},
    {	0xF8000000U, 0xC8000000U, obranch, "bsr" 	},

    {	0xF8000000U, 0xD0000000U, brcond, "bb0" 	},
    {	0xF8000000U, 0xD8000000U, brcond, "bb1" 	},
    {	0xF8000000U, 0xE8000000U, brcond, "bcnd" 	},

    {	0xFC00FC00U, 0xF0008000U, obit, "clr" 		},
    {	0xFC00FC00U, 0xF0008800U, obit, "set" 		},
    {	0xFC00FC00U, 0xF0009000U, obit, "ext" 		},
    {	0xFC00FC00U, 0xF0009800U, obit, "extu" 		},
    {	0xFC00FC00U, 0xF000A000U, obit, "mak" 		},
    {	0xFC00FC00U, 0xF000A800U, obit, "rot" 		},

    {	0xFC00FE00U, 0xF000D000U, otrap, "tb0" 		},
    {	0xFC00FE00U, 0xF000D800U, otrap, "tb1" 		},
    {	0xFC00FE00U, 0xF000E800U, otrap, "tcnd" 	},

    {	0xFC00F2E0U, 0xF4000000U, nimmem, 0,		},
    {	0xFC00F2E0U, 0xF4000200U, nimmem, 0,		},
    {	0xFC00F2E0U, 0xF4001000U, nimmem, 0,		},
    {	0xFC00F2E0U, 0xF4001200U, nimmem, 0,		},
    {	0xFC00F2E0U, 0xF4002000U, nimmem, "st" 		},
    {	0xFC00F2E0U, 0xF4002200U, nimmem, "st" 		},
    {	0xFC00F2E0U, 0xF4003000U, nimmem, "lda" 	},
    {	0xFC00F2E0U, 0xF4003200U, nimmem, "lda" 	},

    {	0xFC00FBE0U, 0xF4004000U, lognim, "and" 	},
    {	0xFC00FBE0U, 0xF4005000U, lognim, "xor" 	},
    {	0xFC00FBE0U, 0xF4005800U, lognim, "or" 		},

    {	0xFC00FCE0U, 0xF4006000U, onimmed, "addu" 	},
    {	0xFC00FCE0U, 0xF4006400U, onimmed, "subu" 	},
    {	0xFC00FCE0U, 0xF4006800U, onimmed, "divu" 	},
    {	0xFC00FCE0U, 0xF4006C00U, onimmed, "mul" 	},
    {	0xFC00FCE0U, 0xF4007000U, onimmed, "add" 	},
    {	0xFC00FCE0U, 0xF4007400U, onimmed, "sub" 	},
    {	0xFC00FCE0U, 0xF4007800U, onimmed, "div" 	},
    {	0xFC00FCE0U, 0xF4007C00U, onimmed, "cmp" 	},
 
    {	0xFC00FFE0U, 0xF4008000U, bitman, "clr" 	},
    {	0xFC00FFE0U, 0xF4008800U, bitman, "set" 	},
    {	0xFC00FFE0U, 0xF4009000U, bitman, "ext" 	},
    {	0xFC00FFE0U, 0xF4009800U, bitman, "extu" 	},
    {	0xFC00FFE0U, 0xF400A000U, bitman, "mak" 	},
    {	0xFC00FFE0U, 0xF400A800U, bitman, "rot" 	},

    {	0xFC00FBE0U, 0xF400C000U, jump, "jmp"		},
    {	0xFC00FBE0U, 0xF400C800U, jump, "jsr"		},

    {	0xFC00FFE0U, 0xF400E800U, instset, "ff1"	},
    {	0xFC00FFE0U, 0xF400EC00U, instset, "ff0"	},
    {	0xFC00FFE0U, 0xF400F800U, instset, "tbnd"	},
    {	0xFC00FFE0U, 0xF400FC00U, instset, "rte"	},
    {	0xFC000000U, 0xF8000000U, instset, "tbnd"	},
    {	0,0,0,0 }
d658 14
a671 13
  register struct opdesc *p;
  
  /* this messes up "orb" instructions ever so slightly, */
  /* but keeps us in sync between routines... */
  if (inst == 0) {
    db_printf ("\t.word 0");
  }
  else 
    {
      for (p = opdecode; p->mask; p++)
	if ((inst & p->mask) == p->match) {
	  (*p->opfun) (inst, p->farg, iadr);
	  break;
a672 3
      if (!p->mask)
	db_printf (badop);
    }
d674 1
a674 1
  return iadr+4;
d680 3
a682 3
  m88k_print_instruction(loc, db_get_value(loc, 4, FALSE));
  db_printf ("\n");
  return loc+4;
@


1.8.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.9 2001/12/22 08:31:04 smurph Exp $	*/
a32 1
#include <sys/param.h>		/* cputyp and friends */
d50 1
a50 1
static char *m88100_ctrlreg[64] = {
a85 56
static char *m88110_ctrlreg[64] = {
	"cr0(PID)   ",
	"cr1(PSR)   ",
	"cr2(EPSR)  ",
	0,
	"cr4(EXIP)  ",
	"cr5(ENIP)  ",
	0,
	"cr7(VBR)   ",
	0,
	0,
	0,
	0,
	0,
	0,
	"cr14(RES1) ",
	"cr15(RES2) ",
	"cr16(SR0)  ",
	"cr17(SR1)  ",
	"cr18(SR2)  ",
	"cr19(SR3)  ",
	"cr20(SR4)  ",
	"fcr0(FPECR)",
	0,
	0,
	0,
	"cr25(ICMD) ",
	"cr26(ICTL) ",
	"cr27(ISAR) ",
	"cr28(ISAP) ",
	"cr29(IUAP) ",
	"cr30(IIR)  ",
	"cr31(IBP)  ",
	"cr32(IPPU) ",
	"cr33(IPPL) ",
	"cr34(ISR)  ",
	"cr35(ILAR) ",
	"cr36(IPAR) ",
	0,0,0,
	"cr40(DCMD) ",
	"cr41(DCTL) ",
	"cr42(DSAR) ",
	"cr43(DSAP) ",
	"cr44(DUAP) ",
	"cr45(DIR)  ",
	"cr46(DBP)  ",
	"cr47(DPPU) ",
	"cr48(DPPL) ",
	"cr49(DSR)  ",
	"cr50(DLAR) ",
	"cr51(DPAR) ",
	0,0,0,0,0,0,0,0,0,0,
	"fcr62(FPSR)",
	"fcr63(FPCR)"
};

d110 1
a110 1
void onimmed __P((int, char *, long));      
d112 1
a112 1
/* Handlers immediate integer arithmetic instructions */
d116 14
a129 14
	register int Linst = inst & 0177777;
	register int Hinst = inst >> 16;
	register int H6inst = Hinst >> 10;
	register int rs1 = Hinst & 037;
	register int rd = ( Hinst >> 5 ) & 037;

	if (( H6inst > 017 ) && ( H6inst < 030 ) && ( H6inst & 01) == 1 )
		db_printf("\t%s.u",opcode);
	else {
		db_printf("\t%s",opcode);
		db_printf("  ");
	}
	db_printf("\t\tr%-3d,r%-3d,", rd, rs1);
	printval(Linst);
d137 13
a149 16
	register int L6inst = (inst >> 11) & 037;
	register int creg = (inst >> 5) & 077;
	register int rd = (inst >> 21) & 037;
	register int rs1 = (inst >> 16) & 037;

	db_printf("\t%s",opcode);

	if ( L6inst == 010 || L6inst == 011 )
		db_printf("\t\tr%-3d,%s", rd, 
			  cputyp == CPU_88100 ? m88100_ctrlreg[creg] : m88110_ctrlreg[creg]);
	else if ( L6inst == 020 || L6inst == 021 )
		db_printf("\t\tr%-3d,%s", rs1, 
			  cputyp == CPU_88100 ? m88100_ctrlreg[creg] : m88110_ctrlreg[creg]);
	else
		db_printf("\t\tr%-3d,r%-3d,%s", rd, rs1,
			  cputyp == CPU_88100 ? m88100_ctrlreg[creg] : m88110_ctrlreg[creg]);
d156 4
a159 4
	if ( t == 0 )
		db_printf("s");
	else
		db_printf("d");
d166 22
a187 21
	register int rs2 = inst & 037;
	register int td = ( inst >> 5 ) & 03;
	register int t2 = ( inst >> 7 ) & 03;
	register int t1 = ( inst >> 9 ) & 03;
	register int rs1 = ( inst >> 16 ) & 037;
	register int rd = ( inst >> 21 ) & 037;
	register int checkbits  = ( inst >> 11 ) & 037;

	db_printf("\t%s.",opcode);
	printsod(td);
	if (( checkbits > 010 && checkbits < 014 ) || ( checkbits == 04 )) {
		printsod(t2);
		db_printf(" ");
		if ( checkbits == 012 || checkbits == 013 )
			db_printf("\t\tr%-3d,r%-3d", rd, rs2);
		else
			db_printf("\t\tr%-3d,r%-3d", rd, rs2);
	} else {
		printsod(t1);printsod(t2);
		db_printf("\t\tr%-3d,r%-3d,r%-3d", rd, rs1, rs2);
	}
d194 9
a202 9
	register int rs2 = inst & 037;
	register int Nbit = ( inst >> 10 ) & 01;

	db_printf("\t%s",opcode);
	if ( Nbit == 1 )
		db_printf(".n");
	else
		db_printf("  ");
	db_printf("\t\tr%-3d",rs2);
d210 15
a224 14
	register int rs2 = inst & 037;
	register int rs1 = ( inst >> 16 ) & 037;
	register int rd = ( inst >> 21 ) & 037;
	register int checkbits = ( inst >> 10 ) & 077;
	register int H6inst = ( inst >> 26 ) & 077;

	db_printf("\t%s",opcode);
	if ( H6inst == 076 ) {
		db_printf("\t\tr%-3d,",rs1);
		printval(inst & 0177777);
	} else if (( checkbits == 072 ) || ( checkbits == 073 ))
		db_printf("\t\tr%-3d,r%-3d", rd, rs2);
	else if ( checkbits == 076 )
		db_printf("\t\tr%-3d,r%-3d",rs1,rs2);
d230 1
a230 1
	long addr;
d232 9
a240 8
	if ( disp & (1 << (bit-1)) ) {
		/* negative value */
		addr = iadr + ((disp << 2) | (~0 << bit));
	} else {
		addr = iadr + (disp << 2);
	}
	db_printsym(addr,DB_STGY_PROC);
	return;
d246 11
a256 10
	int cond = ( inst >> 26 ) & 01;
	int disp = inst &0377777777;

	if ( cond == 0 ) {
		db_printf("\t%s\t\t",opcode);
		symofset(disp, 26, iadr);
	} else {
		db_printf("\t%s.n\t\t",opcode);
		symofset(disp, 26, iadr);
	}
d264 24
a287 4
	int cond = ( inst >> 26 ) & 1;
	int match = ( inst >> 21 ) & 037;
	int rs = ( inst >> 16 ) & 037;
	int disp = ( inst & 0177777 );
d289 2
a290 21
	if ( cond == 0 )
		db_printf("\t%s\t\t", opcode);
	else
		db_printf("\t%s.n\t\t", opcode);
	if ( ( ( inst >> 27 ) & 03 ) == 1 )
		switch (match) {
		case 1 : db_printf("%s,", condname[0]); break;
		case 2 : db_printf("%s,", condname[1]); break;
		case 3 : db_printf("%s,", condname[2]); break;
		case 12: db_printf("%s,", condname[3]); break;
		case 13: db_printf("%s,", condname[4]); break;
		case 14: db_printf("%s,", condname[5]); break;
		default: printval(match); 
			db_printf(",");
		} else {
		printval(match);
		db_printf(",");
	}

	db_printf("r%-3d,", rs);
	symofset(disp, 16, iadr);
d297 22
a318 21
	int vecno = inst & 0777;
	int match = ( inst >> 21 ) & 037;
	int rs = ( inst >> 16 ) & 037;

	db_printf("\t%s\t",opcode);
	if ( ( ( inst >> 12 ) & 017 ) == 0xe )
		switch (match) {
		case 1 : db_printf("%s,", condname[0]);break;
		case 2 : db_printf("%s,", condname[1]);break;
		case 3 : db_printf("%s,", condname[2]);break;
		case 12: db_printf("%s,", condname[3]);break;
		case 13: db_printf("%s,", condname[4]);break;
		case 14: db_printf("%s,", condname[5]);break;
		default: printval(match);
			db_printf(",");
		} else {
		printval(match);
		db_printf(",");
	}
	db_printf("\tr%-3d,", rs);
	printval(vecno);
d326 18
a343 16
	int rs = ( inst >> 16 ) & 037;
	int rd = ( inst >> 21 ) & 037;
	int width = ( inst >> 5 ) & 037;
	int offset = ( inst & 037 );  

	db_printf("\t%s\t\tr%-3d,r%-3d,", opcode, rd, rs); 
	if ( ( ( inst >> 10 ) & 077 ) == 052 ) {
		db_printf("<"); 
		printval(offset); 
		db_printf(">"); 
	} else {
		printval(width);
		db_printf("<");
		printval(offset);
		db_printf(">");
	}
d351 6
a356 6

	int rs1 = ( inst >> 16 ) & 037;
	int rd  = ( inst >> 21 ) & 037;
	int rs2 = inst & 037;

	db_printf("\t%s\t\tr%-3d,r%-3d,r%-3d", opcode, rd, rs1, rs2);
d364 24
a387 23
	register int immed  = inst & 0xFFFF;
	register int rd     = (inst >> 21) & 037;
	register int rs     = (inst >> 16) & 037;
	register int st_lda = (inst >> 28) & 03;
	register int aryno  = (inst >> 26) & 03;
	char c = ' ';

	if (!st_lda) {
		if ((aryno == 0) || (aryno == 01))
			opcode = "xmem";
		else
			opcode = "ld";
		if (aryno == 0)
			aryno = 03;
		if (!(aryno == 01))
			c = 'u';
	} else
		if (st_lda == 01)
		opcode = "ld";

	db_printf("\t%s%s%c\t\tr%-3d,r%-3d,", opcode, instwidth[aryno], 
		  c, rd, rs);
	printval(immed);
d395 53
a447 51
	register int scaled  = (inst >> 9) & 01;
	register int rd      = (inst >> 21) & 037;
	register int rs1     = (inst >> 16) & 037;
	register int rs2     = inst & 037;
	register int st_lda  = (inst >> 12) & 03;
	register int aryno   = (inst >> 10) & 03;
	register int user_bit = 0;
	int signed_fg  = 1;
	char *user           = "    ";
	char c = ' ';

	if (!st_lda) {
		if ((aryno == 0) || (aryno == 01))
			opcode = "xmem";
		else
			opcode = "ld";
		if (aryno == 0)
			aryno = 03;
		if (!(aryno == 01)) {
			c = 'u';
			signed_fg = 0;
		}
	} else
		if (st_lda == 01)
		opcode = "ld";

	if (!(st_lda == 03)) {
		user_bit = (inst >> 8) & 01;
		if (user_bit)
			user = ".usr";
	}

	if (user_bit && signed_fg && (aryno == 01)) {
		if (st_lda)
			db_printf("\t%s%s\tr%-3d,r%-3d", opcode,
				  user, rd, rs1);
		else
			db_printf("\t%s%s\tr%-3d,r%-3d", opcode,
				  user, rd, rs1);
	} else
		if (user_bit && signed_fg)
		db_printf("\t%s%s%s\tr%-3d,r%-3d", opcode, 
			  instwidth[aryno], user, rd, rs1);
	else
		db_printf("\t%s%s%c%s\tr%-3d,r%-3d", opcode, 
			  instwidth[aryno], c, user, rd, rs1);

	if (scaled)
		db_printf("[r%-3d]", rs2);
	else
		db_printf(",r%-3d", rs2);
d455 10
a464 10
	register int rd   = (inst >> 21) & 037;
	register int rs1  = (inst >> 16) & 037;
	register int rs2  = inst & 037;
	register int complemt = (inst >> 10) & 01;
	char *c = "  ";

	if (complemt)
		c = ".c";

	db_printf("\t%s%s\t\tr%-3d,r%-3d,r%-3d", opcode, c, rd, rs1, rs2);
d472 22
a493 10
	register int rd   = (inst >> 21) & 037;
	register int rs1  = (inst >> 16) & 037;
	register int rs2  = inst & 037;
	register int carry = (inst >> 8) & 03;
	register int nochar = (inst >> 10) & 07;
	register int nodecode = (inst >> 11) & 01;
	char *tab, *c ;

	if (nochar > 02)
		tab = "\t\t";
d495 7
a501 18
		tab = "\t";

	if (!nodecode) {
		if (carry == 01)
			c = ".co ";
		else
			if (carry == 02)
			c = ".ci ";
		else
			if (carry == 03)
			c = ".cio";
		else
			c = "    ";
	} else
		c = "    ";

	db_printf("\t%s%s%sr%-3d,r%-3d,r%-3d", opcode, c,
		  tab, rd, rs1, rs2);
d505 3
a507 3
	unsigned mask, match;
	void (*opfun) __P((int, char *, long));
	char *farg;
d510 1
a510 1
	/* ORDER IS IMPORTANT BELOW */
d512 91
a602 91
	{   0xF0000000U, 0x00000000U, immem, 0,},
	{   0xF0000000U, 0x10000000U, immem, 0,},
	{   0xF0000000U, 0x20000000U, immem, "st"},
	{   0xF0000000U, 0x30000000U, immem, "lda"},

	{   0xF8000000U, 0x40000000U, oimmed, "and"},
	{   0xF8000000U, 0x48000000U, oimmed, "mask"},
	{   0xF8000000U, 0x50000000U, oimmed, "xor"},
	{   0xF8000000U, 0x58000000U, oimmed, "or"},
	{   0xFC000000U, 0x60000000U, oimmed, "addu"},
	{   0xFC000000U, 0x64000000U, oimmed, "subu"},
	{   0xFC000000U, 0x68000000U, oimmed, "divu"},
	{   0xFC000000U, 0x6C000000U, oimmed, "mul"},
	{   0xFC000000U, 0x70000000U, oimmed, "add"},
	{   0xFC000000U, 0x74000000U, oimmed, "sub"},
	{   0xFC000000U, 0x78000000U, oimmed, "div"},
	{   0xFC000000U, 0x7C000000U, oimmed, "cmp"},

	{   0xFC00F800U, 0x80004000U, ctrlregs, "ldcr"},
	{   0xFC00F800U, 0x80004800U, ctrlregs, "fldcr"},
	{   0xFC00F800U, 0x80008000U, ctrlregs, "stcr"},
	{   0xFC00F800U, 0x80008800U, ctrlregs, "fstcr"},
	{   0xFC00F800U, 0x8000C000U, ctrlregs, "xcr"},
	{   0xFC00F800U, 0x8000C800U, ctrlregs, "fxcr"},

	{   0xFC00F800U, 0x84000000U, sindou, "fmul"},
	{   0xFC1FFF80U, 0x84002000U, sindou, "flt"},
	{   0xFC00F800U, 0x84002800U, sindou, "fadd"},
	{   0xFC00F800U, 0x84003000U, sindou, "fsub"},
	{   0xFC00F860U, 0x84003800U, sindou, "fcmp"},
	{   0xFC1FFE60U, 0x84004800U, sindou, "int"},
	{   0xFC1FFE60U, 0x84005000U, sindou, "nint"},
	{   0xFC1FFE60U, 0x84005800U, sindou, "trnc"},
	{   0xFC00F800U, 0x84007000U, sindou, "fdiv"},

	{   0xF8000000U, 0xC0000000U, obranch, "br"},
	{   0xF8000000U, 0xC8000000U, obranch, "bsr"},

	{   0xF8000000U, 0xD0000000U, brcond, "bb0"},
	{   0xF8000000U, 0xD8000000U, brcond, "bb1"},
	{   0xF8000000U, 0xE8000000U, brcond, "bcnd"},

	{   0xFC00FC00U, 0xF0008000U, obit, "clr"},
	{   0xFC00FC00U, 0xF0008800U, obit, "set"},
	{   0xFC00FC00U, 0xF0009000U, obit, "ext"},
	{   0xFC00FC00U, 0xF0009800U, obit, "extu"},
	{   0xFC00FC00U, 0xF000A000U, obit, "mak"},
	{   0xFC00FC00U, 0xF000A800U, obit, "rot"},

	{   0xFC00FE00U, 0xF000D000U, otrap, "tb0"},
	{   0xFC00FE00U, 0xF000D800U, otrap, "tb1"},
	{   0xFC00FE00U, 0xF000E800U, otrap, "tcnd"},

	{   0xFC00F2E0U, 0xF4000000U, nimmem, 0,},
	{   0xFC00F2E0U, 0xF4000200U, nimmem, 0,},
	{   0xFC00F2E0U, 0xF4001000U, nimmem, 0,},
	{   0xFC00F2E0U, 0xF4001200U, nimmem, 0,},
	{   0xFC00F2E0U, 0xF4002000U, nimmem, "st"},
	{   0xFC00F2E0U, 0xF4002200U, nimmem, "st"},
	{   0xFC00F2E0U, 0xF4003000U, nimmem, "lda"},
	{   0xFC00F2E0U, 0xF4003200U, nimmem, "lda"},

	{   0xFC00FBE0U, 0xF4004000U, lognim, "and"},
	{   0xFC00FBE0U, 0xF4005000U, lognim, "xor"},
	{   0xFC00FBE0U, 0xF4005800U, lognim, "or"},

	{   0xFC00FCE0U, 0xF4006000U, onimmed, "addu"},
	{   0xFC00FCE0U, 0xF4006400U, onimmed, "subu"},
	{   0xFC00FCE0U, 0xF4006800U, onimmed, "divu"},
	{   0xFC00FCE0U, 0xF4006C00U, onimmed, "mul"},
	{   0xFC00FCE0U, 0xF4007000U, onimmed, "add"},
	{   0xFC00FCE0U, 0xF4007400U, onimmed, "sub"},
	{   0xFC00FCE0U, 0xF4007800U, onimmed, "div"},
	{   0xFC00FCE0U, 0xF4007C00U, onimmed, "cmp"},

	{   0xFC00FFE0U, 0xF4008000U, bitman, "clr"},
	{   0xFC00FFE0U, 0xF4008800U, bitman, "set"},
	{   0xFC00FFE0U, 0xF4009000U, bitman, "ext"},
	{   0xFC00FFE0U, 0xF4009800U, bitman, "extu"},
	{   0xFC00FFE0U, 0xF400A000U, bitman, "mak"},
	{   0xFC00FFE0U, 0xF400A800U, bitman, "rot"},

	{   0xFC00FBE0U, 0xF400C000U, jump, "jmp"},
	{   0xFC00FBE0U, 0xF400C800U, jump, "jsr"},

	{   0xFC00FFE0U, 0xF400E800U, instset, "ff1"},
	{   0xFC00FFE0U, 0xF400EC00U, instset, "ff0"},
	{   0xFC00FFE0U, 0xF400F800U, instset, "tbnd"},
	{   0xFC00FFE0U, 0xF400FC00U, instset, "rte"},
	{   0xFC000000U, 0xF8000000U, instset, "tbnd"},
	{   0,0,0,0}
d610 13
a622 14
	register struct opdesc *p;

	/* this messes up "orb" instructions ever so slightly, */
	/* but keeps us in sync between routines... */
	if (inst == 0) {
		db_printf ("\t.word 0");
	} else {
		for (p = opdecode; p->mask; p++)
			if ((inst & p->mask) == p->match) {
				(*p->opfun) (inst, p->farg, iadr);
				break;
			}
		if (!p->mask)
			db_printf (badop);
d624 3
d628 1
a628 1
	return iadr+4;
d634 3
a636 3
	m88k_print_instruction(loc, db_get_value(loc, 4, FALSE));
	db_printf ("\n");
	return loc+4;
@


1.8.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.8.2.1 2002/01/31 22:55:17 niklas Exp $	*/
d152 16
a167 16
void oimmed(int, char *, long);
void ctrlregs(int, char *, long);
void printsod(int);
void sindou(int, char *, long);
void jump(int, char *, long);
void instset(int, char *, long);
void symofset(int, int, int);
void obranch(int, char *, long);
void brcond(int, char *, long);
void otrap(int, char *, long);
void obit(int, char *, long);
void bitman(int, char *, long);
void immem(int, char *, long);
void nimmem(int, char *, long);
void lognim(int, char *, long);
void onimmed(int, char *, long);      
d296 1
a296 1
	db_printsym(addr,DB_STGY_PROC, db_printf);
d554 1
a554 1
	void (*opfun)(int, char *, long);
@


1.7
log
@Support for MVME197 completed.  Fix SPL defs.
@
text
@a32 1
#include <sys/param.h>		/* cputyp and friends */
d50 1
a50 1
static char *m88100_ctrlreg[64] = {
a85 54
static char *m88110_ctrlreg[64] = {
	"cr0(PID)   ",
	"cr1(PSR)   ",
	"cr2(EPSR)  ",
	0,
	"cr4(EXIP)  ",
	"cr5(ENIP)  ",
	0,
	"cr7(VBR)   ",
	0,
	0,
	0,
	0,
	0,
	0,
	"cr14(RES1) ",
	"cr15(RES2) ",
	"cr16(SR0)  ",
	"cr17(SR1)  ",
	"cr18(SR2)  ",
	"cr19(SR3)  ",
	"cr20(SR4)  ",
	0,
	0,
	0,
	0,
	"cr25(ICMD) ",
	"cr26(ICTL) ",
	"cr27(ISAR) ",
	"cr28(ISAP) ",
	"cr29(IUAP) ",
	"cr30(IIR)  ",
	"cr31(IBP)  ",
	"cr32(IPPU) ",
	"cr33(IPPL) ",
	"cr34(ISR)  ",
	"cr35(ILAR) ",
	"cr36(IPAR) ",
	0,0,0,
	"cr40(DCMD) ",
	"cr41(DCTL) ",
	"cr42(DSAR) ",
	"cr43(DSAP) ",
	"cr44(DUAP) ",
	"cr45(DIR)  ",
	"cr46(DBP)  ",
	"cr47(DPPU) ",
	"cr48(DPPL) ",
	"cr49(DSR)  ",
	"cr50(DLAR) ",
	"cr51(DPAR) ",
	0,0,0,0,0,0,0,0,0,0,0,0
};

d145 1
a145 2
    db_printf("\t\tr%-3d,%s", rd, 
	      cputyp == CPU_88100 ? m88100_ctrlreg[creg] : m88110_ctrlreg[creg]);
d147 1
a147 2
    db_printf("\t\tr%-3d,%s", rs1, 
	      cputyp == CPU_88100 ? m88100_ctrlreg[creg] : m88110_ctrlreg[creg]);
d149 1
a149 2
    db_printf("\t\tr%-3d,r%-3d,%s", rd, rs1,
              cputyp == CPU_88100 ? m88100_ctrlreg[creg] : m88110_ctrlreg[creg]);
@


1.6
log
@Add prototypes, fix compilation warnings, random style fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.5 2001/03/08 00:02:17 miod Exp $	*/
d33 1
d51 1
a51 1
static char *ctrlreg[64] = {
d87 54
d200 2
a201 1
    db_printf("\t\tr%-3d,%s", rd, ctrlreg[creg]);
d203 2
a204 1
    db_printf("\t\tr%-3d,%s", rs1, ctrlreg[creg]);
d206 2
a207 1
    db_printf("\t\tr%-3d,r%-3d,%s", rd, rs1, ctrlreg[creg]);
@


1.5
log
@Some warning hunting.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.4 1999/02/09 06:36:24 smurph Exp $	*/
d33 2
d36 1
d40 1
d94 18
d113 2
a114 2
static void
oimmed(long inst, char  *opcode, long iadr)
d134 2
a135 2
static void
ctrlregs(long inst, char *opcode, long iadr)
d153 1
a153 1
static void
d163 1
a163 1
static void
d191 2
a192 2
static void
jump(long inst, char *opcode, long iadr)
d207 2
a208 2
static void
instset(long inst, char *opcode, long iadr)
d227 1
a227 1
static void
d243 1
a243 1
static void
d261 1
a261 1
static void
d290 1
a290 1
  symofset(disp,16, iadr);
d294 1
a294 1
static void
d323 1
a323 1
static void
d348 1
a348 1
static void
d361 1
a361 1
static void
d392 1
a392 1
static void
d452 1
a452 1
static void
d469 1
a469 1
static void
d506 1
a506 1
    void (*opfun) ();
@


1.4
log
@Added kernel support for user debugging.  Fixed file ID's
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.28 1995/04/19 22:37:27 smurph Exp $	*/
d82 7
a88 1
#define printval(x)  if (x<0) db_printf ("-0x%X", -x); else db_printf("0x%X",x)
@


1.4.6.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.5 2001/03/08 00:02:17 miod Exp $	*/
d82 1
a82 7
#define printval(x) \
	do { \
		if ((x) < 0) \
			db_printf("-0x%X", -(x)); \
		else \
			db_printf("0x%X", (x));	\
	} while (0)
@


1.4.6.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.4.6.1 2001/04/18 16:10:50 niklas Exp $	*/
a32 2
#include <sys/types.h>

a33 1

a36 1
#include <ddb/db_interface.h>
a89 18
/* prototypes */
void oimmed __P((int, char *, long));
void ctrlregs __P((int, char *, long));
void printsod __P((int));
void sindou __P((int, char *, long));
void jump __P((int, char *, long));
void instset __P((int, char *, long));
void symofset __P((int, int, int));
void obranch __P((int, char *, long));
void brcond __P((int, char *, long));
void otrap __P((int, char *, long));
void obit __P((int, char *, long));
void bitman __P((int, char *, long));
void immem __P((int, char *, long));
void nimmem __P((int, char *, long));
void lognim __P((int, char *, long));
void onimmed __P((int, char *, long));

d91 2
a92 2
void
oimmed(int inst, char  *opcode, long iadr)
d112 2
a113 2
void
ctrlregs(int inst, char *opcode, long iadr)
d131 1
a131 1
void
d141 1
a141 1
void
d169 2
a170 2
void
jump(int inst, char *opcode, long iadr)
d185 2
a186 2
void
instset(int inst, char *opcode, long iadr)
d205 1
a205 1
void
d221 1
a221 1
void
d239 1
a239 1
void
d268 1
a268 1
  symofset(disp, 16, iadr);
d272 1
a272 1
void
d301 1
a301 1
void
d326 1
a326 1
void
d339 1
a339 1
void
d370 1
a370 1
void
d430 1
a430 1
void
d447 1
a447 1
void
d484 1
a484 1
    void (*opfun) __P((int, char *, long));
@


1.4.6.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a32 1
#include <sys/param.h>		/* cputyp and friends */
d50 1
a50 1
static char *m88100_ctrlreg[64] = {
a85 56
static char *m88110_ctrlreg[64] = {
	"cr0(PID)   ",
	"cr1(PSR)   ",
	"cr2(EPSR)  ",
	0,
	"cr4(EXIP)  ",
	"cr5(ENIP)  ",
	0,
	"cr7(VBR)   ",
	0,
	0,
	0,
	0,
	0,
	0,
	"cr14(RES1) ",
	"cr15(RES2) ",
	"cr16(SR0)  ",
	"cr17(SR1)  ",
	"cr18(SR2)  ",
	"cr19(SR3)  ",
	"cr20(SR4)  ",
	"fcr0(FPECR)",
	0,
	0,
	0,
	"cr25(ICMD) ",
	"cr26(ICTL) ",
	"cr27(ISAR) ",
	"cr28(ISAP) ",
	"cr29(IUAP) ",
	"cr30(IIR)  ",
	"cr31(IBP)  ",
	"cr32(IPPU) ",
	"cr33(IPPL) ",
	"cr34(ISR)  ",
	"cr35(ILAR) ",
	"cr36(IPAR) ",
	0,0,0,
	"cr40(DCMD) ",
	"cr41(DCTL) ",
	"cr42(DSAR) ",
	"cr43(DSAP) ",
	"cr44(DUAP) ",
	"cr45(DIR)  ",
	"cr46(DBP)  ",
	"cr47(DPPU) ",
	"cr48(DPPL) ",
	"cr49(DSR)  ",
	"cr50(DLAR) ",
	"cr51(DPAR) ",
	0,0,0,0,0,0,0,0,0,0,
	"fcr62(FPSR)",
	"fcr63(FPCR)"
};

d110 1
a110 1
void onimmed __P((int, char *, long));      
d112 1
a112 1
/* Handlers immediate integer arithmetic instructions */
d116 14
a129 14
	register int Linst = inst & 0177777;
	register int Hinst = inst >> 16;
	register int H6inst = Hinst >> 10;
	register int rs1 = Hinst & 037;
	register int rd = ( Hinst >> 5 ) & 037;

	if (( H6inst > 017 ) && ( H6inst < 030 ) && ( H6inst & 01) == 1 )
		db_printf("\t%s.u",opcode);
	else {
		db_printf("\t%s",opcode);
		db_printf("  ");
	}
	db_printf("\t\tr%-3d,r%-3d,", rd, rs1);
	printval(Linst);
d137 13
a149 16
	register int L6inst = (inst >> 11) & 037;
	register int creg = (inst >> 5) & 077;
	register int rd = (inst >> 21) & 037;
	register int rs1 = (inst >> 16) & 037;

	db_printf("\t%s",opcode);

	if ( L6inst == 010 || L6inst == 011 )
		db_printf("\t\tr%-3d,%s", rd, 
			  cputyp == CPU_88100 ? m88100_ctrlreg[creg] : m88110_ctrlreg[creg]);
	else if ( L6inst == 020 || L6inst == 021 )
		db_printf("\t\tr%-3d,%s", rs1, 
			  cputyp == CPU_88100 ? m88100_ctrlreg[creg] : m88110_ctrlreg[creg]);
	else
		db_printf("\t\tr%-3d,r%-3d,%s", rd, rs1,
			  cputyp == CPU_88100 ? m88100_ctrlreg[creg] : m88110_ctrlreg[creg]);
d156 4
a159 4
	if ( t == 0 )
		db_printf("s");
	else
		db_printf("d");
d166 22
a187 21
	register int rs2 = inst & 037;
	register int td = ( inst >> 5 ) & 03;
	register int t2 = ( inst >> 7 ) & 03;
	register int t1 = ( inst >> 9 ) & 03;
	register int rs1 = ( inst >> 16 ) & 037;
	register int rd = ( inst >> 21 ) & 037;
	register int checkbits  = ( inst >> 11 ) & 037;

	db_printf("\t%s.",opcode);
	printsod(td);
	if (( checkbits > 010 && checkbits < 014 ) || ( checkbits == 04 )) {
		printsod(t2);
		db_printf(" ");
		if ( checkbits == 012 || checkbits == 013 )
			db_printf("\t\tr%-3d,r%-3d", rd, rs2);
		else
			db_printf("\t\tr%-3d,r%-3d", rd, rs2);
	} else {
		printsod(t1);printsod(t2);
		db_printf("\t\tr%-3d,r%-3d,r%-3d", rd, rs1, rs2);
	}
d194 9
a202 9
	register int rs2 = inst & 037;
	register int Nbit = ( inst >> 10 ) & 01;

	db_printf("\t%s",opcode);
	if ( Nbit == 1 )
		db_printf(".n");
	else
		db_printf("  ");
	db_printf("\t\tr%-3d",rs2);
d210 15
a224 14
	register int rs2 = inst & 037;
	register int rs1 = ( inst >> 16 ) & 037;
	register int rd = ( inst >> 21 ) & 037;
	register int checkbits = ( inst >> 10 ) & 077;
	register int H6inst = ( inst >> 26 ) & 077;

	db_printf("\t%s",opcode);
	if ( H6inst == 076 ) {
		db_printf("\t\tr%-3d,",rs1);
		printval(inst & 0177777);
	} else if (( checkbits == 072 ) || ( checkbits == 073 ))
		db_printf("\t\tr%-3d,r%-3d", rd, rs2);
	else if ( checkbits == 076 )
		db_printf("\t\tr%-3d,r%-3d",rs1,rs2);
d230 1
a230 1
	long addr;
d232 9
a240 8
	if ( disp & (1 << (bit-1)) ) {
		/* negative value */
		addr = iadr + ((disp << 2) | (~0 << bit));
	} else {
		addr = iadr + (disp << 2);
	}
	db_printsym(addr,DB_STGY_PROC);
	return;
d246 11
a256 10
	int cond = ( inst >> 26 ) & 01;
	int disp = inst &0377777777;

	if ( cond == 0 ) {
		db_printf("\t%s\t\t",opcode);
		symofset(disp, 26, iadr);
	} else {
		db_printf("\t%s.n\t\t",opcode);
		symofset(disp, 26, iadr);
	}
d264 24
a287 4
	int cond = ( inst >> 26 ) & 1;
	int match = ( inst >> 21 ) & 037;
	int rs = ( inst >> 16 ) & 037;
	int disp = ( inst & 0177777 );
d289 2
a290 21
	if ( cond == 0 )
		db_printf("\t%s\t\t", opcode);
	else
		db_printf("\t%s.n\t\t", opcode);
	if ( ( ( inst >> 27 ) & 03 ) == 1 )
		switch (match) {
		case 1 : db_printf("%s,", condname[0]); break;
		case 2 : db_printf("%s,", condname[1]); break;
		case 3 : db_printf("%s,", condname[2]); break;
		case 12: db_printf("%s,", condname[3]); break;
		case 13: db_printf("%s,", condname[4]); break;
		case 14: db_printf("%s,", condname[5]); break;
		default: printval(match); 
			db_printf(",");
		} else {
		printval(match);
		db_printf(",");
	}

	db_printf("r%-3d,", rs);
	symofset(disp, 16, iadr);
d297 22
a318 21
	int vecno = inst & 0777;
	int match = ( inst >> 21 ) & 037;
	int rs = ( inst >> 16 ) & 037;

	db_printf("\t%s\t",opcode);
	if ( ( ( inst >> 12 ) & 017 ) == 0xe )
		switch (match) {
		case 1 : db_printf("%s,", condname[0]);break;
		case 2 : db_printf("%s,", condname[1]);break;
		case 3 : db_printf("%s,", condname[2]);break;
		case 12: db_printf("%s,", condname[3]);break;
		case 13: db_printf("%s,", condname[4]);break;
		case 14: db_printf("%s,", condname[5]);break;
		default: printval(match);
			db_printf(",");
		} else {
		printval(match);
		db_printf(",");
	}
	db_printf("\tr%-3d,", rs);
	printval(vecno);
d326 18
a343 16
	int rs = ( inst >> 16 ) & 037;
	int rd = ( inst >> 21 ) & 037;
	int width = ( inst >> 5 ) & 037;
	int offset = ( inst & 037 );  

	db_printf("\t%s\t\tr%-3d,r%-3d,", opcode, rd, rs); 
	if ( ( ( inst >> 10 ) & 077 ) == 052 ) {
		db_printf("<"); 
		printval(offset); 
		db_printf(">"); 
	} else {
		printval(width);
		db_printf("<");
		printval(offset);
		db_printf(">");
	}
d351 6
a356 6

	int rs1 = ( inst >> 16 ) & 037;
	int rd  = ( inst >> 21 ) & 037;
	int rs2 = inst & 037;

	db_printf("\t%s\t\tr%-3d,r%-3d,r%-3d", opcode, rd, rs1, rs2);
d364 24
a387 23
	register int immed  = inst & 0xFFFF;
	register int rd     = (inst >> 21) & 037;
	register int rs     = (inst >> 16) & 037;
	register int st_lda = (inst >> 28) & 03;
	register int aryno  = (inst >> 26) & 03;
	char c = ' ';

	if (!st_lda) {
		if ((aryno == 0) || (aryno == 01))
			opcode = "xmem";
		else
			opcode = "ld";
		if (aryno == 0)
			aryno = 03;
		if (!(aryno == 01))
			c = 'u';
	} else
		if (st_lda == 01)
		opcode = "ld";

	db_printf("\t%s%s%c\t\tr%-3d,r%-3d,", opcode, instwidth[aryno], 
		  c, rd, rs);
	printval(immed);
d395 53
a447 51
	register int scaled  = (inst >> 9) & 01;
	register int rd      = (inst >> 21) & 037;
	register int rs1     = (inst >> 16) & 037;
	register int rs2     = inst & 037;
	register int st_lda  = (inst >> 12) & 03;
	register int aryno   = (inst >> 10) & 03;
	register int user_bit = 0;
	int signed_fg  = 1;
	char *user           = "    ";
	char c = ' ';

	if (!st_lda) {
		if ((aryno == 0) || (aryno == 01))
			opcode = "xmem";
		else
			opcode = "ld";
		if (aryno == 0)
			aryno = 03;
		if (!(aryno == 01)) {
			c = 'u';
			signed_fg = 0;
		}
	} else
		if (st_lda == 01)
		opcode = "ld";

	if (!(st_lda == 03)) {
		user_bit = (inst >> 8) & 01;
		if (user_bit)
			user = ".usr";
	}

	if (user_bit && signed_fg && (aryno == 01)) {
		if (st_lda)
			db_printf("\t%s%s\tr%-3d,r%-3d", opcode,
				  user, rd, rs1);
		else
			db_printf("\t%s%s\tr%-3d,r%-3d", opcode,
				  user, rd, rs1);
	} else
		if (user_bit && signed_fg)
		db_printf("\t%s%s%s\tr%-3d,r%-3d", opcode, 
			  instwidth[aryno], user, rd, rs1);
	else
		db_printf("\t%s%s%c%s\tr%-3d,r%-3d", opcode, 
			  instwidth[aryno], c, user, rd, rs1);

	if (scaled)
		db_printf("[r%-3d]", rs2);
	else
		db_printf(",r%-3d", rs2);
d455 10
a464 10
	register int rd   = (inst >> 21) & 037;
	register int rs1  = (inst >> 16) & 037;
	register int rs2  = inst & 037;
	register int complemt = (inst >> 10) & 01;
	char *c = "  ";

	if (complemt)
		c = ".c";

	db_printf("\t%s%s\t\tr%-3d,r%-3d,r%-3d", opcode, c, rd, rs1, rs2);
d472 22
a493 10
	register int rd   = (inst >> 21) & 037;
	register int rs1  = (inst >> 16) & 037;
	register int rs2  = inst & 037;
	register int carry = (inst >> 8) & 03;
	register int nochar = (inst >> 10) & 07;
	register int nodecode = (inst >> 11) & 01;
	char *tab, *c ;

	if (nochar > 02)
		tab = "\t\t";
d495 7
a501 18
		tab = "\t";

	if (!nodecode) {
		if (carry == 01)
			c = ".co ";
		else
			if (carry == 02)
			c = ".ci ";
		else
			if (carry == 03)
			c = ".cio";
		else
			c = "    ";
	} else
		c = "    ";

	db_printf("\t%s%s%sr%-3d,r%-3d,r%-3d", opcode, c,
		  tab, rd, rs1, rs2);
d505 3
a507 3
	unsigned mask, match;
	void (*opfun) __P((int, char *, long));
	char *farg;
d510 1
a510 1
	/* ORDER IS IMPORTANT BELOW */
d512 91
a602 91
	{   0xF0000000U, 0x00000000U, immem, 0,},
	{   0xF0000000U, 0x10000000U, immem, 0,},
	{   0xF0000000U, 0x20000000U, immem, "st"},
	{   0xF0000000U, 0x30000000U, immem, "lda"},

	{   0xF8000000U, 0x40000000U, oimmed, "and"},
	{   0xF8000000U, 0x48000000U, oimmed, "mask"},
	{   0xF8000000U, 0x50000000U, oimmed, "xor"},
	{   0xF8000000U, 0x58000000U, oimmed, "or"},
	{   0xFC000000U, 0x60000000U, oimmed, "addu"},
	{   0xFC000000U, 0x64000000U, oimmed, "subu"},
	{   0xFC000000U, 0x68000000U, oimmed, "divu"},
	{   0xFC000000U, 0x6C000000U, oimmed, "mul"},
	{   0xFC000000U, 0x70000000U, oimmed, "add"},
	{   0xFC000000U, 0x74000000U, oimmed, "sub"},
	{   0xFC000000U, 0x78000000U, oimmed, "div"},
	{   0xFC000000U, 0x7C000000U, oimmed, "cmp"},

	{   0xFC00F800U, 0x80004000U, ctrlregs, "ldcr"},
	{   0xFC00F800U, 0x80004800U, ctrlregs, "fldcr"},
	{   0xFC00F800U, 0x80008000U, ctrlregs, "stcr"},
	{   0xFC00F800U, 0x80008800U, ctrlregs, "fstcr"},
	{   0xFC00F800U, 0x8000C000U, ctrlregs, "xcr"},
	{   0xFC00F800U, 0x8000C800U, ctrlregs, "fxcr"},

	{   0xFC00F800U, 0x84000000U, sindou, "fmul"},
	{   0xFC1FFF80U, 0x84002000U, sindou, "flt"},
	{   0xFC00F800U, 0x84002800U, sindou, "fadd"},
	{   0xFC00F800U, 0x84003000U, sindou, "fsub"},
	{   0xFC00F860U, 0x84003800U, sindou, "fcmp"},
	{   0xFC1FFE60U, 0x84004800U, sindou, "int"},
	{   0xFC1FFE60U, 0x84005000U, sindou, "nint"},
	{   0xFC1FFE60U, 0x84005800U, sindou, "trnc"},
	{   0xFC00F800U, 0x84007000U, sindou, "fdiv"},

	{   0xF8000000U, 0xC0000000U, obranch, "br"},
	{   0xF8000000U, 0xC8000000U, obranch, "bsr"},

	{   0xF8000000U, 0xD0000000U, brcond, "bb0"},
	{   0xF8000000U, 0xD8000000U, brcond, "bb1"},
	{   0xF8000000U, 0xE8000000U, brcond, "bcnd"},

	{   0xFC00FC00U, 0xF0008000U, obit, "clr"},
	{   0xFC00FC00U, 0xF0008800U, obit, "set"},
	{   0xFC00FC00U, 0xF0009000U, obit, "ext"},
	{   0xFC00FC00U, 0xF0009800U, obit, "extu"},
	{   0xFC00FC00U, 0xF000A000U, obit, "mak"},
	{   0xFC00FC00U, 0xF000A800U, obit, "rot"},

	{   0xFC00FE00U, 0xF000D000U, otrap, "tb0"},
	{   0xFC00FE00U, 0xF000D800U, otrap, "tb1"},
	{   0xFC00FE00U, 0xF000E800U, otrap, "tcnd"},

	{   0xFC00F2E0U, 0xF4000000U, nimmem, 0,},
	{   0xFC00F2E0U, 0xF4000200U, nimmem, 0,},
	{   0xFC00F2E0U, 0xF4001000U, nimmem, 0,},
	{   0xFC00F2E0U, 0xF4001200U, nimmem, 0,},
	{   0xFC00F2E0U, 0xF4002000U, nimmem, "st"},
	{   0xFC00F2E0U, 0xF4002200U, nimmem, "st"},
	{   0xFC00F2E0U, 0xF4003000U, nimmem, "lda"},
	{   0xFC00F2E0U, 0xF4003200U, nimmem, "lda"},

	{   0xFC00FBE0U, 0xF4004000U, lognim, "and"},
	{   0xFC00FBE0U, 0xF4005000U, lognim, "xor"},
	{   0xFC00FBE0U, 0xF4005800U, lognim, "or"},

	{   0xFC00FCE0U, 0xF4006000U, onimmed, "addu"},
	{   0xFC00FCE0U, 0xF4006400U, onimmed, "subu"},
	{   0xFC00FCE0U, 0xF4006800U, onimmed, "divu"},
	{   0xFC00FCE0U, 0xF4006C00U, onimmed, "mul"},
	{   0xFC00FCE0U, 0xF4007000U, onimmed, "add"},
	{   0xFC00FCE0U, 0xF4007400U, onimmed, "sub"},
	{   0xFC00FCE0U, 0xF4007800U, onimmed, "div"},
	{   0xFC00FCE0U, 0xF4007C00U, onimmed, "cmp"},

	{   0xFC00FFE0U, 0xF4008000U, bitman, "clr"},
	{   0xFC00FFE0U, 0xF4008800U, bitman, "set"},
	{   0xFC00FFE0U, 0xF4009000U, bitman, "ext"},
	{   0xFC00FFE0U, 0xF4009800U, bitman, "extu"},
	{   0xFC00FFE0U, 0xF400A000U, bitman, "mak"},
	{   0xFC00FFE0U, 0xF400A800U, bitman, "rot"},

	{   0xFC00FBE0U, 0xF400C000U, jump, "jmp"},
	{   0xFC00FBE0U, 0xF400C800U, jump, "jsr"},

	{   0xFC00FFE0U, 0xF400E800U, instset, "ff1"},
	{   0xFC00FFE0U, 0xF400EC00U, instset, "ff0"},
	{   0xFC00FFE0U, 0xF400F800U, instset, "tbnd"},
	{   0xFC00FFE0U, 0xF400FC00U, instset, "rte"},
	{   0xFC000000U, 0xF8000000U, instset, "tbnd"},
	{   0,0,0,0}
d610 13
a622 14
	register struct opdesc *p;

	/* this messes up "orb" instructions ever so slightly, */
	/* but keeps us in sync between routines... */
	if (inst == 0) {
		db_printf ("\t.word 0");
	} else {
		for (p = opdecode; p->mask; p++)
			if ((inst & p->mask) == p->match) {
				(*p->opfun) (inst, p->farg, iadr);
				break;
			}
		if (!p->mask)
			db_printf (badop);
d624 3
d628 1
a628 1
	return iadr+4;
d634 3
a636 3
	m88k_print_instruction(loc, db_get_value(loc, 4, FALSE));
	db_printf ("\n");
	return loc+4;
@


1.4.6.4
log
@Merge in -current from about a week ago
@
text
@d152 16
a167 16
void oimmed(int, char *, long);
void ctrlregs(int, char *, long);
void printsod(int);
void sindou(int, char *, long);
void jump(int, char *, long);
void instset(int, char *, long);
void symofset(int, int, int);
void obranch(int, char *, long);
void brcond(int, char *, long);
void otrap(int, char *, long);
void obit(int, char *, long);
void bitman(int, char *, long);
void immem(int, char *, long);
void nimmem(int, char *, long);
void lognim(int, char *, long);
void onimmed(int, char *, long);      
d554 1
a554 1
	void (*opfun)(int, char *, long);
@


1.4.6.5
log
@Sync the SMP branch with 3.3
@
text
@d296 1
a296 1
	db_printsym(addr,DB_STGY_PROC, db_printf);
@


1.4.6.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d43 1
a43 1
static const char *instwidth[4] = {
d47 1
a47 1
static const char *condname[6] = {
d49 1
a49 1
};
d51 1
a51 1
static const char *m88100_ctrlreg[64] = {
d82 1
a82 4
	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
d87 1
a87 1
static const char *m88110_ctrlreg[64] = {
d91 1
a91 1
	NULL,
d94 1
a94 1
	NULL,
d96 6
a101 6
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
d110 3
a112 3
	NULL,
	NULL,
	NULL,
d125 1
a125 3
	NULL,
	NULL,
	NULL,
d138 1
a138 2
	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
	NULL, NULL,
d152 2
a153 2
void oimmed(int, const char *, long);
void ctrlregs(int, const char *, long);
d155 3
a157 3
void sindou(int, const char *, long);
void jump(int, const char *, long);
void instset(int, const char *, long);
d159 9
a167 9
void obranch(int, const char *, long);
void brcond(int, const char *, long);
void otrap(int, const char *, long);
void obit(int, const char *, long);
void bitman(int, const char *, long);
void immem(int, const char *, long);
void nimmem(int, const char *, long);
void lognim(int, const char *, long);
void onimmed(int, const char *, long);
d171 1
a171 1
oimmed(int inst, const char  *opcode, long iadr)
d173 5
a177 5
	int Linst = inst & 0177777;
	int Hinst = inst >> 16;
	int H6inst = Hinst >> 10;
	int rs1 = Hinst & 037;
	int rd = ( Hinst >> 5 ) & 037;
d192 1
a192 1
ctrlregs(int inst, const char *opcode, long iadr)
d194 4
a197 4
	int L6inst = (inst >> 11) & 037;
	int creg = (inst >> 5) & 077;
	int rd = (inst >> 21) & 037;
	int rs1 = (inst >> 16) & 037;
d202 1
a202 1
		db_printf("\t\tr%-3d,%s", rd,
d205 1
a205 1
		db_printf("\t\tr%-3d,%s", rs1,
d224 1
a224 1
sindou(int inst, const char *opcode, long iadr)
d226 7
a232 7
	int rs2 = inst & 037;
	int td = ( inst >> 5 ) & 03;
	int t2 = ( inst >> 7 ) & 03;
	int t1 = ( inst >> 9 ) & 03;
	int rs1 = ( inst >> 16 ) & 037;
	int rd = ( inst >> 21 ) & 037;
	int checkbits  = ( inst >> 11 ) & 037;
d251 1
a251 1
jump(int inst, const char *opcode, long iadr)
d253 2
a254 2
	int rs2 = inst & 037;
	int Nbit = ( inst >> 10 ) & 01;
d265 1
a265 1
/* Handles ff1, ff0, tbnd and rte instructions */
d267 1
a267 1
instset(int inst, const char *opcode, long iadr)
d269 5
a273 5
	int rs2 = inst & 037;
	int rs1 = ( inst >> 16 ) & 037;
	int rd = ( inst >> 21 ) & 037;
	int checkbits = ( inst >> 10 ) & 077;
	int H6inst = ( inst >> 26 ) & 077;
d301 1
a301 1
obranch(int inst, const char *opcode, long iadr)
d318 1
a318 1
brcond(int inst, const char *opcode, long iadr)
d337 1
a337 1
		default: printval(match);
d350 1
a350 1
otrap(int inst, const char *opcode, long iadr)
d378 1
a378 1
obit(int inst, const char *opcode, long iadr)
d383 1
a383 1
	int offset = ( inst & 037 );
d385 1
a385 1
	db_printf("\t%s\t\tr%-3d,r%-3d,", opcode, rd, rs);
d387 3
a389 3
		db_printf("<");
		printval(offset);
		db_printf(">");
d401 1
a401 1
bitman(int inst, const char *opcode, long iadr)
d414 1
a414 1
immem(int inst, const char *opcode, long iadr)
d416 5
a420 5
	int immed  = inst & 0xFFFF;
	int rd     = (inst >> 21) & 037;
	int rs     = (inst >> 16) & 037;
	int st_lda = (inst >> 28) & 03;
	int aryno  = (inst >> 26) & 03;
d436 1
a436 1
	db_printf("\t%s%s%c\t\tr%-3d,r%-3d,", opcode, instwidth[aryno],
d444 1
a444 1
nimmem(int inst, const char *opcode, long iadr)
d446 7
a452 7
	int scaled  = (inst >> 9) & 01;
	int rd      = (inst >> 21) & 037;
	int rs1     = (inst >> 16) & 037;
	int rs2     = inst & 037;
	int st_lda  = (inst >> 12) & 03;
	int aryno   = (inst >> 10) & 03;
	int user_bit = 0;
d487 1
a487 1
		db_printf("\t%s%s%s\tr%-3d,r%-3d", opcode,
d490 1
a490 1
		db_printf("\t%s%s%c%s\tr%-3d,r%-3d", opcode,
d502 1
a502 1
lognim(int inst, const char *opcode, long iadr)
d504 4
a507 4
	int rd   = (inst >> 21) & 037;
	int rs1  = (inst >> 16) & 037;
	int rs2  = inst & 037;
	int complemt = (inst >> 10) & 01;
d519 1
a519 1
onimmed(int inst, const char *opcode, long iadr)
d521 6
a526 6
	int rd   = (inst >> 21) & 037;
	int rs1  = (inst >> 16) & 037;
	int rs2  = inst & 037;
	int carry = (inst >> 8) & 03;
	int nochar = (inst >> 10) & 07;
	int nodecode = (inst >> 11) & 01;
d552 1
a552 1
static const struct opdesc {
d554 2
a555 2
	void (*opfun)(int, const char *, long);
	const char *farg;
d560 2
a561 2
	{   0xF0000000U, 0x00000000U, immem, NULL},
	{   0xF0000000U, 0x10000000U, immem, NULL},
d613 4
a616 4
	{   0xFC00F2E0U, 0xF4000000U, nimmem, NULL},
	{   0xFC00F2E0U, 0xF4000200U, nimmem, NULL},
	{   0xFC00F2E0U, 0xF4001000U, nimmem, NULL},
	{   0xFC00F2E0U, 0xF4001200U, nimmem, NULL},
d650 1
a650 1
	{   0, 0, NULL, NULL}
d653 1
a653 1
static const char *badop = "\t???";
d658 1
a658 1
	const struct opdesc *p;
@


1.3
log
@Cleanup after import. This also seems to bring up the current version.
@
text
@d1 1
@


1.2
log
@This is a remove to get rid of the old mvme88k port which was incomplete
to replace it with a working version. The kernel compiles and works
at least.  The new version will be imported shortly.
@
text
@d43 1
a43 1
};
d76 1
a76 1
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
d80 1
d83 1
a83 1
/* Handlers immediate integer arithmetic instructions */
d85 1
a85 1
oimmed(long inst, char *opcode, long iadr)
d87 14
a100 14
	register int Linst = inst & 0177777;
	register int Hinst = inst >> 16;
	register int H6inst = Hinst >> 10;
	register int rs1 = Hinst & 037;
	register int rd = (Hinst >> 5) & 037;

	if ((H6inst > 017) && (H6inst < 030) && (H6inst & 01) == 1)
		db_printf("\t%s.u", opcode);
	else {
		db_printf("\t%s", opcode);
		db_printf("  ");
	}
	db_printf("\t\tr%-3d,r%-3d,", rd, rs1);
	printval(Linst);
d108 13
a120 14
	register int L6inst = (inst >> 11) & 037;
	register int creg = (inst >> 5) & 077;
	register int rd = (inst >> 21) & 037;
	register int rs1 = (inst >> 16) & 037;

	db_printf("\t%s", opcode);

	if (L6inst == 010 || L6inst == 011)
		db_printf("\t\tr%-3d,%s", rd, ctrlreg[creg]);
	else
		if (L6inst == 020 || L6inst == 021)
			db_printf("\t\tr%-3d,%s", rs1, ctrlreg[creg]);
		else
			db_printf("\t\tr%-3d,r%-3d,%s", rd, rs1, ctrlreg[creg]);
d127 4
a130 4
	if (t == 0)
		db_printf("s");
	else
		db_printf("d");
d132 1
d137 22
a158 22
	register int rs2 = inst & 037;
	register int td = (inst >> 5) & 03;
	register int t2 = (inst >> 7) & 03;
	register int t1 = (inst >> 9) & 03;
	register int rs1 = (inst >> 16) & 037;
	register int rd = (inst >> 21) & 037;
	register int checkbits = (inst >> 11) & 037;

	db_printf("\t%s.", opcode);
	printsod(td);
	if ((checkbits > 010 && checkbits < 014) || (checkbits == 04)) {
		printsod(t2);
		db_printf(" ");
		if (checkbits == 012 || checkbits == 013)
			db_printf("\t\tr%-3d,r%-3d", rd, rs2);
		else
			db_printf("\t\tr%-3d,r%-3d", rd, rs2);
	} else {
		printsod(t1);
		printsod(t2);
		db_printf("\t\tr%-3d,r%-3d,r%-3d", rd, rs1, rs2);
	}
d165 9
a173 9
	register int rs2 = inst & 037;
	register int Nbit = (inst >> 10) & 01;

	db_printf("\t%s", opcode);
	if (Nbit == 1)
		db_printf(".n");
	else
		db_printf("  ");
	db_printf("\t\tr%-3d", rs2);
d177 1
a177 1
/* Handles ff1, ff0, tbnd and rte instructions */
d181 15
a195 16
	register int rs2 = inst & 037;
	register int rs1 = (inst >> 16) & 037;
	register int rd = (inst >> 21) & 037;
	register int checkbits = (inst >> 10) & 077;
	register int H6inst = (inst >> 26) & 077;

	db_printf("\t%s", opcode);
	if (H6inst == 076) {
		db_printf("\t\tr%-3d,", rs1);
		printval(inst & 0177777);
	} else
		if ((checkbits == 072) || (checkbits == 073))
			db_printf("\t\tr%-3d,r%-3d", rd, rs2);
		else
			if (checkbits == 076)
				db_printf("\t\tr%-3d,r%-3d", rs1, rs2);
d199 13
a211 12
symofset(int disp, int bit, int iadr)
{
	long    addr;

	if (disp & (1 << (bit - 1))) {
		/* negative value */
		addr = iadr + ((disp << 2) | (~0 << bit));
	} else {
		addr = iadr + (disp << 2);
	}
	db_printsym(addr, DB_STGY_PROC);
	return;
d217 11
a227 10
	int     cond = (inst >> 26) & 01;
	int     disp = inst & 0377777777;

	if (cond == 0) {
		db_printf("\t%s\t\t", opcode);
		symofset(disp, 26, iadr);
	} else {
		db_printf("\t%s.n\t\t", opcode);
		symofset(disp, 26, iadr);
	}
d235 24
a258 37
	int     cond = (inst >> 26) & 1;
	int     match = (inst >> 21) & 037;
	int     rs = (inst >> 16) & 037;
	int     disp = (inst & 0177777);

	if (cond == 0)
		db_printf("\t%s\t\t", opcode);
	else
		db_printf("\t%s.n\t\t", opcode);
	if (((inst >> 27) & 03) == 1)
		switch (match) {
		case 1:
			db_printf("%s,", condname[0]);
			break;
		case 2:
			db_printf("%s,", condname[1]);
			break;
		case 3:
			db_printf("%s,", condname[2]);
			break;
		case 12:
			db_printf("%s,", condname[3]);
			break;
		case 13:
			db_printf("%s,", condname[4]);
			break;
		case 14:
			db_printf("%s,", condname[5]);
			break;
		default:
			printval(match);
			db_printf(",");
		}
	else {
		printval(match);
		db_printf(",");
	}
d260 2
a261 2
	db_printf("r%-3d,", rs);
	symofset(disp, 16, iadr);
d268 22
a289 35
	int     vecno = inst & 0777;
	int     match = (inst >> 21) & 037;
	int     rs = (inst >> 16) & 037;

	db_printf("\t%s\t", opcode);
	if (((inst >> 12) & 017) == 0xe)
		switch (match) {
		case 1:
			db_printf("%s,", condname[0]);
			break;
		case 2:
			db_printf("%s,", condname[1]);
			break;
		case 3:
			db_printf("%s,", condname[2]);
			break;
		case 12:
			db_printf("%s,", condname[3]);
			break;
		case 13:
			db_printf("%s,", condname[4]);
			break;
		case 14:
			db_printf("%s,", condname[5]);
			break;
		default:
			printval(match);
			db_printf(",");
		}
	else {
		printval(match);
		db_printf(",");
	}
	db_printf("\tr%-3d,", rs);
	printval(vecno);
d297 18
a314 16
	int     rs = (inst >> 16) & 037;
	int     rd = (inst >> 21) & 037;
	int     width = (inst >> 5) & 037;
	int     offset = (inst & 037);

	db_printf("\t%s\t\tr%-3d,r%-3d,", opcode, rd, rs);
	if (((inst >> 10) & 077) == 052) {
		db_printf("<");
		printval(offset);
		db_printf(">");
	} else {
		printval(width);
		db_printf("<");
		printval(offset);
		db_printf(">");
	}
d322 6
a327 6

	int     rs1 = (inst >> 16) & 037;
	int     rd = (inst >> 21) & 037;
	int     rs2 = inst & 037;

	db_printf("\t%s\t\tr%-3d,r%-3d,r%-3d", opcode, rd, rs1, rs2);
d335 22
a356 21
	register int immed = inst & 0xFFFF;
	register int rd = (inst >> 21) & 037;
	register int rs = (inst >> 16) & 037;
	register int st_lda = (inst >> 28) & 03;
	register int aryno = (inst >> 26) & 03;
	char    c = ' ';

	if (!st_lda) {
		if ((aryno == 0) || (aryno == 01))
			opcode = "xmem";
		else
			opcode = "ld";
		if (aryno == 0)
			aryno = 03;
		if (!(aryno == 01))
			c = 'u';
	} else
		if (st_lda == 01)
			opcode = "ld";

	db_printf("\t%s%s%c\t\tr%-3d,r%-3d,", opcode, instwidth[aryno],
d358 1
a358 1
	printval(immed);
d366 53
a418 50
	register int scaled = (inst >> 9) & 01;
	register int rd = (inst >> 21) & 037;
	register int rs1 = (inst >> 16) & 037;
	register int rs2 = inst & 037;
	register int st_lda = (inst >> 12) & 03;
	register int aryno = (inst >> 10) & 03;
	register int user_bit = 0;
	int     signed_fg = 1;
	char   *user = "    ";
	char    c = ' ';

	if (!st_lda) {
		if ((aryno == 0) || (aryno == 01))
			opcode = "xmem";
		else
			opcode = "ld";
		if (aryno == 0)
			aryno = 03;
		if (!(aryno == 01)) {
			c = 'u';
			signed_fg = 0;
		}
	} else
		if (st_lda == 01)
			opcode = "ld";

	if (!(st_lda == 03)) {
		user_bit = (inst >> 8) & 01;
		if (user_bit)
			user = ".usr";
	}
	if (user_bit && signed_fg && (aryno == 01)) {
		if (st_lda)
			db_printf("\t%s%s\tr%-3d,r%-3d", opcode,
			    user, rd, rs1);
		else
			db_printf("\t%s%s\tr%-3d,r%-3d", opcode,
			    user, rd, rs1);
	} else
		if (user_bit && signed_fg)
			db_printf("\t%s%s%s\tr%-3d,r%-3d", opcode,
			    instwidth[aryno], user, rd, rs1);
		else
			db_printf("\t%s%s%c%s\tr%-3d,r%-3d", opcode,
			    instwidth[aryno], c, user, rd, rs1);

	if (scaled)
		db_printf("[r%-3d]", rs2);
	else
		db_printf(",r%-3d", rs2);
d426 10
a435 10
	register int rd = (inst >> 21) & 037;
	register int rs1 = (inst >> 16) & 037;
	register int rs2 = inst & 037;
	register int complemt = (inst >> 10) & 01;
	char   *c = "  ";

	if (complemt)
		c = ".c";

	db_printf("\t%s%s\t\tr%-3d,r%-3d,r%-3d", opcode, c, rd, rs1, rs2);
d443 22
a464 10
	register int rd = (inst >> 21) & 037;
	register int rs1 = (inst >> 16) & 037;
	register int rs2 = inst & 037;
	register int carry = (inst >> 8) & 03;
	register int nochar = (inst >> 10) & 07;
	register int nodecode = (inst >> 11) & 01;
	char   *tab, *c;

	if (nochar > 02)
		tab = "\t\t";
d466 6
a471 17
		tab = "\t";

	if (!nodecode) {
		if (carry == 01)
			c = ".co ";
		else
			if (carry == 02)
				c = ".ci ";
			else
				if (carry == 03)
					c = ".cio";
				else
					c = "    ";
	} else
		c = "    ";

	db_printf("\t%s%s%sr%-3d,r%-3d,r%-3d", opcode, c,
d476 98
a573 253
	unsigned mask, match;
	void    (*opfun) ();
	char   *farg;
}       opdecode[] = {
	/* ORDER IS IMPORTANT BELOW */

	{
		0xF0000000 U, 0x00000000 U, immem, 0,
	}      ,
	{
		0xF0000000 U, 0x10000000 U, immem, 0,
	}      ,
	{
		0xF0000000 U, 0x20000000 U, immem, "st"
	}      ,
	{
		0xF0000000 U, 0x30000000 U, immem, "lda"
	}      ,

	{
		0xF8000000 U, 0x40000000 U, oimmed, "and"
	}      ,
	{
		0xF8000000 U, 0x48000000 U, oimmed, "mask"
	}      ,
	{
		0xF8000000 U, 0x50000000 U, oimmed, "xor"
	}      ,
	{
		0xF8000000 U, 0x58000000 U, oimmed, "or"
	}      ,
	{
		0xFC000000 U, 0x60000000 U, oimmed, "addu"
	}      ,
	{
		0xFC000000 U, 0x64000000 U, oimmed, "subu"
	}      ,
	{
		0xFC000000 U, 0x68000000 U, oimmed, "divu"
	}      ,
	{
		0xFC000000 U, 0x6C000000 U, oimmed, "mul"
	}      ,
	{
		0xFC000000 U, 0x70000000 U, oimmed, "add"
	}      ,
	{
		0xFC000000 U, 0x74000000 U, oimmed, "sub"
	}      ,
	{
		0xFC000000 U, 0x78000000 U, oimmed, "div"
	}      ,
	{
		0xFC000000 U, 0x7C000000 U, oimmed, "cmp"
	}      ,

	{
		0xFC00F800 U, 0x80004000 U, ctrlregs, "ldcr"
	}      ,
	{
		0xFC00F800 U, 0x80004800 U, ctrlregs, "fldcr"
	}      ,
	{
		0xFC00F800 U, 0x80008000 U, ctrlregs, "stcr"
	}      ,
	{
		0xFC00F800 U, 0x80008800 U, ctrlregs, "fstcr"
	}      ,
	{
		0xFC00F800 U, 0x8000C000 U, ctrlregs, "xcr"
	}      ,
	{
		0xFC00F800 U, 0x8000C800 U, ctrlregs, "fxcr"
	}      ,

	{
		0xFC00F800 U, 0x84000000 U, sindou, "fmul"
	}      ,
	{
		0xFC1FFF80 U, 0x84002000 U, sindou, "flt"
	}      ,
	{
		0xFC00F800 U, 0x84002800 U, sindou, "fadd"
	}      ,
	{
		0xFC00F800 U, 0x84003000 U, sindou, "fsub"
	}      ,
	{
		0xFC00F860 U, 0x84003800 U, sindou, "fcmp"
	}      ,
	{
		0xFC1FFE60 U, 0x84004800 U, sindou, "int"
	}      ,
	{
		0xFC1FFE60 U, 0x84005000 U, sindou, "nint"
	}      ,
	{
		0xFC1FFE60 U, 0x84005800 U, sindou, "trnc"
	}      ,
	{
		0xFC00F800 U, 0x84007000 U, sindou, "fdiv"
	}      ,

	{
		0xF8000000 U, 0xC0000000 U, obranch, "br"
	}      ,
	{
		0xF8000000 U, 0xC8000000 U, obranch, "bsr"
	}      ,

	{
		0xF8000000 U, 0xD0000000 U, brcond, "bb0"
	}      ,
	{
		0xF8000000 U, 0xD8000000 U, brcond, "bb1"
	}      ,
	{
		0xF8000000 U, 0xE8000000 U, brcond, "bcnd"
	}      ,

	{
		0xFC00FC00 U, 0xF0008000 U, obit, "clr"
	}      ,
	{
		0xFC00FC00 U, 0xF0008800 U, obit, "set"
	}      ,
	{
		0xFC00FC00 U, 0xF0009000 U, obit, "ext"
	}      ,
	{
		0xFC00FC00 U, 0xF0009800 U, obit, "extu"
	}      ,
	{
		0xFC00FC00 U, 0xF000A000 U, obit, "mak"
	}      ,
	{
		0xFC00FC00 U, 0xF000A800 U, obit, "rot"
	}      ,

	{
		0xFC00FE00 U, 0xF000D000 U, otrap, "tb0"
	}      ,
	{
		0xFC00FE00 U, 0xF000D800 U, otrap, "tb1"
	}      ,
	{
		0xFC00FE00 U, 0xF000E800 U, otrap, "tcnd"
	}      ,

	{
		0xFC00F2E0 U, 0xF4000000 U, nimmem, 0,
	}      ,
	{
		0xFC00F2E0 U, 0xF4000200 U, nimmem, 0,
	}      ,
	{
		0xFC00F2E0 U, 0xF4001000 U, nimmem, 0,
	}      ,
	{
		0xFC00F2E0 U, 0xF4001200 U, nimmem, 0,
	}      ,
	{
		0xFC00F2E0 U, 0xF4002000 U, nimmem, "st"
	}      ,
	{
		0xFC00F2E0 U, 0xF4002200 U, nimmem, "st"
	}      ,
	{
		0xFC00F2E0 U, 0xF4003000 U, nimmem, "lda"
	}      ,
	{
		0xFC00F2E0 U, 0xF4003200 U, nimmem, "lda"
	}      ,

	{
		0xFC00FBE0 U, 0xF4004000 U, lognim, "and"
	}      ,
	{
		0xFC00FBE0 U, 0xF4005000 U, lognim, "xor"
	}      ,
	{
		0xFC00FBE0 U, 0xF4005800 U, lognim, "or"
	}      ,

	{
		0xFC00FCE0 U, 0xF4006000 U, onimmed, "addu"
	}      ,
	{
		0xFC00FCE0 U, 0xF4006400 U, onimmed, "subu"
	}      ,
	{
		0xFC00FCE0 U, 0xF4006800 U, onimmed, "divu"
	}      ,
	{
		0xFC00FCE0 U, 0xF4006C00 U, onimmed, "mul"
	}      ,
	{
		0xFC00FCE0 U, 0xF4007000 U, onimmed, "add"
	}      ,
	{
		0xFC00FCE0 U, 0xF4007400 U, onimmed, "sub"
	}      ,
	{
		0xFC00FCE0 U, 0xF4007800 U, onimmed, "div"
	}      ,
	{
		0xFC00FCE0 U, 0xF4007C00 U, onimmed, "cmp"
	}      ,

	{
		0xFC00FFE0 U, 0xF4008000 U, bitman, "clr"
	}      ,
	{
		0xFC00FFE0 U, 0xF4008800 U, bitman, "set"
	}      ,
	{
		0xFC00FFE0 U, 0xF4009000 U, bitman, "ext"
	}      ,
	{
		0xFC00FFE0 U, 0xF4009800 U, bitman, "extu"
	}      ,
	{
		0xFC00FFE0 U, 0xF400A000 U, bitman, "mak"
	}      ,
	{
		0xFC00FFE0 U, 0xF400A800 U, bitman, "rot"
	}      ,

	{
		0xFC00FBE0 U, 0xF400C000 U, jump, "jmp"
	}      ,
	{
		0xFC00FBE0 U, 0xF400C800 U, jump, "jsr"
	}      ,

	{
		0xFC00FFE0 U, 0xF400E800 U, instset, "ff1"
	}      ,
	{
		0xFC00FFE0 U, 0xF400EC00 U, instset, "ff0"
	}      ,
	{
		0xFC00FFE0 U, 0xF400F800 U, instset, "tbnd"
	}      ,
	{
		0xFC00FFE0 U, 0xF400FC00 U, instset, "rte"
	}      ,
	{
		0xFC000000 U, 0xF8000000 U, instset, "tbnd"
	}      ,
	{
		0, 0, 0, 0
	}
d581 13
a593 14
	register struct opdesc *p;

	/* this messes up "orb" instructions ever so slightly, */
	/* but keeps us in sync between routines... */
	if (inst == 0) {
		db_printf("\t.word 0");
	} else {
		for (p = opdecode; p->mask; p++)
			if ((inst & p->mask) == p->match) {
				(*p->opfun) (inst, p->farg, iadr);
				break;
			}
		if (!p->mask)
			db_printf(badop);
d595 3
d599 1
a599 1
	return iadr + 4;
d601 1
d605 3
a607 3
	m88k_print_instruction(loc, db_get_value(loc, 4, FALSE));
	db_printf("\n");
	return loc + 4;
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@initial 88k import; code by nivas and based on mach luna88k
@
text
@@


1.1.1.2
log
@Third try at importing the mvme88k port. This is a working kernel
from nivas.
Userland and compiler still need to be worked on.
Make certain what directory the import is done from.
@
text
@d43 1
a43 1
};  
d76 1
a76 1
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
a79 1

d82 1
a82 1
/* Handlers immediate integer arithmetic instructions */      
d84 1
a84 1
oimmed(long inst, char  *opcode, long iadr)
d86 14
a99 14
  register int Linst = inst & 0177777;
  register int Hinst = inst >> 16;
  register int H6inst = Hinst >> 10;
  register int rs1 = Hinst & 037;
  register int rd = ( Hinst >> 5 ) & 037;

  if (( H6inst > 017 ) && ( H6inst < 030 ) && ( H6inst & 01) == 1 ) 
    db_printf("\t%s.u",opcode);
  else {
    db_printf("\t%s",opcode);
    db_printf("  ");
  }
  db_printf("\t\tr%-3d,r%-3d,", rd, rs1);
  printval(Linst);
d107 14
a120 13
  register int L6inst = (inst >> 11) & 037;
  register int creg = (inst >> 5) & 077;
  register int rd = (inst >> 21) & 037;
  register int rs1 = (inst >> 16) & 037;
  
  db_printf("\t%s",opcode);
  
  if ( L6inst == 010 || L6inst == 011 )
    db_printf("\t\tr%-3d,%s", rd, ctrlreg[creg]);
  else if ( L6inst == 020 || L6inst == 021 )
    db_printf("\t\tr%-3d,%s", rs1, ctrlreg[creg]);
  else
    db_printf("\t\tr%-3d,r%-3d,%s", rd, rs1, ctrlreg[creg]);
d127 4
a130 4
  if ( t == 0 ) 
    db_printf("s");
  else
    db_printf("d");
a131 1

d136 22
a157 22
  register int rs2 = inst & 037;
  register int td = ( inst >> 5 ) & 03;
  register int t2 = ( inst >> 7 ) & 03;
  register int t1 = ( inst >> 9 ) & 03;
  register int rs1 = ( inst >> 16 ) & 037;
  register int rd = ( inst >> 21 ) & 037;
  register int checkbits  = ( inst >> 11 ) & 037;
  
  db_printf("\t%s.",opcode);
  printsod(td);
  if (( checkbits > 010 && checkbits < 014 ) || ( checkbits == 04 )) {
    printsod(t2);
    db_printf(" ");
    if ( checkbits == 012 || checkbits == 013 )
      db_printf("\t\tr%-3d,r%-3d", rd, rs2);
    else
      db_printf("\t\tr%-3d,r%-3d", rd, rs2);
  }
  else{
    printsod(t1);printsod(t2);
    db_printf("\t\tr%-3d,r%-3d,r%-3d", rd, rs1, rs2);
  }
d164 9
a172 9
  register int rs2 = inst & 037;
  register int Nbit = ( inst >> 10 ) & 01;
  
  db_printf("\t%s",opcode);
  if ( Nbit == 1 )
    db_printf(".n");
  else
    db_printf("  ");
  db_printf("\t\tr%-3d",rs2);
d176 1
a176 1
/* Handles ff1, ff0, tbnd and rte instructions */ 
d180 16
a195 15
  register int rs2 = inst & 037;
  register int rs1 = ( inst >> 16 ) & 037;
  register int rd = ( inst >> 21 ) & 037;
  register int checkbits = ( inst >> 10 ) & 077;
  register int H6inst = ( inst >> 26 ) & 077;
  
  db_printf("\t%s",opcode);
  if ( H6inst == 076 ) {
    db_printf("\t\tr%-3d,",rs1);
    printval(inst & 0177777);
  }
  else if (( checkbits == 072 ) || ( checkbits == 073 ))
    db_printf("\t\tr%-3d,r%-3d", rd, rs2);
  else if ( checkbits == 076 )
    db_printf("\t\tr%-3d,r%-3d",rs1,rs2);
d199 12
a210 13
symofset(int  disp, int  bit, int iadr)
{
  long addr;

  if ( disp & (1 << (bit-1)) ) {
    /* negative value */
    addr = iadr + ((disp << 2) | (~0 << bit));
  }
  else {
    addr = iadr + (disp << 2);
  }
  db_printsym(addr,DB_STGY_PROC);
  return;
d216 10
a225 11
  int cond = ( inst >> 26 ) & 01;
  int disp = inst &0377777777;
  
  if ( cond == 0 ) {
    db_printf("\t%s\t\t",opcode);
    symofset(disp, 26, iadr);
  }
  else {
    db_printf("\t%s.n\t\t",opcode);
    symofset(disp, 26, iadr);
  }
d233 37
a269 24
  int cond = ( inst >> 26 ) & 1;
  int match = ( inst >> 21 ) & 037;
  int rs = ( inst >> 16 ) & 037;
  int disp = ( inst & 0177777 );
  
  if ( cond == 0 )
    db_printf("\t%s\t\t", opcode); 
  else
    db_printf("\t%s.n\t\t", opcode);
  if ( ( ( inst >> 27 ) & 03 ) == 1 )
    switch (match) {
    case 1 : db_printf("%s,", condname[0]); break;
    case 2 : db_printf("%s,", condname[1]); break;
    case 3 : db_printf("%s,", condname[2]); break;
    case 12: db_printf("%s,", condname[3]); break;
    case 13: db_printf("%s,", condname[4]); break;
    case 14: db_printf("%s,", condname[5]); break;
    default: printval(match); 
      db_printf(",");
    }
  else {
    printval(match);
    db_printf(",");
  }
d271 2
a272 2
  db_printf("r%-3d,", rs);
  symofset(disp,16, iadr);
d279 35
a313 22
  int vecno = inst & 0777;
  int match = ( inst >> 21 ) & 037;
  int rs = ( inst >> 16 ) & 037;
  
  db_printf("\t%s\t",opcode);
  if ( ( ( inst >> 12 ) & 017 ) == 0xe )
    switch (match) {
    case 1 : db_printf("%s,", condname[0]);break;
    case 2 : db_printf("%s,", condname[1]);break;
    case 3 : db_printf("%s,", condname[2]);break;
    case 12: db_printf("%s,", condname[3]);break;
    case 13: db_printf("%s,", condname[4]);break;
    case 14: db_printf("%s,", condname[5]);break;
    default: printval(match);
      db_printf(",");
    }
  else {
    printval(match);
    db_printf(",");
  }
  db_printf("\tr%-3d,", rs);
  printval(vecno);
d321 16
a336 18
  int rs = ( inst >> 16 ) & 037;
  int rd = ( inst >> 21 ) & 037;
  int width = ( inst >> 5 ) & 037;
  int offset = ( inst & 037 );  
  
  db_printf("\t%s\t\tr%-3d,r%-3d,", opcode, rd, rs); 
  if ( ( ( inst >> 10 ) & 077 ) == 052 ) {
    db_printf("<"); 
    printval(offset); 
    db_printf(">"); 
  }
  else
    {
      printval(width);
      db_printf("<");
      printval(offset);
      db_printf(">");
    }
d344 6
a349 6
  
  int rs1 = ( inst >> 16 ) & 037;
  int rd  = ( inst >> 21 ) & 037;
  int rs2 = inst & 037;
  
  db_printf("\t%s\t\tr%-3d,r%-3d,r%-3d", opcode, rd, rs1, rs2);
d357 21
a377 22
  register int immed  = inst & 0xFFFF;
  register int rd     = (inst >> 21) & 037;
  register int rs     = (inst >> 16) & 037;
  register int st_lda = (inst >> 28) & 03;
  register int aryno  = (inst >> 26) & 03;
  char c = ' ';
  
  if (!st_lda)	{
    if ((aryno == 0) || (aryno == 01))
      opcode = "xmem";
    else
      opcode = "ld";
    if (aryno == 0)
      aryno = 03;
    if (!(aryno == 01))
      c = 'u';
  }
  else
    if (st_lda == 01)
      opcode = "ld";
  
  db_printf("\t%s%s%c\t\tr%-3d,r%-3d,", opcode, instwidth[aryno], 
d379 1
a379 1
  printval(immed);
d387 50
a436 53
  register int scaled  = (inst >> 9) & 01;
  register int rd      = (inst >> 21) & 037;
  register int rs1     = (inst >> 16) & 037;
  register int rs2     = inst & 037;
  register int st_lda  = (inst >> 12) & 03;
  register int aryno   = (inst >> 10) & 03;
  register int user_bit = 0;
  int signed_fg  = 1;
  char *user           = "    ";
  char c = ' ';
  
  if (!st_lda)	{
    if ((aryno == 0) || (aryno == 01))
      opcode = "xmem";
    else
      opcode = "ld";
    if (aryno == 0)
      aryno = 03;
    if (!(aryno == 01))	{
      c = 'u';
      signed_fg = 0;
    }
  }
  else
    if (st_lda == 01)
      opcode = "ld";
  
  if (!(st_lda == 03))	{
    user_bit = (inst >> 8) & 01;
    if (user_bit)
      user = ".usr";
  }
  
  if (user_bit && signed_fg && (aryno == 01)) {
    if (st_lda)
      db_printf("\t%s%s\tr%-3d,r%-3d", opcode,
		user, rd, rs1);
    else
      db_printf("\t%s%s\tr%-3d,r%-3d", opcode,
		user, rd, rs1);
  }	
  else	
    if (user_bit && signed_fg)
      db_printf("\t%s%s%s\tr%-3d,r%-3d", opcode, 
		instwidth[aryno], user, rd, rs1);
    else
      db_printf("\t%s%s%c%s\tr%-3d,r%-3d", opcode, 
		instwidth[aryno], c, user, rd, rs1);
  
  if (scaled)
    db_printf("[r%-3d]", rs2);
  else
    db_printf(",r%-3d", rs2);
d444 10
a453 10
  register int rd   = (inst >> 21) & 037;
  register int rs1  = (inst >> 16) & 037;
  register int rs2  = inst & 037;
  register int complemt = (inst >> 10) & 01;
  char *c = "  ";
  
  if (complemt)
    c = ".c";
  
  db_printf("\t%s%s\t\tr%-3d,r%-3d,r%-3d", opcode, c, rd, rs1, rs2);
d461 10
a470 22
  register int rd   = (inst >> 21) & 037;
  register int rs1  = (inst >> 16) & 037;
  register int rs2  = inst & 037;
  register int carry = (inst >> 8) & 03;
  register int nochar = (inst >> 10) & 07;
  register int nodecode = (inst >> 11) & 01;
  char *tab, *c ;
  
  if (nochar > 02)
    tab = "\t\t";
  else
    tab = "\t";
  
  if (!nodecode) {
    if (carry == 01)
      c = ".co ";
    else
      if (carry == 02)
	c = ".ci ";
      else
	if (carry == 03)
	  c = ".cio";
d472 17
a488 6
	  c = "    ";
  }
  else
    c = "    ";
  
  db_printf("\t%s%s%sr%-3d,r%-3d,r%-3d", opcode, c,
d493 253
a745 98
    unsigned mask, match;
    void (*opfun) ();
    char *farg;
} opdecode[] = {

    /* ORDER IS IMPORTANT BELOW */

    {	0xF0000000U, 0x00000000U, immem, 0,		},
    {	0xF0000000U, 0x10000000U, immem, 0,		},
    {	0xF0000000U, 0x20000000U, immem, "st"		},
    {	0xF0000000U, 0x30000000U, immem, "lda"		},

    {	0xF8000000U, 0x40000000U, oimmed, "and" 	},
    {	0xF8000000U, 0x48000000U, oimmed, "mask" 	},
    {	0xF8000000U, 0x50000000U, oimmed, "xor" 	},
    {	0xF8000000U, 0x58000000U, oimmed, "or" 		},
    {	0xFC000000U, 0x60000000U, oimmed, "addu" 	},
    {	0xFC000000U, 0x64000000U, oimmed, "subu" 	},
    {	0xFC000000U, 0x68000000U, oimmed, "divu" 	},
    {	0xFC000000U, 0x6C000000U, oimmed, "mul" 	},
    {	0xFC000000U, 0x70000000U, oimmed, "add" 	},
    {	0xFC000000U, 0x74000000U, oimmed, "sub" 	},
    {	0xFC000000U, 0x78000000U, oimmed, "div" 	},
    {	0xFC000000U, 0x7C000000U, oimmed, "cmp" 	},

    {	0xFC00F800U, 0x80004000U, ctrlregs, "ldcr" 	},
    {	0xFC00F800U, 0x80004800U, ctrlregs, "fldcr" 	},
    {	0xFC00F800U, 0x80008000U, ctrlregs, "stcr" 	},
    {	0xFC00F800U, 0x80008800U, ctrlregs, "fstcr" 	},
    {	0xFC00F800U, 0x8000C000U, ctrlregs, "xcr" 	},
    {	0xFC00F800U, 0x8000C800U, ctrlregs, "fxcr" 	},

    {	0xFC00F800U, 0x84000000U, sindou, "fmul" 	},
    {	0xFC1FFF80U, 0x84002000U, sindou, "flt" 	},
    {	0xFC00F800U, 0x84002800U, sindou, "fadd" 	},
    {	0xFC00F800U, 0x84003000U, sindou, "fsub" 	},
    {	0xFC00F860U, 0x84003800U, sindou, "fcmp" 	},
    {	0xFC1FFE60U, 0x84004800U, sindou, "int" 	},
    {	0xFC1FFE60U, 0x84005000U, sindou, "nint" 	},
    {	0xFC1FFE60U, 0x84005800U, sindou, "trnc" 	},
    {	0xFC00F800U, 0x84007000U, sindou, "fdiv" 	},

    {	0xF8000000U, 0xC0000000U, obranch, "br" 	},
    {	0xF8000000U, 0xC8000000U, obranch, "bsr" 	},

    {	0xF8000000U, 0xD0000000U, brcond, "bb0" 	},
    {	0xF8000000U, 0xD8000000U, brcond, "bb1" 	},
    {	0xF8000000U, 0xE8000000U, brcond, "bcnd" 	},

    {	0xFC00FC00U, 0xF0008000U, obit, "clr" 		},
    {	0xFC00FC00U, 0xF0008800U, obit, "set" 		},
    {	0xFC00FC00U, 0xF0009000U, obit, "ext" 		},
    {	0xFC00FC00U, 0xF0009800U, obit, "extu" 		},
    {	0xFC00FC00U, 0xF000A000U, obit, "mak" 		},
    {	0xFC00FC00U, 0xF000A800U, obit, "rot" 		},

    {	0xFC00FE00U, 0xF000D000U, otrap, "tb0" 		},
    {	0xFC00FE00U, 0xF000D800U, otrap, "tb1" 		},
    {	0xFC00FE00U, 0xF000E800U, otrap, "tcnd" 	},

    {	0xFC00F2E0U, 0xF4000000U, nimmem, 0,		},
    {	0xFC00F2E0U, 0xF4000200U, nimmem, 0,		},
    {	0xFC00F2E0U, 0xF4001000U, nimmem, 0,		},
    {	0xFC00F2E0U, 0xF4001200U, nimmem, 0,		},
    {	0xFC00F2E0U, 0xF4002000U, nimmem, "st" 		},
    {	0xFC00F2E0U, 0xF4002200U, nimmem, "st" 		},
    {	0xFC00F2E0U, 0xF4003000U, nimmem, "lda" 	},
    {	0xFC00F2E0U, 0xF4003200U, nimmem, "lda" 	},

    {	0xFC00FBE0U, 0xF4004000U, lognim, "and" 	},
    {	0xFC00FBE0U, 0xF4005000U, lognim, "xor" 	},
    {	0xFC00FBE0U, 0xF4005800U, lognim, "or" 		},

    {	0xFC00FCE0U, 0xF4006000U, onimmed, "addu" 	},
    {	0xFC00FCE0U, 0xF4006400U, onimmed, "subu" 	},
    {	0xFC00FCE0U, 0xF4006800U, onimmed, "divu" 	},
    {	0xFC00FCE0U, 0xF4006C00U, onimmed, "mul" 	},
    {	0xFC00FCE0U, 0xF4007000U, onimmed, "add" 	},
    {	0xFC00FCE0U, 0xF4007400U, onimmed, "sub" 	},
    {	0xFC00FCE0U, 0xF4007800U, onimmed, "div" 	},
    {	0xFC00FCE0U, 0xF4007C00U, onimmed, "cmp" 	},
 
    {	0xFC00FFE0U, 0xF4008000U, bitman, "clr" 	},
    {	0xFC00FFE0U, 0xF4008800U, bitman, "set" 	},
    {	0xFC00FFE0U, 0xF4009000U, bitman, "ext" 	},
    {	0xFC00FFE0U, 0xF4009800U, bitman, "extu" 	},
    {	0xFC00FFE0U, 0xF400A000U, bitman, "mak" 	},
    {	0xFC00FFE0U, 0xF400A800U, bitman, "rot" 	},

    {	0xFC00FBE0U, 0xF400C000U, jump, "jmp"		},
    {	0xFC00FBE0U, 0xF400C800U, jump, "jsr"		},

    {	0xFC00FFE0U, 0xF400E800U, instset, "ff1"	},
    {	0xFC00FFE0U, 0xF400EC00U, instset, "ff0"	},
    {	0xFC00FFE0U, 0xF400F800U, instset, "tbnd"	},
    {	0xFC00FFE0U, 0xF400FC00U, instset, "rte"	},
    {	0xFC000000U, 0xF8000000U, instset, "tbnd"	},
    {	0,0,0,0 }
d753 14
a766 13
  register struct opdesc *p;
  
  /* this messes up "orb" instructions ever so slightly, */
  /* but keeps us in sync between routines... */
  if (inst == 0) {
    db_printf ("\t.word 0");
  }
  else 
    {
      for (p = opdecode; p->mask; p++)
	if ((inst & p->mask) == p->match) {
	  (*p->opfun) (inst, p->farg, iadr);
	  break;
a767 3
      if (!p->mask)
	db_printf (badop);
    }
d769 1
a769 1
  return iadr+4;
a770 1

d774 3
a776 3
  m88k_print_instruction(loc, db_get_value(loc, 4, FALSE));
  db_printf ("\n");
  return loc+4;
@
