head	1.15;
access;
symbols
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.11.0.8
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.6
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.11
	UBC:1.9.0.2
	UBC_BASE:1.9
	OPENBSD_3_0:1.7.0.4
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.4.0.10
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.8
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.6
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.4
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	mvme88kport:1.1.1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	first_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2004.06.19.18.28.37;	author miod;	state dead;
branches;
next	1.14;

1.14
date	2004.01.07.17.52.30;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2003.12.21.13.23.32;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2003.10.11.22.08.57;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.01.26.38;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.22.08.31.04;	author smurph;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.16.23.49.46;	author miod;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2001.12.13.08.55.51;	author smurph;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.16.00.01.51;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.09.05.44.38;	author smurph;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.07.23.58.36;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	99.02.09.06.36.25;	author smurph;	state Exp;
branches
	1.4.6.1;
next	1.3;

1.3
date	97.03.03.20.20.35;	author rahnds;	state Exp;
branches;
next	1.2;

1.2
date	97.03.03.19.07.07;	author rahnds;	state dead;
branches;
next	1.1;

1.1
date	95.10.18.10.54.28;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.10.54.28;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.03.03.19.31.57;	author rahnds;	state Exp;
branches;
next	;

1.4.6.1
date	2001.04.18.16.10.51;	author niklas;	state Exp;
branches;
next	1.4.6.2;

1.4.6.2
date	2002.03.06.01.08.05;	author niklas;	state Exp;
branches;
next	1.4.6.3;

1.4.6.3
date	2002.03.28.10.36.02;	author niklas;	state Exp;
branches;
next	1.4.6.4;

1.4.6.4
date	2004.02.19.10.49.06;	author niklas;	state Exp;
branches;
next	;

1.9.2.1
date	2002.01.31.22.55.17;	author niklas;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2002.06.11.03.37.09;	author art;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Share common ddb files accross m88k platforms.
@
text
@/*	$OpenBSD: db_sstep.c,v 1.14 2004/01/07 17:52:30 miod Exp $	*/
/*
 * Mach Operating System
 * Copyright (c) 1993-1991 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON AND OMRON ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON AND OMRON DISCLAIM ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/systm.h>

#include <machine/db_machdep.h>

#include <ddb/db_access.h>	/* db_get_value() */
#include <ddb/db_break.h>	/* db_breakpoint_t */

/*
 * Support routines for software single step.
 *
 * Author: Daniel Stodolsky (danner@@cs.cmu.edu)
 *
 */

boolean_t inst_delayed(unsigned int ins);

#ifdef INTERNAL_SSTEP
db_breakpoint_t db_not_taken_bkpt = 0;
db_breakpoint_t db_taken_bkpt = 0;
#endif

/*
 * Returns TRUE is the instruction a branch or jump instruction
 * (br, bb0, bb1, bcnd, jmp) but not a function call (bsr or jsr)
 */
boolean_t
inst_branch(ins)
	unsigned int ins;
{
	/* check high five bits */
	switch (ins >> (32 - 5)) {
	case 0x18: /* br */
	case 0x1a: /* bb0 */
	case 0x1b: /* bb1 */
	case 0x1d: /* bcnd */
		return TRUE;
		break;
	case 0x1e: /* could be jmp */
		if ((ins & 0xfffffbe0U) == 0xf400c000U)
			return TRUE;
	}

	return FALSE;
}

/*
 * inst_load(ins)
 * Returns the number of words the instruction loads. byte,
 * half and word count as 1; double word as 2
 */
unsigned
inst_load(ins)
	unsigned int ins;
{
	/* look at the top six bits, for starters */
	switch (ins >> (32 - 6)) {
	case 0x0: /* xmem byte imm */
	case 0x1: /* xmem word imm */

	case 0x2: /* unsigned half-word load imm */
	case 0x3: /* unsigned byte load imm */
	case 0x5: /* signed word load imm */
	case 0x6: /* signed half-word load imm */
	case 0x7: /* signed byte load imm */
		return 1;

	case 0x4: /* signed double word load imm */
		return 2;

	case 0x3d: /* load/store/xmem scaled/unscaled instruction */
		if ((ins & 0xf400c0e0U) == 0xf4000000U)	/* is load/xmem */
			switch ((ins & 0x0000fce0) >> 5) { /* look at bits 15-5, but mask bits 8-9 */
			case 0x0: /* xmem byte */
			case 0x1: /* xmem word */
			case 0x2: /* unsigned half word */
			case 0x3: /* unsigned byte load */
			case 0x5: /* signed word load */
			case 0x6: /* signed half-word load */
			case 0x7: /* signed byte load */
				return 1;

			case 0x4: /* signed double word load */
				return 2;
			} /* end switch load/xmem  */
		break;
	} /* end switch 32-6 */

	return 0;
}

/*
 * inst_store
 * Like inst_load, except for store instructions.
 */
unsigned
inst_store(ins)
	unsigned int ins;
{
	/* decode top 6 bits again */
	switch (ins >> (32 - 6)) {
	case 0x0: /* xmem byte imm */
	case 0x1: /* xmem word imm */
	case 0x9: /* store word imm */
	case 0xa: /* store half-word imm */
	case 0xb: /* store byte imm */
		return 1;

	case 0x8: /* store double word */
		return 2;
	case 0x3d: /* load/store/xmem scaled/unscaled instruction */
		/* check bits 15,14,12,7,6,5 are all 0 */
		if ((ins & 0x0000d0e0U) == 0)
			switch ((ins & 0x00003c00U) >> 10) { /* decode bits 10-13 */
			case 0x0: /* xmem byte imm */
			case 0x1: /* xmem word imm */
			case 0x9: /* store word */
			case 0xa: /* store half-word */
			case 0xb: /* store byte */
				return 1;

			case 0x8: /* store double word */
				return 2;
			} /* end switch store/xmem */
		break;
	} /* end switch 32-6 */

	return 0;
}

/*
 * inst_delayed
 * Returns TRUE if this instruction is followed by a delay slot.
 * Could be br.n, bsr.n bb0.n, bb1.n, bcnd.n or jmp.n or jsr.n
 */
boolean_t
inst_delayed(ins)
	unsigned int ins;
{
	/* check the br, bsr, bb0, bb1, bcnd cases */
	switch ((ins & 0xfc000000U) >> (32 - 6)) {
	case 0x31: /* br */
	case 0x33: /* bsr */
	case 0x35: /* bb0 */
	case 0x37: /* bb1 */
	case 0x3b: /* bcnd */
		return TRUE;
	}

	/* check the jmp, jsr cases */
	/* mask out bits 0-4, bit 11 */
	return ((ins & 0xfffff7e0U) == 0xf400c400U) ? TRUE : FALSE;
}

/*
 * next_instr_address(pc,delay_slot,task) has the following semantics.
 * Let inst be the instruction at pc.
 * If delay_slot = 1, next_instr_address should return
 * the address of the instruction in the delay slot; if this instruction
 * does not have a delay slot, it should return pc.
 * If delay_slot = 0, next_instr_address should return the
 * address of next sequential instruction, or pc if the instruction is
 * followed by a delay slot.
 *
 * 91-11-28 jfriedl: I think the above is wrong. I think it should be:
 *	if delay_slot true, return address of the delay slot if there is one,
 *			    return pc otherwise.
 *	if delay_slot false, return (pc + 4) regardless.
 *
 */
db_addr_t
next_instr_address(pc, delay_slot)
	db_addr_t pc;
	unsigned delay_slot;
{
	if (delay_slot == 0)
		return pc + 4;
	else {
		if (inst_delayed(db_get_value(pc, sizeof(int), FALSE)))
			return pc + 4;
		else
			return pc;
	}
}


/*
 * branch_taken(instruction, program counter, func, func_data)
 *
 * instruction will be a control flow instruction location at address pc.
 * Branch taken is supposed to return the address to which the instruction
 * would jump if the branch is taken. Func can be used to get the current
 * register values when invoked with a register number and func_data as
 * arguments.
 *
 * If the instruction is not a control flow instruction, panic.
 */
db_addr_t
branch_taken(inst, pc, func, func_data)
	u_int inst;
	db_addr_t pc;
	db_expr_t (*func)(db_regs_t *, int);
	db_regs_t *func_data;
{
	/* check if br/bsr */
	if ((inst & 0xf0000000U) == 0xc0000000U) {
		/* signed 26 bit pc relative displacement, shift left two bits */
		inst = (inst & 0x03ffffffU) << 2;
		/* check if sign extension is needed */
		if (inst & 0x08000000U)
			inst |= 0xf0000000U;
		return pc + inst;
	}

	/* check if bb0/bb1/bcnd case */
	switch ((inst & 0xf8000000U)) {
	case 0xd0000000U: /* bb0 */
	case 0xd8000000U: /* bb1 */
	case 0xe8000000U: /* bcnd */
		/* signed 16 bit pc relative displacement, shift left two bits */
		inst = (inst & 0x0000ffffU) << 2;
		/* check if sign extension is needed */
		if (inst & 0x00020000U)
			inst |= 0xfffc0000U;
		return pc + inst;
	}

	/* check jmp/jsr case */
	/* check bits 5-31, skipping 10 & 11 */
	if ((inst & 0xfffff3e0U) == 0xf400c000U) {
		return (*func)(func_data, (inst & 0x0000001fU));  /* the register value */
	}


	panic("branch_taken");
	return 0; /* keeps compiler happy */
}

/*
 * getreg_val - handed a register number and an exception frame.
 *              Returns the value of the register in the specified
 *              frame. Only makes sense for general registers.
 */

db_expr_t
getreg_val(frame, regno)
	db_regs_t *frame;
	int regno;
{
	if (regno == 0)
		return 0;
	else if (regno < 31)
		return frame->r[regno];
	else
		panic("bad register number (%d) to getreg_val.", regno);
}

#ifdef INTERNAL_SSTEP
void
db_set_single_step(regs)
	db_regs_t *regs;
{
	if (cputyp == CPU_88110) {
		((regs)->epsr |= (PSR_TRACE | PSR_SER));
	} else {
		db_addr_t pc = PC_REGS(regs);
#ifndef SOFTWARE_SSTEP_EMUL
		db_addr_t brpc;
		u_int inst;

		/*
		 * User was stopped at pc, e.g. the instruction
		 * at pc was not executed.
		 */
		inst = db_get_value(pc, sizeof(int), FALSE);
		if (inst_branch(inst) || inst_call(inst) || inst_return(inst)) {
			brpc = branch_taken(inst, pc, getreg_val, regs);
			if (brpc != pc) {	/* self-branches are hopeless */
				db_taken_bkpt = db_set_temp_breakpoint(brpc);
			}
#if 0
			/* XXX this seems like a true bug, no?  */
			pc = next_instr_address(pc, 1);
#endif
		}
#endif /*SOFTWARE_SSTEP_EMUL*/
		pc = next_instr_address(pc, 0);
		db_not_taken_bkpt = db_set_temp_breakpoint(pc);
	}
}

void
db_clear_single_step(regs)
	db_regs_t *regs;
{
	if (cputyp == CPU_88110) {
		((regs)->epsr &= ~(PSR_TRACE | PSR_SER));
	} else {
		if (db_taken_bkpt != 0) {
			db_delete_temp_breakpoint(db_taken_bkpt);
			db_taken_bkpt = 0;
		}
		if (db_not_taken_bkpt != 0) {
			db_delete_temp_breakpoint(db_not_taken_bkpt);
			db_not_taken_bkpt = 0;
		}
	}
}
#endif
@


1.14
log
@Constify, remove db_task_name() Mach leftover, and fix an hilarious typo
in db_interface.c comments while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sstep.c,v 1.13 2003/12/21 13:23:32 miod Exp $	*/
@


1.13
log
@Switch db_expr_t from int to long, per consistency with other platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sstep.c,v 1.12 2003/10/11 22:08:57 miod Exp $	*/
d31 1
d33 1
@


1.12
log
@Nuke trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sstep.c,v 1.11 2002/03/14 01:26:38 millert Exp $	*/
d271 1
a271 1
register_t
d280 1
a280 1
	else {
a281 2
		return 0;/*to make compiler happy */
	}
@


1.11
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sstep.c,v 1.10 2001/12/22 08:31:04 smurph Exp $	*/
d47 1
a47 1
#endif 
d73 1
a73 1
/* 
d289 1
a289 1
	register db_regs_t *regs;
d337 1
a337 1
#endif 
@


1.10
log
@mc88110 support in ddb.  Bring in bit definitions.
We can support hardware sstep for mc88110 and
software sstep for mc88100.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sstep.c,v 1.9 2001/12/16 23:49:46 miod Exp $	*/
d42 1
a42 1
boolean_t inst_delayed __P((unsigned int ins));
d228 1
a228 1
	db_expr_t (*func) __P((db_regs_t *, int));
@


1.9
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sstep.c,v 1.7 2001/03/16 00:01:51 miod Exp $	*/
d33 1
d42 6
a47 2
boolean_t inst_delayed __P((unsigned ins));
db_expr_t getreg_val __P((unsigned regno, db_regs_t *frame));
d55 1
a55 1
	unsigned ins;
d67 1
a67 1
		return TRUE;
d80 1
a80 1
	unsigned ins;
d98 1
a98 1
		if ((ins & 0xf400c0e0U) == 0xf4000000U) /* is load/xmem */
d111 1
a111 1
		} /* end switch load/xmem  */
d124 1
a124 1
	unsigned ins;
d164 1
a164 1
	unsigned ins;
d256 4
a259 2
	if ((inst & 0xfffff3e0U) == 0xf400c000U)
		return (*func)(func_data, inst & 0x1f);  /* the register value */
d270 3
a272 3
db_expr_t
getreg_val(regno, frame)
	unsigned regno;
d274 1
d281 1
a281 1
		panic("bad register number to getreg_val.");
d285 53
@


1.9.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sstep.c,v 1.10 2001/12/22 08:31:04 smurph Exp $	*/
a32 1
#include <ddb/db_break.h>	/* db_breakpoint_t */
d41 2
a42 6
boolean_t inst_delayed __P((unsigned int ins));

#ifdef INTERNAL_SSTEP
db_breakpoint_t db_not_taken_bkpt = 0;
db_breakpoint_t db_taken_bkpt = 0;
#endif 
d50 1
a50 1
	unsigned int ins;
d62 1
a62 1
			return TRUE;
d75 1
a75 1
	unsigned int ins;
d93 1
a93 1
		if ((ins & 0xf400c0e0U) == 0xf4000000U)	/* is load/xmem */
d106 1
a106 1
			} /* end switch load/xmem  */
d119 1
a119 1
	unsigned int ins;
d159 1
a159 1
	unsigned int ins;
d251 2
a252 4
	if ((inst & 0xfffff3e0U) == 0xf400c000U) {
		return (*func)(func_data, (inst & 0x0000001fU));  /* the register value */
	}

d263 3
a265 3

register_t
getreg_val(frame, regno)
a266 1
	int regno;
d273 1
a273 1
		panic("bad register number (%d) to getreg_val.", regno);
a276 53

#ifdef INTERNAL_SSTEP
void
db_set_single_step(regs)
	register db_regs_t *regs;
{
	if (cputyp == CPU_88110) {
		((regs)->epsr |= (PSR_TRACE | PSR_SER));
	} else {
		db_addr_t pc = PC_REGS(regs);
#ifndef SOFTWARE_SSTEP_EMUL
		db_addr_t brpc;
		u_int inst;

		/*
		 * User was stopped at pc, e.g. the instruction
		 * at pc was not executed.
		 */
		inst = db_get_value(pc, sizeof(int), FALSE);
		if (inst_branch(inst) || inst_call(inst) || inst_return(inst)) {
			brpc = branch_taken(inst, pc, getreg_val, regs);
			if (brpc != pc) {	/* self-branches are hopeless */
				db_taken_bkpt = db_set_temp_breakpoint(brpc);
			}
#if 0
			/* XXX this seems like a true bug, no?  */
			pc = next_instr_address(pc, 1);
#endif
		}
#endif /*SOFTWARE_SSTEP_EMUL*/
		pc = next_instr_address(pc, 0);
		db_not_taken_bkpt = db_set_temp_breakpoint(pc);
	}
}

void
db_clear_single_step(regs)
	db_regs_t *regs;
{
	if (cputyp == CPU_88110) {
		((regs)->epsr &= ~(PSR_TRACE | PSR_SER));
	} else {
		if (db_taken_bkpt != 0) {
			db_delete_temp_breakpoint(db_taken_bkpt);
			db_taken_bkpt = 0;
		}
		if (db_not_taken_bkpt != 0) {
			db_delete_temp_breakpoint(db_not_taken_bkpt);
			db_not_taken_bkpt = 0;
		}
	}
}
#endif 
@


1.9.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sstep.c,v 1.9.2.1 2002/01/31 22:55:17 niklas Exp $	*/
d42 1
a42 1
boolean_t inst_delayed(unsigned int ins);
d228 1
a228 1
	db_expr_t (*func)(db_regs_t *, int);
@


1.8
log
@Support for MVME197 completed.  Fix SPL defs.
@
text
@a32 1
#include <ddb/db_break.h>	/* db_breakpoint_t */
d41 2
a42 6
boolean_t inst_delayed __P((unsigned int ins));

#ifdef INTERNAL_SSTEP
db_breakpoint_t	db_not_taken_bkpt = 0;
db_breakpoint_t	db_taken_bkpt = 0;
#endif 
d50 1
a50 1
	unsigned int ins;
d75 1
a75 1
	unsigned int ins;
d119 1
a119 1
	unsigned int ins;
d159 1
a159 1
	unsigned int ins;
d251 2
a252 4
	if ((inst & 0xfffff3e0U) == 0xf400c000U){
		return (*func)(func_data, (inst & 0x0000001fU));  /* the register value */
	}

d263 3
a265 3

register_t
getreg_val(frame, regno)
a266 1
	int regno;
d273 1
a273 1
		panic("bad register number (%d) to getreg_val.", regno);
a276 53

#ifdef INTERNAL_SSTEP
void
db_set_single_step(regs)
	register db_regs_t *regs;
{
	if (cputyp == CPU_88110){
		 ((regs)->epsr |= (PSR_TRACE | PSR_SER));
	} else {
		db_addr_t pc = PC_REGS(regs);
#ifndef SOFTWARE_SSTEP_EMUL
		db_addr_t brpc;
		u_int inst;

		/*
		 * User was stopped at pc, e.g. the instruction
		 * at pc was not executed.
		 */
		inst = db_get_value(pc, sizeof(int), FALSE);
		if (inst_branch(inst) || inst_call(inst) || inst_return(inst)) {
			brpc = branch_taken(inst, pc, getreg_val, regs);
			if (brpc != pc) {	/* self-branches are hopeless */
				db_taken_bkpt = db_set_temp_breakpoint(brpc);
			}
#if 0
		/* XXX this seems like a true bug, no?  */
		pc = next_instr_address(pc, 1);
#endif
		}
#endif /*SOFTWARE_SSTEP_EMUL*/
		pc = next_instr_address(pc, 0);
		db_not_taken_bkpt = db_set_temp_breakpoint(pc);
	}
}

void
db_clear_single_step(regs)
	db_regs_t *regs;
{
	if (cputyp == CPU_88110){
		((regs)->epsr &= ~(PSR_TRACE | PSR_SER));
	} else {
		if (db_taken_bkpt != 0) {
		    db_delete_temp_breakpoint(db_taken_bkpt);
		    db_taken_bkpt = 0;
		}
		if (db_not_taken_bkpt != 0) {
		    db_delete_temp_breakpoint(db_not_taken_bkpt);
		    db_not_taken_bkpt = 0;
		}
	}
}
#endif 
@


1.7
log
@KNF, warning hunting.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sstep.c,v 1.6 2001/03/09 05:44:38 smurph Exp $	*/
d33 1
d42 6
a47 2
boolean_t inst_delayed __P((unsigned ins));
db_expr_t getreg_val __P((unsigned regno, db_regs_t *frame));
d55 1
a55 1
	unsigned ins;
d80 1
a80 1
	unsigned ins;
d124 1
a124 1
	unsigned ins;
d164 1
a164 1
	unsigned ins;
d256 4
a259 2
	if ((inst & 0xfffff3e0U) == 0xf400c000U)
		return (*func)(func_data, inst & 0x1f);  /* the register value */
d270 3
a272 3
db_expr_t
getreg_val(regno, frame)
	unsigned regno;
d274 1
d281 1
a281 1
		panic("bad register number to getreg_val.");
d285 53
@


1.6
log
@kernel will compile with -Werror.  Added intr.h
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sstep.c,v 1.5 2001/03/07 23:58:36 miod Exp $	*/
d41 2
a42 2
/* is the instruction a branch or jump instruction (br, bb0, bb1, bcnd, jmp)
   but not a function call (bsr or jsr) */
d44 4
d49 2
a50 1
inst_branch(unsigned ins)
d52 12
a63 14
  /* check high five bits */
 
  switch (ins >> (32-5))
    {
    case 0x18: /* br */
    case 0x1a: /* bb0 */
    case 0x1b: /* bb1 */
    case 0x1d: /* bcnd */
      return TRUE;
      break;
    case 0x1e: /* could be jmp */
      if ((ins & 0xfffffbe0U) == 0xf400c000U)
	return TRUE;
    }
d65 1
a65 1
  return FALSE;
d68 5
a72 3
/* inst_load(ins) - returns the number of words the instruction loads. byte,
   half and word count as 1; double word as 2 */

d74 2
a75 1
inst_load(unsigned ins)
d77 32
a108 1
  /* look at the top six bits, for starters */
d110 1
a110 35
  switch (ins >> (32-6))
    {
    case 0x0: /* xmem byte imm */
    case 0x1: /* xmem word imm */

    case 0x2: /* unsigned half-word load imm */
    case 0x3: /* unsigned byte load imm */
    case 0x5: /* signed word load imm */
    case 0x6: /* signed half-word load imm */
    case 0x7: /* signed byte load imm */
      return 1;

    case 0x4: /* signed double word load imm */
      return 2;

    case 0x3d: /* load/store/xmem scaled/unscaled instruction */
      if ((ins & 0xf400c0e0U) == 0xf4000000U) /* is load/xmem */
	switch ((ins & 0x0000fce0)>>5)  /* look at bits 15-5, but mask bits 8-9 */
	  {
	  case 0x0: /* xmem byte */
	  case 0x1: /* xmem word */
	  case 0x2: /* unsigned half word */
	  case 0x3: /* unsigned byte load */
	  case 0x5: /* signed word load */
	  case 0x6: /* signed half-word load */
	  case 0x7: /* signed byte load */
	    return 1;

	  case 0x4: /* signed double word load */
	    return 2;
	  } /* end switch load/xmem  */
      break;
    } /* end switch 32-6 */

  return 0;
d113 4
a116 2
/* inst_store - like inst_load, except for store instructions. */

d118 2
a119 1
inst_store(unsigned ins)
d121 27
a147 29
  /* decode top 6 bits again */
  switch (ins >> (32-6))
    {
    case 0x0: /* xmem byte imm */
    case 0x1: /* xmem word imm */
    case 0x9: /* store word imm */
    case 0xa: /* store half-word imm */
    case 0xb: /* store byte imm */
      return 1;

    case 0x8: /* store double word */
      return 2;
    case 0x3d: /* load/store/xmem scaled/unscaled instruction */
      /* check bits 15,14,12,7,6,5 are all 0 */
      if ((ins & 0x0000d0e0U) == 0)
	switch ((ins & 0x00003c00U) >> 10 ) /* decode bits 10-13 */
	  {
	  case 0x0: /* xmem byte imm */
	  case 0x1: /* xmem word imm */
	  case 0x9: /* store word */
	  case 0xa: /* store half-word */
	  case 0xb: /* store byte */
	    return 1;

	  case 0x8: /* store double word */
	    return 2;
	  } /* end switch store/xmem */
      break;
    } /* end switch 32-6 */
d149 1
a149 1
  return 0;
d152 5
a156 3
/* inst_delayed - this instruction is followed by a delay slot. Could be
   br.n, bsr.n bb0.n, bb1.n, bcnd.n or jmp.n or jsr.n */

d158 2
a159 1
inst_delayed(unsigned ins)
d161 13
a173 14
  /* check the br, bsr, bb0, bb1, bcnd cases */
  switch ((ins & 0xfc000000U)>>(32-6))
    {
    case 0x31: /* br */
    case 0x33: /* bsr */
    case 0x35: /* bb0 */
    case 0x37: /* bb1 */
    case 0x3b: /* bcnd */
      return TRUE;
    }

 /* check the jmp, jsr cases */
 /* mask out bits 0-4, bit 11 */
  return ((ins & 0xfffff7e0U) == 0xf400c400U) ? TRUE : FALSE;
a175 1
 
d193 3
a195 1
next_instr_address(db_addr_t pc, unsigned delay_slot)
d197 8
a204 9
    if (delay_slot == 0)
	return pc + 4;
    else
    {
	if (inst_delayed(db_get_value(pc,sizeof(int),FALSE)))
	   return pc + 4;
	else
	   return pc;
    }
d226 27
d254 2
a255 32
  /* check if br/bsr */
  if ((inst & 0xf0000000U) == 0xc0000000U)
    {
      /* signed 26 bit pc relative displacement, shift left two bits */
      inst = (inst & 0x03ffffffU)<<2;
      /* check if sign extension is needed */
      if (inst & 0x08000000U)
	inst |= 0xf0000000U;
      return pc + inst;
    }

  /* check if bb0/bb1/bcnd case */
  switch ((inst & 0xf8000000U))
    {
    case 0xd0000000U: /* bb0 */
    case 0xd8000000U: /* bb1 */
    case 0xe8000000U: /* bcnd */
      /* signed 16 bit pc relative displacement, shift left two bits */
      inst = (inst & 0x0000ffffU)<<2;
      /* check if sign extension is needed */
      if (inst & 0x00020000U)
	inst |= 0xfffc0000U;
      return pc + inst;
    }

  /* check jmp/jsr case */
  /* check bits 5-31, skipping 10 & 11 */
  if ((inst & 0xfffff3e0U) == 0xf400c000U)
    return (*func)(func_data, inst & 0x1f);  /* the register value */

  panic("branch_taken");
  return 0; /* keeps compiler happy */
d264 3
a266 1
getreg_val(unsigned regno, db_regs_t *frame)
d268 8
a275 8
    if (regno == 0)
	return 0;
    else if (regno < 31)
	return frame->r[regno];
    else {
	panic("bad register number to getreg_val.");
	return 0;/*to make compiler happy */
    }
@


1.5
log
@Correct argument order for branch_taken's callback function.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sstep.c,v 1.4 1999/02/09 06:36:25 smurph Exp $	*/
d29 2
@


1.4
log
@Added kernel support for user debugging.  Fixed file ID's
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sstep.c,v 1.28 1995/04/19 22:37:27 smurph Exp $	*/
d211 6
a216 6
unsigned
branch_taken(
    unsigned inst,
    unsigned pc,
    db_expr_t (*func)(unsigned int, db_regs_t *),
    db_regs_t *func_data)  /* 'opaque' */
d247 1
a247 1
    return (*func)(inst & 0x1f, func_data);  /* the register value */
@


1.4.6.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sstep.c,v 1.7 2001/03/16 00:01:51 miod Exp $	*/
a28 2
#include <sys/param.h>
#include <sys/systm.h>
d39 2
a40 2
boolean_t inst_delayed __P((unsigned ins));
db_expr_t getreg_val __P((unsigned regno, db_regs_t *frame));
a41 4
/*
 * Returns TRUE is the instruction a branch or jump instruction
 * (br, bb0, bb1, bcnd, jmp) but not a function call (bsr or jsr)
 */
d43 1
a43 2
inst_branch(ins)
	unsigned ins;
d45 14
a58 12
	/* check high five bits */
	switch (ins >> (32 - 5)) {
	case 0x18: /* br */
	case 0x1a: /* bb0 */
	case 0x1b: /* bb1 */
	case 0x1d: /* bcnd */
		return TRUE;
		break;
	case 0x1e: /* could be jmp */
		if ((ins & 0xfffffbe0U) == 0xf400c000U)
		return TRUE;
	}
d60 1
a60 1
	return FALSE;
d63 3
a65 5
/* 
 * inst_load(ins)
 * Returns the number of words the instruction loads. byte,
 * half and word count as 1; double word as 2
 */
d67 1
a67 2
inst_load(ins)
	unsigned ins;
d69 35
a103 32
	/* look at the top six bits, for starters */
	switch (ins >> (32 - 6)) {
	case 0x0: /* xmem byte imm */
	case 0x1: /* xmem word imm */

	case 0x2: /* unsigned half-word load imm */
	case 0x3: /* unsigned byte load imm */
	case 0x5: /* signed word load imm */
	case 0x6: /* signed half-word load imm */
	case 0x7: /* signed byte load imm */
		return 1;

	case 0x4: /* signed double word load imm */
		return 2;

	case 0x3d: /* load/store/xmem scaled/unscaled instruction */
		if ((ins & 0xf400c0e0U) == 0xf4000000U) /* is load/xmem */
			switch ((ins & 0x0000fce0) >> 5) { /* look at bits 15-5, but mask bits 8-9 */
			case 0x0: /* xmem byte */
			case 0x1: /* xmem word */
			case 0x2: /* unsigned half word */
			case 0x3: /* unsigned byte load */
			case 0x5: /* signed word load */
			case 0x6: /* signed half-word load */
			case 0x7: /* signed byte load */
				return 1;

			case 0x4: /* signed double word load */
				return 2;
		} /* end switch load/xmem  */
		break;
	} /* end switch 32-6 */
d105 1
a105 1
	return 0;
d108 2
a109 4
/*
 * inst_store
 * Like inst_load, except for store instructions.
 */
d111 1
a111 2
inst_store(ins)
	unsigned ins;
d113 29
a141 27
	/* decode top 6 bits again */
	switch (ins >> (32 - 6)) {
	case 0x0: /* xmem byte imm */
	case 0x1: /* xmem word imm */
	case 0x9: /* store word imm */
	case 0xa: /* store half-word imm */
	case 0xb: /* store byte imm */
		return 1;

	case 0x8: /* store double word */
		return 2;
	case 0x3d: /* load/store/xmem scaled/unscaled instruction */
		/* check bits 15,14,12,7,6,5 are all 0 */
		if ((ins & 0x0000d0e0U) == 0)
			switch ((ins & 0x00003c00U) >> 10) { /* decode bits 10-13 */
			case 0x0: /* xmem byte imm */
			case 0x1: /* xmem word imm */
			case 0x9: /* store word */
			case 0xa: /* store half-word */
			case 0xb: /* store byte */
				return 1;

			case 0x8: /* store double word */
				return 2;
			} /* end switch store/xmem */
		break;
	} /* end switch 32-6 */
d143 1
a143 1
	return 0;
d146 3
a148 5
/*
 * inst_delayed
 * Returns TRUE if this instruction is followed by a delay slot.
 * Could be br.n, bsr.n bb0.n, bb1.n, bcnd.n or jmp.n or jsr.n
 */
d150 1
a150 2
inst_delayed(ins)
	unsigned ins;
d152 14
a165 13
	/* check the br, bsr, bb0, bb1, bcnd cases */
	switch ((ins & 0xfc000000U) >> (32 - 6)) {
	case 0x31: /* br */
	case 0x33: /* bsr */
	case 0x35: /* bb0 */
	case 0x37: /* bb1 */
	case 0x3b: /* bcnd */
		return TRUE;
	}

	/* check the jmp, jsr cases */
	/* mask out bits 0-4, bit 11 */
	return ((ins & 0xfffff7e0U) == 0xf400c400U) ? TRUE : FALSE;
d168 1
d186 1
a186 3
next_instr_address(pc, delay_slot)
	db_addr_t pc;
	unsigned delay_slot;
d188 9
a196 8
	if (delay_slot == 0)
		return pc + 4;
	else {
		if (inst_delayed(db_get_value(pc, sizeof(int), FALSE)))
			return pc + 4;
		else
			return pc;
	}
d211 6
a216 6
db_addr_t
branch_taken(inst, pc, func, func_data)
	u_int inst;
	db_addr_t pc;
	db_expr_t (*func) __P((db_regs_t *, int));
	db_regs_t *func_data;
a217 27
	/* check if br/bsr */
	if ((inst & 0xf0000000U) == 0xc0000000U) {
		/* signed 26 bit pc relative displacement, shift left two bits */
		inst = (inst & 0x03ffffffU) << 2;
		/* check if sign extension is needed */
		if (inst & 0x08000000U)
			inst |= 0xf0000000U;
		return pc + inst;
	}

	/* check if bb0/bb1/bcnd case */
	switch ((inst & 0xf8000000U)) {
	case 0xd0000000U: /* bb0 */
	case 0xd8000000U: /* bb1 */
	case 0xe8000000U: /* bcnd */
		/* signed 16 bit pc relative displacement, shift left two bits */
		inst = (inst & 0x0000ffffU) << 2;
		/* check if sign extension is needed */
		if (inst & 0x00020000U)
			inst |= 0xfffc0000U;
		return pc + inst;
	}

	/* check jmp/jsr case */
	/* check bits 5-31, skipping 10 & 11 */
	if ((inst & 0xfffff3e0U) == 0xf400c000U)
		return (*func)(func_data, inst & 0x1f);  /* the register value */
d219 32
a250 2
	panic("branch_taken");
	return 0; /* keeps compiler happy */
d259 1
a259 3
getreg_val(regno, frame)
	unsigned regno;
	db_regs_t *frame;
d261 8
a268 8
	if (regno == 0)
		return 0;
	else if (regno < 31)
		return frame->r[regno];
	else {
		panic("bad register number to getreg_val.");
		return 0;/*to make compiler happy */
	}
@


1.4.6.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a32 1
#include <ddb/db_break.h>	/* db_breakpoint_t */
d41 2
a42 6
boolean_t inst_delayed __P((unsigned int ins));

#ifdef INTERNAL_SSTEP
db_breakpoint_t db_not_taken_bkpt = 0;
db_breakpoint_t db_taken_bkpt = 0;
#endif 
d50 1
a50 1
	unsigned int ins;
d62 1
a62 1
			return TRUE;
d75 1
a75 1
	unsigned int ins;
d93 1
a93 1
		if ((ins & 0xf400c0e0U) == 0xf4000000U)	/* is load/xmem */
d106 1
a106 1
			} /* end switch load/xmem  */
d119 1
a119 1
	unsigned int ins;
d159 1
a159 1
	unsigned int ins;
d251 2
a252 4
	if ((inst & 0xfffff3e0U) == 0xf400c000U) {
		return (*func)(func_data, (inst & 0x0000001fU));  /* the register value */
	}

d263 3
a265 3

register_t
getreg_val(frame, regno)
a266 1
	int regno;
d273 1
a273 1
		panic("bad register number (%d) to getreg_val.", regno);
a276 53

#ifdef INTERNAL_SSTEP
void
db_set_single_step(regs)
	register db_regs_t *regs;
{
	if (cputyp == CPU_88110) {
		((regs)->epsr |= (PSR_TRACE | PSR_SER));
	} else {
		db_addr_t pc = PC_REGS(regs);
#ifndef SOFTWARE_SSTEP_EMUL
		db_addr_t brpc;
		u_int inst;

		/*
		 * User was stopped at pc, e.g. the instruction
		 * at pc was not executed.
		 */
		inst = db_get_value(pc, sizeof(int), FALSE);
		if (inst_branch(inst) || inst_call(inst) || inst_return(inst)) {
			brpc = branch_taken(inst, pc, getreg_val, regs);
			if (brpc != pc) {	/* self-branches are hopeless */
				db_taken_bkpt = db_set_temp_breakpoint(brpc);
			}
#if 0
			/* XXX this seems like a true bug, no?  */
			pc = next_instr_address(pc, 1);
#endif
		}
#endif /*SOFTWARE_SSTEP_EMUL*/
		pc = next_instr_address(pc, 0);
		db_not_taken_bkpt = db_set_temp_breakpoint(pc);
	}
}

void
db_clear_single_step(regs)
	db_regs_t *regs;
{
	if (cputyp == CPU_88110) {
		((regs)->epsr &= ~(PSR_TRACE | PSR_SER));
	} else {
		if (db_taken_bkpt != 0) {
			db_delete_temp_breakpoint(db_taken_bkpt);
			db_taken_bkpt = 0;
		}
		if (db_not_taken_bkpt != 0) {
			db_delete_temp_breakpoint(db_not_taken_bkpt);
			db_not_taken_bkpt = 0;
		}
	}
}
#endif 
@


1.4.6.3
log
@Merge in -current from about a week ago
@
text
@d42 1
a42 1
boolean_t inst_delayed(unsigned int ins);
d228 1
a228 1
	db_expr_t (*func)(db_regs_t *, int);
@


1.4.6.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a30 1

a31 1

d47 1
a47 1
#endif
d73 1
a73 1
/*
d271 1
a271 1
db_expr_t
d280 1
a280 1
	else
d282 2
d289 1
a289 1
	db_regs_t *regs;
d337 1
a337 1
#endif
@


1.3
log
@Cleanup after import. This also seems to bring up the current version.
@
text
@d1 1
@


1.2
log
@This is a remove to get rid of the old mvme88k port which was incomplete
to replace it with a working version. The kernel compiles and works
at least.  The new version will be imported shortly.
@
text
@d44 14
a57 1
	/* check high five bits */
d59 2
a60 11
	switch (ins >> (32 - 5)) {
	case 0x18:		/* br */
	case 0x1a:		/* bb0 */
	case 0x1b:		/* bb1 */
	case 0x1d:		/* bcnd */
		return TRUE;
		break;
	case 0x1e:		/* could be jmp */
		if ((ins & 0xfffffbe0 U) == 0xf400c000 U)
			return TRUE;
	}
a61 2
	return FALSE;
}
d68 1
a68 1
	/* look at the top six bits, for starters */
d70 33
a102 32
	switch (ins >> (32 - 6)) {
		case 0x0:	/* xmem byte imm */
		case 0x1:	/* xmem word imm */

		case 0x2:	/* unsigned half-word load imm */
		case 0x3:	/* unsigned byte load imm */
		case 0x5:	/* signed word load imm */
		case 0x6:	/* signed half-word load imm */
		case 0x7:	/* signed byte load imm */
		return 1;

	case 0x4:		/* signed double word load imm */
		return 2;

	case 0x3d:		/* load/store/xmem scaled/unscaled instruction */
		if ((ins & 0xf400c0e0 U) == 0xf4000000 U)	/* is load/xmem */
			switch ((ins & 0x0000fce0) >> 5) {	/* look at bits 15-5,
								 * but mask bits 8-9 */
			case 0x0:	/* xmem byte */
			case 0x1:	/* xmem word */
			case 0x2:	/* unsigned half word */
			case 0x3:	/* unsigned byte load */
			case 0x5:	/* signed word load */
			case 0x6:	/* signed half-word load */
			case 0x7:	/* signed byte load */
				return 1;

			case 0x4:	/* signed double word load */
				return 2;
			}	/* end switch load/xmem  */
		break;
	}			/* end switch 32-6 */
d104 1
a104 1
	return 0;
d106 1
d112 29
a140 27
	/* decode top 6 bits again */
	switch (ins >> (32 - 6)) {
		case 0x0:	/* xmem byte imm */
		case 0x1:	/* xmem word imm */
		case 0x9:	/* store word imm */
		case 0xa:	/* store half-word imm */
		case 0xb:	/* store byte imm */
		return 1;

	case 0x8:		/* store double word */
		return 2;
	case 0x3d:		/* load/store/xmem scaled/unscaled instruction */
		/* check bits 15,14,12,7,6,5 are all 0 */
		if ((ins & 0x0000d0e0 U) == 0)
			switch ((ins & 0x00003c00 U) >> 10) {	/* decode bits 10-13 */
			case 0x0:	/* xmem byte imm */
			case 0x1:	/* xmem word imm */
			case 0x9:	/* store word */
			case 0xa:	/* store half-word */
			case 0xb:	/* store byte */
				return 1;

			case 0x8:	/* store double word */
				return 2;
			}	/* end switch store/xmem */
		break;
	}			/* end switch 32-6 */
d142 1
a142 1
	return 0;
d144 1
d151 14
a164 13
	/* check the br, bsr, bb0, bb1, bcnd cases */
	switch ((ins & 0xfc000000 U) >> (32 - 6)) {
	case 0x31:		/* br */
	case 0x33:		/* bsr */
	case 0x35:		/* bb0 */
	case 0x37:		/* bb1 */
	case 0x3b:		/* bcnd */
		return TRUE;
	}

	/* check the jmp, jsr cases */
	/* mask out bits 0-4, bit 11 */
	return ((ins & 0xfffff7e0 U) == 0xf400c400 U) ? TRUE : FALSE;
d167 1
a167 1

d187 9
a195 8
	if (delay_slot == 0)
		return pc + 4;
	else {
		if (inst_delayed(db_get_value(pc, sizeof(int), FALSE)))
			return pc + 4;
		else
			return pc;
	}
d214 33
a246 30
    db_expr_t(*func) (unsigned int, db_regs_t *),
    db_regs_t * func_data)
{				/* 'opaque' */

	/* check if br/bsr */
	if ((inst & 0xf0000000 U) == 0xc0000000 U) {
		/* signed 26 bit pc relative displacement, shift left two bits */
		inst = (inst & 0x03ffffff U) << 2;
		/* check if sign extension is needed */
		if (inst & 0x08000000 U)
			inst |= 0xf0000000 U;
		return pc + inst;
	}
	/* check if bb0/bb1/bcnd case */
	switch ((inst & 0xf8000000 U)) {
	case 0xd0000000 U:	/* bb0 */
	case 0xd8000000 U:	/* bb1 */
	case 0xe8000000 U:	/* bcnd */
		/* signed 16 bit pc relative displacement, shift left two bits */
		inst = (inst & 0x0000ffff U) << 2;
		/* check if sign extension is needed */
		if (inst & 0x00020000 U)
			inst |= 0xfffc0000 U;
		return pc + inst;
	}

	/* check jmp/jsr case */
	/* check bits 5-31, skipping 10 & 11 */
	if ((inst & 0xfffff3e0 U) == 0xf400c000 U)
		return (*func) (inst & 0x1f, func_data);	/* the register value */
d248 2
a249 2
	panic("branch_taken");
	return 0;		/* keeps compiler happy */
d251 1
d258 1
a258 1
getreg_val(unsigned regno, db_regs_t * frame)
d260 8
a267 9
	if (regno == 0)
		return 0;
	else
		if (regno < 31)
			return frame->r[regno];
		else {
			panic("bad register number to getreg_val.");
			return 0;	/* to make compiler happy */
		}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@initial 88k import; code by nivas and based on mach luna88k
@
text
@@


1.1.1.2
log
@Third try at importing the mvme88k port. This is a working kernel
from nivas.
Userland and compiler still need to be worked on.
Make certain what directory the import is done from.
@
text
@d44 1
a44 14
  /* check high five bits */
 
  switch (ins >> (32-5))
    {
    case 0x18: /* br */
    case 0x1a: /* bb0 */
    case 0x1b: /* bb1 */
    case 0x1d: /* bcnd */
      return TRUE;
      break;
    case 0x1e: /* could be jmp */
      if ((ins & 0xfffffbe0U) == 0xf400c000U)
	return TRUE;
    }
d46 13
a58 1
  return FALSE;
a59 1

d66 1
a66 1
  /* look at the top six bits, for starters */
d68 32
a99 33
  switch (ins >> (32-6))
    {
    case 0x0: /* xmem byte imm */
    case 0x1: /* xmem word imm */

    case 0x2: /* unsigned half-word load imm */
    case 0x3: /* unsigned byte load imm */
    case 0x5: /* signed word load imm */
    case 0x6: /* signed half-word load imm */
    case 0x7: /* signed byte load imm */
      return 1;

    case 0x4: /* signed double word load imm */
      return 2;

    case 0x3d: /* load/store/xmem scaled/unscaled instruction */
      if ((ins & 0xf400c0e0U) == 0xf4000000U) /* is load/xmem */
	switch ((ins & 0x0000fce0)>>5)  /* look at bits 15-5, but mask bits 8-9 */
	  {
	  case 0x0: /* xmem byte */
	  case 0x1: /* xmem word */
	  case 0x2: /* unsigned half word */
	  case 0x3: /* unsigned byte load */
	  case 0x5: /* signed word load */
	  case 0x6: /* signed half-word load */
	  case 0x7: /* signed byte load */
	    return 1;

	  case 0x4: /* signed double word load */
	    return 2;
	  } /* end switch load/xmem  */
      break;
    } /* end switch 32-6 */
d101 1
a101 1
  return 0;
a102 1

d108 27
a134 29
  /* decode top 6 bits again */
  switch (ins >> (32-6))
    {
    case 0x0: /* xmem byte imm */
    case 0x1: /* xmem word imm */
    case 0x9: /* store word imm */
    case 0xa: /* store half-word imm */
    case 0xb: /* store byte imm */
      return 1;

    case 0x8: /* store double word */
      return 2;
    case 0x3d: /* load/store/xmem scaled/unscaled instruction */
      /* check bits 15,14,12,7,6,5 are all 0 */
      if ((ins & 0x0000d0e0U) == 0)
	switch ((ins & 0x00003c00U) >> 10 ) /* decode bits 10-13 */
	  {
	  case 0x0: /* xmem byte imm */
	  case 0x1: /* xmem word imm */
	  case 0x9: /* store word */
	  case 0xa: /* store half-word */
	  case 0xb: /* store byte */
	    return 1;

	  case 0x8: /* store double word */
	    return 2;
	  } /* end switch store/xmem */
      break;
    } /* end switch 32-6 */
d136 1
a136 1
  return 0;
a137 1

d144 13
a156 14
  /* check the br, bsr, bb0, bb1, bcnd cases */
  switch ((ins & 0xfc000000U)>>(32-6))
    {
    case 0x31: /* br */
    case 0x33: /* bsr */
    case 0x35: /* bb0 */
    case 0x37: /* bb1 */
    case 0x3b: /* bcnd */
      return TRUE;
    }

 /* check the jmp, jsr cases */
 /* mask out bits 0-4, bit 11 */
  return ((ins & 0xfffff7e0U) == 0xf400c400U) ? TRUE : FALSE;
d159 1
a159 1
 
d179 8
a186 9
    if (delay_slot == 0)
	return pc + 4;
    else
    {
	if (inst_delayed(db_get_value(pc,sizeof(int),FALSE)))
	   return pc + 4;
	else
	   return pc;
    }
d205 30
a234 33
    db_expr_t (*func)(unsigned int, db_regs_t *),
    db_regs_t *func_data)  /* 'opaque' */
{

  /* check if br/bsr */
  if ((inst & 0xf0000000U) == 0xc0000000U)
    {
      /* signed 26 bit pc relative displacement, shift left two bits */
      inst = (inst & 0x03ffffffU)<<2;
      /* check if sign extension is needed */
      if (inst & 0x08000000U)
	inst |= 0xf0000000U;
      return pc + inst;
    }

  /* check if bb0/bb1/bcnd case */
  switch ((inst & 0xf8000000U))
    {
    case 0xd0000000U: /* bb0 */
    case 0xd8000000U: /* bb1 */
    case 0xe8000000U: /* bcnd */
      /* signed 16 bit pc relative displacement, shift left two bits */
      inst = (inst & 0x0000ffffU)<<2;
      /* check if sign extension is needed */
      if (inst & 0x00020000U)
	inst |= 0xfffc0000U;
      return pc + inst;
    }

  /* check jmp/jsr case */
  /* check bits 5-31, skipping 10 & 11 */
  if ((inst & 0xfffff3e0U) == 0xf400c000U)
    return (*func)(inst & 0x1f, func_data);  /* the register value */
d236 2
a237 2
  panic("branch_taken");
  return 0; /* keeps compiler happy */
a238 1

d245 1
a245 1
getreg_val(unsigned regno, db_regs_t *frame)
d247 9
a255 8
    if (regno == 0)
	return 0;
    else if (regno < 31)
	return frame->r[regno];
    else {
	panic("bad register number to getreg_val.");
	return 0;/*to make compiler happy */
    }
@
