head	1.62;
access;
symbols
	OPENBSD_5_5:1.61.0.4
	OPENBSD_5_5_BASE:1.61
	OPENBSD_5_4:1.60.0.2
	OPENBSD_5_4_BASE:1.60
	OPENBSD_5_3:1.57.0.12
	OPENBSD_5_3_BASE:1.57
	OPENBSD_5_2:1.57.0.10
	OPENBSD_5_2_BASE:1.57
	OPENBSD_5_1_BASE:1.57
	OPENBSD_5_1:1.57.0.8
	OPENBSD_5_0:1.57.0.6
	OPENBSD_5_0_BASE:1.57
	OPENBSD_4_9:1.57.0.4
	OPENBSD_4_9_BASE:1.57
	OPENBSD_4_8:1.57.0.2
	OPENBSD_4_8_BASE:1.57
	OPENBSD_4_7:1.54.0.2
	OPENBSD_4_7_BASE:1.54
	OPENBSD_4_6:1.51.0.10
	OPENBSD_4_6_BASE:1.51
	OPENBSD_4_5:1.51.0.6
	OPENBSD_4_5_BASE:1.51
	OPENBSD_4_4:1.51.0.4
	OPENBSD_4_4_BASE:1.51
	OPENBSD_4_3:1.51.0.2
	OPENBSD_4_3_BASE:1.51
	OPENBSD_4_2:1.49.0.2
	OPENBSD_4_2_BASE:1.49
	OPENBSD_4_1:1.48.0.4
	OPENBSD_4_1_BASE:1.48
	OPENBSD_4_0:1.48.0.2
	OPENBSD_4_0_BASE:1.48
	OPENBSD_3_9:1.45.0.2
	OPENBSD_3_9_BASE:1.45
	OPENBSD_3_8:1.43.0.2
	OPENBSD_3_8_BASE:1.43
	OPENBSD_3_7:1.42.0.2
	OPENBSD_3_7_BASE:1.42
	OPENBSD_3_6:1.41.0.2
	OPENBSD_3_6_BASE:1.41
	SMP_SYNC_A:1.33
	SMP_SYNC_B:1.33
	OPENBSD_3_5:1.30.0.2
	OPENBSD_3_5_BASE:1.30
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	UBC_SYNC_A:1.18
	OPENBSD_3_3:1.18.0.4
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	UBC_SYNC_B:1.18
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SMP:1.1.0.4
	SMP_BASE:1.1
	kame_19991208:1.1
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.62
date	2014.03.18.22.36.35;	author miod;	state dead;
branches;
next	1.61;

1.61
date	2013.09.21.20.05.01;	author miod;	state Exp;
branches;
next	1.60;

1.60
date	2013.06.11.21.06.31;	author miod;	state Exp;
branches;
next	1.59;

1.59
date	2013.05.17.22.51.59;	author miod;	state Exp;
branches;
next	1.58;

1.58
date	2013.05.17.22.46.27;	author miod;	state Exp;
branches;
next	1.57;

1.57
date	2010.07.02.17.27.01;	author nicm;	state Exp;
branches;
next	1.56;

1.56
date	2010.06.28.14.13.29;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2010.04.12.12.57.52;	author tedu;	state Exp;
branches;
next	1.54;

1.54
date	2009.11.09.17.53.39;	author nicm;	state Exp;
branches;
next	1.53;

1.53
date	2009.10.31.12.00.07;	author fgsch;	state Exp;
branches;
next	1.52;

1.52
date	2009.10.31.06.40.16;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2008.01.23.16.37.57;	author jsing;	state Exp;
branches;
next	1.50;

1.50
date	2007.12.27.23.17.53;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2007.05.19.20.35.20;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2006.05.08.14.36.10;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2006.04.17.13.30.02;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2006.04.15.22.32.42;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2006.01.01.11.59.39;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2005.10.13.19.48.34;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2005.04.30.16.40.42;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2004.11.13.14.47.35;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2004.08.24.18.44.49;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2004.08.19.17.10.15;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2004.08.02.08.35.00;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2004.07.31.22.26.27;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2004.07.30.19.02.05;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2004.07.23.23.15.49;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2004.07.23.21.01.09;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2004.07.02.14.00.43;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2004.04.24.19.51.47;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2004.04.16.23.32.44;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2004.04.15.12.35.20;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2004.02.11.20.41.07;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2004.02.10.10.30.25;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2004.02.10.10.06.48;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2004.01.14.20.50.48;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2003.10.23.19.03.26;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2003.10.11.22.08.57;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2003.10.03.16.44.50;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2003.09.28.14.26.25;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2003.09.22.21.39.39;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2003.08.21.21.48.23;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2003.08.15.20.32.14;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2003.08.12.19.32.45;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.12.03.49.56;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2002.04.28.15.17.09;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.14.01.26.39;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.19.07.04.41;	author smurph;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.12.16.23.49.46;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.13.08.55.51;	author smurph;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.31.08.18.24;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.31.01.05.44;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.26.02.37.07;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.24.19.32.06;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.24.19.26.12;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.04.08.09.21;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.09.05.44.38;	author smurph;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.07.23.45.50;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.12.08.16.22;	author smurph;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.01.03.38.14;	author smurph;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.26.23.32.00;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	99.09.27.18.43.23;	author smurph;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2001.04.18.16.10.54;	author niklas;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2001.10.31.03.01.18;	author nate;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2002.03.06.02.04.44;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2002.03.28.10.36.02;	author niklas;	state Exp;
branches;
next	1.1.4.5;

1.1.4.5
date	2003.03.27.23.32.17;	author niklas;	state Exp;
branches;
next	1.1.4.6;

1.1.4.6
date	2004.02.19.10.49.06;	author niklas;	state Exp;
branches;
next	1.1.4.7;

1.1.4.7
date	2004.06.05.23.09.49;	author niklas;	state Exp;
branches;
next	;

1.15.2.1
date	2002.06.11.03.37.09;	author art;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2002.10.29.00.28.07;	author art;	state Exp;
branches;
next	;


desc
@@


1.62
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: dart.c,v 1.61 2013/09/21 20:05:01 miod Exp $	*/

/*
 * Copyright (c) 2013 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * Mach Operating System
 * Copyright (c) 1993-1991 Carnegie Mellon University
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON AND OMRON ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON AND OMRON DISCLAIM ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>

#include <machine/autoconf.h>
#include <machine/board.h>
#include <machine/conf.h>
#include <machine/cpu.h>

#include <dev/cons.h>

#include <dev/ic/mc68681reg.h>
#include <dev/ic/mc68681var.h>

#include <machine/mvme181.h>
#include <machine/mvme188.h>

struct dartsoftc {
	struct mc68681_softc	sc_base;
	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
	struct intrhand		sc_ih;
};

int	dartmatch(struct device *parent, void *self, void *aux);
void	dartattach(struct device *parent, struct device *self, void *aux);

struct cfattach dart_ca = {
	sizeof(struct dartsoftc), dartmatch, dartattach
};

/* console, if applicable, will always be on the first port */
#define	CONS_PORT	A_PORT

cons_decl(dart);
int	dartintr(void *);
uint8_t	dart_read(void *, uint);
void	dart_write(void *, uint, uint8_t);

/*
 * DUART registers are mapped as the least-significant byte of 32-bit addresses.
 * The MVME188 documentation recommends using 32-bit accesses.
 */

uint8_t
dart_read(void *v, uint reg)
{
	struct dartsoftc *sc = v;

	return (uint8_t)bus_space_read_4(sc->sc_iot, sc->sc_ioh, reg << 2);
}

void
dart_write(void *v, uint reg, uint8_t val)
{
	struct dartsoftc *sc = v;

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, reg << 2, val);
	/*
	 * Multiple accesses to the same command register must be delayed,
	 * to prevent the chip from misbehaving.
	 */
	if (reg == DART_CRA || reg == DART_CRB)
		DELAY(2);
}

int
dartmatch(struct device *parent, void *cf, void *aux)
{
	struct confargs *ca = aux;
	bus_space_handle_t ioh;
	int rc;

	/*
	 * We do not accept empty locators here...
	 */
	switch (brdtyp) {
#ifdef MVME181
	case BRD_180:
	case BRD_181:
		if (ca->ca_paddr != M181_DUART)
			return 0;
		break;
#endif
#ifdef MVME188
	case BRD_188:
		if (ca->ca_paddr != DART_BASE)
			return 0;
		break;
#endif
	default:
		return 0;
	}

	if (bus_space_map(ca->ca_iot, ca->ca_paddr, DART_SIZE << 2, 0, &ioh) !=
	    0)
		return 0;
	rc = badaddr((vaddr_t)bus_space_vaddr(ca->ca_iot, ioh), 4);
	bus_space_unmap(ca->ca_iot, ca->ca_paddr, DART_SIZE << 2);

	return rc == 0;
}

void
dartattach(struct device *parent, struct device *self, void *aux)
{
	struct dartsoftc *sc = (struct dartsoftc *)self;
	struct mc68681_softc *msc = &sc->sc_base;
	struct confargs *ca = aux;
	bus_space_handle_t ioh;

	if (ca->ca_ipl < 0)
		ca->ca_ipl = IPL_TTY;

	sc->sc_iot = ca->ca_iot;
	if (bus_space_map(sc->sc_iot, ca->ca_paddr, DART_SIZE << 2, 0, &ioh) !=
	    0) {
		printf(": can't map registers!\n");
		return;
	}
	sc->sc_ioh = ioh;

	/*
	 * Although we are still running using the BUG routines,
	 * this device will be elected as the console after autoconf.
	 * We do not even test since we know we are an MVME181 or
	 * an MVME188 and console is always on the first port.
	 */
	msc->sc_consport = CONS_PORT;
	msc->sc_sw_reg = &msc->sc_sw_reg_store;

	msc->sc_read = dart_read;
	msc->sc_write = dart_write;

	/*
	 * Interrupt configuration.
	 * When running on an AngelFire board, we need to enable the timer
	 * interrupt since the timer output is not wired to a specific
	 * output port.
	 */
#ifdef MVME181
	if (brdtyp == BRD_180 || brdtyp == BRD_181)
		msc->sc_sw_reg->imr = DART_ISR_CT;
#endif

	/*
	 * Input Port configuration.
	 *
	 * On MVME188, they are as follows:
	 *   IP0 = port A CTS
	 *   IP1 = port B CTS
	 *   IP2 and IP4 = port A DCD
	 *   IP3 and IP5 = port B DCD
	 */
	msc->sc_hw[A_PORT].dcd_ip = 2;
	msc->sc_hw[A_PORT].dcd_active_low = 1;
	msc->sc_hw[B_PORT].dcd_ip = 3;
	msc->sc_hw[B_PORT].dcd_active_low = 1;
	msc->sc_sw_reg->acr |=
	    DART_ACR_ISR_IP3_CHANGE_ENABLE | DART_ACR_ISR_IP2_CHANGE_ENABLE;

	/*
	 * Output Port configuration.
	 *
	 * On MVME188, they are as follow:
	 *   OP0 = port A RTS
	 *   OP1 = port B RTS
	 *   OP2 = port A DTR
	 *   OP3 = timer output
	 *   OP5 = port B DTR
	 *
	 * On MVME180 and MVME181 boards, the timer output is not wired to
	 * OP3. Apparently MVME180 routes port B DTR to OP3, while MVME181
	 * is MVME188 compatible.
	 */
	msc->sc_hw[A_PORT].dtr_op = 2;
	msc->sc_hw[A_PORT].rts_op = 0;
#ifdef MVME181
	if (brdtyp == BRD_180)
		msc->sc_hw[B_PORT].dtr_op = 3;
	else
#endif
		msc->sc_hw[B_PORT].dtr_op = 5;
	msc->sc_hw[B_PORT].rts_op = 1;
#ifdef MVME181
	if (brdtyp == BRD_180)
		msc->sc_sw_reg->oprs = 
		    DART_OP_OP3 | DART_OP_OP2 | DART_OP_OP1 | DART_OP_OP0;
	else
#endif
		msc->sc_sw_reg->oprs = 
		    DART_OP_OP5 | DART_OP_OP2 | DART_OP_OP1 | DART_OP_OP0;
	msc->sc_sw_reg->opcr = DART_OPCR_OP7 | DART_OPCR_OP6 |
	    DART_OPCR_OP5 | DART_OPCR_OP4 | DART_OPCR_OP3 | DART_OPCR_OP2;

	/*
	 * Clock configuration.
	 *
	 * MVME181 uses the timer mode, MVME188 uses the counter mode.
	 */
#ifdef MVME181
	if (brdtyp == BRD_180 || brdtyp == BRD_181) {
		extern int m181_clkint;	/* XXX */

		msc->sc_sw_reg->acr = DART_ACR_CT_TIMER_CLK_16;
		msc->sc_sw_reg->ct = &m181_clkint;
	} else
#endif
		msc->sc_sw_reg->acr = DART_ACR_CT_COUNTER_CLK_16;

	mc68681_common_attach(msc);

	/* enable interrupts */
	sc->sc_ih.ih_fn = dartintr;
	sc->sc_ih.ih_arg = sc;
	sc->sc_ih.ih_wantframe = 0;
	sc->sc_ih.ih_ipl = ca->ca_ipl;

	platform->intsrc_establish(INTSRC_DUART, &sc->sc_ih, self->dv_xname);
}

int
dartintr(void *arg)
{
	struct mc68681_softc *sc = arg;
	uint8_t isr, imr;
	int rc;

	isr = (*sc->sc_read)(sc, DART_ISR);
	imr = sc->sc_sw_reg->imr;

	isr &= imr;
	if (isr == 0)
		return 0;

	rc = 1;

#ifdef MVME181
	if (isr & DART_ISR_CT) {
		rc = -1;	/* needs to be handled by the second
				   interrupt handler */
		isr &= ~DART_ISR_CT;
	}
#endif
	if (isr != 0)
		mc68681_intr(sc, isr);

	return rc;
}

/*
 * Console interface routines.
 * Since we select the actual console after all devices are attached,
 * we can safely pick the appropriate softc and use its information.
 */

extern struct cfdriver dart_cd;

void
dartcnprobe(struct consdev *cp)
{
	int maj;

	switch (brdtyp) {
#ifdef MVME181
	case BRD_180:
	case BRD_181:
		break;
#endif
#ifdef MVME188
	case BRD_188:
		break;
#endif
	default:
		return;
	}

	/* do not attach as console if dart0 has not attached */
	if (dart_cd.cd_ndevs == 0 || dart_cd.cd_devs[0] == NULL)
		return;

	/* locate the major number */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == dartopen)
			break;
	if (maj == nchrdev)
		return;

	cp->cn_dev = makedev(maj, CONS_PORT);
	cp->cn_pri = CN_LOWPRI;
}

void
dartcninit(cp)
	struct consdev *cp;
{
}

void
dartcnputc(dev_t dev, int c)
{
	struct dartsoftc *sc;
	int s;

	sc = (struct dartsoftc *)dart_cd.cd_devs[0];

	s = spltty();

	/* inhibit interrupts on the chip */
	dart_write(sc, DART_IMR, sc->sc_base.sc_sw_reg->imr & ~DART_ISR_TXA);
	/* make sure transmitter is enabled */
	dart_write(sc, DART_CRA, DART_CR_TX_ENABLE);

	while ((dart_read(sc, DART_SRA) & DART_SR_TX_READY) == 0)
		;
	dart_write(sc, DART_TBA, c);

	/* wait for transmitter to empty */
	while ((dart_read(sc, DART_SRA) & DART_SR_TX_EMPTY) == 0)
		;

	/* restore the previous state */
	dart_write(sc, DART_IMR, sc->sc_base.sc_sw_reg->imr);
	dart_write(sc, DART_CRA, sc->sc_base.sc_sw_reg->cr[0]);

	splx(s);
}

int
dartcngetc(dev_t dev)
{
	struct dartsoftc *sc;
	uint8_t sr;		/* status reg of port a/b */
	u_char c;		/* received character */
	int s;

	sc = (struct dartsoftc *)dart_cd.cd_devs[0];

	s = spltty();

	/* enable receiver */
	dart_write(sc, DART_CRA, DART_CR_RX_ENABLE);

	for (;;) {
		/* read status reg */
		sr = dart_read(sc, DART_SRA);

		/* receiver interrupt handler */
		if (sr & DART_SR_RX_READY) {
			/* read character from port */
			c = dart_read(sc, DART_RBA);

			/* check break and error conditions */
			if (sr & DART_SR_BREAK) {
				dart_write(sc, DART_CRA, DART_CR_RESET_BREAK);
				dart_write(sc, DART_CRA, DART_CR_RESET_ERROR);
			} else if (sr & (DART_SR_FRAME | DART_SR_PARITY |
			    DART_SR_OVERRUN)) {
				dart_write(sc, DART_CRA, DART_CR_RESET_ERROR);
			} else
				break;
		}
	}
	splx(s);

	return (int)c;
}
@


1.61
log
@Allow for an out-of-softc indirection to reach the software copy of the
important (and write-only) register state; this will allow this driver to
be used as a console before it attaches, to be used shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.60 2013/06/11 21:06:31 miod Exp $	*/
@


1.60
log
@switch mvme88k to the MI dart(4) code. Tested on MVME181 and MVME188.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d173 1
d186 1
a186 1
		msc->sc_sw_reg.imr = DART_ISR_CT;
d202 1
a202 1
	msc->sc_sw_reg.acr |=
d230 1
a230 1
		msc->sc_sw_reg.oprs = 
d234 1
a234 1
		msc->sc_sw_reg.oprs = 
d236 1
a236 1
	msc->sc_sw_reg.opcr = DART_OPCR_OP7 | DART_OPCR_OP6 |
d248 2
a249 2
		msc->sc_sw_reg.acr = DART_ACR_CT_TIMER_CLK_16;
		msc->sc_sw_reg.ct = &m181_clkint;
d252 1
a252 1
		msc->sc_sw_reg.acr = DART_ACR_CT_COUNTER_CLK_16;
d273 1
a273 1
	imr = sc->sc_sw_reg.imr;
d353 1
a353 1
	dart_write(sc, DART_IMR, sc->sc_base.sc_sw_reg.imr & ~DART_ISR_TXA);
d366 2
a367 2
	dart_write(sc, DART_IMR, sc->sc_base.sc_sw_reg.imr);
	dart_write(sc, DART_CRA, sc->sc_base.sc_sw_reg.cr[0]);
@


1.59
log
@Preliminary support for MVME180 and MVME181 boards. On-board serial ports
and VME controller are supported; tod chip isn't supported yet (coming soon).
MVME236 memory boards are not supported and won't likely be (unless I get my
hands on one).

MVME181-1 boots multiuser (slowly) with MVME328 SCSI and MVME376 Ethernet
despite only having 8MB of memory onboard.

MVME180 untested; might need tweaking to get MVME SCSI and Ethernet boards
supported.

Many thanks to Matti Nummi for lending me an MVME181 board.
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.58 2013/05/17 22:46:27 miod Exp $	*/
d4 15
a44 3
#include <sys/ioctl.h>
#include <sys/proc.h>
#include <sys/tty.h>
d55 3
a59 21
#include <mvme88k/dev/dartreg.h>

#ifdef	DDB
#include <ddb/db_var.h>
#endif

#define	NDARTPORTS	2	/* Number of ports */

struct dart_info {
	struct tty		*tty;
	u_char			dart_swflags;
};

/* saved registers */
struct dart_sv_reg {
	u_int8_t	sv_mr1[NDARTPORTS];
	u_int8_t	sv_mr2[NDARTPORTS];
	u_int8_t	sv_csr[NDARTPORTS];
	u_int8_t	sv_cr[NDARTPORTS];
	u_int8_t	sv_imr;
};
d62 1
a62 1
	struct device		sc_dev;
a65 3

	struct dart_sv_reg	sc_sv_reg;
	struct dart_info	sc_dart[NDARTPORTS];
d75 1
a75 5
struct cfdriver dart_cd = {
	NULL, "dart", DV_TTY
};

/* console is on the first port */
a77 1
/* prototypes */
a78 8
int	dart_speed(int);
struct tty *darttty(dev_t);
void	dartstart(struct tty *);
int	dartmctl(dev_t, int, int);
int	dartparam(struct tty *, struct termios *);
void	dartmodemtrans(struct dartsoftc *, unsigned int, unsigned int);
void	dartrint(struct dartsoftc *, int);
void	dartxint(struct dartsoftc *, int);
d80 2
d84 2
a85 2
 * DUART registers are mapped as the least-significant byte of 32-bit
 * addresses. The following macros hide this.
d88 4
a91 5
#define	DART_SIZE	0x40
#define	dart_read(sc, reg) \
	bus_space_read_1((sc)->sc_iot, (sc)->sc_ioh, 3 + ((reg) << 2))
#define	dart_write(sc, reg, val) \
	bus_space_write_1((sc)->sc_iot, (sc)->sc_ioh, 3 + ((reg) << 2), (val))
d93 16
a108 1
#define DART_PORT(dev) minor(dev)
d138 2
a139 1
	if (bus_space_map(ca->ca_iot, ca->ca_paddr, DART_SIZE, 0, &ioh) != 0)
d142 1
a142 1
	bus_space_unmap(ca->ca_iot, ca->ca_paddr, DART_SIZE);
d151 1
d159 2
a160 1
	if (bus_space_map(sc->sc_iot, ca->ca_paddr, DART_SIZE, 0, &ioh) != 0) {
a165 19
	/* save standard initialization */
	sc->sc_sv_reg.sv_mr1[A_PORT] = PARDIS | RXRTS | CL8;
	sc->sc_sv_reg.sv_mr2[A_PORT] = /* TXCTS | */ SB1;
	sc->sc_sv_reg.sv_csr[A_PORT] = BD9600;
	sc->sc_sv_reg.sv_cr[A_PORT]  = TXEN | RXEN;

	sc->sc_sv_reg.sv_mr1[B_PORT] = PARDIS | RXRTS | CL8;
	sc->sc_sv_reg.sv_mr2[B_PORT] = /* TXCTS | */ SB1;
	sc->sc_sv_reg.sv_csr[B_PORT] = BD9600;
	sc->sc_sv_reg.sv_cr[B_PORT]  = TXEN | RXEN;

	/* Start out with Tx and RX interrupts disabled */
	/* Enable input port change interrupt */
	sc->sc_sv_reg.sv_imr  = IIPCHG;
#ifdef MVME181
	if (brdtyp == BRD_180 || brdtyp == BRD_181)
		sc->sc_sv_reg.sv_imr |= ITIMER;
#endif

d168 1
a168 2
	 * this device will be elected as the console after
	 * autoconf.
d172 1
a172 2
	printf(": console");
	delay(10000);
d174 2
a175 43
	/* reset port a */
	dart_write(sc, DART_CRA, RXRESET | TXDIS | RXDIS);
	DELAY_CR;
	dart_write(sc, DART_CRA, TXRESET | TXDIS | RXDIS);
	DELAY_CR;
	dart_write(sc, DART_CRA, ERRRESET | TXDIS | RXDIS);
	DELAY_CR;
	dart_write(sc, DART_CRA, BRKINTRESET | TXDIS | RXDIS);
	DELAY_CR;
	dart_write(sc, DART_CRA, MRRESET | TXDIS | RXDIS);
	DELAY_CR;

	/* reset port b */
	dart_write(sc, DART_CRB, RXRESET | TXDIS | RXDIS);
	DELAY_CR;
	dart_write(sc, DART_CRB, TXRESET | TXDIS | RXDIS);
	DELAY_CR;
	dart_write(sc, DART_CRB, ERRRESET | TXDIS | RXDIS);
	DELAY_CR;
	dart_write(sc, DART_CRB, BRKINTRESET | TXDIS | RXDIS);
	DELAY_CR;
	dart_write(sc, DART_CRB, MRRESET | TXDIS | RXDIS);
	DELAY_CR;

	/* initialize ports */
	dart_write(sc, DART_MR1A, sc->sc_sv_reg.sv_mr1[A_PORT]);
	dart_write(sc, DART_MR2A, sc->sc_sv_reg.sv_mr2[A_PORT]);
	dart_write(sc, DART_CSRA, sc->sc_sv_reg.sv_csr[A_PORT]);
	dart_write(sc, DART_CRA, sc->sc_sv_reg.sv_cr[A_PORT]);

	dart_write(sc, DART_MR1B, sc->sc_sv_reg.sv_mr1[B_PORT]);
	dart_write(sc, DART_MR2B, sc->sc_sv_reg.sv_mr2[B_PORT]);
	dart_write(sc, DART_CSRB, sc->sc_sv_reg.sv_csr[B_PORT]);
	dart_write(sc, DART_CRB, sc->sc_sv_reg.sv_cr[B_PORT]);

	/* initialize common register of a DUART */
	dart_write(sc, DART_OPRS, OPDTRA | OPRTSA | OPDTRB | OPRTSB);

	dart_write(sc, DART_CTUR, SLCTIM >> 8);
	dart_write(sc, DART_CTLR, SLCTIM & 0xff);
	dart_write(sc, DART_ACR, BDSET2 | CCLK16 | IPDCDIB | IPDCDIA);
	dart_write(sc, DART_IMR, sc->sc_sv_reg.sv_imr);
	dart_write(sc, DART_OPCR, OPSET);
d177 10
a186 5
	/* enable interrupts */
	sc->sc_ih.ih_fn = dartintr;
	sc->sc_ih.ih_arg = sc;
	sc->sc_ih.ih_wantframe = 0;
	sc->sc_ih.ih_ipl = ca->ca_ipl;
d188 15
a202 1
	platform->intsrc_establish(INTSRC_DUART, &sc->sc_ih, self->dv_xname);
d204 19
a222 356
	printf("\n");
}

/* speed tables */
const struct dart_s {
	int kspeed;
	int dspeed;
} dart_speeds[] = {
	{ B0,		0	},	/* 0 baud, special HUP condition */
        { B50,		NOBAUD	},	/* 50 baud, not implemented */
	{ B75,		BD75	},	/* 75 baud */
	{ B110,		BD110	},	/* 110 baud */
	{ B134,		BD134	},	/* 134.5 baud */
	{ B150,		BD150	},	/* 150 baud */
	{ B200,		NOBAUD	},	/* 200 baud, not implemented */
	{ B300,		BD300	},	/* 300 baud */
	{ B600,		BD600	},	/* 600 baud */
	{ B1200,	BD1200	},	/* 1200 baud */
	{ B1800,	BD1800	},	/* 1800 baud */
	{ B2400,	BD2400	},	/* 2400 baud */
	{ B4800,	BD4800	},	/* 4800 baud */
	{ B9600,	BD9600	},	/* 9600 baud */
	{ B19200,	BD19200	},	/* 19200 baud */
	{ -1,		NOBAUD	},	/* anything more is uncivilized */
};

int
dart_speed(int speed)
{
	const struct dart_s *ds;

	for (ds = dart_speeds; ds->kspeed != -1; ds++)
		if (ds->kspeed == speed)
			return ds->dspeed;

	return NOBAUD;
}

struct tty *
darttty(dev_t dev)
{
	unsigned int port;
	struct dartsoftc *sc;

	port = DART_PORT(dev);
	if (dart_cd.cd_ndevs == 0 || port >= NDARTPORTS)
		return (NULL);

	sc = (struct dartsoftc *)dart_cd.cd_devs[0];
	return sc->sc_dart[port].tty;
}

void
dartstart(struct tty *tp)
{
	struct dartsoftc *sc;
	dev_t dev;
	int s;
	int port, tries;
	int c;
	bus_addr_t ptaddr;

	dev = tp->t_dev;
	port = DART_PORT(dev);
	if (dart_cd.cd_ndevs == 0 || port >= NDARTPORTS)
		return;

	if ((tp->t_state & TS_ISOPEN) == 0)
		return;

	sc = (struct dartsoftc *)dart_cd.cd_devs[0];
	ptaddr = port ? DART_B_BASE : DART_A_BASE;

	s = spltty();

	if (tp->t_state & (TS_TIMEOUT | TS_BUSY | TS_TTSTOP))
		goto bail;

	ttwakeupwr(tp);
	if (tp->t_outq.c_cc == 0)
		goto bail;

	tp->t_state |= TS_BUSY;
	while (tp->t_outq.c_cc != 0) {

		/* load transmitter until it is full */
		for (tries = 10000; tries != 0; tries --)
			if (dart_read(sc, ptaddr + DART_SRA) & TXRDY)
				break;

		if (tries == 0) {
			timeout_add(&tp->t_rstrt_to, 1);
			tp->t_state |= TS_TIMEOUT;
			break;
		} else {
			c = getc(&tp->t_outq);

			dart_write(sc, ptaddr + DART_TBA, c & 0xff);

			if (port == A_PORT)
				sc->sc_sv_reg.sv_imr |= ITXRDYA;
			else
				sc->sc_sv_reg.sv_imr |= ITXRDYB;
			dart_write(sc, DART_IMR, sc->sc_sv_reg.sv_imr);
		}
	}
	tp->t_state &= ~TS_BUSY;

bail:
	splx(s);
}

int
dartstop(struct tty *tp, int flag)
{
	int s;

	s = spltty();
	if (tp->t_state & TS_BUSY) {
		if ((tp->t_state & TS_TTSTOP) == 0)
			tp->t_state |= TS_FLUSH;
	}
	splx(s);

	return 0;
}

#define HANDLE_FLAG(_FLAG_, _PORT_, _AFLAG_, _BFLAG_) \
do { \
	if (flags & (_FLAG_)) { \
		newflags |= ((_PORT_) == A_PORT) ? (_AFLAG_) : (_BFLAG_); \
		flags &= ~(_FLAG_); \
	} \
} while (0)

/*
 * To be called at spltty - tty already locked.
 * Returns status of carrier.
 */

int
dartmctl(dev_t dev, int flags, int how)
{
	struct dartsoftc *sc;
	int port;
	int newflags = 0;
	struct dart_info *dart;
	int s;

	port = DART_PORT(dev);
	if (dart_cd.cd_ndevs == 0 || port >= NDARTPORTS)
		return (ENODEV);

	sc = (struct dartsoftc *)dart_cd.cd_devs[0];
	dart = &sc->sc_dart[port];

	s = spltty();

	HANDLE_FLAG(TIOCM_DTR, port, OPDTRA, OPDTRB);
	HANDLE_FLAG(TIOCM_RTS, port, OPRTSA, OPRTSB);

	switch (how) {
	case DMSET:
		dart_write(sc, DART_OPRS, newflags);
		dart_write(sc, DART_OPRR, ~newflags);
		break;
	case DMBIS:
		dart_write(sc, DART_OPRS, newflags);
		break;
	case DMBIC:
		dart_write(sc, DART_OPRR, newflags);
		break;
	case DMGET:
		flags = 0;	/* XXX not supported */
		break;
	}

	splx(s);
	return (flags);
}

int
dartioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	int error;
	int port;
	struct tty *tp;
	struct dart_info *dart;
	struct dartsoftc *sc;

	port = DART_PORT(dev);
	sc = (struct dartsoftc *)dart_cd.cd_devs[0];
	dart = &sc->sc_dart[port];

	tp = dart->tty;
	if (tp == NULL)
		return (ENXIO);

	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
	if (error >= 0)
		return(error);

	error = ttioctl(tp, cmd, data, flag, p);
	if (error >= 0)
		return(error);

	switch (cmd) {
	case TIOCSBRK:
	case TIOCCBRK:
		break;
	case TIOCSDTR:
		(void)dartmctl(dev, TIOCM_DTR | TIOCM_RTS, DMBIS);
		break;
	case TIOCCDTR:
		(void)dartmctl(dev, TIOCM_DTR | TIOCM_RTS, DMBIC);
		break;
	case TIOCMSET:
		(void)dartmctl(dev, *(int *) data, DMSET);
		break;
	case TIOCMBIS:
		(void)dartmctl(dev, *(int *) data, DMBIS);
		break;
	case TIOCMBIC:
		(void)dartmctl(dev, *(int *) data, DMBIC);
		break;
	case TIOCMGET:
		*(int *)data = dartmctl(dev, 0, DMGET);
		break;
	case TIOCGFLAGS:
		if (CONS_PORT == port)
			dart->dart_swflags |= TIOCFLAG_SOFTCAR;
		*(int *)data = dart->dart_swflags;
		break;
	case TIOCSFLAGS:
		error = suser(p, 0);
		if (error != 0)
			return (EPERM);

		dart->dart_swflags = *(int *)data;
		if (CONS_PORT == port)
			dart->dart_swflags |= TIOCFLAG_SOFTCAR;
		dart->dart_swflags &= /* only allow valid flags */
			(TIOCFLAG_SOFTCAR | TIOCFLAG_CLOCAL | TIOCFLAG_CRTSCTS);
		break;
	default:
		return (ENOTTY);
	}

	return (0);
}

int
dartparam(struct tty *tp, struct termios *t)
{
	int flags;
	int port;
	int speeds;
	unsigned char mr1, mr2;
	struct dart_info *dart;
	struct dartsoftc *sc;
	dev_t dev;
	bus_addr_t ptaddr;

	dev = tp->t_dev;
	sc = (struct dartsoftc *)dart_cd.cd_devs[0];
	port = DART_PORT(dev);
	dart = &sc->sc_dart[port];
	ptaddr = port ? DART_B_BASE : DART_A_BASE;

	tp->t_ispeed = t->c_ispeed;
	tp->t_ospeed = t->c_ospeed;
	tp->t_cflag = t->c_cflag;

	flags = tp->t_flags;

	/* Reset to make global changes*/
	/* disable Tx and Rx */

	if (CONS_PORT != port) {
		if (port == A_PORT)
			sc->sc_sv_reg.sv_imr &= ~(ITXRDYA | IRXRDYA);
		else
			sc->sc_sv_reg.sv_imr &= ~(ITXRDYB | IRXRDYB);
		dart_write(sc, DART_IMR, sc->sc_sv_reg.sv_imr);

		/* hang up on zero baud rate */
		if (tp->t_ispeed == 0) {
			dartmctl(dev, HUPCL, DMSET);
			return (0);
		} else {
			/* set baudrate */
			speeds = dart_speed(tp->t_ispeed);
			if (speeds == NOBAUD)
				speeds = sc->sc_sv_reg.sv_csr[port];
			dart_write(sc, ptaddr + DART_CSRA, speeds);
			sc->sc_sv_reg.sv_csr[port] = speeds;
		}

		/* get saved mode registers and clear set up parameters */
		mr1 = sc->sc_sv_reg.sv_mr1[port];
		mr1 &= ~(CLMASK | PARTYPEMASK | PARMODEMASK);

		mr2 = sc->sc_sv_reg.sv_mr2[port];
		mr2 &= ~SBMASK;

		/* set up character size */
		if (flags & CS8)
			mr1 |= CL8;
		else if (tp->t_ispeed == B134)
			mr1 |= CL6;
		else
			mr1 |= CL7;

		/* set up stop bits */
		if (tp->t_ospeed == B110)
			mr2 |= SB2;
		else
			mr2 |= SB1;

		/* set up parity */
		if (((flags & PARENB) != PARENB) &&
		    (flags & PARENB)) {
			mr1 |= PAREN;
			if (flags & PARODD)
				mr1 |= ODDPAR;
			else
				mr1 |= EVENPAR;
		} else
			mr1 |= PARDIS;

		if (sc->sc_sv_reg.sv_mr1[port] != mr1 ||
		    sc->sc_sv_reg.sv_mr2[port] != mr2) {
			/* write mode registers to duart */
			dart_write(sc, ptaddr + DART_CRA, MRRESET);
			dart_write(sc, ptaddr + DART_MR1A, mr1);
			dart_write(sc, ptaddr + DART_MR2A, mr2);

			/* save changed mode registers */
			sc->sc_sv_reg.sv_mr1[port] = mr1;
			sc->sc_sv_reg.sv_mr2[port] = mr2;
		}
	}

	/* enable transmitter? */
	if (tp->t_state & TS_BUSY) {
		if (port == A_PORT)
			sc->sc_sv_reg.sv_imr |= ITXRDYA;
		else
			sc->sc_sv_reg.sv_imr |= ITXRDYB;
		dart_write(sc, DART_IMR, sc->sc_sv_reg.sv_imr);
	}

	/* re-enable the receiver */
	DELAY_CR;
	if (port == A_PORT)
		sc->sc_sv_reg.sv_imr |= IRXRDYA;
d224 7
a230 50
		sc->sc_sv_reg.sv_imr |= IRXRDYB;
	dart_write(sc, DART_IMR, sc->sc_sv_reg.sv_imr);

	return (0);
}

void
dartmodemtrans(struct dartsoftc *sc, unsigned int ip, unsigned int ipcr)
{
	unsigned int dcdstate;
	struct tty *tp;
	int port;
	struct dart_info *dart;

	/* input is inverted at port!!! */
	if (ipcr & IPCRDCDA) {
		port = A_PORT;
		dcdstate = !(ip & IPDCDA);
	} else if (ipcr & IPCRDCDB) {
		port = B_PORT;
		dcdstate = !(ip & IPDCDB);
	} else {
		printf("dartmodemtrans: unknown transition ip=0x%x ipcr=0x%x\n",
		       ip, ipcr);
		return;
	}

	dart = &sc->sc_dart[port];
	tp = dart->tty;
	if (tp != NULL)
		ttymodem(tp, dcdstate);
}

int
dartopen(dev_t dev, int flag, int mode, struct proc *p)
{
	int s, port;
	struct dart_info *dart;
	struct dartsoftc *sc;
	struct tty *tp;

	port = DART_PORT(dev);
	if (dart_cd.cd_ndevs == 0 || port >= NDARTPORTS)
		return (ENODEV);
	sc = (struct dartsoftc *)dart_cd.cd_devs[0]; /* the only one */
	dart = &sc->sc_dart[port];

	s = spltty();
	if (dart->tty != NULL)
		tp = dart->tty;
d232 5
a236 26
		tp = dart->tty = ttymalloc(0);

	tp->t_oproc = dartstart;
	tp->t_param = dartparam;
	tp->t_dev = dev;

	if ((tp->t_state & TS_ISOPEN) == 0) {
		ttychars(tp);
		tp->t_iflag = TTYDEF_IFLAG;
		tp->t_oflag = TTYDEF_OFLAG;
		tp->t_lflag = TTYDEF_LFLAG;
		tp->t_ispeed = tp->t_ospeed = B9600;
		dartparam(tp, &tp->t_termios);
		if (port == CONS_PORT) {
			/* console is 8N1 */
			tp->t_cflag = (CREAD | CS8 | HUPCL);
		} else {
			tp->t_cflag = TTYDEF_CFLAG;
		}
		ttsetwater(tp);
		(void)dartmctl(dev, TIOCM_DTR | TIOCM_RTS, DMSET);
		tp->t_state |= TS_CARR_ON;
	} else if (tp->t_state & TS_XCLUDE && suser(p, 0) != 0) {
		splx(s);
		return (EBUSY);
	}
d239 3
a241 2
	 * Reset the tty pointer, as there could have been a dialout
	 * use of the tty with a dialin open waiting.
d243 3
a245 4
	tp->t_dev = dev;
	splx(s);
	return ((*linesw[tp->t_line].l_open)(dev, tp, p));
}
d247 5
a251 7
int
dartclose(dev_t dev, int flag, int mode, struct proc *p)
{
	struct tty *tp;
	struct dart_info *dart;
	struct dartsoftc *sc;
	int port;
d253 1
a253 3
	sc = (struct dartsoftc *)dart_cd.cd_devs[0];
	port = DART_PORT(dev);
	dart = &sc->sc_dart[port];
d255 5
a259 3
	tp = dart->tty;
	(*linesw[tp->t_line].l_close)(tp, flag, p);
	ttyclose(tp);
d261 1
a261 1
	return (0);
d265 1
a265 1
dartread(dev_t dev, struct uio *uio, int flag)
d267 3
a269 4
	int port;
	struct tty *tp;
	struct dart_info *dart;
	struct dartsoftc *sc;
d271 2
a272 3
	sc = (struct dartsoftc *)dart_cd.cd_devs[0];
	port = DART_PORT(dev);
	dart = &sc->sc_dart[port];
d274 3
a276 145
	tp = dart->tty;
	if (tp == NULL)
		return (ENXIO);
	return ((*linesw[tp->t_line].l_read)(tp, uio, flag));
}

int
dartwrite(dev_t dev, struct uio *uio, int flag)
{
	int port;
	struct tty *tp;
	struct dart_info *dart;
	struct dartsoftc *sc;

	sc = (struct dartsoftc *)dart_cd.cd_devs[0];
	port = DART_PORT(dev);
	dart = &sc->sc_dart[port];

	tp = dart->tty;
	if (tp == NULL)
		return (ENXIO);
	return ((*linesw[tp->t_line].l_write)(tp, uio, flag));
}

void
dartrint(struct dartsoftc *sc, int port)
{
	struct tty *tp;
	unsigned char data, sr;
	struct dart_info *dart;
	bus_addr_t ptaddr;

	dart = &sc->sc_dart[port];
	ptaddr = port ? DART_B_BASE : DART_A_BASE;
	tp = dart->tty;

	/* read status reg */
	while ((sr = dart_read(sc, ptaddr + DART_SRA)) & RXRDY) {
		/* read data and reset receiver */
		data = dart_read(sc, ptaddr + DART_RBA);

		if ((tp->t_state & (TS_ISOPEN|TS_WOPEN)) == 0 &&
		    CONS_PORT != port) {
			return;
		}

		if (sr & RBRK) {
			/* clear break state */
			dart_write(sc, ptaddr + DART_CRA, BRKINTRESET);
			DELAY_CR;
			dart_write(sc, ptaddr + DART_CRA, ERRRESET);

#if defined(DDB)
			if (db_console != 0 && port == CONS_PORT)
				Debugger();
#endif
		} else {
			if (sr & (FRERR|PERR|ROVRN)) { /* errors */
				if (sr & ROVRN)
					printf("%s: receiver overrun port %c\n",
					    sc->sc_dev.dv_xname, 'A' + port);
				if (sr & FRERR)
					printf("%s: framing error port %c\n",
					    sc->sc_dev.dv_xname, 'A' + port);
				if (sr & PERR)
					printf("%s: parity error port %c\n",
					    sc->sc_dev.dv_xname, 'A' + port);
				/* clear error state */
				dart_write(sc, ptaddr + DART_CRA, ERRRESET);
			} else {
				/* no errors */
				(*linesw[tp->t_line].l_rint)(data,tp);
#if 0
				{
					if (tp->t_ispeed == B134) /* CS6 */
						data &= 077;
					else if (tp->t_flags & CS8)
						;
					else
						data &= 0177; /* CS7 */
					ttyinput(data, tp);
				}
#endif
			}
		}
	}
}

void
dartxint(struct dartsoftc *sc, int port)
{
	struct tty *tp;
	struct dart_info *dart;

	dart = &sc->sc_dart[port];
	tp = dart->tty;

	if ((tp->t_state & (TS_ISOPEN|TS_WOPEN))==0)
		goto out;

	if (tp->t_state & TS_FLUSH)
		tp->t_state &= ~TS_FLUSH;

	if (tp->t_state & TS_BUSY) {
		tp->t_state &= ~TS_BUSY;
		dartstart(tp);
		if (tp->t_state & TS_BUSY) {
			return;
		}
	}
out:

	/* disable transmitter */
	if (port == 0)
		sc->sc_sv_reg.sv_imr &= ~ITXRDYA;
	else
		sc->sc_sv_reg.sv_imr &= ~ITXRDYB;

	dart_write(sc, DART_IMR, sc->sc_sv_reg.sv_imr);
}

int
dartintr(void *arg)
{
	struct dartsoftc *sc = arg;
	unsigned char isr, imr;
	int port;
	int rc = -1;

	/* read interrupt status register and mask with imr */
	isr = dart_read(sc, DART_ISR);
	imr = sc->sc_sv_reg.sv_imr;

	if ((isr & imr) == 0) {
		/*
		 * We got an interrupt on a disabled condition (such as TX
		 * ready change on a disabled port). This should not happen,
		 * but we have to claim the interrupt anyway.
		 */
#ifdef DEBUG
		printf("dartintr: spurious interrupt, isr %x imr %x\n",
		    isr, imr);
#endif
		return (-1);
	}
d281 4
a284 7
	if (imr & ITIMER) {
		if (isr & ITIMER)
			rc = -1;
		isr &= ~ITIMER;
		if (isr == 0)
			goto done;	/* will be handled by the second
					   interrupt handler */
d287 2
a288 20
	isr &= imr;

	if (isr & IIPCHG) {
		unsigned int ip, ipcr;

		ip = dart_read(sc, DART_IP);
		ipcr = dart_read(sc, DART_IPCR);
		dartmodemtrans(sc, ip, ipcr);
		goto done;
	}

	if (isr & (IRXRDYA | ITXRDYA))
		port = 0;
	else if (isr & (IRXRDYB | ITXRDYB))
		port = 1;
	else {
		printf("dartintr: spurious interrupt, isr 0x%08x\n", isr);
		rc = -1;
		goto done;
	}
a289 12
	if (isr & (IRXRDYA | IRXRDYB)) {
		dartrint(sc, port);
	}
	if (isr & (ITXRDYA | ITXRDYB)) {
		dartxint(sc, port);
	}
	if ((port == A_PORT && (isr & IBRKA)) ||
	    (port == B_PORT && (isr & IBRKB))) {
		dart_write(sc, port ? DART_CRB : DART_CRA, BRKINTRESET);
	}

done:
d299 2
a309 2
		if (badaddr(M181_DUART, 4) != 0)
			return;
a313 2
		if (badaddr(DART_BASE, 4) != 0)
			return;
d320 1
a320 1
	/* do not attach as console if dart has been disabled */
a345 2
	int port;
	bus_addr_t ptaddr;
a347 2
	port = DART_PORT(dev);
	ptaddr = port ? DART_B_BASE : DART_A_BASE;
d352 1
a352 1
	dart_write(sc, DART_IMR, sc->sc_sv_reg.sv_imr & ~ITXRDYA);
d354 1
a354 2
	DELAY_CR;
	dart_write(sc, ptaddr + DART_CRA, TXEN);
d356 1
a356 1
	while ((dart_read(sc, ptaddr + DART_SRA) & TXRDY) == 0)
d358 1
a358 1
	dart_write(sc, ptaddr + DART_TBA, c);
d361 1
a361 1
	while ((dart_read(sc, ptaddr + DART_SRA) & TXEMT) == 0)
d365 2
a366 3
	dart_write(sc, DART_IMR, sc->sc_sv_reg.sv_imr);
	DELAY_CR;
	dart_write(sc, ptaddr + DART_CRA, sc->sc_sv_reg.sv_cr[0]);
d375 1
a375 1
	unsigned char sr;	/* status reg of port a/b */
a377 2
	int port;
	bus_addr_t ptaddr;
a379 2
	port = DART_PORT(dev);
	ptaddr = port ? DART_B_BASE : DART_A_BASE;
d384 1
a384 1
	dart_write(sc, ptaddr + DART_CRA, RXEN);
d388 1
a388 1
		sr = dart_read(sc, ptaddr + DART_SRA);
d390 2
a391 2
		/* receiver interrupt handler*/
		if (sr & RXRDY) {
d393 1
a393 10
			c = dart_read(sc, ptaddr + DART_RBA);

			/* check break condition */
			if (sr & RBRK) {
				/* clear break state */
				dart_write(sc, ptaddr + DART_CRA, BRKINTRESET);
				DELAY_CR;
				dart_write(sc, ptaddr + DART_CRA, ERRRESET);
				break;
			}
d395 8
a402 6
			if (sr & (FRERR | PERR | ROVRN)) {
				/* clear error state */
				dart_write(sc, ptaddr + DART_CRA, ERRRESET);
				DELAY_CR;
				dart_write(sc, ptaddr + DART_CRA, BRKINTRESET);
			} else {
a403 1
			}
d408 1
a408 1
	return ((int)c);
@


1.58
log
@Replace the bunch of md_* function pointers with a `struct board' containing
function pointers for all the board-specific code.

Add a bunch of `struct board' methods to cover most, if not all, of the
`per-board' logic. This allows most of the md drivers to be cleaned up and
no longer need to embed board-specific knowledge.
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.57 2010/07/02 17:27:01 nicm Exp $	*/
d43 1
a122 3
	if (brdtyp != BRD_188)
		return (0);

d126 17
a142 2
	if (ca->ca_paddr != DART_BASE)
		return (0);
d145 1
a145 1
		return (0);
d149 1
a149 1
	return (rc == 0);
d183 4
d192 2
a193 2
	 * We do not even test since we know we are an MVME188 and
	 * console is always on the first port.
d196 1
d852 1
d864 1
a864 1
#if defined(DIAGNOSTIC) && !defined(MULTIPROCESSOR)
d868 13
a880 1
		return (1);
d882 1
d891 1
a891 1
		return (1);
d900 2
a901 1
		return (1);	/* claim it anyway */
d915 2
a916 1
	return (1);
d930 15
a944 1
	if (brdtyp != BRD_188 || badaddr(DART_BASE, 4) != 0)
d946 1
@


1.57
log
@Move common code for waking up writers on a tty into a function.

ok deraadt matthew millert
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.56 2010/06/28 14:13:29 deraadt Exp $	*/
d37 1
a43 1
#include <mvme88k/dev/sysconvar.h>
d230 2
a231 1
	sysconintr_establish(INTSRC_DUART, &sc->sc_ih, self->dv_xname);
@


1.56
log
@Allow tty drivers to request larger buffers at attach time using a
max-baud-rate hint.  Adjust TTYHOG (the nearly full logic) to this new
situation.  The larger buffers are required by the very high speed
KDDI devices in Japan (CF com, or USB ucom) so those are the only two
drivers which currently ask for a larger buffer size.
ok yasuoka miod
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.55 2010/04/12 12:57:52 tedu Exp $	*/
d309 3
a311 9
	if (tp->t_outq.c_cc <= tp->t_lowat) {
		if (tp->t_state & TS_ASLEEP) {
			tp->t_state &= ~TS_ASLEEP;
			wakeup((caddr_t)&tp->t_outq);
		}
		selwakeup(&tp->t_wsel);
		if (tp->t_outq.c_cc == 0)
			goto bail;
	}
@


1.55
log
@Some of the line disciplines want to check for suser.  Better to pass them
a process instead of using curproc.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.54 2009/11/09 17:53:39 nicm Exp $	*/
d645 1
a645 1
		tp = dart->tty = ttymalloc();
@


1.54
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.53 2009/10/31 12:00:07 fgsch Exp $	*/
d678 1
a678 1
	return ((*linesw[tp->t_line].l_open)(dev, tp));
d694 1
a694 1
	(*linesw[tp->t_line].l_close)(tp, flag);
@


1.53
log
@Use suser when possible. Suggested by miod@@.
miod@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.52 2009/10/31 06:40:16 deraadt Exp $	*/
a314 1
		KNOTE(&tp->t_wsel.si_note, 0);
@


1.52
log
@Add missing KNOTE() calls after selwakeup(), until we decide if the KNOTE()
calls can go directly into selwakeup() safely
long discussion with nicm, murmers of consent from tedu and miod, noone
else seems to care of kqueue is busted as long as it makes their sockets
move data fast... pretty sad.
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.51 2008/01/23 16:37:57 jsing Exp $	*/
d668 1
a668 1
	} else if (tp->t_state & TS_XCLUDE && p->p_ucred->cr_uid != 0) {
@


1.51
log
@Cleanup cn_pri. Change constants to more meaningful names, rather than
the hp300 related ones currently in use. CN_NORMAL becomes CN_LOWPRI,
CN_INTERNAL becomes CN_MIDPRI and CN_REMOTE becomes CN_HIGHPRI.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.49 2007/05/19 20:35:20 miod Exp $	*/
d315 1
@


1.50
log
@Make the mvme188 interrupt handling closer to the aviion interrupt handling:
non-VME syscon interrupt sources will now use their own intrhand array,
and interrupt sources will be enabled in the arbiter as interrupt handlers
are registered. This allows VME devices to use the whole 256 interrupts range.
@
text
@d916 1
a916 1
	cp->cn_pri = CN_NORMAL;
@


1.49
log
@Silence a diagnostic message in multiprocessor kernels, it makes things worse.
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.48 2006/05/08 14:36:10 miod Exp $	*/
d43 1
a43 1
#include <mvme88k/dev/sysconreg.h>
a222 1
	dart_write(sc, DART_IVR, SYSCON_VECT + SYSCV_SCC);
d230 1
a230 1
	sysconintr_establish(SYSCV_SCC, &sc->sc_ih, self->dv_xname);
@


1.48
log
@Replace gazillions of badvaddr() or badwordaddr() calls with badaddr() calls.
With a few prototype declarations shuffling, this finally allows
<machine/locore.h> to die.
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.47 2006/04/17 13:30:02 miod Exp $	*/
d772 2
a773 1
					printf("dart0: receiver overrun port %c\n", 'A' + port);
d775 2
a776 1
					printf("dart0: framing error port %c\n", 'A' + port);
d778 2
a779 1
					printf("dart0: parity error port %c\n", 'A' + port);
d851 1
a851 1
#ifdef DIAGNOSTIC
@


1.47
log
@Oops, removed a safety check in dartopen() in previous commit by mistake.
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.46 2006/04/15 22:32:42 miod Exp $	*/
a38 1
#include <machine/locore.h>
d133 1
a133 1
	rc = badvaddr((vaddr_t)bus_space_vaddr(ca->ca_iot, ioh), 4);
@


1.46
log
@Access to the DART registers using bus_space instead of our own memory
mapped structures; this paves the way for hardware with more than one
instance of the DART chip.
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.45 2006/01/01 11:59:39 miod Exp $	*/
d392 1
a392 1
	sc = (struct dartsoftc *) dart_cd.cd_devs[0];
a428 1
	sc = (struct dartsoftc *) dart_cd.cd_devs[0];
d430 1
a636 1
	sc = (struct dartsoftc *) dart_cd.cd_devs[0]; /* the only one */
d638 3
d691 1
a691 1
	sc = (struct dartsoftc *) dart_cd.cd_devs[0];
d710 1
a710 1
	sc = (struct dartsoftc *) dart_cd.cd_devs[0];
@


1.45
log
@Let cons_init() and cons_init_bell() initialize the whole consdev structure,
thus removing the need for drivers to initialize cn_pri to CN_DEAD when
hardware probe fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.44 2005/10/13 19:48:34 miod Exp $	*/
a32 1
#include <sys/uio.h>
a33 1
#include <sys/time.h>
a34 2
#include <sys/simplelock.h>
#include <sys/syslog.h>
a35 1
#include <machine/asm_macro.h>   /* enable/disable interrupts */
a39 1
#include <machine/psl.h>
a46 2
#define spldart()	spltty()

a50 7
#ifdef DEBUG
int dart_debug = 1;
#define dprintf(stuff) if (dart_debug) printf stuff
#else
#define dprintf(stuff)
#endif

d56 9
a64 1
	struct simplelock	t_lock;
d69 5
a73 2
	union  dartreg		*dart_reg;
        union  dart_pt_io	*port_reg[NDARTPORTS];
a74 1
	struct intrhand		sc_ih;
d93 9
a101 13
int dart_speed(int);
struct tty* darttty(dev_t);
void dartstart(struct tty *);
int dartmctl(dev_t, int, int);
int dartparam(struct tty *, struct termios *);
void dartmodemtrans(struct dartsoftc *, unsigned int, unsigned int);
void dartrint(struct dartsoftc *, int);
void dartxint(struct dartsoftc *, int);

int dartintr(void *);
#if 0
void dartbreak(dev_t dev, int state);
#endif
d104 2
a105 6
 * Lock strategy in that driver:
 * Use the tp->t_lock used by chario stuff as a lock
 * when modifying the chip's registers.
 *
 * Should be changed if driver crashes when powering
 * two lines.
d108 6
a115 25
struct dart_sv_reg dart_sv_reg;

/* speed tables */
const struct dart_s {
	int kspeed;
	int dspeed;
} dart_speeds[] = {
	{B0,		0	},	/* 0 baud, special HUP condition */
        {B50,		NOBAUD	},	/* 50 baud, not implemented */
	{B75,		BD75	},	/* 75 baud */
	{B110,		BD110	},	/* 110 baud */
	{B134,		BD134	},	/* 134.5 baud */
	{B150,		BD150	},	/* 150 baud */
	{B200,		NOBAUD	},	/* 200 baud, not implemented */
	{B300,		BD300	},	/* 300 baud */
	{B600,		BD600	},	/* 600 baud */
	{B1200,		BD1200	},	/* 1200 baud */
	{B1800,		BD1800	},	/* 1800 baud */
	{B2400,		BD2400	},	/* 2400 baud */
	{B4800,		BD4800	},	/* 4800 baud */
	{B9600,		BD9600	},	/* 9600 baud */
	{B19200,	BD19200	},	/* 19200 baud */
	{-1,		NOBAUD	},	/* anything more is uncivilized */
};

d117 1
a117 2
dart_speed(speed)
	int speed;
d119 3
a121 1
	const struct dart_s *ds;
a122 31
	for (ds = dart_speeds; ds->kspeed != -1; ds++)
		if (ds->kspeed == speed)
			return ds->dspeed;

	return NOBAUD;
}

struct tty*
darttty(dev)
	dev_t dev;
{
	unsigned int port;
	struct dartsoftc *sc;

	port = DART_PORT(dev);
	if (dart_cd.cd_ndevs == 0 || port >= NDARTPORTS)
		return (NULL);

	sc = (struct dartsoftc *) dart_cd.cd_devs[0];
	return sc->sc_dart[port].tty;
}

int
dartmatch(parent, vcf, args)
	struct device *parent;
	void *vcf, *args;
{
	struct confargs *ca = args;
	union dartreg *addr;

	/* Don't match if wrong cpu */
d126 5
a130 1
	addr = (union dartreg *)ca->ca_paddr;
d132 1
a132 4
	if (badvaddr((vaddr_t)addr, 2)) {
#ifdef DEBUG
		printf("==> dart: failed address check.\n");
#endif
d134 2
a135 1
	}
d137 1
a137 1
	return (1);
d141 1
a141 4
dartattach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
d145 1
a145 3
	union dartreg *addr; /* pointer to DUART regs */
	union dart_pt_io *ptaddr; /* pointer to port regs */
	int port;	/* port index */
d150 6
a155 10
	/* set up dual port memory and registers and init*/
	sc->dart_reg = (union dartreg *)ca->ca_paddr;
        ptaddr = (union  dart_pt_io *)ca->ca_paddr;
	sc->port_reg[A_PORT] = ptaddr;
	ptaddr++;
	sc->port_reg[B_PORT] = ptaddr;
	sc->sc_dart[A_PORT].tty = NULL;
	sc->sc_dart[B_PORT].tty = NULL;

	addr = sc->dart_reg;
d158 9
a166 11
	dart_sv_reg.sv_mr1[A_PORT] = PARDIS | RXRTS | CL8;
	dart_sv_reg.sv_mr2[A_PORT] = /* TXCTS | */ SB1;
	dart_sv_reg.sv_csr[A_PORT] = BD9600;
	dart_sv_reg.sv_cr[A_PORT]  = TXEN | RXEN;

	dart_sv_reg.sv_mr1[B_PORT] = PARDIS | RXRTS | CL8;
	dart_sv_reg.sv_mr2[B_PORT] = /* TXCTS | */ SB1;
	dart_sv_reg.sv_csr[B_PORT] = BD9600;
	dart_sv_reg.sv_cr[B_PORT]  = TXEN | RXEN;

	dart_sv_reg.sv_acr  = BDSET2 | CCLK16 | IPDCDIB | IPDCDIA;
d170 1
a170 1
	dart_sv_reg.sv_imr  = IIPCHG;
a180 2
	dprintf(("\ndartattach: resetting port A\n"));

d182 1
a182 1
	addr->write.wr_cra  = RXRESET     | TXDIS | RXDIS;
d184 1
a184 1
	addr->write.wr_cra  = TXRESET     | TXDIS | RXDIS;
d186 1
a186 1
	addr->write.wr_cra  = ERRRESET    | TXDIS | RXDIS;
d188 3
a190 1
	addr->write.wr_cra  = BRKINTRESET | TXDIS | RXDIS;
a191 3
	addr->write.wr_cra  = MRRESET     | TXDIS | RXDIS;

	dprintf(("dartattach: resetting port B\n"));
d194 1
a194 1
	addr->write.wr_crb  = RXRESET     | TXDIS | RXDIS;
d196 1
a196 1
	addr->write.wr_crb  = TXRESET     | TXDIS | RXDIS;
d198 1
a198 1
	addr->write.wr_crb  = ERRRESET    | TXDIS | RXDIS;
d200 1
a200 1
	addr->write.wr_crb  = BRKINTRESET | TXDIS | RXDIS;
d202 1
a202 1
	addr->write.wr_crb  = MRRESET     | TXDIS | RXDIS;
d206 9
a214 11
	for (port = 0, ptaddr = (union dart_pt_io *)addr;
	    port < MAXPORTS;
	    port++, ptaddr++) {
		dprintf(("dartattach: init port %c\n", 'A' + port));
		ptaddr->write.wr_mr  = dart_sv_reg.sv_mr1[port];
		ptaddr->write.wr_mr  = dart_sv_reg.sv_mr2[port];
		ptaddr->write.wr_csr = dart_sv_reg.sv_csr[port];
		ptaddr->write.wr_cr  = dart_sv_reg.sv_cr [port];
	}

	dprintf(("dartattach: init common regs\n"));
d217 1
a217 1
	addr->write.wr_oprset = OPDTRA | OPRTSA | OPDTRB | OPRTSB;
d219 6
a224 6
	addr->write.wr_ctur  = SLCTIM>>8;
	addr->write.wr_ctlr  = SLCTIM & 0xFF;
	addr->write.wr_acr  = dart_sv_reg.sv_acr;
	addr->write.wr_imr  = dart_sv_reg.sv_imr;
	addr->write.wr_opcr = OPSET;
	addr->write.wr_ivr = SYSCON_VECT + SYSCV_SCC;	/* hard coded vector */
d236 49
a284 3
/*
 * To be called at spltty - tty already locked.
 */
d286 1
a286 2
dartstart(tp)
	struct tty *tp;
d288 1
a289 1
	struct dartsoftc *sc;
a290 2
	union dart_pt_io *ptaddr;
	union dartreg *addr;
d293 1
a299 4
	sc = (struct dartsoftc *) dart_cd.cd_devs[0];
	addr = sc->dart_reg;
	ptaddr = sc->port_reg[port];

d303 3
a320 6
	dprintf(("dartstart: dev(%d, %d)\n", major(dev), minor(dev)));

	if (port != CONS_PORT)
		dprintf(("dartstart: ptaddr = 0x%08x from uart at 0x%08x\n",
			 ptaddr, addr));

d326 1
a326 1
			if (ptaddr->read.rd_sr & TXRDY)
d336 1
a336 4
			if (port != CONS_PORT)
				dprintf(("dartstart: writing char \"%c\" (0x%02x) to port %d\n",
					 c & 0xff, c & 0xff, port));
			ptaddr->write.wr_tb = c & 0xff;
a337 2
			if (port != CONS_PORT)
				dprintf(("dartstart: enabling Tx int\n"));
d339 1
a339 1
				dart_sv_reg.sv_imr |= ITXRDYA;
d341 2
a342 2
				dart_sv_reg.sv_imr |= ITXRDYB;
			addr->write.wr_imr = dart_sv_reg.sv_imr;
a350 3
/*
 * To be called at spltty - tty already locked.
 */
d352 1
a352 3
dartstop(tp, flag)
	struct tty *tp;
	int flag;
d355 1
a356 1

d362 1
d367 6
a372 12
   if (flags & (_FLAG_)) \
      { newflags |= ((_PORT_) == A_PORT) ? (_AFLAG_) : (_BFLAG_); \
        flags &= ~(_FLAG_); }

#define HOW2STR(_OP_) \
	((_OP_) == DMGET) ? "GET" : \
	 (((_OP_) == DMSET) ? "FORCE" : \
	  ((((_OP_) == DMBIS) ? "SET" : \
	   (((((_OP_) == DMBIC) ? "CLR" : "???"))))))

#define FLAGSTRING \
     "\20\1LE\2DTR\3RTS\4ST\5SR\6CTS\7CAR\10RNG\11DSR\12BRK"
d380 1
a380 4
dartmctl (dev, flags, how)
	dev_t dev;
	int flags;
	int how;
d382 1
a382 1
	union dartreg *addr;
a383 1
	unsigned int dcdstate;
a385 1
	struct dartsoftc *sc;
a393 1
	addr = sc->dart_reg;
a394 11
	/* special case: set or clear break */
#if 0
	if (flags & TIOCSBRK) {
		dartbreak(port, 1);
		flags &= ~TIOCSBRK;
	}
	if (flags & TIOCCBRK) {
		dartbreak(port, 0);
		flags &= ~TIOCCBRK;
	}
#endif
a399 11
#if 0
	if (flags) {
		printf("dartmctl: currently only BRK, DTR and RTS supported\n");
		printf("dartmctl: op=%s flags left = 0x%b\n",
		       HOW2STR(how), flags, FLAGSTRING);
		panic("dartmctl");
	}
#endif
	dprintf(("dartmctl: action=%s flags=0x%x\n",
		 HOW2STR(how), newflags));

d402 2
a403 2
		addr->write.wr_oprset = newflags;
		addr->write.wr_oprreset = ~newflags;
d406 1
a406 1
		addr->write.wr_oprset = newflags;
d409 1
a409 1
		addr->write.wr_oprreset = newflags;
d412 1
a412 1
		panic("dartmctl: DMGET not supported (yet)");
a415 5
	/* read DCD input */
	/* input is inverted at port */
	dcdstate = !(addr->read.rd_ip & ((port == A_PORT) ? IPDCDA : IPDCDB));

	dprintf(("dartmctl: DCD is %s\n", dcdstate ? "up" : "down"));
d417 1
a417 1
	return dcdstate;
a419 35
#if 0
/*
 * To be called at spltty - tty already locked.
 */
void
dartbreak(dev, state)
	dev_t dev;
	int state;
{
	union dartreg *addr;
	union dart_pt_io *ptaddr;
	int port;
	struct dart_info *dart;
	struct dartsoftc *sc;

	dprintf(("dartbreak: break %s\n", (state == 1) ? "on" : "off"));

	port = DART_PORT(dev);
	sc = (struct dartsoftc *) dart_cd.cd_devs[0];
	dart = &sc->sc_dart[port];
	addr = sc->dart_reg;

	ptaddr = sc->port_reg[port];

	if (state == 1) {
		/* the duart must be enabled with a dummy byte,
		to prevent the transmitter empty interrupt */
		ptaddr->write.wr_cr = BRKSTART|TXEN;
		ptaddr->write.wr_tb = 0;
	} else {
		ptaddr->write.wr_cr = BRKSTOP;	 /* stop a break*/
	}
}
#endif

d421 1
a421 6
dartioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d429 1
d431 1
a431 2
	if (dart_cd.cd_ndevs == 0 || port >= NDARTPORTS)
		return (ENODEV);
a432 2
	sc = (struct dartsoftc *) dart_cd.cd_devs[0];
	dart = &sc->sc_dart[port];
d434 2
a435 2
	if (!tp)
		return ENXIO;
a446 3
		/* */
		break;

a447 1
		/* */
a448 1

d450 1
a450 1
		(void) dartmctl(dev, TIOCM_DTR | TIOCM_RTS, DMBIS);
a451 1

d453 1
a453 1
		(void) dartmctl(dev, TIOCM_DTR | TIOCM_RTS, DMBIC);
a454 1

d456 1
a456 1
		(void) dartmctl(dev, *(int *) data, DMSET);
a457 1

d459 1
a459 1
		(void) dartmctl(dev, *(int *) data, DMBIS);
a460 1

d462 1
a462 1
		(void) dartmctl(dev, *(int *) data, DMBIC);
a463 1

d465 1
a465 1
/*		*(int *)data = dartmctl(dev, 0, DMGET);*/
d475 1
a475 1
			return(EPERM);
d484 1
a484 1
		return(ENOTTY);
d487 1
a487 1
	return 0;
a489 3
/*
 * To be called at spltty - tty already locked.
 */
d491 1
a491 3
dartparam(tp, t)
	struct tty *tp;
	struct termios *t;
a492 2
	union dartreg *addr;
	union dart_pt_io *ptaddr;
d500 1
d503 1
a503 1
	dprintf(("dartparam: setting param for dev(%d, %d)\n", major(dev), minor(dev)));
a504 4
	if (dart_cd.cd_ndevs == 0 || port >= NDARTPORTS)
		return (ENODEV);

	sc = (struct dartsoftc *) dart_cd.cd_devs[0];
d506 1
a506 2
	addr = sc->dart_reg;
	ptaddr = sc->port_reg[port];
a515 1
	dprintf(("dartparam: disabling Tx and Rx int\n"));
d517 1
a517 3
	if (CONS_PORT == port) {
		dprintf(("dartparam: skipping console init\n"));
	} else {
d519 1
a519 1
			dart_sv_reg.sv_imr = dart_sv_reg.sv_imr & ~(ITXRDYA | IRXRDYA);
d521 2
a522 2
			dart_sv_reg.sv_imr = dart_sv_reg.sv_imr & ~(ITXRDYB | IRXRDYB);
		addr->write.wr_imr = dart_sv_reg.sv_imr;
a525 1
			dprintf(("dartparam: ispeed == 0 -> HUP\n"));
d527 1
a527 1
			return 0;
a530 1
			dprintf(("dartparam: speed 0x%x, baudrate %d\n", speeds, tp->t_ispeed));
d532 3
a534 4
				speeds = dart_sv_reg.sv_csr[port];
			ptaddr->write.wr_csr = speeds;
			dart_sv_reg.sv_csr[port] = speeds;
			dprintf(("dartparam: baudrate set param = %d\n", speeds));
d538 1
a538 1
		mr1 = dart_sv_reg.sv_mr1[port];
d541 1
a541 1
		mr2 = dart_sv_reg.sv_mr2[port];
d545 1
a545 1
		if (flags & CS8) {
d547 1
a547 2
			dprintf(("dartparam: PASS8\n"));
		} else if (tp->t_ispeed == B134) {
d549 1
a549 2
			dprintf(("dartparam: CS6\n"));
		} else {
a550 2
			dprintf(("dartparam: CS7\n"));
		}
d553 1
a553 1
		if (tp->t_ospeed == B110) {
d555 1
a555 2
			dprintf(("dartparam: two stop bits\n"));
		} else {
a556 2
			dprintf(("dartparam: one stop bit\n"));
		}
d562 1
a562 1
			if (flags & PARODD) {
d564 1
a564 2
				dprintf(("dartparam: odd parity\n"));
			} else {
d566 1
a566 3
				dprintf(("dartparam: even parity\n"));
			}
		} else {
a567 2
			dprintf(("dartparam: no parity\n"));
		}
d569 2
a570 2
		if ((dart_sv_reg.sv_mr1[port] != mr1)
		    || (dart_sv_reg.sv_mr2[port] != mr2)) {
d572 3
a574 3
			ptaddr->write.wr_cr = MRRESET;
			ptaddr->write.wr_mr = mr1;
			ptaddr->write.wr_mr = mr2;
d577 2
a578 2
			dart_sv_reg.sv_mr1[port] = mr1;
			dart_sv_reg.sv_mr2[port] = mr2;
a583 2
		dprintf(("dartparam: reenabling Tx int\n"));

d585 1
a585 1
			dart_sv_reg.sv_imr = dart_sv_reg.sv_imr | ITXRDYA;
d587 2
a588 4
			dart_sv_reg.sv_imr = dart_sv_reg.sv_imr | ITXRDYB;
		addr->write.wr_imr = dart_sv_reg.sv_imr;
	} else {
		dprintf(("dartparam: not enabling Tx\n"));
a591 2
	dprintf(("dartparam: reenabling Rx int\n"));

d594 1
a594 1
		dart_sv_reg.sv_imr = dart_sv_reg.sv_imr | IRXRDYA;
d596 2
a597 2
		dart_sv_reg.sv_imr = dart_sv_reg.sv_imr | IRXRDYB;
	addr->write.wr_imr = dart_sv_reg.sv_imr;
d599 1
a599 1
	return 0;
d603 1
a603 4
dartmodemtrans(sc, ip, ipcr)
	struct dartsoftc *sc;
	unsigned int ip;
	unsigned int ipcr;
a609 3
	dprintf(("dartmodemtrans: ip=0x%x ipcr=0x%x\n",
		 ip, ipcr));

d625 1
a625 3
	if (tp != NULL) {
		dprintf(("dartmodemtrans: tp=0x%x new DCD state: %s\n",
		    tp, dcdstate ? "UP" : "DOWN"));
a626 1
	}
d630 1
a630 5
dartopen (dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
d637 1
d639 1
a639 2
	if (dart_cd.cd_ndevs == 0 || port >= NDARTPORTS)
		return (ENODEV);
a640 2
	sc = (struct dartsoftc *) dart_cd.cd_devs[0]; /* the only one */
	dart = &sc->sc_dart[port];
d642 1
a642 2

	if (dart->tty) {
d644 1
a644 1
	} else {
a645 2
		simple_lock_init(&dart->t_lock);
	}
a646 1
	simple_lock(&dart->t_lock);
a667 1
		simple_unlock(&dart->t_lock);
d671 1
a676 1
	simple_unlock(&dart->t_lock);
d682 1
a682 5
dartclose (dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
d689 1
d691 1
a691 2
	if (dart_cd.cd_ndevs == 0 || port >= NDARTPORTS)
		return (ENODEV);
a692 2
	sc = (struct dartsoftc *) dart_cd.cd_devs[0];
	dart = &sc->sc_dart[port];
d697 1
a697 1
	return 0;
d701 1
a701 4
dartread (dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
d708 1
d710 1
a710 2
	if (dart_cd.cd_ndevs == 0 || port >= NDARTPORTS)
		return (ENODEV);
a711 2
	sc = (struct dartsoftc *) dart_cd.cd_devs[0];
	dart = &sc->sc_dart[port];
d713 2
a714 3

	if (!tp)
		return ENXIO;
d719 1
a719 4
dartwrite(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
d726 1
a727 4
	if (dart_cd.cd_ndevs == 0 || port >= NDARTPORTS)
		return (ENODEV);

	sc = (struct dartsoftc *)dart_cd.cd_devs[0];
d731 2
a732 2
	if (!tp)
		return ENXIO;
d737 1
a737 3
dartrint(sc, port)
	struct dartsoftc *sc;
	int port;
a738 2
	union dartreg *addr;
	union dart_pt_io *ptaddr;
d742 1
d745 2
a746 1
	addr = sc->dart_reg;
d749 3
a751 8
	ptaddr = sc->port_reg[port];

	dprintf(("dartrint: Rx int port %d\n", port));

	tp = dart->tty;

	dprintf(("dartrint: ptaddr = 0x%08x from uart at 0x%08x\n",
		 ptaddr, addr));
d753 2
a754 9
	while ((sr = ptaddr->read.rd_sr) & RXRDY) {
		dprintf(("dartrint: sr = 0x%08x\n", sr));

		data = ptaddr->read.rd_rb; /* read data and reset receiver */

		dprintf(("dartrint: read char \"%c\" (0x%02x) tp = 0x%x\n",
			 data, data, tp));

		if ((tp->t_state & (TS_ISOPEN|TS_WOPEN)) == 0 && CONS_PORT != port) {
a758 5
			dprintf(("dartrint: BREAK detected\n"));
			/*
			data = tp->t_breakc;
			ttyinput(data, tp);
			*/
d760 1
a760 1
			ptaddr->write.wr_cr = BRKINTRESET;
d762 1
a762 1
			ptaddr->write.wr_cr = ERRRESET;
d765 1
a765 1
			if (db_console != 0) {
a766 1
			}
a775 1
				dprintf(("dartrint: error received\n"));
d777 1
a777 1
				ptaddr->write.wr_cr = ERRRESET;
a794 1
	dprintf(("dartrint: ready\n"));
d798 1
a798 3
dartxint(sc, port)
	struct dartsoftc *sc;
	int port;
a801 1
	union dartreg *addr;
a803 2
	addr = sc->dart_reg;

a805 2
	simple_lock(&dart->t_lock);

a813 1
		dprintf(("dartxint: starting output\n"));
a815 2
			dprintf(("dartxint: ready - Tx left enabled\n"));
			simple_unlock(&dart->t_lock);
d823 1
a823 1
		dart_sv_reg.sv_imr = dart_sv_reg.sv_imr & ~ITXRDYA;
d825 1
a825 3
		dart_sv_reg.sv_imr = dart_sv_reg.sv_imr & ~ITXRDYB;

	addr->write.wr_imr = dart_sv_reg.sv_imr;
d827 1
a827 3
	simple_unlock(&dart->t_lock);

	dprintf(("dartxint: ready - Tx disabled\n"));
d831 1
a831 2
dartintr(arg)
	void *arg;
a833 1

a835 1
	union dartreg *addr;
d838 2
a839 3
	addr = sc->dart_reg;
	isr = addr->read.rd_isr;
	imr = dart_sv_reg.sv_imr;
d851 1
a851 1
		return 1;
d856 4
a859 2
		unsigned int ip = addr->read.rd_ip;
		unsigned int ipcr = addr->read.rd_ipcr;
d861 1
a861 1
		return 1;
d870 1
a870 1
		return 1;	/* claim it anyway */
a872 3
	dprintf(("dartintr: interrupt from port %d, isr 0x%08x\n",
		 port, isr));

a873 1
		dprintf(("dartintr: Rx interrupt\n"));
a876 1
		dprintf(("dartintr: Tx interrupt\n"));
d881 1
a881 4
		union dart_pt_io *ptaddr = (union dart_pt_io *)addr + port;

		dprintf(("dartintr: clearing end of BREAK state\n"));
		ptaddr->write.wr_cr = BRKINTRESET;
d884 1
a884 2
	dprintf(("dartintr: ready\n"));
	return 1;
d888 3
a890 2
 * Console interface routines. Currently only dev 0 or 1
 * supported.
d894 1
a894 2
dartcnprobe(cp)
	struct consdev *cp;
d898 5
a902 1
	if (brdtyp != BRD_188 || badaddr(DART_BASE, 2) != 0)
d912 1
a912 1
	cp->cn_dev = makedev(maj, 0);
d923 1
a923 3
dartcnputc(dev, c)
	dev_t dev;
	int c;
d925 1
a925 2
	union dartreg *addr;
	union dart_pt_io *ptaddr;
d928 1
d930 1
d932 1
a932 8

	addr = (union dartreg *) MVME188_DUART;

#if 1
	ptaddr = (union dart_pt_io *) addr + (port * 0x20);
#else
	ptaddr = (union dart_pt_io *) addr + ((dev & 1) ? 1 : 0);
#endif
a935 3
	/* Assume first port initialized if we get here. */
	/* Assume the bug initializes the port */

d937 1
a937 1
	addr->write.wr_imr = dart_sv_reg.sv_imr & ~ITXRDYA;
d940 1
a940 1
	ptaddr->write.wr_cr = TXEN;
d942 1
a942 1
	while (!(ptaddr->read.rd_sr & TXRDY))
d944 1
a944 1
	ptaddr->write.wr_tb = c;
d947 1
a947 1
	while (!(ptaddr->read.rd_sr & TXEMT))
d951 1
a951 1
	addr->write.wr_imr = dart_sv_reg.sv_imr;
d953 1
a953 1
	ptaddr->write.wr_cr = dart_sv_reg.sv_cr[0];
d959 1
a959 2
dartcngetc(dev)
	dev_t dev;
d961 2
a962 3
	union dartreg  *addr;	   /* pointer to DUART regs */
	union dart_pt_io  *ptaddr; /* pointer to port regs */
	unsigned char   sr;	       /* status reg of port a/b */
d966 1
d968 1
d970 2
d973 1
a973 6
	addr = (union dartreg *) DART_BASE;
#if 1
	ptaddr = (union dart_pt_io *) addr + (port * 0x20);
#else
	ptaddr = (union dart_pt_io *) addr + ((dev & 1) ? 1 : 0);
#endif
d975 1
a975 1
	ptaddr->write.wr_cr = RXEN;
d979 1
a979 1
		sr = ptaddr->read.rd_sr;
d984 1
a984 1
			c = ptaddr->read.rd_rb;
d989 1
a989 1
				ptaddr->write.wr_cr = BRKINTRESET;
d991 1
a991 1
				ptaddr->write.wr_cr = ERRRESET;
d997 1
a997 1
				ptaddr->write.wr_cr = ERRRESET;
d999 1
a999 1
				ptaddr->write.wr_cr = BRKINTRESET;
d1006 2
a1007 1
	return (int)c;
@


1.44
log
@Merge <machine/cpu_number.h> into <machine/cpu.h>, preparing for intrusive
changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.43 2005/04/30 16:40:42 miod Exp $	*/
a1155 2

	cp->cn_pri = CN_DEAD;
@


1.43
log
@Remove disabled code which would disable all interrupts rather than switch
to spltty for processing.
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.42 2004/11/13 14:47:35 miod Exp $	*/
a43 1
#include <machine/cpu_number.h>
@


1.42
log
@Let the chip settle for a bit more time between trying to output two
characters; this will prevent us from falling into timeout behaviour when
it is in fact not necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.41 2004/08/24 18:44:49 miod Exp $	*/
a1186 3
#if 0
	m88k_psr_type psr;
#endif
a1199 1
#if 1
a1200 3
#else
	psr = disable_interrupts_return_psr();
#endif
a1223 1
#if 1
a1224 3
#else
	set_psr(psr);
#endif
a1236 4
#if 1
#else
	m88k_psr_type psr;
#endif
a1238 1
#if 1
a1239 3
#else
	psr = disable_interrupts_return_psr();
#endif
a1276 1
#if 1
a1277 3
#else
	set_psr(psr);
#endif
@


1.41
log
@Oops, unbreak dartcngetc().
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.40 2004/08/19 17:10:15 miod Exp $	*/
d325 1
a325 1
	int port;
d350 1
a352 1
		selwakeup(&tp->t_wsel);
d361 2
a362 2
	if (tp->t_outq.c_cc != 0) {
		tp->t_state |= TS_BUSY;
d365 9
a373 1
		while (ptaddr->read.rd_sr & TXRDY) {
d384 1
a384 1
				dart_sv_reg.sv_imr = dart_sv_reg.sv_imr | ITXRDYA;
d386 1
a386 1
				dart_sv_reg.sv_imr = dart_sv_reg.sv_imr | ITXRDYB;
a387 3

			if (tp->t_outq.c_cc == 0)
				break;
d389 2
a391 7
		tp->t_state &= ~TS_BUSY;

		if (tp->t_outq.c_cc != 0) {
			timeout_add(&tp->t_rstrt_to, 1);
			tp->t_state |= TS_TIMEOUT;
		}
	}
@


1.40
log
@Fix (well, rewrite) the start() logic - not only would it eat characters,
but it could cause the output to stop completely.

While there, fix cnputc() prototype and clean up cngetc().
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.39 2004/08/02 08:35:00 miod Exp $	*/
d1245 1
a1245 1
	int c;		/* received character */
a1291 1
				/* c &= 0x7f; */
d1301 1
a1301 1
	return c;
@


1.39
log
@More include files cleaning:
- move MAX_CPUS constant to <machine/cpu.h>
- do not include <machine/board.h> unless needed. In fact, remove this file
  entirely on mvme88k, and include <machine/mvme*.h> on a
  compiling-for-this-board basis
- keep MAX_CMMUS constant private to the m8820x code
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.38 2004/07/31 22:26:27 miod Exp $	*/
d322 1
a322 1
	int s, cc;
d342 1
a342 1
	if (tp->t_state & (TS_TIMEOUT |TS_BUSY | TS_TTSTOP))
a354 3
	if (tp->t_state & (TS_TIMEOUT | TS_BUSY | TS_TTSTOP))
		goto bail;

d363 1
a363 1
		cc = tp->t_outq.c_cc;
a365 2
                        if(cc == 0)
				 break;
a366 14
			cc--;
			if (tp->t_flags & CS8 || c <= 0177) {
				if (port != CONS_PORT)
					dprintf(("dartstart: writing char \"%c\" (0x%02x) to port %d\n",
						 c & 0xff, c & 0xff, port));
				ptaddr->write.wr_tb = c & 0xff;

				if (port != CONS_PORT)
					dprintf(("dartstart: enabling Tx int\n"));
				if (port == A_PORT)
					dart_sv_reg.sv_imr = dart_sv_reg.sv_imr | ITXRDYA;
				else
					dart_sv_reg.sv_imr = dart_sv_reg.sv_imr | ITXRDYB;
				addr->write.wr_imr = dart_sv_reg.sv_imr;
d368 22
a389 8
			} else {
				tp->t_state &= ~TS_BUSY;
				if (port != CONS_PORT)
					dprintf(("dartxint: timing out char \"%c\" (0x%02x)\n",
					 c & 0xff, c % 0xff));
				timeout_add(&tp->t_rstrt_to, 1);
				tp->t_state |= TS_TIMEOUT;
			}
d1183 1
a1183 1
	char c;
a1251 1
	char buf[] = "char x";
d1268 1
a1268 1
	do {
d1283 1
a1283 6
#if 1
				splx(s);
#else
				set_psr(psr);
#endif
				return c;
d1286 1
a1286 1
			if (sr & (FRERR|PERR|ROVRN)) {
d1292 2
a1293 7
				buf[5] = (char) c;
#if 1
				splx(s);
#else
				set_psr(psr);
#endif
				return (c & 0x7f);
d1296 1
a1296 1
	} while (-1);
d1302 1
a1302 1
	return -1;
@


1.38
log
@Always claim dart interrupts, even if they report disabled conditions, but
warn about them on console. More informative than ``regular'' spurious interrupt
warnings.
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.37 2004/07/30 19:02:05 miod Exp $	*/
d50 1
@


1.37
log
@Move evcount structures inside struct intrhand, this makes more sense and
gives us more counters in the process.

Also clean up intrhand structures and usage, especially move them to SLISTs.
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.36 2004/07/23 23:15:49 miod Exp $	*/
d1089 1
a1089 1
	unsigned char isr;
a1094 1

d1096 1
a1096 1
	isr &= dart_sv_reg.sv_imr;
d1098 13
a1110 2
	if (isr == 0)	/* not interrupt from this duart */
		return 0;
@


1.36
log
@Better fix for the ttymodem issue.
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.34 2004/07/02 14:00:43 miod Exp $	*/
a38 1
#include <sys/evcount.h>
a75 1
	struct evcount		sc_intrcnt;
d308 1
a308 3
	sysconintr_establish(SYSCV_SCC, &sc->sc_ih);
	evcount_attach(&sc->sc_intrcnt, self->dv_xname,
	    (void *)&sc->sc_ih.ih_ipl, &evcount_intr);
a1100 2

	sc->sc_intrcnt.ec_count++;
@


1.35
log
@Be more careful when handling interrupts - especially the first one after
the console transition from BUG to the chip could lead us to invoke
ttymodem() on a bogus tty.
@
text
@d807 1
a807 2
		printf("dartmodemtrans: unknown transition:\n");
		printf("dartmodemtrans: ip=0x%x ipcr=0x%x\n",
d809 1
a809 1
		panic("dartmodemtrans");
d811 1
d814 3
a816 5

	dprintf(("dartmodemtrans: tp=0x%x new DCD state: %s\n",
		 tp, dcdstate ? "UP" : "DOWN"));

	if (tp != NULL && (tp->t_state & TS_ISOPEN))
d818 1
@


1.34
log
@Switch mvme88k to evcount, but keep maintaining intrcnt[] too for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.33 2004/04/24 19:51:47 miod Exp $	*/
d684 1
a684 1
		addr -> write.wr_imr = dart_sv_reg.sv_imr;
d767 1
a767 1
		addr -> write.wr_imr = dart_sv_reg.sv_imr;
d780 1
a780 1
	addr -> write.wr_imr = dart_sv_reg.sv_imr;
d817 3
a819 1
	(void) ttymodem(tp, dcdstate);
d1104 2
a1105 2
	if (isr) {     /* interrupt from this duart */
		sc->sc_intrcnt.ec_count++;
d1107 8
a1114 6
		if (isr & IIPCHG) {
			unsigned int ip = addr->read.rd_ip;
			unsigned int ipcr = addr->read.rd_ipcr;
			dartmodemtrans(sc, ip, ipcr);
			return 1;
		}
d1116 8
a1123 9
		if (isr & (IRXRDYA | ITXRDYA))
			port = 0;
		else
			if (isr & (IRXRDYB | ITXRDYB))
			port = 1;
		else {
			printf("dartintr: spurious interrupt, isr 0x%08x\n", isr);
			panic("dartintr");
		}
d1125 2
a1126 2
		dprintf(("dartintr: interrupt from port %d, isr 0x%08x\n",
			 port, isr));
d1128 11
a1138 12
		if (isr & (IRXRDYA | IRXRDYB)) {
			dprintf(("dartintr: Rx interrupt\n"));
			dartrint(sc, port);
		}
		if (isr & (ITXRDYA | ITXRDYB)) {
			dprintf(("dartintr: Tx interrupt\n"));
			dartxint(sc, port);
		}
		if (((port == A_PORT) && (isr & IBRKA))
		    || ((port == B_PORT) && (isr & IBRKB))) {
			union dart_pt_io *ptaddr =
			(union dart_pt_io *)addr + port;
d1140 2
a1141 3
			dprintf(("dartintr: clearing end of BREAK state\n"));
			ptaddr->write.wr_cr = BRKINTRESET;
		}
d1143 1
@


1.33
log
@Preliminary switch to an mvme88k bus_space world. Not all drivers have been
converted yet, and they rely upon some linear mappings provided by bus_space.

In order to not impact performance, almost all the bus_space accesses go
through macros and inline functions. This currently restricts us to D16 and
D32 access modes, which are selected at compilation time. Since there are no
plans to support D8 vme devices in the future, this is acceptable for now.

This makes the "len" locator for vme devices go away, and allows to simplify
some code which was using the pcctwo device, and will now directly access
hardware which is known to exist, rather than wait until the device is
attached.

While there, try to enforce more interrupt vector number checks, since these
changes pointed out that dart(4) had been working correctly so far by sheer
luck only.
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.32 2004/04/16 23:32:44 miod Exp $	*/
d39 1
d77 1
a77 1
	struct evcnt		sc_intrcnt;
d311 2
a312 1
	evcnt_attach(&sc->sc_dev, "intr", &sc->sc_intrcnt);
d1103 2
@


1.32
log
@Do not register console as CN_NORMAL priority if we are not in cdevsw[].

Also, in cl, print the correct device name instead of hardcoded cl0 in
various diagnostic/warning messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.31 2004/04/15 12:35:20 miod Exp $	*/
d146 1
a146 1
	{0xFFFF,	NOBAUD	},	/* anything more is uncivilized */
d153 3
a155 2
	const struct dart_s *ds = dart_speeds;
	while (ds->kspeed != 0xFFFF) {
d158 1
a158 2
		ds++;
	}
d186 4
a189 3
	if (brdtyp != BRD_188) return (0);
	ca->ca_vaddr = ca->ca_paddr; /* 1:1 */
	addr = (union dartreg *)ca->ca_vaddr;
d192 1
d194 1
d197 1
a212 4
	if (ca->ca_vec < 0) {
		printf(": no more interrupts!\n");
		return;
	}
d301 1
a301 1
	addr->write.wr_ivr = SYSCV_SCC;	/* hard coded vector */
d309 1
a309 1
	intr_establish(ca->ca_vec, &sc->sc_ih);
@


1.31
log
@constify baud rate to hardware parameters structures.
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.30 2004/02/11 20:41:07 miod Exp $	*/
d60 2
a61 2
   int dart_debug = 1;
   #define dprintf(stuff) if (dart_debug) printf stuff
d63 1
a63 1
   #define dprintf(stuff)
a80 3
	int			sc_flags;
	int			sc_ipl;
	int			sc_vec;
d83 2
a84 2
int dartmatch(struct device *parent, void *self, void *aux);
void dartattach(struct device *parent, struct device *self, void *aux);
d109 1
d111 1
d209 7
d217 2
a218 2
	sc->dart_reg = (union dartreg *)ca->ca_vaddr;
        ptaddr = (union  dart_pt_io *)ca->ca_vaddr;
a221 1
	sc->sc_ipl = ca->ca_ipl = IPL_TTY; /* always... hard coded ipl */
a223 2
	ca->ca_vec = SYSCV_SCC;	/* hard coded vector */
	sc->sc_vec = ca->ca_vec;
d301 1
a301 1
	addr->write.wr_ivr = sc->sc_vec;
a399 1
	return;
d514 1
a545 2

	return;
d547 1
a1002 1
				dprintf(("dartrint: break detected - entering debugger\n"));
a1081 2

	return;
d1153 3
a1155 2
	if (brdtyp != BRD_188 || badaddr(DART_BASE, 2) != 0) {
		cp->cn_pri = CN_DEAD;
a1156 1
	}
d1162 2
@


1.30
log
@Keep using the BUG as the console device until autoconf is over, rather
than switching early.
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.29 2004/02/10 10:30:25 miod Exp $	*/
d124 1
a124 1
#define dart_tty darttty
d128 1
a128 1
struct dart_s {
d154 1
a154 1
	struct dart_s *ds = dart_speeds;
@


1.29
log
@Check for the device existence in cnprobe() as done in match(), to be sure
we don't try to attach a phantom console.

It seems that some late 187 models do not have cl0 at the expected address...
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.28 2004/02/10 10:06:48 miod Exp $	*/
d97 2
a98 1
int dart_cons = -1;
d241 8
a248 3
	if (dart_cons >= 0) {
		printf(": console (tty%s) ", dart_cons == 0 ? "a" : "b");
	}
d358 1
a358 1
	if (port != dart_cons)
d372 1
a372 1
				if (port != dart_cons)
d377 1
a377 1
				if (port != dart_cons)
d387 1
a387 1
				if (port != dart_cons)
d612 1
a612 1
		if (dart_cons == port)
d622 1
a622 1
		if (dart_cons == port)
d673 1
a673 1
	if (dart_cons == port) {
d855 1
a855 1
		if (port == dart_cons) {
d984 1
a984 1
		if ((tp->t_state & (TS_ISOPEN|TS_WOPEN)) == 0 && dart_cons != port) {
a1171 1
	dart_cons = A_PORT;
@


1.28
log
@Fix cnprobe() and cninit() prototypes.
Also, provide a better test for bugtty attachment.
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.27 2004/01/14 20:50:48 miod Exp $	*/
d45 1
d1148 1
a1148 1
	if (brdtyp != BRD_188) {
d1152 1
@


1.27
log
@Do not fill more than the first three fields of cfdriver structures unless
necessary. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.26 2003/10/23 19:03:26 miod Exp $	*/
d97 1
d99 1
a99 4
int dartcnprobe(struct consdev *cp);
int dartcninit(struct consdev *cp);
int dartcngetc(dev_t dev);
void dartcnputc(dev_t dev, char c);
d240 1
a240 1
		printf(" console (tty%s) ", dart_cons == 0 ? "a" : "b");
d1141 1
a1141 1
int
d1149 1
a1149 1
		return 0;
a1157 1
	return (1);
d1160 1
a1160 1
int
a1164 1
	return 0;
@


1.26
log
@No dependency on NDART needed here.
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.25 2003/10/11 22:08:57 miod Exp $	*/
d93 1
a93 1
   NULL, "dart", DV_TTY, 0
@


1.25
log
@Nuke trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.24 2003/10/03 16:44:50 miod Exp $	*/
a51 1
#include "dart.h"
@


1.24
log
@Merge tty_attach() in ttymalloc() and tty_detach() in ttyfree(). The need for
separate tty registering is gone now that sparc has switched to wscons, and
this makes the code less error-prone.

Also, remove tests for ttymalloc() failure, since it uses M_WAITOK.

ok millert@@ deraadt@@, tested by various people as well besides me...
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.23 2003/09/28 14:26:25 miod Exp $	*/
d89 1
a89 1
struct cfattach dart_ca = {       
d91 1
a91 1
};      
d157 1
a157 1
		if (ds->kspeed == speed) 
d164 1
a164 1
struct tty* 
d191 1
a191 1
	
d221 1
a221 1
	sc->sc_vec = ca->ca_vec; 
d241 1
a241 1
	
d326 1
a326 1
	
d333 1
a333 1
	
d335 1
a335 1
	
d338 1
a338 1
	
d372 1
a372 1
				
d446 1
a446 1
	int s; 
d451 1
a451 1
	
d466 1
a466 1
#endif 
d468 1
a468 1
	
d479 1
a479 1
#endif 
d530 1
a530 1
	
d543 1
a543 1
int 
d560 1
a560 1
	
d613 1
a613 1
		error = suser(p, 0); 
d615 1
a615 1
			return(EPERM); 
d633 1
a633 1
int 
d658 1
a658 1
	
d812 1
a812 1
int 
d875 1
a875 1
int 
d890 1
a890 1
	
d896 1
a896 1
	
d900 1
a900 1
int 
d914 1
a914 1
	
d924 1
a924 1
int 
d938 1
a938 1
	
d1025 1
a1025 1
#endif 
a1094 1
	
d1096 1
a1096 1
	
d1193 1
a1193 1
#endif 
d1197 1
a1197 1
#else 
d1199 1
a1199 1
#endif 
d1225 1
a1225 1
#else 
d1227 1
a1227 1
#endif 
d1257 1
a1257 1
#endif 
d1278 1
a1278 1
#else 
d1280 1
a1280 1
#endif 
d1293 1
a1293 1
#else 
d1295 1
a1295 1
#endif 
d1302 1
a1302 1
#else 
d1304 1
a1304 1
#endif 
@


1.23
log
@Be sure to invoke tty_attach() after ttymalloc().
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.22 2003/09/22 21:39:39 miod Exp $	*/
a835 1
		tty_attach(tp);
@


1.22
log
@Off-by-ones, from aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.21 2003/08/21 21:48:23 miod Exp $	*/
d836 1
@


1.21
log
@Bounds checking, prevents ioctls to non-existing dart devices from panic'ing
the kernel; fixes a ttyflags botch reported by Luke Th. Bullock
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.20 2003/08/15 20:32:14 tedu Exp $	*/
d172 1
a172 1
	if (dart_cd.cd_ndevs == 0 || port > NDARTPORTS)
d324 1
a324 1
	if (dart_cd.cd_ndevs == 0 || port > NDARTPORTS)
d449 1
a449 1
	if (dart_cd.cd_ndevs == 0 || port > NDARTPORTS)
d558 1
a558 1
	if (dart_cd.cd_ndevs == 0 || port > NDARTPORTS)
d651 1
a651 1
	if (dart_cd.cd_ndevs == 0 || port > NDARTPORTS)
d825 1
a825 1
	if (dart_cd.cd_ndevs == 0 || port > NDARTPORTS)
d888 1
a888 1
	if (dart_cd.cd_ndevs == 0 || port > NDARTPORTS)
d912 1
a912 1
	if (dart_cd.cd_ndevs == 0 || port > NDARTPORTS)
d936 1
a936 1
	if (dart_cd.cd_ndevs == 0 || port > NDARTPORTS)
@


1.20
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.19 2003/08/12 19:32:45 miod Exp $	*/
d66 2
d78 2
a79 2
        union  dart_pt_io	*port_reg[2];
	struct dart_info	sc_dart[2];
d168 1
a168 1
	int port;
d170 5
a175 1
	port = DART_PORT(dev);
d323 2
a324 1
	if((port = DART_PORT(dev)) > 1)
d448 2
a449 1
	if ((port = DART_PORT(dev)) > 1) {
d451 1
a451 1
	}
d556 1
d558 3
d650 2
a651 1
	if ((port = DART_PORT(dev)) > 1) {
a652 1
	}
d824 2
a825 1
	if ((port = DART_PORT(dev)) > 1) {
d827 1
a827 1
	}
d887 2
a888 2
	if ((port = DART_PORT(dev)) > 1) {
		printf("dartclose: inavalid device dev(%d, %d)\n", major(dev), minor(dev)); 
d890 1
a890 1
	}
d911 2
a912 1
	if ((port = DART_PORT(dev)) > 1) {
d914 1
a914 1
	}
d935 2
a936 1
	if ((port = DART_PORT(dev)) > 1) {
d938 1
a938 1
	}
@


1.19
log
@Use spltty() instead of rolling our own expanded version.
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.18 2002/06/12 03:49:56 miod Exp $	*/
d601 1
a601 1
		error = suser(p->p_ucred, &p->p_acflag); 
@


1.18
log
@cnputc() will take care of the necessary cr->cr/lf translation, so don't
do it in those consoles either.
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.17 2002/04/28 15:17:09 miod Exp $	*/
d53 1
a53 1
#define spldart()	splx(IPL_TTY)
@


1.17
log
@Use the prototypes defined via cdev_decl() macros, instead of rolling our
own; thus fix a lot of foo_open(), foo_close() and foo_ioctl() prototypes
in the process.
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.16 2002/03/14 01:26:39 millert Exp $	*/
d1196 3
a1198 10
	/* If the character is a line feed(\n) */
	/* then follow it with carriage return (\r) */
	for (;;) {
		while (!(ptaddr->read.rd_sr & TXRDY))
			;
		ptaddr->write.wr_tb = c;
		if (c != '\n')
			break;
		c = '\r';
	}
@


1.16
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.15 2001/12/19 07:04:41 smurph Exp $	*/
a29 1
#include <sys/conf.h>
d42 1
a109 6
int dartopen(dev_t dev, int flag, int mode, struct proc *p);
int dartclose(dev_t dev, int flag, int mode, struct proc *p);
int dartread(dev_t dev, struct uio *uio, int flag);
int dartwrite(dev_t dev, struct uio *uio, int flag);
int dartioctl(dev_t dev, int cmd, caddr_t data, int flag, struct proc *p);
int dartstop(struct tty *tp, int flag);
d536 1
a536 1
dartioctl (dev, cmd, data, flag, p)
d538 1
a538 1
	int cmd;
@


1.15
log
@Introduce brdtyp and change what cputyp means.
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.14 2001/12/16 23:49:46 miod Exp $	*/
d84 2
a85 2
int dartmatch __P((struct device *parent, void *self, void *aux));
void dartattach __P((struct device *parent, struct device *self, void *aux));
d97 21
a117 21
int dartcnprobe __P((struct consdev *cp));
int dartcninit __P((struct consdev *cp));
int dartcngetc __P((dev_t dev));
void dartcnputc __P((dev_t dev, char c));
int dart_speed __P((int));
struct tty* darttty __P((dev_t));
void dartstart __P((struct tty *));
int dartmctl __P((dev_t, int, int));
int dartparam __P((struct tty *, struct termios *));
void dartmodemtrans __P((struct dartsoftc *, unsigned int, unsigned int));
void dartrint __P((struct dartsoftc *, int));
void dartxint __P((struct dartsoftc *, int));

int dartopen __P((dev_t dev, int flag, int mode, struct proc *p));
int dartclose __P((dev_t dev, int flag, int mode, struct proc *p));
int dartread __P((dev_t dev, struct uio *uio, int flag));
int dartwrite __P((dev_t dev, struct uio *uio, int flag));
int dartioctl __P((dev_t dev, int cmd, caddr_t data, int flag, struct proc *p));
int dartstop __P((struct tty *tp, int flag));
int dartintr __P((void *));
void dartbreak __P((dev_t dev, int state));
@


1.15.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.15 2001/12/19 07:04:41 smurph Exp $	*/
d30 1
a42 1
#include <machine/conf.h>
d84 2
a85 2
int dartmatch(struct device *parent, void *self, void *aux);
void dartattach(struct device *parent, struct device *self, void *aux);
d97 21
a117 15
int dartcnprobe(struct consdev *cp);
int dartcninit(struct consdev *cp);
int dartcngetc(dev_t dev);
void dartcnputc(dev_t dev, char c);
int dart_speed(int);
struct tty* darttty(dev_t);
void dartstart(struct tty *);
int dartmctl(dev_t, int, int);
int dartparam(struct tty *, struct termios *);
void dartmodemtrans(struct dartsoftc *, unsigned int, unsigned int);
void dartrint(struct dartsoftc *, int);
void dartxint(struct dartsoftc *, int);

int dartintr(void *);
void dartbreak(dev_t dev, int state);
d542 1
a542 1
dartioctl(dev, cmd, data, flag, p)
d544 1
a544 1
	u_long cmd;
@


1.15.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.15.2.1 2002/06/11 03:37:09 art Exp $	*/
d1196 10
a1205 3
	while (!(ptaddr->read.rd_sr & TXRDY))
		;
	ptaddr->write.wr_tb = c;
@


1.14
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.12 2001/08/31 08:18:24 miod Exp $	*/
d188 1
a188 1
	if (cputyp != CPU_188) return (0);
d191 2
a192 1
	if (badvaddr((vaddr_t)addr, 2) <= 0) {
d1142 1
a1142 1
	if (cputyp != CPU_188) {
@


1.13
log
@Support for MVME197 completed.  Fix SPL defs.
@
text
@d188 1
a188 1
	if (brdtyp != BRD_188) return (0);
d191 1
a191 2
	
	if (badvaddr((vaddr_t)addr, 2)) {
d1141 1
a1141 1
	if (brdtyp != BRD_188) {
@


1.12
log
@I should get more sleep.
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.11 2001/08/31 01:05:44 miod Exp $	*/
d188 1
a188 1
	if (cputyp != CPU_188) return (0);
d191 2
a192 1
	if (badvaddr((vaddr_t)addr, 2) <= 0) {
d1142 1
a1142 1
	if (cputyp != CPU_188) {
@


1.11
log
@Clean the DDB entry procedure for all console drivers, and honour
db_console setting.
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.10 2001/08/26 02:37:07 miod Exp $	*/
d56 1
a56 1
#include <db_variables.h>
@


1.10
log
@Add prototypes, fix compilation warnings, random style fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.9 2001/08/24 19:32:06 miod Exp $	*/
d39 4
a43 1
#include <machine/autoconf.h>
d45 2
a46 1
#include <machine/asm_macro.h>   /* enable/disable interrupts */
d48 1
d51 1
a51 1
#include <sys/syslog.h>
a52 1
#include <machine/psl.h>
d55 2
a56 6
#if defined(DDB)
#include <machine/db_machdep.h>		/* for details on entering kdb */
#define DDB_ENTER_BREAK 0x1
#define DDB_ENTER_CHAR  0x2
unsigned char ddb_break_mode = DDB_ENTER_BREAK;
unsigned char ddb_break_char = 0;
d986 1
a986 1
			if (ddb_break_mode & DDB_ENTER_BREAK) {
d988 1
a988 1
				gimmeabreak();
d1004 1
a1004 7
#if defined(DDB)
				if ((ddb_break_mode & DDB_ENTER_CHAR) && (ddb_break_char == data)) {
					dprintf(("dartrint: ddb_break_char detected - entering debugger\n"));
					gimmeabreak();
				} else
#endif
					(*linesw[tp->t_line].l_rint)(data,tp);
@


1.9
log
@Pass a dev_t where a dev_t is expected.
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.8 2001/08/24 19:26:12 miod Exp $	*/
d101 8
d191 1
a191 1
	if (badvaddr(addr, 2) <= 0) {
d1244 2
d1247 1
@


1.8
log
@No newline at the end of panic messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: dart.c,v 1.7 2001/07/04 08:09:21 niklas Exp $	*/
d666 1
a666 1
			dartmctl(tp, HUPCL, DMSET);
@


1.7
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d484 1
a484 1
		panic("dartmctl: DMGET not supported (yet)\n");
@


1.6
log
@kernel will compile with -Werror.  Added intr.h
@
text
@d1 2
@


1.5
log
@Fix interrupt handler registration and prototypes.
While there, some warning hunting.
@
text
@d147 1
a147 1
int speed;
d160 1
a160 1
dev_t dev;
d171 2
a172 2
struct device *parent;
void *vcf, *args;
d190 3
a192 3
struct device *parent;
struct device *self;
void *aux;
d301 1
a301 1
struct tty *tp;
d389 2
a390 2
struct tty *tp;
int flag;
d424 3
a426 3
dev_t dev;
int flags;
int how;
d500 2
a501 2
dev_t dev;
int state;
d532 5
a536 5
dev_t dev;
int cmd;
caddr_t data;
int flag;
struct proc *p;
d618 2
a619 2
struct tty *tp;
struct termios *t;
d762 3
a764 3
struct dartsoftc *sc;
unsigned int ip;
unsigned int ipcr;
d797 4
a800 4
dev_t dev;
int flag;
int mode;
struct proc *p;
d859 4
a862 4
dev_t dev;
int flag;
int mode;
struct proc *p;
d884 3
a886 3
dev_t dev;
struct uio *uio;
int flag;
d907 3
a909 3
dev_t dev;
struct uio *uio;
int flag;
d930 2
a931 2
struct dartsoftc *sc;
int port;
d1020 2
a1021 2
struct dartsoftc *sc;
int port;
d1133 1
a1133 1
struct consdev *cp;
d1153 1
a1153 1
struct consdev *cp;
d1161 2
a1162 2
dev_t dev;
char c;
d1226 1
a1226 1
dev_t dev;
@


1.4
log
@correct buginstat(), statclock now working for '188, systat vmstat now works,
serial driver for '188 working better.
@
text
@d98 1
a98 1
int dartcnputc __P((dev_t dev, char c));
d106 1
a106 1
int dartintr __P((struct dartsoftc *sc));
a173 1
	struct cfdata *cf = vcf;
a195 1
	int i;
d288 1
a289 1
	sc->sc_ih.ih_wantframe = 0;
d305 1
a305 1
	int s, cnt, cc;
d436 1
a436 1
	if (port = DART_PORT(dev) > 1) {
a863 1
	int unit, channel;
d867 1
a867 1
	int s, port;
d888 1
a888 1
	int unit, port;
d893 1
a893 1
	if (port = DART_PORT(dev) > 1) {
d916 1
a916 1
	if (port = DART_PORT(dev) > 1) {
a1025 1
	dev_t dev;
d1068 2
a1069 2
dartintr(sc)
struct dartsoftc *sc;
d1071 2
a1073 1
	unsigned char sr;
d1159 1
a1159 1
int
d1166 1
d1168 1
a1221 1
	return;
@


1.3
log
@Major changes to get MVME188 working.  More header and code cleanups.  The
kernel is tested on MVME188A/2P256 and MVME188A/1P64.
@
text
@d53 2
a54 2
unsigned char ddb_break_mode = DDB_ENTER_BREAK | DDB_ENTER_CHAR;
unsigned char ddb_break_char = '!';
d57 2
a58 2
#if DEBUG
   int dart_debug = 0;
d74 1
d93 1
d123 25
a147 1
int dart_speeds[] =
d149 8
a156 17
	0,		/* 0 baud, special HUP condition */
	NOBAUD,		/* 50 baud, not implemented */
	BD75,		/* 75 baud */
	BD110,		/* 110 baud */
	BD134,		/* 134.5 baud */
	BD150,		/* 150 baud */
	NOBAUD,		/* 200 baud, not implemented */
	BD300,		/* 300 baud */
	BD600,		/* 600 baud */
	BD1200,		/* 1200 baud */
	BD1800,		/* 1800 baud */
	BD2400,		/* 2400 baud */
	BD4800,		/* 4800 baud */
	BD9600,		/* 9600 baud */
	BD19200,	/* 19200 baud */
	NOBAUD		/* 38400 baud, not implemented */
};
d204 4
d209 2
d232 4
d237 1
a237 1
	dprintf(("dartattach: resetting port A\n"));
d307 1
a307 1
	int s, cnt;
d314 3
a316 1
	port = DART_PORT(dev);
d318 2
d323 15
d339 2
a340 2
	addr = sc->dart_reg;
	ptaddr = (union dart_pt_io *)addr + port;
d342 1
a342 2
	if (tp->t_state & (TS_TIMEOUT|TS_BUSY|TS_TTSTOP))
		goto out;
d344 3
a346 5
	/*
	if (tp->t_outq.c_cc <= TTLOWAT(tp)) {
	   ttwakeup(tp);
	}
	*/
a348 1

d350 1
a350 1

d353 2
d356 1
a356 1

d358 3
a360 3

				dprintf(("dartstart: writing char \"%c\" (0x%02x)\n",
					 c & 0xff, c % 0xff));
d362 3
a364 2

				dprintf(("dartstart: enabling Tx int\n"));
d369 2
a370 1
				addr -> write.wr_imr = dart_sv_reg.sv_imr;
d373 2
a374 1
				dprintf(("dartxint: timing out char \"%c\" (0x%02x)\n",
a375 1
#if 1
a376 3
#else
				ttrstrt(tp);
#endif 
d381 2
a382 1
out:
d395 1
d401 1
d436 1
d446 1
d455 3
a457 1

d493 1
a493 1

d518 2
a519 2
	ptaddr = (union dart_pt_io *) addr + port;

d522 1
a522 1
	      to prevent the transmitter empty interrupt */
d593 2
d603 2
a632 2
	dprintf(("dartparam: setting param for dev %d\n", dev));

d634 2
a635 1
	if (port = DART_PORT(dev) > 1) {
d642 2
a643 1
	ptaddr = (union dart_pt_io *) addr + port;
d654 24
a677 5
	if (port == A_PORT)
		dart_sv_reg.sv_imr = dart_sv_reg.sv_imr & ~(ITXRDYA | IRXRDYA);
	else
		dart_sv_reg.sv_imr = dart_sv_reg.sv_imr & ~(ITXRDYB | IRXRDYB);
	addr -> write.wr_imr = dart_sv_reg.sv_imr;
d679 18
a696 33
	/* hang up on zero baud rate */
	if (tp->t_ispeed == 0) {
		dprintf(("dartparam: ispeed == 0 -> HUP\n"));
		dartmctl(tp, HUPCL, DMSET);
		return;
	} else {
		/* set baudrate */
		speeds = dart_speeds[(unsigned char)tp->t_ispeed];
		if (speeds == NOBAUD)
			speeds = dart_sv_reg.sv_csr[port];
		ptaddr->write.wr_csr = speeds;
		dart_sv_reg.sv_csr[port] = speeds;
		dprintf(("dartparam: baudrate set param = %d\n", speeds));
	}

	/* get saved mode registers and clear set up parameters */
	mr1 = dart_sv_reg.sv_mr1[port];
	mr1 &= ~(CLMASK | PARTYPEMASK | PARMODEMASK);

	mr2 = dart_sv_reg.sv_mr2[port];
	mr2 &= ~SBMASK;

	/* set up character size */
	if (flags & CS8) {
		mr1 |= CL8;
		dprintf(("dartparam: PASS8\n"));
	} else if (tp->t_ispeed == B134) {
		mr1 |= CL6;
		dprintf(("dartparam: CS6\n"));
	} else {
		mr1 |= CL7;
		dprintf(("dartparam: CS7\n"));
	}
d698 8
a705 8
	/* set up stop bits */
	if (tp->t_ospeed == B110) {
		mr2 |= SB2;
		dprintf(("dartparam: two stop bits\n"));
	} else {
		mr2 |= SB1;
		dprintf(("dartparam: one stop bit\n"));
	}
d707 11
a717 7
	/* set up parity */
	if (((flags & PARENB) != PARENB) &&
	    (flags & PARENB)) {
		mr1 |= PAREN;
		if (flags & PARODD) {
			mr1 |= ODDPAR;
			dprintf(("dartparam: odd parity\n"));
d719 2
a720 2
			mr1 |= EVENPAR;
			dprintf(("dartparam: even parity\n"));
a721 4
	} else {
		mr1 |= PARDIS;
		dprintf(("dartparam: no parity\n"));
	}
d723 11
a733 10
	if ((dart_sv_reg.sv_mr1[port] != mr1)
	    || (dart_sv_reg.sv_mr2[port] != mr2)) {
		/* write mode registers to duart */
		ptaddr->write.wr_cr = MRRESET;
		ptaddr->write.wr_mr = mr1;
		ptaddr->write.wr_mr = mr2;

		/* save changed mode registers */
		dart_sv_reg.sv_mr1[port] = mr1;
		dart_sv_reg.sv_mr2[port] = mr2;
d809 1
a809 1
	if (port = DART_PORT(dev) > 1) {
d812 1
a812 1
	sc = (struct dartsoftc *) dart_cd.cd_devs[0];
d814 1
a814 1
	s = spldart();
d835 1
a835 1
		if (port == 0) {
d845 1
a846 1
		simple_unlock(&dart->t_lock);
d872 2
a873 1
	if (port = DART_PORT(dev) > 1) {
a879 2

	s = spldart();
d881 1
a881 1
	splx(s);
d946 1
a946 1
	ptaddr = (union dart_pt_io *) addr + port;
d963 1
a963 1
		if ((tp->t_state & (TS_ISOPEN|TS_WOPEN)) == 0) {
d1003 2
d1008 1
a1008 2
#if 0 /* XXX ??? */
					else if (tp->t_flags & (RAW|LITOUT|PASS8)) /*CS8*/
a1009 1
#endif 
d1014 1
d1054 1
a1054 1
	out:
d1084 1
d1086 1
a1086 1

d1092 1
a1092 1
			return 0;
d1158 2
a1159 1
	/* Nothing to do */
d1178 1
a1178 1
	ptaddr = (union dart_pt_io *) addr + port;
d1184 1
a1184 1
	s = spldart();
d1241 1
a1241 1
	s = spldart();
d1247 1
a1247 1
	ptaddr = (union dart_pt_io *) addr + port;
@


1.2
log
@callout.h is gone
@
text
@d49 6
a54 3
#if DDB
   #include <machine/db_machdep.h>		/* for details on entering kdb */
extern unsigned char ddb_break_mode, ddb_break_char;
d58 2
a59 1
   #define dprintf(stuff) /*printf stuff*/
d65 3
a67 3
   struct tty  *tty;
	u_char	   dart_swflags;
   struct simplelock t_lock;
d71 8
a78 8
   struct device        sc_dev;
   struct evcnt         sc_intrcnt;
   union  dartreg       *dart_reg;
   struct dart_info     sc_dart[2];
   struct intrhand      sc_ih;
   int                  sc_flags;
   int                  sc_ipl;
   int                  sc_vec;
d123 16
a138 16
   0,           /* 0 baud, special HUP condition */
   NOBAUD,         /* 50 baud, not implemented */
   BD75,           /* 75 baud */
   BD110,       /* 110 baud */
   BD134,       /* 134.5 baud */
   BD150,       /* 150 baud */
   NOBAUD,         /* 200 baud, not implemented */
   BD300,       /* 300 baud */
   BD600,       /* 600 baud */
   BD1200,         /* 1200 baud */
   BD1800,         /* 1800 baud */
   BD2400,         /* 2400 baud */
   BD4800,         /* 4800 baud */
   BD9600,         /* 9600 baud */
   BD19200,        /* 19200 baud */
   NOBAUD       /* 38400 baud, not implemented */
d141 2
a142 1
struct tty * darttty(dev)
d145 5
a149 5
   int port;
   struct dartsoftc *sc;
   sc = (struct dartsoftc *) dart_cd.cd_devs[0];
   port = DART_PORT(dev);
   return sc->sc_dart[port].tty;
d157 13
a169 13
   struct cfdata *cf = vcf;
   struct confargs *ca = args;
   union dartreg *addr;

   /* Don't match if wrong cpu */
   if (cputyp != CPU_188) return (0);
   ca->ca_vaddr = ca->ca_paddr; /* 1:1 */
   addr = (union dartreg *)ca->ca_vaddr;
   if (badvaddr(addr, 2) <= 0) {
      printf("==> syscon: failed address check.\n");
      return (0);
   }
   return (1);
d178 69
a246 87
   struct dartsoftc *sc = (struct dartsoftc *)self;
   struct confargs *ca = aux;
   int i;
   union dartreg *addr; /* pointer to DUART regs */
   union dart_pt_io *ptaddr; /* pointer to port regs */
   int port;       /* port index */

   /* set up dual port memory and registers and init*/
   sc->dart_reg = (union dartreg *)ca->ca_vaddr;
   sc->sc_ipl = ca->ca_ipl; 
   ca->ca_vec = SYSCV_SCC; /* hard coded vector */
   sc->sc_vec = ca->ca_vec; 

   addr = sc->dart_reg;

   /* save standard initialization */
   dart_sv_reg.sv_mr1[A_PORT] = PARDIS | RXRTS | CL8;
   dart_sv_reg.sv_mr2[A_PORT] = /* TXCTS | */ SB1;
   dart_sv_reg.sv_csr[A_PORT] = BD9600;
   dart_sv_reg.sv_cr[A_PORT]  = TXEN | RXEN;

   dart_sv_reg.sv_mr1[B_PORT] = PARDIS | RXRTS | CL8;
   dart_sv_reg.sv_mr2[B_PORT] = /* TXCTS | */ SB1;
   dart_sv_reg.sv_csr[B_PORT] = BD9600;
   dart_sv_reg.sv_cr[B_PORT]  = TXEN | RXEN;

   dart_sv_reg.sv_acr  = BDSET2 | CCLK16 | IPDCDIB | IPDCDIA;

   /* Start out with Tx and RX interrupts disabled */
   /* Enable input port change interrupt */
   dart_sv_reg.sv_imr  = IIPCHG;

   dprintf(("dartattach: resetting port A\n"));

   /* reset port a */
   addr->write.wr_cra  = RXRESET     | TXDIS | RXDIS;
   DELAY_CR;
   addr->write.wr_cra  = TXRESET     | TXDIS | RXDIS;
   DELAY_CR;
   addr->write.wr_cra  = ERRRESET    | TXDIS | RXDIS;
   DELAY_CR;
   addr->write.wr_cra  = BRKINTRESET | TXDIS | RXDIS;
   DELAY_CR;
   addr->write.wr_cra  = MRRESET     | TXDIS | RXDIS;

   dprintf(("dartattach: resetting port B\n"));

   /* reset port b */
   addr->write.wr_crb  = RXRESET     | TXDIS | RXDIS;
   DELAY_CR;
   addr->write.wr_crb  = TXRESET     | TXDIS | RXDIS;
   DELAY_CR;
   addr->write.wr_crb  = ERRRESET    | TXDIS | RXDIS;
   DELAY_CR;
   addr->write.wr_crb  = BRKINTRESET | TXDIS | RXDIS;
   DELAY_CR;
   addr->write.wr_crb  = MRRESET     | TXDIS | RXDIS;
   DELAY_CR;

   /* initialize ports */
   for (port = 0, ptaddr = (union dart_pt_io *)addr;
       port < MAXPORTS;
       port++, ptaddr++) {
      dprintf(("dartattach: init port %c\n", 'A' + port));
      ptaddr->write.wr_mr  = dart_sv_reg.sv_mr1[port];
      ptaddr->write.wr_mr  = dart_sv_reg.sv_mr2[port];
      ptaddr->write.wr_csr = dart_sv_reg.sv_csr[port];
      ptaddr->write.wr_cr  = dart_sv_reg.sv_cr [port];
   }

   dprintf(("dartattach: init common regs\n"));

   /* initialize common register of a DUART */
   addr->write.wr_oprset = OPDTRA | OPRTSA | OPDTRB | OPRTSB;

   addr->write.wr_ctur  = SLCTIM>>8;
   addr->write.wr_ctlr  = SLCTIM & 0xFF;
   addr->write.wr_acr  = dart_sv_reg.sv_acr;
   addr->write.wr_imr  = dart_sv_reg.sv_imr;
   addr->write.wr_opcr = OPSET;
   addr->write.wr_ivr = sc->sc_vec;

   /* enable interrupts */
   sc->sc_ih.ih_fn = dartintr;
   sc->sc_ih.ih_arg = sc;
   sc->sc_ih.ih_ipl = ca->ca_ipl;
   sc->sc_ih.ih_wantframe = 0;
d248 20
a267 2
   intr_establish(ca->ca_vec, &sc->sc_ih);
   evcnt_attach(&sc->sc_dev, "intr", &sc->sc_intrcnt);
d278 7
a284 56
   dev_t dev;
   struct dartsoftc *sc;
   int s, cnt;
   union dart_pt_io *ptaddr;
   union dartreg *addr;
   int port;
   int c;

   dev = tp->t_dev;
   port = DART_PORT(dev);
   sc = (struct dartsoftc *) dart_cd.cd_devs[0];

   if ((tp->t_state & TS_ISOPEN) == 0)
      return;

   addr = sc->dart_reg;
   ptaddr = (union dart_pt_io *)addr + port;

   if (tp->t_state & (TS_TIMEOUT|TS_BUSY|TS_TTSTOP))
      goto out;

   /*
   if (tp->t_outq.c_cc <= TTLOWAT(tp)) {
      ttwakeup(tp);
   }
   */

   if (tp->t_outq.c_cc != 0) {

      tp->t_state |= TS_BUSY;

      /* load transmitter until it is full */
      while (ptaddr->read.rd_sr & TXRDY) {
         c = getc(&tp->t_outq);

         if (tp->t_flags & CS8 || c <= 0177) {

            dprintf(("dartstart: writing char \"%c\" (0x%02x)\n",
                    c & 0xff, c % 0xff));
            ptaddr->write.wr_tb = c & 0xff;

            dprintf(("dartstart: enabling Tx int\n"));
            if (port == A_PORT)
               dart_sv_reg.sv_imr = dart_sv_reg.sv_imr | ITXRDYA;
            else
               dart_sv_reg.sv_imr = dart_sv_reg.sv_imr | ITXRDYB;
            addr -> write.wr_imr = dart_sv_reg.sv_imr;
         } else {
            tp->t_state &= ~TS_BUSY;
            dprintf(("dartxint: timing out char \"%c\" (0x%02x)\n",
                    c & 0xff, c % 0xff));
            ttrstrt(tp);
            tp->t_state |= TS_TIMEOUT;
         }
      }
   }
d286 54
a339 2
   out:
   return;
d350 1
a350 1
   int s;
d352 5
a356 5
   if (tp->t_state & TS_BUSY) {
      if ((tp->t_state & TS_TTSTOP) == 0)
         tp->t_state |= TS_FLUSH;
   }
   return 0;
d384 23
a406 23
   union dartreg *addr;
   int port;
   unsigned int dcdstate;
   int newflags = 0;
   struct dart_info *dart;
   struct dartsoftc *sc;

   if (port = DART_PORT(dev) > 1) {
      return (ENODEV);
   }
   sc = (struct dartsoftc *) dart_cd.cd_devs[0];
   dart = &sc->sc_dart[port];
   addr = sc->dart_reg;

   /* special case: set or clear break */
   if (flags & TIOCSBRK) {
      dartbreak(port, 1);
      flags &= ~TIOCSBRK;
   }
   if (flags & TIOCCBRK) {
      dartbreak(port, 0);
      flags &= ~TIOCCBRK;
   }
d408 2
a409 2
   HANDLE_FLAG(TIOCM_DTR, port, OPDTRA, OPDTRB);
   HANDLE_FLAG(TIOCM_RTS, port, OPRTSA, OPRTSB);
d412 6
a417 6
   if (flags) {
      printf("dartmctl: currently only BRK, DTR and RTS supported\n");
      printf("dartmctl: op=%s flags left = 0x%b\n",
             HOW2STR(how), flags, FLAGSTRING);
      panic("dartmctl");
   }
d419 18
a436 2
   dprintf(("dartmctl: action=%s flags=0x%x\n",
           HOW2STR(how), newflags));
d438 3
a440 19
   switch (how) {
      case DMSET:
         addr->write.wr_oprset = newflags;
         addr->write.wr_oprreset = ~newflags;
         break;
      case DMBIS:
         addr->write.wr_oprset = newflags;
         break;
      case DMBIC:
         addr->write.wr_oprreset = newflags;
         break;
      case DMGET:
         panic("dartmctl: DMGET not supported (yet)\n");
         break;
   }

   /* read DCD input */
   /* input is inverted at port */
   dcdstate = !(addr->read.rd_ip & ((port == A_PORT) ? IPDCDA : IPDCDB));
d442 1
a442 1
   dprintf(("dartmctl: DCD is %s\n", dcdstate ? "up" : "down"));
d444 1
a444 1
   return dcdstate;
d451 3
a453 1
dartbreak(dev_t dev, int state)
d455 5
a459 23
   union dartreg *addr;
   union dart_pt_io *ptaddr;
   int port;
   struct dart_info *dart;
   struct dartsoftc *sc;

   dprintf(("dartbreak: break %s\n", (state == 1) ? "on" : "off"));

   port = DART_PORT(dev);
   sc = (struct dartsoftc *) dart_cd.cd_devs[0];
   dart = &sc->sc_dart[port];
   addr = sc->dart_reg;

   ptaddr = (union dart_pt_io *) addr + port;

   if (state == 1) {
      /* the duart must be enabled with a dummy byte,
    to prevent the transmitter empty interrupt */
      ptaddr->write.wr_cr = BRKSTART|TXEN;
      ptaddr->write.wr_tb = 0;
   } else {
      ptaddr->write.wr_cr = BRKSTOP;   /* stop a break*/
   }
d461 19
a479 1
   return;
d482 7
a488 6
int dartioctl (dev, cmd, data, flag, p)
	dev_t dev;
	int cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d569 51
a619 130
   union dartreg *addr;
   union dart_pt_io *ptaddr;
   int flags;
   int port;
   int speeds;
   unsigned char mr1, mr2;
   struct dart_info *dart;
   struct dartsoftc *sc;
   dev_t dev;

   dprintf(("dartparam: setting param for dev %d\n", dev));

   dev = tp->t_dev;
   if (port = DART_PORT(dev) > 1) {
      return (ENODEV);
   }

   sc = (struct dartsoftc *) dart_cd.cd_devs[0];
   dart = &sc->sc_dart[port];
   addr = sc->dart_reg;
   ptaddr = (union dart_pt_io *) addr + port;
   tp->t_ispeed = t->c_ispeed;
   tp->t_ospeed = t->c_ospeed;
   tp->t_cflag = t->c_cflag;

   flags = tp->t_flags;

   /* Reset to make global changes*/
   /* disable Tx and Rx */
   dprintf(("dartparam: disabling Tx and Rx int\n"));

   if (port == A_PORT)
      dart_sv_reg.sv_imr = dart_sv_reg.sv_imr & ~(ITXRDYA | IRXRDYA);
   else
      dart_sv_reg.sv_imr = dart_sv_reg.sv_imr & ~(ITXRDYB | IRXRDYB);
   addr -> write.wr_imr = dart_sv_reg.sv_imr;

   /* hang up on zero baud rate */
   if (tp->t_ispeed == 0) {
      dprintf(("dartparam: ispeed == 0 -> HUP\n"));
      dartmctl(tp, HUPCL, DMSET);
      return;
   } else {
      /* set baudrate */
      speeds = dart_speeds[(unsigned char)tp->t_ispeed];
      if (speeds == NOBAUD)
         speeds = dart_sv_reg.sv_csr[port];
      ptaddr->write.wr_csr = speeds;
      dart_sv_reg.sv_csr[port] = speeds;
      dprintf(("dartparam: baudrate set param = %d\n", speeds));
   }

   /* get saved mode registers and clear set up parameters */
   mr1 = dart_sv_reg.sv_mr1[port];
   mr1 &= ~(CLMASK | PARTYPEMASK | PARMODEMASK);

   mr2 = dart_sv_reg.sv_mr2[port];
   mr2 &= ~SBMASK;

   /* set up character size */
   if (flags & CS8) {
      mr1 |= CL8;
      dprintf(("dartparam: PASS8\n"));
   } else if (tp->t_ispeed == B134) {
      mr1 |= CL6;
      dprintf(("dartparam: CS6\n"));
   } else {
      mr1 |= CL7;
      dprintf(("dartparam: CS7\n"));
   }

   /* set up stop bits */
   if (tp->t_ospeed == B110) {
      mr2 |= SB2;
      dprintf(("dartparam: two stop bits\n"));
   } else {
      mr2 |= SB1;
      dprintf(("dartparam: one stop bit\n"));
   }

   /* set up parity */
   if (((flags & PARENB) != PARENB) &&
       (flags & PARENB)) {
      mr1 |= PAREN;
      if (flags & PARODD) {
         mr1 |= ODDPAR;
         dprintf(("dartparam: odd parity\n"));
      } else {
         mr1 |= EVENPAR;
         dprintf(("dartparam: even parity\n"));
      }
   } else {
      mr1 |= PARDIS;
      dprintf(("dartparam: no parity\n"));
   }

   if ((dart_sv_reg.sv_mr1[port] != mr1)
       || (dart_sv_reg.sv_mr2[port] != mr2)) {
      /* write mode registers to duart */
      ptaddr->write.wr_cr = MRRESET;
      ptaddr->write.wr_mr = mr1;
      ptaddr->write.wr_mr = mr2;

      /* save changed mode registers */
      dart_sv_reg.sv_mr1[port] = mr1;
      dart_sv_reg.sv_mr2[port] = mr2;
   }

   /* enable transmitter? */
   if (tp->t_state & TS_BUSY) {
      dprintf(("dartparam: reenabling Tx int\n"));

      if (port == A_PORT)
         dart_sv_reg.sv_imr = dart_sv_reg.sv_imr | ITXRDYA;
      else
         dart_sv_reg.sv_imr = dart_sv_reg.sv_imr | ITXRDYB;
      addr -> write.wr_imr = dart_sv_reg.sv_imr;
   } else {
      dprintf(("dartparam: not enabling Tx\n"));
   }

   /* re-enable the receiver */
   dprintf(("dartparam: reenabling Rx int\n"));

   DELAY_CR;
   if (port == A_PORT)
      dart_sv_reg.sv_imr = dart_sv_reg.sv_imr | IRXRDYA;
   else
      dart_sv_reg.sv_imr = dart_sv_reg.sv_imr | IRXRDYB;
   addr -> write.wr_imr = dart_sv_reg.sv_imr;
d621 80
a700 1
   return 0;
d705 31
a735 31
   struct dartsoftc *sc;
   unsigned int ip;
   unsigned int ipcr;
{
   unsigned int dcdstate;
   struct tty *tp;
   int port;
   struct dart_info *dart;

   dprintf(("dartmodemtrans: ip=0x%x ipcr=0x%x\n",
           ip, ipcr));

   /* input is inverted at port!!! */
   if (ipcr & IPCRDCDA) {
      port = A_PORT;
      dcdstate = !(ip & IPDCDA);
   } else if (ipcr & IPCRDCDB) {
      port = B_PORT;
      dcdstate = !(ip & IPDCDB);
   } else {
      printf("dartmodemtrans: unknown transition:\n");
      printf("dartmodemtrans: ip=0x%x ipcr=0x%x\n",
             ip, ipcr);
      panic("dartmodemtrans");
   }
   dart = &sc->sc_dart[port];
   tp = dart->tty;

   dprintf(("dartmodemtrans: tp=0x%x new DCD state: %s\n",
           tp, dcdstate ? "UP" : "DOWN"));
   (void) ttymodem(tp, dcdstate);
d738 2
a739 1
int dartopen (dev, flag, mode, p)
d745 53
a797 53
   int s, port;
   struct dart_info *dart;
   struct dartsoftc *sc;
   struct tty *tp;

   if (port = DART_PORT(dev) > 1) {
      return (ENODEV);
   }
   sc = (struct dartsoftc *) dart_cd.cd_devs[0];
   dart = &sc->sc_dart[port];
   s = spldart();

   if (dart->tty) {
      tp = dart->tty;
   } else {
      tp = dart->tty = ttymalloc();
      simple_lock_init(&dart->t_lock);
   }

   simple_lock(&dart->t_lock);
   tp->t_oproc = dartstart;
   tp->t_param = dartparam;
   tp->t_dev = dev;

   if ((tp->t_state & TS_ISOPEN) == 0) {
      ttychars(tp);
      tp->t_iflag = TTYDEF_IFLAG;
      tp->t_oflag = TTYDEF_OFLAG;
      tp->t_lflag = TTYDEF_LFLAG;
      tp->t_ispeed = tp->t_ospeed = B9600;
      dartparam(tp, &tp->t_termios);
      if (port == 0) {
         /* console is 8N1 */
         tp->t_cflag = (CREAD | CS8 | HUPCL);
      } else {
         tp->t_cflag = TTYDEF_CFLAG;
      }
      ttsetwater(tp);
      (void)dartmctl(dev, TIOCM_DTR | TIOCM_RTS, DMSET);
      tp->t_state |= TS_CARR_ON;
   } else if (tp->t_state & TS_XCLUDE && p->p_ucred->cr_uid != 0) {
      splx(s);
      simple_unlock(&dart->t_lock);
      return (EBUSY);
   }
   /*
    * Reset the tty pointer, as there could have been a dialout
    * use of the tty with a dialin open waiting.
    */
   tp->t_dev = dev;
   simple_unlock(&dart->t_lock);
   splx(s);
   return ((*linesw[tp->t_line].l_open)(dev, tp));
d800 2
a801 1
int dartclose (dev, flag, mode, p)
d807 18
a824 18
   int unit, channel;
   struct tty *tp;
   struct dart_info *dart;
   struct dartsoftc *sc;
   int s, port;

   if (port = DART_PORT(dev) > 1) {
      return (ENODEV);
   }
   sc = (struct dartsoftc *) dart_cd.cd_devs[0];
   dart = &sc->sc_dart[port];
   tp = dart->tty;
   (*linesw[tp->t_line].l_close)(tp, flag);

   s = spldart();
   ttyclose(tp);
   splx(s);
   return 0;
d827 2
a828 1
int dartread (dev, uio, flag)
d833 15
a847 15
   int unit, port;
   struct tty *tp;
   struct dart_info *dart;
   struct dartsoftc *sc;

   if (port = DART_PORT(dev) > 1) {
      return (ENODEV);
   }
   sc = (struct dartsoftc *) dart_cd.cd_devs[0];
   dart = &sc->sc_dart[port];
   tp = dart->tty;

   if (!tp)
      return ENXIO;
   return ((*linesw[tp->t_line].l_read)(tp, uio, flag));
d850 2
a851 1
int dartwrite (dev, uio, flag)
d856 15
a870 15
   int port;
   struct tty *tp;
   struct dart_info *dart;
   struct dartsoftc *sc;

   if (port = DART_PORT(dev) > 1) {
      return (ENODEV);
   }
   sc = (struct dartsoftc *)dart_cd.cd_devs[0];
   dart = &sc->sc_dart[port];

   tp = dart->tty;
   if (!tp)
      return ENXIO;
   return ((*linesw[tp->t_line].l_write)(tp, uio, flag));
d878 47
a924 47
   union dartreg *addr;
   union dart_pt_io *ptaddr;
   struct tty *tp;
   unsigned char data, sr;
   struct dart_info *dart;

   dart = &sc->sc_dart[port];
   addr = sc->dart_reg;

   /* read status reg */
   ptaddr = (union dart_pt_io *) addr + port;

   dprintf(("dartrint: Rx int dev %d\n", dev));

   tp = dart->tty;

   dprintf(("dartrint: ptaddr = 0x%08x from uart at 0x%08x\n",
           ptaddr, addr));

   while ((sr = ptaddr->read.rd_sr) & RXRDY) {
      dprintf(("dartrint: sr = 0x%08x\n", sr));

      data = ptaddr->read.rd_rb; /* read data and reset receiver */

      dprintf(("dartrint: read char \"%c\" (0x%02x) tp = 0x%x\n",
              data, data, tp));

      if ((tp->t_state & (TS_ISOPEN|TS_WOPEN)) == 0){
         return;
      }

      if (sr & RBRK) {
         dprintf(("dartrint: BREAK detected\n"));
         /*
         data = tp->t_breakc;
         ttyinput(data, tp);
         */
         /* clear break state */
         ptaddr->write.wr_cr = BRKINTRESET;
         DELAY_CR;
         ptaddr->write.wr_cr = ERRRESET;

#if DDB_XXX
         if (ddb_break_mode & DDB_ENTER_BREAK) {
            dprintf(("dartrint: break detected - entering debugger\n"));
            gimmeabreak();
         }
d926 18
a943 18
      } else {
         if (sr & (FRERR|PERR|ROVRN)) { /* errors */
            if (sr & ROVRN)
               printf("dart0: receiver overrun port %c\n", 'A' + port);
            if (sr & FRERR)
               printf("dart0: framing error port %c\n", 'A' + port);
            if (sr & PERR)
               printf("dart0: parity error port %c\n", 'A' + port);
            dprintf(("dartrint: error received\n"));
            /* clear error state */
            ptaddr->write.wr_cr = ERRRESET;
         } else {
            /* no errors */
#if DDB_XXX
            if ((ddb_break_mode & DDB_ENTER_CHAR) && (ddb_break_char == data)) {
               dprintf(("dartrint: ddb_break_char detected - entering debugger\n"));
               gimmeabreak();
            } else
d945 3
a947 3
            {
               if (tp->t_ispeed == B134) /* CS6 */
                  data &= 077;
d949 2
a950 2
               else if (tp->t_flags & (RAW|LITOUT|PASS8)) /*CS8*/
                  ;
d952 8
a959 8
               else
                  data &= 0177; /* CS7 */
               ttyinput(data, tp);
            }
         }
      }
   }
   dprintf(("dartrint: ready\n"));
d967 4
a970 4
   struct tty *tp;
   struct dart_info *dart;
   union dartreg *addr;
   dev_t dev;
d972 2
a973 2
   dart = &sc->sc_dart[port];
   addr = sc->dart_reg;
d975 1
a975 1
   tp = dart->tty;
d977 1
a977 1
   simple_lock(&dart->t_lock);
d979 2
a980 2
   if ((tp->t_state & (TS_ISOPEN|TS_WOPEN))==0)
      goto out;
d982 2
a983 2
   if (tp->t_state & TS_FLUSH)
      tp->t_state &= ~TS_FLUSH;
d985 11
a995 11
   if (tp->t_state & TS_BUSY) {
      tp->t_state &= ~TS_BUSY;
      dprintf(("dartxint: starting output\n"));
      dartstart(tp);
      if (tp->t_state & TS_BUSY) {
         dprintf(("dartxint: ready - Tx left enabled\n"));
         simple_unlock(&dart->t_lock);
         return;
      }
   }
   out:
d997 5
a1001 5
   /* disable transmitter */
   if (port == 0)
      dart_sv_reg.sv_imr = dart_sv_reg.sv_imr & ~ITXRDYA;
   else
      dart_sv_reg.sv_imr = dart_sv_reg.sv_imr & ~ITXRDYB;
d1003 1
a1003 1
   addr->write.wr_imr = dart_sv_reg.sv_imr;
d1005 1
a1005 1
   simple_unlock(&dart->t_lock);
d1007 1
a1007 1
   dprintf(("dartxint: ready - Tx disabled\n"));
d1009 1
a1009 1
   return;
d1016 51
a1066 51
   unsigned char isr;
   unsigned char sr;
   int port;
   union dartreg *addr;

   /* read interrupt status register and mask with imr */
   addr = sc->dart_reg;

   isr = addr->read.rd_isr;
   isr &= dart_sv_reg.sv_imr;

   if (isr) {     /* interrupt from this duart */
      if (isr & IIPCHG) {
         unsigned int ip = addr->read.rd_ip;
         unsigned int ipcr = addr->read.rd_ipcr;
         dartmodemtrans(sc, ip, ipcr);
         return 0;
      }

      if (isr & (IRXRDYA | ITXRDYA))
         port = 0;
      else
         if (isr & (IRXRDYB | ITXRDYB))
         port = 1;
      else {
         printf("dartintr: spurious interrupt, isr 0x%08x\n", isr);
         panic("dartintr");
      }

      dprintf(("dartintr: interrupt from port %d, isr 0x%08x\n",
              port, isr));

      if (isr & (IRXRDYA | IRXRDYB)) {
         dprintf(("dartintr: Rx interrupt\n"));
         dartrint(sc, port);
      }
      if (isr & (ITXRDYA | ITXRDYB)) {
         dprintf(("dartintr: Tx interrupt\n"));
         dartxint(sc, port);
      }
      if (((port == A_PORT) && (isr & IBRKA))
          || ((port == B_PORT) && (isr & IBRKB))) {
         union dart_pt_io *ptaddr =
         (union dart_pt_io *)addr + port;

         dprintf(("dartintr: clearing end of BREAK state\n"));
         ptaddr->write.wr_cr = BRKINTRESET;
      }
   }
   dprintf(("dartintr: ready\n"));
   return 1;
d1078 14
a1091 14
   int maj;
   
   if (cputyp != CPU_188){
      cp->cn_pri = CN_DEAD;
      return 0;
   }
   /* locate the major number */
   for (maj = 0; maj < nchrdev; maj++)
      if (cdevsw[maj].d_open == dartopen)
         break;

   cp->cn_dev = makedev(maj, 0);
   cp->cn_pri = CN_NORMAL;
   return (1);
d1098 1
a1098 1
   /* Nothing to do */
d1106 24
a1129 38
   union dartreg *addr;
   union dart_pt_io *ptaddr;
   m88k_psr_type psr;

   addr = (union dartreg *) MVME188_DUART;

   ptaddr = (union dart_pt_io *) addr + ((dev & 1) ? 1 : 0);

   psr = disable_interrupts_return_psr();

   /* Assume first port initialized if we get here. */
   /* Assume the bug initializes the port */

   /* inhibit interrupts on the chip */
   addr->write.wr_imr = dart_sv_reg.sv_imr & ~ITXRDYA;
   /* make sure transmitter is enabled */
   DELAY_CR;
   ptaddr->write.wr_cr = TXEN;

   /* If the character is a line feed(\n) */
   /* then follow it with carriage return (\r) */
   for (;;) {
      while (!(ptaddr->read.rd_sr & TXRDY))
         ;
      ptaddr->write.wr_tb = c;
      if (c != '\n')
         break;
      c = '\r';
   }

   /* wait for transmitter to empty */
   while (!(ptaddr->read.rd_sr & TXEMT))
      ;

   /* restore the previous state */
   addr->write.wr_imr = dart_sv_reg.sv_imr;
   DELAY_CR;
   ptaddr->write.wr_cr = dart_sv_reg.sv_cr[0];
d1131 16
a1146 1
   set_psr(psr);
d1148 15
a1162 1
   return;
d1169 8
a1176 47
   union dartreg  *addr;      /* pointer to DUART regs */
   union dart_pt_io  *ptaddr; /* pointer to port regs */
   unsigned char   sr;            /* status reg of port a/b */
   int c;          /* received character */
   m88k_psr_type psr;
   char buf[] = "char x";

   psr = disable_interrupts_return_psr();

   addr = (union dartreg *) DART_BASE;
   ptaddr = (union dart_pt_io *) addr + ((dev & 1) ? 1 : 0);

   /* enable receiver */
   ptaddr->write.wr_cr = RXEN;

   do {
      /* read status reg */
      sr = ptaddr->read.rd_sr;

      /* receiver interrupt handler*/
      if (sr & RXRDY) {
         /* read character from port */
         c = ptaddr->read.rd_rb;

         /* check break condition */
         if (sr & RBRK) {
            /* clear break state */
            ptaddr->write.wr_cr = BRKINTRESET;
            DELAY_CR;
            ptaddr->write.wr_cr = ERRRESET;
            set_psr(psr);
            return c;
         }

         if (sr & (FRERR|PERR|ROVRN)) {
            /* clear error state */
            ptaddr->write.wr_cr = ERRRESET;
            DELAY_CR;
            ptaddr->write.wr_cr = BRKINTRESET;
         } else {
            buf[5] = (char) c;

            set_psr(psr);
            return (c & 0x7f);
         }
      }
   } while (-1);
d1178 37
a1214 1
   set_psr(psr);
d1216 22
a1237 1
   return -1;
@


1.1
log
@adding support for MVME188 and MVME197.  Plus 32bit if_ie.
@
text
@a27 1
#include <sys/callout.h>
@


1.1.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d28 1
d50 3
a52 6
#if defined(DDB)
#include <machine/db_machdep.h>		/* for details on entering kdb */
#define DDB_ENTER_BREAK 0x1
#define DDB_ENTER_CHAR  0x2
unsigned char ddb_break_mode = DDB_ENTER_BREAK;
unsigned char ddb_break_char = 0;
d55 2
a56 3
#ifdef DEBUG
   int dart_debug = 1;
   #define dprintf(stuff) if (dart_debug) printf stuff
d62 3
a64 3
	struct tty		*tty;
	u_char			dart_swflags;
	struct simplelock	t_lock;
d68 8
a75 9
	struct device		sc_dev;
	struct evcnt		sc_intrcnt;
	union  dartreg		*dart_reg;
        union  dart_pt_io	*port_reg[2];
	struct dart_info	sc_dart[2];
	struct intrhand		sc_ih;
	int			sc_flags;
	int			sc_ipl;
	int			sc_vec;
a88 1
int dart_cons = -1;
d93 1
a93 1
void dartcnputc __P((dev_t dev, char c));
d101 1
a101 1
int dartintr __P((void *));
d118 18
a135 20
struct dart_s {
	int kspeed;
	int dspeed;
} dart_speeds[] = {
	{B0,		0	},	/* 0 baud, special HUP condition */
        {B50,		NOBAUD	},	/* 50 baud, not implemented */
	{B75,		BD75	},	/* 75 baud */
	{B110,		BD110	},	/* 110 baud */
	{B134,		BD134	},	/* 134.5 baud */
	{B150,		BD150	},	/* 150 baud */
	{B200,		NOBAUD	},	/* 200 baud, not implemented */
	{B300,		BD300	},	/* 300 baud */
	{B600,		BD600	},	/* 600 baud */
	{B1200,		BD1200	},	/* 1200 baud */
	{B1800,		BD1800	},	/* 1800 baud */
	{B2400,		BD2400	},	/* 2400 baud */
	{B4800,		BD4800	},	/* 4800 baud */
	{B9600,		BD9600	},	/* 9600 baud */
	{B19200,	BD19200	},	/* 19200 baud */
	{0xFFFF,	NOBAUD	},	/* anything more is uncivilized */
d138 2
a139 16
int
dart_speed(speed)
	int speed;
{
	struct dart_s *ds = dart_speeds;
	while (ds->kspeed != 0xFFFF) {
		if (ds->kspeed == speed) 
			return ds->dspeed;
		ds++;
	}
	return NOBAUD;
}

struct tty* 
darttty(dev)
	dev_t dev;
d141 5
a145 5
	int port;
	struct dartsoftc *sc;
	sc = (struct dartsoftc *) dart_cd.cd_devs[0];
	port = DART_PORT(dev);
	return sc->sc_dart[port].tty;
d150 2
a151 2
	struct device *parent;
	void *vcf, *args;
d153 13
a165 12
	struct confargs *ca = args;
	union dartreg *addr;

	/* Don't match if wrong cpu */
	if (cputyp != CPU_188) return (0);
	ca->ca_vaddr = ca->ca_paddr; /* 1:1 */
	addr = (union dartreg *)ca->ca_vaddr;
	if (badvaddr(addr, 2) <= 0) {
		printf("==> dart: failed address check.\n");
		return (0);
	}
	return (1);
d170 91
a260 44
	struct device *parent;
	struct device *self;
	void *aux;
{
	struct dartsoftc *sc = (struct dartsoftc *)self;
	struct confargs *ca = aux;
	union dartreg *addr; /* pointer to DUART regs */
	union dart_pt_io *ptaddr; /* pointer to port regs */
	int port;	/* port index */

	/* set up dual port memory and registers and init*/
	sc->dart_reg = (union dartreg *)ca->ca_vaddr;
        ptaddr = (union  dart_pt_io *)ca->ca_vaddr;
	sc->port_reg[A_PORT] = ptaddr;
	ptaddr++;
	sc->port_reg[B_PORT] = ptaddr;
	sc->sc_ipl = ca->ca_ipl = IPL_TTY; /* always... hard coded ipl */
	sc->sc_dart[A_PORT].tty = NULL;
	sc->sc_dart[B_PORT].tty = NULL;
	ca->ca_vec = SYSCV_SCC;	/* hard coded vector */
	sc->sc_vec = ca->ca_vec; 

	addr = sc->dart_reg;

	/* save standard initialization */
	dart_sv_reg.sv_mr1[A_PORT] = PARDIS | RXRTS | CL8;
	dart_sv_reg.sv_mr2[A_PORT] = /* TXCTS | */ SB1;
	dart_sv_reg.sv_csr[A_PORT] = BD9600;
	dart_sv_reg.sv_cr[A_PORT]  = TXEN | RXEN;

	dart_sv_reg.sv_mr1[B_PORT] = PARDIS | RXRTS | CL8;
	dart_sv_reg.sv_mr2[B_PORT] = /* TXCTS | */ SB1;
	dart_sv_reg.sv_csr[B_PORT] = BD9600;
	dart_sv_reg.sv_cr[B_PORT]  = TXEN | RXEN;

	dart_sv_reg.sv_acr  = BDSET2 | CCLK16 | IPDCDIB | IPDCDIA;

	/* Start out with Tx and RX interrupts disabled */
	/* Enable input port change interrupt */
	dart_sv_reg.sv_imr  = IIPCHG;
	
	if (dart_cons >= 0) {
		printf(" console (tty%s) ", dart_cons == 0 ? "a" : "b");
	}
d262 2
a263 58
	dprintf(("\ndartattach: resetting port A\n"));

	/* reset port a */
	addr->write.wr_cra  = RXRESET     | TXDIS | RXDIS;
	DELAY_CR;
	addr->write.wr_cra  = TXRESET     | TXDIS | RXDIS;
	DELAY_CR;
	addr->write.wr_cra  = ERRRESET    | TXDIS | RXDIS;
	DELAY_CR;
	addr->write.wr_cra  = BRKINTRESET | TXDIS | RXDIS;
	DELAY_CR;
	addr->write.wr_cra  = MRRESET     | TXDIS | RXDIS;

	dprintf(("dartattach: resetting port B\n"));

	/* reset port b */
	addr->write.wr_crb  = RXRESET     | TXDIS | RXDIS;
	DELAY_CR;
	addr->write.wr_crb  = TXRESET     | TXDIS | RXDIS;
	DELAY_CR;
	addr->write.wr_crb  = ERRRESET    | TXDIS | RXDIS;
	DELAY_CR;
	addr->write.wr_crb  = BRKINTRESET | TXDIS | RXDIS;
	DELAY_CR;
	addr->write.wr_crb  = MRRESET     | TXDIS | RXDIS;
	DELAY_CR;

	/* initialize ports */
	for (port = 0, ptaddr = (union dart_pt_io *)addr;
	    port < MAXPORTS;
	    port++, ptaddr++) {
		dprintf(("dartattach: init port %c\n", 'A' + port));
		ptaddr->write.wr_mr  = dart_sv_reg.sv_mr1[port];
		ptaddr->write.wr_mr  = dart_sv_reg.sv_mr2[port];
		ptaddr->write.wr_csr = dart_sv_reg.sv_csr[port];
		ptaddr->write.wr_cr  = dart_sv_reg.sv_cr [port];
	}

	dprintf(("dartattach: init common regs\n"));

	/* initialize common register of a DUART */
	addr->write.wr_oprset = OPDTRA | OPRTSA | OPDTRB | OPRTSB;

	addr->write.wr_ctur  = SLCTIM>>8;
	addr->write.wr_ctlr  = SLCTIM & 0xFF;
	addr->write.wr_acr  = dart_sv_reg.sv_acr;
	addr->write.wr_imr  = dart_sv_reg.sv_imr;
	addr->write.wr_opcr = OPSET;
	addr->write.wr_ivr = sc->sc_vec;

	/* enable interrupts */
	sc->sc_ih.ih_fn = dartintr;
	sc->sc_ih.ih_arg = sc;
	sc->sc_ih.ih_wantframe = 0;
	sc->sc_ih.ih_ipl = ca->ca_ipl;

	intr_establish(ca->ca_vec, &sc->sc_ih);
	evcnt_attach(&sc->sc_dev, "intr", &sc->sc_intrcnt);
d272 1
a272 1
	struct tty *tp;
d274 56
a329 33
	dev_t dev;
	struct dartsoftc *sc;
	int s, cc;
	union dart_pt_io *ptaddr;
	union dartreg *addr;
	int port;
	int c;

	dev = tp->t_dev;
	if((port = DART_PORT(dev)) > 1)
		return;
	
	sc = (struct dartsoftc *) dart_cd.cd_devs[0];
	addr = sc->dart_reg;
	ptaddr = sc->port_reg[port];

	if ((tp->t_state & TS_ISOPEN) == 0)
		return;
	
	s = spltty();
	
	if (tp->t_state & (TS_TIMEOUT |TS_BUSY | TS_TTSTOP))
		goto bail;
	
	if (tp->t_outq.c_cc <= tp->t_lowat) {
		if (tp->t_state & TS_ASLEEP) {
			tp->t_state &= ~TS_ASLEEP;
			wakeup((caddr_t)&tp->t_outq);
		}
		if (tp->t_outq.c_cc == 0)
			goto bail;
		selwakeup(&tp->t_wsel);
	}
d331 2
a332 45
	if (tp->t_state & (TS_TIMEOUT | TS_BUSY | TS_TTSTOP))
		goto bail;

	dprintf(("dartstart: dev(%d, %d)\n", major(dev), minor(dev)));

	if (port != dart_cons)
		dprintf(("dartstart: ptaddr = 0x%08x from uart at 0x%08x\n",
			 ptaddr, addr));

	if (tp->t_outq.c_cc != 0) {
		tp->t_state |= TS_BUSY;
		cc = tp->t_outq.c_cc;
		/* load transmitter until it is full */
		while (ptaddr->read.rd_sr & TXRDY) {
                        if(cc == 0)
				 break;
			c = getc(&tp->t_outq);
			cc--;
			if (tp->t_flags & CS8 || c <= 0177) {
				if (port != dart_cons)
					dprintf(("dartstart: writing char \"%c\" (0x%02x) to port %d\n",
						 c & 0xff, c & 0xff, port));
				ptaddr->write.wr_tb = c & 0xff;
				
				if (port != dart_cons)
					dprintf(("dartstart: enabling Tx int\n"));
				if (port == A_PORT)
					dart_sv_reg.sv_imr = dart_sv_reg.sv_imr | ITXRDYA;
				else
					dart_sv_reg.sv_imr = dart_sv_reg.sv_imr | ITXRDYB;
				addr->write.wr_imr = dart_sv_reg.sv_imr;

			} else {
				tp->t_state &= ~TS_BUSY;
				if (port != dart_cons)
					dprintf(("dartxint: timing out char \"%c\" (0x%02x)\n",
					 c & 0xff, c % 0xff));
				timeout_add(&tp->t_rstrt_to, 1);
				tp->t_state |= TS_TIMEOUT;
			}
		}
	}
bail:
	splx(s);
	return;
d340 2
a341 2
	struct tty *tp;
	int flag;
d343 1
a343 2
	int s;
	s = spltty();
d345 5
a349 6
	if (tp->t_state & TS_BUSY) {
		if ((tp->t_state & TS_TTSTOP) == 0)
			tp->t_state |= TS_FLUSH;
	}
	splx(s);
	return 0;
d373 27
a399 11
	dev_t dev;
	int flags;
	int how;
{
	union dartreg *addr;
	int port;
	unsigned int dcdstate;
	int newflags = 0;
	struct dart_info *dart;
	struct dartsoftc *sc;
	int s; 
d401 2
a402 6
	if ((port = DART_PORT(dev)) > 1) {
		return (ENODEV);
	}
	sc = (struct dartsoftc *) dart_cd.cd_devs[0];
	dart = &sc->sc_dart[port];
	addr = sc->dart_reg;
a403 1
	/* special case: set or clear break */
d405 6
a410 8
	if (flags & TIOCSBRK) {
		dartbreak(port, 1);
		flags &= ~TIOCSBRK;
	}
	if (flags & TIOCCBRK) {
		dartbreak(port, 0);
		flags &= ~TIOCCBRK;
	}
d412 2
a413 4
	s = spltty();
	
	HANDLE_FLAG(TIOCM_DTR, port, OPDTRA, OPDTRB);
	HANDLE_FLAG(TIOCM_RTS, port, OPRTSA, OPRTSB);
d415 19
a433 10
#if 0
	if (flags) {
		printf("dartmctl: currently only BRK, DTR and RTS supported\n");
		printf("dartmctl: op=%s flags left = 0x%b\n",
		       HOW2STR(how), flags, FLAGSTRING);
		panic("dartmctl");
	}
#endif 
	dprintf(("dartmctl: action=%s flags=0x%x\n",
		 HOW2STR(how), newflags));
d435 1
a435 15
	switch (how) {
	case DMSET:
		addr->write.wr_oprset = newflags;
		addr->write.wr_oprreset = ~newflags;
		break;
	case DMBIS:
		addr->write.wr_oprset = newflags;
		break;
	case DMBIC:
		addr->write.wr_oprreset = newflags;
		break;
	case DMGET:
		panic("dartmctl: DMGET not supported (yet)\n");
		break;
	}
d437 1
a437 7
	/* read DCD input */
	/* input is inverted at port */
	dcdstate = !(addr->read.rd_ip & ((port == A_PORT) ? IPDCDA : IPDCDB));

	dprintf(("dartmctl: DCD is %s\n", dcdstate ? "up" : "down"));
	splx(s);
	return dcdstate;
d444 1
a444 3
dartbreak(dev, state)
	dev_t dev;
	int state;
d446 7
a452 5
	union dartreg *addr;
	union dart_pt_io *ptaddr;
	int port;
	struct dart_info *dart;
	struct dartsoftc *sc;
d454 4
a457 1
	dprintf(("dartbreak: break %s\n", (state == 1) ? "on" : "off"));
d459 1
a459 4
	port = DART_PORT(dev);
	sc = (struct dartsoftc *) dart_cd.cd_devs[0];
	dart = &sc->sc_dart[port];
	addr = sc->dart_reg;
d461 8
a468 10
	ptaddr = sc->port_reg[port];
	
	if (state == 1) {
		/* the duart must be enabled with a dummy byte,
		to prevent the transmitter empty interrupt */
		ptaddr->write.wr_cr = BRKSTART|TXEN;
		ptaddr->write.wr_tb = 0;
	} else {
		ptaddr->write.wr_cr = BRKSTOP;	 /* stop a break*/
	}
d470 1
a470 1
	return;
d473 1
a473 2
int 
dartioctl (dev, cmd, data, flag, p)
a532 2
		if (dart_cons == port)
			dart->dart_swflags |= TIOCFLAG_SOFTCAR;
a540 2
		if (dart_cons == port)
			dart->dart_swflags |= TIOCFLAG_SOFTCAR;
d556 2
a557 2
	struct tty *tp;
	struct termios *t;
d559 130
a688 9
	union dartreg *addr;
	union dart_pt_io *ptaddr;
	int flags;
	int port;
	int speeds;
	unsigned char mr1, mr2;
	struct dart_info *dart;
	struct dartsoftc *sc;
	dev_t dev;
d690 1
a690 127
	dev = tp->t_dev;
	dprintf(("dartparam: setting param for dev(%d, %d)\n", major(dev), minor(dev)));
	if ((port = DART_PORT(dev)) > 1) {
		return (ENODEV);
	}

	sc = (struct dartsoftc *) dart_cd.cd_devs[0];
	dart = &sc->sc_dart[port];
	addr = sc->dart_reg;
	ptaddr = sc->port_reg[port];
	
	tp->t_ispeed = t->c_ispeed;
	tp->t_ospeed = t->c_ospeed;
	tp->t_cflag = t->c_cflag;

	flags = tp->t_flags;

	/* Reset to make global changes*/
	/* disable Tx and Rx */
	dprintf(("dartparam: disabling Tx and Rx int\n"));

	if (dart_cons == port) {
		dprintf(("dartparam: skipping console init\n"));
	} else {
		if (port == A_PORT)
			dart_sv_reg.sv_imr = dart_sv_reg.sv_imr & ~(ITXRDYA | IRXRDYA);
		else
			dart_sv_reg.sv_imr = dart_sv_reg.sv_imr & ~(ITXRDYB | IRXRDYB);
		addr -> write.wr_imr = dart_sv_reg.sv_imr;

		/* hang up on zero baud rate */
		if (tp->t_ispeed == 0) {
			dprintf(("dartparam: ispeed == 0 -> HUP\n"));
			dartmctl(tp, HUPCL, DMSET);
			return 0;
		} else {
			/* set baudrate */
			speeds = dart_speed(tp->t_ispeed);
			dprintf(("dartparam: speed 0x%x, baudrate %d\n", speeds, tp->t_ispeed));
			if (speeds == NOBAUD)
				speeds = dart_sv_reg.sv_csr[port];
			ptaddr->write.wr_csr = speeds;
			dart_sv_reg.sv_csr[port] = speeds;
			dprintf(("dartparam: baudrate set param = %d\n", speeds));
		}

		/* get saved mode registers and clear set up parameters */
		mr1 = dart_sv_reg.sv_mr1[port];
		mr1 &= ~(CLMASK | PARTYPEMASK | PARMODEMASK);

		mr2 = dart_sv_reg.sv_mr2[port];
		mr2 &= ~SBMASK;

		/* set up character size */
		if (flags & CS8) {
			mr1 |= CL8;
			dprintf(("dartparam: PASS8\n"));
		} else if (tp->t_ispeed == B134) {
			mr1 |= CL6;
			dprintf(("dartparam: CS6\n"));
		} else {
			mr1 |= CL7;
			dprintf(("dartparam: CS7\n"));
		}

		/* set up stop bits */
		if (tp->t_ospeed == B110) {
			mr2 |= SB2;
			dprintf(("dartparam: two stop bits\n"));
		} else {
			mr2 |= SB1;
			dprintf(("dartparam: one stop bit\n"));
		}

		/* set up parity */
		if (((flags & PARENB) != PARENB) &&
		    (flags & PARENB)) {
			mr1 |= PAREN;
			if (flags & PARODD) {
				mr1 |= ODDPAR;
				dprintf(("dartparam: odd parity\n"));
			} else {
				mr1 |= EVENPAR;
				dprintf(("dartparam: even parity\n"));
			}
		} else {
			mr1 |= PARDIS;
			dprintf(("dartparam: no parity\n"));
		}

		if ((dart_sv_reg.sv_mr1[port] != mr1)
		    || (dart_sv_reg.sv_mr2[port] != mr2)) {
			/* write mode registers to duart */
			ptaddr->write.wr_cr = MRRESET;
			ptaddr->write.wr_mr = mr1;
			ptaddr->write.wr_mr = mr2;

			/* save changed mode registers */
			dart_sv_reg.sv_mr1[port] = mr1;
			dart_sv_reg.sv_mr2[port] = mr2;
		}
	}

	/* enable transmitter? */
	if (tp->t_state & TS_BUSY) {
		dprintf(("dartparam: reenabling Tx int\n"));

		if (port == A_PORT)
			dart_sv_reg.sv_imr = dart_sv_reg.sv_imr | ITXRDYA;
		else
			dart_sv_reg.sv_imr = dart_sv_reg.sv_imr | ITXRDYB;
		addr -> write.wr_imr = dart_sv_reg.sv_imr;
	} else {
		dprintf(("dartparam: not enabling Tx\n"));
	}

	/* re-enable the receiver */
	dprintf(("dartparam: reenabling Rx int\n"));

	DELAY_CR;
	if (port == A_PORT)
		dart_sv_reg.sv_imr = dart_sv_reg.sv_imr | IRXRDYA;
	else
		dart_sv_reg.sv_imr = dart_sv_reg.sv_imr | IRXRDYB;
	addr -> write.wr_imr = dart_sv_reg.sv_imr;

	return 0;
d695 162
a856 164
	struct dartsoftc *sc;
	unsigned int ip;
	unsigned int ipcr;
{
	unsigned int dcdstate;
	struct tty *tp;
	int port;
	struct dart_info *dart;

	dprintf(("dartmodemtrans: ip=0x%x ipcr=0x%x\n",
		 ip, ipcr));

	/* input is inverted at port!!! */
	if (ipcr & IPCRDCDA) {
		port = A_PORT;
		dcdstate = !(ip & IPDCDA);
	} else if (ipcr & IPCRDCDB) {
		port = B_PORT;
		dcdstate = !(ip & IPDCDB);
	} else {
		printf("dartmodemtrans: unknown transition:\n");
		printf("dartmodemtrans: ip=0x%x ipcr=0x%x\n",
		       ip, ipcr);
		panic("dartmodemtrans");
	}
	dart = &sc->sc_dart[port];
	tp = dart->tty;

	dprintf(("dartmodemtrans: tp=0x%x new DCD state: %s\n",
		 tp, dcdstate ? "UP" : "DOWN"));
	(void) ttymodem(tp, dcdstate);
}

int 
dartopen (dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
{
	int s, port;
	struct dart_info *dart;
	struct dartsoftc *sc;
	struct tty *tp;

	if ((port = DART_PORT(dev)) > 1) {
		return (ENODEV);
	}
	sc = (struct dartsoftc *) dart_cd.cd_devs[0]; /* the only one */
	dart = &sc->sc_dart[port];
	s = spltty();

	if (dart->tty) {
		tp = dart->tty;
	} else {
		tp = dart->tty = ttymalloc();
		simple_lock_init(&dart->t_lock);
	}

	simple_lock(&dart->t_lock);
	tp->t_oproc = dartstart;
	tp->t_param = dartparam;
	tp->t_dev = dev;

	if ((tp->t_state & TS_ISOPEN) == 0) {
		ttychars(tp);
		tp->t_iflag = TTYDEF_IFLAG;
		tp->t_oflag = TTYDEF_OFLAG;
		tp->t_lflag = TTYDEF_LFLAG;
		tp->t_ispeed = tp->t_ospeed = B9600;
		dartparam(tp, &tp->t_termios);
		if (port == dart_cons) {
			/* console is 8N1 */
			tp->t_cflag = (CREAD | CS8 | HUPCL);
		} else {
			tp->t_cflag = TTYDEF_CFLAG;
		}
		ttsetwater(tp);
		(void)dartmctl(dev, TIOCM_DTR | TIOCM_RTS, DMSET);
		tp->t_state |= TS_CARR_ON;
	} else if (tp->t_state & TS_XCLUDE && p->p_ucred->cr_uid != 0) {
		simple_unlock(&dart->t_lock);
		splx(s);
		return (EBUSY);
	}
	/*
	 * Reset the tty pointer, as there could have been a dialout
	 * use of the tty with a dialin open waiting.
	 */
	tp->t_dev = dev;
	simple_unlock(&dart->t_lock);
	splx(s);
	return ((*linesw[tp->t_line].l_open)(dev, tp));
}

int 
dartclose (dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
{
	struct tty *tp;
	struct dart_info *dart;
	struct dartsoftc *sc;
	int port;

	if ((port = DART_PORT(dev)) > 1) {
		printf("dartclose: inavalid device dev(%d, %d)\n", major(dev), minor(dev)); 
		return (ENODEV);
	}
	sc = (struct dartsoftc *) dart_cd.cd_devs[0];
	dart = &sc->sc_dart[port];
	tp = dart->tty;
	(*linesw[tp->t_line].l_close)(tp, flag);
	ttyclose(tp);
	
	return 0;
}

int 
dartread (dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	int port;
	struct tty *tp;
	struct dart_info *dart;
	struct dartsoftc *sc;

	if ((port = DART_PORT(dev)) > 1) {
		return (ENODEV);
	}
	sc = (struct dartsoftc *) dart_cd.cd_devs[0];
	dart = &sc->sc_dart[port];
	tp = dart->tty;

	if (!tp)
		return ENXIO;
	return ((*linesw[tp->t_line].l_read)(tp, uio, flag));
}

int 
dartwrite(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	int port;
	struct tty *tp;
	struct dart_info *dart;
	struct dartsoftc *sc;

	if ((port = DART_PORT(dev)) > 1) {
		return (ENODEV);
	}
	sc = (struct dartsoftc *)dart_cd.cd_devs[0];
	dart = &sc->sc_dart[port];

	tp = dart->tty;
	if (!tp)
		return ENXIO;
	return ((*linesw[tp->t_line].l_write)(tp, uio, flag));
d861 2
a862 2
	struct dartsoftc *sc;
	int port;
d864 47
a910 47
	union dartreg *addr;
	union dart_pt_io *ptaddr;
	struct tty *tp;
	unsigned char data, sr;
	struct dart_info *dart;

	dart = &sc->sc_dart[port];
	addr = sc->dart_reg;

	/* read status reg */
	ptaddr = sc->port_reg[port];

	dprintf(("dartrint: Rx int port %d\n", port));

	tp = dart->tty;

	dprintf(("dartrint: ptaddr = 0x%08x from uart at 0x%08x\n",
		 ptaddr, addr));

	while ((sr = ptaddr->read.rd_sr) & RXRDY) {
		dprintf(("dartrint: sr = 0x%08x\n", sr));

		data = ptaddr->read.rd_rb; /* read data and reset receiver */

		dprintf(("dartrint: read char \"%c\" (0x%02x) tp = 0x%x\n",
			 data, data, tp));

		if ((tp->t_state & (TS_ISOPEN|TS_WOPEN)) == 0 && dart_cons != port) {
			return;
		}

		if (sr & RBRK) {
			dprintf(("dartrint: BREAK detected\n"));
			/*
			data = tp->t_breakc;
			ttyinput(data, tp);
			*/
			/* clear break state */
			ptaddr->write.wr_cr = BRKINTRESET;
			DELAY_CR;
			ptaddr->write.wr_cr = ERRRESET;

#if defined(DDB)
			if (ddb_break_mode & DDB_ENTER_BREAK) {
				dprintf(("dartrint: break detected - entering debugger\n"));
				gimmeabreak();
			}
d912 18
a929 18
		} else {
			if (sr & (FRERR|PERR|ROVRN)) { /* errors */
				if (sr & ROVRN)
					printf("dart0: receiver overrun port %c\n", 'A' + port);
				if (sr & FRERR)
					printf("dart0: framing error port %c\n", 'A' + port);
				if (sr & PERR)
					printf("dart0: parity error port %c\n", 'A' + port);
				dprintf(("dartrint: error received\n"));
				/* clear error state */
				ptaddr->write.wr_cr = ERRRESET;
			} else {
				/* no errors */
#if defined(DDB)
				if ((ddb_break_mode & DDB_ENTER_CHAR) && (ddb_break_char == data)) {
					dprintf(("dartrint: ddb_break_char detected - entering debugger\n"));
					gimmeabreak();
				} else
d931 6
a936 11
					(*linesw[tp->t_line].l_rint)(data,tp);
#if 0
				{
					if (tp->t_ispeed == B134) /* CS6 */
						data &= 077;
					else if (tp->t_flags & CS8)
						;
					else
						data &= 0177; /* CS7 */
					ttyinput(data, tp);
				}
d938 8
a945 4
			}
		}
	}
	dprintf(("dartrint: ready\n"));
d950 2
a951 2
	struct dartsoftc *sc;
	int port;
d953 4
a956 3
	struct tty *tp;
	struct dart_info *dart;
	union dartreg *addr;
d958 2
a959 2
	dart = &sc->sc_dart[port];
	addr = sc->dart_reg;
d961 1
a961 1
	tp = dart->tty;
d963 1
a963 1
	simple_lock(&dart->t_lock);
d965 2
a966 2
	if ((tp->t_state & (TS_ISOPEN|TS_WOPEN))==0)
		goto out;
d968 2
a969 2
	if (tp->t_state & TS_FLUSH)
		tp->t_state &= ~TS_FLUSH;
d971 11
a981 11
	if (tp->t_state & TS_BUSY) {
		tp->t_state &= ~TS_BUSY;
		dprintf(("dartxint: starting output\n"));
		dartstart(tp);
		if (tp->t_state & TS_BUSY) {
			dprintf(("dartxint: ready - Tx left enabled\n"));
			simple_unlock(&dart->t_lock);
			return;
		}
	}
out:
d983 5
a987 5
	/* disable transmitter */
	if (port == 0)
		dart_sv_reg.sv_imr = dart_sv_reg.sv_imr & ~ITXRDYA;
	else
		dart_sv_reg.sv_imr = dart_sv_reg.sv_imr & ~ITXRDYB;
d989 1
a989 1
	addr->write.wr_imr = dart_sv_reg.sv_imr;
d991 1
a991 1
	simple_unlock(&dart->t_lock);
d993 1
a993 1
	dprintf(("dartxint: ready - Tx disabled\n"));
d995 1
a995 1
	return;
d999 2
a1000 2
dartintr(arg)
	void *arg;
d1002 51
a1052 53
	struct dartsoftc *sc = arg;

	unsigned char isr;
	int port;
	union dartreg *addr;

	/* read interrupt status register and mask with imr */
	addr = sc->dart_reg;

	isr = addr->read.rd_isr;
	
	isr &= dart_sv_reg.sv_imr;
	
	if (isr) {     /* interrupt from this duart */
		if (isr & IIPCHG) {
			unsigned int ip = addr->read.rd_ip;
			unsigned int ipcr = addr->read.rd_ipcr;
			dartmodemtrans(sc, ip, ipcr);
			return 1;
		}

		if (isr & (IRXRDYA | ITXRDYA))
			port = 0;
		else
			if (isr & (IRXRDYB | ITXRDYB))
			port = 1;
		else {
			printf("dartintr: spurious interrupt, isr 0x%08x\n", isr);
			panic("dartintr");
		}

		dprintf(("dartintr: interrupt from port %d, isr 0x%08x\n",
			 port, isr));

		if (isr & (IRXRDYA | IRXRDYB)) {
			dprintf(("dartintr: Rx interrupt\n"));
			dartrint(sc, port);
		}
		if (isr & (ITXRDYA | ITXRDYB)) {
			dprintf(("dartintr: Tx interrupt\n"));
			dartxint(sc, port);
		}
		if (((port == A_PORT) && (isr & IBRKA))
		    || ((port == B_PORT) && (isr & IBRKB))) {
			union dart_pt_io *ptaddr =
			(union dart_pt_io *)addr + port;

			dprintf(("dartintr: clearing end of BREAK state\n"));
			ptaddr->write.wr_cr = BRKINTRESET;
		}
	}
	dprintf(("dartintr: ready\n"));
	return 1;
d1062 1
a1062 1
	struct consdev *cp;
d1064 14
a1077 14
	int maj;

	if (cputyp != CPU_188) {
		cp->cn_pri = CN_DEAD;
		return 0;
	}
	/* locate the major number */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == dartopen)
			break;

	cp->cn_dev = makedev(maj, 0);
	cp->cn_pri = CN_NORMAL;
	return (1);
d1082 1
a1082 1
	struct consdev *cp;
d1084 1
a1084 2
	dart_cons = A_PORT;
	return 0;
d1087 1
a1087 1
void
d1089 2
a1090 2
	dev_t dev;
	char c;
d1092 38
a1129 9
	union dartreg *addr;
	union dart_pt_io *ptaddr;
#if 0
	m88k_psr_type psr;
#endif
	int s;
	int port;

	port = DART_PORT(dev);
d1131 1
a1131 1
	addr = (union dartreg *) MVME188_DUART;
d1133 1
a1133 46
#if 1
	ptaddr = (union dart_pt_io *) addr + (port * 0x20);
#else
	ptaddr = (union dart_pt_io *) addr + ((dev & 1) ? 1 : 0);
#endif 

#if 1
	s = spltty();
#else 
	psr = disable_interrupts_return_psr();
#endif 

	/* Assume first port initialized if we get here. */
	/* Assume the bug initializes the port */

	/* inhibit interrupts on the chip */
	addr->write.wr_imr = dart_sv_reg.sv_imr & ~ITXRDYA;
	/* make sure transmitter is enabled */
	DELAY_CR;
	ptaddr->write.wr_cr = TXEN;

	/* If the character is a line feed(\n) */
	/* then follow it with carriage return (\r) */
	for (;;) {
		while (!(ptaddr->read.rd_sr & TXRDY))
			;
		ptaddr->write.wr_tb = c;
		if (c != '\n')
			break;
		c = '\r';
	}

	/* wait for transmitter to empty */
	while (!(ptaddr->read.rd_sr & TXEMT))
		;

	/* restore the previous state */
	addr->write.wr_imr = dart_sv_reg.sv_imr;
	DELAY_CR;
	ptaddr->write.wr_cr = dart_sv_reg.sv_cr[0];

#if 1
	splx(s);
#else 
	set_psr(psr);
#endif 
d1138 1
a1138 1
	dev_t dev;
d1140 47
a1186 8
	union dartreg  *addr;	   /* pointer to DUART regs */
	union dart_pt_io  *ptaddr; /* pointer to port regs */
	unsigned char   sr;	       /* status reg of port a/b */
	int c;		/* received character */
	int s;
	int port;
	m88k_psr_type psr;
	char buf[] = "char x";
d1188 1
a1188 37
	port = DART_PORT(dev);
#if 1
	s = spltty();
#else
	psr = disable_interrupts_return_psr();
#endif
	addr = (union dartreg *) DART_BASE;
#if 1
	ptaddr = (union dart_pt_io *) addr + (port * 0x20);
#else
	ptaddr = (union dart_pt_io *) addr + ((dev & 1) ? 1 : 0);
#endif 
	/* enable receiver */
	ptaddr->write.wr_cr = RXEN;

	do {
		/* read status reg */
		sr = ptaddr->read.rd_sr;

		/* receiver interrupt handler*/
		if (sr & RXRDY) {
			/* read character from port */
			c = ptaddr->read.rd_rb;

			/* check break condition */
			if (sr & RBRK) {
				/* clear break state */
				ptaddr->write.wr_cr = BRKINTRESET;
				DELAY_CR;
				ptaddr->write.wr_cr = ERRRESET;
#if 1
				splx(s);
#else 
				set_psr(psr);
#endif 
				return c;
			}
d1190 1
a1190 22
			if (sr & (FRERR|PERR|ROVRN)) {
				/* clear error state */
				ptaddr->write.wr_cr = ERRRESET;
				DELAY_CR;
				ptaddr->write.wr_cr = BRKINTRESET;
			} else {
				buf[5] = (char) c;
#if 1
				splx(s);
#else 
				set_psr(psr);
#endif 
				return (c & 0x7f);
			}
		}
	} while (-1);
#if 1
	splx(s);
#else 
	set_psr(psr);
#endif 
	return -1;
@


1.1.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@a0 2
/*	$OpenBSD$	*/

d37 1
a37 3
#include <sys/syslog.h>

#include <machine/asm_macro.h>   /* enable/disable interrupts */
a38 1
#include <machine/cpu.h>
d40 1
a40 2
#include <machine/psl.h>

a41 1

d44 1
a44 1

d46 1
d49 6
a54 2
#ifdef	DDB
#include <ddb/db_var.h>
a98 8
int dart_speed __P((int));
struct tty* darttty __P((dev_t));
void dartstart __P((struct tty *));
int dartmctl __P((dev_t, int, int));
int dartparam __P((struct tty *, struct termios *));
void dartmodemtrans __P((struct dartsoftc *, unsigned int, unsigned int));
void dartrint __P((struct dartsoftc *, int));
void dartxint __P((struct dartsoftc *, int));
d181 1
a181 1
	if (badvaddr((vaddr_t)addr, 2) <= 0) {
d482 1
a482 1
		panic("dartmctl: DMGET not supported (yet)");
d664 1
a664 1
			dartmctl(dev, HUPCL, DMSET);
d976 1
a976 1
			if (db_console != 0) {
d978 1
a978 1
				Debugger();
d994 7
a1000 1
				(*linesw[tp->t_line].l_rint)(data,tp);
a1233 2
#if 1
#else
a1234 1
#endif
@


1.1.4.3
log
@Merge in trunk
@
text
@d188 1
a188 1
	if (brdtyp != BRD_188) return (0);
d191 1
a191 2
	
	if (badvaddr((vaddr_t)addr, 2)) {
d1141 1
a1141 1
	if (brdtyp != BRD_188) {
@


1.1.4.4
log
@Merge in -current from about a week ago
@
text
@d84 2
a85 2
int dartmatch(struct device *parent, void *self, void *aux);
void dartattach(struct device *parent, struct device *self, void *aux);
d97 12
a108 12
int dartcnprobe(struct consdev *cp);
int dartcninit(struct consdev *cp);
int dartcngetc(dev_t dev);
void dartcnputc(dev_t dev, char c);
int dart_speed(int);
struct tty* darttty(dev_t);
void dartstart(struct tty *);
int dartmctl(dev_t, int, int);
int dartparam(struct tty *, struct termios *);
void dartmodemtrans(struct dartsoftc *, unsigned int, unsigned int);
void dartrint(struct dartsoftc *, int);
void dartxint(struct dartsoftc *, int);
d110 8
a117 8
int dartopen(dev_t dev, int flag, int mode, struct proc *p);
int dartclose(dev_t dev, int flag, int mode, struct proc *p);
int dartread(dev_t dev, struct uio *uio, int flag);
int dartwrite(dev_t dev, struct uio *uio, int flag);
int dartioctl(dev_t dev, int cmd, caddr_t data, int flag, struct proc *p);
int dartstop(struct tty *tp, int flag);
int dartintr(void *);
void dartbreak(dev_t dev, int state);
@


1.1.4.5
log
@Sync the SMP branch with 3.3
@
text
@d30 1
a42 1
#include <machine/conf.h>
d110 6
d542 1
a542 1
dartioctl(dev, cmd, data, flag, p)
d544 1
a544 1
	u_long cmd;
d1202 10
a1211 3
	while (!(ptaddr->read.rd_sr & TXRDY))
		;
	ptaddr->write.wr_tb = c;
@


1.1.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d52 2
a53 1
#define spldart()	spltty()
a65 2
#define	NDARTPORTS	2	/* Number of ports */

d76 2
a77 2
        union  dart_pt_io	*port_reg[NDARTPORTS];
	struct dart_info	sc_dart[NDARTPORTS];
d87 1
a87 1
struct cfattach dart_ca = {
d89 1
a89 1
};
d92 1
a92 1
	NULL, "dart", DV_TTY
d155 1
a155 1
		if (ds->kspeed == speed)
d162 1
a162 1
struct tty*
d166 1
a166 1
	unsigned int port;
d168 1
a168 1

a169 4
	if (dart_cd.cd_ndevs == 0 || port >= NDARTPORTS)
		return (NULL);

	sc = (struct dartsoftc *) dart_cd.cd_devs[0];
d185 1
a185 1

d215 1
a215 1
	sc->sc_vec = ca->ca_vec;
d235 1
a235 1

d317 1
a317 2
	port = DART_PORT(dev);
	if (dart_cd.cd_ndevs == 0 || port >= NDARTPORTS)
d319 1
a319 1

d326 1
a326 1

d328 1
a328 1

d331 1
a331 1

d365 1
a365 1

d439 1
a439 1
	int s;
d441 1
a441 2
	port = DART_PORT(dev);
	if (dart_cd.cd_ndevs == 0 || port >= NDARTPORTS)
d443 1
a443 1

d458 1
a458 1
#endif
d460 1
a460 1

d471 1
a471 1
#endif
d522 1
a522 1

d535 1
a535 1
int
a547 1

a548 3
	if (dart_cd.cd_ndevs == 0 || port >= NDARTPORTS)
		return (ENODEV);

d601 1
a601 1
		error = suser(p, 0);
d603 1
a603 1
			return(EPERM);
d621 1
a621 1
int
d638 1
a638 2
	port = DART_PORT(dev);
	if (dart_cd.cd_ndevs == 0 || port >= NDARTPORTS)
d640 1
d646 1
a646 1

d800 1
a800 1
int
d812 1
a812 2
	port = DART_PORT(dev);
	if (dart_cd.cd_ndevs == 0 || port >= NDARTPORTS)
d814 1
a814 1

d862 1
a862 1
int
d874 2
a875 2
	port = DART_PORT(dev);
	if (dart_cd.cd_ndevs == 0 || port >= NDARTPORTS)
d877 1
a877 1

d883 1
a883 1

d887 1
a887 1
int
d898 1
a898 2
	port = DART_PORT(dev);
	if (dart_cd.cd_ndevs == 0 || port >= NDARTPORTS)
d900 1
a900 1

d910 1
a910 1
int
d921 1
a921 2
	port = DART_PORT(dev);
	if (dart_cd.cd_ndevs == 0 || port >= NDARTPORTS)
d923 1
a923 1

d1010 1
a1010 1
#endif
d1080 1
d1082 1
a1082 1

d1179 1
a1179 1
#endif
d1183 1
a1183 1
#else
d1185 1
a1185 1
#endif
d1211 1
a1211 1
#else
d1213 1
a1213 1
#endif
d1243 1
a1243 1
#endif
d1264 1
a1264 1
#else
d1266 1
a1266 1
#endif
d1279 1
a1279 1
#else
d1281 1
a1281 1
#endif
d1288 1
a1288 1
#else
d1290 1
a1290 1
#endif
@


1.1.4.7
log
@Merge with the trunk
@
text
@a44 1
#include <machine/locore.h>
d59 2
a60 2
int dart_debug = 1;
#define dprintf(stuff) if (dart_debug) printf stuff
d62 1
a62 1
#define dprintf(stuff)
d80 3
d85 2
a86 2
int	dartmatch(struct device *parent, void *self, void *aux);
void	dartattach(struct device *parent, struct device *self, void *aux);
d96 1
a96 3
/* console is on the first port */
#define	CONS_PORT	A_PORT

d98 4
a101 1
cons_decl(dart);
a111 1
#if 0
a112 1
#endif
d124 1
a124 1

d128 1
a128 1
const struct dart_s {
d147 1
a147 1
	{-1,		NOBAUD	},	/* anything more is uncivilized */
d154 2
a155 3
	const struct dart_s *ds;

	for (ds = dart_speeds; ds->kspeed != -1; ds++)
d158 2
a159 1

d187 3
a189 4
	if (brdtyp != BRD_188)
		return (0);

	addr = (union dartreg *)ca->ca_paddr;
a191 1
#ifdef DEBUG
a192 1
#endif
a194 1

a209 3
	if (ca->ca_ipl < 0)
		ca->ca_ipl = IPL_TTY;

d211 2
a212 2
	sc->dart_reg = (union dartreg *)ca->ca_paddr;
        ptaddr = (union  dart_pt_io *)ca->ca_paddr;
d216 1
d219 2
d241 3
a243 8
	/*
	 * Although we are still running using the BUG routines,
	 * this device will be elected as the console after
	 * autoconf.
	 * We do not even test since we know we are an MVME188 and
	 * console is always on the first port.
	 */
	printf(": console");
d293 1
a293 1
	addr->write.wr_ivr = SYSCON_VECT + SYSCV_SCC;	/* hard coded vector */
d301 1
a301 1
	sysconintr_establish(SYSCV_SCC, &sc->sc_ih);
d353 1
a353 1
	if (port != CONS_PORT)
d367 1
a367 1
				if (port != CONS_PORT)
d372 1
a372 1
				if (port != CONS_PORT)
d382 1
a382 1
				if (port != CONS_PORT)
d392 1
a506 1
#if 0
d538 2
a540 1
#endif
d607 1
a607 1
		if (CONS_PORT == port)
d617 1
a617 1
		if (CONS_PORT == port)
d668 1
a668 1
	if (CONS_PORT == port) {
d850 1
a850 1
		if (port == CONS_PORT) {
d979 1
a979 1
		if ((tp->t_state & (TS_ISOPEN|TS_WOPEN)) == 0 && CONS_PORT != port) {
d996 1
d1076 2
d1143 1
a1143 1
void
d1149 4
a1152 5
	cp->cn_pri = CN_DEAD;

	if (brdtyp != BRD_188 || badaddr(DART_BASE, 2) != 0)
		return;

a1156 2
	if (maj == nchrdev)
		return;
d1160 1
d1163 1
a1163 1
void
d1167 2
@


