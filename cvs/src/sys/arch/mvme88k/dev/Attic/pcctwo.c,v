head	1.31;
access;
symbols
	OPENBSD_5_5:1.30.0.18
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.30.0.14
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.30.0.12
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.10
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.8
	OPENBSD_5_0:1.30.0.6
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.30.0.4
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.30.0.2
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.29.0.14
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.29.0.16
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.29.0.12
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.29.0.10
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.29.0.8
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.29.0.6
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.29.0.4
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.29.0.2
	OPENBSD_4_0_BASE:1.29
	OPENBSD_3_9:1.27.0.4
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.27.0.2
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.26.0.4
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.26.0.2
	OPENBSD_3_6_BASE:1.26
	SMP_SYNC_A:1.25
	SMP_SYNC_B:1.25
	OPENBSD_3_5:1.21.0.2
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	UBC_SYNC_A:1.16
	OPENBSD_3_3:1.16.0.6
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.4
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	UBC_SYNC_B:1.16
	UBC:1.13.0.2
	UBC_BASE:1.13
	OPENBSD_3_0:1.10.0.4
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.8.0.4
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	SMP:1.7.0.4
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	mvme88kport:1.1.1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	first_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2014.03.18.22.36.36;	author miod;	state dead;
branches;
next	1.30;

1.30
date	2010.06.26.23.24.43;	author guenther;	state Exp;
branches;
next	1.29;

1.29
date	2006.05.08.14.36.10;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2006.04.27.20.19.28;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2005.07.18.02.43.25;	author fgsch;	state Exp;
branches;
next	1.26;

1.26
date	2004.07.30.19.02.06;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2004.05.07.18.10.28;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2004.04.24.19.51.48;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2004.04.16.23.36.48;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2004.04.14.13.42.54;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2004.01.14.20.52.52;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2004.01.14.20.50.48;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2004.01.05.20.06.59;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2003.10.05.20.27.48;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.02.07.06.56;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.14.01.26.39;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.22.18.45.35;	author smurph;	state Exp;
branches;
next	1.14;

1.14
date	2001.12.20.06.07.28;	author smurph;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.19.07.04.41;	author smurph;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2001.12.16.23.49.46;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.13.08.55.51;	author smurph;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.08.00.03.14;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.12.07.29.27;	author smurph;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.26.23.32.00;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	99.09.27.18.43.24;	author smurph;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	99.05.29.04.41.44;	author smurph;	state Exp;
branches;
next	1.5;

1.5
date	98.12.15.05.52.30;	author smurph;	state Exp;
branches;
next	1.4;

1.4
date	97.03.03.20.20.41;	author rahnds;	state Exp;
branches;
next	1.3;

1.3
date	97.03.03.19.07.12;	author rahnds;	state dead;
branches;
next	1.2;

1.2
date	96.11.23.21.46.05;	author kstailey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.10.54.28;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.10.54.28;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.03.03.19.32.02;	author rahnds;	state Exp;
branches;
next	;

1.7.4.1
date	2001.04.18.16.10.59;	author niklas;	state Exp;
branches;
next	1.7.4.2;

1.7.4.2
date	2002.03.06.02.04.44;	author niklas;	state Exp;
branches;
next	1.7.4.3;

1.7.4.3
date	2002.03.28.10.36.02;	author niklas;	state Exp;
branches;
next	1.7.4.4;

1.7.4.4
date	2003.06.07.11.13.16;	author ho;	state Exp;
branches;
next	1.7.4.5;

1.7.4.5
date	2004.02.19.10.49.06;	author niklas;	state Exp;
branches;
next	1.7.4.6;

1.7.4.6
date	2004.06.05.23.09.49;	author niklas;	state Exp;
branches;
next	;

1.13.2.1
date	2002.01.31.22.55.17;	author niklas;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2002.06.11.03.37.10;	author art;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: pcctwo.c,v 1.30 2010/06/26 23:24:43 guenther Exp $ */
/*
 * Copyright (c) 1995 Theo de Raadt
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * VME1x7 PCC2 chip
 */
#include <sys/param.h>
#include <sys/conf.h>
#include <sys/ioctl.h>
#include <sys/proc.h>
#include <sys/tty.h>
#include <sys/uio.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/syslog.h>
#include <sys/fcntl.h>
#include <sys/device.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>

#include <dev/cons.h>

#include <mvme88k/dev/pcctworeg.h>
#include <mvme88k/dev/pcctwovar.h>

#include "bussw.h"

void	pcctwoattach(struct device *, struct device *, void *);
int	pcctwomatch(struct device *, void *, void *);

struct cfattach pcctwo_ca = {
	sizeof(struct pcctwosoftc), pcctwomatch, pcctwoattach
};

struct cfdriver pcctwo_cd = {
	NULL, "pcctwo", DV_DULL
};

int	pcctwo_print(void *args, const char *bus);
int	pcctwo_scan(struct device *parent, void *child, void *args);

int
pcctwomatch(parent, vcf, args)
	struct device *parent;
	void *vcf, *args;
{
	struct confargs *ca = args;
	bus_space_handle_t ioh;
	int rc;
	u_int8_t chipid;

	/* Bomb if wrong cpu */
	switch (brdtyp) {
	case BRD_187:
	case BRD_8120:
	case BRD_197:
		break;
	default:
		return 0;
	}

	if (bus_space_map(ca->ca_iot, PCC2_BASE, PCC2_SIZE,
	    0, &ioh) != 0)
		return 0;
	rc = badaddr((vaddr_t)bus_space_vaddr(ca->ca_iot, ioh), 4);
	if (rc == 0) {
		chipid = bus_space_read_1(ca->ca_iot, ioh, PCCTWO_CHIPID);
		if (chipid != PCC2_ID) {
#ifdef DEBUG
			printf("==> pcctwo: wrong chip id %x.\n", chipid);
			rc = -1;
#endif
		}
	}
	bus_space_unmap(ca->ca_iot, ioh, PCC2_SIZE);

	return rc == 0;
}

void
pcctwoattach(parent, self, args)
	struct device *parent, *self;
	void *args;
{
	struct confargs *ca = args;
	struct pcctwosoftc *sc = (struct pcctwosoftc *)self;
	bus_space_handle_t ioh;
	u_int8_t genctl;

	sc->sc_base = PCC2_BASE;

	if (bus_space_map(ca->ca_iot, sc->sc_base, PCC2_SIZE, 0, &ioh) != 0) {
		printf(": can't map registers!\n");
		return;
	}

	sc->sc_iot = ca->ca_iot;
	sc->sc_ioh = ioh;

	bus_space_write_1(sc->sc_iot, ioh, PCCTWO_VECBASE, PCC2_VECBASE);
	genctl = bus_space_read_1(sc->sc_iot, ioh, PCCTWO_GENCTL);
#if NBUSSW > 0
	if (ca->ca_bustype == BUS_BUSSWITCH) {
                /* Make sure the bus is mc68040 compatible */
		genctl |= PCC2_GENCTL_C040;
	}
#endif
	genctl |= PCC2_GENCTL_IEN;	/* global irq enable */
	bus_space_write_1(sc->sc_iot, ioh, PCCTWO_GENCTL, genctl);

	printf(": rev %d\n",
	    bus_space_read_1(sc->sc_iot, ioh, PCCTWO_CHIPREV));

	config_search(pcctwo_scan, self, args);
}

int
pcctwo_print(args, bus)
	void *args;
	const char *bus;
{
	struct confargs *ca = args;

	if (ca->ca_offset != -1)
		printf(" offset 0x%x", ca->ca_offset);
	if (ca->ca_ipl > 0)
		printf(" ipl %d", ca->ca_ipl);
	return (UNCONF);
}

int
pcctwo_scan(parent, child, args)
	struct device *parent;
	void *child, *args;
{
	struct cfdata *cf = child;
	struct confargs oca, *ca = args;

	bzero(&oca, sizeof oca);
	oca.ca_iot = ca->ca_iot;
	oca.ca_dmat = ca->ca_dmat;
	oca.ca_offset = cf->cf_loc[0];
	oca.ca_ipl = cf->cf_loc[1];
	if (oca.ca_offset != -1) {
		/* offset locator for pcctwo children is relative to segment */
		oca.ca_paddr = ca->ca_paddr + oca.ca_offset;
	} else {
		oca.ca_paddr = -1;
	}
	oca.ca_bustype = BUS_PCCTWO;
	oca.ca_name = cf->cf_driver->cd_name;
	if ((*cf->cf_attach->ca_match)(parent, cf, &oca) == 0)
		return (0);
	config_attach(parent, cf, &oca, pcctwo_print);
	return (1);
}

/*
 * PCC2 interrupts land in a PCC2_NVEC sized hole starting at PCC2_VECBASE
 */
int
pcctwointr_establish(int vec, struct intrhand *ih, const char *name)
{
#ifdef DIAGNOSTIC
	if (vec < 0 || vec >= PCC2_NVEC)
		panic("pcctwo_establish: illegal vector 0x%x", vec);
#endif

	return intr_establish(PCC2_VECBASE + vec, ih, name);
}
@


1.30
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcctwo.c,v 1.29 2006/05/08 14:36:10 miod Exp $ */
@


1.29
log
@Replace gazillions of badvaddr() or badwordaddr() calls with badaddr() calls.
With a few prototype declarations shuffling, this finally allows
<machine/locore.h> to die.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcctwo.c,v 1.28 2006/04/27 20:19:28 miod Exp $ */
a33 1
#include <sys/user.h>
@


1.28
log
@Adjust sizes for the mandatory 1:1 mappings created in pmap_bootstrap().
Saves up to 12KB of no longer necessary page tables.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcctwo.c,v 1.27 2005/07/18 02:43:25 fgsch Exp $ */
d90 1
a90 1
	rc = badvaddr((vaddr_t)bus_space_vaddr(ca->ca_iot, ioh), 4);
@


1.27
log
@remove trailing newline in panic(9); ok millert@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcctwo.c,v 1.26 2004/07/30 19:02:06 miod Exp $ */
d87 1
a87 1
	if (bus_space_map(ca->ca_iot, ca->ca_paddr + PCC2_BASE, PCC2_SIZE,
d115 1
a115 1
	sc->sc_base = ca->ca_paddr + PCC2_BASE;
@


1.26
log
@Move evcount structures inside struct intrhand, this makes more sense and
gives us more counters in the process.

Also clean up intrhand structures and usage, especially move them to SLISTs.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcctwo.c,v 1.25 2004/05/07 18:10:28 miod Exp $ */
d191 1
a191 1
		panic("pcctwo_establish: illegal vector 0x%x\n", vec);
@


1.25
log
@bus_dma(9) implementation for mvme88k, mostly based upon powerpc.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcctwo.c,v 1.24 2004/04/24 19:51:48 miod Exp $ */
d187 1
a187 3
pcctwointr_establish(vec, ih)
	int vec;
	struct intrhand *ih;
d194 1
a194 1
	return (intr_establish(PCC2_VECBASE + vec, ih));
@


1.24
log
@Preliminary switch to an mvme88k bus_space world. Not all drivers have been
converted yet, and they rely upon some linear mappings provided by bus_space.

In order to not impact performance, almost all the bus_space accesses go
through macros and inline functions. This currently restricts us to D16 and
D32 access modes, which are selected at compilation time. Since there are no
plans to support D8 vme devices in the future, this is acceptable for now.

This makes the "len" locator for vme devices go away, and allows to simplify
some code which was using the pcctwo device, and will now directly access
hardware which is known to exist, rather than wait until the device is
attached.

While there, try to enforce more interrupt vector number checks, since these
changes pointed out that dart(4) had been working correctly so far by sheer
luck only.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcctwo.c,v 1.23 2004/04/16 23:36:48 miod Exp $ */
d162 1
a162 2
	struct pcctwosoftc *sc = (struct pcctwosoftc *)parent;
	struct confargs oca;
d165 2
a166 1
	oca.ca_iot = sc->sc_iot;
d171 1
a171 1
		oca.ca_paddr = sc->sc_base - PCC2_BASE + oca.ca_offset;
@


1.23
log
@Bounds check PCC2 and SYSCON interrupt vectors.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcctwo.c,v 1.22 2004/04/14 13:42:54 miod Exp $ */
a47 1
#include <mvme88k/dev/pcctwofunc.h>
d49 1
d53 2
a54 9
struct pcctwosoftc {
	struct device	sc_dev;
	void		*sc_vaddr;	/* PCC2 space */
	void		*sc_paddr;
	struct pcctworeg *sc_pcc2;	/* the actual registers */
};

void pcctwoattach(struct device *, struct device *, void *);
int  pcctwomatch(struct device *, void *, void *);
d64 2
a65 6
struct pcctworeg *sys_pcc2 = NULL;

int pcc2bus;

int pcctwo_print(void *args, const char *bus);
int pcctwo_scan(struct device *parent, void *child, void *args);
d73 3
a75 1
	struct pcctworeg *pcc2;
d81 1
a81 4
		pcc2 = (struct pcctworeg *)(IIOV(ca->ca_paddr) + PCC2_PCC2CHIP_OFF);
		break;
	case BRD_197: /* pcctwo is a child of buswitch XXX smurph */
		pcc2 = (struct pcctworeg *)(IIOV(ca->ca_paddr));
d84 15
a98 2
		/* Bomb if wrong board */
		return (0);
d100 14
d115 5
a119 3
	if (badvaddr((vaddr_t)pcc2, 4)) {
		printf("==> pcctwo: failed address check.\n");
		return (0);
d121 10
a130 3
	if (pcc2->pcc2_chipid != PCC2_CHIPID) {
		printf("==> pcctwo: wrong chip id %x.\n", pcc2->pcc2_chipid);
		return (0);
d132 8
a139 1
	return (1);
d166 1
d169 3
a171 3
	if (((int)oca.ca_offset != -1) && ISIIOVA(sc->sc_vaddr + oca.ca_offset)) {
		oca.ca_vaddr = sc->sc_vaddr + oca.ca_offset;
		oca.ca_paddr = sc->sc_paddr + oca.ca_offset;
d173 1
a173 2
		oca.ca_vaddr = (void *)-1;
		oca.ca_paddr = (void *)-1;
a175 1
	oca.ca_master = (void *)sc->sc_pcc2;
a180 48
}

void
pcctwoattach(parent, self, args)
struct device *parent, *self;
void *args;
{
	struct confargs *ca = args;
	struct pcctwosoftc *sc = (struct pcctwosoftc *)self;

	if (sys_pcc2)
		panic("pcc2 already attached!");

	/*
	 * since we know ourself to land in intiobase land,
	 * we must adjust our address
	 */
	sc->sc_paddr = ca->ca_paddr;
	sc->sc_vaddr = (void *)IIOV(sc->sc_paddr);

	pcc2bus = ca->ca_bustype;

	switch (pcc2bus) {
	case BUS_MAIN:
		sc->sc_pcc2 = (struct pcctworeg *)(sc->sc_vaddr + PCC2_PCC2CHIP_OFF);
		break;
#if NBUSSW > 0
	case BUS_BUSSWITCH:
		sc->sc_pcc2 = (struct pcctworeg *)sc->sc_vaddr;
		/*
		 * fake up our address so that pcc2 child devices
		 * are offset of 0xFFF00000 - XXX smurph
		 */
                sc->sc_paddr -= PCC2_PCC2CHIP_OFF;
                sc->sc_vaddr -= PCC2_PCC2CHIP_OFF;
                /* make sure the bus is mc68040 compatible */
		sc->sc_pcc2->pcc2_genctl |= PCC2_GENCTL_C040;
		break;
#endif
	}
	sys_pcc2 = sc->sc_pcc2;

	printf(": rev %d\n", sc->sc_pcc2->pcc2_chiprev);

	sc->sc_pcc2->pcc2_vecbase = PCC2_VECBASE;
	sc->sc_pcc2->pcc2_genctl |= PCC2_GENCTL_IEN;	/* global irq enable */

	config_search(pcctwo_scan, self, args);
@


1.22
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: pcctwo.c,v 1.21 2004/01/14 20:52:52 miod Exp $ */
d28 1
a28 1
 * VME18x PCC2 chip
d209 6
a214 5
	if (vec >= PCC2_NVEC) {
		printf("pcctwo: illegal vector: 0x%x\n", vec);
		panic("pcctwointr_establish");
	}
	return (intr_establish(PCC2_VECBASE+vec, ih));
@


1.21
log
@mvme* do not support buses with indirect configuration, so don't check and
mourn for this.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcctwo.c,v 1.20 2004/01/14 20:50:48 miod Exp $ */
d182 1
a182 1
		 * are offeset of 0xFFF00000 - XXX smurph
@


1.20
log
@Do not fill more than the first three fields of cfdriver structures unless
necessary. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcctwo.c,v 1.19 2004/01/05 20:06:59 miod Exp $ */
a132 5

	if (parent->dv_cfdata->cf_driver->cd_indirect) {
                printf(" indirect devices not supported\n");
                return 0;
        }
@


1.19
log
@Stop masquerading the M8120 (no-slot MVME187) as a real MVME187, and keep
its value in brdtyp.

Compensate by checking for BRD_8120 everywhere BRD_187 was checked.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcctwo.c,v 1.18 2003/10/05 20:27:48 miod Exp $ */
d68 1
a68 1
	NULL, "pcctwo", DV_DULL, 0
@


1.18
log
@Kill vm_offset_t and vm_size_t, in favor of the [pv]addr_t and [pv]size_t
typedefs.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcctwo.c,v 1.17 2003/06/02 07:06:56 deraadt Exp $ */
d80 2
a81 2
struct device *parent;
void *vcf, *args;
d89 1
@


1.17
log
@licence cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: pcctwo.c,v 1.16 2002/03/14 01:26:39 millert Exp $ */
d99 1
a99 1
	if (badvaddr((vm_offset_t)pcc2, 4)) {
d174 1
a174 1
	
d184 1
a184 1
		/* 
d191 1
a191 1
		sc->sc_pcc2->pcc2_genctl |= PCC2_GENCTL_C040;	
d193 1
a193 1
#endif 
@


1.16
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pcctwo.c,v 1.15 2001/12/22 18:45:35 smurph Exp $ */
a13 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed under OpenBSD by
 *	Theo de Raadt for Willowglen Singapore.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.15
log
@Correct badvaddr() usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcctwo.c,v 1.14 2001/12/20 06:07:28 smurph Exp $ */
d66 2
a67 2
void pcctwoattach __P((struct device *, struct device *, void *));
int  pcctwomatch __P((struct device *, void *, void *));
d81 2
a82 2
int pcctwo_print __P((void *args, const char *bus));
int pcctwo_scan __P((struct device *parent, void *child, void *args));
@


1.14
log
@machine dependant pointer changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcctwo.c,v 1.13 2001/12/19 07:04:41 smurph Exp $ */
d57 2
d79 2
d105 1
a105 1
	if (badvaddr((vm_offset_t)pcc2, 4) <= 0) {
d180 5
a184 2
	switch (brdtyp) {
	case BRD_187:
d187 2
a188 1
	case BRD_197: /* pcctwo is a child of buswitch XXX smurph */
d190 8
d199 1
@


1.13
log
@Introduce brdtyp and change what cputyp means.
@
text
@d1 1
a1 3

/*	$OpenBSD: pcctwo.c,v 1.12 2001/12/16 23:49:46 miod Exp $ */

a190 5
	/*
	 * Set pcc2intr_mask and pcc2intr_ipl.
	 */
	pcc2intr_ipl = (u_char *)&(sc->sc_pcc2->pcc2_ipl);
	pcc2intr_mask = (u_char *)&(sc->sc_pcc2->pcc2_mask);
@


1.13.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 3
a3 1
/*	$OpenBSD: pcctwo.c,v 1.15 2001/12/22 18:45:35 smurph Exp $ */
a58 2
#include "bussw.h"

a78 2
int pcc2bus;

d103 1
a103 1
	if (badvaddr((vm_offset_t)pcc2, 4)) {
d178 2
a179 5
	
	pcc2bus = ca->ca_bustype;

	switch (pcc2bus) {
	case BUS_MAIN:
d182 1
a182 2
#if NBUSSW > 0
	case BUS_BUSSWITCH:
a183 8
		/* 
		 * fake up our address so that pcc2 child devices
		 * are offeset of 0xFFF00000 - XXX smurph
		 */
                sc->sc_paddr -= PCC2_PCC2CHIP_OFF;
                sc->sc_vaddr -= PCC2_PCC2CHIP_OFF;
                /* make sure the bus is mc68040 compatible */
		sc->sc_pcc2->pcc2_genctl |= PCC2_GENCTL_C040;	
a184 1
#endif 
d193 5
@


1.13.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pcctwo.c,v 1.13.2.1 2002/01/31 22:55:17 niklas Exp $ */
d66 2
a67 2
void pcctwoattach(struct device *, struct device *, void *);
int  pcctwomatch(struct device *, void *, void *);
d81 2
a82 2
int pcctwo_print(void *args, const char *bus);
int pcctwo_scan(struct device *parent, void *child, void *args);
@


1.12
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d2 1
a2 1
/*	$OpenBSD: pcctwo.c,v 1.10 2001/03/08 00:03:14 miod Exp $ */
d84 2
a85 2
	struct device *parent;
	void *vcf, *args;
d91 15
a105 15
	switch (cputyp) {
   case CPU_187:
      pcc2 = (struct pcctworeg *)(IIOV(ca->ca_paddr) + PCC2_PCC2CHIP_OFF);
      break;
   case CPU_197: /* pcctwo is a child of buswitch XXX smurph */
      pcc2 = (struct pcctworeg *)(IIOV(ca->ca_paddr));
      break;
   default:
	   /* Bomb if wrong cpu */
      return (0);
   }
	
   if (badvaddr((vm_offset_t)pcc2, 4) <= 0){
	    printf("==> pcctwo: failed address check.\n");
	    return (0);
d107 3
a109 3
	if (pcc2->pcc2_chipid != PCC2_CHIPID){
	    printf("==> pcctwo: wrong chip id %x.\n", pcc2->pcc2_chipid);
	    return (0);
d163 2
a164 2
	struct device *parent, *self;
	void *args;
d178 8
a185 8
	switch (cputyp) {
   case CPU_187:
      sc->sc_pcc2 = (struct pcctworeg *)(sc->sc_vaddr + PCC2_PCC2CHIP_OFF);
      break;
   case CPU_197: /* pcctwo is a child of buswitch XXX smurph */
      sc->sc_pcc2 = (struct pcctworeg *)sc->sc_vaddr;
      break;
   }
@


1.11
log
@Support for MVME197 completed.  Fix SPL defs.
@
text
@a58 2
#include "bussw.h"

a78 2
int pcc2bus;

d91 11
a101 11
	switch (brdtyp) {
	case BRD_187:
		pcc2 = (struct pcctworeg *)(IIOV(ca->ca_paddr) + PCC2_PCC2CHIP_OFF);
		break;
	case BRD_197: /* pcctwo is a child of buswitch XXX smurph */
		pcc2 = (struct pcctworeg *)(IIOV(ca->ca_paddr));
		break;
	default:
	/* Bomb if wrong board */
		return (0);
	}
d103 3
a105 3
	if (badvaddr((vm_offset_t)pcc2, 4)) {
		printf("==> pcctwo: failed address check.\n");
		return (0);
d107 3
a109 3
	if (pcc2->pcc2_chipid != PCC2_CHIPID) {
		printf("==> pcctwo: wrong chip id %x.\n", pcc2->pcc2_chipid);
		return (0);
d178 8
a185 21
	
	pcc2bus = ca->ca_bustype;

	switch (pcc2bus) {
	case BUS_MAIN:
		sc->sc_pcc2 = (struct pcctworeg *)(sc->sc_vaddr + PCC2_PCC2CHIP_OFF);
		break;
#if NBUSSW > 0
	case BUS_BUSSWITCH:
		sc->sc_pcc2 = (struct pcctworeg *)sc->sc_vaddr;
		/* 
		 * fake up our address so that pcc2 child devices
		 * are offeset of 0xFFF00000 - XXX smurph
		 */
                sc->sc_paddr -= PCC2_PCC2CHIP_OFF;
                sc->sc_vaddr -= PCC2_PCC2CHIP_OFF;
                /* make sure the bus is mc68040 compatible */
		sc->sc_pcc2->pcc2_genctl |= PCC2_GENCTL_C040;	
		break;
#endif 
	}
d196 2
a197 4
#if 0
	md.intr_mask = (u_char *)&(sc->sc_pcc2->pcc2_mask);
        md.intr_ipl = (u_char *)&(sc->sc_pcc2->pcc2_ipl);
#endif 
@


1.10
log
@Some warning hunting.
Define new include files for convenience, for use by drivers who can
attach either to pcctwo or syscon, or need bug console routines.
@
text
@d2 1
a2 1
/*	$OpenBSD: pcctwo.c,v 1.9 2001/01/12 07:29:27 smurph Exp $ */
d59 2
d81 2
d95 11
a105 11
	switch (cputyp) {
   case CPU_187:
      pcc2 = (struct pcctworeg *)(IIOV(ca->ca_paddr) + PCC2_PCC2CHIP_OFF);
      break;
   case CPU_197: /* pcctwo is a child of buswitch XXX smurph */
      pcc2 = (struct pcctworeg *)(IIOV(ca->ca_paddr));
      break;
   default:
	   /* Bomb if wrong cpu */
      return (0);
   }
d107 3
a109 3
   if (badvaddr((vm_offset_t)pcc2, 4) <= 0){
	    printf("==> pcctwo: failed address check.\n");
	    return (0);
d111 3
a113 3
	if (pcc2->pcc2_chipid != PCC2_CHIPID){
	    printf("==> pcctwo: wrong chip id %x.\n", pcc2->pcc2_chipid);
	    return (0);
d182 21
a202 8
	switch (cputyp) {
   case CPU_187:
      sc->sc_pcc2 = (struct pcctworeg *)(sc->sc_vaddr + PCC2_PCC2CHIP_OFF);
      break;
   case CPU_197: /* pcctwo is a child of buswitch XXX smurph */
      sc->sc_pcc2 = (struct pcctworeg *)sc->sc_vaddr;
      break;
   }
d213 4
a216 2
	pcc2intr_ipl = (u_char *)&(sc->sc_pcc2->pcc2_ipl);
	pcc2intr_mask = (u_char *)&(sc->sc_pcc2->pcc2_mask);
@


1.9
log
@Update vm interface to MACHIN_NEW_NONCONTIG.  Fix compile warning in pcctwo.c
@
text
@d2 1
a2 1
/*	$OpenBSD: pcctwo.c,v 1.8 2000/03/26 23:32:00 deraadt Exp $ */
d50 2
d53 1
a53 1
#include <machine/autoconf.h>
d56 1
a67 3
#ifdef MVME187
void	setupiackvectors __P((void));
#endif /* MVME187 */
d79 3
a86 1
	struct cfdata *cf = vcf;
d103 1
a103 1
   if (badvaddr(pcc2, 4) <= 0){
a134 1
	struct confargs *ca = args;
a167 1
	int i;
@


1.8
log
@callout.h is gone
@
text
@d2 1
a2 1
/*	$OpenBSD: pcctwo.c,v 1.7 1999/09/27 18:43:24 smurph Exp $ */
d144 1
a144 1
	if ((oca.ca_offset != (void*)-1) && ISIIOVA(sc->sc_vaddr + oca.ca_offset)) {
@


1.7
log
@adding support for MVME188 and MVME197.  Plus 32bit if_ie.
@
text
@d2 1
a2 1
/*	$OpenBSD: pcctwo.c,v 1.6 1999/05/29 04:41:44 smurph Exp $ */
a44 1
#include <sys/callout.h>
@


1.7.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d2 1
a2 1
/*	$OpenBSD: pcctwo.c,v 1.10 2001/03/08 00:03:14 miod Exp $ */
d45 1
d51 1
a51 1

a52 2
#include <machine/cpu.h>

a54 1
#include <mvme88k/dev/pcctwofunc.h>
d66 3
a79 3
int pcctwo_print __P((void *args, const char *bus));
int pcctwo_scan __P((struct device *parent, void *child, void *args));

d85 1
d102 1
a102 1
   if (badvaddr((vm_offset_t)pcc2, 4) <= 0){
d134 1
d145 1
a145 1
	if (((int)oca.ca_offset != -1) && ISIIOVA(sc->sc_vaddr + oca.ca_offset)) {
d168 1
@


1.7.4.2
log
@Merge in trunk
@
text
@d1 3
a3 1
/*	$OpenBSD$ */
a58 2
#include "bussw.h"

a78 2
int pcc2bus;

d84 2
a85 2
struct device *parent;
void *vcf, *args;
d91 15
a105 10
	switch (brdtyp) {
	case BRD_187:
		pcc2 = (struct pcctworeg *)(IIOV(ca->ca_paddr) + PCC2_PCC2CHIP_OFF);
		break;
	case BRD_197: /* pcctwo is a child of buswitch XXX smurph */
		pcc2 = (struct pcctworeg *)(IIOV(ca->ca_paddr));
		break;
	default:
		/* Bomb if wrong board */
		return (0);
d107 3
a109 8

	if (badvaddr((vm_offset_t)pcc2, 4)) {
		printf("==> pcctwo: failed address check.\n");
		return (0);
	}
	if (pcc2->pcc2_chipid != PCC2_CHIPID) {
		printf("==> pcctwo: wrong chip id %x.\n", pcc2->pcc2_chipid);
		return (0);
d163 2
a164 2
struct device *parent, *self;
void *args;
d178 8
a185 21
	
	pcc2bus = ca->ca_bustype;

	switch (pcc2bus) {
	case BUS_MAIN:
		sc->sc_pcc2 = (struct pcctworeg *)(sc->sc_vaddr + PCC2_PCC2CHIP_OFF);
		break;
#if NBUSSW > 0
	case BUS_BUSSWITCH:
		sc->sc_pcc2 = (struct pcctworeg *)sc->sc_vaddr;
		/* 
		 * fake up our address so that pcc2 child devices
		 * are offeset of 0xFFF00000 - XXX smurph
		 */
                sc->sc_paddr -= PCC2_PCC2CHIP_OFF;
                sc->sc_vaddr -= PCC2_PCC2CHIP_OFF;
                /* make sure the bus is mc68040 compatible */
		sc->sc_pcc2->pcc2_genctl |= PCC2_GENCTL_C040;	
		break;
#endif 
	}
d193 5
@


1.7.4.3
log
@Merge in -current from about a week ago
@
text
@d66 2
a67 2
void pcctwoattach(struct device *, struct device *, void *);
int  pcctwomatch(struct device *, void *, void *);
d81 2
a82 2
int pcctwo_print(void *args, const char *bus);
int pcctwo_scan(struct device *parent, void *child, void *args);
@


1.7.4.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pcctwo.c,v 1.7.4.3 2002/03/28 10:36:02 niklas Exp $ */
d14 6
@


1.7.4.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d68 1
a68 1
	NULL, "pcctwo", DV_DULL
d80 2
a81 2
	struct device *parent;
	void *vcf, *args;
a88 1
	case BRD_8120:
d99 1
a99 1
	if (badvaddr((vaddr_t)pcc2, 4)) {
d133 5
d174 1
a174 1

d184 1
a184 1
		/*
d191 1
a191 1
		sc->sc_pcc2->pcc2_genctl |= PCC2_GENCTL_C040;
d193 1
a193 1
#endif
@


1.7.4.6
log
@Merge with the trunk
@
text
@d28 1
a28 1
 * VME1x7 PCC2 chip
d48 1
a49 1
#include <mvme88k/dev/pcctwovar.h>
d53 9
a61 2
void	pcctwoattach(struct device *, struct device *, void *);
int	pcctwomatch(struct device *, void *, void *);
d71 6
a76 2
int	pcctwo_print(void *args, const char *bus);
int	pcctwo_scan(struct device *parent, void *child, void *args);
d84 1
a84 3
	bus_space_handle_t ioh;
	int rc;
	u_int8_t chipid;
d90 4
a93 1
	case BRD_197:
d96 2
a97 1
		return 0;
d100 3
a102 12
	if (bus_space_map(ca->ca_iot, ca->ca_paddr + PCC2_BASE, PCC2_SIZE,
	    0, &ioh) != 0)
		return 0;
	rc = badvaddr((vaddr_t)bus_space_vaddr(ca->ca_iot, ioh), 4);
	if (rc == 0) {
		chipid = bus_space_read_1(ca->ca_iot, ioh, PCCTWO_CHIPID);
		if (chipid != PCC2_ID) {
#ifdef DEBUG
			printf("==> pcctwo: wrong chip id %x.\n", chipid);
			rc = -1;
#endif
		}
d104 3
a106 20
	bus_space_unmap(ca->ca_iot, ioh, PCC2_SIZE);

	return rc == 0;
}

void
pcctwoattach(parent, self, args)
	struct device *parent, *self;
	void *args;
{
	struct confargs *ca = args;
	struct pcctwosoftc *sc = (struct pcctwosoftc *)self;
	bus_space_handle_t ioh;
	u_int8_t genctl;

	sc->sc_base = ca->ca_paddr + PCC2_BASE;

	if (bus_space_map(ca->ca_iot, sc->sc_base, PCC2_SIZE, 0, &ioh) != 0) {
		printf(": can't map registers!\n");
		return;
d108 1
a108 19

	sc->sc_iot = ca->ca_iot;
	sc->sc_ioh = ioh;

	bus_space_write_1(sc->sc_iot, ioh, PCCTWO_VECBASE, PCC2_VECBASE);
	genctl = bus_space_read_1(sc->sc_iot, ioh, PCCTWO_GENCTL);
#if NBUSSW > 0
	if (ca->ca_bustype == BUS_BUSSWITCH) {
                /* Make sure the bus is mc68040 compatible */
		genctl |= PCC2_GENCTL_C040;
	}
#endif
	genctl |= PCC2_GENCTL_IEN;	/* global irq enable */
	bus_space_write_1(sc->sc_iot, ioh, PCCTWO_GENCTL, genctl);

	printf(": rev %d\n",
	    bus_space_read_1(sc->sc_iot, ioh, PCCTWO_CHIPREV));

	config_search(pcctwo_scan, self, args);
d131 2
a132 1
	struct confargs oca, *ca = args;
a134 2
	oca.ca_iot = ca->ca_iot;
	oca.ca_dmat = ca->ca_dmat;
d137 3
a139 3
	if (oca.ca_offset != -1) {
		/* offset locator for pcctwo children is relative to segment */
		oca.ca_paddr = ca->ca_paddr + oca.ca_offset;
d141 2
a142 1
		oca.ca_paddr = -1;
d145 1
d153 48
d209 5
a213 6
#ifdef DIAGNOSTIC
	if (vec < 0 || vec >= PCC2_NVEC)
		panic("pcctwo_establish: illegal vector 0x%x\n", vec);
#endif

	return (intr_establish(PCC2_VECBASE + vec, ih));
@


1.6
log
@Added vme bus device drivers. MVME328, MVME376, MVME332
@
text
@d2 1
a2 1
/*	$OpenBSD: pcctwo.c,v 1.5 1998/12/15 05:52:30 smurph Exp $ */
d90 13
a102 7
	if (!(cputyp == CPU_187 || cputyp == CPU_188)){
	    printf("==> pcctwo: wrong CPU type %x.\n", cputyp);
	    return (0);
	}

	pcc2 = (struct pcctworeg *)(IIOV(ca->ca_paddr) + PCC2_PCC2CHIP_OFF);
	if (badvaddr(pcc2, 4) <= 0){
d179 8
a186 1
	sc->sc_pcc2 = (struct pcctworeg *)(sc->sc_vaddr + PCC2_PCC2CHIP_OFF);
a198 6

#ifdef MVME187
	printf("setting interrupt ack vectors.\n");
	setupiackvectors();
#endif /* MVME187 */

@


1.5
log
@Commit for the first real OpenBSD mvme88k port.
@
text
@d2 1
a2 1
/*	$OpenBSD: pcctwo.c,v 1.5 1996/11/23 21:46:00 kstailey Exp $ */
d90 1
a90 1
	if (cputyp != CPU_187){
@


1.4
log
@Cleanup after import. This also seems to bring up the current version.
@
text
@d1 37
d39 5
d45 1
d47 3
d53 1
d58 4
a61 2
	struct device		sc_dev;
	volatile struct pcc2reg *sc_pcc2reg;
d64 2
a65 4
int	pcctwomatch	__P((struct device *, void *, void *));
int	pcctwoscan	__P((struct device *, void *, void *));
void	pcctwoattach	__P((struct device *, struct device *, void *));

d70 2
a71 2
struct cfattach pcctwo_ca = { 
        sizeof(struct pcctwosoftc), pcctwomatch, pcctwoattach
d75 4
a78 2
        NULL, "pcctwo", DV_DULL, 0
}; 
a79 1
/*ARGSUSED*/
d81 3
a83 1
pcctwomatch(struct device *parent, void *self, void *aux)
d85 18
a102 26
	int 		ret;
	u_char		id, rev; 
	caddr_t		base;
	struct confargs *ca = aux;
	struct cfdata *cf = self;
	
#if 0
	if (cputyp != CPU_167 && cputyp != CPU_166
#ifdef MVME187
		&& cputyp != CPU_187
#endif
		)
	{
		return 0;
	}
#endif /* 0 */
	if (cputyp != CPU_187) {
		return 0;
	}
	
	/* 
	 * If bus or name do not match, fail.
	 */
	if (ca->ca_bustype != BUS_MAIN ||
		strcmp(cf->cf_driver->cd_name, "pcctwo")) {
		return 0;
d104 1
a104 16

	if ((base = (caddr_t)cf->cf_loc[0]) == (caddr_t)-1) {
		return 0;
	}

	id  = badpaddr(base, 1);
	rev = badpaddr(base + 1, 1);

	if (id != PCC2_CHIP_ID || rev != PCC2_CHIP_REV) {
		return 0;
	}

	ca->ca_size = PCC2_SIZE;
	ca->ca_paddr = base;

	return 1;
d108 3
a110 1
pcctwoprint(void *aux, char *parent)
d112 1
a112 11
	struct confargs *ca = aux;

	/*
	 * We call pcctwoprint() via config_attach(). Parent
	 * will always be null and config_attach() would have already
	 * printed "nvram0 at pcctwo0".
	 */
	printf(" addr %x size %x", ca->ca_paddr, ca->ca_size);
	if (ca->ca_ipl != -1) {
		printf(" ipl %x", ca->ca_ipl);
	}
d114 4
a120 1
/*ARGSUSED*/
d122 3
a124 1
pcctwoscan(struct device *parent, void *self, void *aux)
d126 1
a126 2
	struct confargs ca;
	struct cfdata *cf = self;
d128 2
d131 22
a152 55
	/*
	 * Pcctwoscan gets called by config_search() for each
	 * child of parent (pcctwo) specified in ioconf.c.
	 * Fill in the bus type to be PCCTWO and call the child's
	 * match routine. If the child's match returns 1, then
	 * we need to allocate device memory, set it in confargs
	 * and call config_attach(). This, in turn, will call the
	 * child's attach.
	 */

	ca.ca_bustype = BUS_PCCTWO;
	
	if ((*cf->cf_attach->ca_match)(parent, cf, &ca) == 0)
		return 0;
	
	/*
	 * The child would have fixed up ca to reflect what its
	 * requirements are.
	 */
	
	if (cf->cf_loc[2] != ca.ca_ipl) {
		printf("Changing ipl %x specified in ioconf.c to %x for %s\n",
			cf->cf_loc[2], ca.ca_ipl, cf->cf_driver->cd_name);
	}

	/*
	 * If the size specified by the child is 0, don't map
	 * any IO space, but pass in the address of pcc2reg as vaddr.
	 * This is for clock and parallel port which don't have a
	 * separate address space by themselves but use pcc2's register
	 * block.
	 */
	if (ca.ca_size == 0) {
		/*
		 * pcc2regs addr
		 */
#if 0
		ca.ca_vaddr = ((struct confargs *)aux)->ca_vaddr;
#endif /* 0 */
		ca.ca_vaddr = (caddr_t)sc->sc_pcc2reg;

	} else  {
		ca.ca_vaddr = ca.ca_paddr;
	}

#if 0
	ca.ca_parent = ((struct confargs *)aux)->ca_vaddr;
#endif /* 0 */
	ca.ca_parent = (caddr_t)sc->sc_pcc2reg;

	/*
	 * Call child's attach using config_attach().
	 */
	config_attach(parent, cf, &ca, pcctwoprint);
	return 1;
a154 7
/*
 * This function calls the match routine of the configured children
 * in turn. For each configured child, map the device address into
 * iomap space and then call config_attach() to attach the child.
 */

/* ARGSUSED */
d156 3
a158 1
pcctwoattach(struct device *parent, struct device *self, void *aux)
d160 3
a162 8
	struct pcctwosoftc	*sc = (struct pcctwosoftc *)self;
	struct confargs		*ca = aux;
	caddr_t	base;

	if (self->dv_unit > 0) {
		printf(" unsupported\n");
		return;
	}
d164 2
a165 4
	base = ca->ca_vaddr;

	printf(": PCCTWO id 0x%2x rev 0x%2x\n",
		*(u_char *)base, *((u_char *)base + 1));
d168 2
a169 2
	 * mainbus driver would have mapped Pcc2 at base. Save
	 * the address in pcctwosoftc.
d171 9
a179 1
	sc->sc_pcc2reg = (struct pcc2reg *)base;
d184 2
a185 2
	pcc2intr_ipl = (u_char *)&(sc->sc_pcc2reg->pcc2_ipl);
	pcc2intr_mask = (u_char *)&(sc->sc_pcc2reg->pcc2_imask);
d188 1
a188 6
	/*
	 * Get mappings for iack vectors. This doesn't belong here
	 * but is more closely related to pcc than anything I can
	 * think of. (could probably do it in locore.s).
	 */
	
d192 16
a207 1
	(void)config_search(pcctwoscan, self, aux);
@


1.3
log
@This is a remove to get rid of the old mvme88k port which was incomplete
to replace it with a working version. The kernel compiles and works
at least.  The new version will be imported shortly.
@
text
@a0 35
/*	$NetBSD$ */

/*
 * Copyright (c) 1995 Theo de Raadt
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Theo de Raadt
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * VME16x PCC2 chip
 */
a1 5
#include <sys/conf.h>
#include <sys/ioctl.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/tty.h>
a2 1
#include <sys/callout.h>
a3 3
#include <sys/kernel.h>
#include <sys/syslog.h>
#include <sys/fcntl.h>
a6 2
#include <dev/cons.h>
#include <mvme68k/mvme68k/isr.h>
d8 1
a8 1
#include <mvme68k/dev/pcctworeg.h>
d11 2
a12 5
	struct device	sc_dev;
	caddr_t		sc_vaddr;
	caddr_t		sc_paddr;
	struct pcctworeg *sc_pcc2;
	struct intrhand	sc_nmiih;
d15 10
a24 7
void pcctwoattach __P((struct device *, struct device *, void *));
int  pcctwomatch __P((struct device *, void *, void *));
int  pcctwoabort __P((struct frame *));

struct cfdriver pcctwocd = {
	NULL, "pcctwo", pcctwomatch, pcctwoattach,
	DV_DULL, sizeof(struct pcctwosoftc), 0
d27 35
a61 1
struct pcctworeg *sys_pcc2 = NULL;
d63 6
a68 1
struct intrhand *pcctwointrs[PCC2_NVEC];
d70 8
a77 18
int
pcctwomatch(parent, vcf, args)
	struct device *parent;
	void *vcf, *args;
{
	struct cfdata *cf = vcf;
	struct confargs *ca = args;
	struct pcctworeg *pcc2;

	/* the PCC2 only exists on MVME16x's except the 162, right? */
	if (cputyp == CPU_162 || cputyp == CPU_147)
		return (0);
	pcc2 = (struct pcctworeg *)(IIOV(ca->ca_paddr) + PCC2_PCC2CHIP_OFF);
	if (badbaddr(pcc2))
		return (0);
	if (pcc2->pcc2_chipid != PCC2_CHIPID)
		return (0);
	return (1);
d81 1
a81 3
pcctwo_print(args, bus)
	void *args;
	const char *bus;
d83 11
a93 1
	struct confargs *ca = args;
a94 3
	printf(" offset 0x%x", ca->ca_offset);
	if (ca->ca_ipl > 0)
		printf(" ipl %d", ca->ca_ipl);
d98 1
d100 1
a100 3
pcctwo_scan(parent, child, args)
	struct device *parent;
	void *child, *args;
d102 2
a103 1
	struct cfdata *cf = child;
a104 2
	struct confargs *ca = args;
	struct confargs oca;
d106 9
a114 34
	if (parent->dv_cfdata->cf_driver->cd_indirect) {
                printf(" indirect devices not supported\n");
                return 0;
        }

	bzero(&oca, sizeof oca);
	oca.ca_paddr = sc->sc_paddr + cf->cf_loc[0];
	if (ISIIOVA(sc->sc_vaddr + cf->cf_loc[0]))
		oca.ca_vaddr = sc->sc_vaddr + cf->cf_loc[0];
	else
		oca.ca_vaddr = (caddr_t)-1;
	oca.ca_offset = cf->cf_loc[0];
	oca.ca_ipl = cf->cf_loc[1];
	oca.ca_bustype = BUS_PCCTWO;
	oca.ca_master = (void *)sc->sc_pcc2;
	oca.ca_name = cf->cf_driver->cd_name;
	if ((*cf->cf_driver->cd_match)(parent, cf, &oca) == 0)
		return (0);
	config_attach(parent, cf, &oca, pcctwo_print);
	return (1);
}

void
pcctwoattach(parent, self, args)
	struct device *parent, *self;
	void *args;
{
	struct confargs *ca = args;
	struct pcctwosoftc *sc = (struct pcctwosoftc *)self;
	extern u_long vectab[], pcctwotrap;
	int i;

	if (sys_pcc2)
		panic("pcc2 already attached!");
d116 5
d122 2
a123 2
	 * since we know ourself to land in intiobase land,
	 * we must adjust our address
d125 5
a129 6
	sc->sc_paddr = ca->ca_paddr;
	sc->sc_vaddr = (caddr_t)IIOV(sc->sc_paddr);
	sc->sc_pcc2 = (struct pcctworeg *)(sc->sc_vaddr + PCC2_PCC2CHIP_OFF);
	sys_pcc2 = sc->sc_pcc2;

	printf(": rev %d\n", sc->sc_pcc2->pcc2_chiprev);
d132 5
a136 1
	 * make the PCCTWO interrupt range point to the pcc2 trap routine.
d138 11
a148 2
	for (i = 0; i < PCC2_NVEC; i++) {
		vectab[PCC2_VECBASE+i] = (u_long)&pcctwotrap;
d151 4
a154 1
	sc->sc_pcc2->pcc2_genctl |= PCC2_GENCTL_IEN;	/* global irq enable */
d156 5
a160 11
	sys_pcc2->pcc2_gpioirq  = PCC2_GPIO_PLTY | PCC2_IRQ_IEN | 0x7;/*lvl7*/ 
	sys_pcc2->pcc2_gpio = 0; /* do not turn on CR_O or CR_OE */
	sc->sc_nmiih.ih_fn = pcctwoabort;
	sc->sc_nmiih.ih_arg = 0;
	sc->sc_nmiih.ih_lvl = 7;
	sc->sc_nmiih.ih_wantframe = 1;
	/*sc->sc_mc->mc_abort .... enable at ipl 7 */
	pcctwointr_establish(PCC2V_GPIO, &sc->sc_nmiih);

	sc->sc_pcc2->pcc2_vecbase = PCC2_VECBASE;
	config_search(pcctwo_scan, self, args);
a162 1
#ifndef PCCTWOINTR_ASM
d164 3
a166 1
 * pcctwointr: called from locore with the PC and evec from the trap frame.
d168 4
a171 5
int
pcctwointr(pc, evec, frame)
	int pc;
	int evec;
	void *frame;
d173 7
a179 17
	int vec = (evec & 0xfff) >> 2;	/* XXX should be m68k macro? */
	extern u_long intrcnt[];	/* XXX from locore */
	struct intrhand *ih;
	int r;

	vec = vec & 0xf;
	if (vec >= PCC2_NVEC)
		goto bail;

	cnt.v_intr++;
	for (ih = pcctwointrs[vec]; ih; ih = ih->ih_next) {
		if (ih->ih_wantframe)
			r = (*ih->ih_fn)(frame);
		else
			r = (*ih->ih_fn)(ih->ih_arg);
		if (r > 0)
			return;
a180 4
bail:
	return (straytrap(pc, evec));
}
#endif /* !PCCTWOINTR_ASM */
d182 10
a191 12
/*
 * pcctwointr_establish: establish pcctwo interrupt
 */
int
pcctwointr_establish(vec, ih)
	int vec;
	struct intrhand *ih;
{
	if (vec >= PCC2_NVEC) {
		printf("pcctwo: illegal vector: 0x%x\n", vec);
		panic("pcctwointr_establish");
	}
d193 5
a197 13
	/* XXX should attach at tail */
	ih->ih_next = pcctwointrs[vec];
	pcctwointrs[vec] = ih;
}
int
pcctwoabort(frame)
	struct frame *frame;
{
#ifdef REALLY_CARE_ABOUT_DEBOUNCE
	/* wait for it to debounce */
	while (sys_pcc2->pcc2_abortirq & PCC2_ABORT_ABS)
		;
#endif
d199 9
a207 1
	sys_pcc2->pcc2_gpioirq = sys_pcc2->pcc2_gpioirq | PCC2_IRQ_ICLR;
d209 1
a209 2
	nmihand(frame);
	return (1);
@


1.2
log
@added const to second parameter of cfprint_t routines
@
text
@@


1.1
log
@Initial revision
@
text
@d100 1
a100 1
	char *bus;
@


1.1.1.1
log
@initial 88k import; code by nivas and based on mach luna88k
@
text
@@


1.1.1.2
log
@Third try at importing the mvme88k port. This is a working kernel
from nivas.
Userland and compiler still need to be worked on.
Make certain what directory the import is done from.
@
text
@d1 35
d37 5
d43 1
d45 3
d51 2
d54 1
a54 1
#include <mvme88k/dev/pcctworeg.h>
d57 5
a61 2
	struct device		sc_dev;
	volatile struct pcc2reg *sc_pcc2reg;
d64 7
a70 10
int	pcctwomatch	__P((struct device *, void *, void *));
int	pcctwoscan	__P((struct device *, void *, void *));
void	pcctwoattach	__P((struct device *, struct device *, void *));

#ifdef MVME187
void	setupiackvectors __P((void));
#endif /* MVME187 */

struct cfattach pcctwo_ca = { 
        sizeof(struct pcctwosoftc), pcctwomatch, pcctwoattach
d73 1
a73 35
struct cfdriver pcctwo_cd = {
        NULL, "pcctwo", DV_DULL, 0
}; 

/*ARGSUSED*/
int
pcctwomatch(struct device *parent, void *self, void *aux)
{
	int 		ret;
	u_char		id, rev; 
	caddr_t		base;
	struct confargs *ca = aux;
	struct cfdata *cf = self;
	
#if 0
	if (cputyp != CPU_167 && cputyp != CPU_166
#ifdef MVME187
		&& cputyp != CPU_187
#endif
		)
	{
		return 0;
	}
#endif /* 0 */
	if (cputyp != CPU_187) {
		return 0;
	}
	
	/* 
	 * If bus or name do not match, fail.
	 */
	if (ca->ca_bustype != BUS_MAIN ||
		strcmp(cf->cf_driver->cd_name, "pcctwo")) {
		return 0;
	}
d75 1
a75 3
	if ((base = (caddr_t)cf->cf_loc[0]) == (caddr_t)-1) {
		return 0;
	}
d77 18
a94 11
	id  = badpaddr(base, 1);
	rev = badpaddr(base + 1, 1);

	if (id != PCC2_CHIP_ID || rev != PCC2_CHIP_REV) {
		return 0;
	}

	ca->ca_size = PCC2_SIZE;
	ca->ca_paddr = base;

	return 1;
d98 3
a100 1
pcctwoprint(void *aux, char *parent)
d102 1
a102 11
	struct confargs *ca = aux;

	/*
	 * We call pcctwoprint() via config_attach(). Parent
	 * will always be null and config_attach() would have already
	 * printed "nvram0 at pcctwo0".
	 */
	printf(" addr %x size %x", ca->ca_paddr, ca->ca_size);
	if (ca->ca_ipl != -1) {
		printf(" ipl %x", ca->ca_ipl);
	}
d104 3
a109 1
/*ARGSUSED*/
d111 3
a113 1
pcctwoscan(struct device *parent, void *self, void *aux)
d115 1
a115 2
	struct confargs ca;
	struct cfdata *cf = self;
d117 37
d156 2
a157 7
	 * Pcctwoscan gets called by config_search() for each
	 * child of parent (pcctwo) specified in ioconf.c.
	 * Fill in the bus type to be PCCTWO and call the child's
	 * match routine. If the child's match returns 1, then
	 * we need to allocate device memory, set it in confargs
	 * and call config_attach(). This, in turn, will call the
	 * child's attach.
d159 6
a165 5
	ca.ca_bustype = BUS_PCCTWO;
	
	if ((*cf->cf_attach->ca_match)(parent, cf, &ca) == 0)
		return 0;
	
d167 1
a167 2
	 * The child would have fixed up ca to reflect what its
	 * requirements are.
d169 2
a170 4
	
	if (cf->cf_loc[2] != ca.ca_ipl) {
		printf("Changing ipl %x specified in ioconf.c to %x for %s\n",
			cf->cf_loc[2], ca.ca_ipl, cf->cf_driver->cd_name);
d173 1
a173 15
	/*
	 * If the size specified by the child is 0, don't map
	 * any IO space, but pass in the address of pcc2reg as vaddr.
	 * This is for clock and parallel port which don't have a
	 * separate address space by themselves but use pcc2's register
	 * block.
	 */
	if (ca.ca_size == 0) {
		/*
		 * pcc2regs addr
		 */
#if 0
		ca.ca_vaddr = ((struct confargs *)aux)->ca_vaddr;
#endif /* 0 */
		ca.ca_vaddr = (caddr_t)sc->sc_pcc2reg;
d175 8
a182 3
	} else  {
		ca.ca_vaddr = ca.ca_paddr;
	}
d184 3
a186 4
#if 0
	ca.ca_parent = ((struct confargs *)aux)->ca_vaddr;
#endif /* 0 */
	ca.ca_parent = (caddr_t)sc->sc_pcc2reg;
d188 30
a217 5
	/*
	 * Call child's attach using config_attach().
	 */
	config_attach(parent, cf, &ca, pcctwoprint);
	return 1;
d219 1
d222 1
a222 3
 * This function calls the match routine of the configured children
 * in turn. For each configured child, map the device address into
 * iomap space and then call config_attach() to attach the child.
d224 4
a227 4

/* ARGSUSED */
void
pcctwoattach(struct device *parent, struct device *self, void *aux)
d229 3
a231 7
	struct pcctwosoftc	*sc = (struct pcctwosoftc *)self;
	struct confargs		*ca = aux;
	caddr_t	base;

	if (self->dv_unit > 0) {
		printf(" unsupported\n");
		return;
d234 13
a246 10
	base = ca->ca_vaddr;

	printf(": PCCTWO id 0x%2x rev 0x%2x\n",
		*(u_char *)base, *((u_char *)base + 1));

	/*
	 * mainbus driver would have mapped Pcc2 at base. Save
	 * the address in pcctwosoftc.
	 */
	sc->sc_pcc2reg = (struct pcc2reg *)base;
d248 1
a248 15
	/*
	 * Set pcc2intr_mask and pcc2intr_ipl.
	 */
	pcc2intr_ipl = (u_char *)&(sc->sc_pcc2reg->pcc2_ipl);
	pcc2intr_mask = (u_char *)&(sc->sc_pcc2reg->pcc2_imask);

#ifdef MVME187
	/*
	 * Get mappings for iack vectors. This doesn't belong here
	 * but is more closely related to pcc than anything I can
	 * think of. (could probably do it in locore.s).
	 */
	
	setupiackvectors();
#endif /* MVME187 */
d250 2
a251 1
	(void)config_search(pcctwoscan, self, aux);
@
