head	1.22;
access;
symbols
	OPENBSD_5_5:1.21.0.6
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.2
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.20.0.2
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.19.0.8
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.6
	OPENBSD_5_0:1.19.0.4
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.2
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.18.0.12
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.8
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.10
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.6
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.4
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.2
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.17.0.6
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.4
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.13.0.4
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.6
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.9
	UBC:1.8.0.4
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.4.0.8
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.6
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.4
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.1.1.1.0.8
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.6
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.4
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.2
	OPENBSD_2_1_BASE:1.1.1.1
	mvme88kport:1.1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2014.03.18.22.36.35;	author miod;	state dead;
branches;
next	1.21;

1.21
date	2013.05.14.20.30.47;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2013.01.05.11.20.56;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2010.12.23.20.05.08;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2007.12.15.19.35.50;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2006.05.02.21.43.08;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2005.12.11.21.45.31;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2005.10.13.19.43.43;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2005.04.30.16.42.37;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2004.04.12.13.14.54;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2004.01.29.00.40.10;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2004.01.04.01.14.04;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2003.09.01.19.14.01;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.05.22.11.37;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.24.22.46.23;	author miod;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	2001.03.09.05.44.38;	author smurph;	state Exp;
branches;
next	1.6;

1.6
date	2001.02.12.08.16.21;	author smurph;	state Exp;
branches;
next	1.5;

1.5
date	2001.02.01.03.38.13;	author smurph;	state Exp;
branches;
next	1.4;

1.4
date	99.09.27.18.43.21;	author smurph;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	99.05.29.04.41.42;	author smurph;	state Exp;
branches;
next	1.2;

1.2
date	98.12.15.05.52.29;	author smurph;	state Exp;
branches;
next	1.1;

1.1
date	97.03.03.19.32.08;	author rahnds;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.03.03.19.32.08;	author rahnds;	state Exp;
branches;
next	;

1.4.4.1
date	2001.04.18.16.10.52;	author niklas;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2001.10.31.03.01.18;	author nate;	state Exp;
branches;
next	1.4.4.3;

1.4.4.3
date	2002.03.06.01.08.05;	author niklas;	state Exp;
branches;
next	1.4.4.4;

1.4.4.4
date	2004.02.19.10.49.06;	author niklas;	state Exp;
branches;
next	1.4.4.5;

1.4.4.5
date	2004.06.05.23.09.48;	author niklas;	state Exp;
branches;
next	;

1.8.4.1
date	2002.06.11.03.37.09;	author art;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: bugio.c,v 1.21 2013/05/14 20:30:47 miod Exp $ */
/*
 * Copyright (c) 2006, 2010, Miodrag Vallat.
 * Copyright (c) 1998 Steve Murphree, Jr.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>

#include <machine/asm_macro.h>
#include <machine/bugio.h>
#include <machine/prom.h>

register_t ossr3;
register_t bugsr3;

#ifdef MULTIPROCESSOR
#include <sys/lock.h>
__cpu_simple_lock_t bug_lock = __SIMPLELOCK_UNLOCKED;
#define	BUG_LOCK()	__cpu_simple_lock(&bug_lock)
#define	BUG_UNLOCK()	__cpu_simple_unlock(&bug_lock)
#else
#define	BUG_LOCK()	do { } while (0)
#define	BUG_UNLOCK()	do { } while (0)
#endif

#define MVMEPROM_CALL(x)						\
	__asm__ __volatile__ ("or %%r9,%%r0," __STRING(x) "; tb0 0,%%r0,496"	\
	    :::	"r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8",		\
	        "r9", "r10", "r11", "r12", "r13", "memory")

#define	BUGCTXT()							\
{									\
	BUG_LOCK();							\
	psr = get_psr();						\
	set_psr(psr | PSR_IND);			/* paranoia */		\
	__asm__ __volatile__ ("ldcr %0, %%cr20" : "=r" (ossr3));		\
	__asm__ __volatile__ ("stcr %0, %%cr20" :: "r"(bugsr3));		\
}

#define	OSCTXT()							\
{									\
	__asm__ __volatile__ ("ldcr %0, %%cr20" : "=r" (bugsr3));		\
	__asm__ __volatile__ ("stcr %0, %%cr20" :: "r"(ossr3));		\
	set_psr(psr);							\
	BUG_UNLOCK();							\
}

void
buginit()
{
	__asm__ __volatile__ ("ldcr %0, %%cr20" : "=r" (bugsr3));
}

char
buginchr(void)
{
	u_int psr;
	int ret;

#ifdef DIAGNOSTIC
	if (!cold)
		panic("%s: BUG calls are forbidden at this point", __func__);
#endif

	BUGCTXT();
	MVMEPROM_CALL(MVMEPROM_INCHR);
	__asm__ __volatile__ ("or %0,%%r0,%%r2" : "=r" (ret));
	OSCTXT();
	return ((char)ret & 0xff);
}

void
bugoutchr(int c)
{
	u_int psr;

#ifdef DIAGNOSTIC
	if (!cold)
		panic("%s: BUG calls are forbidden at this point", __func__);
#endif

	BUGCTXT();
	__asm__ __volatile__ ("or %%r2,%%r0,%0" : : "r" (c));
	MVMEPROM_CALL(MVMEPROM_OUTCHR);
	OSCTXT();
}

void
bugreturn(void)
{
	u_int psr;

#ifdef DIAGNOSTIC
	if (!cold)
		panic("%s: BUG calls are forbidden at this point", __func__);
#endif

	BUGCTXT();
	MVMEPROM_CALL(MVMEPROM_EXIT);
	OSCTXT();
}

void
bugbrdid(struct mvmeprom_brdid *id)
{
	u_int psr;
	struct mvmeprom_brdid *ptr;

#ifdef DIAGNOSTIC
	if (!cold)
		panic("%s: BUG calls are forbidden at this point", __func__);
#endif

	BUGCTXT();
	MVMEPROM_CALL(MVMEPROM_GETBRDID);
	__asm__ __volatile__ ("or %0,%%r0,%%r2" : "=r" (ptr));
	OSCTXT();

	bcopy(ptr, id, sizeof(struct mvmeprom_brdid));
}

void
bugdiskrd(struct mvmeprom_dskio *dio)
{
	u_int psr;

#ifdef DIAGNOSTIC
	if (!cold)
		panic("%s: BUG calls are forbidden at this point", __func__);
#endif

	BUGCTXT();
	__asm__ __volatile__ ("or %%r2, %%r0, %0" : : "r" (dio));
	MVMEPROM_CALL(MVMEPROM_DSKRD);
	OSCTXT();
}

#ifdef MULTIPROCESSOR

/*
 * Ask the BUG to start a particular cpu at our provided address.
 */
int
spin_cpu(cpuid_t cpu, vaddr_t address)
{
	u_int psr;
	int ret;

#ifdef DIAGNOSTIC
	if (!cold)
		panic("%s: BUG calls are forbidden at this point", __func__);
#endif

	BUGCTXT();
	__asm__ __volatile__ ("or %%r2, %%r0, %0; or %%r3, %%r0, %1" ::
	    "r" (cpu), "r" (address));
	MVMEPROM_CALL(MVMEPROM_FORKMPU);
	__asm__ __volatile__ ("or %0,%%r0,%%r2" : "=r" (ret));
	OSCTXT();

	return (ret);
}

#endif	/* MULTIPROCESSOR */
@


1.21
log
@Older BUG version do not implement the `out cr/lf' BUG system call, and, worse,
do not return from it, for extra fun. The good thing is that the existing
kernel console code logic issueing \n as \r\n works nicely with the regular
BUG output routines, so there was no reason to use this particular BUG routine
in the first place.
@
text
@d1 1
a1 1
/*	$OpenBSD: bugio.c,v 1.20 2013/01/05 11:20:56 miod Exp $ */
@


1.20
log
@Switch m88k ports to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: bugio.c,v 1.19 2010/12/23 20:05:08 miod Exp $ */
a67 15
}

void
bugpcrlf(void)
{
	u_int psr;

#ifdef DIAGNOSTIC
	if (!cold)
		panic("%s: BUG calls are forbidden at this point", __func__);
#endif

	BUGCTXT();
	MVMEPROM_CALL(MVMEPROM_OUTCRLF);
	OSCTXT();
@


1.19
log
@The exception vector page on m88k systems has always been the same page as
the one used by the firmware, which (at least on mvme88k) is at address zero.

This is unfortunate, since this means that NULL pointer dereferences in the
kernel are not caught, and writes cause havoc.

This behaviour was necessary to be able to use the PROM system call interface
during early bootstrap, without having to disassemble the VBR page and
update branches - which use pc-relative displacement - if we were to use
a different VBR address.

On mvme88k, change this and actually set up two VBR pages: one, over the PROM
page (except for the system call vectors), and another one in the kernel
image (which will be mapped read-only). We'll run with the PROM page until
the end of autoconf, and then switch to the kernel one, and unmap all the
PROM below it.

As a bonus, the final kernel page can use optimized data access fault
handlers, which do not have to check for faults caused by badaddr(), since
badaddr() is only used during device probe on buses which do not support
hotplug.

There are a few infrastructure collateral damage on aviion and luna88k, but
these ports do not change their behaviour yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: bugio.c,v 1.18 2007/12/15 19:35:50 miod Exp $ */
d49 1
a49 1
	__asm__ __volatile__ ("or r9,r0," __STRING(x) "; tb0 0,r0,496"	\
d58 2
a59 2
	__asm__ __volatile__ ("ldcr %0, cr20" : "=r" (ossr3));		\
	__asm__ __volatile__ ("stcr %0, cr20" :: "r"(bugsr3));		\
d64 2
a65 2
	__asm__ __volatile__ ("ldcr %0, cr20" : "=r" (bugsr3));		\
	__asm__ __volatile__ ("stcr %0, cr20" :: "r"(ossr3));		\
d88 1
a88 1
	__asm__ __volatile__ ("ldcr %0, cr20" : "=r" (bugsr3));
d104 1
a104 1
	__asm__ __volatile__ ("or %0,r0,r2" : "=r" (ret));
d120 1
a120 1
	__asm__ __volatile__ ("or r2,r0,%0" : : "r" (c));
d153 1
a153 1
	__asm__ __volatile__ ("or %0,r0,r2" : "=r" (ptr));
d170 1
a170 1
	__asm__ __volatile__ ("or r2, r0, %0" : : "r" (dio));
d192 1
a192 1
	__asm__ __volatile__ ("or r2, r0, %0; or r3, r0, %1" ::
d195 1
a195 1
	__asm__ __volatile__ ("or %0,r0,r2" : "=r" (ret));
@


1.18
log
@All MVME BUG manuals concur on SR3 being the only register needing to be
preserved across BUG calls, but on the other hand the last 16 traps need to
be restored to BUG values, not only trap #496.
@
text
@d1 26
a26 2
/*	$OpenBSD: bugio.c,v 1.17 2006/05/02 21:43:08 miod Exp $ */
/*  Copyright (c) 1998 Steve Murphree, Jr. */
a37 5
unsigned long bugvec[32], sysbugvec[32];

void bug_vector(void);
void sysbug_vector(void);

d49 3
a51 26
	__asm__ __volatile__ ("or r9,r0," __STRING(x));			\
	__asm__ __volatile__ ("tb0 0,r0,496" :::			\
	    "r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8",		\
	    "r9", "r10", "r11", "r12", "r13")

void
bug_vector()
{
	unsigned long *vbr;
	int i;

	__asm__ __volatile__ ("ldcr %0, cr7" : "=r" (vbr));
	for (i = 0; i < 32; i++)
		vbr[2 * MVMEPROM_VECTOR + i] = bugvec[i];
}

void
sysbug_vector()
{
	unsigned long *vbr;
	int i;

	__asm__ __volatile__ ("ldcr %0, cr7" : "=r" (vbr));
	for (i = 0; i < 32; i++)
		vbr[2 * MVMEPROM_VECTOR + i] = sysbugvec[i];
}
a57 1
	bug_vector();							\
a65 1
	sysbug_vector();						\
d75 5
d97 5
d114 5
d130 5
d146 5
d164 5
d186 5
d192 2
a193 2
	__asm__ __volatile__ ("or r2, r0, %0" : : "r" (cpu));
	__asm__ __volatile__ ("or r3, r0, %0" : : "r" (address));
@


1.17
log
@Wave goodbye to bugtty on mvme88k as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: bugio.c,v 1.16 2005/12/11 21:45:31 miod Exp $ */
d11 1
a11 1
register_t ossr0, ossr1, ossr2, ossr3;
d14 1
a14 1
unsigned long bugvec[2], sysbugvec[2];
d39 1
d42 2
a43 2
	vbr[2 * MVMEPROM_VECTOR + 0] = bugvec[0];
	vbr[2 * MVMEPROM_VECTOR + 1] = bugvec[1];
d50 1
d53 2
a54 2
	vbr[2 * MVMEPROM_VECTOR + 0] = sysbugvec[0];
	vbr[2 * MVMEPROM_VECTOR + 1] = sysbugvec[1];
d60 2
a61 1
	disable_interrupt(psr);			/* paranoia */		\
a62 3
	__asm__ __volatile__ ("ldcr %0, cr17" : "=r" (ossr0));		\
	__asm__ __volatile__ ("ldcr %0, cr18" : "=r" (ossr1));		\
	__asm__ __volatile__ ("ldcr %0, cr19" : "=r" (ossr2));		\
a63 1
									\
a69 4
									\
	__asm__ __volatile__ ("stcr %0, cr17" :: "r"(ossr0));		\
	__asm__ __volatile__ ("stcr %0, cr18" :: "r"(ossr1));		\
	__asm__ __volatile__ ("stcr %0, cr19" :: "r"(ossr2));		\
@


1.16
log
@Work in progress SMP code; mvme88k boards can spin up secondary CPUs,
kernel boots single user. Still a lot of polishing and bugfixing to do.
@
text
@d1 1
a1 1
/*	$OpenBSD: bugio.c,v 1.15 2005/10/13 19:43:43 miod Exp $ */
d81 1
a81 1
static void
d111 1
a111 1
bugoutchr(unsigned char c)
a113 6
	unsigned char cc;

	if ((cc = c) == '\n') {
		bugpcrlf();
		return;
	}
d116 1
a116 1
	__asm__ __volatile__ ("or r2,r0,%0" : : "r" (cc));
a117 34
	OSCTXT();
}

/* return 1 if not empty else 0 */
int
buginstat(void)
{
	u_int psr;
	int ret;

	BUGCTXT();
	MVMEPROM_CALL(MVMEPROM_INSTAT);
	__asm__ __volatile__  ("or %0,r0,r2" : "=r" (ret));
	OSCTXT();
	return ((ret & 0x08) >> 3);
}

void
bugoutstr(char *s, char *se)
{
	u_int psr;

	BUGCTXT();
	MVMEPROM_CALL(MVMEPROM_OUTSTR);
	OSCTXT();
}

void
bugrtcrd(struct mvmeprom_time *rtc)
{
	u_int psr;

	BUGCTXT();
	MVMEPROM_CALL(MVMEPROM_RTC_RD);
@


1.15
log
@Put the register clobbering constraints on the BUG trap instruction,
not the first ldcr; hopefully gcc did not dare optimizing too much around
here, so this should not change anything in practice.

test martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bugio.c,v 1.14 2005/04/30 16:42:37 miod Exp $ */
d11 1
a11 1
register_t ossr0, ossr1, ossr2, ossr3;	/* XXX ought to be per-cpu */
d19 10
d57 1
d78 1
d138 1
a138 1
	return (ret & 0x4 ? 0 : 1);
d195 23
@


1.14
log
@Remove m88k_psr_type and function with utterly long names to control the psr,
and use get_psr() / set_psr() or simple macros that expand into them everywhere.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: bugio.c,v 1.13 2004/04/12 13:14:54 miod Exp $ */
d11 1
a11 1
register_t ossr0, ossr1, ossr2, ossr3;
d21 3
a23 1
	__asm__ __volatile__ ("tb0 0,r0,496")
d28 1
a28 3
	unsigned long *vbr, psr;

	disable_interrupt(psr);			/* paranoia */
a32 2

	set_psr(psr);
d38 1
a38 3
	unsigned long *vbr, psr;

	disable_interrupt(psr);			/* paranoia */
a42 2

	set_psr(psr);
d47 1
d59 1
a59 3
	__asm__ __volatile__ ("ldcr %0, cr20" : "=r" (bugsr3)::		\
	    "r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8",		\
	    "r9", "r10", "r11", "r12", "r13");				\
d66 1
d72 2
d88 1
d90 1
d93 1
a93 1
	__asm__ __volatile__ ("or %0,r0,r2" : "=r" (ret) : );
d95 1
a95 1
	return ((char)ret & 0xFF);
d101 1
d119 2
a120 1
	register int ret;
d124 1
a124 1
	__asm__ __volatile__  ("or %0,r0,r2" : "=r" (ret) : );
d132 2
d142 2
d152 2
d162 1
d167 1
a167 1
	__asm__ __volatile__ ("or %0,r0,r2" : "=r" (ptr) : );
d176 2
@


1.13
log
@Minor tweaks to appease gcc 3.
@
text
@d1 1
a1 1
/*	$OpenBSD: bugio.c,v 1.12 2004/01/29 00:40:10 miod Exp $ */
d28 1
a28 1
	psr = disable_interrupts_return_psr();	/* paranoia */
d42 1
a42 1
	psr = disable_interrupts_return_psr();	/* paranoia */
@


1.12
log
@187BUG, 188BUG and 197BUG agree that only SSR3 needs to be preserved across
BUG calls, though SSR0-SSR2 will be corrupted on some BUGs.

This allows up to simplify slightly the context switching code.
@
text
@d1 1
a1 1
/*	$OpenBSD: bugio.c,v 1.11 2004/01/04 01:14:04 miod Exp $ */
d20 1
a20 1
	__asm__ __volatile__ (__CONCAT("or r9,r0,",__STRING(x)));	\
@


1.11
log
@Working kluge to ``enable'' the on-board SCSI controller on 187 and 197, if
it is not the boot device and has not been expliictely ``enabled'' in the
BUG.

Will definitely help netboot installations...
@
text
@d1 1
a1 1
/*	$OpenBSD: bugio.c,v 1.10 2003/09/01 19:14:01 miod Exp $ */
d12 1
a12 1
register_t bugsr0, bugsr1, bugsr2, bugsr3;
a58 3
	__asm__ __volatile__ ("stcr %0, cr17" :: "r"(bugsr0));		\
	__asm__ __volatile__ ("stcr %0, cr18" :: "r"(bugsr1));		\
	__asm__ __volatile__ ("stcr %0, cr19" :: "r"(bugsr2));		\
d64 1
a64 1
	__asm__ __volatile__ ("ldcr %0, cr17" : "=r" (bugsr0)::		\
a66 3
	__asm__ __volatile__ ("ldcr %0, cr18" : "=r" (bugsr1));		\
	__asm__ __volatile__ ("ldcr %0, cr19" : "=r" (bugsr2));		\
	__asm__ __volatile__ ("ldcr %0, cr20" : "=r" (bugsr3));		\
a85 3
	__asm__ __volatile__ ("ldcr %0, cr17" : "=r" (bugsr0));
	__asm__ __volatile__ ("ldcr %0, cr18" : "=r" (bugsr1));
	__asm__ __volatile__ ("ldcr %0, cr19" : "=r" (bugsr2));
a91 1
	register int cc;
d95 1
a95 2
	__asm__ __volatile__ ("or %0,r0,r2" : "=r" (cc) : );
	ret = cc;
@


1.10
log
@Prevent userland from invoking BUG system calls, by saving the initial BUG
trap vector contents, putting the bugtrap() stub in place, and switching
back and forth between them when the kernel needs to invoke BUG functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: bugio.c,v 1.9 2002/03/05 22:11:37 miod Exp $ */
d175 9
@


1.9
log
@Kill prom stuff duplicates from bugio.[ch].
@
text
@d1 1
a1 1
/*	$OpenBSD: bugio.c,v 1.8 2001/08/24 22:46:23 miod Exp $ */
d7 1
d14 37
d53 1
d78 1
@


1.8
log
@There is no need to hide potentially useful stuff in .c files.
@
text
@d1 1
a1 1
/*	$OpenBSD: bugio.c,v 1.7 2001/03/09 05:44:38 smurph Exp $ */
d3 1
d6 1
d8 1
d10 37
a46 49
#define INCHR	"0x0000"
#define INSTAT	"0x0001"
#define INLN	"0x0002"
#define READSTR	"0x0003"
#define READLN	"0x0004"
#define	DSKRD	"0x0010"
#define	DSKWR	"0x0011"
#define	DSKCFIG	"0x0012"
#define	NETCFG	"0x001A"
#define	NETCTRL	"0x001D"
#define	OUTCHR	"0x0020"
#define	OUTSTR	"0x0021"
#define	PCRLF	"0x0026"
#define	TMDISP	"0x0042"
#define	BUGDELAY "0x0043"
#define	RTC_DSP	"0x0052"
#define	RTC_RD	"0x0053"
#define	RETURN	"0x0063"
#define	BRD_ID	"0x0070"
#define	FORKMPU	"0x0100"
#define BUGTRAP	"0x01F0"

int ossr0, ossr1, ossr2, ossr3;
int bugsr0, bugsr1, bugsr2, bugsr3;

#define	BUGCTXT()						\
{								\
	asm volatile ("ldcr %0, cr17" : "=r" (ossr0));		\
	asm volatile ("ldcr %0, cr18" : "=r" (ossr1));		\
	asm volatile ("ldcr %0, cr19" : "=r" (ossr2));		\
	asm volatile ("ldcr %0, cr20" : "=r" (ossr3));		\
								\
	asm volatile ("stcr %0, cr17" :: "r"(bugsr0));		\
	asm volatile ("stcr %0, cr18" :: "r"(bugsr1));		\
	asm volatile ("stcr %0, cr19" :: "r"(bugsr2));		\
	asm volatile ("stcr %0, cr20" :: "r"(bugsr3));		\
}

#define	OSCTXT()						\
{								\
	asm volatile ("ldcr %0, cr17" : "=r" (bugsr0):: "r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8", "r9", "r10", "r11", "r12", "r13");	\
	asm volatile ("ldcr %0, cr18" : "=r" (bugsr1));		\
	asm volatile ("ldcr %0, cr19" : "=r" (bugsr2));		\
	asm volatile ("ldcr %0, cr20" : "=r" (bugsr3));		\
								\
	asm volatile ("stcr %0, cr17" :: "r"(ossr0));		\
	asm volatile ("stcr %0, cr18" :: "r"(ossr1));		\
	asm volatile ("stcr %0, cr19" :: "r"(ossr2));		\
	asm volatile ("stcr %0, cr20" :: "r"(ossr3));		\
d52 4
a55 4
	asm volatile ("ldcr %0, cr17" : "=r" (bugsr0));
	asm volatile ("ldcr %0, cr18" : "=r" (bugsr1));
	asm volatile ("ldcr %0, cr19" : "=r" (bugsr2));
	asm volatile ("ldcr %0, cr20" : "=r" (bugsr3));
d64 2
a65 3
	asm volatile ("or r9,r0," INCHR);
	asm volatile ("tb0 0,r0,0x1F0");
	asm volatile ("or %0,r0,r2" : "=r" (cc) : );
d82 2
a83 3
	asm("or r2,r0,%0" : : "r" (cc));
	asm("or r9,r0," OUTCHR);
	asm("tb0 0,r0,0x1F0");
d94 2
a95 3
	asm volatile ("or r9,r0," INSTAT);
	asm volatile ("tb0 0,r0,0x1F0");
	asm volatile ("or %0,r0,r2" : "=r" (ret) : );
d104 1
a104 2
	asm("or r9,r0," OUTSTR);
	asm("tb0 0,r0,0x1F0");
d109 1
a109 1
bugpcrlf(void)
d112 1
a112 2
	asm("or r9,r0," PCRLF);
	asm("tb0 0,r0,0x1F0");
a115 28
/* return 0 on success */
int
bugdskrd(struct bugdisk_io *arg)
{
	int ret;

	BUGCTXT();
	asm("or r9,r0, " DSKRD);
	asm("tb0 0,r0,0x1F0");  
	asm("or %0,r0,r2" : "=r" (ret) : );
	OSCTXT();

	return ((ret&0x4) == 0x4 ? 1 : 0);
}

/* return 0 on success */
int
bugdskwr(struct bugdisk_io *arg)
{
	int ret;
	BUGCTXT();
	asm("or r9,r0, " DSKWR);
	asm("tb0 0,r0,0x1F0");  
	asm("or %0,r0,r2" : "=r" (ret) : );
	OSCTXT();
	return ((ret&0x4) == 0x4 ? 1 : 0);
}

d117 1
a117 1
bugrtcrd(struct bugrtc *rtc)
d120 1
a120 2
	asm("or r9,r0, " RTC_RD);
	asm("tb0 0,r0,0x1F0");
d125 1
a125 1
bugdelay(int delay)
d127 1
a127 18
	BUGCTXT();
	asm("or r2,r0,%0" : : "r" (delay));
	asm("or r9,r0, " BUGDELAY);
	asm("tb0 0,r0,0x1F0");
	OSCTXT();
}

int
bugfork(int cpu, unsigned address)
{
	register int ret;
	BUGCTXT();
	asm("or r9,r0, " FORKMPU);
	asm("tb0 0,r0,0x1F0");
	asm volatile ("or %0,r0,r2" : "=r" (ret) : );
	OSCTXT();
	return(ret);
}
a128 3
void
bugreturn(void)
{
d130 2
a131 2
	asm("or r9,r0, " RETURN);
	asm("tb0 0,r0,0x1F0");
a132 1
}
d134 1
a134 33
void
bugbrdid(struct bugbrdid *id)
{
	struct bugbrdid *ptr;
	BUGCTXT();
	asm("or r9,r0, " BRD_ID);
	asm("tb0 0,r0,0x1F0");
	asm("or %0,r0,r2" : "=r" (ptr) : );
	OSCTXT();
	bcopy(ptr, id, sizeof(struct bugbrdid));
}

void
bugnetctrl(struct bugniocall *niocall)
{
/*	BUGCTXT();*/
	asm("or r2,r0,%0" : : "r" (niocall));
	asm("or r9,r0, " NETCTRL);
	asm("tb0 0,r0,0x1F0");
/*	OSCTXT();*/
}

int
bugnetcfg(struct bugniotcall *niotcall)
{
	register int ret;
/*	BUGCTXT();*/
	asm("or r2,r0,%0" : : "r" (niotcall));
	asm("or r9,r0, " NETCTRL);
	asm("tb0 0,r0,0x1F0");
	asm volatile ("or %0,r0,r2" : "=r" (ret) : );
/*	OSCTXT();*/
	return(ret);
@


1.8.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bugio.c,v 1.8 2001/08/24 22:46:23 miod Exp $ */
a2 1

a4 1

a5 1
#include <machine/prom.h>
d7 49
a55 37
register_t ossr0, ossr1, ossr2, ossr3;
register_t bugsr0, bugsr1, bugsr2, bugsr3;

#define	BUGCTXT()							\
{									\
	__asm__ __volatile__ ("ldcr %0, cr17" : "=r" (ossr0));		\
	__asm__ __volatile__ ("ldcr %0, cr18" : "=r" (ossr1));		\
	__asm__ __volatile__ ("ldcr %0, cr19" : "=r" (ossr2));		\
	__asm__ __volatile__ ("ldcr %0, cr20" : "=r" (ossr3));		\
									\
	__asm__ __volatile__ ("stcr %0, cr17" :: "r"(bugsr0));		\
	__asm__ __volatile__ ("stcr %0, cr18" :: "r"(bugsr1));		\
	__asm__ __volatile__ ("stcr %0, cr19" :: "r"(bugsr2));		\
	__asm__ __volatile__ ("stcr %0, cr20" :: "r"(bugsr3));		\
}

#define	OSCTXT()							\
{									\
	__asm__ __volatile__ ("ldcr %0, cr17" : "=r" (bugsr0)::		\
	    "r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8",		\
	    "r9", "r10", "r11", "r12", "r13");				\
	__asm__ __volatile__ ("ldcr %0, cr18" : "=r" (bugsr1));		\
	__asm__ __volatile__ ("ldcr %0, cr19" : "=r" (bugsr2));		\
	__asm__ __volatile__ ("ldcr %0, cr20" : "=r" (bugsr3));		\
									\
	__asm__ __volatile__ ("stcr %0, cr17" :: "r"(ossr0));		\
	__asm__ __volatile__ ("stcr %0, cr18" :: "r"(ossr1));		\
	__asm__ __volatile__ ("stcr %0, cr19" :: "r"(ossr2));		\
	__asm__ __volatile__ ("stcr %0, cr20" :: "r"(ossr3));		\
}

static void
bugpcrlf(void)
{
	BUGCTXT();
	MVMEPROM_CALL(MVMEPROM_OUTCRLF);
	OSCTXT();
d61 4
a64 4
	__asm__ __volatile__ ("ldcr %0, cr17" : "=r" (bugsr0));
	__asm__ __volatile__ ("ldcr %0, cr18" : "=r" (bugsr1));
	__asm__ __volatile__ ("ldcr %0, cr19" : "=r" (bugsr2));
	__asm__ __volatile__ ("ldcr %0, cr20" : "=r" (bugsr3));
d73 3
a75 2
	MVMEPROM_CALL(MVMEPROM_INCHR);
	__asm__ __volatile__ ("or %0,r0,r2" : "=r" (cc) : );
d92 3
a94 2
	__asm__ __volatile__ ("or r2,r0,%0" : : "r" (cc));
	MVMEPROM_CALL(MVMEPROM_OUTCHR);
d105 3
a107 2
	MVMEPROM_CALL(MVMEPROM_INSTAT);
	__asm__ __volatile__  ("or %0,r0,r2" : "=r" (ret) : );
d116 38
a153 1
	MVMEPROM_CALL(MVMEPROM_OUTSTR);
d155 1
d159 1
a159 1
bugrtcrd(struct mvmeprom_time *rtc)
d162 2
a163 1
	MVMEPROM_CALL(MVMEPROM_RTC_RD);
d168 22
d193 2
a194 1
	MVMEPROM_CALL(MVMEPROM_EXIT);
d199 1
a199 1
bugbrdid(struct mvmeprom_brdid *id)
d201 1
a201 2
	struct mvmeprom_brdid *ptr;

d203 3
a205 2
	MVMEPROM_CALL(MVMEPROM_GETBRDID);
	__asm__ __volatile__ ("or %0,r0,r2" : "=r" (ptr) : );
d207 2
d210 21
a230 1
	bcopy(ptr, id, sizeof(struct mvmeprom_brdid));
@


1.7
log
@kernel will compile with -Werror.  Added intr.h
@
text
@d1 1
a1 1
/*	$OpenBSD: bugio.c,v 1.6 2001/02/12 08:16:21 smurph Exp $ */
a218 35

typedef struct netcnfgp {
	unsigned int magic;
	unsigned int nodemem;
	unsigned int bfla;
	unsigned int bfea;
	unsigned int bfed;
	unsigned int bfl;
	unsigned int bfbo;
	unsigned int tbuffer;
	unsigned char cipa[4];
	unsigned char sipa[4];
	unsigned char netmask[4];
	unsigned char broadcast[4];
	unsigned char gipa[4];
	unsigned char bootp_retry;
	unsigned char tftp_retry;
	unsigned char bootp_ctl;
	unsigned char cnfgp_ctl;
	unsigned char filename[64];
	unsigned char argfname[64];
} NETCNFGP;

struct bugniotcall {
	unsigned char clun;
	unsigned char dlun;
	unsigned char ci;
	unsigned char cd;
	NETCNFGP * netcfngp_p;
	void * unused;
#define NIOT_READ  (1<<0)
#define NIOT_WRITE (1<<1)
#define NIOT_NVRAM (1<<2)    
	unsigned long cntrlflag;
};
@


1.6
log
@correct buginstat(), statclock now working for '188, systat vmstat now works,
serial driver for '188 working better.
@
text
@d1 1
a1 1
/*	$OpenBSD: bugio.c,v 1.5 2001/02/01 03:38:13 smurph Exp $ */
d3 2
d21 1
a21 1
#define	DELAY	"0x0043"
d81 1
a91 1

a94 1

d99 1
a99 1

d112 1
d121 1
d131 1
a131 1

d146 1
a146 1

d158 1
d167 1
d172 1
a172 1
	asm("or r9,r0, " DELAY);
d177 1
d180 1
d184 1
d186 1
d189 1
d198 1
d210 1
d255 1
d258 1
d263 1
d265 1
@


1.5
log
@Major changes to get MVME188 working.  More header and code cleanups.  The
kernel is tested on MVME188A/2P256 and MVME188A/1P64.
@
text
@d1 1
a1 1
/*	$OpenBSD: bugio.c,v 1.4 1999/09/27 18:43:21 smurph Exp $ */
d108 1
a108 1
	return (ret & 0x4 ? 1 : 0);
@


1.4
log
@adding support for MVME188 and MVME197.  Plus 32bit if_ie.
@
text
@d1 1
a1 1
/*	$OpenBSD: bugio.c,v 1.3 1999/05/29 04:41:42 smurph Exp $ */
d24 1
d69 1
a69 1
   int ret;
d74 2
a75 2
   ret = cc;
   OSCTXT();
d87 1
a87 1
	
d101 1
a101 1
	int ret;
d135 1
a135 1
	asm("tb0 0,r0,0x1F0");	
d149 1
a149 1
	asm("tb0 0,r0,0x1F0");	
d172 8
d208 20
a227 20
typedef struct netcnfgp { 
    unsigned int magic;
    unsigned int nodemem;
    unsigned int bfla;
    unsigned int bfea;
    unsigned int bfed;
    unsigned int bfl;
    unsigned int bfbo;
    unsigned int tbuffer;
    unsigned char cipa[4];
    unsigned char sipa[4];
    unsigned char netmask[4];
    unsigned char broadcast[4];
    unsigned char gipa[4];
    unsigned char bootp_retry;
    unsigned char tftp_retry;
    unsigned char bootp_ctl;
    unsigned char cnfgp_ctl;
    unsigned char filename[64];
    unsigned char argfname[64];
@


1.4.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: bugio.c,v 1.7 2001/03/09 05:44:38 smurph Exp $ */
a2 2
#include <sys/param.h>
#include <sys/systm.h>
d19 1
a19 1
#define	BUGDELAY "0x0043"
a23 1
#define	FORKMPU	"0x0100"
d68 1
a68 1
	int ret;
d73 2
a74 2
	ret = cc;
	OSCTXT();
a77 1
void
d86 2
a88 1
	BUGCTXT();
d92 1
d97 1
a97 1
int
d100 1
a100 1
	register int ret;
d107 1
a107 1
	return (ret & 0x4 ? 0 : 1);
a109 1
void
a117 1
void
d127 1
a127 1
int
d134 1
a134 1
	asm("tb0 0,r0,0x1F0");  
d142 1
a142 1
int
d148 1
a148 1
	asm("tb0 0,r0,0x1F0");  
a153 1
void
a161 1
void
d166 1
a166 11
	asm("or r9,r0, " BUGDELAY);
	asm("tb0 0,r0,0x1F0");
	OSCTXT();
}

int
bugfork(int cpu, unsigned address)
{
	register int ret;
	BUGCTXT();
	asm("or r9,r0, " FORKMPU);
a167 1
	asm volatile ("or %0,r0,r2" : "=r" (ret) : );
a168 1
	return(ret);
a170 1
void
a178 1
void
a189 1
void
d199 20
a218 20
typedef struct netcnfgp {
	unsigned int magic;
	unsigned int nodemem;
	unsigned int bfla;
	unsigned int bfea;
	unsigned int bfed;
	unsigned int bfl;
	unsigned int bfbo;
	unsigned int tbuffer;
	unsigned char cipa[4];
	unsigned char sipa[4];
	unsigned char netmask[4];
	unsigned char broadcast[4];
	unsigned char gipa[4];
	unsigned char bootp_retry;
	unsigned char tftp_retry;
	unsigned char bootp_ctl;
	unsigned char cnfgp_ctl;
	unsigned char filename[64];
	unsigned char argfname[64];
a233 1
int
a235 1
	register int ret;
a239 1
	asm volatile ("or %0,r0,r2" : "=r" (ret) : );
a240 1
	return(ret);
@


1.4.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: bugio.c,v 1.4.4.1 2001/04/18 16:10:52 niklas Exp $ */
d219 35
@


1.4.4.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a2 1

a4 1

a5 1
#include <machine/prom.h>
d7 49
a55 37
register_t ossr0, ossr1, ossr2, ossr3;
register_t bugsr0, bugsr1, bugsr2, bugsr3;

#define	BUGCTXT()							\
{									\
	__asm__ __volatile__ ("ldcr %0, cr17" : "=r" (ossr0));		\
	__asm__ __volatile__ ("ldcr %0, cr18" : "=r" (ossr1));		\
	__asm__ __volatile__ ("ldcr %0, cr19" : "=r" (ossr2));		\
	__asm__ __volatile__ ("ldcr %0, cr20" : "=r" (ossr3));		\
									\
	__asm__ __volatile__ ("stcr %0, cr17" :: "r"(bugsr0));		\
	__asm__ __volatile__ ("stcr %0, cr18" :: "r"(bugsr1));		\
	__asm__ __volatile__ ("stcr %0, cr19" :: "r"(bugsr2));		\
	__asm__ __volatile__ ("stcr %0, cr20" :: "r"(bugsr3));		\
}

#define	OSCTXT()							\
{									\
	__asm__ __volatile__ ("ldcr %0, cr17" : "=r" (bugsr0)::		\
	    "r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8",		\
	    "r9", "r10", "r11", "r12", "r13");				\
	__asm__ __volatile__ ("ldcr %0, cr18" : "=r" (bugsr1));		\
	__asm__ __volatile__ ("ldcr %0, cr19" : "=r" (bugsr2));		\
	__asm__ __volatile__ ("ldcr %0, cr20" : "=r" (bugsr3));		\
									\
	__asm__ __volatile__ ("stcr %0, cr17" :: "r"(ossr0));		\
	__asm__ __volatile__ ("stcr %0, cr18" :: "r"(ossr1));		\
	__asm__ __volatile__ ("stcr %0, cr19" :: "r"(ossr2));		\
	__asm__ __volatile__ ("stcr %0, cr20" :: "r"(ossr3));		\
}

static void
bugpcrlf(void)
{
	BUGCTXT();
	MVMEPROM_CALL(MVMEPROM_OUTCRLF);
	OSCTXT();
d61 4
a64 4
	__asm__ __volatile__ ("ldcr %0, cr17" : "=r" (bugsr0));
	__asm__ __volatile__ ("ldcr %0, cr18" : "=r" (bugsr1));
	__asm__ __volatile__ ("ldcr %0, cr19" : "=r" (bugsr2));
	__asm__ __volatile__ ("ldcr %0, cr20" : "=r" (bugsr3));
d73 3
a75 2
	MVMEPROM_CALL(MVMEPROM_INCHR);
	__asm__ __volatile__ ("or %0,r0,r2" : "=r" (cc) : );
d92 3
a94 2
	__asm__ __volatile__ ("or r2,r0,%0" : : "r" (cc));
	MVMEPROM_CALL(MVMEPROM_OUTCHR);
d105 3
a107 2
	MVMEPROM_CALL(MVMEPROM_INSTAT);
	__asm__ __volatile__  ("or %0,r0,r2" : "=r" (ret) : );
d116 38
a153 1
	MVMEPROM_CALL(MVMEPROM_OUTSTR);
d155 1
d159 1
a159 1
bugrtcrd(struct mvmeprom_time *rtc)
d162 2
a163 1
	MVMEPROM_CALL(MVMEPROM_RTC_RD);
d168 22
d193 2
a194 1
	MVMEPROM_CALL(MVMEPROM_EXIT);
d199 1
a199 1
bugbrdid(struct mvmeprom_brdid *id)
d201 1
a201 2
	struct mvmeprom_brdid *ptr;

d203 3
a205 2
	MVMEPROM_CALL(MVMEPROM_GETBRDID);
	__asm__ __volatile__ ("or %0,r0,r2" : "=r" (ptr) : );
d207 2
d210 21
a230 1
	bcopy(ptr, id, sizeof(struct mvmeprom_brdid));
@


1.4.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a6 1
#include <machine/asm_macro.h>
d11 1
a11 38
register_t bugsr3;

unsigned long bugvec[2], sysbugvec[2];

void bug_vector(void);
void sysbug_vector(void);

#define MVMEPROM_CALL(x)						\
	__asm__ __volatile__ (__CONCAT("or r9,r0,",__STRING(x)));	\
	__asm__ __volatile__ ("tb0 0,r0,496")

void
bug_vector()
{
	unsigned long *vbr, psr;

	psr = disable_interrupts_return_psr();	/* paranoia */

	__asm__ __volatile__ ("ldcr %0, cr7" : "=r" (vbr));
	vbr[2 * MVMEPROM_VECTOR + 0] = bugvec[0];
	vbr[2 * MVMEPROM_VECTOR + 1] = bugvec[1];

	set_psr(psr);
}

void
sysbug_vector()
{
	unsigned long *vbr, psr;

	psr = disable_interrupts_return_psr();	/* paranoia */

	__asm__ __volatile__ ("ldcr %0, cr7" : "=r" (vbr));
	vbr[2 * MVMEPROM_VECTOR + 0] = sysbugvec[0];
	vbr[2 * MVMEPROM_VECTOR + 1] = sysbugvec[1];

	set_psr(psr);
}
a14 1
	bug_vector();							\
d20 3
d28 1
a28 1
	__asm__ __volatile__ ("ldcr %0, cr20" : "=r" (bugsr3)::		\
d31 3
a38 1
	sysbug_vector();						\
d52 3
d61 1
d65 2
a66 1
	__asm__ __volatile__ ("or %0,r0,r2" : "=r" (ret) : );
a134 9
}

void
bugdiskrd(struct mvmeprom_dskio *dio)
{
	BUGCTXT();
	__asm__ __volatile__ ("or r2, r0, %0" : : "r" (dio));
	MVMEPROM_CALL(MVMEPROM_DSKRD);
	OSCTXT();
@


1.4.4.5
log
@Merge with the trunk
@
text
@d20 1
a20 1
	__asm__ __volatile__ ("or r9,r0," __STRING(x));			\
@


1.3
log
@Added vme bus device drivers. MVME328, MVME376, MVME332
@
text
@d1 1
a1 1
/*	$OpenBSD: bugio.c,v 1.2 1998/12/15 05:52:29 smurph Exp $ */
d67 2
a68 1
	register int cc asm("r2");
d73 3
a75 2
	OSCTXT();
	return ((char)cc & 0xFF);
@


1.2
log
@Commit for the first real OpenBSD mvme88k port.
@
text
@d1 1
a1 1
/*	$OpenBSD: bugio.c,v 1.1 1997/03/03 19:32:04 rahnds Exp $ */
d13 1
d160 9
d192 44
@


1.1
log
@Initial revision
@
text
@d1 2
a66 1
	
d70 1
a70 1
	/*asm("or %0,r0,r2" : "=r" (cc) : );*/
a74 14
/* return 1 if not empty else 0 */

buginstat(void)
{
	int ret;

	BUGCTXT();
	asm volatile ("or r9,r0," INSTAT);
	asm volatile ("tb0 0,r0,0x1F0");
	asm volatile ("or %0,r0,r2" : "=r" (ret) : );
	OSCTXT();
	return (ret & 0x40 ? 1 : 0);
}

d93 14
d180 1
a180 1
	BUGCTXT();
d184 1
a184 1
	OSCTXT();
@


1.1.1.1
log
@Third try at importing the mvme88k port. This is a working kernel
from nivas.
Userland and compiler still need to be worked on.
Make certain what directory the import is done from.
@
text
@@
