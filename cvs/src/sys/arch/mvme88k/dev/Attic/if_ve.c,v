head	1.24;
access;
symbols
	SMP_SYNC_A:1.24
	SMP_SYNC_B:1.24
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	UBC_SYNC_A:1.18
	OPENBSD_3_3:1.18.0.4
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	UBC_SYNC_B:1.18
	UBC:1.13.0.2
	UBC_BASE:1.13
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.1.0.8
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.6
	OPENBSD_2_7_BASE:1.1
	SMP:1.1.0.4
	SMP_BASE:1.1
	kame_19991208:1.1
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.24
date	2003.12.27.23.58.11;	author miod;	state dead;
branches;
next	1.23;

1.23
date	2003.12.19.22.30.18;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2003.10.13.13.17.23;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2003.10.05.20.27.47;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2003.09.29.09.08.19;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.02.23.27.51;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.04.28.15.17.09;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.14.01.26.39;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.05.22.11.37;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.22.18.45.35;	author smurph;	state Exp;
branches;
next	1.14;

1.14
date	2001.12.22.09.49.39;	author smurph;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.16.23.49.46;	author miod;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2001.12.13.08.55.51;	author smurph;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.06.19.53.15;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.11.20.05.24;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.26.02.37.07;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.11.23.21.13;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.09.22.28.27;	author fgsch;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.09.05.44.39;	author smurph;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.08.00.03.13;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.20.19.39.32;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.12.08.16.23;	author smurph;	state Exp;
branches;
next	1.2;

1.2
date	2001.02.01.03.38.14;	author smurph;	state Exp;
branches;
next	1.1;

1.1
date	99.05.29.04.41.43;	author smurph;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2001.04.18.16.10.56;	author niklas;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2001.10.31.03.01.18;	author nate;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2001.11.13.21.04.14;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2002.03.06.02.04.44;	author niklas;	state Exp;
branches;
next	1.1.4.5;

1.1.4.5
date	2002.03.28.10.36.02;	author niklas;	state Exp;
branches;
next	1.1.4.6;

1.1.4.6
date	2003.03.27.23.32.18;	author niklas;	state Exp;
branches;
next	1.1.4.7;

1.1.4.7
date	2003.06.07.11.13.16;	author ho;	state Exp;
branches;
next	1.1.4.8;

1.1.4.8
date	2004.02.19.10.49.06;	author niklas;	state dead;
branches;
next	;

1.13.2.1
date	2002.01.31.22.55.17;	author niklas;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2002.06.11.03.37.09;	author art;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Replace the MVME376 driver from a homemade and dusty if_ve driver to
a ``regular'' if_le driver, sharing the common am7990 code.
@
text
@/*	$OpenBSD: if_ve.c,v 1.23 2003/12/19 22:30:18 miod Exp $ */
/*-
 * Copyright (c) 1999 Steve Murphree, Jr.
 * Copyright (c) 1982, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

/* if_ve.c - Motorola MVME376 vme bus ethernet driver.  Based on if_le.c */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/syslog.h>
#include <sys/socket.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/ioctl.h>
#include <sys/errno.h>

#include <net/if.h>
#include <net/if_media.h>

#ifdef INET
#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
#endif

#include <net/if_media.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#include <net/bpfdesc.h>
#endif

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>
#include <machine/cmmu.h>	/* DMA_CACHE_SYNC, etc... */

#include <mvme88k/dev/if_vereg.h>
#include <mvme88k/dev/if_vevar.h>
#include <mvme88k/dev/pcctworeg.h>
#include <mvme88k/dev/vme.h>

#ifdef LEDEBUG
void ve_recv_print(struct vam7990_softc *, int);
void ve_xmit_print(struct vam7990_softc *, int);
#endif

void ve_rint(struct vam7990_softc *);
void ve_tint(struct vam7990_softc *);

int ve_put(struct vam7990_softc *, int, struct mbuf *);
struct mbuf *ve_get(struct vam7990_softc *, int, int);
void ve_read(struct vam7990_softc *, int, int);

void ve_shutdown(void *);

#define	ifp	(&sc->sc_arpcom.ac_if)
#ifndef	ETHER_CMP
#define	ETHER_CMP(a, b) bcmp((a), (b), ETHER_ADDR_LEN)
#endif
#define LANCE_REVC_BUG 1
/*
 * Ethernet software status per interface.
 *
 * Each interface is referenced by a network interface structure,
 * arpcom.ac_if, which the routing code uses to locate the interface.
 * This structure contains the output queue for the interface, its address, ...
 */
struct	ve_softc {
	struct vam7990_softc	sc_am7990; /* glue to MI code */
	struct intrhand		sc_ih;      /* interrupt vectoring */
	struct vereg1		*sc_r1;     /* LANCE registers */
	u_short			csr;        /* Control/Status reg image */
	u_long			board_addr;
	struct evcnt		sc_intrcnt;
	struct evcnt		sc_errcnt;
	struct vme2reg		*sc_vme2;
	u_char			sc_ipl;
	u_char			sc_vec;
	int			sc_flags;
};

struct cfdriver ve_cd = {
	NULL, "ve", DV_IFNET
};


/* autoconfiguration driver */
void	veattach(struct device *, struct device *, void *);
int	vematch(struct device *, void *, void *);
void	veetheraddr(struct vam7990_softc *sc);

struct cfattach ve_ca = {
	sizeof(struct ve_softc), vematch, veattach
};

void vewrcsr(struct vam7990_softc *, u_int16_t, u_int16_t);
u_int16_t verdcsr(struct vam7990_softc *, u_int16_t);
void nvram_cmd(struct vam7990_softc *, u_char, u_short);
u_int16_t nvram_read(struct vam7990_softc *, u_char);
void vereset(struct vam7990_softc *);
void ve_ackint(struct vam7990_softc *);

/* send command to the nvram controller */
void
nvram_cmd(sc, cmd, addr)
	struct vam7990_softc *sc;
	u_char cmd;
	u_short addr;
{
	int i;
	struct vereg1 *reg1 = ((struct ve_softc *)sc)->sc_r1;

	for (i=0;i<8;i++) {
		reg1->ver1_ear=((cmd|(addr<<1))>>i);
		CDELAY;
	}
}

/* read nvram one bit at a time */
u_int16_t
nvram_read(sc, nvram_addr)
	struct vam7990_softc *sc;
	u_char nvram_addr;
{
	u_short val = 0, mask = 0x04000;
	u_int16_t wbit;
	/* these used by macros DO NOT CHANGE!*/
	struct vereg1 *reg1 = ((struct ve_softc *)sc)->sc_r1;
	sc->csr = 0x4f;
	ENABLE_NVRAM;
	nvram_cmd(sc, NVRAM_RCL, 0);
	DISABLE_NVRAM;
	CDELAY;
	ENABLE_NVRAM;
	nvram_cmd(sc, NVRAM_READ, nvram_addr);
	for (wbit=0; wbit<15; wbit++) {
		(reg1->ver1_ear & 0x01) ?
			(val = (val | mask)) : (val = (val & (~mask)));
		mask = mask>>1;
		CDELAY;
	}
	(reg1->ver1_ear & 0x01) ?
		(val = (val | 0x8000)) : (val = (val & 0x7FFF));
	CDELAY;
	DISABLE_NVRAM;
	return (val);
}

void
vewrcsr(sc, port, val)
	struct vam7990_softc *sc;
	u_int16_t port, val;
{
	register struct vereg1 *ve1 = ((struct ve_softc *)sc)->sc_r1;

	ve1->ver1_rap = port;
	ve1->ver1_rdp = val;
}

u_int16_t
verdcsr(sc, port)
	struct vam7990_softc *sc;
	u_int16_t port;
{
	register struct vereg1 *ve1 = ((struct ve_softc *)sc)->sc_r1;
	u_int16_t val;

	ve1->ver1_rap = port;
	val = ve1->ver1_rdp;
	return (val);
}

/* reset MVME376, set ipl and vec */
void
vereset(sc)
	struct vam7990_softc *sc;
{
	register struct vereg1 *reg1 = ((struct ve_softc *)sc)->sc_r1;
	u_char vec = ((struct ve_softc *)sc)->sc_vec;
	u_char ipl = ((struct ve_softc *)sc)->sc_ipl;
	sc->csr = 0x4f;
	WRITE_CSR_AND( ~ipl );
	SET_VEC(vec);
	return;
}

/* ack the intrrupt by reenableling interrupts */
void
ve_ackint(sc)
	struct vam7990_softc *sc;
{
	register struct vereg1 *reg1 = ((struct ve_softc *)sc)->sc_r1;
	ENABLE_INTR;
        CLEAR_INTR;
}

int
vematch(parent, vcf, args)
	struct device *parent;
	void *vcf, *args;
{

	struct confargs *ca = args;
	if (badvaddr((unsigned)ca->ca_vaddr, 1))
		return (0);
		return (1);
}

/*
 * Interface exists: make available by filling in network interface
 * record.  System will initialize the interface when it is ready
 * to accept packets.
 */
void
veattach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	register struct ve_softc *lesc = (struct ve_softc *)self;
	struct vam7990_softc *sc = &lesc->sc_am7990;
	struct confargs *ca = aux;
	int pri = ca->ca_ipl;
	caddr_t addr;

	addr = ca->ca_vaddr;

	if (addr == 0) {
		printf("\n%s: can't map LANCE registers\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	/* Are we the boot device? */
	if (ca->ca_paddr == bootaddr)
		bootdv = self;

	lesc->sc_r1 = (struct vereg1 *)ca->ca_vaddr;
	lesc->sc_ipl = ca->ca_ipl;
	lesc->sc_vec = ca->ca_vec;


	/* get the first available etherbuf */
	switch ((int)ca->ca_paddr) {
	case 0xFFFF1200:
		addr = (caddr_t)0xFD6C0000;
		break;
	case 0xFFFF1400:
		addr = (caddr_t)0xFD700000;
		break;
	case 0xFFFF1600:
		addr = (caddr_t)0xFD740000;
		break;
	default:
		panic("ve: invalid address");
	}

	sc->sc_mem = (void *)mapiodev(addr, LEMEMSIZE);

	if (sc->sc_mem == NULL)	panic("ve: no more memory in external I/O map");
	sc->sc_memsize = LEMEMSIZE;
	sc->sc_conf3 = LE_C3_BSWP;
	sc->sc_addr = kvtop((vaddr_t)sc->sc_mem);

	/* get ether address via bug call */
	veetheraddr(sc);

	evcnt_attach(&sc->sc_dev, "intr", &lesc->sc_intrcnt);
	evcnt_attach(&sc->sc_dev, "errs", &lesc->sc_errcnt);

	sc->sc_copytodesc = ve_copytobuf_contig;
	sc->sc_copyfromdesc = ve_copyfrombuf_contig;
	sc->sc_copytobuf = ve_copytobuf_contig;
	sc->sc_copyfrombuf = ve_copyfrombuf_contig;
	sc->sc_zerobuf = ve_zerobuf_contig;

	sc->sc_rdcsr = verdcsr;
	sc->sc_wrcsr = vewrcsr;
	sc->sc_hwreset = vereset;
	sc->sc_hwinit = NULL;
	vereset(sc);

	ve_config(sc);

	/* connect the interrupt */
	lesc->sc_ih.ih_fn = ve_intr;
	lesc->sc_ih.ih_arg = sc;
	lesc->sc_ih.ih_wantframe = 0;
	lesc->sc_ih.ih_ipl = pri;
	vmeintr_establish(ca->ca_vec + 0, &lesc->sc_ih);
}

void
veetheraddr(sc)
	struct vam7990_softc *sc;
{
	u_char * cp = sc->sc_arpcom.ac_enaddr;
	u_int16_t ival[3];
	u_char i;

	for (i=0; i<3; i++) {
		ival[i] = nvram_read(sc, i);
	}
	memcpy(cp, &ival[0], 6);
}

void
ve_config(sc)
	struct vam7990_softc *sc;
{
	int mem;

	/* Make sure the chip is stopped. */
	ve_stop(sc);

	/* Initialize ifnet structure. */
	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
	ifp->if_softc = sc;
	ifp->if_start = ve_start;
	ifp->if_ioctl = ve_ioctl;
	ifp->if_watchdog = ve_watchdog;
	ifp->if_flags =
	IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;
#ifdef LANCE_REVC_BUG
	ifp->if_flags &= ~IFF_MULTICAST;
#endif

	/* Attach the interface. */
	if_attach(ifp);
	ether_ifattach(ifp);

	if (sc->sc_memsize > 262144)
		sc->sc_memsize = 262144;

	switch (sc->sc_memsize) {
	case 8192:
		sc->sc_nrbuf = 4;
		sc->sc_ntbuf = 1;
		break;
	case 16384:
		sc->sc_nrbuf = 8;
		sc->sc_ntbuf = 2;
		break;
	case 32768:
		sc->sc_nrbuf = 16;
		sc->sc_ntbuf = 4;
		break;
	case 65536:
		sc->sc_nrbuf = 32;
		sc->sc_ntbuf = 8;
		break;
	case 131072:
		sc->sc_nrbuf = 64;
		sc->sc_ntbuf = 16;
		break;
	case 262144:
		sc->sc_nrbuf = 128;
		sc->sc_ntbuf = 32;
		break;
	default:
		panic("ve_config: weird memory size %ld", sc->sc_memsize);
	}

	printf("\n%s: address %s\n", sc->sc_dev.dv_xname,
	       ether_sprintf(sc->sc_arpcom.ac_enaddr));
	printf("%s: %d receive buffers, %d transmit buffers\n",
	       sc->sc_dev.dv_xname, sc->sc_nrbuf, sc->sc_ntbuf);

	sc->sc_sh = shutdownhook_establish(ve_shutdown, sc);
	if (sc->sc_sh == NULL)
		panic("ve_config: can't establish shutdownhook");

	mem = 0;
	sc->sc_initaddr = mem;
	mem += sizeof(struct veinit);
	sc->sc_rmdaddr = mem;
	mem += sizeof(struct vermd) * sc->sc_nrbuf;
	sc->sc_tmdaddr = mem;
	mem += sizeof(struct vetmd) * sc->sc_ntbuf;
	sc->sc_rbufaddr = mem;
	mem += LEBLEN * sc->sc_nrbuf;
	sc->sc_tbufaddr = mem;
	mem += LEBLEN * sc->sc_ntbuf;
#ifdef notyet
	if (mem > ...)
		panic(...);
#endif
}

void
ve_reset(sc)
	struct vam7990_softc *sc;
{
	int s;

	s = splimp();
	ve_init(sc);
	splx(s);
}

/*
 * Set up the initialization block and the descriptor rings.
 */
void
ve_meminit(sc)
	register struct vam7990_softc *sc;
{
	u_long a;
	int bix;
	struct veinit init;
	struct vermd rmd;
	struct vetmd tmd;

#if NBPFILTER > 0
	if (ifp->if_flags & IFF_PROMISC)
		init.init_mode = LE_MODE_NORMAL | LE_MODE_PROM;
	else
#endif
		init.init_mode = LE_MODE_NORMAL;
	init.init_padr[0] =
	(sc->sc_arpcom.ac_enaddr[1] << 8) | sc->sc_arpcom.ac_enaddr[0];
	init.init_padr[1] =
	(sc->sc_arpcom.ac_enaddr[3] << 8) | sc->sc_arpcom.ac_enaddr[2];
	init.init_padr[2] =
	(sc->sc_arpcom.ac_enaddr[5] << 8) | sc->sc_arpcom.ac_enaddr[4];
	ve_setladrf(&sc->sc_arpcom, init.init_ladrf);

	sc->sc_last_rd = 0;
	sc->sc_first_td = sc->sc_last_td = sc->sc_no_td = 0;

	a = sc->sc_addr + LE_RMDADDR(sc, 0);
	init.init_rdra = a;
	init.init_rlen = (a >> 16) | ((ffs(sc->sc_nrbuf) - 1) << 13);

	a = sc->sc_addr + LE_TMDADDR(sc, 0);
	init.init_tdra = a;
	init.init_tlen = (a >> 16) | ((ffs(sc->sc_ntbuf) - 1) << 13);

	(*sc->sc_copytodesc)(sc, &init, LE_INITADDR(sc), sizeof(init));

	/*
	 * Set up receive ring descriptors.
	 */
	for (bix = 0; bix < sc->sc_nrbuf; bix++) {
		a = sc->sc_addr + LE_RBUFADDR(sc, bix);
		rmd.rmd0 = a;
		rmd.rmd1_hadr = a >> 16;
		rmd.rmd1_bits = LE_R1_OWN;
		rmd.rmd2 = -LEBLEN | LE_XMD2_ONES;
		rmd.rmd3 = 0;
		(*sc->sc_copytodesc)(sc, &rmd, LE_RMDADDR(sc, bix),
				     sizeof(rmd));
	}

	/*
	 * Set up transmit ring descriptors.
	 */
	for (bix = 0; bix < sc->sc_ntbuf; bix++) {
		a = sc->sc_addr + LE_TBUFADDR(sc, bix);
		tmd.tmd0 = a;
		tmd.tmd1_hadr = a >> 16;
		tmd.tmd1_bits = LE_R1_STP | LE_R1_ENP;
		tmd.tmd2 = -2000 | LE_XMD2_ONES;
		tmd.tmd3 = 0;
		(*sc->sc_copytodesc)(sc, &tmd, LE_TMDADDR(sc, bix),
				     sizeof(tmd));
	}
}

void
ve_stop(sc)
	struct vam7990_softc *sc;
{

	(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_STOP);
}

/*
 * Initialization of interface; set up initialization block
 * and transmit/receive descriptor rings.
 */
void
ve_init(sc)
	register struct vam7990_softc *sc;
{
	register int timo;
	u_long a;

	(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_STOP);
	DELAY(100);

	/* Newer LANCE chips have a reset register */
	if (sc->sc_hwreset)
		(*sc->sc_hwreset)(sc);

	/* Set the correct byte swapping mode, etc. */
	(*sc->sc_wrcsr)(sc, LE_CSR3, sc->sc_conf3);

	/* Set up LANCE init block. */
	ve_meminit(sc);

	/* Give LANCE the physical address of its init block. */
	a = sc->sc_addr + LE_INITADDR(sc);
	(*sc->sc_wrcsr)(sc, LE_CSR1, a);
	(*sc->sc_wrcsr)(sc, LE_CSR2, a >> 16);

	/* Try to initialize the LANCE. */
	DELAY(100);
	(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_INIT);

	/* Wait for initialization to finish. */
	for (timo = 100000; timo; timo--)
		if ((*sc->sc_rdcsr)(sc, LE_CSR0) & LE_C0_IDON)
			break;

	if ((*sc->sc_rdcsr)(sc, LE_CSR0) & LE_C0_IDON) {
		/* Start the LANCE. */
		(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_INEA | LE_C0_STRT |
		    LE_C0_IDON);
		ifp->if_flags |= IFF_RUNNING;
		ifp->if_flags &= ~IFF_OACTIVE;
		ifp->if_timer = 0;
		ve_start(ifp);
	} else
		printf("%s: controller failed to initialize\n", sc->sc_dev.dv_xname);
	if (sc->sc_hwinit)
		(*sc->sc_hwinit)(sc);
}

/*
 * Routine to copy from mbuf chain to transmit buffer in
 * network buffer memory.
 */
int
ve_put(sc, boff, m)
	struct vam7990_softc *sc;
	int boff;
	register struct mbuf *m;
{
	register struct mbuf *n;
	register int len, tlen = 0;

	for (; m; m = n) {
		len = m->m_len;
		if (len == 0) {
			MFREE(m, n);
			continue;
		}
		(*sc->sc_copytobuf)(sc, mtod(m, caddr_t), boff, len);
		boff += len;
		tlen += len;
		MFREE(m, n);
	}
	if (tlen < LEMINSIZE) {
		(*sc->sc_zerobuf)(sc, boff, LEMINSIZE - tlen);
		tlen = LEMINSIZE;
	}
	return (tlen);
}

/*
 * Pull data off an interface.
 * Len is length of data, with local net header stripped.
 * We copy the data into mbufs.  When full cluster sized units are present
 * we copy into clusters.
 */
struct mbuf *
ve_get(sc, boff, totlen)
	struct vam7990_softc *sc;
	int boff, totlen;
{
	register struct mbuf *m;
	struct mbuf *top, **mp;
	int len, pad;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == 0)
		return (0);
	m->m_pkthdr.rcvif = ifp;
	m->m_pkthdr.len = totlen;
	pad = ALIGN(sizeof(struct ether_header)) - sizeof(struct ether_header);
	m->m_data += pad;
	len = MHLEN - pad;
	top = 0;
	mp = &top;

	while (totlen > 0) {
		if (top) {
			MGET(m, M_DONTWAIT, MT_DATA);
			if (m == 0) {
				m_freem(top);
				return 0;
			}
			len = MLEN;
		}
		if (top && totlen >= MINCLSIZE) {
			MCLGET(m, M_DONTWAIT);
			if (m->m_flags & M_EXT)
				len = MCLBYTES;
		}
		m->m_len = len = min(totlen, len);
		(*sc->sc_copyfrombuf)(sc, mtod(m, caddr_t), boff, len);
		boff += len;
		totlen -= len;
		*mp = m;
		mp = &m->m_next;
	}

	return (top);
}

/*
 * Pass a packet to the higher levels.
 */
void
ve_read(sc, boff, len)
	register struct vam7990_softc *sc;
	int boff, len;
{
	struct mbuf *m;
#ifdef LANCE_REVC_BUG
	struct ether_header *eh;
#endif

	if (len <= sizeof(struct ether_header) ||
	    len > ETHERMTU + sizeof(struct ether_header)) {
#ifdef LEDEBUG
		printf("%s: invalid packet size %d; dropping\n",
		    sc->sc_dev.dv_xname, len);
#endif
		ifp->if_ierrors++;
		return;
	}

	/* Pull packet off interface. */
	m = ve_get(sc, boff, len);
	if (m == 0) {
		ifp->if_ierrors++;
		return;
	}

	ifp->if_ipackets++;

#if NBPFILTER > 0
	/*
	 * Check if there's a BPF listener on this interface.
	 * If so, hand off the raw packet to BPF.
	 */
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m);
#endif

#ifdef LANCE_REVC_BUG
	/*
	 * The old LANCE (Rev. C) chips have a bug which causes
	 * garbage to be inserted in front of the received packet.
	 * The work-around is to ignore packets with an invalid
	 * destination address (garbage will usually not match).
	 * Of course, this precludes multicast support...
	 */
	eh = mtod(m, struct ether_header *);
	if (ETHER_CMP(eh->ether_dhost, sc->sc_arpcom.ac_enaddr) &&
	    ETHER_CMP(eh->ether_dhost, etherbroadcastaddr)) {
		m_freem(m);
		return;
	}
#endif

	/* Pass the packet up. */
	ether_input_mbuf(ifp, m);
}

void
ve_rint(sc)
	struct vam7990_softc *sc;
{
	register int bix;
	int rp;
	struct vermd rmd;

	bix = sc->sc_last_rd;

	/* Process all buffers with valid data. */
	for (;;) {
		rp = LE_RMDADDR(sc, bix);
		(*sc->sc_copyfromdesc)(sc, &rmd, rp, sizeof(rmd));

		if (rmd.rmd1_bits & LE_R1_OWN)
			break;

		if (rmd.rmd1_bits & LE_R1_ERR) {
			if (rmd.rmd1_bits & LE_R1_ENP) {
#ifdef LEDEBUG
				if ((rmd.rmd1_bits & LE_R1_OFLO) == 0) {
					if (rmd.rmd1_bits & LE_R1_FRAM)
						printf("%s: framing error\n",
						    sc->sc_dev.dv_xname);
					if (rmd.rmd1_bits & LE_R1_CRC)
						printf("%s: crc mismatch\n",
						    sc->sc_dev.dv_xname);
				}
#endif
			} else {
				if (rmd.rmd1_bits & LE_R1_OFLO)
					printf("%s: overflow\n",
					    sc->sc_dev.dv_xname);
			}
			if (rmd.rmd1_bits & LE_R1_BUFF)
				printf("%s: receive buffer error\n",
				    sc->sc_dev.dv_xname);
			ifp->if_ierrors++;
		} else if ((rmd.rmd1_bits & (LE_R1_STP | LE_R1_ENP)) !=
		    (LE_R1_STP | LE_R1_ENP)) {
			printf("%s: dropping chained buffer\n",
			    sc->sc_dev.dv_xname);
			ifp->if_ierrors++;
		} else {
#ifdef LEDEBUG
			if (sc->sc_debug)
				ve_recv_print(sc, sc->sc_last_rd);
#endif
			ve_read(sc, LE_RBUFADDR(sc, bix),
			    (int)rmd.rmd3 - 4);
		}

		rmd.rmd1_bits = LE_R1_OWN;
		rmd.rmd2 = -LEBLEN | LE_XMD2_ONES;
		rmd.rmd3 = 0;
		(*sc->sc_copytodesc)(sc, &rmd, rp, sizeof(rmd));

#ifdef LEDEBUG
		if (sc->sc_debug)
			printf("sc->sc_last_rd = %x, rmd: "
			       "ladr %04x, hadr %02x, flags %02x, "
			       "bcnt %04x, mcnt %04x\n",
				sc->sc_last_rd,
				rmd.rmd0, rmd.rmd1_hadr, rmd.rmd1_bits,
				rmd.rmd2, rmd.rmd3);
#endif

		if (++bix == sc->sc_nrbuf)
			bix = 0;
	}

	sc->sc_last_rd = bix;
}

void
ve_tint(sc)
	register struct vam7990_softc *sc;
{
	register int bix;
	struct vetmd tmd;

	bix = sc->sc_first_td;

	for (;;) {
		if (sc->sc_no_td <= 0)
			break;

		(*sc->sc_copyfromdesc)(sc, &tmd, LE_TMDADDR(sc, bix),
		    sizeof(tmd));

#ifdef LEDEBUG
		if (sc->sc_debug)
			printf("trans tmd: "
			    "ladr %04x, hadr %02x, flags %02x, "
			    "bcnt %04x, mcnt %04x\n",
			    tmd.tmd0, tmd.tmd1_hadr, tmd.tmd1_bits,
			    tmd.tmd2, tmd.tmd3);
#endif

		if (tmd.tmd1_bits & LE_T1_OWN)
			break;

		ifp->if_flags &= ~IFF_OACTIVE;

		if (tmd.tmd1_bits & LE_T1_ERR) {
			if (tmd.tmd3 & LE_T3_BUFF)
				printf("%s: transmit buffer error\n",
				    sc->sc_dev.dv_xname);
			else if (tmd.tmd3 & LE_T3_UFLO)
				printf("%s: underflow\n", sc->sc_dev.dv_xname);
			if (tmd.tmd3 & (LE_T3_BUFF | LE_T3_UFLO)) {
				ve_reset(sc);
				return;
			}
			if (tmd.tmd3 & LE_T3_LCAR) {
				if (sc->sc_nocarrier)
					(*sc->sc_nocarrier)(sc);
				else
					printf("%s: lost carrier\n",
					    sc->sc_dev.dv_xname);
			}
			if (tmd.tmd3 & LE_T3_LCOL)
				ifp->if_collisions++;
			if (tmd.tmd3 & LE_T3_RTRY) {
				printf("%s: excessive collisions, tdr %d\n",
				    sc->sc_dev.dv_xname,
				    tmd.tmd3 & LE_T3_TDR_MASK);
				ifp->if_collisions += 16;
			}
			ifp->if_oerrors++;
		} else {
			if (tmd.tmd1_bits & LE_T1_ONE)
				ifp->if_collisions++;
			else if (tmd.tmd1_bits & LE_T1_MORE)
				/* Real number is unknown. */
				ifp->if_collisions += 2;
			ifp->if_opackets++;
		}

		if (++bix == sc->sc_ntbuf)
			bix = 0;

		--sc->sc_no_td;
	}

	sc->sc_first_td = bix;

	ve_start(ifp);

	if (sc->sc_no_td == 0)
		ifp->if_timer = 0;
}

/*
 * Controller interrupt.
 */
int
ve_intr(arg)
	register void *arg;
{
	register struct vam7990_softc *sc = arg;
	register u_int16_t isr;

	isr = (*sc->sc_rdcsr)(sc, LE_CSR0);
#ifdef LEDEBUG
	if (sc->sc_debug)
		printf("%s: ve_intr entering with isr=%04x\n",
		    sc->sc_dev.dv_xname, isr);
#endif
	if ((isr & LE_C0_INTR) == 0)
		return (0);

	/* clear the interrupting condition */
	(*sc->sc_wrcsr)(sc, LE_CSR0,
			isr & (LE_C0_INEA | LE_C0_BABL | LE_C0_MISS |
			       LE_C0_MERR | LE_C0_RINT | LE_C0_TINT | LE_C0_IDON));
	if (isr & LE_C0_ERR) {
		if (isr & LE_C0_BABL) {
#ifdef LEDEBUG
			printf("%s: babble\n", sc->sc_dev.dv_xname);
#endif
			ifp->if_oerrors++;
		}
#if 0
		if (isr & LE_C0_CERR) {
			printf("%s: collision error\n", sc->sc_dev.dv_xname);
			ifp->if_collisions++;
		}
#endif
		if (isr & LE_C0_MISS) {
#ifdef LEDEBUG
			printf("%s: missed packet\n", sc->sc_dev.dv_xname);
#endif
			ifp->if_ierrors++;
		}
		if (isr & LE_C0_MERR) {
			printf("%s: memory error\n", sc->sc_dev.dv_xname);
			ve_reset(sc);
			return (1);
		}
	}

	if ((isr & LE_C0_RXON) == 0) {
		printf("%s: receiver disabled\n", sc->sc_dev.dv_xname);
		ifp->if_ierrors++;
		ve_reset(sc);
		return (1);
	}
	if ((isr & LE_C0_TXON) == 0) {
		printf("%s: transmitter disabled\n", sc->sc_dev.dv_xname);
		ifp->if_oerrors++;
		ve_reset(sc);
		return (1);
	}

	if (isr & LE_C0_RINT)
		ve_rint(sc);
	if (isr & LE_C0_TINT)
		ve_tint(sc);
	ve_ackint(sc);
	return (1);
}

#undef	ifp

void
ve_watchdog(ifp)
	struct ifnet *ifp;
{
	struct vam7990_softc *sc = ifp->if_softc;

	log(LOG_ERR, "%s: device timeout\n", sc->sc_dev.dv_xname);
	++ifp->if_oerrors;

	ve_reset(sc);
}

/*
 * Setup output on interface.
 * Get another datagram to send off of the interface queue, and map it to the
 * interface before starting the output.
 * Called only at splimp or interrupt level.
 */
void
ve_start(ifp)
	register struct ifnet *ifp;
{
	register struct vam7990_softc *sc = ifp->if_softc;
	register int bix;
	register struct mbuf *m;
	struct vetmd tmd;
	int rp;
	int len;

	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
		return;

	bix = sc->sc_last_td;

	for (;;) {
		rp = LE_TMDADDR(sc, bix);
		(*sc->sc_copyfromdesc)(sc, &tmd, rp, sizeof(tmd));

		if (tmd.tmd1_bits & LE_T1_OWN) {
			ifp->if_flags |= IFF_OACTIVE;
			printf("missing buffer, no_td = %d, last_td = %d\n",
			    sc->sc_no_td, sc->sc_last_td);
		}

		IF_DEQUEUE(&ifp->if_snd, m);
		if (m == 0)
			break;

#if NBPFILTER > 0
		/*
		 * If BPF is listening on this interface, let it see the packet
		 * before we commit it to the wire.
		 */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m);
#endif

		/*
		 * Copy the mbuf chain into the transmit buffer.
		 */
		len = ve_put(sc, LE_TBUFADDR(sc, bix), m);

#ifdef LEDEBUG
		if (len > ETHERMTU + sizeof(struct ether_header))
			printf("packet length %d\n", len);
#endif

		ifp->if_timer = 5;

		/*
		 * Init transmit registers, and set transmit start flag.
		 */
		tmd.tmd1_bits = LE_T1_OWN | LE_T1_STP | LE_T1_ENP;
		tmd.tmd2 = -len | LE_XMD2_ONES;
		tmd.tmd3 = 0;

		(*sc->sc_copytodesc)(sc, &tmd, rp, sizeof(tmd));

#ifdef LEDEBUG
		if (sc->sc_debug)
			ve_xmit_print(sc, sc->sc_last_td);
#endif

		(*sc->sc_wrcsr)(sc, LE_CSR0, LE_C0_INEA | LE_C0_TDMD);

		if (++bix == sc->sc_ntbuf)
			bix = 0;

		if (++sc->sc_no_td == sc->sc_ntbuf) {
			ifp->if_flags |= IFF_OACTIVE;
			break;
		}

	}

	sc->sc_last_td = bix;
}

/*
 * Process an ioctl request.
 */
int
ve_ioctl(ifp, cmd, data)
	register struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
{
	register struct vam7990_softc *sc = ifp->if_softc;
	struct ifaddr *ifa = (struct ifaddr *)data;
	struct ifreq *ifr = (struct ifreq *)data;
	int s, error = 0;

	s = splimp();

	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {
		splx(s);
		return error;
	}

	switch (cmd) {

	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;

		switch (ifa->ifa_addr->sa_family) {
#ifdef INET
		case AF_INET:
			ve_init(sc);
			arp_ifinit(&sc->sc_arpcom, ifa);
			break;
#endif
		default:
			ve_init(sc);
			break;
		}
		break;

	case SIOCSIFFLAGS:
		if ((ifp->if_flags & IFF_UP) == 0 &&
		    (ifp->if_flags & IFF_RUNNING) != 0) {
			/*
			 * If interface is marked down and it is running, then
			 * stop it.
			 */
			ve_stop(sc);
			ifp->if_flags &= ~IFF_RUNNING;
		} else if ((ifp->if_flags & IFF_UP) != 0 &&
		    	   (ifp->if_flags & IFF_RUNNING) == 0) {
			/*
			 * If interface is marked up and it is stopped, then
			 * start it.
			 */
			ve_init(sc);
		} else {
			/*
			 * Reset the interface to pick up changes in any other
			 * flags that affect hardware registers.
			 */
			/*ve_stop(sc);*/
			ve_init(sc);
		}
#ifdef LEDEBUG
		if (ifp->if_flags & IFF_DEBUG)
			sc->sc_debug = 1;
		else
			sc->sc_debug = 0;
#endif
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_arpcom) :
		    ether_delmulti(ifr, &sc->sc_arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware filter
			 * accordingly.
			 */
			ve_reset(sc);
			error = 0;
		}
		break;

	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		if (sc->sc_hasifmedia)
			error = ifmedia_ioctl(ifp, ifr, &sc->sc_ifmedia, cmd);
		else
			error = EINVAL;
		break;

	default:
		error = EINVAL;
		break;
	}

	splx(s);
	return (error);
}

void
ve_shutdown(arg)
	void *arg;
{

	ve_stop((struct vam7990_softc *)arg);
}

#ifdef LEDEBUG
void
ve_recv_print(sc, no)
	struct vam7990_softc *sc;
	int no;
{
	struct vermd rmd;
	u_int16_t len;
	struct ether_header eh;

	(*sc->sc_copyfromdesc)(sc, &rmd, LE_RMDADDR(sc, no), sizeof(rmd));
	len = rmd.rmd3;
	printf("%s: receive buffer %d, len = %d\n", sc->sc_dev.dv_xname, no,
	    len);
	printf("%s: status %04x\n", sc->sc_dev.dv_xname,
	    (*sc->sc_rdcsr)(sc, LE_CSR0));
	printf("%s: ladr %04x, hadr %02x, flags %02x, bcnt %04x, mcnt %04x\n",
	    sc->sc_dev.dv_xname,
	    rmd.rmd0, rmd.rmd1_hadr, rmd.rmd1_bits, rmd.rmd2, rmd.rmd3);
	if (len >= sizeof(eh)) {
		(*sc->sc_copyfrombuf)(sc, &eh, LE_RBUFADDR(sc, no), sizeof(eh));
		printf("%s: dst %s", sc->sc_dev.dv_xname,
			ether_sprintf(eh.ether_dhost));
		printf(" src %s type %04x\n", ether_sprintf(eh.ether_shost),
			ntohs(eh.ether_type));
	}
}

void
ve_xmit_print(sc, no)
	struct vam7990_softc *sc;
	int no;
{
	struct vetmd tmd;
	u_int16_t len;
	struct ether_header eh;

	(*sc->sc_copyfromdesc)(sc, &tmd, LE_TMDADDR(sc, no), sizeof(tmd));
	len = -tmd.tmd2;
	printf("%s: transmit buffer %d, len = %d\n", sc->sc_dev.dv_xname, no,
	    len);
	printf("%s: status %04x\n", sc->sc_dev.dv_xname,
	    (*sc->sc_rdcsr)(sc, LE_CSR0));
	printf("%s: ladr %04x, hadr %02x, flags %02x, bcnt %04x, mcnt %04x\n",
	    sc->sc_dev.dv_xname,
	    tmd.tmd0, tmd.tmd1_hadr, tmd.tmd1_bits, tmd.tmd2, tmd.tmd3);
	if (len >= sizeof(eh)) {
		(*sc->sc_copyfrombuf)(sc, &eh, LE_TBUFADDR(sc, no), sizeof(eh));
		printf("%s: dst %s", sc->sc_dev.dv_xname,
			ether_sprintf(eh.ether_dhost));
		printf(" src %s type %04x\n", ether_sprintf(eh.ether_shost),
		    ntohs(eh.ether_type));
	}
}
#endif /* LEDEBUG */

/*
 * Set up the logical address filter.
 */
void
ve_setladrf(ac, af)
	struct arpcom *ac;
	u_int16_t *af;
{
	struct ifnet *ifp = &ac->ac_if;
	struct ether_multi *enm;
	register u_char *cp, c;
	register u_int32_t crc;
	register int i, len;
	struct ether_multistep step;

	/*
	 * Set up multicast address filter by passing all multicast addresses
	 * through a crc generator, and then using the high order 6 bits as an
	 * index into the 64 bit logical address filter.  The high order bit
	 * selects the word, while the rest of the bits select the bit within
	 * the word.
	 */

	if (ifp->if_flags & IFF_PROMISC)
		goto allmulti;

	af[0] = af[1] = af[2] = af[3] = 0x0000;
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		if (ETHER_CMP(enm->enm_addrlo, enm->enm_addrhi)) {
			/*
			 * We must listen to a range of multicast addresses.
			 * For now, just accept all multicasts, rather than
			 * trying to set only those filter bits needed to match
			 * the range.  (At this time, the only use of address
			 * ranges is for IP multicast routing, for which the
			 * range is big enough to require all bits set.)
			 */
			goto allmulti;
		}

		cp = enm->enm_addrlo;
		crc = 0xffffffff;
		for (len = sizeof(enm->enm_addrlo); --len >= 0;) {
			c = *cp++;
			for (i = 8; --i >= 0;) {
				if ((crc & 0x01) ^ (c & 0x01)) {
					crc >>= 1;
					crc ^= 0xedb88320;
				} else
					crc >>= 1;
				c >>= 1;
			}
		}
		/* Just want the 6 most significant bits. */
		crc >>= 26;

		/* Set the corresponding bit in the filter. */
		af[crc >> 4] |= 1 << (crc & 0xf);

		ETHER_NEXT_MULTI(step, enm);
	}
	ifp->if_flags &= ~IFF_ALLMULTI;
	return;

allmulti:
	ifp->if_flags |= IFF_ALLMULTI;
	af[0] = af[1] = af[2] = af[3] = 0xffff;
}


/*
 * Routines for accessing the transmit and receive buffers.
 * The various CPU and adapter configurations supported by this
 * driver require three different access methods for buffers
 * and descriptors:
 *	(1) contig (contiguous data; no padding),
 *	(2) gap2 (two bytes of data followed by two bytes of padding),
 *	(3) gap16 (16 bytes of data followed by 16 bytes of padding).
 */

/*
 * contig: contiguous data with no padding.
 *
 * Buffers may have any alignment.
 */

void
ve_copytobuf_contig(sc, from, boff, len)
	struct vam7990_softc *sc;
	void *from;
	int boff, len;
{
	volatile caddr_t buf = sc->sc_mem;
	volatile caddr_t phys = (caddr_t)sc->sc_addr;
	dma_cachectl((vaddr_t)phys + boff, len, DMA_CACHE_SYNC);
	dma_cachectl((vaddr_t)buf + boff, len, DMA_CACHE_SYNC);

	/*
	 * Just call bcopy() to do the work.
	 */
	bcopy(from, buf + boff, len);
}

void
ve_copyfrombuf_contig(sc, to, boff, len)
	struct vam7990_softc *sc;
	void *to;
	int boff, len;
{
	volatile caddr_t buf = sc->sc_mem;
	volatile caddr_t phys = (caddr_t)sc->sc_addr;
	dma_cachectl((vaddr_t)phys + boff, len, DMA_CACHE_SYNC_INVAL);
	dma_cachectl((vaddr_t)buf + boff, len, DMA_CACHE_SYNC_INVAL);
	/*
	 * Just call bcopy() to do the work.
	 */
	bcopy(buf + boff, to, len);
}

void
ve_zerobuf_contig(sc, boff, len)
	struct vam7990_softc *sc;
	int boff, len;
{
	volatile caddr_t buf = sc->sc_mem;
	volatile caddr_t phys = (caddr_t)sc->sc_addr;
	dma_cachectl((vaddr_t)phys + boff, len, DMA_CACHE_SYNC);
	dma_cachectl((vaddr_t)buf + boff, len, DMA_CACHE_SYNC);

	/*
	 * Just let bzero() do the work
	 */
	bzero(buf + boff, len);
}
@


1.23
log
@Pass -Wformat, and silence a few vme* debug printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ve.c,v 1.22 2003/10/13 13:17:23 miod Exp $ */
@


1.22
log
@Do not define LEDEBUG by default.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ve.c,v 1.21 2003/10/05 20:27:47 miod Exp $ */
d395 1
a395 1
		panic("ve_config: weird memory size %d", sc->sc_memsize);
@


1.21
log
@Kill vm_offset_t and vm_size_t, in favor of the [pv]addr_t and [pv]size_t
typedefs.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ve.c,v 1.20 2003/09/29 09:08:19 miod Exp $ */
a74 3

#define LEDEBUG 1

@


1.20
log
@avaliable -> available
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ve.c,v 1.19 2003/06/02 23:27:51 millert Exp $ */
d39 1
a39 1
#include <sys/mbuf.h> 
d89 1
a89 1
void ve_read(struct vam7990_softc *, int, int); 
d151 3
a153 3
		reg1->ver1_ear=((cmd|(addr<<1))>>i); 
		CDELAY; 
	} 
d174 1
a174 1
		(reg1->ver1_ear & 0x01) ? 
d179 1
a179 1
	(reg1->ver1_ear & 0x01) ? 
d274 1
a274 1
	
d294 1
a294 1
	
d296 1
a296 1
	
d300 1
a300 1
	sc->sc_addr = kvtop((vm_offset_t)sc->sc_mem);
d403 1
a403 1
	printf("%s: %d receive buffers, %d transmit buffers\n", 
d885 1
a885 1
			isr & (LE_C0_INEA | LE_C0_BABL | LE_C0_MISS | 
d1297 2
a1298 2
	dma_cachectl((vm_offset_t)phys + boff, len, DMA_CACHE_SYNC);
	dma_cachectl((vm_offset_t)buf + boff, len, DMA_CACHE_SYNC);
d1314 2
a1315 2
	dma_cachectl((vm_offset_t)phys + boff, len, DMA_CACHE_SYNC_INVAL);
	dma_cachectl((vm_offset_t)buf + boff, len, DMA_CACHE_SYNC_INVAL);
d1329 2
a1330 2
	dma_cachectl((vm_offset_t)phys + boff, len, DMA_CACHE_SYNC);
	dma_cachectl((vm_offset_t)buf + boff, len, DMA_CACHE_SYNC);
@


1.19
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ve.c,v 1.18 2002/04/28 15:17:09 miod Exp $ */
d280 1
a280 1
	/* get the first avaliable etherbuf */
@


1.18
log
@Use the prototypes defined via cdev_decl() macros, instead of rolling our
own; thus fix a lot of foo_open(), foo_close() and foo_ioctl() prototypes
in the process.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ve.c,v 1.17 2002/03/14 01:26:39 millert Exp $ */
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.17
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ve.c,v 1.16 2002/03/05 22:11:37 miod Exp $ */
a151 1
	u_char rcmd = 0;
a153 3
	rcmd = addr;
	rcmd = rcmd << 3;
	rcmd |= cmd;
@


1.16
log
@Kill prom stuff duplicates from bugio.[ch].
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ve.c,v 1.15 2001/12/22 18:45:35 smurph Exp $ */
d84 2
a85 2
void ve_recv_print __P((struct vam7990_softc *, int));
void ve_xmit_print __P((struct vam7990_softc *, int));
d88 2
a89 2
void ve_rint __P((struct vam7990_softc *));
void ve_tint __P((struct vam7990_softc *));
d91 3
a93 3
int ve_put __P((struct vam7990_softc *, int, struct mbuf *));
struct mbuf *ve_get __P((struct vam7990_softc *, int, int));
void ve_read __P((struct vam7990_softc *, int, int)); 
d95 1
a95 1
void ve_shutdown __P((void *));
d137 6
a142 6
void vewrcsr __P((struct vam7990_softc *, u_int16_t, u_int16_t));
u_int16_t verdcsr __P((struct vam7990_softc *, u_int16_t));
void nvram_cmd __P((struct vam7990_softc *, u_char, u_short));
u_int16_t nvram_read __P((struct vam7990_softc *, u_char));
void vereset __P((struct vam7990_softc *));
void ve_ackint __P((struct vam7990_softc *));
@


1.15
log
@Correct badvaddr() usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ve.c,v 1.14 2001/12/22 09:49:39 smurph Exp $ */
a72 1
#include <machine/bugio.h>
@


1.14
log
@masive cmmu overhaul.  function pointers now control cmmu functionality
instead of case statements based on cpu type.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ve.c,v 1.13 2001/12/16 23:49:46 miod Exp $ */
d250 2
a251 1
	if (!badvaddr((unsigned)ca->ca_vaddr, 1)) {
a252 3
	} else {
		return (0);
	}           
@


1.13
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ve.c,v 1.11 2001/11/06 19:53:15 miod Exp $ */
d74 1
a74 1
#include <machine/mmu.h>	/* DMA_CACHE_SYNC, etc... */
@


1.13.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ve.c,v 1.15 2001/12/22 18:45:35 smurph Exp $ */
d74 1
a74 1
#include <machine/cmmu.h>	/* DMA_CACHE_SYNC, etc... */
d250 3
a252 1
	if (badvaddr((unsigned)ca->ca_vaddr, 1))
d254 1
a254 1
		return (1);
@


1.13.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ve.c,v 1.13.2.1 2002/01/31 22:55:17 niklas Exp $ */
d73 1
d85 2
a86 2
void ve_recv_print(struct vam7990_softc *, int);
void ve_xmit_print(struct vam7990_softc *, int);
d89 2
a90 2
void ve_rint(struct vam7990_softc *);
void ve_tint(struct vam7990_softc *);
d92 3
a94 3
int ve_put(struct vam7990_softc *, int, struct mbuf *);
struct mbuf *ve_get(struct vam7990_softc *, int, int);
void ve_read(struct vam7990_softc *, int, int); 
d96 1
a96 1
void ve_shutdown(void *);
d138 6
a143 6
void vewrcsr(struct vam7990_softc *, u_int16_t, u_int16_t);
u_int16_t verdcsr(struct vam7990_softc *, u_int16_t);
void nvram_cmd(struct vam7990_softc *, u_char, u_short);
u_int16_t nvram_read(struct vam7990_softc *, u_char);
void vereset(struct vam7990_softc *);
void ve_ackint(struct vam7990_softc *);
d153 1
d156 3
@


1.12
log
@Support for MVME197 completed.  Fix SPL defs.
@
text
@d74 1
a74 1
#include <machine/cmmu.h>	/* DMA_CACHE_SYNC, etc... */
d250 3
a252 1
	if (badvaddr((unsigned)ca->ca_vaddr, 1))
d254 1
a254 1
	return (1);
@


1.11
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ve.c,v 1.10 2001/09/11 20:05:24 miod Exp $ */
d74 1
a74 1
#include <machine/mmu.h>	/* DMA_CACHE_SYNC, etc... */
d250 1
a250 3
	if (!badvaddr((unsigned)ca->ca_vaddr, 1)) {
		return (1);
	} else {
d252 1
a252 1
	}           
@


1.10
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ve.c,v 1.9 2001/08/26 02:37:07 miod Exp $ */
d69 1
a69 1
#include <vm/vm.h>
@


1.9
log
@Add prototypes, fix compilation warnings, random style fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ve.c,v 1.8 2001/08/11 23:21:13 art Exp $ */
a69 1
#include <vm/vm_kern.h>
@


1.8
log
@Unnecessary and redundant includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ve.c,v 1.7 2001/07/09 22:28:27 fgsch Exp $ */
d90 2
a91 2
integrate void ve_rint __P((struct vam7990_softc *));
integrate void ve_tint __P((struct vam7990_softc *));
d93 3
a95 3
integrate int ve_put __P((struct vam7990_softc *, int, struct mbuf *));
integrate struct mbuf *ve_get __P((struct vam7990_softc *, int, int));
integrate void ve_read __P((struct vam7990_softc *, int, int)); 
d97 1
a97 1
hide void ve_shutdown __P((void *));
d139 6
a144 2
hide void vewrcsr __P((struct vam7990_softc *, u_int16_t, u_int16_t));
hide u_int16_t verdcsr __P((struct vam7990_softc *, u_int16_t));
d148 1
a148 1
nvram_cmd(sc, cmd, addr )
d196 1
a196 1
hide void
d207 1
a207 1
hide u_int16_t
d312 1
a312 1
	sc->sc_addr = kvtop(sc->sc_mem);
d583 1
a583 1
integrate int
d616 1
a616 1
integrate struct mbuf *
d664 1
a664 1
integrate void
d710 1
d722 1
a722 1
integrate void
d797 1
a797 1
integrate void
d1150 1
a1150 1
hide void
a1348 2


@


1.7
log
@trivial ether_input_mbuf().
btw, shouldn't this code share the am7990 core?
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ve.c,v 1.6 2001/03/09 05:44:39 smurph Exp $ */
a69 1
#include <vm/vm_map.h>
@


1.6
log
@kernel will compile with -Werror.  Added intr.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ve.c,v 1.5 2001/03/08 00:03:13 miod Exp $ */
d667 1
d669 1
a689 3
	/* We assume that the header fit entirely in one mbuf. */
	eh = mtod(m, struct ether_header *);

d714 2
a715 3
	/* Pass the packet up, with the ether header sort-of removed. */
	m_adj(m, sizeof(struct ether_header));
	ether_input(ifp, eh, m);
@


1.5
log
@Some warning hunting.
Define new include files for convenience, for use by drivers who can
attach either to pcctwo or syscon, or need bug console routines.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ve.c,v 1.4 2001/02/20 19:39:32 mickey Exp $ */
d146 3
a148 3
struct vam7990_softc *sc;
u_char cmd;
u_short addr;
d166 2
a167 2
struct vam7990_softc *sc;
u_char nvram_addr;
d220 1
a220 1
struct vam7990_softc *sc;
d234 1
a234 1
struct vam7990_softc *sc;
d243 2
a244 2
struct device *parent;
void *vcf, *args;
d248 1
a248 1
	if (!badvaddr(ca->ca_vaddr, 1)) {
d262 3
a264 3
struct device *parent;
struct device *self;
void *aux;
d341 1
a341 1
struct vam7990_softc *sc;
d355 1
a355 1
struct vam7990_softc *sc;
d452 1
a452 1
register struct vam7990_softc *sc;
@


1.4
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ve.c,v 1.3 2001/02/12 08:16:23 smurph Exp $ */
a151 1
	u_char rcmd2= 0;
a171 1
	int i;
a268 1
	register int a;
a271 3
	char *cp;
	int i, ipl;

d334 1
@


1.3
log
@correct buginstat(), statclock now working for '188, systat vmstat now works,
serial driver for '188 working better.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ve.c,v 1.2 2001/02/01 03:38:14 smurph Exp $ */
a381 4

#if NBPFILTER > 0
	bpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, sizeof(struct ether_header));
#endif
@


1.2
log
@Major changes to get MVME188 working.  More header and code cleanups.  The
kernel is tested on MVME188A/2P256 and MVME188A/1P64.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ve.c,v 1.1 1999/05/29 04:41:43 smurph Exp $ */
d144 1
d150 3
a152 3
   int i;
   u_char rcmd = 0;
   u_char rcmd2= 0;
d154 8
a161 8
   
   rcmd = addr;
   rcmd = rcmd << 3;
   rcmd |= cmd;
   for(i=0;i<8;i++){ 
      reg1->ver1_ear=((cmd|(addr<<1))>>i); 
      CDELAY; 
   } 
d170 4
a173 4
   u_short val = 0, mask = 0x04000;
   u_int16_t wbit;
   /* these used by macros DO NOT CHANGE!*/
   int i;
d175 18
a192 16
   sc->csr = 0x4f;
   ENABLE_NVRAM;
   nvram_cmd(sc, NVRAM_RCL, 0);
   DISABLE_NVRAM;
   CDELAY;
   ENABLE_NVRAM;
   nvram_cmd(sc, NVRAM_READ, nvram_addr);
   for (wbit=0; wbit<15; wbit++) {
      (reg1->ver1_ear & 0x01) ? (val = (val | mask)) : (val = (val & (~mask)));
      mask = mask>>1;
      CDELAY;
   }
   (reg1->ver1_ear & 0x01) ? (val = (val | 0x8000)) : (val = (val & 0x7FFF));
   CDELAY;
   DISABLE_NVRAM;
   return (val);
d222 1
a222 1
	struct vam7990_softc *sc;
d225 5
a229 5
   u_char vec = ((struct ve_softc *)sc)->sc_vec;
   u_char ipl = ((struct ve_softc *)sc)->sc_ipl;
   sc->csr = 0x4f;
   WRITE_CSR_AND( ~ipl );
   SET_VEC(vec);
d240 1
d245 2
a246 2
	struct device *parent;
	void *vcf, *args;
d251 2
a252 6
      if (ca->ca_vec & 0x03) {
         printf("ve: bad vector 0x%x\n", ca->ca_vec);
         return (0);
      }
		return(1);
   } else {
d254 1
a254 1
	}	    
d264 3
a266 3
	struct device *parent;
	struct device *self;
	void *aux;
d291 2
a292 2
   lesc->sc_ipl = ca->ca_ipl;
   lesc->sc_vec = ca->ca_vec;
d294 19
a312 16
   /* get the first avaliable etherbuf */
   switch ((int)ca->ca_paddr) {
   case 0xFFFF1200:
      addr = (caddr_t)0xFD6C0000;
      break;
   case 0xFFFF1400:
      addr = (caddr_t)0xFD700000;
      break;
   case 0xFFFF1600:
      addr = (caddr_t)0xFD740000;
      break;
   default:
      panic("ve: invalid address");
   }
   sc->sc_mem = (void *)mapiodev(addr, LEMEMSIZE);
   if (sc->sc_mem == NULL) panic("ve: no more memory in external I/O map");
d316 1
a316 1
	
d319 1
a319 1
	
d348 8
a355 8
   u_char * cp = sc->sc_arpcom.ac_enaddr;
   u_int16_t ival[3];
   u_char i;
   
   for (i=0; i<3; i++) {
      ival[i] = nvram_read(sc, i);
   }
   memcpy(cp, &ival[0], 6);
d360 1
a360 1
	struct vam7990_softc *sc;
d374 1
a374 1
	    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;
d420 1
a420 1
          ether_sprintf(sc->sc_arpcom.ac_enaddr));
d422 1
a422 1
          sc->sc_dev.dv_xname, sc->sc_nrbuf, sc->sc_ntbuf);
d461 1
a461 1
	register struct vam7990_softc *sc;
d476 1
a476 1
	    (sc->sc_arpcom.ac_enaddr[1] << 8) | sc->sc_arpcom.ac_enaddr[0];
d478 1
a478 1
	    (sc->sc_arpcom.ac_enaddr[3] << 8) | sc->sc_arpcom.ac_enaddr[2];
d480 1
a480 1
	    (sc->sc_arpcom.ac_enaddr[5] << 8) | sc->sc_arpcom.ac_enaddr[4];
d507 1
a507 1
		    sizeof(rmd));
d517 2
a518 2
		tmd.tmd1_bits = 0;
		tmd.tmd2 = 0 | LE_XMD2_ONES;
d521 1
a521 1
		    sizeof(tmd));
@


1.1
log
@Added vme bus device drivers. MVME328, MVME376, MVME332
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ve.c,v 1.0 1999/04286 22:41:18 smurph Exp $ */
d76 1
d113 11
a123 11
	struct vam7990_softc  sc_am7990; /* glue to MI code */
	struct intrhand      sc_ih;      /* interrupt vectoring */
	struct vereg1        *sc_r1;     /* LANCE registers */
	u_short              csr;        /* Control/Status reg image */
   u_long               board_addr;
	struct evcnt	      sc_intrcnt;
	struct evcnt	      sc_errcnt;
	struct vme2reg	      *sc_vme2;
	u_char               sc_ipl;
	u_char               sc_vec;
	int                  sc_flags;
d236 1
a236 1
   ENABLE_INTR;
d330 1
a330 1
   vereset(sc);
d388 1
a388 1
   case 8192:
d900 3
a902 3
   (*sc->sc_wrcsr)(sc, LE_CSR0,
	    isr & (LE_C0_INEA | LE_C0_BABL | LE_C0_MISS | LE_C0_MERR |
		   LE_C0_RINT | LE_C0_TINT | LE_C0_IDON));
d946 1
a946 1
   ve_ackint(sc);
d1312 3
d1329 3
a1331 1

d1344 3
@


1.1.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ve.c,v 1.6 2001/03/09 05:44:39 smurph Exp $ */
a75 1
#include <machine/mmu.h>	/* DMA_CACHE_SYNC, etc... */
d112 11
a122 11
	struct vam7990_softc	sc_am7990; /* glue to MI code */
	struct intrhand		sc_ih;      /* interrupt vectoring */
	struct vereg1		*sc_r1;     /* LANCE registers */
	u_short			csr;        /* Control/Status reg image */
	u_long			board_addr;
	struct evcnt		sc_intrcnt;
	struct evcnt		sc_errcnt;
	struct vme2reg		*sc_vme2;
	u_char			sc_ipl;
	u_char			sc_vec;
	int			sc_flags;
a142 1
void
d144 7
a150 6
	struct vam7990_softc *sc;
	u_char cmd;
	u_short addr;
{
	int i;
	u_char rcmd = 0;
d152 8
a159 8

	rcmd = addr;
	rcmd = rcmd << 3;
	rcmd |= cmd;
	for (i=0;i<8;i++) {
		reg1->ver1_ear=((cmd|(addr<<1))>>i); 
		CDELAY; 
	} 
d165 2
a166 2
	struct vam7990_softc *sc;
	u_char nvram_addr;
d168 4
a171 3
	u_short val = 0, mask = 0x04000;
	u_int16_t wbit;
	/* these used by macros DO NOT CHANGE!*/
d173 16
a188 18
	sc->csr = 0x4f;
	ENABLE_NVRAM;
	nvram_cmd(sc, NVRAM_RCL, 0);
	DISABLE_NVRAM;
	CDELAY;
	ENABLE_NVRAM;
	nvram_cmd(sc, NVRAM_READ, nvram_addr);
	for (wbit=0; wbit<15; wbit++) {
		(reg1->ver1_ear & 0x01) ? 
			(val = (val | mask)) : (val = (val & (~mask)));
		mask = mask>>1;
		CDELAY;
	}
	(reg1->ver1_ear & 0x01) ? 
		(val = (val | 0x8000)) : (val = (val & 0x7FFF));
	CDELAY;
	DISABLE_NVRAM;
	return (val);
d221 5
a225 5
	u_char vec = ((struct ve_softc *)sc)->sc_vec;
	u_char ipl = ((struct ve_softc *)sc)->sc_ipl;
	sc->csr = 0x4f;
	WRITE_CSR_AND( ~ipl );
	SET_VEC(vec);
d232 1
a232 1
	struct vam7990_softc *sc;
d235 1
a235 2
	ENABLE_INTR;
        CLEAR_INTR;
d245 7
a251 3
	if (!badvaddr((unsigned)ca->ca_vaddr, 1)) {
		return (1);
	} else {
d253 1
a253 1
	}           
d270 1
d274 3
d290 2
a291 3
	lesc->sc_ipl = ca->ca_ipl;
	lesc->sc_vec = ca->ca_vec;

d293 16
a308 18
	/* get the first avaliable etherbuf */
	switch ((int)ca->ca_paddr) {
	case 0xFFFF1200:
		addr = (caddr_t)0xFD6C0000;
		break;
	case 0xFFFF1400:
		addr = (caddr_t)0xFD700000;
		break;
	case 0xFFFF1600:
		addr = (caddr_t)0xFD740000;
		break;
	default:
		panic("ve: invalid address");
	}
	
	sc->sc_mem = (void *)mapiodev(addr, LEMEMSIZE);
	
	if (sc->sc_mem == NULL)	panic("ve: no more memory in external I/O map");
d312 1
a312 1

d315 1
a315 1

d329 1
a329 1
	vereset(sc);
a335 1
	lesc->sc_ih.ih_wantframe = 0;
d342 1
a342 1
	struct vam7990_softc *sc;
d344 8
a351 8
	u_char * cp = sc->sc_arpcom.ac_enaddr;
	u_int16_t ival[3];
	u_char i;

	for (i=0; i<3; i++) {
		ival[i] = nvram_read(sc, i);
	}
	memcpy(cp, &ival[0], 6);
d370 1
a370 1
	IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;
d379 4
d387 1
a387 1
	case 8192:
d416 1
a416 1
	       ether_sprintf(sc->sc_arpcom.ac_enaddr));
d418 1
a418 1
	       sc->sc_dev.dv_xname, sc->sc_nrbuf, sc->sc_ntbuf);
d472 1
a472 1
	(sc->sc_arpcom.ac_enaddr[1] << 8) | sc->sc_arpcom.ac_enaddr[0];
d474 1
a474 1
	(sc->sc_arpcom.ac_enaddr[3] << 8) | sc->sc_arpcom.ac_enaddr[2];
d476 1
a476 1
	(sc->sc_arpcom.ac_enaddr[5] << 8) | sc->sc_arpcom.ac_enaddr[4];
d503 1
a503 1
				     sizeof(rmd));
d513 2
a514 2
		tmd.tmd1_bits = LE_R1_STP | LE_R1_ENP;
		tmd.tmd2 = -2000 | LE_XMD2_ONES;
d517 1
a517 1
				     sizeof(tmd));
d899 3
a901 3
	(*sc->sc_wrcsr)(sc, LE_CSR0,
			isr & (LE_C0_INEA | LE_C0_BABL | LE_C0_MISS | 
			       LE_C0_MERR | LE_C0_RINT | LE_C0_TINT | LE_C0_IDON));
d945 1
a945 1
	ve_ackint(sc);
a1310 3
	volatile caddr_t phys = (caddr_t)sc->sc_addr;
	dma_cachectl((vm_offset_t)phys + boff, len, DMA_CACHE_SYNC);
	dma_cachectl((vm_offset_t)buf + boff, len, DMA_CACHE_SYNC);
d1325 1
a1325 3
	volatile caddr_t phys = (caddr_t)sc->sc_addr;
	dma_cachectl((vm_offset_t)phys + boff, len, DMA_CACHE_SYNC_INVAL);
	dma_cachectl((vm_offset_t)buf + boff, len, DMA_CACHE_SYNC_INVAL);
a1337 3
	volatile caddr_t phys = (caddr_t)sc->sc_addr;
	dma_cachectl((vm_offset_t)phys + boff, len, DMA_CACHE_SYNC);
	dma_cachectl((vm_offset_t)buf + boff, len, DMA_CACHE_SYNC);
@


1.1.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ve.c,v 1.1.4.1 2001/04/18 16:10:56 niklas Exp $ */
d70 2
d91 2
a92 2
void ve_rint __P((struct vam7990_softc *));
void ve_tint __P((struct vam7990_softc *));
d94 3
a96 3
int ve_put __P((struct vam7990_softc *, int, struct mbuf *));
struct mbuf *ve_get __P((struct vam7990_softc *, int, int));
void ve_read __P((struct vam7990_softc *, int, int)); 
d98 1
a98 1
void ve_shutdown __P((void *));
d140 2
a141 6
void vewrcsr __P((struct vam7990_softc *, u_int16_t, u_int16_t));
u_int16_t verdcsr __P((struct vam7990_softc *, u_int16_t));
void nvram_cmd __P((struct vam7990_softc *, u_char, u_short));
u_int16_t nvram_read __P((struct vam7990_softc *, u_char));
void vereset __P((struct vam7990_softc *));
void ve_ackint __P((struct vam7990_softc *));
d145 1
a145 1
nvram_cmd(sc, cmd, addr)
d193 1
a193 1
void
d204 1
a204 1
u_int16_t
d309 1
a309 1
	sc->sc_addr = kvtop((vm_offset_t)sc->sc_mem);
d580 1
a580 1
int
d613 1
a613 1
struct mbuf *
d661 1
a661 1
void
a666 1
#ifdef LANCE_REVC_BUG
a667 1
#endif
d688 3
a707 1
	eh = mtod(m, struct ether_header *);
d715 3
a717 2
	/* Pass the packet up. */
	ether_input_mbuf(ifp, m);
d720 1
a720 1
void
d795 1
a795 1
void
d1148 1
a1148 1
void
d1347 2
@


1.1.4.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d69 1
a69 1
#include <uvm/uvm_extern.h>
@


1.1.4.4
log
@Merge in trunk
@
text
@d73 2
a74 1
#include <machine/cmmu.h>	/* DMA_CACHE_SYNC, etc... */
d250 3
a252 1
	if (badvaddr((unsigned)ca->ca_vaddr, 1))
d254 1
a254 1
		return (1);
@


1.1.4.5
log
@Merge in -current from about a week ago
@
text
@d84 2
a85 2
void ve_recv_print(struct vam7990_softc *, int);
void ve_xmit_print(struct vam7990_softc *, int);
d88 2
a89 2
void ve_rint(struct vam7990_softc *);
void ve_tint(struct vam7990_softc *);
d91 3
a93 3
int ve_put(struct vam7990_softc *, int, struct mbuf *);
struct mbuf *ve_get(struct vam7990_softc *, int, int);
void ve_read(struct vam7990_softc *, int, int); 
d95 1
a95 1
void ve_shutdown(void *);
d137 6
a142 6
void vewrcsr(struct vam7990_softc *, u_int16_t, u_int16_t);
u_int16_t verdcsr(struct vam7990_softc *, u_int16_t);
void nvram_cmd(struct vam7990_softc *, u_char, u_short);
u_int16_t nvram_read(struct vam7990_softc *, u_char);
void vereset(struct vam7990_softc *);
void ve_ackint(struct vam7990_softc *);
@


1.1.4.6
log
@Sync the SMP branch with 3.3
@
text
@d152 1
d155 3
@


1.1.4.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ve.c,v 1.1.4.6 2003/03/27 23:32:18 niklas Exp $ */
d15 5
a19 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.1.4.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ve.c,v 1.1.4.7 2003/06/07 11:13:16 ho Exp $ */
@


