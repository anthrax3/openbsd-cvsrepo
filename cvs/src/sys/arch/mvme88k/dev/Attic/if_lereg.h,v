head	1.7;
access;
symbols
	OPENBSD_5_5:1.6.0.30
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.26
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.24
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.22
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.20
	OPENBSD_5_0:1.6.0.18
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.16
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.14
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.10
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.12
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.8
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.6
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.4
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.2
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.5.0.4
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.3.0.8
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.6
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.4
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	OPENBSD_3_5:1.2.0.4
	OPENBSD_3_5_BASE:1.2
	SMP:1.2.0.2;
locks; strict;
comment	@ * @;


1.7
date	2014.03.18.22.36.36;	author miod;	state dead;
branches;
next	1.6;

1.6
date	2007.05.25.21.27.15;	author krw;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.27.06.27.03;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2006.04.26.21.06.08;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.17.08.36.22;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2003.12.30.21.25.59;	author miod;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2003.12.27.23.58.11;	author miod;	state Exp;
branches;
next	;

1.2.2.1
date	2004.06.05.23.09.49;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: if_lereg.h,v 1.6 2007/05/25 21:27:15 krw Exp $ */

/*-
 * Copyright (c) 1982, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * @@(#)if_lereg.h	8.2 (Berkeley) 10/30/93
 */

#define	VLEMEMSIZE	0x00040000
#define	VLEMEMBASE	0xfd6c0000

/*
 * LANCE registers for MVME376
 */
struct vlereg1 {
	volatile u_int16_t	ler1_csr;	/* board control/status register */
	volatile u_int16_t	ler1_vec;	/* interrupt vector register */
	volatile u_int16_t	ler1_rdp;	/* data port */
	volatile u_int16_t	ler1_rap;	/* register select port */
	volatile u_int16_t	ler1_ear;	/* ethernet address register */
};

#define	NVRAM_EN	0x0008	/* NVRAM enable bit (active low) */
#define	INTR_EN		0x0010	/* interrupt enable bit (active low) */
#define	PARITYB		0x0020	/* parity error clear bit */
#define	HW_RS		0x0040	/* hardware reset bit (active low) */
#define	SYSFAILB	0x0080	/* SYSFAIL bit */

#define	NVRAM_RWEL	0xe0	/* Reset write enable latch      */
#define	NVRAM_STO	0x60	/* Store ram to eeprom           */
#define	NVRAM_SLP	0xa0	/* Novram into low power mode    */
#define	NVRAM_WRITE	0x20	/* Writes word from location x   */
#define	NVRAM_SWEL	0xc0	/* Set write enable latch        */
#define	NVRAM_RCL	0x40	/* Recall eeprom data into ram   */
#define	NVRAM_READ	0x00	/* Reads word from location x    */

#define	CDELAY		delay(10000)
#define	WRITE_CSR_OR(x) \
	do { \
		((struct le_softc *)sc)->sc_csr |= (x); \
		reg1->ler1_csr = ((struct le_softc *)sc)->sc_csr; \
	} while (0)
#define	WRITE_CSR_AND(x) \
	do { \
		((struct le_softc *)sc)->sc_csr &= ~(x); \
		reg1->ler1_csr = ((struct le_softc *)sc)->sc_csr; \
	} while (0)
#define	ENABLE_NVRAM	WRITE_CSR_AND(NVRAM_EN)
#define	DISABLE_NVRAM	WRITE_CSR_OR(NVRAM_EN)
#define	ENABLE_INTR	WRITE_CSR_AND(INTR_EN)
#define	DISABLE_INTR	WRITE_CSR_OR(INTR_EN)
#define	RESET_HW \
	do { \
		WRITE_CSR_AND(HW_RS); \
		CDELAY; \
	} while (0)
#define	SET_VEC(x) \
	reg1->ler1_vec = (x)
#define	SYSFAIL_CL	WRITE_CSR_AND(SYSFAILB)
@


1.6
log
@"interupt" -> "interrupt" in various comments. Mostly from Diego Casati.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lereg.h,v 1.5 2006/04/27 06:27:03 miod Exp $ */
@


1.5
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lereg.h,v 1.4 2006/04/26 21:06:08 miod Exp $ */
d42 1
a42 1
	volatile u_int16_t	ler1_vec;	/* interupt vector register */
@


1.4
log
@The dual-ported memory of the MVME376 boards is D32 addressable, say the
documentation, so we can use the MI {zero,copy{to,from}}buf_contig
callbacks, which rely upon bcopy() and bzero(), instead of their d16_bcopy()
and d16_bzero() equivalents. No functional change, except an unnoticeable
speedup.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lereg.h,v 1.3 2004/05/17 08:36:22 miod Exp $ */
d83 1
a83 1
	reg1->ler1_vec |= (x)
@


1.3
log
@KNF and minor cleaning.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lereg.h,v 1.2 2003/12/30 21:25:59 miod Exp $ */
d48 5
a52 5
#define	NVRAM_EN	0x0008	/* NVRAM enable bit              */
#define	INTR_EN		0x0010	/* Interrupt enable bit          */
#define	PARITYB		0x0020	/* Parity clear bit              */
#define	HW_RS		0x0040	/* Hardware reset bit            */
#define	SYSFAILB	0x0080	/* SYSFAIL bit                   */
a78 1
		WRITE_CSR_AND(0xff00); \
d83 1
a83 4
	do { \
		reg1->ler1_vec = 0; \
		reg1->ler1_vec |= (x); \
	} while (0)
@


1.2
log
@Add support for all six Motorola-supported configurations of MVME376
cards. The original code would only work with the first configuration,
as the etherbuf addresses grow _downwards_ from 0xfd6c0000 with Motorola's
jumper configuration.

Reference: MVME376 Ethernet Communication Controller User's Manual (MVME376/D1)

While there, do not panic() on failure to attach, but simply print an
error message and return.

XXX Proper care of the memory mapping still needs to be written, as the memory
XXX space of the MVME376 is always outside extio.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lereg.h,v 1.1 2003/12/27 23:58:11 miod Exp $ */
d34 1
a34 1
#define	VLEMEMSIZE	0x00040000 
d41 5
a45 5
   volatile u_int16_t      ler1_csr;       /* board control/status register */
   volatile u_int16_t      ler1_vec;       /* interupt vector register */
   volatile u_int16_t      ler1_rdp;       /* data port */
   volatile u_int16_t      ler1_rap;       /* register select port */
   volatile u_int16_t      ler1_ear;       /* ethernet address register */
d48 41
a88 32
#define NVRAM_EN    0x0008 /* NVRAM enable bit              */
#define INTR_EN     0x0010 /* Interrupt enable bit          */
#define PARITYB     0x0020 /* Parity clear bit              */
#define HW_RS       0x0040 /* Hardware reset bit            */
#define SYSFAILB    0x0080 /* SYSFAIL bit                   */
#define NVRAM_RWEL   0xE0  /* Reset write enable latch      */
#define NVRAM_STO    0x60  /* Store ram to eeprom           */
#define NVRAM_SLP    0xA0  /* Novram into low power mode    */
#define NVRAM_WRITE  0x20  /* Writes word from location x   */
#define NVRAM_SWEL   0xC0  /* Set write enable latch        */
#define NVRAM_RCL    0x40  /* Recall eeprom data into ram   */
#define NVRAM_READ   0x00  /* Reads word from location x    */

#define CDELAY  delay(10000)
#define WRITE_CSR_OR(x)    reg1->ler1_csr=((struct le_softc *)sc)->csr|=x
#define WRITE_CSR_AND(x)   reg1->ler1_csr=((struct le_softc *)sc)->csr&=x
#define ENABLE_NVRAM       WRITE_CSR_AND(~NVRAM_EN)
#define DISABLE_NVRAM      WRITE_CSR_OR(NVRAM_EN)
#define ENABLE_INTR        WRITE_CSR_AND(~INTR_EN)
#define DISABLE_INTR       WRITE_CSR_OR(INTR_EN)
#define RESET_HW           WRITE_CSR_AND(~0xFF00);WRITE_CSR_AND(~HW_RS);CDELAY
#define SET_IPL(x)         WRITE_CSR_AND(~x)
#define SET_VEC(x)         reg1->ler1_vec=0;reg1->ler1_vec |=x;
#define PARITY_CL          WRITE_CSR_AND(~PARITYB)
#define SYSFAIL_CL         WRITE_CSR_AND(~SYSFAILB)
#define NVRAM_CMD(c,a)     for(i=0;i<8;i++){ \
                              reg1->ler1_ear=((c|(a<<1))>>i); \
                              CDELAY; \
                           } \
                           CDELAY;


@


1.2.2.1
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d34 1
a34 1
#define	VLEMEMSIZE	0x00040000
d41 5
a45 5
	volatile u_int16_t	ler1_csr;	/* board control/status register */
	volatile u_int16_t	ler1_vec;	/* interupt vector register */
	volatile u_int16_t	ler1_rdp;	/* data port */
	volatile u_int16_t	ler1_rap;	/* register select port */
	volatile u_int16_t	ler1_ear;	/* ethernet address register */
d48 32
a79 41
#define	NVRAM_EN	0x0008	/* NVRAM enable bit              */
#define	INTR_EN		0x0010	/* Interrupt enable bit          */
#define	PARITYB		0x0020	/* Parity clear bit              */
#define	HW_RS		0x0040	/* Hardware reset bit            */
#define	SYSFAILB	0x0080	/* SYSFAIL bit                   */

#define	NVRAM_RWEL	0xe0	/* Reset write enable latch      */
#define	NVRAM_STO	0x60	/* Store ram to eeprom           */
#define	NVRAM_SLP	0xa0	/* Novram into low power mode    */
#define	NVRAM_WRITE	0x20	/* Writes word from location x   */
#define	NVRAM_SWEL	0xc0	/* Set write enable latch        */
#define	NVRAM_RCL	0x40	/* Recall eeprom data into ram   */
#define	NVRAM_READ	0x00	/* Reads word from location x    */

#define	CDELAY		delay(10000)
#define	WRITE_CSR_OR(x) \
	do { \
		((struct le_softc *)sc)->sc_csr |= (x); \
		reg1->ler1_csr = ((struct le_softc *)sc)->sc_csr; \
	} while (0)
#define	WRITE_CSR_AND(x) \
	do { \
		((struct le_softc *)sc)->sc_csr &= ~(x); \
		reg1->ler1_csr = ((struct le_softc *)sc)->sc_csr; \
	} while (0)
#define	ENABLE_NVRAM	WRITE_CSR_AND(NVRAM_EN)
#define	DISABLE_NVRAM	WRITE_CSR_OR(NVRAM_EN)
#define	ENABLE_INTR	WRITE_CSR_AND(INTR_EN)
#define	DISABLE_INTR	WRITE_CSR_OR(INTR_EN)
#define	RESET_HW \
	do { \
		WRITE_CSR_AND(0xff00); \
		WRITE_CSR_AND(HW_RS); \
		CDELAY; \
	} while (0)
#define	SET_VEC(x) \
	do { \
		reg1->ler1_vec = 0; \
		reg1->ler1_vec |= (x); \
	} while (0)
#define	SYSFAIL_CL	WRITE_CSR_AND(SYSFAILB)
@


1.1
log
@Replace the MVME376 driver from a homemade and dusty if_ve driver to
a ``regular'' if_le driver, sharing the common am7990 code.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lereg.h,v 1.7 2003/06/02 23:27:50 millert Exp $ */
d34 2
a35 1
#define VLEMEMSIZE 0x40000 
@

