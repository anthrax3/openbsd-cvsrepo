head	1.17;
access;
symbols
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.6
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.4
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.12
	UBC:1.8.0.2
	UBC_BASE:1.8
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.1.0.8
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.6
	OPENBSD_2_7_BASE:1.1
	SMP:1.1.0.4
	SMP_BASE:1.1
	kame_19991208:1.1
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.17
date	2003.10.11.22.06.50;	author miod;	state dead;
branches;
next	1.16;

1.16
date	2003.10.08.22.36.11;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2003.10.05.20.25.08;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.02.23.27.51;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.02.07.06.56;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.14.01.26.39;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.05.22.11.37;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2002.01.14.21.34.39;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.20.06.07.28;	author smurph;	state Exp;
branches;
next	1.8;

1.8
date	2001.12.16.23.49.46;	author miod;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2001.12.13.08.55.51;	author smurph;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.26.02.37.07;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.09.05.44.39;	author smurph;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.07.23.45.51;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.12.08.16.23;	author smurph;	state Exp;
branches;
next	1.2;

1.2
date	2001.02.01.03.38.14;	author smurph;	state Exp;
branches;
next	1.1;

1.1
date	99.09.27.18.43.25;	author smurph;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2001.04.18.16.11.00;	author niklas;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2001.10.31.03.01.18;	author nate;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2002.03.06.02.04.44;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2002.03.28.10.36.02;	author niklas;	state Exp;
branches;
next	1.1.4.5;

1.1.4.5
date	2003.06.07.11.13.16;	author ho;	state Exp;
branches;
next	1.1.4.6;

1.1.4.6
date	2004.02.19.10.49.06;	author niklas;	state dead;
branches;
next	;

1.8.2.1
date	2002.01.31.22.55.17;	author niklas;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2002.06.11.03.37.10;	author art;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Merge sclock and clock pseudo-devices.
@
text
@/*	$OpenBSD: sclock.c,v 1.16 2003/10/08 22:36:11 miod Exp $ */
/*
 * Copyright (c) 1999 Steve Murphree, Jr.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1995 Nivas Madhur
 * Copyright (c) 1994 Gordon W. Ross
 * Copyright (c) 1993 Adam Glass
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

/*
 * Statistics clock driver.
 */

#include <sys/param.h>
#include <sys/simplelock.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/systm.h>
#ifdef GPROF
#include <sys/gmon.h>
#endif

#include <machine/board.h>
#include <machine/psl.h>
#include <machine/autoconf.h>
#include <machine/cpu.h>

#include "pcctwo.h"
#if NPCCTWO > 0
#include <mvme88k/dev/pcctwofunc.h>
#include <mvme88k/dev/pcctworeg.h>
#endif

#include "syscon.h"
#if NSYSCON > 0
#include <mvme88k/dev/sysconfunc.h>
#include <mvme88k/dev/sysconreg.h>
#endif

struct simplelock cio_lock;
/*
 * Statistics clock interval and variance, in usec.  Variance must be a
 * power of two.  Since this gives us an even number, not an odd number,
 * we discard one case and compensate.  That is, a variance of 4096 would
 * give us offsets in [0..4095].  Instead, we take offsets in [1..4095].
 * This is symmetric about the point 2048, or statvar/2, and thus averages
 * to that value (assuming uniform random numbers).
 */
int statvar = 8192;
int statmin;			/* statclock interval - 1/2*variance */

int	sclockmatch(struct device *, void *, void *);
void	sclockattach(struct device *, struct device *, void *);

void	sbc_initstatclock(void);
void	m188_initstatclock(void);
void	m188_cio_init(unsigned);
u_char	read_cio(unsigned);
void	write_cio(unsigned, unsigned);

struct sclocksoftc {
	struct device			sc_dev;
	struct intrhand sc_statih;
};

struct cfattach sclock_ca = {
        sizeof(struct sclocksoftc), sclockmatch, sclockattach
};

struct cfdriver sclock_cd = {
        NULL, "sclock", DV_DULL, 0
};

int	sbc_statintr(void *);
int	m188_statintr(void *);

u_char	stat_reset;

/*
 * Every machine needs, but doesn't have to have, a statistics clock.
 * For this platform, this file manages it, no matter what form it takes.
 */
int
sclockmatch(parent, vcf, args)
	struct device *parent;
	void *vcf, *args;
{
	struct confargs *ca = args;
	struct cfdata *cf = vcf;

	if (strcmp(cf->cf_driver->cd_name, "sclock")) {
		return (0);
	}

	/*
	 * clock has to be at ipl 5
	 * We return the ipl here so that the parent can print
	 * a message if it is different from what ioconf.c says.
	 */
	ca->ca_ipl = IPL_CLOCK;
	/* set size to 0 - see pcctwo.c:match for details */
	ca->ca_len = 0;
	return (1);
}

void
sclockattach(parent, self, args)
	struct device *parent, *self;
	void *args;
{
	struct confargs *ca = args;
	struct sclocksoftc *sc = (struct sclocksoftc *)self;

	switch (ca->ca_bustype) {
#if NPCCTWO > 0
	case BUS_PCCTWO:
		sc->sc_statih.ih_fn = sbc_statintr;
		sc->sc_statih.ih_arg = 0;
		sc->sc_statih.ih_wantframe = 1;
		sc->sc_statih.ih_ipl = ca->ca_ipl;
		stat_reset = ca->ca_ipl | PCC2_IRQ_IEN | PCC2_IRQ_ICLR;
		pcctwointr_establish(PCC2V_TIMER2, &sc->sc_statih);
		md.statclock_init_func = sbc_initstatclock;
		break;
#endif /* NPCCTWO */
#if NSYSCON > 0
	case BUS_SYSCON:
		sc->sc_statih.ih_fn = m188_statintr;
		sc->sc_statih.ih_arg = 0;
		sc->sc_statih.ih_wantframe = 1;
		sc->sc_statih.ih_ipl = ca->ca_ipl;
		sysconintr_establish(SYSCV_TIMER2, &sc->sc_statih);
		md.statclock_init_func = m188_initstatclock;
		break;
#endif /* NSYSCON */
	}
	printf("\n");
}

#if NPCCTWO > 0
void
sbc_initstatclock(void)
{
	int statint, minint;

#ifdef CLOCK_DEBUG
	printf("SBC statclock init\n");
#endif
	if (stathz == 0)
		stathz = hz;
	if (1000000 % stathz) {
		printf("cannot get %d Hz statclock; using 100 Hz\n", stathz);
		stathz = 100;
	}
	profhz = stathz;		/* always */

	statint = 1000000 / stathz;
	minint = statint / 2 + 100;
	while (statvar > minint)
		statvar >>= 1;

	/* statclock */
	sys_pcc2->pcc2_t2ctl = 0;
	sys_pcc2->pcc2_t2cmp = pcc2_timer_us2lim(statint);
	sys_pcc2->pcc2_t2count = 0;
	sys_pcc2->pcc2_t2ctl = PCC2_TCTL_CEN | PCC2_TCTL_COC |
			       PCC2_TCTL_COVF;
	sys_pcc2->pcc2_t2irq = stat_reset;

	statmin = statint - (statvar >> 1);
}

int
sbc_statintr(eframe)
	void *eframe;
{
	u_long newint, r, var;

	sys_pcc2->pcc2_t2irq = stat_reset;

	/* increment intr counter */
	intrcnt[M88K_SCLK_IRQ]++;

	statclock((struct clockframe *)eframe);

	/*
	 * Compute new randomized interval.  The intervals are uniformly
	 * distributed on [statint - statvar / 2, statint + statvar / 2],
	 * and therefore have mean statint, giving a stathz frequency clock.
	 */
	var = statvar;
	do {
		r = random() & (var - 1);
	} while (r == 0);
	newint = statmin + r;

	sys_pcc2->pcc2_t2ctl = 0;
	sys_pcc2->pcc2_t2cmp = pcc2_timer_us2lim(newint);
	sys_pcc2->pcc2_t2count = 0;		/* should I? */
	sys_pcc2->pcc2_t2irq = stat_reset;
	sys_pcc2->pcc2_t2ctl = PCC2_TCTL_CEN | PCC2_TCTL_COC;
	return (1);
}
#endif /* NPCCTWO */

#if NSYSCON > 0
#define CIO_LOCK simple_lock(&cio_lock)
#define CIO_UNLOCK simple_unlock(&cio_lock)

int
m188_statintr(eframe)
	void *eframe;
{
	u_long newint, r, var;

	CIO_LOCK;

	/* increment intr counter */
	intrcnt[M88K_SCLK_IRQ]++;

	statclock((struct clockframe *)eframe);
	write_cio(CIO_CSR1, CIO_GCB|CIO_CIP);  /* Ack the interrupt */

	/*
	 * Compute new randomized interval.  The intervals are uniformly
	 * distributed on [statint - statvar / 2, statint + statvar / 2],
	 * and therefore have mean statint, giving a stathz frequency clock.
	 */
	var = statvar;
	do {
		r = random() & (var - 1);
	} while (r == 0);
	newint = statmin + r;
	/*
	printf("newint = %d, 0x%x\n", newint, newint);
	*/
	write_cio(CIO_CT1MSB, (newint & 0xFF00) >> 8);	/* Load time constant CTC #1 */
	write_cio(CIO_CT1LSB, newint & 0xFF);

	write_cio(CIO_CSR1, CIO_GCB|CIO_CIP);  /* Start CTC #1 running */
#if 0
	if (*ist & CIOI_BIT) {
		printf("CIOI not clearing!\n");
	}
#endif
	CIO_UNLOCK;
	return (1);
}

void
m188_initstatclock(void)
{
	int statint, minint;

#ifdef CLOCK_DEBUG
	printf("VME188 clock init\n");
#endif
	simple_lock_init(&cio_lock);
	if (stathz == 0)
		stathz = hz;
	if (1000000 % stathz) {
		printf("cannot get %d Hz statclock; using 100 Hz\n", stathz);
		stathz = 100;
	}
	profhz = stathz;		/* always */

	statint = 1000000 / stathz;
	minint = statint / 2 + 100;
	while (statvar > minint)
		statvar >>= 1;
	m188_cio_init(statint);
	statmin = statint - (statvar >> 1);
}

#define CIO_CNTRL 0xFFF8300C

/* Write CIO register */
void
write_cio(reg, val)
	unsigned reg,val;
{
	int s, i;
	int *volatile cio_ctrl = (int *volatile)CIO_CNTRL;

	s = splclock();
	CIO_LOCK;

	i = *cio_ctrl;				/* goto state 1 */
	*cio_ctrl = 0;				/* take CIO out of RESET */
	i = *cio_ctrl;				/* reset CIO state machine */

	*cio_ctrl = (reg & 0xFF);		/* Select register */
	*cio_ctrl = (val & 0xFF);		/* Write the value */

	CIO_UNLOCK;
	splx(s);
}

/* Read CIO register */
u_char
read_cio(reg)
	unsigned reg;
{
	int c;
	int s, i;
	int *volatile cio_ctrl = (int *volatile)CIO_CNTRL;

	s = splclock();
	CIO_LOCK;

	/* Select register */
	*cio_ctrl = (char)(reg&0xFF);
	/* Delay for a short time to allow 8536 to settle */
	for (i=0;i<100;i++);
	/* read the value */
	c = *cio_ctrl;
	CIO_UNLOCK;
	splx(s);
	return ((u_char)c&0xFF);
}

/*
 * Initialize the CTC (8536)
 * Only the counter/timers are used - the IO ports are un-comitted.
 * Channels 1 and 2 are linked to provide a /32 counter.
 */

void
m188_cio_init(p)
	unsigned p;
{
	long i;
	short period;

	CIO_LOCK;

	period = p & 0xFFFF;

	/* Initialize 8536 CTC */
	/* Start by forcing chip into known state */
	(void) read_cio(CIO_MICR);

	write_cio(CIO_MICR, CIO_MICR_RESET);	/* Reset the CTC */
	for (i=0;i < 1000L; i++)	 /* Loop to delay */
		;
	/* Clear reset and start init seq. */
	write_cio(CIO_MICR, 0x00);

	/* Wait for chip to come ready */
	while ((read_cio(CIO_MICR)) != (char) CIO_MICR_RJA)
		;
	/* init Z8036 */
	write_cio(CIO_MICR, CIO_MICR_MIE | CIO_MICR_NV | CIO_MICR_RJA | CIO_MICR_DLC);
	write_cio(CIO_CTMS1, CIO_CTMS_CSC);	/* Continuous count */
	write_cio(CIO_PDCB, 0xFF);		/* set port B to input */

	/* Load time constant CTC #1 */
	write_cio(CIO_CT1MSB, (period & 0xFF00) >> 8);
	write_cio(CIO_CT1LSB, period & 0xFF);

	/* enable counter 1 */
	write_cio(CIO_MCCR, CIO_MCCR_CT1E | CIO_MCCR_PBE);

	/* enable interrupts and start */
	/*write_cio(CIO_IVR, SYSCV_TIMER2);*/
	write_cio(CIO_CSR1, CIO_GCB|CIO_TCB|CIO_IE);	/* Start CTC #1 running */

	CIO_UNLOCK;
}
#endif /* NSYSCON */
@


1.16
log
@Sync VMEChip2 timer usage with mvme68k (i.e. make it slightly more sane).
Also, use it even when the 1x7 is not a system controller - this does not
matter.
@
text
@d1 1
a1 1
/*	$OpenBSD: sclock.c,v 1.15 2003/10/05 20:25:08 miod Exp $ */
@


1.15
log
@De-register
@
text
@d1 1
a1 1
/*	$OpenBSD: sclock.c,v 1.14 2003/06/02 23:27:51 millert Exp $ */
d84 1
d90 1
a95 1
#include <mvme88k/dev/vme.h>
a96 1
extern struct vme2reg *sys_vme2;
a133 1
int	sclockbus;
d157 1
a157 1
	ca->ca_ipl   = IPL_CLOCK;
d159 1
a159 1
	ca->ca_len  = 0;
d171 1
a171 3
	sclockbus = ca->ca_bustype;

	switch (sclockbus) {
a180 1
		printf(": VME1x7");
a190 1
		printf(": VME188");
@


1.14
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: sclock.c,v 1.13 2003/06/02 07:06:56 deraadt Exp $ */
d4 1
a4 1
 * 
d68 1
a68 1
 * Statistics clock driver. 
d85 1
a85 1
#if NPCCTWO > 0 
d90 1
a90 1
#if NSYSCON > 0 
d125 3
a127 3
}; 
 
struct cfdriver sclock_cd = { 
d129 1
a129 1
}; 
d138 1
a138 1
 * Every machine needs, but doesn't have to have, a statistics clock. 
d146 2
a147 2
	register struct confargs *ca = args;
	register struct cfdata *cf = vcf;
d175 1
a175 1
#if NPCCTWO > 0 
d187 1
a187 1
#if NSYSCON > 0 
d198 1
a198 1
	}         
d202 1
a202 1
#if NPCCTWO > 0 
d206 1
a206 1
	register int statint, minint;
d210 1
a210 1
#endif 
d239 1
a239 1
	register u_long newint, r, var;
d244 2
a245 2
	intrcnt[M88K_SCLK_IRQ]++; 
	
d268 1
a268 1
#if NSYSCON > 0 
d276 1
a276 1
	register u_long newint, r, var;
d279 1
a279 1
	
d281 1
a281 1
	intrcnt[M88K_SCLK_IRQ]++; 
d301 1
a301 1
	
d307 1
a307 1
#endif 
d315 1
a315 1
	register int statint, minint;
d333 2
a334 2
	m188_cio_init(statint);  
	statmin = statint - (statvar >> 1);  
d346 1
a346 1
	
d349 1
a349 1
	
d356 1
a356 1
	
d372 1
a372 1
	
d424 1
a424 1
	write_cio(CIO_MCCR, CIO_MCCR_CT1E | CIO_MCCR_PBE);   
@


1.13
log
@licence cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: sclock.c,v 1.12 2002/03/14 01:26:39 millert Exp $ */
d49 1
a49 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.12
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: sclock.c,v 1.11 2002/03/05 22:11:37 miod Exp $ */
a12 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Theo de Raadt for Willowglen Singapore.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.11
log
@Kill prom stuff duplicates from bugio.[ch].
@
text
@d1 1
a1 1
/*	$OpenBSD: sclock.c,v 1.10 2002/01/14 21:34:39 miod Exp $ */
d119 2
a120 2
int	sclockmatch	__P((struct device *, void *, void *));
void	sclockattach	__P((struct device *, struct device *, void *));
d122 5
a126 5
void	sbc_initstatclock	__P((void));
void	m188_initstatclock	__P((void));
void	m188_cio_init		__P((unsigned));
u_char	read_cio		__P((unsigned));
void	write_cio		__P((unsigned, unsigned));
d141 2
a142 2
int	sbc_statintr	__P((void *));
int	m188_statintr	__P((void *));
@


1.10
log
@volatile police.
@
text
@d1 1
a1 1
/*	$OpenBSD: sclock.c,v 1.9 2001/12/20 06:07:28 smurph Exp $ */
a92 1
#include <machine/bugio.h>
@


1.9
log
@machine dependant pointer changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: sclock.c,v 1.8 2001/12/16 23:49:46 miod Exp $ */
d356 1
a356 1
	volatile int *cio_ctrl = (volatile int *)CIO_CNTRL;
d379 1
a379 1
	volatile int *cio_ctrl = (volatile int *)CIO_CNTRL;
@


1.8
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: sclock.c,v 1.6 2001/08/26 02:37:07 miod Exp $ */
d194 1
a194 1
		mdfp.statclock_init_func = &sbc_initstatclock;
d205 1
a205 1
		mdfp.statclock_init_func = &m188_initstatclock;
@


1.8.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: sclock.c,v 1.10 2002/01/14 21:34:39 miod Exp $ */
d194 1
a194 1
		md.statclock_init_func = sbc_initstatclock;
d205 1
a205 1
		md.statclock_init_func = m188_initstatclock;
d356 1
a356 1
	int *volatile cio_ctrl = (int *volatile)CIO_CNTRL;
d379 1
a379 1
	int *volatile cio_ctrl = (int *volatile)CIO_CNTRL;
@


1.8.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sclock.c,v 1.8.2.1 2002/01/31 22:55:17 niklas Exp $ */
d93 1
d120 2
a121 2
int	sclockmatch(struct device *, void *, void *);
void	sclockattach(struct device *, struct device *, void *);
d123 5
a127 5
void	sbc_initstatclock(void);
void	m188_initstatclock(void);
void	m188_cio_init(unsigned);
u_char	read_cio(unsigned);
void	write_cio(unsigned, unsigned);
d142 2
a143 2
int	sbc_statintr(void *);
int	m188_statintr(void *);
@


1.7
log
@Support for MVME197 completed.  Fix SPL defs.
@
text
@d194 1
a194 1
		md.statclock_init_func = &sbc_initstatclock;
d205 1
a205 1
		md.statclock_init_func = &m188_initstatclock;
@


1.6
log
@Add prototypes, fix compilation warnings, random style fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: sclock.c,v 1.5 2001/03/09 05:44:39 smurph Exp $ */
d194 1
a194 1
		mdfp.statclock_init_func = &sbc_initstatclock;
d205 1
a205 1
		mdfp.statclock_init_func = &m188_initstatclock;
@


1.5
log
@kernel will compile with -Werror.  Added intr.h
@
text
@d1 1
a1 1
/*	$OpenBSD: sclock.c,v 1.4 2001/03/07 23:45:51 miod Exp $ */
d120 2
a121 2
static int	sclockmatch	__P((struct device *, void *, void *));
static void	sclockattach	__P((struct device *, struct device *, void *));
d126 1
d373 1
a373 1
static u_char
@


1.4
log
@Fix interrupt handler registration and prototypes.
While there, some warning hunting.
@
text
@d1 1
a1 1
/*	$OpenBSD: sclock.c,v 1.3 2001/02/12 08:16:23 smurph Exp $ */
d153 2
a154 2
struct device *parent;
void *vcf, *args;
d176 2
a177 2
struct device *parent, *self;
void *args;
d352 1
a352 1
unsigned reg,val;
d374 1
a374 1
unsigned reg;
d401 2
a402 1
m188_cio_init(unsigned p)
@


1.3
log
@correct buginstat(), statclock now working for '188, systat vmstat now works,
serial driver for '188 working better.
@
text
@d1 1
a1 1
/*	$OpenBSD: sclock.c,v 1.2 2001/02/01 03:38:14 smurph Exp $ */
d85 1
d97 1
d102 1
d246 2
a247 2
sbc_statintr(cap)
void *cap;
d256 1
a256 1
	statclock((struct clockframe *)cap);
d283 2
a284 2
m188_statintr(cap)
void *cap;
a286 1
        volatile int *ist = (volatile int *)MVME188_IST;
d293 1
a293 1
	statclock((struct clockframe *)cap);
@


1.2
log
@Major changes to get MVME188 working.  More header and code cleanups.  The
kernel is tested on MVME188A/2P256 and MVME188A/1P64.
@
text
@d1 1
a1 1
/*	$OpenBSD: sclock.c,v 1.1 1999/09/27 18:43:25 smurph Exp $ */
d250 3
d287 4
d309 4
a312 3
	/* force a trigger event */
	write_cio(CIO_CSR1, CIO_GCB|CIO_TCB|CIO_IE);  /* Start CTC #1 running */
	if (*ist & DTI_BIT) {
d315 1
@


1.1
log
@adding support for MVME188 and MVME197.  Plus 32bit if_ie.
@
text
@d1 1
a1 1
/*	$OpenBSD: sclock.c,v 1.5 1999/05/29 04:41:43 smurph Exp $ */
d89 1
d117 2
a118 2
static int	sclockmatch __P((struct device *, void *, void *));
static void	sclockattach __P((struct device *, struct device *, void *));
d120 4
a123 4
void sbc_initstatclock __P((void));
void m188_initstatclock __P((void));
void m188_cio_init __P((unsigned));
void write_cio __P((unsigned, unsigned));
d138 2
a139 2
int	sbc_statintr __P((void *));
int   m188_statintr __P((void *));
d150 2
a151 2
	struct device *parent;
	void *vcf, *args;
d173 2
a174 2
	struct device *parent, *self;
	void *args;
d180 2
a181 2
   
   switch (sclockbus) {
d183 10
a192 10
   case BUS_PCCTWO:
	   sc->sc_statih.ih_fn = sbc_statintr;
      sc->sc_statih.ih_arg = 0;
      sc->sc_statih.ih_wantframe = 1;
      sc->sc_statih.ih_ipl = ca->ca_ipl;
      stat_reset = ca->ca_ipl | PCC2_IRQ_IEN | PCC2_IRQ_ICLR;
   	pcctwointr_establish(PCC2V_TIMER2, &sc->sc_statih);
      mdfp.statclock_init_func = &sbc_initstatclock;
      printf(": VME1x7");
      break;
d195 9
a203 9
   case BUS_SYSCON:
      sc->sc_statih.ih_fn = m188_statintr;
      sc->sc_statih.ih_arg = 0;
      sc->sc_statih.ih_wantframe = 1;
      sc->sc_statih.ih_ipl = ca->ca_ipl;
      sysconintr_establish(SYSCV_TIMER2, &sc->sc_statih);
      mdfp.statclock_init_func = &m188_initstatclock;
      printf(": VME188");
      break;
d205 2
a206 2
   }         
   printf("\n");
d215 2
a216 2
#ifdef DEBUG
   printf("SBC statclock init\n");
d236 1
a236 1
	    PCC2_TCTL_COVF;
d244 1
a244 1
	void *cap;
d278 1
a278 1
	void *cap;
d281 1
d283 1
a283 1
   CIO_LOCK;
d285 1
a285 1
   write_cio(CIO_CSR1, CIO_GCB|CIO_CIP);  /* Ack the interrupt */
d297 3
a299 1
/*   printf("newint = %d, 0x%x\n", newint, newint);*/
d302 6
a307 3
   /* force a trigger event */
   write_cio(CIO_CSR1, CIO_GCB|CIO_TCB|CIO_IE);  /* Start CTC #1 running */
   CIO_UNLOCK;
d316 2
a317 2
#ifdef DEBUG
   printf("VME188 clock init\n");
d332 2
a333 2
   m188_cio_init(statint);  
   statmin = statint - (statvar >> 1);  
d344 2
d347 10
a356 4
	/* Select register */
   *((volatile int *) CIO_CTRL) = (reg & 0xFF);
   /* Write the value */
   *((volatile int *) CIO_CTRL) = (val & 0xFF);
d366 5
a370 2
   int s, i;
   volatile int *port = (volatile int *)CIO_CNTRL;
a371 1
	s = splclock();
d373 1
a373 1
   *port = (char)(reg&0xFF);
d375 1
a375 1
	for(i=0;i<100;i++);
d377 2
a378 1
   c = *port;
d380 1
a380 1
	return((u_char)c&0xFF);
d393 3
a395 1
   short period;
d397 1
a397 1
   CIO_LOCK;
d399 1
a399 3
   period = p & 0xFFFF;
	
   /* Initialize 8536 CTC */
d404 1
a404 1
	for(i=0;i < 1000L; i++)		/* Loop to delay */
d407 1
a407 1
   write_cio(CIO_MICR, 0x00);
d410 1
a410 1
	while((read_cio(CIO_MICR)) != (char) CIO_MICR_RJA)
d412 1
a412 1
   /* init Z8036 */
d415 4
a418 3
   write_cio(CIO_PDCB, 0xFF);    /* set port B to input */
	
   write_cio(CIO_CT1MSB, (period & 0xFF00) >> 8);	/* Load time constant CTC #1 */
a419 3
	
   /* enable counter 1 */
   write_cio(CIO_MCCR, CIO_MCCR_CT1E | CIO_MCCR_PBE);	
d421 4
a424 1
   /* enable interrupts and start */
d426 3
a428 3
   write_cio(CIO_CSR1, CIO_GCB|CIO_TCB|CIO_IE);  /* Start CTC #1 running */
   
   CIO_UNLOCK;
a429 1

@


1.1.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: sclock.c,v 1.5 2001/03/09 05:44:39 smurph Exp $ */
a84 1
#include <sys/systm.h>
a88 1
#include <machine/board.h>
a94 1
#include <mvme88k/dev/pcctwofunc.h>
a98 1
#include <mvme88k/dev/sysconfunc.h>
d116 2
a117 2
static int	sclockmatch	__P((struct device *, void *, void *));
static void	sclockattach	__P((struct device *, struct device *, void *));
d119 4
a122 4
void	sbc_initstatclock	__P((void));
void	m188_initstatclock	__P((void));
void	m188_cio_init		__P((unsigned));
void	write_cio		__P((unsigned, unsigned));
d137 2
a138 2
int	sbc_statintr	__P((void *));
int	m188_statintr	__P((void *));
d179 2
a180 2

	switch (sclockbus) {
d182 10
a191 10
	case BUS_PCCTWO:
		sc->sc_statih.ih_fn = sbc_statintr;
		sc->sc_statih.ih_arg = 0;
		sc->sc_statih.ih_wantframe = 1;
		sc->sc_statih.ih_ipl = ca->ca_ipl;
		stat_reset = ca->ca_ipl | PCC2_IRQ_IEN | PCC2_IRQ_ICLR;
		pcctwointr_establish(PCC2V_TIMER2, &sc->sc_statih);
		mdfp.statclock_init_func = &sbc_initstatclock;
		printf(": VME1x7");
		break;
d194 9
a202 9
	case BUS_SYSCON:
		sc->sc_statih.ih_fn = m188_statintr;
		sc->sc_statih.ih_arg = 0;
		sc->sc_statih.ih_wantframe = 1;
		sc->sc_statih.ih_ipl = ca->ca_ipl;
		sysconintr_establish(SYSCV_TIMER2, &sc->sc_statih);
		mdfp.statclock_init_func = &m188_initstatclock;
		printf(": VME188");
		break;
d204 2
a205 2
	}         
	printf("\n");
d214 2
a215 2
#ifdef CLOCK_DEBUG
	printf("SBC statclock init\n");
d235 1
a235 1
			       PCC2_TCTL_COVF;
d242 2
a243 2
sbc_statintr(eframe)
	void *eframe;
d249 1
a249 4
	/* increment intr counter */
	intrcnt[M88K_SCLK_IRQ]++; 
	
	statclock((struct clockframe *)eframe);
d276 2
a277 2
m188_statintr(eframe)
	void *eframe;
d281 3
a283 7
	CIO_LOCK;
	
	/* increment intr counter */
	intrcnt[M88K_SCLK_IRQ]++; 

	statclock((struct clockframe *)eframe);
	write_cio(CIO_CSR1, CIO_GCB|CIO_CIP);  /* Ack the interrupt */
d295 1
a295 3
	/*
	printf("newint = %d, 0x%x\n", newint, newint);
	*/
d298 3
a300 8
	
	write_cio(CIO_CSR1, CIO_GCB|CIO_CIP);  /* Start CTC #1 running */
#if 0
	if (*ist & CIOI_BIT) {
		printf("CIOI not clearing!\n");
	}
#endif 
	CIO_UNLOCK;
d309 2
a310 2
#ifdef CLOCK_DEBUG
	printf("VME188 clock init\n");
d325 2
a326 2
	m188_cio_init(statint);  
	statmin = statint - (statvar >> 1);  
d334 1
a334 1
	unsigned reg,val;
a336 2
	volatile int *cio_ctrl = (volatile int *)CIO_CNTRL;
	
d338 4
a341 10
	CIO_LOCK;
	
	i = *cio_ctrl;				/* goto state 1 */
	*cio_ctrl = 0;				/* take CIO out of RESET */
	i = *cio_ctrl;				/* reset CIO state machine */

	*cio_ctrl = (reg & 0xFF);		/* Select register */
	*cio_ctrl = (val & 0xFF);		/* Write the value */
	
	CIO_UNLOCK;
d348 1
a348 1
	unsigned reg;
d351 3
a353 3
	int s, i;
	volatile int *cio_ctrl = (volatile int *)CIO_CNTRL;

a354 2
	CIO_LOCK;
	
d356 1
a356 1
	*cio_ctrl = (char)(reg&0xFF);
d358 1
a358 1
	for (i=0;i<100;i++);
d360 1
a360 2
	c = *cio_ctrl;
	CIO_UNLOCK;
d362 1
a362 1
	return ((u_char)c&0xFF);
d372 1
a372 2
m188_cio_init(p)
	unsigned p;
d375 1
a375 1
	short period;
d377 1
a377 1
	CIO_LOCK;
d379 3
a381 3
	period = p & 0xFFFF;

	/* Initialize 8536 CTC */
d386 1
a386 1
	for (i=0;i < 1000L; i++)	 /* Loop to delay */
d389 1
a389 1
	write_cio(CIO_MICR, 0x00);
d392 1
a392 1
	while ((read_cio(CIO_MICR)) != (char) CIO_MICR_RJA)
d394 1
a394 1
	/* init Z8036 */
d397 3
a399 4
	write_cio(CIO_PDCB, 0xFF);		/* set port B to input */

	/* Load time constant CTC #1 */
	write_cio(CIO_CT1MSB, (period & 0xFF00) >> 8);
d401 3
d405 1
a405 4
	/* enable counter 1 */
	write_cio(CIO_MCCR, CIO_MCCR_CT1E | CIO_MCCR_PBE);   

	/* enable interrupts and start */
d407 4
a410 1
	write_cio(CIO_CSR1, CIO_GCB|CIO_TCB|CIO_IE);	/* Start CTC #1 running */
a411 2
	CIO_UNLOCK;
}
@


1.1.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: sclock.c,v 1.1.4.1 2001/04/18 16:11:00 niklas Exp $ */
d120 2
a121 2
int	sclockmatch	__P((struct device *, void *, void *));
void	sclockattach	__P((struct device *, struct device *, void *));
a125 1
u_char	read_cio		__P((unsigned));
d372 1
a372 1
u_char
@


1.1.4.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d93 1
d194 1
a194 1
		md.statclock_init_func = sbc_initstatclock;
d205 1
a205 1
		md.statclock_init_func = m188_initstatclock;
d356 1
a356 1
	int *volatile cio_ctrl = (int *volatile)CIO_CNTRL;
d379 1
a379 1
	int *volatile cio_ctrl = (int *volatile)CIO_CNTRL;
@


1.1.4.4
log
@Merge in -current from about a week ago
@
text
@d119 2
a120 2
int	sclockmatch(struct device *, void *, void *);
void	sclockattach(struct device *, struct device *, void *);
d122 5
a126 5
void	sbc_initstatclock(void);
void	m188_initstatclock(void);
void	m188_cio_init(unsigned);
u_char	read_cio(unsigned);
void	write_cio(unsigned, unsigned);
d141 2
a142 2
int	sbc_statintr(void *);
int	m188_statintr(void *);
@


1.1.4.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sclock.c,v 1.1.4.4 2002/03/28 10:36:02 niklas Exp $ */
d13 6
d55 5
a59 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.1.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: sclock.c,v 1.1.4.5 2003/06/07 11:13:16 ho Exp $ */
@


