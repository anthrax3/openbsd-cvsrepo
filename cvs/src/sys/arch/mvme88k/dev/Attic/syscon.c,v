head	1.32;
access;
symbols
	OPENBSD_5_5:1.31.0.4
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.30.0.2
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.29.0.10
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.29.0.8
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.6
	OPENBSD_5_0:1.29.0.4
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.29.0.2
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.28.0.12
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.28.0.8
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.28.0.10
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.28.0.6
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.28.0.4
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.28.0.2
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.27.0.4
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.27.0.2
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.26.0.2
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.23.0.4
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.23.0.2
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.22.0.4
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.22.0.2
	OPENBSD_3_6_BASE:1.22
	SMP_SYNC_A:1.20
	SMP_SYNC_B:1.20
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.10.0.6
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.10
	UBC:1.8.0.2
	UBC_BASE:1.8
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SMP:1.1.0.4
	SMP_BASE:1.1
	kame_19991208:1.1
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.32
date	2014.03.18.22.36.36;	author miod;	state dead;
branches;
next	1.31;

1.31
date	2013.09.26.19.02.07;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2013.05.17.22.46.27;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2010.09.20.06.33.47;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	2007.12.27.23.17.53;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2006.11.18.12.04.57;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2006.04.19.19.41.24;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2006.04.17.18.27.30;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2006.04.15.15.45.21;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2005.07.18.02.43.25;	author fgsch;	state Exp;
branches;
next	1.22;

1.22
date	2004.08.02.08.35.00;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2004.07.30.19.02.06;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2004.05.07.18.10.28;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2004.04.24.19.51.48;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2004.04.16.23.36.48;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2004.04.14.23.27.11;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2004.04.14.22.33.28;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2004.01.14.20.52.52;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2004.01.14.20.50.48;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2003.10.11.22.08.57;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2003.09.28.22.14.33;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.07.06.56;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.01.26.39;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.05.23.15.33;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2001.12.19.07.04.41;	author smurph;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2001.12.16.23.49.46;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2001.12.13.08.55.51;	author smurph;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.09.05.44.39;	author smurph;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.07.23.45.52;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.01.03.38.15;	author smurph;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.26.23.32.00;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	99.09.27.18.43.25;	author smurph;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2001.04.18.16.11.05;	author niklas;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2002.03.06.02.04.44;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2002.03.28.10.36.02;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2003.06.07.11.13.17;	author ho;	state Exp;
branches;
next	1.1.4.5;

1.1.4.5
date	2004.02.19.10.49.06;	author niklas;	state Exp;
branches;
next	1.1.4.6;

1.1.4.6
date	2004.06.05.23.09.49;	author niklas;	state Exp;
branches;
next	;

1.8.2.1
date	2002.06.11.03.37.10;	author art;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: syscon.c,v 1.31 2013/09/26 19:02:07 miod Exp $ */
/*
 * Copyright (c) 1999 Steve Murphree, Jr.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * VME188 SYSCON
 */

#include <sys/param.h>
#include <sys/conf.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>

#include <machine/autoconf.h>
#include <machine/board.h>
#include <machine/cpu.h>

#include <machine/mvme188.h>

struct sysconsoftc {
	struct device	sc_dev;

	struct intrhand sc_abih;	/* `abort' switch */
	struct intrhand sc_acih;	/* `ac fail' */
	struct intrhand sc_sfih;	/* `sys fail' */
};

void	sysconattach(struct device *, struct device *, void *);
int	sysconmatch(struct device *, void *, void *);

int	syscon_print(void *, const char *);
int	syscon_scan(struct device *, void *, void *);
int	sysconabort(void *);
int	sysconacfail(void *);
int	sysconsysfail(void *);

struct cfattach syscon_ca = {
	sizeof(struct sysconsoftc), sysconmatch, sysconattach
};

struct cfdriver syscon_cd = {
	NULL, "syscon", DV_DULL
};

int
sysconmatch(struct device *parent, void *cf, void *args)
{
	/* Don't match if wrong cpu */
	if (brdtyp != BRD_188)
		return (0);

	return (syscon_cd.cd_ndevs == 0);
}

void
sysconattach(struct device *parent, struct device *self, void *args)
{
	struct sysconsoftc *sc = (struct sysconsoftc *)self;

	printf("\n");

	/*
	 * Clear SYSFAIL if lit.
	 */
	*(volatile u_int32_t *)MVME188_UCSR |= UCSR_DRVSFBIT;
	*(volatile u_int32_t *)MVME188_CLRINT = ISTATE_SYSFAIL;

	sc->sc_abih.ih_fn = sysconabort;
	sc->sc_abih.ih_arg = 0;
	sc->sc_abih.ih_wantframe = 1;
	sc->sc_abih.ih_ipl = IPL_ABORT;

	sc->sc_acih.ih_fn = sysconacfail;
	sc->sc_acih.ih_arg = 0;
	sc->sc_acih.ih_wantframe = 1;
	sc->sc_acih.ih_ipl = IPL_ABORT;

	sc->sc_sfih.ih_fn = sysconsysfail;
	sc->sc_sfih.ih_arg = 0;
	sc->sc_sfih.ih_wantframe = 1;
	sc->sc_sfih.ih_ipl = IPL_ABORT;

	platform->intsrc_establish(INTSRC_ABORT, &sc->sc_abih, "abort");
	platform->intsrc_establish(INTSRC_ACFAIL, &sc->sc_acih, "acfail");
	platform->intsrc_establish(INTSRC_SYSFAIL, &sc->sc_sfih, "sysfail");

	config_search(syscon_scan, self, args);
}

int
syscon_scan(struct device *parent, void *child, void *args)
{
	struct cfdata *cf = child;
	struct confargs oca, *ca = args;

	bzero(&oca, sizeof oca);
	oca.ca_iot = ca->ca_iot;
	oca.ca_dmat = ca->ca_dmat;
	oca.ca_offset = cf->cf_loc[0];
	oca.ca_ipl = cf->cf_loc[1];
	if (oca.ca_offset != -1)
		oca.ca_paddr = ca->ca_paddr + oca.ca_offset;
	else
		oca.ca_paddr = -1;
	oca.ca_bustype = BUS_SYSCON;
	oca.ca_name = cf->cf_driver->cd_name;

	if ((*cf->cf_attach->ca_match)(parent, cf, &oca) == 0)
		return (0);

	config_attach(parent, cf, &oca, syscon_print);
	return (1);
}

int
syscon_print(void *args, const char *bus)
{
	struct confargs *ca = args;

	if (ca->ca_offset != -1)
		printf(" offset 0x%x", ca->ca_offset);
	if (ca->ca_ipl > 0)
		printf(" ipl %d", ca->ca_ipl);
	return (UNCONF);
}

int
sysconabort(void *eframe)
{
	*(volatile u_int32_t *)MVME188_CLRINT = ISTATE_ABORT;
	nmihand(eframe);
	return (1);
}

int
sysconsysfail(void *eframe)
{
	*(volatile u_int32_t *)MVME188_CLRINT = ISTATE_SYSFAIL;
	printf("WARNING: SYSFAIL* ASSERTED\n");
	return (1);
}

int
sysconacfail(void *eframe)
{
	*(volatile u_int32_t *)MVME188_CLRINT = ISTATE_ACFAIL;
	printf("WARNING: ACFAIL* ASSERTED\n");
	return (1);
}
@


1.31
log
@Clear SYSFAIL upon boot, for real.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscon.c,v 1.30 2013/05/17 22:46:27 miod Exp $ */
@


1.30
log
@Replace the bunch of md_* function pointers with a `struct board' containing
function pointers for all the board-specific code.

Add a bunch of `struct board' methods to cover most, if not all, of the
`per-board' logic. This allows most of the md drivers to be cleaned up and
no longer need to embed board-specific knowledge.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscon.c,v 1.29 2010/09/20 06:33:47 matthew Exp $ */
d89 1
@


1.29
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syscon.c,v 1.28 2007/12/27 23:17:53 miod Exp $ */
d38 1
a41 1
#include <mvme88k/dev/sysconvar.h>
a81 1
	int i;
a85 6
	 * Set up interrupt handlers.
	 */
	for (i = 0; i < INTSRC_VME; i++)
		SLIST_INIT(&sysconintr_handlers[i]);

	/*
d105 3
a107 3
	sysconintr_establish(INTSRC_ABORT, &sc->sc_abih, "abort");
	sysconintr_establish(INTSRC_ACFAIL, &sc->sc_acih, "acfail");
	sysconintr_establish(INTSRC_SYSFAIL, &sc->sc_sfih, "sysfail");
a146 94
}

/*
 * Interrupt related code
 */

intrhand_t sysconintr_handlers[INTSRC_VME];

int
sysconintr_establish(u_int intsrc, struct intrhand *ih, const char *name)
{
	intrhand_t *list;

	list = &sysconintr_handlers[intsrc];
	if (!SLIST_EMPTY(list)) {
#ifdef DIAGNOSTIC
		printf("%s: interrupt source %u already registered\n",
		    __func__, intsrc);
#endif
		return (EINVAL);
	}

	evcount_attach(&ih->ih_count, name, &ih->ih_ipl);
	SLIST_INSERT_HEAD(list, ih, ih_link);

	syscon_intsrc_enable(intsrc, ih->ih_ipl);

	return (0);
}

void
sysconintr_disestablish(u_int intsrc, struct intrhand *ih)
{
	intrhand_t *list;

	list = &sysconintr_handlers[intsrc];
	evcount_detach(&ih->ih_count);
	SLIST_REMOVE(list, ih, intrhand, ih_link);

	syscon_intsrc_disable(intsrc);
}

/* Interrupt masks per logical interrupt source */
const u_int32_t syscon_intsrc[] = {
	0,
	IRQ_ABORT,
	IRQ_ACF,
	IRQ_SF,
	IRQ_CIOI,
	IRQ_DTI,
	IRQ_DI,
	IRQ_VME1,
	IRQ_VME2,
	IRQ_VME3,
	IRQ_VME4,
	IRQ_VME5,
	IRQ_VME6,
	IRQ_VME7
};

void
syscon_intsrc_enable(u_int intsrc, int ipl)
{
	u_int32_t psr;
	u_int32_t intmask = syscon_intsrc[intsrc];
	int i;

	psr = get_psr();
	set_psr(psr | PSR_IND);

	for (i = IPL_NONE; i < ipl; i++)
		int_mask_val[i] |= intmask;

	setipl(getipl());

	set_psr(psr);
}

void
syscon_intsrc_disable(u_int intsrc)
{
	u_int32_t psr;
	u_int32_t intmask = syscon_intsrc[intsrc];
	int i;

	psr = get_psr();
	set_psr(psr | PSR_IND);

	for (i = 0; i < NIPLS; i++)
		int_mask_val[i] &= ~intmask;

	setipl(getipl());

	set_psr(psr);
@


1.28
log
@Make the mvme188 interrupt handling closer to the aviion interrupt handling:
non-VME syscon interrupt sources will now use their own intrhand array,
and interrupt sources will be enabled in the arbiter as interrupt handlers
are registered. This allows VME devices to use the whole 256 interrupts range.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscon.c,v 1.27 2006/11/18 12:04:57 miod Exp $ */
d176 1
a176 2
	evcount_attach(&ih->ih_count, name, (void *)&ih->ih_ipl,
	    &evcount_intr);
@


1.27
log
@Do not include <machine/frame.h> (forgotten when the former was removed).
@
text
@d1 1
a1 1
/*	$OpenBSD: syscon.c,v 1.26 2006/04/19 19:41:24 miod Exp $ */
d41 1
a41 1
#include <mvme88k/dev/sysconreg.h>
a48 3
#if 0
	struct intrhand sc_m188ih;	/* `m188 interrupt' */
#endif
a58 1
int	sysconm188(void *);
d69 1
a69 3
sysconmatch(parent, vcf, args)
	struct device *parent;
	void *vcf, *args;
d75 1
a75 1
	return (1);
d78 2
a79 4
int
syscon_print(args, bus)
	void *args;
	const char *bus;
d81 34
a114 1
	struct confargs *ca = args;
d116 1
a116 5
	if (ca->ca_offset != -1)
		printf(" offset 0x%x", ca->ca_offset);
	if (ca->ca_ipl > 0)
		printf(" ipl %d", ca->ca_ipl);
	return (UNCONF);
d120 1
a120 3
syscon_scan(parent, child, args)
	struct device *parent;
	void *child, *args;
d130 1
a130 1
	if (oca.ca_offset != -1) {
d132 1
a132 1
	} else {
a133 1
	}
d136 1
d139 1
d144 41
d186 1
a186 3
sysconattach(parent, self, args)
	struct device *parent, *self;
	void *args;
d188 1
a188 1
	struct sysconsoftc *sc = (struct sysconsoftc *)self;
d190 3
a192 1
	printf("\n");
d194 2
a195 4
	/*
	 * Clear SYSFAIL if lit.
	 */
	*(volatile u_int32_t *)MVME188_UCSR |= UCSR_DRVSFBIT;
d197 17
a213 7
	/*
	 * pseudo driver, abort interrupt handler
	 */
	sc->sc_abih.ih_fn = sysconabort;
	sc->sc_abih.ih_arg = 0;
	sc->sc_abih.ih_wantframe = 1;
	sc->sc_abih.ih_ipl = IPL_ABORT;
d215 6
a220 4
	sc->sc_acih.ih_fn = sysconacfail;
	sc->sc_acih.ih_arg = 0;
	sc->sc_acih.ih_wantframe = 1;
	sc->sc_acih.ih_ipl = IPL_ABORT;
d222 2
a223 4
	sc->sc_sfih.ih_fn = sysconsysfail;
	sc->sc_sfih.ih_arg = 0;
	sc->sc_sfih.ih_wantframe = 1;
	sc->sc_sfih.ih_ipl = IPL_ABORT;
d225 2
a226 6
#if 0
	sc->sc_m188ih.ih_fn = sysconm188;
	sc->sc_m188ih.ih_arg = 0;
	sc->sc_m188ih.ih_wantframe = 1;
	sc->sc_m188ih.ih_ipl = IPL_ABORT;
#endif
d228 1
a228 6
	sysconintr_establish(SYSCV_ABRT, &sc->sc_abih, "abort");
	sysconintr_establish(SYSCV_ACF, &sc->sc_acih, "acfail");
	sysconintr_establish(SYSCV_SYSF, &sc->sc_sfih, "sysfail");
#if 0
	intr_establish(M188_IVEC, &sc->sc_m188ih, self->dv_xname);
#endif
d230 1
a230 1
	config_search(syscon_scan, self, args);
d233 2
a234 2
int
sysconintr_establish(int vec, struct intrhand *ih, const char *name)
d236 11
a246 4
#ifdef DIAGNOSTIC
	if (vec < 0 || vec >= SYSCON_NVEC)
		panic("sysconintr_establish: illegal vector 0x%x", vec);
#endif
d248 1
a248 1
	return intr_establish(SYSCON_VECT + vec, ih, name);
d252 1
a252 2
sysconabort(eframe)
	void *eframe;
d260 1
a260 2
sysconsysfail(eframe)
	void *eframe;
d268 1
a268 2
sysconacfail(eframe)
	void *eframe;
a273 11

#if 0
int
sysconm188(eframe)
	void *eframe;
{
	/* shouldn't happen! */
	printf("MVME188: self-inflicted interrupt\n");
	return (1);
}
#endif
@


1.26
log
@Better diagnostic messages in the MVME188 interrupt handler; also no need
to register an interrupt handler for the SYSCON board interrupts anymore,
as we never trigger it.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscon.c,v 1.25 2006/04/17 18:27:30 miod Exp $ */
a38 1
#include <machine/frame.h>
@


1.25
log
@On MVME188, clear SYSFAIL and set up a decent VME data transfer timeout,
instead of relying on what the BUG leaves us with.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscon.c,v 1.24 2006/04/15 15:45:21 miod Exp $ */
d50 1
d52 1
d157 1
d162 1
d167 1
d169 1
d212 1
d221 1
@


1.24
log
@Clean up <machine/mvme188.h> out of duplicate defines, sort them by relevance,
add more comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscon.c,v 1.23 2005/07/18 02:43:25 fgsch Exp $ */
d131 5
@


1.23
log
@remove trailing newline in panic(9); ok millert@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syscon.c,v 1.22 2004/08/02 08:35:00 miod Exp $ */
d178 2
a179 2
	ISR_RESET_NMI;
	nmihand((struct frame *)eframe);
d187 2
a188 2
	ISR_RESET_SYSFAIL;
	nmihand((struct frame *)eframe);
d196 2
a197 2
	ISR_RESET_ACFAIL;
	nmihand((struct frame *)eframe);
d205 2
a206 1
	printf("MVME188 interrupting?\n");
@


1.22
log
@More include files cleaning:
- move MAX_CPUS constant to <machine/cpu.h>
- do not include <machine/board.h> unless needed. In fact, remove this file
  entirely on mvme88k, and include <machine/mvme*.h> on a
  compiling-for-this-board basis
- keep MAX_CMMUS constant private to the m8820x code
@
text
@d1 1
a1 1
/*	$OpenBSD: syscon.c,v 1.21 2004/07/30 19:02:06 miod Exp $ */
d168 1
a168 1
		panic("sysconintr_establish: illegal vector 0x%x\n", vec);
@


1.21
log
@Move evcount structures inside struct intrhand, this makes more sense and
gives us more counters in the process.

Also clean up intrhand structures and usage, especially move them to SLISTs.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscon.c,v 1.20 2004/05/07 18:10:28 miod Exp $ */
a38 1
#include <machine/board.h>
d41 1
@


1.20
log
@bus_dma(9) implementation for mvme88k, mostly based upon powerpc.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscon.c,v 1.19 2004/04/24 19:51:48 miod Exp $ */
d155 4
a158 4
	sysconintr_establish(SYSCV_ABRT, &sc->sc_abih);
	sysconintr_establish(SYSCV_ACF, &sc->sc_acih);
	sysconintr_establish(SYSCV_SYSF, &sc->sc_sfih);
	intr_establish(M188_IVEC, &sc->sc_m188ih);
d164 1
a164 3
sysconintr_establish(vec, ih)
	int vec;
	struct intrhand *ih;
d171 1
a171 1
	return (intr_establish(SYSCON_VECT + vec, ih));
@


1.19
log
@Preliminary switch to an mvme88k bus_space world. Not all drivers have been
converted yet, and they rely upon some linear mappings provided by bus_space.

In order to not impact performance, almost all the bus_space accesses go
through macros and inline functions. This currently restricts us to D16 and
D32 access modes, which are selected at compilation time. Since there are no
plans to support D8 vme devices in the future, this is acceptable for now.

This makes the "len" locator for vme devices go away, and allows to simplify
some code which was using the pcctwo device, and will now directly access
hardware which is known to exist, rather than wait until the device is
attached.

While there, try to enforce more interrupt vector number checks, since these
changes pointed out that dart(4) had been working correctly so far by sheer
luck only.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscon.c,v 1.18 2004/04/16 23:36:48 miod Exp $ */
d107 1
@


1.18
log
@Bounds check PCC2 and SYSCON interrupt vectors.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscon.c,v 1.17 2004/04/14 23:27:11 miod Exp $ */
a41 1
#include <mvme88k/dev/sysconfunc.h>
a43 19
struct sysconreg syscon_reg = {
   (unsigned int *volatile)IEN0_REG,	(unsigned int *volatile)IEN1_REG,
   (unsigned int *volatile)IEN2_REG,	(unsigned int *volatile)IEN3_REG,
   (unsigned int *volatile)IENALL_REG,	(unsigned int *volatile)IST_REG,
   (unsigned int *volatile)SETSWI_REG,	(unsigned int *volatile)CLRSWI_REG,
   (unsigned int *volatile)ISTATE_REG,	(unsigned int *volatile)CLRINT_REG,
   (unsigned char *volatile)GLB0,	(unsigned char *volatile)GLB1,
   (unsigned char *volatile)GLB2,	(unsigned char *volatile)GLB3,
   (unsigned int *volatile)UCSR_REG,	(unsigned int *volatile)GLBRES_REG,
   (unsigned int *volatile)CCSR_REG,	(unsigned int *volatile)ERROR_REG,
   (unsigned int *volatile)PCNFA_REG,	(unsigned int *volatile)PCNFB_REG,
   (unsigned int *volatile)EXTAD_REG,	(unsigned int *volatile)EXTAM_REG,
   (unsigned int *volatile)WHOAMI_REG,	(unsigned int *volatile)WMAD_REG,
   (unsigned int *volatile)RMAD_REG,	(unsigned int *volatile)WVAD_REG,
   (unsigned int *volatile)RVAD_REG,	(unsigned int *volatile)CIO_PORTC,
   (unsigned int *volatile)CIO_PORTB,	(unsigned int *volatile)CIO_PORTA,
   (unsigned int *volatile)CIO_CTRL
   };

d46 1
a46 3
	void		*sc_vaddr;	/* Utility I/O space */
	void		*sc_paddr;
	struct sysconreg *sc_syscon;	/* the actual registers */
d53 9
a61 7
void sysconattach(struct device *, struct device *, void *);
int  sysconmatch(struct device *, void *, void *);
void setupiackvectors(void);
int  sysconabort(void *);
int  sysconacfail(void *);
int  sysconsysfail(void *);
int  sysconm188(void *);
a70 5
struct sysconreg *sys_syscon;

int syscon_print(void *args, const char *bus);
int syscon_scan(struct device *parent, void *child, void *args);

a75 3
	struct confargs *ca = args;
	struct sysconreg *syscon;

a79 9
	/* Only allow one instance */
	if (sys_syscon != NULL)
		return (0);

	/*
	 * Uh, MVME188 better have on of these, so always match if it
	 * is a MVME188...
	 */
	syscon = (struct sysconreg *)(IIOV(ca->ca_paddr));
d103 1
a103 2
	struct sysconsoftc *sc = (struct sysconsoftc *)parent;
	struct confargs oca;
d106 1
d109 2
a110 3
	if ((oca.ca_offset != -1) && ISIIOVA(sc->sc_vaddr + oca.ca_offset)) {
		oca.ca_vaddr = sc->sc_vaddr + oca.ca_offset;
		oca.ca_paddr = sc->sc_paddr + oca.ca_offset;
d112 1
a112 2
		oca.ca_vaddr = (void *)-1;
		oca.ca_paddr = (void *)-1;
a114 1
	oca.ca_master = (void *)sc->sc_syscon;
a126 1
	struct confargs *ca = args;
a128 9
	/*
	 * since we know ourself to land in intiobase land,
	 * we must adjust our address
	 */
	sc->sc_paddr = ca->ca_paddr;
	sc->sc_vaddr = (void *)IIOV(sc->sc_paddr);
	sc->sc_syscon = &syscon_reg;
	sys_syscon = sc->sc_syscon;

d168 1
a168 1
	if (vec < SYSCON_VECT || vec >= SYSCON_VECT + SYSCON_NVEC)
d172 1
a172 1
	return (intr_establish(vec, ih));
@


1.17
log
@Way too much include files here...
@
text
@d1 1
a1 1
/*	$OpenBSD: syscon.c,v 1.16 2004/04/14 22:33:28 miod Exp $ */
d204 3
a206 3
	intr_establish(SYSCV_ABRT, &sc->sc_abih);
	intr_establish(SYSCV_ACF, &sc->sc_acih);
	intr_establish(SYSCV_SYSF, &sc->sc_sfih);
d217 5
@


1.16
log
@Correctly register syscon interrupt handlers.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscon.c,v 1.15 2004/01/14 20:52:52 miod Exp $ */
a32 5
#include <sys/ioctl.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/tty.h>
#include <sys/uio.h>
a34 2
#include <sys/syslog.h>
#include <sys/fcntl.h>
a41 2
#include <dev/cons.h>

d146 1
a146 1
	if (((int)oca.ca_offset != -1) && ISIIOVA(sc->sc_vaddr + oca.ca_offset)) {
@


1.15
log
@mvme* do not support buses with indirect configuration, so don't check and
mourn for this.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscon.c,v 1.14 2004/01/14 20:50:48 miod Exp $ */
a171 1

d188 1
a188 1
	printf(": rev %d\n", 1);
d197 1
d200 1
a200 1
	sc->sc_abih.ih_wantframe = 1;
d202 1
d205 1
a205 1
	sc->sc_abih.ih_wantframe = 1;
d207 1
d210 1
a210 1
	sc->sc_abih.ih_wantframe = 1;
a262 1

@


1.14
log
@Do not fill more than the first three fields of cfdriver structures unless
necessary. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscon.c,v 1.13 2003/10/11 22:08:57 miod Exp $ */
a150 5

	if (parent->dv_cfdata->cf_driver->cd_indirect) {
		printf(" indirect devices not supported\n");
		return 0;
	}
@


1.13
log
@Nuke trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscon.c,v 1.12 2003/09/28 22:14:33 miod Exp $ */
d97 1
a97 1
	NULL, "syscon", DV_DULL, 0
@


1.12
log
@Clean various MVME188 related routines, fixing typos and removing unnecessary
diagnostic code in the process.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscon.c,v 1.11 2003/06/02 07:06:56 deraadt Exp $ */
d70 1
a70 1
   (unsigned int *volatile)CIO_CTRL 
d72 1
a72 1
  
d122 1
a122 1
	 * Uh, MVME188 better have on of these, so always match if it 
d196 1
a196 1
	/* 
@


1.11
log
@licence cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: syscon.c,v 1.10 2002/03/14 01:26:39 millert Exp $ */
d79 2
a80 2
	struct intrhand sc_acih;	/* `ac fial' */
	struct intrhand sc_sfih;	/* `sys fial' */
d100 1
a100 1
struct sysconreg *sys_syscon = NULL;
d114 11
a124 3
	if (brdtyp != BRD_188) return (0);  /* The only one... */
	/* Uh, MVME188 better have on of these, so always match if it 
	 * is a MVME188... */
a183 3

	if (sys_syscon)
		panic("syscon already attached!");
@


1.10
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: syscon.c,v 1.9 2002/02/05 23:15:33 miod Exp $ */
a13 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed under OpenBSD by
 *	Theo de Raadt for Willowglen Singapore.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.9
log
@I wonder how those two were not commited among the "volatile police" two
weeks ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscon.c,v 1.8 2001/12/19 07:04:41 smurph Exp $ */
d90 7
a96 7
void sysconattach __P((struct device *, struct device *, void *));
int  sysconmatch __P((struct device *, void *, void *));
void setupiackvectors __P((void));
int  sysconabort __P((void *));
int  sysconacfail __P((void *));
int  sysconsysfail __P((void *));
int  sysconm188 __P((void *));
d108 2
a109 2
int syscon_print __P((void *args, const char *bus));
int syscon_scan __P((struct device *parent, void *child, void *args));
@


1.8
log
@Introduce brdtyp and change what cputyp means.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscon.c,v 1.7 2001/12/16 23:49:46 miod Exp $ */
d61 16
a76 16
   (volatile unsigned int*)IEN0_REG,(volatile unsigned int*)IEN1_REG,
   (volatile unsigned int*)IEN2_REG,(volatile unsigned int*)IEN3_REG,
   (volatile unsigned int*)IENALL_REG,(volatile unsigned int*)IST_REG,
   (volatile unsigned int*)SETSWI_REG,(volatile unsigned int*)CLRSWI_REG,
   (volatile unsigned int*)ISTATE_REG,(volatile unsigned int*)CLRINT_REG,
   (volatile unsigned char*)GLB0,(volatile unsigned char*)GLB1,
   (volatile unsigned char*)GLB2,(volatile unsigned char*)GLB3,
   (volatile unsigned int*)UCSR_REG,(volatile unsigned int*)GLBRES_REG,
   (volatile unsigned int*)CCSR_REG,(volatile unsigned int*)ERROR_REG,
   (volatile unsigned int*)PCNFA_REG,(volatile unsigned int*)PCNFB_REG,
   (volatile unsigned int*)EXTAD_REG,(volatile unsigned int*)EXTAM_REG,
   (volatile unsigned int*)WHOAMI_REG,(volatile unsigned int*)WMAD_REG,
   (volatile unsigned int*)RMAD_REG,(volatile unsigned int*)WVAD_REG,
   (volatile unsigned int*)RVAD_REG,(volatile unsigned int*)CIO_PORTC,
   (volatile unsigned int*)CIO_PORTB,(volatile unsigned int*)CIO_PORTA,
   (volatile unsigned int*)CIO_CTRL 
@


1.8.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: syscon.c,v 1.8 2001/12/19 07:04:41 smurph Exp $ */
d61 16
a76 16
   (unsigned int *volatile)IEN0_REG,	(unsigned int *volatile)IEN1_REG,
   (unsigned int *volatile)IEN2_REG,	(unsigned int *volatile)IEN3_REG,
   (unsigned int *volatile)IENALL_REG,	(unsigned int *volatile)IST_REG,
   (unsigned int *volatile)SETSWI_REG,	(unsigned int *volatile)CLRSWI_REG,
   (unsigned int *volatile)ISTATE_REG,	(unsigned int *volatile)CLRINT_REG,
   (unsigned char *volatile)GLB0,	(unsigned char *volatile)GLB1,
   (unsigned char *volatile)GLB2,	(unsigned char *volatile)GLB3,
   (unsigned int *volatile)UCSR_REG,	(unsigned int *volatile)GLBRES_REG,
   (unsigned int *volatile)CCSR_REG,	(unsigned int *volatile)ERROR_REG,
   (unsigned int *volatile)PCNFA_REG,	(unsigned int *volatile)PCNFB_REG,
   (unsigned int *volatile)EXTAD_REG,	(unsigned int *volatile)EXTAM_REG,
   (unsigned int *volatile)WHOAMI_REG,	(unsigned int *volatile)WMAD_REG,
   (unsigned int *volatile)RMAD_REG,	(unsigned int *volatile)WVAD_REG,
   (unsigned int *volatile)RVAD_REG,	(unsigned int *volatile)CIO_PORTC,
   (unsigned int *volatile)CIO_PORTB,	(unsigned int *volatile)CIO_PORTA,
   (unsigned int *volatile)CIO_CTRL 
d90 7
a96 7
void sysconattach(struct device *, struct device *, void *);
int  sysconmatch(struct device *, void *, void *);
void setupiackvectors(void);
int  sysconabort(void *);
int  sysconacfail(void *);
int  sysconsysfail(void *);
int  sysconm188(void *);
d108 2
a109 2
int syscon_print(void *args, const char *bus);
int syscon_scan(struct device *parent, void *child, void *args);
@


1.7
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscon.c,v 1.5 2001/03/09 05:44:39 smurph Exp $ */
d120 1
a120 1
	if (cputyp != CPU_188) return (0);
@


1.6
log
@Support for MVME197 completed.  Fix SPL defs.
@
text
@d120 1
a120 1
	if (brdtyp != BRD_188) return (0);  /* The only one... */
@


1.5
log
@kernel will compile with -Werror.  Added intr.h
@
text
@d1 1
a1 1
/*	$OpenBSD: syscon.c,v 1.4 2001/03/07 23:45:52 miod Exp $ */
d120 1
a120 1
	if (cputyp != CPU_188) return (0);
@


1.4
log
@Fix interrupt handler registration and prototypes.
While there, some warning hunting.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscon.c,v 1.3 2001/02/01 03:38:15 smurph Exp $ */
d113 2
a114 2
struct device *parent;
void *vcf, *args;
d129 2
a130 2
void *args;
const char *bus;
d143 2
a144 2
struct device *parent;
void *child, *args;
d177 2
a178 2
struct device *parent, *self;
void *args;
d227 2
a228 2
int vec;
struct intrhand *ih;
@


1.3
log
@Major changes to get MVME188 working.  More header and code cleanups.  The
kernel is tested on MVME188A/2P256 and MVME188A/1P64.
@
text
@d1 1
a1 2

/*	$OpenBSD: syscon.c,v 1.2 2000/03/26 23:32:00 deraadt Exp $ */
d49 2
d52 1
a52 1
#include <machine/autoconf.h>
d54 1
a54 1
#include <machine/board.h>
d57 1
d93 4
a96 4
int  sysconabort __P((struct frame *frame));
int  sysconacfail __P((struct frame *frame));
int  sysconsysfail __P((struct frame *frame));
int  sysconm188 __P((struct frame *frame));
d108 3
a115 1
	struct cfdata *cf = vcf;
a147 1
	struct confargs *ca = args;
a181 1
	int i;
d202 1
a203 1
	sc->sc_abih.ih_wantframe = 1;
d206 1
a207 1
	sc->sc_acih.ih_wantframe = 1;
d210 1
a211 1
	sc->sc_sfih.ih_wantframe = 1;
d214 1
a215 1
	sc->sc_m188ih.ih_wantframe = 1;
d234 2
a235 2
sysconabort(frame)
struct frame *frame;
d238 1
a238 1
	nmihand(frame);
d243 2
a244 2
sysconsysfail(frame)
struct frame *frame;
d247 1
a247 1
	nmihand(frame);
d252 2
a253 2
sysconacfail(frame)
struct frame *frame;
d256 1
a256 1
	nmihand(frame);
d261 2
a262 2
sysconm188(frame)
struct frame *frame;
@


1.2
log
@callout.h is gone
@
text
@d2 1
a2 1
/*	$OpenBSD: syscon.c,v 1.1 1999/09/27 18:43:25 smurph Exp $ */
d82 4
a85 3
   struct intrhand sc_abih;       /* `abort' switch */
   struct intrhand sc_acih;       /* `ac fial' */
   struct intrhand sc_sfih;       /* `sys fial' */
d94 1
d108 2
a109 2
	struct device *parent;
	void *vcf, *args;
d117 3
a119 3
   /* Uh, MVME188 better have on of these, so always match if it 
    * is a MVME188... */	
   syscon = (struct sysconreg *)(IIOV(ca->ca_paddr));
d125 2
a126 2
	void *args;
	const char *bus;
d139 2
a140 2
	struct device *parent;
	void *child, *args;
d148 3
a150 3
      printf(" indirect devices not supported\n");
      return 0;
   }
d155 1
a155 1
	if ((oca.ca_offset != (void*)-1) && ISIIOVA(sc->sc_vaddr + oca.ca_offset)) {
d172 1
d174 2
a175 2
	struct device *parent, *self;
	void *args;
d195 24
a218 19
   /* 
    * pseudo driver, abort interrupt handler
    */
   sc->sc_abih.ih_fn = sysconabort;
   sc->sc_abih.ih_arg = 0;
   sc->sc_abih.ih_ipl = IPL_ABORT;
   sc->sc_abih.ih_wantframe = 1;
   sc->sc_acih.ih_fn = sysconacfail;
   sc->sc_acih.ih_arg = 0;
   sc->sc_acih.ih_ipl = IPL_ABORT;
   sc->sc_acih.ih_wantframe = 1;
   sc->sc_sfih.ih_fn = sysconsysfail;
   sc->sc_sfih.ih_arg = 0;
   sc->sc_sfih.ih_ipl = IPL_ABORT;
   sc->sc_sfih.ih_wantframe = 1;
   
   intr_establish(SYSCV_ABRT, &sc->sc_abih);
   intr_establish(SYSCV_ACF, &sc->sc_acih);
   intr_establish(SYSCV_SYSF, &sc->sc_sfih);
d225 2
a226 2
	int vec;
	struct intrhand *ih;
d233 1
a233 1
	struct frame *frame;
d235 2
a236 2
   ISR_RESET_NMI;
   nmihand(frame);
d242 1
a242 1
	struct frame *frame;
d244 2
a245 2
   ISR_RESET_SYSFAIL;
   nmihand(frame);
d251 10
a260 1
	struct frame *frame;
d262 1
a262 2
   ISR_RESET_ACFAIL;
   nmihand(frame);
@


1.1
log
@adding support for MVME188 and MVME197.  Plus 32bit if_ie.
@
text
@d2 1
a2 1
/*	$OpenBSD: syscon.c,v 1.0 1999/05/29 04:41:44 smurph Exp $ */
a44 1
#include <sys/callout.h>
@


1.1.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 2
a2 1
/*	$OpenBSD: syscon.c,v 1.5 2001/03/09 05:44:39 smurph Exp $ */
d45 1
d51 1
a51 1

d53 1
a53 1
#include <machine/cpu.h>
a54 2
#include <machine/frame.h>

a56 1
#include <mvme88k/dev/sysconfunc.h>
d83 3
a85 4
	struct intrhand sc_abih;	/* `abort' switch */
	struct intrhand sc_acih;	/* `ac fial' */
	struct intrhand sc_sfih;	/* `sys fial' */
	struct intrhand sc_m188ih;	/* `m188 interrupt' */
d91 3
a93 4
int  sysconabort __P((void *));
int  sysconacfail __P((void *));
int  sysconsysfail __P((void *));
int  sysconm188 __P((void *));
a104 3
int syscon_print __P((void *args, const char *bus));
int syscon_scan __P((struct device *parent, void *child, void *args));

d110 1
d116 3
a118 3
	/* Uh, MVME188 better have on of these, so always match if it 
	 * is a MVME188... */
	syscon = (struct sysconreg *)(IIOV(ca->ca_paddr));
d143 1
d147 3
a149 3
		printf(" indirect devices not supported\n");
		return 0;
	}
d154 1
a154 1
	if (((int)oca.ca_offset != -1) && ISIIOVA(sc->sc_vaddr + oca.ca_offset)) {
a170 1

d177 1
d193 19
a211 24
	/* 
	 * pseudo driver, abort interrupt handler
	 */
	sc->sc_abih.ih_fn = sysconabort;
	sc->sc_abih.ih_arg = 0;
	sc->sc_abih.ih_wantframe = 1;
	sc->sc_abih.ih_ipl = IPL_ABORT;
	sc->sc_acih.ih_fn = sysconacfail;
	sc->sc_acih.ih_arg = 0;
	sc->sc_abih.ih_wantframe = 1;
	sc->sc_acih.ih_ipl = IPL_ABORT;
	sc->sc_sfih.ih_fn = sysconsysfail;
	sc->sc_sfih.ih_arg = 0;
	sc->sc_abih.ih_wantframe = 1;
	sc->sc_sfih.ih_ipl = IPL_ABORT;
	sc->sc_m188ih.ih_fn = sysconm188;
	sc->sc_m188ih.ih_arg = 0;
	sc->sc_abih.ih_wantframe = 1;
	sc->sc_m188ih.ih_ipl = IPL_ABORT;

	intr_establish(SYSCV_ABRT, &sc->sc_abih);
	intr_establish(SYSCV_ACF, &sc->sc_acih);
	intr_establish(SYSCV_SYSF, &sc->sc_sfih);
	intr_establish(M188_IVEC, &sc->sc_m188ih);
d225 2
a226 11
sysconabort(eframe)
	void *eframe;
{
	ISR_RESET_NMI;
	nmihand((struct frame *)eframe);
	return (1);
}

int
sysconsysfail(eframe)
	void *eframe;
d228 2
a229 2
	ISR_RESET_SYSFAIL;
	nmihand((struct frame *)eframe);
d234 2
a235 2
sysconacfail(eframe)
	void *eframe;
d237 2
a238 2
	ISR_RESET_ACFAIL;
	nmihand((struct frame *)eframe);
d243 2
a244 2
sysconm188(eframe)
	void *eframe;
d246 2
a247 1
	printf("MVME188 interrupting?\n");
@


1.1.4.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d61 16
a76 16
   (unsigned int *volatile)IEN0_REG,	(unsigned int *volatile)IEN1_REG,
   (unsigned int *volatile)IEN2_REG,	(unsigned int *volatile)IEN3_REG,
   (unsigned int *volatile)IENALL_REG,	(unsigned int *volatile)IST_REG,
   (unsigned int *volatile)SETSWI_REG,	(unsigned int *volatile)CLRSWI_REG,
   (unsigned int *volatile)ISTATE_REG,	(unsigned int *volatile)CLRINT_REG,
   (unsigned char *volatile)GLB0,	(unsigned char *volatile)GLB1,
   (unsigned char *volatile)GLB2,	(unsigned char *volatile)GLB3,
   (unsigned int *volatile)UCSR_REG,	(unsigned int *volatile)GLBRES_REG,
   (unsigned int *volatile)CCSR_REG,	(unsigned int *volatile)ERROR_REG,
   (unsigned int *volatile)PCNFA_REG,	(unsigned int *volatile)PCNFB_REG,
   (unsigned int *volatile)EXTAD_REG,	(unsigned int *volatile)EXTAM_REG,
   (unsigned int *volatile)WHOAMI_REG,	(unsigned int *volatile)WMAD_REG,
   (unsigned int *volatile)RMAD_REG,	(unsigned int *volatile)WVAD_REG,
   (unsigned int *volatile)RVAD_REG,	(unsigned int *volatile)CIO_PORTC,
   (unsigned int *volatile)CIO_PORTB,	(unsigned int *volatile)CIO_PORTA,
   (unsigned int *volatile)CIO_CTRL 
d120 1
a120 1
	if (brdtyp != BRD_188) return (0);  /* The only one... */
@


1.1.4.3
log
@Merge in -current from about a week ago
@
text
@d90 7
a96 7
void sysconattach(struct device *, struct device *, void *);
int  sysconmatch(struct device *, void *, void *);
void setupiackvectors(void);
int  sysconabort(void *);
int  sysconacfail(void *);
int  sysconsysfail(void *);
int  sysconm188(void *);
d108 2
a109 2
int syscon_print(void *args, const char *bus);
int syscon_scan(struct device *parent, void *child, void *args);
@


1.1.4.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: syscon.c,v 1.1.4.3 2002/03/28 10:36:02 niklas Exp $ */
d14 6
@


1.1.4.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d70 1
a70 1
   (unsigned int *volatile)CIO_CTRL
d72 1
a72 1

d79 2
a80 2
	struct intrhand sc_acih;	/* `ac fail' */
	struct intrhand sc_sfih;	/* `sys fail' */
d97 1
a97 1
	NULL, "syscon", DV_DULL
d100 1
a100 1
struct sysconreg *sys_syscon;
d114 3
a116 11
	if (brdtyp != BRD_188)
		return (0);

	/* Only allow one instance */
	if (sys_syscon != NULL)
		return (0);

	/*
	 * Uh, MVME188 better have on of these, so always match if it
	 * is a MVME188...
	 */
d144 5
d177 3
d191 1
a191 1
	/*
@


1.1.4.6
log
@Merge with the trunk
@
text
@d33 5
d40 2
d49 3
d54 19
d75 3
a77 1

d84 7
a90 9
void	sysconattach(struct device *, struct device *, void *);
int	sysconmatch(struct device *, void *, void *);

int	syscon_print(void *, const char *);
int	syscon_scan(struct device *, void *, void *);
int	sysconabort(void *);
int	sysconacfail(void *);
int	sysconsysfail(void *);
int	sysconm188(void *);
d100 5
d110 3
d117 9
d149 2
a150 1
	struct confargs oca, *ca = args;
a152 2
	oca.ca_iot = ca->ca_iot;
	oca.ca_dmat = ca->ca_dmat;
d155 3
a157 2
	if (oca.ca_offset != -1) {
		oca.ca_paddr = ca->ca_paddr + oca.ca_offset;
d159 2
a160 1
		oca.ca_paddr = -1;
d163 1
d172 1
d177 1
d180 10
a189 1
	printf("\n");
a197 1

d200 1
a200 1
	sc->sc_acih.ih_wantframe = 1;
a201 1

d204 1
a204 1
	sc->sc_sfih.ih_wantframe = 1;
a205 1

d208 1
a208 1
	sc->sc_m188ih.ih_wantframe = 1;
d211 3
a213 3
	sysconintr_establish(SYSCV_ABRT, &sc->sc_abih);
	sysconintr_establish(SYSCV_ACF, &sc->sc_acih);
	sysconintr_establish(SYSCV_SYSF, &sc->sc_sfih);
d224 1
a224 6
#ifdef DIAGNOSTIC
	if (vec < 0 || vec >= SYSCON_NVEC)
		panic("sysconintr_establish: illegal vector 0x%x\n", vec);
#endif

	return (intr_establish(SYSCON_VECT + vec, ih));
d261 1
@


