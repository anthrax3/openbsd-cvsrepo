head	1.85;
access;
symbols
	OPENBSD_5_5:1.84.0.4
	OPENBSD_5_5_BASE:1.84
	OPENBSD_5_4:1.83.0.12
	OPENBSD_5_4_BASE:1.83
	OPENBSD_5_3:1.83.0.10
	OPENBSD_5_3_BASE:1.83
	OPENBSD_5_2:1.83.0.8
	OPENBSD_5_2_BASE:1.83
	OPENBSD_5_1_BASE:1.83
	OPENBSD_5_1:1.83.0.6
	OPENBSD_5_0:1.83.0.4
	OPENBSD_5_0_BASE:1.83
	OPENBSD_4_9:1.83.0.2
	OPENBSD_4_9_BASE:1.83
	OPENBSD_4_8:1.81.0.2
	OPENBSD_4_8_BASE:1.81
	OPENBSD_4_7:1.78.0.2
	OPENBSD_4_7_BASE:1.78
	OPENBSD_4_6:1.76.0.6
	OPENBSD_4_6_BASE:1.76
	OPENBSD_4_5:1.76.0.2
	OPENBSD_4_5_BASE:1.76
	OPENBSD_4_4:1.71.0.2
	OPENBSD_4_4_BASE:1.71
	OPENBSD_4_3:1.70.0.2
	OPENBSD_4_3_BASE:1.70
	OPENBSD_4_2:1.64.0.4
	OPENBSD_4_2_BASE:1.64
	OPENBSD_4_1:1.64.0.2
	OPENBSD_4_1_BASE:1.64
	OPENBSD_4_0:1.62.0.2
	OPENBSD_4_0_BASE:1.62
	OPENBSD_3_9:1.60.0.2
	OPENBSD_3_9_BASE:1.60
	OPENBSD_3_8:1.55.0.2
	OPENBSD_3_8_BASE:1.55
	OPENBSD_3_7:1.53.0.4
	OPENBSD_3_7_BASE:1.53
	OPENBSD_3_6:1.53.0.2
	OPENBSD_3_6_BASE:1.53
	SMP_SYNC_A:1.41
	SMP_SYNC_B:1.40
	OPENBSD_3_5:1.29.0.2
	OPENBSD_3_5_BASE:1.29
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	UBC_SYNC_A:1.18
	OPENBSD_3_3:1.18.0.2
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	UBC_SYNC_B:1.17
	UBC:1.13.0.2
	UBC_BASE:1.13
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.2.0.8
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.6
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.4
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.85
date	2014.03.18.22.36.36;	author miod;	state dead;
branches;
next	1.84;

1.84
date	2014.01.18.04.11.07;	author dlg;	state Exp;
branches;
next	1.83;

1.83
date	2010.12.23.20.25.18;	author miod;	state Exp;
branches;
next	1.82;

1.82
date	2010.11.18.21.13.19;	author miod;	state Exp;
branches;
next	1.81;

1.81
date	2010.06.28.18.31.01;	author krw;	state Exp;
branches;
next	1.80;

1.80
date	2010.05.20.00.55.17;	author krw;	state Exp;
branches;
next	1.79;

1.79
date	2010.03.23.01.57.19;	author krw;	state Exp;
branches;
next	1.78;

1.78
date	2010.01.09.23.15.06;	author krw;	state Exp;
branches;
next	1.77;

1.77
date	2009.11.22.14.14.10;	author krw;	state Exp;
branches;
next	1.76;

1.76
date	2009.02.16.21.19.06;	author miod;	state Exp;
branches;
next	1.75;

1.75
date	2009.02.08.13.28.01;	author miod;	state Exp;
branches;
next	1.74;

1.74
date	2009.02.01.20.42.24;	author miod;	state Exp;
branches;
next	1.73;

1.73
date	2009.02.01.00.44.36;	author miod;	state Exp;
branches;
next	1.72;

1.72
date	2009.01.29.22.16.34;	author miod;	state Exp;
branches;
next	1.71;

1.71
date	2008.07.30.18.08.03;	author miod;	state Exp;
branches;
next	1.70;

1.70
date	2008.01.05.00.34.07;	author miod;	state Exp;
branches;
next	1.69;

1.69
date	2008.01.03.22.32.42;	author miod;	state Exp;
branches;
next	1.68;

1.68
date	2008.01.01.22.54.28;	author miod;	state Exp;
branches;
next	1.67;

1.67
date	2008.01.01.17.21.29;	author miod;	state Exp;
branches;
next	1.66;

1.66
date	2007.10.06.02.18.38;	author krw;	state Exp;
branches;
next	1.65;

1.65
date	2007.10.03.10.52.11;	author krw;	state Exp;
branches;
next	1.64;

1.64
date	2006.12.01.19.36.09;	author miod;	state Exp;
branches;
next	1.63;

1.63
date	2006.11.28.23.59.45;	author dlg;	state Exp;
branches;
next	1.62;

1.62
date	2006.05.08.14.36.10;	author miod;	state Exp;
branches;
next	1.61;

1.61
date	2006.03.15.20.20.40;	author miod;	state Exp;
branches;
next	1.60;

1.60
date	2005.12.27.22.48.01;	author miod;	state Exp;
branches;
next	1.59;

1.59
date	2005.12.27.22.45.28;	author miod;	state Exp;
branches;
next	1.58;

1.58
date	2005.12.27.22.05.27;	author miod;	state Exp;
branches;
next	1.57;

1.57
date	2005.12.27.21.38.13;	author miod;	state Exp;
branches;
next	1.56;

1.56
date	2005.12.03.18.09.37;	author krw;	state Exp;
branches;
next	1.55;

1.55
date	2005.04.27.14.09.45;	author miod;	state Exp;
branches;
next	1.54;

1.54
date	2005.04.27.14.07.38;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2004.09.06.06.25.28;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2004.07.30.19.02.06;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2004.07.20.23.07.06;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2004.07.20.20.33.18;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2004.07.20.20.32.02;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2004.07.20.20.28.54;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2004.07.19.20.35.37;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2004.07.19.20.34.59;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2004.07.19.20.32.47;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2004.07.19.20.31.51;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2004.07.18.19.45.51;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2004.07.02.14.00.43;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2004.06.10.16.05.22;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2004.05.23.20.52.16;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2004.05.22.21.02.38;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2004.05.22.19.34.12;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2004.05.21.10.24.42;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2004.05.20.21.16.48;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2004.05.20.16.42.54;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2004.05.09.05.34.00;	author krw;	state Exp;
branches;
next	1.33;

1.33
date	2004.04.30.19.08.02;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2004.04.24.20.34.53;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2004.04.24.19.51.48;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2004.04.16.23.35.50;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2004.01.29.21.39.05;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2004.01.20.16.48.27;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2004.01.14.20.50.48;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2004.01.14.02.00.41;	author krw;	state Exp;
branches;
next	1.25;

1.25
date	2004.01.02.23.38.37;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2003.12.26.10.41.43;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2003.12.25.21.01.39;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2003.11.07.10.16.45;	author jmc;	state Exp;
branches;
next	1.21;

1.21
date	2003.11.03.06.54.26;	author david;	state Exp;
branches;
next	1.20;

1.20
date	2003.10.05.20.27.48;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.02.23.27.52;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.12.14.07.20.25;	author fgsch;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.14.21.34.59;	author todd;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.14.01.26.39;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.01.14.21.34.39;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2001.12.22.09.49.39;	author smurph;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.16.23.49.46;	author miod;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2001.12.13.08.55.51;	author smurph;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.06.00.30.38;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.31.01.52.19;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.26.02.37.07;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.25.00.43.14;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.14.21.30.35;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.16.12.49.47;	author ho;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.09.05.44.39;	author smurph;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.08.00.03.15;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.01.03.38.16;	author smurph;	state Exp;
branches;
next	1.2;

1.2
date	99.09.27.18.43.25;	author smurph;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	99.05.29.04.41.44;	author smurph;	state Exp;
branches;
next	;

1.2.4.1
date	2001.04.18.16.11.07;	author niklas;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2001.07.04.10.20.00;	author niklas;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2001.10.31.03.01.18;	author nate;	state Exp;
branches;
next	1.2.4.4;

1.2.4.4
date	2001.11.13.21.04.14;	author niklas;	state Exp;
branches;
next	1.2.4.5;

1.2.4.5
date	2002.03.06.02.04.44;	author niklas;	state Exp;
branches;
next	1.2.4.6;

1.2.4.6
date	2002.03.28.10.36.02;	author niklas;	state Exp;
branches;
next	1.2.4.7;

1.2.4.7
date	2003.03.27.23.32.18;	author niklas;	state Exp;
branches;
next	1.2.4.8;

1.2.4.8
date	2003.06.07.11.13.17;	author ho;	state Exp;
branches;
next	1.2.4.9;

1.2.4.9
date	2004.02.19.10.49.06;	author niklas;	state Exp;
branches;
next	1.2.4.10;

1.2.4.10
date	2004.06.05.23.09.49;	author niklas;	state Exp;
branches;
next	1.2.4.11;

1.2.4.11
date	2004.06.13.08.50.08;	author niklas;	state Exp;
branches;
next	;

1.13.2.1
date	2002.01.31.22.55.18;	author niklas;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2002.06.11.03.37.10;	author art;	state Exp;
branches;
next	1.13.2.3;

1.13.2.3
date	2002.10.29.00.28.07;	author art;	state Exp;
branches;
next	1.13.2.4;

1.13.2.4
date	2003.05.19.21.45.53;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.85
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: vs.c,v 1.84 2014/01/18 04:11:07 dlg Exp $	*/

/*
 * Copyright (c) 2004, 2009, Miodrag Vallat.
 * Copyright (c) 1999 Steve Murphree, Jr.
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Van Jacobson of Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * MVME328S SCSI adaptor driver
 */

/* This card lives in D16 space */
#define	__BUS_SPACE_RESTRICT_D16__

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/disklabel.h>
#include <sys/buf.h>
#include <sys/malloc.h>

#include <uvm/uvm_extern.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <machine/autoconf.h>
#include <machine/cmmu.h>
#include <machine/cpu.h>

#include <mvme88k/dev/vsreg.h>
#include <mvme88k/dev/vsvar.h>
#include <mvme88k/dev/vme.h>

int	vsmatch(struct device *, void *, void *);
void	vsattach(struct device *, struct device *, void *);
void	vs_minphys(struct buf *, struct scsi_link *);
void	vs_scsicmd(struct scsi_xfer *);

struct scsi_adapter vs_scsiswitch = {
	vs_scsicmd,
	vs_minphys,
	0,			/* no lun support */
	0,			/* no lun support */
};

struct cfattach vs_ca = {
	sizeof(struct vs_softc), vsmatch, vsattach,
};

struct cfdriver vs_cd = {
	NULL, "vs", DV_DULL,
};

int	do_vspoll(struct vs_softc *, struct scsi_xfer *, int);
void	thaw_queue(struct vs_softc *, int);
void	thaw_all_queues(struct vs_softc *);
int	vs_alloc_sg(struct vs_softc *);
int	vs_alloc_wq(struct vs_softc *);
void	vs_build_sg_list(struct vs_softc *, struct vs_cb *, bus_addr_t);
void	vs_chksense(struct vs_cb *, struct scsi_xfer *);
int	vs_eintr(void *);
int	vs_getcqe(struct vs_softc *, bus_addr_t *, bus_addr_t *);
int	vs_identify(struct vs_channel *, int);
int	vs_initialize(struct vs_softc *);
int	vs_intr(struct vs_softc *);
int	vs_load_command(struct vs_softc *, struct vs_cb *, bus_addr_t,
	    bus_addr_t, struct scsi_link *, int, struct scsi_generic *, int,
	    uint8_t *, int);
int	vs_nintr(void *);
void	vs_poll(struct vs_softc *, struct vs_cb *);
void	vs_print_addr(struct vs_softc *, struct scsi_xfer *);
struct vs_cb *vs_find_queue(struct scsi_link *, struct vs_softc *);
void	vs_reset(struct vs_softc *, int);
void	vs_resync(struct vs_softc *);
void	vs_scsidone(struct vs_softc *, struct vs_cb *);
int	vs_unit_value(int, int, int);

static __inline__ void vs_free(struct vs_softc *, struct vs_cb *);
static __inline__ void vs_clear_return_info(struct vs_softc *);

int
vsmatch(struct device *device, void *cf, void *args)
{
	struct confargs *ca = args;
	bus_space_tag_t iot = ca->ca_iot;
	bus_space_handle_t ioh;
	int rc;
	u_int16_t id;

	if (bus_space_map(iot, ca->ca_paddr, S_SHORTIO, 0, &ioh) != 0)
		return 0;
	rc = badaddr((vaddr_t)bus_space_vaddr(iot, ioh) + sh_CSS + CSB_TYPE, 2);
	if (rc == 0) {
		id = bus_space_read_2(iot, ioh, sh_CSS + CSB_TYPE);
		if (id != JAGUAR && id != COUGAR)
			rc = 1;
		/*
		 * Note that this will reject Cougar boards configured with
		 * less than 2KB of short I/O memory.
		 * Is it worth checking for a Cougar signature at lower
		 * addresses, knowing that we can't really work unless
		 * the board is jumped to enable the whole 2KB?
		 */
	}
	bus_space_unmap(iot, ioh, S_SHORTIO);

	return rc == 0;
}

void
vsattach(struct device *parent, struct device *self, void *args)
{
	struct vs_softc *sc = (struct vs_softc *)self;
	struct vs_channel *vc;
	struct confargs *ca = args;
	struct scsi_link *sc_link;
	struct scsibus_attach_args saa;
	int evec, bus;
	int tmp;

	/* get the next available vector for the error interrupt */
	evec = vme_findvec(ca->ca_vec);

	if (ca->ca_vec < 0 || evec < 0) {
		printf(": no more interrupts!\n");
		return;
	}
	if (ca->ca_ipl < 0)
		ca->ca_ipl = IPL_BIO;

	printf(" vec 0x%x: ", evec);

	sc->sc_dmat = ca->ca_dmat;
	sc->sc_iot = ca->ca_iot;
	if (bus_space_map(sc->sc_iot, ca->ca_paddr, S_SHORTIO, 0,
	    &sc->sc_ioh) != 0) {
		printf("can't map registers!\n");
		return;
	}

	sc->sc_bid = csb_read(2, CSB_TYPE);
	sc->sc_ipl = ca->ca_ipl;
	sc->sc_nvec = ca->ca_vec;
	sc->sc_evec = evec;

	if (vs_initialize(sc))
		return;

	sc->sc_ih_n.ih_fn = vs_nintr;
	sc->sc_ih_n.ih_arg = sc;
	sc->sc_ih_n.ih_wantframe = 0;
	sc->sc_ih_n.ih_ipl = ca->ca_ipl;

	sc->sc_ih_e.ih_fn = vs_eintr;
	sc->sc_ih_e.ih_arg = sc;
	sc->sc_ih_e.ih_wantframe = 0;
	sc->sc_ih_e.ih_ipl = ca->ca_ipl;

	vmeintr_establish(sc->sc_nvec, &sc->sc_ih_n, self->dv_xname);
	snprintf(sc->sc_intrname_e, sizeof sc->sc_intrname_e,
	    "%s_err", self->dv_xname);
	vmeintr_establish(sc->sc_evec, &sc->sc_ih_e, sc->sc_intrname_e);

	/*
	 * Attach all scsi units on us, watching for boot device
	 * (see device_register).
	 */
	tmp = bootpart;
	if (ca->ca_paddr != bootaddr)
		bootpart = -1;		/* invalid flag to device_register */

	for (bus = 0; bus < 2; bus++) {
		vc = &sc->sc_channel[bus];
		if (vc->vc_id < 0)
			continue;

		sc_link = &vc->vc_link;
		sc_link->adapter = &vs_scsiswitch;
		sc_link->adapter_buswidth = vc->vc_width;
		sc_link->adapter_softc = sc;
		sc_link->adapter_target = vc->vc_id;
		if (sc->sc_bid != JAGUAR)
			sc_link->luns = 1;	/* not enough queues */
		sc_link->openings = 1;
		if (bus != 0)
			sc_link->flags = SDEV_2NDBUS;

		printf("%s: channel %d", sc->sc_dev.dv_xname, bus);
		switch (vc->vc_type) {
		case VCT_SE:
			printf(", single-ended");
			break;
		case VCT_DIFFERENTIAL:
			printf(", differential");
			break;
		}
		printf("\n");

		if (vc->vc_width == 0) {
			printf("%s: daughterboard disabled, "
			    "not enough on-board memory\n",
			    sc->sc_dev.dv_xname);
			continue;
		}

		bzero(&saa, sizeof(saa));
		saa.saa_sc_link = &vc->vc_link;

		bootbus = bus;
		config_found(self, &saa, scsiprint);
	}

	bootpart = tmp;		    /* restore old values */
	bootbus = 0;
}

void
vs_minphys(struct buf *bp, struct scsi_link *sl)
{
	if (bp->b_bcount > ptoa(MAX_SG_ELEMENTS))
		bp->b_bcount = ptoa(MAX_SG_ELEMENTS);
	minphys(bp);
}

void
vs_print_addr(struct vs_softc *sc, struct scsi_xfer *xs)
{
	if (xs == NULL)
		printf("%s: ", sc->sc_dev.dv_xname);
	else {
		sc_print_addr(xs->sc_link);

		/* print bus number too if appropriate */
		if (sc->sc_channel[1].vc_width >= 0)
			printf("(channel %d) ",
			    !!(xs->sc_link->flags & SDEV_2NDBUS));
	}
}

int
do_vspoll(struct vs_softc *sc, struct scsi_xfer *xs, int canreset)
{
	int to;
	int crsw, bus;

	if (xs != NULL) {
		bus = !!(xs->sc_link->flags & SDEV_2NDBUS);
		to = xs->timeout;
		if (to == 0)
			to = 2000;
	} else {
		bus = -1;
		to = 2000;
	}

	while (((crsw = CRSW) & (M_CRSW_CRBV | M_CRSW_CC)) == 0) {
		if (to-- <= 0) {
			vs_print_addr(sc, xs);
			printf("command timeout, crsw 0x%x\n", crsw);

			if (canreset) {
				vs_reset(sc, bus);
				vs_resync(sc);
			}
			return 1;
		}
		delay(1000);
	}
#ifdef VS_DEBUG
	printf("%s: crsw %04x to %d/%d\n",
	    __func__, crsw, to, xs ? xs->timeout : 2000);
#endif
	return 0;
}

void
vs_poll(struct vs_softc *sc, struct vs_cb *cb)
{
	struct scsi_xfer *xs;
	int s;
	int rc;

	xs = cb->cb_xs;
	rc = do_vspoll(sc, xs, 1);

	s = splbio();
	if (rc != 0) {
		xs->error = XS_SELTIMEOUT;
		xs->status = -1;
#ifdef VS_DEBUG
		printf("%s: polled command timed out\n", __func__);
#endif
		vs_free(sc, cb);
		scsi_done(xs);
	} else
		vs_scsidone(sc, cb);
	splx(s);

	if (CRSW & M_CRSW_ER)
		CRB_CLR_ER;
	CRB_CLR_DONE;

	vs_clear_return_info(sc);
}

void
thaw_queue(struct vs_softc *sc, int target)
{
	THAW(target);

	/* loop until thawed */
	while (THAW_REG & M_THAW_TWQE)
		;
}

void
thaw_all_queues(struct vs_softc *sc)
{
	int i;

	for (i = 1; i <= sc->sc_nwq; i++)
		thaw_queue(sc, i);
}

void
vs_scsidone(struct vs_softc *sc, struct vs_cb *cb)
{
	struct scsi_xfer *xs = cb->cb_xs;
	u_int32_t len;
	int error;

	len = vs_read(4, sh_RET_IOPB + IOPB_LENGTH);
	xs->resid = xs->datalen - len;

	error = vs_read(2, sh_RET_IOPB + IOPB_STATUS);
#ifdef VS_DEBUG
	printf("%s: queue %d, len %u (resid %d) error %d\n",
	    __func__, cb->cb_q, len, xs->resid, error);
	if (error != 0)
		printf("%s: last select %d %d, phase %02x %02x\n",
		    __func__, csb_read(1, CSB_LPDS), csb_read(1, CSB_LSDS),
		    csb_read(1, CSB_PPS), csb_read(1, CSB_SPS));
#endif
	if ((error & 0xff) == SCSI_SELECTION_TO) {
		xs->error = XS_SELTIMEOUT;
		xs->status = -1;
	} else {
		if (xs->flags & (SCSI_DATA_IN | SCSI_DATA_OUT)) {
			bus_dmamap_sync(sc->sc_dmat, cb->cb_dmamap, 0,
			    cb->cb_dmalen, (xs->flags & SCSI_DATA_IN) ?
			      BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmat, cb->cb_dmamap);
		}

		xs->status = error >> 8;
	}

	while (xs->status == SCSI_CHECK) {
		vs_chksense(cb, xs);
	}

	vs_free(sc, cb);
	scsi_done(xs);
}

void
vs_scsicmd(struct scsi_xfer *xs)
{
	struct scsi_link *slp = xs->sc_link;
	struct vs_softc *sc = slp->adapter_softc;
	int flags;
	bus_addr_t cqep, iopb;
	struct vs_cb *cb;
	int s;
	int rc;

	flags = xs->flags;
	if (flags & SCSI_POLL) {
		cb = sc->sc_cb;
		cqep = sh_MCE;
		iopb = sh_MCE_IOPB;

#ifdef VS_DEBUG
		if (mce_read(2, CQE_QECR) & M_QECR_GO)
			printf("%s: master command queue busy\n",
			    sc->sc_dev.dv_xname);
#endif
		/* Wait until we can use the command queue entry. */
		while (mce_read(2, CQE_QECR) & M_QECR_GO)
			;
#ifdef VS_DEBUG
		if (cb->cb_xs != NULL) {
			printf("%s: master command not idle\n",
			    sc->sc_dev.dv_xname);
			xs->error = XS_BUSY;
			scsi_done(xs);
			return;
		}
#endif
		s = splbio();
	} else {
		s = splbio();
		cb = vs_find_queue(slp, sc);
		if (cb == NULL) {
			splx(s);
#ifdef VS_DEBUG
			printf("%s: queue for target %d is busy\n",
			    sc->sc_dev.dv_xname, slp->target);
#endif
			xs->error = XS_NO_CCB;
			scsi_done(xs);
			return;
		}
		if (vs_getcqe(sc, &cqep, &iopb)) {
			/* XXX shouldn't happen since our queue is ready */
			splx(s);
#ifdef VS_DEBUG
			printf("%s: no free CQEs\n", sc->sc_dev.dv_xname);
#endif
			xs->error = XS_NO_CCB;
			s = splbio();
			scsi_done(xs);
			splx(s);
			return;
		}
	}

#ifdef VS_DEBUG
	printf("%s: sending SCSI command %02x (length %d) on queue %d\n",
	    __func__, xs->cmd->opcode, xs->cmdlen, cb->cb_q);
#endif
	rc = vs_load_command(sc, cb, cqep, iopb, slp, xs->flags,
	    xs->cmd, xs->cmdlen, xs->data, xs->datalen);
	if (rc != 0) {
		printf("%s: unable to load DMA map: error %d\n",
		    sc->sc_dev.dv_xname, rc);
		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
		splx(s);
		return;
	}

	vs_write(1, cqep + CQE_WORK_QUEUE, cb->cb_q);

	cb->cb_xs = xs;
	splx(s);

	vs_write(4, cqep + CQE_CTAG, (u_int32_t)cb);

	if (crb_read(2, CRB_CRSW) & M_CRSW_AQ)
		vs_write(2, cqep + CQE_QECR, M_QECR_AA | M_QECR_GO);
	else
		vs_write(2, cqep + CQE_QECR, M_QECR_GO);

	if (flags & SCSI_POLL) {
		/* poll for the command to complete */
		vs_poll(sc, cb);
	}
}

int
vs_load_command(struct vs_softc *sc, struct vs_cb *cb, bus_addr_t cqep,
    bus_addr_t iopb, struct scsi_link *slp, int flags,
    struct scsi_generic *cmd, int cmdlen, uint8_t *data, int datalen)
{
	unsigned int iopb_len;
	int option;
	int rc;

	/*
	 * We should only provide the iopb len if the controller is not
	 * able to compute it from the SCSI command group.
	 * Note that Jaguar has no knowledge of group 2.
	 */
	switch ((cmd->opcode) >> 5) {
	case 0:
	case 1:
	case 5:
		iopb_len = 0;
		break;
	case 2:
		if (sc->sc_bid == COUGAR)
			iopb_len = 0;
		else
		/* FALLTHROUGH */
	default:
		iopb_len = IOPB_SHORT_SIZE + ((cmdlen + 1) >> 1);
		break;
	}

	vs_bzero(iopb, IOPB_LONG_SIZE);
	bus_space_write_region_1(sc->sc_iot, sc->sc_ioh, iopb + IOPB_SCSI_DATA,
	    (u_int8_t *)cmd, cmdlen);
	vs_write(2, iopb + IOPB_CMD, IOPB_PASSTHROUGH);
	vs_write(2, iopb + IOPB_UNIT,
	  vs_unit_value(slp->flags & SDEV_2NDBUS, slp->target, slp->lun));
#ifdef VS_DEBUG
	printf("%s: target %d lun %d encoded as %04x\n",
	    __func__, slp->target, slp->lun, (u_int)
	    vs_unit_value(slp->flags & SDEV_2NDBUS, slp->target, slp->lun));
#endif
	vs_write(1, iopb + IOPB_NVCT, sc->sc_nvec);
	vs_write(1, iopb + IOPB_EVCT, sc->sc_evec);

	/*
	 * Setup DMA map for data transfer
	 */
	if (flags & (SCSI_DATA_IN | SCSI_DATA_OUT)) {
		cb->cb_dmalen = (bus_size_t)datalen;
		rc = bus_dmamap_load(sc->sc_dmat, cb->cb_dmamap,
		    data, cb->cb_dmalen, NULL,
		    BUS_DMA_NOWAIT | BUS_DMA_STREAMING |
		    ((flags & SCSI_DATA_IN) ? BUS_DMA_READ : BUS_DMA_WRITE));
		if (rc != 0)
			return rc;

		bus_dmamap_sync(sc->sc_dmat, cb->cb_dmamap, 0,
		    cb->cb_dmalen, (flags & SCSI_DATA_IN) ?
		      BUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE);
	}

	option = 0;
	if (flags & SCSI_DATA_OUT)
		option |= M_OPT_DIR;
	if (slp->adapter_buswidth > 8)
		option |= M_OPT_GO_WIDE;

	if (flags & SCSI_POLL) {
		vs_write(2, iopb + IOPB_OPTION, option);
		vs_write(2, iopb + IOPB_LEVEL, 0);
	} else {
		vs_write(2, iopb + IOPB_OPTION, option | M_OPT_IE);
		vs_write(2, iopb + IOPB_LEVEL, sc->sc_ipl);
	}
	vs_write(2, iopb + IOPB_ADDR, ADDR_MOD);

	if (flags & (SCSI_DATA_IN | SCSI_DATA_OUT))
		vs_build_sg_list(sc, cb, iopb);

	vs_bzero(cqep, CQE_SIZE);
	vs_write(2, cqep + CQE_IOPB_ADDR, iopb);
	vs_write(1, cqep + CQE_IOPB_LENGTH, iopb_len);
	/* CQE_WORK_QUEUE to be filled by the caller */

	return 0;
}

void
vs_chksense(struct vs_cb *cb, struct scsi_xfer *xs)
{
	struct scsi_link *slp = xs->sc_link;
	struct vs_softc *sc = slp->adapter_softc;
	struct scsi_sense ss;
	int rc;
	int s;

#ifdef VS_DEBUG
	printf("%s: target %d\n", slp->target);
#endif
	/* ack and clear the error */
	if (CRSW & M_CRSW_ER)
		CRB_CLR_ER;
	CRB_CLR_DONE;
	xs->status = 0;

	/* Wait until we can use the command queue entry. */
	while (mce_read(2, CQE_QECR) & M_QECR_GO)
		;

	bzero(&ss, sizeof ss);
	ss.opcode = REQUEST_SENSE;
	ss.byte2 = slp->lun << 5;
	ss.length = sizeof(xs->sense);

#ifdef VS_DEBUG
	printf("%s: sending SCSI command %02x (length %d) on queue %d\n",
	    __func__, ss.opcode, sizeof ss, 0);
#endif
	rc = vs_load_command(sc, cb, sh_MCE, sh_MCE_IOPB, slp,
	    SCSI_DATA_IN | SCSI_POLL,
	    (struct scsi_generic *)&ss, sizeof ss, (uint8_t *)&xs->sense,
	    sizeof(xs->sense));
	if (rc != 0) {
		printf("%s: unable to load DMA map: error %d\n",
		    sc->sc_dev.dv_xname, rc);
		xs->error = XS_DRIVER_STUFFUP;
		xs->status = 0;
		return;
	}

	mce_write(1, CQE_WORK_QUEUE, 0);
	mce_write(2, CQE_QECR, M_QECR_GO);

	/* poll for the command to complete */
	s = splbio();
	do_vspoll(sc, xs, 1);
	xs->status = vs_read(2, sh_RET_IOPB + IOPB_STATUS) >> 8;
	splx(s);
}

int
vs_getcqe(struct vs_softc *sc, bus_addr_t *cqep, bus_addr_t *iopbp)
{
	bus_addr_t cqe, iopb;
	int qhdp;

	qhdp = mcsb_read(2, MCSB_QHDP);
	cqe = sh_CQE(qhdp);
	iopb = sh_IOPB(qhdp);

	if (vs_read(2, cqe + CQE_QECR) & M_QECR_GO) {
		/* queue still in use, should never happen */
		return EAGAIN;
	}

	if (++qhdp == NUM_CQE)
		qhdp = 0;
	mcsb_write(2, MCSB_QHDP, qhdp);

	vs_bzero(cqe, CQE_SIZE);
	*cqep = cqe;
	*iopbp = iopb;
	return (0);
}

int
vs_identify(struct vs_channel *vc, int cid)
{
	vc->vc_width = 0;
	vc->vc_type = VCT_UNKNOWN;

	if (vc->vc_id < 0)
		return (0);

	switch (cid) {
	case 0x00:
		vc->vc_width = 8;
		vc->vc_type = VCT_SE;
		break;
	case 0x01:
		vc->vc_width = 8;
		vc->vc_type = VCT_DIFFERENTIAL;
		break;
	case 0x02:
		vc->vc_width = 16;
		vc->vc_type = VCT_SE;
		break;
	case 0x03:
	case 0x0e:
		vc->vc_width = 16;
		vc->vc_type = VCT_DIFFERENTIAL;
		break;
	default:
		vc->vc_id = -1;
		return (0);
	}

	return (vc->vc_width - 1);
}

int
vs_initialize(struct vs_softc *sc)
{
	int i, msr, id, rc;
	u_int targets;

	/*
	 * Reset the board, and wait for it to get ready.
	 * The reset signal is applied for 70 usec, and the board status
	 * is not tested until 100 usec after the reset signal has been
	 * cleared, per the manual (MVME328/D1) pages 4-6 and 4-9.
	 */

	mcsb_write(2, MCSB_MCR, M_MCR_RES | M_MCR_SFEN);
	delay(70);
	mcsb_write(2, MCSB_MCR, M_MCR_SFEN);

	delay(100);
	i = 0;
	for (;;) {
		msr = mcsb_read(2, MCSB_MSR);
		if ((msr & (M_MSR_BOK | M_MSR_CNA)) == M_MSR_BOK)
			break;
		if (++i > 5000) {
			printf("board reset failed, status %x\n", msr);
			return 1;
		}
		delay(1000);
	}

	/* describe the board */
	switch (sc->sc_bid) {
	default:
	case JAGUAR:
		printf("Jaguar");
		break;
	case COUGAR:
		id = csb_read(1, CSB_EXTID);
		switch (id) {
		case 0x00:
			printf("Cougar");
			break;
		case 0x02:
			printf("Cougar II");
			break;
		default:
			printf("unknown Cougar version %02x", id);
			break;
		}
		break;
	}

	/* initialize channels id */
	sc->sc_channel[0].vc_id = csb_read(1, CSB_PID);
	sc->sc_channel[1].vc_id = -1;
	switch (id = csb_read(1, CSB_DBID)) {
	case DBID_SCSI2:
	case DBID_SCSI:
		sc->sc_channel[1].vc_id = csb_read(1, CSB_SID);
		break;
	case DBID_PRINTER:
		printf(", printer port");
		break;
	case DBID_NONE:
		break;
	default:
		printf(", unknown daughterboard id %x", id);
		break;
	}

	printf("\n");

	/*
	 * On cougar boards, find how many work queues we can use,
	 * and whether we are on wide or narrow buses.
	 */
	switch (sc->sc_bid) {
	case COUGAR:
		sc->sc_nwq = csb_read(2, CSB_NWQ);
		/*
		 * Despite what the documentation says, this value is not
		 * always provided. If it is invalid, decide on the number
		 * of available work queues from the memory size, as the
		 * firmware does.
		 */
#ifdef VS_DEBUG
		printf("%s: controller reports %d work queues\n",
		    __func__, sc->sc_nwq);
#endif
		if (sc->sc_nwq != 0x0f && sc->sc_nwq != 0xff) {
			if (csb_read(2, CSB_BSIZE) >= 0x0100)
				sc->sc_nwq = 0xff;	/* >= 256KB, 255 WQ */
			else
				sc->sc_nwq = 0x0f;	/* < 256KB, 15 WQ */
		}
#ifdef VS_DEBUG
		printf("%s: driver deducts %d work queues\n",
		    __func__, sc->sc_nwq);
#endif
		if (sc->sc_nwq > NUM_WQ)
			sc->sc_nwq = NUM_WQ;

		targets = vs_identify(&sc->sc_channel[0],
		    csb_read(1, CSB_PFECID));
		targets += vs_identify(&sc->sc_channel[1],
		    csb_read(1, CSB_SFECID));

		if (sc->sc_nwq > targets)
			sc->sc_nwq = targets;
		else {
			/*
			 * We can't drive the daughter board if there is not
			 * enough on-board memory for all the work queues.
			 * XXX This might work by moving everything off-board?
			 */
			if (sc->sc_nwq < targets)
				sc->sc_channel[1].vc_width = 0;
		}
		break;
	default:
	case JAGUAR:
		sc->sc_nwq = JAGUAR_MAX_WQ;
		sc->sc_channel[0].vc_width = sc->sc_channel[1].vc_width = 8;
		break;
	}

	CRB_CLR_DONE;
	mcsb_write(2, MCSB_QHDP, 0);

	vs_bzero(sh_CIB, CIB_SIZE);
	cib_write(2, CIB_NCQE, NUM_CQE);
	cib_write(2, CIB_BURST, 0);
	cib_write(2, CIB_NVECT, (sc->sc_ipl << 8) | sc->sc_nvec);
	cib_write(2, CIB_EVECT, (sc->sc_ipl << 8) | sc->sc_evec);
	cib_write(2, CIB_PID, 0x08);	/* use default */
	cib_write(2, CIB_SID, 0x08);	/* use default */
	cib_write(2, CIB_CRBO, sh_CRB);
	cib_write(4, CIB_SELECT, SELECTION_TIMEOUT);
	cib_write(4, CIB_WQTIMO, 4);
	cib_write(4, CIB_VMETIMO, 0 /* VME_BUS_TIMEOUT */);
	cib_write(2, CIB_ERR_FLGS, M_ERRFLGS_RIN | M_ERRFLGS_RSE);
	cib_write(2, CIB_SBRIV, (sc->sc_ipl << 8) | sc->sc_evec);
	cib_write(1, CIB_SOF0, 0x15);
	cib_write(1, CIB_SRATE0, 100 / 4);
	cib_write(1, CIB_SOF1, 0);
	cib_write(1, CIB_SRATE1, 0);

	vs_bzero(sh_MCE_IOPB, IOPB_LONG_SIZE);
	mce_iopb_write(2, IOPB_CMD, CNTR_INIT);
	mce_iopb_write(2, IOPB_OPTION, 0);
	mce_iopb_write(1, IOPB_NVCT, sc->sc_nvec);
	mce_iopb_write(1, IOPB_EVCT, sc->sc_evec);
	mce_iopb_write(2, IOPB_LEVEL, 0 /* sc->sc_ipl */);
	mce_iopb_write(2, IOPB_ADDR, SHIO_MOD);
	mce_iopb_write(4, IOPB_BUFF, sh_CIB);
	mce_iopb_write(4, IOPB_LENGTH, CIB_SIZE);

	vs_bzero(sh_MCE, CQE_SIZE);
	mce_write(2, CQE_IOPB_ADDR, sh_MCE_IOPB);
	mce_write(1, CQE_IOPB_LENGTH, 0);
	mce_write(1, CQE_WORK_QUEUE, 0);
	mce_write(2, CQE_QECR, M_QECR_GO);

	/* poll for the command to complete */
	do_vspoll(sc, NULL, 1);

	if ((rc = vs_alloc_sg(sc)) != 0)
		return rc;

	if ((rc = vs_alloc_wq(sc)) != 0)
		return rc;

	/* initialize work queues */
#ifdef VS_DEBUG
	printf("%s: initializing %d work queues\n",
	    __func__, sc->sc_nwq);
#endif

	for (i = 1; i <= sc->sc_nwq; i++) {
		/* Wait until we can use the command queue entry. */
		while (mce_read(2, CQE_QECR) & M_QECR_GO)
			;

		vs_bzero(sh_MCE_IOPB, IOPB_LONG_SIZE);
		mce_iopb_write(2, WQCF_CMD, CNTR_INIT_WORKQ);
		mce_iopb_write(2, WQCF_OPTION, 0);
		mce_iopb_write(1, WQCF_NVCT, sc->sc_nvec);
		mce_iopb_write(1, WQCF_EVCT, sc->sc_evec);
		mce_iopb_write(2, WQCF_ILVL, 0 /* sc->sc_ipl */);
		mce_iopb_write(2, WQCF_WORKQ, i);
		mce_iopb_write(2, WQCF_WOPT, M_WOPT_FE | M_WOPT_IWQ);
		if (sc->sc_bid == JAGUAR)
			mce_iopb_write(2, WQCF_SLOTS, JAGUAR_MAX_Q_SIZ);
		mce_iopb_write(4, WQCF_CMDTO, 4);	/* 1 second */
		if (sc->sc_bid != JAGUAR)
			mce_iopb_write(2, WQCF_UNIT,
			    vs_unit_value(i > sc->sc_channel[0].vc_width,
				i - sc->sc_channel[0].vc_width, 0));

		vs_bzero(sh_MCE, CQE_SIZE);
		mce_write(2, CQE_IOPB_ADDR, sh_MCE_IOPB);
		mce_write(1, CQE_IOPB_LENGTH, 0);
		mce_write(1, CQE_WORK_QUEUE, 0);
		mce_write(2, CQE_QECR, M_QECR_GO);

		/* poll for the command to complete */
		do_vspoll(sc, NULL, 1);
		if (CRSW & M_CRSW_ER) {
			printf("%s: work queue %d initialization error 0x%x\n",
			    sc->sc_dev.dv_xname, i,
			    vs_read(2, sh_RET_IOPB + IOPB_STATUS));
			return ENXIO;
		}
		CRB_CLR_DONE;
	}

	/* start queue mode */
	mcsb_write(2, MCSB_MCR, mcsb_read(2, MCSB_MCR) | M_MCR_SQM);

	/* reset all SCSI buses */
	vs_reset(sc, -1);
	/* sync all devices */
	vs_resync(sc);

	return 0;
}

/*
 * Allocate memory for the scatter/gather lists.
 *
 * Since vs_minphys() makes sure we won't need more than flat lists of
 * up to MAX_SG_ELEMENTS entries, we need to allocate storage for one
 * such list per work queue.
 */
int
vs_alloc_sg(struct vs_softc *sc)
{
	size_t sglen;
	int nseg;
	int rc;

	sglen = (sc->sc_nwq + 1) * MAX_SG_ELEMENTS * sizeof(struct vs_sg_entry);
	sglen = round_page(sglen);

	rc = bus_dmamem_alloc(sc->sc_dmat, sglen, 0, 0,
	    &sc->sc_sgseg, 1, &nseg, BUS_DMA_NOWAIT);
	if (rc != 0) {
		printf("%s: unable to allocate s/g memory: error %d\n",
		    sc->sc_dev.dv_xname, rc);
		goto fail1;
	}
	rc = bus_dmamem_map(sc->sc_dmat, &sc->sc_sgseg, nseg, sglen,
	    (caddr_t *)&sc->sc_sgva, BUS_DMA_NOWAIT | BUS_DMA_COHERENT);
	if (rc != 0) {
		printf("%s: unable to map s/g memory: error %d\n",
		    sc->sc_dev.dv_xname, rc);
		goto fail2;
	}
	rc = bus_dmamap_create(sc->sc_dmat, sglen, 1, sglen, 0,
	    BUS_DMA_NOWAIT /* | BUS_DMA_ALLOCNOW */, &sc->sc_sgmap);
	if (rc != 0) {
		printf("%s: unable to create s/g dma map: error %d\n",
		    sc->sc_dev.dv_xname, rc);
		goto fail3;
	}
	rc = bus_dmamap_load(sc->sc_dmat, sc->sc_sgmap, sc->sc_sgva,
	    sglen, NULL, BUS_DMA_NOWAIT);
	if (rc != 0) {
		printf("%s: unable to load s/g dma map: error %d\n",
		    sc->sc_dev.dv_xname, rc);
		goto fail4;
	}

	return 0;

fail4:
	bus_dmamap_destroy(sc->sc_dmat, sc->sc_sgmap);
fail3:
	bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->sc_sgva, PAGE_SIZE);
fail2:
	bus_dmamem_free(sc->sc_dmat, &sc->sc_sgseg, 1);
fail1:
	return rc;
}

/*
 * Allocate one command block per work qeue.
 */
int
vs_alloc_wq(struct vs_softc *sc)
{
	struct vs_cb *cb;
	u_int i;
	int rc;

	sc->sc_cb = malloc((sc->sc_nwq + 1) * sizeof(struct vs_cb), M_DEVBUF,
	    M_ZERO | M_NOWAIT);
	if (sc->sc_cb == NULL) {
		printf("%s: unable to allocate %d work queues\n",
		    sc->sc_dev.dv_xname, sc->sc_nwq);
		return ENOMEM;
	}

	for (i = 0, cb = sc->sc_cb; i <= sc->sc_nwq; i++, cb++) {
		cb->cb_q = i;

		rc = bus_dmamap_create(sc->sc_dmat, ptoa(MAX_SG_ELEMENTS),
		    MAX_SG_ELEMENTS, MAX_SG_ELEMENT_SIZE, 0,
		    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &cb->cb_dmamap);
		if (rc != 0) {
			printf("%s: unable to create dma map for queue %d"
			    ": error %d\n",
			    sc->sc_dev.dv_xname, i, rc);
			goto fail;
		}
	}

	return 0;

fail:
	while (i != 0) {
		i--; cb--;
		bus_dmamap_destroy(sc->sc_dmat, cb->cb_dmamap);
	}
	free(sc->sc_cb, M_DEVBUF);
	sc->sc_cb = NULL;

	return rc;
}

void
vs_resync(struct vs_softc *sc)
{
	struct vs_channel *vc;
	int bus, target;

	for (bus = 0; bus < 2; bus++) {
		vc = &sc->sc_channel[bus];
		if (vc->vc_id < 0 || vc->vc_width == 0)
			break;

		for (target = 0; target < vc->vc_width; target++) {
			if (target == vc->vc_id)
				continue;

			/* Wait until we can use the command queue entry. */
			while (mce_read(2, CQE_QECR) & M_QECR_GO)
				;

			vs_bzero(sh_MCE_IOPB, IOPB_SHORT_SIZE);
			mce_iopb_write(2, DRCF_CMD, CNTR_DEV_REINIT);
			mce_iopb_write(2, DRCF_OPTION, 0); /* prefer polling */
			mce_iopb_write(1, DRCF_NVCT, sc->sc_nvec);
			mce_iopb_write(1, DRCF_EVCT, sc->sc_evec);
			mce_iopb_write(2, DRCF_ILVL, 0);
			mce_iopb_write(2, DRCF_UNIT,
			    vs_unit_value(bus, target, 0));

			vs_bzero(sh_MCE, CQE_SIZE);
			mce_write(2, CQE_IOPB_ADDR, sh_MCE_IOPB);
			mce_write(1, CQE_IOPB_LENGTH, 0);
			mce_write(1, CQE_WORK_QUEUE, 0);
			mce_write(2, CQE_QECR, M_QECR_GO);

			/* poll for the command to complete */
			do_vspoll(sc, NULL, 0);
			if (CRSW & M_CRSW_ER)
				CRB_CLR_ER;
			CRB_CLR_DONE;
		}
	}
}

void
vs_reset(struct vs_softc *sc, int bus)
{
	int b, s;

	s = splbio();

	for (b = 0; b < 2; b++) {
		if (bus >= 0 && b != bus)
			continue;

		/* Wait until we can use the command queue entry. */
		while (mce_read(2, CQE_QECR) & M_QECR_GO)
			;

		vs_bzero(sh_MCE_IOPB, IOPB_SHORT_SIZE);
		mce_iopb_write(2, SRCF_CMD, IOPB_RESET);
		mce_iopb_write(2, SRCF_OPTION, 0);	/* prefer polling */
		mce_iopb_write(1, SRCF_NVCT, sc->sc_nvec);
		mce_iopb_write(1, SRCF_EVCT, sc->sc_evec);
		mce_iopb_write(2, SRCF_ILVL, 0);
		mce_iopb_write(2, SRCF_BUSID, b << 15);

		vs_bzero(sh_MCE, CQE_SIZE);
		mce_write(2, CQE_IOPB_ADDR, sh_MCE_IOPB);
		mce_write(1, CQE_IOPB_LENGTH, 0);
		mce_write(1, CQE_WORK_QUEUE, 0);
		mce_write(2, CQE_QECR, M_QECR_GO);

		/* poll for the command to complete */
		for (;;) {
			do_vspoll(sc, NULL, 0);
			/* ack & clear scsi error condition cause by reset */
			if (CRSW & M_CRSW_ER) {
				CRB_CLR_DONE;
				vs_write(2, sh_RET_IOPB + IOPB_STATUS, 0);
				break;
			}
			CRB_CLR_DONE;
		}
	}

	thaw_all_queues(sc);

	splx(s);
}

/* free a cb and thaw its queue; invoked at splbio */
static __inline__ void
vs_free(struct vs_softc *sc, struct vs_cb *cb)
{
	if (cb->cb_q != 0)
		thaw_queue(sc, cb->cb_q);
	cb->cb_xs = NULL;
}

/* normal interrupt routine */
int
vs_nintr(void *vsc)
{
	struct vs_softc *sc = (struct vs_softc *)vsc;
	struct vs_cb *cb;
	int s;

#if 0	/* bogus! */
	if ((CRSW & CONTROLLER_ERROR) == CONTROLLER_ERROR)
		return vs_eintr(sc);
#endif

	/* Got a valid interrupt on this device */
	s = splbio();
	cb = (struct vs_cb *)crb_read(4, CRB_CTAG);

	/*
	 * If this is a controller error, there won't be a cb
	 * pointer in the CTAG field.  Bad things happen if you try
	 * to point to address 0.  But then, we should have caught
	 * the controller error above.
	 */
	if (cb != NULL) {
#ifdef VS_DEBUG
		printf("%s: interrupt for queue %d\n", __func__, cb->cb_q);
#endif
		vs_scsidone(sc, cb);
	} else {
#ifdef VS_DEBUG
		printf("%s: normal interrupt but no related command???\n",
		    __func__);
#endif
	}

	/* ack the interrupt */
	if (CRSW & M_CRSW_ER)
		CRB_CLR_ER;
	CRB_CLR_DONE;

	vs_clear_return_info(sc);
	splx(s);

	return 1;
}

/* error interrupts */
int
vs_eintr(void *vsc)
{
	struct vs_softc *sc = (struct vs_softc *)vsc;
	struct vs_cb *cb;
	struct scsi_xfer *xs;
	int crsw, ecode;
	int s;

	/* Got a valid interrupt on this device */
	s = splbio();

	crsw = vs_read(2, sh_CEVSB + CEVSB_CRSW);
	ecode = vs_read(1, sh_CEVSB + CEVSB_ERROR);
	cb = (struct vs_cb *)crb_read(4, CRB_CTAG);
	xs = cb != NULL ? cb->cb_xs : NULL;

#ifdef VS_DEBUG
	printf("%s: error interrupt, crsw %04x, error %d, queue %d\n",
	    __func__, (u_int)crsw, ecode, cb ? cb->cb_q : -1);
#endif
	vs_print_addr(sc, xs);

	if (crsw & M_CRSW_RST) {
		printf("bus reset\n");
	} else {
		switch (ecode) {
		case CEVSB_ERR_TYPE:
			printf("IOPB type error\n");
			break;
		case CEVSB_ERR_TO:
			printf("timeout\n");
			break;
		case CEVSB_ERR_TR:
			printf("reconnect error\n");
			break;
		case CEVSB_ERR_OF:
			printf("overflow\n");
			break;
		case CEVSB_ERR_BD:
			printf("bad direction\n");
			break;
		case CEVSB_ERR_NR:
			printf("non-recoverable error\n");
			break;
		case CEVSB_ERR_PANIC:
			printf("board panic\n");
			break;
		default:
			printf("unexpected error %x\n", ecode);
			break;
		}
	}

	if (xs != NULL) {
		xs->error = XS_SELTIMEOUT;
		xs->status = -1;
		scsi_done(xs);
	}

	if (CRSW & M_CRSW_ER)
		CRB_CLR_ER;
	CRB_CLR_DONE;

	thaw_all_queues(sc);
	vs_clear_return_info(sc);
	splx(s);

	return 1;
}

static void
vs_clear_return_info(struct vs_softc *sc)
{
	vs_bzero(sh_RET_IOPB, CRB_SIZE + IOPB_LONG_SIZE);
}

/*
 * Choose the first available work queue (invoked at splbio).
 * We used a simple round-robin mechanism which is faster than rescanning
 * from the beginning if we have more than one target on the bus.
 */
struct vs_cb *
vs_find_queue(struct scsi_link *sl, struct vs_softc *sc)
{
	struct vs_cb *cb;
	u_int q;

	/*
	 * Map the target number (0-7/15) to the 1-7/15 range, target 0
	 * picks the host adapter target number (since host adapter
	 * commands are issued on queue #0).
	 */
	q = sl->target;
	if (q == 0)
		q = sl->adapter_target;
	if (sl->flags & SDEV_2NDBUS)
		q += sc->sc_channel[0].vc_width - 1; /* map to 8-14 or 16-30 */

	if ((cb = sc->sc_cb + q)->cb_xs == NULL)
		return (cb);

	return (NULL);
}

/*
 * Encode a specific target.
 */
int
vs_unit_value(int bus, int tgt, int lun)
{
	int unit = 0;

	if (bus != 0)
		unit |= M_UNIT_BUS;	/* secondary bus */

	if (tgt > 7 || lun > 7) {
		/* extended addressing (for Cougar II-Wide only) */
		unit |= M_UNIT_EXT;
		unit |= (lun & 0x3f) << 8;
		unit |= (tgt & 0x0f) << 0;
	} else {
		unit |= lun << 3;
		unit |= tgt << 0;
	}

	return (unit);
}

/*
 * Build the scatter/gather list for the given control block and update
 * its IOPB.
 */
void
vs_build_sg_list(struct vs_softc *sc, struct vs_cb *cb, bus_addr_t iopb)
{
	struct vs_sg_entry *sgentry;
	int segno;
	bus_dma_segment_t *seg = cb->cb_dmamap->dm_segs;
	bus_size_t sgoffs;
	bus_size_t len;

	/*
	 * No need to build a scatter/gather chain if there is only
	 * one contiguous physical area.
	 */
	if (cb->cb_dmamap->dm_nsegs == 1) {
		vs_write(4, iopb + IOPB_BUFF, seg->ds_addr);
		vs_write(4, iopb + IOPB_LENGTH, cb->cb_dmalen);
		return;
	}

	/*
	 * Otherwise, we need to build the flat s/g list.
	 */

	sgentry = sc->sc_sgva + cb->cb_q * MAX_SG_ELEMENTS;
	sgoffs = (vaddr_t)sgentry - (vaddr_t)sc->sc_sgva;

	len = cb->cb_dmalen;
	for (segno = 0; segno < cb->cb_dmamap->dm_nsegs; seg++, segno++) {
		if (seg->ds_len > len) {
			sgentry->count.bytes = htobe16(len);
			len = 0;
		} else {
			sgentry->count.bytes = htobe16(seg->ds_len);
			len -= seg->ds_len;
		}
		sgentry->pa_high = htobe16(seg->ds_addr >> 16);
		sgentry->pa_low = htobe16(seg->ds_addr & 0xffff);
		sgentry->addr = htobe16(ADDR_MOD);
		sgentry++;
	}

	bus_dmamap_sync(sc->sc_dmat, sc->sc_sgmap, sgoffs,
	    cb->cb_dmamap->dm_nsegs * sizeof(struct vs_sg_entry),
	    BUS_DMASYNC_PREWRITE);

	vs_write(2, iopb + IOPB_OPTION,
	    vs_read(2, iopb + IOPB_OPTION) | M_OPT_SG);
	vs_write(2, iopb + IOPB_ADDR,
	    vs_read(2, iopb + IOPB_ADDR) | M_ADR_SG_LINK);
	vs_write(4, iopb + IOPB_BUFF,
	    sc->sc_sgmap->dm_segs[0].ds_addr + sgoffs);
	vs_write(4, iopb + IOPB_LENGTH, cb->cb_dmamap->dm_nsegs);
	vs_write(4, iopb + IOPB_SGTTL, cb->cb_dmalen);
}
@


1.84
log
@if the controller is too busy to do a POLLed command, return XS_BUSY
instead of XS_NO_CCB.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.83 2010/12/23 20:25:18 miod Exp $	*/
@


1.83
log
@Better malloc the right size, overruns are so 200x... Pass the brown paper
bag, please.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.82 2010/11/18 21:13:19 miod Exp $	*/
d425 1
a425 1
			xs->error = XS_NO_CCB;
@


1.82
log
@Do not #include <sys/dkstat.h> if you don't need anything from it.
ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.81 2010/06/28 18:31:01 krw Exp $	*/
d802 1
a802 1
			 * We can't drive the daugther board if there is not
d932 1
a932 1
	sglen = sc->sc_nwq * MAX_SG_ELEMENTS * sizeof(struct vs_sg_entry);
d986 1
a986 1
	sc->sc_cb = malloc(sc->sc_nwq * sizeof(struct vs_cb), M_DEVBUF,
@


1.81
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.80 2010/05/20 00:55:17 krw Exp $	*/
a47 1
#include <sys/dkstat.h>
@


1.80
log
@New scsi code seems to be stable. Pluck previously identified
low-hanging splbio/splx pairs that are no longer needed and see if
this reveals any hidden scsi flaws.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.79 2010/03/23 01:57:19 krw Exp $	*/
a76 7
struct scsi_device vs_scsidev = {
	NULL,		/* use default error handler */
	NULL,		/* do not have a start function */
	NULL,		/* have no async handler */
	NULL,		/* Use default done routine */
};

a212 1
		sc_link->device = &vs_scsidev;
@


1.79
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.78 2010/01/09 23:15:06 krw Exp $	*/
a434 1
			s = splbio();
a435 1
			splx(s);
a449 1
			s = splbio();
a450 1
			splx(s);
@


1.78
log
@Zap all setting of ITSDONE in drivers that don't look at it. Nobody
else cares so it's just noise. Drivers that actually look at ITSDONE
are unchanged.

ok marco@@ (for his files) dlg@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.77 2009/11/22 14:14:10 krw Exp $	*/
d68 1
a68 1
int	vs_scsicmd(struct scsi_xfer *);
d108 1
a108 1
int	vs_poll(struct vs_softc *, struct vs_cb *);
d315 1
a315 1
int
a342 1
	return (COMPLETE);
d405 1
a405 1
int
d434 5
a438 1
			return (NO_CCB);
d451 5
a455 1
			return (NO_CCB);
d463 5
a467 1
			return (NO_CCB);
d483 1
a483 1
		return (COMPLETE);
d500 1
a500 1
		return vs_poll(sc, cb);
a501 2

	return (SUCCESSFULLY_QUEUED);
@


1.77
log
@Bring last drivers fully into the NO_CCB world by replacing
TRY_AGAIN_LATER uses with equivalent NO_CCB.  Eliminates confusion
between the two as was always intended.  buf I/O's that can't be
started get pushed back onto the front of the queue and retried.
Others get sent back to originator as failures. No more epi-cycle
looping inside the SCSI midlayer hoping the problem goes away.

Various testers, no objection from miod@@ as vs(4) was tested by
nick@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.76 2009/02/16 21:19:06 miod Exp $	*/
a328 1
		xs->flags |= ITSDONE;
a401 1
	xs->flags |= ITSDONE;
a1227 1
		xs->flags |= ITSDONE;
@


1.76
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.75 2009/02/08 13:28:01 miod Exp $	*/
d437 1
a437 1
			return (TRY_AGAIN_LATER);
d450 1
a450 1
			return (TRY_AGAIN_LATER);
d458 1
a458 1
			return (TRY_AGAIN_LATER);
@


1.75
log
@Use the correct flags when bus_dmamap_sync()ing the s/g lists.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.74 2009/02/01 20:42:24 miod Exp $	*/
d67 1
a67 1
void	vs_minphys(struct buf *);
d257 1
a257 1
vs_minphys(struct buf *bp)
@


1.74
log
@Nuke whitespace at EOL.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.73 2009/02/01 00:44:36 miod Exp $	*/
a1122 8
#if 0
	if (cb->cb_sg != NULL) {
		vs_dealloc_scatter_gather(cb->cb_sg);
		cb->cb_sg = NULL;
	}
#else
	/* nothing to do, really */
#endif
d1336 1
a1336 1
			sgentry->count.bytes = len;
d1339 1
a1339 1
			sgentry->count.bytes = seg->ds_len;
d1342 3
a1344 3
		sgentry->pa_high = seg->ds_addr >> 16;
		sgentry->pa_low = seg->ds_addr & 0xffff;
		sgentry->addr = ADDR_MOD;
d1350 1
a1350 1
	    BUS_DMASYNC_PREREAD);
@


1.73
log
@Finally switch this driver to bus_dma.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.72 2009/01/29 22:16:34 miod Exp $	*/
d557 1
a557 1
			
d969 1
a969 1
		    
d1359 1
a1359 1
	
@


1.72
log
@Add a few cache operations after I/O completes.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.71 2008/07/30 18:08:03 miod Exp $	*/
d4 1
a4 1
 * Copyright (c) 2004, Miodrag Vallat.
d67 1
d72 1
a72 1
	minphys,
d95 4
a98 5
M328_SG	vs_alloc_scatter_gather(void);
M328_SG	vs_build_memory_structure(struct vs_softc *, struct scsi_xfer *,
	    bus_addr_t);
void	vs_chksense(struct scsi_xfer *);
void	vs_dealloc_scatter_gather(M328_SG);
d104 3
a106 2
void	vs_link_sg_element(sg_list_element_t *, vaddr_t, int);
void	vs_link_sg_list(sg_list_element_t *, vaddr_t, int);
a117 1
static __inline__ paddr_t kvtop(vaddr_t);
d171 1
a171 1
	sc->sc_paddr = ca->ca_paddr;
d173 1
a173 1
	if (bus_space_map(sc->sc_iot, sc->sc_paddr, S_SHORTIO, 0,
d207 1
a207 1
	if (sc->sc_paddr != bootaddr)
d257 8
d389 6
a394 3
		if (xs->flags & SCSI_DATA_IN)
			dma_cachectl(pmap_kernel(), (vaddr_t)xs->data,
			    xs->datalen, DMA_CACHE_INV);
d400 1
a400 1
		vs_chksense(xs);
d413 1
a413 2
	int flags, option;
	unsigned int iopb_len;
a415 1
	u_int queue;
d417 1
d421 1
a421 1
		cb = &sc->sc_cb[0];
d462 21
a482 1
	queue = cb->cb_q;
d484 21
a504 1
	vs_bzero(iopb, IOPB_LONG_SIZE);
d511 1
a511 1
	switch ((xs->cmd->opcode) >> 5) {
d523 1
a523 1
		iopb_len = IOPB_SHORT_SIZE + ((xs->cmdlen + 1) >> 1);
d527 1
a527 4
#ifdef VS_DEBUG
	printf("%s: sending SCSI command %02x (length %d, iopb length %d) on queue %d\n",
	    __func__, xs->cmd->opcode, xs->cmdlen, iopb_len, queue);
#endif
d529 1
a529 2
	    (u_int8_t *)xs->cmd, xs->cmdlen);

d542 1
a542 3
	 * Since the 88k doesn't support cache snooping, we have
	 * to flush the cache for a write and flush with inval for
	 * a read, prior to starting the IO.
d544 14
a557 3
	dma_cachectl(pmap_kernel(), (vaddr_t)xs->data, xs->datalen,
	    flags & SCSI_DATA_IN ? DMA_CACHE_SYNC_INVAL : DMA_CACHE_SYNC);
	
d573 4
d579 1
a579 1
	vs_write(1, cqep + CQE_WORK_QUEUE, queue);
d581 1
a581 21
	cb->cb_xs = xs;
	splx(s);

	if (xs->datalen != 0)
		cb->cb_sg = vs_build_memory_structure(sc, xs, iopb);
	else
		cb->cb_sg = NULL;

	vs_write(4, cqep + CQE_CTAG, (u_int32_t)cb);

	if (crb_read(2, CRB_CRSW) & M_CRSW_AQ)
		vs_write(2, cqep + CQE_QECR, M_QECR_AA | M_QECR_GO);
	else
		vs_write(2, cqep + CQE_QECR, M_QECR_GO);

	if (flags & SCSI_POLL) {
		/* poll for the command to complete */
		return vs_poll(sc, cb);
	}

	return (SUCCESSFULLY_QUEUED);
d585 1
a585 1
vs_chksense(struct scsi_xfer *xs)
a586 1
	int s;
d589 3
a591 1
	struct scsi_sense *ss;
d606 4
a609 7
	vs_bzero(sh_MCE_IOPB, IOPB_LONG_SIZE);
	/* This is a command, so point to it */
	ss = (void *)(bus_space_vaddr(sc->sc_iot, sc->sc_ioh) +
	    sh_MCE_IOPB + IOPB_SCSI_DATA);
	ss->opcode = REQUEST_SENSE;
	ss->byte2 = slp->lun << 5;
	ss->length = sizeof(struct scsi_sense_data);
d611 15
a625 10
	mce_iopb_write(2, IOPB_CMD, IOPB_PASSTHROUGH);
	mce_iopb_write(2, IOPB_OPTION, 0);
	mce_iopb_write(1, IOPB_NVCT, sc->sc_nvec);
	mce_iopb_write(1, IOPB_EVCT, sc->sc_evec);
	mce_iopb_write(2, IOPB_LEVEL, 0 /* sc->sc_ipl */);
	mce_iopb_write(2, IOPB_ADDR, ADDR_MOD);
	mce_iopb_write(4, IOPB_BUFF, kvtop((vaddr_t)&xs->sense));
	mce_iopb_write(4, IOPB_LENGTH, sizeof(struct scsi_sense_data));
	mce_iopb_write(2, IOPB_UNIT,
	  vs_unit_value(slp->flags & SDEV_2NDBUS, slp->target, slp->lun));
a626 6
	dma_cachectl(pmap_kernel(), (vaddr_t)&xs->sense,
	    sizeof(struct scsi_sense_data), DMA_CACHE_SYNC_INVAL);

	vs_bzero(sh_MCE, CQE_SIZE);
	mce_write(2, CQE_IOPB_ADDR, sh_MCE_IOPB);
	mce_write(1, CQE_IOPB_LENGTH, 0);
d700 1
a700 1
	int i, msr, id;
d863 6
a873 2
	for (i = 0; i <= sc->sc_nwq; i++)
		sc->sc_cb[i].cb_q = i;
d905 4
a908 3
			printf("work queue %d initialization error 0x%x\n",
			    i, vs_read(2, sh_RET_IOPB + IOPB_STATUS));
			return 1;
d924 103
d1123 1
d1128 3
d1281 1
a1281 1
	if ((cb = &sc->sc_cb[q])->cb_xs == NULL)
d1312 2
a1313 1
 * Useful functions for scatter/gather list
a1314 24

M328_SG
vs_alloc_scatter_gather(void)
{
	M328_SG sg;

	sg = malloc(sizeof(struct m328_sg), M_DEVBUF, M_WAITOK | M_ZERO);

	return (sg);
}

void
vs_dealloc_scatter_gather(M328_SG sg)
{
	int i;

	if (sg->level > 0) {
		for (i = 0; sg->down[i] && i < MAX_SG_ELEMENTS; i++) {
			vs_dealloc_scatter_gather(sg->down[i]);
		}
	}
	free(sg, M_DEVBUF);
}

d1316 1
a1316 1
vs_link_sg_element(sg_list_element_t *element, vaddr_t phys_add, int len)
d1318 5
a1322 32
	element->count.bytes = len;
	element->addrlo = phys_add;
	element->addrhi = phys_add >> 16;
	element->link = 0; /* FALSE */
	element->transfer_type = NORMAL_TYPE;
	element->memory_type = LONG_TRANSFER;
	element->address_modifier = ADRM_EXT_S_D;
}

void
vs_link_sg_list(sg_list_element_t *list, vaddr_t phys_add, int elements)
{
	list->count.scatter.gather = elements;
	list->addrlo = phys_add;
	list->addrhi = phys_add >> 16;
	list->link = 1;	   /* TRUE */
	list->transfer_type = NORMAL_TYPE;
	list->memory_type = LONG_TRANSFER;
	list->address_modifier = ADRM_EXT_S_D;
}

M328_SG
vs_build_memory_structure(struct vs_softc *sc, struct scsi_xfer *xs,
     bus_addr_t iopb)
{
	M328_SG sg;
	vaddr_t starting_point_virt, starting_point_phys, point_virt,
	point1_phys, point2_phys, virt;
	unsigned int len;
	int level;

	sg = NULL;	/* Hopefully we need no scatter/gather list */
d1325 2
a1326 11
	 * We have the following things:
	 *	virt			va of the virtual memory block
	 *	len			length of the virtual memory block
	 *	starting_point_virt	va of the physical memory block
	 *	starting_point_phys	pa of the physical memory block
	 *	point_virt		va of the virtual memory
	 *				    we are checking at the moment
	 *	point1_phys		pa of the physical memory
	 *				    we are checking at the moment
	 *	point2_phys		pa of another physical memory
	 *				    we are checking at the moment
d1328 5
a1332 5

	level = 0;
	virt = starting_point_virt = (vaddr_t)xs->data;
	point1_phys = starting_point_phys = kvtop((vaddr_t)xs->data);
	len = xs->datalen;
d1335 1
a1335 1
	 * Check if we need scatter/gather
a1336 73
	if (trunc_page(virt + len - 1) != trunc_page(virt)) {
		for (point_virt = round_page(starting_point_virt + 1);
		    /* if we do already scatter/gather we have to stay in the loop and jump */
		    point_virt < virt + len || sg != NULL;
		    point_virt += PAGE_SIZE) {		   /* out later */

			point2_phys = kvtop(point_virt);

			if ((point2_phys != trunc_page(point1_phys) + PAGE_SIZE) ||		   /* physical memory is not contiguous */
			    (point_virt - starting_point_virt >= MAX_SG_BLOCK_SIZE && sg)) {   /* we only can access (1<<16)-1 bytes in scatter/gather_mode */
				if (point_virt - starting_point_virt >= MAX_SG_BLOCK_SIZE) {	       /* We were walking too far for one scatter/gather block ... */
					point_virt = trunc_page(starting_point_virt+MAX_SG_BLOCK_SIZE-1);    /* So go back to the beginning of the last matching page */
					/* and generate the physical address of
					 * this location for the next time. */
					point2_phys = kvtop(point_virt);
				}

				if (sg == NULL)
					sg = vs_alloc_scatter_gather();

#if 1 /* broken firmware */
				if (sg->elements >= MAX_SG_ELEMENTS) {
					vs_dealloc_scatter_gather(sg);
					printf("%s: scatter/gather list too large\n",
					    sc->sc_dev.dv_xname);
					return (NULL);
				}
#else /* if the firmware will ever get fixed */
				while (sg->elements >= MAX_SG_ELEMENTS) {
					if (!sg->up) { /* If the list full in this layer ? */
						sg->up = vs_alloc_scatter_gather();
						sg->up->level = sg->level+1;
						sg->up->down[0] = sg;
						sg->up->elements = 1;
					}
					/* link this full list also in physical memory */
					vs_link_sg_list(&(sg->up->list[sg->up->elements-1]),
							kvtop((vaddr_t)sg->list),
							sg->elements);
					sg = sg->up;	  /* Climb up */
				}
				while (sg->level) {  /* As long as we are not a the base level */
					int i;

					i = sg->elements;
					/* We need a new element */
					sg->down[i] = vs_alloc_scatter_gather();
					sg->down[i]->level = sg->level - 1;
					sg->down[i]->up = sg;
					sg->elements++;
					sg = sg->down[i]; /* Climb down */
				}
#endif /* 1 */
				if (point_virt < virt + len) {
					/* linking element */
					vs_link_sg_element(&(sg->list[sg->elements]),
							   starting_point_phys,
							   point_virt - starting_point_virt);
					sg->elements++;
				} else {
					/* linking last element */
					vs_link_sg_element(&(sg->list[sg->elements]),
							   starting_point_phys,
							   virt + len - starting_point_virt);
					sg->elements++;
					break;			       /* We have now collected all blocks */
				}
				starting_point_virt = point_virt;
				starting_point_phys = point2_phys;
			}
			point1_phys = point2_phys;
		}
	}
d1338 2
a1339 3
	/*
	 * Climb up along the right side of the tree until we reach the top.
	 */
d1341 8
a1348 7
	if (sg != NULL) {
		while (sg->up) {
			/* link this list also in physical memory */
			vs_link_sg_list(&(sg->up->list[sg->up->elements-1]),
					kvtop((vaddr_t)sg->list),
					sg->elements);
			sg = sg->up;		       /* Climb up */
d1350 4
a1353 12

		vs_write(2, iopb + IOPB_OPTION,
		    vs_read(2, iopb + IOPB_OPTION) | M_OPT_SG);
		vs_write(2, iopb + IOPB_ADDR,
		    vs_read(2, iopb + IOPB_ADDR) | M_ADR_SG_LINK);
		vs_write(4, iopb + IOPB_BUFF, kvtop((vaddr_t)sg->list));
		vs_write(4, iopb + IOPB_LENGTH, sg->elements);
		vs_write(4, iopb + IOPB_SGTTL, len);
	} else {
		/* no scatter/gather necessary */
		vs_write(4, iopb + IOPB_BUFF, starting_point_phys);
		vs_write(4, iopb + IOPB_LENGTH, len);
a1354 2
	return sg;
}
d1356 12
a1367 8
static paddr_t
kvtop(vaddr_t va)
{
	paddr_t pa;

	pmap_extract(pmap_kernel(), va, &pa);
	/* XXX check for failure */
	return pa;
@


1.71
log
@Do not print adapter target id on the attachment line, now that scsibus(4)
prints it. These should be the last offenders.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.70 2008/01/05 00:34:07 miod Exp $	*/
d380 5
a384 1
	} else
d386 1
d585 3
d695 1
a695 1
		printf("Jaguar, ");
d722 1
a722 1
		printf("with printer port");
d727 1
a727 1
		printf("with unknown daughterboard id %x", id);
@


1.70
log
@For each channel, tell if it is single-ended or differential if we can know
this. Might help before someone sets his disks on fire. Especially with
boards where not all channels are of the same type.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.69 2008/01/03 22:32:42 miod Exp $	*/
d227 1
a227 1
		printf("%s: channel %d, ", sc->sc_dev.dv_xname, bus);
d230 1
a230 1
			printf("single-ended, ");
d233 1
a233 1
			printf("differential, ");
d236 1
a236 1
		printf("SCSI ID %d\n", vc->vc_id);
@


1.69
log
@Enable wide transfers in the IOPB on wide busses, and get the IOPB passthrough
SCSI commands length correct (it's a length in 16 bit words, not in 8 bit
bytes).
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.68 2008/01/01 22:54:28 miod Exp $	*/
d101 1
d152 1
d202 7
a208 1
	printf("SCSI ID");
d211 2
a212 1
		if (sc->sc_id[bus] < 0)
d215 1
a215 1
		sc_link = &sc->sc_link[bus];
d217 1
a217 1
		sc_link->adapter_buswidth = sc->sc_width[bus];
d219 1
a219 1
		sc_link->adapter_target = sc->sc_id[bus];
d222 1
a222 1
			sc_link->luns = 1;
d227 10
a236 12
		printf("%c%d", bus == 0 ? ' ' : '/', sc->sc_id[bus]);
	}

	printf("\n");

	/*
	 * Attach all scsi units on us, watching for boot device
	 * (see device_register).
	 */
	tmp = bootpart;
	if (sc->sc_paddr != bootaddr)
		bootpart = -1;		/* invalid flag to device_register */
d238 1
a238 5
	for (bus = 0; bus < 2; bus++) {
		if (sc->sc_id[bus] < 0)
			continue;

		if (sc->sc_width[bus] == 0) {
d246 1
a246 1
		saa.saa_sc_link = &sc->sc_link[bus];
d265 2
a266 2
		if (sc->sc_width[1] >= 0)
			printf("(bus %d) ",
d619 35
d693 1
a693 1
			printf("Cougar, ");
d696 1
a696 1
			printf("Cougar II, ");
d699 1
a699 1
			printf("unknown Cougar %02x, ", id);
d706 2
a707 2
	sc->sc_id[0] = csb_read(1, CSB_PID);
	sc->sc_id[1] = -1;
d711 1
a711 4
#if 0
		printf("daughter board, ");
#endif
		sc->sc_id[1] = csb_read(1, CSB_SID);
d714 1
a714 1
		printf("printer port, ");
d719 1
a719 1
		printf("unknown daughterboard id %x, ", id);
d723 2
d755 4
a758 8
		sc->sc_width[0] = csb_read(1, CSB_PFECID) & 0x02 ? 16 : 8;
		targets = sc->sc_width[0] - 1;
		if (sc->sc_id[1] >= 0) {
			sc->sc_width[1] =
			    csb_read(1, CSB_SFECID) & 0x02 ? 16 : 8;
			targets += sc->sc_width[1] - 1;
		} else
			sc->sc_width[1] = 0;
d769 1
a769 1
				sc->sc_width[1] = 0;
d775 1
a775 1
		sc->sc_width[0] = sc->sc_width[1] = 8;
d845 2
a846 2
			    vs_unit_value(i > sc->sc_width[0],
				i - sc->sc_width[0], 0));
d878 1
d882 2
a883 1
		if (sc->sc_id[bus] < 0 || sc->sc_width[bus] == 0)
d886 2
a887 2
		for (target = 0; target < sc->sc_width[bus]; target++) {
			if (target == sc->sc_id[bus])
d1123 1
a1123 1
		q += sc->sc_width[0] - 1;	/* map to 8-14 or 16-30 */
@


1.68
log
@Match on Cougar boards, and try to drive them like Jaguars on steroids. On
wide Cougars, use one command queue per target and disable lun support, so
that we do not overflow the board's memory; and since we are behaving as
a Jaguar, do not do tagged queuing or synchronous transfer negotiation.

Tested on two MVME328XT-2 (4220 and second revision artwork 4220) narrow
Cougar-I (but wide external connectors), but probes fail with select timeout
so far; I could not get various Motorola BUG to probe devices on these boards
either, so we're even (and maybe both my boards are toast, but I won't bet
money on this).
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.67 2008/01/01 17:21:29 miod Exp $	*/
d297 4
d369 4
d465 1
a465 1
		iopb_len = IOPB_SHORT_SIZE + xs->cmdlen;
d498 2
d951 1
d954 1
@


1.67
log
@A potpourri of bugfixes:
- switch back to a fixed queue number allocation, but keep the rotating
  command queue entries. Force openings to 1 because of this.
- make sure to mark the queue as ready before invoking scsi_done(), which
  could trigger a request for the same target.
- allocate a command queue and an IOPB at the same time, instead of using two
  routines and ugly queue pointer arithmetic.

This makes the daughterboard work, as long as the first scsi chain is not
empty.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.66 2007/10/06 02:18:38 krw Exp $	*/
d112 1
d125 1
d129 1
a129 1
	rc = badaddr((vaddr_t)bus_space_vaddr(iot, ioh), 1);
d131 2
a132 1
		if (bus_space_read_2(iot, ioh, sh_CSS + CSB_TYPE) != JAGUAR)
d134 7
d177 1
d208 1
a208 1
		sc_link->adapter_buswidth = 8;
d212 2
a213 3
#if 0
		sc_link->luns = 1;
#endif
d235 7
d262 1
a262 1
		if (sc->sc_id[1] >= 0)
d315 3
d347 1
a347 1
	for (i = 1; i < NUM_WQ; i++)
d362 4
d443 1
a443 1
	 * Note that it has no knowledge of group 2.
d451 5
d461 4
d470 6
a475 1
	  IOPB_UNIT_VALUE(!!(slp->flags & SDEV_2NDBUS), slp->target, slp->lun));
d535 3
d565 1
a565 1
	  IOPB_UNIT_VALUE(!!(slp->flags & SDEV_2NDBUS), slp->target, slp->lun));
d608 2
a609 4
	int i, msr, dbid;

	for (i = 0; i < NUM_WQ; i++)
		sc->sc_cb[i].cb_q = i;
d635 22
d660 1
a660 1
	switch (dbid = csb_read(1, CSB_DBID)) {
d674 59
a732 1
		printf("unknown daughterboard id %x, ", dbid);
d744 2
a745 2
	cib_write(2, CIB_PID, 0x08);	/* XXX default */
	cib_write(2, CIB_SID, 0x08);
d777 8
a784 1
	for (i = 1; i < NUM_WQ; i++) {
d797 2
a798 1
		mce_iopb_write(2, WQCF_SLOTS, JAGUAR_MAX_Q_SIZ);
d800 4
d838 1
a838 1
		if (sc->sc_id[bus] < 0)
d841 1
a841 1
		for (target = 0; target < 8; target++) {
d856 1
a856 1
			    IOPB_UNIT_VALUE(bus, target, 0));
d954 4
a957 1
	if (cb != NULL)
d959 6
d995 4
d1068 3
a1070 3
	 * Map the target number (0-7) to the 1-7 range, target 0 picks
	 * the host adapter target number (since host adapter commands
	 * are issued on queue #0).
d1076 1
a1076 1
		q += 7;		/* map to queues 8-14 */
d1082 24
@


1.66
log
@Oops. Forgot to do FREE -> free when I did MALLOC -> malloc.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.65 2007/10/03 10:52:11 krw Exp $	*/
d100 1
a100 2
bus_addr_t vs_getcqe(struct vs_softc *);
bus_addr_t vs_getiopb(struct vs_softc *);
d113 1
a113 1
static __inline__ void vs_free(struct vs_cb *);
d128 4
d204 1
a204 1
		sc_link->openings = NUM_IOPB / 8;
d298 1
a298 1
#if 0
a299 2
#endif
		vs_free(cb);
d353 1
a353 2
	thaw_queue(sc, cb->cb_q);

a354 2

	vs_free(cb);
d397 2
a398 1
			printf("%s: no free queues\n", sc->sc_dev.dv_xname);
d402 2
a403 2
		cqep = vs_getcqe(sc);
		if (cqep == 0) {
d405 3
a409 1
		iopb = vs_getiopb(sc);
d539 2
a540 2
bus_addr_t
vs_getcqe(struct vs_softc *sc)
d542 1
a542 1
	bus_addr_t cqep;
d546 2
a547 1
	cqep = sh_CQE(qhdp);
d549 3
a551 3
	if (vs_read(2, cqep + CQE_QECR) & M_QECR_GO) {
		/* should never happen */
		return 0;
d558 4
a561 20
	vs_bzero(cqep, CQE_SIZE);
	return cqep;
}

bus_addr_t
vs_getiopb(struct vs_softc *sc)
{
	bus_addr_t iopb;
	int qhdp;

	/*
	 * Since we are always invoked after vs_getcqe(), qhdp has already
	 * been incremented...
	 */
	qhdp = mcsb_read(2, MCSB_QHDP);
	if (--qhdp < 0)
		qhdp = NUM_CQE - 1;

	iopb = sh_IOPB(qhdp);
	return iopb;
d789 1
a789 1
/* free a cb; invoked at splbio */
d791 1
a791 1
vs_free(struct vs_cb *cb)
d793 2
a920 1
	static u_int last = 0;
d923 10
a932 6
	q = last;
	for (;;) {
		if (++q == NUM_WQ)
			q = 1;
		if (q == last)
			break;
d934 2
a935 5
		if ((cb = &sc->sc_cb[q])->cb_xs == NULL) {
			last = q;
			return (cb);
		}
	}
@


1.65
log
@MALLOC+bzero -> malloc+M_ZERO.

In ip_esp.c all allocated memory is now zero'd in the
"malloc(sizeof(*tc) + alen ..." case. The +alen memory was not
initialized by the bzero() call. Noticed by chl@@.

"Looks good" art@@ "seems ok" chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.64 2006/12/01 19:36:09 miod Exp $	*/
d976 1
a976 1
	FREE(sg, M_DEVBUF);
@


1.64
log
@Unbreak.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.63 2006/11/28 23:59:45 dlg Exp $	*/
d961 1
a961 2
	MALLOC(sg, M328_SG, sizeof(struct m328_sg), M_DEVBUF, M_WAITOK);
	bzero(sg, sizeof(struct m328_sg));
@


1.63
log
@give scsi controllers a real attach args to fill in when attaching scsibus.

ok miod@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.62 2006/05/08 14:36:10 miod Exp $	*/
d140 1
@


1.62
log
@Replace gazillions of badvaddr() or badwordaddr() calls with badaddr() calls.
With a few prototype declarations shuffling, this finally allows
<machine/locore.h> to die.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.61 2006/03/15 20:20:40 miod Exp $	*/
d221 3
d225 1
a225 1
		config_found(self, &sc->sc_link[bus], scsiprint);
@


1.61
log
@Nuke dk_establish(), no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.60 2005/12/27 22:48:01 miod Exp $	*/
d59 1
a59 1
#include <machine/param.h>
d128 1
a128 1
	rc = badvaddr((vaddr_t)bus_space_vaddr(iot, ioh), 1);
@


1.60
log
@Remove the 1:1 association between SCSI targets and work queues, but use a
cyclic search of the first unused work queue.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.59 2005/12/27 22:45:28 miod Exp $	*/
d211 1
a211 1
	 * (see dk_establish).
d215 1
a215 1
		bootpart = -1;		/* invalid flag to dk_establish */
@


1.59
log
@Fail existing command upon bus reset.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.58 2005/12/27 22:05:27 miod Exp $	*/
a99 1
void	vs_free(struct vs_cb *);
d109 1
a109 1
int	vs_queue_number(struct scsi_link *, struct vs_softc *);
d112 1
a112 1
void	vs_scsidone(struct vs_softc *, struct scsi_xfer *);
d114 1
d277 1
a277 1
vs_poll(struct vs_softc *sc, struct vs_cb *cmd)
d280 1
d283 1
a283 1
	xs = cmd->cb_xs;
a284 1
	vs_free(cmd);
d286 1
d294 1
d296 2
a297 1
		vs_scsidone(sc, xs);
d327 1
a327 1
vs_scsidone(struct vs_softc *sc, struct scsi_xfer *xs)
d329 1
a331 1
	int tgt;
a342 1
	tgt = vs_queue_number(xs->sc_link, sc);
a344 1
		thaw_queue(sc, tgt);
d348 1
a348 1
	thaw_queue(sc, tgt);
d351 2
d365 1
a367 6

	queue = flags & SCSI_POLL ? 0 : vs_queue_number(slp, sc);
	cb = &sc->sc_cb[queue];
	if (cb->cb_xs != NULL)
		return (TRY_AGAIN_LATER);

d369 1
d373 5
d381 8
d390 9
d401 1
d407 2
d462 2
d579 3
d799 2
a800 1
void
a815 1
	struct scsi_xfer *xs;
d831 2
a832 6
	if (cb != NULL) {
		xs = cb->cb_xs;
		vs_free(cb);

		vs_scsidone(sc, xs);
	}
d921 3
a923 8
 * Choose the work queue number for a specific target.
 *
 * Targets on the primary channel are mapped to queues 1-7, while targets
 * on the secondary channel are mapped to queues 8-14.
 * To do so, we assign each target the queue matching its own number,
 * plus eight on the secondary bus, except for target 0 on the first channel
 * and 7 on the secondary channel which gets assigned to the queue matching
 * the controller id.
d925 2
a926 2
int
vs_queue_number(struct scsi_link *sl, struct vs_softc *sc)
d928 3
a930 1
	int bus, target;
d932 6
a937 2
	bus = !!(sl->flags & SDEV_2NDBUS);
	target = sl->target;
d939 5
a943 5
	if (target == sc->sc_id[bus])
		return 0;

	if (target > sc->sc_id[bus])
		target--;
d945 1
a945 1
	return (bus == 0 ? 1 : 8) + target;
@


1.58
log
@Better initialize local variables before they are used, even if the compiler
did not notice.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.57 2005/12/27 21:38:13 miod Exp $	*/
a837 7
	if (crsw & M_CRSW_RST) {
		printf("%s: bus reset\n", sc->sc_dev.dv_xname);
		vs_clear_return_info(sc);
		splx(s);
		return 1;
	}

d840 29
a868 25
	switch (ecode) {
	case CEVSB_ERR_TYPE:
		printf("IOPB type error\n");
		break;
	case CEVSB_ERR_TO:
		printf("timeout\n");
		break;
	case CEVSB_ERR_TR:
		printf("reconnect error\n");
		break;
	case CEVSB_ERR_OF:
		printf("overflow\n");
		break;
	case CEVSB_ERR_BD:
		printf("bad direction\n");
		break;
	case CEVSB_ERR_NR:
		printf("non-recoverable error\n");
		break;
	case CEVSB_ERR_PANIC:
		printf("board panic\n");
		break;
	default:
		printf("unexpected error %x\n", ecode);
		break;
@


1.57
log
@Keep an array of command blocks (formerly M328_CMD), one per queue - since
we can't send more commands simultaneously - instead of using MALLOC/FREE
for every scsi command we send.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.56 2005/12/03 18:09:37 krw Exp $	*/
d363 2
a369 1
	flags = xs->flags;
@


1.56
log
@The first thing done when XXX_scsi_cmd() returns TRY_AGAIN_LATER is
to set xs->error to XS_BUSY. So it is pointless and misleading to
set xs->error to XS_TIMEOUT, XS_DRIVER_STUFFUP or XS_BUSY just before
returning TRY_AGAIN_LATER.

No functional change.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.55 2005/04/27 14:09:45 miod Exp $	*/
d100 1
a100 1
void	vs_free(M328_CMD *);
d108 1
a108 1
int	vs_poll(struct vs_softc *, M328_CMD *);
d277 1
a277 1
vs_poll(struct vs_softc *sc, M328_CMD *cmd)
d282 1
a282 1
	xs = cmd->xs;
d360 7
a366 1
	M328_CMD *m328_cmd;
d434 1
a434 4
	vs_write(1, cqep + CQE_WORK_QUEUE,
	    flags & SCSI_POLL ? 0 : vs_queue_number(slp, sc));

	MALLOC(m328_cmd, M328_CMD*, sizeof(M328_CMD), M_DEVBUF, M_WAITOK);
d436 1
a436 1
	m328_cmd->xs = xs;
d438 1
a438 1
		m328_cmd->top_sg_list = vs_build_memory_structure(sc, xs, iopb);
d440 1
a440 1
		m328_cmd->top_sg_list = NULL;
d442 1
a442 1
	vs_write(4, cqep + CQE_CTAG, (u_int32_t)m328_cmd);
d451 1
a451 1
		return vs_poll(sc, m328_cmd);
d770 1
a770 1
vs_free(M328_CMD *m328_cmd)
d772 3
a774 3
	if (m328_cmd->top_sg_list != NULL) {
		vs_dealloc_scatter_gather(m328_cmd->top_sg_list);
		m328_cmd->top_sg_list = (M328_SG)NULL;
d776 1
a776 1
	FREE(m328_cmd, M_DEVBUF); /* free the command tag */
d784 1
a784 1
	M328_CMD *m328_cmd;
d793 1
a793 1
	m328_cmd = (void *)crb_read(4, CRB_CTAG);
d796 1
a796 1
	 * If this is a controller error, there won't be a m328_cmd
d801 3
a803 3
	if (m328_cmd != NULL) {
		xs = m328_cmd->xs;
		vs_free(m328_cmd);
d824 1
a824 1
	M328_CMD *m328_cmd;
d834 2
a835 2
	m328_cmd = (void *)crb_read(4, CRB_CTAG);
	xs = m328_cmd != NULL ? m328_cmd->xs : NULL;
@


1.55
log
@Allow userland to cause the data cache to be flushed for any arbitrary address
range in the current process, using trap #451.

This is necessary for proper gcc trampolines operation, and, later, ld.so...
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.54 2005/04/27 14:07:38 miod Exp $	*/
a372 1
			xs->error = XS_DRIVER_STUFFUP;
@


1.54
log
@Always include <uvm/uvm_extern.h> before <machine/cmmu.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.53 2004/09/06 06:25:28 miod Exp $	*/
d411 1
a411 1
	dma_cachectl((vaddr_t)xs->data, xs->datalen,
@


1.53
log
@Jumbo pack of fixes:
- do not leak memory when polling;
- bring LUN support back - Motorola documentation says LUNs are not
  supported, but it's a SysV/m88k limitation, not a hardware one.
- honour request timeout while polling (instead of using a fixed value)
- do not program the scsi command length if the hardware knows it from
  the scsi command group (as advised in the manual)
- various minor fixes, especially better error recovery.

tested by nick@@ and I; ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.52 2004/07/30 19:02:06 miod Exp $	*/
d52 1
a52 1
#include <uvm/uvm.h>
d58 1
a63 1
#include <machine/cmmu.h>
@


1.52
log
@Move evcount structures inside struct intrhand, this makes more sense and
gives us more counters in the process.

Also clean up intrhand structures and usage, especially move them to SLISTs.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.51 2004/07/20 23:07:06 miod Exp $	*/
d91 1
a91 1
int	do_vspoll(struct vs_softc *, struct scsi_xfer *, int, int);
a96 1
int	vs_checkintr(struct vs_softc *, struct scsi_xfer *, int *);
d100 1
d108 2
a109 1
int	vs_poll(struct vs_softc *, struct scsi_xfer *);
d113 1
a113 1
void	vs_scsidone(struct vs_softc *, struct scsi_xfer *, int);
d197 1
d199 1
d229 15
d245 1
a245 1
do_vspoll(struct vs_softc *sc, struct scsi_xfer *xs, int to, int canreset)
d247 1
a247 1
	int i;
d250 1
a250 1
	if (xs != NULL)
d252 4
a255 1
	else
d257 2
a258 5

	/* XXX use cmd_wait values */
	if (to <= 0)
		to = 50000;
	i = 10000;
d261 7
a267 14
		if (--i <= 0) {
			i = 50000;
			--to;
			if (to <= 0) {
				if (canreset) {
					vs_reset(sc, bus);
					vs_resync(sc);
				}
				if (xs == NULL)
					printf("%s: ", sc->sc_dev.dv_xname);
				else
					sc_print_addr(xs->sc_link);
				printf("timeout %d crsw 0x%x\n", to, crsw);
				return 1;
d269 1
d271 1
d277 1
a277 1
vs_poll(struct vs_softc *sc, struct scsi_xfer *xs)
d279 2
a280 2
	int status;
	int to;
d282 3
a284 14
	to = xs->timeout / 1000;
	for (;;) {
		if (do_vspoll(sc, xs, to, 1)) {
			xs->error = XS_SELTIMEOUT;
			xs->status = -1;
			xs->flags |= ITSDONE;
			vs_clear_return_info(sc);
			if (xs->flags & SCSI_POLL)
				return (COMPLETE);
			break;
		}
		if (vs_checkintr(sc, xs, &status)) {
			vs_scsidone(sc, xs, status);
		}
d286 9
a294 3
		if (CRSW & M_CRSW_ER)
			CRB_CLR_ER;
		CRB_CLR_DONE;
d296 3
a298 3
		if (xs->flags & ITSDONE)
			break;
	}
d319 1
a319 1
	for (i = 1; i < NUM_WQ ; i++)
d324 1
a324 1
vs_scsidone(struct vs_softc *sc, struct scsi_xfer *xs, int stat)
d326 2
d330 10
a340 2
	xs->status = stat;

d366 4
d381 16
a396 1
	iopb_len = IOPB_SHORT_SIZE + xs->cmdlen;
a426 8
	/*
	 * Wait until we can use the command queue entry.
	 * Should only have to wait if the master command
	 * queue entry is busy and we are polling.
	 */
	while (vs_read(2, cqep + CQE_QECR) & M_QECR_GO)
		;

d449 1
a449 1
		return vs_poll(sc, xs);
d469 4
d494 1
a494 2
	mce_write(1, CQE_IOPB_LENGTH,
	    IOPB_SHORT_SIZE + sizeof(struct scsi_sense));
d500 1
a500 1
	do_vspoll(sc, xs, 0, 1);
d628 1
a628 1
	mce_write(1, CQE_IOPB_LENGTH, IOPB_LONG_SIZE);
d633 1
a633 1
	do_vspoll(sc, NULL, 0, 1);
d637 4
d654 1
a654 1
		mce_write(1, CQE_IOPB_LENGTH, IOPB_LONG_SIZE);
d659 6
a664 3
		do_vspoll(sc, NULL, 0, 1);
		if (CRSW & M_CRSW_ER)
			CRB_CLR_ER;
a665 3
#if 0
		delay(500);
#endif
a670 9
	do_vspoll(sc, NULL, 0, 1);
	if (CRSW & M_CRSW_ER) {
		printf("initialization error, status = 0x%x\n",
		    vs_read(2, sh_RET_IOPB + IOPB_STATUS));
		CRB_CLR_DONE;
		return 1;
	}
	CRB_CLR_DONE;

d692 4
d707 1
a707 1
			mce_write(1, CQE_IOPB_LENGTH, IOPB_SHORT_SIZE);
d712 1
a712 1
			do_vspoll(sc, NULL, 0, 0);
d731 4
d745 1
a745 1
		mce_write(1, CQE_IOPB_LENGTH, IOPB_SHORT_SIZE);
d751 1
a751 1
			do_vspoll(sc, NULL, 0, 0);
d767 2
a768 7
/*
 * Process an interrupt from the MVME328
 * We'll generally update: xs->{flags,resid,error,sense,status} and
 * occasionally xs->retries.
 */
int
vs_checkintr(struct vs_softc *sc, struct scsi_xfer *xs, int *status)
d770 3
a772 13
	u_int32_t len;
	int error;

	len = vs_read(4, sh_RET_IOPB + IOPB_LENGTH);
	error = vs_read(2, sh_RET_IOPB + IOPB_STATUS);
	*status = error >> 8;

	xs->resid = xs->datalen - len;

	if ((error & 0xff) == SCSI_SELECTION_TO) {
		xs->error = XS_SELTIMEOUT;
		xs->status = -1;
		*status = -1;
d774 1
a774 2

	return 1;
a783 1
	int status;
d801 1
a801 5
		if (m328_cmd->top_sg_list != NULL) {
			vs_dealloc_scatter_gather(m328_cmd->top_sg_list);
			m328_cmd->top_sg_list = (M328_SG)NULL;
		}
		FREE(m328_cmd, M_DEVBUF); /* free the command tag */
d803 1
a803 3
		if (vs_checkintr(sc, xs, &status)) {
			vs_scsidone(sc, xs, status);
		}
d842 1
a842 4
	if (xs == NULL)
		printf("%s: ", sc->sc_dev.dv_xname);
	else
		sc_print_addr(xs->sc_link);
a849 6
		if (xs != NULL) {
			xs->error = XS_SELTIMEOUT;
			xs->status = -1;
			xs->flags |= ITSDONE;
			scsi_done(xs);
		}
d871 7
d908 1
a908 1
	int bus;
d911 1
d913 1
a913 1
	if (sl->target == sc->sc_id[bus])
d916 4
a919 7
	if (bus == 0)
		return sl->target == 0 ? sc->sc_id[bus] : sl->target;
	else
		if (sl->target > sc->sc_id[bus])
			return 8 + sl->target - 1;
		else
			return 8 + sl->target;
@


1.51
log
@Forgot to put this chunk in.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.50 2004/07/20 20:33:18 miod Exp $	*/
a50 1
#include <sys/evcount.h>
d179 1
a179 5
	vmeintr_establish(sc->sc_nvec, &sc->sc_ih_n);
	vmeintr_establish(sc->sc_evec, &sc->sc_ih_e);

	evcount_attach(&sc->sc_intrcnt_n, self->dv_xname,
	    (void *)&sc->sc_ih_n.ih_ipl, &evcount_intr);
d182 1
a182 2
	evcount_attach(&sc->sc_intrcnt_e, sc->sc_intrname_e,
	    (void *)&sc->sc_ih_e.ih_ipl, &evcount_intr);
a772 1
	sc->sc_intrcnt_n.ec_count++;
a816 1
	sc->sc_intrcnt_e.ec_count++;
@


1.50
log
@Let the boot device detection code handle secondary SCSI buses.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.49 2004/07/20 20:32:02 miod Exp $	*/
d650 2
a651 2
	/* reset SCSI bus */
	vs_reset(sc);
d654 1
a654 1
	printf("SCSI ID %d\n", sc->sc_pid);
d661 40
a700 1
	int i;
d702 2
a703 2
	for (i = 0; i < 8; i++) {
		if (i == sc->sc_pid)
d707 6
a712 6
		mce_iopb_write(2, DRCF_CMD, CNTR_DEV_REINIT);
		mce_iopb_write(2, DRCF_OPTION, 0); /* no interrupts yet */
		mce_iopb_write(1, DRCF_NVCT, sc->sc_nvec);
		mce_iopb_write(1, DRCF_EVCT, sc->sc_evec);
		mce_iopb_write(2, DRCF_ILVL, 0);
		mce_iopb_write(2, DRCF_UNIT, IOPB_UNIT_VALUE(i, 0));
d721 8
a728 33
		do_vspoll(sc, 0, 0);
		if (CRSW & M_CRSW_ER)
			CRB_CLR_ER;
		CRB_CLR_DONE;
	}
}

void
vs_reset(struct vs_softc *sc)
{
	int s;

	s = splbio();

	vs_bzero(sh_MCE_IOPB, IOPB_SHORT_SIZE);
	mce_iopb_write(2, SRCF_CMD, IOPB_RESET);
	mce_iopb_write(2, SRCF_OPTION, 0);	/* not interrupts yet... */
	mce_iopb_write(1, SRCF_NVCT, sc->sc_nvec);
	mce_iopb_write(1, SRCF_EVCT, sc->sc_evec);
	mce_iopb_write(2, SRCF_ILVL, 0);
	mce_iopb_write(2, SRCF_BUSID, 0);

	vs_bzero(sh_MCE, CQE_SIZE);
	mce_write(2, CQE_IOPB_ADDR, sh_MCE_IOPB);
	mce_write(1, CQE_IOPB_LENGTH, IOPB_SHORT_SIZE);
	mce_write(1, CQE_WORK_QUEUE, 0);
	mce_write(2, CQE_QECR, M_QECR_GO);

	/* poll for the command to complete */
	for (;;) {
		do_vspoll(sc, NULL, 0, 0);
		/* ack & clear scsi error condition cause by reset */
		if (CRSW & M_CRSW_ER) {
a729 2
			vs_write(2, sh_RET_IOPB + IOPB_STATUS, 0);
			break;
a730 1
		CRB_CLR_DONE;
@


1.49
log
@Work in progress to support daughterboards. The driver now will attach a
second scsi bus if a SCSI daughterboard is present, and is supposed to know
about this and send scsi commands to the appropriate bus.

Unfortunately probing the second bus does not report any device at the
moment (though you can boot off it), but I can't see the issue at the moment.

Thanks to tdeval@@ for lending a few boards equipped with daughterboards
for testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.48 2004/07/20 20:28:54 miod Exp $	*/
d224 1
d228 2
a229 1
	bootpart = tmp;		    /* restore old value */
@


1.48
log
@Use sc_print_addr for error messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.47 2004/07/19 20:35:37 miod Exp $	*/
d110 2
a111 1
void	vs_reset(struct vs_softc *);
a115 1
static __inline__ int vs_queue_number(int, int);
d139 2
a140 1
	int evec;
a169 7
	sc->sc_link.adapter_softc = sc;
	sc->sc_link.adapter_target = sc->sc_pid;
	sc->sc_link.adapter = &vs_scsiswitch;
	sc->sc_link.device = &vs_scsidev;
	sc->sc_link.luns = 1;
	sc->sc_link.openings = NUM_IOPB / 8;

d190 22
d213 1
a213 1
	 * attach all scsi units on us, watching for boot device
d219 8
a226 1
	config_found(self, &sc->sc_link, scsiprint);
d234 1
a234 1
	int crsw;
d236 8
a243 2
	if (to <= 0 ) to = 50000;
	/* use cmd_wait values? */
d252 1
a252 1
					vs_reset(sc);
d315 1
a315 1
	for (i = 1; i <= 7; i++)
d323 2
a328 1
		tgt = vs_queue_number(xs->sc_link->target, sc->sc_pid);
a331 1
	tgt = vs_queue_number(xs->sc_link->target, sc->sc_pid);
d333 1
a334 1
	thaw_queue(sc, tgt);
d368 2
a369 1
	vs_write(2, iopb + IOPB_UNIT, IOPB_UNIT_VALUE(slp->target, slp->lun));
d405 1
a405 1
	    flags & SCSI_POLL ? 0 : vs_queue_number(slp->target, sc->sc_pid));
d460 2
a461 1
	mce_iopb_write(2, IOPB_UNIT, IOPB_UNIT_VALUE(slp->target, slp->lun));
d547 2
a548 2
	sc->sc_pid = csb_read(1, CSB_PID);
	sc->sc_sid = -1;
d552 1
d554 2
a555 1
		sc->sc_sid = csb_read(1, CSB_SID);
d575 2
a576 2
	cib_write(2, CIB_PID, sc->sc_pid);
	cib_write(2, CIB_SID, 0);	/* disable second channel */
d608 1
a608 1
	for (i = 1; i < 8; i++) {
d883 6
a888 3
 * Targets on the primary channel should be mapped to queues 1-7,
 * so we assign each target the queue matching its own number, except for
 * target zero which gets assigned to the queue matching the controller id.
d890 2
a891 2
static int
vs_queue_number(int target, int host)
d893 14
a906 1
	return target == 0 ? host : target;
@


1.47
log
@Recognize the daughter board type, if any - but it is not supported yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.46 2004/07/19 20:34:59 miod Exp $	*/
d92 1
a92 1
int	do_vspoll(struct vs_softc *, int, int);
d208 1
a208 1
do_vspoll(struct vs_softc *sc, int to, int canreset)
d226 5
a230 2
				printf("%s: timeout %d crsw 0x%x\n",
				    sc->sc_dev.dv_xname, to, crsw);
d246 1
a246 1
		if (do_vspoll(sc, to, 1)) {
d441 1
a441 1
	do_vspoll(sc, 0, 1);
d572 1
a572 1
	do_vspoll(sc, 0, 1);
d594 1
a594 1
		do_vspoll(sc, 0, 1);
d606 1
a606 1
	do_vspoll(sc, 0, 1);
d677 1
a677 1
		do_vspoll(sc, 0, 0);
d794 2
a795 4
	else {
		printf("%s(target %d): ",
		    sc->sc_dev.dv_xname, xs->sc_link->target);
	}
@


1.46
log
@After a work queue has been aborted and the abort has been acknowledged,
do not keep setting the A.A. bit in further queue control operations, as
advised by the manual.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.45 2004/07/19 20:32:47 miod Exp $	*/
d486 1
a486 1
	int i, msr;
d514 16
a529 1
	sc->sc_sid = csb_read(1, CSB_SID);
@


1.45
log
@When we want to thaw all work queues we care about, do it correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.44 2004/07/19 20:31:51 miod Exp $	*/
d385 3
a387 3
		vs_write(2, cqep + CQE_QECR, M_QECR_AA);

	vs_write(2, cqep + CQE_QECR, vs_read(2, cqep + CQE_QECR) | M_QECR_GO);
@


1.44
log
@Direct REQUEST_SENSE commands to the correct target, instead of always
target zero. This makes targets other than zero working now...

Spotted by nick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.43 2004/07/18 19:45:51 miod Exp $	*/
d94 1
d279 9
a301 1
	/* thaw all work queues */
d669 1
a669 2
	/* thaw all work queues */
	thaw_queue(sc, 0xff);
d818 1
a818 1
	thaw_queue(sc, 0xff);
@


1.43
log
@Typos
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.42 2004/07/02 14:00:43 miod Exp $	*/
d327 1
a327 1
	vs_write(2, iopb + IOPB_UNIT, (slp->lun << 3) | slp->target);
d418 1
d611 1
a611 1
		mce_iopb_write(2, DRCF_UNIT, i);
@


1.42
log
@Switch mvme88k to evcount, but keep maintaining intrcnt[] too for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.41 2004/06/10 16:05:22 miod Exp $	*/
d797 1
a797 1
	case CESVB_ERR_PANIC:
@


1.41
log
@Fix a logic error in sglist creation.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.40 2004/05/23 20:52:16 miod Exp $	*/
d51 1
d187 7
a193 2
	evcnt_attach(&sc->sc_dev, "intr", &sc->sc_intrcnt_n);
	evcnt_attach(&sc->sc_dev, "intr", &sc->sc_intrcnt_e);
d706 1
a706 1
	sc->sc_intrcnt_n.ev_count++;
d751 1
a751 1
	sc->sc_intrcnt_e.ev_count++;
@


1.40
log
@Nuke kvtop(), preserving a private copy in mvme88k vs(4) for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.39 2004/05/22 21:02:38 miod Exp $	*/
d915 2
a916 2
	if (len > PAGE_SIZE) {
		for (level = 0, point_virt = round_page(starting_point_virt+1);
d918 2
a919 2
		    point_virt < virt + (vaddr_t)len || sg ;
		    point_virt += PAGE_SIZE) {			   /* out later */
d923 1
a923 1
			if ((point2_phys - trunc_page(point1_phys) - PAGE_SIZE) ||		   /* physical memory is not contiguous */
d938 2
d968 1
a968 1
				if (point_virt < virt+(vaddr_t)len) {
d972 1
a972 1
							   point_virt-starting_point_virt);
d978 1
a978 1
							   (vaddr_t)(virt+len)-starting_point_virt);
@


1.39
log
@Reset the board during probe. As a result, we can now honor the SCSI
controller ID jumpers, instead of reprogramming the board to 7 every time.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.38 2004/05/22 19:34:12 miod Exp $	*/
d52 1
a52 1
#include <uvm/uvm_param.h>
d114 1
d1013 10
@


1.38
log
@Convert to bus_space; but it still uses kvtop()...
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.34 2004/05/09 05:34:00 krw Exp $	*/
d113 1
d149 1
a149 1
	printf(" vec 0x%x", evec);
d155 1
a155 1
		printf(": can't map registers!\n");
d162 4
d167 1
a167 1
	sc->sc_link.adapter_target = 7;
a182 3
	if (vs_initialize(sc))
		return;

d278 1
a278 1
		tgt = xs->sc_link->target + 1;
d282 1
a282 1
	tgt = xs->sc_link->target + 1;
d356 1
a356 1
	    flags & SCSI_POLL ? 0 : slp->target + 1);
d469 29
a497 1
	int i;
d507 2
a508 2
	cib_write(2, CIB_PID, 7);
	cib_write(2, CIB_SID, 0);
d584 1
a584 1
	printf(": SCSI ID %d\n", sc->sc_link.adapter_target);
d593 4
a596 1
	for (i = 0; i < 7; i++) {
d813 13
@


1.37
log
@More cleaning, better registers programming, better error messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.36 2004/05/20 21:16:48 miod Exp $ */
d4 1
d38 1
a38 1
 * MVME328S scsi adaptor driver
d94 2
a95 1
M328_SG	vs_build_memory_structure(struct scsi_xfer *, M328_IOPB *);
d100 2
a101 2
M328_CQE *vs_getcqe(struct vs_softc *);
M328_IOPB *vs_getiopb(struct vs_softc *);
d115 1
a115 3
vsmatch(pdp, vcf, args)
	struct device *pdp;
	void *vcf, *args;
d122 1
a122 1
	if (bus_space_map(iot, ca->ca_paddr, PAGE_SIZE, 0, &ioh) != 0)
d125 1
a125 1
	bus_space_unmap(iot, ioh, PAGE_SIZE);
d131 1
a131 3
vsattach(parent, self, args)
	struct device *parent, *self;
	void *args;
a136 2
	bus_space_tag_t iot = ca->ca_iot;
	bus_space_handle_t ioh;
d148 6
a153 1
	if (bus_space_map(iot, ca->ca_paddr, PAGE_SIZE, 0, &ioh) != 0) {
a157 4
	printf(" vec 0x%x", evec);

	sc->sc_vsreg = (void *)bus_space_vaddr(iot, ioh);

d191 1
a191 1
	if (ca->ca_paddr != bootaddr)
d198 1
a198 4
do_vspoll(sc, to, canreset)
	struct vs_softc *sc;
	int to;
	int canreset;
d201 2
d207 1
a207 1
	while (!(CRSW & (M_CRSW_CRBV | M_CRSW_CC))) {
d216 2
a217 1
				printf ("timed out: timeout %d crsw 0x%x\n", to, CRSW);
d226 1
a226 3
vs_poll(sc, xs)
	struct vs_softc *sc;
	struct scsi_xfer *xs;
d259 1
a259 3
thaw_queue(sc, target)
	struct vs_softc *sc;
	int target;
d269 1
a269 4
vs_scsidone(sc, xs, stat)
	struct vs_softc *sc;
	struct scsi_xfer *xs;
	int stat;
d289 1
a289 2
vs_scsicmd(xs)
	struct scsi_xfer *xs;
d295 1
a295 5
	M328_CQE *mc = (M328_CQE*)&sc->sc_vsreg->sh_MCE;
	M328_CRB *crb = (M328_CRB *)&sc->sc_vsreg->sh_CRB;
	M328_IOPB *miopb = (M328_IOPB *)&sc->sc_vsreg->sh_MCE_IOPB;
	M328_CQE *cqep;
	M328_IOPB *iopb;
d300 2
a301 2
		cqep = mc;
		iopb = miopb;
d304 1
a304 1
		if (cqep == NULL) {
d311 1
a311 1
	d16_bzero(iopb, sizeof(M328_IOPB));
d313 8
a320 6
	iopb_len = sizeof(M328_short_IOPB) + xs->cmdlen;
	d16_bcopy(xs->cmd, &iopb->iopb_SCSI[0], xs->cmdlen);
	iopb->iopb_CMD = IOPB_SCSI;
	iopb->iopb_UNIT = (slp->lun << 3) | slp->target;
	iopb->iopb_NVCT = (u_char)sc->sc_nvec;
	iopb->iopb_EVCT = (u_char)sc->sc_evec;
d329 1
a329 1

a330 2
	if (flags & SCSI_DATA_IN)
		option |= OPT_READ;
d332 1
a332 1
		option |= OPT_WRITE;
d335 2
a336 2
		iopb->iopb_OPTION = option | OPT_INTDIS;
		iopb->iopb_LEVEL = 0;
d338 2
a339 2
		iopb->iopb_OPTION = option | OPT_INTEN;
		iopb->iopb_LEVEL = sc->sc_ipl;
d341 1
a341 1
	iopb->iopb_ADDR = ADDR_MOD;
d348 2
a349 1
	while (cqep->cqe_QECR & M_QECR_GO);
d351 4
a354 3
	cqep->cqe_IOPB_ADDR = OFF(iopb);
	cqep->cqe_IOPB_LENGTH = iopb_len;
	cqep->cqe_WORK_QUEUE = flags & SCSI_POLL ? 0 : slp->target + 1;
d360 1
a360 1
		m328_cmd->top_sg_list = vs_build_memory_structure(xs, iopb);
d364 1
a364 1
	LV(cqep->cqe_CTAG, m328_cmd);
d366 4
a369 4
	if (crb->crb_CRSW & M_CRSW_AQ) {
		cqep->cqe_QECR = M_QECR_AA;
	}
	cqep->cqe_QECR |= M_QECR_GO;
d380 1
a380 2
vs_chksense(xs)
	struct scsi_xfer *xs;
a385 3
	M328_CQE *mc = (M328_CQE*)&sc->sc_vsreg->sh_MCE;
	M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
	M328_IOPB *miopb = (M328_IOPB *)&sc->sc_vsreg->sh_MCE_IOPB;
d393 1
a393 1
	d16_bzero(miopb, sizeof(M328_IOPB));
d395 2
a396 2
	ss = (void *)&miopb->iopb_SCSI[0];
	d16_bzero(ss, sizeof(*ss));
d401 15
a415 15
	miopb->iopb_CMD = IOPB_SCSI;
	miopb->iopb_OPTION = OPT_READ;
	miopb->iopb_NVCT = (u_char)sc->sc_nvec;
	miopb->iopb_EVCT = (u_char)sc->sc_evec;
	miopb->iopb_LEVEL = 0; /*sc->sc_ipl;*/
	miopb->iopb_ADDR = ADDR_MOD;
	LV(miopb->iopb_BUFF, kvtop((vaddr_t)&xs->sense));
	LV(miopb->iopb_LENGTH, sizeof(struct scsi_sense_data));

	d16_bzero(mc, sizeof(M328_CQE));
	mc->cqe_IOPB_ADDR = OFF(miopb);
	mc->cqe_IOPB_LENGTH = sizeof(M328_short_IOPB) +
			      sizeof(struct scsi_sense);
	mc->cqe_WORK_QUEUE = 0;
	mc->cqe_QECR = M_QECR_GO;
d420 1
a420 1
	xs->status = riopb->iopb_STATUS >> 8;
d424 2
a425 3
M328_CQE *
vs_getcqe(sc)
	struct vs_softc *sc;
d427 1
a427 2
	M328_MCSB *mcsb = (M328_MCSB *)&sc->sc_vsreg->sh_MCSB;
	M328_CQE *cqep;
d430 2
a431 2
	qhdp = mcsb->mcsb_QHDP;
	cqep = (M328_CQE *)&sc->sc_vsreg->sh_CQE[qhdp];
d433 1
a433 1
	if (cqep->cqe_QECR & M_QECR_GO) {
d435 1
a435 1
		return NULL;
d440 1
a440 1
	mcsb->mcsb_QHDP = qhdp;
d442 1
a442 1
	d16_bzero(cqep, sizeof(M328_CQE));
d446 2
a447 3
M328_IOPB *
vs_getiopb(sc)
	struct vs_softc *sc;
d449 1
a449 2
	M328_MCSB *mcsb = (M328_MCSB *)&sc->sc_vsreg->sh_MCSB;
	M328_IOPB *iopb;
d456 1
a456 1
	qhdp = mcsb->mcsb_QHDP;
d460 1
a460 1
	iopb = (M328_IOPB *)&sc->sc_vsreg->sh_IOPB[qhdp];
d465 1
a465 2
vs_initialize(sc)
	struct vs_softc *sc;
a466 7
	M328_CIB *cib = (M328_CIB *)&sc->sc_vsreg->sh_CIB;
	M328_CQE *mc = (M328_CQE*)&sc->sc_vsreg->sh_MCE;
	M328_CRB *crb = (M328_CRB *)&sc->sc_vsreg->sh_CRB;
	M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
	M328_MCSB *mcsb = (M328_MCSB *)&sc->sc_vsreg->sh_MCSB;
	M328_IOPB *iopb;
	M328_WQCF *wiopb = (M328_WQCF *)&sc->sc_vsreg->sh_MCE_IOPB;
d470 1
a470 1
	mcsb->mcsb_QHDP = 0;
d472 33
a504 37
	d16_bzero(cib, sizeof(M328_CIB));
	cib->cib_NCQE = 10;
	cib->cib_BURST = 0;
	cib->cib_NVECT = (sc->sc_ipl << 8) | sc->sc_nvec;
	cib->cib_EVECT = (sc->sc_ipl << 8) | sc->sc_evec;
	cib->cib_PID = 0x07;
	cib->cib_SID = 0x00;
	cib->cib_CRBO = OFF(crb);
	cib->cib_SELECT_msw = HI(SELECTION_TIMEOUT);
	cib->cib_SELECT_lsw = LO(SELECTION_TIMEOUT);
	cib->cib_WQ0TIMO_msw = HI(4);
	cib->cib_WQ0TIMO_lsw = LO(4);
	cib->cib_VMETIMO_msw = 0; /*HI(VME_BUS_TIMEOUT);*/
	cib->cib_VMETIMO_lsw = 0; /*LO(VME_BUS_TIMEOUT);*/
	cib->cib_ERR_FLGS = M_ERRFLGS_RIN | M_ERRFLGS_RSE;
	cib->cib_SBRIV = (sc->sc_ipl << 8) | sc->sc_evec;
	cib->cib_SOF0 = 0x15;
	cib->cib_SRATE0 = 100 / 4;
	cib->cib_SOF1 = 0x0;
	cib->cib_SRATE1 = 0x0;

	iopb = (M328_IOPB *)&sc->sc_vsreg->sh_MCE_IOPB;
	d16_bzero(iopb, sizeof(M328_IOPB));
	iopb->iopb_CMD = CNTR_INIT;
	iopb->iopb_OPTION = 0;
	iopb->iopb_NVCT = (u_char)sc->sc_nvec;
	iopb->iopb_EVCT = (u_char)sc->sc_evec;
	iopb->iopb_LEVEL = 0; /*sc->sc_ipl;*/
	iopb->iopb_ADDR = SHIO_MOD;
	LV(iopb->iopb_BUFF, OFF(cib));
	LV(iopb->iopb_LENGTH, sizeof(M328_CIB));

	d16_bzero(mc, sizeof(M328_CQE));
	mc->cqe_IOPB_ADDR = OFF(iopb);
	mc->cqe_IOPB_LENGTH = sizeof(M328_IOPB);
	mc->cqe_WORK_QUEUE = 0;
	mc->cqe_QECR = M_QECR_GO;
d511 16
a526 16
		d16_bzero(wiopb, sizeof(M328_IOPB));
		wiopb->wqcf_CMD = CNTR_INIT_WORKQ;
		wiopb->wqcf_OPTION = 0;
		wiopb->wqcf_NVCT = (u_char)sc->sc_nvec;
		wiopb->wqcf_EVCT = (u_char)sc->sc_evec;
		wiopb->wqcf_ILVL = 0; /*sc->sc_ipl;*/
		wiopb->wqcf_WORKQ = i;
		wiopb->wqcf_WOPT = (WQO_FOE | WQO_INIT);
		wiopb->wqcf_SLOTS = JAGUAR_MAX_Q_SIZ;
		LV(wiopb->wqcf_CMDTO, 4); /* 1 second */

		d16_bzero(mc, sizeof(M328_CQE));
		mc->cqe_IOPB_ADDR = OFF(wiopb);
		mc->cqe_IOPB_LENGTH = sizeof(M328_IOPB);
		mc->cqe_WORK_QUEUE = 0;
		mc->cqe_QECR = M_QECR_GO;
d539 1
a539 1
	mcsb->mcsb_MCR |= M_MCR_SQM;
d543 2
a544 1
		printf("error: status = 0x%x\n", riopb->iopb_STATUS);
d546 1
a546 1
		return (1);
d554 2
a555 2
	printf(": target %d\n", sc->sc_link.adapter_target);
	return (0);
d559 1
a559 2
vs_resync(sc)
	struct vs_softc *sc;
a560 2
	M328_CQE *mc = (M328_CQE*)&sc->sc_vsreg->sh_MCE;
	M328_DRCF *devreset = (M328_DRCF *)&sc->sc_vsreg->sh_MCE_IOPB;
d564 13
a576 13
		d16_bzero(devreset, sizeof(M328_DRCF));
		devreset->drcf_CMD = CNTR_DEV_REINIT;
		devreset->drcf_OPTION = 0x00;	    /* no interrupts yet... */
		devreset->drcf_NVCT = sc->sc_nvec;
		devreset->drcf_EVCT = sc->sc_evec;
		devreset->drcf_ILVL = 0;
		devreset->drcf_UNIT = i;

		d16_bzero(mc, sizeof(M328_CQE));
		mc->cqe_IOPB_ADDR = OFF(devreset);
		mc->cqe_IOPB_LENGTH = sizeof(M328_DRCF);
		mc->cqe_WORK_QUEUE = 0;
		mc->cqe_QECR = M_QECR_GO;
d587 1
a587 2
vs_reset(sc)
	struct vs_softc *sc;
d589 1
a589 4
	u_int s;
	M328_CQE *mc = (M328_CQE*)&sc->sc_vsreg->sh_MCE;
	M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
	M328_SRCF *reset = (M328_SRCF *)&sc->sc_vsreg->sh_MCE_IOPB;
d593 13
a605 13
	d16_bzero(reset, sizeof(M328_SRCF));
	reset->srcf_CMD = IOPB_RESET;
	reset->srcf_OPTION = 0x00;	 /* no interrupts yet... */
	reset->srcf_NVCT = sc->sc_nvec;
	reset->srcf_EVCT = sc->sc_evec;
	reset->srcf_ILVL = 0;
	reset->srcf_BUSID = 0;

	d16_bzero(mc, sizeof(M328_CQE));
	mc->cqe_IOPB_ADDR = OFF(reset);
	mc->cqe_IOPB_LENGTH = sizeof(M328_SRCF);
	mc->cqe_WORK_QUEUE = 0;
	mc->cqe_QECR = M_QECR_GO;
d613 1
a613 1
			riopb->iopb_STATUS = 0;
d620 1
a620 1
	thaw_queue(sc, 0xFF);
d622 1
a622 1
	splx (s);
a629 1

d631 1
a631 4
vs_checkintr(sc, xs, status)
	struct vs_softc *sc;
	struct scsi_xfer *xs;
	int   *status;
d633 1
a633 2
	M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
	u_long len;
d636 2
a637 2
	VL(len, riopb->iopb_LENGTH);
	error = riopb->iopb_STATUS;
d653 1
a653 2
vs_nintr(vsc)
	void *vsc;
a655 1
	M328_CRB *crb = (M328_CRB *)&sc->sc_vsreg->sh_CRB;
d662 1
a662 1
		return(vs_eintr(sc));
d667 1
a667 1
	VL((unsigned long)m328_cmd, crb->crb_CTAG);
d671 3
a673 3
	 * pointer in the CTAG feild.  Bad things happen if you try
	 * to point to address 0.  Controller error should be handled
	 * in vsdma.c  I'll change this soon - steve.
d677 1
a677 1
		if (m328_cmd->top_sg_list) {
d679 1
a679 1
			m328_cmd->top_sg_list = (M328_SG)0;
d696 1
a696 1
	return (1);
d699 1
d701 1
a701 2
vs_eintr(vsc)
	void *vsc;
a703 1
	M328_CEVSB *crb = (M328_CEVSB *)&sc->sc_vsreg->sh_CRB;
d706 1
a706 2
	int crsw = crb->cevsb_CRSW;
	int ecode = crb->cevsb_ERROR;
d713 3
a715 1
	VL((unsigned long)m328_cmd, crb->cevsb_CTAG);
d719 1
a719 1
		printf("%s: bus reset!\n", sc->sc_dev.dv_xname);
d722 1
a722 1
		return(1);
d734 1
a734 1
		printf("IOPB Type error\n");
d769 1
a769 1
	thaw_queue(sc, 0xFF);
d773 1
a773 1
	return(1);
d777 1
a777 2
vs_clear_return_info(sc)
	struct vs_softc *sc;
d779 1
a779 5
        M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
	M328_CEVSB *crb = (M328_CEVSB *)&sc->sc_vsreg->sh_CRB;
	d16_bzero(riopb, sizeof(M328_IOPB));
	/* note that this also partially overrides the sh_RET_IOPB before... */
	d16_bzero(crb, sizeof(M328_CEVSB));
d798 1
a798 2
vs_dealloc_scatter_gather(sg)
	M328_SG sg;
d811 1
a811 4
vs_link_sg_element(element, phys_add, len)
	sg_list_element_t *element;
	vaddr_t phys_add;
	int len;
d814 2
a815 1
	LV(element->address, phys_add);
d819 1
a819 1
	element->address_modifier = 0xD;
d823 1
a823 4
vs_link_sg_list(list, phys_add, elements)
	sg_list_element_t *list;
	vaddr_t phys_add;
	int elements;
d825 3
a827 3

	list->count.scatter.gather  = elements;
	LV(list->address, phys_add);
d831 1
a831 1
	list->address_modifier = 0xD;
d835 2
a836 3
vs_build_memory_structure(xs, iopb)
	struct scsi_xfer *xs;
	M328_IOPB  *iopb;	       /* the iopb */
d838 1
a838 1
	M328_SG   sg;
d841 2
a842 2
	unsigned len;
	int       level;
d844 1
a844 1
	sg = (M328_SG)0;   /* Hopefully we need no scatter/gather list */
d848 10
a857 7
	 *	virt			the virtual address of the contiguous virtual memory block
	 *	len			the length of the contiguous virtual memory block
	 *	starting_point_virt	the virtual address of the contiguous *physical* memory block
	 *	starting_point_phys	the *physical* address of the contiguous *physical* memory block
	 *	point_virt		the pointer to the virtual memory we are checking at the moment
	 *	point1_phys		the pointer to the *physical* memory we are checking at the moment
	 *	point2_phys		the pointer to the *physical* memory we are checking at the moment
d864 1
a867 1

a878 1
					assert( MAX_SG_BLOCK_SIZE > PAGE_SIZE );
d885 1
a885 2
				if (!sg) {
					/* We allocate our fist scatter/gather list */
d887 1
a887 1
				}
a888 1

a892 1

d944 1
a944 1
	if (sg) {
d953 7
a959 5
		iopb->iopb_OPTION |= M_OPT_SG;
		iopb->iopb_ADDR |= M_ADR_SG_LINK;
		LV(iopb->iopb_BUFF, kvtop((vaddr_t)sg->list));
		LV(iopb->iopb_LENGTH, sg->elements);
		LV(iopb->iopb_SGTTL, len);
d962 2
a963 2
		LV(iopb->iopb_BUFF, starting_point_phys);
		LV(iopb->iopb_LENGTH, len);
d965 1
a965 1
	return (sg);
@


1.36
log
@More "can't help but clean things while reading".
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.35 2004/05/20 16:42:54 miod Exp $ */
d91 1
a91 1
void	thaw_queue(struct vs_softc *, u_int8_t);
d210 1
a210 1
	/*spl0();*/
a215 1
				/*splx(s);*/
a235 1
	/*s = splbio();*/
a241 1
			/* clear the return information */
d250 1
d252 5
a256 3
			CRB_CLR_ER(CRSW);
		CRB_CLR_DONE(CRSW);
		if (xs->flags & ITSDONE) break;
d258 1
a258 1
	/* clear the return information */
d266 1
a266 1
	u_int8_t target;
d268 2
a269 4
	u_short t;
	t = target << 8;
	t |= 0x0001;
	THAW_REG = t;
d271 2
a272 1
	while (THAW_REG & 0x01);
a291 1
	/*sc->sc_tinfo[slp->target].cmds++;*/
d304 1
a304 1
	int flags;
a313 1

a325 1
	iopb_len = sizeof(M328_short_IOPB) + xs->cmdlen;
d328 1
d331 1
a331 2
	iopb->iopb_UNIT = slp->lun << 3;
	iopb->iopb_UNIT |= slp->target;
d340 8
a347 9
	if (xs->flags & SCSI_DATA_IN) {	 /* read */
		dma_cachectl((vaddr_t)xs->data, xs->datalen,
			     DMA_CACHE_SYNC_INVAL);
		iopb->iopb_OPTION |= OPT_READ;
	} else {			 /* write */
		dma_cachectl((vaddr_t)xs->data, xs->datalen,
			     DMA_CACHE_SYNC);
		iopb->iopb_OPTION |= OPT_WRITE;
	}
d350 1
a350 1
		iopb->iopb_OPTION |= OPT_INTDIS;
d353 1
a353 1
		iopb->iopb_OPTION |= OPT_INTEN;
d367 1
a367 5
	if (flags & SCSI_POLL) {
		cqep->cqe_WORK_QUEUE = 0;
	} else {
		cqep->cqe_WORK_QUEUE = slp->target + 1;
	}
d372 1
a372 1
	if (xs->datalen) {
d374 2
a375 3
	} else {
		m328_cmd->top_sg_list = (M328_SG)0;
	}
d388 1
d406 2
a407 2
		CRB_CLR_ER(CRSW);
	CRB_CLR_DONE(CRSW);
d433 1
a436 5
	/*
	if (xs->cmd->opcode != PREVENT_ALLOW) {
	   xs->error = XS_SENSE;
	}
	*/
d447 9
d457 3
a459 1
	cqep = (M328_CQE *)&sc->sc_vsreg->sh_CQE[mcsb->mcsb_QHDP];
a460 4
	if (cqep->cqe_QECR & M_QECR_GO)
		return NULL; /* Hopefully, this will never happen */
	mcsb->mcsb_QHDP++;
	if (mcsb->mcsb_QHDP == NUM_CQE)	mcsb->mcsb_QHDP = 0;
d471 1
a471 1
	int slot;
d473 9
a481 6
	if (mcsb->mcsb_QHDP == 0) {
		slot = NUM_CQE - 1;
	} else {
		slot = mcsb->mcsb_QHDP - 1;
	}
	iopb = (M328_IOPB *)&sc->sc_vsreg->sh_IOPB[slot];
d498 3
a500 1
	CRB_CLR_DONE(CRSW);
a501 1
	mcsb->mcsb_QHDP = 0;
d504 2
a505 4
	cib->cib_NVECT = sc->sc_ipl << 8;
	cib->cib_NVECT |= sc->sc_nvec;
	cib->cib_EVECT = sc->sc_ipl << 8;
	cib->cib_EVECT |= sc->sc_evec;
d516 1
a516 2
	cib->cib_SBRIV = sc->sc_ipl << 8;
	cib->cib_SBRIV |= sc->sc_evec;
d518 1
a518 1
	cib->cib_SRATE0 = 100/4;
d538 1
d560 1
d564 3
a566 2
			CRB_CLR_ER(CRSW);
		CRB_CLR_DONE(CRSW);
d568 1
d570 1
d577 1
a577 1
		CRB_CLR_DONE(CRSW);
d580 1
a580 1
	CRB_CLR_DONE(CRSW);
d612 1
d616 2
a617 2
			CRB_CLR_ER(CRSW);
		CRB_CLR_DONE(CRSW);
d630 2
a638 1
	s = splbio();
d645 1
d647 1
a647 1
	while (1) {
d651 1
a651 1
			CRB_CLR_DONE(CRSW);
d655 1
a655 1
		CRB_CLR_DONE(CRSW);
d657 1
d660 1
d710 1
a711 1
	/* Got a valid interrupt on this device */
d713 1
a714 1
	VL((unsigned long)m328_cmd, crb->crb_CTAG);
d721 1
a721 1
	if (m328_cmd) {
d728 1
d733 1
d736 3
a738 3
		CRB_CLR_ER(CRSW);
	CRB_CLR_DONE(CRSW);
	/* clear the return information */
d741 1
d755 1
a755 1
	int status, s;
d757 1
a758 2

	/* Got a valid interrupt on this device */
d762 1
a762 1
	xs = m328_cmd->xs;
d765 1
a765 2
		printf("%s: SCSI Bus Reset!\n", vs_name(sc));
		/* clear the return information */
d770 8
d780 1
a780 1
		printf("%s: IOPB Type error!\n", vs_name(sc));
d783 7
a789 6
		printf("%s: Timeout!\n", vs_name(sc));
		xs->error = XS_SELTIMEOUT;
		xs->status = -1;
		xs->flags |= ITSDONE;
		status = -1;
		scsi_done(xs);
d791 2
a792 2
	case CEVSB_ERR_TR:	/* Target Reconnect, no IOPB */
		printf("%s: Target Reconnect error!\n", vs_name(sc));
d794 2
a795 2
	case CEVSB_ERR_OF:	/* Overflow */
		printf("%s: Overflow error!\n", vs_name(sc));
d797 2
a798 2
	case CEVSB_ERR_BD:	/* Bad direction */
		printf("%s: Bad Direction!\n", vs_name(sc));
d800 2
a801 2
	case CEVSB_ERR_NR:	/* Non-Recoverable Error */
		printf("%s: Non-Recoverable error!\n", vs_name(sc));
d803 2
a804 2
	case CESVB_ERR_PANIC:	/* Board Panic!!! */
		printf("%s: Board Panic!!!\n", vs_name(sc));
d807 2
a808 4
		printf("%s: Uh oh!... Error 0x%x\n", vs_name(sc), ecode);
#ifdef DDB
		Debugger();
#endif
d810 1
d812 3
a814 2
		CRB_CLR_ER(CRSW);
	CRB_CLR_DONE(CRSW);
a815 1
	/* clear the return information */
d818 1
d822 1
a822 1
static __inline__ void
d829 1
d855 1
a855 1
		for (i=0; sg->down[i] && i<MAX_SG_ELEMENTS; i++) {
@


1.35
log
@General cleanup before attempting to move towards bus_space and bus_dma.
Also fix an arithmetic bug which caused almost no harm by luck.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.34 2004/05/09 05:34:00 krw Exp $ */
d414 2
a415 1
	CRB_CLR_ER(CRSW);
d499 1
a499 2
	u_short i, crsw;
	int failed = 0;
a544 1
	CRB_CLR_DONE(CRSW);
d566 1
a566 3
		if (CRSW & M_CRSW_ER) {
			/*printf("\nerror: queue %d status = 0x%x\n", i, riopb->iopb_STATUS);*/
			/*failed = 1;*/
a567 1
		}
a571 1
	CRSW = 0;
d573 1
a573 1
	crsw = CRSW;
d577 2
a578 1
		CRB_CLR_ER(CRSW);
a581 4
	if (failed) {
		printf(": failed!\n");
		return (1);
	}
d587 1
a587 1
	return (0); /* success */
d596 3
a598 2
	u_short i;
	for (i=0; i<7; i++) {
d614 1
a614 1
		if (CRSW & M_CRSW_ER) {
a615 1
		}
a647 1
			CRB_CLR_ER(CRSW);
a670 2
	int   target = -1;
	int   lun = -1;
a671 2
	struct scsi_generic *cmd;
	u_long buf;
d673 1
a673 5
	u_char error;

	target = xs->sc_link->target;
	lun = xs->sc_link->lun;
	cmd = (struct scsi_generic *)&riopb->iopb_SCSI[0];
a674 1
	VL(buf, riopb->iopb_BUFF);
d676 2
a677 2
	*status = riopb->iopb_STATUS >> 8;
	error = riopb->iopb_STATUS & 0xFF;
d679 1
a679 5
	if (len != xs->datalen) {
		xs->resid = xs->datalen - len;
	} else {
		xs->resid = 0;
	}
d681 1
a681 1
	if (error == SCSI_SELECTION_TO) {
d686 1
@


1.34
log
@Eliminate verbosity parameter to scsi_print_sense and the associated
chunk of code. It was never executed unless you were debugging a
mvmex8k 'vs' device.

ok miod@@ (mvmex8k bits) marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.33 2004/04/30 19:08:02 miod Exp $ */
a136 1
	struct vsreg *rp;
d159 1
a159 1
	sc->sc_vsreg = rp = (void *)bus_space_vaddr(iot, ioh);
a212 3
#ifdef SDEBUG2
			printf ("waiting: timeout %d crsw 0x%x\n", to, CRSW);
#endif
d307 1
a307 2
	unsigned long buf, len;
	u_short iopb_len;
a316 34
#ifdef SDEBUG
	printf("scsi_cmd() ");
	if (xs->cmd->opcode == 0) {
		printf("TEST_UNIT_READY ");
	} else if (xs->cmd->opcode == REQUEST_SENSE) {
		printf("REQUEST_SENSE   ");
	} else if (xs->cmd->opcode == INQUIRY) {
		printf("INQUIRY         ");
	} else if (xs->cmd->opcode == MODE_SELECT) {
		printf("MODE_SELECT     ");
	} else if (xs->cmd->opcode == MODE_SENSE) {
		printf("MODE_SENSE      ");
	} else if (xs->cmd->opcode == START_STOP) {
		printf("START_STOP      ");
	} else if (xs->cmd->opcode == RESERVE) {
		printf("RESERVE         ");
	} else if (xs->cmd->opcode == RELEASE) {
		printf("RELEASE         ");
	} else if (xs->cmd->opcode == PREVENT_ALLOW) {
		printf("PREVENT_ALLOW   ");
	} else if (xs->cmd->opcode == POSITION_TO_ELEMENT) {
		printf("POSITION_TO_EL  ");
	} else if (xs->cmd->opcode == CHANGE_DEFINITION) {
		printf("CHANGE_DEF      ");
	} else if (xs->cmd->opcode == MODE_SENSE_BIG) {
		printf("MODE_SENSE_BIG  ");
	} else if (xs->cmd->opcode == MODE_SELECT_BIG) {
		printf("MODE_SELECT_BIG ");
	} else if (xs->cmd->opcode == 0x25) {
		printf("READ_CAPACITY   ");
	} else if (xs->cmd->opcode == 0x08) {
		printf("READ_COMMAND    ");
	}
#endif
d322 4
a327 4
	if (cqep == NULL) {
		xs->error = XS_DRIVER_STUFFUP;
		return (TRY_AGAIN_LATER);
	}
a391 7
	VL(buf, iopb->iopb_BUFF);
	VL(len, iopb->iopb_LENGTH);
#ifdef SDEBUG
	printf("tgt %d lun %d buf %x len %d wqn %d ipl %d crsw 0x%x\n",
	       slp->target, slp->lun, buf, len, cqep->cqe_WORK_QUEUE,
	       iopb->iopb_LEVEL, crb->crb_CRSW);
#endif
a449 3
#ifdef SDEBUG
	scsi_print_sense(xs);
#endif
d479 1
a479 1
		slot = NUM_CQE;
a483 1
	d16_bzero(iopb, sizeof(M328_IOPB));
a503 1
	sc->sc_qhp = 0;
a602 1
	M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
a620 8
		if (riopb->iopb_STATUS) {
#ifdef SDEBUG
			printf("status: %x\n", riopb->iopb_STATUS);
#endif
			sc->sc_tinfo[i].avail = 0;
		} else {
			sc->sc_tinfo[i].avail = 1;
		}
a696 57
#ifdef SDEBUG
	printf("scsi_chk() ");

	if (xs->cmd->opcode == 0) {
		printf("TEST_UNIT_READY ");
	} else if (xs->cmd->opcode == REQUEST_SENSE) {
		printf("REQUEST_SENSE   ");
	} else if (xs->cmd->opcode == INQUIRY) {
		printf("INQUIRY         ");
	} else if (xs->cmd->opcode == MODE_SELECT) {
		printf("MODE_SELECT     ");
	} else if (xs->cmd->opcode == MODE_SENSE) {
		printf("MODE_SENSE      ");
	} else if (xs->cmd->opcode == START_STOP) {
		printf("START_STOP      ");
	} else if (xs->cmd->opcode == RESERVE) {
		printf("RESERVE         ");
	} else if (xs->cmd->opcode == RELEASE) {
		printf("RELEASE         ");
	} else if (xs->cmd->opcode == PREVENT_ALLOW) {
		printf("PREVENT_ALLOW   ");
	} else if (xs->cmd->opcode == POSITION_TO_ELEMENT) {
		printf("POSITION_TO_EL  ");
	} else if (xs->cmd->opcode == CHANGE_DEFINITION) {
		printf("CHANGE_DEF      ");
	} else if (xs->cmd->opcode == MODE_SENSE_BIG) {
		printf("MODE_SENSE_BIG  ");
	} else if (xs->cmd->opcode == MODE_SELECT_BIG) {
		printf("MODE_SELECT_BIG ");
	} else if (xs->cmd->opcode == 0x25) {
		printf("READ_CAPACITY   ");
	} else if (xs->cmd->opcode == 0x08) {
		printf("READ_COMMAND    ");
	}

	printf("tgt %d lun %d buf %x len %d status %x ", target, lun, buf, len, riopb->iopb_STATUS);

	if (CRSW & M_CRSW_EX) {
		printf("[ex]");
	}
	if (CRSW & M_CRSW_QMS) {
		printf("[qms]");
	}
	if (CRSW & M_CRSW_SC) {
		printf("[sc]");
	}
	if (CRSW & M_CRSW_SE) {
		printf("[se]");
	}
	if (CRSW & M_CRSW_AQ) {
		printf("[aq]");
	}
	if (CRSW & M_CRSW_ER) {
		printf("[er]");
	}
	printf("\n");
#endif
a730 4
#ifdef SDEBUG
	printf("Interrupt!!! ");
	printf("m328_cmd == 0x%x\n", m328_cmd);
#endif
a766 5
#ifdef SDEBUG
	int type = crb->cevsb_TYPE;
	int length = crb->cevsb_IOPB_LENGTH;
	int wq = crb->cevsb_WORK_QUEUE;
#endif
a775 4
#ifdef SDEBUG
	printf("Error Interrupt!!! ");
	printf("m328_cmd == 0x%x\n", m328_cmd);
#endif
a817 4
#ifdef SDEBUG
	printf("%s: crsw = 0x%x iopb_type = %d iopb_len = %d wq = %d error = 0x%x\n",
	       vs_name(sc), crsw, type, length, wq, ecode);
#endif
@


1.33
log
@Fix logic botch resulting in a too optimistic openings value.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.32 2004/04/24 20:34:53 miod Exp $ */
d497 1
a497 1
	scsi_print_sense(xs, 2);
@


1.32
log
@Do not ignore vs_poll() return value.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.31 2004/04/24 19:51:48 miod Exp $ */
d170 1
a170 1
	sc->sc_link.openings = roundup(NUM_IOPB, 8) / 8;
@


1.31
log
@Preliminary switch to an mvme88k bus_space world. Not all drivers have been
converted yet, and they rely upon some linear mappings provided by bus_space.

In order to not impact performance, almost all the bus_space accesses go
through macros and inline functions. This currently restricts us to D16 and
D32 access modes, which are selected at compilation time. Since there are no
plans to support D8 vme devices in the future, this is acceptable for now.

This makes the "len" locator for vme devices go away, and allows to simplify
some code which was using the pcctwo device, and will now directly access
hardware which is known to exist, rather than wait until the device is
attached.

While there, try to enforce more interrupt vector number checks, since these
changes pointed out that dart(4) had been working correctly so far by sheer
luck only.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.30 2004/04/16 23:35:50 miod Exp $ */
d405 1
a405 1
	      * queue entry is busy and we are polling.
d442 1
a442 2
		vs_poll(sc, xs);
		return (COMPLETE);
@


1.30
log
@When a VMEBus device needs to use two interrupt vectors, be nice and let it
actually use two distinct vectors, rather than twice the same.

Because of this, print vector last in vmeprint() so that dmesg remains pretty
in the multi-vector case.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.29 2004/01/29 21:39:05 deraadt Exp $ */
d40 3
d118 8
d127 1
a127 1
	return (!badvaddr((unsigned)ca->ca_vaddr, 1));
d140 2
d153 5
d160 1
a160 1
	sc->sc_vsreg = rp = ca->ca_vaddr;
@


1.29
log
@typos; jjy2+@@pitt.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.28 2004/01/20 16:48:27 miod Exp $ */
d58 2
a59 2
#include <mvme88k/dev/vme.h>		/* vme_findvec() */
#include <machine/cmmu.h>		/* DMA_CACHE_SYNC, etc... */
d120 1
a120 1
vsattach(parent, self, auxp)
d122 1
a122 1
	void *auxp;
d125 3
a127 2
	struct confargs *ca = auxp;
	struct vsreg * rp;
d130 12
d146 1
a146 2
	/* get the next available vector for the error interrupt func. */
	sc->sc_evec = vme_findvec();
@


1.28
log
@In some situations, the MVME328S can be so hung that our current reset code
fails. Unfortunately, in this case, do_vspoll() would invoke the reset
function ad nauseum.

Allow the flow to exit this infernal loop, attach() will correctly fail.

This is temporary band-aid until a stronger reset sequence is found.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.27 2004/01/14 20:50:48 miod Exp $ */
d907 1
a907 1
	case CEVSB_ERR_NR:	/* Non-Recoverabl Error */
d910 2
a911 2
	case CESVB_ERR_PANIC:	/* Board Painc!!! */
		printf("%s: Board Painc!!!\n", vs_name(sc));
@


1.27
log
@Do not fill more than the first three fields of cfdriver structures unless
necessary. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.26 2004/01/14 02:00:41 krw Exp $ */
d87 1
a87 1
int	do_vspoll(struct vs_softc *, int);
d172 1
a172 1
do_vspoll(sc, to)
d175 1
d191 4
a194 2
				vs_reset(sc);
				vs_resync(sc);
d214 1
a214 1
		if (do_vspoll(sc, to)) {
d460 1
a460 1
	do_vspoll(sc, 0);
d566 1
a566 1
	do_vspoll(sc, 0);
d588 1
a588 1
		do_vspoll(sc, 0);
d601 1
a601 1
	do_vspoll(sc, 0);
d643 1
a643 1
		do_vspoll(sc, 0);
d684 1
a684 1
		do_vspoll(sc, 0);
@


1.26
log
@Nuke SDEV_NOLUNS, SDEV_FORCELUNS, and PQUIRK_FORCELUNS quirks. Also
moreluns field in scsi_link structure.  Instead, treat an INQUIRY
result that duplicates the INQUIRY result of LUN 0 as proof the LUN
does not exist.  Compensate for lack of SDEV_NOLUNS where necessary by
setting sc_link->luns to 1, which has the same effect. From Marco
Peereboom.

Don't issue Test Unit Ready command before INQUIRY command - not
necessary and potentially harmful to devices with ADEV_NOTUR quirk
since quirks have not been set yet. From mycroft@@NetBSD

ok deraadt@@, mvme* changes by miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.25 2004/01/02 23:38:37 miod Exp $ */
d84 1
a84 1
	NULL, "vs", DV_DULL, 0
@


1.25
log
@Better openings value computation.

For now, the result is the same as the hard-coded constant it used to be, due
to a pessimistic NUM_IOPB value. This will change.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.24 2003/12/26 10:41:43 miod Exp $ */
d139 1
a286 1
	slp->quirks |= SDEV_NOLUNS;
@


1.24
log
@Merge the attachment part and the real work part of the SCSI drivers in
one file per driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.23 2003/12/25 21:01:39 miod Exp $ */
d139 1
a139 1
	sc->sc_link.openings = 1;
@


1.23
log
@Provide common D16 vmespace block access functions, instead of vs and vx each
rolling their own.

Use them more cleverly in vx, in order to get the driver to at least attach
and frob chips. Not tested besides multiuser boot (hence ttyflags -a), and
checking cu(1) connects. More testing to come once I remember where I have
hidden the 332XT transition module...
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.22 2003/11/07 10:16:45 jmc Exp $ */
d37 1
a37 1
 * MVME328 scsi adaptor driver
a55 1
#if defined(mvme88k)
d60 46
a105 21
#else
#include <mvme68k/dev/vsreg.h>
#include <mvme68k/dev/vsvar.h>
#include <mvme68k/dev/vme.h>		/* vme_findvec() */
#endif /* mvme88k */

int  vs_checkintr(struct vs_softc *, struct scsi_xfer *, int *);
void vs_chksense(struct scsi_xfer *);
void vs_reset(struct vs_softc *);
void vs_resync(struct vs_softc *);
int  vs_initialize(struct vs_softc *);
int  vs_nintr(struct vs_softc *);
int  vs_eintr(struct vs_softc *);
int  vs_poll(struct vs_softc *, struct scsi_xfer *);
void vs_scsidone(struct vs_softc *, struct scsi_xfer *, int);
M328_CQE  * vs_getcqe(struct vs_softc *);
M328_IOPB * vs_getiopb(struct vs_softc *);
int do_vspoll(struct vs_softc *, int);
void thaw_queue(struct vs_softc *, u_int8_t);
void vs_link_sg_element(sg_list_element_t *, vaddr_t, int);
void vs_link_sg_list(sg_list_element_t *, vaddr_t, int);
d109 10
a118 3
/*
 * default minphys routine for MVME328 based controllers
 */
d120 39
a158 3
vs_minphys(bp)
	struct buf *bp;
{
d160 2
a161 1
	 * No max transfer at this level.
d163 5
a167 1
	minphys(bp);
d247 1
a247 1
vs_scsidone (sc, xs, stat)
a350 1
#if defined(mvme88k)
a352 1
#endif
a354 1
#if defined(mvme88k)
a356 1
#endif
d567 1
a567 1
	for (i=1; i<8; i++) {
d704 1
a704 1
	struct   vs_softc *sc;
d798 2
a799 2
vs_nintr(sc)
	struct vs_softc *sc;
d801 1
d848 2
a849 2
vs_eintr(sc)
	struct vs_softc *sc;
d851 1
@


1.22
log
@adress -> address, and a few more; all from Jonathon Gray;

(mvme68k/mvme88k) vs.c and (vax) if_le.c ok miod@@
isakmpd ones ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.21 2003/11/03 06:54:26 david Exp $ */
a77 2
void vs_copy(void *, void *, unsigned short);
void vs_zero(void *, u_long);
a85 49
 * 16 bit 's' memory functions.  MVME328 is a D16 board.
 * We must program with that in mind or else...
 * bcopy/bzero (the 'b' meaning byte) is implemented in
 * 32 bit operations for speed, so thay are not really
 * 'byte' operations at all!!  MVME1x7 can be set up to
 * handle D32 -> D16 read/writes via VMEChip2 Address
 * modifiers, however MVME188 can not.  These next two
 * function insure 16 bit copy/zero operations.  The
 * structures are all implemented with 16 bit or less
 * types.   smurph
 */

void
vs_copy(src, dst, cnt)
	void *src;
	void *dst;
	unsigned short cnt;
{
	unsigned short *volatile x, *volatile y;
	unsigned short volatile z;

	z = cnt >> 1;
	x = (unsigned short *)src;
	y = (unsigned short *)dst;

	while (z--) {
		*y++ = *x++;
	}
}

void
vs_zero(src, cnt)
	void *src;
	u_long cnt;
{
	unsigned short *source;
	unsigned short zero = 0;
	unsigned short z;

	source = (unsigned short *) src;
	z = cnt >> 1;

	while (z--) {
		*source++ = zero;
	}
	return;
}

/*
d264 1
a264 1
	vs_zero(iopb, sizeof(M328_IOPB));
d266 1
a266 1
	vs_copy(xs->cmd, &iopb->iopb_SCSI[0], xs->cmdlen);
d364 1
a364 1
	vs_zero(miopb, sizeof(M328_IOPB));
d367 1
a367 1
	vs_zero(ss, sizeof(*ss));
d381 1
a381 1
	vs_zero(mc, sizeof(M328_CQE));
d415 1
a415 1
	vs_zero(cqep, sizeof(M328_CQE));
d433 1
a433 1
	vs_zero(iopb, sizeof(M328_IOPB));
d452 1
a452 1
	vs_zero(cib, sizeof(M328_CIB));
d479 1
a479 1
	vs_zero(iopb, sizeof(M328_IOPB));
d489 1
a489 1
	vs_zero(mc, sizeof(M328_CQE));
d500 1
a500 1
		vs_zero(wiopb, sizeof(M328_IOPB));
d511 1
a511 1
		vs_zero(mc, sizeof(M328_CQE));
d558 1
a558 1
		vs_zero(devreset, sizeof(M328_DRCF));
d566 1
a566 1
		vs_zero(mc, sizeof(M328_CQE));
d597 1
a597 1
	vs_zero(reset, sizeof(M328_SRCF));
d606 1
a606 1
	vs_zero(mc, sizeof(M328_CQE));
d866 2
a867 2
	vs_zero(riopb, sizeof(M328_IOPB));
	vs_zero(crb, sizeof(M328_CEVSB));
@


1.21
log
@spelling fixes (in the comments)
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.20 2003/10/05 20:27:48 miod Exp $ */
d1024 2
a1025 1
					/* and gererate the physadress of this location for the next time. */
@


1.20
log
@Kill vm_offset_t and vm_size_t, in favor of the [pv]addr_t and [pv]size_t
typedefs.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.19 2003/06/02 23:27:52 millert Exp $ */
d1105 1
a1105 1
		/* no scatter/gather neccessary */
@


1.19
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.18 2002/12/14 07:20:25 fgsch Exp $ */
d82 2
a83 2
void vs_link_sg_element(sg_list_element_t *, vm_offset_t, int);
void vs_link_sg_list(sg_list_element_t *, vm_offset_t, int);
d87 1
a87 1
/* 
d90 4
a93 4
 * bcopy/bzero (the 'b' meaning byte) is implemented in 
 * 32 bit operations for speed, so thay are not really 
 * 'byte' operations at all!!  MVME1x7 can be set up to 
 * handle D32 -> D16 read/writes via VMEChip2 Address 
d95 1
a95 1
 * function insure 16 bit copy/zero operations.  The 
d105 7
a111 7
{ 
	register unsigned short *volatile x, *volatile y;
	register unsigned short volatile z; 

	z = cnt >> 1; 
	x = (unsigned short *)src; 
	y = (unsigned short *)dst; 
d114 1
a114 1
		*y++ = *x++; 
d123 3
a125 3
	register unsigned short *source;
	register unsigned short zero = 0;
	register unsigned short z; 
d128 1
a128 1
	z = cnt >> 1; 
d149 1
a149 1
int 
d212 1
a212 1
void 
d225 1
a225 1
void 
d229 1
a229 1
	int stat;                             
d231 1
a231 1
	int tgt; 
d243 1
a243 1
	
d301 1
a301 1
#endif 
d331 1
a331 1
		dma_cachectl((vm_offset_t)xs->data, xs->datalen,
d333 1
a333 1
#endif      
d337 1
a337 1
		dma_cachectl((vm_offset_t)xs->data, xs->datalen,
d339 1
a339 1
#endif      
d354 1
a354 1
	 * Should only have to wait if the master command 
d384 2
a385 2
	printf("tgt %d lun %d buf %x len %d wqn %d ipl %d crsw 0x%x\n", 
	       slp->target, slp->lun, buf, len, cqep->cqe_WORK_QUEUE, 
d387 1
a387 1
#endif 
d429 1
a429 1
	LV(miopb->iopb_BUFF, kvtop((vm_offset_t)&xs->sense));
d434 1
a434 1
	mc->cqe_IOPB_LENGTH = sizeof(M328_short_IOPB) + 
d449 1
a449 1
#endif   
d606 1
a606 1
	M328_DRCF *devreset = (M328_DRCF *)&sc->sc_vsreg->sh_MCE_IOPB;  
d627 1
a627 1
#endif 
d646 1
a646 1
	M328_SRCF *reset = (M328_SRCF *)&sc->sc_vsreg->sh_MCE_IOPB;  
d764 1
a764 1
#endif   
d782 1
a782 1
	register struct vs_softc *sc;
d789 1
a789 1
	
d801 1
a801 1
#endif 
d804 1
a804 1
	 * pointer in the CTAG feild.  Bad things happen if you try 
d831 1
a831 1
	register struct vs_softc *sc;
d844 1
a844 1
	
d849 1
a849 1
	
d854 1
a854 1
#endif 
d898 1
a898 1
	printf("%s: crsw = 0x%x iopb_type = %d iopb_len = %d wq = %d error = 0x%x\n", 
d900 1
a900 1
#endif 
d913 1
a913 1
	register struct vs_softc *sc;
d940 1
a940 1
	register int i;
d953 2
a954 2
	register vm_offset_t phys_add;
	register int len;
d967 2
a968 2
	register vm_offset_t phys_add;
	register int elements;
d979 1
a979 1
M328_SG 
d985 1
a985 1
	vm_offset_t starting_point_virt, starting_point_phys, point_virt, 
d1004 2
a1005 2
	virt = starting_point_virt = (vm_offset_t)xs->data;
	point1_phys = starting_point_phys = kvtop((vm_offset_t)xs->data);
d1014 1
a1014 1
		    point_virt < virt + (vm_offset_t)len || sg ;
d1048 2
a1049 2
					vs_link_sg_list(&(sg->up->list[sg->up->elements-1]), 
							kvtop((vm_offset_t)sg->list),
d1054 1
a1054 1
					register int i;
d1058 1
a1058 1
					sg->down[i] = vs_alloc_scatter_gather();  
d1065 1
a1065 1
				if (point_virt < virt+(vm_offset_t)len) {
d1067 2
a1068 2
					vs_link_sg_element(&(sg->list[sg->elements]), 
							   starting_point_phys, 
d1073 3
a1075 3
					vs_link_sg_element(&(sg->list[sg->elements]), 
							   starting_point_phys, 
							   (vm_offset_t)(virt+len)-starting_point_virt);
d1093 2
a1094 2
			vs_link_sg_list(&(sg->up->list[sg->up->elements-1]), 
					kvtop((vm_offset_t)sg->list),
d1101 1
a1101 1
		LV(iopb->iopb_BUFF, kvtop((vm_offset_t)sg->list));
@


1.18
log
@handeled -> handled; reported by someone on the list, but i no longer
have the mail.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.16 2002/03/14 01:26:39 millert Exp $ */
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.17
log
@spelling; from Brian Poole <raj@@cerias.purdue.edu>
@
text
@d809 1
a809 1
	 * to point to address 0.  Controller error should be handeled
@


1.16
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.15 2002/01/14 21:34:39 miod Exp $ */
d998 2
a999 2
	 *	virt			the virtuell address of the contiguous virtual memory block
	 *	len			the lenght of the contiguous virtual memory block
@


1.15
log
@volatile police.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.14 2001/12/22 09:49:39 smurph Exp $ */
d71 17
a87 17
int  vs_checkintr        __P((struct vs_softc *, struct scsi_xfer *, int *));
void vs_chksense         __P((struct scsi_xfer *));
void vs_reset            __P((struct vs_softc *));
void vs_resync           __P((struct vs_softc *));
int  vs_initialize       __P((struct vs_softc *));
int  vs_nintr            __P((struct vs_softc *));
int  vs_eintr            __P((struct vs_softc *));
int  vs_poll             __P((struct vs_softc *, struct scsi_xfer *));
void vs_scsidone         __P((struct vs_softc *, struct scsi_xfer *, int));
M328_CQE  * vs_getcqe    __P((struct vs_softc *));
M328_IOPB * vs_getiopb   __P((struct vs_softc *));
void vs_copy __P((void *, void *, unsigned short));
void vs_zero __P((void *, u_long));
int do_vspoll __P((struct vs_softc *, int));
void thaw_queue __P((struct vs_softc *, u_int8_t));
void vs_link_sg_element __P((sg_list_element_t *, vm_offset_t, int));
void vs_link_sg_list __P((sg_list_element_t *, vm_offset_t, int));
d89 1
a89 1
static __inline__ void vs_clear_return_info __P((struct vs_softc *));
@


1.14
log
@masive cmmu overhaul.  function pointers now control cmmu functionality
instead of case statements based on cpu type.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.13 2001/12/16 23:49:46 miod Exp $ */
d110 2
a111 1
	register unsigned short volatile *x, *y, z; 
d114 2
a115 2
	x = (unsigned short *) src; 
	y = (unsigned short *) dst; 
@


1.13
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.11 2001/11/06 00:30:38 art Exp $ */
d64 1
a64 1
#include <machine/mmu.h>		/* DMA_CACHE_SYNC, etc... */
@


1.13.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.15 2002/01/14 21:34:39 miod Exp $ */
d64 1
a64 1
#include <machine/cmmu.h>		/* DMA_CACHE_SYNC, etc... */
d110 1
a110 2
	register unsigned short *volatile x, *volatile y;
	register unsigned short volatile z; 
d113 2
a114 2
	x = (unsigned short *)src; 
	y = (unsigned short *)dst; 
@


1.13.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.13.2.1 2002/01/31 22:55:18 niklas Exp $ */
d71 17
a87 17
int  vs_checkintr(struct vs_softc *, struct scsi_xfer *, int *);
void vs_chksense(struct scsi_xfer *);
void vs_reset(struct vs_softc *);
void vs_resync(struct vs_softc *);
int  vs_initialize(struct vs_softc *);
int  vs_nintr(struct vs_softc *);
int  vs_eintr(struct vs_softc *);
int  vs_poll(struct vs_softc *, struct scsi_xfer *);
void vs_scsidone(struct vs_softc *, struct scsi_xfer *, int);
M328_CQE  * vs_getcqe(struct vs_softc *);
M328_IOPB * vs_getiopb(struct vs_softc *);
void vs_copy(void *, void *, unsigned short);
void vs_zero(void *, u_long);
int do_vspoll(struct vs_softc *, int);
void thaw_queue(struct vs_softc *, u_int8_t);
void vs_link_sg_element(sg_list_element_t *, vm_offset_t, int);
void vs_link_sg_list(sg_list_element_t *, vm_offset_t, int);
d89 1
a89 1
static __inline__ void vs_clear_return_info(struct vs_softc *);
@


1.13.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.13.2.2 2002/06/11 03:37:10 art Exp $ */
d998 2
a999 2
	 *	virt			the virtual address of the contiguous virtual memory block
	 *	len			the length of the contiguous virtual memory block
@


1.13.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d809 1
a809 1
	 * to point to address 0.  Controller error should be handled
@


1.12
log
@Support for MVME197 completed.  Fix SPL defs.
@
text
@a58 1
#include <machine/cmmu.h>
@


1.11
log
@Kill vm/vm_param.h, move it to uvm/uvm_param.h
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.10 2001/08/31 01:52:19 miod Exp $ */
d59 1
@


1.10
log
@Assorted changes to really let non-DDB kernels (such as the future RAMDISK,
hint, hint) compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.9 2001/08/26 02:37:07 miod Exp $ */
d52 1
a52 1
#include <vm/vm_param.h>
@


1.9
log
@Add prototypes, fix compilation warnings, random style fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.8 2001/06/25 00:43:14 mickey Exp $ */
d896 1
d898 1
@


1.8
log
@cold is in systm now
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.7 2001/06/14 21:30:35 miod Exp $ */
d61 4
a64 4
   #include <mvme88k/dev/vsreg.h>
   #include <mvme88k/dev/vsvar.h>
   #include <mvme88k/dev/vme.h>		/* vme_findvec() */
   #include <machine/mmu.h>		/* DMA_CACHE_SYNC, etc... */
d66 3
a68 3
   #include <mvme68k/dev/vsreg.h>
   #include <mvme68k/dev/vsvar.h>
   #include <mvme68k/dev/vme.h>		/* vme_findvec() */
d82 6
a90 2
extern u_int   kvtop();

d432 1
a432 1
	LV(miopb->iopb_BUFF, kvtop(&xs->sense));
d1006 1
a1006 1
	point1_phys = starting_point_phys = kvtop(xs->data);
@


1.7
log
@Big cleanup of VM issues:
o get rid of m88k_foo macros when there is an mi foo macro
o remove the ability, for the pmap module, to handle a native mmu page
  size different from the vm module page size. This allows some
  optimizations in pmap.c
o remove dead stuff from <machine/vmparam.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.6 2001/05/16 12:49:47 ho Exp $ */
a84 1
extern int cold;
@


1.6
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.5 2001/03/09 05:44:39 smurph Exp $ */
d51 3
d56 1
d60 1
a60 2
#if defined(MVME187) || defined(MVME188) || defined(MVME197)
   #define PAGESIZE 4096
a64 2
   #define ROUND_PAGE m88k_round_page
   #define TRUNC_PAGE m88k_trunc_page
d69 1
a69 3
   #define ROUND_PAGE m68k_round_page
   #define TRUNC_PAGE m68k_trunc_page
#endif /* MVME187 */
d325 1
a325 1
	 * Since the 187 doesn't support cache snooping, we have
d330 1
a330 1
#if defined(MVME187) || defined(MVME188) || defined(MVME197)
d336 1
a336 1
#if defined(MVME187) || defined(MVME188) || defined(MVME197)
d1009 2
a1010 2
	if (len > PAGESIZE) {
		for (level = 0, point_virt = ROUND_PAGE(starting_point_virt+1);
d1013 1
a1013 1
		    point_virt += PAGESIZE) {			   /* out later */
d1017 1
a1017 1
			if ((point2_phys - TRUNC_PAGE(point1_phys) - PAGESIZE) ||		   /* physical memory is not contiguous */
d1020 2
a1021 2
					assert( MAX_SG_BLOCK_SIZE > PAGESIZE );
					point_virt = TRUNC_PAGE(starting_point_virt+MAX_SG_BLOCK_SIZE-1);    /* So go back to the beginning of the last matching page */
@


1.5
log
@kernel will compile with -Werror.  Added intr.h
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.4 2001/03/08 00:03:15 miod Exp $ */
a929 4
	assert ( sg );
	if ( !sg ) {
		panic ("Memory for scatter_gather_list not available");
	}
@


1.4
log
@Some warning hunting.
Define new include files for convenience, for use by drivers who can
attach either to pcctwo or syscon, or need bug console routines.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.3 2001/02/01 03:38:16 smurph Exp $ */
d104 3
a106 3
void *src;
void *dst;
unsigned short cnt;
d121 2
a122 2
void *src;
u_long cnt;
d142 1
a142 1
struct buf *bp;
d152 2
a153 2
struct vs_softc *sc;
int to;
d181 2
a182 2
struct vs_softc *sc;
struct scsi_xfer *xs;
d215 2
a216 2
struct vs_softc *sc;
u_int8_t target;
d228 3
a230 3
struct vs_softc *sc;
struct scsi_xfer *xs;
int stat;                             
d252 1
a252 1
struct scsi_xfer *xs;
d401 1
a401 1
struct scsi_xfer *xs;
d456 1
a456 1
struct vs_softc *sc;
d473 1
a473 1
struct vs_softc *sc;
d491 1
a491 1
struct vs_softc *sc;
d603 1
a603 1
struct vs_softc *sc;
d642 1
a642 1
struct vs_softc *sc;
d688 3
a690 3
struct   vs_softc *sc;
struct scsi_xfer *xs;
int   *status;
d783 1
a783 1
register struct vs_softc *sc;
d832 1
a832 1
register struct vs_softc *sc;
d912 1
a912 1
register struct vs_softc *sc;
d941 1
a941 1
M328_SG sg;
d955 3
a957 3
sg_list_element_t *element;
register vm_offset_t phys_add;
register int len;
d969 3
a971 3
sg_list_element_t *list;
register vm_offset_t phys_add;
register int elements;
d984 2
a985 2
struct scsi_xfer *xs;
M328_IOPB  *iopb;	       /* the iopb */
@


1.3
log
@Major changes to get MVME188 working.  More header and code cleanups.  The
kernel is tested on MVME188A/2P256 and MVME188A/1P64.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.2 1999/09/27 18:43:25 smurph Exp $ */
d73 1
a73 1
int  vs_chksense         __P((struct scsi_xfer *));
a183 9
	M328_CIB *cib = (M328_CIB *)&sc->sc_vsreg->sh_CIB;
	M328_CQE *mc = (M328_CQE*)&sc->sc_vsreg->sh_MCE;
	M328_CRB *crb = (M328_CRB *)&sc->sc_vsreg->sh_CRB;
	M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
	M328_IOPB *miopb = (M328_IOPB *)&sc->sc_vsreg->sh_MCE_IOPB;
	M328_MCSB *mcsb = (M328_MCSB *)&sc->sc_vsreg->sh_MCSB;
	M328_CQE *cqep;
	M328_IOPB *iopb;
	int i;
a184 1
	int s;
a232 1
	struct scsi_link *slp = xs->sc_link;
d256 1
a256 1
	int flags, s, i;
a260 1
	M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
a261 1
	M328_MCSB *mcsb = (M328_MCSB *)&sc->sc_vsreg->sh_MCSB;
d399 1
a399 1
int
d403 1
a403 1
	int flags, s, i;
a643 1
	struct vsreg * rp;
a644 6
	u_char  i;
	struct iopb_reset* iopr;
	struct cqe *cqep;
	struct iopb_scsi *iopbs;
	struct scsi_sense *ss;
	M328_CIB *cib = (M328_CIB *)&sc->sc_vsreg->sh_CIB;
a645 1
	M328_CRB *crb = (M328_CRB *)&sc->sc_vsreg->sh_CRB;
a646 1
	M328_MCSB *mcsb = (M328_MCSB *)&sc->sc_vsreg->sh_MCSB;
a647 1
	M328_IOPB *iopb;
a691 1
	struct vsreg * rp = sc->sc_vsreg;
a693 1
	M328_CRB *crb = (M328_CRB *)&sc->sc_vsreg->sh_CRB;
a785 1
	M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
d838 1
d842 1
@


1.2
log
@adding support for MVME188 and MVME197.  Plus 32bit if_ie.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.1 1999/05/29 04:41:44 smurph Exp $ */
d60 2
a61 1
   #include "machine/mmu.h"
d67 1
d76 3
a78 2
void vs_initialize       __P((struct vs_softc *));
int  vs_intr             __P((struct vs_softc *));
d80 1
a80 1
void vs_scsidone         __P((struct scsi_xfer *, int));
d84 2
d88 1
d103 4
a106 1
scopy(void *src, void *dst, unsigned short cnt) 
d108 1
a108 1
   register unsigned short volatile *x, *y, z; 
d110 7
a116 7
   z = cnt >> 1; 
   x = (unsigned short *) src; 
   y = (unsigned short *) dst; 

   while (z--) {
      *y++ = *x++; 
   }
d120 3
a122 1
szero(void *src, u_long cnt)
d124 11
a134 11
   register unsigned short *source;
   register unsigned short zero = 0;
   register unsigned short z; 

   source = (unsigned short *) src;
   z = cnt >> 1; 

   while (z--) {
      *source++ = zero;
   }
   return;
a136 4




d144 4
a147 4
   /*
    * No max transfer at this level.
    */
   minphys(bp);
d150 2
a151 1
int do_vspoll(sc, to)
d155 9
a163 9
   int i;
   if (to <= 0 ) to = 50000;
   /* use cmd_wait values? */
   i = 50000;
   /*spl0();*/
   while (!(CRSW & (M_CRSW_CRBV | M_CRSW_CC))) {
      if (--i <= 0) {
#ifdef DEBUG
         printf ("waiting: timeout %d crsw 0x%x\n", to, CRSW);
d165 12
a176 12
         i = 50000;
         --to;
         if (to <= 0) {
            /*splx(s);*/
            vs_reset(sc);
            vs_resync(sc);
            printf ("timed out: timeout %d crsw 0x%x\n", to, CRSW);
            return 1;
         }
      }
   }
   return 0;
d184 37
a220 26
   M328_CIB *cib = (M328_CIB *)&sc->sc_vsreg->sh_CIB;
   M328_CQE *mc = (M328_CQE*)&sc->sc_vsreg->sh_MCE;
   M328_CRB *crb = (M328_CRB *)&sc->sc_vsreg->sh_CRB;
   M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
   M328_IOPB *miopb = (M328_IOPB *)&sc->sc_vsreg->sh_MCE_IOPB;
   M328_MCSB *mcsb = (M328_MCSB *)&sc->sc_vsreg->sh_MCSB;
   M328_CQE *cqep;
   M328_IOPB *iopb;
   int i;
   int status;
   int s;
   int to;

   /*s = splbio();*/
   to = xs->timeout / 1000;
   for (;;) {
      if (do_vspoll(sc, to)) break;
      if (vs_checkintr(sc, xs, &status)) {
         vs_scsidone(xs, status);
      }
      if (CRSW & M_CRSW_ER)
         CRB_CLR_ER(CRSW);
      CRB_CLR_DONE(CRSW);
      if (xs->flags & ITSDONE) break;
   }
   return (COMPLETE);
d223 2
a224 1
void thaw_queue(sc, target)
d228 6
a233 6
   u_short t;
   t = target << 8;
   t |= 0x0001;
   THAW_REG = t;
   /* loop until thawed */
   while (THAW_REG & 0x01);
d237 2
a238 1
vs_scsidone (xs, stat)
d242 17
a258 16
   struct scsi_link *slp = xs->sc_link;
   struct vs_softc *sc = slp->adapter_softc;
   M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
   xs->status = stat;
   while (xs->status == SCSI_CHECK) {
      vs_chksense(xs);
      thaw_queue(sc, slp->target + 1);
   }
   xs->flags |= ITSDONE;
   /*sc->sc_tinfo[slp->target].cmds++;*/
   if (CRSW & M_CRSW_ER)
      CRB_CLR_ER(CRSW);
   CRB_CLR_DONE(CRSW);
   thaw_queue(sc, slp->target + 1);
   szero(riopb, sizeof(M328_IOPB));
   scsi_done(xs);
d265 16
a280 21
   struct scsi_link *slp = xs->sc_link;
   struct vs_softc *sc = slp->adapter_softc;
   int flags, s, i;
   unsigned long buf, len;
   u_short iopb_len;
   M328_CQE *mc = (M328_CQE*)&sc->sc_vsreg->sh_MCE;
   M328_CRB *crb = (M328_CRB *)&sc->sc_vsreg->sh_CRB;
   M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
   M328_IOPB *miopb = (M328_IOPB *)&sc->sc_vsreg->sh_MCE_IOPB;
   M328_MCSB *mcsb = (M328_MCSB *)&sc->sc_vsreg->sh_MCSB;
   M328_CQE *cqep;
   M328_IOPB *iopb;
   M328_CMD *m328_cmd;

   /* If the target doesn't exist, abort */
   if (!sc->sc_tinfo[slp->target].avail) {
      xs->error = XS_SELTIMEOUT;
      xs->status = -1;
      xs->flags |= ITSDONE;
      scsi_done(xs);
   }
a281 2
   slp->quirks |= SDEV_NOLUNS;
   flags = xs->flags;
d283 32
a314 32
   printf("scsi_cmd() ");
   if (xs->cmd->opcode == 0) {
      printf("TEST_UNIT_READY ");
   } else if (xs->cmd->opcode == REQUEST_SENSE) {
      printf("REQUEST_SENSE   ");
   } else if (xs->cmd->opcode == INQUIRY) {
      printf("INQUIRY         ");
   } else if (xs->cmd->opcode == MODE_SELECT) {
      printf("MODE_SELECT     ");
   } else if (xs->cmd->opcode == MODE_SENSE) {
      printf("MODE_SENSE      ");
   } else if (xs->cmd->opcode == START_STOP) {
      printf("START_STOP      ");
   } else if (xs->cmd->opcode == RESERVE) {
      printf("RESERVE         ");
   } else if (xs->cmd->opcode == RELEASE) {
      printf("RELEASE         ");
   } else if (xs->cmd->opcode == PREVENT_ALLOW) {
      printf("PREVENT_ALLOW   ");
   } else if (xs->cmd->opcode == POSITION_TO_ELEMENT) {
      printf("POSITION_TO_EL  ");
   } else if (xs->cmd->opcode == CHANGE_DEFINITION) {
      printf("CHANGE_DEF      ");
   } else if (xs->cmd->opcode == MODE_SENSE_BIG) {
      printf("MODE_SENSE_BIG  ");
   } else if (xs->cmd->opcode == MODE_SELECT_BIG) {
      printf("MODE_SELECT_BIG ");
   } else if (xs->cmd->opcode == 0x25) {
      printf("READ_CAPACITY   ");
   } else if (xs->cmd->opcode == 0x08) {
      printf("READ_COMMAND    ");
   }
d316 31
a346 36
   if (flags & SCSI_POLL) {
      cqep = mc;
      iopb = miopb;
   } else {
      cqep = vs_getcqe(sc);
      iopb = vs_getiopb(sc);
   }
   if (cqep == NULL) {
      xs->error = XS_DRIVER_STUFFUP;
      return (TRY_AGAIN_LATER);
   }

/*	s = splbio();*/
   iopb_len = sizeof(M328_short_IOPB) + xs->cmdlen;
   szero(iopb, sizeof(M328_IOPB));

   scopy(xs->cmd, &iopb->iopb_SCSI[0], xs->cmdlen);
   iopb->iopb_CMD = IOPB_SCSI;
#if 0
   LV(iopb->iopb_BUFF, kvtop(xs->data));
   LV(iopb->iopb_LENGTH, xs->datalen);
#endif   
   iopb->iopb_UNIT = slp->lun << 3;
   iopb->iopb_UNIT |= slp->target;
   iopb->iopb_NVCT = (u_char)sc->sc_nvec;
   iopb->iopb_EVCT = (u_char)sc->sc_evec;

   /*
    * Since the 187 doesn't support cache snooping, we have
    * to flush the cache for a write and flush with inval for
    * a read, prior to starting the IO.
    */
   if (xs->flags & SCSI_DATA_IN) {  /* read */
#if defined(MVME187)
      dma_cachectl((vm_offset_t)xs->data, xs->datalen,
                   DMA_CACHE_SYNC_INVAL);
d348 5
a352 5
      iopb->iopb_OPTION |= OPT_READ;
   } else {                         /* write */
#if defined(MVME187)
      dma_cachectl((vm_offset_t)xs->data, xs->datalen,
                   DMA_CACHE_SYNC);
d354 2
a355 2
      iopb->iopb_OPTION |= OPT_WRITE;
   }
d357 40
a396 40
   if (flags & SCSI_POLL) {
      iopb->iopb_OPTION |= OPT_INTDIS;
      iopb->iopb_LEVEL = 0;
   } else {
      iopb->iopb_OPTION |= OPT_INTEN;
      iopb->iopb_LEVEL = sc->sc_ipl;
   }
   iopb->iopb_ADDR = ADDR_MOD;

   /*
    * Wait until we can use the command queue entry.
    * Should only have to wait if the master command 
    * queue entry is busy.
    */
   while (cqep->cqe_QECR & M_QECR_GO);

   cqep->cqe_IOPB_ADDR = OFF(iopb);
   cqep->cqe_IOPB_LENGTH = iopb_len;
   if (flags & SCSI_POLL) {
      cqep->cqe_WORK_QUEUE = slp->target + 1;
   } else {
      cqep->cqe_WORK_QUEUE = slp->target + 1;
   }
   
   MALLOC(m328_cmd, M328_CMD*, sizeof(M328_CMD), M_DEVBUF, M_WAITOK);
   
   m328_cmd->xs = xs;
   if (xs->datalen) {
      m328_cmd->top_sg_list = vs_build_memory_structure(xs, iopb);
   } else {
      m328_cmd->top_sg_list = (M328_SG)0;
   }

   LV(cqep->cqe_CTAG, m328_cmd);

   if (crb->crb_CRSW & M_CRSW_AQ) {
      cqep->cqe_QECR = M_QECR_AA;
   }
   VL(buf, iopb->iopb_BUFF);
   VL(len, iopb->iopb_LENGTH);
d398 3
a400 2
   printf("tgt %d lun %d buf %x len %d wqn %d ipl %d\n", slp->target, 
          slp->lun, buf, len, cqep->cqe_WORK_QUEUE, iopb->iopb_LEVEL);
d402 1
a402 1
   cqep->cqe_QECR |= M_QECR_GO;
d404 6
a409 8
   if (flags & SCSI_POLL) {
      /* poll for the command to complete */
/*      splx(s);*/
      vs_poll(sc, xs);
      return (COMPLETE);
   }
/*	splx(s);*/
   return (SUCCESSFULLY_QUEUED);
d416 45
a460 44
   int flags, s, i;
   struct scsi_link *slp = xs->sc_link;
   struct vs_softc *sc = slp->adapter_softc;
   struct scsi_sense *ss;
   M328_CQE *mc = (M328_CQE*)&sc->sc_vsreg->sh_MCE;
   M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
   M328_IOPB *miopb = (M328_IOPB *)&sc->sc_vsreg->sh_MCE_IOPB;

   /* ack and clear the error */
   CRB_CLR_DONE(CRSW);
   CRB_CLR_ER(CRSW);
   xs->status = 0;

   szero(miopb, sizeof(M328_IOPB));
   /* This is a command, so point to it */
   ss = (void *)&miopb->iopb_SCSI[0];
   szero(ss, sizeof(*ss));
   ss->opcode = REQUEST_SENSE;
   ss->byte2 = slp->lun << 5;
   ss->length = sizeof(struct scsi_sense_data);

   miopb->iopb_CMD = IOPB_SCSI;
   miopb->iopb_OPTION = OPT_READ;
   miopb->iopb_NVCT = (u_char)sc->sc_nvec;
   miopb->iopb_EVCT = (u_char)sc->sc_evec;
   miopb->iopb_LEVEL = 0; /*sc->sc_ipl;*/
   miopb->iopb_ADDR = ADDR_MOD;
   LV(miopb->iopb_BUFF, kvtop(&xs->sense));
   LV(miopb->iopb_LENGTH, sizeof(struct scsi_sense_data));

   szero(mc, sizeof(M328_CQE));
   mc->cqe_IOPB_ADDR = OFF(miopb);
   mc->cqe_IOPB_LENGTH = sizeof(M328_short_IOPB) + sizeof(struct scsi_sense);
   mc->cqe_WORK_QUEUE = 0;
   mc->cqe_QECR = M_QECR_GO;
   /* poll for the command to complete */
   s = splbio();
   do_vspoll(sc, 0);
   /*
   if (xs->cmd->opcode != PREVENT_ALLOW) {
      xs->error = XS_SENSE;
   }
   */
   xs->status = riopb->iopb_STATUS >> 8;
d462 1
a462 1
   scsi_print_sense(xs, 2);
d464 1
a464 1
   splx(s);
d471 2
a472 2
   M328_MCSB *mcsb = (M328_MCSB *)&sc->sc_vsreg->sh_MCSB;
   M328_CQE *cqep;
d474 1
a474 1
   cqep = (M328_CQE *)&sc->sc_vsreg->sh_CQE[mcsb->mcsb_QHDP];
d476 6
a481 6
   if (cqep->cqe_QECR & M_QECR_GO)
      return NULL; /* Hopefully, this will never happen */
   mcsb->mcsb_QHDP++;
   if (mcsb->mcsb_QHDP == NUM_CQE) mcsb->mcsb_QHDP = 0;
   szero(cqep, sizeof(M328_CQE));
   return cqep;
d488 12
a499 12
   M328_MCSB *mcsb = (M328_MCSB *)&sc->sc_vsreg->sh_MCSB;
   M328_IOPB *iopb;
   int slot;

   if (mcsb->mcsb_QHDP == 0) {
      slot = NUM_CQE;
   } else {
      slot = mcsb->mcsb_QHDP - 1;
   }
   iopb = (M328_IOPB *)&sc->sc_vsreg->sh_IOPB[slot];
   szero(iopb, sizeof(M328_IOPB));
   return iopb;
d502 1
a502 1
void
d506 106
a611 104
   M328_CIB *cib = (M328_CIB *)&sc->sc_vsreg->sh_CIB;
   M328_CQE *mc = (M328_CQE*)&sc->sc_vsreg->sh_MCE;
   M328_CRB *crb = (M328_CRB *)&sc->sc_vsreg->sh_CRB;
   M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
   M328_MCSB *mcsb = (M328_MCSB *)&sc->sc_vsreg->sh_MCSB;
   M328_IOPB *iopb;
   M328_WQCF *wiopb = (M328_WQCF *)&sc->sc_vsreg->sh_MCE_IOPB;
   u_short i, crsw;
   int failed = 0;

   CRB_CLR_DONE(CRSW);
   szero(cib, sizeof(M328_CIB));
   mcsb->mcsb_QHDP = 0;
   sc->sc_qhp = 0;
   cib->cib_NCQE = 10;
   cib->cib_BURST = 0;
   cib->cib_NVECT = sc->sc_ipl << 8;
   cib->cib_NVECT |= sc->sc_nvec;
   cib->cib_EVECT = sc->sc_ipl << 8;
   cib->cib_EVECT |= sc->sc_evec;
   cib->cib_PID = 0x07;
   cib->cib_SID = 0x00;
   cib->cib_CRBO = OFF(crb);
   cib->cib_SELECT_msw = HI(SELECTION_TIMEOUT);
   cib->cib_SELECT_lsw = LO(SELECTION_TIMEOUT);
   cib->cib_WQ0TIMO_msw = HI(4);
   cib->cib_WQ0TIMO_lsw = LO(4);
   cib->cib_VMETIMO_msw = 0; /*HI(VME_BUS_TIMEOUT);*/
   cib->cib_VMETIMO_lsw = 0; /*LO(VME_BUS_TIMEOUT);*/
   cib->cib_SBRIV = sc->sc_ipl << 8;
   cib->cib_SBRIV |= sc->sc_evec;
   cib->cib_SOF0 = 0x15;
   cib->cib_SRATE0 = 100/4;
   cib->cib_SOF1 = 0x0;
   cib->cib_SRATE1 = 0x0;

   iopb = (M328_IOPB *)&sc->sc_vsreg->sh_MCE_IOPB;
   szero(iopb, sizeof(M328_IOPB));
   iopb->iopb_CMD = CNTR_INIT;
   iopb->iopb_OPTION = 0;
   iopb->iopb_NVCT = (u_char)sc->sc_nvec;
   iopb->iopb_EVCT = (u_char)sc->sc_evec;
   iopb->iopb_LEVEL = 0; /*sc->sc_ipl;*/
   iopb->iopb_ADDR = SHIO_MOD;
   LV(iopb->iopb_BUFF, OFF(cib));
   LV(iopb->iopb_LENGTH, sizeof(M328_CIB));

   szero(mc, sizeof(M328_CQE));
   mc->cqe_IOPB_ADDR = OFF(iopb);
   mc->cqe_IOPB_LENGTH = sizeof(M328_IOPB);
   mc->cqe_WORK_QUEUE = 0;
   mc->cqe_QECR = M_QECR_GO;
   /* poll for the command to complete */
   do_vspoll(sc, 0);
   CRB_CLR_DONE(CRSW);

   /* initialize work queues */
   for (i=1; i<8; i++) {
      szero(wiopb, sizeof(M328_IOPB));
      wiopb->wqcf_CMD = CNTR_INIT_WORKQ;
      wiopb->wqcf_OPTION = 0;
      wiopb->wqcf_NVCT = (u_char)sc->sc_nvec;
      wiopb->wqcf_EVCT = (u_char)sc->sc_evec;
      wiopb->wqcf_ILVL = 0; /*sc->sc_ipl;*/
      wiopb->wqcf_WORKQ = i;
      wiopb->wqcf_WOPT = (WQO_FOE | WQO_INIT);
      wiopb->wqcf_SLOTS = JAGUAR_MAX_Q_SIZ;
      LV(wiopb->wqcf_CMDTO, 2);

      szero(mc, sizeof(M328_CQE));
      mc->cqe_IOPB_ADDR = OFF(wiopb);
      mc->cqe_IOPB_LENGTH = sizeof(M328_IOPB);
      mc->cqe_WORK_QUEUE = 0;
      mc->cqe_QECR = M_QECR_GO;
      /* poll for the command to complete */
      do_vspoll(sc, 0);
      if (CRSW & M_CRSW_ER) {
         /*printf("\nerror: queue %d status = 0x%x\n", i, riopb->iopb_STATUS);*/
         /*failed = 1;*/
         CRB_CLR_ER(CRSW);
      }
      CRB_CLR_DONE(CRSW);
      delay(500);
   }
   /* start queue mode */
   CRSW = 0;
   mcsb->mcsb_MCR |= M_MCR_SQM;
   crsw = CRSW;
   do_vspoll(sc, 0);
   if (CRSW & M_CRSW_ER) {
      printf("error: status = 0x%x\n", riopb->iopb_STATUS);
      CRB_CLR_ER(CRSW);
   }
   CRB_CLR_DONE(CRSW);

   if (failed) {
      printf(": failed!\n");
      return;
   }
   /* reset SCSI bus */
   vs_reset(sc);
   /* sync all devices */
   vs_resync(sc);
   printf(": target %d\n", sc->sc_link.adapter_target);
d618 33
a650 31
   M328_CQE *mc = (M328_CQE*)&sc->sc_vsreg->sh_MCE;
   M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
   M328_DRCF *devreset = (M328_DRCF *)&sc->sc_vsreg->sh_MCE_IOPB;  
   u_short i;

   for (i=0; i<7; i++) {
      szero(devreset, sizeof(M328_DRCF));
      devreset->drcf_CMD = CNTR_DEV_REINIT;
      devreset->drcf_OPTION = 0x00;       /* no interrupts yet... */
      devreset->drcf_NVCT = sc->sc_nvec;
      devreset->drcf_EVCT = sc->sc_evec;
      devreset->drcf_ILVL = 0;
      devreset->drcf_UNIT = i;

      szero(mc, sizeof(M328_CQE));
      mc->cqe_IOPB_ADDR = OFF(devreset);
      mc->cqe_IOPB_LENGTH = sizeof(M328_DRCF);
      mc->cqe_WORK_QUEUE = 0;
      mc->cqe_QECR = M_QECR_GO;
      /* poll for the command to complete */
      do_vspoll(sc, 0);
      if (riopb->iopb_STATUS) {
         sc->sc_tinfo[i].avail = 0;
      } else {
         sc->sc_tinfo[i].avail = 1;
      }
      if (CRSW & M_CRSW_ER) {
         CRB_CLR_ER(CRSW);
      }
      CRB_CLR_DONE(CRSW);
   }
d657 44
a700 44
   struct vsreg * rp;
   u_int s;
   u_char  i;
   struct iopb_reset* iopr;
   struct cqe *cqep;
   struct iopb_scsi *iopbs;
   struct scsi_sense *ss;
   M328_CIB *cib = (M328_CIB *)&sc->sc_vsreg->sh_CIB;
   M328_CQE *mc = (M328_CQE*)&sc->sc_vsreg->sh_MCE;
   M328_CRB *crb = (M328_CRB *)&sc->sc_vsreg->sh_CRB;
   M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
   M328_MCSB *mcsb = (M328_MCSB *)&sc->sc_vsreg->sh_MCSB;
   M328_SRCF *reset = (M328_SRCF *)&sc->sc_vsreg->sh_MCE_IOPB;  
   M328_IOPB *iopb;

   szero(reset, sizeof(M328_SRCF));
   reset->srcf_CMD = IOPB_RESET;
   reset->srcf_OPTION = 0x00;       /* no interrupts yet... */
   reset->srcf_NVCT = sc->sc_nvec;
   reset->srcf_EVCT = sc->sc_evec;
   reset->srcf_ILVL = 0;
   reset->srcf_BUSID = 0;
   s = splbio();

   szero(mc, sizeof(M328_CQE));
   mc->cqe_IOPB_ADDR = OFF(reset);
   mc->cqe_IOPB_LENGTH = sizeof(M328_SRCF);
   mc->cqe_WORK_QUEUE = 0;
   mc->cqe_QECR = M_QECR_GO;
   /* poll for the command to complete */
   while (1) {
      do_vspoll(sc, 0);
      /* ack & clear scsi error condition cause by reset */
      if (CRSW & M_CRSW_ER) {
         CRB_CLR_ER(CRSW);
         CRB_CLR_DONE(CRSW);
         riopb->iopb_STATUS = 0;
         break;
      }
      CRB_CLR_DONE(CRSW);
   }
   /* thaw all work queues */
   thaw_queue(sc, 0xFF);
   splx (s);
a702 1

d715 18
a732 18
   struct vsreg * rp = sc->sc_vsreg;
   int   target = -1;
   int   lun = -1;
   M328_CRB *crb = (M328_CRB *)&sc->sc_vsreg->sh_CRB;
   M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
   struct scsi_generic *cmd;
   u_long buf;
   u_long len;
   u_char error;

   target = xs->sc_link->target;
   lun = xs->sc_link->lun;
   cmd = (struct scsi_generic *)&riopb->iopb_SCSI[0];

   VL(buf, riopb->iopb_BUFF);
   VL(len, riopb->iopb_LENGTH);
   *status = riopb->iopb_STATUS >> 8;
   error = riopb->iopb_STATUS & 0xFF;
d735 1
a735 1
   printf("scsi_chk() ");
d737 53
a789 53
   if (xs->cmd->opcode == 0) {
      printf("TEST_UNIT_READY ");
   } else if (xs->cmd->opcode == REQUEST_SENSE) {
      printf("REQUEST_SENSE   ");
   } else if (xs->cmd->opcode == INQUIRY) {
      printf("INQUIRY         ");
   } else if (xs->cmd->opcode == MODE_SELECT) {
      printf("MODE_SELECT     ");
   } else if (xs->cmd->opcode == MODE_SENSE) {
      printf("MODE_SENSE      ");
   } else if (xs->cmd->opcode == START_STOP) {
      printf("START_STOP      ");
   } else if (xs->cmd->opcode == RESERVE) {
      printf("RESERVE         ");
   } else if (xs->cmd->opcode == RELEASE) {
      printf("RELEASE         ");
   } else if (xs->cmd->opcode == PREVENT_ALLOW) {
      printf("PREVENT_ALLOW   ");
   } else if (xs->cmd->opcode == POSITION_TO_ELEMENT) {
      printf("POSITION_TO_EL  ");
   } else if (xs->cmd->opcode == CHANGE_DEFINITION) {
      printf("CHANGE_DEF      ");
   } else if (xs->cmd->opcode == MODE_SENSE_BIG) {
      printf("MODE_SENSE_BIG  ");
   } else if (xs->cmd->opcode == MODE_SELECT_BIG) {
      printf("MODE_SELECT_BIG ");
   } else if (xs->cmd->opcode == 0x25) {
      printf("READ_CAPACITY   ");
   } else if (xs->cmd->opcode == 0x08) {
      printf("READ_COMMAND    ");
   }

   printf("tgt %d lun %d buf %x len %d status %x ", target, lun, buf, len, riopb->iopb_STATUS);

   if (CRSW & M_CRSW_EX) {
      printf("[ex]");
   }
   if (CRSW & M_CRSW_QMS) {
      printf("[qms]");
   }
   if (CRSW & M_CRSW_SC) {
      printf("[sc]");
   }
   if (CRSW & M_CRSW_SE) {
      printf("[se]");
   }
   if (CRSW & M_CRSW_AQ) {
      printf("[aq]");
   }
   if (CRSW & M_CRSW_ER) {
      printf("[er]");
   }
   printf("\n");
d791 12
a802 12
   if (len != xs->datalen) {
      xs->resid = xs->datalen - len;
   } else {
      xs->resid = 0;
   }

   if (error == SCSI_SELECTION_TO) {
      xs->error = XS_SELTIMEOUT;
      xs->status = -1;
      *status = -1;
   }
   return 1;
d805 1
d807 1
a807 1
vs_intr (sc)
d810 13
a822 8
   M328_CRB *crb = (M328_CRB *)&sc->sc_vsreg->sh_CRB;
   struct scsi_xfer *xs;
   M328_CMD *m328_cmd;
   unsigned long loc;
   int status;
   int s;
   s = splbio();
   /* Got a valid interrupt on this device */
d824 1
a824 1
   VL(loc, crb->crb_CTAG);
d826 2
a827 2
   printf("Interrupt!!! ");
   printf("loc == 0x%x\n", loc);
d829 113
a941 20
   /*
    * If this is a controller error, there won't be a m328_cmd
    * pointer in the CTAG feild.  Bad things happen if you try 
    * to point to address 0.  Controller error should be handeled
    * in vsdma.c  I'll change this soon - steve.
    */
   if (loc) {
      m328_cmd = (M328_CMD *)loc;
      xs = m328_cmd->xs;
      if (m328_cmd->top_sg_list) {
         vs_dealloc_scatter_gather(m328_cmd->top_sg_list);
         m328_cmd->top_sg_list = (M328_SG)0;
      }
      
      FREE(m328_cmd, M_DEVBUF); /* free the command tag */
      if (vs_checkintr (sc, xs, &status)) {
         vs_scsidone(xs, status);
      }
   }
   splx(s);
d951 1
a951 1
   M328_SG sg;
d953 6
a958 6
   MALLOC(sg, M328_SG, sizeof(struct m328_sg), M_DEVBUF, M_WAITOK);
   assert ( sg );
   if ( !sg ) {
      panic ("Memory for scatter_gather_list not available");
   }
   bzero(sg, sizeof(struct m328_sg));
d960 1
a960 1
   return (sg);
d964 2
a965 1
vs_dealloc_scatter_gather(M328_SG sg)
d967 1
a967 1
   register int i;
d969 6
a974 6
   if (sg->level > 0) {
      for (i=0; sg->down[i] && i<MAX_SG_ELEMENTS; i++) {
         vs_dealloc_scatter_gather(sg->down[i]);
      }
   }
   FREE(sg, M_DEVBUF);
d978 11
a988 10
vs_link_sg_element(sg_list_element_t * element,
                               register vm_offset_t       phys_add,
                               register int         len)
{
   element->count.bytes = len;
   LV(element->address, phys_add);
   element->link = 0; /* FALSE */
   element->transfer_type = NORMAL_TYPE;
   element->memory_type = LONG_TRANSFER;
   element->address_modifier = 0xD;
d992 4
a995 3
vs_link_sg_list(sg_list_element_t * list,
                            register vm_offset_t    phys_add,
                            register int      elements)
d998 6
a1003 6
   list->count.scatter.gather  = elements;
   LV(list->address, phys_add);
   list->link = 1;    /* TRUE */
   list->transfer_type = NORMAL_TYPE;
   list->memory_type = LONG_TRANSFER;
   list->address_modifier = 0xD;
a1005 1

d1009 1
a1009 1
M328_IOPB  *iopb;              /* the iopb */
d1011 48
a1058 48
   M328_SG   sg;
   vm_offset_t starting_point_virt, starting_point_phys, point_virt, 
      point1_phys, point2_phys, virt;
   unsigned len;
   int       level;

   sg = (M328_SG)0;   /* Hopefully we need no scatter/gather list */

   /*
    * We have the following things:
    *	virt			the virtuell address of the contiguous virtual memory block
    *	len			the lenght of the contiguous virtual memory block
    *	starting_point_virt	the virtual address of the contiguous *physical* memory block
    *	starting_point_phys	the *physical* address of the contiguous *physical* memory block
    *	point_virt		the pointer to the virtual memory we are checking at the moment
    *	point1_phys		the pointer to the *physical* memory we are checking at the moment
    *	point2_phys		the pointer to the *physical* memory we are checking at the moment
    */
   
   level = 0;
   virt = starting_point_virt = (vm_offset_t)xs->data;
   point1_phys = starting_point_phys = kvtop(xs->data);
   len = xs->datalen;
   /*
    * Check if we need scatter/gather
    */

   if (len > PAGESIZE) {
      for (level = 0, point_virt = ROUND_PAGE(starting_point_virt+1);
          /* if we do already scatter/gather we have to stay in the loop and jump */
          point_virt < virt + (vm_offset_t)len || sg ;
          point_virt += PAGESIZE) {                      /* out later */

         point2_phys = kvtop(point_virt);

         if ((point2_phys - TRUNC_PAGE(point1_phys) - PAGESIZE) ||                  /* physical memory is not contiguous */
             (point_virt - starting_point_virt >= MAX_SG_BLOCK_SIZE && sg)) {   /* we only can access (1<<16)-1 bytes in scatter/gather_mode */
            if (point_virt - starting_point_virt >= MAX_SG_BLOCK_SIZE) {           /* We were walking too far for one scatter/gather block ... */
               assert( MAX_SG_BLOCK_SIZE > PAGESIZE );
               point_virt = TRUNC_PAGE(starting_point_virt+MAX_SG_BLOCK_SIZE-1);    /* So go back to the beginning of the last matching page */
               /* and gererate the physadress of this location for the next time. */
               point2_phys = kvtop(point_virt);
            }

            if (!sg) {
               /* We allocate our fist scatter/gather list */
               sg = vs_alloc_scatter_gather();
            }
d1061 4
a1064 4
            if (sg->elements >= MAX_SG_ELEMENTS) {
               vs_dealloc_scatter_gather(sg);
               return (NULL);
            }
d1067 24
a1090 24
            while (sg->elements >= MAX_SG_ELEMENTS) {
               if (!sg->up) { /* If the list full in this layer ? */
                  sg->up = vs_alloc_scatter_gather();
                  sg->up->level = sg->level+1;
                  sg->up->down[0] = sg;
                  sg->up->elements = 1;
               }
               /* link this full list also in physical memory */
               vs_link_sg_list(&(sg->up->list[sg->up->elements-1]), 
                                           kvtop((vm_offset_t)sg->list),
                                           sg->elements);
               sg = sg->up;      /* Climb up */
            }
            while (sg->level) {  /* As long as we are not a the base level */
               register int i;

               i = sg->elements;
               /* We need a new element */
               sg->down[i] = vs_alloc_scatter_gather();  
               sg->down[i]->level = sg->level - 1;
               sg->down[i]->up = sg;
               sg->elements++;
               sg = sg->down[i]; /* Climb down */
            }
d1092 45
a1136 46

            if (point_virt < virt+(vm_offset_t)len) {
               /* linking element */
               vs_link_sg_element(&(sg->list[sg->elements]), 
                                  starting_point_phys, 
                                  point_virt-starting_point_virt);
               sg->elements++;
            } else {
               /* linking last element */
               vs_link_sg_element(&(sg->list[sg->elements]), 
                                  starting_point_phys, 
                                  (vm_offset_t)(virt+len)-starting_point_virt);
               sg->elements++;
               break;                         /* We have now collected all blocks */
            }
            starting_point_virt = point_virt;
            starting_point_phys = point2_phys;
         }
         point1_phys = point2_phys;
      }
   }

   /*
    * Climb up along the right side of the tree until we reach the top.
    */

   if (sg) {
      while (sg->up) {
         /* link this list also in physical memory */
         vs_link_sg_list(&(sg->up->list[sg->up->elements-1]), 
                         kvtop((vm_offset_t)sg->list),
                         sg->elements);
         sg = sg->up;                   /* Climb up */
      }

      iopb->iopb_OPTION |= M_OPT_SG;
      iopb->iopb_ADDR |= M_ADR_SG_LINK;
      LV(iopb->iopb_BUFF, kvtop((vm_offset_t)sg->list));
      LV(iopb->iopb_LENGTH, sg->elements);
      LV(iopb->iopb_SGTTL, len);
   } else { 
      /* no scatter/gather neccessary */
      LV(iopb->iopb_BUFF, starting_point_phys);
      LV(iopb->iopb_LENGTH, len);
   }
   return (sg);
a1137 1

@


1.2.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.5 2001/03/09 05:44:39 smurph Exp $ */
d60 1
a60 2
   #include <mvme88k/dev/vme.h>		/* vme_findvec() */
   #include <machine/mmu.h>		/* DMA_CACHE_SYNC, etc... */
a65 1
   #include <mvme68k/dev/vme.h>		/* vme_findvec() */
d71 1
a71 1
void vs_chksense         __P((struct scsi_xfer *));
d74 2
a75 3
int  vs_initialize       __P((struct vs_softc *));
int  vs_nintr            __P((struct vs_softc *));
int  vs_eintr            __P((struct vs_softc *));
d77 1
a77 1
void vs_scsidone         __P((struct vs_softc *, struct scsi_xfer *, int));
a80 2
static __inline__ void vs_clear_return_info __P((struct vs_softc *));

a82 1

d97 1
a97 4
vs_copy(src, dst, cnt)
	void *src;
	void *dst;
	unsigned short cnt;
d99 1
a99 1
	register unsigned short volatile *x, *y, z; 
d101 7
a107 7
	z = cnt >> 1; 
	x = (unsigned short *) src; 
	y = (unsigned short *) dst; 

	while (z--) {
		*y++ = *x++; 
	}
d111 1
a111 3
vs_zero(src, cnt)
	void *src;
	u_long cnt;
d113 11
a123 11
	register unsigned short *source;
	register unsigned short zero = 0;
	register unsigned short z; 

	source = (unsigned short *) src;
	z = cnt >> 1; 

	while (z--) {
		*source++ = zero;
	}
	return;
d126 4
d135 1
a135 1
	struct buf *bp;
d137 19
a155 20
	/*
	 * No max transfer at this level.
	 */
	minphys(bp);
}

int 
do_vspoll(sc, to)
	struct vs_softc *sc;
	int to;
{
	int i;
	if (to <= 0 ) to = 50000;
	/* use cmd_wait values? */
	i = 10000;
	/*spl0();*/
	while (!(CRSW & (M_CRSW_CRBV | M_CRSW_CC))) {
		if (--i <= 0) {
#ifdef SDEBUG2
			printf ("waiting: timeout %d crsw 0x%x\n", to, CRSW);
d157 12
a168 12
			i = 50000;
			--to;
			if (to <= 0) {
				/*splx(s);*/
				vs_reset(sc);
				vs_resync(sc);
				printf ("timed out: timeout %d crsw 0x%x\n", to, CRSW);
				return 1;
			}
		}
	}
	return 0;
d173 2
a174 2
	struct vs_softc *sc;
	struct scsi_xfer *xs;
d176 38
a213 27
	int status;
	int to;

	/*s = splbio();*/
	to = xs->timeout / 1000;
	for (;;) {
		if (do_vspoll(sc, to)) {
			xs->error = XS_SELTIMEOUT;
			xs->status = -1;
			xs->flags |= ITSDONE;
			/* clear the return information */
			vs_clear_return_info(sc);
			if (xs->flags & SCSI_POLL)
				return (COMPLETE);
			break;
		}
		if (vs_checkintr(sc, xs, &status)) {
			vs_scsidone(sc, xs, status);
		}
		if (CRSW & M_CRSW_ER)
			CRB_CLR_ER(CRSW);
		CRB_CLR_DONE(CRSW);
		if (xs->flags & ITSDONE) break;
	}
	/* clear the return information */
	vs_clear_return_info(sc);
	return (COMPLETE);
d217 20
a236 34
thaw_queue(sc, target)
	struct vs_softc *sc;
	u_int8_t target;
{
	u_short t;
	t = target << 8;
	t |= 0x0001;
	THAW_REG = t;
	/* loop until thawed */
	while (THAW_REG & 0x01);
}

void 
vs_scsidone (sc, xs, stat)
	struct vs_softc *sc;
	struct scsi_xfer *xs;
	int stat;                             
{
	int tgt; 
	xs->status = stat;

	while (xs->status == SCSI_CHECK) {
		vs_chksense(xs);
		tgt = xs->sc_link->target + 1;
		thaw_queue(sc, tgt);
	}

	tgt = xs->sc_link->target + 1;
	xs->flags |= ITSDONE;
	/*sc->sc_tinfo[slp->target].cmds++;*/
	
	/* thaw all work queues */
	thaw_queue(sc, tgt);
	scsi_done(xs);
d241 1
a241 1
	struct scsi_xfer *xs;
d243 21
a263 14
	struct scsi_link *slp = xs->sc_link;
	struct vs_softc *sc = slp->adapter_softc;
	int flags;
	unsigned long buf, len;
	u_short iopb_len;
	M328_CQE *mc = (M328_CQE*)&sc->sc_vsreg->sh_MCE;
	M328_CRB *crb = (M328_CRB *)&sc->sc_vsreg->sh_CRB;
	M328_IOPB *miopb = (M328_IOPB *)&sc->sc_vsreg->sh_MCE_IOPB;
	M328_CQE *cqep;
	M328_IOPB *iopb;
	M328_CMD *m328_cmd;

	slp->quirks |= SDEV_NOLUNS;
	flags = xs->flags;
d265 2
d268 32
a299 32
	printf("scsi_cmd() ");
	if (xs->cmd->opcode == 0) {
		printf("TEST_UNIT_READY ");
	} else if (xs->cmd->opcode == REQUEST_SENSE) {
		printf("REQUEST_SENSE   ");
	} else if (xs->cmd->opcode == INQUIRY) {
		printf("INQUIRY         ");
	} else if (xs->cmd->opcode == MODE_SELECT) {
		printf("MODE_SELECT     ");
	} else if (xs->cmd->opcode == MODE_SENSE) {
		printf("MODE_SENSE      ");
	} else if (xs->cmd->opcode == START_STOP) {
		printf("START_STOP      ");
	} else if (xs->cmd->opcode == RESERVE) {
		printf("RESERVE         ");
	} else if (xs->cmd->opcode == RELEASE) {
		printf("RELEASE         ");
	} else if (xs->cmd->opcode == PREVENT_ALLOW) {
		printf("PREVENT_ALLOW   ");
	} else if (xs->cmd->opcode == POSITION_TO_ELEMENT) {
		printf("POSITION_TO_EL  ");
	} else if (xs->cmd->opcode == CHANGE_DEFINITION) {
		printf("CHANGE_DEF      ");
	} else if (xs->cmd->opcode == MODE_SENSE_BIG) {
		printf("MODE_SENSE_BIG  ");
	} else if (xs->cmd->opcode == MODE_SELECT_BIG) {
		printf("MODE_SELECT_BIG ");
	} else if (xs->cmd->opcode == 0x25) {
		printf("READ_CAPACITY   ");
	} else if (xs->cmd->opcode == 0x08) {
		printf("READ_COMMAND    ");
	}
d301 36
a336 31
	if (flags & SCSI_POLL) {
		cqep = mc;
		iopb = miopb;
	} else {
		cqep = vs_getcqe(sc);
		iopb = vs_getiopb(sc);
	}
	if (cqep == NULL) {
		xs->error = XS_DRIVER_STUFFUP;
		return (TRY_AGAIN_LATER);
	}

	iopb_len = sizeof(M328_short_IOPB) + xs->cmdlen;
	vs_zero(iopb, sizeof(M328_IOPB));

	vs_copy(xs->cmd, &iopb->iopb_SCSI[0], xs->cmdlen);
	iopb->iopb_CMD = IOPB_SCSI;
	iopb->iopb_UNIT = slp->lun << 3;
	iopb->iopb_UNIT |= slp->target;
	iopb->iopb_NVCT = (u_char)sc->sc_nvec;
	iopb->iopb_EVCT = (u_char)sc->sc_evec;

	/*
	 * Since the 187 doesn't support cache snooping, we have
	 * to flush the cache for a write and flush with inval for
	 * a read, prior to starting the IO.
	 */
	if (xs->flags & SCSI_DATA_IN) {	 /* read */
#if defined(MVME187) || defined(MVME188) || defined(MVME197)
		dma_cachectl((vm_offset_t)xs->data, xs->datalen,
			     DMA_CACHE_SYNC_INVAL);
d338 5
a342 5
		iopb->iopb_OPTION |= OPT_READ;
	} else {			 /* write */
#if defined(MVME187) || defined(MVME188) || defined(MVME197)
		dma_cachectl((vm_offset_t)xs->data, xs->datalen,
			     DMA_CACHE_SYNC);
d344 2
a345 2
		iopb->iopb_OPTION |= OPT_WRITE;
	}
d347 40
a386 40
	if (flags & SCSI_POLL) {
		iopb->iopb_OPTION |= OPT_INTDIS;
		iopb->iopb_LEVEL = 0;
	} else {
		iopb->iopb_OPTION |= OPT_INTEN;
		iopb->iopb_LEVEL = sc->sc_ipl;
	}
	iopb->iopb_ADDR = ADDR_MOD;

	/*
	 * Wait until we can use the command queue entry.
	 * Should only have to wait if the master command 
	      * queue entry is busy and we are polling.
	 */
	while (cqep->cqe_QECR & M_QECR_GO);

	cqep->cqe_IOPB_ADDR = OFF(iopb);
	cqep->cqe_IOPB_LENGTH = iopb_len;
	if (flags & SCSI_POLL) {
		cqep->cqe_WORK_QUEUE = 0;
	} else {
		cqep->cqe_WORK_QUEUE = slp->target + 1;
	}

	MALLOC(m328_cmd, M328_CMD*, sizeof(M328_CMD), M_DEVBUF, M_WAITOK);

	m328_cmd->xs = xs;
	if (xs->datalen) {
		m328_cmd->top_sg_list = vs_build_memory_structure(xs, iopb);
	} else {
		m328_cmd->top_sg_list = (M328_SG)0;
	}

	LV(cqep->cqe_CTAG, m328_cmd);

	if (crb->crb_CRSW & M_CRSW_AQ) {
		cqep->cqe_QECR = M_QECR_AA;
	}
	VL(buf, iopb->iopb_BUFF);
	VL(len, iopb->iopb_LENGTH);
d388 2
a389 3
	printf("tgt %d lun %d buf %x len %d wqn %d ipl %d crsw 0x%x\n", 
	       slp->target, slp->lun, buf, len, cqep->cqe_WORK_QUEUE, 
	       iopb->iopb_LEVEL, crb->crb_CRSW);
d391 1
a391 1
	cqep->cqe_QECR |= M_QECR_GO;
d393 8
a400 6
	if (flags & SCSI_POLL) {
		/* poll for the command to complete */
		vs_poll(sc, xs);
		return (COMPLETE);
	}
	return (SUCCESSFULLY_QUEUED);
d403 1
a403 1
void
d405 1
a405 1
	struct scsi_xfer *xs;
d407 44
a450 45
	int s;
	struct scsi_link *slp = xs->sc_link;
	struct vs_softc *sc = slp->adapter_softc;
	struct scsi_sense *ss;
	M328_CQE *mc = (M328_CQE*)&sc->sc_vsreg->sh_MCE;
	M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
	M328_IOPB *miopb = (M328_IOPB *)&sc->sc_vsreg->sh_MCE_IOPB;

	/* ack and clear the error */
	CRB_CLR_ER(CRSW);
	CRB_CLR_DONE(CRSW);
	xs->status = 0;

	vs_zero(miopb, sizeof(M328_IOPB));
	/* This is a command, so point to it */
	ss = (void *)&miopb->iopb_SCSI[0];
	vs_zero(ss, sizeof(*ss));
	ss->opcode = REQUEST_SENSE;
	ss->byte2 = slp->lun << 5;
	ss->length = sizeof(struct scsi_sense_data);

	miopb->iopb_CMD = IOPB_SCSI;
	miopb->iopb_OPTION = OPT_READ;
	miopb->iopb_NVCT = (u_char)sc->sc_nvec;
	miopb->iopb_EVCT = (u_char)sc->sc_evec;
	miopb->iopb_LEVEL = 0; /*sc->sc_ipl;*/
	miopb->iopb_ADDR = ADDR_MOD;
	LV(miopb->iopb_BUFF, kvtop(&xs->sense));
	LV(miopb->iopb_LENGTH, sizeof(struct scsi_sense_data));

	vs_zero(mc, sizeof(M328_CQE));
	mc->cqe_IOPB_ADDR = OFF(miopb);
	mc->cqe_IOPB_LENGTH = sizeof(M328_short_IOPB) + 
			      sizeof(struct scsi_sense);
	mc->cqe_WORK_QUEUE = 0;
	mc->cqe_QECR = M_QECR_GO;
	/* poll for the command to complete */
	s = splbio();
	do_vspoll(sc, 0);
	/*
	if (xs->cmd->opcode != PREVENT_ALLOW) {
	   xs->error = XS_SENSE;
	}
	*/
	xs->status = riopb->iopb_STATUS >> 8;
d452 1
a452 1
	scsi_print_sense(xs, 2);
d454 1
a454 1
	splx(s);
d459 1
a459 1
	struct vs_softc *sc;
d461 2
a462 2
	M328_MCSB *mcsb = (M328_MCSB *)&sc->sc_vsreg->sh_MCSB;
	M328_CQE *cqep;
d464 1
a464 1
	cqep = (M328_CQE *)&sc->sc_vsreg->sh_CQE[mcsb->mcsb_QHDP];
d466 6
a471 6
	if (cqep->cqe_QECR & M_QECR_GO)
		return NULL; /* Hopefully, this will never happen */
	mcsb->mcsb_QHDP++;
	if (mcsb->mcsb_QHDP == NUM_CQE)	mcsb->mcsb_QHDP = 0;
	vs_zero(cqep, sizeof(M328_CQE));
	return cqep;
d476 1
a476 1
	struct vs_softc *sc;
d478 12
a489 12
	M328_MCSB *mcsb = (M328_MCSB *)&sc->sc_vsreg->sh_MCSB;
	M328_IOPB *iopb;
	int slot;

	if (mcsb->mcsb_QHDP == 0) {
		slot = NUM_CQE;
	} else {
		slot = mcsb->mcsb_QHDP - 1;
	}
	iopb = (M328_IOPB *)&sc->sc_vsreg->sh_IOPB[slot];
	vs_zero(iopb, sizeof(M328_IOPB));
	return iopb;
d492 1
a492 1
int
d494 1
a494 1
	struct vs_softc *sc;
d496 104
a599 106
	M328_CIB *cib = (M328_CIB *)&sc->sc_vsreg->sh_CIB;
	M328_CQE *mc = (M328_CQE*)&sc->sc_vsreg->sh_MCE;
	M328_CRB *crb = (M328_CRB *)&sc->sc_vsreg->sh_CRB;
	M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
	M328_MCSB *mcsb = (M328_MCSB *)&sc->sc_vsreg->sh_MCSB;
	M328_IOPB *iopb;
	M328_WQCF *wiopb = (M328_WQCF *)&sc->sc_vsreg->sh_MCE_IOPB;
	u_short i, crsw;
	int failed = 0;

	CRB_CLR_DONE(CRSW);
	vs_zero(cib, sizeof(M328_CIB));
	mcsb->mcsb_QHDP = 0;
	sc->sc_qhp = 0;
	cib->cib_NCQE = 10;
	cib->cib_BURST = 0;
	cib->cib_NVECT = sc->sc_ipl << 8;
	cib->cib_NVECT |= sc->sc_nvec;
	cib->cib_EVECT = sc->sc_ipl << 8;
	cib->cib_EVECT |= sc->sc_evec;
	cib->cib_PID = 0x07;
	cib->cib_SID = 0x00;
	cib->cib_CRBO = OFF(crb);
	cib->cib_SELECT_msw = HI(SELECTION_TIMEOUT);
	cib->cib_SELECT_lsw = LO(SELECTION_TIMEOUT);
	cib->cib_WQ0TIMO_msw = HI(4);
	cib->cib_WQ0TIMO_lsw = LO(4);
	cib->cib_VMETIMO_msw = 0; /*HI(VME_BUS_TIMEOUT);*/
	cib->cib_VMETIMO_lsw = 0; /*LO(VME_BUS_TIMEOUT);*/
	cib->cib_ERR_FLGS = M_ERRFLGS_RIN | M_ERRFLGS_RSE;
	cib->cib_SBRIV = sc->sc_ipl << 8;
	cib->cib_SBRIV |= sc->sc_evec;
	cib->cib_SOF0 = 0x15;
	cib->cib_SRATE0 = 100/4;
	cib->cib_SOF1 = 0x0;
	cib->cib_SRATE1 = 0x0;

	iopb = (M328_IOPB *)&sc->sc_vsreg->sh_MCE_IOPB;
	vs_zero(iopb, sizeof(M328_IOPB));
	iopb->iopb_CMD = CNTR_INIT;
	iopb->iopb_OPTION = 0;
	iopb->iopb_NVCT = (u_char)sc->sc_nvec;
	iopb->iopb_EVCT = (u_char)sc->sc_evec;
	iopb->iopb_LEVEL = 0; /*sc->sc_ipl;*/
	iopb->iopb_ADDR = SHIO_MOD;
	LV(iopb->iopb_BUFF, OFF(cib));
	LV(iopb->iopb_LENGTH, sizeof(M328_CIB));

	vs_zero(mc, sizeof(M328_CQE));
	mc->cqe_IOPB_ADDR = OFF(iopb);
	mc->cqe_IOPB_LENGTH = sizeof(M328_IOPB);
	mc->cqe_WORK_QUEUE = 0;
	mc->cqe_QECR = M_QECR_GO;
	/* poll for the command to complete */
	do_vspoll(sc, 0);
	CRB_CLR_DONE(CRSW);

	/* initialize work queues */
	for (i=1; i<8; i++) {
		vs_zero(wiopb, sizeof(M328_IOPB));
		wiopb->wqcf_CMD = CNTR_INIT_WORKQ;
		wiopb->wqcf_OPTION = 0;
		wiopb->wqcf_NVCT = (u_char)sc->sc_nvec;
		wiopb->wqcf_EVCT = (u_char)sc->sc_evec;
		wiopb->wqcf_ILVL = 0; /*sc->sc_ipl;*/
		wiopb->wqcf_WORKQ = i;
		wiopb->wqcf_WOPT = (WQO_FOE | WQO_INIT);
		wiopb->wqcf_SLOTS = JAGUAR_MAX_Q_SIZ;
		LV(wiopb->wqcf_CMDTO, 4); /* 1 second */

		vs_zero(mc, sizeof(M328_CQE));
		mc->cqe_IOPB_ADDR = OFF(wiopb);
		mc->cqe_IOPB_LENGTH = sizeof(M328_IOPB);
		mc->cqe_WORK_QUEUE = 0;
		mc->cqe_QECR = M_QECR_GO;
		/* poll for the command to complete */
		do_vspoll(sc, 0);
		if (CRSW & M_CRSW_ER) {
			/*printf("\nerror: queue %d status = 0x%x\n", i, riopb->iopb_STATUS);*/
			/*failed = 1;*/
			CRB_CLR_ER(CRSW);
		}
		CRB_CLR_DONE(CRSW);
		delay(500);
	}
	/* start queue mode */
	CRSW = 0;
	mcsb->mcsb_MCR |= M_MCR_SQM;
	crsw = CRSW;
	do_vspoll(sc, 0);
	if (CRSW & M_CRSW_ER) {
		printf("error: status = 0x%x\n", riopb->iopb_STATUS);
		CRB_CLR_ER(CRSW);
	}
	CRB_CLR_DONE(CRSW);

	if (failed) {
		printf(": failed!\n");
		return (1);
	}
	/* reset SCSI bus */
	vs_reset(sc);
	/* sync all devices */
	vs_resync(sc);
	printf(": target %d\n", sc->sc_link.adapter_target);
	return (0); /* success */
d604 1
a604 1
	struct vs_softc *sc;
d606 31
a636 33
	M328_CQE *mc = (M328_CQE*)&sc->sc_vsreg->sh_MCE;
	M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
	M328_DRCF *devreset = (M328_DRCF *)&sc->sc_vsreg->sh_MCE_IOPB;  
	u_short i;
	for (i=0; i<7; i++) {
		vs_zero(devreset, sizeof(M328_DRCF));
		devreset->drcf_CMD = CNTR_DEV_REINIT;
		devreset->drcf_OPTION = 0x00;	    /* no interrupts yet... */
		devreset->drcf_NVCT = sc->sc_nvec;
		devreset->drcf_EVCT = sc->sc_evec;
		devreset->drcf_ILVL = 0;
		devreset->drcf_UNIT = i;

		vs_zero(mc, sizeof(M328_CQE));
		mc->cqe_IOPB_ADDR = OFF(devreset);
		mc->cqe_IOPB_LENGTH = sizeof(M328_DRCF);
		mc->cqe_WORK_QUEUE = 0;
		mc->cqe_QECR = M_QECR_GO;
		/* poll for the command to complete */
		do_vspoll(sc, 0);
		if (riopb->iopb_STATUS) {
#ifdef SDEBUG
			printf("status: %x\n", riopb->iopb_STATUS);
#endif 
			sc->sc_tinfo[i].avail = 0;
		} else {
			sc->sc_tinfo[i].avail = 1;
		}
		if (CRSW & M_CRSW_ER) {
			CRB_CLR_ER(CRSW);
		}
		CRB_CLR_DONE(CRSW);
	}
d641 1
a641 1
	struct vs_softc *sc;
d643 44
a686 34
	u_int s;
	M328_CQE *mc = (M328_CQE*)&sc->sc_vsreg->sh_MCE;
	M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
	M328_SRCF *reset = (M328_SRCF *)&sc->sc_vsreg->sh_MCE_IOPB;  

	vs_zero(reset, sizeof(M328_SRCF));
	reset->srcf_CMD = IOPB_RESET;
	reset->srcf_OPTION = 0x00;	 /* no interrupts yet... */
	reset->srcf_NVCT = sc->sc_nvec;
	reset->srcf_EVCT = sc->sc_evec;
	reset->srcf_ILVL = 0;
	reset->srcf_BUSID = 0;
	s = splbio();

	vs_zero(mc, sizeof(M328_CQE));
	mc->cqe_IOPB_ADDR = OFF(reset);
	mc->cqe_IOPB_LENGTH = sizeof(M328_SRCF);
	mc->cqe_WORK_QUEUE = 0;
	mc->cqe_QECR = M_QECR_GO;
	/* poll for the command to complete */
	while (1) {
		do_vspoll(sc, 0);
		/* ack & clear scsi error condition cause by reset */
		if (CRSW & M_CRSW_ER) {
			CRB_CLR_ER(CRSW);
			CRB_CLR_DONE(CRSW);
			riopb->iopb_STATUS = 0;
			break;
		}
		CRB_CLR_DONE(CRSW);
	}
	/* thaw all work queues */
	thaw_queue(sc, 0xFF);
	splx (s);
d689 1
d698 22
a719 20
	struct   vs_softc *sc;
	struct scsi_xfer *xs;
	int   *status;
{
	int   target = -1;
	int   lun = -1;
	M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
	struct scsi_generic *cmd;
	u_long buf;
	u_long len;
	u_char error;

	target = xs->sc_link->target;
	lun = xs->sc_link->lun;
	cmd = (struct scsi_generic *)&riopb->iopb_SCSI[0];

	VL(buf, riopb->iopb_BUFF);
	VL(len, riopb->iopb_LENGTH);
	*status = riopb->iopb_STATUS >> 8;
	error = riopb->iopb_STATUS & 0xFF;
d722 1
a722 1
	printf("scsi_chk() ");
d724 53
a776 53
	if (xs->cmd->opcode == 0) {
		printf("TEST_UNIT_READY ");
	} else if (xs->cmd->opcode == REQUEST_SENSE) {
		printf("REQUEST_SENSE   ");
	} else if (xs->cmd->opcode == INQUIRY) {
		printf("INQUIRY         ");
	} else if (xs->cmd->opcode == MODE_SELECT) {
		printf("MODE_SELECT     ");
	} else if (xs->cmd->opcode == MODE_SENSE) {
		printf("MODE_SENSE      ");
	} else if (xs->cmd->opcode == START_STOP) {
		printf("START_STOP      ");
	} else if (xs->cmd->opcode == RESERVE) {
		printf("RESERVE         ");
	} else if (xs->cmd->opcode == RELEASE) {
		printf("RELEASE         ");
	} else if (xs->cmd->opcode == PREVENT_ALLOW) {
		printf("PREVENT_ALLOW   ");
	} else if (xs->cmd->opcode == POSITION_TO_ELEMENT) {
		printf("POSITION_TO_EL  ");
	} else if (xs->cmd->opcode == CHANGE_DEFINITION) {
		printf("CHANGE_DEF      ");
	} else if (xs->cmd->opcode == MODE_SENSE_BIG) {
		printf("MODE_SENSE_BIG  ");
	} else if (xs->cmd->opcode == MODE_SELECT_BIG) {
		printf("MODE_SELECT_BIG ");
	} else if (xs->cmd->opcode == 0x25) {
		printf("READ_CAPACITY   ");
	} else if (xs->cmd->opcode == 0x08) {
		printf("READ_COMMAND    ");
	}

	printf("tgt %d lun %d buf %x len %d status %x ", target, lun, buf, len, riopb->iopb_STATUS);

	if (CRSW & M_CRSW_EX) {
		printf("[ex]");
	}
	if (CRSW & M_CRSW_QMS) {
		printf("[qms]");
	}
	if (CRSW & M_CRSW_SC) {
		printf("[sc]");
	}
	if (CRSW & M_CRSW_SE) {
		printf("[se]");
	}
	if (CRSW & M_CRSW_AQ) {
		printf("[aq]");
	}
	if (CRSW & M_CRSW_ER) {
		printf("[er]");
	}
	printf("\n");
d778 12
a789 12
	if (len != xs->datalen) {
		xs->resid = xs->datalen - len;
	} else {
		xs->resid = 0;
	}

	if (error == SCSI_SELECTION_TO) {
		xs->error = XS_SELTIMEOUT;
		xs->status = -1;
		*status = -1;
	}
	return 1;
a791 1
/* normal interrupt routine */
d793 2
a794 2
vs_nintr(sc)
	register struct vs_softc *sc;
d796 8
a803 12
	M328_CRB *crb = (M328_CRB *)&sc->sc_vsreg->sh_CRB;
	M328_CMD *m328_cmd;
	struct scsi_xfer *xs;
	int status;
	int s;
	
	if ((CRSW & CONTROLLER_ERROR) == CONTROLLER_ERROR)
		return(vs_eintr(sc));

	s = splbio();
	/* Got a valid interrupt on this device */
	sc->sc_intrcnt_n.ev_count++;
d805 1
a805 1
	VL((unsigned long)m328_cmd, crb->crb_CTAG);
d807 2
a808 2
	printf("Interrupt!!! ");
	printf("m328_cmd == 0x%x\n", m328_cmd);
d810 20
a829 115
	/*
	 * If this is a controller error, there won't be a m328_cmd
	 * pointer in the CTAG feild.  Bad things happen if you try 
	 * to point to address 0.  Controller error should be handeled
	 * in vsdma.c  I'll change this soon - steve.
	 */
	if (m328_cmd) {
		xs = m328_cmd->xs;
		if (m328_cmd->top_sg_list) {
			vs_dealloc_scatter_gather(m328_cmd->top_sg_list);
			m328_cmd->top_sg_list = (M328_SG)0;
		}
		FREE(m328_cmd, M_DEVBUF); /* free the command tag */
		if (vs_checkintr(sc, xs, &status)) {
			vs_scsidone(sc, xs, status);
		}
	}
	/* ack the interrupt */
	if (CRSW & M_CRSW_ER)
		CRB_CLR_ER(CRSW);
	CRB_CLR_DONE(CRSW);
	/* clear the return information */
	vs_clear_return_info(sc);
	splx(s);
	return (1);
}

int
vs_eintr(sc)
	register struct vs_softc *sc;
{
	M328_CEVSB *crb = (M328_CEVSB *)&sc->sc_vsreg->sh_CRB;
	M328_CMD *m328_cmd;
	struct scsi_xfer *xs;
	int crsw = crb->cevsb_CRSW;
#ifdef SDEBUG
	int type = crb->cevsb_TYPE;
	int length = crb->cevsb_IOPB_LENGTH;
	int wq = crb->cevsb_WORK_QUEUE;
#endif
	int ecode = crb->cevsb_ERROR;
	int status, s;
	
	s = splbio();

	/* Got a valid interrupt on this device */
	sc->sc_intrcnt_e.ev_count++;
	
	VL((unsigned long)m328_cmd, crb->cevsb_CTAG);
#ifdef SDEBUG
	printf("Error Interrupt!!! ");
	printf("m328_cmd == 0x%x\n", m328_cmd);
#endif 
	xs = m328_cmd->xs;

	if (crsw & M_CRSW_RST) {
		printf("%s: SCSI Bus Reset!\n", vs_name(sc));
		/* clear the return information */
		vs_clear_return_info(sc);
		splx(s);
		return(1);
	}
	switch (ecode) {
	case CEVSB_ERR_TYPE:
		printf("%s: IOPB Type error!\n", vs_name(sc));
		break;
	case CEVSB_ERR_TO:
		printf("%s: Timeout!\n", vs_name(sc));
		xs->error = XS_SELTIMEOUT;
		xs->status = -1;
		xs->flags |= ITSDONE;
		status = -1;
		scsi_done(xs);
		break;
	case CEVSB_ERR_TR:	/* Target Reconnect, no IOPB */
		printf("%s: Target Reconnect error!\n", vs_name(sc));
		break;
	case CEVSB_ERR_OF:	/* Overflow */
		printf("%s: Overflow error!\n", vs_name(sc));
		break;
	case CEVSB_ERR_BD:	/* Bad direction */
		printf("%s: Bad Direction!\n", vs_name(sc));
		break;
	case CEVSB_ERR_NR:	/* Non-Recoverabl Error */
		printf("%s: Non-Recoverable error!\n", vs_name(sc));
		break;
	case CESVB_ERR_PANIC:	/* Board Painc!!! */
		printf("%s: Board Painc!!!\n", vs_name(sc));
		break;
	default:
		printf("%s: Uh oh!... Error 0x%x\n", vs_name(sc), ecode);
		Debugger();
	}
#ifdef SDEBUG
	printf("%s: crsw = 0x%x iopb_type = %d iopb_len = %d wq = %d error = 0x%x\n", 
	       vs_name(sc), crsw, type, length, wq, ecode);
#endif 
	if (CRSW & M_CRSW_ER)
		CRB_CLR_ER(CRSW);
	CRB_CLR_DONE(CRSW);
	thaw_queue(sc, 0xFF);
	/* clear the return information */
	vs_clear_return_info(sc);
	splx(s);
	return(1);
}

static __inline__ void
vs_clear_return_info(sc)
	register struct vs_softc *sc;
{
        M328_IOPB *riopb = (M328_IOPB *)&sc->sc_vsreg->sh_RET_IOPB;
	M328_CEVSB *crb = (M328_CEVSB *)&sc->sc_vsreg->sh_CRB;
	vs_zero(riopb, sizeof(M328_IOPB));
	vs_zero(crb, sizeof(M328_CEVSB));
d839 1
a839 1
	M328_SG sg;
d841 6
a846 6
	MALLOC(sg, M328_SG, sizeof(struct m328_sg), M_DEVBUF, M_WAITOK);
	assert ( sg );
	if ( !sg ) {
		panic ("Memory for scatter_gather_list not available");
	}
	bzero(sg, sizeof(struct m328_sg));
d848 1
a848 1
	return (sg);
d852 1
a852 2
vs_dealloc_scatter_gather(sg)
	M328_SG sg;
d854 1
a854 1
	register int i;
d856 6
a861 6
	if (sg->level > 0) {
		for (i=0; sg->down[i] && i<MAX_SG_ELEMENTS; i++) {
			vs_dealloc_scatter_gather(sg->down[i]);
		}
	}
	FREE(sg, M_DEVBUF);
d865 10
a874 11
vs_link_sg_element(element, phys_add, len)
	sg_list_element_t *element;
	register vm_offset_t phys_add;
	register int len;
{
	element->count.bytes = len;
	LV(element->address, phys_add);
	element->link = 0; /* FALSE */
	element->transfer_type = NORMAL_TYPE;
	element->memory_type = LONG_TRANSFER;
	element->address_modifier = 0xD;
d878 3
a880 4
vs_link_sg_list(list, phys_add, elements)
	sg_list_element_t *list;
	register vm_offset_t phys_add;
	register int elements;
d883 6
a888 6
	list->count.scatter.gather  = elements;
	LV(list->address, phys_add);
	list->link = 1;	   /* TRUE */
	list->transfer_type = NORMAL_TYPE;
	list->memory_type = LONG_TRANSFER;
	list->address_modifier = 0xD;
d891 1
d894 2
a895 2
	struct scsi_xfer *xs;
	M328_IOPB  *iopb;	       /* the iopb */
d897 48
a944 48
	M328_SG   sg;
	vm_offset_t starting_point_virt, starting_point_phys, point_virt, 
	point1_phys, point2_phys, virt;
	unsigned len;
	int       level;

	sg = (M328_SG)0;   /* Hopefully we need no scatter/gather list */

	/*
	 * We have the following things:
	 *	virt			the virtuell address of the contiguous virtual memory block
	 *	len			the lenght of the contiguous virtual memory block
	 *	starting_point_virt	the virtual address of the contiguous *physical* memory block
	 *	starting_point_phys	the *physical* address of the contiguous *physical* memory block
	 *	point_virt		the pointer to the virtual memory we are checking at the moment
	 *	point1_phys		the pointer to the *physical* memory we are checking at the moment
	 *	point2_phys		the pointer to the *physical* memory we are checking at the moment
	 */

	level = 0;
	virt = starting_point_virt = (vm_offset_t)xs->data;
	point1_phys = starting_point_phys = kvtop(xs->data);
	len = xs->datalen;
	/*
	 * Check if we need scatter/gather
	 */

	if (len > PAGESIZE) {
		for (level = 0, point_virt = ROUND_PAGE(starting_point_virt+1);
		    /* if we do already scatter/gather we have to stay in the loop and jump */
		    point_virt < virt + (vm_offset_t)len || sg ;
		    point_virt += PAGESIZE) {			   /* out later */

			point2_phys = kvtop(point_virt);

			if ((point2_phys - TRUNC_PAGE(point1_phys) - PAGESIZE) ||		   /* physical memory is not contiguous */
			    (point_virt - starting_point_virt >= MAX_SG_BLOCK_SIZE && sg)) {   /* we only can access (1<<16)-1 bytes in scatter/gather_mode */
				if (point_virt - starting_point_virt >= MAX_SG_BLOCK_SIZE) {	       /* We were walking too far for one scatter/gather block ... */
					assert( MAX_SG_BLOCK_SIZE > PAGESIZE );
					point_virt = TRUNC_PAGE(starting_point_virt+MAX_SG_BLOCK_SIZE-1);    /* So go back to the beginning of the last matching page */
					/* and gererate the physadress of this location for the next time. */
					point2_phys = kvtop(point_virt);
				}

				if (!sg) {
					/* We allocate our fist scatter/gather list */
					sg = vs_alloc_scatter_gather();
				}
d947 4
a950 4
				if (sg->elements >= MAX_SG_ELEMENTS) {
					vs_dealloc_scatter_gather(sg);
					return (NULL);
				}
d953 24
a976 24
				while (sg->elements >= MAX_SG_ELEMENTS) {
					if (!sg->up) { /* If the list full in this layer ? */
						sg->up = vs_alloc_scatter_gather();
						sg->up->level = sg->level+1;
						sg->up->down[0] = sg;
						sg->up->elements = 1;
					}
					/* link this full list also in physical memory */
					vs_link_sg_list(&(sg->up->list[sg->up->elements-1]), 
							kvtop((vm_offset_t)sg->list),
							sg->elements);
					sg = sg->up;	  /* Climb up */
				}
				while (sg->level) {  /* As long as we are not a the base level */
					register int i;

					i = sg->elements;
					/* We need a new element */
					sg->down[i] = vs_alloc_scatter_gather();  
					sg->down[i]->level = sg->level - 1;
					sg->down[i]->up = sg;
					sg->elements++;
					sg = sg->down[i]; /* Climb down */
				}
d978 46
a1023 45
				if (point_virt < virt+(vm_offset_t)len) {
					/* linking element */
					vs_link_sg_element(&(sg->list[sg->elements]), 
							   starting_point_phys, 
							   point_virt-starting_point_virt);
					sg->elements++;
				} else {
					/* linking last element */
					vs_link_sg_element(&(sg->list[sg->elements]), 
							   starting_point_phys, 
							   (vm_offset_t)(virt+len)-starting_point_virt);
					sg->elements++;
					break;			       /* We have now collected all blocks */
				}
				starting_point_virt = point_virt;
				starting_point_phys = point2_phys;
			}
			point1_phys = point2_phys;
		}
	}

	/*
	 * Climb up along the right side of the tree until we reach the top.
	 */

	if (sg) {
		while (sg->up) {
			/* link this list also in physical memory */
			vs_link_sg_list(&(sg->up->list[sg->up->elements-1]), 
					kvtop((vm_offset_t)sg->list),
					sg->elements);
			sg = sg->up;		       /* Climb up */
		}

		iopb->iopb_OPTION |= M_OPT_SG;
		iopb->iopb_ADDR |= M_ADR_SG_LINK;
		LV(iopb->iopb_BUFF, kvtop((vm_offset_t)sg->list));
		LV(iopb->iopb_LENGTH, sg->elements);
		LV(iopb->iopb_SGTTL, len);
	} else {
		/* no scatter/gather neccessary */
		LV(iopb->iopb_BUFF, starting_point_phys);
		LV(iopb->iopb_LENGTH, len);
	}
	return (sg);
d1025 1
@


1.2.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.2.4.1 2001/04/18 16:11:07 niklas Exp $ */
a50 3

#include <vm/vm_param.h>

a52 1

d56 2
a57 1
#if defined(mvme88k)
d62 2
d68 3
a70 1
#endif /* mvme88k */
d86 1
d326 1
a326 1
	 * Since the 88k doesn't support cache snooping, we have
d331 1
a331 1
#if defined(mvme88k)
d337 1
a337 1
#if defined(mvme88k)
d930 4
d1014 2
a1015 2
	if (len > PAGE_SIZE) {
		for (level = 0, point_virt = round_page(starting_point_virt+1);
d1018 1
a1018 1
		    point_virt += PAGE_SIZE) {			   /* out later */
d1022 1
a1022 1
			if ((point2_phys - trunc_page(point1_phys) - PAGE_SIZE) ||		   /* physical memory is not contiguous */
d1025 2
a1026 2
					assert( MAX_SG_BLOCK_SIZE > PAGE_SIZE );
					point_virt = trunc_page(starting_point_virt+MAX_SG_BLOCK_SIZE-1);    /* So go back to the beginning of the last matching page */
@


1.2.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.2.4.2 2001/07/04 10:20:00 niklas Exp $ */
d61 4
a64 4
#include <mvme88k/dev/vsreg.h>
#include <mvme88k/dev/vsvar.h>
#include <mvme88k/dev/vme.h>		/* vme_findvec() */
#include <machine/mmu.h>		/* DMA_CACHE_SYNC, etc... */
d66 3
a68 3
#include <mvme68k/dev/vsreg.h>
#include <mvme68k/dev/vsvar.h>
#include <mvme68k/dev/vme.h>		/* vme_findvec() */
a81 6
void vs_copy __P((void *, void *, unsigned short));
void vs_zero __P((void *, u_long));
int do_vspoll __P((struct vs_softc *, int));
void thaw_queue __P((struct vs_softc *, u_int8_t));
void vs_link_sg_element __P((sg_list_element_t *, vm_offset_t, int));
void vs_link_sg_list __P((sg_list_element_t *, vm_offset_t, int));
d85 2
d428 1
a428 1
	LV(miopb->iopb_BUFF, kvtop((vm_offset_t)&xs->sense));
a891 1
#ifdef DDB
a892 1
#endif
d1002 1
a1002 1
	point1_phys = starting_point_phys = kvtop((vm_offset_t)xs->data);
@


1.2.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d52 1
a52 1
#include <uvm/uvm_param.h>
@


1.2.4.5
log
@Merge in trunk
@
text
@d64 1
a64 1
#include <machine/cmmu.h>		/* DMA_CACHE_SYNC, etc... */
d110 1
a110 2
	register unsigned short *volatile x, *volatile y;
	register unsigned short volatile z; 
d113 2
a114 2
	x = (unsigned short *)src; 
	y = (unsigned short *)dst; 
@


1.2.4.6
log
@Merge in -current from about a week ago
@
text
@d71 17
a87 17
int  vs_checkintr(struct vs_softc *, struct scsi_xfer *, int *);
void vs_chksense(struct scsi_xfer *);
void vs_reset(struct vs_softc *);
void vs_resync(struct vs_softc *);
int  vs_initialize(struct vs_softc *);
int  vs_nintr(struct vs_softc *);
int  vs_eintr(struct vs_softc *);
int  vs_poll(struct vs_softc *, struct scsi_xfer *);
void vs_scsidone(struct vs_softc *, struct scsi_xfer *, int);
M328_CQE  * vs_getcqe(struct vs_softc *);
M328_IOPB * vs_getiopb(struct vs_softc *);
void vs_copy(void *, void *, unsigned short);
void vs_zero(void *, u_long);
int do_vspoll(struct vs_softc *, int);
void thaw_queue(struct vs_softc *, u_int8_t);
void vs_link_sg_element(sg_list_element_t *, vm_offset_t, int);
void vs_link_sg_list(sg_list_element_t *, vm_offset_t, int);
d89 1
a89 1
static __inline__ void vs_clear_return_info(struct vs_softc *);
@


1.2.4.7
log
@Sync the SMP branch with 3.3
@
text
@d809 1
a809 1
	 * to point to address 0.  Controller error should be handled
d998 2
a999 2
	 *	virt			the virtual address of the contiguous virtual memory block
	 *	len			the length of the contiguous virtual memory block
@


1.2.4.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.2.4.7 2003/03/27 23:32:18 niklas Exp $ */
d19 5
a23 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.2.4.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d37 1
a37 1
 * MVME328S scsi adaptor driver
d56 1
d61 23
d85 27
a111 45
int	vsmatch(struct device *, void *, void *);
void	vsattach(struct device *, struct device *, void *);
int	vs_scsicmd(struct scsi_xfer *);

struct scsi_adapter vs_scsiswitch = {
	vs_scsicmd,
	minphys,
	0,			/* no lun support */
	0,			/* no lun support */
};

struct scsi_device vs_scsidev = {
	NULL,		/* use default error handler */
	NULL,		/* do not have a start function */
	NULL,		/* have no async handler */
	NULL,		/* Use default done routine */
};

struct cfattach vs_ca = {
	sizeof(struct vs_softc), vsmatch, vsattach,
};

struct cfdriver vs_cd = {
	NULL, "vs", DV_DULL,
};

int	do_vspoll(struct vs_softc *, int, int);
void	thaw_queue(struct vs_softc *, u_int8_t);
M328_SG	vs_alloc_scatter_gather(void);
M328_SG	vs_build_memory_structure(struct scsi_xfer *, M328_IOPB *);
int	vs_checkintr(struct vs_softc *, struct scsi_xfer *, int *);
void	vs_chksense(struct scsi_xfer *);
void	vs_dealloc_scatter_gather(M328_SG);
int	vs_eintr(void *);
M328_CQE *vs_getcqe(struct vs_softc *);
M328_IOPB *vs_getiopb(struct vs_softc *);
int	vs_initialize(struct vs_softc *);
int	vs_intr(struct vs_softc *);
void	vs_link_sg_element(sg_list_element_t *, vaddr_t, int);
void	vs_link_sg_list(sg_list_element_t *, vaddr_t, int);
int	vs_nintr(void *);
int	vs_poll(struct vs_softc *, struct scsi_xfer *);
void	vs_reset(struct vs_softc *);
void	vs_resync(struct vs_softc *);
void	vs_scsidone(struct vs_softc *, struct scsi_xfer *, int);
d113 4
a116 1
static __inline__ void vs_clear_return_info(struct vs_softc *);
d118 4
a121 4
int
vsmatch(pdp, vcf, args)
	struct device *pdp;
	void *vcf, *args;
d123 6
a128 1
	struct confargs *ca = args;
d130 4
a133 1
	return (!badvaddr((unsigned)ca->ca_vaddr, 1));
d136 3
d140 3
a142 40
vsattach(parent, self, auxp)
	struct device *parent, *self;
	void *auxp;
{
	struct vs_softc *sc = (struct vs_softc *)self;
	struct confargs *ca = auxp;
	struct vsreg * rp;
	int tmp;

	sc->sc_vsreg = rp = ca->ca_vaddr;

	sc->sc_ipl = ca->ca_ipl;
	sc->sc_nvec = ca->ca_vec;
	/* get the next available vector for the error interrupt func. */
	sc->sc_evec = vme_findvec();
	sc->sc_link.adapter_softc = sc;
	sc->sc_link.adapter_target = 7;
	sc->sc_link.adapter = &vs_scsiswitch;
	sc->sc_link.device = &vs_scsidev;
	sc->sc_link.luns = 1;
	sc->sc_link.openings = roundup(NUM_IOPB, 8) / 8;

	sc->sc_ih_n.ih_fn = vs_nintr;
	sc->sc_ih_n.ih_arg = sc;
	sc->sc_ih_n.ih_wantframe = 0;
	sc->sc_ih_n.ih_ipl = ca->ca_ipl;

	sc->sc_ih_e.ih_fn = vs_eintr;
	sc->sc_ih_e.ih_arg = sc;
	sc->sc_ih_e.ih_wantframe = 0;
	sc->sc_ih_e.ih_ipl = ca->ca_ipl;

	if (vs_initialize(sc))
		return;

	vmeintr_establish(sc->sc_nvec, &sc->sc_ih_n);
	vmeintr_establish(sc->sc_evec, &sc->sc_ih_e);
	evcnt_attach(&sc->sc_dev, "intr", &sc->sc_intrcnt_n);
	evcnt_attach(&sc->sc_dev, "intr", &sc->sc_intrcnt_e);

d144 1
a144 2
	 * attach all scsi units on us, watching for boot device
	 * (see dk_establish).
d146 1
a146 5
	tmp = bootpart;
	if (ca->ca_paddr != bootaddr)
		bootpart = -1;		/* invalid flag to dk_establish */
	config_found(self, &sc->sc_link, scsiprint);
	bootpart = tmp;		    /* restore old value */
d149 2
a150 2
int
do_vspoll(sc, to, canreset)
a152 1
	int canreset;
d168 2
a169 4
				if (canreset) {
					vs_reset(sc);
					vs_resync(sc);
				}
d189 1
a189 1
		if (do_vspoll(sc, to, 1)) {
d212 1
a212 1
void
d225 2
a226 2
void
vs_scsidone(sc, xs, stat)
d229 1
a229 1
	int stat;
d231 1
a231 1
	int tgt;
d243 1
a243 1

d265 1
d301 1
a301 1
#endif
d315 1
a315 1
	d16_bzero(iopb, sizeof(M328_IOPB));
d317 1
a317 1
	d16_bcopy(xs->cmd, &iopb->iopb_SCSI[0], xs->cmdlen);
d330 2
a331 1
		dma_cachectl((vaddr_t)xs->data, xs->datalen,
d333 1
d336 2
a337 1
		dma_cachectl((vaddr_t)xs->data, xs->datalen,
d339 1
d354 1
a354 1
	 * Should only have to wait if the master command
d384 2
a385 2
	printf("tgt %d lun %d buf %x len %d wqn %d ipl %d crsw 0x%x\n",
	       slp->target, slp->lun, buf, len, cqep->cqe_WORK_QUEUE,
d387 1
a387 1
#endif
d415 1
a415 1
	d16_bzero(miopb, sizeof(M328_IOPB));
d418 1
a418 1
	d16_bzero(ss, sizeof(*ss));
d429 1
a429 1
	LV(miopb->iopb_BUFF, kvtop((vaddr_t)&xs->sense));
d432 1
a432 1
	d16_bzero(mc, sizeof(M328_CQE));
d434 1
a434 1
	mc->cqe_IOPB_LENGTH = sizeof(M328_short_IOPB) +
d440 1
a440 1
	do_vspoll(sc, 0, 1);
d449 1
a449 1
#endif
d466 1
a466 1
	d16_bzero(cqep, sizeof(M328_CQE));
d484 1
a484 1
	d16_bzero(iopb, sizeof(M328_IOPB));
d503 1
a503 1
	d16_bzero(cib, sizeof(M328_CIB));
d530 1
a530 1
	d16_bzero(iopb, sizeof(M328_IOPB));
d540 1
a540 1
	d16_bzero(mc, sizeof(M328_CQE));
d546 1
a546 1
	do_vspoll(sc, 0, 1);
d550 2
a551 2
	for (i = 1; i < 8; i++) {
		d16_bzero(wiopb, sizeof(M328_IOPB));
d562 1
a562 1
		d16_bzero(mc, sizeof(M328_CQE));
d568 1
a568 1
		do_vspoll(sc, 0, 1);
d581 1
a581 1
	do_vspoll(sc, 0, 1);
d606 1
a606 1
	M328_DRCF *devreset = (M328_DRCF *)&sc->sc_vsreg->sh_MCE_IOPB;
d609 1
a609 1
		d16_bzero(devreset, sizeof(M328_DRCF));
d617 1
a617 1
		d16_bzero(mc, sizeof(M328_CQE));
d623 1
a623 1
		do_vspoll(sc, 0, 0);
d627 1
a627 1
#endif
d646 1
a646 1
	M328_SRCF *reset = (M328_SRCF *)&sc->sc_vsreg->sh_MCE_IOPB;
d648 1
a648 1
	d16_bzero(reset, sizeof(M328_SRCF));
d657 1
a657 1
	d16_bzero(mc, sizeof(M328_CQE));
d664 1
a664 1
		do_vspoll(sc, 0, 0);
d687 1
a687 1
	struct vs_softc *sc;
d764 1
a764 1
#endif
d781 2
a782 2
vs_nintr(vsc)
	void *vsc;
a783 1
	struct vs_softc *sc = (struct vs_softc *)vsc;
d789 1
a789 1

d801 1
a801 1
#endif
d804 1
a804 1
	 * pointer in the CTAG feild.  Bad things happen if you try
d830 2
a831 2
vs_eintr(vsc)
	void *vsc;
a832 1
	struct vs_softc *sc = (struct vs_softc *)vsc;
d844 1
a844 1

d849 1
a849 1

d854 1
a854 1
#endif
d885 1
a885 1
	case CEVSB_ERR_NR:	/* Non-Recoverable Error */
d888 2
a889 2
	case CESVB_ERR_PANIC:	/* Board Panic!!! */
		printf("%s: Board Panic!!!\n", vs_name(sc));
d898 1
a898 1
	printf("%s: crsw = 0x%x iopb_type = %d iopb_len = %d wq = %d error = 0x%x\n",
d900 1
a900 1
#endif
d913 1
a913 1
	struct vs_softc *sc;
d917 2
a918 2
	d16_bzero(riopb, sizeof(M328_IOPB));
	d16_bzero(crb, sizeof(M328_CEVSB));
d940 1
a940 1
	int i;
d953 2
a954 2
	vaddr_t phys_add;
	int len;
d967 2
a968 2
	vaddr_t phys_add;
	int elements;
d979 1
a979 1
M328_SG
d985 1
a985 1
	vaddr_t starting_point_virt, starting_point_phys, point_virt,
d1004 2
a1005 2
	virt = starting_point_virt = (vaddr_t)xs->data;
	point1_phys = starting_point_phys = kvtop((vaddr_t)xs->data);
d1014 1
a1014 1
		    point_virt < virt + (vaddr_t)len || sg ;
d1024 1
a1024 2
					/* and generate the physical address of
					 * this location for the next time. */
d1048 2
a1049 2
					vs_link_sg_list(&(sg->up->list[sg->up->elements-1]),
							kvtop((vaddr_t)sg->list),
d1054 1
a1054 1
					int i;
d1058 1
a1058 1
					sg->down[i] = vs_alloc_scatter_gather();
d1065 1
a1065 1
				if (point_virt < virt+(vaddr_t)len) {
d1067 2
a1068 2
					vs_link_sg_element(&(sg->list[sg->elements]),
							   starting_point_phys,
d1073 3
a1075 3
					vs_link_sg_element(&(sg->list[sg->elements]),
							   starting_point_phys,
							   (vaddr_t)(virt+len)-starting_point_virt);
d1093 2
a1094 2
			vs_link_sg_list(&(sg->up->list[sg->up->elements-1]),
					kvtop((vaddr_t)sg->list),
d1101 1
a1101 1
		LV(iopb->iopb_BUFF, kvtop((vaddr_t)sg->list));
d1105 1
a1105 1
		/* no scatter/gather necessary */
@


1.2.4.10
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a3 1
 * Copyright (c) 2004, Miodrag Vallat.
d37 1
a37 1
 * MVME328S SCSI adaptor driver
a39 3
/* This card lives in D16 space */
#define	__BUS_SPACE_RESTRICT_D16__

d48 1
a48 1
#include <uvm/uvm.h>
d58 2
a59 2
#include <mvme88k/dev/vme.h>
#include <machine/cmmu.h>
d88 1
a88 1
void	thaw_queue(struct vs_softc *, int);
d90 1
a90 2
M328_SG	vs_build_memory_structure(struct vs_softc *, struct scsi_xfer *,
	    bus_addr_t);
d95 2
a96 2
bus_addr_t vs_getcqe(struct vs_softc *);
bus_addr_t vs_getiopb(struct vs_softc *);
a107 2
static __inline__ int vs_queue_number(int, int);
static __inline__ paddr_t kvtop(vaddr_t);
d110 3
a112 1
vsmatch(struct device *device, void *cf, void *args)
a114 8
	bus_space_tag_t iot = ca->ca_iot;
	bus_space_handle_t ioh;
	int rc;

	if (bus_space_map(iot, ca->ca_paddr, S_SHORTIO, 0, &ioh) != 0)
		return 0;
	rc = badvaddr((vaddr_t)bus_space_vaddr(iot, ioh), 1);
	bus_space_unmap(iot, ioh, S_SHORTIO);
d116 1
a116 1
	return rc == 0;
d120 3
a122 1
vsattach(struct device *parent, struct device *self, void *args)
d125 2
a126 2
	struct confargs *ca = args;
	int evec;
d129 1
a129 19
	/* get the next available vector for the error interrupt */
	evec = vme_findvec(ca->ca_vec);

	if (ca->ca_vec < 0 || evec < 0) {
		printf(": no more interrupts!\n");
		return;
	}
	if (ca->ca_ipl < 0)
		ca->ca_ipl = IPL_BIO;

	printf(" vec 0x%x: ", evec);

	sc->sc_paddr = ca->ca_paddr;
	sc->sc_iot = ca->ca_iot;
	if (bus_space_map(sc->sc_iot, sc->sc_paddr, S_SHORTIO, 0,
	    &sc->sc_ioh) != 0) {
		printf("can't map registers!\n");
		return;
	}
d133 2
a134 5
	sc->sc_evec = evec;

	if (vs_initialize(sc))
		return;

d136 1
a136 1
	sc->sc_link.adapter_target = sc->sc_pid;
d140 1
a140 1
	sc->sc_link.openings = NUM_IOPB / 8;
d152 3
d165 1
a165 1
	if (sc->sc_paddr != bootaddr)
d172 4
a175 1
do_vspoll(struct vs_softc *sc, int to, int canreset)
a177 2
	int crsw;

d181 2
a182 2

	while (((crsw = CRSW) & (M_CRSW_CRBV | M_CRSW_CC)) == 0) {
d184 3
d190 1
d195 1
a195 2
				printf("%s: timeout %d crsw 0x%x\n",
				    sc->sc_dev.dv_xname, to, crsw);
d204 3
a206 1
vs_poll(struct vs_softc *sc, struct scsi_xfer *xs)
d211 1
d218 1
a226 1

d228 3
a230 5
			CRB_CLR_ER;
		CRB_CLR_DONE;

		if (xs->flags & ITSDONE)
			break;
d232 1
a232 1

d238 8
a245 4
thaw_queue(struct vs_softc *sc, int target)
{
	THAW(target);

d247 1
a247 2
	while (THAW_REG & M_THAW_TWQE)
		;
d251 4
a254 1
vs_scsidone(struct vs_softc *sc, struct scsi_xfer *xs, int stat)
d261 1
a261 1
		tgt = vs_queue_number(xs->sc_link->target, sc->sc_pid);
d265 1
a265 1
	tgt = vs_queue_number(xs->sc_link->target, sc->sc_pid);
d267 1
d275 2
a276 1
vs_scsicmd(struct scsi_xfer *xs)
d280 8
a287 3
	int flags, option;
	unsigned int iopb_len;
	bus_addr_t cqep, iopb;
d291 35
d327 2
a328 2
		cqep = sh_MCE;
		iopb = sh_MCE_IOPB;
a330 4
		if (cqep == 0) {
			xs->error = XS_DRIVER_STUFFUP;
			return (TRY_AGAIN_LATER);
		}
d333 4
d338 9
a346 10
	vs_bzero(iopb, IOPB_LONG_SIZE);

	iopb_len = IOPB_SHORT_SIZE + xs->cmdlen;
	bus_space_write_region_1(sc->sc_iot, sc->sc_ioh, iopb + IOPB_SCSI_DATA,
	    (u_int8_t *)xs->cmd, xs->cmdlen);

	vs_write(2, iopb + IOPB_CMD, IOPB_PASSTHROUGH);
	vs_write(2, iopb + IOPB_UNIT, (slp->lun << 3) | slp->target);
	vs_write(1, iopb + IOPB_NVCT, sc->sc_nvec);
	vs_write(1, iopb + IOPB_EVCT, sc->sc_evec);
d353 9
a361 6
	dma_cachectl((vaddr_t)xs->data, xs->datalen,
	    flags & SCSI_DATA_IN ? DMA_CACHE_SYNC_INVAL : DMA_CACHE_SYNC);
	
	option = 0;
	if (flags & SCSI_DATA_OUT)
		option |= M_OPT_DIR;
d364 2
a365 2
		vs_write(2, iopb + IOPB_OPTION, option);
		vs_write(2, iopb + IOPB_LEVEL, 0);
d367 2
a368 2
		vs_write(2, iopb + IOPB_OPTION, option | M_OPT_IE);
		vs_write(2, iopb + IOPB_LEVEL, sc->sc_ipl);
d370 1
a370 1
	vs_write(2, iopb + IOPB_ADDR, ADDR_MOD);
d375 1
a375 1
	 * queue entry is busy and we are polling.
d377 1
a377 2
	while (vs_read(2, cqep + CQE_QECR) & M_QECR_GO)
		;
d379 7
a385 4
	vs_write(2, cqep + CQE_IOPB_ADDR, iopb);
	vs_write(1, cqep + CQE_IOPB_LENGTH, iopb_len);
	vs_write(1, cqep + CQE_WORK_QUEUE,
	    flags & SCSI_POLL ? 0 : vs_queue_number(slp->target, sc->sc_pid));
d390 5
a394 4
	if (xs->datalen != 0)
		m328_cmd->top_sg_list = vs_build_memory_structure(sc, xs, iopb);
	else
		m328_cmd->top_sg_list = NULL;
d396 1
a396 1
	vs_write(4, cqep + CQE_CTAG, (u_int32_t)m328_cmd);
d398 11
a408 4
	if (crb_read(2, CRB_CRSW) & M_CRSW_AQ)
		vs_write(2, cqep + CQE_QECR, M_QECR_AA);

	vs_write(2, cqep + CQE_QECR, vs_read(2, cqep + CQE_QECR) | M_QECR_GO);
d412 2
a413 1
		return vs_poll(sc, xs);
a414 1

d419 2
a420 1
vs_chksense(struct scsi_xfer *xs)
d426 3
d431 2
a432 3
	if (CRSW & M_CRSW_ER)
		CRB_CLR_ER;
	CRB_CLR_DONE;
d435 1
a435 1
	vs_bzero(sh_MCE_IOPB, IOPB_LONG_SIZE);
d437 2
a438 2
	ss = (void *)(bus_space_vaddr(sc->sc_iot, sc->sc_ioh) +
	    sh_MCE_IOPB + IOPB_SCSI_DATA);
d443 15
a457 16
	mce_iopb_write(2, IOPB_CMD, IOPB_PASSTHROUGH);
	mce_iopb_write(2, IOPB_OPTION, 0);
	mce_iopb_write(1, IOPB_NVCT, sc->sc_nvec);
	mce_iopb_write(1, IOPB_EVCT, sc->sc_evec);
	mce_iopb_write(2, IOPB_LEVEL, 0 /* sc->sc_ipl */);
	mce_iopb_write(2, IOPB_ADDR, ADDR_MOD);
	mce_iopb_write(4, IOPB_BUFF, kvtop((vaddr_t)&xs->sense));
	mce_iopb_write(4, IOPB_LENGTH, sizeof(struct scsi_sense_data));

	vs_bzero(sh_MCE, CQE_SIZE);
	mce_write(2, CQE_IOPB_ADDR, sh_MCE_IOPB);
	mce_write(1, CQE_IOPB_LENGTH,
	    IOPB_SHORT_SIZE + sizeof(struct scsi_sense));
	mce_write(1, CQE_WORK_QUEUE, 0);
	mce_write(2, CQE_QECR, M_QECR_GO);

d461 9
a469 1
	xs->status = vs_read(2, sh_RET_IOPB + IOPB_STATUS) >> 8;
d473 14
a486 19
bus_addr_t
vs_getcqe(struct vs_softc *sc)
{
	bus_addr_t cqep;
	int qhdp;

	qhdp = mcsb_read(2, MCSB_QHDP);
	cqep = sh_CQE(qhdp);

	if (vs_read(2, cqep + CQE_QECR) & M_QECR_GO) {
		/* should never happen */
		return 0;
	}

	if (++qhdp == NUM_CQE)
		qhdp = 0;
	mcsb_write(2, MCSB_QHDP, qhdp);

	vs_bzero(cqep, CQE_SIZE);
d490 7
a496 5
bus_addr_t
vs_getiopb(struct vs_softc *sc)
{
	bus_addr_t iopb;
	int qhdp;
d498 7
a504 9
	/*
	 * Since we are always invoked after vs_getcqe(), qhdp has already
	 * been incremented...
	 */
	qhdp = mcsb_read(2, MCSB_QHDP);
	if (--qhdp < 0)
		qhdp = NUM_CQE - 1;

	iopb = sh_IOPB(qhdp);
d509 2
a510 1
vs_initialize(struct vs_softc *sc)
d512 53
a564 67
	int i, msr;

	/*
	 * Reset the board, and wait for it to get ready.
	 * The reset signal is applied for 70 usec, and the board status
	 * is not tested until 100 usec after the reset signal has been
	 * cleared, per the manual (MVME328/D1) pages 4-6 and 4-9.
	 */

	mcsb_write(2, MCSB_MCR, M_MCR_RES | M_MCR_SFEN);
	delay(70);
	mcsb_write(2, MCSB_MCR, M_MCR_SFEN);

	delay(100);
	i = 0;
	for (;;) {
		msr = mcsb_read(2, MCSB_MSR);
		if ((msr & (M_MSR_BOK | M_MSR_CNA)) == M_MSR_BOK)
			break;
		if (++i > 5000) {
			printf("board reset failed, status %x\n", msr);
			return 1;
		}
		delay(1000);
	}

	/* initialize channels id */
	sc->sc_pid = csb_read(1, CSB_PID);
	sc->sc_sid = csb_read(1, CSB_SID);

	CRB_CLR_DONE;
	mcsb_write(2, MCSB_QHDP, 0);

	vs_bzero(sh_CIB, CIB_SIZE);
	cib_write(2, CIB_NCQE, NUM_CQE);
	cib_write(2, CIB_BURST, 0);
	cib_write(2, CIB_NVECT, (sc->sc_ipl << 8) | sc->sc_nvec);
	cib_write(2, CIB_EVECT, (sc->sc_ipl << 8) | sc->sc_evec);
	cib_write(2, CIB_PID, sc->sc_pid);
	cib_write(2, CIB_SID, 0);	/* disable second channel */
	cib_write(2, CIB_CRBO, sh_CRB);
	cib_write(4, CIB_SELECT, SELECTION_TIMEOUT);
	cib_write(4, CIB_WQTIMO, 4);
	cib_write(4, CIB_VMETIMO, 0 /* VME_BUS_TIMEOUT */);
	cib_write(2, CIB_ERR_FLGS, M_ERRFLGS_RIN | M_ERRFLGS_RSE);
	cib_write(2, CIB_SBRIV, (sc->sc_ipl << 8) | sc->sc_evec);
	cib_write(1, CIB_SOF0, 0x15);
	cib_write(1, CIB_SRATE0, 100 / 4);
	cib_write(1, CIB_SOF1, 0);
	cib_write(1, CIB_SRATE1, 0);

	vs_bzero(sh_MCE_IOPB, IOPB_LONG_SIZE);
	mce_iopb_write(2, IOPB_CMD, CNTR_INIT);
	mce_iopb_write(2, IOPB_OPTION, 0);
	mce_iopb_write(1, IOPB_NVCT, sc->sc_nvec);
	mce_iopb_write(1, IOPB_EVCT, sc->sc_evec);
	mce_iopb_write(2, IOPB_LEVEL, 0 /* sc->sc_ipl */);
	mce_iopb_write(2, IOPB_ADDR, SHIO_MOD);
	mce_iopb_write(4, IOPB_BUFF, sh_CIB);
	mce_iopb_write(4, IOPB_LENGTH, CIB_SIZE);

	vs_bzero(sh_MCE, CQE_SIZE);
	mce_write(2, CQE_IOPB_ADDR, sh_MCE_IOPB);
	mce_write(1, CQE_IOPB_LENGTH, IOPB_LONG_SIZE);
	mce_write(1, CQE_WORK_QUEUE, 0);
	mce_write(2, CQE_QECR, M_QECR_GO);

d567 1
d571 16
a586 17
		vs_bzero(sh_MCE_IOPB, IOPB_LONG_SIZE);
		mce_iopb_write(2, WQCF_CMD, CNTR_INIT_WORKQ);
		mce_iopb_write(2, WQCF_OPTION, 0);
		mce_iopb_write(1, WQCF_NVCT, sc->sc_nvec);
		mce_iopb_write(1, WQCF_EVCT, sc->sc_evec);
		mce_iopb_write(2, WQCF_ILVL, 0 /* sc->sc_ipl */);
		mce_iopb_write(2, WQCF_WORKQ, i);
		mce_iopb_write(2, WQCF_WOPT, M_WOPT_FE | M_WOPT_IWQ);
		mce_iopb_write(2, WQCF_SLOTS, JAGUAR_MAX_Q_SIZ);
		mce_iopb_write(4, WQCF_CMDTO, 4);	/* 1 second */

		vs_bzero(sh_MCE, CQE_SIZE);
		mce_write(2, CQE_IOPB_ADDR, sh_MCE_IOPB);
		mce_write(1, CQE_IOPB_LENGTH, IOPB_LONG_SIZE);
		mce_write(1, CQE_WORK_QUEUE, 0);
		mce_write(2, CQE_QECR, M_QECR_GO);

d589 6
a594 4
		if (CRSW & M_CRSW_ER)
			CRB_CLR_ER;
		CRB_CLR_DONE;
#if 0
a595 1
#endif
a596 1

d598 3
a600 2
	mcsb_write(2, MCSB_MCR, mcsb_read(2, MCSB_MCR) | M_MCR_SQM);

d603 2
a604 4
		printf("initialization error, status = 0x%x\n",
		    vs_read(2, sh_RET_IOPB + IOPB_STATUS));
		CRB_CLR_DONE;
		return 1;
d606 1
a606 1
	CRB_CLR_DONE;
d608 4
d616 2
a617 2
	printf("SCSI ID %d\n", sc->sc_pid);
	return 0;
d621 2
a622 1
vs_resync(struct vs_softc *sc)
d624 18
a641 20
	int i;

	for (i = 0; i < 8; i++) {
		if (i == sc->sc_pid)
			continue;

		vs_bzero(sh_MCE_IOPB, IOPB_SHORT_SIZE);
		mce_iopb_write(2, DRCF_CMD, CNTR_DEV_REINIT);
		mce_iopb_write(2, DRCF_OPTION, 0); /* no interrupts yet */
		mce_iopb_write(1, DRCF_NVCT, sc->sc_nvec);
		mce_iopb_write(1, DRCF_EVCT, sc->sc_evec);
		mce_iopb_write(2, DRCF_ILVL, 0);
		mce_iopb_write(2, DRCF_UNIT, i);

		vs_bzero(sh_MCE, CQE_SIZE);
		mce_write(2, CQE_IOPB_ADDR, sh_MCE_IOPB);
		mce_write(1, CQE_IOPB_LENGTH, IOPB_SHORT_SIZE);
		mce_write(1, CQE_WORK_QUEUE, 0);
		mce_write(2, CQE_QECR, M_QECR_GO);

d644 12
a655 3
		if (CRSW & M_CRSW_ER)
			CRB_CLR_ER;
		CRB_CLR_DONE;
d660 2
a661 1
vs_reset(struct vs_softc *sc)
d663 12
a674 2
	int s;

d677 5
a681 14
	vs_bzero(sh_MCE_IOPB, IOPB_SHORT_SIZE);
	mce_iopb_write(2, SRCF_CMD, IOPB_RESET);
	mce_iopb_write(2, SRCF_OPTION, 0);	/* not interrupts yet... */
	mce_iopb_write(1, SRCF_NVCT, sc->sc_nvec);
	mce_iopb_write(1, SRCF_EVCT, sc->sc_evec);
	mce_iopb_write(2, SRCF_ILVL, 0);
	mce_iopb_write(2, SRCF_BUSID, 0);

	vs_bzero(sh_MCE, CQE_SIZE);
	mce_write(2, CQE_IOPB_ADDR, sh_MCE_IOPB);
	mce_write(1, CQE_IOPB_LENGTH, IOPB_SHORT_SIZE);
	mce_write(1, CQE_WORK_QUEUE, 0);
	mce_write(2, CQE_QECR, M_QECR_GO);

d683 1
a683 1
	for (;;) {
d687 3
a689 2
			CRB_CLR_DONE;
			vs_write(2, sh_RET_IOPB + IOPB_STATUS, 0);
d692 1
a692 1
		CRB_CLR_DONE;
a693 1

d695 2
a696 3
	thaw_queue(sc, 0xff);

	splx(s);
d704 1
d706 4
a709 1
vs_checkintr(struct vs_softc *sc, struct scsi_xfer *xs, int *status)
d711 79
a789 8
	u_int32_t len;
	int error;

	len = vs_read(4, sh_RET_IOPB + IOPB_LENGTH);
	error = vs_read(2, sh_RET_IOPB + IOPB_STATUS);
	*status = error >> 8;

	xs->resid = xs->datalen - len;
d791 1
a791 1
	if ((error & 0xff) == SCSI_SELECTION_TO) {
a795 1

d801 2
a802 1
vs_nintr(void *vsc)
d805 1
d812 1
a812 1
		return vs_eintr(sc);
d814 1
a815 1
	s = splbio();
a816 1
	m328_cmd = (void *)crb_read(4, CRB_CTAG);
d818 5
d825 3
a827 3
	 * pointer in the CTAG field.  Bad things happen if you try
	 * to point to address 0.  But then, we should have caught
	 * the controller error above.
d829 1
a829 1
	if (m328_cmd != NULL) {
d831 1
a831 1
		if (m328_cmd->top_sg_list != NULL) {
d833 1
a833 1
			m328_cmd->top_sg_list = (M328_SG)NULL;
a835 1

a839 1

d842 3
a844 3
		CRB_CLR_ER;
	CRB_CLR_DONE;

d847 1
a847 2

	return 1;
a849 1
/* error interrupts */
d851 2
a852 1
vs_eintr(void *vsc)
d855 1
d858 10
a867 2
	int crsw, ecode;
	int s;
a869 1
	s = splbio();
d872 6
a877 4
	crsw = vs_read(2, sh_CEVSB + CEVSB_CRSW);
	ecode = vs_read(1, sh_CEVSB + CEVSB_ERROR);
	m328_cmd = (void *)crb_read(4, CRB_CTAG);
	xs = m328_cmd != NULL ? m328_cmd->xs : NULL;
d880 2
a881 1
		printf("%s: bus reset\n", sc->sc_dev.dv_xname);
d884 1
a884 8
		return 1;
	}

	if (xs == NULL)
		printf("%s: ", sc->sc_dev.dv_xname);
	else {
		printf("%s(target %d): ",
		    sc->sc_dev.dv_xname, xs->sc_link->target);
a885 1

d888 1
a888 1
		printf("IOPB type error\n");
d891 6
a896 7
		printf("timeout\n");
		if (xs != NULL) {
			xs->error = XS_SELTIMEOUT;
			xs->status = -1;
			xs->flags |= ITSDONE;
			scsi_done(xs);
		}
d898 2
a899 2
	case CEVSB_ERR_TR:
		printf("reconnect error\n");
d901 2
a902 2
	case CEVSB_ERR_OF:
		printf("overflow\n");
d904 2
a905 2
	case CEVSB_ERR_BD:
		printf("bad direction\n");
d907 2
a908 2
	case CEVSB_ERR_NR:
		printf("non-recoverable error\n");
d910 2
a911 2
	case CESVB_ERR_PANIC:
		printf("board panic\n");
d914 4
a917 2
		printf("unexpected error %x\n", ecode);
		break;
d919 4
a922 1

d924 4
a927 4
		CRB_CLR_ER;
	CRB_CLR_DONE;

	thaw_queue(sc, 0xff);
d930 1
a930 8

	return 1;
}

static void
vs_clear_return_info(struct vs_softc *sc)
{
	vs_bzero(sh_RET_IOPB, CRB_SIZE + IOPB_LONG_SIZE);
d933 3
a935 9
/*
 * Choose the work queue number for a specific target.
 *
 * Targets on the primary channel should be mapped to queues 1-7,
 * so we assign each target the queue matching its own number, except for
 * target zero which gets assigned to the queue matching the controller id.
 */
static int
vs_queue_number(int target, int host)
d937 4
a940 1
	return target == 0 ? host : target;
d959 2
a960 1
vs_dealloc_scatter_gather(M328_SG sg)
d965 1
a965 1
		for (i = 0; sg->down[i] && i < MAX_SG_ELEMENTS; i++) {
d973 4
a976 1
vs_link_sg_element(sg_list_element_t *element, vaddr_t phys_add, int len)
d979 1
a979 2
	element->addrlo = phys_add;
	element->addrhi = phys_add >> 16;
d983 1
a983 1
	element->address_modifier = ADRM_EXT_S_D;
d987 4
a990 1
vs_link_sg_list(sg_list_element_t *list, vaddr_t phys_add, int elements)
d992 3
a994 3
	list->count.scatter.gather = elements;
	list->addrlo = phys_add;
	list->addrhi = phys_add >> 16;
d998 1
a998 1
	list->address_modifier = ADRM_EXT_S_D;
d1002 3
a1004 2
vs_build_memory_structure(struct vs_softc *sc, struct scsi_xfer *xs,
     bus_addr_t iopb)
d1006 1
a1006 1
	M328_SG sg;
d1009 2
a1010 2
	unsigned int len;
	int level;
d1012 1
a1012 1
	sg = NULL;	/* Hopefully we need no scatter/gather list */
d1016 7
a1022 10
	 *	virt			va of the virtual memory block
	 *	len			length of the virtual memory block
	 *	starting_point_virt	va of the physical memory block
	 *	starting_point_phys	pa of the physical memory block
	 *	point_virt		va of the virtual memory
	 *				    we are checking at the moment
	 *	point1_phys		pa of the physical memory
	 *				    we are checking at the moment
	 *	point2_phys		pa of another physical memory
	 *				    we are checking at the moment
a1028 1

d1032 1
d1044 1
d1051 2
a1052 1
				if (sg == NULL)
d1054 2
a1056 1
#if 1 /* broken firmware */
d1061 1
d1113 1
a1113 1
	if (sg != NULL) {
d1122 5
a1126 7
		vs_write(2, iopb + IOPB_OPTION,
		    vs_read(2, iopb + IOPB_OPTION) | M_OPT_SG);
		vs_write(2, iopb + IOPB_ADDR,
		    vs_read(2, iopb + IOPB_ADDR) | M_ADR_SG_LINK);
		vs_write(4, iopb + IOPB_BUFF, kvtop((vaddr_t)sg->list));
		vs_write(4, iopb + IOPB_LENGTH, sg->elements);
		vs_write(4, iopb + IOPB_SGTTL, len);
d1129 2
a1130 2
		vs_write(4, iopb + IOPB_BUFF, starting_point_phys);
		vs_write(4, iopb + IOPB_LENGTH, len);
d1132 1
a1132 11
	return sg;
}

static paddr_t
kvtop(vaddr_t va)
{
	paddr_t pa;

	pmap_extract(pmap_kernel(), va, &pa);
	/* XXX check for failure */
	return pa;
@


1.2.4.11
log
@sync to HEAD
@
text
@d915 2
a916 2
	if (trunc_page(virt + len - 1) != trunc_page(virt)) {
		for (point_virt = round_page(starting_point_virt + 1);
d918 2
a919 2
		    point_virt < virt + len || sg != NULL;
		    point_virt += PAGE_SIZE) {		   /* out later */
d923 1
a923 1
			if ((point2_phys != trunc_page(point1_phys) + PAGE_SIZE) ||		   /* physical memory is not contiguous */
a937 2
					printf("%s: scatter/gather list too large\n",
					    sc->sc_dev.dv_xname);
d966 1
a966 1
				if (point_virt < virt + len) {
d970 1
a970 1
							   point_virt - starting_point_virt);
d976 1
a976 1
							   virt + len - starting_point_virt);
@


1.1
log
@Added vme bus device drivers. MVME328, MVME376, MVME332
@
text
@d1 1
a1 1
/*	$OpenBSD: vs.c,v 1.2 1998/12/15 05:52:31 smurph Exp $ */
d55 8
a62 4
#if defined(MVME187)
#include <mvme88k/dev/vsreg.h>
#include <mvme88k/dev/vsvar.h>
#include "machine/mmu.h"
d64 4
a67 2
#include <mvme68k/dev/vsreg.h>
#include <mvme68k/dev/vsvar.h>
d82 47
a128 1
extern u_int	kvtop();
d135 1
a135 1
	struct buf *bp;
d137 4
a140 4
	/*
	 * No max transfer at this level.
	 */
	minphys(bp);
d144 2
a145 2
	struct vs_softc *sc;
	int to;
d152 1
a152 1
   while(!(CRSW & (M_CRSW_CRBV | M_CRSW_CC))){
d173 2
a174 2
	struct vs_softc *sc;
	struct scsi_xfer *xs;
d184 9
a192 9
	int i;
	int status;
	int s;
	int to;

	/*s = splbio();*/
	to = xs->timeout / 1000;
	for (;;) {
		if (do_vspoll(sc, to)) break;
d194 3
a196 3
			vs_scsidone(xs, status);
		}
      if (CRSW & M_CRSW_ER) 
d200 2
a201 2
	}
	return (COMPLETE);
d205 2
a206 2
   struct vs_softc *sc;
   u_int8_t target;
d231 1
a231 1
   if (CRSW & M_CRSW_ER) 
d235 1
a235 1
   bzero(riopb, sizeof(M328_IOPB));
d241 1
a241 1
	struct scsi_xfer *xs;
d243 3
a245 3
	struct scsi_link *slp = xs->sc_link;
	struct vs_softc *sc = slp->adapter_softc;
	int flags, s, i;
d255 1
d264 1
a264 1
	
d269 1
a269 1
   if (xs->cmd->opcode == 0){
d301 1
a301 1
   if (flags & SCSI_POLL){
d304 1
a304 1
   }else{
d310 1
a310 1
      return(TRY_AGAIN_LATER);
d312 1
a312 1
   
d315 1
a315 1
   bzero(iopb, sizeof(M328_IOPB));
d317 3
a319 2
	bcopy(xs->cmd, &iopb->iopb_SCSI[0], xs->cmdlen);
	iopb->iopb_CMD = IOPB_SCSI;
d322 1
d327 6
a332 6
	
	/*
	 * Since the 187 doesn't support cache snooping, we have
	 * to flush the cache for a write and flush with inval for
	 * a read, prior to starting the IO.
	 */
d336 1
a336 1
							DMA_CACHE_SYNC_INVAL);
d341 2
a342 2
		dma_cachectl((vm_offset_t)xs->data, xs->datalen,
							DMA_CACHE_SYNC);
d346 1
a346 1
   
d355 1
a355 1
   
d361 2
a362 2
   while(cqep->cqe_QECR & M_QECR_GO);
   
d365 1
a365 1
   if (flags & SCSI_POLL){
d367 1
a367 1
   }else{
a369 1
   LV(cqep->cqe_CTAG, xs);
d371 11
d392 2
a393 2
   
   if (flags & SCSI_POLL){
d400 1
a400 1
	return(SUCCESSFULLY_QUEUED);
d405 1
a405 1
	struct scsi_xfer *xs;
d407 1
a407 1
	int flags, s, i;
d414 1
a414 1
   
d419 2
a420 2
   
   bzero(miopb, sizeof(M328_IOPB));
d423 1
a423 1
   bzero(ss, sizeof(*ss));
d427 1
a427 1
   
d436 2
a437 2
   
   bzero(mc, sizeof(M328_CQE));
d459 1
a459 1
	struct vs_softc *sc;
d463 1
a463 1
   
d465 2
a466 2
   
   if (cqep->cqe_QECR & M_QECR_GO) 
d470 1
a470 1
   bzero(cqep, sizeof(M328_CQE));
d476 1
a476 1
	struct vs_softc *sc;
d481 2
a482 2
   
   if (mcsb->mcsb_QHDP == 0) { 
d488 1
a488 1
   bzero(iopb, sizeof(M328_IOPB));
d494 1
a494 1
	struct vs_softc *sc;
d506 2
a507 1
   bzero(cib, sizeof(M328_CIB));
d533 1
a533 1
   bzero(iopb, sizeof(M328_IOPB));
d542 2
a543 2
   
   bzero(mc, sizeof(M328_CQE));
d551 1
a551 1
   
d554 1
a554 1
      bzero(wiopb, sizeof(M328_IOPB));
d564 2
a565 2
      
      bzero(mc, sizeof(M328_CQE));
d573 1
a573 1
         printf("error: queue %d status = 0x%x\n", i, riopb->iopb_STATUS);
d578 1
a578 1
      delay(1000);
d590 1
a590 1
   
d599 1
a599 1
	printf(": target %d\n", sc->sc_link.adapter_target);
d601 1
a601 1
	
d604 1
a604 1
	struct vs_softc *sc;
d612 1
a612 1
      bzero(devreset, sizeof(M328_DRCF));
d619 2
a620 2
      
      bzero(mc, sizeof(M328_CQE));
d641 1
a641 1
	struct vs_softc *sc;
d643 4
a646 4
	struct vsreg * rp;
	u_int s;
	u_char  i;
	struct iopb_reset* iopr;
d657 2
a658 2
   
   bzero(reset, sizeof(M328_SRCF));
d666 2
a667 2
   
   bzero(mc, sizeof(M328_CQE));
d673 1
a673 1
   while(1){
d686 1
a686 1
	splx (s);
d698 7
a704 7
	struct	vs_softc *sc;
	struct scsi_xfer *xs;
	int	*status;
{
	struct vsreg * rp = sc->sc_vsreg;
	int	target = -1;
	int	lun = -1;
d715 1
a715 1
   
d723 2
a724 2
   
   if (xs->cmd->opcode == 0){
d755 1
a755 1
   
d757 1
a757 1
   
d783 1
a783 1
   
d794 1
a794 1
	register struct vs_softc *sc;
d797 2
a798 1
	struct scsi_xfer *xs;
d800 1
a800 1
	int status;
d802 3
a804 3
	s = splbio();
	/* Got a valid interrupt on this device */
   
d811 1
a811 1
    * If this is a controller error, there won't be a scsi_xfer
d814 1
a814 1
    * in m328dma.c  I'll change this soon - steve.
d817 8
a824 1
      xs = (struct scsi_xfer *)loc;
d829 33
a861 1
	splx(s);
d864 161
@

