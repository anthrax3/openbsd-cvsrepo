head	1.20;
access;
symbols
	OPENBSD_5_5:1.19.0.6
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.2
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.17.0.30
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.28
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.26
	OPENBSD_5_0:1.17.0.24
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.22
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.20
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.16
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.18
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.14
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.12
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.10
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.8
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.6
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.4
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.16.0.6
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.4
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.8
	UBC:1.7.0.2
	UBC_BASE:1.7
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.3.0.8
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.6
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.4
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.1.1.1.0.8
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.6
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.4
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.2
	OPENBSD_2_1_BASE:1.1.1.1
	mvme88kport:1.1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2014.03.18.22.36.36;	author miod;	state dead;
branches;
next	1.19;

1.19
date	2013.05.17.22.46.27;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2013.05.14.21.01.21;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2005.11.25.22.14.32;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2004.07.30.19.02.06;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2004.04.24.19.51.48;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2004.04.16.23.35.50;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2003.12.28.19.44.26;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2003.12.25.21.01.39;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2003.12.22.11.54.48;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.11.22.08.57;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.04.04.11.37;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.39;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.07.22.31.57;	author miod;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.08.12.12.03.02;	author heko;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.09.05.44.39;	author smurph;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.01.03.38.15;	author smurph;	state Exp;
branches;
next	1.3;

1.3
date	99.05.29.04.41.44;	author smurph;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	98.12.15.05.52.31;	author smurph;	state Exp;
branches;
next	1.1;

1.1
date	97.03.03.19.32.04;	author rahnds;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.03.03.19.32.04;	author rahnds;	state Exp;
branches;
next	;

1.3.4.1
date	2001.04.18.16.11.06;	author niklas;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2001.10.31.03.01.18;	author nate;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2001.11.13.21.04.14;	author niklas;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2002.03.28.10.36.02;	author niklas;	state Exp;
branches;
next	1.3.4.5;

1.3.4.5
date	2003.06.07.11.13.17;	author ho;	state Exp;
branches;
next	1.3.4.6;

1.3.4.6
date	2004.02.19.10.49.06;	author niklas;	state Exp;
branches;
next	1.3.4.7;

1.3.4.7
date	2004.06.05.23.09.49;	author niklas;	state Exp;
branches;
next	;

1.7.2.1
date	2002.06.11.03.37.10;	author art;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: vme.h,v 1.19 2013/05/17 22:46:27 miod Exp $ */

/*
 * Copyright (c) 1995 Theo de Raadt
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef __MVME88K_DEV_VME_H__
#define	__MVME88K_DEV_VME_H__

#define	VME2_BASE		0xfff40000

#define	VME2_SADDR1		0x0000
#define	VME2_SADDR2		0x0004
#define	VME2_SLAVELMOD1		0x0008
#define	VME2_SLAVELMOD2		0x000c
#define	VME2_SLAVECTL		0x0010
#define	VME2_MASTER1		0x0014
#define	VME2_MASTER2		0x0018
#define	VME2_MASTER3		0x001c
#define	VME2_MASTER4		0x0020
#define	VME2_MASTER4MOD		0x0024
#define	VME2_MASTERCTL		0x0028
#define	VME2_GCSRCTL		0x002c
#define	VME2_DMACTL		0x0030
#define	VME2_DMAMODE		0x0034
#define	VME2_DMALADDR		0x0038
#define	VME2_DMAVMEADDR		0x003c
#define	VME2_DMACOUNT		0x0040
#define	VME2_DMATABLE		0x0044
#define	VME2_DMASTAT		0x0048
#define	VME2_TCR		0x004c
#define	VME2_T1CMP		0x0050
#define	VME2_T1COUNT		0x0054
#define	VME2_T2CMP		0x0058
#define	VME2_T2COUNT		0x005c
#define	VME2_TCTL		0x0060
#define	VME2_PRESCALE		0x0064
#define	VME2_IRQSTAT		0x0068
#define	VME2_IRQEN		0x006c
#define	VME2_SETSOFTIRQ		0x0070
#define	VME2_IRQCLR		0x0074
#define	VME2_IRQL1		0x0078
#define	VME2_IRQL2		0x007c
#define	VME2_IRQL3		0x0080
#define	VME2_IRQL4		0x0084
#define	VME2_VBR		0x0088
#define	VME2_MISC		0x008c

#define	VME2_GCSR_ID		0x0100
#define	VME2_GCSR_LM_SIG_BSCR	0x0104
#define	VME2_GCSR_0		0x0108
#define	VME2_GCSR_1		0x010c
#define	VME2_GCSR_2		0x0110
#define	VME2_GCSR_3		0x0114
#define	VME2_GCSR_4		0x0118
#define	VME2_GCSR_5		0x011c

#define	VME2_SADDR_END		0xffff0000	/* VME address END & START */
#define	VME2_SADDR_START	0x0000ffff
#define	VME2_SADDR_LADDR	0xffff0000		/* local base address */
#define	VME2_SADDR_SIZE(mem)	(0x1000 - (mem) >> 16)	/* encoding of size */

#define	VME2_SLAVE_CHOOSE(bits, num) ((bits) << (16*((num)-1)))
#define	VME2_SLAVECTL_WP	0x00000100		/* write posting */
#define	VME2_SLAVECTL_SNP_NO	0x00000000		/* no snooping */
#define	VME2_SLAVECTL_SNP_SINK	0x00000200		/* sink data */
#define	VME2_SLAVECTL_SNP_INVAL	0x00000400		/* invalidate */
#define	VME2_SLAVECTL_ADDER	0x00000800		/* use adder */
#define	VME2_SLAVECTL_SUP	0x00000080		/* modifier bit */
#define	VME2_SLAVECTL_USR	0x00000040		/* modifier bit */
#define	VME2_SLAVECTL_A32	0x00000020		/* modifier bit */
#define	VME2_SLAVECTL_A24	0x00000010		/* modifier bit */
#define	VME2_SLAVECTL_D64	0x00000008		/* modifier bit */
#define	VME2_SLAVECTL_BLK	0x00000004		/* modifier bit */
#define	VME2_SLAVECTL_PGM	0x00000002		/* modifier bit */
#define	VME2_SLAVECTL_DAT	0x00000001		/* modifier bit */

#define	VME2_MASTERCTL_4SHIFT	24
#define	VME2_MASTERCTL_3SHIFT	16
#define	VME2_MASTERCTL_2SHIFT	8
#define	VME2_MASTERCTL_1SHIFT	0
#define	VME2_MASTERCTL_D16	0x80
#define	VME2_MASTERCTL_WP	0x40
#define	VME2_MASTERCTL_AM	0x3f
#define	VME2_MASTERCTL_AM24SB	0x3f	/* A24 Supervisory Block Transfer */
#define	VME2_MASTERCTL_AM24SP	0x3e	/* A24 Supervisory Program Access */
#define	VME2_MASTERCTL_AM24SD	0x3d	/* A24 Supervisory Data Access */
#define	VME2_MASTERCTL_AM24UB	0x3b	/* A24 Non-priv. Block Transfer */
#define	VME2_MASTERCTL_AM24UP	0x3a	/* A24 Non-priv. Program Access */
#define	VME2_MASTERCTL_AM24UD	0x39	/* A24 Non-priv. Data Access */
#define	VME2_MASTERCTL_AM16S		0x2d	/* A16 Supervisory Access */
#define	VME2_MASTERCTL_AM16U		0x29	/* A16 Non-priv. Access */
#define	VME2_MASTERCTL_AM32SB	0x0f	/* A32 Supervisory Block Transfer */
#define	VME2_MASTERCTL_AM32SP	0x0e	/* A32 Supervisory Program Access */
#define	VME2_MASTERCTL_AM32SD	0x0d	/* A32 Supervisory Data Access */
#define	VME2_MASTERCTL_AM32UB	0x0b	/* A32 Non-priv. Block Transfer */
#define	VME2_MASTERCTL_AM32UP	0x0a	/* A32 Non-priv. Program Access */
#define	VME2_MASTERCTL_AM32UD	0x09	/* A32 Non-priv Data Access */

#define	VME2_MASTERCTL_ALL	0xff

#define	VME2_GCSRCTL_OFF	0xf0000000
#define	VME2_GCSRCTL_MDEN4	0x00080000
#define	VME2_GCSRCTL_MDEN3	0x00040000
#define	VME2_GCSRCTL_MDEN2	0x00020000
#define	VME2_GCSRCTL_MDEN1	0x00010000
#define	VME2_GCSRCTL_I2EN	0x00008000	/* F decode (A24D16/A32D16) on */
#define	VME2_GCSRCTL_I2WP	0x00004000	/* F decode write post */
#define	VME2_GCSRCTL_I2SU	0x00002000	/* F decode is supervisor */
#define	VME2_GCSRCTL_I2PD	0x00001000	/* F decode is program */
#define	VME2_GCSRCTL_I1EN	0x00000800	/* short decode (A16Dx) on */
#define	VME2_GCSRCTL_I1D16	0x00000400	/* short decode is D16 */
#define	VME2_GCSRCTL_I1WP	0x00000200	/* short decode write post */
#define	VME2_GCSRCTL_I1SU	0x00000100	/* short decode is supervisor */
#define	VME2_GCSRCTL_ROMSIZE	0x000000c0	/* size of ROM */
#define	VME2_GCSRCTL_ROMBSPD	0x00000038	/* speed of ROM */
#define	VME2_GCSRCTL_ROMASPD	0x00000007	/* speed of ROM */

#define	VME2_TCR_1MS		(1 << 8)       	/* Watchdog 1 ms */
#define	VME2_TCR_2MS		(2 << 8)       	/* Watchdog 2 ms */
#define	VME2_TCR_4MS		(3 << 8)       	/* Watchdog 4 ms */
#define	VME2_TCR_8MS		(4 << 8)       	/* Watchdog 8 ms */
#define	VME2_TCR_16MS		(5 << 8)       	/* Watchdog 16 ms */
#define	VME2_TCR_32MS		(6 << 8)       	/* Watchdog 32 ms */
#define	VME2_TCR_64MS		(7 << 8)       	/* Watchdog 64 ms */
#define	VME2_TCR_128MS		(8 << 8)       	/* Watchdog 128 ms */
#define	VME2_TCR_256MS		(9 << 8)       	/* Watchdog 256 ms */
#define	VME2_TCR_512MS		(10 << 8)	/* Watchdog 512 ms */
#define	VME2_TCR_1S		(11 << 8)	/* Watchdog 1 s */
#define	VME2_TCR_4S		(12 << 8)	/* Watchdog 4 s */
#define	VME2_TCR_16S		(13 << 8)	/* Watchdog 16 s */
#define	VME2_TCR_32S		(14 << 8)	/* Watchdog 32 s */
#define	VME2_TCR_64S		(15 << 8)	/* Watchdog 64 s */

#define	VME2_TCTL1_CEN		0x01
#define	VME2_TCTL1_COC		0x02
#define	VME2_TCTL1_COVF		0x04
#define	VME2_TCTL1_OVF		0xf0
#define	VME2_TCTL2_CEN		(0x01 << 8)
#define	VME2_TCTL2_COC		(0x02 << 8)
#define	VME2_TCTL2_COVF		(0x04 << 8)
#define	VME2_TCTL2_OVF		(0xf0 << 8)
#define	VME2_TCTL_WDEN		0x00010000	/* Watchdog Enable */
#define	VME2_TCTL_WDRSE		0x00020000	/* Watchdog Reset Enable */
#define	VME2_TCTL_WDSL		0x00040000	/* local or system reset */
#define	VME2_TCTL_WDBFE		0x00080000	/* Watchdog Board Fail Enable */
#define	VME2_TCTL_WDTO		0x00100000	/* Watchdog Timeout Status */
#define	VME2_TCTL_WDCC		0x00200000	/* Watchdog Clear Counter */
#define	VME2_TCTL_WDCS		0x00400000	/* Watchdog Clear Timeout */
#define	VME2_TCTL_SRST		0x00800000	/* system reset */
#define	VME2_TCTL_RSWE		0x01000000	/* Reset Switch Enable */
#define	VME2_TCTL_BDFLO		0x02000000	/* Assert Board Fail */
#define	VME2_TCTL_CPURS		0x04000000	/* Clear Power-up Reset bit */
#define	VME2_TCTL_PURS		0x08000000	/* Power-up Reset bit */
#define	VME2_TCTL_BDFLI		0x10000000	/* Board Fail Status*/
#define	VME2_TCTL_SYSFAIL	0x20000000	/* light SYSFAIL led */
#define	VME2_TCTL_SCON		0x40000000	/* we are SCON */

#define	VME2_IRQ_ACF		0x80000000
#define	VME2_IRQ_AB		0x40000000
#define	VME2_IRQ_SYSF		0x20000000
#define	VME2_IRQ_MWP		0x10000000
#define	VME2_IRQ_PE		0x08000000
#define	VME2_IRQ_V1IE		0x04000000
#define	VME2_IRQ_TIC2		0x02000000
#define	VME2_IRQ_TIC1		0x01000000
#define	VME2_IRQ_VIA		0x00800000
#define	VME2_IRQ_DMA		0x00400000
#define	VME2_IRQ_SIG3		0x00200000
#define	VME2_IRQ_SIG2		0x00100000
#define	VME2_IRQ_SIG1		0x00080000
#define	VME2_IRQ_SIG0		0x00040000
#define	VME2_IRQ_LM1		0x00020000
#define	VME2_IRQ_LM0		0x00010000
#define	VME2_IRQ_SW7		0x00008000
#define	VME2_IRQ_SW6		0x00004000
#define	VME2_IRQ_SW5		0x00002000
#define	VME2_IRQ_SW4		0x00001000
#define	VME2_IRQ_SW3		0x00000800
#define	VME2_IRQ_SW2		0x00000400
#define	VME2_IRQ_SW1		0x00000200
#define	VME2_IRQ_SW0		0x00000100
#define	VME2_IRQ_SW(x)		((1 << (x))) << 8)
#define	VME2_IRQ_SPARE		0x00000080
#define	VME2_IRQ_VME7		0x00000040
#define	VME2_IRQ_VME6		0x00000020
#define	VME2_IRQ_VME5		0x00000010
#define	VME2_IRQ_VME4		0x00000008
#define	VME2_IRQ_VME3		0x00000004
#define	VME2_IRQ_VME2		0x00000002
#define	VME2_IRQ_VME1		0x00000001
#define	VME2_IRQ_VME(x)		(1 << ((x) - 1))

#define	VME2_IRQL1_ACFSHIFT	28
#define	VME2_IRQL1_ABSHIFT	24
#define	VME2_IRQL1_SYSFSHIFT	20
#define	VME2_IRQL1_WPESHIFT	16
#define	VME2_IRQL1_PESHIFT	12
#define	VME2_IRQL1_V1IESHIFT	8
#define	VME2_IRQL1_TIC2SHIFT	4
#define	VME2_IRQL1_TIC1SHIFT	0

#define	VME2_IRQL2_VIASHIFT	28
#define	VME2_IRQL2_DMASHIFT	24
#define	VME2_IRQL2_SIG3SHIFT	20
#define	VME2_IRQL2_SIG2SHIFT	16
#define	VME2_IRQL2_SIG1SHIFT	12
#define	VME2_IRQL2_SIG0SHIFT	8
#define	VME2_IRQL2_LM1SHIFT	4
#define	VME2_IRQL2_LM0SHIFT	0

#define	VME2_IRQL3_SW7SHIFT	28
#define	VME2_IRQL3_SW6SHIFT	24
#define	VME2_IRQL3_SW5SHIFT	20
#define	VME2_IRQL3_SW4SHIFT	16
#define	VME2_IRQL3_SW3SHIFT	12
#define	VME2_IRQL3_SW2SHIFT	8
#define	VME2_IRQL3_SW1SHIFT	4
#define	VME2_IRQL3_SW0SHIFT	0

#define	VME2_IRQL4_SPARESHIFT	28
#define	VME2_IRQL4_VME7SHIFT	24
#define	VME2_IRQL4_VME6SHIFT	20
#define	VME2_IRQL4_VME5SHIFT	16
#define	VME2_IRQL4_VME4SHIFT	12
#define	VME2_IRQL4_VME3SHIFT	8
#define	VME2_IRQL4_VME2SHIFT	4
#define	VME2_IRQL4_VME1SHIFT	0

#define	VME2_SYSFAIL		(1 << 22)
#define	VME2_IOCTL1_MIEN	(1 << 23)
#define	VME2_VBR_0SHIFT		28
#define	VME2_VBR_1SHIFT		24
#define	VME2_SET_VBR0(x)	((x) << VME2_VBR_0SHIFT)
#define	VME2_SET_VBR1(x)	((x) << VME2_VBR_1SHIFT)
#define	VME2_GET_VBR0(x)	((((x) >> 28) & 0xf) << 4)
#define	VME2_GET_VBR1(x)	((((x) >> 24) & 0xf) << 4)
#define	VME2_VBR_GPOXXXX	0x00ffffff

#define	VME2_MISC_MPIRQEN	0x00000080	/* do not set */
#define	VME2_MISC_REVEROM	0x00000040	/* 167: dis eprom. 166: en flash */
#define	VME2_MISC_DISSRAM	0x00000020	/* do not set */
#define	VME2_MISC_DISMST	0x00000010
#define	VME2_MISC_NOELBBSY	0x00000008	/* do not set */
#define	VME2_MISC_DISBSYT	0x00000004	/* do not set */
#define	VME2_MISC_ENINT		0x00000002	/* do not set */
#define	VME2_MISC_DISBGN	0x00000001	/* do not set */

#define	VME2_GCSR_LM3		0x8000
#define	VME2_GCSR_LM2		0x4000
#define	VME2_GCSR_LM1		0x2000
#define	VME2_GCSR_LM0		0x1000
#define	VME2_GCSR_SIG3		0x0800
#define	VME2_GCSR_SIG2		0x0400
#define	VME2_GCSR_SIG1		0x0200
#define	VME2_GCSR_SIG0		0x0100
#define	VME2_GCSR_RST		0x0080
#define	VME2_GCSR_ISF		0x0040
#define	VME2_GCSR_BF		0x0020
#define	VME2_GCSR_SCON		0x0010
#define	VME2_GCSR_SF		0x0008

#define	VME2_A16D32BASE	0xffff0000UL
#define	VME2_A16D32LEN	0x00010000UL
#define	VME2_A32D16BASE	0xf1000000UL
#define	VME2_A32D16LEN	0x01000000UL
#define	VME2_A16D16BASE	0xffff0000UL
#define	VME2_A16D16LEN	0x00010000UL
#define	VME2_A24D16BASE	0xf0000000UL
#define	VME2_A24D16LEN	0x01000000UL
#define	VME2_A16BASE	0xffff0000UL
#define	VME2_A24BASE	0xff000000UL

paddr_t	vmepmap(struct device *sc, off_t vmeaddr, int bustype);
int	vmerw(struct device *sc, struct uio *uio, int flags, int bus);
int	vmeintr_establish(int, struct intrhand *, const char *);
int	vme_findvec(int);
int	vmescan(struct device *, void *, void *, int);

#endif /* __MVME88K_DEV_VME_H__ */
@


1.19
log
@Replace the bunch of md_* function pointers with a `struct board' containing
function pointers for all the board-specific code.

Add a bunch of `struct board' methods to cover most, if not all, of the
`per-board' logic. This allows most of the md drivers to be cleaned up and
no longer need to embed board-specific knowledge.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.h,v 1.18 2013/05/14 21:01:21 miod Exp $ */
@


1.18
log
@typo in multiple inclusion guard symbol name.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.h,v 1.17 2005/11/25 22:14:32 miod Exp $ */
a30 11
struct vmesoftc {
	struct device		sc_dev;
	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
	struct intrhand 	sc_abih;       /* `abort' switch */
};

/*
 * XXX: this chip has some rather insane access rules!
 */

d70 9
d270 14
d295 5
a299 5
paddr_t vmepmap(struct device *sc, off_t vmeaddr, int bustype);
int vmerw(struct device *sc, struct uio *uio, int flags, int bus);
int vmeintr_establish(int, struct intrhand *, const char *);
int vme_findvec(int);
int vmescan(struct device *, void *, void *, int);
@


1.17
log
@Prefer vaddr_t and paddr_t types, instead of void * and heavy casts.
Improves readability, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.h,v 1.16 2004/07/30 19:02:06 miod Exp $ */
d28 2
a29 2
#ifndef __MVEME88K_DEV_VME_H__
#define	__MVEME88K_DEV_VME_H__
d289 1
a289 1
#endif /* __MVEME88K_DEV_VME_H__ */
@


1.16
log
@Move evcount structures inside struct intrhand, this makes more sense and
gives us more counters in the process.

Also clean up intrhand structures and usage, especially move them to SLISTs.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.h,v 1.15 2004/04/24 19:51:48 miod Exp $ */
d283 1
a283 1
void *vmepmap(struct device *sc, off_t vmeaddr, int bustype);
@


1.15
log
@Preliminary switch to an mvme88k bus_space world. Not all drivers have been
converted yet, and they rely upon some linear mappings provided by bus_space.

In order to not impact performance, almost all the bus_space accesses go
through macros and inline functions. This currently restricts us to D16 and
D32 access modes, which are selected at compilation time. Since there are no
plans to support D8 vme devices in the future, this is acceptable for now.

This makes the "len" locator for vme devices go away, and allows to simplify
some code which was using the pcctwo device, and will now directly access
hardware which is known to exist, rather than wait until the device is
attached.

While there, try to enforce more interrupt vector number checks, since these
changes pointed out that dart(4) had been working correctly so far by sheer
luck only.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.h,v 1.14 2004/04/16 23:35:50 miod Exp $ */
d285 1
a285 1
int vmeintr_establish(int vec, struct intrhand *ih);
@


1.14
log
@When a VMEBus device needs to use two interrupt vectors, be nice and let it
actually use two distinct vectors, rather than twice the same.

Because of this, print vector last in vmeprint() so that dmesg remains pretty
in the multi-vector case.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.h,v 1.13 2003/12/28 19:44:26 miod Exp $ */
d29 1
a29 1
#define __MVEME88K_DEV_VME_H__
d32 4
a35 3
	struct device	sc_dev;
	void *		sc_vaddr;
	struct intrhand sc_abih;       /* `abort' switch */
d39 1
a39 1
 * XXX: this chip has some rather inane access rules!
d41 67
a107 37
struct vme2reg {
/*00*/	volatile u_long		vme2_slaveaddr1;
/*04*/	volatile u_long		vme2_slaveaddr2;
#define VME2_SADDR_END		0xffff0000		/* VME address END & START */
#define VME2_SADDR_START	0x0000ffff
/*08*/	volatile u_long		vme2_slavelmod1;
/*0c*/	volatile u_long		vme2_slavelmod2;
#define VME2_SADDR_LADDR	0xffff0000		/* local base address */
#define VME2_SADDR_SIZE(mem)	(0x1000 - (mem) >> 16)	/* encoding of size */
/*10*/	volatile u_long		vme2_slavectl;
#define VME2_SLAVE_CHOOSE(bits, num) ((bits) << (16*((num)-1)))
#define VME2_SLAVECTL_WP	0x00000100		/* write posting */
#define VME2_SLAVECTL_SNP_NO	0x00000000		/* no snooping */
#define VME2_SLAVECTL_SNP_SINK	0x00000200		/* sink data */
#define VME2_SLAVECTL_SNP_INVAL	0x00000400		/* invalidate */
#define VME2_SLAVECTL_ADDER	0x00000800		/* use adder */
#define VME2_SLAVECTL_SUP	0x00000080		/* modifier bit */
#define VME2_SLAVECTL_USR	0x00000040		/* modifier bit */
#define VME2_SLAVECTL_A32	0x00000020		/* modifier bit */
#define VME2_SLAVECTL_A24	0x00000010		/* modifier bit */
#define VME2_SLAVECTL_D64	0x00000008		/* modifier bit */
#define VME2_SLAVECTL_BLK	0x00000004		/* modifier bit */
#define VME2_SLAVECTL_PGM	0x00000002		/* modifier bit */
#define VME2_SLAVECTL_DAT	0x00000001		/* modifier bit */
/*14*/	volatile u_long		vme2_master1;
/*18*/	volatile u_long		vme2_master2;
/*1c*/	volatile u_long		vme2_master3;
/*20*/	volatile u_long		vme2_master4;
/*24*/	volatile u_long		vme2_master4mod;
/*28*/	volatile u_long		vme2_masterctl;
#define VME2_MASTERCTL_4SHIFT	24
#define VME2_MASTERCTL_3SHIFT	16
#define VME2_MASTERCTL_2SHIFT	8
#define VME2_MASTERCTL_1SHIFT	0
#define VME2_MASTERCTL_D16	0x80
#define VME2_MASTERCTL_WP	0x40
#define VME2_MASTERCTL_AM	0x3f
d123 148
a270 164
#define VME2_MASTERCTL_ALL	0xff
/*2c*/	volatile u_long		vme2_gcsrctl;
#define VME2_GCSRCTL_OFF	0xf0000000
#define VME2_GCSRCTL_MDEN4	0x00080000
#define VME2_GCSRCTL_MDEN3	0x00040000
#define VME2_GCSRCTL_MDEN2	0x00020000
#define VME2_GCSRCTL_MDEN1	0x00010000
#define VME2_GCSRCTL_I2EN	0x00008000	/* F decode (A24D16/A32D16) on */
#define VME2_GCSRCTL_I2WP	0x00004000	/* F decode write post */
#define VME2_GCSRCTL_I2SU	0x00002000	/* F decode is supervisor */
#define VME2_GCSRCTL_I2PD	0x00001000	/* F decode is program */
#define VME2_GCSRCTL_I1EN	0x00000800	/* short decode (A16Dx) on */
#define VME2_GCSRCTL_I1D16	0x00000400	/* short decode is D16 */
#define VME2_GCSRCTL_I1WP	0x00000200	/* short decode write post */
#define VME2_GCSRCTL_I1SU	0x00000100	/* short decode is supervisor */
#define VME2_GCSRCTL_ROMSIZE	0x000000c0	/* size of ROM */
#define VME2_GCSRCTL_ROMBSPD	0x00000038	/* speed of ROM */
#define VME2_GCSRCTL_ROMASPD	0x00000007	/* speed of ROM */
/*30*/	volatile u_long		vme2_dmactl;
/*34*/	volatile u_long		vme2_dmamode;
/*38*/	volatile u_long		vme2_dmaladdr;
/*3c*/	volatile u_long		vme2_dmavmeaddr;
/*40*/	volatile u_long		vme2_dmacount;
/*44*/	volatile u_long		vme2_dmatable;
/*48*/	volatile u_long		vme2_dmastat;
/*4c*/	volatile u_long		vme2_tcr;
#define VME2_TCR_1MS		(1 << 8)       	/* Watchdog 1 ms */
#define VME2_TCR_2MS		(2 << 8)       	/* Watchdog 2 ms */
#define VME2_TCR_4MS		(3 << 8)       	/* Watchdog 4 ms */
#define VME2_TCR_8MS		(4 << 8)       	/* Watchdog 8 ms */
#define VME2_TCR_16MS		(5 << 8)       	/* Watchdog 16 ms */
#define VME2_TCR_32MS		(6 << 8)       	/* Watchdog 32 ms */
#define VME2_TCR_64MS		(7 << 8)       	/* Watchdog 64 ms */
#define VME2_TCR_128MS		(8 << 8)       	/* Watchdog 128 ms */
#define VME2_TCR_256MS		(9 << 8)       	/* Watchdog 256 ms */
#define VME2_TCR_512MS		(10 << 8)	/* Watchdog 512 ms */
#define VME2_TCR_1S		(11 << 8)	/* Watchdog 1 s */
#define VME2_TCR_4S		(12 << 8)	/* Watchdog 4 s */
#define VME2_TCR_16S		(13 << 8)	/* Watchdog 16 s */
#define VME2_TCR_32S		(14 << 8)	/* Watchdog 32 s */
#define VME2_TCR_64S		(15 << 8)	/* Watchdog 64 s */
/*50*/	volatile u_long		vme2_t1cmp;
/*54*/	volatile u_long		vme2_t1count;
/*58*/	volatile u_long		vme2_t2cmp;
/*5c*/	volatile u_long		vme2_t2count;
/*60*/	volatile u_long		vme2_tctl;
#define VME2_TCTL1_CEN		0x01
#define VME2_TCTL1_COC		0x02
#define VME2_TCTL1_COVF		0x04
#define VME2_TCTL1_OVF		0xf0
#define VME2_TCTL2_CEN		(0x01 << 8)
#define VME2_TCTL2_COC		(0x02 << 8)
#define VME2_TCTL2_COVF		(0x04 << 8)
#define VME2_TCTL2_OVF		(0xf0 << 8)
#define VME2_TCTL_WDEN		0x00010000	/* Watchdog Enable */
#define VME2_TCTL_WDRSE		0x00020000	/* Watchdog Reset Enable */
#define VME2_TCTL_WDSL		0x00040000	/* local or system reset */
#define VME2_TCTL_WDBFE		0x00080000	/* Watchdog Board Fail Enable */
#define VME2_TCTL_WDTO		0x00100000	/* Watchdog Timeout Status */
#define VME2_TCTL_WDCC		0x00200000	/* Watchdog Clear Counter */
#define VME2_TCTL_WDCS		0x00400000	/* Watchdog Clear Timeout */
#define VME2_TCTL_SRST		0x00800000	/* system reset */
#define VME2_TCTL_RSWE		0x01000000	/* Reset Switch Enable */
#define VME2_TCTL_BDFLO		0x02000000	/* Assert Board Fail */
#define VME2_TCTL_CPURS		0x04000000	/* Clear Power-up Reset bit */
#define VME2_TCTL_PURS		0x08000000	/* Power-up Reset bit */
#define VME2_TCTL_BDFLI		0x10000000	/* Board Fail Status*/
#define VME2_TCTL_SYSFAIL	0x20000000	/* light SYSFAIL led */
#define VME2_TCTL_SCON		0x40000000	/* we are SCON */
/*64*/	volatile u_long		vme2_prescale;
/*68*/	volatile u_long		vme2_irqstat;
/*6c*/	volatile u_long		vme2_irqen;
/*70*/	volatile u_long		vme2_setsoftirq;	/* VME2_IRQ_SWx only */
/*74*/	volatile u_long		vme2_irqclr;		/* except VME2_IRQ_VMEx */
#define VME2_IRQ_ACF		0x80000000
#define VME2_IRQ_AB		0x40000000
#define VME2_IRQ_SYSF		0x20000000
#define VME2_IRQ_MWP		0x10000000
#define VME2_IRQ_PE		0x08000000
#define VME2_IRQ_V1IE		0x04000000
#define VME2_IRQ_TIC2		0x02000000
#define VME2_IRQ_TIC1		0x01000000
#define VME2_IRQ_VIA		0x00800000
#define VME2_IRQ_DMA		0x00400000
#define VME2_IRQ_SIG3		0x00200000
#define VME2_IRQ_SIG2		0x00100000
#define VME2_IRQ_SIG1		0x00080000
#define VME2_IRQ_SIG0		0x00040000
#define VME2_IRQ_LM1		0x00020000
#define VME2_IRQ_LM0		0x00010000
#define VME2_IRQ_SW7		0x00008000
#define VME2_IRQ_SW6		0x00004000
#define VME2_IRQ_SW5		0x00002000
#define VME2_IRQ_SW4		0x00001000
#define VME2_IRQ_SW3		0x00000800
#define VME2_IRQ_SW2		0x00000400
#define VME2_IRQ_SW1		0x00000200
#define VME2_IRQ_SW0		0x00000100
#define VME2_IRQ_SW(x)		((1 << (x))) << 8)
#define VME2_IRQ_SPARE		0x00000080
#define VME2_IRQ_VME7		0x00000040
#define VME2_IRQ_VME6		0x00000020
#define VME2_IRQ_VME5		0x00000010
#define VME2_IRQ_VME4		0x00000008
#define VME2_IRQ_VME3		0x00000004
#define VME2_IRQ_VME2		0x00000002
#define VME2_IRQ_VME1		0x00000001
#define VME2_IRQ_VME(x)		(1 << ((x) - 1))
/*78*/	volatile u_long		vme2_irql1;
#define VME2_IRQL1_ACFSHIFT	28
#define VME2_IRQL1_ABSHIFT	24
#define VME2_IRQL1_SYSFSHIFT	20
#define VME2_IRQL1_WPESHIFT	16
#define VME2_IRQL1_PESHIFT	12
#define VME2_IRQL1_V1IESHIFT	8
#define VME2_IRQL1_TIC2SHIFT	4
#define VME2_IRQL1_TIC1SHIFT	0
/*7c*/	volatile u_long		vme2_irql2;
#define VME2_IRQL2_VIASHIFT	28
#define VME2_IRQL2_DMASHIFT	24
#define VME2_IRQL2_SIG3SHIFT	20
#define VME2_IRQL2_SIG2SHIFT	16
#define VME2_IRQL2_SIG1SHIFT	12
#define VME2_IRQL2_SIG0SHIFT	8
#define VME2_IRQL2_LM1SHIFT	4
#define VME2_IRQL2_LM0SHIFT	0
/*80*/	volatile u_long		vme2_irql3;
#define VME2_IRQL3_SW7SHIFT	28
#define VME2_IRQL3_SW6SHIFT	24
#define VME2_IRQL3_SW5SHIFT	20
#define VME2_IRQL3_SW4SHIFT	16
#define VME2_IRQL3_SW3SHIFT	12
#define VME2_IRQL3_SW2SHIFT	8
#define VME2_IRQL3_SW1SHIFT	4
#define VME2_IRQL3_SW0SHIFT	0
/*84*/	volatile u_long		vme2_irql4;
#define VME2_IRQL4_SPARESHIFT	28
#define VME2_IRQL4_VME7SHIFT	24
#define VME2_IRQL4_VME6SHIFT	20
#define VME2_IRQL4_VME5SHIFT	16
#define VME2_IRQL4_VME4SHIFT	12
#define VME2_IRQL4_VME3SHIFT	8
#define VME2_IRQL4_VME2SHIFT	4
#define VME2_IRQL4_VME1SHIFT	0
/*88*/	volatile u_long		vme2_vbr;
#define VME2_SYSFAIL       (1 << 22)
#define VME2_IOCTL1_MIEN       	(1 << 23)
#define VME2_VBR_0SHIFT		28
#define VME2_VBR_1SHIFT		24
#define VME2_SET_VBR0(x)	((x) << VME2_VBR_0SHIFT)
#define VME2_SET_VBR1(x)	((x) << VME2_VBR_1SHIFT)
#define VME2_GET_VBR0(x)	((((x)->vme2_vbr >> 28) & 0xf) << 4)
#define VME2_GET_VBR1(x)	((((x)->vme2_vbr >> 24) & 0xf) << 4)
#define VME2_VBR_GPOXXXX	0x00ffffff
/*8c*/	volatile u_long		vme2_misc;
#define VME2_MISC_MPIRQEN	0x00000080	/* do not set */
#define VME2_MISC_REVEROM	0x00000040	/* 167: dis eprom. 166: en flash */
#define VME2_MISC_DISSRAM	0x00000020	/* do not set */
#define VME2_MISC_DISMST	0x00000010
#define VME2_MISC_NOELBBSY	0x00000008	/* do not set */
#define VME2_MISC_DISBSYT	0x00000004	/* do not set */
#define VME2_MISC_ENINT		0x00000002	/* do not set */
#define VME2_MISC_DISBGN	0x00000001	/* do not set */
};
d272 10
a281 10
#define VME2_A16D32BASE	0xffff0000UL
#define VME2_A16D32LEN	0x00010000UL
#define VME2_A32D16BASE	0xf1000000UL
#define VME2_A32D16LEN	0x01000000UL
#define VME2_A16D16BASE	0xffff0000UL
#define VME2_A16D16LEN	0x00010000UL
#define VME2_A24D16BASE	0xf0000000UL
#define VME2_A24D16LEN	0x01000000UL
#define VME2_A16BASE	0xffff0000UL
#define VME2_A24BASE	0xff000000UL
d283 1
a283 1
void *vmepmap(struct device *sc, off_t vmeaddr, int len, int bustype);
a287 4

/* D16 access functions */
void d16_bcopy(const void *, void *, size_t);
void d16_bzero(void *, size_t);
@


1.13
log
@Having vmel and vmes keep another pointer to their parent in their softc is
just plain silly!
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.h,v 1.12 2003/12/25 21:01:39 miod Exp $ */
d271 1
a271 1
int vme_findvec(void);
@


1.12
log
@Provide common D16 vmespace block access functions, instead of vs and vx each
rolling their own.

Use them more cleverly in vx, in order to get the driver to at least attach
and frob chips. Not tested besides multiuser boot (hence ttyflags -a), and
checking cu(1) connects. More testing to come once I remember where I have
hidden the 332XT transition module...
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.h,v 1.11 2003/12/22 11:54:48 miod Exp $ */
a36 103
struct vmessoftc {
	struct device		sc_dev;
	struct vmesoftc		*sc_vme;
};

struct vmelsoftc {
	struct device		sc_dev;
	struct vmesoftc		*sc_vme;
};

/*
 * MVME147 vme configuration registers.
*/
struct vme1reg {
/*01*/	volatile u_short		vme1_scon;
#define VME1_SCON_SWITCH	0x01		/* SCON jumper is set */
#define VME1_SCON_SRESET	0x02		/* assert SRESET on bus */
#define VME1_SCON_SYSFAIL	0x04		/* assert SYSFAIL on bus */
#define VME1_SCON_ROBIN		0x08		/* round robin bus requests */
/*03*/	volatile u_short		vme1_reqconf;
#define VME1_REQ_IPLMASK	0x03		/* interrupt level for requester */
#define VME1_REQ_RNEVER		0x08
#define VME1_REQ_RWD		0x10
#define VME1_REQ_DHB		0x40
#define VME1_REQ_DWB		0x80
/*05*/	volatile u_short		vme1_masconf;
#define VME1_MAS_D16		0x01		/* force d8/16 accesses only */
#define VME1_MAS_MASA24		0x02		/* send address mod for A24 access */
#define VME1_MAS_MASA16		0x04		/* send address mod for A16 access */
#define VME1_MAS_MASUAT		0x08		/* handle unaligned VME cycles */
#define VME1_MAS_CFILL		0x10		/* DO NOT USE */
#define VME1_MAS_MASWP		0x20		/* VME fast mode (DO NOT USE) */
/*07*/	volatile u_short		vme1_slconf;
#define VME1_SLAVE_SLVD16	0x01		/* DO NOT USE */
#define VME1_SLAVE_SLVWP	0x20		/* DO NOT USE */
#define VME1_SLAVE_SLVEN	0x80		/* allow access to onboard DRAM */
/*09*/	volatile u_short		vme1_timerconf;
#define VME1_TIMER_LOCAL_MASK	0x03
#define VME1_TIMER_LOCAL_T0	0x00		/* local timeout 102 microsec */
#define VME1_TIMER_LOCAL_T1	0x01		/* local timeout 205 microsec */
#define VME1_TIMER_LOCAL_T2	0x02		/* local timeout 410 microsec */
#define VME1_TIMER_LOCAL_T3	0x03		/* local timeout disabled */
#define VME1_TIMER_VMEACC_MASK	0x0c
#define VME1_TIMER_VMEACC_T0	0x00		/* VME access timeout 102 microsec */
#define VME1_TIMER_VMEACC_T1	0x04		/* VME access timeout 1.6 millisec */
#define VME1_TIMER_VMEACC_T2	0x08		/* VME access timeout 51 millisec */
#define VME1_TIMER_VMEACC_T3	0x0c		/* VME access timeout disabled */
#define VME1_TIMER_VMEGLO_MASK	0x30
#define VME1_TIMER_VMEGLO_T0	0x00		/* VME glob timeout 102 microsec */
#define VME1_TIMER_VMEGLO_T1	0x10		/* VME glob timeout 205 microsec */
#define VME1_TIMER_VMEGLO_T2	0x20		/* VME glob timeout 410 microsec */
#define VME1_TIMER_VMEGLO_T3	0x30		/* VME glob timeout disabled */
#define VME1_TIMER_ARBTO	0x40		/* enable VME arbitration timer */
/*0b*/	volatile u_short		vme1_sladdrmod;
#define VME1_SLMOD_DATA		0x01
#define VME1_SLMOD_PRGRM	0x02
#define VME1_SLMOD_BLOCK	0x04
#define VME1_SLMOD_SHORT	0x08
#define VME1_SLMOD_STND		0x10
#define VME1_SLMOD_EXTED	0x20
#define VME1_SLMOD_USER		0x40
#define VME1_SLMOD_SUPER	0x80
/*0d*/	volatile u_short		vme1_msaddrmod;
#define VME1_MSMOD_AM_MASK	0x3f
#define VME1_MSMOD_AMSEL	0x80
/*0f*/	volatile u_short		vme1_irqen;
#define VME1_IRQ_VME(x)		(1 << (x))
/*11*/	volatile u_short		vme1_uirqen;
/*13*/	volatile u_short		vme1_uirq;
/*15*/	volatile u_short		vme1_irq;
/*17*/	volatile u_short		vme1_vmeid;
/*19*/	volatile u_short		vme1_buserr;
/*1b*/	volatile u_short		vme1_gcsr;
#define VME1_GCSR_OFF		0x0f
/*1d*/	u_short			:16;
/*1f*/	u_short			:16;
/*21*/	volatile u_short		vme1_gcsr_gr0;
/*23*/	volatile u_short		vme1_gcsr_gr1;
/*25*/	volatile u_short		vme1_gcsr_boardid;
/*27*/	volatile u_short		vme1_gcsr_gpr0;
/*29*/	volatile u_short		vme1_gcsr_gpr1;
/*2b*/	volatile u_short		vme1_gcsr_gpr2;
/*2d*/	volatile u_short		vme1_gcsr_gpr3;
/*2f*/	volatile u_short		vme1_gcsr_gpr4;
};

/*
 * Basic VME memory layout for the MVME147 follows:
 *    - A32D32 accesses occur at memsize-0xefffffff. This makes it
 *	impossible to do A32D32 accesses before the end of your onboard
 *	memory. If you want to do low address A24D32 accesses, and you
 *	have 16M or more onboard memory you'll find you cannot.
 *    - A32D16 accesses can occur at 0xf0000000-0xff7fffff.
 *    - A16D16 accesses can occur at 0xffff0000-0xffffffff.
 */
#define VME1_A32D32BASE	0x00000000UL
#define VME1_A32D32LEN	0xf0000000UL
#define VME1_A32D16BASE	0xf0000000UL
#define VME1_A32D16LEN	0x0f800000UL
#define VME1_A16D16BASE	0xffff0000UL
#define VME1_A16D16LEN	0x00010000UL
#define VME1_A16BASE	0xffff0000UL

d268 2
a269 2
void *vmepmap(struct vmesoftc *sc, off_t vmeaddr, int len, int bustype);
int vmerw(struct vmesoftc *sc, struct uio *uio, int flags, int bus);
@


1.11
log
@Correctly handle vme attachments which specify a larger ca_len size than
initially expected.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.h,v 1.10 2003/10/11 22:08:57 miod Exp $ */
d376 4
@


1.10
log
@Nuke trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.h,v 1.9 2003/06/04 04:11:37 deraadt Exp $ */
d371 1
a371 2
void * vmepmap(struct vmesoftc *sc, off_t vmeaddr, int len, int bustype);
void * vmemap(struct vmesoftc *sc, off_t vmeaddr, int len, int bustype);
@


1.9
log
@more term 3 and 4 changes
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.h,v 1.8 2002/03/14 01:26:39 millert Exp $ */
d350 1
a350 1
#define VME2_MISC_MPIRQEN	0x00000080	/* do not set */	
d353 1
a353 1
#define VME2_MISC_DISMST	0x00000010	
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.h,v 1.7 2001/11/07 22:31:57 miod Exp $ */
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Theo de Raadt
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.7
log
@post-mmap API change fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.h,v 1.6 2001/08/12 12:03:02 heko Exp $ */
d376 6
a381 6
void * vmepmap __P((struct vmesoftc *sc, off_t vmeaddr, int len, int bustype));
void * vmemap __P((struct vmesoftc *sc, off_t vmeaddr, int len, int bustype));
int vmerw __P((struct vmesoftc *sc, struct uio *uio, int flags, int bus));
int vmeintr_establish __P((int vec, struct intrhand *ih));
int vme_findvec __P((void));
int vmescan __P((struct device *, void *, void *, int));
@


1.7.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.h,v 1.7 2001/11/07 22:31:57 miod Exp $ */
d376 6
a381 6
void * vmepmap(struct vmesoftc *sc, off_t vmeaddr, int len, int bustype);
void * vmemap(struct vmesoftc *sc, off_t vmeaddr, int len, int bustype);
int vmerw(struct vmesoftc *sc, struct uio *uio, int flags, int bus);
int vmeintr_establish(int vec, struct intrhand *ih);
int vme_findvec(void);
int vmescan(struct device *, void *, void *, int);
@


1.6
log
@#(endif|else) foo is incorrect, make it #endif /* foo */
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.h,v 1.5 2001/03/09 05:44:39 smurph Exp $ */
d376 2
a377 2
void * vmepmap __P((struct vmesoftc *sc, void * vmeaddr, int len, int bustype));
void * vmemap __P((struct vmesoftc *sc, void * vmeaddr, int len, int bustype));
@


1.5
log
@kernel will compile with -Werror.  Added intr.h
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.h,v 1.4 2001/02/01 03:38:15 smurph Exp $ */
d383 1
a383 1
#endif __MVEME88K_DEV_VME_H__
@


1.4
log
@Major changes to get MVME188 working.  More header and code cleanups.  The
kernel is tested on MVME188A/2P256 and MVME188A/1P64.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.h,v 1.3 1999/05/29 04:41:44 smurph Exp $ */
d381 1
@


1.3
log
@Added vme bus device drivers. MVME328, MVME376, MVME332
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.h,v 1.2 1998/12/15 05:52:31 smurph Exp $ */
d33 3
a35 3
#if 0
#include <machine/cpu.h>
#endif
d225 16
a240 1
/*4c*/	volatile u_long		vme2_vmejunk;
d250 18
a268 2
#define VME2_TCTL_SYSFAIL	0x20000000	/* light SYSFAIL led */
#define VME2_TCTL_SRST		0x00800000	/* system reset */
d298 1
d346 1
d349 4
d376 7
a382 5
void * vmepmap __P((struct vmesoftc *sc, void * vmeaddr, int len,
	    int bustype));
void * vmemap __P((struct vmesoftc *sc, void * vmeaddr, int len,
	    int bustype));
int	vmerw __P((struct vmesoftc *sc, struct uio *uio, int flags, int bus));
@


1.3.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.h,v 1.5 2001/03/09 05:44:39 smurph Exp $ */
d33 3
a35 3
#ifndef __MVEME88K_DEV_VME_H__
#define __MVEME88K_DEV_VME_H__

d225 1
a225 16
/*4c*/	volatile u_long		vme2_tcr;
#define VME2_TCR_1MS		(1 << 8)       	/* Watchdog 1 ms */
#define VME2_TCR_2MS		(2 << 8)       	/* Watchdog 2 ms */
#define VME2_TCR_4MS		(3 << 8)       	/* Watchdog 4 ms */
#define VME2_TCR_8MS		(4 << 8)       	/* Watchdog 8 ms */
#define VME2_TCR_16MS		(5 << 8)       	/* Watchdog 16 ms */
#define VME2_TCR_32MS		(6 << 8)       	/* Watchdog 32 ms */
#define VME2_TCR_64MS		(7 << 8)       	/* Watchdog 64 ms */
#define VME2_TCR_128MS		(8 << 8)       	/* Watchdog 128 ms */
#define VME2_TCR_256MS		(9 << 8)       	/* Watchdog 256 ms */
#define VME2_TCR_512MS		(10 << 8)	/* Watchdog 512 ms */
#define VME2_TCR_1S		(11 << 8)	/* Watchdog 1 s */
#define VME2_TCR_4S		(12 << 8)	/* Watchdog 4 s */
#define VME2_TCR_16S		(13 << 8)	/* Watchdog 16 s */
#define VME2_TCR_32S		(14 << 8)	/* Watchdog 32 s */
#define VME2_TCR_64S		(15 << 8)	/* Watchdog 64 s */
d235 2
a236 11
#define VME2_TCTL2_CEN		(0x01 << 8)
#define VME2_TCTL2_COC		(0x02 << 8)
#define VME2_TCTL2_COVF		(0x04 << 8)
#define VME2_TCTL2_OVF		(0xf0 << 8)
#define VME2_TCTL_WDEN		0x00010000	/* Watchdog Enable */
#define VME2_TCTL_WDRSE		0x00020000	/* Watchdog Reset Enable */
#define VME2_TCTL_WDSL		0x00040000	/* local or system reset */
#define VME2_TCTL_WDBFE		0x00080000	/* Watchdog Board Fail Enable */
#define VME2_TCTL_WDTO		0x00100000	/* Watchdog Timeout Status */
#define VME2_TCTL_WDCC		0x00200000	/* Watchdog Clear Counter */
#define VME2_TCTL_WDCS		0x00400000	/* Watchdog Clear Timeout */
a237 7
#define VME2_TCTL_RSWE		0x01000000	/* Reset Switch Enable */
#define VME2_TCTL_BDFLO		0x02000000	/* Assert Board Fail */
#define VME2_TCTL_CPURS		0x04000000	/* Clear Power-up Reset bit */
#define VME2_TCTL_PURS		0x08000000	/* Power-up Reset bit */
#define VME2_TCTL_BDFLI		0x10000000	/* Board Fail Status*/
#define VME2_TCTL_SYSFAIL	0x20000000	/* light SYSFAIL led */
#define VME2_TCTL_SCON		0x40000000	/* we are SCON */
a266 1
#define VME2_IRQ_SW(x)		((1 << (x))) << 8)
a313 1
#define VME2_IOCTL1_MIEN       	(1 << 23)
a315 4
#define VME2_SET_VBR0(x)	((x) << VME2_VBR_0SHIFT)
#define VME2_SET_VBR1(x)	((x) << VME2_VBR_1SHIFT)
#define VME2_GET_VBR0(x)	((((x)->vme2_vbr >> 28) & 0xf) << 4)
#define VME2_GET_VBR1(x)	((((x)->vme2_vbr >> 24) & 0xf) << 4)
d339 5
a343 8
void * vmepmap __P((struct vmesoftc *sc, void * vmeaddr, int len, int bustype));
void * vmemap __P((struct vmesoftc *sc, void * vmeaddr, int len, int bustype));
int vmerw __P((struct vmesoftc *sc, struct uio *uio, int flags, int bus));
int vmeintr_establish __P((int vec, struct intrhand *ih));
int vme_findvec __P((void));
int vmescan __P((struct device *, void *, void *, int));

#endif __MVEME88K_DEV_VME_H__
@


1.3.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.h,v 1.3.4.1 2001/04/18 16:11:06 niklas Exp $ */
d383 1
a383 1
#endif /* __MVEME88K_DEV_VME_H__ */
@


1.3.4.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d376 2
a377 2
void * vmepmap __P((struct vmesoftc *sc, off_t vmeaddr, int len, int bustype));
void * vmemap __P((struct vmesoftc *sc, off_t vmeaddr, int len, int bustype));
@


1.3.4.4
log
@Merge in -current from about a week ago
@
text
@d376 6
a381 6
void * vmepmap(struct vmesoftc *sc, off_t vmeaddr, int len, int bustype);
void * vmemap(struct vmesoftc *sc, off_t vmeaddr, int len, int bustype);
int vmerw(struct vmesoftc *sc, struct uio *uio, int flags, int bus);
int vmeintr_establish(int vec, struct intrhand *ih);
int vme_findvec(void);
int vmescan(struct device *, void *, void *, int);
@


1.3.4.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.h,v 1.3.4.4 2002/03/28 10:36:02 niklas Exp $ */
d15 5
@


1.3.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d37 103
d350 1
a350 1
#define VME2_MISC_MPIRQEN	0x00000080	/* do not set */
d353 1
a353 1
#define VME2_MISC_DISMST	0x00000010
d371 3
a373 2
void *vmepmap(struct device *sc, off_t vmeaddr, int len, int bustype);
int vmerw(struct device *sc, struct uio *uio, int flags, int bus);
a376 4

/* D16 access functions */
void d16_bcopy(const void *, void *, size_t);
void d16_bzero(void *, size_t);
@


1.3.4.7
log
@Merge with the trunk
@
text
@d29 1
a29 1
#define	__MVEME88K_DEV_VME_H__
d32 3
a34 4
	struct device		sc_dev;
	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
	struct intrhand 	sc_abih;       /* `abort' switch */
d38 1
a38 1
 * XXX: this chip has some rather insane access rules!
d40 37
a76 67

#define	VME2_BASE		0xfff40000

#define	VME2_SADDR1		0x0000
#define	VME2_SADDR2		0x0004
#define	VME2_SLAVELMOD1		0x0008
#define	VME2_SLAVELMOD2		0x000c
#define	VME2_SLAVECTL		0x0010
#define	VME2_MASTER1		0x0014
#define	VME2_MASTER2		0x0018
#define	VME2_MASTER3		0x001c
#define	VME2_MASTER4		0x0020
#define	VME2_MASTER4MOD		0x0024
#define	VME2_MASTERCTL		0x0028
#define	VME2_GCSRCTL		0x002c
#define	VME2_DMACTL		0x0030
#define	VME2_DMAMODE		0x0034
#define	VME2_DMALADDR		0x0038
#define	VME2_DMAVMEADDR		0x003c
#define	VME2_DMACOUNT		0x0040
#define	VME2_DMATABLE		0x0044
#define	VME2_DMASTAT		0x0048
#define	VME2_TCR		0x004c
#define	VME2_T1CMP		0x0050
#define	VME2_T1COUNT		0x0054
#define	VME2_T2CMP		0x0058
#define	VME2_T2COUNT		0x005c
#define	VME2_TCTL		0x0060
#define	VME2_PRESCALE		0x0064
#define	VME2_IRQSTAT		0x0068
#define	VME2_IRQEN		0x006c
#define	VME2_SETSOFTIRQ		0x0070
#define	VME2_IRQCLR		0x0074
#define	VME2_IRQL1		0x0078
#define	VME2_IRQL2		0x007c
#define	VME2_IRQL3		0x0080
#define	VME2_IRQL4		0x0084
#define	VME2_VBR		0x0088
#define	VME2_MISC		0x008c

#define	VME2_SADDR_END		0xffff0000	/* VME address END & START */
#define	VME2_SADDR_START	0x0000ffff
#define	VME2_SADDR_LADDR	0xffff0000		/* local base address */
#define	VME2_SADDR_SIZE(mem)	(0x1000 - (mem) >> 16)	/* encoding of size */

#define	VME2_SLAVE_CHOOSE(bits, num) ((bits) << (16*((num)-1)))
#define	VME2_SLAVECTL_WP	0x00000100		/* write posting */
#define	VME2_SLAVECTL_SNP_NO	0x00000000		/* no snooping */
#define	VME2_SLAVECTL_SNP_SINK	0x00000200		/* sink data */
#define	VME2_SLAVECTL_SNP_INVAL	0x00000400		/* invalidate */
#define	VME2_SLAVECTL_ADDER	0x00000800		/* use adder */
#define	VME2_SLAVECTL_SUP	0x00000080		/* modifier bit */
#define	VME2_SLAVECTL_USR	0x00000040		/* modifier bit */
#define	VME2_SLAVECTL_A32	0x00000020		/* modifier bit */
#define	VME2_SLAVECTL_A24	0x00000010		/* modifier bit */
#define	VME2_SLAVECTL_D64	0x00000008		/* modifier bit */
#define	VME2_SLAVECTL_BLK	0x00000004		/* modifier bit */
#define	VME2_SLAVECTL_PGM	0x00000002		/* modifier bit */
#define	VME2_SLAVECTL_DAT	0x00000001		/* modifier bit */

#define	VME2_MASTERCTL_4SHIFT	24
#define	VME2_MASTERCTL_3SHIFT	16
#define	VME2_MASTERCTL_2SHIFT	8
#define	VME2_MASTERCTL_1SHIFT	0
#define	VME2_MASTERCTL_D16	0x80
#define	VME2_MASTERCTL_WP	0x40
#define	VME2_MASTERCTL_AM	0x3f
d92 164
a255 58
#define	VME2_MASTERCTL_ALL	0xff

#define	VME2_GCSRCTL_OFF	0xf0000000
#define	VME2_GCSRCTL_MDEN4	0x00080000
#define	VME2_GCSRCTL_MDEN3	0x00040000
#define	VME2_GCSRCTL_MDEN2	0x00020000
#define	VME2_GCSRCTL_MDEN1	0x00010000
#define	VME2_GCSRCTL_I2EN	0x00008000	/* F decode (A24D16/A32D16) on */
#define	VME2_GCSRCTL_I2WP	0x00004000	/* F decode write post */
#define	VME2_GCSRCTL_I2SU	0x00002000	/* F decode is supervisor */
#define	VME2_GCSRCTL_I2PD	0x00001000	/* F decode is program */
#define	VME2_GCSRCTL_I1EN	0x00000800	/* short decode (A16Dx) on */
#define	VME2_GCSRCTL_I1D16	0x00000400	/* short decode is D16 */
#define	VME2_GCSRCTL_I1WP	0x00000200	/* short decode write post */
#define	VME2_GCSRCTL_I1SU	0x00000100	/* short decode is supervisor */
#define	VME2_GCSRCTL_ROMSIZE	0x000000c0	/* size of ROM */
#define	VME2_GCSRCTL_ROMBSPD	0x00000038	/* speed of ROM */
#define	VME2_GCSRCTL_ROMASPD	0x00000007	/* speed of ROM */

#define	VME2_TCR_1MS		(1 << 8)       	/* Watchdog 1 ms */
#define	VME2_TCR_2MS		(2 << 8)       	/* Watchdog 2 ms */
#define	VME2_TCR_4MS		(3 << 8)       	/* Watchdog 4 ms */
#define	VME2_TCR_8MS		(4 << 8)       	/* Watchdog 8 ms */
#define	VME2_TCR_16MS		(5 << 8)       	/* Watchdog 16 ms */
#define	VME2_TCR_32MS		(6 << 8)       	/* Watchdog 32 ms */
#define	VME2_TCR_64MS		(7 << 8)       	/* Watchdog 64 ms */
#define	VME2_TCR_128MS		(8 << 8)       	/* Watchdog 128 ms */
#define	VME2_TCR_256MS		(9 << 8)       	/* Watchdog 256 ms */
#define	VME2_TCR_512MS		(10 << 8)	/* Watchdog 512 ms */
#define	VME2_TCR_1S		(11 << 8)	/* Watchdog 1 s */
#define	VME2_TCR_4S		(12 << 8)	/* Watchdog 4 s */
#define	VME2_TCR_16S		(13 << 8)	/* Watchdog 16 s */
#define	VME2_TCR_32S		(14 << 8)	/* Watchdog 32 s */
#define	VME2_TCR_64S		(15 << 8)	/* Watchdog 64 s */

#define	VME2_TCTL1_CEN		0x01
#define	VME2_TCTL1_COC		0x02
#define	VME2_TCTL1_COVF		0x04
#define	VME2_TCTL1_OVF		0xf0
#define	VME2_TCTL2_CEN		(0x01 << 8)
#define	VME2_TCTL2_COC		(0x02 << 8)
#define	VME2_TCTL2_COVF		(0x04 << 8)
#define	VME2_TCTL2_OVF		(0xf0 << 8)
#define	VME2_TCTL_WDEN		0x00010000	/* Watchdog Enable */
#define	VME2_TCTL_WDRSE		0x00020000	/* Watchdog Reset Enable */
#define	VME2_TCTL_WDSL		0x00040000	/* local or system reset */
#define	VME2_TCTL_WDBFE		0x00080000	/* Watchdog Board Fail Enable */
#define	VME2_TCTL_WDTO		0x00100000	/* Watchdog Timeout Status */
#define	VME2_TCTL_WDCC		0x00200000	/* Watchdog Clear Counter */
#define	VME2_TCTL_WDCS		0x00400000	/* Watchdog Clear Timeout */
#define	VME2_TCTL_SRST		0x00800000	/* system reset */
#define	VME2_TCTL_RSWE		0x01000000	/* Reset Switch Enable */
#define	VME2_TCTL_BDFLO		0x02000000	/* Assert Board Fail */
#define	VME2_TCTL_CPURS		0x04000000	/* Clear Power-up Reset bit */
#define	VME2_TCTL_PURS		0x08000000	/* Power-up Reset bit */
#define	VME2_TCTL_BDFLI		0x10000000	/* Board Fail Status*/
#define	VME2_TCTL_SYSFAIL	0x20000000	/* light SYSFAIL led */
#define	VME2_TCTL_SCON		0x40000000	/* we are SCON */
d257 10
a266 34
#define	VME2_IRQ_ACF		0x80000000
#define	VME2_IRQ_AB		0x40000000
#define	VME2_IRQ_SYSF		0x20000000
#define	VME2_IRQ_MWP		0x10000000
#define	VME2_IRQ_PE		0x08000000
#define	VME2_IRQ_V1IE		0x04000000
#define	VME2_IRQ_TIC2		0x02000000
#define	VME2_IRQ_TIC1		0x01000000
#define	VME2_IRQ_VIA		0x00800000
#define	VME2_IRQ_DMA		0x00400000
#define	VME2_IRQ_SIG3		0x00200000
#define	VME2_IRQ_SIG2		0x00100000
#define	VME2_IRQ_SIG1		0x00080000
#define	VME2_IRQ_SIG0		0x00040000
#define	VME2_IRQ_LM1		0x00020000
#define	VME2_IRQ_LM0		0x00010000
#define	VME2_IRQ_SW7		0x00008000
#define	VME2_IRQ_SW6		0x00004000
#define	VME2_IRQ_SW5		0x00002000
#define	VME2_IRQ_SW4		0x00001000
#define	VME2_IRQ_SW3		0x00000800
#define	VME2_IRQ_SW2		0x00000400
#define	VME2_IRQ_SW1		0x00000200
#define	VME2_IRQ_SW0		0x00000100
#define	VME2_IRQ_SW(x)		((1 << (x))) << 8)
#define	VME2_IRQ_SPARE		0x00000080
#define	VME2_IRQ_VME7		0x00000040
#define	VME2_IRQ_VME6		0x00000020
#define	VME2_IRQ_VME5		0x00000010
#define	VME2_IRQ_VME4		0x00000008
#define	VME2_IRQ_VME3		0x00000004
#define	VME2_IRQ_VME2		0x00000002
#define	VME2_IRQ_VME1		0x00000001
#define	VME2_IRQ_VME(x)		(1 << ((x) - 1))
d268 1
a268 67
#define	VME2_IRQL1_ACFSHIFT	28
#define	VME2_IRQL1_ABSHIFT	24
#define	VME2_IRQL1_SYSFSHIFT	20
#define	VME2_IRQL1_WPESHIFT	16
#define	VME2_IRQL1_PESHIFT	12
#define	VME2_IRQL1_V1IESHIFT	8
#define	VME2_IRQL1_TIC2SHIFT	4
#define	VME2_IRQL1_TIC1SHIFT	0

#define	VME2_IRQL2_VIASHIFT	28
#define	VME2_IRQL2_DMASHIFT	24
#define	VME2_IRQL2_SIG3SHIFT	20
#define	VME2_IRQL2_SIG2SHIFT	16
#define	VME2_IRQL2_SIG1SHIFT	12
#define	VME2_IRQL2_SIG0SHIFT	8
#define	VME2_IRQL2_LM1SHIFT	4
#define	VME2_IRQL2_LM0SHIFT	0

#define	VME2_IRQL3_SW7SHIFT	28
#define	VME2_IRQL3_SW6SHIFT	24
#define	VME2_IRQL3_SW5SHIFT	20
#define	VME2_IRQL3_SW4SHIFT	16
#define	VME2_IRQL3_SW3SHIFT	12
#define	VME2_IRQL3_SW2SHIFT	8
#define	VME2_IRQL3_SW1SHIFT	4
#define	VME2_IRQL3_SW0SHIFT	0

#define	VME2_IRQL4_SPARESHIFT	28
#define	VME2_IRQL4_VME7SHIFT	24
#define	VME2_IRQL4_VME6SHIFT	20
#define	VME2_IRQL4_VME5SHIFT	16
#define	VME2_IRQL4_VME4SHIFT	12
#define	VME2_IRQL4_VME3SHIFT	8
#define	VME2_IRQL4_VME2SHIFT	4
#define	VME2_IRQL4_VME1SHIFT	0

#define	VME2_SYSFAIL		(1 << 22)
#define	VME2_IOCTL1_MIEN	(1 << 23)
#define	VME2_VBR_0SHIFT		28
#define	VME2_VBR_1SHIFT		24
#define	VME2_SET_VBR0(x)	((x) << VME2_VBR_0SHIFT)
#define	VME2_SET_VBR1(x)	((x) << VME2_VBR_1SHIFT)
#define	VME2_GET_VBR0(x)	((((x) >> 28) & 0xf) << 4)
#define	VME2_GET_VBR1(x)	((((x) >> 24) & 0xf) << 4)
#define	VME2_VBR_GPOXXXX	0x00ffffff

#define	VME2_MISC_MPIRQEN	0x00000080	/* do not set */
#define	VME2_MISC_REVEROM	0x00000040	/* 167: dis eprom. 166: en flash */
#define	VME2_MISC_DISSRAM	0x00000020	/* do not set */
#define	VME2_MISC_DISMST	0x00000010
#define	VME2_MISC_NOELBBSY	0x00000008	/* do not set */
#define	VME2_MISC_DISBSYT	0x00000004	/* do not set */
#define	VME2_MISC_ENINT		0x00000002	/* do not set */
#define	VME2_MISC_DISBGN	0x00000001	/* do not set */

#define	VME2_A16D32BASE	0xffff0000UL
#define	VME2_A16D32LEN	0x00010000UL
#define	VME2_A32D16BASE	0xf1000000UL
#define	VME2_A32D16LEN	0x01000000UL
#define	VME2_A16D16BASE	0xffff0000UL
#define	VME2_A16D16LEN	0x00010000UL
#define	VME2_A24D16BASE	0xf0000000UL
#define	VME2_A24D16LEN	0x01000000UL
#define	VME2_A16BASE	0xffff0000UL
#define	VME2_A24BASE	0xff000000UL

void *vmepmap(struct device *sc, off_t vmeaddr, int bustype);
d271 1
a271 1
int vme_findvec(int);
d273 4
@


1.2
log
@Commit for the first real OpenBSD mvme88k port.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.h,v 1.9 1998/01/19 00:13:04 etheisen Exp $ */
d191 2
a192 2
#define	VME2_MASTERCTL_AM16S	0x2d	/* A16 Supervisory Access */
#define	VME2_MASTERCTL_AM16U	0x29	/* A16 Non-priv. Access */
d231 4
d313 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD$ */
d38 1
a38 2
	caddr_t		sc_vaddr;
#if 1
d40 10
a49 1
#endif
d233 1
d334 1
a334 1
caddr_t	vmepmap __P((struct vmesoftc *sc, caddr_t vmeaddr, int len,
d336 1
a336 1
caddr_t	vmemap __P((struct vmesoftc *sc, caddr_t vmeaddr, int len,
@


1.1.1.1
log
@Third try at importing the mvme88k port. This is a working kernel
from nivas.
Userland and compiler still need to be worked on.
Make certain what directory the import is done from.
@
text
@@
