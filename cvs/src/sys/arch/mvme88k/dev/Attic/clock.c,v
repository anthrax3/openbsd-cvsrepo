head	1.46;
access;
symbols
	OPENBSD_3_9:1.44.0.6
	OPENBSD_3_9_BASE:1.44
	OPENBSD_3_8:1.44.0.4
	OPENBSD_3_8_BASE:1.44
	OPENBSD_3_7:1.44.0.2
	OPENBSD_3_7_BASE:1.44
	OPENBSD_3_6:1.42.0.2
	OPENBSD_3_6_BASE:1.42
	SMP_SYNC_A:1.30
	SMP_SYNC_B:1.30
	OPENBSD_3_5:1.29.0.2
	OPENBSD_3_5_BASE:1.29
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	UBC_SYNC_A:1.19
	OPENBSD_3_3:1.19.0.6
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.19.0.4
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	UBC_SYNC_B:1.19
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.10.0.4
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.6.0.8
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.6
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.4
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	mvme88kport:1.1.1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	first_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.46
date	2006.04.19.22.09.40;	author miod;	state dead;
branches;
next	1.45;

1.45
date	2006.04.15.22.31.46;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2004.12.24.22.50.30;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2004.11.08.16.39.31;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2004.08.25.21.47.54;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2004.08.25.20.18.46;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2004.08.25.08.01.40;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2004.08.25.08.00.06;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2004.08.24.22.01.29;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2004.08.24.07.42.04;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2004.08.02.14.36.07;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2004.08.02.08.35.00;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2004.07.30.22.09.59;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2004.07.30.19.02.05;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2004.07.23.21.00.09;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2004.07.02.14.00.42;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2004.04.24.19.51.47;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2004.01.14.20.50.48;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2003.12.22.11.54.48;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2003.12.12.21.51.29;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2003.10.11.22.06.50;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2003.10.08.22.36.11;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2003.10.08.19.10.04;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2003.09.28.22.10.20;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2003.09.28.18.03.41;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.02.23.27.51;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.02.07.06.56;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.14.01.26.39;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.01.14.21.34.38;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.22.09.49.39;	author smurph;	state Exp;
branches;
next	1.16;

1.16
date	2001.12.20.06.07.28;	author smurph;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.19.07.04.41;	author smurph;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.12.16.23.49.46;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.14.02.11.43;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.13.08.55.51;	author smurph;	state Exp;
branches;
next	1.11;

1.11
date	2001.10.28.00.57.20;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.09.05.44.38;	author smurph;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.07.23.45.50;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.12.08.16.22;	author smurph;	state Exp;
branches;
next	1.7;

1.7
date	2001.02.01.03.38.14;	author smurph;	state Exp;
branches;
next	1.6;

1.6
date	99.09.27.18.43.23;	author smurph;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	99.05.29.04.41.43;	author smurph;	state Exp;
branches;
next	1.4;

1.4
date	98.12.15.05.52.29;	author smurph;	state Exp;
branches;
next	1.3;

1.3
date	97.03.03.20.20.39;	author rahnds;	state Exp;
branches;
next	1.2;

1.2
date	97.03.03.19.07.10;	author rahnds;	state dead;
branches;
next	1.1;

1.1
date	95.10.18.10.54.28;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.10.54.28;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.03.03.19.32.01;	author rahnds;	state Exp;
branches;
next	;

1.6.4.1
date	2001.04.18.16.10.54;	author niklas;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2001.11.13.21.04.14;	author niklas;	state Exp;
branches;
next	1.6.4.3;

1.6.4.3
date	2002.03.06.02.04.44;	author niklas;	state Exp;
branches;
next	1.6.4.4;

1.6.4.4
date	2002.03.28.10.36.02;	author niklas;	state Exp;
branches;
next	1.6.4.5;

1.6.4.5
date	2003.06.07.11.13.16;	author ho;	state Exp;
branches;
next	1.6.4.6;

1.6.4.6
date	2004.02.19.10.49.06;	author niklas;	state Exp;
branches;
next	1.6.4.7;

1.6.4.7
date	2004.06.05.23.09.49;	author niklas;	state Exp;
branches;
next	;

1.15.2.1
date	2002.01.31.22.55.17;	author niklas;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2002.06.11.03.37.09;	author art;	state Exp;
branches;
next	;


desc
@@


1.46
log
@Get rid of the clock device attachment - since the clock is not something
we can live without, move it into the board-dependent code. This even makes
the code slightly smaller.

clock.c is moved from dev/ to mvme88k/ and only keeps common variables and
delay().
@
text
@/*	$OpenBSD: clock.c,v 1.45 2006/04/15 22:31:46 miod Exp $ */
/*
 * Copyright (c) 1999 Steve Murphree, Jr.
 * Copyright (c) 1995 Theo de Raadt
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1995 Nivas Madhur
 * Copyright (c) 1994 Gordon W. Ross
 * Copyright (c) 1993 Adam Glass
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)clock.c	8.1 (Berkeley) 6/11/93
 */

/*
 * Interval and statistic clocks driver.
 */

#include <sys/param.h>
#include <sys/simplelock.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/systm.h>

#include <machine/asm.h>
#include <machine/psl.h>
#include <machine/autoconf.h>
#include <machine/bugio.h>
#include <machine/cpu.h>

#include "pcctwo.h"
#if NPCCTWO > 0
#include <machine/mvme1x7.h>
#include <mvme88k/dev/pcctwovar.h>
#include <mvme88k/dev/pcctworeg.h>
#endif

#include "syscon.h"
#if NSYSCON > 0
#include <machine/mvme188.h>
#include <mvme88k/dev/sysconreg.h>
#endif

#include <mvme88k/dev/vme.h>

#include "bugtty.h"
#if NBUGTTY > 0
#include <mvme88k/dev/bugttyfunc.h>
#endif

int	clockmatch(struct device *, void *, void *);
void	clockattach(struct device *, struct device *, void *);

void	sbc_init_clocks(void);
void	m188_init_clocks(void);
void	m188_cio_init(unsigned);
u_int	read_cio(int);
void	write_cio(int, u_int);

struct clocksoftc {
	struct device	sc_dev;
	struct intrhand	sc_profih;
	struct intrhand	sc_statih;
};

struct cfattach clock_ca = {
        sizeof(struct clocksoftc), clockmatch, clockattach
};

struct cfdriver clock_cd = {
        NULL, "clock", DV_DULL
};

int	sbc_clockintr(void *);
int	sbc_statintr(void *);
int	m188_clockintr(void *);
int	m188_statintr(void *);

#if NPCCTWO > 0
u_int8_t prof_reset;
u_int8_t stat_reset;
#endif

#if NSYSCON > 0
struct simplelock cio_lock;

#define	CIO_LOCK	simple_lock(&cio_lock)
#define	CIO_UNLOCK	simple_unlock(&cio_lock)
#endif

/*
 * Statistics clock interval and variance, in usec.  Variance must be a
 * power of two.  Since this gives us an even number, not an odd number,
 * we discard one case and compensate.  That is, a variance of 4096 would
 * give us offsets in [0..4095].  Instead, we take offsets in [1..4095].
 * This is symmetric about the point 2048, or statvar/2, and thus averages
 * to that value (assuming uniform random numbers).
 */
int statvar = 8192;
int statmin;			/* statclock interval - 1/2*variance */

/*
 * Every machine must have a clock tick device of some sort; for this
 * platform this file manages it, no matter what form it takes.
 */
int
clockmatch(struct device *parent, void *vcf, void *args)
{
	struct confargs *ca = args;
	struct cfdata *cf = vcf;

	if (strcmp(cf->cf_driver->cd_name, "clock")) {
		return (0);
	}

	/*
	 * clock has to be at ipl 5
	 * We return the ipl here so that the parent can print
	 * a message if it is different from what ioconf.c says.
	 */
	ca->ca_ipl = IPL_CLOCK;
	return (1);
}

void
clockattach(struct device *parent, struct device *self, void *args)
{
	struct confargs *ca = args;
	struct clocksoftc *sc = (struct clocksoftc *)self;

	switch (ca->ca_bustype) {
#if NPCCTWO > 0
	case BUS_PCCTWO:
		sc->sc_profih.ih_fn = sbc_clockintr;
		sc->sc_profih.ih_arg = 0;
		sc->sc_profih.ih_wantframe = 1;
		sc->sc_profih.ih_ipl = ca->ca_ipl;
		prof_reset = ca->ca_ipl | PCC2_IRQ_IEN | PCC2_IRQ_ICLR;
		pcctwointr_establish(PCC2V_TIMER1, &sc->sc_profih, "clock");
		sc->sc_statih.ih_fn = sbc_statintr;
		sc->sc_statih.ih_arg = 0;
		sc->sc_statih.ih_wantframe = 1;
		sc->sc_statih.ih_ipl = ca->ca_ipl;
		stat_reset = ca->ca_ipl | PCC2_IRQ_IEN | PCC2_IRQ_ICLR;
		pcctwointr_establish(PCC2V_TIMER2, &sc->sc_statih, "stat");
		md_init_clocks = sbc_init_clocks;
		break;
#endif /* NPCCTWO */
#if NSYSCON > 0
	case BUS_SYSCON:
		sc->sc_profih.ih_fn = m188_clockintr;
		sc->sc_profih.ih_arg = 0;
		sc->sc_profih.ih_wantframe = 1;
		sc->sc_profih.ih_ipl = ca->ca_ipl;
		sysconintr_establish(SYSCV_TIMER2, &sc->sc_profih, "clock");
		sc->sc_statih.ih_fn = m188_statintr;
		sc->sc_statih.ih_arg = 0;
		sc->sc_statih.ih_wantframe = 1;
		sc->sc_statih.ih_ipl = ca->ca_ipl;
		sysconintr_establish(SYSCV_TIMER1, &sc->sc_statih, "stat");
		md_init_clocks = m188_init_clocks;
		break;
#endif /* NSYSCON */
	}

	printf("\n");
}

#if NPCCTWO > 0

void
sbc_init_clocks(void)
{
	int statint, minint;

#ifdef DIAGNOSTIC
	if (1000000 % hz) {
		printf("cannot get %d Hz clock; using 100 Hz\n", hz);
		hz = 100;
	}
#endif
	tick = 1000000 / hz;

	/* profclock */
	*(volatile u_int8_t *)(OBIO_START + PCC2_BASE + PCCTWO_T1CTL) = 0;
	*(volatile u_int32_t *)(OBIO_START + PCC2_BASE + PCCTWO_T1CMP) =
	    pcc2_timer_us2lim(tick);
	*(volatile u_int32_t *)(OBIO_START + PCC2_BASE + PCCTWO_T1COUNT) = 0;
	*(volatile u_int8_t *)(OBIO_START + PCC2_BASE + PCCTWO_T1CTL) =
	    PCC2_TCTL_CEN | PCC2_TCTL_COC | PCC2_TCTL_COVF;
	*(volatile u_int8_t *)(OBIO_START + PCC2_BASE + PCCTWO_T1ICR) =
	    prof_reset;

	if (stathz == 0)
		stathz = hz;
#ifdef DIAGNOSTIC
	if (1000000 % stathz) {
		printf("cannot get %d Hz statclock; using 100 Hz\n", stathz);
		stathz = 100;
	}
#endif
	profhz = stathz;		/* always */

	statint = 1000000 / stathz;
	minint = statint / 2 + 100;
	while (statvar > minint)
		statvar >>= 1;

	/* statclock */
	*(volatile u_int8_t *)(OBIO_START + PCC2_BASE + PCCTWO_T2CTL) = 0;
	*(volatile u_int32_t *)(OBIO_START + PCC2_BASE + PCCTWO_T2CMP) =
	    pcc2_timer_us2lim(statint);
	*(volatile u_int32_t *)(OBIO_START + PCC2_BASE + PCCTWO_T2COUNT) = 0;
	*(volatile u_int8_t *)(OBIO_START + PCC2_BASE + PCCTWO_T2CTL) =
	    PCC2_TCTL_CEN | PCC2_TCTL_COC | PCC2_TCTL_COVF;
	*(volatile u_int8_t *)(OBIO_START + PCC2_BASE + PCCTWO_T2ICR) =
	    stat_reset;

	statmin = statint - (statvar >> 1);
}

/*
 * clockintr: ack intr and call hardclock
 */
int
sbc_clockintr(void *eframe)
{
	*(volatile u_int8_t *)(OBIO_START + PCC2_BASE + PCCTWO_T1ICR) =
	    prof_reset;

	hardclock(eframe);
#if NBUGTTY > 0
	bugtty_chkinput();
#endif /* NBUGTTY */

	return (1);
}

int
sbc_statintr(void *eframe)
{
	u_long newint, r, var;

	*(volatile u_int8_t *)(OBIO_START + PCC2_BASE + PCCTWO_T2ICR) =
	    stat_reset;

	statclock((struct clockframe *)eframe);

	/*
	 * Compute new randomized interval.  The intervals are uniformly
	 * distributed on [statint - statvar / 2, statint + statvar / 2],
	 * and therefore have mean statint, giving a stathz frequency clock.
	 */
	var = statvar;
	do {
		r = random() & (var - 1);
	} while (r == 0);
	newint = statmin + r;

	*(volatile u_int8_t *)(OBIO_START + PCC2_BASE + PCCTWO_T2CTL) = 0;
	*(volatile u_int32_t *)(OBIO_START + PCC2_BASE + PCCTWO_T2CMP) =
	    pcc2_timer_us2lim(newint);
	*(volatile u_int32_t *)(OBIO_START + PCC2_BASE + PCCTWO_T2COUNT) = 0;
	*(volatile u_int8_t *)(OBIO_START + PCC2_BASE + PCCTWO_T2ICR) =
	    stat_reset;
	*(volatile u_int8_t *)(OBIO_START + PCC2_BASE + PCCTWO_T2CTL) =
	    PCC2_TCTL_CEN | PCC2_TCTL_COC;
	return (1);
}

#endif /* NPCCTWO */

#if NSYSCON > 0

/*
 * Notes on the MVME188 clock usage:
 *
 * We have two sources for timers:
 * - two counter/timers in the DUART (MC68681/MC68692)
 * - three counter/timers in the Zilog Z8536
 *
 * However:
 * - Z8536 CT#3 is reserved as a watchdog device; and its input is
 *   user-controllable with jumpers on the SYSCON board, so we can't
 *   really use it.
 * - When using the Z8536 in timer mode, it _seems_ like it resets at
 *   0xffff instead of the initial count value...
 * - Despite having per-counter programmable interrupt vectors, the
 *   SYSCON logic forces fixed vectors for the DUART and the Z8536 timer
 *   interrupts.
 * - The DUART timers keep counting down from 0xffff even after
 *   interrupting, and need to be manually stopped, then restarted, to
 *   resume counting down the initial count value.
 *
 * Also, while the Z8536 has a very reliable 4MHz clock source, the
 * 3.6864MHz clock source of the DUART timers does not seem to be correct.
 *
 * As a result, clock is run on a Z8536 counter, kept in counter mode and
 * retriggered every interrupt, while statclock is run on a DUART counter,
 * but in practice runs at an average 96Hz instead of the expected 100Hz.
 *
 * It should be possible to run statclock on the Z8536 counter #2, but
 * this would make interrupt handling more tricky, in the case both
 * counters interrupt at the same time...
 */

#define	DART_ISR		0xfff82017	/* interrupt status */
#define	DART_IVR		0xfff82033	/* interrupt vector */
#define	DART_STARTC		0xfff8203b	/* start counter cmd */
#define	DART_STOPC		0xfff8203f	/* stop counter cmd */
#define	DART_ACR		0xfff82013	/* auxiliary control */
#define	DART_CTUR		0xfff8201b	/* counter/timer MSB */
#define	DART_CTLR		0xfff8201f	/* counter/timer LSB */
#define	DART_OPCR		0xfff82037	/* output port config*/

void
m188_init_clocks(void)
{
	volatile u_int8_t imr;
	int statint, minint;

#ifdef DIAGNOSTIC
	if (1000000 % hz) {
		printf("cannot get %d Hz clock; using 100 Hz\n", hz);
		hz = 100;
	}
#endif
	tick = 1000000 / hz;

	simple_lock_init(&cio_lock);
	m188_cio_init(tick);

	if (stathz == 0)
		stathz = hz;
#ifdef DIAGNOSTIC
	if (1000000 % stathz) {
		printf("cannot get %d Hz statclock; using 100 Hz\n", stathz);
		stathz = 100;
	}
#endif
	profhz = stathz;		/* always */

	/*
	 * The DUART runs at 3.6864 MHz, CT#1 will run in PCLK/16 mode.
	 */
	statint = (3686400 / 16) / stathz;
	minint = statint / 2 + 100;
	while (statvar > minint)
		statvar >>= 1;
	statmin = statint - (statvar >> 1);

	/* clear the counter/timer output OP3 while we program the DART */
	*(volatile u_int8_t *)DART_OPCR = 0x00;
	/* set interrupt vec */
	*(volatile u_int8_t *)DART_IVR = SYSCON_VECT + SYSCV_TIMER1;
	/* do the stop counter/timer command */
	imr = *(volatile u_int8_t *)DART_STOPC;
	/* set counter/timer to counter mode, PCLK/16 */
	*(volatile u_int8_t *)DART_ACR = 0x30;
	*(volatile u_int8_t *)DART_CTUR = (statint >> 8);
	*(volatile u_int8_t *)DART_CTLR = (statint & 0xff);
	/* set the counter/timer output OP3 */
	*(volatile u_int8_t *)DART_OPCR = 0x04;
	/* give the start counter/timer command */
	imr = *(volatile u_int8_t *)DART_STARTC;
}

int
m188_clockintr(void *eframe)
{
	CIO_LOCK;
	write_cio(CIO_CSR1, CIO_GCB | CIO_CIP);  /* Ack the interrupt */

	hardclock(eframe);
#if NBUGTTY > 0
	bugtty_chkinput();
#endif /* NBUGTTY */

	/* restart counter */
	write_cio(CIO_CSR1, CIO_GCB | CIO_TCB | CIO_IE);
	CIO_UNLOCK;

	return (1);
}

int
m188_statintr(void *eframe)
{
	volatile u_int8_t tmp;
	u_long newint, r, var;

	/* stop counter and acknowledge interrupt */
	tmp = *(volatile u_int8_t *)DART_STOPC;
	tmp = *(volatile u_int8_t *)DART_ISR;

	statclock((struct clockframe *)eframe);

	/*
	 * Compute new randomized interval.  The intervals are uniformly
	 * distributed on [statint - statvar / 2, statint + statvar / 2],
	 * and therefore have mean statint, giving a stathz frequency clock.
	 */
	var = statvar;
	do {
		r = random() & (var - 1);
	} while (r == 0);
	newint = statmin + r;

	/* setup new value and restart counter */
	*(volatile u_int8_t *)DART_CTUR = (newint >> 8);
	*(volatile u_int8_t *)DART_CTLR = (newint & 0xff);
	tmp = *(volatile u_int8_t *)DART_STARTC;

	return (1);
}

/* Write CIO register */
void
write_cio(int reg, u_int val)
{
	int s;
	volatile int i;
	volatile u_int32_t * cio_ctrl = (volatile u_int32_t *)CIO_CTRL;

	s = splclock();
	CIO_LOCK;

	i = *cio_ctrl;				/* goto state 1 */
	*cio_ctrl = 0;				/* take CIO out of RESET */
	i = *cio_ctrl;				/* reset CIO state machine */

	*cio_ctrl = (reg & 0xff);		/* select register */
	*cio_ctrl = (val & 0xff);		/* write the value */

	CIO_UNLOCK;
	splx(s);
}

/* Read CIO register */
u_int
read_cio(int reg)
{
	int c, s;
	volatile int i;
	volatile u_int32_t * cio_ctrl = (volatile u_int32_t *)CIO_CTRL;

	s = splclock();
	CIO_LOCK;

	/* select register */
	*cio_ctrl = (reg & 0xff);
	/* delay for a short time to allow 8536 to settle */
	for (i = 0; i < 100; i++)
		;
	/* read the value */
	c = *cio_ctrl;
	CIO_UNLOCK;
	splx(s);
	return (c & 0xff);
}

/*
 * Initialize the CTC (8536)
 * Only the counter/timers are used - the IO ports are un-comitted.
 */
void
m188_cio_init(unsigned period)
{
	volatile int i;

	CIO_LOCK;

	/* Start by forcing chip into known state */
	read_cio(CIO_MICR);
	write_cio(CIO_MICR, CIO_MICR_RESET);	/* Reset the CTC */
	for (i = 0; i < 1000; i++)	 	/* Loop to delay */
		;

	/* Clear reset and start init seq. */
	write_cio(CIO_MICR, 0x00);

	/* Wait for chip to come ready */
	while ((read_cio(CIO_MICR) & CIO_MICR_RJA) == 0)
		;

	/* Initialize the 8536 for real */
	write_cio(CIO_MICR,
	    CIO_MICR_MIE /* | CIO_MICR_NV */ | CIO_MICR_RJA | CIO_MICR_DLC);
	write_cio(CIO_CTMS1, CIO_CTMS_CSC);	/* Continuous count */
	write_cio(CIO_PDCB, 0xff);		/* set port B to input */

	period <<= 1;	/* CT#1 runs at PCLK/2, hence 2MHz */
	write_cio(CIO_CT1MSB, period >> 8);
	write_cio(CIO_CT1LSB, period);
	/* enable counter #1 */
	write_cio(CIO_MCCR, CIO_MCCR_CT1E | CIO_MCCR_PBE);
	write_cio(CIO_CSR1, CIO_GCB | CIO_TCB | CIO_IE);

	CIO_UNLOCK;
}
#endif /* NSYSCON */

void
delay(int us)
{
	if (brdtyp == BRD_188) {
		extern void m188_delay(int);

		m188_delay(us);
	} else {
		/*
		 * On MVME187 and MVME197, use the VMEchip for the
		 * delay clock.
		 */
		*(volatile u_int32_t *)(VME2_BASE + VME2_T1CMP) = 0xffffffff;
		*(volatile u_int32_t *)(VME2_BASE + VME2_T1COUNT) = 0;
		*(volatile u_int32_t *)(VME2_BASE + VME2_TCTL) |=
		    VME2_TCTL1_CEN;

		while ((*(volatile u_int32_t *)(VME2_BASE + VME2_T1COUNT)) <
		    (u_int32_t)us)
			;
		*(volatile u_int32_t *)(VME2_BASE + VME2_TCTL) &=
		    ~VME2_TCTL1_CEN;
	}
}
@


1.45
log
@Remove DART defines from <machine/mvme188.h> (except for its base address),
and compensate in clock.c which still needs to access a few of its
registers.

While there, access DART registers as bytes as advised in the manual, not
as ints.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.44 2004/12/24 22:50:30 miod Exp $ */
@


1.44
log
@{e,}intr{cnt,names} bye-bye.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.43 2004/11/08 16:39:31 miod Exp $ */
d361 9
d373 1
a373 1
	volatile u_int32_t imr;
d407 1
a407 1
	*(volatile u_int32_t *)DART_OPCR = 0x00;
d409 1
a409 1
	*(volatile u_int32_t *)DART_IVR = SYSCON_VECT + SYSCV_TIMER1;
d411 1
a411 1
	imr = *(volatile u_int32_t *)DART_STOPC;
d413 3
a415 3
	*(volatile u_int32_t *)DART_ACR = 0x30;
	*(volatile u_int32_t *)DART_CTUR = (statint >> 8);
	*(volatile u_int32_t *)DART_CTLR = (statint & 0xff);
d417 1
a417 1
	*(volatile u_int32_t *)DART_OPCR = 0x04;
d419 1
a419 1
	imr = *(volatile u_int32_t *)DART_STARTC;
d443 1
a443 1
	volatile u_int32_t tmp;
d447 2
a448 2
	tmp = *(volatile u_int32_t *)DART_STOPC;
	tmp = *(volatile u_int32_t *)DART_ISR;
d464 3
a466 3
	*(volatile u_int32_t *)DART_CTUR = (newint >> 8);
	*(volatile u_int32_t *)DART_CTLR = (newint & 0xff);
	tmp = *(volatile u_int32_t *)DART_STARTC;
@


1.43
log
@Kill struct md_p, which was really only necessary for mvme88k; on
luna88k it disappears completely, while mvme88k keeps 3 global variables,
one of them scheduled to disappear very soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.42 2004/08/25 21:47:54 miod Exp $ */
a284 2
	intrcnt[M88K_CLK_IRQ]++;

a300 2
	intrcnt[M88K_SCLK_IRQ]++;

a418 1
	intrcnt[M88K_CLK_IRQ]++;
a440 1
	intrcnt[M88K_SCLK_IRQ]++;
@


1.42
log
@Swap the sources for clock and statclock on MVME188 (the Z8536 being more
reliable), and add a large block of comments to explain the timer
mess^Wsituation on MVME188.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.40 2004/08/25 08:01:40 miod Exp $ */
d108 2
a109 4
void	sbc_initclock(void);
void	sbc_initstatclock(void);
void	m188_initclock(void);
void	m188_initstatclock(void);
a193 1
		md.clock_init_func = sbc_initclock;
d200 1
a200 1
		md.statclock_init_func = sbc_initstatclock;
a209 1
		md.clock_init_func = m188_initclock;
d215 1
a215 1
		md.statclock_init_func = m188_initstatclock;
d226 1
a226 1
sbc_initclock(void)
d228 3
a230 3
#ifdef CLOCK_DEBUG
	printf("SBC clock init\n");
#endif
d235 1
a246 20
}

/*
 * clockintr: ack intr and call hardclock
 */
int
sbc_clockintr(void *eframe)
{
	*(volatile u_int8_t *)(OBIO_START + PCC2_BASE + PCCTWO_T1ICR) =
	    prof_reset;

	intrcnt[M88K_CLK_IRQ]++;

	hardclock(eframe);
#if NBUGTTY > 0
	bugtty_chkinput();
#endif /* NBUGTTY */

	return (1);
}
a247 8
void
sbc_initstatclock(void)
{
	int statint, minint;

#ifdef CLOCK_DEBUG
	printf("SBC statclock init\n");
#endif
d250 1
d255 1
d276 19
d365 52
a435 18
void
m188_initclock(void)
{
#ifdef CLOCK_DEBUG
	printf("VME188 clock init\n");
#endif
#ifdef DIAGNOSTIC
	if (1000000 % hz) {
		printf("cannot get %d Hz clock; using 100 Hz\n", hz);
		hz = 100;
	}
#endif
	tick = 1000000 / hz;

	simple_lock_init(&cio_lock);
	m188_cio_init(tick);
}

a465 44
}

void
m188_initstatclock(void)
{
	volatile u_int32_t imr;
	int statint, minint;

#ifdef CLOCK_DEBUG
	printf("VME188 statclock init\n");
#endif
	if (stathz == 0)
		stathz = hz;
#ifdef DIAGNOSTIC
	if (1000000 % stathz) {
		printf("cannot get %d Hz statclock; using 100 Hz\n", stathz);
		stathz = 100;
	}
#endif
	profhz = stathz;		/* always */

	/*
	 * The DUART runs at 3.6864 MHz, CT#1 will run in PCLK/16 mode.
	 */
	statint = (3686400 / 16) / stathz;
	minint = statint / 2 + 100;
	while (statvar > minint)
		statvar >>= 1;
	statmin = statint - (statvar >> 1);

	/* clear the counter/timer output OP3 while we program the DART */
	*(volatile u_int32_t *)DART_OPCR = 0x00;
	/* set interrupt vec */
	*(volatile u_int32_t *)DART_IVR = SYSCON_VECT + SYSCV_TIMER1;
	/* do the stop counter/timer command */
	imr = *(volatile u_int32_t *)DART_STOPC;
	/* set counter/timer to counter mode, PCLK/16 */
	*(volatile u_int32_t *)DART_ACR = 0x30;
	*(volatile u_int32_t *)DART_CTUR = (statint >> 8);
	*(volatile u_int32_t *)DART_CTLR = (statint & 0xff);
	/* set the counter/timer output OP3 */
	*(volatile u_int32_t *)DART_OPCR = 0x04;
	/* give the start counter/timer command */
	imr = *(volatile u_int32_t *)DART_STARTC;
@


1.41
log
@Rearm the DUART counter as soon as we enter the interrupt handler, to not
drift the clock of the hardclock() processing time.
@
text
@d212 1
a212 1
		sysconintr_establish(SYSCV_TIMER1, &sc->sc_profih, "clock");
d218 1
a218 1
		sysconintr_establish(SYSCV_TIMER2, &sc->sc_statih, "stat");
d342 33
d378 2
a379 6
	volatile u_int32_t tmp;

	tmp = *(volatile u_int32_t *)DART_STOPC;
	/* acknowledge the timer interrupt */
	tmp = *(volatile u_int32_t *)DART_ISR;
	tmp = *(volatile u_int32_t *)DART_STARTC;
a381 1

d387 4
a396 3
	volatile int imr;
	int counter;

d400 1
d405 1
d408 2
a409 23
	/*
	 * The DUART runs at 3.6864 MHz in PCLK/16 mode, hence for a
	 * 100 Hz timer, it needs (3686400 / 16) / 100 ticks per cycle.
	 */
	counter = (3686400 / 16) / hz;

#ifdef CLOCK_DEBUG
	printf("tick == %d, counter == %d\n", tick, counter);
#endif
	/* clear the counter/timer output OP3 while we program the DART */
	*(volatile u_int32_t *)DART_OPCR = 0x00;
	/* set interrupt vec */
	*(volatile u_int32_t *)DART_IVR = SYSCON_VECT + SYSCV_TIMER1;
	/* do the stop counter/timer command */
	imr = *(volatile u_int32_t *)DART_STOPC;
	/* set counter/timer to counter mode, clock/16 */
	*(volatile u_int32_t *)DART_ACR = 0x30;
	*(volatile u_int32_t *)DART_CTUR = (counter >> 8);
	*(volatile u_int32_t *)DART_CTLR = (counter & 0xff);
	/* set the counter/timer output OP3 */
	*(volatile u_int32_t *)DART_OPCR = 0x04;
	/* give the start counter/timer command */
	imr = *(volatile u_int32_t *)DART_STARTC;
d415 1
d418 3
a420 1
	CIO_LOCK;
a422 1

a423 1
	write_cio(CIO_CSR1, CIO_GCB | CIO_CIP);  /* Ack the interrupt */
d436 4
a439 4
	/* Load time constant CTC #1 */
	newint <<= 1;	/* CT1 runs at PCLK/2, hence 2MHz */
	write_cio(CIO_CT1MSB, newint >> 8);
	write_cio(CIO_CT1LSB, newint);
a440 4
	/* Start CTC #1 running */
	write_cio(CIO_CSR1, CIO_GCB | CIO_TCB | CIO_IE);

	CIO_UNLOCK;
d447 1
a452 1
	simple_lock_init(&cio_lock);
d455 1
d460 1
d463 4
a466 1
	statint = 1000000 / stathz;
a469 1
	m188_cio_init(statint);
d471 15
d503 2
a504 2
	*cio_ctrl = (reg & 0xff);		/* Select register */
	*cio_ctrl = (val & 0xff);		/* Write the value */
d521 1
a521 1
	/* Select register */
d523 1
a523 1
	/* Delay for a short time to allow 8536 to settle */
a535 1
 * Channels 1 and 2 are linked to provide a /32 counter.
a536 1

a543 2
	/* Initialize 8536 CTC */

d557 1
a557 1
	/* Initialize the 8536 */
d563 1
a563 2
	/* Load time constant CTC #1 */
	period <<= 1;	/* CT1 runs at PCLK/2, hence 2MHz */
d566 1
a566 2

	/* enable counter 1 */
a567 2

	/* Start CTC #1 running */
@


1.40
log
@Better DUART timer interval computation for clock.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.39 2004/08/25 08:00:06 miod Exp $ */
d345 1
a345 1
	volatile int tmp;
d347 1
d349 2
a350 4
	tmp = *(int *volatile)DART_ISR;

	/* stop the timer while the interrupt is being serviced */
	tmp = *(int *volatile)DART_STOPC;
a358 8
	tmp = *(int *volatile)DART_STARTC;

#ifdef CLOCK_DEBUG
	if (*(int *volatile)MVME188_IST & DTI_BIT) {
		printf("DTI not clearing!\n");
	}
#endif

d387 3
a389 2
	*((int *volatile)DART_OPCR) = 0x00;

d391 1
a391 2
	imr = *((int *volatile)DART_STOPC);

d393 5
a397 7
	*((int *volatile)DART_ACR) = 0x30;

	*((int *volatile)DART_CTUR) = (counter >> 8);
	*((int *volatile)DART_CTLR) = (counter & 0xff);
	/* set interrupt vec */
	*((int *volatile)DART_IVR) = SYSCON_VECT + SYSCV_TIMER1;

d399 1
a399 5
	/* (yes, this is supposed to be a read) */
	imr = *((int *volatile)DART_STARTC);

	/* set the counter/timer output OP3 */
	*((int *volatile)DART_OPCR) = 0x04;
d427 2
a428 2
	write_cio(CIO_CT1MSB, (newint & 0xff00) >> 8);
	write_cio(CIO_CT1LSB, newint & 0xff);
d468 1
a468 1
	int *volatile cio_ctrl = (int *volatile)CIO_CTRL;
d490 1
a490 1
	int *volatile cio_ctrl = (int *volatile)CIO_CTRL;
d543 2
a544 2
	write_cio(CIO_CT1MSB, (period & 0xff00) >> 8);
	write_cio(CIO_CT1LSB, period & 0xff);
@


1.39
log
@Use a simpler delay() routine for MVME188, from Mach via Luna88k
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.38 2004/08/24 22:01:29 miod Exp $ */
a111 1
void	m188_timer_init(unsigned);
d374 3
a384 2
	m188_timer_init(tick);
}
d386 5
a390 5
void
m188_timer_init(unsigned period)
{
	volatile int imr;
	int counter;
a391 7
	/* make sure the counter range is proper. */
	if (period < 9)
		counter = 2;
	else if (period > 284421)
		counter = 65535;
	else
		counter	= period / 4.34;
d393 1
a393 2
	printf("tick == %d, period == %d\n", tick, period);
	printf("timer will interrupt every %d usec\n", (int) (counter * 4.34));
d404 2
a405 2
	*((int *volatile)DART_CTUR) = counter / 256;	/* set counter MSB */
	*((int *volatile)DART_CTLR) = counter % 256;	/* set counter LSB */
@


1.38
log
@The#@@$#%^&}1 z8536 timers runs at PCLK/2, hence 2MHz. Compensate, since
the code assumes 1MHz timers.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.37 2004/08/24 07:42:04 miod Exp $ */
d583 1
a583 1
		extern int cpuspeed;
d585 1
a585 7
		/*
		 * Unable to use a real timer, use a tight loop.
		 * XXX not accurate!
		 */
		volatile int c = (3 * us) / (cpuspeed == 25 ? 4 : 5);
		while (--c > 0)
			;
@


1.37
log
@Correctly initialize and shuffle statclock on 1x7.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.36 2004/08/02 14:36:07 miod Exp $ */
a83 1
#include <machine/cmmu.h>	/* DMA_CACHE_SYNC, etc... */
d141 1
d146 1
a250 1

d449 1
a484 2
#define CIO_CNTRL 0xfff8300c

d491 1
a491 1
	int *volatile cio_ctrl = (int *volatile)CIO_CNTRL;
d513 1
a513 1
	int *volatile cio_ctrl = (int *volatile)CIO_CNTRL;
d565 1
@


1.36
log
@Better Z8536 initial programming.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.35 2004/08/02 08:35:00 miod Exp $ */
a237 1
		tick = 1000000 / hz;
d239 1
d296 1
a296 1
	    pcc2_timer_us2lim(tick);
d331 1
a331 1
	    pcc2_timer_us2lim(tick);
a380 1
		tick = 1000000 / hz;
d382 1
d538 1
a538 1
m188_cio_init(unsigned p)
a540 1
	short period;
a542 2

	period = p & 0xffff;
@


1.35
log
@More include files cleaning:
- move MAX_CPUS constant to <machine/cpu.h>
- do not include <machine/board.h> unless needed. In fact, remove this file
  entirely on mvme88k, and include <machine/mvme*.h> on a
  compiling-for-this-board basis
- keep MAX_CMMUS constant private to the m8820x code
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.34 2004/07/30 22:09:59 miod Exp $ */
d453 1
a453 1
	write_cio(CIO_CSR1, CIO_GCB | CIO_CIP);
d465 1
a465 1
	printf("VME188 clock init\n");
@


1.34
log
@Really initialize the z8536; gives us the profiling clock again on 188.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.33 2004/07/30 19:02:05 miod Exp $ */
a79 1
#include <machine/board.h>	/* for register defines */
d88 1
d95 1
@


1.33
log
@Move evcount structures inside struct intrhand, this makes more sense and
gives us more counters in the process.

Also clean up intrhand structures and usage, especially move them to SLISTs.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.32 2004/07/23 21:00:09 miod Exp $ */
d114 2
a115 2
u_int8_t read_cio(int);
void	write_cio(int, u_int8_t);
d487 1
a487 1
write_cio(int reg, u_int8_t val)
d489 2
a490 1
	int s, i;
d508 1
a508 1
u_int8_t
d511 2
a512 2
	int c;
	int s, i;
d519 1
a519 1
	*cio_ctrl = (char)(reg & 0xff);
d539 1
a539 1
	long i;
d563 1
a563 1
	    CIO_MICR_MIE | CIO_MICR_NV | CIO_MICR_RJA | CIO_MICR_DLC);
@


1.32
log
@Better delay code for MVME188. Should make console and network much more
reactive.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.31 2004/07/02 14:00:42 miod Exp $ */
a77 1
#include <sys/evcount.h>
a119 1
	struct evcount	sc_profcnt;
a120 1
	struct evcount	sc_statcnt;
d194 1
a194 1
		pcctwointr_establish(PCC2V_TIMER1, &sc->sc_profih);
d201 1
a201 1
		pcctwointr_establish(PCC2V_TIMER2, &sc->sc_statih);
d211 1
a211 1
		sysconintr_establish(SYSCV_TIMER1, &sc->sc_profih);
d217 1
a217 1
		sysconintr_establish(SYSCV_TIMER2, &sc->sc_statih);
a222 4
	evcount_attach(&sc->sc_statcnt, "stat", (void *)&sc->sc_statih.ih_ipl,
	    &evcount_intr);
	evcount_attach(&sc->sc_profcnt, "clock", (void *)&sc->sc_profih.ih_ipl,
	    &evcount_intr);
a257 2
	struct clocksoftc *sc = clock_cd.cd_devs[0];

a261 1
	sc->sc_profcnt.ec_count++;
a307 1
	struct clocksoftc *sc = clock_cd.cd_devs[0];
a313 1
	sc->sc_statcnt.ec_count++;
a344 1
	struct clocksoftc *sc = clock_cd.cd_devs[0];
a353 1
	sc->sc_profcnt.ec_count++;
a426 1
	struct clocksoftc *sc = clock_cd.cd_devs[0];
a431 1
	sc->sc_statcnt.ec_count++;
@


1.31
log
@Switch mvme88k to evcount, but keep maintaining intrcnt[] too for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.30 2004/04/24 19:51:47 miod Exp $ */
d600 2
d604 1
d606 1
a606 1
		volatile int c = (25 * us) / 3;	/* XXX not accurate! */
@


1.30
log
@Preliminary switch to an mvme88k bus_space world. Not all drivers have been
converted yet, and they rely upon some linear mappings provided by bus_space.

In order to not impact performance, almost all the bus_space accesses go
through macros and inline functions. This currently restricts us to D16 and
D32 access modes, which are selected at compilation time. Since there are no
plans to support D8 vme devices in the future, this is acceptable for now.

This makes the "len" locator for vme devices go away, and allows to simplify
some code which was using the pcctwo device, and will now directly access
hardware which is known to exist, rather than wait until the device is
attached.

While there, try to enforce more interrupt vector number checks, since these
changes pointed out that dart(4) had been working correctly so far by sheer
luck only.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.29 2004/01/14 20:50:48 miod Exp $ */
d78 1
d121 1
d123 1
d225 5
d265 2
d271 2
d318 1
a323 1
	/* increment intr counter */
d325 1
d357 1
d367 2
d441 1
a445 1
	/* increment intr counter */
d447 1
@


1.29
log
@Do not fill more than the first three fields of cfdriver structures unless
necessary. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.28 2003/12/22 11:54:48 miod Exp $ */
d89 1
a89 1
#include <mvme88k/dev/pcctwofunc.h>
a90 1
extern struct vme2reg *sys_vme2;
a94 1
#include <mvme88k/dev/sysconfunc.h>
d97 1
d136 1
d139 1
d240 8
a247 5
	sys_pcc2->pcc2_t1ctl = 0;
	sys_pcc2->pcc2_t1cmp = pcc2_timer_us2lim(tick);
	sys_pcc2->pcc2_t1count = 0;
	sys_pcc2->pcc2_t1ctl = PCC2_TCTL_CEN | PCC2_TCTL_COC | PCC2_TCTL_COVF;
	sys_pcc2->pcc2_t1irq = prof_reset;
d257 2
a258 1
	sys_pcc2->pcc2_t1irq = prof_reset;
d291 8
a298 5
	sys_pcc2->pcc2_t2ctl = 0;
	sys_pcc2->pcc2_t2cmp = pcc2_timer_us2lim(statint);
	sys_pcc2->pcc2_t2count = 0;
	sys_pcc2->pcc2_t2ctl = PCC2_TCTL_CEN | PCC2_TCTL_COC | PCC2_TCTL_COVF;
	sys_pcc2->pcc2_t2irq = stat_reset;
d308 2
a309 1
	sys_pcc2->pcc2_t2irq = stat_reset;
d327 8
a334 5
	sys_pcc2->pcc2_t2ctl = 0;
	sys_pcc2->pcc2_t2cmp = pcc2_timer_us2lim(newint);
	sys_pcc2->pcc2_t2count = 0;		/* should I? */
	sys_pcc2->pcc2_t2irq = stat_reset;
	sys_pcc2->pcc2_t2ctl = PCC2_TCTL_CEN | PCC2_TCTL_COC;
d390 1
a390 1
	if ( period < 9 )
d392 1
a392 1
	else if ( period > 284421 )
d411 2
a412 1
	*((int *volatile)DART_IVR) = SYSCV_TIMER1;	/* set interrupt vec */
d433 1
a433 1
	write_cio(CIO_CSR1, CIO_GCB|CIO_CIP);  /* Ack the interrupt */
d451 1
a451 1
	write_cio(CIO_CSR1, CIO_GCB|CIO_CIP);
d582 6
a587 14

#if NPCCTWO > 0
	/*
	 * On MVME187 and MVME197, we use the vme system controller for
	 * the delay clock.
	 * Do not go to the real timer until the vme device is attached.
	 * We could directly access the chip, but oh well, who cares.
	 */
	if (sys_vme2 != NULL) {
		sys_vme2->vme2_t1cmp = 0xffffffff;
		sys_vme2->vme2_t1count = 0;
		sys_vme2->vme2_tctl |= VME2_TCTL1_CEN;

		while (sys_vme2->vme2_t1count < us)
d589 9
a597 3
		sys_vme2->vme2_tctl &= ~VME2_TCTL1_CEN;
	} else
#endif
d599 2
a600 6
	/*
	 * If we can't use a real timer, use a tight loop.
	 */
	{
		volatile int c = (25 * us) / 3;	/* XXX not accurate! */
		while (--c > 0)
d602 2
@


1.28
log
@Correctly handle vme attachments which specify a larger ca_len size than
initially expected.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.27 2003/12/12 21:51:29 miod Exp $ */
d129 1
a129 1
        NULL, "clock", DV_DULL, 0
@


1.27
log
@Provide a better delay() resolution on 188.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.26 2003/10/11 22:06:50 miod Exp $ */
a175 2
	/* set size to 0 - see pcctwo.c:match for details */
	ca->ca_len = 0;
@


1.26
log
@Merge sclock and clock pseudo-devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.25 2003/10/08 22:36:11 miod Exp $ */
d594 1
a594 1
		volatile int c = 3 * us;	/* XXX not accurate! */
@


1.25
log
@Sync VMEChip2 timer usage with mvme68k (i.e. make it slightly more sane).
Also, use it even when the 1x7 is not a system controller - this does not
matter.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.24 2003/10/08 19:10:04 miod Exp $ */
d70 1
a70 1
 * interval clock driver.
a77 3
#ifdef GPROF
#include <sys/gmon.h>
#endif
a79 1
#include <machine/asm_macro.h>	/* for stack_pointer() */
d110 1
d112 1
d114 3
d133 1
d135 9
d145 10
a154 1
u_char	prof_reset;
d161 1
a161 3
clockmatch(parent, vcf, args)
	struct device *parent;
	void *vcf, *args;
d182 1
a182 3
clockattach(parent, self, args)
	struct device *parent, *self;
	void *args;
d197 7
d214 6
d227 1
d253 1
a253 2
sbc_clockintr(eframe)
	void *eframe;
a264 1
#endif /* NPCCTWO */
d267 1
a267 2
delay(us)
	int us;
d269 39
a307 1
	volatile int c;
a308 1
#if NPCCTWO > 0
d310 3
a312 3
	 * We use the vme system controller for the delay clock.
	 * Do not go to the real timer until vme device is present.
	 * Or, in the case of MVME188, not at all.
d314 13
a326 4
	if (sys_vme2 != NULL) {
		sys_vme2->vme2_t1cmp = 0xffffffff;
		sys_vme2->vme2_t1count = 0;
		sys_vme2->vme2_tctl |= VME2_TCTL1_CEN;
d328 1
a328 10
		while (sys_vme2->vme2_t1count < us)
			;
		sys_vme2->vme2_tctl &= ~VME2_TCTL1_CEN;
		return;
	}
#endif
	c = 3 * us;	/* XXX not accurate! */
	while (--c > 0)
		;
}
a330 2
int counter;

d332 1
a332 2
m188_clockintr(eframe)
	void *eframe;
d377 1
a377 1
	dma_cachectl(0xFFF82000, 0x1000, DMA_CACHE_SYNC_INVAL);
d391 1
a391 1
	*((int *volatile) DART_OPCR) = 0x00;
d394 1
a394 1
	imr = *((int *volatile) DART_STOPC);
d397 1
a397 1
	*((int *volatile) DART_ACR) = 0x30;
d399 3
a401 3
	*((int *volatile) DART_CTUR) = counter / 256;	    /* set counter MSB */
	*((int *volatile) DART_CTLR) = counter % 256;	    /* set counter LSB */
	*((int *volatile) DART_IVR) = SYSCV_TIMER1;	  /* set interrupt vec */
d405 1
a405 1
	imr = *((int *volatile) DART_STARTC);
d408 157
a564 1
	*((int *volatile) DART_OPCR) = 0x04;
d568 31
@


1.24
log
@delay() is actually a void function.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.23 2003/09/28 22:10:20 miod Exp $ */
d90 1
d95 1
a95 4
#include "bugtty.h"
#if NBUGTTY > 0
#include <mvme88k/dev/bugttyfunc.h>
#endif
d97 1
d105 4
a108 1
extern struct vme2reg *sys_vme2;
a133 1
int	clockbus;
d157 1
a157 1
	ca->ca_ipl   = IPL_CLOCK;
d159 1
a159 1
	ca->ca_len  = 0;
d171 1
a171 3
	clockbus = ca->ca_bustype;

	switch (clockbus) {
a180 1
		printf(": VME1x7");
a190 1
		printf(": VME188");
d214 1
a214 2
	sys_pcc2->pcc2_t1ctl = PCC2_TCTL_CEN | PCC2_TCTL_COC |
			       PCC2_TCTL_COVF;
d244 1
d250 8
a257 3
	if (sys_vme2 == NULL || brdtyp == BRD_188) {
		c = 3 * us;	/* XXX not accurate! */
		while (--c > 0);
d260 3
a262 5
	sys_vme2->vme2_irql1 |= (0 << VME2_IRQL1_TIC1SHIFT);
	sys_vme2->vme2_t1count = 0;
	sys_vme2->vme2_tctl |= (VME2_TCTL1_CEN | VME2_TCTL1_COVF);

	while (sys_vme2->vme2_t1count < us)
a263 1
	sys_vme2->vme2_tctl &= ~(VME2_TCTL1_CEN | VME2_TCTL1_COVF);
a275 3
#if 0
	dma_cachectl(DART_BASE, PAGE_SIZE, DMA_CACHE_SYNC_INVAL);
#else
a276 1
#endif
@


1.23
log
@Properly acknowledge MVME188 clock interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.22 2003/09/28 18:03:41 miod Exp $ */
a107 2
u_long delay_factor = 1;

d242 1
a242 1
int
d256 1
a256 1
		return (0);
a264 1
	return (0);
@


1.22
log
@Be volatile enough to start the clock on 188.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.21 2003/06/02 23:27:51 millert Exp $ */
a233 1
	/* increment intr counter */
a234 1

a277 3
	int *volatile dti_stop = (int *volatile)DART_STOPC;
	int *volatile dti_start = (int *volatile)DART_STARTC;
        int *volatile ist = (int *volatile)MVME188_IST;
a278 2
	/* increment intr counter */
	intrcnt[M88K_CLK_IRQ]++;
a279 3
	dma_cachectl(0xFFF82000, 0x1000, DMA_CACHE_SYNC_INVAL);
	tmp = *dti_stop;

d281 4
a284 2
	/* clear the counter/timer output OP3 while we program the DART */
	*((int *volatile) DART_OPCR) = 0x00;
d286 2
a287 2
	/* do the stop counter/timer command */
	tmp = *((int *volatile) DART_STOPC);
d289 1
a289 7
	/* set counter/timer to counter mode, clock/16 */
	*((int *volatile) DART_ACR) = 0x30;

	*((int *volatile) DART_CTUR) = counter / 256;	     /* set counter MSB */
	*((int *volatile) DART_CTLR) = counter % 256;	     /* set counter LSB */
	*((int *volatile) DART_IVR) = SYSCV_TIMER1;	  /* set interrupt vec */
#endif
d295 4
a298 6
	/* give the start counter/timer command */
	tmp = *dti_start;
#if 0
	*((int *volatile) DART_OPCR) = 0x04;
#endif
	if (*ist & DTI_BIT) {
d301 1
@


1.21
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.20 2003/06/02 07:06:56 deraadt Exp $ */
d5 1
a5 1
 * 
d91 1
a91 1
#if NPCCTWO > 0 
d100 1
a100 1
#if NSYSCON > 0 
a106 1
int timerok = 0;
d110 2
a111 2
static int	clockmatch(struct device *, void *, void *);
static void	clockattach(struct device *, struct device *, void *);
d125 3
a127 3
}; 
 
struct cfdriver clock_cd = { 
d129 1
a129 1
}; 
d146 2
a147 2
	register struct confargs *ca = args;
	register struct cfdata *cf = vcf;
d187 1
a187 1
#if NSYSCON > 0 && defined(MVME188)
d198 1
a198 1
	}         
d208 1
a208 1
#endif 
d233 1
a233 1
	
d235 2
a236 2
	intrcnt[M88K_CLK_IRQ]++; 
	
d241 1
a241 1
	timerok = 1;
d245 1
d248 1
a248 1
	register int us;
d250 1
a250 1
	volatile register int c;
d258 1
a258 1
		c = 3 * us;
d272 3
a274 3
#if NSYSCON > 0 
int counter = 0;
#define IST	
d283 1
a283 4
#ifdef DEBUG
	register unsigned long sp;
#endif
	
d285 1
a285 1
	intrcnt[M88K_CLK_IRQ]++; 
a288 1
	
a289 12
#ifdef DEBUG
	/* check kernel stack for overflow */
	sp = stack_pointer();
	if (sp < UADDR + NBPG && sp > UADDR) {
		if (*ist & DTI_BIT) {
			printf("DTI not clearing!\n");
		}
		printf("kernel stack @@ 0x%8x\n", sp);
		panic("stack overflow imminent!");
	}
#endif
	
d303 1
a303 1
#endif 
d308 1
d313 1
a313 1
#endif 
d317 1
d335 1
a335 1
void 
d338 1
a338 1
	int imr;
d364 1
a364 1
	
@


1.20
log
@licence cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.19 2002/03/14 01:26:39 millert Exp $ */
d50 1
a50 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.19
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.18 2002/01/14 21:34:38 miod Exp $ */
a13 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Theo de Raadt for Willowglen Singapore.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.18
log
@volatile police.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.17 2001/12/22 09:49:39 smurph Exp $ */
d121 2
a122 2
static int	clockmatch	__P((struct device *, void *, void *));
static void	clockattach	__P((struct device *, struct device *, void *));
d126 1
a126 1
void	m188_timer_init	__P((unsigned));
d142 2
a143 2
int	sbc_clockintr	__P((void *));
int	m188_clockintr	__P((void *));
@


1.17
log
@masive cmmu overhaul.  function pointers now control cmmu functionality
instead of case statements based on cpu type.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.16 2001/12/20 06:07:28 smurph Exp $ */
d290 3
a292 3
	volatile int *dti_stop = (volatile int *)DART_STOPC;
	volatile int *dti_start = (volatile int *)DART_STARTC;
        volatile int *ist = (volatile int *)MVME188_IST;
d318 1
a318 1
	*((volatile int *) DART_OPCR) = 0x00;
d321 1
a321 1
	tmp = *((volatile int *) DART_STOPC);
d324 1
a324 1
	*((volatile int *) DART_ACR) = 0x30;
d326 3
a328 3
	*((volatile int *) DART_CTUR) = counter / 256;	     /* set counter MSB */
	*((volatile int *) DART_CTLR) = counter % 256;	     /* set counter LSB */
	*((volatile int *) DART_IVR) = SYSCV_TIMER1;	  /* set interrupt vec */
d337 1
a337 1
	*((volatile int *) DART_OPCR) = 0x04;
d377 1
a377 1
	*((volatile int *) DART_OPCR) = 0x00;
d380 1
a380 1
	imr = *((volatile int *) DART_STOPC);
d383 1
a383 1
	*((volatile int *) DART_ACR) = 0x30;
d385 3
a387 3
	*((volatile int *) DART_CTUR) = counter / 256;	    /* set counter MSB */
	*((volatile int *) DART_CTLR) = counter % 256;	    /* set counter LSB */
	*((volatile int *) DART_IVR) = SYSCV_TIMER1;	  /* set interrupt vec */
d391 1
a391 1
	imr = *((volatile int *) DART_STARTC);
d394 1
a394 1
	*((volatile int *) DART_OPCR) = 0x04;
@


1.16
log
@machine dependant pointer changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.15 2001/12/19 07:04:41 smurph Exp $ */
d99 1
a99 1
#include <machine/mmu.h>	/* DMA_CACHE_SYNC, etc... */
@


1.15
log
@Introduce brdtyp and change what cputyp means.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.14 2001/12/16 23:49:46 miod Exp $ */
d194 1
a194 1
		mdfp.clock_init_func = &sbc_initclock;
d205 1
a205 1
		mdfp.clock_init_func = &m188_initclock;
@


1.15.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.18 2002/01/14 21:34:38 miod Exp $ */
d99 1
a99 1
#include <machine/cmmu.h>	/* DMA_CACHE_SYNC, etc... */
d194 1
a194 1
		md.clock_init_func = sbc_initclock;
d205 1
a205 1
		md.clock_init_func = m188_initclock;
d290 3
a292 3
	int *volatile dti_stop = (int *volatile)DART_STOPC;
	int *volatile dti_start = (int *volatile)DART_STARTC;
        int *volatile ist = (int *volatile)MVME188_IST;
d318 1
a318 1
	*((int *volatile) DART_OPCR) = 0x00;
d321 1
a321 1
	tmp = *((int *volatile) DART_STOPC);
d324 1
a324 1
	*((int *volatile) DART_ACR) = 0x30;
d326 3
a328 3
	*((int *volatile) DART_CTUR) = counter / 256;	     /* set counter MSB */
	*((int *volatile) DART_CTLR) = counter % 256;	     /* set counter LSB */
	*((int *volatile) DART_IVR) = SYSCV_TIMER1;	  /* set interrupt vec */
d337 1
a337 1
	*((int *volatile) DART_OPCR) = 0x04;
d377 1
a377 1
	*((int *volatile) DART_OPCR) = 0x00;
d380 1
a380 1
	imr = *((int *volatile) DART_STOPC);
d383 1
a383 1
	*((int *volatile) DART_ACR) = 0x30;
d385 3
a387 3
	*((int *volatile) DART_CTUR) = counter / 256;	    /* set counter MSB */
	*((int *volatile) DART_CTLR) = counter % 256;	    /* set counter LSB */
	*((int *volatile) DART_IVR) = SYSCV_TIMER1;	  /* set interrupt vec */
d391 1
a391 1
	imr = *((int *volatile) DART_STARTC);
d394 1
a394 1
	*((int *volatile) DART_OPCR) = 0x04;
@


1.15.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.15.2.1 2002/01/31 22:55:17 niklas Exp $ */
d121 2
a122 2
static int	clockmatch(struct device *, void *, void *);
static void	clockattach(struct device *, struct device *, void *);
d126 1
a126 1
void	m188_timer_init(unsigned);
d142 2
a143 2
int	sbc_clockintr(void *);
int	m188_clockintr(void *);
@


1.14
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.11 2001/10/28 00:57:20 miod Exp $ */
d267 1
a267 1
	if (sys_vme2 == NULL || cputyp == CPU_188) {
@


1.13
log
@Even more one-liners to get the kernel to link.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.12 2001/12/13 08:55:51 smurph Exp $ */
a99 1
#include <machine/cmmu.h>
d194 1
a194 1
		md.clock_init_func = sbc_initclock;
d205 1
a205 1
		md.clock_init_func = m188_initclock;
d267 1
a267 1
	if (sys_vme2 == NULL || brdtyp == BRD_188) {
@


1.12
log
@Support for MVME197 completed.  Fix SPL defs.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.11 2001/10/28 00:57:20 miod Exp $ */
d100 1
@


1.11
log
@I have nothing against stack checks at clock ints, as long as they are
gramatically correct and only there if DEBUG is defined.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.10 2001/03/09 05:44:38 smurph Exp $ */
d194 1
a194 1
		mdfp.clock_init_func = &sbc_initclock;
d205 1
a205 1
		mdfp.clock_init_func = &m188_initclock;
d267 1
a267 1
	if (sys_vme2 == NULL || cputyp == CPU_188) {
@


1.10
log
@kernel will compile with -Werror.  Added intr.h
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.9 2001/03/07 23:45:50 miod Exp $ */
d92 1
d293 1
d295 1
d304 1
d312 1
a312 1
		panic("stack overflow eminant!");
d314 1
@


1.9
log
@Fix interrupt handler registration and prototypes.
While there, some warning hunting.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.8 2001/02/12 08:16:22 smurph Exp $ */
d153 2
a154 2
struct device *parent;
void *vcf, *args;
d176 2
a177 2
struct device *parent, *self;
void *args;
d257 1
a257 1
register int us;
@


1.8
log
@correct buginstat(), statclock now working for '188, systat vmstat now works,
serial driver for '188 working better.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.7 2001/02/01 03:38:14 smurph Exp $ */
d87 1
d101 1
d103 4
d110 1
a141 1
int	sbc_statintr	__P((void *));
a142 1
int	m188_statintr	__P((void *));
a215 2
	register int statint, minint;

d239 2
a240 2
sbc_clockintr(arg)
void *arg;
d247 1
a247 2
	hardclock(arg);
#include "bugtty.h"
d260 1
a260 1
	unsigned long st;
d285 2
a286 2
m188_clockintr(arg)
void *arg;
d325 1
a325 2
	hardclock(arg);
#include "bugtty.h"
a342 2
	register int statint, minint;

@


1.7
log
@Major changes to get MVME188 working.  More header and code cleanups.  The
kernel is tested on MVME188A/2P256 and MVME188A/1P64.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.6 1999/09/27 18:43:23 smurph Exp $ */
d240 4
d247 1
a247 1
/*	bugtty_chkinput();*/
d292 2
d326 1
a326 1
/*	bugtty_chkinput(); */
@


1.6
log
@adding support for MVME188 and MVME197.  Plus 32bit if_ie.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.5 1999/05/29 04:41:43 smurph Exp $ */
d91 2
d97 1
d113 2
a114 2
static int	clockmatch __P((struct device *, void *, void *));
static void	clockattach __P((struct device *, struct device *, void *));
d116 3
a118 3
void sbc_initclock(void);
void m188_initclock(void);
void m188_timer_init __P((unsigned));
d121 3
a123 3
	struct device			sc_dev;
	struct intrhand sc_profih;
	struct intrhand sc_statih;
d134 4
a137 4
int	sbc_clockintr __P((void *));
int	sbc_statintr __P((void *));
int   m188_clockintr __P((void *));
int   m188_statintr __P((void *));
d148 2
a149 2
	struct device *parent;
	void *vcf, *args;
a165 2


d171 2
a172 2
	struct device *parent, *self;
	void *args;
d178 13
a190 13
   
   switch (clockbus) {
#if NPCCTWO > 0 
   case BUS_PCCTWO:
	   sc->sc_profih.ih_fn = sbc_clockintr;
      sc->sc_profih.ih_arg = 0;
      sc->sc_profih.ih_wantframe = 1;
      sc->sc_profih.ih_ipl = ca->ca_ipl;
      prof_reset = ca->ca_ipl | PCC2_IRQ_IEN | PCC2_IRQ_ICLR;
   	pcctwointr_establish(PCC2V_TIMER1, &sc->sc_profih);
      mdfp.clock_init_func = &sbc_initclock;
      printf(": VME1x7");
      break;
d192 10
a201 10
#if NSYSCON > 0 
   case BUS_SYSCON:
      sc->sc_profih.ih_fn = m188_clockintr;
      sc->sc_profih.ih_arg = 0;
      sc->sc_profih.ih_wantframe = 1;
      sc->sc_profih.ih_ipl = ca->ca_ipl;
      sysconintr_establish(SYSCV_TIMER1, &sc->sc_profih);
      mdfp.clock_init_func = &m188_initclock;
      printf(": VME188");
      break;
d203 1
a203 1
   }         
d207 1
a207 1
#if NPCCTWO > 0 
d213 2
a214 2
#ifdef DEBUG
   printf("SBC clock init\n");
d227 1
a227 1
	    PCC2_TCTL_COVF;
d237 1
a237 1
	void *arg;
d243 1
a243 1
	bugtty_chkinput();
d246 1
a246 1
   return (1);
d249 1
a249 1

d251 1
a251 1
	register int us;
d258 1
a258 1
    * Or, in the case of MVME188, not at all.
d261 3
a263 3
	    c = 3 * us;
	    while (--c > 0);
	    return(0);
d265 3
a267 3
   sys_vme2->vme2_irql1 |= (0 << VME2_IRQL1_TIC1SHIFT);
   sys_vme2->vme2_t1count = 0;
   sys_vme2->vme2_tctl |= (VME2_TCTL1_CEN | VME2_TCTL1_COVF);
d269 1
a269 1
   while (sys_vme2->vme2_t1count < us)
d271 1
a271 1
   sys_vme2->vme2_tctl &= ~(VME2_TCTL1_CEN | VME2_TCTL1_COVF);
d277 1
a277 1

d280 1
a280 1
	void *arg;
d282 35
a316 15
   volatile int tmp;
   /* acknowledge the timer interrupt */
   /* clear the counter/timer output OP3 while we program the DART */
   *((volatile int *) DART_OPCR) = 0x00;

   /* do the stop counter/timer command */
   tmp = *((volatile int *) DART_STOPC);

   /* set counter/timer to counter mode, clock/16 */
   *((volatile int *) DART_ACR) = 0x30;
   
   *((volatile int *) DART_CTUR) = counter / 256;	/* set counter MSB */
   *((volatile int *) DART_CTLR) = counter % 256;	/* set counter LSB */
   *((volatile int *) DART_IVR) = SYSCV_TIMER1;      /* set interrupt vec */

d320 1
a320 1
	bugtty_chkinput();
d322 8
a329 3
   /* give the start counter/timer command */
   tmp = *((volatile int *) DART_STARTC);
   *((volatile int *) DART_OPCR) = 0x04;
d338 2
a339 2
#ifdef DEBUG
   printf("VME188 clock init\n");
d352 2
a353 1
    int imr;
d355 10
a364 10
    /* make sure the counter range is proper. */
    if ( period < 9 )
        counter = 2;
    else if ( period > 284421 )
        counter = 65535;
    else
        counter = period / 4.34;
#ifdef DEBUG
    printf("tick == %d, period == %d\n", tick, period);
    printf("timer will interrupt every %d usec\n", (int) (counter * 4.34));
d366 2
a367 2
    /* clear the counter/timer output OP3 while we program the DART */
    *((volatile int *) DART_OPCR) = 0x00;
d369 2
a370 2
    /* do the stop counter/timer command */
    imr = *((volatile int *) DART_STOPC);
d372 2
a373 9
    /* set counter/timer to counter mode, clock/16 */
    *((volatile int *) DART_ACR) = 0x30;
    
    *((volatile int *) DART_CTUR) = counter / 256;	/* set counter MSB */
    *((volatile int *) DART_CTLR) = counter % 256;	/* set counter LSB */
    *((volatile int *) DART_IVR) = SYSCV_TIMER1;      /* set interrupt vec */
    /* give the start counter/timer command */
    /* (yes, this is supposed to be a read) */
    imr = *((volatile int *) DART_STARTC);
d375 10
a384 2
    /* set the counter/timer output OP3 */
    *((volatile int *) DART_OPCR) = 0x04;
d387 1
@


1.6.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.10 2001/03/09 05:44:38 smurph Exp $ */
a86 1
#include <sys/systm.h>
a90 2
#include <machine/asm_macro.h>	/* for stack_pointer() */
#include <machine/board.h>	/* for register defines */
a94 1
#include <machine/mmu.h>	/* DMA_CACHE_SYNC, etc... */
a96 1
#include <mvme88k/dev/pcctwofunc.h>
a97 4
#include "bugtty.h"
#if NBUGTTY > 0
#include <mvme88k/dev/bugttyfunc.h>
#endif
a100 1
#include <mvme88k/dev/sysconfunc.h>
d110 2
a111 2
static int	clockmatch	__P((struct device *, void *, void *));
static void	clockattach	__P((struct device *, struct device *, void *));
d113 3
a115 3
void	sbc_initclock(void);
void	m188_initclock(void);
void	m188_timer_init	__P((unsigned));
d118 3
a120 3
	struct device	sc_dev;
	struct intrhand	sc_profih;
	struct intrhand	sc_statih;
d131 4
a134 2
int	sbc_clockintr	__P((void *));
int	m188_clockintr	__P((void *));
d163 2
d177 13
a189 13

	switch (clockbus) {
#if NPCCTWO > 0
	case BUS_PCCTWO:
		sc->sc_profih.ih_fn = sbc_clockintr;
		sc->sc_profih.ih_arg = 0;
		sc->sc_profih.ih_wantframe = 1;
		sc->sc_profih.ih_ipl = ca->ca_ipl;
		prof_reset = ca->ca_ipl | PCC2_IRQ_IEN | PCC2_IRQ_ICLR;
		pcctwointr_establish(PCC2V_TIMER1, &sc->sc_profih);
		mdfp.clock_init_func = &sbc_initclock;
		printf(": VME1x7");
		break;
d191 10
a200 10
#if NSYSCON > 0 && defined(MVME188)
	case BUS_SYSCON:
		sc->sc_profih.ih_fn = m188_clockintr;
		sc->sc_profih.ih_arg = 0;
		sc->sc_profih.ih_wantframe = 1;
		sc->sc_profih.ih_ipl = ca->ca_ipl;
		sysconintr_establish(SYSCV_TIMER1, &sc->sc_profih);
		mdfp.clock_init_func = &m188_initclock;
		printf(": VME188");
		break;
d202 1
a202 1
	}         
d206 1
a206 1
#if NPCCTWO > 0
d210 4
a213 2
#ifdef CLOCK_DEBUG
	printf("SBC clock init\n");
d226 1
a226 1
			       PCC2_TCTL_COVF;
d235 2
a236 2
sbc_clockintr(eframe)
	void *eframe;
d239 2
a240 5
	
	/* increment intr counter */
	intrcnt[M88K_CLK_IRQ]++; 
	
	hardclock(eframe);
d245 1
a245 1
	return (1);
d248 1
a248 1
int
d253 1
a253 1

d257 1
a257 1
	 * Or, in the case of MVME188, not at all.
d260 3
a262 3
		c = 3 * us;
		while (--c > 0);
		return (0);
d264 3
a266 3
	sys_vme2->vme2_irql1 |= (0 << VME2_IRQL1_TIC1SHIFT);
	sys_vme2->vme2_t1count = 0;
	sys_vme2->vme2_tctl |= (VME2_TCTL1_CEN | VME2_TCTL1_COVF);
d268 1
a268 1
	while (sys_vme2->vme2_t1count < us)
d270 1
a270 1
	sys_vme2->vme2_tctl &= ~(VME2_TCTL1_CEN | VME2_TCTL1_COVF);
d276 1
a276 1
#define IST	
d278 2
a279 2
m188_clockintr(eframe)
	void *eframe;
d281 17
a297 38
	volatile int tmp;
	volatile int *dti_stop = (volatile int *)DART_STOPC;
	volatile int *dti_start = (volatile int *)DART_STARTC;
        volatile int *ist = (volatile int *)MVME188_IST;
	register unsigned long sp;
	
	/* increment intr counter */
	intrcnt[M88K_CLK_IRQ]++; 
	/* acknowledge the timer interrupt */
	dma_cachectl(0xFFF82000, 0x1000, DMA_CACHE_SYNC_INVAL);
	tmp = *dti_stop;
	

	/* check kernel stack for overflow */
	sp = stack_pointer();
	if (sp < UADDR + NBPG && sp > UADDR) {
		if (*ist & DTI_BIT) {
			printf("DTI not clearing!\n");
		}
		printf("kernel stack @@ 0x%8x\n", sp);
		panic("stack overflow eminant!");
	}
	
#if 0
	/* clear the counter/timer output OP3 while we program the DART */
	*((volatile int *) DART_OPCR) = 0x00;

	/* do the stop counter/timer command */
	tmp = *((volatile int *) DART_STOPC);

	/* set counter/timer to counter mode, clock/16 */
	*((volatile int *) DART_ACR) = 0x30;

	*((volatile int *) DART_CTUR) = counter / 256;	     /* set counter MSB */
	*((volatile int *) DART_CTLR) = counter % 256;	     /* set counter LSB */
	*((volatile int *) DART_IVR) = SYSCV_TIMER1;	  /* set interrupt vec */
#endif 
	hardclock(eframe);
d301 3
a303 8
	/* give the start counter/timer command */
	tmp = *dti_start;
#if 0
	*((volatile int *) DART_OPCR) = 0x04;
#endif 
	if (*ist & DTI_BIT) {
		printf("DTI not clearing!\n");
	}
d310 4
a313 2
#ifdef CLOCK_DEBUG
	printf("VME188 clock init\n");
d326 1
a326 2
	int imr;
	dma_cachectl(0xFFF82000, 0x1000, DMA_CACHE_SYNC_INVAL);
d328 10
a337 10
	/* make sure the counter range is proper. */
	if ( period < 9 )
		counter = 2;
	else if ( period > 284421 )
		counter = 65535;
	else
		counter	= period / 4.34;
#ifdef CLOCK_DEBUG
	printf("tick == %d, period == %d\n", tick, period);
	printf("timer will interrupt every %d usec\n", (int) (counter * 4.34));
d339 2
a340 5
	/* clear the counter/timer output OP3 while we program the DART */
	*((volatile int *) DART_OPCR) = 0x00;

	/* do the stop counter/timer command */
	imr = *((volatile int *) DART_STOPC);
d342 2
a343 2
	/* set counter/timer to counter mode, clock/16 */
	*((volatile int *) DART_ACR) = 0x30;
d345 9
a353 7
	*((volatile int *) DART_CTUR) = counter / 256;	    /* set counter MSB */
	*((volatile int *) DART_CTLR) = counter % 256;	    /* set counter LSB */
	*((volatile int *) DART_IVR) = SYSCV_TIMER1;	  /* set interrupt vec */
	
	/* give the start counter/timer command */
	/* (yes, this is supposed to be a read) */
	imr = *((volatile int *) DART_STARTC);
d355 2
a356 2
	/* set the counter/timer output OP3 */
	*((volatile int *) DART_OPCR) = 0x04;
a358 1

@


1.6.4.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a91 1
#include <machine/asm.h>
a291 1
#ifdef DEBUG
a292 1
#endif
a300 1
#ifdef DEBUG
d308 1
a308 1
		panic("stack overflow imminent!");
a309 1
#endif
@


1.6.4.3
log
@Merge in trunk
@
text
@d99 1
a99 1
#include <machine/cmmu.h>	/* DMA_CACHE_SYNC, etc... */
d194 1
a194 1
		md.clock_init_func = sbc_initclock;
d205 1
a205 1
		md.clock_init_func = m188_initclock;
d267 1
a267 1
	if (sys_vme2 == NULL || brdtyp == BRD_188) {
d290 3
a292 3
	int *volatile dti_stop = (int *volatile)DART_STOPC;
	int *volatile dti_start = (int *volatile)DART_STARTC;
        int *volatile ist = (int *volatile)MVME188_IST;
d318 1
a318 1
	*((int *volatile) DART_OPCR) = 0x00;
d321 1
a321 1
	tmp = *((int *volatile) DART_STOPC);
d324 1
a324 1
	*((int *volatile) DART_ACR) = 0x30;
d326 3
a328 3
	*((int *volatile) DART_CTUR) = counter / 256;	     /* set counter MSB */
	*((int *volatile) DART_CTLR) = counter % 256;	     /* set counter LSB */
	*((int *volatile) DART_IVR) = SYSCV_TIMER1;	  /* set interrupt vec */
d337 1
a337 1
	*((int *volatile) DART_OPCR) = 0x04;
d377 1
a377 1
	*((int *volatile) DART_OPCR) = 0x00;
d380 1
a380 1
	imr = *((int *volatile) DART_STOPC);
d383 1
a383 1
	*((int *volatile) DART_ACR) = 0x30;
d385 3
a387 3
	*((int *volatile) DART_CTUR) = counter / 256;	    /* set counter MSB */
	*((int *volatile) DART_CTLR) = counter % 256;	    /* set counter LSB */
	*((int *volatile) DART_IVR) = SYSCV_TIMER1;	  /* set interrupt vec */
d391 1
a391 1
	imr = *((int *volatile) DART_STARTC);
d394 1
a394 1
	*((int *volatile) DART_OPCR) = 0x04;
@


1.6.4.4
log
@Merge in -current from about a week ago
@
text
@d121 2
a122 2
static int	clockmatch(struct device *, void *, void *);
static void	clockattach(struct device *, struct device *, void *);
d126 1
a126 1
void	m188_timer_init(unsigned);
d142 2
a143 2
int	sbc_clockintr(void *);
int	m188_clockintr(void *);
@


1.6.4.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.6.4.4 2002/03/28 10:36:02 niklas Exp $ */
d14 6
d56 5
a60 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.6.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d5 1
a5 1
 *
d70 1
a70 1
 * Interval and statistic clocks driver.
d78 3
d83 1
a89 1

d91 1
a91 1
#if NPCCTWO > 0
d94 4
a97 1
extern struct vme2reg *sys_vme2;
a98 1

d100 1
a100 1
#if NSYSCON > 0
d106 4
a109 4
#include "bugtty.h"
#if NBUGTTY > 0
#include <mvme88k/dev/bugttyfunc.h>
#endif
d111 2
a112 2
int	clockmatch(struct device *, void *, void *);
void	clockattach(struct device *, struct device *, void *);
a114 1
void	sbc_initstatclock(void);
a115 1
void	m188_initstatclock(void);
a116 3
void	m188_cio_init(unsigned);
u_int8_t read_cio(int);
void	write_cio(int, u_int8_t);
d126 5
a130 5
};

struct cfdriver clock_cd = {
        NULL, "clock", DV_DULL
};
a132 1
int	sbc_statintr(void *);
a133 6
int	m188_statintr(void *);

u_int8_t prof_reset;
u_int8_t stat_reset;

struct simplelock cio_lock;
d135 2
a136 13
#define	CIO_LOCK	simple_lock(&cio_lock)
#define	CIO_UNLOCK	simple_unlock(&cio_lock)

/*
 * Statistics clock interval and variance, in usec.  Variance must be a
 * power of two.  Since this gives us an even number, not an odd number,
 * we discard one case and compensate.  That is, a variance of 4096 would
 * give us offsets in [0..4095].  Instead, we take offsets in [1..4095].
 * This is symmetric about the point 2048, or statvar/2, and thus averages
 * to that value (assuming uniform random numbers).
 */
int statvar = 8192;
int statmin;			/* statclock interval - 1/2*variance */
d143 3
a145 1
clockmatch(struct device *parent, void *vcf, void *args)
d147 2
a148 2
	struct confargs *ca = args;
	struct cfdata *cf = vcf;
d159 3
a161 1
	ca->ca_ipl = IPL_CLOCK;
d166 3
a168 1
clockattach(struct device *parent, struct device *self, void *args)
d173 3
a175 1
	switch (ca->ca_bustype) {
d185 1
a185 7
		sc->sc_statih.ih_fn = sbc_statintr;
		sc->sc_statih.ih_arg = 0;
		sc->sc_statih.ih_wantframe = 1;
		sc->sc_statih.ih_ipl = ca->ca_ipl;
		stat_reset = ca->ca_ipl | PCC2_IRQ_IEN | PCC2_IRQ_ICLR;
		pcctwointr_establish(PCC2V_TIMER2, &sc->sc_statih);
		md.statclock_init_func = sbc_initstatclock;
d188 1
a188 1
#if NSYSCON > 0
d196 1
a196 6
		sc->sc_statih.ih_fn = m188_statintr;
		sc->sc_statih.ih_arg = 0;
		sc->sc_statih.ih_wantframe = 1;
		sc->sc_statih.ih_ipl = ca->ca_ipl;
		sysconintr_establish(SYSCV_TIMER2, &sc->sc_statih);
		md.statclock_init_func = m188_initstatclock;
d199 1
a199 1
	}
a203 1

d209 1
a209 1
#endif
d220 2
a221 1
	sys_pcc2->pcc2_t1ctl = PCC2_TCTL_CEN | PCC2_TCTL_COC | PCC2_TCTL_COVF;
d230 2
a231 1
sbc_clockintr(void *eframe)
d234 4
a237 2

	intrcnt[M88K_CLK_IRQ]++;
d242 1
a242 1

d245 1
a245 32

void
sbc_initstatclock(void)
{
	int statint, minint;

#ifdef CLOCK_DEBUG
	printf("SBC statclock init\n");
#endif
	if (stathz == 0)
		stathz = hz;
	if (1000000 % stathz) {
		printf("cannot get %d Hz statclock; using 100 Hz\n", stathz);
		stathz = 100;
	}
	profhz = stathz;		/* always */

	statint = 1000000 / stathz;
	minint = statint / 2 + 100;
	while (statvar > minint)
		statvar >>= 1;

	/* statclock */
	sys_pcc2->pcc2_t2ctl = 0;
	sys_pcc2->pcc2_t2cmp = pcc2_timer_us2lim(statint);
	sys_pcc2->pcc2_t2count = 0;
	sys_pcc2->pcc2_t2ctl = PCC2_TCTL_CEN | PCC2_TCTL_COC | PCC2_TCTL_COVF;
	sys_pcc2->pcc2_t2irq = stat_reset;

	statmin = statint - (statvar >> 1);
}

d247 2
a248 1
sbc_statintr(void *eframe)
d250 1
a250 8
	u_long newint, r, var;

	sys_pcc2->pcc2_t2irq = stat_reset;

	/* increment intr counter */
	intrcnt[M88K_SCLK_IRQ]++;

	statclock((struct clockframe *)eframe);
d253 3
a255 3
	 * Compute new randomized interval.  The intervals are uniformly
	 * distributed on [statint - statvar / 2, statint + statvar / 2],
	 * and therefore have mean statint, giving a stathz frequency clock.
d257 13
a269 12
	var = statvar;
	do {
		r = random() & (var - 1);
	} while (r == 0);
	newint = statmin + r;

	sys_pcc2->pcc2_t2ctl = 0;
	sys_pcc2->pcc2_t2cmp = pcc2_timer_us2lim(newint);
	sys_pcc2->pcc2_t2count = 0;		/* should I? */
	sys_pcc2->pcc2_t2irq = stat_reset;
	sys_pcc2->pcc2_t2ctl = PCC2_TCTL_CEN | PCC2_TCTL_COC;
	return (1);
d272 3
a274 3
#endif /* NPCCTWO */

#if NSYSCON > 0
d276 2
a277 1
m188_clockintr(void *eframe)
d280 29
d310 2
a311 2
	/* acknowledge the timer interrupt */
	tmp = *(int *volatile)DART_ISR;
d313 2
a314 2
	/* stop the timer while the interrupt is being serviced */
	tmp = *(int *volatile)DART_STOPC;
d316 4
a319 1
	intrcnt[M88K_CLK_IRQ]++;
d324 6
a329 5

	tmp = *(int *volatile)DART_STARTC;

#ifdef CLOCK_DEBUG
	if (*(int *volatile)MVME188_IST & DTI_BIT) {
a331 2
#endif

d349 1
a349 1
void
d352 2
a353 2
	volatile int imr;
	int counter;
d367 1
a367 1
	*((int *volatile)DART_OPCR) = 0x00;
d370 1
a370 1
	imr = *((int *volatile)DART_STOPC);
d373 1
a373 5
	*((int *volatile)DART_ACR) = 0x30;

	*((int *volatile)DART_CTUR) = counter / 256;	/* set counter MSB */
	*((int *volatile)DART_CTLR) = counter % 256;	/* set counter LSB */
	*((int *volatile)DART_IVR) = SYSCV_TIMER1;	/* set interrupt vec */
d375 4
d381 1
a381 1
	imr = *((int *volatile)DART_STARTC);
d384 1
a384 157
	*((int *volatile)DART_OPCR) = 0x04;
}

int
m188_statintr(void *eframe)
{
	u_long newint, r, var;

	CIO_LOCK;

	/* increment intr counter */
	intrcnt[M88K_SCLK_IRQ]++;

	statclock((struct clockframe *)eframe);
	write_cio(CIO_CSR1, CIO_GCB|CIO_CIP);  /* Ack the interrupt */

	/*
	 * Compute new randomized interval.  The intervals are uniformly
	 * distributed on [statint - statvar / 2, statint + statvar / 2],
	 * and therefore have mean statint, giving a stathz frequency clock.
	 */
	var = statvar;
	do {
		r = random() & (var - 1);
	} while (r == 0);
	newint = statmin + r;

	/* Load time constant CTC #1 */
	write_cio(CIO_CT1MSB, (newint & 0xff00) >> 8);
	write_cio(CIO_CT1LSB, newint & 0xff);

	/* Start CTC #1 running */
	write_cio(CIO_CSR1, CIO_GCB|CIO_CIP);

	CIO_UNLOCK;
	return (1);
}

void
m188_initstatclock(void)
{
	int statint, minint;

#ifdef CLOCK_DEBUG
	printf("VME188 clock init\n");
#endif
	simple_lock_init(&cio_lock);
	if (stathz == 0)
		stathz = hz;
	if (1000000 % stathz) {
		printf("cannot get %d Hz statclock; using 100 Hz\n", stathz);
		stathz = 100;
	}
	profhz = stathz;		/* always */

	statint = 1000000 / stathz;
	minint = statint / 2 + 100;
	while (statvar > minint)
		statvar >>= 1;
	m188_cio_init(statint);
	statmin = statint - (statvar >> 1);
}

#define CIO_CNTRL 0xfff8300c

/* Write CIO register */
void
write_cio(int reg, u_int8_t val)
{
	int s, i;
	int *volatile cio_ctrl = (int *volatile)CIO_CNTRL;

	s = splclock();
	CIO_LOCK;

	i = *cio_ctrl;				/* goto state 1 */
	*cio_ctrl = 0;				/* take CIO out of RESET */
	i = *cio_ctrl;				/* reset CIO state machine */

	*cio_ctrl = (reg & 0xff);		/* Select register */
	*cio_ctrl = (val & 0xff);		/* Write the value */

	CIO_UNLOCK;
	splx(s);
}

/* Read CIO register */
u_int8_t
read_cio(int reg)
{
	int c;
	int s, i;
	int *volatile cio_ctrl = (int *volatile)CIO_CNTRL;

	s = splclock();
	CIO_LOCK;

	/* Select register */
	*cio_ctrl = (char)(reg & 0xff);
	/* Delay for a short time to allow 8536 to settle */
	for (i = 0; i < 100; i++)
		;
	/* read the value */
	c = *cio_ctrl;
	CIO_UNLOCK;
	splx(s);
	return (c & 0xff);
}

/*
 * Initialize the CTC (8536)
 * Only the counter/timers are used - the IO ports are un-comitted.
 * Channels 1 and 2 are linked to provide a /32 counter.
 */

void
m188_cio_init(unsigned p)
{
	long i;
	short period;

	CIO_LOCK;

	period = p & 0xffff;

	/* Initialize 8536 CTC */

	/* Start by forcing chip into known state */
	read_cio(CIO_MICR);
	write_cio(CIO_MICR, CIO_MICR_RESET);	/* Reset the CTC */
	for (i = 0; i < 1000; i++)	 	/* Loop to delay */
		;

	/* Clear reset and start init seq. */
	write_cio(CIO_MICR, 0x00);

	/* Wait for chip to come ready */
	while ((read_cio(CIO_MICR) & CIO_MICR_RJA) == 0)
		;

	/* Initialize the 8536 */
	write_cio(CIO_MICR,
	    CIO_MICR_MIE | CIO_MICR_NV | CIO_MICR_RJA | CIO_MICR_DLC);
	write_cio(CIO_CTMS1, CIO_CTMS_CSC);	/* Continuous count */
	write_cio(CIO_PDCB, 0xff);		/* set port B to input */

	/* Load time constant CTC #1 */
	write_cio(CIO_CT1MSB, (period & 0xff00) >> 8);
	write_cio(CIO_CT1LSB, period & 0xff);

	/* enable counter 1 */
	write_cio(CIO_MCCR, CIO_MCCR_CT1E | CIO_MCCR_PBE);

	/* Start CTC #1 running */
	write_cio(CIO_CSR1, CIO_GCB | CIO_TCB | CIO_IE);

	CIO_UNLOCK;
a387 31
void
delay(int us)
{

#if NPCCTWO > 0
	/*
	 * On MVME187 and MVME197, we use the vme system controller for
	 * the delay clock.
	 * Do not go to the real timer until the vme device is attached.
	 * We could directly access the chip, but oh well, who cares.
	 */
	if (sys_vme2 != NULL) {
		sys_vme2->vme2_t1cmp = 0xffffffff;
		sys_vme2->vme2_t1count = 0;
		sys_vme2->vme2_tctl |= VME2_TCTL1_CEN;

		while (sys_vme2->vme2_t1count < us)
			;
		sys_vme2->vme2_tctl &= ~VME2_TCTL1_CEN;
	} else
#endif

	/*
	 * If we can't use a real timer, use a tight loop.
	 */
	{
		volatile int c = (25 * us) / 3;	/* XXX not accurate! */
		while (--c > 0)
			;
	}
}
@


1.6.4.7
log
@Merge with the trunk
@
text
@d89 1
a89 1
#include <mvme88k/dev/pcctwovar.h>
d91 1
d96 1
a98 1

a136 1
#if NPCCTWO > 0
a138 1
#endif
d239 5
a243 8
	*(volatile u_int8_t *)(OBIO_START + PCC2_BASE + PCCTWO_T1CTL) = 0;
	*(volatile u_int32_t *)(OBIO_START + PCC2_BASE + PCCTWO_T1CMP) =
	    pcc2_timer_us2lim(tick);
	*(volatile u_int32_t *)(OBIO_START + PCC2_BASE + PCCTWO_T1COUNT) = 0;
	*(volatile u_int8_t *)(OBIO_START + PCC2_BASE + PCCTWO_T1CTL) =
	    PCC2_TCTL_CEN | PCC2_TCTL_COC | PCC2_TCTL_COVF;
	*(volatile u_int8_t *)(OBIO_START + PCC2_BASE + PCCTWO_T1ICR) =
	    prof_reset;
d253 1
a253 2
	*(volatile u_int8_t *)(OBIO_START + PCC2_BASE + PCCTWO_T1ICR) =
	    prof_reset;
d286 5
a290 8
	*(volatile u_int8_t *)(OBIO_START + PCC2_BASE + PCCTWO_T2CTL) = 0;
	*(volatile u_int32_t *)(OBIO_START + PCC2_BASE + PCCTWO_T2CMP) =
	    pcc2_timer_us2lim(tick);
	*(volatile u_int32_t *)(OBIO_START + PCC2_BASE + PCCTWO_T2COUNT) = 0;
	*(volatile u_int8_t *)(OBIO_START + PCC2_BASE + PCCTWO_T2CTL) =
	    PCC2_TCTL_CEN | PCC2_TCTL_COC | PCC2_TCTL_COVF;
	*(volatile u_int8_t *)(OBIO_START + PCC2_BASE + PCCTWO_T2ICR) =
	    stat_reset;
d300 1
a300 2
	*(volatile u_int8_t *)(OBIO_START + PCC2_BASE + PCCTWO_T2ICR) =
	    stat_reset;
d318 5
a322 8
	*(volatile u_int8_t *)(OBIO_START + PCC2_BASE + PCCTWO_T2CTL) = 0;
	*(volatile u_int32_t *)(OBIO_START + PCC2_BASE + PCCTWO_T2CMP) =
	    pcc2_timer_us2lim(tick);
	*(volatile u_int32_t *)(OBIO_START + PCC2_BASE + PCCTWO_T2COUNT) = 0;
	*(volatile u_int8_t *)(OBIO_START + PCC2_BASE + PCCTWO_T2ICR) =
	    stat_reset;
	*(volatile u_int8_t *)(OBIO_START + PCC2_BASE + PCCTWO_T2CTL) =
	    PCC2_TCTL_CEN | PCC2_TCTL_COC;
d378 1
a378 1
	if (period < 9)
d380 1
a380 1
	else if (period > 284421)
d399 1
a399 2
	/* set interrupt vec */
	*((int *volatile)DART_IVR) = SYSCON_VECT + SYSCV_TIMER1;
d420 1
a420 1
	write_cio(CIO_CSR1, CIO_GCB | CIO_CIP);  /* Ack the interrupt */
d438 1
a438 1
	write_cio(CIO_CSR1, CIO_GCB | CIO_CIP);
d569 23
a591 4
	if (brdtyp == BRD_188) {
		/*
		 * Unable to use a real timer, use a tight loop.
		 */
a594 15
	} else {
		/*
		 * On MVME187 and MVME197, use the VMEchip for the
		 * delay clock.
		 */
		*(volatile u_int32_t *)(VME2_BASE + VME2_T1CMP) = 0xffffffff;
		*(volatile u_int32_t *)(VME2_BASE + VME2_T1COUNT) = 0;
		*(volatile u_int32_t *)(VME2_BASE + VME2_TCTL) |=
		    VME2_TCTL1_CEN;

		while ((*(volatile u_int32_t *)(VME2_BASE + VME2_T1COUNT)) <
		    (u_int32_t)us)
			;
		*(volatile u_int32_t *)(VME2_BASE + VME2_TCTL) &=
		    ~VME2_TCTL1_CEN;
@


1.5
log
@Added vme bus device drivers. MVME328, MVME376, MVME332
@
text
@d1 1
a1 2
/*	$OpenBSD: clock.c,v 1.4 1998/12/15 05:52:29 smurph Exp $ */

d3 1
d80 1
a80 1
 * Clock driver. Has both interval timer as well as statistics timer.
d84 1
d95 2
a96 1

d98 5
d104 1
a104 1
#include "pcctwo.h"
a105 11

/*
 * Statistics clock interval and variance, in usec.  Variance must be a
 * power of two.  Since this gives us an even number, not an odd number,
 * we discard one case and compensate.  That is, a variance of 4096 would
 * give us offsets in [0..4095].  Instead, we take offsets in [1..4095].
 * This is symmetric about the point 2048, or statvar/2, and thus averages
 * to that value (assuming uniform random numbers).
 */
int statvar = 8192;
int statmin;			/* statclock interval - 1/2*variance */
d112 4
a115 2
/*int		clockintr __P((void *, void *));*/
/*#int		statintr __P((void *, void *));*/
d131 4
a134 2
int	clockintr __P((void *));
int	statintr __P((void *));
d137 1
a137 1
u_char	stat_reset, prof_reset;
d139 1
a139 1
	/*
d142 1
a142 1
	 */
d151 1
a151 2
	if (ca->ca_bustype != BUS_PCCTWO ||
		strcmp(cf->cf_driver->cd_name, "clock")) {
a175 10
	sc->sc_profih.ih_fn = clockintr;
	sc->sc_profih.ih_arg = 0;
	sc->sc_profih.ih_wantframe = 1;
	sc->sc_profih.ih_ipl = ca->ca_ipl;

	sc->sc_statih.ih_fn = statintr;
	sc->sc_statih.ih_arg = 0;
	sc->sc_statih.ih_wantframe = 1;
	sc->sc_statih.ih_ipl = ca->ca_ipl;

d177 26
a202 5
	prof_reset = ca->ca_ipl | PCC2_IRQ_IEN | PCC2_IRQ_ICLR;
	stat_reset = ca->ca_ipl | PCC2_IRQ_IEN | PCC2_IRQ_ICLR;
	pcctwointr_establish(PCC2V_TIMER1, &sc->sc_profih);
	pcctwointr_establish(PCC2V_TIMER2, &sc->sc_statih);

d206 3
a208 22
	/*
 * clockintr: ack intr and call hardclock
	 */
int
clockintr(arg)
	void *arg;
{
	sys_pcc2->pcc2_t1irq = prof_reset;
	hardclock(arg);
#include "bugtty.h"
#if NBUGTTY > 0
	bugtty_chkinput();
#endif /* NBUGTTY */
	timerok = 1;
	return (1);
}

/*
 * Set up real-time clock; we don't have a statistics clock at
 * present.
 */
cpu_initclocks()
d212 3
a219 12
	if (stathz == 0)
		stathz = hz;
	if (1000000 % stathz) {
		printf("cannot get %d Hz statclock; using 100 Hz\n", stathz);
		stathz = 100;
	}
	profhz = stathz;		/* always */

	statint = 1000000 / stathz;
	minint = statint / 2 + 100;
	while (statvar > minint)
		statvar >>= 1;
a228 15
	/* statclock */
	sys_pcc2->pcc2_t2ctl = 0;
	sys_pcc2->pcc2_t2cmp = pcc2_timer_us2lim(statint);
	sys_pcc2->pcc2_t2count = 0;
	sys_pcc2->pcc2_t2ctl = PCC2_TCTL_CEN | PCC2_TCTL_COC |
	    PCC2_TCTL_COVF;
	sys_pcc2->pcc2_t2irq = stat_reset;

	statmin = statint - (statvar >> 1);
}

void
setstatclockrate(newhz)
	int newhz;
{
d231 3
d235 2
a236 2
statintr(cap)
	void *cap;
d238 8
a245 24
	register u_long newint, r, var;

	sys_pcc2->pcc2_t2irq = stat_reset;

	statclock((struct clockframe *)cap);

	/*
	 * Compute new randomized interval.  The intervals are uniformly
	 * distributed on [statint - statvar / 2, statint + statvar / 2],
	 * and therefore have mean statint, giving a stathz frequency clock.
	 */
	var = statvar;
	do {
		r = random() & (var - 1);
	} while (r == 0);
	newint = statmin + r;

	sys_pcc2->pcc2_t2ctl = 0;
	sys_pcc2->pcc2_t2cmp = pcc2_timer_us2lim(newint);
	sys_pcc2->pcc2_t2count = 0;		/* should I? */
	sys_pcc2->pcc2_t2irq = stat_reset;
	sys_pcc2->pcc2_t2ctl = PCC2_TCTL_CEN | PCC2_TCTL_COC;

	return (1);
d247 1
a247 1

d256 2
a257 1
	 * Do not go to the real timer until vme device is present
d259 2
a260 2
	if (sys_vme2 == NULL) {
	    c = 5 * us;
d269 1
a269 1
      ;
d271 34
a304 1
   return (0);	    
d307 4
d312 15
d328 31
@


1.4
log
@Commit for the first real OpenBSD mvme88k port.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.3 1996/04/28 11:06:02 deraadt Exp $ */
d92 1
d96 1
d98 1
d110 1
a110 1
int timerok;
d209 1
d294 1
d299 1
a299 1

d301 2
a302 3
	 * XXX MVME167 doesn't have a 3rd free-running timer,
	 * so we use a stupid loop. Fix the code to watch t1:
	 * the profiling timer.
d304 13
a316 4
	c = 4 * us;
	while (--c > 0)
		;
	return (0);
d318 3
@


1.3
log
@Cleanup after import. This also seems to bring up the current version.
@
text
@d1 1
a1 1
/*	$NetBSD: clock.c,v 1.22 1995/05/29 23:57:15 pk Exp $ */
d4 29
d90 1
d95 1
d113 2
a114 2
int		clockintr __P((void *, void *));
int		statintr __P((void *, void *));
d118 2
a119 1
	volatile struct pcc2reg		*sc_pcc2reg;
d130 5
a134 1
struct intrhand clockintrhand, statintrhand;
d136 8
a143 2
static int
clockmatch(struct device *parent, void *self, void *aux)
d145 2
a146 2
	register struct confargs *ca = aux;
	register struct cfdata *cf = self;
d160 2
a161 1
	ca->ca_size  = 0;
d163 1
a163 1
	return 1;
d166 4
a169 3
/* ARGSUSED */
static void
clockattach(struct device *parent, struct device *self, void *aux)
d171 1
a171 1
	struct confargs *ca = aux;
a172 1
	u_long	elapsedtime;
d174 15
a188 2
	extern void delay(u_long);
	extern int cpuspeed;
a189 19
	/*
	 * save virtual address of the pcc2 block since our
	 * registers are in that block.
	 */
	sc->sc_pcc2reg = (struct pcc2reg *)ca->ca_vaddr;

	/*
	 * calibrate for delay() calls.
	 * We do this by using tick timer1 in free running mode before
	 * cpu_initclocks() is called so turn on clock interrupts etc.
	 * 
	 *	the approach is:
	 *		set count in timer to 0
	 *		call delay(1000) for a 1000 us delay
	 *		after return, stop count and figure out
	 *			how many us went by (call it x)
	 *		now the factor to multiply the arg. passed to
	 *		delay would be (x/1000) rounded up to an int.
	 */
d191 1
a191 10
	sc->sc_pcc2reg->pcc2_t1ctl 	&= ~PCC2_TICTL_CEN;
	sc->sc_pcc2reg->pcc2_psclkadj 	= 256 - cpuspeed;
	sc->sc_pcc2reg->pcc2_t1irq	&= ~PCC2_TTIRQ_IEN;
	sc->sc_pcc2reg->pcc2_t1cntr	= 0;
	sc->sc_pcc2reg->pcc2_t1ctl 	|= PCC2_TICTL_CEN;
	delay(1000);	/* delay for 1 ms */
	sc->sc_pcc2reg->pcc2_t1ctl 	&= ~PCC2_TICTL_CEN;
	elapsedtime = sc->sc_pcc2reg->pcc2_t1cntr;

	delay_factor = (u_long)(elapsedtime / 1000 + 1);
d194 1
a194 3
	 * program clock to interrupt at IPL_CLOCK. Set everything
	 * except compare registers, interrupt enable and counter
	 * enable registers.
d196 11
a206 26
	sc->sc_pcc2reg->pcc2_t1ctl &= ~(PCC2_TICTL_CEN);
	sc->sc_pcc2reg->pcc2_t1cntr= 0;
	sc->sc_pcc2reg->pcc2_t1ctl |= (PCC2_TICTL_COC|PCC2_TICTL_COVF);
	sc->sc_pcc2reg->pcc2_t1irq = (PCC2_TTIRQ_ICLR|IPL_CLOCK);

	sc->sc_pcc2reg->pcc2_t2ctl &= ~(PCC2_TICTL_CEN);
	sc->sc_pcc2reg->pcc2_t2cntr= 0;
	sc->sc_pcc2reg->pcc2_t2ctl |= (PCC2_TICTL_COC|PCC2_TICTL_COVF);
	sc->sc_pcc2reg->pcc2_t2irq = (PCC2_TTIRQ_ICLR|IPL_CLOCK);

	/*
	 * Establish inerrupt handlers.
	 */
	clockintrhand.ih_fn = clockintr;
	clockintrhand.ih_arg = 0; /* don't want anything */
	clockintrhand.ih_ipl = IPL_CLOCK;
	clockintrhand.ih_wantframe = 1;
	intr_establish(PCC2_VECT+9, &clockintrhand);

	statintrhand.ih_fn = statintr;
	statintrhand.ih_arg = 0; /* don't want anything */
	statintrhand.ih_ipl = IPL_CLOCK;
	statintrhand.ih_wantframe = 1;
	intr_establish(PCC2_VECT+8, &statintrhand);

	timerok = 1;
d210 2
a211 6
 * Set up the real-time and statistics clocks.  Leave stathz 0 only if
 * no alternative timer is available. mvme167/mvme187 has 2 tick timers
 * in pcc2 - we are using timer 1 for clock interrupt and timer 2 for
 * statistics.
 *
 * The frequencies of these clocks must be an even number of microseconds.
a215 3
	volatile struct pcc2reg *pcc2reg;

	pcc2reg = ((struct clocksoftc *)clock_cd.cd_devs[0])->sc_pcc2reg;
a233 9
	/*
	 * hz value 100 means we want the clock to interrupt 100
	 * times a sec or 100 times in 1000000 us ie, 1 interrupt
	 * every 10000 us. Program the tick timer compare register
	 * to this value.
	 */
	pcc2reg->pcc2_t1cmp = tick;
	pcc2reg->pcc2_t2cmp = statint;
	statmin = statint - (statvar >> 1);
d235 15
a249 7
	/* start the clocks ticking */
	pcc2reg->pcc2_t1ctl = (PCC2_TICTL_CEN|PCC2_TICTL_COC|PCC2_TICTL_COVF);
	pcc2reg->pcc2_t2ctl = (PCC2_TICTL_CEN|PCC2_TICTL_COC|PCC2_TICTL_COVF);
	/* and enable those interrupts */
	pcc2reg->pcc2_t1irq |= (PCC2_TTIRQ_IEN|PCC2_TTIRQ_ICLR);
	pcc2reg->pcc2_t2irq |= (PCC2_TTIRQ_IEN|PCC2_TTIRQ_ICLR);
}
d251 1
a251 8
/*
 * Dummy setstatclockrate(), since we know profhz==hz.
 */
/* ARGSUSED */
void
setstatclockrate(int newhz)
{
	/* nothing */
a253 3
/*
 * Delay: wait for `about' n microseconds to pass.
 */
d255 2
a256 15
delay(volatile u_long n)
{
	volatile u_long cnt = n * delay_factor;

	while (cnt-- > 0) {
		asm volatile("");
	}
}

/*
 * Clock interrupt handler. Calls hardclock() after setting up a
 * clockframe.
 */
int
clockintr(void *cap, void *frame)
a257 17
	volatile struct pcc2reg *reg;

	reg = ((struct clocksoftc *)clock_cd.cd_devs[0])->sc_pcc2reg;
	
	/* Clear the interrupt */
	reg->pcc2_t1irq = (PCC2_TTIRQ_IEN|PCC2_TTIRQ_ICLR|IPL_CLOCK);
#if 0
	reg->pcc2_t1irq |= PCC2_TTIRQ_ICLR;
#endif /* 0 */

	hardclock((struct clockframe *)frame);
#include "bugtty.h"
#if NBUGTTY > 0
	bugtty_chkinput();
#endif /* NBUGTTY */

	return (1);
a259 3
/*
 * Stat clock interrupt handler.
 */
d261 2
a262 1
statintr(void *cap, void *frame)
a263 1
	volatile struct pcc2reg *reg;
d266 1
a266 7
	reg = ((struct clocksoftc *)clock_cd.cd_devs[0])->sc_pcc2reg;
	
	/* Clear the interrupt */
#if 0
	reg->pcc2_t2irq |= PCC2_TTIRQ_ICLR;
#endif /* 0 */
	reg->pcc2_t2irq = (PCC2_TTIRQ_IEN|PCC2_TTIRQ_ICLR|IPL_CLOCK);
d268 1
a268 1
	statclock((struct clockframe *)frame);
d281 5
a285 9
	/*
	 * reprogram statistics timer to interrupt at
	 * newint us intervals.
	 */
	reg->pcc2_t2ctl = ~(PCC2_TICTL_CEN);
	reg->pcc2_t2cntr = 0;
	reg->pcc2_t2cmp = newint;
	reg->pcc2_t2ctl = (PCC2_TICTL_CEN|PCC2_TICTL_COC|PCC2_TICTL_COVF);
	reg->pcc2_t2irq |= (PCC2_TTIRQ_ICLR|PCC2_TTIRQ_IEN);
d290 2
a291 13
/*
 * Return the best possible estimate of the time in the timeval
 * to which tvp points.  We do this by returning the current time
 * plus the amount of time since the last clock interrupt.
 *
 * Check that this time is no less than any previously-reported time,
 * which could happen around the time of a clock adjustment.  Just for
 * fun, we guarantee that the time will be greater than the value
 * obtained by a previous call.
 */
void
microtime(tvp)
	register struct timeval *tvp;
d293 1
a293 2
	int s;
	static struct timeval lasttime;
d295 9
a303 14
	s = splhigh();
	*tvp = time;
	while (tvp->tv_usec > 1000000) {
		tvp->tv_sec++;
		tvp->tv_usec -= 1000000;
	}
	if (tvp->tv_sec == lasttime.tv_sec &&
	    tvp->tv_usec <= lasttime.tv_usec &&
	    (tvp->tv_usec = lasttime.tv_usec + 1) > 1000000) {
		tvp->tv_sec++;
		tvp->tv_usec -= 1000000;
	}
	lasttime = *tvp;
	splx(s);
@


1.2
log
@This is a remove to get rid of the old mvme88k port which was incomplete
to replace it with a working version. The kernel compiles and works
at least.  The new version will be imported shortly.
@
text
@d1 52
d57 6
a62 3
#include <machine/board.h>
#include <machine/bug.h>
#include <machine/pcctworeg.h>
d64 38
a101 3
extern u_int *pcc_io_base;
extern const u_int timer_reload;
void	setstatclockrate (int hzrate)
d103 7
a109 1
}       
d111 10
a120 2
resettodr()
{
d123 3
a125 2
int
hexdectodec(unsigned char n)
d127 37
d165 31
a195 1
	return(((n>>4)&0x0F)*10 + (n&0x0F));
d198 14
a211 5
#define STARTOFTIME 1970
#define FEBRUARY 2
#define leapyear(year) (((year)%4==0) && ((year)%100) != 0 || ((year)%400) == 0)
#define days_in_year(year) (leapyear((year)) ? 366 : 365)
#define   days_in_month(a)    (month_days[(a) - 1])
d213 12
a224 3
static int month_days[12] = {
     31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
}; 
d226 21
d248 6
a253 1
inittodr(time_t base)
d255 1
a255 30
	struct bugrtc rtc;
	u_long sec, min, hour, day, month, year;
	u_long i, tmp, timebuf;

	/* ignore suggested time, use realtime clock via bug */
	bugrtcrd(&rtc);
	sec	= hexdectodec(rtc.s);
	min	= hexdectodec(rtc.m);
	hour	= hexdectodec(rtc.H);
	day	= hexdectodec(rtc.D);
	month	= hexdectodec(rtc.M);
	year	= hexdectodec(rtc.Y) + 1900;

	tmp = 0;
	for (i = STARTOFTIME; i < year; i++) {
		tmp += days_in_year(i);
	}
	for (i = 1; i < month; i++) {
		tmp += days_in_month(i);
	}
	if (leapyear(year) && month > FEBRUARY) {
		tmp++;
	}
	printf("date yy mm dd hh mm.ss:%02d %02d %02d %02d %02d.%02d:",
		year,month,day,hour,min, sec);
	tmp += (day -1);
	timebuf = (((tmp * 24 + hour) * 60 + min) * 60 + sec);
	printf(" epochsec %d\n",timebuf);
	time.tv_sec = timebuf;
	time.tv_usec = 0;
d258 5
a262 1
clkread()
d264 5
d271 6
a276 1
cpu_initclocks()
d278 6
d285 10
a294 10
	u_int *io_base;
	io_base = 0xfffe1000; /* should really be return of virtmem alloc */
	/*
	io_base = pcc_io_base;
	*/
	/* timer 2 setup */
	PCC_TIMER2_PRE(io_base) = timer_reload;
	PCC_TIMER2_CTR(io_base) = 0x7;
	PCC_TIMER2_ICR(io_base) = 0x8e;
#endif
d298 1
a298 1
 * Clock interrupts.
d301 1
a301 2
clockintr(cap)
	void *cap;
d303 6
d310 3
a312 5
	volatile register unsigned char icr;
	/* clear clock interrupt */
	asm ("ld.b %0,%1" : "=r" (icr) : "" (TIMER2ICR));
	icr |= ICLR;
	asm ("st.b %0,%1" : "=r" (icr) : "" (TIMER2ICR));
d314 22
a335 3
	/* read the limit register to clear the interrupt */
#endif /* 0 */
	hardclock((struct clockframe *)cap);
d338 33
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@initial 88k import; code by nivas and based on mach luna88k
@
text
@@


1.1.1.2
log
@Third try at importing the mvme88k port. This is a working kernel
from nivas.
Userland and compiler still need to be worked on.
Make certain what directory the import is done from.
@
text
@a0 52
/*	$NetBSD: clock.c,v 1.22 1995/05/29 23:57:15 pk Exp $ */

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1995 Nivas Madhur
 * Copyright (c) 1994 Gordon W. Ross
 * Copyright (c) 1993 Adam Glass
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)clock.c	8.1 (Berkeley) 6/11/93
 */

/*
 * Clock driver. Has both interval timer as well as statistics timer.
 */
d5 3
a7 3
#ifdef GPROF
#include <sys/gmon.h>
#endif
d9 5
a13 2
#include <machine/autoconf.h>
#include <machine/cpu.h>
d15 1
a15 38
#include <mvme88k/dev/pcctworeg.h>

/*
 * Statistics clock interval and variance, in usec.  Variance must be a
 * power of two.  Since this gives us an even number, not an odd number,
 * we discard one case and compensate.  That is, a variance of 4096 would
 * give us offsets in [0..4095].  Instead, we take offsets in [1..4095].
 * This is symmetric about the point 2048, or statvar/2, and thus averages
 * to that value (assuming uniform random numbers).
 */
int statvar = 8192;
int statmin;			/* statclock interval - 1/2*variance */
int timerok;

u_long delay_factor = 1;

static int	clockmatch __P((struct device *, void *, void *));
static void	clockattach __P((struct device *, struct device *, void *));
int		clockintr __P((void *, void *));
int		statintr __P((void *, void *));

struct clocksoftc {
	struct device			sc_dev;
	volatile struct pcc2reg		*sc_pcc2reg;
};

struct cfattach clock_ca = {
        sizeof(struct clocksoftc), clockmatch, clockattach
}; 
 
struct cfdriver clock_cd = { 
        NULL, "clock", DV_DULL, 0
}; 

struct intrhand clockintrhand, statintrhand;

static int
clockmatch(struct device *parent, void *self, void *aux)
a16 18
	register struct confargs *ca = aux;
	register struct cfdata *cf = self;

	if (ca->ca_bustype != BUS_PCCTWO ||
		strcmp(cf->cf_driver->cd_name, "clock")) {
		return (0);
	}

	/*
	 * clock has to be at ipl 5
	 * We return the ipl here so that the parent can print
	 * a message if it is different from what ioconf.c says.
	 */
	ca->ca_ipl   = IPL_CLOCK;
	/* set size to 0 - see pcctwo.c:match for details */
	ca->ca_size  = 0;

	return 1;
d19 2
a20 3
/* ARGSUSED */
static void
clockattach(struct device *parent, struct device *self, void *aux)
a21 37
	struct confargs *ca = aux;
	struct clocksoftc *sc = (struct clocksoftc *)self;
	u_long	elapsedtime;

	extern void delay(u_long);
	extern int cpuspeed;

	/*
	 * save virtual address of the pcc2 block since our
	 * registers are in that block.
	 */
	sc->sc_pcc2reg = (struct pcc2reg *)ca->ca_vaddr;

	/*
	 * calibrate for delay() calls.
	 * We do this by using tick timer1 in free running mode before
	 * cpu_initclocks() is called so turn on clock interrupts etc.
	 * 
	 *	the approach is:
	 *		set count in timer to 0
	 *		call delay(1000) for a 1000 us delay
	 *		after return, stop count and figure out
	 *			how many us went by (call it x)
	 *		now the factor to multiply the arg. passed to
	 *		delay would be (x/1000) rounded up to an int.
	 */
	printf("\n");
	sc->sc_pcc2reg->pcc2_t1ctl 	&= ~PCC2_TICTL_CEN;
	sc->sc_pcc2reg->pcc2_psclkadj 	= 256 - cpuspeed;
	sc->sc_pcc2reg->pcc2_t1irq	&= ~PCC2_TTIRQ_IEN;
	sc->sc_pcc2reg->pcc2_t1cntr	= 0;
	sc->sc_pcc2reg->pcc2_t1ctl 	|= PCC2_TICTL_CEN;
	delay(1000);	/* delay for 1 ms */
	sc->sc_pcc2reg->pcc2_t1ctl 	&= ~PCC2_TICTL_CEN;
	elapsedtime = sc->sc_pcc2reg->pcc2_t1cntr;

	delay_factor = (u_long)(elapsedtime / 1000 + 1);
d23 1
a23 31
	/*
	 * program clock to interrupt at IPL_CLOCK. Set everything
	 * except compare registers, interrupt enable and counter
	 * enable registers.
	 */
	sc->sc_pcc2reg->pcc2_t1ctl &= ~(PCC2_TICTL_CEN);
	sc->sc_pcc2reg->pcc2_t1cntr= 0;
	sc->sc_pcc2reg->pcc2_t1ctl |= (PCC2_TICTL_COC|PCC2_TICTL_COVF);
	sc->sc_pcc2reg->pcc2_t1irq = (PCC2_TTIRQ_ICLR|IPL_CLOCK);

	sc->sc_pcc2reg->pcc2_t2ctl &= ~(PCC2_TICTL_CEN);
	sc->sc_pcc2reg->pcc2_t2cntr= 0;
	sc->sc_pcc2reg->pcc2_t2ctl |= (PCC2_TICTL_COC|PCC2_TICTL_COVF);
	sc->sc_pcc2reg->pcc2_t2irq = (PCC2_TTIRQ_ICLR|IPL_CLOCK);

	/*
	 * Establish inerrupt handlers.
	 */
	clockintrhand.ih_fn = clockintr;
	clockintrhand.ih_arg = 0; /* don't want anything */
	clockintrhand.ih_ipl = IPL_CLOCK;
	clockintrhand.ih_wantframe = 1;
	intr_establish(PCC2_VECT+9, &clockintrhand);

	statintrhand.ih_fn = statintr;
	statintrhand.ih_arg = 0; /* don't want anything */
	statintrhand.ih_ipl = IPL_CLOCK;
	statintrhand.ih_wantframe = 1;
	intr_establish(PCC2_VECT+8, &statintrhand);

	timerok = 1;
d26 5
a30 12
/*
 * Set up the real-time and statistics clocks.  Leave stathz 0 only if
 * no alternative timer is available. mvme167/mvme187 has 2 tick timers
 * in pcc2 - we are using timer 1 for clock interrupt and timer 2 for
 * statistics.
 *
 * The frequencies of these clocks must be an even number of microseconds.
 */
cpu_initclocks()
{
	register int statint, minint;
	volatile struct pcc2reg *pcc2reg;
d32 3
a34 1
	pcc2reg = ((struct clocksoftc *)clock_cd.cd_devs[0])->sc_pcc2reg;
a35 34
	if (1000000 % hz) {
		printf("cannot get %d Hz clock; using 100 Hz\n", hz);
		hz = 100;
		tick = 1000000 / hz;
	}
	if (stathz == 0)
		stathz = hz;
	if (1000000 % stathz) {
		printf("cannot get %d Hz statclock; using 100 Hz\n", stathz);
		stathz = 100;
	}
	profhz = stathz;		/* always */

	statint = 1000000 / stathz;
	minint = statint / 2 + 100;
	while (statvar > minint)
		statvar >>= 1;
	/*
	 * hz value 100 means we want the clock to interrupt 100
	 * times a sec or 100 times in 1000000 us ie, 1 interrupt
	 * every 10000 us. Program the tick timer compare register
	 * to this value.
	 */
	pcc2reg->pcc2_t1cmp = tick;
	pcc2reg->pcc2_t2cmp = statint;
	statmin = statint - (statvar >> 1);

	/* start the clocks ticking */
	pcc2reg->pcc2_t1ctl = (PCC2_TICTL_CEN|PCC2_TICTL_COC|PCC2_TICTL_COVF);
	pcc2reg->pcc2_t2ctl = (PCC2_TICTL_CEN|PCC2_TICTL_COC|PCC2_TICTL_COVF);
	/* and enable those interrupts */
	pcc2reg->pcc2_t1irq |= (PCC2_TTIRQ_IEN|PCC2_TTIRQ_ICLR);
	pcc2reg->pcc2_t2irq |= (PCC2_TTIRQ_IEN|PCC2_TTIRQ_ICLR);
}
d37 1
a37 6
/*
 * Dummy setstatclockrate(), since we know profhz==hz.
 */
/* ARGSUSED */
void
setstatclockrate(int newhz)
d39 30
a68 1
	/* nothing */
d71 1
a71 5
/*
 * Delay: wait for `about' n microseconds to pass.
 */
void
delay(volatile u_long n)
a72 5
	volatile u_long cnt = n * delay_factor;

	while (cnt-- > 0) {
		asm volatile("");
	}
d75 1
a75 6
/*
 * Clock interrupt handler. Calls hardclock() after setting up a
 * clockframe.
 */
int
clockintr(void *cap, void *frame)
a76 6
	volatile struct pcc2reg *reg;

	reg = ((struct clocksoftc *)clock_cd.cd_devs[0])->sc_pcc2reg;
	
	/* Clear the interrupt */
	reg->pcc2_t1irq = (PCC2_TTIRQ_IEN|PCC2_TTIRQ_ICLR|IPL_CLOCK);
d78 10
a87 10
	reg->pcc2_t1irq |= PCC2_TTIRQ_ICLR;
#endif /* 0 */

	hardclock((struct clockframe *)frame);
#include "bugtty.h"
#if NBUGTTY > 0
	bugtty_chkinput();
#endif /* NBUGTTY */

	return (1);
d91 1
a91 1
 * Stat clock interrupt handler.
d94 2
a95 1
statintr(void *cap, void *frame)
d97 6
a102 2
	volatile struct pcc2reg *reg;
	register u_long newint, r, var;
d104 1
a104 5
	reg = ((struct clocksoftc *)clock_cd.cd_devs[0])->sc_pcc2reg;
	
	/* Clear the interrupt */
#if 0
	reg->pcc2_t2irq |= PCC2_TTIRQ_ICLR;
d106 1
a106 24
	reg->pcc2_t2irq = (PCC2_TTIRQ_IEN|PCC2_TTIRQ_ICLR|IPL_CLOCK);

	statclock((struct clockframe *)frame);

	/*
	 * Compute new randomized interval.  The intervals are uniformly
	 * distributed on [statint - statvar / 2, statint + statvar / 2],
	 * and therefore have mean statint, giving a stathz frequency clock.
	 */
	var = statvar;
	do {
		r = random() & (var - 1);
	} while (r == 0);
	newint = statmin + r;

	/*
	 * reprogram statistics timer to interrupt at
	 * newint us intervals.
	 */
	reg->pcc2_t2ctl = ~(PCC2_TICTL_CEN);
	reg->pcc2_t2cntr = 0;
	reg->pcc2_t2cmp = newint;
	reg->pcc2_t2ctl = (PCC2_TICTL_CEN|PCC2_TICTL_COC|PCC2_TICTL_COVF);
	reg->pcc2_t2irq |= (PCC2_TTIRQ_ICLR|PCC2_TTIRQ_IEN);
a108 33
}

/*
 * Return the best possible estimate of the time in the timeval
 * to which tvp points.  We do this by returning the current time
 * plus the amount of time since the last clock interrupt.
 *
 * Check that this time is no less than any previously-reported time,
 * which could happen around the time of a clock adjustment.  Just for
 * fun, we guarantee that the time will be greater than the value
 * obtained by a previous call.
 */
void
microtime(tvp)
	register struct timeval *tvp;
{
	int s;
	static struct timeval lasttime;

	s = splhigh();
	*tvp = time;
	while (tvp->tv_usec > 1000000) {
		tvp->tv_sec++;
		tvp->tv_usec -= 1000000;
	}
	if (tvp->tv_sec == lasttime.tv_sec &&
	    tvp->tv_usec <= lasttime.tv_usec &&
	    (tvp->tv_usec = lasttime.tv_usec + 1) > 1000000) {
		tvp->tv_sec++;
		tvp->tv_usec -= 1000000;
	}
	lasttime = *tvp;
	splx(s);
@
