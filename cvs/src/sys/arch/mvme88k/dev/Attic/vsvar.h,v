head	1.22;
access;
symbols
	OPENBSD_5_5:1.21.0.24
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.20
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.18
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.16
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.14
	OPENBSD_5_0:1.21.0.12
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.10
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.8
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.4
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.21.0.6
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.2
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.20.0.4
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.18.0.8
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.6
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.4
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.2
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.17.0.6
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.4
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.5
	UBC:1.4.0.4
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.1.0.8
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.6
	OPENBSD_2_7_BASE:1.1
	SMP:1.1.0.4
	SMP_BASE:1.1
	kame_19991208:1.1
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.22
date	2014.03.18.22.36.36;	author miod;	state dead;
branches;
next	1.21;

1.21
date	2009.02.01.00.44.36;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2008.01.05.00.34.07;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2008.01.01.22.54.28;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2005.12.27.21.38.13;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2004.09.06.06.25.28;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2004.07.30.19.02.06;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2004.07.20.20.32.02;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2004.07.02.14.00.43;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2004.05.22.21.02.38;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2004.05.22.21.00.44;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2004.05.22.19.34.12;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2004.05.21.10.24.42;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2004.05.20.16.42.54;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.26.10.41.43;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2003.10.05.20.27.48;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.02.23.27.52;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.14.01.26.39;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.26.02.37.07;	author miod;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	2001.03.07.01.57.56;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2001.02.01.03.38.16;	author smurph;	state Exp;
branches;
next	1.1;

1.1
date	99.05.29.04.41.44;	author smurph;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2001.04.18.16.11.10;	author niklas;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2001.10.31.03.01.18;	author nate;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2002.03.28.10.36.02;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2003.06.07.11.13.17;	author ho;	state Exp;
branches;
next	1.1.4.5;

1.1.4.5
date	2004.02.19.10.49.06;	author niklas;	state Exp;
branches;
next	1.1.4.6;

1.1.4.6
date	2004.06.05.23.09.49;	author niklas;	state Exp;
branches;
next	;

1.4.4.1
date	2002.06.11.03.37.10;	author art;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: vsvar.h,v 1.21 2009/02/01 00:44:36 miod Exp $	*/
/*
 * Copyright (c) 2004, 2009, Miodrag Vallat.
 * Copyright (c) 1999 Steve Murphree, Jr.
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Van Jacobson of Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#ifndef	_VSVAR_H_
#define	_VSVAR_H_

/*
 * Scatter/gather structures
 *
 * Each s/g element is 8 bytes long; a s/g list is limited to 64
 * entries. To afford larger lists, it is possible to use ``link''
 * entries, which can add up to 64 new entries (and contain link
 * entries themselves, too), by setting the M_ADR_SG_LINK bit in
 * the address modifier field.
 *
 * To keep things simple, this driver will use only use a flat list
 * of up to 64 entries, thereby limiting the maximum transfer to
 * 64 pages (worst case situation).
 */

#define	MAX_SG_ELEMENTS	64

struct vs_sg_entry {
	union {
		uint16_t	bytes;	/* entry byte count */
		struct {
			uint8_t gather;	/* count of linked entries */
			uint8_t reserved;
		} link;
	} count;
	uint16_t	pa_high;	/* 32-bit address field split... */
	uint16_t	pa_low;		/* ... due to alignment */
	uint16_t	addr;		/* address type and modifier */
};

/* largest power of two for the bytes field */
#define	MAX_SG_ELEMENT_SIZE	(1U << 15)

/*
 * Command control block
 */
struct vs_cb {
	struct scsi_xfer	*cb_xs;	/* current command */
	u_int			 cb_q;	/* controller queue it's in */

	bus_dmamap_t		 cb_dmamap;
	bus_size_t		 cb_dmalen;
};

/*
 * Per-channel information
 */
struct vs_channel {
	int			vc_id;		/* host id */
	int			vc_width;	/* number of targets */
	int			vc_type;	/* channel type */
#define	VCT_UNKNOWN			0
#define	VCT_SE				1
#define	VCT_DIFFERENTIAL		2
	struct scsi_link	vc_link;
};

struct vs_softc {
	struct device		 sc_dev;

	bus_space_tag_t		 sc_iot;
	bus_space_handle_t	 sc_ioh;
	bus_dma_tag_t		 sc_dmat;

	int			 sc_bid;	/* board id */
	struct vs_channel	 sc_channel[2];

	struct intrhand		 sc_ih_n;	/* normal interrupt handler */
	int			 sc_nvec;
	struct intrhand		 sc_ih_e;	/* error interrupt handler */
	int			 sc_evec;
	char			 sc_intrname_e[16 + 4];
	int			 sc_ipl;

	u_int			 sc_nwq;	/* number of work queues */
	struct vs_cb		*sc_cb;

	bus_dmamap_t		 sc_sgmap;
	bus_dma_segment_t	 sc_sgseg;
	struct vs_sg_entry	*sc_sgva;
};

/* Access macros */

#define	vs_read(w,o) \
	bus_space_read_##w (sc->sc_iot, sc->sc_ioh, (o))
#define	vs_write(w,o,v) \
	bus_space_write_##w (sc->sc_iot, sc->sc_ioh, (o), (v))
#define	vs_bzero(o,s) \
	bus_space_set_region_2(sc->sc_iot, sc->sc_ioh, (o), 0, (s) / 2)

#define	cib_read(w,o)		vs_read(w, sh_CIB + (o))
#define	cib_write(w,o,v)	vs_write(w, sh_CIB + (o), (v))
#define	crb_read(w,o)		vs_read(w, sh_CRB + (o))
#define	crb_write(w,o,v)	vs_write(w, sh_CRB + (o), (v))
#define	csb_read(w,o)		vs_read(w, sh_CSS + (o))
#define	mce_read(w,o)		vs_read(w, sh_MCE + (o))
#define	mce_write(w,o,v)	vs_write(w, sh_MCE + (o), (v))
#define	mce_iopb_read(w,o)	vs_read(w, sh_MCE_IOPB + (o))
#define	mce_iopb_write(w,o,v)	vs_write(w, sh_MCE_IOPB + (o), (v))
#define	mcsb_read(w,o)		vs_read(w, sh_MCSB + (o))
#define	mcsb_write(w,o,v)	vs_write(w, sh_MCSB + (o), (v))

#define	CRSW		crb_read(2, CRB_CRSW)
#define	CRB_CLR_DONE	crb_write(2, CRB_CRSW, 0)
#define	CRB_CLR_ER	crb_write(2, CRB_CRSW, CRSW & ~M_CRSW_ER)

#define	THAW_REG	mcsb_read(2, MCSB_THAW)
#define	THAW(x) \
	do { \
		mcsb_write(1, MCSB_THAW, (x)); \
		mcsb_write(1, MCSB_THAW + 1, M_THAW_TWQE); \
	} while (0)

#endif /* _M328VAR_H */
@


1.21
log
@Finally switch this driver to bus_dma.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsvar.h,v 1.20 2008/01/05 00:34:07 miod Exp $	*/
@


1.20
log
@For each channel, tell if it is single-ended or differential if we can know
this. Might help before someone sets his disks on fire. Especially with
boards where not all channels are of the same type.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsvar.h,v 1.19 2008/01/01 22:54:28 miod Exp $	*/
d3 1
a3 1
 * Copyright (c) 2004, Miodrag Vallat.
d39 11
a49 4
 * The largest single request will be MAXPHYS bytes which will require
 * at most MAXPHYS/NBPG+1 chain elements to describe, i.e. if none of
 * the buffer pages are physically contiguous (MAXPHYS/NBPG) and the
 * buffer is not page aligned (+1).
a50 2
#define	DMAMAXIO	(MAXPHYS/NBPG+1)
#define	OFF(x)	(u_int16_t)(x)
d52 1
a52 3
/*
 * scatter/gather structures
 */
d54 1
a54 1
typedef struct {
d56 1
a56 2
		unsigned short bytes :16;
#define	MAX_SG_BLOCK_SIZE	(1<<16)
d58 3
a60 3
			unsigned short :8;
			unsigned short gather:8;
		} scatter;
d62 3
a64 23
	u_int16_t addrhi, addrlo;	/* split due to alignment */
	unsigned short link:1;
	unsigned short :3;
	unsigned short transfer_type:2;
#define	SHORT_TRANSFER			0x1
#define	LONG_TRANSFER			0x2
#define	SCATTER_GATTER_LIST_IN_SHORT_IO	0x3
	unsigned short memory_type:2;
#define	NORMAL_TYPE	0x0
#define	BLOCK_MODE	0x1
	unsigned short address_modifier:8;
} sg_list_element_t;

typedef sg_list_element_t * scatter_gather_list_t;

#define	MAX_SG_ELEMENTS	64

struct m328_sg {
	struct m328_sg *up;
	int elements;
	int level;
	struct m328_sg *down[MAX_SG_ELEMENTS];
	sg_list_element_t list[MAX_SG_ELEMENTS];
d67 2
a68 1
typedef struct m328_sg *M328_SG;
d70 3
d74 5
a78 3
	struct scsi_xfer *cb_xs;
	u_int	cb_q;
	M328_SG cb_sg;
d81 3
d95 22
a116 12
	struct device		sc_dev;
	int			sc_bid;		/* board id */
	paddr_t			sc_paddr;
	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
	struct intrhand		sc_ih_e, sc_ih_n;
	char			sc_intrname_e[16 + 4];
	int			sc_ipl;
	int			sc_evec, sc_nvec;
	u_int			sc_nwq;		/* number of work queues */
	struct vs_channel	sc_channel[2];
	struct vs_cb		sc_cb[1 + NUM_WQ];
@


1.19
log
@Match on Cougar boards, and try to drive them like Jaguars on steroids. On
wide Cougars, use one command queue per target and disable lun support, so
that we do not overflow the board's memory; and since we are behaving as
a Jaguar, do not do tagged queuing or synchronous transfer negotiation.

Tested on two MVME328XT-2 (4220 and second revision artwork 4220) narrow
Cougar-I (but wide external connectors), but probes fail with select timeout
so far; I could not get various Motorola BUG to probe devices on these boards
either, so we're even (and maybe both my boards are toast, but I won't bet
money on this).
@
text
@d1 1
a1 1
/*	$OpenBSD: vsvar.h,v 1.18 2005/12/27 21:38:13 miod Exp $	*/
d93 10
d114 1
a114 3
	int			sc_id[2];	/* host id per bus */
	int			sc_width[2];	/* number of targets per bus */
	struct scsi_link	sc_link[2];
@


1.18
log
@Keep an array of command blocks (formerly M328_CMD), one per queue - since
we can't send more commands simultaneously - instead of using MALLOC/FREE
for every scsi command we send.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsvar.h,v 1.17 2004/09/06 06:25:28 miod Exp $	*/
d95 1
d103 3
a105 1
	int			sc_id[2];
d107 1
a107 1
	struct vs_cb		sc_cb[NUM_WQ];
@


1.17
log
@Jumbo pack of fixes:
- do not leak memory when polling;
- bring LUN support back - Motorola documentation says LUNs are not
  supported, but it's a SysV/m88k limitation, not a hardware one.
- honour request timeout while polling (instead of using a fixed value)
- do not program the scsi command length if the hardware knows it from
  the scsi command group (as advised in the manual)
- various minor fixes, especially better error recovery.

tested by nick@@ and I; ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsvar.h,v 1.16 2004/07/30 19:02:06 miod Exp $	*/
d87 5
a91 4
typedef struct {
	struct scsi_xfer *xs;
	M328_SG top_sg_list;
} M328_CMD;
d104 1
@


1.16
log
@Move evcount structures inside struct intrhand, this makes more sense and
gives us more counters in the process.

Also clean up intrhand structures and usage, especially move them to SLISTs.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsvar.h,v 1.15 2004/07/20 20:32:02 miod Exp $	*/
d133 1
a133 1
		mcsb_write(1, MCSB_THAW, (x) << 8); \
@


1.15
log
@Work in progress to support daughterboards. The driver now will attach a
second scsi bus if a SCSI daughterboard is present, and is supposed to know
about this and send scsi commands to the appropriate bus.

Unfortunately probing the second bus does not report any device at the
moment (though you can boot off it), but I can't see the issue at the moment.

Thanks to tdeval@@ for lending a few boards equipped with daughterboards
for testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsvar.h,v 1.14 2004/07/02 14:00:43 miod Exp $	*/
a97 2
	struct evcount		sc_intrcnt_e;
	struct evcount		sc_intrcnt_n;
@


1.14
log
@Switch mvme88k to evcount, but keep maintaining intrcnt[] too for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsvar.h,v 1.13 2004/05/22 21:02:38 miod Exp $	*/
d103 2
a104 2
	int			sc_pid, sc_sid;
	struct scsi_link	sc_link;
@


1.13
log
@Reset the board during probe. As a result, we can now honor the SCSI
controller ID jumpers, instead of reprogramming the board to 7 every time.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsvar.h,v 1.12 2004/05/22 21:00:44 miod Exp $	*/
d98 3
a100 1
	struct evcnt		sc_intrcnt_e, sc_intrcnt_n;
@


1.12
log
@Safer work queue thaw sequence.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsvar.h,v 1.11 2004/05/22 19:34:12 miod Exp $	*/
d101 1
d118 1
@


1.11
log
@Convert to bus_space; but it still uses kvtop()...
@
text
@d1 1
a1 1
/*	$OpenBSD: vsvar.h,v 1.8 2003/12/26 10:41:43 miod Exp $	*/
d129 5
a133 1
#define	THAW(x)		mcsb_write(2, MCSB_THAW, ((x) << 8) | M_THAW_TWQE)
@


1.10
log
@More cleaning, better registers programming, better error messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsvar.h,v 1.9 2004/05/20 16:42:54 miod Exp $ */
d3 1
d35 2
a36 2
#ifndef _VSVAR_H_
#define _VSVAR_H_
d45 1
a45 3
#define  LO(x) (u_short)((unsigned long)x & 0x0000FFFF)
#define  HI(x) (u_short)((unsigned long)x >> 16)
#define  OFF(x) (u_short)((vaddr_t)x - (vaddr_t)sc->sc_vsreg)
d47 3
a49 1
/****************     Scater/Gather Stuff                *******************/
d54 1
a54 1
   #define MAX_SG_BLOCK_SIZE	(1<<16)	/* the size *has* to be always *smaller* */
d57 1
a57 1
			unsigned short gather :8;
d60 11
a70 14
	LONGV           address;
	unsigned short  link :1;
	unsigned short  :3;
	unsigned short  transfer_type :2;
	/* 				0x0 is reserved */
   #define SHORT_TREANSFER 		0x1
   #define LONG_TRANSFER			0x2
   #define SCATTER_GATTER_LIST_IN_SHORT_IO	0x3
	unsigned short  memory_type :2;
   #define NORMAL_TYPE			0x0
   #define BLOCK_MODE			0x1
	/*				0x2 is reserved */
	/*				0x3 is reserved */
	unsigned short  address_modifier :8;
d75 1
a75 1
#define MAX_SG_ELEMENTS 64
d78 4
a81 4
	struct m328_sg  *up;
	int                     elements;
	int                     level;
	struct m328_sg  *down[MAX_SG_ELEMENTS];
d88 2
a89 2
   struct scsi_xfer  *xs;
   M328_SG           top_sg_list;
d92 11
a102 1
/**************** END Scater/Gather Stuff                *******************/
d104 23
a126 12
struct  vs_softc {
	struct  device sc_dev;
	struct  intrhand sc_ih_e;
	struct  intrhand sc_ih_n;
	struct  evcnt sc_intrcnt_e;
	struct  evcnt sc_intrcnt_n;
	u_short  sc_ipl;
	u_short  sc_evec;
	u_short  sc_nvec;
	struct  scsi_link sc_link;	/* proto for sub devices */
	struct   vsreg  *sc_vsreg;
};
d128 2
a129 35
/* sync states */
#define SYNC_START	0	/* no sync handshake started */
#define SYNC_SENT	1	/* we sent sync request, no answer yet */
#define SYNC_DONE	2	/* target accepted our (or inferior) settings,
				   or it rejected the request and we stay async */

#define IOPB_SCSI    0x20
#define IOPB_RESET   0x22
#define IOPB_INIT    0x41
#define IOPB_WQINIT  0x42
#define IOPB_DEV_RESET   0x4D

#define OPT_INTEN    0x0001
#define OPT_INTDIS   0x0000
#define OPT_SG       0x0002
#define OPT_SST      0x0004
#define OPT_SIT      0x0040
#define OPT_READ     0x0000
#define OPT_WRITE    0x0100

#define AM_S32       0x01
#define AM_S16       0x05
#define AM_16        0x0100
#define AM_32        0x0200
#define AM_SHORT     0x0300
#define AM_NORMAL    0x0000
#define AM_BLOCK     0x0400
#define AM_D64BLOCK  0x0C00

#define WQO_AE             0x0001   /* abort enable bit */
#define WQO_FOE            0x0004   /* freeze on error */
#define WQO_PE             0x0008   /* parity enable bit */
#define WQO_ARE            0x0010   /* autosense recovery enable bit */
#define WQO_RFWQ           0x0020   /* report frozen work queue bit */
#define WQO_INIT           0x8000   /* work queue init bit */
@


1.9
log
@General cleanup before attempting to move towards bus_space and bus_dma.
Also fix an arithmetic bug which caused almost no harm by luck.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsvar.h,v 1.8 2003/12/26 10:41:43 miod Exp $ */
a46 1
#define  vs_name(sc)	(sc)->sc_dev.dv_xname
@


1.8
log
@Merge the attachment part and the real work part of the SCSI drivers in
one file per driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsvar.h,v 1.7 2003/10/05 20:27:48 miod Exp $ */
d46 1
a46 1
#define  OFF(x) (u_short)((long)kvtop((vaddr_t)x) - (long)kvtop((vaddr_t)sc->sc_vsreg))
a96 13
struct vs_tinfo {
	int	cmds;		/* #commands processed */
	int	dconns;		/* #disconnects */
	int	touts;		/* #timeouts */
	int	perrs;		/* #parity errors */
	int	senses;		/* #request sense commands sent */
	ushort	lubusy;		/* What local units/subr. are busy? */
	u_char	flags;
	u_char	period;		/* Period suggestion */
	u_char	offset;		/* Offset suggestion */
	int	avail;		/* Is there a device there */
} tinfo_t;

a106 2
	u_long  sc_chnl;		/* channel 0 or 1 for dual bus cards */
	u_long  sc_qhp;			/* Command queue head pointer */
a107 13
#define SSH_NACB 8
	struct vs_tinfo sc_tinfo[SSH_NACB];
	u_char  sc_flags;
	u_char  sc_sien;
	u_char  sc_dien;
	u_char  sc_minsync;
	struct map *hus_map;
	/* one for each target */
	struct syncpar {
		u_char state;
		u_char sxfer;
		u_char sbcl;
	} sc_sync[8];
@


1.7
log
@Kill vm_offset_t and vm_size_t, in favor of the [pv]addr_t and [pv]size_t
typedefs.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsvar.h,v 1.6 2003/06/02 23:27:52 millert Exp $ */
a172 16

void vs_minphys(struct buf *bp);
int vs_scsicmd(struct scsi_xfer *);
/*
 * Scatter/gather functions
 */

M328_SG vs_alloc_scatter_gather(void);
void    vs_dealloc_scatter_gather(M328_SG sg);
void    vs_link_scatter_gather_element(sg_list_element_t *element,
					    vaddr_t phys_add,
					    int len);
void    vs_link_scatter_gather_list(sg_list_element_t *list,
					 vaddr_t phys_add,
					 int elements);
M328_SG vs_build_memory_structure(struct scsi_xfer *xs, M328_IOPB *iopb);
@


1.6
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsvar.h,v 1.5 2002/03/14 01:26:39 millert Exp $ */
d46 1
a46 1
#define  OFF(x) (u_short)((long)kvtop((vm_offset_t)x) - (long)kvtop((vm_offset_t)sc->sc_vsreg))
d65 3
a67 3
   #define SHORT_TREANSFER 		0x1	
   #define LONG_TRANSFER			0x2	
   #define SCATTER_GATTER_LIST_IN_SHORT_IO	0x3	
d69 2
a70 2
   #define NORMAL_TYPE			0x0	
   #define BLOCK_MODE			0x1	
d183 2
a184 2
					    register vm_offset_t phys_add,
					    register int len);
d186 2
a187 2
					 register vm_offset_t phys_add,
					 register int elements);
@


1.5
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: vsvar.h,v 1.4 2001/08/26 02:37:07 miod Exp $ */
d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.4
log
@Add prototypes, fix compilation warnings, random style fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsvar.h,v 1.3 2001/03/07 01:57:56 miod Exp $ */
d178 2
a179 2
void vs_minphys __P((struct buf *bp));
int vs_scsicmd __P((struct scsi_xfer *));
d184 3
a186 3
M328_SG vs_alloc_scatter_gather __P((void));
void    vs_dealloc_scatter_gather __P((M328_SG sg));
void    vs_link_scatter_gather_element __P((sg_list_element_t *element,
d188 2
a189 2
					    register int len));
void    vs_link_scatter_gather_list __P((sg_list_element_t *list,
d191 2
a192 2
					 register int elements));
M328_SG vs_build_memory_structure __P((struct scsi_xfer *xs, M328_IOPB *iopb));
@


1.4.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vsvar.h,v 1.4 2001/08/26 02:37:07 miod Exp $ */
d178 2
a179 2
void vs_minphys(struct buf *bp);
int vs_scsicmd(struct scsi_xfer *);
d184 3
a186 3
M328_SG vs_alloc_scatter_gather(void);
void    vs_dealloc_scatter_gather(M328_SG sg);
void    vs_link_scatter_gather_element(sg_list_element_t *element,
d188 2
a189 2
					    register int len);
void    vs_link_scatter_gather_list(sg_list_element_t *list,
d191 2
a192 2
					 register int elements);
M328_SG vs_build_memory_structure(struct scsi_xfer *xs, M328_IOPB *iopb);
@


1.3
log
@Change siop name to ssh, as per mvme68k, to prevent conflict with the
other siop driver. Change siop-related defines to ssh-related defines
everywhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsvar.h,v 1.2 2001/02/01 03:38:16 smurph Exp $ */
d50 1
a50 1
#define  OFF(x) (u_short)((long)kvtop(x) - (long)kvtop(sc->sc_vsreg))
@


1.2
log
@Major changes to get MVME188 working.  More header and code cleanups.  The
kernel is tested on MVME188A/2P256 and MVME188A/1P64.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsvar.h,v 1.1 1999/05/29 04:41:44 smurph Exp $ */
d127 2
a128 2
#define SIOP_NACB 8
	struct vs_tinfo sc_tinfo[8];
@


1.1
log
@Added vme bus device drivers. MVME328, MVME376, MVME332
@
text
@d1 1
a1 1
/*	$OpenBSD: vsvar.h,v 1.0 1999/05/01 05:52:31 smurph Exp $ */
d51 49
d108 4
a111 4
	u_char  flags;
	u_char  period;		/* Period suggestion */
	u_char  offset;		/* Offset suggestion */
   int   avail;      /* Is there a device there */
d114 6
a119 6
struct	vs_softc {
	struct	device sc_dev;
	struct	intrhand sc_ih_e;
	struct	intrhand sc_ih_n;
	struct	evcnt sc_intrcnt_e;
	struct	evcnt sc_intrcnt_n;
d121 6
a126 6
   u_short  sc_evec;
   u_short  sc_nvec;
	struct	scsi_link sc_link;	/* proto for sub devices */
	u_long	sc_chnl;		         /* channel 0 or 1 for dual bus cards */
	u_long	sc_qhp;		         /* Command queue head pointer */
	struct   vsreg	*sc_vsreg;
d129 3
a131 3
	u_char	sc_flags;
	u_char	sc_sien;
	u_char	sc_dien;
d133 1
a133 1
   struct map *hus_map;
d180 13
@


1.1.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsvar.h,v 1.3 2001/03/07 01:57:56 miod Exp $ */
a50 49
#define  vs_name(sc)	(sc)->sc_dev.dv_xname

/****************     Scater/Gather Stuff                *******************/

typedef struct {
	union {
		unsigned short bytes :16;
   #define MAX_SG_BLOCK_SIZE	(1<<16)	/* the size *has* to be always *smaller* */
		struct {
			unsigned short :8;
			unsigned short gather :8;
		} scatter;
	} count;
	LONGV           address;
	unsigned short  link :1;
	unsigned short  :3;
	unsigned short  transfer_type :2;
	/* 				0x0 is reserved */
   #define SHORT_TREANSFER 		0x1	
   #define LONG_TRANSFER			0x2	
   #define SCATTER_GATTER_LIST_IN_SHORT_IO	0x3	
	unsigned short  memory_type :2;
   #define NORMAL_TYPE			0x0	
   #define BLOCK_MODE			0x1	
	/*				0x2 is reserved */
	/*				0x3 is reserved */
	unsigned short  address_modifier :8;
} sg_list_element_t;

typedef sg_list_element_t * scatter_gather_list_t;

#define MAX_SG_ELEMENTS 64

struct m328_sg {
	struct m328_sg  *up;
	int                     elements;
	int                     level;
	struct m328_sg  *down[MAX_SG_ELEMENTS];
	sg_list_element_t list[MAX_SG_ELEMENTS];
};

typedef struct m328_sg *M328_SG;

typedef struct {
   struct scsi_xfer  *xs;
   M328_SG           top_sg_list;
} M328_CMD;

/**************** END Scater/Gather Stuff                *******************/
d59 4
a62 4
	u_char	flags;
	u_char	period;		/* Period suggestion */
	u_char	offset;		/* Offset suggestion */
	int	avail;		/* Is there a device there */
d65 6
a70 6
struct  vs_softc {
	struct  device sc_dev;
	struct  intrhand sc_ih_e;
	struct  intrhand sc_ih_n;
	struct  evcnt sc_intrcnt_e;
	struct  evcnt sc_intrcnt_n;
d72 11
a82 11
	u_short  sc_evec;
	u_short  sc_nvec;
	struct  scsi_link sc_link;	/* proto for sub devices */
	u_long  sc_chnl;		/* channel 0 or 1 for dual bus cards */
	u_long  sc_qhp;			/* Command queue head pointer */
	struct   vsreg  *sc_vsreg;
#define SSH_NACB 8
	struct vs_tinfo sc_tinfo[SSH_NACB];
	u_char  sc_flags;
	u_char  sc_sien;
	u_char  sc_dien;
d84 1
a84 1
	struct map *hus_map;
a130 13
/*
 * Scatter/gather functions
 */

M328_SG vs_alloc_scatter_gather __P((void));
void    vs_dealloc_scatter_gather __P((M328_SG sg));
void    vs_link_scatter_gather_element __P((sg_list_element_t *element,
					    register vm_offset_t phys_add,
					    register int len));
void    vs_link_scatter_gather_list __P((sg_list_element_t *list,
					 register vm_offset_t phys_add,
					 register int elements));
M328_SG vs_build_memory_structure __P((struct scsi_xfer *xs, M328_IOPB *iopb));
@


1.1.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: vsvar.h,v 1.1.4.1 2001/04/18 16:11:10 niklas Exp $ */
d50 1
a50 1
#define  OFF(x) (u_short)((long)kvtop((vm_offset_t)x) - (long)kvtop((vm_offset_t)sc->sc_vsreg))
@


1.1.4.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d178 2
a179 2
void vs_minphys(struct buf *bp);
int vs_scsicmd(struct scsi_xfer *);
d184 3
a186 3
M328_SG vs_alloc_scatter_gather(void);
void    vs_dealloc_scatter_gather(M328_SG sg);
void    vs_link_scatter_gather_element(sg_list_element_t *element,
d188 2
a189 2
					    register int len);
void    vs_link_scatter_gather_list(sg_list_element_t *list,
d191 2
a192 2
					 register int elements);
M328_SG vs_build_memory_structure(struct scsi_xfer *xs, M328_IOPB *iopb);
@


1.1.4.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vsvar.h,v 1.1.4.3 2002/03/28 10:36:02 niklas Exp $ */
d18 5
a22 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.1.4.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d46 1
a46 1
#define  OFF(x) (u_short)((long)kvtop((vaddr_t)x) - (long)kvtop((vaddr_t)sc->sc_vsreg))
d65 3
a67 3
   #define SHORT_TREANSFER 		0x1
   #define LONG_TRANSFER			0x2
   #define SCATTER_GATTER_LIST_IN_SHORT_IO	0x3
d69 2
a70 2
   #define NORMAL_TYPE			0x0
   #define BLOCK_MODE			0x1
d173 16
@


1.1.4.6
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1
 * Copyright (c) 2004, Miodrag Vallat.
d34 2
a35 2
#ifndef	_VSVAR_H_
#define	_VSVAR_H_
d44 4
a47 1
#define	OFF(x)	(u_int16_t)(x)
d49 1
a49 3
/*
 * scatter/gather structures
 */
d54 1
a54 1
#define	MAX_SG_BLOCK_SIZE	(1<<16)
d57 1
a57 1
			unsigned short gather:8;
d60 14
a73 11
	u_int16_t addrhi, addrlo;	/* split due to alignment */
	unsigned short link:1;
	unsigned short :3;
	unsigned short transfer_type:2;
#define	SHORT_TRANSFER			0x1
#define	LONG_TRANSFER			0x2
#define	SCATTER_GATTER_LIST_IN_SHORT_IO	0x3
	unsigned short memory_type:2;
#define	NORMAL_TYPE	0x0
#define	BLOCK_MODE	0x1
	unsigned short address_modifier:8;
d78 1
a78 1
#define	MAX_SG_ELEMENTS	64
d81 4
a84 4
	struct m328_sg *up;
	int elements;
	int level;
	struct m328_sg *down[MAX_SG_ELEMENTS];
d91 2
a92 2
	struct scsi_xfer *xs;
	M328_SG top_sg_list;
d95 41
a135 11
struct vs_softc {
	struct device		sc_dev;
	paddr_t			sc_paddr;
	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
	struct intrhand		sc_ih_e, sc_ih_n;
	struct evcnt		sc_intrcnt_e, sc_intrcnt_n;
	int			sc_ipl;
	int			sc_evec, sc_nvec;
	int			sc_pid, sc_sid;
	struct scsi_link	sc_link;
d138 35
a172 31
/* Access macros */

#define	vs_read(w,o) \
	bus_space_read_##w (sc->sc_iot, sc->sc_ioh, (o))
#define	vs_write(w,o,v) \
	bus_space_write_##w (sc->sc_iot, sc->sc_ioh, (o), (v))
#define	vs_bzero(o,s) \
	bus_space_set_region_2(sc->sc_iot, sc->sc_ioh, (o), 0, (s) / 2)

#define	cib_read(w,o)		vs_read(w, sh_CIB + (o))
#define	cib_write(w,o,v)	vs_write(w, sh_CIB + (o), (v))
#define	crb_read(w,o)		vs_read(w, sh_CRB + (o))
#define	crb_write(w,o,v)	vs_write(w, sh_CRB + (o), (v))
#define	csb_read(w,o)		vs_read(w, sh_CSS + (o))
#define	mce_read(w,o)		vs_read(w, sh_MCE + (o))
#define	mce_write(w,o,v)	vs_write(w, sh_MCE + (o), (v))
#define	mce_iopb_read(w,o)	vs_read(w, sh_MCE_IOPB + (o))
#define	mce_iopb_write(w,o,v)	vs_write(w, sh_MCE_IOPB + (o), (v))
#define	mcsb_read(w,o)		vs_read(w, sh_MCSB + (o))
#define	mcsb_write(w,o,v)	vs_write(w, sh_MCSB + (o), (v))

#define	CRSW		crb_read(2, CRB_CRSW)
#define	CRB_CLR_DONE	crb_write(2, CRB_CRSW, 0)
#define	CRB_CLR_ER	crb_write(2, CRB_CRSW, CRSW & ~M_CRSW_ER)

#define	THAW_REG	mcsb_read(2, MCSB_THAW)
#define	THAW(x) \
	do { \
		mcsb_write(1, MCSB_THAW, (x) << 8); \
		mcsb_write(1, MCSB_THAW + 1, M_THAW_TWQE); \
	} while (0)
@


