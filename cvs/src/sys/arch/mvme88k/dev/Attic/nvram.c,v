head	1.36;
access;
symbols
	OPENBSD_5_5:1.35.0.6
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.35.0.2
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.33.0.10
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.33.0.8
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.6
	OPENBSD_5_0:1.33.0.4
	OPENBSD_5_0_BASE:1.33
	OPENBSD_4_9:1.33.0.2
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.32.0.6
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.32.0.4
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.30.0.6
	OPENBSD_4_5_BASE:1.30
	OPENBSD_4_4:1.30.0.4
	OPENBSD_4_4_BASE:1.30
	OPENBSD_4_3:1.30.0.2
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.29.0.6
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.29.0.4
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.29.0.2
	OPENBSD_4_0_BASE:1.29
	OPENBSD_3_9:1.25.0.8
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.25.0.6
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.25.0.4
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.25.0.2
	OPENBSD_3_6_BASE:1.25
	SMP_SYNC_A:1.25
	SMP_SYNC_B:1.25
	OPENBSD_3_5:1.23.0.2
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	UBC_SYNC_A:1.19
	OPENBSD_3_3:1.19.0.4
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.19.0.2
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	UBC_SYNC_B:1.19
	UBC:1.16.0.2
	UBC_BASE:1.16
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.6.0.4
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	SMP:1.5.0.4
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.1.1.1.0.8
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.6
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.4
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.2
	OPENBSD_2_1_BASE:1.1.1.1
	mvme88kport:1.1.1.1;
locks; strict;
comment	@ * @;


1.36
date	2014.03.18.22.36.36;	author miod;	state dead;
branches;
next	1.35;

1.35
date	2013.05.18.10.21.50;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2013.05.17.22.38.25;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2010.12.26.15.40.59;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.31;

1.31
date	2009.03.09.19.51.16;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2007.12.20.05.19.38;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2006.06.19.15.13.35;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2006.05.08.14.36.10;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2006.04.27.20.13.42;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2006.04.26.21.14.00;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2004.04.24.19.51.48;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2004.04.15.21.35.59;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2004.01.14.20.50.48;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2003.10.05.20.25.08;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2003.09.28.22.10.41;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.02.07.06.56;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2002.04.28.15.17.09;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.14.01.26.39;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.05.22.11.37;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2001.12.19.07.04.41;	author smurph;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2001.12.16.23.49.46;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2001.12.13.08.55.51;	author smurph;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.06.00.30.38;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.01.12.13.46;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.26.02.37.07;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.14.21.30.34;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.09.05.44.39;	author smurph;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.08.00.03.14;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.04.04.01.59;	author smurph;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.11.02.44.29;	author pjanzen;	state Exp;
branches;
next	1.5;

1.5
date	99.09.27.18.43.24;	author smurph;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	99.04.11.03.26.27;	author smurph;	state Exp;
branches;
next	1.3;

1.3
date	99.01.11.05.11.43;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	98.12.15.05.52.30;	author smurph;	state Exp;
branches;
next	1.1;

1.1
date	97.03.03.19.32.04;	author rahnds;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.03.03.19.32.04;	author rahnds;	state Exp;
branches;
next	;

1.5.4.1
date	2001.04.18.16.10.59;	author niklas;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2001.07.04.10.19.54;	author niklas;	state Exp;
branches;
next	1.5.4.3;

1.5.4.3
date	2001.10.31.03.01.18;	author nate;	state Exp;
branches;
next	1.5.4.4;

1.5.4.4
date	2001.11.13.21.04.14;	author niklas;	state Exp;
branches;
next	1.5.4.5;

1.5.4.5
date	2002.03.06.02.04.44;	author niklas;	state Exp;
branches;
next	1.5.4.6;

1.5.4.6
date	2002.03.28.10.36.02;	author niklas;	state Exp;
branches;
next	1.5.4.7;

1.5.4.7
date	2003.03.27.23.32.18;	author niklas;	state Exp;
branches;
next	1.5.4.8;

1.5.4.8
date	2003.06.07.11.13.16;	author ho;	state Exp;
branches;
next	1.5.4.9;

1.5.4.9
date	2004.02.19.10.49.06;	author niklas;	state Exp;
branches;
next	1.5.4.10;

1.5.4.10
date	2004.06.05.23.09.49;	author niklas;	state Exp;
branches;
next	;

1.16.2.1
date	2002.06.11.03.37.09;	author art;	state Exp;
branches;
next	;


desc
@@


1.36
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: nvram.c,v 1.35 2013/05/18 10:21:50 miod Exp $ */

/*
 * Copyright (c) 1995 Theo de Raadt
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/ioctl.h>
#include <sys/time.h>
#include <sys/uio.h>

#include <machine/autoconf.h>
#include <machine/bugio.h>
#include <machine/conf.h>
#include <machine/cpu.h>
#include <machine/mioctl.h>

#include <uvm/uvm_param.h>

#include <mvme88k/mvme88k/clockvar.h>
#include <mvme88k/dev/memdevs.h>
#include <mvme88k/dev/nvramreg.h>

struct nvramsoftc {
	struct device           sc_dev;
	paddr_t			sc_base;
	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
	bus_addr_t		sc_regs;
	size_t			sc_len;

#ifdef MVME188
	u_int8_t		*sc_nvram;
#endif
};

void    nvramattach(struct device *, struct device *, void *);
int     nvrammatch(struct device *, void *, void *);

struct cfattach nvram_ca = {
	sizeof(struct nvramsoftc), nvrammatch, nvramattach
};

struct cfdriver nvram_cd = {
	NULL, "nvram", DV_DULL
};

time_t	chiptotime(struct clock_ymdhms *);
void	timetochip(struct clock_ymdhms *);
time_t	nvram_inittodr(void);
void	nvram_resettodr(void);

int	nvram188read(struct nvramsoftc *, struct uio *, int);
int	nvram188write(struct nvramsoftc *, struct uio *, int);

int
nvrammatch(parent, vcf, args)
	struct device *parent;
	void *vcf, *args;
{
	struct confargs *ca = args;
	bus_space_handle_t ioh;
	int rc;

	if (bus_space_map(ca->ca_iot, ca->ca_paddr, PAGE_SIZE, 0, &ioh) != 0)
		return (0);
	rc = badaddr((vaddr_t)bus_space_vaddr(ca->ca_iot, ioh), 1) == 0;
	bus_space_unmap(ca->ca_iot, ioh, PAGE_SIZE);
	return (rc);
}

void
nvramattach(parent, self, args)
	struct device *parent, *self;
	void *args;
{
	struct confargs *ca = args;
	struct nvramsoftc *sc = (struct nvramsoftc *)self;
	bus_space_handle_t ioh;
	vsize_t maplen;

	switch (brdtyp) {
#ifdef MVME188
	case BRD_188:
		sc->sc_len = MK48T02_SIZE;
		maplen = sc->sc_len * 4;
		sc->sc_regs = M188_NVRAM_TOD_OFF;
		break;
#endif
	default:
		sc->sc_len = MK48T08_SIZE;
		maplen = sc->sc_len;
		sc->sc_regs = SBC_NVRAM_TOD_OFF;
		break;
	}

	sc->sc_iot = ca->ca_iot;
	sc->sc_base = ca->ca_paddr;

	if (bus_space_map(sc->sc_iot, sc->sc_base, round_page(maplen),
	    BUS_SPACE_MAP_LINEAR, &ioh) != 0) {
		printf(": can't map mem space\n");
		return;
	}

	sc->sc_ioh = ioh;

	printf(": MK48T0%lu\n", sc->sc_len / 1024);

	md_inittodr = nvram_inittodr;
	md_resettodr = nvram_resettodr;
}

time_t
chiptotime(struct clock_ymdhms *c)
{
	c->dt_sec = FROMBCD(c->dt_sec);
	c->dt_min = FROMBCD(c->dt_min);
	c->dt_hour = FROMBCD(c->dt_hour);
	c->dt_day = FROMBCD(c->dt_day);
	c->dt_mon = FROMBCD(c->dt_mon);
	c->dt_year = FROMBCD(c->dt_year) + YEAR0;
	/* XXX 2-digit year => Y2070 problem */
	if (c->dt_year < POSIX_BASE_YEAR)
		c->dt_year += 100;

	return clock_ymdhms_to_secs(c);
}

void
timetochip(struct clock_ymdhms *c)
{
	clock_secs_to_ymdhms(time_second, c);

	c->dt_sec = TOBCD(c->dt_sec);
	c->dt_min = TOBCD(c->dt_min);
	c->dt_hour = TOBCD(c->dt_hour);
	c->dt_day = TOBCD(c->dt_day);
	c->dt_mon = TOBCD(c->dt_mon);
	c->dt_year = TOBCD(c->dt_year % 100);
}

time_t
nvram_inittodr()
{
	struct nvramsoftc *sc = nvram_cd.cd_devs[0];
	struct clock_ymdhms c;

	switch (brdtyp) {
#ifdef MVME188
	case BRD_188:
		bus_space_write_4(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + (CLK_CSR << 2), CLK_READ |
		    bus_space_read_4(sc->sc_iot, sc->sc_ioh,
		      sc->sc_regs + (CLK_CSR << 2)));
		c.dt_sec = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + (CLK_SEC << 2)) & 0xff;
		c.dt_min = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + (CLK_MIN << 2)) & 0xff;
		c.dt_hour = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + (CLK_HOUR << 2)) & 0xff;
		c.dt_day = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + (CLK_DAY << 2)) & 0xff;
		c.dt_mon = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + (CLK_MONTH << 2)) & 0xff;
		c.dt_year = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + (CLK_YEAR << 2)) & 0xff;
		bus_space_write_4(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + (CLK_CSR << 2),
		    bus_space_read_4(sc->sc_iot, sc->sc_ioh,
		      sc->sc_regs + (CLK_CSR << 2)) & ~CLK_READ);
		break;
#endif
	default:
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + CLK_CSR, CLK_READ |
		    bus_space_read_1(sc->sc_iot, sc->sc_ioh,
		      sc->sc_regs + CLK_CSR));
		c.dt_sec = bus_space_read_1(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + CLK_SEC);
		c.dt_min = bus_space_read_1(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + CLK_MIN);
		c.dt_hour = bus_space_read_1(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + CLK_HOUR);
		c.dt_day = bus_space_read_1(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + CLK_DAY);
		c.dt_mon = bus_space_read_1(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + CLK_MONTH);
		c.dt_year = bus_space_read_1(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + CLK_YEAR);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + CLK_CSR,
		    bus_space_read_1(sc->sc_iot, sc->sc_ioh,
		      sc->sc_regs + CLK_CSR) & ~CLK_READ);
	}

	return chiptotime(&c);
}

/*
 * Reset the clock based on the current time.
 * Used when the current clock is preposterous, when the time is changed,
 * and when rebooting.  Do nothing if the time is not yet known, e.g.,
 * when crashing during autoconfig.
 */
void
nvram_resettodr()
{
	struct nvramsoftc *sc = nvram_cd.cd_devs[0];
	struct clock_ymdhms c;

	timetochip(&c);

	switch (brdtyp) {
#ifdef MVME188
	case BRD_188:
		bus_space_write_4(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + (CLK_CSR << 2), CLK_WRITE |
		    bus_space_read_4(sc->sc_iot, sc->sc_ioh,
		      sc->sc_regs + (CLK_CSR << 2)));
		bus_space_write_4(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + (CLK_SEC << 2), c.dt_sec);
		bus_space_write_4(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + (CLK_MIN << 2), c.dt_min);
		bus_space_write_4(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + (CLK_HOUR << 2), c.dt_hour);
		bus_space_write_4(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + (CLK_WDAY << 2), c.dt_wday);
		bus_space_write_4(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + (CLK_DAY << 2), c.dt_day);
		bus_space_write_4(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + (CLK_MONTH << 2), c.dt_mon);
		bus_space_write_4(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + (CLK_YEAR << 2), c.dt_year);
		bus_space_write_4(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + (CLK_CSR << 2),
		    bus_space_read_4(sc->sc_iot, sc->sc_ioh,
		      sc->sc_regs + (CLK_CSR << 2)) & ~CLK_WRITE);
		break;
#endif
	default:
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + CLK_CSR, CLK_WRITE |
		    bus_space_read_1(sc->sc_iot, sc->sc_ioh,
		      sc->sc_regs + CLK_CSR));
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + CLK_SEC, c.dt_sec);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + CLK_MIN, c.dt_min);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + CLK_HOUR, c.dt_hour);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + CLK_WDAY, c.dt_wday);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + CLK_DAY, c.dt_day);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + CLK_MONTH, c.dt_mon);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + CLK_YEAR, c.dt_year);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + CLK_CSR,
		    bus_space_read_1(sc->sc_iot, sc->sc_ioh,
		      sc->sc_regs + CLK_CSR) & ~CLK_WRITE);
		break;
	}
}

/*ARGSUSED*/
int
nvramopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	if (minor(dev) >= nvram_cd.cd_ndevs ||
	    nvram_cd.cd_devs[minor(dev)] == NULL)
		return (ENODEV);

	return (0);
}

/*ARGSUSED*/
int
nvramclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	/*
	 * On MVME188, it might be worth free()ing the NVRAM copy here.
	 */
	return (0);
}

/*ARGSUSED*/
int
nvramioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	int unit = minor(dev);
	struct nvramsoftc *sc = (struct nvramsoftc *) nvram_cd.cd_devs[unit];
	int error = 0;

	switch (cmd) {
	case MIOCGSIZ:
		*(int *)data = sc->sc_len;
		break;
	default:
		error = ENOTTY;
		break;
	}
	return (error);
}

/*ARGSUSED*/
int
nvramread(dev_t dev, struct uio *uio, int flags)
{
	int unit = minor(dev);
	struct nvramsoftc *sc = (struct nvramsoftc *)nvram_cd.cd_devs[unit];

#ifdef MVME188
	if (brdtyp == BRD_188)
		return (nvram188read(sc, uio, flags));
#endif

	return (memdevrw(bus_space_vaddr(sc->sc_iot, sc->sc_ioh),
	    sc->sc_len, uio, flags));
}

/*ARGSUSED*/
int
nvramwrite(dev_t dev, struct uio *uio, int flags)
{
	int unit = minor(dev);
	struct nvramsoftc *sc = (struct nvramsoftc *) nvram_cd.cd_devs[unit];

#ifdef MVME188
	if (brdtyp == BRD_188)
		return (nvram188write(sc, uio, flags));
#endif

	return (memdevrw(bus_space_vaddr(sc->sc_iot, sc->sc_ioh),
	    sc->sc_len, uio, flags));
}

paddr_t
nvrammmap(dev, off, prot)
	dev_t dev;
	off_t off;
	int prot;
{
	int unit = minor(dev);
	struct nvramsoftc *sc = (struct nvramsoftc *) nvram_cd.cd_devs[unit];

	if (minor(dev) != 0)
		return (-1);

#ifdef MVME188
	/* disallow mmap on MVME188 due to non-linear layout */
	if (brdtyp == BRD_188)
		return (-1);
#endif

	/* allow access only in RAM */
	if (off < 0 || off >= round_page(sc->sc_len))
		return (-1);
	return (sc->sc_base + off);
}

#ifdef MVME188

int	read_nvram(struct nvramsoftc *);

/*
 * Build a local copy of the NVRAM contents.
 */
int
read_nvram(struct nvramsoftc *sc)
{
	size_t cnt;
	u_int8_t *dest;
	u_int32_t *src;

	if (sc->sc_nvram == NULL) {
		sc->sc_nvram = (u_int8_t *)malloc(sc->sc_len, M_DEVBUF, 
		    M_WAITOK | M_CANFAIL);
		if (sc->sc_nvram == NULL)
			return (EAGAIN);
	}

	dest = sc->sc_nvram;
	src = (u_int32_t *)bus_space_vaddr(sc->sc_iot, sc->sc_ioh);
	cnt = sc->sc_len;
	while (cnt-- != 0)
		*dest++ = (u_int8_t)*src++;

	return (0);
}

/*
 * Specific memdevrw wrappers to cope with the 188 design.
 */

int
nvram188read(struct nvramsoftc *sc, struct uio *uio, int flags)
{
	int rc;

	/*
	 * Get a copy of the NVRAM contents.
	 */
	rc = read_nvram(sc);
	if (rc != 0)
		return (rc);

	/*
	 * Move data from our NVRAM copy to the user.
	 */
	return (memdevrw(sc->sc_nvram, sc->sc_len, uio, flags));
}

int
nvram188write(struct nvramsoftc *sc, struct uio *uio, int flags)
{
	size_t cnt;
	u_int8_t *src;
	u_int32_t *dest;
	int rc;

	/*
	 * Get a copy of the NVRAM contents.
	 */
	rc = read_nvram(sc);
	if (rc != 0)
		return (rc);

	/*
	 * Move data from the user to our NVRAM copy.
	 */
	rc = memdevrw(sc->sc_nvram, sc->sc_len, uio, flags);
	if (rc != 0) {
		/* reset NVRAM copy contents */
		read_nvram(sc);
		return (rc);
	}

	/*
	 * Update the NVRAM. This could be optimized by only working on
	 * the areas which have been modified by the user.
	 */
	src = sc->sc_nvram;
	dest = (u_int32_t *)bus_space_vaddr(sc->sc_iot, sc->sc_ioh);
	cnt = sc->sc_len;
	while (cnt-- != 0) {
		if ((*dest & 0xff) != *src)
			*dest = (u_int32_t)*src;
		dest++;
		src++;
	}

	return (0);
}
#endif
@


1.35
log
@Missing bits intended to go with the previous commit but lost in diff splitting:
Split inittodr/resettodr code from actual tod routines, to allow for
multiple tod routines in the near future.

Use the mi clock_ymdhms_to_secs and clock_secs_to_ymdhms routines.
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.34 2013/05/17 22:38:25 miod Exp $ */
@


1.34
log
@Split inittodr/resettodr code from actual tod routines, to allow for
multiple tod routines in the near future.

Use the mi clock_ymdhms_to_secs and clock_secs_to_ymdhms routines.
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.33 2010/12/26 15:40:59 miod Exp $ */
d135 3
d140 2
a141 19
/*
 * BCD to decimal and decimal to BCD.
 */
#define	FROMBCD(x)	(((x) >> 4) * 10 + ((x) & 0xf))
#define	TOBCD(x)	(((x) / 10 * 16) + ((x) % 10))

#define	SECYR		(SECDAY * 365)
#define	LEAPYEAR(y)	(((y) & 3) == 0)

/*
 * This code is defunct after 2068.
 * Will Unix still be here then??
 */
const int dayyr[12] =
{ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 };

u_long
chiptotime(sec, min, hour, day, mon, year)
	int sec, min, hour, day, mon, year;
d143 9
a151 28
	int days, yr;

	sec = FROMBCD(sec);
	min = FROMBCD(min);
	hour = FROMBCD(hour);
	day = FROMBCD(day);
	mon = FROMBCD(mon);
	year = FROMBCD(year) + YEAR0;

	/* simple sanity checks */
	if (year>164 || mon<1 || mon>12 || day<1 || day>31)
		return (0);
	yr = 70;
	days = 0;

	if (year < 70) {		/* 2000 <= year */
		for (; yr < 100; yr++)	/* deal with first 30 years */
			days += LEAPYEAR(yr) ? 366 : 365;
		yr = 0;
	}

	for (; yr < year; yr++)		/* deal with years left */
		days += LEAPYEAR(yr) ? 366 : 365;

	days += dayyr[mon - 1] + day - 1;

	if (LEAPYEAR(yr) && mon > 2)
		days++;
d153 1
a153 2
	/* now have days since Jan 1, 1970; the rest is easy... */
	return (days * SECDAY + hour * 3600 + min * 60 + sec);
a155 12
struct chiptime {
	int     sec;
	int     min;
	int     hour;
	int     wday;
	int     day;
	int     mon;
	int     year;
};

void timetochip(struct chiptime *c);

d157 1
a157 2
timetochip(c)
	struct chiptime *c;
d159 1
a159 17
	time_t t, t2, t3, now = time_second;

	/* January 1 1970 was a Thursday (4 in unix wdays) */
	/* compute the days since the epoch */
	t2 = now / SECDAY;

	t3 = (t2 + 4) % 7;	/* day of week */
	c->wday = TOBCD(t3 + 1);

	/* compute the year */
	t = 69;
	while (t2 >= 0) {	/* whittle off years */
		t3 = t2;
		t++;
		t2 -= LEAPYEAR(t) ? 366 : 365;
	}
	c->year = t;
d161 6
a166 25
	/* t3 = month + day; separate */
	t = LEAPYEAR(t);
	for (t2 = 1; t2 < 12; t2++)
		if (t3 < (dayyr[t2] + ((t && (t2 > 1)) ? 1:0)))
			break;

	/* t2 is month */
	c->mon = t2;
	c->day = t3 - dayyr[t2 - 1] + 1;
	if (t && t2 > 2)
		c->day--;

	/* the rest is easy */
	t = now % SECDAY;
	c->hour = t / 3600;
	t %= 3600;
	c->min = t / 60;
	c->sec = t % 60;

	c->sec = TOBCD(c->sec);
	c->min = TOBCD(c->min);
	c->hour = TOBCD(c->hour);
	c->day = TOBCD(c->day);
	c->mon = TOBCD(c->mon);
	c->year = TOBCD((c->year - YEAR0) % 100);
d169 2
a170 6
/*
 * Set up the system's time, given a `reasonable' time value.
 */

void
inittodr(time_t base)
d172 2
a173 18
	struct nvramsoftc *sc = (struct nvramsoftc *) nvram_cd.cd_devs[0];
	int sec, min, hour, day, mon, year;
	int badbase = 0, waszero = base == 0;
	struct timespec ts;

	ts.tv_sec = ts.tv_nsec = 0;

	if (base < 35 * SECYR) {
		/*
		 * If base is 0, assume filesystem time is just unknown
		 * in stead of preposterous. Don't bark.
		 */
		if (base != 0)
			printf("WARNING: preposterous time in file system\n");
		/* not going to use it anyway, if the chip is readable */
		base = 39 * SECYR;
		badbase = 1;
	}
d175 3
a177 1
	if (brdtyp == BRD_188) {
d182 1
a182 1
		sec = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
d184 1
a184 1
		min = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
d186 1
a186 1
		hour = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
d188 1
a188 1
		day = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
d190 1
a190 1
		mon = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
d192 1
a192 1
		year = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
d198 3
a200 1
	} else {
d205 1
a205 1
		sec = bus_space_read_1(sc->sc_iot, sc->sc_ioh,
d207 1
a207 1
		min = bus_space_read_1(sc->sc_iot, sc->sc_ioh,
d209 1
a209 1
		hour = bus_space_read_1(sc->sc_iot, sc->sc_ioh,
d211 1
a211 1
		day = bus_space_read_1(sc->sc_iot, sc->sc_ioh,
d213 1
a213 1
		mon = bus_space_read_1(sc->sc_iot, sc->sc_ioh,
d215 1
a215 1
		year = bus_space_read_1(sc->sc_iot, sc->sc_ioh,
@


1.33
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.32 2009/03/29 21:53:52 sthen Exp $ */
d35 1
a36 1
#include <sys/timetc.h>
a42 2
#include <machine/psl.h>
#include <machine/vmparam.h>
d46 1
a48 1
#include <mvme88k/dev/pcctworeg.h>
d74 5
a78 1
u_long	chiptotime(int, int, int, int, int, int);
d134 1
a134 1
	printf(": MK48T0%d\n", sc->sc_len / 1024);
d321 1
a321 27
	if ((ts.tv_sec = chiptotime(sec, min, hour, day, mon, year)) == 0) {
		printf("WARNING: bad date in nvram");
#ifdef DEBUG
		printf("\nday = %d, mon = %d, year = %d, hour = %d, min = %d, sec = %d",
		       FROMBCD(day), FROMBCD(mon), FROMBCD(year) + YEAR0,
		       FROMBCD(hour), FROMBCD(min), FROMBCD(sec));
#endif
		/*
		 * Believe the time in the file system for lack of
		 * anything better, resetting the clock.
		 */
		ts.tv_sec = base;
		if (!badbase)
			resettodr();
	} else {
		int deltat = ts.tv_sec - base;

		if (deltat < 0)
			deltat = -deltat;
		if (waszero || deltat < 2 * SECDAY)
			goto done;
		printf("WARNING: clock %s %d days",
		       ts.tv_sec < base ? "lost" : "gained", deltat / SECDAY);
	}
	printf(" -- CHECK AND RESET THE DATE!\n");
done:
	tc_setclock(&ts);
d331 1
a331 1
resettodr()
d333 2
a334 2
	struct nvramsoftc *sc = (struct nvramsoftc *) nvram_cd.cd_devs[0];
	struct chiptime c;
a335 2
	if (time_second == 0 || sc == NULL)
		return;
d338 3
a340 1
	if (brdtyp == BRD_188) {
d346 1
a346 1
		    sc->sc_regs + (CLK_SEC << 2), c.sec);
d348 1
a348 1
		    sc->sc_regs + (CLK_MIN << 2), c.min);
d350 1
a350 1
		    sc->sc_regs + (CLK_HOUR << 2), c.hour);
d352 1
a352 1
		    sc->sc_regs + (CLK_WDAY << 2), c.wday);
d354 1
a354 1
		    sc->sc_regs + (CLK_DAY << 2), c.day);
d356 1
a356 1
		    sc->sc_regs + (CLK_MONTH << 2), c.mon);
d358 1
a358 1
		    sc->sc_regs + (CLK_YEAR << 2), c.year);
d363 3
a365 1
	} else {
d371 1
a371 1
		    sc->sc_regs + CLK_SEC, c.sec);
d373 1
a373 1
		    sc->sc_regs + CLK_MIN, c.min);
d375 1
a375 1
		    sc->sc_regs + CLK_HOUR, c.hour);
d377 1
a377 1
		    sc->sc_regs + CLK_WDAY, c.wday);
d379 1
a379 1
		    sc->sc_regs + CLK_DAY, c.day);
d381 1
a381 1
		    sc->sc_regs + CLK_MONTH, c.mon);
d383 1
a383 1
		    sc->sc_regs + CLK_YEAR, c.year);
d388 1
d509 1
a509 1
	u_int cnt;
d554 1
a554 1
	u_int cnt;
@


1.32
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.31 2009/03/09 19:51:16 miod Exp $ */
d517 1
a517 1
	return (atop(sc->sc_base + off));
@


1.31
log
@Switch mvme88k to timecounters.
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.30 2007/12/20 05:19:38 miod Exp $ */
d126 1
a126 1
		printf(": can't map memory!\n");
@


1.30
log
@Stricter range checks in mmap function.
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.29 2006/06/19 15:13:35 deraadt Exp $ */
d36 1
a135 32
 * Return the best possible estimate of the time in the timeval
 * to which tvp points.  We do this by returning the current time
 * plus the amount of time since the last clock interrupt (clock.c:clkread).
 *
 * Check that this time is no less than any previously-reported time,
 * which could happen around the time of a clock adjustment.  Just for fun,
 * we guarantee that the time will be greater than the value obtained by a
 * previous call.
 */
void
microtime(tvp)
	struct timeval *tvp;
{
	int s = splhigh();
	static struct timeval lasttime;

	*tvp = time;
	while (tvp->tv_usec >= 1000000) {
		tvp->tv_sec++;
		tvp->tv_usec -= 1000000;
	}
	if (tvp->tv_sec == lasttime.tv_sec &&
	    tvp->tv_usec <= lasttime.tv_usec &&
	    (tvp->tv_usec = lasttime.tv_usec + 1) >= 1000000) {
		tvp->tv_sec++;
		tvp->tv_usec -= 1000000;
	}
	lasttime = *tvp;
	splx(s);
}

/*
d204 1
a204 1
	int t, t2, t3, now = time.tv_sec;
d254 1
a254 2
inittodr(base)
	time_t base;
d259 3
d271 1
a271 1
		base = 36 * SECYR + 109 * SECDAY + 22 * 3600;
d319 1
a319 1
	if ((time.tv_sec = chiptotime(sec, min, hour, day, mon, year)) == 0) {
d330 1
a330 1
		time.tv_sec = base;
d334 1
a334 1
		int deltat = time.tv_sec - base;
d339 1
a339 1
			return;
d341 1
a341 1
		       time.tv_sec < base ? "lost" : "gained", deltat / SECDAY);
d344 2
d360 1
a360 1
	if (!time.tv_sec || sc == NULL)
@


1.29
log
@move clock_subr.c to a better place, and now it is always in the kernel
so that things can use it; tested on all architectures; ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.28 2006/05/08 14:36:10 miod Exp $ */
d542 1
a542 1
	if (off < 0 || off > sc->sc_len)
@


1.28
log
@Replace gazillions of badvaddr() or badwordaddr() calls with badaddr() calls.
With a few prototype declarations shuffling, this finally allows
<machine/locore.h> to die.
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.27 2006/04/27 20:13:42 miod Exp $ */
a171 1
#define	SECDAY		(24 * 60 * 60)
@


1.27
log
@Manage a local copy of the MVME188 nvram and update the real data when
necessary; allow opening /dev/nvram0 on MVME188 again (but no mmap).
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.26 2006/04/26 21:14:00 miod Exp $ */
d90 1
a90 1
	rc = badvaddr((vaddr_t)bus_space_vaddr(ca->ca_iot, ioh), 1) == 0;
@


1.26
log
@On MVME188, the 2KB nvram is non contiguous; each byte is mapped into a
32 bit int. So map the right size, and fail open() until the uiomove() wrapper
is modified to cope with this.
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.25 2004/04/24 19:51:48 miod Exp $ */
a27 5
/*
 * 8/22/2000 BH Cleaned up year 2000 problems with calendar hardware.
 * This code will break again in 2068 or so - come dance on my grave.
 */

a29 1
#include <sys/ioctl.h>
d31 1
d33 2
a35 1
#include <sys/malloc.h>
d58 4
d75 3
a77 1
u_long chiptotime(int, int, int, int, int, int);
d105 3
a107 1
	if (brdtyp == BRD_188) {
d111 3
a113 1
	} else {
d117 1
d124 1
a124 1
	    0, &ioh) != 0) {
d180 2
a181 2
const short dayyr[12] =
{ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};
d293 1
a293 1
	if (base < 5 * SECYR) {
d301 1
a301 1
		base = 21*SECYR + 186*SECDAY + SECDAY/2;
a451 6
#ifdef MVME188
	/* for now, do not allow userland to access the nvram on 188. */
	if (brdtyp == BRD_188)
		return (ENXIO);
#endif

d462 3
d494 17
a510 4
nvramrw(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
d515 5
d536 6
d547 95
@


1.25
log
@Preliminary switch to an mvme88k bus_space world. Not all drivers have been
converted yet, and they rely upon some linear mappings provided by bus_space.

In order to not impact performance, almost all the bus_space accesses go
through macros and inline functions. This currently restricts us to D16 and
D32 access modes, which are selected at compilation time. Since there are no
plans to support D8 vme devices in the future, this is acceptable for now.

This makes the "len" locator for vme devices go away, and allows to simplify
some code which was using the pcctwo device, and will now directly access
hardware which is known to exist, rather than wait until the device is
attached.

While there, try to enforce more interrupt vector number checks, since these
changes pointed out that dart(4) had been working correctly so far by sheer
luck only.
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.24 2004/04/15 21:35:59 miod Exp $ */
a81 1
#if 0
a84 2
#endif
	struct mvmeprom_time rtc;
a85 2
	bugrtcrd(&rtc);
#if 0
d88 1
a88 7
	if (badvaddr(bus_space_vaddr(ca->ca_iot, ioh), 1)) {
#ifdef DEBUG
		printf("==> nvram: address 0x%x failed check\n", ca->ca_paddr);
#endif
		rc = 0;
	} else
		rc = 1;
d90 1
a90 4
	return rc;
#else
	return 1;
#endif
d101 1
d105 1
d109 1
d116 1
a116 1
	if (bus_space_map(sc->sc_iot, sc->sc_base, round_page(sc->sc_len),
d444 7
a501 5
/*
 * If the NVRAM is of the 2K variety, an extra 2K of who-knows-what
 * will also be mmap'd, due to PAGE_SIZE being 4K. Usually, the NVRAM
 * repeats, so userland gets two copies back-to-back.
 */
@


1.24
log
@Since *ramread and *ramwrite are the same code, really, factorize them a la
memread/memwrite.
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.23 2004/01/14 20:50:48 miod Exp $ */
d57 5
a61 4
	void *      sc_paddr;
	void *      sc_vaddr;
	int         sc_len;
	void *      sc_regs;
d83 3
a85 1
	int ret;
a86 1
	struct confargs *ca = args;
a87 3
	ca->ca_vaddr = ca->ca_paddr;   /* map 1:1 */
/*X*/	if (ca->ca_vaddr == (void *)-1)
/*X*/		return (1);
d89 1
d91 1
a91 3
	bugrtcrd(&rtc);
	if (badvaddr(IIOV(ca->ca_vaddr), 1)) {
		printf("==> nvram: address 0x%x failed check\n", ca->ca_vaddr);
d93 5
d99 3
a101 1
		return (1);
d103 1
a103 2
	bugrtcrd(&rtc);
	return (1);
d113 2
a114 4
	struct nvramsoftc       *sc = (struct nvramsoftc *)self;

	sc->sc_paddr = ca->ca_paddr;
	sc->sc_vaddr = ca->ca_vaddr;
d118 1
d121 1
d124 7
a130 11
/*X*/	if (sc->sc_vaddr == (void *)-1)
/*X*/		sc->sc_vaddr = mapiodev((void *)sc->sc_paddr,
/*X*/		max(sc->sc_len, NBPG));
/*X*/	if (sc->sc_vaddr == NULL)
/*X*/		panic("failed to map!");

	if (brdtyp != BRD_188) {
		sc->sc_regs = (void *)(sc->sc_vaddr + sc->sc_len -
				       sizeof(struct clockreg));
	} else {
		sc->sc_regs = (void *)(sc->sc_vaddr + M188_NVRAM_TOD_OFF);
d133 3
a135 1
	printf(": MK48T0%d len %d\n", sc->sc_len / 1024, sc->sc_len);
d308 43
a350 20
	if (brdtyp != BRD_188) {
		struct clockreg *cl = (struct clockreg *)sc->sc_regs;
		cl->cl_csr |= CLK_READ;		/* enable read (stop time) */
		sec = cl->cl_sec;
		min = cl->cl_min;
		hour = cl->cl_hour;
		day = cl->cl_mday;
		mon = cl->cl_month;
		year = cl->cl_year;
		cl->cl_csr &= ~CLK_READ;	/* time wears on... */
	} else { /* CPU_188 */
		struct m188_clockreg *cl = (struct m188_clockreg *)sc->sc_regs;
		cl->cl_csr |= CLK_READ;		/* enable read (stop time) */
		sec = cl->cl_sec & 0xff;
		min = cl->cl_min & 0xff;
		hour = cl->cl_hour & 0xff;
		day = cl->cl_mday & 0xff;
		mon = cl->cl_month & 0xff;
		year = cl->cl_year & 0xff;
		cl->cl_csr &= ~CLK_READ;	/* time wears on... */
d352 1
a390 2
	if (brdtyp != BRD_188) {
		struct clockreg *cl = (struct clockreg *)sc->sc_regs;
d392 3
a394 14
		if (!time.tv_sec || cl == NULL)
			return;
		timetochip(&c);
		cl->cl_csr |= CLK_WRITE;	/* enable write */
		cl->cl_sec = c.sec;
		cl->cl_min = c.min;
		cl->cl_hour = c.hour;
		cl->cl_wday = c.wday;
		cl->cl_mday = c.day;
		cl->cl_month = c.mon;
		cl->cl_year = c.year;
		cl->cl_csr &= ~CLK_WRITE;	/* load them up */
	} else { /* CPU_188 */
		struct m188_clockreg *cl = (struct m188_clockreg *)sc->sc_regs;
d396 46
a441 12
		if (!time.tv_sec || cl == NULL)
			return;
		timetochip(&c);
		cl->cl_csr |= CLK_WRITE;	/* enable write */
		cl->cl_sec = c.sec;
		cl->cl_min = c.min;
		cl->cl_hour = c.hour;
		cl->cl_wday = c.wday;
		cl->cl_mday = c.day;
		cl->cl_month = c.mon;
		cl->cl_year = c.year;
		cl->cl_csr &= ~CLK_WRITE;	/* load them up */
d502 2
a503 1
	return (memdevrw(sc->sc_vaddr, sc->sc_len, uio, flags));
d508 1
a508 1
 * will also be mmap'd, due to NBPG being 4K. On the MVME147 the NVRAM
d526 1
a526 1
	return (atop(sc->sc_paddr + off));
@


1.23
log
@Do not fill more than the first three fields of cfdriver structures unless
necessary. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.22 2003/10/05 20:25:08 miod Exp $ */
d447 1
a447 14
nvramread(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{
	int unit = minor(dev);
	struct nvramsoftc *sc = (struct nvramsoftc *) nvram_cd.cd_devs[unit];

	return (memdevrw(sc->sc_vaddr, sc->sc_len, uio, flags));
}

/*ARGSUSED*/
int
nvramwrite(dev, uio, flags)
d476 1
a476 1
	if (off > sc->sc_len)
@


1.22
log
@De-register
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.21 2003/09/28 22:10:41 miod Exp $ */
d71 1
a71 1
	NULL, "nvram", DV_DULL, 0
@


1.21
log
@Be less verbose, unless option DEBUG, when the nvram battery is toast.
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.20 2003/06/02 07:06:56 deraadt Exp $ */
d5 1
a5 1
 * 
d28 1
a28 1
/* 
d66 1
a66 1
struct cfattach nvram_ca = { 
d68 1
a68 1
}; 
d148 1
a148 1
	register struct timeval *tvp;
d187 1
a187 1
	register int sec, min, hour, day, mon, year;
d189 1
a189 1
	register int days, yr;
d236 1
a236 1
	register struct chiptime *c;
d238 1
a238 1
	register int t, t2, t3, now = time.tv_sec;
d287 1
a287 1
void 
d307 1
a307 1
		register struct clockreg *cl = (struct clockreg *)sc->sc_regs;
d317 1
a317 1
		register struct m188_clockreg *cl = (struct m188_clockreg *)sc->sc_regs;
d366 1
a366 1
		register struct clockreg *cl = (struct clockreg *)sc->sc_regs;
d381 1
a381 1
		register struct m188_clockreg *cl = (struct m188_clockreg *)sc->sc_regs;
@


1.20
log
@licence cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.19 2002/04/28 15:17:09 miod Exp $ */
d328 3
a330 2
		printf("WARNING: bad date in nvram\n");
		printf("day = %d, mon = %d, year = %d, hour = %d, min = %d, sec = %d",
d333 1
@


1.19
log
@Use the prototypes defined via cdev_decl() macros, instead of rolling our
own; thus fix a lot of foo_open(), foo_close() and foo_ioctl() prototypes
in the process.
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.18 2002/03/14 01:26:39 millert Exp $ */
a13 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Theo de Raadt for Willowglen Singapore.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.18
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.17 2002/03/05 22:11:37 miod Exp $ */
a46 1
#include <machine/psl.h>
d49 1
d52 1
a79 8
int nvramopen(dev_t dev, int flag, int mode);
int nvramclose(dev_t dev, int flag, int mode);
int nvramioctl(dev_t dev, int cmd, caddr_t data, int flag,
    struct proc *p);
int nvramread(dev_t dev, struct uio *uio, int flags);
int nvramwrite(dev_t dev, struct uio *uio, int flags);
paddr_t nvrammmap(dev_t dev, off_t off, int prot);

d364 2
a365 1
void resettodr()
d404 1
a404 1
nvramopen(dev, flag, mode)
d407 1
d417 1
a417 1
nvramclose(dev, flag, mode)
d420 1
d429 1
a429 1
	int cmd;
@


1.17
log
@Kill prom stuff duplicates from bugio.[ch].
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.16 2001/12/19 07:04:41 smurph Exp $ */
d68 2
a69 2
void    nvramattach     __P((struct device *, struct device *, void *));
int     nvrammatch __P((struct device *, void *, void *));
d79 7
a85 7
int nvramopen __P((dev_t dev, int flag, int mode));
int nvramclose __P((dev_t dev, int flag, int mode));
int nvramioctl __P((dev_t dev, int cmd, caddr_t data, int flag,
    struct proc *p));
int nvramread __P((dev_t dev, struct uio *uio, int flags));
int nvramwrite __P((dev_t dev, struct uio *uio, int flags));
paddr_t nvrammmap __P((dev_t dev, off_t off, int prot));
d87 1
a87 1
u_long chiptotime __P((int, int, int, int, int, int));
d245 1
a245 1
void timetochip __P((struct chiptime *c));
@


1.16
log
@Introduce brdtyp and change what cputyp means.
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.15 2001/12/16 23:49:46 miod Exp $ */
d98 1
a98 1
	struct bugrtc rtc;
@


1.16.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.16 2001/12/19 07:04:41 smurph Exp $ */
d47 1
a49 1
#include <machine/conf.h>
a51 1
#include <machine/psl.h>
d68 2
a69 2
void    nvramattach(struct device *, struct device *, void *);
int     nvrammatch(struct device *, void *, void *);
d79 9
a87 1
u_long chiptotime(int, int, int, int, int, int);
d98 1
a98 1
	struct mvmeprom_time rtc;
d245 1
a245 1
void timetochip(struct chiptime *c);
d371 1
a371 2
void
resettodr()
d410 1
a410 1
nvramopen(dev, flag, mode, p)
a412 1
	struct proc *p;
d422 1
a422 1
nvramclose(dev, flag, mode, p)
a424 1
	struct proc *p;
d433 1
a433 1
	u_long cmd;
@


1.15
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.13 2001/11/06 00:30:38 art Exp $ */
d105 1
a105 7
	ret = badvaddr(IIOV(ca->ca_vaddr), 1);
	if (ret != 0)
		ret = badvaddr(IIOV(ca->ca_vaddr), 2);
	if (ret != 0)
		ret = badvaddr(IIOV(ca->ca_vaddr), 4);

	if (ret != 0) {
d127 1
a127 1
	if (cputyp == CPU_188) {
d139 1
a139 1
	if (cputyp != CPU_188) {
d319 1
a319 1
	if (cputyp != CPU_188) {
d375 1
a375 1
	if (cputyp != CPU_188) {
@


1.14
log
@Support for MVME197 completed.  Fix SPL defs.
@
text
@d105 7
a111 1
	if (badvaddr(IIOV(ca->ca_vaddr), 1)) {
d133 1
a133 1
	if (brdtyp == BRD_188) {
d145 1
a145 1
	if (brdtyp != BRD_188) {
d325 1
a325 1
	if (brdtyp != BRD_188) {
d381 1
a381 1
	if (brdtyp != BRD_188) {
@


1.13
log
@Kill vm/vm_param.h, move it to uvm/uvm_param.h
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.11 2001/08/26 02:37:07 miod Exp $ */
d105 1
a105 7
	ret = badvaddr(IIOV(ca->ca_vaddr), 1);
	if (ret != 0)
		ret = badvaddr(IIOV(ca->ca_vaddr), 2);
	if (ret != 0)
		ret = badvaddr(IIOV(ca->ca_vaddr), 4);

	if (ret != 0) {
d127 1
a127 1
	if (cputyp == CPU_188) {
d139 1
a139 1
	if (cputyp != CPU_188) {
d319 1
a319 1
	if (cputyp != CPU_188) {
d375 1
a375 1
	if (cputyp != CPU_188) {
@


1.12
log
@Change d_mmap in struct cdevsw from:
        int     (*d_mmap)       __P((dev_t, int, int));
to:
	paddr_t	(*d_mmap)	__P((dev_t, off_t, int));

This allows us to mmap devices past 4GB offsets.
@
text
@d54 1
a54 1
#include <vm/vm_param.h>
@


1.11
log
@Add prototypes, fix compilation warnings, random style fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.10 2001/06/14 21:30:34 miod Exp $ */
d85 1
a85 1
int nvrammmap __P((dev_t dev, int off, int prot));
d490 1
a490 1
int
d493 2
a494 1
	int off, prot;
@


1.10
log
@Big cleanup of VM issues:
o get rid of m88k_foo macros when there is an mi foo macro
o remove the ability, for the pmap module, to handle a native mmu page
  size different from the vm module page size. This allows some
  optimizations in pmap.c
o remove dead stuff from <machine/vmparam.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.9 2001/03/09 05:44:39 smurph Exp $ */
d87 2
d204 1
a204 1
static u_long
@


1.9
log
@kernel will compile with -Werror.  Added intr.h
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.8 2001/03/08 00:03:14 miod Exp $ */
d46 1
d54 2
d502 1
a502 1
	return (m88k_btop(sc->sc_paddr + off));
@


1.8
log
@Some warning hunting.
Define new include files for convenience, for use by drivers who can
attach either to pcctwo or syscon, or need bug console routines.
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.7 2001/01/04 04:01:59 smurph Exp $ */
d86 2
a87 2
struct device *parent;
void *vcf, *args;
d119 2
a120 2
struct device *parent, *self;
void *args;
d162 1
a162 1
register struct timeval *tvp;
a167 1
	tvp->tv_usec;
d201 1
a201 1
register int sec, min, hour, day, mon, year;
d303 1
a303 1
time_t base;
d412 2
a413 2
dev_t dev;
int flag, mode;
d424 2
a425 2
dev_t dev;
int flag, mode;
d457 3
a459 3
dev_t dev;
struct uio *uio;
int flags;
d470 3
a472 3
dev_t dev;
struct uio *uio;
int flags;
d487 2
a488 2
dev_t dev;
int off, prot;
@


1.7
log
@Y2K fix for TODC - Submitted by Bob Harbour.  Thanks Bob!
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.6 2000/04/11 02:44:29 pjanzen Exp $ */
d52 2
d76 8
d89 1
d91 1
a91 1
	struct cfdata *cf = vcf;
d247 3
d251 1
a251 1
register struct chiptime *c;
d434 5
a438 4
dev_t   dev;
caddr_t data;
int     cmd, flag;
struct proc *p;
@


1.6
log
@Check usec for >= 1000000, not just > ; as msaitoh@@NetBSD.org
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.5 1999/09/27 18:43:24 smurph Exp $ */
d34 5
d56 1
a56 1
	struct device		sc_dev;
d63 2
a64 2
void	nvramattach	__P((struct device *, struct device *, void *));
int	nvrammatch __P((struct device *, void *, void *));
d67 1
a67 1
        sizeof(struct nvramsoftc), nvrammatch, nvramattach
d69 1
a69 1
 
d71 1
a71 1
        NULL, "nvram", DV_DULL, 0
d76 2
a77 2
	struct device *parent;
	void *vcf, *args;
d83 1
a83 1
   ca->ca_vaddr = ca->ca_paddr;  /* map 1:1 */
d90 8
a97 8
	if (ret != 0)  
	    ret = badvaddr(IIOV(ca->ca_vaddr), 2);
	if (ret != 0) 
	    ret = badvaddr(IIOV(ca->ca_vaddr), 4);
	
	if (ret != 0){
	    printf("==> nvram: address 0x%x failed check\n", ca->ca_vaddr);
	    return(0);
d99 1
a99 1
	    return(1);
d102 1
a102 1
	return(1);
d108 2
a109 2
	struct device *parent, *self;
	void *args;
d112 1
a112 1
	struct nvramsoftc	*sc = (struct nvramsoftc *)self;
d118 4
a121 4
      sc->sc_len = MK48T02_SIZE;
   } else {
      sc->sc_len = MK48T08_SIZE;
   }
d125 1
a125 1
/*X*/		    max(sc->sc_len, NBPG));
d130 5
a134 5
      sc->sc_regs = (void *)(sc->sc_vaddr + sc->sc_len -
          sizeof(struct clockreg));
   } else {
      sc->sc_regs = (void *)(sc->sc_vaddr + M188_NVRAM_TOD_OFF);
   }
d151 1
a151 1
	register struct timeval *tvp;
d187 1
a187 1
    { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 };
d191 1
a191 1
	register int sec, min, hour, day, mon, year;
d203 1
a203 1
	if (year < 70 || year > 164 || mon < 1 || mon > 12 || day < 1 || day > 31)
d205 1
d207 8
a214 1
	for (yr = 70; yr < year; yr++)
d216 1
d218 1
d221 1
d227 7
a233 7
	int	sec;
	int	min;
	int	hour;
	int	wday;
	int	day;
	int	mon;
	int	year;
d237 1
a237 1
	register struct chiptime *c;
d241 2
a242 1
	/* compute the year */
d244 2
a245 1
	t3 = (t2 + 2) % 7;	/* day of week */
d248 1
d260 1
a260 1
		if (t3 < dayyr[t2] + (t && t2 > 1))
d281 1
a281 1
	c->year = TOBCD(c->year - YEAR0);
d290 1
a290 1
	time_t base;
d308 20
a327 20
      register struct clockreg *cl = (struct clockreg *)sc->sc_regs;
   	cl->cl_csr |= CLK_READ;		/* enable read (stop time) */
   	sec = cl->cl_sec;
   	min = cl->cl_min;
   	hour = cl->cl_hour;
   	day = cl->cl_mday;
   	mon = cl->cl_month;
   	year = cl->cl_year;
   	cl->cl_csr &= ~CLK_READ;	/* time wears on */
   } else { /* CPU_188 */
      register struct m188_clockreg *cl = (struct m188_clockreg *)sc->sc_regs;
   	cl->cl_csr |= CLK_READ;		/* enable read (stop time) */
   	sec = cl->cl_sec & 0xff;
   	min = cl->cl_min & 0xff;
   	hour = cl->cl_hour & 0xff;
   	day = cl->cl_mday & 0xff;
   	mon = cl->cl_month & 0xff;
   	year = cl->cl_year & 0xff;
   	cl->cl_csr &= ~CLK_READ;	/* time wears on */
   }
d330 3
a332 3
      printf("day = %d, mon = %d, year = %d, hour = %d, min = %d, sec = %d",
             FROMBCD(day), FROMBCD(mon), FROMBCD(year) + YEAR0,
             FROMBCD(hour), FROMBCD(min), FROMBCD(sec));
d348 1
a348 1
		    time.tv_sec < base ? "lost" : "gained", deltat / SECDAY);
d362 32
a393 32
   struct chiptime c;
   if (cputyp != CPU_188) {
      register struct clockreg *cl = (struct clockreg *)sc->sc_regs;
   
   	if (!time.tv_sec || cl == NULL)
   		return;
   	timetochip(&c);
   	cl->cl_csr |= CLK_WRITE;	/* enable write */
   	cl->cl_sec = c.sec;
   	cl->cl_min = c.min;
   	cl->cl_hour = c.hour;
   	cl->cl_wday = c.wday;
   	cl->cl_mday = c.day;
   	cl->cl_month = c.mon;
   	cl->cl_year = c.year;
   	cl->cl_csr &= ~CLK_WRITE;	/* load them up */
   } else { /* CPU_188 */
      register struct m188_clockreg *cl = (struct m188_clockreg *)sc->sc_regs;
   
   	if (!time.tv_sec || cl == NULL)
   		return;
   	timetochip(&c);
   	cl->cl_csr |= CLK_WRITE;	/* enable write */
   	cl->cl_sec = c.sec;
   	cl->cl_min = c.min;
   	cl->cl_hour = c.hour;
   	cl->cl_wday = c.wday;
   	cl->cl_mday = c.day;
   	cl->cl_month = c.mon;
   	cl->cl_year = c.year;
   	cl->cl_csr &= ~CLK_WRITE;	/* load them up */
   }
d399 2
a400 2
	dev_t dev;
	int flag, mode;
d411 2
a412 2
	dev_t dev;
	int flag, mode;
d420 4
a423 4
	dev_t   dev;
	caddr_t data;
	int     cmd, flag;
	struct proc *p;
d428 1
a428 1
	
d443 3
a445 3
	dev_t dev;
	struct uio *uio;
	int flags;
d456 3
a458 3
	dev_t dev;
	struct uio *uio;
	int flags;
d473 2
a474 2
	dev_t dev;
	int off, prot;
@


1.5
log
@adding support for MVME188 and MVME197.  Plus 32bit if_ie.
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.4 1999/04/11 03:26:27 smurph Exp $ */
d153 1
a153 1
	while (tvp->tv_usec > 1000000) {
d159 1
a159 1
	    (tvp->tv_usec = lasttime.tv_usec + 1) > 1000000) {
@


1.5.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.9 2001/03/09 05:44:39 smurph Exp $ */
a33 5
/* 
 * 8/22/2000 BH Cleaned up year 2000 problems with calendar hardware.
 * This code will break again in 2068 or so - come dance on my grave.
 */

a46 2

#include <mvme88k/dev/memdevs.h>
d51 1
a51 1
	struct device           sc_dev;
d58 2
a59 2
void    nvramattach     __P((struct device *, struct device *, void *));
int     nvrammatch __P((struct device *, void *, void *));
d62 1
a62 1
	sizeof(struct nvramsoftc), nvrammatch, nvramattach
d64 1
a64 1

d66 1
a66 1
	NULL, "nvram", DV_DULL, 0
a68 8
int nvramopen __P((dev_t dev, int flag, int mode));
int nvramclose __P((dev_t dev, int flag, int mode));
int nvramioctl __P((dev_t dev, int cmd, caddr_t data, int flag,
    struct proc *p));
int nvramread __P((dev_t dev, struct uio *uio, int flags));
int nvramwrite __P((dev_t dev, struct uio *uio, int flags));
int nvrammmap __P((dev_t dev, int off, int prot));

a73 1
#if 0
d75 1
a75 1
#endif
d78 1
a78 1
	ca->ca_vaddr = ca->ca_paddr;   /* map 1:1 */
d85 8
a92 8
	if (ret != 0)
		ret = badvaddr(IIOV(ca->ca_vaddr), 2);
	if (ret != 0)
		ret = badvaddr(IIOV(ca->ca_vaddr), 4);

	if (ret != 0) {
		printf("==> nvram: address 0x%x failed check\n", ca->ca_vaddr);
		return (0);
d94 1
a94 1
		return (1);
d97 1
a97 1
	return (1);
d107 1
a107 1
	struct nvramsoftc       *sc = (struct nvramsoftc *)self;
d113 4
a116 4
		sc->sc_len = MK48T02_SIZE;
	} else {
		sc->sc_len = MK48T08_SIZE;
	}
d120 1
a120 1
/*X*/		max(sc->sc_len, NBPG));
d125 5
a129 5
		sc->sc_regs = (void *)(sc->sc_vaddr + sc->sc_len -
				       sizeof(struct clockreg));
	} else {
		sc->sc_regs = (void *)(sc->sc_vaddr + M188_NVRAM_TOD_OFF);
	}
d152 2
a153 1
	while (tvp->tv_usec >= 1000000) {
d159 1
a159 1
	    (tvp->tv_usec = lasttime.tv_usec + 1) >= 1000000) {
d182 1
a182 1
{ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};
d198 1
a198 1
	if (year>164 || mon<1 || mon>12 || day<1 || day>31)
a199 1
	yr = 70;
d201 1
a201 8

	if (year < 70) {		/* 2000 <= year */
		for (; yr < 100; yr++)	/* deal with first 30 years */
			days += LEAPYEAR(yr) ? 366 : 365;
		yr = 0;
	}

	for (; yr < year; yr++)		/* deal with years left */
a202 1

a203 1

a205 1

d211 7
a217 7
	int     sec;
	int     min;
	int     hour;
	int     wday;
	int     day;
	int     mon;
	int     year;
a219 3
void timetochip __P((struct chiptime *c));

void
d225 1
a225 2
	/* January 1 1970 was a Thursday (4 in unix wdays) */
	/* compute the days since the epoch */
d227 1
a227 2

	t3 = (t2 + 4) % 7;	/* day of week */
a229 1
	/* compute the year */
d241 1
a241 1
		if (t3 < (dayyr[t2] + ((t && (t2 > 1)) ? 1:0)))
d262 1
a262 1
	c->year = TOBCD((c->year - YEAR0) % 100);
d289 20
a308 20
		register struct clockreg *cl = (struct clockreg *)sc->sc_regs;
		cl->cl_csr |= CLK_READ;		/* enable read (stop time) */
		sec = cl->cl_sec;
		min = cl->cl_min;
		hour = cl->cl_hour;
		day = cl->cl_mday;
		mon = cl->cl_month;
		year = cl->cl_year;
		cl->cl_csr &= ~CLK_READ;	/* time wears on... */
	} else { /* CPU_188 */
		register struct m188_clockreg *cl = (struct m188_clockreg *)sc->sc_regs;
		cl->cl_csr |= CLK_READ;		/* enable read (stop time) */
		sec = cl->cl_sec & 0xff;
		min = cl->cl_min & 0xff;
		hour = cl->cl_hour & 0xff;
		day = cl->cl_mday & 0xff;
		mon = cl->cl_month & 0xff;
		year = cl->cl_year & 0xff;
		cl->cl_csr &= ~CLK_READ;	/* time wears on... */
	}
d311 3
a313 3
		printf("day = %d, mon = %d, year = %d, hour = %d, min = %d, sec = %d",
		       FROMBCD(day), FROMBCD(mon), FROMBCD(year) + YEAR0,
		       FROMBCD(hour), FROMBCD(min), FROMBCD(sec));
d329 1
a329 1
		       time.tv_sec < base ? "lost" : "gained", deltat / SECDAY);
d343 32
a374 32
	struct chiptime c;
	if (cputyp != CPU_188) {
		register struct clockreg *cl = (struct clockreg *)sc->sc_regs;

		if (!time.tv_sec || cl == NULL)
			return;
		timetochip(&c);
		cl->cl_csr |= CLK_WRITE;	/* enable write */
		cl->cl_sec = c.sec;
		cl->cl_min = c.min;
		cl->cl_hour = c.hour;
		cl->cl_wday = c.wday;
		cl->cl_mday = c.day;
		cl->cl_month = c.mon;
		cl->cl_year = c.year;
		cl->cl_csr &= ~CLK_WRITE;	/* load them up */
	} else { /* CPU_188 */
		register struct m188_clockreg *cl = (struct m188_clockreg *)sc->sc_regs;

		if (!time.tv_sec || cl == NULL)
			return;
		timetochip(&c);
		cl->cl_csr |= CLK_WRITE;	/* enable write */
		cl->cl_sec = c.sec;
		cl->cl_min = c.min;
		cl->cl_hour = c.hour;
		cl->cl_wday = c.wday;
		cl->cl_mday = c.day;
		cl->cl_month = c.mon;
		cl->cl_year = c.year;
		cl->cl_csr &= ~CLK_WRITE;	/* load them up */
	}
d401 1
a401 2
	dev_t dev;
	int cmd;
d403 1
a403 1
	int flag;
d409 1
a409 1

@


1.5.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.5.4.1 2001/04/18 16:10:59 niklas Exp $ */
a45 1

a52 2
#include <vm/vm_param.h>

d499 1
a499 1
	return (atop(sc->sc_paddr + off));
@


1.5.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.5.4.2 2001/07/04 10:19:54 niklas Exp $ */
a86 2
u_long chiptotime __P((int, int, int, int, int, int));

d202 1
a202 1
u_long
@


1.5.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d54 1
a54 1
#include <uvm/uvm_param.h>
d85 1
a85 1
paddr_t nvrammmap __P((dev_t dev, off_t off, int prot));
d490 1
a490 1
paddr_t
d493 1
a493 2
	off_t off;
	int prot;
@


1.5.4.5
log
@Merge in trunk
@
text
@d98 1
a98 1
	struct mvmeprom_time rtc;
d105 7
a111 1
	if (badvaddr(IIOV(ca->ca_vaddr), 1)) {
d133 1
a133 1
	if (brdtyp == BRD_188) {
d145 1
a145 1
	if (brdtyp != BRD_188) {
d325 1
a325 1
	if (brdtyp != BRD_188) {
d381 1
a381 1
	if (brdtyp != BRD_188) {
@


1.5.4.6
log
@Merge in -current from about a week ago
@
text
@d68 2
a69 2
void    nvramattach(struct device *, struct device *, void *);
int     nvrammatch(struct device *, void *, void *);
d79 7
a85 7
int nvramopen(dev_t dev, int flag, int mode);
int nvramclose(dev_t dev, int flag, int mode);
int nvramioctl(dev_t dev, int cmd, caddr_t data, int flag,
    struct proc *p);
int nvramread(dev_t dev, struct uio *uio, int flags);
int nvramwrite(dev_t dev, struct uio *uio, int flags);
paddr_t nvrammmap(dev_t dev, off_t off, int prot);
d87 1
a87 1
u_long chiptotime(int, int, int, int, int, int);
d245 1
a245 1
void timetochip(struct chiptime *c);
@


1.5.4.7
log
@Sync the SMP branch with 3.3
@
text
@d47 1
a49 1
#include <machine/conf.h>
a51 1
#include <machine/psl.h>
d79 8
d371 1
a371 2
void
resettodr()
d410 1
a410 1
nvramopen(dev, flag, mode, p)
a412 1
	struct proc *p;
d422 1
a422 1
nvramclose(dev, flag, mode, p)
a424 1
	struct proc *p;
d433 1
a433 1
	u_long cmd;
@


1.5.4.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.5.4.7 2003/03/27 23:32:18 niklas Exp $ */
d14 6
@


1.5.4.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d5 1
a5 1
 *
d28 1
a28 1
/*
d66 1
a66 1
struct cfattach nvram_ca = {
d68 1
a68 1
};
d71 1
a71 1
	NULL, "nvram", DV_DULL
d148 1
a148 1
	struct timeval *tvp;
d187 1
a187 1
	int sec, min, hour, day, mon, year;
d189 1
a189 1
	int days, yr;
d236 1
a236 1
	struct chiptime *c;
d238 1
a238 1
	int t, t2, t3, now = time.tv_sec;
d287 1
a287 1
void
d307 1
a307 1
		struct clockreg *cl = (struct clockreg *)sc->sc_regs;
d317 1
a317 1
		struct m188_clockreg *cl = (struct m188_clockreg *)sc->sc_regs;
d328 2
a329 3
		printf("WARNING: bad date in nvram");
#ifdef DEBUG
		printf("\nday = %d, mon = %d, year = %d, hour = %d, min = %d, sec = %d",
a331 1
#endif
d364 1
a364 1
		struct clockreg *cl = (struct clockreg *)sc->sc_regs;
d379 1
a379 1
		struct m188_clockreg *cl = (struct m188_clockreg *)sc->sc_regs;
@


1.5.4.10
log
@Merge with the trunk
@
text
@d57 4
a60 5
	paddr_t			sc_base;
	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
	bus_addr_t		sc_regs;
	size_t			sc_len;
d82 2
a84 3
	bus_space_handle_t ioh;
	int rc;
#endif
d86 3
d90 1
d92 2
a93 2
#if 0
	if (bus_space_map(ca->ca_iot, ca->ca_paddr, PAGE_SIZE, 0, &ioh) != 0)
a94 5
	if (badvaddr(bus_space_vaddr(ca->ca_iot, ioh), 1)) {
#ifdef DEBUG
		printf("==> nvram: address 0x%x failed check\n", ca->ca_paddr);
#endif
		rc = 0;
d96 1
a96 3
		rc = 1;
	bus_space_unmap(ca->ca_iot, ioh, PAGE_SIZE);
	return rc;
d98 2
a99 1
	return 1;
d109 4
a112 2
	struct nvramsoftc *sc = (struct nvramsoftc *)self;
	bus_space_handle_t ioh;
a115 1
		sc->sc_regs = M188_NVRAM_TOD_OFF;
a117 1
		sc->sc_regs = SBC_NVRAM_TOD_OFF;
d120 11
a130 7
	sc->sc_iot = ca->ca_iot;
	sc->sc_base = ca->ca_paddr;

	if (bus_space_map(sc->sc_iot, sc->sc_base, round_page(sc->sc_len),
	    0, &ioh) != 0) {
		printf(": can't map memory!\n");
		return;
d133 1
a133 3
	sc->sc_ioh = ioh;

	printf(": MK48T0%d\n", sc->sc_len / 1024);
d306 20
a325 43

	if (brdtyp == BRD_188) {
		bus_space_write_4(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + (CLK_CSR << 2), CLK_READ |
		    bus_space_read_4(sc->sc_iot, sc->sc_ioh,
		      sc->sc_regs + (CLK_CSR << 2)));
		sec = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + (CLK_SEC << 2)) & 0xff;
		min = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + (CLK_MIN << 2)) & 0xff;
		hour = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + (CLK_HOUR << 2)) & 0xff;
		day = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + (CLK_DAY << 2)) & 0xff;
		mon = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + (CLK_MONTH << 2)) & 0xff;
		year = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + (CLK_YEAR << 2)) & 0xff;
		bus_space_write_4(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + (CLK_CSR << 2),
		    bus_space_read_4(sc->sc_iot, sc->sc_ioh,
		      sc->sc_regs + (CLK_CSR << 2)) & ~CLK_READ);
	} else {
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + CLK_CSR, CLK_READ |
		    bus_space_read_1(sc->sc_iot, sc->sc_ioh,
		      sc->sc_regs + CLK_CSR));
		sec = bus_space_read_1(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + CLK_SEC);
		min = bus_space_read_1(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + CLK_MIN);
		hour = bus_space_read_1(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + CLK_HOUR);
		day = bus_space_read_1(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + CLK_DAY);
		mon = bus_space_read_1(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + CLK_MONTH);
		year = bus_space_read_1(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + CLK_YEAR);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + CLK_CSR,
		    bus_space_read_1(sc->sc_iot, sc->sc_ioh,
		      sc->sc_regs + CLK_CSR) & ~CLK_READ);
a326 1

d365 2
d368 14
a381 3
	if (!time.tv_sec || sc == NULL)
		return;
	timetochip(&c);
d383 12
a394 46
	if (brdtyp == BRD_188) {
		bus_space_write_4(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + (CLK_CSR << 2), CLK_WRITE |
		    bus_space_read_4(sc->sc_iot, sc->sc_ioh,
		      sc->sc_regs + (CLK_CSR << 2)));
		bus_space_write_4(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + (CLK_SEC << 2), c.sec);
		bus_space_write_4(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + (CLK_MIN << 2), c.min);
		bus_space_write_4(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + (CLK_HOUR << 2), c.hour);
		bus_space_write_4(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + (CLK_WDAY << 2), c.wday);
		bus_space_write_4(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + (CLK_DAY << 2), c.day);
		bus_space_write_4(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + (CLK_MONTH << 2), c.mon);
		bus_space_write_4(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + (CLK_YEAR << 2), c.year);
		bus_space_write_4(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + (CLK_CSR << 2),
		    bus_space_read_4(sc->sc_iot, sc->sc_ioh,
		      sc->sc_regs + (CLK_CSR << 2)) & ~CLK_WRITE);
	} else {
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + CLK_CSR, CLK_WRITE |
		    bus_space_read_1(sc->sc_iot, sc->sc_ioh,
		      sc->sc_regs + CLK_CSR));
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + CLK_SEC, c.sec);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + CLK_MIN, c.min);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + CLK_HOUR, c.hour);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + CLK_WDAY, c.wday);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + CLK_DAY, c.day);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + CLK_MONTH, c.mon);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + CLK_YEAR, c.year);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    sc->sc_regs + CLK_CSR,
		    bus_space_read_1(sc->sc_iot, sc->sc_ioh,
		      sc->sc_regs + CLK_CSR) & ~CLK_WRITE);
d447 14
a460 1
nvramrw(dev, uio, flags)
d468 1
a468 2
	return (memdevrw(bus_space_vaddr(sc->sc_iot, sc->sc_ioh),
	    sc->sc_len, uio, flags));
d473 1
a473 1
 * will also be mmap'd, due to PAGE_SIZE being 4K. Usually, the NVRAM
d489 1
a489 1
	if (off < 0 || off > sc->sc_len)
d491 1
a491 1
	return (atop(sc->sc_base + off));
@


1.4
log
@Fix for 25 Mhz.
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.3 1999/01/11 05:11:43 millert Exp $ */
a49 1

d52 4
a55 4
	void *		sc_paddr;
	void *		sc_vaddr;
	int		sc_len;
	struct clockreg *sc_regs;
d78 1
d112 5
a116 1
	sc->sc_len = MK48T08_SIZE;
d124 6
a129 2
	sc->sc_regs = (struct clockreg *)(sc->sc_vaddr + sc->sc_len -
	    sizeof(struct clockreg));
d268 1
a273 1
	register struct clockreg *cl = sc->sc_regs;
d288 21
a308 8
	cl->cl_csr |= CLK_READ;		/* enable read (stop time) */
	sec = cl->cl_sec;
	min = cl->cl_min;
	hour = cl->cl_hour;
	day = cl->cl_mday;
	mon = cl->cl_month;
	year = cl->cl_year;
	cl->cl_csr &= ~CLK_READ;	/* time wears on */
d310 4
a313 1
		printf("WARNING: bad date in nvram");
d343 32
a374 15
	register struct clockreg *cl = sc->sc_regs;
	struct chiptime c;

	if (!time.tv_sec || cl == NULL)
		return;
	timetochip(&c);
	cl->cl_csr |= CLK_WRITE;	/* enable write */
	cl->cl_sec = c.sec;
	cl->cl_min = c.min;
	cl->cl_hour = c.hour;
	cl->cl_wday = c.wday;
	cl->cl_mday = c.day;
	cl->cl_month = c.mon;
	cl->cl_year = c.year;
	cl->cl_csr &= ~CLK_WRITE;	/* load them up */
a394 1

@


1.3
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.2 1998/12/15 05:52:30 smurph Exp $ */
d43 1
d74 2
a75 1
	{
d78 1
a78 1

d81 18
a98 1
	return (!badvaddr(ca->ca_vaddr, 1));
@


1.2
log
@Commit for the first real OpenBSD mvme88k port.
@
text
@d1 1
a1 1
/*	$OpenBSD: nvram.c,v 1.4 1996/06/11 10:15:16 deraadt Exp $ */
d99 1
a99 1
/*X*/		panic("failed to map!\n");
@


1.1
log
@Initial revision
@
text
@d1 33
d35 1
a35 1
#include <sys/conf.h>
d37 2
a38 2
#include <sys/proc.h>
#include <sys/tty.h>
d40 3
a42 3
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
d44 2
a45 2
#include <machine/autoconf.h>

d49 1
d52 4
a55 4
	caddr_t			sc_paddr;
	caddr_t			sc_vaddr;
	int			sc_size;
	volatile struct clockreg *sc_clockreg;
a57 1
int	nvrammatch	__P((struct device *, void *, void *));
d59 1
a68 1
/* ARGSUSED */
d70 3
a72 13
nvrammatch(struct device *parent, void *self, void *aux)
{
	struct confargs *ca = aux;
	struct cfdata *cf = self;
	caddr_t base;
	int ret;
	
#if 0
	if (cputyp != CPU_167 && cputyp != CPU_166
#ifdef CPU_187
		&& cputyp != CPU_187
#endif
		)
d74 2
a75 16
		return 0;
	}
#endif /* 0 */
	
	if (cputyp != CPU_187) {
		return 0;
	}
	
	/* 
	 * If bus or name do not match, fail.
	 */
	if (ca->ca_bustype != BUS_PCCTWO ||
		strcmp(cf->cf_driver->cd_name, "nvram")) {
		return 0;
	}

d77 3
a79 15
	/* 3 locators base, size, ipl */
	base = (caddr_t)cf->cf_loc[0];

	if (badpaddr(base, 1) == -1) {
		return 0;
	}

	/*
	 * Tell our parent our requirements.
	 */
	ca->ca_paddr = (caddr_t)cf->cf_loc[0];
	ca->ca_size  = NVRAMSIZE;
	ca->ca_ipl   = 0;

	return 1;
a81 1
/* ARGSUSED */
d83 3
a85 1
nvramattach(struct device *parent, struct device *self, void *aux)
d87 1
a88 1
	struct confargs		*ca = aux;
d90 10
a99 1
	sc->sc_clockreg = (struct clockreg *)(ca->ca_vaddr + NVRAM_TOD_OFF);
d101 4
a104 1
	printf(": MK48T08\n");
a106 1
#if 0
d108 8
a115 2
 * Write en/dis-able clock registers.  We coordinate so that several
 * writers can run simultaneously.
d118 2
a119 2
clk_wenable(onoff)
	int onoff;
d121 16
a136 9
	register int s;
	register vm_prot_t prot;/* nonzero => change prot */
	static int writers;

	s = splhigh();
	if (onoff)
		prot = writers++ == 0 ? VM_PROT_READ|VM_PROT_WRITE : 0;
	else
		prot = --writers == 0 ? VM_PROT_READ : 0;
a137 2
	if (prot)
		pmap_changeprot(pmap_kernel(), (vm_offset_t)clockreg, prot, 1);
a138 1
#endif /* 0 */
d141 1
a141 1
 * BCD to hex and hex to BCD.
d148 1
a148 1
#define LEAPYEAR(y) 	(((y) % 4 == 0) && ((y) % 100) != 0 || ((y) % 400) == 0)
d157 3
a159 1
chiptotime(int sec, int min, int hour, int day, int mon, int year)
d171 1
a171 1
	if (year < 70 || mon < 1 || mon > 12 || day < 1 || day > 31)
d193 2
a194 1
timetochip(struct chiptime *c)
d241 3
a243 2
void
inittodr(time_t base)
d245 2
a246 2
	register struct nvramsoftc *sc;
	register volatile struct clockreg *cl;
a248 3
	
	sc = (struct nvramsoftc *)nvram_cd.cd_devs[0];
	cl = sc->sc_clockreg;
a260 1
	
d269 2
a270 5

	time.tv_sec = chiptotime(sec, min, hour, day, mon, year);

	if (time.tv_sec == 0) {
		printf("WARNING: bad date in battery clock");
d297 1
a297 2
void
resettodr()
d299 2
a300 2
	register struct nvramsoftc *sc;
	register volatile struct clockreg *cl;
d303 1
a303 3
	sc = (struct nvramsoftc *)nvram_cd.cd_devs[0];

	if (!time.tv_sec || (cl = sc->sc_clockreg) == NULL)
a305 1

d315 93
@


1.1.1.1
log
@Third try at importing the mvme88k port. This is a working kernel
from nivas.
Userland and compiler still need to be worked on.
Make certain what directory the import is done from.
@
text
@@
