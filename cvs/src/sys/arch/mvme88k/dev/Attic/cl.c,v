head	1.61;
access;
symbols
	OPENBSD_5_5:1.60.0.4
	OPENBSD_5_5_BASE:1.60
	OPENBSD_5_4:1.59.0.14
	OPENBSD_5_4_BASE:1.59
	OPENBSD_5_3:1.59.0.12
	OPENBSD_5_3_BASE:1.59
	OPENBSD_5_2:1.59.0.10
	OPENBSD_5_2_BASE:1.59
	OPENBSD_5_1_BASE:1.59
	OPENBSD_5_1:1.59.0.8
	OPENBSD_5_0:1.59.0.6
	OPENBSD_5_0_BASE:1.59
	OPENBSD_4_9:1.59.0.4
	OPENBSD_4_9_BASE:1.59
	OPENBSD_4_8:1.59.0.2
	OPENBSD_4_8_BASE:1.59
	OPENBSD_4_7:1.57.0.2
	OPENBSD_4_7_BASE:1.57
	OPENBSD_4_6:1.54.0.4
	OPENBSD_4_6_BASE:1.54
	OPENBSD_4_5:1.53.0.6
	OPENBSD_4_5_BASE:1.53
	OPENBSD_4_4:1.53.0.4
	OPENBSD_4_4_BASE:1.53
	OPENBSD_4_3:1.53.0.2
	OPENBSD_4_3_BASE:1.53
	OPENBSD_4_2:1.52.0.6
	OPENBSD_4_2_BASE:1.52
	OPENBSD_4_1:1.52.0.4
	OPENBSD_4_1_BASE:1.52
	OPENBSD_4_0:1.52.0.2
	OPENBSD_4_0_BASE:1.52
	OPENBSD_3_9:1.50.0.2
	OPENBSD_3_9_BASE:1.50
	OPENBSD_3_8:1.49.0.4
	OPENBSD_3_8_BASE:1.49
	OPENBSD_3_7:1.49.0.2
	OPENBSD_3_7_BASE:1.49
	OPENBSD_3_6:1.48.0.2
	OPENBSD_3_6_BASE:1.48
	SMP_SYNC_A:1.45
	SMP_SYNC_B:1.45
	OPENBSD_3_5:1.40.0.2
	OPENBSD_3_5_BASE:1.40
	OPENBSD_3_4:1.29.0.2
	OPENBSD_3_4_BASE:1.29
	UBC_SYNC_A:1.27
	OPENBSD_3_3:1.27.0.2
	OPENBSD_3_3_BASE:1.27
	OPENBSD_3_2:1.26.0.2
	OPENBSD_3_2_BASE:1.26
	OPENBSD_3_1:1.23.0.2
	OPENBSD_3_1_BASE:1.23
	UBC_SYNC_B:1.26
	UBC:1.18.0.2
	UBC_BASE:1.18
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.6.0.4
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	SMP:1.5.0.4
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.1.1.1.0.8
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.6
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.4
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.2
	OPENBSD_2_1_BASE:1.1.1.1
	mvme88kport:1.1.1.1;
locks; strict;
comment	@ * @;


1.61
date	2014.03.18.22.36.35;	author miod;	state dead;
branches;
next	1.60;

1.60
date	2013.10.07.17.53.57;	author miod;	state Exp;
branches;
next	1.59;

1.59
date	2010.06.28.14.13.29;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2010.04.12.12.57.52;	author tedu;	state Exp;
branches;
next	1.57;

1.57
date	2009.11.09.17.53.39;	author nicm;	state Exp;
branches;
next	1.56;

1.56
date	2009.10.31.12.00.07;	author fgsch;	state Exp;
branches;
next	1.55;

1.55
date	2009.10.31.06.40.16;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2009.05.31.12.25.53;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2008.01.23.16.37.57;	author jsing;	state Exp;
branches;
next	1.52;

1.52
date	2006.05.08.14.36.10;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2006.04.15.22.29.49;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2006.01.01.11.59.39;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2005.01.25.12.13.22;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2004.07.30.19.02.05;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2004.07.02.14.00.42;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2004.07.02.11.19.58;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2004.04.29.16.20.02;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2004.04.24.19.51.47;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2004.04.16.23.32.44;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2004.04.15.12.35.20;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2004.04.15.08.41.44;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2004.02.11.20.41.07;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2004.02.10.10.30.25;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2004.02.10.10.06.48;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2004.01.14.20.50.48;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2004.01.05.20.08.01;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2004.01.02.23.37.17;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2003.12.29.07.04.14;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2003.12.19.22.30.18;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2003.10.05.20.27.47;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2003.10.03.16.44.50;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2003.09.28.14.26.25;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2003.08.15.20.32.14;	author tedu;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.03.21.09.01;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2003.01.13.20.09.19;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2002.06.12.03.49.56;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2002.06.11.05.13.39;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2002.04.28.15.17.09;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2002.03.14.03.15.57;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.14.01.26.39;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.15.20.45.30;	author nordin;	state Exp;
branches;
next	1.20;

1.20
date	2002.01.14.21.34.38;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2002.01.07.03.05.57;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.19.07.04.41;	author smurph;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2001.12.16.23.49.46;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2001.12.14.00.51.41;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.13.08.55.51;	author smurph;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.31.01.05.44;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.26.02.37.07;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.24.22.46.57;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.27.05.44.49;	author nate;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.09.05.44.38;	author smurph;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.07.23.45.50;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.12.08.16.22;	author smurph;	state Exp;
branches;
next	1.7;

1.7
date	2001.02.01.03.38.14;	author smurph;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.26.23.32.00;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	99.09.27.18.43.22;	author smurph;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	99.05.29.04.41.43;	author smurph;	state Exp;
branches;
next	1.3;

1.3
date	99.01.11.05.11.42;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	98.12.15.05.52.29;	author smurph;	state Exp;
branches;
next	1.1;

1.1
date	97.03.03.19.32.04;	author rahnds;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.03.03.19.32.04;	author rahnds;	state Exp;
branches;
next	;

1.5.4.1
date	2001.04.18.16.10.53;	author niklas;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2001.07.04.10.19.53;	author niklas;	state Exp;
branches;
next	1.5.4.3;

1.5.4.3
date	2001.10.31.03.01.18;	author nate;	state Exp;
branches;
next	1.5.4.4;

1.5.4.4
date	2002.03.06.02.04.44;	author niklas;	state Exp;
branches;
next	1.5.4.5;

1.5.4.5
date	2002.03.28.10.36.02;	author niklas;	state Exp;
branches;
next	1.5.4.6;

1.5.4.6
date	2003.03.27.23.32.17;	author niklas;	state Exp;
branches;
next	1.5.4.7;

1.5.4.7
date	2003.06.07.11.13.16;	author ho;	state Exp;
branches;
next	1.5.4.8;

1.5.4.8
date	2004.02.19.10.49.06;	author niklas;	state Exp;
branches;
next	1.5.4.9;

1.5.4.9
date	2004.06.05.23.09.48;	author niklas;	state Exp;
branches;
next	;

1.18.2.1
date	2002.01.31.22.55.17;	author niklas;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2002.06.11.03.37.09;	author art;	state Exp;
branches;
next	1.18.2.3;

1.18.2.3
date	2002.10.29.00.28.07;	author art;	state Exp;
branches;
next	1.18.2.4;

1.18.2.4
date	2003.05.19.21.45.53;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.61
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: cl.c,v 1.60 2013/10/07 17:53:57 miod Exp $ */

/*
 * Copyright (c) 1995 Dale Rahn. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* DMA mode still does not work!!! */

#include <sys/param.h>
#include <sys/ioctl.h>
#include <sys/proc.h>
#include <sys/tty.h>
#include <sys/uio.h>
#include <sys/systm.h>
#include <sys/time.h>
#include <sys/device.h>
#include <sys/syslog.h>

#include <machine/autoconf.h>
#include <machine/conf.h>
#include <machine/cpu.h>
#include <machine/psl.h>

#include <dev/cons.h>

#include <mvme88k/dev/clreg.h>
#include <mvme88k/dev/pcctworeg.h>
#include <mvme88k/dev/pcctwovar.h>

#ifdef	DDB
#include <ddb/db_var.h>
#endif

#define splcl()	spltty()

/* min timeout 0xa, what is a good value */
#define CL_TIMEOUT	0x10
#define CL_FIFO_MAX	0x20
#define CL_FIFO_CNT	0xc
#define	CL_RX_TIMEOUT	0x10

#define CL_RXDMAINT	0x82
#define CL_TXDMAINT	0x42
#define CL_TXMASK	0x47
#define CL_RXMASK	0x87
#define CL_TXINTR	0x02
#define CL_RXINTR	0x02

struct cl_cons {
	bus_space_tag_t		cl_iot;
	bus_space_handle_t	cl_ioh;
	volatile u_int8_t	*cl_rxiack;
	u_int8_t		channel;
} cl_cons;

struct cl_info {
	struct tty *tty;
	u_char	cl_swflags;
	u_char	cl_softchar;
	u_char	cl_consio;
	u_char	cl_speed;
	u_char	cl_parstop;	/* parity, stop bits. */
	u_char	cl_rxmode;
	u_char	cl_txmode;
	u_char	cl_clen;
	u_char	cl_parity;
#if 0
	u_char  transmitting;
#endif
	u_long  txcnt;
	u_long  rxcnt;

	void *rx[2];
	void *rxp[2];
	void *tx[2];
	void *txp[2];
};
#define CLCD_PORTS_PER_CHIP 4
#define CL_BUFSIZE 256

#ifndef DO_MALLOC
/* four (4) buffers per port */
char cl_dmabuf[CLCD_PORTS_PER_CHIP * CL_BUFSIZE * 4];
char cl_dmabuf1[CLCD_PORTS_PER_CHIP * CL_BUFSIZE * 4];
#endif

struct clsoftc {
	struct device		sc_dev;
	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
	time_t			sc_fotime;	/* time of last fifo overrun */
	struct cl_info		sc_cl[CLCD_PORTS_PER_CHIP];
	struct intrhand		sc_ih_e;
	struct intrhand		sc_ih_m;
	struct intrhand		sc_ih_t;
	struct intrhand		sc_ih_r;
	char			sc_errintrname[16 + 4];
	char			sc_mxintrname[16 + 3];
	char			sc_rxintrname[16 + 3];
	char			sc_txintrname[16 + 3];
	struct pcctwosoftc	*sc_pcctwo;
};

const struct {
	u_int speed;
	u_char divisor;
	u_char clock;
	u_char rx_timeout;
} cl_clocks[] = {
	{ 64000, 0x26, 0, 0x01},
	{ 56000, 0x2c, 0, 0x01},
	{ 38400, 0x40, 0, 0x01},
	{ 19200, 0x81, 0, 0x02},
	{  9600, 0x40, 1, 0x04},
	{  7200, 0x56, 1, 0x04},
	{  4800, 0x81, 1, 0x08},
	{  3600, 0xad, 1, 0x08},
	{  2400, 0x40, 2, 0x10},
	{  1200, 0x81, 2, 0x20},
	{   600, 0x40, 3, 0x40},
	{   300, 0x81, 3, 0x80},
	{   150, 0x40, 3, 0x80},
	{   110, 0x58, 4, 0xff},
	{    50, 0xC2, 4, 0xff},
	{     0, 0x00, 0, 0},
};

#define	CL_SAFE_CLOCK	4	/* 9600 entry */

/* prototypes */
cons_decl(cl);
int cl_instat(struct clsoftc *sc);
u_int8_t cl_clkdiv(int speed);
u_int8_t cl_clknum(int speed);
u_int8_t cl_clkrxtimeout(int speed);
void clstart(struct tty *tp);
void cl_unblock(struct tty *tp);
int clccparam(struct clsoftc *sc, struct termios *par, int channel);

int clparam(struct tty *tp, struct termios *t);
int cl_mintr(void *);
int cl_txintr(void *);
int cl_rxintr(void *);
void cl_overflow(struct clsoftc *sc, int channel, long *ptime, char *msg);
void cl_parity(struct clsoftc *sc, int channel);
void cl_frame(struct clsoftc *sc, int channel);
void cl_break( struct clsoftc *sc, int channel);
int clmctl(dev_t dev, int bits, int how);
#ifdef DEBUG
void cl_dumpport(struct clsoftc *, int);
#endif

int	clprobe(struct device *parent, void *self, void *aux);
void	clattach(struct device *parent, struct device *self, void *aux);

void	cl_initchannel(struct clsoftc *sc, int channel);
void	clputc(struct clsoftc *sc, int unit, u_char c);

struct cfattach cl_ca = {
	sizeof(struct clsoftc), clprobe, clattach
};

struct cfdriver cl_cd = {
	NULL, "cl", DV_TTY
};

#if 0
#define CLCDBUF 80
void cloutput(struct tty *tp);
#endif

#define CL_UNIT(x) (minor(x) >> 2)
#define CL_CHANNEL(x) (minor(x) & 3)

struct tty *
cltty(dev)
	dev_t dev;
{
	int unit, channel;
	struct clsoftc *sc;

	unit = CL_UNIT(dev);
	if (unit >= cl_cd.cd_ndevs ||
	    (sc = (struct clsoftc *)cl_cd.cd_devs[unit]) == NULL) {
		return NULL;
	}
	channel = CL_CHANNEL(dev);
	return sc->sc_cl[channel].tty;
}

int
clprobe(parent, self, aux)
	struct device *parent;
	void *self;
	void *aux;
{
	struct confargs *ca = aux;
	bus_space_handle_t ioh;
	int rc;

	if (brdtyp == BRD_188)
		return 0;

	/*
	 * We do not accept empty locators here...
	 */
	if (ca->ca_paddr == CD2400_BASE_ADDR ||
	    (ca->ca_paddr == CD2400_SECONDARY_ADDR && brdtyp == BRD_8120)) {
		if (bus_space_map(ca->ca_iot, ca->ca_paddr, CD2400_SIZE,
		    0, &ioh) != 0)
			return 0;
		rc = badaddr((vaddr_t)bus_space_vaddr(ca->ca_iot, ioh), 1);
		bus_space_unmap(ca->ca_iot, ioh, CD2400_SIZE);
		return rc == 0;
	}

	return 0;
}

void
clattach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	struct clsoftc *sc = (struct clsoftc *)self;
	struct confargs *ca = aux;
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	int i;

	if (ca->ca_ipl < 0)
		ca->ca_ipl = IPL_TTY;

	iot = sc->sc_iot = ca->ca_iot;
	if (bus_space_map(iot, ca->ca_paddr, CD2400_SIZE, 0, &ioh) != 0) {
		printf(": can't map registers!\n");
		return;
	}
	sc->sc_ioh = ioh;
	sc->sc_pcctwo = (struct pcctwosoftc *)parent;

	if (ca->ca_paddr == CD2400_BASE_ADDR) {
		/*
		 * Although we are still running using the BUG routines,
		 * this device will be elected as the console after
		 * autoconf. Mark it as such.
		 */
		sc->sc_cl[0].cl_consio = 1;
		printf(": console");
	} else {
		/* reset chip only if we are not console device */
		/* wait for GFRCR */
	}
	/* allow chip to settle before continuing */
	delay(800);

	/* set up global registers */
	bus_space_write_1(iot, ioh, CL_TPR, CL_TIMEOUT);
	bus_space_write_1(iot, ioh, CL_RPILR, 0x03);
	bus_space_write_1(iot, ioh, CL_TPILR, 0x02);
	bus_space_write_1(iot, ioh, CL_MPILR, 0x01);

#ifdef DO_MALLOC
	sc->sc_cl[0].rx[0] = (void *)(dvma_malloc(16 * CL_BUFSIZE));
#else
	/* XXX */
	if ((vaddr_t)ca->ca_paddr == CD2400_BASE_ADDR)
		sc->sc_cl[0].rx[0] = (void *)(&cl_dmabuf);
	else
		sc->sc_cl[0].rx[0] = (void *)(&cl_dmabuf1);
#endif
	sc->sc_cl[0].rx[1] = (void *)(((int)sc->sc_cl[0].rx[0]) + CL_BUFSIZE);
	sc->sc_cl[1].rx[0] = (void *)(((int)sc->sc_cl[0].rx[1]) + CL_BUFSIZE);
	sc->sc_cl[1].rx[1] = (void *)(((int)sc->sc_cl[1].rx[0]) + CL_BUFSIZE);

	sc->sc_cl[2].rx[0] = (void *)(((int)sc->sc_cl[1].rx[1]) + CL_BUFSIZE);
	sc->sc_cl[2].rx[1] = (void *)(((int)sc->sc_cl[2].rx[0]) + CL_BUFSIZE);
	sc->sc_cl[3].rx[0] = (void *)(((int)sc->sc_cl[2].rx[1]) + CL_BUFSIZE);
	sc->sc_cl[3].rx[1] = (void *)(((int)sc->sc_cl[3].rx[0]) + CL_BUFSIZE);

	sc->sc_cl[0].tx[0] = (void *)(((int)sc->sc_cl[3].rx[1]) + CL_BUFSIZE);
	sc->sc_cl[0].tx[1] = (void *)(((int)sc->sc_cl[0].tx[0]) + CL_BUFSIZE);
	sc->sc_cl[1].tx[0] = (void *)(((int)sc->sc_cl[0].tx[1]) + CL_BUFSIZE);
	sc->sc_cl[1].tx[1] = (void *)(((int)sc->sc_cl[1].tx[0]) + CL_BUFSIZE);

	sc->sc_cl[2].tx[0] = (void *)(((int)sc->sc_cl[1].tx[1]) + CL_BUFSIZE);
	sc->sc_cl[2].tx[1] = (void *)(((int)sc->sc_cl[2].tx[0]) + CL_BUFSIZE);
	sc->sc_cl[3].tx[0] = (void *)(((int)sc->sc_cl[2].tx[1]) + CL_BUFSIZE);
	sc->sc_cl[3].tx[1] = (void *)(((int)sc->sc_cl[3].tx[0]) + CL_BUFSIZE);
	for (i = 0; i < CLCD_PORTS_PER_CHIP; i++) {
#if 0
		int j;

		for (j = 0; j < 2 ; j++) {
			sc->sc_cl[i].rxp[j] = (void *)kvtop(sc->sc_cl[i].rx[j]);
			printf("cl[%d].rxbuf[%d] %x p %x\n",
			    i, j, sc->sc_cl[i].rx[j], sc->sc_cl[i].rxp[j]);
			sc->sc_cl[i].txp[j] = (void *)kvtop(sc->sc_cl[i].tx[j]);
			printf("cl[%d].txbuf[%d] %x p %x\n",
			    i, j, sc->sc_cl[i].tx[j], sc->sc_cl[i].txp[j]);
		}
#endif
#if 0
		sc->sc_cl[i].cl_rxmode =
			!(!((flags >> (i * CL_FLAG_BIT_PCH)) & 0x01));
		sc->sc_cl[i].cl_txmode =
			!(!((flags >> (i * CL_FLAG_BIT_PCH)) & 0x02));
		sc->sc_cl[i].cl_softchar =
			!(!((flags >> (i * CL_FLAG_BIT_PCH)) & 0x04));
#endif
		cl_initchannel(sc, i);
	}

	/* clear errors */
	bus_space_write_1(sc->sc_pcctwo->sc_iot, sc->sc_pcctwo->sc_ioh,
	    PCCTWO_SCCERR, 0x01);

	/* enable interrupts */
	sc->sc_ih_e.ih_fn = cl_rxintr;
	sc->sc_ih_e.ih_arg = sc;
	sc->sc_ih_e.ih_wantframe = 0;
	sc->sc_ih_e.ih_ipl = ca->ca_ipl;

	sc->sc_ih_m.ih_fn = cl_mintr;
	sc->sc_ih_m.ih_arg = sc;
	sc->sc_ih_m.ih_wantframe = 0;
	sc->sc_ih_m.ih_ipl = ca->ca_ipl;

	sc->sc_ih_t.ih_fn = cl_txintr;
	sc->sc_ih_t.ih_arg = sc;
	sc->sc_ih_t.ih_wantframe = 0;
	sc->sc_ih_t.ih_ipl = ca->ca_ipl;

	sc->sc_ih_r.ih_fn = cl_rxintr;
	sc->sc_ih_r.ih_arg = sc;
	sc->sc_ih_r.ih_wantframe = 0;
	sc->sc_ih_r.ih_ipl = ca->ca_ipl;

	snprintf(sc->sc_errintrname, sizeof sc->sc_errintrname,
	    "%s_err", self->dv_xname);
	snprintf(sc->sc_mxintrname, sizeof sc->sc_mxintrname,
	    "%s_mx", self->dv_xname);
	snprintf(sc->sc_rxintrname, sizeof sc->sc_rxintrname,
	    "%s_rx", self->dv_xname);
	snprintf(sc->sc_txintrname, sizeof sc->sc_txintrname,
	    "%s_tx", self->dv_xname);

	pcctwointr_establish(PCC2V_SCC_RXE, &sc->sc_ih_e, sc->sc_errintrname);
	pcctwointr_establish(PCC2V_SCC_M, &sc->sc_ih_m, sc->sc_mxintrname);
	pcctwointr_establish(PCC2V_SCC_TX, &sc->sc_ih_t, sc->sc_txintrname);
	pcctwointr_establish(PCC2V_SCC_RX, &sc->sc_ih_r, sc->sc_rxintrname);

	bus_space_write_1(sc->sc_pcctwo->sc_iot, sc->sc_pcctwo->sc_ioh,
	    PCCTWO_SCCICR, PCC2_IRQ_IEN | (ca->ca_ipl & PCC2_IRQ_IPL));
	bus_space_write_1(sc->sc_pcctwo->sc_iot, sc->sc_pcctwo->sc_ioh,
	    PCCTWO_SCCTX, PCC2_IRQ_IEN | (ca->ca_ipl & PCC2_IRQ_IPL));
	bus_space_write_1(sc->sc_pcctwo->sc_iot, sc->sc_pcctwo->sc_ioh,
	    PCCTWO_SCCRX, PCC2_IRQ_IEN | (ca->ca_ipl & PCC2_IRQ_IPL));

	printf("\n");
}

void
cl_initchannel(sc, channel)
	struct clsoftc *sc;
	int channel;
{
	int s;
	bus_space_tag_t iot;
	bus_space_handle_t ioh;

	iot = sc->sc_iot;
	ioh = sc->sc_ioh;

	/* set up option registers */
	sc->sc_cl[channel].tty = NULL;
	s = splhigh();

	bus_space_write_1(iot, ioh, CL_CAR, channel);
	bus_space_write_1(iot, ioh, CL_LIVR, PCC2_VECT + PCC2V_SCC_RXE);
	bus_space_write_1(iot, ioh, CL_IER, 0);

	if (sc->sc_cl[channel].cl_consio == 0) {
		bus_space_write_1(iot, ioh, CL_CMR, 0x02);
		bus_space_write_1(iot, ioh, CL_COR1, 0x17);
		bus_space_write_1(iot, ioh, CL_COR2, 0x00);
		bus_space_write_1(iot, ioh, CL_COR3, 0x02);
		bus_space_write_1(iot, ioh, CL_COR4, 0xec);
		bus_space_write_1(iot, ioh, CL_COR5, 0xec);
		bus_space_write_1(iot, ioh, CL_COR6, 0x00);
		bus_space_write_1(iot, ioh, CL_COR7, 0x00);
		bus_space_write_1(iot, ioh, CL_SCHR1, 0x00);
		bus_space_write_1(iot, ioh, CL_SCHR2, 0x00);
		bus_space_write_1(iot, ioh, CL_SCHR3, 0x00);
		bus_space_write_1(iot, ioh, CL_SCHR4, 0x00);
		bus_space_write_1(iot, ioh, CL_SCRL, 0x00);
		bus_space_write_1(iot, ioh, CL_SCRH, 0x00);
		bus_space_write_1(iot, ioh, CL_LNXT, 0x00);
		bus_space_write_1(iot, ioh, CL_RBPR, 0x40);	/* 9600 */
		bus_space_write_1(iot, ioh, CL_RCOR, 0x01);
		bus_space_write_1(iot, ioh, CL_TBPR, 0x40);	/* 9600 */
		bus_space_write_1(iot, ioh, CL_TCOR, 0x01 << 5);
		/* console port should be 0x88 already */
		bus_space_write_1(iot, ioh, CL_MSVR_RTS, 0x00);
		bus_space_write_1(iot, ioh, CL_MSVR_DTR, 0x00);
		bus_space_write_1(iot, ioh, CL_RTPRL, CL_RX_TIMEOUT);
		bus_space_write_1(iot, ioh, CL_RTPRH, 0x00);
	}
	bus_space_write_1(iot, ioh, CL_CCR, 0x20);
	while (bus_space_read_1(iot, ioh, CL_CCR) != 0)
		;

	splx(s);
}


int cldefaultrate = TTYDEF_SPEED;

int
clmctl(dev, bits, how)
	dev_t dev;
	int bits;
	int how;
{
	struct clsoftc *sc;
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	int s;

	/* should only be called with valid device */
	sc = (struct clsoftc *)cl_cd.cd_devs[CL_UNIT(dev)];
	iot = sc->sc_iot;
	ioh = sc->sc_ioh;

	/* settings are currently ignored */
	s = splcl();
	switch (how) {
	case DMSET:
		if (bits & TIOCM_RTS)
			bus_space_write_1(iot, ioh, CL_MSVR_RTS, 0x01);
		else
			bus_space_write_1(iot, ioh, CL_MSVR_RTS, 0x00);
		if (bits & TIOCM_DTR)
			bus_space_write_1(iot, ioh, CL_MSVR_DTR, 0x02);
		else
			bus_space_write_1(iot, ioh, CL_MSVR_DTR, 0x00);
		break;

	case DMBIC:
		if (bits & TIOCM_RTS)
			bus_space_write_1(iot, ioh, CL_MSVR_RTS, 0x00);
		if (bits & TIOCM_DTR)
			bus_space_write_1(iot, ioh, CL_MSVR_DTR, 0x00);
		break;

	case DMBIS:
		if (bits & TIOCM_RTS)
			bus_space_write_1(iot, ioh, CL_MSVR_RTS, 0x01);
		if (bits & TIOCM_DTR)
			bus_space_write_1(iot, ioh, CL_MSVR_DTR, 0x02);
		break;

	case DMGET:
		bits = 0;

		{
			u_int8_t msvr;

			msvr = bus_space_read_1(iot, ioh, CL_MSVR_RTS);
			if (msvr & 0x80)
				bits |= TIOCM_DSR;
			if (msvr & 0x40)
				bits |= TIOCM_CD;
			if (msvr & 0x20)
				bits |= TIOCM_CTS;
			if (msvr & 0x10)
				bits |= TIOCM_DTR;
			if (msvr & 0x02)
				bits |= TIOCM_DTR;
			if (msvr & 0x01)
				bits |= TIOCM_RTS;
		}
		break;
	}
	splx(s);
#if 0
	bits = 0;
	/* proper defaults? */
	bits |= TIOCM_DTR;
	bits |= TIOCM_RTS;
	bits |= TIOCM_CTS;
	bits |= TIOCM_CD;
	/*	bits |= TIOCM_RI; */
	bits |= TIOCM_DSR;
#endif

	return bits;
}

int
clopen(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
{
	int s, unit, channel;
	struct cl_info *cl;
	struct clsoftc *sc;
	struct tty *tp;

	unit = CL_UNIT(dev);
	if (unit >= cl_cd.cd_ndevs ||
	    (sc = (struct clsoftc *)cl_cd.cd_devs[unit]) == NULL) {
		return ENODEV;
	}

	channel = CL_CHANNEL(dev);
	cl = &sc->sc_cl[channel];

	s = splcl();
	if (cl->tty) {
		tp = cl->tty;
	} else {
		tp = cl->tty = ttymalloc(0);
	}
	tp->t_oproc = clstart;
	tp->t_param = clparam;
	tp->t_dev = dev;

	if ((tp->t_state & TS_ISOPEN) == 0) {
		tp->t_state |= TS_WOPEN;
		ttychars(tp);
		if (tp->t_ispeed == 0) {
			/*
			 * only when cleared do we reset to defaults.
			 */
			tp->t_iflag = TTYDEF_IFLAG;
			tp->t_oflag = TTYDEF_OFLAG;
			tp->t_lflag = TTYDEF_LFLAG;
			tp->t_ispeed = tp->t_ospeed = cldefaultrate;

			if (sc->sc_cl[channel].cl_consio != 0) {
				/* console is 8N1 */
				tp->t_cflag = (CREAD | CS8 | HUPCL);
			} else {
				tp->t_cflag = TTYDEF_CFLAG;
			}
		}
		/*
		 * do these all the time
		 */
		if (cl->cl_swflags & TIOCFLAG_CLOCAL)
			tp->t_cflag |= CLOCAL;
		if (cl->cl_swflags & TIOCFLAG_CRTSCTS)
			tp->t_cflag |= CRTSCTS;
		if (cl->cl_swflags & TIOCFLAG_MDMBUF)
			tp->t_cflag |= MDMBUF;
		clparam(tp, &tp->t_termios);
		ttsetwater(tp);

		(void)clmctl(dev, TIOCM_DTR | TIOCM_RTS, DMSET);
#ifdef XXX
		if ((cl->cl_swflags & TIOCFLAG_SOFTCAR) ||
			(clmctl(dev, 0, DMGET) & TIOCM_CD)) {
			tp->t_state |= TS_CARR_ON;
		} else {
			tp->t_state &= ~TS_CARR_ON;
		}
#endif
		tp->t_state |= TS_CARR_ON;
		{
			u_int8_t save;

			save = bus_space_read_1(sc->sc_iot, sc->sc_ioh, CL_CAR);
			bus_space_write_1(sc->sc_iot, sc->sc_ioh, CL_CAR,
			    channel);
			bus_space_write_1(sc->sc_iot, sc->sc_ioh, CL_IER, 0x88);
			bus_space_write_1(sc->sc_iot, sc->sc_ioh, CL_CAR,
			    save);
		}
	} else if (tp->t_state & TS_XCLUDE && suser(p, 0) != 0) {
		splx(s);
		return EBUSY;
	}
	splx(s);

	/*
	 * Reset the tty pointer, as there could have been a dialout
	 * use of the tty with a dialin open waiting.
	 */
	tp->t_dev = dev;
#ifdef DEBUG
	cl_dumpport(sc, channel);
#endif
	return (*linesw[tp->t_line].l_open)(dev, tp, p);
}

int
clparam(tp, t)
	struct tty *tp;
	struct termios *t;
{
	int unit, channel;
	struct clsoftc *sc;
	int s;
	dev_t dev;

	dev = tp->t_dev;
	unit = CL_UNIT(dev);
	if (unit >= cl_cd.cd_ndevs ||
	    (sc = (struct clsoftc *)cl_cd.cd_devs[unit]) == NULL) {
		return ENODEV;
	}
	channel = CL_CHANNEL(dev);
	tp->t_ispeed = t->c_ispeed;
	tp->t_ospeed = t->c_ospeed;
	tp->t_cflag = t->c_cflag;
	clccparam(sc, t, channel);
	s = splcl();
	cl_unblock(tp);
	splx(s);
	return 0;
}

#if 0
void
cloutput(tp)
	struct tty *tp;
{
	int cc, s, unit, cnt;
	u_char *tptr;
	int channel;
	struct clsoftc *sc;
	dev_t dev;
	u_char cl_obuffer[CLCDBUF+1];

	dev = tp->t_dev;
	unit = CL_UNIT(dev);
	if (unit >= cl_cd.cd_ndevs ||
	    (sc = (struct clsoftc *)cl_cd.cd_devs[unit]) == NULL) {
		return;
	}
	channel = CL_CHANNEL(dev);

	if ((tp->t_state & TS_ISOPEN) == 0)
		return;

	s = splcl();
	cc = tp->t_outq.c_cc;
	while (cc > 0) {
/*XXX*/
		cnt = min (CLCDBUF,cc);
		cnt = q_to_b(&tp->t_outq, cl_obuffer, cnt);
		if (cnt == 0) {
			break;
		}
		for (tptr = cl_obuffer; tptr < &cl_obuffer[cnt]; tptr++) {
			clputc(sc, channel, *tptr);
		}
		cc -= cnt;
	}
	splx(s);
}
#endif

int
clclose(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
{
	int unit, channel;
	struct tty *tp;
	struct cl_info *cl;
	struct clsoftc *sc;
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	int s;

	unit = CL_UNIT(dev);
	if (unit >= cl_cd.cd_ndevs ||
	    (sc = (struct clsoftc *)cl_cd.cd_devs[unit]) == NULL) {
		return ENODEV;
	}
	channel = CL_CHANNEL(dev);
	cl = &sc->sc_cl[channel];
	iot = sc->sc_iot;
	ioh = sc->sc_ioh;
	tp = cl->tty;
	(*linesw[tp->t_line].l_close)(tp, flag, p);

	s = splcl();
	bus_space_write_1(iot, ioh, CL_CAR, channel);
	if (cl->cl_consio == 0 && (tp->t_cflag & HUPCL) != 0) {
		bus_space_write_1(iot, ioh, CL_MSVR_RTS, 0x00);
		bus_space_write_1(iot, ioh, CL_MSVR_DTR, 0x00);
		bus_space_write_1(iot, ioh, CL_CCR, 0x05);
	}


	splx(s);
	ttyclose(tp);

#if 0
	cl->tty = NULL;
#endif
#ifdef DEBUG
	cl_dumpport(sc, channel);
#endif

	return 0;
}

int
clread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	int unit, channel;
	struct tty *tp;
	struct cl_info *cl;
	struct clsoftc *sc;
	unit = CL_UNIT(dev);
	if (unit >= cl_cd.cd_ndevs ||
	    (sc = (struct clsoftc *)cl_cd.cd_devs[unit]) == NULL) {
		return ENODEV;
	}
	channel = CL_CHANNEL(dev);
	cl = &sc->sc_cl[channel];
	tp = cl->tty;
	if (tp == NULL)
		return ENXIO;
	return (*linesw[tp->t_line].l_read)(tp, uio, flag);
}

int
clwrite(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	int unit, channel;
	struct tty *tp;
	struct cl_info *cl;
	struct clsoftc *sc;
	unit = CL_UNIT(dev);
	if (unit >= cl_cd.cd_ndevs ||
	    (sc = (struct clsoftc *)cl_cd.cd_devs[unit]) == NULL) {
		return ENODEV;
	}
	channel = CL_CHANNEL(dev);
	cl = &sc->sc_cl[channel];
	tp = cl->tty;
	if (tp == NULL)
		return ENXIO;
	return (*linesw[tp->t_line].l_write)(tp, uio, flag);
}

int
clioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	int error;
	int unit, channel;
	struct tty *tp;
	struct cl_info *cl;
	struct clsoftc *sc;
	unit = CL_UNIT(dev);
	if (unit >= cl_cd.cd_ndevs ||
	    (sc = (struct clsoftc *)cl_cd.cd_devs[unit]) == NULL) {
		return ENODEV;
	}
	channel = CL_CHANNEL(dev);
	cl = &sc->sc_cl[channel];
	tp = cl->tty;
	if (tp == NULL)
		return ENXIO;

	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
	if (error >= 0)
		return error;

	error = ttioctl(tp, cmd, data, flag, p);
	if (error >= 0)
		return error;

	switch (cmd) {
	case TIOCSBRK:
		/* */
		break;

	case TIOCCBRK:
		/* */
		break;

	case TIOCSDTR:
		(void) clmctl(dev, TIOCM_DTR | TIOCM_RTS, DMBIS);
		break;

	case TIOCCDTR:
		(void) clmctl(dev, TIOCM_DTR | TIOCM_RTS, DMBIC);
		break;

	case TIOCMSET:
		(void) clmctl(dev, *(int *) data, DMSET);
		break;

	case TIOCMBIS:
		(void) clmctl(dev, *(int *) data, DMBIS);
		break;

	case TIOCMBIC:
		(void) clmctl(dev, *(int *) data, DMBIC);
		break;

	case TIOCMGET:
		*(int *)data = clmctl(dev, 0, DMGET);
		break;
	case TIOCGFLAGS:
		*(int *)data = cl->cl_swflags;
		break;
	case TIOCSFLAGS:
		error = suser(p, 0);
		if (error != 0)
			return EPERM;

		cl->cl_swflags = *(int *)data;
		cl->cl_swflags &= /* only allow valid flags */
			(TIOCFLAG_SOFTCAR | TIOCFLAG_CLOCAL | TIOCFLAG_CRTSCTS);
		break;
	default:
		return ENOTTY;
	}

	return 0;
}

int
clstop(tp, flag)
	struct tty *tp;
	int flag;
{
	int s;

	s = splcl();
	if (tp->t_state & TS_BUSY) {
		if ((tp->t_state & TS_TTSTOP) == 0)
			tp->t_state |= TS_FLUSH;
	}
	splx(s);
	return 0;
}

void
clcnprobe(cp)
	struct consdev *cp;
{
	int maj;

	/* bomb if it'a a MVME188 */
	if (brdtyp == BRD_188 || badaddr(CD2400_BASE_ADDR, 1) != 0)
		return;

	/* do not attach as console if cl has been disabled */
	if (cl_cd.cd_ndevs == 0 || cl_cd.cd_devs[0] == NULL)
		return;

	/* locate the major number */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == clopen)
			break;
	if (maj == nchrdev)
		return;

	cp->cn_dev = makedev(maj, 0);
	cp->cn_pri = CN_LOWPRI;
}

void
clcninit(cp)
	struct consdev *cp;
{
	struct clsoftc *sc;

	sc = (struct clsoftc *)cl_cd.cd_devs[0];
	cl_cons.cl_iot = sc->sc_iot;
	cl_cons.cl_ioh = sc->sc_ioh;
	cl_cons.cl_rxiack = (void *)(sc->sc_pcctwo->sc_base + PCCTWO_SCCRXIACK);
}

int
cl_instat(sc)
	struct clsoftc *sc;
{
	u_int8_t rir;

	if (sc == NULL)
		rir = bus_space_read_1(cl_cons.cl_iot, cl_cons.cl_ioh, CL_RIR);
	else
		rir = bus_space_read_1(sc->sc_iot, sc->sc_ioh, CL_RIR);

	return (rir & 0x40);
}

int
clcngetc(dev)
	dev_t dev;
{
	u_int8_t val, reoir, licr, data;
	int got_char = 0;
	u_int8_t ier_old;
	bus_space_tag_t iot;
	bus_space_handle_t ioh;

	iot = cl_cons.cl_iot;
	ioh = cl_cons.cl_ioh;

	bus_space_write_1(iot, ioh, CL_CAR, 0);
	ier_old = bus_space_read_1(iot, ioh, CL_IER);
	if ((ier_old & 0x08) == 0) {
		bus_space_write_1(iot, ioh, CL_IER, 0x08);
	} else
		ier_old = 0xff;

	while (got_char == 0) {
		val = bus_space_read_1(iot, ioh, CL_RIR);
		/* if no receive interrupt pending wait */
		if ((val & 0x80) == 0)
			continue;

		/* XXX do we need to suck the entire FIFO contents? */
		reoir = *cl_cons.cl_rxiack; /* receive PIACK */
		licr = bus_space_read_1(iot, ioh, CL_LICR);
		/* is the interrupt for us? (port 0) */
		if (((licr >> 2) & 0x3) == 0) {
			(void)bus_space_read_1(iot, ioh, CL_RISRL);
			(void)bus_space_read_1(iot, ioh, CL_RFOC);
			data = bus_space_read_1(iot, ioh, CL_RDR);
			if (ier_old != 0xff)
				bus_space_write_1(iot, ioh, CL_IER, ier_old);
			got_char = 1;
		} else {
			/* read and discard the character */
			data = bus_space_read_1(iot, ioh, CL_RDR);
		}
		bus_space_write_1(iot, ioh, CL_TEOIR, 0x00);
	}

	return data;
}

void
clcnputc(dev, c)
	dev_t dev;
	u_char c;
{
	clputc(0, 0, c);
}

void
clcnpollc(dev, on)
	dev_t dev;
	int on;
{
	if (on != 0) {
		/* enable polling */
	} else {
		/* disable polling */
	}
}

void
clputc(sc, unit, c)
	struct clsoftc *sc;
	int unit;
	u_char c;
{
	u_int8_t schar;
	u_int8_t oldchannel;
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	int s;

	if (sc == NULL) {
		/* output on console */
		iot = cl_cons.cl_iot;
		ioh = cl_cons.cl_ioh;
	} else {
		iot = sc->sc_iot;
		ioh = sc->sc_ioh;
	}

	s = splhigh();
	oldchannel = bus_space_read_1(iot, ioh, CL_CAR);
	bus_space_write_1(iot, ioh, CL_CAR, unit);
	if (unit == 0) {
		schar = bus_space_read_1(iot, ioh, CL_SCHR3);
		/* send special char, number 3 */
		bus_space_write_1(iot, ioh, CL_SCHR3, c);
		bus_space_write_1(iot, ioh, CL_STCR, 0x08 | 3);
		while (bus_space_read_1(iot, ioh, CL_STCR) != 0) {
			/* wait until cl notices the command
			 * otherwise it may not notice the character
			 * if we send characters too fast.
			 */
		}
		DELAY(5);
		bus_space_write_1(iot, ioh, CL_SCHR3, schar);
	} else {
		if (bus_space_read_1(iot, ioh, CL_TFTC) != 0)
			bus_space_write_1(iot, ioh, CL_TDR, c);
	}
	bus_space_write_1(iot, ioh, CL_CAR, oldchannel);
	splx(s);
}

int
clccparam(sc, par, channel)
	struct clsoftc *sc;
	struct termios *par;
	int channel;
{
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	u_int divisor, clk, clen;
	int s, imask, ints;

	iot = sc->sc_iot;
	ioh = sc->sc_ioh;

	s = splcl();
	bus_space_write_1(iot, ioh, CL_CAR, channel);
	if (par->c_ospeed == 0) {
		/* dont kill the console */
		if (sc->sc_cl[channel].cl_consio == 0) {
			/* disconnect, drop RTS DTR stop receiver */
			bus_space_write_1(iot, ioh, CL_MSVR_RTS, 0x00);
			bus_space_write_1(iot, ioh, CL_MSVR_DTR, 0x00);
			bus_space_write_1(iot, ioh, CL_CCR, 0x05);
		}
		splx(s);
		return 0xff;
	}

	bus_space_write_1(iot, ioh, CL_MSVR_RTS, 0x03);
	bus_space_write_1(iot, ioh, CL_MSVR_DTR, 0x03);

	divisor = cl_clkdiv(par->c_ospeed);
	clk	= cl_clknum(par->c_ospeed);
	bus_space_write_1(iot, ioh, CL_TBPR, divisor);
	bus_space_write_1(iot, ioh, CL_TCOR, clk << 5);
	divisor = cl_clkdiv(par->c_ispeed);
	clk	= cl_clknum(par->c_ispeed);
	bus_space_write_1(iot, ioh, CL_RBPR, divisor);
	bus_space_write_1(iot, ioh, CL_RCOR, clk);
	bus_space_write_1(iot, ioh, CL_RTPRL, cl_clkrxtimeout(par->c_ispeed));
	bus_space_write_1(iot, ioh, CL_RTPRH, 0x00);

	switch (par->c_cflag & CSIZE) {
	case CS5:
		clen = 4; /* this is the mask for the chip. */
		imask = 0x1F;
		break;
	case CS6:
		clen = 5;
		imask = 0x3F;
		break;
	case CS7:
		clen = 6;
		imask = 0x7F;
		break;
	default:
		clen = 7;
		imask = 0xFF;
	}

	bus_space_write_1(iot, ioh, CL_COR3, par->c_cflag & PARENB ? 4 : 2);

	{
		u_int8_t cor1;
		if (par->c_cflag & PARENB) {
			if (par->c_cflag & PARODD) {
				cor1 = 0xE0 | clen ; /* odd */
			} else {
				cor1 = 0x40 | clen ; /* even */
			}
		} else {
			cor1 = 0x10 | clen; /* ignore parity */
		}

		if (bus_space_read_1(iot, ioh, CL_COR1) != cor1) {
			bus_space_write_1(iot, ioh, CL_COR1, cor1);
			bus_space_write_1(iot, ioh, CL_CCR, 0x20);
			while (bus_space_read_1(iot, ioh, CL_CCR) != 0)
				;
		}
	}

	if (sc->sc_cl[channel].cl_consio == 0 && (par->c_cflag & CREAD) == 0)
		bus_space_write_1(iot, ioh, CL_CCR, 0x08);
	else
		bus_space_write_1(iot, ioh, CL_CCR, 0x0a);

	while (bus_space_read_1(iot, ioh, CL_CCR) != 0)
		;

	ints = 0;
#define SCC_DSR 0x80
#define SCC_DCD 0x40
#define SCC_CTS 0x20
	if ((par->c_cflag & CLOCAL) == 0) {
		ints |= SCC_DCD;
	}
	if ((par->c_cflag & CCTS_OFLOW) != 0) {
		ints |= SCC_CTS;
	}
	if ((par->c_cflag & CRTSCTS) != 0) {
		ints |= SCC_CTS;
	}
#ifdef DONT_LET_HARDWARE
	if ((par->c_cflag & CCTS_IFLOW) != 0) {
		ints |= SCC_DSR;
	}
#endif
	bus_space_write_1(iot, ioh, CL_COR4, ints | CL_FIFO_CNT);
	bus_space_write_1(iot, ioh, CL_COR5, ints | CL_FIFO_CNT);

	splx(s);

	return imask;
}

static int clknum = 0;

u_int8_t
cl_clkdiv(speed)
	int speed;
{
	int i;

	if (cl_clocks[clknum].speed == speed)
		return cl_clocks[clknum].divisor;

	for  (i = 0; cl_clocks[i].speed != 0; i++) {
		if (cl_clocks[i].speed == speed) {
			clknum = i;
			return cl_clocks[clknum].divisor;
		}
	}

	/* return some sane value if unknown speed */
	return cl_clocks[CL_SAFE_CLOCK].divisor;
}

u_int8_t
cl_clknum(speed)
	int speed;
{
	int i;

	if (cl_clocks[clknum].speed == speed)
		return cl_clocks[clknum].clock;

	for (i = 0; cl_clocks[i].speed != 0; i++) {
		if (cl_clocks[clknum].speed == speed) {
			clknum = i;
			return cl_clocks[clknum].clock;
		}
	}

	/* return some sane value if unknown speed */
	return cl_clocks[CL_SAFE_CLOCK].clock;
}

u_int8_t
cl_clkrxtimeout(speed)
	int speed;
{
	int i;

	if (cl_clocks[clknum].speed == speed)
		return cl_clocks[clknum].rx_timeout;

	for  (i = 0; cl_clocks[i].speed != 0; i++) {
		if (cl_clocks[i].speed == speed) {
			clknum = i;
			return cl_clocks[clknum].rx_timeout;
		}
	}

	/* return some sane value if unknown speed */
	return cl_clocks[CL_SAFE_CLOCK].rx_timeout;
}

void
cl_unblock(tp)
	struct tty *tp;
{
	tp->t_state &= ~TS_FLUSH;
	if (tp->t_outq.c_cc != 0)
		clstart(tp);
}

void
clstart(tp)
	struct tty *tp;
{
	dev_t dev;
	struct clsoftc *sc;
	int channel, unit, s;
#if 0
	int cnt;
	u_int8_t cbuf;
#endif

	dev = tp->t_dev;
	channel = CL_CHANNEL(dev);
/* hack to test output on non console only */
#if 0
	if (channel == 0) {
		cloutput(tp);
		return;
	}
#endif
	unit = CL_UNIT(dev);
	if (unit >= cl_cd.cd_ndevs ||
	    (sc = (struct clsoftc *)cl_cd.cd_devs[unit]) == NULL) {
		return;
	}

	if ((tp->t_state & TS_ISOPEN) == 0)
		return;

	s = splcl();
#if 0
	if (sc->sc_cl[channel].transmitting == 1) {
		/* i'm busy, go away, I will get to it later. */
		splx(s);
		return;
	}
	cnt = q_to_b(&tp->t_outq, &cbuf, 1);
	if ( cnt != 0 ) {
		sc->sc_cl[channel].transmitting = 1;
		bus_space_write_1(sc->sc_iot, sc->sc_ioh, CL_CAR, channel);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh, CL_TDR, cbuf);
	} else {
		sc->sc_cl[channel].transmitting = 0;
	}
#else
	if ((tp->t_state & (TS_TIMEOUT | TS_BUSY | TS_TTSTOP | TS_FLUSH)) == 0)
	{
		tp->t_state |= TS_BUSY;
		bus_space_write_1(sc->sc_iot, sc->sc_ioh, CL_CAR, channel);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh, CL_IER,
		    bus_space_read_1(sc->sc_iot, sc->sc_ioh, CL_IER) | 0x03);
	}
#endif
	splx(s);
}

int
cl_mintr(arg)
	void *arg;
{
	struct clsoftc *sc = arg;
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	u_int8_t mir, misr, msvr;
	int channel;

	iot = sc->sc_iot;
	ioh = sc->sc_ioh;

	mir = bus_space_read_1(iot, ioh, CL_MIR);
	if ((mir & 0x40) == 0) {
		return 0;
	}

	channel = mir & 0x03;
	misr = bus_space_read_1(iot, ioh, CL_MISR);
	msvr = bus_space_read_1(iot, ioh, CL_MSVR_RTS);
	if (misr & 0x01) {
		/* timers are not currently used?? */
		log(LOG_WARNING, "cl_mintr: channel %x timer 1 unexpected\n",channel);
	}
	if (misr & 0x02) {
		/* timers are not currently used?? */
		log(LOG_WARNING, "cl_mintr: channel %x timer 2 unexpected\n",channel);
	}
	if (misr & 0x20) {
#ifdef DEBUG
		log(LOG_WARNING, "cl_mintr: channel %x cts %x\n",channel,
		    ((msvr & 0x20) != 0x0)
		);
#endif
	}
	if (misr & 0x40) {
		struct tty *tp = sc->sc_cl[channel].tty;
#ifdef DEBUG
		log(LOG_WARNING, "cl_mintr: channel %x cd %x\n",channel,
		    ((msvr & 0x40) != 0x0)
		);
#endif
		(*linesw[tp->t_line].l_modem)(tp, ((msvr & 0x40) != 0x0) );
	}
	if (misr & 0x80) {
#ifdef DEBUG
		log(LOG_WARNING, "cl_mintr: channel %x dsr %x\n",channel,
		((msvr & 0x80) != 0x0)
		);
#endif
	}
	bus_space_write_1(iot, ioh, CL_MEOIR, 0);
	return 1;
}

int
cl_txintr(arg)
	void *arg;
{
	static int empty;
	struct clsoftc *sc = arg;
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	u_int8_t tir, cmr, teoir;
	u_int8_t max;
	int channel;
	struct tty *tp;
	int cnt;
	u_char buffer[CL_FIFO_MAX +1];

	iot = sc->sc_iot;
	ioh = sc->sc_ioh;
	tir = bus_space_read_1(iot, ioh, CL_TIR);
	if ((tir & 0x40) == 0) {
		return 0;
	}

	channel = tir & 0x03;
	sc->sc_cl[channel].txcnt ++;

	cmr = bus_space_read_1(iot, ioh, CL_CMR);

	tp = sc->sc_cl[channel].tty;
	if (tp == NULL || (tp->t_state & TS_ISOPEN) == 0) {
		bus_space_write_1(iot, ioh, CL_IER,
		    bus_space_read_1(iot, ioh, CL_IER) & ~0x03);
		bus_space_write_1(iot, ioh, CL_TEOIR, 0x08);
		return 1;
	}

	switch (cmr & CL_TXMASK) {
	case CL_TXDMAINT:
	{
		u_int8_t dmabsts;
		int nbuf, busy, resid;
		void *pbuffer;

		dmabsts = bus_space_read_1(iot, ioh, CL_DMABSTS);
		nbuf = ((dmabsts & 0x8) >> 3) & 0x1;
		busy = ((dmabsts & 0x4) >> 2) & 0x1;

		do {
			pbuffer = sc->sc_cl[channel].tx[nbuf];
			resid = tp->t_outq.c_cc;
			cnt = min (CL_BUFSIZE,resid);
			log(LOG_WARNING, "cl_txintr: resid %x cnt %x pbuf %p\n",
			    resid, cnt, pbuffer);
			if (cnt != 0) {
				cnt = q_to_b(&tp->t_outq, pbuffer, cnt);
				resid -= cnt;
				if (nbuf == 0) {
					bus_space_write_2(iot, ioh, CL_ATBADRU,
					    ((u_long)sc->sc_cl[channel].txp[nbuf]) >> 16);
					bus_space_write_2(iot, ioh, CL_ATBADRL,
					    ((u_long) sc->sc_cl[channel].txp[nbuf]) & 0xffff);
					bus_space_write_2(iot, ioh, CL_ATBCNT,
					    cnt);
					bus_space_write_1(iot, ioh, CL_ATBSTS,
					    0x43);
				} else {
					bus_space_write_2(iot, ioh, CL_BTBADRU,
					    ((u_long)sc->sc_cl[channel].txp[nbuf]) >> 16);
					bus_space_write_2(iot, ioh, CL_BTBADRL,
					    ((u_long) sc->sc_cl[channel].txp[nbuf]) & 0xffff);
					bus_space_write_2(iot, ioh, CL_BTBCNT,
					    cnt);
					bus_space_write_1(iot, ioh, CL_BTBSTS,
					    0x43);
				}
				teoir = 0x08;
			} else {
				teoir = 0x08;
				if (tp->t_state & TS_BUSY) {
					tp->t_state &= ~(TS_BUSY | TS_FLUSH);
					if (tp->t_state & TS_ASLEEP) {
						tp->t_state &= ~TS_ASLEEP;
						wakeup((caddr_t) &tp->t_outq);
					}
					selwakeup(&tp->t_wsel);
				}
				bus_space_write_1(iot, ioh, CL_IER,
				    bus_space_read_1(iot, ioh, CL_IER) & ~0x03);
			}
			nbuf = ~nbuf & 0x1;
			busy--;
		} while (resid != 0 && busy != -1);/* if not busy do other buffer */
	}
		break;
	case CL_TXINTR:
		max = bus_space_read_1(iot, ioh, CL_TFTC);
		cnt = min((int)max,tp->t_outq.c_cc);
		if (cnt != 0) {
			cnt = q_to_b(&tp->t_outq, buffer, cnt);
			empty = 0;
			bus_space_write_multi_1(iot, ioh, CL_TDR, buffer, cnt);
			teoir = 0x00;
		} else {
			if (empty > 5 && ((empty % 20000 )== 0)) {
				log(LOG_WARNING, "cl_txintr to many empty intr %d channel %d\n",
				    empty, channel);
			}
			empty++;
			teoir = 0x08;
			if (tp->t_state & TS_BUSY) {
				tp->t_state &= ~(TS_BUSY | TS_FLUSH);
				if (tp->t_state & TS_ASLEEP) {
					tp->t_state &= ~TS_ASLEEP;
					wakeup((caddr_t) &tp->t_outq);
				}
				selwakeup(&tp->t_wsel);
			}
			bus_space_write_1(iot, ioh, CL_IER,
			    bus_space_read_1(iot, ioh, CL_IER) & ~0x03);
		}
		break;
	default:
		log(LOG_WARNING, "cl_txintr unknown mode %x\n", cmr);
		/* we probably will go to hell quickly now */
		teoir = 0x08;
	}
	bus_space_write_1(iot, ioh, CL_TEOIR, teoir);
	return 1;
}

int
cl_rxintr(arg)
	void *arg;
{
	struct clsoftc *sc = arg;
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	u_int8_t rir, channel, cmr, risrl;
	u_int8_t fifocnt;
	struct tty *tp;
	int i;
	u_int8_t reoir;
	u_char buffer[CL_FIFO_MAX +1];
#ifdef DDB
	int wantddb = 0;
#endif

	iot = sc->sc_iot;
	ioh = sc->sc_ioh;

	rir = bus_space_read_1(iot, ioh, CL_RIR);
	if ((rir & 0x40) == 0x0) {
		return 0;
	}

	channel = rir & 0x3;
	cmr = bus_space_read_1(iot, ioh, CL_CMR);

	sc->sc_cl[channel].rxcnt ++;
	risrl = bus_space_read_1(iot, ioh, CL_RISRL);
	if (risrl & 0x80) {
		/* timeout, no characters */
	} else
	/* We don't need no stinkin special characters */
	if (risrl & 0x08) {
		cl_overflow(sc, channel, (long *)&sc->sc_fotime, "fifo");
	} else
	if (risrl & 0x04) {
		cl_parity(sc, channel);
	} else
	if (risrl & 0x02) {
		cl_frame(sc, channel);
	} else
	if (risrl & 0x01) {
#ifdef DDB
		if (sc->sc_cl[channel].cl_consio)
			wantddb = db_console;
#endif
		cl_break(sc, channel);
	}
	reoir = 0x08;

	switch (cmr & CL_RXMASK) {
	case CL_RXDMAINT:
	{
		int nbuf;
		u_int16_t cnt;
		int bufcomplete;
		u_int8_t status, dmabsts;
		u_int8_t risrh;

		risrh = bus_space_read_1(iot, ioh, CL_RISRH);
		dmabsts = bus_space_read_1(iot, ioh, CL_DMABSTS);
		nbuf = (risrh & 0x08) ? 1 : 0;
		bufcomplete = (risrh & 0x20) ? 1 : 0;
		if (nbuf == 0) {
			cnt = bus_space_read_2(iot, ioh, CL_ARBCNT);
			status = bus_space_read_1(iot, ioh, CL_ARBSTS);
		} else {
			cnt = bus_space_read_2(iot, ioh, CL_BRBCNT);
			status = bus_space_read_1(iot, ioh, CL_BRBSTS);
		}
#if USE_BUFFER
		cl_appendbufn(sc, channel, sc->rx[nbuf], cnt);
#else
		{
			int i;
			u_char *pbuf;

			tp = sc->sc_cl[channel].tty;
			pbuf = sc->sc_cl[channel].rx[nbuf];
			/* this should be done at off level */
			{
				u_int16_t rcbadru, rcbadrl;
				u_int8_t arbsts, brbsts;
				u_char *pbufs, *pbufe;

				rcbadru = bus_space_read_2(iot, ioh,
				    CL_RCBADRU);
				rcbadrl = bus_space_read_2(iot, ioh,
				    CL_RCBADRL);
				arbsts = bus_space_read_1(iot, ioh, CL_ARBSTS);
				brbsts = bus_space_read_1(iot, ioh, CL_BRBSTS);
				pbufs = sc->sc_cl[channel].rxp[nbuf];
				pbufe = (u_char *)(((u_long)rcbadru << 16) | (u_long)rcbadrl);
				cnt = pbufe - pbufs;
			}
			reoir = 0x0 | (bufcomplete) ? 0 : 0xd0;
			bus_space_write_1(iot, ioh, CL_REOIR, reoir);

			DELAY(10); /* give the chip a moment */

			for (i = 0; i < cnt; i++) {
				u_char c;
				c = pbuf[i];
				(*linesw[tp->t_line].l_rint)(c,tp);
			}
			/* this should be done at off level */
			if (nbuf == 0) {
				bus_space_write_2(iot, ioh, CL_ARBCNT,
				    CL_BUFSIZE);
				bus_space_write_2(iot, ioh, CL_ARBSTS, 0x01);
			} else {
				bus_space_write_2(iot, ioh, CL_BRBCNT,
				    CL_BUFSIZE);
				bus_space_write_2(iot, ioh, CL_BRBSTS, 0x01);
			}
		}
#endif
	}
		bus_space_write_1(iot, ioh, CL_REOIR, reoir);
		break;
	case CL_RXINTR:
		fifocnt = bus_space_read_1(iot, ioh, CL_RFOC);
		tp = sc->sc_cl[channel].tty;
		bus_space_read_multi_1(iot, ioh, CL_RDR, buffer, fifocnt);
		if (tp == NULL) {
			/* if the channel is not configured,
			 * dont send characters upstream.
			 * also fix problem with NULL dereference
			 */
			reoir = 0x00;
			break;
		}

		bus_space_write_1(iot, ioh, CL_REOIR, reoir);
		for (i = 0; i < fifocnt; i++) {
			u_char c;
			c = buffer[i];
#if USE_BUFFER
			cl_appendbuf(sc, channel, c);
#else
			/* does any restricitions exist on spl
			 * for this call
			 */
			(*linesw[tp->t_line].l_rint)(c,tp);
#endif
		}
		break;
	default:
		log(LOG_WARNING, "cl_rxintr unknown mode %x\n", cmr);
		/* we probably will go to hell quickly now */
		bus_space_write_1(iot, ioh, CL_REOIR, 0x08);
	}
#ifdef DDB
	if (wantddb != 0)
		Debugger();
#endif
	return 1;
}

void
cl_overflow(sc, channel, ptime, msg)
	struct clsoftc *sc;
	int channel;
	long *ptime;
	char *msg;
{
	log(LOG_WARNING, "%s[%d]: %s overrun\n", sc->sc_dev.dv_xname,
	    channel, msg);
}

void
cl_parity(sc, channel)
	struct clsoftc *sc;
	int channel;
{
	log(LOG_WARNING, "%s[%d]: parity error\n", sc->sc_dev.dv_xname,
	    channel);
}

void
cl_frame(sc, channel)
	struct clsoftc *sc;
	int channel;
{
	log(LOG_WARNING, "%s[%d]: frame error\n", sc->sc_dev.dv_xname,
	    channel);
}

void
cl_break(sc, channel)
	struct clsoftc *sc;
	int channel;
{
#ifdef DEBUG
	log(LOG_WARNING, "%s[%d]: break detected\n", sc->sc_dev.dv_xname,
	    channel);
#endif
}

#ifdef DEBUG
void
cl_dumpport(struct clsoftc *sc, int channel)
{
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	u_int8_t livr, cmr, cor1, cor2, cor3, cor4, cor5, cor6, cor7,
	    schr1, schr2, schr3, schr4, scrl, scrh, lnxt,
	    rbpr, rcor, tbpr, tcor, rpilr, rir, tpr, ier, ccr,
	    dmabsts, arbsts, brbsts, atbsts, btbsts,
	    csr, rts, dtr, rtprl, rtprh;
	u_int16_t rcbadru, rcbadrl, arbadru, arbadrl, arbcnt,
	    brbadru, brbadrl, brbcnt;
	u_int16_t tcbadru, tcbadrl, atbadru, atbadrl, atbcnt,
	    btbadru, btbadrl, btbcnt;
	int s;

	iot = sc->sc_iot;
	ioh = sc->sc_ioh;

	s = splcl();
	bus_space_write_1(iot, ioh, CL_CAR, channel);
	livr = bus_space_read_1(iot, ioh, CL_LIVR);
	cmr = bus_space_read_1(iot, ioh, CL_CMR);
	cor1 = bus_space_read_1(iot, ioh, CL_COR1);
	cor2 = bus_space_read_1(iot, ioh, CL_COR2);
	cor3 = bus_space_read_1(iot, ioh, CL_COR3);
	cor4 = bus_space_read_1(iot, ioh, CL_COR4);
	cor5 = bus_space_read_1(iot, ioh, CL_COR5);
	cor6 = bus_space_read_1(iot, ioh, CL_COR6);
	cor7 = bus_space_read_1(iot, ioh, CL_COR7);
	schr1 = bus_space_read_1(iot, ioh, CL_SCHR1);
	schr2 = bus_space_read_1(iot, ioh, CL_SCHR2);
	schr3 = bus_space_read_1(iot, ioh, CL_SCHR3);
	schr4 = bus_space_read_1(iot, ioh, CL_SCHR4);
	scrl = bus_space_read_1(iot, ioh, CL_SCRL);
	scrh = bus_space_read_1(iot, ioh, CL_SCRH);
	lnxt = bus_space_read_1(iot, ioh, CL_LNXT);
	rbpr = bus_space_read_1(iot, ioh, CL_RBPR);
	rcor = bus_space_read_1(iot, ioh, CL_RCOR);
	tbpr = bus_space_read_1(iot, ioh, CL_TBPR);
	rpilr = bus_space_read_1(iot, ioh, CL_RPILR);
	rir = bus_space_read_1(iot, ioh, CL_RIR);
	ier = bus_space_read_1(iot, ioh, CL_IER);
	ccr = bus_space_read_1(iot, ioh, CL_CCR);
	tcor = bus_space_read_1(iot, ioh, CL_TCOR);
	csr = bus_space_read_1(iot, ioh, CL_CSR);
	tpr = bus_space_read_1(iot, ioh, CL_TPR);
	rts = bus_space_read_1(iot, ioh, CL_MSVR_RTS);
	dtr = bus_space_read_1(iot, ioh, CL_MSVR_DTR);
	rtprl = bus_space_read_1(iot, ioh, CL_RTPRL);
	rtprh = bus_space_read_1(iot, ioh, CL_RTPRH);
	dmabsts = bus_space_read_1(iot, ioh, CL_DMABSTS);
	tcbadru = bus_space_read_2(iot, ioh, CL_TCBADRU);
	tcbadrl = bus_space_read_2(iot, ioh, CL_TCBADRL);
	rcbadru = bus_space_read_2(iot, ioh, CL_RCBADRU);
	rcbadrl = bus_space_read_2(iot, ioh, CL_RCBADRL);
	arbadru = bus_space_read_2(iot, ioh, CL_ARBADRU);
	arbadrl = bus_space_read_2(iot, ioh, CL_ARBADRL);
	arbcnt  = bus_space_read_2(iot, ioh, CL_ARBCNT);
	arbsts  = bus_space_read_1(iot, ioh, CL_ARBSTS);
	brbadru = bus_space_read_2(iot, ioh, CL_BRBADRU);
	brbadrl = bus_space_read_2(iot, ioh, CL_BRBADRL);
	brbcnt  = bus_space_read_2(iot, ioh, CL_BRBCNT);
	brbsts  = bus_space_read_1(iot, ioh, CL_BRBSTS);
	atbadru = bus_space_read_2(iot, ioh, CL_ATBADRU);
	atbadrl = bus_space_read_2(iot, ioh, CL_ATBADRL);
	atbcnt  = bus_space_read_2(iot, ioh, CL_ATBCNT);
	atbsts  = bus_space_read_1(iot, ioh, CL_ATBSTS);
	btbadru = bus_space_read_2(iot, ioh, CL_BTBADRU);
	btbadrl = bus_space_read_2(iot, ioh, CL_BTBADRL);
	btbcnt  = bus_space_read_2(iot, ioh, CL_BTBCNT);
	btbsts  = bus_space_read_1(iot, ioh, CL_BTBSTS);
	splx(s);

	printf("{ port %x livr %x cmr %x\n",
		  channel,livr,   cmr);
	printf("cor1 %x cor2 %x cor3 %x cor4 %x cor5 %x cor6 %x cor7 %x\n",
		cor1,   cor2,   cor3,   cor4,   cor5,   cor6,   cor7);
	printf("schr1 %x schr2 %x schr3 %x schr4 %x\n",
		schr1,   schr2,   schr3,   schr4);
	printf("scrl %x scrh %x lnxt %x\n",
		scrl,   scrh,   lnxt);
	printf("rbpr %x rcor %x tbpr %x tcor %x\n",
		rbpr,   rcor,   tbpr,   tcor);
	printf("rpilr %x rir %x ier %x ccr %x\n",
		rpilr,   rir,   ier,   ccr);
	printf("tpr %x csr %x rts %x dtr %x\n",
		tpr,   csr,   rts,   dtr);
	printf("rtprl %x rtprh %x\n",
		rtprl,   rtprh);
	printf("rxcnt %x txcnt %x\n",
		sc->sc_cl[channel].rxcnt, sc->sc_cl[channel].txcnt);
	printf("dmabsts %x, tcbadru %x, tcbadrl %x, rcbadru %x, rcbadrl %x,\n",
		dmabsts,    tcbadru,    tcbadrl,    rcbadru,    rcbadrl );
	printf("arbadru %x, arbadrl %x, arbcnt %x, arbsts %x\n",
		arbadru,    arbadrl,    arbcnt,    arbsts);
	printf("brbadru %x, brbadrl %x, brbcnt %x, brbsts %x\n",
		brbadru,    brbadrl,    brbcnt,    brbsts);
	printf("atbadru %x, atbadrl %x, atbcnt %x, atbsts %x\n",
		atbadru,    atbadrl,    atbcnt,    atbsts);
	printf("btbadru %x, btbadrl %x, btbcnt %x, btbsts %x\n",
		btbadru,    btbadrl,    btbcnt,    btbsts);
	printf("}\n");
}
#endif
@


1.60
log
@Do not invoke ttymodem() directly, but l_modem from the current linedisc.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.59 2010/06/28 14:13:29 deraadt Exp $ */
@


1.59
log
@Allow tty drivers to request larger buffers at attach time using a
max-baud-rate hint.  Adjust TTYHOG (the nearly full logic) to this new
situation.  The larger buffers are required by the very high speed
KDDI devices in Japan (CF com, or USB ucom) so those are the only two
drivers which currently ask for a larger buffer size.
ok yasuoka miod
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.58 2010/04/12 12:57:52 tedu Exp $ */
d1332 1
a1332 1
		ttymodem(tp, ((msvr & 0x40) != 0x0) );
@


1.58
log
@Some of the line disciplines want to check for suser.  Better to pass them
a process instead of using curproc.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.57 2009/11/09 17:53:39 nicm Exp $ */
d546 1
a546 1
		tp = cl->tty = ttymalloc();
@


1.57
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.56 2009/10/31 12:00:07 fgsch Exp $ */
d617 1
a617 1
	return (*linesw[tp->t_line].l_open)(dev, tp);
d713 1
a713 1
	(*linesw[tp->t_line].l_close)(tp, flag);
@


1.56
log
@Use suser when possible. Suggested by miod@@.
miod@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.55 2009/10/31 06:40:16 deraadt Exp $ */
a1428 1
					KNOTE(&tp->t_wsel.si_note, 0);
a1459 1
				KNOTE(&tp->t_wsel.si_note, 0);
@


1.55
log
@Add missing KNOTE() calls after selwakeup(), until we decide if the KNOTE()
calls can go directly into selwakeup() safely
long discussion with nicm, murmers of consent from tedu and miod, noone
else seems to care of kqueue is busted as long as it makes their sockets
move data fast... pretty sad.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.54 2009/05/31 12:25:53 miod Exp $ */
d603 1
a603 1
	} else if (tp->t_state & TS_XCLUDE && p->p_ucred->cr_uid != 0) {
@


1.54
log
@Fix definition of CL_FIFO_MAX to match what the hardware can do; this in
turn fixes a stack smash in cl_rxintr().
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.53 2008/01/23 16:37:57 jsing Exp $ */
d1429 1
d1461 1
@


1.53
log
@Cleanup cn_pri. Change constants to more meaningful names, rather than
the hp300 related ones currently in use. CN_NORMAL becomes CN_LOWPRI,
CN_INTERNAL becomes CN_MIDPRI and CN_REMOTE becomes CN_HIGHPRI.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.52 2006/05/08 14:36:10 miod Exp $ */
d58 1
a58 1
#define CL_FIFO_MAX	0x10
@


1.52
log
@Replace gazillions of badvaddr() or badwordaddr() calls with badaddr() calls.
With a few prototype declarations shuffling, this finally allows
<machine/locore.h> to die.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.51 2006/04/15 22:29:49 miod Exp $ */
d904 1
a904 1
	cp->cn_pri = CN_NORMAL;
@


1.51
log
@Invoke bus_space_unmap with the correct bus_space_handle_t upon attachment
failure.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.50 2006/01/01 11:59:39 miod Exp $ */
a41 1
#include <machine/locore.h>
d232 1
a232 1
		rc = badvaddr((vaddr_t)bus_space_vaddr(ca->ca_iot, ioh), 1);
@


1.50
log
@Let cons_init() and cons_init_bell() initialize the whole consdev structure,
thus removing the need for drivers to initialize cn_pri to CN_DEAD when
hardware probe fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.49 2005/01/25 12:13:22 miod Exp $ */
d234 1
a234 1
		bus_space_unmap(ca->ca_iot, ca->ca_paddr, CD2400_SIZE);
@


1.49
log
@Do not write anything when ignoring cl interrupts not for us; this kills
M8120, since cl0 and cl1 share the same interrupt, and cl1 would warn,
using cl0 as the console, and an infinite loop would occur.

Spotted by Christian Groessler, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.48 2004/07/30 19:02:05 miod Exp $ */
a887 2

	cp->cn_pri = CN_DEAD;
@


1.48
log
@Move evcount structures inside struct intrhand, this makes more sense and
gives us more counters in the process.

Also clean up intrhand structures and usage, especially move them to SLISTs.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.47 2004/07/02 14:00:42 miod Exp $ */
a1306 2
		/* only if intr is not shared? */
		log(LOG_WARNING, "cl_mintr extra intr\n");
a1366 2
		/* only if intr is not shared ??? */
		log(LOG_WARNING, "cl_txintr extra intr\n");
a1498 2
		/* only if intr is not shared ??? */
		log(LOG_WARNING, "cl_rxintr extra intr\n");
@


1.47
log
@Switch mvme88k to evcount, but keep maintaining intrcnt[] too for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.46 2004/07/02 11:19:58 miod Exp $ */
a37 1
#include <sys/evcount.h>
a111 6
	struct evcount		sc_txintrcnt;
	char			sc_txintrname[16 + 3];
	struct evcount		sc_rxintrcnt;
	char			sc_rxintrname[16 + 3];
	struct evcount		sc_mxintrcnt;
	char			sc_mxintrname[16 + 3];
d118 4
d361 13
a373 4
	pcctwointr_establish(PCC2V_SCC_RXE, &sc->sc_ih_e);
	pcctwointr_establish(PCC2V_SCC_M, &sc->sc_ih_m);
	pcctwointr_establish(PCC2V_SCC_TX, &sc->sc_ih_t);
	pcctwointr_establish(PCC2V_SCC_RX, &sc->sc_ih_r);
a381 13
	snprintf(sc->sc_txintrname, sizeof sc->sc_txintrname,
	    "%s_tx", self->dv_xname);
	evcount_attach(&sc->sc_txintrcnt, sc->sc_txintrname,
	    (void *)&sc->sc_ih_t.ih_ipl, &evcount_intr);
	snprintf(sc->sc_rxintrname, sizeof sc->sc_rxintrname,
	    "%s_rx", self->dv_xname);
	evcount_attach(&sc->sc_rxintrcnt, sc->sc_rxintrname,
	    (void *)&sc->sc_ih_r.ih_ipl, &evcount_intr);
	snprintf(sc->sc_mxintrname, sizeof sc->sc_mxintrname,
	    "%s_mx", self->dv_xname);
	evcount_attach(&sc->sc_mxintrcnt, sc->sc_mxintrname,
	    (void *)&sc->sc_ih_m.ih_ipl, &evcount_intr);

a1310 1
	sc->sc_mxintrcnt.ec_count++;
a1372 1
	sc->sc_txintrcnt.ec_count++;
d1507 1
a1507 1
	sc->sc_rxintrcnt.ec_count++;
@


1.46
log
@Be sure to fill intrhand structures correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.45 2004/04/29 16:20:02 miod Exp $ */
d38 1
d113 6
a118 3
	struct evcnt		sc_txintrcnt;
	struct evcnt		sc_rxintrcnt;
	struct evcnt		sc_mxintrcnt;
d376 12
a387 3
	evcnt_attach(&sc->sc_dev, "intr", &sc->sc_txintrcnt);
	evcnt_attach(&sc->sc_dev, "intr", &sc->sc_rxintrcnt);
	evcnt_attach(&sc->sc_dev, "intr", &sc->sc_mxintrcnt);
d1318 1
a1318 1
	sc->sc_mxintrcnt.ev_count++;
d1381 1
a1381 1
	sc->sc_txintrcnt.ev_count++;
d1516 1
a1516 1
	sc->sc_rxintrcnt.ev_count++;
@


1.45
log
@Bugfix sync with mvme68k:
- wait until all RX processing is over to invoke ddb upon break
- turn off the most annoying log() messages unless option DEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.44 2004/04/24 19:51:47 miod Exp $ */
d347 1
a347 1
	sc->sc_ih_e.ih_wantframe = 0;
d352 1
a352 1
	sc->sc_ih_e.ih_wantframe = 0;
d357 1
a357 1
	sc->sc_ih_e.ih_wantframe = 0;
@


1.44
log
@Preliminary switch to an mvme88k bus_space world. Not all drivers have been
converted yet, and they rely upon some linear mappings provided by bus_space.

In order to not impact performance, almost all the bus_space accesses go
through macros and inline functions. This currently restricts us to D16 and
D32 access modes, which are selected at compilation time. Since there are no
plans to support D8 vme devices in the future, this is acceptable for now.

This makes the "len" locator for vme devices go away, and allows to simplify
some code which was using the pcctwo device, and will now directly access
hardware which is known to exist, rather than wait until the device is
attached.

While there, try to enforce more interrupt vector number checks, since these
changes pointed out that dart(4) had been working correctly so far by sheer
luck only.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.43 2004/04/16 23:32:44 miod Exp $ */
d1319 1
d1323 1
d1327 1
d1331 1
d1335 1
d1339 1
d1490 3
a1505 1
	reoir = 0x08;
a1510 1
		reoir = 0x08;
d1512 1
a1512 1
	/* We don't need no sinkin special characters */
a1514 1
		reoir = 0x08;
a1517 1
		reoir = 0x08;
a1520 1
		reoir = 0x08;
d1523 4
a1527 1
		reoir = 0x08;
d1529 1
d1633 4
d1674 1
a1674 4
#ifdef DDB
	if (sc->sc_cl[channel].cl_consio && db_console != 0)
		Debugger();
#else
@


1.43
log
@Do not register console as CN_NORMAL priority if we are not in cdevsw[].

Also, in cl, print the correct device name instead of hardcoded cl0 in
various diagnostic/warning messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.42 2004/04/15 12:35:20 miod Exp $ */
d49 1
d71 4
a74 4
	void	*cl_paddr;
	struct clreg *volatile cl_vaddr;
	struct pcctworeg *volatile pcctwoaddr;
	u_char	channel;
d88 1
d90 1
d109 7
a115 8
	struct device	sc_dev;
	struct evcnt sc_txintrcnt;
	struct evcnt sc_rxintrcnt;
	struct evcnt sc_mxintrcnt;
	time_t	sc_rotime;	/* time of last ring overrun */
	time_t	sc_fotime;	/* time of last fifo overrun */
	u_char *pbase;
	struct clreg *cl_reg;
d121 1
a121 2
	struct pcctworeg		*sc_pcctwo;
	int			sc_flags;
d148 2
d153 3
a155 3
u_char cl_clkdiv(int speed);
u_char cl_clknum(int speed);
u_char cl_clkrxtimeout(int speed);
d170 1
a170 1
void cl_dumpport(int channel);
d176 2
a177 3
void cl_initchannel(struct clsoftc *sc, int channel);
void clputc(struct clsoftc *sc, int unit, u_char c);
u_char clgetc(struct clsoftc *sc, int *channel);
d205 1
a205 1
		return (NULL);
a216 1
	struct clreg *cl_reg;
d218 2
d222 1
a222 1
		return (0);
d227 9
a235 5
	if ((vaddr_t)ca->ca_paddr == CD2400_BASE_ADDR ||
	    ((vaddr_t)ca->ca_paddr == CD2400_SECONDARY_ADDR &&
	     brdtyp == BRD_8120)) {
		ca->ca_ipl = IPL_TTY;
		ca->ca_vaddr = ca->ca_paddr;
d237 1
a237 4
		cl_reg = (struct clreg *)ca->ca_vaddr;
		return (!badvaddr((vaddr_t)&cl_reg->cl_gfrcr, 1));
	} else
		return (0);
d248 2
d252 10
a261 2
	sc->cl_reg = (struct clreg *)ca->ca_vaddr;
	sc->sc_pcctwo = ca->ca_master;
d263 1
a263 1
	if ((paddr_t)ca->ca_paddr == CD2400_BASE_ADDR) {
d270 1
a270 1
		printf(": console ");
d275 2
a276 2
        /* allow chip to settle before continuing */
        delay(800);
d279 4
a282 4
	sc->cl_reg->cl_tpr = CL_TIMEOUT;
	sc->cl_reg->cl_rpilr = 0x03;
	sc->cl_reg->cl_tpilr = 0x02;
	sc->cl_reg->cl_mpilr = 0x01;
d334 5
d360 11
a370 11
	intr_establish(PCC2_VECT + SRXEIRQ, &sc->sc_ih_e);
	intr_establish(PCC2_VECT + SMOIRQ, &sc->sc_ih_m);
	intr_establish(PCC2_VECT + STxIRQ, &sc->sc_ih_t);
	intr_establish(PCC2_VECT + SRxIRQ, &sc->sc_ih_r);
	sc->sc_pcctwo = ca->ca_master;
	sc->sc_pcctwo->pcc2_sccerr = 0x01; /* clear errors */

	/* enable all interrupts at ca_ipl */
	sc->sc_pcctwo->pcc2_sccirq = 0x10 | (ca->ca_ipl & 0x7);
	sc->sc_pcctwo->pcc2_scctx  = 0x10 | (ca->ca_ipl & 0x7);
	sc->sc_pcctwo->pcc2_sccrx  = 0x10 | (ca->ca_ipl & 0x7);
d375 1
d385 6
a390 1
	struct clreg *cl_reg = sc->cl_reg;
d394 25
a418 24
	cl_reg->cl_car	= (u_char) channel;
	cl_reg->cl_livr	= PCC2_VECT + 0xc;/* set vector base at 5C */
	cl_reg->cl_ier	= 0x00;
	/* if the port is not the console, should be init for all ports??*/
	if (sc->sc_cl[channel].cl_consio != 1) {
		cl_reg->cl_cmr	= 0x02;
		cl_reg->cl_cor1	= 0x17;
		cl_reg->cl_cor2	= 0x00;
		cl_reg->cl_cor3	= 0x02;
		cl_reg->cl_cor4	= 0xec;
		cl_reg->cl_cor5	= 0xec;
		cl_reg->cl_cor6	= 0x00;
		cl_reg->cl_cor7	= 0x00;
		cl_reg->cl_schr1	= 0x00;
		cl_reg->cl_schr2	= 0x00;
		cl_reg->cl_schr3	= 0x00;
		cl_reg->cl_schr4	= 0x00;
		cl_reg->cl_scrl	= 0x00;
		cl_reg->cl_scrh	= 0x00;
		cl_reg->cl_lnxt	= 0x00;
		cl_reg->cl_rbpr	= 0x40; /* 9600 */
		cl_reg->cl_rcor	= 0x01;
		cl_reg->cl_tbpr	= 0x40; /* 9600 */
		cl_reg->cl_tcor	= 0x01 << 5;
d420 8
a427 8
		cl_reg->cl_msvr_rts	= 0x00;
		cl_reg->cl_msvr_dtr	= 0x00;
		cl_reg->cl_rtprl	= CL_RX_TIMEOUT;
		cl_reg->cl_rtprh	= 0x00;
	}
	sc->cl_reg->cl_ccr = 0x20;
	while (sc->cl_reg->cl_ccr != 0) {
	}
d441 3
d445 1
a445 1
	struct clsoftc *sc;
d447 4
a450 4
	sc = (struct clsoftc *) cl_cd.cd_devs[CL_UNIT(dev)];
	/*
	printf("mctl: dev %x, bits %x, how %x,\n",dev, bits, how);
	*/
d455 8
a462 10
		if( bits & TIOCM_RTS) {
			sc->cl_reg->cl_msvr_rts = 0x01;
		} else {
			sc->cl_reg->cl_msvr_rts = 0x00;
		}
		if( bits & TIOCM_DTR) {
			sc->cl_reg->cl_msvr_dtr = 0x02;
		} else {
			sc->cl_reg->cl_msvr_dtr = 0x00;
		}
d466 4
a469 6
		if( bits & TIOCM_RTS) {
			sc->cl_reg->cl_msvr_rts = 0x00;
		}
		if( bits & TIOCM_DTR) {
			sc->cl_reg->cl_msvr_dtr = 0x00;
		}
d473 4
a476 6
		if( bits & TIOCM_RTS) {
			sc->cl_reg->cl_msvr_rts = 0x01;
		}
		if( bits & TIOCM_DTR) {
			sc->cl_reg->cl_msvr_dtr = 0x02;
		}
d483 4
a486 3
			u_char msvr;
			msvr = sc->cl_reg->cl_msvr_rts;
			if( msvr & 0x80) {
d488 1
a488 2
			}
			if( msvr & 0x40) {
d490 1
a490 2
			}
			if( msvr & 0x20) {
d492 1
a492 2
			}
			if( msvr & 0x10) {
d494 1
a494 2
			}
			if( msvr & 0x02) {
d496 1
a496 2
			}
			if( msvr & 0x01) {
a497 1
			}
d513 1
a513 4
	/*
	printf("retbits %x\n", bits);
	*/
	return(bits);
d530 2
a531 2
		(sc = (struct clsoftc *) cl_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
d533 1
d536 1
d559 1
a559 1
			if(sc->sc_cl[channel].cl_consio == 1) {
d589 8
a596 47
			u_char save = sc->cl_reg->cl_car;
			sc->cl_reg->cl_car = channel;
			sc->cl_reg->cl_ier	= 0x88;
#ifdef CL_DMA_WORKS
			{
			sc->cl_reg->cl_cmr	=
				/* CL_TXDMAINT | */ CL_RXDMAINT;
			sc->cl_reg->cl_ier	= 0xa8;
			sc->cl_reg->cl_licr	= 0x00;
			}
			sc->cl_reg->cl_arbadrl	=
				((u_long)sc->sc_cl[channel].rxp[0]) & 0xffff;
			sc->cl_reg->cl_arbadru	=
				((u_long)sc->sc_cl[channel].rxp[0]) >> 16;
			sc->cl_reg->cl_brbadrl	=
				((u_long)sc->sc_cl[channel].rxp[1]) & 0xffff;
			sc->cl_reg->cl_brbadru	=
				((u_long)sc->sc_cl[channel].rxp[1]) >> 16;
			sc->cl_reg->cl_atbadrl	=
				((u_long)sc->sc_cl[channel].txp[0]) & 0xffff;
			sc->cl_reg->cl_atbadru	=
				((u_long)sc->sc_cl[channel].txp[0]) >> 16;
			sc->cl_reg->cl_btbadrl	=
				((u_long)sc->sc_cl[channel].txp[1]) & 0xffff;
			sc->cl_reg->cl_btbadru	=
				((u_long)sc->sc_cl[channel].txp[1]) >> 16;
			sc->cl_reg->cl_arbcnt	= CL_BUFSIZE;
			sc->cl_reg->cl_brbcnt	= CL_BUFSIZE;
			sc->cl_reg->cl_arbsts	= 0x01;
			sc->cl_reg->cl_brbsts	= 0x01;
if (channel == 2) { /* test one channel now */
			/* shift for tx DMA */
			/* no shift for rx DMA */
#if 0
			/* tx only */
			sc->cl_reg->cl_licr	= (CL_DMAMODE << 4);
			sc->cl_reg->cl_cmr	= 0x42;
#endif
		/* rx only */
			sc->cl_reg->cl_licr	= 0x00;
			sc->cl_reg->cl_cmr	= 0x82;
}
			sc->cl_reg->cl_ccr = 0x20;
			while (sc->cl_reg->cl_ccr != 0) {
			}
#endif /* CL_DMA_WORKS */
			sc->cl_reg->cl_car = save;
d600 1
a600 1
		return(EBUSY);
d602 1
a602 7
#ifdef XXX
	/*
	 * if NONBLOCK requested, ignore carrier
	 */
	if (flag & O_NONBLOCK)
	goto done;
#endif
a603 1
	splx(s);
d610 1
a610 1
	cl_dumpport(channel);
d612 1
a612 1
	return((*linesw[tp->t_line].l_open)(dev, tp));
d628 2
a629 2
		(sc = (struct clsoftc *) cl_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
d657 1
a657 1
		(sc = (struct clsoftc *) cl_cd.cd_devs[unit]) == NULL) {
d694 2
d697 1
d700 2
a701 2
		(sc = (struct clsoftc *) cl_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
d705 2
d711 6
a717 6
	sc->cl_reg->cl_car = channel;
	if(cl->cl_consio == 0 && (tp->t_cflag & HUPCL) != 0) {
		sc->cl_reg->cl_msvr_rts = 0x00;
		sc->cl_reg->cl_msvr_dtr = 0x00;
		sc->cl_reg->cl_ccr = 0x05;
	}
d726 1
a726 1
	cl_dumpport(channel);
d744 2
a745 2
		(sc = (struct clsoftc *) cl_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
d750 1
a750 1
	if (!tp)
d752 1
a752 1
	return((*linesw[tp->t_line].l_read)(tp, uio, flag));
d767 2
a768 2
		(sc = (struct clsoftc *) cl_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
d773 1
a773 1
	if (!tp)
d775 1
a775 1
	return((*linesw[tp->t_line].l_write)(tp, uio, flag));
d793 2
a794 2
		(sc = (struct clsoftc *) cl_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
d799 1
a799 1
	if (!tp)
d804 1
a804 1
		return(error);
d808 1
a808 1
		return(error);
d848 1
a848 1
			return(EPERM);
d855 1
a855 1
		return(ENOTTY);
a876 7
/*
 * clcn* stuff happens before configure() runs kicking off
 * autoconfig. Use a virtual mapping set up in locore till
 * the device is actually configured. Need mappings for
 * pcc2 space and Cirrus chip area.
 */

d889 4
d908 1
a908 1
	struct clreg *volatile cl_reg;
d910 4
a913 33
	cl_cons.cl_paddr = (void *)CD2400_BASE_ADDR;
	cl_cons.cl_vaddr   = (struct clreg *)IIOV(cl_cons.cl_paddr);
	cl_cons.pcctwoaddr = (void *)IIOV(0xfff42000);
	cl_reg = cl_cons.cl_vaddr;
	/* reset the chip? */
#ifdef CLCD_DO_RESET
#endif
	/* set up globals */
#ifdef NOT_ALREADY_SETUP
	cl_reg->cl_tftc  = 0x10;
	cl_reg->cl_tpr   = CL_TIMEOUT; /* is this correct?? */
	cl_reg->cl_rpilr = 0x03;
	cl_reg->cl_tpilr = 0x02;
	cl_reg->cl_mpilr = 0x01;

	/* set up the tty00 to be 9600 8N1 */
	cl_reg->cl_car   = 0x00;
	cl_reg->cl_cor1  = 0x17;	/* No parity, ignore parity, 8 bit char */
	cl_reg->cl_cor2  = 0x00;
	cl_reg->cl_cor3  = 0x02;	/* 1 stop bit */
	cl_reg->cl_cor4  = 0x00;
	cl_reg->cl_cor5  = 0x00;
	cl_reg->cl_cor6  = 0x00;
	cl_reg->cl_cor7  = 0x00;
	cl_reg->cl_schr1 = 0x00;
	cl_reg->cl_schr2 = 0x00;
	cl_reg->cl_schr3 = 0x00;
	cl_reg->cl_schr4 = 0x00;
	cl_reg->cl_scrl  = 0x00;
	cl_reg->cl_scrh  = 0x00;
	cl_reg->cl_lnxt  = 0x00;
	cl_reg->cl_cpsr  = 0x00;
#endif
d920 8
a927 7
	struct clreg *volatile cl_reg;
	if ( NULL == sc) {
		cl_reg = cl_cons.cl_vaddr;
	} else {
		cl_reg = sc->cl_reg;
	}
	return (cl_reg->cl_rir & 0x40);
d934 1
a934 4
	u_char val, reoir, licr, isrl, data = 0, fifo_cnt;
#if 0
	u_char status;
#endif
d936 13
a948 8
	u_char ier_old = 0xff;
	struct clreg *volatile cl_reg = cl_cons.cl_vaddr;
	struct pcctworeg *volatile pcc2_base = cl_cons.pcctwoaddr;
	cl_reg->cl_car = 0;
	if (!(cl_reg->cl_ier & 0x08)) {
		ier_old = cl_reg->cl_ier;
		cl_reg->cl_ier	= 0x08;
	}
d951 1
a951 1
		val = cl_reg->cl_rir;
d953 1
a953 1
		if (!(val & 0x80)) {
d955 1
a955 1
		}
d957 3
a959 2
		reoir = pcc2_base->pcc2_sccrxiack; /* receive PIACK */
		licr = cl_reg->cl_licr;
d961 5
a965 23
			/* is the interrupt for us (port 0) */
			/* the character is for us yea. */
			isrl = cl_reg->cl_risrl;
#if 0
			if (isrl & 0x01) {
				status = BREAK;
			}
			if (isrl & 0x02) {
				status = FRAME;
			}
			if (isrl & 0x04) {
				status = PARITY;
			}
			if (isrl & 0x08) {
				status = OVERFLOW;
			}
			/* we do not have special characters ;-) */
#endif
			fifo_cnt = cl_reg->cl_rfoc;
			data = cl_reg->cl_rdr;
			if (ier_old != 0xff) {
				cl_reg->cl_ier  = ier_old;
			}
a966 1
			cl_reg->cl_teoir = 0x00;
d968 2
a969 2
			data = cl_reg->cl_rdr;
			cl_reg->cl_teoir = 0x00;
d971 1
d990 1
a990 1
	if (1 == on) {
a994 1
	return;
d1003 4
d1008 2
a1009 4
	u_char schar;
	u_char oldchannel;
	struct clreg *volatile cl_reg;
	if (0 == sc) {
d1011 2
a1012 1
		cl_reg = cl_cons.cl_vaddr;
d1014 2
a1015 1
		cl_reg = sc->cl_reg;
d1017 4
a1020 14
#ifdef NEW_CLCD_STRUCT
	/* should we disable, flush and all that goo? */
	cl->car = unit;
	schar = cl->schr3;
	cl->schr3 = c;
	cl->stcr = 0x08 | 0x03; /* send special char, char 3 */
	while (0 != cl->stcr) {
		/* wait until cl notices the command
		 * otherwise it may not notice the character
		 * if we send characters too fast.
		 */
	}
	cl->schr3 = schar;
#else
d1022 5
a1026 7
		s = splhigh();
		oldchannel = cl_reg->cl_car;
		cl_reg->cl_car = unit;
		schar = cl_reg->cl_schr3;
		cl_reg->cl_schr3 = c;
		cl_reg->cl_stcr = 0x08 | 0x03; /* send special char, char 3 */
		while (0 != cl_reg->cl_stcr) {
d1033 1
a1033 3
		cl_reg->cl_schr3 = schar;
		cl_reg->cl_car = oldchannel;
		splx(s);
d1035 2
a1036 8
		s = splhigh();
		oldchannel = cl_reg->cl_car;
		cl_reg->cl_car = unit;
		if (cl_reg->cl_tftc > 0) {
			cl_reg->cl_tdr = c;
		}
		cl_reg->cl_car = oldchannel;
		splx(s);
d1038 2
a1039 55
#endif
	return;
}

u_char
clgetc(sc, channel)
	struct clsoftc *sc;
	int *channel;
{
	struct clreg *volatile cl_reg;
	struct pcctworeg *volatile pcc2_base;
	u_char val, reoir, licr, isrl, fifo_cnt, data;
	if (0 == sc) {
		cl_reg = cl_cons.cl_vaddr;
		pcc2_base = cl_cons.pcctwoaddr;
	} else {
		cl_reg = sc->cl_reg;
		pcc2_base = sc->sc_pcctwo;
	}
	val = cl_reg->cl_rir;
	/* if no receive interrupt pending wait */
	if (!(val & 0x80)) {
		return 0;
	}
	/* XXX do we need to suck the entire FIFO contents? */
	reoir = pcc2_base->pcc2_sccrxiack; /* receive PIACK */
	licr = cl_reg->cl_licr;
	*channel = (licr >> 2) & 0x3;
	/* is the interrupt for us (port 0) */
	/* the character is for us yea. */
	isrl = cl_reg->cl_risrl;
#if 0
	if (isrl & 0x01) {
		status = BREAK;
	}
	if (isrl & 0x02) {
		status = FRAME;
	}
	if (isrl & 0x04) {
		status = PARITY;
	}
	if (isrl & 0x08) {
		status = OVERFLOW;
	}
	/* we do not have special characters ;-) */
#endif
	fifo_cnt = cl_reg->cl_rfoc;
	if (fifo_cnt > 0) {
		data = cl_reg->cl_rdr;
		cl_reg->cl_teoir = 0x00;
	} else {
		data = 0;
		cl_reg->cl_teoir = 0x08;
	}
	return data;
d1048 2
d1053 3
d1057 1
a1057 1
	sc->cl_reg->cl_car = channel;
d1060 1
a1060 1
		if(sc->sc_cl[channel].cl_consio == 0) {
d1062 3
a1064 3
			sc->cl_reg->cl_msvr_rts = 0x00;
			sc->cl_reg->cl_msvr_dtr = 0x00;
			sc->cl_reg->cl_ccr = 0x05;
d1067 1
a1067 1
		return (0xff);
d1070 2
a1071 2
	sc->cl_reg->cl_msvr_rts = 0x03;
	sc->cl_reg->cl_msvr_dtr = 0x03;
d1075 2
a1076 2
	sc->cl_reg->cl_tbpr = divisor;
	sc->cl_reg->cl_tcor = clk << 5;
d1079 4
a1082 4
	sc->cl_reg->cl_rbpr = divisor;
	sc->cl_reg->cl_rcor = clk;
	sc->cl_reg->cl_rtprl = cl_clkrxtimeout(par->c_ispeed);
	sc->cl_reg->cl_rtprh = 0x00;
d1101 2
a1102 1
	sc->cl_reg->cl_cor3 = par->c_cflag & PARENB ? 4 : 2;
d1105 1
a1105 1
		u_char cor1;
d1115 6
a1120 5
		if (sc->cl_reg->cl_cor1 != cor1) {
			sc->cl_reg->cl_cor1 = cor1;
			sc->cl_reg->cl_ccr = 0x20;
			while (sc->cl_reg->cl_ccr != 0) {
			}
d1124 8
a1131 9
	if (sc->sc_cl[channel].cl_consio == 0
		&& (par->c_cflag & CREAD) == 0 )
	{
		sc->cl_reg->cl_ccr = 0x08;
	} else {
		sc->cl_reg->cl_ccr = 0x0a;
	}
	while (sc->cl_reg->cl_ccr != 0) {
	}
d1150 2
a1151 2
	sc->cl_reg->cl_cor4 = ints | CL_FIFO_CNT;
	sc->cl_reg->cl_cor5 = ints | CL_FIFO_CNT;
d1154 1
d1160 1
a1160 1
u_char
d1164 3
a1166 2
	int i = 0;
	if (cl_clocks[clknum].speed == speed) {
d1168 1
a1168 1
	}
d1175 1
d1177 1
a1177 1
	return cl_clocks[4].divisor;
d1180 1
a1180 1
u_char
d1184 3
a1186 3
	int found = 0;
	int i = 0;
	if (cl_clocks[clknum].speed == speed) {
d1188 2
a1189 2
	}
	for  (i = 0; found != 0 && cl_clocks[i].speed != 0; i++) {
d1195 1
d1197 1
a1197 1
	return cl_clocks[4].clock;
d1200 1
a1200 1
u_char
d1204 3
a1206 2
	int i = 0;
	if (cl_clocks[clknum].speed == speed) {
d1208 1
a1208 1
	}
d1215 1
d1217 1
a1217 1
	return cl_clocks[4].rx_timeout;
d1238 1
a1238 1
	u_char cbuf;
d1252 1
a1252 1
		(sc = (struct clsoftc *) cl_cd.cd_devs[unit]) == NULL) {
d1269 2
a1270 2
		sc->cl_reg->cl_car = channel;
		sc->cl_reg->cl_tdr = cbuf;
d1278 3
a1280 2
		sc->cl_reg->cl_car = channel;
		sc->cl_reg->cl_ier = sc->cl_reg->cl_ier | 0x3;
a1283 1
	return;
d1291 4
d1296 2
a1297 2
	u_char mir, misr, msvr;
	int channel;
d1299 2
a1300 1
	if(((mir = sc->cl_reg->cl_mir) & 0x40) == 0x0) {
d1308 2
a1309 2
	misr = sc->cl_reg->cl_misr;
	msvr = sc->cl_reg->cl_msvr_rts;
d1320 1
a1320 1
		((msvr & 0x20) != 0x0)
d1326 1
a1326 1
		((msvr & 0x40) != 0x0)
d1335 1
a1335 1
	sc->cl_reg->cl_meoir = 0x00;
d1343 1
d1345 4
a1348 4

	static int empty = 0;
	u_char tir, cmr, teoir;
	u_char max;
d1353 5
a1357 2
	u_char *tptr;
	if (((tir = sc->cl_reg->cl_tir) & 0x40) == 0x0) {
d1365 1
a1365 1
	cmr     = sc->cl_reg->cl_cmr;
d1367 1
a1367 1
	sc->sc_cl[channel].txcnt ++;
d1371 3
a1373 2
		sc->cl_reg->cl_ier = sc->cl_reg->cl_ier & ~0x3;
		sc->cl_reg->cl_teoir = 0x08;
d1376 1
d1379 27
a1405 35
		{
			u_char dmabsts;
			int nbuf, busy, resid;
			void *pbuffer;
			dmabsts = sc->cl_reg->cl_dmabsts;
			log(LOG_WARNING, "cl_txintr: DMAMODE channel %x dmabsts %x\n",
			    channel, dmabsts);
			nbuf = ((dmabsts & 0x8) >> 3) & 0x1;
			busy = ((dmabsts & 0x4) >> 2) & 0x1;

			do {
				pbuffer = sc->sc_cl[channel].tx[nbuf];
				resid = tp->t_outq.c_cc;
				cnt = min (CL_BUFSIZE,resid);
				log(LOG_WARNING, "cl_txintr: resid %x cnt %x pbuf %p\n",
				    resid, cnt, pbuffer);
				if (cnt != 0) {
					cnt = q_to_b(&tp->t_outq, pbuffer, cnt);
					resid -= cnt;
					if (nbuf == 0) {
						sc->cl_reg->cl_atbadru =
						((u_long) sc->sc_cl[channel].txp[nbuf]) >> 16;
						sc->cl_reg->cl_atbadrl =
						((u_long) sc->sc_cl[channel].txp[nbuf]) & 0xffff;
						sc->cl_reg->cl_atbcnt = cnt;
						sc->cl_reg->cl_atbsts = 0x43;
					} else {
						sc->cl_reg->cl_btbadru =
						((u_long) sc->sc_cl[channel].txp[nbuf]) >> 16;
						sc->cl_reg->cl_btbadrl =
						((u_long) sc->sc_cl[channel].txp[nbuf]) & 0xffff;
						sc->cl_reg->cl_btbcnt = cnt;
						sc->cl_reg->cl_btbsts = 0x43;
					}
					teoir = 0x08;
d1407 17
a1423 8
					teoir = 0x08;
					if (tp->t_state & TS_BUSY) {
						tp->t_state &= ~(TS_BUSY | TS_FLUSH);
						if (tp->t_state & TS_ASLEEP) {
							tp->t_state &= ~TS_ASLEEP;
							wakeup((caddr_t) &tp->t_outq);
						}
						selwakeup(&tp->t_wsel);
d1425 1
a1425 1
					sc->cl_reg->cl_ier = sc->cl_reg->cl_ier & ~0x3;
d1427 7
a1433 5
				nbuf = ~nbuf & 0x1;
				busy--;
			} while (resid != 0 && busy != -1);/* if not busy do other buffer */
			log(LOG_WARNING, "cl_txintr: done\n");
		}
d1436 2
a1437 2
		max = sc->cl_reg->cl_tftc;
		cnt = min ((int)max,tp->t_outq.c_cc);
d1441 1
a1441 3
			for (tptr = buffer; tptr < &buffer[cnt]; tptr++) {
				sc->cl_reg->cl_tdr = *tptr;
			}
d1458 2
a1459 1
			sc->cl_reg->cl_ier = sc->cl_reg->cl_ier & ~0x3;
d1467 1
a1467 1
	sc->cl_reg->cl_teoir = teoir;
d1476 4
a1479 3

	u_char rir, channel, cmr, risrl;
	u_char fifocnt;
d1482 1
a1482 1
	u_char reoir;
d1485 5
a1489 2
	rir = sc->cl_reg->cl_rir;
	if((rir & 0x40) == 0x0) {
d1496 1
a1496 1
	cmr = sc->cl_reg->cl_cmr;
d1500 1
a1500 1
	risrl = sc->cl_reg->cl_risrl;
d1507 1
a1507 1
		cl_overflow (sc, channel, (long *)&sc->sc_fotime, "fifo");
d1525 18
a1542 24
		{
			int nbuf;
			u_short cnt;
			int bufcomplete;
			u_char status, dmabsts;
			u_char risrh = sc->cl_reg->cl_risrh;
			dmabsts = sc->cl_reg->cl_dmabsts;
#ifdef DMA_DEBUG
log(LOG_WARNING, "cl_txintr: DMAMODE channel %x dmabsts %x risrl %x risrh %x\n",
	channel, dmabsts, risrl, risrh);
#endif
			nbuf = (risrh & 0x08) ? 1 : 0;
			bufcomplete = (risrh & 0x20) ? 1 : 0;
			if (nbuf == 0) {
				cnt  = sc->cl_reg->cl_arbcnt;
				status =  sc->cl_reg->cl_arbsts;
			} else {
				cnt  = sc->cl_reg->cl_brbcnt;
				status =  sc->cl_reg->cl_brbsts;
			}
#ifdef DMA_DEBUG
			log(LOG_WARNING, "cl_rxintr: 1channel %x buf %x cnt %x status %x\n",
			    channel, nbuf, cnt, status);
#endif
d1544 1
a1544 1
			cl_appendbufn(sc, channel, sc->rx[nbuf], cnt);
d1546 7
d1554 24
a1577 40
				int i;
				u_char *pbuf;
				tp = sc->sc_cl[channel].tty;
				pbuf = sc->sc_cl[channel].rx[nbuf];
				/* this should be done at off level */
				{
					u_short rcbadru, rcbadrl;
					u_char arbsts, brbsts;
					u_char *pbufs, *pbufe;
					rcbadru = sc->cl_reg->cl_rcbadru;
					rcbadrl = sc->cl_reg->cl_rcbadrl;
					arbsts =  sc->cl_reg->cl_arbsts;
					brbsts =  sc->cl_reg->cl_brbsts;
					pbufs = sc->sc_cl[channel].rxp[nbuf];
					pbufe = (u_char *)(((u_long)rcbadru << 16) | (u_long)rcbadrl);
					cnt = pbufe - pbufs;
#ifdef DMA_DEBUG
					log(LOG_WARNING, "cl_rxintr: rcbadru %x rcbadrl %x arbsts %x brbsts %x cnt %x\n",
					    rcbadru, rcbadrl, arbsts, brbsts, cnt);
#endif
#ifdef DMA_DEBUG1
					log(LOG_WARNING, "cl_rxintr: buf %x cnt %x\n",
					    nbuf, cnt);
#endif
				}
				reoir = 0x0 | (bufcomplete) ? 0 : 0xd0;
				sc->cl_reg->cl_reoir = reoir;
#ifdef DMA_DEBUG
				log(LOG_WARNING, "cl_rxintr: reoir %x\n", reoir);
#endif
				delay(10); /* give the chip a moment */
#ifdef DMA_DEBUG
				log(LOG_WARNING, "cl_rxintr: 2channel %x buf %x cnt %x status %x\n",
				    channel, nbuf, cnt, status);
#endif
				for (i = 0; i < cnt; i++) {
					u_char c;
					c = pbuf[i];
					(*linesw[tp->t_line].l_rint)(c,tp);
				}
d1579 8
a1586 7
				if (nbuf == 0) {
					sc->cl_reg->cl_arbcnt = CL_BUFSIZE;
					sc->cl_reg->cl_arbsts = 0x01;
				} else {
					sc->cl_reg->cl_brbcnt = CL_BUFSIZE;
					sc->cl_reg->cl_brbsts = 0x01;
				}
d1588 1
d1590 2
a1591 2
		}
		sc->cl_reg->cl_reoir = reoir;
d1594 1
a1594 1
		fifocnt = sc->cl_reg->cl_rfoc;
d1596 2
a1597 4
		for (i = 0; i < fifocnt; i++) {
			buffer[i] = sc->cl_reg->cl_rdr;
		}
		if (NULL == tp) {
d1606 1
a1606 1
		sc->cl_reg->cl_reoir = reoir;
d1623 1
a1623 1
		sc->cl_reg->cl_reoir = 0x08;
d1673 1
a1673 2
cl_dumpport(channel)
	int channel;
d1675 11
a1685 14
	u_char	livr, cmr, cor1, cor2, cor3, cor4, cor5, cor6, cor7,
		schr1, schr2, schr3, schr4, scrl, scrh, lnxt,
		rbpr, rcor, tbpr, tcor, rpilr, rir, tpr, ier, ccr,
		dmabsts, arbsts, brbsts, atbsts, btbsts,
		csr, rts, dtr, rtprl, rtprh;
	void *volatile parbadru, *volatile parbadrl,
	     *volatile parbsts, *volatile parbcnt;
	u_short rcbadru, rcbadrl, arbadru, arbadrl, arbcnt,
		brbadru, brbadrl, brbcnt;
	u_short tcbadru, tcbadrl, atbadru, atbadrl, atbcnt,
		btbadru, btbadrl, btbcnt;
	struct clsoftc *sc;

	struct clreg *volatile cl_reg;
d1688 2
a1689 3
	cl_reg = cl_cons.cl_vaddr;

	sc = (struct clsoftc *) cl_cd.cd_devs[0];
d1692 52
a1743 62
	cl_reg->cl_car	= (u_char) channel;
	livr = cl_reg->cl_livr;
	cmr = cl_reg->cl_cmr;
	cor1 = cl_reg->cl_cor1;
	cor2 = cl_reg->cl_cor2;
	cor3 = cl_reg->cl_cor3;
	cor4 = cl_reg->cl_cor4;
	cor5 = cl_reg->cl_cor5;
	cor6 = cl_reg->cl_cor6;
	cor7 = cl_reg->cl_cor7;
	schr1 = cl_reg->cl_schr1;
	schr2 = cl_reg->cl_schr2;
	schr3 = cl_reg->cl_schr3;
	schr4 = cl_reg->cl_schr4;
	scrl = cl_reg->cl_scrl;
	scrh = cl_reg->cl_scrh;
	lnxt = cl_reg->cl_lnxt;
	rbpr = cl_reg->cl_rbpr;
	rcor = cl_reg->cl_rcor;
	tbpr = cl_reg->cl_tbpr;
	rpilr = cl_reg->cl_rpilr;
	rir = cl_reg->cl_rir;
	ier = cl_reg->cl_ier;
	ccr = cl_reg->cl_ccr;
	tcor = cl_reg->cl_tcor;
	csr = cl_reg->cl_csr;
	tpr = cl_reg->cl_tpr;
	rts = cl_reg->cl_msvr_rts;
	dtr = cl_reg->cl_msvr_dtr;
	rtprl = cl_reg->cl_rtprl;
	rtprh = cl_reg->cl_rtprh;
	dmabsts = cl_reg->cl_dmabsts;
	tcbadru = cl_reg->cl_tcbadru;
	tcbadrl = cl_reg->cl_tcbadrl;
	rcbadru = cl_reg->cl_rcbadru;
	rcbadrl = cl_reg->cl_rcbadrl;

	parbadru = &(cl_reg->cl_arbadru);
	parbadrl = &(cl_reg->cl_arbadrl);
	parbcnt  = &(cl_reg->cl_arbcnt);
	parbsts  = &(cl_reg->cl_arbsts);

	arbadru = cl_reg->cl_arbadru;
	arbadrl = cl_reg->cl_arbadrl;
	arbcnt  = cl_reg->cl_arbcnt;
	arbsts  = cl_reg->cl_arbsts;

	brbadru = cl_reg->cl_brbadru;
	brbadrl = cl_reg->cl_brbadrl;
	brbcnt  = cl_reg->cl_brbcnt;
	brbsts  = cl_reg->cl_brbsts;

	atbadru = cl_reg->cl_atbadru;
	atbadrl = cl_reg->cl_atbadrl;
	atbcnt  = cl_reg->cl_atbcnt;
	atbsts  = cl_reg->cl_atbsts;

	btbadru = cl_reg->cl_btbadru;
	btbadrl = cl_reg->cl_btbadrl;
	btbcnt  = cl_reg->cl_btbcnt;
	btbsts  = cl_reg->cl_btbsts;

a1765 2
	printf("parbadru %x, parbadrl %x, parbcnt %x, parbsts %x\n",
		parbadru,    parbadrl,    parbcnt,    parbsts);
@


1.42
log
@constify baud rate to hardware parameters structures.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.41 2004/04/15 08:41:44 miod Exp $ */
d161 1
a161 1
void cl_overflow(struct clsoftc *sc, int channel, long *ptime, u_char *msg);
a175 3
#if 0
void cloutput(struct tty *tp);
#endif
d185 1
d187 2
a911 2
	/* always there ? */
	/* serial major */
d914 2
d917 1
a917 2
	if (brdtyp == BRD_188 || badaddr(CD2400_BASE_ADDR, 1) != 0) {
		cp->cn_pri = CN_DEAD;
a918 1
	}
d924 4
a927 1
	cp->cn_dev = makedev (maj, 0);
a1742 1
			reoir = 0x00;
d1749 1
a1749 2
		reoir = 0x08;
		sc->cl_reg->cl_reoir = reoir;
d1755 1
a1755 1
cl_overflow (sc, channel, ptime, msg)
d1759 1
a1759 1
	u_char *msg;
d1761 2
a1762 11
/*
	if (*ptime != time.tv_sec) {
*/
	{
/*
		*ptime = time.tv_sec;
*/
		log(LOG_WARNING, "%s%d[%d]: %s overrun\n", cl_cd.cd_name,
			0 /* fix */, channel, msg);
	}
	return;
d1766 1
a1766 1
cl_parity (sc, channel)
d1770 2
a1771 2
	log(LOG_WARNING, "%s%d[%d]: parity error\n", cl_cd.cd_name, 0, channel);
	return;
d1775 1
a1775 1
cl_frame (sc, channel)
d1779 2
a1780 2
	log(LOG_WARNING, "%s%d[%d]: frame error\n", cl_cd.cd_name, 0, channel);
	return;
d1782 1
d1784 1
a1784 1
cl_break (sc, channel)
d1792 2
a1793 1
	log(LOG_WARNING, "%s%d[%d]: break detected\n", cl_cd.cd_name, 0, channel);
a1794 1
	return;
a1917 1
	return;
@


1.41
log
@Remove orphaned CLCD_DO_POLLED_INPUT code.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.40 2004/02/11 20:41:07 miod Exp $ */
d122 2
a123 1
struct {
@


1.40
log
@Keep using the BUG as the console device until autoconf is over, rather
than switching early.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.39 2004/02/10 10:30:25 miod Exp $ */
a68 2
#define	CLCD_DO_POLLED_INPUT

a177 3
#ifdef	CLCD_DO_POLLED_INPUT
void cl_chkinput(void);
#endif
a188 4
#ifdef	CLCD_DO_POLLED_INPUT
int dopoll = 1;
#endif

d339 1
a339 3
#ifdef CLCD_DO_POLLED_INPUT
	dopoll = 0;
#endif
a1125 39

#ifdef CLCD_DO_POLLED_INPUT
void
cl_chkinput()
{
	struct tty *tp;
	int unit;
	struct clsoftc *sc;
	int channel;

	if (dopoll == 0)
		return;
	for (unit = 0; unit < cl_cd.cd_ndevs; unit++) {
		if (unit >= cl_cd.cd_ndevs ||
			(sc = (struct clsoftc *) cl_cd.cd_devs[unit]) == NULL) {
			continue;
		}
		if (cl_instat(sc)) {
			while (cl_instat(sc)){
				int ch;
				u_char c;
				/*
				*(pinchar++) = clcngetc();
				*/
				ch = clgetc(sc,&channel) & 0xff;
				c = ch;

				tp = sc->sc_cl[channel].tty;
				if (NULL != tp) {
					(*linesw[tp->t_line].l_rint)(c,tp);
				}
			}
			/*
			wakeup(tp);
			*/
		}
	}
}
#endif
@


1.39
log
@Check for the device existence in cnprobe() as done in match(), to be sure
we don't try to attach a phantom console.

It seems that some late 187 models do not have cl0 at the expected address...
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.38 2004/02/10 10:06:48 miod Exp $ */
d257 6
a262 3
	if ((u_char *)ca->ca_paddr == (u_char *)cl_cons.cl_paddr) {
		/* if this device is configured as console,
		 * line cl_cons.channel is the console */
@


1.38
log
@Fix cnprobe() and cninit() prototypes.
Also, provide a better test for bugtty attachment.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.37 2004/01/14 20:50:48 miod Exp $ */
d42 1
d924 1
a924 1
	if (brdtyp == BRD_188) {
d928 1
@


1.37
log
@Do not fill more than the first three fields of cfdriver structures unless
necessary. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.36 2004/01/05 20:08:01 miod Exp $ */
d148 1
a148 2
int clcnprobe(struct consdev *cp);
int clcninit(struct consdev *cp);
a149 3
int clcngetc(dev_t dev);
void clcnputc(dev_t dev, u_char c);
void clcnpollc(dev_t, int);
d914 1
a914 1
int
d925 1
a925 1
		return 0;
a932 2

	return 1;
d935 1
a935 1
int
a973 1
	return 0;
@


1.36
log
@Support for the second set of serial ports on the M8120 (untested)
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.35 2004/01/02 23:37:17 miod Exp $ */
d192 1
a192 1
	NULL, "cl", DV_TTY, 0
@


1.35
log
@Relaxed dependencies, and do not undef DEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.34 2003/12/29 07:04:14 deraadt Exp $ */
d102 2
a103 1
char cl_dmabuf [CLCD_PORTS_PER_CHIP * CL_BUFSIZE * 4];
d210 1
d213 1
a213 1
		(sc = (struct clsoftc *) cl_cd.cd_devs[unit]) == NULL) {
a225 4
	/* probing onboard 166/167/187 CL-cd2400
	 * should be previously configured,
	 * we can check the value before resetting the chip
	 */
d230 1
a230 1
		return 0;
d232 13
a244 7
	ca->ca_ipl = IPL_TTY;
	ca->ca_vaddr = ca->ca_paddr = (void *)CD2400_BASE_ADDR;
	cl_reg = (struct clreg *)ca->ca_vaddr;

	if (badvaddr((vaddr_t)&cl_reg->cl_gfrcr,1))
		return 0;
	return 1;
d281 5
a285 1
	sc->sc_cl[0].rx[0] = (void *) (&cl_dmabuf);
@


1.34
log
@correct probe console printf; miod ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.33 2003/12/19 22:30:18 miod Exp $ */
a46 3

#include "cl.h"
#include "pcctwo.h"
a69 3
#ifdef DEBUG
#undef DEBUG
#endif
d196 1
d198 1
a201 3
#define CL_TTY(x) (minor(x))

struct tty *cltty(dev_t dev);
d203 2
a204 1
struct tty *cltty(dev)
d340 1
d342 1
@


1.33
log
@Pass -Wformat, and silence a few vme* debug printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.32 2003/10/05 20:27:47 miod Exp $ */
d266 1
a266 1
		printf(" console ");
@


1.32
log
@Kill vm_offset_t and vm_size_t, in favor of the [pv]addr_t and [pv]size_t
typedefs.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.31 2003/10/03 16:44:50 miod Exp $ */
d1556 1
a1556 1
				log(LOG_WARNING, "cl_txintr: resid %x cnt %x pbuf %x\n",
@


1.31
log
@Merge tty_attach() in ttymalloc() and tty_detach() in ttyfree(). The need for
separate tty registering is gone now that sparc has switched to wscons, and
this makes the code less error-prone.

Also, remove tests for ttymalloc() failure, since it uses M_WAITOK.

ok millert@@ deraadt@@, tested by various people as well besides me...
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.30 2003/09/28 14:26:25 miod Exp $ */
d5 1
a5 1
 *   
d25 1
a25 1
 */  
d67 1
a67 1
#define CL_RXMASK	0x87 
d192 1
a192 1
struct cfattach cl_ca = {       
d194 2
a195 2
};      
  
d198 1
a198 1
}; 
d216 1
a216 1
	if (unit >= cl_cd.cd_ndevs || 
d224 1
a224 1
int	
d231 1
a231 1
	 * should be previously configured, 
d236 1
a236 1
	
d244 1
a244 1
	if (badvaddr((vm_offset_t)&cl_reg->cl_gfrcr,1))
d380 1
a380 1
		cl_reg->cl_cmr	= 0x02; 
a485 1
			
d518 1
a518 1
	
d520 1
a520 1
	if (unit >= cl_cd.cd_ndevs || 
d584 1
a584 1
				/* CL_TXDMAINT | */ CL_RXDMAINT; 
d614 1
a614 1
			sc->cl_reg->cl_cmr	= 0x42; 
d618 1
a618 1
			sc->cl_reg->cl_cmr	= 0x82; 
d662 1
a662 1
	if (unit >= cl_cd.cd_ndevs || 
d691 1
a691 1
	if (unit >= cl_cd.cd_ndevs || 
d731 1
a731 1
	if (unit >= cl_cd.cd_ndevs || 
d741 1
a741 1
	
d773 1
a773 1
	if (unit >= cl_cd.cd_ndevs || 
d796 1
a796 1
	if (unit >= cl_cd.cd_ndevs || 
d822 1
a822 1
	if (unit >= cl_cd.cd_ndevs || 
d876 1
a876 1
		error = suser(p, 0); 
d878 1
a878 1
			return(EPERM); 
d942 1
a942 1
	
d1050 1
a1050 1
	
d1148 1
a1148 1
		if (unit >= cl_cd.cd_ndevs || 
d1175 1
a1175 1
u_char 
d1239 1
a1239 1
	if (par->c_ospeed == 0) { 
d1295 1
a1295 1
		if (sc->cl_reg->cl_cor1 != cor1) { 
d1339 1
a1339 1
u_char 
d1357 1
a1357 1
u_char 
d1376 1
a1376 1
u_char 
d1425 1
a1425 1
	if (unit >= cl_cd.cd_ndevs || 
d1488 1
a1488 1
		log(LOG_WARNING, "cl_mintr: channel %x cts %x\n",channel, 
d1644 1
a1644 1
	
d1708 1
a1708 1
#else 
@


1.30
log
@Be sure to invoke tty_attach() after ttymalloc().
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.29 2003/08/15 20:32:14 tedu Exp $ */
a531 1
		tty_attach(tp);
@


1.29
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.28 2003/06/03 21:09:01 deraadt Exp $ */
d532 1
a532 1
/*		tty_attach(tp);*/  
@


1.28
log
@terms 3 & 4 cleanup based on "terms" file
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.27 2003/01/13 20:09:19 miod Exp $ */
d878 1
a878 1
		error = suser(p->p_ucred, &p->p_acflag); 
@


1.27
log
@Missing splx()
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.26 2002/06/12 03:49:56 miod Exp $ */
a4 1
 *
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Dale Rahn.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.26
log
@cnputc() will take care of the necessary cr->cr/lf translation, so don't
do it in those consoles either.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.25 2002/06/11 05:13:39 miod Exp $ */
d62 1
a62 1
#define splcl()	splx(IPL_TTY)
d1341 1
@


1.25
log
@cnputc() routines are void, not int.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.24 2002/04/28 15:17:09 miod Exp $ */
a1066 4
	/* is this the correct location for the cr -> cr/lf tranlation? */
	if (c == '\n')
		clputc(0, 0, '\r');

@


1.24
log
@Use the prototypes defined via cdev_decl() macros, instead of rolling our
own; thus fix a lot of foo_open(), foo_close() and foo_ioctl() prototypes
in the process.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.23 2002/03/14 03:15:57 millert Exp $ */
d163 1
a163 1
int clcnputc(dev_t dev, u_char c);
d1062 1
a1062 1
int
a1071 1
	return 0;
@


1.23
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.22 2002/03/14 01:26:39 millert Exp $ */
a35 1
#include <sys/conf.h>
d45 2
a47 1
#include <machine/autoconf.h>
d51 1
a187 7
int clopen(dev_t dev, int flag, int mode, struct proc *p);
int clclose(dev_t dev, int flag, int mode, struct proc *p);
int clread(dev_t dev, struct uio *uio, int flag);
int clwrite(dev_t dev, struct uio *uio, int flag);
int clioctl(dev_t dev, int cmd, caddr_t data, int flag, struct proc *p);
int clstop(struct tty *tp, int flag);

d370 1
d421 2
a422 1
int clmctl (dev, bits, how)
d514 2
a515 1
int clopen (dev, flag, mode, p)
d657 3
a659 1
int clparam(tp, t)
d726 2
a727 1
int clclose (dev, flag, mode, p)
d769 3
a771 1
int clread (dev, uio, flag)
d793 2
a794 1
int clwrite (dev, uio, flag)
d816 2
a817 1
int clioctl (dev, cmd, data, flag, p)
d819 1
a819 1
	int cmd;
d898 1
d999 1
d1087 1
d1118 26
a1143 12
if (unit == 0) {
	s = splhigh();
	oldchannel = cl_reg->cl_car;
	cl_reg->cl_car = unit;
	schar = cl_reg->cl_schr3;
	cl_reg->cl_schr3 = c;
	cl_reg->cl_stcr = 0x08 | 0x03; /* send special char, char 3 */
	while (0 != cl_reg->cl_stcr) {
		/* wait until cl notices the command
		 * otherwise it may not notice the character
		 * if we send characters too fast.
		 */
a1144 14
	DELAY(5);
	cl_reg->cl_schr3 = schar;
	cl_reg->cl_car = oldchannel;
	splx(s);
} else {
	s = splhigh();
	oldchannel = cl_reg->cl_car;
	cl_reg->cl_car = unit;
	if (cl_reg->cl_tftc > 0) {
		cl_reg->cl_tdr = c;
	}
	cl_reg->cl_car = oldchannel;
	splx(s);
}
d1240 1
d1368 1
d1387 1
d1833 1
d1842 1
@


1.22
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.21 2002/02/15 20:45:30 nordin Exp $ */
d198 1
a198 1
void cloutput __P( (struct tty *tp));
d1666 1
a1666 1
		cl_overflow (sc, channel, (long*)&sc->sc_fotime, "fifo");
@


1.21
log
@Don't cast nonexistent return value from splx to (void). ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.20 2002/01/14 21:34:38 miod Exp $ */
d158 22
a179 22
int clcnprobe __P((struct consdev *cp));
int clcninit __P((struct consdev *cp));
int cl_instat __P((struct clsoftc *sc));
int clcngetc __P((dev_t dev));
int clcnputc __P((dev_t dev, u_char c));
void clcnpollc __P((dev_t, int));
u_char cl_clkdiv __P((int speed));
u_char cl_clknum __P((int speed));
u_char cl_clkrxtimeout __P((int speed));
void clstart __P((struct tty *tp));
void cl_unblock __P((struct tty *tp));
int clccparam __P((struct clsoftc *sc, struct termios *par, int channel));

int clparam __P((struct tty *tp, struct termios *t));
int cl_mintr __P((void *));
int cl_txintr __P((void *));
int cl_rxintr __P((void *));
void cl_overflow __P((struct clsoftc *sc, int channel, long *ptime, u_char *msg));
void cl_parity __P((struct clsoftc *sc, int channel));
void cl_frame __P((struct clsoftc *sc, int channel));
void cl_break __P(( struct clsoftc *sc, int channel));
int clmctl __P((dev_t dev, int bits, int how));
d181 1
a181 1
void cl_dumpport __P((int channel));
d184 2
a185 2
int	clprobe __P((struct device *parent, void *self, void *aux));
void	clattach __P((struct device *parent, struct device *self, void *aux));
d187 10
a196 10
int clopen  __P((dev_t dev, int flag, int mode, struct proc *p));
int clclose __P((dev_t dev, int flag, int mode, struct proc *p));
int clread  __P((dev_t dev, struct uio *uio, int flag));
int clwrite __P((dev_t dev, struct uio *uio, int flag));
int clioctl __P((dev_t dev, int cmd, caddr_t data, int flag, struct proc *p));
int clstop  __P((struct tty *tp, int flag));

void cl_initchannel __P((struct clsoftc *sc, int channel));
void clputc __P((struct clsoftc *sc, int unit, u_char c));
u_char clgetc __P((struct clsoftc *sc, int *channel));
d201 1
a201 1
void cl_chkinput __P((void));
d220 1
a220 1
struct tty *cltty __P((dev_t dev));
@


1.20
log
@volatile police.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.19 2002/01/07 03:05:57 miod Exp $ */
d500 1
a500 1
	(void)splx(s);
@


1.19
log
@Do not enter ddb twice in a row on console break.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.18 2001/12/19 07:04:41 smurph Exp $ */
d83 2
a84 2
	volatile struct clreg *cl_vaddr;
	volatile struct pcctworeg *pcctwoaddr;
d944 1
a944 1
	volatile struct clreg *cl_reg;
d986 1
a986 1
	volatile struct clreg *cl_reg;
d1004 2
a1005 2
	volatile struct clreg *cl_reg = cl_cons.cl_vaddr;
	volatile struct pcctworeg *pcc2_base = cl_cons.pcctwoaddr;
d1090 1
a1090 1
	volatile struct clreg *cl_reg;
d1186 2
a1187 2
	volatile struct clreg *cl_reg;
	volatile struct pcctworeg *pcc2_base;
d1863 2
a1864 1
	volatile void * parbadru, *parbadrl,  *parbsts, *parbcnt;
d1871 1
a1871 1
	volatile struct clreg *cl_reg;
@


1.18
log
@Introduce brdtyp and change what cputyp means.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.17 2001/12/16 23:49:46 miod Exp $ */
a1645 3
#ifdef DDB
	int wantddb = 0;
#endif
a1677 4
#ifdef DDB
		if (sc->sc_cl[channel].cl_consio)
			wantddb = 1;
#endif
a1800 4
#ifdef DDB
	if (wantddb != 0 && db_console != 0)
		Debugger();
#endif
d1845 1
a1845 1
	if (db_console != 0)
@


1.18.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.20 2002/01/14 21:34:38 miod Exp $ */
d83 2
a84 2
	struct clreg *volatile cl_vaddr;
	struct pcctworeg *volatile pcctwoaddr;
d944 1
a944 1
	struct clreg *volatile cl_reg;
d986 1
a986 1
	struct clreg *volatile cl_reg;
d1004 2
a1005 2
	struct clreg *volatile cl_reg = cl_cons.cl_vaddr;
	struct pcctworeg *volatile pcc2_base = cl_cons.pcctwoaddr;
d1090 1
a1090 1
	struct clreg *volatile cl_reg;
d1186 2
a1187 2
	struct clreg *volatile cl_reg;
	struct pcctworeg *volatile pcc2_base;
d1646 3
d1681 4
d1808 4
d1856 1
a1856 1
	if (sc->sc_cl[channel].cl_consio && db_console != 0)
d1874 1
a1874 2
	void *volatile parbadru, *volatile parbadrl,
	     *volatile parbsts, *volatile parbcnt;
d1881 1
a1881 1
	struct clreg *volatile cl_reg;
@


1.18.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.18.2.1 2002/01/31 22:55:17 niklas Exp $ */
d36 1
d46 1
a47 2
#include <machine/conf.h>
#include <machine/cpu.h>
a50 1

d158 22
a179 22
int clcnprobe(struct consdev *cp);
int clcninit(struct consdev *cp);
int cl_instat(struct clsoftc *sc);
int clcngetc(dev_t dev);
int clcnputc(dev_t dev, u_char c);
void clcnpollc(dev_t, int);
u_char cl_clkdiv(int speed);
u_char cl_clknum(int speed);
u_char cl_clkrxtimeout(int speed);
void clstart(struct tty *tp);
void cl_unblock(struct tty *tp);
int clccparam(struct clsoftc *sc, struct termios *par, int channel);

int clparam(struct tty *tp, struct termios *t);
int cl_mintr(void *);
int cl_txintr(void *);
int cl_rxintr(void *);
void cl_overflow(struct clsoftc *sc, int channel, long *ptime, u_char *msg);
void cl_parity(struct clsoftc *sc, int channel);
void cl_frame(struct clsoftc *sc, int channel);
void cl_break( struct clsoftc *sc, int channel);
int clmctl(dev_t dev, int bits, int how);
d181 1
a181 1
void cl_dumpport(int channel);
d184 2
a185 2
int	clprobe(struct device *parent, void *self, void *aux);
void	clattach(struct device *parent, struct device *self, void *aux);
d187 10
a196 3
void cl_initchannel(struct clsoftc *sc, int channel);
void clputc(struct clsoftc *sc, int unit, u_char c);
u_char clgetc(struct clsoftc *sc, int *channel);
d198 1
a198 1
void cloutput(struct tty *tp);
d201 1
a201 1
void cl_chkinput(void);
d220 1
a220 1
struct tty *cltty(dev_t dev);
a375 1

d426 1
a426 2
int
clmctl(dev, bits, how)
d500 1
a500 1
	splx(s);
d518 1
a518 2
int
clopen(dev, flag, mode, p)
d660 1
a660 3

int
clparam(tp, t)
d727 1
a727 2
int
clclose(dev, flag, mode, p)
d769 1
a769 3

int
clread(dev, uio, flag)
d791 1
a791 2
int
clwrite(dev, uio, flag)
d813 1
a813 2
int
clioctl(dev, cmd, data, flag, p)
d815 1
a815 1
	u_long cmd;
a893 1

a993 1

a1080 1

d1111 23
a1133 26
	if (unit == 0) {
		s = splhigh();
		oldchannel = cl_reg->cl_car;
		cl_reg->cl_car = unit;
		schar = cl_reg->cl_schr3;
		cl_reg->cl_schr3 = c;
		cl_reg->cl_stcr = 0x08 | 0x03; /* send special char, char 3 */
		while (0 != cl_reg->cl_stcr) {
			/* wait until cl notices the command
			 * otherwise it may not notice the character
			 * if we send characters too fast.
			 */
		}
		DELAY(5);
		cl_reg->cl_schr3 = schar;
		cl_reg->cl_car = oldchannel;
		splx(s);
	} else {
		s = splhigh();
		oldchannel = cl_reg->cl_car;
		cl_reg->cl_car = unit;
		if (cl_reg->cl_tftc > 0) {
			cl_reg->cl_tdr = c;
		}
		cl_reg->cl_car = oldchannel;
		splx(s);
d1135 3
a1232 1

a1359 1

a1377 1

d1666 1
a1666 1
		cl_overflow (sc, channel, (long *)&sc->sc_fotime, "fifo");
a1822 1

a1830 1

@


1.18.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.18.2.2 2002/06/11 03:37:09 art Exp $ */
d163 1
a163 1
void clcnputc(dev_t dev, u_char c);
d1062 1
a1062 1
void
d1067 4
d1072 1
@


1.18.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d62 1
a62 1
#define splcl()	spltty()
a1340 1
	splx(s);
@


1.17
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.14 2001/08/31 01:05:44 miod Exp $ */
a219 2
extern int cputyp;

d248 2
a249 2
	int ret;
	if (cputyp != CPU_187)
d253 1
a253 1
	ca->ca_paddr = (void *)CD2400_BASE_ADDR;
d256 3
a258 6
#if 0
	ret = !badvaddr(&cl_reg->cl_gfrcr,1);
#else
	ret = 1;
#endif
	return ret;
d926 1
a926 1
	if (cputyp == CPU_188) {
d946 1
a946 1
	cl_cons.cl_paddr = (void *)0xfff45000;
@


1.16
log
@One more free commit, thanks to smurph@@, in order to get GENERIC going.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.15 2001/12/13 08:55:51 smurph Exp $ */
d220 2
d250 2
a251 2
	
	if (brdtyp == BRD_188)
d255 1
a255 1
	ca->ca_vaddr = ca->ca_paddr = (void *)CD2400_BASE_ADDR;
d258 6
a263 3
	if (badvaddr((vm_offset_t)&cl_reg->cl_gfrcr,1))
		return 0;
	return 1;
d404 4
a407 4
		cl_reg->cl_schr1 = 0x00;
		cl_reg->cl_schr2 = 0x00;
		cl_reg->cl_schr3 = 0x00;
		cl_reg->cl_schr4 = 0x00;
d416 4
a419 4
		cl_reg->cl_msvr_rts = 0x00;
		cl_reg->cl_msvr_dtr = 0x00;
		cl_reg->cl_rtprl = CL_RX_TIMEOUT;
		cl_reg->cl_rtprh = 0x00;
d931 1
a931 1
	if (brdtyp == BRD_188) {
d941 1
a941 1
	
d951 1
a951 1
	cl_cons.cl_paddr = (void *)CD2400_BASE_ADDR;
@


1.15
log
@Support for MVME197 completed.  Fix SPL defs.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.14 2001/08/31 01:05:44 miod Exp $ */
d256 1
a256 1
	if (badvaddr(&cl_reg->cl_gfrcr,1))
@


1.14
log
@Clean the DDB entry procedure for all console drivers, and honour
db_console setting.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.13 2001/08/26 02:37:07 miod Exp $ */
a219 2
extern int cputyp;

d248 2
a249 2
	int ret;
	if (cputyp != CPU_187)
d253 1
a253 1
	ca->ca_paddr = (void *)CD2400_BASE_ADDR;
d256 3
a258 6
#if 0
	ret = !badvaddr(&cl_reg->cl_gfrcr,1);
#else
	ret = 1;
#endif
	return ret;
d399 4
a402 4
		cl_reg->cl_schr1	= 0x00;
		cl_reg->cl_schr2	= 0x00;
		cl_reg->cl_schr3	= 0x00;
		cl_reg->cl_schr4	= 0x00;
d411 4
a414 4
		cl_reg->cl_msvr_rts	= 0x00;
		cl_reg->cl_msvr_dtr	= 0x00;
		cl_reg->cl_rtprl	= CL_RX_TIMEOUT;
		cl_reg->cl_rtprh	= 0x00;
d926 1
a926 1
	if (cputyp == CPU_188) {
d936 1
a936 1

d946 1
a946 1
	cl_cons.cl_paddr = (void *)0xfff45000;
@


1.13
log
@Add prototypes, fix compilation warnings, random style fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.12 2001/08/24 22:46:57 miod Exp $ */
d44 2
d48 2
d52 1
a52 1
#include <sys/syslog.h>
d56 5
a60 1
#include <machine/psl.h>
a80 1
#define DEBUG_KERN 1
d1651 1
a1651 1
#ifdef CONSOLEBREAKDDB
d1686 1
a1686 1
#ifdef CONSOLEBREAKDDB
d1813 2
a1814 2
#ifdef CONSOLEBREAKDDB
	if (wantddb)
d1860 3
a1862 2
#ifdef DEBUG_KERN
	Debugger();
@


1.12
log
@Remove unused debugging code, fix uninitialized variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.11 2001/06/27 05:44:49 nate Exp $ */
d68 2
d153 1
d156 1
d173 1
d175 1
d193 3
a1139 1
/*
a1140 2
*/
#if 1
@


1.11
log
@recieve -> receive
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.10 2001/03/09 05:44:38 smurph Exp $ */
d987 1
a987 1
	u_char val, reoir, licr, isrl, data, fifo_cnt;
d1855 1
a1855 25
void
cl_dumpport0()
{
	cl_dumpport(0);
	return;
}
void
cl_dumpport1()
{
	cl_dumpport(1);
	return;
}
void
cl_dumpport2()
{
	cl_dumpport(2);
	return;
}
void
cl_dumpport3()
{
	cl_dumpport(3);
	return;
}

d1901 1
d1977 1
@


1.10
log
@kernel will compile with -Werror.  Added intr.h
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.9 2001/03/07 23:45:50 miod Exp $ */
d1239 1
a1239 1
			/* disconnect, drop RTS DTR stop reciever */
@


1.9
log
@Fix interrupt handler registration and prototypes.
While there, some warning hunting.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.8 2001/02/12 08:16:22 smurph Exp $ */
d759 3
a761 3
dev_t dev;
struct uio *uio;
int flag;
d781 3
a783 3
dev_t dev;
struct uio *uio;
int flag;
d803 5
a807 5
dev_t dev;
int cmd;
caddr_t data;
int flag;
struct proc *p;
d908 1
a908 1
struct consdev *cp;
d931 1
a931 1
struct consdev *cp;
d1332 1
d1334 1
d1704 2
a1705 2
log(LOG_WARNING, "cl_rxintr: 1channel %x buf %x cnt %x status %x\n",
channel, nbuf, cnt, status);
d1809 4
a1812 4
struct clsoftc *sc;
int channel;
long *ptime;
u_char *msg;
@


1.8
log
@correct buginstat(), statclock now working for '188, systat vmstat now works,
serial driver for '188 working better.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.7 2001/02/01 03:38:14 smurph Exp $ */
d161 3
a163 3
int cl_mintr __P((struct clsoftc *sc));
int cl_txintr __P((struct clsoftc *sc));
int cl_rxintr __P((struct clsoftc *sc));
d181 6
a186 4
static void cl_initchannel __P((struct clsoftc *sc, int channel));
static void clputc __P((struct clsoftc *sc, int unit, u_char c));
static u_char clgetc __P((struct clsoftc *sc, int *channel));
static void cloutput __P( (struct tty *tp));
d206 3
a208 1
struct tty * cltty(dev)
d305 1
d307 1
a307 1
#if 0
d330 1
a331 1
	sc->sc_ih_e.ih_wantframe = 0;
d335 1
a336 1
	sc->sc_ih_m.ih_wantframe = 0;
d340 1
a341 1
	sc->sc_ih_t.ih_wantframe = 0;
d345 1
a346 1
	sc->sc_ih_r.ih_wantframe = 0;
d365 1
a365 1
static void
d675 3
a677 1
void cloutput(tp)
d714 1
d987 4
a990 1
	u_char val, reoir, licr, isrl, data, status, fifo_cnt;
d1057 2
d1070 1
a1070 1
static void
d1172 2
a1173 1
static u_char 
d1400 4
d1405 1
a1405 2
	struct clsoftc *sc;
	int channel, unit, s, cnt;
d1453 2
a1454 2
cl_mintr(sc)
	struct clsoftc *sc;
d1456 2
d1460 1
a1460 1
	struct tty *tp;
d1501 2
a1502 2
cl_txintr(sc)
struct clsoftc *sc;
d1504 3
a1506 1
	static empty = 0;
d1625 2
a1626 2
cl_rxintr(sc)
	struct clsoftc *sc;
d1628 2
a1630 1
	u_char c;
@


1.7
log
@Major changes to get MVME188 working.  More header and code cleanups.  The
kernel is tested on MVME188A/2P256 and MVME188A/1P64.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.6 2000/03/26 23:32:00 deraadt Exp $ */
d751 2
a752 2
	dev_t dev;
	struct uio *uio;
d771 1
d773 3
a775 3
	dev_t dev;
	struct uio *uio;
	int flag;
d793 1
d795 5
a799 5
	dev_t dev;
	int cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d1371 1
d1380 1
d1434 1
d1483 1
a1483 1
	struct clsoftc *sc;
d1493 1
a1493 1
	if(((tir = sc->cl_reg->cl_tir) & 0x40) == 0x0) {
d1500 3
a1502 3
	channel	= tir & 0x03;
	cmr	= sc->cl_reg->cl_cmr;
	
d1518 2
a1519 2
		log(LOG_WARNING, "cl_txintr: DMAMODE channel %x dmabsts %x\n",
			channel, dmabsts);
d1527 2
a1528 2
		log(LOG_WARNING, "cl_txintr: resid %x cnt %x pbuf %x\n",
			resid, cnt, pbuffer);
d1534 1
a1534 1
							((u_long) sc->sc_cl[channel].txp[nbuf]) >> 16;
d1536 1
a1536 1
							((u_long) sc->sc_cl[channel].txp[nbuf]) & 0xffff;
d1541 1
a1541 1
							((u_long) sc->sc_cl[channel].txp[nbuf]) >> 16;
d1543 1
a1543 1
							((u_long) sc->sc_cl[channel].txp[nbuf]) & 0xffff;
d1547 1
a1547 1
				teoir = 0x08;
d1563 1
a1563 1
		log(LOG_WARNING, "cl_txintr: done\n");
d1578 2
a1579 2
			log(LOG_WARNING, "cl_txintr to many empty intr %d channel %d\n",
				empty, channel);
d1691 12
a1702 12
			/* this should be done at off level */
{
	u_short rcbadru, rcbadrl;
	u_char arbsts, brbsts;
	u_char *pbufs, *pbufe;
	rcbadru = sc->cl_reg->cl_rcbadru;
	rcbadrl = sc->cl_reg->cl_rcbadrl;
	arbsts =  sc->cl_reg->cl_arbsts;
	brbsts =  sc->cl_reg->cl_brbsts;
	pbufs = sc->sc_cl[channel].rxp[nbuf];
	pbufe = (u_char *)(((u_long)rcbadru << 16) | (u_long)rcbadrl);
	cnt = pbufe - pbufs;
d1704 2
a1705 2
	log(LOG_WARNING, "cl_rxintr: rcbadru %x rcbadrl %x arbsts %x brbsts %x cnt %x\n",
	rcbadru, rcbadrl, arbsts, brbsts, cnt);
d1708 2
a1709 2
	log(LOG_WARNING, "cl_rxintr: buf %x cnt %x\n",
	nbuf, cnt);
d1711 1
a1711 1
}
d1715 1
a1715 1
log(LOG_WARNING, "cl_rxintr: reoir %x\n", reoir);
d1719 2
a1720 2
log(LOG_WARNING, "cl_rxintr: 2channel %x buf %x cnt %x status %x\n",
channel, nbuf, cnt, status);
d1760 1
a1760 1
		cl_appendbuf(sc, channel, c);
@


1.6
log
@callout.h is gone
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.5 1999/09/27 18:43:22 smurph Exp $ */
d898 1
a898 1
	struct consdev *cp;
d902 15
a916 15
   int maj;
	
 	/* bomb if it'a a MVME188 */
   if (cputyp == CPU_188){
      cp->cn_pri = CN_DEAD;
      return 0;
   }
   /* locate the major number */
  	for (maj = 0; maj < nchrdev; maj++)
   	if (cdevsw[maj].d_open == clopen)
	      break;
   cp->cn_dev = makedev (maj, 0);
   cp->cn_pri = CN_NORMAL;
   
   return 1;
@


1.5
log
@adding support for MVME188 and MVME197.  Plus 32bit if_ie.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.4 1999/05/29 04:41:43 smurph Exp $ */
a35 1
#include <sys/callout.h>
@


1.5.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.10 2001/03/09 05:44:38 smurph Exp $ */
d36 1
d162 3
a164 3
int cl_mintr __P((void *));
int cl_txintr __P((void *));
int cl_rxintr __P((void *));
d182 4
a185 6
void cl_initchannel __P((struct clsoftc *sc, int channel));
void clputc __P((struct clsoftc *sc, int unit, u_char c));
u_char clgetc __P((struct clsoftc *sc, int *channel));
#if 0
void cloutput __P( (struct tty *tp));
#endif
d205 1
a205 3
struct tty *cltty __P((dev_t dev));

struct tty *cltty(dev)
d302 1
a303 2
		int j;

d326 1
a327 1
	sc->sc_ih_e.ih_ipl = ca->ca_ipl;
a330 1
	sc->sc_ih_e.ih_wantframe = 0;
d332 1
a335 1
	sc->sc_ih_e.ih_wantframe = 0;
d337 1
a340 1
	sc->sc_ih_e.ih_wantframe = 0;
d342 1
d361 1
a361 1
void
d671 1
a671 3
#if 0
void
cloutput(tp)
a707 1
#endif
d754 1
a754 1
	int flag;
a771 1

a792 1

d903 15
a917 15
	int maj;

	/* bomb if it'a a MVME188 */
	if (cputyp == CPU_188) {
		cp->cn_pri = CN_DEAD;
		return 0;
	}
	/* locate the major number */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == clopen)
			break;
	cp->cn_dev = makedev (maj, 0);
	cp->cn_pri = CN_NORMAL;

	return 1;
d922 1
a922 1
	struct consdev *cp;
d978 1
a978 4
	u_char val, reoir, licr, isrl, data, fifo_cnt;
#if 0
	u_char status;
#endif
a1044 2

void
d1056 1
a1056 1
void
d1158 1
a1158 2

u_char 
a1316 1

a1317 1

a1369 1

a1377 1

d1383 1
d1385 1
a1385 5
	int channel, unit, s;
#if 0
	int cnt;
	u_char cbuf;
#endif
a1430 1

d1432 2
a1433 2
cl_mintr(arg)
	void *arg;
a1434 2
	struct clsoftc *sc = arg;

d1437 1
a1437 1

d1478 2
a1479 2
cl_txintr(arg)
	void *arg;
d1481 1
a1481 3
	struct clsoftc *sc = arg;

	static int empty = 0;
d1489 1
a1489 1
	if (((tir = sc->cl_reg->cl_tir) & 0x40) == 0x0) {
d1496 3
a1498 3
	channel = tir & 0x03;
	cmr     = sc->cl_reg->cl_cmr;

d1514 2
a1515 2
			log(LOG_WARNING, "cl_txintr: DMAMODE channel %x dmabsts %x\n",
			    channel, dmabsts);
d1523 2
a1524 2
				log(LOG_WARNING, "cl_txintr: resid %x cnt %x pbuf %x\n",
				    resid, cnt, pbuffer);
d1530 1
a1530 1
						((u_long) sc->sc_cl[channel].txp[nbuf]) >> 16;
d1532 1
a1532 1
						((u_long) sc->sc_cl[channel].txp[nbuf]) & 0xffff;
d1537 1
a1537 1
						((u_long) sc->sc_cl[channel].txp[nbuf]) >> 16;
d1539 1
a1539 1
						((u_long) sc->sc_cl[channel].txp[nbuf]) & 0xffff;
d1543 1
a1543 1
					teoir = 0x08;
d1559 1
a1559 1
			log(LOG_WARNING, "cl_txintr: done\n");
d1574 2
a1575 2
				log(LOG_WARNING, "cl_txintr to many empty intr %d channel %d\n",
				    empty, channel);
d1600 2
a1601 2
cl_rxintr(arg)
	void *arg;
a1602 2
	struct clsoftc *sc = arg;

d1604 1
d1676 2
a1677 2
			log(LOG_WARNING, "cl_rxintr: 1channel %x buf %x cnt %x status %x\n",
			    channel, nbuf, cnt, status);
d1687 12
a1698 12
				/* this should be done at off level */
				{
					u_short rcbadru, rcbadrl;
					u_char arbsts, brbsts;
					u_char *pbufs, *pbufe;
					rcbadru = sc->cl_reg->cl_rcbadru;
					rcbadrl = sc->cl_reg->cl_rcbadrl;
					arbsts =  sc->cl_reg->cl_arbsts;
					brbsts =  sc->cl_reg->cl_brbsts;
					pbufs = sc->sc_cl[channel].rxp[nbuf];
					pbufe = (u_char *)(((u_long)rcbadru << 16) | (u_long)rcbadrl);
					cnt = pbufe - pbufs;
d1700 2
a1701 2
					log(LOG_WARNING, "cl_rxintr: rcbadru %x rcbadrl %x arbsts %x brbsts %x cnt %x\n",
					    rcbadru, rcbadrl, arbsts, brbsts, cnt);
d1704 2
a1705 2
					log(LOG_WARNING, "cl_rxintr: buf %x cnt %x\n",
					    nbuf, cnt);
d1707 1
a1707 1
				}
d1711 1
a1711 1
				log(LOG_WARNING, "cl_rxintr: reoir %x\n", reoir);
d1715 2
a1716 2
				log(LOG_WARNING, "cl_rxintr: 2channel %x buf %x cnt %x status %x\n",
				    channel, nbuf, cnt, status);
d1756 1
a1756 1
			cl_appendbuf(sc, channel, c);
d1781 4
a1784 4
	struct clsoftc *sc;
	int channel;
	long *ptime;
	u_char *msg;
@


1.5.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.5.4.1 2001/04/18 16:10:53 niklas Exp $ */
d1239 1
a1239 1
			/* disconnect, drop RTS DTR stop receiver */
@


1.5.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.5.4.2 2001/07/04 10:19:53 niklas Exp $ */
a43 2
#include <sys/syslog.h>

a45 2
#include <machine/psl.h>

d48 1
a48 1

d52 1
a52 5

#ifdef	DDB
#include <ddb/db_var.h>
#endif

a67 2
#define	CLCD_DO_POLLED_INPUT

d71 1
a150 1
int cl_instat __P((struct clsoftc *sc));
a152 1
void clcnpollc __P((dev_t, int));
a168 1
#ifdef DEBUG
a169 1
#endif
a186 3
#ifdef	CLCD_DO_POLLED_INPUT
void cl_chkinput __P((void));
#endif
d987 1
a987 1
	u_char val, reoir, licr, isrl, data = 0, fifo_cnt;
d1131 1
d1133 2
d1638 1
a1638 1
#ifdef DDB
d1673 1
a1673 1
#ifdef DDB
d1800 2
a1801 2
#ifdef DDB
	if (wantddb != 0 && db_console != 0)
d1847 2
a1848 3
#ifdef DDB
	if (db_console != 0)
		Debugger();
d1855 25
a1879 1
#ifdef DEBUG
a1924 1
	rir = cl_reg->cl_rir;
a1999 1
#endif
@


1.5.4.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d83 2
a84 2
	struct clreg *volatile cl_vaddr;
	struct pcctworeg *volatile pcctwoaddr;
d220 2
d250 2
a251 2
	
	if (brdtyp == BRD_188)
d255 1
a255 1
	ca->ca_vaddr = ca->ca_paddr = (void *)CD2400_BASE_ADDR;
d258 6
a263 3
	if (badvaddr((vm_offset_t)&cl_reg->cl_gfrcr,1))
		return 0;
	return 1;
d505 1
a505 1
	splx(s);
d931 1
a931 1
	if (brdtyp == BRD_188) {
d949 1
a949 1
	struct clreg *volatile cl_reg;
d951 1
a951 1
	cl_cons.cl_paddr = (void *)CD2400_BASE_ADDR;
d991 1
a991 1
	struct clreg *volatile cl_reg;
d1009 2
a1010 2
	struct clreg *volatile cl_reg = cl_cons.cl_vaddr;
	struct pcctworeg *volatile pcc2_base = cl_cons.pcctwoaddr;
d1095 1
a1095 1
	struct clreg *volatile cl_reg;
d1191 2
a1192 2
	struct clreg *volatile cl_reg;
	struct pcctworeg *volatile pcc2_base;
d1651 3
d1686 4
d1813 4
d1861 1
a1861 1
	if (sc->sc_cl[channel].cl_consio && db_console != 0)
d1879 1
a1879 2
	void *volatile parbadru, *volatile parbadrl,
	     *volatile parbsts, *volatile parbcnt;
d1886 1
a1886 1
	struct clreg *volatile cl_reg;
@


1.5.4.5
log
@Merge in -current from about a week ago
@
text
@d158 22
a179 22
int clcnprobe(struct consdev *cp);
int clcninit(struct consdev *cp);
int cl_instat(struct clsoftc *sc);
int clcngetc(dev_t dev);
int clcnputc(dev_t dev, u_char c);
void clcnpollc(dev_t, int);
u_char cl_clkdiv(int speed);
u_char cl_clknum(int speed);
u_char cl_clkrxtimeout(int speed);
void clstart(struct tty *tp);
void cl_unblock(struct tty *tp);
int clccparam(struct clsoftc *sc, struct termios *par, int channel);

int clparam(struct tty *tp, struct termios *t);
int cl_mintr(void *);
int cl_txintr(void *);
int cl_rxintr(void *);
void cl_overflow(struct clsoftc *sc, int channel, long *ptime, u_char *msg);
void cl_parity(struct clsoftc *sc, int channel);
void cl_frame(struct clsoftc *sc, int channel);
void cl_break( struct clsoftc *sc, int channel);
int clmctl(dev_t dev, int bits, int how);
d181 1
a181 1
void cl_dumpport(int channel);
d184 2
a185 2
int	clprobe(struct device *parent, void *self, void *aux);
void	clattach(struct device *parent, struct device *self, void *aux);
d187 10
a196 10
int clopen(dev_t dev, int flag, int mode, struct proc *p);
int clclose(dev_t dev, int flag, int mode, struct proc *p);
int clread(dev_t dev, struct uio *uio, int flag);
int clwrite(dev_t dev, struct uio *uio, int flag);
int clioctl(dev_t dev, int cmd, caddr_t data, int flag, struct proc *p);
int clstop(struct tty *tp, int flag);

void cl_initchannel(struct clsoftc *sc, int channel);
void clputc(struct clsoftc *sc, int unit, u_char c);
u_char clgetc(struct clsoftc *sc, int *channel);
d198 1
a198 1
void cloutput(struct tty *tp);
d201 1
a201 1
void cl_chkinput(void);
d220 1
a220 1
struct tty *cltty(dev_t dev);
d1666 1
a1666 1
		cl_overflow (sc, channel, (long *)&sc->sc_fotime, "fifo");
@


1.5.4.6
log
@Sync the SMP branch with 3.3
@
text
@d36 1
d46 1
a47 2
#include <machine/conf.h>
#include <machine/cpu.h>
a50 1

d61 1
a61 1
#define splcl()	spltty()
d162 1
a162 1
void clcnputc(dev_t dev, u_char c);
d187 7
a375 1

d426 1
a426 2
int
clmctl(dev, bits, how)
d518 1
a518 2
int
clopen(dev, flag, mode, p)
d660 1
a660 3

int
clparam(tp, t)
d727 1
a727 2
int
clclose(dev, flag, mode, p)
d769 1
a769 3

int
clread(dev, uio, flag)
d791 1
a791 2
int
clwrite(dev, uio, flag)
d813 1
a813 2
int
clioctl(dev, cmd, data, flag, p)
d815 1
a815 1
	u_long cmd;
a893 1

a993 1

d1056 1
a1056 1
void
d1061 4
d1066 1
a1080 1

d1111 23
a1133 26
	if (unit == 0) {
		s = splhigh();
		oldchannel = cl_reg->cl_car;
		cl_reg->cl_car = unit;
		schar = cl_reg->cl_schr3;
		cl_reg->cl_schr3 = c;
		cl_reg->cl_stcr = 0x08 | 0x03; /* send special char, char 3 */
		while (0 != cl_reg->cl_stcr) {
			/* wait until cl notices the command
			 * otherwise it may not notice the character
			 * if we send characters too fast.
			 */
		}
		DELAY(5);
		cl_reg->cl_schr3 = schar;
		cl_reg->cl_car = oldchannel;
		splx(s);
	} else {
		s = splhigh();
		oldchannel = cl_reg->cl_car;
		cl_reg->cl_car = unit;
		if (cl_reg->cl_tftc > 0) {
			cl_reg->cl_tdr = c;
		}
		cl_reg->cl_car = oldchannel;
		splx(s);
d1135 3
a1232 1

a1337 1
	splx(s);
a1359 1

a1377 1

a1822 1

a1830 1

@


1.5.4.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.5.4.6 2003/03/27 23:32:17 niklas Exp $ */
d5 1
d15 5
@


1.5.4.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d5 1
a5 1
 *
d25 1
a25 1
 */
d47 3
d67 1
a67 1
#define CL_RXMASK	0x87
d73 3
d108 1
a108 2
char cl_dmabuf[CLCD_PORTS_PER_CHIP * CL_BUFSIZE * 4];
char cl_dmabuf1[CLCD_PORTS_PER_CHIP * CL_BUFSIZE * 4];
d192 1
a192 1
struct cfattach cl_ca = {
d194 2
a195 2
};

d197 2
a198 2
	NULL, "cl", DV_TTY
};
a201 1
#ifdef	CLCD_DO_POLLED_INPUT
a202 1
#endif
d206 1
d208 3
a210 2
struct tty *
cltty(dev)
a214 1

d216 2
a217 2
	if (unit >= cl_cd.cd_ndevs ||
	    (sc = (struct clsoftc *)cl_cd.cd_devs[unit]) == NULL) {
d224 1
a224 1
int
d230 4
d236 1
a236 1

d238 1
a238 1
		return (0);
d240 3
a242 8
	/*
	 * We do not accept empty locators here...
	 */
	if ((vaddr_t)ca->ca_paddr == CD2400_BASE_ADDR ||
	    ((vaddr_t)ca->ca_paddr == CD2400_SECONDARY_ADDR &&
	     brdtyp == BRD_8120)) {
		ca->ca_ipl = IPL_TTY;
		ca->ca_vaddr = ca->ca_paddr;
d244 3
a246 4
		cl_reg = (struct clreg *)ca->ca_vaddr;
		return (!badvaddr((vaddr_t)&cl_reg->cl_gfrcr, 1));
	} else
		return (0);
d266 1
a266 1
		printf(": console ");
d283 1
a283 5
	/* XXX */
	if ((vaddr_t)ca->ca_paddr == CD2400_BASE_ADDR)
		sc->sc_cl[0].rx[0] = (void *)(&cl_dmabuf);
	else
		sc->sc_cl[0].rx[0] = (void *)(&cl_dmabuf1);
a345 1
#ifdef CLCD_DO_POLLED_INPUT
a346 1
#endif
d380 1
a380 1
		cl_reg->cl_cmr	= 0x02;
d486 1
d519 1
a519 1

d521 1
a521 1
	if (unit >= cl_cd.cd_ndevs ||
d532 1
d586 1
a586 1
				/* CL_TXDMAINT | */ CL_RXDMAINT;
d616 1
a616 1
			sc->cl_reg->cl_cmr	= 0x42;
d620 1
a620 1
			sc->cl_reg->cl_cmr	= 0x82;
d664 1
a664 1
	if (unit >= cl_cd.cd_ndevs ||
d693 1
a693 1
	if (unit >= cl_cd.cd_ndevs ||
d733 1
a733 1
	if (unit >= cl_cd.cd_ndevs ||
d743 1
a743 1

d775 1
a775 1
	if (unit >= cl_cd.cd_ndevs ||
d798 1
a798 1
	if (unit >= cl_cd.cd_ndevs ||
d824 1
a824 1
	if (unit >= cl_cd.cd_ndevs ||
d878 1
a878 1
		error = suser(p, 0);
d880 1
a880 1
			return(EPERM);
d944 1
a944 1

d1052 1
a1052 1

d1150 1
a1150 1
		if (unit >= cl_cd.cd_ndevs ||
d1177 1
a1177 1
u_char
d1241 1
a1241 1
	if (par->c_ospeed == 0) {
d1297 1
a1297 1
		if (sc->cl_reg->cl_cor1 != cor1) {
d1341 1
a1341 1
u_char
d1359 1
a1359 1
u_char
d1378 1
a1378 1
u_char
d1427 1
a1427 1
	if (unit >= cl_cd.cd_ndevs ||
d1490 1
a1490 1
		log(LOG_WARNING, "cl_mintr: channel %x cts %x\n",channel,
d1558 1
a1558 1
				log(LOG_WARNING, "cl_txintr: resid %x cnt %x pbuf %p\n",
d1646 1
a1646 1

d1710 1
a1710 1
#else
@


1.5.4.9
log
@Merge with the trunk
@
text
@a41 1
#include <machine/locore.h>
a47 1
#include <mvme88k/dev/pcctwovar.h>
d68 2
d71 4
a74 4
	bus_space_tag_t		cl_iot;
	bus_space_handle_t	cl_ioh;
	volatile u_int8_t	*cl_rxiack;
	u_int8_t		channel;
a87 1
#if 0
a88 1
#endif
d107 8
a114 7
	struct device		sc_dev;
	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
	struct evcnt		sc_txintrcnt;
	struct evcnt		sc_rxintrcnt;
	struct evcnt		sc_mxintrcnt;
	time_t			sc_fotime;	/* time of last fifo overrun */
d120 2
a121 1
	struct pcctwosoftc	*sc_pcctwo;
d123 1
a123 2

const struct {
a146 2
#define	CL_SAFE_CLOCK	4	/* 9600 entry */

d148 2
a149 1
cons_decl(cl);
d151 6
a156 3
u_int8_t cl_clkdiv(int speed);
u_int8_t cl_clknum(int speed);
u_int8_t cl_clkrxtimeout(int speed);
d165 1
a165 1
void cl_overflow(struct clsoftc *sc, int channel, long *ptime, char *msg);
d171 1
a171 1
void cl_dumpport(struct clsoftc *, int);
d177 9
a185 2
void	cl_initchannel(struct clsoftc *sc, int channel);
void	clputc(struct clsoftc *sc, int unit, u_char c);
a194 1
#if 0
d196 3
a198 1
void cloutput(struct tty *tp);
d214 1
a214 1
		return NULL;
d226 1
a227 2
	bus_space_handle_t ioh;
	int rc;
d230 1
a230 1
		return 0;
d235 5
a239 9
	if (ca->ca_paddr == CD2400_BASE_ADDR ||
	    (ca->ca_paddr == CD2400_SECONDARY_ADDR && brdtyp == BRD_8120)) {
		if (bus_space_map(ca->ca_iot, ca->ca_paddr, CD2400_SIZE,
		    0, &ioh) != 0)
			return 0;
		rc = badvaddr((vaddr_t)bus_space_vaddr(ca->ca_iot, ioh), 1);
		bus_space_unmap(ca->ca_iot, ca->ca_paddr, CD2400_SIZE);
		return rc == 0;
	}
d241 4
a244 1
	return 0;
a254 2
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
d257 2
a258 2
	if (ca->ca_ipl < 0)
		ca->ca_ipl = IPL_TTY;
d260 3
a262 14
	iot = sc->sc_iot = ca->ca_iot;
	if (bus_space_map(iot, ca->ca_paddr, CD2400_SIZE, 0, &ioh) != 0) {
		printf(": can't map registers!\n");
		return;
	}
	sc->sc_ioh = ioh;
	sc->sc_pcctwo = (struct pcctwosoftc *)parent;

	if (ca->ca_paddr == CD2400_BASE_ADDR) {
		/*
		 * Although we are still running using the BUG routines,
		 * this device will be elected as the console after
		 * autoconf. Mark it as such.
		 */
d264 1
a264 1
		printf(": console");
d269 2
a270 2
	/* allow chip to settle before continuing */
	delay(800);
d273 4
a276 4
	bus_space_write_1(iot, ioh, CL_TPR, CL_TIMEOUT);
	bus_space_write_1(iot, ioh, CL_RPILR, 0x03);
	bus_space_write_1(iot, ioh, CL_TPILR, 0x02);
	bus_space_write_1(iot, ioh, CL_MPILR, 0x01);
a327 5

	/* clear errors */
	bus_space_write_1(sc->sc_pcctwo->sc_iot, sc->sc_pcctwo->sc_ioh,
	    PCCTWO_SCCERR, 0x01);

d348 14
a361 12

	pcctwointr_establish(PCC2V_SCC_RXE, &sc->sc_ih_e);
	pcctwointr_establish(PCC2V_SCC_M, &sc->sc_ih_m);
	pcctwointr_establish(PCC2V_SCC_TX, &sc->sc_ih_t);
	pcctwointr_establish(PCC2V_SCC_RX, &sc->sc_ih_r);

	bus_space_write_1(sc->sc_pcctwo->sc_iot, sc->sc_pcctwo->sc_ioh,
	    PCCTWO_SCCICR, PCC2_IRQ_IEN | (ca->ca_ipl & PCC2_IRQ_IPL));
	bus_space_write_1(sc->sc_pcctwo->sc_iot, sc->sc_pcctwo->sc_ioh,
	    PCCTWO_SCCTX, PCC2_IRQ_IEN | (ca->ca_ipl & PCC2_IRQ_IPL));
	bus_space_write_1(sc->sc_pcctwo->sc_iot, sc->sc_pcctwo->sc_ioh,
	    PCCTWO_SCCRX, PCC2_IRQ_IEN | (ca->ca_ipl & PCC2_IRQ_IPL));
a365 1

d375 1
a375 6
	bus_space_tag_t iot;
	bus_space_handle_t ioh;

	iot = sc->sc_iot;
	ioh = sc->sc_ioh;

d379 24
a402 25

	bus_space_write_1(iot, ioh, CL_CAR, channel);
	bus_space_write_1(iot, ioh, CL_LIVR, PCC2_VECT + PCC2V_SCC_RXE);
	bus_space_write_1(iot, ioh, CL_IER, 0);

	if (sc->sc_cl[channel].cl_consio == 0) {
		bus_space_write_1(iot, ioh, CL_CMR, 0x02);
		bus_space_write_1(iot, ioh, CL_COR1, 0x17);
		bus_space_write_1(iot, ioh, CL_COR2, 0x00);
		bus_space_write_1(iot, ioh, CL_COR3, 0x02);
		bus_space_write_1(iot, ioh, CL_COR4, 0xec);
		bus_space_write_1(iot, ioh, CL_COR5, 0xec);
		bus_space_write_1(iot, ioh, CL_COR6, 0x00);
		bus_space_write_1(iot, ioh, CL_COR7, 0x00);
		bus_space_write_1(iot, ioh, CL_SCHR1, 0x00);
		bus_space_write_1(iot, ioh, CL_SCHR2, 0x00);
		bus_space_write_1(iot, ioh, CL_SCHR3, 0x00);
		bus_space_write_1(iot, ioh, CL_SCHR4, 0x00);
		bus_space_write_1(iot, ioh, CL_SCRL, 0x00);
		bus_space_write_1(iot, ioh, CL_SCRH, 0x00);
		bus_space_write_1(iot, ioh, CL_LNXT, 0x00);
		bus_space_write_1(iot, ioh, CL_RBPR, 0x40);	/* 9600 */
		bus_space_write_1(iot, ioh, CL_RCOR, 0x01);
		bus_space_write_1(iot, ioh, CL_TBPR, 0x40);	/* 9600 */
		bus_space_write_1(iot, ioh, CL_TCOR, 0x01 << 5);
d404 8
a411 8
		bus_space_write_1(iot, ioh, CL_MSVR_RTS, 0x00);
		bus_space_write_1(iot, ioh, CL_MSVR_DTR, 0x00);
		bus_space_write_1(iot, ioh, CL_RTPRL, CL_RX_TIMEOUT);
		bus_space_write_1(iot, ioh, CL_RTPRH, 0x00);
	}
	bus_space_write_1(iot, ioh, CL_CCR, 0x20);
	while (bus_space_read_1(iot, ioh, CL_CCR) != 0)
		;
d425 1
a426 4
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	int s;

d428 4
a431 4
	sc = (struct clsoftc *)cl_cd.cd_devs[CL_UNIT(dev)];
	iot = sc->sc_iot;
	ioh = sc->sc_ioh;

d436 10
a445 8
		if (bits & TIOCM_RTS)
			bus_space_write_1(iot, ioh, CL_MSVR_RTS, 0x01);
		else
			bus_space_write_1(iot, ioh, CL_MSVR_RTS, 0x00);
		if (bits & TIOCM_DTR)
			bus_space_write_1(iot, ioh, CL_MSVR_DTR, 0x02);
		else
			bus_space_write_1(iot, ioh, CL_MSVR_DTR, 0x00);
d449 6
a454 4
		if (bits & TIOCM_RTS)
			bus_space_write_1(iot, ioh, CL_MSVR_RTS, 0x00);
		if (bits & TIOCM_DTR)
			bus_space_write_1(iot, ioh, CL_MSVR_DTR, 0x00);
d458 6
a463 4
		if (bits & TIOCM_RTS)
			bus_space_write_1(iot, ioh, CL_MSVR_RTS, 0x01);
		if (bits & TIOCM_DTR)
			bus_space_write_1(iot, ioh, CL_MSVR_DTR, 0x02);
d470 3
a472 4
			u_int8_t msvr;

			msvr = bus_space_read_1(iot, ioh, CL_MSVR_RTS);
			if (msvr & 0x80)
d474 2
a475 1
			if (msvr & 0x40)
d477 2
a478 1
			if (msvr & 0x20)
d480 2
a481 1
			if (msvr & 0x10)
d483 2
a484 1
			if (msvr & 0x02)
d486 2
a487 1
			if (msvr & 0x01)
d489 1
d505 4
a508 1
	return bits;
d525 2
a526 2
	    (sc = (struct clsoftc *)cl_cd.cd_devs[unit]) == NULL) {
		return ENODEV;
a527 1

a529 1

d552 1
a552 1
			if (sc->sc_cl[channel].cl_consio != 0) {
d582 47
a628 8
			u_int8_t save;

			save = bus_space_read_1(sc->sc_iot, sc->sc_ioh, CL_CAR);
			bus_space_write_1(sc->sc_iot, sc->sc_ioh, CL_CAR,
			    channel);
			bus_space_write_1(sc->sc_iot, sc->sc_ioh, CL_IER, 0x88);
			bus_space_write_1(sc->sc_iot, sc->sc_ioh, CL_CAR,
			    save);
d632 1
a632 1
		return EBUSY;
d634 8
a642 1

d649 1
a649 1
	cl_dumpport(sc, channel);
d651 1
a651 1
	return (*linesw[tp->t_line].l_open)(dev, tp);
d667 2
a668 2
	    (sc = (struct clsoftc *)cl_cd.cd_devs[unit]) == NULL) {
		return ENODEV;
d696 1
a696 1
	    (sc = (struct clsoftc *)cl_cd.cd_devs[unit]) == NULL) {
a732 2
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
a733 1

d736 2
a737 2
	    (sc = (struct clsoftc *)cl_cd.cd_devs[unit]) == NULL) {
		return ENODEV;
a740 2
	iot = sc->sc_iot;
	ioh = sc->sc_ioh;
d745 6
a750 5
	bus_space_write_1(iot, ioh, CL_CAR, channel);
	if (cl->cl_consio == 0 && (tp->t_cflag & HUPCL) != 0) {
		bus_space_write_1(iot, ioh, CL_MSVR_RTS, 0x00);
		bus_space_write_1(iot, ioh, CL_MSVR_DTR, 0x00);
		bus_space_write_1(iot, ioh, CL_CCR, 0x05);
a752 1

d760 1
a760 1
	cl_dumpport(sc, channel);
d778 2
a779 2
	    (sc = (struct clsoftc *)cl_cd.cd_devs[unit]) == NULL) {
		return ENODEV;
d784 1
a784 1
	if (tp == NULL)
d786 1
a786 1
	return (*linesw[tp->t_line].l_read)(tp, uio, flag);
d801 2
a802 2
	    (sc = (struct clsoftc *)cl_cd.cd_devs[unit]) == NULL) {
		return ENODEV;
d807 1
a807 1
	if (tp == NULL)
d809 1
a809 1
	return (*linesw[tp->t_line].l_write)(tp, uio, flag);
d827 2
a828 2
	    (sc = (struct clsoftc *)cl_cd.cd_devs[unit]) == NULL) {
		return ENODEV;
d833 1
a833 1
	if (tp == NULL)
d838 1
a838 1
		return error;
d842 1
a842 1
		return error;
d882 1
a882 1
			return EPERM;
d889 1
a889 1
		return ENOTTY;
d911 8
a918 1
void
d922 2
a925 2
	cp->cn_pri = CN_DEAD;

d927 4
a930 7
	if (brdtyp == BRD_188 || badaddr(CD2400_BASE_ADDR, 1) != 0)
		return;

	/* do not attach as console if cl has been disabled */
	if (cl_cd.cd_ndevs == 0 || cl_cd.cd_devs[0] == NULL)
		return;

d935 2
a936 2
	if (maj == nchrdev)
		return;
d938 1
a938 2
	cp->cn_dev = makedev(maj, 0);
	cp->cn_pri = CN_NORMAL;
d941 1
a941 1
void
d945 1
a945 1
	struct clsoftc *sc;
d947 34
a980 4
	sc = (struct clsoftc *)cl_cd.cd_devs[0];
	cl_cons.cl_iot = sc->sc_iot;
	cl_cons.cl_ioh = sc->sc_ioh;
	cl_cons.cl_rxiack = (void *)(sc->sc_pcctwo->sc_base + PCCTWO_SCCRXIACK);
d987 7
a993 8
	u_int8_t rir;

	if (sc == NULL)
		rir = bus_space_read_1(cl_cons.cl_iot, cl_cons.cl_ioh, CL_RIR);
	else
		rir = bus_space_read_1(sc->sc_iot, sc->sc_ioh, CL_RIR);

	return (rir & 0x40);
d1000 4
a1003 1
	u_int8_t val, reoir, licr, data;
d1005 8
a1012 13
	u_int8_t ier_old;
	bus_space_tag_t iot;
	bus_space_handle_t ioh;

	iot = cl_cons.cl_iot;
	ioh = cl_cons.cl_ioh;

	bus_space_write_1(iot, ioh, CL_CAR, 0);
	ier_old = bus_space_read_1(iot, ioh, CL_IER);
	if ((ier_old & 0x08) == 0) {
		bus_space_write_1(iot, ioh, CL_IER, 0x08);
	} else
		ier_old = 0xff;
d1015 1
a1015 1
		val = bus_space_read_1(iot, ioh, CL_RIR);
d1017 1
a1017 1
		if ((val & 0x80) == 0)
d1019 1
a1019 1

d1021 2
a1022 3
		reoir = *cl_cons.cl_rxiack; /* receive PIACK */
		licr = bus_space_read_1(iot, ioh, CL_LICR);
		/* is the interrupt for us? (port 0) */
d1024 23
a1046 5
			(void)bus_space_read_1(iot, ioh, CL_RISRL);
			(void)bus_space_read_1(iot, ioh, CL_RFOC);
			data = bus_space_read_1(iot, ioh, CL_RDR);
			if (ier_old != 0xff)
				bus_space_write_1(iot, ioh, CL_IER, ier_old);
d1048 1
d1050 2
a1051 2
			/* read and discard the character */
			data = bus_space_read_1(iot, ioh, CL_RDR);
a1052 1
		bus_space_write_1(iot, ioh, CL_TEOIR, 0x00);
d1071 1
a1071 1
	if (on != 0) {
d1076 1
a1084 4
	u_int8_t schar;
	u_int8_t oldchannel;
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
d1086 4
a1089 2

	if (sc == NULL) {
d1091 1
a1091 2
		iot = cl_cons.cl_iot;
		ioh = cl_cons.cl_ioh;
d1093 13
a1105 2
		iot = sc->sc_iot;
		ioh = sc->sc_ioh;
d1107 2
a1108 4

	s = splhigh();
	oldchannel = bus_space_read_1(iot, ioh, CL_CAR);
	bus_space_write_1(iot, ioh, CL_CAR, unit);
d1110 7
a1116 5
		schar = bus_space_read_1(iot, ioh, CL_SCHR3);
		/* send special char, number 3 */
		bus_space_write_1(iot, ioh, CL_SCHR3, c);
		bus_space_write_1(iot, ioh, CL_STCR, 0x08 | 3);
		while (bus_space_read_1(iot, ioh, CL_STCR) != 0) {
d1123 102
a1224 1
		bus_space_write_1(iot, ioh, CL_SCHR3, schar);
d1226 2
a1227 2
		if (bus_space_read_1(iot, ioh, CL_TFTC) != 0)
			bus_space_write_1(iot, ioh, CL_TDR, c);
d1229 1
a1229 2
	bus_space_write_1(iot, ioh, CL_CAR, oldchannel);
	splx(s);
a1237 2
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
a1240 3
	iot = sc->sc_iot;
	ioh = sc->sc_ioh;

d1242 1
a1242 1
	bus_space_write_1(iot, ioh, CL_CAR, channel);
d1245 1
a1245 1
		if (sc->sc_cl[channel].cl_consio == 0) {
d1247 3
a1249 3
			bus_space_write_1(iot, ioh, CL_MSVR_RTS, 0x00);
			bus_space_write_1(iot, ioh, CL_MSVR_DTR, 0x00);
			bus_space_write_1(iot, ioh, CL_CCR, 0x05);
d1252 1
a1252 1
		return 0xff;
d1255 2
a1256 2
	bus_space_write_1(iot, ioh, CL_MSVR_RTS, 0x03);
	bus_space_write_1(iot, ioh, CL_MSVR_DTR, 0x03);
d1260 2
a1261 2
	bus_space_write_1(iot, ioh, CL_TBPR, divisor);
	bus_space_write_1(iot, ioh, CL_TCOR, clk << 5);
d1264 4
a1267 4
	bus_space_write_1(iot, ioh, CL_RBPR, divisor);
	bus_space_write_1(iot, ioh, CL_RCOR, clk);
	bus_space_write_1(iot, ioh, CL_RTPRL, cl_clkrxtimeout(par->c_ispeed));
	bus_space_write_1(iot, ioh, CL_RTPRH, 0x00);
d1286 1
a1286 2

	bus_space_write_1(iot, ioh, CL_COR3, par->c_cflag & PARENB ? 4 : 2);
d1289 1
a1289 1
		u_int8_t cor1;
d1299 5
a1303 6

		if (bus_space_read_1(iot, ioh, CL_COR1) != cor1) {
			bus_space_write_1(iot, ioh, CL_COR1, cor1);
			bus_space_write_1(iot, ioh, CL_CCR, 0x20);
			while (bus_space_read_1(iot, ioh, CL_CCR) != 0)
				;
d1307 9
a1315 8
	if (sc->sc_cl[channel].cl_consio == 0 && (par->c_cflag & CREAD) == 0)
		bus_space_write_1(iot, ioh, CL_CCR, 0x08);
	else
		bus_space_write_1(iot, ioh, CL_CCR, 0x0a);

	while (bus_space_read_1(iot, ioh, CL_CCR) != 0)
		;

d1334 2
a1335 2
	bus_space_write_1(iot, ioh, CL_COR4, ints | CL_FIFO_CNT);
	bus_space_write_1(iot, ioh, CL_COR5, ints | CL_FIFO_CNT);
a1337 1

d1343 1
a1343 1
u_int8_t
d1347 2
a1348 3
	int i;

	if (cl_clocks[clknum].speed == speed)
d1350 1
a1350 1

a1356 1

d1358 1
a1358 1
	return cl_clocks[CL_SAFE_CLOCK].divisor;
d1361 1
a1361 1
u_int8_t
d1365 3
a1367 3
	int i;

	if (cl_clocks[clknum].speed == speed)
d1369 2
a1370 2

	for (i = 0; cl_clocks[i].speed != 0; i++) {
a1375 1

d1377 1
a1377 1
	return cl_clocks[CL_SAFE_CLOCK].clock;
d1380 1
a1380 1
u_int8_t
d1384 2
a1385 3
	int i;

	if (cl_clocks[clknum].speed == speed)
d1387 1
a1387 1

a1393 1

d1395 1
a1395 1
	return cl_clocks[CL_SAFE_CLOCK].rx_timeout;
d1416 1
a1416 1
	u_int8_t cbuf;
d1430 1
a1430 1
	    (sc = (struct clsoftc *)cl_cd.cd_devs[unit]) == NULL) {
d1447 2
a1448 2
		bus_space_write_1(sc->sc_iot, sc->sc_ioh, CL_CAR, channel);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh, CL_TDR, cbuf);
d1456 2
a1457 3
		bus_space_write_1(sc->sc_iot, sc->sc_ioh, CL_CAR, channel);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh, CL_IER,
		    bus_space_read_1(sc->sc_iot, sc->sc_ioh, CL_IER) | 0x03);
d1461 1
d1469 2
a1470 3
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	u_int8_t mir, misr, msvr;
d1473 1
a1473 5
	iot = sc->sc_iot;
	ioh = sc->sc_ioh;

	mir = bus_space_read_1(iot, ioh, CL_MIR);
	if ((mir & 0x40) == 0) {
d1481 2
a1482 2
	misr = bus_space_read_1(iot, ioh, CL_MISR);
	msvr = bus_space_read_1(iot, ioh, CL_MSVR_RTS);
a1491 1
#ifdef DEBUG
d1493 1
a1493 1
		    ((msvr & 0x20) != 0x0)
a1494 1
#endif
a1497 1
#ifdef DEBUG
d1499 1
a1499 1
		    ((msvr & 0x40) != 0x0)
a1500 1
#endif
a1503 1
#ifdef DEBUG
a1506 1
#endif
d1508 1
a1508 1
	bus_space_write_1(iot, ioh, CL_MEOIR, 0);
a1515 1
	static int empty;
d1517 4
a1520 4
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	u_int8_t tir, cmr, teoir;
	u_int8_t max;
d1525 2
a1526 5

	iot = sc->sc_iot;
	ioh = sc->sc_ioh;
	tir = bus_space_read_1(iot, ioh, CL_TIR);
	if ((tir & 0x40) == 0) {
d1534 2
a1537 2
	cmr = bus_space_read_1(iot, ioh, CL_CMR);

d1540 2
a1541 3
		bus_space_write_1(iot, ioh, CL_IER,
		    bus_space_read_1(iot, ioh, CL_IER) & ~0x03);
		bus_space_write_1(iot, ioh, CL_TEOIR, 0x08);
a1543 1

d1546 35
a1580 27
	{
		u_int8_t dmabsts;
		int nbuf, busy, resid;
		void *pbuffer;

		dmabsts = bus_space_read_1(iot, ioh, CL_DMABSTS);
		nbuf = ((dmabsts & 0x8) >> 3) & 0x1;
		busy = ((dmabsts & 0x4) >> 2) & 0x1;

		do {
			pbuffer = sc->sc_cl[channel].tx[nbuf];
			resid = tp->t_outq.c_cc;
			cnt = min (CL_BUFSIZE,resid);
			log(LOG_WARNING, "cl_txintr: resid %x cnt %x pbuf %p\n",
			    resid, cnt, pbuffer);
			if (cnt != 0) {
				cnt = q_to_b(&tp->t_outq, pbuffer, cnt);
				resid -= cnt;
				if (nbuf == 0) {
					bus_space_write_2(iot, ioh, CL_ATBADRU,
					    ((u_long)sc->sc_cl[channel].txp[nbuf]) >> 16);
					bus_space_write_2(iot, ioh, CL_ATBADRL,
					    ((u_long) sc->sc_cl[channel].txp[nbuf]) & 0xffff);
					bus_space_write_2(iot, ioh, CL_ATBCNT,
					    cnt);
					bus_space_write_1(iot, ioh, CL_ATBSTS,
					    0x43);
d1582 8
a1589 17
					bus_space_write_2(iot, ioh, CL_BTBADRU,
					    ((u_long)sc->sc_cl[channel].txp[nbuf]) >> 16);
					bus_space_write_2(iot, ioh, CL_BTBADRL,
					    ((u_long) sc->sc_cl[channel].txp[nbuf]) & 0xffff);
					bus_space_write_2(iot, ioh, CL_BTBCNT,
					    cnt);
					bus_space_write_1(iot, ioh, CL_BTBSTS,
					    0x43);
				}
				teoir = 0x08;
			} else {
				teoir = 0x08;
				if (tp->t_state & TS_BUSY) {
					tp->t_state &= ~(TS_BUSY | TS_FLUSH);
					if (tp->t_state & TS_ASLEEP) {
						tp->t_state &= ~TS_ASLEEP;
						wakeup((caddr_t) &tp->t_outq);
d1591 1
a1591 1
					selwakeup(&tp->t_wsel);
d1593 5
a1597 7
				bus_space_write_1(iot, ioh, CL_IER,
				    bus_space_read_1(iot, ioh, CL_IER) & ~0x03);
			}
			nbuf = ~nbuf & 0x1;
			busy--;
		} while (resid != 0 && busy != -1);/* if not busy do other buffer */
	}
d1600 2
a1601 2
		max = bus_space_read_1(iot, ioh, CL_TFTC);
		cnt = min((int)max,tp->t_outq.c_cc);
d1605 3
a1607 1
			bus_space_write_multi_1(iot, ioh, CL_TDR, buffer, cnt);
d1624 1
a1624 2
			bus_space_write_1(iot, ioh, CL_IER,
			    bus_space_read_1(iot, ioh, CL_IER) & ~0x03);
d1632 1
a1632 1
	bus_space_write_1(iot, ioh, CL_TEOIR, teoir);
d1641 3
a1643 4
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	u_int8_t rir, channel, cmr, risrl;
	u_int8_t fifocnt;
d1646 1
a1646 1
	u_int8_t reoir;
a1647 6
#ifdef DDB
	int wantddb = 0;
#endif

	iot = sc->sc_iot;
	ioh = sc->sc_ioh;
d1649 2
a1650 2
	rir = bus_space_read_1(iot, ioh, CL_RIR);
	if ((rir & 0x40) == 0x0) {
d1657 2
a1658 1
	cmr = bus_space_read_1(iot, ioh, CL_CMR);
d1661 1
a1661 1
	risrl = bus_space_read_1(iot, ioh, CL_RISRL);
d1664 1
d1666 1
a1666 1
	/* We don't need no stinkin special characters */
d1668 2
a1669 1
		cl_overflow(sc, channel, (long *)&sc->sc_fotime, "fifo");
d1673 1
d1677 1
a1679 4
#ifdef DDB
		if (sc->sc_cl[channel].cl_consio)
			wantddb = db_console;
#endif
d1681 1
a1682 1
	reoir = 0x08;
d1686 24
a1709 18
	{
		int nbuf;
		u_int16_t cnt;
		int bufcomplete;
		u_int8_t status, dmabsts;
		u_int8_t risrh;

		risrh = bus_space_read_1(iot, ioh, CL_RISRH);
		dmabsts = bus_space_read_1(iot, ioh, CL_DMABSTS);
		nbuf = (risrh & 0x08) ? 1 : 0;
		bufcomplete = (risrh & 0x20) ? 1 : 0;
		if (nbuf == 0) {
			cnt = bus_space_read_2(iot, ioh, CL_ARBCNT);
			status = bus_space_read_1(iot, ioh, CL_ARBSTS);
		} else {
			cnt = bus_space_read_2(iot, ioh, CL_BRBCNT);
			status = bus_space_read_1(iot, ioh, CL_BRBSTS);
		}
d1711 1
a1711 1
		cl_appendbufn(sc, channel, sc->rx[nbuf], cnt);
a1712 7
		{
			int i;
			u_char *pbuf;

			tp = sc->sc_cl[channel].tty;
			pbuf = sc->sc_cl[channel].rx[nbuf];
			/* this should be done at off level */
d1714 40
a1753 24
				u_int16_t rcbadru, rcbadrl;
				u_int8_t arbsts, brbsts;
				u_char *pbufs, *pbufe;

				rcbadru = bus_space_read_2(iot, ioh,
				    CL_RCBADRU);
				rcbadrl = bus_space_read_2(iot, ioh,
				    CL_RCBADRL);
				arbsts = bus_space_read_1(iot, ioh, CL_ARBSTS);
				brbsts = bus_space_read_1(iot, ioh, CL_BRBSTS);
				pbufs = sc->sc_cl[channel].rxp[nbuf];
				pbufe = (u_char *)(((u_long)rcbadru << 16) | (u_long)rcbadrl);
				cnt = pbufe - pbufs;
			}
			reoir = 0x0 | (bufcomplete) ? 0 : 0xd0;
			bus_space_write_1(iot, ioh, CL_REOIR, reoir);

			DELAY(10); /* give the chip a moment */

			for (i = 0; i < cnt; i++) {
				u_char c;
				c = pbuf[i];
				(*linesw[tp->t_line].l_rint)(c,tp);
			}
d1755 7
a1761 8
			if (nbuf == 0) {
				bus_space_write_2(iot, ioh, CL_ARBCNT,
				    CL_BUFSIZE);
				bus_space_write_2(iot, ioh, CL_ARBSTS, 0x01);
			} else {
				bus_space_write_2(iot, ioh, CL_BRBCNT,
				    CL_BUFSIZE);
				bus_space_write_2(iot, ioh, CL_BRBSTS, 0x01);
d1763 1
d1765 1
a1765 3
#endif
	}
		bus_space_write_1(iot, ioh, CL_REOIR, reoir);
d1768 1
a1768 1
		fifocnt = bus_space_read_1(iot, ioh, CL_RFOC);
d1770 4
a1773 2
		bus_space_read_multi_1(iot, ioh, CL_RDR, buffer, fifocnt);
		if (tp == NULL) {
d1782 1
a1782 1
		bus_space_write_1(iot, ioh, CL_REOIR, reoir);
d1793 1
d1800 2
a1801 1
		bus_space_write_1(iot, ioh, CL_REOIR, 0x08);
a1802 4
#ifdef DDB
	if (wantddb != 0)
		Debugger();
#endif
d1807 1
a1807 1
cl_overflow(sc, channel, ptime, msg)
d1811 1
a1811 1
	char *msg;
d1813 11
a1823 2
	log(LOG_WARNING, "%s[%d]: %s overrun\n", sc->sc_dev.dv_xname,
	    channel, msg);
d1827 1
a1827 1
cl_parity(sc, channel)
d1831 2
a1832 2
	log(LOG_WARNING, "%s[%d]: parity error\n", sc->sc_dev.dv_xname,
	    channel);
d1836 1
a1836 1
cl_frame(sc, channel)
d1840 2
a1841 2
	log(LOG_WARNING, "%s[%d]: frame error\n", sc->sc_dev.dv_xname,
	    channel);
a1842 1

d1844 1
a1844 1
cl_break(sc, channel)
d1848 5
a1852 3
#ifdef DEBUG
	log(LOG_WARNING, "%s[%d]: break detected\n", sc->sc_dev.dv_xname,
	    channel);
d1854 1
d1859 2
a1860 1
cl_dumpport(struct clsoftc *sc, int channel)
d1862 14
a1875 11
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	u_int8_t livr, cmr, cor1, cor2, cor3, cor4, cor5, cor6, cor7,
	    schr1, schr2, schr3, schr4, scrl, scrh, lnxt,
	    rbpr, rcor, tbpr, tcor, rpilr, rir, tpr, ier, ccr,
	    dmabsts, arbsts, brbsts, atbsts, btbsts,
	    csr, rts, dtr, rtprl, rtprh;
	u_int16_t rcbadru, rcbadrl, arbadru, arbadrl, arbcnt,
	    brbadru, brbadrl, brbcnt;
	u_int16_t tcbadru, tcbadrl, atbadru, atbadrl, atbcnt,
	    btbadru, btbadrl, btbcnt;
d1878 3
a1880 2
	iot = sc->sc_iot;
	ioh = sc->sc_ioh;
d1883 62
a1944 52
	bus_space_write_1(iot, ioh, CL_CAR, channel);
	livr = bus_space_read_1(iot, ioh, CL_LIVR);
	cmr = bus_space_read_1(iot, ioh, CL_CMR);
	cor1 = bus_space_read_1(iot, ioh, CL_COR1);
	cor2 = bus_space_read_1(iot, ioh, CL_COR2);
	cor3 = bus_space_read_1(iot, ioh, CL_COR3);
	cor4 = bus_space_read_1(iot, ioh, CL_COR4);
	cor5 = bus_space_read_1(iot, ioh, CL_COR5);
	cor6 = bus_space_read_1(iot, ioh, CL_COR6);
	cor7 = bus_space_read_1(iot, ioh, CL_COR7);
	schr1 = bus_space_read_1(iot, ioh, CL_SCHR1);
	schr2 = bus_space_read_1(iot, ioh, CL_SCHR2);
	schr3 = bus_space_read_1(iot, ioh, CL_SCHR3);
	schr4 = bus_space_read_1(iot, ioh, CL_SCHR4);
	scrl = bus_space_read_1(iot, ioh, CL_SCRL);
	scrh = bus_space_read_1(iot, ioh, CL_SCRH);
	lnxt = bus_space_read_1(iot, ioh, CL_LNXT);
	rbpr = bus_space_read_1(iot, ioh, CL_RBPR);
	rcor = bus_space_read_1(iot, ioh, CL_RCOR);
	tbpr = bus_space_read_1(iot, ioh, CL_TBPR);
	rpilr = bus_space_read_1(iot, ioh, CL_RPILR);
	rir = bus_space_read_1(iot, ioh, CL_RIR);
	ier = bus_space_read_1(iot, ioh, CL_IER);
	ccr = bus_space_read_1(iot, ioh, CL_CCR);
	tcor = bus_space_read_1(iot, ioh, CL_TCOR);
	csr = bus_space_read_1(iot, ioh, CL_CSR);
	tpr = bus_space_read_1(iot, ioh, CL_TPR);
	rts = bus_space_read_1(iot, ioh, CL_MSVR_RTS);
	dtr = bus_space_read_1(iot, ioh, CL_MSVR_DTR);
	rtprl = bus_space_read_1(iot, ioh, CL_RTPRL);
	rtprh = bus_space_read_1(iot, ioh, CL_RTPRH);
	dmabsts = bus_space_read_1(iot, ioh, CL_DMABSTS);
	tcbadru = bus_space_read_2(iot, ioh, CL_TCBADRU);
	tcbadrl = bus_space_read_2(iot, ioh, CL_TCBADRL);
	rcbadru = bus_space_read_2(iot, ioh, CL_RCBADRU);
	rcbadrl = bus_space_read_2(iot, ioh, CL_RCBADRL);
	arbadru = bus_space_read_2(iot, ioh, CL_ARBADRU);
	arbadrl = bus_space_read_2(iot, ioh, CL_ARBADRL);
	arbcnt  = bus_space_read_2(iot, ioh, CL_ARBCNT);
	arbsts  = bus_space_read_1(iot, ioh, CL_ARBSTS);
	brbadru = bus_space_read_2(iot, ioh, CL_BRBADRU);
	brbadrl = bus_space_read_2(iot, ioh, CL_BRBADRL);
	brbcnt  = bus_space_read_2(iot, ioh, CL_BRBCNT);
	brbsts  = bus_space_read_1(iot, ioh, CL_BRBSTS);
	atbadru = bus_space_read_2(iot, ioh, CL_ATBADRU);
	atbadrl = bus_space_read_2(iot, ioh, CL_ATBADRL);
	atbcnt  = bus_space_read_2(iot, ioh, CL_ATBCNT);
	atbsts  = bus_space_read_1(iot, ioh, CL_ATBSTS);
	btbadru = bus_space_read_2(iot, ioh, CL_BTBADRU);
	btbadrl = bus_space_read_2(iot, ioh, CL_BTBADRL);
	btbcnt  = bus_space_read_2(iot, ioh, CL_BTBCNT);
	btbsts  = bus_space_read_1(iot, ioh, CL_BTBSTS);
d1967 2
d1978 1
@


1.4
log
@Added vme bus device drivers. MVME328, MVME376, MVME332
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.3 1999/01/11 05:11:42 millert Exp $ */
d903 15
a917 10
	int maj;

	/* locate the major number */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == clopen)
			break;
	cp->cn_dev = makedev (maj, 0);
	cp->cn_pri = CN_NORMAL;

	return 1;
@


1.3
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.2 1998/12/15 05:52:29 smurph Exp $ */
a44 1
/* #include <sys/queue.h> */
a47 1
#if defined(MVME187)
a48 3
#else
#include <mvme68k/dev/clreg.h>
#endif
a50 1

a51 3

#if NPCCTWO > 0
#if defined(MVME187)
a52 6
#else
#include <mvme68k/dev/pcctworeg.h>
#endif
#endif

#if defined(MVME187)
a54 3
#else
#define splcl() spl3()
#endif
d219 2
a220 1
int	clprobe(parent, self, aux)
d263 2
a264 2
		sc->sc_cl[cl_cons.channel].cl_consio = 1;
		printf(" console");
d270 1
a270 1
        delay(100);
d343 12
a354 19
	switch (ca->ca_bustype) {
	case BUS_PCCTWO:
		dopoll = 0;
		intr_establish(PCC2_VECT + SRXEIRQ, &sc->sc_ih_e);
		intr_establish(PCC2_VECT + SMOIRQ, &sc->sc_ih_m);
		intr_establish(PCC2_VECT + STxIRQ, &sc->sc_ih_t);
		intr_establish(PCC2_VECT + SRxIRQ, &sc->sc_ih_r);
		sc->sc_pcctwo = ca->ca_master;
		sc->sc_pcctwo->pcc2_sccerr = 0x01; /* clear errors */

		/* enable all interrupts at ca_ipl */
		sc->sc_pcctwo->pcc2_sccirq = 0x10 | (ca->ca_ipl & 0x7);
		sc->sc_pcctwo->pcc2_scctx  = 0x10 | (ca->ca_ipl & 0x7);
		sc->sc_pcctwo->pcc2_sccrx  = 0x10 | (ca->ca_ipl & 0x7);
		break;
	default:	
		/* oops */
		panic ("cl driver on unknown bus");
	}
@


1.2
log
@Commit for the first real OpenBSD mvme88k port.
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.1.1.1 1997/03/03 19:32:04 rahnds Exp $ */
d377 1
a377 1
		panic ("cl driver on unknown bus\n");
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD: cl.c,v 1.14 1996/06/11 10:17:34 deraadt Exp $ */
d87 4
d94 1
a94 1
	volatile struct pcc2reg *pcctwoaddr;
d140 1
a140 1
	struct pcc2reg		*sc_pcctwo;
a247 3
	register struct cfdata *cf = self;
	caddr_t base;

d249 1
a249 11
#if 0
	if (cputyp != CPU_167 && cputyp != CPU_166
#ifdef CPU_187
		&& cputyp != CPU_187
#endif
		)
	{
		return 0;
	}
#endif /* 0 */
	if (cputyp != CPU_187) {
a250 1
	}
d252 3
a254 7
	/*
	 * If bus or name do not match, fail.
	 */
	if (ca->ca_bustype != BUS_PCCTWO ||
		strcmp(cf->cf_driver->cd_name, "cl")) {
		return 0;
	}
d256 6
a261 14
	base = (caddr_t)cf->cf_loc[0];

	if (badpaddr(base, 1) == -1) {
		return 0;
	}

	/*
	 * tell our parent our requirements
	 */
	ca->ca_paddr = (caddr_t)CD2400_BASE_ADDR;
	ca->ca_size = CD2400_SIZE;
	ca->ca_ipl = IPL_TTY;
	
	return 1;
d275 1
a275 1
	sc->sc_pcctwo = (struct pcc2reg *)ca->ca_parent;
d286 3
d367 2
a368 2
		sc->sc_pcctwo = (struct pcc2reg *)ca->ca_parent;
		sc->sc_pcctwo->pcc2_sccerrstat = 0x01; /* clear errors */
d371 3
a373 3
		sc->sc_pcctwo->pcc2_sccmoirq = 0x10 | (ca->ca_ipl & 0x7);
		sc->sc_pcctwo->pcc2_scctxirq  = 0x10 | (ca->ca_ipl & 0x7);
		sc->sc_pcctwo->pcc2_sccrxirq  = 0x10 | (ca->ca_ipl & 0x7);
d943 1
a943 13
#if defined(MVME187)
 	volatile struct clreg *cl_reg;
	extern vm_offset_t clconsvaddr, pcc2consvaddr;
	
	cl_cons.cl_paddr = (void *)CD2400_BASE_ADDR;
	cl_cons.cl_vaddr = (struct clreg *)CD2400_BASE_ADDR;
	cl_cons.pcctwoaddr = (struct pcc2reg *)PCC2_BASE_ADDR;
#else
#ifdef MAP_DOES_WORK
	int size = (0x1ff + PGOFSET) & ~PGOFSET;
	int pcc2_size = (0x3C + PGOFSET) & ~PGOFSET;
#endif
	struct clreg *cl_reg;
a945 4
#ifdef MAP_DOES_WORK
	cl_cons.cl_vaddr = mapiodev(cl_cons.cl_paddr,size);
	cd_pcc2_base = mapiodev(0xfff42000,pcc2_size);
#else
a947 2
#endif
#endif /* defined(MVME187)
d1001 1
a1001 1
	volatile struct pcc2reg *pcc2_base = cl_cons.pcctwoaddr;
d1007 1
d1015 1
a1015 1
		reoir = pcc2_base->pcc2_sccrxpiack; /* receive PIACK */
d1183 1
a1183 1
	volatile struct pcc2reg *pcc2_base;
d1198 1
a1198 1
	reoir = pcc2_base->pcc2_sccrxpiack; /* receive PIACK */
d1652 1
a1652 1
		cl_overflow (sc, channel, &sc->sc_fotime, "fifo");
d1838 3
d1842 1
@


1.1.1.1
log
@Third try at importing the mvme88k port. This is a working kernel
from nivas.
Userland and compiler still need to be worked on.
Make certain what directory the import is done from.
@
text
@@
