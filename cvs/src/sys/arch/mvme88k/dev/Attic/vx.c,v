head	1.44;
access;
symbols
	OPENBSD_5_5:1.43.0.14
	OPENBSD_5_5_BASE:1.43
	OPENBSD_5_4:1.43.0.10
	OPENBSD_5_4_BASE:1.43
	OPENBSD_5_3:1.43.0.8
	OPENBSD_5_3_BASE:1.43
	OPENBSD_5_2:1.43.0.6
	OPENBSD_5_2_BASE:1.43
	OPENBSD_5_1_BASE:1.43
	OPENBSD_5_1:1.43.0.4
	OPENBSD_5_0:1.43.0.2
	OPENBSD_5_0_BASE:1.43
	OPENBSD_4_9:1.42.0.4
	OPENBSD_4_9_BASE:1.42
	OPENBSD_4_8:1.42.0.2
	OPENBSD_4_8_BASE:1.42
	OPENBSD_4_7:1.40.0.2
	OPENBSD_4_7_BASE:1.40
	OPENBSD_4_6:1.39.0.6
	OPENBSD_4_6_BASE:1.39
	OPENBSD_4_5:1.39.0.2
	OPENBSD_4_5_BASE:1.39
	OPENBSD_4_4:1.38.0.10
	OPENBSD_4_4_BASE:1.38
	OPENBSD_4_3:1.38.0.8
	OPENBSD_4_3_BASE:1.38
	OPENBSD_4_2:1.38.0.6
	OPENBSD_4_2_BASE:1.38
	OPENBSD_4_1:1.38.0.4
	OPENBSD_4_1_BASE:1.38
	OPENBSD_4_0:1.38.0.2
	OPENBSD_4_0_BASE:1.38
	OPENBSD_3_9:1.36.0.8
	OPENBSD_3_9_BASE:1.36
	OPENBSD_3_8:1.36.0.6
	OPENBSD_3_8_BASE:1.36
	OPENBSD_3_7:1.36.0.4
	OPENBSD_3_7_BASE:1.36
	OPENBSD_3_6:1.36.0.2
	OPENBSD_3_6_BASE:1.36
	SMP_SYNC_A:1.33
	SMP_SYNC_B:1.33
	OPENBSD_3_5:1.27.0.2
	OPENBSD_3_5_BASE:1.27
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	UBC_SYNC_A:1.20
	OPENBSD_3_3:1.20.0.4
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.20.0.2
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	UBC_SYNC_B:1.20
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SMP:1.1.0.4
	SMP_BASE:1.1
	kame_19991208:1.1
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.44
date	2014.03.18.22.36.36;	author miod;	state dead;
branches;
next	1.43;

1.43
date	2011.04.07.15.30.15;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2010.06.28.14.13.29;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2010.04.12.12.57.52;	author tedu;	state Exp;
branches;
next	1.40;

1.40
date	2009.10.31.12.00.07;	author fgsch;	state Exp;
branches;
next	1.39;

1.39
date	2008.09.23.04.44.31;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2006.07.28.21.46.02;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2006.05.08.14.36.10;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2004.07.30.19.02.06;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2004.07.02.14.00.43;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2004.07.02.11.19.43;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2004.05.26.21.16.10;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2004.05.26.21.15.31;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2004.05.25.21.22.49;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2004.05.25.21.21.23;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2004.04.24.19.51.48;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2004.04.16.23.36.27;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2003.12.27.21.58.20;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2003.12.25.21.01.39;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2003.12.22.11.54.48;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2003.11.09.00.31.59;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2003.10.05.20.27.48;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2003.08.15.20.32.14;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.03.21.09.01;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2002.04.28.15.17.09;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.14.03.15.57;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.14.01.26.39;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.01.14.21.34.39;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2001.12.22.18.45.35;	author smurph;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.19.07.04.41;	author smurph;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.12.16.23.49.46;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.13.08.55.51;	author smurph;	state Exp;
branches;
next	1.12;

1.12
date	2001.10.28.00.57.38;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.31.08.18.24;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.31.01.05.44;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.26.02.37.07;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.27.05.44.49;	author nate;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.25.00.43.14;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.09.05.44.39;	author smurph;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.07.23.45.52;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.25.03.50.48;	author todd;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.14.20.25.22;	author smurph;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.26.23.32.00;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	99.05.29.04.41.45;	author smurph;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2001.04.18.16.11.10;	author niklas;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2001.07.04.10.20.01;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2001.10.31.03.01.18;	author nate;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2001.11.13.21.04.14;	author niklas;	state Exp;
branches;
next	1.1.4.5;

1.1.4.5
date	2002.03.06.02.04.44;	author niklas;	state Exp;
branches;
next	1.1.4.6;

1.1.4.6
date	2002.03.28.10.36.02;	author niklas;	state Exp;
branches;
next	1.1.4.7;

1.1.4.7
date	2003.03.27.23.32.18;	author niklas;	state Exp;
branches;
next	1.1.4.8;

1.1.4.8
date	2003.06.07.11.13.17;	author ho;	state Exp;
branches;
next	1.1.4.9;

1.1.4.9
date	2004.02.19.10.49.06;	author niklas;	state Exp;
branches;
next	1.1.4.10;

1.1.4.10
date	2004.06.05.23.09.49;	author niklas;	state Exp;
branches;
next	;

1.15.2.1
date	2002.01.31.22.55.18;	author niklas;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2002.06.11.03.37.10;	author art;	state Exp;
branches;
next	;


desc
@@


1.44
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: vx.c,v 1.43 2011/04/07 15:30:15 miod Exp $ */
/*
 * Copyright (c) 1999 Steve Murphree, Jr.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* This card lives in D16 space */
#define	__BUS_SPACE_RESTRICT_D16__

#include <sys/param.h>
#include <sys/ioctl.h>
#include <sys/proc.h>
#include <sys/tty.h>
#include <sys/uio.h>
#include <sys/systm.h>
#include <sys/time.h>
#include <sys/device.h>
#include <sys/syslog.h>

#include <machine/autoconf.h>
#include <machine/conf.h>
#include <machine/cpu.h>
#include <machine/psl.h>

#include <dev/cons.h>

#include <mvme88k/dev/vme.h>
#include <mvme88k/dev/vxreg.h>

#define splvx()	spltty()

struct vx_info {
	struct   tty *tty;
	u_char   vx_swflags;
	int      vx_linestatus;
	int      open;
	int      waiting;
	u_char   vx_speed;
	u_char   read_pending;
	struct   wring  *wringp;
	struct   rring  *rringp;
};

struct vxsoftc {
	struct device     sc_dev;
	struct vx_info  sc_info[NVXPORTS];
	struct vxreg    *vx_reg;
	vaddr_t		board_vaddr;
	struct channel    *channel;
	char              channel_number;
	struct packet     sc_bppwait_pkt;
	void              *sc_bppwait_pktp;
	struct intrhand   sc_ih;
	int               sc_vec;
	struct envelope   *elist_head, *elist_tail;
	struct packet     *plist_head, *plist_tail;
};

int  vxmatch(struct device *, void *, void *);
void vxattach(struct device *, struct device *, void *);

struct cfattach vx_ca = {
	sizeof(struct vxsoftc), vxmatch, vxattach
};

struct cfdriver vx_cd = {
	NULL, "vx", DV_TTY
};

int	bpp_send(struct vxsoftc *, void *, int);
void	ccode(struct vxsoftc *, int, char);
int	create_channels(struct vxsoftc *);
void	create_free_queue(struct vxsoftc *);
short	dtr_ctl(struct vxsoftc *, int, int);
int	env_isvalid(struct envelope *);
struct envelope *find_status_packet(struct vxsoftc *, struct packet *);
short	flush_ctl(struct vxsoftc *, int, int);
struct envelope *get_cmd_tail(struct vxsoftc *);
void	*get_free_envelope(struct vxsoftc *);
void	*get_free_packet(struct vxsoftc *);
struct envelope *get_next_envelope(struct vxsoftc *, struct envelope *);
struct packet *get_packet(struct vxsoftc *, struct envelope *);
struct envelope *get_status_head(struct vxsoftc *);
void	put_free_envelope(struct vxsoftc *, void *);
void	put_free_packet(struct vxsoftc *, void *);
void	read_chars(struct vxsoftc *, int);
void	read_wakeup(struct vxsoftc *, int);
short	rts_ctl(struct vxsoftc *, int, int);
void	set_status_head(struct vxsoftc *, void *);
void	vx_break(struct vxsoftc *, int);
int	vx_ccparam(struct vxsoftc *, struct termios *, int);
int	vx_event(struct vxsoftc *, struct packet *);
void	vx_frame(struct vxsoftc *, int);
int	vx_init(struct vxsoftc *);
int	vx_intr(void *);
int	vx_mctl(dev_t, int, int);
void	vx_overflow(struct vxsoftc *, int, long *, u_char *);
int	vx_param(struct tty *, struct termios *);
int	vx_poll(struct vxsoftc *, struct packet *);
void	vxputc(struct vxsoftc *, int, u_char);
int	vx_sintr(struct vxsoftc *);
void	vxstart(struct tty *tp);
u_short	vxtspeed(int);
void	vx_unblock(struct tty *);

/* flags for bpp_send() */
#define	NOWAIT 0
#define	WAIT 1

#define VX_UNIT(x) (minor(x) / NVXPORTS)
#define VX_PORT(x) (minor(x) % NVXPORTS)

/*
 * Convert dual-ported physical addresse to host virtual address, and the
 * opposite.
 */
#define	VIRTUAL(addr)	(((addr) & 0xffff) + sc->board_vaddr)
#define	PHYSICAL(addr) \
	(((addr - sc->board_vaddr) & 0xffff) | LOCAL_DPMEM_ADDRESS)

#if 0
#define  LO(x) (u_short)((unsigned long)x & 0x0000FFFF)
#define  HI(x) (u_short)((unsigned long)x >> 16)
#else
#define	LO(x)	(u_short)(x)
#define	HI(x)	(LOCAL_DPMEM_ADDRESS >> 16)
#endif

struct tty *
vxtty(dev_t dev)
{
	int unit, port;
	struct vxsoftc *sc;

	unit = VX_UNIT(dev);
	if (unit >= vx_cd.cd_ndevs ||
	    (sc = (struct vxsoftc *)vx_cd.cd_devs[unit]) == NULL) {
		return (NULL);
	}
	port = VX_PORT(dev);
	return sc->sc_info[port].tty;
}

int
vxmatch(struct device *parent, void *self, void *aux)
{
	struct vxreg *vx_reg;
	struct confargs *ca = aux;
	bus_space_tag_t iot = ca->ca_iot;
	bus_space_handle_t ioh;
	int rc;

	if (bus_space_map(iot, ca->ca_paddr, 0x10000, 0, &ioh) != 0)
		return 0;
	vx_reg = (struct vxreg *)bus_space_vaddr(iot, ioh);
	rc = badaddr((vaddr_t)&vx_reg->ipc_cr, 1);
	bus_space_unmap(iot, ioh, 0x10000);

	return rc == 0;
}

void
vxattach(struct device *parent, struct device *self, void *aux)
{
	struct vxsoftc *sc = (struct vxsoftc *)self;
	struct confargs *ca = aux;
	bus_space_tag_t iot = ca->ca_iot;
	bus_space_handle_t ioh;

	if (ca->ca_vec < 0) {
		printf(": no more interrupts!\n");
		return;
	}
	if (ca->ca_ipl < 0)
		ca->ca_ipl = IPL_TTY;

	if (bus_space_map(iot, ca->ca_paddr, 0x10000, 0, &ioh) != 0) {
		printf(": can't map registers!\n");
		return;
	}

	/* set up dual port memory and registers and init */
	sc->board_vaddr = (vaddr_t)bus_space_vaddr(iot, ioh);
	sc->vx_reg = (struct vxreg *)sc->board_vaddr;
	sc->channel = (struct channel *)(sc->board_vaddr + 0x0100);
	sc->sc_vec = ca->ca_vec;

	printf("\n");

	if (create_channels(sc) != 0) {
		printf("%s: failed to create channel %d\n",
		    sc->sc_dev.dv_xname, sc->channel->channel_number);
		return;
	}
	if (vx_init(sc) != 0) {
		printf("%s: failed to initialize\n", sc->sc_dev.dv_xname);
		return;
	}

	/* enable interrupts */
	sc->sc_ih.ih_fn = vx_intr;
	sc->sc_ih.ih_arg = sc;
	sc->sc_ih.ih_wantframe = 0;
	sc->sc_ih.ih_ipl = IPL_TTY;

	vmeintr_establish(ca->ca_vec, &sc->sc_ih, self->dv_xname);
}

short
dtr_ctl(struct vxsoftc *sc, int port, int on)
{
	struct packet pkt;

	bzero(&pkt, sizeof(struct packet));
	pkt.command = CMD_IOCTL;
	pkt.ioctl_cmd_l = IOCTL_TCXONC;
	pkt.command_pipe_number = sc->channel_number;
	pkt.status_pipe_number = sc->channel_number;
	pkt.device_number = port;
	if (on) {
		pkt.ioctl_arg_l = 6;  /* assert DTR */
	} else {
		pkt.ioctl_arg_l = 7;  /* negate DTR */
	}

	return bpp_send(sc, &pkt, WAIT);
}

short
rts_ctl(struct vxsoftc *sc, int port, int on)
{
	struct packet pkt;

	bzero(&pkt, sizeof(struct packet));
	pkt.command = CMD_IOCTL;
	pkt.ioctl_cmd_l = IOCTL_TCXONC;
	pkt.command_pipe_number = sc->channel_number;
	pkt.status_pipe_number = sc->channel_number;
	pkt.device_number = port;
	if (on) {
		pkt.ioctl_arg_l = 4;  /* assert RTS */
	} else {
		pkt.ioctl_arg_l = 5;  /* negate RTS */
	}

	return bpp_send(sc, &pkt, WAIT);
}

#if 0
short
flush_ctl(struct vxsoftc *sc, int port, int which)
{
	struct packet pkt;

	bzero(&pkt, sizeof(struct packet));
	pkt.command = CMD_IOCTL;
	pkt.ioctl_cmd_l = IOCTL_TCFLSH;
	pkt.command_pipe_number = sc->channel_number;
	pkt.status_pipe_number = sc->channel_number;
	pkt.device_number = port;
	pkt.ioctl_arg_l = which; /* 0=input, 1=output, 2=both */

	return bpp_send(sc, &pkt, WAIT);
}
#endif

int
vx_mctl(dev_t dev, int bits, int how)
{
	int s, unit, port;
	struct vxsoftc *sc;
	struct vx_info *vxt;
	u_char msvr;

	unit = VX_UNIT(dev);
	port = VX_PORT(dev);
	sc = (struct vxsoftc *)vx_cd.cd_devs[unit];
	vxt = &sc->sc_info[port];

	s = splvx();
	switch (how) {
	case DMSET:
		if (bits & TIOCM_RTS) {
			rts_ctl(sc, port, 1);
			vxt->vx_linestatus |= TIOCM_RTS;
		} else {
			rts_ctl(sc, port, 0);
			vxt->vx_linestatus &= ~TIOCM_RTS;
		}
		if (bits & TIOCM_DTR) {
			dtr_ctl(sc, port, 1);
			vxt->vx_linestatus |= TIOCM_DTR;
		} else {
			dtr_ctl(sc, port, 0);
			vxt->vx_linestatus &= ~TIOCM_DTR;
		}
		break;
	case DMBIC:
		if (bits & TIOCM_RTS) {
			rts_ctl(sc, port, 0);
			vxt->vx_linestatus &= ~TIOCM_RTS;
		}
		if (bits & TIOCM_DTR) {
			dtr_ctl(sc, port, 0);
			vxt->vx_linestatus &= ~TIOCM_DTR;
		}
		break;

	case DMBIS:
		if (bits & TIOCM_RTS) {
			rts_ctl(sc, port, 1);
			vxt->vx_linestatus |= TIOCM_RTS;
		}
		if (bits & TIOCM_DTR) {
			dtr_ctl(sc, port, 1);
			vxt->vx_linestatus |= TIOCM_DTR;
		}
		break;

	case DMGET:
		bits = 0;
		msvr = vxt->vx_linestatus;
		if (msvr & TIOCM_DSR) {
			bits |= TIOCM_DSR;
		}
		if (msvr & TIOCM_CD) {
			bits |= TIOCM_CD;
		}
		if (msvr & TIOCM_CTS) {
			bits |= TIOCM_CTS;
		}
		if (msvr & TIOCM_DTR) {
			bits |= TIOCM_DTR;
		}
		if (msvr & TIOCM_RTS) {
			bits |= TIOCM_RTS;
		}
		break;
	}

	splx(s);

#if 0
	bits = 0;
	bits |= TIOCM_DTR;
	bits |= TIOCM_RTS;
	bits |= TIOCM_CTS;
	bits |= TIOCM_CD;
	bits |= TIOCM_DSR;
#endif
	return (bits);
}

int
vxopen(dev_t dev, int flag, int mode, struct proc *p)
{
	int s, unit, port, error;
	struct vx_info *vxt;
	struct vxsoftc *sc;
	struct tty *tp;
	struct packet opkt;
	u_short code;

	unit = VX_UNIT(dev);
	port = VX_PORT(dev);
	if (unit >= vx_cd.cd_ndevs ||
	    (sc = (struct vxsoftc *) vx_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
	}
	vxt = &sc->sc_info[port];

#if 0
	flush_ctl(sc, port, 2);
#endif

	bzero(&opkt, sizeof(struct packet));
	opkt.command_pipe_number = sc->channel_number;
	opkt.status_pipe_number = sc->channel_number;
	opkt.command = CMD_OPEN;
	opkt.device_number = port;

	if ((error = bpp_send(sc, &opkt, WAIT)) != 0) {
#ifdef DEBUG_VXT
		printf("unit %d, port %d, ", unit, port);
		printf("error = %d\n", error);
#endif
		return (ENXIO);
	}

	code = opkt.event_code;

	s = splvx();
	if (vxt->tty) {
		tp = vxt->tty;
	} else {
		tp = vxt->tty = ttymalloc(0);
	}

	/* set line status */
	tp->t_state |= TS_CARR_ON;
	if (code & E_DCD) {
		tp->t_state |= TS_CARR_ON;
		vxt->vx_linestatus |= TIOCM_CD;
	}
	if (code & E_DSR) {
		vxt->vx_linestatus |= TIOCM_DSR;
	}
	if (code & E_CTS) {
		vxt->vx_linestatus |= TIOCM_CTS;
	}

	tp->t_oproc = vxstart;
	tp->t_param = vx_param;
	tp->t_dev = dev;

	if ((tp->t_state & TS_ISOPEN) == 0) {
		tp->t_state |= TS_WOPEN;
		ttychars(tp);
		if (tp->t_ispeed == 0) {
			/*
			 * only when cleared do we reset to defaults.
			 */
			tp->t_iflag = TTYDEF_IFLAG;
			tp->t_oflag = TTYDEF_OFLAG;
			tp->t_lflag = TTYDEF_LFLAG;
			tp->t_ispeed = tp->t_ospeed = TTYDEF_SPEED;
			tp->t_cflag = TTYDEF_CFLAG;
		}
		/*
		 * do these all the time
		 */
		if (vxt->vx_swflags & TIOCFLAG_CLOCAL)
			tp->t_cflag |= CLOCAL;
		if (vxt->vx_swflags & TIOCFLAG_CRTSCTS)
			tp->t_cflag |= CRTSCTS;
		if (vxt->vx_swflags & TIOCFLAG_MDMBUF)
			tp->t_cflag |= MDMBUF;
		vx_param(tp, &tp->t_termios);
		ttsetwater(tp);

		(void)vx_mctl(dev, TIOCM_DTR | TIOCM_RTS, DMSET);

		tp->t_state |= TS_CARR_ON;
	} else if (tp->t_state & TS_XCLUDE && suser(p, 0) != 0) {
		splx(s);
		return (EBUSY);
	}

	/*
	 * Reset the tty pointer, as there could have been a dialout
	 * use of the tty with a dialin open waiting.
	 */
	tp->t_dev = dev;
	vxt->open = 1;
	splx(s);
	return (*linesw[tp->t_line].l_open)(dev, tp, p);
}

int
vx_param(struct tty *tp, struct termios *t)
{
	int unit, port;
	struct vxsoftc *sc;
	dev_t dev;

	dev = tp->t_dev;
	unit = VX_UNIT(dev);
	if (unit >= vx_cd.cd_ndevs ||
	    (sc = (struct vxsoftc *) vx_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
	}
	port = VX_PORT(dev);
	tp->t_ispeed = t->c_ispeed;
	tp->t_ospeed = t->c_ospeed;
	tp->t_cflag = t->c_cflag;
	vx_ccparam(sc, t, port);
	vx_unblock(tp);
	return 0;
}

int
vxclose(dev_t dev, int flag, int mode, struct proc *p)
{
	int unit, port;
	struct tty *tp;
	struct vx_info *vxt;
	struct vxsoftc *sc;
	int s;
	struct packet cpkt;

	unit = VX_UNIT(dev);
	if (unit >= vx_cd.cd_ndevs ||
	    (sc = (struct vxsoftc *) vx_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
	}
	port = VX_PORT(dev);
	vxt = &sc->sc_info[port];
#if 0
	flush_ctl(sc, port, 2);	/* flush both input and output */
#endif

	tp = vxt->tty;
	(*linesw[tp->t_line].l_close)(tp, flag, p);

	s = splvx();

	if ((tp->t_cflag & HUPCL) != 0) {
		rts_ctl(sc, port, 0);
		dtr_ctl(sc, port, 0);
	}

	bzero(&cpkt, sizeof(struct packet));
	cpkt.command_pipe_number = sc->channel_number;
	cpkt.status_pipe_number = sc->channel_number;
	cpkt.command = CMD_CLOSE;
	cpkt.device_number = port;
	bpp_send(sc, &cpkt, NOWAIT);

	vxt->open = 0;
	splx(s);
	ttyclose(tp);

	return (0);
}

void
read_wakeup(struct vxsoftc *sc, int port)
{
	struct packet rwp;
	struct vx_info *volatile vxt;

	vxt = &sc->sc_info[port];
	/*
	 * If we already have a read_wakeup paket
	 * for this port, do nothing.
	 */
	if (vxt->read_pending != 0)
		return;
	else
		vxt->read_pending = 1;

	bzero(&rwp, sizeof(struct packet));
	rwp.command_pipe_number = sc->channel_number;
	rwp.status_pipe_number = sc->channel_number;
	rwp.command = CMD_READW;
	rwp.device_number = port;

	/*
	 * Do not wait.  Characters will be transferred
	 * to (*linesw[tp->t_line].l_rint)(c, tp); by
	 * vx_intr()  (IPC will notify via interrupt)
	 */
	bpp_send(sc, &rwp, NOWAIT);
}

int
vxread(dev_t dev, struct uio *uio, int flag)
{
	int unit, port;
	struct tty *tp;
	struct vx_info *volatile vxt;
	struct vxsoftc *volatile sc;

	unit = VX_UNIT(dev);
	if (unit >= vx_cd.cd_ndevs ||
	    (sc = (struct vxsoftc *) vx_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
	}
	port = VX_PORT(dev);
	vxt = &sc->sc_info[port];
	tp = vxt->tty;
	if (!tp)
		return ENXIO;
	return ((*linesw[tp->t_line].l_read)(tp, uio, flag));
}

int
vxwrite(dev_t dev, struct uio *uio, int flag)
{
	int unit, port;
	struct tty *tp;
	struct vx_info *vxt;
	struct vxsoftc *sc;
	struct wring *wp;
	struct packet wwp;
	u_short get, put;

	unit = VX_UNIT(dev);
	if (unit >= vx_cd.cd_ndevs ||
	    (sc = (struct vxsoftc *) vx_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
	}
	port = VX_PORT(dev);
	vxt = &sc->sc_info[port];
	tp = vxt->tty;
	if (!tp)
		return ENXIO;

	wp = sc->sc_info[port].wringp;
	get = wp->get;
	put = wp->put;
	if ((put + 1) == get) {
		bzero(&wwp, sizeof(struct packet));
		wwp.command_pipe_number = sc->channel_number;
		wwp.status_pipe_number = sc->channel_number;
		wwp.command = CMD_WRITEW;
		wwp.device_number = port;
		if (bpp_send(sc, &wwp, WAIT))
			return (ENXIO);
	}

	return ((*linesw[tp->t_line].l_write)(tp, uio, flag));
}

int
vxioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	int error;
	int unit, port;
	struct tty *tp;
	struct vx_info *vxt;
	struct vxsoftc *sc;

	unit = VX_UNIT(dev);
	if (unit >= vx_cd.cd_ndevs ||
	    (sc = (struct vxsoftc *) vx_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
	}
	port = VX_PORT(dev);
	vxt = &sc->sc_info[port];
	tp = vxt->tty;
	if (!tp)
		return ENXIO;

	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);

	error = ttioctl(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);

	switch (cmd) {
	case TIOCSBRK:
		/* */
		break;

	case TIOCCBRK:
		/* */
		break;

	case TIOCSDTR:
		vx_mctl(dev, TIOCM_DTR | TIOCM_RTS, DMBIS);
		break;

	case TIOCCDTR:
		vx_mctl(dev, TIOCM_DTR | TIOCM_RTS, DMBIC);
		break;

	case TIOCMSET:
		vx_mctl(dev, *(int *)data, DMSET);
		break;

	case TIOCMBIS:
		vx_mctl(dev, *(int *)data, DMBIS);
		break;

	case TIOCMBIC:
		vx_mctl(dev, *(int *)data, DMBIC);
		break;

	case TIOCMGET:
		*(int *)data = vx_mctl(dev, 0, DMGET);
		break;

	case TIOCGFLAGS:
		*(int *)data = vxt->vx_swflags;
		break;

	case TIOCSFLAGS:
		error = suser(p, 0);
		if (error != 0)
			return (EPERM);

		vxt->vx_swflags = *(int *)data;
		vxt->vx_swflags &= /* only allow valid flags */
		    (TIOCFLAG_SOFTCAR | TIOCFLAG_CLOCAL | TIOCFLAG_CRTSCTS);
		break;

	default:
		return (ENOTTY);
	}

	return 0;
}

int
vxstop(struct tty *tp, int flag)
{
	int s;

	s = splvx();
	if (tp->t_state & TS_BUSY) {
		if ((tp->t_state & TS_TTSTOP) == 0)
			tp->t_state |= TS_FLUSH;
	}
	splx(s);
	return 0;
}

void
vxputc(struct vxsoftc *sc, int port, u_char c)
{
	struct wring *wp;

	wp = sc->sc_info[port].wringp;
	wp->data[wp->put++ & (WRING_BUF_SIZE - 1)] = c;
	wp->put &= (WRING_BUF_SIZE - 1);
}

u_short
vxtspeed(int speed)
{
	switch (speed) {
	case B0:
		return VB0;
	case B50:
		return VB50;
	case B75:
		return VB75;
	case B110:
		return VB110;
	case B134:
		return VB134;
	case B150:
		return VB150;
	case B200:
		return VB200;
	case B300:
		return VB300;
	case B600:
		return VB600;
	case B1200:
		return VB1200;
	case B1800:
		return VB1800;
	case B2400:
		return VB2400;
	case B4800:
		return VB4800;
	case B9600:
		return VB9600;
	case B19200:
		return VB19200;
	case B38400:
		return VB38400;
	default:
		return VB9600;
	}
}

int
vx_ccparam(struct vxsoftc *sc, struct termios *par, int port)
{
	int imask = 0, s;
	int cflag;
	struct packet pkt;

	if (par->c_ospeed == 0) {
		s = splvx();
		/* disconnect, drop RTS DTR stop receiver */
		rts_ctl(sc, port, 0);
		dtr_ctl(sc, port, 0);
		splx(s);
		return (0xff);
	}

	bzero(&pkt, sizeof(struct packet));
	pkt.command = CMD_IOCTL;
	pkt.ioctl_cmd_l = IOCTL_TCGETA;
	pkt.command_pipe_number = sc->channel_number;
	pkt.status_pipe_number = sc->channel_number;
	pkt.device_number = port;
	if (bpp_send(sc, &pkt, WAIT))
		return 0xff;

	cflag = pkt.pb.tio.c_cflag;
	cflag |= vxtspeed(par->c_ospeed);

	switch (par->c_cflag & CSIZE) {
	case CS5:
		cflag |= VCS5;
		imask = 0x1F;
		break;
	case CS6:
		cflag |= VCS6;
		imask = 0x3F;
		break;
	case CS7:
		cflag |= VCS7;
		imask = 0x7F;
		break;
	default:
		cflag |= VCS8;
		imask = 0xFF;
	}

	if (par->c_cflag & PARENB) cflag |= VPARENB;
	else cflag &= ~VPARENB;
	if (par->c_cflag & PARODD) cflag |= VPARODD;
	else cflag &= ~VPARODD;
	if (par->c_cflag & CREAD) cflag |= VCREAD;
	else cflag &= ~VCREAD;
	if (par->c_cflag & CLOCAL) cflag |= VCLOCAL;
	else cflag &= ~VCLOCAL;
	if (par->c_cflag & HUPCL) cflag |= VHUPCL;
	else cflag &= ~VHUPCL;

	pkt.command = CMD_IOCTL;
	pkt.ioctl_cmd_l = IOCTL_TCSETA;
	pkt.command_pipe_number = sc->channel_number;
	pkt.status_pipe_number = sc->channel_number;
	pkt.device_number = port;
	pkt.pb.tio.c_cflag = cflag;
	if (bpp_send(sc, &pkt, WAIT))
		return 0xff;

	return imask;
}

void
vx_unblock(struct tty *tp)
{
	tp->t_state &= ~TS_FLUSH;
	if (tp->t_outq.c_cc != 0)
		vxstart(tp);
}

void
vxstart(struct tty *tp)
{
	dev_t dev;
	struct vxsoftc *sc;
	struct wring *wp;
	int cc, port, unit, s, cnt, i;
	u_short get, put;
	char buffer[256];

	dev = tp->t_dev;
	port = VX_PORT(dev);
	unit = VX_UNIT(dev);
	if (unit >= vx_cd.cd_ndevs ||
	    (sc = (struct vxsoftc *) vx_cd.cd_devs[unit]) == NULL) {
		return;
	}

	if ((tp->t_state & TS_ISOPEN) == 0)
		return;

	s = splvx();
	if ((tp->t_state & (TS_TIMEOUT | TS_BUSY | TS_TTSTOP | TS_FLUSH)) == 0) {
		tp->t_state |= TS_BUSY;
		wp = sc->sc_info[port].wringp;
		get = wp->get;
		put = wp->put;
		cc = tp->t_outq.c_cc;
		while (cc > 0) {
			cnt = min(sizeof buffer, cc);
			cnt = q_to_b(&tp->t_outq, buffer, cnt);
			buffer[cnt] = 0;
			for (i = 0; i < cnt; i++) {
				vxputc(sc, port, buffer[i]);
			}
			cc -= cnt;
		}
		tp->t_state &= ~TS_BUSY;
	}
	splx(s);
}

void
read_chars(struct vxsoftc *sc, int port)
{
	/*
	 * This routine is called by vx_intr() when there are
	 * characters in the read ring.  It will process one
	 * cooked line, put the chars in the line disipline ring,
	 * and then return.  The characters may then
	 * be read by vxread.
	 */
	struct vx_info *vxt;
	struct rring *rp;
	struct tty *tp;
	u_short get, put;
	int frame_count, i, open;
	char c;

	vxt = &sc->sc_info[port];
	tp = vxt->tty;
	rp = vxt->rringp;
	open = vxt->open;
	get = rp->get;
	put = rp->put;
#ifdef DEBUG_VXT
	printf("read_chars() get=%d, put=%d ", get, put);
	printf("open = %d ring at 0x%x\n", open, rp);
#endif
	while (get != put) {
		frame_count = rp->data[rp->get++ & (RRING_BUF_SIZE - 1)];
		rp->get &= (RRING_BUF_SIZE - 1);
		for (i = 0; i < frame_count; i++) {
			c = rp->data[rp->get++ & (RRING_BUF_SIZE - 1)];
			rp->get &= (RRING_BUF_SIZE - 1);
			if (open)
				(*linesw[tp->t_line].l_rint)(c, tp);
		}
		c = rp->data[rp->get++ & (RRING_BUF_SIZE - 1)];
		rp->get &= (RRING_BUF_SIZE - 1);
		if (!(c & DELIMITER)) {
			vx_frame(sc, port);
			break;
		} else {
			break;
		}
		get = rp->get;
		put = rp->put;
	}
	vxt->read_pending = 0;
	read_wakeup(sc, port);
}

void
ccode(struct vxsoftc *sc, int port, char c)
{
	struct vx_info *vxt;
	struct tty *tp;

	vxt = &sc->sc_info[port];
	tp = vxt->tty;
	(*linesw[tp->t_line].l_rint)(c, tp);
}

int
vx_intr(void *arg)
{
	struct vxsoftc *sc = arg;
	struct envelope *envp, *next_envp;
	struct packet *pktp, pkt;
	int valid;
	short cmd;
	u_char port;

	while (env_isvalid(get_status_head(sc))) {
		pktp = get_packet(sc, get_status_head(sc));
		valid = env_isvalid(get_status_head(sc));
		cmd = pktp->command;
		port = pktp->device_number;
		/*
		 * If we are waiting on this packet, store the info
		 * so bpp_send can process the packet
		 */
		if (sc->sc_bppwait_pktp == pktp)
			d16_bcopy(pktp, &sc->sc_bppwait_pkt, sizeof(struct packet));

		d16_bcopy(pktp, &pkt, sizeof(struct packet));
		next_envp = get_next_envelope(sc, get_status_head(sc));
		envp = get_status_head(sc);
		/* return envelope and packet to the free queues */
		put_free_envelope(sc, envp);
		put_free_packet(sc, pktp);
		/* mark new status pipe head pointer */
		set_status_head(sc, next_envp);
		/* if it was valid, process packet */
		switch (cmd) {
		case CMD_READW:
#ifdef DEBUG_VXT
			printf("READW Packet\n");
#endif
			read_chars(sc, port);
			break;
		case CMD_WRITEW:
#ifdef DEBUG_VXT
			printf("WRITEW Packet\n");  /* Still don't know XXXsmurph */
#endif
			break;
		case CMD_EVENT:
#ifdef DEBUG_VXT
			printf("EVENT Packet\n");
#endif
			vx_event(sc, &pkt);
			break;
		case CMD_PROCESSED:
#ifdef DEBUG_VXT
			printf("CMD_PROCESSED Packet\n");
#endif
			break;
		default:
#ifdef DEBUG_VXT
			printf("Other packet 0x%x\n", cmd);
#endif
			break;
		}
	}
	return 1;
}

int
vx_event(struct vxsoftc *sc, struct packet *evntp)
{
	u_short code = evntp->event_code;
	struct packet evnt;
	struct vx_info *vxt;

	vxt = &sc->sc_info[evntp->device_number];

	if (code & E_INTR) {
		ccode(sc, evntp->device_number, CINTR);
	}
	if (code & E_QUIT) {
		ccode(sc, evntp->device_number, CQUIT);
	}
	if (code & E_HUP) {
		rts_ctl(sc, evntp->device_number, 0);
		dtr_ctl(sc, evntp->device_number, 0);
	}
	if (code & E_DCD) {
		vxt->vx_linestatus |= TIOCM_CD;
	}
	if (code & E_DSR) {
		vxt->vx_linestatus |= TIOCM_DSR;
	}
	if (code & E_CTS) {
		vxt->vx_linestatus |= TIOCM_CTS;
	}
	if (code & E_LOST_DCD) {
		vxt->vx_linestatus &= ~TIOCM_CD;
	}
	if (code & E_LOST_DSR) {
		vxt->vx_linestatus &= ~TIOCM_DSR;
	}
	if (code & E_LOST_CTS) {
		vxt->vx_linestatus &= ~TIOCM_CTS;
	}
	if (code & E_PR_FAULT) {
		/* do something... */
	}
	if (code & E_PR_POUT) {
		/* do something... */
	}
	if (code & E_PR_SELECT) {
		/* do something... */
	}
	if (code & E_SWITCH) {
		/* do something... */
	}
	if (code & E_BREAK) {
		vx_break(sc, evntp->device_number);
	}

	/* send an event packet back to the device */
	bzero(&evnt, sizeof(struct packet));
	evnt.command = CMD_EVENT;
	evnt.device_number = evntp->device_number;
	evnt.command_pipe_number = sc->channel_number;
	/* return status on same channel */
	evnt.status_pipe_number = sc->channel_number;
	/* send packet to the firmware */
	bpp_send(sc, &evnt, NOWAIT);

	return 1;
}

void
vx_overflow(struct vxsoftc *sc, int port, long *ptime, u_char *msg)
{
	log(LOG_WARNING, "%s port %d: overrun\n",
	    sc->sc_dev.dv_xname, port);
}

void
vx_frame(struct vxsoftc *sc, int port)
{
	log(LOG_WARNING, "%s port %d: frame error\n",
	    sc->sc_dev.dv_xname, port);
}

void
vx_break(struct vxsoftc *sc, int port)
{
	/*
	 * No need to check for a ddb break, as the console can never be on
	 * this hardware.
	 */
	log(LOG_WARNING, "%s port %d: break detected\n",
	    sc->sc_dev.dv_xname, port);
}

/*
 *	Initialization and Buffered Pipe Protocol (BPP) code
 */

void
create_free_queue(struct vxsoftc *sc)
{
	int i;
	struct envelope *envp, env;
	struct packet *pktp, pkt;

	envp = (struct envelope *)VIRTUAL(ENVELOPE_AREA);
	sc->elist_head = envp;
	for (i = 1; i <= NENVELOPES; i++) {
		bzero(&env, sizeof(struct envelope));
		if (i == NENVELOPES)
			env.link = 0;
		else
			env.link = ENVELOPE_AREA + i * sizeof(struct envelope);
		env.packet_ptr = 0;
		env.valid_flag = 0;
		d16_bcopy(&env, envp, sizeof(struct envelope));
		envp++;
	}
	sc->elist_tail = --envp;

	pktp = (struct packet *)VIRTUAL(PACKET_AREA);
	sc->plist_head = pktp;
	for (i = 1; i <= NPACKETS; i++) {
		bzero(&pkt, sizeof(struct packet));
		if (i == NPACKETS)
			pkt.link = 0;
		else
			pkt.link = PACKET_AREA + i * sizeof(struct packet);
		d16_bcopy(&pkt, pktp, sizeof(struct packet));
		pktp++;
	}
	sc->plist_tail = --pktp;
}

void *
get_free_envelope(struct vxsoftc *sc)
{
	struct envelope *envp;
	paddr_t link;

	envp = sc->elist_head;
	/* pick envelope next pointer from the envelope itself */
	d16_bcopy((const void *)&envp->link, &link, sizeof link);
	sc->elist_head = (struct envelope *)VIRTUAL(link);
	d16_bzero(envp, sizeof(struct envelope));

	return envp;
}

void
put_free_envelope(struct vxsoftc *sc, void *ep)
{
	struct envelope *envp = (struct envelope *)ep;
	u_long link;

#if 0
	d16_bzero(envp, sizeof(struct envelope));
#endif
	/* put envelope next pointer in the envelope itself */
	link = PHYSICAL((vaddr_t)envp);
	d16_bzero((void *)&envp->link, sizeof envp->link);
	d16_bcopy(&link, (void *)&sc->elist_tail->link, sizeof link);

	sc->elist_tail = envp;
}

void *
get_free_packet(struct vxsoftc *sc)
{
	struct packet *pktp;
	paddr_t link;

	pktp = sc->plist_head;
	/* pick packet next pointer from the packet itself */
	d16_bcopy((const void *)&pktp->link, &link, sizeof link);
	sc->plist_head = (struct packet *)VIRTUAL(link);
	d16_bzero(pktp, sizeof(struct packet));

	return pktp;
}

void
put_free_packet(struct vxsoftc *sc, void *pp)
{
	struct packet *pktp = (struct packet *)pp;
	u_long link;

#if 0
	d16_bzero(pktp, sizeof(struct packet));
#endif
	pktp->command = CMD_PROCESSED;
	/* put packet next pointer in the packet itself */
	link = PHYSICAL((vaddr_t)pktp);
	d16_bzero((void *)&pktp->link, sizeof pktp->link);
	d16_bcopy(&link, (void *)&sc->plist_tail->link, sizeof link);

	sc->plist_tail = pktp;
}

/*
 * This is the nitty gritty.  All the rest if this code
 * was hell to come by.  Getting this right from the
 * Moto manual took *time*!
 */
int
create_channels(struct vxsoftc *sc)
{
	u_long envp;
	u_short status;
	u_short tas;
	struct vxreg *ipc_csr = sc->vx_reg;

	/* wait for busy bit to clear */
	while ((ipc_csr->ipc_cr & IPC_CR_BUSY))
		;

	create_free_queue(sc);

	/* set up channel header. we only want one */
	tas = ipc_csr->ipc_tas;
	while (!(tas & IPC_TAS_VALID_STATUS)) {
		envp = PHYSICAL((vaddr_t)get_free_envelope(sc));
		sc->channel->command_pipe_head_ptr_h = HI(envp);
		sc->channel->command_pipe_head_ptr_l = LO(envp);
		sc->channel->command_pipe_tail_ptr_h =
		    sc->channel->command_pipe_head_ptr_h;
		sc->channel->command_pipe_tail_ptr_l =
		    sc->channel->command_pipe_head_ptr_l;
		envp = PHYSICAL((vaddr_t)get_free_envelope(sc));
		sc->channel->status_pipe_head_ptr_h = HI(envp);
		sc->channel->status_pipe_head_ptr_l = LO(envp);
		sc->channel->status_pipe_tail_ptr_h =
		    sc->channel->status_pipe_head_ptr_h;
		sc->channel->status_pipe_tail_ptr_l =
		    sc->channel->status_pipe_head_ptr_l;
		sc->channel->interrupt_level = IPL_TTY;
		sc->channel->interrupt_vec = sc->sc_vec;
		sc->channel->channel_priority = 0;
		sc->channel->channel_number = 0;
		sc->channel->valid = 1;
		sc->channel->address_modifier = 0x8d; /* A32/D16 supervisor data access */
		sc->channel->datasize = 0; /* 32 bit data mode */

		/* loop until TAS bit is zero */
		while ((ipc_csr->ipc_tas & IPC_TAS_TAS))
			;
		ipc_csr->ipc_tas |= IPC_TAS_TAS;
		/* load address of channel header */
		ipc_csr->ipc_addrh = HI(CHANNEL_H);
		ipc_csr->ipc_addrl = LO(CHANNEL_H);
		/* load address modifier reg (supervisor data access) */
		ipc_csr->ipc_amr = 0x8d;
		/* load tas with create channel command */
		ipc_csr->ipc_tas |= IPC_CSR_CREATE;
		/* set vaild command bit */
		ipc_csr->ipc_tas |= IPC_TAS_VALID_CMD;
		/* notify IPC of the CSR command */
		ipc_csr->ipc_cr |= IPC_CR_ATTEN;

		/* loop until IPC sets valid status bit */
		delay(5000);
		tas = ipc_csr->ipc_tas;
	}

	/* save the status */
	status = ipc_csr->ipc_sr;
	/* set COMMAND COMPLETE bit */
	ipc_csr->ipc_tas |= IPC_TAS_COMPLETE;
	/* notify IPC that we are through */
	ipc_csr->ipc_cr |= IPC_CR_ATTEN;
	/* check and see if the channel was created */
	if (status == 0 && sc->channel->valid) {
		sc->channel_number = sc->channel->channel_number;
#ifdef DEBUG_VXT
		printf("%s: created channel %d\n", sc->sc_dev.dv_xname,
		       sc->channel->channel_number);
#endif
		return 0;
	} else {
		switch (status) {
		case 0x0000:
			printf("%s: channel not valid\n",
			       sc->sc_dev.dv_xname);
			break;
		case 0xFFFF:
			printf("%s: invalid CSR command\n",
			       sc->sc_dev.dv_xname);
			break;
		case 0xC000:
			printf("%s: could not read channel structure\n",
			       sc->sc_dev.dv_xname);
			break;
		case 0x8000:
			printf("%s: could not write channel structure\n",
			       sc->sc_dev.dv_xname);
			break;
		default:
			printf("%s: unknown IPC CSR command error 0x%x\n",
			       sc->sc_dev.dv_xname, status);
			break;
		}
		return 1;
	}
}

struct envelope *
get_next_envelope(struct vxsoftc *sc, struct envelope *thisenv)
{
	paddr_t ptr;

	d16_bcopy((const void*)&thisenv->link, &ptr, sizeof ptr);

	return (struct envelope *)VIRTUAL(ptr);
}

int
env_isvalid(struct envelope *thisenv)
{
	return (int)thisenv->valid_flag;
}

struct envelope *
get_cmd_tail(struct vxsoftc *sc)
{
	paddr_t retaddr;

	retaddr = sc->channel->command_pipe_tail_ptr_h << 16;
	retaddr += sc->channel->command_pipe_tail_ptr_l;
	return (struct envelope *)VIRTUAL(retaddr);
}

struct envelope *
get_status_head(struct vxsoftc *sc)
{
	paddr_t retaddr;

	retaddr = sc->channel->status_pipe_head_ptr_h << 16;
	retaddr += sc->channel->status_pipe_head_ptr_l;
	return (struct envelope *)VIRTUAL(retaddr);
}

void
set_status_head(struct vxsoftc *sc, void *envp)
{
	paddr_t ptr;

	ptr = PHYSICAL((vaddr_t)envp);
	sc->channel->status_pipe_head_ptr_h = HI(ptr);
	sc->channel->status_pipe_head_ptr_l = LO(ptr);
}

struct packet *
get_packet(struct vxsoftc *sc, struct envelope *thisenv)
{
	paddr_t baseaddr;

	if (thisenv == NULL)
		return NULL;

	/*
	 * packet ptr returned on status pipe is only last two bytes
	 * so we must supply the full address based on the board address.
	 * This also works for all envelopes because every address is an
	 * offset to the board address.
	 */
	d16_bcopy((const void *)&thisenv->packet_ptr, &baseaddr, sizeof baseaddr);
	return (struct packet *)VIRTUAL(baseaddr);
}

/*
 *	Send a command via BPP
 */
int
bpp_send(struct vxsoftc *sc, void *pkt, int wait_flag)
{
	struct envelope *envp;
	struct packet *pktp;
	paddr_t ptr;
	int tmo;

	/* load up packet in dual port mem */
	pktp = get_free_packet(sc);
	d16_bcopy(pkt, pktp, sizeof(struct packet));

	envp = get_cmd_tail(sc);
	ptr = PHYSICAL((vaddr_t)get_free_envelope(sc)); /* put a NULL env on the tail */
	sc->channel->command_pipe_tail_ptr_h = HI(ptr);
	sc->channel->command_pipe_tail_ptr_l = LO(ptr);
	d16_bcopy(&ptr, (void *)&envp->link, sizeof envp->link);
	ptr = PHYSICAL((vaddr_t)pktp);
	d16_bcopy(&ptr, (void *)&envp->packet_ptr, sizeof envp->packet_ptr);
	envp->valid_flag = 1;

	sc->vx_reg->ipc_cr |= IPC_CR_ATTEN;

	/* wait for a packet to return */
	if (wait_flag == NOWAIT)
		return 0;

	tmo = 0;
	while (pktp->command != CMD_PROCESSED) {
#ifdef DEBUG_VXT
		printf("Polling for packet 0x%x in envelope 0x%x...\n", pktp, envp);
#endif
		vx_intr(sc);
		if (++tmo > 20) {
			printf("%s: bpp_send pkt %x env %x timed out %d\n",
			    sc->sc_dev.dv_xname, pktp, envp, pktp->command);
			return ETIMEDOUT;
		}
		delay(5000);
	}
	d16_bcopy(pktp, pkt, sizeof(struct packet));
	return pktp->error_l;
}

/*
 *	BPP commands
 */

int
vx_init(struct vxsoftc *sc)
{
	int i;
	int error;
	struct init_info *infp, inf;
	paddr_t wringp, rringp;
	struct packet init;
	struct packet evnt;

	/* init wait queue */
	d16_bzero(&sc->sc_bppwait_pkt, sizeof(struct packet));
	sc->sc_bppwait_pktp = NULL;
	/* set up init_info array */
	wringp = WRING_AREA;
	rringp = RRING_AREA;
	infp = (struct init_info *)VIRTUAL(INIT_INFO_AREA);

	for (i = 0; i < NVXPORTS; i++) {
		bzero(&inf, sizeof(struct init_info));
		inf.write_ring_ptr_h = HI(wringp);
		inf.write_ring_ptr_l = LO(wringp);
		sc->sc_info[i].wringp = (struct wring *)VIRTUAL(wringp);
		inf.read_ring_ptr_h = HI(rringp);
		inf.read_ring_ptr_l = LO(rringp);
		sc->sc_info[i].rringp = (struct rring *)VIRTUAL(rringp);
#ifdef DEBUG_VXT
		printf("write at 0x%8x, read at 0x%8x\n", wringp, rringp);
#endif
		inf.write_ring_size = WRING_DATA_SIZE;
		inf.read_ring_size = RRING_DATA_SIZE;
		inf.def_termio.c_iflag = VBRKINT;
		inf.def_termio.c_oflag = 0;
		inf.def_termio.c_cflag = (VB9600 | VCS8);

		inf.def_termio.c_lflag = VISIG; /* enable signal processing */
		inf.def_termio.c_line = 1; /* raw line discipline */
		inf.def_termio.c_cc[0] = CINTR;
		inf.def_termio.c_cc[1] = CQUIT;
		inf.def_termio.c_cc[2] = CERASE;
		inf.def_termio.c_cc[3] = CKILL;
		inf.def_termio.c_cc[4] = CEOF;
		inf.def_termio.c_cc[5] = CEOL;
		d16_bcopy(&inf, infp, sizeof(struct init_info));
		wringp += sizeof(struct wring);
		rringp += sizeof(struct rring);
		infp++;
	}

	/* set up init_packet */
	bzero(&init, sizeof(struct packet));
	init.command = CMD_INIT;
	init.command_pipe_number = sc->channel_number;
	/* return status on the same channel */
	init.status_pipe_number = sc->channel_number;
	init.interrupt_level = IPL_TTY;
	init.interrupt_vec = sc->sc_vec;
	init.init_info_ptr_h = HI(INIT_INFO_AREA);
	init.init_info_ptr_l = LO(INIT_INFO_AREA);

	/* send packet to the firmware and wait for completion */
	if ((error = bpp_send(sc, &init, WAIT)) != 0)
		return error;

	/* send one event packet to each device */
	for (i = 0; i < NVXPORTS; i++) {
		bzero(&evnt, sizeof(struct packet));
		evnt.command = CMD_EVENT;
		evnt.device_number = i;
		evnt.command_pipe_number = sc->channel_number;
		/* return status on same channel */
		evnt.status_pipe_number = sc->channel_number;
		/* send packet to the firmware */
		bpp_send(sc, &evnt, NOWAIT);
	}

	return 0;
}
@


1.43
log
@Do not use NULL in integer comparisons. No functional change.
ok matthew@@ tedu@@, also eyeballed by at least krw@@ oga@@ kettenis@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.42 2010/06/28 14:13:29 deraadt Exp $ */
@


1.42
log
@Allow tty drivers to request larger buffers at attach time using a
max-baud-rate hint.  Adjust TTYHOG (the nearly full logic) to this new
situation.  The larger buffers are required by the very high speed
KDDI devices in Japan (CF com, or USB ucom) so those are the only two
drivers which currently ask for a larger buffer size.
ok yasuoka miod
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.41 2010/04/12 12:57:52 tedu Exp $ */
d1136 1
a1136 1
			env.link = NULL;
d1139 1
a1139 1
		env.packet_ptr = NULL;
d1151 1
a1151 1
			pkt.link = NULL;
@


1.41
log
@Some of the line disciplines want to check for suser.  Better to pass them
a process instead of using curproc.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.40 2009/10/31 12:00:07 fgsch Exp $ */
d418 1
a418 1
		tp = vxt->tty = ttymalloc();
@


1.40
log
@Use suser when possible. Suggested by miod@@.
miod@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.39 2008/09/23 04:44:31 miod Exp $ */
d478 1
a478 1
	return (*linesw[tp->t_line].l_open)(dev, tp);
d525 1
a525 1
	(*linesw[tp->t_line].l_close)(tp, flag);
@


1.39
log
@Fix uninitialized variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.38 2006/07/28 21:46:02 miod Exp $ */
d466 1
a466 1
	} else if (tp->t_state & TS_XCLUDE && p->p_ucred->cr_uid != 0) {
@


1.38
log
@4KB buffer on the stack, and would you like fries with that?
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.37 2006/05/08 14:36:10 miod Exp $ */
d960 1
@


1.37
log
@Replace gazillions of badvaddr() or badwordaddr() calls with badaddr() calls.
With a few prototype declarations shuffling, this finally allows
<machine/locore.h> to die.
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.36 2004/07/30 19:02:06 miod Exp $ */
d869 1
a869 1
	char buffer[WRING_BUF_SIZE];
d890 1
a890 1
			cnt = min(WRING_BUF_SIZE, cc);
@


1.36
log
@Move evcount structures inside struct intrhand, this makes more sense and
gives us more counters in the process.

Also clean up intrhand structures and usage, especially move them to SLISTs.
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.35 2004/07/02 14:00:43 miod Exp $ */
d178 1
a178 1
	rc = badvaddr((vaddr_t)&vx_reg->ipc_cr, 1);
@


1.35
log
@Switch mvme88k to evcount, but keep maintaining intrcnt[] too for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.34 2004/07/02 11:19:43 miod Exp $ */
a40 1
#include <sys/evcount.h>
a67 1
	struct evcount    sc_intrcnt;
d228 1
a228 3
	vmeintr_establish(ca->ca_vec, &sc->sc_ih);
	evcount_attach(&sc->sc_intrcnt, self->dv_xname,
	    (void *)&sc->sc_ih.ih_ipl, &evcount_intr);
a972 2

	sc->sc_intrcnt.ec_count++;
@


1.34
log
@Remove unused extra intrhand.
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.33 2004/05/26 21:16:10 miod Exp $ */
d41 1
d69 1
a69 1
	struct evcnt      sc_intrcnt;
d231 2
a232 1
	evcnt_attach(&sc->sc_dev, "intr", &sc->sc_intrcnt);
d978 1
a978 1
	sc->sc_intrcnt.ev_count++;
@


1.33
log
@Define correct EOF and EOL characters in the default firmware termios
structure.
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.32 2004/05/26 21:15:31 miod Exp $ */
d76 1
a76 2
	struct intrhand   sc_ih_c;
	struct intrhand   sc_ih_s;
d224 4
a227 4
	sc->sc_ih_c.ih_fn = vx_intr;
	sc->sc_ih_c.ih_arg = sc;
	sc->sc_ih_c.ih_wantframe = 0;
	sc->sc_ih_c.ih_ipl = IPL_TTY;
d229 1
a229 1
	vmeintr_establish(ca->ca_vec, &sc->sc_ih_c);
@


1.32
log
@Use physical addresses as seen in the A24 MVME332XT address space, this
allows the driver to really don't care about its VME address and simplifies
some code.
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.31 2004/05/25 21:22:49 miod Exp $ */
d1303 1
d1306 1
d1491 2
a1492 6
		inf.def_termio.c_cc[4] = 20;
		inf.def_termio.c_cc[5] = 2;
		inf.reserved1 = 0;  /* Must Be Zero */
		inf.reserved2 = 0;
		inf.reserved3 = 0;
		inf.reserved4 = 0;
@


1.31
log
@Make bpp_send() return the packet error code when invoked with NOWAIT.
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.30 2004/05/25 21:21:23 miod Exp $ */
a70 1
	paddr_t		board_addr;
d142 10
a151 2
#define	PHYSICAL(addr)	(((addr - sc->board_vaddr) & 0xffff) + sc->board_addr)
/* #define	PHYSICAL(addr)	(((addr - sc->board_vaddr) & 0xffff) | 0xf30000) */
a199 2

	sc->board_addr = ca->ca_paddr;
@


1.30
log
@Make this driver aware of non-1:1 mappings.
This currently mimcs the existing code, which can be cleaned up further.
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.29 2004/04/24 19:51:48 miod Exp $ */
d95 1
a95 1
void	bpp_send(struct vxsoftc *, void *, int);
a244 1
	bpp_send(sc, &pkt, NOWAIT);
d246 1
a246 1
	return (pkt.error_l);
a264 1
	bpp_send(sc, &pkt, NOWAIT);
d266 1
a266 1
	return (pkt.error_l);
a281 1
	bpp_send(sc, &pkt, NOWAIT);
d283 1
a283 1
	return (pkt.error_l);
d377 1
a377 1
	int s, unit, port;
a396 1
	opkt.link = 0x33333333;	/* eye catcher */
d402 1
a402 3
	bpp_send(sc, &opkt, WAIT);

	if (opkt.error_l) {
d405 1
a405 1
		printf("error = %d\n", opkt.error_l);
a532 1
	cpkt.link = 0x55555555;	/* eye catcher */
a562 1
	rwp.link = 0x11111111;	/* eye catcher */
a623 1
		wwp.link = 0x22222222;	/* eye catcher */
d628 1
a628 3
		bpp_send(sc, &wwp, WAIT);

		if (wwp.error_l != 0)
d804 2
a805 1
	bpp_send(sc, &pkt, WAIT);
d845 2
a846 1
	bpp_send(sc, &pkt, WAIT);
d1395 1
a1395 1
void
d1400 2
a1401 1
	u_long ptr;
d1419 5
a1423 2
	if (wait_flag != NOWAIT) {
		while (pktp->command != CMD_PROCESSED) {
d1425 1
a1425 1
			printf("Polling for packet 0x%x in envelope 0x%x...\n", pktp, envp);
d1427 5
a1431 2
			vx_intr(sc);
			delay(5000);
d1433 1
a1433 1
		d16_bcopy(pktp, pkt, sizeof(struct packet));
d1435 2
d1447 1
a1497 1
	init.link = 0x12345678;	/* eye catcher */
d1508 2
a1509 3
	bpp_send(sc, &init, WAIT);
	if (init.error_l != 0)
		return init.error_l;
@


1.29
log
@Preliminary switch to an mvme88k bus_space world. Not all drivers have been
converted yet, and they rely upon some linear mappings provided by bus_space.

In order to not impact performance, almost all the bus_space accesses go
through macros and inline functions. This currently restricts us to D16 and
D32 access modes, which are selected at compilation time. Since there are no
plans to support D8 vme devices in the future, this is acceptable for now.

This makes the "len" locator for vme devices go away, and allows to simplify
some code which was using the pcctwo device, and will now directly access
hardware which is known to exist, rather than wait until the device is
attached.

While there, try to enforce more interrupt vector number checks, since these
changes pointed out that dart(4) had been working correctly so far by sheer
luck only.
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.28 2004/04/16 23:36:27 miod Exp $ */
d71 2
a72 1
	vaddr_t		board_addr;
d106 1
a106 1
struct envelope *get_next_envelope(struct envelope *);
d138 8
d194 2
d202 3
a204 3
	sc->board_addr = (vaddr_t)bus_space_vaddr(iot, ioh);
	sc->vx_reg = (struct vxreg *)sc->board_addr;
	sc->channel = (struct channel *)(sc->board_addr + 0x0100);
d996 1
a996 1
		next_envp = get_next_envelope(get_status_head(sc));
d1139 1
a1139 1
	envp = (struct envelope *)ENVELOPE_AREA;
d1141 1
a1141 1
	for (i = 0; i < NENVELOPES; i++) {
d1143 1
a1143 1
		if (i == NENVELOPES - 1)
d1146 1
a1146 1
			env.link = (u_long)envp + sizeof(struct envelope);
d1154 1
a1154 1
	pktp = (struct packet *)PACKET_AREA;
d1156 1
a1156 1
	for (i = 0; i < NPACKETS; i++) {
d1158 1
a1158 1
		if (i == NPACKETS - 1)
d1161 1
a1161 1
			pkt.link = (u_long)pktp + sizeof(struct packet);
d1171 2
a1172 2
	void *envp;
	u_long link;
d1176 2
a1177 2
	d16_bcopy((const void *)&sc->elist_head->link, &link, sizeof link);
	sc->elist_head = (struct envelope *)link;
d1193 2
a1194 1
	link = (u_long)envp;
a1195 1
	d16_bzero((void *)&envp->link, sizeof envp->link);
d1204 1
a1204 1
	u_long link;
d1208 2
a1209 2
	d16_bcopy((const void *)&sc->plist_head->link, &link, sizeof link);
	sc->plist_head = (struct packet *)link;
d1226 2
a1227 1
	link = (u_long)pktp;
a1228 1
	d16_bzero((void *)&pktp->link, sizeof pktp->link);
d1241 1
a1241 1
	struct envelope *envp;
d1244 1
a1244 1
	struct vxreg *ipc_csr;
a1245 1
	ipc_csr = sc->vx_reg;
d1247 2
a1248 1
	while ((ipc_csr->ipc_cr & IPC_CR_BUSY)) ;
d1251 1
d1255 1
a1255 1
		envp = get_free_envelope(sc);
d1262 1
a1262 1
		envp = get_free_envelope(sc);
d1278 2
a1279 1
		while ((ipc_csr->ipc_tas & IPC_TAS_TAS)) ;
d1282 2
a1283 2
		ipc_csr->ipc_addrh = HI(sc->channel);
		ipc_csr->ipc_addrl = LO(sc->channel);
d1305 1
a1305 1
	if (!status && sc->channel->valid) {
d1338 1
a1338 1
get_next_envelope(struct envelope *thisenv)
d1340 1
a1340 1
	u_long ptr;
d1344 1
a1344 1
	return ((struct envelope *)ptr);
d1356 1
a1356 1
	unsigned long retaddr;
d1358 1
a1358 1
	retaddr = (unsigned long)sc->vx_reg;
d1360 1
a1360 1
	return ((struct envelope *)retaddr);
d1366 1
a1366 1
	unsigned long retaddr;
d1368 1
a1368 1
	retaddr = (unsigned long)sc->vx_reg;
d1370 1
a1370 1
	return ((struct envelope *)retaddr);
d1376 5
a1380 2
	sc->channel->status_pipe_head_ptr_h = HI(envp);
	sc->channel->status_pipe_head_ptr_l = LO(envp);
d1386 1
a1386 1
	u_long baseaddr;
d1398 1
a1398 3
	baseaddr |= (u_long)sc->vx_reg;

	return ((struct packet *)baseaddr);
d1416 1
a1416 2
	ptr = (unsigned long)get_free_envelope(sc); /* put a NULL env on the tail */
	d16_bcopy(&ptr, (void *)&envp->link, sizeof envp->link);
d1419 2
a1420 1
	ptr = (u_long)pktp;
d1448 1
a1448 3
	struct wring *wringp;
	struct rring *rringp;
	struct termio def_termio;
a1451 1
	bzero(&def_termio, sizeof(struct termio));
d1456 4
a1459 3
	wringp = (struct wring *)WRING_AREA;
	rringp = (struct rring *)RRING_AREA;
	infp = (struct init_info *)INIT_INFO_AREA;
d1464 1
a1464 1
		sc->sc_info[i].wringp = wringp;
d1467 1
a1467 1
		sc->sc_info[i].rringp = rringp;
d1490 3
a1492 1
		wringp++; rringp++; infp++;
d1494 1
d1523 1
@


1.28
log
@Do not attach if we could not get an interrupt.
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.27 2003/12/27 21:58:20 miod Exp $ */
d29 3
d71 1
a71 1
	unsigned int      board_addr;
a77 1
	int               sc_ipl;
d157 3
d161 5
a165 4
	ca->ca_ipl = IPL_TTY;
	ca->ca_len = 0x10000;	/* we know this */

	vx_reg = (struct vxreg *)ca->ca_vaddr;
d167 1
a167 1
	return (!badvaddr((vaddr_t)&vx_reg->ipc_cr, 1));
d175 2
d185 5
d191 1
a191 1
	sc->board_addr = (unsigned int)ca->ca_vaddr;
a193 1
	sc->sc_ipl = ca->ca_ipl;
d212 1
a212 1
	sc->sc_ih_c.ih_ipl = ca->ca_ipl;
d1257 1
a1257 1
		sc->channel->interrupt_level = sc->sc_ipl;
d1487 1
a1487 1
	init.interrupt_level = sc->sc_ipl;
@


1.27
log
@Basic cleaning and KNF; no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.26 2003/12/25 21:01:39 miod Exp $ */
a76 1
	int               sc_flags;
d170 7
d178 3
a180 2
	sc->vx_reg = (struct vxreg *)ca->ca_vaddr;
	sc->channel = (struct channel *)(ca->ca_vaddr + 0x0100);
a182 1
	sc->board_addr = (unsigned int)ca->ca_vaddr;
@


1.26
log
@Provide common D16 vmespace block access functions, instead of vs and vx each
rolling their own.

Use them more cleverly in vx, in order to get the driver to at least attach
and frob chips. Not tested besides multiuser boot (hence ttyflags -a), and
checking cu(1) connects. More testing to come once I remember where I have
hidden the 332XT transition module...
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.25 2003/12/22 11:54:48 miod Exp $ */
a48 9
#include "pcctwo.h"
#if NPCCTWO > 0
#include <mvme88k/dev/pcctworeg.h>
#endif

#ifdef	DDB
#include <ddb/db_var.h>
#endif

a56 1
	u_char   vx_consio;
d66 1
a66 2
	struct evcnt      sc_sintrcnt;
	struct vx_info  sc_info[9];
a74 3
#if defined(MVME187) || defined(MVME197)
	struct vme2reg    *sc_vme2;
#endif
d82 2
a83 52
/* prototypes */

struct envelope *get_next_envelope(struct envelope *thisenv);
struct envelope *get_status_head(struct vxsoftc *sc);
void set_status_head(struct vxsoftc *sc, void *envp);
struct packet *get_packet(struct vxsoftc *sc, struct envelope *thisenv);
struct envelope *find_status_packet(struct vxsoftc *sc, struct packet * pktp);

void read_wakeup(struct vxsoftc *sc, int port);
int  bpp_send(struct vxsoftc *sc, void *pkt, int wait_flag);

int  create_channels(struct vxsoftc *sc);
int  env_isvalid(struct envelope *thisenv);
void *get_free_envelope(struct vxsoftc *sc);
void put_free_envelope(struct vxsoftc *sc, void *envp);
void *get_free_packet(struct vxsoftc *sc);
void put_free_packet(struct vxsoftc *sc, void *pktp);

int  vx_init(struct vxsoftc *sc);
int  vx_event(struct vxsoftc *sc, struct packet *evntp);

void vx_unblock(struct tty *tp);
int  vx_ccparam(struct vxsoftc *sc, struct termios *par, int port);

int  vx_param(struct tty *tp, struct termios *t);
int  vx_intr(void * arg);
int  vx_sintr(struct vxsoftc *sc);
int  vx_poll(struct vxsoftc *sc, struct packet *wpktp);
void vx_overflow(struct vxsoftc *sc, int port, long *ptime, u_char *msg);
void vx_frame(struct vxsoftc *sc, int port);
void vx_break( struct vxsoftc *sc, int port);
int  vx_mctl(dev_t dev, int bits, int how);

int  vxmatch(struct device *parent, void *self, void *aux);
void vxattach(struct device *parent, struct device *self, void *aux);

void vxstart(struct tty *tp);

void   vxputc(struct vxsoftc *sc, int port, u_char c);

struct tty * vxtty(dev_t);
short dtr_ctl(struct vxsoftc *, int, int);
short rts_ctl(struct vxsoftc *, int, int);
short flush_ctl(struct vxsoftc *, int, int);
u_short vxtspeed(int);
void read_chars(struct vxsoftc *, int);
void ccode(struct vxsoftc *, int, char);
int create_free_queue(struct vxsoftc *);
struct envelope *get_cmd_tail(struct vxsoftc *);
#ifdef DEBUG_VXT
void print_dump(struct vxsoftc *);
#endif
d90 1
a90 1
	NULL, "vx", DV_TTY, 0
d93 42
a134 2
#define VX_UNIT(x) (minor(x) / 9)
#define VX_PORT(x) (minor(x) % 9)
d137 1
a137 2
vxtty(dev)
	dev_t dev;
d152 1
a152 4
vxmatch(parent, self, aux)
	struct device *parent;
	void *self;
	void *aux;
d157 1
a157 1
	ca->ca_ipl = 3;	/* we need interrupts for this board to work */
a160 2
	if (badvaddr((unsigned)&vx_reg->ipc_cr, 1))
			return (0);
d162 1
a162 1
	return (1);
d166 1
a166 4
vxattach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
d171 1
a171 1
	/* set up dual port memory and registers and init*/
a173 3
#if defined(MVME187) || defined(MVME197)
	sc->sc_vme2 = ca->ca_master;
#endif
d180 3
a182 3
	if (create_channels(sc)) {
		printf("%s: failed to create channel %d\n", sc->sc_dev.dv_xname,
		       sc->channel->channel_number);
d185 1
a185 1
	if (vx_init(sc)) {
a199 2
int vxtdefaultrate = TTYDEF_SPEED;

d201 1
a201 4
dtr_ctl(sc, port, on)
	struct vxsoftc *sc;
	int port;
	int on;
d217 1
d222 1
a222 4
rts_ctl(sc, port, on)
	struct vxsoftc *sc;
	int port;
	int on;
d238 1
d242 1
d244 1
a244 4
flush_ctl(sc, port, which)
	struct vxsoftc *sc;
	int port;
	int which;
d256 1
d259 1
d262 1
a262 4
vx_mctl(dev, bits, how)
	dev_t dev;
	int bits;
	int how;
d271 1
a271 1
	sc = (struct vxsoftc *) vx_cd.cd_devs[unit];
d277 1
a277 1
		if( bits & TIOCM_RTS) {
a281 1

d284 1
a284 1
		if ( bits & TIOCM_DTR) {
d293 1
a293 1
		if ( bits & TIOCM_RTS) {
d297 1
a297 1
		if ( bits & TIOCM_DTR) {
d304 1
a304 1
		if ( bits & TIOCM_RTS) {
d308 1
a308 1
		if ( bits & TIOCM_DTR) {
d317 1
a317 1
		if ( msvr & TIOCM_DSR) {
d320 1
a320 1
		if ( msvr & TIOCM_CD) {
d323 1
a323 1
		if ( msvr & TIOCM_CTS) {
d326 1
a326 1
		if ( msvr & TIOCM_DTR) {
d329 1
a329 1
		if ( msvr & TIOCM_RTS) {
d336 2
d344 1
d349 1
a349 5
vxopen(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
a359 1

d364 1
d366 3
a368 1
	/*flush_ctl(sc, port, 2);*/
d377 1
a377 1
	bpp_send(sc, &opkt, WAIT_POLL);
d384 1
a384 1
		return (ENODEV);
d388 1
a389 2

	vxt = &sc->sc_info[port];
d423 1
a423 1
			tp->t_ispeed = tp->t_ospeed = vxtdefaultrate;
d453 1
a453 1
	return ((*linesw[tp->t_line].l_open)(dev, tp));
d457 1
a457 3
vx_param(tp, t)
	struct tty *tp;
	struct termios *t;
d479 1
a479 5
vxclose(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
d494 4
a497 1
/*   flush_ctl(sc, port, 2);   flush both input and output */
a498 1
	vxt = &sc->sc_info[port];
d502 2
a508 2
	s = splvx();

d515 1
a516 1
	bpp_send(sc, &cpkt, NOWAIT);
d520 1
d525 1
a525 3
read_wakeup(sc, port)
	struct vxsoftc *sc;
	int port;
d529 1
d535 1
a535 1
	if (vxt->read_pending) {
d537 1
a537 1
	} else {
a538 1
	}
d549 1
a549 1
	 * to (*linesw[tp->t_line].l_rint)(c,tp); by
d556 1
a556 4
vxread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
d577 1
a577 4
vxwrite(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
a591 1

a600 1

d608 1
d610 3
a612 18
		port = VX_PORT(dev);
		vxt = &sc->sc_info[port];
		tp = vxt->tty;
		if (!tp) return ENXIO;

		wp = sc->sc_info[port].wringp;
		get = wp->get;
		put = wp->put;

		if ((put + 1) == get) {
			bzero(&wwp, sizeof(struct packet));
			wwp.link = 0x22222222;	/* eye catcher */
			wwp.command_pipe_number = sc->channel_number;
			wwp.status_pipe_number = sc->channel_number;
			wwp.command = CMD_WRITEW;
			wwp.device_number = port;

			bpp_send(sc, &wwp, WAIT_POLL);
a613 5
			if (wwp.error_l) {
				return (ENXIO);
			}
		}
	}
d618 1
a618 6
vxioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d655 1
a655 1
		(void) vx_mctl(dev, TIOCM_DTR | TIOCM_RTS, DMBIS);
d659 1
a659 1
		(void) vx_mctl(dev, TIOCM_DTR | TIOCM_RTS, DMBIC);
d663 1
a663 1
		(void) vx_mctl(dev, *(int *) data, DMSET);
d667 1
a667 1
		(void) vx_mctl(dev, *(int *) data, DMBIS);
d671 1
a671 1
		(void) vx_mctl(dev, *(int *) data, DMBIC);
d695 1
d700 1
a700 3
vxstop(tp, flag)
	struct tty *tp;
	int flag;
d714 1
a714 4
vxputc(sc, port, c)
	struct vxsoftc *sc;
	int port;
	u_char c;
d719 2
a720 2
	wp->data[wp->put++ & (WRING_BUF_SIZE-1)] = c;
	wp->put &= (WRING_BUF_SIZE-1);
d724 1
a724 2
vxtspeed(speed)
	int speed;
a728 1
		break;
a730 1
		break;
a732 1
		break;
a734 1
		break;
a736 1
		break;
a738 1
		break;
a740 1
		break;
a742 1
		break;
a744 1
		break;
a746 1
		break;
a748 1
		break;
a750 1
		break;
a752 1
		break;
a754 1
		break;
a756 1
		break;
a758 1
		break;
a760 1
		break;
d765 1
a765 4
vx_ccparam(sc, par, port)
	struct vxsoftc *sc;
	struct termios *par;
	int port;
d767 2
a768 2
	int imask=0, s;
	int cflag /*, iflag, oflag, lflag*/;
a770 2
	bzero(&pkt, sizeof(struct packet));

d773 3
a775 6
		/* dont kill the console */
		if (sc->sc_info[port].vx_consio == 0) {
			/* disconnect, drop RTS DTR stop receiver */
			rts_ctl(sc, port, 0);
			dtr_ctl(sc, port, 0);
		}
d780 1
d786 1
a786 1
	bpp_send(sc, &pkt, WAIT_POLL);
d819 1
a819 26
#if 0
	if (par->c_iflag & BRKINT) iflag |= VBRKINT;
	else iflag &= ~VBRKINT;
	if (par->c_iflag & ISTRIP) iflag |= VISTRIP;
	else iflag &= ~VISTRIP;
	if (par->c_iflag & ICRNL) iflag |= VICRNL;
	else iflag &= ~VICRNL;
	if (par->c_iflag & IXON) iflag |= VIXON;
	else iflag &= ~VIXON;
	if (par->c_iflag & IXANY) iflag |= VIXANY;
	else iflag &= ~VIXANY;
	if (par->c_oflag & OPOST) oflag |= VOPOST;
	else oflag &= ~VOPOST;
	if (par->c_oflag & ONLCR) oflag |= VONLCR;
	else oflag &= ~VONLCR;
	if (par->c_oflag & OXTABS) oflag |= VOXTABS;
	else oflag &= ~VOXTABS;
	if (par->c_lflag & ECHO) lflag |= VECHO;
	else lflag &= ~VECHO;
	if (par->c_lflag & ECHOE) lflag |= VECHOE;
	else lflag &= ~VECHOE;
	if (par->c_lflag & ICANON) lflag |= VICANON;
	else lflag &= ~VICANON;
	if (par->c_lflag & ISIG) lflag |= VISIG;
	else lflag &= ~VISIG;
#endif
d826 1
a826 5
#if 0
	pkt.pb.tio.c_iflag = iflag;
	pkt.pb.tio.c_oflag = oflag;
	pkt.pb.tio.c_lflag = lflag;
#endif
a827 1
	bpp_send(sc, &pkt, WAIT_POLL);
d832 1
a832 2
vx_unblock(tp)
	struct tty *tp;
d840 1
a840 2
vxstart(tp)
	struct tty *tp;
d871 1
a871 1
			for (i=0; i<cnt; i++) {
d882 1
a882 3
read_chars(sc, port)
	struct vxsoftc *sc;
	int port;
d911 1
a911 1
		for (i=0; i<frame_count; i++) {
d915 1
a915 1
				(*linesw[tp->t_line].l_rint)(c,tp);
d920 1
a920 1
			vx_frame (sc, port);
d933 1
a933 4
ccode(sc, port, c)
	struct vxsoftc *sc;
	int port;
	char c;
d937 1
d939 1
a939 3
	vxt = &sc->sc_info[port];
	tp = vxt->tty;
	(*linesw[tp->t_line].l_rint)(c,tp);
d943 1
a943 2
vx_intr(arg)
	void *arg;
d949 2
a950 5
	short  cmd;
	u_char  port;

#if defined(MVME187) || defined(MVME197)
	struct vme2reg *vme2 = (struct vme2reg *)sc->sc_vme2;
d952 1
a952 6
	if (vme2->vme2_vbr & VME2_SYSFAIL) {
		/* do something... print_dump(sc); */
	}
#endif /* defined(MVME187) || defined(MVME197) */

	if (!cold) sc->sc_intrcnt.ev_count++;
d959 4
a962 2
		/* if we are waiting on this packet, strore the info so bpp_send
		   can process the packet  */
a980 1
			return 1;
a985 1
			return 1;
a991 1
			return 1;
a996 1
			return 1;
a1001 1
			return 1;
d1009 1
a1009 3
vx_event(sc, evntp)
	struct vxsoftc *sc;
	struct packet *evntp;
d1058 1
a1058 1
		vx_break (sc, evntp->device_number);
d1061 1
a1061 1
	/* send and event packet backe to the device */
d1070 1
d1075 1
a1075 5
vx_overflow(sc, port, ptime, msg)
	struct vxsoftc *sc;
	int port;
	long *ptime;
	u_char *msg;
d1077 2
a1078 1
	log(LOG_WARNING, "%s port %d: overrun\n", sc->sc_dev.dv_xname, port);
d1082 1
a1082 3
vx_frame(sc, port)
	struct vxsoftc *sc;
	int port;
d1084 2
a1085 1
	log(LOG_WARNING, "%s port %d: frame error\n", sc->sc_dev.dv_xname, port);
d1089 1
a1089 3
vx_break(sc, port)
	struct vxsoftc *sc;
	int port;
d1091 6
a1096 6
#ifdef DDB
	if (db_console != 0)
		Debugger();
#else
	log(LOG_WARNING, "%s port %d: break detected\n", sc->sc_dev.dv_xname, port);
#endif
d1103 2
a1104 3
int
create_free_queue(sc)
	struct vxsoftc *sc;
d1108 1
a1108 1
	struct packet   *pktp, pkt;
d1112 1
a1112 1
	for (i=0; i < NENVELOPES; i++) {
d1114 1
a1114 1
		if (i==(NENVELOPES - 1)) {
d1116 1
a1116 1
		} else {
a1117 1
		}
d1127 1
a1127 1
	for (i=0; i < NPACKETS; i++) {
d1129 1
a1129 1
		if (i==(NPACKETS - 1)) {
d1131 1
a1131 1
		} else {
a1132 1
		}
a1136 1
	return 0; /* no error */
d1140 1
a1140 2
get_free_envelope(sc)
	struct vxsoftc *sc;
d1155 1
a1155 3
put_free_envelope(sc, ep)
	struct vxsoftc *sc;
	void * ep;
d1172 1
a1172 2
get_free_packet(sc)
	struct vxsoftc *sc;
d1187 1
a1187 3
put_free_packet(sc, pp)
	struct vxsoftc *sc;
	void *pp;
d1210 1
a1210 2
create_channels(sc)
	struct vxsoftc *sc;
d1219 2
a1220 1
	while ((ipc_csr->ipc_cr & IPC_CR_BUSY));
d1222 1
a1222 1
	/* set up channel header.  we only want one */
d1228 4
a1231 2
		sc->channel->command_pipe_tail_ptr_h = sc->channel->command_pipe_head_ptr_h;
		sc->channel->command_pipe_tail_ptr_l = sc->channel->command_pipe_head_ptr_l;
d1235 5
a1239 3
		sc->channel->status_pipe_tail_ptr_h = sc->channel->status_pipe_head_ptr_h;
		sc->channel->status_pipe_tail_ptr_l = sc->channel->status_pipe_head_ptr_l;
		sc->channel->interrupt_level =  sc->sc_ipl;
d1244 1
a1244 1
		sc->channel->address_modifier = 0x8D; /* A32/D16 supervisor data access */
d1248 1
a1248 1
		while ((ipc_csr->ipc_tas & IPC_TAS_TAS));
d1254 1
a1254 1
		ipc_csr->ipc_amr = 0x8D;
d1261 2
a1262 1
		/* loop until IPC sets vaild status bit */
d1302 1
a1302 1
		return status; /* error */
a1305 19
#ifdef DEBUG_VXT
void
print_dump(sc)
	struct vxsoftc *sc;
{
	char *dump_area;
#define	DUMPSIZE	(0x100 - 0x30)
	char dump[1 + DUMPSIZE];

	bzero(&dump, sizeof dump);

	dump_area = (char *)0xff780030;
	d16_bcopy(dump_area, &dump, DUMPSIZE);
#undef	DUMPSIZE

	printf("%s", dump);
}
#endif

d1307 1
a1307 2
get_next_envelope(thisenv)
	struct envelope *thisenv;
d1317 1
a1317 2
env_isvalid(thisenv)
	struct envelope *thisenv;
d1319 1
a1319 1
	return thisenv->valid_flag;
d1323 1
a1323 2
get_cmd_tail(sc)
	struct vxsoftc *sc;
d1326 1
d1333 1
a1333 2
get_status_head(sc)
	struct vxsoftc *sc;
d1336 1
d1343 1
a1343 3
set_status_head(sc, envp)
	struct vxsoftc *sc;
	void *envp;
d1350 1
a1350 3
get_packet(sc, thisenv)
	struct vxsoftc *sc;
	struct envelope *thisenv;
d1361 1
a1361 1
	 * offset to the board address
d1372 1
a1372 1
int
d1388 1
a1388 1
	ptr = (u_long)pktp;		   /* add the command packet */
d1390 1
a1390 1
	envp->valid_flag = 1;		   /* set valid command flag */
d1393 3
a1395 1
	if (wait_flag) {		    /* wait for a packet to return */
a1403 1
		return 0;
a1404 1
	return 0; /* no error */
d1412 1
a1412 2
vx_init(sc)
	struct vxsoftc *sc;
d1430 1
a1430 1
	for (i=0; i<9; i++) {
d1448 1
a1448 1
		inf.def_termio.c_line = 1; /* raw line disipline, we want to control it! */
d1455 1
a1455 1
		inf.reserved1 = 0;  /* Must be Zero */
d1475 3
a1477 1
	bpp_send(sc, &init, WAIT_POLL);
d1479 10
a1488 16
	/* check for error */
	if (init.error_l !=0) {
		return init.error_l;
	} else {
		/* send one event packet to each device; */
		for (i = 0; i < 9; i++) {
			bzero(&evnt, sizeof(struct packet));
			evnt.command = CMD_EVENT;
			evnt.device_number = i;
			evnt.command_pipe_number = sc->channel_number;
			/* return status on same channel */
			evnt.status_pipe_number = sc->channel_number;
			/* send packet to the firmware */
			bpp_send(sc, &evnt, NOWAIT);
		}
		return 0;
d1490 1
@


1.25
log
@Correctly handle vme attachments which specify a larger ca_len size than
initially expected.
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.24 2003/11/09 00:31:59 miod Exp $ */
a59 4
#ifdef DEBUG
#undef DEBUG
#endif

d98 1
a98 1
void *get_next_envelope(struct envelope *thisenv);
a108 1
void memcpy2(void *dest, const void *src, size_t size);
a142 1
void wzero(void *, size_t);
d144 2
d147 1
a147 1
struct envelope *get_cmd_tail(struct vxsoftc *);
d157 2
a158 2
#define VX_UNIT(x) (int)(minor(x) / 9)
#define VX_PORT(x) (int)(minor(x) % 9)
d160 2
a161 1
struct tty * vxtty(dev)
d166 1
d169 1
a169 1
	    (sc = (struct vxsoftc *) vx_cd.cd_devs[unit]) == NULL) {
d245 1
d268 1
d291 1
d303 2
a304 1
int vx_mctl (dev, bits, how)
d391 2
a392 1
int vxopen (dev, flag, mode, p)
d402 1
a402 1
	struct open_packet opkt;
d416 1
a416 4
	opkt.eye_catcher[0] = 0x33;
	opkt.eye_catcher[1] = 0x33;
	opkt.eye_catcher[2] = 0x33;
	opkt.eye_catcher[3] = 0x33;
d497 1
a497 2
	sc->sc_info[port].open = 1;
	read_wakeup(sc, port);
d527 1
a527 1
vxclose (dev, flag, mode, p)
d538 2
a539 1
	struct close_packet cpkt;
d560 1
a560 4
	cpkt.eye_catcher[0] = 0x55;
	cpkt.eye_catcher[1] = 0x55;
	cpkt.eye_catcher[2] = 0x55;
	cpkt.eye_catcher[3] = 0x55;
d567 1
a569 1
	sc->sc_info[port].open = 0;
d578 1
a578 1
	struct read_wakeup_packet rwp;
d592 1
a592 4
	rwp.eye_catcher[0] = 0x11;
	rwp.eye_catcher[1] = 0x11;
	rwp.eye_catcher[2] = 0x11;
	rwp.eye_catcher[3] = 0x11;
d607 1
a607 1
vxread (dev, uio, flag)
d625 2
a626 1
	if (!tp) return ENXIO;
d631 1
a631 1
vxwrite (dev, uio, flag)
d641 1
a641 1
	struct write_wakeup_packet wwp;
d653 2
a654 1
	if (!tp) return ENXIO;
d662 1
a662 4
		wwp.eye_catcher[0] = 0x22;
		wwp.eye_catcher[1] = 0x22;
		wwp.eye_catcher[2] = 0x22;
		wwp.eye_catcher[3] = 0x22;
d679 1
a679 4
			wwp.eye_catcher[0] = 0x22;
			wwp.eye_catcher[1] = 0x22;
			wwp.eye_catcher[2] = 0x22;
			wwp.eye_catcher[3] = 0x22;
d696 1
a696 1
vxioctl (dev, cmd, data, flag, p)
d708 1
d772 1
a772 1
				   (TIOCFLAG_SOFTCAR | TIOCFLAG_CLOCAL | TIOCFLAG_CRTSCTS);
a807 1
	return;
d877 2
a878 1
	struct ioctl_a_packet pkt;
d900 1
a900 1
	cflag = pkt.c_cflag;
d962 1
a962 1
	pkt.c_cflag = cflag;
d964 3
a966 3
	pkt.c_iflag = iflag;
	pkt.c_oflag = oflag;
	pkt.c_lflag = lflag;
a1022 1
	return;
a1075 1
	return;
d1110 1
d1121 1
a1121 1
			memcpy2(&sc->sc_bppwait_pkt, pktp, sizeof(struct packet));
d1123 1
a1123 1
		memcpy2(&pkt, pktp, sizeof(struct packet));
d1176 1
a1176 1
	struct event_packet evnt;
d1226 1
a1226 1
	bzero(&evnt, sizeof(struct event_packet));
d1238 1
a1238 1
vx_overflow (sc, port, ptime, msg)
a1244 1
	return;
d1248 1
a1248 1
vx_frame (sc, port)
a1252 1
	return;
d1256 1
a1256 1
vx_break (sc, port)
a1265 1
	return;
a1271 28
/* special function for 16 bit data transfer */
/* Not needed now that I figured out VME bus */
/* mappings and address modifiers, but I don't */
/* want to change them :) */
void
memcpy2(void *dest, const void *src, size_t size)
{
	size_t i;
	u_int16_t *d, *s;

	d = (u_int16_t *)dest;
	s = (u_int16_t *)src;
	size /= 2;
	for (i = 0; i < size; i++)
		*d++ = *s++;
}

void
wzero(void *addr, size_t size)
{
	u_int16_t *d;

	d = (u_int16_t *)addr;
	size /= 2;
	while (size-- != 0)
		*d++ = 0;
}

d1277 2
a1278 2
	struct envelope *envp;
	struct packet   *pktp;
d1283 1
a1283 1
		bzero(envp, sizeof(struct envelope));
d1285 1
a1285 1
			envp->link = NULL;
d1287 1
a1287 1
			envp->link = (u_long)envp + sizeof(struct envelope);
d1289 3
a1291 2
		envp->packet_ptr = NULL;
		envp->valid_flag = 0;
d1299 1
a1299 1
		bzero(pktp, sizeof(struct packet));
d1301 1
a1301 1
			pktp->link = NULL;
d1303 1
a1303 1
			pktp->link = (u_long)pktp + sizeof(struct packet);
d1305 1
d1317 1
d1320 5
a1324 2
	sc->elist_head = (struct envelope *)sc->elist_head->link;
	bzero(envp, sizeof(struct envelope));
d1334 10
a1343 3
	bzero(envp, sizeof(struct envelope));
	sc->elist_tail->link = (ulong)envp;
	envp->link = NULL;
d1352 1
d1355 5
a1359 2
	sc->plist_head = (struct packet *)sc->plist_head->link;
	bzero(pktp, sizeof(struct packet));
d1369 5
a1373 1
	/*bzero(pktp, sizeof(struct packet));*/
d1375 5
a1379 2
	sc->plist_tail->link = (u_long)pktp;
	pktp->link = NULL;
d1480 1
d1486 4
a1489 2
	char dump[209];
	bzero(&dump, 209);
d1492 2
a1493 1
	memcpy2(&dump, dump_area, 208);
d1497 1
d1499 1
a1499 1
void *
d1503 5
a1507 1
	return ((void *)thisenv->link);
d1551 4
a1554 1
	unsigned long baseaddr;
a1555 2
	if (thisenv == NULL) return NULL;
	baseaddr = (unsigned long)sc->vx_reg;
d1562 4
a1565 2
	baseaddr |= thisenv->packet_ptr;
	return ((void *)baseaddr);
d1576 1
a1576 2
	unsigned long newenv;

d1580 1
a1580 1
	memcpy2(pktp, pkt, sizeof(struct packet));
d1583 6
a1588 5
	newenv = (unsigned long)get_free_envelope(sc); /* put a NULL env on the tail */
	envp->link = newenv;
	sc->channel->command_pipe_tail_ptr_h = HI(newenv);
	sc->channel->command_pipe_tail_ptr_l = LO(newenv);
	envp->packet_ptr = (u_long)pktp;   /* add the command packet */
d1600 1
a1600 1
		memcpy2(pkt, pktp, sizeof(struct packet));
d1619 2
a1620 2
	struct init_packet init;
	struct event_packet evnt;
d1624 1
a1624 1
	bzero(&sc->sc_bppwait_pkt, sizeof(struct packet));
d1632 2
a1633 2
		infp->write_ring_ptr_h = HI(wringp);
		infp->write_ring_ptr_l = LO(wringp);
d1635 2
a1636 2
		infp->read_ring_ptr_h = HI(rringp);
		infp->read_ring_ptr_l = LO(rringp);
d1641 19
a1659 18
		infp->write_ring_size = WRING_DATA_SIZE;
		infp->read_ring_size = RRING_DATA_SIZE;
		infp->def_termio.c_iflag = VBRKINT;
		infp->def_termio.c_oflag = 0;
		infp->def_termio.c_cflag = (VB9600 | VCS8);

		infp->def_termio.c_lflag = VISIG; /* enable signal processing */
		infp->def_termio.c_line = 1; /* raw line disipline, we want to control it! */
		infp->def_termio.c_cc[0] = CINTR;
		infp->def_termio.c_cc[1] = CQUIT;
		infp->def_termio.c_cc[2] = CERASE;
		infp->def_termio.c_cc[3] = CKILL;
		infp->def_termio.c_cc[4] = 20;
		infp->def_termio.c_cc[5] = 2;
		infp->reserved1 = 0;  /* Must be Zero */
		infp->reserved2 = 0;
		infp->reserved3 = 0;
		infp->reserved4 = 0;
d1663 2
a1664 5
	bzero(&init, sizeof(struct init_packet));
	init.eye_catcher[0] = 0x12;
	init.eye_catcher[1] = 0x34;
	init.eye_catcher[2] = 0x56;
	init.eye_catcher[3] = 0x78;
d1682 2
a1683 2
		for (i=0; i<9; i++) {
			bzero(&evnt, sizeof(struct event_packet));
@


1.24
log
@Typos; Jonathan Gray
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.23 2003/10/05 20:27:48 miod Exp $ */
a163 3
struct envelope *bpp_wait;
unsigned int board_addr;

a186 4
#ifdef OLD_MAPPINGS
	ca->ca_vaddr = ca->ca_paddr;
#endif
	ca->ca_len = 0x10000; /* we know this. */
d188 1
a190 1
	board_addr = (unsigned int)ca->ca_vaddr;
d193 2
a194 1
		return (1);
@


1.23
log
@Kill vm_offset_t and vm_size_t, in favor of the [pv]addr_t and [pv]size_t
typedefs.
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.22 2003/08/15 20:32:14 tedu Exp $ */
d1169 1
a1169 1
		case CMD_PROCCESED:
d1171 1
a1171 1
			printf("CMD_PROCCESED Packet\n");
d1400 1
a1400 1
	pktp->command = CMD_PROCCESED;
d1604 1
a1604 1
		while (pktp->command != CMD_PROCCESED) {
@


1.22
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.21 2003/06/03 21:09:01 deraadt Exp $ */
d3 1
a3 1
 * Copyright (c) 1999 Steve Murphree, Jr. 
d27 1
a27 1
 */  
d153 1
a153 1
struct cfattach vx_ca = {       
d155 1
a155 1
};      
d159 2
a160 2
}; 
      
d173 1
a173 1
	if (unit >= vx_cd.cd_ndevs || 
d181 1
a181 1
int   
d189 1
a189 1
   
d211 1
a211 1
	
d217 3
a219 3
#endif 
	sc->sc_ipl = ca->ca_ipl; 
	sc->sc_vec = ca->ca_vec; 
d225 1
a225 1
		printf("%s: failed to create channel %d\n", sc->sc_dev.dv_xname, 
d411 1
a411 1
	if (unit >= vx_cd.cd_ndevs || 
d434 1
a434 1
#endif 
d445 1
a445 1
		tp = vxt->tty = ttymalloc();  
d509 1
a509 1
int 
d520 1
a520 1
	if (unit >= vx_cd.cd_ndevs || 
d533 1
a533 1
int 
d547 1
a547 1
	if (unit >= vx_cd.cd_ndevs || 
d582 1
a582 1
void 
d590 2
a591 2
	/* 
	 * If we already have a read_wakeup paket 
d612 1
a612 1
	 * to (*linesw[tp->t_line].l_rint)(c,tp); by 
d618 1
a618 1
int 
d630 1
a630 1
	if (unit >= vx_cd.cd_ndevs || 
d641 1
a641 1
int 
d656 1
a656 1
	if (unit >= vx_cd.cd_ndevs || 
d709 1
a709 1
}  
d725 1
a725 1
	if (unit >= vx_cd.cd_ndevs || 
d781 1
a781 1
		error = suser(p, 0); 
d971 1
a971 1
#endif 
d1011 1
a1011 1
	if (unit >= vx_cd.cd_ndevs || 
d1041 1
a1041 1
void 
d1046 1
a1046 1
	/* 
d1048 1
a1048 1
	 * characters in the read ring.  It will process one 
d1050 1
a1050 1
	 * and then return.  The characters may then 
d1069 1
a1069 1
#endif 
a1124 1
		
d1134 1
a1134 1
		/* if we are waiting on this packet, strore the info so bpp_send 
d1151 3
a1153 3
			printf("READW Packet\n");  
#endif 
			read_chars(sc, port);          
d1159 1
a1159 1
#endif 
d1164 2
a1165 2
			printf("EVENT Packet\n");  
#endif 
d1172 1
a1172 1
#endif 
d1177 2
a1178 2
			printf("Other packet 0x%x\n", cmd);  
#endif 
d1186 1
a1186 1
int 
a1226 1
		
a1229 1
		
a1232 1
		
a1235 1
		
d1298 8
a1305 9
	int i;
	short *d, *s;
	d = (short *) dest;
	s = (short *) src;
	for (i=0; i<(size/2); i++) {
		*d = *s;
		d++;
		s++;
	}
d1311 6
a1316 7
	int i;
	short *d;
	d = (short *) addr;
	for (i=0; i<(size/2); i++) {
		*d = 0;
		d++;
	}
d1358 1
a1358 1
get_free_envelope(sc) 
d1369 1
a1369 1
void 
d1381 1
a1381 1
void * 
d1393 1
a1393 1
void 
d1406 1
a1406 1
/* 
d1408 2
a1409 2
 * was hell to come by.  Getting this right from the 
 * Moto manual took *time*!  
d1411 1
a1411 1
int 
d1446 1
a1446 1
		while ((ipc_csr->ipc_tas & IPC_TAS_TAS)); 
d1473 1
a1473 1
		printf("%s: created channel %d\n", sc->sc_dev.dv_xname, 
d1479 1
a1479 1
			printf("%s: channel not valid\n", 
d1483 1
a1483 1
			printf("%s: invalid CSR command\n", 
d1487 1
a1487 1
			printf("%s: could not read channel structure\n", 
d1491 1
a1491 1
			printf("%s: could not write channel structure\n", 
d1495 1
a1495 1
			printf("%s: unknown IPC CSR command error 0x%x\n", 
d1524 1
a1524 1
int 
d1533 1
a1533 1
	struct vxsoftc *sc; 
a1557 1
	return;   
d1565 1
a1565 1
	unsigned long baseaddr; 
d1569 1
a1569 1
	/* 
d1573 1
a1573 1
	 * offset to the board address 
d1582 1
a1582 1
int 
d1607 1
a1607 1
#endif 
d1621 1
a1621 1
int 
d1651 1
a1651 1
#endif 
@


1.21
log
@terms 3 & 4 cleanup based on "terms" file
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.20 2002/04/28 15:17:09 miod Exp $ */
d781 1
a781 1
		error = suser(p->p_ucred, &p->p_acflag); 
@


1.20
log
@Use the prototypes defined via cdev_decl() macros, instead of rolling our
own; thus fix a lot of foo_open(), foo_close() and foo_ioctl() prototypes
in the process.
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.19 2002/03/14 03:15:57 millert Exp $ */
a5 1
 *   
d14 1
a14 4
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Dale Rahn.
 * 4. The name of the author may not be used to endorse or promote products
@


1.19
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.18 2002/03/14 01:26:39 millert Exp $ */
a33 1
#include <sys/conf.h>
d43 2
a45 1
#include <machine/autoconf.h>
a140 5
int  vxopen(dev_t dev, int flag, int mode, struct proc *p);
int  vxclose(dev_t dev, int flag, int mode, struct proc *p);
int  vxread(dev_t dev, struct uio *uio, int flag);
int  vxwrite(dev_t dev, struct uio *uio, int flag);
int  vxioctl(dev_t dev, int cmd, caddr_t data, int flag, struct proc *p);
a141 1
int  vxstop(struct tty *tp, int flag);
d718 1
a718 1
	int cmd;
@


1.18
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.17 2002/01/14 21:34:39 miod Exp $ */
d1315 2
a1316 2
	d = (short*) dest;
	s = (short*) src;
d1329 1
a1329 1
	d = (short*) addr;
d1398 1
a1398 1
void* 
d1594 1
a1594 1
	return ((void*)baseaddr);
@


1.17
log
@volatile police.
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.16 2001/12/22 18:45:35 smurph Exp $ */
d106 56
a161 56
void *get_next_envelope __P((struct envelope *thisenv));
struct envelope *get_status_head __P((struct vxsoftc *sc));
void set_status_head __P((struct vxsoftc *sc, void *envp));
struct packet *get_packet __P((struct vxsoftc *sc, struct envelope *thisenv));
struct envelope *find_status_packet __P((struct vxsoftc *sc, struct packet * pktp));

void read_wakeup __P((struct vxsoftc *sc, int port));
int  bpp_send __P((struct vxsoftc *sc, void *pkt, int wait_flag));

int  create_channels __P((struct vxsoftc *sc));
int  env_isvalid __P((struct envelope *thisenv));
void memcpy2 __P((void *dest, const void *src, size_t size));
void *get_free_envelope __P((struct vxsoftc *sc));
void put_free_envelope __P((struct vxsoftc *sc, void *envp));
void *get_free_packet __P((struct vxsoftc *sc));
void put_free_packet __P((struct vxsoftc *sc, void *pktp));

int  vx_init __P((struct vxsoftc *sc));
int  vx_event __P((struct vxsoftc *sc, struct packet *evntp));

void vx_unblock __P((struct tty *tp));
int  vx_ccparam __P((struct vxsoftc *sc, struct termios *par, int port));

int  vx_param __P((struct tty *tp, struct termios *t));
int  vx_intr __P((void * arg));
int  vx_sintr __P((struct vxsoftc *sc));
int  vx_poll __P((struct vxsoftc *sc, struct packet *wpktp));
void vx_overflow __P((struct vxsoftc *sc, int port, long *ptime, u_char *msg));
void vx_frame __P((struct vxsoftc *sc, int port));
void vx_break __P(( struct vxsoftc *sc, int port));
int  vx_mctl __P((dev_t dev, int bits, int how));

int  vxmatch __P((struct device *parent, void *self, void *aux));
void vxattach __P((struct device *parent, struct device *self, void *aux));

int  vxopen  __P((dev_t dev, int flag, int mode, struct proc *p));
int  vxclose __P((dev_t dev, int flag, int mode, struct proc *p));
int  vxread  __P((dev_t dev, struct uio *uio, int flag));
int  vxwrite __P((dev_t dev, struct uio *uio, int flag));
int  vxioctl __P((dev_t dev, int cmd, caddr_t data, int flag, struct proc *p));
void vxstart __P((struct tty *tp));
int  vxstop  __P((struct tty *tp, int flag));

void   vxputc __P((struct vxsoftc *sc, int port, u_char c));

struct tty * vxtty __P((dev_t));
short dtr_ctl __P((struct vxsoftc *, int, int));
short rts_ctl __P((struct vxsoftc *, int, int));
short flush_ctl __P((struct vxsoftc *, int, int));
u_short vxtspeed __P((int));
void read_chars __P((struct vxsoftc *, int));
void ccode __P((struct vxsoftc *, int, char));
void wzero __P((void *, size_t));
int create_free_queue __P((struct vxsoftc *));
void print_dump __P((struct vxsoftc *));
struct envelope *get_cmd_tail __P((struct vxsoftc *));
@


1.16
log
@Correct badvaddr() usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.15 2001/12/19 07:04:41 smurph Exp $ */
d598 1
a598 1
	volatile struct vx_info *vxt;
d636 2
a637 2
	volatile struct vx_info *vxt;
	volatile struct vxsoftc *sc;
@


1.15
log
@Introduce brdtyp and change what cputyp means.
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.14 2001/12/16 23:49:46 miod Exp $ */
d208 1
a208 3
	if (!badvaddr((unsigned)&vx_reg->ipc_cr, 1)) {
		if (ca->ca_vec & 0x03) {
			printf("xvt: bad vector 0x%x\n", ca->ca_vec);
a209 1
		}
a210 3
	} else {
		return (0);
	}      
@


1.15.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.17 2002/01/14 21:34:39 miod Exp $ */
d208 3
a210 1
	if (badvaddr((unsigned)&vx_reg->ipc_cr, 1))
d212 1
d214 3
d604 1
a604 1
	struct vx_info *volatile vxt;
d642 2
a643 2
	struct vx_info *volatile vxt;
	struct vxsoftc *volatile sc;
@


1.15.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.15.2.1 2002/01/31 22:55:18 niklas Exp $ */
d34 1
d44 1
a45 2
#include <machine/conf.h>
#include <machine/cpu.h>
d106 56
a161 50
void *get_next_envelope(struct envelope *thisenv);
struct envelope *get_status_head(struct vxsoftc *sc);
void set_status_head(struct vxsoftc *sc, void *envp);
struct packet *get_packet(struct vxsoftc *sc, struct envelope *thisenv);
struct envelope *find_status_packet(struct vxsoftc *sc, struct packet * pktp);

void read_wakeup(struct vxsoftc *sc, int port);
int  bpp_send(struct vxsoftc *sc, void *pkt, int wait_flag);

int  create_channels(struct vxsoftc *sc);
int  env_isvalid(struct envelope *thisenv);
void memcpy2(void *dest, const void *src, size_t size);
void *get_free_envelope(struct vxsoftc *sc);
void put_free_envelope(struct vxsoftc *sc, void *envp);
void *get_free_packet(struct vxsoftc *sc);
void put_free_packet(struct vxsoftc *sc, void *pktp);

int  vx_init(struct vxsoftc *sc);
int  vx_event(struct vxsoftc *sc, struct packet *evntp);

void vx_unblock(struct tty *tp);
int  vx_ccparam(struct vxsoftc *sc, struct termios *par, int port);

int  vx_param(struct tty *tp, struct termios *t);
int  vx_intr(void * arg);
int  vx_sintr(struct vxsoftc *sc);
int  vx_poll(struct vxsoftc *sc, struct packet *wpktp);
void vx_overflow(struct vxsoftc *sc, int port, long *ptime, u_char *msg);
void vx_frame(struct vxsoftc *sc, int port);
void vx_break( struct vxsoftc *sc, int port);
int  vx_mctl(dev_t dev, int bits, int how);

int  vxmatch(struct device *parent, void *self, void *aux);
void vxattach(struct device *parent, struct device *self, void *aux);

void vxstart(struct tty *tp);

void   vxputc(struct vxsoftc *sc, int port, u_char c);

struct tty * vxtty(dev_t);
short dtr_ctl(struct vxsoftc *, int, int);
short rts_ctl(struct vxsoftc *, int, int);
short flush_ctl(struct vxsoftc *, int, int);
u_short vxtspeed(int);
void read_chars(struct vxsoftc *, int);
void ccode(struct vxsoftc *, int, char);
void wzero(void *, size_t);
int create_free_queue(struct vxsoftc *);
void print_dump(struct vxsoftc *);
struct envelope *get_cmd_tail(struct vxsoftc *);
d724 1
a724 1
	u_long cmd;
d1315 2
a1316 2
	d = (short *) dest;
	s = (short *) src;
d1329 1
a1329 1
	d = (short *) addr;
d1398 1
a1398 1
void * 
d1594 1
a1594 1
	return ((void *)baseaddr);
@


1.14
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.12 2001/10/28 00:57:38 miod Exp $ */
a199 2
	if (cputyp != CPU_187)
		return 0;
@


1.13
log
@Support for MVME197 completed.  Fix SPL defs.
@
text
@d200 2
d210 7
a216 1
	if (badvaddr((unsigned)&vx_reg->ipc_cr, 1))
d218 1
a218 1
	return (1);
@


1.12
log
@Let 188-only kernels compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.11 2001/08/31 08:18:24 miod Exp $ */
a199 2
	if (cputyp != CPU_187)
		return 0;
d208 1
a208 7
	if (!badvaddr((unsigned)&vx_reg->ipc_cr, 1)) {
		if (ca->ca_vec & 0x03) {
			printf("xvt: bad vector 0x%x\n", ca->ca_vec);
			return (0);
		}
		return (1);
	} else {
d210 1
a210 1
	}      
@


1.11
log
@I should get more sleep.
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.10 2001/08/31 01:05:44 miod Exp $ */
d50 1
a55 1
#include <mvme88k/dev/vme.h>
@


1.10
log
@Clean the DDB entry procedure for all console drivers, and honour
db_console setting.
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.9 2001/08/26 02:37:07 miod Exp $ */
d59 1
a59 1
#include <ddb/db_variables.h>
@


1.9
log
@Add prototypes, fix compilation warnings, random style fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.8 2001/06/27 05:44:49 nate Exp $ */
d46 1
d58 4
a61 1
#include <machine/psl.h>
a66 1
#define DEBUG_KERN 1
d1301 3
a1303 2
#ifdef DEBUG_KERN
	Debugger();
@


1.8
log
@recieve -> receive
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.7 2001/06/25 00:43:14 mickey Exp $ */
d42 2
d46 1
d48 1
d50 1
a50 1
#include <sys/syslog.h>
d53 2
a54 2
   #include <mvme88k/dev/pcctworeg.h>
   #include <mvme88k/dev/vme.h>
d61 1
a61 1
   #undef DEBUG
d146 13
a158 1
static void   vxputc __P((struct vxsoftc *sc, int port, u_char c));
a170 1
extern int cputyp;
d285 3
a287 3
struct vxsoftc *sc;
int port;
int on;
d307 3
a309 3
struct vxsoftc *sc;
int port;
int which;
d827 1
a827 1
static void
d841 2
a842 1
u_short vxtspeed(speed)
d1342 1
a1342 1
struct vxsoftc *sc;
a1729 1

@


1.7
log
@cold is in systm now
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.6 2001/03/09 05:44:39 smurph Exp $ */
d899 1
a899 1
			/* disconnect, drop RTS DTR stop reciever */
@


1.6
log
@kernel will compile with -Werror.  Added intr.h
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.5 2001/03/07 23:45:52 miod Exp $ */
a95 2

extern int cold;  /* var in autoconf.c that is set in machdep.c when booting */
@


1.5
log
@Fix interrupt handler registration and prototypes.
While there, some warning hunting.
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.4 2001/01/25 03:50:48 todd Exp $ */
d62 10
a71 10
   struct   tty *tty;
   u_char   vx_swflags;
   int      vx_linestatus;
   int      open;
   int      waiting;
   u_char   vx_consio;
   u_char   vx_speed;
   u_char   read_pending;
   struct   wring  *wringp;
   struct   rring  *rringp;
d75 12
a86 12
   struct device     sc_dev;
   struct evcnt      sc_intrcnt;
   struct evcnt      sc_sintrcnt;
   struct vx_info  sc_info[9];
   struct vxreg    *vx_reg;
   unsigned int      board_addr;
   struct channel    *channel;
   char              channel_number;
   struct packet     sc_bppwait_pkt;
   void              *sc_bppwait_pktp;
   struct intrhand   sc_ih_c;
   struct intrhand   sc_ih_s;
d88 1
a88 1
   struct vme2reg    *sc_vme2;
d90 5
a94 5
   int               sc_ipl;
   int               sc_vec;
   int               sc_flags;
   struct envelope   *elist_head, *elist_tail;
   struct packet     *plist_head, *plist_tail;
d111 1
d147 1
a147 1
   sizeof(struct vxsoftc), vxmatch, vxattach
d151 1
a151 1
   NULL, "vx", DV_TTY, 0
d162 1
a162 1
dev_t dev;
d164 9
a172 9
   int unit, port;
   struct vxsoftc *sc;
   unit = VX_UNIT(dev);
   if (unit >= vx_cd.cd_ndevs || 
       (sc = (struct vxsoftc *) vx_cd.cd_devs[unit]) == NULL) {
      return (NULL);
   }
   port = VX_PORT(dev);
   return sc->sc_info[port].tty;
d177 3
a179 3
struct device *parent;
void *self;
void *aux;
d181 5
a185 5
   struct vxreg *vx_reg;
   struct confargs *ca = aux;

   if (cputyp != CPU_187)
      return 0;
d187 1
a187 1
   ca->ca_vaddr = ca->ca_paddr;
d189 14
a202 14
   ca->ca_len = 0x10000; /* we know this. */
	ca->ca_ipl = 3; /* we need interrupts for this board to work */
   
   vx_reg = (struct vxreg *)ca->ca_vaddr;
   board_addr = (unsigned int)ca->ca_vaddr;
   if (!badvaddr(&vx_reg->ipc_cr, 1)){
      if (ca->ca_vec & 0x03) {
         printf("xvt: bad vector 0x%x\n", ca->ca_vec);
         return (0);
      }
      return (1);
   } else {
      return (0);
   }      
d207 10
a216 10
struct device *parent;
struct device *self;
void *aux;
{
   struct vxsoftc *sc = (struct vxsoftc *)self;
   struct confargs *ca = aux;

   /* set up dual port memory and registers and init*/
   sc->vx_reg = (struct vxreg *)ca->ca_vaddr;
   sc->channel = (struct channel *)(ca->ca_vaddr + 0x0100);
d218 1
a218 1
   sc->sc_vme2 = ca->ca_master;
d220 21
a240 5
   sc->sc_ipl = ca->ca_ipl; 
   sc->sc_vec = ca->ca_vec; 
   sc->board_addr = (unsigned int)ca->ca_vaddr;
   
   printf("\n");
d242 2
a243 18
   if (create_channels(sc)) {
      printf("%s: failed to create channel %d\n", sc->sc_dev.dv_xname, 
             sc->channel->channel_number);
      return;
   }
   if (vx_init(sc)){
      printf("%s: failed to initialize\n", sc->sc_dev.dv_xname);
      return;
   }
   
   /* enable interrupts */
   sc->sc_ih_c.ih_fn = vx_intr;
   sc->sc_ih_c.ih_arg = sc;
   sc->sc_ih_c.ih_wantframe = 0;
   sc->sc_ih_c.ih_ipl = ca->ca_ipl;
   
   vmeintr_establish(ca->ca_vec, &sc->sc_ih_c);
   evcnt_attach(&sc->sc_dev, "intr", &sc->sc_intrcnt);
d250 18
a267 18
   struct vxsoftc *sc;
   int port;
   int on;
{
   struct packet pkt;
   bzero(&pkt, sizeof(struct packet));
   pkt.command = CMD_IOCTL;
   pkt.ioctl_cmd_l = IOCTL_TCXONC;
   pkt.command_pipe_number = sc->channel_number;
   pkt.status_pipe_number = sc->channel_number;
   pkt.device_number = port;
   if (on) {
      pkt.ioctl_arg_l = 6;  /* assert DTR */
   } else {
      pkt.ioctl_arg_l = 7;  /* negate DTR */
   }
   bpp_send(sc, &pkt, NOWAIT);
   return (pkt.error_l);
d272 18
a289 18
   struct vxsoftc *sc;
   int port;
   int on;
{
   struct packet pkt;
   bzero(&pkt, sizeof(struct packet));
   pkt.command = CMD_IOCTL;
   pkt.ioctl_cmd_l = IOCTL_TCXONC;
   pkt.command_pipe_number = sc->channel_number;
   pkt.status_pipe_number = sc->channel_number;
   pkt.device_number = port;
   if (on) {
      pkt.ioctl_arg_l = 4;  /* assert RTS */
   } else {
      pkt.ioctl_arg_l = 5;  /* negate RTS */
   }
   bpp_send(sc, &pkt, NOWAIT);
   return (pkt.error_l);
d294 14
a307 14
   struct vxsoftc *sc;
   int port;
   int which;
{
   struct packet pkt;
   bzero(&pkt, sizeof(struct packet));
   pkt.command = CMD_IOCTL;
   pkt.ioctl_cmd_l = IOCTL_TCFLSH;
   pkt.command_pipe_number = sc->channel_number;
   pkt.status_pipe_number = sc->channel_number;
   pkt.device_number = port;
   pkt.ioctl_arg_l = which; /* 0=input, 1=output, 2=both */
   bpp_send(sc, &pkt, NOWAIT);
   return (pkt.error_l);
d311 17
a327 17
dev_t dev;
int bits;
int how;
{
   int s, unit, port;
   struct vxsoftc *sc;
   struct vx_info *vxt;
   u_char msvr;
   
   unit = VX_UNIT(dev);
   port = VX_PORT(dev);
   sc = (struct vxsoftc *) vx_cd.cd_devs[unit];
   vxt = &sc->sc_info[port];
	
   s = splvx();
   switch (how) {
   case DMSET:
d330 1
a330 1
         vxt->vx_linestatus |= TIOCM_RTS;
d333 2
a334 2
         
         vxt->vx_linestatus &= ~TIOCM_RTS;
d336 1
a336 1
		if( bits & TIOCM_DTR) {
d338 1
a338 1
         vxt->vx_linestatus |= TIOCM_DTR;
d341 1
a341 1
         vxt->vx_linestatus &= ~TIOCM_DTR;
d344 2
a345 2
   case DMBIC:
      if ( bits & TIOCM_RTS) {
d347 3
a349 3
         vxt->vx_linestatus &= ~TIOCM_RTS;
      }
      if ( bits & TIOCM_DTR) {
d351 3
a353 3
         vxt->vx_linestatus &= ~TIOCM_DTR;
      }
      break;
d355 2
a356 2
   case DMBIS:
      if ( bits & TIOCM_RTS) {
d358 3
a360 3
         vxt->vx_linestatus |= TIOCM_RTS;
      }
      if ( bits & TIOCM_DTR) {
d362 3
a364 3
         vxt->vx_linestatus |= TIOCM_DTR;
      }
      break;
d366 1
a366 1
   case DMGET:
d369 1
a369 1
		if( msvr & TIOCM_DSR) {
d372 1
a372 1
		if( msvr & TIOCM_CD) {
d375 1
a375 1
		if( msvr & TIOCM_CTS) {
d378 1
a378 1
		if( msvr & TIOCM_DTR) {
d381 1
a381 1
		if( msvr & TIOCM_RTS) {
d384 5
a388 5
      break;
   }
   
   splx(s);
   bits = 0;
d394 1
a394 1
   return (bits);
d398 19
a416 11
dev_t dev;
int flag;
int mode;
struct proc *p;
{
   int s, unit, port;
   struct vx_info *vxt;
   struct vxsoftc *sc;
   struct tty *tp;
   struct open_packet opkt;
   u_short code;
d418 15
a432 23
   unit = VX_UNIT(dev);
   port = VX_PORT(dev);
   
   if (unit >= vx_cd.cd_ndevs || 
       (sc = (struct vxsoftc *) vx_cd.cd_devs[unit]) == NULL) {
      return (ENODEV);
   }
   
   /*flush_ctl(sc, port, 2);*/
   
   bzero(&opkt, sizeof(struct packet));
   opkt.eye_catcher[0] = 0x33;
   opkt.eye_catcher[1] = 0x33;
   opkt.eye_catcher[2] = 0x33;
   opkt.eye_catcher[3] = 0x33;
   opkt.command_pipe_number = sc->channel_number;
   opkt.status_pipe_number = sc->channel_number;
   opkt.command = CMD_OPEN;
   opkt.device_number = port;
   
   bpp_send(sc, &opkt, WAIT_POLL);
   
   if (opkt.error_l) {
d434 2
a435 2
      printf("unit %d, port %d, ", unit, port);
      printf("error = %d\n", opkt.error_l);
d437 4
a440 4
      return (ENODEV);
   }
   
   code = opkt.event_code;
d442 52
a493 11
   
   vxt = &sc->sc_info[port];
   if (vxt->tty) {
      tp = vxt->tty;
   } else {
      tp = vxt->tty = ttymalloc();  
   }
   
   /* set line status */
   tp->t_state |= TS_CARR_ON;
   if (code & E_DCD) {
d495 4
a498 37
      vxt->vx_linestatus |= TIOCM_CD;
   }
   if (code & E_DSR) {
      vxt->vx_linestatus |= TIOCM_DSR;
   }
   if (code & E_CTS) {
      vxt->vx_linestatus |= TIOCM_CTS;
   }
   
   tp->t_oproc = vxstart;
   tp->t_param = vx_param;
   tp->t_dev = dev;
   
   if ((tp->t_state & TS_ISOPEN) == 0) {
      tp->t_state |= TS_WOPEN;
      ttychars(tp);
      if (tp->t_ispeed == 0) {
         /*
          * only when cleared do we reset to defaults.
          */
         tp->t_iflag = TTYDEF_IFLAG;
         tp->t_oflag = TTYDEF_OFLAG;
         tp->t_lflag = TTYDEF_LFLAG;
         tp->t_ispeed = tp->t_ospeed = vxtdefaultrate;
         tp->t_cflag = TTYDEF_CFLAG;
      }
      /*
       * do these all the time
       */
      if (vxt->vx_swflags & TIOCFLAG_CLOCAL)
         tp->t_cflag |= CLOCAL;
      if (vxt->vx_swflags & TIOCFLAG_CRTSCTS)
         tp->t_cflag |= CRTSCTS;
      if (vxt->vx_swflags & TIOCFLAG_MDMBUF)
         tp->t_cflag |= MDMBUF;
      vx_param(tp, &tp->t_termios);
      ttsetwater(tp);
d500 9
a508 17
      (void)vx_mctl(dev, TIOCM_DTR | TIOCM_RTS, DMSET);
      
      tp->t_state |= TS_CARR_ON;
   } else if (tp->t_state & TS_XCLUDE && p->p_ucred->cr_uid != 0) {
      splx(s);
      return (EBUSY);
   }

   /*
    * Reset the tty pointer, as there could have been a dialout
    * use of the tty with a dialin open waiting.
    */
   tp->t_dev = dev;
   sc->sc_info[port].open = 1;
   read_wakeup(sc, port);
   splx(s);
   return ((*linesw[tp->t_line].l_open)(dev, tp));
d513 2
a514 2
struct tty *tp;
struct termios *t;
d516 17
a532 17
   int unit, port;
   struct vxsoftc *sc;
   dev_t dev;

   dev = tp->t_dev;
   unit = VX_UNIT(dev);
   if (unit >= vx_cd.cd_ndevs || 
       (sc = (struct vxsoftc *) vx_cd.cd_devs[unit]) == NULL) {
      return (ENODEV);
   }
   port = VX_PORT(dev);
   tp->t_ispeed = t->c_ispeed;
   tp->t_ospeed = t->c_ospeed;
   tp->t_cflag = t->c_cflag;
   vx_ccparam(sc, t, port);
   vx_unblock(tp);
   return 0;
d537 17
a553 17
dev_t dev;
int flag;
int mode;
struct proc *p;
{
   int unit, port;
   struct tty *tp;
   struct vx_info *vxt;
   struct vxsoftc *sc;
   int s;
   struct close_packet cpkt;
   unit = VX_UNIT(dev);
   if (unit >= vx_cd.cd_ndevs || 
       (sc = (struct vxsoftc *) vx_cd.cd_devs[unit]) == NULL) {
      return (ENODEV);
   }
   port = VX_PORT(dev);
d555 6
a560 6
   
   vxt = &sc->sc_info[port];
   tp = vxt->tty;
   (*linesw[tp->t_line].l_close)(tp, flag);
   
   if((tp->t_cflag & HUPCL) != 0) {
d564 18
a581 18
	
   s = splvx();
   
   bzero(&cpkt, sizeof(struct packet));
   cpkt.eye_catcher[0] = 0x55;
   cpkt.eye_catcher[1] = 0x55;
   cpkt.eye_catcher[2] = 0x55;
   cpkt.eye_catcher[3] = 0x55;
   cpkt.command_pipe_number = sc->channel_number;
   cpkt.status_pipe_number = sc->channel_number;
   cpkt.command = CMD_CLOSE;
   cpkt.device_number = port;
   
   bpp_send(sc, &cpkt, NOWAIT);
   splx(s);
   ttyclose(tp);
   sc->sc_info[port].open = 0;
   return (0);
d586 2
a587 2
struct vxsoftc *sc;
int port;
d589 29
a617 29
   struct read_wakeup_packet rwp;
   volatile struct vx_info *vxt;
   vxt = &sc->sc_info[port];
   /* 
    * If we already have a read_wakeup paket 
    * for this port, do nothing.
    */
   if (vxt->read_pending) {
      return;
   } else {
      vxt->read_pending = 1;
   }

   bzero(&rwp, sizeof(struct packet));
   rwp.eye_catcher[0] = 0x11;
   rwp.eye_catcher[1] = 0x11;
   rwp.eye_catcher[2] = 0x11;
   rwp.eye_catcher[3] = 0x11;
   rwp.command_pipe_number = sc->channel_number;
   rwp.status_pipe_number = sc->channel_number;
   rwp.command = CMD_READW;
   rwp.device_number = port;
   
   /*
    * Do not wait.  Characters will be transferred
    * to (*linesw[tp->t_line].l_rint)(c,tp); by 
    * vx_intr()  (IPC will notify via interrupt)
    */
   bpp_send(sc, &rwp, NOWAIT);
d622 19
a640 19
dev_t dev;
struct uio *uio;
int flag;
{
   int unit, port;
   struct tty *tp;
   volatile struct vx_info *vxt;
   volatile struct vxsoftc *sc;

   unit = VX_UNIT(dev);
   if (unit >= vx_cd.cd_ndevs || 
       (sc = (struct vxsoftc *) vx_cd.cd_devs[unit]) == NULL) {
      return (ENODEV);
   }
   port = VX_PORT(dev);
   vxt = &sc->sc_info[port];
   tp = vxt->tty;
   if (!tp) return ENXIO;
   return ((*linesw[tp->t_line].l_read)(tp, uio, flag));
d645 17
a661 37
dev_t dev;
struct uio *uio;
int flag;
{
   int unit, port;
   struct tty *tp;
   struct vx_info *vxt;
   struct vxsoftc *sc;
   struct wring *wp;
   struct write_wakeup_packet wwp;
   u_short get, put;
   
   unit = VX_UNIT(dev);
   if (unit >= vx_cd.cd_ndevs || 
       (sc = (struct vxsoftc *) vx_cd.cd_devs[unit]) == NULL) {
      return (ENODEV);
   }
   
   port = VX_PORT(dev);
   vxt = &sc->sc_info[port];
   tp = vxt->tty;
   if (!tp) return ENXIO;
   
   wp = sc->sc_info[port].wringp;
   get = wp->get;
   put = wp->put;
   
   if ((put + 1) == get) {
      bzero(&wwp, sizeof(struct packet));
      wwp.eye_catcher[0] = 0x22;
      wwp.eye_catcher[1] = 0x22;
      wwp.eye_catcher[2] = 0x22;
      wwp.eye_catcher[3] = 0x22;
      wwp.command_pipe_number = sc->channel_number;
      wwp.status_pipe_number = sc->channel_number;
      wwp.command = CMD_WRITEW;
      wwp.device_number = port;
d663 48
a710 7
      bpp_send(sc, &wwp, WAIT_POLL);
      
      if (wwp.error_l) {
         return (ENXIO);
      }
   }
   return ((*linesw[tp->t_line].l_write)(tp, uio, flag));
d715 38
a752 38
dev_t dev;
int cmd;
caddr_t data;
int flag;
struct proc *p;
{
   int error;
   int unit, port;
   struct tty *tp;
   struct vx_info *vxt;
   struct vxsoftc *sc;
   unit = VX_UNIT(dev);
   if (unit >= vx_cd.cd_ndevs || 
       (sc = (struct vxsoftc *) vx_cd.cd_devs[unit]) == NULL) {
      return (ENODEV);
   }
   port = VX_PORT(dev);
   vxt = &sc->sc_info[port];
   tp = vxt->tty;
   if (!tp)
      return ENXIO;

   error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
   if (error >= 0)
      return (error);

   error = ttioctl(tp, cmd, data, flag, p);
   if (error >= 0)
      return (error);

   switch (cmd) {
   case TIOCSBRK:
      /* */
      break;

   case TIOCCBRK:
      /* */
      break;
d754 1
a754 1
   case TIOCSDTR:
d756 1
a756 1
      break;
d758 1
a758 1
   case TIOCCDTR:
d760 1
a760 1
      break;
d762 1
a762 1
   case TIOCMSET:
d764 1
a764 1
      break;
d766 1
a766 1
   case TIOCMBIS:
d768 1
a768 1
      break;
d770 1
a770 1
   case TIOCMBIC:
d772 1
a772 1
      break;
d774 1
a774 1
   case TIOCMGET:
d776 1
a776 1
      break;
d778 1
a778 1
   case TIOCGFLAGS:
d782 1
a782 1
   case TIOCSFLAGS:
d785 1
a785 1
			return(EPERM); 
d789 2
a790 2
			(TIOCFLAG_SOFTCAR | TIOCFLAG_CLOCAL | TIOCFLAG_CRTSCTS);
      break;
d792 4
a795 4
   default:
      return (ENOTTY);
   }
   return 0;
d800 2
a801 2
struct tty *tp;
int flag;
d803 1
a803 1
   int s;
d806 4
a809 4
   if (tp->t_state & TS_BUSY) {
      if ((tp->t_state & TS_TTSTOP) == 0)
         tp->t_state |= TS_FLUSH;
   }
d811 1
a811 1
   return 0;
d816 10
a825 10
struct vxsoftc *sc;
int port;
u_char c;
{
   struct wring *wp;
   
   wp = sc->sc_info[port].wringp;
   wp->data[wp->put++ & (WRING_BUF_SIZE-1)] = c;
   wp->put &= (WRING_BUF_SIZE-1);
   return;
d829 1
a829 1
int speed;
d831 53
a883 53
   switch (speed) {
   case B0:
      return VB0;
      break;
   case B50:
      return VB50;
      break;
   case B75:
      return VB75;
      break;
   case B110:
      return VB110;
      break;
   case B134:
      return VB134;
      break;
   case B150:
      return VB150;
      break;
   case B200:
      return VB200;
      break;
   case B300:
      return VB300;
      break;
   case B600:
      return VB600;
      break;
   case B1200:
      return VB1200;
      break;
   case B1800:
      return VB1800;
      break;
   case B2400:
      return VB2400;
      break;
   case B4800:
      return VB4800;
      break;
   case B9600:
      return VB9600;
      break;
   case B19200:
      return VB19200;
      break;
   case B38400:
      return VB38400;
      break;
   default:
      return VB9600;
      break;
   }
d888 32
a919 32
struct vxsoftc *sc;
struct termios *par;
int port;
{
   int imask=0, s;
   int cflag /*, iflag, oflag, lflag*/;
   struct ioctl_a_packet pkt;
   bzero(&pkt, sizeof(struct packet));
   
   if (par->c_ospeed == 0) { 
      s = splvx();
      /* dont kill the console */
      if(sc->sc_info[port].vx_consio == 0) {
         /* disconnect, drop RTS DTR stop reciever */
         rts_ctl(sc, port, 0);
         dtr_ctl(sc, port, 0);
      }
      splx(s);
      return (0xff);
   }
   
   pkt.command = CMD_IOCTL;
   pkt.ioctl_cmd_l = IOCTL_TCGETA;
   pkt.command_pipe_number = sc->channel_number;
   pkt.status_pipe_number = sc->channel_number;
   pkt.device_number = port;
   bpp_send(sc, &pkt, WAIT_POLL);
   
   cflag = pkt.c_cflag;
   cflag |= vxtspeed(par->c_ospeed);
   
   switch (par->c_cflag & CSIZE) {
d935 49
a983 32
   }
   
   if (par->c_cflag & PARENB) cflag |= VPARENB; else cflag &= ~VPARENB;
   if (par->c_cflag & PARODD) cflag |= VPARODD; else cflag &= ~VPARODD;
   if (par->c_cflag & CREAD) cflag |= VCREAD; else cflag &= ~VCREAD;
   if (par->c_cflag & CLOCAL) cflag |= VCLOCAL; else cflag &= ~VCLOCAL;
   if (par->c_cflag & HUPCL) cflag |= VHUPCL; else cflag &= ~VHUPCL;
   /*
   if (par->c_iflag & BRKINT) iflag |= VBRKINT; else iflag &= ~VBRKINT;
   if (par->c_iflag & ISTRIP) iflag |= VISTRIP; else iflag &= ~VISTRIP;
   if (par->c_iflag & ICRNL) iflag |= VICRNL; else iflag &= ~VICRNL;
   if (par->c_iflag & IXON) iflag |= VIXON; else iflag &= ~VIXON;
   if (par->c_iflag & IXANY) iflag |= VIXANY; else iflag &= ~VIXANY;
   if (par->c_oflag & OPOST) oflag |= VOPOST; else oflag &= ~VOPOST;
   if (par->c_oflag & ONLCR) oflag |= VONLCR; else oflag &= ~VONLCR;
   if (par->c_oflag & OXTABS) oflag |= VOXTABS; else oflag &= ~VOXTABS;
   if (par->c_lflag & ECHO) lflag |= VECHO; else lflag &= ~VECHO;
   if (par->c_lflag & ECHOE) lflag |= VECHOE; else lflag &= ~VECHOE;
   if (par->c_lflag & ICANON) lflag |= VICANON; else lflag &= ~VICANON;
   if (par->c_lflag & ISIG) lflag |= VISIG; else lflag &= ~VISIG;
   */
   pkt.command = CMD_IOCTL;
   pkt.ioctl_cmd_l = IOCTL_TCSETA;
   pkt.command_pipe_number = sc->channel_number;
   pkt.status_pipe_number = sc->channel_number;
   pkt.device_number = port;
   pkt.c_cflag = cflag;
/*
   pkt.c_iflag = iflag;
   pkt.c_oflag = oflag;
   pkt.c_lflag = lflag;
 */
d985 2
a986 2
   bpp_send(sc, &pkt, WAIT_POLL);
   return imask;
d991 1
a991 1
struct tty *tp;
d993 3
a995 3
   tp->t_state &= ~TS_FLUSH;
   if (tp->t_outq.c_cc != 0)
      vxstart(tp);
d1000 1
a1000 1
struct tty *tp;
d1002 38
a1039 38
   dev_t dev;
   struct vxsoftc *sc;
   struct wring *wp;
   int cc, port, unit, s, cnt, i;
   u_short get, put;
   char buffer[WRING_BUF_SIZE];

   dev = tp->t_dev;
   port = VX_PORT(dev);
   unit = VX_UNIT(dev);
   if (unit >= vx_cd.cd_ndevs || 
       (sc = (struct vxsoftc *) vx_cd.cd_devs[unit]) == NULL) {
      return;
   }
   
   if ((tp->t_state & TS_ISOPEN) == 0)
      return;
	
   s = splvx();
   if ((tp->t_state & (TS_TIMEOUT | TS_BUSY | TS_TTSTOP | TS_FLUSH)) == 0) {
      tp->t_state |= TS_BUSY;
      wp = sc->sc_info[port].wringp;
      get = wp->get;
      put = wp->put;
      cc = tp->t_outq.c_cc;
      while (cc > 0) {
         cnt = min(WRING_BUF_SIZE, cc);
         cnt = q_to_b(&tp->t_outq, buffer, cnt);
         buffer[cnt] = 0;
         for (i=0; i<cnt; i++) {
            vxputc(sc, port, buffer[i]);
         }
         cc -= cnt;
      }
      tp->t_state &= ~TS_BUSY;
   }
   splx(s);
   return;
d1044 2
a1045 2
struct vxsoftc *sc;
int port;
d1047 20
a1066 20
   /* 
    * This routine is called by vx_intr() when there are
    * characters in the read ring.  It will process one 
    * cooked line, put the chars in the line disipline ring,
    * and then return.  The characters may then 
    * be read by vxread.
    */
   struct vx_info *vxt;
   struct rring *rp;
   struct tty *tp;
   u_short get, put;
   int frame_count, i, open;
   char c;
   
   vxt = &sc->sc_info[port];
   tp = vxt->tty;
   rp = vxt->rringp;
   open = vxt->open;
   get = rp->get;
   put = rp->put;
d1068 2
a1069 2
   printf("read_chars() get=%d, put=%d ", get, put);
   printf("open = %d ring at 0x%x\n", open, rp);
d1071 23
a1093 23
   while (get != put) {
      frame_count = rp->data[rp->get++ & (RRING_BUF_SIZE - 1)];
      rp->get &= (RRING_BUF_SIZE - 1);
      for (i=0; i<frame_count; i++) {
         c = rp->data[rp->get++ & (RRING_BUF_SIZE - 1)];
         rp->get &= (RRING_BUF_SIZE - 1);
         if (open) 
            (*linesw[tp->t_line].l_rint)(c,tp);
      }
      c = rp->data[rp->get++ & (RRING_BUF_SIZE - 1)];
      rp->get &= (RRING_BUF_SIZE - 1);
      if (!(c & DELIMITER)) {
         vx_frame (sc, port);
         break;
      } else {
         break;
      }
      get = rp->get;
      put = rp->put;
   }
   vxt->read_pending = 0;
   read_wakeup(sc, port);
   return;
d1098 10
a1107 10
struct vxsoftc *sc;
int port;
char c;
{
   struct vx_info *vxt;
   struct tty *tp;
   tp = vxt->tty;
   vxt = &sc->sc_info[port];
   tp = vxt->tty;
   (*linesw[tp->t_line].l_rint)(c,tp);
d1115 3
a1117 4

   struct envelope *envp, *next_envp;
   struct packet *pktp, pkt;
   int valid;
d1120 1
d1122 1
a1122 1
   struct vme2reg *vme2 = (struct vme2reg *)sc->sc_vme2;
d1124 4
a1127 3
   if (vme2->vme2_vbr & VME2_SYSFAIL){
      /* do something... print_dump(sc); */
   }
d1129 23
a1151 23
   if (!cold) sc->sc_intrcnt.ev_count++;
   
   while (env_isvalid(get_status_head(sc))) {
      pktp = get_packet(sc, get_status_head(sc));
      valid = env_isvalid(get_status_head(sc));
      cmd = pktp->command;
      port = pktp->device_number;
      /* if we are waiting on this packet, strore the info so bpp_send 
         can process the packet  */
      if (sc->sc_bppwait_pktp == pktp)
         memcpy2(&sc->sc_bppwait_pkt, pktp, sizeof(struct packet));
      
      memcpy2(&pkt, pktp, sizeof(struct packet));
      next_envp = get_next_envelope(get_status_head(sc));
      envp = get_status_head(sc);
      /* return envelope and packet to the free queues */
      put_free_envelope(sc, envp);
      put_free_packet(sc, pktp);
      /* mark new status pipe head pointer */
      set_status_head(sc, next_envp);
      /* if it was valid, process packet */
      switch (cmd) {
      case CMD_READW:
d1153 1
a1153 1
         printf("READW Packet\n");  
d1155 4
a1158 4
         read_chars(sc, port);          
         return 1;
         break;
      case CMD_WRITEW:
d1160 1
a1160 1
         printf("WRITEW Packet\n");  /* Still don't know XXXsmurph */
d1162 3
a1164 3
         return 1;
         break;
      case CMD_EVENT:
d1166 1
a1166 1
         printf("EVENT Packet\n");  
d1168 4
a1171 4
         vx_event(sc, &pkt);
         return 1;
         break;
      case CMD_PROCCESED:
d1173 1
a1173 1
         printf("CMD_PROCCESED Packet\n");
d1175 3
a1177 3
         return 1;
         break;
      default:
d1179 1
a1179 1
         printf("Other packet 0x%x\n", cmd);  
d1181 5
a1185 5
         return 1;
         break;
      }
   }
   return 1;
d1190 2
a1191 2
struct vxsoftc *sc;
struct packet *evntp;
d1193 64
a1256 60
   u_short code = evntp->event_code;
   struct event_packet evnt;
   struct vx_info *vxt;
   
   vxt = &sc->sc_info[evntp->device_number];
   
   if (code & E_INTR) {
      ccode(sc, evntp->device_number, CINTR);
   }
   if (code & E_QUIT) {
      ccode(sc, evntp->device_number, CQUIT);
   }
   if (code & E_HUP) {
      rts_ctl(sc, evntp->device_number, 0);
      dtr_ctl(sc, evntp->device_number, 0);
   }
   if (code & E_DCD) {
      vxt->vx_linestatus |= TIOCM_CD;
   }
   if (code & E_DSR) {
      vxt->vx_linestatus |= TIOCM_DSR;
   }
   if (code & E_CTS) {
      vxt->vx_linestatus |= TIOCM_CTS;
   }
   if (code & E_LOST_DCD) {
      vxt->vx_linestatus &= ~TIOCM_CD;
   }
   if (code & E_LOST_DSR) {
      vxt->vx_linestatus &= ~TIOCM_DSR;
   }
   if (code & E_LOST_CTS) {
      vxt->vx_linestatus &= ~TIOCM_CTS;
   }
   if (code & E_PR_FAULT) {
      /* do something... */
   }
   if (code & E_PR_POUT) {
      /* do something... */
   }
   if (code & E_PR_SELECT) {
      /* do something... */
   }
   if (code & E_SWITCH) {
      /* do something... */
   }
   if (code & E_BREAK) {
      vx_break (sc, evntp->device_number);
   }
   
   /* send and event packet backe to the device */
   bzero(&evnt, sizeof(struct event_packet));
   evnt.command = CMD_EVENT;
   evnt.device_number = evntp->device_number;
   evnt.command_pipe_number = sc->channel_number;
   /* return status on same channel */
   evnt.status_pipe_number = sc->channel_number;
   /* send packet to the firmware */
   bpp_send(sc, &evnt, NOWAIT);
   return 1;
d1261 4
a1264 4
struct vxsoftc *sc;
int port;
long *ptime;
u_char *msg;
d1266 2
a1267 2
   log(LOG_WARNING, "%s port %d: overrun\n", sc->sc_dev.dv_xname, port);
   return;
d1272 2
a1273 2
struct vxsoftc *sc;
int port;
d1275 2
a1276 2
   log(LOG_WARNING, "%s port %d: frame error\n", sc->sc_dev.dv_xname, port);
   return;
d1281 2
a1282 2
struct vxsoftc *sc;
int port;
d1285 1
a1285 1
   Debugger();
d1287 1
a1287 1
   log(LOG_WARNING, "%s port %d: break detected\n", sc->sc_dev.dv_xname, port);
d1289 1
a1289 1
   return;
d1303 9
a1311 9
   int i;
   short *d, *s;
   d = (short*) dest;
   s = (short*) src;
   for (i=0; i<(size/2); i++) {
      *d = *s;
      d++;
      s++;
   }
d1317 7
a1323 7
   int i;
   short *d;
   d = (short*) addr;
   for (i=0; i<(size/2); i++) {
      *d = 0;
      d++;
   }
d1330 32
a1361 32
   int i;
   struct envelope *envp;
   struct packet   *pktp;

   envp = (struct envelope *)ENVELOPE_AREA;
   sc->elist_head = envp;
   for (i=0; i < NENVELOPES; i++) {
      bzero(envp, sizeof(struct envelope));
      if (i==(NENVELOPES - 1)) {
         envp->link = NULL;
      } else {
         envp->link = (u_long)envp + sizeof(struct envelope);
      }
      envp->packet_ptr = NULL;
      envp->valid_flag = 0;
      envp++;
   }
   sc->elist_tail = --envp;

   pktp = (struct packet *)PACKET_AREA;
   sc->plist_head = pktp;
   for (i=0; i < NPACKETS; i++) {
      bzero(pktp, sizeof(struct packet));
      if (i==(NPACKETS - 1)) {
         pktp->link = NULL;
      } else {
         pktp->link = (u_long)pktp + sizeof(struct packet);
      }
      pktp++;
   }
   sc->plist_tail = --pktp;
   return 0; /* no error */
d1366 1
a1366 1
struct vxsoftc *sc;
d1368 1
a1368 1
   void *envp;
d1370 4
a1373 4
   envp = sc->elist_head;
   sc->elist_head = (struct envelope *)sc->elist_head->link;
   bzero(envp, sizeof(struct envelope));
   return envp;
d1378 2
a1379 2
struct vxsoftc *sc;
void * ep;
d1381 5
a1385 5
   struct envelope *envp = (struct envelope *)ep;
   bzero(envp, sizeof(struct envelope));
   sc->elist_tail->link = (ulong)envp;
   envp->link = NULL;
   sc->elist_tail = envp;
d1390 1
a1390 1
struct vxsoftc *sc;
d1392 1
a1392 1
   struct packet *pktp;
d1394 4
a1397 4
   pktp = sc->plist_head;
   sc->plist_head = (struct packet *)sc->plist_head->link;
   bzero(pktp, sizeof(struct packet));
   return pktp;
d1402 2
a1403 2
struct vxsoftc *sc;
void *pp;
d1405 6
a1410 6
   struct packet *pktp = (struct packet *)pp;
   /*bzero(pktp, sizeof(struct packet));*/
   pktp->command = CMD_PROCCESED;
   sc->plist_tail->link = (u_long)pktp;
   pktp->link = NULL;
   sc->plist_tail = pktp;
d1420 1
a1420 1
struct vxsoftc *sc;
d1422 86
a1507 86
   struct envelope *envp;
   u_short status;
   u_short tas;
   struct vxreg *ipc_csr;
   
   ipc_csr = sc->vx_reg;
   /* wait for busy bit to clear */
   while ((ipc_csr->ipc_cr & IPC_CR_BUSY));
   create_free_queue(sc);
   /* set up channel header.  we only want one */
   tas = ipc_csr->ipc_tas;
   while (!(tas & IPC_TAS_VALID_STATUS)) {
      envp = get_free_envelope(sc);
      sc->channel->command_pipe_head_ptr_h = HI(envp);
      sc->channel->command_pipe_head_ptr_l = LO(envp);
      sc->channel->command_pipe_tail_ptr_h = sc->channel->command_pipe_head_ptr_h;
      sc->channel->command_pipe_tail_ptr_l = sc->channel->command_pipe_head_ptr_l;
      envp = get_free_envelope(sc);
      sc->channel->status_pipe_head_ptr_h = HI(envp);
      sc->channel->status_pipe_head_ptr_l = LO(envp);
      sc->channel->status_pipe_tail_ptr_h = sc->channel->status_pipe_head_ptr_h;
      sc->channel->status_pipe_tail_ptr_l = sc->channel->status_pipe_head_ptr_l;
      sc->channel->interrupt_level =  sc->sc_ipl;
      sc->channel->interrupt_vec = sc->sc_vec;
      sc->channel->channel_priority = 0;
      sc->channel->channel_number = 0;
      sc->channel->valid = 1;
      sc->channel->address_modifier = 0x8D; /* A32/D16 supervisor data access */
      sc->channel->datasize = 0; /* 32 bit data mode */

      /* loop until TAS bit is zero */
      while ((ipc_csr->ipc_tas & IPC_TAS_TAS)); 
      ipc_csr->ipc_tas |= IPC_TAS_TAS;
      /* load address of channel header */
      ipc_csr->ipc_addrh = HI(sc->channel);
      ipc_csr->ipc_addrl = LO(sc->channel);
      /* load address modifier reg (supervisor data access) */
      ipc_csr->ipc_amr = 0x8D;
      /* load tas with create channel command */
      ipc_csr->ipc_tas |= IPC_CSR_CREATE;
      /* set vaild command bit */
      ipc_csr->ipc_tas |= IPC_TAS_VALID_CMD;
      /* notify IPC of the CSR command */
      ipc_csr->ipc_cr |= IPC_CR_ATTEN;
      /* loop until IPC sets vaild status bit */
      delay(5000);
      tas = ipc_csr->ipc_tas;
   }

   /* save the status */
   status = ipc_csr->ipc_sr;
   /* set COMMAND COMPLETE bit */
   ipc_csr->ipc_tas |= IPC_TAS_COMPLETE;
   /* notify IPC that we are through */
   ipc_csr->ipc_cr |= IPC_CR_ATTEN;
   /* check and see if the channel was created */
   if (!status && sc->channel->valid) {
      sc->channel_number = sc->channel->channel_number;
      printf("%s: created channel %d\n", sc->sc_dev.dv_xname, 
             sc->channel->channel_number);
      return 0;
   } else {
      switch (status) {
      case 0x0000:
         printf("%s: channel not valid\n", 
                sc->sc_dev.dv_xname);
         break;
      case 0xFFFF:
         printf("%s: invalid CSR command\n", 
                sc->sc_dev.dv_xname);
         break;
      case 0xC000:
         printf("%s: could not read channel structure\n", 
                sc->sc_dev.dv_xname);
         break;
      case 0x8000:
         printf("%s: could not write channel structure\n", 
                sc->sc_dev.dv_xname);
         break;
      default:
         printf("%s: unknown IPC CSR command error 0x%x\n", 
                sc->sc_dev.dv_xname, status);
         break;
      }
      return status; /* error */
   }
d1512 1
a1512 1
struct vxsoftc *sc;
d1514 3
a1516 3
   char *dump_area;
   char dump[209];
   bzero(&dump, 209);
d1518 4
a1521 4
   dump_area = (char *)0xff780030;
   memcpy2(&dump, dump_area, 208);
   
   printf("%s", dump);
d1526 1
a1526 1
struct envelope *thisenv;
d1528 1
a1528 1
   return ((void *)thisenv->link);
d1533 1
a1533 1
struct envelope *thisenv;
d1535 1
a1535 1
   return thisenv->valid_flag;
d1540 1
a1540 1
struct vxsoftc *sc;
d1542 4
a1545 4
   unsigned long retaddr;
   retaddr = (unsigned long)sc->vx_reg;
   retaddr += sc->channel->command_pipe_tail_ptr_l;
   return ((struct envelope *)retaddr);
d1550 1
a1550 1
struct vxsoftc *sc;
d1552 4
a1555 4
   unsigned long retaddr;
   retaddr = (unsigned long)sc->vx_reg;
   retaddr += sc->channel->status_pipe_head_ptr_l;
   return ((struct envelope *)retaddr);
d1560 2
a1561 2
struct vxsoftc *sc;
void *envp;
d1563 3
a1565 3
   sc->channel->status_pipe_head_ptr_h = HI(envp);
   sc->channel->status_pipe_head_ptr_l = LO(envp);
   return;   
d1570 2
a1571 2
struct vxsoftc *sc;
struct envelope *thisenv;
d1573 1
a1573 1
   unsigned long baseaddr; 
d1575 10
a1584 10
   if (thisenv == NULL) return NULL;
   baseaddr = (unsigned long)sc->vx_reg;
   /* 
    * packet ptr returned on status pipe is only last two bytes
    * so we must supply the full address based on the board address.
    * This also works for all envelopes because every address is an
    * offset to the board address 
    */
   baseaddr |= thisenv->packet_ptr;
   return ((void*)baseaddr);
d1593 20
a1612 20
   struct envelope *envp;
   struct packet *pktp;
   unsigned long newenv;


   /* load up packet in dual port mem */
   pktp = get_free_packet(sc);
   memcpy2(pktp, pkt, sizeof(struct packet));
   
   envp = get_cmd_tail(sc);
   newenv = (unsigned long)get_free_envelope(sc); /* put a NULL env on the tail */
   envp->link = newenv;
   sc->channel->command_pipe_tail_ptr_h = HI(newenv);
   sc->channel->command_pipe_tail_ptr_l = LO(newenv);
   envp->packet_ptr = (u_long)pktp;   /* add the command packet */
   envp->valid_flag = 1;              /* set valid command flag */

   sc->vx_reg->ipc_cr |= IPC_CR_ATTEN;
   if (wait_flag) {                    /* wait for a packet to return */
      while (pktp->command != CMD_PROCCESED) {
d1614 1
a1614 1
            printf("Polling for packet 0x%x in envelope 0x%x...\n", pktp, envp);
d1616 7
a1622 7
            vx_intr(sc);
            delay(5000);
      }
      memcpy2(pkt, pktp, sizeof(struct packet));
      return 0;
   }
   return 0; /* no error */
d1628 1
d1631 1
a1631 1
struct vxsoftc *sc;
d1633 24
a1656 24
   int i;
   struct init_info *infp, inf;
   struct wring *wringp;
   struct rring *rringp;
   struct termio def_termio;
   struct init_packet init;
   struct event_packet evnt;

   bzero(&def_termio, sizeof(struct termio));
   /* init wait queue */
   bzero(&sc->sc_bppwait_pkt, sizeof(struct packet));
   sc->sc_bppwait_pktp = NULL;
   /* set up init_info array */
   wringp = (struct wring *)WRING_AREA;
   rringp = (struct rring *)RRING_AREA;
   infp = (struct init_info *)INIT_INFO_AREA;
   for (i=0; i<9; i++) {
      bzero(&inf, sizeof(struct init_info));
      infp->write_ring_ptr_h = HI(wringp);
      infp->write_ring_ptr_l = LO(wringp);
      sc->sc_info[i].wringp = wringp;
      infp->read_ring_ptr_h = HI(rringp);
      infp->read_ring_ptr_l = LO(rringp);
      sc->sc_info[i].rringp = rringp;
d1658 1
a1658 1
      printf("write at 0x%8x, read at 0x%8x\n", wringp, rringp);
d1660 55
a1714 55
      infp->write_ring_size = WRING_DATA_SIZE;
      infp->read_ring_size = RRING_DATA_SIZE;
      infp->def_termio.c_iflag = VBRKINT;
      infp->def_termio.c_oflag = 0;
      infp->def_termio.c_cflag = (VB9600 | VCS8);
      
      infp->def_termio.c_lflag = VISIG; /* enable signal processing */
      infp->def_termio.c_line = 1; /* raw line disipline, we want to control it! */
      infp->def_termio.c_cc[0] = CINTR;
      infp->def_termio.c_cc[1] = CQUIT;
      infp->def_termio.c_cc[2] = CERASE;
      infp->def_termio.c_cc[3] = CKILL;
      infp->def_termio.c_cc[4] = 20;
      infp->def_termio.c_cc[5] = 2;
      infp->reserved1 = 0;  /* Must be Zero */
      infp->reserved2 = 0;
      infp->reserved3 = 0;
      infp->reserved4 = 0;
      wringp++; rringp++; infp++;
   }
   /* set up init_packet */
   bzero(&init, sizeof(struct init_packet));
   init.eye_catcher[0] = 0x12;
   init.eye_catcher[1] = 0x34;
   init.eye_catcher[2] = 0x56;
   init.eye_catcher[3] = 0x78;
   init.command = CMD_INIT;
   init.command_pipe_number = sc->channel_number;
   /* return status on the same channel */
   init.status_pipe_number = sc->channel_number;
   init.interrupt_level = sc->sc_ipl;
   init.interrupt_vec = sc->sc_vec;
   init.init_info_ptr_h = HI(INIT_INFO_AREA);
   init.init_info_ptr_l = LO(INIT_INFO_AREA);

   /* send packet to the firmware and wait for completion */
   bpp_send(sc, &init, WAIT_POLL);

   /* check for error */
   if (init.error_l !=0) {
      return init.error_l;
   } else {
      /* send one event packet to each device; */
      for (i=0; i<9; i++) {
         bzero(&evnt, sizeof(struct event_packet));
         evnt.command = CMD_EVENT;
         evnt.device_number = i;
         evnt.command_pipe_number = sc->channel_number;
         /* return status on same channel */
         evnt.status_pipe_number = sc->channel_number;
         /* send packet to the firmware */
         bpp_send(sc, &evnt, NOWAIT);
      }
      return 0;
   }
a1715 1

@


1.4
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.3 2001/01/14 20:25:22 smurph Exp $ */
d111 1
a111 1
void *memcpy2 __P((void *dest, const void *src, size_t size));
d124 1
a124 1
int  vx_intr __P((struct vxsoftc *sc));
a143 1
static u_char vxgetc __P((struct vxsoftc *sc, int *port));
a180 1
   struct vxsoftc *sc = self;
d182 1
a182 1
   int ret;
a211 1
   int i;
d238 1
a239 1
   sc->sc_ih_c.ih_wantframe = 0;
d247 1
d269 1
d291 1
a314 1
   int vxbits;
a516 1
   int s;
a587 1
   struct rring *rp;
a654 1
   int i, cnt, s;
a791 8
static u_char 
vxgetc(sc, port)
struct vxsoftc *sc;
int *port;
{
   return 0;
}

d870 2
a871 3
   struct termio tio;
   int imask=0, ints, s;
   int cflag, iflag, oflag, lflag;
a963 1
   u_char cbuf;
a968 1
   char *wrdp;
a1016 1
   struct read_wakeup_packet rwp;
d1019 1
a1019 1
   int frame_count, i, pc = 0, open;
d1057 1
d1072 2
a1073 2
vx_intr(sc)
struct vxsoftc *sc;
d1075 2
a1077 1
   struct envelope env;
d1079 1
a1079 1
   int valid, i;
d1256 1
a1256 1
void *
a1287 1
   struct envelope env;
a1288 1
   struct packet   pkt;
a1378 3
   struct envelope env;
   struct packet *pktp;
   u_char valid;
d1380 1
a1380 1
   u_short tas, csr;
d1470 1
a1470 1
   char *dump_area, *end_dump, *dumpp;
a1471 1
   char dump2[209];
a1528 1
   struct envelope env;
d1550 1
a1550 2
   struct init_packet init, *initp;
   struct packet *wpktp, *pktp, *testpktp;
a1551 1
   int i, s;
@


1.3
log
@Complete move to UVM virtual memory system.  More header fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.2 2000/03/26 23:32:00 deraadt Exp $ */
d615 1
a615 1
    * Do not wait.  Characters will be transfered
@


1.2
log
@callout.h is gone
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.1 1999/05/29 04:41:45 smurph Exp $ */
d87 1
d89 1
d219 1
d221 1
d1096 1
d1102 1
a1572 1
   struct vme2reg *vme2 = (struct vme2reg *)sc->sc_vme2;
@


1.1
log
@Added vme bus device drivers. MVME328, MVME376, MVME332
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.0 1999/03/28 05:11:42 smurph Exp $ */
a33 1
#include <sys/callout.h>
@


1.1.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.6 2001/03/09 05:44:39 smurph Exp $ */
d34 1
d63 10
a72 10
	struct   tty *tty;
	u_char   vx_swflags;
	int      vx_linestatus;
	int      open;
	int      waiting;
	u_char   vx_consio;
	u_char   vx_speed;
	u_char   read_pending;
	struct   wring  *wringp;
	struct   rring  *rringp;
d76 18
a93 20
	struct device     sc_dev;
	struct evcnt      sc_intrcnt;
	struct evcnt      sc_sintrcnt;
	struct vx_info  sc_info[9];
	struct vxreg    *vx_reg;
	unsigned int      board_addr;
	struct channel    *channel;
	char              channel_number;
	struct packet     sc_bppwait_pkt;
	void              *sc_bppwait_pktp;
	struct intrhand   sc_ih_c;
	struct intrhand   sc_ih_s;
#if defined(MVME187) || defined(MVME197)
	struct vme2reg    *sc_vme2;
#endif
	int               sc_ipl;
	int               sc_vec;
	int               sc_flags;
	struct envelope   *elist_head, *elist_tail;
	struct packet     *plist_head, *plist_tail;
d110 1
a110 2
int  env_isvalid __P((struct envelope *thisenv));
void memcpy2 __P((void *dest, const void *src, size_t size));
d123 1
a123 1
int  vx_intr __P((void * arg));
d143 1
d146 1
a146 1
	sizeof(struct vxsoftc), vxmatch, vxattach
d150 1
a150 1
	NULL, "vx", DV_TTY, 0
d161 1
a161 1
	dev_t dev;
d163 9
a171 9
	int unit, port;
	struct vxsoftc *sc;
	unit = VX_UNIT(dev);
	if (unit >= vx_cd.cd_ndevs || 
	    (sc = (struct vxsoftc *) vx_cd.cd_devs[unit]) == NULL) {
		return (NULL);
	}
	port = VX_PORT(dev);
	return sc->sc_info[port].tty;
d176 10
a185 9
	struct device *parent;
	void *self;
	void *aux;
{
	struct vxreg *vx_reg;
	struct confargs *ca = aux;
   
	if (cputyp != CPU_187)
		return 0;
d187 1
a187 1
	ca->ca_vaddr = ca->ca_paddr;
d189 14
a202 14
	ca->ca_len = 0x10000; /* we know this. */
	ca->ca_ipl = 3;	/* we need interrupts for this board to work */

	vx_reg = (struct vxreg *)ca->ca_vaddr;
	board_addr = (unsigned int)ca->ca_vaddr;
	if (!badvaddr((unsigned)&vx_reg->ipc_cr, 1)) {
		if (ca->ca_vec & 0x03) {
			printf("xvt: bad vector 0x%x\n", ca->ca_vec);
			return (0);
		}
		return (1);
	} else {
		return (0);
	}      
d207 17
a223 28
	struct device *parent;
	struct device *self;
	void *aux;
{
	struct vxsoftc *sc = (struct vxsoftc *)self;
	struct confargs *ca = aux;
	
	/* set up dual port memory and registers and init*/
	sc->vx_reg = (struct vxreg *)ca->ca_vaddr;
	sc->channel = (struct channel *)(ca->ca_vaddr + 0x0100);
#if defined(MVME187) || defined(MVME197)
	sc->sc_vme2 = ca->ca_master;
#endif 
	sc->sc_ipl = ca->ca_ipl; 
	sc->sc_vec = ca->ca_vec; 
	sc->board_addr = (unsigned int)ca->ca_vaddr;

	printf("\n");

	if (create_channels(sc)) {
		printf("%s: failed to create channel %d\n", sc->sc_dev.dv_xname, 
		       sc->channel->channel_number);
		return;
	}
	if (vx_init(sc)) {
		printf("%s: failed to initialize\n", sc->sc_dev.dv_xname);
		return;
	}
d225 18
a242 8
	/* enable interrupts */
	sc->sc_ih_c.ih_fn = vx_intr;
	sc->sc_ih_c.ih_arg = sc;
	sc->sc_ih_c.ih_wantframe = 0;
	sc->sc_ih_c.ih_ipl = ca->ca_ipl;

	vmeintr_establish(ca->ca_vec, &sc->sc_ih_c);
	evcnt_attach(&sc->sc_dev, "intr", &sc->sc_intrcnt);
a246 1
short
d248 18
a265 18
	struct vxsoftc *sc;
	int port;
	int on;
{
	struct packet pkt;
	bzero(&pkt, sizeof(struct packet));
	pkt.command = CMD_IOCTL;
	pkt.ioctl_cmd_l = IOCTL_TCXONC;
	pkt.command_pipe_number = sc->channel_number;
	pkt.status_pipe_number = sc->channel_number;
	pkt.device_number = port;
	if (on) {
		pkt.ioctl_arg_l = 6;  /* assert DTR */
	} else {
		pkt.ioctl_arg_l = 7;  /* negate DTR */
	}
	bpp_send(sc, &pkt, NOWAIT);
	return (pkt.error_l);
a267 1
short
d269 18
a286 18
struct vxsoftc *sc;
int port;
int on;
{
	struct packet pkt;
	bzero(&pkt, sizeof(struct packet));
	pkt.command = CMD_IOCTL;
	pkt.ioctl_cmd_l = IOCTL_TCXONC;
	pkt.command_pipe_number = sc->channel_number;
	pkt.status_pipe_number = sc->channel_number;
	pkt.device_number = port;
	if (on) {
		pkt.ioctl_arg_l = 4;  /* assert RTS */
	} else {
		pkt.ioctl_arg_l = 5;  /* negate RTS */
	}
	bpp_send(sc, &pkt, NOWAIT);
	return (pkt.error_l);
a288 1
short
d290 14
a303 14
struct vxsoftc *sc;
int port;
int which;
{
	struct packet pkt;
	bzero(&pkt, sizeof(struct packet));
	pkt.command = CMD_IOCTL;
	pkt.ioctl_cmd_l = IOCTL_TCFLSH;
	pkt.command_pipe_number = sc->channel_number;
	pkt.status_pipe_number = sc->channel_number;
	pkt.device_number = port;
	pkt.ioctl_arg_l = which; /* 0=input, 1=output, 2=both */
	bpp_send(sc, &pkt, NOWAIT);
	return (pkt.error_l);
d307 18
a324 17
	dev_t dev;
	int bits;
	int how;
{
	int s, unit, port;
	struct vxsoftc *sc;
	struct vx_info *vxt;
	u_char msvr;

	unit = VX_UNIT(dev);
	port = VX_PORT(dev);
	sc = (struct vxsoftc *) vx_cd.cd_devs[unit];
	vxt = &sc->sc_info[port];

	s = splvx();
	switch (how) {
	case DMSET:
d327 1
a327 1
			vxt->vx_linestatus |= TIOCM_RTS;
d330 2
a331 2

			vxt->vx_linestatus &= ~TIOCM_RTS;
d333 1
a333 1
		if ( bits & TIOCM_DTR) {
d335 1
a335 1
			vxt->vx_linestatus |= TIOCM_DTR;
d338 1
a338 1
			vxt->vx_linestatus &= ~TIOCM_DTR;
d341 2
a342 2
	case DMBIC:
		if ( bits & TIOCM_RTS) {
d344 3
a346 3
			vxt->vx_linestatus &= ~TIOCM_RTS;
		}
		if ( bits & TIOCM_DTR) {
d348 3
a350 3
			vxt->vx_linestatus &= ~TIOCM_DTR;
		}
		break;
d352 2
a353 2
	case DMBIS:
		if ( bits & TIOCM_RTS) {
d355 3
a357 3
			vxt->vx_linestatus |= TIOCM_RTS;
		}
		if ( bits & TIOCM_DTR) {
d359 3
a361 3
			vxt->vx_linestatus |= TIOCM_DTR;
		}
		break;
d363 1
a363 1
	case DMGET:
d366 1
a366 1
		if ( msvr & TIOCM_DSR) {
d369 1
a369 1
		if ( msvr & TIOCM_CD) {
d372 1
a372 1
		if ( msvr & TIOCM_CTS) {
d375 1
a375 1
		if ( msvr & TIOCM_DTR) {
d378 1
a378 1
		if ( msvr & TIOCM_RTS) {
d381 5
a385 5
		break;
	}

	splx(s);
	bits = 0;
d391 1
a391 1
	return (bits);
d395 11
a405 19
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
{
	int s, unit, port;
	struct vx_info *vxt;
	struct vxsoftc *sc;
	struct tty *tp;
	struct open_packet opkt;
	u_short code;

	unit = VX_UNIT(dev);
	port = VX_PORT(dev);

	if (unit >= vx_cd.cd_ndevs || 
	    (sc = (struct vxsoftc *) vx_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
	}
d407 23
a429 15
	/*flush_ctl(sc, port, 2);*/

	bzero(&opkt, sizeof(struct packet));
	opkt.eye_catcher[0] = 0x33;
	opkt.eye_catcher[1] = 0x33;
	opkt.eye_catcher[2] = 0x33;
	opkt.eye_catcher[3] = 0x33;
	opkt.command_pipe_number = sc->channel_number;
	opkt.status_pipe_number = sc->channel_number;
	opkt.command = CMD_OPEN;
	opkt.device_number = port;

	bpp_send(sc, &opkt, WAIT_POLL);

	if (opkt.error_l) {
d431 2
a432 2
		printf("unit %d, port %d, ", unit, port);
		printf("error = %d\n", opkt.error_l);
d434 4
a437 4
		return (ENODEV);
	}

	code = opkt.event_code;
d439 11
a449 11

	vxt = &sc->sc_info[port];
	if (vxt->tty) {
		tp = vxt->tty;
	} else {
		tp = vxt->tty = ttymalloc();  
	}

	/* set line status */
	tp->t_state |= TS_CARR_ON;
	if (code & E_DCD) {
d451 37
a487 8
		vxt->vx_linestatus |= TIOCM_CD;
	}
	if (code & E_DSR) {
		vxt->vx_linestatus |= TIOCM_DSR;
	}
	if (code & E_CTS) {
		vxt->vx_linestatus |= TIOCM_CTS;
	}
d489 17
a505 46
	tp->t_oproc = vxstart;
	tp->t_param = vx_param;
	tp->t_dev = dev;

	if ((tp->t_state & TS_ISOPEN) == 0) {
		tp->t_state |= TS_WOPEN;
		ttychars(tp);
		if (tp->t_ispeed == 0) {
			/*
			 * only when cleared do we reset to defaults.
			 */
			tp->t_iflag = TTYDEF_IFLAG;
			tp->t_oflag = TTYDEF_OFLAG;
			tp->t_lflag = TTYDEF_LFLAG;
			tp->t_ispeed = tp->t_ospeed = vxtdefaultrate;
			tp->t_cflag = TTYDEF_CFLAG;
		}
		/*
		 * do these all the time
		 */
		if (vxt->vx_swflags & TIOCFLAG_CLOCAL)
			tp->t_cflag |= CLOCAL;
		if (vxt->vx_swflags & TIOCFLAG_CRTSCTS)
			tp->t_cflag |= CRTSCTS;
		if (vxt->vx_swflags & TIOCFLAG_MDMBUF)
			tp->t_cflag |= MDMBUF;
		vx_param(tp, &tp->t_termios);
		ttsetwater(tp);

		(void)vx_mctl(dev, TIOCM_DTR | TIOCM_RTS, DMSET);

		tp->t_state |= TS_CARR_ON;
	} else if (tp->t_state & TS_XCLUDE && p->p_ucred->cr_uid != 0) {
		splx(s);
		return (EBUSY);
	}

	/*
	 * Reset the tty pointer, as there could have been a dialout
	 * use of the tty with a dialin open waiting.
	 */
	tp->t_dev = dev;
	sc->sc_info[port].open = 1;
	read_wakeup(sc, port);
	splx(s);
	return ((*linesw[tp->t_line].l_open)(dev, tp));
d510 2
a511 2
	struct tty *tp;
	struct termios *t;
d513 18
a530 17
	int unit, port;
	struct vxsoftc *sc;
	dev_t dev;

	dev = tp->t_dev;
	unit = VX_UNIT(dev);
	if (unit >= vx_cd.cd_ndevs || 
	    (sc = (struct vxsoftc *) vx_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
	}
	port = VX_PORT(dev);
	tp->t_ispeed = t->c_ispeed;
	tp->t_ospeed = t->c_ospeed;
	tp->t_cflag = t->c_cflag;
	vx_ccparam(sc, t, port);
	vx_unblock(tp);
	return 0;
d535 17
a551 17
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
{
	int unit, port;
	struct tty *tp;
	struct vx_info *vxt;
	struct vxsoftc *sc;
	int s;
	struct close_packet cpkt;
	unit = VX_UNIT(dev);
	if (unit >= vx_cd.cd_ndevs || 
	    (sc = (struct vxsoftc *) vx_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
	}
	port = VX_PORT(dev);
d553 6
a558 6

	vxt = &sc->sc_info[port];
	tp = vxt->tty;
	(*linesw[tp->t_line].l_close)(tp, flag);

	if ((tp->t_cflag & HUPCL) != 0) {
d562 18
a579 18

	s = splvx();

	bzero(&cpkt, sizeof(struct packet));
	cpkt.eye_catcher[0] = 0x55;
	cpkt.eye_catcher[1] = 0x55;
	cpkt.eye_catcher[2] = 0x55;
	cpkt.eye_catcher[3] = 0x55;
	cpkt.command_pipe_number = sc->channel_number;
	cpkt.status_pipe_number = sc->channel_number;
	cpkt.command = CMD_CLOSE;
	cpkt.device_number = port;

	bpp_send(sc, &cpkt, NOWAIT);
	splx(s);
	ttyclose(tp);
	sc->sc_info[port].open = 0;
	return (0);
d584 2
a585 2
	struct vxsoftc *sc;
	int port;
d587 30
a616 29
	struct read_wakeup_packet rwp;
	volatile struct vx_info *vxt;
	vxt = &sc->sc_info[port];
	/* 
	 * If we already have a read_wakeup paket 
	 * for this port, do nothing.
	 */
	if (vxt->read_pending) {
		return;
	} else {
		vxt->read_pending = 1;
	}

	bzero(&rwp, sizeof(struct packet));
	rwp.eye_catcher[0] = 0x11;
	rwp.eye_catcher[1] = 0x11;
	rwp.eye_catcher[2] = 0x11;
	rwp.eye_catcher[3] = 0x11;
	rwp.command_pipe_number = sc->channel_number;
	rwp.status_pipe_number = sc->channel_number;
	rwp.command = CMD_READW;
	rwp.device_number = port;

	/*
	 * Do not wait.  Characters will be transferred
	 * to (*linesw[tp->t_line].l_rint)(c,tp); by 
	 * vx_intr()  (IPC will notify via interrupt)
	 */
	bpp_send(sc, &rwp, NOWAIT);
d621 19
a639 19
	dev_t dev;
	struct uio *uio;
	int flag;
{
	int unit, port;
	struct tty *tp;
	volatile struct vx_info *vxt;
	volatile struct vxsoftc *sc;

	unit = VX_UNIT(dev);
	if (unit >= vx_cd.cd_ndevs || 
	    (sc = (struct vxsoftc *) vx_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
	}
	port = VX_PORT(dev);
	vxt = &sc->sc_info[port];
	tp = vxt->tty;
	if (!tp) return ENXIO;
	return ((*linesw[tp->t_line].l_read)(tp, uio, flag));
d644 38
a681 17
	dev_t dev;
	struct uio *uio;
	int flag;
{
	int unit, port;
	struct tty *tp;
	struct vx_info *vxt;
	struct vxsoftc *sc;
	struct wring *wp;
	struct write_wakeup_packet wwp;
	u_short get, put;

	unit = VX_UNIT(dev);
	if (unit >= vx_cd.cd_ndevs || 
	    (sc = (struct vxsoftc *) vx_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
	}
d683 7
a689 48
	port = VX_PORT(dev);
	vxt = &sc->sc_info[port];
	tp = vxt->tty;
	if (!tp) return ENXIO;

	wp = sc->sc_info[port].wringp;
	get = wp->get;
	put = wp->put;

	if ((put + 1) == get) {
		bzero(&wwp, sizeof(struct packet));
		wwp.eye_catcher[0] = 0x22;
		wwp.eye_catcher[1] = 0x22;
		wwp.eye_catcher[2] = 0x22;
		wwp.eye_catcher[3] = 0x22;
		wwp.command_pipe_number = sc->channel_number;
		wwp.status_pipe_number = sc->channel_number;
		wwp.command = CMD_WRITEW;
		wwp.device_number = port;

		port = VX_PORT(dev);
		vxt = &sc->sc_info[port];
		tp = vxt->tty;
		if (!tp) return ENXIO;

		wp = sc->sc_info[port].wringp;
		get = wp->get;
		put = wp->put;

		if ((put + 1) == get) {
			bzero(&wwp, sizeof(struct packet));
			wwp.eye_catcher[0] = 0x22;
			wwp.eye_catcher[1] = 0x22;
			wwp.eye_catcher[2] = 0x22;
			wwp.eye_catcher[3] = 0x22;
			wwp.command_pipe_number = sc->channel_number;
			wwp.status_pipe_number = sc->channel_number;
			wwp.command = CMD_WRITEW;
			wwp.device_number = port;

			bpp_send(sc, &wwp, WAIT_POLL);

			if (wwp.error_l) {
				return (ENXIO);
			}
		}
	}
	return ((*linesw[tp->t_line].l_write)(tp, uio, flag));
d694 38
a731 34
	dev_t dev;
	int cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	int error;
	int unit, port;
	struct tty *tp;
	struct vx_info *vxt;
	struct vxsoftc *sc;
	unit = VX_UNIT(dev);
	if (unit >= vx_cd.cd_ndevs || 
	    (sc = (struct vxsoftc *) vx_cd.cd_devs[unit]) == NULL) {
		return (ENODEV);
	}
	port = VX_PORT(dev);
	vxt = &sc->sc_info[port];
	tp = vxt->tty;
	if (!tp)
		return ENXIO;

	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);

	error = ttioctl(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);

	switch (cmd) {
	case TIOCSBRK:
		/* */
		break;
d733 1
a733 5
	case TIOCCBRK:
		/* */
		break;

	case TIOCSDTR:
d735 1
a735 1
		break;
d737 1
a737 1
	case TIOCCDTR:
d739 1
a739 1
		break;
d741 1
a741 1
	case TIOCMSET:
d743 1
a743 1
		break;
d745 1
a745 1
	case TIOCMBIS:
d747 1
a747 1
		break;
d749 1
a749 1
	case TIOCMBIC:
d751 1
a751 1
		break;
d753 1
a753 1
	case TIOCMGET:
d755 1
a755 1
		break;
d757 1
a757 1
	case TIOCGFLAGS:
d761 1
a761 1
	case TIOCSFLAGS:
d764 1
a764 1
			return (EPERM);
d768 2
a769 2
				   (TIOCFLAG_SOFTCAR | TIOCFLAG_CLOCAL | TIOCFLAG_CRTSCTS);
		break;
d771 4
a774 4
	default:
		return (ENOTTY);
	}
	return 0;
d779 2
a780 2
	struct tty *tp;
	int flag;
d782 1
a782 1
	int s;
d785 4
a788 4
	if (tp->t_state & TS_BUSY) {
		if ((tp->t_state & TS_TTSTOP) == 0)
			tp->t_state |= TS_FLUSH;
	}
d790 9
a798 1
	return 0;
d803 10
a812 10
	struct vxsoftc *sc;
	int port;
	u_char c;
{
	struct wring *wp;

	wp = sc->sc_info[port].wringp;
	wp->data[wp->put++ & (WRING_BUF_SIZE-1)] = c;
	wp->put &= (WRING_BUF_SIZE-1);
	return;
d816 1
a816 1
	int speed;
d818 53
a870 53
	switch (speed) {
	case B0:
		return VB0;
		break;
	case B50:
		return VB50;
		break;
	case B75:
		return VB75;
		break;
	case B110:
		return VB110;
		break;
	case B134:
		return VB134;
		break;
	case B150:
		return VB150;
		break;
	case B200:
		return VB200;
		break;
	case B300:
		return VB300;
		break;
	case B600:
		return VB600;
		break;
	case B1200:
		return VB1200;
		break;
	case B1800:
		return VB1800;
		break;
	case B2400:
		return VB2400;
		break;
	case B4800:
		return VB4800;
		break;
	case B9600:
		return VB9600;
		break;
	case B19200:
		return VB19200;
		break;
	case B38400:
		return VB38400;
		break;
	default:
		return VB9600;
		break;
	}
d875 33
a907 32
	struct vxsoftc *sc;
	struct termios *par;
	int port;
{
	int imask=0, s;
	int cflag /*, iflag, oflag, lflag*/;
	struct ioctl_a_packet pkt;
	bzero(&pkt, sizeof(struct packet));

	if (par->c_ospeed == 0) {
		s = splvx();
		/* dont kill the console */
		if (sc->sc_info[port].vx_consio == 0) {
			/* disconnect, drop RTS DTR stop reciever */
			rts_ctl(sc, port, 0);
			dtr_ctl(sc, port, 0);
		}
		splx(s);
		return (0xff);
	}

	pkt.command = CMD_IOCTL;
	pkt.ioctl_cmd_l = IOCTL_TCGETA;
	pkt.command_pipe_number = sc->channel_number;
	pkt.status_pipe_number = sc->channel_number;
	pkt.device_number = port;
	bpp_send(sc, &pkt, WAIT_POLL);

	cflag = pkt.c_cflag;
	cflag |= vxtspeed(par->c_ospeed);

	switch (par->c_cflag & CSIZE) {
d923 32
a954 49
	}

	if (par->c_cflag & PARENB) cflag |= VPARENB;
	else cflag &= ~VPARENB;
	if (par->c_cflag & PARODD) cflag |= VPARODD;
	else cflag &= ~VPARODD;
	if (par->c_cflag & CREAD) cflag |= VCREAD;
	else cflag &= ~VCREAD;
	if (par->c_cflag & CLOCAL) cflag |= VCLOCAL;
	else cflag &= ~VCLOCAL;
	if (par->c_cflag & HUPCL) cflag |= VHUPCL;
	else cflag &= ~VHUPCL;
#if 0
	if (par->c_iflag & BRKINT) iflag |= VBRKINT;
	else iflag &= ~VBRKINT;
	if (par->c_iflag & ISTRIP) iflag |= VISTRIP;
	else iflag &= ~VISTRIP;
	if (par->c_iflag & ICRNL) iflag |= VICRNL;
	else iflag &= ~VICRNL;
	if (par->c_iflag & IXON) iflag |= VIXON;
	else iflag &= ~VIXON;
	if (par->c_iflag & IXANY) iflag |= VIXANY;
	else iflag &= ~VIXANY;
	if (par->c_oflag & OPOST) oflag |= VOPOST;
	else oflag &= ~VOPOST;
	if (par->c_oflag & ONLCR) oflag |= VONLCR;
	else oflag &= ~VONLCR;
	if (par->c_oflag & OXTABS) oflag |= VOXTABS;
	else oflag &= ~VOXTABS;
	if (par->c_lflag & ECHO) lflag |= VECHO;
	else lflag &= ~VECHO;
	if (par->c_lflag & ECHOE) lflag |= VECHOE;
	else lflag &= ~VECHOE;
	if (par->c_lflag & ICANON) lflag |= VICANON;
	else lflag &= ~VICANON;
	if (par->c_lflag & ISIG) lflag |= VISIG;
	else lflag &= ~VISIG;
#endif 
	pkt.command = CMD_IOCTL;
	pkt.ioctl_cmd_l = IOCTL_TCSETA;
	pkt.command_pipe_number = sc->channel_number;
	pkt.status_pipe_number = sc->channel_number;
	pkt.device_number = port;
	pkt.c_cflag = cflag;
#if 0
	pkt.c_iflag = iflag;
	pkt.c_oflag = oflag;
	pkt.c_lflag = lflag;
#endif
d956 2
a957 2
	bpp_send(sc, &pkt, WAIT_POLL);
	return imask;
d962 1
a962 1
	struct tty *tp;
d964 3
a966 3
	tp->t_state &= ~TS_FLUSH;
	if (tp->t_outq.c_cc != 0)
		vxstart(tp);
d971 1
a971 1
	struct tty *tp;
d973 40
a1012 38
	dev_t dev;
	struct vxsoftc *sc;
	struct wring *wp;
	int cc, port, unit, s, cnt, i;
	u_short get, put;
	char buffer[WRING_BUF_SIZE];

	dev = tp->t_dev;
	port = VX_PORT(dev);
	unit = VX_UNIT(dev);
	if (unit >= vx_cd.cd_ndevs || 
	    (sc = (struct vxsoftc *) vx_cd.cd_devs[unit]) == NULL) {
		return;
	}

	if ((tp->t_state & TS_ISOPEN) == 0)
		return;

	s = splvx();
	if ((tp->t_state & (TS_TIMEOUT | TS_BUSY | TS_TTSTOP | TS_FLUSH)) == 0) {
		tp->t_state |= TS_BUSY;
		wp = sc->sc_info[port].wringp;
		get = wp->get;
		put = wp->put;
		cc = tp->t_outq.c_cc;
		while (cc > 0) {
			cnt = min(WRING_BUF_SIZE, cc);
			cnt = q_to_b(&tp->t_outq, buffer, cnt);
			buffer[cnt] = 0;
			for (i=0; i<cnt; i++) {
				vxputc(sc, port, buffer[i]);
			}
			cc -= cnt;
		}
		tp->t_state &= ~TS_BUSY;
	}
	splx(s);
	return;
d1017 2
a1018 2
	struct vxsoftc *sc;
	int port;
d1020 21
a1040 20
	/* 
	 * This routine is called by vx_intr() when there are
	 * characters in the read ring.  It will process one 
	 * cooked line, put the chars in the line disipline ring,
	 * and then return.  The characters may then 
	 * be read by vxread.
	 */
	struct vx_info *vxt;
	struct rring *rp;
	struct tty *tp;
	u_short get, put;
	int frame_count, i, open;
	char c;

	vxt = &sc->sc_info[port];
	tp = vxt->tty;
	rp = vxt->rringp;
	open = vxt->open;
	get = rp->get;
	put = rp->put;
d1042 2
a1043 2
	printf("read_chars() get=%d, put=%d ", get, put);
	printf("open = %d ring at 0x%x\n", open, rp);
d1045 23
a1067 23
	while (get != put) {
		frame_count = rp->data[rp->get++ & (RRING_BUF_SIZE - 1)];
		rp->get &= (RRING_BUF_SIZE - 1);
		for (i=0; i<frame_count; i++) {
			c = rp->data[rp->get++ & (RRING_BUF_SIZE - 1)];
			rp->get &= (RRING_BUF_SIZE - 1);
			if (open)
				(*linesw[tp->t_line].l_rint)(c,tp);
		}
		c = rp->data[rp->get++ & (RRING_BUF_SIZE - 1)];
		rp->get &= (RRING_BUF_SIZE - 1);
		if (!(c & DELIMITER)) {
			vx_frame (sc, port);
			break;
		} else {
			break;
		}
		get = rp->get;
		put = rp->put;
	}
	vxt->read_pending = 0;
	read_wakeup(sc, port);
	return;
a1069 1
void
d1071 10
a1080 10
	struct vxsoftc *sc;
	int port;
	char c;
{
	struct vx_info *vxt;
	struct tty *tp;
	tp = vxt->tty;
	vxt = &sc->sc_info[port];
	tp = vxt->tty;
	(*linesw[tp->t_line].l_rint)(c,tp);
d1084 2
a1085 2
vx_intr(arg)
	void *arg;
d1087 4
a1090 4
	struct vxsoftc *sc = arg;
	struct envelope *envp, *next_envp;
	struct packet *pktp, pkt;
	int valid;
d1093 1
d1095 26
a1120 31
#if defined(MVME187) || defined(MVME197)
	struct vme2reg *vme2 = (struct vme2reg *)sc->sc_vme2;

	if (vme2->vme2_vbr & VME2_SYSFAIL) {
		/* do something... print_dump(sc); */
		
	}
#endif /* defined(MVME187) || defined(MVME197) */
	if (!cold) sc->sc_intrcnt.ev_count++;

	while (env_isvalid(get_status_head(sc))) {
		pktp = get_packet(sc, get_status_head(sc));
		valid = env_isvalid(get_status_head(sc));
		cmd = pktp->command;
		port = pktp->device_number;
		/* if we are waiting on this packet, strore the info so bpp_send 
		   can process the packet  */
		if (sc->sc_bppwait_pktp == pktp)
			memcpy2(&sc->sc_bppwait_pkt, pktp, sizeof(struct packet));

		memcpy2(&pkt, pktp, sizeof(struct packet));
		next_envp = get_next_envelope(get_status_head(sc));
		envp = get_status_head(sc);
		/* return envelope and packet to the free queues */
		put_free_envelope(sc, envp);
		put_free_packet(sc, pktp);
		/* mark new status pipe head pointer */
		set_status_head(sc, next_envp);
		/* if it was valid, process packet */
		switch (cmd) {
		case CMD_READW:
d1122 1
a1122 1
			printf("READW Packet\n");  
d1124 4
a1127 4
			read_chars(sc, port);          
			return 1;
			break;
		case CMD_WRITEW:
d1129 1
a1129 1
			printf("WRITEW Packet\n");  /* Still don't know XXXsmurph */
d1131 3
a1133 3
			return 1;
			break;
		case CMD_EVENT:
d1135 1
a1135 1
			printf("EVENT Packet\n");  
d1137 4
a1140 4
			vx_event(sc, &pkt);
			return 1;
			break;
		case CMD_PROCCESED:
d1142 1
a1142 1
			printf("CMD_PROCCESED Packet\n");
d1144 3
a1146 3
			return 1;
			break;
		default:
d1148 1
a1148 1
			printf("Other packet 0x%x\n", cmd);  
d1150 5
a1154 5
			return 1;
			break;
		}
	}
	return 1;
d1159 2
a1160 2
	struct vxsoftc *sc;
	struct packet *evntp;
d1162 60
a1221 64
	u_short code = evntp->event_code;
	struct event_packet evnt;
	struct vx_info *vxt;

	vxt = &sc->sc_info[evntp->device_number];

	if (code & E_INTR) {
		ccode(sc, evntp->device_number, CINTR);
	}
	if (code & E_QUIT) {
		ccode(sc, evntp->device_number, CQUIT);
	}
	if (code & E_HUP) {
		rts_ctl(sc, evntp->device_number, 0);
		dtr_ctl(sc, evntp->device_number, 0);
	}
	if (code & E_DCD) {
		vxt->vx_linestatus |= TIOCM_CD;
	}
	if (code & E_DSR) {
		vxt->vx_linestatus |= TIOCM_DSR;
	}
	if (code & E_CTS) {
		vxt->vx_linestatus |= TIOCM_CTS;
	}
	if (code & E_LOST_DCD) {
		vxt->vx_linestatus &= ~TIOCM_CD;
	}
	if (code & E_LOST_DSR) {
		vxt->vx_linestatus &= ~TIOCM_DSR;
	}
	if (code & E_LOST_CTS) {
		vxt->vx_linestatus &= ~TIOCM_CTS;
	}
	if (code & E_PR_FAULT) {
		/* do something... */
		
	}
	if (code & E_PR_POUT) {
		/* do something... */
		
	}
	if (code & E_PR_SELECT) {
		/* do something... */
		
	}
	if (code & E_SWITCH) {
		/* do something... */
		
	}
	if (code & E_BREAK) {
		vx_break (sc, evntp->device_number);
	}

	/* send and event packet backe to the device */
	bzero(&evnt, sizeof(struct event_packet));
	evnt.command = CMD_EVENT;
	evnt.device_number = evntp->device_number;
	evnt.command_pipe_number = sc->channel_number;
	/* return status on same channel */
	evnt.status_pipe_number = sc->channel_number;
	/* send packet to the firmware */
	bpp_send(sc, &evnt, NOWAIT);
	return 1;
d1226 4
a1229 4
	struct vxsoftc *sc;
	int port;
	long *ptime;
	u_char *msg;
d1231 2
a1232 2
	log(LOG_WARNING, "%s port %d: overrun\n", sc->sc_dev.dv_xname, port);
	return;
d1237 2
a1238 2
	struct vxsoftc *sc;
	int port;
d1240 2
a1241 2
	log(LOG_WARNING, "%s port %d: frame error\n", sc->sc_dev.dv_xname, port);
	return;
d1246 2
a1247 2
	struct vxsoftc *sc;
	int port;
d1250 1
a1250 1
	Debugger();
d1252 1
a1252 1
	log(LOG_WARNING, "%s port %d: break detected\n", sc->sc_dev.dv_xname, port);
d1254 1
a1254 1
	return;
d1265 1
a1265 1
void
d1268 9
a1276 9
	int i;
	short *d, *s;
	d = (short*) dest;
	s = (short*) src;
	for (i=0; i<(size/2); i++) {
		*d = *s;
		d++;
		s++;
	}
d1282 7
a1288 7
	int i;
	short *d;
	d = (short*) addr;
	for (i=0; i<(size/2); i++) {
		*d = 0;
		d++;
	}
d1295 34
a1328 32
	int i;
	struct envelope *envp;
	struct packet   *pktp;

	envp = (struct envelope *)ENVELOPE_AREA;
	sc->elist_head = envp;
	for (i=0; i < NENVELOPES; i++) {
		bzero(envp, sizeof(struct envelope));
		if (i==(NENVELOPES - 1)) {
			envp->link = NULL;
		} else {
			envp->link = (u_long)envp + sizeof(struct envelope);
		}
		envp->packet_ptr = NULL;
		envp->valid_flag = 0;
		envp++;
	}
	sc->elist_tail = --envp;

	pktp = (struct packet *)PACKET_AREA;
	sc->plist_head = pktp;
	for (i=0; i < NPACKETS; i++) {
		bzero(pktp, sizeof(struct packet));
		if (i==(NPACKETS - 1)) {
			pktp->link = NULL;
		} else {
			pktp->link = (u_long)pktp + sizeof(struct packet);
		}
		pktp++;
	}
	sc->plist_tail = --pktp;
	return 0; /* no error */
d1333 1
a1333 1
	struct vxsoftc *sc;
d1335 1
a1335 1
	void *envp;
d1337 4
a1340 4
	envp = sc->elist_head;
	sc->elist_head = (struct envelope *)sc->elist_head->link;
	bzero(envp, sizeof(struct envelope));
	return envp;
d1345 2
a1346 2
	struct vxsoftc *sc;
	void * ep;
d1348 5
a1352 5
	struct envelope *envp = (struct envelope *)ep;
	bzero(envp, sizeof(struct envelope));
	sc->elist_tail->link = (ulong)envp;
	envp->link = NULL;
	sc->elist_tail = envp;
d1357 1
a1357 1
	struct vxsoftc *sc;
d1359 1
a1359 1
	struct packet *pktp;
d1361 4
a1364 4
	pktp = sc->plist_head;
	sc->plist_head = (struct packet *)sc->plist_head->link;
	bzero(pktp, sizeof(struct packet));
	return pktp;
d1369 2
a1370 2
	struct vxsoftc *sc;
	void *pp;
d1372 6
a1377 6
	struct packet *pktp = (struct packet *)pp;
	/*bzero(pktp, sizeof(struct packet));*/
	pktp->command = CMD_PROCCESED;
	sc->plist_tail->link = (u_long)pktp;
	pktp->link = NULL;
	sc->plist_tail = pktp;
d1387 1
a1387 1
	struct vxsoftc *sc;
d1389 89
a1477 86
	struct envelope *envp;
	u_short status;
	u_short tas;
	struct vxreg *ipc_csr;

	ipc_csr = sc->vx_reg;
	/* wait for busy bit to clear */
	while ((ipc_csr->ipc_cr & IPC_CR_BUSY));
	create_free_queue(sc);
	/* set up channel header.  we only want one */
	tas = ipc_csr->ipc_tas;
	while (!(tas & IPC_TAS_VALID_STATUS)) {
		envp = get_free_envelope(sc);
		sc->channel->command_pipe_head_ptr_h = HI(envp);
		sc->channel->command_pipe_head_ptr_l = LO(envp);
		sc->channel->command_pipe_tail_ptr_h = sc->channel->command_pipe_head_ptr_h;
		sc->channel->command_pipe_tail_ptr_l = sc->channel->command_pipe_head_ptr_l;
		envp = get_free_envelope(sc);
		sc->channel->status_pipe_head_ptr_h = HI(envp);
		sc->channel->status_pipe_head_ptr_l = LO(envp);
		sc->channel->status_pipe_tail_ptr_h = sc->channel->status_pipe_head_ptr_h;
		sc->channel->status_pipe_tail_ptr_l = sc->channel->status_pipe_head_ptr_l;
		sc->channel->interrupt_level =  sc->sc_ipl;
		sc->channel->interrupt_vec = sc->sc_vec;
		sc->channel->channel_priority = 0;
		sc->channel->channel_number = 0;
		sc->channel->valid = 1;
		sc->channel->address_modifier = 0x8D; /* A32/D16 supervisor data access */
		sc->channel->datasize = 0; /* 32 bit data mode */

		/* loop until TAS bit is zero */
		while ((ipc_csr->ipc_tas & IPC_TAS_TAS)); 
		ipc_csr->ipc_tas |= IPC_TAS_TAS;
		/* load address of channel header */
		ipc_csr->ipc_addrh = HI(sc->channel);
		ipc_csr->ipc_addrl = LO(sc->channel);
		/* load address modifier reg (supervisor data access) */
		ipc_csr->ipc_amr = 0x8D;
		/* load tas with create channel command */
		ipc_csr->ipc_tas |= IPC_CSR_CREATE;
		/* set vaild command bit */
		ipc_csr->ipc_tas |= IPC_TAS_VALID_CMD;
		/* notify IPC of the CSR command */
		ipc_csr->ipc_cr |= IPC_CR_ATTEN;
		/* loop until IPC sets vaild status bit */
		delay(5000);
		tas = ipc_csr->ipc_tas;
	}

	/* save the status */
	status = ipc_csr->ipc_sr;
	/* set COMMAND COMPLETE bit */
	ipc_csr->ipc_tas |= IPC_TAS_COMPLETE;
	/* notify IPC that we are through */
	ipc_csr->ipc_cr |= IPC_CR_ATTEN;
	/* check and see if the channel was created */
	if (!status && sc->channel->valid) {
		sc->channel_number = sc->channel->channel_number;
		printf("%s: created channel %d\n", sc->sc_dev.dv_xname, 
		       sc->channel->channel_number);
		return 0;
	} else {
		switch (status) {
		case 0x0000:
			printf("%s: channel not valid\n", 
			       sc->sc_dev.dv_xname);
			break;
		case 0xFFFF:
			printf("%s: invalid CSR command\n", 
			       sc->sc_dev.dv_xname);
			break;
		case 0xC000:
			printf("%s: could not read channel structure\n", 
			       sc->sc_dev.dv_xname);
			break;
		case 0x8000:
			printf("%s: could not write channel structure\n", 
			       sc->sc_dev.dv_xname);
			break;
		default:
			printf("%s: unknown IPC CSR command error 0x%x\n", 
			       sc->sc_dev.dv_xname, status);
			break;
		}
		return status; /* error */
	}
d1482 1
a1482 1
	struct vxsoftc *sc;
d1484 4
a1487 3
	char *dump_area;
	char dump[209];
	bzero(&dump, 209);
d1489 4
a1492 4
	dump_area = (char *)0xff780030;
	memcpy2(&dump, dump_area, 208);

	printf("%s", dump);
d1497 1
a1497 1
	struct envelope *thisenv;
d1499 1
a1499 1
	return ((void *)thisenv->link);
d1504 1
a1504 1
	struct envelope *thisenv;
d1506 1
a1506 1
	return thisenv->valid_flag;
d1511 1
a1511 1
	struct vxsoftc *sc; 
d1513 4
a1516 4
	unsigned long retaddr;
	retaddr = (unsigned long)sc->vx_reg;
	retaddr += sc->channel->command_pipe_tail_ptr_l;
	return ((struct envelope *)retaddr);
d1521 1
a1521 1
	struct vxsoftc *sc;
d1523 4
a1526 4
	unsigned long retaddr;
	retaddr = (unsigned long)sc->vx_reg;
	retaddr += sc->channel->status_pipe_head_ptr_l;
	return ((struct envelope *)retaddr);
d1531 2
a1532 2
	struct vxsoftc *sc;
	void *envp;
d1534 3
a1536 3
	sc->channel->status_pipe_head_ptr_h = HI(envp);
	sc->channel->status_pipe_head_ptr_l = LO(envp);
	return;   
d1541 2
a1542 2
	struct vxsoftc *sc;
	struct envelope *thisenv;
d1544 2
a1545 1
	unsigned long baseaddr; 
d1547 10
a1556 10
	if (thisenv == NULL) return NULL;
	baseaddr = (unsigned long)sc->vx_reg;
	/* 
	 * packet ptr returned on status pipe is only last two bytes
	 * so we must supply the full address based on the board address.
	 * This also works for all envelopes because every address is an
	 * offset to the board address 
	 */
	baseaddr |= thisenv->packet_ptr;
	return ((void*)baseaddr);
d1565 23
a1587 20
	struct envelope *envp;
	struct packet *pktp;
	unsigned long newenv;


	/* load up packet in dual port mem */
	pktp = get_free_packet(sc);
	memcpy2(pktp, pkt, sizeof(struct packet));

	envp = get_cmd_tail(sc);
	newenv = (unsigned long)get_free_envelope(sc); /* put a NULL env on the tail */
	envp->link = newenv;
	sc->channel->command_pipe_tail_ptr_h = HI(newenv);
	sc->channel->command_pipe_tail_ptr_l = LO(newenv);
	envp->packet_ptr = (u_long)pktp;   /* add the command packet */
	envp->valid_flag = 1;		   /* set valid command flag */

	sc->vx_reg->ipc_cr |= IPC_CR_ATTEN;
	if (wait_flag) {		    /* wait for a packet to return */
		while (pktp->command != CMD_PROCCESED) {
d1589 1
a1589 1
			printf("Polling for packet 0x%x in envelope 0x%x...\n", pktp, envp);
d1591 7
a1597 7
			vx_intr(sc);
			delay(5000);
		}
		memcpy2(pkt, pktp, sizeof(struct packet));
		return 0;
	}
	return 0; /* no error */
a1602 1

d1605 1
a1605 1
	struct vxsoftc *sc;
d1607 24
a1630 24
	int i;
	struct init_info *infp, inf;
	struct wring *wringp;
	struct rring *rringp;
	struct termio def_termio;
	struct init_packet init;
	struct event_packet evnt;

	bzero(&def_termio, sizeof(struct termio));
	/* init wait queue */
	bzero(&sc->sc_bppwait_pkt, sizeof(struct packet));
	sc->sc_bppwait_pktp = NULL;
	/* set up init_info array */
	wringp = (struct wring *)WRING_AREA;
	rringp = (struct rring *)RRING_AREA;
	infp = (struct init_info *)INIT_INFO_AREA;
	for (i=0; i<9; i++) {
		bzero(&inf, sizeof(struct init_info));
		infp->write_ring_ptr_h = HI(wringp);
		infp->write_ring_ptr_l = LO(wringp);
		sc->sc_info[i].wringp = wringp;
		infp->read_ring_ptr_h = HI(rringp);
		infp->read_ring_ptr_l = LO(rringp);
		sc->sc_info[i].rringp = rringp;
d1632 1
a1632 1
		printf("write at 0x%8x, read at 0x%8x\n", wringp, rringp);
d1634 55
a1688 55
		infp->write_ring_size = WRING_DATA_SIZE;
		infp->read_ring_size = RRING_DATA_SIZE;
		infp->def_termio.c_iflag = VBRKINT;
		infp->def_termio.c_oflag = 0;
		infp->def_termio.c_cflag = (VB9600 | VCS8);

		infp->def_termio.c_lflag = VISIG; /* enable signal processing */
		infp->def_termio.c_line = 1; /* raw line disipline, we want to control it! */
		infp->def_termio.c_cc[0] = CINTR;
		infp->def_termio.c_cc[1] = CQUIT;
		infp->def_termio.c_cc[2] = CERASE;
		infp->def_termio.c_cc[3] = CKILL;
		infp->def_termio.c_cc[4] = 20;
		infp->def_termio.c_cc[5] = 2;
		infp->reserved1 = 0;  /* Must be Zero */
		infp->reserved2 = 0;
		infp->reserved3 = 0;
		infp->reserved4 = 0;
		wringp++; rringp++; infp++;
	}
	/* set up init_packet */
	bzero(&init, sizeof(struct init_packet));
	init.eye_catcher[0] = 0x12;
	init.eye_catcher[1] = 0x34;
	init.eye_catcher[2] = 0x56;
	init.eye_catcher[3] = 0x78;
	init.command = CMD_INIT;
	init.command_pipe_number = sc->channel_number;
	/* return status on the same channel */
	init.status_pipe_number = sc->channel_number;
	init.interrupt_level = sc->sc_ipl;
	init.interrupt_vec = sc->sc_vec;
	init.init_info_ptr_h = HI(INIT_INFO_AREA);
	init.init_info_ptr_l = LO(INIT_INFO_AREA);

	/* send packet to the firmware and wait for completion */
	bpp_send(sc, &init, WAIT_POLL);

	/* check for error */
	if (init.error_l !=0) {
		return init.error_l;
	} else {
		/* send one event packet to each device; */
		for (i=0; i<9; i++) {
			bzero(&evnt, sizeof(struct event_packet));
			evnt.command = CMD_EVENT;
			evnt.device_number = i;
			evnt.command_pipe_number = sc->channel_number;
			/* return status on same channel */
			evnt.status_pipe_number = sc->channel_number;
			/* send packet to the firmware */
			bpp_send(sc, &evnt, NOWAIT);
		}
		return 0;
	}
d1690 1
@


1.1.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.1.4.1 2001/04/18 16:11:10 niklas Exp $ */
d97 2
d901 1
a901 1
			/* disconnect, drop RTS DTR stop receiver */
@


1.1.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.1.4.2 2001/07/04 10:20:01 niklas Exp $ */
a41 2
#include <sys/syslog.h>

a43 2
#include <machine/psl.h>

a44 1

d46 1
a46 1

d49 2
a50 6
#include <mvme88k/dev/pcctworeg.h>
#include <mvme88k/dev/vme.h>
#endif

#ifdef	DDB
#include <ddb/db_var.h>
d53 1
d57 1
a57 1
#undef DEBUG
d59 1
d142 1
a142 13
void   vxputc __P((struct vxsoftc *sc, int port, u_char c));

struct tty * vxtty __P((dev_t));
short dtr_ctl __P((struct vxsoftc *, int, int));
short rts_ctl __P((struct vxsoftc *, int, int));
short flush_ctl __P((struct vxsoftc *, int, int));
u_short vxtspeed __P((int));
void read_chars __P((struct vxsoftc *, int));
void ccode __P((struct vxsoftc *, int, char));
void wzero __P((void *, size_t));
int create_free_queue __P((struct vxsoftc *));
void print_dump __P((struct vxsoftc *));
struct envelope *get_cmd_tail __P((struct vxsoftc *));
d155 1
d270 3
a272 3
	struct vxsoftc *sc;
	int port;
	int on;
d292 3
a294 3
	struct vxsoftc *sc;
	int port;
	int which;
d812 1
a812 1
void
d826 1
a826 2
u_short
vxtspeed(speed)
d1282 2
a1283 3
#ifdef DDB
	if (db_console != 0)
		Debugger();
d1326 1
a1326 1
	struct vxsoftc *sc;
d1714 1
@


1.1.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a49 1
#include <mvme88k/dev/vme.h>
d55 1
@


1.1.4.5
log
@Merge in trunk
@
text
@d200 2
d210 3
a212 1
	if (badvaddr((unsigned)&vx_reg->ipc_cr, 1))
d214 1
d216 3
d606 1
a606 1
	struct vx_info *volatile vxt;
d644 2
a645 2
	struct vx_info *volatile vxt;
	struct vxsoftc *volatile sc;
@


1.1.4.6
log
@Merge in -current from about a week ago
@
text
@d106 56
a161 56
void *get_next_envelope(struct envelope *thisenv);
struct envelope *get_status_head(struct vxsoftc *sc);
void set_status_head(struct vxsoftc *sc, void *envp);
struct packet *get_packet(struct vxsoftc *sc, struct envelope *thisenv);
struct envelope *find_status_packet(struct vxsoftc *sc, struct packet * pktp);

void read_wakeup(struct vxsoftc *sc, int port);
int  bpp_send(struct vxsoftc *sc, void *pkt, int wait_flag);

int  create_channels(struct vxsoftc *sc);
int  env_isvalid(struct envelope *thisenv);
void memcpy2(void *dest, const void *src, size_t size);
void *get_free_envelope(struct vxsoftc *sc);
void put_free_envelope(struct vxsoftc *sc, void *envp);
void *get_free_packet(struct vxsoftc *sc);
void put_free_packet(struct vxsoftc *sc, void *pktp);

int  vx_init(struct vxsoftc *sc);
int  vx_event(struct vxsoftc *sc, struct packet *evntp);

void vx_unblock(struct tty *tp);
int  vx_ccparam(struct vxsoftc *sc, struct termios *par, int port);

int  vx_param(struct tty *tp, struct termios *t);
int  vx_intr(void * arg);
int  vx_sintr(struct vxsoftc *sc);
int  vx_poll(struct vxsoftc *sc, struct packet *wpktp);
void vx_overflow(struct vxsoftc *sc, int port, long *ptime, u_char *msg);
void vx_frame(struct vxsoftc *sc, int port);
void vx_break( struct vxsoftc *sc, int port);
int  vx_mctl(dev_t dev, int bits, int how);

int  vxmatch(struct device *parent, void *self, void *aux);
void vxattach(struct device *parent, struct device *self, void *aux);

int  vxopen(dev_t dev, int flag, int mode, struct proc *p);
int  vxclose(dev_t dev, int flag, int mode, struct proc *p);
int  vxread(dev_t dev, struct uio *uio, int flag);
int  vxwrite(dev_t dev, struct uio *uio, int flag);
int  vxioctl(dev_t dev, int cmd, caddr_t data, int flag, struct proc *p);
void vxstart(struct tty *tp);
int  vxstop(struct tty *tp, int flag);

void   vxputc(struct vxsoftc *sc, int port, u_char c);

struct tty * vxtty(dev_t);
short dtr_ctl(struct vxsoftc *, int, int);
short rts_ctl(struct vxsoftc *, int, int);
short flush_ctl(struct vxsoftc *, int, int);
u_short vxtspeed(int);
void read_chars(struct vxsoftc *, int);
void ccode(struct vxsoftc *, int, char);
void wzero(void *, size_t);
int create_free_queue(struct vxsoftc *);
void print_dump(struct vxsoftc *);
struct envelope *get_cmd_tail(struct vxsoftc *);
d1315 2
a1316 2
	d = (short *) dest;
	s = (short *) src;
d1329 1
a1329 1
	d = (short *) addr;
d1398 1
a1398 1
void * 
d1594 1
a1594 1
	return ((void *)baseaddr);
@


1.1.4.7
log
@Sync the SMP branch with 3.3
@
text
@d34 1
d44 1
a45 2
#include <machine/conf.h>
#include <machine/cpu.h>
d141 5
d147 1
d724 1
a724 1
	u_long cmd;
@


1.1.4.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vx.c,v 1.1.4.7 2003/03/27 23:32:18 niklas Exp $ */
d6 1
d15 4
a18 1
 * 3. The name of the author may not be used to endorse or promote products
@


1.1.4.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d3 1
a3 1
 * Copyright (c) 1999 Steve Murphree, Jr.
d27 1
a27 1
 */
d49 9
d60 4
d70 1
d80 2
a81 1
	struct vx_info  sc_info[NVXPORTS];
d90 3
d100 1
a100 2
int  vxmatch(struct device *, void *, void *);
void vxattach(struct device *, struct device *, void *);
d102 52
a153 1
struct cfattach vx_ca = {
d155 1
a155 1
};
d158 5
a162 2
	NULL, "vx", DV_TTY
};
d164 2
a165 39
void	bpp_send(struct vxsoftc *, void *, int);
void	ccode(struct vxsoftc *, int, char);
int	create_channels(struct vxsoftc *);
void	create_free_queue(struct vxsoftc *);
short	dtr_ctl(struct vxsoftc *, int, int);
int	env_isvalid(struct envelope *);
struct envelope *find_status_packet(struct vxsoftc *, struct packet *);
short	flush_ctl(struct vxsoftc *, int, int);
struct envelope *get_cmd_tail(struct vxsoftc *);
void	*get_free_envelope(struct vxsoftc *);
void	*get_free_packet(struct vxsoftc *);
struct envelope *get_next_envelope(struct envelope *);
struct packet *get_packet(struct vxsoftc *, struct envelope *);
struct envelope *get_status_head(struct vxsoftc *);
void	put_free_envelope(struct vxsoftc *, void *);
void	put_free_packet(struct vxsoftc *, void *);
void	read_chars(struct vxsoftc *, int);
void	read_wakeup(struct vxsoftc *, int);
short	rts_ctl(struct vxsoftc *, int, int);
void	set_status_head(struct vxsoftc *, void *);
void	vx_break(struct vxsoftc *, int);
int	vx_ccparam(struct vxsoftc *, struct termios *, int);
int	vx_event(struct vxsoftc *, struct packet *);
void	vx_frame(struct vxsoftc *, int);
int	vx_init(struct vxsoftc *);
int	vx_intr(void *);
int	vx_mctl(dev_t, int, int);
void	vx_overflow(struct vxsoftc *, int, long *, u_char *);
int	vx_param(struct tty *, struct termios *);
int	vx_poll(struct vxsoftc *, struct packet *);
void	vxputc(struct vxsoftc *, int, u_char);
int	vx_sintr(struct vxsoftc *);
void	vxstart(struct tty *tp);
u_short	vxtspeed(int);
void	vx_unblock(struct tty *);

/* flags for bpp_send() */
#define	NOWAIT 0
#define	WAIT 1
d167 2
a168 5
#define VX_UNIT(x) (minor(x) / NVXPORTS)
#define VX_PORT(x) (minor(x) % NVXPORTS)

struct tty *
vxtty(dev_t dev)
a171 1

d173 2
a174 2
	if (unit >= vx_cd.cd_ndevs ||
	    (sc = (struct vxsoftc *)vx_cd.cd_devs[unit]) == NULL) {
d181 5
a185 2
int
vxmatch(struct device *parent, void *self, void *aux)
d189 6
a194 3

	ca->ca_ipl = IPL_TTY;
	ca->ca_len = 0x10000;	/* we know this */
d197 4
a200 2

	return (!badvaddr((vaddr_t)&vx_reg->ipc_cr, 1));
d204 4
a207 1
vxattach(struct device *parent, struct device *self, void *aux)
d211 2
a212 2

	/* set up dual port memory and registers and init */
d215 5
a219 2
	sc->sc_ipl = ca->ca_ipl;
	sc->sc_vec = ca->ca_vec;
d224 3
a226 3
	if (create_channels(sc) != 0) {
		printf("%s: failed to create channel %d\n",
		    sc->sc_dev.dv_xname, sc->channel->channel_number);
d229 1
a229 1
	if (vx_init(sc) != 0) {
d244 2
d247 4
a250 1
dtr_ctl(struct vxsoftc *sc, int port, int on)
a252 1

a264 1

d269 4
a272 1
rts_ctl(struct vxsoftc *sc, int port, int on)
a274 1

a286 1

a289 1
#if 0
d291 4
a294 1
flush_ctl(struct vxsoftc *sc, int port, int which)
a296 1

a304 1

a306 1
#endif
d308 4
a311 2
int
vx_mctl(dev_t dev, int bits, int how)
d320 1
a320 1
	sc = (struct vxsoftc *)vx_cd.cd_devs[unit];
d326 1
a326 1
		if (bits & TIOCM_RTS) {
d331 1
d334 1
a334 1
		if (bits & TIOCM_DTR) {
d343 1
a343 1
		if (bits & TIOCM_RTS) {
d347 1
a347 1
		if (bits & TIOCM_DTR) {
d354 1
a354 1
		if (bits & TIOCM_RTS) {
d358 1
a358 1
		if (bits & TIOCM_DTR) {
d367 1
a367 1
		if (msvr & TIOCM_DSR) {
d370 1
a370 1
		if (msvr & TIOCM_CD) {
d373 1
a373 1
		if (msvr & TIOCM_CTS) {
d376 1
a376 1
		if (msvr & TIOCM_DTR) {
d379 1
a379 1
		if (msvr & TIOCM_RTS) {
a385 2

#if 0
a391 1
#endif
d395 5
a399 2
int
vxopen(dev_t dev, int flag, int mode, struct proc *p)
d405 1
a405 1
	struct packet opkt;
d410 2
a411 1
	if (unit >= vx_cd.cd_ndevs ||
a414 1
	vxt = &sc->sc_info[port];
d416 1
a416 3
#if 0
	flush_ctl(sc, port, 2);
#endif
d419 4
a422 1
	opkt.link = 0x33333333;	/* eye catcher */
d428 1
a428 1
	bpp_send(sc, &opkt, WAIT);
d434 2
a435 2
#endif
		return (ENXIO);
d439 1
d441 1
a441 1
	s = splvx();
d445 1
a445 1
		tp = vxt->tty = ttymalloc();
d475 1
a475 1
			tp->t_ispeed = tp->t_ospeed = TTYDEF_SPEED;
d503 2
a504 1
	vxt->open = 1;
d506 1
a506 1
	return (*linesw[tp->t_line].l_open)(dev, tp);
d509 4
a512 2
int
vx_param(struct tty *tp, struct termios *t)
d520 1
a520 1
	if (unit >= vx_cd.cd_ndevs ||
d533 6
a538 2
int
vxclose(dev_t dev, int flag, int mode, struct proc *p)
d545 1
a545 2
	struct packet cpkt;

d547 1
a547 1
	if (unit >= vx_cd.cd_ndevs ||
d552 2
a554 4
#if 0
	flush_ctl(sc, port, 2);	/* flush both input and output */
#endif

a557 2
	s = splvx();

d563 2
d566 4
a569 1
	cpkt.link = 0x55555555;	/* eye catcher */
d574 1
a575 2

	vxt->open = 0;
d578 1
a578 1

d582 4
a585 2
void
read_wakeup(struct vxsoftc *sc, int port)
d587 1
a587 1
	struct packet rwp;
a588 1

d590 2
a591 2
	/*
	 * If we already have a read_wakeup paket
d594 1
a594 1
	if (vxt->read_pending != 0)
d596 1
a596 1
	else
d598 1
d601 4
a604 1
	rwp.link = 0x11111111;	/* eye catcher */
d612 1
a612 1
	 * to (*linesw[tp->t_line].l_rint)(c, tp); by
d618 5
a622 2
int
vxread(dev_t dev, struct uio *uio, int flag)
d630 1
a630 1
	if (unit >= vx_cd.cd_ndevs ||
d637 1
a637 2
	if (!tp)
		return ENXIO;
d641 5
a645 2
int
vxwrite(dev_t dev, struct uio *uio, int flag)
d652 1
a652 1
	struct packet wwp;
d656 1
a656 1
	if (unit >= vx_cd.cd_ndevs ||
d660 1
d664 1
a664 2
	if (!tp)
		return ENXIO;
d669 1
d672 4
a675 1
		wwp.link = 0x22222222;	/* eye catcher */
a679 1
		bpp_send(sc, &wwp, WAIT);
d681 26
a706 2
		if (wwp.error_l != 0)
			return (ENXIO);
a707 1

d709 1
a709 1
}
d712 6
a717 1
vxioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
a723 1

d725 1
a725 1
	if (unit >= vx_cd.cd_ndevs ||
d753 1
a753 1
		vx_mctl(dev, TIOCM_DTR | TIOCM_RTS, DMBIS);
d757 1
a757 1
		vx_mctl(dev, TIOCM_DTR | TIOCM_RTS, DMBIC);
d761 1
a761 1
		vx_mctl(dev, *(int *)data, DMSET);
d765 1
a765 1
		vx_mctl(dev, *(int *)data, DMBIS);
d769 1
a769 1
		vx_mctl(dev, *(int *)data, DMBIC);
d781 1
a781 1
		error = suser(p, 0);
d787 1
a787 1
		    (TIOCFLAG_SOFTCAR | TIOCFLAG_CLOCAL | TIOCFLAG_CRTSCTS);
a792 1

d797 3
a799 1
vxstop(struct tty *tp, int flag)
d813 4
a816 1
vxputc(struct vxsoftc *sc, int port, u_char c)
d821 3
a823 2
	wp->data[wp->put++ & (WRING_BUF_SIZE - 1)] = c;
	wp->put &= (WRING_BUF_SIZE - 1);
d827 2
a828 1
vxtspeed(int speed)
d833 1
d836 1
d839 1
d842 1
d845 1
d848 1
d851 1
d854 1
d857 1
d860 1
d863 1
d866 1
d869 1
d872 1
d875 1
d878 1
d881 1
d886 4
a889 1
vx_ccparam(struct vxsoftc *sc, struct termios *par, int port)
d891 4
a894 3
	int imask = 0, s;
	int cflag;
	struct packet pkt;
d898 6
a903 3
		/* disconnect, drop RTS DTR stop receiver */
		rts_ctl(sc, port, 0);
		dtr_ctl(sc, port, 0);
a907 1
	bzero(&pkt, sizeof(struct packet));
d913 1
a913 1
	bpp_send(sc, &pkt, WAIT);
d915 1
a915 1
	cflag = pkt.pb.tio.c_cflag;
d946 26
a971 1

d977 6
a982 2
	pkt.pb.tio.c_cflag = cflag;
	bpp_send(sc, &pkt, WAIT);
d984 1
d989 2
a990 1
vx_unblock(struct tty *tp)
d998 2
a999 1
vxstart(struct tty *tp)
d1011 1
a1011 1
	if (unit >= vx_cd.cd_ndevs ||
d1030 1
a1030 1
			for (i = 0; i < cnt; i++) {
d1038 1
d1041 4
a1044 2
void
read_chars(struct vxsoftc *sc, int port)
d1046 1
a1046 1
	/*
d1048 1
a1048 1
	 * characters in the read ring.  It will process one
d1050 1
a1050 1
	 * and then return.  The characters may then
d1069 1
a1069 1
#endif
d1073 1
a1073 1
		for (i = 0; i < frame_count; i++) {
d1077 1
a1077 1
				(*linesw[tp->t_line].l_rint)(c, tp);
d1082 1
a1082 1
			vx_frame(sc, port);
d1092 1
d1096 4
a1099 1
ccode(struct vxsoftc *sc, int port, char c)
a1102 1

d1104 3
a1106 1
	(*linesw[tp->t_line].l_rint)(c, tp);
d1110 2
a1111 1
vx_intr(void *arg)
d1117 2
a1118 2
	short cmd;
	u_char port;
d1120 9
a1128 1
	sc->sc_intrcnt.ev_count++;
d1135 2
a1136 4
		/*
		 * If we are waiting on this packet, store the info
		 * so bpp_send can process the packet
		 */
d1138 1
a1138 1
			d16_bcopy(pktp, &sc->sc_bppwait_pkt, sizeof(struct packet));
d1140 1
a1140 1
		d16_bcopy(pktp, &pkt, sizeof(struct packet));
d1152 4
a1155 3
			printf("READW Packet\n");
#endif
			read_chars(sc, port);
d1160 2
a1161 1
#endif
d1165 2
a1166 2
			printf("EVENT Packet\n");
#endif
d1168 1
d1170 1
a1170 1
		case CMD_PROCESSED:
d1172 3
a1174 2
			printf("CMD_PROCESSED Packet\n");
#endif
d1178 3
a1180 2
			printf("Other packet 0x%x\n", cmd);
#endif
d1187 4
a1190 2
int
vx_event(struct vxsoftc *sc, struct packet *evntp)
d1193 1
a1193 1
	struct packet evnt;
d1228 1
d1232 1
d1236 1
d1240 1
d1243 1
a1243 1
		vx_break(sc, evntp->device_number);
d1246 2
a1247 2
	/* send an event packet back to the device */
	bzero(&evnt, sizeof(struct packet));
a1254 1

d1259 5
a1263 1
vx_overflow(struct vxsoftc *sc, int port, long *ptime, u_char *msg)
d1265 2
a1266 2
	log(LOG_WARNING, "%s port %d: overrun\n",
	    sc->sc_dev.dv_xname, port);
d1270 3
a1272 1
vx_frame(struct vxsoftc *sc, int port)
d1274 2
a1275 2
	log(LOG_WARNING, "%s port %d: frame error\n",
	    sc->sc_dev.dv_xname, port);
d1279 3
a1281 1
vx_break(struct vxsoftc *sc, int port)
d1283 7
a1289 6
	/*
	 * No need to check for a ddb break, as the console can never be on
	 * this hardware.
	 */
	log(LOG_WARNING, "%s port %d: break detected\n",
	    sc->sc_dev.dv_xname, port);
d1296 4
d1301 1
a1301 1
create_free_queue(struct vxsoftc *sc)
d1304 29
a1332 2
	struct envelope *envp, env;
	struct packet *pktp, pkt;
d1336 9
a1344 9
	for (i = 0; i < NENVELOPES; i++) {
		bzero(&env, sizeof(struct envelope));
		if (i == NENVELOPES - 1)
			env.link = NULL;
		else
			env.link = (u_long)envp + sizeof(struct envelope);
		env.packet_ptr = NULL;
		env.valid_flag = 0;
		d16_bcopy(&env, envp, sizeof(struct envelope));
d1351 7
a1357 7
	for (i = 0; i < NPACKETS; i++) {
		bzero(&pkt, sizeof(struct packet));
		if (i == NPACKETS - 1)
			pkt.link = NULL;
		else
			pkt.link = (u_long)pktp + sizeof(struct packet);
		d16_bcopy(&pkt, pktp, sizeof(struct packet));
d1361 1
d1365 2
a1366 1
get_free_envelope(struct vxsoftc *sc)
a1368 1
	u_long link;
d1371 2
a1372 5
	/* pick envelope next pointer from the envelope itself */
	d16_bcopy((const void *)&sc->elist_head->link, &link, sizeof link);
	sc->elist_head = (struct envelope *)link;
	d16_bzero(envp, sizeof(struct envelope));

d1376 4
a1379 2
void
put_free_envelope(struct vxsoftc *sc, void *ep)
d1382 3
a1384 10
	u_long link;

#if 0
	d16_bzero(envp, sizeof(struct envelope));
#endif
	/* put envelope next pointer in the envelope itself */
	link = (u_long)envp;
	d16_bcopy(&link, (void *)&sc->elist_tail->link, sizeof link);
	d16_bzero((void *)&envp->link, sizeof envp->link);

d1388 3
a1390 2
void *
get_free_packet(struct vxsoftc *sc)
a1392 1
	u_long link;
d1395 2
a1396 5
	/* pick packet next pointer from the packet itself */
	d16_bcopy((const void *)&sc->plist_head->link, &link, sizeof link);
	sc->plist_head = (struct packet *)link;
	d16_bzero(pktp, sizeof(struct packet));

d1400 4
a1403 2
void
put_free_packet(struct vxsoftc *sc, void *pp)
d1406 4
a1409 11
	u_long link;

#if 0
	d16_bzero(pktp, sizeof(struct packet));
#endif
	pktp->command = CMD_PROCESSED;
	/* put packet next pointer in the packet itself */
	link = (u_long)pktp;
	d16_bcopy(&link, (void *)&sc->plist_tail->link, sizeof link);
	d16_bzero((void *)&pktp->link, sizeof pktp->link);

d1413 1
a1413 1
/*
d1415 2
a1416 2
 * was hell to come by.  Getting this right from the
 * Moto manual took *time*!
d1418 3
a1420 2
int
create_channels(struct vxsoftc *sc)
d1429 1
a1429 2
	while ((ipc_csr->ipc_cr & IPC_CR_BUSY)) ;

d1431 1
a1431 1
	/* set up channel header. we only want one */
d1437 2
a1438 4
		sc->channel->command_pipe_tail_ptr_h =
		    sc->channel->command_pipe_head_ptr_h;
		sc->channel->command_pipe_tail_ptr_l =
		    sc->channel->command_pipe_head_ptr_l;
d1442 3
a1444 5
		sc->channel->status_pipe_tail_ptr_h =
		    sc->channel->status_pipe_head_ptr_h;
		sc->channel->status_pipe_tail_ptr_l =
		    sc->channel->status_pipe_head_ptr_l;
		sc->channel->interrupt_level = sc->sc_ipl;
d1449 1
a1449 1
		sc->channel->address_modifier = 0x8d; /* A32/D16 supervisor data access */
d1453 1
a1453 1
		while ((ipc_csr->ipc_tas & IPC_TAS_TAS)) ;
d1459 1
a1459 1
		ipc_csr->ipc_amr = 0x8d;
d1466 1
a1466 2

		/* loop until IPC sets valid status bit */
d1480 1
a1480 1
		printf("%s: created channel %d\n", sc->sc_dev.dv_xname,
d1486 1
a1486 1
			printf("%s: channel not valid\n",
d1490 1
a1490 1
			printf("%s: invalid CSR command\n",
d1494 1
a1494 1
			printf("%s: could not read channel structure\n",
d1498 1
a1498 1
			printf("%s: could not write channel structure\n",
d1502 1
a1502 1
			printf("%s: unknown IPC CSR command error 0x%x\n",
d1506 1
a1506 1
		return 1;
d1510 3
a1512 2
struct envelope *
get_next_envelope(struct envelope *thisenv)
d1514 6
a1519 1
	u_long ptr;
d1521 2
a1522 1
	d16_bcopy((const void*)&thisenv->link, &ptr, sizeof ptr);
d1524 5
a1528 1
	return ((struct envelope *)ptr);
d1531 3
a1533 2
int
env_isvalid(struct envelope *thisenv)
d1535 1
a1535 1
	return (int)thisenv->valid_flag;
d1539 2
a1540 1
get_cmd_tail(struct vxsoftc *sc)
a1542 1

d1549 2
a1550 1
get_status_head(struct vxsoftc *sc)
a1552 1

d1559 3
a1561 1
set_status_head(struct vxsoftc *sc, void *envp)
d1565 1
d1569 3
a1571 1
get_packet(struct vxsoftc *sc, struct envelope *thisenv)
d1573 1
a1573 1
	u_long baseaddr;
d1575 3
a1577 4
	if (thisenv == NULL)
		return NULL;

	/*
d1581 1
a1581 1
	 * offset to the board address.
d1583 2
a1584 4
	d16_bcopy((const void *)&thisenv->packet_ptr, &baseaddr, sizeof baseaddr);
	baseaddr |= (u_long)sc->vx_reg;

	return ((struct packet *)baseaddr);
d1590 1
a1590 1
void
d1595 2
a1596 1
	u_long ptr;
d1600 1
a1600 1
	d16_bcopy(pkt, pktp, sizeof(struct packet));
d1603 6
a1608 7
	ptr = (unsigned long)get_free_envelope(sc); /* put a NULL env on the tail */
	d16_bcopy(&ptr, (void *)&envp->link, sizeof envp->link);
	sc->channel->command_pipe_tail_ptr_h = HI(ptr);
	sc->channel->command_pipe_tail_ptr_l = LO(ptr);
	ptr = (u_long)pktp;
	d16_bcopy(&ptr, (void *)&envp->packet_ptr, sizeof envp->packet_ptr);
	envp->valid_flag = 1;
d1611 2
a1612 4

	/* wait for a packet to return */
	if (wait_flag != NOWAIT) {
		while (pktp->command != CMD_PROCESSED) {
d1615 1
a1615 1
#endif
d1619 2
a1620 1
		d16_bcopy(pktp, pkt, sizeof(struct packet));
d1622 1
d1629 3
a1631 2
int
vx_init(struct vxsoftc *sc)
d1638 2
a1639 2
	struct packet init;
	struct packet evnt;
d1643 1
a1643 1
	d16_bzero(&sc->sc_bppwait_pkt, sizeof(struct packet));
d1649 1
a1649 1
	for (i = 0; i < NVXPORTS; i++) {
d1651 2
a1652 2
		inf.write_ring_ptr_h = HI(wringp);
		inf.write_ring_ptr_l = LO(wringp);
d1654 2
a1655 2
		inf.read_ring_ptr_h = HI(rringp);
		inf.read_ring_ptr_l = LO(rringp);
d1659 19
a1677 20
#endif
		inf.write_ring_size = WRING_DATA_SIZE;
		inf.read_ring_size = RRING_DATA_SIZE;
		inf.def_termio.c_iflag = VBRKINT;
		inf.def_termio.c_oflag = 0;
		inf.def_termio.c_cflag = (VB9600 | VCS8);

		inf.def_termio.c_lflag = VISIG; /* enable signal processing */
		inf.def_termio.c_line = 1; /* raw line discipline */
		inf.def_termio.c_cc[0] = CINTR;
		inf.def_termio.c_cc[1] = CQUIT;
		inf.def_termio.c_cc[2] = CERASE;
		inf.def_termio.c_cc[3] = CKILL;
		inf.def_termio.c_cc[4] = 20;
		inf.def_termio.c_cc[5] = 2;
		inf.reserved1 = 0;  /* Must Be Zero */
		inf.reserved2 = 0;
		inf.reserved3 = 0;
		inf.reserved4 = 0;
		d16_bcopy(&inf, infp, sizeof(struct init_info));
d1681 5
a1685 2
	bzero(&init, sizeof(struct packet));
	init.link = 0x12345678;	/* eye catcher */
d1696 4
a1699 2
	bpp_send(sc, &init, WAIT);
	if (init.error_l != 0)
d1701 13
a1713 11

	/* send one event packet to each device */
	for (i = 0; i < NVXPORTS; i++) {
		bzero(&evnt, sizeof(struct packet));
		evnt.command = CMD_EVENT;
		evnt.device_number = i;
		evnt.command_pipe_number = sc->channel_number;
		/* return status on same channel */
		evnt.status_pipe_number = sc->channel_number;
		/* send packet to the firmware */
		bpp_send(sc, &evnt, NOWAIT);
a1714 1
	return 0;
@


1.1.4.10
log
@Merge with the trunk
@
text
@a28 3
/* This card lives in D16 space */
#define	__BUS_SPACE_RESTRICT_D16__

d68 1
a68 1
	vaddr_t		board_vaddr;
d75 1
d77 1
d93 1
a93 1
int	bpp_send(struct vxsoftc *, void *, int);
d104 1
a104 1
struct envelope *get_next_envelope(struct vxsoftc *, struct envelope *);
a135 16
/*
 * Convert dual-ported physical addresse to host virtual address, and the
 * opposite.
 */
#define	VIRTUAL(addr)	(((addr) & 0xffff) + sc->board_vaddr)
#define	PHYSICAL(addr) \
	(((addr - sc->board_vaddr) & 0xffff) | LOCAL_DPMEM_ADDRESS)

#if 0
#define  LO(x) (u_short)((unsigned long)x & 0x0000FFFF)
#define  HI(x) (u_short)((unsigned long)x >> 16)
#else
#define	LO(x)	(u_short)(x)
#define	HI(x)	(LOCAL_DPMEM_ADDRESS >> 16)
#endif

a155 3
	bus_space_tag_t iot = ca->ca_iot;
	bus_space_handle_t ioh;
	int rc;
d157 4
a160 5
	if (bus_space_map(iot, ca->ca_paddr, 0x10000, 0, &ioh) != 0)
		return 0;
	vx_reg = (struct vxreg *)bus_space_vaddr(iot, ioh);
	rc = badvaddr((vaddr_t)&vx_reg->ipc_cr, 1);
	bus_space_unmap(iot, ioh, 0x10000);
d162 1
a162 1
	return rc == 0;
a169 14
	bus_space_tag_t iot = ca->ca_iot;
	bus_space_handle_t ioh;

	if (ca->ca_vec < 0) {
		printf(": no more interrupts!\n");
		return;
	}
	if (ca->ca_ipl < 0)
		ca->ca_ipl = IPL_TTY;

	if (bus_space_map(iot, ca->ca_paddr, 0x10000, 0, &ioh) != 0) {
		printf(": can't map registers!\n");
		return;
	}
d172 3
a174 3
	sc->board_vaddr = (vaddr_t)bus_space_vaddr(iot, ioh);
	sc->vx_reg = (struct vxreg *)sc->board_vaddr;
	sc->channel = (struct channel *)(sc->board_vaddr + 0x0100);
d176 1
d194 1
a194 1
	sc->sc_ih_c.ih_ipl = IPL_TTY;
d216 1
d218 1
a218 1
	return bpp_send(sc, &pkt, WAIT);
d237 1
d239 1
a239 1
	return bpp_send(sc, &pkt, WAIT);
d255 1
d257 1
a257 1
	return bpp_send(sc, &pkt, WAIT);
d351 1
a351 1
	int s, unit, port, error;
d371 1
d377 3
a379 1
	if ((error = bpp_send(sc, &opkt, WAIT)) != 0) {
d382 1
a382 1
		printf("error = %d\n", error);
d510 1
d541 1
d603 1
d608 3
a610 1
		if (bpp_send(sc, &wwp, WAIT))
d786 1
a786 2
	if (bpp_send(sc, &pkt, WAIT))
		return 0xff;
d826 1
a826 2
	if (bpp_send(sc, &pkt, WAIT))
		return 0xff;
d967 1
a967 1
		next_envp = get_next_envelope(sc, get_status_head(sc));
d1110 1
a1110 1
	envp = (struct envelope *)VIRTUAL(ENVELOPE_AREA);
d1112 1
a1112 1
	for (i = 1; i <= NENVELOPES; i++) {
d1114 1
a1114 1
		if (i == NENVELOPES)
d1117 1
a1117 1
			env.link = ENVELOPE_AREA + i * sizeof(struct envelope);
d1125 1
a1125 1
	pktp = (struct packet *)VIRTUAL(PACKET_AREA);
d1127 1
a1127 1
	for (i = 1; i <= NPACKETS; i++) {
d1129 1
a1129 1
		if (i == NPACKETS)
d1132 1
a1132 1
			pkt.link = PACKET_AREA + i * sizeof(struct packet);
d1142 2
a1143 2
	struct envelope *envp;
	paddr_t link;
d1147 2
a1148 2
	d16_bcopy((const void *)&envp->link, &link, sizeof link);
	sc->elist_head = (struct envelope *)VIRTUAL(link);
d1164 2
a1165 1
	link = PHYSICAL((vaddr_t)envp);
a1166 1
	d16_bcopy(&link, (void *)&sc->elist_tail->link, sizeof link);
d1175 1
a1175 1
	paddr_t link;
d1179 2
a1180 2
	d16_bcopy((const void *)&pktp->link, &link, sizeof link);
	sc->plist_head = (struct packet *)VIRTUAL(link);
d1197 2
a1198 1
	link = PHYSICAL((vaddr_t)pktp);
a1199 1
	d16_bcopy(&link, (void *)&sc->plist_tail->link, sizeof link);
d1212 1
a1212 1
	u_long envp;
d1215 1
a1215 1
	struct vxreg *ipc_csr = sc->vx_reg;
d1217 1
d1219 1
a1219 2
	while ((ipc_csr->ipc_cr & IPC_CR_BUSY))
		;
a1221 1

d1225 1
a1225 1
		envp = PHYSICAL((vaddr_t)get_free_envelope(sc));
d1232 1
a1232 1
		envp = PHYSICAL((vaddr_t)get_free_envelope(sc));
d1239 1
a1239 1
		sc->channel->interrupt_level = IPL_TTY;
d1248 1
a1248 2
		while ((ipc_csr->ipc_tas & IPC_TAS_TAS))
			;
d1251 2
a1252 2
		ipc_csr->ipc_addrh = HI(CHANNEL_H);
		ipc_csr->ipc_addrl = LO(CHANNEL_H);
d1274 1
a1274 1
	if (status == 0 && sc->channel->valid) {
a1275 1
#ifdef DEBUG_VXT
a1277 1
#endif
d1307 1
a1307 1
get_next_envelope(struct vxsoftc *sc, struct envelope *thisenv)
d1309 1
a1309 1
	paddr_t ptr;
d1313 1
a1313 1
	return (struct envelope *)VIRTUAL(ptr);
d1325 1
a1325 1
	paddr_t retaddr;
d1327 1
a1327 1
	retaddr = sc->channel->command_pipe_tail_ptr_h << 16;
d1329 1
a1329 1
	return (struct envelope *)VIRTUAL(retaddr);
d1335 1
a1335 1
	paddr_t retaddr;
d1337 1
a1337 1
	retaddr = sc->channel->status_pipe_head_ptr_h << 16;
d1339 1
a1339 1
	return (struct envelope *)VIRTUAL(retaddr);
d1345 2
a1346 5
	paddr_t ptr;

	ptr = PHYSICAL((vaddr_t)envp);
	sc->channel->status_pipe_head_ptr_h = HI(ptr);
	sc->channel->status_pipe_head_ptr_l = LO(ptr);
d1352 1
a1352 1
	paddr_t baseaddr;
d1364 3
a1366 1
	return (struct packet *)VIRTUAL(baseaddr);
d1372 1
a1372 1
int
d1377 1
a1377 2
	paddr_t ptr;
	int tmo;
d1384 2
a1385 1
	ptr = PHYSICAL((vaddr_t)get_free_envelope(sc)); /* put a NULL env on the tail */
d1388 1
a1388 2
	d16_bcopy(&ptr, (void *)&envp->link, sizeof envp->link);
	ptr = PHYSICAL((vaddr_t)pktp);
d1395 2
a1396 5
	if (wait_flag == NOWAIT)
		return 0;

	tmo = 0;
	while (pktp->command != CMD_PROCESSED) {
d1398 1
a1398 1
		printf("Polling for packet 0x%x in envelope 0x%x...\n", pktp, envp);
d1400 2
a1401 5
		vx_intr(sc);
		if (++tmo > 20) {
			printf("%s: bpp_send pkt %x env %x timed out %d\n",
			    sc->sc_dev.dv_xname, pktp, envp, pktp->command);
			return ETIMEDOUT;
d1403 1
a1403 1
		delay(5000);
a1404 2
	d16_bcopy(pktp, pkt, sizeof(struct packet));
	return pktp->error_l;
a1414 1
	int error;
d1416 3
a1418 1
	paddr_t wringp, rringp;
d1422 1
d1427 3
a1429 4
	wringp = WRING_AREA;
	rringp = RRING_AREA;
	infp = (struct init_info *)VIRTUAL(INIT_INFO_AREA);

d1434 1
a1434 1
		sc->sc_info[i].wringp = (struct wring *)VIRTUAL(wringp);
d1437 1
a1437 1
		sc->sc_info[i].rringp = (struct rring *)VIRTUAL(rringp);
d1453 6
a1458 2
		inf.def_termio.c_cc[4] = CEOF;
		inf.def_termio.c_cc[5] = CEOL;
d1460 1
a1460 3
		wringp += sizeof(struct wring);
		rringp += sizeof(struct rring);
		infp++;
a1461 1

d1464 1
d1469 1
a1469 1
	init.interrupt_level = IPL_TTY;
d1475 3
a1477 2
	if ((error = bpp_send(sc, &init, WAIT)) != 0)
		return error;
a1489 1

@


