head	1.29;
access;
symbols
	OPENBSD_5_5:1.28.0.6
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.28.0.2
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.27.0.6
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.4
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.2
	OPENBSD_5_0:1.26.0.2
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.25.0.2
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.24.0.6
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.24.0.2
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.24.0.4
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.23.0.6
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.4
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.23.0.2
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.22.0.4
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.22.0.2
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.21.0.2
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.18.0.2
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.14.0.4
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.8.0.8
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.8
	UBC:1.7.0.2
	UBC_BASE:1.7
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.3.0.10
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.8
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.6
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.4
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.1.1.1.0.8
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.6
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.4
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.2
	OPENBSD_2_1_BASE:1.1.1.1
	mvme88kport:1.1.1.1;
locks; strict;
comment	@ * @;


1.29
date	2014.03.18.22.36.36;	author miod;	state dead;
branches;
next	1.28;

1.28
date	2013.05.17.22.51.59;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2011.10.09.17.01.34;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2011.04.07.15.30.15;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2010.12.23.20.05.08;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2009.03.05.21.55.12;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2007.11.27.16.22.13;	author martynas;	state Exp;
branches;
next	1.22;

1.22
date	2007.02.11.12.41.29;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2006.07.07.19.36.50;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2006.05.06.16.59.28;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2006.04.27.20.19.28;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2005.12.11.21.45.31;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2005.11.25.22.14.31;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2005.10.13.19.48.35;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2005.09.25.20.55.15;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2004.11.09.15.02.23;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2004.08.02.08.35.00;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2004.05.07.18.10.28;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2004.04.24.19.51.48;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2004.01.14.20.50.48;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2003.09.16.20.46.08;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.39;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.12.19.07.04.41;	author smurph;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.12.16.23.49.46;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2001.12.13.08.55.51;	author smurph;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.26.02.37.07;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	99.05.29.04.41.44;	author smurph;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	98.12.15.05.52.30;	author smurph;	state Exp;
branches;
next	1.1;

1.1
date	97.03.03.19.32.05;	author rahnds;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.03.03.19.32.05;	author rahnds;	state Exp;
branches;
next	;

1.3.4.1
date	2001.10.31.03.01.18;	author nate;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2002.03.06.02.04.44;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2002.03.28.10.36.02;	author niklas;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2004.02.19.10.49.06;	author niklas;	state Exp;
branches;
next	1.3.4.5;

1.3.4.5
date	2004.06.05.23.09.49;	author niklas;	state Exp;
branches;
next	;

1.7.2.1
date	2002.06.11.03.37.09;	author art;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: mainbus.c,v 1.28 2013/05/17 22:51:59 miod Exp $ */
/*
 * Copyright (c) 1998 Steve Murphree, Jr.
 * Copyright (c) 2004, Miodrag Vallat.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/reboot.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/disklabel.h>
#include <sys/extent.h>
#include <sys/malloc.h>

#include <uvm/uvm_extern.h>

#include <machine/bus.h>
#include <machine/autoconf.h>
#include <machine/cmmu.h>
#include <machine/cpu.h>

#ifdef M88100
#include <machine/m8820x.h>
#endif
#ifdef MVME181
#include <machine/mvme181.h>
#endif
#ifdef MVME187
#include <machine/mvme187.h>
#endif
#ifdef MVME188
#include <machine/mvme188.h>
#endif
#ifdef MVME197
#include <machine/mvme197.h>
#endif

void	mainbus_attach(struct device *, struct device *, void *);
int 	mainbus_match(struct device *, void *, void *);
int	mainbus_print(void *, const char *);
int	mainbus_scan(struct device *, void *, void *);

/*
 * bus_space routines for 1:1 obio mappings
 */

int	mainbus_map(bus_addr_t, bus_size_t, int, bus_space_handle_t *);
void	mainbus_unmap(bus_space_handle_t, bus_size_t);
int	mainbus_subregion(bus_space_handle_t, bus_size_t, bus_size_t,
	    bus_space_handle_t *);
void	*mainbus_vaddr(bus_space_handle_t);

const struct mvme88k_bus_space_tag mainbus_bustag = {
	mainbus_map,
	mainbus_unmap,
	mainbus_subregion,
	mainbus_vaddr
};

bus_addr_t	 bs_obio_start;
bus_addr_t	 bs_obio_end;
struct extent	*bs_extent;

/*
 * Obio (internal IO) space is mapped 1:1 (see pmap_bootstrap() for details).
 *
 * However, sram attaches as a child of mainbus, but does not reside in
 * internal IO space. As a result, we have to allow both 1:1 and regular
 * translations, depending upon the address to map.
 */

int
mainbus_map(bus_addr_t addr, bus_size_t size, int flags,
    bus_space_handle_t *ret)
{
	vaddr_t map;

	map = mapiodev((paddr_t)addr, size);
	if (map == 0)
		return ENOMEM;

	*ret = (bus_space_handle_t)map;
	return 0;
}

void
mainbus_unmap(bus_space_handle_t handle, bus_size_t size)
{
	/* XXX what to do for non-obio mappings? */
}

int
mainbus_subregion(bus_space_handle_t handle, bus_addr_t offset,
    bus_size_t size, bus_space_handle_t *ret)
{
	*ret = handle + offset;
	return (0);
}

void *
mainbus_vaddr(bus_space_handle_t handle)
{
	return (void *)handle;
}

/*
 * Map a range [pa, pa+size) in the given map to a kernel address
 * in iomap space.
 *
 * Note: To be flexible, I did not put a restriction on the alignment
 * of pa. However, it is advisable to have pa page aligned since otherwise,
 * we might have several mappings for a given chunk of the IO page.
 */
vaddr_t
mapiodev(paddr_t addr, int _size)
{
	vaddr_t	va, iova, off;
	paddr_t pa, epa;
	psize_t size;
	int s, error;

	/* sanity checks */
	if (_size <= 0)
		return 0;
	size = (psize_t)_size;
	epa = addr + size;
	if (epa < addr && epa != 0)
		return 0;

	/* check for 1:1 mapping */
	if (addr >= bs_obio_start) {
		if (bs_obio_end == 0 || epa <= bs_obio_end)
			return ((vaddr_t)addr);
		else if (addr <= bs_obio_end)
			/* across obio and non-obio, not supported */
			return 0;
	}

	pa = trunc_page(addr);
	off = addr & PGOFSET;
	size = round_page(off + size);

	s = splhigh();
	error = extent_alloc_region(bs_extent, atop(pa), atop(size),
	    EX_MALLOCOK | (cold ? 0 : EX_WAITSPACE));
	splx(s);

	if (error != 0)
		return 0;

	va = uvm_km_valloc(kernel_map, size);
	if (va == 0) {
		extent_free(bs_extent, atop(pa), atop(size),
		    EX_MALLOCOK | (cold ? 0 : EX_WAITSPACE));
		return 0;
	}

	iova = va + off;
	while (size != 0) {
		pmap_enter(pmap_kernel(), va, pa, UVM_PROT_RW,
		    UVM_PROT_RW | PMAP_WIRED);
		size -= PAGE_SIZE;
		va += PAGE_SIZE;
		pa += PAGE_SIZE;
	}
	pmap_update(pmap_kernel());

	return (iova);
}

/*
 * Free up the mapping in iomap.
 */
void
unmapiodev(vaddr_t va, int _size)
{
	vaddr_t eva, kva, off;
	vsize_t size;
	paddr_t pa;
	int s, error;

	/* sanity checks */
	if (_size <= 0)
		return;
	size = (vsize_t)_size;
	eva = va + size;
	if (eva < va && eva != 0)
		return;

	/* check for 1:1 mapping */
	if (va >= bs_obio_start) {
		if (bs_obio_end == 0 || eva <= bs_obio_end)
			return;
		else if (va <= bs_obio_end)
			/* across obio and non-obio, not supported */
			return;
	}

	off = va & PGOFSET;
	kva = trunc_page(va);
	size = round_page(off + size);

	if (pmap_extract(pmap_kernel(), kva, &pa) == FALSE)
		panic("unmapiodev(%p,%p)", kva, size);

	pmap_remove(pmap_kernel(), kva, kva + size);
	pmap_update(pmap_kernel());
	uvm_km_free(kernel_map, kva, size);

	s = splhigh();
	error = extent_free(bs_extent, atop(pa), atop(size),
	    EX_MALLOCOK | (cold ? 0 : EX_WAITSPACE));
#ifdef DIAGNOSTIC
	if (error != 0)
		printf("unmapiodev(%p pa %p, %p): extent_free failed\n",
		    kva, pa, size);
#endif
	splx(s);
}

/*
 * Configuration glue
 */

struct cfattach mainbus_ca = {
	sizeof(struct device), mainbus_match, mainbus_attach
};

struct cfdriver mainbus_cd = {
	NULL, "mainbus", DV_DULL
};

int
mainbus_match(struct device *parent, void *cf, void *args)
{
	return (1);
}

int
mainbus_print(void *args, const char *bus)
{
	struct confargs *ca = args;

	if (ca->ca_paddr != -1)
		printf(" addr 0x%x", ca->ca_paddr);
	return (UNCONF);
}

int
mainbus_scan(struct device *parent, void *child, void *args)
{
	struct cfdata *cf = child;
	struct confargs oca;

	bzero(&oca, sizeof oca);
	oca.ca_iot = &mainbus_bustag;
	oca.ca_dmat = 0;	/* XXX no need for a meaningful value yet */
	oca.ca_bustype = BUS_MAIN;
	oca.ca_paddr = cf->cf_loc[0];
	oca.ca_ipl = -1;
	oca.ca_name = cf->cf_driver->cd_name;
	if ((*cf->cf_attach->ca_match)(parent, cf, &oca) == 0)
		return (0);
	config_attach(parent, cf, &oca, mainbus_print);
	return (1);
}

void
mainbus_attach(struct device *parent, struct device *self, void *args)
{
	extern char cpu_model[];

	printf(": %s\n", cpu_model);

	/*
	 * Display cpu/mmu details for the main processor.
	 */
	cpu_configuration_print(1);

	/*
	 * Initialize an extent to keep track of I/O mappings.
	 */
#ifdef M88100
	if (CPU_IS88100) {
		switch (brdtyp) {
#ifdef MVME181
		case BRD_180:
		case BRD_181:
			bs_obio_start = M181_OBIO_START;
			bs_obio_end = 0;
			break;
#endif
		default:
			bs_obio_start = BATC8_VA;	/* hardwired BATC */
			bs_obio_end = 0;
			break;
		}
	}
#endif
#ifdef MVME197
	if (CPU_IS88110) {
		bs_obio_start = OBIO197_START;
		bs_obio_end = OBIO197_START + OBIO197_SIZE;
	}
#endif
	bs_extent = extent_create("bus_space", atop(physmem),
	    1 + atop(0U - PAGE_SIZE), M_DEVBUF, NULL, 0, EX_NOWAIT);
	if (bs_extent == NULL)
		panic("unable to allocate bus_space extent");

	(void)config_search(mainbus_scan, self, args);
}
@


1.28
log
@Preliminary support for MVME180 and MVME181 boards. On-board serial ports
and VME controller are supported; tod chip isn't supported yet (coming soon).
MVME236 memory boards are not supported and won't likely be (unless I get my
hands on one).

MVME181-1 boots multiuser (slowly) with MVME328 SCSI and MVME376 Ethernet
despite only having 8MB of memory onboard.

MVME180 untested; might need tweaking to get MVME SCSI and Ethernet boards
supported.

Many thanks to Matti Nummi for lending me an MVME181 board.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.27 2011/10/09 17:01:34 miod Exp $ */
@


1.27
log
@Rework secondary processor initialization. cmmu initialization is now
performed much earlier in the processor startup.
No visible change, paves the way for the much important diff three commits
from here.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.26 2011/04/07 15:30:15 miod Exp $ */
d47 3
d307 13
a319 2
		bs_obio_start = BATC8_VA;	/* hardwired BATC */
		bs_obio_end = 0;
@


1.26
log
@Do not use NULL in integer comparisons. No functional change.
ok matthew@@ tedu@@, also eyeballed by at least krw@@ oga@@ kettenis@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.25 2010/12/23 20:05:08 miod Exp $ */
a289 1
	extern void cpu_hatch_secondary_processors(void *);
a317 12

#ifdef MULTIPROCESSOR
	/*
	 * Spin up the other processors, but do not give them work to
	 * do yet.
	 * On MVME188 boards, the system hangs if secondary processors
	 * try to issue BUG calls (i.e. when printing their information
	 * on console), so we postpone this to the end of autoconf.
	 */
	if (brdtyp != BRD_188)
		cpu_hatch_secondary_processors(NULL);
#endif
@


1.25
log
@The exception vector page on m88k systems has always been the same page as
the one used by the firmware, which (at least on mvme88k) is at address zero.

This is unfortunate, since this means that NULL pointer dereferences in the
kernel are not caught, and writes cause havoc.

This behaviour was necessary to be able to use the PROM system call interface
during early bootstrap, without having to disassemble the VBR page and
update branches - which use pc-relative displacement - if we were to use
a different VBR address.

On mvme88k, change this and actually set up two VBR pages: one, over the PROM
page (except for the system call vectors), and another one in the kernel
image (which will be mapped read-only). We'll run with the PROM page until
the end of autoconf, and then switch to the kernel one, and unmap all the
PROM below it.

As a bonus, the final kernel page can use optimized data access fault
handlers, which do not have to check for faults caused by badaddr(), since
badaddr() is only used during device probe on buses which do not support
hotplug.

There are a few infrastructure collateral damage on aviion and luna88k, but
these ports do not change their behaviour yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.24 2009/03/05 21:55:12 miod Exp $ */
d98 1
a98 1
	if (map == NULL)
d143 1
a143 1
		return NULL;
d147 1
a147 1
		return NULL;
d155 1
a155 1
			return NULL;
d168 1
a168 1
		return NULL;
d174 1
a174 1
		return NULL;
@


1.24
log
@Change SMP secondary processor startup to have them ``hatch'' earlier,
so that they can invoke sched_init_cpu() before the scheduler starts,
which allows the horrible kluge in cpu_configure() to die.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.23 2007/11/27 16:22:13 martynas Exp $ */
d328 1
a328 3
	if (brdtyp == BRD_188)
		startuphook_establish(cpu_hatch_secondary_processors, NULL);
	else
@


1.23
log
@typos;  ok jmc@@
sys/dev/pci/pciide.c from naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.22 2007/02/11 12:41:29 miod Exp $ */
d290 1
d319 14
@


1.22
log
@Rework the i/o mapping logic so that it allows the 1:1 region to not go up to
the end of the address space; allows the A16D16 VME space to be mapped
correctly again on MVME197.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.21 2006/07/07 19:36:50 miod Exp $ */
d154 1
a154 1
			/* accross obio and non-obio, not supported */
d214 1
a214 1
			/* accross obio and non-obio, not supported */
@


1.21
log
@Get rid of the fixed iomap for device mappings, and allocated va ranges
off kernel_map whenever necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.20 2006/05/06 16:59:28 miod Exp $ */
d79 2
a80 1
bus_addr_t	 bs_threshold;
d134 1
a134 3
mapiodev(addr, size)
	paddr_t addr;
	int size;
d137 2
a138 1
	paddr_t pa;
d141 6
a146 1
	if (size <= 0)
d149 8
a156 2
	if (addr >= bs_threshold)
		return ((vaddr_t)addr);
d163 1
a163 1
	error = extent_alloc_region(bs_extent, pa, size,
d172 1
a172 1
		extent_free(bs_extent, pa, size,
d194 1
a194 3
unmapiodev(va, size)
	vaddr_t va;
	int size;
d196 2
a197 1
	vaddr_t kva, off;
d201 6
a206 1
	if (va >= bs_threshold)
d209 9
d230 1
a230 1
	error = extent_free(bs_extent, pa, size,
d253 1
a253 4
mainbus_match(parent, cf, args)
	struct device *parent;
	void *cf;
	void *args;
d259 1
a259 3
mainbus_print(args, bus)
	void *args;
	const char *bus;
d269 1
a269 3
mainbus_scan(parent, child, args)
	struct device *parent;
	void *child, *args;
d288 1
a288 3
mainbus_attach(parent, self, args)
	struct device *parent, *self;
	void *args;
d303 4
a306 2
	if (CPU_IS88100)
		bs_threshold = BATC8_VA;	/* hardwired BATC */
d309 4
a312 2
	if (CPU_IS88110)
		bs_threshold = OBIO197_START;
d314 2
a315 2
	bs_extent = extent_create("bus_space", physmem,
	    bs_threshold, M_DEVBUF, NULL, 0, EX_NOWAIT);
@


1.20
log
@On 88100-based systems, take the two hardwired BATC into account in
pmap_extract(), and do not bother creating regular page table mappings
for obio regions which are covered by these BATC entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.19 2006/04/27 20:19:28 miod Exp $ */
d35 1
d79 2
a80 2
extern struct extent *iomap_extent;
extern struct vm_map *iomap_map;
d86 1
a86 1
 * internal IO space. As a result, we have to allow both 1:1 and iomap
a94 18
	static bus_addr_t threshold = 0;

	if (threshold == 0) {
#ifdef M88100
		if (CPU_IS88100)
			threshold = BATC8_VA;	/* hardwired BATC */
#endif
#ifdef MVME197
		if (CPU_IS88110)
			threshold = OBIO197_START;
#endif
	}

	if (addr >= threshold)
		map = (vaddr_t)addr;
	else {
		map = mapiodev((paddr_t)addr, size);
	}
d96 1
d125 1
a125 1
 * Map a range [pa, pa+size] in the given map to a kernel address
d133 2
a134 2
mapiodev(pa, size)
	paddr_t pa;
d137 2
a138 2
	vaddr_t	iova, tva, off;
	paddr_t ppa;
d144 5
a148 2
	ppa = trunc_page(pa);
	off = pa & PGOFSET;
d152 2
a153 2
	error = extent_alloc(iomap_extent, size, PAGE_SIZE, 0, EX_NOBOUNDARY,
	    EX_WAITSPACE, &iova);
d159 8
a166 1
	tva = iova;
d168 2
a169 3
		pmap_enter(vm_map_pmap(iomap_map), tva, ppa,
			   VM_PROT_WRITE | VM_PROT_READ,
			   VM_PROT_WRITE | VM_PROT_READ | PMAP_WIRED);
d171 2
a172 2
		tva += PAGE_SIZE;
		ppa += PAGE_SIZE;
d174 1
a174 1
	pmap_update(vm_map_pmap(iomap_map));
d176 1
a176 1
	return (iova + off);
d188 1
d191 3
d198 6
a203 2
	pmap_remove(vm_map_pmap(iomap_map), kva, kva + size);
	pmap_update(vm_map_pmap(iomap_map));
d206 2
a207 1
	error = extent_free(iomap_extent, kva, size, EX_NOWAIT);
d210 2
a211 1
		printf("unmapiodev: extent_free failed\n");
d283 16
@


1.19
log
@Adjust sizes for the mandatory 1:1 mappings created in pmap_bootstrap().
Saves up to 12KB of no longer necessary page tables.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.18 2005/12/11 21:45:31 miod Exp $ */
d43 3
d97 3
a99 11
		switch (brdtyp) {
#ifdef MVME188
		case BRD_188:
			threshold = MVME188_UTILITY;
			break;
#endif
#ifdef MVME187
		case BRD_187:
		case BRD_8120:
			threshold = OBIO187_START;
			break;
d102 2
a103 1
		case BRD_197:
a104 3
			threshold = OBIO197_START;
			break;
		}
a279 6

	/* XXX
	 * should have a please-attach-first list for mainbus,
	 * to ensure that the pcc/vme2/mcc chips are attached
	 * first.
	 */
@


1.18
log
@Work in progress SMP code; mvme88k boards can spin up secondary CPUs,
kernel boots single user. Still a lot of polishing and bugfixing to do.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.17 2005/11/25 22:14:31 miod Exp $ */
d43 3
d49 2
a50 2
#if defined(MVME187) || defined(MVME197)
#include <machine/mvme1x7.h>
d103 2
d109 1
a109 1
			threshold = OBIO_START;
@


1.17
log
@Prefer vaddr_t and paddr_t types, instead of void * and heavy casts.
Improves readability, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.16 2005/10/13 19:48:35 miod Exp $ */
d279 1
a279 1
	 * Display cpu/mmu details. Only for the master CPU so far.
@


1.16
log
@Merge <machine/cpu_number.h> into <machine/cpu.h>, preparing for intrusive
changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.15 2005/09/25 20:55:15 miod Exp $ */
a74 3
void	*mapiodev(void *, int);
void	unmapiodev(void *, int);

d112 1
a112 1
		map = (vaddr_t)mapiodev((void *)addr, size);
d150 1
a150 1
void *
d152 1
a152 1
	void *pa;
d162 2
a163 2
	ppa = trunc_page((paddr_t)pa);
	off = (paddr_t)pa & PGOFSET;
d185 1
a185 1
	return (void *)(iova + off);
d193 1
a193 1
	void *va;
d199 2
a200 2
	off = (vaddr_t)va & PGOFSET;
	kva = trunc_page((vaddr_t)va);
@


1.15
log
@Change the size parameter of cmmu_flush_tlb() from bytes to pages. This makes
things easier for the callers, and allows us to inline the "fewer than 4 pages"
situation for speed.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.14 2004/11/09 15:02:23 miod Exp $ */
a41 1
#include <machine/cpu_number.h>
@


1.14
log
@Luna88k does not have an iomap, so kill all iomap related defines, and
move the mapiodev()/unmapiodev() code back to mvme88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.13 2004/08/02 08:35:00 miod Exp $ */
a176 2

	cmmu_flush_tlb(cpu_number(), 1, iova, size);	/* necessary? */
@


1.13
log
@More include files cleaning:
- move MAX_CPUS constant to <machine/cpu.h>
- do not include <machine/board.h> unless needed. In fact, remove this file
  entirely on mvme88k, and include <machine/mvme*.h> on a
  compiling-for-this-board basis
- keep MAX_CMMUS constant private to the m8820x code
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.12 2004/05/07 18:10:28 miod Exp $ */
d34 3
d42 1
d73 6
a115 3
#if 0
		map = iomap_mapin(addr, size, 0);
#else
a116 1
#endif
d144 75
@


1.12
log
@bus_dma(9) implementation for mvme88k, mostly based upon powerpc.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.11 2004/04/24 19:51:48 miod Exp $ */
a36 1
#include <machine/board.h>
d39 7
@


1.11
log
@Preliminary switch to an mvme88k bus_space world. Not all drivers have been
converted yet, and they rely upon some linear mappings provided by bus_space.

In order to not impact performance, almost all the bus_space accesses go
through macros and inline functions. This currently restricts us to D16 and
D32 access modes, which are selected at compilation time. Since there are no
plans to support D8 vme devices in the future, this is acceptable for now.

This makes the "len" locator for vme devices go away, and allows to simplify
some code which was using the pcctwo device, and will now directly access
hardware which is known to exist, rather than wait until the device is
attached.

While there, try to enforce more interrupt vector number checks, since these
changes pointed out that dart(4) had been working correctly so far by sheer
luck only.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.10 2004/01/14 20:50:48 miod Exp $ */
d177 1
@


1.10
log
@Do not fill more than the first three fields of cfdriver structures unless
necessary. No functional change.
@
text
@d1 27
a27 2
/*	$OpenBSD: mainbus.c,v 1.9 2003/09/16 20:46:08 miod Exp $ */
/*  Copyright (c) 1998 Steve Murphree, Jr. */
d35 3
a39 1
#include <machine/autoconf.h>
d41 96
a136 4
void mainbus_attach(struct device *, struct device *, void *);
int  mainbus_match(struct device *, void *, void *);
int mainbus_print(void *, const char *);
int mainbus_scan(struct device *, void *, void *);
d162 2
a163 2
	if (ca->ca_paddr != (void *)-1)
		printf(" addr 0x%x", (u_int32_t)ca->ca_paddr);
d176 3
a178 2
	oca.ca_paddr = (void *)cf->cf_loc[0];
	oca.ca_vaddr = (void *)-1;
a179 1
	oca.ca_bustype = BUS_MAIN;
@


1.9
log
@Provide more information about the CPU/CMMU configuration in the dmesg
output. Also, if the board configuration parameter area is invalid, warn the
user and assume safe values - this is likely caused by a dead NVRAM battery.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.8 2002/03/14 01:26:39 millert Exp $ */
d24 1
a24 1
	NULL, "mainbus", DV_DULL, 0
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.7 2001/12/19 07:04:41 smurph Exp $ */
d10 1
d73 8
a80 1
	printf (" machine type MVME%x\n", brdtyp);
@


1.7
log
@Introduce brdtyp and change what cputyp means.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.6 2001/12/16 23:49:46 miod Exp $ */
d13 4
a16 4
void mainbus_attach __P((struct device *, struct device *, void *));
int  mainbus_match __P((struct device *, void *, void *));
int mainbus_print __P((void *, const char *));
int mainbus_scan __P((struct device *, void *, void *));
@


1.7.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.7 2001/12/19 07:04:41 smurph Exp $ */
d13 4
a16 4
void mainbus_attach(struct device *, struct device *, void *);
int  mainbus_match(struct device *, void *, void *);
int mainbus_print(void *, const char *);
int mainbus_scan(struct device *, void *, void *);
@


1.6
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.4 2001/08/26 02:37:07 miod Exp $ */
d72 1
a72 1
	printf (" machine type MVME%x\n", cputyp);
@


1.5
log
@Support for MVME197 completed.  Fix SPL defs.
@
text
@d72 1
a72 1
	printf (" machine type MVME%x\n", brdtyp);
@


1.4
log
@Add prototypes, fix compilation warnings, random style fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.3 1999/05/29 04:41:44 smurph Exp $ */
d72 1
a72 1
	printf (" machine type MVME%x\n", cputyp);
@


1.3
log
@Added vme bus device drivers. MVME328, MVME376, MVME332
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.2 1998/12/15 05:52:30 smurph Exp $ */
d15 2
a81 1

@


1.3.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.3 1999/05/29 04:41:44 smurph Exp $ */
a14 2
int mainbus_print __P((void *, const char *));
int mainbus_scan __P((struct device *, void *, void *));
d80 1
@


1.3.4.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d72 1
a72 1
	printf (" machine type MVME%x\n", brdtyp);
@


1.3.4.3
log
@Merge in -current from about a week ago
@
text
@d13 4
a16 4
void mainbus_attach(struct device *, struct device *, void *);
int  mainbus_match(struct device *, void *, void *);
int mainbus_print(void *, const char *);
int mainbus_scan(struct device *, void *, void *);
@


1.3.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a9 1
#include <machine/cmmu.h>
d23 1
a23 1
	NULL, "mainbus", DV_DULL
d72 1
a72 8
	extern char cpu_model[];

	printf(": %s\n", cpu_model);

	/*
	 * Display cpu/mmu details. Only for the master CPU so far.
	 */
	cpu_configuration_print(1);
@


1.3.4.5
log
@Merge with the trunk
@
text
@d2 1
a2 26
/*
 * Copyright (c) 1998 Steve Murphree, Jr.
 * Copyright (c) 2004, Miodrag Vallat.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

a9 3
#include <machine/bus.h>
#include <machine/autoconf.h>
#include <machine/board.h>
d12 1
d14 4
a17 96
void	mainbus_attach(struct device *, struct device *, void *);
int 	mainbus_match(struct device *, void *, void *);
int	mainbus_print(void *, const char *);
int	mainbus_scan(struct device *, void *, void *);

/*
 * bus_space routines for 1:1 obio mappings
 */

int	mainbus_map(bus_addr_t, bus_size_t, int, bus_space_handle_t *);
void	mainbus_unmap(bus_space_handle_t, bus_size_t);
int	mainbus_subregion(bus_space_handle_t, bus_size_t, bus_size_t,
	    bus_space_handle_t *);
void	*mainbus_vaddr(bus_space_handle_t);

const struct mvme88k_bus_space_tag mainbus_bustag = {
	mainbus_map,
	mainbus_unmap,
	mainbus_subregion,
	mainbus_vaddr
};

/*
 * Obio (internal IO) space is mapped 1:1 (see pmap_bootstrap() for details).
 *
 * However, sram attaches as a child of mainbus, but does not reside in
 * internal IO space. As a result, we have to allow both 1:1 and iomap
 * translations, depending upon the address to map.
 */

int
mainbus_map(bus_addr_t addr, bus_size_t size, int flags,
    bus_space_handle_t *ret)
{
	vaddr_t map;
	static bus_addr_t threshold = 0;

	if (threshold == 0) {
		switch (brdtyp) {
#ifdef MVME188
		case BRD_188:
			threshold = MVME188_UTILITY;
			break;
#endif
#ifdef MVME187
		case BRD_187:
		case BRD_8120:
#endif
#ifdef MVME197
		case BRD_197:
#endif
			threshold = OBIO_START;
			break;
		}
	}

	if (addr >= threshold)
		map = (vaddr_t)addr;
	else {
#if 0
		map = iomap_mapin(addr, size, 0);
#else
		map = (vaddr_t)mapiodev((void *)addr, size);
#endif
	}

	if (map == NULL)
		return ENOMEM;

	*ret = (bus_space_handle_t)map;
	return 0;
}

void
mainbus_unmap(bus_space_handle_t handle, bus_size_t size)
{
	/* XXX what to do for non-obio mappings? */
}

int
mainbus_subregion(bus_space_handle_t handle, bus_addr_t offset,
    bus_size_t size, bus_space_handle_t *ret)
{
	*ret = handle + offset;
	return (0);
}

void *
mainbus_vaddr(bus_space_handle_t handle)
{
	return (void *)handle;
}

/*
 * Configuration glue
 */
d43 2
a44 2
	if (ca->ca_paddr != -1)
		printf(" addr 0x%x", ca->ca_paddr);
d57 3
a59 2
	oca.ca_iot = &mainbus_bustag;
	oca.ca_dmat = 0;	/* XXX no need for a meaningful value yet */
a60 2
	oca.ca_paddr = cf->cf_loc[0];
	oca.ca_ipl = -1;
@


1.2
log
@Commit for the first real OpenBSD mvme88k port.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.1 1997/03/03 19:32:04 rahnds Exp $ */
d70 1
a70 1
	printf (" machine type %x\n", cputyp);
@


1.1
log
@Initial revision
@
text
@d1 2
d13 2
a14 8
void mbattach __P((struct device *, struct device *, void *));
int mbprint __P((void *, const char *));
int mbmatch __P((struct device *, void *, void *));
int submatch __P((struct device *, void *, void *));

/* 
 * mainbus driver 
 */
d17 1
a17 1
	sizeof(struct device), mbmatch, mbattach
d25 4
a28 1
mbmatch(struct device *pdp, void *self, void *auxp)
d30 1
a30 8
	struct cfdata *cfp = self;

	if (cfp->cf_unit > 0)
		return(0);
	/*
	 * We are always here
	 */
	return(1);
d33 4
a36 5
/*
 * "find" all the things that should be there.
 */
void
mbattach(struct device *pdp, struct device *dp, void *auxp)
d38 1
a38 9
	struct cfdata *cf;
	extern int cputyp;

	/* nothing to do for this bus */
	printf (" machine type %x\n", cputyp);

	if ((cf = config_search(submatch, dp, auxp)) != NULL) {
		return;
	}
d40 3
d46 3
a48 1
mbprint(void *auxp, const char *pnp)
d50 13
a62 3
	if (pnp)
		printf("%s at %s", (char *)auxp, pnp);
	return(UNCONF);
d65 4
a68 2
int
submatch(struct device *parent, void *self, void *aux)
d70 1
a70 10
	struct confargs *ca = aux;
	struct cfdata   *cf = self;

	ca->ca_bustype = BUS_MAIN;
	ca->ca_paddr = (caddr_t)cf->cf_loc[0];
	ca->ca_size = cf->cf_loc[1];

	if (!(*cf->cf_attach->ca_match)(parent, cf, ca)) {
		if (!parent)
			cf->cf_fstate = FSTATE_FOUND;
d72 4
a75 5
		return 0;
	}

	/*
	 * mapin the device memory of the child and call attach.
a76 4
#if 0
	ca->ca_vaddr = (caddr_t)iomap_mapin(ca->ca_paddr, ca->ca_size, 1);
#endif /* 0 */
	ca->ca_vaddr = ca->ca_paddr;
d78 2
a79 1
	config_attach(parent, cf, ca, mbprint);
a80 2
	return 1;
}
@


1.1.1.1
log
@Third try at importing the mvme88k port. This is a working kernel
from nivas.
Userland and compiler still need to be worked on.
Make certain what directory the import is done from.
@
text
@@
