head	1.53;
access;
symbols
	OPENBSD_5_5:1.52.0.6
	OPENBSD_5_5_BASE:1.52
	OPENBSD_5_4:1.52.0.2
	OPENBSD_5_4_BASE:1.52
	OPENBSD_5_3:1.51.0.8
	OPENBSD_5_3_BASE:1.51
	OPENBSD_5_2:1.51.0.6
	OPENBSD_5_2_BASE:1.51
	OPENBSD_5_1_BASE:1.51
	OPENBSD_5_1:1.51.0.4
	OPENBSD_5_0:1.51.0.2
	OPENBSD_5_0_BASE:1.51
	OPENBSD_4_9:1.49.0.10
	OPENBSD_4_9_BASE:1.49
	OPENBSD_4_8:1.49.0.8
	OPENBSD_4_8_BASE:1.49
	OPENBSD_4_7:1.49.0.4
	OPENBSD_4_7_BASE:1.49
	OPENBSD_4_6:1.49.0.6
	OPENBSD_4_6_BASE:1.49
	OPENBSD_4_5:1.49.0.2
	OPENBSD_4_5_BASE:1.49
	OPENBSD_4_4:1.48.0.4
	OPENBSD_4_4_BASE:1.48
	OPENBSD_4_3:1.48.0.2
	OPENBSD_4_3_BASE:1.48
	OPENBSD_4_2:1.46.0.2
	OPENBSD_4_2_BASE:1.46
	OPENBSD_4_1:1.45.0.2
	OPENBSD_4_1_BASE:1.45
	OPENBSD_4_0:1.44.0.2
	OPENBSD_4_0_BASE:1.44
	OPENBSD_3_9:1.40.0.2
	OPENBSD_3_9_BASE:1.40
	OPENBSD_3_8:1.39.0.6
	OPENBSD_3_8_BASE:1.39
	OPENBSD_3_7:1.39.0.4
	OPENBSD_3_7_BASE:1.39
	OPENBSD_3_6:1.39.0.2
	OPENBSD_3_6_BASE:1.39
	SMP_SYNC_A:1.36
	SMP_SYNC_B:1.36
	OPENBSD_3_5:1.29.0.2
	OPENBSD_3_5_BASE:1.29
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	UBC_SYNC_A:1.19
	OPENBSD_3_3:1.19.0.6
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.19.0.4
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	UBC_SYNC_B:1.19
	UBC:1.18.0.2
	UBC_BASE:1.18
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	SMP:1.4.0.4
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.1.1.1.0.8
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.6
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.4
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.2
	OPENBSD_2_1_BASE:1.1.1.1
	mvme88kport:1.1.1.1;
locks; strict;
comment	@ * @;


1.53
date	2014.03.18.22.36.36;	author miod;	state dead;
branches;
next	1.52;

1.52
date	2013.05.17.22.46.27;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2011.04.12.21.38.18;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2011.04.07.15.30.15;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2009.02.17.21.03.21;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2007.12.27.23.17.53;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2007.11.17.05.33.38;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2007.03.22.18.52.38;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2006.11.16.23.21.56;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2006.05.08.14.36.10;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2006.04.26.20.48.06;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2006.04.17.18.27.30;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2006.04.17.18.26.26;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2005.11.25.22.14.31;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2004.08.02.08.35.00;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2004.07.30.19.02.06;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2004.07.23.22.19.07;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2004.05.07.18.10.28;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2004.04.30.21.32.52;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2004.04.24.19.51.48;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2004.04.16.23.35.50;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2004.04.16.06.20.24;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2004.04.16.06.06.46;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2004.04.14.23.06.16;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2004.01.14.20.52.52;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2004.01.14.20.50.48;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2003.12.28.19.44.26;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2003.12.27.23.56.41;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2003.12.22.11.54.48;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2003.12.19.22.30.18;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2003.10.08.22.36.11;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2003.10.05.20.27.48;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2003.09.28.22.14.33;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.04.04.11.37;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.14.01.26.39;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.16.23.49.46;	author miod;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2001.12.13.08.55.51;	author smurph;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.07.22.31.57;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.06.19.53.15;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2001.10.28.00.57.38;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2001.09.11.20.05.24;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.26.02.37.07;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.24.19.34.21;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.11.23.21.13;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.09.05.44.39;	author smurph;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.07.23.45.52;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2001.02.01.03.38.15;	author smurph;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.14.20.25.22;	author smurph;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.26.23.32.00;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	99.09.27.18.43.25;	author smurph;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	99.05.29.04.41.44;	author smurph;	state Exp;
branches;
next	1.2;

1.2
date	98.12.15.05.52.31;	author smurph;	state Exp;
branches;
next	1.1;

1.1
date	97.03.03.19.32.03;	author rahnds;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.03.03.19.32.03;	author rahnds;	state Exp;
branches;
next	;

1.4.4.1
date	2001.04.18.16.11.06;	author niklas;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2001.10.31.03.01.18;	author nate;	state Exp;
branches;
next	1.4.4.3;

1.4.4.3
date	2001.11.13.21.04.14;	author niklas;	state Exp;
branches;
next	1.4.4.4;

1.4.4.4
date	2002.03.28.10.36.02;	author niklas;	state Exp;
branches;
next	1.4.4.5;

1.4.4.5
date	2003.06.07.11.13.17;	author ho;	state Exp;
branches;
next	1.4.4.6;

1.4.4.6
date	2004.02.19.10.49.06;	author niklas;	state Exp;
branches;
next	1.4.4.7;

1.4.4.7
date	2004.06.05.23.09.49;	author niklas;	state Exp;
branches;
next	;

1.18.2.1
date	2002.06.11.03.37.10;	author art;	state Exp;
branches;
next	;


desc
@@


1.53
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: vme.c,v 1.52 2013/05/17 22:46:27 miod Exp $ */
/*
 * Copyright (c) 2004, Miodrag Vallat.
 * Copyright (c) 1999 Steve Murphree, Jr.
 * Copyright (c) 1995 Theo de Raadt
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/conf.h>
#include <sys/ioctl.h>
#include <sys/proc.h>
#include <sys/uio.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>

#include <machine/autoconf.h>
#include <machine/board.h>
#include <machine/cpu.h>

#include <mvme88k/dev/vme.h>

int	vmematch(struct device *, void *, void *);
void	vmeattach(struct device *, struct device *, void *);

u_long	vme2chip_map(u_long, int);
int	vmeprint(void *, const char *);

int vmebustype;
unsigned int vmevecbase;

const struct cfattach vme_ca = {
        sizeof(struct device), vmematch, vmeattach
};

struct cfdriver vme_cd = {
        NULL, "vme", DV_DULL
};

/*
 * bus_space routines for VME mappings
 */

int	vme_map(bus_addr_t, bus_size_t, int, bus_space_handle_t *);
void	vme_unmap(bus_space_handle_t, bus_size_t);
int	vme_subregion(bus_space_handle_t, bus_size_t, bus_size_t,
	    bus_space_handle_t *);
void *	vme_vaddr(bus_space_handle_t);

const struct mvme88k_bus_space_tag vme_bustag = {
	vme_map,
	vme_unmap,
	vme_subregion,
	vme_vaddr
};

/*
 * VME space mapping functions
 */

int
vme_map(bus_addr_t addr, bus_size_t size, int flags, bus_space_handle_t *ret)
{
	vaddr_t map;

	map = (vaddr_t)mapiodev((paddr_t)addr, size);
	if (map == 0)
		return ENOMEM;

	*ret = (bus_space_handle_t)map;
	return 0;
}

void
vme_unmap(bus_space_handle_t handle, bus_size_t size)
{
	unmapiodev((vaddr_t)handle, size);
}

int
vme_subregion(bus_space_handle_t handle, bus_addr_t offset, bus_size_t size,
    bus_space_handle_t *ret)
{
	*ret = handle + offset;
	return (0);
}

void *
vme_vaddr(bus_space_handle_t handle)
{
	return (void *)handle;
}

/*
 * Extra D16 access functions
 *
 * D16 cards will trigger bus errors on attempting to read or write more
 * than 16 bits on the bus. Given how the m88k processor works, this means
 * basically that all long (D32) accesses must be carefully taken care of.
 *
 * Since the kernels bcopy() and bzero() routines will use 32 bit accesses
 * for performance, here are specific D16-compatible routines. They will
 * also revert to D8 operations if neither of the operands is properly
 * aligned.
 */

void d16_bcopy(const void *, void *, size_t);
void d16_bzero(void *, size_t);

void
d16_bcopy(const void *src, void *dst, size_t len)
{
	if ((vaddr_t)src & 1 || (vaddr_t)dst & 1)
		bus_space_write_region_1(&vme_bustag, 0, (vaddr_t)dst,
		    (void *)src, len);
	else {
		bus_space_write_region_2(&vme_bustag, 0, (vaddr_t)dst,
		    (void *)src, len / 2);
		if (len & 1)
			bus_space_write_1(&vme_bustag, 0,
			    dst + len - 1, *(u_int8_t *)(src + len - 1));
	}
}

void
d16_bzero(void *dst, size_t len)
{
	if ((vaddr_t)dst & 1)
		bus_space_set_region_1(&vme_bustag, 0, (vaddr_t)dst, 0, len);
	else {
		bus_space_set_region_2(&vme_bustag, 0, (vaddr_t)dst, 0, len / 2);
		if (len & 1)
			bus_space_write_1(&vme_bustag, 0, dst + len - 1, 0);
	}
}

/*
 * Configuration glue
 */

int
vmematch(struct device *parent, void *cf, void *args)
{
#ifdef MVME187
	if (brdtyp == BRD_8120)
		return 0;
#endif
	return 1;
}

int
vmeprint(void *args, const char *bus)
{
	struct confargs *ca = args;

	printf(" addr 0x%x", ca->ca_paddr);
	if (ca->ca_ipl > 0)
		printf(" ipl %d", ca->ca_ipl);
	if (ca->ca_vec >= 0)
		printf(" vec 0x%x", ca->ca_vec);
	return UNCONF;
}

int
vmescan(struct device *parent, void *child, void *args, int bustype)
{
	struct cfdata *cf = child;
	struct confargs oca, *ca = args;

	bzero(&oca, sizeof oca);
	oca.ca_iot = &vme_bustag;
	oca.ca_dmat = ca->ca_dmat;
	oca.ca_bustype = bustype;
	oca.ca_paddr = cf->cf_loc[0];
	oca.ca_vec = cf->cf_loc[1];
	oca.ca_ipl = cf->cf_loc[2];
	if (oca.ca_ipl > 0 && oca.ca_vec < 0)
		oca.ca_vec = vme_findvec(-1);
	oca.ca_name = cf->cf_driver->cd_name;

	if ((*cf->cf_attach->ca_match)(parent, cf, &oca) == 0)
		return 0;

	config_attach(parent, cf, &oca, vmeprint);
	return 1;
}

void
vmeattach(struct device *parent, struct device *self, void *args)
{
	struct confargs *ca = args;

	if (platform->is_syscon())
		printf(": system controller");
	printf("\n");

	vmevecbase = platform->init_vme(self->dv_xname);
	vmebustype = ca->ca_bustype;

	while (config_found(self, args, NULL))
		;
}

/* find a VME vector based on what is in NVRAM settings. */
int
vme_findvec(int skip)
{
	return intr_findvec(vmevecbase, 0xff, skip);
}

/*
 * make local addresses 1G-2G correspond to VME addresses 3G-4G,
 * as D32
 */
#define VME2_D32STARTPHYS	(1*1024*1024*1024UL)
#define VME2_D32ENDPHYS		(2*1024*1024*1024UL)
#define VME2_D32STARTVME	(3*1024*1024*1024UL)
#define VME2_D32BITSVME		(3*1024*1024*1024UL)

/*
 * make local addresses 3G-3.75G correspond to VME addresses 3G-3.75G,
 * as D16
 */
#define VME2_D16STARTPHYS	(3*1024*1024*1024UL)
#define VME2_D16ENDPHYS		(3*1024*1024*1024UL + 768*1024*1024UL)
#define VME2_A32D16STARTPHYS	(0xff000000UL)
#define VME2_A32D16ENDPHYS	(0xff7fffffUL)

/*
 * Returns a physical address mapping for a VME address & length.
 * Note: on some hardware it is not possible to create certain
 * mappings, ie. the MVME147 cannot do 32 bit accesses to VME bus
 * addresses from 0 to physmem.
 */
paddr_t
vmepmap(struct device *sc, off_t vmeaddr, int bustype)
{
	u_int32_t base = (u_int32_t)vmeaddr;	/* wrap around 4GB */

	switch (bustype) {
	case BUS_VMES:		/* D16 VME Transfers */
#ifdef DEBUG
		printf("base 0x%8llx/0x%8x\n", vmeaddr, base);
#endif
		base = vme2chip_map(base, 16);
#ifdef DEBUG
		if (base == 0)
			printf("%s: cannot map pa 0x%x\n", sc->dv_xname, base);
#endif
		break;
	case BUS_VMEL:		/* D32 VME Transfers */
#ifdef DEBUG
		printf("base 0x%8llx/0x%8x\n", vmeaddr, base);
#endif
		base = vme2chip_map(base, 32);
#ifdef DEBUG
		if (base == 0)
			printf("%s: cannot map pa 0x%x\n", sc->dv_xname, base);
#endif
		break;
	}

	return base;
}

static vaddr_t vmemap(struct device *, off_t);
static void vmeunmap(paddr_t);

/* if successful, returns the va of a vme bus mapping */
static __inline__ vaddr_t
vmemap(struct device *sc, off_t vmeaddr)
{
	paddr_t pa;

	pa = vmepmap(sc, vmeaddr, BUS_VMES);
	if (pa == 0)
		return (0);
	return mapiodev(pa, PAGE_SIZE);
}

static __inline__ void
vmeunmap(vaddr_t va)
{
	unmapiodev(va, PAGE_SIZE);
}

int
vmerw(struct device *sc, struct uio *uio, int flags, int bus)
{
	vaddr_t v;
	size_t c;
	struct iovec *iov;
	paddr_t vme;
	int error = 0;

	while (uio->uio_resid > 0 && error == 0) {
		iov = uio->uio_iov;
		if (iov->iov_len == 0) {
			uio->uio_iov++;
			uio->uio_iovcnt--;
			if (uio->uio_iovcnt < 0)
				panic("vmerw");
			continue;
		}

		v = uio->uio_offset;
		c = ulmin(iov->iov_len, MAXPHYS);
		if ((v & PGOFSET) + c > PAGE_SIZE) /* max 1 page at a time */
			c = PAGE_SIZE - (v & PGOFSET);
		if (c == 0)
			return 0;
		vme = vmemap(sc, v & ~PGOFSET);
		if (vme == 0)
			return EACCES;
		error = uiomove((void *)vme + (v & PGOFSET), c, uio);
		vmeunmap(vme);
	}
	return error;
}

/*
 * Currently registered VME interrupt vectors for a given IPL, if they
 * are unique. Used to help the MVME181 and MVME188 interrupt handler when
 * they fail to complete the VME interrupt acknowledge cycle to get the
 * interrupt vector number.
 */
u_int vmevec_hints[NIPLS] = {
	(u_int)-1, (u_int)-1, (u_int)-1, (u_int)-1,
	(u_int)-1, (u_int)-1, (u_int)-1, (u_int)-1
};

/*
 * On the VMEbus, only one cpu may be configured to respond to any
 * particular vme ipl. Therefore, it wouldn't make sense to globally
 * enable all the interrupts all the time -- it would not be possible
 * to put two cpu's and one vme card into a single cage. Rather, we
 * enable each vme interrupt only when we are attaching a device that
 * uses it. This makes it easier (though not trivial) to put two cpu
 * cards in one VME cage, and both can have some limited access to vme
 * interrupts (just can't share the same irq).
 * Obviously no check is made to see if another cpu is using that
 * interrupt. If you share you will lose.
 */

int
vmeintr_establish(int vec, struct intrhand *ih, const char *name)
{
	int rc;

#ifdef DIAGNOSTIC
	if (ih->ih_ipl < 1 || ih->ih_ipl > 7)
		return EINVAL;
#endif

	if (platform->intsrc_available(INTSRC_VME, ih->ih_ipl) != 0)
		return EINVAL;

	if ((rc = intr_establish(vec, ih, name)) != 0)
		return rc;

	if (vmevec_hints[ih->ih_ipl] == (u_int)-1)
		vmevec_hints[ih->ih_ipl] = vec;
	else
		vmevec_hints[ih->ih_ipl] = (u_int)-1;

	/*
	 * Enable VME interrupt source for this level, if necessary.
	 */
	platform->intsrc_enable(INTSRC_VME, ih->ih_ipl);

	return 0;
}

/*
 * A32 accesses on the MVME1[6789]x require setting up mappings in
 * the VME2 chip.
 * XXX VME address must be between 2G and 4G
 * XXX We only support D32 at the moment..
 * XXX smurph - This is bogus, get rid of it! Should check vme/syscon for offsets.
 */
u_long
vme2chip_map(base, dwidth)
	u_long base;
	int dwidth;
{
	/*
	 * Since we are checking range for one page only, no need to check
	 * for address wraparound.
	 */
	switch (dwidth) {
	case 16:
		if (base < VME2_D16STARTPHYS ||
		    base + PAGE_SIZE > VME2_D16ENDPHYS)
			return 0;
		break;
	case 32:
		if (base < VME2_D32STARTPHYS ||
		    base + PAGE_SIZE > VME2_D32ENDPHYS)
			return 0;
		break;
	default:
		return 0;
	}
	return base;
}
@


1.52
log
@Replace the bunch of md_* function pointers with a `struct board' containing
function pointers for all the board-specific code.

Add a bunch of `struct board' methods to cover most, if not all, of the
`per-board' logic. This allows most of the md drivers to be cleaned up and
no longer need to embed board-specific knowledge.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.51 2011/04/12 21:38:18 miod Exp $ */
@


1.51
log
@A few, hopefully last, NULL-as-an-integer misuses.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.50 2011/04/07 15:30:15 miod Exp $ */
d39 1
a41 3
#include "pcctwo.h"
#include "syscon.h"

a42 4
#if NSYSCON > 0
#include <machine/mvme188.h>
#include <mvme88k/dev/sysconvar.h>
#endif
a46 2
void	vme2chip_init(struct vmesoftc *);
void	vmesyscon_init(struct vmesoftc *);
a47 1
int	vme2abort(void *);
d53 2
a54 2
struct cfattach vme_ca = {
        sizeof(struct vmesoftc), vmematch, vmeattach
d163 1
a163 4
vmematch(parent, cf, args)
	struct device *parent;
	void *cf;
	void *args;
d167 1
a167 1
		return (0);
d169 1
a169 1
	return (1);
d173 1
a173 3
vmeprint(args, bus)
	void *args;
	const char *bus;
d182 1
a182 1
	return (UNCONF);
d186 1
a186 4
vmescan(parent, child, args, bustype)
	struct device *parent;
	void *child, *args;
	int bustype;
d203 1
a203 1
		return (0);
d206 1
a206 1
	return (1);
d210 1
a210 3
vmeattach(parent, self, args)
	struct device *parent, *self;
	void *args;
a211 1
	struct vmesoftc *sc = (struct vmesoftc *)self;
d214 3
a216 10
	/*
	 * This is a waste if we are attached to SYSCON - but then obio
	 * mappings are free...
	 */
	sc->sc_iot = ca->ca_iot;
	if (bus_space_map(sc->sc_iot, ca->ca_paddr, PAGE_SIZE, 0,
	    &sc->sc_ioh) != 0) {
		printf(": can't map registers!\n");
		return;
	}
d218 1
a220 42
	switch (ca->ca_bustype) {
#if NPCCTWO > 0
	case BUS_PCCTWO:
	{
		u_int32_t vbr;

		/* Sanity check that the BUG is set up right */
		vbr = bus_space_read_4(sc->sc_iot, sc->sc_ioh, VME2_VBR);
		vmevecbase = VME2_GET_VBR1(vbr) + 0x10;
		if (vmevecbase >= 0x100) {
			panic("Correct the VME Vector Base Registers "
			    "in the Bug ROM.\n"
			    "Suggested values are 0x60 for VME Vec0 and "
			    "0x70 for VME Vec1.");
		}

		if ((bus_space_read_4(sc->sc_iot, sc->sc_ioh, VME2_TCTL) &
		    VME2_TCTL_SCON) != 0)
			printf(": system controller");
		printf("\n");

		vme2chip_init(sc);
	}
		break;
#endif
#if NSYSCON > 0
	case BUS_SYSCON:
	{
		u_int8_t sconc;

		vmevecbase = 0;	/* all vectors available */
		sconc = *(volatile u_int8_t *)MVME188_GLOBAL1;
		if (ISSET(sconc, M188_SYSCON))
			printf(": system controller");
		printf("\n");

		vmesyscon_init(sc);
	}
		break;
#endif
	}

a235 1

a249 1

d257 1
a257 4
vmepmap(sc, vmeaddr, bustype)
	struct device *sc;
	off_t vmeaddr;
	int bustype;
d261 2
a262 6
	switch (vmebustype) {
#if NPCCTWO > 0 || NSYSCON > 0
	case BUS_PCCTWO:
	case BUS_SYSCON:
		switch (bustype) {
		case BUS_VMES:		/* D16 VME Transfers */
d264 1
a264 2
			printf("base 0x%8llx/0x%8x\n",
			    vmeaddr, base);
d266 1
a266 1
			base = vme2chip_map(base, 16);
d268 2
a269 4
			if (base == 0) {
				printf("%s: cannot map pa 0x%x\n",
				    sc->dv_xname, base);
			}
d271 2
a272 2
			break;
		case BUS_VMEL:		/* D32 VME Transfers */
d274 1
a274 2
			printf("base 0x%8llx/0x%8x\n",
			    vmeaddr, base);
d276 1
a276 1
			base = vme2chip_map(base, 32);
d278 2
a279 4
			if (base == 0) {
				printf("%s: cannot map pa 0x%x\n",
				    sc->dv_xname, base);
			}
a280 2
			break;
		}
a281 3
#endif
	default:
		return 0;
d283 2
a284 1
	return (base);
d287 1
a287 1
static vaddr_t vmemap(struct vmesoftc *, off_t);
d292 1
a292 1
vmemap(struct vmesoftc *sc, off_t vmeaddr)
d296 1
a296 1
	pa = vmepmap((struct device *)sc, vmeaddr, BUS_VMES);
d309 1
a309 5
vmerw(sc, uio, flags, bus)
	struct device *sc;
	struct uio *uio;
	int flags;
	int bus;
d312 1
a312 1
	int c;
d328 1
a328 1
		c = min(iov->iov_len, MAXPHYS);
d333 1
a333 1
		vme = vmemap((struct vmesoftc *)sc, v & ~PGOFSET);
a341 1
#ifdef MVME188
d344 3
a346 2
 * are unique. Used to help the MVME188 interrupt handler when it's getting
 * behind.
d348 1
a348 1
u_int vmevec_hints[8] = {
a351 1
#endif
a368 3
#if NPCCTWO > 0
	struct vmesoftc *sc = (struct vmesoftc *) vme_cd.cd_devs[0];
#endif
d373 1
a373 1
		return (EINVAL);
d376 2
a377 9
	switch (vmebustype) {
#if NPCCTWO > 0
	case BUS_PCCTWO:
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, VME2_IRQEN,
		    bus_space_read_4(sc->sc_iot, sc->sc_ioh, VME2_IRQEN) |
		    VME2_IRQ_VME(ih->ih_ipl));
		break;
#endif
	}
d380 1
a380 1
		return (rc);
a381 1
#ifdef MVME188
a385 16
#endif

	return (0);
}

#if NPCCTWO > 0
void
vme2chip_init(sc)
	struct vmesoftc *sc;
{
	u_int32_t ctl, irqen, master, master4mod;

	/* turn off SYSFAIL LED */
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, VME2_TCTL,
	    bus_space_read_4(sc->sc_iot, sc->sc_ioh, VME2_TCTL) &
	    ~VME2_TCTL_SYSFAIL);
d388 1
a388 1
	 * Display the VMEChip2 decoder status.
d390 1
a390 29
	printf("%s: using BUG parameters\n", sc->sc_dev.dv_xname);
	ctl = bus_space_read_4(sc->sc_iot, sc->sc_ioh, VME2_GCSRCTL);
	if (ctl & VME2_GCSRCTL_MDEN1) {
		master = bus_space_read_4(sc->sc_iot, sc->sc_ioh, VME2_MASTER1);
		printf("%s: 1phys 0x%08lx-0x%08lx to VME 0x%08lx-0x%08lx\n",
		    sc->sc_dev.dv_xname, master << 16, master & 0xffff0000,
		    master << 16, master & 0xffff0000);
	}
	if (ctl & VME2_GCSRCTL_MDEN2) {
		master = bus_space_read_4(sc->sc_iot, sc->sc_ioh, VME2_MASTER2);
		printf("%s: 2phys 0x%08lx-0x%08lx to VME 0x%08lx-0x%08lx\n",
		    sc->sc_dev.dv_xname, master << 16, master & 0xffff0000,
		    master << 16, master & 0xffff0000);
	}
	if (ctl & VME2_GCSRCTL_MDEN3) {
		master = bus_space_read_4(sc->sc_iot, sc->sc_ioh, VME2_MASTER3);
		printf("%s: 3phys 0x%08lx-0x%08lx to VME 0x%08lx-0x%08lx\n",
		    sc->sc_dev.dv_xname, master << 16, master & 0xffff0000,
		    master << 16, master & 0xffff0000);
	}
	if (ctl & VME2_GCSRCTL_MDEN4) {
		master = bus_space_read_4(sc->sc_iot, sc->sc_ioh, VME2_MASTER4);
		master4mod = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
		    VME2_MASTER4MOD);
		printf("%s: 4phys 0x%08lx-0x%08lx to VME 0x%08lx-0x%08lx\n",
		    sc->sc_dev.dv_xname, master << 16, master & 0xffff0000,
		    (master << 16) + (master4mod << 16),
		    (master & 0xffff0000) + (master4mod & 0xffff0000));
	}
d392 1
a392 67
	/*
	 * Map the VME irq levels to the cpu levels 1:1.
	 * This is rather inflexible, but much easier.
	 */
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, VME2_IRQL4,
	    (7 << VME2_IRQL4_VME7SHIFT) | (6 << VME2_IRQL4_VME6SHIFT) |
	    (5 << VME2_IRQL4_VME5SHIFT) | (4 << VME2_IRQL4_VME4SHIFT) |
	    (3 << VME2_IRQL4_VME3SHIFT) | (2 << VME2_IRQL4_VME2SHIFT) |
	    (1 << VME2_IRQL4_VME1SHIFT));
	printf("%s: vme to cpu irq level 1:1\n",sc->sc_dev.dv_xname);

	/* Enable the reset switch */
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, VME2_TCTL, VME2_TCTL_RSWE |
	    bus_space_read_4(sc->sc_iot, sc->sc_ioh, VME2_TCTL));
	/* Set Watchdog timeout to about 1 minute */
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, VME2_TCR, VME2_TCR_64S |
	    bus_space_read_4(sc->sc_iot, sc->sc_ioh, VME2_TCR));
	/* Enable VMEChip2 Interrupts */
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, VME2_VBR, VME2_IOCTL1_MIEN |
	    bus_space_read_4(sc->sc_iot, sc->sc_ioh, VME2_VBR));

	/*
	 * Map the Software VME irq levels to the cpu level 7.
	*/
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, VME2_IRQL3,
	    (7 << VME2_IRQL3_SW7SHIFT) | (7 << VME2_IRQL3_SW6SHIFT) |
	    (7 << VME2_IRQL3_SW5SHIFT) | (7 << VME2_IRQL3_SW4SHIFT) |
	    (7 << VME2_IRQL3_SW3SHIFT) | (7 << VME2_IRQL3_SW2SHIFT) |
	    (7 << VME2_IRQL3_SW1SHIFT));

	/*
	 * pseudo driver, abort interrupt handler
	 */
	sc->sc_abih.ih_fn = vme2abort;
	sc->sc_abih.ih_arg = 0;
	sc->sc_abih.ih_wantframe = 1;
	sc->sc_abih.ih_ipl = IPL_NMI;
	intr_establish(110, &sc->sc_abih, sc->sc_dev.dv_xname);

	irqen = bus_space_read_4(sc->sc_iot, sc->sc_ioh, VME2_IRQEN);
	irqen |= VME2_IRQ_AB;
	/* bus_space_write_4(sc->sc_iot, sc->sc_ioh, VME2_IRQEN, irqen); */

	/*
	 * Enable ACFAIL interrupt, but disable Timer 1 interrupt - we
	 * prefer it without for delay().
	 */
	irqen = (irqen | VME2_IRQ_ACF) & ~VME2_IRQ_TIC1;
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, VME2_IRQEN, irqen);
}
#endif /* NPCCTWO */

#if NSYSCON > 0
void
vmesyscon_init(sc)
	struct vmesoftc *sc;
{
	u_int32_t ucsr;

	/*
	 * Force a reasonable timeout for VME data transfers.
	 * We can not disable this, this would cause autoconf to hang
	 * on the first missing device we'll probe.
	 */
	ucsr = *(volatile u_int32_t*)MVME188_UCSR;
	ucsr = (ucsr & ~VTOSELBITS) | VTO128US;
	*(volatile u_int32_t *)MVME188_UCSR = ucsr;
a393 1
#endif /* NSYSCON */
a426 19

#if NPCCTWO > 0
int
vme2abort(eframe)
	void *eframe;
{
	struct vmesoftc *sc = (struct vmesoftc *)vme_cd.cd_devs[0];

	if ((bus_space_read_4(sc->sc_iot, sc->sc_ioh, VME2_IRQSTAT) &
	    VME2_IRQ_AB) == 0) {
		printf("%s: abort irq not set\n", sc->sc_dev.dv_xname);
		return (0);
	}

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, VME2_IRQCLR, VME2_IRQ_AB);
	nmihand(eframe);
	return (1);
}
#endif
@


1.50
log
@Do not use NULL in integer comparisons. No functional change.
ok matthew@@ tedu@@, also eyeballed by at least krw@@ oga@@ kettenis@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.49 2009/02/17 21:03:21 miod Exp $ */
d97 1
a97 1
	if (map == NULL)
d346 1
a346 1
			if (base == NULL) {
d359 1
a359 1
			if (base == NULL) {
@


1.49
log
@Be sure to pass a valid confargs * to child devices of vme0 when attaching,
for they will attempt to dereference it and having NULL readable while
in the kernel is just cheating.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.48 2007/12/27 23:17:53 miod Exp $ */
d369 1
a369 1
		return NULL;
d384 2
a385 2
	if (pa == NULL)
		return (NULL);
d425 1
a425 1
		if (vme == NULL)
d629 1
a629 1
			return NULL;
d634 1
a634 1
			return NULL;
d637 1
a637 1
		return NULL;
@


1.48
log
@Make the mvme188 interrupt handling closer to the aviion interrupt handling:
non-VME syscon interrupt sources will now use their own intrhand array,
and interrupt sources will be enabled in the arbiter as interrupt handlers
are registered. This allows VME devices to use the whole 256 interrupts range.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.47 2007/11/17 05:33:38 miod Exp $ */
d289 1
a289 1
	while (config_found(self, NULL, NULL))
@


1.47
log
@Add some preprocessor magic to let M187 and M188 kernels compile again.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.46 2007/03/22 18:52:38 miod Exp $ */
d47 1
a47 1
#include <mvme88k/dev/sysconreg.h>
a56 1
int	sysconabort(void *);
d194 1
a194 1
	if (ca->ca_vec > 0)
d277 1
a277 1
		vmevecbase = 0x60;  /* Hard coded for MVME188 */
@


1.46
log
@When registering VME interrupts, maintain a direct ipl->vector table, as long
as no more than one interrupt is registered for a given level.

Then, if the VME interrupt vector reading cycle fails on the 188 interrupt
arbiter, we can use this table as a hint if it has a valid entry, since
we know on which ipl line the interrupt occured.

This basically silences the
m188_ext_int: timeout getting VME interrupt vector, level 3, mask 0x400<IRQ3>
occasional messages appearing when the MVME376 is overloaded.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.45 2006/11/16 23:21:56 miod Exp $ */
d462 1
d464 1
@


1.45
log
@Ratibibugle struct frame and <machine/frame.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.44 2006/05/08 14:36:10 miod Exp $ */
d434 12
d463 6
d480 11
a490 1
	return intr_establish(vec, ih, name);
@


1.44
log
@Replace gazillions of badvaddr() or badwordaddr() calls with badaddr() calls.
With a few prototype declarations shuffling, this finally allows
<machine/locore.h> to die.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.43 2006/04/26 20:48:06 miod Exp $ */
a39 1
#include <machine/frame.h>
a617 2
	struct frame *frame = eframe;

d627 1
a627 1
	nmihand(frame);
@


1.43
log
@We do not need to reserve the 0x60..0x7f interrupt vector range on MVME188,
so let VME interrupt numbers start at 0x60 on these machines.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.42 2006/04/17 18:27:30 miod Exp $ */
a40 1
#include <machine/locore.h>
a97 3
#if 0
	map = iomap_mapin(addr, size, 0);
#else
a98 1
#endif
a108 3
#if 0
	iomap_mapout(handle, size);
#else
a109 1
#endif
@


1.42
log
@On MVME188, clear SYSFAIL and set up a decent VME data transfer timeout,
instead of relying on what the BUG leaves us with.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.41 2006/04/17 18:26:26 miod Exp $ */
d288 1
a288 1
		vmevecbase = 0x80;  /* Hard coded for MVME188 */
a454 10
 */

/*
 * All VME bus devices will use a vector starting with VBR1 + 0x10
 * and determined by intr_findvec(). (in machdep.c) vmeintr_establish()
 * should be called with the 'vec' argument = 0 to 'auto vector' a
 * VME device.
 *
 * The 8 SW interrupters will start with VBR1.  The rest will start
 * with VBR0< 4) & 0xFF.
@


1.41
log
@Better constant names for the MVME188 GCSR set.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.40 2005/11/25 22:14:31 miod Exp $ */
d587 2
d590 3
a592 3
	 * Nothing to do - though we ought to check the settings and
	 * print them.  Abort button vector has already been setup in
	 * sysconattach().
d594 3
@


1.40
log
@Prefer vaddr_t and paddr_t types, instead of void * and heavy casts.
Improves readability, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.39 2004/08/02 08:35:00 miod Exp $ */
d289 1
a289 1
		sconc = *(volatile u_int8_t *)GLB1;
@


1.39
log
@More include files cleaning:
- move MAX_CPUS constant to <machine/cpu.h>
- do not include <machine/board.h> unless needed. In fact, remove this file
  entirely on mvme88k, and include <machine/mvme*.h> on a
  compiling-for-this-board basis
- keep MAX_CMMUS constant private to the m8820x code
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.38 2004/07/30 19:02:06 miod Exp $ */
d102 1
a102 1
	map = (vaddr_t)mapiodev((void *)addr, size);
d117 1
a117 1
	unmapiodev((void *)handle, size);
d337 1
a337 1
void *
d382 1
a382 1
	return ((void *)base);
d385 2
a386 2
static void *vmemap(struct vmesoftc *, off_t);
static void vmeunmap(void *);
d389 1
a389 1
static __inline__ void *
d392 1
a392 1
	void *pa;
d401 1
a401 1
vmeunmap(void *va)
d416 1
a416 1
	void *vme;
@


1.38
log
@Move evcount structures inside struct intrhand, this makes more sense and
gives us more counters in the process.

Also clean up intrhand structures and usage, especially move them to SLISTs.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.37 2004/07/23 22:19:07 miod Exp $ */
d48 1
@


1.37
log
@Eventually get the MVME188 reset sequence to work, and allow it to return
to the BUG instead of spinning if our reset fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.36 2004/05/07 18:10:28 miod Exp $ */
d467 1
a467 3
vmeintr_establish(vec, ih)
	int vec;
	struct intrhand *ih;
d481 1
a481 1
	return intr_establish(vec, ih);
d566 1
a566 1
	intr_establish(110, &sc->sc_abih);
@


1.36
log
@bus_dma(9) implementation for mvme88k, mostly based upon powerpc.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.35 2004/04/30 21:32:52 miod Exp $ */
d288 2
a289 2
		sconc = *(volatile u_int8_t *)GLOBAL1;
		if (!ISSET(sconc, M188_SYSCONNEG))
@


1.35
log
@Correctly cope with unaligned memory pointers in d16_b*()
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.34 2004/04/24 19:51:48 miod Exp $ */
d216 1
a216 1
	struct confargs oca;
d220 1
@


1.34
log
@Preliminary switch to an mvme88k bus_space world. Not all drivers have been
converted yet, and they rely upon some linear mappings provided by bus_space.

In order to not impact performance, almost all the bus_space accesses go
through macros and inline functions. This currently restricts us to D16 and
D32 access modes, which are selected at compilation time. Since there are no
plans to support D8 vme devices in the future, this is acceptable for now.

This makes the "len" locator for vme devices go away, and allows to simplify
some code which was using the pcctwo device, and will now directly access
hardware which is known to exist, rather than wait until the device is
attached.

While there, try to enforce more interrupt vector number checks, since these
changes pointed out that dart(4) had been working correctly so far by sheer
luck only.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.33 2004/04/16 23:35:50 miod Exp $ */
d132 43
@


1.33
log
@When a VMEBus device needs to use two interrupt vectors, be nice and let it
actually use two distinct vectors, rather than twice the same.

Because of this, print vector last in vmeprint() so that dmesg remains pretty
in the multi-vector case.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.32 2004/04/16 06:20:24 miod Exp $ */
d3 1
d51 2
a52 2
int  vmematch(struct device *, void *, void *);
void vmeattach(struct device *, struct device *, void *);
d54 6
a59 9
void vme2chip_init(struct vmesoftc *);
u_long vme2chip_map(u_long, int, int);
int vme2abort(void *);
int sysconabort(void *);
int vmeprint(void *, const char *);
void *vmemap(struct vmesoftc *sc, off_t vmeaddr, int len, int bustype);
void vmeunmap(void *, int);

void vmesyscon_init(struct vmesoftc *);
d62 1
a62 3
int vmevecbase;

struct vme2reg *sys_vme2;
a71 9
int
vmematch(parent, cf, args)
	struct device *parent;
	void *cf;
	void *args;
{
	return (1);
}

d73 1
a73 2
 * make local addresses 1G-2G correspond to VME addresses 3G-4G,
 * as D32
d76 12
a87 4
#define VME2_D32STARTPHYS	(1*1024*1024*1024UL)
#define VME2_D32ENDPHYS		(2*1024*1024*1024UL)
#define VME2_D32STARTVME	(3*1024*1024*1024UL)
#define VME2_D32BITSVME		(3*1024*1024*1024UL)
d90 1
a90 2
 * make local addresses 3G-3.75G correspond to VME addresses 3G-3.75G,
 * as D16
a91 4
#define VME2_D16STARTPHYS	(3*1024*1024*1024UL)
#define VME2_D16ENDPHYS		(3*1024*1024*1024UL + 768*1024*1024UL)
#define VME2_A32D16STARTPHYS	(0xFF000000UL)
#define VME2_A32D16ENDPHYS		(0xFF7FFFFFUL)
d93 2
a94 13

/*
 * Returns a physical address mapping for a VME address & length.
 * Note: on some hardware it is not possible to create certain
 * mappings, ie. the MVME147 cannot do 32 bit accesses to VME bus
 * addresses from 0 to physmem.
 */
void *
vmepmap(sc, vmeaddr, len, bustype)
	struct device *sc;
	off_t vmeaddr;
	int len;
	int bustype;
d96 1
a96 1
	u_int32_t base = (u_int32_t)vmeaddr;
d98 4
a101 10
	len = roundup(len, NBPG);
	switch (vmebustype) {
#if NPCCTWO > 0 || NSYSCON > 0
	case BUS_PCCTWO:
	case BUS_SYSCON:
		switch (bustype) {
		case BUS_VMES:		/* D16 VME Transfers */
#ifdef DEBUG
			printf("base 0x%8llx/0x%8x len 0x%x\n",
			    vmeaddr, base, len);
d103 14
a116 11
			base = vme2chip_map(base, len, 16);
			if (base == NULL) {
				printf("%s: cannot map pa 0x%x len 0x%x\n",
				    sc->dv_xname, base, len);
				return (NULL);
			}
			break;
		case BUS_VMEL:		/* D32 VME Transfers */
#ifdef DEBUG
			printf("base 0x%8llx/0x%8x len 0x%x\n",
			    vmeaddr, base, len);
a117 12
			base = vme2chip_map(base, len, 32);
			if (base == NULL) {
				printf("%s: cannot map pa 0x%x len 0x%x\n",
				    sc->dv_xname, base, len);
				return (NULL);
			}
			break;
		}
		break;
#endif
	}
	return ((void *)base);
d120 3
a122 7
/* if successful, returns the va of a vme bus mapping */
void *
vmemap(sc, vmeaddr, len, bustype)
	struct vmesoftc *sc;
	off_t vmeaddr;
	int len;
	int bustype;
d124 2
a125 7
	void *pa, *va;

	pa = vmepmap((struct device *)sc, vmeaddr, len, bustype);
	if (pa == NULL)
		return (NULL);
	va = mapiodev(pa, len);
	return (va);
d128 2
a129 4
void
vmeunmap(va, len)
	void *va;
	int len;
d131 1
a131 1
	unmapiodev(va, len);
d134 4
d139 4
a142 5
vmerw(sc, uio, flags, bus)
	struct device *sc;
	struct uio *uio;
	int flags;
	int bus;
d144 5
a148 32
	vaddr_t v;
	int c;
	struct iovec *iov;
	void *vme;
	int error = 0;

	while (uio->uio_resid > 0 && error == 0) {
		iov = uio->uio_iov;
		if (iov->iov_len == 0) {
			uio->uio_iov++;
			uio->uio_iovcnt--;
			if (uio->uio_iovcnt < 0)
				panic("vmerw");
			continue;
		}

		v = uio->uio_offset;
		c = min(iov->iov_len, MAXPHYS);
		if ((v & PGOFSET) + c > NBPG)	/* max NBPG at a time */
			c = NBPG - (v & PGOFSET);
		if (c == 0)
			return (0);
		vme = vmemap((struct vmesoftc *)sc, v & ~PGOFSET,
		    NBPG, BUS_VMES);
		if (vme == NULL) {
			error = EFAULT;	/* XXX? */
			continue;
		}
		error = uiomove((void *)vme + (v & PGOFSET), c, uio);
		vmeunmap(vme, NBPG);
	}
	return (error);
d158 1
a158 1
	printf(" addr 0x%x", ca->ca_offset);
a172 1
	struct vmesoftc *sc = (struct vmesoftc *)parent;
a173 1
	size_t len;
d176 1
d178 4
a181 5
	oca.ca_paddr = (void *)cf->cf_loc[0];
	oca.ca_len = cf->cf_loc[1];
	oca.ca_vec = cf->cf_loc[2];
	oca.ca_ipl = cf->cf_loc[3];
	if (oca.ca_ipl > 0 && oca.ca_vec == -1)
a182 10
	if (oca.ca_len == -1)
		oca.ca_len = PAGE_SIZE;
	len = oca.ca_len;

	oca.ca_offset = (u_int)oca.ca_paddr;
	oca.ca_vaddr = vmemap(sc, (vaddr_t)oca.ca_paddr, oca.ca_len,
	    oca.ca_bustype);
	if (oca.ca_vaddr == NULL)
		oca.ca_vaddr = (void *)-1;	/* XXX */
	oca.ca_master = (void *)sc;
d184 2
a185 3
	if ((*cf->cf_attach->ca_match)(parent, cf, &oca) == 0) {
		if (oca.ca_vaddr != (void *)-1)
			vmeunmap(oca.ca_vaddr, len);
a186 16
	}

	/*
	 * Map the whole space the driver is interested in.
	 */
	if (len != oca.ca_len) {
		vmeunmap(oca.ca_vaddr, len);
		if (oca.ca_len != 0) {
			if (vmemap(sc, (vaddr_t)oca.ca_paddr, oca.ca_len,
			    oca.ca_bustype) == NULL) {
				printf("%s: can't map VME space\n",
				    oca.ca_name);
				return (0);
			}
		}
	}
d200 11
a210 1
	sc->sc_vaddr = ca->ca_vaddr;
d217 1
a217 1
		struct vme2reg *vme2;
d219 8
a226 4
		vme2 = (struct vme2reg *)sc->sc_vaddr;
		/* Sanity check that the Bug is set up right */
		if (VME2_GET_VBR1(vme2) >= 0xF0) {
			panic("Correct the VME Vector Base Registers in the Bug ROM.\nSuggested values are 0x60 for VME Vec0 and 0x70 for VME Vec1.");
d228 4
a231 4
		vmevecbase = VME2_GET_VBR1(vme2) + 0x10;
		printf(": vector base 0x%x", vmevecbase);
		if (vme2->vme2_tctl & VME2_TCTL_SCON)
			printf(", system controller");
d233 1
d248 1
d267 133
a427 7
#if NPCCTWO > 0
	struct vme2reg *vme2;
#endif
#if NSYSCON > 0
	struct sysconreg *syscon;
#endif
	int x;
d432 3
a434 8
		vme2 = (struct vme2reg *)sc->sc_vaddr;
		vme2->vme2_irqen = vme2->vme2_irqen |
		    VME2_IRQ_VME(ih->ih_ipl);
		break;
#endif
#if NSYSCON > 0
	case BUS_SYSCON:
		syscon = (struct sysconreg *)sc->sc_vaddr;
d438 2
a439 2
	x = (intr_establish(vec, ih));
	return (x);
d447 1
a447 4
	struct vme2reg *vme2 = (struct vme2reg *)sc->sc_vaddr;
	u_long ctl;

	sys_vme2 = vme2;
d450 3
a452 1
	vme2->vme2_tctl &= ~VME2_TCTL_SYSFAIL;
d458 1
a458 1
	ctl = vme2->vme2_gcsrctl;
d460 1
d462 2
a463 3
		    sc->sc_dev.dv_xname,
		    vme2->vme2_master1 << 16, vme2->vme2_master1 & 0xffff0000,
		    vme2->vme2_master1 << 16, vme2->vme2_master1 & 0xffff0000);
d466 1
d468 2
a469 3
		    sc->sc_dev.dv_xname,
		    vme2->vme2_master2 << 16, vme2->vme2_master2 & 0xffff0000,
		    vme2->vme2_master2 << 16, vme2->vme2_master2 & 0xffff0000);
d472 1
d474 2
a475 3
		    sc->sc_dev.dv_xname,
		    vme2->vme2_master3 << 16, vme2->vme2_master3 & 0xffff0000,
		    vme2->vme2_master3 << 16, vme2->vme2_master3 & 0xffff0000);
d478 3
d482 3
a484 5
		    sc->sc_dev.dv_xname,
		    vme2->vme2_master4 << 16, vme2->vme2_master4 & 0xffff0000,
		    (vme2->vme2_master4 << 16) + (vme2->vme2_master4mod << 16),
		    (vme2->vme2_master4 & 0xffff0000) +
		      (vme2->vme2_master4mod & 0xffff0000));
d491 5
a495 4
	vme2->vme2_irql4 = (7 << VME2_IRQL4_VME7SHIFT) |
	    (6 << VME2_IRQL4_VME6SHIFT) | (5 << VME2_IRQL4_VME5SHIFT) |
	    (4 << VME2_IRQL4_VME4SHIFT) | (3 << VME2_IRQL4_VME3SHIFT) |
	    (2 << VME2_IRQL4_VME2SHIFT) | (1 << VME2_IRQL4_VME1SHIFT);
d499 2
a500 1
	vme2->vme2_tctl |= VME2_TCTL_RSWE;
d502 2
a503 1
	vme2->vme2_tcr |= VME2_TCR_64S;
d505 3
a507 1
	vme2->vme2_vbr |= VME2_IOCTL1_MIEN;
d511 5
a515 5
	vme2->vme2_irql3 = (7 << VME2_IRQL3_SW7SHIFT) |
	    (7 << VME2_IRQL3_SW6SHIFT) | (7 << VME2_IRQL3_SW5SHIFT) |
	    (7 << VME2_IRQL3_SW4SHIFT) | (7 << VME2_IRQL3_SW3SHIFT) |
	    (7 << VME2_IRQL3_SW2SHIFT) | (7 << VME2_IRQL3_SW1SHIFT) |
	    (7 << VME2_IRQL3_SW0SHIFT);
d525 4
a528 1
	vme2->vme2_irqen |= VME2_IRQ_AB;
d534 2
a535 1
	vme2->vme2_irqen = (vme2->vme2_irqen | VME2_IRQ_ACF) & ~VME2_IRQ_TIC1;
d560 1
a560 1
vme2chip_map(base, len, dwidth)
d562 1
a562 1
	int len, dwidth;
d564 4
d570 3
d576 2
a577 2
		    base + (u_long)len > VME2_D32ENDPHYS)
			return (NULL);
d579 2
d582 1
a582 1
	return (base);
d592 1
a592 2
	struct vmesoftc *sc = (struct vmesoftc *) vme_cd.cd_devs[0];
	struct vme2reg *vme2 = (struct vme2reg *)sc->sc_vaddr;
d594 2
a595 1
	if ((vme2->vme2_irqstat & VME2_IRQ_AB) == 0) {
d600 1
a600 1
	vme2->vme2_irqclr = VME2_IRQ_AB;
a604 1

@


1.32
log
@During bootup, only print the VMEChip2 decoder settings for those which are
enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.30 2004/04/14 23:06:16 miod Exp $ */
a31 2
#include <sys/user.h>
#include <sys/tty.h>
a34 2
#include <sys/syslog.h>
#include <sys/fcntl.h>
a35 1
#include <uvm/uvm_extern.h>
a40 1
#include <machine/pmap.h>
d231 2
a234 2
	if (ca->ca_ipl > 0)
		printf(" ipl %d", ca->ca_ipl);
d256 1
a256 1
		oca.ca_vec = vme_findvec();
d346 1
a346 1
vme_findvec(void)
d348 1
a348 1
	return(intr_findvec(vmevecbase, 0xFF));
d512 1
a512 1
 * XXX smurph - This is bogus, get rid of it! Should check vme/syson for offsets.
@


1.31
log
@When the abort button is pressed on 1x7, do not invoke the trap handler twice.
@
text
@d425 3
a427 1
	ctl = vme2->vme2_masterctl;
d429 27
a455 17
	/* setup a A32D16 space */
	printf("%s: 1phys 0x%08lx-0x%08lx to VME 0x%08lx-0x%08lx\n",
	       sc->sc_dev.dv_xname,
	       vme2->vme2_master1 << 16, vme2->vme2_master1 & 0xffff0000,
	       vme2->vme2_master1 << 16, vme2->vme2_master1 & 0xffff0000);

	/* setup a A32D32 space */
	printf("%s: 2phys 0x%08lx-0x%08lx to VME 0x%08lx-0x%08lx\n",
	       sc->sc_dev.dv_xname,
	       vme2->vme2_master2 << 16, vme2->vme2_master2 & 0xffff0000,
	       vme2->vme2_master2 << 16, vme2->vme2_master2 & 0xffff0000);

	/* setup a A24D16 space */
	printf("%s: 3phys 0x%08lx-0x%08lx to VME 0x%08lx-0x%08lx\n",
	       sc->sc_dev.dv_xname,
	       vme2->vme2_master3 << 16, vme2->vme2_master3 & 0xffff0000,
	       vme2->vme2_master3 << 16, vme2->vme2_master3 & 0xffff0000);
a456 6
	/* setup a XXXXXX space */
	printf("%s: 4phys 0x%08lx-0x%08lx to VME 0x%08lx-0x%08lx\n",
	       sc->sc_dev.dv_xname,
	       vme2->vme2_master4 << 16, vme2->vme2_master4 & 0xffff0000,
	       (vme2->vme2_master4 << 16) + (vme2->vme2_master4mod << 16),
	       (vme2->vme2_master4 & 0xffff0000) + (vme2->vme2_master4mod & 0xffff0000));
a465 4
	/*
	printf("%s: vme2_irql4 = 0x%08x\n",	sc->sc_dev.dv_xname,
	    vme2->vme2_irql4);
	*/
a504 18
#ifdef TODO
	struct sysconreg *syscon = (struct sysconreg *)sc->sc_vaddr;
	u_long ctl;

	/* turn off SYSFAIL LED */
	vme2->vme2_tctl &= ~VME2_TCTL_SYSFAIL;

	ctl = vme2->vme2_masterctl;
	printf("%s: using BUG parameters\n", sc->sc_dev.dv_xname);
	printf("%s: 1phys 0x%08x-0x%08x to VME 0x%08x-0x%08x master\n",
	       sc->sc_dev.dv_xname,
	       vme2->vme2_master1 << 16, vme2->vme2_master1 & 0xffff0000,
	       vme2->vme2_master1 << 16, vme2->vme2_master1 & 0xffff0000);
	printf("%s: 2phys 0x%08x-0x%08x to VME 0x%08x-0x%08x slave\n",
	       sc->sc_dev.dv_xname,
	       vme2->vme2_master2 << 16, vme2->vme2_master2 & 0xffff0000,
	       vme2->vme2_master2 << 16, vme2->vme2_master2 & 0xffff0000);

d506 3
a508 1
	 * pseudo driver, abort interrupt handler
a509 6
	sc->sc_abih.ih_fn = sysconabort;
	sc->sc_abih.ih_arg = 0;
	sc->sc_abih.ih_wantframe = 1;
	sc->sc_abih.ih_ipl = IPL_NMI;
	intr_establish(110, &sc->sc_abih);
#endif /* TODO */
@


1.30
log
@After enough checks on real hardware, it turns out the documentation is wrong,
for once - SCON in GLOBAL1 on MVME188 is an SCON*, thus low if the board is
the system controller.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.29 2004/01/14 20:52:52 miod Exp $ */
d450 1
a450 1
	       (vme2->vme2_master4 & 0xffff0000) + (vme2->vme2_master4 & 0xffff0000));
a565 1
	int rc = 0;
d567 1
a567 12
	if (vme2->vme2_irqstat & VME2_IRQ_AB) {
		vme2->vme2_irqclr = VME2_IRQ_AB;
		nmihand(frame);
		rc = 1;
	}
	if (vme2->vme2_irqstat & VME2_IRQ_AB) {
		vme2->vme2_irqclr = VME2_IRQ_AB;
		nmihand(frame);
		rc = 1;
	}
#if 0
	if (vme2->vme2_irqstat & VME2_IRQ_AB == 0) {
d571 1
a571 1
#endif
@


1.29
log
@mvme* do not support buses with indirect configuration, so don't check and
mourn for this.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.28 2004/01/14 20:50:48 miod Exp $ */
d337 1
a337 1
		if (ISSET(sconc, M188_SYSCON))
@


1.28
log
@Do not fill more than the first three fields of cfdriver structures unless
necessary. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.27 2003/12/28 19:44:26 miod Exp $ */
a253 5

	if (parent->dv_cfdata->cf_driver->cd_indirect) {
		printf(" indirect devices not supported\n");
		return 0;
	}
@


1.27
log
@Having vmel and vmes keep another pointer to their parent in their softc is
just plain silly!
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.26 2003/12/27 23:56:41 miod Exp $ */
d79 1
a79 1
        NULL, "vme", DV_DULL, 0
@


1.26
log
@Do not print vaddr in vme attachments.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.25 2003/12/22 11:54:48 miod Exp $ */
d119 1
a119 1
	struct vmesoftc *sc;
d140 1
a140 1
				    sc->sc_dev.dv_xname, base, len);
d152 1
a152 1
				    sc->sc_dev.dv_xname, base, len);
d173 1
a173 1
	pa = vmepmap(sc, vmeaddr, len, bustype);
d190 1
a190 1
	struct vmesoftc *sc;
d217 1
a217 1
		vme = vmemap(sc, v & ~PGOFSET,
@


1.25
log
@Correctly handle vme attachments which specify a larger ca_len size than
initially expected.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.24 2003/12/19 22:30:18 miod Exp $ */
d138 1
a138 1
			if (base == NULL){
d150 1
a150 1
			if (base == NULL){
d236 1
a236 1
	printf(" addr 0x%x vaddr %p", ca->ca_offset, ca->ca_vaddr);
@


1.24
log
@Pass -Wformat, and silence a few vme* debug printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.23 2003/10/08 22:36:11 miod Exp $ */
d63 2
a65 1
int vmeprint(void *, const char *);
d253 1
d269 2
a270 1
		oca.ca_len = 4096;
d275 2
a276 2
	if (!oca.ca_vaddr)
		oca.ca_vaddr = (void *)-1;
d281 1
a281 1
			vmeunmap(oca.ca_vaddr, oca.ca_len);
d284 1
d286 1
a286 2
	 * If match works, the driver is responsible for
	 * vmunmap()ing if it does not need the mapping.
d288 12
@


1.23
log
@Sync VMEChip2 timer usage with mvme68k (i.e. make it slightly more sane).
Also, use it even when the 1x7 is not a system controller - this does not
matter.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.22 2003/10/05 20:27:48 miod Exp $ */
d132 4
a135 1
			/*printf("base 0x%8x/0x%8x len 0x%x\n", vmeaddr, base, len);*/
d144 4
a147 2
			printf("base 0x%8x/0x%8x len 0x%x\n",
				vmeaddr, base, len);
d235 1
a235 2
	printf(" addr 0x%x", ca->ca_offset);
	printf(" vaddr 0x%x", ca->ca_vaddr);
d418 1
a418 1
	printf("%s: 1phys 0x%08x-0x%08x to VME 0x%08x-0x%08x\n",
d424 1
a424 1
	printf("%s: 2phys 0x%08x-0x%08x to VME 0x%08x-0x%08x\n",
d430 1
a430 1
	printf("%s: 3phys 0x%08x-0x%08x to VME 0x%08x-0x%08x\n",
d436 1
a436 1
	printf("%s: 4phys 0x%08x-0x%08x to VME 0x%08x-0x%08x\n",
@


1.22
log
@Kill vm_offset_t and vm_size_t, in favor of the [pv]addr_t and [pv]size_t
typedefs.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.21 2003/09/28 22:14:33 miod Exp $ */
d71 1
a71 1
struct vme2reg *sys_vme2 = NULL;
a299 1
		int scon;
a307 1
		scon = (vme2->vme2_tctl & VME2_TCTL_SCON);
d309 1
a309 1
		if (scon != 0)
a310 2
		if (scon)
			sys_vme2 = vme2;
d406 2
d460 21
a480 14
	vme2->vme2_irql3 = (7 << VME2_IRQL3_SW7SHIFT) | (7 << VME2_IRQL3_SW6SHIFT) |
			(7 << VME2_IRQL3_SW5SHIFT) | (7 << VME2_IRQL3_SW4SHIFT) |
			(7 << VME2_IRQL3_SW3SHIFT) | (7 << VME2_IRQL3_SW2SHIFT) |
			(7 << VME2_IRQL3_SW1SHIFT) | (7 << VME2_IRQL3_SW0SHIFT);
		/*
		 * pseudo driver, abort interrupt handler
		 */
		sc->sc_abih.ih_fn = vme2abort;
		sc->sc_abih.ih_arg = 0;
		sc->sc_abih.ih_wantframe = 1;
		sc->sc_abih.ih_ipl = IPL_NMI;
		intr_establish(110, &sc->sc_abih);
		vme2->vme2_irqen |= VME2_IRQ_AB;
	vme2->vme2_irqen |= VME2_IRQ_ACF;
@


1.21
log
@Clean various MVME188 related routines, fixing typos and removing unnecessary
diagnostic code in the process.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.20 2003/06/04 04:11:37 deraadt Exp $ */
d52 1
a52 1
#if NSYSCON > 0 
d75 2
a76 2
}; 
 
d79 1
a79 1
}; 
d189 3
a191 3
	register vm_offset_t v;
	register int c;
	register struct iovec *iov;
d266 1
a266 1
	oca.ca_vaddr = vmemap(sc, (vm_offset_t)oca.ca_paddr, oca.ca_len,
d279 1
a279 1
	 * vmunmap()ing if it does not need the mapping. 
d361 3
a363 3
 * All VME bus devices will use a vector starting with VBR1 + 0x10 
 * and determined by intr_findvec(). (in machdep.c) vmeintr_establish() 
 * should be called with the 'vec' argument = 0 to 'auto vector' a 
d366 1
a366 1
 * The 8 SW interrupters will start with VBR1.  The rest will start 
d392 1
a392 1
#if NSYSCON > 0 
d462 1
a462 1
	vme2->vme2_irql3 = (7 << VME2_IRQL3_SW7SHIFT) | (7 << VME2_IRQL3_SW6SHIFT) | 
d464 1
a464 1
			(7 << VME2_IRQL3_SW3SHIFT) | (7 << VME2_IRQL3_SW2SHIFT) | 
d466 1
a466 1
		/* 
d502 1
a502 1
	/* 
d564 1
a564 1
#endif 
@


1.20
log
@more term 3 and 4 changes
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.19 2002/03/14 01:26:39 millert Exp $ */
a292 2
	/* XXX any initialization to do? */

d294 1
a295 1
	vmebustype = ca->ca_bustype;
d310 3
a312 1
		printf(": vector base 0x%x, %ssystem controller\n", vmevecbase, scon ? "" : "not ");
d315 1
d323 1
a323 1
		char sconc;
d326 4
a329 3
		sconc = *(char *)GLOBAL1;
		sconc &= M188_SYSCON;
		printf(": %ssystem controller\n", sconc ? "" : "not ");
d335 1
@


1.19
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.18 2001/12/16 23:49:46 miod Exp $ */
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Theo de Raadt
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.18
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.16 2001/11/07 22:31:57 miod Exp $ */
d61 2
a62 2
int  vmematch __P((struct device *, void *, void *));
void vmeattach __P((struct device *, struct device *, void *));
d64 6
a69 6
void vme2chip_init __P((struct vmesoftc *));
u_long vme2chip_map __P((u_long, int, int));
int vme2abort __P((void *));
int sysconabort __P((void *));
void vmeunmap __P((void *, int));
int vmeprint __P((void *, const char *));
d71 1
a71 1
void vmesyscon_init __P((struct vmesoftc *));
@


1.18.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.18 2001/12/16 23:49:46 miod Exp $ */
d61 2
a62 2
int  vmematch(struct device *, void *, void *);
void vmeattach(struct device *, struct device *, void *);
d64 6
a69 6
void vme2chip_init(struct vmesoftc *);
u_long vme2chip_map(u_long, int, int);
int vme2abort(void *);
int sysconabort(void *);
void vmeunmap(void *, int);
int vmeprint(void *, const char *);
d71 1
a71 1
void vmesyscon_init(struct vmesoftc *);
@


1.17
log
@Support for MVME197 completed.  Fix SPL defs.
@
text
@d411 1
d465 12
a476 12
			   (7 << VME2_IRQL3_SW5SHIFT) | (7 << VME2_IRQL3_SW4SHIFT) |
			   (7 << VME2_IRQL3_SW3SHIFT) | (7 << VME2_IRQL3_SW2SHIFT) | 
			   (7 << VME2_IRQL3_SW1SHIFT) | (7 << VME2_IRQL3_SW0SHIFT);
	/* 
	 * pseudo driver, abort interrupt handler
	 */
	sc->sc_abih.ih_fn = vme2abort;
	sc->sc_abih.ih_arg = 0;
	sc->sc_abih.ih_wantframe = 1;
	sc->sc_abih.ih_ipl = IPL_NMI;
	intr_establish(110, &sc->sc_abih);
	vme2->vme2_irqen |= VME2_IRQ_AB;
@


1.16
log
@post-mmap API change fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.15 2001/11/06 19:53:15 miod Exp $ */
a410 1

d464 12
a475 12
			(7 << VME2_IRQL3_SW5SHIFT) | (7 << VME2_IRQL3_SW4SHIFT) |
			(7 << VME2_IRQL3_SW3SHIFT) | (7 << VME2_IRQL3_SW2SHIFT) | 
			(7 << VME2_IRQL3_SW1SHIFT) | (7 << VME2_IRQL3_SW0SHIFT);
		/* 
		 * pseudo driver, abort interrupt handler
		 */
		sc->sc_abih.ih_fn = vme2abort;
		sc->sc_abih.ih_arg = 0;
		sc->sc_abih.ih_wantframe = 1;
		sc->sc_abih.ih_ipl = IPL_NMI;
		intr_establish(110, &sc->sc_abih);
		vme2->vme2_irqen |= VME2_IRQ_AB;
@


1.15
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.14 2001/10/28 00:57:38 miod Exp $ */
a67 1
void * vmemap __P((struct vmesoftc *, void *, int, int));
d124 1
a124 1
	void *vmeaddr;
d166 1
a166 1
	void *vmeaddr;
d216 1
a216 1
		vme = vmemap(sc, (void *)(v & ~PGOFSET),
d271 2
a272 1
	oca.ca_vaddr = vmemap(sc, oca.ca_paddr, oca.ca_len, oca.ca_bustype);
@


1.14
log
@Let 188-only kernels compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.13 2001/09/11 20:05:24 miod Exp $ */
d45 1
a45 1
#include <vm/vm.h>
@


1.13
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.12 2001/08/26 02:37:07 miod Exp $ */
a296 1
	struct vme2reg *vme2;
d308 1
@


1.12
log
@Add prototypes, fix compilation warnings, random style fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.11 2001/08/24 19:34:21 miod Exp $ */
a45 1
#include <vm/vm_kern.h>
@


1.11
log
@Correctly tell if a syscon is main one on 188.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.10 2001/08/11 23:21:13 art Exp $ */
d47 6
a52 4
#include "machine/autoconf.h"
#include "machine/cpu.h"
#include "machine/frame.h"
#include "machine/pmap.h"
d65 2
a66 2
void vme2chip_init __P((struct vmesoftc *sc));
u_long vme2chip_map __P((u_long base, int len, int dwidth));
d69 5
a73 1
int     intr_findvec __P((int start, int end));
d75 2
a76 2
static int vmebustype;
static int vmevecbase;
@


1.10
log
@Unnecessary and redundant includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.9 2001/03/09 05:44:39 smurph Exp $ */
a292 1
	int scon;
d302 3
d313 2
a314 1
		if (scon) sys_vme2 = vme2;
d316 1
d321 9
a329 8
		{
			char sconc;
			vmevecbase = 0x80;  /* Hard coded for MVME188 */
			sconc = *(char *)GLOBAL1;
			sconc &= M188_SYSCON;
			printf(": %ssystem controller\n", scon ? "" : "not ");
			vmesyscon_init(sc);
		}
@


1.9
log
@kernel will compile with -Werror.  Added intr.h
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.8 2001/03/07 23:45:52 miod Exp $ */
a45 1
#include <vm/vm_map.h>
@


1.8
log
@Fix interrupt handler registration and prototypes.
While there, some warning hunting.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.7 2001/02/01 03:38:15 smurph Exp $ */
d288 2
a289 2
struct device *parent, *self;
void *args;
a294 1
	char sconc;
d318 8
a325 5
		vmevecbase = 0x80;  /* Hard coded for MVME188 */
		sconc = *(char *)GLOBAL1;
		sconc &= M188_SYSCON;
		printf(": %ssystem controller\n", scon ? "" : "not ");
		vmesyscon_init(sc);
d475 1
a475 1
struct vmesoftc *sc;
d521 1
a521 1
		return (base);
d526 1
a526 1
		return (base);
d528 1
@


1.7
log
@Major changes to get MVME188 working.  More header and code cleanups.  The
kernel is tested on MVME188A/2P256 and MVME188A/1P64.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.6 2001/01/14 20:25:22 smurph Exp $ */
d64 1
a64 1
int vme2chip_init __P((struct vmesoftc *sc));
d66 2
a67 2
int vme2abort __P((struct frame *frame));
int sysconabort __P((struct frame *frame));
a88 1
	struct confargs *ca = args;
d191 1
a191 1
	register vm_offset_t o, v;
a248 1
	struct confargs *ca = args;
a292 1
	struct vme1reg *vme1;
d394 1
a394 1
int
d399 1
a399 1
	u_long ctl, addr, vasize;
d428 2
a429 2
	       vme2->vme2_master4 << 16 + vme2->vme2_master4mod << 16,
	       vme2->vme2_master4 & 0xffff0000 + vme2->vme2_master4 & 0xffff0000);
d462 1
a463 1
		sc->sc_abih.ih_wantframe = 1;
d471 1
a471 1
int
d475 1
d477 1
a477 1
	u_long ctl, addr, vasize;
a478 1
#ifdef TODO
d498 1
a499 1
	sc->sc_abih.ih_wantframe = 1;
a504 2
#if defined(MVME162) || defined(MVME167) || defined(MVME177) || defined(MVME188) || defined (MVME187) || defined (MVME197)

d530 2
a531 2
vme2abort(frame)
	struct frame *frame;
d533 2
a559 2
#endif /* MVME1[678]x */

@


1.6
log
@Complete move to UVM virtual memory system.  More header fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.5 2000/03/26 23:32:00 deraadt Exp $ */
d68 1
d71 2
d265 1
a265 1
		oca.ca_vec = intr_findvec(255, 0);
d290 2
a291 2
	struct device *parent, *self;
	void *args;
d298 1
a298 1
   char sconc;
d309 5
d315 2
a316 2
		printf(": %ssystem controller\n", scon ? "" : "not ");
      if (scon) sys_vme2 = vme2;
d322 3
a324 3
		vme2 = (struct vme2reg *)sc->sc_vaddr;
      sconc = *(char *)GLOBAL1;
      sconc &= M188_SYSCON;
a329 1

d334 7
d353 11
a377 2
	x = (intr_establish(vec, ih));

a388 4
		/*
      syscon->vme2_irqen = vme2->vme2_irqen |
		    VMES_IRQ_VME(ih->ih_ipl);
      */
d392 1
d411 3
a413 3
	    sc->sc_dev.dv_xname,
	    vme2->vme2_master1 << 16, vme2->vme2_master1 & 0xffff0000,
	    vme2->vme2_master1 << 16, vme2->vme2_master1 & 0xffff0000);
d417 3
a419 3
	    sc->sc_dev.dv_xname,
	    vme2->vme2_master2 << 16, vme2->vme2_master2 & 0xffff0000,
	    vme2->vme2_master2 << 16, vme2->vme2_master2 & 0xffff0000);
d423 3
a425 3
	    sc->sc_dev.dv_xname,
	    vme2->vme2_master3 << 16, vme2->vme2_master3 & 0xffff0000,
	    vme2->vme2_master3 << 16, vme2->vme2_master3 & 0xffff0000);
d429 4
a432 4
	    sc->sc_dev.dv_xname,
	    vme2->vme2_master4 << 16, vme2->vme2_master4 & 0xffff0000,
	    vme2->vme2_master4 << 16 + vme2->vme2_master4mod << 16,
       vme2->vme2_master4 & 0xffff0000 + vme2->vme2_master4 & 0xffff0000);
d446 14
a459 1
	if (vmebustype == BUS_PCCTWO){
d469 1
a469 2
	}
	vme2->vme2_irqen = vme2->vme2_irqen | VME2_IRQ_ACF;
d476 1
a476 1
	struct vmesoftc *sc;
d488 3
a490 3
	    sc->sc_dev.dv_xname,
	    vme2->vme2_master1 << 16, vme2->vme2_master1 & 0xffff0000,
	    vme2->vme2_master1 << 16, vme2->vme2_master1 & 0xffff0000);
d492 12
a503 12
	    sc->sc_dev.dv_xname,
	    vme2->vme2_master2 << 16, vme2->vme2_master2 & 0xffff0000,
	    vme2->vme2_master2 << 16, vme2->vme2_master2 & 0xffff0000);

   /* 
    * pseudo driver, abort interrupt handler
    */
   sc->sc_abih.ih_fn = sysconabort;
   sc->sc_abih.ih_arg = 0;
   sc->sc_abih.ih_ipl = IPL_NMI;
   sc->sc_abih.ih_wantframe = 1;
   intr_establish(110, &sc->sc_abih);
d540 1
d542 11
d557 1
@


1.5
log
@callout.h is gone
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.4 1999/09/27 18:43:25 smurph Exp $ */
d455 1
a455 1
   printf("%s: 1phys 0x%08x-0x%08x to VME 0x%08x-0x%08x master\n",
d476 1
a476 1
#if defined(MVME162) || defined(MVME167) || defined(MVME177) || defined (MVME187) || defined (MVME197)
@


1.4
log
@adding support for MVME188 and MVME197.  Plus 32bit if_ie.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.3 1999/05/29 04:41:44 smurph Exp $ */
a39 1
#include <sys/callout.h>
@


1.4.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.9 2001/03/09 05:44:39 smurph Exp $ */
d40 1
d65 1
a65 1
void vme2chip_init __P((struct vmesoftc *sc));
d67 2
a68 3
int vme2abort __P((void *));
int sysconabort __P((void *));
int     intr_findvec __P((int start, int end));
a70 2
static int vmevecbase;

d87 1
d190 1
a190 1
	register vm_offset_t v;
d248 1
d263 1
a263 1
		oca.ca_vec = vme_findvec();
d293 1
d296 1
a306 5
		/* Sanity check that the Bug is set up right */
		if (VME2_GET_VBR1(vme2) >= 0xF0) {
			panic("Correct the VME Vector Base Registers in the Bug ROM.\nSuggested values are 0x60 for VME Vec0 and 0x70 for VME Vec1.");
		}
		vmevecbase = VME2_GET_VBR1(vme2) + 0x10;
d308 2
a309 2
		printf(": vector base 0x%x, %ssystem controller\n", vmevecbase, scon ? "" : "not ");
		if (scon) sys_vme2 = vme2;
d315 5
a319 8
		{
			char sconc;
			vmevecbase = 0x80;  /* Hard coded for MVME188 */
			sconc = *(char *)GLOBAL1;
			sconc &= M188_SYSCON;
			printf(": %ssystem controller\n", scon ? "" : "not ");
			vmesyscon_init(sc);
		}
d323 1
a327 7
/* find a VME vector based on what is in NVRAM settings. */
int
vme_findvec(void)
{
	return(intr_findvec(vmevecbase, 0xFF));
}

a339 11

/*
 * All VME bus devices will use a vector starting with VBR1 + 0x10 
 * and determined by intr_findvec(). (in machdep.c) vmeintr_establish() 
 * should be called with the 'vec' argument = 0 to 'auto vector' a 
 * VME device.
 *
 * The 8 SW interrupters will start with VBR1.  The rest will start 
 * with VBR0< 4) & 0xFF.
 */

d354 2
d367 4
a373 1
	x = (intr_establish(vec, ih));
d378 1
a378 1
void
d383 1
a383 1
	u_long ctl;
d392 3
a394 3
	       sc->sc_dev.dv_xname,
	       vme2->vme2_master1 << 16, vme2->vme2_master1 & 0xffff0000,
	       vme2->vme2_master1 << 16, vme2->vme2_master1 & 0xffff0000);
d398 3
a400 3
	       sc->sc_dev.dv_xname,
	       vme2->vme2_master2 << 16, vme2->vme2_master2 & 0xffff0000,
	       vme2->vme2_master2 << 16, vme2->vme2_master2 & 0xffff0000);
d404 3
a406 3
	       sc->sc_dev.dv_xname,
	       vme2->vme2_master3 << 16, vme2->vme2_master3 & 0xffff0000,
	       vme2->vme2_master3 << 16, vme2->vme2_master3 & 0xffff0000);
d410 4
a413 4
	       sc->sc_dev.dv_xname,
	       vme2->vme2_master4 << 16, vme2->vme2_master4 & 0xffff0000,
	       (vme2->vme2_master4 << 16) + (vme2->vme2_master4mod << 16),
	       (vme2->vme2_master4 & 0xffff0000) + (vme2->vme2_master4 & 0xffff0000));
d427 1
a427 14

	/* Enable the reset switch */
	vme2->vme2_tctl |= VME2_TCTL_RSWE;
	/* Set Watchdog timeout to about 1 minute */
	vme2->vme2_tcr |= VME2_TCR_64S;
	/* Enable VMEChip2 Interrupts */
	vme2->vme2_vbr |= VME2_IOCTL1_MIEN;
	/*
	 * Map the Software VME irq levels to the cpu level 7.
	*/
	vme2->vme2_irql3 = (7 << VME2_IRQL3_SW7SHIFT) | (7 << VME2_IRQL3_SW6SHIFT) | 
			(7 << VME2_IRQL3_SW5SHIFT) | (7 << VME2_IRQL3_SW4SHIFT) |
			(7 << VME2_IRQL3_SW3SHIFT) | (7 << VME2_IRQL3_SW2SHIFT) | 
			(7 << VME2_IRQL3_SW1SHIFT) | (7 << VME2_IRQL3_SW0SHIFT);
d433 1
a434 1
		sc->sc_abih.ih_ipl = IPL_NMI;
d437 2
a438 1
	vme2->vme2_irqen |= VME2_IRQ_ACF;
d443 1
a443 1
void
a446 1
#ifdef TODO
d448 1
a448 1
	u_long ctl;
d450 1
d456 4
a459 4
	printf("%s: 1phys 0x%08x-0x%08x to VME 0x%08x-0x%08x master\n",
	       sc->sc_dev.dv_xname,
	       vme2->vme2_master1 << 16, vme2->vme2_master1 & 0xffff0000,
	       vme2->vme2_master1 << 16, vme2->vme2_master1 & 0xffff0000);
d461 12
a472 12
	       sc->sc_dev.dv_xname,
	       vme2->vme2_master2 << 16, vme2->vme2_master2 & 0xffff0000,
	       vme2->vme2_master2 << 16, vme2->vme2_master2 & 0xffff0000);

	/* 
	 * pseudo driver, abort interrupt handler
	 */
	sc->sc_abih.ih_fn = sysconabort;
	sc->sc_abih.ih_arg = 0;
	sc->sc_abih.ih_wantframe = 1;
	sc->sc_abih.ih_ipl = IPL_NMI;
	intr_establish(110, &sc->sc_abih);
d477 2
d493 1
a493 1
		break;
d498 1
a498 1
		break;
a499 1
	return (base);
d504 2
a505 2
vme2abort(eframe)
	void *eframe;
a506 2
	struct frame *frame = eframe;

a508 1
	int rc = 0;
a509 11
	if (vme2->vme2_irqstat & VME2_IRQ_AB) {
		vme2->vme2_irqclr = VME2_IRQ_AB;
		nmihand(frame);
		rc = 1;
	}
	if (vme2->vme2_irqstat & VME2_IRQ_AB) {
		vme2->vme2_irqclr = VME2_IRQ_AB;
		nmihand(frame);
		rc = 1;
	}
#if 0
a513 1
#endif 
d519 2
@


1.4.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.4.4.1 2001/04/18 16:11:06 niklas Exp $ */
d46 6
a51 6

#include <machine/autoconf.h>
#include <machine/cpu.h>
#include <machine/frame.h>
#include <machine/locore.h>
#include <machine/pmap.h>
d64 2
a65 2
void vme2chip_init __P((struct vmesoftc *));
u_long vme2chip_map __P((u_long, int, int));
d68 1
a68 5
void * vmemap __P((struct vmesoftc *, void *, int, int));
void vmeunmap __P((void *, int));
int vmeprint __P((void *, const char *));

void vmesyscon_init __P((struct vmesoftc *));
d70 2
a71 2
int vmebustype;
int vmevecbase;
d294 1
a303 3
	{
		int scon;

d312 1
a312 2
		if (scon)
			sys_vme2 = vme2;
a313 1
	}
d318 8
a325 9
	{
		char sconc;

		vmevecbase = 0x80;  /* Hard coded for MVME188 */
		sconc = *(char *)GLOBAL1;
		sconc &= M188_SYSCON;
		printf(": %ssystem controller\n", sconc ? "" : "not ");
		vmesyscon_init(sc);
	}
@


1.4.4.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d45 1
a45 1
#include <uvm/uvm_extern.h>
d68 1
d125 1
a125 1
	off_t vmeaddr;
d167 1
a167 1
	off_t vmeaddr;
d217 1
a217 1
		vme = vmemap(sc, v & ~PGOFSET,
d272 1
a272 2
	oca.ca_vaddr = vmemap(sc, (vm_offset_t)oca.ca_paddr, oca.ca_len,
	    oca.ca_bustype);
d297 1
a308 1
		struct vme2reg *vme2;
@


1.4.4.4
log
@Merge in -current from about a week ago
@
text
@d61 2
a62 2
int  vmematch(struct device *, void *, void *);
void vmeattach(struct device *, struct device *, void *);
d64 6
a69 6
void vme2chip_init(struct vmesoftc *);
u_long vme2chip_map(u_long, int, int);
int vme2abort(void *);
int sysconabort(void *);
void vmeunmap(void *, int);
int vmeprint(void *, const char *);
d71 1
a71 1
void vmesyscon_init(struct vmesoftc *);
@


1.4.4.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.4.4.4 2002/03/28 10:36:02 niklas Exp $ */
d15 5
@


1.4.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d52 1
a52 1
#if NSYSCON > 0
d63 1
a64 2
void *vmemap(struct vmesoftc *sc, off_t vmeaddr, int len, int bustype);
void vmeunmap(void *, int);
d71 1
a71 1
struct vme2reg *sys_vme2;
d75 2
a76 2
};

d78 2
a79 2
        NULL, "vme", DV_DULL
};
d118 1
a118 1
	struct device *sc;
d132 1
a132 4
#ifdef DEBUG
			printf("base 0x%8llx/0x%8x len 0x%x\n",
			    vmeaddr, base, len);
#endif
d134 1
a134 1
			if (base == NULL) {
d136 1
a136 1
				    sc->dv_xname, base, len);
d141 2
a142 4
#ifdef DEBUG
			printf("base 0x%8llx/0x%8x len 0x%x\n",
			    vmeaddr, base, len);
#endif
d144 1
a144 1
			if (base == NULL) {
d146 1
a146 1
				    sc->dv_xname, base, len);
d167 1
a167 1
	pa = vmepmap((struct device *)sc, vmeaddr, len, bustype);
d184 1
a184 1
	struct device *sc;
d189 3
a191 3
	vaddr_t v;
	int c;
	struct iovec *iov;
d211 1
a211 1
		vme = vmemap((struct vmesoftc *)sc, v & ~PGOFSET,
d231 1
d248 5
a252 1
	size_t len;
d263 1
a263 2
		oca.ca_len = PAGE_SIZE;
	len = oca.ca_len;
d266 1
a266 1
	oca.ca_vaddr = vmemap(sc, (vaddr_t)oca.ca_paddr, oca.ca_len,
d268 2
a269 2
	if (oca.ca_vaddr == NULL)
		oca.ca_vaddr = (void *)-1;	/* XXX */
d274 1
a274 1
			vmeunmap(oca.ca_vaddr, len);
a276 1

d278 2
a279 1
	 * Map the whole space the driver is interested in.
a280 12
	if (len != oca.ca_len) {
		vmeunmap(oca.ca_vaddr, len);
		if (oca.ca_len != 0) {
			if (vmemap(sc, (vaddr_t)oca.ca_paddr, oca.ca_len,
			    oca.ca_bustype) == NULL) {
				printf("%s: can't map VME space\n",
				    oca.ca_name);
				return (0);
			}
		}
	}

d293 2
d296 1
a297 1

d302 1
d311 4
a314 4
		printf(": vector base 0x%x", vmevecbase);
		if (vme2->vme2_tctl & VME2_TCTL_SCON)
			printf(", system controller");
		printf("\n");
d322 1
a322 1
		u_int8_t sconc;
d325 3
a327 4
		sconc = *(volatile u_int8_t *)GLOBAL1;
		if (ISSET(sconc, M188_SYSCON))
			printf(": system controller");
		printf("\n");
a332 1

d358 3
a360 3
 * All VME bus devices will use a vector starting with VBR1 + 0x10
 * and determined by intr_findvec(). (in machdep.c) vmeintr_establish()
 * should be called with the 'vec' argument = 0 to 'auto vector' a
d363 1
a363 1
 * The 8 SW interrupters will start with VBR1.  The rest will start
d389 1
a389 1
#if NSYSCON > 0
a406 2
	sys_vme2 = vme2;

d413 1
a413 1
	printf("%s: 1phys 0x%08lx-0x%08lx to VME 0x%08lx-0x%08lx\n",
d419 1
a419 1
	printf("%s: 2phys 0x%08lx-0x%08lx to VME 0x%08lx-0x%08lx\n",
d425 1
a425 1
	printf("%s: 3phys 0x%08lx-0x%08lx to VME 0x%08lx-0x%08lx\n",
d431 1
a431 1
	printf("%s: 4phys 0x%08lx-0x%08lx to VME 0x%08lx-0x%08lx\n",
d459 14
a472 21
	vme2->vme2_irql3 = (7 << VME2_IRQL3_SW7SHIFT) |
	    (7 << VME2_IRQL3_SW6SHIFT) | (7 << VME2_IRQL3_SW5SHIFT) |
	    (7 << VME2_IRQL3_SW4SHIFT) | (7 << VME2_IRQL3_SW3SHIFT) |
	    (7 << VME2_IRQL3_SW2SHIFT) | (7 << VME2_IRQL3_SW1SHIFT) |
	    (7 << VME2_IRQL3_SW0SHIFT);

	/*
	 * pseudo driver, abort interrupt handler
	 */
	sc->sc_abih.ih_fn = vme2abort;
	sc->sc_abih.ih_arg = 0;
	sc->sc_abih.ih_wantframe = 1;
	sc->sc_abih.ih_ipl = IPL_NMI;
	intr_establish(110, &sc->sc_abih);
	vme2->vme2_irqen |= VME2_IRQ_AB;

	/*
	 * Enable ACFAIL interrupt, but disable Timer 1 interrupt - we
	 * prefer it without for delay().
	 */
	vme2->vme2_irqen = (vme2->vme2_irqen | VME2_IRQ_ACF) & ~VME2_IRQ_TIC1;
d499 1
a499 1
	/*
d561 1
a561 1
#endif
@


1.4.4.7
log
@Merge with the trunk
@
text
@a2 1
 * Copyright (c) 2004, Miodrag Vallat.
d32 2
d37 2
d40 1
d46 1
d56 2
a57 2
int	vmematch(struct device *, void *, void *);
void	vmeattach(struct device *, struct device *, void *);
d59 9
a67 6
void	vme2chip_init(struct vmesoftc *);
void	vmesyscon_init(struct vmesoftc *);
u_long	vme2chip_map(u_long, int);
int	vme2abort(void *);
int	sysconabort(void *);
int	vmeprint(void *, const char *);
d70 3
a72 1
unsigned int vmevecbase;
a81 109
/*
 * bus_space routines for VME mappings
 */

int	vme_map(bus_addr_t, bus_size_t, int, bus_space_handle_t *);
void	vme_unmap(bus_space_handle_t, bus_size_t);
int	vme_subregion(bus_space_handle_t, bus_size_t, bus_size_t,
	    bus_space_handle_t *);
void *	vme_vaddr(bus_space_handle_t);

const struct mvme88k_bus_space_tag vme_bustag = {
	vme_map,
	vme_unmap,
	vme_subregion,
	vme_vaddr
};

/*
 * VME space mapping functions
 */

int
vme_map(bus_addr_t addr, bus_size_t size, int flags, bus_space_handle_t *ret)
{
	vaddr_t map;

#if 0
	map = iomap_mapin(addr, size, 0);
#else
	map = (vaddr_t)mapiodev((void *)addr, size);
#endif
	if (map == NULL)
		return ENOMEM;

	*ret = (bus_space_handle_t)map;
	return 0;
}

void
vme_unmap(bus_space_handle_t handle, bus_size_t size)
{
#if 0
	iomap_mapout(handle, size);
#else
	unmapiodev((void *)handle, size);
#endif
}

int
vme_subregion(bus_space_handle_t handle, bus_addr_t offset, bus_size_t size,
    bus_space_handle_t *ret)
{
	*ret = handle + offset;
	return (0);
}

void *
vme_vaddr(bus_space_handle_t handle)
{
	return (void *)handle;
}

/*
 * Extra D16 access functions
 *
 * D16 cards will trigger bus errors on attempting to read or write more
 * than 16 bits on the bus. Given how the m88k processor works, this means
 * basically that all long (D32) accesses must be carefully taken care of.
 *
 * Since the kernels bcopy() and bzero() routines will use 32 bit accesses
 * for performance, here are specific D16-compatible routines. They will
 * also revert to D8 operations if neither of the operands is properly
 * aligned.
 */

void d16_bcopy(const void *, void *, size_t);
void d16_bzero(void *, size_t);

void
d16_bcopy(const void *src, void *dst, size_t len)
{
	if ((vaddr_t)src & 1 || (vaddr_t)dst & 1)
		bus_space_write_region_1(&vme_bustag, 0, (vaddr_t)dst,
		    (void *)src, len);
	else {
		bus_space_write_region_2(&vme_bustag, 0, (vaddr_t)dst,
		    (void *)src, len / 2);
		if (len & 1)
			bus_space_write_1(&vme_bustag, 0,
			    dst + len - 1, *(u_int8_t *)(src + len - 1));
	}
}

void
d16_bzero(void *dst, size_t len)
{
	if ((vaddr_t)dst & 1)
		bus_space_set_region_1(&vme_bustag, 0, (vaddr_t)dst, 0, len);
	else {
		bus_space_set_region_2(&vme_bustag, 0, (vaddr_t)dst, 0, len / 2);
		if (len & 1)
			bus_space_write_1(&vme_bustag, 0, dst + len - 1, 0);
	}
}

/*
 * Configuration glue
 */

a87 4
#ifdef MVME187
	if (brdtyp == BRD_8120)
		return (0);
#endif
a90 116
int
vmeprint(args, bus)
	void *args;
	const char *bus;
{
	struct confargs *ca = args;

	printf(" addr 0x%x", ca->ca_paddr);
	if (ca->ca_ipl > 0)
		printf(" ipl %d", ca->ca_ipl);
	if (ca->ca_vec > 0)
		printf(" vec 0x%x", ca->ca_vec);
	return (UNCONF);
}

int
vmescan(parent, child, args, bustype)
	struct device *parent;
	void *child, *args;
	int bustype;
{
	struct cfdata *cf = child;
	struct confargs oca, *ca = args;

	bzero(&oca, sizeof oca);
	oca.ca_iot = &vme_bustag;
	oca.ca_dmat = ca->ca_dmat;
	oca.ca_bustype = bustype;
	oca.ca_paddr = cf->cf_loc[0];
	oca.ca_vec = cf->cf_loc[1];
	oca.ca_ipl = cf->cf_loc[2];
	if (oca.ca_ipl > 0 && oca.ca_vec < 0)
		oca.ca_vec = vme_findvec(-1);
	oca.ca_name = cf->cf_driver->cd_name;

	if ((*cf->cf_attach->ca_match)(parent, cf, &oca) == 0)
		return (0);

	config_attach(parent, cf, &oca, vmeprint);
	return (1);
}

void
vmeattach(parent, self, args)
	struct device *parent, *self;
	void *args;
{
	struct vmesoftc *sc = (struct vmesoftc *)self;
	struct confargs *ca = args;

	/*
	 * This is a waste if we are attached to SYSCON - but then obio
	 * mappings are free...
	 */
	sc->sc_iot = ca->ca_iot;
	if (bus_space_map(sc->sc_iot, ca->ca_paddr, PAGE_SIZE, 0,
	    &sc->sc_ioh) != 0) {
		printf(": can't map registers!\n");
		return;
	}

	vmebustype = ca->ca_bustype;

	switch (ca->ca_bustype) {
#if NPCCTWO > 0
	case BUS_PCCTWO:
	{
		u_int32_t vbr;

		/* Sanity check that the BUG is set up right */
		vbr = bus_space_read_4(sc->sc_iot, sc->sc_ioh, VME2_VBR);
		vmevecbase = VME2_GET_VBR1(vbr) + 0x10;
		if (vmevecbase >= 0x100) {
			panic("Correct the VME Vector Base Registers "
			    "in the Bug ROM.\n"
			    "Suggested values are 0x60 for VME Vec0 and "
			    "0x70 for VME Vec1.");
		}

		if ((bus_space_read_4(sc->sc_iot, sc->sc_ioh, VME2_TCTL) &
		    VME2_TCTL_SCON) != 0)
			printf(": system controller");
		printf("\n");

		vme2chip_init(sc);
	}
		break;
#endif
#if NSYSCON > 0
	case BUS_SYSCON:
	{
		u_int8_t sconc;

		vmevecbase = 0x80;  /* Hard coded for MVME188 */
		sconc = *(volatile u_int8_t *)GLOBAL1;
		if (!ISSET(sconc, M188_SYSCONNEG))
			printf(": system controller");
		printf("\n");

		vmesyscon_init(sc);
	}
		break;
#endif
	}

	while (config_found(self, NULL, NULL))
		;
}

/* find a VME vector based on what is in NVRAM settings. */
int
vme_findvec(int skip)
{
	return intr_findvec(vmevecbase, 0xff, skip);
}

d107 2
a108 2
#define VME2_A32D16STARTPHYS	(0xff000000UL)
#define VME2_A32D16ENDPHYS	(0xff7fffffUL)
d118 1
a118 1
vmepmap(sc, vmeaddr, bustype)
d121 1
d124 1
a124 1
	u_int32_t base = (u_int32_t)vmeaddr;	/* wrap around 4GB */
d126 1
d134 2
a135 2
			printf("base 0x%8llx/0x%8x\n",
			    vmeaddr, base);
d137 1
a137 2
			base = vme2chip_map(base, 16);
#ifdef DEBUG
d139 3
a141 2
				printf("%s: cannot map pa 0x%x\n",
				    sc->dv_xname, base);
a142 1
#endif
d146 2
a147 2
			printf("base 0x%8llx/0x%8x\n",
			    vmeaddr, base);
d149 1
a149 2
			base = vme2chip_map(base, 32);
#ifdef DEBUG
d151 3
a153 2
				printf("%s: cannot map pa 0x%x\n",
				    sc->dv_xname, base);
a154 1
#endif
a158 2
	default:
		return NULL;
a162 3
static void *vmemap(struct vmesoftc *, off_t);
static void vmeunmap(void *);

d164 6
a169 2
static __inline__ void *
vmemap(struct vmesoftc *sc, off_t vmeaddr)
d171 1
a171 1
	void *pa;
d173 1
a173 1
	pa = vmepmap((struct device *)sc, vmeaddr, BUS_VMES);
d176 2
a177 1
	return mapiodev(pa, PAGE_SIZE);
d180 4
a183 2
static __inline__ void
vmeunmap(void *va)
d185 1
a185 1
	unmapiodev(va, PAGE_SIZE);
d213 2
a214 2
		if ((v & PGOFSET) + c > PAGE_SIZE) /* max 1 page at a time */
			c = PAGE_SIZE - (v & PGOFSET);
d216 7
a222 4
			return 0;
		vme = vmemap((struct vmesoftc *)sc, v & ~PGOFSET);
		if (vme == NULL)
			return EACCES;
d224 117
a340 1
		vmeunmap(vme);
d342 13
a354 1
	return error;
d386 7
d397 8
a404 3
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, VME2_IRQEN,
		    bus_space_read_4(sc->sc_iot, sc->sc_ioh, VME2_IRQEN) |
		    VME2_IRQ_VME(ih->ih_ipl));
d408 2
a409 2

	return intr_establish(vec, ih);
d417 4
a420 1
	u_int32_t ctl, irqen, master, master4mod;
d423 1
a423 3
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, VME2_TCTL,
	    bus_space_read_4(sc->sc_iot, sc->sc_ioh, VME2_TCTL) &
	    ~VME2_TCTL_SYSFAIL);
d425 1
a425 3
	/*
	 * Display the VMEChip2 decoder status.
	 */
d427 24
a450 29
	ctl = bus_space_read_4(sc->sc_iot, sc->sc_ioh, VME2_GCSRCTL);
	if (ctl & VME2_GCSRCTL_MDEN1) {
		master = bus_space_read_4(sc->sc_iot, sc->sc_ioh, VME2_MASTER1);
		printf("%s: 1phys 0x%08lx-0x%08lx to VME 0x%08lx-0x%08lx\n",
		    sc->sc_dev.dv_xname, master << 16, master & 0xffff0000,
		    master << 16, master & 0xffff0000);
	}
	if (ctl & VME2_GCSRCTL_MDEN2) {
		master = bus_space_read_4(sc->sc_iot, sc->sc_ioh, VME2_MASTER2);
		printf("%s: 2phys 0x%08lx-0x%08lx to VME 0x%08lx-0x%08lx\n",
		    sc->sc_dev.dv_xname, master << 16, master & 0xffff0000,
		    master << 16, master & 0xffff0000);
	}
	if (ctl & VME2_GCSRCTL_MDEN3) {
		master = bus_space_read_4(sc->sc_iot, sc->sc_ioh, VME2_MASTER3);
		printf("%s: 3phys 0x%08lx-0x%08lx to VME 0x%08lx-0x%08lx\n",
		    sc->sc_dev.dv_xname, master << 16, master & 0xffff0000,
		    master << 16, master & 0xffff0000);
	}
	if (ctl & VME2_GCSRCTL_MDEN4) {
		master = bus_space_read_4(sc->sc_iot, sc->sc_ioh, VME2_MASTER4);
		master4mod = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
		    VME2_MASTER4MOD);
		printf("%s: 4phys 0x%08lx-0x%08lx to VME 0x%08lx-0x%08lx\n",
		    sc->sc_dev.dv_xname, master << 16, master & 0xffff0000,
		    (master << 16) + (master4mod << 16),
		    (master & 0xffff0000) + (master4mod & 0xffff0000));
	}

d455 4
a458 5
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, VME2_IRQL4,
	    (7 << VME2_IRQL4_VME7SHIFT) | (6 << VME2_IRQL4_VME6SHIFT) |
	    (5 << VME2_IRQL4_VME5SHIFT) | (4 << VME2_IRQL4_VME4SHIFT) |
	    (3 << VME2_IRQL4_VME3SHIFT) | (2 << VME2_IRQL4_VME2SHIFT) |
	    (1 << VME2_IRQL4_VME1SHIFT));
d460 4
d466 1
a466 2
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, VME2_TCTL, VME2_TCTL_RSWE |
	    bus_space_read_4(sc->sc_iot, sc->sc_ioh, VME2_TCTL));
d468 1
a468 2
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, VME2_TCR, VME2_TCR_64S |
	    bus_space_read_4(sc->sc_iot, sc->sc_ioh, VME2_TCR));
d470 1
a470 3
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, VME2_VBR, VME2_IOCTL1_MIEN |
	    bus_space_read_4(sc->sc_iot, sc->sc_ioh, VME2_VBR));

d474 5
a478 5
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, VME2_IRQL3,
	    (7 << VME2_IRQL3_SW7SHIFT) | (7 << VME2_IRQL3_SW6SHIFT) |
	    (7 << VME2_IRQL3_SW5SHIFT) | (7 << VME2_IRQL3_SW4SHIFT) |
	    (7 << VME2_IRQL3_SW3SHIFT) | (7 << VME2_IRQL3_SW2SHIFT) |
	    (7 << VME2_IRQL3_SW1SHIFT));
d488 1
a488 4

	irqen = bus_space_read_4(sc->sc_iot, sc->sc_ioh, VME2_IRQEN);
	irqen |= VME2_IRQ_AB;
	/* bus_space_write_4(sc->sc_iot, sc->sc_ioh, VME2_IRQEN, irqen); */
d494 1
a494 2
	irqen = (irqen | VME2_IRQ_ACF) & ~VME2_IRQ_TIC1;
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, VME2_IRQEN, irqen);
d503 18
d522 1
a522 3
	 * Nothing to do - though we ought to check the settings and
	 * print them.  Abort button vector has already been setup in
	 * sysconattach().
d524 6
d538 1
a538 1
 * XXX smurph - This is bogus, get rid of it! Should check vme/syscon for offsets.
d541 1
a541 1
vme2chip_map(base, dwidth)
d543 1
a543 1
	int dwidth;
a544 4
	/*
	 * Since we are checking range for one page only, no need to check
	 * for address wraparound.
	 */
a546 3
		if (base < VME2_D16STARTPHYS ||
		    base + PAGE_SIZE > VME2_D16ENDPHYS)
			return NULL;
d550 2
a551 2
		    base + PAGE_SIZE > VME2_D32ENDPHYS)
			return NULL;
a552 2
	default:
		return NULL;
d554 1
a554 1
	return base;
d564 3
a566 1
	struct vmesoftc *sc = (struct vmesoftc *)vme_cd.cd_devs[0];
d568 12
a579 2
	if ((bus_space_read_4(sc->sc_iot, sc->sc_ioh, VME2_IRQSTAT) &
	    VME2_IRQ_AB) == 0) {
d583 2
a584 2

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, VME2_IRQCLR, VME2_IRQ_AB);
d589 1
@


1.3
log
@Added vme bus device drivers. MVME328, MVME376, MVME332
@
text
@d1 1
a1 2
/*	$OpenBSD: vme.c,v 1.2 1998/12/15 05:52:31 smurph Exp $ */

d3 1
d55 1
d58 3
a64 1
int vme1chip_init __P((struct vmesoftc *sc));
d68 1
a70 4
volatile vm_offset_t master1va;
volatile vm_offset_t master2va;
volatile vm_offset_t master3va;
volatile vm_offset_t master4va;
a87 9

#if NMC > 0
	if (ca->ca_bustype == BUS_MC) {
		struct mcreg *mc = (struct mcreg *)ca->ca_master;

		if (mc->mc_ver & MC_VER_NOVME)
			return (0);
	}
#endif
a90 19
#ifndef BUGMAP
/*
 * make local addresses 1G-2G correspond to VME addresses 3G-4G,
 * as D32
 */
#define VME2_D32STARTPHYS	(1*1024*1024*1024UL)
#define VME2_D32ENDPHYS		(2*1024*1024*1024UL)
#define VME2_D32STARTVME	(3*1024*1024*1024UL)
#define VME2_D32BITSVME		(3*1024*1024*1024UL)

/*
 * make local addresses 3G-3.75G correspond to VME addresses 3G-3.75G,
 * as D16
 */
#define VME2_D16STARTPHYS	(3*1024*1024*1024UL)
#define VME2_D16ENDPHYS		(3*1024*1024*1024UL + 768*1024*1024UL)

#else

a109 2
#endif

d128 1
a128 36
#if NPCC > 0
	case BUS_PCC:
		switch (bustype) {
		case BUS_VMES:
			printf("base 0x%8x/0x%8x len 0x%x\n",
				vmeaddr, base, len);
			if (base > VME1_A16BASE &&
			    (base+len - VME1_A16BASE) < VME1_A16D16LEN) {
				base = base - VME1_A16BASE + VME1_A16D16BASE;
				printf("vmes1: base = 0x%8x\n", base); /* 1:1 */
			} else if (base > VME1_A32D16BASE &&
			    base+len < VME1_A16BASE) {
				/* 1:1 mapped */
				printf("vmes2: base = 0x%8x\n", base);
			} else {
				printf("%s: cannot map pa 0x%x len 0x%x\n",
				    sc->sc_dev.dv_xname, base, len);
				return (NULL);
			}
			break;
		case BUS_VMEL:
			if (base >= physmem && (base+len) < VME1_A32D32LEN)
				base = base + VME1_A32D32BASE;
			else if (base+len < VME1_A32D16LEN)		/* HACK! */
				base = base + VME1_A32D16BASE;
			else {
				printf("%s: cannot map pa 0x%x len 0x%x\n",
				    sc->sc_dev.dv_xname, base, len);
				return (NULL);
			}
			break;
		}
		break;
#endif
#if NMC > 0 || NPCCTWO > 0
	case BUS_MC:
d130 1
d296 1
d304 1
a304 10
#if NPCC > 0
	case BUS_PCC:
		vme1 = (struct vme1reg *)sc->sc_vaddr;
		scon = (vme1->vme1_scon & VME1_SCON_SWITCH);
		printf(": %ssystem controller\n", scon ? "" : "not ");
		vme1chip_init(sc);
		break;
#endif
#if (NMC > 0) || (NPCCTWO > 0)
	case BUS_MC:
d313 9
d346 2
a347 2
#if NPCC > 0
	struct vme1reg *vme1;
d349 2
a350 2
#if NMC > 0 || NPCCTWO > 0
	struct vme2reg *vme2;
d357 1
a357 9
#if NPCC > 0
	case BUS_PCC:
		vme1 = (struct vme1reg *)sc->sc_vaddr;
		vme1->vme1_irqen = vme1->vme1_irqen |
		    VME1_IRQ_VME(ih->ih_ipl);
		break;
#endif
#if NMC > 0 || NPCCTWO > 0
	case BUS_MC:
d364 9
d377 1
a377 17
#if defined(MVME147)
int
vme1chip_init(sc)
	struct vmesoftc *sc;
{
	struct vme1reg *vme1 = (struct vme1reg *)sc->sc_vaddr;

	vme1->vme1_scon &= ~VME1_SCON_SYSFAIL;	/* XXX doesn't work */
}
#endif


#ifndef BUGMAP

/*
 * XXX what AM bits should be used for the D32/D16 mappings?
 */
d383 1
a383 1
	u_long ctl;
d389 2
a390 4

	/* unused decoders 1 */
	vme2->vme2_master1 = 0;
	ctl &= ~(VME2_MASTERCTL_ALL << VME2_MASTERCTL_1SHIFT);
d396 1
a396 3
	/* unused decoders 2 */
	vme2->vme2_master2 = 0;
	ctl &= ~(VME2_MASTERCTL_ALL << VME2_MASTERCTL_2SHIFT);
a402 5
	vme2->vme2_master3 = ((VME2_D16ENDPHYS-1) & 0xffff0000) |
	    (VME2_D16STARTPHYS >> 16);
	ctl &= ~(VME2_MASTERCTL_ALL << VME2_MASTERCTL_3SHIFT);
	ctl |= (VME2_MASTERCTL_D16 | VME2_MASTERCTL_AM24UD) <<
	    VME2_MASTERCTL_3SHIFT;
d408 1
a408 8
	/* setup a A32D32 space */
	vme2->vme2_master4 = ((VME2_D32ENDPHYS-1) & 0xffff0000) |
	    (VME2_D32STARTPHYS >> 16);
	vme2->vme2_master4mod = (VME2_D32STARTVME & 0xffff0000) |
	    (VME2_D32BITSVME >> 16);
	ctl &= ~(VME2_MASTERCTL_ALL << VME2_MASTERCTL_4SHIFT);
	ctl |= (VME2_MASTERCTL_AM32UD) <<
	    VME2_MASTERCTL_4SHIFT;
d412 2
a413 22
	    vme2->vme2_master4 << 16, vme2->vme2_master4 & 0xffff0000);

	vme2->vme2_masterctl = ctl;
	ctl = vme2->vme2_gcsrctl;

	/* enable A16 short IO map decoder (0xffffxxxx) */
	ctl &= ~(VME2_GCSRCTL_I1EN | VME2_GCSRCTL_I1D16 | VME2_GCSRCTL_I1WP |
	    VME2_GCSRCTL_I1SU);
	ctl |= VME2_GCSRCTL_I1EN | VME2_GCSRCTL_I1D16 | VME2_GCSRCTL_I1SU;

	/* enable A24D16 (0xf0xxxxxx) and A32D16 (0xf[1-e]xxxxxx) decoders */
	ctl &= ~(VME2_GCSRCTL_I2EN | VME2_GCSRCTL_I2WP | VME2_GCSRCTL_I2SU |
	    VME2_GCSRCTL_I2PD);
	ctl |= VME2_GCSRCTL_I2EN | VME2_GCSRCTL_I2SU | VME2_GCSRCTL_I2PD;

	/* map decoders 3 & 4 which were just configured */
	ctl &= ~(VME2_GCSRCTL_MDEN4 | VME2_GCSRCTL_MDEN3 | VME2_GCSRCTL_MDEN1 |
	    VME2_GCSRCTL_MDEN2);
	ctl |= VME2_GCSRCTL_MDEN4 | VME2_GCSRCTL_MDEN3;

	vme2->vme2_gcsrctl = ctl;

d422 2
d426 5
a430 3

#if NPCCTWO > 0
	if (vmebustype == BUS_PCCTWO) {
d433 1
a433 1
		sc->sc_abih.ih_ipl = 7;
d435 1
a435 2

		intr_establish(110, &sc->sc_abih);	/* XXX 110 */
a437 1
#endif
d440 1
d442 1
a442 2
#else /* BUGMAP */

d444 1
a444 1
vme2chip_init(sc)
d447 1
a447 1
	struct vme2reg *vme2 = (struct vme2reg *)sc->sc_vaddr;
d450 1
d456 1
a456 2
	/* setup a A32D16 space */
	printf("%s: 1phys 0x%08x-0x%08x to VME 0x%08x-0x%08x\n",
d460 1
a460 3

	/* setup a A32D32 space */
	printf("%s: 2phys 0x%08x-0x%08x to VME 0x%08x-0x%08x\n",
d465 9
a473 42
	/* setup a A24D16 space */
	printf("%s: 3phys 0x%08x-0x%08x to VME 0x%08x-0x%08x\n",
	    sc->sc_dev.dv_xname,
	    vme2->vme2_master3 << 16, vme2->vme2_master3 & 0xffff0000,
	    vme2->vme2_master3 << 16, vme2->vme2_master3 & 0xffff0000);

	/* setup a XXXXXX space */
	printf("%s: 4phys 0x%08x-0x%08x to VME 0x%08x-0x%08x\n",
	    sc->sc_dev.dv_xname,
	    vme2->vme2_master4 << 16, vme2->vme2_master4 & 0xffff0000,
	    vme2->vme2_master4 << 16 + vme2->vme2_master4mod << 16,
       vme2->vme2_master4 & 0xffff0000 + vme2->vme2_master4 & 0xffff0000);
	/*
	 * Map the VME irq levels to the cpu levels 1:1.
	 * This is rather inflexible, but much easier.
	 */
	vme2->vme2_irql4 = (7 << VME2_IRQL4_VME7SHIFT) |
	    (6 << VME2_IRQL4_VME6SHIFT) | (5 << VME2_IRQL4_VME5SHIFT) |
	    (4 << VME2_IRQL4_VME4SHIFT) | (3 << VME2_IRQL4_VME3SHIFT) |
	    (2 << VME2_IRQL4_VME2SHIFT) | (1 << VME2_IRQL4_VME1SHIFT);
	printf("%s: vme to cpu irq level 1:1\n",sc->sc_dev.dv_xname);
	/*
	printf("%s: vme2_irql4 = 0x%08x\n",	sc->sc_dev.dv_xname,
	    vme2->vme2_irql4);
	*/
#if NPCCTWO > 0
	if (vmebustype == BUS_PCCTWO){
		/* 
		 * pseudo driver, abort interrupt handler
		 */
		sc->sc_abih.ih_fn = vme2abort;
		sc->sc_abih.ih_arg = 0;
		sc->sc_abih.ih_ipl = IPL_NMI;
		sc->sc_abih.ih_wantframe = 1;
#if 0
		printf("inserting vme_ab handler\n");
#endif
		intr_establish(110, &sc->sc_abih);
		vme2->vme2_irqen |= VME2_IRQ_AB;
	}
#endif
	vme2->vme2_irqen = vme2->vme2_irqen | VME2_IRQ_ACF;
d475 1
a475 1
#endif /* BUGMAP */
d477 1
a477 1
#if defined(MVME162) || defined(MVME167) || defined(MVME177) || defined (MVME187) || defined (MVME188)
d480 1
a480 1
 * A32 accesses on the MVME1[678]x require setting up mappings in
d484 1
d511 1
a511 1
		printf("%s: vme2chip irq not set\n", sc->sc_dev.dv_xname);
@


1.2
log
@Commit for the first real OpenBSD mvme88k port.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.9 1998/01/19 00:13:04 etheisen Exp $ */
d46 7
a52 3
#include <machine/autoconf.h>
#include <machine/cpu.h>
#include <machine/frame.h>
d67 5
d98 20
a117 1
	}
a118 1
#if defined(MVME162) || defined(MVME167) || defined(MVME177) || defined (MVME187)
d123 1
d135 3
d140 1
d196 7
a202 17
		case BUS_VMES:
			/*printf("base %x len %d\n", base, len);*/
			if (base > VME2_A16BASE &&
			    (base+len-VME2_A16BASE) < VME2_A16D16LEN) {
				/* XXX busted? */
				base = base - VME2_A16BASE + VME2_A16D16BASE;
			} else if (base > VME2_A24BASE &&
			    (base+len-VME2_A24BASE) < VME2_A24D16LEN) {
				base = base - VME2_A24BASE + VME2_D16STARTPHYS;
			} else if ((base+len) < VME2_A32D16LEN) {
				/* XXX busted? */
				base = base + VME2_A32D16BASE;
			} else {
				printf("vme2chip_map\n");
				base = vme2chip_map(base, len, 16);
				if (base == NULL)
					return (NULL);
d205 3
a207 6
		case BUS_VMEL:
#if 0
			if (base > VME2_A16BASE &&
			    (base+len-VME2_A16BASE) < VME2_A16D32LEN)
				base = base - VME2_A16BASE + VME2_A16D32BASE;
#endif
d209 3
a211 1
			if (base == NULL)
d213 1
d296 1
d371 1
a371 1
		printf(": %sscon\n", scon ? "" : "not ");
d380 2
a381 1
		printf(": %sscon\n", scon ? "" : "not ");
d451 1
a451 1
#if defined(MVME162) || defined(MVME167) || defined(MVME177) || defined (MVME187)
d471 1
a471 1
	printf("%s: 1phys 0x%08x-0x%08x to VMExxx 0x%08x-0x%08x\n",
d479 1
a479 1
	printf("%s: 2phys 0x%08x-0x%08x to VMExxx 0x%08x-0x%08x\n",
d490 1
a490 1
	printf("%s: 3phys 0x%08x-0x%08x to VMED16 0x%08x-0x%08x\n",
d503 1
a503 1
	printf("%s: 4phys 0x%08x-0x%08x to VMED32 0x%08x-0x%08x\n",
d540 65
d622 3
a638 3
		if (base < VME2_D16STARTPHYS ||
		    base + (u_long)len > VME2_D16ENDPHYS)
			return (NULL);
d641 2
a642 1
		if (base < VME2_D32STARTVME)
d644 1
a644 1
		return (base - VME2_D32STARTVME + VME2_D32STARTPHYS);
d666 2
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD$ */
d48 1
d60 1
a60 2

int vme2abort __P((void *cap, void *frame));
d73 1
a73 1
vmematch(parent, self, args)
d75 1
a75 1
	void *self;
a77 5
	/* XXX should we look at the id/rev in GCSR area? nivas */
	caddr_t		base;
	u_char		id;
	u_char		rev; 
	struct cfdata *cf = self;
d80 3
a82 3
	/* 
	 * If bus or name do not match, fail.
	 */
d84 2
a85 3
	if (ca->ca_bustype != BUS_MAIN ||
		strcmp(cf->cf_driver->cd_name, "vme")) {
		return 0;
d87 2
a88 3

	if ((base = (caddr_t)cf->cf_loc[0]) == (caddr_t)-1) {
		return 0;
d91 9
a99 3
	ca->ca_size = 0x100;
	ca->ca_paddr = base;
	ca->ca_bustype = BUS_PCCTWO;
d101 7
a107 2
	return (1);
}
d115 1
a115 1
caddr_t
d118 1
a118 1
	caddr_t vmeaddr;
d122 1
a122 1
	u_long base = (u_long)vmeaddr;
d130 2
d133 1
a133 1
			    (base+len - VME1_A16BASE) < VME1_A16D16LEN)
d135 7
a141 4
			else if (base+len < VME1_A32D16LEN)
				base = base + VME1_A32D16BASE;
			else {
				printf("%s: cannot map pa %x len %x\n",
d152 1
a152 1
				printf("%s: cannot map pa %x len %x\n",
d165 1
d167 2
a168 1
			    (base+len-VME2_A16BASE) < VME2_A16D16LEN)
d170 5
a174 4
			else if (base > VME2_A24BASE &&
			    (base+len-VME2_A24BASE) < VME2_A24D16LEN)
				base = base - VME2_A24BASE + VME2_A24D16BASE;
			else if ((base+len) < VME2_A32D16LEN)
d176 2
a177 1
			else {
d197 1
a197 1
	return ((caddr_t)base);
d201 1
a201 1
caddr_t
d204 1
a204 1
	caddr_t vmeaddr;
d208 1
a208 2
	caddr_t pa, va;
	extern vm_offset_t iomap_mapin(vm_offset_t, vm_size_t, boolean_t);
d210 1
a210 1
	pa = vmepmap(sc, pa, len, bustype);
d213 1
a213 4
#if 0
	va = (caddr_t)iomap_mapin((vm_offset_t)pa, len, 1);
#endif
	va = pa;
d219 1
a219 1
	caddr_t va;
d222 1
a222 3
#if 0
	iomap_mapout(va, len);
#endif
d235 1
a235 1
	caddr_t vme;
d254 1
a254 1
		vme = vmemap(sc, (caddr_t)(v & ~PGOFSET),
d260 1
a260 1
		error = uiomove((caddr_t)vme + (v & PGOFSET), c, uio);
d269 1
a269 1
	char *bus;
d273 3
a277 2
	if (ca->ca_vec > 0)
		printf(" vec %d", ca->ca_vec);
d299 4
a302 11
	oca.ca_paddr = (caddr_t)cf->cf_loc[0];
	oca.ca_size = cf->cf_loc[1];
	oca.ca_ipl = cf->cf_loc[2];
	oca.ca_vec = cf->cf_loc[3];

	/*
	 * Assign a vector if the config file did not specify
	 * one.
	 */

#ifdef notyet
d304 3
a306 2
		oca.ca_vec = intr_freevec();
#endif /* notyet */
d308 2
a309 2
	oca.ca_vaddr = (void *)vmemap(sc, oca.ca_paddr, oca.ca_size,
	    oca.ca_bustype);
d312 2
a313 1
	oca.ca_parent = (void *)sc;
d316 1
a316 1
			vmeunmap(oca.ca_vaddr, oca.ca_size);
d319 4
a360 2
	default:
		printf(" unknown parent bus %x", ca->ca_bustype);
a425 10
#if defined(MVME162) || defined(MVME167) || defined(MVME177) || defined(MVME187)

/*
 * make local addresses 1G-2G correspond to VME addresses 3G-4G,
 * as D32
 */
#define VME2_D32STARTPHYS	(1*1024*1024*1024UL)
#define VME2_D32ENDPHYS		(2*1024*1024*1024UL)
#define VME2_D32STARTVME	(3*1024*1024*1024UL)
#define VME2_D32BITSVME		(3*1024*1024*1024UL)
d427 1
a427 6
/*
 * make local addresses 3G-3.75G correspond to VME addresses 3G-3.75G,
 * as D16
 */
#define VME2_D16STARTPHYS	(3*1024*1024*1024UL)
#define VME2_D16ENDPHYS		(3*1024*1024*1024UL + 768*1024*1024UL)
d444 4
a447 3
#if 0
	/* unused decoders 1 & 2 */
	printf("%s: phys 0x%08x-0x%08x to VMExxx 0x%08x-0x%08x\n",
d451 5
a455 1
	printf("%s: phys 0x%08x-0x%08x to VMExxx 0x%08x-0x%08x\n",
a458 1
#endif
d460 1
a460 1
	/* setup a D16 space */
d464 1
a464 1
	ctl |= (VME2_MASTERCTL_AM32SP | VME2_MASTERCTL_D16) <<
d466 1
a466 2
#if 0
	printf("%s: phys 0x%08x-0x%08x to VMED16 0x%08x-0x%08x\n",
d468 2
a469 3
	    VME2_D16STARTPHYS, VME2_D16ENDPHYS-1,
	    VME2_D16STARTPHYS, VME2_D16ENDPHYS-1);
#endif
d471 1
a471 1
	/* setup a D32 space */
d477 1
a477 1
	ctl |= (VME2_MASTERCTL_AM32SP) <<
d479 1
a479 2
#if 0
	printf("%s: phys 0x%08x-0x%08x to VMED32 0x%08x-0x%08x\n",
d481 2
a482 3
	    VME2_D32STARTPHYS, VME2_D32ENDPHYS-1,
	    VME2_D32STARTVME, VME2_D32STARTVME | ~VME2_D32BITSVME);
#endif
a484 1

d512 4
a515 5
	/*
	 * disable all interrupts, they will be enabled by each
	 * driver when it configures
	 */
	vme2->vme2_irqen = 0;
d530 2
a531 1
	
d557 2
a558 1
#if 1
d560 2
a561 1
vme2abort(void *cap, void *frame)
a564 1
	extern void nmihand(void *);
d566 3
a568 3
	if (!(vme2->vme2_irqstat & VME2_IRQ_AB)) {
		printf("vme2abort irq not set\n");
		return 0;
a569 1

d572 1
a572 1
	return 1;
@


1.1.1.1
log
@Third try at importing the mvme88k port. This is a working kernel
from nivas.
Userland and compiler still need to be worked on.
Make certain what directory the import is done from.
@
text
@@
