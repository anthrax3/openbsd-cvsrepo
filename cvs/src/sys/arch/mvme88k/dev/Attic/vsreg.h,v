head	1.16;
access;
symbols
	OPENBSD_5_5:1.15.0.28
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.24
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.22
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.20
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.18
	OPENBSD_5_0:1.15.0.16
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.14
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.12
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.8
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.10
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.6
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.4
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.2
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.14.0.4
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.2
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.13.0.10
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.8
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.6
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.4
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	UBC_SYNC_A:1.3
	OPENBSD_3_3:1.3.0.12
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.10
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.3
	UBC:1.3.0.6
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.4
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.2.0.8
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.6
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.4
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.16
date	2014.03.18.22.36.36;	author miod;	state dead;
branches;
next	1.15;

1.15
date	2008.01.01.22.54.28;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2006.12.21.02.28.47;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2004.09.06.06.25.28;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2004.07.20.20.32.02;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2004.07.19.20.35.37;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2004.07.19.20.31.51;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2004.07.18.19.45.51;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2004.05.22.19.34.12;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.21.10.24.42;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.20.16.42.54;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2003.09.29.09.08.19;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.02.23.27.52;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.01.03.38.16;	author smurph;	state Exp;
branches;
next	1.2;

1.2
date	99.09.27.18.43.26;	author smurph;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	99.05.29.04.41.44;	author smurph;	state Exp;
branches;
next	;

1.2.4.1
date	2001.04.18.16.11.09;	author niklas;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2003.06.07.11.13.17;	author ho;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2004.02.19.10.49.06;	author niklas;	state Exp;
branches;
next	1.2.4.4;

1.2.4.4
date	2004.06.05.23.09.49;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: vsreg.h,v 1.15 2008/01/01 22:54:28 miod Exp $	*/
/*
 * Copyright (c) 2004, Miodrag Vallat.
 * Copyright (c) 1999 Steve Murphree, Jr.
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from source contributed by Mark Bellon.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef	_MVME328_REG_H_
#define	_MVME328_REG_H_

/*
 * JAGUAR specific device limits
 */

#define	JAGUAR_MIN_Q_SIZ		2
#define	JAGUAR_MAX_CTLR_CMDS		80	/* Interphase says so */
#define	JAGUAR_MAX_Q_SIZ		(JAGUAR_MAX_CTLR_CMDS / JAGUAR_MAX_WQ)
#define	JAGUAR_MAX_WQ			(2 * 7)

/*
 * COUGAR specific device limits
 */

#define	COUGAR_MIN_Q_SIZ		2
#define	COUGAR_CMDS_PER_256K		42	/* Interphase says so */

/*
 * Structures
 */

#define	NUM_CQE			10
#define	NUM_IOPB		NUM_CQE
#define	NUM_WQ			(2 * 15)

/*
 * Master Control Status Block (MCSB)
 */

#define	MCSB_MSR		0x000000	/* master status register */
#define	M_MSR_QFC	0x0004		/* queue flush complete */
#define	M_MSR_BOK	0x0002		/* board OK */
#define	M_MSR_CNA	0x0001		/* controller not available */
#define	MCSB_MCR		0x000002	/* master control register */
#define	M_MCR_SFEN	0x2000		/* sysfail enable */
#define	M_MCR_RES	0x1000		/* reset controller */
#define	M_MCR_FLQ	0x0800		/* flush queue */
#define	M_MCR_FLQR	0x0004		/* flush queue and report */
#define	M_MCR_SQM	0x0001		/* start queue mode */
#define	MCSB_IQAR		0x000004	/* interrupt on queue avail */
#define	M_IQAR_IQEA	0x8000		/* interrupt on queue entry avail */
#define	M_IQAR_IQEH	0x4000		/* interrupt on queue half empty */
#define	M_IQAR_ILVL	0x0700		/* interrupt lvl on queue available */
#define	M_IQAR_IVCT	0x00ff		/* interrupt vector on queue avail */
#define	MCSB_QHDP		0x000006	/* queue head pointer */
#define	MCSB_THAW		0x000008	/* thaw work queue */
#define	M_THAW_TWQN	0xff00		/* thaw work queue number */
#define	M_THAW_TWQE	0x0001		/* thaw work queue enable */
#define	MCSB_SIZE		0x000010

/*
 * Host Semaphore Block (HSB)
 */

#define	HSB_INITQ		0x000000	/* init MCE flag */
#define	HSB_WORKQ		0x000002	/* work queue number */
#define	HSB_MAGIC		0x000004	/* magic word */
#define	HSB_SIZE		0x000008

/*
 * Controller Initialization Block (CIB)
 */

#define	CIB_NCQE		0x000000	/* number of CQE */
#define	CIB_BURST		0x000002	/* DMA burst count */
#define	CIB_NVECT		0x000004	/* normal completion vector */
#define	CIB_EVECT		0x000006	/* error completion vector */
#define	M_VECT_ILVL	0x0700		/* Interrupt Level mask */
#define	M_VECT_IVCT	0x00ff		/* Interrupt Vector mask */
#define	CIB_PID			0x000008	/* primary scsi bus id */
#define	CIB_SID			0x00000a	/* secondary scsi bus id */
#define	M_PSID_DFT	0x0008 		/* default ID enable */
#define	M_PSID_ID	0x0007		/* primary/secondary SCSI ID */
#define	CIB_CRBO		0x00000c	/* CRB offset */
#define	CIB_SELECT		0x00000e	/* selection timeout in ms */
#define	CIB_WQTIMO		0x000012	/* work queue timeout in 256ms */
#define	CIB_VMETIMO		0x000016	/* VME timeout in 32ms */
#define	CIB_OBMT		0x00001e	/* offboard CRB mtype/xfer type/ad mod */
#define	CIB_OBADDR		0x000020	/* host mem address for offboard CRB */
#define	CIB_ERR_FLGS		0x000024	/* error recovery flags */
#define	M_ERRFLGS_FOSR	0x0001		/* Freeze on SCSI bus reset */
#define	M_ERRFLGS_RIN	0x0002		/* SCSI bus reset interrupt */
#define	M_ERRFLGS_RSE	0x0004		/* Report COUGAR SCSI errors */
#define	CIB_SBRIV		0x00002a	/* scsi bus reset interrupt vector */
#define	CIB_SOF0		0x00002c	/* synchronous offset (bus 0) */
#define	CIB_SRATE0		0x00002d	/* sync negotiation rate (bus 0) */
#define	CIB_SOF1		0x00002e	/* synchronous offset (bus 0) */
#define	CIB_SRATE1		0x00002f	/* sync negotiation rate (bus 0) */
#define	CIB_SIZE		0x000030

/*
 * Command Queue Entry (CQE)
 */

#define	CQE_QECR		0x000000	/* queue entry control reg */
#define	M_QECR_IOPB	0x0f00		/* IOPB type (must be zero) */
#define	M_QECR_HPC	0x0004		/* High Priority command */
#define	M_QECR_AA	0x0002		/* abort acknowledge */
#define	M_QECR_GO	0x0001		/* Go/Busy */
#define	CQE_IOPB_ADDR		0x000002	/* IOPB address */
#define	CQE_CTAG		0x000004	/* command tag */
#define	CQE_IOPB_LENGTH		0x000008	/* IOPB length */
#define	CQE_WORK_QUEUE		0x000009	/* work queue number */
#define	CQE_SIZE		0x00000c

/*
 * Command Response Block (CRB)
 */

#define	CRB_CRSW		0x000000	/* status word */
#define	M_CRSW_SE	0x0800		/* SCSI error (COUGAR) */
#define	M_CRSW_RST	0x0400		/* SCSI Bus reset (COUGAR) */
#define	M_CRSW_SC	0x0080		/* status change */
#define	M_CRSW_CQA	0x0040		/* Command queue entry available */
#define	M_CRSW_QMS	0x0020		/* queue mode started */
#define	M_CRSW_AQ	0x0010		/* abort queue */
#define	M_CRSW_EX	0x0008		/* exception */
#define	M_CRSW_ER	0x0004		/* error */
#define	M_CRSW_CC	0x0002		/* command complete */
#define	M_CRSW_CRBV	0x0001		/* cmd response block valid/clear */
#define	CRB_CTAG		0x000004	/* command tag */
#define	CRB_IOPB_LENGTH		0x000008	/* IOPB length */
#define	CRB_WORK_QUEUE		0x000009	/* work queue number */
#define	CRB_SIZE		0x00000c

/*
 * Controller Error Vector Status Block (CEVSB)
 * This is a variation of the CRB, _but larger_.
 */

#define	CONTROLLER_ERROR	0x0085
#define	NR_SCSI_ERROR		0x0885

#define	CEVSB_CRSW		0x000000	/* status word */
#define	CEVSB_TYPE		0x000002	/* IOPB type */
#define	CEVSB_CTAG		0x000004	/* command tag */
#define	CEVSB_IOPB_LENGTH	0x000008	/* IOPB length */
#define	CEVSB_WORK_QUEUE	0x000009	/* work queue number */
#define	CEVSB_ERROR		0x00000d	/* error code */
#define	CEVSB_ERR_TYPE	0xc0			/* IOPB type error */
#define	CEVSB_ERR_TO	0xc1			/* IOPB timeout error */
#define	CEVSB_ERR_TR	0x82			/* Target Reconnect, no IOPB */
#define	CEVSB_ERR_OF	0x83			/* Overflow */
#define	CEVSB_ERR_BD	0x84			/* Bad direction */
#define	CEVSB_ERR_NR	0x86			/* Non-Recoverabl Error */
#define	CEVSB_ERR_PANIC	0xff			/* Board Painc!!! */
#define	CEVSB_AUXERR		0x00000e	/* cougar error code */
#define	CEVSB_SIZE		0x000010

/*
 * Configuration Status Block (CSB)
 */

#define	CSB_TYPE		0x000000	/* board ID */
#define	COUGAR		0x4220
#define	JAGUAR		0x0000
#define	CSB_EXTID		0x000002	/* cougar extended ID */
#define	CSB_PCODE		0x000003	/* product code */
#define	CSB_PVAR		0x000009	/* product variation */
#define	CSB_FREV		0x00000d	/* firmware revision level */
#define	CSB_FDATE		0x000012	/* firmware release date */
#define	CSB_SSIZE		0x00001a	/* system memory size in KB */
#define	CSB_BSIZE		0x00001c	/* buffer memory size in KB */
#define	CSB_NWQ			0x00001e	/* number of work queues (C) */
#define	CSB_PFECID		0x000020	/* primary bus FEC id */
#define	CSB_SFECID		0x000021	/* secondary bus FEC id */
#define	CSB_PID			0x000022	/* primary bus id */
#define	CSB_SID			0x000023	/* secondary bus id */
#define	CSB_LPDS		0x000024	/* last primary device selected */
#define	CSB_LSDS		0x000025	/* last secondary device selected */
#define	CSB_PPS			0x000026	/* primary phase sense */
#define	CSB_SPS			0x000027	/* secondary phase sense */
#define	CSB_DBID		0x000029	/* daughter board id */
#define	DBID_SCSI2	0x02			/* modern SCSI ??? */
#define	DBID_PRINTER	0x04			/* printer daughter board */
#define	DBID_SCSI	0x06			/* SCSI daugter board */
#define	DBID_NONE	0x07			/* no daughter board */
#define	CSB_SDS			0x00002b	/* software DIP switch */
#define	CSB_FWQR		0x00002e	/* frozen work queues register */
#define	CSB_SIZE		0x000078

/*
 * IOPB Format (IOPB)
 */

#define	IOPB_CMD		0x000000	/* command code */
#define	IOPB_OPTION		0x000002	/* option word */
#define	M_OPT_HEAD_TAG		0x3000	/* head of queue command queue tag */
#define	M_OPT_ORDERED_TAG	0x2000	/* order command queue tag */
#define	M_OPT_SIMPLE_TAG	0x1000	/* simple command queue tag */
#define	M_OPT_GO_WIDE		0x0800	/* use WIDE transfers */
#define	M_OPT_DIR		0x0100	/* VME direction bit */
#define	M_OPT_SG_BLOCK		0x0008	/* scatter/gather in 512 byte blocks */
#define	M_OPT_SS		0x0004	/* Suppress synchronous transfer */
#define	M_OPT_SG		0x0002	/* scatter/gather bit */
#define	M_OPT_IE		0x0001	/* Interrupt enable */
#define	IOPB_STATUS		0x000004	/* return status word */
#define	IOPB_NVCT		0x000008	/* normal completion vector */
#define	IOPB_EVCT		0x000009	/* error completion vector */
#define	IOPB_LEVEL		0x00000a	/* interrupt level */
#define	IOPB_ADDR		0x00000e	/* address type and modifier */
#define	M_ADR_TRANS	0x0c00		/* transfer type */
#define	M_ADR_MEMT	0x0300		/* memory type */
#define	M_ADR_MOD	0x00ff		/* VME address modifier */
#define	M_ADR_SG_LINK	0x8000		/* Scatter/Gather Link bit */
#define	IOPB_BUFF		0x000010	/* buffer address */
#define	IOPB_LENGTH		0x000014	/* max transfer length */
#define	IOPB_SGTTL		0x000018	/* S/G total transfer length */
#define	IOPB_UNIT		0x00001e	/* unit address on scsi bus */
#define	M_UNIT_EXT_LUN	0xff00		/* Extended Address */
#define	M_UNIT_EXT	0x0080		/* Extended Address Enable */
#define	M_UNIT_BUS	0x0040		/* SCSI Bus Selection */
#define	M_UNIT_LUN	0x0038		/* Logical Unit Number */
#define	M_UNIT_ID	0x0007		/* SCSI Device ID */
#define	IOPB_SCSI_DATA		0x000020	/* SCSI words for passthrough */
#define	IOPB_SHORT_SIZE		0x000020
#define	IOPB_LONG_SIZE		0x000040

/*
 * Initialize Work Queue Command Format (WQCF)
 * This is a specific case of IOPB.
 */

#define	WQCF_CMD		0x000000	/* command code */
#define	M_WOPT_IWQ	0x8000		/* initialize work queue */
#define	M_WOPT_PE	0x0008		/* parity check enable */
#define	M_WOPT_FE	0x0004		/* freeze on error enable */
#define	M_WOPT_TM	0x0002		/* target mode enable */
#define	M_WOPT_AE	0x0001		/* abort enable */
#define	WQCF_OPTION		0x000002	/* option word */
#define	WQCF_STATUS		0x000004	/* return status word */
#define	WQCF_NVCT		0x000008	/* normal completion vector */
#define	WQCF_EVCT		0x000009	/* error completion vector */
#define	WQCF_ILVL		0x00000a	/* interrupt level */
#define	WQCF_WORKQ		0x00001c	/* work queue number */
#define	WQCF_WOPT		0x00001e	/* work queue options */
#define	WQCF_SLOTS		0x000020	/* # of slots in work queues */
#define	WQCF_UNIT		0x000022	/* unit address (C) */
#define	WQCF_CMDTO		0x000024	/* command timeout */

/*
 * SCSI Reset Command Format (SRCF)
 * This is a specific case of IOPB.
 */

#define	SRCF_CMD		0x000000	/* command code */
#define	SRCF_OPTION		0x000002	/* option word */
#define	SRCF_STATUS		0x000004	/* return status word */
#define	SRCF_NVCT		0x000008	/* normal completion vector */
#define	SRCF_EVCT		0x000009	/* error completion vector */
#define	SRCF_ILVL		0x00000a	/* interrupt level */
#define	SRCF_BUSID		0x00001c	/* scsi bus id to reset */

/*
 * Device Reinitialize Command Format (DRCF)
 * This is a specific case of IOPB.
 */

#define	DRCF_CMD		0x000000	/* command code */
#define	DRCF_OPTION		0x000002	/* option word */
#define	DRCF_STATUS		0x000004	/* return status word */
#define	DRCF_NVCT		0x000008	/* normal completion vector */
#define	DRCF_EVCT		0x000009	/* error completion vector */
#define	DRCF_ILVL		0x00000a	/* interrupt level */
#define	DRCF_UNIT		0x00001e	/* unit address */

/*
 * Short I/O memory layout
 */

#define	S_SHORTIO		0x000800

#define	sh_MCSB		(0)
#define	sh_MCE		(sh_MCSB + MCSB_SIZE)
#define	sh_CQE(x)	(sh_MCE + CQE_SIZE + CQE_SIZE * (x))
#define	sh_IOPB(x)	(sh_CQE(NUM_CQE) + IOPB_LONG_SIZE * (x))
#define	sh_MCE_IOPB	(sh_IOPB(NUM_IOPB))
#define	sh_CIB		(sh_MCE_IOPB + IOPB_LONG_SIZE)

#define	sh_CSS		(S_SHORTIO - CSB_SIZE)
#define	sh_RET_IOPB	(sh_CSS - IOPB_LONG_SIZE)
#define	sh_CRB		(sh_RET_IOPB - CRB_SIZE)
#define	sh_CEVSB	sh_CRB
#define	sh_HSB		(sh_CRB - HSB_SIZE)

#if (sh_CIB + CIB_SIZE > sh_HSB)
#error	invalid memory layout
#endif

#define	SELECTION_TIMEOUT		250	/* milliseconds */
#define	VME_BUS_TIMEOUT			15	/* units of 30ms */
#define	M328_INFINITE_TIMEOUT		0	/* wait forever */

/*
 * IOPB command codes
 */

#define	IOPB_PASSTHROUGH		0x20 /* SCSI passthrough commands */
#define	IOPB_PASSTHROUGH_EXT		0x21 /* SCSI passthrough extended */
#define	IOPB_RESET			0x22 /* reset bus */

#define	CNTR_DIAG			0x40 /* perform diagnostics */
#define	CNTR_INIT			0x41 /* initialize controller */
#define	CNTR_INIT_WORKQ			0x42 /* initialize work queue */
#define	CNTR_DUMP_INIT			0x43 /* dump initialization parameters */
#define	CNTR_DUMP_WORDQ			0x44 /* dump work queue parameters */
#define	CNTR_CANCEL_IOPB		0x48 /* cancel command tag */
#define	CNTR_FLUSH_WORKQ		0x49 /* flush work queue */
#define	CNTR_DEV_REINIT			0x4c /* reinitialize device */
#define	CNTR_ISSUE_ABORT		0x4e /* abort has been issued */
#define	CNTR_DOWNLOAD_FIRMWARE		0x4f /* download firmware (COUGAR) */

/*
 * Memory types
 */

#define	MEMT_16BIT	1	/* 16 bit memory type */
#define	MEMT_32BIT	2	/* 32 bit memory type */
#define	MEMT_SHIO	3	/* short I/O memory type */
#define	MEMTYPE		MEMT_32BIT

/*
 * Transfer types
 */

#define	TT_NORMAL		0	/* normal mode transfers */
#define	TT_BLOCK		1	/* block mode transfers */
#define	TT_DISABLE_INC_ADDR	2	/* disable incrementing addresses */
#define	TT_D64			3	/* D64 mode transfers */

/*
 * Error codes
 */

#define	MACSI_GOOD_STATUS	0x00
#define	MACSI_QUEUE_FULL	0x01
#define	MACSI_CMD_CODE_ERR	0x04
#define	MACSI_QUEUE_NUMBER_ERR	0x05

#define	RESET_BUS_STATUS	0x11	/* SCSI bus reset IOPB forced this */
#define	NO_SECONDARY_PORT	0x12	/* second SCSI bus not available */
#define	SCSI_DEVICE_IS_RESET	0x14
#define	CMD_ABORT_BY_RESET	0x15

#define	VME_BUS_ERROR		0x20
#define	VME_BUS_ACC_TIMEOUT	0x21
#define	VME_BUS_BAD_ADDR	0x23
#define	VME_BUS_BAD_MEM_TYPE	0x24
#define	VME_BUS_BAD_COUNT	0x25
#define	VME_BUS_FETCH_ERROR	0x26
#define	VME_BUS_FETCH_TIMEOUT	0x27
#define	VME_BUS_POST_ERROR	0x28
#define	VME_BUS_POST_TIMEOUT	0x29
#define	VME_BUS_BAD_FETCH_ADDR	0x2a
#define	VME_BUS_BAD_POST_ADDR	0x2b
#define	VME_BUS_SG_FETCH	0x2c
#define	VME_BUS_SG_TIMEOUT	0x2d
#define	VME_BUS_SG_COUNT	0x2e

#define	SCSI_SELECTION_TO	0x30
#define	SCSI_DISCONNECT_TIMEOUT	0x31
#define	SCSI_ABNORMAL_SEQ	0x32
#define	SCSI_DISCONNECT_ERR	0x33
#define	SCSI_XFER_EXCEPTION	0x34
#define	SCSI_PARITY_ERROR	0x35

#define	DEVICE_NO_IOPB		0x82
#define	IOPB_CTLR_EXH		0x83
#define	IOPB_DIR_ERROR		0x84
#define	COUGAR_ERROR		0x86
#define	MACSI_INCORRECT_HW	0x90
#define	MACSI_ILGL_IOPB_VAL	0x92
#define	MACSI_ILLEGAL_IMAGE	0x9c
#define	IOPB_TYPE_ERR		0xc0	/* IOPB type not 0 */
#define	IOPB_TIMEOUT		0xc1

#define	COUGAR_PANIC		0xff

#define	MACSI_INVALID_TIMEOUT	0x843

/*
 * VME addressing modes
 */

#define	ADRM_STD_S_P		0x3e	/* standard supervisory program */
#define	ADRM_STD_S_D		0x3d	/* standard supervisory data */
#define	ADRM_STD_N_P		0x3a	/* standard normal program */
#define	ADRM_STD_N_D		0x39	/* standard normal data */
#define	ADRM_SHT_S_IO		0x2d	/* short supervisory I/O */
#define	ADRM_SHT_N_IO		0x29	/* short normal I/O */
#define	ADRM_EXT_S_P		0x0e	/* extended supervisory program */
#define	ADRM_EXT_S_D		0x0d	/* extended supervisory data */
#define	ADRM_EXT_N_P		0x0a	/* extended normal program */
#define	ADRM_EXT_N_D		0x09	/* extended normal data */
#define	ADRM_EXT_S_BM		0x0f	/* extended supervisory block mode */
#define	ADRM_EXT_S_D64		0x0c	/* extended supervisory D64 mode */

#define	ADDR_MOD	((TT_NORMAL << 10) | (MEMTYPE << 8) | ADRM_EXT_S_D)
#define	BLOCK_MOD	((TT_BLOCK << 10) | (MEMTYPE << 8) | ADRM_EXT_S_BM)
#define	D64_MOD		((TT_D64 << 10) | (MEMTYPE << 8) | ADRM_EXT_S_D64)
#define	SHIO_MOD	((TT_NORMAL << 10) | (MEMT_SHIO << 8) | ADRM_SHT_N_IO)

#endif	/* _MVME328_REG_H_ */
@


1.15
log
@Match on Cougar boards, and try to drive them like Jaguars on steroids. On
wide Cougars, use one command queue per target and disable lun support, so
that we do not overflow the board's memory; and since we are behaving as
a Jaguar, do not do tagged queuing or synchronous transfer negotiation.

Tested on two MVME328XT-2 (4220 and second revision artwork 4220) narrow
Cougar-I (but wide external connectors), but probes fail with select timeout
so far; I could not get various Motorola BUG to probe devices on these boards
either, so we're even (and maybe both my boards are toast, but I won't bet
money on this).
@
text
@d1 1
a1 1
/*	$OpenBSD: vsreg.h,v 1.14 2006/12/21 02:28:47 krw Exp $	*/
@


1.14
log
@'tranfer' -> 'transfer' in comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsreg.h,v 1.13 2004/09/06 06:25:28 miod Exp $	*/
d44 2
a45 1
#define	JAGUAR_MAX_Q_SIZ		(JAGUAR_MAX_CTLR_CMDS / NUM_WQ)
d60 1
a60 1
#define	NUM_WQ			15
d190 1
a190 1
#define	CSB_TYPE		0x000000	/* jaguar/cougar */
d193 1
d200 1
d274 1
a347 3

#define	IOPB_UNIT_VALUE(bus, target, lun) \
	(((bus) << 6) | ((lun) << 3) | (target & 7))
@


1.13
log
@Jumbo pack of fixes:
- do not leak memory when polling;
- bring LUN support back - Motorola documentation says LUNs are not
  supported, but it's a SysV/m88k limitation, not a hardware one.
- honour request timeout while polling (instead of using a fixed value)
- do not program the scsi command length if the hardware knows it from
  the scsi command group (as advised in the manual)
- various minor fixes, especially better error recovery.

tested by nick@@ and I; ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsreg.h,v 1.12 2004/07/20 20:32:02 miod Exp $	*/
d361 2
a362 2
#define	TT_NORMAL		0	/* normal mode tranfers */
#define	TT_BLOCK		1	/* block mode tranfers */
@


1.12
log
@Work in progress to support daughterboards. The driver now will attach a
second scsi bus if a SCSI daughterboard is present, and is supposed to know
about this and send scsi commands to the appropriate bus.

Unfortunately probing the second bus does not report any device at the
moment (though you can boot off it), but I can't see the issue at the moment.

Thanks to tdeval@@ for lending a few boards equipped with daughterboards
for testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsreg.h,v 1.11 2004/07/19 20:35:37 miod Exp $	*/
a42 1
#define	JAGUAR_MAX_Q_SIZ		2
d44 1
@


1.11
log
@Recognize the daughter board type, if any - but it is not supported yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsreg.h,v 1.10 2004/07/19 20:31:51 miod Exp $	*/
d59 1
d345 2
a346 1
#define	IOPB_UNIT_VALUE(target, lun)	((lun) << 3 | (target & 7))
@


1.10
log
@Direct REQUEST_SENSE commands to the correct target, instead of always
target zero. This makes targets other than zero working now...

Spotted by nick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vsreg.h,v 1.9 2004/07/18 19:45:51 miod Exp $	*/
d205 5
a209 1
#define	CSB_DBIB		0x000029	/* daughter board id */
@


1.9
log
@Typos
@
text
@d1 1
a1 1
/*	$OpenBSD: vsreg.h,v 1.8 2004/05/22 19:34:12 miod Exp $	*/
d339 2
@


1.8
log
@Convert to bus_space; but it still uses kvtop()...
@
text
@d1 1
a1 1
/*	$OpenBSD: vsreg.h,v 1.5 2003/09/29 09:08:19 miod Exp $	*/
d180 1
a180 1
#define	CESVB_ERR_PANIC	0xff			/* Board Painc!!! */
@


1.7
log
@More cleaning, better registers programming, better error messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsreg.h,v 1.6 2004/05/20 16:42:54 miod Exp $ */
d3 1
d35 2
a36 12
#if !defined(_M328REG_H_)
#define _M328REG_H_


typedef struct LONGV
{
        u_short  msw;
        u_short  lsw;
} LONGV;

#define MSW(x)  ((x).msw)
#define LSW(x)  ((x).lsw)
d39 1
a39 1
 * macro to convert a unsigned long to a LONGV
d42 3
a44 5
#define LV( a, b) \
{ \
  MSW( a ) = ( (( (unsigned long)(b) ) >> 16) & 0xffff ); \
  LSW( a ) = ( ( (unsigned long)(b) ) & 0xffff); \
}
d47 1
a47 1
 * macro to convert a LONGV to a unsigned long
d50 2
a51 7
#define VL( a, b) \
{ \
  a = ( (((unsigned long) MSW(b)) << 16 ) | (((unsigned long) LSW(b)) & 0x0ffff) ); \
}

#define         COUGAR          0x4220  /* board type (config. status area) */
#define         JAGUAR          0
d54 1
a54 1
 *      JAGUAR specific device limits.
d57 2
a58 3
#define JAGUAR_MIN_Q_SIZ                2       /* got'a have at least one! */
#define JAGUAR_MAX_Q_SIZ                2       /* can't have more */
#define JAGUAR_MAX_CTLR_CMDS            80      /* Interphase says so */
d61 1
a61 8
 *      COUGAR specific device limits.
 */

#define COUGAR_MIN_Q_SIZ                2       /* got'a have at least one! */
#define COUGAR_CMDS_PER_256K            42      /* Interphase says so */

/*
 * Structures
d64 365
a428 587
#define NUM_CQE                 10
#define MAX_IOPB                64
#define NUM_IOPB                NUM_CQE

#define S_IOPB_RES              (MAX_IOPB - sizeof(M328_short_IOPB))

#define S_SHORTIO               2048

#define S_IOPB                  sizeof(M328_IOPB)
#define S_CIB                   sizeof(M328_CIB)
#define S_MCSB                  sizeof(M328_MCSB)
#define S_MCE                   sizeof(M328_CQE)
#define S_CQE                   (sizeof(M328_CQE) * NUM_CQE)
#define S_HIOPB                 (sizeof(M328_IOPB) * NUM_IOPB)
#define S_HSB                   sizeof(M328_HSB)
#define S_CRB                   sizeof(M328_CRB)
#define S_CSS                   sizeof(M328_CSB)
#define S_NOT_HOST              (S_MCSB + S_MCE + S_CQE + S_HIOPB + S_IOPB + \
                                 S_CIB + S_HSB + S_CRB + S_IOPB + S_CSS)
#define S_HUS_FREE              (S_SHORTIO - S_NOT_HOST)

#define S_WQCF                  sizeof(M328_WQCF)


/****************     Master Control Status Block (MCSB) *******************/

/*
 * defines for Master Status Register
 */

#define M_MSR_QFC               0x0004          /* queue flush complete */
#define M_MSR_BOK               0x0002          /* board OK */
#define M_MSR_CNA               0x0001          /* controller not available */

/*
 * defines for Master Control Register
 */

#define M_MCR_SFEN              0x2000          /* sysfail enable */
#define M_MCR_RES               0x1000          /* reset controller */
#define M_MCR_FLQ               0x0800          /* flush queue */
#define M_MCR_FLQR              0x0004          /* flush queue and report */
#define M_MCR_SQM               0x0001          /* start queue mode */

/*
 * defines for Interrupt on Queue Available Register
 */

#define M_IQAR_IQEA             0x8000  /* interrupt on queue entry avail */
#define M_IQAR_IQEH             0x4000  /* interrupt on queue half empty */
#define M_IQAR_ILVL             0x0700  /* interrupt lvl on queue available */
#define M_IQAR_IVCT             0x00FF  /* interrupt vector on queue avail */

/*
 * defines for Thaw Work Queue Register
 */

#define M_THAW_TWQN             0xff00          /* thaw work queue number */
#define M_THAW_TWQE             0x0001          /* thaw work queue enable */

typedef struct mcsb
{                                       /* Master control/Status Block */
    volatile u_short      mcsb_MSR;       /* Master status register */
    volatile u_short      mcsb_MCR;       /* Master Control register */
    volatile u_short      mcsb_IQAR;      /* Interrupt on Queue Available Reg */
    volatile u_short      mcsb_QHDP;      /* Queue head pointer */
    volatile u_short      mcsb_THAW;      /* Thaw work Queue */
    volatile u_short      mcsb_RES0;      /* Reserved word 0 */
    volatile u_short      mcsb_RES1;      /* Reserved word 1 */
    volatile u_short      mcsb_RES2;      /* Reserved word 2 */
} M328_MCSB;

/**************** END Master Control Status Block (MCSB) *******************/

/****************     Host Semaphore Block (HSB)         *******************/

typedef struct hsb
{                                       /* Host Semaphore Block */
    volatile u_short      hsb_INITQ;      /* Init MCE Flag */
    volatile u_short      hsb_WORKQ;      /* Work Queue number */
    volatile u_short      hsb_MAGIC;      /* Magic word */
    volatile u_short      hsb_RES0;       /* Reserved word */
} M328_HSB;

/**************** END Host Semaphore Block (HSB)         *******************/

/****************     Perform Diagnostics Command Format *******************/

typedef struct pdcf
{                                       /* Perform Diagnostics Cmd Format */
    volatile u_short      pdcf_CMD;       /* Command normally 0x40 */
    volatile u_short      pdcf_RES0;      /* Reserved word */
    volatile u_short      pdcf_STATUS;    /* Return Status */
    volatile u_short      pdcf_RES1;      /* Reserved Word */
    volatile u_short      pdcf_ROM;       /* ROM Test Results */
    volatile u_short      pdcf_BUFRAM;    /* Buffer RAM results */
    volatile u_short      pdcf_EVENT_RAM; /* Event Ram test Results */
    volatile u_short      pdcf_SCSI_PRI_PORT; /* SCSI Primary Port Reg test */
    volatile u_short      pdcf_SCSI_SEC_PORT; /* SCSI Secondary Port Reg test */
} M328_PDCF;

#define PDCF_SUCCESS            0xFFFF

/**************** END Perform Diagnostics Command Format *******************/

/***************      Controller Initialization Block (CIB) *****************/

/*
 * defines for Interrupt Vectors
 */

#define M_VECT_ILVL             0x0700  /* Interrupt Level */
#define M_VECT_IVCT             0x00FF  /* Interrupt Vector */

/*
 * defines for SCSI Bus ID Registers
 */

#define M_PSID_DFT              0x0008  /* default ID enable */
#define M_PSID_ID               0x0007  /* Primary/Secondary SCSI ID */

/*
 *      Error recovery flags.
 */

#define M_ERRFLGS_FOSR          0x0001  /* Freeze on SCSI bus reset */
#define M_ERRFLGS_RIN           0x0002  /* SCSI bus reset interrupt */
#define M_ERRFLGS_RSE           0x0004  /* Report COUGAR SCSI errors */

/*
 * Controller Initialization Block
 */

typedef struct cib
{
    volatile u_short      cib_NCQE;       /* Number of Command Queue Entries */
    volatile u_short      cib_BURST;      /* DMA Burst count */
    volatile u_short      cib_NVECT;      /* Normal Completion Vector */
    volatile u_short      cib_EVECT;      /* Error Completion Vector */
    volatile u_short      cib_PID;        /* Primary SCSI Bus ID */
    volatile u_short      cib_SID;        /* Secondary SCSI Bus ID */
    volatile u_short      cib_CRBO;       /* Command Response Block Offset */
    volatile u_short      cib_SELECT_msw;/* Selection timeout in milli_second */
    volatile u_short      cib_SELECT_lsw;/* Selection timeout in milli_second */
    volatile u_short      cib_WQ0TIMO_msw;/* Work Q - timeout in 256 ms */
    volatile u_short      cib_WQ0TIMO_lsw;/* Work Q - timeout in 256 ms */
    volatile u_short      cib_VMETIMO_msw;/* VME Time out in 32 ms */
    volatile u_short      cib_VMETIMO_lsw;/* VME Time out in 32 ms */
    volatile u_short      cib_RES0[2];    /* Reserved words */
    volatile u_short      cib_OBMT;       /* offbrd CRB mtype/xfer type/ad mod */
    volatile u_short      cib_OBADDR_msw;/* host mem address for offboard CRB */
    volatile u_short      cib_OBADDR_lsw;/* host mem address for offboard CRB */
    volatile u_short      cib_ERR_FLGS;   /* error recovery flags */
    volatile u_short      cib_RES1;       /* reserved word */
    volatile u_short      cib_RES2;       /* reserved word */
    volatile u_short      cib_SBRIV;      /* SCSI Bus Reset Interrupt Vector */
    volatile u_char       cib_SOF0;       /* Synchronous offset (Bus 0) */
    volatile u_char       cib_SRATE0;     /* Sync negotiation rate (Bus 0) */
    volatile u_char       cib_SOF1;       /* Synchronous offset (Bus 1) */
    volatile u_char       cib_SRATE1;     /* Sync negotiation rate (Bus 1) */
} M328_CIB;

/**************** END Controller Initialization Block (CIB) *****************/

/****************     Command Queue Entry (CQE)          *******************/

/*
 * defines for Queue Entry Control Register
 */

#define M_QECR_IOPB             0x0F00  /* IOPB type (must be zero) */
#define M_QECR_HPC              0x0004  /* High Priority command */
#define M_QECR_AA               0x0002  /* abort acknowledge */
#define M_QECR_GO               0x0001  /* Go/Busy */

#define CQE_GO(qecr)            ((qecr) |= M_QECR_GO)
#define CQE_AA_GO(qecr)         ((qecr) |= (M_QECR_GO + M_QECR_AA))

typedef struct cqe
{                                       /* Command Queue Entry */
    volatile u_short      cqe_QECR;       /* Queue Entry Control Register */
    volatile u_short      cqe_IOPB_ADDR;  /* IOPB Address */
    volatile LONGV        cqe_CTAG;       /* Command Tag */
    volatile u_char       cqe_IOPB_LENGTH;/* IOPB Length */
    volatile u_char       cqe_WORK_QUEUE; /* Work Queue Number */
    volatile u_short      cqe_RES0;       /* Reserved word */
} M328_CQE;

/**************** END Command Queue Entry (CQE)          *******************/

/****************     Command Response Block (CRB)       *******************/

/*
 * defines for Command Response Status Word
 */

#define M_CRSW_SE               0x0800  /* SCSI error (COUGAR) */
#define M_CRSW_RST              0x0400  /* SCSI Bus reset (COUGAR) */
#define M_CRSW_SC               0x0080  /* status change */
#define M_CRSW_CQA              0x0040  /* Command queue entry available */
#define M_CRSW_QMS              0x0020  /* queue mode started */
#define M_CRSW_AQ               0x0010  /* abort queue */
#define M_CRSW_EX               0x0008  /* exception */
#define M_CRSW_ER               0x0004  /* error */
#define M_CRSW_CC               0x0002  /* command complete */
#define M_CRSW_CRBV             0x0001  /* cmd response block valid/clear */

#define CRB_CLR_DONE		((CRSW) = 0)
#define CRB_CLR_ER		((CRSW) &= ~M_CRSW_ER)

typedef struct crb
{                                       /* Command Response Block */
    volatile u_short    crb_CRSW;       /* Command Response Status Word */
    volatile u_short    crb_RES0;       /* Reserved word */
    volatile LONGV      crb_CTAG;       /* Command Tag */
    volatile u_char     crb_IOPB_LENGTH;/* IOPB Length */
    volatile u_char     crb_WORK_QUEUE; /* Work Queue Number */
    volatile u_short    crb_RES1;       /* Reserved word */
} M328_CRB;

/**************** END Command Response Block (CRB)       *******************/

/***********     Controller Error Vector Status Block (CEVSB) **************/
#define CONTROLLER_ERROR    0x0085
#define NR_SCSI_ERROR       0x0885
typedef struct cevsb {				/* Command Response Block */
    volatile u_short      cevsb_CRSW;     /* Command Response Status Word */
    volatile u_char       cevsb_TYPE;     /* IOPB type */
    volatile u_char       cevsb_RES0;     /* Reserved byte */
    volatile LONGV        cevsb_CTAG;     /* Command Tag */
    volatile u_char       cevsb_IOPB_LENGTH;/* IOPB Length */
    volatile u_char       cevsb_WORK_QUEUE;/* Work Queue Number */
    volatile u_short      cevsb_RES1;     /* Reserved word */
    volatile u_char       cevsb_RES2;     /* Reserved byte */
    volatile u_char       cevsb_ERROR;    /* error code */
#define CEVSB_ERR_TYPE	0xC0			/* IOPB type error */
#define CEVSB_ERR_TO	0xC1			/* IOPB timeout error */
#define CEVSB_ERR_TR	0x82			/* Target Reconnect, no IOPB */
#define CEVSB_ERR_OF	0x83			/* Overflow */
#define CEVSB_ERR_BD	0x84			/* Bad direction */
#define CEVSB_ERR_NR	0x86			/* Non-Recoverabl Error */
#define CESVB_ERR_PANIC	0xFF			/* Board Painc!!! */
    volatile u_short      cevsb_AUXERR;   /* COUGAR error code */
} M328_CEVSB;

/***********  END Controller Error Vector Status Block (CEVSB) **************/

/****************     Configuration Status Block (CSB)   *******************/

typedef struct csb
{                                       /* Configuration Status Blk */
    volatile u_short      csb_TYPE;       /* 0x0=JAGUAR, 0x4220=COUGAR */
    volatile u_char       csb_RES1;       /* Reserved byte */
    volatile u_char       csb_PCODE[3];   /* Product Code */
    volatile u_short      csb_RES2;       /* Reserved word */
    volatile u_char       csb_RES3;       /* Reserved byte */
    volatile u_char       csb_PVAR;       /* Product Variation */
    volatile u_short      csb_RES4;       /* Reserved word */
    volatile u_char       csb_RES5;       /* Reserved byte */
    volatile u_char       csb_FREV[3];    /* Firmware Revision level */
    volatile u_short      csb_RES6;       /* Reserved word */
    volatile u_char       csb_FDATE[8];   /* Firmware Release date */
    volatile u_short      csb_SSIZE;      /* System memory size in Kbytes */
    volatile u_short      csb_BSIZE;      /* Buffer memory size in Kbytes */
    volatile u_short      csb_RES8;       /* Reserved word */
    volatile u_char       csb_PFECID;     /* Primary Bus FEC ID */
    volatile u_char       csb_SFECID;     /* Secondard Bus FEC ID */
    volatile u_char       csb_PID;        /* Primary Bus ID */
    volatile u_char       csb_SID;        /* Secondary Bus ID */
    volatile u_char       csb_LPDS;       /* Last Primary Device Selected */
    volatile u_char       csb_LSDS;       /* Last Secondary Device Selected */
    volatile u_char       csb_PPS;        /* Primary Phase Sense */
    volatile u_char       csb_SPS;        /* Secondary Phase Sense */
    volatile u_char       csb_RES10;      /* Reserved byte */
    volatile u_char       csb_DBID;       /* Daughter Board ID */
    volatile u_char       csb_RES11;      /* Reserved byte */
    volatile u_char       csb_SDS;        /* Software DIP Switch */
    volatile u_short      csb_RES12;      /* Reserved word */
    volatile u_short      csb_FWQR;       /* Frozen Work Queues Register */
    volatile u_char       csb_RES13[72];  /* Reserved bytes */
} M328_CSB;

/**************** END Configuration Status Block (CSB)   *******************/

/****************     IOPB Format (IOPB)                 *******************/

/*
 * defines for IOPB Option Word
 */

#define M_OPT_HEAD_TAG          0x3000  /* head of queue command queue tag */
#define M_OPT_ORDERED_TAG       0x2000  /* order command queue tag */
#define M_OPT_SIMPLE_TAG        0x1000  /* simple command queue tag */
#define M_OPT_GO_WIDE           0x0800  /* use WIDE transfers */
#define M_OPT_DIR               0x0100  /* VME direction bit */
#define M_OPT_SG_BLOCK          0x0008  /* scatter/gather in 512 byte blocks */
#define M_OPT_SS                0x0004  /* Suppress synchronous transfer */
#define M_OPT_SG                0x0002  /* scatter/gather bit */
#define M_OPT_IE                0x0001  /* Interrupt enable */

/*
 * defines for IOPB Address Type and Modifier
 */

#define M_ADR_TRANS             0x0C00  /* transfer type */
#define M_ADR_MEMT              0x0300  /* memory type */
#define M_ADR_MOD               0x00FF  /* VME address modifier */
#define M_ADR_SG_LINK           0x8000  /* Scatter/Gather Link bit */

/*
 * defines for IOPB Unit Address on SCSI Bus
 */

#define M_UNIT_EXT_LUN          0xFF00  /* Extended Address */
#define M_UNIT_EXT              0x0080  /* Extended Address Enable */
#define M_UNIT_BUS              0x0040  /* SCSI Bus Selection */
#define M_UNIT_LUN              0x0038  /* Logical Unit Number */
#define M_UNIT_ID               0x0007  /* SCSI Device ID */

typedef struct short_iopb
{
    volatile u_short      iopb_CMD;       /* IOPB Command code */
    volatile u_short      iopb_OPTION;    /* IOPB Option word */
    volatile u_short      iopb_STATUS;    /* IOPB Return Status word */
    volatile u_short      iopb_RES0;      /* IOPB Reserved word */
    volatile u_char       iopb_NVCT;      /* IOPB Normal completion Vector */
    volatile u_char       iopb_EVCT;      /* IOPB Error  completion Vector */
    volatile u_short      iopb_LEVEL;     /* IOPB Interrupt Level */
    volatile u_short      iopb_RES1;      /* IOPB Reserved word */
    volatile u_short      iopb_ADDR;      /* IOPB Address type and modifer */
    volatile LONGV        iopb_BUFF;      /* IOPB Buffer Address */
    volatile LONGV        iopb_LENGTH;    /* IOPB Max-Transfer Length */
    volatile LONGV        iopb_SGTTL;     /* IOPB Scatter/Gather Total Transfer len */
    volatile u_short      iopb_RES4;      /* IOPB Reserved word */
    volatile u_short      iopb_UNIT;      /* IOPB Unit address on SCSI bus */
} M328_short_IOPB;

typedef struct iopb
{
    volatile u_short      iopb_CMD;       /* IOPB Command code */
    volatile u_short      iopb_OPTION;    /* IOPB Option word */
    volatile u_short      iopb_STATUS;    /* IOPB Return Status word */
    volatile u_short      iopb_RES0;      /* IOPB Reserved word */
    volatile u_char       iopb_NVCT;      /* IOPB Normal completion Vector */
    volatile u_char       iopb_EVCT;      /* IOPB Error  completion Vector */
    volatile u_short      iopb_LEVEL;     /* IOPB Interrupt Level */
    volatile u_short      iopb_RES1;      /* IOPB Reserved word */
    volatile u_short      iopb_ADDR;      /* IOPB Address type and modifer */
    volatile LONGV        iopb_BUFF;      /* IOPB Buffer Address */
    volatile LONGV        iopb_LENGTH;    /* IOPB Max-Transfer Length */
    volatile LONGV        iopb_SGTTL;     /* IOPB Scatter/Gather Total Transfer len */
    volatile u_short      iopb_RES4;      /* IOPB Reserved word */
    volatile u_short      iopb_UNIT;      /* IOPB Unit address on SCSI bus */
    u_short      iopb_SCSI[S_IOPB_RES/2]; /* IOPB SCSI words for pass thru */
} M328_IOPB;

/**************** END IOPB Format (IOPB)                 *******************/

/****************     Initialize Work Queue Command Format (WQCF) ***********/

#define M_WOPT_IWQ              0x8000          /* initialize work queue */
#define M_WOPT_PE               0x0008          /* parity check enable */
#define M_WOPT_FE               0x0004          /* freeze on error enable */
#define M_WOPT_TM               0x0002          /* target mode enable */
#define M_WOPT_AE               0x0001          /* abort enable */

typedef struct wqcf
{                                       /* Initialize Work Queue Cmd Format*/
    volatile u_short      wqcf_CMD;       /* Command Normally (0x42) */
    volatile u_short      wqcf_OPTION;    /* Command Options */
    volatile u_short      wqcf_STATUS;    /* Return Status */
    volatile u_short      wqcf_RES0;      /* Reserved word */
    volatile u_char       wqcf_NVCT;      /* Normal Completion Vector */
    volatile u_char       wqcf_EVCT;      /* Error Completion Vector */
    volatile u_short      wqcf_ILVL;      /* Interrupt Level */
    volatile u_short      wqcf_RES1[8];   /* Reserved words */
    volatile u_short      wqcf_WORKQ;     /* Work Queue Number */
    volatile u_short      wqcf_WOPT;      /* Work Queue Options */
    volatile u_short      wqcf_SLOTS;     /* Number of slots in Work Queues */
    volatile u_short      wqcf_RES2;      /* Reserved word */
    volatile LONGV        wqcf_CMDTO;     /* Command timeout */
    volatile u_short      wqcf_RES3;      /* Reserved word */
} M328_WQCF;

/**************** END Initialize Work Queue Command Format (WQCF) ***********/

/****************     SCSI Reset Command Format (SRCF) ***********/

typedef struct srcf
{                                       /* SCSI Reset Cmd Format*/
    volatile u_short      srcf_CMD;       /* Command Normally (0x22) */
    volatile u_short      srcf_OPTION;    /* Command Options */
    volatile u_short      srcf_STATUS;    /* Return Status */
    volatile u_short      srcf_RES0;      /* Reserved word */
    volatile u_char       srcf_NVCT;      /* Normal Completion Vector */
    volatile u_char       srcf_EVCT;      /* Error Completion Vector */
    volatile u_short      srcf_ILVL;      /* Interrupt Level */
    volatile u_short      srcf_RES1[8];   /* Reserved words */
    volatile u_short      srcf_BUSID;     /* SCSI bus ID to reset */
} M328_SRCF;

/**************** END SCSI Reset Command Format (SRCF) ***********/

/****************     Device Reinitialize Command Format (DRCF) ***********/

typedef struct drcf
{                                       /* Device Reinitialize Cmd Format*/
    volatile u_short      drcf_CMD;       /* Command Normally (0x4C) */
    volatile u_short      drcf_OPTION;    /* Command Options */
    volatile u_short      drcf_STATUS;    /* Return Status */
    volatile u_short      drcf_RES0;      /* Reserved word */
    volatile u_char       drcf_NVCT;      /* Normal Completion Vector */
    volatile u_char       drcf_EVCT;      /* Error Completion Vector */
    volatile u_short      drcf_ILVL;      /* Interrupt Level */
    volatile u_short      drcf_RES1[9];   /* Reserved words */
    volatile u_short      drcf_UNIT;      /* Unit Address */
} M328_DRCF;

/**************** END SCSI Reset Command Format (SRCF) ***********/

/**************** Host Down Loadable Firmware (HDLF) ***********/

typedef struct hdlf
{                                       /* Host Down Loadable Firmware cmd */
    volatile u_short      hdlf_CMD;       /* Command Normally (0x4F) */
    volatile u_short      hdlf_OPTION;    /* Command Options */
    volatile u_short      hdlf_STATUS;    /* Return Status */
    volatile u_short      hdlf_RES0;      /* Reserved word */
    volatile u_char       hdlf_NVCT;      /* Normal Completion Vector */
    volatile u_char       hdlf_EVCT;      /* Error Completion Vector */
    volatile u_short      hdlf_ILVL;      /* Interrupt Level */
    volatile u_short      hdlf_RES1;      /* Reserved word */
    volatile u_short      hdlf_ADDR;      /* Address type and modifer */
    volatile LONGV        hdlf_BUFF;      /* Buffer Address */
    volatile LONGV        hdlf_LENGTH;    /* Max-Transfer Length */
    volatile LONGV        hdlf_CSUM;      /* Checksum */
    volatile u_short      hdlf_RES2;      /* Reserved word */
    volatile u_short      hdlf_SEQ;       /* Sequence number */
    volatile u_short      hdlf_RES3[6];   /* Reserved words */
} M328_HDLF;

#define M328_INITIALIZE_DOWNLOAD        0x0010
#define M328_TRANSFER_PACKET            0x0020
#define M328_PROGRAM_FLASH              0x0040
#define M328_MOTOROLA_S_RECORDS         0x1000

/**************** END SCSI Reset Command Format (SRCF) ***********/

/****************     Short I/O Format                   *******************/

struct vsreg
{
    M328_MCSB   sh_MCSB;           /* Master Control / Status Block */
    M328_CQE    sh_MCE;            /* Master Command Entry */
    M328_CQE    sh_CQE[NUM_CQE];   /* Command Queue Entry */
    M328_IOPB   sh_IOPB[NUM_IOPB]; /* Host IOPB   Space */
    M328_IOPB   sh_MCE_IOPB;       /* Host MCE IOPB Space */
    M328_CIB    sh_CIB;            /* Controller Initialization Block */
    volatile u_char sh_HUS[S_HUS_FREE];/* Host Usable Space */
    M328_HSB    sh_HSB;            /* Host Semaphore Block */
    M328_CRB    sh_CRB;            /* Command Response Block */
    M328_IOPB   sh_RET_IOPB;       /* Returned IOPB */
    M328_CSB    sh_CSS;            /* Controller Specific Space/Block */
};

#define CRSW		sc->sc_vsreg->sh_CRB.crb_CRSW
#define THAW_REG	sc->sc_vsreg->sh_MCSB.mcsb_THAW
#define THAW(x)		THAW_REG = (((x) << 8) | M_THAW_TWQE)

#define SELECTION_TIMEOUT               250     /* milliseconds */
#define VME_BUS_TIMEOUT                 0xF     /* units of 30ms */

/**************** END Short I/O Format                   *******************/

/*
 *  SCSI IOPB definitions
 */

#define IOPB_PASS_THRU      0x20    /* SCSI Pass Through commands */
#define IOPB_PASS_THRU_EXT  0x21    /* SCSI Pass Through Extended commands */
#define IOPB_RESET          0x22    /* SCSI Reset bus */

/*
 *  SCSI Control IOPB's
 */

#define CNTR_DIAG           0x40        /* Perform Diagnostics */
#define CNTR_INIT           0x41        /* Initialize Controller */
#define CNTR_INIT_WORKQ     0x42        /* Initialize Work Queue */
#define CNTR_DUMP_INIT      0x43        /* Dump Initialization Parameters */
#define CNTR_DUMP_WORDQ     0x44        /* Dump work Queue Parameters */
#define CNTR_CANCEL_IOPB    0x48        /* Cancel command tag */
#define CNTR_FLUSH_WORKQ    0x49        /* Flush Work Queue */
#define CNTR_DEV_REINIT     0x4C        /* Reinitialize Device */
#define CNTR_ISSUE_ABORT    0x4E        /* An abort has been issued */
#define CNTR_DOWNLOAD_FIRMWARE 0x4F     /* Download firmware (COUGAR) */


/*
 *  Memory types
 */

#define MEMT_16BIT              1       /* 16 Bit Memory type */
#define MEMT_32BIT              2       /* 32 Bit Memory type */
#define MEMT_SHIO               3       /* Short I/O Memory type */
#define MEMTYPE         MEMT_32BIT      /* do 32-bit transfers */

/*
 *  Transfer types
 */

#define TT_NORMAL               0       /* Normal Mode Tranfers */
#define TT_BLOCK                1       /* block  Mode Tranfers */
#define TT_DISABLE_INC_ADDR     2       /* Disable Incrementing Addresses */
#define TT_D64                  3       /* D64 Mode Transfers */

/*
 *      Error codes.
 */

#define MACSI_GOOD_STATUS       0x00    /* Good status */
#define MACSI_QUEUE_FULL        0x01    /* The work queue is full */
#define MACSI_CMD_CODE_ERR      0x04    /* The IOPB command field is invalid */
#define MACSI_QUEUE_NUMBER_ERR  0x05    /* Invalid queue number */

#define RESET_BUS_STATUS        0x11    /* SCSI bus reset IOPB forced this */
#define NO_SECONDARY_PORT       0x12    /* second SCSI bus not available */
#define SCSI_DEVICE_IS_RESET    0x14    /* device has been reset */
#define CMD_ABORT_BY_RESET      0x15    /* device has been reset */

#define VME_BUS_ERROR           0x20    /* There was a VME BUS error */
#define VME_BUS_ACC_TIMEOUT     0x21
#define VME_BUS_BAD_ADDR        0x23
#define VME_BUS_BAD_MEM_TYPE    0x24
#define VME_BUS_BAD_COUNT       0x25
#define VME_BUS_FETCH_ERROR     0x26
#define VME_BUS_FETCH_TIMEOUT   0x27
#define VME_BUS_POST_ERROR      0x28
#define VME_BUS_POST_TIMEOUT    0x29
#define VME_BUS_BAD_FETCH_ADDR  0x2A
#define VME_BUS_BAD_POST_ADDR   0x2B
#define VME_BUS_SG_FETCH        0x2C
#define VME_BUS_SG_TIMEOUT      0x2D
#define VME_BUS_SG_COUNT        0x2E

#define SCSI_SELECTION_TO       0x30    /* select time out */
#define SCSI_DISCONNECT_TIMEOUT 0x31    /* disconnect timeout */
#define SCSI_ABNORMAL_SEQ       0x32    /* abnormal sequence */
#define SCSI_DISCONNECT_ERR     0x33    /* disconnect error */
#define SCSI_XFER_EXCEPTION     0x34    /* transfer cnt exception */
#define SCSI_PARITY_ERROR       0x35    /* parity error */

#define DEVICE_NO_IOPB          0x82    /* IOPB no available */
#define IOPB_CTLR_EHX           0x83    /* IOPB counter exhausted */
#define IOPB_DIR_ERROR          0x84    /* IOPB direction wrong */
#define COUGAR_ERROR            0x86    /* COUGAR unrecoverable error */
#define MACSI_INCORRECT_HARDWARE 0x90    /* Insufficient memory */
#define MACSI_ILGL_IOPB_VAL     0x92    /* Invalid field in the IOPB */
#define MACSI_ILLEGAL_IMAGE     0x9C    /* Submitted fails reuested action */
#define IOPB_TYPE_ERR           0xC0    /* IOPB type not 0 */
#define IOPB_TIMEOUT            0xC1    /* IOPB timed out */

#define COUGAR_PANIC            0xFF    /* COUGAR paniced */

#define MACSI_INVALID_TIMEOUT   0x843   /* The SCSI byte to byte timer expired */

/*
 *      VME addressing modes
 */

#define ADRM_STD_S_P            0x3E    /* Standard Supervisory Program */
#define ADRM_STD_S_D            0x3D    /* Standard Supervisory Data */
#define ADRM_STD_N_P            0x3A    /* Standard Normal Program */
#define ADRM_STD_N_D            0x39    /* Standard Normal Data */
#define ADRM_SHT_S_IO           0x2D    /* Short Supervisory IO */
#define ADRM_SHT_N_IO           0x29    /* Short Normal IO */
#define ADRM_EXT_S_P            0x0E    /* Extended Supervisory Program */
#define ADRM_EXT_S_D            0x0D    /* Extended Supervisory Data */
#define ADRM_EXT_N_P            0x0A    /* Extended Normal Program */
#define ADRM_EXT_N_D            0x09    /* Extended Normal Data */
#define ADRM_EXT_S_BM           0x0F    /* Extended Supervisory Block Mode */
#define ADRM_EXT_S_D64          0x0C    /* Extended Supervisory D64 Mode */

#define ADDR_MOD        ( (TT_NORMAL << 10) | (MEMTYPE << 8) | ADRM_EXT_S_D )
#define BLOCK_MOD       ( (TT_BLOCK << 10) | (MEMTYPE << 8) | ADRM_EXT_S_BM )
#define D64_MOD         ( (TT_D64 << 10) | (MEMTYPE << 8) | ADRM_EXT_S_D64 )
#define SHIO_MOD        ( (TT_NORMAL << 10) | (MEMT_SHIO << 8) | ADRM_SHT_N_IO)
d430 1
a430 1
#endif /* _M328REG_H_ */
@


1.6
log
@General cleanup before attempting to move towards bus_space and bus_dma.
Also fix an arithmetic bug which caused almost no harm by luck.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsreg.h,v 1.5 2003/09/29 09:08:19 miod Exp $ */
d91 1
d93 1
d95 1
a110 2
#define HOST_ID                 0x4321

d295 2
a296 6
#define CRB_CLR_DONE(crsw)      ((crsw) = 0)
#define CRB_CLR_ER(crsw)        ((crsw) &= ~M_CRSW_ER)
#define CRB_CLR_SC(crsw)	((crsw) &= ~M_CRSW_SC)
#define CRB_CLR_SE(crsw)	((crsw) &= ~M_CRSW_SE)
#define CRB_CLR_RST(crsw)	((crsw) &= ~M_CRSW_RST)
#define CRB_CLR(crsw)		((crsw) &= ~(x))
d553 4
a556 4
#define CRSW sc->sc_vsreg->sh_CRB.crb_CRSW
#define THAW_REG sc->sc_vsreg->sh_MCSB.mcsb_THAW
#define THAW(x) THAW_REG=((u_char)x << 8);THAW_REG |= M_THAW_TWQE
#define QUEUE_FZN(x) (sc->sc_vsreg->sh_CSS.csb_FWQR & (1 << x))
a558 1
#define M328_INFINITE_TIMEOUT           0       /* wait forever */
@


1.5
log
@avaliable -> available
@
text
@d1 1
a1 1
/*	$OpenBSD: vsreg.h,v 1.4 2003/06/02 23:27:52 millert Exp $ */
a566 16
 * Scatter gather structure
 */

typedef struct ipsg
{
    volatile u_short      sg_count;       /* byte/entry count */
    volatile u_short      sg_addrhi;      /* datablock/entry address high */
    volatile u_short      sg_addrlo;      /* datablock/entry address low */
    volatile u_short      sg_meminfo;     /* memory information */
}IPSG;

#define MACSI_SG        256     /* number of MACSI scat/gat entries     */
#define S_MACSI_SG      (MACSI_SG * sizeof(IPSG))
#define MACSI_SG_RSIZE  65535   /* max len of each scatter/gather entry */

/*
a656 6

/*
 *      Handy vector macro.
 */

#define VEC(c, vec)     (((c) -> mc_ipl << 8) + (vec))
@


1.4
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsreg.h,v 1.3 2001/02/01 03:38:16 smurph Exp $ */
d137 1
a137 1
#define M_IQAR_ILVL             0x0700  /* interrupt lvl on queue avaliable */
@


1.3
log
@Major changes to get MVME188 working.  More header and code cleanups.  The
kernel is tested on MVME188A/2P256 and MVME188A/1P64.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsreg.h,v 1.2 1999/09/27 18:43:26 smurph Exp $ */
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.2
log
@adding support for MVME188 and MVME197.  Plus 32bit if_ie.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsreg.h,v 1.1 1999/05/29 04:41:44 smurph Exp $ */
a164 47
/****************     Scater/Gather Stuff                *******************/

typedef struct {
   union {
      unsigned short bytes :16;
   #define MAX_SG_BLOCK_SIZE	(1<<16)	/* the size *has* to be always *smaller* */
      struct {
         unsigned short :8;
         unsigned short gather :8;
      } scatter;
   } count;
   LONGV           address;
   unsigned short  link :1;
   unsigned short  :3;
   unsigned short  transfer_type :2;
   /* 				0x0 is reserved */
   #define SHORT_TREANSFER 		0x1	
   #define LONG_TRANSFER			0x2	
   #define SCATTER_GATTER_LIST_IN_SHORT_IO	0x3	
   unsigned short  memory_type :2;
   #define NORMAL_TYPE			0x0	
   #define BLOCK_MODE			0x1	
   /*				0x2 is reserved */
   /*				0x3 is reserved */
   unsigned short  address_modifier :8;
}sg_list_element_t;

typedef sg_list_element_t * scatter_gather_list_t;

#define MAX_SG_ELEMENTS 64

struct m328_sg {
   struct m328_sg  *up;
   int                     elements;
   int                     level;
   struct m328_sg  *down[MAX_SG_ELEMENTS];
   sg_list_element_t list[MAX_SG_ELEMENTS];
};

typedef struct m328_sg *M328_SG;

typedef struct {
   struct scsi_xfer  *xs;
   M328_SG           top_sg_list;
} M328_CMD;
/**************** END Scater/Gather Stuff                *******************/

d300 4
d318 3
a320 3

typedef struct cevsb
{                                       /* Command Response Block */
d330 7
a704 14

/*
 * Scatter/gather functions
 */

M328_SG vs_alloc_scatter_gather __P((void));
void    vs_dealloc_scatter_gather __P((M328_SG sg));
void    vs_link_scatter_gather_element __P((sg_list_element_t *element,
                                            register vm_offset_t phys_add,
                                            register int len));
void    vs_link_scatter_gather_list __P((sg_list_element_t *list,
                                         register vm_offset_t phys_add,
                                         register int elements));
M328_SG vs_build_memory_structure __P((struct scsi_xfer *xs, M328_IOPB *iopb));
@


1.2.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: vsreg.h,v 1.3 2001/02/01 03:38:16 smurph Exp $ */
d165 47
a346 4
#define CRB_CLR_SC(crsw)	((crsw) &= ~M_CRSW_SC)
#define CRB_CLR_SE(crsw)	((crsw) &= ~M_CRSW_SE)
#define CRB_CLR_RST(crsw)	((crsw) &= ~M_CRSW_RST)
#define CRB_CLR(crsw)		((crsw) &= ~(x))
d361 3
a363 3
#define CONTROLLER_ERROR    0x0085
#define NR_SCSI_ERROR       0x0885
typedef struct cevsb {				/* Command Response Block */
a372 7
#define CEVSB_ERR_TYPE	0xC0			/* IOPB type error */
#define CEVSB_ERR_TO	0xC1			/* IOPB timeout error */
#define CEVSB_ERR_TR	0x82			/* Target Reconnect, no IOPB */
#define CEVSB_ERR_OF	0x83			/* Overflow */
#define CEVSB_ERR_BD	0x84			/* Bad direction */
#define CEVSB_ERR_NR	0x86			/* Non-Recoverabl Error */
#define CESVB_ERR_PANIC	0xFF			/* Board Painc!!! */
d741 14
@


1.2.4.2
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vsreg.h,v 1.2.4.1 2001/04/18 16:11:09 niklas Exp $ */
d17 5
a21 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.2.4.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d137 1
a137 1
#define M_IQAR_ILVL             0x0700  /* interrupt lvl on queue available */
@


1.2.4.4
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1
 * Copyright (c) 2004, Miodrag Vallat.
d34 22
a55 2
#ifndef	_MVME328_REG_H_
#define	_MVME328_REG_H_
d58 1
a58 1
 * JAGUAR specific device limits
d61 7
a67 3
#define	JAGUAR_MIN_Q_SIZ		2
#define	JAGUAR_MAX_Q_SIZ		2
#define	JAGUAR_MAX_CTLR_CMDS		80	/* Interphase says so */
d70 1
a70 1
 * COUGAR specific device limits
d73 3
a75 2
#define	COUGAR_MIN_Q_SIZ		2
#define	COUGAR_CMDS_PER_256K		42	/* Interphase says so */
d78 1
a78 1
 * Structures
d81 2
a82 2
#define	NUM_CQE			10
#define	NUM_IOPB		NUM_CQE
d85 1
a85 1
 * Master Control Status Block (MCSB)
d88 613
a700 365
#define	MCSB_MSR		0x000000	/* master status register */
#define	M_MSR_QFC	0x0004		/* queue flush complete */
#define	M_MSR_BOK	0x0002		/* board OK */
#define	M_MSR_CNA	0x0001		/* controller not available */
#define	MCSB_MCR		0x000002	/* master control register */
#define	M_MCR_SFEN	0x2000		/* sysfail enable */
#define	M_MCR_RES	0x1000		/* reset controller */
#define	M_MCR_FLQ	0x0800		/* flush queue */
#define	M_MCR_FLQR	0x0004		/* flush queue and report */
#define	M_MCR_SQM	0x0001		/* start queue mode */
#define	MCSB_IQAR		0x000004	/* interrupt on queue avail */
#define	M_IQAR_IQEA	0x8000		/* interrupt on queue entry avail */
#define	M_IQAR_IQEH	0x4000		/* interrupt on queue half empty */
#define	M_IQAR_ILVL	0x0700		/* interrupt lvl on queue available */
#define	M_IQAR_IVCT	0x00ff		/* interrupt vector on queue avail */
#define	MCSB_QHDP		0x000006	/* queue head pointer */
#define	MCSB_THAW		0x000008	/* thaw work queue */
#define	M_THAW_TWQN	0xff00		/* thaw work queue number */
#define	M_THAW_TWQE	0x0001		/* thaw work queue enable */
#define	MCSB_SIZE		0x000010

/*
 * Host Semaphore Block (HSB)
 */

#define	HSB_INITQ		0x000000	/* init MCE flag */
#define	HSB_WORKQ		0x000002	/* work queue number */
#define	HSB_MAGIC		0x000004	/* magic word */
#define	HSB_SIZE		0x000008

/*
 * Controller Initialization Block (CIB)
 */

#define	CIB_NCQE		0x000000	/* number of CQE */
#define	CIB_BURST		0x000002	/* DMA burst count */
#define	CIB_NVECT		0x000004	/* normal completion vector */
#define	CIB_EVECT		0x000006	/* error completion vector */
#define	M_VECT_ILVL	0x0700		/* Interrupt Level mask */
#define	M_VECT_IVCT	0x00ff		/* Interrupt Vector mask */
#define	CIB_PID			0x000008	/* primary scsi bus id */
#define	CIB_SID			0x00000a	/* secondary scsi bus id */
#define	M_PSID_DFT	0x0008 		/* default ID enable */
#define	M_PSID_ID	0x0007		/* primary/secondary SCSI ID */
#define	CIB_CRBO		0x00000c	/* CRB offset */
#define	CIB_SELECT		0x00000e	/* selection timeout in ms */
#define	CIB_WQTIMO		0x000012	/* work queue timeout in 256ms */
#define	CIB_VMETIMO		0x000016	/* VME timeout in 32ms */
#define	CIB_OBMT		0x00001e	/* offboard CRB mtype/xfer type/ad mod */
#define	CIB_OBADDR		0x000020	/* host mem address for offboard CRB */
#define	CIB_ERR_FLGS		0x000024	/* error recovery flags */
#define	M_ERRFLGS_FOSR	0x0001		/* Freeze on SCSI bus reset */
#define	M_ERRFLGS_RIN	0x0002		/* SCSI bus reset interrupt */
#define	M_ERRFLGS_RSE	0x0004		/* Report COUGAR SCSI errors */
#define	CIB_SBRIV		0x00002a	/* scsi bus reset interrupt vector */
#define	CIB_SOF0		0x00002c	/* synchronous offset (bus 0) */
#define	CIB_SRATE0		0x00002d	/* sync negotiation rate (bus 0) */
#define	CIB_SOF1		0x00002e	/* synchronous offset (bus 0) */
#define	CIB_SRATE1		0x00002f	/* sync negotiation rate (bus 0) */
#define	CIB_SIZE		0x000030

/*
 * Command Queue Entry (CQE)
 */

#define	CQE_QECR		0x000000	/* queue entry control reg */
#define	M_QECR_IOPB	0x0f00		/* IOPB type (must be zero) */
#define	M_QECR_HPC	0x0004		/* High Priority command */
#define	M_QECR_AA	0x0002		/* abort acknowledge */
#define	M_QECR_GO	0x0001		/* Go/Busy */
#define	CQE_IOPB_ADDR		0x000002	/* IOPB address */
#define	CQE_CTAG		0x000004	/* command tag */
#define	CQE_IOPB_LENGTH		0x000008	/* IOPB length */
#define	CQE_WORK_QUEUE		0x000009	/* work queue number */
#define	CQE_SIZE		0x00000c

/*
 * Command Response Block (CRB)
 */

#define	CRB_CRSW		0x000000	/* status word */
#define	M_CRSW_SE	0x0800		/* SCSI error (COUGAR) */
#define	M_CRSW_RST	0x0400		/* SCSI Bus reset (COUGAR) */
#define	M_CRSW_SC	0x0080		/* status change */
#define	M_CRSW_CQA	0x0040		/* Command queue entry available */
#define	M_CRSW_QMS	0x0020		/* queue mode started */
#define	M_CRSW_AQ	0x0010		/* abort queue */
#define	M_CRSW_EX	0x0008		/* exception */
#define	M_CRSW_ER	0x0004		/* error */
#define	M_CRSW_CC	0x0002		/* command complete */
#define	M_CRSW_CRBV	0x0001		/* cmd response block valid/clear */
#define	CRB_CTAG		0x000004	/* command tag */
#define	CRB_IOPB_LENGTH		0x000008	/* IOPB length */
#define	CRB_WORK_QUEUE		0x000009	/* work queue number */
#define	CRB_SIZE		0x00000c

/*
 * Controller Error Vector Status Block (CEVSB)
 * This is a variation of the CRB, _but larger_.
 */

#define	CONTROLLER_ERROR	0x0085
#define	NR_SCSI_ERROR		0x0885

#define	CEVSB_CRSW		0x000000	/* status word */
#define	CEVSB_TYPE		0x000002	/* IOPB type */
#define	CEVSB_CTAG		0x000004	/* command tag */
#define	CEVSB_IOPB_LENGTH	0x000008	/* IOPB length */
#define	CEVSB_WORK_QUEUE	0x000009	/* work queue number */
#define	CEVSB_ERROR		0x00000d	/* error code */
#define	CEVSB_ERR_TYPE	0xc0			/* IOPB type error */
#define	CEVSB_ERR_TO	0xc1			/* IOPB timeout error */
#define	CEVSB_ERR_TR	0x82			/* Target Reconnect, no IOPB */
#define	CEVSB_ERR_OF	0x83			/* Overflow */
#define	CEVSB_ERR_BD	0x84			/* Bad direction */
#define	CEVSB_ERR_NR	0x86			/* Non-Recoverabl Error */
#define	CESVB_ERR_PANIC	0xff			/* Board Painc!!! */
#define	CEVSB_AUXERR		0x00000e	/* cougar error code */
#define	CEVSB_SIZE		0x000010

/*
 * Configuration Status Block (CSB)
 */

#define	CSB_TYPE		0x000000	/* jaguar/cougar */
#define	COUGAR		0x4220
#define	JAGUAR		0x0000
#define	CSB_PCODE		0x000003	/* product code */
#define	CSB_PVAR		0x000009	/* product variation */
#define	CSB_FREV		0x00000d	/* firmware revision level */
#define	CSB_FDATE		0x000012	/* firmware release date */
#define	CSB_SSIZE		0x00001a	/* system memory size in KB */
#define	CSB_BSIZE		0x00001c	/* buffer memory size in KB */
#define	CSB_PFECID		0x000020	/* primary bus FEC id */
#define	CSB_SFECID		0x000021	/* secondary bus FEC id */
#define	CSB_PID			0x000022	/* primary bus id */
#define	CSB_SID			0x000023	/* secondary bus id */
#define	CSB_LPDS		0x000024	/* last primary device selected */
#define	CSB_LSDS		0x000025	/* last secondary device selected */
#define	CSB_PPS			0x000026	/* primary phase sense */
#define	CSB_SPS			0x000027	/* secondary phase sense */
#define	CSB_DBIB		0x000029	/* daughter board id */
#define	CSB_SDS			0x00002b	/* software DIP switch */
#define	CSB_FWQR		0x00002e	/* frozen work queues register */
#define	CSB_SIZE		0x000078

/*
 * IOPB Format (IOPB)
 */

#define	IOPB_CMD		0x000000	/* command code */
#define	IOPB_OPTION		0x000002	/* option word */
#define	M_OPT_HEAD_TAG		0x3000	/* head of queue command queue tag */
#define	M_OPT_ORDERED_TAG	0x2000	/* order command queue tag */
#define	M_OPT_SIMPLE_TAG	0x1000	/* simple command queue tag */
#define	M_OPT_GO_WIDE		0x0800	/* use WIDE transfers */
#define	M_OPT_DIR		0x0100	/* VME direction bit */
#define	M_OPT_SG_BLOCK		0x0008	/* scatter/gather in 512 byte blocks */
#define	M_OPT_SS		0x0004	/* Suppress synchronous transfer */
#define	M_OPT_SG		0x0002	/* scatter/gather bit */
#define	M_OPT_IE		0x0001	/* Interrupt enable */
#define	IOPB_STATUS		0x000004	/* return status word */
#define	IOPB_NVCT		0x000008	/* normal completion vector */
#define	IOPB_EVCT		0x000009	/* error completion vector */
#define	IOPB_LEVEL		0x00000a	/* interrupt level */
#define	IOPB_ADDR		0x00000e	/* address type and modifier */
#define	M_ADR_TRANS	0x0c00		/* transfer type */
#define	M_ADR_MEMT	0x0300		/* memory type */
#define	M_ADR_MOD	0x00ff		/* VME address modifier */
#define	M_ADR_SG_LINK	0x8000		/* Scatter/Gather Link bit */
#define	IOPB_BUFF		0x000010	/* buffer address */
#define	IOPB_LENGTH		0x000014	/* max transfer length */
#define	IOPB_SGTTL		0x000018	/* S/G total transfer length */
#define	IOPB_UNIT		0x00001e	/* unit address on scsi bus */
#define	M_UNIT_EXT_LUN	0xff00		/* Extended Address */
#define	M_UNIT_EXT	0x0080		/* Extended Address Enable */
#define	M_UNIT_BUS	0x0040		/* SCSI Bus Selection */
#define	M_UNIT_LUN	0x0038		/* Logical Unit Number */
#define	M_UNIT_ID	0x0007		/* SCSI Device ID */
#define	IOPB_SCSI_DATA		0x000020	/* SCSI words for passthrough */
#define	IOPB_SHORT_SIZE		0x000020
#define	IOPB_LONG_SIZE		0x000040

/*
 * Initialize Work Queue Command Format (WQCF)
 * This is a specific case of IOPB.
 */

#define	WQCF_CMD		0x000000	/* command code */
#define	M_WOPT_IWQ	0x8000		/* initialize work queue */
#define	M_WOPT_PE	0x0008		/* parity check enable */
#define	M_WOPT_FE	0x0004		/* freeze on error enable */
#define	M_WOPT_TM	0x0002		/* target mode enable */
#define	M_WOPT_AE	0x0001		/* abort enable */
#define	WQCF_OPTION		0x000002	/* option word */
#define	WQCF_STATUS		0x000004	/* return status word */
#define	WQCF_NVCT		0x000008	/* normal completion vector */
#define	WQCF_EVCT		0x000009	/* error completion vector */
#define	WQCF_ILVL		0x00000a	/* interrupt level */
#define	WQCF_WORKQ		0x00001c	/* work queue number */
#define	WQCF_WOPT		0x00001e	/* work queue options */
#define	WQCF_SLOTS		0x000020	/* # of slots in work queues */
#define	WQCF_CMDTO		0x000024	/* command timeout */

/*
 * SCSI Reset Command Format (SRCF)
 * This is a specific case of IOPB.
 */

#define	SRCF_CMD		0x000000	/* command code */
#define	SRCF_OPTION		0x000002	/* option word */
#define	SRCF_STATUS		0x000004	/* return status word */
#define	SRCF_NVCT		0x000008	/* normal completion vector */
#define	SRCF_EVCT		0x000009	/* error completion vector */
#define	SRCF_ILVL		0x00000a	/* interrupt level */
#define	SRCF_BUSID		0x00001c	/* scsi bus id to reset */

/*
 * Device Reinitialize Command Format (DRCF)
 * This is a specific case of IOPB.
 */

#define	DRCF_CMD		0x000000	/* command code */
#define	DRCF_OPTION		0x000002	/* option word */
#define	DRCF_STATUS		0x000004	/* return status word */
#define	DRCF_NVCT		0x000008	/* normal completion vector */
#define	DRCF_EVCT		0x000009	/* error completion vector */
#define	DRCF_ILVL		0x00000a	/* interrupt level */
#define	DRCF_UNIT		0x00001e	/* unit address */

/*
 * Short I/O memory layout
 */

#define	S_SHORTIO		0x000800

#define	sh_MCSB		(0)
#define	sh_MCE		(sh_MCSB + MCSB_SIZE)
#define	sh_CQE(x)	(sh_MCE + CQE_SIZE + CQE_SIZE * (x))
#define	sh_IOPB(x)	(sh_CQE(NUM_CQE) + IOPB_LONG_SIZE * (x))
#define	sh_MCE_IOPB	(sh_IOPB(NUM_IOPB))
#define	sh_CIB		(sh_MCE_IOPB + IOPB_LONG_SIZE)

#define	sh_CSS		(S_SHORTIO - CSB_SIZE)
#define	sh_RET_IOPB	(sh_CSS - IOPB_LONG_SIZE)
#define	sh_CRB		(sh_RET_IOPB - CRB_SIZE)
#define	sh_CEVSB	sh_CRB
#define	sh_HSB		(sh_CRB - HSB_SIZE)

#if (sh_CIB + CIB_SIZE > sh_HSB)
#error	invalid memory layout
#endif

#define	SELECTION_TIMEOUT		250	/* milliseconds */
#define	VME_BUS_TIMEOUT			15	/* units of 30ms */
#define	M328_INFINITE_TIMEOUT		0	/* wait forever */

/*
 * IOPB command codes
 */

#define	IOPB_PASSTHROUGH		0x20 /* SCSI passthrough commands */
#define	IOPB_PASSTHROUGH_EXT		0x21 /* SCSI passthrough extended */
#define	IOPB_RESET			0x22 /* reset bus */

#define	CNTR_DIAG			0x40 /* perform diagnostics */
#define	CNTR_INIT			0x41 /* initialize controller */
#define	CNTR_INIT_WORKQ			0x42 /* initialize work queue */
#define	CNTR_DUMP_INIT			0x43 /* dump initialization parameters */
#define	CNTR_DUMP_WORDQ			0x44 /* dump work queue parameters */
#define	CNTR_CANCEL_IOPB		0x48 /* cancel command tag */
#define	CNTR_FLUSH_WORKQ		0x49 /* flush work queue */
#define	CNTR_DEV_REINIT			0x4c /* reinitialize device */
#define	CNTR_ISSUE_ABORT		0x4e /* abort has been issued */
#define	CNTR_DOWNLOAD_FIRMWARE		0x4f /* download firmware (COUGAR) */

/*
 * Memory types
 */

#define	MEMT_16BIT	1	/* 16 bit memory type */
#define	MEMT_32BIT	2	/* 32 bit memory type */
#define	MEMT_SHIO	3	/* short I/O memory type */
#define	MEMTYPE		MEMT_32BIT

/*
 * Transfer types
 */

#define	TT_NORMAL		0	/* normal mode tranfers */
#define	TT_BLOCK		1	/* block mode tranfers */
#define	TT_DISABLE_INC_ADDR	2	/* disable incrementing addresses */
#define	TT_D64			3	/* D64 mode transfers */

/*
 * Error codes
 */

#define	MACSI_GOOD_STATUS	0x00
#define	MACSI_QUEUE_FULL	0x01
#define	MACSI_CMD_CODE_ERR	0x04
#define	MACSI_QUEUE_NUMBER_ERR	0x05

#define	RESET_BUS_STATUS	0x11	/* SCSI bus reset IOPB forced this */
#define	NO_SECONDARY_PORT	0x12	/* second SCSI bus not available */
#define	SCSI_DEVICE_IS_RESET	0x14
#define	CMD_ABORT_BY_RESET	0x15

#define	VME_BUS_ERROR		0x20
#define	VME_BUS_ACC_TIMEOUT	0x21
#define	VME_BUS_BAD_ADDR	0x23
#define	VME_BUS_BAD_MEM_TYPE	0x24
#define	VME_BUS_BAD_COUNT	0x25
#define	VME_BUS_FETCH_ERROR	0x26
#define	VME_BUS_FETCH_TIMEOUT	0x27
#define	VME_BUS_POST_ERROR	0x28
#define	VME_BUS_POST_TIMEOUT	0x29
#define	VME_BUS_BAD_FETCH_ADDR	0x2a
#define	VME_BUS_BAD_POST_ADDR	0x2b
#define	VME_BUS_SG_FETCH	0x2c
#define	VME_BUS_SG_TIMEOUT	0x2d
#define	VME_BUS_SG_COUNT	0x2e

#define	SCSI_SELECTION_TO	0x30
#define	SCSI_DISCONNECT_TIMEOUT	0x31
#define	SCSI_ABNORMAL_SEQ	0x32
#define	SCSI_DISCONNECT_ERR	0x33
#define	SCSI_XFER_EXCEPTION	0x34
#define	SCSI_PARITY_ERROR	0x35

#define	DEVICE_NO_IOPB		0x82
#define	IOPB_CTLR_EXH		0x83
#define	IOPB_DIR_ERROR		0x84
#define	COUGAR_ERROR		0x86
#define	MACSI_INCORRECT_HW	0x90
#define	MACSI_ILGL_IOPB_VAL	0x92
#define	MACSI_ILLEGAL_IMAGE	0x9c
#define	IOPB_TYPE_ERR		0xc0	/* IOPB type not 0 */
#define	IOPB_TIMEOUT		0xc1

#define	COUGAR_PANIC		0xff

#define	MACSI_INVALID_TIMEOUT	0x843

/*
 * VME addressing modes
 */

#define	ADRM_STD_S_P		0x3e	/* standard supervisory program */
#define	ADRM_STD_S_D		0x3d	/* standard supervisory data */
#define	ADRM_STD_N_P		0x3a	/* standard normal program */
#define	ADRM_STD_N_D		0x39	/* standard normal data */
#define	ADRM_SHT_S_IO		0x2d	/* short supervisory I/O */
#define	ADRM_SHT_N_IO		0x29	/* short normal I/O */
#define	ADRM_EXT_S_P		0x0e	/* extended supervisory program */
#define	ADRM_EXT_S_D		0x0d	/* extended supervisory data */
#define	ADRM_EXT_N_P		0x0a	/* extended normal program */
#define	ADRM_EXT_N_D		0x09	/* extended normal data */
#define	ADRM_EXT_S_BM		0x0f	/* extended supervisory block mode */
#define	ADRM_EXT_S_D64		0x0c	/* extended supervisory D64 mode */

#define	ADDR_MOD	((TT_NORMAL << 10) | (MEMTYPE << 8) | ADRM_EXT_S_D)
#define	BLOCK_MOD	((TT_BLOCK << 10) | (MEMTYPE << 8) | ADRM_EXT_S_BM)
#define	D64_MOD		((TT_D64 << 10) | (MEMTYPE << 8) | ADRM_EXT_S_D64)
#define	SHIO_MOD	((TT_NORMAL << 10) | (MEMT_SHIO << 8) | ADRM_SHT_N_IO)
d702 1
a702 1
#endif	/* _MVME328_REG_H_ */
@


1.1
log
@Added vme bus device drivers. MVME328, MVME376, MVME332
@
text
@d1 1
a1 1
/*	$OpenBSD: vsreg.h,v 1.0 1999/05/01 05:52:31 smurph Exp $ */
d41 1
d165 46
d438 1
d463 1
a463 2
    volatile u_short      iopb_RES2;      /* IOPB Reserved word */
    volatile u_short      iopb_RES3;      /* IOPB Reserved word */
d481 1
a481 2
    volatile u_short      iopb_RES2;      /* IOPB Reserved word */
    volatile u_short      iopb_RES3;      /* IOPB Reserved word */
d645 1
d741 14
@

