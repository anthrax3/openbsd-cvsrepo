head	1.22;
access;
symbols
	OPENBSD_5_5:1.21.0.16
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.12
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.10
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.8
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.6
	OPENBSD_5_0:1.21.0.4
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.2
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.20.0.6
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.4
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.19.0.6
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.4
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.2
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.18.0.6
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.4
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.2
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.17.0.8
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.6
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.4
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.9
	UBC:1.7.0.2
	UBC_BASE:1.7
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.1.0.12
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_8:1.1.0.10
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.8
	OPENBSD_2_7_BASE:1.1
	SMP:1.1.0.6
	SMP_BASE:1.1
	kame_19991208:1.1
	OPENBSD_2_6:1.1.0.4
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.2
	OPENBSD_2_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.22
date	2014.03.18.22.36.36;	author miod;	state dead;
branches;
next	1.21;

1.21
date	2010.12.26.15.40.59;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.19;

1.19
date	2007.12.20.05.19.38;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2006.04.26.21.09.48;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2004.04.24.19.51.48;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2004.04.15.21.35.59;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2004.01.14.20.50.48;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2004.01.05.20.06.59;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2004.01.01.19.59.22;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2004.01.01.01.51.32;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2003.10.11.22.08.57;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.02.07.06.56;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.04.28.15.17.09;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.39;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.12.19.07.04.41;	author smurph;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.12.16.23.49.46;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2001.12.13.08.55.51;	author smurph;	state Exp;
branches;
next	1.4;

1.4
date	2001.11.06.19.53.15;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.01.12.13.46;	author art;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.14.21.30.34;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	98.12.15.05.52.31;	author smurph;	state Exp;
branches
	1.1.6.1;
next	;

1.1.6.1
date	2001.07.04.10.19.56;	author niklas;	state Exp;
branches;
next	1.1.6.2;

1.1.6.2
date	2001.11.13.21.04.14;	author niklas;	state Exp;
branches;
next	1.1.6.3;

1.1.6.3
date	2002.03.06.02.04.44;	author niklas;	state Exp;
branches;
next	1.1.6.4;

1.1.6.4
date	2002.03.28.10.36.02;	author niklas;	state Exp;
branches;
next	1.1.6.5;

1.1.6.5
date	2003.03.27.23.32.18;	author niklas;	state Exp;
branches;
next	1.1.6.6;

1.1.6.6
date	2003.06.07.11.13.16;	author ho;	state Exp;
branches;
next	1.1.6.7;

1.1.6.7
date	2004.02.19.10.49.06;	author niklas;	state Exp;
branches;
next	1.1.6.8;

1.1.6.8
date	2004.06.05.23.09.49;	author niklas;	state Exp;
branches;
next	;

1.7.2.1
date	2002.06.11.03.37.10;	author art;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: sram.c,v 1.21 2010/12/26 15:40:59 miod Exp $ */

/*
 * Copyright (c) 1995 Theo de Raadt
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/ioctl.h>
#include <sys/buf.h>
#include <sys/systm.h>
#include <sys/uio.h>
#include <sys/malloc.h>
#include <sys/device.h>

#include <machine/autoconf.h>
#include <machine/conf.h>
#include <machine/cpu.h>
#include <machine/mioctl.h>

#include <mvme88k/dev/memdevs.h>

#include <uvm/uvm_extern.h>

struct sramsoftc {
	struct device		sc_dev;
	paddr_t			sc_base;
	size_t			sc_len;
	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
};

void sramattach(struct device *, struct device *, void *);
int  srammatch(struct device *, void *, void *);

struct cfattach sram_ca = {
	sizeof(struct sramsoftc), srammatch, sramattach
};

struct cfdriver sram_cd = {
	NULL, "sram", DV_DULL
};

int
srammatch(parent, vcf, args)
	struct device *parent;
	void *vcf, *args;
{
	if (brdtyp != BRD_187 && brdtyp != BRD_8120)	/* The only ones... */
		return (0);

	return (1);
}

void
sramattach(parent, self, args)
	struct device *parent, *self;
	void	*args;
{
	struct confargs *ca = args;
	struct sramsoftc *sc = (struct sramsoftc *)self;
	bus_space_handle_t ioh;

	sc->sc_iot = ca->ca_iot;
	sc->sc_base = ca->ca_paddr;
	sc->sc_len = 128 * 1024;		/* always 128K */

	if (bus_space_map(sc->sc_iot, sc->sc_base, sc->sc_len,
	    BUS_SPACE_MAP_LINEAR, &ioh) != 0) {
		printf(": can't map mem space\n");
		return;
	}

	sc->sc_ioh = ioh;

	printf(": %dKB\n", sc->sc_len / 1024);
}

/*ARGSUSED*/
int
sramopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	if (minor(dev) >= sram_cd.cd_ndevs ||
	    sram_cd.cd_devs[minor(dev)] == NULL)
		return (ENODEV);
	return (0);
}

/*ARGSUSED*/
int
sramclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{

	return (0);
}

/*ARGSUSED*/
int
sramioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	int unit = minor(dev);
	struct sramsoftc *sc = (struct sramsoftc *) sram_cd.cd_devs[unit];
	int error = 0;

	switch (cmd) {
	case MIOCGSIZ:
		*(int *)data = sc->sc_len;
		break;
	default:
		error = ENOTTY;
		break;
	}
	return (error);
}

/*ARGSUSED*/
int
sramrw(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{
	int unit = minor(dev);
	struct sramsoftc *sc = (struct sramsoftc *) sram_cd.cd_devs[unit];

	return memdevrw(bus_space_vaddr(sc->sc_iot, sc->sc_ioh),
	    sc->sc_len, uio, flags);
}

paddr_t
srammmap(dev, off, prot)
	dev_t dev;
	off_t off;
	int prot;
{
	int unit = minor(dev);
	struct sramsoftc *sc = (struct sramsoftc *) sram_cd.cd_devs[unit];

	if (minor(dev) != 0)
		return (-1);

	/* allow access only in RAM */
	if (off < 0 || off >= round_page(sc->sc_len))
		return (-1);
	return (sc->sc_base + off);
}
@


1.21
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d1 1
a1 1
/*	$OpenBSD: sram.c,v 1.20 2009/03/29 21:53:52 sthen Exp $ */
@


1.20
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: sram.c,v 1.19 2007/12/20 05:19:38 miod Exp $ */
d176 1
a176 1
	return (atop(sc->sc_base + off));
@


1.19
log
@Stricter range checks in mmap function.
@
text
@d1 1
a1 1
/*	$OpenBSD: sram.c,v 1.18 2006/04/26 21:09:48 miod Exp $ */
d90 1
a90 1
		printf(": can't map memory!\n");
@


1.18
log
@Define BUS_SPACE_MAP_LINEAR and use it when appropriate. Right now
bus_space_map() always maps everything linear, but this could change
in the future.
@
text
@d1 1
a1 1
/*	$OpenBSD: sram.c,v 1.17 2004/04/24 19:51:48 miod Exp $ */
d174 1
a174 1
	if (off < 0 || off > sc->sc_len)
@


1.17
log
@Preliminary switch to an mvme88k bus_space world. Not all drivers have been
converted yet, and they rely upon some linear mappings provided by bus_space.

In order to not impact performance, almost all the bus_space accesses go
through macros and inline functions. This currently restricts us to D16 and
D32 access modes, which are selected at compilation time. Since there are no
plans to support D8 vme devices in the future, this is acceptable for now.

This makes the "len" locator for vme devices go away, and allows to simplify
some code which was using the pcctwo device, and will now directly access
hardware which is known to exist, rather than wait until the device is
attached.

While there, try to enforce more interrupt vector number checks, since these
changes pointed out that dart(4) had been working correctly so far by sheer
luck only.
@
text
@d1 1
a1 1
/*	$OpenBSD: sram.c,v 1.16 2004/04/15 21:35:59 miod Exp $ */
d88 2
a89 1
	if (bus_space_map(sc->sc_iot, sc->sc_base, sc->sc_len, 0, &ioh) != 0) {
@


1.16
log
@Since *ramread and *ramwrite are the same code, really, factorize them a la
memread/memwrite.
@
text
@d1 1
a1 1
/*	$OpenBSD: sram.c,v 1.15 2004/01/14 20:50:48 miod Exp $ */
d46 5
a50 4
	struct device	sc_dev;
	void *		sc_paddr;
	void *		sc_vaddr;
	int		sc_len;
d69 1
a69 3
	struct confargs *ca = args;

	if (brdtyp != BRD_187 && brdtyp != BRD_8120)	/* The only one... */
d72 1
a72 4
	ca->ca_paddr = (void *)0xffe00000;
	ca->ca_vaddr = (void *)0xffe00000;

	return (!badvaddr((vaddr_t)ca->ca_vaddr, 1));
d82 1
d84 7
a90 10
	switch (brdtyp) {
#ifdef MVME187
	case BRD_187:
	case BRD_8120:
		sc->sc_len = 128*1024;		/* always 128K */
		break;
#endif
	default:
		sc->sc_len = 0;
		break;
d93 1
a93 1
	printf(": len %d", sc->sc_len);
d95 1
a95 7
	sc->sc_paddr = ca->ca_paddr;
	sc->sc_vaddr = mapiodev((void *)sc->sc_paddr, sc->sc_len);
	if (sc->sc_vaddr == NULL) {
		sc->sc_len = 0;
		printf(" -- failed to map");
	}
	printf("\n");
d156 2
a157 1
	return (memdevrw(sc->sc_vaddr, sc->sc_len, uio, flags));
d175 1
a175 1
	return (atop(sc->sc_paddr + off));
@


1.15
log
@Do not fill more than the first three fields of cfdriver structures unless
necessary. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sram.c,v 1.14 2004/01/05 20:06:59 miod Exp $ */
d160 1
a160 14
sramread(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{
	int unit = minor(dev);
	struct sramsoftc *sc = (struct sramsoftc *) sram_cd.cd_devs[unit];

	return (memdevrw(sc->sc_vaddr, sc->sc_len, uio, flags));
}

/*ARGSUSED*/
int
sramwrite(dev, uio, flags)
d184 1
a184 1
	if (off > sc->sc_len)
@


1.14
log
@Stop masquerading the M8120 (no-slot MVME187) as a real MVME187, and keep
its value in brdtyp.

Compensate by checking for BRD_8120 everywhere BRD_187 was checked.
@
text
@d1 1
a1 1
/*	$OpenBSD: sram.c,v 1.13 2004/01/01 19:59:22 miod Exp $ */
d60 1
a60 1
	NULL, "sram", DV_DULL, 0
@


1.13
log
@Oops, commited from the wrong tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: sram.c,v 1.11 2003/10/11 22:08:57 miod Exp $ */
d70 1
a70 1
	if (brdtyp != BRD_187)	/* The only one... */
d90 1
@


1.12
log
@Let this attach correctly.
@
text
@d41 2
a67 1
	struct cfdata *cf = vcf;
a68 1
	int ret;
d76 1
a76 1
	return (!badvaddr(ca->ca_vaddr, 1))
a85 2
	struct mcreg *mc;
	int i;
@


1.11
log
@Nuke trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: sram.c,v 1.10 2003/06/02 07:06:56 deraadt Exp $ */
d76 1
a76 11
	if (ca->ca_vaddr == (void *)-1){
	    if (badvaddr(ca->ca_vaddr, 4) <= 0){
		printf("==> sram: failed physical address check.\n");
		return (0);
	    }
	}
	if (badvaddr(ca->ca_vaddr, 1) <= 0){
	    printf("==> sram: failed virtual address check.\n");
	    return (0);
	}
	return (1);
a89 11
#ifdef MVME167
	case BRD_167:
	case BRD_166:
		sc->sc_len = 128*1024;		/* always 128K */
		break;
#endif
#ifdef MVME177
	case BRD_177:
		sc->sc_len = 128*1024;		/* always 128K */
		break;
#endif
@


1.10
log
@licence cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: sram.c,v 1.9 2002/04/28 15:17:09 miod Exp $ */
d168 1
a168 1
	
@


1.9
log
@Use the prototypes defined via cdev_decl() macros, instead of rolling our
own; thus fix a lot of foo_open(), foo_close() and foo_ioctl() prototypes
in the process.
@
text
@d1 1
a1 1
/*	$OpenBSD: sram.c,v 1.8 2002/03/14 01:26:39 millert Exp $ */
a14 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed under OpenBSD by
 *	Theo de Raadt for Willowglen Singapore.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: sram.c,v 1.7 2001/12/19 07:04:41 smurph Exp $ */
a34 1
#include <sys/conf.h>
d40 1
d42 2
a43 1
#include <sys/device.h>
a44 1
#include <machine/autoconf.h>
d46 1
d140 1
a140 1
sramopen(dev, flag, mode)
d143 1
d153 1
a153 1
sramclose(dev, flag, mode)
d156 1
d165 2
a166 1
	dev_t   dev;
d168 1
a168 1
	int     cmd, flag;
@


1.7
log
@Introduce brdtyp and change what cputyp means.
@
text
@d1 1
a1 1
/*	$OpenBSD: sram.c,v 1.6 2001/12/16 23:49:46 miod Exp $ */
d55 2
a56 2
void sramattach __P((struct device *, struct device *, void *));
int  srammatch __P((struct device *, void *, void *));
@


1.7.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sram.c,v 1.7 2001/12/19 07:04:41 smurph Exp $ */
d35 1
d41 1
d43 1
a43 1

a44 2
#include <machine/conf.h>
#include <machine/cpu.h>
a45 1

d55 2
a56 2
void sramattach(struct device *, struct device *, void *);
int  srammatch(struct device *, void *, void *);
d139 1
a139 1
sramopen(dev, flag, mode, p)
a141 1
	struct proc *p;
d151 1
a151 1
sramclose(dev, flag, mode, p)
a153 1
	struct proc *p;
d162 1
a162 2
	dev_t dev;
	u_long cmd;
d164 1
a164 1
	int flag;
@


1.6
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: sram.c,v 1.4 2001/11/06 19:53:15 miod Exp $ */
d75 1
a75 1
	if (cputyp != CPU_187)
d104 1
a104 1
	switch (cputyp) {
d106 2
a107 2
	case CPU_167:
	case CPU_166:
d112 1
a112 1
	case CPU_177:
d117 1
a117 1
	case CPU_187:
@


1.5
log
@Support for MVME197 completed.  Fix SPL defs.
@
text
@d75 1
a75 1
	if (brdtyp != BRD_187)	/* The only one... */
d104 1
a104 1
	switch (brdtyp) {
d106 2
a107 2
	case BRD_167:
	case BRD_166:
d112 1
a112 1
	case BRD_177:
d117 1
a117 1
	case BRD_187:
@


1.4
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: sram.c,v 1.3 2001/11/01 12:13:46 art Exp $ */
d75 1
a75 1
	if (cputyp != CPU_187)
d104 1
a104 1
	switch (cputyp) {
d106 2
a107 2
	case CPU_167:
	case CPU_166:
d112 1
a112 1
	case CPU_177:
d117 1
a117 1
	case CPU_187:
@


1.3
log
@Change d_mmap in struct cdevsw from:
        int     (*d_mmap)       __P((dev_t, int, int));
to:
	paddr_t	(*d_mmap)	__P((dev_t, off_t, int));

This allows us to mmap devices past 4GB offsets.
@
text
@d1 1
a1 1
/*	$OpenBSD: sram.c,v 1.2 2001/06/14 21:30:34 miod Exp $ */
d46 1
a46 1
#include <vm/vm.h>
@


1.2
log
@Big cleanup of VM issues:
o get rid of m88k_foo macros when there is an mi foo macro
o remove the ability, for the pmap module, to handle a native mmu page
  size different from the vm module page size. This allows some
  optimizations in pmap.c
o remove dead stuff from <machine/vmparam.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: sram.c,v 1.1 1998/12/15 05:52:31 smurph Exp $ */
d208 1
a208 1
int
d211 2
a212 1
	int off, prot;
@


1.1
log
@Commit for the first real OpenBSD mvme88k port.
@
text
@d1 1
a1 1
/*	$OpenBSD: sram.c,v 1.5 1997/11/20 17:02:31 etheisen Exp $ */
d222 1
a222 1
	return (m88k_btop(sc->sc_paddr + off));
@


1.1.6.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: sram.c,v 1.1 1998/12/15 05:52:31 smurph Exp $ */
d222 1
a222 1
	return (atop(sc->sc_paddr + off));
@


1.1.6.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d46 1
a46 1
#include <uvm/uvm_extern.h>
d208 1
a208 1
paddr_t
d211 1
a211 2
	off_t off;
	int prot;
@


1.1.6.3
log
@Merge in trunk
@
text
@d75 1
a75 1
	if (brdtyp != BRD_187)	/* The only one... */
d104 1
a104 1
	switch (brdtyp) {
d106 2
a107 2
	case BRD_167:
	case BRD_166:
d112 1
a112 1
	case BRD_177:
d117 1
a117 1
	case BRD_187:
@


1.1.6.4
log
@Merge in -current from about a week ago
@
text
@d55 2
a56 2
void sramattach(struct device *, struct device *, void *);
int  srammatch(struct device *, void *, void *);
@


1.1.6.5
log
@Sync the SMP branch with 3.3
@
text
@d35 1
d41 1
d43 1
a43 1

a44 2
#include <machine/conf.h>
#include <machine/cpu.h>
a45 1

d139 1
a139 1
sramopen(dev, flag, mode, p)
a141 1
	struct proc *p;
d151 1
a151 1
sramclose(dev, flag, mode, p)
a153 1
	struct proc *p;
d162 1
a162 2
	dev_t dev;
	u_long cmd;
d164 1
a164 1
	int flag;
@


1.1.6.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sram.c,v 1.1.6.5 2003/03/27 23:32:18 niklas Exp $ */
d15 6
@


1.1.6.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a40 2
#include <mvme88k/dev/memdevs.h>

d58 1
a58 1
	NULL, "sram", DV_DULL
d66 1
d68 1
d70 1
a70 1
	if (brdtyp != BRD_187 && brdtyp != BRD_8120)	/* The only one... */
d76 11
a86 1
	return (!badvaddr((vaddr_t)ca->ca_vaddr, 1));
d96 2
d100 11
a112 1
	case BRD_8120:
d168 1
a168 1

@


1.1.6.8
log
@Merge with the trunk
@
text
@d46 4
a49 5
	struct device		sc_dev;
	paddr_t			sc_base;
	size_t			sc_len;
	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
d68 3
a70 1
	if (brdtyp != BRD_187 && brdtyp != BRD_8120)	/* The only ones... */
d73 4
a76 1
	return (1);
a85 1
	bus_space_handle_t ioh;
d87 10
a96 7
	sc->sc_iot = ca->ca_iot;
	sc->sc_base = ca->ca_paddr;
	sc->sc_len = 128 * 1024;		/* always 128K */

	if (bus_space_map(sc->sc_iot, sc->sc_base, sc->sc_len, 0, &ioh) != 0) {
		printf(": can't map memory!\n");
		return;
d99 1
a99 1
	sc->sc_ioh = ioh;
d101 7
a107 1
	printf(": %dKB\n", sc->sc_len / 1024);
d160 14
a173 1
sramrw(dev, uio, flags)
d181 1
a181 2
	return memdevrw(bus_space_vaddr(sc->sc_iot, sc->sc_ioh),
	    sc->sc_len, uio, flags);
d197 1
a197 1
	if (off < 0 || off > sc->sc_len)
d199 1
a199 1
	return (atop(sc->sc_base + off));
@


