head	1.21;
access;
symbols
	OPENBSD_5_5:1.20.0.28
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.24
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.22
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.20
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.18
	OPENBSD_5_0:1.20.0.16
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.14
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.12
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.8
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.10
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.6
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.4
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.17.0.6
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.4
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.16.0.4
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.2
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.15.0.4
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.2
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.6
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	SMP:1.5.0.2
	UBC_SYNC_B:1.6
	UBC:1.4.0.2
	UBC_BASE:1.4;
locks; strict;
comment	@ * @;


1.21
date	2014.03.18.22.36.35;	author miod;	state dead;
branches;
next	1.20;

1.20
date	2007.12.13.18.50.10;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2007.12.04.23.45.52;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2007.12.04.05.40.14;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2006.05.08.14.36.10;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2005.07.18.02.43.25;	author fgsch;	state Exp;
branches;
next	1.15;

1.15
date	2004.07.30.19.02.05;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2004.05.07.18.10.28;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2004.04.24.19.51.47;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2004.04.14.13.43.13;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2004.01.14.20.52.52;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2004.01.14.20.50.48;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2003.12.19.22.30.18;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.06.06.31.26;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.02.07.06.56;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.01.26.39;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.05.22.11.37;	author miod;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2001.12.19.07.04.41;	author smurph;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2001.12.19.04.02.25;	author smurph;	state Exp;
branches;
next	1.2;

1.2
date	2001.12.16.23.49.46;	author miod;	state dead;
branches;
next	1.1;

1.1
date	2001.12.13.08.59.38;	author smurph;	state Exp;
branches;
next	;

1.4.2.1
date	2002.06.11.03.37.09;	author art;	state Exp;
branches;
next	;

1.5.2.1
date	2002.03.28.10.36.02;	author niklas;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2003.06.07.11.13.16;	author ho;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2004.02.19.10.49.06;	author niklas;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	2004.06.05.23.09.48;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: bussw.c,v 1.20 2007/12/13 18:50:10 miod Exp $ */
/*
 * Copyright (c) 1999 Steve Murphree, Jr.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/systm.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>

#include <mvme88k/dev/busswreg.h>

struct bussw_softc {
	struct device		sc_dev;
	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
};

void    bussw_attach(struct device *, struct device *, void *);
int     bussw_match(struct device *, void *, void *);

struct cfattach bussw_ca = {
	sizeof(struct bussw_softc), bussw_match, bussw_attach
};

struct cfdriver bussw_cd = {
	NULL, "bussw", DV_DULL
};

int	bussw_print(void *, const char *);
int	bussw_scan(struct device *, void *, void *);

int
bussw_match(parent, vcf, args)
	struct device *parent;
	void *vcf, *args;
{
	struct confargs *ca = args;
	bus_space_handle_t ioh;
	int rc;
	u_int8_t chipid;

	/* Don't match if wrong cpu */
	if (brdtyp != BRD_197)
		return 0;

	if (bus_space_map(ca->ca_iot, ca->ca_paddr, BS_SIZE, 0, &ioh) != 0)
		return 0;
	rc = badaddr((vaddr_t)bus_space_vaddr(ca->ca_iot, ioh), 4);
	if (rc == 0) {
		chipid = bus_space_read_1(ca->ca_iot, ioh, BS_CHIPID);
		if (chipid != BUSSWITCH_ID) {
#ifdef DEBUG
			printf("==> busswitch: wrong chip id %x\n", chipid);
#endif
			rc = -1;
		}
	}
	bus_space_unmap(ca->ca_iot, ioh, BS_SIZE);

	return rc == 0;
}

void
bussw_attach(parent, self, args)
	struct device *parent, *self;
	void *args;
{
	struct confargs *ca = args;
	struct bussw_softc *sc = (struct bussw_softc *)self;
	bus_space_handle_t ioh;
	int i;

	if (bus_space_map(ca->ca_iot, ca->ca_paddr, BS_SIZE, 0, &ioh) != 0) {
		printf(": can't map registers!\n");
		return;
	}

	sc->sc_iot = ca->ca_iot;
	sc->sc_ioh = ioh;

	bus_space_write_1(sc->sc_iot, ioh, BS_VBASE,
	    bus_space_read_1(sc->sc_iot, ioh, BS_VBASE) | BS_VECBASE);

	/* enable external interrupts */
	bus_space_write_2(sc->sc_iot, ioh, BS_GCSR,
	    bus_space_read_2(sc->sc_iot, ioh, BS_GCSR) | BS_GCSR_XIPL);

	/* disable write posting */
	for (i = 0; i < 4; i++)
		bus_space_write_1(sc->sc_iot, ioh, BS_PAR + i,
		    bus_space_read_1(sc->sc_iot, ioh, BS_PAR + i) & ~BS_PAR_WPEN);

	/* enable abort switch */
	bus_space_write_1(sc->sc_iot, ioh, BS_ABORT,
	    bus_space_read_1(sc->sc_iot, ioh, BS_ABORT) | BS_ABORT_IEN);

	printf(": rev %x\n",
	    bus_space_read_1(sc->sc_iot, ioh, BS_CHIPREV));

	config_search(bussw_scan, self, args);
}

int
bussw_print(args, bus)
	void *args;
	const char *bus;
{
	struct confargs *ca = args;

	if (ca->ca_offset != -1)
		printf(" offset 0x%x", ca->ca_offset);
	if (ca->ca_ipl > 0)
		printf(" ipl %d", ca->ca_ipl);
	return (UNCONF);
}

int
bussw_scan(parent, child, args)
	struct device *parent;
	void *child, *args;
{
	struct cfdata *cf = child;
	struct confargs oca, *ca = args;

	bzero(&oca, sizeof oca);
	oca.ca_iot = ca->ca_iot;
	oca.ca_dmat = ca->ca_dmat;
	oca.ca_offset = cf->cf_loc[0];
	oca.ca_ipl = cf->cf_loc[1];
	if (oca.ca_offset != -1) {
		oca.ca_paddr = ca->ca_paddr + oca.ca_offset;
	} else {
		oca.ca_paddr = -1;
	}
	oca.ca_bustype = BUS_BUSSWITCH;
	oca.ca_name = cf->cf_driver->cd_name;
	if ((*cf->cf_attach->ca_match)(parent, cf, &oca) == 0)
		return (0);
	config_attach(parent, cf, &oca, bussw_print);
	return (1);
}
@


1.20
log
@Disable write posting, this does not work on BusSwitch revision #1. The BUG
should do this for us, but better play safe.
@
text
@d1 1
a1 1
/*	$OpenBSD: bussw.c,v 1.19 2007/12/04 23:45:52 miod Exp $ */
@


1.19
log
@Work in progress SMP code for 88110 processor using the BusSwitch chip as
an IPI facility, for MVME197DP.

It's still missing a few remote cache IPIs and IPI do not seem to be reliably
triggered on remote processors at the moment (but this could be a problem
on the board I am currently testing on), at least it will boot multiuser
using only cpu0 to schedule processes.
@
text
@d1 1
a1 1
/*	$OpenBSD: bussw.c,v 1.18 2007/12/04 05:40:14 miod Exp $ */
d96 1
d112 5
@


1.18
log
@Program the abort interrupt source correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: bussw.c,v 1.17 2006/05/08 14:36:10 miod Exp $ */
a38 1
	struct intrhand 	sc_abih;	/* `abort' switch */
a55 2
int	busswabort(void *);
int	busswintr_establish(int, struct intrhand *, const char *);
d107 2
d112 1
a112 9
	/*
	 * pseudo driver, abort interrupt handler
	 */
	sc->sc_abih.ih_fn = busswabort;
	sc->sc_abih.ih_arg = 0;
	sc->sc_abih.ih_wantframe = 1;
	sc->sc_abih.ih_ipl = IPL_NMI;

	busswintr_establish(BS_ABORTIRQ, &sc->sc_abih, "abort");
a159 30
}

int
busswintr_establish(int vec, struct intrhand *ih, const char *name)
{
#ifdef DIAGNOSTIC
	if (vec < 0 || vec >= BS_NVEC)
		panic("busswintr_establish: illegal vector 0x%x", vec);
#endif

	return intr_establish(BS_VECBASE + vec, ih, name);
}

int
busswabort(eframe)
	void *eframe;
{
	struct frame *frame = eframe;

	struct bussw_softc *sc = (struct bussw_softc *)bussw_cd.cd_devs[0];
	u_int8_t abort;

	abort = bus_space_read_1(sc->sc_iot, sc->sc_ioh, BS_ABORT);
	if (abort & BS_ABORT_INT) {
		bus_space_write_1(sc->sc_iot, sc->sc_ioh, BS_ABORT,
		    abort | BS_ABORT_ICLR);
		nmihand(frame);
		return 1;
	}
	return 0;
@


1.17
log
@Replace gazillions of badvaddr() or badwordaddr() calls with badaddr() calls.
With a few prototype declarations shuffling, this finally allows
<machine/locore.h> to die.
@
text
@d1 1
a1 1
/*	$OpenBSD: bussw.c,v 1.16 2005/07/18 02:43:25 fgsch Exp $ */
d123 1
a123 1
	    bus_space_read_4(sc->sc_iot, ioh, BS_ABORT) | BS_ABORT_IEN);
@


1.16
log
@remove trailing newline in panic(9); ok millert@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bussw.c,v 1.15 2004/07/30 19:02:05 miod Exp $ */
a28 1
#include <sys/ioctl.h>
d31 1
a31 3
#include <sys/uio.h>
#include <sys/malloc.h>
#include <machine/psl.h>
a33 2
#include <machine/mioctl.h>
#include <machine/vmparam.h>
d76 1
a76 1
	rc = badvaddr((vaddr_t)bus_space_vaddr(ca->ca_iot, ioh), 4);
@


1.15
log
@Move evcount structures inside struct intrhand, this makes more sense and
gives us more counters in the process.

Also clean up intrhand structures and usage, especially move them to SLISTs.
@
text
@d1 1
a1 1
/*	$OpenBSD: bussw.c,v 1.14 2004/05/07 18:10:28 miod Exp $ */
d181 1
a181 1
		panic("busswintr_establish: illegal vector 0x%x\n", vec);
@


1.14
log
@bus_dma(9) implementation for mvme88k, mostly based upon powerpc.
@
text
@d1 1
a1 1
/*	$OpenBSD: bussw.c,v 1.13 2004/04/24 19:51:47 miod Exp $ */
d63 1
a63 1
int	busswintr_establish(int, struct intrhand *);
d126 1
a126 1
	busswintr_establish(BS_ABORTIRQ, &sc->sc_abih);
d177 1
a177 3
busswintr_establish(vec, ih)
	int vec;
	struct intrhand *ih;
d184 1
a184 1
	return (intr_establish(BS_VECBASE + vec, ih));
@


1.13
log
@Preliminary switch to an mvme88k bus_space world. Not all drivers have been
converted yet, and they rely upon some linear mappings provided by bus_space.

In order to not impact performance, almost all the bus_space accesses go
through macros and inline functions. This currently restricts us to D16 and
D32 access modes, which are selected at compilation time. Since there are no
plans to support D8 vme devices in the future, this is acceptable for now.

This makes the "len" locator for vme devices go away, and allows to simplify
some code which was using the pcctwo device, and will now directly access
hardware which is known to exist, rather than wait until the device is
attached.

While there, try to enforce more interrupt vector number checks, since these
changes pointed out that dart(4) had been working correctly so far by sheer
luck only.
@
text
@d1 1
a1 1
/*	$OpenBSD: bussw.c,v 1.12 2004/04/14 13:43:13 miod Exp $ */
a43 1
	paddr_t			sc_base;
a111 1
	sc->sc_base = ca->ca_paddr;
d156 1
a156 2
	struct bussw_softc *sc = (struct bussw_softc *)parent;
	struct confargs oca;
d159 2
a160 1
	oca.ca_iot = sc->sc_iot;
d164 1
a164 1
		oca.ca_paddr = sc->sc_base + oca.ca_offset;
@


1.12
log
@Remove unused softc members.
@
text
@d1 1
a1 2
/*	$OpenBSD: bussw.c,v 1.11 2004/01/14 20:52:52 miod Exp $ */

a40 1
#include <mvme88k/dev/busswfunc.h>
d44 1
a44 2
	void *			sc_paddr;
	void *			sc_vaddr;
d46 2
a47 1
	struct bussw_reg        *sc_bussw;
d61 4
a64 3
int bussw_print(void *args, const char *bus);
int bussw_scan(struct device *parent, void *child, void *args);
int busswabort(void *);
d72 3
a74 1
	struct bussw_reg *bussw;
d78 1
a78 1
		return (0);
d80 13
a92 3
	bussw = (struct bussw_reg *)(IIOV(ca->ca_paddr));
	if (badvaddr((vaddr_t)bussw, 4))
		return (0);
d94 1
a94 1
	return (1);
d104 15
a118 1
        struct bussw_reg *bs;
a119 4
	sc->sc_vaddr = sc->sc_paddr = ca->ca_paddr;
	bs = sc->sc_bussw = (struct bussw_reg *)sc->sc_vaddr;
	bs->bs_intr2 |= BS_VECBASE;
	bs->bs_gcsr |= BS_GCSR_XIPL;
d122 1
a122 1
   */
d126 2
a127 1
	sc->sc_abih.ih_ipl = IPL_NMI;	/* level 8!! */
d129 5
a133 1
	bs->bs_intr1 |= BS_INTR1_ABORT_IEN;
a134 1
	printf(": rev %ld\n", BS_CHIPREV(bs));
d162 1
d165 2
a166 3
	if (((int)oca.ca_offset != -1) && ISIIOVA(sc->sc_vaddr + oca.ca_offset)) {
		oca.ca_vaddr = sc->sc_vaddr + oca.ca_offset;
		oca.ca_paddr = sc->sc_paddr + oca.ca_offset;
d168 1
a168 2
		oca.ca_vaddr = (void *)-1;
		oca.ca_paddr = (void *)-1;
a170 1
	oca.ca_master = (void *)sc->sc_bussw;
d183 6
a188 5
	if (vec >= BS_NVEC) {
		printf("bussw: illegal vector: 0x%x\n", vec);
		panic("busswintr_establish");
	}
	return (intr_establish(BS_VECBASE+vec, ih));
d198 1
a198 1
        struct bussw_reg *bs  = sc->sc_bussw;
d200 4
a203 2
	if (bs->bs_intr1 & BS_INTR1_ABORT_INT) {
		bs->bs_intr1 |= BS_INTR1_ABORT_ICLR;
a208 1

@


1.11
log
@mvme* do not support buses with indirect configuration, so don't check and
mourn for this.
@
text
@d1 1
a1 1
/*	$OpenBSD: bussw.c,v 1.10 2004/01/14 20:50:48 miod Exp $ */
d46 3
a48 4
	void *		sc_paddr;
	void *		sc_vaddr;
	int		sc_len;
	struct intrhand sc_abih;	/* `abort' switch */
d92 1
a92 1
	struct bussw_softc      *sc = (struct bussw_softc *)self;
@


1.10
log
@Do not fill more than the first three fields of cfdriver structures unless
necessary. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: bussw.c,v 1.9 2003/12/19 22:30:18 miod Exp $ */
a135 5

	if (parent->dv_cfdata->cf_driver->cd_indirect) {
		printf(" indirect devices not supported\n");
		return 0;
	}
@


1.9
log
@Pass -Wformat, and silence a few vme* debug printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: bussw.c,v 1.8 2003/10/06 06:31:26 miod Exp $ */
d61 1
a61 1
	NULL, "bussw", DV_DULL, 0
@


1.8
log
@More vm_offset_t removal I forgot to check in; spotted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bussw.c,v 1.7 2003/06/02 07:06:56 deraadt Exp $ */
d110 1
a110 1
	printf(": rev %d\n", BS_CHIPREV(bs));
@


1.7
log
@licence cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: bussw.c,v 1.6 2002/03/14 01:26:39 millert Exp $ */
d5 1
a5 1
 * 
d56 1
a56 1
struct cfattach bussw_ca = { 
d58 2
a59 2
}; 
 
d75 1
d77 3
a79 2
	if (brdtyp != BRD_197) return (0);	/* The only one... */
	
d81 3
a83 4
	if (badvaddr((vm_offset_t)bussw, 4)) {
	    printf("==> busswitch: failed address check.\n");
	    return (0);
	}
d181 1
a181 1
	
@


1.6
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: bussw.c,v 1.5 2002/03/05 22:11:37 miod Exp $ */
a13 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Theo de Raadt for Willowglen Singapore.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.5
log
@Kill prom stuff duplicates from bugio.[ch].
@
text
@d1 1
a1 1
/*	$OpenBSD: bussw.c,v 1.4 2001/12/19 07:04:41 smurph Exp $ */
d59 2
a60 2
void    bussw_attach    __P((struct device *, struct device *, void *));
int     bussw_match __P((struct device *, void *, void *));
d70 3
a72 3
int bussw_print __P((void *args, const char *bus));
int bussw_scan __P((struct device *parent, void *child, void *args));
int busswabort __P((void *));
@


1.5.2.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d59 2
a60 2
void    bussw_attach(struct device *, struct device *, void *);
int     bussw_match(struct device *, void *, void *);
d70 3
a72 3
int bussw_print(void *args, const char *bus);
int bussw_scan(struct device *parent, void *child, void *args);
int busswabort(void *);
@


1.5.2.2
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bussw.c,v 1.5.2.1 2002/03/28 10:36:02 niklas Exp $ */
d14 6
@


1.5.2.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d5 1
a5 1
 *
d56 1
a56 1
struct cfattach bussw_ca = {
d58 2
a59 2
};

d61 1
a61 1
	NULL, "bussw", DV_DULL
a74 1

d76 2
a77 3
	if (brdtyp != BRD_197)
		return (0);

d79 4
a82 3
	if (badvaddr((vaddr_t)bussw, 4))
		return (0);

d109 1
a109 1
	printf(": rev %ld\n", BS_CHIPREV(bs));
d136 5
d180 1
a180 1

@


1.5.2.4
log
@Merge with the trunk
@
text
@d2 1
d42 1
d46 5
a50 3
	struct intrhand 	sc_abih;	/* `abort' switch */
	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
d64 3
a66 4
int	bussw_print(void *, const char *);
int	bussw_scan(struct device *, void *, void *);
int	busswabort(void *);
int	busswintr_establish(int, struct intrhand *);
d74 1
a74 3
	bus_space_handle_t ioh;
	int rc;
	u_int8_t chipid;
d78 1
a78 1
		return 0;
d80 3
a82 13
	if (bus_space_map(ca->ca_iot, ca->ca_paddr, BS_SIZE, 0, &ioh) != 0)
		return 0;
	rc = badvaddr((vaddr_t)bus_space_vaddr(ca->ca_iot, ioh), 4);
	if (rc == 0) {
		chipid = bus_space_read_1(ca->ca_iot, ioh, BS_CHIPID);
		if (chipid != BUSSWITCH_ID) {
#ifdef DEBUG
			printf("==> busswitch: wrong chip id %x\n", chipid);
#endif
			rc = -1;
		}
	}
	bus_space_unmap(ca->ca_iot, ioh, BS_SIZE);
d84 1
a84 1
	return rc == 0;
d93 2
a94 15
	struct bussw_softc *sc = (struct bussw_softc *)self;
	bus_space_handle_t ioh;

	if (bus_space_map(ca->ca_iot, ca->ca_paddr, BS_SIZE, 0, &ioh) != 0) {
		printf(": can't map registers!\n");
		return;
	}

	sc->sc_iot = ca->ca_iot;
	sc->sc_ioh = ioh;

	bus_space_write_1(sc->sc_iot, ioh, BS_VBASE,
	    bus_space_read_1(sc->sc_iot, ioh, BS_VBASE) | BS_VECBASE);
	bus_space_write_2(sc->sc_iot, ioh, BS_GCSR,
	    bus_space_read_2(sc->sc_iot, ioh, BS_GCSR) | BS_GCSR_XIPL);
d96 4
d102 1
a102 1
	 */
d106 1
a106 2
	sc->sc_abih.ih_ipl = IPL_NMI;

d108 1
a108 5
	bus_space_write_1(sc->sc_iot, ioh, BS_ABORT,
	    bus_space_read_4(sc->sc_iot, ioh, BS_ABORT) | BS_ABORT_IEN);

	printf(": rev %x\n",
	    bus_space_read_1(sc->sc_iot, ioh, BS_CHIPREV));
d110 1
d134 2
a135 1
	struct confargs oca, *ca = args;
a137 2
	oca.ca_iot = ca->ca_iot;
	oca.ca_dmat = ca->ca_dmat;
d140 3
a142 2
	if (oca.ca_offset != -1) {
		oca.ca_paddr = ca->ca_paddr + oca.ca_offset;
d144 2
a145 1
		oca.ca_paddr = -1;
d148 1
d161 5
a165 6
#ifdef DIAGNOSTIC
	if (vec < 0 || vec >= BS_NVEC)
		panic("busswintr_establish: illegal vector 0x%x\n", vec);
#endif

	return (intr_establish(BS_VECBASE + vec, ih));
d175 1
a175 1
	u_int8_t abort;
d177 2
a178 4
	abort = bus_space_read_1(sc->sc_iot, sc->sc_ioh, BS_ABORT);
	if (abort & BS_ABORT_INT) {
		bus_space_write_1(sc->sc_iot, sc->sc_ioh, BS_ABORT,
		    abort | BS_ABORT_ICLR);
d184 1
@


1.4
log
@Introduce brdtyp and change what cputyp means.
@
text
@d1 1
a1 1
/*	$OpenBSD: bussw.c,v 1.3 2001/12/19 04:02:25 smurph Exp $ */
a42 1
#include <machine/bugio.h>
@


1.4.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bussw.c,v 1.4 2001/12/19 07:04:41 smurph Exp $ */
d43 1
d60 2
a61 2
void    bussw_attach(struct device *, struct device *, void *);
int     bussw_match(struct device *, void *, void *);
d71 3
a73 3
int bussw_print(void *args, const char *bus);
int bussw_scan(struct device *parent, void *child, void *args);
int busswabort(void *);
@


1.3
log
@bus switch name shortened.  Added register definitons and functionality.
@
text
@d1 1
a1 1
/*	$OpenBSD: busswitch.c,v 1.6 2001/12/16 23:49:46 miod Exp $ */
d82 2
a83 2
   /* Don't match if wrong cpu */
	if (cputyp != CPU_197) return (0);
@


1.2
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: bussw.c,v 1.1 2001/12/13 08:59:38 smurph Exp $ */
d52 4
a55 4
	struct device   sc_dev;
	void            *sc_paddr;
	void            *sc_vaddr;
	int             sc_len;
d66 1
a66 1

d77 2
a78 2
struct device *parent;
void *vcf, *args;
d82 3
a84 4
	/* Don't match if wrong cpu */
	if (brdtyp != BRD_197) 
		return (0);  /* The only one... */

d87 2
a88 2
		printf("==> busswitch: failed address check.\n");
		return (0);
d95 2
a96 2
struct device *parent, *self;
void *args;
d106 1
a106 1
	/* 
d108 1
a108 1
	 */
d122 2
a123 2
void *args;
const char *bus;
d136 2
a137 2
struct device *parent;
void *child, *args;
@


1.1
log
@Support for MVME917 complete.
@
text
@d1 1
a1 1
/*	$OpenBSD: busswitch.c,v 1.4 2001/03/09 05:44:38 smurph Exp $ */
@

