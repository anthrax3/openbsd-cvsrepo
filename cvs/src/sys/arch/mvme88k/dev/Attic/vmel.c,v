head	1.21;
access;
symbols
	OPENBSD_5_5:1.20.0.14
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.10
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.8
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.6
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.4
	OPENBSD_5_0:1.20.0.2
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.19.0.2
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.18.0.2
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.16.0.16
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.18
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.14
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.12
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.10
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.8
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.6
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.4
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.15.0.6
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.4
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.2
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.10
	UBC:1.7.0.2
	UBC_BASE:1.7
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.2.0.10
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.8
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.6
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.1.1.1.0.8
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.6
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.4
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.2
	OPENBSD_2_1_BASE:1.1.1.1
	mvme88kport:1.1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2014.03.18.22.36.36;	author miod;	state dead;
branches;
next	1.20;

1.20
date	2011.04.07.15.30.15;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2010.12.26.15.40.59;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2010.06.27.12.41.23;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2010.06.26.23.24.44;	author guenther;	state Exp;
branches;
next	1.16;

1.16
date	2005.11.25.22.14.32;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2004.04.24.19.51.48;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2004.01.14.20.50.48;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2003.12.28.19.44.26;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2003.12.19.22.30.18;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.04.04.11.37;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.28.15.17.09;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.03.15.57;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.39;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.07.22.31.57;	author miod;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.11.01.12.13.46;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.26.02.37.07;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.14.21.30.35;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.09.05.44.39;	author smurph;	state Exp;
branches;
next	1.2;

1.2
date	98.12.15.05.52.31;	author smurph;	state Exp;
branches
	1.2.6.1;
next	1.1;

1.1
date	97.03.03.19.32.04;	author rahnds;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.03.03.19.32.04;	author rahnds;	state Exp;
branches;
next	;

1.2.6.1
date	2001.04.18.16.11.06;	author niklas;	state Exp;
branches;
next	1.2.6.2;

1.2.6.2
date	2001.07.04.10.19.57;	author niklas;	state Exp;
branches;
next	1.2.6.3;

1.2.6.3
date	2001.10.31.03.01.18;	author nate;	state Exp;
branches;
next	1.2.6.4;

1.2.6.4
date	2001.11.13.21.04.14;	author niklas;	state Exp;
branches;
next	1.2.6.5;

1.2.6.5
date	2002.03.28.10.36.02;	author niklas;	state Exp;
branches;
next	1.2.6.6;

1.2.6.6
date	2003.03.27.23.32.18;	author niklas;	state Exp;
branches;
next	1.2.6.7;

1.2.6.7
date	2003.06.07.11.13.17;	author ho;	state Exp;
branches;
next	1.2.6.8;

1.2.6.8
date	2004.02.19.10.49.06;	author niklas;	state Exp;
branches;
next	1.2.6.9;

1.2.6.9
date	2004.06.05.23.09.49;	author niklas;	state Exp;
branches;
next	;

1.7.2.1
date	2002.06.11.03.37.10;	author art;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: vmel.c,v 1.20 2011/04/07 15:30:15 miod Exp $ */

/*
 * Copyright (c) 1995 Theo de Raadt
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/conf.h>
#include <machine/cpu.h>

#include <mvme88k/dev/vme.h>

/*
 * The VMEL driver deals with D32 transfers on the VME bus. The number
 * of address bits (A16, A24, A32) is irrelevant since the mapping
 * functions will decide how many address bits are relevant.
 */

void	vmelattach(struct device *, struct device *, void *);
int	vmelmatch(struct device *, void *, void *);
int	vmelscan(struct device *, void *, void *);

struct cfattach vmel_ca = {
        sizeof(struct device), vmelmatch, vmelattach
};

struct cfdriver vmel_cd = {
        NULL, "vmel", DV_DULL
};

int
vmelmatch(parent, cf, args)
	struct device *parent;
	void *cf, *args;
{
	return (1);
}

int
vmelscan(parent, child, args)
	struct device *parent;
	void *child, *args;
{
	return (vmescan(parent, child, args, BUS_VMEL));
}

void
vmelattach(parent, self, args)
	struct device *parent, *self;
	void *args;
{
	printf("\n");

	config_search(vmelscan, self, args);
}

/*ARGSUSED*/
int
vmelopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	if (minor(dev) >= vmel_cd.cd_ndevs ||
	    vmel_cd.cd_devs[minor(dev)] == NULL)
		return (ENODEV);
	return (0);
}

/*ARGSUSED*/
int
vmelclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{

	return (0);
}

/*ARGSUSED*/
int
vmelioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	int error = 0;

	switch (cmd) {
	default:
		error = ENOTTY;
		break;
	}
	return (error);
}

int
vmelread(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{
	int unit = minor(dev);
	struct device *sc = (struct device *)vmel_cd.cd_devs[unit];

	return (vmerw(sc->dv_parent, uio, flags, BUS_VMEL));
}

int
vmelwrite(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{
	int unit = minor(dev);
	struct device *sc = (struct device *)vmel_cd.cd_devs[unit];

	return (vmerw(sc->dv_parent, uio, flags, BUS_VMEL));
}

paddr_t
vmelmmap(dev, off, prot)
	dev_t dev;
	off_t off;
	int prot;
{
	int unit = minor(dev);
	struct device *sc = (struct device *)vmel_cd.cd_devs[unit];
	paddr_t pa;

	pa = vmepmap(sc->dv_parent, off, BUS_VMEL);
#ifdef DEBUG
	printf("vmel %llx pa %p\n", off, pa);
#endif
	if (pa == 0)
		return (-1);
	return (pa);
}
@


1.20
log
@Do not use NULL in integer comparisons. No functional change.
ok matthew@@ tedu@@, also eyeballed by at least krw@@ oga@@ kettenis@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmel.c,v 1.19 2010/12/26 15:40:59 miod Exp $ */
@


1.19
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmel.c,v 1.18 2010/06/27 12:41:23 miod Exp $ */
d167 1
a167 1
	if (pa == NULL)
@


1.18
log
@Bunch of include adjustements to restore compilability.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmel.c,v 1.17 2010/06/26 23:24:44 guenther Exp $ */
d169 1
a169 1
	return (atop(pa));
@


1.17
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmel.c,v 1.16 2005/11/25 22:14:32 miod Exp $ */
d33 2
@


1.16
log
@Prefer vaddr_t and paddr_t types, instead of void * and heavy casts.
Improves readability, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmel.c,v 1.15 2004/04/24 19:51:48 miod Exp $ */
a29 1
#include <sys/user.h>
@


1.15
log
@Preliminary switch to an mvme88k bus_space world. Not all drivers have been
converted yet, and they rely upon some linear mappings provided by bus_space.

In order to not impact performance, almost all the bus_space accesses go
through macros and inline functions. This currently restricts us to D16 and
D32 access modes, which are selected at compilation time. Since there are no
plans to support D8 vme devices in the future, this is acceptable for now.

This makes the "len" locator for vme devices go away, and allows to simplify
some code which was using the pcctwo device, and will now directly access
hardware which is known to exist, rather than wait until the device is
attached.

While there, try to enforce more interrupt vector number checks, since these
changes pointed out that dart(4) had been working correctly so far by sheer
luck only.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmel.c,v 1.14 2004/01/14 20:50:48 miod Exp $ */
d160 1
a160 1
	void * pa;
@


1.14
log
@Do not fill more than the first three fields of cfdriver structures unless
necessary. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmel.c,v 1.13 2003/12/28 19:44:26 miod Exp $ */
d47 3
a49 2
void vmelattach(struct device *, struct device *, void *);
int  vmelmatch(struct device *, void *, void *);
a58 2
int vmelscan(struct device *, void *, void *);

d162 1
a162 1
	pa = vmepmap(sc->dv_parent, off, NBPG, BUS_VMEL);
@


1.13
log
@Having vmel and vmes keep another pointer to their parent in their softc is
just plain silly!
@
text
@d1 1
a1 1
/*	$OpenBSD: vmel.c,v 1.12 2003/12/19 22:30:18 miod Exp $ */
d55 1
a55 1
        NULL, "vmel", DV_DULL, 0
@


1.12
log
@Pass -Wformat, and silence a few vme* debug printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmel.c,v 1.11 2003/06/04 04:11:37 deraadt Exp $ */
d51 1
a51 1
        sizeof(struct vmelsoftc), vmelmatch, vmelattach
a80 2
	struct vmelsoftc *sc = (struct vmelsoftc *)self;

a82 2
	sc->sc_vme = (struct vmesoftc *)parent;

d136 1
a136 1
	struct vmelsoftc *sc = (struct vmelsoftc *) vmel_cd.cd_devs[unit];
d138 1
a138 1
	return (vmerw(sc->sc_vme, uio, flags, BUS_VMEL));
d148 1
a148 1
	struct vmelsoftc *sc = (struct vmelsoftc *) vmel_cd.cd_devs[unit];
d150 1
a150 1
	return (vmerw(sc->sc_vme, uio, flags, BUS_VMEL));
d160 1
a160 1
	struct vmelsoftc *sc = (struct vmelsoftc *) vmel_cd.cd_devs[unit];
d163 1
a163 1
	pa = vmepmap(sc->sc_vme, off, NBPG, BUS_VMEL);
@


1.11
log
@more term 3 and 4 changes
@
text
@d1 1
a1 1
/*	$OpenBSD: vmel.c,v 1.10 2002/04/28 15:17:09 miod Exp $ */
d168 3
a170 1
	printf("vmel %x pa %x\n", off, pa);
@


1.10
log
@Use the prototypes defined via cdev_decl() macros, instead of rolling our
own; thus fix a lot of foo_open(), foo_close() and foo_ioctl() prototypes
in the process.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmel.c,v 1.9 2002/03/14 03:15:57 millert Exp $ */
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Theo de Raadt
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.9
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: vmel.c,v 1.8 2002/03/14 01:26:39 millert Exp $ */
a33 1
#include <sys/conf.h>
d40 2
d43 1
a43 1
#include <machine/autoconf.h>
a63 6
int vmelopen(dev_t, int, int);
int vmelclose(dev_t, int, int);
int vmelioctl(dev_t, int, caddr_t, int, struct proc *);
int vmelread(dev_t, struct uio *, int);
int vmelwrite(dev_t, struct uio *, int);
paddr_t vmelmmap(dev_t, off_t, int);
d97 1
a97 1
vmelopen(dev, flag, mode)
d100 1
d110 1
a110 1
vmelclose(dev, flag, mode)
d113 1
d122 2
a123 1
	dev_t   dev;
d125 1
a125 1
	int     cmd, flag;
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: vmel.c,v 1.7 2001/11/07 22:31:57 miod Exp $ */
d62 1
a62 1
int vmelscan(struct device *, void *, void*);
@


1.7
log
@post-mmap API change fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmel.c,v 1.6 2001/11/01 12:13:46 art Exp $ */
d51 2
a52 2
void vmelattach __P((struct device *, struct device *, void *));
int  vmelmatch __P((struct device *, void *, void *));
d62 7
a68 7
int vmelscan __P((struct device *, void *, void*));
int vmelopen __P((dev_t, int, int));
int vmelclose __P((dev_t, int, int));
int vmelioctl __P((dev_t, int, caddr_t, int, struct proc *));
int vmelread __P((dev_t, struct uio *, int));
int vmelwrite __P((dev_t, struct uio *, int));
paddr_t vmelmmap __P((dev_t, off_t, int));
@


1.7.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vmel.c,v 1.7 2001/11/07 22:31:57 miod Exp $ */
d34 1
d41 1
a42 3
#include <machine/conf.h>
#include <machine/cpu.h>

d51 2
a52 2
void vmelattach(struct device *, struct device *, void *);
int  vmelmatch(struct device *, void *, void *);
d62 7
a68 1
int vmelscan(struct device *, void *, void *);
d102 1
a102 1
vmelopen(dev, flag, mode, p)
a104 1
	struct proc *p;
d114 1
a114 1
vmelclose(dev, flag, mode, p)
a116 1
	struct proc *p;
d125 1
a125 2
	dev_t dev;
	u_long cmd;
d127 1
a127 1
	int flag;
@


1.6
log
@Change d_mmap in struct cdevsw from:
        int     (*d_mmap)       __P((dev_t, int, int));
to:
	paddr_t	(*d_mmap)	__P((dev_t, off_t, int));

This allows us to mmap devices past 4GB offsets.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmel.c,v 1.5 2001/08/26 02:37:07 miod Exp $ */
d174 1
a174 1
	pa = vmepmap(sc->sc_vme, (void *)off, NBPG, BUS_VMEL);
@


1.5
log
@Add prototypes, fix compilation warnings, random style fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmel.c,v 1.4 2001/06/14 21:30:35 miod Exp $ */
d68 1
a68 1
int vmelmmap __P((dev_t, int, int));
d164 1
a164 1
int
d167 2
a168 1
	int off, prot;
@


1.4
log
@Big cleanup of VM issues:
o get rid of m88k_foo macros when there is an mi foo macro
o remove the ability, for the pmap module, to handle a native mmu page
  size different from the vm module page size. This allows some
  optimizations in pmap.c
o remove dead stuff from <machine/vmparam.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: vmel.c,v 1.3 2001/03/09 05:44:39 smurph Exp $ */
d61 8
@


1.3
log
@kernel will compile with -Werror.  Added intr.h
@
text
@d1 1
a1 1
/*	$OpenBSD: vmel.c,v 1.2 1998/12/15 05:52:31 smurph Exp $ */
d40 1
d169 1
a169 1
	return (m88k_btop(pa));
@


1.2
log
@Commit for the first real OpenBSD mvme88k port.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmel.c,v 1.9 1998/01/19 00:13:04 etheisen Exp $ */
a120 2
	int unit = minor(dev);
	struct vmelsoftc *sc = (struct vmelsoftc *) vmel_cd.cd_devs[unit];
@


1.2.6.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmel.c,v 1.3 2001/03/09 05:44:39 smurph Exp $ */
d121 2
@


1.2.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmel.c,v 1.2.6.1 2001/04/18 16:11:06 niklas Exp $ */
a39 1

d168 1
a168 1
	return (atop(pa));
@


1.2.6.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: vmel.c,v 1.2.6.2 2001/07/04 10:19:57 niklas Exp $ */
a60 8

int vmelscan __P((struct device *, void *, void*));
int vmelopen __P((dev_t, int, int));
int vmelclose __P((dev_t, int, int));
int vmelioctl __P((dev_t, int, caddr_t, int, struct proc *));
int vmelread __P((dev_t, struct uio *, int));
int vmelwrite __P((dev_t, struct uio *, int));
int vmelmmap __P((dev_t, int, int));
@


1.2.6.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d68 1
a68 1
paddr_t vmelmmap __P((dev_t, off_t, int));
d164 1
a164 1
paddr_t
d167 1
a167 2
	off_t off;
	int prot;
d173 1
a173 1
	pa = vmepmap(sc->sc_vme, off, NBPG, BUS_VMEL);
@


1.2.6.5
log
@Merge in -current from about a week ago
@
text
@d51 2
a52 2
void vmelattach(struct device *, struct device *, void *);
int  vmelmatch(struct device *, void *, void *);
d62 7
a68 7
int vmelscan(struct device *, void *, void *);
int vmelopen(dev_t, int, int);
int vmelclose(dev_t, int, int);
int vmelioctl(dev_t, int, caddr_t, int, struct proc *);
int vmelread(dev_t, struct uio *, int);
int vmelwrite(dev_t, struct uio *, int);
paddr_t vmelmmap(dev_t, off_t, int);
@


1.2.6.6
log
@Sync the SMP branch with 3.3
@
text
@d34 1
d41 1
a42 3
#include <machine/conf.h>
#include <machine/cpu.h>

d63 6
d102 1
a102 1
vmelopen(dev, flag, mode, p)
a104 1
	struct proc *p;
d114 1
a114 1
vmelclose(dev, flag, mode, p)
a116 1
	struct proc *p;
d125 1
a125 2
	dev_t dev;
	u_long cmd;
d127 1
a127 1
	int flag;
@


1.2.6.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vmel.c,v 1.2.6.6 2003/03/27 23:32:18 niklas Exp $ */
d15 5
@


1.2.6.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d51 1
a51 1
        sizeof(struct device), vmelmatch, vmelattach
d55 1
a55 1
        NULL, "vmel", DV_DULL
d81 2
d85 2
d140 1
a140 1
	struct device *sc = (struct device *)vmel_cd.cd_devs[unit];
d142 1
a142 1
	return (vmerw(sc->dv_parent, uio, flags, BUS_VMEL));
d152 1
a152 1
	struct device *sc = (struct device *)vmel_cd.cd_devs[unit];
d154 1
a154 1
	return (vmerw(sc->dv_parent, uio, flags, BUS_VMEL));
d164 1
a164 1
	struct device *sc = (struct device *)vmel_cd.cd_devs[unit];
d167 2
a168 4
	pa = vmepmap(sc->dv_parent, off, NBPG, BUS_VMEL);
#ifdef DEBUG
	printf("vmel %llx pa %p\n", off, pa);
#endif
@


1.2.6.9
log
@Merge with the trunk
@
text
@d47 2
a48 3
void	vmelattach(struct device *, struct device *, void *);
int	vmelmatch(struct device *, void *, void *);
int	vmelscan(struct device *, void *, void *);
d58 2
d163 1
a163 1
	pa = vmepmap(sc->dv_parent, off, BUS_VMEL);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD$ */
a52 5
struct vmelsoftc {
	struct device		sc_dev;
	struct vmesoftc		*sc_vme;
};

d164 1
a164 1
	caddr_t pa;
d166 1
a166 1
	pa = vmepmap(sc->sc_vme, (caddr_t)off, NBPG, BUS_VMEL);
@


1.1.1.1
log
@Third try at importing the mvme88k port. This is a working kernel
from nivas.
Userland and compiler still need to be worked on.
Make certain what directory the import is done from.
@
text
@@
