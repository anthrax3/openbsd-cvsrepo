head	1.24;
access;
symbols
	OPENBSD_5_5:1.23.0.14
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.10
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.8
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.6
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.4
	OPENBSD_5_0:1.23.0.2
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.22.0.2
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.21.0.2
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.19.0.16
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.18
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.14
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.12
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.10
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.8
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.6
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.4
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.19.0.2
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.18.0.6
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.4
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.2
	OPENBSD_3_6_BASE:1.18
	SMP_SYNC_A:1.18
	SMP_SYNC_B:1.18
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.10
	UBC:1.7.0.2
	UBC_BASE:1.7
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.2.0.10
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.8
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.6
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.1.1.1.0.8
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.6
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.4
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.2
	OPENBSD_2_1_BASE:1.1.1.1
	mvme88kport:1.1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2014.03.18.22.36.36;	author miod;	state dead;
branches;
next	1.23;

1.23
date	2011.04.07.15.30.15;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2010.12.26.15.40.59;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2010.06.27.12.41.23;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2010.06.26.23.24.44;	author guenther;	state Exp;
branches;
next	1.19;

1.19
date	2005.11.25.22.14.32;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2004.04.24.19.51.48;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2004.01.14.20.50.48;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2003.12.28.19.44.26;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2003.12.27.23.57.06;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2003.12.25.21.01.39;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2003.12.19.22.30.18;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2003.10.11.22.08.57;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.04.04.11.37;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.28.15.17.09;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.03.15.57;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.39;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.07.22.31.57;	author miod;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.11.01.12.13.46;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.26.02.37.07;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.14.21.30.35;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.09.05.44.39;	author smurph;	state Exp;
branches;
next	1.2;

1.2
date	98.12.15.05.52.31;	author smurph;	state Exp;
branches
	1.2.6.1;
next	1.1;

1.1
date	97.03.03.19.32.04;	author rahnds;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.03.03.19.32.04;	author rahnds;	state Exp;
branches;
next	;

1.2.6.1
date	2001.04.18.16.11.07;	author niklas;	state Exp;
branches;
next	1.2.6.2;

1.2.6.2
date	2001.07.04.10.19.58;	author niklas;	state Exp;
branches;
next	1.2.6.3;

1.2.6.3
date	2001.10.31.03.01.18;	author nate;	state Exp;
branches;
next	1.2.6.4;

1.2.6.4
date	2001.11.13.21.04.14;	author niklas;	state Exp;
branches;
next	1.2.6.5;

1.2.6.5
date	2002.03.28.10.36.02;	author niklas;	state Exp;
branches;
next	1.2.6.6;

1.2.6.6
date	2003.03.27.23.32.18;	author niklas;	state Exp;
branches;
next	1.2.6.7;

1.2.6.7
date	2003.06.07.11.13.17;	author ho;	state Exp;
branches;
next	1.2.6.8;

1.2.6.8
date	2004.02.19.10.49.06;	author niklas;	state Exp;
branches;
next	1.2.6.9;

1.2.6.9
date	2004.06.05.23.09.49;	author niklas;	state Exp;
branches;
next	;

1.7.2.1
date	2002.06.11.03.37.10;	author art;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: vmes.c,v 1.23 2011/04/07 15:30:15 miod Exp $ */

/*
 * Copyright (c) 1995 Theo de Raadt
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>

#include <machine/bus.h>
#include <machine/autoconf.h>
#include <machine/conf.h>
#include <machine/cpu.h>

#include <uvm/uvm_extern.h>

#include <mvme88k/dev/vme.h>

/*
 * The VMES driver deals with D16 transfers on the VME bus. The number
 * of address bits (A16, A24, A32) is irrelevant since the mapping
 * functions will decide how many address bits are relevant.
 */

void	vmesattach(struct device *, struct device *, void *);
int	vmesmatch(struct device *, void *, void *);
int	vmesscan(struct device *, void *, void *);

struct cfattach vmes_ca = {
        sizeof(struct device), vmesmatch, vmesattach
};

struct cfdriver vmes_cd = {
        NULL, "vmes", DV_DULL
};

/*
 * Configuration glue
 */

int
vmesmatch(parent, cf, args)
	struct device *parent;
	void *cf, *args;
{
	return (1);
}

int
vmesscan(parent, child, args)
	struct device *parent;
	void *child, *args;
{
	return (vmescan(parent, child, args, BUS_VMES));
}

void
vmesattach(parent, self, args)
	struct device *parent, *self;
	void *args;
{
	printf("\n");

	config_search(vmesscan, self, args);
}

/*ARGSUSED*/
int
vmesopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	if (minor(dev) >= vmes_cd.cd_ndevs ||
	    vmes_cd.cd_devs[minor(dev)] == NULL)
		return (ENODEV);
	return (0);
}

/*ARGSUSED*/
int
vmesclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{

	return (0);
}

/*ARGSUSED*/
int
vmesioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	int error = 0;

	switch (cmd) {
	default:
		error = ENOTTY;
		break;
	}
	return (error);
}

int
vmesread(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{
	int unit = minor(dev);
	struct device *sc = (struct device *)vmes_cd.cd_devs[unit];

	return (vmerw(sc->dv_parent, uio, flags, BUS_VMES));
}

int
vmeswrite(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{
	int unit = minor(dev);
	struct device *sc = (struct device *)vmes_cd.cd_devs[unit];

	return (vmerw(sc->dv_parent, uio, flags, BUS_VMES));
}

paddr_t
vmesmmap(dev, off, prot)
	dev_t dev;
	off_t off;
	int prot;
{
	int unit = minor(dev);
	struct device *sc = (struct device *)vmes_cd.cd_devs[unit];
	paddr_t pa;

	pa = vmepmap(sc->dv_parent, off, BUS_VMES);
#ifdef DEBUG
	printf("vmes %llx pa %p\n", off, pa);
#endif
	if (pa == 0)
		return (-1);
	return (pa);
}
@


1.23
log
@Do not use NULL in integer comparisons. No functional change.
ok matthew@@ tedu@@, also eyeballed by at least krw@@ oga@@ kettenis@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmes.c,v 1.22 2010/12/26 15:40:59 miod Exp $ */
@


1.22
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmes.c,v 1.21 2010/06/27 12:41:23 miod Exp $ */
d172 1
a172 1
	if (pa == NULL)
@


1.21
log
@Bunch of include adjustements to restore compilability.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmes.c,v 1.20 2010/06/26 23:24:44 guenther Exp $ */
d174 1
a174 1
	return (atop(pa));
@


1.20
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmes.c,v 1.19 2005/11/25 22:14:32 miod Exp $ */
d38 2
@


1.19
log
@Prefer vaddr_t and paddr_t types, instead of void * and heavy casts.
Improves readability, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmes.c,v 1.18 2004/04/24 19:51:48 miod Exp $ */
a29 1
#include <sys/user.h>
@


1.18
log
@Preliminary switch to an mvme88k bus_space world. Not all drivers have been
converted yet, and they rely upon some linear mappings provided by bus_space.

In order to not impact performance, almost all the bus_space accesses go
through macros and inline functions. This currently restricts us to D16 and
D32 access modes, which are selected at compilation time. Since there are no
plans to support D8 vme devices in the future, this is acceptable for now.

This makes the "len" locator for vme devices go away, and allows to simplify
some code which was using the pcctwo device, and will now directly access
hardware which is known to exist, rather than wait until the device is
attached.

While there, try to enforce more interrupt vector number checks, since these
changes pointed out that dart(4) had been working correctly so far by sheer
luck only.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmes.c,v 1.17 2004/01/14 20:50:48 miod Exp $ */
d165 1
a165 1
	void * pa;
@


1.17
log
@Do not fill more than the first three fields of cfdriver structures unless
necessary. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmes.c,v 1.16 2003/12/28 19:44:26 miod Exp $ */
d35 1
d48 3
a50 2
void vmesattach(struct device *, struct device *, void *);
int  vmesmatch(struct device *, void *, void *);
d60 3
a62 1
int vmesscan(struct device *, void *, void *);
d167 1
a167 1
	pa = vmepmap(sc->dv_parent, off, NBPG, BUS_VMES);
a173 39
}

/*
 * Specific D16 access functions
 *
 * D16 cards will trigger bus errors on attempting to read or write more
 * than 16 bits on the bus. Given how the m88k processor works, this means
 * basically that all long (D32) accesses must be carefully taken care of.
 *
 * Since the kernels bcopy() and bzero() routines will use 32 bit accesses
 * for performance, here are specific D16-compatible routines. They expect
 * pointers to be 16-bit aligned.
 */

void
d16_bcopy(const void *src, void *dst, size_t len)
{
	const u_int16_t *s = (const u_int16_t *)src;
	u_int16_t *d = (u_int16_t *)dst;
	size_t l = len;

	l >>= 1;
	while (l-- != 0)
		*d++ = *s++;
	if (len & 1)
		*(u_int8_t *)d = *(u_int8_t *)s;
}

void
d16_bzero(void *dst, size_t len)
{
	u_int16_t *d = (u_int16_t *)dst;
	size_t l = len;

	l >>= 1;
	while (l-- != 0)
		*d++ = 0;
	if (len & 1)
		*(u_int8_t *)d = 0;
@


1.16
log
@Having vmel and vmes keep another pointer to their parent in their softc is
just plain silly!
@
text
@d1 1
a1 1
/*	$OpenBSD: vmes.c,v 1.15 2003/12/27 23:57:06 miod Exp $ */
d55 1
a55 1
        NULL, "vmes", DV_DULL, 0
@


1.15
log
@Handle odd sizes in d16_bcopy() and d16_bzero().
@
text
@d1 1
a1 1
/*	$OpenBSD: vmes.c,v 1.14 2003/12/25 21:01:39 miod Exp $ */
d51 1
a51 1
        sizeof(struct vmessoftc), vmesmatch, vmesattach
a80 2
	struct vmessoftc *sc = (struct vmessoftc *)self;

a82 2
	sc->sc_vme = (struct vmesoftc *)parent;

d136 1
a136 1
	struct vmessoftc *sc = (struct vmessoftc *) vmes_cd.cd_devs[unit];
d138 1
a138 1
	return (vmerw(sc->sc_vme, uio, flags, BUS_VMES));
d148 1
a148 1
	struct vmessoftc *sc = (struct vmessoftc *) vmes_cd.cd_devs[unit];
d150 1
a150 1
	return (vmerw(sc->sc_vme, uio, flags, BUS_VMES));
d160 1
a160 1
	struct vmessoftc *sc = (struct vmessoftc *) vmes_cd.cd_devs[unit];
d163 1
a163 1
	pa = vmepmap(sc->sc_vme, off, NBPG, BUS_VMES);
@


1.14
log
@Provide common D16 vmespace block access functions, instead of vs and vx each
rolling their own.

Use them more cleverly in vx, in order to get the driver to at least attach
and frob chips. Not tested besides multiuser boot (hence ttyflags -a), and
checking cu(1) connects. More testing to come once I remember where I have
hidden the 332XT transition module...
@
text
@d1 1
a1 1
/*	$OpenBSD: vmes.c,v 1.13 2003/12/19 22:30:18 miod Exp $ */
d193 1
d195 2
a196 2
	len >>= 1;
	while (len-- != 0)
d198 2
d206 1
d208 2
a209 2
	len >>= 1;
	while (len-- != 0)
d211 2
@


1.13
log
@Pass -Wformat, and silence a few vme* debug printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmes.c,v 1.12 2003/10/11 22:08:57 miod Exp $ */
d174 33
@


1.12
log
@Nuke trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmes.c,v 1.11 2003/06/04 04:11:37 deraadt Exp $ */
d168 3
a170 1
	printf("vmes %x pa %x\n", off, pa);
@


1.11
log
@more term 3 and 4 changes
@
text
@d1 1
a1 1
/*	$OpenBSD: vmes.c,v 1.10 2002/04/28 15:17:09 miod Exp $ */
d52 2
a53 2
}; 
 
@


1.10
log
@Use the prototypes defined via cdev_decl() macros, instead of rolling our
own; thus fix a lot of foo_open(), foo_close() and foo_ioctl() prototypes
in the process.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmes.c,v 1.9 2002/03/14 03:15:57 millert Exp $ */
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Theo de Raadt
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.9
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: vmes.c,v 1.8 2002/03/14 01:26:39 millert Exp $ */
a33 1
#include <sys/conf.h>
d41 1
d43 1
a63 6
int vmesopen(dev_t, int, int);
int vmesclose(dev_t, int, int);
int vmesioctl(dev_t, int, caddr_t, int, struct proc *);
int vmesread(dev_t, struct uio *, int);
int vmeswrite(dev_t, struct uio *, int);
paddr_t vmesmmap(dev_t, off_t, int);
d97 1
a97 1
vmesopen(dev, flag, mode)
d100 1
d110 1
a110 1
vmesclose(dev, flag, mode)
d113 1
d122 2
a123 1
	dev_t   dev;
d125 1
a125 1
	int     cmd, flag;
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: vmes.c,v 1.7 2001/11/07 22:31:57 miod Exp $ */
d62 1
a62 1
int vmesscan(struct device *, void *, void*);
@


1.7
log
@post-mmap API change fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmes.c,v 1.6 2001/11/01 12:13:46 art Exp $ */
d51 2
a52 2
void vmesattach __P((struct device *, struct device *, void *));
int  vmesmatch __P((struct device *, void *, void *));
d62 7
a68 7
int vmesscan __P((struct device *, void *, void*));
int vmesopen __P((dev_t, int, int));
int vmesclose __P((dev_t, int, int));
int vmesioctl __P((dev_t, int, caddr_t, int, struct proc *));
int vmesread __P((dev_t, struct uio *, int));
int vmeswrite __P((dev_t, struct uio *, int));
paddr_t vmesmmap __P((dev_t, off_t, int));
@


1.7.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vmes.c,v 1.7 2001/11/07 22:31:57 miod Exp $ */
d34 1
a41 1
#include <machine/conf.h>
a42 1

d51 2
a52 2
void vmesattach(struct device *, struct device *, void *);
int  vmesmatch(struct device *, void *, void *);
d62 7
a68 1
int vmesscan(struct device *, void *, void *);
d102 1
a102 1
vmesopen(dev, flag, mode, p)
a104 1
	struct proc *p;
d114 1
a114 1
vmesclose(dev, flag, mode, p)
a116 1
	struct proc *p;
d125 1
a125 2
	dev_t dev;
	u_long cmd;
d127 1
a127 1
	int flag;
@


1.6
log
@Change d_mmap in struct cdevsw from:
        int     (*d_mmap)       __P((dev_t, int, int));
to:
	paddr_t	(*d_mmap)	__P((dev_t, off_t, int));

This allows us to mmap devices past 4GB offsets.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmes.c,v 1.5 2001/08/26 02:37:07 miod Exp $ */
d174 1
a174 1
	pa = vmepmap(sc->sc_vme, (void *)off, NBPG, BUS_VMES);
@


1.5
log
@Add prototypes, fix compilation warnings, random style fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmes.c,v 1.4 2001/06/14 21:30:35 miod Exp $ */
d68 1
a68 1
int vmesmmap __P((dev_t, int, int));
d164 1
a164 1
int
d167 2
a168 1
	int off, prot;
@


1.4
log
@Big cleanup of VM issues:
o get rid of m88k_foo macros when there is an mi foo macro
o remove the ability, for the pmap module, to handle a native mmu page
  size different from the vm module page size. This allows some
  optimizations in pmap.c
o remove dead stuff from <machine/vmparam.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: vmes.c,v 1.3 2001/03/09 05:44:39 smurph Exp $ */
d61 8
@


1.3
log
@kernel will compile with -Werror.  Added intr.h
@
text
@d1 1
a1 1
/*	$OpenBSD: vmes.c,v 1.2 1998/12/15 05:52:31 smurph Exp $ */
d40 1
d169 1
a169 1
	return (m88k_btop(pa));
@


1.2
log
@Commit for the first real OpenBSD mvme88k port.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmes.c,v 1.9 1998/01/19 00:13:04 etheisen Exp $ */
a120 2
	int unit = minor(dev);
	struct vmessoftc *sc = (struct vmessoftc *) vmes_cd.cd_devs[unit];
@


1.2.6.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmes.c,v 1.3 2001/03/09 05:44:39 smurph Exp $ */
d121 2
@


1.2.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmes.c,v 1.2.6.1 2001/04/18 16:11:07 niklas Exp $ */
a39 1

d168 1
a168 1
	return (atop(pa));
@


1.2.6.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: vmes.c,v 1.2.6.2 2001/07/04 10:19:58 niklas Exp $ */
a60 8

int vmesscan __P((struct device *, void *, void*));
int vmesopen __P((dev_t, int, int));
int vmesclose __P((dev_t, int, int));
int vmesioctl __P((dev_t, int, caddr_t, int, struct proc *));
int vmesread __P((dev_t, struct uio *, int));
int vmeswrite __P((dev_t, struct uio *, int));
int vmesmmap __P((dev_t, int, int));
@


1.2.6.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d68 1
a68 1
paddr_t vmesmmap __P((dev_t, off_t, int));
d164 1
a164 1
paddr_t
d167 1
a167 2
	off_t off;
	int prot;
d173 1
a173 1
	pa = vmepmap(sc->sc_vme, off, NBPG, BUS_VMES);
@


1.2.6.5
log
@Merge in -current from about a week ago
@
text
@d51 2
a52 2
void vmesattach(struct device *, struct device *, void *);
int  vmesmatch(struct device *, void *, void *);
d62 7
a68 7
int vmesscan(struct device *, void *, void *);
int vmesopen(dev_t, int, int);
int vmesclose(dev_t, int, int);
int vmesioctl(dev_t, int, caddr_t, int, struct proc *);
int vmesread(dev_t, struct uio *, int);
int vmeswrite(dev_t, struct uio *, int);
paddr_t vmesmmap(dev_t, off_t, int);
@


1.2.6.6
log
@Sync the SMP branch with 3.3
@
text
@d34 1
a41 1
#include <machine/conf.h>
a42 1

d63 6
d102 1
a102 1
vmesopen(dev, flag, mode, p)
a104 1
	struct proc *p;
d114 1
a114 1
vmesclose(dev, flag, mode, p)
a116 1
	struct proc *p;
d125 1
a125 2
	dev_t dev;
	u_long cmd;
d127 1
a127 1
	int flag;
@


1.2.6.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vmes.c,v 1.2.6.6 2003/03/27 23:32:18 niklas Exp $ */
d15 5
@


1.2.6.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d51 3
a53 3
        sizeof(struct device), vmesmatch, vmesattach
};

d55 1
a55 1
        NULL, "vmes", DV_DULL
d81 2
d85 2
d140 1
a140 1
	struct device *sc = (struct device *)vmes_cd.cd_devs[unit];
d142 1
a142 1
	return (vmerw(sc->dv_parent, uio, flags, BUS_VMES));
d152 1
a152 1
	struct device *sc = (struct device *)vmes_cd.cd_devs[unit];
d154 1
a154 1
	return (vmerw(sc->dv_parent, uio, flags, BUS_VMES));
d164 1
a164 1
	struct device *sc = (struct device *)vmes_cd.cd_devs[unit];
d167 2
a168 4
	pa = vmepmap(sc->dv_parent, off, NBPG, BUS_VMES);
#ifdef DEBUG
	printf("vmes %llx pa %p\n", off, pa);
#endif
a171 39
}

/*
 * Specific D16 access functions
 *
 * D16 cards will trigger bus errors on attempting to read or write more
 * than 16 bits on the bus. Given how the m88k processor works, this means
 * basically that all long (D32) accesses must be carefully taken care of.
 *
 * Since the kernels bcopy() and bzero() routines will use 32 bit accesses
 * for performance, here are specific D16-compatible routines. They expect
 * pointers to be 16-bit aligned.
 */

void
d16_bcopy(const void *src, void *dst, size_t len)
{
	const u_int16_t *s = (const u_int16_t *)src;
	u_int16_t *d = (u_int16_t *)dst;
	size_t l = len;

	l >>= 1;
	while (l-- != 0)
		*d++ = *s++;
	if (len & 1)
		*(u_int8_t *)d = *(u_int8_t *)s;
}

void
d16_bzero(void *dst, size_t len)
{
	u_int16_t *d = (u_int16_t *)dst;
	size_t l = len;

	l >>= 1;
	while (l-- != 0)
		*d++ = 0;
	if (len & 1)
		*(u_int8_t *)d = 0;
@


1.2.6.9
log
@Merge with the trunk
@
text
@a34 1
#include <machine/bus.h>
d47 2
a48 3
void	vmesattach(struct device *, struct device *, void *);
int	vmesmatch(struct device *, void *, void *);
int	vmesscan(struct device *, void *, void *);
d58 1
a58 3
/*
 * Configuration glue
 */
d163 1
a163 1
	pa = vmepmap(sc->dv_parent, off, BUS_VMES);
d170 39
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD$ */
a52 5
struct vmessoftc {
	struct device		sc_dev;
	struct vmesoftc		*sc_vme;
};

a60 1

d164 1
a164 1
	caddr_t pa;
d166 1
a166 1
	pa = vmepmap(sc->sc_vme, (caddr_t)off, NBPG, BUS_VMES);
@


1.1.1.1
log
@Third try at importing the mvme88k port. This is a working kernel
from nivas.
Userland and compiler still need to be worked on.
Make certain what directory the import is done from.
@
text
@@
