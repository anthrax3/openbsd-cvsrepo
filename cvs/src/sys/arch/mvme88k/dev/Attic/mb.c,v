head	1.3;
access;
symbols
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	UBC_SYNC_A:1.3
	UBC_SYNC_B:1.3
	SMP:1.3.0.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	first_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.3
date	97.03.03.19.07.11;	author rahnds;	state dead;
branches;
next	1.2;

1.2
date	96.11.23.21.46.05;	author kstailey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.10.54.28;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.10.54.28;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.3
log
@This is a remove to get rid of the old mvme88k port which was incomplete
to replace it with a working version. The kernel compiles and works
at least.  The new version will be imported shortly.
@
text
@#include <sys/param.h>
#include <sys/systm.h>
#include <sys/reboot.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/disklabel.h>
#include <machine/cpu.h>

void mbattach __P((struct device *, struct device *, void *));
int mbprint __P((void *, const char *));
int mbmatch __P((struct device *, struct cfdata *, void *));
int submatch( struct device *parent, struct cfdata *self, void *aux);

/* 
 * mainbus driver 
 */
struct cfdriver mainbuscd = {
	NULL, "mainbus", mbmatch, mbattach, 
	DV_DULL, sizeof(struct device), NULL, 0
};

int
mbmatch(pdp, cfp, auxp)
	struct device *pdp;
	struct cfdata *cfp;
	void *auxp;
{
	if (cfp->cf_unit > 0)
		return(0);
	/*
	 * We are always here
	 */
	return(1);
}
/*
 * "find" all the things that should be there.
 */
void
mbattach(pdp, dp, auxp)
	struct device *pdp, *dp;
	void *auxp;
{
	struct cfdata *cf;
	extern int machineid;

	/* nothing to do for this bus */
	printf (" machine type %x\n", machineid);

	if ((cf = config_search(submatch, dp, auxp)) != NULL) {
		return;
	}

}

mbprint(auxp, pnp)
	void *auxp;
	const char *pnp;
{
	if (pnp)
		printf("%s at %s", (char *)auxp, pnp);
	return(UNCONF);
}

int
submatch(parent, self, aux)
	struct device *parent;
	struct cfdata *self;
	void *aux;
{
	if (!(*self->cf_driver->cd_match)(parent, self, NULL)) {
		/*
		 * STOLEN - BE CAREFUL
		 * If we don't do this, isa_configure() will repeatedly try to
		 * probe devices that weren't found.  But we need to be careful
		 * to do it only for the ISA bus, or we would cause things like
		 * `com0 at ast? slave ?' to not probe on the second ast.
		 */
		if (!parent)
			self->cf_fstate = FSTATE_FOUND;

		return 0;
	}

	config_attach(parent, self, NULL, mbprint);

	return 1;
}
@


1.2
log
@added const to second parameter of cfprint_t routines
@
text
@@


1.1
log
@Initial revision
@
text
@d10 1
a10 1
int mbprint __P((void *, char *));
d57 1
a57 1
	char *pnp;
@


1.1.1.1
log
@initial 88k import; code by nivas and based on mach luna88k
@
text
@@
