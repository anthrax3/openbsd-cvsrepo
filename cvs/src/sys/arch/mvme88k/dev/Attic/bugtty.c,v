head	1.24;
access;
symbols
	OPENBSD_3_9:1.23.0.2
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.22.0.6
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.22.0.4
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.22.0.2
	OPENBSD_3_6_BASE:1.22
	SMP_SYNC_A:1.22
	SMP_SYNC_B:1.22
	OPENBSD_3_5:1.21.0.2
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.13
	OPENBSD_3_3:1.13.0.4
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.13
	UBC:1.9.0.2
	UBC_BASE:1.9
	OPENBSD_3_0:1.7.0.4
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.4.0.10
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.8
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.6
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.4
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	mvme88kport:1.1.1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	first_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2006.05.02.21.43.08;	author miod;	state dead;
branches;
next	1.23;

1.23
date	2005.12.11.21.44.04;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2004.05.16.22.23.06;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2004.02.10.10.06.48;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2004.01.14.20.50.48;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2004.01.13.21.29.23;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2003.12.22.11.54.48;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2003.10.11.22.08.57;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2003.09.01.19.14.01;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2003.08.15.20.32.14;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.03.21.09.01;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.12.03.49.56;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2002.04.28.15.17.09;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.01.26.39;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.15.20.45.30;	author nordin;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.16.23.49.46;	author miod;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2001.12.13.08.55.51;	author smurph;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.09.05.44.38;	author smurph;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.08.00.03.12;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2001.02.12.08.16.22;	author smurph;	state Exp;
branches;
next	1.4;

1.4
date	98.12.15.05.52.29;	author smurph;	state Exp;
branches
	1.4.6.1;
next	1.3;

1.3
date	97.03.03.20.20.38;	author rahnds;	state Exp;
branches;
next	1.2;

1.2
date	97.03.03.19.07.09;	author rahnds;	state dead;
branches;
next	1.1;

1.1
date	95.10.18.10.54.28;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.10.54.28;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.03.03.19.32.06;	author rahnds;	state Exp;
branches;
next	;

1.4.6.1
date	2001.04.18.16.10.52;	author niklas;	state Exp;
branches;
next	1.4.6.2;

1.4.6.2
date	2002.03.06.01.08.05;	author niklas;	state Exp;
branches;
next	1.4.6.3;

1.4.6.3
date	2002.03.28.10.36.02;	author niklas;	state Exp;
branches;
next	1.4.6.4;

1.4.6.4
date	2003.03.27.23.32.17;	author niklas;	state Exp;
branches;
next	1.4.6.5;

1.4.6.5
date	2003.06.07.11.13.16;	author ho;	state Exp;
branches;
next	1.4.6.6;

1.4.6.6
date	2004.02.19.10.49.06;	author niklas;	state Exp;
branches;
next	1.4.6.7;

1.4.6.7
date	2004.06.05.23.09.48;	author niklas;	state Exp;
branches;
next	;

1.9.2.1
date	2002.06.11.03.37.09;	author art;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2002.10.29.00.28.07;	author art;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Wave goodbye to bugtty on mvme88k as well.
@
text
@/*	$OpenBSD: bugtty.c,v 1.23 2005/12/11 21:44:04 miod Exp $ */

/* Copyright (c) 1998 Steve Murphree, Jr.
 * Copyright (c) 1995 Dale Rahn.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/ioctl.h>
#include <sys/device.h>
#include <sys/tty.h>
#include <sys/proc.h>
#include <sys/uio.h>
#include <sys/queue.h>
#include <dev/cons.h>

#include <machine/autoconf.h>
#include <machine/bugio.h>
#include <machine/conf.h>
#include <machine/cpu.h>

#include <mvme88k/dev/bugttyfunc.h>

int bugttymatch(struct device *parent, void *self, void *aux);
void bugttyattach(struct device *parent, struct device *self, void *aux);

struct cfattach bugtty_ca = {
        sizeof(struct device), bugttymatch, bugttyattach
};

struct cfdriver bugtty_cd = {
        NULL, "bugtty", DV_TTY
};

/* prototypes */
cons_decl(bugtty);

struct tty *bugttytty(dev_t dev);
int bugttymctl(dev_t dev, int bits, int how);
int bugttyparam(struct tty *tp, struct termios *tm);

#define DIALOUT(x) ((x) & 0x80)
#define SWFLAGS(dev) (bugttyswflags | (DIALOUT(dev) ? TIOCFLAG_SOFTCAR : 0))

#define BUGBUF 80
char bugtty_ibuffer[BUGBUF+1];
volatile char *pinchar = bugtty_ibuffer;
char bug_obuffer[BUGBUF+1];

#define	BUGTTYS	4
struct tty *bugtty_tty[BUGTTYS];

int
bugttymatch(parent, self, aux)
	struct device *parent;
	void *self;
	void *aux;
{
	struct confargs *ca = aux;

	/*
	 * Do not attach if a suitable console driver has been attached.
	 */
	if (cn_tab != NULL && cn_tab->cn_probe != bugttycnprobe)
		return (0);

	ca->ca_ipl = IPL_TTY;
	return (1);
}

void
bugttyattach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	printf(": fallback console\n");
}

#define BUGTTYUNIT(x) ((x) & (0x7f))
void bugttyoutput(struct tty *tp);

int bugttydefaultrate = TTYDEF_SPEED;
int bugttyswflags;

struct tty *
bugttytty(dev)
	dev_t dev;
{
	int unit;
	unit = BUGTTYUNIT(dev);
	if (unit >= BUGTTYS) {
		return (NULL);
	}
	return bugtty_tty[unit];
}

int
bugttymctl(dev, bits, how)
	dev_t dev;
	int bits, how;
{
	int s;

	/*printf("mctl: dev %x, bits %x, how %x,",dev, bits, how);*/

	/* settings are currently ignored */
	s = spltty();
	switch (how) {
	case DMSET:
		break;
	case DMBIC:
		break;
	case DMBIS:
		break;
	case DMGET:
		break;
	}
	splx(s);

	bits = 0;
	/* proper defaults? */
	bits |= TIOCM_DTR;
	bits |= TIOCM_RTS;
	bits |= TIOCM_CTS;
	bits |= TIOCM_CD;
	/* bits |= TIOCM_RI; */
	bits |= TIOCM_DSR;

	/* printf("retbits %x\n", bits); */
	return (bits);
}

int
bugttyopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	int s, unit = BUGTTYUNIT(dev);
	struct tty *tp;

	s = spltty();
	if (bugtty_tty[unit]) {
		tp = bugtty_tty[unit];
	} else {
		tp = bugtty_tty[unit] = ttymalloc();
	}
	tp->t_oproc = bugttyoutput;
	tp->t_param = NULL;
	tp->t_dev = dev;

	if ((tp->t_state & TS_ISOPEN) == 0) {
		tp->t_state |= TS_WOPEN;
		ttychars(tp);
		if (tp->t_ispeed == 0) {
			/*
			 * only when cleared do we reset to defaults.
			 */
			tp->t_iflag = TTYDEF_IFLAG;
			tp->t_oflag = TTYDEF_OFLAG;
			tp->t_cflag = TTYDEF_CFLAG;
			tp->t_lflag = TTYDEF_LFLAG;
			tp->t_ispeed = tp->t_ospeed = bugttydefaultrate;
		}
		/* bugtty does not have carrier */
		tp->t_cflag |= CLOCAL;
		/*
		 * do these all the time
		 */
		if (bugttyswflags & TIOCFLAG_CLOCAL)
			tp->t_cflag |= CLOCAL;
		if (bugttyswflags & TIOCFLAG_CRTSCTS)
			tp->t_cflag |= CRTSCTS;
		if (bugttyswflags & TIOCFLAG_MDMBUF)
			tp->t_cflag |= MDMBUF;
		bugttyparam(tp, &tp->t_termios);
		ttsetwater(tp);

		(void)bugttymctl(dev, TIOCM_DTR | TIOCM_RTS, DMSET);
		/*
		if ((SWFLAGS(dev) & TIOCFLAG_SOFTCAR) ||
		    (bugttymctl(dev, 0, DMGET) & TIOCM_CD))
			tp->t_state |= TS_CARR_ON;
		else
			tp->t_state &= ~TS_CARR_ON;
		*/
		tp->t_state |= TS_CARR_ON;
	} else if (tp->t_state & TS_XCLUDE && p->p_ucred->cr_uid != 0) {
		splx(s);
		return (EBUSY);
	}

	/*
	 * if NONBLOCK requested, ignore carrier
	 */
/*
	if (flag & O_NONBLOCK)
		goto done;
*/

	splx(s);
	/*
	 * Reset the tty pointer, as there could have been a dialout
	 * use of the tty with a dialin open waiting.
	 */
	tp->t_dev = dev;
	return ((*linesw[tp->t_line].l_open)(dev, tp));
}

int
bugttyparam(tp, tm)
	struct tty *tp;
	struct termios *tm;
{
	return (0);
}

void
bugttyoutput(tp)
	struct tty *tp;
{
	int cc, s, cnt;

	/* only supports one unit */

	if ((tp->t_state & TS_ISOPEN) == 0)
		return;

	s = spltty();
	cc = tp->t_outq.c_cc;
	while (cc > 0) {
		cnt = min(BUGBUF, cc);
		cnt = q_to_b(&tp->t_outq, bug_obuffer, cnt);
		bugoutstr(bug_obuffer, &bug_obuffer[cnt]);
		cc -= cnt;
	}
	splx(s);
}

int
bugttyclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	int unit = BUGTTYUNIT(dev);
	struct tty *tp = bugtty_tty[unit];

	(*linesw[tp->t_line].l_close)(tp, flag);

	ttyclose(tp);
#if 0
	bugtty_tty[unit] = NULL;
#endif
	return (0);
}

int
bugttyread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	struct tty *tp;

	if ((tp = bugtty_tty[BUGTTYUNIT(dev)]) == NULL)
		return (ENXIO);
	return ((*linesw[tp->t_line].l_read)(tp, uio, flag));
}

/* only to be called at splclk() */
void
bugtty_chkinput()
{
	struct tty *tp;

	tp = bugtty_tty[0]; /* assumes console is the first port */
	if (tp == NULL)
		return;

	while (buginstat() != 0) {
		u_char c = buginchr() & 0xff;
		(*linesw[tp->t_line].l_rint)(c, tp);
	}
}

int
bugttywrite(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
#if 0
	/* bypass tty output routines. */
	int i, cnt, s;
	int oldoff;

	s = spltty();
	oldoff = uio->uio_offset;
	do  {
		uiomove(bug_obuffer, BUGBUF, uio);
		bugoutstr(bug_obuffer, &bug_obuffer[uio->uio_offset - oldoff]);
		oldoff = uio->uio_offset;
	} while (uio->uio_resid != 0);
	splx(s);

	return (0);
#else
	struct tty *tp;
	if((tp = bugtty_tty[BUGTTYUNIT(dev)]) == NULL)
		return (ENXIO);
	return ((*linesw[tp->t_line].l_write)(tp, uio, flag));
#endif
}

int
bugttyioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	int unit = BUGTTYUNIT(dev);
	struct tty *tp = bugtty_tty[unit];
	int error;

	if (!tp)
		return (ENXIO);

	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);

	error = ttioctl(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);

	switch (cmd) {
	case TIOCSBRK:
		/* */
		break;

	case TIOCCBRK:
		/* */
		break;

	case TIOCSDTR:
		(void) bugttymctl(dev, TIOCM_DTR | TIOCM_RTS, DMBIS);
		break;

	case TIOCCDTR:
		(void) bugttymctl(dev, TIOCM_DTR | TIOCM_RTS, DMBIC);
		break;

	case TIOCMSET:
		(void) bugttymctl(dev, *(int *) data, DMSET);
		break;

	case TIOCMBIS:
		(void) bugttymctl(dev, *(int *) data, DMBIS);
		break;

	case TIOCMBIC:
		(void) bugttymctl(dev, *(int *) data, DMBIC);
		break;

	case TIOCMGET:
		*(int *)data = bugttymctl(dev, 0, DMGET);
		break;
	case TIOCGFLAGS:
		*(int *)data = SWFLAGS(dev);
		break;
	case TIOCSFLAGS:
		error = suser(p, 0);
		if (error != 0)
			return (EPERM);

		bugttyswflags = *(int *)data;
		bugttyswflags &= /* only allow valid flags */
		    (TIOCFLAG_SOFTCAR | TIOCFLAG_CLOCAL | TIOCFLAG_CRTSCTS);
		break;
	default:
		return (ENOTTY);
	}

	return (0);
}

int
bugttystop(tp, flag)
	struct tty *tp;
	int flag;
{
	int s;

	s = spltty();
	if (tp->t_state & TS_BUSY) {
		if ((tp->t_state & TS_TTSTOP) == 0)
			tp->t_state |= TS_FLUSH;
	}
	splx(s);
	return (0);
}

/*
 * bugtty is the last possible choice for a console device.
 */
void
bugttycnprobe(cp)
	struct consdev *cp;
{
	int maj;

	/* locate the major number */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == bugttyopen)
			break;

	cp->cn_dev = makedev(maj, 0);
	cp->cn_pri = CN_NORMAL;
}

void
bugttycninit(cp)
	struct consdev *cp;
{
	/* Nothing to do */
}

int
bugttycngetc(dev)
	dev_t dev;
{
	return (buginchr());
}

void
bugttycnputc(dev, c)
	dev_t dev;
	char c;
{
	bugoutchr(c);
}
@


1.23
log
@Remove unused includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: bugtty.c,v 1.22 2004/05/16 22:23:06 miod Exp $ */
@


1.22
log
@Simplify bugtty_chkinput(), from mvmeppc.
@
text
@d1 1
a1 1
/*	$OpenBSD: bugtty.c,v 1.21 2004/02/10 10:06:48 miod Exp $ */
a45 2

#include "bugtty.h"
@


1.21
log
@Fix cnprobe() and cninit() prototypes.
Also, provide a better test for bugtty attachment.
@
text
@d1 1
a1 1
/*	$OpenBSD: bugtty.c,v 1.20 2004/01/14 20:50:48 miod Exp $ */
d302 3
a304 3
	int rc = 0;
	tp = bugtty_tty[0]; /* Kinda ugly hack */
	if (tp == NULL )
d307 3
a309 8
	if ((rc = buginstat()) != 0) {
		while (buginstat() != 0) {
			u_char c = buginchr() & 0xff;
			(*linesw[tp->t_line].l_rint)(c, tp);
		}
		/*
		wakeup(tp);
		*/
@


1.20
log
@Do not fill more than the first three fields of cfdriver structures unless
necessary. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: bugtty.c,v 1.19 2004/01/13 21:29:23 miod Exp $ */
a47 2
#include "cl.h"
#include "dart.h"
d61 1
a61 4
int bugttycnprobe(struct consdev *cp);
int bugttycninit(struct consdev *cp);
int bugttycngetc(dev_t dev);
void bugttycnputc(dev_t dev, char c);
d89 2
a90 16
#if NCL > 0
	{
		extern struct cfdriver cl_cd;

		if (cl_cd.cd_ndevs != 0)
			return (0);
	}
#endif
#if NDART > 0
	{
		extern struct cfdriver dart_cd;

		if (dart_cd.cd_ndevs != 0)
			return (0);
	}
#endif
d440 1
a440 1
int
a452 1
	return (1);
d455 1
a455 1
int
a459 1
	return 0;
@


1.19
log
@Take advantage of the way config(8) works to probe for bugtty last during
autoconf. Bugtty will then not attach if either cl or dart has attached.

Note that, if you boot -c and disable the real console driver for your
board, you lose, because of the early console initialization. This is not
supported anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: bugtty.c,v 1.18 2003/12/22 11:54:48 miod Exp $ */
d59 1
a59 1
        NULL, "bugtty", DV_TTY, 0
@


1.18
log
@Correctly handle vme attachments which specify a larger ca_len size than
initially expected.
@
text
@d1 1
a1 1
/*	$OpenBSD: bugtty.c,v 1.17 2003/10/11 22:08:57 miod Exp $ */
d48 2
d80 2
a81 2
struct tty *bugtty_tty[NBUGTTY];
int needprom = 1;
a92 1
	 * XXX but bugtty is probed first!
d94 16
a109 2
	if (needprom == 0)
		return (0);
a110 2
	ca->ca_paddr = (void *)0xfff45000;
	ca->ca_vaddr = (void *)0xfff45000;
a111 1
	ca->ca_name = "bugtty";
d136 1
a136 1
	if (unit >= 4) {
a185 4
	extern int needprom;

	if (needprom == 0)
		return (ENODEV);
a463 6
	int needprom = 1;

	if (needprom == 0) {
		cp->cn_pri = CN_DEAD;
		return (0);
	}
@


1.17
log
@Nuke trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: bugtty.c,v 1.16 2003/09/01 19:14:01 miod Exp $ */
a79 11
/*
	int	ca_bustype;
	void	*ca_vaddr;
	void	*ca_paddr;
	int	ca_offset;
	int	ca_len;
	int	ca_ipl;
	int	ca_vec;
	char	*ca_name;
	void	*ca_master;	 points to bus-dependent data
*/
d89 4
d95 1
a97 1
	ca->ca_len = 0x200;
d99 1
a99 1
	ca->ca_name = "bugtty\0";
@


1.16
log
@Prevent userland from invoking BUG system calls, by saving the initial BUG
trap vector contents, putting the bugtrap() stub in place, and switching
back and forth between them when the kernel needs to invoke BUG functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: bugtty.c,v 1.15 2003/08/15 20:32:14 tedu Exp $ */
d3 1
a3 1
/* Copyright (c) 1998 Steve Murphree, Jr. 
d6 1
a6 1
 *   
d28 1
a28 1
 */  
d54 1
a54 1
};      
d89 1
a89 1
	void	*ca_master;	 points to bus-dependent data 
d99 1
a99 1
	
d125 1
a125 1
struct tty * 
d311 1
a311 1
		return (ENXIO); 
d381 1
a381 1
	if (error >= 0) 
d424 1
a424 1
		error = suser(p, 0); 
d426 1
a426 1
			return (EPERM); 
d464 1
a464 1
	
d469 1
a469 1
		
@


1.15
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bugtty.c,v 1.14 2003/06/03 21:09:01 deraadt Exp $ */
d116 1
a116 1
	printf(": bugtty\n");
a469 15
#if 0
	switch (cputyp) {
	case CPU_147:
	case CPU_162:
		cp->cn_pri = CN_NORMAL;
		return (0);
	default:
		break;
	}
#endif
#if 0
	cp->cn_pri = CN_NORMAL;
	return (0);
#endif /* 0 */

@


1.14
log
@terms 3 & 4 cleanup based on "terms" file
@
text
@d1 1
a1 1
/*	$OpenBSD: bugtty.c,v 1.13 2002/06/12 03:49:56 miod Exp $ */
d424 1
a424 1
		error = suser(p->p_ucred, &p->p_acflag); 
@


1.13
log
@cnputc() will take care of the necessary cr->cr/lf translation, so don't
do it in those consoles either.
@
text
@d1 1
a1 1
/*	$OpenBSD: bugtty.c,v 1.12 2002/04/28 15:17:09 miod Exp $ */
d15 1
a15 4
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *   This product includes software developed by Dale Rahn.
 * 4. The name of the author may not be used to endorse or promote products
@


1.12
log
@Use the prototypes defined via cdev_decl() macros, instead of rolling our
own; thus fix a lot of foo_open(), foo_close() and foo_ioctl() prototypes
in the process.
@
text
@d1 1
a1 1
/*	$OpenBSD: bugtty.c,v 1.11 2002/03/14 01:26:39 millert Exp $ */
a517 2
	if (c == '\n')
		bugoutchr('\r');
@


1.11
log
@First round of __P removal in sys
@
text
@d1 2
a2 1
/*	$OpenBSD: bugtty.c,v 1.10 2002/02/15 20:45:30 nordin Exp $ */
a38 1
#include <sys/conf.h>
d45 1
a68 7
int bugttyopen(dev_t dev, int flag, int mode, struct proc *p);
int bugttyclose(dev_t dev, int flag, int mode, struct proc *p);
int bugttyread(dev_t dev, struct uio *uio, int flag);
int bugttywrite(dev_t dev, struct uio *uio, int flag);
int bugttyioctl(dev_t dev, int cmd, caddr_t data, int flag, struct proc *p);
int bugttystop(struct tty *tp, int flag);

d141 1
a141 1
	bugttymctl(dev, bits, how)
d269 1
a269 1
	int cc, s, cnt ;
d371 1
a371 1
	int cmd;
@


1.10
log
@Don't cast nonexistent return value from splx to (void). ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bugtty.c,v 1.9 2001/12/16 23:49:46 miod Exp $ */
d51 2
a52 2
int bugttymatch __P((struct device *parent, void *self, void *aux));
void bugttyattach __P((struct device *parent, struct device *self, void *aux));
d63 15
a77 15
int bugttycnprobe __P((struct consdev *cp));
int bugttycninit __P((struct consdev *cp));
int bugttycngetc __P((dev_t dev));
void bugttycnputc __P((dev_t dev, char c));

int bugttyopen __P((dev_t dev, int flag, int mode, struct proc *p));
int bugttyclose __P((dev_t dev, int flag, int mode, struct proc *p));
int bugttyread __P((dev_t dev, struct uio *uio, int flag));
int bugttywrite __P((dev_t dev, struct uio *uio, int flag));
int bugttyioctl __P((dev_t dev, int cmd, caddr_t data, int flag, struct proc *p));
int bugttystop __P((struct tty *tp, int flag));

struct tty *bugttytty __P((dev_t dev));
int bugttymctl __P((dev_t dev, int bits, int how));
int bugttyparam __P((struct tty *tp, struct termios *tm));
d129 1
a129 1
void bugttyoutput __P((struct tty *tp));
@


1.9
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: bugtty.c,v 1.7 2001/03/09 05:44:38 smurph Exp $ */
d167 1
a167 1
	(void)splx(s);
@


1.9.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 2
/*	$OpenBSD$ */

d38 1
a44 1
#include <machine/conf.h>
d51 2
a52 2
int bugttymatch(struct device *parent, void *self, void *aux);
void bugttyattach(struct device *parent, struct device *self, void *aux);
d63 15
a77 8
int bugttycnprobe(struct consdev *cp);
int bugttycninit(struct consdev *cp);
int bugttycngetc(dev_t dev);
void bugttycnputc(dev_t dev, char c);

struct tty *bugttytty(dev_t dev);
int bugttymctl(dev_t dev, int bits, int how);
int bugttyparam(struct tty *tp, struct termios *tm);
d129 1
a129 1
void bugttyoutput(struct tty *tp);
d147 1
a147 1
bugttymctl(dev, bits, how)
d167 1
a167 1
	splx(s);
d275 1
a275 1
	int cc, s, cnt;
d377 1
a377 1
	u_long cmd;
@


1.9.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bugtty.c,v 1.9.2.1 2002/06/11 03:37:09 art Exp $ */
d518 2
@


1.8
log
@Support for MVME197 completed.  Fix SPL defs.
@
text
@d479 15
@


1.7
log
@kernel will compile with -Werror.  Added intr.h
@
text
@d1 1
a1 1
/*	$OpenBSD: bugtty.c,v 1.6 2001/03/08 00:03:12 miod Exp $ */
a478 15
#if 0
	switch (cputyp) {
	case CPU_147:
	case CPU_162:
		cp->cn_pri = CN_NORMAL;
		return (0);
	default:
		break;
	}
#endif
#if 0
	cp->cn_pri = CN_NORMAL;
	return (0);
#endif /* 0 */

@


1.6
log
@Some warning hunting.
Define new include files for convenience, for use by drivers who can
attach either to pcctwo or syscon, or need bug console routines.
@
text
@d1 1
a1 1
/*	$OpenBSD: bugtty.c,v 1.5 2001/02/12 08:16:22 smurph Exp $ */
d136 1
a136 1
dev_t dev;
d147 3
a149 3
bugttymctl(dev, bits, how)
dev_t dev;
int bits, how;
d184 3
a186 3
dev_t dev;
int flag, mode;
struct proc *p;
d273 1
a273 1
struct tty *tp;
d295 3
a297 3
dev_t dev;
int flag, mode;
struct proc *p;
d313 3
a315 3
dev_t dev;
struct uio *uio;
int flag;
d347 3
a349 3
dev_t dev;
struct uio *uio;
int flag;
d376 5
a380 5
dev_t dev;
int cmd;
caddr_t data;
int flag;
struct proc *p;
d450 2
a451 2
struct tty *tp;
int flag;
d469 1
a469 1
struct consdev *cp;
d506 1
a506 1
struct consdev *cp;
d514 1
a514 1
dev_t dev;
d521 2
a522 2
dev_t dev;
char c;
@


1.5
log
@correct buginstat(), statclock now working for '188, systat vmstat now works,
serial driver for '188 working better.
@
text
@d1 1
a1 1
/*	$OpenBSD: bugtty.c,v 1.4 1998/12/15 05:52:29 smurph Exp $ */
d44 1
d47 2
d66 1
a66 1
int bugttycnputc __P((dev_t dev, char c));
d75 4
a150 2
	static int settings = TIOCM_DTR | TIOCM_RTS |
	    TIOCM_CTS | TIOCM_CD | TIOCM_DSR;
d264 3
a266 1
bugttyparam()
d275 1
a275 1
	int cc, s, unit, cnt ;
a323 1
#if 1
d325 1
d334 2
a335 2
	if (rc = buginstat()) {
		while (buginstat()) {
a343 1
#endif
d519 1
a519 1
int
a523 2
	int s;

@


1.4
log
@Commit for the first real OpenBSD mvme88k port.
@
text
@d1 1
a1 1
/*	$OpenBSD: bugio.c,v 1.1 1997/03/03 19:32:04 rahnds Exp $ */
a79 1
#define bugtty_tty bugttytty
d127 12
d141 2
a142 2
	dev_t dev;
	int bits, how;
d179 3
a181 3
	dev_t dev;
	int flag, mode;
	struct proc *p;
d266 1
a266 1
	struct tty *tp;
d288 3
a290 3
	dev_t dev;
	int flag, mode;
	struct proc *p;
d306 3
a308 3
	dev_t dev;
	struct uio *uio;
	int flag;
d322 1
a322 1

d327 1
a327 1
	if (buginstat()) {
d341 3
a343 3
	dev_t dev;
	struct uio *uio;
	int flag;
d370 5
a374 5
	dev_t dev;
	int cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d444 2
a445 2
	struct tty *tp;
	int flag;
d463 1
a463 1
	struct consdev *cp;
d500 1
a500 1
	struct consdev *cp;
d502 2
a503 1
    /* Nothing to do */
d508 1
a508 1
	dev_t dev;
d515 2
a516 2
	dev_t dev;
	char c;
@


1.4.6.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: bugtty.c,v 1.7 2001/03/09 05:44:38 smurph Exp $ */
a43 1
#include <machine/bugio.h>
a45 2
#include <mvme88k/dev/bugttyfunc.h>

d63 1
a63 1
void bugttycnputc __P((dev_t dev, char c));
a71 4
struct tty *bugttytty __P((dev_t dev));
int bugttymctl __P((dev_t dev, int bits, int how));
int bugttyparam __P((struct tty *tp, struct termios *tm));

d80 1
a127 12
struct tty * 
bugttytty(dev)
	dev_t dev;
{
	int unit;
	unit = BUGTTYUNIT(dev);
	if (unit >= 4) {
		return (NULL);
	}
	return bugtty_tty[unit];
}

d129 1
a129 1
	bugttymctl(dev, bits, how)
d133 2
d248 1
a248 3
bugttyparam(tp, tm)
	struct tty *tp;
	struct termios *tm;
d257 1
a257 1
	int cc, s, cnt ;
d306 1
a307 1
void
d311 1
a311 1
	int rc = 0;
d316 2
a317 2
	if ((rc = buginstat()) != 0) {
		while (buginstat() != 0) {
d326 1
d491 1
a491 2
	/* Nothing to do */
	return 0;
d501 1
a501 1
void
d506 2
@


1.4.6.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d167 1
a167 1
	splx(s);
@


1.4.6.3
log
@Merge in -current from about a week ago
@
text
@d51 2
a52 2
int bugttymatch(struct device *parent, void *self, void *aux);
void bugttyattach(struct device *parent, struct device *self, void *aux);
d63 15
a77 15
int bugttycnprobe(struct consdev *cp);
int bugttycninit(struct consdev *cp);
int bugttycngetc(dev_t dev);
void bugttycnputc(dev_t dev, char c);

int bugttyopen(dev_t dev, int flag, int mode, struct proc *p);
int bugttyclose(dev_t dev, int flag, int mode, struct proc *p);
int bugttyread(dev_t dev, struct uio *uio, int flag);
int bugttywrite(dev_t dev, struct uio *uio, int flag);
int bugttyioctl(dev_t dev, int cmd, caddr_t data, int flag, struct proc *p);
int bugttystop(struct tty *tp, int flag);

struct tty *bugttytty(dev_t dev);
int bugttymctl(dev_t dev, int bits, int how);
int bugttyparam(struct tty *tp, struct termios *tm);
d129 1
a129 1
void bugttyoutput(struct tty *tp);
@


1.4.6.4
log
@Sync the SMP branch with 3.3
@
text
@a1 1

d38 1
a44 1
#include <machine/conf.h>
d68 7
d147 1
a147 1
bugttymctl(dev, bits, how)
d275 1
a275 1
	int cc, s, cnt;
d377 1
a377 1
	u_long cmd;
d524 2
@


1.4.6.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bugtty.c,v 1.4.6.4 2003/03/27 23:32:17 niklas Exp $ */
d15 4
a18 1
 * 3. The name of the author may not be used to endorse or promote products
@


1.4.6.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d3 1
a3 1
/* Copyright (c) 1998 Steve Murphree, Jr.
d6 1
a6 1
 *
d28 1
a28 1
 */
a47 2
#include "cl.h"
#include "dart.h"
d54 1
a54 1
};
d57 1
a57 1
        NULL, "bugtty", DV_TTY
d78 13
a90 2
#define	BUGTTYS	4
struct tty *bugtty_tty[BUGTTYS];
d99 6
a104 21

	/*
	 * Do not attach if a suitable console driver has been attached.
	 */
#if NCL > 0
	{
		extern struct cfdriver cl_cd;

		if (cl_cd.cd_ndevs != 0)
			return (0);
	}
#endif
#if NDART > 0
	{
		extern struct cfdriver dart_cd;

		if (dart_cd.cd_ndevs != 0)
			return (0);
	}
#endif

d106 1
d116 1
a116 1
	printf(": fallback console\n");
d125 1
a125 1
struct tty *
d131 1
a131 1
	if (unit >= BUGTTYS) {
d181 4
d311 1
a311 1
		return (ENXIO);
d381 1
a381 1
	if (error >= 0)
d424 1
a424 1
		error = suser(p, 0);
d426 1
a426 1
			return (EPERM);
d463 21
@


1.4.6.7
log
@Merge with the trunk
@
text
@d48 2
d63 4
a66 1
cons_decl(bugtty);
d94 16
a109 2
	if (cn_tab != NULL && cn_tab->cn_probe != bugttycnprobe)
		return (0);
d321 3
a323 3

	tp = bugtty_tty[0]; /* assumes console is the first port */
	if (tp == NULL)
d326 8
a333 3
	while (buginstat() != 0) {
		u_char c = buginchr() & 0xff;
		(*linesw[tp->t_line].l_rint)(c, tp);
d459 1
a459 1
void
d472 1
d475 1
a475 1
void
d480 1
@


1.3
log
@Cleanup after import. This also seems to bring up the current version.
@
text
@d1 2
a2 3
/*	$NetBSD$ */

/*
d83 11
a100 1
	extern int needprom;
d105 3
a107 5
	/*
	 * tell our parent our requirements
	 */
	ca->ca_paddr = (caddr_t)0xfff45000;
	ca->ca_size = 0x200;
d109 1
d119 1
a119 1
	printf("\n");
d455 2
a456 2
	extern int needprom;

d471 2
a472 1
#else
a483 1

d491 1
@


1.2
log
@This is a remove to get rid of the old mvme88k port which was incomplete
to replace it with a working version. The kernel compiles and works
at least.  The new version will be imported shortly.
@
text
@d52 6
a57 3
struct cfdriver bugttycd = {
	NULL, "bugtty", bugttymatch, bugttyattach,
	DV_TTY, sizeof(struct device)
d92 1
d96 6
d497 2
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@initial 88k import; code by nivas and based on mach luna88k
@
text
@@


1.1.1.2
log
@Third try at importing the mvme88k port. This is a working kernel
from nivas.
Userland and compiler still need to be worked on.
Make certain what directory the import is done from.
@
text
@d52 3
a54 6
struct cfattach bugtty_ca = {
        sizeof(struct device), bugttymatch, bugttyattach
};      

struct cfdriver bugtty_cd = {
        NULL, "bugtty", DV_TTY, 0
a88 1
	struct confargs *ca = aux;
a91 6
	/*
	 * tell our parent our requirements
	 */
	ca->ca_paddr = (caddr_t)0xfff45000;
	ca->ca_size = 0x200;
	ca->ca_ipl = IPL_TTY;
a486 2
	int s;

@
