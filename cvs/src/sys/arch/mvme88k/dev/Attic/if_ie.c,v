head	1.49;
access;
symbols
	OPENBSD_5_5:1.48.0.4
	OPENBSD_5_5_BASE:1.48
	OPENBSD_5_4:1.45.0.4
	OPENBSD_5_4_BASE:1.45
	OPENBSD_5_3:1.45.0.2
	OPENBSD_5_3_BASE:1.45
	OPENBSD_5_2:1.44.0.12
	OPENBSD_5_2_BASE:1.44
	OPENBSD_5_1_BASE:1.44
	OPENBSD_5_1:1.44.0.10
	OPENBSD_5_0:1.44.0.8
	OPENBSD_5_0_BASE:1.44
	OPENBSD_4_9:1.44.0.6
	OPENBSD_4_9_BASE:1.44
	OPENBSD_4_8:1.44.0.4
	OPENBSD_4_8_BASE:1.44
	OPENBSD_4_7:1.44.0.2
	OPENBSD_4_7_BASE:1.44
	OPENBSD_4_6:1.43.0.6
	OPENBSD_4_6_BASE:1.43
	OPENBSD_4_5:1.43.0.2
	OPENBSD_4_5_BASE:1.43
	OPENBSD_4_4:1.41.0.10
	OPENBSD_4_4_BASE:1.41
	OPENBSD_4_3:1.41.0.8
	OPENBSD_4_3_BASE:1.41
	OPENBSD_4_2:1.41.0.6
	OPENBSD_4_2_BASE:1.41
	OPENBSD_4_1:1.41.0.4
	OPENBSD_4_1_BASE:1.41
	OPENBSD_4_0:1.41.0.2
	OPENBSD_4_0_BASE:1.41
	OPENBSD_3_9:1.37.0.2
	OPENBSD_3_9_BASE:1.37
	OPENBSD_3_8:1.33.0.2
	OPENBSD_3_8_BASE:1.33
	OPENBSD_3_7:1.32.0.2
	OPENBSD_3_7_BASE:1.32
	OPENBSD_3_6:1.31.0.2
	OPENBSD_3_6_BASE:1.31
	SMP_SYNC_A:1.28
	SMP_SYNC_B:1.28
	OPENBSD_3_5:1.27.0.2
	OPENBSD_3_5_BASE:1.27
	OPENBSD_3_4:1.24.0.2
	OPENBSD_3_4_BASE:1.24
	UBC_SYNC_A:1.23
	OPENBSD_3_3:1.23.0.2
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.22.0.4
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.22.0.2
	OPENBSD_3_1_BASE:1.22
	UBC_SYNC_B:1.22
	UBC:1.18.0.2
	UBC_BASE:1.18
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.7.0.4
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	SMP:1.6.0.4
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.1.1.1.0.8
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.6
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.4
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.2
	OPENBSD_2_1_BASE:1.1.1.1
	mvme88kport:1.1.1.1;
locks; strict;
comment	@ * @;


1.49
date	2014.03.18.22.36.36;	author miod;	state dead;
branches;
next	1.48;

1.48
date	2013.11.30.20.24.45;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2013.11.27.08.56.31;	author mpi;	state Exp;
branches;
next	1.46;

1.46
date	2013.09.05.20.55.57;	author bluhm;	state Exp;
branches;
next	1.45;

1.45
date	2012.10.10.04.52.16;	author camield;	state Exp;
branches;
next	1.44;

1.44
date	2009.10.31.14.31.11;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2008.11.28.02.44.17;	author brad;	state Exp;
branches;
next	1.42;

1.42
date	2008.10.02.20.21.13;	author brad;	state Exp;
branches;
next	1.41;

1.41
date	2006.05.08.14.36.10;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2006.04.17.13.39.48;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2006.04.16.00.46.32;	author pascoe;	state Exp;
branches;
next	1.38;

1.38
date	2006.03.25.22.41.41;	author djm;	state Exp;
branches;
next	1.37;

1.37
date	2006.01.17.02.03.53;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2006.01.11.07.22.00;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2005.12.11.21.44.04;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2005.10.12.19.33.48;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2005.07.31.03.52.18;	author pascoe;	state Exp;
branches;
next	1.32;

1.32
date	2005.01.15.05.24.10;	author brad;	state Exp;
branches;
next	1.31;

1.31
date	2004.08.02.08.35.00;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2004.07.30.19.02.05;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2004.07.02.14.00.43;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2004.04.24.19.51.48;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2004.01.14.20.50.48;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2003.10.05.20.27.47;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2003.09.29.09.08.19;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.02.07.06.56;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2003.01.28.01.37.52;	author jason;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.14.01.26.39;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.05.23.15.33;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2002.01.14.21.34.38;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2001.12.22.18.45.35;	author smurph;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.16.23.49.46;	author miod;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2001.12.13.08.55.51;	author smurph;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.28.16.13.28;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.06.19.53.15;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.26.02.37.07;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.24.19.26.12;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.08.21.01.10;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.08.08.09.13;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.09.05.44.38;	author smurph;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.07.23.45.51;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.20.19.39.32;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.03.00.54.53;	author todd;	state Exp;
branches;
next	1.6;

1.6
date	99.09.27.18.43.24;	author smurph;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	99.05.29.04.41.43;	author smurph;	state Exp;
branches;
next	1.4;

1.4
date	99.03.03.22.10.32;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	99.01.11.05.11.42;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	98.12.15.05.52.30;	author smurph;	state Exp;
branches;
next	1.1;

1.1
date	97.03.03.19.32.06;	author rahnds;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.03.03.19.32.06;	author rahnds;	state Exp;
branches;
next	;

1.6.4.1
date	2000.03.24.09.08.14;	author niklas;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2001.04.18.16.10.55;	author niklas;	state Exp;
branches;
next	1.6.4.3;

1.6.4.3
date	2001.07.04.10.19.54;	author niklas;	state Exp;
branches;
next	1.6.4.4;

1.6.4.4
date	2001.10.31.03.01.18;	author nate;	state Exp;
branches;
next	1.6.4.5;

1.6.4.5
date	2001.11.13.21.04.14;	author niklas;	state Exp;
branches;
next	1.6.4.6;

1.6.4.6
date	2001.12.05.00.39.12;	author niklas;	state Exp;
branches;
next	1.6.4.7;

1.6.4.7
date	2002.03.06.02.04.44;	author niklas;	state Exp;
branches;
next	1.6.4.8;

1.6.4.8
date	2002.03.28.10.36.02;	author niklas;	state Exp;
branches;
next	1.6.4.9;

1.6.4.9
date	2003.03.27.23.32.17;	author niklas;	state Exp;
branches;
next	1.6.4.10;

1.6.4.10
date	2003.06.07.11.13.16;	author ho;	state Exp;
branches;
next	1.6.4.11;

1.6.4.11
date	2004.02.19.10.49.06;	author niklas;	state Exp;
branches;
next	1.6.4.12;

1.6.4.12
date	2004.06.05.23.09.49;	author niklas;	state Exp;
branches;
next	;

1.18.2.1
date	2002.01.31.22.55.17;	author niklas;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2002.06.11.03.37.09;	author art;	state Exp;
branches;
next	1.18.2.3;

1.18.2.3
date	2003.05.19.21.45.53;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.49
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: if_ie.c,v 1.48 2013/11/30 20:24:45 miod Exp $ */

/*-
 * Copyright (c) 1998 Steve Murphree, Jr.
 * Copyright (c) 1995 Theo de Raadt
 * Copyright (c) 1993, 1994, 1995 Charles Hannum.
 * Copyright (c) 1992, 1993, University of Vermont and State
 *  Agricultural College.
 * Copyright (c) 1992, 1993, Garrett A. Wollman.
 *
 * Portions:
 * Copyright (c) 1994, 1995, Rafal K. Boni
 * Copyright (c) 1990, 1991, William F. Jolitz
 * Copyright (c) 1990, The Regents of the University of California
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Charles Hannum, by the
 *	University of Vermont and State Agricultural College and Garrett A.
 *	Wollman, by William F. Jolitz, and by the University of California,
 *	Berkeley, Lawrence Berkeley Laboratory, and its contributors.
 * 4. Neither the names of the Universities nor the names of the authors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR AUTHORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Intel 82596 Ethernet chip
 * Register, bit, and structure definitions.
 *
 * Original StarLAN driver written by Garrett Wollman with reference to the
 * Clarkson Packet Driver code for this chip written by Russ Nelson and others.
 *
 * BPF support code taken from hpdev/if_le.c, supplied with tcpdump.
 *
 * 3C507 support is loosely based on code donated to NetBSD by Rafal Boni.
 *
 * Majorly cleaned up and 3C507 code merged by Charles Hannum.
 *
 * Converted to SUN ie driver by Charles D. Cranor,
 *		October 1994, January 1995.
 * This sun version based on i386 version 1.30.
 */

extern void *etherbuf;
extern int etherlen;

/*
Mode of operation:

   We run the 82596 in a standard Ethernet mode.  We keep NFRAMES
   received frame descriptors around for the receiver to use, and
   NRXBUF associated receive buffer descriptors, both in a circular
   list.  Whenever a frame is received, we rotate both lists as
   necessary.  (The 596 treats both lists as a simple queue.)  We also
   keep a transmit command around so that packets can be sent off
   quickly.

   We configure the adapter in AL-LOC = 1 mode, which means that the
   Ethernet/802.3 MAC header is placed at the beginning of the receive
   buffer rather than being split off into various fields in the RFD.
   This also means that we must include this header in the transmit
   buffer as well.

   By convention, all transmit commands, and only transmit commands,
   shall have the I (IE_CMD_INTR) bit set in the command.  This way,
   when an interrupt arrives at ieintr(), it is immediately possible
   to tell what precisely caused it.  ANY OTHER command-sending
   routines should run at splnet(), and should post an acknowledgement
   to every interrupt they generate.

*/

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/buf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/syslog.h>
#include <sys/device.h>

#include <net/if.h>
#include <net/if_types.h>
#include <net/if_dl.h>
#include <net/route.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#include <net/bpfdesc.h>
#endif

#ifdef INET
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/if_ether.h>
#endif

#include <uvm/uvm_extern.h>

#include <machine/bus.h>
#include <machine/autoconf.h>
#include <machine/cpu.h>
#include <machine/pmap.h>

#include <mvme88k/dev/if_ie.h>
#include <mvme88k/dev/i82596.h>
#include <mvme88k/dev/pcctworeg.h>
#include <mvme88k/dev/pcctwovar.h>

static struct mbuf *last_not_for_us;

#define	IED_RINT	0x01
#define	IED_TINT	0x02
#define	IED_RNR		0x04
#define	IED_CNA		0x08
#define	IED_READFRAME	0x10
#define	IED_ALL		0x1f

#define	ETHER_MIN_LEN	64
#define	ETHER_MAX_LEN	1518
#define	ETHER_ADDR_LEN	6

#define B_PER_F         3               /* recv buffers per frame */
#define MXFRAMES        300             /* max number of recv frames */
#define	MXRXBUF		(MXFRAMES*B_PER_F) /* number of buffers to allocate */
#define	IE_RBUF_SIZE	256		/* size of each receive buffer;
						MUST BE POWER OF TWO */
#define	NTXBUF		2		/* number of transmit commands */
#define	IE_TBUF_SIZE	ETHER_MAX_LEN	/* length of transmit buffer */

struct ie_softc {
	struct device sc_dev;   /* device structure */
	struct intrhand sc_ih, sc_failih;  /* interrupt info */
	char	sc_failintrname[16 + 4];

	caddr_t sc_iobase;      /* KVA of base of 24 bit addr space */
	caddr_t sc_maddr;       /* KVA of base of chip's RAM (16bit addr sp.)*/
	u_int sc_msize;         /* how much RAM we have/use */
	caddr_t sc_reg;         /* KVA of car's register */
	int sc_bustype;

	struct arpcom sc_arpcom;/* system arpcom structure */

	void (*reset_596)(struct ie_softc *);
				/* card dependent reset function */
	void (*chan_attn)(struct ie_softc *);
				/* card dependent attn function */
	void (*run_596)(struct ie_softc *);
				/* card depenent "go on-line" function */
	void (*memcopy)(const void *, void *, size_t);
	                        /* card dependent memory copy function */
	void (*memzero)(void *, size_t);
	                        /* card dependent memory zero function */
	int want_mcsetup;       /* mcsetup flag */
	int promisc;            /* are we in promisc mode? */

	/*
	 * pointers to the 3 major control structures
	 */

	struct ie_sys_conf_ptr *volatile scp;
	struct ie_int_sys_conf_ptr *volatile iscp;
	struct ie_sys_ctl_block *volatile scb;

	/*
	 * pointer and size of a block of KVA where the buffers
	 * are to be allocated from
	 */

	caddr_t buf_area;
	int buf_area_sz;

	/*
	 * the actual buffers (recv and xmit)
	 */

	struct ie_recv_frame_desc *volatile rframes[MXFRAMES];
	struct ie_recv_buf_desc *volatile rbuffs[MXRXBUF];
	char *volatile cbuffs[MXRXBUF];
	int rfhead, rftail, rbhead, rbtail;

	struct ie_xmit_cmd *volatile xmit_cmds[NTXBUF];
	struct ie_xmit_buf *volatile xmit_buffs[NTXBUF];
	u_char *xmit_cbuffs[NTXBUF];
	int xmit_busy;
	int xmit_free;
	int xchead, xctail;

	struct ie_en_addr mcast_addrs[MAXMCAST + 1];
	int mcast_count;

	int nframes;      /* number of frames in use */
	int nrxbuf;       /* number of recv buffs in use */

#ifdef IEDEBUG
	int sc_debug;
#endif
	struct pcctwosoftc	*sc_pcctwo;
};

void ie_obreset(struct ie_softc *);
void ie_obattend(struct ie_softc *);
void ie_obrun(struct ie_softc *);
int ie_setupram(struct ie_softc *sc);

void iewatchdog(struct ifnet *);
int ieintr(void *);
int iefailintr(void *);
int ieinit(struct ie_softc *);
int ieioctl(struct ifnet *, u_long, caddr_t);
void iestart(struct ifnet *);
void iereset(struct ie_softc *);
void ie_readframe(struct ie_softc *, int);
void ie_drop_packet_buffer(struct ie_softc *);
int command_and_wait(struct ie_softc *, int,
    void *volatile, int);
void ierint(struct ie_softc *);
void ietint(struct ie_softc *);
int ieget(struct ie_softc *, struct mbuf **,
		      struct ether_header *, int *);
void setup_bufs(struct ie_softc *);
int mc_setup(struct ie_softc *, void *);
void mc_reset(struct ie_softc *);
static __inline int ether_equal(u_char *, u_char *);
static __inline void ie_ack(struct ie_softc *, u_int);
static __inline void ie_setup_config(struct ie_config_cmd *volatile,
                                          int, int);
static __inline int check_eh(struct ie_softc *, struct ether_header *,
                                  int *);
static __inline int ie_buflen(struct ie_softc *, int);
static __inline int ie_packet_len(struct ie_softc *);
static __inline void iexmit(struct ie_softc *);
static __inline caddr_t Align(caddr_t);

void chan_attn_timeout(void *);
void run_tdr(struct ie_softc *, struct ie_tdr_cmd *);
void iestop(struct ie_softc *);

#ifdef IEDEBUG
void print_rbd(struct ie_recv_buf_desc *volatile);

int in_ierint = 0;
int in_ietint = 0;
#endif

int iematch(struct device *, void *, void *);
void ieattach(struct device *, struct device *, void *);

struct cfattach ie_ca = {
	sizeof(struct ie_softc), iematch, ieattach
};

struct cfdriver ie_cd = {
	NULL, "ie", DV_IFNET
};

/*
 * address generation macros
 */
/* Make 32 bit value from swapped data (err counters access) */
#define MK_32(ptr)	((((u_int)(ptr) >> 16) & 0xffff) | ((u_int)(ptr) << 16))

#define MKADR_32(ptr)  \
			((caddr_t)((((u_int)(ptr) >> 16) & 0xffff) | \
				(((u_int)(ptr) << 16)) + UNCACHED_MEMORY_ADDR))

/* *NOTE* The next macros also converts to physical address! */
#define	ASWAP(ptr)	((((u_int)(ptr) >> 16) & 0x1fff) | ((u_int)(ptr) << 16))

#define SWT_32(to, from) { \
			u_int *t = (u_int *)&to; \
			*t = ((((u_int)from >> 16) & 0x1fff) | ((u_int)from << 16)); \
                        }
/*
 * Here are a few useful functions.  We could have done these as macros, but
 * since we have the inline facility, it makes sense to use that instead.
 */
static inline void
ie_setup_config(cmd, promiscuous, manchester)
	struct ie_config_cmd *volatile cmd;
	int promiscuous, manchester;
{

	cmd->ie_config_count = 0x0e;
	cmd->ie_fifo = 0xc8;
	cmd->ie_save_bad = 0x40;
	cmd->ie_addr_len = 0x2e;
	cmd->ie_priority = 0;
	cmd->ie_ifs = 0x60;
	cmd->ie_slot_low = 0;
	cmd->ie_slot_high = 0xf2;
	cmd->ie_promisc = !!promiscuous | manchester << 2;
	cmd->ie_crs_cdt = 0;
	cmd->ie_min_len = 64;
	cmd->ie_junk = 0xff;
	cmd->ie_dplx = 0x00;
	cmd->ie_miabf = 0x3f;
}

static inline void
ie_ack(sc, mask)
	struct ie_softc *sc;
	u_int mask;
{
	struct ie_sys_ctl_block *volatile scb = sc->scb;

	command_and_wait(sc, scb->ie_status & mask, 0, 0);
}

int
iematch(parent, vcf, args)
	struct device *parent;
	void	*vcf, *args;
{
	struct confargs *ca = args;

	if (badaddr(ca->ca_paddr, 1)) {
		return(0);
	}

	return(1);
}

/*
 * Deep Magic: reset it, then set SCP address again. Pray.
 */
void
ie_obreset(sc)
	struct ie_softc *sc;
{
	struct ieob *volatile ieo = (struct ieob *) sc->sc_reg;
	volatile int t;
	u_long	a;

	a = IE_PORT_RESET;
	ieo->porthigh = a & 0xffff;
	t = 0; t = 1;
	ieo->portlow = a >> 16;
	delay(1000);

	pmap_extract(pmap_kernel(), (vaddr_t)sc->scp, &a);
	a |= IE_PORT_NEWSCPADDR;
	ieo->porthigh = a & 0xffff;
	t = 0; t = 1;
	ieo->portlow = a >> 16;
	delay(1000);
}

void
ie_obattend(sc)
	struct ie_softc *sc;
{
	struct ieob *volatile ieo = (struct ieob *) sc->sc_reg;

	ieo->attn = 1;
}

void
ie_obrun(sc)
	struct ie_softc *sc;
{
}

void
ieattach(parent, self, aux)
	struct device *parent, *self;
	void   *aux;
{
	struct ie_softc *sc = (void *) self;
	struct confargs *ca = aux;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	extern void myetheraddr(u_char *);	/* should be elsewhere */
	struct ieob *volatile ieo;
	paddr_t pa;

	sc->sc_pcctwo = (struct pcctwosoftc *)parent;
	sc->reset_596 = ie_obreset;
	sc->chan_attn = ie_obattend;
	sc->run_596 = ie_obrun;
	sc->memcopy = bcopy;
	sc->memzero = bzero;
	sc->sc_msize = etherlen;
	sc->sc_reg = (void *)ca->ca_paddr;
	ieo = (struct ieob *volatile) sc->sc_reg;

	/* get the first available etherbuf */
	sc->sc_maddr = etherbuf;	/* maddr = vaddr */
	if (sc->sc_maddr == NULL) {
		printf(": too many ethernet boards\n");
		return;
	} else
		etherbuf = NULL;	/* XXX */

	if (pmap_extract(pmap_kernel(), (vaddr_t)sc->sc_maddr, &pa) == FALSE) {
		printf(": pmap_extract() failed!\n");
		return;
	}
	sc->sc_iobase = (caddr_t)pa;	/* iobase = paddr (24 bit) */

	(sc->memzero)(sc->sc_maddr, sc->sc_msize);
	sc->iscp = (struct ie_int_sys_conf_ptr *volatile)
	    sc->sc_maddr; /* @@@@ location zero */
	sc->scb = (struct ie_sys_ctl_block *volatile)
	    roundup((int)sc->iscp + sizeof(struct ie_int_sys_conf_ptr), 16);
	sc->scp = (struct ie_sys_conf_ptr *)
	    roundup((int)sc->scb + sizeof(struct ie_sys_ctl_block), 16);

	sc->scp->ie_bus_use = 0x44;
	pmap_extract(pmap_kernel(), (vaddr_t)sc->iscp, &pa);
	SWT_32(sc->scp->ie_iscp_ptr, pa);
	/*
	 * rest of first page is unused (wasted!), rest of ram
	 * for buffers
	 */
	sc->buf_area = sc->sc_maddr + NBPG;
	sc->buf_area_sz = sc->sc_msize - NBPG;
	myetheraddr(sc->sc_arpcom.ac_enaddr);

	if (ie_setupram(sc) == 0) {
		printf(": RAM CONFIG FAILED!\n");
		/* XXX should reclaim resources? */
		return;
	}
	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
	ifp->if_softc = sc;
	ifp->if_start = iestart;
	ifp->if_ioctl = ieioctl;
	ifp->if_watchdog = iewatchdog;
	ifp->if_flags =
	    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;

	/* Attach the interface. */
	if_attach(ifp);
	ether_ifattach(ifp);

	printf(": address %s\n", ether_sprintf(sc->sc_arpcom.ac_enaddr));

	sc->sc_bustype = ca->ca_bustype;

	sc->sc_ih.ih_fn = ieintr;
	sc->sc_ih.ih_arg = sc;
	sc->sc_ih.ih_wantframe = 0;
	sc->sc_ih.ih_ipl = ca->ca_ipl;

	sc->sc_failih.ih_fn = iefailintr;
	sc->sc_failih.ih_arg = sc;
	sc->sc_failih.ih_wantframe = 0;
	sc->sc_failih.ih_ipl = ca->ca_ipl;

	pcctwointr_establish(PCC2V_IE, &sc->sc_ih, self->dv_xname);
	snprintf(sc->sc_failintrname, sizeof sc->sc_failintrname, "%s_err",
	    self->dv_xname);
	pcctwointr_establish(PCC2V_IEFAIL, &sc->sc_failih, sc->sc_failintrname);

	/* enable device interrupts */
	bus_space_write_1(sc->sc_pcctwo->sc_iot, sc->sc_pcctwo->sc_ioh,
	    PCCTWO_IEICR, PCC2_SC_SNOOP | PCC2_IRQ_IEN | PCC2_IRQ_ICLR |
	      (ca->ca_ipl & PCC2_IRQ_IPL));
	bus_space_write_1(sc->sc_pcctwo->sc_iot, sc->sc_pcctwo->sc_ioh,
	    PCCTWO_IEBERR, PCC2_IRQ_IEN | PCC2_IRQ_ICLR |
	      (ca->ca_ipl & PCC2_IRQ_IPL));
}

/*
 * Device timeout/watchdog routine.  Entered if the device neglects to generate
 * an interrupt after a transmit has been started on it.
 */
void
iewatchdog(ifp)
	struct ifnet *ifp;
{
	struct ie_softc *sc = ifp->if_softc;

	log(LOG_ERR, "%s: device timeout\n", sc->sc_dev.dv_xname);
	++sc->sc_arpcom.ac_if.if_oerrors;

	iereset(sc);
}

int
iefailintr(v)
	void *v;
{
	struct ie_softc *sc = v;

	/* safe: clear irq */
	bus_space_write_1(sc->sc_pcctwo->sc_iot, sc->sc_pcctwo->sc_ioh,
	    PCCTWO_IEICR, PCC2_IRQ_ICLR |
	    bus_space_read_1(sc->sc_pcctwo->sc_iot, sc->sc_pcctwo->sc_ioh,
	      PCCTWO_IEICR));
	/* clear failure */
	bus_space_write_1(sc->sc_pcctwo->sc_iot, sc->sc_pcctwo->sc_ioh,
	    PCCTWO_IEBERR, PCC2_IRQ_ICLR |
	    bus_space_read_1(sc->sc_pcctwo->sc_iot, sc->sc_pcctwo->sc_ioh,
	      PCCTWO_IEBERR));
	/* reset error */
	bus_space_write_1(sc->sc_pcctwo->sc_iot, sc->sc_pcctwo->sc_ioh,
	    PCCTWO_IEERR, PCC2_IEERR_SCLR);

	iereset(sc);
	return (1);
}

/*
 * What to do upon receipt of an interrupt.
 */
int
ieintr(v)
	void *v;
{
	struct ie_softc *sc = v;
	u_short status;

	status = sc->scb->ie_status;

loop:
	/* Ack interrupts FIRST in case we receive more during the ISR. */
	ie_ack(sc, IE_ST_WHENCE & status);
	/* clear irq */
	bus_space_write_1(sc->sc_pcctwo->sc_iot, sc->sc_pcctwo->sc_ioh,
	    PCCTWO_IEICR, PCC2_IRQ_ICLR |
	    bus_space_read_1(sc->sc_pcctwo->sc_iot, sc->sc_pcctwo->sc_ioh,
	      PCCTWO_IEICR));

	if (status & (IE_ST_RECV | IE_ST_RNR)) {
#ifdef IEDEBUG
		in_ierint++;
		if (sc->sc_debug & IED_RINT)
			printf("%s: rint\n", sc->sc_dev.dv_xname);
#endif
		ierint(sc);
#ifdef IEDEBUG
		in_ierint--;
#endif
	}

	if (status & IE_ST_DONE) {
#ifdef IEDEBUG
		in_ietint++;
		if (sc->sc_debug & IED_TINT)
			printf("%s: tint\n", sc->sc_dev.dv_xname);
#endif
		ietint(sc);
#ifdef IEDEBUG
		in_ietint--;
#endif
	}

	if (status & IE_ST_RNR) {
		printf("%s: receiver not ready\n", sc->sc_dev.dv_xname);
		sc->sc_arpcom.ac_if.if_ierrors++;
		iereset(sc);
	}

#ifdef IEDEBUG
	if ((status & IE_ST_ALLDONE) && (sc->sc_debug & IED_CNA))
		printf("%s: cna\n", sc->sc_dev.dv_xname);
#endif

	if ((status = sc->scb->ie_status) & IE_ST_WHENCE)
		goto loop;

	return 1;
}

/*
 * Process a received-frame interrupt.
 */
void
ierint(sc)
	struct ie_softc *sc;
{
	struct ie_sys_ctl_block *volatile scb = sc->scb;
	int i, status;
	static int timesthru = 1024;

	i = sc->rfhead;
	for (;;) {
		status = sc->rframes[i]->ie_fd_status;

		if ((status & IE_FD_COMPLETE) && (status & IE_FD_OK)) {
			sc->sc_arpcom.ac_if.if_ipackets++;
			if (!--timesthru) {
				sc->sc_arpcom.ac_if.if_ierrors +=
				    MK_32(scb->ie_err_crc) +
				    MK_32(scb->ie_err_align) +
				    MK_32(scb->ie_err_resource) +
				    MK_32(scb->ie_err_overrun) +
				    MK_32(scb->ie_err_coll) +
				    MK_32(scb->ie_err_short);
				scb->ie_err_crc = 0;
				scb->ie_err_align = 0;
				scb->ie_err_resource = 0;
				scb->ie_err_overrun = 0;
				scb->ie_err_coll = 0;
				scb->ie_err_short = 0;
				timesthru = 1024;
			}
			ie_readframe(sc, i);
		} else {
			if ((status & IE_FD_RNR) != 0 &&
			    (scb->ie_status & IE_RU_READY) == 0) {
				sc->rframes[0]->ie_fd_buf_desc = ASWAP(sc->rbuffs[0]);
				scb->ie_recv_list = ASWAP(sc->rframes[0]);
				command_and_wait(sc, IE_RU_START, 0, 0);
			}
			break;
		}
		i = (i + 1) % sc->nframes;
	}
}

/*
 * Process a command-complete interrupt.  These are only generated by the
 * transmission of frames.  This routine is deceptively simple, since most of
 * the real work is done by iestart().
 */
void
ietint(sc)
	struct ie_softc *sc;
{
	int status;

	sc->sc_arpcom.ac_if.if_timer = 0;
	sc->sc_arpcom.ac_if.if_flags &= ~IFF_OACTIVE;

	status = sc->xmit_cmds[sc->xctail]->ie_xmit_status;

	if (!(status & IE_STAT_COMPL) || (status & IE_STAT_BUSY))
		printf("ietint: command still busy!\n");

	if (status & IE_STAT_OK) {
		sc->sc_arpcom.ac_if.if_opackets++;
		sc->sc_arpcom.ac_if.if_collisions += status & IE_XS_MAXCOLL;
	} else if (status & IE_STAT_ABORT) {
		sc->sc_arpcom.ac_if.if_oerrors++;
	} else if (status & IE_XS_NOCARRIER) {
		sc->sc_arpcom.ac_if.if_oerrors++;
	} else if (status & IE_XS_LOSTCTS) {
		sc->sc_arpcom.ac_if.if_oerrors++;
	} else if (status & IE_XS_UNDERRUN) {
		sc->sc_arpcom.ac_if.if_oerrors++;
	} else if (status & IE_XS_EXCMAX) {
		sc->sc_arpcom.ac_if.if_collisions += 16;
		sc->sc_arpcom.ac_if.if_oerrors++;
	}

	/*
	 * If multicast addresses were added or deleted while transmitting,
	 * mc_reset() set the want_mcsetup flag indicating that we should do
	 * it.
	 */
	if (sc->want_mcsetup) {
		mc_setup(sc, (caddr_t)sc->xmit_cbuffs[sc->xctail]);
		sc->want_mcsetup = 0;
	}

	/* Done with the buffer. */
	sc->xmit_free++;
	sc->xmit_busy = 0;
	sc->xctail = (sc->xctail + 1) % NTXBUF;

	iestart(&sc->sc_arpcom.ac_if);
}

/*
 * Compare two Ether/802 addresses for equality, inlined and unrolled for
 * speed.  I'd love to have an inline assembler version of this...
 */
static inline int
ether_equal(one, two)
	u_char *one, *two;
{

	if (one[0] != two[0] || one[1] != two[1] || one[2] != two[2] ||
	    one[3] != two[3] || one[4] != two[4] || one[5] != two[5])
		return 0;
	return 1;
}

/*
 * Check for a valid address.  to_bpf is filled in with one of the following:
 *   0 -> BPF doesn't get this packet
 *   1 -> BPF does get this packet
 *   2 -> BPF does get this packet, but we don't
 * Return value is true if the packet is for us, and false otherwise.
 *
 * This routine is a mess, but it's also critical that it be as fast
 * as possible.  It could be made cleaner if we can assume that the
 * only client which will fiddle with IFF_PROMISC is BPF.  This is
 * probably a good assumption, but we do not make it here.  (Yet.)
 */
static inline int
check_eh(sc, eh, to_bpf)
	struct ie_softc *sc;
	struct ether_header *eh;
	int *to_bpf;
{
	int i;

	switch(sc->promisc) {
	case IFF_ALLMULTI:
		/*
		 * Receiving all multicasts, but no unicasts except those
		 * destined for us.
		 */
#if NBPFILTER > 0
		*to_bpf = (sc->sc_arpcom.ac_if.if_bpf != 0); /* BPF gets this packet if anybody cares */
#endif
		if (eh->ether_dhost[0] & 1)
			return 1;
		if (ether_equal(eh->ether_dhost, sc->sc_arpcom.ac_enaddr)) return 1;
		return 0;

	case IFF_PROMISC:
		/*
		 * Receiving all packets.  These need to be passed on to BPF.
		 */
#if NBPFILTER > 0
		*to_bpf = (sc->sc_arpcom.ac_if.if_bpf != 0) ||
		    (sc->sc_arpcom.ac_if.if_bridgeport != NULL);
#else
		*to_bpf = (sc->sc_arpcom.ac_if.if_bridgeport != NULL);
#endif
		/* If for us, accept and hand up to BPF */
		if (ether_equal(eh->ether_dhost, sc->sc_arpcom.ac_enaddr)) return 1;

#if NBPFILTER > 0
		if (*to_bpf && sc->sc_arpcom.ac_if.if_bridgeport == NULL)
			*to_bpf = 2; /* we don't need to see it */
#endif

		/*
		 * Not a multicast, so BPF wants to see it but we don't.
		 */
		if (!(eh->ether_dhost[0] & 1))
			return 1;

		/*
		 * If it's one of our multicast groups, accept it and pass it
		 * up.
		 */
		for (i = 0; i < sc->mcast_count; i++) {
			if (ether_equal(eh->ether_dhost, (u_char *)&sc->mcast_addrs[i])) {
#if NBPFILTER > 0
				if (*to_bpf)
					*to_bpf = 1;
#endif
				return 1;
			}
		}
		return 1;

	case IFF_ALLMULTI | IFF_PROMISC:
		/*
		 * Acting as a multicast router, and BPF running at the same
		 * time.  Whew!  (Hope this is a fast machine...)
		 */
#if NBPFILTER > 0
		*to_bpf = (sc->sc_arpcom.ac_if.if_bpf != 0) ||
		    (sc->sc_arpcom.ac_if.if_bridgeport != NULL);
#else
		*to_bpf = (sc->sc_arpcom.ac_if.if_bridgeport != NULL);
#endif
		/* We want to see multicasts. */
		if (eh->ether_dhost[0] & 1)
			return 1;

		/* We want to see our own packets */
		if (ether_equal(eh->ether_dhost, sc->sc_arpcom.ac_enaddr))
			return 1;

		/* Anything else goes to BPF but nothing else. */
#if NBPFILTER > 0
		if (*to_bpf && sc->sc_arpcom.ac_if.if_bridgeport == NULL)
			*to_bpf = 2;
#endif
		return 1;

	default:
		/*
		 * Only accept unicast packets destined for us, or multicasts
		 * for groups that we belong to.  For now, we assume that the
		 * '596 will only return packets that we asked it for.  This
		 * isn't strictly true (it uses hashing for the multicast
		 * filter), but it will do in this case, and we want to get out
		 * of here as quickly as possible.
		 */
#if NBPFILTER > 0
		*to_bpf = (sc->sc_arpcom.ac_if.if_bpf != 0);
#endif
		return 1;
	}
	return 0;
}

/*
 * We want to isolate the bits that have meaning...  This assumes that
 * IE_RBUF_SIZE is an even power of two.  If somehow the act_len exceeds
 * the size of the buffer, then we are screwed anyway.
 */
static inline int
ie_buflen(sc, head)
	struct ie_softc *sc;
	int head;
{

	return (sc->rbuffs[head]->ie_rbd_actual & (IE_RBUF_SIZE | (IE_RBUF_SIZE - 1)));
}

static inline int
ie_packet_len(sc)
	struct ie_softc *sc;
{
	int i;
	int head = sc->rbhead;
	int acc = 0;

	do {
		if (!(sc->rbuffs[sc->rbhead]->ie_rbd_actual & IE_RBD_USED)) {
#ifdef IEDEBUG
			print_rbd(sc->rbuffs[sc->rbhead]);
#endif
			log(LOG_ERR, "%s: receive descriptors out of sync at %d\n",
			    sc->sc_dev.dv_xname, sc->rbhead);
			iereset(sc);
			return -1;
		}

		i = sc->rbuffs[head]->ie_rbd_actual & IE_RBD_LAST;

		acc += ie_buflen(sc, head);
		head = (head + 1) % sc->nrxbuf;
	} while (!i);

	return acc;
}

/*
 * Setup all necessary artifacts for an XMIT command, and then pass the XMIT
 * command to the chip to be executed.  On the way, if we have a BPF listener
 * also give him a copy.
 */
inline static void
iexmit(sc)
	struct ie_softc *sc;
{

#if NBPFILTER > 0
	/*
	 * If BPF is listening on this interface, let it see the packet before
	 * we push it on the wire.
	 */
	if (sc->sc_arpcom.ac_if.if_bpf)
		bpf_tap(sc->sc_arpcom.ac_if.if_bpf,
		    sc->xmit_cbuffs[sc->xctail],
		    sc->xmit_buffs[sc->xctail]->ie_xmit_flags,
		    BPF_DIRECTION_OUT);
#endif

#if 0
printf("iexmit base %x cmd %x bfd %x to %x\n",
sc->sc_maddr,
sc->xmit_cmds[sc->xctail],
sc->xmit_buffs[sc->xctail],
sc->xmit_cbuffs[sc->xctail]);
#endif
	sc->xmit_buffs[sc->xctail]->ie_xmit_flags |= IE_XMIT_LAST;
	sc->xmit_buffs[sc->xctail]->ie_xmit_next = 0xffffffff;
	SWT_32(sc->xmit_buffs[sc->xctail]->ie_xmit_buf,
		sc->xmit_cbuffs[sc->xctail]);

	sc->xmit_cmds[sc->xctail]->com.ie_cmd_link = 0xffffffff;
	sc->xmit_cmds[sc->xctail]->com.ie_cmd_cmd =
	  IE_CMD_XMIT | IE_CMD_INTR | IE_CMD_LAST | IE_CMD_FLEX;

	sc->xmit_cmds[sc->xctail]->ie_xmit_status = 0;
	sc->xmit_cmds[sc->xctail]->ie_xmit_desc =
	    ASWAP(sc->xmit_buffs[sc->xctail]);
	sc->xmit_cmds[sc->xctail]->ie_xmit_count = 0;

	sc->scb->ie_command_list =
	  ASWAP(sc->xmit_cmds[sc->xctail]);
	command_and_wait(sc, IE_CU_START, 0, 0);

	sc->xmit_busy = 1;
	sc->sc_arpcom.ac_if.if_timer = 5;
}

/*
 * Read data off the interface, and turn it into an mbuf chain.
 *
 * This code is DRAMATICALLY different from the previous version; this
 * version tries to allocate the entire mbuf chain up front, given the
 * length of the data available.  This enables us to allocate mbuf
 * clusters in many situations where before we would have had a long
 * chain of partially-full mbufs.  This should help to speed up the
 * operation considerably.  (Provided that it works, of course.)
 */
int
ieget(sc, mp, ehp, to_bpf)
	struct ie_softc *sc;
	struct mbuf **mp;
	struct ether_header *ehp;
	int *to_bpf;
{
	struct mbuf *m, *top, **mymp;
	int i;
	int offset;
	int totlen, resid;
	int thismboff;
	int head;

	totlen = ie_packet_len(sc);
	if (totlen <= 0)
		return -1;

	i = sc->rbhead;

	/*
	 * Snarf the Ethernet header.
	 */
	(sc->memcopy)((caddr_t)sc->cbuffs[i], (caddr_t)ehp, sizeof *ehp);

	/*
	 * As quickly as possible, check if this packet is for us.
	 * If not, don't waste a single cycle copying the rest of the
	 * packet in.
	 * This is only a consideration when FILTER is defined; i.e., when
	 * we are either running BPF or doing multicasting.
	 */
	if (!check_eh(sc, ehp, to_bpf)) {
		ie_drop_packet_buffer(sc);
		sc->sc_arpcom.ac_if.if_ierrors--; /* just this case, it's not an error */
		return -1;
	}
	totlen -= (offset = sizeof *ehp);

	MGETHDR(*mp, M_DONTWAIT, MT_DATA);
	if (!*mp) {
		ie_drop_packet_buffer(sc);
		return -1;
	}

	m = *mp;
	m->m_pkthdr.rcvif = &sc->sc_arpcom.ac_if;
	m->m_len = MHLEN;
	resid = m->m_pkthdr.len = totlen;
	top = 0;
	mymp = &top;

	/*
	 * This loop goes through and allocates mbufs for all the data we will
	 * be copying in.  It does not actually do the copying yet.
	 */
	do {				/* while (resid > 0) */
		/*
		 * Try to allocate an mbuf to hold the data that we have.  If
		 * we already allocated one, just get another one and stick it
		 * on the end (eventually).  If we don't already have one, try
		 * to allocate an mbuf cluster big enough to hold the whole
		 * packet, if we think it's reasonable, or a single mbuf which
		 * may or may not be big enough.
		 * Got that?
		 */
		if (top) {
			MGET(m, M_DONTWAIT, MT_DATA);
			if (!m) {
				m_freem(top);
				ie_drop_packet_buffer(sc);
				return -1;
			}
			m->m_len = MLEN;
		}

		if (resid >= MINCLSIZE) {
			MCLGET(m, M_DONTWAIT);
			if (m->m_flags & M_EXT)
				m->m_len = min(resid, MCLBYTES);
		} else {
			if (resid < m->m_len) {
				if (!top && resid + max_linkhdr <= m->m_len)
					m->m_data += max_linkhdr;
				m->m_len = resid;
			}
		}
		resid -= m->m_len;
		*mymp = m;
		mymp = &m->m_next;
	} while (resid > 0);

	resid = totlen;
	m = top;
	thismboff = 0;
	head = sc->rbhead;

	/*
	 * Now we take the mbuf chain (hopefully only one mbuf most of the
	 * time) and stuff the data into it.  There are no possible failures at
	 * or after this point.
	 */
	while (resid > 0) {		/* while there's stuff left */
		int thislen = ie_buflen(sc, head) - offset;

		/*
		 * If too much data for the current mbuf, then fill the current
		 * one up, go to the next one, and try again.
		 */
		if (thislen > m->m_len - thismboff) {
			int newlen = m->m_len - thismboff;
			(sc->memcopy)((caddr_t)(sc->cbuffs[head] + offset),
			    mtod(m, caddr_t) + thismboff, (u_int)newlen);
			m = m->m_next;
			thismboff = 0;		/* new mbuf, so no offset */
			offset += newlen;	/* we are now this far
							into the packet */
			resid -= newlen;	/* so there is this much
							left to get */
			continue;
		}

		/*
		 * If there is more than enough space in the mbuf to hold the
		 * contents of this buffer, copy everything in, advance
		 * pointers and so on.
		 */
		if (thislen < m->m_len - thismboff) {
			(sc->memcopy)((caddr_t)(sc->cbuffs[head] + offset),
			    mtod(m, caddr_t) + thismboff, (u_int)thislen);
			thismboff += thislen;	/* we are this far into the mbuf */
			resid -= thislen;	/* and this much is left */
			goto nextbuf;
		}

		/*
		 * Otherwise, there is exactly enough space to put this
		 * buffer's contents into the current mbuf.  Do the combination
		 * of the above actions.
		 */
		(sc->memcopy)((caddr_t)(sc->cbuffs[head] + offset),
		    mtod(m, caddr_t) + thismboff, (u_int)thislen);
		m = m->m_next;
		thismboff = 0;		/* new mbuf, start at the beginning */
		resid -= thislen;	/* and we are this far through */

		/*
		 * Advance all the pointers.  We can get here from either of
		 * the last two cases, but never the first.
		 */
	nextbuf:
		offset = 0;
		sc->rbuffs[head]->ie_rbd_actual = 0;
		sc->rbuffs[head]->ie_rbd_length |= IE_RBD_LAST;
		sc->rbhead = head = (head + 1) % sc->nrxbuf;
		sc->rbuffs[sc->rbtail]->ie_rbd_length &= ~IE_RBD_LAST;
		sc->rbtail = (sc->rbtail + 1) % sc->nrxbuf;
	}

	/*
	 * Unless something changed strangely while we were doing the copy, we
	 * have now copied everything in from the shared memory.
	 * This means that we are done.
	 */
	return 0;
}

/*
 * Read frame NUM from unit UNIT (pre-cached as IE).
 *
 * This routine reads the RFD at NUM, and copies in the buffers from the list
 * of RBD, then rotates the RBD and RFD lists so that the receiver doesn't
 * start complaining.  Trailers are DROPPED---there's no point in wasting time
 * on confusing code to deal with them.  Hopefully, this machine will never ARP
 * for trailers anyway.
 */
void
ie_readframe(sc, num)
	struct ie_softc *sc;
	int num;			/* frame number to read */
{
	int status;
	struct mbuf *m = 0;
	struct ether_header eh;
#if NBPFILTER > 0
	int bpf_gets_it = 0;
#endif

	status = sc->rframes[num]->ie_fd_status;

	/* Immediately advance the RFD list, since we have copied ours now. */
	sc->rframes[num]->ie_fd_status = 0;
	sc->rframes[num]->ie_fd_actual = 0;
	sc->rframes[num]->ie_fd_last |= IE_FD_LAST;
	sc->rframes[sc->rftail]->ie_fd_last &= ~IE_FD_LAST;
	sc->rftail = (sc->rftail + 1) % sc->nframes;
	sc->rfhead = (sc->rfhead + 1) % sc->nframes;

	if (status & IE_FD_OK) {
#if NBPFILTER > 0
		if (ieget(sc, &m, &eh, &bpf_gets_it)) {
#else
		if (ieget(sc, &m, &eh, 0)) {
#endif
			sc->sc_arpcom.ac_if.if_ierrors++;
			return;
		}
	}

#ifdef IEDEBUG
	if (sc->sc_debug & IED_READFRAME)
		printf("%s: frame from ether %s type %x\n", sc->sc_dev.dv_xname,
		    ether_sprintf(eh.ether_shost), (u_int)eh.ether_type);
#endif

	if (!m)
		return;

	if (last_not_for_us) {
		m_freem(last_not_for_us);
		last_not_for_us = 0;
	}

#if NBPFILTER > 0
	/*
	 * Check for a BPF filter; if so, hand it up.
	 * Note that we have to stick an extra mbuf up front, because bpf_mtap
	 * expects to have the ether header at the front.
	 * It doesn't matter that this results in an ill-formatted mbuf chain,
	 * since BPF just looks at the data.  (It doesn't try to free the mbuf,
	 * tho' it will make a copy for tcpdump.)
	 */
	if (bpf_gets_it) {
		/* Pass it up. */
		bpf_mtap_hdr(sc->sc_arpcom.ac_if.if_bpf, (caddr_t)&eh,
		    sizeof(eh), m, BPF_DIRECTION_IN);
	}
	/*
	 * A signal passed up from the filtering code indicating that the
	 * packet is intended for BPF but not for the protocol machinery.
	 * We can save a few cycles by not handing it off to them.
	 */
	if (bpf_gets_it == 2) {
		last_not_for_us = m;
		return;
	}
#endif /* NBPFILTER > 0 */

	/*
	 * In here there used to be code to check destination addresses upon
	 * receipt of a packet.  We have deleted that code, and replaced it
	 * with code to check the address much earlier in the cycle, before
	 * copying the data in; this saves us valuable cycles when operating
	 * as a multicast router or when using BPF.
	 */

	/*
	 * Finally pass this packet up to higher layers.
	 */
	ether_input(&sc->sc_arpcom.ac_if, &eh, m);
}

void
ie_drop_packet_buffer(sc)
	struct ie_softc *sc;
{
	int i;

	do {
		/*
		 * This means we are somehow out of sync.  So, we reset the
		 * adapter.
		 */
		if (!(sc->rbuffs[sc->rbhead]->ie_rbd_actual & IE_RBD_USED)) {
#ifdef IEDEBUG
			print_rbd(sc->rbuffs[sc->rbhead]);
#endif
			log(LOG_ERR, "%s: receive descriptors out of sync at %d\n",
			    sc->sc_dev.dv_xname, sc->rbhead);
			iereset(sc);
			return;
		}

		i = sc->rbuffs[sc->rbhead]->ie_rbd_actual & IE_RBD_LAST;

		sc->rbuffs[sc->rbhead]->ie_rbd_length |= IE_RBD_LAST;
		sc->rbuffs[sc->rbhead]->ie_rbd_actual = 0;
		sc->rbhead = (sc->rbhead + 1) % sc->nrxbuf;
		sc->rbuffs[sc->rbtail]->ie_rbd_length &= ~IE_RBD_LAST;
		sc->rbtail = (sc->rbtail + 1) % sc->nrxbuf;
	} while (!i);
}


/*
 * Start transmission on an interface.
 */
void
iestart(ifp)
	struct ifnet *ifp;
{
	struct ie_softc *sc = ifp->if_softc;
	struct mbuf *m0, *m;
	u_char *buffer;
	u_short len;

	if ((ifp->if_flags & IFF_RUNNING) == 0)
		return;

	if (sc->xmit_free == 0) {
		ifp->if_flags |= IFF_OACTIVE;
		if (!sc->xmit_busy)
			iexmit(sc);
		return;
	}

	do {
		IF_DEQUEUE(&sc->sc_arpcom.ac_if.if_snd, m);
		if (!m)
			break;

		len = 0;
		buffer = sc->xmit_cbuffs[sc->xchead];

		for (m0 = m; m && (len +m->m_len) < IE_TBUF_SIZE;
		                                           m = m->m_next) {
			bcopy(mtod(m, caddr_t), buffer, m->m_len);
			buffer += m->m_len;
			len += m->m_len;
		}
		if (m)
		  printf("%s: tbuf overflow\n", sc->sc_dev.dv_xname);

		m_freem(m0);

		if (len < ETHER_MIN_LEN - ETHER_CRC_LEN) {
			bzero(buffer, ETHER_MIN_LEN - ETHER_CRC_LEN - len);
			len = ETHER_MIN_LEN - ETHER_CRC_LEN;
			buffer += ETHER_MIN_LEN - ETHER_CRC_LEN;
		}

		sc->xmit_buffs[sc->xchead]->ie_xmit_flags = len;

		sc->xmit_free--;
		sc->xchead = (sc->xchead + 1) % NTXBUF;
	} while (sc->xmit_free > 0);

	/* If we stuffed any packets into the card's memory, send now. */
	if ((sc->xmit_free < NTXBUF) && (!sc->xmit_busy))
		iexmit(sc);

	return;
}

/*
 * set up IE's ram space
 */
int
ie_setupram(sc)
	struct ie_softc *sc;
{
	struct ie_int_sys_conf_ptr *volatile iscp;
	struct ie_sys_ctl_block *volatile scb;
	int     s;

	s = splnet();

	iscp = sc->iscp;
	(sc->memzero)((char *) iscp, sizeof *iscp);

	scb = sc->scb;
	(sc->memzero)((char *) scb, sizeof *scb);
	scb->ie_off_timer = 10;
	scb->ie_on_timer = 10000;

	iscp->ie_busy = 1;	/* ie_busy == char */
	SWT_32(iscp->ie_base, sc->scb);

	(sc->reset_596) (sc);
	(sc->chan_attn) (sc);

	delay(100);		/* wait a while... */

	if (iscp->ie_busy) {
		splx(s);
		return 0;
	}
	/*
	 * Acknowledge any interrupts we may have caused...
	 */
	ie_ack(sc, IE_ST_WHENCE);
	splx(s);

	return 1;
}

void
iereset(sc)
	struct ie_softc *sc;
{
	int s = splnet();

	printf("%s: reset\n", sc->sc_dev.dv_xname);

	/* Clear OACTIVE in case we're called from watchdog (frozen xmit). */
	sc->sc_arpcom.ac_if.if_flags &= ~(IFF_UP | IFF_OACTIVE);
	ieioctl(&sc->sc_arpcom.ac_if, SIOCSIFFLAGS, 0);

	/*
	 * Stop i82596 dead in its tracks.
	 */
	if (command_and_wait(sc, IE_RU_ABORT | IE_CU_ABORT, 0, 0))
		printf("%s: abort commands timed out\n", sc->sc_dev.dv_xname);

	if (command_and_wait(sc, IE_RU_DISABLE | IE_CU_STOP, 0, 0))
		printf("%s: disable commands timed out\n", sc->sc_dev.dv_xname);

#ifdef notdef
	if (!check_ie_present(sc, sc->sc_maddr, sc->sc_msize))
		panic("ie disappeared!");
#endif

	sc->sc_arpcom.ac_if.if_flags |= IFF_UP;
	ieioctl(&sc->sc_arpcom.ac_if, SIOCSIFFLAGS, 0);

	splx(s);
}

#if 0
/*
 * This is called if we time out.
 */
static void
chan_attn_timeout(rock)
	caddr_t rock;
{

	*(int *)rock = 1;
}
#endif

/*
 * Send a command to the controller and wait for it to either complete
 * or be accepted, depending on the command.  If the command pointer
 * is null, then pretend that the command is not an action command.
 * If the command pointer is not null, and the command is an action
 * command, wait for
 * ((struct ie_cmd_common *volatile)pcmd)->ie_cmd_status & MASK
 * to become true.
 */
int
command_and_wait(sc, cmd, pcmd, mask)
	struct ie_softc *sc;
	int cmd;
	void *volatile pcmd;
	int mask;
{
	struct ie_cmd_common *volatile cc = pcmd;
	struct ie_sys_ctl_block *volatile scb = sc->scb;
	volatile int timedout = 0;
#if 0
	struct timeout chan_tmo;
	extern int hz;
#endif

	scb->ie_command = (u_short)cmd;

	if (IE_ACTION_COMMAND(cmd) && pcmd) {
		(sc->chan_attn)(sc);

#if 0
                /*
                 * XXX
                 * I don't think this timeout works on suns.
                 * we are at splnet() in the loop, and the timeout
                 * stuff runs at software spl (so it is masked off?).
                 */

		/*
		 * According to the packet driver, the minimum timeout should
		 * be .369 seconds, which we round up to .4.
		 */
		timeout_set(&chan_tmo, chan_attn_timeout, (caddr_t)&timedout);
		timeout_add(&chan_tmo, (caddr_t)&timedout, 2 * hz / 5);
#endif

		/*
		 * Now spin-lock waiting for status.  This is not a very nice
		 * thing to do, but I haven't figured out how, or indeed if, we
		 * can put the process waiting for action to sleep.  (We may
		 * be getting called through some other timeout running in the
		 * kernel.)
		 */
		for (;;)
			if ((cc->ie_cmd_status & mask) || timedout)
				break;
#if 0
		timeout_del(&chan_tmo);
#endif

		return timedout;
	} else {
		/*
		 * Otherwise, just wait for the command to be accepted.
		 */
		(sc->chan_attn)(sc);

		while (scb->ie_command)
			;				/* XXX spin lock */

		return 0;
	}
}

/*
 * Run the time-domain reflectometer.
 */
void
run_tdr(sc, cmd)
	struct ie_softc *sc;
	struct ie_tdr_cmd *cmd;
{
	int result;

	cmd->com.ie_cmd_status = 0;
	cmd->com.ie_cmd_cmd = IE_CMD_TDR | IE_CMD_LAST;
	cmd->com.ie_cmd_link = 0xffffffff;

	sc->scb->ie_command_list = ASWAP(cmd);
	cmd->ie_tdr_time = 0;

	if (command_and_wait(sc, IE_CU_START, cmd, IE_STAT_COMPL) ||
	    !(cmd->com.ie_cmd_status & IE_STAT_OK))
		result = 0x10000; /* XXX */
	else
		result = cmd->ie_tdr_time;

	ie_ack(sc, IE_ST_WHENCE);

	if (result & IE_TDR_SUCCESS)
		return;

	if (result & 0x10000)
		printf("%s: TDR command failed\n", sc->sc_dev.dv_xname);
	else if (result & IE_TDR_XCVR) {
#ifdef IEDEBUG
		printf("%s: transceiver problem\n", sc->sc_dev.dv_xname);
#endif
	} else if (result & IE_TDR_OPEN)
		printf("%s: TDR detected an open %d clocks away\n",
		    sc->sc_dev.dv_xname, result & IE_TDR_TIME);
	else if (result & IE_TDR_SHORT)
		printf("%s: TDR detected a short %d clocks away\n",
		    sc->sc_dev.dv_xname, result & IE_TDR_TIME);
	else
		printf("%s: TDR returned unknown status %x\n",
		    sc->sc_dev.dv_xname, result);
}

#ifdef notdef
/* ALIGN works on 8 byte boundaries.... but 4 byte boundaries are ok for sun */
#define	_ALLOC(p, n)	(bzero(p, n), p += n, p - n)
#define	ALLOC(p, n)	_ALLOC(p, ALIGN(n)) /* XXX convert to this? */
#endif

static inline caddr_t
Align(ptr)
        caddr_t ptr;
{
        u_long  l = (u_long)ptr;

        l = (l + 3) & ~3L;
        return (caddr_t)l;
}

/*
 * setup_bufs: set up the buffers
 *
 * we have a block of KVA at sc->buf_area which is of size sc->buf_area_sz.
 * this is to be used for the buffers.  the chip indexs its control data
 * structures with 16 bit offsets, and it indexes actual buffers with
 * 24 bit addresses.   so we should allocate control buffers first so that
 * we don't overflow the 16 bit offset field.   The number of transmit
 * buffers is fixed at compile time.
 *
 * note: this function was written to be easy to understand, rather than
 *       highly efficient (it isn't in the critical path).
 */
void
setup_bufs(sc)
	struct ie_softc *sc;
{
	caddr_t ptr = sc->buf_area;	/* memory pool */
	int     n, r;

	/*
	 * step 0: zero memory and figure out how many recv buffers and
	 * frames we can have.   XXX CURRENTLY HARDWIRED AT MAX
	 */
	(sc->memzero)(ptr, sc->buf_area_sz);
	ptr = Align(ptr);	/* set alignment and stick with it */

	n = (int)Align((caddr_t)sizeof(struct ie_xmit_cmd)) +
	    (int)Align((caddr_t)sizeof(struct ie_xmit_buf)) + IE_TBUF_SIZE;
	n *= NTXBUF;		/* n = total size of xmit area */

	n = sc->buf_area_sz - n;/* n = free space for recv stuff */

	r = (int)Align((caddr_t)sizeof(struct ie_recv_frame_desc)) +
	    (((int)Align((caddr_t)sizeof(struct ie_recv_buf_desc)) + IE_RBUF_SIZE) * B_PER_F);

	/* r = size of one R frame */

	sc->nframes = n / r;
	if (sc->nframes <= 0)
		panic("ie: bogus buffer calc");
	if (sc->nframes > MXFRAMES)
		sc->nframes = MXFRAMES;

	sc->nrxbuf = sc->nframes * B_PER_F;

#ifdef IEDEBUG
	printf("IEDEBUG: %d frames %d bufs\n", sc->nframes, sc->nrxbuf);
#endif

	/*
	 *  step 1a: lay out and zero frame data structures for transmit and recv
	 */
	for (n = 0; n < NTXBUF; n++) {
		sc->xmit_cmds[n] = (struct ie_xmit_cmd *volatile)ptr;
		ptr = Align(ptr + sizeof(struct ie_xmit_cmd));
	}

	for (n = 0; n < sc->nframes; n++) {
		sc->rframes[n] = (struct ie_recv_frame_desc *volatile)ptr;
		ptr = Align(ptr + sizeof(struct ie_recv_frame_desc));
	}

	/*
	 * step 1b: link together the recv frames and set EOL on last one
	 */
	for (n = 0; n < sc->nframes; n++) {
		sc->rframes[n]->ie_fd_last = IE_FD_FLEX;
		sc->rframes[n]->ie_fd_size = 0;
		sc->rframes[n]->ie_fd_next =
		    ASWAP(sc->rframes[(n + 1) % sc->nframes]);
	}
	sc->rframes[sc->nframes - 1]->ie_fd_last |= IE_FD_LAST;

	/*
	 * step 2a: lay out and zero frame buffer structures for xmit and recv
	 */
	for (n = 0; n < NTXBUF; n++) {
		sc->xmit_buffs[n] = (struct ie_xmit_buf *volatile)ptr;
		ptr = Align(ptr + sizeof(struct ie_xmit_buf));
	}

	for (n = 0; n < sc->nrxbuf; n++) {
		sc->rbuffs[n] = (struct ie_recv_buf_desc *volatile)ptr;
		ptr = Align(ptr + sizeof(struct ie_recv_buf_desc));
	}

	/*
	 * step 2b: link together recv bufs and set EOL on last one
	 */
	for (n = 0; n < sc->nrxbuf; n++) {
		sc->rbuffs[n]->ie_rbd_next =
		    ASWAP(sc->rbuffs[(n + 1) % sc->nrxbuf]);
	}
	sc->rbuffs[sc->nrxbuf - 1]->ie_rbd_length |= IE_RBD_LAST;

	/*
	 * step 3: allocate the actual data buffers for xmit and recv
	 * recv buffer gets linked into recv_buf_desc list here
	 */
	for (n = 0; n < NTXBUF; n++) {
		sc->xmit_cbuffs[n] = (u_char *) ptr;
		ptr = Align(ptr + IE_TBUF_SIZE);
	}

	/* Pointers to last packet sent and next available transmit buffer. */
	sc->xchead = sc->xctail = 0;

	/* Clear transmit-busy flag and set number of free transmit buffers. */
	sc->xmit_busy = 0;
	sc->xmit_free = NTXBUF;

	for (n = 0; n < sc->nrxbuf; n++) {
		sc->cbuffs[n] = (char *) ptr;	/* XXX why char vs uchar? */
		sc->rbuffs[n]->ie_rbd_length = IE_RBUF_SIZE;
		SWT_32(sc->rbuffs[n]->ie_rbd_buffer, ptr);
		ptr = Align(ptr + IE_RBUF_SIZE);
	}

	/*
	 * step 4: set the head and tail pointers on receive to keep track of
	 * the order in which RFDs and RBDs are used.   link in recv frames
	 * and buffer into the scb.
	 */

	sc->rfhead = 0;
	sc->rftail = sc->nframes - 1;
	sc->rbhead = 0;
	sc->rbtail = sc->nrxbuf - 1;

	sc->scb->ie_recv_list = ASWAP(sc->rframes[0]);
	sc->rframes[0]->ie_fd_buf_desc = ASWAP(sc->rbuffs[0]);

#ifdef IEDEBUG
	printf("IE_DEBUG: reserved %d bytes\n", ptr - sc->buf_area);
#endif
}

/*
 * Run the multicast setup command.
 * Called at splnet().
 */
int
mc_setup(sc, ptr)
	struct ie_softc *sc;
	void *ptr;
{
	struct ie_mcast_cmd *volatile cmd = ptr;

	cmd->com.ie_cmd_status = 0;
	cmd->com.ie_cmd_cmd = IE_CMD_MCAST | IE_CMD_LAST;
	cmd->com.ie_cmd_link = 0xffffffff;

	(sc->memcopy)((caddr_t)sc->mcast_addrs, (caddr_t)cmd->ie_mcast_addrs,
	    sc->mcast_count * sizeof *sc->mcast_addrs);

	cmd->ie_mcast_bytes = sc->mcast_count * ETHER_ADDR_LEN; /* grrr... */

	sc->scb->ie_command_list = ASWAP(cmd);
	if (command_and_wait(sc, IE_CU_START, cmd, IE_STAT_COMPL) ||
	    !(cmd->com.ie_cmd_status & IE_STAT_OK)) {
		printf("%s: multicast address setup command failed\n",
		    sc->sc_dev.dv_xname);
		return 0;
	}
	return 1;
}

/*
 * This routine takes the environment generated by check_ie_present() and adds
 * to it all the other structures we need to operate the adapter.  This
 * includes executing the CONFIGURE, IA-SETUP, and MC-SETUP commands, starting
 * the receiver unit, and clearing interrupts.
 *
 * THIS ROUTINE MUST BE CALLED AT splnet() OR HIGHER.
 */
int
ieinit(sc)
	struct ie_softc *sc;
{
	struct ie_sys_ctl_block *volatile scb = sc->scb;
	void *ptr;

	ptr = sc->buf_area;

	/*
	 * Set up bus throttles.
	 */

	{
		if (command_and_wait(sc, IE_CU_THROTTLE, 0, 0)) {
			printf("%s: throttle set command failed\n",
			    sc->sc_dev.dv_xname);
			return 0;
		}
	}

	/*
	 * Send the configure command first.
	 */

	{
		struct ie_config_cmd *volatile cmd = ptr;

		scb->ie_command_list = ASWAP(cmd);
		cmd->com.ie_cmd_status = 0;
		cmd->com.ie_cmd_cmd = IE_CMD_CONFIG | IE_CMD_LAST;
		cmd->com.ie_cmd_link = 0xffffffff;

		ie_setup_config(cmd, sc->promisc, 0);

		if (command_and_wait(sc, IE_CU_START, cmd, IE_STAT_COMPL) ||
		    !(cmd->com.ie_cmd_status & IE_STAT_OK)) {
			printf("%s: configure command failed\n",
			    sc->sc_dev.dv_xname);
			return 0;
		}
	}

	/*
	 * Now send the Individual Address Setup command.
	 */
	{
		struct ie_iasetup_cmd *volatile cmd = ptr;

		scb->ie_command_list = ASWAP(cmd);
		cmd->com.ie_cmd_status = 0;
		cmd->com.ie_cmd_cmd = IE_CMD_IASETUP | IE_CMD_LAST;
		cmd->com.ie_cmd_link = 0xffffffff;

		(sc->memcopy)(sc->sc_arpcom.ac_enaddr,
		      (caddr_t)&cmd->ie_address, sizeof cmd->ie_address);

		if (command_and_wait(sc, IE_CU_START, cmd, IE_STAT_COMPL) ||
		    !(cmd->com.ie_cmd_status & IE_STAT_OK)) {
			printf("%s: individual address setup command failed\n",
			    sc->sc_dev.dv_xname);
			return 0;
		}
	}

	/*
	 * Now run the time-domain reflectometer.
	 */
	run_tdr(sc, ptr);

	/*
	 * Acknowledge any interrupts we have generated thus far.
	 */
	ie_ack(sc, IE_ST_WHENCE);

	/*
	 * Set up the transmit and recv buffers.
	 */
	setup_bufs(sc);

	sc->sc_arpcom.ac_if.if_flags |= IFF_RUNNING; /* tell higher levels that we are here */

	sc->scb->ie_recv_list = ASWAP(sc->rframes[0]);
	command_and_wait(sc, IE_RU_START, 0, 0);

	ie_ack(sc, IE_ST_WHENCE);

	if (sc->run_596)
	  (sc->run_596)(sc);

	return 0;
}

void
iestop(sc)
	struct ie_softc *sc;
{

	command_and_wait(sc, IE_RU_DISABLE, 0, 0);
}

int
ieioctl(ifp, cmd, data)
	struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
{
	struct ie_softc *sc = ifp->if_softc;
	struct ifaddr *ifa = (struct ifaddr *)data;
	int s, error = 0;

	s = splnet();

	switch(cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;

		switch(ifa->ifa_addr->sa_family) {
#ifdef INET
		case AF_INET:
			ieinit(sc);
			arp_ifinit(&sc->sc_arpcom, ifa);
			break;
#endif
		default:
			ieinit(sc);
			break;
		}
		break;

	case SIOCSIFFLAGS:
		sc->promisc = ifp->if_flags & (IFF_PROMISC | IFF_ALLMULTI);
		if ((ifp->if_flags & IFF_UP) == 0 &&
		    (ifp->if_flags & IFF_RUNNING) != 0) {
			/*
			 * If interface is marked down and it is running, then
			 * stop it.
			 */
			iestop(sc);
			ifp->if_flags &= ~IFF_RUNNING;
		} else if ((ifp->if_flags & IFF_UP) != 0 &&
			   (ifp->if_flags & IFF_RUNNING) == 0) {
			/*
			 * If interface is marked up and it is stopped, then
			 * start it.
			 */
			ieinit(sc);
		} else {
			/*
			 * Reset the interface to pick up changes in any other
			 * flags that affect hardware registers.
			 */
			iestop(sc);
			ieinit(sc);
		}
#ifdef IEDEBUG
		if (ifp->if_flags & IFF_DEBUG)
			sc->sc_debug = IED_ALL;
		else
			sc->sc_debug = 0;
#endif
		break;

	default:
		error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			mc_reset(sc);
		error = 0;
	}

	splx(s);
	return error;
}

void
mc_reset(sc)
	struct ie_softc *sc;
{
	struct arpcom *ac = &sc->sc_arpcom;
	struct ether_multi *enm;
	struct ether_multistep step;

	if (ac->ac_multirangecnt > 0) {
		ac->ac_if.if_flags |= IFF_ALLMULTI;
		ieioctl(&ac->ac_if, SIOCSIFFLAGS, (void *)0);
		goto setflag;
	}

	/*
	 * Step through the list of addresses.
	 */
	sc->mcast_count = 0;
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm) {
		if (sc->mcast_count >= MAXMCAST) {
			ac->ac_if.if_flags |= IFF_ALLMULTI;
			ieioctl(&ac->ac_if, SIOCSIFFLAGS, (void *)0);
			goto setflag;
		}

		bcopy(enm->enm_addrlo, &sc->mcast_addrs[sc->mcast_count], 6);
		sc->mcast_count++;
		ETHER_NEXT_MULTI(step, enm);
	}
setflag:
	sc->want_mcsetup = 1;
}

#ifdef IEDEBUG
void
print_rbd(rbd)
	struct ie_recv_buf_desc *volatile rbd;
{

	printf("RBD at %08lx:\nactual %04x, next %04x, buffer %08x\n"
	    "length %04x, mbz %04x\n", (u_long)rbd, rbd->ie_rbd_actual,
	    rbd->ie_rbd_next, rbd->ie_rbd_buffer, rbd->ie_rbd_length,
	    rbd->mbz);
}
#endif

@


1.48
log
@unbreak
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.47 2013/11/27 08:56:31 mpi Exp $ */
@


1.47
log
@Instead of comparing the lower and higher addresses of all the multicast
entries to decide if the IFF_ALLMULTI flag should be set, check if there
is at least one real range between them.

This should not change the behavior of any driver but if you encounter
any problem, feel free to revert the offending chunk and ping me about
it.

ok naddy@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.46 2013/09/05 20:55:57 bluhm Exp $ */
d1860 1
a1860 1
	struct arpcom *ac = sc->sc_arpcom;
@


1.46
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Remove these include lines from mvme68k, mvme88k,
sparc drivers.
test and OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.45 2012/10/10 04:52:16 camield Exp $ */
d1860 1
d1864 6
d1874 1
a1874 1
	ETHER_FIRST_MULTI(step, &sc->sc_arpcom, enm);
d1876 3
a1878 4
		if (sc->mcast_count >= MAXMCAST ||
		    bcmp(enm->enm_addrlo, enm->enm_addrhi, 6) != 0) {
			sc->sc_arpcom.ac_if.if_flags |= IFF_ALLMULTI;
			ieioctl(&sc->sc_arpcom.ac_if, SIOCSIFFLAGS, (void *)0);
@


1.45
log
@Missed the MD bits with the bridgeport change.  Found the hard way by deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.44 2009/10/31 14:31:11 deraadt Exp $ */
a121 1
#include <netinet/in_var.h>
@


1.44
log
@in the absense of link state handling, drivers should still be silent; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.43 2008/11/28 02:44:17 brad Exp $ */
d750 1
a750 1
		    (sc->sc_arpcom.ac_if.if_bridge != NULL);
d752 1
a752 1
		*to_bpf = (sc->sc_arpcom.ac_if.if_bridge != NULL);
d758 1
a758 1
		if (*to_bpf && sc->sc_arpcom.ac_if.if_bridge == NULL)
d790 1
a790 1
		    (sc->sc_arpcom.ac_if.if_bridge != NULL);
d792 1
a792 1
		*to_bpf = (sc->sc_arpcom.ac_if.if_bridge != NULL);
d804 1
a804 1
		if (*to_bpf && sc->sc_arpcom.ac_if.if_bridge == NULL)
@


1.43
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.42 2008/10/02 20:21:13 brad Exp $ */
a664 1
		printf("%s: send aborted\n", sc->sc_dev.dv_xname);
a666 1
		printf("%s: no carrier\n", sc->sc_dev.dv_xname);
a668 1
		printf("%s: lost CTS\n", sc->sc_dev.dv_xname);
a670 1
		printf("%s: DMA underrun\n", sc->sc_dev.dv_xname);
a672 1
		printf("%s: too many collisions\n", sc->sc_dev.dv_xname);
d1473 2
a1474 1
	else if (result & IE_TDR_XCVR)
d1476 2
a1477 1
	else if (result & IE_TDR_OPEN)
@


1.42
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.41 2006/05/08 14:36:10 miod Exp $ */
a1791 1
	struct ifreq *ifr = (struct ifreq *)data;
a1845 17
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_arpcom):
		    ether_delmulti(ifr, &sc->sc_arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware filter
			 * accordingly.
			 */
			if (ifp->if_flags & IFF_RUNNING)
				mc_reset(sc);
			error = 0;
		}
		break;

d1848 6
@


1.41
log
@Replace gazillions of badvaddr() or badwordaddr() calls with badaddr() calls.
With a few prototype declarations shuffling, this finally allows
<machine/locore.h> to die.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.40 2006/04/17 13:39:48 miod Exp $ */
a1796 5
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {
		splx(s);
		return error;
	}

a1797 1

d1865 1
a1865 1
		error = EINVAL;
d1867 1
@


1.40
log
@Revert previous - causes misaligned exceptions in ip4_input()...
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.38 2006/03/25 22:41:41 djm Exp $ */
d346 1
a346 1
	if (badvaddr(ca->ca_paddr, 1)) {
@


1.39
log
@Convert the last remaining net-driver users of ether_input to ether_input_mbuf.

sgec ok martin@@
if_ie ok miod@@
if_de, if_hp not in GENERIC
ok brad@@
@
text
@d943 1
a943 1
	int offset = 0;
d971 1
d1158 13
a1170 4
	/* Check for a BPF filter; if so, hand it up. */
	if (bpf_gets_it)
		bpf_mtap(sc->sc_arpcom.ac_if.if_bpf, m, BPF_DIRECTION_IN);

d1193 1
a1193 1
	ether_input_mbuf(&sc->sc_arpcom.ac_if, m);
@


1.38
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.37 2006/01/17 02:03:53 deraadt Exp $ */
d943 1
a943 1
	int offset;
a970 1
	totlen -= (offset = sizeof *ehp);
d1157 4
a1160 13
	/*
	 * Check for a BPF filter; if so, hand it up.
	 * Note that we have to stick an extra mbuf up front, because bpf_mtap
	 * expects to have the ether header at the front.
	 * It doesn't matter that this results in an ill-formatted mbuf chain,
	 * since BPF just looks at the data.  (It doesn't try to free the mbuf,
	 * tho' it will make a copy for tcpdump.)
	 */
	if (bpf_gets_it) {
		/* Pass it up. */
		bpf_mtap_hdr(sc->sc_arpcom.ac_if.if_bpf, (caddr_t)&eh,
		    sizeof(eh), m, BPF_DIRECTION_IN);
	}
d1183 1
a1183 1
	ether_input(&sc->sc_arpcom.ac_if, &eh, m);
@


1.37
log
@since bcopy/bzero will be assigned to these pointers, get the size_t in the cast right; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.36 2006/01/11 07:22:00 miod Exp $ */
d891 2
a892 1
		    sc->xmit_buffs[sc->xctail]->ie_xmit_flags);
d1169 1
a1169 1
		    sizeof(eh), m);
@


1.36
log
@Switch to __HAVE_DEVICE_REGISTER to find the device we're booted from.
Simpler, better.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.35 2005/12/11 21:44:04 miod Exp $ */
d179 1
a179 1
	void (*memcopy)(const void *, void *, u_int);
d181 1
a181 1
	void (*memzero)(void *, u_int);
@


1.35
log
@Remove unused includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.34 2005/10/12 19:33:48 miod Exp $ */
a413 4

        /* Are we the boot device? */
        if (ca->ca_paddr == bootaddr)
                bootdv = self;
@


1.34
log
@Kill unused global variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.33 2005/07/31 03:52:18 pascoe Exp $ */
a111 1
#include <net/netisr.h>
@


1.33
log
@Introduce bpf_mtap_af and bpf_mtap_hdr to be used when passing a mbuf chain
to bpf with either an address family or other header added.

These helpers only allocate a much smaller struct m_hdr on the stack when
needed, rather than leaving 256 byte struct mbufs on the stack in deep
call paths.  Also removes a fair bit of duplicated code.

commit now, tune after deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.32 2005/01/15 05:24:10 brad Exp $ */
a140 1
struct vm_map *ie_map; /* for obio */
a1243 1
/*printf("iestart\n");*/
@


1.32
log
@make sure interface is in RUNNING state before touching the multicast filters

From NetBSD

NetBSD PR 27678 for details

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.31 2004/08/02 08:35:00 miod Exp $ */
a1171 5
		struct mbuf m0;
		m0.m_len = sizeof eh;
		m0.m_data = (caddr_t)&eh;
		m0.m_next = m;

d1173 2
a1174 1
		bpf_mtap(sc->sc_arpcom.ac_if.if_bpf, &m0);
@


1.31
log
@More include files cleaning:
- move MAX_CPUS constant to <machine/cpu.h>
- do not include <machine/board.h> unless needed. In fact, remove this file
  entirely on mvme88k, and include <machine/mvme*.h> on a
  compiling-for-this-board basis
- keep MAX_CMMUS constant private to the m8820x code
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.30 2004/07/30 19:02:05 miod Exp $ */
d1874 2
a1875 1
			mc_reset(sc);
@


1.30
log
@Move evcount structures inside struct intrhand, this makes more sense and
gives us more counters in the process.

Also clean up intrhand structures and usage, especially move them to SLISTs.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.29 2004/07/02 14:00:43 miod Exp $ */
a131 1
#include <machine/board.h>
@


1.29
log
@Switch mvme88k to evcount, but keep maintaining intrcnt[] too for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.28 2004/04/24 19:51:48 miod Exp $ */
a107 1
#include <sys/evcount.h>
d166 1
a166 1
	struct evcount sc_intrcnt; /* # of interrupts, per ie */
d486 4
a489 2
	pcctwointr_establish(PCC2V_IE, &sc->sc_ih);
	pcctwointr_establish(PCC2V_IEFAIL, &sc->sc_failih);
a497 3

	evcount_attach(&sc->sc_intrcnt, self->dv_xname,
	    (void *)&sc->sc_ih.ih_ipl, &evcount_intr);
a598 1
	sc->sc_intrcnt.ec_count++;
@


1.28
log
@Preliminary switch to an mvme88k bus_space world. Not all drivers have been
converted yet, and they rely upon some linear mappings provided by bus_space.

In order to not impact performance, almost all the bus_space accesses go
through macros and inline functions. This currently restricts us to D16 and
D32 access modes, which are selected at compilation time. Since there are no
plans to support D8 vme devices in the future, this is acceptable for now.

This makes the "len" locator for vme devices go away, and allows to simplify
some code which was using the pcctwo device, and will now directly access
hardware which is known to exist, rather than wait until the device is
attached.

While there, try to enforce more interrupt vector number checks, since these
changes pointed out that dart(4) had been working correctly so far by sheer
luck only.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.27 2004/01/14 20:50:48 miod Exp $ */
d108 1
d167 1
a167 1
	struct evcnt sc_intrcnt; /* # of interrupts, per ie */
d498 2
a499 1
	evcnt_attach(&sc->sc_dev, "intr", &sc->sc_intrcnt);
d601 1
a601 1
	sc->sc_intrcnt.ev_count++;
@


1.27
log
@Do not fill more than the first three fields of cfdriver structures unless
necessary. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.26 2003/10/05 20:27:47 miod Exp $ */
d130 1
d132 1
d135 1
a135 3
#include "pcctwo.h"
#include <mvme88k/dev/pcctworeg.h>
#include <mvme88k/dev/pcctwofunc.h>
d138 2
a139 1
#include <machine/board.h>
d230 1
a230 6
#if NMC > 0
	struct mcreg *sc_mc;
#endif
#if NPCCTWO > 0
	struct pcctworeg *sc_pcc2;
#endif
d349 1
a349 1
	if (badvaddr((unsigned)IIOV(ca->ca_vaddr), 1)){
d352 1
a395 3
/*
 * Taken almost exactly from Bill's if_is.c, then modified beyond recognition.
 */
a404 1
	int     pri = ca->ca_ipl;
d408 1
d415 1
a415 1
	sc->sc_reg = ca->ca_vaddr;
d424 10
a433 3
	if (sc->sc_maddr == NULL) panic("ie: too many ethernet boards");
	if (pmap_extract(pmap_kernel(), (vaddr_t)sc->sc_maddr, &pa) == FALSE)
		panic("ie: pmap_extract");
a435 2
	/*printf("maddrP %x iobaseV %x\n", sc->sc_maddr, sc->sc_iobase);*/

a442 1
	/*printf("scpV %x iscpV %x scbV %x\n", sc->scp, sc->iscp, sc->scb);*/
d479 2
a480 1
	sc->sc_ih.ih_ipl = pri;
d484 1
a484 1
	sc->sc_failih.ih_ipl = pri;
a486 3
	sc->sc_pcc2 = (struct pcctworeg *)ca->ca_master;
	sc->sc_pcc2->pcc2_ieirq = pri | PCC2_SC_SNOOP |
	    PCC2_IRQ_IEN | PCC2_IRQ_ICLR;
d488 8
a495 2
	sc->sc_pcc2->pcc2_iefailirq = pri | PCC2_IRQ_IEN |
	    PCC2_IRQ_ICLR;
d518 1
a518 1
void *v;
d522 13
a534 3
	sc->sc_pcc2->pcc2_ieirq |= PCC2_IRQ_ICLR;	/* safe: clear irq */
	sc->sc_pcc2->pcc2_iefailirq |= PCC2_IRQ_ICLR;	/* clear failure */
	sc->sc_pcc2->pcc2_ieerr = PCC2_IEERR_SCLR;	/* reset error */
a550 1
/*printf("I");*/
d555 5
a559 1
	sc->sc_pcc2->pcc2_ieirq |= PCC2_IRQ_ICLR;	/* clear irq */
@


1.26
log
@Kill vm_offset_t and vm_size_t, in favor of the [pv]addr_t and [pv]size_t
typedefs.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.25 2003/09/29 09:08:19 miod Exp $ */
d290 1
a290 1
	NULL, "ie", DV_IFNET, 0
@


1.25
log
@avaliable -> available
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.24 2003/06/02 07:06:56 deraadt Exp $ */
d4 1
a4 1
 * Copyright (c) 1998 Steve Murphree, Jr. 
d62 1
a62 1
 * Converted to SUN ie driver by Charles D. Cranor, 
d197 1
a197 1
	 * pointer and size of a block of KVA where the buffers 
d200 1
a200 1
        
d346 1
a346 1
int 
d356 1
a356 1
	return(1);                      
d413 1
a413 1
	vm_offset_t pa;
d536 1
a536 1
	register u_short status;
d607 1
a607 1
				    MK_32(scb->ie_err_crc) + 
d609 1
a609 1
				    MK_32(scb->ie_err_resource) + 
d908 1
a908 1
	sc->scb->ie_command_list = 
d924 1
a924 1
 * operation considerably.  (Provided that it works, of course.)  
d1255 1
a1255 1
		for (m0 = m; m && (len +m->m_len) < IE_TBUF_SIZE; 
d1288 1
a1288 1
int 
d1377 3
a1379 3
 * command, wait for 
 * ((struct ie_cmd_common *volatile)pcmd)->ie_cmd_status & MASK 
 * to become true.  
d1517 1
a1517 1
void 
d1734 1
a1734 1
		(sc->memcopy)(sc->sc_arpcom.ac_enaddr, 
d1783 1
a1783 1
	register struct ifnet *ifp;
@


1.24
log
@licence cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.23 2003/01/28 01:37:52 jason Exp $ */
d428 1
a428 1
	/* get the first avaliable etherbuf */
@


1.23
log
@pad < minimal length packets with 0's; based on netbsd; tested by miod
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.22 2002/03/14 01:26:39 millert Exp $ */
a31 3
 *    and
 *      This product includes software developed under OpenBSD by
 *	Theo de Raadt for Willowglen Singapore.
@


1.22
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.21 2002/02/05 23:15:33 miod Exp $ */
d1268 7
a1274 1
		len = max(len, ETHER_MIN_LEN);
@


1.21
log
@I wonder how those two were not commited among the "volatile police" two
weeks ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.20 2002/01/14 21:34:38 miod Exp $ */
d178 1
a178 1
	void (*reset_596) __P((struct ie_softc *));
d180 1
a180 1
	void (*chan_attn) __P((struct ie_softc *));
d182 1
a182 1
	void (*run_596) __P((struct ie_softc *));
d184 1
a184 1
	void (*memcopy) __P((const void *, void *, u_int));
d186 1
a186 1
	void (*memzero) __P((void *, u_int));
d240 37
a276 37
void ie_obreset __P((struct ie_softc *));
void ie_obattend __P((struct ie_softc *));
void ie_obrun __P((struct ie_softc *));
int ie_setupram __P((struct ie_softc *sc));

void iewatchdog __P((struct ifnet *));
int ieintr __P((void *));
int iefailintr __P((void *));
int ieinit __P((struct ie_softc *));
int ieioctl __P((struct ifnet *, u_long, caddr_t));
void iestart __P((struct ifnet *));
void iereset __P((struct ie_softc *));
void ie_readframe __P((struct ie_softc *, int));
void ie_drop_packet_buffer __P((struct ie_softc *));
int command_and_wait __P((struct ie_softc *, int,
    void *volatile, int));
void ierint __P((struct ie_softc *));
void ietint __P((struct ie_softc *));
int ieget __P((struct ie_softc *, struct mbuf **,
		      struct ether_header *, int *));
void setup_bufs __P((struct ie_softc *));
int mc_setup __P((struct ie_softc *, void *));
void mc_reset __P((struct ie_softc *));
static __inline int ether_equal __P((u_char *, u_char *));
static __inline void ie_ack __P((struct ie_softc *, u_int));
static __inline void ie_setup_config __P((struct ie_config_cmd *volatile,
                                          int, int));
static __inline int check_eh __P((struct ie_softc *, struct ether_header *,
                                  int *));
static __inline int ie_buflen __P((struct ie_softc *, int));
static __inline int ie_packet_len __P((struct ie_softc *));
static __inline void iexmit __P((struct ie_softc *));
static __inline caddr_t Align __P((caddr_t));

void chan_attn_timeout __P((void *));
void run_tdr __P((struct ie_softc *, struct ie_tdr_cmd *));
void iestop __P((struct ie_softc *));
d279 1
a279 1
void print_rbd __P((struct ie_recv_buf_desc *volatile));
d285 2
a286 2
int iematch __P((struct device *, void *, void *));
void ieattach __P((struct device *, struct device *, void *));
@


1.20
log
@volatile police.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.19 2001/12/22 18:45:35 smurph Exp $ */
d255 1
a255 1
    void volatile *, int));
@


1.19
log
@Correct badvaddr() usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.18 2001/12/16 23:49:46 miod Exp $ */
d195 3
a197 3
	volatile struct ie_sys_conf_ptr *scp;
	volatile struct ie_int_sys_conf_ptr *iscp;
	volatile struct ie_sys_ctl_block *scb;
d211 3
a213 3
	volatile struct ie_recv_frame_desc *rframes[MXFRAMES];
	volatile struct ie_recv_buf_desc *rbuffs[MXRXBUF];
	volatile char *cbuffs[MXRXBUF];
d216 2
a217 2
	volatile struct ie_xmit_cmd *xmit_cmds[NTXBUF];
	volatile struct ie_xmit_buf *xmit_buffs[NTXBUF];
d265 1
a265 1
static __inline void ie_setup_config __P((volatile struct ie_config_cmd *,
d279 1
a279 1
void print_rbd __P((volatile struct ie_recv_buf_desc *));
d319 1
a319 1
	volatile struct ie_config_cmd *cmd;
d344 1
a344 1
	volatile struct ie_sys_ctl_block *scb = sc->scb;
d369 1
a369 1
	volatile struct ieob *ieo = (struct ieob *) sc->sc_reg;
d391 1
a391 1
	volatile struct ieob *ieo = (struct ieob *) sc->sc_reg;
d415 1
a415 1
	volatile struct ieob *ieo;
d425 1
a425 1
	ieo = (volatile struct ieob *) sc->sc_reg;
d441 1
a441 1
	sc->iscp = (volatile struct ie_int_sys_conf_ptr *)
d443 1
a443 1
	sc->scb = (volatile struct ie_sys_ctl_block *)
d598 1
a598 1
	volatile struct ie_sys_ctl_block *scb = sc->scb;
d1289 2
a1290 2
	volatile struct ie_int_sys_conf_ptr *iscp;
	volatile struct ie_sys_ctl_block *scb;
d1375 1
a1375 1
 * ((volatile struct ie_cmd_common *)pcmd)->ie_cmd_status & MASK 
d1382 1
a1382 1
	volatile void *pcmd;
d1385 2
a1386 2
	volatile struct ie_cmd_common *cc = pcmd;
	volatile struct ie_sys_ctl_block *scb = sc->scb;
d1555 1
a1555 1
		sc->xmit_cmds[n] = (volatile struct ie_xmit_cmd *) ptr;
d1560 1
a1560 1
		sc->rframes[n] = (volatile struct ie_recv_frame_desc *) ptr;
d1579 1
a1579 1
		sc->xmit_buffs[n] = (volatile struct ie_xmit_buf *) ptr;
d1584 1
a1584 1
		sc->rbuffs[n] = (volatile struct ie_recv_buf_desc *) ptr;
d1648 1
a1648 1
	volatile struct ie_mcast_cmd *cmd = ptr;
d1681 1
a1681 1
	volatile struct ie_sys_ctl_block *scb = sc->scb;
d1703 1
a1703 1
		volatile struct ie_config_cmd *cmd = ptr;
d1724 1
a1724 1
		volatile struct ie_iasetup_cmd *cmd = ptr;
d1901 1
a1901 1
	volatile struct ie_recv_buf_desc *rbd;
@


1.18
log
@Revert the mvme88k to 20011212. Recent changes had not been merged correctly,
and I am fed up with dissecting diffs to put back code that disappeared.
This will likely be fixed shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.16 2001/11/28 16:13:28 art Exp $ */
a354 1
	int ret;
d356 1
a356 1
	if ((ret = badvaddr((unsigned)IIOV(ca->ca_vaddr), 1)) <=0){
@


1.18.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.20 2002/01/14 21:34:38 miod Exp $ */
d195 3
a197 3
	struct ie_sys_conf_ptr *volatile scp;
	struct ie_int_sys_conf_ptr *volatile iscp;
	struct ie_sys_ctl_block *volatile scb;
d211 3
a213 3
	struct ie_recv_frame_desc *volatile rframes[MXFRAMES];
	struct ie_recv_buf_desc *volatile rbuffs[MXRXBUF];
	char *volatile cbuffs[MXRXBUF];
d216 2
a217 2
	struct ie_xmit_cmd *volatile xmit_cmds[NTXBUF];
	struct ie_xmit_buf *volatile xmit_buffs[NTXBUF];
d265 1
a265 1
static __inline void ie_setup_config __P((struct ie_config_cmd *volatile,
d279 1
a279 1
void print_rbd __P((struct ie_recv_buf_desc *volatile));
d319 1
a319 1
	struct ie_config_cmd *volatile cmd;
d344 1
a344 1
	struct ie_sys_ctl_block *volatile scb = sc->scb;
d355 1
d357 1
a357 1
	if (badvaddr((unsigned)IIOV(ca->ca_vaddr), 1)){
d370 1
a370 1
	struct ieob *volatile ieo = (struct ieob *) sc->sc_reg;
d392 1
a392 1
	struct ieob *volatile ieo = (struct ieob *) sc->sc_reg;
d416 1
a416 1
	struct ieob *volatile ieo;
d426 1
a426 1
	ieo = (struct ieob *volatile) sc->sc_reg;
d442 1
a442 1
	sc->iscp = (struct ie_int_sys_conf_ptr *volatile)
d444 1
a444 1
	sc->scb = (struct ie_sys_ctl_block *volatile)
d599 1
a599 1
	struct ie_sys_ctl_block *volatile scb = sc->scb;
d1290 2
a1291 2
	struct ie_int_sys_conf_ptr *volatile iscp;
	struct ie_sys_ctl_block *volatile scb;
d1376 1
a1376 1
 * ((struct ie_cmd_common *volatile)pcmd)->ie_cmd_status & MASK 
d1383 1
a1383 1
	void *volatile pcmd;
d1386 2
a1387 2
	struct ie_cmd_common *volatile cc = pcmd;
	struct ie_sys_ctl_block *volatile scb = sc->scb;
d1556 1
a1556 1
		sc->xmit_cmds[n] = (struct ie_xmit_cmd *volatile)ptr;
d1561 1
a1561 1
		sc->rframes[n] = (struct ie_recv_frame_desc *volatile)ptr;
d1580 1
a1580 1
		sc->xmit_buffs[n] = (struct ie_xmit_buf *volatile)ptr;
d1585 1
a1585 1
		sc->rbuffs[n] = (struct ie_recv_buf_desc *volatile)ptr;
d1649 1
a1649 1
	struct ie_mcast_cmd *volatile cmd = ptr;
d1682 1
a1682 1
	struct ie_sys_ctl_block *volatile scb = sc->scb;
d1704 1
a1704 1
		struct ie_config_cmd *volatile cmd = ptr;
d1725 1
a1725 1
		struct ie_iasetup_cmd *volatile cmd = ptr;
d1902 1
a1902 1
	struct ie_recv_buf_desc *volatile rbd;
@


1.18.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.18.2.1 2002/01/31 22:55:17 niklas Exp $ */
d178 1
a178 1
	void (*reset_596)(struct ie_softc *);
d180 1
a180 1
	void (*chan_attn)(struct ie_softc *);
d182 1
a182 1
	void (*run_596)(struct ie_softc *);
d184 1
a184 1
	void (*memcopy)(const void *, void *, u_int);
d186 1
a186 1
	void (*memzero)(void *, u_int);
d240 37
a276 37
void ie_obreset(struct ie_softc *);
void ie_obattend(struct ie_softc *);
void ie_obrun(struct ie_softc *);
int ie_setupram(struct ie_softc *sc);

void iewatchdog(struct ifnet *);
int ieintr(void *);
int iefailintr(void *);
int ieinit(struct ie_softc *);
int ieioctl(struct ifnet *, u_long, caddr_t);
void iestart(struct ifnet *);
void iereset(struct ie_softc *);
void ie_readframe(struct ie_softc *, int);
void ie_drop_packet_buffer(struct ie_softc *);
int command_and_wait(struct ie_softc *, int,
    void *volatile, int);
void ierint(struct ie_softc *);
void ietint(struct ie_softc *);
int ieget(struct ie_softc *, struct mbuf **,
		      struct ether_header *, int *);
void setup_bufs(struct ie_softc *);
int mc_setup(struct ie_softc *, void *);
void mc_reset(struct ie_softc *);
static __inline int ether_equal(u_char *, u_char *);
static __inline void ie_ack(struct ie_softc *, u_int);
static __inline void ie_setup_config(struct ie_config_cmd *volatile,
                                          int, int);
static __inline int check_eh(struct ie_softc *, struct ether_header *,
                                  int *);
static __inline int ie_buflen(struct ie_softc *, int);
static __inline int ie_packet_len(struct ie_softc *);
static __inline void iexmit(struct ie_softc *);
static __inline caddr_t Align(caddr_t);

void chan_attn_timeout(void *);
void run_tdr(struct ie_softc *, struct ie_tdr_cmd *);
void iestop(struct ie_softc *);
d279 1
a279 1
void print_rbd(struct ie_recv_buf_desc *volatile);
d285 2
a286 2
int iematch(struct device *, void *, void *);
void ieattach(struct device *, struct device *, void *);
@


1.18.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d1268 1
a1268 7

		if (len < ETHER_MIN_LEN - ETHER_CRC_LEN) {
			bzero(buffer, ETHER_MIN_LEN - ETHER_CRC_LEN - len);
			len = ETHER_MIN_LEN - ETHER_CRC_LEN;
			buffer += ETHER_MIN_LEN - ETHER_CRC_LEN;
		}

@


1.17
log
@Support for MVME197 completed.  Fix SPL defs.
@
text
@d285 1
a285 1
int  iematch  __P((struct device *, void *, void *));
d355 1
d357 1
a357 1
	if (badvaddr((unsigned)IIOV(ca->ca_vaddr), 1)){
d543 1
a543 1
/* printf("I"); */
d892 5
a896 5
	printf("iexmit base %x cmd %x bfd %x to %x\n",
	sc->sc_maddr,
	sc->xmit_cmds[sc->xctail],
	sc->xmit_buffs[sc->xctail],
	sc->xmit_cbuffs[sc->xctail]);
@


1.16
log
@zap some typedefs.
vm_map_t -> struct vm_map *
vm_map_entry_t -> struct vm_map_entry *
simple_lock_data_t -> struct simplelock

(uvm not done yet, coming in the next commit)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.15 2001/11/06 19:53:15 miod Exp $ */
d285 1
a285 1
int iematch __P((struct device *, void *, void *));
a354 1
	int ret;
d356 1
a356 1
	if ((ret = badvaddr((unsigned)IIOV(ca->ca_vaddr), 1)) <=0){
d542 1
a542 1
/*printf("I");*/
d891 5
a895 5
printf("iexmit base %x cmd %x bfd %x to %x\n",
sc->sc_maddr,
sc->xmit_cmds[sc->xctail],
sc->xmit_buffs[sc->xctail],
sc->xmit_cbuffs[sc->xctail]);
@


1.15
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.14 2001/08/26 02:37:07 miod Exp $ */
d144 1
a144 1
vm_map_t ie_map; /* for obio */
@


1.14
log
@Add prototypes, fix compilation warnings, random style fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.13 2001/08/24 19:26:12 miod Exp $ */
d131 1
a131 1
#include <vm/vm.h>
@


1.13
log
@No newline at the end of panic messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.12 2001/08/08 21:01:10 miod Exp $ */
d138 1
d178 6
a183 3
	void (*reset_596)();    /* card dependent reset function */
	void (*chan_attn)();    /* card dependent attn function */
	void (*run_596)();      /* card depenent "go on-line" function */
d240 3
a242 3
static void ie_obreset __P((struct ie_softc *));
static void ie_obattend __P((struct ie_softc *));
static void ie_obrun __P((struct ie_softc *));
d252 3
a254 3
static void ie_readframe __P((struct ie_softc *, int));
static void ie_drop_packet_buffer __P((struct ie_softc *));
static int command_and_wait __P((struct ie_softc *, int,
d256 3
a258 3
/*static*/ void ierint __P((struct ie_softc *));
/*static*/ void ietint __P((struct ie_softc *));
static int ieget __P((struct ie_softc *, struct mbuf **,
d260 17
a276 3
static void setup_bufs __P((struct ie_softc *));
static int mc_setup __P((struct ie_softc *, void *));
static void mc_reset __P((struct ie_softc *));
d285 2
a286 3
int iematch();
void ieattach();
extern void pcctwointr_establish();
d380 1
a380 1
	pmap_extract(pmap_kernel(), sc->scp, &a);
d435 1
a435 1
	if (pmap_extract(pmap_kernel(), sc->sc_maddr, &pa) == FALSE)
d451 1
a451 1
	pmap_extract(pmap_kernel(), sc->iscp, &pa);
d930 1
a930 1
static inline int
d1106 1
a1106 1
static void
d1196 1
a1196 1
static void
d1379 1
a1379 1
static int
d1446 1
a1446 1
static void
d1515 1
a1515 1
static void 
d1529 2
a1530 2
	n = (int)Align(sizeof(struct ie_xmit_cmd)) +
	    (int)Align(sizeof(struct ie_xmit_buf)) + IE_TBUF_SIZE;
d1535 2
a1536 2
	r = (int)Align(sizeof(struct ie_recv_frame_desc)) +
	    (((int)Align(sizeof(struct ie_recv_buf_desc)) + IE_RBUF_SIZE) * B_PER_F);
d1644 1
a1644 1
static int
d1771 1
a1771 1
static void
d1871 1
a1871 1
static void
@


1.12
log
@New timeouts.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.11 2001/06/08 08:09:13 art Exp $ */
d1331 1
a1331 1
		panic("ie disappeared!\n");
d1525 1
a1525 1
		panic("ie: bogus buffer calc\n");
@


1.11
log
@Change the paddr_t pmap_extract(struct pmap *, vaddr_t) interface to
boolean_t pmap_extract(struct pmap *, vaddr_t, paddr_t *).
Matches NetBSD. Tested by various people on various platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.10 2001/03/09 05:44:38 smurph Exp $ */
d1373 1
d1394 2
a1395 1
		timeout(chan_attn_timeout, (caddr_t)&timedout, 2 * hz / 5);
d1409 1
a1409 1
		untimeout(chan_attn_timeout, (caddr_t)&timedout);
@


1.10
log
@kernel will compile with -Werror.  Added intr.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.9 2001/03/07 23:45:51 miod Exp $ */
a163 2
#define CACHED_TO_PHYS(x) pmap_extract(pmap_kernel(), (vm_offset_t)(x))

d363 2
a364 2
	a = (u_long)CACHED_TO_PHYS(sc->scp) |
      IE_PORT_NEWSCPADDR;
d418 2
a419 2
	pa = CACHED_TO_PHYS(sc->sc_maddr);
	if (pa == 0) panic("ie: pmap_extract");
d434 2
a435 1
	SWT_32(sc->scp->ie_iscp_ptr, CACHED_TO_PHYS(sc->iscp));
@


1.9
log
@Fix interrupt handler registration and prototypes.
While there, some warning hunting.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.8 2001/02/20 19:39:32 mickey Exp $ */
d184 1
a184 1
   void (*memzero) __P((void *, u_int));
d212 1
a212 1
   int rfhead, rftail, rbhead, rbtail;
d241 1
d271 1
d342 1
a342 1
	if ((ret = badvaddr(IIOV(ca->ca_vaddr), 1)) <=0){
d521 1
a521 1
void *v;
@


1.8
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.7 2000/03/03 00:54:53 todd Exp $ */
a336 1
	struct cfdata *cf = vcf;
a397 1
	register struct bootpath *bp;
d466 1
d470 1
d1339 1
d1350 1
d1371 1
d1373 1
a1499 2
	volatile struct ie_recv_frame_desc *rfd = (void *) ptr;
	volatile struct ie_recv_buf_desc *rbd;
a1663 1
	int n;
@


1.7
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.6 1999/09/27 18:43:24 smurph Exp $ */
a462 4

#if NBPFILTER > 0
	bpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, sizeof(struct ether_header));
#endif
@


1.6
log
@adding support for MVME188 and MVME197.  Plus 32bit if_ie.
@
text
@d1 1
a1 1
/*	$Id: if_ie.c,v 1.5 1999/05/29 04:41:43 smurph Exp $ */
@


1.6.4.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
@


1.6.4.2
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.10 2001/03/09 05:44:38 smurph Exp $ */
d184 1
a184 1
	void (*memzero) __P((void *, u_int));
d212 1
a212 1
	int rfhead, rftail, rbhead, rbtail;
a240 1
int ie_setupram __P((struct ie_softc *sc));
a269 1
extern void pcctwointr_establish();
d337 1
d341 1
a341 1
	if ((ret = badvaddr((unsigned)IIOV(ca->ca_vaddr), 1)) <=0){
d399 1
d464 4
a471 1
	sc->sc_ih.ih_wantframe = 0;
a474 1
	sc->sc_failih.ih_wantframe = 0;
d523 1
a523 1
	void *v;
a1342 1
#if 0
a1352 1
#endif
a1372 1
#if 0
a1373 1
#endif
d1500 2
d1666 1
@


1.6.4.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.6.4.2 2001/04/18 16:10:55 niklas Exp $ */
d164 2
d365 2
a366 2
	pmap_extract(pmap_kernel(), sc->scp, &a);
	a |= IE_PORT_NEWSCPADDR;
d420 2
a421 2
	if (pmap_extract(pmap_kernel(), sc->sc_maddr, &pa) == FALSE)
		panic("ie: pmap_extract");
d436 1
a436 2
	pmap_extract(pmap_kernel(), sc->iscp, &pa);
	SWT_32(sc->scp->ie_iscp_ptr, pa);
@


1.6.4.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.6.4.3 2001/07/04 10:19:54 niklas Exp $ */
a137 1
#include <mvme88k/dev/pcctwofunc.h>
d177 3
a179 6
	void (*reset_596) __P((struct ie_softc *));
				/* card dependent reset function */
	void (*chan_attn) __P((struct ie_softc *));
				/* card dependent attn function */
	void (*run_596) __P((struct ie_softc *));
				/* card depenent "go on-line" function */
d236 3
a238 3
void ie_obreset __P((struct ie_softc *));
void ie_obattend __P((struct ie_softc *));
void ie_obrun __P((struct ie_softc *));
d248 3
a250 3
void ie_readframe __P((struct ie_softc *, int));
void ie_drop_packet_buffer __P((struct ie_softc *));
int command_and_wait __P((struct ie_softc *, int,
d252 3
a254 3
void ierint __P((struct ie_softc *));
void ietint __P((struct ie_softc *));
int ieget __P((struct ie_softc *, struct mbuf **,
d256 3
a258 17
void setup_bufs __P((struct ie_softc *));
int mc_setup __P((struct ie_softc *, void *));
void mc_reset __P((struct ie_softc *));
static __inline int ether_equal __P((u_char *, u_char *));
static __inline void ie_ack __P((struct ie_softc *, u_int));
static __inline void ie_setup_config __P((volatile struct ie_config_cmd *,
                                          int, int));
static __inline int check_eh __P((struct ie_softc *, struct ether_header *,
                                  int *));
static __inline int ie_buflen __P((struct ie_softc *, int));
static __inline int ie_packet_len __P((struct ie_softc *));
static __inline void iexmit __P((struct ie_softc *));
static __inline caddr_t Align __P((caddr_t));

void chan_attn_timeout __P((void *));
void run_tdr __P((struct ie_softc *, struct ie_tdr_cmd *));
void iestop __P((struct ie_softc *));
d267 3
a269 2
int iematch __P((struct device *, void *, void *));
void ieattach __P((struct device *, struct device *, void *));
d363 1
a363 1
	pmap_extract(pmap_kernel(), (vaddr_t)sc->scp, &a);
d418 1
a418 1
	if (pmap_extract(pmap_kernel(), (vaddr_t)sc->sc_maddr, &pa) == FALSE)
d434 1
a434 1
	pmap_extract(pmap_kernel(), (vaddr_t)sc->iscp, &pa);
d913 1
a913 1
int
d1089 1
a1089 1
void
d1179 1
a1179 1
void
d1331 1
a1331 1
		panic("ie disappeared!");
d1362 1
a1362 1
int
a1372 1
	struct timeout chan_tmo;
d1393 1
a1393 2
		timeout_set(&chan_tmo, chan_attn_timeout, (caddr_t)&timedout);
		timeout_add(&chan_tmo, (caddr_t)&timedout, 2 * hz / 5);
d1407 1
a1407 1
		timeout_del(&chan_tmo);
d1427 1
a1427 1
void
d1496 1
a1496 1
void 
d1510 2
a1511 2
	n = (int)Align((caddr_t)sizeof(struct ie_xmit_cmd)) +
	    (int)Align((caddr_t)sizeof(struct ie_xmit_buf)) + IE_TBUF_SIZE;
d1516 2
a1517 2
	r = (int)Align((caddr_t)sizeof(struct ie_recv_frame_desc)) +
	    (((int)Align((caddr_t)sizeof(struct ie_recv_buf_desc)) + IE_RBUF_SIZE) * B_PER_F);
d1523 1
a1523 1
		panic("ie: bogus buffer calc");
d1625 1
a1625 1
int
d1752 1
a1752 1
void
d1852 1
a1852 1
void
@


1.6.4.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d131 1
a131 1
#include <uvm/uvm_extern.h>
@


1.6.4.6
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.6.4.5 2001/11/13 21:04:14 niklas Exp $ */
d144 1
a144 1
struct vm_map *ie_map; /* for obio */
@


1.6.4.7
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d195 3
a197 3
	struct ie_sys_conf_ptr *volatile scp;
	struct ie_int_sys_conf_ptr *volatile iscp;
	struct ie_sys_ctl_block *volatile scb;
d211 3
a213 3
	struct ie_recv_frame_desc *volatile rframes[MXFRAMES];
	struct ie_recv_buf_desc *volatile rbuffs[MXRXBUF];
	char *volatile cbuffs[MXRXBUF];
d216 2
a217 2
	struct ie_xmit_cmd *volatile xmit_cmds[NTXBUF];
	struct ie_xmit_buf *volatile xmit_buffs[NTXBUF];
d255 1
a255 1
    void *volatile, int));
d265 1
a265 1
static __inline void ie_setup_config __P((struct ie_config_cmd *volatile,
d279 1
a279 1
void print_rbd __P((struct ie_recv_buf_desc *volatile));
d319 1
a319 1
	struct ie_config_cmd *volatile cmd;
d344 1
a344 1
	struct ie_sys_ctl_block *volatile scb = sc->scb;
d355 1
d357 1
a357 1
	if (badvaddr((unsigned)IIOV(ca->ca_vaddr), 1)){
d370 1
a370 1
	struct ieob *volatile ieo = (struct ieob *) sc->sc_reg;
d392 1
a392 1
	struct ieob *volatile ieo = (struct ieob *) sc->sc_reg;
d416 1
a416 1
	struct ieob *volatile ieo;
d426 1
a426 1
	ieo = (struct ieob *volatile) sc->sc_reg;
d442 1
a442 1
	sc->iscp = (struct ie_int_sys_conf_ptr *volatile)
d444 1
a444 1
	sc->scb = (struct ie_sys_ctl_block *volatile)
d599 1
a599 1
	struct ie_sys_ctl_block *volatile scb = sc->scb;
d1290 2
a1291 2
	struct ie_int_sys_conf_ptr *volatile iscp;
	struct ie_sys_ctl_block *volatile scb;
d1376 1
a1376 1
 * ((struct ie_cmd_common *volatile)pcmd)->ie_cmd_status & MASK 
d1383 1
a1383 1
	void *volatile pcmd;
d1386 2
a1387 2
	struct ie_cmd_common *volatile cc = pcmd;
	struct ie_sys_ctl_block *volatile scb = sc->scb;
d1556 1
a1556 1
		sc->xmit_cmds[n] = (struct ie_xmit_cmd *volatile)ptr;
d1561 1
a1561 1
		sc->rframes[n] = (struct ie_recv_frame_desc *volatile)ptr;
d1580 1
a1580 1
		sc->xmit_buffs[n] = (struct ie_xmit_buf *volatile)ptr;
d1585 1
a1585 1
		sc->rbuffs[n] = (struct ie_recv_buf_desc *volatile)ptr;
d1649 1
a1649 1
	struct ie_mcast_cmd *volatile cmd = ptr;
d1682 1
a1682 1
	struct ie_sys_ctl_block *volatile scb = sc->scb;
d1704 1
a1704 1
		struct ie_config_cmd *volatile cmd = ptr;
d1725 1
a1725 1
		struct ie_iasetup_cmd *volatile cmd = ptr;
d1902 1
a1902 1
	struct ie_recv_buf_desc *volatile rbd;
@


1.6.4.8
log
@Merge in -current from about a week ago
@
text
@d178 1
a178 1
	void (*reset_596)(struct ie_softc *);
d180 1
a180 1
	void (*chan_attn)(struct ie_softc *);
d182 1
a182 1
	void (*run_596)(struct ie_softc *);
d184 1
a184 1
	void (*memcopy)(const void *, void *, u_int);
d186 1
a186 1
	void (*memzero)(void *, u_int);
d240 37
a276 37
void ie_obreset(struct ie_softc *);
void ie_obattend(struct ie_softc *);
void ie_obrun(struct ie_softc *);
int ie_setupram(struct ie_softc *sc);

void iewatchdog(struct ifnet *);
int ieintr(void *);
int iefailintr(void *);
int ieinit(struct ie_softc *);
int ieioctl(struct ifnet *, u_long, caddr_t);
void iestart(struct ifnet *);
void iereset(struct ie_softc *);
void ie_readframe(struct ie_softc *, int);
void ie_drop_packet_buffer(struct ie_softc *);
int command_and_wait(struct ie_softc *, int,
    void *volatile, int);
void ierint(struct ie_softc *);
void ietint(struct ie_softc *);
int ieget(struct ie_softc *, struct mbuf **,
		      struct ether_header *, int *);
void setup_bufs(struct ie_softc *);
int mc_setup(struct ie_softc *, void *);
void mc_reset(struct ie_softc *);
static __inline int ether_equal(u_char *, u_char *);
static __inline void ie_ack(struct ie_softc *, u_int);
static __inline void ie_setup_config(struct ie_config_cmd *volatile,
                                          int, int);
static __inline int check_eh(struct ie_softc *, struct ether_header *,
                                  int *);
static __inline int ie_buflen(struct ie_softc *, int);
static __inline int ie_packet_len(struct ie_softc *);
static __inline void iexmit(struct ie_softc *);
static __inline caddr_t Align(caddr_t);

void chan_attn_timeout(void *);
void run_tdr(struct ie_softc *, struct ie_tdr_cmd *);
void iestop(struct ie_softc *);
d279 1
a279 1
void print_rbd(struct ie_recv_buf_desc *volatile);
d285 2
a286 2
int iematch(struct device *, void *, void *);
void ieattach(struct device *, struct device *, void *);
@


1.6.4.9
log
@Sync the SMP branch with 3.3
@
text
@d1268 1
a1268 7

		if (len < ETHER_MIN_LEN - ETHER_CRC_LEN) {
			bzero(buffer, ETHER_MIN_LEN - ETHER_CRC_LEN - len);
			len = ETHER_MIN_LEN - ETHER_CRC_LEN;
			buffer += ETHER_MIN_LEN - ETHER_CRC_LEN;
		}

@


1.6.4.10
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie.c,v 1.6.4.9 2003/03/27 23:32:17 niklas Exp $ */
d32 3
@


1.6.4.11
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d4 1
a4 1
 * Copyright (c) 1998 Steve Murphree, Jr.
d62 1
a62 1
 * Converted to SUN ie driver by Charles D. Cranor,
d197 1
a197 1
	 * pointer and size of a block of KVA where the buffers
d200 1
a200 1

d290 1
a290 1
	NULL, "ie", DV_IFNET
d346 1
a346 1
int
d356 1
a356 1
	return(1);
d413 1
a413 1
	paddr_t pa;
d428 1
a428 1
	/* get the first available etherbuf */
d536 1
a536 1
	u_short status;
d607 1
a607 1
				    MK_32(scb->ie_err_crc) +
d609 1
a609 1
				    MK_32(scb->ie_err_resource) +
d908 1
a908 1
	sc->scb->ie_command_list =
d924 1
a924 1
 * operation considerably.  (Provided that it works, of course.)
d1255 1
a1255 1
		for (m0 = m; m && (len +m->m_len) < IE_TBUF_SIZE;
d1288 1
a1288 1
int
d1377 3
a1379 3
 * command, wait for
 * ((struct ie_cmd_common *volatile)pcmd)->ie_cmd_status & MASK
 * to become true.
d1517 1
a1517 1
void
d1734 1
a1734 1
		(sc->memcopy)(sc->sc_arpcom.ac_enaddr,
d1783 1
a1783 1
	struct ifnet *ifp;
@


1.6.4.12
log
@Merge with the trunk
@
text
@a129 1
#include <machine/bus.h>
a130 1
#include <machine/board.h>
d133 3
a135 1

d138 1
a138 2
#include <mvme88k/dev/pcctworeg.h>
#include <mvme88k/dev/pcctwovar.h>
d229 6
a234 1
	struct pcctwosoftc	*sc_pcctwo;
d353 1
a353 1
	if (badvaddr(ca->ca_paddr, 1)) {
a355 1

d399 3
d411 1
a414 1
	sc->sc_pcctwo = (struct pcctwosoftc *)parent;
d421 1
a421 1
	sc->sc_reg = (void *)ca->ca_paddr;
d430 4
a433 5
	if (sc->sc_maddr == NULL) {
		printf(": too many ethernet boards\n");
		return;
	} else
		etherbuf = NULL;	/* XXX */
d435 1
a435 5
	if (pmap_extract(pmap_kernel(), (vaddr_t)sc->sc_maddr, &pa) == FALSE) {
		printf(": pmap_extract() failed!\n");
		return;
	}
	sc->sc_iobase = (caddr_t)pa;	/* iobase = paddr (24 bit) */
d444 1
d481 1
a481 2
	sc->sc_ih.ih_ipl = ca->ca_ipl;

d485 1
a485 1
	sc->sc_failih.ih_ipl = ca->ca_ipl;
d488 3
d492 2
a493 8

	/* enable device interrupts */
	bus_space_write_1(sc->sc_pcctwo->sc_iot, sc->sc_pcctwo->sc_ioh,
	    PCCTWO_IEICR, PCC2_SC_SNOOP | PCC2_IRQ_IEN | PCC2_IRQ_ICLR |
	      (ca->ca_ipl & PCC2_IRQ_IPL));
	bus_space_write_1(sc->sc_pcctwo->sc_iot, sc->sc_pcctwo->sc_ioh,
	    PCCTWO_IEBERR, PCC2_IRQ_IEN | PCC2_IRQ_ICLR |
	      (ca->ca_ipl & PCC2_IRQ_IPL));
d516 1
a516 1
	void *v;
d520 3
a522 13
	/* safe: clear irq */
	bus_space_write_1(sc->sc_pcctwo->sc_iot, sc->sc_pcctwo->sc_ioh,
	    PCCTWO_IEICR, PCC2_IRQ_ICLR |
	    bus_space_read_1(sc->sc_pcctwo->sc_iot, sc->sc_pcctwo->sc_ioh,
	      PCCTWO_IEICR));
	/* clear failure */
	bus_space_write_1(sc->sc_pcctwo->sc_iot, sc->sc_pcctwo->sc_ioh,
	    PCCTWO_IEBERR, PCC2_IRQ_ICLR |
	    bus_space_read_1(sc->sc_pcctwo->sc_iot, sc->sc_pcctwo->sc_ioh,
	      PCCTWO_IEBERR));
	/* reset error */
	bus_space_write_1(sc->sc_pcctwo->sc_iot, sc->sc_pcctwo->sc_ioh,
	    PCCTWO_IEERR, PCC2_IEERR_SCLR);
d539 1
d544 1
a544 5
	/* clear irq */
	bus_space_write_1(sc->sc_pcctwo->sc_iot, sc->sc_pcctwo->sc_ioh,
	    PCCTWO_IEICR, PCC2_IRQ_ICLR |
	    bus_space_read_1(sc->sc_pcctwo->sc_iot, sc->sc_pcctwo->sc_ioh,
	      PCCTWO_IEICR));
@


1.5
log
@Added vme bus device drivers. MVME328, MVME376, MVME332
@
text
@d1 1
a1 1
/*	$Id: if_ie.c,v 1.4 1999/03/03 22:10:32 jason Exp $ */
d53 1
a53 1
 * Intel 82586 Ethernet chip
d76 1
a76 1
   We run the 82586 in a standard Ethernet mode.  We keep NFRAMES
d80 1
a80 1
   necessary.  (The 586 treats both lists as a simple queue.)  We also
a132 6
/*
 * ugly byte-order hack for SUNs
 */

#define SWAP(x)         (x)

d139 1
a139 1
#include <mvme88k/dev/i82586.h>
d164 1
a164 36

/*
 * Ethernet status, per interface.
 *
 * hardware addresses/sizes to know (all KVA):
 *   sc_iobase = base of chip's 24 bit address space
 *   sc_maddr  = base address of chip RAM as stored in ie_base of iscp
 *   sc_msize  = size of chip's RAM
 *   sc_reg    = address of card dependent registers
 *
 * the chip uses two types of pointers: 16 bit and 24 bit
 *   16 bit pointers are offsets from sc_maddr/ie_base
 *      KVA(16 bit offset) = offset + sc_maddr
 *   24 bit pointers are offset from sc_iobase in KVA
 *      KVA(24 bit address) = address + sc_iobase
 *
 * on the vme/multibus we have the page map to control where ram appears
 * in the address space.   we choose to have RAM start at 0 in the
 * 24 bit address space.   this means that sc_iobase == sc_maddr!
 * to get the phyiscal address of the board's RAM you must take the
 * top 12 bits of the physical address of the register address
 * and or in the 4 bits from the status word as bits 17-20 (remember that
 * the board ignores the chip's top 4 address lines).
 * For example:
 *   if the register is @@ 0xffe88000, then the top 12 bits are 0xffe00000.
 *   to get the 4 bits from the the status word just do status & IEVME_HADDR.
 *   suppose the value is "4".   Then just shift it left 16 bits to get
 *   it into bits 17-20 (e.g. 0x40000).    Then or it to get the
 *   address of RAM (in our example: 0xffe40000).   see the attach routine!
 *
 * on the onboard ie interface the 24 bit address space is hardwired
 * to be 0xff000000 -> 0xffffffff of KVA.   this means that sc_iobase
 * will be 0xff000000.   sc_maddr will be where ever we allocate RAM
 * in KVA.    note that since the SCP is at a fixed address it means
 * that we have to allocate a fixed KVA for the SCP.
 */
d179 1
a179 1
	void (*reset_586)();    /* card dependent reset function */
d181 1
a181 1
	void (*run_586)();      /* card depenent "go on-line" function */
d184 1
a184 1
        void (*memzero) __P((void *, u_int));
a185 2

	
d212 1
a212 1
        int rfhead, rftail, rbhead, rbtail;
d230 4
d235 1
d281 14
a294 10
 *   MK_24 = KVA -> 24 bit address in SUN byte order
 *   MK_16 = KVA -> 16 bit address in INTEL byte order
 *   ST_24 = store a 24 bit address in SUN byte order to INTEL byte order
 */
#define MK_24(base, ptr) ((caddr_t)((u_long)ptr))
#define MK_16(base, ptr) SWAP((u_short)( ((u_long)(ptr)) - ((u_long)(base)) ))
#define ST_24(to, from) { \
                            u_long fval = (u_long)(from); \
                            u_char *t = (u_char *)&(to), *f = (u_char *)&fval; \
                            t[0] = f[2]; t[1] = f[3]; /*t[2] = f[0]*/; t[3] = f[1]; \
d306 2
a307 2
	cmd->ie_config_count = 0x0c;
	cmd->ie_fifo = 8;
d318 2
d340 1
a340 1
	
d342 1
a342 1
	    return(0);
d344 1
a344 1
	return (1);
d364 2
a365 2
	a = (u_long)pmap_extract(pmap_kernel(), (vm_offset_t)sc->scp) |
	    IE_PORT_NEWSCPADDR;
d404 1
a404 1
	sc->reset_586 = ie_obreset;
d406 1
a406 1
	sc->run_586 = ie_obrun;
d412 5
a416 5
	
	/* Are we the boot device? */
	if (ca->ca_paddr == bootaddr)
	bootdv = self;
   
d420 1
a420 1
	pa = pmap_extract(pmap_kernel(), (vm_offset_t)sc->sc_maddr);
d428 1
a428 1
	    sc->sc_maddr; /* @@ location zero */
d435 2
a436 8
	sc->scp->ie_bus_use = 0;	/* 16-bit */
	ST_24(sc->scp->ie_iscp_ptr,
		pmap_extract(pmap_kernel(), (vm_offset_t)sc->iscp));

	/*printf("iscpV(%x) = iscpP(%x) -> scp.ptr@@%x = val:%x\n",
	    sc->iscp, pmap_extract(pmap_kernel(), (vm_offset_t)sc->iscp),
	    &sc->scp->ie_iscp_ptr, sc->scp->ie_iscp_ptr);*/

d597 12
a608 7
				    SWAP(scb->ie_err_crc) + 
				    SWAP(scb->ie_err_align) +
				    SWAP(scb->ie_err_resource) + 
				    SWAP(scb->ie_err_overrun);
				scb->ie_err_crc = scb->ie_err_align =
				    scb->ie_err_resource = scb->ie_err_overrun =
				    0;
d615 2
a616 4
				sc->rframes[0]->ie_fd_buf_desc =
					MK_16(sc->sc_maddr, sc->rbuffs[0]);
				scb->ie_recv_list = 
				  MK_16(sc->sc_maddr, sc->rframes[0]);
d646 1
a646 2
		sc->sc_arpcom.ac_if.if_collisions += 
		  SWAP(status & IE_XS_MAXCOLL);
d801 1
a801 1
		 * '586 will only return packets that we asked it for.  This
d825 1
a825 2
	return (SWAP(sc->rbuffs[head]->ie_rbd_actual)
	    & (IE_RBUF_SIZE | (IE_RBUF_SIZE - 1)));
d874 1
a874 1
		    SWAP(sc->xmit_buffs[sc->xctail]->ie_xmit_flags));
d877 2
a878 1
/*printf("iexmit base %x cmd %x bfd %x to %x\n",
d882 2
a883 1
sc->xmit_cbuffs[sc->xctail]);*/
d885 3
a887 3
	sc->xmit_buffs[sc->xctail]->ie_xmit_next = SWAP(0xffff);
	ST_24(sc->xmit_buffs[sc->xctail]->ie_xmit_buf,
	    MK_24(sc->sc_iobase, sc->xmit_cbuffs[sc->xctail]));
d889 1
a889 1
	sc->xmit_cmds[sc->xctail]->com.ie_cmd_link = SWAP(0xffff);
d891 1
a891 1
	  IE_CMD_XMIT | IE_CMD_INTR | IE_CMD_LAST;
d893 1
a893 1
	sc->xmit_cmds[sc->xctail]->ie_xmit_status = SWAP(0);
d895 2
a896 1
	    MK_16(sc->sc_maddr, sc->xmit_buffs[sc->xctail]);
d899 1
a899 1
	  MK_16(sc->sc_maddr, sc->xmit_cmds[sc->xctail]);
d1068 1
a1068 1
		sc->rbuffs[head]->ie_rbd_actual = SWAP(0);
d1107 2
a1108 1
	sc->rframes[num]->ie_fd_status = SWAP(0);
d1206 1
a1206 1
		sc->rbuffs[sc->rbhead]->ie_rbd_actual = SWAP(0);
d1256 1
a1256 1
		sc->xmit_buffs[sc->xchead]->ie_xmit_flags = SWAP(len);
d1287 2
d1291 1
a1291 2
	iscp->ie_scb_offset = MK_16(sc->sc_maddr, scb);
	ST_24(iscp->ie_base, sc->sc_iobase);
d1293 1
a1293 1
	(sc->reset_586) (sc);
d1324 1
a1324 1
	 * Stop i82586 dead in its tracks.
d1334 1
a1334 1
		panic("ie disappeared!");
d1433 1
a1433 1
	cmd->com.ie_cmd_status = SWAP(0);
d1435 1
a1435 1
	cmd->com.ie_cmd_link = SWAP(0xffff);
d1437 2
a1438 2
	sc->scb->ie_command_list = MK_16(sc->sc_maddr, cmd);
	cmd->ie_tdr_time = SWAP(0);
d1524 1
a1524 1
		panic("ie: bogus buffer calc");
d1551 2
d1554 1
a1554 1
		    MK_16(sc->sc_maddr, sc->rframes[(n + 1) % sc->nframes]);
d1576 1
a1576 1
		    MK_16(sc->sc_maddr, sc->rbuffs[(n + 1) % sc->nrxbuf]);
d1598 2
a1599 2
		sc->rbuffs[n]->ie_rbd_length = SWAP(IE_RBUF_SIZE);
		ST_24(sc->rbuffs[n]->ie_rbd_buffer, MK_24(sc->sc_iobase, ptr));
d1614 2
a1615 2
	sc->scb->ie_recv_list = MK_16(sc->sc_maddr, sc->rframes[0]);
	sc->rframes[0]->ie_fd_buf_desc = MK_16(sc->sc_maddr, sc->rbuffs[0]);
d1633 1
a1633 1
	cmd->com.ie_cmd_status = SWAP(0);
d1635 1
a1635 1
	cmd->com.ie_cmd_link = SWAP(0xffff);
d1640 1
a1640 2
	cmd->ie_mcast_bytes = 
	  SWAP(sc->mcast_count * ETHER_ADDR_LEN); /* grrr... */
d1642 1
a1642 1
	sc->scb->ie_command_list = MK_16(sc->sc_maddr, cmd);
d1671 12
d1685 1
d1689 2
a1690 2
		scb->ie_command_list = MK_16(sc->sc_maddr, cmd);
		cmd->com.ie_cmd_status = SWAP(0);
d1692 1
a1692 1
		cmd->com.ie_cmd_link = SWAP(0xffff);
d1710 2
a1711 2
		scb->ie_command_list = MK_16(sc->sc_maddr, cmd);
		cmd->com.ie_cmd_status = SWAP(0);
d1713 1
a1713 1
		cmd->com.ie_cmd_link = SWAP(0xffff);
d1743 1
a1743 1
	sc->scb->ie_recv_list = MK_16(sc->sc_maddr, sc->rframes[0]);
d1748 2
a1749 2
	if (sc->run_586)
	  (sc->run_586)(sc);
d1894 1
@


1.4
log
@rework check_eh() so that it is bridge aware
@
text
@d1 1
a1 1
/*	$Id: if_ie.c,v 1.3 1999/01/11 05:11:42 millert Exp $ */
a141 4

#if !defined(MVME187)
#include "mc.h"
#endif
a142 6

#if NMC > 0
#include <mvme68k/dev/mcreg.h>
#endif
#if NPCCTWO > 0
#if defined(MVME187)
a143 5
#else
#include <mvme68k/dev/pcctworeg.h>
#endif
#endif

a272 4
#if NMC > 0
	struct mcreg *sc_mc;
#endif
#if NPCCTWO > 0
a273 1
#endif
a373 1
	    printf("==> ie: failed address check returning %ld.\n", ret);
d444 6
a449 5

        /* Are we the boot device? */
        if (ca->ca_paddr == bootaddr)
                bootdv = self;

d451 1
d453 1
a453 1
	if (pa == 0) panic("ie pmap_extract");
d515 7
a521 23
	switch (sc->sc_bustype) {
#if NMC > 0
	case BUS_MC:
		mcintr_establish(MCV_IE, &sc->sc_ih);
		sc->sc_mc = (struct mcreg *)ca->ca_master;
		sc->sc_mc->mc_ieirq = pri | MC_SC_SNOOP | MC_IRQ_IEN |
		    MC_IRQ_ICLR;
		mcintr_establish(MCV_IEFAIL, &sc->sc_failih);
		sc->sc_mc->mc_iefailirq = pri | MC_IRQ_IEN | MC_IRQ_ICLR;
		break;
#endif
#if NPCCTWO > 0
	case BUS_PCCTWO:
		pcctwointr_establish(PCC2V_IE, &sc->sc_ih);
		sc->sc_pcc2 = (struct pcctworeg *)ca->ca_master;
		sc->sc_pcc2->pcc2_ieirq = pri | PCC2_SC_SNOOP |
		    PCC2_IRQ_IEN | PCC2_IRQ_ICLR;
		pcctwointr_establish(PCC2V_IEFAIL, &sc->sc_failih);
		sc->sc_pcc2->pcc2_iefailirq = pri | PCC2_IRQ_IEN |
		    PCC2_IRQ_ICLR;
		break;
#endif
	}
d548 3
a550 16
	switch (sc->sc_bustype) {
#if NMC > 0
	case BUS_MC:
		sc->sc_mc->mc_ieirq |= MC_IRQ_ICLR;		/* safe: clear irq */
		sc->sc_mc->mc_iefailirq |= MC_IRQ_ICLR;		/* clear failure */
		sc->sc_mc->mc_ieerr = MC_IEERR_SCLR;		/* reset error */
		break;
#endif
#if NPCCTWO > 0
	case BUS_PCCTWO:
		sc->sc_pcc2->pcc2_ieirq |= PCC2_IRQ_ICLR;	/* safe: clear irq */
		sc->sc_pcc2->pcc2_iefailirq |= PCC2_IRQ_ICLR;	/* clear failure */
		sc->sc_pcc2->pcc2_ieerr = PCC2_IEERR_SCLR;	/* reset error */
		break;
#endif
	}
d572 1
a572 12
	switch (sc->sc_bustype) {
#if NMC > 0
	case BUS_MC:
		sc->sc_mc->mc_ieirq |= MC_IRQ_ICLR;		/* clear irq */
		break;
#endif
#if NPCCTWO > 0
	case BUS_PCCTWO:
		sc->sc_pcc2->pcc2_ieirq |= PCC2_IRQ_ICLR;	/* clear irq */
		break;
#endif
	}
@


1.3
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$Id: if_ie.c,v 1.2 1998/12/15 05:52:30 smurph Exp $ */
d832 4
a835 1
		*to_bpf = (sc->sc_arpcom.ac_if.if_bpf != 0);
d841 1
a841 1
		if (*to_bpf)
d872 4
a875 1
		*to_bpf = (sc->sc_arpcom.ac_if.if_bpf != 0);
d887 1
a887 1
		if (*to_bpf)
@


1.2
log
@Commit for the first real OpenBSD mvme88k port.
@
text
@d1 1
a1 1
/*	$Id: if_ie.c,v 1.1.1.1 1997/03/03 19:32:06 rahnds Exp $ */
d1419 1
a1419 1
		panic("ie disappeared!\n");
d1609 1
a1609 1
		panic("ie: bogus buffer calc\n");
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$Id: if_ie.c,v 1.1 1996/05/09 00:58:36 build Exp build $ */
d4 1
d292 1
a292 1
	struct pcc2reg *sc_pcc2;
d343 1
a343 2

#define MK_24(base, ptr) ((caddr_t)(((u_long)(ptr)) & 0x00ffffff))
d348 1
a348 1
                            t[0] = f[2]; t[1] = f[3]; t[2] = 0; t[3] = f[1]; \
d391 5
a395 6

#if defined(MVME187)
	caddr_t base;
	if (cputyp != CPU_187)
	{
		return 0;
d397 1
a397 26

	/*
	 * If bus or name do not match, fail.
	 */
	if (ca->ca_bustype != BUS_PCCTWO ||
		strcmp(cf->cf_driver->cd_name, "ie")) {
		return 0;
	}

	base = (caddr_t)cf->cf_loc[0];

	if (badpaddr(base, 1) == -1) {
		return 0;
	}

	/*
	 * tell our parent our requirements
	 */
	ca->ca_paddr = (caddr_t)LANCE_ADDR;
	ca->ca_size = 0x1000;
	ca->ca_ipl = IPL_NET;

	return 1;
#else
	return (!badvaddr(ca->ca_vaddr, 4));
#endif
a409 1
	u_long	b;
a410 4
	/*
	 * Convert a to the format the chip expects before writing
	 * the high and low (16 bit) words of the CPU port.
	 */
d412 1
a412 2
	ST_24(b, a);
	ieo->porthigh = b >> 16;
d414 1
a414 1
	ieo->portlow = b & 0xffff;
d417 3
a419 4
	a = (u_long)pmap_extract(pmap_kernel(), (vm_offset_t)sc->scp)
						| IE_PORT_NEWSCPADDR;
	ST_24(b, a);
	ieo->porthigh = b >> 16;
d421 1
a421 1
	ieo->portlow = b & 0xffff;
a465 2
#if XXXX
	/* Don't know what this yet XXX nivas */
a468 1
#endif
a469 1
#if 0
a486 22
#endif /* 0 */
	sc->sc_maddr = etherbuf;	/* maddr = vaddr */
	pa = pmap_extract(pmap_kernel(), (vm_offset_t)sc->sc_maddr);
	if (pa == 0) panic("ie pmap_extract");
	sc->sc_iobase = (caddr_t)pa;	/* iobase = paddr (24 bit) */

	(sc->memzero)(sc->sc_maddr, sc->sc_msize);

	sc->scb = (volatile struct ie_sys_ctl_block *)
	    			sc->sc_maddr; /* @@ location zero */
	sc->scp = (struct ie_sys_conf_ptr *)
	    roundup((int)sc->scb + sizeof(struct ie_sys_ctl_block), 16);
	sc->iscp = (volatile struct ie_int_sys_conf_ptr *)
	    roundup((int)sc->scp + sizeof(struct ie_sys_conf_ptr), 16);

	/*printf("maddrV %x iobaseP %x\n", sc->sc_maddr, sc->sc_iobase);*/
	/*printf("scpV %x iscpV %x scbV %x\n", sc->scp, sc->iscp, sc->scb);*/

	/*
	 * init scp; iscp will be inited later in ie_setupram().
	 */
	sc->scp->ie_bus_use = 0;	/* 8-bit */
d547 3
a549 4

		intr_establish(PCC2_VECT + LANCIRQ, &sc->sc_ih);
		sc->sc_pcc2 = (struct pcc2reg *)ca->ca_parent;
		sc->sc_pcc2->pcc2_lancirq = pri |
d551 2
a552 2
		intr_establish(PCC2_VECT + LANCERR, &sc->sc_failih);
		sc->sc_pcc2->pcc2_lancerrirq = pri | PCC2_IRQ_IEN |
d593 3
a595 3
		sc->sc_pcc2->pcc2_lancirq |= PCC2_IRQ_ICLR;	/* safe: clear irq */
		sc->sc_pcc2->pcc2_lancerrirq |= PCC2_IRQ_ICLR;	/* clear failure */
		sc->sc_pcc2->pcc2_lancerrstat = PCC2_IEERR_SCLR;	/* reset error */
d628 1
a628 1
		sc->sc_pcc2->pcc2_lancirq |= PCC2_IRQ_ICLR;	/* clear irq */
@


1.1.1.1
log
@Third try at importing the mvme88k port. This is a working kernel
from nivas.
Userland and compiler still need to be worked on.
Make certain what directory the import is done from.
@
text
@@
