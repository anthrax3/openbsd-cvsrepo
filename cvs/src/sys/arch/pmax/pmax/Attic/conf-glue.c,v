head	1.11;
access;
symbols
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	UBC_SYNC_A:1.11
	UBC_SYNC_B:1.11
	OPENBSD_2_9:1.10.0.10
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.10.0.8
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.6
	OPENBSD_2_7_BASE:1.10
	SMP:1.10.0.4
	SMP_BASE:1.10
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2001.06.24.23.48.33;	author deraadt;	state dead;
branches;
next	1.10;

1.10
date	99.08.30.21.03.26;	author maja;	state Exp;
branches
	1.10.4.1;
next	1.9;

1.9
date	99.01.11.05.11.50;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.05.10.04.01.22;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	98.01.29.15.44.11;	author graichen;	state Exp;
branches;
next	1.6;

1.6
date	97.06.10.14.20.06;	author graichen;	state Exp;
branches;
next	1.5;

1.5
date	97.02.03.10.30.53;	author graichen;	state Exp;
branches;
next	1.4;

1.4
date	96.12.22.15.18.25;	author graichen;	state Exp;
branches;
next	1.3;

1.3
date	96.09.15.21.13.04;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.30.09.24.31;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.31;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.31;	author deraadt;	state Exp;
branches;
next	;

1.10.4.1
date	2001.07.04.10.21.36;	author niklas;	state dead;
branches;
next	;


desc
@@


1.11
log
@bye bye, with prejudice
@
text
@/*	$NetBSD: conf-glue.c,v 1.13 1997/05/24 09:37:45 jonathan Exp $	*/

/*
 * conf-glue.c:
 * A hand-edited ioconf.c, as generated by config.old program
 *
 * Seriously munged  to support old-stype pmax configurations
 * configured and compiled with new config.
 * Since new config doesn't yet support most pmax drivers,
 * this file contains an driver configuration table produced
 * by config.old run on a `generic' configuration.
 * This table uses device counts produced by the new config
 * ``needs-count'' keyword, that tells us at compile time
 * the maximum number of each device  that were configured.
 *
 * It also  provides a dummy set of cfdriver  structures,
 * for devices present in the configuration file, but
 * whose drivers don't (yet) have a struct cfdriver.
 * This avoids link-time errors with unresolved references
 * from the `parent table' produced by new-style config,
 * which assumes all device drivers have a struct cfdriver.
 *
 * THIS MAY NOT WORK FOR ALL MACHINES.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/types.h>
#include <sys/device.h>
#include <sys/buf.h>
#include <sys/dkstat.h>

#include <machine/autoconf.h>
#include <pmax/dev/device.h>

#define C (char *)

/*
 * Get old-style count of how many devices were configured
 * for each driver.
 */
#include "asc.h"
#include "sii.h"
#include "rz.h"
#include "tz.h"


/* declarations for glue to 4.4bsd pmax port SCSI drivers and autoconfig */
#if NASC > 0
extern struct pmax_driver ascdriver;
#endif
#if NSII > 0
extern struct pmax_driver siidriver;
#endif
#if NRZ > 0
extern struct pmax_driver rzdriver;
#endif
#if NTZ > 0
extern struct pmax_driver tzdriver;
#endif


/*
 * A fixed-at-compile-time disk configuration for the pmax-specific
 * scsi code.
 *
 * If you want to change this, fix the pmax kernel to use new-style
 * config code and the machine-independent NetBSD scsi drivers.
 */

struct pmax_scsi_device scsi_dinit[] = {
/*driver,	cdriver,	unit,	ctlr,	drive,	lun,	dk,	flags*/

#if NSII > 0
# if NRZ > 0
{ &rzdriver,	&siidriver,	0,	0,	0,	0,	1,	0x0 },
{ &rzdriver,	&siidriver,	1,	0,	1,	0,	1,	0x0 },
{ &rzdriver,	&siidriver,	2,	0,	2,	0,	1,	0x0 },
{ &rzdriver,	&siidriver,	3,	0,	3,	0,	1,	0x0 },
{ &rzdriver,	&siidriver,	4,	0,	4,	0,	1,	0x0 },
{ &rzdriver,    &siidriver,     5,      0,      5,      0,      1,      0x0 },
{ &rzdriver,    &siidriver,     6,      0,      6,      0,      1,      0x0 },
# endif /* NRZ */

# if NTZ > 0
{ &tzdriver,	&siidriver,	0,	0,	5,	0,	0,	0x0 },
{ &tzdriver,	&siidriver,	1,	0,	6,	0,	0,	0x0 },
# endif /* NTZ */
#endif /* NSII */


#if NASC > 0
# if NRZ > 0
{ &rzdriver,	&ascdriver,	0,	0,	0,	0,	1,	0x0 },
{ &rzdriver,	&ascdriver,	1,	0,	1,	0,	1,	0x0 },
{ &rzdriver,	&ascdriver,	2,	0,	2,	0,	1,	0x0 },
{ &rzdriver,	&ascdriver,	3,	0,	3,	0,	1,	0x0 },
{ &rzdriver,	&ascdriver,	4,	0,	4,	0,	1,	0x0 },
{ &rzdriver,	&ascdriver,	5,	0,	5,	0,	1,	0x0 },
{ &rzdriver,	&ascdriver,	6,	0,	6,	0,	1,	0x0 },

# if NRZ > 7
{ &rzdriver,    &ascdriver,     8,      1,      0,      0,      1,      0x0 },
{ &rzdriver,    &ascdriver,     9,      1,      1,      0,      1,      0x0 },
{ &rzdriver,    &ascdriver,     10,     1,      2,      0,      1,      0x0 },
{ &rzdriver,    &ascdriver,     11,     1,      3,      0,      1,      0x0 },
{ &rzdriver,    &ascdriver,     12,     1,      4,      0,      1,      0x0 },
{ &rzdriver,    &ascdriver,     13,     1,      5,      0,      1,      0x0 },
{ &rzdriver,    &ascdriver,     14,     1,      6,      0,      1,      0x0 },
# endif /* NRZ > 7 */
# endif /* NRZ */

# if NTZ > 0
{ &tzdriver,	&ascdriver,	0,	0,	5,	0,	0,	0x0 },
{ &tzdriver,	&ascdriver,	1,	0,	6,	0,	0,	0x0 },

# if NTZ > 2
{ &tzdriver,    &ascdriver,     2,      1,      5,      0,      0,      0x0 },
{ &tzdriver,    &ascdriver,     3,      1,      6,      0,      0,      0x0 },
# endif /* NTZ > 2 */
# endif /* NTZ */
#endif /* NASC */

 { 0 }
};


int	nomatch  __P((struct device * parent, void *cfdata, void *aux));
void	noattach __P((struct device *parent, struct device *self, void *aux));


/* placeholder definitions for new-style scsi bus/disk/tape drivers */

struct cfattach oldscsibus_ca = { 0, nomatch, noattach };
struct cfdriver oldscsibus_cd = {NULL, "oldscsibus", DV_DULL };

struct cfattach rz_ca = { 0, nomatch, noattach };
struct cfdriver rz_cd	= { NULL, "rz", DV_DULL };

struct cfattach tz_ca = { 0, nomatch, noattach };
struct cfdriver tz_cd	= { NULL, "tz", DV_DULL} ;


#define MAX_SCSI 4
static int nscsi;
static struct pmax_ctlr pmax_scsi_table[MAX_SCSI+1] = {
/*	driver,		unit,	addr,		flags */

	{ NULL, },  { NULL, }, { NULL, }, { NULL, },
	{ NULL, } /* sentinel */
};

/*
 * Callback for scsi controllers to register themselves with this
 * config glue.  Construct an old-style pmax autoconfiguration
 * SCSI-driver table entry for a  DECstation SCSI controller, and add it
 * to the table of known SCSI drivers.  Needed for old-style pmax
 * SCSI-bus probing.  configure() will call us back to probe
 * each known controller for the statically-configured drives, above.
 */
void
pmax_add_scsi(dp, unit)
	struct pmax_driver *dp;
	int unit;
{
	struct pmax_ctlr *cp  = &pmax_scsi_table[nscsi++];
	if (nscsi > MAX_SCSI) {
		panic("Too many old-style SCSI adaptors");
	}
	cp->pmax_driver = dp;
	cp->pmax_unit = unit;
}

/*
 * Configure scsi devices on old-style pmax scsi drivers.
 * Interrupts must be enabled or this will hang.
 *
 * Called by configure() after all possible controllers have been
 * found.  The controllers really should invoke new-style
 * autoconfiguration on themselves, probing their SCSI buses,
 * but the pmax drivers don't yet have polled SCSI.
 */
void
configure_scsi()
{
	register struct pmax_ctlr *cp;
	register struct pmax_scsi_device *dp;
	register struct pmax_driver *drp;

	/* probe and initialize SCSI buses */
	for (cp = &pmax_scsi_table[0]; (drp = cp->pmax_driver) != NULL; cp++) {

		/* probe and initialize devices connected to controller */
		for (dp = scsi_dinit; (drp = dp->sd_driver) != NULL; dp++) {
			/* might want to get fancier later */
			if (dp->sd_cdriver != cp->pmax_driver ||
			    dp->sd_ctlr != cp->pmax_unit)
			    continue;	/* not connected */
			if (!(*drp->d_init)(dp))
			    continue;
			dp->sd_alive = 1;

		}
	}
}


/*
 * Match function in struct cfdriver of old-conf drivers: never matches.
 */
int
nomatch(parent, cfdata, aux)
	struct device *parent;
	void *cfdata;
	void *aux;
{
#if /*def DEBUG*/ 0
	struct cfdata *cf = cfdata;
	struct confargs *ca = aux;

	printf("nomatch  %s: %s: %s offset 0x%lx not yet done: %x\n",
	        parent->dv_cfdata->cf_driver->cd_name,
	       parent->dv_xname,
	       ca->ca_name, ca->ca_offset);
#endif
	return 0;
}


/*
 * Attach function in struct cfdriver of old-conf drivers: never called.
 */
void
noattach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	struct confargs *ca = aux;

	/*XXX*/
#ifdef DEBUG
	printf("new attach  %s%d from %s: not yet done\n",
	       ca->ca_name, self->dv_unit,
	       parent->dv_xname);
#else
	panic("Can't do new-config attach of old device %s%d",
	      ca->ca_name, self->dv_unit);
#endif
	return;
}

@


1.10
log
@replace "" with "oldscsibus" in oldscsibus_cd. -moj
@
text
@@


1.10.4.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@@


1.9
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d135 1
a135 1
struct cfdriver oldscsibus_cd = {NULL, "", DV_DULL };
@


1.8
log
@1) It's a 'lun' not a 'slave'
2) 16 partitions
@
text
@d168 1
a168 1
		panic("Too many old-style SCSI adaptors\n");
d247 1
a247 1
	panic("Can't do new-config attach of old device %s%d\n",
@


1.7
log
@add support for disks and tapes on a second scsi controller (asc1)
-> originally from m. hitch -> tested by Andris Strazdins <andzs@@latnet.lv>
@
text
@d72 1
a72 1
/*driver,	cdriver,	unit,	ctlr,	drive,	slave,	dk,	flags*/
@


1.6
log
@update the pmax specific stuff to NetBSD-current as of about 970608 - some
cosmetic things will follow together with an update to an exact NETBSD_CU-
RRENT_xxxxxx level
@
text
@d81 3
a83 3
{ &rzdriver,	&siidriver,	5,	0,	5,	0,	1,	0x0 },
{ &rzdriver,	&siidriver,	6,	0,	6,	0,	1,	0x0 },
# endif /* NTZ */
d101 10
d116 5
@


1.5
log
@add entries for rz5 and rz6 (scsi disks on scsi id 5 & 6 - required for
zip drives)
@
text
@d1 1
a1 1
/*	$NetBSD: conf-glue.c,v 1.12 1996/10/13 03:39:47 christos Exp $	*/
d232 1
a232 1
	panic("Can't do new-config attach of old device %s\n",
@


1.4
log
@update the pmax stuff to NetBSD 961107 - this version i got somehow
compiled on my decstation 2100 (PLUTO) - but it will not fully work
out of the box - but i want to bring it into the tree because i get
my own pmax on 961228 - so that i have a good startpoint then :-)

all the OpenBSD changes to the pmax tree will follow in the next commit
@
text
@d81 2
d99 2
@


1.3
log
@sync to netbsd; for graichen
@
text
@d1 2
d75 1
d81 3
d86 1
d89 1
d91 1
d97 3
d102 1
d183 1
a183 5
			/* if device is a disk, assign number for statistics */
			if (dp->sd_dk && dkn < DK_NDRIVE)
			    dp->sd_dk = dkn++;
			else
			    dp->sd_dk = -1;
@


1.2
log
@from netbsd:
Move the old-style disk instrumentation "structures" to a central
location (sys/kern/subr_disk.c) and note that they should/will be
deprecated.
@
text
@d25 1
a30 1

d71 2
d80 3
d90 3
a92 1
0
d102 5
a106 1
struct cfdriver oldscsibuscd = {NULL, "", nomatch, noattach, DV_DULL, 0, 0};
d108 2
a109 2
struct cfdriver rzcd	= {NULL, "rz", nomatch, noattach, DV_DULL, 0, 0};
struct cfdriver tzcd	= {NULL, "tz", nomatch, noattach, DV_DULL, 0, 0};
d159 1
a159 1
	for (cp = &pmax_scsi_table[0]; drp = cp->pmax_driver; cp++) {
d162 1
a162 1
		for (dp = scsi_dinit; drp = dp->sd_driver; dp++) {
d189 1
d192 1
a192 1
#if /*def DEBUG*/ 0
d219 1
a219 1
	panic("Can't do ew-attach of old device %s\n",
@


1.1
log
@Initial revision
@
text
@a146 2
	extern int dkn;	/* number of iostat dk numbers assigned */

@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
