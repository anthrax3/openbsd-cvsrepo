head	1.6;
access;
symbols
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	UBC_SYNC_A:1.6
	UBC_SYNC_B:1.6
	OPENBSD_2_9:1.5.0.12
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.10
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.8
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.6
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.4
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2001.06.24.23.48.43;	author deraadt;	state dead;
branches;
next	1.5;

1.5
date	99.01.11.05.11.52;	author millert;	state Exp;
branches
	1.5.6.1;
next	1.4;

1.4
date	98.05.18.00.28.27;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	98.05.09.21.29.55;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.12.22.15.18.36;	author graichen;	state Exp;
branches;
next	1.1;

1.1
date	96.09.29.11.36.51;	author deraadt;	state Exp;
branches;
next	;

1.5.6.1
date	2001.07.04.10.21.49;	author niklas;	state dead;
branches;
next	;


desc
@@


1.6
log
@bye bye, with prejudice
@
text
@/*	$NetBSD: mips_machdep.c,v 1.6 1996/10/13 21:37:51 jonathan Exp $	*/

/*
 * Copyright 1996 The Board of Trustees of The Leland Stanford
 * Junior University. All Rights Reserved.
 *
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies.  Stanford University
 * makes no representations about the suitability of this
 * software for any purpose.  It is provided "as is" without
 * express or implied warranty.
 */

#include <sys/param.h>
#include <sys/systm.h>

#include <machine/cpu.h>		/* declaration of of cpu_id */
#include <machine/locore.h>

mips_locore_jumpvec_t mips_locore_jumpvec = {
  NULL, NULL, NULL, NULL,
  NULL, NULL, NULL, NULL,
  NULL, NULL
};

/*
 * Forward declarations
 * XXX should be in a header file so each mips port can include it.
 */
extern void cpu_identify __P((void));
extern void mips_vector_init __P((void));

void mips1_vector_init __P((void));
void mips3_vector_init __P((void));


#ifdef MIPS1	/*  r2000 family  (mips-I cpu) */
/*
 * MIPS-I (r2000) locore-function vector.
 */
mips_locore_jumpvec_t R2000_locore_vec =
{
	mips1_ConfigCache,
	mips1_FlushCache,
	mips1_FlushDCache,
	mips1_FlushICache,
	/*mips1_FlushICache*/ mips1_FlushCache,
	mips1_SetPID,
	mips1_TLBFlush,
	mips1_TLBFlushAddr,
	mips1_TLBUpdate,
	mips1_TLBWriteIndexed
};

void
mips1_vector_init()
{
	extern char mips1_UTLBMiss[], mips1_UTLBMissEnd[];
	extern char mips1_exception[], mips1_exceptionEnd[];

	/*
	 * Copy down exception vector code.
	 */
	if (mips1_UTLBMissEnd - mips1_UTLBMiss > 0x80)
		panic("startup: UTLB code too large");
	bcopy(mips1_UTLBMiss, (char *)MIPS_UTLB_MISS_EXC_VEC,
		mips1_UTLBMissEnd - mips1_UTLBMiss);
	bcopy(mips1_exception, (char *)MIPS1_GEN_EXC_VEC,
	      mips1_exceptionEnd - mips1_exception);

	/*
	 * Copy locore-function vector.
	 */
	bcopy(&R2000_locore_vec, &mips_locore_jumpvec,
	      sizeof(mips_locore_jumpvec_t));

	/*
	 * Clear out the I and D caches.
	 */
	mips1_ConfigCache();
	mips1_FlushCache();
}
#endif /* MIPS1 */


#ifdef MIPS3		/* r4000 family (mips-III cpu) */
/*
 * MIPS-III (r4000) locore-function vector.
 */
mips_locore_jumpvec_t R4000_locore_vec =
{
	mips3_ConfigCache,
	mips3_FlushCache,
	mips3_FlushDCache,
	mips3_FlushICache,
#if 0
	 /*
	  * No such vector exists, perhaps it was meant to be HitFlushDCache?
	  */
	mips3_ForceCacheUpdate,
#else
	mips3_FlushCache,
#endif
	mips3_SetPID,
	mips3_TLBFlush,
	mips3_TLBFlushAddr,
	mips3_TLBUpdate,
	mips3_TLBWriteIndexed
};

void
mips3_vector_init()
{

	/* TLB miss handler address and end */
	extern char mips3_exception[], mips3_exceptionEnd[];

	/* r4000 exception handler address and end */
	extern char mips3_TLBMiss[], mips3_TLBMissEnd[];

	/*
	 * Copy down exception vector code.
	 */
	if (mips3_TLBMissEnd - mips3_TLBMiss > 0x80)
		panic("startup: UTLB code too large");
	bcopy(mips3_TLBMiss, (char *)MIPS_UTLB_MISS_EXC_VEC,
	      mips3_TLBMissEnd - mips3_TLBMiss);

	bcopy(mips3_exception, (char *)MIPS_GEN_EXC_VEC,
	      mips3_exceptionEnd - mips3_exception);

	/*
	 * Copy locore-function vector.
	 */
	bcopy(&R4000_locore_vec, &mips_locore_jumpvec,
	      sizeof(mips_locore_jumpvec_t));

	/*
	 * Clear out the I and D caches.
	 */
	mips3_ConfigCache();
	mips3_FlushCache();
}
#endif	/* MIPS3 */


/*
 * Do all the stuff that locore normally does before calling main(),
 * that is common to all mips-CPU NetBSD ports.
 *
 * The principal purpose of this function is to examine the
 * variable cpu_id, into which the kernel locore start code
 * writes the cpu ID register, and to then copy appropriate
 * cod into the CPU exception-vector entries and the jump tables
 * used to  hide the differences in cache and TLB handling in
 * different MIPS  CPUs.
 * 
 * This should be the very first thing called by each port's
 * init_main() function.
 */

/*
 * Initialize the hardware exception vectors, and the jump table used to
 * call locore cache and TLB management functions, based on the kind
 * of CPU the kernel is running on.
 */
void mips_vector_init()
{
	register caddr_t v;
	extern char edata[], end[];

	/* clear the BSS segment */
	v = (caddr_t)mips_round_page(end);
	bzero(edata, v - edata);

	/* Work out what kind of CPU and FPU are present. */
	switch(cpu_id.cpu.cp_imp) {

#ifdef MIPS1	/*  r2000 family  (mips-I cpu) */
	case MIPS_R2000:
	case MIPS_R3000:
	  	mips1_vector_init();
		break;
#endif /* MIPS1 */


#ifdef MIPS3		/* r4000 family (mips-III cpu) */
	case MIPS_R4000:
	  	mips3_vector_init();
		break;
#endif /* MIPS3 */

	default:
		panic("Unconfigured or unsupported MIPS cpu");

	}
}


/*
 * Identify cpu and fpu type and revision.
 *
 * XXX Should be moved to mips_cpu.c but that doesn't exist
 */
void
cpu_identify()
{


	/* Work out what kind of CPU and FPU are present. */

	switch(cpu_id.cpu.cp_imp) {

	case MIPS_R2000:
		printf("MIPS R2000 CPU");
		break;
	case MIPS_R3000:

	  	/*
		 * XXX
		 * R2000A silicion has an r3000 core and shows up here.
		 *  The caller should indicate that by setting a flag
		 * indicating the baseboard is  socketed for an r2000.
		 * Needs more thought.
		 */
#ifdef notyet
	  	if (SYSTEM_HAS_R2000_CPU_SOCKET())
			printf("MIPS R2000A CPU");
		else
#endif
		printf("MIPS R3000 CPU");
		break;
	case MIPS_R6000:
		printf("MIPS R6000 CPU");
		break;

	case MIPS_R4000:
#ifdef pica /* XXX*/
		if(machPrimaryInstCacheSize == 16384)
			printf("MIPS R4400 CPU");
		else
#endif /* XXX*/
			printf("MIPS R4000 CPU");
		break;
	case MIPS_R3LSI:
		printf("LSI Logic R3000 derivate");
		break;
	case MIPS_R6000A:
		printf("MIPS R6000A CPU");
		break;
	case MIPS_R3IDT:
		printf("IDT R3000 derivate");
		break;
	case MIPS_R10000:
		printf("MIPS R10000/T5 CPU");
		break;
	case MIPS_R4200:
		printf("MIPS R4200 CPU (ICE)");
		break;
	case MIPS_R8000:
		printf("MIPS R8000 Blackbird/TFP CPU");
		break;
	case MIPS_R4600:
		printf("QED R4600 Orion CPU");
		break;
	case MIPS_R3SONY:
		printf("Sony R3000 based CPU");
		break;
	case MIPS_R3TOSH:
		printf("Toshiba R3000 based CPU");
		break;
	case MIPS_R3NKK:
		printf("NKK R3000 based CPU");
		break;
	case MIPS_UNKC1:
	case MIPS_UNKC2:
	default:
		printf("Unknown CPU type (0x%x)",cpu_id.cpu.cp_imp);
		break;
	}
	printf(" Rev. %d.%d with ", cpu_id.cpu.cp_majrev, cpu_id.cpu.cp_minrev);


	switch(fpu_id.cpu.cp_imp) {

	case MIPS_SOFT:
		printf("Software emulation float");
		break;
	case MIPS_R2360:
		printf("MIPS R2360 FPC");
		break;
	case MIPS_R2010:
		printf("MIPS R2010 FPC");
		break;
	case MIPS_R3010:
	  	/*
		 * XXX FPUs  for R2000A(?) silicion has an r3010 core and
		 *  shows up here.
		 */
#ifdef notyet
	  	if (SYSTEM_HAS_R2000_CPU_SOCKET())
			printf("MIPS R2010A CPU");
		else
#endif
		printf("MIPS R3010 FPC");
		break;
	case MIPS_R6010:
		printf("MIPS R6010 FPC");
		break;
	case MIPS_R4010:
		printf("MIPS R4010 FPC");
		break;
	case MIPS_R31LSI:
		printf("FPC");
		break;
	case MIPS_R10010:
		printf("MIPS R10000/T5 FPU");
		break;
	case MIPS_R4210:
		printf("MIPS R4200 FPC (ICE)");
	case MIPS_R8000:
		printf("MIPS R8000 Blackbird/TFP");
		break;
	case MIPS_R4600:
		printf("QED R4600 Orion FPC");
		break;
	case MIPS_R3SONY:
		printf("Sony R3000 based FPC");
		break;
	case MIPS_R3TOSH:
		printf("Toshiba R3000 based FPC");
		break;
	case MIPS_R3NKK:
		printf("NKK R3000 based FPC");
		break;
	case MIPS_UNKF1:
	default:
		printf("Unknown FPU type (0x%x)", fpu_id.cpu.cp_imp);
		break;
	}
	printf(" Rev. %d.%d", fpu_id.cpu.cp_majrev, fpu_id.cpu.cp_minrev);
	printf("\n");

#ifdef pica
	printf("        Primary cache size: %dkb Instruction, %dkb Data.\n",
		machPrimaryInstCacheSize / 1024,
		machPrimaryDataCacheSize / 1024);
#endif
}
@


1.5
log
@panic prints a newline for you, don't do it in the panic string
@
text
@@


1.5.6.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@@


1.4
log
@new cpureg.h from NetBSD plus modifications to use the changed macro names
@
text
@d196 1
a196 1
		panic("Unconfigured or unsupported MIPS cpu\n");
@


1.3
log
@#include <pmax/foo.h> -> #include <machine/foo.h>
@
text
@d68 1
a68 1
	bcopy(mips1_UTLBMiss, (char *)MACH_UTLB_MISS_EXC_VEC,
d70 1
a70 1
	bcopy(mips1_exception, (char *)MACH_GEN_EXC_VEC,
d128 1
a128 1
	bcopy(mips3_TLBMiss, (char *)MACH_UTLB_MISS_EXC_VEC,
d131 1
a131 1
	bcopy(mips3_exception, (char *)MACH_GEN_EXC_VEC,
@


1.2
log
@update the pmax stuff to NetBSD 961107 - this version i got somehow
compiled on my decstation 2100 (PLUTO) - but it will not fully work
out of the box - but i want to bring it into the tree because i get
my own pmax on 961228 - so that i have a good startpoint then :-)

all the OpenBSD changes to the pmax tree will follow in the next commit
@
text
@a18 2
#include <pmax/cpu.h>		/* declaration of of cpu_id */
#include <pmax/locore.h>
d20 1
@


1.1
log
@merge mips back into pmax; by graichen
@
text
@d1 1
a1 1
/*	$NetBSD: mips_machdep.c,v 1.1 1996/05/19 00:31:57 jonathan Exp $	*/
d16 3
d20 2
a21 1
#include <machine/locore.h>
d29 9
d39 2
d46 10
a55 28
	mips_r2000_ConfigCache,
	mips_r2000_FlushCache,
	mips_r2000_FlushDCache,
	mips_r2000_FlushICache,
	/*mips_r2000_FlushICache*/ mips_r2000_FlushCache,
	mips_r2000_SetPID,
	mips_r2000_TLBFlush,
	mips_r2000_TLBFlushAddr,
	mips_r2000_TLBUpdate,
	mips_r2000_TLBWriteIndexed
};

#ifdef CPU_R4000
/*
 * MIPS-III (r4000) locore-function vector.
 */
mips_locore_jumpvec_t R4000_locore_vec =
{
	mips_r4000_ConfigCache,
	mips_r4000_FlushCache,
	mips_r4000_FlushDCache,
	mips_r4000_FlushICache,
	mips_r4000_ForceCacheUpdate,
	mips_r4000_SetPID,
	mips_r4000_TLBFlush,
	mips_r4000_TLBFlushAddr,
	mips_r4000_TLBUpdate,
	mips_r4000_TLBWriteIndexed
a56 17
#endif	/* CPU_R4000 */


/*
 * Do all the stuff that locore normally does before calling main(),
 * that is common to all mips-CPU NetBSD ports.
 *
 * The principal purpose of this function is to examine the
 * variable cpu_id, into which the kernel locore start code
 * writes the cpu ID register, and to then copy appropriate
 * cod into the CPU exception-vector entries and the jump tables
 * used to  hide the differences in cache and TLB handling in
 * different MIPS  CPUs.
 * 
 * This should be the very first thing called by each port's
 * init_main() function.
 */
d59 1
a59 1
r2000_vector_init()
d61 2
a62 2
	extern char MachUTLBMiss[], MachUTLBMissEnd[];
	extern char mips_R2000_exception[], mips_R2000_exceptionEnd[];
d67 1
a67 1
	if (MachUTLBMissEnd - MachUTLBMiss > 0x80)
d69 4
a72 4
	bcopy(MachUTLBMiss, (char *)MACH_UTLB_MISS_EXC_VEC,
		MachUTLBMissEnd - MachUTLBMiss);
	bcopy(mips_R2000_exception, (char *)MACH_GEN_EXC_VEC,
	      mips_R2000_exceptionEnd - mips_R2000_exception);
d83 2
a84 2
	mips_r2000_ConfigCache();
	mips_r2000_FlushCache();
d86 1
d89 25
a113 1
#ifdef CPU_R4000
d115 1
a115 1
r4000_vector_init()
d118 5
a122 2
	extern char MachUTLBMiss[], MachUTLBMissEnd[];
	extern char mips_R4000_exception[], mips_R4000_exceptionEnd[];
d127 1
a127 1
	if (MachUTLBMissEnd - MachUTLBMiss > 0x80)
d129 2
a130 2
	bcopy(MachUTLBMiss, (char *)MACH_UTLB_MISS_EXC_VEC,
	      MachUTLBMissEnd - MachUTLBMiss);
d132 2
a133 2
	bcopy(mips_r4000_exception, (char *)MACH_GEN_EXC_VEC,
	      mips_r4000_exceptionEnd - mips_r4000_exception);
d144 2
a145 2
	mips_r4000_ConfigCache();
	mips_r4000_FlushCache();
d147 17
a163 1
#endif
d170 1
a170 2
void
mips_vector_init()
d182 1
d185 1
a185 1
	  	r2000_vector_init();
d187 2
d190 1
a190 1
#ifdef CPU_R4000
d192 1
a192 1
	  	r4000_vector_init();
d194 1
a194 1
#endif CPU_R4000
@
