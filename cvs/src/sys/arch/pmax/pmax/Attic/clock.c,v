head	1.9;
access;
symbols
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	UBC_SYNC_A:1.9
	UBC_SYNC_B:1.9
	OPENBSD_2_9:1.8.0.6
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.8.0.4
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	SMP:1.7.0.8
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.6
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.4
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2001.06.24.23.48.32;	author deraadt;	state dead;
branches;
next	1.8;

1.8
date	2000.03.12.19.08.19;	author maja;	state Exp;
branches;
next	1.7;

1.7
date	98.05.18.00.28.17;	author millert;	state Exp;
branches
	1.7.8.1;
next	1.6;

1.6
date	98.01.19.10.45.39;	author graichen;	state Exp;
branches;
next	1.5;

1.5
date	97.07.07.08.24.19;	author graichen;	state Exp;
branches;
next	1.4;

1.4
date	96.12.22.15.18.24;	author graichen;	state Exp;
branches;
next	1.3;

1.3
date	96.09.15.21.13.04;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.01.09.09.24.32;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.31;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.31;	author deraadt;	state Exp;
branches;
next	;

1.7.8.1
date	2000.03.24.09.08.32;	author niklas;	state Exp;
branches;
next	1.7.8.2;

1.7.8.2
date	2001.07.04.10.21.35;	author niklas;	state dead;
branches;
next	;


desc
@@


1.9
log
@bye bye, with prejudice
@
text
@/*	$OpenBSD: clock.c,v 1.8 2000/03/12 19:08:19 maja Exp $	*/
/*	$NetBSD: clock.c,v 1.15 1996/10/13 03:39:45 christos Exp $	*/

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department and Ralph Campbell.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah Hdr: clock.c 1.18 91/01/21
 *
 *	@@(#)clock.c	8.1 (Berkeley) 6/10/93
 */

#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/systm.h>
#include <sys/device.h>

#include <machine/autoconf.h>
#include <machine/machConst.h>
#include <pmax/pmax/clockreg.h>

#include "tc.h"			/* Is a Turbochannel configured? */

#if NTC>0
#include <dev/tc/tcvar.h>
#include <dev/tc/ioasicvar.h>
#endif


/*
 * Machine-dependent clock routines.
 *
 * Startrtclock restarts the real-time clock, which provides
 * hardclock interrupts to kern_clock.c.
 *
 * Inittodr initializes the time of day hardware which provides
 * date functions.  Its primary function is to use some file
 * system information in case the hardare clock lost state.
 *
 * Resettodr restores the time of day hardware after a time change.
 */

volatile struct chiptime *Mach_clock_addr;


/* Some values for rates for the RTC interrupt */
#define RATE_32_HZ	0xB	/* 31.250 ms */
#define RATE_64_HZ	0xA	/* 15.625 ms */
#define RATE_128_HZ	0x9	/* 7.8125 ms */
#define RATE_256_HZ	0x8	/* 3.90625 ms */
#define RATE_512_HZ	0x7	/* 1953.125 us*/
#define RATE_1024_HZ	0x6	/* 976.562 us */
#define RATE_2048_HZ	0x5	/* 488.281 usecs/interrupt */

/* why should this be defined in the config file ? TTTTT */
#ifndef HZ
#define HZ 256
#endif

#undef SELECTED_RATE
#if (HZ == 64)
# define SELECTED_RATE RATE_64_HZ	/* 4.4bsd default on pmax */
# define SHIFT_HZ 6
# else	/* !64 Hz */
#if (HZ == 128)
# define SELECTED_RATE RATE_128_HZ
# define SHIFT_HZ 7
#else	/* !128 Hz */
#if (HZ == 256)
# define SELECTED_RATE RATE_256_HZ
# define SHIFT_HZ 8
#else /*!256Hz*/
#if (HZ == 512)
# define SELECTED_RATE RATE_512_HZ
# define SHIFT_HZ 9
#else /*!512hz*/
#if (HZ == 1024)
# define SELECTED_RATE RATE_1024_HZ
# define SHIFT_HZ 10
#else /* !1024hz*/
# error RTC interrupt rate HZ not recognised; must be a power of 2
#endif /*!64Hz*/
#endif /*!1024Hz*/
#endif /*!512 Hz*/
#endif /*!256 Hz*/
#endif /*!128Hz*/

/*
 * RTC interrupt rate: pick one of 64, 128, 256, 512, 1024, 2048.
 * The appropriate rate is machine-dependent, or even model-dependent.
 *
 * Unless a machine has a hardware free-running clock, the RTC interrupt
 * rate is an upper limit on gettimeofday(), context switch interval,
 * and generally the resolution of real-time.  The standard 4.4bsd pmax
 * RTC tick rate is 64Hz, which has low overhead but is ludicrous when
 * doing serious performance measurement.  For machines faster than 3100s,
 * 1024Hz gives millisecond resolution.   Alphas have an on-chip counter,
 * and at least some IOASIC Decstations have  a turbochannel cycle-counter,
 * either of which which can be interpolated between RTC interrupts, to
 * give resolution in ns or tens of ns.
 */

#ifndef HZ
#ifdef __mips__
/*#define HZ 64*/	/* conveniently divides 1 sec */
#define HZ 256	/* default on Ultrix */
#else
# error Kernel config parameter HZ not defined
#endif
#endif

/* Compute value to program clock with, given config parameter RTC_HZ */



/* global autoconfiguration variables -- bus type*/
extern struct cfdriver mainbus_cd;
#if NTC>0
extern struct cfdriver ioasic_cd;
extern struct cfdriver tc_cd;
#endif


/* Definition of the driver for autoconfig. */
static int	clockmatch __P((struct device *, void *, void *));
static void	clockattach __P((struct device *, struct device *, void *));

struct cfattach clock_ca = {
	sizeof(struct device), clockmatch, clockattach
};

struct cfdriver clock_cd = {
	NULL, "clock", DV_DULL
};

#ifdef notyet
static void	clock_startintr __P((void *));
static void	clock_stopintr __P((void *));
#endif

volatile struct chiptime *Mach_clock_addr;

static int
clockmatch(parent, cfdata, aux)
	struct device *parent;
	void *cfdata;
	void *aux;
{
	struct cfdata *cf = cfdata;
	struct confargs *ca = aux;
#if NTC>0
	struct ioasicdev_attach_args *d = aux;
#endif
#ifdef notdef /* XXX */
	struct tc_cfloc *asic_locp = (struct asic_cfloc *)cf->cf_loc;
#endif
	int nclocks;

#if NTC>0
	if (parent->dv_cfdata->cf_driver != &ioasic_cd &&
	    parent->dv_cfdata->cf_driver != &tc_cd &&
	    parent->dv_cfdata->cf_driver != &mainbus_cd)
#else
	if (parent->dv_cfdata->cf_driver != &mainbus_cd)
#endif
		return(0);

	/* make sure that we're looking for this type of device. */
#if NTC>0
	if (parent->dv_cfdata->cf_driver != &mainbus_cd) {
		if (strcmp(d->iada_modname, "mc146818") != 0)
			return (0);
	} else
#endif
	if (strcmp(ca->ca_name, "mc146818") != 0)
		return (0);

	/* All known decstations have a Dallas RTC */
	nclocks = 1;

	/* if it can't have the one mentioned, reject it */
	if (cf->cf_unit >= nclocks)
		return (0);

	return (1);
}

static void
clockattach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	struct confargs *ca = aux;
#if NTC>0
	struct ioasicdev_attach_args *d = aux;
#endif
#ifndef pmax
	register volatile struct chiptime *c;
#endif

#if NTC>0
	if (parent->dv_cfdata->cf_driver != &mainbus_cd)
		Mach_clock_addr = (struct chiptime *)
			MIPS_PHYS_TO_KSEG1(d->iada_addr);
	else
#endif
		Mach_clock_addr = (struct chiptime *)
			MIPS_PHYS_TO_KSEG1(ca->ca_addr);

#ifdef pmax
	printf("\n");
	return;
#endif

#ifndef pmax	/* Turn interrupts off, just in case. */
	
	c = Mach_clock_addr;
	c->regb = REGB_DATA_MODE | REGB_HOURS_FORMAT;
	wbflush();
#endif

#ifdef notyet /*XXX*/ /*FIXME*/
	BUS_INTR_ESTABLISH(ca, (intr_handler_t)hardclock, NULL);
#endif
}

/*
 * Start the real-time and statistics clocks. Leave stathz 0 since there
 * are no other timers available.
 */
void
cpu_initclocks()
{
	register volatile struct chiptime *c;
	extern int tickadj;
#ifdef NTP
	extern int fixtick;
#endif
	register long tmp;

	if (Mach_clock_addr == NULL)
		panic("cpu_initclocks: no clock to initialize");

	hz = HZ;		/* Clock Hz is a configuration parameter */
	tick = 1000000 / hz;	/* number of microseconds between interrupts */
#ifdef NTP
	fixtick =
#endif
	tickfix = 1000000 - (hz * tick);
	if (tickfix) {
		int ftp;

		ftp = min(ffs(tickfix), ffs(hz));
		tickfix >>= (ftp - 1);
		tickfixinterval = hz >> (ftp - 1);
        }

	c = Mach_clock_addr;
	c->rega = REGA_TIME_BASE | SELECTED_RATE;
	c->regb = REGB_PER_INT_ENA | REGB_DATA_MODE | REGB_HOURS_FORMAT;
	wbflush();		/* Alpha needs this */

	/*
	 * Reset tickadj to ntp's idea of what it should be
	 * XXX this should be in conf/param.c
	 */
	tmp = (long) tick * 500L;
	tickadj = (int)(tmp / 1000000L);
	if (tmp % 1000000L > 0)
		tickadj++;
}

/*
 * We assume newhz is either stathz or profhz, and that neither will
 * change after being set up above.  Could recalculate intervals here
 * but that would be a drag.
 */
void
setstatclockrate(newhz)
	int newhz;
{
	/* nothing we can do */
}

/*
 * This is the amount to add to the value stored in the clock chip
 * to get the current year.
 *
 * Experimentation (and passing years) show that Decstation PROMS
 * assume the kernel uses the clock chip as a time-of-year clock.
 * The PROM assumes the clock is always set to 1972 or 1973, and contains
 * time-of-year in seconds.   The PROM checks the clock at boot time,
 * and if it's outside that range, sets it to 1972-01-01.
 */
#if 1		/* testing, until we write time-of-year code as aboce */
#define YR_OFFSET	28	/* good til dec 31, 2001 */
#define DAY_OFFSET	/*1*/ 0
#else
#define YR_OFFSET	22
#define DAY_OFFSET	1
#endif

#define	BASE_YEAR	1972

/*
 * This code is defunct after 2099.
 * Will Unix still be here then??
 */
static short dayyr[12] = {
	0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334
};

/*
 * Initialize the time of day register, based on the time base which is, e.g.
 * from a filesystem.  Base provides the time to within six months,
 * and the time of year clock (if any) provides the rest.
 */
void
inittodr(base)
	time_t base;
{
	register volatile struct chiptime *c;
	register int days, yr;
	int sec, min, hour, day, mon, year;
	long deltat;
	int badbase, s;

	if (base < 5*SECYR) {
		printf("WARNING: preposterous time in file system");
		/* read the system clock anyway */
		base = 6*SECYR + 186*SECDAY + SECDAY/2;
		badbase = 1;
	} else
		badbase = 0;

	c = Mach_clock_addr;

	/*
	 * Don't read clock registers while they are being updated,
	 * and make sure we don't re-read the clock's registers
	 * too often while waiting.
	 */
	s = splclock();
	while ((c->rega & REGA_UIP) == 1) {
		splx(s);
		DELAY(10);
		s = splclock();
	}

	sec = c->sec;
	min = c->min;
	hour = c->hour;
	day = c->day;
	mon = c->mon;
	year = c->year;

	splx(s);

#ifdef	DEBUG_CLOCK
	printf("inittodr(): todr hw yy/mm/dd= %d/%d/%d\n", year, mon, day);
#endif
	/* convert from PROM time-of-year convention to actual time */
	day  += DAY_OFFSET;
	year += YR_OFFSET;

	/* simple sanity checks */
	if (year < 70 || mon < 1 || mon > 12 || day < 1 || day > 31 ||
	    hour > 23 || min > 59 || sec > 59) {
		/*
		 * Believe the time in the file system for lack of
		 * anything better, resetting the TODR.
		 */
		time.tv_sec = base;
		if (!badbase) {
			printf("WARNING: preposterous clock chip time\n");
			resettodr();
		}
		goto bad;
	}
	days = 0;
	for (yr = 70; yr < year; yr++)
		days += LEAPYEAR(yr) ? 366 : 365;
	days += dayyr[mon - 1] + day - 1;
	if (LEAPYEAR(yr) && mon > 2)
		days++;
	/* now have days since Jan 1, 1970; the rest is easy... */
	time.tv_sec = days * SECDAY + hour * 3600 + min * 60 + sec;

	if (!badbase) {
		/*
		 * See if we gained/lost two or more days;
		 * if so, assume something is amiss.
		 */
		deltat = time.tv_sec - base;
		if (deltat < 0)
			deltat = -deltat;
		if (deltat < 2 * SECDAY)
			return;
		printf("WARNING: clock %s %ld days",
		    time.tv_sec < base ? "lost" : "gained", deltat / SECDAY);
	}
bad:
	printf(" -- CHECK AND RESET THE DATE!\n");
}

/*
 * Reset the TODR based on the time value; used when the TODR
 * has a preposterous value and also when the time is reset
 * by the stime system call.  Also called when the TODR goes past
 * TODRZERO + 100*(SECYEAR+2*SECDAY) (e.g. on Jan 2 just after midnight)
 * to wrap the TODR around.
 */
void
resettodr()
{
	register volatile struct chiptime *c;
	register int t, t2;
	int sec, min, hour, day, dow, mon, year;
	int s;

	/* compute the day of week. */
	t2 = time.tv_sec / SECDAY;
	dow = (t2 + 4) % 7;	/* 1/1/1970 was thursday */

	/* compute the year */
	t = t2;
	year = 69;
	while (t2 >= 0) {	/* whittle off years */
		t = t2;
		year++;
		t2 -= LEAPYEAR(year) ? 366 : 365;
	}

	/* t = month + day; separate */
	t2 = LEAPYEAR(year);
	for (mon = 1; mon < 12; mon++)
		if (t < dayyr[mon] + (t2 && mon > 1))
			break;

	day = t - dayyr[mon - 1] + 1;
	if (t2 && mon > 2)
		day--;

	/* the rest is easy */
	t = time.tv_sec % SECDAY;
	hour = t / 3600;
	t %= 3600;
	min = t / 60;
	sec = t % 60;

	c = Mach_clock_addr;

	/* convert to the  format the PROM uses */
	day  -= DAY_OFFSET;
 	year -= YR_OFFSET;

	s = splclock();
	t = c->regd;				/* reset VRT */
	c->regb = REGB_SET_TIME | REGB_DATA_MODE | REGB_HOURS_FORMAT;
	wbflush();
	c->rega = 0x70;				/* reset time base */
	wbflush();

	c->sec = sec;
	c->min = min;
	c->hour = hour;
	/*c->dayw = dow;*/
	c->day = day;
	c->mon = mon;
	c->year = year;
	wbflush();

	c->rega = REGA_TIME_BASE | SELECTED_RATE;
	c->regb = REGB_PER_INT_ENA | REGB_DATA_MODE | REGB_HOURS_FORMAT;
	wbflush();
	splx(s);
#ifdef	DEBUG_CLOCK
	printf("resettodr(): todr hw yy/mm/dd= %d/%d/%d\n", year, mon, day);
#endif

	c->nvram[48*4] |= 1;		/* Set PROM time-valid bit */
	wbflush();
}

/*XXX*/
/*
 * Wait "n" microseconds.
 * (scsi code needs this).
*/
void
delay(n)
	int n;
{
	DELAY(n);
}
@


1.8
log
@Update clock code to work until 2001-12-31. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.7
log
@new cpureg.h from NetBSD plus modifications to use the changed macro names
@
text
@d1 1
d330 1
a330 1
#define YR_OFFSET	26	/* good til dec 31, 1999 */
@


1.7.8.1
log
@Sync with -current
@
text
@a0 1
/*	$OpenBSD$	*/
d329 1
a329 1
#define YR_OFFSET	28	/* good til dec 31, 2001 */
@


1.7.8.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.7.8.1 2000/03/24 09:08:32 niklas Exp $	*/
@


1.6
log
@this hack should fix the date/time problem i (and i think others
too :-) see since 1998 on their pmaxes - will check it this evening
but it looks so trivial that it must work

all this should be reworked to get rid of this stupid way of setting
the time ...
@
text
@d237 1
a237 1
			MACH_PHYS_TO_UNCACHED(d->iada_addr);
d241 1
a241 1
			MACH_PHYS_TO_UNCACHED(ca->ca_addr);
@


1.5
log
@set a useful value for HZ here - so that we no longer have to set it
in the kernel config file
@
text
@d329 1
a329 1
#define YR_OFFSET	24	/* good til dec 31, 1997 */
@


1.4
log
@update the pmax stuff to NetBSD 961107 - this version i got somehow
compiled on my decstation 2100 (PLUTO) - but it will not fully work
out of the box - but i want to bring it into the tree because i get
my own pmax on 961228 - so that i have a good startpoint then :-)

all the OpenBSD changes to the pmax tree will follow in the next commit
@
text
@d87 5
@


1.3
log
@sync to netbsd; for graichen
@
text
@d1 1
a1 1
/*	$NetBSD: clock.c,v 1.12.4.1 1996/05/30 04:10:34 mhitch Exp $	*/
@


1.2
log
@from netbsd:
Update a kludge from 4.4bsd/pmax: DECstation PROMs force the clock to
be in 1972 or 1973. If the clock is set to the actual time, the PROM
appears to reset the chip date to 1972 at each reboot.
Change the "year offset" from 22 years to 24 years (good till 1997)
until this code is replaced with something that uses the chip as a
seconds-since-beginning-of-year clock (encoded as a date, relative to
1972-01-01 00:00:00).
@
text
@d1 1
a1 1
/*	$NetBSD: clock.c,v 1.9 1996/01/07 15:38:44 jonathan Exp $	*/
d54 8
d88 26
d130 1
a130 1
#ifndef RTC_HZ
d132 2
a133 1
#define RTC_HZ 64
d135 1
a135 1
# error Kernel config parameter RTC_HZ not defined
a140 21
#if (RTC_HZ == 128)
# define SELECTED_RATE RATE_128_HZ
#else	/* !128 Hz */
#if (RTC_HZ == 256)
# define SELECTED_RATE RATE_256_HZ
#else /*!256Hz*/
#if (RTC_HZ == 512)
# define SELECTED_RATE RATE_512_HZ
#else /*!512hz*/
#if (RTC_HZ == 1024)
# define SELECTED_RATE RATE_1024_HZ
#else /* !1024hz*/
# if (RTC_HZ == 64)
# define SELECTED_RATE RATE_64_HZ	/* 4.4bsd default on pmax */
# else
# error RTC interrupt rate RTC_HZ not recognised; must be a power of 2
#endif /*!64Hz*/
#endif /*!1024Hz*/
#endif /*!512 Hz*/
#endif /*!256 Hz*/
#endif /*!128Hz*/
d143 8
d154 7
a160 2
struct cfdriver clockcd = {
	NULL, "clock", clockmatch, clockattach, DV_DULL, sizeof(struct device),
d163 1
d166 1
d178 3
a183 2
	register volatile struct chiptime *c;
	int vec, ipl;
d186 9
d196 7
a202 1
	if (!BUS_MATCHNAME(ca, "dallas_rtc"))
a205 1
#ifdef pmax
a206 11
#else      
	/*See how many clocks this system has */	
	switch (hwrpb->rpb_type) {
	case ST_DEC_3000_500:
	case ST_DEC_3000_300:
		nclocks = 1;
		break;
	default:
		nclocks = 0;
	}
#endif
d221 5
d227 1
a227 1
	struct confargs *ca = aux;
d229 8
a236 2
	Mach_clock_addr = (struct chiptime *)
		MACH_PHYS_TO_UNCACHED(BUS_CVTADDR(ca));
d247 1
a247 1
	MachEmptyWriteBuffer();
d264 4
d272 1
a272 1
	hz = RTC_HZ;		/* Clock Hz is a configuration parameter */
d274 3
d289 10
a298 1
	MachEmptyWriteBuffer();		/* Alpha needs this */
d375 1
a375 1
		s = splx();
d427 1
a427 1
		printf("WARNING: clock %s %d days",
d454 1
d488 1
a488 1
	MachEmptyWriteBuffer();
d490 1
a490 1
	MachEmptyWriteBuffer();
d499 1
a499 1
	MachEmptyWriteBuffer();
d503 1
a503 1
	MachEmptyWriteBuffer();
d510 1
a510 1
	MachEmptyWriteBuffer();
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: clock.c,v 1.8 1995/08/10 10:50:58 jonathan Exp $	*/
d256 6
d263 4
d268 4
d305 6
a310 1
	/* don't read clock registers while they are being updated */
d312 6
a317 2
	while ((c->rega & REGA_UIP) == 1)
		;
d321 1
a321 1
	day = c->day + 1;
d323 2
a324 1
	year = c->year + YR_OFFSET;
d327 7
d386 1
a386 1
	int sec, min, hour, day, mon, year;
d389 4
a393 1
	t2 = time.tv_sec / SECDAY;
d419 5
d425 2
a426 2
	t = c->regb;
	c->regb = t | REGB_SET_TIME;
d428 3
d434 2
a435 1
	c->day = day - 1;
d437 5
a441 2
	c->year = year - YR_OFFSET;
	c->regb = t;
d444 6
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
