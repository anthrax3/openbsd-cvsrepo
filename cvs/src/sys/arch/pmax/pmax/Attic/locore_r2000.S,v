head	1.6;
access;
symbols
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	UBC_SYNC_A:1.6
	UBC_SYNC_B:1.6
	OPENBSD_2_9:1.5.0.14
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.12
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.10
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.8
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.6
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.4
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@# @;


1.6
date	2001.06.24.23.48.40;	author deraadt;	state dead;
branches;
next	1.5;

1.5
date	98.10.15.21.30.17;	author imp;	state Exp;
branches
	1.5.8.1;
next	1.4;

1.4
date	98.09.15.10.53.55;	author pefo;	state Exp;
branches;
next	1.3;

1.3
date	98.05.18.00.28.22;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.12.22.15.18.32;	author graichen;	state Exp;
branches;
next	1.1;

1.1
date	96.09.29.11.36.47;	author deraadt;	state Exp;
branches;
next	;

1.5.8.1
date	2001.07.04.10.21.45;	author niklas;	state dead;
branches;
next	;


desc
@@


1.6
log
@bye bye, with prejudice
@
text
@/*	$NetBSD: locore_r2000.S,v 1.27 1996/10/13 21:37:41 jonathan Exp $	*/

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Digital Equipment Corporation and Ralph Campbell.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * Copyright (C) 1989 Digital Equipment Corporation.
 * Permission to use, copy, modify, and distribute this software and
 * its documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appears in all copies.
 * Digital Equipment Corporation makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 * from: Header: /sprite/src/kernel/mach/ds3100.md/RCS/loMem.s,
 *	v 1.1 89/07/11 17:55:04 nelson Exp  SPRITE (DECWRL)
 * from: Header: /sprite/src/kernel/mach/ds3100.md/RCS/machAsm.s,
 *	v 9.2 90/01/29 18:00:39 shirriff Exp  SPRITE (DECWRL)
 * from: Header: /sprite/src/kernel/vm/ds3100.md/vmPmaxAsm.s,
 *	v 1.1 89/07/10 14:27:41 nelson Exp  SPRITE (DECWRL)
 *
 *	@@(#)locore.s	8.5 (Berkeley) 1/4/94
 */

/*
 *----------------------------------------------------------------------------
 *
 * mips1_UTLBmiss --
 *
 *	Vector code for a MIPS-I user-space TLB miss from user-space.
 *
 *
 * This code is copied to the UTLB exception vector address to
 * handle user level TLB translation misses.
 * NOTE: This code must be relocatable!!!
 */
	.globl	_C_LABEL(mips1_UTLBMiss)
_C_LABEL(mips1_UTLBMiss):
	.set	noat
	mfc0	k0, MIPS_COP_0_BAD_VADDR	# get the virtual address
	lw	k1, UADDR+U_PCB_SEGTAB		# get the current segment table
	bltz	k0, 1f				# R3000 chip bug
	srl	k0, k0, SEGSHIFT		# compute segment table index
	sll	k0, k0, 2
	addu	k1, k1, k0
	mfc0	k0, MIPS_COP_0_BAD_VADDR	# get the virtual address
	lw	k1, 0(k1)			# get pointer to segment map
	srl	k0, k0, PGSHIFT - 2		# compute segment map index
	andi	k0, k0, (NPTEPG - 1) << 2
	beq	k1, zero, 2f			# invalid segment map
	addu	k1, k1, k0			# index into segment map
	lw	k0, 0(k1)			# get page PTE
	nop
	beq	k0, zero, 2f			# dont load invalid entries
	mtc0	k0, MIPS_COP_0_TLB_LOW
	mfc0	k1, MIPS_COP_0_EXC_PC		# get return address
	tlbwr					# update TLB
	j	k1
	rfe
1:
	mfc0	k1, MIPS_COP_0_EXC_PC		# get return address
	nop
	j	k1
	rfe
2:
	j	mips1_SlowFault			# handle the rest
	nop
	.set	at
	.globl	_C_LABEL(mips1_UTLBMissEnd)
_C_LABEL(mips1_UTLBMissEnd):


/*
 *----------------------------------------------------------------------------
 *
 * mips1_execption --
 *
 *	Vector code for the general exception vector 0x80000080
 *	on an r2000 or r3000.
 *
 * This code is copied to the general exception vector address to
 * handle all execptions except RESET and UTLBMiss.
 * NOTE: This code must be relocatable!!!
 *
 *----------------------------------------------------------------------------
 */
	.globl	_C_LABEL(mips1_exception)
_C_LABEL(mips1_exception):
/*
 * Find out what mode we came from and jump to the proper handler.
 */
	.set	noat
	mfc0	k0, MIPS_COP_0_STATUS_REG	# Get the status register
	mfc0	k1, MIPS_COP_0_CAUSE_REG	# Get the cause register value.
	and	k0, k0, MIPS1_SR_KU_PREV	# test for user mode
	sll	k0, k0, 4			# shift user bit for cause index
	and	k1, k1, MIPS1_CR_EXC_CODE	# Mask out the cause bits.
	or	k1, k1, k0			# change index to user table
1:
	la	k0, _C_LABEL(mips1_ExceptionTable) # get base of the jump table
	addu	k0, k0, k1			# Get the address of the
						#  function entry.  Note that
						#  the cause is already
						#  shifted left by 2 bits so
						#  we dont have to shift.
	lw	k0, 0(k0)			# Get the function address
	nop
	j	k0				# Jump to the function.
	nop
	.set	at
	.globl	_C_LABEL(mips1_exceptionEnd)
_C_LABEL(mips1_exceptionEnd):




/*----------------------------------------------------------------------------
 *
 * mips1_SlowFault --
 *
 * Alternate entry point into the mips1_UserGenExceptionor or
 * or mips1_user_Kern_exception, when the ULTB miss handler couldn't
 * find a TLB entry.
 *
 * Find out what mode we came from and call the appropriate handler.
 */
mips1_SlowFault:
	.set	noat
	mfc0	k0, MIPS_COP_0_STATUS_REG
	nop
	and	k0, k0, MIPS_SR_KU_PREV
	bne	k0, zero, _C_LABEL(mips1_UserGenException)
	nop
	.set	at
/*
 * Fall though ...
 */

/*----------------------------------------------------------------------------
 *
 * mips1_KernGenException --
 *
 *	Handle an exception from kernel mode.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------------
 */

/*
 * The kernel exception stack contains 18 saved general registers,
 * the status register and the multiply lo and high registers.
 * In addition, we set this up for linkage conventions.
 */
#define KERN_REG_SIZE		(18 * 4)
#define KERN_REG_OFFSET		(STAND_FRAME_SIZE)
#define KERN_SR_OFFSET		(STAND_FRAME_SIZE + KERN_REG_SIZE)
#define KERN_MULT_LO_OFFSET	(STAND_FRAME_SIZE + KERN_REG_SIZE + 4)
#define KERN_MULT_HI_OFFSET	(STAND_FRAME_SIZE + KERN_REG_SIZE + 8)
#define	KERN_EXC_FRAME_SIZE	(STAND_FRAME_SIZE + KERN_REG_SIZE + 12)

NNON_LEAF(mips1_KernGenException, KERN_EXC_FRAME_SIZE, ra)
	.set	noat
#ifdef KADB
	la	k0, kdbpcb			# save registers for kadb
	sw	s0, (S0 * 4)(k0)
	sw	s1, (S1 * 4)(k0)
	sw	s2, (S2 * 4)(k0)
	sw	s3, (S3 * 4)(k0)
	sw	s4, (S4 * 4)(k0)
	sw	s5, (S5 * 4)(k0)
	sw	s6, (S6 * 4)(k0)
	sw	s7, (S7 * 4)(k0)
	sw	s8, (S8 * 4)(k0)
	sw	gp, (GP * 4)(k0)
	sw	sp, (SP * 4)(k0)
#endif
	subu	sp, sp, KERN_EXC_FRAME_SIZE
	.mask	0x80000000, (STAND_RA_OFFSET - KERN_EXC_FRAME_SIZE)
/*
 * Save the relevant kernel registers onto the stack.
 * We don't need to save s0 - s8, sp and gp because
 * the compiler does it for us.
 */
	sw	AT, KERN_REG_OFFSET + 0(sp)
	sw	v0, KERN_REG_OFFSET + 4(sp)
	sw	v1, KERN_REG_OFFSET + 8(sp)
	sw	a0, KERN_REG_OFFSET + 12(sp)
	mflo	v0
	mfhi	v1
	sw	a1, KERN_REG_OFFSET + 16(sp)
	sw	a2, KERN_REG_OFFSET + 20(sp)
	sw	a3, KERN_REG_OFFSET + 24(sp)
	sw	t0, KERN_REG_OFFSET + 28(sp)
	mfc0	a0, MIPS_COP_0_STATUS_REG	# First arg is the status reg.
	sw	t1, KERN_REG_OFFSET + 32(sp)
	sw	t2, KERN_REG_OFFSET + 36(sp)
	sw	t3, KERN_REG_OFFSET + 40(sp)
	sw	t4, KERN_REG_OFFSET + 44(sp)
	mfc0	a1, MIPS_COP_0_CAUSE_REG	# Second arg is the cause reg.
	sw	t5, KERN_REG_OFFSET + 48(sp)
	sw	t6, KERN_REG_OFFSET + 52(sp)
	sw	t7, KERN_REG_OFFSET + 56(sp)
	sw	t8, KERN_REG_OFFSET + 60(sp)
	mfc0	a2, MIPS_COP_0_BAD_VADDR	# Third arg is the fault addr.
	sw	t9, KERN_REG_OFFSET + 64(sp)
	sw	ra, KERN_REG_OFFSET + 68(sp)
	sw	v0, KERN_MULT_LO_OFFSET(sp)
	sw	v1, KERN_MULT_HI_OFFSET(sp)
	mfc0	a3, MIPS_COP_0_EXC_PC		# Fourth arg is the pc.
	sw	a0, KERN_SR_OFFSET(sp)
/*
 * Call the exception handler.
 */
	jal	_C_LABEL(trap)
	sw	a3, STAND_RA_OFFSET(sp)		# for debugging
/*
 * Restore registers and return from the exception.
 * v0 contains the return address.
 */
	lw	a0, KERN_SR_OFFSET(sp)
	lw	t0, KERN_MULT_LO_OFFSET(sp)
	lw	t1, KERN_MULT_HI_OFFSET(sp)
	mtc0	a0, MIPS_COP_0_STATUS_REG	# Restore the SR, disable intrs
	mtlo	t0
	mthi	t1
	move	k0, v0

	lw	AT, KERN_REG_OFFSET + 0(sp)
	lw	v0, KERN_REG_OFFSET + 4(sp)

	RESTORE_KERN_REGISTERS(KERN_REG_OFFSET)

	addu	sp, sp, KERN_EXC_FRAME_SIZE
	j	k0				# Now return from the
	rfe					#  exception.
	.set	at
END(mips1_KernGenException)

/*----------------------------------------------------------------------------
 *
 * mips1_UserGenException --
 *
 *	Handle an exception from user mode.
 *
 * Results:
 * 	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------------
 */
NNON_LEAF(mips1_UserGenException, STAND_FRAME_SIZE, ra)
	.set	noat
	.mask	0x80000000, (STAND_RA_OFFSET - STAND_FRAME_SIZE)
/*
 * Save all of the registers except for the kernel temporaries in u.u_pcb.
 */
	sw	AT, UADDR+U_PCB_REGS+(AST * 4)
	sw	v0, UADDR+U_PCB_REGS+(V0 * 4)
	sw	v1, UADDR+U_PCB_REGS+(V1 * 4)
	sw	a0, UADDR+U_PCB_REGS+(A0 * 4)
	mflo	v0
	sw	a1, UADDR+U_PCB_REGS+(A1 * 4)
	sw	a2, UADDR+U_PCB_REGS+(A2 * 4)
	sw	a3, UADDR+U_PCB_REGS+(A3 * 4)
	sw	t0, UADDR+U_PCB_REGS+(T0 * 4)
	mfhi	v1
	sw	t1, UADDR+U_PCB_REGS+(T1 * 4)
	sw	t2, UADDR+U_PCB_REGS+(T2 * 4)
	sw	t3, UADDR+U_PCB_REGS+(T3 * 4)
	sw	t4, UADDR+U_PCB_REGS+(T4 * 4)
	mfc0	a0, MIPS_COP_0_STATUS_REG	# First arg is the status reg.
	sw	t5, UADDR+U_PCB_REGS+(T5 * 4)
	sw	t6, UADDR+U_PCB_REGS+(T6 * 4)
	sw	t7, UADDR+U_PCB_REGS+(T7 * 4)
	sw	s0, UADDR+U_PCB_REGS+(S0 * 4)
	mfc0	a1, MIPS_COP_0_CAUSE_REG	# Second arg is the cause reg.
	sw	s1, UADDR+U_PCB_REGS+(S1 * 4)
	sw	s2, UADDR+U_PCB_REGS+(S2 * 4)
	sw	s3, UADDR+U_PCB_REGS+(S3 * 4)
	sw	s4, UADDR+U_PCB_REGS+(S4 * 4)
	mfc0	a2, MIPS_COP_0_BAD_VADDR	# Third arg is the fault addr
	sw	s5, UADDR+U_PCB_REGS+(S5 * 4)
	sw	s6, UADDR+U_PCB_REGS+(S6 * 4)
	sw	s7, UADDR+U_PCB_REGS+(S7 * 4)
	sw	t8, UADDR+U_PCB_REGS+(T8 * 4)
	mfc0	a3, MIPS_COP_0_EXC_PC		# Fourth arg is the pc.
	sw	t9, UADDR+U_PCB_REGS+(T9 * 4)
	sw	gp, UADDR+U_PCB_REGS+(GP * 4)
	sw	sp, UADDR+U_PCB_REGS+(SP * 4)
	sw	s8, UADDR+U_PCB_REGS+(S8 * 4)
	li	sp, KERNELSTACK - STAND_FRAME_SIZE	# switch to kernel SP
	sw	ra, UADDR+U_PCB_REGS+(RA * 4)
	sw	v0, UADDR+U_PCB_REGS+(MULLO * 4)
	sw	v1, UADDR+U_PCB_REGS+(MULHI * 4)
	sw	a0, UADDR+U_PCB_REGS+(SR * 4)
#ifdef __GP_SUPPORT__
	la	gp, _C_LABEL(_gp)		# switch to kernel GP
#endif
	sw	a3, UADDR+U_PCB_REGS+(PC * 4)
	sw	a3, STAND_RA_OFFSET(sp)		# for debugging
	.set	at
	and	t0, a0, ~MIPS_SR_COP_1_BIT	# Turn off the FPU.
	.set	noat
/*
 * Call the exception handler.
 */
	jal	_C_LABEL(trap)
	mtc0	t0, MIPS_COP_0_STATUS_REG
/*
 * Restore user registers and return. NOTE: interrupts are enabled.
 */
	lw	a0, UADDR+U_PCB_REGS+(SR * 4)
	lw	t0, UADDR+U_PCB_REGS+(MULLO * 4)
	lw	t1, UADDR+U_PCB_REGS+(MULHI * 4)
	mtc0	a0, MIPS_COP_0_STATUS_REG	# this should disable interrupts
	mtlo	t0
	mthi	t1
	lw	k0, UADDR+U_PCB_REGS+(PC * 4)
	lw	AT, UADDR+U_PCB_REGS+(AST * 4)
	lw	v0, UADDR+U_PCB_REGS+(V0 * 4)

	RESTORE_USER_REGS(UADDR)

	j	k0
	rfe
	.set	at
END(mips1_UserGenException)

/*----------------------------------------------------------------------------
 *
 * mips1_KernIntr --
 *
 *	Handle an interrupt from kernel mode.
 *	Interrupts use the standard kernel stack.
 *	switch_exit sets up a kernel stack after exit so interrupts won't fail.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------------
 */
#define KINTR_REG_OFFSET	(STAND_FRAME_SIZE)
#define KINTR_SR_OFFSET		(STAND_FRAME_SIZE + KERN_REG_SIZE)
#define KINTR_MULT_LO_OFFSET	(STAND_FRAME_SIZE + KERN_REG_SIZE + 4)
#define KINTR_MULT_HI_OFFSET	(STAND_FRAME_SIZE + KERN_REG_SIZE + 8)
#define KINTR_GP_OFFSET		(STAND_FRAME_SIZE + KERN_REG_SIZE + 12)
#define	KINTR_FRAME_SIZE	(STAND_FRAME_SIZE + KERN_REG_SIZE + 16)

NNON_LEAF(mips1_KernIntr, KINTR_FRAME_SIZE, ra)
	.set	noat
	subu	sp, sp, KINTR_FRAME_SIZE	# allocate stack frame
	.mask	0x80000000, (STAND_RA_OFFSET - KINTR_FRAME_SIZE)
/*
 * Save the relevant kernel registers onto the stack.
 * We don't need to save s0 - s8 and sp because
 * the compiler does it for us.
 */
	sw	AT, KINTR_REG_OFFSET + 0(sp)
	sw	v0, KINTR_REG_OFFSET + 4(sp)
	sw	v1, KINTR_REG_OFFSET + 8(sp)
	sw	a0, KINTR_REG_OFFSET + 12(sp)
	mflo	v0
	mfhi	v1
	sw	a1, KINTR_REG_OFFSET + 16(sp)
	sw	a2, KINTR_REG_OFFSET + 20(sp)
	sw	a3, KINTR_REG_OFFSET + 24(sp)
	sw	t0, KINTR_REG_OFFSET + 28(sp)
	mfc0	a0, MIPS_COP_0_STATUS_REG	# First arg is the status reg.
	sw	t1, KINTR_REG_OFFSET + 32(sp)
	sw	t2, KINTR_REG_OFFSET + 36(sp)
	sw	t3, KINTR_REG_OFFSET + 40(sp)
	sw	t4, KINTR_REG_OFFSET + 44(sp)
	mfc0	a1, MIPS_COP_0_CAUSE_REG	# Second arg is the cause reg.
	sw	t5, KINTR_REG_OFFSET + 48(sp)
	sw	t6, KINTR_REG_OFFSET + 52(sp)
	sw	t7, KINTR_REG_OFFSET + 56(sp)
	sw	t8, KINTR_REG_OFFSET + 60(sp)
	mfc0	a2, MIPS_COP_0_EXC_PC		# Third arg is the pc.
	sw	t9, KINTR_REG_OFFSET + 64(sp)
	sw	ra, KINTR_REG_OFFSET + 68(sp)
	sw	v0, KINTR_MULT_LO_OFFSET(sp)
	sw	v1, KINTR_MULT_HI_OFFSET(sp)
	sw	a0, KINTR_SR_OFFSET(sp)
	sw	gp, KINTR_GP_OFFSET(sp)
#ifdef __GP_SUPPORT__
	la	gp, _C_LABEL(_gp)		# switch to kernel GP
#endif
/*
 * Call the interrupt handler.
 */
	jal	_C_LABEL(interrupt)
	sw	a2, STAND_RA_OFFSET(sp)		# for debugging
/*
 * Restore registers and return from the interrupt.
 */
	lw	a0, KINTR_SR_OFFSET(sp)
	lw	t0, KINTR_MULT_LO_OFFSET(sp)
	lw	t1, KINTR_MULT_HI_OFFSET(sp)
	mtc0	a0, MIPS_COP_0_STATUS_REG	# Restore the SR, disable intrs
	mtlo	t0
	mthi	t1
	lw	k0, STAND_RA_OFFSET(sp)
	lw	AT, KINTR_REG_OFFSET + 0(sp)
	lw	v0, KINTR_REG_OFFSET + 4(sp)

	RESTORE_KERN_REGISTERS(KINTR_REG_OFFSET)

	addu	sp, sp, KINTR_FRAME_SIZE
	j	k0				# Now return from the
	rfe					#  interrupt.
	.set	at
END(mips1_KernIntr)

/*----------------------------------------------------------------------------
 *
 * mips1_UserIntr --
 *
 *	Handle an interrupt from user mode.
 *	Note: we save minimal state in the u.u_pcb struct and use the standard
 *	kernel stack since there has to be a u page if we came from user mode.
 *	If there is a pending software interrupt, then save the remaining state
 *	and call softintr(). This is all because if we call switch() inside
 *	interrupt(), not all the user registers have been saved in u.u_pcb.
 *
 * Results:
 * 	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------------
 */
NNON_LEAF(mips1_UserIntr, STAND_FRAME_SIZE, ra)
	.set	noat
	.mask	0x80000000, (STAND_RA_OFFSET - STAND_FRAME_SIZE)
/*
 * Save the relevant user registers into the u.u_pcb struct.
 * We don't need to save s0 - s8 because
 * the compiler does it for us.
 */
	sw	AT, UADDR+U_PCB_REGS+(AST * 4)
	sw	v0, UADDR+U_PCB_REGS+(V0 * 4)
	sw	v1, UADDR+U_PCB_REGS+(V1 * 4)
	sw	a0, UADDR+U_PCB_REGS+(A0 * 4)
	mflo	v0
	mfhi	v1
	sw	a1, UADDR+U_PCB_REGS+(A1 * 4)
	sw	a2, UADDR+U_PCB_REGS+(A2 * 4)
	sw	a3, UADDR+U_PCB_REGS+(A3 * 4)
	sw	t0, UADDR+U_PCB_REGS+(T0 * 4)
	mfc0	a0, MIPS_COP_0_STATUS_REG	# First arg is the status reg.
	sw	t1, UADDR+U_PCB_REGS+(T1 * 4)
	sw	t2, UADDR+U_PCB_REGS+(T2 * 4)
	sw	t3, UADDR+U_PCB_REGS+(T3 * 4)
	sw	t4, UADDR+U_PCB_REGS+(T4 * 4)
	mfc0	a1, MIPS_COP_0_CAUSE_REG	# Second arg is the cause reg.
	sw	t5, UADDR+U_PCB_REGS+(T5 * 4)
	sw	t6, UADDR+U_PCB_REGS+(T6 * 4)
	sw	t7, UADDR+U_PCB_REGS+(T7 * 4)
	sw	t8, UADDR+U_PCB_REGS+(T8 * 4)
	mfc0	a2, MIPS_COP_0_EXC_PC		# Third arg is the pc.
	sw	t9, UADDR+U_PCB_REGS+(T9 * 4)
	sw	gp, UADDR+U_PCB_REGS+(GP * 4)
	sw	sp, UADDR+U_PCB_REGS+(SP * 4)
	sw	ra, UADDR+U_PCB_REGS+(RA * 4)
	li	sp, KERNELSTACK - STAND_FRAME_SIZE	# switch to kernel SP
	sw	v0, UADDR+U_PCB_REGS+(MULLO * 4)
	sw	v1, UADDR+U_PCB_REGS+(MULHI * 4)
	sw	a0, UADDR+U_PCB_REGS+(SR * 4)
	sw	a2, UADDR+U_PCB_REGS+(PC * 4)
#ifdef __GP_SUPPORT__
	la	gp, _C_LABEL(_gp)		# switch to kernel GP
#endif
	.set	at
	and	t0, a0, ~MIPS_SR_COP_1_BIT	# Turn off the FPU.
	.set	noat
	mtc0	t0, MIPS_COP_0_STATUS_REG
/*
 * Call the interrupt handler.
 */
	jal	_C_LABEL(interrupt)
	sw	a2, STAND_RA_OFFSET(sp)		# for debugging
/*
 * Restore registers and return from the interrupt.
 */
	lw	a0, UADDR+U_PCB_REGS+(SR * 4)
	lw	v0, _C_LABEL(astpending)	# any pending interrupts?
	mtc0	a0, MIPS_COP_0_STATUS_REG	# Restore the SR, disable intrs
	bne	v0, zero, 1f			# dont restore, call softintr
	lw	t0, UADDR+U_PCB_REGS+(MULLO * 4)
	lw	t1, UADDR+U_PCB_REGS+(MULHI * 4)
	lw	k0, UADDR+U_PCB_REGS+(PC * 4)
	lw	AT, UADDR+U_PCB_REGS+(AST * 4)
	lw	v0, UADDR+U_PCB_REGS+(V0 * 4)
	lw	v1, UADDR+U_PCB_REGS+(V1 * 4)
	lw	a0, UADDR+U_PCB_REGS+(A0 * 4)
	lw	a1, UADDR+U_PCB_REGS+(A1 * 4)
	lw	a2, UADDR+U_PCB_REGS+(A2 * 4)
	lw	a3, UADDR+U_PCB_REGS+(A3 * 4)
	mtlo	t0
	mthi	t1
	lw	t0, UADDR+U_PCB_REGS+(T0 * 4)
	lw	t1, UADDR+U_PCB_REGS+(T1 * 4)
	lw	t2, UADDR+U_PCB_REGS+(T2 * 4)
	lw	t3, UADDR+U_PCB_REGS+(T3 * 4)
	lw	t4, UADDR+U_PCB_REGS+(T4 * 4)
	lw	t5, UADDR+U_PCB_REGS+(T5 * 4)
	lw	t6, UADDR+U_PCB_REGS+(T6 * 4)
	lw	t7, UADDR+U_PCB_REGS+(T7 * 4)
	lw	t8, UADDR+U_PCB_REGS+(T8 * 4)
	lw	t9, UADDR+U_PCB_REGS+(T9 * 4)
	lw	gp, UADDR+U_PCB_REGS+(GP * 4)
	lw	sp, UADDR+U_PCB_REGS+(SP * 4)
	lw	ra, UADDR+U_PCB_REGS+(RA * 4)
	j	k0				# Now return from the
	rfe					#  interrupt.

1:
/*
 * We have pending software interrupts; save remaining user state in u.u_pcb.
 */
	sw	s0, UADDR+U_PCB_REGS+(S0 * 4)
	sw	s1, UADDR+U_PCB_REGS+(S1 * 4)
	sw	s2, UADDR+U_PCB_REGS+(S2 * 4)
	sw	s3, UADDR+U_PCB_REGS+(S3 * 4)
	sw	s4, UADDR+U_PCB_REGS+(S4 * 4)
	sw	s5, UADDR+U_PCB_REGS+(S5 * 4)
	sw	s6, UADDR+U_PCB_REGS+(S6 * 4)
	sw	s7, UADDR+U_PCB_REGS+(S7 * 4)
	sw	s8, UADDR+U_PCB_REGS+(S8 * 4)
	li	t0, MIPS_HARD_INT_MASK | MIPS_SR_INT_IE
/*
 * Call the software interrupt handler.
 */
	jal	_C_LABEL(softintr)
	mtc0	t0, MIPS_COP_0_STATUS_REG	# enable interrupts (spl0)
/*
 * Restore user registers and return. NOTE: interrupts are enabled.
 */
	lw	a0, UADDR+U_PCB_REGS+(SR * 4)
	lw	t0, UADDR+U_PCB_REGS+(MULLO * 4)
	lw	t1, UADDR+U_PCB_REGS+(MULHI * 4)
	mtc0	a0, MIPS_COP_0_STATUS_REG	# this should disable interrupts
	mtlo	t0
	mthi	t1
	lw	k0, UADDR+U_PCB_REGS+(PC * 4)
	lw	AT, UADDR+U_PCB_REGS+(AST * 4)
	lw	v0, UADDR+U_PCB_REGS+(V0 * 4)

	RESTORE_USER_REGS(UADDR)

	j	k0
	rfe
	.set	at
END(mips1_UserIntr)

/*
 *  Mark where code entreed from exception hander jumptable
 * ends, for stack traceback code.
 */

	.globl	_C_LABEL(mips1_exceptionentry_end)
_C_LABEL(mips1_exceptionentry_end):


/*----------------------------------------------------------------------------
 *
 *		XXX  START of r3000-specific code  XXX 
 *
 *----------------------------------------------------------------------------
 */



#if 0
/*----------------------------------------------------------------------------
 *
 * mips1_TLBModException --
 *
 *	Handle a TLB modified exception.
 *	The BaddVAddr, Context, and EntryHi registers contain the failed
 *	virtual address.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------------
 */
NLEAF(mips1_TLBModException)
	.set	noat
	tlbp					# find the TLB entry
	mfc0	k0, MIPS_COP_0_TLB_LOW		# get the physical address
	mfc0	k1, MIPS_COP_0_TLB_INDEX	# check to be sure its valid
	or	k0, k0, MIPS1_TLB_MOD_BIT	# update TLB
	blt	k1, zero, 4f			# not found!!!
	mtc0	k0, MIPS_COP_0_TLB_LOW
	li	k1, MIPS_KSEG0_START
	subu	k0, k0, k1
	srl	k0, k0, MIPS1_TLB_PHYS_PAGE_SHIFT
	la	k1, pmap_attributes
	addu	k0, k0, k1
	lbu	k1, 0(k0)			# fetch old value
	nop
	or	k1, k1, 1			# set modified bit
	sb	k1, 0(k0)			# save new value
	mfc0	k0, MIPS_COP_0_EXC_PC		# get return address
	nop
	j	k0
	rfe
4:
	break	0				# panic
	.set	at
END(mips1_TLBModException)
#endif

/*----------------------------------------------------------------------------
 *
 * mips1_TLBMissException --
 *
 *	Handle a TLB miss exception from kernel mode.
 *	The BaddVAddr, Context, and EntryHi registers contain the failed
 *	virtual address.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------------
 */
NLEAF(mips1_TLBMissException)
	.set	noat
	mfc0	k0, MIPS_COP_0_BAD_VADDR	# get the fault address
	li	k1, VM_MIN_KERNEL_ADDRESS	# compute index
	subu	k0, k0, k1
	lw	k1, _C_LABEL(Sysmapsize)	# index within range?
	srl	k0, k0, PGSHIFT
	sltu	k1, k0, k1
	beq	k1, zero, 1f			# No. check for valid stack
	nop
	lw	k1, _C_LABEL(Sysmap)
	sll	k0, k0, 2			# compute offset from index
	addu	k1, k1, k0
	lw	k0, 0(k1)			# get PTE entry
	mfc0	k1, MIPS_COP_0_EXC_PC		# get return address
	mtc0	k0, MIPS_COP_0_TLB_LOW		# save PTE entry
	and	k0, k0, PG_V			# check for valid entry
	beq	k0, zero, _C_LABEL(mips1_KernGenException) # PTE invalid
	nop
	tlbwr					# update TLB
	j	k1
	rfe

1:
	subu	k0, sp, UADDR + 0x200		# check to see if we have a
	sltiu	k0, UPAGES*NBPG - 0x200		#  valid kernel stack
	bne	k0, zero, _C_LABEL(mips1_KernGenException) # Go panic
	nop

	la	a0, start - START_FRAME - 8	# set sp to a valid place
	sw	sp, 24(a0)
	move	sp, a0
	la	a0, 1f
	mfc0	a2, MIPS_COP_0_STATUS_REG
	mfc0	a3, MIPS_COP_0_CAUSE_REG
	mfc0	a1, MIPS_COP_0_EXC_PC
	sw	a2, 16(sp)
	sw	a3, 20(sp)
	sw	sp, 24(sp)
	move	a2, ra
	jal	_C_LABEL(printf)
	mfc0	a3, MIPS_COP_0_BAD_VADDR
	.data
1:
	.asciiz	"ktlbmiss: PC %x RA %x ADR %x\nSR %x CR %x SP %x\n"
	.text

	la	sp, start - START_FRAME		# set sp to a valid place
	PANIC("kernel stack overflow")
	.set	at
END(mips1_TLBMissException)


/*--------------------------------------------------------------------------
 *
 * mips1_TLBWriteIndexed --
 *
 *	Write the given entry into the TLB at the given index.
 *
 *	mips1_TLBWriteIndexed(index, highEntry, lowEntry)
 *		int index;
 *		int highEntry;
 *		int lowEntry;
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	TLB entry set.
 *
 *--------------------------------------------------------------------------
 */
LEAF(mips1_TLBWriteIndexed)
	mfc0	v1, MIPS_COP_0_STATUS_REG	# Save the status register.
	mtc0	zero, MIPS_COP_0_STATUS_REG	# Disable interrupts
	mfc0	t0, MIPS_COP_0_TLB_HI		# Save the current PID.

	sll	a0, a0, MIPS1_TLB_INDEX_SHIFT
	mtc0	a0, MIPS_COP_0_TLB_INDEX	# Set the index.
	mtc0	a1, MIPS_COP_0_TLB_HI		# Set up entry high.
	mtc0	a2, MIPS_COP_0_TLB_LOW		# Set up entry low.
	nop
	tlbwi					# Write the TLB

	mtc0	t0, MIPS_COP_0_TLB_HI		# Restore the PID.
	j	ra
	mtc0	v1, MIPS_COP_0_STATUS_REG	# Restore the status register
END(mips1_TLBWriteIndexed)

#if 0
/*--------------------------------------------------------------------------
 *
 * mips1_TLBWriteRandom --
 *
 *	Write the given entry into the TLB at a random location.
 *
 *	mips1_TLBWriteRandom(highEntry, lowEntry)
 *		unsigned highEntry;
 *		unsigned lowEntry;
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	TLB entry set.
 *
 *--------------------------------------------------------------------------
 */
LEAF(mips1_TLBWriteRandom)
	mfc0	v1, MIPS_COP_0_STATUS_REG	# Save the status register.
	mtc0	zero, MIPS_COP_0_STATUS_REG	# Disable interrupts
	mfc0	v0, MIPS_COP_0_TLB_HI		# Save the current PID.
	nop

	mtc0	a0, MIPS_COP_0_TLB_HI		# Set up entry high.
	mtc0	a1, MIPS_COP_0_TLB_LOW		# Set up entry low.
	nop
	tlbwr					# Write the TLB

	mtc0	v0, MIPS_COP_0_TLB_HI		# Restore the PID.
	j	ra
	mtc0	v1, MIPS_COP_0_STATUS_REG	# Restore the status register
END(mips1_TLBWriteRandom)
#endif

/*--------------------------------------------------------------------------
 *
 * mips1_SetPID --
 *
 *	Write the given pid into the TLB pid reg.
 *
 *	mips1_SetPID(pid)
 *		int pid;
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	PID set in the entry hi register.
 *
 *--------------------------------------------------------------------------
 */
LEAF(mips1_SetPID)
	sll	a0, a0, MIPS_TLB_PID_SHIFT	# put PID in right spot
	mtc0	a0, MIPS_COP_0_TLB_HI		# Write the hi reg value
	j	ra
	nop
END(mips1_SetPID)

/*--------------------------------------------------------------------------
 *
 * mips1_TLBFlush --
 *
 *	Flush the "random" entries from the TLB.
 *
 *	mips1_TLBFlush()
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The TLB is flushed.
 *
 *--------------------------------------------------------------------------
 */
LEAF(mips1_TLBFlush)
	mfc0	v1, MIPS_COP_0_STATUS_REG	# Save the status register.
	mtc0	zero, MIPS_COP_0_STATUS_REG	# Disable interrupts
	mfc0	t0, MIPS_COP_0_TLB_HI		# Save the PID
	li	t1, MIPS_KSEG0_START		# invalid address
	mtc0	t1, MIPS_COP_0_TLB_HI		# Mark entry high as invalid
	mtc0	zero, MIPS_COP_0_TLB_LOW	# Zero out low entry.
/*
 * Align the starting value (t1) and the upper bound (t2).
 */
	li	t1, MIPS1_TLB_FIRST_RAND_ENTRY << MIPS1_TLB_INDEX_SHIFT
	li	t2, MIPS1_TLB_NUM_TLB_ENTRIES << MIPS1_TLB_INDEX_SHIFT
1:
	mtc0	t1, MIPS_COP_0_TLB_INDEX	# Set the index register.
	addu	t1, t1, 1 << MIPS1_TLB_INDEX_SHIFT	# Increment index.
	bne	t1, t2, 1b
	tlbwi					# Write the TLB entry.

	mtc0	t0, MIPS_COP_0_TLB_HI		# Restore the PID
	j	ra
	mtc0	v1, MIPS_COP_0_STATUS_REG	# Restore the status register
END(mips1_TLBFlush)

#if 0
/*--------------------------------------------------------------------------
 *
 * mips1_TLBFlushPID --
 *
 *	Flush all entries with the given PID from the TLB.
 *
 *	mips1_TLBFlushPID(pid)
 *		int pid;
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	All entries corresponding to this PID are flushed.
 *
 *--------------------------------------------------------------------------
 */
LEAF(mips1_TLBFlushPID)
	mfc0	v1, MIPS_COP_0_STATUS_REG	# Save the status register.
	mtc0	zero, MIPS_COP_0_STATUS_REG	# Disable interrupts
	mfc0	t0, MIPS_COP_0_TLB_HI		# Save the current PID
	sll	a0, a0, MIPS_TLB_PID_SHIFT	# Align the pid to flush.
/*
 * Align the starting value (t1) and the upper bound (t2).
 */
	li	t1, MIPS1_FIRST_RAND_ENTRY << MIPS1_TLB_INDEX_SHIFT
	li	t2, MIPS1_NUM_TLB_ENTRIES << MIPS1_TLB_INDEX_SHIFT
	mtc0	t1, MIPS_COP_0_TLB_INDEX	# Set the index register
1:
	addu	t1, t1, 1 << MIPS1_TLB_INDEX_SHIFT	# Increment index.
	tlbr					# Read from the TLB
	mfc0	t4, MIPS_COP_0_TLB_HI		# Fetch the hi register.
	nop
	and	t4, t4, MIPS1_TLB_PID		# compare PIDs
	bne	t4, a0, 2f
	li	v0, MIPS_KSEG0_START	# invalid address
	mtc0	v0, MIPS_COP_0_TLB_HI		# Mark entry high as invalid
	mtc0	zero, MIPS_COP_0_TLB_LOW	# Zero out low entry.
	nop
	tlbwi					# Write the entry.
2:
	bne	t1, t2, 1b
	mtc0	t1, MIPS_COP_0_TLB_INDEX	# Set the index register

	mtc0	t0, MIPS_COP_0_TLB_HI		# restore PID
	j	ra
	mtc0	v1, MIPS_COP_0_STATUS_REG	# Restore the status register
END(mips1_TLBFlushPID)
#endif

/*--------------------------------------------------------------------------
 *
 * mips1_TLBFlushAddr --
 *
 *	Flush any TLB entries for the given address and TLB PID.
 *
 *	mips1_TLBFlushAddr(highreg)
 *		unsigned highreg;
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The process's page is flushed from the TLB.
 *
 *--------------------------------------------------------------------------
 */
LEAF(mips1_TLBFlushAddr)
	mfc0	v1, MIPS_COP_0_STATUS_REG	# Save the status register.
	mtc0	zero, MIPS_COP_0_STATUS_REG	# Disable interrupts
	mfc0	t0, MIPS_COP_0_TLB_HI		# Get current PID
	nop

	mtc0	a0, MIPS_COP_0_TLB_HI		# look for addr & PID
	nop
	tlbp					# Probe for the entry.
	mfc0	v0, MIPS_COP_0_TLB_INDEX	# See what we got
	li	t1, MIPS_KSEG0_START	# Load invalid entry.
	bltz	v0, 1f				# index < 0 => !found
	mtc0	t1, MIPS_COP_0_TLB_HI		# Mark entry high as invalid
	mtc0	zero, MIPS_COP_0_TLB_LOW	# Zero out low entry.
	nop
	tlbwi
1:
	mtc0	t0, MIPS_COP_0_TLB_HI		# restore PID
	j	ra
	mtc0	v1, MIPS_COP_0_STATUS_REG	# Restore the status register
END(mips1_TLBFlushAddr)

/*--------------------------------------------------------------------------
 *
 * mips1_TLBUpdate --
 *
 *	Update the TLB if highreg is found; otherwise, enter the data.
 *
 *	mips1_TLBUpdate(highreg, lowreg)
 *		unsigned highreg, lowreg;
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------------------
 */
LEAF(mips1_TLBUpdate)
	mfc0	v1, MIPS_COP_0_STATUS_REG	# Save the status register.
	mtc0	zero, MIPS_COP_0_STATUS_REG	# Disable interrupts
	mfc0	t0, MIPS_COP_0_TLB_HI		# Save current PID
	nop					# 2 cycles before intr disabled
	mtc0	a0, MIPS_COP_0_TLB_HI		# init high reg.
	nop
	tlbp					# Probe for the entry.
	mfc0	v0, MIPS_COP_0_TLB_INDEX	# See what we got
	mtc0	a1, MIPS_COP_0_TLB_LOW		# init low reg.
	bltz	v0, 1f				# index < 0 => !found
	sra	v0, v0, MIPS1_TLB_INDEX_SHIFT	# convert index to regular num
	b	2f
	tlbwi					# update slot found
1:
	mtc0	a0, MIPS_COP_0_TLB_HI		# init high reg.
	nop
	tlbwr					# enter into a random slot
2:
	mtc0	t0, MIPS_COP_0_TLB_HI		# restore PID
	j	ra
	mtc0	v1, MIPS_COP_0_STATUS_REG	# Restore the status register
END(mips1_TLBUpdate)

/*--------------------------------------------------------------------------
 *
 * mips1_TLBFind --
 *
 *	Search the TLB for the given entry.
 *
 *	mips1_TLBFind(hi)
 *		unsigned hi;
 *
 * Results:
 *	Returns a value >= 0 if the entry was found (the index).
 *	Returns a value < 0 if the entry was not found.
 *
 * Side effects:
 *	tlbhi and tlblo will contain the TLB entry found.
 *
 *--------------------------------------------------------------------------
 */
	.comm	tlbhi, 4
	.comm	tlblo, 4
LEAF(mips1_TLBFind)
	mfc0	v1, MIPS_COP_0_STATUS_REG	# Save the status register.
	mtc0	zero, MIPS_COP_0_STATUS_REG	# Disable interrupts
	mfc0	t0, MIPS_COP_0_TLB_HI		# Get current PID
	nop
	mtc0	a0, MIPS_COP_0_TLB_HI		# Set up entry high.
	nop
	tlbp					# Probe for the entry.
	mfc0	v0, MIPS_COP_0_TLB_INDEX	# See what we got
	nop
	bltz	v0, 1f				# not found
	nop
	tlbr					# read TLB
	mfc0	t1, MIPS_COP_0_TLB_HI		# See what we got
	mfc0	t2, MIPS_COP_0_TLB_LOW		# See what we got
	sw	t1, tlbhi
	sw	t2, tlblo
	srl	v0, v0, MIPS1_TLB_INDEX_SHIFT	# convert index to regular num
1:
	mtc0	t0, MIPS_COP_0_TLB_HI		# Restore current PID
	j	ra
	mtc0	v1, MIPS_COP_0_STATUS_REG	# Restore the status register
END(mips1_TLBFind)

/*--------------------------------------------------------------------------
 *
 * mips1_TLBRead --
 *
 *	Read the TLB entry.
 *
 *	mips1_TLBRead(entry)
 *		unsigned entry;
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	tlbhi and tlblo will contain the TLB entry found.
 *
 *--------------------------------------------------------------------------
 */
LEAF(mips1_TLBRead)
	mfc0	v1, MIPS_COP_0_STATUS_REG	# Save the status register.
	mtc0	zero, MIPS_COP_0_STATUS_REG	# Disable interrupts
	mfc0	t0, MIPS_COP_0_TLB_HI		# Get current PID

	sll	a0, a0, MIPS1_TLB_INDEX_SHIFT
	mtc0	a0, MIPS_COP_0_TLB_INDEX	# Set the index register
	nop
	tlbr					# Read from the TLB
	mfc0	t3, MIPS_COP_0_TLB_HI		# fetch the hi entry
	mfc0	t4, MIPS_COP_0_TLB_LOW		# fetch the low entry
	sw	t3, tlbhi
	sw	t4, tlblo

	mtc0	t0, MIPS_COP_0_TLB_HI		# restore PID
	j	ra
	mtc0	v1, MIPS_COP_0_STATUS_REG	# Restore the status register
END(mips1_TLBRead)

/*--------------------------------------------------------------------------
 *
 * mips1_TLBGetPID --
 *
 *	mips1_TLBGetPID()
 *
 * Results:
 *	Returns the current TLB pid reg.
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------------------
 */
LEAF(mips1_TLBGetPID)
	mfc0	v0, MIPS_COP_0_TLB_HI		# get PID
	nop
	and	v0, v0, MIPS1_TLB_PID		# mask off PID
	j	ra
	srl	v0, v0, MIPS_TLB_PID_SHIFT	# put PID in right spot
END(mips1_TLBGetPID)


/*----------------------------------------------------------------------------
 *
 *	R3000 cache sizing and flushing code.
 *
 *----------------------------------------------------------------------------
 */


/*----------------------------------------------------------------------------
 *
 * mips1_ConfigCache --
 *
 *	Size the caches.
 *	NOTE: should only be called from mach_init().
 *
 * Results:
 *     	None.
 *
 * Side effects:
 *	The size of the data cache is stored into machDataCacheSize and the
 *	size of instruction cache is stored into machInstCacheSize.
 *
 *----------------------------------------------------------------------------
 */
NON_LEAF(mips1_ConfigCache, STAND_FRAME_SIZE, ra)
	subu	sp, sp, STAND_FRAME_SIZE
	sw	ra, STAND_RA_OFFSET(sp)		# Save return address.
	.mask	0x80000000, (STAND_RA_OFFSET - STAND_FRAME_SIZE)
	mtc0	zero, MIPS_COP_0_STATUS_REG	# Disable interrupts.
	la	v0, 1f
	or	v0, MIPS_KSEG1_START	# Run uncached.
	j	v0
	nop
1:
/*
 * This works because jal doesn't change pc[31..28] and the
 * linker still thinks SizeCache is in the cached region so it computes
 * the correct address without complaining.
 */
	jal	_C_LABEL(mips1_SizeCache)	# Get the size of the d-cache.
	nop
	sw	v0, _C_LABEL(machDataCacheSize)
	nop					# Make sure sw out of pipe
	nop
	nop
	nop
	li	v0, MIPS_SR_SWAP_CACHES		# Swap caches
	mtc0	v0, MIPS_COP_0_STATUS_REG
	nop					# Insure caches stable
	nop
	nop
	nop
	jal	_C_LABEL(mips1_SizeCache)	# Get the size of the i-cache.
	nop
	mtc0	zero, MIPS_COP_0_STATUS_REG	# Swap back caches and enable.
	nop
	nop
	nop
	nop
	sw	v0, _C_LABEL(machInstCacheSize)
	la	t0, 1f
	j	t0				# Back to cached mode
	nop
1:
	lw	ra, STAND_RA_OFFSET(sp)		# Restore return addr
	addu	sp, sp, STAND_FRAME_SIZE	# Restore sp.
	j	ra
	nop
END(mips1_ConfigCache)

/*----------------------------------------------------------------------------
 *
 * mips1_SizeCache --
 *
 *	Get the size of the cache.
 *
 * Results:
 *	The size of the cache.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------------
 */
LEAF(mips1_SizeCache)
	mfc0	t0, MIPS_COP_0_STATUS_REG	# Save the current status reg.
	nop
	or	v0, t0, MIPS_SR_ISOL_CACHES	# Isolate the caches.
	nop					# Make sure no stores in pipe
	mtc0	v0, MIPS_COP_0_STATUS_REG
	nop					# Make sure isolated
	nop
	nop
/*
 * Clear cache size boundaries.
 */
	li	v0, MIPS_MIN_CACHE_SIZE
	li	v1, MIPS_KSEG0_START
	li	t2, MIPS_MAX_CACHE_SIZE
1:
	addu	t1, v0, v1			# Compute address to clear
	sw	zero, 0(t1)			# Clear cache memory
	bne	v0, t2, 1b
	sll	v0, v0, 1

	li	v0, -1
	sw	v0, 0(v1)			# Store marker in cache
	li	v0, MIPS_MIN_CACHE_SIZE
2:
	addu	t1, v0, v1			# Compute address
	lw	t3, 0(t1)			# Look for marker
	nop
	bne	t3, zero, 3f			# Found marker.
	nop
	bne	v0, t2, 2b			# keep looking
	sll	v0, v0, 1			# cache size * 2

	move	v0, zero			# must be no cache
3:
	mtc0	t0, MIPS_COP_0_STATUS_REG
	nop					# Make sure unisolated
	nop
	nop
	nop
	j	ra
	nop
END(mips1_SizeCache)

/*----------------------------------------------------------------------------
 *
 * mips1_FlushCache --
 *
 *	Flush the caches.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The contents of the caches is flushed.
 *
 *----------------------------------------------------------------------------
 */
LEAF(mips1_FlushCache)
	lw	t1, _C_LABEL(machInstCacheSize)	# Must load before isolating
	lw	t2, _C_LABEL(machDataCacheSize)	# Must load before isolating
	mfc0	t3, MIPS_COP_0_STATUS_REG 	# Save the status register.
	mtc0	zero, MIPS_COP_0_STATUS_REG	# Disable interrupts.
	la	v0, 1f
	or	v0, MIPS_KSEG1_START	# Run uncached.
	j	v0
	nop
/*
 * Flush the instruction cache.
 */
1:
	li	v0, MIPS_SR_ISOL_CACHES | MIPS_SR_SWAP_CACHES
	mtc0	v0, MIPS_COP_0_STATUS_REG	# Isolate and swap caches.
	li	t0, MIPS_KSEG1_START
	subu	t0, t0, t1
	li	t1, MIPS_KSEG1_START
	la	v0, 1f				# Run cached
	j	v0
	nop
1:
	addu	t0, t0, 4
	bne	t0, t1, 1b
	sb	zero, -4(t0)

	la	v0, 1f
	or	v0, MIPS_KSEG1_START
	j	v0				# Run uncached
	nop
/*
 * Flush the data cache.
 */
1:
	li	v0, MIPS_SR_ISOL_CACHES
	mtc0	v0, MIPS_COP_0_STATUS_REG	# Isolate and swap back caches
	li	t0, MIPS_KSEG1_START
	subu	t0, t0, t2
	la	v0, 1f
	j	v0				# Back to cached mode
	nop
1:
	addu	t0, t0, 4
	bne	t0, t1, 1b
	sb	zero, -4(t0)

	nop					# Insure isolated stores
	nop					#   out of pipe.
	nop
	nop
	mtc0	t3, MIPS_COP_0_STATUS_REG	# Restore status reg.
	nop					# Insure cache unisolated.
	nop
	nop
	nop
	j	ra
	nop
END(mips1_FlushCache)

/*----------------------------------------------------------------------------
 *
 * mips1_FlushICache --
 *
 *	void mips1_FlushICache(addr, len)
 *		vm_offset_t addr, len;
 *
 *	Flush instruction cache for range of addr to addr + len - 1.
 *	The address can be any valid address so long as no TLB misses occur.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The contents of the cache is flushed.
 *
 *----------------------------------------------------------------------------
 */
LEAF(mips1_FlushICache)
	mfc0	t0, MIPS_COP_0_STATUS_REG	# Save SR
	mtc0	zero, MIPS_COP_0_STATUS_REG	# Disable interrupts.

	la	v1, 1f
	or	v1, MIPS_KSEG1_START	# Run uncached.
	j	v1
	nop
1:
	bc0f	1b				# make sure stores are complete
	li	v1, MIPS_SR_ISOL_CACHES | MIPS_SR_SWAP_CACHES
	mtc0	v1, MIPS_COP_0_STATUS_REG
	nop
	addu	a1, a1, a0			# compute ending address
1:
	addu	a0, a0, 4
	bne	a0, a1, 1b
	sb	zero, -4(a0)

	mtc0	t0, MIPS_COP_0_STATUS_REG	# enable interrupts
	j	ra				# return and run cached
	nop
END(mips1_FlushICache)

/*----------------------------------------------------------------------------
 *
 * mips1_FlushDCache --
 *
 *	void mips1_FlushDCache(addr, len)
 *		vm_offset_t addr, len;
 *
 *	Flush data cache for range of addr to addr + len - 1.
 *	The address can be any valid address so long as no TLB misses occur.
 *	(Be sure to use cached K0SEG kernel addresses)
 * Results:
 *	None.
 *
 * Side effects:
 *	The contents of the cache is flushed.
 *
 *----------------------------------------------------------------------------
 */
LEAF(mips1_FlushDCache)
	mfc0	t0, MIPS_COP_0_STATUS_REG	# Save SR
	mtc0	zero, MIPS_COP_0_STATUS_REG	# Disable interrupts.
	nop
1:
	bc0f	1b				# make sure stores are complete
# BUG: should drain write buffer.
# The insn above does not work on some all DEC machines, or all variants
# of the mips architecture.
	li	v1, MIPS_SR_ISOL_CACHES
	mtc0	v1, MIPS_COP_0_STATUS_REG
	nop
	addu	t1, a1, a0			# compute ending address
1:
	sb	zero, 0(a0)
	sb	zero, 4(a0)
	sb	zero, 8(a0)
	sb	zero, 12(a0)
	sb	zero, 16(a0)
	sb	zero, 20(a0)
	sb	zero, 24(a0)
	addu	a0, 32
	bltu	a0, t1, 1b
	sb	zero, -4(a0)

	nop					# drain pipeline
	nop
	mtc0	t0, MIPS_COP_0_STATUS_REG	# enable interrupts
	nop
	j	ra				# return and run cached
	nop
END(mips1_FlushDCache)

/*----------------------------------------------------------------------------
 *
 *		XXX  END of r3000-specific code  XXX 
 *
 *----------------------------------------------------------------------------
 */

@


1.5
log
@
Back out PEFO's trap change.  It breaks everybody, it seems.
@
text
@@


1.5.8.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@@


1.4
log
@Real trapframe and no more __FORK_BRAINDAMAGE
@
text
@d186 1
a186 1
 * The kernel exception stack contains 32 saved general registers,
d190 1
a190 1
#define KERN_REG_SIZE		(NUMSAVEREGS * 4)
d192 4
a195 1
#define	KERN_TRAP_FRAME_SIZE	(STAND_FRAME_SIZE + KERN_REG_SIZE + 12)
d197 1
a197 1
NNON_LEAF(mips1_KernGenException, KERN_TRAP_FRAME_SIZE, ra)
d213 2
a214 2
	subu	sp, sp, KERN_TRAP_FRAME_SIZE
	.mask	0x80000000, (STAND_RA_OFFSET - KERN_TRAP_FRAME_SIZE)
d220 4
a223 4
	sw	AT, KERN_REG_OFFSET + (AST * 4)(sp)
	sw	v0, KERN_REG_OFFSET + (V0 * 4)(sp)
	sw	v1, KERN_REG_OFFSET + (V1 * 4)(sp)
	sw	a0, KERN_REG_OFFSET + (A0 * 4)(sp)
d226 4
a229 4
	sw	a1, KERN_REG_OFFSET + (A1 * 4)(sp)
	sw	a2, KERN_REG_OFFSET + (A2 * 4)(sp)
	sw	a3, KERN_REG_OFFSET + (A3 * 4)(sp)
	sw	t0, KERN_REG_OFFSET + (T0 * 4)(sp)
d231 4
a234 4
	sw	t1, KERN_REG_OFFSET + (T1 * 4)(sp)
	sw	t2, KERN_REG_OFFSET + (T2 * 4)(sp)
	sw	t3, KERN_REG_OFFSET + (T3 * 4)(sp)
	sw	t4, KERN_REG_OFFSET + (T4 * 4)(sp)
d236 4
a239 4
	sw	t5, KERN_REG_OFFSET + (T5 * 4)(sp)
	sw	t6, KERN_REG_OFFSET + (T6 * 4)(sp)
	sw	t7, KERN_REG_OFFSET + (T7 * 4)(sp)
	sw	t8, KERN_REG_OFFSET + (T8 * 4)(sp)
d241 4
a244 4
	sw	t9, KERN_REG_OFFSET + (T9 * 4)(sp)
	sw	ra, KERN_REG_OFFSET + (RA * 4)(sp)
	sw	v0, KERN_REG_OFFSET + (MULLO * 4)(sp)
	sw	v1, KERN_REG_OFFSET + (MULHI * 4)(sp)
d246 1
a246 4
	sw	a0, KERN_REG_OFFSET + (SR * 4)(sp)
	sw	a1, KERN_REG_OFFSET + (CAUSE * 4)(sp)
	sw	a2, KERN_REG_OFFSET + (BADVADDR * 4)(sp)
	sw	a3, KERN_REG_OFFSET + (PC * 4)(sp)
a249 1
	addu	a0, sp, KERN_REG_OFFSET
d256 3
a258 3
	lw	a0, KERN_REG_OFFSET + (SR * 4)(sp)
	lw	t0, KERN_REG_OFFSET + (MULLO * 4)(sp)
	lw	t1, KERN_REG_OFFSET + (MULHI * 4)(sp)
d263 3
a265 2
	lw	AT, KERN_REG_OFFSET + (AST * 4)(sp)
	lw	v0, KERN_REG_OFFSET + (V0 * 4)(sp)
d269 1
a269 1
	addu	sp, sp, KERN_TRAP_FRAME_SIZE
d299 1
d304 1
d309 1
d314 1
d319 1
d324 1
a328 6
	mflo	v0
	mfhi	v1
	mfc0	a0, MIPS_COP_0_STATUS_REG	# First arg is the status reg.
	mfc0	a1, MIPS_COP_0_CAUSE_REG	# Second arg is the cause reg.
	mfc0	a2, MIPS_COP_0_BAD_VADDR	# Third arg is the fault addr
	mfc0	a3, MIPS_COP_0_EXC_PC		# Fourth arg is the pc.
a333 3
	sw	a1, UADDR+U_PCB_REGS+(CAUSE * 4)
	sw	a2, UADDR+U_PCB_REGS+(BADVADDR * 4)
	sw	a3, UADDR+U_PCB_REGS+(PC * 4)
d337 1
a344 1
	li	a0, UADDR+U_PCB_REGS
d383 6
d390 1
a390 1
NNON_LEAF(mips1_KernIntr, KERN_TRAP_FRAME_SIZE, ra)
d392 2
a393 2
	subu	sp, sp, KERN_TRAP_FRAME_SIZE	# allocate stack frame
	.mask	0x80000000, (STAND_RA_OFFSET - KERN_TRAP_FRAME_SIZE)
d399 4
a402 4
	sw	AT, KERN_REG_OFFSET + (AST * 4)(sp)
	sw	v0, KERN_REG_OFFSET + (V0 * 4)(sp)
	sw	v1, KERN_REG_OFFSET + (V1 * 4)(sp)
	sw	a0, KERN_REG_OFFSET + (A0 * 4)(sp)
d405 24
a428 22
	sw	a1, KERN_REG_OFFSET + (A1 * 4)(sp)
	sw	a2, KERN_REG_OFFSET + (A2 * 4)(sp)
	sw	a3, KERN_REG_OFFSET + (A3 * 4)(sp)
	sw	t0, KERN_REG_OFFSET + (T0 * 4)(sp)
	mfc0	a0, MIPS_COP_0_STATUS_REG
	sw	t1, KERN_REG_OFFSET + (T1 * 4)(sp)
	sw	t2, KERN_REG_OFFSET + (T2 * 4)(sp)
	sw	t3, KERN_REG_OFFSET + (T3 * 4)(sp)
	sw	t4, KERN_REG_OFFSET + (T4 * 4)(sp)
	mfc0	a1, MIPS_COP_0_CAUSE_REG
	sw	t5, KERN_REG_OFFSET + (T5 * 4)(sp)
	sw	t6, KERN_REG_OFFSET + (T6 * 4)(sp)
	sw	t7, KERN_REG_OFFSET + (T7 * 4)(sp)
	sw	t8, KERN_REG_OFFSET + (T8 * 4)(sp)
	sw	t9, KERN_REG_OFFSET + (T9 * 4)(sp)
	sw	ra, KERN_REG_OFFSET + (RA * 4)(sp)
	sw	v0, KERN_REG_OFFSET + (MULLO * 4)(sp)
	sw	v1, KERN_REG_OFFSET + (MULHI * 4)(sp)
	mfc0	a2, MIPS_COP_0_EXC_PC
	sw	a0, KERN_REG_OFFSET + (SR * 4)(sp)
	sw	a1, KERN_REG_OFFSET + (CAUSE * 4)(sp)
	sw	a2, KERN_REG_OFFSET + (PC * 4)(sp)
a431 1
	addu	a0, sp, KERN_REG_OFFSET
d433 1
a433 1
	sw	a2,  STAND_RA_OFFSET(sp)
d437 3
a439 3
	lw	a0, KERN_REG_OFFSET + (SR * 4)(sp)
	lw	t0, KERN_REG_OFFSET + (MULLO * 4)(sp)
	lw	t1, KERN_REG_OFFSET + (MULHI * 4)(sp)
d443 3
a445 3
	lw	k0, KERN_REG_OFFSET + (PC * 4)(sp)
	lw	AT, KERN_REG_OFFSET + (AST * 4)(sp)
	lw	v0, KERN_REG_OFFSET + (V0 * 4)(sp)
d447 1
a447 1
	RESTORE_KERN_REGISTERS(KERN_REG_OFFSET)
d449 1
a449 1
	addu	sp, sp, KERN_TRAP_FRAME_SIZE
a510 1
	sw	a1, UADDR+U_PCB_REGS+(CAUSE * 4)
a521 1
	li	a0, UADDR+U_PCB_REGS
d523 1
a523 1
	sw	a2, STAND_RA_OFFSET(sp)		# debugging
@


1.3
log
@new cpureg.h from NetBSD plus modifications to use the changed macro names
@
text
@d186 1
a186 1
 * The kernel exception stack contains 18 saved general registers,
d190 1
a190 1
#define KERN_REG_SIZE		(18 * 4)
d192 1
a192 4
#define KERN_SR_OFFSET		(STAND_FRAME_SIZE + KERN_REG_SIZE)
#define KERN_MULT_LO_OFFSET	(STAND_FRAME_SIZE + KERN_REG_SIZE + 4)
#define KERN_MULT_HI_OFFSET	(STAND_FRAME_SIZE + KERN_REG_SIZE + 8)
#define	KERN_EXC_FRAME_SIZE	(STAND_FRAME_SIZE + KERN_REG_SIZE + 12)
d194 1
a194 1
NNON_LEAF(mips1_KernGenException, KERN_EXC_FRAME_SIZE, ra)
d210 2
a211 2
	subu	sp, sp, KERN_EXC_FRAME_SIZE
	.mask	0x80000000, (STAND_RA_OFFSET - KERN_EXC_FRAME_SIZE)
d217 4
a220 4
	sw	AT, KERN_REG_OFFSET + 0(sp)
	sw	v0, KERN_REG_OFFSET + 4(sp)
	sw	v1, KERN_REG_OFFSET + 8(sp)
	sw	a0, KERN_REG_OFFSET + 12(sp)
d223 4
a226 4
	sw	a1, KERN_REG_OFFSET + 16(sp)
	sw	a2, KERN_REG_OFFSET + 20(sp)
	sw	a3, KERN_REG_OFFSET + 24(sp)
	sw	t0, KERN_REG_OFFSET + 28(sp)
d228 4
a231 4
	sw	t1, KERN_REG_OFFSET + 32(sp)
	sw	t2, KERN_REG_OFFSET + 36(sp)
	sw	t3, KERN_REG_OFFSET + 40(sp)
	sw	t4, KERN_REG_OFFSET + 44(sp)
d233 4
a236 4
	sw	t5, KERN_REG_OFFSET + 48(sp)
	sw	t6, KERN_REG_OFFSET + 52(sp)
	sw	t7, KERN_REG_OFFSET + 56(sp)
	sw	t8, KERN_REG_OFFSET + 60(sp)
d238 4
a241 4
	sw	t9, KERN_REG_OFFSET + 64(sp)
	sw	ra, KERN_REG_OFFSET + 68(sp)
	sw	v0, KERN_MULT_LO_OFFSET(sp)
	sw	v1, KERN_MULT_HI_OFFSET(sp)
d243 4
a246 1
	sw	a0, KERN_SR_OFFSET(sp)
d250 1
d257 3
a259 3
	lw	a0, KERN_SR_OFFSET(sp)
	lw	t0, KERN_MULT_LO_OFFSET(sp)
	lw	t1, KERN_MULT_HI_OFFSET(sp)
d264 2
a265 3

	lw	AT, KERN_REG_OFFSET + 0(sp)
	lw	v0, KERN_REG_OFFSET + 4(sp)
d269 1
a269 1
	addu	sp, sp, KERN_EXC_FRAME_SIZE
a298 1
	mflo	v0
a302 1
	mfhi	v1
a306 1
	mfc0	a0, MIPS_COP_0_STATUS_REG	# First arg is the status reg.
a310 1
	mfc0	a1, MIPS_COP_0_CAUSE_REG	# Second arg is the cause reg.
a314 1
	mfc0	a2, MIPS_COP_0_BAD_VADDR	# Third arg is the fault addr
a318 1
	mfc0	a3, MIPS_COP_0_EXC_PC		# Fourth arg is the pc.
d323 6
d334 3
a339 1
	sw	a3, UADDR+U_PCB_REGS+(PC * 4)
d347 1
a385 6
#define KINTR_REG_OFFSET	(STAND_FRAME_SIZE)
#define KINTR_SR_OFFSET		(STAND_FRAME_SIZE + KERN_REG_SIZE)
#define KINTR_MULT_LO_OFFSET	(STAND_FRAME_SIZE + KERN_REG_SIZE + 4)
#define KINTR_MULT_HI_OFFSET	(STAND_FRAME_SIZE + KERN_REG_SIZE + 8)
#define KINTR_GP_OFFSET		(STAND_FRAME_SIZE + KERN_REG_SIZE + 12)
#define	KINTR_FRAME_SIZE	(STAND_FRAME_SIZE + KERN_REG_SIZE + 16)
d387 1
a387 1
NNON_LEAF(mips1_KernIntr, KINTR_FRAME_SIZE, ra)
d389 2
a390 2
	subu	sp, sp, KINTR_FRAME_SIZE	# allocate stack frame
	.mask	0x80000000, (STAND_RA_OFFSET - KINTR_FRAME_SIZE)
d396 4
a399 4
	sw	AT, KINTR_REG_OFFSET + 0(sp)
	sw	v0, KINTR_REG_OFFSET + 4(sp)
	sw	v1, KINTR_REG_OFFSET + 8(sp)
	sw	a0, KINTR_REG_OFFSET + 12(sp)
d402 22
a423 24
	sw	a1, KINTR_REG_OFFSET + 16(sp)
	sw	a2, KINTR_REG_OFFSET + 20(sp)
	sw	a3, KINTR_REG_OFFSET + 24(sp)
	sw	t0, KINTR_REG_OFFSET + 28(sp)
	mfc0	a0, MIPS_COP_0_STATUS_REG	# First arg is the status reg.
	sw	t1, KINTR_REG_OFFSET + 32(sp)
	sw	t2, KINTR_REG_OFFSET + 36(sp)
	sw	t3, KINTR_REG_OFFSET + 40(sp)
	sw	t4, KINTR_REG_OFFSET + 44(sp)
	mfc0	a1, MIPS_COP_0_CAUSE_REG	# Second arg is the cause reg.
	sw	t5, KINTR_REG_OFFSET + 48(sp)
	sw	t6, KINTR_REG_OFFSET + 52(sp)
	sw	t7, KINTR_REG_OFFSET + 56(sp)
	sw	t8, KINTR_REG_OFFSET + 60(sp)
	mfc0	a2, MIPS_COP_0_EXC_PC		# Third arg is the pc.
	sw	t9, KINTR_REG_OFFSET + 64(sp)
	sw	ra, KINTR_REG_OFFSET + 68(sp)
	sw	v0, KINTR_MULT_LO_OFFSET(sp)
	sw	v1, KINTR_MULT_HI_OFFSET(sp)
	sw	a0, KINTR_SR_OFFSET(sp)
	sw	gp, KINTR_GP_OFFSET(sp)
#ifdef __GP_SUPPORT__
	la	gp, _C_LABEL(_gp)		# switch to kernel GP
#endif
d427 1
d429 1
a429 1
	sw	a2, STAND_RA_OFFSET(sp)		# for debugging
d433 3
a435 3
	lw	a0, KINTR_SR_OFFSET(sp)
	lw	t0, KINTR_MULT_LO_OFFSET(sp)
	lw	t1, KINTR_MULT_HI_OFFSET(sp)
d439 3
a441 3
	lw	k0, STAND_RA_OFFSET(sp)
	lw	AT, KINTR_REG_OFFSET + 0(sp)
	lw	v0, KINTR_REG_OFFSET + 4(sp)
d443 1
a443 1
	RESTORE_KERN_REGISTERS(KINTR_REG_OFFSET)
d445 1
a445 1
	addu	sp, sp, KINTR_FRAME_SIZE
d507 1
d519 1
d521 1
a521 1
	sw	a2, STAND_RA_OFFSET(sp)		# for debugging
@


1.2
log
@update the pmax stuff to NetBSD 961107 - this version i got somehow
compiled on my decstation 2100 (PLUTO) - but it will not fully work
out of the box - but i want to bring it into the tree because i get
my own pmax on 961228 - so that i have a good startpoint then :-)

all the OpenBSD changes to the pmax tree will follow in the next commit
@
text
@d71 1
a71 1
	mfc0	k0, MACH_COP_0_BAD_VADDR	# get the virtual address
d77 1
a77 1
	mfc0	k0, MACH_COP_0_BAD_VADDR	# get the virtual address
d86 2
a87 2
	mtc0	k0, MACH_COP_0_TLB_LOW
	mfc0	k1, MACH_COP_0_EXC_PC		# get return address
d92 1
a92 1
	mfc0	k1, MACH_COP_0_EXC_PC		# get return address
d124 3
a126 3
	mfc0	k0, MACH_COP_0_STATUS_REG	# Get the status register
	mfc0	k1, MACH_COP_0_CAUSE_REG	# Get the cause register value.
	and	k0, k0, MIPS_3K_SR_KU_PREV	# test for user mode
d128 1
a128 1
	and	k1, k1, MIPS_3K_CR_EXC_CODE	# Mask out the cause bits.
d160 1
a160 1
	mfc0	k0, MACH_COP_0_STATUS_REG
d162 1
a162 1
	and	k0, k0, MACH_SR_KU_PREV
d230 1
a230 1
	mfc0	a0, MACH_COP_0_STATUS_REG	# First arg is the status reg.
d235 1
a235 1
	mfc0	a1, MACH_COP_0_CAUSE_REG	# Second arg is the cause reg.
d240 1
a240 1
	mfc0	a2, MACH_COP_0_BAD_VADDR	# Third arg is the fault addr.
d245 1
a245 1
	mfc0	a3, MACH_COP_0_EXC_PC		# Fourth arg is the pc.
d259 1
a259 1
	mtc0	a0, MACH_COP_0_STATUS_REG	# Restore the SR, disable intrs
d309 1
a309 1
	mfc0	a0, MACH_COP_0_STATUS_REG	# First arg is the status reg.
d314 1
a314 1
	mfc0	a1, MACH_COP_0_CAUSE_REG	# Second arg is the cause reg.
d319 1
a319 1
	mfc0	a2, MACH_COP_0_BAD_VADDR	# Third arg is the fault addr
d324 1
a324 1
	mfc0	a3, MACH_COP_0_EXC_PC		# Fourth arg is the pc.
d340 1
a340 1
	and	t0, a0, ~MACH_SR_COP_1_BIT	# Turn off the FPU.
d346 1
a346 1
	mtc0	t0, MACH_COP_0_STATUS_REG
d353 1
a353 1
	mtc0	a0, MACH_COP_0_STATUS_REG	# this should disable interrupts
d409 1
a409 1
	mfc0	a0, MACH_COP_0_STATUS_REG	# First arg is the status reg.
d414 1
a414 1
	mfc0	a1, MACH_COP_0_CAUSE_REG	# Second arg is the cause reg.
d419 1
a419 1
	mfc0	a2, MACH_COP_0_EXC_PC		# Third arg is the pc.
d440 1
a440 1
	mtc0	a0, MACH_COP_0_STATUS_REG	# Restore the SR, disable intrs
d492 1
a492 1
	mfc0	a0, MACH_COP_0_STATUS_REG	# First arg is the status reg.
d497 1
a497 1
	mfc0	a1, MACH_COP_0_CAUSE_REG	# Second arg is the cause reg.
d502 1
a502 1
	mfc0	a2, MACH_COP_0_EXC_PC		# Third arg is the pc.
d516 1
a516 1
	and	t0, a0, ~MACH_SR_COP_1_BIT	# Turn off the FPU.
d518 1
a518 1
	mtc0	t0, MACH_COP_0_STATUS_REG
d529 1
a529 1
	mtc0	a0, MACH_COP_0_STATUS_REG	# Restore the SR, disable intrs
d572 1
a572 1
	li	t0, MACH_HARD_INT_MASK | MIPS_SR_INT_IE
d577 1
a577 1
	mtc0	t0, MACH_COP_0_STATUS_REG	# enable interrupts (spl0)
d584 1
a584 1
	mtc0	a0, MACH_COP_0_STATUS_REG	# this should disable interrupts
d636 3
a638 3
	mfc0	k0, MACH_COP_0_TLB_LOW		# get the physical address
	mfc0	k1, MACH_COP_0_TLB_INDEX	# check to be sure its valid
	or	k0, k0, VMMACH_TLB_MOD_BIT	# update TLB
d640 2
a641 2
	mtc0	k0, MACH_COP_0_TLB_LOW
	li	k1, MACH_CACHED_MEMORY_ADDR
d643 1
a643 1
	srl	k0, k0, VMMACH_TLB_PHYS_PAGE_SHIFT
d650 1
a650 1
	mfc0	k0, MACH_COP_0_EXC_PC		# get return address
d678 1
a678 1
	mfc0	k0, MACH_COP_0_BAD_VADDR	# get the fault address
d690 2
a691 2
	mfc0	k1, MACH_COP_0_EXC_PC		# get return address
	mtc0	k0, MACH_COP_0_TLB_LOW		# save PTE entry
d709 3
a711 3
	mfc0	a2, MACH_COP_0_STATUS_REG
	mfc0	a3, MACH_COP_0_CAUSE_REG
	mfc0	a1, MACH_COP_0_EXC_PC
d717 1
a717 1
	mfc0	a3, MACH_COP_0_BAD_VADDR
d749 8
a756 8
	mfc0	v1, MACH_COP_0_STATUS_REG	# Save the status register.
	mtc0	zero, MACH_COP_0_STATUS_REG	# Disable interrupts
	mfc0	t0, MACH_COP_0_TLB_HI		# Save the current PID.

	sll	a0, a0, VMMACH_TLB_INDEX_SHIFT
	mtc0	a0, MACH_COP_0_TLB_INDEX	# Set the index.
	mtc0	a1, MACH_COP_0_TLB_HI		# Set up entry high.
	mtc0	a2, MACH_COP_0_TLB_LOW		# Set up entry low.
d760 1
a760 1
	mtc0	t0, MACH_COP_0_TLB_HI		# Restore the PID.
d762 1
a762 1
	mtc0	v1, MACH_COP_0_STATUS_REG	# Restore the status register
d785 3
a787 3
	mfc0	v1, MACH_COP_0_STATUS_REG	# Save the status register.
	mtc0	zero, MACH_COP_0_STATUS_REG	# Disable interrupts
	mfc0	v0, MACH_COP_0_TLB_HI		# Save the current PID.
d790 2
a791 2
	mtc0	a0, MACH_COP_0_TLB_HI		# Set up entry high.
	mtc0	a1, MACH_COP_0_TLB_LOW		# Set up entry low.
d795 1
a795 1
	mtc0	v0, MACH_COP_0_TLB_HI		# Restore the PID.
d797 1
a797 1
	mtc0	v1, MACH_COP_0_STATUS_REG	# Restore the status register
d819 2
a820 2
	sll	a0, a0, VMMACH_TLB_PID_SHIFT	# put PID in right spot
	mtc0	a0, MACH_COP_0_TLB_HI		# Write the hi reg value
d842 6
a847 6
	mfc0	v1, MACH_COP_0_STATUS_REG	# Save the status register.
	mtc0	zero, MACH_COP_0_STATUS_REG	# Disable interrupts
	mfc0	t0, MACH_COP_0_TLB_HI		# Save the PID
	li	t1, MACH_CACHED_MEMORY_ADDR	# invalid address
	mtc0	t1, MACH_COP_0_TLB_HI		# Mark entry high as invalid
	mtc0	zero, MACH_COP_0_TLB_LOW	# Zero out low entry.
d851 2
a852 2
	li	t1, VMMACH_FIRST_RAND_ENTRY << VMMACH_TLB_INDEX_SHIFT
	li	t2, VMMACH_NUM_TLB_ENTRIES << VMMACH_TLB_INDEX_SHIFT
d854 2
a855 2
	mtc0	t1, MACH_COP_0_TLB_INDEX	# Set the index register.
	addu	t1, t1, 1 << VMMACH_TLB_INDEX_SHIFT	# Increment index.
d859 1
a859 1
	mtc0	t0, MACH_COP_0_TLB_HI		# Restore the PID
d861 1
a861 1
	mtc0	v1, MACH_COP_0_STATUS_REG	# Restore the status register
d883 4
a886 4
	mfc0	v1, MACH_COP_0_STATUS_REG	# Save the status register.
	mtc0	zero, MACH_COP_0_STATUS_REG	# Disable interrupts
	mfc0	t0, MACH_COP_0_TLB_HI		# Save the current PID
	sll	a0, a0, VMMACH_TLB_PID_SHIFT	# Align the pid to flush.
d890 3
a892 3
	li	t1, VMMACH_FIRST_RAND_ENTRY << VMMACH_TLB_INDEX_SHIFT
	li	t2, VMMACH_NUM_TLB_ENTRIES << VMMACH_TLB_INDEX_SHIFT
	mtc0	t1, MACH_COP_0_TLB_INDEX	# Set the index register
d894 1
a894 1
	addu	t1, t1, 1 << VMMACH_TLB_INDEX_SHIFT	# Increment index.
d896 1
a896 1
	mfc0	t4, MACH_COP_0_TLB_HI		# Fetch the hi register.
d898 1
a898 1
	and	t4, t4, VMMACH_TLB_PID		# compare PIDs
d900 3
a902 3
	li	v0, MACH_CACHED_MEMORY_ADDR	# invalid address
	mtc0	v0, MACH_COP_0_TLB_HI		# Mark entry high as invalid
	mtc0	zero, MACH_COP_0_TLB_LOW	# Zero out low entry.
d907 1
a907 1
	mtc0	t1, MACH_COP_0_TLB_INDEX	# Set the index register
d909 1
a909 1
	mtc0	t0, MACH_COP_0_TLB_HI		# restore PID
d911 1
a911 1
	mtc0	v1, MACH_COP_0_STATUS_REG	# Restore the status register
d933 3
a935 3
	mfc0	v1, MACH_COP_0_STATUS_REG	# Save the status register.
	mtc0	zero, MACH_COP_0_STATUS_REG	# Disable interrupts
	mfc0	t0, MACH_COP_0_TLB_HI		# Get current PID
d938 1
a938 1
	mtc0	a0, MACH_COP_0_TLB_HI		# look for addr & PID
d941 2
a942 2
	mfc0	v0, MACH_COP_0_TLB_INDEX	# See what we got
	li	t1, MACH_CACHED_MEMORY_ADDR	# Load invalid entry.
d944 2
a945 2
	mtc0	t1, MACH_COP_0_TLB_HI		# Mark entry high as invalid
	mtc0	zero, MACH_COP_0_TLB_LOW	# Zero out low entry.
d949 1
a949 1
	mtc0	t0, MACH_COP_0_TLB_HI		# restore PID
d951 1
a951 1
	mtc0	v1, MACH_COP_0_STATUS_REG	# Restore the status register
d972 3
a974 3
	mfc0	v1, MACH_COP_0_STATUS_REG	# Save the status register.
	mtc0	zero, MACH_COP_0_STATUS_REG	# Disable interrupts
	mfc0	t0, MACH_COP_0_TLB_HI		# Save current PID
d976 1
a976 1
	mtc0	a0, MACH_COP_0_TLB_HI		# init high reg.
d979 2
a980 2
	mfc0	v0, MACH_COP_0_TLB_INDEX	# See what we got
	mtc0	a1, MACH_COP_0_TLB_LOW		# init low reg.
d982 1
a982 1
	sra	v0, v0, VMMACH_TLB_INDEX_SHIFT	# convert index to regular num
d986 1
a986 1
	mtc0	a0, MACH_COP_0_TLB_HI		# init high reg.
d990 1
a990 1
	mtc0	t0, MACH_COP_0_TLB_HI		# restore PID
d992 1
a992 1
	mtc0	v1, MACH_COP_0_STATUS_REG	# Restore the status register
d1016 3
a1018 3
	mfc0	v1, MACH_COP_0_STATUS_REG	# Save the status register.
	mtc0	zero, MACH_COP_0_STATUS_REG	# Disable interrupts
	mfc0	t0, MACH_COP_0_TLB_HI		# Get current PID
d1020 1
a1020 1
	mtc0	a0, MACH_COP_0_TLB_HI		# Set up entry high.
d1023 1
a1023 1
	mfc0	v0, MACH_COP_0_TLB_INDEX	# See what we got
d1028 2
a1029 2
	mfc0	t1, MACH_COP_0_TLB_HI		# See what we got
	mfc0	t2, MACH_COP_0_TLB_LOW		# See what we got
d1032 1
a1032 1
	srl	v0, v0, VMMACH_TLB_INDEX_SHIFT	# convert index to regular num
d1034 1
a1034 1
	mtc0	t0, MACH_COP_0_TLB_HI		# Restore current PID
d1036 1
a1036 1
	mtc0	v1, MACH_COP_0_STATUS_REG	# Restore the status register
d1057 3
a1059 3
	mfc0	v1, MACH_COP_0_STATUS_REG	# Save the status register.
	mtc0	zero, MACH_COP_0_STATUS_REG	# Disable interrupts
	mfc0	t0, MACH_COP_0_TLB_HI		# Get current PID
d1061 2
a1062 2
	sll	a0, a0, VMMACH_TLB_INDEX_SHIFT
	mtc0	a0, MACH_COP_0_TLB_INDEX	# Set the index register
d1065 2
a1066 2
	mfc0	t3, MACH_COP_0_TLB_HI		# fetch the hi entry
	mfc0	t4, MACH_COP_0_TLB_LOW		# fetch the low entry
d1070 1
a1070 1
	mtc0	t0, MACH_COP_0_TLB_HI		# restore PID
d1072 1
a1072 1
	mtc0	v1, MACH_COP_0_STATUS_REG	# Restore the status register
d1090 1
a1090 1
	mfc0	v0, MACH_COP_0_TLB_HI		# get PID
d1092 1
a1092 1
	and	v0, v0, VMMACH_TLB_PID		# mask off PID
d1094 1
a1094 1
	srl	v0, v0, VMMACH_TLB_PID_SHIFT	# put PID in right spot
d1126 1
a1126 1
	mtc0	zero, MACH_COP_0_STATUS_REG	# Disable interrupts.
d1128 1
a1128 1
	or	v0, MACH_UNCACHED_MEMORY_ADDR	# Run uncached.
d1144 2
a1145 2
	li	v0, MACH_SR_SWAP_CACHES		# Swap caches
	mtc0	v0, MACH_COP_0_STATUS_REG
d1152 1
a1152 1
	mtc0	zero, MACH_COP_0_STATUS_REG	# Swap back caches and enable.
d1183 1
a1183 1
	mfc0	t0, MACH_COP_0_STATUS_REG	# Save the current status reg.
d1185 1
a1185 1
	or	v0, t0, MACH_SR_ISOL_CACHES	# Isolate the caches.
d1187 1
a1187 1
	mtc0	v0, MACH_COP_0_STATUS_REG
d1194 3
a1196 3
	li	v0, MACH_MIN_CACHE_SIZE
	li	v1, MACH_CACHED_MEMORY_ADDR
	li	t2, MACH_MAX_CACHE_SIZE
d1205 1
a1205 1
	li	v0, MACH_MIN_CACHE_SIZE
d1217 1
a1217 1
	mtc0	t0, MACH_COP_0_STATUS_REG
d1243 2
a1244 2
	mfc0	t3, MACH_COP_0_STATUS_REG 	# Save the status register.
	mtc0	zero, MACH_COP_0_STATUS_REG	# Disable interrupts.
d1246 1
a1246 1
	or	v0, MACH_UNCACHED_MEMORY_ADDR	# Run uncached.
d1253 3
a1255 3
	li	v0, MACH_SR_ISOL_CACHES | MACH_SR_SWAP_CACHES
	mtc0	v0, MACH_COP_0_STATUS_REG	# Isolate and swap caches.
	li	t0, MACH_UNCACHED_MEMORY_ADDR
d1257 1
a1257 1
	li	t1, MACH_UNCACHED_MEMORY_ADDR
d1267 1
a1267 1
	or	v0, MACH_UNCACHED_MEMORY_ADDR
d1274 3
a1276 3
	li	v0, MACH_SR_ISOL_CACHES
	mtc0	v0, MACH_COP_0_STATUS_REG	# Isolate and swap back caches
	li	t0, MACH_UNCACHED_MEMORY_ADDR
d1290 1
a1290 1
	mtc0	t3, MACH_COP_0_STATUS_REG	# Restore status reg.
d1318 2
a1319 2
	mfc0	t0, MACH_COP_0_STATUS_REG	# Save SR
	mtc0	zero, MACH_COP_0_STATUS_REG	# Disable interrupts.
d1322 1
a1322 1
	or	v1, MACH_UNCACHED_MEMORY_ADDR	# Run uncached.
d1327 2
a1328 2
	li	v1, MACH_SR_ISOL_CACHES | MACH_SR_SWAP_CACHES
	mtc0	v1, MACH_COP_0_STATUS_REG
d1336 1
a1336 1
	mtc0	t0, MACH_COP_0_STATUS_REG	# enable interrupts
d1360 2
a1361 2
	mfc0	t0, MACH_COP_0_STATUS_REG	# Save SR
	mtc0	zero, MACH_COP_0_STATUS_REG	# Disable interrupts.
d1368 2
a1369 2
	li	v1, MACH_SR_ISOL_CACHES
	mtc0	v1, MACH_COP_0_STATUS_REG
d1386 1
a1386 1
	mtc0	t0, MACH_COP_0_STATUS_REG	# enable interrupts
@


1.1
log
@merge mips back into pmax; by graichen
@
text
@d1 54
d59 1
a59 2
 * mips_r2000_UTLBmiss --
 * MachUTLBmiss --
d68 2
a69 4
	.globl	_C_LABEL(mips_R2000_UTLBMiss)
_C_LABEL(mips_R2000_UTLBMiss):
	.globl	_C_LABEL(MachUTLBMiss)
_C_LABEL(MachUTLBMiss):
d97 1
a97 1
	j	mips_r2000_SlowFault			# handle the rest
d100 2
a101 5
	.globl	_C_LABEL(MachUTLBMissEnd)
_C_LABEL(MachUTLBMissEnd):

	.globl	_C_LABEL(mips_R2000_UTLBMissEnd)
_C_LABEL(mips_R2000_UTLBMissEnd):
d107 1
a107 1
 * mips_R2000_execption --
d118 2
a119 2
	.globl	_C_LABEL(mips_R2000_exception)
_C_LABEL(mips_R2000_exception):
d131 1
a131 1
	la	k0, _C_LABEL(mips_r2000_ExceptionTable) # get base of the jump table
d142 2
a143 2
	.globl	_C_LABEL(mips_R2000_exceptionEnd)
_C_LABEL(mips_R2000_exceptionEnd):
d150 1
a150 1
 * mips_r2000_SlowFault --
d152 2
a153 2
 * Alternate entry point into the mips_r2000_UserGenExceptionor or
 * or mips_r2000_user_Kern_exception, when the ULTB miss handler couldn't
d158 1
a158 1
mips_r2000_SlowFault:
d163 1
a163 1
	bne	k0, zero, _C_LABEL(mips_r2000_UserGenException)
d172 1
a172 1
 * mips_r2000_KernGenException --
d197 1
a197 1
NNON_LEAF(mips_r2000_KernGenException, KERN_EXC_FRAME_SIZE, ra)
d273 1
a273 1
END(mips_r2000_KernGenException)
d277 1
a277 1
 * mips_r2000_UserGenException --
d289 1
a289 1
NNON_LEAF(mips_r2000_UserGenException, STAND_FRAME_SIZE, ra)
d360 1
a360 1
	RESTORE_USER_REGS()
d365 1
a365 1
END(mips_r2000_UserGenException)
d369 1
a369 1
 * mips_r2000_KernIntr --
d390 1
a390 1
NNON_LEAF(mips_r2000_KernIntr, KINTR_FRAME_SIZE, ra)
d453 1
a453 1
END(mips_r2000_KernIntr)
d457 1
a457 1
 * mips_r2000_UserIntr --
d474 1
a474 1
NNON_LEAF(mips_r2000_UserIntr, STAND_FRAME_SIZE, ra)
d591 1
a591 1
	RESTORE_USER_REGS()
d596 6
a601 1
END(mips_r2000_UserIntr)
d603 2
d619 1
a619 1
 * mips_r2000_TLBModException --
d633 1
a633 1
NLEAF(mips_r2000_TLBModException)
d657 1
a657 1
END(mips_r2000_TLBModException)
d662 1
a662 1
 * mips_r2000_TLBMissException --
d676 1
a676 1
NLEAF(mips_r2000_TLBMissException)
d693 1
a693 1
	beq	k0, zero, _C_LABEL(mips_r2000_KernGenException) # PTE invalid
d702 1
a702 1
	bne	k0, zero, _C_LABEL(mips_r2000_KernGenException) # Go panic
d726 1
a726 1
END(mips_r2000_TLBMissException)
d731 1
a731 1
 * mips_r2000_TLBWriteIndexed --
d735 1
a735 1
 *	mips_r2000_TLBWriteIndexed(index, highEntry, lowEntry)
d748 1
a748 1
LEAF(mips_r2000_TLBWriteIndexed)
d763 1
a763 1
END(mips_r2000_TLBWriteIndexed)
d768 1
a768 1
 * mips_r2000_TLBWriteRandom --
d772 1
a772 1
 *	mips_r2000_TLBWriteRandom(highEntry, lowEntry)
d784 1
a784 1
LEAF(mips_r2000_TLBWriteRandom)
d798 1
a798 1
END(mips_r2000_TLBWriteRandom)
d803 1
a803 1
 * mips_r2000_SetPID --
d807 1
a807 1
 *	mips_r2000_SetPID(pid)
d818 1
a818 1
LEAF(mips_r2000_SetPID)
d823 1
a823 1
END(mips_r2000_SetPID)
d827 1
a827 1
 * mips_r2000_TLBFlush --
d831 1
a831 1
 *	mips_r2000_TLBFlush()
d841 1
a841 1
LEAF(mips_r2000_TLBFlush)
d862 1
a862 1
END(mips_r2000_TLBFlush)
d867 1
a867 1
 * mips_r2000_TLBFlushPID --
d871 1
a871 1
 *	mips_r2000_TLBFlushPID(pid)
d882 1
a882 1
LEAF(mips_r2000_TLBFlushPID)
d912 1
a912 1
END(mips_r2000_TLBFlushPID)
d917 1
a917 1
 * mips_r2000_TLBFlushAddr --
d921 1
a921 1
 *	mips_r2000_TLBFlushAddr(highreg)
d932 1
a932 1
LEAF(mips_r2000_TLBFlushAddr)
d952 1
a952 1
END(mips_r2000_TLBFlushAddr)
d956 1
a956 1
 * mips_r2000_TLBUpdate --
d960 1
a960 1
 *	mips_r2000_TLBUpdate(highreg, lowreg)
d971 1
a971 1
LEAF(mips_r2000_TLBUpdate)
d993 1
a993 1
END(mips_r2000_TLBUpdate)
d997 1
a997 1
 * mips_r2000_TLBFind --
d1001 1
a1001 1
 *	mips_r2000_TLBFind(hi)
d1015 1
a1015 1
LEAF(mips_r2000_TLBFind)
d1037 1
a1037 1
END(mips_r2000_TLBFind)
d1041 1
a1041 1
 * mips_r2000_TLBRead --
d1045 1
a1045 1
 *	mips_r2000_TLBRead(entry)
d1056 1
a1056 1
LEAF(mips_r2000_TLBRead)
d1073 1
a1073 1
END(mips_r2000_TLBRead)
d1077 1
a1077 1
 * mips_r2000_TLBGetPID --
d1079 1
a1079 1
 *	mips_r2000_TLBGetPID()
d1089 1
a1089 1
LEAF(mips_r2000_TLBGetPID)
d1095 1
a1095 1
END(mips_r2000_TLBGetPID)
d1108 1
a1108 1
 * mips_r2000_ConfigCache --
d1122 1
a1122 1
NON_LEAF(mips_r2000_ConfigCache, STAND_FRAME_SIZE, ra)
d1137 1
a1137 1
	jal	_C_LABEL(mips_r2000_SizeCache)	# Get the size of the d-cache.
d1150 1
a1150 1
	jal	_C_LABEL(mips_r2000_SizeCache)	# Get the size of the i-cache.
d1166 1
a1166 1
END(mips_r2000_ConfigCache)
d1170 1
a1170 1
 * mips_r2000_SizeCache --
d1182 1
a1182 1
LEAF(mips_r2000_SizeCache)
d1224 1
a1224 1
END(mips_r2000_SizeCache)
d1228 1
a1228 1
 * mips_r2000_FlushCache --
d1240 1
a1240 1
LEAF(mips_r2000_FlushCache)
d1297 1
a1297 1
END(mips_r2000_FlushCache)
d1301 1
a1301 1
 * mips_r2000_FlushICache --
d1303 1
a1303 1
 *	void mips_r2000_FlushICache(addr, len)
d1317 1
a1317 1
LEAF(mips_r2000_FlushICache)
d1339 1
a1339 1
END(mips_r2000_FlushICache)
d1343 1
a1343 1
 * mips_r2000_FlushDCache --
d1345 1
a1345 1
 *	void mips_r2000_FlushDCache(addr, len)
d1359 1
a1359 1
LEAF(mips_r2000_FlushDCache)
d1390 1
a1390 1
END(mips_r2000_FlushDCache)
@
