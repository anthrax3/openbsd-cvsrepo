head	1.25;
access;
symbols
	SMP_SYNC_A:1.25
	SMP_SYNC_B:1.25
	UBC_SYNC_A:1.25
	UBC_SYNC_B:1.25
	OPENBSD_2_9:1.23.0.2
	OPENBSD_2_9_BASE:1.23
	OPENBSD_2_8:1.21.0.2
	OPENBSD_2_8_BASE:1.21
	OPENBSD_2_7:1.20.0.6
	OPENBSD_2_7_BASE:1.20
	SMP:1.20.0.4
	SMP_BASE:1.20
	kame_19991208:1.20
	OPENBSD_2_6:1.20.0.2
	OPENBSD_2_6_BASE:1.20
	OPENBSD_2_5:1.18.0.2
	OPENBSD_2_5_BASE:1.18
	OPENBSD_2_4:1.17.0.2
	OPENBSD_2_4_BASE:1.17
	OPENBSD_2_3:1.12.0.2
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.25
date	2001.06.24.23.48.46;	author deraadt;	state dead;
branches;
next	1.24;

1.24
date	2001.05.05.20.56.49;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2001.04.03.20.25.35;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2000.11.10.18.15.41;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2000.06.08.09.46.27;	author art;	state Exp;
branches;
next	1.20;

1.20
date	99.05.24.23.09.06;	author jason;	state Exp;
branches
	1.20.4.1;
next	1.19;

1.19
date	99.05.22.10.01.09;	author maja;	state Exp;
branches;
next	1.18;

1.18
date	99.01.07.23.16.05;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	98.10.15.21.30.17;	author imp;	state Exp;
branches;
next	1.16;

1.16
date	98.09.30.12.38.44;	author pefo;	state Exp;
branches;
next	1.15;

1.15
date	98.09.15.10.53.55;	author pefo;	state Exp;
branches;
next	1.14;

1.14
date	98.05.18.00.28.31;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	98.05.09.21.29.58;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	98.03.05.21.18.19;	author maja;	state Exp;
branches;
next	1.11;

1.11
date	98.03.05.21.14.38;	author maja;	state Exp;
branches;
next	1.10;

1.10
date	97.07.23.06.58.25;	author denny;	state Exp;
branches;
next	1.9;

1.9
date	97.07.07.08.28.31;	author graichen;	state Exp;
branches;
next	1.8;

1.8
date	97.06.10.14.20.12;	author graichen;	state Exp;
branches;
next	1.7;

1.7
date	97.02.05.23.48.47;	author graichen;	state Exp;
branches;
next	1.6;

1.6
date	97.02.03.11.45.19;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.12.22.15.18.40;	author graichen;	state Exp;
branches;
next	1.4;

1.4
date	96.09.15.21.13.18;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.01.12.16.45.22;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.30.08.37.41;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.34;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.34;	author deraadt;	state Exp;
branches;
next	;

1.20.4.1
date	2001.04.18.16.12.50;	author niklas;	state Exp;
branches;
next	1.20.4.2;

1.20.4.2
date	2001.07.04.10.21.54;	author niklas;	state dead;
branches;
next	;


desc
@@


1.25
log
@bye bye, with prejudice
@
text
@/*	$OpenBSD: trap.c,v 1.24 2001/05/05 20:56:49 art Exp $	*/
/*	$NetBSD: trap.c,v 1.50 1996/10/13 21:37:49 jonathan Exp $	*/

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department and Ralph Campbell.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah Hdr: trap.c 1.32 91/04/06
 *
 *	@@(#)trap.c	8.5 (Berkeley) 1/11/94
 */

#if !defined(MIPS1) && !defined(MIPS3)
#error  Neither  "MIPS1" (r2000 family), "MIP3" (r4000 family) was configured.
#endif

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/proc.h>
#include <sys/kernel.h>
#include <sys/signalvar.h>
#include <sys/syscall.h>
#include <sys/user.h>
#include <sys/buf.h>
#ifdef KTRACE
#include <sys/ktrace.h>
#endif
#include <net/netisr.h>

#include <machine/locore.h>

#include <machine/trap.h>
#include <machine/psl.h>
#include <machine/reg.h>
#include <machine/cpu.h>
#include <machine/locore.h>
#include <machine/pte.h>
#include <machine/mips_opcode.h>

#include <vm/vm.h>
#include <vm/vm_kern.h>
#include <vm/vm_page.h>

#include <sys/cdefs.h>
#include <sys/syslog.h>
#include <miscfs/procfs/procfs.h>

#include "ppp.h"
#include "bridge.h"

struct	proc *machFPCurProcPtr;		/* pointer to last proc to use FP */

/*
 * Port-specific hardware interrupt handler
 */

int (*mips_hardware_intr) __P((u_int mask, u_int pc, u_int status,
			       u_int cause)) =
	( int (*) __P((u_int, u_int, u_int, u_int)) ) 0;

/*
 * Exception-handling functions, called via machExceptionTable from locore
 */
extern void MachTLBModException  __P((void));
extern void MachTLBMissException __P((void));

extern void mips1_KernGenException __P((void));
extern void mips1_UserGenException __P((void));
extern void mips1_KernIntr __P((void));
extern void mips1_UserIntr __P((void));
extern void mips1_TLBModException  __P((void));

extern void mips1_TLBMissException __P((void));
/* marks end of vector code */
extern void mips1_UTLBMiss	__P((void));
extern void mips1_exceptionentry_end __P((void));

extern void mips3_KernGenException __P((void));
extern void mips3_UserGenException __P((void));
extern void mips3_KernIntr __P((void));
extern void mips3_UserIntr __P((void));
extern void mips3_TLBModException  __P((void));
extern void mips3_TLBMissException __P((void));

/* marks end of vector code */
extern void mips3_TLBMiss	__P((void));
extern void mips3_exceptionentry_end __P((void));


void (*mips1_ExceptionTable[]) __P((void)) = {
/*
 * The kernel exception handlers.
 */
    mips1_KernIntr,			/* 0 external interrupt */
    mips1_KernGenException,		/* 1 TLB modification */
    mips1_TLBMissException,		/* 2 TLB miss (load or instr. fetch) */
    mips1_TLBMissException,		/* 3 TLB miss (store) */
    mips1_KernGenException,		/* 4 address error (load or I-fetch) */
    mips1_KernGenException,		/* 5 address error (store) */
    mips1_KernGenException,		/* 6 bus error (I-fetch) */
    mips1_KernGenException,		/* 7 bus error (load or store) */
    mips1_KernGenException,		/* 8 system call */
    mips1_KernGenException,		/* 9 breakpoint */
    mips1_KernGenException,		/* 10 reserved instruction */
    mips1_KernGenException,		/* 11 coprocessor unusable */
    mips1_KernGenException,		/* 12 arithmetic overflow */
    mips1_KernGenException,		/* 13 r4k trap excpt, r3k reserved */
    mips1_KernGenException,		/* 14 r4k virt coherence, r3k reserved */
    mips1_KernGenException,		/* 15 r4k FP exception, r3k reserved */
    mips1_KernGenException,		/* 16 reserved */
    mips1_KernGenException,		/* 17 reserved */
    mips1_KernGenException,		/* 18 reserved */
    mips1_KernGenException,		/* 19 reserved */
    mips1_KernGenException,		/* 20 reserved */
    mips1_KernGenException,		/* 21 reserved */
    mips1_KernGenException,		/* 22 reserved */
    mips1_KernGenException,		/* 23 watch exception */
    mips1_KernGenException,		/* 24 reserved */
    mips1_KernGenException,		/* 25 reserved */
    mips1_KernGenException,		/* 26 reserved */
    mips1_KernGenException,		/* 27 reserved */
    mips1_KernGenException,		/* 28 reserved */
    mips1_KernGenException,		/* 29 reserved */
    mips1_KernGenException,		/* 30 reserved */
    mips1_KernGenException,		/* 31 virt. coherence exception data */
/*
 * The user exception handlers.
 */
    mips1_UserIntr,		        /*  0 */
    mips1_UserGenException,	        /*  1 */
    mips1_UserGenException,	        /*  2 */
    mips1_UserGenException,	        /*  3 */
    mips1_UserGenException,	        /*  4 */
    mips1_UserGenException,	        /*  5 */
    mips1_UserGenException,	        /*  6 */
    mips1_UserGenException,	        /*  7 */
    mips1_UserGenException,	        /*  8 */
    mips1_UserGenException,	        /*  9 */
    mips1_UserGenException,	        /* 10 */
    mips1_UserGenException,	        /* 11 */
    mips1_UserGenException,	        /* 12 */
    mips1_UserGenException,	        /* 13 */
    mips1_UserGenException,	        /* 14 */
    mips1_UserGenException,	        /* 15 */
    mips1_UserGenException,		/* 16 */
    mips1_UserGenException,		/* 17 */
    mips1_UserGenException,		/* 18 */
    mips1_UserGenException,		/* 19 */
    mips1_UserGenException,		/* 20 */
    mips1_UserGenException,		/* 21 */
    mips1_UserGenException,		/* 22 */
    mips1_UserGenException,		/* 23 */
    mips1_UserGenException,		/* 24 */
    mips1_UserGenException,		/* 25 */
    mips1_UserGenException,		/* 26 */
    mips1_UserGenException,		/* 27 */
    mips1_UserGenException,		/* 28 */
    mips1_UserGenException,		/* 29 */
    mips1_UserGenException,		/* 20 */
    mips1_UserGenException,		/* 31 */
};

#ifdef MIPS3		/* r4000 family (mips-III cpu) */

void (*mips3_ExceptionTable[]) __P((void)) = {
/*
 * The kernel exception handlers.
 */
    mips3_KernIntr,			/* 0 external interrupt */
    mips3_KernGenException,		/* 1 TLB modification */
    mips3_TLBMissException,		/* 2 TLB miss (load or instr. fetch) */
    mips3_TLBMissException,		/* 3 TLB miss (store) */
    mips3_KernGenException,		/* 4 address error (load or I-fetch) */
    mips3_KernGenException,		/* 5 address error (store) */
    mips3_KernGenException,		/* 6 bus error (I-fetch) */
    mips3_KernGenException,		/* 7 bus error (load or store) */
    mips3_KernGenException,		/* 8 system call */
    mips3_KernGenException,		/* 9 breakpoint */
    mips3_KernGenException,		/* 10 reserved instruction */
    mips3_KernGenException,		/* 11 coprocessor unusable */
    mips3_KernGenException,		/* 12 arithmetic overflow */
    mips3_KernGenException,		/* 13 r4k trap excpt, r3k reserved */
    mips3_KernGenException,		/* 14 r4k virt coherence, r3k reserved */
    mips3_KernGenException,		/* 15 r4k FP exception, r3k reserved */
    mips3_KernGenException,		/* 16 reserved */
    mips3_KernGenException,		/* 17 reserved */
    mips3_KernGenException,		/* 18 reserved */
    mips3_KernGenException,		/* 19 reserved */
    mips3_KernGenException,		/* 20 reserved */
    mips3_KernGenException,		/* 21 reserved */
    mips3_KernGenException,		/* 22 reserved */
    mips3_KernGenException,		/* 23 watch exception */
    mips3_KernGenException,		/* 24 reserved */
    mips3_KernGenException,		/* 25 reserved */
    mips3_KernGenException,		/* 26 reserved */
    mips3_KernGenException,		/* 27 reserved */
    mips3_KernGenException,		/* 28 reserved */
    mips3_KernGenException,		/* 29 reserved */
    mips3_KernGenException,		/* 30 reserved */
    mips3_KernGenException,		/* 31 virt. coherence exception data */
/*
 * The user exception handlers.
 */
    mips3_UserIntr,		        /*  0 */
    mips3_UserGenException,	        /*  1 */
    mips3_UserGenException,	        /*  2 */
    mips3_UserGenException,	        /*  3 */
    mips3_UserGenException,	        /*  4 */
    mips3_UserGenException,	        /*  5 */
    mips3_UserGenException,	        /*  6 */
    mips3_UserGenException,	        /*  7 */
    mips3_UserGenException,	        /*  8 */
    mips3_UserGenException,	        /*  9 */
    mips3_UserGenException,	        /* 10 */
    mips3_UserGenException,	        /* 11 */
    mips3_UserGenException,	        /* 12 */
    mips3_UserGenException,	        /* 13 */
    mips3_UserGenException,	        /* 14 */
    mips3_UserGenException,	        /* 15 */
    mips3_UserGenException,		/* 16 */
    mips3_UserGenException,		/* 17 */
    mips3_UserGenException,		/* 18 */
    mips3_UserGenException,		/* 19 */
    mips3_UserGenException,		/* 20 */
    mips3_UserGenException,		/* 21 */
    mips3_UserGenException,		/* 22 */
    mips3_UserGenException,		/* 23 */
    mips3_UserGenException,		/* 24 */
    mips3_UserGenException,		/* 25 */
    mips3_UserGenException,		/* 26 */
    mips3_UserGenException,		/* 27 */
    mips3_UserGenException,		/* 28 */
    mips3_UserGenException,		/* 29 */
    mips3_UserGenException,		/* 20 */
    mips3_UserGenException,		/* 31 */
};
#endif	/* MIPS3 */


char	*trap_type[] = {
	"external interrupt",
	"TLB modification",
	"TLB miss (load or instr. fetch)",
	"TLB miss (store)",
	"address error (load or I-fetch)",
	"address error (store)",
	"bus error (I-fetch)",
	"bus error (load or store)",
	"system call",
	"breakpoint",
	"reserved instruction",
	"coprocessor unusable",
	"arithmetic overflow",
	"r4k trap/r3k reserved 13",
	"r4k virtual coherency instruction/r3k reserved 14",
	"r4k floating point/ r3k reserved 15",
	"reserved 16",
	"reserved 17",
	"reserved 18",
	"reserved 19",
	"reserved 20",
	"reserved 21",
	"reserved 22",
	"r4000 watch",
	"reserved 24",
	"reserved 25",
	"reserved 26",
	"reserved 27",
	"reserved 28",
	"reserved 29",
	"reserved 30",
	"r4000 virtual coherency data",
};

#ifdef DEBUG
#define TRAPSIZE	10
struct trapdebug {		/* trap history buffer for debugging */
	u_int	status;
	u_int	cause;
	u_int	vadr;
	u_int	pc;
	u_int	ra;
	u_int	sp;
	u_int	code;
} trapdebug[TRAPSIZE], *trp = trapdebug;

void trapDump __P((char * msg));
void cpu_getregs __P((int *regs));
#endif	/* DEBUG */

/*
 * Other forward declarations.
 */
u_int MachEmulateBranch __P((unsigned *regsPtr,
			     unsigned instPC,
			     unsigned fpcCSR,
			     int allowNonBranch));

/* extern functions used but not declared elsewhere */
extern void MachFPInterrupt __P((u_int status, u_int cause, u_int pc));
extern void clearsoftclock __P((void));
extern void clearsoftnet __P((void));
extern int splx __P((int));
extern int splhigh __P((void));
extern void MachSwitchFPState __P((struct proc *from, struct user *to));

/* only called by locore */
extern u_int trap __P((u_int status, u_int cause, u_int vaddr,  u_int pc,
			 int args));


#ifdef DEBUG /* stack trace code, also useful to DDB one day */
extern void stacktrace __P(()); /*XXX*/
extern void logstacktrace __P(()); /*XXX*/

/* extern functions printed by name in stack backtraces */
extern void idle __P((void)),  cpu_switch __P(( struct proc *p));
extern void MachEmptyWriteBuffer __P((void));
extern void MachUTLBMiss __P((void));
extern void setsoftclock __P((void));
extern int main __P((void*));
extern void am7990_meminit __P((void*)); /* XXX */
#endif	/* DEBUG */


extern volatile struct chiptime *Mach_clock_addr;
extern u_long kernelfaults;
u_long kernelfaults = 0;
extern u_long intrcnt[];

/*
 * Index into intrcnt[], which is defined in locore
 */
typedef enum {
	SOFTCLOCK_INTR =0,
	SOFTNET_INTR	=1,
	SERIAL0_INTR=2,
	SERIAL1_INTR = 3,
	SERIAL2_INTR = 4,
	LANCE_INTR =5,
	SCSI_INTR = 6,
	ERROR_INTR=7,
	HARDCLOCK = 8,
  	FPU_INTR   =9,
	SLOT0_INTR =10,
	SLOT1_INTR =11,
	SLOT2_INTR =12,
	DTOP_INTR = 13, /* XXX */
	ISDN_INTR = 14, /* XXX */
	FLOPPY_INTR = 15,
	STRAY_INTR = 16
} decstation_intr_t;


/*
 * Handle an exception.
 * Called from MachKernGenException() or MachUserGenException()
 * when a processor trap occurs.
 * In the case of a kernel trap, we return the pc where to resume if
 * ((struct pcb *)UADDR)->pcb_onfault is set, otherwise, return old pc.
 */
u_int
trap(statusReg, causeReg, vadr, pc, args)
	unsigned statusReg;	/* status register at time of the exception */
	unsigned causeReg;	/* cause register at time of exception */
	unsigned vadr;		/* address (if any) the fault occured on */
	unsigned pc;		/* program counter where to continue */
{
	register int type, i;
	unsigned ucode = 0;
	register struct proc *p = curproc;
	u_quad_t sticks;
	vm_prot_t ftype;
	extern unsigned onfault_table[];
	int typ = 0;
	union sigval sv;

#ifdef DEBUG
	trp->status = statusReg;
	trp->cause = causeReg;
	trp->vadr = vadr;
	trp->pc = pc;
	trp->ra = !USERMODE(statusReg) ? ((int *)&args)[19] :
		p->p_md.md_regs[RA];
	trp->sp = (int)&args;
	trp->code = 0;
	if (++trp == &trapdebug[TRAPSIZE])
		trp = trapdebug;
#endif

	cnt.v_trap++;
	type = (causeReg & MIPS1_CR_EXC_CODE) >> MIPS_CR_EXC_CODE_SHIFT;
	if (USERMODE(statusReg)) {
		type |= T_USER;
		sticks = p->p_sticks;
	}

	/*
	 * Enable hardware interrupts if they were on before.
	 * We only respond to software interrupts when returning to user mode.
	 */
	if (statusReg & MIPS_SR_INT_ENA_PREV)
		splx((statusReg & MIPS_HARD_INT_MASK) | MIPS_SR_INT_IE);

	switch (type) {
	case T_TLB_MOD:
		/* check for kernel address */
		if ((int)vadr < 0) {
			register pt_entry_t *pte;
			register unsigned entry;
			register vm_offset_t pa;

			pte = kvtopte(vadr);
			entry = pte->pt_entry;
#ifdef DIAGNOSTIC
			if (!(entry & PG_V) || (entry & PG_M))
				panic("trap: ktlbmod: invalid pte");
#endif
			if (PAGE_IS_RDONLY(entry, vadr)) {
				/* write to read only page in the kernel */
				ftype = VM_PROT_WRITE;
				goto kernel_fault;
			}
			entry |= PG_M;
			pte->pt_entry = entry;
			vadr &= ~PGOFSET;
			MachTLBUpdate(vadr, entry);
			pa = PTE_TO_PADDR(entry);
#ifdef ATTR
			pmap_attributes[atop(pa)] |= PMAP_ATTR_MOD;
#else
			if (!IS_VM_PHYSADDR(pa))
				panic("trap: ktlbmod: unmanaged page");
			PHYS_TO_VM_PAGE(pa)->flags &= ~PG_CLEAN;
#endif
			return (pc);
		}
		/* FALLTHROUGH */

	case T_TLB_MOD+T_USER:
	    {
		register pt_entry_t *pte;
		register unsigned entry;
		register vm_offset_t pa;
		pmap_t pmap = p->p_vmspace->vm_map.pmap;

		if (!(pte = pmap_segmap(pmap, vadr)))
			panic("trap: utlbmod: invalid segmap");
		pte += (vadr >> PGSHIFT) & (NPTEPG - 1);
		entry = pte->pt_entry;
#ifdef DIAGNOSTIC
		if (!(entry & PG_V) || (entry & PG_M)) {
			panic("trap: utlbmod: invalid pte");
		}
#endif
		if (PAGE_IS_RDONLY(entry, vadr)) {
			/* write to read only page */
			ftype = VM_PROT_WRITE;
			goto dofault;
		}
		entry |= PG_M;
		pte->pt_entry = entry;
		vadr = (vadr & ~PGOFSET) |
			(pmap->pm_tlbpid << MIPS_TLB_PID_SHIFT);
		MachTLBUpdate(vadr, entry);
		pa = PTE_TO_PADDR(entry);
#ifdef ATTR
		pmap_attributes[atop(pa)] |= PMAP_ATTR_MOD;
#else
		if (!IS_VM_PHYSADDR(pa)) {
			panic("trap: utlbmod: unmanaged page");
		}
		PHYS_TO_VM_PAGE(pa)->flags &= ~PG_CLEAN;
#endif
		if (!USERMODE(statusReg))
			return (pc);
		goto out;
	    }

	case T_TLB_LD_MISS:
	case T_TLB_ST_MISS:
		ftype = (type == T_TLB_ST_MISS) ? VM_PROT_WRITE : VM_PROT_READ;
		/* check for kernel address */
		if ((int)vadr < 0) {
			register vm_offset_t va;
			int rv;

		kernel_fault:
			kernelfaults++;
			va = trunc_page((vm_offset_t)vadr);
			rv = vm_fault(kernel_map, va, ftype, FALSE);
			if (rv == KERN_SUCCESS)
				return (pc);
			if ((i = ((struct pcb *)UADDR)->pcb_onfault) != 0) {
				((struct pcb *)UADDR)->pcb_onfault = 0;
				return (onfault_table[i]);
			}
			goto err;
		}
		/*
		 * It is an error for the kernel to access user space except
		 * through the copyin/copyout routines.
		 */
		if ((i = ((struct pcb *)UADDR)->pcb_onfault) == 0)
			goto err;
		/* check for fuswintr() or suswintr() getting a page fault */
		if (i == 4)
			return (onfault_table[i]);
		goto dofault;

	case T_TLB_LD_MISS+T_USER:
		ftype = VM_PROT_READ;
		goto dofault;

	case T_TLB_ST_MISS+T_USER:
		ftype = VM_PROT_WRITE;
	dofault:
	    {
		register vm_offset_t va;
		register struct vmspace *vm;
		register vm_map_t map;
		int rv;

		vm = p->p_vmspace;
		map = &vm->vm_map;
		va = trunc_page((vm_offset_t)vadr);
		rv = vm_fault(map, va, ftype, FALSE);
#ifdef VMFAULT_TRACE
		printf("vm_fault(%x (pmap %x), %x (%x), %x, %d) -> %x at pc %x\n",
		       map, vm->vm_map.pmap, va, vadr, ftype, FALSE, rv, pc);
#endif
		/*
		 * If this was a stack access we keep track of the maximum
		 * accessed stack size.  Also, if vm_fault gets a protection
		 * failure it is due to accessing the stack region outside
		 * the current limit and we need to reflect that as an access
		 * error.
		 */
		if ((caddr_t)va >= vm->vm_maxsaddr) {
			if (rv == KERN_SUCCESS) {
				unsigned nss;

				nss = btoc(USRSTACK-(unsigned)va);
				if (nss > vm->vm_ssize)
					vm->vm_ssize = nss;
			} else if (rv == KERN_PROTECTION_FAILURE)
				rv = KERN_INVALID_ADDRESS;
		}
		if (rv == KERN_SUCCESS) {
			if (!USERMODE(statusReg))
				return (pc);
			goto out;
		}
		if (!USERMODE(statusReg)) {
			if ((i = ((struct pcb *)UADDR)->pcb_onfault) != 0) {
				((struct pcb *)UADDR)->pcb_onfault = 0;
				return (onfault_table[i]);
			}
			goto err;
		}
		ucode = ftype;
		i = SIGSEGV;
		typ = SEGV_MAPERR;
		break;
	    }

	case T_ADDR_ERR_LD+T_USER:	/* misaligned or kseg access */
	case T_ADDR_ERR_ST+T_USER:	/* misaligned or kseg access */
		ucode = 0;		/* XXX should be VM_PROT_something */
		i = SIGBUS;
		typ = BUS_ADRALN;
		break;
	case T_BUS_ERR_IFETCH+T_USER:	/* BERR asserted to cpu */
	case T_BUS_ERR_LD_ST+T_USER:	/* BERR asserted to cpu */
		ucode = 0;		/* XXX should be VM_PROT_something */
		i = SIGBUS;
		typ = BUS_OBJERR;
		break;

	case T_SYSCALL+T_USER:
	    {
		register int *locr0 = p->p_md.md_regs;
		register struct sysent *callp;
		unsigned int code;
		int numsys;
		struct args {
			int i[8];
		} args;
		int rval[2];

		cnt.v_syscall++;
		/* compute next PC after syscall instruction */
		if ((int)causeReg < 0)
			locr0[PC] = MachEmulateBranch(locr0, pc, 0, 0);
		else
			locr0[PC] += 4;
		callp = p->p_emul->e_sysent;
		numsys = p->p_emul->e_nsysent;
		code = locr0[V0];
		switch (code) {
		case SYS_syscall:
			/*
			 * Code is first argument, followed by actual args.
			 */
			code = locr0[A0];
			if (code >= numsys)
				callp += p->p_emul->e_nosys; /* (illegal) */
			else
				callp += code;
			i = callp->sy_argsize / sizeof(int);
			args.i[0] = locr0[A1];
			args.i[1] = locr0[A2];
			args.i[2] = locr0[A3];
			if (i > 3) {
				i = copyin((caddr_t)(locr0[SP] +
						4 * sizeof(int)),
					(caddr_t)&args.i[3],
					(u_int)(i - 3) * sizeof(int));
				if (i) {
					locr0[V0] = i;
					locr0[A3] = 1;
#ifdef SYSCALL_DEBUG
					scdebug_call(p, code, args.i);
#endif
#ifdef KTRACE
					if (KTRPOINT(p, KTR_SYSCALL))
						ktrsyscall(p, code,
							callp->sy_argsize,
							args.i);
#endif
					goto done;
				}
			}
			break;

		case SYS___syscall:
			/*
			 * Like syscall, but code is a quad, so as to maintain
			 * quad alignment for the rest of the arguments.
			 */
			code = locr0[A0 + _QUAD_LOWWORD];
			if (code >= numsys)
				callp += p->p_emul->e_nosys; /* (illegal) */
			else
				callp += code;
			i = callp->sy_argsize / sizeof(int);
			args.i[0] = locr0[A2];
			args.i[1] = locr0[A3];
			if (i > 2) {
				i = copyin((caddr_t)(locr0[SP] +
						4 * sizeof(int)),
					(caddr_t)&args.i[2],
					(u_int)(i - 2) * sizeof(int));
				if (i) {
					locr0[V0] = i;
					locr0[A3] = 1;
#ifdef SYSCALL_DEBUG
					scdebug_call(p, code, args.i);
#endif
#ifdef KTRACE
					if (KTRPOINT(p, KTR_SYSCALL))
						ktrsyscall(p, code,
							callp->sy_argsize,
							args.i);
#endif
					goto done;
				}
			}
			break;

		default:
			if (code >= numsys)
				callp += p->p_emul->e_nosys; /* (illegal) */
			else
				callp += code;
			i = callp->sy_narg;
			args.i[0] = locr0[A0];
			args.i[1] = locr0[A1];
			args.i[2] = locr0[A2];
			args.i[3] = locr0[A3];
			if (i > 4) {
				i = copyin((caddr_t)(locr0[SP] +
						4 * sizeof(int)),
					(caddr_t)&args.i[4],
					(u_int)(i - 4) * sizeof(int));
				if (i) {
					locr0[V0] = i;
					locr0[A3] = 1;
#ifdef SYSCALL_DEBUG
					scdebug_call(p, code, args.i);
#endif
#ifdef KTRACE
					if (KTRPOINT(p, KTR_SYSCALL))
						ktrsyscall(p, code,
							callp->sy_argsize,
							args.i);
#endif
					goto done;
				}
			}
		}
#ifdef SYSCALL_DEBUG
		scdebug_call(p, code, args.i);
#endif
#ifdef KTRACE
		if (KTRPOINT(p, KTR_SYSCALL))
			ktrsyscall(p, code, callp->sy_argsize, args.i);
#endif
		rval[0] = 0;
		rval[1] = locr0[V1];
#ifdef DEBUG
		if (trp == trapdebug)
			trapdebug[TRAPSIZE - 1].code = code;
		else
			trp[-1].code = code;
#endif
		i = (*callp->sy_call)(p, &args, rval);
		/*
		 * Reinitialize proc pointer `p' as it may be different
		 * if this is a child returning from fork syscall.
		 */
		p = curproc;
		locr0 = p->p_md.md_regs;
#ifdef DEBUG
		{ int s;
		s = splhigh();
		trp->status = statusReg;
		trp->cause = causeReg;
		trp->vadr = locr0[SP];
		trp->pc = locr0[PC];
		trp->ra = locr0[RA];
		/*trp->sp = (int)&args;*/
		trp->code = -code;
		if (++trp == &trapdebug[TRAPSIZE])
			trp = trapdebug;
		splx(s);
		}
#endif
		switch (i) {
		case 0:
			locr0[V0] = rval[0];
			locr0[V1] = rval[1];
			locr0[A3] = 0;
			break;

		case ERESTART:
			locr0[PC] = pc;
			break;

		case EJUSTRETURN:
			break;	/* nothing to do */

		default:
			locr0[V0] = i;
			locr0[A3] = 1;
		}

		/*
		 * If we modified code or data, flush caches.
		 * XXX code unyderling ptrace() and/or proc fs should do this?
		 */
		if (code == SYS_ptrace)
			MachFlushCache();
	done:
#ifdef SYSCALL_DEBUG
		scdebug_ret(p, code, i, rval);
#endif
#ifdef KTRACE
		if (KTRPOINT(p, KTR_SYSRET))
			ktrsysret(p, code, i, rval[0]); /*XXX*/
#endif
		goto out;
	    }

	case T_BREAK+T_USER:
	    {
		register unsigned va, instr;

		/* compute address of break instruction */
		va = pc;
		if ((int)causeReg < 0)
			va += 4;

		/* read break instruction */
		instr = fuiword((caddr_t)va);
#if 0
		printf("trap: %s (%d) breakpoint %x at %x: (adr %x ins %x)\n",
			p->p_comm, p->p_pid, instr, pc,
			p->p_md.md_ss_addr, p->p_md.md_ss_instr); /* XXX */
#endif
#ifdef KADB
		if (instr == MIPS_BREAK_BRKPT || instr == MIPS_BREAK_SSTEP)
			goto err;
#endif
		if (p->p_md.md_ss_addr != va || instr != MIPS_BREAK_SSTEP) {
			i = SIGTRAP;
			typ = TRAP_TRACE;
			break;
		}

		/* restore original instruction and clear BP  */
		i = suiword((caddr_t)va, p->p_md.md_ss_instr);
		if (i < 0) {
			vm_offset_t sa, ea;
			int rv;

			sa = trunc_page((vm_offset_t)va);
			ea = round_page((vm_offset_t)va+sizeof(int)-1);
			rv = vm_map_protect(&p->p_vmspace->vm_map, sa, ea,
				VM_PROT_DEFAULT, FALSE);
			if (rv == KERN_SUCCESS) {
				i = suiword((caddr_t)va, p->p_md.md_ss_instr);
				(void) vm_map_protect(&p->p_vmspace->vm_map,
					sa, ea, VM_PROT_READ|VM_PROT_EXECUTE,
					FALSE);
			}
		}
		if (i < 0)
			printf("Warning: can't restore instruction at %x: %x\n",
				p->p_md.md_ss_addr, p->p_md.md_ss_instr);
		p->p_md.md_ss_addr = 0;
		i = SIGTRAP;
		typ = TRAP_BRKPT;
		break;
	    }

	case T_RES_INST+T_USER:
		i = SIGILL;
		typ = ILL_ILLOPC;
		break;

	case T_COP_UNUSABLE+T_USER:
		if ((causeReg & MIPS_CR_COP_ERR) != 0x10000000) {
			i = SIGILL;	/* only FPU instructions allowed */
			typ = ILL_ILLOPC;
			break;
		}
		MachSwitchFPState(machFPCurProcPtr,
				  (struct user*)p->p_md.md_regs);
		machFPCurProcPtr = p;
		p->p_md.md_regs[PS] |= MIPS_SR_COP_1_BIT;
		p->p_md.md_flags |= MDP_FPUSED;
		goto out;

	case T_FPE:
#ifdef DEBUG
		trapDump("fpintr");
#else
		printf("FPU Trap: PC %x CR %x SR %x\n",
			pc, causeReg, statusReg);
		goto err;
#endif

	case T_FPE+T_USER:
		MachFPTrap(statusReg, causeReg, pc);
		goto out;

	case T_OVFLOW+T_USER:
		i = SIGFPE;
		typ = FPE_FLTOVF;
		break;

	case T_ADDR_ERR_LD:	/* misaligned access */
	case T_ADDR_ERR_ST:	/* misaligned access */
	case T_BUS_ERR_LD_ST:	/* BERR asserted to cpu */
		if ((i = ((struct pcb *)UADDR)->pcb_onfault) != 0) {
			((struct pcb *)UADDR)->pcb_onfault = 0;
			return (onfault_table[i]);
		}
		/* FALLTHROUGH */

	default:
	err:
#ifdef KADB
	    {
		extern struct pcb kdbpcb;

		if (USERMODE(statusReg))
			kdbpcb = p->p_addr->u_pcb;
		else {
			kdbpcb.pcb_regs[ZERO] = 0;
			kdbpcb.pcb_regs[AST] = ((int *)&args)[2];
			kdbpcb.pcb_regs[V0] = ((int *)&args)[3];
			kdbpcb.pcb_regs[V1] = ((int *)&args)[4];
			kdbpcb.pcb_regs[A0] = ((int *)&args)[5];
			kdbpcb.pcb_regs[A1] = ((int *)&args)[6];
			kdbpcb.pcb_regs[A2] = ((int *)&args)[7];
			kdbpcb.pcb_regs[A3] = ((int *)&args)[8];
			kdbpcb.pcb_regs[T0] = ((int *)&args)[9];
			kdbpcb.pcb_regs[T1] = ((int *)&args)[10];
			kdbpcb.pcb_regs[T2] = ((int *)&args)[11];
			kdbpcb.pcb_regs[T3] = ((int *)&args)[12];
			kdbpcb.pcb_regs[T4] = ((int *)&args)[13];
			kdbpcb.pcb_regs[T5] = ((int *)&args)[14];
			kdbpcb.pcb_regs[T6] = ((int *)&args)[15];
			kdbpcb.pcb_regs[T7] = ((int *)&args)[16];
			kdbpcb.pcb_regs[T8] = ((int *)&args)[17];
			kdbpcb.pcb_regs[T9] = ((int *)&args)[18];
			kdbpcb.pcb_regs[RA] = ((int *)&args)[19];
			kdbpcb.pcb_regs[MULLO] = ((int *)&args)[21];
			kdbpcb.pcb_regs[MULHI] = ((int *)&args)[22];
			kdbpcb.pcb_regs[PC] = pc;
			kdbpcb.pcb_regs[SR] = statusReg;
			bzero((caddr_t)&kdbpcb.pcb_regs[F0], 33 * sizeof(int));
		}
		if (kdb(causeReg, vadr, p, !USERMODE(statusReg)))
			return (kdbpcb.pcb_regs[PC]);
	    }
#else
#ifdef DEBUG
		stacktrace();
		trapDump("trap");
#endif
#endif
		panic("trap");
	}
	p->p_md.md_regs [PC] = pc;
	p->p_md.md_regs [CAUSE] = causeReg;
	p->p_md.md_regs [BADVADDR] = vadr;
	sv.sival_int = vadr;
	trapsignal(p, i, ucode, typ, sv);
out:
	/*
	 * Note: we should only get here if returning to user mode.
	 */
	/* take pending signals */
	while ((i = CURSIG(p)) != 0)
		postsig(i);
	p->p_priority = p->p_usrpri;
	astpending = 0;
	if (want_resched) {
		int s;

		/*
		 * Since we are curproc, clock will normally just change
		 * our priority without moving us from one queue to another
		 * (since the running process is not on a queue.)
		 * If that happened after we put ourselves on the run queue
		 * but before we switched, we might not be on the queue
		 * indicated by our priority.
		 */
		s = splstatclock();
		setrunqueue(p);
		p->p_stats->p_ru.ru_nivcsw++;
		mi_switch();
		splx(s);
		while ((i = CURSIG(p)) != 0)
			postsig(i);
	}

	/*
	 * If profiling, charge system time to the trapped pc.
	 */
	if (p->p_flag & P_PROFIL) {
		extern int psratio;

		addupc_task(p, pc, (int)(p->p_sticks - sticks) * psratio);
	}

	curpriority = p->p_priority;
	return (pc);
}

/*
 * Handle an interrupt.
 * Called from MachKernIntr() or MachUserIntr()
 * Note: curproc might be NULL.
 */
void
interrupt(statusReg, causeReg, pc /* XXX what, args */ )
	unsigned statusReg;	/* status register at time of the exception */
	unsigned causeReg;	/* cause register at time of exception */
	unsigned pc;		/* program counter where to continue */
{
	register unsigned mask;
	/*struct clockframe cf;*/

#ifdef DEBUG
	trp->status = statusReg;
	trp->cause = causeReg;
	trp->vadr = 0;
	trp->pc = pc;
	trp->ra = 0;
	trp->sp = /* (int)&args */ 0;	/* XXX pass args in */
	trp->code = 0;
	if (++trp == &trapdebug[TRAPSIZE])
		trp = trapdebug;
#endif

	cnt.v_intr++;
	mask = causeReg & statusReg;	/* pending interrupts & enable mask */
	if (mips_hardware_intr)
		splx((*mips_hardware_intr)(mask, pc, statusReg, causeReg));
	if (mask & MIPS_INT_MASK_5) {
		intrcnt[FPU_INTR]++;
		if (!USERMODE(statusReg)) {
#ifdef DEBUG
			trapDump("fpintr");
#else
			printf("FPU interrupt: PC %x CR %x SR %x\n",
				pc, causeReg, statusReg);
#endif
		} else
			MachFPInterrupt(statusReg, causeReg, pc);
	}

	/* process network interrupt if we trapped or will very soon */
	/* XXX fixme: operator precedence botch? */
	if ((mask & MIPS_SOFT_INT_MASK_1) ||
	    netisr && (statusReg & MIPS_SOFT_INT_MASK_1)) {
		clearsoftnet();
		cnt.v_soft++;
		intrcnt[SOFTNET_INTR]++;
#ifdef INET
		if (netisr & (1 << NETISR_ARP)) {
			netisr &= ~(1 << NETISR_ARP);
			arpintr();
		}
		if (netisr & (1 << NETISR_IP)) {
			netisr &= ~(1 << NETISR_IP);
			ipintr();
		}
#endif
#ifdef INET6
		if (netisr & (1 << NETISR_IPV6)) {
			netisr &= ~(1 << NETISR_IPV6);
			ipv6intr();
		}
#endif
#ifdef NETATALK
		if (netisr & (1 << NETISR_ATALK)) {
			netisr &= ~(1 << NETISR_ATALK);
			atintr();
		}
#endif
#ifdef NS
		if (netisr & (1 << NETISR_NS)) {
			netisr &= ~(1 << NETISR_NS);
			nsintr();
		}
#endif
#ifdef ISO
		if (netisr & (1 << NETISR_ISO)) {
			netisr &= ~(1 << NETISR_ISO);
			clnlintr();
		}
#endif
#if NPPP > 0
		if (netisr & (1 << NETISR_PPP)) {
			netisr &= ~(1 << NETISR_PPP);
			pppintr();
		}
#endif
#if NBRIDGE > 0
		if (netisr & (1 << NETISR_BRIDGE)) {
			netisr &= ~(1 << NETISR_BRIDGE);
			bridgeintr();
		}
#endif
	}

	if (mask & MIPS_SOFT_INT_MASK_0) {
		clearsoftclock();
		intrcnt[SOFTCLOCK_INTR]++;
		cnt.v_soft++;
		softclock();
	}
}


/*
 * This is called from MachUserIntr() if astpending is set.
 * This is very similar to the tail of trap().
 */
void
softintr(statusReg, pc)
	unsigned statusReg;	/* status register at time of the exception */
	unsigned pc;		/* program counter where to continue */
{
	register struct proc *p = curproc;
	int sig;

	cnt.v_soft++;
	/* take pending signals */
	while ((sig = CURSIG(p)) != 0)
		postsig(sig);
	p->p_priority = p->p_usrpri;
	astpending = 0;
	if (p->p_flag & P_OWEUPC) {
		p->p_flag &= ~P_OWEUPC;
		ADDUPROF(p);
	}
	if (want_resched) {
		int s;

		/*
		 * Since we are curproc, clock will normally just change
		 * our priority without moving us from one queue to another
		 * (since the running process is not on a queue.)
		 * If that happened after we put ourselves on the run queue
		 * but before we switched, we might not be on the queue
		 * indicated by our priority.
		 */
		s = splstatclock();
		setrunqueue(p);
		p->p_stats->p_ru.ru_nivcsw++;
		mi_switch();
		splx(s);
		while ((sig = CURSIG(p)) != 0)
			postsig(sig);
	}
	curpriority = p->p_priority;
}

#ifdef DEBUG
void
trapDump(msg)
	char *msg;
{
	register int i;
	int s;

	s = splhigh();
	printf("trapDump(%s)\n", msg);
	for (i = 0; i < TRAPSIZE; i++) {
		if (trp == trapdebug)
			trp = &trapdebug[TRAPSIZE - 1];
		else
			trp--;
		if (trp->cause == 0)
			break;
		printf("%s: ADR %x PC %x CR %x SR %x\n",
			trap_type[(trp->cause & MIPS1_CR_EXC_CODE) >>
				MIPS_CR_EXC_CODE_SHIFT],
			trp->vadr, trp->pc, trp->cause, trp->status);
		printf("   RA %x SP %x code %d\n", trp->ra, trp->sp, trp->code);
	}
	bzero(trapdebug, sizeof(trapdebug));
	trp = trapdebug;
	splx(s);
}
#endif

/*
 * forward declaration
 */
static unsigned GetBranchDest __P((InstFmt *InstPtr));


/*
 * Compute destination of a branch instruction.
 * XXX  Compute desination of r4000 squashed branches?
 */
static unsigned
GetBranchDest(InstPtr)
	InstFmt *InstPtr;
{
	return ((unsigned)InstPtr + 4 + ((short)InstPtr->IType.imm << 2));
}


/*
 * Return the resulting PC as if the branch was executed.
 */
unsigned
MachEmulateBranch(regsPtr, instPC, fpcCSR, allowNonBranch)
	unsigned *regsPtr;
	unsigned instPC;
	unsigned fpcCSR;
	int allowNonBranch;
{
	InstFmt inst;
	unsigned retAddr;
	int condition;

	inst.word = (instPC < MIPS_KSEG0_START) ?
		fuiword((caddr_t)instPC) : *(unsigned*)instPC;

#if 0
	printf("regsPtr=%x PC=%x Inst=%x fpcCsr=%x\n", regsPtr, instPC,
		inst.word, fpcCSR); /* XXX */
#endif
	switch ((int)inst.JType.op) {
	case OP_SPECIAL:
		switch ((int)inst.RType.func) {
		case OP_JR:
		case OP_JALR:
			retAddr = regsPtr[inst.RType.rs];
			break;

		default:
			if (!allowNonBranch)
				panic("MachEmulateBranch: Non-branch");
			retAddr = instPC + 4;
			break;
		}
		break;

	case OP_BCOND:
		switch ((int)inst.IType.rt) {
		case OP_BLTZ:
		case OP_BLTZAL:
		case OP_BLTZL:		/* squashed */
		case OP_BLTZALL:	/* squashed */

			if ((int)(regsPtr[inst.RType.rs]) < 0)
				retAddr = GetBranchDest((InstFmt *)instPC);
			else
				retAddr = instPC + 8;
			break;

		case OP_BGEZ:
		case OP_BGEZAL:
		case OP_BGEZL:		/* squashed */
		case OP_BGEZALL:	/* squashed */

			if ((int)(regsPtr[inst.RType.rs]) >= 0)
				retAddr = GetBranchDest((InstFmt *)instPC);
			else
				retAddr = instPC + 8;
			break;

		default:
			panic("MachEmulateBranch: Bad branch cond");
		}
		break;

	case OP_J:
	case OP_JAL:
		retAddr = (inst.JType.target << 2) | 
			((unsigned)instPC & 0xF0000000);
		break;

	case OP_BEQ:
	case OP_BEQL:			/* squashed */

		if (regsPtr[inst.RType.rs] == regsPtr[inst.RType.rt])
			retAddr = GetBranchDest((InstFmt *)instPC);
		else
			retAddr = instPC + 8;
		break;

	case OP_BNE:
	case OP_BNEL:			/* squashed */

		if (regsPtr[inst.RType.rs] != regsPtr[inst.RType.rt])
			retAddr = GetBranchDest((InstFmt *)instPC);
		else
			retAddr = instPC + 8;
		break;

	case OP_BLEZ:
	case OP_BLEZL:				/* squashed */

		if ((int)(regsPtr[inst.RType.rs]) <= 0)
			retAddr = GetBranchDest((InstFmt *)instPC);
		else
			retAddr = instPC + 8;
		break;

	case OP_BGTZ:
	case OP_BGTZL:				/* squashed */

		if ((int)(regsPtr[inst.RType.rs]) > 0)
			retAddr = GetBranchDest((InstFmt *)instPC);
		else
			retAddr = instPC + 8;
		break;

	case OP_COP1:
		switch (inst.RType.rs) {
		case OP_BCx:
		case OP_BCy:
			if ((inst.RType.rt & COPz_BC_TF_MASK) == COPz_BC_TRUE)
				condition = fpcCSR & MIPS_FPU_COND_BIT;
			else
				condition = !(fpcCSR & MIPS_FPU_COND_BIT);
			if (condition)
				retAddr = GetBranchDest((InstFmt *)instPC);
			else
				retAddr = instPC + 8;
			break;

		default:
			if (!allowNonBranch)
				panic("MachEmulateBranch: Bad coproc branch instruction");
			retAddr = instPC + 4;
		}
		break;

	default:
		if (!allowNonBranch)
			panic("MachEmulateBranch: Non-branch instruction");
		retAddr = instPC + 4;
	}
#if 0
	printf("Target addr=%x\n", retAddr); /* XXX */
#endif
	return (retAddr);
}


/*
 * This routine is called by procxmt() to single step one instruction.
 * We do this by storing a break instruction after the current instruction,
 * resuming execution, and then restoring the old instruction.
 */
int
cpu_singlestep(p)
	register struct proc *p;
{
	register unsigned va;
	register int *locr0 = p->p_md.md_regs;
	int i;

#if notanymore
	/* compute next address after current location */
	va = MachEmulateBranch(locr0, locr0[PC], locr0[FSR], 1);
	if (p->p_md.md_ss_addr || p->p_md.md_ss_addr == va ||
	    !useracc((caddr_t)va, 4, B_READ)) {
		printf("SS %s (%d): breakpoint already set at %x (va %x)\n",
			p->p_comm, p->p_pid, p->p_md.md_ss_addr, va); /* XXX */
		return (EFAULT);
	}
	p->p_md.md_ss_addr = va;
	p->p_md.md_ss_instr = fuiword((caddr_t)va);
	i = suiword((caddr_t)va, MIPS_BREAK_SSTEP);
	if (i < 0) {
		vm_offset_t sa, ea;
		int rv;

		sa = trunc_page((vm_offset_t)va);
		ea = round_page((vm_offset_t)va+sizeof(int)-1);
		rv = vm_map_protect(&p->p_vmspace->vm_map, sa, ea,
			VM_PROT_DEFAULT, FALSE);
		if (rv == KERN_SUCCESS) {
			i = suiword((caddr_t)va, MIPS_BREAK_SSTEP);
			(void) vm_map_protect(&p->p_vmspace->vm_map,
				sa, ea, VM_PROT_READ|VM_PROT_EXECUTE, FALSE);
		}
	}
#endif
	int bpinstr = MIPS_BREAK_SSTEP;
	int curinstr;
	struct uio uio;
	struct iovec iov;

	/*
	 * Fetch what's at the current location.
	 */
	iov.iov_base = (caddr_t)&curinstr;
	iov.iov_len = sizeof(int); 
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1; 
	uio.uio_offset = (off_t)locr0[PC];
	uio.uio_resid = sizeof(int);
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_READ;
	uio.uio_procp = curproc;
	procfs_domem(curproc, p, NULL, &uio);

	/* compute next address after current location */
	if(curinstr != 0) {
		va = MachEmulateBranch(locr0, locr0[PC], locr0[FSR], curinstr);
	}
	else {
		va = locr0[PC] + 4;
	}
	if (p->p_md.md_ss_addr) {
		printf("SS %s (%d): breakpoint already set at %x (va %x)\n",
			p->p_comm, p->p_pid, p->p_md.md_ss_addr, va); /* XXX */
		return (EFAULT);
	}
	p->p_md.md_ss_addr = va;

	/*
	 * Fetch what's at the current location.
	 */
	iov.iov_base = (caddr_t)&p->p_md.md_ss_instr;
	iov.iov_len = sizeof(int); 
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1; 
	uio.uio_offset = (off_t)va;
	uio.uio_resid = sizeof(int);
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_READ;
	uio.uio_procp = curproc;
	procfs_domem(curproc, p, NULL, &uio);

	/*
	 * Store breakpoint instruction at the "next" location now.
	 */
	iov.iov_base = (caddr_t)&bpinstr;
	iov.iov_len = sizeof(int); 
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1; 
	uio.uio_offset = (off_t)va;
	uio.uio_resid = sizeof(int);
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_WRITE;
	uio.uio_procp = curproc;
	i = procfs_domem(curproc, p, NULL, &uio);
	MachFlushCache(); /* XXX memory barrier followed by flush icache? */

	if (i < 0)
		return (EFAULT);
#if 0
	printf("SS %s (%d): breakpoint set at %x: %x (pc %x) br %x\n",
		p->p_comm, p->p_pid, p->p_md.md_ss_addr,
		p->p_md.md_ss_instr, locr0[PC], fuword((caddr_t)va)); /* XXX */
#endif
	return (0);
}

#ifdef DEBUG
int
kdbpeek(addr)
{
	if (addr & 3) {
		printf("kdbpeek: unaligned address %x\n", addr);
		return (-1);
	}
	return (*(int *)addr);
}
#endif

#ifdef DEBUG
#define MIPS_JR_RA	0x03e00008	/* instruction code for jr ra */

/* forward */
char *fn_name(unsigned addr);
void stacktrace_subr __P((int, int, int, int, int (*)(const char*, ...)));

/*
 * Print a stack backtrace.
 */
void
stacktrace(a0, a1, a2, a3)
	int a0, a1, a2, a3;
{
	stacktrace_subr(a0, a1, a2, a3, printf);
}

void
logstacktrace(a0, a1, a2, a3)
	int a0, a1, a2, a3;
{
	stacktrace_subr(a0, a1, a2, a3, addlog);
}

void
stacktrace_subr(a0, a1, a2, a3, printfn)
	int a0, a1, a2, a3;
	int (*printfn) __P((const char*, ...));
{
	unsigned pc, sp, fp, ra, va, subr;
	unsigned instr, mask;
	InstFmt i;
	int more, stksize;
	int regs[3];
	extern char start[], edata[];
	unsigned int frames =  0;

	cpu_getregs(regs);

	/* get initial values from the exception frame */
	sp = regs[0];
	pc = regs[1];
	ra = 0;
	fp = regs[2];

/* Jump here when done with a frame, to start a new one */
loop:
	ra = 0;

/* Jump here after a nonstandard (interrupt handler) frame */
specialframe:
	stksize = 0;
	subr = 0;
	if	(frames++ > 100) {
		(*printfn)("\nstackframe count exceeded\n");
		/* return breaks stackframe-size heuristics with gcc -O2 */
		goto finish;	/*XXX*/
	}

	/* check for bad SP: could foul up next frame */
	if (sp & 3 || sp < 0x80000000) {
		(*printfn)("SP 0x%x: not in kernel\n", sp);
		ra = 0;
		subr = 0;
		goto done;
	}

/*
 * check for PC between two entry points
 */
# define Between(x, y, z) \
		( ((x) <= (y)) && ((y) < (z)) )
# define pcBetween(a,b) \
		Between((unsigned)a, pc, (unsigned)b)


	/* Backtraces should continue through interrupts from kernel mode */
#ifdef MIPS1	/*  r2000 family  (mips-I cpu) */
	if (pcBetween(mips1_KernIntr, mips1_UserIntr)) {
		/* NOTE: the offsets depend on the code in locore.s */
		(*printfn)("r3000 KernIntr+%x: (%x, %x ,%x) -------\n",
		       pc-(unsigned)mips1_KernIntr, a0, a1, a2);
		a0 = kdbpeek(sp + 36);
		a1 = kdbpeek(sp + 40);
		a2 = kdbpeek(sp + 44);
		a3 = kdbpeek(sp + 48);

		pc = kdbpeek(sp + 20);	/* exc_pc - pc at time of exception */
		ra = kdbpeek(sp + 92);	/* ra at time of exception */
		sp = sp + 108;
		goto specialframe;
	}
#endif	/* MIPS1 */

#ifdef MIPS3		/* r4000 family (mips-III cpu) */
	if (pcBetween(mips3_KernIntr, mips3_UserIntr)) {
		/* NOTE: the offsets depend on the code in locore.s */
		(*printfn)("R4000 KernIntr+%x: (%x, %x ,%x) -------\n",
		       pc-(unsigned)mips3_KernIntr, a0, a1, a2);
		a0 = kdbpeek(sp + 36);
		a1 = kdbpeek(sp + 40);
		a2 = kdbpeek(sp + 44);
		a3 = kdbpeek(sp + 48);

		pc = kdbpeek(sp + 20);	/* exc_pc - pc at time of exception */
		ra = kdbpeek(sp + 92);	/* ra at time of exception */
		sp = sp + 108;
		goto specialframe;
	}
#endif	/* MIPS3 */



	/*
	 * Check for current PC in  exception handler code that don't
	 * have a preceding "j ra" at the tail of the preceding function. 
	 * Depends on relative ordering of functions in locore.
	 */

	/* XXX fixup tests after cutting and pasting in locore.S */
	/* R4000  exception handlers */

#ifdef MIPS1	/*  r2000 family  (mips-I cpu) */
	if (pcBetween(mips1_KernGenException, mips1_UserGenException))
		subr = (unsigned) mips1_KernGenException;
	else if (pcBetween(mips1_UserGenException,mips1_KernIntr))
		subr = (unsigned) mips1_UserGenException;
	else if (pcBetween(mips1_KernIntr, mips1_UserIntr))
		subr = (unsigned) mips1_KernIntr;
	else if (pcBetween(mips1_UserIntr, mips1_TLBMissException))
		subr = (unsigned) mips1_UserIntr;

	else if (pcBetween(mips1_UserIntr, mips1_TLBMissException))
		subr = (unsigned) mips1_UserIntr;
	else if (pcBetween(mips1_UTLBMiss, mips1_exceptionentry_end)) {
		(*printfn)("<<mips1 locore>>");
		goto done;
	}
	else
#endif /* MIPS1 */


#ifdef MIPS3		/* r4000 family (mips-III cpu) */
	/* R4000  exception handlers */
	if (pcBetween(mips3_KernGenException, mips3_UserGenException))
		subr = (unsigned) mips3_KernGenException;
	else if (pcBetween(mips3_UserGenException,mips3_KernIntr))
		subr = (unsigned) mips3_UserGenException;
	else if (pcBetween(mips3_KernIntr, mips3_UserIntr))
		subr = (unsigned) mips3_KernIntr;


	else if (pcBetween(mips3_UserIntr, mips3_TLBMissException))
		subr = (unsigned) mips3_UserIntr;
	else if (pcBetween(mips3_TLBMiss, mips3_exceptionentry_end)) {
		(*printfn)("<<mips3 locore>>");
		goto done;
	} else
#endif /* MIPS3 */


	if (pcBetween(splx, wbflush))
		subr = (unsigned) splx;
	else if (pcBetween(cpu_switch, fuword))
		subr = (unsigned) cpu_switch;
	else if (pcBetween(idle, cpu_switch))	{
		subr = (unsigned) idle;
		ra = 0;
		goto done;
	}


	/* Check for bad PC */
	if (pc & 3 || pc < 0x80000000 || pc >= (unsigned)edata) {
		(*printfn)("PC 0x%x: not in kernel space\n", pc);
		ra = 0;
		goto done;
	}
	if (!pcBetween(start, (unsigned) edata)) {
		(*printfn)("PC 0x%x: not in kernel text\n", pc);
		ra = 0;
		goto done;
	}

	/*
	 * Find the beginning of the current subroutine by scanning backwards
	 * from the current PC for the end of the previous subroutine.
	 */
	if (!subr) {
		va = pc - sizeof(int);
		while ((instr = kdbpeek(va)) != MIPS_JR_RA)
		va -= sizeof(int);
		va += 2 * sizeof(int);	/* skip back over branch & delay slot */
		/* skip over nulls which might separate .o files */
		while ((instr = kdbpeek(va)) == 0)
			va += sizeof(int);
		subr = va;
	}

	/*
	 * Jump here for locore entry pointsn for which the preceding
	 * function doesn't end in "j ra"
	 */
#if 0
stackscan:
#endif
	/* scan forwards to find stack size and any saved registers */
	stksize = 0;
	more = 3;
	mask = 0;
	for (va = subr; more; va += sizeof(int),
	     		      more = (more == 3) ? 3 : more - 1) {
		/* stop if hit our current position */
		if (va >= pc)
			break;
		instr = kdbpeek(va);
		i.word = instr;
		switch (i.JType.op) {
		case OP_SPECIAL:
			switch (i.RType.func) {
			case OP_JR:
			case OP_JALR:
				more = 2; /* stop after next instruction */
				break;

			case OP_SYSCALL:
			case OP_BREAK:
				more = 1; /* stop now */
			};
			break;

		case OP_BCOND:
		case OP_J:
		case OP_JAL:
		case OP_BEQ:
		case OP_BNE:
		case OP_BLEZ:
		case OP_BGTZ:
			more = 2; /* stop after next instruction */
			break;

		case OP_COP0:
		case OP_COP1:
		case OP_COP2:
		case OP_COP3:
			switch (i.RType.rs) {
			case OP_BCx:
			case OP_BCy:
				more = 2; /* stop after next instruction */
			};
			break;

		case OP_SW:
			/* look for saved registers on the stack */
			if (i.IType.rs != 29)
				break;
			/* only restore the first one */
			if (mask & (1 << i.IType.rt))
				break;
			mask |= (1 << i.IType.rt);
			switch (i.IType.rt) {
			case 4: /* a0 */
				a0 = kdbpeek(sp + (short)i.IType.imm);
				break;

			case 5: /* a1 */
				a1 = kdbpeek(sp + (short)i.IType.imm);
				break;

			case 6: /* a2 */
				a2 = kdbpeek(sp + (short)i.IType.imm);
				break;

			case 7: /* a3 */
				a3 = kdbpeek(sp + (short)i.IType.imm);
				break;

			case 30: /* fp */
				fp = kdbpeek(sp + (short)i.IType.imm);
				break;

			case 31: /* ra */
				ra = kdbpeek(sp + (short)i.IType.imm);
			}
			break;

		case OP_ADDI:
		case OP_ADDIU:
			/* look for stack pointer adjustment */
			if (i.IType.rs != 29 || i.IType.rt != 29)
				break;
			stksize = - ((short)i.IType.imm);
		}
	}

done:
	(*printfn)("%s+%x (%x,%x,%x,%x) ra %x sz %d\n",
		fn_name(subr), pc - subr, a0, a1, a2, a3, ra, stksize);

	if (ra) {
		if (pc == ra && stksize == 0)
			(*printfn)("stacktrace: loop!\n");
		else {
			pc = ra;
			sp += stksize;
			ra = 0;
			goto loop;
		}
	} else {
finish:
		if (curproc)
			(*printfn)("User-level: pid %d\n", curproc->p_pid);
		else
			(*printfn)("User-level: curproc NULL\n");
	}
}

/*
 * Functions ``special'' enough to print by name
 */
#ifdef __STDC__
#define Name(_fn)  { (void*)_fn, # _fn }
#else
#define Name(_fn) { _fn, "_fn"}
#endif
static struct { void *addr; char *name;} names[] = {
	Name(stacktrace),
	Name(stacktrace_subr),
	Name(main),
	Name(interrupt),
	Name(trap),
#ifdef pmax
	Name(am7990_meminit),
#endif

#ifdef MIPS1	/*  r2000 family  (mips-I cpu) */
	Name(mips1_KernGenException),
	Name(mips1_UserGenException),
	Name(mips1_KernIntr),
	Name(mips1_UserIntr),
#endif	/* MIPS1 */

#ifdef MIPS3		/* r4000 family (mips-III cpu) */
	Name(mips3_KernGenException),
	Name(mips3_UserGenException),
	Name(mips3_KernIntr),
	Name(mips3_UserIntr),
#endif	/* MIPS3 */

	Name(splx),
	Name(idle),
	Name(cpu_switch),
	{0, 0}
};

/*
 * Map a function address to a string name, if known; or a hex string.
 */
char *
fn_name(unsigned addr)
{
	static char buf[17];
	int i = 0;

	for (i = 0; names[i].name; i++)
		if (names[i].addr == (void*)addr)
			return (names[i].name);
	sprintf(buf, "%x", addr);
	return (buf);
}

#endif /* DEBUG */
@


1.24
log
@Get rid of CLSIZE and all related stuff.
CLSIZE -> 1
CLBYTES -> PAGE_SIZE
OLOFSET -> PAGE_MASK
etc.
At the same time some archs needed some cleaning in vmparam.h so that
goes in at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.23 2001/04/03 20:25:35 art Exp $	*/
@


1.23
log
@Fix a vm_pmap in a debug printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.22 2000/11/10 18:15:41 art Exp $	*/
d577 1
a577 1
				nss = clrnd(btoc(USRSTACK-(unsigned)va));
@


1.22
log
@Change the ktrace interface functions from taking the trace vnode to taking the
traced proc. The vnode is in the proc and all functions need the proc.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.21 2000/06/08 09:46:27 art Exp $	*/
d564 1
a564 1
		       map, &vm->vm_pmap, va, vadr, ftype, FALSE, rv, pc);
@


1.21
log
@&vm_pmap -> vm_map.pmap
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.20 1999/05/24 23:09:06 jason Exp $	*/
d661 1
a661 1
						ktrsyscall(p->p_tracep, code,
d696 1
a696 1
						ktrsyscall(p->p_tracep, code,
d728 1
a728 1
						ktrsyscall(p->p_tracep, code,
d741 1
a741 1
			ktrsyscall(p->p_tracep, code, callp->sy_argsize, args.i);
d804 1
a804 1
			ktrsysret(p->p_tracep, code, i, rval[0]); /*XXX*/
@


1.20
log
@Only do basic work in the ethernet interrupt context, and queue packets to
be bridged.  Do the real work in a scheduled netisr.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.19 1999/05/22 10:01:09 maja Exp $	*/
d479 1
a479 1
		pmap_t pmap = &p->p_vmspace->vm_pmap;
@


1.20.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.23 2001/04/03 20:25:35 art Exp $	*/
d479 1
a479 1
		pmap_t pmap = p->p_vmspace->vm_map.pmap;
d564 1
a564 1
		       map, vm->vm_map.pmap, va, vadr, ftype, FALSE, rv, pc);
d661 1
a661 1
						ktrsyscall(p, code,
d696 1
a696 1
						ktrsyscall(p, code,
d728 1
a728 1
						ktrsyscall(p, code,
d741 1
a741 1
			ktrsyscall(p, code, callp->sy_argsize, args.i);
d804 1
a804 1
			ktrsysret(p, code, i, rval[0]); /*XXX*/
@


1.20.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.20.4.1 2001/04/18 16:12:50 niklas Exp $	*/
@


1.19
log
@pr/796 applied fix from Urazmetov Wasilx <Wasilx@@forest.ihep.su> -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.18 1999/01/07 23:16:05 deraadt Exp $	*/
d83 1
d1086 6
@


1.18
log
@global decl for *intr() routines, plus add INET6
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.17 1998/10/15 21:30:17 imp Exp $	*/
d1459 1
a1459 1
void stacktrace_subr __P((int, int, int, int, void (*)(const char*, ...)));
d1481 1
a1481 1
	void (*printfn) __P((const char*, ...));
@


1.17
log
@
Back out PEFO's trap change.  It breaks everybody, it seems.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.14 1998/05/18 00:28:31 millert Exp $	*/
a81 7
/* all this to get prototypes for ipintr() and arpintr() */
#include <sys/socket.h>
#include <net/if.h>
#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <netinet/ip_var.h>

d1055 6
@


1.16
log
@Fix ERESTART bug introduced with trapframes
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.15 1998/09/15 10:53:55 pefo Exp $	*/
d68 1
a68 2
#include <machine/regnum.h>
#include <machine/frame.h>
d334 1
a334 1
u_int MachEmulateBranch __P((struct trap_frame *,
d348 2
a349 2
extern u_int trap __P((struct trap_frame *));
void child_return __P((struct proc *p));
d403 5
a407 2
trap(trapframe)
	struct trap_frame *trapframe;
d419 7
a425 7
	trp->status = trapframe->sr;
	trp->cause = trapframe->cause;
	trp->vadr = trapframe->badvaddr;
	trp->pc = trapframe->pc;
	trp->ra = !USERMODE(trapframe->sr) ? trapframe->pc :
		p->p_md.md_regs->ra;
	trp->sp = (int)trapframe;
d432 2
a433 2
	type = (trapframe->cause & MIPS1_CR_EXC_CODE) >> MIPS_CR_EXC_CODE_SHIFT;
	if (USERMODE(trapframe->sr)) {
d442 2
a443 2
	if (trapframe->sr & MIPS_SR_INT_ENA_PREV)
		splx((trapframe->sr & MIPS_HARD_INT_MASK) | MIPS_SR_INT_IE);
d448 1
a448 1
		if ((int)trapframe->badvaddr < 0) {
d453 1
a453 1
			pte = kvtopte(trapframe->badvaddr);
d459 1
a459 1
			if (PAGE_IS_RDONLY(entry, trapframe->badvaddr)) {
d466 2
a467 2
			trapframe->badvaddr &= ~PGOFSET;
			MachTLBUpdate(trapframe->badvaddr, entry);
d476 1
a476 1
			return (trapframe->pc);
d487 1
a487 1
		if (!(pte = pmap_segmap(pmap, trapframe->badvaddr)))
d489 1
a489 1
		pte += (trapframe->badvaddr >> PGSHIFT) & (NPTEPG - 1);
d496 1
a496 1
		if (PAGE_IS_RDONLY(entry, trapframe->badvaddr)) {
d503 1
a503 1
		trapframe->badvaddr = (trapframe->badvaddr & ~PGOFSET) |
d505 1
a505 1
		MachTLBUpdate(trapframe->badvaddr, entry);
d515 2
a516 2
		if (!USERMODE(trapframe->sr))
			return (trapframe->pc);
d524 1
a524 1
		if ((int)trapframe->badvaddr < 0) {
d530 1
a530 1
			va = trunc_page((vm_offset_t)trapframe->badvaddr);
d533 1
a533 1
				return (trapframe->pc);
d566 1
a566 1
		va = trunc_page((vm_offset_t)trapframe->badvaddr);
d570 1
a570 1
		       map, &vm->vm_pmap, va, trapframe->badvaddr, ftype, FALSE, rv, trapframe->pc);
d590 2
a591 2
			if (!USERMODE(trapframe->sr))
				return (trapframe->pc);
d594 1
a594 1
		if (!USERMODE(trapframe->sr)) {
d622 2
a623 2
		struct trap_frame *locr0 = p->p_md.md_regs;
		struct sysent *callp;
a624 1
		unsigned int tpc;
d633 2
a634 3
		tpc = trapframe->pc; /* Remember if restarted! */
		if ((int)trapframe->cause < 0)
			locr0->pc = MachEmulateBranch(locr0, trapframe->pc, 0, 0);
d636 1
a636 1
			locr0->pc += 4;
d639 1
a639 1
		code = locr0->v0;
d645 1
a645 1
			code = locr0->a0;
d651 3
a653 3
			args.i[0] = locr0->a1;
			args.i[1] = locr0->a2;
			args.i[2] = locr0->a3;
d655 1
a655 1
				i = copyin((caddr_t)(locr0->sp +
d660 2
a661 2
					locr0->v0 = i;
					locr0->a3 = 1;
d681 1
a681 6
			if(_QUAD_LOWWORD == 0) {
				code = locr0->a0;
			}
			else {
				code = locr0->a1;
			}
d687 2
a688 2
			args.i[0] = locr0->a2;
			args.i[1] = locr0->a3;
d690 1
a690 1
				i = copyin((caddr_t)(locr0->sp +
d695 2
a696 2
					locr0->v0 = i;
					locr0->a3 = 1;
d717 4
a720 4
			args.i[0] = locr0->a0;
			args.i[1] = locr0->a1;
			args.i[2] = locr0->a2;
			args.i[3] = locr0->a3;
d722 1
a722 1
				i = copyin((caddr_t)(locr0->sp +
d727 2
a728 2
					locr0->v0 = i;
					locr0->a3 = 1;
d750 1
a750 1
		rval[1] = locr0->v1;
d767 5
a771 5
		trp->status = trapframe->sr;
		trp->cause = trapframe->cause;
		trp->vadr = locr0->sp;
		trp->pc = locr0->pc;
		trp->ra = locr0->ra;
d781 3
a783 3
			locr0->v0 = rval[0];
			locr0->v1 = rval[1];
			locr0->a3 = 0;
d787 1
a787 1
			locr0->pc = tpc;
d794 2
a795 2
			locr0->v0 = i;
			locr0->a3 = 1;
d820 2
a821 2
		va = trapframe->pc;
		if ((int)trapframe->cause < 0)
d828 1
a828 1
			p->p_comm, p->p_pid, instr, trapframe->pc,
d873 1
a873 1
		if ((trapframe->cause & MIPS_CR_COP_ERR) != 0x10000000) {
d881 1
a881 1
		p->p_md.md_regs->sr |= MIPS_SR_COP_1_BIT;
d890 1
a890 1
			trapframe->pc, trapframe->cause, trapframe->sr);
d895 1
a895 1
		MachFPTrap(trapframe->sr, trapframe->cause, trapframe->pc);
d918 1
a918 1
		if (USERMODE(trapframe->sr))
d921 24
a944 24
			kdbpcb.pcb_regs->zero = 0;
			kdbpcb.pcb_regs->ast = ((int *)&args)[2];
			kdbpcb.pcb_regs->v0 = ((int *)&args)[3];
			kdbpcb.pcb_regs->v1 = ((int *)&args)[4];
			kdbpcb.pcb_regs->a0 = ((int *)&args)[5];
			kdbpcb.pcb_regs->a1 = ((int *)&args)[6];
			kdbpcb.pcb_regs->a2 = ((int *)&args)[7];
			kdbpcb.pcb_regs->a3 = ((int *)&args)[8];
			kdbpcb.pcb_regs->t0 = ((int *)&args)[9];
			kdbpcb.pcb_regs->t1 = ((int *)&args)[10];
			kdbpcb.pcb_regs->t2 = ((int *)&args)[11];
			kdbpcb.pcb_regs->t3 = ((int *)&args)[12];
			kdbpcb.pcb_regs->t4 = ((int *)&args)[13];
			kdbpcb.pcb_regs->t5 = ((int *)&args)[14];
			kdbpcb.pcb_regs->t6 = ((int *)&args)[15];
			kdbpcb.pcb_regs->t7 = ((int *)&args)[16];
			kdbpcb.pcb_regs->t8 = ((int *)&args)[17];
			kdbpcb.pcb_regs->t9 = ((int *)&args)[18];
			kdbpcb.pcb_regs->ra = ((int *)&args)[19];
			kdbpcb.pcb_regs->mullo = ((int *)&args)[21];
			kdbpcb.pcb_regs->mulhi = ((int *)&args)[22];
			kdbpcb.pcb_regs->pc = trapframe->pc;
			kdbpcb.pcb_regs->sr = trapframe->sr;
			bzero((caddr_t)&kdbpcb.pcb_regs->f0, 33 * sizeof(int));
d946 2
a947 2
		if (kdb(trapframe->cause, trapframe->badvaddr, p, !USERMODE(trapframe->sr)))
			return (kdbpcb.pcb_regs->pc);
d957 4
a960 4
	p->p_md.md_regs->pc = trapframe->pc;
	p->p_md.md_regs->cause = trapframe->cause;
	p->p_md.md_regs->badvaddr = trapframe->badvaddr;
	sv.sival_int = trapframe->badvaddr;
d997 1
a997 1
		addupc_task(p, trapframe->pc, (int)(p->p_sticks - sticks) * psratio);
d1001 1
a1001 54
	return (trapframe->pc);
}

void
child_return(p)
	struct proc *p;
{
	struct trap_frame *trapframe;
	int i;

	trapframe = p->p_md.md_regs;
	trapframe->v0 = 0;
	trapframe->v1 = 1;
	trapframe->a3 = 0;

	/* take pending signals */
	while ((i = CURSIG(p)) != 0)
		postsig(i);
	p->p_priority = p->p_usrpri;
	astpending = 0;
	if (want_resched) {
		int s;

		/*
		 * Since we are curproc, clock will normally just change
		 * our priority without moving us from one queue to another
		 * (since the running process is not on a queue.)
		 * If that happened after we put ourselves on the run queue
		 * but before we switched, we might not be on the queue
		 * indicated by our priority.
		 */
		s = splstatclock();
		setrunqueue(p);
		p->p_stats->p_ru.ru_nivcsw++;
		mi_switch();
		splx(s);
		while ((i = CURSIG(p)) != 0)
			postsig(i);
	}

#if 0 /* Need sticks */
	if (p->p_flag & P_PROFIL) {
		extern int psratio;

		addupc_task(p, trapframe->pc, (int)(p->p_sticks - sticks) * psratio);
	}
#endif

	curpriority = p->p_priority;

#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET))
		ktrsysret(p->p_tracep, SYS_fork, 0, 0);
#endif 
d1010 4
a1013 2
interrupt(trapframe)
	struct trap_frame *trapframe;
d1019 2
a1020 2
	trp->status = trapframe->sr;
	trp->cause = trapframe->cause;
d1022 1
a1022 1
	trp->pc = trapframe->pc;
d1031 1
a1031 1
	mask = trapframe->cause & trapframe->sr;	/* pending interrupts & enable mask */
d1033 1
a1033 1
		splx((*mips_hardware_intr)(mask, trapframe->pc, trapframe->sr, trapframe->cause));
d1036 1
a1036 1
		if (!USERMODE(trapframe->sr)) {
d1041 1
a1041 1
				trapframe->pc, trapframe->cause, trapframe->sr);
d1044 1
a1044 1
			MachFPInterrupt(trapframe->sr, trapframe->cause, trapframe->pc);
d1050 1
a1050 1
	    netisr && (trapframe->sr & MIPS_SOFT_INT_MASK_1)) {
d1194 2
a1195 2
MachEmulateBranch(frame, instPC, fpcCSR, allowNonBranch)
	struct trap_frame *frame;
a1202 1
	u_int *regsPtr = (u_int *)frame;
d1340 2
a1341 2
	unsigned va;
	struct trap_frame *locr0 = p->p_md.md_regs;
d1346 1
a1346 1
	va = MachEmulateBranch(locr0, locr0->pc, locr0[FSR], 1);
d1383 1
a1383 1
	uio.uio_offset = (off_t)locr0->pc;
d1392 1
a1392 1
		va = MachEmulateBranch(locr0, locr0->pc, locr0->fsr, curinstr);
d1395 1
a1395 1
		va = locr0->pc + 4;
d1438 1
a1438 1
		p->p_md.md_ss_instr, locr0->pc, fuword((caddr_t)va)); /* XXX */
d1460 1
a1460 1
void stacktrace_subr __P((int, int, int, int, int (*)(const char*, ...)));
d1482 1
a1482 1
	int (*printfn) __P((const char*, ...));
@


1.15
log
@Real trapframe and no more __FORK_BRAINDAMAGE
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.14 1998/05/18 00:28:31 millert Exp $	*/
d623 1
d632 1
d792 1
a792 1
			locr0->pc = trapframe->pc;
@


1.14
log
@new cpureg.h from NetBSD plus modifications to use the changed macro names
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.13 1998/05/09 21:29:58 millert Exp $	*/
d68 2
a69 1
#include <machine/reg.h>
d335 1
a335 1
u_int MachEmulateBranch __P((unsigned *regsPtr,
d349 2
a350 2
extern u_int trap __P((u_int status, u_int cause, u_int vaddr,  u_int pc,
			 int args));
d404 2
a405 5
trap(statusReg, causeReg, vadr, pc, args)
	unsigned statusReg;	/* status register at time of the exception */
	unsigned causeReg;	/* cause register at time of exception */
	unsigned vadr;		/* address (if any) the fault occured on */
	unsigned pc;		/* program counter where to continue */
d417 7
a423 7
	trp->status = statusReg;
	trp->cause = causeReg;
	trp->vadr = vadr;
	trp->pc = pc;
	trp->ra = !USERMODE(statusReg) ? ((int *)&args)[19] :
		p->p_md.md_regs[RA];
	trp->sp = (int)&args;
d430 2
a431 2
	type = (causeReg & MIPS1_CR_EXC_CODE) >> MIPS_CR_EXC_CODE_SHIFT;
	if (USERMODE(statusReg)) {
d440 2
a441 2
	if (statusReg & MIPS_SR_INT_ENA_PREV)
		splx((statusReg & MIPS_HARD_INT_MASK) | MIPS_SR_INT_IE);
d446 1
a446 1
		if ((int)vadr < 0) {
d451 1
a451 1
			pte = kvtopte(vadr);
d457 1
a457 1
			if (PAGE_IS_RDONLY(entry, vadr)) {
d464 2
a465 2
			vadr &= ~PGOFSET;
			MachTLBUpdate(vadr, entry);
d474 1
a474 1
			return (pc);
d485 1
a485 1
		if (!(pte = pmap_segmap(pmap, vadr)))
d487 1
a487 1
		pte += (vadr >> PGSHIFT) & (NPTEPG - 1);
d494 1
a494 1
		if (PAGE_IS_RDONLY(entry, vadr)) {
d501 1
a501 1
		vadr = (vadr & ~PGOFSET) |
d503 1
a503 1
		MachTLBUpdate(vadr, entry);
d513 2
a514 2
		if (!USERMODE(statusReg))
			return (pc);
d522 1
a522 1
		if ((int)vadr < 0) {
d528 1
a528 1
			va = trunc_page((vm_offset_t)vadr);
d531 1
a531 1
				return (pc);
d564 1
a564 1
		va = trunc_page((vm_offset_t)vadr);
d568 1
a568 1
		       map, &vm->vm_pmap, va, vadr, ftype, FALSE, rv, pc);
d588 2
a589 2
			if (!USERMODE(statusReg))
				return (pc);
d592 1
a592 1
		if (!USERMODE(statusReg)) {
d620 2
a621 2
		register int *locr0 = p->p_md.md_regs;
		register struct sysent *callp;
d631 2
a632 2
		if ((int)causeReg < 0)
			locr0[PC] = MachEmulateBranch(locr0, pc, 0, 0);
d634 1
a634 1
			locr0[PC] += 4;
d637 1
a637 1
		code = locr0[V0];
d643 1
a643 1
			code = locr0[A0];
d649 3
a651 3
			args.i[0] = locr0[A1];
			args.i[1] = locr0[A2];
			args.i[2] = locr0[A3];
d653 1
a653 1
				i = copyin((caddr_t)(locr0[SP] +
d658 2
a659 2
					locr0[V0] = i;
					locr0[A3] = 1;
d679 6
a684 1
			code = locr0[A0 + _QUAD_LOWWORD];
d690 2
a691 2
			args.i[0] = locr0[A2];
			args.i[1] = locr0[A3];
d693 1
a693 1
				i = copyin((caddr_t)(locr0[SP] +
d698 2
a699 2
					locr0[V0] = i;
					locr0[A3] = 1;
d720 4
a723 4
			args.i[0] = locr0[A0];
			args.i[1] = locr0[A1];
			args.i[2] = locr0[A2];
			args.i[3] = locr0[A3];
d725 1
a725 1
				i = copyin((caddr_t)(locr0[SP] +
d730 2
a731 2
					locr0[V0] = i;
					locr0[A3] = 1;
d753 1
a753 1
		rval[1] = locr0[V1];
d770 5
a774 5
		trp->status = statusReg;
		trp->cause = causeReg;
		trp->vadr = locr0[SP];
		trp->pc = locr0[PC];
		trp->ra = locr0[RA];
d784 3
a786 3
			locr0[V0] = rval[0];
			locr0[V1] = rval[1];
			locr0[A3] = 0;
d790 1
a790 1
			locr0[PC] = pc;
d797 2
a798 2
			locr0[V0] = i;
			locr0[A3] = 1;
d823 2
a824 2
		va = pc;
		if ((int)causeReg < 0)
d831 1
a831 1
			p->p_comm, p->p_pid, instr, pc,
d876 1
a876 1
		if ((causeReg & MIPS_CR_COP_ERR) != 0x10000000) {
d884 1
a884 1
		p->p_md.md_regs[PS] |= MIPS_SR_COP_1_BIT;
d893 1
a893 1
			pc, causeReg, statusReg);
d898 1
a898 1
		MachFPTrap(statusReg, causeReg, pc);
d921 1
a921 1
		if (USERMODE(statusReg))
d924 24
a947 24
			kdbpcb.pcb_regs[ZERO] = 0;
			kdbpcb.pcb_regs[AST] = ((int *)&args)[2];
			kdbpcb.pcb_regs[V0] = ((int *)&args)[3];
			kdbpcb.pcb_regs[V1] = ((int *)&args)[4];
			kdbpcb.pcb_regs[A0] = ((int *)&args)[5];
			kdbpcb.pcb_regs[A1] = ((int *)&args)[6];
			kdbpcb.pcb_regs[A2] = ((int *)&args)[7];
			kdbpcb.pcb_regs[A3] = ((int *)&args)[8];
			kdbpcb.pcb_regs[T0] = ((int *)&args)[9];
			kdbpcb.pcb_regs[T1] = ((int *)&args)[10];
			kdbpcb.pcb_regs[T2] = ((int *)&args)[11];
			kdbpcb.pcb_regs[T3] = ((int *)&args)[12];
			kdbpcb.pcb_regs[T4] = ((int *)&args)[13];
			kdbpcb.pcb_regs[T5] = ((int *)&args)[14];
			kdbpcb.pcb_regs[T6] = ((int *)&args)[15];
			kdbpcb.pcb_regs[T7] = ((int *)&args)[16];
			kdbpcb.pcb_regs[T8] = ((int *)&args)[17];
			kdbpcb.pcb_regs[T9] = ((int *)&args)[18];
			kdbpcb.pcb_regs[RA] = ((int *)&args)[19];
			kdbpcb.pcb_regs[MULLO] = ((int *)&args)[21];
			kdbpcb.pcb_regs[MULHI] = ((int *)&args)[22];
			kdbpcb.pcb_regs[PC] = pc;
			kdbpcb.pcb_regs[SR] = statusReg;
			bzero((caddr_t)&kdbpcb.pcb_regs[F0], 33 * sizeof(int));
d949 2
a950 2
		if (kdb(causeReg, vadr, p, !USERMODE(statusReg)))
			return (kdbpcb.pcb_regs[PC]);
d960 4
a963 4
	p->p_md.md_regs [PC] = pc;
	p->p_md.md_regs [CAUSE] = causeReg;
	p->p_md.md_regs [BADVADDR] = vadr;
	sv.sival_int = vadr;
d1000 1
a1000 1
		addupc_task(p, pc, (int)(p->p_sticks - sticks) * psratio);
d1004 54
a1057 1
	return (pc);
d1066 2
a1067 4
interrupt(statusReg, causeReg, pc /* XXX what, args */ )
	unsigned statusReg;	/* status register at time of the exception */
	unsigned causeReg;	/* cause register at time of exception */
	unsigned pc;		/* program counter where to continue */
d1073 2
a1074 2
	trp->status = statusReg;
	trp->cause = causeReg;
d1076 1
a1076 1
	trp->pc = pc;
d1085 1
a1085 1
	mask = causeReg & statusReg;	/* pending interrupts & enable mask */
d1087 1
a1087 1
		splx((*mips_hardware_intr)(mask, pc, statusReg, causeReg));
d1090 1
a1090 1
		if (!USERMODE(statusReg)) {
d1095 1
a1095 1
				pc, causeReg, statusReg);
d1098 1
a1098 1
			MachFPInterrupt(statusReg, causeReg, pc);
d1104 1
a1104 1
	    netisr && (statusReg & MIPS_SOFT_INT_MASK_1)) {
d1248 2
a1249 2
MachEmulateBranch(regsPtr, instPC, fpcCSR, allowNonBranch)
	unsigned *regsPtr;
d1257 1
d1395 2
a1396 2
	register unsigned va;
	register int *locr0 = p->p_md.md_regs;
d1401 1
a1401 1
	va = MachEmulateBranch(locr0, locr0[PC], locr0[FSR], 1);
d1438 1
a1438 1
	uio.uio_offset = (off_t)locr0[PC];
d1447 1
a1447 1
		va = MachEmulateBranch(locr0, locr0[PC], locr0[FSR], curinstr);
d1450 1
a1450 1
		va = locr0[PC] + 4;
d1493 1
a1493 1
		p->p_md.md_ss_instr, locr0[PC], fuword((caddr_t)va)); /* XXX */
d1515 1
a1515 1
void stacktrace_subr __P((int, int, int, int, void (*)(const char*, ...)));
d1537 1
a1537 1
	void (*printfn) __P((const char*, ...));
@


1.13
log
@#include <pmax/foo.h> -> #include <machine/foo.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.12 1998/03/05 21:18:19 maja Exp $	*/
d432 1
a432 1
	type = (causeReg & MIPS_3K_CR_EXC_CODE) >> MACH_CR_EXC_CODE_SHIFT;
d442 2
a443 2
	if (statusReg & MIPS_3K_SR_INT_ENA_PREV)
		splx((statusReg & MACH_HARD_INT_MASK) | MIPS_SR_INT_IE);
d504 1
a504 1
			(pmap->pm_tlbpid << VMMACH_TLB_PID_SHIFT);
d832 1
a832 1
		if (instr == MACH_BREAK_BRKPT || instr == MACH_BREAK_SSTEP)
d835 1
a835 1
		if (p->p_md.md_ss_addr != va || instr != MACH_BREAK_SSTEP) {
d873 1
a873 1
		if ((causeReg & MACH_CR_COP_ERR) != 0x10000000) {
d881 1
a881 1
		p->p_md.md_regs[PS] |= MACH_SR_COP_1_BIT;
d1034 1
a1034 1
	if (mask & MACH_INT_MASK_5) {
d1049 2
a1050 2
	if ((mask & MACH_SOFT_INT_MASK_1) ||
	    netisr && (statusReg & MACH_SOFT_INT_MASK_1)) {
d1090 1
a1090 1
	if (mask & MACH_SOFT_INT_MASK_0) {
d1161 2
a1162 2
			trap_type[(trp->cause & MIPS_3K_CR_EXC_CODE) >>
				MACH_CR_EXC_CODE_SHIFT],
d1204 1
a1204 1
	inst.word = (instPC < MACH_CACHED_MEMORY_ADDR) ?
d1303 1
a1303 1
				condition = fpcCSR & MACH_FPC_COND_BIT;
d1305 1
a1305 1
				condition = !(fpcCSR & MACH_FPC_COND_BIT);
d1355 1
a1355 1
	i = suiword((caddr_t)va, MACH_BREAK_SSTEP);
d1365 1
a1365 1
			i = suiword((caddr_t)va, MACH_BREAK_SSTEP);
d1371 1
a1371 1
	int bpinstr = MACH_BREAK_SSTEP;
@


1.12
log
@add OpenBSD tag
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d64 1
a64 1
#include <pmax/locore.h>
@


1.11
log
@please gcc 2.8
@
text
@d1 1
@


1.10
log
@Add AppleTalk netisr. Only tested (indeed, only compiled) on mac68k port.
Add options NETATALK to your config to try it out.
@
text
@d415 1
d959 2
a960 1
	trapsignal(p, i, ucode, typ, (caddr_t)vadr);
@


1.9
log
@go back to versions before the last NetBSD merge - it has broken
current kernels somehow - per or me has to look deeper at the diffs
@
text
@d1061 6
@


1.8
log
@update the pmax specific stuff to NetBSD-current as of about 970608 - some
cosmetic things will follow together with an update to an exact NETBSD_CU-
RRENT_xxxxxx level
@
text
@d1 1
a1 1
/*	$NetBSD: trap.c,v 1.55 1997/05/25 10:01:38 jonathan Exp $	*/
a348 2
extern void interrupt __P((u_int status, u_int cause, u_int pc));
extern void softintr __P((unsigned statusReg, unsigned pc));
d1047 1
a1047 1
	    (netisr && (statusReg & MACH_SOFT_INT_MASK_1))) {
d1328 1
a1328 1
mips_singlestep(p)
@


1.7
log
@bring siginfo stuff for the pmax in sync with the arc and add
BUFCACHEPERCENT for the pmax
@
text
@d1 1
a1 1
/*	$NetBSD: trap.c,v 1.50 1996/10/13 21:37:49 jonathan Exp $	*/
d349 2
d1049 1
a1049 1
	    netisr && (statusReg & MACH_SOFT_INT_MASK_1)) {
d1330 1
a1330 1
cpu_singlestep(p)
@


1.6
log
@SA_SIGINFO
@
text
@d414 1
a414 1
	int typ;
d599 1
a599 1
		ucode = vadr;
d607 1
d613 1
@


1.5
log
@update the pmax stuff to NetBSD 961107 - this version i got somehow
compiled on my decstation 2100 (PLUTO) - but it will not fully work
out of the box - but i want to bring it into the tree because i get
my own pmax on 961228 - so that i have a good startpoint then :-)

all the OpenBSD changes to the pmax tree will follow in the next commit
@
text
@d414 1
d601 1
d607 3
d613 1
d833 1
d859 1
d865 1
d871 1
d896 1
d956 1
a956 1
	trapsignal(p, i, ucode);
@


1.4
log
@sync to netbsd; for graichen
@
text
@d1 1
a1 1
/*	$NetBSD: trap.c,v 1.37.2.2 1996/09/09 20:39:56 thorpej Exp $	*/
d45 2
a46 2
#if #defined(CPU_R4000) && !defined(CPU_R3000)
#error Must define at least one of CPU_R3000 or CPU_R4000.
d63 2
d106 22
a127 14
extern void mips_r2000_KernGenException __P((void));
extern void mips_r2000_UserGenException __P((void));
extern void mips_r2000_KernIntr __P((void));
extern void mips_r2000_UserIntr __P((void));
extern void mips_r2000_TLBModException  __P((void));
extern void mips_r2000_TLBMissException __P((void));


extern void mips_r4000_KernGenException __P((void));
extern void mips_r4000_UserGenException __P((void));
extern void mips_r4000_KernIntr __P((void));
extern void mips_r4000_UserIntr __P((void));
extern void mips_r4000_TLBModException  __P((void));
extern void mips_r4000_TLBMissException __P((void));
d129 1
a129 1
void (*mips_r2000_ExceptionTable[]) __P((void)) = {
d133 32
a164 32
    mips_r2000_KernIntr,			/* 0 external interrupt */
    mips_r2000_KernGenException,		/* 1 TLB modification */
    mips_r2000_TLBMissException,		/* 2 TLB miss (load or instr. fetch) */
    mips_r2000_TLBMissException,		/* 3 TLB miss (store) */
    mips_r2000_KernGenException,		/* 4 address error (load or I-fetch) */
    mips_r2000_KernGenException,		/* 5 address error (store) */
    mips_r2000_KernGenException,		/* 6 bus error (I-fetch) */
    mips_r2000_KernGenException,		/* 7 bus error (load or store) */
    mips_r2000_KernGenException,		/* 8 system call */
    mips_r2000_KernGenException,		/* 9 breakpoint */
    mips_r2000_KernGenException,		/* 10 reserved instruction */
    mips_r2000_KernGenException,		/* 11 coprocessor unusable */
    mips_r2000_KernGenException,		/* 12 arithmetic overflow */
    mips_r2000_KernGenException,		/* 13 r4k trap excpt, r3k reserved */
    mips_r2000_KernGenException,		/* 14 r4k virt coherence, r3k reserved */
    mips_r2000_KernGenException,		/* 15 r4k FP exception, r3k reserved */
    mips_r2000_KernGenException,		/* 16 reserved */
    mips_r2000_KernGenException,		/* 17 reserved */
    mips_r2000_KernGenException,		/* 18 reserved */
    mips_r2000_KernGenException,		/* 19 reserved */
    mips_r2000_KernGenException,		/* 20 reserved */
    mips_r2000_KernGenException,		/* 21 reserved */
    mips_r2000_KernGenException,		/* 22 reserved */
    mips_r2000_KernGenException,		/* 23 watch exception */
    mips_r2000_KernGenException,		/* 24 reserved */
    mips_r2000_KernGenException,		/* 25 reserved */
    mips_r2000_KernGenException,		/* 26 reserved */
    mips_r2000_KernGenException,		/* 27 reserved */
    mips_r2000_KernGenException,		/* 28 reserved */
    mips_r2000_KernGenException,		/* 29 reserved */
    mips_r2000_KernGenException,		/* 30 reserved */
    mips_r2000_KernGenException,		/* 31 virt. coherence exception data */
d168 32
a199 32
    mips_r2000_UserIntr,		        /*  0 */
    mips_r2000_UserGenException,	        /*  1 */
    mips_r2000_UserGenException,	        /*  2 */
    mips_r2000_UserGenException,	        /*  3 */
    mips_r2000_UserGenException,	        /*  4 */
    mips_r2000_UserGenException,	        /*  5 */
    mips_r2000_UserGenException,	        /*  6 */
    mips_r2000_UserGenException,	        /*  7 */
    mips_r2000_UserGenException,	        /*  8 */
    mips_r2000_UserGenException,	        /*  9 */
    mips_r2000_UserGenException,	        /* 10 */
    mips_r2000_UserGenException,	        /* 11 */
    mips_r2000_UserGenException,	        /* 12 */
    mips_r2000_UserGenException,	        /* 13 */
    mips_r2000_UserGenException,	        /* 14 */
    mips_r2000_UserGenException,	        /* 15 */
    mips_r2000_UserGenException,		/* 16 */
    mips_r2000_UserGenException,		/* 17 */
    mips_r2000_UserGenException,		/* 18 */
    mips_r2000_UserGenException,		/* 19 */
    mips_r2000_UserGenException,		/* 20 */
    mips_r2000_UserGenException,		/* 21 */
    mips_r2000_UserGenException,		/* 22 */
    mips_r2000_UserGenException,		/* 23 */
    mips_r2000_UserGenException,		/* 24 */
    mips_r2000_UserGenException,		/* 25 */
    mips_r2000_UserGenException,		/* 26 */
    mips_r2000_UserGenException,		/* 27 */
    mips_r2000_UserGenException,		/* 28 */
    mips_r2000_UserGenException,		/* 29 */
    mips_r2000_UserGenException,		/* 20 */
    mips_r2000_UserGenException,		/* 31 */
d202 3
a204 1
void (*machExceptionTable[]) __P((void)) = {
d208 32
a239 32
    mips_r2000_KernIntr,			/* 0 external interrupt */
    mips_r2000_KernGenException,		/* 1 TLB modification */
    mips_r2000_TLBMissException,		/* 2 TLB miss (load or instr. fetch) */
    mips_r2000_TLBMissException,		/* 3 TLB miss (store) */
    mips_r2000_KernGenException,		/* 4 address error (load or I-fetch) */
    mips_r2000_KernGenException,		/* 5 address error (store) */
    mips_r2000_KernGenException,		/* 6 bus error (I-fetch) */
    mips_r2000_KernGenException,		/* 7 bus error (load or store) */
    mips_r2000_KernGenException,		/* 8 system call */
    mips_r2000_KernGenException,		/* 9 breakpoint */
    mips_r2000_KernGenException,		/* 10 reserved instruction */
    mips_r2000_KernGenException,		/* 11 coprocessor unusable */
    mips_r2000_KernGenException,		/* 12 arithmetic overflow */
    mips_r2000_KernGenException,		/* 13 r4k trap excpt, r3k reserved */
    mips_r2000_KernGenException,		/* 14 r4k virt coherence, r3k reserved */
    mips_r2000_KernGenException,		/* 15 r4k FP exception, r3k reserved */
    mips_r2000_KernGenException,		/* 16 reserved */
    mips_r2000_KernGenException,		/* 17 reserved */
    mips_r2000_KernGenException,		/* 18 reserved */
    mips_r2000_KernGenException,		/* 19 reserved */
    mips_r2000_KernGenException,		/* 20 reserved */
    mips_r2000_KernGenException,		/* 21 reserved */
    mips_r2000_KernGenException,		/* 22 reserved */
    mips_r2000_KernGenException,		/* 23 watch exception */
    mips_r2000_KernGenException,		/* 24 reserved */
    mips_r2000_KernGenException,		/* 25 reserved */
    mips_r2000_KernGenException,		/* 26 reserved */
    mips_r2000_KernGenException,		/* 27 reserved */
    mips_r2000_KernGenException,		/* 28 reserved */
    mips_r2000_KernGenException,		/* 29 reserved */
    mips_r2000_KernGenException,		/* 30 reserved */
    mips_r2000_KernGenException,		/* 31 virt. coherence exception data */
d243 32
a274 32
    mips_r2000_UserIntr,		        /*  0 */
    mips_r2000_UserGenException,	        /*  1 */
    mips_r2000_UserGenException,	        /*  2 */
    mips_r2000_UserGenException,	        /*  3 */
    mips_r2000_UserGenException,	        /*  4 */
    mips_r2000_UserGenException,	        /*  5 */
    mips_r2000_UserGenException,	        /*  6 */
    mips_r2000_UserGenException,	        /*  7 */
    mips_r2000_UserGenException,	        /*  8 */
    mips_r2000_UserGenException,	        /*  9 */
    mips_r2000_UserGenException,	        /* 10 */
    mips_r2000_UserGenException,	        /* 11 */
    mips_r2000_UserGenException,	        /* 12 */
    mips_r2000_UserGenException,	        /* 13 */
    mips_r2000_UserGenException,	        /* 14 */
    mips_r2000_UserGenException,	        /* 15 */
    mips_r2000_UserGenException,		/* 16 */
    mips_r2000_UserGenException,		/* 17 */
    mips_r2000_UserGenException,		/* 18 */
    mips_r2000_UserGenException,		/* 19 */
    mips_r2000_UserGenException,		/* 20 */
    mips_r2000_UserGenException,		/* 21 */
    mips_r2000_UserGenException,		/* 22 */
    mips_r2000_UserGenException,		/* 23 */
    mips_r2000_UserGenException,		/* 24 */
    mips_r2000_UserGenException,		/* 25 */
    mips_r2000_UserGenException,		/* 26 */
    mips_r2000_UserGenException,		/* 27 */
    mips_r2000_UserGenException,		/* 28 */
    mips_r2000_UserGenException,		/* 29 */
    mips_r2000_UserGenException,		/* 20 */
    mips_r2000_UserGenException,		/* 31 */
d276 2
d303 1
a303 1
	"r4k watch",
d311 1
a311 1
	"r4k virtual coherency data",
d456 1
a456 1
			if (entry & PG_RO) {
d465 1
a465 1
			pa = entry & PG_FRAME;
d493 1
a493 1
		if (entry & PG_RO) {
d503 1
a503 1
		pa = entry & PG_FRAME;
d599 1
a599 1
		i = (rv == KERN_PROTECTION_FAILURE) ? SIGBUS : SIGSEGV;
d607 1
a607 1
		i = SIGSEGV;
d787 7
d1073 1
a1073 1
 	}
d1155 13
a1181 4
#ifdef notyet	/*  Compute desination of r4000 squashed branches */
#define GetBranchDest(InstPtr, inst) \
	((unsigned)InstPtr + 4 + ((short)inst.IType.imm << 2))

d1184 1
a1184 1
#endif
a1307 6
static unsigned
GetBranchDest(InstPtr)
	InstFmt *InstPtr;
{
	return ((unsigned)InstPtr + 4 + ((short)InstPtr->IType.imm << 2));
}
d1509 3
a1511 3
	/* Backtraces should contine through interrupts from kernel mode */
#ifdef CPU_R3000
	if (pcBetween(mips_r2000_KernIntr, mips_r2000_UserIntr)) {
d1514 1
a1514 1
		       pc-(unsigned)mips_r2000_KernIntr, a0, a1, a2);
d1525 1
a1525 1
#endif	/* CPU_R3000 */
d1527 2
a1528 2
#ifdef CPU_R4000
	if (pcBetween(mips_r4000_KernIntr, mips_r4000_UserIntr) {
d1531 1
a1531 1
		       pc-(unsigned)mips_r4000_KernIntr, a0, a1, a2);
d1542 1
a1542 1
#endif	/* cpu_r4000 */
d1555 18
a1572 8
	if (pcBetween(mips_r2000_KernGenException, mips_r2000_UserGenException))
		subr = (unsigned) mips_r2000_KernGenException;
	else if (pcBetween(mips_r2000_UserGenException,mips_r2000_KernIntr))
		subr = (unsigned) mips_r2000_UserGenException;
	else if (pcBetween(mips_r2000_KernIntr, mips_r2000_UserIntr))
		subr = (unsigned) mips_r2000_KernIntr;
	else if (pcBetween(mips_r2000_UserIntr, mips_r2000_TLBMissException))
		subr = (unsigned) mips_r2000_UserIntr;
a1573 2
	else if (pcBetween(mips_r2000_UserIntr, mips_r2000_TLBMissException))
		subr = (unsigned) mips_r2000_UserIntr;
d1575 1
d1577 6
a1582 7
#ifdef CPU_R4000
	else if (pcBetween(mips_r4000_KernGenException, mips_r4000_UserGenException))
		subr = (unsigned) mips_r4000_KernGenException;
	else if (pcBetween(mips_r4000_UserGenException,mips_r4000_KernIntr))
		subr = (unsigned) mips_r4000_UserGenException;
	else if (pcBetween(mips_r4000_KernIntr, mips_r4000_UserIntr))
		subr = (unsigned) mips_r4000_KernIntr;
d1585 7
a1591 3
	else if (pcBetween(mips_r4000_UserIntr, mips_r4000_TLBMissException))
		subr = (unsigned) mips_r4000_UserIntr;
#endif /* CPU_R4000 */
d1594 1
a1594 1
	else if (pcBetween(splx, MachEmptyWriteBuffer))
a1602 4
	else if (pc >= (unsigned)MachUTLBMiss && pc < (unsigned)setsoftclock) {
		(*printfn)("<<locore>>");
		goto done;
	}
d1604 2
a1605 1
	/* check for bad PC */
d1767 14
a1780 13
#ifdef CPU_R3000
	Name(mips_r2000_KernGenException),
	Name(mips_r2000_UserGenException),
	Name(mips_r2000_KernIntr),
	Name(mips_r2000_UserIntr),
#endif	/* CPU_R3000 */

#ifdef CPU_R4000
	Name(mips_r4000_KernGenException),
	Name(mips_r4000_UserGenException),
	Name(mips_r4000_KernIntr),
	Name(mips_r4000_UserIntr),
#endif	/* CPU_R4000 */
@


1.3
log
@SIGBUS is an alignment fault. SIGSEGV is an access violation
@
text
@d1 1
a1 1
/*	$NetBSD: trap.c,v 1.24 1995/12/28 16:22:41 jonathan Exp $	*/
d45 4
d67 1
a74 16
#include <pmax/pmax/clockreg.h>
#include <pmax/pmax/kn01.h>
#include <pmax/pmax/kn02.h>
#include <pmax/pmax/kmin.h>
#include <pmax/pmax/maxine.h>
#include <pmax/pmax/kn03.h>
#include <pmax/pmax/asic.h>
#include <pmax/pmax/turbochannel.h>

#include <pmax/stand/dec_prom.h>

#include <asc.h>
#include <sii.h>
#include <le.h>
#include <dc.h>

d77 1
d79 8
a86 1
#include <pmax/pmax/trap.h>
d91 8
a100 4
extern void MachKernGenException __P((void));
extern void MachUserGenException __P((void));
extern void MachKernIntr __P((void));
extern void MachUserIntr __P((void));
d104 88
d196 32
a227 16
	MachKernIntr,			/* external interrupt */
	MachKernGenException,		/* TLB modification */
	MachTLBMissException,		/* TLB miss (load or instr. fetch) */
	MachTLBMissException,		/* TLB miss (store) */
	MachKernGenException,		/* address error (load or I-fetch) */
	MachKernGenException,		/* address error (store) */
	MachKernGenException,		/* bus error (I-fetch) */
	MachKernGenException,		/* bus error (load or store) */
	MachKernGenException,		/* system call */
	MachKernGenException,		/* breakpoint */
	MachKernGenException,		/* reserved instruction */
	MachKernGenException,		/* coprocessor unusable */
	MachKernGenException,		/* arithmetic overflow */
	MachKernGenException,		/* reserved */
	MachKernGenException,		/* reserved */
	MachKernGenException,		/* reserved */
d231 32
a262 16
	MachUserIntr,
	MachUserGenException,
	MachUserGenException,
	MachUserGenException,
	MachUserGenException,
	MachUserGenException,
	MachUserGenException,
	MachUserGenException,
	MachUserGenException,
	MachUserGenException,
	MachUserGenException,
	MachUserGenException,
	MachUserGenException,
	MachUserGenException,
	MachUserGenException,
	MachUserGenException,
d279 19
a297 3
	"reserved 13",
	"reserved 14",
	"reserved 15",
d308 1
d316 7
d328 1
a328 1
extern void splx __P((int));
a329 1
extern void MachTLBUpdate __P((u_int, u_int));
d347 1
d351 4
a354 7

static void pmax_errintr __P((void));
static void kn02_errintr __P((void)), kn02ba_errintr __P((void));

#ifdef DS5000_240
static void kn03_errintr __P ((void));
extern u_long kn03_tc3_imask;
d357 1
a357 2
 * IOASIC 40ns bus-cycle counter, used as hi-resolution clock:
 * may also be present on (some) XINE, 3min hardware, but not tested there.
d359 19
a377 11
extern u_long asic_base;	/* Base address of I/O asic */
u_long latched_cycle_cnt;	/*
				 * IOASIC cycle counter, latched on every
				 * interrupt from RTC chip (64Hz).
				 */
#endif /*DS5000_240*/

static unsigned kn02ba_recover_erradr __P((u_int phys, u_int mer));
extern tc_option_t tc_slot_info[TC_MAX_LOGICAL_SLOTS];
extern u_long kmin_tc3_imask, xine_tc3_imask;
extern const struct callback *callv;
a378 8
int (*pmax_hardware_intr) __P((u_int mask, u_int pc, u_int status,
			       u_int cause)) =
	( int (*) __P((u_int, u_int, u_int, u_int)) ) 0;

extern volatile struct chiptime *Mach_clock_addr;
extern u_long intrcnt[];
extern u_long kernelfaults;
u_long kernelfaults = 0;
d408 1
d415 1
a415 1
	type = (causeReg & MACH_CR_EXC_CODE) >> MACH_CR_EXC_CODE_SHIFT;
d425 2
a426 2
	if (statusReg & MACH_SR_INT_ENA_PREV)
		splx((statusReg & MACH_HARD_INT_MASK) | MACH_SR_INT_ENA_CUR);
d475 1
a475 1
		if (!(entry & PG_V) || (entry & PG_M))
d477 1
d493 1
a493 1
		if (!IS_VM_PHYSADDR(pa))
d495 1
d517 1
a517 1
			if (i = ((struct pcb *)UADDR)->pcb_onfault) {
d578 1
a578 1
			if (i = ((struct pcb *)UADDR)->pcb_onfault) {
d585 1
a585 1
		i = SIGSEGV;
d593 1
a593 1
		i = SIGBUS;
d748 1
d779 1
a779 1
			ktrsysret(p->p_tracep, code, i, rval);
d850 13
d870 1
a870 1
		if (i = ((struct pcb *)UADDR)->pcb_onfault) {
d973 1
a973 1
interrupt(statusReg, causeReg, pc)
d979 1
a979 1
	struct clockframe cf;
d987 1
d995 2
a996 2
	if (pmax_hardware_intr)
		splx((*pmax_hardware_intr)(mask, pc, statusReg, causeReg));
d998 1
a998 1
		intrcnt[7]++;
d1011 1
d1016 1
a1016 1
		intrcnt[1]++;
a1038 1
#include "ppp.h"
d1049 1
a1049 1
		intrcnt[0]++;
d1052 1
a1052 56
  	}
}

/*
 * Handle pmax (DECstation 2100/3100) interrupts.
 */
int
kn01_intr(mask, pc, statusReg, causeReg)
	unsigned mask;
	unsigned pc;
	unsigned statusReg;
	unsigned causeReg;
{
	register volatile struct chiptime *c = Mach_clock_addr;
	struct clockframe cf;
	int temp;
	extern struct cfdriver siicd;
	extern struct cfdriver lecd;

	/* handle clock interrupts ASAP */
	if (mask & MACH_INT_MASK_3) {
		intrcnt[6]++;
		temp = c->regc;	/* XXX clear interrupt bits */
		cf.pc = pc;
		cf.sr = statusReg;
		hardclock(&cf);

		/* keep clock interrupts enabled */
		causeReg &= ~MACH_INT_MASK_3;
	}
	/* Re-enable clock interrupts */
	splx(MACH_INT_MASK_3 | MACH_SR_INT_ENA_CUR);
#if NSII > 0
	if (mask & MACH_INT_MASK_0) {
		intrcnt[2]++;
		siiintr(siicd.cd_devs[0]);
	}
#endif
#if NLE > 0
	if (mask & MACH_INT_MASK_1) {
		intrcnt[3]++;
		leintr(lecd.cd_devs[0]);
	}
#endif
#if NDC > 0
	if (mask & MACH_INT_MASK_2) {
		intrcnt[4]++;
		dcintr(0);
	}
#endif
	if (mask & MACH_INT_MASK_4) {
		intrcnt[5]++;
		pmax_errintr();
	}
	return ((statusReg & ~causeReg & MACH_HARD_INT_MASK) |
		MACH_SR_INT_ENA_CUR);
a1054 436
/*
 * Handle hardware interrupts for the KN02. (DECstation 5000/200)
 * Returns spl value.
 */
int
kn02_intr(mask, pc, statusReg, causeReg)
	unsigned mask;
	unsigned pc;
	unsigned statusReg;
	unsigned causeReg;
{
	register unsigned i, m;
	register volatile struct chiptime *c = Mach_clock_addr;
	register unsigned csr;
	int temp;
	struct clockframe cf;
	static int warned = 0;

	/* handle clock interrupts ASAP */
	if (mask & MACH_INT_MASK_1) {
		csr = *(unsigned *)MACH_PHYS_TO_UNCACHED(KN02_SYS_CSR);
		if ((csr & KN02_CSR_PSWARN) && !warned) {
			warned = 1;
			printf("WARNING: power supply is overheating!\n");
		} else if (warned && !(csr & KN02_CSR_PSWARN)) {
			warned = 0;
			printf("WARNING: power supply is OK again\n");
		}
		intrcnt[6]++;

		temp = c->regc;	/* XXX clear interrupt bits */
		cf.pc = pc;
		cf.sr = statusReg;
		hardclock(&cf);

		/* keep clock interrupts enabled */
		causeReg &= ~MACH_INT_MASK_1;
	}
	/* Re-enable clock interrupts */
	splx(MACH_INT_MASK_1 | MACH_SR_INT_ENA_CUR);
	if (mask & MACH_INT_MASK_0) {
		static int intr_map[8] = { 8, 9, 10, 11, 12, 4, 3, 2 };

		csr = *(unsigned *)MACH_PHYS_TO_UNCACHED(KN02_SYS_CSR);
		m = csr & (csr >> KN02_CSR_IOINTEN_SHIFT) & KN02_CSR_IOINT;
#if 0
		*(unsigned *)MACH_PHYS_TO_UNCACHED(KN02_SYS_CSR) =
			(csr & ~(KN02_CSR_WRESERVED | 0xFF)) |
			(m << KN02_CSR_IOINTEN_SHIFT);
#endif
		for (i = 0; m; i++, m >>= 1) {
			if (!(m & 1))
				continue;
			intrcnt[intr_map[i]]++;
			if (tc_slot_info[i].intr)
				(*tc_slot_info[i].intr)(tc_slot_info[i].sc);
			else
				printf("spurious interrupt %d\n", i);
		}
#if 0
		*(unsigned *)MACH_PHYS_TO_UNCACHED(KN02_SYS_CSR) =
			csr & ~(KN02_CSR_WRESERVED | 0xFF);
#endif
	}
	if (mask & MACH_INT_MASK_3) {
		intrcnt[5]++;
		kn02_errintr();
	}

	return ((statusReg & ~causeReg & MACH_HARD_INT_MASK) |
		MACH_SR_INT_ENA_CUR);
}

/*
 * 3min hardware interrupts. (DECstation 5000/1xx)
 */
int
kmin_intr(mask, pc, statusReg, causeReg)
	unsigned mask;
	unsigned pc;
	unsigned statusReg;
	unsigned causeReg;
{
	register u_int intr;
	register volatile struct chiptime *c = Mach_clock_addr;
	volatile u_int *imaskp =
		(volatile u_int *)MACH_PHYS_TO_UNCACHED(KMIN_REG_IMSK);
	volatile u_int *intrp =
		(volatile u_int *)MACH_PHYS_TO_UNCACHED(KMIN_REG_INTR);
	unsigned int old_mask;
	struct clockframe cf;
	int temp;
	static int user_warned = 0;

	old_mask = *imaskp & kmin_tc3_imask;
	*imaskp = kmin_tc3_imask |
		 (KMIN_IM0 & ~(KN03_INTR_TC_0|KN03_INTR_TC_1|KN03_INTR_TC_2));

	if (mask & MACH_INT_MASK_4)
		(*callv->_halt)((int *)0, 0);
	if (mask & MACH_INT_MASK_3) {
		intr = *intrp;

		/* masked interrupts are still observable */
		intr &= old_mask;
	
		if (intr & KMIN_INTR_SCSI_PTR_LOAD) {
			*intrp &= ~KMIN_INTR_SCSI_PTR_LOAD;
#ifdef notdef
			asc_dma_intr();
#endif
		}
	
		if (intr & (KMIN_INTR_SCSI_OVRUN | KMIN_INTR_SCSI_READ_E))
			*intrp &= ~(KMIN_INTR_SCSI_OVRUN | KMIN_INTR_SCSI_READ_E);

		if (intr & KMIN_INTR_LANCE_READ_E)
			*intrp &= ~KMIN_INTR_LANCE_READ_E;

		if (intr & KMIN_INTR_TIMEOUT)
			kn02ba_errintr();
	
		if (intr & KMIN_INTR_CLOCK) {
			temp = c->regc;	/* XXX clear interrupt bits */
			cf.pc = pc;
			cf.sr = statusReg;
			hardclock(&cf);
		}
	
		if ((intr & KMIN_INTR_SCC_0) &&
			tc_slot_info[KMIN_SCC0_SLOT].intr)
			(*(tc_slot_info[KMIN_SCC0_SLOT].intr))
			(tc_slot_info[KMIN_SCC0_SLOT].sc);
	
		if ((intr & KMIN_INTR_SCC_1) &&
			tc_slot_info[KMIN_SCC1_SLOT].intr)
			(*(tc_slot_info[KMIN_SCC1_SLOT].intr))
			(tc_slot_info[KMIN_SCC1_SLOT].sc);
	
		if ((intr & KMIN_INTR_SCSI) &&
			tc_slot_info[KMIN_SCSI_SLOT].intr)
			(*(tc_slot_info[KMIN_SCSI_SLOT].intr))
			(tc_slot_info[KMIN_SCSI_SLOT].sc);
	
		if ((intr & KMIN_INTR_LANCE) &&
			tc_slot_info[KMIN_LANCE_SLOT].intr)
			(*(tc_slot_info[KMIN_LANCE_SLOT].intr))
			(tc_slot_info[KMIN_LANCE_SLOT].sc);
	
		if (user_warned && ((intr & KMIN_INTR_PSWARN) == 0)) {
			printf("%s\n", "Power supply ok now.");
			user_warned = 0;
		}
		if ((intr & KMIN_INTR_PSWARN) && (user_warned < 3)) {
			user_warned++;
			printf("%s\n", "Power supply overheating");
		}
	}
	if ((mask & MACH_INT_MASK_0) && tc_slot_info[0].intr)
		(*tc_slot_info[0].intr)(tc_slot_info[0].sc);
	if ((mask & MACH_INT_MASK_1) && tc_slot_info[1].intr)
		(*tc_slot_info[1].intr)(tc_slot_info[1].sc);
	if ((mask & MACH_INT_MASK_2) && tc_slot_info[2].intr)
		(*tc_slot_info[2].intr)(tc_slot_info[2].sc);

#if 0 /*XXX*/
	if (mask & (MACH_INT_MASK_2|MACH_INT_MASK_1|MACH_INT_MASK_0))
		printf("kmin: slot intr, mask 0x%x\n",
			mask &
			(MACH_INT_MASK_2|MACH_INT_MASK_1|MACH_INT_MASK_0));
#endif
	
	return ((statusReg & ~causeReg & MACH_HARD_INT_MASK) |
		MACH_SR_INT_ENA_CUR);
}

/*
 * Maxine hardware interrupts. (Personal DECstation 5000/xx)
 */
int
xine_intr(mask, pc, statusReg, causeReg)
	unsigned mask;
	unsigned pc;
	unsigned statusReg;
	unsigned causeReg;
{
	register u_int intr;
	register volatile struct chiptime *c = Mach_clock_addr;
	volatile u_int *imaskp = (volatile u_int *)
		MACH_PHYS_TO_UNCACHED(XINE_REG_IMSK);
	volatile u_int *intrp = (volatile u_int *)
		MACH_PHYS_TO_UNCACHED(XINE_REG_INTR);
	u_int old_mask;
	struct clockframe cf;
	int temp;

	old_mask = *imaskp & xine_tc3_imask;
	*imaskp = xine_tc3_imask;

	if (mask & MACH_INT_MASK_4)
		(*callv->_halt)((int *)0, 0);

	/* handle clock interrupts ASAP */
	if (mask & MACH_INT_MASK_1) {
		temp = c->regc;	/* XXX clear interrupt bits */
		cf.pc = pc;
		cf.sr = statusReg;
		hardclock(&cf);
		causeReg &= ~MACH_INT_MASK_1;
		/* reenable clock interrupts */
		splx(MACH_INT_MASK_1 | MACH_SR_INT_ENA_CUR);
	}
	if (mask & MACH_INT_MASK_3) {
		intr = *intrp;
		/* masked interrupts are still observable */
		intr &= old_mask;

		if ((intr & XINE_INTR_SCC_0)) {
			if (tc_slot_info[XINE_SCC0_SLOT].intr)
				(*(tc_slot_info[XINE_SCC0_SLOT].intr))
				(tc_slot_info[XINE_SCC0_SLOT].sc);
			else
				printf ("can't handle scc interrupt\n");
		}
	
		if (intr & XINE_INTR_SCSI_PTR_LOAD) {
			*intrp &= ~XINE_INTR_SCSI_PTR_LOAD;
#ifdef notdef
			asc_dma_intr();
#endif
		}
	
		if (intr & (XINE_INTR_SCSI_OVRUN | XINE_INTR_SCSI_READ_E))
			*intrp &= ~(XINE_INTR_SCSI_OVRUN | XINE_INTR_SCSI_READ_E);

		if (intr & XINE_INTR_LANCE_READ_E)
			*intrp &= ~XINE_INTR_LANCE_READ_E;

		if (intr & XINE_INTR_DTOP_RX) {
			if (tc_slot_info[XINE_DTOP_SLOT].intr)
				(*(tc_slot_info[XINE_DTOP_SLOT].intr))
				(tc_slot_info[XINE_DTOP_SLOT].sc);
			else
				printf ("can't handle dtop interrupt\n");
		}
	
		if (intr & XINE_INTR_FLOPPY) {
			if (tc_slot_info[XINE_FLOPPY_SLOT].intr)
				(*(tc_slot_info[XINE_FLOPPY_SLOT].intr))
				(tc_slot_info[XINE_FLOPPY_SLOT].sc);
		else
			printf ("can't handle floppy interrupt\n");
		}
	
		if (intr & XINE_INTR_TC_0) {
			if (tc_slot_info[0].intr)
				(*(tc_slot_info[0].intr))
				(tc_slot_info[0].sc);
			else
				printf ("can't handle tc0 interrupt\n");
		}
	
		if (intr & XINE_INTR_TC_1) {
			if (tc_slot_info[1].intr)
				(*(tc_slot_info[1].intr))
				(tc_slot_info[1].sc);
			else
				printf ("can't handle tc1 interrupt\n");
		}
	
		if (intr & XINE_INTR_ISDN) {
			if (tc_slot_info[XINE_ISDN_SLOT].intr)
				(*(tc_slot_info[XINE_ISDN_SLOT].intr))
				(tc_slot_info[XINE_ISDN_SLOT].sc);
			else
				printf ("can't handle isdn interrupt\n");
		}
	
		if (intr & XINE_INTR_SCSI) {
			if (tc_slot_info[XINE_SCSI_SLOT].intr)
				(*(tc_slot_info[XINE_SCSI_SLOT].intr))
				(tc_slot_info[XINE_SCSI_SLOT].sc);
			else
				printf ("can't handle scsi interrupt\n");
		}
	
		if (intr & XINE_INTR_LANCE) {
			if (tc_slot_info[XINE_LANCE_SLOT].intr)
				(*(tc_slot_info[XINE_LANCE_SLOT].intr))
				(tc_slot_info[XINE_LANCE_SLOT].sc);
			else
				printf ("can't handle lance interrupt\n");
	
		}
	}
	if (mask & MACH_INT_MASK_2)
		kn02ba_errintr();
	return ((statusReg & ~causeReg & MACH_HARD_INT_MASK) |
		MACH_SR_INT_ENA_CUR);
}

#ifdef DS5000_240
/*
 * 3Max+ hardware interrupts. (DECstation 5000/240) UNTESTED!!
 */
int
kn03_intr(mask, pc, statusReg, causeReg)
	unsigned mask;
	unsigned pc;
	unsigned statusReg;
	unsigned causeReg;
{
	register u_int intr;
	register volatile struct chiptime *c = Mach_clock_addr;
	volatile u_int *imaskp = (volatile u_int *)
		MACH_PHYS_TO_UNCACHED(KN03_REG_IMSK);
	volatile u_int *intrp = (volatile u_int *)
		MACH_PHYS_TO_UNCACHED(KN03_REG_INTR);
	u_int old_mask;
	struct clockframe cf;
	int temp;
	static int user_warned = 0;

	old_mask = *imaskp & kn03_tc3_imask;
	*imaskp = kn03_tc3_imask;

	if (mask & MACH_INT_MASK_4)
		(*callv->_halt)((int *)0, 0);

	/* handle clock interrupts ASAP */
	if (mask & MACH_INT_MASK_1) {
		temp = c->regc;	/* XXX clear interrupt bits */
		cf.pc = pc;
		cf.sr = statusReg;
		intrcnt[6]++;
		hardclock(&cf);
		latched_cycle_cnt = *(u_long*)(ASIC_REG_CTR(asic_base));
		causeReg &= ~MACH_INT_MASK_1;
		/* reenable clock interrupts */
		splx(MACH_INT_MASK_1 | MACH_SR_INT_ENA_CUR);
	}

	if (mask & MACH_INT_MASK_0) {
		intr = *intrp;
		/* masked interrupts are still observable */
		intr &= old_mask;

		if (intr & KN03_INTR_SCSI_PTR_LOAD) {
			*intrp &= ~KN03_INTR_SCSI_PTR_LOAD;
#ifdef notdef
			asc_dma_intr();
#endif
		}
	
		if (intr & (KN03_INTR_SCSI_OVRUN | KN03_INTR_SCSI_READ_E))
			*intrp &= ~(KN03_INTR_SCSI_OVRUN | KN03_INTR_SCSI_READ_E);

		if (intr & KN03_INTR_LANCE_READ_E)
			*intrp &= ~KN03_INTR_LANCE_READ_E;

		if ((intr & KN03_INTR_SCC_0) &&
			tc_slot_info[KN03_SCC0_SLOT].intr) {
			(*(tc_slot_info[KN03_SCC0_SLOT].intr))
			(tc_slot_info[KN03_SCC0_SLOT].sc);
			intrcnt[2]++;
		}
	
		if ((intr & KN03_INTR_SCC_1) &&
			tc_slot_info[KN03_SCC1_SLOT].intr) {
			(*(tc_slot_info[KN03_SCC1_SLOT].intr))
			(tc_slot_info[KN03_SCC1_SLOT].sc);
			intrcnt[2]++;
		}
	
		if ((intr & KN03_INTR_TC_0) &&
			tc_slot_info[0].intr) {
			(*(tc_slot_info[0].intr))
			(tc_slot_info[0].sc);
			intrcnt[8]++;
		}
#ifdef DIAGNOSTIC
		else if (intr & KN03_INTR_TC_0)
			printf ("can't handle tc0 interrupt\n");
#endif /*DIAGNOSTIC*/

		if ((intr & KN03_INTR_TC_1) &&
			tc_slot_info[1].intr) {
			(*(tc_slot_info[1].intr))
			(tc_slot_info[1].sc);
			intrcnt[9]++;
		}
#ifdef DIAGNOSTIC
		else if (intr & KN03_INTR_TC_1)
			printf ("can't handle tc1 interrupt\n");
#endif /*DIAGNOSTIC*/

		if ((intr & KN03_INTR_TC_2) &&
			tc_slot_info[2].intr) {
			(*(tc_slot_info[2].intr))
			(tc_slot_info[2].sc);
			intrcnt[10]++;
		}
#ifdef DIAGNOSTIC
		else if (intr & KN03_INTR_TC_2)
			printf ("can't handle tc2 interrupt\n");
#endif /*DIAGNOSTIC*/
	
		if ((intr & KN03_INTR_SCSI) &&
			tc_slot_info[KN03_SCSI_SLOT].intr) {
			(*(tc_slot_info[KN03_SCSI_SLOT].intr))
			(tc_slot_info[KN03_SCSI_SLOT].sc);
			intrcnt[4]++;
		}
	
		if ((intr & KN03_INTR_LANCE) &&
			tc_slot_info[KN03_LANCE_SLOT].intr) {
			(*(tc_slot_info[KN03_LANCE_SLOT].intr))
			(tc_slot_info[KN03_LANCE_SLOT].sc);
			intrcnt[3]++;
		}
	
		if (user_warned && ((intr & KN03_INTR_PSWARN) == 0)) {
			printf("%s\n", "Power supply ok now.");
			user_warned = 0;
		}
		if ((intr & KN03_INTR_PSWARN) && (user_warned < 3)) {
			user_warned++;
			printf("%s\n", "Power supply overheating");
		}
	}
	if (mask & MACH_INT_MASK_3)
		kn03_errintr();
	return ((statusReg & ~causeReg & MACH_HARD_INT_MASK) |
		MACH_SR_INT_ENA_CUR);
}
#endif /* DS5000_240 */
d1118 1
a1118 1
			trap_type[(trp->cause & MACH_CR_EXC_CODE) >>
d1121 1
a1121 1
		printf("   RA %x code %d\n", trp-> ra, trp->code);
a1129 129
 *----------------------------------------------------------------------
 *
 * MemErrorInterrupts --
 *   pmax_errintr - for the DS2100/DS3100
 *   kn02_errintr - for the DS5000/200
 *   kn02ba_errintr - for the DS5000/1xx and DS5000/xx
 *
 *	Handler an interrupt for the control register.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
static void
pmax_errintr()
{
	volatile u_short *sysCSRPtr =
		(u_short *)MACH_PHYS_TO_UNCACHED(KN01_SYS_CSR);
	u_short csr;

	csr = *sysCSRPtr;

	if (csr & KN01_CSR_MERR) {
		printf("Memory error at 0x%x\n",
			*(unsigned *)MACH_PHYS_TO_UNCACHED(KN01_SYS_ERRADR));
		panic("Mem error interrupt");
	}
	*sysCSRPtr = (csr & ~KN01_CSR_MBZ) | 0xff;
}

static void
kn02_errintr()
{
	u_int erradr, chksyn, physadr;
	int i;

	erradr = *(u_int *)MACH_PHYS_TO_UNCACHED(KN02_SYS_ERRADR);
	chksyn = *(u_int *)MACH_PHYS_TO_UNCACHED(KN02_SYS_CHKSYN);
	*(u_int *)MACH_PHYS_TO_UNCACHED(KN02_SYS_ERRADR) = 0;
	MachEmptyWriteBuffer();

	if (!(erradr & KN02_ERR_VALID))
		return;
	/* extract the physical word address and compensate for pipelining */
	physadr = erradr & KN02_ERR_ADDRESS;
	if (!(erradr & KN02_ERR_WRITE))
		physadr = (physadr & ~0xfff) | ((physadr & 0xfff) - 5);
	physadr <<= 2;
	printf("%s memory %s %s error at 0x%x\n",
		(erradr & KN02_ERR_CPU) ? "CPU" : "DMA",
		(erradr & KN02_ERR_WRITE) ? "write" : "read",
		(erradr & KN02_ERR_ECCERR) ? "ECC" : "timeout",
		physadr);
	if (erradr & KN02_ERR_ECCERR) {
		*(u_int *)MACH_PHYS_TO_UNCACHED(KN02_SYS_CHKSYN) = 0;
		MachEmptyWriteBuffer();
		printf("ECC 0x%x\n", chksyn);

		/* check for a corrected, single bit, read error */
		if (!(erradr & KN02_ERR_WRITE)) {
			if (physadr & 0x4) {
				/* check high word */
				if (chksyn & KN02_ECC_SNGHI)
					return;
			} else {
				/* check low word */
				if (chksyn & KN02_ECC_SNGLO)
					return;
			}
		}
	}
	panic("Mem error interrupt");
}

#ifdef DS5000_240
static void
kn03_errintr()
{

	printf("erradr %x\n", *(unsigned *)MACH_PHYS_TO_UNCACHED(KN03_SYS_ERRADR));
	*(unsigned *)MACH_PHYS_TO_UNCACHED(KN03_SYS_ERRADR) = 0;
	MachEmptyWriteBuffer();
}
#endif /* DS5000_240 */

static void
kn02ba_errintr()
{
	register int mer, adr, siz;
	static int errintr_cnt = 0;

	siz = *(volatile int *)MACH_PHYS_TO_UNCACHED(KMIN_REG_MSR);
	mer = *(volatile int *)MACH_PHYS_TO_UNCACHED(KMIN_REG_MER);
	adr = *(volatile int *)MACH_PHYS_TO_UNCACHED(KMIN_REG_AER);

	/* clear interrupt bit */
	*(unsigned int *)MACH_PHYS_TO_UNCACHED(KMIN_REG_TIMEOUT) = 0;

	errintr_cnt++;
	printf("(%d)%s%x [%x %x %x]\n", errintr_cnt,
	       "Bad memory chip at phys ",
	       kn02ba_recover_erradr(adr, mer),
	       mer, siz, adr);
}

static unsigned
kn02ba_recover_erradr(phys, mer)
	register unsigned phys, mer;
{
	/* phys holds bits 28:2, mer knows which byte */
	switch (mer & KMIN_MER_LASTBYTE) {
	case KMIN_LASTB31:
		mer = 3; break;
	case KMIN_LASTB23:
		mer = 2; break;
	case KMIN_LASTB15:
		mer = 1; break;
	case KMIN_LASTB07:
		mer = 0; break;
	}
	return ((phys & KMIN_AER_ADDR_MASK) | mer);
}


/*
d1137 1
a1137 1
u_int
d1148 4
d1154 1
a1154 1
		
d1179 3
d1188 1
d1190 3
a1192 1
		case OP_BGEZ:
d1211 2
d1220 2
d1229 2
d1238 2
a1284 2
#ifdef DEBUG

d1298 1
d1324 63
d1397 1
d1476 9
d1486 19
a1504 1
	if (pc >= (unsigned)MachKernIntr && pc < (unsigned)MachUserIntr) {
d1506 2
a1507 2
		(*printfn)("MachKernIntr+%x: (%x, %x ,%x) -------\n",
		       pc-(unsigned)MachKernIntr, a0, a1, a2);
d1518 1
a1520 4
# define Between(x, y, z) \
		( ((x) <= (y)) && ((y) < (z)) )
# define pcBetween(a,b) \
		Between((unsigned)a, pc, (unsigned)b)
d1527 31
a1557 8
	if (pcBetween(MachKernGenException, MachUserGenException))
		subr = (unsigned) MachKernGenException;
	else if (pcBetween(MachUserGenException,MachKernIntr))
		subr = (unsigned) MachUserGenException;
	else if (pcBetween(MachKernIntr, MachUserIntr))
		subr = (unsigned) MachKernIntr;
	else if (pcBetween(MachUserIntr, MachTLBMissException))
		subr = (unsigned) MachUserIntr;
d1574 6
a1579 1
		(*printfn)("PC 0x%x: not in kernel\n", pc);
d1603 1
d1605 1
d1731 17
a1747 4
	Name(MachKernGenException),
	Name(MachUserGenException),
	Name(MachKernIntr),
	Name(MachUserIntr),
@


1.2
log
@from netbsd:
Change MachEmulateBranch() to be able to read an insn from user space.
Kernel-debugger breakpoints in user space, or FP insns that cause
underflow in a delay slot, should now work properly. Single-stepping
of arbitrary user processes, from user level, should be added.
@
text
@d441 1
a441 1
		i = (rv == KERN_PROTECTION_FAILURE) ? SIGBUS : SIGSEGV;
d449 1
a449 1
		i = SIGSEGV;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: trap.c,v 1.23 1995/09/11 22:03:00 jonathan Exp $	*/
d1608 4
a1611 1
	inst = *(InstFmt *)instPC;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

