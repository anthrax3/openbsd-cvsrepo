head	1.9;
access;
symbols
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	UBC_SYNC_A:1.9
	UBC_SYNC_B:1.9
	OPENBSD_2_9:1.7.0.14
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.12
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.10
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.8
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.6
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.4
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2001.06.24.23.48.31;	author deraadt;	state dead;
branches;
next	1.8;

1.8
date	2001.05.05.22.34.08;	author art;	state Exp;
branches;
next	1.7;

1.7
date	98.05.10.04.01.20;	author millert;	state Exp;
branches
	1.7.8.1;
next	1.6;

1.6
date	97.07.07.08.28.29;	author graichen;	state Exp;
branches;
next	1.5;

1.5
date	97.06.10.14.20.05;	author graichen;	state Exp;
branches;
next	1.4;

1.4
date	96.12.22.15.18.24;	author graichen;	state Exp;
branches;
next	1.3;

1.3
date	96.09.15.21.13.03;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.30.09.24.30;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.31;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.31;	author deraadt;	state Exp;
branches;
next	;

1.7.8.1
date	2001.07.04.10.21.35;	author niklas;	state dead;
branches;
next	;


desc
@@


1.9
log
@bye bye, with prejudice
@
text
@/*	$NetBSD: autoconf.c,v 1.18 1996/10/13 03:39:44 christos Exp $	*/

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department and Ralph Campbell.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah Hdr: autoconf.c 1.31 91/01/21
 *
 *	@@(#)autoconf.c	8.1 (Berkeley) 6/10/93
 */

/*
 * Setup the system to run on the current machine.
 *
 * cpu_configure() is called at boot time.  Available
 * devices are determined (from possibilities mentioned in ioconf.c),
 * and the drivers are initialized.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/map.h>
#include <sys/buf.h>
#include <sys/dkstat.h>
#include <sys/conf.h>
#include <sys/disklabel.h>
#include <sys/dmap.h>
#include <sys/reboot.h>
#include <sys/device.h>

#include <machine/cpu.h>
#include <pmax/dev/device.h>
#include <pmax/pmax/pmaxtype.h>
#include <pmax/pmax/turbochannel.h>

void setroot __P((void));
void swapconf __P((void));
void dumpconf __P((void)); 	/* XXX */

void xconsinit __P((void));	/* XXX console-init continuation */

#if 0
/*
 * XXX system-dependent, should call through a pointer.
 * (spl0 should _NOT_ enable TC interrupts on a 3MIN.)
 *
 */
int spl0 __P((void));
#endif

void	makebootdev __P((char *cp));

/*
 * The following several variables are related to
 * the configuration process, and are used in initializing
 * the machine.
 */
int	cold = 1;	/* if 1, still working on cold-start */
int	cpuspeed = 30;	/* approx # instr per usec. */
extern	int pmax_boardtype;
extern	tc_option_t tc_slot_info[TC_MAX_LOGICAL_SLOTS];


extern int cputype;	/* glue for new-style config */
int cputype;

extern int initcpu __P((void));		/*XXX*/
void configure_scsi __P((void));

/*
 * Determine mass storage and memory configuration for a machine.
 * Print cpu type, and then iterate over an array of devices
 * found on the baseboard or in turbochannel option slots.
 * Once devices are configured, enable interrupts, and probe
 * for attached scsi devices.
 */
void
cpu_configure()
{
	int s;

	/*
	 * Set CPU type for new-style config. 
	 * Should support Decstations with CPUs on daughterboards,
	 * where system-type (board type) and CPU type aren't
	 * necessarily the same.
	 * (On hold until someone donates an r4400 daughterboard).
	 */
	cputype = pmax_boardtype;		/*XXX*/


	/*
	 * Kick off autoconfiguration
	 */
	s = splhigh();
	if (config_rootfound("mainbus", "mainbus") == NULL)
	    panic("no mainbus found");

#if 0
	printf("looking for non-PROM console driver\n");
#endif

	xconsinit();	/* do kludged-up console init */

#ifdef DEBUG
	if (cputype == DS_3MIN)
/*FIXME*/	printf("switched to non-PROM console\n");
#endif

	initcpu();

#ifdef DEBUG
	printf("autconfiguration done, spl back to 0x%x\n", s);
#endif
	/*
	 * Configuration is finished,  turn on interrupts.
	 * This is just spl0(), except on the 3MIN, where TURBOChannel
	 * option cards interrupt at IPLs 0-2, and some dumb drivers like
	 * the cfb want to just disable interrupts.
	 */
	if (cputype != DS_3MIN)
		spl0();

	/*
	 * Probe SCSI bus using old-style pmax configuration table.
	 * We do not yet have machine-independent SCSI support or polled
	 * SCSI.
	 */
	printf("Beginning old-style SCSI device autoconfiguration\n");
	configure_scsi();

#ifdef GENERIC
	if ((boothowto & RB_ASKNAME) == 0)
		setroot();
	setconf();
#else
	setroot();
#endif
	swapconf();
	cold = 0;
}

/*
 * Configure swap space and related parameters.
 */
void
swapconf()
{
	register struct swdevt *swp;
	register int nblks;

	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		int maj = major(swp->sw_dev);

		if (maj > nblkdev)
			break;
		if (bdevsw[maj].d_psize) {
			nblks = (*bdevsw[maj].d_psize)(swp->sw_dev);
			if (nblks != -1 &&
			    (swp->sw_nblks == 0 || swp->sw_nblks > nblks))
				swp->sw_nblks = nblks;
			swp->sw_nblks = ctod(dtoc(swp->sw_nblks));
		}
	}
	dumpconf();
}

#define	DOSWAP			/* Change swdevt and dumpdev too */
u_long	bootdev = 0;		/* should be dev_t, but not until 32 bits */

static	char devname[][2] = {
	{  0,  0  },	/*  0 = 4.4bsd rz */
	{  0,  0  },	/*  1 = vax ht */
	{  0,  0  },	/*  2 = ?? */
	{ 'r','k' },	/*  3 = rk */
	{  0,  0  },	/*  4 = sw */
	{ 't','m' },	/*  5 = tm */
	{ 't','s' },	/*  6 = ts */
	{ 'm','t' },	/*  7 = mt */
	{ 'r','t' },	/*  8 = rt*/
	{  0,  0  },	/*  9 = ?? */
	{ 'u','t' },	/* 10 = ut */
	{ 'i','d' },	/* 11 = 11/725 idc */
	{ 'r','x' },	/* 12 = rx */
	{ 'u','u' },	/* 13 = uu */
	{ 'r','l' },	/* 14 = rl */
	{ 't','u' },	/* 15 = tmscp */
	{ 'c','s' },	/* 16 = cs */
	{ 'm','d' },	/* 17 = md */
	{ 's','t' },	/* 18 = st */
	{ 's','d' },	/* 19 = sd */
	{ 't','z' },	/* 20 = tz */
	{ 'r','z' },	/* 21 = rz */
	{  0,  0  },	/* 22 = ?? */
	{ 'r','a' },	/* 23 = ra */
};

/*
 * Attempt to find the device from which we were booted.
 * If we can do so, and not instructed not to do so,
 * change rootdev to correspond to the load device.
 */
void
setroot()
{
	int  majdev, mindev, unit, part, controller;
	dev_t  orootdev;
	struct swdevt *swp;
	register struct pmax_scsi_device *dp;

#ifdef DOSWAP
	dev_t temp;
#endif

	if (boothowto & RB_DFLTROOT ||
	    (bootdev & B_MAGICMASK) != B_DEVMAGIC)
		return;
	majdev = B_TYPE(bootdev);
	if (majdev >= sizeof(devname) / sizeof(devname[0]))
		return;
	controller = B_CONTROLLER(bootdev);
	part = B_PARTITION(bootdev);
	unit = B_UNIT(bootdev);

	for (dp = scsi_dinit; ; dp++) {
		if (dp->sd_driver == 0)
			return;
		if (dp->sd_alive && dp->sd_drive == unit &&
		    dp->sd_ctlr == controller &&
		    dp->sd_driver->d_name[0] == devname[majdev][0] &&
		    dp->sd_driver->d_name[1] == devname[majdev][1]) {
			mindev = dp->sd_unit;
		    	break;
		}
	}
	/*
	 * Form a new rootdev
	 */
	orootdev = rootdev;
	rootdev = MAKEDISKDEV(majdev, mindev, part);
	/*
	 * If the original rootdev is the same as the one
	 * just calculated, don't need to adjust the swap configuration.
	 */
	if (rootdev == orootdev)
		return;

	printf("Changing root device to %c%c%d%c\n",
		devname[majdev][0], devname[majdev][1],
		mindev, part + 'a');

#ifdef DOSWAP
	part = mindev % MAXPARTITIONS;
	temp = 0;
	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		if (majdev == major(swp->sw_dev) &&
		    part == DISKPART(swp->sw_dev)) {
			temp = swdevt[0].sw_dev;
			swdevt[0].sw_dev = swp->sw_dev;
			swp->sw_dev = temp;
			break;
		}
	}
	if (swp->sw_dev == NODEV)
		return;

	/*
	 * If dumpdev was the same as the old primary swap
	 * device, move it to the new primary swap device.
	 */
	if (temp == dumpdev)
		dumpdev = swdevt[0].sw_dev;
#endif
}

/*
 * Look at the string 'cp' and decode the boot device.
 * Boot names can be something like 'rz(0,0,0)vmunix' or '5/rz0/vmunix'.
 */
void
makebootdev(cp)
	register char *cp;
{
	int majdev, unit, part, ctrl;

	if (*cp >= '0' && *cp <= '9') {
		/* XXX should be able to specify controller */
		if (cp[1] != '/' || cp[4] < '0' || cp[4] > '9')
			goto defdev;
		unit = cp[4] - '0';
		if (cp[5] >= 'a' && cp[5] <= 'h')
			part = cp[5] - 'a';
		else
			part = 0;
		cp += 2;
		for (majdev = 0; majdev < sizeof(devname)/sizeof(devname[0]);
		    majdev++) {
			if (cp[0] == devname[majdev][0] &&
			    cp[1] == devname[majdev][1]) {
				bootdev = MAKEBOOTDEV(majdev, 0, 0, unit, part);
				return;
			}
		}
		goto defdev;
	}
	for (majdev = 0; majdev < sizeof(devname)/sizeof(devname[0]); majdev++)
		if (cp[0] == devname[majdev][0] &&
		    cp[1] == devname[majdev][1] &&
		    cp[2] == '(')
			goto fndmaj;
defdev:
	bootdev = B_DEVMAGIC;
	return;

fndmaj:
	for (ctrl = 0, cp += 3; *cp >= '0' && *cp <= '9'; )
		ctrl = ctrl * 10 + *cp++ - '0';
	if (*cp == ',')
		cp++;
	for (unit = 0; *cp >= '0' && *cp <= '9'; )
		unit = unit * 10 + *cp++ - '0';
	if (*cp == ',')
		cp++;
	for (part = 0; *cp >= '0' && *cp <= '9'; )
		part = part * 10 + *cp++ - '0';
	if (*cp != ')')
		goto defdev;
	bootdev = MAKEBOOTDEV(majdev, 0, ctrl, unit, part);
}
@


1.8
log
@Rename configure() to cpu_configure().
Move it from cpu_startup() to main().
@
text
@@


1.7
log
@1) It's a 'lun' not a 'slave'
2) 16 partitions
@
text
@d48 1
a48 1
 * Configure() is called at boot time.  Available
a83 1
void	configure __P((void));
a85 2


d111 1
a111 1
configure()
@


1.7.8.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@@


1.6
log
@go back to versions before the last NetBSD merge - it has broken
current kernels somehow - per or me has to look deeper at the diffs
@
text
@d59 1
a233 3
#define	PARTITIONMASK	0x7
#define	PARTITIONSHIFT	3

a274 1
	mindev = (mindev << PARTITIONSHIFT) + part;
d276 1
a276 1
	rootdev = makedev(majdev, mindev);
d286 1
a286 1
		mindev >> PARTITIONSHIFT, part + 'a');
d289 1
a289 1
	mindev &= ~PARTITIONMASK;
d293 1
a293 1
		    mindev == (minor(swp->sw_dev) & ~PARTITIONMASK)) {
@


1.5
log
@update the pmax specific stuff to NetBSD-current as of about 970608 - some
cosmetic things will follow together with an update to an exact NETBSD_CU-
RRENT_xxxxxx level
@
text
@d1 1
a1 1
/*	$NetBSD: autoconf.c,v 1.24 1997/05/25 08:17:00 jonathan Exp $	*/
a63 1
#include <machine/autoconf.h>
d82 4
@


1.4
log
@update the pmax stuff to NetBSD 961107 - this version i got somehow
compiled on my decstation 2100 (PLUTO) - but it will not fully work
out of the box - but i want to bring it into the tree because i get
my own pmax on 961228 - so that i have a good startpoint then :-)

all the OpenBSD changes to the pmax tree will follow in the next commit
@
text
@d1 1
a1 1
/*	$NetBSD: autoconf.c,v 1.18 1996/10/13 03:39:44 christos Exp $	*/
d64 1
a82 4

void	configure __P((void));
void	makebootdev __P((char *cp));

@


1.3
log
@sync to netbsd; for graichen
@
text
@d1 1
a1 1
/*	$NetBSD: autoconf.c,v 1.16 1996/04/10 17:38:18 jonathan Exp $	*/
@


1.2
log
@from netbsd:
Move the old-style disk instrumentation "structures" to a central
location (sys/kern/subr_disk.c) and note that they should/will be
deprecated.
@
text
@d1 1
a1 1
/*	$NetBSD: autoconf.c,v 1.14 1995/12/28 19:16:58 thorpej Exp $	*/
d61 1
d68 20
a102 1
void cpu_configure __P((void));
a105 62
 * Print cpu type. (This should be moved into cpu.c)
 */

void
cpu_configure()
{
	/*
	 * for some reason the Pmax has an R2000 cpu with an implementation
	 * level of 2 and DEC's R3000s are level 2 as well?
	 */
	if (pmax_boardtype == DS_PMAX) {
		cpu.cpu.cp_imp = MIPS_R2000;
		fpu.cpu.cp_imp = MIPS_R2010;
	}

	switch (cpu.cpu.cp_imp) {
	case MIPS_R2000:
		printf("cpu0 (MIPS R2000 revision %d.%d)\n",
			cpu.cpu.cp_majrev, cpu.cpu.cp_minrev);
		break;

	case MIPS_R3000:
		printf("cpu0 (MIPS R3000 revision %d.%d)\n",
			cpu.cpu.cp_majrev, cpu.cpu.cp_minrev);
		break;

	case MIPS_R4000:
		printf("cpu0 (MIPS R4000 revision %d.%d)\n",
			cpu.cpu.cp_majrev, cpu.cpu.cp_minrev);
		break;

	default:
		printf("cpu0 (implementation %d revision %d.%d)\n",
			cpu.cpu.cp_imp, cpu.cpu.cp_majrev, cpu.cpu.cp_minrev);
	}
	switch (fpu.cpu.cp_imp) {
	case MIPS_R2010:
		printf("fpu0 (MIPS R2010 revision %d.%d)\n",
			fpu.cpu.cp_majrev, fpu.cpu.cp_minrev);
		break;

	case MIPS_R3010:
		printf("fpu0 (MIPS R3010 revision %d.%d)\n",
			fpu.cpu.cp_majrev, fpu.cpu.cp_minrev);
		break;

	case MIPS_R4010:
		printf("fpu0 (MIPS R4010 revision %d.%d)\n",
			fpu.cpu.cp_majrev, fpu.cpu.cp_minrev);
		break;

	default:
		printf("fpu0 (implementation %d revision %d.%d)\n",
			fpu.cpu.cp_imp, fpu.cpu.cp_majrev, fpu.cpu.cp_minrev);
	}
	printf("data cache size %dK inst cache size %dK\n",
		machDataCacheSize >> 10, machInstCacheSize >> 10);

}


/*
a114 1
	register struct pmax_ctlr *cp;
d131 1
a131 1
	if (config_rootfound("mainbus", "mainbus") == 0)
d181 1
d207 24
a230 24
	  0, 0,		/*  0 = 4.4bsd rz */
	  0, 0,		/*  1 = vax ht */
	  0, 0,		/*  2 = ?? */
	'r','k',	/*  3 = rk */
	  0, 0,		/*  4 = sw */
	't','m',	/*  5 = tm */
	't','s',	/*  6 = ts */
	'm','t',	/*  7 = mt */
	'r','t',	/*  8 = rt*/
	 0,  0,		/*  9 = ?? */
	'u','t',	/* 10 = ut */
	'i','d',	/* 11 = 11/725 idc */
	'r','x',	/* 12 = rx */
	'u','u',	/* 13 = uu */
	'r','l',	/* 14 = rl */
	't','u',	/* 15 = tmscp */
	'c','s',	/* 16 = cs */
	'm','d',	/* 17 = md */
	's','t',	/* 18 = st */
	's','d',	/* 19 = sd */
	't','z',	/* 20 = tz */
	'r','z',	/* 21 = rz */
	 0,  0,		/* 22 = ?? */
	'r','a',	/* 23 = ra */
d241 1
d245 1
a245 1
	dev_t temp, orootdev;
d249 4
d293 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: autoconf.c,v 1.13 1995/09/13 19:36:01 jonathan Exp $	*/
a72 1
int	dkn;		/* number of iostat dk numbers assigned so far */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
