head	1.31;
access;
symbols
	SMP_SYNC_A:1.31
	SMP_SYNC_B:1.31
	UBC_SYNC_A:1.31
	UBC_SYNC_B:1.31
	OPENBSD_2_9:1.26.0.2
	OPENBSD_2_9_BASE:1.26
	OPENBSD_2_8:1.25.0.2
	OPENBSD_2_8_BASE:1.25
	OPENBSD_2_7:1.23.0.2
	OPENBSD_2_7_BASE:1.23
	SMP:1.22.0.4
	SMP_BASE:1.22
	kame_19991208:1.22
	OPENBSD_2_6:1.22.0.2
	OPENBSD_2_6_BASE:1.22
	OPENBSD_2_5:1.21.0.2
	OPENBSD_2_5_BASE:1.21
	OPENBSD_2_4:1.20.0.2
	OPENBSD_2_4_BASE:1.20
	OPENBSD_2_3:1.15.0.4
	OPENBSD_2_3_BASE:1.15
	OPENBSD_2_2:1.15.0.2
	OPENBSD_2_2_BASE:1.15
	OPENBSD_2_1:1.13.0.2
	OPENBSD_2_1_BASE:1.13
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2001.06.24.23.48.41;	author deraadt;	state dead;
branches;
next	1.30;

1.30
date	2001.05.17.18.41.49;	author provos;	state Exp;
branches;
next	1.29;

1.29
date	2001.05.12.22.47.08;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2001.05.05.22.34.09;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2001.05.05.20.56.49;	author art;	state Exp;
branches;
next	1.26;

1.26
date	2000.11.08.14.38.23;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2000.10.27.00.16.16;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2000.07.04.05.46.23;	author maja;	state Exp;
branches;
next	1.23;

1.23
date	2000.03.23.09.59.55;	author art;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	99.05.22.21.22.28;	author weingart;	state Exp;
branches
	1.22.4.1;
next	1.21;

1.21
date	99.01.11.05.11.51;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	98.10.16.01.57.22;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	98.09.15.10.53.55;	author pefo;	state Exp;
branches;
next	1.18;

1.18
date	98.06.04.03.49.50;	author jason;	state Exp;
branches;
next	1.17;

1.17
date	98.05.18.00.28.24;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	98.05.08.19.27.45;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	97.07.07.08.28.30;	author graichen;	state Exp;
branches;
next	1.14;

1.14
date	97.06.10.14.20.09;	author graichen;	state Exp;
branches;
next	1.13;

1.13
date	97.02.05.23.48.46;	author graichen;	state Exp;
branches;
next	1.12;

1.12
date	97.02.03.15.05.00;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.02.03.11.45.17;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.01.16.20.43.42;	author kstailey;	state Exp;
branches;
next	1.9;

1.9
date	96.12.22.15.18.34;	author graichen;	state Exp;
branches;
next	1.8;

1.8
date	96.10.12.08.40.39;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.09.29.11.36.49;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.09.15.21.13.13;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.07.27.11.40.50;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.05.08.08.42.51;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.01.05.16.18.12;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.30.08.39.14;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.33;	author deraadt;	state Exp;
branches;
next	;

1.22.4.1
date	2000.03.24.09.08.33;	author niklas;	state Exp;
branches;
next	1.22.4.2;

1.22.4.2
date	2001.04.18.16.12.47;	author niklas;	state Exp;
branches;
next	1.22.4.3;

1.22.4.3
date	2001.07.04.10.21.47;	author niklas;	state dead;
branches;
next	;

1.23.2.1
date	2000.07.13.16.05.30;	author jason;	state Exp;
branches;
next	;


desc
@@


1.31
log
@bye bye, with prejudice
@
text
@/*	$OpenBSD: machdep.c,v 1.30 2001/05/17 18:41:49 provos Exp $	*/
/*	$NetBSD: machdep.c,v 1.67 1996/10/23 20:04:40 mhitch Exp $	*/

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department, The Mach Operating System project at
 * Carnegie-Mellon University and Ralph Campbell.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)machdep.c	8.3 (Berkeley) 1/12/94
 */

/* from: Utah Hdr: machdep.c 1.63 91/04/24 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/signalvar.h>
#include <sys/kernel.h>
#include <sys/map.h>
#include <sys/proc.h>
#include <sys/buf.h>
#include <sys/reboot.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/clist.h>
#include <sys/timeout.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/msgbuf.h>
#include <sys/ioctl.h>
#include <sys/tty.h>
#include <sys/device.h>
#include <sys/user.h>
#include <sys/exec.h>
#include <sys/sysctl.h>
#include <sys/mount.h>
#include <sys/syscallargs.h>
#ifdef SYSVMSG
#include <sys/msg.h>
#endif
#ifdef SYSVSEM
#include <sys/sem.h>
#endif
#ifdef SYSVSHM
#include <sys/shm.h>
#endif

#include <vm/vm_kern.h>

#include <machine/cpu.h>
#include <machine/reg.h>
#include <machine/psl.h>
#include <machine/pte.h>
#include <machine/dc7085cons.h>

#include <pmax/stand/dec_prom.h>

#include <pmax/dev/ascreg.h>
#include <pmax/dev/led.h>

#include <machine/autoconf.h>
#include <machine/locore.h>

#include <pmax/pmax/clockreg.h>
#include <pmax/pmax/kn01.h>
#include <pmax/pmax/kn02.h>
#include <pmax/pmax/kmin.h>
#include <pmax/pmax/maxine.h>
#include <pmax/pmax/kn03.h>
#include <pmax/pmax/asic.h>
#include <pmax/pmax/turbochannel.h>
#include <pmax/pmax/pmaxtype.h>
#include <pmax/pmax/cons.h>

#include "pm.h"
#include "cfb.h"
#include "mfb.h"
#include "xcfb.h"
#include "sfb.h"
#include "dtop.h"
#include "scc.h"
#include "le_ioasic.h"
#include "asc.h"
#include "led.h"

extern void fbPutc();

/* Will scan from max to min, inclusive */
static int tc_max_slot = KN02_TC_MAX;
static int tc_min_slot = KN02_TC_MIN;
static u_int tc_slot_phys_base [TC_MAX_SLOTS] = {
	/* use 3max for default values */
	KN02_PHYS_TC_0_START, KN02_PHYS_TC_1_START,
	KN02_PHYS_TC_2_START, KN02_PHYS_TC_3_START,
	KN02_PHYS_TC_4_START, KN02_PHYS_TC_5_START,
	KN02_PHYS_TC_6_START, KN02_PHYS_TC_7_START
};

/* the following is used externally (sysctl_hw) */
char	machine[] = "pmax";	/* cpu "architecture" */
char	cpu_model[30];

vm_map_t buffer_map;

/*
 * Declare these as initialized data so we can patch them.
 */
int	nswbuf = 0;
#ifdef	NBUF
int	nbuf = NBUF;
#else
int	nbuf = 0;
#endif
#ifdef	BUFPAGES
int	bufpages = BUFPAGES;
#else
int	bufpages = 0;
#endif
int	maxmem;			/* max memory per process */
int	physmem;		/* max supported memory, changes to actual */
int	physmem_boardmax;	/* {model,simm}-specific bound on physmem */
int	pmax_boardtype;		/* Mother board type */
#ifndef UVM
u_long	le_iomem;		/* 128K for lance chip via. ASIC */
#endif
u_long	asc_iomem;		/* and 7 * 8K buffers for the scsi */
u_long	ioasic_base;		/* Base address of I/O asic */
const	struct callback *callv;	/* pointer to PROM entry points */

extern void	(*tc_enable_interrupt)  __P ((u_int slotno,
					      int (*handler) __P((void *sc)),
					      void *sc, int onoff)); 
void	(*tc_enable_interrupt) __P ((u_int slotno,
				     int (*handler) __P ((void *sc)),
				     void *sc, int onoff));
extern	int (*mips_hardware_intr)();

int	kn02_intr(), kmin_intr(), xine_intr();

#ifdef DS3100
extern int	kn01_intr();
void	kn01_enable_intr  __P ((u_int slotno,
				int (*handler) __P ((intr_arg_t sc)),
				intr_arg_t sc, int onoff));
#endif /* DS3100 */

#ifdef DS5100 /* mipsmate */
# include <pmax/pmax/kn230var.h>   /* kn230_establish_intr(), kn230_intr() */
#endif

#ifdef DS5000_240
int	kn03_intr();
#endif

extern	int Mach_spl0(), Mach_spl1(), Mach_spl2(), Mach_spl3(), splhigh();
int	(*Mach_splbio)() = splhigh;
int	(*Mach_splnet)() = splhigh;
int	(*Mach_spltty)() = splhigh;
int	(*Mach_splimp)() = splhigh;
int	(*Mach_splclock)() = splhigh;
int	(*Mach_splstatclock)() = splhigh;
extern	volatile struct chiptime *Mach_clock_addr;
u_long	kmin_tc3_imask, xine_tc3_imask;

#ifdef DS5000_240
u_long	kn03_tc3_imask;
extern u_long latched_cycle_cnt;
#endif

tc_option_t tc_slot_info[TC_MAX_LOGICAL_SLOTS];
static	void asic_init();
extern	void RemconsInit();

#ifdef DS5000_200
void	kn02_enable_intr __P ((u_int slotno,
			       int (*handler) __P((intr_arg_t sc)),
			       intr_arg_t sc, int onoff));
#endif /*DS5000_200*/

#ifdef DS5000_100
void	kmin_enable_intr __P ((u_int slotno, int (*handler) (intr_arg_t sc),
			     intr_arg_t sc, int onoff));
#endif /*DS5000_100*/

#ifdef DS5000_25
void	xine_enable_intr __P ((u_int slotno, int (*handler) (intr_arg_t sc),
			    intr_arg_t sc, int onoff));
#endif /*DS5000_25*/

#ifdef DS5000_240
void	kn03_enable_intr __P ((u_int slotno, int (*handler) (intr_arg_t sc),
			       intr_arg_t sc, int onoff));
#endif /*DS5000_240*/

#if defined(DS5000_200) || defined(DS5000_25) || defined(DS5000_100) || \
    defined(DS5000_240)
volatile u_int *Mach_reset_addr;
#endif /* DS5000_200 || DS5000_25 || DS5000_100 || DS5000_240 */


void	prom_halt __P((int, char *))   __attribute__((__noreturn__));


/*
 * safepri is a safe priority for sleep to set for a spin-wait
 * during autoconfiguration or after a panic.
 */
int	safepri = PSL_LOWIPL;

struct	user *proc0paddr;
struct	proc nullproc;		/* for use by swtch_exit() */

/*
 * Do all the stuff that locore normally does before calling main().
 * Process arguments passed to us by the prom monitor.
 * Return the first page address following the system.
 */
void
mach_init(argc, argv, code, cv)
	int argc;
	char *argv[];
	u_int code;
	const struct callback *cv;
{
	register char *cp;
	register int i;
	register unsigned firstaddr;
	register caddr_t v;
	caddr_t start;
	extern char edata[], end[];
	extern char MachUTLBMiss[], MachUTLBMissEnd[];
	extern char mips_R2000_exception[], mips_R2000_exceptionEnd[];

	/* clear the BSS segment */
	v = (caddr_t)mips_round_page(end);
	bzero(edata, v - edata);

	/* Initialize callv so we can do PROM output... */
	if (code == DEC_PROM_MAGIC) {
		callv = cv;
	} else {
		callv = &callvec;
	}

	/* check for direct boot from DS5000 PROM */
	if (argc > 0 && strcmp(argv[0], "boot") == 0) {
		argc--;
		argv++;
	}

	/*
	 * Copy exception-dispatch code down to exception vector.
	 * Initialize locore-function vector.
	 * Clear out the I and D caches.
	 */
#ifdef notyet
	/* XXX locore doesn't set up cpu type early enough for this */
	mips_vector_init();
#else
	mips1_vector_init();
#endif

	/* look at argv[0] and compute bootdev */
	makebootdev(argv[0]);

	/*
	 * Look at arguments passed to us and compute boothowto.
	 */
#ifdef GENERIC
	boothowto = RB_SINGLE | RB_ASKNAME;
#else
	boothowto = RB_SINGLE;
#endif
#ifdef KADB
	boothowto |= RB_KDB;
#endif
	if (argc > 1) {
		for (i = 1; i < argc; i++) {
			for (cp = argv[i]; *cp; cp++) {
				switch (*cp) {
				case 'a': /* autoboot */
					boothowto &= ~RB_SINGLE;
					break;

				case 'd': /* use compiled in default root */
					boothowto |= RB_DFLTROOT;
					break;

				case 'm': /* mini root present in memory */
					boothowto |= RB_MINIROOT;
					break;

				case 'n': /* ask for names */
					boothowto |= RB_ASKNAME;
					break;

				case 'N': /* don't ask for names */
					boothowto &= ~RB_ASKNAME;
				}
			}
		}
	}

#ifdef MFS
	/*
	 * Check to see if a mini-root was loaded into memory. It resides
	 * at the start of the next page just after the end of BSS.
	 */
	if (boothowto & RB_MINIROOT) {
		boothowto |= RB_DFLTROOT;
		v += mfs_initminiroot(v);
	}
#endif

	/*
	 * Init mapping for u page(s) for proc[0], pm_tlbpid 1.
	 */
	start = v;
	proc0.p_addr = proc0paddr = (struct user *)v;
	proc0.p_md.md_regs = proc0paddr->u_pcb.pcb_regs;
	firstaddr = MIPS_KSEG0_TO_PHYS(v);
	for (i = 0; i < UPAGES; i++) {
		MachTLBWriteIndexed(i,
			(UADDR + (i << PGSHIFT)) | (1 << MIPS_TLB_PID_SHIFT),
			proc0.p_md.md_upte[i] = firstaddr | PG_V | PG_M);
		firstaddr += NBPG;
	}
	v += UPAGES * NBPG;
	MachSetPID(1);

	/*
	 * init nullproc for swtch_exit().
	 * init mapping for u page(s), pm_tlbpid 0
	 * This could be used for an idle process.
	 */
	nullproc.p_addr = (struct user *)v;
	nullproc.p_md.md_regs = nullproc.p_addr->u_pcb.pcb_regs;
	bcopy("nullproc", nullproc.p_comm, sizeof("nullproc"));
	for (i = 0; i < UPAGES; i++) {
		nullproc.p_md.md_upte[i] = firstaddr | PG_V | PG_M;
		firstaddr += NBPG;
	}
	v += UPAGES * NBPG;

	/* clear pages for u areas */
	bzero(start, v - start);

	/*
	 * Determine what model of computer we are running on.
	 */
	if (code == DEC_PROM_MAGIC) {
		i = (*cv->_getsysid)();
		cp = "";
	} else {
		if (cp = (*callv->_getenv)("systype"))
			i = atoi(cp);
		else {
			cp = "";
			i = 0;
		}
	}
	/* check for MIPS based platform */
	if (((i >> 24) & 0xFF) != 0x82) {
		printf("Unknown System type '%s' 0x%x\n", cp, i);
		boot(RB_HALT | RB_NOSYNC);
	}

	/*
	 * Initialize physmem_boardmax; assume no SIMM-bank limits.
	 * Adjst later in model-specific code if necessary.
	 */
	physmem_boardmax = MIPS_MAX_MEM_ADDR;

	/* check what model platform we are running on */
	pmax_boardtype = ((i >> 16) & 0xff);

	switch (pmax_boardtype) {

#ifdef DS3100
	case DS_PMAX:	/* DS3100 Pmax */
		/*
		 * Set up interrupt handling and I/O addresses.
		 */
		mips_hardware_intr = kn01_intr;
		tc_enable_interrupt = kn01_enable_intr; /*XXX*/
		Mach_splbio = Mach_spl0;
		Mach_splnet = Mach_spl1;
		Mach_spltty = Mach_spl2;
		Mach_splimp = splhigh; /*XXX Mach_spl1(), if not for malloc()*/
		Mach_splclock = Mach_spl3;
		Mach_splstatclock = Mach_spl3;
		Mach_clock_addr = (volatile struct chiptime *)
			MIPS_PHYS_TO_KSEG1(KN01_SYS_CLOCK);
		strcpy(cpu_model, "3100");
		break;
#endif /* DS3100 */


#ifdef DS5100
	case DS_MIPSMATE:	/* DS5100 aka mipsmate aka kn230 */
		/* XXX just a guess */
		/*
		 * Set up interrupt handling and I/O addresses.
		 */
		mips_hardware_intr = kn230_intr;
		tc_enable_interrupt = kn01_enable_intr; /*XXX*/
		Mach_splbio = Mach_spl0;
		Mach_splnet = Mach_spl1;
		Mach_spltty = Mach_spl2;
		Mach_splimp = Mach_spl2;
		Mach_splclock = Mach_spl3;
		Mach_splstatclock = Mach_spl3;
		Mach_clock_addr = (volatile struct chiptime *)
			MIPS_PHYS_TO_KSEG1(KN01_SYS_CLOCK);
		strcpy(cpu_model, "5100");
		break;
#endif /* DS5100 */

#ifdef DS5000_200
	case DS_3MAX:	/* DS5000/200 3max */
		{
		volatile int *csr_addr =
			(volatile int *)MIPS_PHYS_TO_KSEG1(KN02_SYS_CSR);

		Mach_reset_addr =
		    (unsigned *)MIPS_PHYS_TO_KSEG1(KN02_SYS_ERRADR);
		/* clear any memory errors from new-config probes */
		*Mach_reset_addr = 0;

		/*
		 * Enable ECC memory correction, turn off LEDs, and
		 * disable all TURBOchannel interrupts.
		 */
		i = *csr_addr;
		*csr_addr = (i & ~(KN02_CSR_WRESERVED | KN02_CSR_IOINTEN)) |
			KN02_CSR_CORRECT | 0xff;
		mips_hardware_intr = kn02_intr;
		tc_enable_interrupt = kn02_enable_intr;
		Mach_splbio = Mach_spl0;
		Mach_splnet = Mach_spl0;
		Mach_spltty = Mach_spl0;
		Mach_splimp = Mach_spl0;
		Mach_splclock = Mach_spl1;
		Mach_splstatclock = Mach_spl1;
		Mach_clock_addr = (volatile struct chiptime *)
			MIPS_PHYS_TO_KSEG1(KN02_SYS_CLOCK);

		}
		strcpy(cpu_model, "5000/200");
		break;
#endif /* DS5000_200 */

#ifdef DS5000_100
	case DS_3MIN:	/* DS5000/1xx 3min */
		tc_max_slot = KMIN_TC_MAX;
		tc_min_slot = KMIN_TC_MIN;
		tc_slot_phys_base[0] = KMIN_PHYS_TC_0_START;
		tc_slot_phys_base[1] = KMIN_PHYS_TC_1_START;
		tc_slot_phys_base[2] = KMIN_PHYS_TC_2_START;
		ioasic_base = MIPS_PHYS_TO_KSEG1(KMIN_SYS_ASIC);
		mips_hardware_intr = kmin_intr;
		tc_enable_interrupt = kmin_enable_intr;
		kmin_tc3_imask = (KMIN_INTR_CLOCK | KMIN_INTR_PSWARN |
			KMIN_INTR_TIMEOUT);

		/*
		 * Since all the motherboard interrupts come through the
		 * I/O ASIC, it has to be turned off for all the spls and
		 * since we don't know what kinds of devices are in the
		 * turbochannel option slots, just splhigh().
		 */
		Mach_splbio = splhigh;
		Mach_splnet = splhigh;
		Mach_spltty = splhigh;
		Mach_splimp = splhigh;
		Mach_splclock = splhigh;
		Mach_splstatclock = splhigh;
		Mach_clock_addr = (volatile struct chiptime *)
			MIPS_PHYS_TO_KSEG1(KMIN_SYS_CLOCK);


		/*
		 * Initialize interrupts.
		 */
		*(u_int *)IOASIC_REG_IMSK(ioasic_base) = KMIN_IM0;
		*(u_int *)IOASIC_REG_INTR(ioasic_base) = 0;

		/* clear any memory errors from probes */
		Mach_reset_addr =
		    (u_int*)MIPS_PHYS_TO_KSEG1(KMIN_REG_TIMEOUT);
		(*Mach_reset_addr) = 0;

		strcpy(cpu_model, "5000/1xx");

		/*
		 * The kmin memory hardware seems to wrap  memory addresses
		 * with 4Mbyte SIMMs, which causes the physmem computation
		 * to lose.  Find out how big the SIMMS are and set
		 * max_	physmem accordingly.
		 * XXX Do MAXINEs lose the same way?
		 */
		physmem_boardmax = KMIN_PHYS_MEMORY_END + 1;
		if ((*(int*)(MIPS_PHYS_TO_KSEG1(KMIN_REG_MSR)) &
		     KMIN_MSR_SIZE_16Mb) == 0)
			physmem_boardmax = physmem_boardmax >> 2;
		physmem_boardmax = MIPS_PHYS_TO_KSEG1(physmem_boardmax);

		break;
#endif /* ds5000_100 */

#ifdef DS5000_25
	case DS_MAXINE:	/* DS5000/xx maxine */
		tc_max_slot = XINE_TC_MAX;
		tc_min_slot = XINE_TC_MIN;
		tc_slot_phys_base[0] = XINE_PHYS_TC_0_START;
		tc_slot_phys_base[1] = XINE_PHYS_TC_1_START;
		ioasic_base = MIPS_PHYS_TO_KSEG1(XINE_SYS_ASIC);
		mips_hardware_intr = xine_intr;
		tc_enable_interrupt = xine_enable_intr;
		Mach_splbio = Mach_spl3;
		Mach_splnet = Mach_spl3;
		Mach_spltty = Mach_spl3;
		Mach_splimp = Mach_spl3;
		Mach_splclock = Mach_spl1;
		Mach_splstatclock = Mach_spl1;
		Mach_clock_addr = (volatile struct chiptime *)
			MIPS_PHYS_TO_KSEG1(XINE_SYS_CLOCK);

		/*
		 * Initialize interrupts.
		 */
		*(u_int *)IOASIC_REG_IMSK(ioasic_base) = XINE_IM0;
		*(u_int *)IOASIC_REG_INTR(ioasic_base) = 0;
		/* clear any memory errors from probes */
		Mach_reset_addr =
		    (u_int*)MIPS_PHYS_TO_KSEG1(XINE_REG_TIMEOUT);
		(*Mach_reset_addr) = 0;
		strcpy(cpu_model, "5000/25");
		break;
#endif /*DS5000_25*/

#ifdef DS5000_240
	case DS_3MAXPLUS:	/* DS5000/240 3max+ */
		tc_max_slot = KN03_TC_MAX;
		tc_min_slot = KN03_TC_MIN;
		tc_slot_phys_base[0] = KN03_PHYS_TC_0_START;
		tc_slot_phys_base[1] = KN03_PHYS_TC_1_START;
		tc_slot_phys_base[2] = KN03_PHYS_TC_2_START;
		ioasic_base = MIPS_PHYS_TO_KSEG1(KN03_SYS_ASIC);
		mips_hardware_intr = kn03_intr;
		tc_enable_interrupt = kn03_enable_intr;
		Mach_reset_addr =
		    (u_int *)MIPS_PHYS_TO_KSEG1(KN03_SYS_ERRADR);
		*Mach_reset_addr = 0;

		/*
		 * Reset interrupts, clear any errors from newconf probes
		 */

		Mach_splbio = Mach_spl0;
		Mach_splnet = Mach_spl0;
		Mach_spltty = Mach_spl0;
		Mach_splimp = Mach_spl0;
		Mach_splclock = Mach_spl1;
		Mach_splstatclock = Mach_spl1;
		Mach_clock_addr = (volatile struct chiptime *)
			MIPS_PHYS_TO_KSEG1(KN03_SYS_CLOCK);

		asic_init(0);
		/*
		 * Initialize interrupts.
		 */
		kn03_tc3_imask = KN03_IM0 &
			~(KN03_INTR_TC_0|KN03_INTR_TC_1|KN03_INTR_TC_2);
		*(u_int *)IOASIC_REG_IMSK(ioasic_base) = kn03_tc3_imask;
		*(u_int *)IOASIC_REG_INTR(ioasic_base) = 0;
		wbflush();
		/* XXX hard-reset LANCE */
		 *(u_int *)IOASIC_REG_CSR(ioasic_base) |= 0x100;

		/* clear any memory errors from probes */
		*Mach_reset_addr = 0;
		strcpy(cpu_model, "5000/240");
		break;
#endif /* DS5000_240 */

	default:
		printf("kernel not configured for systype 0x%x\n", i);
		boot(RB_HALT | RB_NOSYNC);
	}

	/*
	 * Find out how much memory is available.
	 * Be careful to save and restore the original contents for msgbuf.
	 */
	physmem = btoc((vm_offset_t)v - KERNBASE);
	cp = (char *)MIPS_PHYS_TO_KSEG1(physmem << PGSHIFT);	
	while (cp < (char *)physmem_boardmax) {
	  	int j;
		if (badaddr(cp, 4))
			break;
		i = *(int *)cp;
		j = ((int *)cp)[4];
		*(int *)cp = 0xa5a5a5a5;
		/*
		 * Data will persist on the bus if we read it right away.
		 * Have to be tricky here.
		 */
		((int *)cp)[4] = 0x5a5a5a5a;
		wbflush();
		if (*(int *)cp != 0xa5a5a5a5)
			break;
		*(int *)cp = i;
		((int *)cp)[4] = j;
		cp += NBPG;
		physmem++;
	}

	maxmem = physmem;

#ifndef UVM
#if NLE_IOASIC > 0
	/*
	 * Grab 128K at the top of physical memory for the lance chip
	 * on machines where it does dma through the I/O ASIC.
	 * It must be physically contiguous and aligned on a 128K boundary.
	 */
	if (pmax_boardtype == DS_3MIN || pmax_boardtype == DS_MAXINE ||
		pmax_boardtype == DS_3MAXPLUS) {
		maxmem -= btoc(128 * 1024);
		le_iomem = (maxmem << PGSHIFT);
	}
#endif /* NLE_IOASIC */
#endif
#if NASC > 0
	/*
	 * Ditto for the scsi chip. There is probably a way to make asc.c
	 * do dma without these buffers, but it would require major
	 * re-engineering of the asc driver.
	 * They must be 8K in size and page aligned.
	 * (now 16K, as that's how big clustered FFS reads/writes get).
	 */
	if (pmax_boardtype == DS_3MIN || pmax_boardtype == DS_MAXINE ||
		pmax_boardtype == DS_3MAXPLUS) {
		maxmem -= btoc(ASC_NCMD * (16 *1024));
		asc_iomem = (maxmem << PGSHIFT);
	}
#endif /* NASC */

	/*
	 * Initialize error message buffer (at end of core).
	 */
	maxmem -= btoc(MSGBUFSIZE);
	msgbufp = (struct msgbuf *)(MIPS_PHYS_TO_KSEG0(maxmem << PGSHIFT));
	initmsgbuf((caddr_t)msgbufp, round_page(MSGBUFSIZE));
	
	/*
	 * Allocate space for system data structures.
	 * The first available kernel virtual address is in "v".
	 * As pages of kernel virtual memory are allocated, "v" is incremented.
	 *
	 * These data structures are allocated here instead of cpu_startup()
	 * because physical memory is directly addressable. We don't have
	 * to map these into virtual address space.
	 */
	start = v;

#define	valloc(name, type, num) \
	    (name) = (type *)v; v = (caddr_t)((name)+(num))
#define	valloclim(name, type, num, lim) \
	    (name) = (type *)v; v = (caddr_t)((lim) = ((name)+(num)))
#ifdef REAL_CLISTS
	valloc(cfree, struct cblock, nclist);
#endif
	valloc(timeouts, struct timeout, ntimeout);
#ifdef SYSVSHM
	valloc(shmsegs, struct shmid_ds, shminfo.shmmni);
#endif
#ifdef SYSVSEM
	valloc(sema, struct semid_ds, seminfo.semmni);
	valloc(sem, struct sem, seminfo.semmns);
	/* This is pretty disgusting! */
	valloc(semu, int, (seminfo.semmnu * seminfo.semusz) / sizeof(int));
#endif
#ifdef SYSVMSG
	valloc(msgpool, char, msginfo.msgmax);
	valloc(msgmaps, struct msgmap, msginfo.msgseg);
	valloc(msghdrs, struct msg, msginfo.msgtql);
	valloc(msqids, struct msqid_ds, msginfo.msgmni);
#endif

#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif

	/*
	 * Determine how many buffers to allocate.
	 * We allocate more buffer space than the BSD standard of
	 * using 10% of memory for the first 2 Meg, 5% of remaining.
	 * We just allocate a flat 10%.  Ensure a minimum of 16 buffers.
	 * We allocate 1/2 as many swap buffer headers as file i/o buffers.
	 */
	if (bufpages == 0) {
		if (physmem < btoc(2 * 1024 * 1024))
			bufpages = physmem / 10;
		else
			bufpages = (btoc(2 * 1024 * 1024) + physmem) *
			    BUFCACHEPERCENT / 100;
	}
	if (nbuf == 0) {
		nbuf = bufpages;
		if (nbuf < 16)
			nbuf = 16;
	}

	/* Restrict to at most 70% filled kvm */
	if (nbuf * MAXBSIZE >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) * 7 / 10)
		nbuf = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    MAXBSIZE * 7 / 10;

	/* More buffer pages than fits into the buffers is senseless.  */
	if (bufpages > nbuf * MAXBSIZE / PAGE_SIZE)
		bufpages = nbuf * MAXBSIZE / PAGE_SIZE;

	if (nswbuf == 0) {
		nswbuf = (nbuf / 2) &~ 1;	/* force even */
		if (nswbuf > 256)
			nswbuf = 256;		/* sanity */
	}
	valloc(swbuf, struct buf, nswbuf);
	valloc(buf, struct buf, nbuf);

	/*
	 * Clear allocated memory.
	 */
	bzero(start, v - start);

	/*
	 * Initialize the virtual memory system.
	 */
	pmap_bootstrap((vm_offset_t)v);

}



/*
 * cpu_startup: allocate memory for variable-sized tables,
 * initialize cpu, and do autoconfiguration.
 */
void
cpu_startup()
{
	register unsigned i;
	register caddr_t v;
	int base, residual;
	vm_offset_t minaddr, maxaddr;
	vm_size_t size;
#ifdef DEBUG
	extern int pmapdebug;
	int opmapdebug = pmapdebug;

	pmapdebug = 0;
#endif

	for (i = 0; i < btoc(MSGBUFSIZE); i++)
		pmap_enter(pmap_kernel(), (vm_offset_t)msgbufp,
		    maxmem + i * NBPG, VM_PROT_READ|VM_PROT_WRITE, TRUE,
		    VM_PROT_READ|VM_PROT_WRITE);

	/*
	 * Good {morning,afternoon,evening,night}.
	 */
	printf(version);
	printf("real mem = %d\n", ctob(physmem));

	/*
	 * Allocate virtual address space for file I/O buffers.
	 * Note they are different than the array of headers, 'buf',
	 * and usually occupy more virtual memory than physical.
	 */
	size = MAXBSIZE * nbuf;
	buffer_map = kmem_suballoc(kernel_map, (vm_offset_t *)&buffers,
				   &maxaddr, size, TRUE);
	minaddr = (vm_offset_t)buffers;
	if (vm_map_find(buffer_map, vm_object_allocate(size), (vm_offset_t)0,
			&minaddr, size, FALSE) != KERN_SUCCESS)
		panic("startup: cannot allocate buffers");
	base = bufpages / nbuf;
	residual = bufpages % nbuf;
	if (base >= MAXBSIZE / PAGE_SIZE) {
		/* don't want to alloc more physical mem than needed */
		base = MAXBSIZE / PAGE_SIZE;
		residual = 0;
	}

	for (i = 0; i < nbuf; i++) {
		vm_size_t curbufsize;
		vm_offset_t curbuf;

		/*
		 * First <residual> buffers get (base+1) physical pages
		 * allocated for them.  The rest get (base) physical pages.
		 *
		 * The rest of each buffer occupies virtual space,
		 * but has no physical memory allocated for it.
		 */
		curbuf = (vm_offset_t)buffers + i * MAXBSIZE;
		curbufsize = PAGE_SIZE * (i < residual ? base+1 : base);
		vm_map_pageable(buffer_map, curbuf, curbuf+curbufsize, FALSE);
		vm_map_simplify(buffer_map, curbuf);
	}
	/*
	 * Allocate a submap for exec arguments.  This map effectively
	 * limits the number of processes exec'ing at any time.
	 */
	exec_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr,
				 16 * NCARGS, TRUE);
	/*
	 * Allocate a submap for physio
	 */
	phys_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr,
				 VM_PHYS_SIZE, TRUE);

	mb_map = kmem_suballoc(kernel_map, (vm_offset_t *)&mbutl, &maxaddr,
			       VM_MBUF_SIZE, FALSE);
	/*
	 * Initialize timeouts
	 */
	timeout_init();

#ifdef DEBUG
	pmapdebug = opmapdebug;
#endif
	printf("avail mem = %d\n", ptoa(cnt.v_free_count));
	printf("using %d buffers containing %d bytes of memory\n",
		nbuf, bufpages * PAGE_SIZE);

	/*
	 * Set up buffers, so they can be used to read disk labels.
	 */
	bufinit();

	/*
	 * Set up CPU-specific registers, cache, etc.
	 */
	initcpu();
}

/*
 * machine dependent system variables.
 */
cpu_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
{
#if (NLED > 0)
	int ret, oldval;
#endif

	/* all sysctl names at this level are terminal */
	if (namelen != 1)
		return (ENOTDIR);		/* overloaded */

	switch (name[0]) {
	case CPU_CONSDEV:
		return (sysctl_rdstruct(oldp, oldlenp, newp, &cn_tab->cn_dev,
		    sizeof cn_tab->cn_dev));
	case CPU_LED_BLINK:
#if (NLED > 0)
		oldval = pmax_led_blink;
		ret = sysctl_int(oldp, oldlenp, newp, newlen, &pmax_led_blink);

		/*
		 * If we were false and are now true, call led_blink().
		 * led_blink() itself will catch the other case.
		 */
		led_pmax_cycle((caddr_t *)0);
		return (ret);
#endif
	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
}

/*
 * Set registers on exec.
 * Clear all registers except sp, pc, and t9.
 * $sp is set to the stack pointer passed in.  $pc is set to the entry
 * point given by the exec_package passed in, as is $t9 (used for PIC
 * code by the MIPS elf abi).
 */
void
setregs(p, pack, stack, retval)
	register struct proc *p;
	struct exec_package *pack;
	u_long stack;
	register_t *retval;
{
	extern struct proc *machFPCurProcPtr;

	bzero((caddr_t)p->p_md.md_regs, (FSR + 1) * sizeof(int));
	p->p_md.md_regs[SP] = stack;
	p->p_md.md_regs[PC] = pack->ep_entry & ~3;
        p->p_md.md_regs[T9] = pack->ep_entry & ~3; /* abicall requirement */
	p->p_md.md_regs[PS] = PSL_USERSET;
	p->p_md.md_flags & ~MDP_FPUSED;
	if (machFPCurProcPtr == p)
		machFPCurProcPtr = (struct proc *)0;
}

/*
 * WARNING: code in locore.s assumes the layout shown for sf_signum
 * thru sf_handler so... don't screw with them!
 */
struct sigframe {
	int	sf_signum;		/* signo for handler */
	siginfo_t *sf_sip;		/* pointer to siginfo_t */
	struct	sigcontext *sf_scp;	/* context ptr for handler */
	sig_t	sf_handler;		/* handler addr for u_sigc */
	struct	sigcontext sf_sc;	/* actual context */
	siginfo_t sf_si;
};

#ifdef DEBUG
int sigdebug = 0;
int sigpid = 0;
#define SDB_FOLLOW	0x01
#define SDB_KSTACK	0x02
#define SDB_FPSTATE	0x04
#endif

/*
 * Send an interrupt to process.
 */
void
sendsig(catcher, sig, mask, code, type, val)
	sig_t catcher;
	int sig, mask;
	u_long code;
	int type;
	union sigval val;
{
	register struct proc *p = curproc;
	register struct sigframe *fp;
	register int *regs;
	register struct sigacts *psp = p->p_sigacts;
	int oonstack, fsize;
	struct sigcontext ksc;
	extern char sigcode[], esigcode[];

	regs = p->p_md.md_regs;
	oonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
	/*
	 * Allocate and validate space for the signal handler
	 * context. Note that if the stack is in data space, the
	 * call to grow() is a nop, and the copyout()
	 * will fail if the process has not already allocated
	 * the space with a `brk'.
	 */
	fsize = sizeof(struct sigframe);
	if (!(psp->ps_siginfo & sigmask(sig)))
		fsize -= sizeof(siginfo_t);
	if ((psp->ps_flags & SAS_ALTSTACK) &&
	    (psp->ps_sigstk.ss_flags & SS_ONSTACK) == 0 &&
	    (psp->ps_sigonstack & sigmask(sig))) {
		fp = (struct sigframe *)(psp->ps_sigstk.ss_sp +
					 psp->ps_sigstk.ss_size - fsize);
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
	} else
		fp = (struct sigframe *)(regs[SP] - fsize);
	if ((unsigned)fp <= USRSTACK - ctob(p->p_vmspace->vm_ssize)) 
		(void)grow(p, (unsigned)fp);
#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) ||
	    (sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
		printf("sendsig(%d): sig %d ssp %x usp %x scp %x\n",
		       p->p_pid, sig, &oonstack, fp, &fp->sf_sc);
#endif
	/*
	 * Build the signal context to be used by sigreturn.
	 */
	ksc.sc_onstack = oonstack;
	ksc.sc_mask = mask;
	ksc.sc_pc = regs[PC];
	ksc.mullo = regs [MULLO];
	ksc.mulhi = regs [MULHI];
	ksc.sc_regs[ZERO] = 0xACEDBADE;		/* magic number */
	bcopy((caddr_t)&regs[1], (caddr_t)&ksc.sc_regs[1],
		sizeof(ksc.sc_regs) - sizeof(int));
	ksc.sc_fpused = p->p_md.md_flags & MDP_FPUSED;
	if (ksc.sc_fpused) {
		extern struct proc *machFPCurProcPtr;

		/* if FPU has current state, save it first */
		if (p == machFPCurProcPtr)
			MachSaveCurFPState(p);
		bcopy((caddr_t)&p->p_md.md_regs[F0], (caddr_t)ksc.sc_fpregs,
			sizeof(ksc.sc_fpregs));
	}

	if (psp->ps_siginfo & sigmask(sig)) {
		siginfo_t si;

		initsiginfo(&si, sig, code, type, val);
		if (copyout((caddr_t)&si, (caddr_t)&fp->sf_si, sizeof si))
			goto bail;
	}

	if (copyout((caddr_t)&ksc, (caddr_t)&fp->sf_sc, sizeof(ksc))) {
bail:
		/*
		 * Process has trashed its stack; give it an illegal
		 * instruction to halt it in its tracks.
		 */
		SIGACTION(p, SIGILL) = SIG_DFL;
		sig = sigmask(SIGILL);
		p->p_sigignore &= ~sig;
		p->p_sigcatch &= ~sig;
		p->p_sigmask &= ~sig;
		psignal(p, SIGILL);
		return;
	}
	/* 
	 * Build the argument list for the signal handler.
	 */
	regs[A0] = sig;
	regs[A1] = (psp->ps_siginfo & sigmask(sig)) ? (int)&fp->sf_si : NULL;
	regs[A2] = (int)&fp->sf_sc;
	regs[A3] = (int)catcher;

	regs[PC] = (int)catcher;
	regs[T9] = (int)catcher;
	regs[SP] = (int)fp;
	/*
	 * Signal trampoline code is at base of user stack.
	 */
	regs[RA] = (int)PS_STRINGS - (esigcode - sigcode);
#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) ||
	    (sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
		printf("sendsig(%d): sig %d returns\n",
		       p->p_pid, sig);
#endif
}

/*
 * System call to cleanup state after a signal
 * has been taken.  Reset signal mask and
 * stack state from context left by sendsig (above).
 * Return to previous pc and psl as specified by
 * context left by sendsig. Check carefully to
 * make sure that the user has not modified the
 * psl to gain improper priviledges or to cause
 * a machine fault.
 */
/* ARGSUSED */
int
sys_sigreturn(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_sigreturn_args /* {
		syscallarg(struct sigcontext *) sigcntxp;
	} */ *uap = v;
	register struct sigcontext *scp;
	register int *regs;
	struct sigcontext ksc;
	int error;

	scp = SCARG(uap, sigcntxp);
#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW)
		printf("sigreturn: pid %d, scp %x\n", p->p_pid, scp);
#endif
	regs = p->p_md.md_regs;
	/*
	 * Test and fetch the context structure.
	 * We grab it all at once for speed.
	 */
	error = copyin((caddr_t)scp, (caddr_t)&ksc, sizeof(ksc));
	if (error || ksc.sc_regs[ZERO] != 0xACEDBADE) {
#ifdef DEBUG
		if (!(sigdebug & SDB_FOLLOW))
			printf("sigreturn: pid %d, scp %x\n", p->p_pid, scp);
		printf("  old sp %x ra %x pc %x\n",
			regs[SP], regs[RA], regs[PC]);
		printf("  new sp %x ra %x pc %x err %d z %x\n",
			ksc.sc_regs[SP], ksc.sc_regs[RA], ksc.sc_regs[PC],
			error, ksc.sc_regs[ZERO]);
#endif
		return (EINVAL);
	}
	scp = &ksc;
	/*
	 * Restore the user supplied information
	 */
	if (scp->sc_onstack & 01)
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
	else
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
	p->p_sigmask = scp->sc_mask &~ sigcantmask;
	regs[PC] = scp->sc_pc;
	regs[MULLO] = scp->mullo;
	regs[MULHI] = scp->mulhi;
	bcopy((caddr_t)&scp->sc_regs[1], (caddr_t)&regs[1],
		sizeof(scp->sc_regs) - sizeof(int));
	if (scp->sc_fpused)
		bcopy((caddr_t)scp->sc_fpregs, (caddr_t)&p->p_md.md_regs[F0],
			sizeof(scp->sc_fpregs));
	return (EJUSTRETURN);
}

int	waittime = -1;
struct pcb dumppcb;


/*
 * These variables are needed by /sbin/savecore
 */
int	dumpmag = (int)0x8fca0101;	/* magic number for savecore */
int	dumpsize = 0;		/* also for savecore */
long	dumplo = 0;

void
dumpconf()
{
	int nblks;

	dumpsize = physmem;
	if (dumpdev != NODEV && bdevsw[major(dumpdev)].d_psize) {
		nblks = (*bdevsw[major(dumpdev)].d_psize)(dumpdev);
		if (dumpsize > btoc(dbtob(nblks - dumplo)))
			dumpsize = btoc(dbtob(nblks - dumplo));
		else if (dumplo == 0)
			dumplo = nblks - btodb(ctob(physmem));
	}
	/*
	 * Don't dump on the first block
	 * in case the dump device includes a disk label.
	 */
	if (dumplo < btodb(PAGE_SIZE))
		dumplo = btodb(PAGE_SIZE);
}

/*
 * Doadump comes here after turning off memory management and
 * getting on the dump stack, either when called above, or by
 * the auto-restart code.
 */
void
dumpsys()
{
	int error;
	extern int msgbufmapped;

	/* Save registers. */
	savectx((struct user *)&dumppcb, 0);

	msgbufmapped = 0;
	if (dumpdev == NODEV)
		return;
	/*
	 * For dumps during autoconfiguration,
	 * if dump device has already configured...
	 */
	if (dumpsize == 0)
		dumpconf();
	if (dumplo < 0)
		return;
	printf("\ndumping to dev %x, offset %d\n", dumpdev, dumplo);
	printf("dump ");
	/*
	 * XXX
	 * All but first arguments to  dump() bogus.
	 * What should blkno, va, size be?
	 */
	error = (*bdevsw[major(dumpdev)].d_dump)(dumpdev, 0, 0, 0);
	switch (error) {

	case ENXIO:
		printf("device bad\n");
		break;

	case EFAULT:
		printf("device not ready\n");
		break;

	case EINVAL:
		printf("area improper\n");
		break;

	case EIO:
		printf("i/o error\n");
		break;

	default:
		printf("error %d\n", error);
		break;

	case 0:
		printf("succeeded\n");
	}
}


/*
 * call PROM to halt or reboot.
 */
volatile void
prom_halt(howto, bootstr)
	int howto;
	char *bootstr;

{
	if (callv != &callvec) {
		if (howto & RB_HALT)
			(*callv->_rex)('h');
		else {
			(*callv->_rex)('b');
		}
	} else if (howto & RB_HALT) {
		volatile void (*f)() = (volatile void (*)())DEC_PROM_REINIT;

		(*f)();	/* jump back to prom monitor */
	} else {
		volatile void (*f)() = (volatile void (*)())DEC_PROM_AUTOBOOT;
		(*f)();	/* jump back to prom monitor and do 'auto' cmd */
	}

	while(1) ;	/* fool gcc */
	/*NOTREACHED*/
}

void
boot(howto)
	register int howto;
{
	extern int cold;

	/* take a snap shot before clobbering any registers */
	if (curproc)
		savectx(curproc->p_addr, 0);

#ifdef DEBUG
	if (panicstr)
		stacktrace();
#endif

	/* If system is cold, just halt. */
	if (cold) {
		howto |= RB_HALT;
		goto haltsys;
	}

	/* If "always halt" was specified as a boot flag, obey. */
	if ((boothowto & RB_HALT) != 0)
		howto |= RB_HALT;

	boothowto = howto;
	if ((howto & RB_NOSYNC) == 0 && waittime < 0) {
		/*
		 * Synchronize the disks....
		 */
		waittime = 0;
		vfs_shutdown();

		/*
		 * If we've been adjusting the clock, the todr
		 * will be out of synch; adjust it now unless
		 * the system was sitting in ddb.
		 */
		if ((howto & RB_TIMEBAD) == 0) {
			resettodr();
		} else {
			printf("WARNING: not updating battery clock\n");
		}
	}

	/* Disable interrupts. */
	splhigh();

	/* If rebooting and a dump is requested do it. */
#if 0
	if ((howto & (RB_DUMP | RB_HALT)) == RB_DUMP)
#else
	if (howto & RB_DUMP)
#endif
		dumpsys();

	/* run any shutdown hooks */
	doshutdownhooks();

haltsys:

	/* Finally, halt/reboot the system. */
	printf("%s\n\n", howto & RB_HALT ? "halted." : "rebooting...");
	prom_halt(howto & RB_HALT, NULL);
	/*NOTREACHED*/
}


/*
 * Read a high-resolution clock, if one is available, and return
 * the current microsecond offset from time-of-day.
 */

#ifndef DS5000_240
# define clkread() (0)
#else

/*
 * IOASIC TC cycle counter, latched on every interrupt from RTC chip.
 */
u_long latched_cycle_cnt;

/*
 * On a Decstation 5000/240,  use the turbochannel bus-cycle counter
 * to interpolate micro-seconds since the  last RTC clock tick.
 * The interpolation base is the copy of the bus cycle-counter taken
 * by the RTC interrupt handler.
 * XXX on XINE, use the microsecond free-running counter.
 *
 */
static inline u_long
clkread()
{

	register u_long usec, cycles;	/* really 32 bits? */

	/* only support 5k/240 TC bus counter */
	if (pmax_boardtype != DS_3MAXPLUS) {
		return (0);
	}

	cycles = *(u_long*)IOASIC_REG_CTR(ioasic_base);

	/* Compute difference in cycle count from last hardclock() to now */
#if 1
	/* my code, using u_ints */
	cycles = cycles - latched_cycle_cnt;
#else
	/* Mills code, using (signed) ints */
	if (cycles >= latched_cycle_cnt)
		cycles = cycles - latched_cycle_cnt;
	else
		cycles = latched_cycle_cnt - cycles;
#endif

	/*
	 * Scale from 40ns to microseconds.
	 * Avoid a kernel FP divide (by 25) using the approximation 
	 * 1/25 = 40/1000 =~ 41/ 1024, which is good to 0.0975 %
	 */
	usec = cycles + (cycles << 3) + (cycles << 5);
	usec = usec >> 10;

#ifdef CLOCK_DEBUG
	if (usec > 3906 +4) {
		 addlog("clkread: usec %d, counter=%lx\n",
			 usec, latched_cycle_cnt);
		stacktrace();
	}
#endif /*CLOCK_DEBUG*/
	return usec;
}

#if 0
void
microset()
{
		latched_cycle_cnt = *(u_long*)(IOASIC_REG_CTR(ioasic_base));
}
#endif
#endif /*DS5000_240*/


/*
 * Return the best possible estimate of the time in the timeval
 * to which tvp points.  Unfortunately, we can't read the hardware registers.
 * We guarantee that the time will be greater than the value obtained by a
 * previous call.
 */
void
microtime(tvp)
	register struct timeval *tvp;
{
	int s = splclock();
	static struct timeval lasttime;
	register long usec;


	*tvp = time;
	tvp->tv_usec += clkread();
	if (tvp->tv_usec >= 1000000) {
		tvp->tv_usec -= 1000000;
		tvp->tv_sec++;
	}

	if (tvp->tv_sec == lasttime.tv_sec &&
	    tvp->tv_usec <= lasttime.tv_usec &&
	    (tvp->tv_usec = lasttime.tv_usec + 1) > 1000000) {
		tvp->tv_sec++;
		tvp->tv_usec -= 1000000;
	}
	lasttime = *tvp;
	splx(s);
}

int
initcpu()
{
	register volatile struct chiptime *c;
	int i;

#if defined(DS5000_200) || defined(DS5000_25) || defined(DS5000_100) || \
    defined(DS5000_240)
	/* Reset after bus errors during probe */
	if (Mach_reset_addr) {
		*Mach_reset_addr = 0;
		wbflush();
	}
#endif

	/* clear any pending interrupts */
	switch (pmax_boardtype) {
	case DS_PMAX:
		break;	/* nothing to  do for KN01. */
	case DS_3MAXPLUS:
	case DS_3MIN:
	case DS_MAXINE:
		*(u_int *)IOASIC_REG_INTR(ioasic_base) = 0;
		break;
	case DS_3MAX:
		*(u_int *)MIPS_PHYS_TO_KSEG1(KN02_SYS_CHKSYN) = 0;
		wbflush();
		break;
	default:
		printf("initcpu(): unknown system type 0x%x\n", pmax_boardtype);
		break;
	}

	/*
	 * With newconf, this should be  done elswhere, but without it
	 * we hang (?)
	 */
#if 1 /*XXX*/
	/* disable clock interrupts (until startrtclock()) */
	if (Mach_clock_addr) {
	c = Mach_clock_addr;
	c->regb = REGB_DATA_MODE | REGB_HOURS_FORMAT;
	i = c->regc;
	}
	return (i);
#endif
}

/*
 * Convert an ASCII string into an integer.
 */
int
atoi(s)
	char *s;
{
	int c;
	unsigned base = 10, d;
	int neg = 0, val = 0;

	if (s == 0 || (c = *s++) == 0)
		goto out;

	/* skip spaces if any */
	while (c == ' ' || c == '\t')
		c = *s++;

	/* parse sign, allow more than one (compat) */
	while (c == '-') {
		neg = !neg;
		c = *s++;
	}

	/* parse base specification, if any */
	if (c == '0') {
		c = *s++;
		switch (c) {
		case 'X':
		case 'x':
			base = 16;
			break;
		case 'B':
		case 'b':
			base = 2;
			break;
		default:
			base = 8;
		}
	}

	/* parse number proper */
	for (;;) {
		if (c >= '0' && c <= '9')
			d = c - '0';
		else if (c >= 'a' && c <= 'z')
			d = c - 'a' + 10;
		else if (c >= 'A' && c <= 'Z')
			d = c - 'A' + 10;
		else
			break;
		val *= base;
		val += d;
		c = *s++;
	}
	if (neg)
		val = -val;
out:
	return val;	
}


#ifdef DS3100

/*
 * Enable an interrupt from a slot on the KN01 internal bus.
 *
 * The 4.4bsd kn01 interrupt handler hard-codes r3000 CAUSE register
 * bits to particular device interrupt handlers.  We may choose to store
 * function and softc pointers at some future point.
 */
void
kn01_enable_intr(slotno, handler, sc, on)
	register unsigned int slotno;
	int (*handler) __P((void* softc));
	void *sc;
	int on;
{
	/*
	 */
	if (on)  {
		tc_slot_info[slotno].intr = handler;
		tc_slot_info[slotno].sc = sc;
	} else {
		tc_slot_info[slotno].intr = 0;
		tc_slot_info[slotno].sc = 0;
	}
}
#endif /* DS3100 */


#ifdef DS5000_200

/*
 * Enable/Disable interrupts for a TURBOchannel slot on the 3MAX.
 */
void
kn02_enable_intr(slotno, handler, sc, on)
	register u_int slotno;
	int (*handler) __P((void* softc));
	void *sc;
	int on;
{
	register volatile int *p_csr =
		(volatile int *)MIPS_PHYS_TO_KSEG1(KN02_SYS_CSR);
	int csr;
	int s;

#if 0
	printf("3MAX enable_intr: imask %x, %sabling slot %d, sc %p\n",
	       kn03_tc3_imask, (on? "en" : "dis"), slotno, sc);
#endif

	if (slotno > TC_MAX_LOGICAL_SLOTS)
		panic("kn02_enable_intr: bogus slot %d", slotno);

	if (on)  {
		/*printf("kn02: slot %d handler 0x%x\n", slotno, handler);*/
		tc_slot_info[slotno].intr = handler;
		tc_slot_info[slotno].sc = sc;
	} else {
		tc_slot_info[slotno].intr = 0;
		tc_slot_info[slotno].sc = 0;
	}

	slotno = 1 << (slotno + KN02_CSR_IOINTEN_SHIFT);
	s = Mach_spl0();
	csr = *p_csr & ~(KN02_CSR_WRESERVED | 0xFF);
	if (on)
		*p_csr = csr | slotno;
	else
		*p_csr = csr & ~slotno;
	splx(s);
}
#endif /*DS5000_200*/

#ifdef DS5000_100
/*
 *	Object:
 *		kmin_enable_intr		EXPORTED function
 *
 *	Enable/Disable interrupts from a TURBOchannel slot.
 *
 *	We pretend we actually have 8 slots even if we really have
 *	only 4: TCslots 0-2 maps to slots 0-2, TCslot3 maps to
 *	slots 3-7 (see pmax/tc/ds-asic-conf.c).
 *
 *	3MIN TURBOchannel interrupts are unlike other decstations,
 *	in that interrupt requests from the option slots (0-2) map
 *	directly to R3000 interrupt lines, not to IOASIC interrupt
 *	bits.  If it weren't for that, the 3MIN and 3MAXPLUS could
 *	share   interrupt handlers and interrupt-enable code
 */
void
kmin_enable_intr(slotno, handler, sc, on)
	register unsigned int slotno;
	int (*handler) __P((void* softc));
	void *sc;
	int on;
{
	register unsigned mask;

	switch (slotno) {
		/* slots 0-2 don't interrupt through the IOASIC. */
	case 0:
		mask = MIPS_INT_MASK_0;	break;
	case 1:
		mask = MIPS_INT_MASK_1; break;
	case 2:
		mask = MIPS_INT_MASK_2; break;

	case KMIN_SCSI_SLOT:
		mask = (KMIN_INTR_SCSI | KMIN_INTR_SCSI_PTR_LOAD |
			KMIN_INTR_SCSI_OVRUN | KMIN_INTR_SCSI_READ_E);
		break;

	case KMIN_LANCE_SLOT:
		mask = KMIN_INTR_LANCE;
		break;
	case KMIN_SCC0_SLOT:
		mask = KMIN_INTR_SCC_0;
		break;
	case KMIN_SCC1_SLOT:
		mask = KMIN_INTR_SCC_1;
		break;
	case KMIN_ASIC_SLOT:
		mask = KMIN_INTR_ASIC;
		break;
	default:
		return;
	}

#if defined(DEBUG) || defined(DIAGNOSTIC)
	printf("3MIN: imask %x, %sabling slot %d, sc %x addr 0x%x\n",
	       kmin_tc3_imask, (on? "en" : "dis"), slotno, sc, handler);
#endif

	/*
	 * Enable the interrupt  handler, and if it's an IOASIC
	 * slot, set the IOASIC interrupt mask.
	 * Otherwise, set the appropriate spl level in the R3000
	 * register.
	 * Be careful to set handlers  before enabling, and disable
	 * interrupts before clearing handlers.
	 */

	if (on) {
		/* Set the interrupt handler and argument ... */
		tc_slot_info[slotno].intr = handler;
		tc_slot_info[slotno].sc = sc;

		/* ... and set the relevant mask */
		if (slotno <= 2) {
			/* it's an option slot */
			int s = splhigh();
			printf("Enabling 3MIN tcslot %d (UNTESTED)\n", slotno);
			s  |= mask;
			splx(s);
		} else {
			/* it's a baseboard device going via the ASIC */
			kmin_tc3_imask |= mask;
		}
	} else {
		/* Clear the relevant mask... */
		if (slotno <= 2) {	
			/* it's an option slot */
			int s = splhigh();
			printf("kmin_intr: cannot disable option slot %d\n",
				slotno);
			s &= ~mask;
			splx(s);
		} else {
			/* it's a baseboard device going via the ASIC */
			kmin_tc3_imask &= ~mask;
		}
		/* ... and clear the handler */
		tc_slot_info[slotno].intr = 0;
		tc_slot_info[slotno].sc = 0;
	}
}
#endif /*DS5000_100*/


#ifdef DS5000_25
/*
 *	Object:
 *		xine_enable_intr		EXPORTED function
 *
 *	Enable/Disable interrupts from a TURBOchannel slot.
 *
 *	We pretend we actually have 11 slots even if we really have
 *	only 3: TCslots 0-1 maps to slots 0-1, TCslot 2 is used for
 *	the system (TCslot3), TCslot3 maps to slots 3-10
 *	 (see pmax/tc/ds-asic-conf.c).
 *	Note that all these interrupts come in via the IMR.
 */
void
xine_enable_intr(slotno, handler, sc, on)
	register unsigned int slotno;
	int (*handler) __P((void* softc));
	void *sc;
	int on;
{
	register unsigned mask;

	switch (slotno) {
	case 0:			/* a real slot, but  */
		mask = XINE_INTR_TC_0;
		break;
	case 1:			/* a real slot, but */
		mask = XINE_INTR_TC_1;
		break;
	case XINE_FLOPPY_SLOT:
		mask = XINE_INTR_FLOPPY;
		break;
	case XINE_SCSI_SLOT:
		mask = (XINE_INTR_SCSI | XINE_INTR_SCSI_PTR_LOAD |
			XINE_INTR_SCSI_OVRUN | XINE_INTR_SCSI_READ_E);
		break;
	case XINE_LANCE_SLOT:
		mask = XINE_INTR_LANCE;
		break;
	case XINE_SCC0_SLOT:
		mask = XINE_INTR_SCC_0;
		break;
	case XINE_DTOP_SLOT:
		mask = XINE_INTR_DTOP_RX;
		break;
	case XINE_ISDN_SLOT:
		mask = XINE_INTR_ISDN;
		break;
	case XINE_ASIC_SLOT:
		mask = XINE_INTR_ASIC;
		break;
	default:
		return;/* ignore */
	}

	if (on) {
		xine_tc3_imask |= mask;
		tc_slot_info[slotno].intr = handler;
		tc_slot_info[slotno].sc = sc;
	} else {
		xine_tc3_imask &= ~mask;
		tc_slot_info[slotno].intr = 0;
		tc_slot_info[slotno].sc = 0;
	}
	*(u_int *)IOASIC_REG_IMSK(ioasic_base) = xine_tc3_imask;
}
#endif /*DS5000_25*/

#ifdef DS5000_240
void
kn03_tc_reset()
{
/*
	 * Reset interrupts, clear any errors from newconf probes
	 */
	*(u_int *)IOASIC_REG_INTR(ioasic_base) = 0;
	*(unsigned *)MIPS_PHYS_TO_KSEG1(KN03_SYS_ERRADR) = 0;
}


/*
 *	Object:
 *		kn03_enable_intr		EXPORTED function
 *
 *	Enable/Disable interrupts from a TURBOchannel slot.
 *
 *	We pretend we actually have 8 slots even if we really have
 *	only 4: TCslots 0-2 maps to slots 0-2, TCslot3 maps to
 *	slots 3-7 (see pmax/tc/ds-asic-conf.c).
 */
void
kn03_enable_intr(slotno, handler, sc, on)
	register unsigned int slotno;
	int (*handler) __P((void* softc));
	void *sc;
	int on;
{
	register unsigned mask;

#if 0
	printf("3MAXPLUS: imask %x, %sabling slot %d, unit %d addr 0x%x\n",
	       kn03_tc3_imask, (on? "en" : "dis"), slotno, unit, handler);
#endif

	switch (slotno) {
	case 0:
		mask = KN03_INTR_TC_0;
		break;
	case 1:
		mask = KN03_INTR_TC_1;
		break;
	case 2:
		mask = KN03_INTR_TC_2;
		break;
	case KN03_SCSI_SLOT:
		mask = (KN03_INTR_SCSI | KN03_INTR_SCSI_PTR_LOAD |
			KN03_INTR_SCSI_OVRUN | KN03_INTR_SCSI_READ_E);
		break;
	case KN03_LANCE_SLOT:
		mask = KN03_INTR_LANCE;
		mask |= IOASIC_INTR_LANCE_READ_E;
		break;
	case KN03_SCC0_SLOT:
		mask = KN03_INTR_SCC_0;
		break;
	case KN03_SCC1_SLOT:
		mask = KN03_INTR_SCC_1;
		break;
	case KN03_ASIC_SLOT:
		mask = KN03_INTR_ASIC;
		break;
	default:
#ifdef DIAGNOSTIC
		printf("warning: enabling unknown intr %x\n", slotno);
#endif
		goto done;
	}
	if (on) {
		kn03_tc3_imask |= mask;
		tc_slot_info[slotno].intr = handler;
		tc_slot_info[slotno].sc = sc;

	} else {
		kn03_tc3_imask &= ~mask;
		tc_slot_info[slotno].intr = 0;
		tc_slot_info[slotno].sc = 0;
	}
done:
	*(u_int *)IOASIC_REG_IMSK(ioasic_base) = kn03_tc3_imask;
	wbflush();
}
#endif /* DS5000_240 */


/*
 * Initialize the I/O asic
 */
static void
asic_init(isa_maxine)
	int isa_maxine;
{
	volatile u_int *decoder;

	/* These are common between 3min and maxine */
	decoder = (volatile u_int *)IOASIC_REG_LANCE_DECODE(ioasic_base);
	*decoder = KMIN_LANCE_CONFIG;

	/* set the SCSI DMA configuration map */
	decoder = (volatile u_int *) IOASIC_REG_SCSI_DECODE(ioasic_base);
	(*decoder) = 0x00000000e;
}
@


1.30
log
@convert mbuf and cluster allocation to pool, mostly from NetBSD
okay art@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.29 2001/05/12 22:47:08 miod Exp $	*/
@


1.29
log
@Do not use curproc before it gets initialized.
From niklas@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.28 2001/05/05 22:34:09 art Exp $	*/
a857 7
	/*
	 * Finally, allocate mbuf pool.  Since mclrefcnt is an off-size
	 * we use the more space efficient malloc in place of kmem_alloc.
	 */
	mclrefcnt = (char *)malloc(NMBCLUSTERS+PAGE_SIZE/MCLBYTES,
				   M_MBUF, M_NOWAIT);
	bzero(mclrefcnt, NMBCLUSTERS+PAGE_SIZE/MCLBYTES);
@


1.28
log
@Rename configure() to cpu_configure().
Move it from cpu_startup() to main().
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.27 2001/05/05 20:56:49 art Exp $	*/
d351 2
a352 2
	curproc->p_addr = proc0paddr = (struct user *)v;
	curproc->p_md.md_regs = proc0paddr->u_pcb.pcb_regs;
d357 1
a357 1
			curproc->p_md.md_upte[i] = firstaddr | PG_V | PG_M);
@


1.27
log
@Get rid of CLSIZE and all related stuff.
CLSIZE -> 1
CLBYTES -> PAGE_SIZE
OLOFSET -> PAGE_MASK
etc.
At the same time some archs needed some cleaning in vmparam.h so that
goes in at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.26 2000/11/08 14:38:23 art Exp $	*/
a887 5

	/*
	 * Configure the system.
	 */
	configure();
@


1.26
log
@Code that I will forget to change when I convert pmax to UVM.
Better to commit it now.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.25 2000/10/27 00:16:16 mickey Exp $	*/
d737 1
a737 1
			bufpages = physmem / (10 * CLSIZE);
d740 1
a740 1
			    BUFCACHEPERCENT / (100 * CLSIZE);
d755 2
a756 2
	if (bufpages > nbuf * MAXBSIZE / CLBYTES)
		bufpages = nbuf * MAXBSIZE / CLBYTES;
d824 1
a824 1
	if (base >= MAXBSIZE / CLBYTES) {
d826 1
a826 1
		base = MAXBSIZE / CLBYTES;
d842 1
a842 1
		curbufsize = CLBYTES * (i < residual ? base+1 : base);
d862 1
a862 1
	mclrefcnt = (char *)malloc(NMBCLUSTERS+CLBYTES/MCLBYTES,
d864 1
a864 1
	bzero(mclrefcnt, NMBCLUSTERS+CLBYTES/MCLBYTES);
d877 1
a877 1
		nbuf, bufpages * CLBYTES);
d1191 1
a1191 1
	 * Don't dump on the first CLBYTES (why CLBYTES?)
d1194 2
a1195 2
	if (dumplo < btodb(CLBYTES))
		dumplo = btodb(CLBYTES);
@


1.25
log
@more precise BUFCACHEPERCENT calculations.
from gluk@@ptci.ru; deraadt@@ and niklas@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.24 2000/07/04 05:46:23 maja Exp $	*/
d155 1
d157 1
d653 1
d666 1
@


1.24
log
@Make dmesg and /kern/msgbuf work on pmax. Thanks art@@ for help with mem.c. ok miod@@. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d735 2
a736 2
			bufpages = (btoc(2 * 1024 * 1024) + physmem) /
			    ((100/BUFCACHEPERCENT) * CLSIZE);
@


1.23
log
@New API for timeouts. Replaces the old timeout()/untimeout() API and
makes it the callers responsibility to allocate resources for the
timeouts.

This is a KISS implementation and does _not_ solve the problems of slow
handling of a large number of pending timeouts (this will be solved in
future work) (although hardclock is now guarateed to take constant time
for handling of timeouts).

Old timeout() and untimeout() are implemented as wrappers around the new
API and kept for compatibility. They will be removed as soon as all
subsystems are converted to use the new API.
@
text
@d1 1
a150 1
int	msgbufmapped = 0;	/* set when safe to use msgbuf */
d681 1
a681 1
	maxmem -= btoc(sizeof (struct msgbuf));
d683 2
a684 2
	msgbufmapped = 1;

d795 5
d1203 1
@


1.23.2.1
log
@Pull in patch from current:
Errata:
As originally shipped, the pmax port would fail to install due to /kern/msgbuf bugs.
Fix (maja):
Make dmesg and /kern/msgbuf work on pmax. Thanks art@@ for help with mem.c. ok miod
@@. -moj
@
text
@a0 1
/*	$OpenBSD: machdep.c,v 1.24 2000/07/04 05:46:23 maja Exp $	*/
d150 1
d681 1
a681 1
	maxmem -= btoc(MSGBUFSIZE);
d683 2
a684 2
	initmsgbuf((caddr_t)msgbufp, round_page(MSGBUFSIZE));
	
a794 5
	for (i = 0; i < btoc(MSGBUFSIZE); i++)
		pmap_enter(pmap_kernel(), (vm_offset_t)msgbufp,
		    maxmem + i * NBPG, VM_PROT_READ|VM_PROT_WRITE, TRUE,
		    VM_PROT_READ|VM_PROT_WRITE);

a1197 1
	extern int msgbufmapped;
@


1.22
log
@Add new vm_swap code for dynamic swap.  From netbsd, munged some by me, and
others.   syscall commit pending.
@
text
@d57 1
a57 1
#include <sys/callout.h>
d703 1
a703 1
	valloc(callout, struct callout, ncallout);
d859 1
a859 1
	 * Initialize callouts
d861 1
a861 4
	callfree = callout;
	for (i = 1; i < ncallout; i++)
		callout[i-1].c_next = &callout[i];
	callout[i-1].c_next = NULL;
@


1.22.4.1
log
@Sync with -current
@
text
@d57 1
a57 1
#include <sys/timeout.h>
d703 1
a703 1
	valloc(timeouts, struct timeout, ntimeout);
d859 1
a859 1
	 * Initialize timeouts
d861 4
a864 1
	timeout_init();
@


1.22.4.2
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@a0 1
/*	$OpenBSD: machdep.c,v 1.26 2000/11/08 14:38:23 art Exp $	*/
d150 1
a154 1
#ifndef UVM
a155 1
#endif
a650 1
#ifndef UVM
a662 1
#endif
d681 1
a681 1
	maxmem -= btoc(MSGBUFSIZE);
d683 2
a684 2
	initmsgbuf((caddr_t)msgbufp, round_page(MSGBUFSIZE));
	
d735 2
a736 2
			bufpages = (btoc(2 * 1024 * 1024) + physmem) *
			    BUFCACHEPERCENT / (100 * CLSIZE);
a794 5
	for (i = 0; i < btoc(MSGBUFSIZE); i++)
		pmap_enter(pmap_kernel(), (vm_offset_t)msgbufp,
		    maxmem + i * NBPG, VM_PROT_READ|VM_PROT_WRITE, TRUE,
		    VM_PROT_READ|VM_PROT_WRITE);

a1197 1
	extern int msgbufmapped;
@


1.22.4.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.22.4.2 2001/04/18 16:12:47 niklas Exp $	*/
@


1.21
log
@panic prints a newline for you, don't do it in the panic string
@
text
@a703 1
	valloc(swapmap, struct map, nswapmap = maxproc * 2);
@


1.20
log
@revert pmax machdep.c too (Warner missed this one)
@
text
@d1618 1
a1618 1
		panic("kn02_enable_intr: bogus slot %d\n", slotno);
@


1.19
log
@Real trapframe and no more __FORK_BRAINDAMAGE
@
text
@d82 1
a82 2
#include <machine/regnum.h>
#include <machine/frame.h>
d350 1
a350 1
	curproc->p_md.md_regs = &proc0paddr->u_pcb.pcb_regs;
d367 1
a367 1
	nullproc.p_md.md_regs = &nullproc.p_addr->u_pcb.pcb_regs;
d949 4
a952 4
	p->p_md.md_regs->sp = stack;
	p->p_md.md_regs->pc = pack->ep_entry & ~3;
        p->p_md.md_regs->t9 = pack->ep_entry & ~3; /* abicall requirement */
	p->p_md.md_regs->sr = PSL_USERSET;
d990 3
a992 3
	struct proc *p = curproc;
	struct sigframe *fp;
	struct trap_frame *regs;
d1017 1
a1017 1
		fp = (struct sigframe *)(regs->sp - fsize);
d1031 3
a1033 3
	ksc.sc_pc = regs->pc;
	ksc.mullo = regs->mullo;
	ksc.mulhi = regs->mulhi;
d1035 1
a1035 1
	bcopy((caddr_t)&regs->ast, (caddr_t)&ksc.sc_regs[1],
d1044 1
a1044 1
		bcopy((caddr_t)&p->p_md.md_regs->f0, (caddr_t)ksc.sc_fpregs,
d1073 8
a1080 8
	regs->a0 = sig;
	regs->a1 = (psp->ps_siginfo & sigmask(sig)) ? (int)&fp->sf_si : NULL;
	regs->a2 = (int)&fp->sf_sc;
	regs->a3 = (int)catcher;

	regs->pc = (int)catcher;
	regs->t9 = (int)catcher;
	regs->sp = (int)fp;
d1084 1
a1084 1
	regs->ra = (int)PS_STRINGS - (esigcode - sigcode);
d1113 2
a1114 2
	struct sigcontext *scp;
	struct trap_frame *regs;
d1134 1
a1134 1
			regs->sp, regs->ra, regs->pc);
d1150 4
a1153 4
	regs->pc = scp->sc_pc;
	regs->mullo = scp->mullo;
	regs->mulhi = scp->mulhi;
	bcopy((caddr_t)&scp->sc_regs[1], (caddr_t)&regs->ast,
d1156 1
a1156 1
		bcopy((caddr_t)scp->sc_fpregs, (caddr_t)&p->p_md.md_regs->f0,
@


1.18
log
@LED blinker for the back panel leds on the 2100/3100.
@
text
@d82 2
a83 1
#include <machine/reg.h>
d351 1
a351 1
	curproc->p_md.md_regs = proc0paddr->u_pcb.pcb_regs;
d368 1
a368 1
	nullproc.p_md.md_regs = nullproc.p_addr->u_pcb.pcb_regs;
d950 4
a953 4
	p->p_md.md_regs[SP] = stack;
	p->p_md.md_regs[PC] = pack->ep_entry & ~3;
        p->p_md.md_regs[T9] = pack->ep_entry & ~3; /* abicall requirement */
	p->p_md.md_regs[PS] = PSL_USERSET;
d991 3
a993 3
	register struct proc *p = curproc;
	register struct sigframe *fp;
	register int *regs;
d1018 1
a1018 1
		fp = (struct sigframe *)(regs[SP] - fsize);
d1032 3
a1034 3
	ksc.sc_pc = regs[PC];
	ksc.mullo = regs [MULLO];
	ksc.mulhi = regs [MULHI];
d1036 1
a1036 1
	bcopy((caddr_t)&regs[1], (caddr_t)&ksc.sc_regs[1],
d1045 1
a1045 1
		bcopy((caddr_t)&p->p_md.md_regs[F0], (caddr_t)ksc.sc_fpregs,
d1074 8
a1081 8
	regs[A0] = sig;
	regs[A1] = (psp->ps_siginfo & sigmask(sig)) ? (int)&fp->sf_si : NULL;
	regs[A2] = (int)&fp->sf_sc;
	regs[A3] = (int)catcher;

	regs[PC] = (int)catcher;
	regs[T9] = (int)catcher;
	regs[SP] = (int)fp;
d1085 1
a1085 1
	regs[RA] = (int)PS_STRINGS - (esigcode - sigcode);
d1114 2
a1115 2
	register struct sigcontext *scp;
	register int *regs;
d1135 1
a1135 1
			regs[SP], regs[RA], regs[PC]);
d1151 4
a1154 4
	regs[PC] = scp->sc_pc;
	regs[MULLO] = scp->mullo;
	regs[MULHI] = scp->mulhi;
	bcopy((caddr_t)&scp->sc_regs[1], (caddr_t)&regs[1],
d1157 1
a1157 1
		bcopy((caddr_t)scp->sc_fpregs, (caddr_t)&p->p_md.md_regs[F0],
@


1.17
log
@new cpureg.h from NetBSD plus modifications to use the changed macro names
@
text
@d90 1
a105 1

d115 1
d902 3
d914 12
@


1.16
log
@add missing cast
@
text
@d350 1
a350 1
	firstaddr = MACH_CACHED_TO_PHYS(v);
d353 1
a353 1
			(UADDR + (i << PGSHIFT)) | (1 << VMMACH_TLB_PID_SHIFT),
d401 1
a401 1
	physmem_boardmax = MACH_MAX_MEM_ADDR;
d422 1
a422 1
			MACH_PHYS_TO_UNCACHED(KN01_SYS_CLOCK);
d443 1
a443 1
			MACH_PHYS_TO_UNCACHED(KN01_SYS_CLOCK);
d452 1
a452 1
			(volatile int *)MACH_PHYS_TO_UNCACHED(KN02_SYS_CSR);
d455 1
a455 1
		    (unsigned *)MACH_PHYS_TO_UNCACHED(KN02_SYS_ERRADR);
d475 1
a475 1
			MACH_PHYS_TO_UNCACHED(KN02_SYS_CLOCK);
d489 1
a489 1
		ioasic_base = MACH_PHYS_TO_UNCACHED(KMIN_SYS_ASIC);
d508 1
a508 1
			MACH_PHYS_TO_UNCACHED(KMIN_SYS_CLOCK);
d519 1
a519 1
		    (u_int*)MACH_PHYS_TO_UNCACHED(KMIN_REG_TIMEOUT);
d532 1
a532 1
		if ((*(int*)(MACH_PHYS_TO_UNCACHED(KMIN_REG_MSR)) &
d535 1
a535 1
		physmem_boardmax = MACH_PHYS_TO_UNCACHED(physmem_boardmax);
d546 1
a546 1
		ioasic_base = MACH_PHYS_TO_UNCACHED(XINE_SYS_ASIC);
d556 1
a556 1
			MACH_PHYS_TO_UNCACHED(XINE_SYS_CLOCK);
d565 1
a565 1
		    (u_int*)MACH_PHYS_TO_UNCACHED(XINE_REG_TIMEOUT);
d578 1
a578 1
		ioasic_base = MACH_PHYS_TO_UNCACHED(KN03_SYS_ASIC);
d582 1
a582 1
		    (u_int *)MACH_PHYS_TO_UNCACHED(KN03_SYS_ERRADR);
d596 1
a596 1
			MACH_PHYS_TO_UNCACHED(KN03_SYS_CLOCK);
d626 1
a626 1
	cp = (char *)MACH_PHYS_TO_UNCACHED(physmem << PGSHIFT);	
d681 1
a681 1
	msgbufp = (struct msgbuf *)(MACH_PHYS_TO_CACHED(maxmem << PGSHIFT));
d1465 1
a1465 1
		*(u_int *)MACH_PHYS_TO_UNCACHED(KN02_SYS_CHKSYN) = 0;
d1592 1
a1592 1
		(volatile int *)MACH_PHYS_TO_UNCACHED(KN02_SYS_CSR);
d1653 1
a1653 1
		mask = MACH_INT_MASK_0;	break;
d1655 1
a1655 1
		mask = MACH_INT_MASK_1; break;
d1657 1
a1657 1
		mask = MACH_INT_MASK_2; break;
d1807 1
a1807 1
	*(unsigned *)MACH_PHYS_TO_UNCACHED(KN03_SYS_ERRADR) = 0;
@


1.15
log
@go back to versions before the last NetBSD merge - it has broken
current kernels somehow - per or me has to look deeper at the diffs
@
text
@d1188 1
a1188 1
	savectx(&dumppcb, 0);
@


1.14
log
@update the pmax specific stuff to NetBSD-current as of about 970608 - some
cosmetic things will follow together with an update to an exact NETBSD_CU-
RRENT_xxxxxx level
@
text
@d1 1
a1 1
/*	$NetBSD: machdep.c,v 1.76 1997/05/31 20:33:30 mhitch Exp $	*/
a79 1
#include <ufs/mfs/mfs_extern.h>		/* mfs_initminiroot() */
d85 1
a102 1
#include <pmax/pmax/trap.h>		/* mboard-specific interrupt fns */
d105 1
a117 1
#if defined(DS5000_25) || defined(DS5000_100) || defined(DS5000_240)
a127 1
#endif
d165 4
d170 1
d180 3
a182 25
/*
 * Interrupt-blocking functions defined in locore. These names aren't used
 * directly except here and in interrupt handlers.
 */

/* Block out one hardware interrupt-enable bit. */
extern int	Mach_spl0 __P((void)), Mach_spl1 __P((void));
extern int	Mach_spl2 __P((void)), Mach_spl3 __P((void));

/* Block out nested interrupt-enable bits. */
extern int	cpu_spl0 __P((void)), cpu_spl1 __P((void));
extern int	cpu_spl2 __P((void)), cpu_spl3 __P((void));
extern int	splhigh __P((void));

/*
 * Instead, we declare the standard splXXX names as function pointers,
 * and initialie them to point to the above functions to match
 * the way a specific motherboard is  wired up.
 */
int	(*Mach_splbio) __P((void)) = splhigh;
int	(*Mach_splnet)__P((void)) = splhigh;
int	(*Mach_spltty)__P((void)) = splhigh;
int	(*Mach_splimp)__P((void)) = splhigh;
int	(*Mach_splclock)__P((void)) = splhigh;
int	(*Mach_splstatclock)__P((void)) = splhigh;
d184 7
a193 14
int	savectx __P((struct user *up));		/* XXX save state b4 crash*/


tc_option_t tc_slot_info[TC_MAX_LOGICAL_SLOTS];


/*
 *  Local functions.
 */
#ifdef DS5000_240	/* XXX */
static	void asic_init __P((int isa_maxine));
#endif
extern	int	atoi __P((const char *cp));
int	initcpu __P((void));
d195 2
a196 1
static	u_long	clkread __P((void));	/* get usec-resolution clock */
a197 6
void	dumpsys __P((void));		/* do a dump */

/* initialize bss, etc. from kernel start, before main() is called. */
extern	void
mach_init __P((int argc, char *argv[], u_int code,
    const struct callback *cv));
d199 3
a219 3
u_long	kn03_tc3_imask;
extern	u_long latched_cycle_cnt;
void	kn03_tc_reset __P((void));		/* XXX unused? */
a231 5
#ifdef DEBUG
/* stacktrace code violates prototypes to get callee's registers */
extern void stacktrace __P((void)); /*XXX*/
#endif

a241 9

/*
 * XXX locore callback-vector setup should be done via mips_vector_init()
 * using CPU-family information, but that doesn't work yet, so for now we
 * explicitly call the mips1 setup function.
 */
extern void mips1_vector_init __P((void));


d260 2
d384 1
a384 2
		cp = (*callv->_getenv)("systype");
		if (cp)
d415 3
a417 3
		Mach_splbio = cpu_spl0;
		Mach_splnet = cpu_spl1;
		Mach_spltty = cpu_spl2;
d419 2
a420 3
		Mach_splclock = cpu_spl3;
		Mach_splstatclock = cpu_spl3;

d472 2
a473 2
		Mach_splclock = cpu_spl1;
		Mach_splstatclock = cpu_spl1;
a548 2

		/* On the MAXINE ioasic interrupts at level 3. */
d553 2
a554 12

		/*
		 * Note priority inversion of ioasic and clock:
		 * clock interrupts are at hw priority 1, and when blocking
		 * clock interrups we we must block hw priority 3
		 * (bio,net,tty) also.
		 *
		 * XXX hw priority 2 is used for memory errors, we
		 * should not disable memory errors during clock interrupts!
		 */
		Mach_splclock = cpu_spl3;
		Mach_splstatclock = cpu_spl3;
d588 1
d592 3
a594 7
		Mach_splimp = Mach_spl0;	/* XXX */
		/*
		 * Clock interrupts at hw priority 1 must block bio,net,tty
		 * at hw priority 0.
		 */
		Mach_splclock = cpu_spl1;
		Mach_splstatclock = cpu_spl1;
d771 1
d784 1
d850 2
a851 1
	 * Finally, allocate mbuf cluster submap.
d853 3
d869 1
a869 1
	printf("avail mem = %ld\n", ptoa(cnt.v_free_count));
a888 1

a891 1
int
a915 1

d937 1
a937 1
	p->p_md.md_flags &= ~MDP_FPUSED;
d1006 2
a1007 2
	    ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid))
		printf("sendsig(%d): sig %d ssp %p usp %p scp %p\n",
d1071 1
a1071 1
	    ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid))
d1105 1
a1105 1
		printf("sigreturn: pid %d, scp %p\n", p->p_pid, scp);
d1116 1
a1116 1
			printf("sigreturn: pid %d, scp %p\n", p->p_pid, scp);
d1146 1
a1146 1
struct user dumppcb;	/* Actually, struct pcb would do. */
d1188 1
a1188 1
	savectx(&dumppcb);
d1201 1
a1201 1
	printf("\ndumping to dev %x, offset %ld\n", dumpdev, dumplo);
d1253 1
a1253 2
		volatile void (*f) __P((void)) = 
		    (volatile void (*) __P((void))) DEC_PROM_REINIT;
d1257 1
a1257 2
		volatile void (*f) __P((void)) = 
		    (volatile void (*) __P((void)))DEC_PROM_AUTOBOOT;
d1273 1
a1273 1
		savectx(curproc->p_addr);
a1320 2
haltsys:

d1324 1
d1420 2
d1444 1
a1444 1
	int i = 0;
d1493 1
a1493 1
	const char *s;
d1681 1
a1681 1
	printf("3MIN: imask %lx, %sabling slot %d, sc %p handler %p\n",
a1884 1
#ifdef DS5000_240	/* XXX */
a1901 1
#endif /* DS5000_240 XXX */
@


1.13
log
@bring siginfo stuff for the pmax in sync with the arc and add
BUFCACHEPERCENT for the pmax
@
text
@d1 1
a1 1
/*	$NetBSD: machdep.c,v 1.67 1996/10/23 20:04:40 mhitch Exp $	*/
d80 1
a85 1
#include <machine/dc7085cons.h>
d103 1
a105 1

a110 1
#include "dc.h"
a115 5
#if NDTOP > 0
#include <pmax/dev/dtopvar.h>
#endif


d118 1
d129 1
a166 4
extern	int (*mips_hardware_intr)();

int	kn02_intr(), kmin_intr(), xine_intr();

a167 1
extern int	kn01_intr();
d177 25
a201 3
#ifdef DS5000_240
int	kn03_intr();
#endif
a202 7
extern	int Mach_spl0(), Mach_spl1(), Mach_spl2(), Mach_spl3(), splhigh();
int	(*Mach_splbio)() = splhigh;
int	(*Mach_splnet)() = splhigh;
int	(*Mach_spltty)() = splhigh;
int	(*Mach_splimp)() = splhigh;
int	(*Mach_splclock)() = splhigh;
int	(*Mach_splstatclock)() = splhigh;
d206 14
d221 1
a221 2
u_long	kn03_tc3_imask;
extern u_long latched_cycle_cnt;
d223 6
a229 3
tc_option_t tc_slot_info[TC_MAX_LOGICAL_SLOTS];
static	void asic_init();
extern	void RemconsInit();
d248 3
d263 5
d278 9
a304 2
	extern char MachUTLBMiss[], MachUTLBMissEnd[];
	extern char mips_R2000_exception[], mips_R2000_exceptionEnd[];
d427 2
a428 1
		if (cp = (*callv->_getenv)("systype"))
d459 3
a461 3
		Mach_splbio = Mach_spl0;
		Mach_splnet = Mach_spl1;
		Mach_spltty = Mach_spl2;
d463 3
a465 2
		Mach_splclock = Mach_spl3;
		Mach_splstatclock = Mach_spl3;
d517 2
a518 2
		Mach_splclock = Mach_spl1;
		Mach_splstatclock = Mach_spl1;
d594 2
d600 12
a611 2
		Mach_splclock = Mach_spl1;
		Mach_splstatclock = Mach_spl1;
a644 1

d648 7
a654 3
		Mach_splimp = Mach_spl0;
		Mach_splclock = Mach_spl1;
		Mach_splstatclock = Mach_spl1;
a830 1

a842 1
	register caddr_t v;
d908 1
a908 2
	 * Finally, allocate mbuf pool.  Since mclrefcnt is an off-size
	 * we use the more space efficient malloc in place of kmem_alloc.
a909 3
	mclrefcnt = (char *)malloc(NMBCLUSTERS+CLBYTES/MCLBYTES,
				   M_MBUF, M_NOWAIT);
	bzero(mclrefcnt, NMBCLUSTERS+CLBYTES/MCLBYTES);
d923 1
a923 1
	printf("avail mem = %d\n", ptoa(cnt.v_free_count));
d943 1
d947 1
d972 1
d994 1
a994 1
	p->p_md.md_flags & ~MDP_FPUSED;
d1063 2
a1064 2
	    (sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
		printf("sendsig(%d): sig %d ssp %x usp %x scp %x\n",
d1128 1
a1128 1
	    (sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
d1162 1
a1162 1
		printf("sigreturn: pid %d, scp %x\n", p->p_pid, scp);
d1173 1
a1173 1
			printf("sigreturn: pid %d, scp %x\n", p->p_pid, scp);
d1203 1
a1203 1
struct pcb dumppcb;
d1245 1
a1245 1
	savectx(&dumppcb, 0);
d1258 1
a1258 1
	printf("\ndumping to dev %x, offset %d\n", dumpdev, dumplo);
d1310 2
a1311 1
		volatile void (*f)() = (volatile void (*)())DEC_PROM_REINIT;
d1315 2
a1316 1
		volatile void (*f)() = (volatile void (*)())DEC_PROM_AUTOBOOT;
d1332 1
a1332 1
		savectx(curproc->p_addr, 0);
d1380 2
a1384 1
haltsys:
a1479 2
	register long usec;

d1502 1
a1502 1
	int i;
d1551 1
a1551 1
	char *s;
d1739 1
a1739 1
	printf("3MIN: imask %x, %sabling slot %d, sc %x addr 0x%x\n",
d1943 1
d1961 1
@


1.12
log
@More siginfo implementations (alpha and mips might even work)
move "siginfo_t *" to 2nd arg of signal handler as 1003.1b requires.
I really wish I had 1003.1b documentation.
@
text
@d726 4
d737 7
a743 2
	if (bufpages == 0)
		bufpages = physmem / 10 / CLSIZE;
d749 11
d821 6
@


1.11
log
@SA_SIGINFO
@
text
@d928 1
a928 1
	int	sf_code;		/* additional info for handler */
d932 1
d972 2
d1011 9
d1021 1
d1038 1
a1038 1
	regs[A1] = code;
@


1.10
log
@do not call resettodr() if RB_TIMEBAD is set due to being in ddb with clock updates suspended
@
text
@d946 1
a946 1
sendsig(catcher, sig, mask, code)
d950 2
@


1.9
log
@update the pmax stuff to NetBSD 961107 - this version i got somehow
compiled on my decstation 2100 (PLUTO) - but it will not fully work
out of the box - but i want to bring it into the tree because i get
my own pmax on 961228 - so that i have a good startpoint then :-)

all the OpenBSD changes to the pmax tree will follow in the next commit
@
text
@d1265 2
a1266 1
		 * will be out of synch; adjust it now.
d1268 5
a1272 1
		resettodr();
@


1.8
log
@+SYSVSEM/MSG support; netbsd pr#2825, hwr@@pilhuhn.de
@
text
@d1 1
a1 1
/*	$NetBSD: machdep.c,v 1.51.2.4 1996/06/25 21:52:17 jtc Exp $	*/
a105 3
#include <pmax/pmax/mips_machdep.c>	/* XXX */


d236 3
a285 17
#if 0
	/*
	 * Copy down exception vector code.
	 */
	if (MachUTLBMissEnd - MachUTLBMiss > 0x80)
		panic("startup: UTLB code too large");
	bcopy(MachUTLBMiss, (char *)MACH_UTLB_MISS_EXC_VEC,
		MachUTLBMissEnd - MachUTLBMiss);
	bcopy(mips_R2000_exception, (char *)MACH_GEN_EXC_VEC,
		mips_R2000_exceptionEnd - mips_R2000_exception);

	/*
	 * Copy locore-function vector.
	 */
	bcopy(&R2000_locore_vec, &mips_locore_jumpvec,
	      sizeof(mips_locore_jumpvec_t));

d287 2
d291 3
a293 2
	mips_r2000_ConfigCache();
	mips_r2000_FlushCache();
d295 1
a295 2
	/*XXX*/
	r2000_vector_init();
d1111 1
d1114 3
d1152 3
d1201 29
d1234 1
d1245 10
d1261 1
a1261 1
		vfs_shutdown ();
a1268 11
	(void) splhigh();		/* extreme priority */
	if (callv != &callvec) {
		if (howto & RB_HALT)
			(*callv->_rex)('h');
		else {
			if (howto & RB_DUMP)
				dumpsys();
			(*callv->_rex)('b');
		}
	} else if (howto & RB_HALT) {
		volatile void (*f)() = (volatile void (*)())DEC_PROM_REINIT;
d1270 15
a1284 3
		(*f)();	/* jump back to prom monitor */
	} else {
		volatile void (*f)() = (volatile void (*)())DEC_PROM_AUTOBOOT;
d1286 3
a1288 5
		if (howto & RB_DUMP)
			dumpsys();
		(*f)();	/* jump back to prom monitor and do 'auto' cmd */
	}
	while(1) ;	/* fool gcc */
a1292 1

d1642 1
a1642 1
	       kn03_tc3_imask, (on? "en" : "dis"), slotno, sc, handler);
@


1.7
log
@merge mips back into pmax; by graichen
@
text
@d69 6
d727 12
@


1.6
log
@sync to netbsd; for graichen
@
text
@d100 1
a100 1
#include <mips/mips/mips_machdep.c>	/* XXX */
@


1.5
log
@handle RB_CONFIG
@
text
@d1 1
a1 1
/*	$NetBSD: machdep.c,v 1.41 1996/01/04 22:22:40 jtc Exp $	*/
a82 1
#include <pmax/dev/sccreg.h>
d86 2
a98 10
#include <pm.h>
#include <cfb.h>
#include <mfb.h>
#include <xcfb.h>
#include <sfb.h>
#include <dc.h>
#include <dtop.h>
#include <scc.h>
#include <le.h>
#include <asc.h>
d100 13
a112 2
#include <pmax/dev/sccvar.h>
#include <pmax/dev/dcvar.h>
d115 1
a115 1
extern int dtopKBDGetc();
a118 1
extern int KBDGetc();
a119 1
/*extern struct consdev cn_tab;*/
d155 1
d159 1
a159 1
u_long	asic_base;		/* Base address of I/O asic */
d168 1
a168 1
extern	int (*pmax_hardware_intr)();
d179 4
d186 1
d196 1
d201 1
d206 1
a206 3
#ifdef DS5000

#if 1 /*def DS5000_200*/
d210 1
a210 1
#endif /*def DS5000_200*/
d227 2
d230 1
a230 1
#endif /* DS5000 */
d247 1
d261 1
a261 1
	extern char MachException[], MachExceptionEnd[];
d264 1
a264 1
	v = (caddr_t)pmax_round_page(end);
d280 27
a392 16
	 * Copy down exception vector code.
	 */
	if (MachUTLBMissEnd - MachUTLBMiss > 0x80)
		panic("startup: UTLB code too large");
	bcopy(MachUTLBMiss, (char *)MACH_UTLB_MISS_EXC_VEC,
		MachUTLBMissEnd - MachUTLBMiss);
	bcopy(MachException, (char *)MACH_GEN_EXC_VEC,
		MachExceptionEnd - MachException);

	/*
	 * Clear out the I and D caches.
	 */
	MachConfigCache();
	MachFlushCache();

	/*
d412 6
d422 2
d428 1
a428 1
		pmax_hardware_intr = kn01_intr;
d433 1
a433 1
		Mach_splimp = Mach_spl2;
d440 1
d442 3
a444 1
	case DS_MIPSFAIR:	/* DS5100 mipsfair */
d449 1
a449 1
		pmax_hardware_intr = kn01_intr;
d461 1
d463 1
a463 1
#ifdef DS5000
d481 1
a481 1
		pmax_hardware_intr = kn02_intr;
d495 1
d504 2
a505 2
		asic_base = MACH_PHYS_TO_UNCACHED(KMIN_SYS_ASIC);
		pmax_hardware_intr = kmin_intr;
d529 2
a530 2
		*(u_int *)ASIC_REG_IMSK(asic_base) = KMIN_IM0;
		*(u_int *)ASIC_REG_INTR(asic_base) = 0;
d538 14
a552 1

d561 2
a562 2
		asic_base = MACH_PHYS_TO_UNCACHED(XINE_SYS_ASIC);
		pmax_hardware_intr = xine_intr;
d576 2
a577 2
		*(u_int *)ASIC_REG_IMSK(asic_base) = XINE_IM0;
		*(u_int *)ASIC_REG_INTR(asic_base) = 0;
d593 2
a594 2
		asic_base = MACH_PHYS_TO_UNCACHED(KN03_SYS_ASIC);
		pmax_hardware_intr = kn03_intr;
d619 2
a620 2
		*(u_int *)ASIC_REG_IMSK(asic_base) = kn03_tc3_imask;
		*(u_int *)ASIC_REG_INTR(asic_base) = 0;
d623 1
a623 1
		 *(u_int *)ASIC_REG_CSR(asic_base) |= 0x100;
a629 1
#endif /* DS5000 */
d641 3
a643 2
	cp = (char *)MACH_PHYS_TO_UNCACHED(physmem << PGSHIFT);
	while (cp < (char *)MACH_MAX_MEM_ADDR) {
d647 1
d654 1
a654 1
		MachEmptyWriteBuffer();
d658 1
d665 1
a665 1
#if NLE > 0
d676 1
a676 1
#endif /* NLE */
d763 1
a862 7
	if (boothowto & RB_CONFIG) {
#ifdef BOOT_CONFIG
		user_config();
#else
		printf("kernel does not support -c; continuing..\n");
#endif
	}
d895 4
a898 1
 * Clear all registers except sp, pc.
d912 1
d1025 1
a1108 53
boot(howto)
	register int howto;
{

	/* take a snap shot before clobbering any registers */
	if (curproc)
		savectx(curproc->p_addr, 0);

#ifdef DEBUG
	if (panicstr)
		stacktrace();
#endif

	boothowto = howto;
	if ((howto & RB_NOSYNC) == 0 && waittime < 0) {
		extern struct proc proc0;
		/* avoid panic at boot XXX */
		if (curproc == NULL)
			curproc = &proc0;
		/*
		 * Synchronize the disks....
		 */
		waittime = 0;
		vfs_shutdown ();

		/*
		 * If we've been adjusting the clock, the todr
		 * will be out of synch; adjust it now.
		 */
		resettodr();
	}
	(void) splhigh();		/* extreme priority */
	if (callv != &callvec) {
		if (howto & RB_HALT)
			(*callv->_rex)('h');
		else {
			if (howto & RB_DUMP)
				dumpsys();
			(*callv->_rex)('b');
		}
	} else if (howto & RB_HALT) {
		volatile void (*f)() = (volatile void (*)())DEC_PROM_REINIT;

		(*f)();	/* jump back to prom monitor */
	} else {
		volatile void (*f)() = (volatile void (*)())DEC_PROM_AUTOBOOT;

		if (howto & RB_DUMP)
			dumpsys();
		(*f)();	/* jump back to prom monitor and do 'auto' cmd */
	}
	/*NOTREACHED*/
}
d1114 1
d1140 1
d1158 7
a1164 1
	switch (error = (*bdevsw[major(dumpdev)].d_dump)(dumpdev)) {
d1191 129
a1335 1
#ifdef notdef
d1337 2
a1338 1
	while (tvp->tv_usec > 1000000) {
a1339 30
		tvp->tv_usec -= 1000000;
	}
#endif
	/*
	 * if there's a turbochannel cycle counter, use that to
	 * interpolate micro-seconds since the  last RTC clock tick,
	 * using the software copy of the bus cycle-counter taken by
	 * the RTC interrupt handler.
	 */
#ifdef DS5000_240
	if (pmax_boardtype == DS_3MAXPLUS) {
		usec = *(u_int*)ASIC_REG_CTR(asic_base);
		/* subtract cycle count a last  tick */
		if (usec >= latched_cycle_cnt)
			usec = usec - latched_cycle_cnt;
		else
			usec = latched_cycle_cnt - usec;

		/*
		 * scale from 40ns to microseconds.
		 * avoid a kernel FP divide (by 25) using
		 * an approximation 1/25 = 40/1000 =~ 41/ 1024.
		 */
		usec = usec + (usec << 3) + (usec << 5);
		usec = usec >> 10;
		tvp-> tv_usec += usec;
		if (tvp->tv_usec >= 1000000) {
			tvp->tv_usec -= 1000000;
			tvp->tv_sec++;
		}
a1340 1
#endif
d1352 1
d1358 2
d1363 1
a1363 1
		MachEmptyWriteBuffer();
d1365 1
d1374 1
a1374 1
		*(u_int *)ASIC_REG_INTR(asic_base) = 0;
d1378 1
a1378 1
		MachEmptyWriteBuffer();
d1381 1
a1381 1
		printf("Unknown system type in initcpu()\n");
d1462 1
a1462 1
#ifdef DS5000
d1488 1
d1491 2
d1509 2
a1510 2
	printf("3MAX enable_intr: imask %x, %sabling slot %d, unit %d\n",
	       kn03_tc3_imask, (on? "en" : "dis"), slotno, unit);
d1534 1
d1536 1
d1575 1
d1640 1
d1642 2
d1707 1
a1707 1
	*(u_int *)ASIC_REG_IMSK(asic_base) = xine_tc3_imask;
d1709 1
d1718 1
a1718 1
	*(u_int *)ASIC_REG_INTR(asic_base) = 0;
d1763 1
a1763 1
		mask |= ASIC_INTR_LANCE_READ_E;
d1791 1
a1791 1
	*(u_int *)ASIC_REG_IMSK(asic_base) = kn03_tc3_imask;
d1807 1
a1807 1
	decoder = (volatile u_int *)ASIC_REG_LANCE_DECODE(asic_base);
d1811 1
a1811 1
	decoder = (volatile u_int *) ASIC_REG_SCSI_DECODE(asic_base);
a1813 1
#endif /* DS5000 */
@


1.4
log
@fix panic at reboot.
@
text
@d814 7
@


1.3
log
@ss_sp is correct, ss_base is not. noticed by agc@@sde.uts.amdahl.com; netbsd pr#1784
@
text
@d1070 4
@


1.2
log
@from netbsd: Add untested, partial support for Decsystem 5100 (mipsfair).
@
text
@d1 1
a1 1
/*	$NetBSD: machdep.c,v 1.40 1995/12/28 06:45:00 jonathan Exp $	*/
d916 1
a916 1
		fp = (struct sigframe *)(psp->ps_sigstk.ss_base +
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: machdep.c,v 1.39 1995/10/07 06:25:59 mycroft Exp $	*/
d411 18
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
