head	1.7;
access;
symbols
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	UBC_SYNC_A:1.7
	UBC_SYNC_B:1.7
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	SMP:1.4.0.12
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.10
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.8
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.6
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2000.08.19.18.55.53;	author maja;	state dead;
branches;
next	1.6;

1.6
date	2000.07.19.13.51.56;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.01.22.25.46;	author maja;	state Exp;
branches;
next	1.4;

1.4
date	97.07.07.08.21.07;	author graichen;	state Exp;
branches
	1.4.12.1;
next	1.3;

1.3
date	96.12.22.15.17.25;	author graichen;	state Exp;
branches;
next	1.2;

1.2
date	96.09.15.21.12.18;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.26;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.26;	author deraadt;	state Exp;
branches;
next	;

1.4.12.1
date	2001.04.18.16.12.34;	author niklas;	state dead;
branches;
next	;


desc
@@


1.7
log
@Late in the release of OpenBSD/pmax 2.7 a conflict between the pmax
dc driver and the generic if_dc driver was found. The fix was to
change the pmax drivers name to dz instead. But this was only done
in a miminal way.

This commit will remove the old dc driver.

-moj
@
text
@/*	$NetBSD: dc.c,v 1.30 1996/10/16 02:10:33 jonathan Exp $	*/

/*-
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Ralph Campbell and Rick Macklem.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)dc.c	8.5 (Berkeley) 6/2/95
 */

/*
 * devDC7085.c --
 *
 *     	This file contains machine-dependent routines that handle the
 *	output queue for the serial lines.
 *
 *	Copyright (C) 1989 Digital Equipment Corporation.
 *	Permission to use, copy, modify, and distribute this software and
 *	its documentation for any purpose and without fee is hereby granted,
 *	provided that the above copyright notice appears in all copies.
 *	Digital Equipment Corporation makes no representations about the
 *	suitability of this software for any purpose.  It is provided "as is"
 *	without express or implied warranty.
 *
 * from: Header: /sprite/src/kernel/dev/ds3100.md/RCS/devDC7085.c,
 *	v 1.4 89/08/29 11:55:30 nelson Exp  SPRITE (DECWRL)";
 */

/*
 * DC7085 (DZ-11 look alike) Driver
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/ioctl.h>
#include <sys/tty.h>
#include <sys/proc.h>
#include <sys/map.h>
#include <sys/buf.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/uio.h>
#include <sys/kernel.h>
#include <sys/syslog.h>

#include <machine/conf.h>
#include <sys/device.h>
#include <machine/autoconf.h>
#include <dev/tc/tcvar.h>
#include <dev/tc/ioasicvar.h>

#include <machine/dc7085cons.h>
#include <machine/pmioctl.h>

#include <pmax/pmax/pmaxtype.h>
#include <pmax/pmax/cons.h>

#include <pmax/dev/lk201.h>

/*
 * XXX in dcvar.h or not?
 * #include <pmax/dev/pdma.h>
 */
#include "dcvar.h"

#include "tc.h"

#include <pmax/dev/lk201var.h>		/* XXX KbdReset band friends */

#include <pmax/dev/dcvar.h>
#include <pmax/dev/dc_cons.h>

extern struct cfdriver mainbus_cd;

#define DCUNIT(dev) (minor(dev) >> 2)
#define DCLINE(dev) (minor(dev) & 3)

/*
 * Autoconfiguration data for config.
 * 
 * Use the statically-allocated softc until old autoconfig code and
 * config.old are completely gone.
 */
int	old_dcmatch  __P((struct device * parent, void *cfdata, void *aux));
void	old_dcattach __P((struct device *parent, struct device *self, void *aux));


extern struct cfdriver dz_cd;
struct  cfdriver dz_cd = {
	NULL, "dz", DV_TTY
};



/*
 * Forward declarations
 */
struct tty *dctty __P((dev_t  dev));
void dcstart	__P((struct tty *));
void dcrint	 __P((struct dc_softc *sc));
void dcxint	__P((struct tty *));
int dcmctl	 __P((dev_t dev, int bits, int how));
void dcscan	__P((void *));
int dcparam	__P((struct tty *tp, struct termios *t));
static int cold_dcparam __P((struct tty *tp, struct termios *t, 
		      dcregs *dcaddr, int allow_19200));

void	dc_reset __P ((dcregs *dcaddr));

/* console I/O */
int  dcGetc	__P((dev_t));
void dcPutc	__P((dev_t, int));
void dcPollc	__P((dev_t, int));
void dc_consinit __P((dev_t dev, dcregs *dcaddr));


/* QVSS-compatible in-kernel X input event parser, pointer tracker */
void	(*dcDivertXInput) __P((int cc)); /* X windows keyboard input routine */
void	(*dcMouseEvent) __P((int));	/* X windows mouse motion event routine */
void	(*dcMouseButtons) __P((int));	/* X windows mouse buttons event routine */
#ifdef DEBUG
int	debugChar;
#endif


/*
 * The DC7085 doesn't interrupt on carrier transitions, so
 * we have to use a timer to watch it.
 */
int	dc_timer;		/* true if timer started */

/*
 * Pdma structures for fast output code
 */

struct speedtab dcspeedtab[] = {
	{ 0,	0,	},
	{ 50,	LPR_B50    },
	{ 75,	LPR_B75    },
	{ 110,	LPR_B110   },
	{ 134,	LPR_B134   },
	{ 150,	LPR_B150   },
	{ 300,	LPR_B300   },
	{ 600,	LPR_B600   },
	{ 1200,	LPR_B1200  },
	{ 1800,	LPR_B1800  },
	{ 2400,	LPR_B2400  },
	{ 4800,	LPR_B4800  },
	{ 9600,	LPR_B9600  },
	{ 19200,LPR_B19200 },
#ifdef notyet
	{ 19200,LPR_B38400 },	/* Overloaded with 19200, per chip. */
#endif
	{ -1,	-1 }
};

#ifndef	PORTSELECTOR
#define	ISPEED	TTYDEF_SPEED
#define	LFLAG	TTYDEF_LFLAG
#else
#define	ISPEED	B4800
#define	LFLAG	(TTYDEF_LFLAG & ~ECHO)
#endif

/*
 * Console line variables, for use when cold
 */
extern int cold;
dcregs *dc_cons_addr = 0;

/*
 * Is there a framebuffer console device using this serial driver?
 * XXX used for ugly special-cased console input that should be redone
 * more cleanly.
 */
static inline int raster_console __P((void));

static inline int
raster_console()
{
	return (cn_tab->cn_pri == CN_INTERNAL ||
		cn_tab->cn_pri == CN_NORMAL);
}


/* XXX move back into dc_consinit when debugged */
static struct consdev dccons = {
	NULL, NULL, dcGetc, dcPutc, dcPollc, NODEV, CN_REMOTE
};

/*
 * Special-case code to attach a console.
 * We were using PROM callbacks for console I/O,
 * and we just reset the chip under the console.
 * wire up this driver as console ASAP.
 *
 * Must be called at spltty() or higher.
 */
void
dc_consinit(dev, dcaddr)
	dev_t dev;
	register dcregs *dcaddr;
{
  	struct termios cterm;
  	struct tty ctty;

	/* save address in case we're cold */
	if (cold && dc_cons_addr == 0)
		dc_cons_addr = dcaddr;

	/* reset chip */
	dc_reset(dcaddr);

	dcaddr->dc_lpr = LPR_RXENAB | LPR_8_BIT_CHAR |
		LPR_B9600 | DCLINE(dev);
	wbflush();
	DELAY(10);

	bzero(&cterm, sizeof(cterm));
	bzero(&ctty, sizeof(ctty));
	ctty.t_dev = dev;
	dccons.cn_dev = dev;
	cterm.c_cflag |= CLOCAL;
	cterm.c_cflag = CS8;
	cterm.c_ospeed = 9600;
	*cn_tab = dccons;
	cold_dcparam(&ctty, &cterm, dcaddr, 0); /* XXX untested */
}


/*
 * Attach DC7085 (dz-11) device.
 */
int
dcattach(sc, addr, dtr_mask, rtscts_mask, speed,
	   console_line)
	register struct dc_softc *sc;
	void *addr;
	int dtr_mask, rtscts_mask, speed, console_line;
{
	register dcregs *dcaddr;
	register struct pdma *pdp;
	register struct tty *tp;
	register int line;
	int s;
	
	dcaddr = (dcregs *)addr;

	/*
	 * For a remote console, wait a while for previous output to
	 * complete.
	 * XXX both cn_dev == 0 and cn_pri == CN_DEAD are bug workarounds.
	 * The interface between ttys and cpu_cons.c should be reworked.
	 */
	if (sc->sc_dv.dv_unit == 0 &&	/* XXX why only unit 0? */
	    (major(cn_tab->cn_dev) == DCDEV || major(cn_tab->cn_dev) == 0) &&
	    (cn_tab->cn_pri == CN_REMOTE || (cn_tab->cn_pri == CN_DEAD))) {
		DELAY(10000);
	}
	/* reset chip and enable interrupts */
	dc_reset(dcaddr);
	dcaddr->dc_csr |= (CSR_MSE | CSR_TIE | CSR_RIE);

	/* init pseudo DMA structures */
	pdp = &sc->dc_pdma[0];
	for (line = 0; line < 4; line++) {
		pdp->p_addr = (void *)dcaddr;
		tp = sc->dc_tty[line] = ttymalloc();
		if (line != DCKBD_PORT && line != DCMOUSE_PORT)
			tty_attach(tp);
		tp->t_dev = makedev(DCDEV, 4 * sc->sc_dv.dv_unit + line);
		pdp->p_arg = (int) tp;
		pdp->p_fcn = dcxint;
		pdp++;
	}
	sc->dcsoftCAR = sc->sc_dv.dv_cfdata->cf_flags | 0xB;

	if (dc_timer == 0) {
		dc_timer = 1;
		timeout(dcscan, (void *)0, hz);
	}

	sc->dc_19200 = speed;
	sc->dc_modem = dtr_mask;
	sc->dc_rtscts = rtscts_mask;


	/*
	 * Special handling for consoles.
	 */
	if (sc->sc_dv.dv_unit == 0) {
		if (raster_console()) {
			s = spltty();
			dcaddr->dc_lpr = LPR_RXENAB | LPR_8_BIT_CHAR |
				LPR_B4800 | DCKBD_PORT;
			wbflush();
			dcaddr->dc_lpr = LPR_RXENAB | LPR_B4800 | LPR_OPAR |
				LPR_PARENB | LPR_8_BIT_CHAR | DCMOUSE_PORT;
			wbflush();
			DELAY(1000);
			KBDReset(makedev(DCDEV, DCKBD_PORT), dcPutc);
			MouseInit(makedev(DCDEV, DCMOUSE_PORT), dcPutc, dcGetc);
			splx(s);
		}
		else if (major(cn_tab->cn_dev) == DCDEV) {
			s = spltty();
			dc_consinit(cn_tab->cn_dev, dcaddr);
			dcaddr->dc_csr |= (CSR_MSE | CSR_TIE | CSR_RIE);
			splx(s);
		}
	}
	return (1);
}


/*
 * Reset chip.  Does not change modem control output bits
 * or modem state register.
 * Does not enable interrupts; caller must explicitly or
 * TIE and RIE on if desired (XXX not true yet)
 */
void
dc_reset(dcaddr)
	register dcregs *dcaddr;
{
	/* Reset CSR and wait until cleared. */
	dcaddr->dc_csr = CSR_CLR;
	wbflush();
	DELAY(10);
	while (dcaddr->dc_csr & CSR_CLR)
		;

	/* Enable scanner. */
	dcaddr->dc_csr = CSR_MSE;
	wbflush();
	DELAY(10);
}


int
dcopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	register struct tty *tp;
	register struct dc_softc *sc;
	register int unit, line;
	int s, error = 0;

	unit = DCUNIT(dev);
	line = DCLINE(dev);
	if (unit >= dz_cd.cd_ndevs || line > 4)
		return (ENXIO);

	sc = dz_cd.cd_devs[unit];
	if (sc->dc_pdma[line].p_addr == (void *)0)
		return (ENXIO);	  

	tp = sc->dc_tty[line];
	if (tp == NULL) {
		tp = sc->dc_tty[line] = ttymalloc();
		tty_attach(tp);
	}
	tp->t_oproc = dcstart;
	tp->t_param = dcparam;
	tp->t_dev = dev;
	if ((tp->t_state & TS_ISOPEN) == 0) {
		tp->t_state |= TS_WOPEN;
		ttychars(tp);
#ifndef PORTSELECTOR
		if (tp->t_ispeed == 0) {
#endif
			tp->t_iflag = TTYDEF_IFLAG;
			tp->t_oflag = TTYDEF_OFLAG;
			tp->t_cflag = TTYDEF_CFLAG;
			tp->t_lflag = LFLAG;
			tp->t_ispeed = tp->t_ospeed = ISPEED;
#ifdef PORTSELECTOR
			tp->t_cflag |= HUPCL;
#else
		}
#endif
		(void) dcparam(tp, &tp->t_termios);
		ttsetwater(tp);
	} else if ((tp->t_state & TS_XCLUDE) && curproc->p_ucred->cr_uid != 0)
		return (EBUSY);
#ifdef HW_FLOW_CONTROL
	(void) dcmctl(dev, DML_DTR | DML_RTS, DMSET);
#else
	(void) dcmctl(dev, DML_DTR, DMSET);
#endif
	if ((sc->dcsoftCAR & (1 << line)) ||
	    (dcmctl(dev, 0, DMGET) & DML_CAR))
		tp->t_state |= TS_CARR_ON;
	s = spltty();
	while (!(flag & O_NONBLOCK) && !(tp->t_cflag & CLOCAL) &&
	       !(tp->t_state & TS_CARR_ON)) {
		tp->t_state |= TS_WOPEN;
		if ((error = ttysleep(tp, (caddr_t)&tp->t_rawq,
				      TTIPRI | PCATCH, ttopen, 0)) != 0)
			break;
	}
	splx(s);
	if (error)
		return (error);
	return ((*linesw[tp->t_line].l_open)(dev, tp));
}

/*ARGSUSED*/
int
dcclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	register struct dc_softc *sc;
	register struct tty *tp;
	register int line, bit;
	int s;

	sc = dz_cd.cd_devs[DCUNIT(dev)];
	line = DCLINE(dev);
	tp = sc->dc_tty[line];
	bit = 1 << (line + 8);
	s = spltty();
	/* turn off the break bit if it is set */
	if (sc->dc_brk & bit) {
		sc->dc_brk &= ~bit;
		ttyoutput(0, tp);
	}
	splx(s);
	(*linesw[tp->t_line].l_close)(tp, flag);
	if ((tp->t_cflag & HUPCL) || (tp->t_state & TS_WOPEN) ||
	    !(tp->t_state & TS_ISOPEN))
		(void) dcmctl(dev, 0, DMSET);
	return (ttyclose(tp));
}

int
dcread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
{
	register struct dc_softc *sc;
	register struct tty *tp;

	sc = dz_cd.cd_devs[DCUNIT(dev)];
	tp = sc->dc_tty[DCLINE(dev)];

#ifdef HW_FLOW_CONTROL
	if ((tp->t_cflag & CRTS_IFLOW) && (tp->t_state & TS_TBLOCK) &&
	    tp->t_rawq.c_cc < TTYHOG/5) {
		tp->t_state &= ~TS_TBLOCK;
		(void) dcmctl(dev, DML_RTS, DMBIS);
	}
#endif /* HW_FLOW_CONTROL */

	return ((*linesw[tp->t_line].l_read)(tp, uio, flag));
}

int
dcwrite(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
{
	register struct dc_softc *sc;
	register struct tty *tp;

	sc = dz_cd.cd_devs[DCUNIT(dev)];
	tp = sc->dc_tty[DCLINE(dev)];
	return ((*linesw[tp->t_line].l_write)(tp, uio, flag));
}

struct tty *
dctty(dev)
        dev_t dev;
{
	register struct dc_softc *sc;
	register struct tty *tp;

	sc = dz_cd.cd_devs[DCUNIT(dev)];
	tp = sc->dc_tty[DCLINE(dev)];
        return (tp);
}

/*ARGSUSED*/
int
dcioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	register struct dc_softc *sc;
	register struct tty *tp;
	register int unit;
	register int line;
	int error;


	unit = DCUNIT(dev);
	line = DCLINE(dev);
	sc = dz_cd.cd_devs[unit];
	tp = sc->dc_tty[line];

	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);
	error = ttioctl(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);

	switch (cmd) {

	case TIOCSBRK:
		sc->dc_brk |= 1 << (line + 8);
		ttyoutput(0, tp);
		break;

	case TIOCCBRK:
		sc->dc_brk &= ~(1 << (line + 8));
		ttyoutput(0, tp);
		break;

	case TIOCSDTR:
		(void) dcmctl(dev, DML_DTR|DML_RTS, DMBIS);
		break;

	case TIOCCDTR:
		(void) dcmctl(dev, DML_DTR|DML_RTS, DMBIC);
		break;

	case TIOCMSET:
		(void) dcmctl(dev, *(int *)data, DMSET);
		break;

	case TIOCMBIS:
		(void) dcmctl(dev, *(int *)data, DMBIS);
		break;

	case TIOCMBIC:
		(void) dcmctl(dev, *(int *)data, DMBIC);
		break;

	case TIOCMGET:
		*(int *)data = dcmctl(dev, 0, DMGET);
		break;

	default:
		return (ENOTTY);
	}
	return (0);
}

/*
 * Set line parameters
 */

int
dcparam(tp, t)
	register struct tty *tp;
	register struct termios *t;
{
	register struct dc_softc *sc;
	register dcregs *dcaddr;


	/*
	 * Extract softc data, and pass entire request onto
	 * cold_dcparam() for argument checking and execution.
	 */
	sc = dz_cd.cd_devs[DCUNIT(tp->t_dev)];
	dcaddr = (dcregs *)sc->dc_pdma[0].p_addr;
	return (cold_dcparam(tp, t, dcaddr, sc->dc_19200));

}

int
cold_dcparam(tp, t, dcaddr, allow_19200)
	register struct tty *tp;
	register struct termios *t;
	register dcregs *dcaddr;
	int allow_19200;
{
	register int lpr;
	register int cflag = t->c_cflag;
	int unit = minor(tp->t_dev);
	int ospeed = ttspeedtab(t->c_ospeed, dcspeedtab);
	int s;
	int line;

	line = DCLINE(tp->t_dev);

	/* check requested parameters */
        if (ospeed < 0 || (t->c_ispeed && t->c_ispeed != t->c_ospeed) ||
            (cflag & CSIZE) == CS5 || (cflag & CSIZE) == CS6 ||
	    (t->c_ospeed >= 19200 && allow_19200 != 1))
                return (EINVAL);
        /* and copy to tty */
        tp->t_ispeed = t->c_ispeed;
        tp->t_ospeed = t->c_ospeed;
        tp->t_cflag = cflag;

	/*
	 * Handle console cases specially.
	 */
	if (raster_console()) {
		if (unit == DCKBD_PORT) {
			lpr = LPR_RXENAB | LPR_8_BIT_CHAR |
				LPR_B4800 | DCKBD_PORT;
			goto out;
		} else if (unit == DCMOUSE_PORT) {
			lpr = LPR_RXENAB | LPR_B4800 | LPR_OPAR |
				LPR_PARENB | LPR_8_BIT_CHAR | DCMOUSE_PORT;
			goto out;
		}
	} else if (tp->t_dev == cn_tab->cn_dev) {
		lpr = LPR_RXENAB | LPR_8_BIT_CHAR | LPR_B9600 | line;
		goto out;
	}
	if (ospeed == 0) {
		(void) dcmctl(unit, 0, DMSET);	/* hang up line */
		return (0);
	}
	lpr = LPR_RXENAB | ospeed | line;
	if ((cflag & CSIZE) == CS7)
		lpr |= LPR_7_BIT_CHAR;
	else
		lpr |= LPR_8_BIT_CHAR;
	if (cflag & PARENB)
		lpr |= LPR_PARENB;
	if (cflag & PARODD)
		lpr |= LPR_OPAR;
	if (cflag & CSTOPB)
		lpr |= LPR_2_STOP;
out:
	s = spltty();
	dcaddr->dc_lpr = lpr;
	wbflush();
	splx(s);
	DELAY(10);
	return (0);
}


/*
 * Check for interrupts from all devices.
 */
int
dcintr(xxxunit)
	void *xxxunit;
{
	register struct dc_softc *sc = xxxunit;
	register dcregs *dcaddr;
	register unsigned csr;

	dcaddr = (dcregs *)sc->dc_pdma[0].p_addr;
	while ((csr = dcaddr->dc_csr) & (CSR_RDONE | CSR_TRDY)) {
		if (csr & CSR_RDONE)
			dcrint(sc);
		if (csr & CSR_TRDY)
			dcxint(sc->dc_tty[((csr >> 8) & 03)]);
	}
	/* XXX check for spurious interrupts */
	return 0;
}

void
dcrint(sc)
	register struct dc_softc * sc;
{
	register dcregs *dcaddr;
	register struct tty *tp;
	register int c, cc;
	int overrun = 0;
	register struct tty **dc_tty;

	dc_tty = ((struct dc_softc*)dz_cd.cd_devs[0])->dc_tty;	/* XXX */

	dcaddr = (dcregs *)sc->dc_pdma[0].p_addr;	/*XXX*/
	while ((c = dcaddr->dc_rbuf) < 0) {	/* char present */
		cc = c & 0xff;
		tp = sc->dc_tty[((c >> 8) & 03)];

		if ((c & RBUF_OERR) && overrun == 0) {
			log(LOG_WARNING, "%s,%d: silo overflow\n",
				sc->sc_dv.dv_xname,
				(c >> 8) & 03);
			overrun = 1;
		}
		/* the keyboard requires special translation */
		if (raster_console() && tp == dc_tty[DCKBD_PORT]) {
#ifdef KADB
			if (cc == LK_DO) {
				spl0();
				kdbpanic();
				return;
			}
#endif
#ifdef DEBUG
			debugChar = cc;
#endif
			if (dcDivertXInput) {
				(*dcDivertXInput)(cc);
				return;
			}
			if ((cc = kbdMapChar(cc)) < 0)
				return;
		} else if (tp == dc_tty[DCMOUSE_PORT] && dcMouseButtons) {
			mouseInput(cc);
			return;
		}
		if (!(tp->t_state & TS_ISOPEN)) {
			wakeup((caddr_t)&tp->t_rawq);
#ifdef PORTSELECTOR
			if (!(tp->t_state & TS_WOPEN))
#endif
				return;
		}
		if (c & RBUF_FERR)
			cc |= TTY_FE;
		if (c & RBUF_PERR)
			cc |= TTY_PE;
#ifdef HW_FLOW_CONTROL
		if ((tp->t_cflag & CRTS_IFLOW) && !(tp->t_state & TS_TBLOCK) &&
		    tp->t_rawq.c_cc + tp->t_canq.c_cc >= TTYHOG) {
			tp->t_state &= ~TS_TBLOCK;
			(void) dcmctl(tp->t_dev, DML_RTS, DMBIC);
		}
#endif /* HWW_FLOW_CONTROL */
		(*linesw[tp->t_line].l_rint)(cc, tp);
	}
	DELAY(10);
}

void
dcxint(tp)
	register struct tty *tp;
{
	register struct dc_softc *sc;
	register struct pdma *dp;
	register dcregs *dcaddr;
	int line, linemask;

	sc = dz_cd.cd_devs[DCUNIT(tp->t_dev)];	/* XXX */

	line = DCLINE(tp->t_dev);
	linemask = 1 << line;

	dp = &sc->dc_pdma[line];
	if (dp->p_mem < dp->p_end) {
		dcaddr = (dcregs *)dp->p_addr;

#ifdef HW_FLOW_CONTROL
		/* check for hardware flow control of output */
		if ((tp->t_cflag & CCTS_OFLOW) && (sc->dc_rtscts & linemask)) {
			switch (line) {
			case 2:
				if (dcaddr->dc_msr & MSR_CTS2)
					break;
				goto stop;

			case 3:
				if (dcaddr->dc_msr & MSR_CTS3)
					break;
			stop:
				tp->t_state &= ~TS_BUSY;
				tp->t_state |= TS_TTSTOP;
				ndflush(&tp->t_outq, dp->p_mem - 
						(caddr_t)tp->t_outq.c_cf);
				dp->p_end = dp->p_mem = tp->t_outq.c_cf;
				dcaddr->dc_tcr &= ~(1 << line);
				wbflush();
				DELAY(10);
				return;
			}
		}
#endif /* HW_FLOW_CONTROL */
		dcaddr->dc_tdr = sc->dc_brk | *(u_char *)dp->p_mem;
		dp->p_mem++;

		wbflush();
		DELAY(10);
		return;
	}
	tp->t_state &= ~TS_BUSY;
	if (tp->t_state & TS_FLUSH)
		tp->t_state &= ~TS_FLUSH;
	else {
		ndflush(&tp->t_outq, dp->p_mem - (caddr_t) tp->t_outq.c_cf);
		dp->p_end = dp->p_mem = tp->t_outq.c_cf;
	}
	if (tp->t_line)
		(*linesw[tp->t_line].l_start)(tp);
	else
		dcstart(tp);
	if (tp->t_outq.c_cc == 0 || !(tp->t_state & TS_BUSY)) {
		dcaddr = (dcregs *)dp->p_addr;
		dcaddr->dc_tcr &= ~(1 << line);
		wbflush();
		DELAY(10);
	}
}

void
dcstart(tp)
	register struct tty *tp;
{
	register struct dc_softc *sc;
	register struct pdma *dp;
	register dcregs *dcaddr;
	register int cc;
	int line, s;

	sc = dz_cd.cd_devs[DCUNIT(tp->t_dev)];
	line = DCLINE(tp->t_dev);
	dp = &sc->dc_pdma[line];
	dcaddr = (dcregs *)dp->p_addr;
	s = spltty();
	if (tp->t_state & (TS_TIMEOUT|TS_BUSY|TS_TTSTOP))
		goto out;
	if (tp->t_outq.c_cc <= tp->t_lowat) {
		if (tp->t_state & TS_ASLEEP) {
			tp->t_state &= ~TS_ASLEEP;
			wakeup((caddr_t)&tp->t_outq);
		}
		selwakeup(&tp->t_wsel);
	}
	if (tp->t_outq.c_cc == 0)
		goto out;
	/* handle console specially */
	if (raster_console() && tp == sc->dc_tty[DCKBD_PORT]) {
		while (tp->t_outq.c_cc > 0) {
			cc = getc(&tp->t_outq) & 0x7f;
			cnputc(cc);
		}
		/*
		 * After we flush the output queue we may need to wake
		 * up the process that made the output.
		 */
		if (tp->t_outq.c_cc <= tp->t_lowat) {
			if (tp->t_state & TS_ASLEEP) {
				tp->t_state &= ~TS_ASLEEP;
				wakeup((caddr_t)&tp->t_outq);
			}
			selwakeup(&tp->t_wsel);
		}
		goto out;
	}
  	cc = ndqb(&tp->t_outq, 0);
	if (cc == 0)
		goto out;
	tp->t_state |= TS_BUSY;
	dp->p_end = dp->p_mem = tp->t_outq.c_cf;
	dp->p_end += cc;
	dcaddr->dc_tcr |= 1 << line;
	wbflush();
out:
	splx(s);
}

/*
 * Stop output on a line.
 */
/*ARGSUSED*/
int /* was void TTTTT */
dcstop(tp, flag)
	register struct tty *tp;
{
	register struct dc_softc *sc;
	register struct pdma *dp;
	register int s;

	sc = dz_cd.cd_devs[DCUNIT(tp->t_dev)];
	dp = &sc->dc_pdma[DCLINE(tp->t_dev)];
	s = spltty();
	if (tp->t_state & TS_BUSY) {
		dp->p_end = dp->p_mem;
		if (!(tp->t_state & TS_TTSTOP))
			tp->t_state |= TS_FLUSH;
	}
	splx(s);
}

int
dcmctl(dev, bits, how)
	dev_t dev;
	int bits, how;
{
	register struct dc_softc *sc;
	register dcregs *dcaddr;
	register int line, mbits;
	int b, s;
	register int tcr, msr;

	line = DCLINE(dev);
	sc = dz_cd.cd_devs[DCUNIT(dev)];
	b = 1 << line;
	dcaddr = (dcregs *)sc->dc_pdma[line].p_addr;
	s = spltty();
	/* only channel 2 has modem control on a DECstation 2100/3100 */
	mbits = DML_DTR | DML_DSR | DML_CAR;
#ifdef HW_FLOW_CONTROL
	mbits != DML_RTS;
#endif /* HW_FLOW_CONTROL */
	switch (line) {
	case  2:  /* pmax partial-modem comms port, full-modem port on 3max */
		mbits = 0;
		tcr = dcaddr->dc_tcr;
		if (tcr & TCR_DTR2)
			mbits |= DML_DTR;
		if ((sc->dc_rtscts & (1<<line)) && (tcr & TCR_RTS2))
			mbits |= DML_RTS;
		msr = dcaddr->dc_msr;
		if (msr & MSR_CD2)
			mbits |= DML_CAR;
		if (msr & MSR_DSR2) {
			/*
			 * XXX really tests for DS_PMAX instead of DS_3MAX
			 * but close enough for now.  Vaxes?
			 */
			if ((sc->dc_rtscts & (1 << line )) == 0 &&
			    (sc->dc_modem & (1 << line )))
				mbits |= DML_CAR | DML_DSR;
			else
				mbits |= DML_DSR;
		}
		break;

	case 3: /* no modem control on pmax, console port on 3max */
	  	/*
		 * XXX really tests for DS_3MAX instead of DS_PMAX
		 * but close enough for now.  Vaxes?
		 */
		if ( sc->dc_modem & (1 << line )) {
			mbits = 0;
			tcr = dcaddr->dc_tcr;
			if (tcr & TCR_DTR3)
				mbits |= DML_DTR;
#ifdef HW_FLOW_CONTROL
			/* XXX OK for get, but not for set? */
			/*if ( sc->dc_rtscts & (1 << line ))*/
			if (tcr & TCR_RTS3)
				mbits |= DML_RTS;
#endif /*HW_FLOW_CONTROL*/
			msr = dcaddr->dc_msr;
			if (msr & MSR_CD3)
				mbits |= DML_CAR;
			if (msr & MSR_DSR3)
				mbits |= DML_DSR;
		}
	}
	switch (how) {
	case DMSET:
		mbits = bits;
		break;

	case DMBIS:
		mbits |= bits;
		break;

	case DMBIC:
		mbits &= ~bits;
		break;

	case DMGET:
		(void) splx(s);
		return (mbits);
	}
	switch (line) {
	case  2: /* 2 */
		tcr = dcaddr->dc_tcr;
		if (mbits & DML_DTR)
			tcr |= TCR_DTR2;
		else
			tcr &= ~TCR_DTR2;
		/*if (pmax_boardtype != DS_PMAX)*/
		if (sc->dc_rtscts & (1 << line)) {
			if (mbits & DML_RTS)
				tcr |= TCR_RTS2;
			else
				tcr &= ~TCR_RTS2;
		}
		dcaddr->dc_tcr = tcr;
		break;

	case 3:
		/* XXX DTR not supported on this line on 2100/3100 */
		/*if (pmax_boardtype != DS_PMAX)*/
		if (sc->dc_modem & (1 << line)) {
			tcr = dcaddr->dc_tcr;
			if (mbits & DML_DTR)
				tcr |= TCR_DTR3;
			else
				tcr &= ~TCR_DTR3;
#ifdef HW_FLOW_CONTROL
		/*if (sc->dc_rtscts & (1 << line))*/
			if (mbits & DML_RTS)
				tcr |= TCR_RTS3;
			else
				tcr &= ~TCR_RTS3;
#endif /* HW_FLOW_CONTROL */
			dcaddr->dc_tcr = tcr;
		}
	}
	(void) splx(s);
	return (mbits);
}

/*
 * This is called by timeout() periodically.
 * Check to see if modem status bits have changed.
 */
void
dcscan(arg)
	void *arg;
{
	register struct dc_softc *sc = dz_cd.cd_devs[0]; /* XXX */
	register dcregs *dcaddr;
	register struct tty *tp;
	register int unit, limit, dtr, dsr;
	int s;

	/* only channel 2 has modem control on a DECstation 2100/3100 */
	dtr = TCR_DTR2;
	dsr = MSR_DSR2;
#ifdef HW_FLOW_CONTROL
	/*limit = (pmax_boardtype == DS_PMAX) ? 2 : 3;*/
	limit =  (sc->dc_rtscts & (1 << 3)) ? 3 : 2;	/*XXX*/
#else
	limit = 2;
#endif
	s = spltty();
	for (unit = 2; unit <= limit; unit++, dtr >>= 2, dsr >>= 8) {
		tp = sc->dc_tty[unit];
		dcaddr = (dcregs *)sc->dc_pdma[unit].p_addr;
		if ((dcaddr->dc_msr & dsr) || (sc->dcsoftCAR & (1 << unit))) {
			/* carrier present */
			if (!(tp->t_state & TS_CARR_ON))
				(void)(*linesw[tp->t_line].l_modem)(tp, 1);
		} else if ((tp->t_state & TS_CARR_ON) &&
		    (*linesw[tp->t_line].l_modem)(tp, 0) == 0)
			dcaddr->dc_tcr &= ~dtr;
#ifdef HW_FLOW_CONTROL
		/*
		 * If we are using hardware flow control and output is stopped,
		 * then resume transmit.
		 */
		if ((tp->t_cflag & CCTS_OFLOW) && (tp->t_state & TS_TTSTOP) &&
		     /*pmax_boardtype != DS_PMAX*/
		    (sc->dc_rtscts & (1 << unit)) ) {
			switch (unit) {
			case 2:
				if (dcaddr->dc_msr & MSR_CTS2)
					break;
				continue;

			case 3:
				if (dcaddr->dc_msr & MSR_CTS3)
					break;
				continue;
			}
			tp->t_state &= ~TS_TTSTOP;
			dcstart(tp);
		}
#endif /* HW_FLOW_CONTROL */
	}
	splx(s);
	timeout(dcscan, (void *)0, hz);
}

/*
 * ----------------------------------------------------------------------------
 *
 * dcGetc --
 *
 *	Read a character from a serial line.
 *
 * Results:
 *	A character read from the serial port.
 *
 * Side effects:
 *	None.
 *
 * ----------------------------------------------------------------------------
 */
int
dcGetc(dev)
	dev_t dev;
{
	register dcregs *dcaddr;
	register int c;
	register int line;
	int s;

	line = DCLINE(dev);
	if (cold && dc_cons_addr) {
		dcaddr = dc_cons_addr;
	} else {
		struct dc_softc *sc;
		sc = dz_cd.cd_devs[DCUNIT(dev)];
		dcaddr = (dcregs *)sc->dc_pdma[line].p_addr;
	}
	if (!dcaddr)
		return (0);
	s = spltty();
	for (;;) {
		if (!(dcaddr->dc_csr & CSR_RDONE))
			continue;
		c = dcaddr->dc_rbuf;
		DELAY(10);
		if (((c >> 8) & 03) == line)
			break;
	}
	splx(s);
	return (c & 0xff);
}

/*
 * Send a char on a port, non interrupt driven.
 */
void
dcPutc(dev, c)
	dev_t dev;
	int c;
{
	register dcregs *dcaddr;
	register u_short tcr;
	register int timeout;
	int s, out_line, activeline;
	int brk;

	s = spltty();
	out_line = DCLINE(dev);
	if (cold && dc_cons_addr) {
		brk = 0;
		dcaddr = dc_cons_addr;
	} else {
		struct dc_softc *sc;

		sc = dz_cd.cd_devs[DCUNIT(dev)];
		dcaddr = (dcregs *)sc->dc_pdma[out_line].p_addr;
		brk = sc->dc_brk;
	}
	tcr = dcaddr->dc_tcr;
	dcaddr->dc_tcr = tcr | (1 << out_line);
	wbflush();
	DELAY(10);
	while (1) {
		/*
		 * Wait for transmitter to be not busy.
		 */
		timeout = 1000000;
		while (!(dcaddr->dc_csr & CSR_TRDY) && timeout > 0)
			timeout--;
		if (timeout == 0) {
			printf("dcPutc: timeout waiting for CSR_TRDY\n");
			break;
		}
		activeline = (dcaddr->dc_csr >> 8) & 3;
		/*
		 * Check to be sure its the right port.
		 */
		if (activeline != out_line) {
			tcr |= 1 << activeline;
			dcaddr->dc_tcr &= ~(1 << out_line);
			wbflush();
			DELAY(10);
			continue;
		}
		/*
		 * Start sending the character.
		 */
		dcaddr->dc_tdr = brk | (c & 0xff);
		wbflush();
		DELAY(10);
		/*
		 * Wait for character to be sent.
		 */
		while (1) {
			/*
			 * cc -O bug: this code produces and infinite loop!
			 * while (!(dcaddr->dc_csr & CSR_TRDY))
			 *	;
			 */
			timeout = 1000000;
			while (!(dcaddr->dc_csr & CSR_TRDY) && timeout > 0)
				timeout--;
			activeline = (dcaddr->dc_csr >> 8) & 3;
			if (activeline != out_line) {
				tcr |= 1 << activeline;
				dcaddr->dc_tcr &= ~(1 << activeline);
				wbflush();
				DELAY(10);
				continue;
			}
			dcaddr->dc_tcr &= ~(1 << out_line);
			wbflush();
			DELAY(10);
			break;
		}
		break;
	}
	/*
	 * Enable interrupts for other lines which became ready.
	 */
	if (tcr & 0xF) {
		dcaddr->dc_tcr = tcr;
		wbflush();
		DELAY(10);
	}

	splx(s);
}


/*
 * Enable/disable polling mode
 */
void
dcPollc(dev, on)
	dev_t dev;
	int on;
{
#if defined(DIAGNOSTIC) || defined(DEBUG)
	printf("dc_Pollc(%d, %d): not implemented\n", minor(dev), on);
#endif
}

@


1.6
log
@unnecessary declaration of ttrstrt
@
text
@@


1.5
log
@changed dc to dz to avoid conflict with if_dc. -moj
@
text
@a137 2
extern void ttrstrt __P((void *));

@


1.4
log
@fix typo ... i hope i got the right one (3 vs. 2)
@
text
@d118 3
a120 3
extern struct cfdriver dc_cd;
struct  cfdriver dc_cd = {
	NULL, "dc", DV_TTY
d385 1
a385 1
	if (unit >= dc_cd.cd_ndevs || line > 4)
d388 1
a388 1
	sc = dc_cd.cd_devs[unit];
d454 1
a454 1
	sc = dc_cd.cd_devs[DCUNIT(dev)];
d480 1
a480 1
	sc = dc_cd.cd_devs[DCUNIT(dev)];
d502 1
a502 1
	sc = dc_cd.cd_devs[DCUNIT(dev)];
d514 1
a514 1
	sc = dc_cd.cd_devs[DCUNIT(dev)];
d537 1
a537 1
	sc = dc_cd.cd_devs[unit];
d606 1
a606 1
	sc = dc_cd.cd_devs[DCUNIT(tp->t_dev)];
d712 1
a712 1
	dc_tty = ((struct dc_softc*)dc_cd.cd_devs[0])->dc_tty;	/* XXX */
d779 1
a779 1
	sc = dc_cd.cd_devs[DCUNIT(tp->t_dev)];	/* XXX */
d849 1
a849 1
	sc = dc_cd.cd_devs[DCUNIT(tp->t_dev)];
d908 1
a908 1
	sc = dc_cd.cd_devs[DCUNIT(tp->t_dev)];
d931 1
a931 1
	sc = dc_cd.cd_devs[DCUNIT(dev)];
d1052 1
a1052 1
	register struct dc_softc *sc = dc_cd.cd_devs[0]; /* XXX */
d1135 1
a1135 1
		sc = dc_cd.cd_devs[DCUNIT(dev)];
d1175 1
a1175 1
		sc = dc_cd.cd_devs[DCUNIT(dev)];
@


1.4.12.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@@


1.3
log
@update the pmax stuff to NetBSD 961107 - this version i got somehow
compiled on my decstation 2100 (PLUTO) - but it will not fully work
out of the box - but i want to bring it into the tree because i get
my own pmax on 961228 - so that i have a good startpoint then :-)

all the OpenBSD changes to the pmax tree will follow in the next commit
@
text
@d1063 1
a1063 1
	limit =  (sc->dc_rtscts & (1 << 3)) :3  : 2;	/*XXX*/
@


1.2
log
@sync to netbsd; for graichen
@
text
@d1 1
a1 1
/*	$NetBSD: dc.c,v 1.16.4.5 1996/06/16 17:15:51 mhitch Exp $	*/
d38 1
a38 1
 *	@@(#)dc.c	8.2 (Berkeley) 11/30/93
a58 2
#include "dc.h"
#if NDC > 0
d62 1
a78 1
#include <machine/machConst.h>
a87 1
#include <pmax/dev/pdma.h>
d90 4
d95 1
d100 3
a102 1
extern int pmax_boardtype;
d105 2
a106 4
struct dc_softc {
	struct device sc_dv;
	struct pdma dc_pdma[4];
};
d114 2
a115 2
int	dcmatch  __P((struct device * parent, void *cfdata, void *aux));
void	dcattach __P((struct device *parent, struct device *self, void *aux));
a116 2
int	dc_doprobe __P((void *addr, int unit, int flags, int pri));
int	dcintr __P((void * xxxunit));
a118 5

struct cfattach dc_ca = {
	sizeof(struct dc_softc), dcmatch, dcattach
};

a123 1
#define	NDCLINE 	(NDC*4)
d125 4
d130 1
d132 1
a132 1
void dcPutc	__P((dev_t, int));
d134 4
a138 2
int dcGetc	__P((dev_t));
int dcparam	__P((struct tty *, struct termios *));
d140 13
a152 5
struct	tty *dc_tty[NDCLINE];
int	dc_cnt = NDCLINE;
void	(*dcDivertXInput)();	/* X windows keyboard input routine */
void	(*dcMouseEvent)();	/* X windows mouse motion event routine */
void	(*dcMouseButtons)();	/* X windows mouse buttons event routine */
a156 5
/*
 * Software copy of brk register since it isn't readable
 */
int	dc_brk[NDC];
char	dcsoftCAR[NDC];		/* mask of dc's with carrier on (DSR) */
a166 1
struct	pdma dcpdma[NDCLINE];
d183 3
d198 1
a198 10
 * Forward declarations
 */
struct tty *dctty __P((dev_t  dev));
void dcrint __P((int));
int dcmctl __P((dev_t dev, int bits, int how));



/*
 * Match driver based on name
d200 2
a201 79
int
dcmatch(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
{
	struct confargs *ca = aux;
#if NTC>0
	struct ioasicdev_attach_args *d = aux;
#endif

	static int nunits = 0;

#if NTC > 0
	if (parent->dv_cfdata->cf_driver == &ioasic_cd) {
		if (strcmp(d->iada_modname, "dc") != 0 &&
		    strcmp(d->iada_modname, "dc7085") != 0)
			return (0);
	}
	else
#endif /* NTC */

	if (parent->dv_cfdata->cf_driver == &mainbus_cd) {
		if (strcmp(ca->ca_name, "dc") != 0 &&
		    strcmp(ca->ca_name, "mdc") != 0 &&
		    strcmp(ca->ca_name, "dc7085") != 0)
			return (0);
	}
	else
		return (0);

	/*
	 * Use statically-allocated softc and attach code until
	 * old config is completely gone.  Don't  over-run softc.
	 */
	if (nunits > NDC) {
		printf("dc: too many units for old config\n");
		return (0);
	}
	nunits++;
	return (1);
}

void
dcattach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	register struct confargs *ca = aux;
#if NTC > 0
	struct ioasicdev_attach_args *d = aux;
#endif /* NTC */
	caddr_t dcaddr;


#if NTC > 0
	if (parent->dv_cfdata->cf_driver == &ioasic_cd) {
		dcaddr = (caddr_t)d->iada_addr;
		(void) dc_doprobe((void*)MACH_PHYS_TO_UNCACHED(dcaddr),
				  self->dv_unit, self->dv_cfdata->cf_flags,
				  (int)d->iada_cookie);
		/* tie pseudo-slot to device */
		ioasic_intr_establish(parent, d->iada_cookie, TC_IPL_TTY,
		    dcintr, self);
	}
	else
#endif /* NTC */
	if (parent->dv_cfdata->cf_driver == &mainbus_cd) {
		dcaddr = (caddr_t)ca->ca_addr;
		(void) dc_doprobe((void*)MACH_PHYS_TO_UNCACHED(dcaddr),
				  self->dv_unit, self->dv_cfdata->cf_flags,
				  ca->ca_slot);

		/* tie pseudo-slot to device */
		BUS_INTR_ESTABLISH(ca, dcintr, self);
	}
	printf("\n");
}
d218 45
d264 1
a264 2
 * DC7085 (dz-11) probe routine from old-style config.
 * This is only here out of intertia.
d267 3
a269 1
dc_doprobe(addr, unit, flags, priority)
d271 1
a271 1
	int unit, flags, priority;
d276 1
a276 1
	register int cntr;
d278 2
a279 5

	if (unit >= NDC)
		return (0);
	if (badaddr(addr, 2))
		return (0);
d284 2
d287 3
a289 2
	if (major(cn_tab->cn_dev) == DCDEV && unit == 0 &&
		cn_tab->cn_pri == CN_REMOTE)
d291 4
a294 8

	/* reset chip */
	dcaddr = (dcregs *)addr;
	dcaddr->dc_csr = CSR_CLR;
	wbflush();
	while (dcaddr->dc_csr & CSR_CLR)
		;
	dcaddr->dc_csr = CSR_MSE | CSR_TIE | CSR_RIE;
d297 2
a298 2
	pdp = &dcpdma[unit * 4];
	for (cntr = 0; cntr < 4; cntr++) {
d300 2
a301 2
		tp = dc_tty[unit * 4 + cntr] = ttymalloc();
		if (cntr != DCKBD_PORT && cntr != DCMOUSE_PORT)
d303 1
d308 1
a308 1
	dcsoftCAR[unit] = flags | 0xB;
d315 5
d323 2
a324 3
	if (unit == 0) {
		if (cn_tab->cn_pri == CN_INTERNAL ||
		    cn_tab->cn_pri == CN_NORMAL) {
d336 2
a337 1
		} else if (major(cn_tab->cn_dev) == DCDEV) {
d339 2
a340 5
			dcaddr->dc_lpr = LPR_RXENAB | LPR_8_BIT_CHAR |
				LPR_B9600 | minor(cn_tab->cn_dev);
			wbflush();
			DELAY(1000);
			/*cn_tab.cn_disabled = 0;*/ /* FIXME */
d344 20
d365 4
a368 1
	return (1);
d371 1
d379 2
a380 1
	register int unit;
d383 3
a385 2
	unit = minor(dev);
	if (unit >= dc_cnt || dcpdma[unit].p_addr == (void *)0)
d387 6
a392 1
	tp = dc_tty[unit];
d394 1
a394 1
		tp = dc_tty[unit] = ttymalloc();
d420 3
d424 4
d449 1
d451 2
a452 1
	register int unit, bit;
d454 8
a461 5
	unit = minor(dev);
	tp = dc_tty[unit];
	bit = 1 << ((unit & 03) + 8);
	if (dc_brk[unit >> 2] & bit) {
		dc_brk[unit >> 2] &= ~bit;
d464 1
d477 1
d480 11
a490 1
	tp = dc_tty[minor(dev)];
d499 1
d502 2
a503 1
	tp = dc_tty[minor(dev)];
d511 5
a515 1
        struct tty *tp = dc_tty [minor (dev)];
d528 1
d530 2
a531 2
	register int unit = minor(dev);
	register int dc = unit >> 2;
d534 6
a539 1
	tp = dc_tty[unit];
d550 1
a550 1
		dc_brk[dc] |= 1 << ((unit & 03) + 8);
d555 1
a555 1
		dc_brk[dc] &= ~(1 << ((unit & 03) + 8));
d589 4
d598 18
d617 2
d623 4
d631 1
a631 1
	    (pmax_boardtype == DS_PMAX && t->c_ospeed == 19200))
a637 2
	dcaddr = (dcregs *)dcpdma[unit].p_addr;

d643 1
a643 1
			dcaddr->dc_lpr = LPR_RXENAB | LPR_8_BIT_CHAR |
d645 1
a645 2
			wbflush();
			return (0);
d647 1
a647 1
			dcaddr->dc_lpr = LPR_RXENAB | LPR_B4800 | LPR_OPAR |
d649 1
a649 2
			wbflush();
			return (0);
d652 2
a653 4
		dcaddr->dc_lpr = LPR_RXENAB | LPR_8_BIT_CHAR |
			LPR_B9600 | unit;
		wbflush();
		return (0);
d659 1
a659 1
	lpr = LPR_RXENAB | ospeed | (unit & 03);
d670 2
d674 1
d679 1
d691 1
a691 4
	register int unit = sc->sc_dv.dv_unit;

	unit <<= 2;
	dcaddr = (dcregs *)dcpdma[unit].p_addr;
d694 1
a694 1
			dcrint(unit);
d696 1
a696 1
			dcxint(dc_tty[unit + ((csr >> 8) & 03)]);
d703 2
a704 2
dcrint(unit)
	register int unit;
d710 3
d714 1
a714 1
	dcaddr = (dcregs *)dcpdma[unit].p_addr;
d717 2
a718 1
		tp = dc_tty[unit + ((c >> 8) & 03)];
d720 2
a721 1
			log(LOG_WARNING, "dc%d,%d: silo overflow\n", unit >> 2,
d726 1
a726 1
		if (tp == dc_tty[DCKBD_PORT] && raster_console()) {
d758 7
d774 1
d777 6
a782 1
	int unit = minor(tp->t_dev);
d784 1
a784 1
	dp = &dcpdma[unit];
d787 29
a815 1
		dcaddr->dc_tdr = dc_brk[unit >> 2] | *dp->p_mem++; 
d833 1
a833 1
		dcaddr->dc_tcr &= ~(1 << (unit & 03));
d843 1
d847 1
a847 1
	int s;
d849 3
a851 1
	dp = &dcpdma[minor(tp->t_dev)];
d866 1
a866 1
	if (tp == dc_tty[DCKBD_PORT] && raster_console()) {
d884 2
a885 2
	cc = ndqb(&tp->t_outq, 0);
	if (cc == 0) 
a886 1

d890 1
a890 1
	dcaddr->dc_tcr |= 1 << (minor(tp->t_dev) & 03);
d900 1
a900 1
int
d904 1
d908 2
a909 1
	dp = &dcpdma[minor(tp->t_dev)];
a916 2

	return (0);
d924 1
d926 1
a926 1
	register int unit, mbits;
d928 1
a928 1
	register int msr;
d930 4
a933 3
	unit = minor(dev);
	b = 1 << (unit & 03);
	dcaddr = (dcregs *)dcpdma[unit].p_addr;
d935 1
a935 1
	/* only channel 2 has modem control (what about line 3?) */
d937 5
a941 2
	switch (unit & 03) {
	case 2:
d943 2
a944 1
		if (dcaddr->dc_tcr & TCR_DTR2)
d946 2
d952 6
a957 1
			if (pmax_boardtype == DS_PMAX)
d964 6
a969 2
	case 3:
		if (pmax_boardtype != DS_PMAX) {
d971 2
a972 1
			if (dcaddr->dc_tcr & TCR_DTR3)
d974 6
d1004 3
a1006 2
	switch (unit & 03) {
	case 2:
d1008 1
a1008 1
			dcaddr->dc_tcr |= TCR_DTR2;
d1010 9
a1018 1
			dcaddr->dc_tcr &= ~TCR_DTR2;
d1022 4
a1025 1
		if (pmax_boardtype != DS_PMAX) {
d1027 7
a1033 1
				dcaddr->dc_tcr |= TCR_DTR3;
d1035 3
a1037 1
				dcaddr->dc_tcr &= ~TCR_DTR3;
a1039 2
	if ((mbits & DML_DTR) && (dcsoftCAR[unit >> 2] & b))
		dc_tty[unit]->t_state |= TS_CARR_ON;
d1052 1
d1055 1
a1055 1
	register int i, bit, car;
d1058 9
d1068 34
a1101 15
	/* only channel 2 has modem control (what about line 3?) */
	dcaddr = (dcregs *)dcpdma[i = 2].p_addr;
	tp = dc_tty[i];
	bit = TCR_DTR2;
	if (dcsoftCAR[i >> 2] & bit)
		car = 1;
	else
		car = dcaddr->dc_msr & MSR_DSR2;
	if (car) {
		/* carrier present */
		if (!(tp->t_state & TS_CARR_ON))
			(void)(*linesw[tp->t_line].l_modem)(tp, 1);
	} else if ((tp->t_state & TS_CARR_ON) &&
	    (*linesw[tp->t_line].l_modem)(tp, 0) == 0)
		dcaddr->dc_tcr &= ~bit;
d1127 1
d1130 8
a1137 1
	dcaddr = (dcregs *)dcpdma[minor(dev)].p_addr;
d1146 1
a1146 1
		if (((c >> 8) & 03) == (minor(dev) & 03))
d1164 2
a1165 1
	int s, line;
d1168 11
a1178 2

	dcaddr = (dcregs *)dcpdma[minor(dev)].p_addr;
d1180 1
a1180 1
	dcaddr->dc_tcr = tcr | (1 << minor(dev));
d1194 1
a1194 1
		line = (dcaddr->dc_csr >> 8) & 3;
d1198 3
a1200 3
		if (line != minor(dev)) {
			tcr |= 1 << line;
			dcaddr->dc_tcr &= ~(1 << line);
d1208 1
a1208 1
		dcaddr->dc_tdr = dc_brk[0] | (c & 0xff);
d1223 4
a1226 4
			line = (dcaddr->dc_csr >> 8) & 3;
			if (line != minor(dev)) {
				tcr |= 1 << line;
				dcaddr->dc_tcr &= ~(1 << line);
d1231 1
a1231 1
			dcaddr->dc_tcr &= ~(1 << minor(dev));
d1249 15
a1263 1
#endif /* NDC */
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: dc.c,v 1.12 1995/09/11 21:29:23 jonathan Exp $	*/
d59 1
a59 1
#include <dc.h>
d77 1
d81 2
d94 3
d99 6
d107 2
a108 1
 * Autoconfiguration data for config.new.
a110 1
 * 
d118 8
a125 3
extern struct cfdriver dccd;
struct  cfdriver dccd = {
	NULL, "dc", dcmatch, dcattach, DV_DULL, sizeof(struct device), 0
d166 15
a180 15
	0,	0,
	50,	LPR_B50,
	75,	LPR_B75,
	110,	LPR_B110,
	134,	LPR_B134,
	150,	LPR_B150,
	300,	LPR_B300,
	600,	LPR_B600,
	1200,	LPR_B1200,
	1800,	LPR_B1800,
	2400,	LPR_B2400,
	4800,	LPR_B4800,
	9600,	LPR_B9600,
	19200,	LPR_B19200,
	-1,	-1
d192 9
a208 1
	struct cfdata *cf = match;
d210 3
d216 16
a231 1
	if (!BUS_MATCHNAME(ca, "dc"))
d253 4
a257 3
	(void) dc_doprobe((void*)MACH_PHYS_TO_UNCACHED(BUS_CVTADDR(ca)),
			  self->dv_unit, self->dv_cfdata->cf_flags,
			  ca->ca_slot);
d259 21
a279 2
	/* tie pseudo-slot to device */
	BUS_INTR_ESTABLISH(ca, dcintr, (void *)self->dv_unit);
d288 2
d298 5
d329 1
a329 1
	MachEmptyWriteBuffer();
d339 2
d361 1
a361 1
			MachEmptyWriteBuffer();
d364 1
a364 1
			MachEmptyWriteBuffer();
d373 1
a373 1
			MachEmptyWriteBuffer();
d383 1
d397 1
a397 1
	if (tp == NULL)
d399 2
d429 2
a430 2
		if (error = ttysleep(tp, (caddr_t)&tp->t_rawq, TTIPRI | PCATCH,
		    ttopen, 0))
d440 1
d463 1
d474 1
d494 1
d497 1
a497 1
	int cmd;
d557 1
d587 1
a587 1
			MachEmptyWriteBuffer();
d592 1
a592 1
			MachEmptyWriteBuffer();
d598 1
a598 1
		MachEmptyWriteBuffer();
d617 1
a617 1
	MachEmptyWriteBuffer();
d629 1
a629 1
	register int unit = (int)xxxunit;
d633 2
d647 1
d715 1
a715 1
		MachEmptyWriteBuffer();
d733 1
a733 1
		MachEmptyWriteBuffer();
d788 1
a788 1
	MachEmptyWriteBuffer();
d797 1
d812 2
d816 1
d989 1
a989 1
	MachEmptyWriteBuffer();
d1009 1
a1009 1
			MachEmptyWriteBuffer();
d1017 1
a1017 1
		MachEmptyWriteBuffer();
d1035 1
a1035 1
				MachEmptyWriteBuffer();
d1040 1
a1040 1
			MachEmptyWriteBuffer();
d1051 1
a1051 1
		MachEmptyWriteBuffer();
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
