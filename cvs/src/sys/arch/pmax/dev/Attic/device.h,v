head	1.8;
access;
symbols
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	UBC_SYNC_A:1.8
	UBC_SYNC_B:1.8
	OPENBSD_2_9:1.7.0.14
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.12
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.10
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.8
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.6
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.4
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2001.06.24.23.47.33;	author deraadt;	state dead;
branches;
next	1.7;

1.7
date	98.05.10.04.01.15;	author millert;	state Exp;
branches
	1.7.8.1;
next	1.6;

1.6
date	97.06.10.14.18.44;	author graichen;	state Exp;
branches;
next	1.5;

1.5
date	96.12.22.15.17.29;	author graichen;	state Exp;
branches;
next	1.4;

1.4
date	96.10.28.11.40.50;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.10.23.13.25.31;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.09.15.21.12.19;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.26;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.26;	author deraadt;	state Exp;
branches;
next	;

1.7.8.1
date	2001.07.04.10.20.45;	author niklas;	state dead;
branches;
next	;


desc
@@


1.8
log
@bye bye, with prejudice
@
text
@/*	$NetBSD: device.h,v 1.12 1997/01/31 02:00:56 thorpej Exp $	*/

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Ralph Campbell.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)device.h	8.1 (Berkeley) 6/10/93
 */

/*
 * This structure is used to encapsulate the routines for a device driver.
 * This allows an "object oriented" approach so a controller device driver
 * can support multiple attached devices or a device can be attached to
 * different types of controllers.
 */
struct ScsiCmd;
struct device;

struct pmax_driver {
	char	*d_name;	/* device driver name (e.g., "rz") */

				/* routine to probe & initialize device */
	int	(*d_init) __P((void *));
				/* routine to start operation */
	void	(*d_start) __P((struct ScsiCmd *cmd));
				/* routine to call when operation complete */
	void	(*d_done) __P(( int unit, int errno, int buflen,
			int status_byte));
				/* routine to call when interrupt is seen */
	int	(*d_intr) __P((void* sc));
};

/*
 * This structure describes controllers directly connected to CPU
 * and is partially initialized in "ioconf.c" by the 'config' program.
 */
struct pmax_ctlr {
	struct pmax_driver *pmax_driver;/* controller driver routines */
	int		pmax_unit;	/* controller number */
	char		*pmax_addr;	/* address of controller */
	int		pmax_pri;	/* interrupt priority */
	int		pmax_flags;	/* flags */

	int		pmax_alive;	/* true if init routine succeeded */
};

/*
 * This structure describes devices connected to a SCSI interface
 * and is partially initialized in "ioconf.c" by the 'config' program.
 */
struct pmax_scsi_device {
	struct pmax_driver *sd_driver;	/* SCSI device driver routines */
	struct pmax_driver *sd_cdriver;	/* SCSI interface driver routines */
	int		sd_unit;	/* device unit number */
	int		sd_ctlr;	/* SCSI interface number */
	int		sd_drive;	/* SCSI address number */
	int		sd_lun;		/* LUN if device has multiple units */
	int		sd_flags;	/* flags */

	int		sd_alive;	/* true if init routine succeeded */
	struct device	*sd_devp;	/* new config glue kludge */
};

/* Define special unit types used by the config program */
#define QUES	-1	/* -1 means '?' */
#define	UNKNOWN -2	/* -2 means not set yet */

/*
 * This structure contains information that a SCSI interface controller 
 * needs to execute a SCSI command.
 */
typedef struct ScsiCmd {
	struct	pmax_scsi_device *sd; /* device requesting the command */
	int	unit;		/* unit number passed to device done routine */
	int	flags;		/* control flags for this command (see below) */
	int	buflen;		/* length of the data buffer in bytes */
	char	*buf;		/* pointer to data buffer for this command */
	int	cmdlen;		/* length of data in cmdbuf */
	u_char	*cmd;		/* buffer for the SCSI command */
	int	error;		/* compatibility hack for new scsi */
} ScsiCmd;

/*
 * Define flags for controlling the SCSI command.
 *
 * SCSICMD_DATA_TO_DEVICE
 *	TRUE -> data is to be transferred to the device.
 *	FALSE -> data is to be transferred from the device.
 *	meaningless if buflen is 0.
 * SCSICMD_USE_SYNC
 *	Attempt to negotiate for a synchronous data transfer.
 */
#define SCSICMD_DATA_TO_DEVICE	0x01
#define SCSICMD_USE_SYNC	0x02

#ifdef _KERNEL
extern struct pmax_ctlr pmax_cinit[];
extern struct pmax_scsi_device scsi_dinit[];

/*
 * Old-style pmax driver glue:
 * Callbacks to add known a controller, and to configure all slaves on
 * all  known controllers.
 */
void pmax_add_scsi __P((struct pmax_driver *dp, int unit));
void configure_scsi __P((void));

#endif	/* _KERNEL */
@


1.7
log
@1) It's a 'lun' not a 'slave'
2) 16 partitions
@
text
@@


1.7.8.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@@


1.6
log
@update the pmax specific stuff to NetBSD-current as of about 970608 - some
cosmetic things will follow together with an update to an exact NETBSD_CU-
RRENT_xxxxxx level
@
text
@d88 1
a88 1
	int		sd_slave;	/* LUN if device has multiple units */
@


1.5
log
@update the pmax stuff to NetBSD 961107 - this version i got somehow
compiled on my decstation 2100 (PLUTO) - but it will not fully work
out of the box - but i want to bring it into the tree because i get
my own pmax on 961228 - so that i have a good startpoint then :-)

all the OpenBSD changes to the pmax tree will follow in the next commit
@
text
@d1 1
a1 1
/*	$NetBSD: device.h,v 1.11 1996/10/01 01:04:50 jonathan Exp $	*/
d48 1
d92 1
@


1.4
log
@Fix d_done prototype
@
text
@d1 1
a1 1
/*	$NetBSD: device.h,v 1.9 1996/04/10 16:27:38 jonathan Exp $	*/
d57 2
a58 1
	void	(*d_done) __P((int, int, int, int));
a87 1
	int		sd_dk;		/* used for disk statistics */
@


1.3
log
@An empty arglist is called __P((void)) not __P(())
@
text
@d57 1
a57 1
	void	(*d_done) __P((void));
@


1.2
log
@sync to netbsd; for graichen
@
text
@d57 1
a57 1
	void	(*d_done) __P(());
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: device.h,v 1.8 1995/09/25 21:10:03 jonathan Exp $	*/
d128 10
a137 1
#endif
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
