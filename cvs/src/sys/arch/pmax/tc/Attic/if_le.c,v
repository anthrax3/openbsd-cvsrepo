head	1.7;
access;
symbols
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	UBC_SYNC_A:1.7
	UBC_SYNC_B:1.7
	SMP:1.7.0.2
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.7
date	96.12.22.15.19.03;	author graichen;	state dead;
branches;
next	1.6;

1.6
date	96.09.15.21.13.24;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	95.12.30.08.44.45;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	95.12.26.18.07.00;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.18.16.43.22;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.26.31;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.36;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.36;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.7
log
@update the pmax stuff to NetBSD 961107 - this version i got somehow
compiled on my decstation 2100 (PLUTO) - but it will not fully work
out of the box - but i want to bring it into the tree because i get
my own pmax on 961228 - so that i have a good startpoint then :-)

all the OpenBSD changes to the pmax tree will follow in the next commit
@
text
@/*	$NetBSD: if_le.c,v 1.13 1996/05/07 01:23:31 thorpej Exp $	*/

/*-
 * Copyright (c) 1995 Charles M. Hannum.  All rights reserved.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Ralph Campbell and Rick Macklem.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)if_le.c	8.2 (Berkeley) 11/16/93
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/syslog.h>
#include <sys/socket.h>
#include <sys/device.h>

#include <net/if.h>

#ifdef INET
#include <netinet/in.h>
#include <netinet/if_ether.h>
#endif

#include <machine/autoconf.h>

#include <dev/ic/am7990reg.h>
#include <dev/ic/am7990var.h>

#include <dev/tc/tcvar.h>
#include <dev/tc/ioasicvar.h>
#include <dev/tc/if_levar.h>

#ifdef pmax
#define wbflush() MachEmptyWriteBuffer()

/* This should be in a header file, but where? */
extern struct cfdriver mainbus_cd;	/* XXX really 3100/5100 b'board */

#include <pmax/pmax/kn01.h>
#include <machine/machConst.h>
#include <pmax/pmax/asic.h>

#else /* Alpha */
#include <machine/rpb.h>
#endif  /* Alpha */

/* access LANCE registers */
void lewritereg();
#define	LERDWR(cntl, src, dst)	{ (dst) = (src); wbflush(); }
#define	LEWREG(src, dst)	lewritereg(&(dst), (src))

#define LE_OFFSET_RAM		0x0
#define LE_OFFSET_LANCE		0x100000
#define LE_OFFSET_ROM		0x1c0000

extern caddr_t le_iomem;

int le_pmax_match __P((struct device *, void *, void *));
void le_pmax_attach __P((struct device *, struct device *, void *));

hide void le_pmax_copytobuf_gap2 __P((struct am7990_softc *, void *,
	    int, int));
hide void le_pmax_copyfrombuf_gap2 __P((struct am7990_softc *, void *,
	    int, int));

hide void le_pmax_copytobuf_gap16 __P((struct am7990_softc *, void *,
	    int, int));
hide void le_pmax_copyfrombuf_gap16 __P((struct am7990_softc *, void *,
	    int, int));
hide void le_pmax_zerobuf_gap16 __P((struct am7990_softc *, int, int));

struct cfattach le_pmax_ca = {
	sizeof(struct le_softc), le_pmax_match, le_pmax_attach
};

hide void le_pmax_wrcsr __P((struct am7990_softc *, u_int16_t, u_int16_t));
hide u_int16_t le_pmax_rdcsr __P((struct am7990_softc *, u_int16_t));  

hide void
le_pmax_wrcsr(sc, port, val)
	struct am7990_softc *sc;
	u_int16_t port, val;
{
	struct lereg1 *ler1 = ((struct le_softc *)sc)->sc_r1;

	LEWREG(port, ler1->ler1_rap);
	LERDWR(port, val, ler1->ler1_rdp);
}

hide u_int16_t
le_pmax_rdcsr(sc, port)
	struct am7990_softc *sc;
	u_int16_t port;
{
	struct lereg1 *ler1 = ((struct le_softc *)sc)->sc_r1;
	u_int16_t val;

	LEWREG(port, ler1->ler1_rap);
	LERDWR(0, ler1->ler1_rdp, val);
	return (val);
}

int
le_pmax_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct cfdata *cf = match;
	struct confargs *ca = aux;
#ifdef notdef /* XXX */
	struct tc_cfloc *tc_locp;
	struct asic_cfloc *asic_locp;
#endif

#ifdef notdef /* XXX */
	tclocp = (struct tc_cfloc *)cf->cf_loc;
#endif

	/* XXX CHECK BUS */
	/* make sure that we're looking for this type of device. */
	if (!TC_BUS_MATCHNAME(ca, "PMAD-BA ") && /* untested alpha TC option */
	    !TC_BUS_MATCHNAME(ca, "PMAD-AA ") && /* KN02 b'board, old option */
	    !TC_BUS_MATCHNAME(ca, "lance"))	/* NetBSD name for b'board  */
		return (0);

#ifdef notdef /* XXX */
	/* make sure the unit matches the cfdata */
	if ((cf->cf_unit != tap->ta_unit &&
	     tap->ta_unit != TA_ANYUNIT) ||
	    (tclocp->cf_slot != tap->ta_slot &&
	     tclocp->cf_slot != TC_SLOT_WILD) ||
	    (tclocp->cf_offset != tap->ta_offset &&
	     tclocp->cf_offset != TC_OFFSET_WILD))
		return (0);
#endif

	return (1);
}

void
le_pmax_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	register struct le_softc *lesc = (void *)self;
	register struct am7990_softc *sc = &lesc->sc_am7990;
	struct confargs *ca = aux;
	u_char *cp;	/* pointer to MAC address */
	int i;

	if (parent->dv_cfdata->cf_driver == &ioasic_cd) {
		/* It's on the system IOCTL ASIC */
		volatile u_int *ldp;
		tc_addr_t dma_mask;

		lesc->sc_r1 = (struct lereg1 *)
		    MACH_PHYS_TO_UNCACHED(ca->ca_addr);
#ifdef alpha
		lesc->sc_r1 = TC_DENSE_TO_SPARSE(sc->sc_r1);
#endif
		sc->sc_mem = (void *)MACH_PHYS_TO_UNCACHED(le_iomem);
/* XXX */	cp = (u_char *)IOASIC_SYS_ETHER_ADDRESS(ioasic_base);

		sc->sc_copytodesc = le_pmax_copytobuf_gap2;
		sc->sc_copyfromdesc = le_pmax_copyfrombuf_gap2;
		sc->sc_copytobuf = le_pmax_copytobuf_gap16;
		sc->sc_copyfrombuf = le_pmax_copyfrombuf_gap16;
		sc->sc_zerobuf = le_pmax_zerobuf_gap16;

		/*
		 * And enable Lance dma through the asic.
		 */
		ldp = (volatile u_int *) (IOASIC_REG_LANCE_DMAPTR(ioasic_base));
		dma_mask = ((tc_addr_t)le_iomem << 3);
#ifdef alpha
		/* Set upper 64 bits of DMA mask */
		dma_mask  = (dma_mask & ~(tc_addr_t)0x1f) |
			(((tc_addr_t)le_iomem >> 29) & 0x1f);
#endif /*alpha*/
		*ldp = dma_mask;
		*(volatile u_int *)IOASIC_REG_CSR(ioasic_base) |=
		    IOASIC_CSR_DMAEN_LANCE;
		wbflush();
	}
	else
	if (parent->dv_cfdata->cf_driver == &tc_cd) {
		/* It's on the turbochannel proper, or on KN02 baseboard. */
		lesc->sc_r1 = (struct lereg1 *)
		    (ca->ca_addr + LE_OFFSET_LANCE);
		sc->sc_mem = (void *)
		    (ca->ca_addr + LE_OFFSET_RAM);
		cp = (u_char *)(ca->ca_addr + LE_OFFSET_ROM + 2);

		sc->sc_copytodesc = am7990_copytobuf_contig;
		sc->sc_copyfromdesc = am7990_copyfrombuf_contig;
		sc->sc_copytobuf = am7990_copytobuf_contig;
		sc->sc_copyfrombuf = am7990_copyfrombuf_contig;
		sc->sc_zerobuf = am7990_zerobuf_contig;
	}
#ifdef pmax
	 else if (parent->dv_cfdata->cf_driver == &mainbus_cd) {
		/* It's on the baseboard, attached directly to mainbus. */

		lesc->sc_r1 = (struct lereg1 *)(ca->ca_addr);
/*XXX*/		sc->sc_mem = (void *)MACH_PHYS_TO_UNCACHED(0x19000000);
/*XXX*/		cp = (u_char *)(MACH_PHYS_TO_UNCACHED(KN01_SYS_CLOCK) + 1);

		sc->sc_copytodesc = le_pmax_copytobuf_gap2;
		sc->sc_copyfromdesc = le_pmax_copyfrombuf_gap2;
		sc->sc_copytobuf = le_pmax_copytobuf_gap2;
		sc->sc_copyfrombuf = le_pmax_copyfrombuf_gap2;
		sc->sc_zerobuf = le_pmax_zerobuf_gap2;
	}
#endif

	sc->sc_rdcsr = le_pmax_rdcsr;
	sc->sc_wrcsr = le_pmax_wrcsr;
	sc->sc_hwinit = NULL;

	sc->sc_conf3 = 0;
	sc->sc_addr = 0;
	sc->sc_memsize = 65536;

	/*
	 * Get the ethernet address out of rom
	 */
	for (i = 0; i < sizeof(sc->sc_arpcom.ac_enaddr); i++) {
		sc->sc_arpcom.ac_enaddr[i] = *cp;
		cp += 4;
	}

	am7990_config(sc);

	BUS_INTR_ESTABLISH(ca, am7990_intr, sc);

	if (parent->dv_cfdata->cf_driver == &ioasic_cd) {
		/* XXX YEECH!!! */
		*(volatile u_int *)IOASIC_REG_IMSK(ioasic_base) |=
			IOASIC_INTR_LANCE;
		wbflush();
	}
}

/*
 * Write a lance register port, reading it back to ensure success. This seems
 * to be necessary during initialization, since the chip appears to be a bit
 * pokey sometimes.
 */
void
lewritereg(regptr, val)
	register volatile u_short *regptr;
	register u_short val;
{
	register int i = 0;

	while (*regptr != val) {
		*regptr = val;
		wbflush();
		if (++i > 10000) {
			printf("le: Reg did not settle (to x%x): x%x\n", val,
			    *regptr);
			return;
		}
		DELAY(100);
	}
}

/*
 * Routines for accessing the transmit and receive buffers are provided
 * by am7990.c, because of the LE_NEED_BUF_* macros defined above.
 * Unfortunately, CPU addressing of these buffers is done in one of
 * 3 ways:
 * - contiguous (for the 3max and turbochannel option card)
 * - gap2, which means shorts (2 bytes) interspersed with short (2 byte)
 *   spaces (for the pmax)
 * - gap16, which means 16bytes interspersed with 16byte spaces
 *   for buffers which must begin on a 32byte boundary (for 3min and maxine)
 * The buffer offset is the logical byte offset, assuming contiguous storage.
 */

/*
 * gap2: two bytes of data followed by two bytes of pad.
 *
 * Buffers must be 4-byte aligned.  The code doesn't worry about
 * doing an extra byte.
 */

void
le_pmax_copytobuf_gap2(sc, fromv, boff, len)
	struct am7990_softc *sc;  
	void *fromv;
	int boff;
	register int len;
{
	volatile caddr_t buf = sc->sc_mem;
	register caddr_t from = fromv;
	register volatile u_int16_t *bptr;  

	if (boff & 0x1) {
		/* handle unaligned first byte */
		bptr = ((volatile u_int16_t *)buf) + (boff - 1);
		*bptr = (*from++ << 8) | (*bptr & 0xff);
		bptr += 2;  
		len--;
	} else
		bptr = ((volatile u_int16_t *)buf) + boff;
	while (len > 1) {
		*bptr = (from[1] << 8) | (from[0] & 0xff);
		bptr += 2;
		from += 2;
		len -= 2;
	}
	if (len == 1)
		*bptr = (u_int16_t)*from;
}

void
le_pmax_copyfrombuf_gap2(sc, tov, boff, len)
	struct am7990_softc *sc;
	void *tov;
	int boff, len;
{
	volatile caddr_t buf = sc->sc_mem;
	register caddr_t to = tov;
	register volatile u_int16_t *bptr;
	register u_int16_t tmp;

	if (boff & 0x1) {
		/* handle unaligned first byte */
		bptr = ((volatile u_int16_t *)buf) + (boff - 1);
		*to++ = (*bptr >> 8) & 0xff;
		bptr += 2;
		len--;
	} else
		bptr = ((volatile u_int16_t *)buf) + boff;
	while (len > 1) {
		tmp = *bptr;
		*to++ = tmp & 0xff;
		*to++ = (tmp >> 8) & 0xff;
		bptr += 2;
		len -= 2;
	}
	if (len == 1)
		*to = *bptr & 0xff;
}

/*
 * gap16: 16 bytes of data followed by 16 bytes of pad.
 *
 * Buffers must be 32-byte aligned.
 */

void
le_pmax_copytobuf_gap16(sc, fromv, boff, len)
	struct am7990_softc *sc;
	void *fromv;
	int boff;
	register int len;
{
	volatile caddr_t buf = sc->sc_mem;
	register caddr_t from = fromv;
	register caddr_t bptr;
	register int xfer;

	bptr = buf + ((boff << 1) & ~0x1f);
	boff &= 0xf;
	xfer = min(len, 16 - boff);
	while (len > 0) {
		bcopy(from, bptr + boff, xfer);
		from += xfer;
		bptr += 32;
		boff = 0;
		len -= xfer;
		xfer = min(len, 16);
	}
}

void
le_pmax_copyfrombuf_gap16(sc, tov, boff, len)
	struct am7990_softc *sc;
	void *tov;
	int boff, len;
{
	volatile caddr_t buf = sc->sc_mem;
	register caddr_t to = tov;
	register caddr_t bptr;
	register int xfer;

	bptr = buf + ((boff << 1) & ~0x1f);
	boff &= 0xf;
	xfer = min(len, 16 - boff);
	while (len > 0) {
		bcopy(bptr + boff, to, xfer);
		to += xfer;
		bptr += 32;
		boff = 0;
		len -= xfer;
		xfer = min(len, 16);
	}
}

void
le_pmax_zerobuf_gap16(sc, boff, len)
	struct am7990_softc *sc;
	int boff, len;
{
	volatile caddr_t buf = sc->sc_mem;
	register caddr_t bptr;
	register int xfer;

	bptr = buf + ((boff << 1) & ~0x1f);
	boff &= 0xf;
	xfer = min(len, 16 - boff);
	while (len > 0) {
		bzero(bptr + boff, xfer);
		bptr += 32;
		boff = 0;
		len -= xfer;
		xfer = min(len, 16);
	}
}
@


1.6
log
@sync to netbsd; for graichen
@
text
@@


1.5
log
@from netbsd:
Use machine-independent TurboChannel include files from dev/tc.
Add machine-dependent TC definitions in pmax/include/tc_machdep.h.
@
text
@d1 1
a1 1
/*	$NetBSD: if_le.c,v 1.7 1995/12/28 08:42:15 jonathan Exp $	*/
d60 3
d70 2
a71 3
/* These should be in a header file, but where? */
extern u_long asic_base;
extern struct cfdriver mainbuscd;	/* XXX really 3100/5100 b'board */
a80 7

#include <dev/ic/am7990reg.h>
#define LE_NEED_BUF_CONTIG
#define LE_NEED_BUF_GAP2
#define LE_NEED_BUF_GAP16
#include <dev/ic/am7990var.h>

d92 2
a93 2
#define	LE_SOFTC(unit)	lecd.cd_devs[unit]
#define	LE_DELAY(x)	DELAY(x)
d95 10
a104 4
int lematch __P((struct device *, void *, void *));
void leattach __P((struct device *, struct device *, void *));

int leintr __P((void *sc));
d106 3
d110 2
a111 3
struct cfdriver lecd = {
	NULL, "le", lematch, leattach, DV_IFNET, sizeof (struct le_softc)
};
d113 3
a115 3
integrate void
lewrcsr(sc, port, val)
	struct le_softc *sc;
d118 1
a118 1
	struct lereg1 *ler1 = sc->sc_r1;
d124 3
a126 3
integrate u_int16_t
lerdcsr(sc, port)
	struct le_softc *sc;
d129 1
a129 1
	struct lereg1 *ler1 = sc->sc_r1;
d138 1
a138 1
lematch(parent, match, aux)
d155 3
a157 3
	if (!BUS_MATCHNAME(ca, "PMAD-BA ") &&	/* untested alpha TC option */
	    !BUS_MATCHNAME(ca, "PMAD-AA ") && /* KN02 baseboard, old option */
	    !BUS_MATCHNAME(ca, "lance"))	/* NetBSD name for b'board  */
d175 1
a175 1
leattach(parent, self, aux)
d179 2
a180 1
	register struct le_softc *sc = (void *)self;
d185 1
a185 1
	if (parent->dv_cfdata->cf_driver == &ioasiccd) {
d190 2
a191 2
		sc->sc_r1 = (struct lereg1 *)
		    MACH_PHYS_TO_UNCACHED(BUS_CVTADDR(ca));
d193 1
a193 1
		sc->sc_r1 = TC_DENSE_TO_SPARSE(sc->sc_r1);
d196 1
a196 1
/* XXX */	cp = (u_char *)ASIC_SYS_ETHER_ADDRESS(asic_base);
d198 5
a202 5
		sc->sc_copytodesc = copytobuf_gap2;
		sc->sc_copyfromdesc = copyfrombuf_gap2;
		sc->sc_copytobuf = copytobuf_gap16;
		sc->sc_copyfrombuf = copyfrombuf_gap16;
		sc->sc_zerobuf = zerobuf_gap16;
d207 1
a207 1
		ldp = (volatile u_int *) (ASIC_REG_LANCE_DMAPTR(asic_base));
d215 2
a216 2
		*(volatile u_int *)ASIC_REG_CSR(asic_base) |=
		    ASIC_CSR_DMAEN_LANCE;
d219 15
d235 1
a235 1
	 else if (parent->dv_cfdata->cf_driver == &mainbuscd) {
d238 1
a238 1
		sc->sc_r1 = (struct lereg1 *)BUS_CVTADDR(ca);
d242 5
a246 5
		sc->sc_copytodesc = copytobuf_gap2;
		sc->sc_copyfromdesc = copyfrombuf_gap2;
		sc->sc_copytobuf = copytobuf_gap2;
		sc->sc_copyfrombuf = copyfrombuf_gap2;
		sc->sc_zerobuf = zerobuf_gap2;
a248 8
	else
	if (parent->dv_cfdata->cf_driver == &tccd) {
		/* It's on the turbochannel proper, or on KN02 baseboard. */
		sc->sc_r1 = (struct lereg1 *)
		    (BUS_CVTADDR(ca) + LE_OFFSET_LANCE);
		sc->sc_mem = (void *)
		    (BUS_CVTADDR(ca) + LE_OFFSET_RAM);
		cp = (u_char *)(BUS_CVTADDR(ca) + LE_OFFSET_ROM + 2);
d250 3
a252 6
		sc->sc_copytodesc = copytobuf_contig;
		sc->sc_copyfromdesc = copyfrombuf_contig;
		sc->sc_copytobuf = copytobuf_contig;
		sc->sc_copyfrombuf = copyfrombuf_contig;
		sc->sc_zerobuf = zerobuf_contig;
	}
d266 1
a266 3
	sc->sc_arpcom.ac_if.if_name = lecd.cd_name;
	leconfig(sc);

d268 1
a268 1
	BUS_INTR_ESTABLISH(ca, leintr, sc);
d270 1
a270 1
	if (parent->dv_cfdata->cf_driver == &ioasiccd) {
d272 2
a273 1
		*(volatile u_int *)ASIC_REG_IMSK(asic_base) |= ASIC_INTR_LANCE;
d315 141
a455 1
#include <dev/ic/am7990.c>
@


1.4
log
@from netbsd:
Add support for ptrace PT_GETREGS and PT_SETREGS for NetBSD/pmax:
 * define PT_GETREGS and PT_SETREGS in pmax/include/ptrace.h
 * Flesh out the stubs in pmax/pmax/process_machdep.c to handle
   those requests.
 * Now that "struct reg" is actually used, remove the bogus
   #ifdef LANGUAGE_C around its definition, and redo pmax/include/reg.h
   so that the definitions needed by locore.S are in a separate file,
   pmax/include/regnum.h.
 * update locore.S to match.
@
text
@d1 1
a1 1
/*	$NetBSD: if_le.c,v 1.5 1995/12/22 12:52:09 jonathan Exp $	*/
d60 4
a64 1
typedef u_int32_t word_t;
a67 2
int	pmax_boardtype;		/* Mother board type */
/*extern u_long le_iomem;*/
d69 1
a69 5

/* does this machine have an ASIC? */
#define SYSTEM_HAS_ASIC() \
  (pmax_boardtype == DS_MAXINE || pmax_boardtype == DS_3MIN || \
   pmax_boardtype == DS_3MAXPLUS)
a72 2
#include <pmax/pmax/pmaxtype.h>
#include <pmax/tc/tc.h>
d74 1
a74 1
#include <pmax/tc/if_levar.h>
a75 5

typedef  u_int64 word_t;
#define SYSTEM_HAS_ASIC() \
 (hwrpb->rpb_type == ST_DEC_3000_300 || hwrpb->rpb_type == ST_DEC_3000_500)

a76 4
#include <alpha/tc/tc.h>
#include <alpha/tc/asic.h>
#include <alpha/tc/if_levar.h>

a79 1

d181 2
a182 2
	if (sc->sc_dev.dv_unit == 0 && SYSTEM_HAS_ASIC()) {
		/* It's on the system ASIC */
d184 1
a184 1
		word_t dma_mask;
d204 1
a204 1
		dma_mask = ((word_t)le_iomem << 3);
d207 2
a208 2
		dma_mask  = (dma_mask & ~(word_t)0x1f) |
			(((word_t)le_iomem >> 29) & 0x1f);
d216 1
a216 1
	 else if (sc->sc_dev.dv_unit == 0 && (pmax_boardtype == DS_PMAX)) {
d230 2
a231 1
	else {
d264 1
a264 1
	if (SYSTEM_HAS_ASIC()) {
@


1.3
log
@update from netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: if_le.c,v 1.4 1995/12/17 04:46:00 jonathan Exp $	*/
d225 1
@


1.2
log
@update from netbsd (verbatim)
@
text
@d1 1
a1 1
/*	$NetBSD: if_le.c,v 1.3 1995/11/25 01:23:51 cgd Exp $	*/
a79 1
#define LEINTR_UNIT	1	/* pmax interrupts take a unit as arg */
a117 3
#ifdef LEINTR_UNIT
int leintr __P((int unit));
#else
d119 1
a119 1
#endif
d274 1
a274 3
#ifdef LEINTR_UNIT
	BUS_INTR_ESTABLISH(ca, leintr, self->dv_unit);
#else
d276 1
a276 1
#endif
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: if_le.c,v 1.2.2.1 1995/10/13 03:22:51 jonathan Exp $	*/
d80 1
d97 3
a101 1

a115 18
/*
 * Routines for accessing the transmit and receive buffers. Unfortunately,
 * CPU addressing of these buffers is done in one of 3 ways:
 * - contiguous (for the 3max and turbochannel option card)
 * - gap2, which means shorts (2 bytes) interspersed with short (2 byte)
 *   spaces (for the kn01)
 * - gap16, which means 16bytes interspersed with 16byte spaces
 *   for buffers which must begin on a 32byte boundary (for 3min,
 *   maxine and 3maxplus).  The gap16 machines still need gap2 for DMA
 *   ring-buffer descriptors.
 * These functions are now defined in the machine-independent code;
 * set the preprocessor macros that say which ones we need.
 */

#define	LE_NEED_BUF_CONTIG
#define	LE_NEED_BUF_GAP2
#define	LE_NEED_BUF_GAP16

d119 5
a123 1
int leintr __P((void *));
a128 10
void copytobuf_contig __P((struct le_softc *, void *, int, int));
void copyfrombuf_contig __P((struct le_softc *, void *, int, int));
void zerobuf_contig __P((struct le_softc *, int, int));
integrate void copytobuf_gap16 __P((struct le_softc *, void *, int, int));
integrate void copyfrombuf_gap16 __P((struct le_softc *, void *, int, int));
integrate void zerobuf_gap16 __P((struct le_softc *, int, int));
integrate void copytobuf_gap2 __P((struct le_softc *, void *, int, int));
integrate void copyfrombuf_gap2 __P((struct le_softc *, void *, int, int));
integrate void zerobuf_gap2 __P((struct le_softc *, int, int));

d173 1
a173 1
	    !BUS_MATCHNAME(ca, "lance"))  /* Our name for baseboard devices */
d207 1
a207 2

#ifdef alpha	/* !pmax */
d209 1
a209 2
#endif	/* !pmax */

d224 1
a224 2

#ifdef alpha /* !pmax */
d228 1
a228 3
#endif /* alpha*/

		*ldp = dma_mask;
d232 1
a232 1
	} else
d234 1
a234 1
	if (sc->sc_dev.dv_unit == 0 && (pmax_boardtype == DS_PMAX)) {
d247 1
a247 1
#endif	/* pmax */
d278 3
d282 1
a282 1

a313 7
#include <dev/ic/am7990.c>

/**
 ** XXX These could arguably go in dev/ic/am7990.c, or at least somewhere
 **     sharable with other Lance drivers that need them.
 **/

d315 10
a324 7
 * Routines for accessing the transmit and receive buffers.
 * The various CPU and adapter configurations supported by this
 * driver require three different access methods for buffers
 * and descriptors:
 *	(1) contig (contiguous data; no padding),
 *	(2) gap2 (two bytes of data followed by two bytes of padding),
 *	(3) gap16 (16 bytes of data followed by 16 bytes of padding).
d327 1
a327 218
#ifdef LE_NEED_BUF_CONTIG
/*
 * contig: contiguous data with no padding.
 *
 * Buffers may have any alignment.
 */

/*integrate*/ void
copytobuf_contig(sc, from, boff, len)
	struct le_softc *sc;
	void *from;
	int boff, len;
{
	volatile caddr_t buf = sc->sc_mem;

	/*
	 * Just call bcopy() to do the work.
	 */
	bcopy(from, buf + boff, len);
}

/*integrate*/ void
copyfrombuf_contig(sc, to, boff, len)
	struct le_softc *sc;
	void *to;
	int boff, len;
{
	volatile caddr_t buf = sc->sc_mem;

	/*
	 * Just call bcopy() to do the work.
	 */
	bcopy(buf + boff, to, len);
}

/*integrate*/ void
zerobuf_contig(sc, boff, len)
	struct le_softc *sc;
	int boff, len;
{
	volatile caddr_t buf = sc->sc_mem;

	/*
	 * Just let bzero() do the work
	 */
	bzero(buf + boff, len);
}
#endif /* LE_NEED_BUF_CONTIG */

#ifdef LE_NEED_BUF_GAP2
/*
 * gap2: two bytes of data followed by two bytes of pad.
 *
 * Buffers must be 4-byte aligned.  The code doesn't worry about
 * doing an extra byte.
 */

integrate void
copytobuf_gap2(sc, fromv, boff, len)
	struct le_softc *sc;
	void *fromv;
	int boff;
	register int len;
{
	volatile caddr_t buf = sc->sc_mem;
	register caddr_t from = fromv;
	register volatile u_int16_t *bptr;
	register int xfer;

	if (boff & 0x1) {
		/* handle unaligned first byte */
		bptr = ((volatile u_int16_t *)buf) + (boff - 1);
		*bptr = (*from++ << 8) | (*bptr & 0xff);
		bptr += 2;
		len--;
	} else
		bptr = ((volatile u_int16_t *)buf) + boff;
	while (len > 1) {
		*bptr = (from[1] << 8) | (from[0] & 0xff);
		bptr += 2;
		from += 2;
		len -= 2;
	}
	if (len == 1)
		*bptr = (u_int16_t)*from;
}

integrate void
copyfrombuf_gap2(sc, tov, boff, len)
	struct le_softc *sc;
	void *tov;
	int boff, len;
{
	volatile caddr_t buf = sc->sc_mem;
	register caddr_t to = tov;
	register volatile u_int16_t *bptr;
	register u_int16_t tmp;
	register int xfer;

	if (boff & 0x1) {
		/* handle unaligned first byte */
		bptr = ((volatile u_int16_t *)buf) + (boff - 1);
		*to++ = (*bptr >> 8) & 0xff;
		bptr += 2;
		len--;
	} else
		bptr = ((volatile u_int16_t *)buf) + boff;
	while (len > 1) {
		tmp = *bptr;
		*to++ = tmp & 0xff;
		*to++ = (tmp >> 8) & 0xff;
		bptr += 2;
		len -= 2;
	}
	if (len == 1)
		*to = *bptr & 0xff;
}

integrate void
zerobuf_gap2(sc, boff, len)
	struct le_softc *sc;
	int boff, len;
{
	volatile caddr_t buf = sc->sc_mem;
	register volatile u_int16_t *bptr;

	if ((unsigned)boff & 0x1) {
		bptr = ((volatile u_int16_t *)buf) + (boff - 1);
		*bptr &= 0xff;
		bptr += 2;
		len--;
	} else
		bptr = ((volatile u_int16_t *)buf) + boff;
	while (len > 0) {
		*bptr = 0;
		bptr += 2;
		len -= 2;
	}
}
#endif /* LE_NEED_BUF_GAP2 */

#ifdef LE_NEED_BUF_GAP16
/*
 * gap16: 16 bytes of data followed by 16 bytes of pad.
 *
 * Buffers must be 32-byte aligned.
 */

integrate void
copytobuf_gap16(sc, fromv, boff, len)
	struct le_softc *sc;
	void *fromv;
	int boff;
	register int len;
{
	volatile caddr_t buf = sc->sc_mem;
	register caddr_t from = fromv;
	register caddr_t bptr;
	register int xfer;

	bptr = buf + ((boff << 1) & ~0x1f);
	boff &= 0xf;
	xfer = min(len, 16 - boff);
	while (len > 0) {
		bcopy(from, bptr + boff, xfer);
		from += xfer;
		bptr += 32;
		boff = 0;
		len -= xfer;
		xfer = min(len, 16);
	}
}

integrate void
copyfrombuf_gap16(sc, tov, boff, len)
	struct le_softc *sc;
	void *tov;
	int boff, len;
{
	volatile caddr_t buf = sc->sc_mem;
	register caddr_t to = tov;
	register caddr_t bptr;
	register int xfer;

	bptr = buf + ((boff << 1) & ~0x1f);
	boff &= 0xf;
	xfer = min(len, 16 - boff);
	while (len > 0) {
		bcopy(bptr + boff, to, xfer);
		to += xfer;
		bptr += 32;
		boff = 0;
		len -= xfer;
		xfer = min(len, 16);
	}
}

integrate void
zerobuf_gap16(sc, boff, len)
	struct le_softc *sc;
	int boff, len;
{
	volatile caddr_t buf = sc->sc_mem;
	register caddr_t bptr;
	register int xfer;

	bptr = buf + ((boff << 1) & ~0x1f);
	boff &= 0xf;
	xfer = min(len, 16 - boff);
	while (len > 0) {
		bzero(bptr + boff, xfer);
		bptr += 32;
		boff = 0;
		len -= xfer;
		xfer = min(len, 16);
	}
}
#endif /* LE_NEED_BUF_GAP16 */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
