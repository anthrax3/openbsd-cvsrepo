head	1.231;
access;
symbols
	OPENBSD_6_2_BASE:1.231
	OPENBSD_6_1:1.226.0.4
	OPENBSD_6_1_BASE:1.226
	OPENBSD_6_0:1.221.0.2
	OPENBSD_6_0_BASE:1.221
	OPENBSD_5_9:1.217.0.2
	OPENBSD_5_9_BASE:1.217
	OPENBSD_5_8:1.215.0.4
	OPENBSD_5_8_BASE:1.215
	OPENBSD_5_7:1.206.0.2
	OPENBSD_5_7_BASE:1.206
	OPENBSD_5_6:1.189.0.4
	OPENBSD_5_6_BASE:1.189
	OPENBSD_5_5:1.173.0.4
	OPENBSD_5_5_BASE:1.173
	OPENBSD_5_4:1.165.0.2
	OPENBSD_5_4_BASE:1.165
	OPENBSD_5_3:1.160.0.2
	OPENBSD_5_3_BASE:1.160
	OPENBSD_5_2:1.155.0.2
	OPENBSD_5_2_BASE:1.155
	OPENBSD_5_1_BASE:1.152
	OPENBSD_5_1:1.152.0.2
	OPENBSD_5_0:1.149.0.2
	OPENBSD_5_0_BASE:1.149
	OPENBSD_4_9:1.130.0.2
	OPENBSD_4_9_BASE:1.130
	OPENBSD_4_8:1.119.0.2
	OPENBSD_4_8_BASE:1.119
	OPENBSD_4_7:1.105.0.2
	OPENBSD_4_7_BASE:1.105
	OPENBSD_4_6:1.96.0.4
	OPENBSD_4_6_BASE:1.96
	OPENBSD_4_5:1.88.0.2
	OPENBSD_4_5_BASE:1.88
	OPENBSD_4_4:1.82.0.2
	OPENBSD_4_4_BASE:1.82
	OPENBSD_4_3:1.67.0.2
	OPENBSD_4_3_BASE:1.67
	OPENBSD_4_2:1.60.0.2
	OPENBSD_4_2_BASE:1.60
	OPENBSD_4_1:1.55.0.2
	OPENBSD_4_1_BASE:1.55
	OPENBSD_4_0:1.50.0.2
	OPENBSD_4_0_BASE:1.50
	OPENBSD_3_9:1.45.0.4
	OPENBSD_3_9_BASE:1.45
	OPENBSD_3_8:1.35.0.2
	OPENBSD_3_8_BASE:1.35
	OPENBSD_3_7:1.30.0.4
	OPENBSD_3_7_BASE:1.30
	OPENBSD_3_6:1.30.0.2
	OPENBSD_3_6_BASE:1.30
	SMP_SYNC_A:1.24
	SMP_SYNC_B:1.24
	OPENBSD_3_5:1.22.0.2
	OPENBSD_3_5_BASE:1.22
	SMP:1.5.0.2;
locks; strict;
comment	@ * @;


1.231
date	2017.07.12.06.26.32;	author natano;	state Exp;
branches;
next	1.230;
commitid	Jb2yji2oX9woPvMw;

1.230
date	2017.06.29.07.19.40;	author mlarkin;	state Exp;
branches;
next	1.229;
commitid	ahMaROXls0LeFLGN;

1.229
date	2017.05.18.09.20.06;	author kettenis;	state Exp;
branches;
next	1.228;
commitid	JOc8Yh7oTJlujapO;

1.228
date	2017.04.30.16.45.45;	author mpi;	state Exp;
branches;
next	1.227;
commitid	2Gtqjzrin9LL2yHk;

1.227
date	2017.04.30.13.04.49;	author mpi;	state Exp;
branches;
next	1.226;
commitid	xDPbcPU6tYP39nZG;

1.226
date	2017.03.11.11.55.03;	author mpi;	state Exp;
branches;
next	1.225;
commitid	eXDj5wwfsbdFBB4L;

1.225
date	2017.03.07.11.49.42;	author natano;	state Exp;
branches;
next	1.224;
commitid	qcVMvyIHDSrZgRKv;

1.224
date	2017.03.02.10.38.09;	author natano;	state Exp;
branches;
next	1.223;
commitid	EeVoCYFCx2tYicZQ;

1.223
date	2016.10.09.11.25.39;	author tom;	state Exp;
branches;
next	1.222;
commitid	DfYvEDcFmu1LY9q1;

1.222
date	2016.09.18.14.28.24;	author deraadt;	state Exp;
branches;
next	1.221;
commitid	BJaYTqaJQ1246GGO;

1.221
date	2016.05.21.00.56.43;	author deraadt;	state Exp;
branches;
next	1.220;
commitid	oWpLaBOdDMvIxei3;

1.220
date	2016.05.16.01.48.28;	author mlarkin;	state Exp;
branches;
next	1.219;
commitid	65gBGnAnVuQSxYFk;

1.219
date	2016.05.10.18.39.42;	author deraadt;	state Exp;
branches;
next	1.218;
commitid	qfOifNidEGDB2jL1;

1.218
date	2016.04.03.17.48.33;	author guenther;	state Exp;
branches;
next	1.217;
commitid	9ebLv9UDmLVagKMI;

1.217
date	2015.10.21.07.59.17;	author mpi;	state Exp;
branches;
next	1.216;
commitid	XglPgGQ8qaiL0M4l;

1.216
date	2015.08.30.10.05.09;	author yasuoka;	state Exp;
branches;
next	1.215;
commitid	8KYmU15QlyhusRif;

1.215
date	2015.07.16.23.03.40;	author sf;	state Exp;
branches;
next	1.214;
commitid	vQBQlDELfKUomsax;

1.214
date	2015.06.28.18.54.54;	author guenther;	state Exp;
branches;
next	1.213;
commitid	9qSlzkscc1lVVnYi;

1.213
date	2015.06.07.06.24.59;	author guenther;	state Exp;
branches;
next	1.212;
commitid	TPuT1ptKkvRzlUfp;

1.212
date	2015.05.24.01.01.49;	author guenther;	state Exp;
branches;
next	1.211;
commitid	ZeKgaxXwOerLHwE3;

1.211
date	2015.05.18.19.59.27;	author guenther;	state Exp;
branches;
next	1.210;
commitid	MLFvGCnCMKMdmAtY;

1.210
date	2015.04.25.21.21.02;	author guenther;	state Exp;
branches;
next	1.209;
commitid	VKvPrYVxXk7Ixzez;

1.209
date	2015.04.18.22.16.21;	author kettenis;	state Exp;
branches;
next	1.208;
commitid	yRnPx9jjsPnb6oP6;

1.208
date	2015.03.25.21.05.18;	author kettenis;	state Exp;
branches;
next	1.207;
commitid	k6HPjf5wfG49EBGs;

1.207
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.206;
commitid	p4LJxGKbi0BU2cG6;

1.206
date	2015.01.12.16.33.31;	author deraadt;	state Exp;
branches;
next	1.205;
commitid	A44BjxYQVmvEK2uf;

1.205
date	2015.01.06.12.50.47;	author dlg;	state Exp;
branches;
next	1.204;
commitid	EAvvmUR28EGEqQFd;

1.204
date	2014.12.21.16.27.07;	author mlarkin;	state Exp;
branches;
next	1.203;
commitid	dB4lAFOCpyuORTUm;

1.203
date	2014.12.18.05.33.48;	author mlarkin;	state Exp;
branches;
next	1.202;
commitid	JVgpC5JUPLFOXy8N;

1.202
date	2014.12.15.01.53.45;	author tedu;	state Exp;
branches;
next	1.201;
commitid	zTvdNqjakdDTl6z6;

1.201
date	2014.12.10.15.29.52;	author mikeb;	state Exp;
branches;
next	1.200;
commitid	qHQiR2HLROzvZr7B;

1.200
date	2014.12.08.07.12.37;	author mlarkin;	state Exp;
branches;
next	1.199;
commitid	9gsjQWzKEbWkbtZI;

1.199
date	2014.12.02.18.13.10;	author tedu;	state Exp;
branches;
next	1.198;
commitid	ZYUxNRICiD9sC1vn;

1.198
date	2014.11.22.18.55.20;	author deraadt;	state Exp;
branches;
next	1.197;
commitid	nFIm5oOp8CCDBtjV;

1.197
date	2014.11.22.18.31.46;	author mlarkin;	state Exp;
branches;
next	1.196;
commitid	OZhulzwbZ5ey9UWV;

1.196
date	2014.11.18.20.51.00;	author krw;	state Exp;
branches;
next	1.195;
commitid	G35ycnLxaVis5TX9;

1.195
date	2014.11.16.12.30.56;	author deraadt;	state Exp;
branches;
next	1.194;
commitid	yv0ECmCdICvq576h;

1.194
date	2014.11.08.03.31.58;	author guenther;	state Exp;
branches;
next	1.193;
commitid	YFizaenkUOfymebA;

1.193
date	2014.10.09.04.18.09;	author tedu;	state Exp;
branches;
next	1.192;
commitid	TALRTC31uBKXjwur;

1.192
date	2014.09.27.08.27.17;	author mlarkin;	state Exp;
branches;
next	1.191;
commitid	i5yi9pGJ06IurEA4;

1.191
date	2014.09.27.07.56.18;	author mlarkin;	state Exp;
branches;
next	1.190;
commitid	SJza6NQ6eSqybU6h;

1.190
date	2014.09.19.20.02.25;	author kettenis;	state Exp;
branches;
next	1.189;
commitid	lZNawJpIJwhgF8VB;

1.189
date	2014.07.21.17.25.47;	author uebayasi;	state Exp;
branches;
next	1.188;
commitid	7QO4UJr3EKVAMc8t;

1.188
date	2014.07.13.22.53.38;	author uebayasi;	state Exp;
branches;
next	1.187;
commitid	wsdp3qtXGjMj98oD;

1.187
date	2014.07.13.22.13.06;	author uebayasi;	state Exp;
branches;
next	1.186;
commitid	qYPOd6Qi4aRBKldK;

1.186
date	2014.07.13.12.11.01;	author jasper;	state Exp;
branches;
next	1.185;
commitid	XHZxhpAa5R1Ymp1z;

1.185
date	2014.07.11.22.28.05;	author uebayasi;	state Exp;
branches;
next	1.184;
commitid	fOXKrBuMmlMGQdd4;

1.184
date	2014.07.10.21.46.02;	author mpi;	state Exp;
branches;
next	1.183;
commitid	iYq3Z1ZWDKR3sS9G;

1.183
date	2014.07.10.20.15.26;	author uebayasi;	state Exp;
branches;
next	1.182;
commitid	YzvTa4t6mddz7Mh4;

1.182
date	2014.07.10.13.34.32;	author uebayasi;	state Exp;
branches;
next	1.181;
commitid	xpsLTYRIkonFtkr1;

1.181
date	2014.07.10.12.13.48;	author uebayasi;	state Exp;
branches;
next	1.180;
commitid	aofvn6ceiucgjg4N;

1.180
date	2014.06.15.11.43.24;	author sf;	state Exp;
branches;
next	1.179;
commitid	Y0AWLKcfCeF28jP4;

1.179
date	2014.05.31.15.49.28;	author mpi;	state Exp;
branches;
next	1.178;
commitid	eA4Y0YE1IUzj6hpW;

1.178
date	2014.05.30.13.46.16;	author mpi;	state Exp;
branches;
next	1.177;

1.177
date	2014.03.29.18.09.28;	author guenther;	state Exp;
branches;
next	1.176;

1.176
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.175;

1.175
date	2014.03.22.06.05.45;	author guenther;	state Exp;
branches;
next	1.174;

1.174
date	2014.03.13.03.52.55;	author dlg;	state Exp;
branches;
next	1.173;

1.173
date	2014.01.05.20.23.56;	author mlarkin;	state Exp;
branches;
next	1.172;

1.172
date	2013.12.23.23.23.22;	author deraadt;	state Exp;
branches;
next	1.171;

1.171
date	2013.11.19.04.12.17;	author guenther;	state Exp;
branches;
next	1.170;

1.170
date	2013.11.02.15.02.27;	author kettenis;	state Exp;
branches;
next	1.169;

1.169
date	2013.10.05.17.25.00;	author guenther;	state Exp;
branches;
next	1.168;

1.168
date	2013.10.05.16.58.30;	author guenther;	state Exp;
branches;
next	1.167;

1.167
date	2013.09.29.12.56.31;	author kettenis;	state Exp;
branches;
next	1.166;

1.166
date	2013.09.28.12.40.28;	author miod;	state Exp;
branches;
next	1.165;

1.165
date	2013.06.29.21.06.15;	author brad;	state Exp;
branches;
next	1.164;

1.164
date	2013.06.11.16.42.06;	author deraadt;	state Exp;
branches;
next	1.163;

1.163
date	2013.06.02.16.38.05;	author guenther;	state Exp;
branches;
next	1.162;

1.162
date	2013.03.21.15.50.27;	author deraadt;	state Exp;
branches;
next	1.161;

1.161
date	2013.03.02.07.02.07;	author guenther;	state Exp;
branches;
next	1.160;

1.160
date	2013.01.16.05.49.48;	author dlg;	state Exp;
branches;
next	1.159;

1.159
date	2012.12.02.07.03.31;	author guenther;	state Exp;
branches;
next	1.158;

1.158
date	2012.10.19.16.38.30;	author mlarkin;	state Exp;
branches;
next	1.157;

1.157
date	2012.10.09.12.58.07;	author jsing;	state Exp;
branches;
next	1.156;

1.156
date	2012.10.08.21.47.47;	author deraadt;	state Exp;
branches;
next	1.155;

1.155
date	2012.06.04.15.19.47;	author jsing;	state Exp;
branches;
next	1.154;

1.154
date	2012.06.03.13.18.32;	author kettenis;	state Exp;
branches;
next	1.153;

1.153
date	2012.05.06.04.20.40;	author guenther;	state Exp;
branches;
next	1.152;

1.152
date	2012.01.13.12.55.52;	author jsing;	state Exp;
branches;
next	1.151;

1.151
date	2012.01.11.19.33.28;	author krw;	state Exp;
branches;
next	1.150;

1.150
date	2012.01.11.15.58.27;	author jsing;	state Exp;
branches;
next	1.149;

1.149
date	2011.07.10.18.11.49;	author deraadt;	state Exp;
branches;
next	1.148;

1.148
date	2011.07.05.04.48.01;	author guenther;	state Exp;
branches;
next	1.147;

1.147
date	2011.07.04.15.54.24;	author guenther;	state Exp;
branches;
next	1.146;

1.146
date	2011.07.04.06.05.56;	author guenther;	state Exp;
branches;
next	1.145;

1.145
date	2011.07.03.20.22.07;	author oga;	state Exp;
branches;
next	1.144;

1.144
date	2011.06.26.22.39.59;	author deraadt;	state Exp;
branches;
next	1.143;

1.143
date	2011.06.05.19.41.06;	author deraadt;	state Exp;
branches;
next	1.142;

1.142
date	2011.05.30.22.25.20;	author oga;	state Exp;
branches;
next	1.141;

1.141
date	2011.04.26.17.33.17;	author jsing;	state Exp;
branches;
next	1.140;

1.140
date	2011.04.18.21.44.55;	author guenther;	state Exp;
branches;
next	1.139;

1.139
date	2011.04.17.20.38.09;	author deraadt;	state Exp;
branches;
next	1.138;

1.138
date	2011.04.15.04.52.39;	author guenther;	state Exp;
branches;
next	1.137;

1.137
date	2011.04.13.02.49.12;	author guenther;	state Exp;
branches;
next	1.136;

1.136
date	2011.04.10.03.56.38;	author guenther;	state Exp;
branches;
next	1.135;

1.135
date	2011.04.05.21.14.00;	author guenther;	state Exp;
branches;
next	1.134;

1.134
date	2011.04.02.18.16.50;	author oga;	state Exp;
branches;
next	1.133;

1.133
date	2011.04.02.17.36.45;	author beck;	state Exp;
branches;
next	1.132;

1.132
date	2011.03.20.21.44.08;	author guenther;	state Exp;
branches;
next	1.131;

1.131
date	2011.03.18.03.10.47;	author guenther;	state Exp;
branches;
next	1.130;

1.130
date	2011.01.13.20.34.04;	author mikeb;	state Exp;
branches;
next	1.129;

1.129
date	2010.11.22.21.07.16;	author miod;	state Exp;
branches;
next	1.128;

1.128
date	2010.11.20.20.33.23;	author miod;	state Exp;
branches;
next	1.127;

1.127
date	2010.11.13.04.16.42;	author guenther;	state Exp;
branches;
next	1.126;

1.126
date	2010.10.26.05.49.10;	author guenther;	state Exp;
branches;
next	1.125;

1.125
date	2010.10.14.04.38.24;	author guenther;	state Exp;
branches;
next	1.124;

1.124
date	2010.10.02.23.31.33;	author deraadt;	state Exp;
branches;
next	1.123;

1.123
date	2010.10.02.23.30.39;	author deraadt;	state Exp;
branches;
next	1.122;

1.122
date	2010.09.29.15.11.31;	author joshe;	state Exp;
branches;
next	1.121;

1.121
date	2010.09.29.13.46.38;	author joshe;	state Exp;
branches;
next	1.120;

1.120
date	2010.09.21.01.04.12;	author matthew;	state Exp;
branches;
next	1.119;

1.119
date	2010.08.05.21.10.10;	author deraadt;	state Exp;
branches;
next	1.118;

1.118
date	2010.07.25.21.43.38;	author deraadt;	state Exp;
branches;
next	1.117;

1.117
date	2010.07.23.14.56.31;	author kettenis;	state Exp;
branches;
next	1.116;

1.116
date	2010.07.01.23.06.33;	author kettenis;	state Exp;
branches;
next	1.115;

1.115
date	2010.07.01.19.56.12;	author mlarkin;	state Exp;
branches;
next	1.114;

1.114
date	2010.06.30.19.23.15;	author oga;	state Exp;
branches;
next	1.113;

1.113
date	2010.06.27.13.28.46;	author miod;	state Exp;
branches;
next	1.112;

1.112
date	2010.06.27.03.03.48;	author thib;	state Exp;
branches;
next	1.111;

1.111
date	2010.06.10.17.54.13;	author deraadt;	state Exp;
branches;
next	1.110;

1.110
date	2010.06.05.05.55.56;	author deraadt;	state Exp;
branches;
next	1.109;

1.109
date	2010.05.18.19.42.48;	author oga;	state Exp;
branches;
next	1.108;

1.108
date	2010.05.18.07.05.18;	author halex;	state Exp;
branches;
next	1.107;

1.107
date	2010.05.13.19.27.24;	author oga;	state Exp;
branches;
next	1.106;

1.106
date	2010.03.24.00.36.04;	author oga;	state Exp;
branches;
next	1.105;

1.105
date	2010.03.08.03.40.50;	author jolan;	state Exp;
branches;
next	1.104;

1.104
date	2010.03.07.04.14.22;	author deraadt;	state Exp;
branches;
next	1.103;

1.103
date	2010.03.01.07.08.27;	author dlg;	state Exp;
branches;
next	1.102;

1.102
date	2009.11.23.16.21.54;	author pirofti;	state Exp;
branches;
next	1.101;

1.101
date	2009.08.11.19.17.16;	author miod;	state Exp;
branches;
next	1.100;

1.100
date	2009.08.11.18.46.31;	author miod;	state Exp;
branches;
next	1.99;

1.99
date	2009.08.09.10.40.17;	author blambert;	state Exp;
branches;
next	1.98;

1.98
date	2009.08.02.16.28.39;	author beck;	state Exp;
branches;
next	1.97;

1.97
date	2009.07.22.20.33.12;	author deraadt;	state Exp;
branches;
next	1.96;

1.96
date	2009.06.15.17.01.25;	author beck;	state Exp;
branches;
next	1.95;

1.95
date	2009.06.14.03.04.07;	author deraadt;	state Exp;
branches;
next	1.94;

1.94
date	2009.06.07.02.01.54;	author oga;	state Exp;
branches;
next	1.93;

1.93
date	2009.06.03.21.30.19;	author beck;	state Exp;
branches;
next	1.92;

1.92
date	2009.06.02.03.04.54;	author jordan;	state Exp;
branches;
next	1.91;

1.91
date	2009.05.30.20.47.00;	author kettenis;	state Exp;
branches;
next	1.90;

1.90
date	2009.04.30.01.16.56;	author dlg;	state Exp;
branches;
next	1.89;

1.89
date	2009.04.20.15.44.49;	author reyk;	state Exp;
branches;
next	1.88;

1.88
date	2009.02.15.02.03.40;	author marco;	state Exp;
branches;
next	1.87;

1.87
date	2009.01.02.05.16.15;	author miod;	state Exp;
branches;
next	1.86;

1.86
date	2008.12.30.05.33.15;	author miod;	state Exp;
branches;
next	1.85;

1.85
date	2008.11.22.18.12.32;	author art;	state Exp;
branches;
next	1.84;

1.84
date	2008.10.09.19.04.18;	author kettenis;	state Exp;
branches;
next	1.83;

1.83
date	2008.10.06.21.05.56;	author kettenis;	state Exp;
branches;
next	1.82;

1.82
date	2008.08.12.18.27.22;	author weingart;	state Exp;
branches;
next	1.81;

1.81
date	2008.06.27.17.22.14;	author miod;	state Exp;
branches;
next	1.80;

1.80
date	2008.06.26.05.42.09;	author ray;	state Exp;
branches;
next	1.79;

1.79
date	2008.06.11.18.49.50;	author weingart;	state Exp;
branches;
next	1.78;

1.78
date	2008.06.10.02.55.39;	author weingart;	state Exp;
branches;
next	1.77;

1.77
date	2008.06.08.13.55.06;	author kettenis;	state Exp;
branches;
next	1.76;

1.76
date	2008.06.02.11.46.19;	author jsg;	state Exp;
branches;
next	1.75;

1.75
date	2008.05.23.15.39.43;	author jasper;	state Exp;
branches;
next	1.74;

1.74
date	2008.04.30.13.59.33;	author dlg;	state Exp;
branches;
next	1.73;

1.73
date	2008.04.25.11.30.22;	author dlg;	state Exp;
branches;
next	1.72;

1.72
date	2008.04.24.12.33.14;	author dlg;	state Exp;
branches;
next	1.71;

1.71
date	2008.04.12.12.49.28;	author kettenis;	state Exp;
branches;
next	1.70;

1.70
date	2008.04.09.16.58.10;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2008.03.29.15.26.47;	author krw;	state Exp;
branches;
next	1.68;

1.68
date	2008.03.17.23.17.24;	author deraadt;	state Exp;
branches;
next	1.67;

1.67
date	2007.12.11.17.53.18;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2007.11.25.09.11.12;	author jsg;	state Exp;
branches;
next	1.65;

1.65
date	2007.11.03.22.23.35;	author mikeb;	state Exp;
branches;
next	1.64;

1.64
date	2007.10.31.15.55.46;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2007.10.28.10.25.09;	author martin;	state Exp;
branches;
next	1.62;

1.62
date	2007.10.17.02.30.26;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2007.08.26.18.54.37;	author kettenis;	state Exp;
branches;
next	1.60;

1.60
date	2007.08.02.16.40.27;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2007.06.06.17.15.11;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2007.05.29.20.36.47;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2007.05.26.20.26.50;	author pedro;	state Exp;
branches;
next	1.56;

1.56
date	2007.05.23.20.33.46;	author pvalchev;	state Exp;
branches;
next	1.55;

1.55
date	2007.02.17.23.59.03;	author marco;	state Exp;
branches;
next	1.54;

1.54
date	2007.02.01.20.42.17;	author art;	state Exp;
branches;
next	1.53;

1.53
date	2007.01.15.23.19.05;	author jsg;	state Exp;
branches;
next	1.52;

1.52
date	2006.11.07.09.09.42;	author otto;	state Exp;
branches;
next	1.51;

1.51
date	2006.10.01.10.52.10;	author kettenis;	state Exp;
branches;
next	1.50;

1.50
date	2006.05.31.10.34.54;	author todd;	state Exp;
branches;
next	1.49;

1.49
date	2006.05.27.04.46.12;	author gwk;	state Exp;
branches;
next	1.48;

1.48
date	2006.05.20.22.38.52;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2006.03.15.21.03.37;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2006.03.09.17.24.00;	author weingart;	state Exp;
branches;
next	1.45;

1.45
date	2006.01.19.18.21.03;	author grange;	state Exp;
branches;
next	1.44;

1.44
date	2006.01.06.10.53.16;	author grange;	state Exp;
branches;
next	1.43;

1.43
date	2006.01.06.10.42.34;	author grange;	state Exp;
branches;
next	1.42;

1.42
date	2005.12.16.23.00.03;	author marco;	state Exp;
branches;
next	1.41;

1.41
date	2005.12.13.00.18.19;	author jsg;	state Exp;
branches;
next	1.40;

1.40
date	2005.11.13.21.44.06;	author fgsch;	state Exp;
branches;
next	1.39;

1.39
date	2005.11.13.17.51.52;	author fgsch;	state Exp;
branches;
next	1.38;

1.38
date	2005.10.28.16.59.19;	author kettenis;	state Exp;
branches;
next	1.37;

1.37
date	2005.10.26.18.46.06;	author martin;	state Exp;
branches;
next	1.36;

1.36
date	2005.09.19.01.28.04;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2005.08.06.14.26.50;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2005.08.01.16.18.43;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2005.08.01.15.42.39;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2005.07.26.08.38.29;	author art;	state Exp;
branches;
next	1.31;

1.31
date	2005.06.02.20.09.38;	author tholo;	state Exp;
branches;
next	1.30;

1.30
date	2004.08.03.00.56.22;	author art;	state Exp;
branches;
next	1.29;

1.29
date	2004.07.19.15.09.05;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2004.07.08.04.23.04;	author david;	state Exp;
branches;
next	1.27;

1.27
date	2004.07.03.20.36.04;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2004.06.25.11.03.27;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2004.06.22.01.16.50;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2004.05.13.20.20.24;	author sturm;	state Exp;
branches;
next	1.23;

1.23
date	2004.05.05.16.43.53;	author marc;	state Exp;
branches;
next	1.22;

1.22
date	2004.03.11.21.06.01;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2004.03.10.23.02.53;	author tom;	state Exp;
branches;
next	1.20;

1.20
date	2004.03.09.23.06.38;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2004.03.09.23.05.13;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2004.02.28.22.26.05;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2004.02.27.23.45.23;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2004.02.27.22.10.01;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2004.02.27.21.55.49;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2004.02.27.21.55.25;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2004.02.27.17.41.25;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2004.02.25.00.16.04;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2004.02.24.20.26.24;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2004.02.24.00.20.45;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2004.02.23.09.12.59;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2004.02.23.01.19.52;	author tom;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.21.03.00.23;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.19.18.48.44;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.13.03.37.10;	author mickey;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2004.02.13.00.05.52;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.03.12.09.47;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2004.01.29.13.21.10;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.28.01.39.39;	author mickey;	state Exp;
branches;
next	;

1.5.2.1
date	2004.02.22.22.08.18;	author niklas;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2004.06.05.23.09.24;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.231
log
@remove CPU_LIDSUSPEND/machdep.lidsuspend

"fire away!" tedu
@
text
@/*	$OpenBSD: machdep.c,v 1.230 2017/06/29 07:19:40 mlarkin Exp $	*/
/*	$NetBSD: machdep.c,v 1.3 2003/05/07 22:58:18 fvdl Exp $	*/

/*-
 * Copyright (c) 1996, 1997, 1998, 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Charles M. Hannum and by Jason R. Thorpe of the Numerical Aerospace
 * Simulation Facility, NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*-
 * Copyright (c) 1982, 1987, 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * William Jolitz.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)machdep.c	7.4 (Berkeley) 6/3/91
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/signal.h>
#include <sys/signalvar.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/exec.h>
#include <sys/buf.h>
#include <sys/reboot.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/msgbuf.h>
#include <sys/mount.h>
#include <sys/vnode.h>
#include <sys/extent.h>
#include <sys/core.h>
#include <sys/kcore.h>
#include <sys/syscallargs.h>

#include <dev/cons.h>
#include <stand/boot/bootarg.h>

#include <net/if.h>
#include <uvm/uvm.h>

#include <sys/sysctl.h>

#include <machine/cpu.h>
#include <machine/cpufunc.h>
#include <machine/pio.h>
#include <machine/psl.h>
#include <machine/reg.h>
#include <machine/specialreg.h>
#include <machine/fpu.h>
#include <machine/biosvar.h>
#include <machine/mpbiosvar.h>
#include <machine/kcore.h>
#include <machine/tss.h>

#include <dev/isa/isareg.h>
#include <machine/isa_machdep.h>
#include <dev/ic/i8042reg.h>

#ifdef DDB
#include <machine/db_machdep.h>
#include <ddb/db_extern.h>
extern int db_console;
#endif

#include "isa.h"
#include "isadma.h"
#include "ksyms.h"

#include "acpi.h"
#if NACPI > 0
#include <dev/acpi/acpivar.h>
#endif

#include "com.h"
#if NCOM > 0
#include <sys/tty.h>
#include <dev/ic/comvar.h>
#include <dev/ic/comreg.h>
#endif

#include "softraid.h"
#if NSOFTRAID > 0
#include <dev/softraidvar.h>
#endif

#ifdef HIBERNATE
#include <machine/hibernate_var.h>
#endif /* HIBERNATE */

#include "ukbd.h"
#include "pckbc.h"
#if NPCKBC > 0 && NUKBD > 0
#include <dev/ic/pckbcvar.h>
#endif

/* the following is used externally (sysctl_hw) */
char machine[] = MACHINE;

/*
 * switchto vectors
 */
void (*cpu_idle_leave_fcn)(void) = NULL;
void (*cpu_idle_cycle_fcn)(void) = NULL;
void (*cpu_idle_enter_fcn)(void) = NULL;

/* the following is used externally for concurrent handlers */
int setperf_prio = 0;

#ifdef CPURESET_DELAY
int	cpureset_delay = CPURESET_DELAY;
#else
int     cpureset_delay = 0;
#endif

int	physmem;
u_int64_t	dumpmem_low;
u_int64_t	dumpmem_high;
extern int	boothowto;
int	cpu_class;

paddr_t	dumpmem_paddr;
vaddr_t	dumpmem_vaddr;
psize_t	dumpmem_sz;

vaddr_t kern_end;

vaddr_t	msgbuf_vaddr;
paddr_t msgbuf_paddr;

vaddr_t	idt_vaddr;
paddr_t	idt_paddr;

vaddr_t lo32_vaddr;
paddr_t lo32_paddr;
paddr_t tramp_pdirpa;

int kbd_reset;
int lid_action = 1;
int forceukbd;

/*
 * safepri is a safe priority for sleep to set for a spin-wait
 * during autoconfiguration or after a panic.
 */
int	safepri = 0;

struct vm_map *exec_map = NULL;
struct vm_map *phys_map = NULL;

/* UVM constraint ranges. */
struct uvm_constraint_range  isa_constraint = { 0x0, 0x00ffffffUL };
struct uvm_constraint_range  dma_constraint = { 0x0, 0xffffffffUL };
struct uvm_constraint_range *uvm_md_constraints[] = {
    &isa_constraint,
    &dma_constraint,
    NULL,
};

#ifdef DEBUG
int sigdebug = 0;
pid_t sigpid = 0;
#define SDB_FOLLOW      0x01
#endif

paddr_t avail_start;
paddr_t avail_end;

void (*delay_func)(int) = i8254_delay;
void (*initclock_func)(void) = i8254_initclocks;

/*
 * Format of boot information passed to us by 32-bit /boot
 */
typedef struct _boot_args32 {
	int	ba_type;
	int	ba_size;
	int	ba_nextX;	/* a ptr in 32-bit world, but not here */
	char	ba_arg[1];
} bootarg32_t;

#define BOOTARGC_MAX	NBPG	/* one page */

bios_bootmac_t *bios_bootmac;

/* locore copies the arguments from /boot to here for us */
char bootinfo[BOOTARGC_MAX];
int bootinfo_size = BOOTARGC_MAX;

void getbootinfo(char *, int);

/* Data passed to us by /boot, filled in by getbootinfo() */
bios_diskinfo_t	*bios_diskinfo;
bios_memmap_t	*bios_memmap;
u_int32_t	bios_cksumlen;
bios_efiinfo_t	*bios_efiinfo;

/*
 * Size of memory segments, before any memory is stolen.
 */
phys_ram_seg_t mem_clusters[VM_PHYSSEG_MAX];
int	mem_cluster_cnt;

int	cpu_dump(void);
int	cpu_dumpsize(void);
u_long	cpu_dump_mempagecnt(void);
void	dumpsys(void);
void	cpu_init_extents(void);
void	map_tramps(void);
void	init_x86_64(paddr_t);
void	(*cpuresetfn)(void);

#ifdef APERTURE
int allowaperture = 0;
#endif

/*
 * Machine-dependent startup code
 */
void
cpu_startup(void)
{
	vaddr_t minaddr, maxaddr;

	msgbuf_vaddr = PMAP_DIRECT_MAP(msgbuf_paddr);
	initmsgbuf((caddr_t)msgbuf_vaddr, round_page(MSGBUFSIZE));

	printf("%s", version);
	startclocks();

	printf("real mem = %lu (%luMB)\n", ptoa((psize_t)physmem),
	    ptoa((psize_t)physmem)/1024/1024);

	/*
	 * Allocate a submap for exec arguments.  This map effectively
	 * limits the number of processes exec'ing at any time.
	 */
	minaddr = vm_map_min(kernel_map);
	exec_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
				   16*NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);

	/*
	 * Allocate a submap for physio
	 */
	minaddr = vm_map_min(kernel_map);
	phys_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
				   VM_PHYS_SIZE, 0, FALSE, NULL);

	printf("avail mem = %lu (%luMB)\n", ptoa((psize_t)uvmexp.free),
	    ptoa((psize_t)uvmexp.free)/1024/1024);

	bufinit();

	if (boothowto & RB_CONFIG) {
#ifdef BOOT_CONFIG
		user_config();
#else
		printf("kernel does not support -c; continuing..\n");
#endif
	}

	/* Safe for i/o port / memory space allocation to use malloc now. */
	x86_bus_space_mallocok();
}

/*
 * Set up proc0's PCB and the cpu's TSS.
 */
void
x86_64_proc0_tss_ldt_init(void)
{
	struct pcb *pcb;

	cpu_info_primary.ci_curpcb = pcb = &proc0.p_addr->u_pcb;
	pcb->pcb_cr0 = rcr0();
	pcb->pcb_fsbase = 0;
	pcb->pcb_kstack = (u_int64_t)proc0.p_addr + USPACE - 16;
	proc0.p_md.md_regs = (struct trapframe *)pcb->pcb_kstack - 1;

	/* an empty iomap, by setting its offset to the TSS limit */
	cpu_info_primary.ci_tss->tss_iobase = sizeof(struct x86_64_tss);
	cpu_info_primary.ci_tss->tss_rsp0 = pcb->pcb_kstack;
	cpu_info_primary.ci_tss->tss_ist[0] =
	    (u_int64_t)proc0.p_addr + PAGE_SIZE - 16;

	ltr(GSYSSEL(GPROC0_SEL, SEL_KPL));
	lldt(0);
}

/*       
 * Set up TSS for a new PCB.
 */         
         
#ifdef MULTIPROCESSOR
void    
x86_64_init_pcb_tss_ldt(struct cpu_info *ci)   
{        
	struct pcb *pcb = ci->ci_idle_pcb;
 
	ci->ci_tss->tss_iobase = sizeof(*ci->ci_tss);
	ci->ci_tss->tss_rsp0 = pcb->pcb_kstack;
	ci->ci_tss->tss_ist[0] = pcb->pcb_kstack - USPACE + PAGE_SIZE;

	pcb->pcb_cr0 = rcr0();
}       
#endif	/* MULTIPROCESSOR */

bios_diskinfo_t *
bios_getdiskinfo(dev_t dev)
{
	bios_diskinfo_t *pdi;

	if (bios_diskinfo == NULL)
		return NULL;

	for (pdi = bios_diskinfo; pdi->bios_number != -1; pdi++) {
		if ((dev & B_MAGICMASK) == B_DEVMAGIC) { /* search by bootdev */
			if (pdi->bsd_dev == dev)
				break;
		} else {
			if (pdi->bios_number == dev)
				break;
		}
	}

	if (pdi->bios_number == -1)
		return NULL;
	else
		return pdi;
}

int
bios_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen, struct proc *p)
{
	bios_diskinfo_t *pdi;
	extern dev_t bootdev;
	int biosdev;

	/* all sysctl names at this level except diskinfo are terminal */
	if (namelen != 1 && name[0] != BIOS_DISKINFO)
		return (ENOTDIR);	       /* overloaded */

	if (!(bootapiver & BAPIV_VECTOR))
		return EOPNOTSUPP;

	switch (name[0]) {
	case BIOS_DEV:
		if ((pdi = bios_getdiskinfo(bootdev)) == NULL)
			return ENXIO;
		biosdev = pdi->bios_number;
		return sysctl_rdint(oldp, oldlenp, newp, biosdev);
	case BIOS_DISKINFO:
		if (namelen != 2)
			return ENOTDIR;
		if ((pdi = bios_getdiskinfo(name[1])) == NULL)
			return ENXIO;
		return sysctl_rdstruct(oldp, oldlenp, newp, pdi, sizeof(*pdi));
	case BIOS_CKSUMLEN:
		return sysctl_rdint(oldp, oldlenp, newp, bios_cksumlen);
	default:
		return EOPNOTSUPP;
	}
	/* NOTREACHED */
}

/*  
 * machine dependent system variables.
 */ 
int
cpu_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen, struct proc *p)
{
	extern int amd64_has_xcrypt;
	dev_t consdev;
	dev_t dev;
	int val, error;

	switch (name[0]) {
	case CPU_CONSDEV:
		if (namelen != 1)
			return (ENOTDIR);		/* overloaded */
		if (cn_tab != NULL)
			consdev = cn_tab->cn_dev;
		else
			consdev = NODEV;
		return (sysctl_rdstruct(oldp, oldlenp, newp, &consdev,
		    sizeof consdev));
	case CPU_CHR2BLK:
		if (namelen != 2)
			return (ENOTDIR);		/* overloaded */
		dev = chrtoblk((dev_t)name[1]);
		return sysctl_rdstruct(oldp, oldlenp, newp, &dev, sizeof(dev));
	case CPU_BIOS:
		return bios_sysctl(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen, p);
	case CPU_CPUVENDOR:
		return (sysctl_rdstring(oldp, oldlenp, newp, cpu_vendor));
	case CPU_CPUID:
		return (sysctl_rdint(oldp, oldlenp, newp, cpu_id));
	case CPU_CPUFEATURE:
		return (sysctl_rdint(oldp, oldlenp, newp, cpu_feature));
	case CPU_KBDRESET:
		if (securelevel > 0)
			return (sysctl_rdint(oldp, oldlenp, newp,
			    kbd_reset));
		else
			return (sysctl_int(oldp, oldlenp, newp, newlen,
			    &kbd_reset));
	case CPU_ALLOWAPERTURE:
		if (namelen != 1)
			return (ENOTDIR);		/* overloaded */
#ifdef APERTURE
		if (securelevel > 0)
			return (sysctl_int_lower(oldp, oldlenp, newp, newlen,
			    &allowaperture));
		else
			return (sysctl_int(oldp, oldlenp, newp, newlen,
			    &allowaperture));
#else
		return (sysctl_rdint(oldp, oldlenp, newp, 0));
#endif
	case CPU_XCRYPT:
		return (sysctl_rdint(oldp, oldlenp, newp, amd64_has_xcrypt));
	case CPU_LIDACTION:
		val = lid_action;
		error = sysctl_int(oldp, oldlenp, newp, newlen, &val);
		if (!error) {
			if (val < 0 || val > 2)
				error = EINVAL;
			else
				lid_action = val;
		}
		return (error);
#if NPCKBC > 0 && NUKBD > 0
	case CPU_FORCEUKBD:
		if (forceukbd)
			return (sysctl_rdint(oldp, oldlenp, newp, forceukbd));

		error = sysctl_int(oldp, oldlenp, newp, newlen, &forceukbd);
		if (forceukbd)
			pckbc_release_console();
		return (error);
#endif
	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
}

/*
 * Send an interrupt to process.
 *
 * Stack is set up to allow sigcode stored
 * in u. to call routine, followed by kcall
 * to sigreturn routine below.  After sigreturn
 * resets the signal mask, the stack, and the
 * frame pointer, it returns to the user
 * specified pc, psl.
 */
void
sendsig(sig_t catcher, int sig, int mask, u_long code, int type,
    union sigval val)
{
	struct proc *p = curproc;
	struct trapframe *tf = p->p_md.md_regs;
	struct sigacts *psp = p->p_p->ps_sigacts;
	struct sigcontext ksc;
	siginfo_t ksi;
	register_t sp, scp, sip;
	u_long sss;

	memcpy(&ksc, tf, sizeof(*tf));
	bzero((char *)&ksc + sizeof(*tf), sizeof(ksc) - sizeof(*tf));
	ksc.sc_mask = mask;

	/* Allocate space for the signal handler context. */
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0 &&
	    !sigonstack(tf->tf_rsp) && (psp->ps_sigonstack & sigmask(sig)))
		sp = (register_t)p->p_sigstk.ss_sp + p->p_sigstk.ss_size;
	else
		sp = tf->tf_rsp - 128;

	sp &= ~15ULL;	/* just in case */
	sss = (sizeof(ksc) + 15) & ~15;

	if (p->p_md.md_flags & MDP_USEDFPU) {
		fpusave_proc(p, 1);
		sp -= fpu_save_len;
		ksc.sc_fpstate = (struct fxsave64 *)sp;
		if (copyout(&p->p_addr->u_pcb.pcb_savefpu.fp_fxsave,
		    (void *)sp, fpu_save_len))
			sigexit(p, SIGILL);

		/* Signal handlers get a completely clean FP state */
		p->p_md.md_flags &= ~MDP_USEDFPU;
	}

	sip = 0;
	if (psp->ps_siginfo & sigmask(sig)) {
		sip = sp - ((sizeof(ksi) + 15) & ~15);
		sss += (sizeof(ksi) + 15) & ~15;

		initsiginfo(&ksi, sig, code, type, val);
		if (copyout(&ksi, (void *)sip, sizeof(ksi)))
			sigexit(p, SIGILL);
	}
	scp = sp - sss;

	ksc.sc_cookie = (long)scp ^ p->p_p->ps_sigcookie;
	if (copyout(&ksc, (void *)scp, sizeof(ksc)))
		sigexit(p, SIGILL);

	/*
	 * Build context to run handler in.
	 */
	tf->tf_rax = (u_int64_t)catcher;
	tf->tf_rdi = sig;
	tf->tf_rsi = sip;
	tf->tf_rdx = scp;

	tf->tf_rip = (u_int64_t)p->p_p->ps_sigcode;
	tf->tf_cs = GSEL(GUCODE_SEL, SEL_UPL);
	tf->tf_rflags &= ~(PSL_T|PSL_D|PSL_VM|PSL_AC);
	tf->tf_rsp = scp;
	tf->tf_ss = GSEL(GUDATA_SEL, SEL_UPL);
}

/*
 * System call to cleanup state after a signal
 * has been taken.  Reset signal mask and
 * stack state from context left by sendsig (above).
 * Return to previous pc and psl as specified by
 * context left by sendsig. Check carefully to
 * make sure that the user has not modified the
 * psl to gain improper privileges or to cause
 * a machine fault.
 */
int
sys_sigreturn(struct proc *p, void *v, register_t *retval)
{
	struct sys_sigreturn_args /* {
		syscallarg(struct sigcontext *) sigcntxp;
	} */ *uap = v;
	struct sigcontext ksc, *scp = SCARG(uap, sigcntxp);
	struct trapframe *tf = p->p_md.md_regs;
	int error;

	if (PROC_PC(p) != p->p_p->ps_sigcoderet) {
		sigexit(p, SIGILL);
		return (EPERM);
	}

	if ((error = copyin((caddr_t)scp, &ksc, sizeof ksc)))
		return (error);

	if (ksc.sc_cookie != ((long)scp ^ p->p_p->ps_sigcookie)) {
		sigexit(p, SIGILL);
		return (EFAULT);
	}

	/* Prevent reuse of the sigcontext cookie */
	ksc.sc_cookie = 0;
	(void)copyout(&ksc.sc_cookie, (caddr_t)scp +
	    offsetof(struct sigcontext, sc_cookie), sizeof (ksc.sc_cookie));

	if (((ksc.sc_rflags ^ tf->tf_rflags) & PSL_USERSTATIC) != 0 ||
	    !USERMODE(ksc.sc_cs, ksc.sc_eflags))
		return (EINVAL);

	if (p->p_md.md_flags & MDP_USEDFPU)
		fpusave_proc(p, 0);

	if (ksc.sc_fpstate) {
		struct fxsave64 *fx = &p->p_addr->u_pcb.pcb_savefpu.fp_fxsave;

		if ((error = copyin(ksc.sc_fpstate, fx, fpu_save_len)))
			return (error);
		fx->fx_mxcsr &= fpu_mxcsr_mask;
		p->p_md.md_flags |= MDP_USEDFPU;
	}

	ksc.sc_trapno = tf->tf_trapno;
	ksc.sc_err = tf->tf_err;
	memcpy(tf, &ksc, sizeof(*tf));

	/* Restore signal mask. */
	p->p_sigmask = ksc.sc_mask & ~sigcantmask;

	/*
	 * sigreturn() needs to return to userspace via the 'iretq'
	 * method, so that if the process was interrupted (by tick,
	 * an IPI, whatever) as opposed to already being in the kernel
	 * when a signal was being delivered, the process will be
	 * completely restored, including the userland %rcx and %r11
	 * registers which the 'sysretq' instruction cannot restore.
	 */
	p->p_md.md_flags |= MDP_IRET;

	return (EJUSTRETURN);
}

#ifdef MULTIPROCESSOR
/* force a CPU into the kernel, whether or not it's idle */
void
cpu_kick(struct cpu_info *ci)
{
	/* only need to kick other CPUs */
	if (ci != curcpu()) {
		if (cpu_mwait_size > 0) {
			/*
			 * If not idling, then send an IPI, else
			 * just clear the "keep idling" bit.
			 */
			if ((ci->ci_mwait & MWAIT_IN_IDLE) == 0)
				x86_send_ipi(ci, X86_IPI_NOP);
			else
				atomic_clearbits_int(&ci->ci_mwait,
				    MWAIT_KEEP_IDLING);
		} else {
			/* no mwait, so need an IPI */
			x86_send_ipi(ci, X86_IPI_NOP);
		}
	}
}
#endif

/*
 * Notify the current process (p) that it has a signal pending,
 * process as soon as possible.
 */
void
signotify(struct proc *p)
{
	aston(p);
	cpu_kick(p->p_cpu);
}

#ifdef MULTIPROCESSOR
void
cpu_unidle(struct cpu_info *ci)
{
	if (cpu_mwait_size > 0 && (ci->ci_mwait & MWAIT_ONLY)) {
		/*
		 * Just clear the "keep idling" bit; if it wasn't
		 * idling then we didn't need to do anything anyway.
		 */
		atomic_clearbits_int(&ci->ci_mwait, MWAIT_KEEP_IDLING);
		return;
	}

	if (ci != curcpu())
		x86_send_ipi(ci, X86_IPI_NOP);
}
#endif

int	waittime = -1;
struct pcb dumppcb;

__dead void
boot(int howto)
{
	if ((howto & RB_POWERDOWN) != 0)
		lid_action = 0;

	if (cold) {
		if ((howto & RB_USERREQ) == 0)
			howto |= RB_HALT;
		goto haltsys;
	}

	boothowto = howto;
	if ((howto & RB_NOSYNC) == 0 && waittime < 0) {
		waittime = 0;
		vfs_shutdown();

		if ((howto & RB_TIMEBAD) == 0) {
			resettodr();
		} else {
			printf("WARNING: not updating battery clock\n");
		}
	}
	if_downall();

	uvm_shutdown();
	splhigh();
	cold = 1;

	if ((howto & RB_DUMP) != 0)
		dumpsys();

haltsys:
	config_suspend_all(DVACT_POWERDOWN);

#ifdef MULTIPROCESSOR
	x86_broadcast_ipi(X86_IPI_HALT);
#endif

	if ((howto & RB_HALT) != 0) {
#if NACPI > 0 && !defined(SMALL_KERNEL)
		extern int acpi_enabled;

		if (acpi_enabled) {
			delay(500000);
			if ((howto & RB_POWERDOWN) != 0)
				acpi_powerdown();
		}
#endif
		printf("\n");
		printf("The operating system has halted.\n");
		printf("Please press any key to reboot.\n\n");
		cnpollc(1);	/* for proper keyboard command handling */
		cngetc();
		cnpollc(0);
	}

	printf("rebooting...\n");
	if (cpureset_delay > 0)
		delay(cpureset_delay * 1000);
	cpu_reset();
	for (;;)
		continue;
	/* NOTREACHED */
}

/*
 * These variables are needed by /sbin/savecore
 */
u_long	dumpmag = 0x8fca0101;	/* magic number */
int 	dumpsize = 0;		/* pages */
long	dumplo = 0; 		/* blocks */

/*
 * cpu_dump: dump the machine-dependent kernel core dump headers.
 */
int
cpu_dump(void)
{
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
	char buf[dbtob(1)];
	kcore_seg_t *segp;
	cpu_kcore_hdr_t *cpuhdrp;
	phys_ram_seg_t *memsegp;
	caddr_t va;
	int i;

	dump = bdevsw[major(dumpdev)].d_dump;

	memset(buf, 0, sizeof buf);
	segp = (kcore_seg_t *)buf;
	cpuhdrp = (cpu_kcore_hdr_t *)&buf[ALIGN(sizeof(*segp))];
	memsegp = (phys_ram_seg_t *)&buf[ALIGN(sizeof(*segp)) +
	    ALIGN(sizeof(*cpuhdrp))];

	/*
	 * Generate a segment header.
	 */
	CORE_SETMAGIC(*segp, KCORE_MAGIC, MID_MACHINE, CORE_CPU);
	segp->c_size = dbtob(1) - ALIGN(sizeof(*segp));

	/*
	 * Add the machine-dependent header info.
	 */
	cpuhdrp->ptdpaddr = PTDpaddr;
	cpuhdrp->nmemsegs = mem_cluster_cnt;

	/*
	 * Fill in the memory segment descriptors.
	 */
	for (i = 0; i < mem_cluster_cnt; i++) {
		memsegp[i].start = mem_clusters[i].start;
		memsegp[i].size = mem_clusters[i].size & ~PAGE_MASK;
	}

	/*
	 * If we have dump memory then assume the kernel stack is in high
	 * memory and bounce
	 */
	if (dumpmem_vaddr != 0) {
		memcpy((char *)dumpmem_vaddr, buf, sizeof(buf));
		va = (caddr_t)dumpmem_vaddr;
	} else {
		va = (caddr_t)buf;
	}
	return (dump(dumpdev, dumplo, va, dbtob(1)));
}

/*
 * This is called by main to set dumplo and dumpsize.
 * Dumps always skip the first PAGE_SIZE of disk space
 * in case there might be a disk label stored there.
 * If there is extra space, put dump at the end to
 * reduce the chance that swapping trashes it.
 */
void
dumpconf(void)
{
	int nblks, dumpblks;	/* size of dump area */

	if (dumpdev == NODEV ||
	    (nblks = (bdevsw[major(dumpdev)].d_psize)(dumpdev)) == 0)
		return;
	if (nblks <= ctod(1))
		return;

	dumpblks = cpu_dumpsize();
	if (dumpblks < 0)
		return;
	dumpblks += ctod(cpu_dump_mempagecnt());

	/* If dump won't fit (incl. room for possible label), punt. */
	if (dumpblks > (nblks - ctod(1)))
		return;

	/* Put dump at end of partition */
	dumplo = nblks - dumpblks;

	/* dumpsize is in page units, and doesn't include headers. */
	dumpsize = cpu_dump_mempagecnt();
}

/*
 * Doadump comes here after turning off memory management and
 * getting on the dump stack, either when called above, or by
 * the auto-restart code.
 */
#define BYTES_PER_DUMP  MAXPHYS /* must be a multiple of pagesize */

void
dumpsys(void)
{
	u_long totalbytesleft, bytes, i, n, memseg;
	u_long maddr;
	daddr_t blkno;
	void *va;
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
	int error;

	/* Save registers. */
	savectx(&dumppcb);

	if (dumpdev == NODEV)
		return;

	/*
	 * For dumps during autoconfiguration,
	 * if dump device has already configured...
	 */
	if (dumpsize == 0)
		dumpconf();
	if (dumplo <= 0 || dumpsize == 0) {
		printf("\ndump to dev %u,%u not possible\n", major(dumpdev),
		    minor(dumpdev));
		return;
	}
	printf("\ndumping to dev %u,%u offset %ld\n", major(dumpdev),
	    minor(dumpdev), dumplo);

	error = (*bdevsw[major(dumpdev)].d_psize)(dumpdev);
	printf("dump ");
	if (error == -1) {
		printf("area unavailable\n");
		return;
	}

	if ((error = cpu_dump()) != 0)
		goto err;

	totalbytesleft = ptoa(cpu_dump_mempagecnt());
	blkno = dumplo + cpu_dumpsize();
	dump = bdevsw[major(dumpdev)].d_dump;
	error = 0;

	for (memseg = 0; memseg < mem_cluster_cnt; memseg++) {
		maddr = mem_clusters[memseg].start;
		bytes = mem_clusters[memseg].size;

		for (i = 0; i < bytes; i += n, totalbytesleft -= n) {
			/* Print out how many MBs we have left to go. */
			if ((totalbytesleft % (1024*1024)) < BYTES_PER_DUMP)
				printf("%ld ", totalbytesleft / (1024 * 1024));

			/* Limit size for next transfer. */
			n = bytes - i;
			if (n > BYTES_PER_DUMP)
				n = BYTES_PER_DUMP;
			if (maddr > 0xffffffff) {
				va = (void *)dumpmem_vaddr;
				if (n > dumpmem_sz)
					n = dumpmem_sz;
				memcpy(va, (void *)PMAP_DIRECT_MAP(maddr), n);
			} else {
				va = (void *)PMAP_DIRECT_MAP(maddr);
			}

			error = (*dump)(dumpdev, blkno, va, n);
			if (error)
				goto err;
			maddr += n;
			blkno += btodb(n);		/* XXX? */

#if 0	/* XXX this doesn't work.  grr. */
			/* operator aborting dump? */
			if (sget() != NULL) {
				error = EINTR;
				break;
			}
#endif
		}
	}

 err:
	switch (error) {

	case ENXIO:
		printf("device bad\n");
		break;

	case EFAULT:
		printf("device not ready\n");
		break;

	case EINVAL:
		printf("area improper\n");
		break;

	case EIO:
		printf("i/o error\n");
		break;

	case EINTR:
		printf("aborted from console\n");
		break;

	case 0:
		printf("succeeded\n");
		break;

	default:
		printf("error %d\n", error);
		break;
	}
	printf("\n\n");
	delay(5000000);		/* 5 seconds */
}

/*
 * Force the userspace FS.base to be reloaded from the PCB on return from
 * the kernel, and reset most the segment registers (%ds, %es, and %fs)
 * to their expected userspace value.
 */
void
reset_segs(void)
{
	/*
	 * Segment registers (%ds, %es, %fs, %gs) aren't in the trapframe.
	 * %gs is reset on return to userspace to avoid having to deal with
	 * swapgs; others are reset on context switch and here.  This
	 * operates like the cpu_switchto() sequence: if we haven't reset
	 * %[def]s already, do so now.
	 */
	if (curcpu()->ci_flags & CPUF_USERSEGS) {
		curcpu()->ci_flags &= ~CPUF_USERSEGS;
		__asm volatile(
		    "movw %%ax,%%ds\n\t"
		    "movw %%ax,%%es\n\t"
		    "movw %%ax,%%fs" : : "a"(GSEL(GUDATA_SEL, SEL_UPL)));
	}
}

/*
 * Clear registers on exec
 */
void
setregs(struct proc *p, struct exec_package *pack, u_long stack,
    register_t *retval)
{
	struct trapframe *tf;

	/* If we were using the FPU, forget about it. */
	if (p->p_addr->u_pcb.pcb_fpcpu != NULL)
		fpusave_proc(p, 0);
	p->p_md.md_flags &= ~MDP_USEDFPU;
	p->p_md.md_flags |= MDP_IRET;

	reset_segs();
	p->p_addr->u_pcb.pcb_fsbase = 0;

	tf = p->p_md.md_regs;
	tf->tf_rdi = 0;
	tf->tf_rsi = 0;
	tf->tf_rbp = 0;
	tf->tf_rbx = 0;
	tf->tf_rdx = 0;
	tf->tf_rcx = 0;
	tf->tf_rax = 0;
	tf->tf_r8 = 0;
	tf->tf_r9 = 0;
	tf->tf_r10 = 0;
	tf->tf_r11 = 0;
	tf->tf_r12 = 0;
	tf->tf_r13 = 0;
	tf->tf_r14 = 0;
	tf->tf_r15 = 0;
	tf->tf_rip = pack->ep_entry;
	tf->tf_cs = GSEL(GUCODE_SEL, SEL_UPL);
	tf->tf_rflags = PSL_USERSET;
	tf->tf_rsp = stack;
	tf->tf_ss = GSEL(GUDATA_SEL, SEL_UPL);

	retval[1] = 0;
}

/*
 * Initialize segments and descriptor tables
 */

struct gate_descriptor *idt;
char idt_allocmap[NIDT];
extern  struct user *proc0paddr;

void
setgate(struct gate_descriptor *gd, void *func, int ist, int type, int dpl,
    int sel)
{
	gd->gd_looffset = (u_int64_t)func & 0xffff;
	gd->gd_selector = sel;
	gd->gd_ist = ist;
	gd->gd_type = type;
	gd->gd_dpl = dpl;
	gd->gd_p = 1;
	gd->gd_hioffset = (u_int64_t)func >> 16;
	gd->gd_zero = 0;
	gd->gd_xx1 = 0;
	gd->gd_xx2 = 0;
	gd->gd_xx3 = 0;
}

void
unsetgate(struct gate_descriptor *gd)
{
	memset(gd, 0, sizeof (*gd));
}

void
setregion(struct region_descriptor *rd, void *base, u_int16_t limit)
{
	rd->rd_limit = limit;
	rd->rd_base = (u_int64_t)base;
}

/*
 * Note that the base and limit fields are ignored in long mode.
 */
void
set_mem_segment(struct mem_segment_descriptor *sd, void *base, size_t limit,
    int type, int dpl, int gran, int def32, int is64)
{
	sd->sd_lolimit = (unsigned)limit;
	sd->sd_lobase = (unsigned long)base;
	sd->sd_type = type;
	sd->sd_dpl = dpl;
	sd->sd_p = 1;
	sd->sd_hilimit = (unsigned)limit >> 16;
	sd->sd_avl = 0;
	sd->sd_long = is64;
	sd->sd_def32 = def32;
	sd->sd_gran = gran;
	sd->sd_hibase = (unsigned long)base >> 24;
}

void
set_sys_segment(struct sys_segment_descriptor *sd, void *base, size_t limit,
    int type, int dpl, int gran)
{
	memset(sd, 0, sizeof *sd);
	sd->sd_lolimit = (unsigned)limit;
	sd->sd_lobase = (u_int64_t)base;
	sd->sd_type = type;
	sd->sd_dpl = dpl;
	sd->sd_p = 1;
	sd->sd_hilimit = (unsigned)limit >> 16;
	sd->sd_gran = gran;
	sd->sd_hibase = (u_int64_t)base >> 24;
}

void cpu_init_idt(void)
{
	struct region_descriptor region;

	setregion(&region, idt, NIDT * sizeof(idt[0]) - 1);
	lidt(&region); 
}

void
cpu_init_extents(void)
{
	extern struct extent *iomem_ex;
	static int already_done;
	int i;

	/* We get called for each CPU, only first should do this */
	if (already_done)
		return;

	/*
	 * Allocate the physical addresses used by RAM from the iomem
	 * extent map.
	 */
	for (i = 0; i < mem_cluster_cnt; i++) {
		if (extent_alloc_region(iomem_ex, mem_clusters[i].start,
		    mem_clusters[i].size, EX_NOWAIT)) {
			/* XXX What should we do? */
			printf("WARNING: CAN'T ALLOCATE RAM (%llx-%llx)"
			    " FROM IOMEM EXTENT MAP!\n", mem_clusters[i].start,
			    mem_clusters[i].start + mem_clusters[i].size - 1);
		}
	}

	already_done = 1;
}

#if defined(MULTIPROCESSOR) || \
    (NACPI > 0 && !defined(SMALL_KERNEL))
void
map_tramps(void)
{
	struct pmap *kmp = pmap_kernel();
	extern paddr_t tramp_pdirpa;
#ifdef MULTIPROCESSOR
	extern u_char cpu_spinup_trampoline[];
	extern u_char cpu_spinup_trampoline_end[];
	extern u_char mp_tramp_data_start[];
	extern u_char mp_tramp_data_end[];
	extern u_int32_t mp_pdirpa;
#endif

	pmap_kenter_pa(lo32_vaddr, lo32_paddr, PROT_READ | PROT_WRITE);

	/*
	 * The initial PML4 pointer must be below 4G, so if the
	 * current one isn't, use a "bounce buffer" and save it
	 * for tramps to use.
	 */
	if (kmp->pm_pdirpa > 0xffffffff) {
		memcpy((void *)lo32_vaddr, kmp->pm_pdir, PAGE_SIZE);
		tramp_pdirpa = lo32_paddr;
	} else
		tramp_pdirpa = kmp->pm_pdirpa;

	pmap_kremove(lo32_vaddr, PAGE_SIZE);

#ifdef MULTIPROCESSOR
	/* Map MP tramp code and data pages RW for copy */
	pmap_kenter_pa(MP_TRAMPOLINE, MP_TRAMPOLINE,
	    PROT_READ | PROT_WRITE);

	pmap_kenter_pa(MP_TRAMP_DATA, MP_TRAMP_DATA,
	    PROT_READ | PROT_WRITE);

	memset((caddr_t)MP_TRAMPOLINE, 0xcc, PAGE_SIZE);
	memset((caddr_t)MP_TRAMP_DATA, 0xcc, PAGE_SIZE);

	memcpy((caddr_t)MP_TRAMPOLINE,
	    cpu_spinup_trampoline,
	    cpu_spinup_trampoline_end-cpu_spinup_trampoline);

	memcpy((caddr_t)MP_TRAMP_DATA,
		mp_tramp_data_start,
		mp_tramp_data_end - mp_tramp_data_start);

	/*
	 * We need to patch this after we copy the tramp data,
	 * the symbol points into the copied tramp data page.
	 */
	mp_pdirpa = tramp_pdirpa;

	/* Unmap, will be remapped in cpu_start_secondary */
	pmap_kremove(MP_TRAMPOLINE, PAGE_SIZE);
	pmap_kremove(MP_TRAMP_DATA, PAGE_SIZE);
#endif /* MULTIPROCESSOR */
}
#endif

#define	IDTVEC(name)	__CONCAT(X, name)
typedef void (vector)(void);
extern vector *IDTVEC(exceptions)[];

void
init_x86_64(paddr_t first_avail)
{
	struct region_descriptor region;
	bios_memmap_t *bmp;
	int x, ist;

	cpu_init_msrs(&cpu_info_primary);

	proc0.p_addr = proc0paddr;
	cpu_info_primary.ci_curpcb = &proc0.p_addr->u_pcb;

	x86_bus_space_init();

	/*
	 * Attach the glass console early in case we need to display a panic.
	 */
	cninit();

	/*
	 * Initialize PAGE_SIZE-dependent variables.
	 */
	uvm_setpagesize();

	/*
	 * Boot arguments are in a single page specified by /boot.
	 *
	 * We require the "new" vector form, as well as memory ranges
	 * to be given in bytes rather than KB.
	 *
	 * locore copies the data into bootinfo[] for us.
	 */
	if ((bootapiver & (BAPIV_VECTOR | BAPIV_BMEMMAP)) ==
	    (BAPIV_VECTOR | BAPIV_BMEMMAP)) {
		if (bootinfo_size >= sizeof(bootinfo))
			panic("boot args too big");

		getbootinfo(bootinfo, bootinfo_size);
	} else
		panic("invalid /boot");

/*
 * Memory on the AMD64 port is described by three different things.
 *
 * 1. biosbasemem, biosextmem - These are outdated, and should really
 *    only be used to santize the other values.  They are the things
 *    we get back from the BIOS using the legacy routines, usually
 *    only describing the lower 4GB of memory.
 *
 * 2. bios_memmap[] - This is the memory map as the bios has returned
 *    it to us.  It includes memory the kernel occupies, etc.
 *
 * 3. mem_cluster[] - This is the massaged free memory segments after
 *    taking into account the contents of bios_memmap, biosbasemem,
 *    biosextmem, and locore/machdep/pmap kernel allocations of physical
 *    pages.
 *
 * The other thing is that the physical page *RANGE* is described by
 * three more variables:
 *
 * avail_start - This is a physical address of the start of available
 *               pages, until IOM_BEGIN.  This is basically the start
 *               of the UVM managed range of memory, with some holes...
 *
 * avail_end - This is the end of physical pages.  All physical pages
 *             that UVM manages are between avail_start and avail_end.
 *             There are holes...
 *
 * first_avail - This is the first available physical page after the
 *               kernel, page tables, etc.
 *
 * We skip the first few pages for trampolines, hibernate, and to avoid
 * buggy SMI implementations that could corrupt the first 64KB.
 */
	avail_start = 16*PAGE_SIZE;

#ifdef MULTIPROCESSOR
	if (avail_start < MP_TRAMPOLINE + PAGE_SIZE)
		avail_start = MP_TRAMPOLINE + PAGE_SIZE;
	if (avail_start < MP_TRAMP_DATA + PAGE_SIZE)
		avail_start = MP_TRAMP_DATA + PAGE_SIZE;
#endif

#if (NACPI > 0 && !defined(SMALL_KERNEL))
	if (avail_start < ACPI_TRAMPOLINE + PAGE_SIZE)
		avail_start = ACPI_TRAMPOLINE + PAGE_SIZE;
	if (avail_start < ACPI_TRAMP_DATA + PAGE_SIZE)
		avail_start = ACPI_TRAMP_DATA + PAGE_SIZE;
#endif

#ifdef HIBERNATE
	if (avail_start < HIBERNATE_HIBALLOC_PAGE + PAGE_SIZE)
		avail_start = HIBERNATE_HIBALLOC_PAGE + PAGE_SIZE;
#endif /* HIBERNATE */

	/*
	 * We need to go through the BIOS memory map given, and
	 * fill out mem_clusters and mem_cluster_cnt stuff, taking
	 * into account all the points listed above.
	 */ 
	avail_end = mem_cluster_cnt = 0;
	for (bmp = bios_memmap; bmp->type != BIOS_MAP_END; bmp++) {
		paddr_t s1, s2, e1, e2;

		/* Ignore non-free memory */
		if (bmp->type != BIOS_MAP_FREE)
			continue;
		if (bmp->size < PAGE_SIZE)
			continue;

		/* Init our segment(s), round/trunc to pages */
		s1 = round_page(bmp->addr);
		e1 = trunc_page(bmp->addr + bmp->size);
		s2 = e2 = 0;

		/*
		 * XXX Some buggy ACPI BIOSes use memory that they
		 * declare as free.  Typically the affected memory
		 * areas are small blocks between areas reserved for
		 * ACPI and other BIOS goo.  So skip areas smaller
		 * than 1 MB above the 16 MB boundary (to avoid
		 * affecting legacy stuff).
		 */
		if (s1 > 16*1024*1024 && (e1 - s1) < 1*1024*1024)
			continue;

		/* Check and adjust our segment(s) */
		/* Nuke low pages */
		if (s1 < avail_start) {
			s1 = avail_start;
			if (s1 > e1)
				continue;
		}

		/* Crop stuff into "640K hole" */
		if (s1 < IOM_BEGIN && e1 > IOM_BEGIN)
			e1 = IOM_BEGIN;
		if (s1 < biosbasemem && e1 > biosbasemem)
			e1 = biosbasemem;

		/* Split any segments straddling the 16MB boundary */
		if (s1 < 16*1024*1024 && e1 > 16*1024*1024) {
			e2 = e1;
			s2 = e1 = 16*1024*1024;
		}

		/* Store segment(s) */
		if (e1 - s1 >= PAGE_SIZE) {
			mem_clusters[mem_cluster_cnt].start = s1;
			mem_clusters[mem_cluster_cnt].size = e1 - s1;
			mem_cluster_cnt++;
		}
		if (e2 - s2 >= PAGE_SIZE) {
			mem_clusters[mem_cluster_cnt].start = s2;
			mem_clusters[mem_cluster_cnt].size = e2 - s2;
			mem_cluster_cnt++;
		}
		if (avail_end < e1) avail_end = e1;
		if (avail_end < e2) avail_end = e2;
	}

	/*
	 * Call pmap initialization to make new kernel address space.
	 * We must do this before loading pages into the VM system.
	 */
	first_avail = pmap_bootstrap(first_avail, trunc_page(avail_end));

	/* Allocate these out of the 640KB base memory */
	if (avail_start != PAGE_SIZE)
		avail_start = pmap_prealloc_lowmem_ptps(avail_start);

	cpu_init_extents();

	/* Make sure the end of the space used by the kernel is rounded. */
	first_avail = round_page(first_avail);
	kern_end = KERNBASE + first_avail;

	/*
	 * Now, load the memory clusters (which have already been
	 * flensed) into the VM system.
	 */
	for (x = 0; x < mem_cluster_cnt; x++) {
		paddr_t seg_start = mem_clusters[x].start;
		paddr_t seg_end = seg_start + mem_clusters[x].size;

		if (seg_start < first_avail) seg_start = first_avail;
		if (seg_start > seg_end) continue;
		if (seg_end - seg_start < PAGE_SIZE) continue;

		physmem += atop(mem_clusters[x].size);

#if DEBUG_MEMLOAD
		printf("loading 0x%lx-0x%lx (0x%lx-0x%lx)\n",
		    seg_start, seg_end, atop(seg_start), atop(seg_end));
#endif
		uvm_page_physload(atop(seg_start), atop(seg_end),
		    atop(seg_start), atop(seg_end), 0);
	}

	/*
         * Now, load the memory between the end of I/O memory "hole"
         * and the kernel.
	 */
	{
		paddr_t seg_start = round_page(IOM_END);
		paddr_t seg_end = trunc_page(KERNTEXTOFF - KERNBASE);

		if (seg_start < seg_end) {
#if DEBUG_MEMLOAD
			printf("loading 0x%lx-0x%lx\n", seg_start, seg_end);
#endif
			uvm_page_physload(atop(seg_start), atop(seg_end),
			    atop(seg_start), atop(seg_end), 0);
		}
	}

#if DEBUG_MEMLOAD
	printf("avail_start = 0x%lx\n", avail_start);
	printf("avail_end = 0x%lx\n", avail_end);
	printf("first_avail = 0x%lx\n", first_avail);
#endif

	/*
	 * Steal memory for the message buffer (at end of core).
	 */
	{
		struct vm_physseg *vps = NULL;
		psize_t sz = round_page(MSGBUFSIZE);
		psize_t reqsz = sz;

		for (x = 0; x < vm_nphysseg; x++) {
			vps = &vm_physmem[x];
			if (ptoa(vps->avail_end) == avail_end)
				break;
		}
		if (x == vm_nphysseg)
			panic("init_x86_64: can't find end of memory");

		/* Shrink so it'll fit in the last segment. */
		if ((vps->avail_end - vps->avail_start) < atop(sz))
			sz = ptoa(vps->avail_end - vps->avail_start);

		vps->avail_end -= atop(sz);
		vps->end -= atop(sz);
		msgbuf_paddr = ptoa(vps->avail_end);

		/* Remove the last segment if it now has no pages. */
		if (vps->start == vps->end) {
			for (vm_nphysseg--; x < vm_nphysseg; x++)
				vm_physmem[x] = vm_physmem[x + 1];
		}

		/* Now find where the new avail_end is. */
		for (avail_end = 0, x = 0; x < vm_nphysseg; x++)
			if (vm_physmem[x].avail_end > avail_end)
				avail_end = vm_physmem[x].avail_end;
		avail_end = ptoa(avail_end);

		/* Warn if the message buffer had to be shrunk. */
		if (sz != reqsz)
			printf("WARNING: %ld bytes not available for msgbuf "
			    "in last cluster (%ld used)\n", reqsz, sz);
	}

	/*
	 * Steal some memory for a dump bouncebuffer if we have memory over
	 * the 32-bit barrier.
	 */
	if (avail_end > 0xffffffff) {
		struct vm_physseg *vps = NULL;
		psize_t sz = round_page(MAX(BYTES_PER_DUMP, dbtob(1)));

		/* XXX assumes segments are ordered */
		for (x = 0; x < vm_nphysseg; x++) {
			vps = &vm_physmem[x];
			/* Find something between 16meg and 4gig */
			if (ptoa(vps->avail_end) <= 0xffffffff &&
			    ptoa(vps->avail_start) >= 0xffffff)
				break;
		}
		if (x == vm_nphysseg)
			panic("init_x86_64: no memory between "
			    "0xffffff-0xffffffff");

		/* Shrink so it'll fit in the segment. */
		if ((vps->avail_end - vps->avail_start) < atop(sz))
			sz = ptoa(vps->avail_end - vps->avail_start);

		vps->avail_end -= atop(sz);
		vps->end -= atop(sz);
		dumpmem_paddr = ptoa(vps->avail_end);
		dumpmem_vaddr = PMAP_DIRECT_MAP(dumpmem_paddr);
		dumpmem_sz = sz;

		/* Remove the last segment if it now has no pages. */
		if (vps->start == vps->end) {
			for (vm_nphysseg--; x < vm_nphysseg; x++)
				vm_physmem[x] = vm_physmem[x + 1];
		}
	}

	pmap_growkernel(VM_MIN_KERNEL_ADDRESS + 32 * 1024 * 1024);

	pmap_kenter_pa(idt_vaddr, idt_paddr, PROT_READ | PROT_WRITE);
	pmap_kenter_pa(idt_vaddr + PAGE_SIZE, idt_paddr + PAGE_SIZE,
	    PROT_READ | PROT_WRITE);

#if defined(MULTIPROCESSOR) || \
    (NACPI > 0 && !defined(SMALL_KERNEL))
	map_tramps();
#endif

	idt = (struct gate_descriptor *)idt_vaddr;
	cpu_info_primary.ci_tss = (void *)(idt + NIDT);
	cpu_info_primary.ci_gdt = (void *)(cpu_info_primary.ci_tss + 1);

	/* make gdt gates and memory segments */
	set_mem_segment(GDT_ADDR_MEM(cpu_info_primary.ci_gdt, GCODE_SEL), 0,
	    0xfffff, SDT_MEMERA, SEL_KPL, 1, 0, 1);

	set_mem_segment(GDT_ADDR_MEM(cpu_info_primary.ci_gdt, GDATA_SEL), 0,
	    0xfffff, SDT_MEMRWA, SEL_KPL, 1, 0, 1);

	set_mem_segment(GDT_ADDR_MEM(cpu_info_primary.ci_gdt, GUCODE32_SEL), 0,
	    atop(VM_MAXUSER_ADDRESS32) - 1, SDT_MEMERA, SEL_UPL, 1, 1, 0);

	set_mem_segment(GDT_ADDR_MEM(cpu_info_primary.ci_gdt, GUDATA_SEL), 0,
	    atop(VM_MAXUSER_ADDRESS) - 1, SDT_MEMRWA, SEL_UPL, 1, 0, 1);

	set_mem_segment(GDT_ADDR_MEM(cpu_info_primary.ci_gdt, GUCODE_SEL), 0,
	    atop(VM_MAXUSER_ADDRESS) - 1, SDT_MEMERA, SEL_UPL, 1, 0, 1);

	set_sys_segment(GDT_ADDR_SYS(cpu_info_primary.ci_gdt, GPROC0_SEL),
	    cpu_info_primary.ci_tss, sizeof (struct x86_64_tss)-1,
	    SDT_SYS386TSS, SEL_KPL, 0);

	/* exceptions */
	for (x = 0; x < 32; x++) {
		ist = (x == 8) ? 1 : 0;
		setgate(&idt[x], IDTVEC(exceptions)[x], ist, SDT_SYS386IGT,
		    (x == 3 || x == 4) ? SEL_UPL : SEL_KPL,
		    GSEL(GCODE_SEL, SEL_KPL));
		idt_allocmap[x] = 1;
	}

	setregion(&region, cpu_info_primary.ci_gdt, GDT_SIZE - 1);
	lgdt(&region);

	cpu_init_idt();

	intr_default_setup();
	fpuinit(&cpu_info_primary);

	softintr_init();
	splraise(IPL_IPI);
	enable_intr();

#ifdef DDB
	db_machine_init();
	ddb_init();
	if (boothowto & RB_KDB)
		db_enter();
#endif
}

void
cpu_reset(void)
{

	disable_intr();

	if (cpuresetfn)
		(*cpuresetfn)();

	/*
	 * The keyboard controller has 4 random output pins, one of which is
	 * connected to the RESET pin on the CPU in many PCs.  We tell the
	 * keyboard controller to pulse this line a couple of times.
	 */
	outb(IO_KBD + KBCMDP, KBC_PULSE0);
	delay(100000);
	outb(IO_KBD + KBCMDP, KBC_PULSE0);
	delay(100000);

	/*
	 * Try to cause a triple fault and watchdog reset by making the IDT
	 * invalid and causing a fault.
	 */
	memset((caddr_t)idt, 0, NIDT * sizeof(idt[0]));
	__asm volatile("divl %0,%1" : : "q" (0), "a" (0)); 

	for (;;)
		continue;
	/* NOTREACHED */
}

/*
 * cpu_dumpsize: calculate size of machine-dependent kernel core dump headers.
 */
int
cpu_dumpsize(void)
{
	int size;

	size = ALIGN(sizeof(kcore_seg_t)) +
	    ALIGN(mem_cluster_cnt * sizeof(phys_ram_seg_t));
	if (roundup(size, dbtob(1)) != dbtob(1))
		return (-1);

	return (1);
}

/*
 * cpu_dump_mempagecnt: calculate the size of RAM (in pages) to be dumped.
 */
u_long
cpu_dump_mempagecnt(void)
{
	u_long i, n;

	n = 0;
	for (i = 0; i < mem_cluster_cnt; i++)
		n += atop(mem_clusters[i].size);
	return (n);
}

/*
 * Figure out which portions of memory are used by the kernel/system.
 */
int
amd64_pa_used(paddr_t addr)
{
	struct vm_page	*pg;

	/* Kernel manages these */
	if ((pg = PHYS_TO_VM_PAGE(addr)) && (pg->pg_flags & PG_DEV) == 0)
		return 1;

	/* Kernel is loaded here */
	if (addr > IOM_END && addr < (kern_end - KERNBASE))
		return 1;

	/* Low memory used for various bootstrap things */
	if (addr < avail_start)
		return 1;

	/*
	 * The only regions I can think of that are left are the things
	 * we steal away from UVM.  The message buffer?
	 * XXX - ignore these for now.
	 */

	return 0;
}

void
cpu_initclocks(void)
{
	(*initclock_func)();
}

void
need_resched(struct cpu_info *ci)
{
	ci->ci_want_resched = 1;

	/* There's a risk we'll be called before the idle threads start */
	if (ci->ci_curproc) {
		aston(ci->ci_curproc);
		cpu_kick(ci);
	}
}

/*
 * Allocate an IDT vector slot within the given range.
 * XXX needs locking to avoid MP allocation races.
 */

int
idt_vec_alloc(int low, int high)
{
	int vec;

	for (vec = low; vec <= high; vec++) {
		if (idt_allocmap[vec] == 0) {
			idt_allocmap[vec] = 1;
			return vec;
		}
	}
	return 0;
}

void
idt_vec_set(int vec, void (*function)(void))
{
	/*
	 * Vector should be allocated, so no locking needed.
	 */
	KASSERT(idt_allocmap[vec] == 1);
	setgate(&idt[vec], function, 0, SDT_SYS386IGT, SEL_KPL,
	    GSEL(GCODE_SEL, SEL_KPL));
}

void
idt_vec_free(int vec)
{
	unsetgate(&idt[vec]);
	idt_allocmap[vec] = 0;
}

#ifdef DIAGNOSTIC
void
splassert_check(int wantipl, const char *func)
{
	int cpl = curcpu()->ci_ilevel;
	int floor = curcpu()->ci_handled_intr_level;

	if (cpl < wantipl) {
		splassert_fail(wantipl, cpl, func);
	}
	if (floor > wantipl) {
		splassert_fail(wantipl, floor, func);
	}
	
}
#endif

int
copyin32(const uint32_t *uaddr, uint32_t *kaddr)
{
	if ((vaddr_t)uaddr & 0x3)
		return EFAULT;

	/* copyin(9) is atomic */
	return copyin(uaddr, kaddr, sizeof(uint32_t));
}

void
getbootinfo(char *bootinfo, int bootinfo_size)
{
	bootarg32_t *q;
	bios_ddb_t *bios_ddb;
	bios_bootduid_t *bios_bootduid;
	bios_bootsr_t *bios_bootsr;
	int docninit = 0;

#undef BOOTINFO_DEBUG
#ifdef BOOTINFO_DEBUG
	printf("bootargv:");
#endif

	for (q = (bootarg32_t *)bootinfo;
	    (q->ba_type != BOOTARG_END) &&
	    ((((char *)q) - bootinfo) < bootinfo_size);
	    q = (bootarg32_t *)(((char *)q) + q->ba_size)) {

		switch (q->ba_type) {
		case BOOTARG_MEMMAP:
			bios_memmap = (bios_memmap_t *)q->ba_arg;
#ifdef BOOTINFO_DEBUG
			printf(" memmap %p", bios_memmap);
#endif
			break;
		case BOOTARG_DISKINFO:
			bios_diskinfo = (bios_diskinfo_t *)q->ba_arg;
#ifdef BOOTINFO_DEBUG
			printf(" diskinfo %p", bios_diskinfo);
#endif
			break;
		case BOOTARG_APMINFO:
			/* generated by i386 boot loader */
			break;
		case BOOTARG_CKSUMLEN:
			bios_cksumlen = *(u_int32_t *)q->ba_arg;
#ifdef BOOTINFO_DEBUG
			printf(" cksumlen %d", bios_cksumlen);
#endif
			break;
		case BOOTARG_PCIINFO:
			/* generated by i386 boot loader */
			break;
		case BOOTARG_CONSDEV:
			if (q->ba_size >= sizeof(bios_consdev_t) +
			    offsetof(struct _boot_args32, ba_arg)) {
				bios_consdev_t *cdp =
				    (bios_consdev_t*)q->ba_arg;
#if NCOM > 0
				static const int ports[] =
				    { 0x3f8, 0x2f8, 0x3e8, 0x2e8 };
				int unit = minor(cdp->consdev);
				int consaddr = cdp->consaddr;
				if (consaddr == -1 && unit >= 0 &&
				    unit < nitems(ports))
					consaddr = ports[unit];
				if (major(cdp->consdev) == 8 &&
				    consaddr != -1) {
					comconsunit = unit;
					comconsaddr = consaddr;
					comconsrate = cdp->conspeed;
					comconsiot = X86_BUS_SPACE_IO;

					/* Probe the serial port this time. */
					docninit++;
				}
#endif
#ifdef BOOTINFO_DEBUG
				printf(" console 0x%x:%d",
				    cdp->consdev, cdp->conspeed);
#endif
			}
			break;
		case BOOTARG_BOOTMAC:
			bios_bootmac = (bios_bootmac_t *)q->ba_arg;
			break;

		case BOOTARG_DDB:
			bios_ddb = (bios_ddb_t *)q->ba_arg;
#ifdef DDB
			db_console = bios_ddb->db_console;
#endif
			break;

		case BOOTARG_BOOTDUID:
			bios_bootduid = (bios_bootduid_t *)q->ba_arg;
			memcpy(bootduid, bios_bootduid, sizeof(bootduid));
			break;

		case BOOTARG_BOOTSR:
			bios_bootsr = (bios_bootsr_t *)q->ba_arg;
#if NSOFTRAID > 0
			memcpy(&sr_bootuuid, &bios_bootsr->uuid,
			    sizeof(sr_bootuuid));
			memcpy(&sr_bootkey, &bios_bootsr->maskkey,
			    sizeof(sr_bootkey));
#endif
			explicit_bzero(bios_bootsr, sizeof(bios_bootsr_t));
			break;

		case BOOTARG_EFIINFO:
			bios_efiinfo = (bios_efiinfo_t *)q->ba_arg;
			if (bios_efiinfo->fb_addr != 0)
				docninit++;
			break;

		default:
#ifdef BOOTINFO_DEBUG
			printf(" unsupported arg (%d) %p", q->ba_type,
			    q->ba_arg);
#endif
			break;
		}
	}
	if (docninit > 0)
		cninit();
#ifdef BOOTINFO_DEBUG
	printf("\n");
#endif
}

int
check_context(const struct reg *regs, struct trapframe *tf)
{
	uint16_t sel;

	if (((regs->r_rflags ^ tf->tf_rflags) & PSL_USERSTATIC) != 0)
		return EINVAL;

	sel = regs->r_ss & 0xffff;
	if (!VALID_USER_DSEL(sel)) 
		return EINVAL;

	sel = regs->r_cs & 0xffff;
	if (!VALID_USER_CSEL(sel))
		return EINVAL;

	if (regs->r_rip >= VM_MAXUSER_ADDRESS)
		return EINVAL;

	return 0;
}
@


1.230
log
@Remove a block of "#if 0" code that has been in the file since r1.1, 13
years ago. This was part of the original reset code port from i386, and
we've never been able to reset amd64 in the way the code tries to do in
the #if 0 block since we don't have a 'PTD' variable in amd64.

I thought to keep this around for diffability with i386, but that's pretty
pointless now as the diff between the two machdep.c files is over 5000
lines already...
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.229 2017/05/18 09:20:06 kettenis Exp $	*/
a478 1
	case CPU_LIDSUSPEND:
@


1.229
log
@Since copyin(9) already doeas access 32-bit quantities atomically, we can
add copyin32(9) as a simple C wrapper around it.  These wrappers do check
alignment and return EFAULT if the userland pointer is misaligned.  This is
enough to guarantee that the access doesn't cross a cache line boundary which
could make the access non-atomic.

ok mpi@@, visa@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.228 2017/04/30 16:45:45 mpi Exp $	*/
a1633 9

#if 0
	/*
	 * Try to cause a triple fault and watchdog reset by unmapping the
	 * entire address space and doing a TLB flush.
	 */
	memset((caddr_t)PTD, 0, PAGE_SIZE);
	tlbflush(); 
#endif
@


1.228
log
@Rename Debugger() into db_enter().

Using a name with the 'db_' prefix makes it invisible from the dynamic
profiler.

ok deraadt@@, kettenis@@, visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.227 2017/04/30 13:04:49 mpi Exp $	*/
d1779 10
@


1.227
log
@Unifdef KGDB.

It doesn't compile und hasn't been working during the last decade.

ok kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.226 2017/03/11 11:55:03 mpi Exp $	*/
d1605 1
a1605 1
		Debugger();
@


1.226
log
@Introduce a new knob to force the first USB keyboard as console input.

By setting "machdep.forceukbd=1" you can now use your USB keyboard in
ddb(4) even if your BIOS emulates a pckbd(4).

ok tom@@, kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.225 2017/03/07 11:49:42 natano Exp $	*/
a89 4
#ifdef KGDB
#include <sys/kgdb.h>
#endif

a266 22
#ifdef KGDB
#ifndef KGDB_DEVNAME
#define KGDB_DEVNAME	"com"
#endif /* KGDB_DEVNAME */
char kgdb_devname[] = KGDB_DEVNAME;
#if NCOM > 0
#ifndef KGDBADDR
#define KGDBADDR	0x3f8
#endif /* KGDBADDR */
int comkgdbaddr = KGDBADDR;
#ifndef KGDBRATE
#define KGDBRATE	TTYDEF_SPEED
#endif /* KGDBRATE */
int comkgdbrate = KGDBRATE;
#ifndef KGDBMODE
#define KGDBMODE	((TTYDEF_CFLAG & ~(CSIZE | CSTOPB | PARENB)) | CS8)
#endif /* KGDBMODE */
int comkgdbmode = KGDBMODE;
#endif /* NCOM */
void	kgdb_port_init(void);
#endif /* KGDB */

a1606 7
#ifdef KGDB
	kgdb_port_init();
	if (boothowto & RB_KDB) {
		kgdb_debug_init = 1;
		kgdb_connect(1);
	}
#endif
a1607 14

#ifdef KGDB
void
kgdb_port_init(void)
{
#if NCOM > 0
	if (!strcmp(kgdb_devname, "com")) {
		bus_space_tag_t tag = X86_BUS_SPACE_IO;
		com_kgdb_attach(tag, comkgdbaddr, comkgdbrate, COM_FREQ,
		    comkgdbmode);
	}
#endif
} 
#endif /* KGDB */
@


1.225
log
@Disallow setting machdep.lidaction to any other value but [0,2].

suggested by halex
ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.224 2017/03/02 10:38:09 natano Exp $	*/
d149 6
d198 1
d516 10
@


1.224
log
@Add a new sysctl machdep.lidaction. The sysctl works as follows:

machdep.lidaction=0	# do nothing
machdep.lidaction=1	# suspend
machdep.lidaction=2	# hibernate

lidsuspend is just an alias for lidaction, so if you change one, the
other one will have the same value. The plan is to remove
machdep.lidsuspend eventually when people have upgraded their
/ets/sysctl.conf.

discussed with deraadt, who came up with the new MIB name
no objections mlarkin
ok stsp halex jcs
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.223 2016/10/09 11:25:39 tom Exp $	*/
d450 1
d500 9
a508 1
		return (sysctl_int(oldp, oldlenp, newp, newlen, &lid_action));
@


1.223
log
@Apply consistency to forever loops with continue and NOTREACHED

Same thought from kettenis@@, ok krw@@ phessler@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.222 2016/09/18 14:28:24 deraadt Exp $	*/
d191 1
a191 1
int lid_suspend = 1;
d498 2
a499 1
		return (sysctl_int(oldp, oldlenp, newp, newlen, &lid_suspend));
d719 1
a719 1
		lid_suspend = 0;
@


1.222
log
@option INSECURE is obsolete
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.221 2016/05/21 00:56:43 deraadt Exp $	*/
d775 2
a776 1
	for (;;) ;
d1664 3
a1666 1
	for (;;);
@


1.221
log
@hand-massage sendsig() and sys_sigreturn() to be much more similar.
ok guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.220 2016/05/16 01:48:28 mlarkin Exp $	*/
a286 3
#ifdef INSECURE
int allowaperture = 1;
#else
a287 1
#endif
@


1.220
log
@
Pad end of code in the MP trampoline with int3 instead of 0x0 as it is
certain we don't want an intentional sled here either.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.219 2016/05/10 18:39:42 deraadt Exp $	*/
a530 6
#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) && (!sigpid || p->p_pid == sigpid))
		printf("sendsig: %s[%d] sig %d catcher %p\n",
		    p->p_comm, p->p_pid, sig, catcher);
#endif

a584 6

#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) && (!sigpid || p->p_pid == sigpid))
		printf("sendsig(%d): pc 0x%llx, catcher 0x%llx\n", p->p_pid,
		    tf->tf_rip, tf->tf_rax);
#endif
d603 1
a603 1
	struct sigcontext *scp = SCARG(uap, sigcntxp), ksc;
a607 2
		printf("%s(%d): sigreturn not from tramp [pc 0x%llx %lx]\n",
		    p->p_comm, p->p_pid, PROC_PC(p), p->p_p->ps_sigcoderet);
a615 3
		printf("%s(%d): cookie %lx should have been %lx\n",
		    p->p_comm, p->p_pid, ksc.sc_cookie,
		    (long)scp ^ p->p_p->ps_sigcookie);
d623 1
a623 2
	    offsetof(struct sigcontext, sc_cookie),
	    sizeof (ksc.sc_cookie));
@


1.219
log
@SROP mitigation.  sendsig() stores a (per-process ^ &sigcontext) cookie
inside the sigcontext.  sigreturn(2) checks syscall entry was from the
exact PC addr in the (per-process ASLR) sigtramp, verifies the cookie,
and clears it to prevent sigcontext reuse.
not yet tested on landisk, sparc, *88k, socppc.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.218 2016/04/03 17:48:33 guenther Exp $	*/
d1235 3
@


1.218
log
@Move the setting of pcb_fsbase out of reset_segs() into its callers

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.217 2015/10/21 07:59:17 mpi Exp $	*/
d574 1
d615 1
a615 1
	struct sigcontext *scp, ksc;
d619 7
a625 5
	scp = SCARG(uap, sigcntxp);
#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) && (!sigpid || p->p_pid == sigpid))
		printf("sigreturn: pid %d, scp %p\n", p->p_pid, scp);
#endif
d628 14
@


1.217
log
@Do not call uvm_swap_finicrypt_all() a second time in dumpsys().

ok tedu@@, deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.216 2015/08/30 10:05:09 yasuoka Exp $	*/
d1006 3
a1008 1
 * Set FS.base for userspace and reset %ds, %es, and %fs segment registers
d1011 1
a1011 1
reset_segs(struct pcb *pcb, u_int64_t fsbase)
a1026 1
	pcb->pcb_fsbase = fsbase;
d1044 2
a1045 1
	reset_segs(&p->p_addr->u_pcb, 0);
@


1.216
log
@Modify kernel to prepare boot from UEFI.

- Add new boot arg "bios_efi_info_t" to pass the paramters from UEFI
- Make bios(4) and acpi(4) be able to probe with the parameters from
  UEFI
- Add efifb(8).  It uses the framebuffer from UEFI and it will work as
  a backend of wsdisplay(4) and wsfb (X11 video driver).  Disabled by
  the kernel config for this moment

input and ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.215 2015/07/16 23:03:40 sf Exp $	*/
a915 4

#ifdef UVM_SWAP_ENCRYPT
	uvm_swap_finicrypt_all();
#endif
@


1.215
log
@Remove 4 second delay on reboot/shutdown that was added 8 years
ago to "workaround MP timeout/splhigh/scsi race at reboot time".

Probably the issue has been fixed by now. And if not, the relevant scsi
controller drivers should add a workaround in their DVACT_POWERDOWN
hook.

While there, change the default final reset delay on amd64 to 0. People
who like looking at the final reboot message may still set the
CPURESET_DELAY define.

OK deraadt@@ kettenis@@ mlarkin@@ uebayasi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.214 2015/06/28 18:54:54 guenther Exp $	*/
d247 1
d1808 1
d1866 1
a1866 1
					cninit();
d1902 6
d1916 2
@


1.214
log
@Force the return to userspace from execve to go through iretq to get all
registers.  This lets us kill the special handling of pid 1 in fork and
merge {proc,child}_trampoline(). Do the same if ptrace(PT_SETREGS) is used
to modify registers.

ok mlarkin@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.213 2015/06/07 06:24:59 guenther Exp $	*/
d165 1
a165 1
int     cpureset_delay = 2000; /* default to 2s */
a741 2

	delay(4*1000000);	/* XXX */
@


1.213
log
@Enable use of mwait in non-MP boxes and report # of C-substates up to C7,
truncating trailing zeros.

Testing by many as part of a larger change to use ACPI _CST objects
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.212 2015/05/24 01:01:49 guenther Exp $	*/
d1046 1
@


1.212
log
@Treat primary cpu like others and put pointer to its GDT in cpu_info.ci_gdt

requested by and ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.211 2015/05/18 19:59:27 guenther Exp $	*/
d701 1
a701 1
	if (cpu_mwait_size > 0) {
@


1.211
log
@Do lazy update/reset of the FS.base and %[def]s segment registers: reseting
segment registers in cpu_switchto if the old thread had made it to userspace
and restoring FS.base only on first return to userspace since context switch.

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.210 2015/04/25 21:21:02 guenther Exp $	*/
a1079 1
char *gdtstore;
d1560 1
a1560 1
	gdtstore = (void *)(cpu_info_primary.ci_tss + 1);
d1563 1
a1563 1
	set_mem_segment(GDT_ADDR_MEM(gdtstore, GCODE_SEL), 0,
d1566 1
a1566 1
	set_mem_segment(GDT_ADDR_MEM(gdtstore, GDATA_SEL), 0,
d1569 1
a1569 1
	set_mem_segment(GDT_ADDR_MEM(gdtstore, GUCODE32_SEL), 0,
d1572 1
a1572 1
	set_mem_segment(GDT_ADDR_MEM(gdtstore, GUDATA_SEL), 0,
d1575 1
a1575 1
	set_mem_segment(GDT_ADDR_MEM(gdtstore, GUCODE_SEL), 0,
d1578 1
a1578 1
	set_sys_segment(GDT_ADDR_SYS(gdtstore, GPROC0_SEL),
d1591 1
a1591 1
	setregion(&region, gdtstore, GDT_SIZE - 1);
@


1.210
log
@cpu_busy_cycle_fcn callback has never been used
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.209 2015/04/18 22:16:21 kettenis Exp $	*/
a578 5
	tf->tf_ds = GSEL(GUDATA_SEL, SEL_UPL);
	tf->tf_es = GSEL(GUDATA_SEL, SEL_UPL);
	tf->tf_fs = GSEL(GUDATA_SEL, SEL_UPL);
	tf->tf_gs = GSEL(GUDATA_SEL, SEL_UPL);

d1011 23
d1046 2
a1047 1
	p->p_addr->u_pcb.pcb_fsbase = 0;
a1049 4
	tf->tf_ds = GSEL(GUDATA_SEL, SEL_UPL);
	tf->tf_es = GSEL(GUDATA_SEL, SEL_UPL);
	tf->tf_fs = GSEL(GUDATA_SEL, SEL_UPL);
	tf->tf_gs = GSEL(GUDATA_SEL, SEL_UPL);
a1920 16
		return EINVAL;

	sel = regs->r_es & 0xffff;
	if (sel != 0 && !VALID_USER_DSEL(sel))
		return EINVAL;

	sel = regs->r_fs & 0xffff;
	if (sel != 0 && !VALID_USER_DSEL(sel))
		return EINVAL;

	sel = regs->r_gs & 0xffff;
	if (sel != 0 && !VALID_USER_DSEL(sel))
		return EINVAL;

	sel = regs->r_ds & 0xffff;
	if (!VALID_USER_DSEL(sel))
@


1.209
log
@It seems that the CPUID lies about the monitor-line size, or at least our
interpretation of it isn't quite right.  So instead of allocating memory
and slicing it based on the parameters returned by CPUID, simply use a member
in struct cpu_info like basically all other OSes out there do.  Our struct
cpu_info is large enough to never cause any overlap.  This makes the
mwait-based idle loop actually work.  We still execute the CPUID instruction
to make sure monitor/mwait is properly supported by the hardware we're
running on.

ok sthen@@, deraadt@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.208 2015/03/25 21:05:18 kettenis Exp $	*/
a157 1
void (*cpu_busy_cycle_fcn)(void) = NULL;
@


1.208
log
@Save/restore AVX registers and other XSAVE-managed state information when
entering/leaving a signal handler like we already do the the FPU and SSE
state.  This should make it possible to use AVX instructions in signal
handlers.

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.207 2015/03/14 03:38:46 jsg Exp $	*/
d674 1
a674 1
		if (ci->ci_mwait != NULL) {
d679 1
a679 1
			if ((ci->ci_mwait[0] & MWAIT_IN_IDLE) == 0)
d682 1
a682 1
				atomic_clearbits_int(&ci->ci_mwait[0],
d707 1
a707 1
	if (ci->ci_mwait != NULL) {
d712 1
a712 1
		atomic_clearbits_int(&ci->ci_mwait[0], MWAIT_KEEP_IDLING);
@


1.207
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.206 2015/01/12 16:33:31 deraadt Exp $	*/
d553 1
a553 1
		sp -= sizeof(struct fxsave64);
d556 1
a556 1
		    (void *)sp, sizeof(struct fxsave64)))
d641 1
a641 1
		if ((error = copyin(ksc.sc_fpstate, fx, sizeof(*fx))))
@


1.206
log
@Enable lid suspends by default in the kernel, and remove the question from
the installer.  We used a full release cycle to learn that suspend/resume
is reliable enough for this default.  Personal policy can disable this using
machdep.lidsuspend=0 in /etc/sysctl.conf
ok more people begging, and less people whining
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.205 2015/01/06 12:50:47 dlg Exp $	*/
a116 1
#include <amd64/isa/nvram.h>
@


1.205
log
@when we're entering an interrupt handler, record its ipl so splassert
can check if we're entering code we think should only be used from
lower ipls.

modelled a bit on how sparc64 does things.

with help from and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.204 2014/12/21 16:27:07 mlarkin Exp $	*/
d193 1
a193 1
int lid_suspend;
@


1.204
log
@Prevent writing to the kernel area via the direct map. We do this by padding
the end of the kernel area to 2MB, so that the direct map pages can then
have the W permission removed (X permission was already removed in a previous
diff). This creates a VA hole at the end of bss, so adjust for that since
that's where symbols get loaded by the bootloader (for now, map that region
RO until the boot loader can be updated to place the symbols at "end" instead
of "end of bss").

with help from and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.203 2014/12/18 05:33:48 mlarkin Exp $	*/
d1777 1
d1782 2
a1783 3

	if (wantipl == IPL_NONE && curcpu()->ci_idepth != 0) {
		splassert_fail(-1, curcpu()->ci_idepth, func);
d1785 1
@


1.203
log
@
Unmap the MP hatch and ACPI resume trampolines when not in active use.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.202 2014/12/15 01:53:45 tedu Exp $	*/
a179 2

char	*ssym = NULL;
@


1.202
log
@change bcopy to memcpy. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.201 2014/12/10 15:29:52 mikeb Exp $	*/
d1179 8
d1204 24
a1227 4
	/* Map trampoline code page RW (to copy code) */
	pmap_kenter_pa((vaddr_t)MP_TRAMPOLINE,	/* virtual */
	    (paddr_t)MP_TRAMPOLINE,	/* physical */
	    PROT_READ | PROT_WRITE);	/* protection */
a1228 5

	/* Map trampoline code page RW (to copy code) */
	pmap_kenter_pa((vaddr_t)ACPI_TRAMPOLINE, /* virtual */
	    (paddr_t)ACPI_TRAMPOLINE,	/* physical */
	    PROT_READ | PROT_WRITE);	/* protection */
@


1.201
log
@retire shutdown hooks; ok deraadt, krw
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.200 2014/12/08 07:12:37 mlarkin Exp $	*/
d540 1
a540 1
	bcopy(tf, &ksc, sizeof(*tf));
d652 1
a652 1
	bcopy(&ksc, tf, sizeof(*tf));
d848 1
a848 1
		bcopy(buf, (char *)dumpmem_vaddr, sizeof(buf));
d963 1
a963 1
				bcopy((void *)PMAP_DIRECT_MAP(maddr), va, n);
d1853 1
a1853 1
			bcopy(bios_bootduid, bootduid, sizeof(bootduid));
d1859 1
a1859 1
			bcopy(&bios_bootsr->uuid, &sr_bootuuid,
d1861 1
a1861 1
			bcopy(&bios_bootsr->maskkey, &sr_bootkey,
@


1.200
log
@
Split the ACPI resume trampoline into code and data, move the data page to
.rodata (kernel copies to the RW page), protect the code page with RX
permissions, protect the code page with RW permissions.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.199 2014/12/02 18:13:10 tedu Exp $	*/
a761 1
	doshutdownhooks();
@


1.199
log
@delete all the simplelocks. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.198 2014/11/22 18:55:20 deraadt Exp $	*/
d1203 1
d1206 1
a1206 1
	    PROT_MASK);		/* protection */
d1300 2
@


1.198
log
@{ on seperate line at start of function or I go crazy
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.197 2014/11/22 18:31:46 mlarkin Exp $	*/
a1069 1
struct simplelock idt_lock;
a1721 1
	simple_lock(&idt_lock);
a1724 1
			simple_unlock(&idt_lock);
a1727 1
	simple_unlock(&idt_lock);
a1744 1
	simple_lock(&idt_lock);
a1746 1
	simple_unlock(&idt_lock);
@


1.197
log
@
Split the MP trampoline into two pages, one for code and one for data/stack
and then protect the code page as RX and the data/stack page as RW (NX).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.196 2014/11/18 20:51:00 krw Exp $	*/
d1178 2
a1179 1
map_tramps(void) {
@


1.196
log
@Nuke some obvious #include duplications.

ok espie@@ deraadt@@ millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.195 2014/11/16 12:30:56 deraadt Exp $	*/
d1181 1
a1181 1
	pmap_kenter_pa(lo32_vaddr, lo32_paddr, PROT_READ | PROT_WRITE | PROT_EXEC);
d1194 2
d1197 1
d1200 1
a1200 1
	    PROT_MASK);		/* protection */
d1292 2
@


1.195
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.194 2014/11/08 03:31:58 guenther Exp $	*/
a110 1
#include <machine/reg.h>
@


1.194
log
@Kill #if 0'ed code for boot args that we don't care about on amd64.

ok deraadt@@ mlarkin@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.193 2014/10/09 04:18:09 tedu Exp $	*/
d1182 1
a1182 1
	pmap_kenter_pa(lo32_vaddr, lo32_paddr, VM_PROT_ALL);
d1198 1
a1198 1
	    VM_PROT_ALL);		/* protection */
d1203 1
a1203 1
	    VM_PROT_ALL);		/* protection */
d1510 1
a1510 1
	pmap_kenter_pa(idt_vaddr, idt_paddr, VM_PROT_READ|VM_PROT_WRITE);
d1512 1
a1512 1
	    VM_PROT_READ|VM_PROT_WRITE);
@


1.193
log
@no need for lkm_map now
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.192 2014/09/27 08:27:17 mlarkin Exp $	*/
a248 6
#if NAPM > 0 || defined(DEBUG)
bios_apminfo_t	*apm;
#endif
#if NPCI > 0
bios_pciinfo_t	*bios_pciinfo;
#endif
a1796 2
#if 0
#if NAPM > 0 || defined(DEBUG)
d1798 1
a1798 4
#ifdef BOOTINFO_DEBUG
			printf(" apminfo %p", q->ba_arg);
#endif
			apm = (bios_apminfo_t *)q->ba_arg;
a1799 2
#endif
#endif
a1805 2
#if 0
#if NPCI > 0
d1807 1
a1807 4
			bios_pciinfo = (bios_pciinfo_t *)q->ba_arg;
#ifdef BOOTINFO_DEBUG
			printf(" pciinfo %p", bios_pciinfo);
#endif
a1808 2
#endif
#endif
@


1.192
log
@

Removed an ununsed macro

ok tedu@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.191 2014/09/27 07:56:18 mlarkin Exp $	*/
a203 6
#ifdef LKM
vaddr_t lkm_start, lkm_end;
static struct vm_map lkm_map_store;
extern struct vm_map *lkm_map;
#endif

a335 6
#ifdef LKM
	uvm_map_setup(&lkm_map_store, lkm_start, lkm_end, VM_MAP_PAGEABLE);
	lkm_map_store.pmap = pmap_kernel();
	lkm_map = &lkm_map_store;
#endif

a1388 6

#ifdef LKM
	lkm_start = KERNTEXTOFF + first_avail;
	/* set it to the end of the jumpable region, should be safe enough */
	lkm_end = 0xffffffffffffffff;
#endif
@


1.191
log
@

typo in a printf

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.190 2014/09/19 20:02:25 kettenis Exp $	*/
a1164 2

#define	KBTOB(x)	((size_t)(x) * 1024UL)
@


1.190
log
@Use config_suspend_all(9).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.189 2014/07/21 17:25:47 uebayasi Exp $	*/
d357 1
a357 1
		printf("kernel does not support - c; continuing..\n");
@


1.189
log
@boot(9): Reduce annoying style diffs

- Always use either: ((x & RB_XXX) != 0) or ((x & RB_XXX) == 0) in boolean
  context (mostly if (x), or x ? y : z)
  - prom_halt() in alpha is confirmed to take int as boolean

Converted by coccinelle.  No functional change intended.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a748 2
	struct device *mainbus;

d782 1
a782 3
	mainbus = device_mainbus();
	if (mainbus != NULL)
		config_suspend(mainbus, DVACT_POWERDOWN);
@


1.188
log
@boot(9): Cosmetic changes to improve diff'ability.
@
text
@d751 1
a751 1
	if (howto & RB_POWERDOWN)
d779 1
a779 1
	if (howto & RB_DUMP)
d792 1
a792 1
	if (howto & RB_HALT) {
d798 1
a798 1
			if (howto & RB_POWERDOWN)
d814 1
a814 1
	for(;;) ;
@


1.187
log
@Cosmetic changes to reduce diffs.
@
text
@d815 1
a815 1
	/*NOTREACHED*/
@


1.186
log
@use nitems() instead of handrolling something identical

ok mpi@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.185 2014/07/11 22:28:05 uebayasi Exp $	*/
d776 1
a776 1
	splhigh();		/* Disable interrupts. */
a778 1
	/* Do a dump if requested. */
@


1.185
log
@boot(9): Undo curproc-overriding hacks

Some (not all) boot(9) implementations have ancient hacks which overrides if
(curproc == NULL).  This was probably made in a hope to forcibly proceed
various clean-shutdown related code, including VFS shutdown.  Let's clarify
that clean-shutdown needs process context; it is impossible to cleanly shutdown
VFS from within e.g. a panic in SPL_HIGH.

OK kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1865 1
a1865 1
				    unit < (sizeof(ports)/sizeof(ports[0])))
@


1.184
log
@Set cold to 1 before executing the DVACT_POWERDOWN handlers when halting or
rebooting a machine, like it is done in the hibernate case.

At least some USB host controller drivers rely on this to busy way instead
of sleeping.  Avoid a panic on macppc with an uhci(4) cardbus plugged in.

ok deraadt@@, uebayashi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.183 2014/07/10 20:15:26 uebayasi Exp $	*/
d160 1
a762 3

		if (curproc == NULL)
			curproc = &proc0;
@


1.183
log
@boot(9): Remove comments about RB_*, "cold", and savectx()

Again remove slightly different comments to reduce diffs.  These will be
re-added once boot() become MI and its specification is clearly re-defined.

OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d779 1
@


1.182
log
@boot(): Remove comments about RB_TIMEBAD to reduce diffs

RB_TIMEBAD is documented well enough that the comment is not needed.  sparc64
does slightly different and its comment is left with XXX.

OK deraadt@@ miod@@
@
text
@a753 4
		/*
		 * If the system is cold, just halt, unless the user
		 * explicitly asked for reboot.
		 */
@


1.181
log
@boot(): Unify declarations

OK deraadt@@
@
text
@d768 1
a768 1
			curproc = &proc0;	/* XXX */
d770 1
a770 4
		/*
		 * If we've been adjusting the clock, the todr
		 * will be out of synch; adjust it now.
		 */
@


1.180
log
@Fix a few format string bugs with -DDEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.179 2014/05/31 15:49:28 mpi Exp $	*/
d745 1
a745 1
void
@


1.179
log
@Revert previous diff setting cold to 1 on shutdown because it breaks machine
with softraid(4) disks.

softraid(4) is the last real consumer of the doshutdownhooks(9) API and it is
not trivial to convert its hook to a DVACT_POWERDOWN handler since the latter
does not allow to sleep.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.178 2014/05/30 13:46:16 mpi Exp $	*/
d619 1
a619 1
		printf("sendsig(%d): pc 0x%x, catcher 0x%x\n", p->p_pid,
@


1.178
log
@Set cold to 1 before executing the DVACT_POWERDOWN handlers when halting or
rebooting a machine, like it is done in the hibernate case.

At least some USB host controller drivers rely on this to busy way instead
of sleeping.  Avoid a panic on macppc with an uhci(4) cardbus plugged in.

ok deraadt@@, uebayashi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.177 2014/03/29 18:09:28 guenther Exp $	*/
a785 1
	cold = 1;
@


1.177
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.176 2014/03/26 05:23:42 guenther Exp $	*/
d786 1
@


1.176
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.175 2014/03/22 06:05:45 guenther Exp $	*/
d1656 1
a1656 1
	__asm __volatile("divl %0,%1" : : "q" (0), "a" (0)); 
@


1.175
log
@Move p_sigacts from struct proc to struct process.

testing help mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.174 2014/03/13 03:52:55 dlg Exp $	*/
d611 1
a611 1
	tf->tf_rip = (u_int64_t)p->p_sigcode;
@


1.174
log
@get rid of the assumption that the head of the alldevs list is the
"mainbus" device. this breaks when mpath is enabled because it
attaches before mainbus and therefore takes the head position.

have autoconf provide device_mainbus() which looks up mainbus_cd,
and use that instead.

discussed with deraadt who just wants mpath stuff to move forward
despite there being many ways to shine this particular turd.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.173 2014/01/05 20:23:56 mlarkin Exp $	*/
d546 1
a546 1
	struct sigacts * psp = p->p_sigacts;
@


1.173
log
@

Don't use the first 64KB for anything, including tramps. Move tramps and
hibernate goo up after 64KB to avoid posible corruption by buggy BIOS SMM
code. Diff also ensures the first 64KB doesn't get handed to UVM either.

ok deraadt@@, tested by many with no regressions reported
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.172 2013/12/23 23:23:22 deraadt Exp $	*/
d748 2
d793 3
a795 2
	if (!TAILQ_EMPTY(&alldevs))
		config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.172
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.171 2013/11/19 04:12:17 guenther Exp $	*/
a1230 1

d1311 3
d1315 1
a1316 2
	avail_start = PAGE_SIZE; /* BIOS leaves data in low memory */
				 /* and VM system doesn't work with phys 0 */
d1364 1
a1364 1
		/* Nuke page zero */
@


1.171
log
@format string fixes picked up with -Wformat=2

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.170 2013/11/02 15:02:27 kettenis Exp $	*/
d1262 1
a1262 1
	 * Initailize PAGE_SIZE-dependent variables.
@


1.170
log
@Cleanup bios_oconsdev_t.  Make sure you have a halfway recent bootloader
(at least BOOT 3.20 on amd64 and BOOT 3.18 on i386) or you'll risk losing
your serial console.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.169 2013/10/05 17:25:00 guenther Exp $	*/
d1197 1
a1197 1
			printf("WARNING: CAN'T ALLOCATE RAM (%lx-%lx)"
@


1.169
log
@Revert one chunk from previous: don't need another #include here
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.168 2013/10/05 16:58:30 guenther Exp $	*/
d1859 1
a1859 1
			if (q->ba_size >= sizeof(bios_oconsdev_t) +
d1867 1
a1867 4
				int consaddr = -1;
				if (q->ba_size >= sizeof(bios_consdev_t) +
				    offsetof(struct _boot_args32, ba_arg))
					consaddr = cdp->consaddr;
@


1.168
log
@Use monitor/mwait to idle when available.  Make cpu_unidle() do nothing
if can tell the target CPU isn't actually idling and introduce cpu_kick()
for the cases where we want to force a non-idle CPU into the kernel.

critical review of early versions by weingart@@; testing by many
ok haesbaert@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.167 2013/09/29 12:56:31 kettenis Exp $	*/
a87 1
#include <sys/wait.h>
@


1.167
log
@Get rid of cnset().  It is only used on amd64/i386 and doesn't really do
anything useful there.  Switching from glass console to serial console is
already done by cninit(), and the reinitializaton of cn_tab by cnset()
breaks the conseleness checks in the wsdisplay code.

Tested on various amd64/i386 systems with both glass and serial console.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.166 2013/09/28 12:40:28 miod Exp $	*/
d88 1
d689 25
d722 1
a722 1
	cpu_unidle(p->p_cpu);
d729 9
d1740 1
a1740 1
		cpu_unidle(ci);
@


1.166
log
@In boot(), do not iterate over alldevs if it's empty (i.e. halting from ddb
with ddb entered early with boot -d or from UKC).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.165 2013/06/29 21:06:15 brad Exp $	*/
a1854 1
				cnset(cdp->consdev);
@


1.165
log
@Remove unsigned comparison >= 0.

Pointed out by LLVM.

ok matthew@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.164 2013/06/11 16:42:06 deraadt Exp $	*/
d757 2
a758 1
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.164
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.163 2013/06/02 16:38:05 guenther Exp $	*/
d1678 1
a1678 1
	if (addr >= 0 && addr < avail_start)
@


1.163
log
@Don't need gdt.h here
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.162 2013/03/21 15:50:27 deraadt Exp $	*/
d802 1
a802 1
	int (*dump)(dev_t, daddr64_t, caddr_t, size_t);
d897 1
a897 1
	daddr64_t blkno;
d899 1
a899 1
	int (*dump)(dev_t, daddr64_t, caddr_t, size_t);
@


1.162
log
@move kernel after 16MB. needed for additional growth that might come in a
little while...
diff from martynas who is not around now
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.161 2013/03/02 07:02:07 guenther Exp $	*/
a103 1
#include <machine/gdt.h>
@


1.161
log
@The last use of the int $80 syscall entry was in 5.1, so we no longer
need to reserve it

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.160 2013/01/16 05:49:48 dlg Exp $	*/
d1406 18
@


1.160
log
@init comconsiot to X86_BUS_SPACE_IO in case someone changes the value of
that thing to be something other than 0, which as a global it gets initted
to.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.159 2012/12/02 07:03:31 guenther Exp $	*/
a1533 3

	/* 128 was the old interrupt gate for syscalls; remove in 2013 */
	idt_allocmap[128] = 1;
@


1.159
log
@Determine whether we're currently on the alternative signal stack
dynamically, by comparing the stack pointer against the altstack
base and size, so that you get the correct answer if you longjmp
out of the signal handler, as tested by regress/sys/kern/stackjmp/.
Also, fix alt stack handling on vax, where it was completely broken.

Testing and corrections by miod@@, krw@@, tobiasu@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.158 2012/10/19 16:38:30 mlarkin Exp $	*/
d1830 1
@


1.158
log
@

amd64 hibernate "unpack-time" mmu/pmap code and asm goo. Work in
progress.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.157 2012/10/09 12:58:07 jsing Exp $	*/
d560 1
a560 1
	ksc.sc_onstack = p->p_sigstk.ss_flags & SS_ONSTACK;
a561 1
	ksc.sc_fpstate = NULL;
d564 2
a565 2
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0 && !ksc.sc_onstack &&
	    (psp->ps_sigonstack & sigmask(sig))) {
d567 1
a567 2
		p->p_sigstk.ss_flags |= SS_ONSTACK;
	} else
d673 1
a673 5
	/* Restore signal stack. */
	if (ksc.sc_onstack)
		p->p_sigstk.ss_flags |= SS_ONSTACK;
	else
		p->p_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.157
log
@Allow boot(8) to pass information to the kernel, regarding the softraid
volume that it booted off.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.155 2012/06/04 15:19:47 jsing Exp $	*/
d148 4
d1297 5
@


1.156
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d143 5
d1755 1
d1853 11
@


1.155
log
@Correct the backwards compatibility code for console device configuration.

Fix tested by naddy@@

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.153 2012/05/06 04:20:40 guenther Exp $	*/
d755 1
@


1.154
log
@Add support for serial consoles at non-standard addresses.  This implements
a new "machine comaddr" command that makes it possible to configure the
io port used to access the serial port.  This can be used to use serial ports
on a puc(4) device as serial console.
@
text
@d1800 2
a1801 1
			if (q->ba_size >= sizeof(bios_oconsdev_t)) {
d1809 2
a1810 1
				if (q->ba_size >= sizeof(bios_consdev_t))
@


1.153
log
@Garbage collect the old int$80 kernel entry point: the last use of
it by the not-normally-used sigreturn() stub in libc was changed to
use 'syscall' instruction in 5.0

ok mikeb@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.152 2012/01/13 12:55:52 jsing Exp $	*/
d1800 1
a1800 1
			if (q->ba_size >= sizeof(bios_consdev_t)) {
d1807 8
a1814 2
				if (major(cdp->consdev) == 8 && unit >= 0 &&
				    unit < (sizeof(ports)/sizeof(ports[0]))) {
d1816 1
a1816 1
					comconsaddr = ports[unit];
@


1.152
log
@Switch back to bootduid, however remember to include sys/systm.h...
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.150 2012/01/11 15:58:27 jsing Exp $	*/
a1201 1
extern vector IDTVEC(osyscall);
d1526 1
a1526 3
	/* new-style interrupt gate for syscalls */
	setgate(&idt[128], &IDTVEC(osyscall), 0, SDT_SYS386IGT, SEL_UPL,
	    GSEL(GCODE_SEL, SEL_KPL));
@


1.151
log
@Backout premature use of 'bootduid', as 'rootduid' has not yet been
renamed.
@
text
@d1840 1
a1840 1
			bcopy(bios_bootduid, rootduid, sizeof(rootduid));
@


1.150
log
@Pass the DUID of the boot disk via bootduid instead of rootduid, since it
is the DUID that we booted from, which is not always going to be the same
as the DUID that we mount root on.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.149 2011/07/10 18:11:49 deraadt Exp $	*/
d1840 1
a1840 1
			bcopy(bios_bootduid, bootduid, sizeof(bootduid));
@


1.149
log
@remove irrelevant comments
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.148 2011/07/05 04:48:01 guenther Exp $	*/
d1751 1
a1751 1
	bios_rootduid_t *bios_rootduid;
d1838 3
a1840 3
		case BOOTARG_ROOTDUID:
			bios_rootduid = (bios_rootduid_t *)q->ba_arg;
			bcopy(bios_rootduid, rootduid, sizeof(rootduid));
@


1.148
log
@Recommit the reverted sigacts change now that the NFS use-after-free
problem has been tracked down.  This fixes the sharing of the signal
handling state: shared bits go in sigacts, per-rthread bits goes in
struct proc.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.147 2011/07/04 15:54:24 guenther Exp $	*/
a786 4
 * XXXfvdl share dumpcode.
 */

/*
a1481 3
	/*
	 * XXXfvdl todo: acpi wakeup code.
	 */
@


1.147
log
@Force the sigreturn syscall to return to userspace via iretq by setting
the MDP_IRET flag in md_proc, then switch sigcode to enter the kernel
via syscall instead of int$80.  Rearrange the return paths in both the
sysretq and iretq paths to reduce how long interrupts are blocked and
shave instructions.

ok kettenis@@, extra testing krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.146 2011/07/04 06:05:56 guenther Exp $	*/
d551 1
a551 1
	ksc.sc_onstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d556 1
a556 1
	if ((psp->ps_flags & SAS_ALTSTACK) && !ksc.sc_onstack &&
d558 2
a559 2
		sp = (register_t)psp->ps_sigstk.ss_sp + psp->ps_sigstk.ss_size;
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
d668 1
a668 1
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
d670 1
a670 1
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.146
log
@Fix typo; ok ariane@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.145 2011/07/03 20:22:07 oga Exp $	*/
d672 10
@


1.145
log
@Fix boot dump on bigmem machines.

Allocate a bouncebuffer at boot time and bounce all pages over
0xffffffff through it.

``looks right but not tested'' miod@@, ok krw (who watched me test it on
his monster laptop.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.144 2011/06/26 22:39:59 deraadt Exp $	*/
d1373 1
a1373 1
	 * fleensed) into the VM system.
@


1.144
log
@if_downall() cannot be done MI in sys_reboot() because vfs_shutdown()
might need network (ie. nfs).  Move the call to the MD boot() routines.
This cause for boot hangs diagnosed by kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.143 2011/06/05 19:41:06 deraadt Exp $	*/
d168 5
d798 1
d829 11
a839 1
	return (dump(dumpdev, dumplo, (caddr_t)buf, dbtob(1)));
d889 1
d945 8
d954 1
a954 2
			error = (*dump)(dumpdev, blkno,
			    (caddr_t)PMAP_DIRECT_MAP(maddr), n);
d1441 36
a1553 1

@


1.143
log
@Move the bufcachepercent setting code to MI locations -- set it to 42%
for now; that is unlikely to hit some of the remaining starvation bugs.
Repair the bufpages calculation too; i386 was doing it ahead of time
(incorrectly) and then re-calculating it.
ok thib
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.142 2011/05/30 22:25:20 oga Exp $	*/
d97 1
d727 1
@


1.142
log
@Remove the freelist member from vm_physseg

The new world order of pmemrange makes this data completely redundant
(being dealt with by the pmemrange constraints instead). Remove all code
that messes with the freelist.

While touching every caller of uvm_page_physload() anyway, add the flags
argument to all callers (all but one is 0 and that one already used
PHYSLOAD_DEVICE) and remove the macro magic to allow callers to continue
without it.

Should shrink the code a bit, as well.

matthew@@ pointed out some mistakes i'd made.
``freelist death, I like. Ok.' ariane@@
`I agree with the general direction, go ahead and i'll fix any fallout
shortly'' miod@@ (68k 88k and vax i could not check would build)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.141 2011/04/26 17:33:17 jsing Exp $	*/
a196 11

#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 10
#endif

#ifdef BUFPAGES
int	bufpages = BUFPAGES;
#else
int	bufpages = 0;
#endif
int bufcachepercent = BUFCACHEPERCENT;
@


1.141
log
@Make amd64/i386 boot(8) pass the DUID of the selected boot device to the
kernel so that it can use it to identify the root disk. This will be
needed in order to correctly boot from a softraid volume.

ok deraadt@@ marco@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.139 2011/04/17 20:38:09 deraadt Exp $	*/
a1362 1
		int seg_type;
a1369 8
		/* XXX - Should deal with 4GB boundary */
		if (seg_start >= (1UL<<32))
			seg_type = VM_FREELIST_HIGH;
		else if (seg_end <= 16*1024*1024)
			seg_type = VM_FREELIST_LOW;
		else
			seg_type = VM_FREELIST_DEFAULT;

d1375 1
a1375 1
		    atop(seg_start), atop(seg_end), seg_type);
@


1.140
log
@Revert the sigacts diff: NFS can apparently retain pointers to processes
until they're zombies and then send them signals (for intr mounts).  Until
that is untangled, the sigacts change is unsafe.  sthen@@ was the victim
for this one
@
text
@d1707 1
d1792 5
@


1.139
log
@bigmem works well enough on amd64; we do not need the knob to turn it
off anymore.
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.138 2011/04/15 04:52:39 guenther Exp $	*/
d556 1
a556 1
	ksc.sc_onstack = p->p_sigstk.ss_flags & SS_ONSTACK;
d561 1
a561 1
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0 && !ksc.sc_onstack &&
d563 2
a564 2
		sp = (register_t)p->p_sigstk.ss_sp + p->p_sigstk.ss_size;
		p->p_sigstk.ss_flags |= SS_ONSTACK;
d673 1
a673 1
		p->p_sigstk.ss_flags |= SS_ONSTACK;
d675 1
a675 1
		p->p_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.138
log
@Correct the sharing of the signal handling state: stuff that should
be shared (p_sigignore, p_sigcatch, P_NOCLDSTOP, P_NOCLDWAIT) moves
to struct sigacts, wihle stuff that should be per rthread (ps_oldmask,
SAS_OLDMASK, ps_sigstk) moves to struct proc.  Treat the coredumping
state bits (ps_sig, ps_code, ps_type, ps_sigval) as per-rthread
until our locking around coredumping is better.

Oh, and remove the old SunOS-compat ps_usertramp member.

"I like the sound of this" tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.137 2011/04/13 02:49:12 guenther Exp $	*/
a1183 2
int bigmem = 1;

a1267 4
	/* Let us know if we're supporting > 4GB ram load */
	if (bigmem)
		printf("Bigmem = %d\n", bigmem);

a1302 8
			if (s1 > e1)
				continue;
		}

		/* Crop to fit below 4GB for now */
		if (!bigmem && (e1 >= (1UL<<32))) {
			printf("Ignoring %dMB above 4GB\n", (e1-(1UL<<32))>>20);
			e1 = (1UL << 32) - 1;
@


1.137
log
@Unrevert the FS.base diff: the issues were actually elsewhere
Additional testing by jasper@@ and pea@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.136 2011/04/10 03:56:38 guenther Exp $	*/
d556 1
a556 1
	ksc.sc_onstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d561 1
a561 1
	if ((psp->ps_flags & SAS_ALTSTACK) && !ksc.sc_onstack &&
d563 2
a564 2
		sp = (register_t)psp->ps_sigstk.ss_sp + psp->ps_sigstk.ss_size;
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
d673 1
a673 1
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
d675 1
a675 1
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.136
log
@Revert bulk of the FS.base diff, as it causes issues on some machines
and the problem isn't obvious yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.135 2011/04/05 21:14:00 guenther Exp $	*/
d371 1
d1003 1
@


1.135
log
@Add support for per-rthread base-offset for the %fs selector on amd64.
Add pcb_fsbase to the PCB for tracking what the value for the thread
is, and ci_cur_fsbase to struct cpu_info for tracking the CPU's current
value for FS.base, then on return to user-space, skip the setting if the
CPU has the right value already.  Non-threaded processes without TLS leave
FS.base zero, which can be conveniently optimized: setting %fs zeros
FS.base for fewer cycles than wrmsr.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.134 2011/04/02 18:16:50 oga Exp $	*/
a370 1
	pcb->pcb_fsbase = 0;
a1001 1
	p->p_addr->u_pcb.pcb_fsbase = 0;
@


1.134
log
@Remove the AMD GART based iommu code.

With current strategies to put memory in the ``correct'' place it isn't
needed.  There's also the problem that it did not work on all machines,
failing completely on some and utterly breaking DMA. So just remove it.
If anyone needs it it will be in the Attic.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.133 2011/04/02 17:36:45 beck Exp $	*/
d371 1
d1003 1
@


1.133
log
@Enable bigmem by default on amd64.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.132 2011/03/20 21:44:08 guenther Exp $	*/
a1316 4
		} else if (bigmem && (e1 >= (1UL<<32))) {
			extern int amdgart_enable;

			amdgart_enable = 1;
@


1.132
log
@When reading MXCSR from userland sigcontext or a ptrace request,
mask out invalid bits to prevent a protect fault.

Original diff by joshe@@; further feedback and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.131 2011/03/18 03:10:47 guenther Exp $	*/
d1182 1
a1182 1
int bigmem = 0;
@


1.131
log
@Old-style MTRRs were never used on amd64, so remove the remaining traces
of them, as well as some other unused proc md_flags bits: MDP_COMPAT and
MDP_SYSCALL.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.130 2011/01/13 20:34:04 mikeb Exp $	*/
d658 3
a660 2
		if ((error = copyin(ksc.sc_fpstate,
		    &p->p_addr->u_pcb.pcb_savefpu.fp_fxsave, sizeof (struct fxsave64))))
d662 1
d1509 1
@


1.130
log
@set lkm_end to the end of the jumpable virtual space;  tested by me and marco
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.129 2010/11/22 21:07:16 miod Exp $	*/
a108 1
#include <machine/mtrr.h>
a228 2

struct mtrr_funcs *mtrr_funcs;
@


1.129
log
@Remove prototypes for missing (removed) functions or already found in a
MI header file.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.128 2010/11/20 20:33:23 miod Exp $	*/
d1369 2
a1370 1
	lkm_end = KERNBASE + NKL2_KIMG_ENTRIES * NBPD_L2;
@


1.128
log
@This is a first step towards getting rid of avail_start and avail_end in the
kernel, currently limited to low-hanging fruit: these variables were used
by bus_dma to specify the range in which to allocate memory, back when
uvm_pglistalloc() was stupid and would not walk the vm_physseg[].

Nowadays, except on some platforms for early initialization, these variables
are not used, or do not need to be global variables. Therefore:
- remove `extern' declarations of avail_start and avail_end (or close cousins,
  such as arm physical_start and physical_end) from files which no longer need
  to use them.
- make them local variables whenever possible.
- remove them when they are assigned to but no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.127 2010/11/13 04:16:42 guenther Exp $	*/
a1187 1
	extern void consinit(void);
@


1.127
log
@Switch from TSS-per-process to TSS-per-CPU, placing the TSS right
next to the cpu's GDT, also making the double-fault stack per-CPU,
leaving it at the top of the page of the CPU's idle process.  Inline
pmap_activate() and pmap_deactivate() into the asm cpu_switchto
routine, adding a check for the new pmap already being marked as
active on the CPU.  Garbage collect the hasn't-been-used-in-years
GDT update IPI.

Tested by many; ok mikeb@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.126 2010/10/26 05:49:10 guenther Exp $	*/
d225 2
a226 1
extern	paddr_t avail_start, avail_end;
@


1.126
log
@The LDT is only used by dead compat code now, so load the ldt
register with the null selector (disabling use of it), stop reloading
it on every context switch, and blow away the table itself, as well
as the pcb and pmap bits that were used to track it.  Also, delete
two other unused pcb members: pcb_usersp and pcb_flags.  (Deleting
pcb_usersp also keeps the pcb_savefpu member aligned properly.)
Finally, delete the defines for the unimplemented AMD64_{GET,SET}_LDT
sysarch() calls.

Tested by various with both AMD and Intel chips
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.125 2010/10/14 04:38:24 guenther Exp $	*/
d114 1
d364 1
a364 1
 * Set up proc0's TSS
a369 3
	int x;

	gdt_init();
d372 3
d376 5
a380 10
	pcb->pcb_tss.tss_iobase =
	    (u_int16_t)((caddr_t)pcb->pcb_iomap - (caddr_t)&pcb->pcb_tss);
	for (x = 0; x < sizeof(pcb->pcb_iomap) / 4; x++)
		pcb->pcb_iomap[x] = 0xffffffff;

	pcb->pcb_cr0 = rcr0();
	pcb->pcb_tss.tss_rsp0 = (u_int64_t)proc0.p_addr + USPACE - 16;
	pcb->pcb_tss.tss_ist[0] = (u_int64_t)proc0.p_addr + PAGE_SIZE;
	proc0.p_md.md_regs = (struct trapframe *)pcb->pcb_tss.tss_rsp0 - 1;
	proc0.p_md.md_tss_sel = tss_alloc(pcb);
d382 1
a382 1
	ltr(proc0.p_md.md_tss_sel);
a393 1
	int x;      
d396 3
a398 4
	pcb->pcb_tss.tss_iobase =
	    (u_int16_t)((caddr_t)pcb->pcb_iomap - (caddr_t)&pcb->pcb_tss);
	for (x = 0; x < sizeof(pcb->pcb_iomap) / 4; x++)
		pcb->pcb_iomap[x] = 0xffffffff;
a400 2
        
        ci->ci_idle_tss_sel = tss_alloc(pcb);
d1466 2
a1467 1
	gdtstore = (char *)(idt + NIDT);
d1485 4
d1503 1
a1503 1
	setregion(&region, gdtstore, DYNSEL_START - 1);
a1527 3
        /* Make sure maxproc is sane */ 
        if (maxproc > cpu_maxproc())
                maxproc = cpu_maxproc();
a1698 9
}

/*
 * Number of processes is limited by number of available GDT slots.
 */
int
cpu_maxproc(void)
{
	return (MAXGDTSIZ - DYNSEL_START) / 16;
@


1.125
log
@Clean up segment handling: switch user-space to using code and data
segments in the GDT instead of the LDT and eliminate the GDT slots
that we don't actually use.

tested on both amd and intel by several
not really the right person, but ok: kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.124 2010/10/02 23:31:33 deraadt Exp $	*/
d363 1
a363 1
 * Set up proc0's TSS and LDT.
a374 1
	pcb->pcb_flags = 0;
a379 2
	pcb->pcb_ldt_sel = pmap_kernel()->pm_ldt_sel =
	    GSYSSEL(GLDT_SEL, SEL_KPL);
d387 1
a387 1
	lldt(pcb->pcb_ldt_sel);
d391 1
a391 1
 * Set up TSS and LDT for a new PCB.
a405 3
	/* XXXfvdl pmap_kernel not needed */ 
	pcb->pcb_ldt_sel = pmap_kernel()->pm_ldt_sel =
	    GSYSSEL(GLDT_SEL, SEL_KPL);
a1003 1
	struct pcb *pcb = &p->p_addr->u_pcb;
a1010 2
	pcb->pcb_flags = 0;

a1046 1
char *ldtstore;
a1186 2
extern vector IDTVEC(syscall);
extern vector IDTVEC(syscall32);
a1187 1
extern vector IDTVEC(oosyscall);
a1196 1
	struct mem_segment_descriptor *ldt_segp;
a1474 1
	ldtstore = gdtstore + DYNSEL_START;
d1477 2
a1478 5
	set_mem_segment(GDT_ADDR_MEM(gdtstore, GCODE_SEL), 0, 0xfffff, SDT_MEMERA,
	    SEL_KPL, 1, 0, 1);

	set_mem_segment(GDT_ADDR_MEM(gdtstore, GDATA_SEL), 0, 0xfffff, SDT_MEMRWA,
	    SEL_KPL, 1, 0, 1);
d1480 2
a1481 2
	set_sys_segment(GDT_ADDR_SYS(gdtstore, GLDT_SEL), ldtstore, LDT_SIZE - 1,
	    SDT_SYSLDT, SEL_KPL, 0);
d1484 1
a1484 1
	    atop(VM_MAXUSER_ADDRESS) - 1, SDT_MEMERA, SEL_UPL, 1, 1, 0);
a1490 30

	/* make ldt gates and memory segments */
	setgate((struct gate_descriptor *)(ldtstore + LSYS5CALLS_SEL),
	    &IDTVEC(oosyscall), 0, SDT_SYS386CGT, SEL_UPL,
	    GSEL(GCODE_SEL, SEL_KPL));

	*(struct mem_segment_descriptor *)(ldtstore + LUCODE_SEL) =
	    *GDT_ADDR_MEM(gdtstore, GUCODE_SEL);
	*(struct mem_segment_descriptor *)(ldtstore + LUDATA_SEL) =
	    *GDT_ADDR_MEM(gdtstore, GUDATA_SEL);

	/*
	 * 32 bit LDT entries.
	 */
	ldt_segp = (struct mem_segment_descriptor *)(ldtstore + LUCODE32_SEL);
	set_mem_segment(ldt_segp, 0, atop(VM_MAXUSER_ADDRESS32) - 1,
	    SDT_MEMERA, SEL_UPL, 1, 1, 0);
	ldt_segp = (struct mem_segment_descriptor *)(ldtstore + LUDATA32_SEL);
	set_mem_segment(ldt_segp, 0, atop(VM_MAXUSER_ADDRESS32) - 1,
	    SDT_MEMRWA, SEL_UPL, 1, 1, 0);

	/*
	 * Other entries.
	 */
	memcpy((struct gate_descriptor *)(ldtstore + LSOL26CALLS_SEL),
	    (struct gate_descriptor *)(ldtstore + LSYS5CALLS_SEL),
	    sizeof (struct gate_descriptor));
	memcpy((struct gate_descriptor *)(ldtstore + LBSDICALLS_SEL),
	    (struct gate_descriptor *)(ldtstore + LSYS5CALLS_SEL),
	    sizeof (struct gate_descriptor));
@


1.124
log
@turn off lid suspend if we doing halt -p
ok kettenis marco miod
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.123 2010/10/02 23:30:39 deraadt Exp $	*/
d615 4
a618 4
	tf->tf_ds = LSEL(LUDATA_SEL, SEL_UPL);
	tf->tf_es = LSEL(LUDATA_SEL, SEL_UPL);
	tf->tf_fs = LSEL(LUDATA_SEL, SEL_UPL);
	tf->tf_gs = LSEL(LUDATA_SEL, SEL_UPL);
d626 1
a626 1
	tf->tf_cs = LSEL(LUCODE_SEL, SEL_UPL);
d629 1
a629 1
	tf->tf_ss = LSEL(LUDATA_SEL, SEL_UPL);
d1021 4
a1024 4
	tf->tf_ds = LSEL(LUDATA_SEL, SEL_UPL);
	tf->tf_es = LSEL(LUDATA_SEL, SEL_UPL);
	tf->tf_fs = LSEL(LUDATA_SEL, SEL_UPL);
	tf->tf_gs = LSEL(LUDATA_SEL, SEL_UPL);
d1041 1
a1041 1
	tf->tf_cs = LSEL(LUCODE_SEL, SEL_UPL);
d1044 1
a1044 1
	tf->tf_ss = LSEL(LUDATA_SEL, SEL_UPL);
d1501 2
a1502 2
	set_mem_segment(GDT_ADDR_MEM(gdtstore, GUCODE_SEL), 0,
	    atop(VM_MAXUSER_ADDRESS) - 1, SDT_MEMERA, SEL_UPL, 1, 0, 1);
d1507 3
a1518 10

	/*
	 * 32 bit GDT entries.
	 */

	set_mem_segment(GDT_ADDR_MEM(gdtstore, GUCODE32_SEL), 0,
	    atop(VM_MAXUSER_ADDRESS) - 1, SDT_MEMERA, SEL_UPL, 1, 1, 0);

	set_mem_segment(GDT_ADDR_MEM(gdtstore, GUDATA32_SEL), 0,
	    atop(VM_MAXUSER_ADDRESS) - 1, SDT_MEMRWA, SEL_UPL, 1, 1, 0);
@


1.123
log
@unneccessary check before calling cpu_unidle; Vladimir Kirillov
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.122 2010/09/29 15:11:31 joshe Exp $	*/
d720 2
@


1.122
log
@Back out previous, it appears to be broken.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.120 2010/09/21 01:04:12 matthew Exp $	*/
d1714 1
a1714 2
		if (ci != curcpu())
			cpu_unidle(ci);
@


1.121
log
@When reading MXCSR from userland sigcontext, mask out invalid bits.

This prevents a protection fault if a userland signal handler
scribbles all over it's struct sigcontext

Help from and ok guenther@@ kettenis@@
@
text
@d674 2
a675 3
		struct fxsave64 *fx = &p->p_addr->u_pcb.pcb_savefpu.fp_fxsave;

		if ((error = copyin(ksc.sc_fpstate, fx, sizeof(*fx))))
a676 1
		fx->fx_mxcsr &= fpu_mxcsr_mask;
a1213 1
	fpuinit(&cpu_info_primary);
@


1.120
log
@Make splassert(IPL_NONE) work on amd64 the same as it does on i386.

ok oga@@ (a while back)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.119 2010/08/05 21:10:10 deraadt Exp $	*/
d674 3
a676 2
		if ((error = copyin(ksc.sc_fpstate,
		    &p->p_addr->u_pcb.pcb_savefpu.fp_fxsave, sizeof (struct fxsave64))))
d678 1
d1216 1
@


1.119
log
@new i386/amd64 machdep.lidsuspend sysctl which decides whether a lid
close causes a suspend.  resumes are not tied to this; they happen
unconditionally.  this is a temporary knob for the 4.8 release; afterwards
it will move to a more convenient place
much moaning discussing where to put the knob with kettenis
tested by various including phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.118 2010/07/25 21:43:38 deraadt Exp $	*/
d1778 4
@


1.118
log
@in the clock drivers, seperate the soft-state and hard-state which was
all jumbled up in the same functions. the rtc (mc chip) and clock (i8243)
startup was also mixed up.  they the soft state and hardware state can
be started in the right order, and it is easy to restart just the
neccessary parts upon resume.  tested in numerous cases:
(apic, pic) * (GENERIC.MP, GENERIC) * (mp, non-mp) * (i386, amd64)
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.117 2010/07/23 14:56:31 kettenis Exp $	*/
d181 1
d534 2
@


1.117
log
@Don't leak the contents of the FPU and SSE registers between processes.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.116 2010/07/01 23:06:33 kettenis Exp $	*/
d318 1
a1700 5

	if (initclock_func == i8254_initclocks)
		i8254_inittimecounter();
	else
		i8254_inittimecounter_simple();
@


1.116
log
@Make our trapframe squeeky clean in setregs().  Avoid leaking registers into
the new process image.

ok deraadt@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.115 2010/07/01 19:56:12 mlarkin Exp $	*/
a552 1
	struct savefpu *sfp = &p->p_addr->u_pcb.pcb_savefpu;
a591 2
		sfp->fp_fxsave.fx_fcw = __INITIAL_NPXCW__;
		sfp->fp_fxsave.fx_mxcsr = __INITIAL_MXCSR__;
d1010 1
a1011 1
	p->p_md.md_flags &= ~MDP_USEDFPU;
a1012 3
	pcb->pcb_savefpu.fp_fxsave.fx_fcw = __INITIAL_NPXCW__;
	pcb->pcb_savefpu.fp_fxsave.fx_mxcsr = __INITIAL_MXCSR__;
	pcb->pcb_savefpu.fp_fxsave.fx_mxcsr_mask = __INITIAL_MXCSR_MASK__;
@


1.115
log
@

Typo in comment.

ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.114 2010/06/30 19:23:15 oga Exp $	*/
d1032 8
@


1.114
log
@amd64_pa_used is weird.

We check a bunch of things, where most archs are a lot more simple.
Also, we get problems sometimes: My x201 can't map the framebuffer BAR
from the aperture with the chunk that checks the bios sections, meaning
the bios is claiming something about it.

Kettenis@@ and I are pretty sure that the rest of the checks are more than
sufficient, so just nuke that one.

for the record, in the same situation i386 just checks again VGA_START,
BIOS_END and physmem.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.113 2010/06/27 13:28:46 miod Exp $	*/
d1243 1
a1243 1
 * 1. biosbasemem, biosextmem - These are outdated, and should realy
@


1.113
log
@If you include <uvm/uvm.h>, you do not need to include any other <uvm/uvm_foo.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.112 2010/06/27 03:03:48 thib Exp $	*/
a1671 1
	bios_memmap_t	*bmp;
a1679 7

	/* Memory is otherwise reserved */
	for (bmp = bios_memmap; bmp->type != BIOS_MAP_END; bmp++) {
		if (addr > bmp->addr && addr < (bmp->addr + bmp->size) &&
			bmp->type != BIOS_MAP_FREE)
			return 1;
	}
@


1.112
log
@uvm constraints. Add two mandatory MD symbols, uvm_md_constraints
which contains the constraints for DMA/memory allocation for each
architecture, and dma_constraints which contains the range of addresses
that are dma accessable by the system.

This is based on ariane@@'s physcontig diff, with lots of bugfixes and
additions the following additions by my self:

Introduce a new function pool_set_constraints() which sets the address
range for which we allocate pages for the pool from, this is now used
for the mbuf/mbuf cluster pools to keep them dma accessible.

The !direct archs no longer stuff pages into the kernel object in
uvm_km_getpage_pla but rather do a pmap_extract() in uvm_km_putpages.

Tested heavily by my self on i386, amd64 and sparc64. Some tests on
alpha and SGI.

"commit it" beck, art, oga, deraadt
"i like the diff" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.110 2010/06/05 05:55:56 deraadt Exp $	*/
a97 3
#include <uvm/uvm_extern.h>
#include <uvm/uvm_page.h>
#include <uvm/uvm_swap.h>
@


1.111
log
@Declare safepri at the MD level on each platform, so that the kern_synch.c
does not have to deal with it as a common.  Some platforms may be missed
by this commit... if you spot one, fix it the same way.
ok miod
@
text
@d97 1
d210 9
@


1.110
log
@Pass signal handlers a more clean FPU state (ie. the right modes) and
properly restore it in sigreturn.  Lots of deep digging by matthieu,
otto, guenther, kettenis and I.. and I am certain I forgot some other
people.
ok kettenis otto matthieu
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.109 2010/05/18 19:42:48 oga Exp $	*/
d183 6
@


1.109
log
@Since we're direct mapped and don't need to worry about kva availability or
reservation, we don't need to stick to transferring single pages during boot
dump anymore.

so bump the limit up to MAXPHYS (64k). Dramatically speeding up boot
dump/crash on amd64. (my 4gig machine went from 13.5 minues to just over
1min  with this diff)

ok toby, marco. Discussed with miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.108 2010/05/18 07:05:18 halex Exp $	*/
d540 1
d577 5
d659 6
a664 3
	if (ksc.sc_fpstate && (error = copyin(ksc.sc_fpstate,
	    &p->p_addr->u_pcb.pcb_savefpu.fp_fxsave, sizeof (struct fxsave64))))
		return (error);
@


1.108
log
@tweak dumpsys's countdown to cope with upcoming speedup

tested by ckuethe@@, ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.107 2010/05/13 19:27:24 oga Exp $	*/
d862 1
a862 1
#define BYTES_PER_DUMP  PAGE_SIZE /* must be a multiple of pagesize XXX small */
@


1.107
log
@Synchronise amd64 more with other PMAP_DIRECT architectures. (step 1,
more to come later)

Specfically, there is no reason to reserve a special virtual address just so we
can do boot dump, we have a direct map of every page anyway.

since pmap_map is deprecated and MD only anyway, this means we can remove that
interface too. If anything this should increase reliability since pmap_enter
won't fail under memory pressure during dump (unlikely but possible). It is also
simpler and smaller ;)

Tested by myself and ckuethe, no regressions.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.106 2010/03/24 00:36:04 oga Exp $	*/
d918 1
a918 1
			if ((totalbytesleft % (1024*1024)) == 0)
@


1.106
log
@Bring back PHYSLOAD_DEVICE for uvm_page_physload.

ok kettenis@@ beck@@ (tentatively) and ariane@@. deraadt asked for it to be
commited now.

original commit message:

	extend uvm_page_physload to have the ability to add "device" pages to
	the system.

	This is needed in the case where you need managed pages so you can
	handle faulting and pmap_page_protect() on said pages when you manage
	memory in such regions (i'm looking at you, graphics cards).

	these pages are flagged PG_DEV, and shall never be on the freelists,
	assert this. behaviour remains unchanged in the non-device case,
	specifically for all archs currently in the tree we panic if called
	after bootstrap.

	ok art@@ kettenis@@, beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.105 2010/03/08 03:40:50 jolan Exp $	*/
a862 9
static vaddr_t dumpspace;

vaddr_t
reserve_dumppages(vaddr_t p)
{

	dumpspace = p;
	return (p + BYTES_PER_DUMP);
}
d926 2
a927 4
			(void) pmap_map(dumpspace, maddr, maddr + n,
			    VM_PROT_READ);

			error = (*dump)(dumpdev, blkno, (caddr_t)dumpspace, n);
@


1.105
log
@fix compiling without ACPI, ok marco@@ deraadt@@ krw@@ mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.104 2010/03/07 04:14:22 deraadt Exp $	*/
d1660 2
a1661 1
	bios_memmap_t *bmp;
d1664 1
a1664 1
	if (PHYS_TO_VM_PAGE(addr))
@


1.104
log
@back out strict splassert semantics from 1.103; it breaks some things
like bigmem (disabled by default), sppp (ask wilfried about
"splassert: if_up/down: want 5 have 7")
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.102 2009/11/23 16:21:54 pirofti Exp $	*/
d1267 1
a1267 1
#ifndef SMALL_KERNEL
d1270 1
a1270 1
#endif /* !SMALL_KERNEL */
@


1.103
log
@bring the splassert semantic from sparc64 to amd64. splassert in interrupt
handlers now checks that the spl the isr was established at is the same as
the one passed to splassert. this lets you check that isrs dont enter code
that have insufficient protection if entered from process context.

ok kettenis@@
@
text
@d1771 1
a1771 2
	if (cpl < wantipl ||
	    (curcpu()->ci_idepth && cpl > wantipl)) {
@


1.102
log
@Remove ACPI_SLEEP_ENABLED checks.

This enables by default the suspend/resume paths in the kernel.

Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.101 2009/08/11 19:17:16 miod Exp $	*/
d1771 2
a1772 1
	if (cpl < wantipl) {
@


1.101
log
@Do not bother initializing bufpages in the md code if the computation is
exactly the same the mi could will use if bufinit() is invoked with
bufpages == 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.100 2009/08/11 18:46:31 miod Exp $	*/
d1145 1
a1145 1
    (NACPI > 0 && defined(ACPI_SLEEP_ENABLED) && !defined(SMALL_KERNEL))
a1169 1
#ifdef ACPI_SLEEP_ENABLED
a1172 1
#endif /* ACPI_SLEEP_ENABLED */
d1267 1
a1267 1
#ifdef ACPI_SLEEP_ENABLED
d1270 1
a1270 1
#endif /* ACPI_SLEEP_ENABLED */
d1464 1
a1464 1
    (NACPI > 0 && defined(ACPI_SLEEP_ENABLED) && !defined(SMALL_KERNEL))
@


1.100
log
@With the SysV memory allocation changes, allocsys() doesn't do anything
anymore. Get rid of it completely.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.99 2009/08/09 10:40:17 blambert Exp $	*/
a307 7

	/*
	 * Determine how many buffers to allocate.
	 * We allocate bufcachepercent% of memory for buffer space.
	 */
	if (bufpages == 0)
		bufpages = physmem * bufcachepercent / 100;
@


1.99
log
@Rototill system V message queues.

No longer allocate a static amount of memory for messages in MD
boot path; message queues, message metadata, and message data now
all use dynamic memory, which means that runtime sysctls should now
be trivial to implement.

Since I'm going to be around all week to fix any breakage, this should
probably just go in now.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.98 2009/08/02 16:28:39 beck Exp $	*/
a253 2
vaddr_t	allocsys(vaddr_t);
void	setup_buffers(void);
a298 2
	vaddr_t v;
	vsize_t sz;
d310 2
a311 2
	 * Find out how much space we need, allocate it,
	 * and then give everything true virtual addresses.
d313 2
a314 7
	sz = allocsys(0);
	if ((v = uvm_km_zalloc(kernel_map, round_page(sz))) == 0)
		panic("startup: no room for tables");
	if (allocsys(v) - v != sz)
		panic("startup: table size inconsistency");

	setup_buffers();
a351 30
}

/*
 * Allocate space for system data structures.  We are given
 * a starting virtual address and we return a final virtual
 * address; along the way we set each data structure pointer.
 *
 * We call allocsys() with 0 to find out how much space we want,
 * allocate that much and fill it with zeroes, and then call
 * allocsys() again with the correct base virtual address.
 */
vaddr_t
allocsys(vaddr_t v)
{

#define	valloc(name, type, num) \
	    v = (vaddr_t)(((name) = (type *)v) + (num))

	return v;
}

void
setup_buffers()
{
	/*
	 * Determine how many buffers to allocate.
	 * We allocate bufcachepercent% of memory for buffer space.
	 */
	if (bufpages == 0)
		bufpages = physmem * bufcachepercent / 100;
@


1.98
log
@
Dynamic buffer cache support - a re-commit of what was backed out
after c2k9

allows buffer cache to be extended and grow/shrink dynamically

tested by many, ok oga@@, "why not just commit it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.97 2009/07/22 20:33:12 deraadt Exp $	*/
a89 4
#ifdef SYSVMSG
#include <sys/msg.h>
#endif

a377 7

#ifdef SYSVMSG
	valloc(msgpool, char, msginfo.msgmax);
	valloc(msgmaps, struct msgmap, msginfo.msgseg);
	valloc(msghdrs, struct msg, msginfo.msgtql);
	valloc(msqids, struct msqid_ds, msginfo.msgmni);
#endif
@


1.97
log
@via nano cpus are amd64, and so we need machdep.xcrypt
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.96 2009/06/15 17:01:25 beck Exp $	*/
a401 6

	/* Restrict to at most 25% filled kvm */
	if (bufpages >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / PAGE_SIZE / 4) 
		bufpages = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    PAGE_SIZE / 4;
@


1.96
log
@Back out all the buffer cache changes I committed during c2k9. This reverts three
commits:

1) The sysctl allowing bufcachepercent to be changed at boot time.
2) The change moving the buffer cache hash chains to a red-black tree
3) The dynamic buffer cache (Which depended on the earlier too).

ok on the backout from marco and todd
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.95 2009/06/14 03:04:07 deraadt Exp $	*/
d532 1
d580 2
@


1.95
log
@backout:
> extend uvm_page_physload to have the ability to add "device" pages to the
> system.
since it was overlayed over a system that we warned would go "in to be
tested, but may be pulled out".  oga, you just made me spend 20 minutes
of time I should not have had to spend doing this.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.93 2009/06/03 21:30:19 beck Exp $	*/
d402 6
@


1.94
log
@extend uvm_page_physload to have the ability to add "device" pages to the
system.

This is needed in the case where you need managed pages so you can
handle faulting and pmap_page_protect() on said pages when you manage
memory in such regions (i'm looking at you, graphics cards).

these pages are flagged PG_DEV, and shall never be on the freelists,
assert this. behaviour remains unchanged in the non-device case,
specifically for all archs currently in the tree we panic if called
after bootstrap.

ok art@@, kettenis@@, ariane@@, beck@@.
@
text
@d1716 1
a1716 2
	struct vm_page	*pg;
	bios_memmap_t	*bmp;
d1719 1
a1719 1
	if ((pg = PHYS_TO_VM_PAGE(addr)) && (pg->pg_flags & PG_DEV) == 0)
@


1.93
log
@add kern.bufcachepercent sysctl to allow adjusting the buffer cache
size on a running system.
ok art@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.92 2009/06/02 03:04:54 jordan Exp $	*/
d1716 2
a1717 1
	bios_memmap_t *bmp;
d1720 1
a1720 1
	if (PHYS_TO_VM_PAGE(addr))
@


1.92
log
@Added interface for cpu idle on amd64
ok gwk@@, toby@@, marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.91 2009/05/30 20:47:00 kettenis Exp $	*/
a401 6

	/* Restrict to at most 25% filled kvm */
	if (bufpages >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / PAGE_SIZE / 4) 
		bufpages = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    PAGE_SIZE / 4;
@


1.91
log
@Don't use biosbasemem and biosextmem to initialize iomem_ex, since on some
BIOSen it's a complete lie.  Instead use the information from the memory
map like we do on i386.

ok weingart@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.90 2009/04/30 01:16:56 dlg Exp $	*/
d150 7
@


1.90
log
@pass db_console from the bootloader to the kernel, and then use it to
set ddb.console real early.

requested by art@@
no problem! deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.89 2009/04/20 15:44:49 reyk Exp $	*/
d1174 1
d1182 1
a1182 2
	 * extent map.  This is done before the addresses are
	 * page rounded just to make sure we get them all.
d1184 8
a1191 11
	if (extent_alloc_region(iomem_ex, 0, KBTOB(biosbasemem),
	    EX_NOWAIT)) {
		/* XXX What should we do? */
		printf("WARNING: CAN'T ALLOCATE BASE MEMORY FROM "
		    "IOMEM EXTENT MAP!\n");
	}
	if (extent_alloc_region(iomem_ex, IOM_END, KBTOB(biosextmem),
	    EX_NOWAIT)) {
		/* XXX What should we do? */
		printf("WARNING: CAN'T ALLOCATE EXTENDED MEMORY FROM "
		    "IOMEM EXTENT MAP!\n");
d1366 2
@


1.89
log
@bigmem is not tweakable by config(8), it never was.

ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.88 2009/02/15 02:03:40 marco Exp $	*/
d129 1
d1837 1
d1915 7
@


1.88
log
@Add sleep plumbing code for amd64 making it the sameish as i386. Committing
per mlarkin request.

Code from mlarkin, mptramp code from kurt
Lots of comments weingart, art & others
Tested in snaps for weeks
ok kurt, marco
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.87 2009/01/02 05:16:15 miod Exp $	*/
a1240 1
/* Tweakable by config(8) */
@


1.87
log
@Do not evict the kernel image from the mem_clusters[] array, otherwise
it won't get included in kernel crash dumps.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.86 2008/12/30 05:33:15 miod Exp $	*/
d176 1
d257 1
d1199 33
d1325 5
d1519 4
a1522 1
	pmap_kenter_pa(lo32_vaddr, lo32_paddr, VM_PROT_READ|VM_PROT_WRITE);
@


1.86
log
@savecore(8) wants dumpmag to be an unsigned long.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.85 2008/11/22 18:12:32 art Exp $	*/
d1301 1
a1301 1
		paddr_t s1, s2, e1, e2, s3, e3, s4, e4;
d1312 1
a1312 1
		s2 = e2 = 0; s3 = e3 = 0; s4 = e4 = 0;
a1348 18
/* XXX - This is sooo GROSS! */
#define KERNEL_START IOM_END
		/* Crop stuff into kernel from bottom */
		if (s1 < KERNEL_START && e1 > KERNEL_START &&
		    e1 < first_avail) {
			e1 = KERNEL_START;
		}
		/* Crop stuff into kernel from top */
		if (s1 > KERNEL_START && s1 < first_avail &&
		    e1 > first_avail) {
			s1 = first_avail;
		}
		/* Split stuff straddling kernel */
		if (s1 <= KERNEL_START && e1 >= first_avail) {
			s2 = first_avail; e2 = e1;
			e1 = KERNEL_START;
		}

d1351 2
a1352 6
			e3 = e1;
			s3 = e1 = 16*1024*1024;
		}
		if (s2 < 16*1024*1024 && e2 > 16*1024*1024) {
			e4 = e2;
			s4 = e2 = 16*1024*1024;
a1365 10
		if (e3 - s3 >= PAGE_SIZE) {
			mem_clusters[mem_cluster_cnt].start = s3;
			mem_clusters[mem_cluster_cnt].size = e3 - s3;
			mem_cluster_cnt++;
		}
		if (e4 - s4 >= PAGE_SIZE) {
			mem_clusters[mem_cluster_cnt].start = s4;
			mem_clusters[mem_cluster_cnt].size = e4 - s4;
			mem_cluster_cnt++;
		}
a1367 2
		if (avail_end < e3) avail_end = e3;
		if (avail_end < e4) avail_end = e4;
@


1.85
log
@The last parts of cpu_unidle. i386, amd64 and sparc64
In short, make cpu_unidle do what signotify used to do and
make signotify use cpu_unidle.
Also, include a cpu_unidle in need_resched, it won't change much right now
but will be needed in the future.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.84 2008/10/09 19:04:18 kettenis Exp $	*/
d825 1
a825 1
u_int32_t	dumpmag = 0x8fca0101;	/* magic number */
@


1.84
log
@Skip memory areas smaller than 1 MB above the 16 MB boundary to deal with
buggy ACP BIOSes.  Based on a diff from weingart@@.

ok deraadt@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.83 2008/10/06 21:05:56 kettenis Exp $	*/
d729 3
d733 6
a738 2
	if (p->p_cpu != curcpu() && p->p_cpu != NULL)
		x86_send_ipi(p->p_cpu, X86_IPI_NOP);
a739 1
}
d1752 7
a1758 2
	if ((ci)->ci_curproc != NULL)
		aston((ci)->ci_curproc);
@


1.83
log
@Remove useless comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.82 2008/08/12 18:27:22 weingart Exp $	*/
d1307 11
@


1.82
log
@Nuke bigmem for release, still has issues.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.81 2008/06/27 17:22:14 miod Exp $	*/
a1741 1
 * XXXfvdl share idt code
@


1.81
log
@Clear swap encryption keys before dumping a kernel image.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.80 2008/06/26 05:42:09 ray Exp $	*/
d1201 1
a1201 1
int bigmem = 1;
@


1.80
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.79 2008/06/11 18:49:50 weingart Exp $	*/
d103 1
d945 4
@


1.79
log
@Fix GART enabling by using segment end address instead of total
physmem.  This should be more correct than earlier code.
Thank you to Markus Hennecke <markus-hennecke -at- markus-hennecke.de>
for reminding me.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.78 2008/06/10 02:55:39 weingart Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.78
log
@All your memory belong to us.  This has been in snaps for a while,
and seems to work.  If it breaks, people had plenty of chances to
complain.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.77 2008/06/08 13:55:06 kettenis Exp $	*/
a312 6
	if (physmem >= atop(1ULL << 32)) {
		extern int amdgart_enable;

		amdgart_enable = 1;
	}

d1322 4
@


1.77
log
@Make serial console on non-primary ports work to on i386.

tested by jbg@@, "it is right" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.76 2008/06/02 11:46:19 jsg Exp $	*/
d261 1
d1166 33
d1208 2
a1209 1
#define	KBTOB(x)	((size_t)(x) * 1024UL)
d1214 1
a1214 1
	extern struct extent *iomem_ex;
d1217 2
a1218 3
	int x, first16q, ist;
	u_int64_t seg_start, seg_end;
	u_int64_t seg_start1, seg_end1;
d1254 31
d1292 4
d1297 7
a1303 5
	 * Call pmap initialization to make new kernel address space.
	 * We must do this before loading pages into the VM system.
	 */
	pmap_bootstrap(VM_MIN_KERNEL_ADDRESS,
	    IOM_END + trunc_page(KBTOB(biosextmem)));
d1305 5
a1309 2
	if (avail_start != PAGE_SIZE)
		pmap_prealloc_lowmem_ptps();
d1311 9
a1319 11
	if (mem_cluster_cnt == 0) {
		/*
		 * Allocate the physical addresses used by RAM from the iomem
		 * extent map.  This is done before the addresses are
		 * page rounded just to make sure we get them all.
		 */
		if (extent_alloc_region(iomem_ex, 0, KBTOB(biosbasemem),
		    EX_NOWAIT)) {
			/* XXX What should we do? */
			printf("WARNING: CAN'T ALLOCATE BASE MEMORY FROM "
			    "IOMEM EXTENT MAP!\n");
d1321 7
a1327 8
		mem_clusters[0].start = 0;
		mem_clusters[0].size = trunc_page(KBTOB(biosbasemem));
		physmem += atop(mem_clusters[0].size);
		if (extent_alloc_region(iomem_ex, IOM_END, KBTOB(biosextmem),
		    EX_NOWAIT)) {
			/* XXX What should we do? */
			printf("WARNING: CAN'T ALLOCATE EXTENDED MEMORY FROM "
			    "IOMEM EXTENT MAP!\n");
a1328 15
#if 0
#if NISADMA > 0
		/*
		 * Some motherboards/BIOSes remap the 384K of RAM that would
		 * normally be covered by the ISA hole to the end of memory
		 * so that it can be used.  However, on a 16M system, this
		 * would cause bounce buffers to be allocated and used.
		 * This is not desirable behaviour, as more than 384K of
		 * bounce buffers might be allocated.  As a work-around,
		 * we round memory down to the nearest 1M boundary if
		 * we're using any isadma devices and the remapped memory
		 * is what puts us over 16M.
		 */
		if (biosextmem > (15*1024) && biosextmem < (16*1024)) {
			char pbuf[9];
d1330 22
a1351 5
			format_bytes(pbuf, sizeof(pbuf),
			    biosextmem - (15*1024));
			printf("Warning: ignoring %s of remapped memory\n",
			    pbuf);
			biosextmem = (15*1024);
a1352 5
#endif
#endif
		mem_clusters[1].start = IOM_END;
		mem_clusters[1].size = trunc_page(KBTOB(biosextmem));
		physmem += atop(mem_clusters[1].size);
d1354 9
a1362 1
		mem_cluster_cnt = 2;
d1364 25
a1388 1
		avail_end = IOM_END + trunc_page(KBTOB(biosextmem));
d1392 2
a1393 5
	 * If we have 16M of RAM or less, just put it all on
	 * the default free list.  Otherwise, put the first
	 * 16M of RAM on a lower priority free list (so that
	 * all of the ISA DMA'able memory won't be eaten up
	 * first-off).
d1395 7
a1401 4
	if (avail_end <= (16 * 1024 * 1024))
		first16q = VM_FREELIST_DEFAULT;
	else
		first16q = VM_FREELIST_FIRST16;
d1414 1
a1414 4
	 * rounded and truncated) into the VM system.
	 *
	 * NOTE: WE ASSUME THAT MEMORY STARTS AT 0 AND THAT THE KERNEL
	 * IS LOADED AT IOM_END (1M).
d1417 17
a1433 21
		seg_start = mem_clusters[x].start;
		seg_end = mem_clusters[x].start + mem_clusters[x].size;
		seg_start1 = 0;
		seg_end1 = 0;

		if (seg_start > 0xffffffffULL) {
			printf("skipping %lld bytes of memory above 4GB\n",
			    seg_end - seg_start);
			continue;
		}
		if (seg_end > 0x100000000ULL) {
			printf("skipping %lld bytes of memory above 4GB\n",
			    seg_end - 0x100000000ULL);
			seg_end = 0x100000000ULL;
		}

		/*
		 * Skip memory before our available starting point.
		 */
		if (seg_end <= avail_start)
			continue;
a1434 28
		if (avail_start >= seg_start && avail_start < seg_end) {
			if (seg_start != 0)
				panic("init_x86_64: memory doesn't start at 0");
			seg_start = avail_start;
			if (seg_start == seg_end)
				continue;
		}

		/*
		 * If this segment contains the kernel, split it
		 * in two, around the kernel.
		 */
		if (seg_start <= IOM_END && first_avail <= seg_end) {
			seg_start1 = first_avail;
			seg_end1 = seg_end;
			seg_end = IOM_END;
		}

		/* First hunk */
		if (seg_start != seg_end) {
			if (seg_start <= (16 * 1024 * 1024) &&
			    first16q != VM_FREELIST_DEFAULT) {
				u_int64_t tmp;

				if (seg_end > (16 * 1024 * 1024))
					tmp = (16 * 1024 * 1024);
				else
					tmp = seg_end;
d1436 6
a1441 12
				printf("loading 0x%qx-0x%qx (0x%lx-0x%lx)\n",
				    (unsigned long long)seg_start,
				    (unsigned long long)tmp,
				    atop(seg_start), atop(tmp));
#endif
				uvm_page_physload(atop(seg_start),
				    atop(tmp), atop(seg_start),
				    atop(tmp), first16q);
				seg_start = tmp;
			}

			if (seg_start != seg_end) {
d1443 4
a1446 46
				printf("loading 0x%qx-0x%qx (0x%lx-0x%lx)\n",
				    (unsigned long long)seg_start,
				    (unsigned long long)seg_end,
				    atop(seg_start), atop(seg_end));
#endif
				uvm_page_physload(atop(seg_start),
				    atop(seg_end), atop(seg_start),
				    atop(seg_end), VM_FREELIST_DEFAULT);
			}
		}

		/* Second hunk */
		if (seg_start1 != seg_end1) {
			if (seg_start1 <= (16 * 1024 * 1024) &&
			    first16q != VM_FREELIST_DEFAULT) {
				u_int64_t tmp;

				if (seg_end1 > (16 * 1024 * 1024))
					tmp = (16 * 1024 * 1024);
				else
					tmp = seg_end1;
#if DEBUG_MEMLOAD
				printf("loading 0x%qx-0x%qx (0x%lx-0x%lx)\n",
				    (unsigned long long)seg_start1,
				    (unsigned long long)tmp,
				    atop(seg_start1), atop(tmp));
#endif
				uvm_page_physload(atop(seg_start1),
				    atop(tmp), atop(seg_start1),
				    atop(tmp), first16q);
				seg_start1 = tmp;
			}

			if (seg_start1 != seg_end1) {
#if DEBUG_MEMLOAD
				printf("loading 0x%qx-0x%qx (0x%lx-0x%lx)\n",
				    (unsigned long long)seg_start1,
				    (unsigned long long)seg_end1,
				    atop(seg_start1), atop(seg_end1));
#endif
				uvm_page_physload(atop(seg_start1),
				    atop(seg_end1), atop(seg_start1),
				    atop(seg_end1), VM_FREELIST_DEFAULT);
			}
		}
	}
d1686 36
@


1.76
log
@Move interrupt setup to before ddb setup not after.
Makes early ddb (boot -d/ddb from ukc) work on amd64.
Similiar to the change made in NetBSD by Andrew Doran.

ok kettenis@@ fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.75 2008/05/23 15:39:43 jasper Exp $	*/
d1818 1
@


1.75
log
@- remove USER_LDT, it was never in a state where it would copile, nor will
we support i386-compat mode on amd64.

agreed by beck@@, dlg@@, kettenis@@
ok deraadt@@, tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.74 2008/04/30 13:59:33 dlg Exp $	*/
d1564 6
a1582 6

	intr_default_setup();

	softintr_init();
	splraise(IPL_IPI);
	enable_intr();
@


1.74
log
@fix serial console handling on amd64. currently only glass console ever
works, even if the boot loader is configured to use serial console.

after the changes jsing and i made, the initial probe of the serial port
was failing since the default base addres for the port is invalid. cos of
that the kernel would only ever consider the glass console for use. this
fixes it by reprobing the serial port if we get any config for it from the
boot loader.

advice on aesthetics from miod@@
advice and ok from kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.73 2008/04/25 11:30:22 dlg Exp $	*/
a1053 4
#ifdef USER_LDT
	pmap_ldt_cleanup(p);
#endif

a1738 3
#ifdef USER_LDT
	return ((MAXGDTSIZ - DYNSEL_START) / 32);
#else
a1739 1
#endif
@


1.73
log
@the code that parses arguments from the boot loader on amd64 wasnt checking
what type of console was specified, so when a glass console was used it was
still configuring serial bits. this makes it so serial config only occurs
for serial console devices.

found by jolan@@, thib@@, and maybe sthen@@
sorry guys
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.72 2008/04/24 12:33:14 dlg Exp $	*/
d146 6
a1182 1
	extern void consinit(void);
d1197 4
a1200 1
	consinit();	/* XXX SHOULD NOT BE DONE HERE */
a1206 4
#if 0
	uvmexp.ncolors = 2;
#endif
 
a1819 1
#include "com.h"
d1823 5
a1827 9
				if (major(cdp->consdev) == 8) {
					int unit = minor(cdp->consdev);
					/* ic/com.c */
					extern int comconsrate;
					extern int comconsaddr;

					if (unit >= 0 && unit <
					    (sizeof(ports) / sizeof(ports[0])))
						comconsaddr = ports[unit];
d1829 2
a1830 1
					comconsrate = cdp->conspeed;
@


1.72
log
@allow amd64 to use serial ports other than com0 as the console. previously
it was stuck to com0 no matter what the boot loader told the kernel.

this relies on the com diff jsing just committed.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.71 2008/04/12 12:49:28 kettenis Exp $	*/
d1818 1
a1818 1
				static const int comports[] =
d1820 9
a1828 8
				int unit = minor(cdp->consdev);
				/* ic/com.c */
				extern int comconsrate;
				extern int comconsaddr;

				if (unit >= 0 && unit < (sizeof(comports) /
				    sizeof(comports[0])))
					comconsaddr = comports[unit];
d1830 2
a1831 1
				comconsrate = cdp->conspeed;
@


1.71
log
@Get rid of acpi_s5 global variables; simply send SIGUSR2 instead of SUGUSR1
to tell init(8) to power down the machine.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.70 2008/04/09 16:58:10 deraadt Exp $	*/
d1813 1
a1813 2
			if (q->ba_size >= sizeof(bios_consdev_t))
			{
d1818 11
a1828 1
				extern int comconsrate; /* ic/com.c */
@


1.70
log
@Add new stub uvm_shutdown() and call it from the right place in MD boot()
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.70 2008/04/09 16:50:27 deraadt Exp $	*/
d793 1
a793 1
		extern int acpi_s5, acpi_enabled;
d797 1
a797 1
			if (howto & RB_POWERDOWN || acpi_s5)
@


1.69
log
@Fix amd64 and i386 serial console handling for non-default speeds. Bring
i386 pccom into line with com. Problem reported and first diff by Markus
Hennecke, who also tested and corrected subsequent diffs. Boot messages
and console now work with his 57K serial connections.

Suggestions and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.68 2008/03/17 23:17:24 deraadt Exp $	*/
d777 2
a778 2
	/* Disable interrupts. */
	splhigh();
@


1.68
log
@Clear PSL_D when entering signal handlers; pointed out by dfly people;
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.67 2007/12/11 17:53:18 deraadt Exp $	*/
d1819 2
a1820 2
				extern int comdefaultrate; /* ic/com.c */
				comdefaultrate = cdp->conspeed;
@


1.67
log
@if we pxebooted, and can find the interface, put it in a "pxeboot" group
so that later applications can try to do the right thing
for reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.66 2007/11/25 09:11:12 jsg Exp $	*/
d662 1
a662 1
	tf->tf_rflags &= ~(PSL_T|PSL_VM|PSL_AC);
@


1.66
log
@When available and ACPI is enabled use the ACPI reset method
to reboot.  This is required for some quirky sis machines
and likely others to reboot.

Tested by many. 'commit early commit often' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.65 2007/11/03 22:23:35 mikeb Exp $	*/
a223 1
#ifdef NFSCLIENT
a224 1
#endif
a1828 1
#ifdef NFSCLIENT
a1831 1
#endif                 
@


1.65
log
@Fix LKM support for amd64.

ok deraadt weingart
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.64 2007/10/31 15:55:46 deraadt Exp $	*/
d258 1
d1610 3
@


1.64
log
@for now, workaround MP timeout/splhigh/scsi race at reboot time using a
delay.  will be revisited.  ok art
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.63 2007/10/28 10:25:09 martin Exp $	*/
d179 6
d340 6
d1307 5
@


1.63
log
@get rid of btoc/ctob in favor of atop/ptoa
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.62 2007/10/17 02:30:26 deraadt Exp $	*/
d763 2
@


1.62
log
@replacement for the pctr codebase that can handle amd64 processors as
well (in fact, all 4 combinations of codebase and processor) written by
Mike Belopuhov and Aleksey Lomovtsev
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.61 2007/08/26 18:54:37 kettenis Exp $	*/
d301 1
a301 1
	if (physmem >= btoc(1ULL << 32)) {
@


1.61
log
@Use ptoa((psize_t)...) and %lu to print memory size.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.60 2007/08/02 16:40:27 deraadt Exp $	*/
d539 2
@


1.60
log
@copy nvram code from i386, because amd64 can use it too.  done by
tybollt@@solace.miun.se, ok jcs
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.59 2007/06/06 17:15:11 deraadt Exp $	*/
d298 2
a299 2
	printf("real mem = %u (%uMB)\n", ctob(physmem),
	    ctob(physmem)/1024/1024);
d334 2
a335 2
	printf("avail mem = %lu (%luMB)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free)/1024/1024);
@


1.59
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.58 2007/05/29 20:36:47 deraadt Exp $	*/
d130 1
@


1.58
log
@start of dumpconf() unification, which one day we can pray will be MI
(and part of setroot); ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.57 2007/05/26 20:26:50 pedro Exp $	*/
d818 1
a818 1
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
d911 2
a912 2
	daddr_t blkno;
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
@


1.57
log
@Dynamic buffer cache. Initial diff from mickey@@, okay art@@ beck@@ toby@@
deraadt@@ dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.56 2007/05/23 20:33:46 pvalchev Exp $	*/
a865 1
	const struct bdevsw *bdev;
d868 3
a870 9
	if (dumpdev == NODEV)
		goto bad;
	bdev = &bdevsw[major(dumpdev)];

	if (bdev == NULL)
		panic("dumpconf: bad dumpdev=0x%x", dumpdev);
	if (bdev->d_psize == NULL)
		goto bad;
	nblks = (*bdev->d_psize)(dumpdev);
d872 1
a872 1
		goto bad;
d876 1
a876 1
		goto bad;
d881 1
a881 1
		goto bad;
a887 4
	return;

 bad:
	dumpsize = 0;
@


1.56
log
@Print real/available memory in MB as well as bytes in dmesg, and unify
architectures to print it the same way.
ok henning, miod; i386 part from tom
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.55 2007/02/17 23:59:03 marco Exp $	*/
a180 6
#ifdef NBUF
int	nbuf = NBUF;
#else
int	nbuf = 0;
#endif

d245 1
a245 1
void	setup_buffers(vaddr_t *);
d316 1
a316 5
	/*
	 * Now allocate buffers proper. They are different than the above
	 * in that they usually occupy more virtual memory than physical.
	 */
	setup_buffers(&maxaddr);
a334 2
	printf("using %u buffers containing %u bytes (%uK) of memory\n",
	    nbuf, bufpages * PAGE_SIZE, bufpages * PAGE_SIZE / 1024);
a349 12

/*
 * The following defines are for the code in setup_buffers that tries to
 * ensure that enough ISA DMAable memory is still left after the buffercache
 * has been allocated.
 */
#define CHUNKSZ		(3 * 1024 * 1024)
#define ISADMA_LIMIT	(16 * 1024 * 1024)	/* XXX wrong place */
#define ALLOC_PGS(sz, limit, pgs) \
    uvm_pglistalloc((sz), 0, (limit), PAGE_SIZE, 0, &(pgs), 1, 0)
#define FREE_PGS(pgs) uvm_pglistfree(&(pgs))

a372 28
	/*
	 * Determine how many buffers to allocate.  We use 10% of the
	 * first 2MB of memory, and 10% of the rest, with a minimum of 16
	 * buffers.  We allocate 1/2 as many swap buffer headers as file
	 * i/o buffers.
	 */
	if (bufpages == 0) {
		bufpages = (btoc(2 * 1024 * 1024) + physmem) *
		    bufcachepercent / 100;
	}
	if (nbuf == 0) {
		nbuf = bufpages;
		if (nbuf < 16)
			nbuf = 16;
	}

	/* Restrict to at most 35% filled kvm */
	/* XXX - This needs UBC... */
	if (nbuf >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / MAXBSIZE * 35 / 100) 
		nbuf = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    MAXBSIZE * 35 / 100;

	/* More buffer pages than fits into the buffers is senseless.  */
	if (bufpages > nbuf * MAXBSIZE / PAGE_SIZE)
		bufpages = nbuf * MAXBSIZE / PAGE_SIZE;

	valloc(buf, struct buf, nbuf);
d377 1
a377 1
setup_buffers(vaddr_t *maxaddr)
a378 65
	vsize_t size;
	vaddr_t addr;
	int base, residual, left, chunk, i;
	struct pglist pgs, saved_pgs;
	struct vm_page *pg;
	int rv;

	size = MAXBSIZE * nbuf;
	addr = vm_map_min(kernel_map);
	if ((rv = uvm_map(kernel_map, &addr, round_page(size),
		    NULL, UVM_UNKNOWN_OFFSET, 0,
		    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
				UVM_ADV_NORMAL, 0))))
		panic("cpu_startup: cannot allocate VM for buffers %d", rv);
	buffers = (char *)addr;

	base = bufpages / nbuf;
	residual = bufpages % nbuf;
	if (base >= MAXBSIZE / PAGE_SIZE) {
		/* don't want to alloc more physical mem than needed */
		base = MAXBSIZE / PAGE_SIZE;
		residual = 0;
	}

	/*
	 * In case we might need DMA bouncing we have to make sure there
	 * is some memory below 16MB available.  On machines with many
	 * pages reserved for the buffer cache we risk filling all of that
	 * area with buffer pages.  We still want much of the buffers
	 * reside there as that lowers the probability of them needing to
	 * bounce, but we have to set aside some space for DMA buffers too.
	 *
	 * The current strategy is to grab hold of one 3MB chunk below 16MB
	 * first, which we are saving for DMA buffers, then try to get
	 * one chunk at a time for fs buffers, until that is not possible
	 * anymore, at which point we get the rest wherever we may find it.
	 * After that we give our saved area back. That will guarantee at
	 * least 3MB below 16MB left for drivers' attach routines, among
	 * them isadma.  However we still have a potential problem of PCI
	 * devices attached earlier snatching that memory.  This can be
	 * solved by making the PCI DMA memory allocation routines go for
	 * memory above 16MB first.
	 */

	left = bufpages;

	/*
	 * First, save ISA DMA bounce buffer area so we won't lose that
	 * capability.
	 */
	TAILQ_INIT(&saved_pgs);
	TAILQ_INIT(&pgs);
	if (!ALLOC_PGS(CHUNKSZ, ISADMA_LIMIT, saved_pgs)) {
		/*
		 * Then, grab as much ISA DMAable memory as possible
		 * for the buffer cache as it is nice to not need to
		 * bounce all buffer I/O.
		 */
		for (left = bufpages; left > 0; left -= chunk) {
			chunk = min(left, CHUNKSZ / PAGE_SIZE);
			if (ALLOC_PGS(chunk * PAGE_SIZE, ISADMA_LIMIT, pgs))
				break;
		}
	}

d380 2
a381 1
	 * If we need more pages for the buffer cache, get them from anywhere.
d383 2
a384 2
	if (left > 0 && ALLOC_PGS(left * PAGE_SIZE, avail_end, pgs))
		panic("cannot get physical memory for buffer cache");
d386 5
a390 25
	/*
	 * Finally, give back the ISA DMA bounce buffer area, so it can be
	 * allocated by the isadma driver later.
	 */
	if (!TAILQ_EMPTY(&saved_pgs))
		FREE_PGS(saved_pgs);

	pg = TAILQ_FIRST(&pgs);
	for (i = 0; i < nbuf; i++) {
		/*
		 * First <residual> buffers get (base+1) physical pages
		 * allocated for them.  The rest get (base) physical pages.
		 *
		 * The rest of each buffer occupies virtual space,
		 * but has no physical memory allocated for it.
		 */
		addr = (vaddr_t)buffers + i * MAXBSIZE;
		for (size = PAGE_SIZE * (i < residual ? base + 1 : base);
		    size > 0; size -= PAGE_SIZE, addr += PAGE_SIZE) {
			pmap_kenter_pa(addr, VM_PAGE_TO_PHYS(pg),
			    VM_PROT_READ|VM_PROT_WRITE);
			pg = TAILQ_NEXT(pg, pageq);
		}
	}
	pmap_update(pmap_kernel());
@


1.55
log
@Add SMALL_KERNEL throught acpi to make it fit on boot media.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.54 2007/02/01 20:42:17 art Exp $	*/
d303 2
a304 1
	printf("real mem = %u (%uK)\n", ctob(physmem), ctob(physmem)/1024);
d343 2
a344 2
	printf("avail mem = %lu (%luK)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free)/1024);
@


1.54
log
@When doing signotify, check if we're notifying a process on another
cpu and if we do, send it an IPI that will force to get into the kernel
and process the AST.

This makes signals to processes on other CPUs to be actually delivered
as soon as possible instead of some time in the future when some
interupt happens.

heavy testing by krw@@, miod@@ ok (in principle, since he doesn't do amd64)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.53 2007/01/15 23:19:05 jsg Exp $	*/
d911 1
a911 1
#if NACPI > 0
@


1.53
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.52 2006/11/07 09:09:42 otto Exp $	*/
d845 14
@


1.52
log
@Timecounters for amd64. Diff by art@@, tested by many. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.51 2006/10/01 10:52:10 kettenis Exp $	*/
d565 1
a565 2
x86_64_init_pcb_tss_ldt(ci)   
	struct cpu_info *ci;
d585 1
a585 2
bios_getdiskinfo(dev)
	dev_t dev;
d609 2
a610 8
bios_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
d647 2
a648 8
cpu_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
d937 1
a937 1
cpu_dump()
d985 1
a985 1
dumpconf()
d1039 1
a1039 1
dumpsys()
d1207 2
a1208 4
setgate(gd, func, ist, type, dpl, sel)
	struct gate_descriptor *gd;
	void *func;
	int ist, type, dpl, sel;
d1224 1
a1224 2
unsetgate(gd)
	struct gate_descriptor *gd;
d1230 1
a1230 4
setregion(rd, base, limit)
	struct region_descriptor *rd;
	void *base;
	u_int16_t limit;
d1240 2
a1241 5
set_mem_segment(sd, base, limit, type, dpl, gran, def32, is64)
	struct mem_segment_descriptor *sd;
	void *base;
	size_t limit;
	int type, dpl, gran, is64;
d1257 2
a1258 5
set_sys_segment(sd, base, limit, type, dpl, gran)
	struct sys_segment_descriptor *sd;
	void *base;
	size_t limit;
	int type, dpl, gran;
d1271 1
a1271 1
void cpu_init_idt()
d1291 1
a1291 2
init_x86_64(first_avail)
	paddr_t first_avail;
d1702 1
a1702 1
kgdb_port_init()
d1715 1
a1715 1
cpu_reset()
d1753 1
a1753 1
cpu_dumpsize()
d1769 1
a1769 1
cpu_dump_mempagecnt()
d1805 1
a1805 3
idt_vec_alloc(low, high)
	int low;
	int high;
d1822 1
a1822 3
idt_vec_set(vec, function)
	int vec;
	void (*function)(void);
d1833 1
a1833 2
idt_vec_free(vec)
	int vec;
@


1.51
log
@Switch fpu control word to the hardware default.  This makes us use 64-bit
precision instead of 53-bit precision, giving us proper support for
"long double".

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.50 2006/05/31 10:34:54 todd Exp $	*/
a206 1
void (*microtime_func)(struct timeval *) = i8254_microtime;
d1810 5
@


1.50
log
@do not call acpi_powerdown() unless acpi has successfully initialized
ok gwk@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.49 2006/05/27 04:46:12 gwk Exp $	*/
d1185 1
a1185 1
	pcb->pcb_savefpu.fp_fxsave.fx_fcw = __OpenBSD_NPXCW__;
@


1.49
log
@Teach powernow about setperf prioritys, add a setperf_prio to amd64.
ok uwe@@, "good" tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.48 2006/05/20 22:38:52 deraadt Exp $	*/
d913 1
a913 1
		extern int acpi_s5;
d915 5
a919 3
		delay(500000);
		if (howto & RB_POWERDOWN || acpi_s5)
			acpi_powerdown();
@


1.48
log
@handle BOOTARG_BOOTMAC from boot block; tested by reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.47 2006/03/15 21:03:37 deraadt Exp $	*/
d148 3
@


1.47
log
@use sysctl_int_lower() for the aperture variable.  This lets root close
the aperture without having to reboot, but does not allow re-opening;
ok matthieu
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.46 2006/03/09 17:24:00 weingart Exp $	*/
d221 4
d1960 5
@


1.46
log
@Typo fix from 'P-O Yliniemi <peo atsomehostlike bsd-guide.net>'
marco@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.45 2006/01/19 18:21:03 grange Exp $	*/
d695 2
a696 2
			return (sysctl_rdint(oldp, oldlenp, newp,
			    allowaperture));
@


1.45
log
@Fix NACPI > 1 (should be >0). Spotted by form@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.44 2006/01/06 10:53:16 grange Exp $	*/
d179 1
a179 1
int	nbuf = NUF;
@


1.44
log
@Err, commited from the wrong tree
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.43 2006/01/06 10:42:34 grange Exp $	*/
d141 1
a141 1
#if NACPI > 1
@


1.43
log
@Fix acpi includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.42 2005/12/16 23:00:03 marco Exp $	*/
a141 1
#include <dev/acpi/acpireg.h>
@


1.42
log
@Make amd64 powerdown logic identical to i386.

ok jordan@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.41 2005/12/13 00:18:19 jsg Exp $	*/
a129 1
#include <dev/acpi/acpivar.h>
d142 1
@


1.41
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.
Checked by ian@@, deraadt@@ and millert@@, arm portion checked by drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.40 2005/11/13 21:44:06 fgsch Exp $	*/
a136 1
#include "acpi.h"
d141 3
a143 2
#if NACPI > 0
extern struct acpi_softc *acpi_softc;
d146 1
a905 1
	        if (howto & RB_POWERDOWN) {
d907 5
a911 5
			if (acpi_softc) {
				delay(500000);
				acpi_enter_sleep_state(acpi_softc, ACPI_STATE_S5);
				printf("WARNING: powerdown failed!\n");
			}
a912 2
		}

@


1.40
log
@remove unused define.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.39 2005/11/13 17:51:52 fgsch Exp $	*/
d56 1
a56 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.39
log
@untested kgdb support for amd64. prolly needs more work when
getting and setting the registers, but it's a start. kettenis@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.38 2005/10/28 16:59:19 kettenis Exp $	*/
a166 2

#define	CPUID2MODEL(cpuid)	(((cpuid) >> 4) & 15)
@


1.38
log
@Use normal kernel stack for #BP exceptions.  Fixes PR 4562.
ok weingart@@, deraadt@@

Fix from myself, via NetBSD.  Duh!
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.37 2005/10/26 18:46:06 martin Exp $	*/
d258 22
d1727 14
@


1.37
log
@goodbye more Mach macros

help toby, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.36 2005/09/19 01:28:04 deraadt Exp $	*/
d1664 1
a1664 1
		ist = (x == 8 || x == 3) ? 1 : 0;
@


1.36
log
@floppy support; form@@openbsd.ru
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.35 2005/08/06 14:26:50 miod Exp $	*/
d1617 1
a1617 1
	    x86_btop(VM_MAXUSER_ADDRESS) - 1, SDT_MEMERA, SEL_UPL, 1, 0, 1);
d1620 1
a1620 1
	    x86_btop(VM_MAXUSER_ADDRESS) - 1, SDT_MEMRWA, SEL_UPL, 1, 0, 1);
d1637 1
a1637 1
	    x86_btop(VM_MAXUSER_ADDRESS) - 1, SDT_MEMERA, SEL_UPL, 1, 1, 0);
d1640 1
a1640 1
	    x86_btop(VM_MAXUSER_ADDRESS) - 1, SDT_MEMRWA, SEL_UPL, 1, 1, 0);
d1646 1
a1646 1
	set_mem_segment(ldt_segp, 0, x86_btop(VM_MAXUSER_ADDRESS32) - 1,
d1649 1
a1649 1
	set_mem_segment(ldt_segp, 0, x86_btop(VM_MAXUSER_ADDRESS32) - 1,
@


1.35
log
@We do not need a char machine_arch[] constant.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.34 2005/08/01 16:18:43 deraadt Exp $	*/
d1380 1
d1402 1
@


1.34
log
@enable amdgart if > 4GB of memory
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.33 2005/08/01 15:42:39 miod Exp $	*/
d151 1
a151 2
char machine[] = "amd64";		/* cpu "architecture" */
char machine_arch[] = "amd64";		/* machine == machine_arch */
@


1.33
log
@Kill more "memory might be 2MB or less" checks in bufpages computation.
ok deraadt@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.32 2005/07/26 08:38:29 art Exp $	*/
d283 6
@


1.32
log
@Instead of juggling around with cr4 and enabling parts of it sometimes,
other parts later, etc. Just set it to the same default value everywhere.
We won't survive without PSE and tt's not like someone will suddenly make
an amd64 that doesn't support PGE.

This will allow us to make the bootstrap process slightly more sane.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.31 2005/06/02 20:09:38 tholo Exp $	*/
d376 2
a377 5
		if (physmem < btoc(2 * 1024 * 1024))
			bufpages = physmem / 10;
		else
			bufpages = (btoc(2 * 1024 * 1024) + physmem) *
			    bufcachepercent / 100;
@


1.31
log
@Start on a basic ACPI framework -- does not do much more than read out the
ACPI tables into kernel memory and attach ACPI and HPET timers currently.

In order to test this code, enabling the devices in GENERIC as well as
the ACPI_ENABLE option is needed.  This code does not do any thermal
control yet, so this should be done with care depending on the platform.

In the tree so more people can contribute to making this more fully
featured.

Ok niklas@@ grange@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.30 2004/08/03 00:56:22 art Exp $	*/
a274 1
	int x;
d277 1
a277 13
	/*
	 * Initialize error message buffer (et end of core).
	 */
	msgbuf_vaddr = uvm_km_valloc(kernel_map, x86_round_page(MSGBUFSIZE));
	if (msgbuf_vaddr == 0)
		panic("failed to valloc msgbuf_vaddr");

	/* msgbuf_paddr was init'd in pmap */
	for (x = 0; x < btoc(MSGBUFSIZE); x++)
		pmap_kenter_pa((vaddr_t)msgbuf_vaddr + x * PAGE_SIZE,
		    msgbuf_paddr + x * PAGE_SIZE, VM_PROT_READ|VM_PROT_WRITE);
	pmap_update(pmap_kenel());

@


1.30
log
@Hehehe. Remove an #if 0 function that was used in the early days to debug
why vga scrolling wasn't working by sending beeps on the speaker.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.29 2004/07/19 15:09:05 art Exp $	*/
d134 1
d141 1
d146 4
d902 5
a906 3
			delay(500000);
			acpi_enter_sleep_state(acpi_softc, ACPI_STATE_S5);
			printf("WARNING: powerdown failed!\n");
@


1.29
log
@Implement __HAVE_PMAP_DIRECT on amd64 using large pages. At this moment
it's limited to 512GB (one L4 page table entry) physical memory. Only
used carefully at this moment, but more improvements are in the pipeline.

tested by many, deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.28 2004/07/08 04:23:04 david Exp $	*/
a1296 30

#if 0
void
beepme(int pitch, int duration)
{
#define IO_TIMER1       0x040
#define IO_PPI          0x061
#define              TIMER_SEL2      0x80
#define              TIMER_16BIT     0x30 
#define              TIMER_SQWAVE    0x06 
#define TIMER_CNTR2     (IO_TIMER1 + 2)
#define TIMER_MODE      (IO_TIMER1 + 3)
#define TIMER_FREQ      1193182
#define TIMER_DIV(x) ((TIMER_FREQ+(x)/2)/(x))

#define PIT_ENABLETMR2  0x01
#define PIT_SPKRDATA    0x02
#define PIT_SPKR        (PIT_ENABLETMR2|PIT_SPKRDATA)

#define PITCH 440

	outb(IO_TIMER1 + TIMER_MODE, TIMER_SEL2 | TIMER_16BIT | TIMER_SQWAVE);
	outb(IO_TIMER1 + TIMER_CNTR2, TIMER_DIV(pitch) % 256);
	outb(IO_TIMER1 + TIMER_CNTR2, TIMER_DIV(pitch) / 256);
	outb(IO_PPI, inb(IO_PPI) | PIT_SPKR);
	delay(duration / 2);
	outb(IO_PPI, inb(IO_PPI) & ~PIT_SPKR);
	delay(duration / 2);
}
#endif
@


1.28
log
@enclose some MP-only things in #ifdef MULTIPROCESSOR
ok deraadt@@ niklas@@; testing by pvalchev@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.27 2004/07/03 20:36:04 kettenis Exp $	*/
d1386 2
a1387 1
	pmap_bootstrap(VM_MIN_KERNEL_ADDRESS);
@


1.27
log
@Check return value instead of uninitialized variable.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.26 2004/06/25 11:03:27 art Exp $	*/
d546 1
d566 1
@


1.26
log
@SMP support. Big parts from NetBSD, but with some really serious debugging
done by me, niklas and others. Especially wrt. NXE support.

Still needs some polishing, especially in dmesg messages, but we're now
building kernel faster than ever.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.25 2004/06/22 01:16:50 art Exp $	*/
a1036 1
	int psize;
d1063 1
a1063 1
	if (psize == -1) {
@


1.25
log
@Switch amd64 to __HAVE_CPUINFO

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.24 2004/05/13 20:20:24 sturm Exp $	*/
d204 4
a1799 10
#if 0
extern void i8254_microtime(struct timeval *tv);

/*
 * XXXXXXX
 * the simulator's 8254 seems to travel backward in time sometimes?
 * work around this with this hideous code. Unacceptable for
 * real hardware, but this is just a patch to stop the weird
 * effects. SMP unsafe, etc.
 */
d1801 1
a1801 1
microtime(struct timeval *tv)
d1803 1
a1803 12
	static struct timeval mtv;

	i8254_microtime(tv);
	if (tv->tv_sec <= mtv.tv_sec && tv->tv_usec < mtv.tv_usec) {
		mtv.tv_usec++;
		if (mtv.tv_usec > 1000000) {
			mtv.tv_sec++;
			mtv.tv_usec = 0;
		}
		*tv = mtv;
	} else
		mtv = *tv;
a1804 1
#endif
@


1.24
log
@activate systrace on amd64, while here get rid of syscall_{plain,fancy}
instead use syscall() as everywhere else

ok mickey, tested and ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.23 2004/05/05 16:43:53 marc Exp $	*/
a1823 1
#ifdef MULTIPROCESSOR
a1830 1
#endif
@


1.23
log
@
write cpuhdr with info needed by libkvm to crash dumps.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.22 2004/03/11 21:06:01 deraadt Exp $	*/
a247 1
void	syscall_intern(struct proc *p);
a1157 2

	syscall_intern(p);
@


1.22
log
@we changed the default buffer cache size
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.21 2004/03/10 23:02:53 tom Exp $	*/
d129 1
d933 3
d941 3
d950 14
@


1.21
log
@Ensure that we obey a user's ddb> boot reboot command even if the system
is cold (during startup).

This adds RB_USERREQ to sys/reboot.h, uses it in the ddb commands, and
ensures that */*/machdep.c:boot() won't set RB_HALT when cold if this
flag is set.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.20 2004/03/09 23:06:38 deraadt Exp $	*/
d374 1
a374 1
	 * first 2MB of memory, and 5% of the rest, with a minimum of 16
@


1.20
log
@undo part from tom
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.19 2004/03/09 23:05:13 deraadt Exp $	*/
d846 6
a851 1
		howto |= RB_HALT;
@


1.19
log
@simplify the delay stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.18 2004/02/28 22:26:05 deraadt Exp $	*/
d846 1
a846 6
		/*
		 * If the system is cold, just halt, unless the user
		 * explicitly asked for reboot.
		 */
		if ((howto & RB_USERREQ) == 0)
			howto |= RB_HALT;
@


1.18
log
@rename our NPXCW setting
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.17 2004/02/27 23:45:23 deraadt Exp $	*/
a202 4
void (*delay_func)(int) = i8254_delay;
void (*microtime_func)(struct timeval *) = i8254_microtime;
void (*initclock_func)(void) = i8254_initclocks;

d846 6
a851 1
		howto |= RB_HALT;
a1804 6

void
cpu_initclocks()
{
	(*initclock_func)();
}
@


1.17
log
@remove old crud
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.16 2004/02/27 22:10:01 deraadt Exp $	*/
d1142 1
a1142 1
	pcb->pcb_savefpu.fp_fxsave.fx_fcw = __NetBSD_NPXCW__;
@


1.16
log
@more machdep sysctl support
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.15 2004/02/27 21:55:49 deraadt Exp $	*/
a145 2

int x86_64_ndisks = 0;
@


1.15
log
@permit 10% of memory as buffer cache
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.14 2004/02/27 21:55:25 deraadt Exp $	*/
d175 2
d668 11
@


1.14
log
@put a bit more flesh in the sysctl machdep; parts from tom
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.13 2004/02/27 17:41:25 deraadt Exp $	*/
d185 1
a185 1
#define BUFCACHEPERCENT 5
@


1.13
log
@move to amd64 MACHINE_ARCH
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.12 2004/02/25 00:16:04 deraadt Exp $	*/
d566 66
a647 4
	/* all sysctl names at this level are terminal */
	if (namelen != 1)
		return (ENOTDIR);		/* overloaded */

d650 2
d663 3
d667 2
@


1.12
log
@dkcsum stuff for amd64, written by tom, who cannot commit it at the moment.
now the amd64 knows what drive it was booted from.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.10 2004/02/24 00:20:45 mickey Exp $	*/
d145 1
a145 1
char machine_arch[] = "x86_64";		/* machine == machine_arch */
@


1.11
log
@support CPU_CHR2BLK sysctl
@
text
@d110 1
d126 1
d210 29
d1253 17
d1813 85
@


1.10
log
@repair kvm; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.9 2004/02/23 09:12:59 mickey Exp $	*/
d549 1
d563 5
a567 1

@


1.9
log
@the consdev pass from boot and a cnset() in the kernel seems to be a bit premature and cause problems
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.8 2004/02/23 01:19:52 tom Exp $	*/
d160 1
d1300 1
@


1.8
log
@- Pick up the /boot argc, argv in locore.S (though not currently used)
- Probe for console devices (incl serial) in /boot
- Pass console device from /boot to kernel (temp via additional param)

With this, boot> set tty com0 now works.

"just don't break a build" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.7 2004/02/21 03:00:23 deraadt Exp $	*/
a1215 10

	/*
	 * XXX /boot temporarily passes an extra parameter for the
	 *     console device.
	 */
	{
		extern dev_t boot_consdev;

		cnset(boot_consdev);
	}
@


1.7
log
@aperture stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.6 2004/02/19 18:48:44 deraadt Exp $	*/
d1216 10
@


1.6
log
@simplify rsp setting in sendsig
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.5 2004/02/13 03:37:10 mickey Exp $	*/
d221 8
d562 10
a571 12
#ifdef notyet
	case CPU_BOOTED_KERNEL:
	        bibp = lookup_bootinfo(BTINFO_BOOTPATH);
	        if(!bibp)
			return(ENOENT); /* ??? */
		return (sysctl_rdstring(oldp, oldlenp, newp, bibp->bootpath));
	case CPU_DISKINFO:
		if (x86_64_alldisks == NULL)
			return (ENOENT);
		return (sysctl_rdstruct(oldp, oldlenp, newp, x86_64_alldisks,
		    sizeof (struct disklist) +
			(x86_64_ndisks - 1) * sizeof (struct nativedisk_info)));
@


1.5
log
@save/restore fpu state around the signal handler. skip a gap on unempty stack per abi. form drahn@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.4 2004/02/13 00:05:52 mickey Exp $	*/
d656 1
a656 1
	tf->tf_rsp = sp - sss;
@


1.5.2.1
log
@The merge of these files were done to another date than the rest, fix.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a600 3
	if (p->p_md.md_flags & MDP_USEDFPU)
		fpusave_proc(p, 1);

d604 1
d612 1
a612 1
		sp = tf->tf_rsp;
d616 10
d691 9
d701 2
a702 1
	if (copyin((caddr_t)scp, &ksc, sizeof ksc))
@


1.5.2.2
log
@Merge with the trunk
@
text
@a109 1
#include <stand/boot/bootarg.h>
a124 1
#include <machine/biosvar.h>
a126 1
#include <machine/kcore.h>
d143 3
a145 1
char machine_arch[] = "amd64";		/* machine == machine_arch */
a159 1
vaddr_t kern_end;
a171 2
int kbd_reset;

d182 1
a182 1
#define BUFCACHEPERCENT 10
d200 4
a206 29
 * Format of boot information passed to us by 32-bit /boot
 */
typedef struct _boot_args32 {
	int	ba_type;
	int	ba_size;
	int	ba_nextX;	/* a ptr in 32-bit world, but not here */
	char	ba_arg[1];
} bootarg32_t;

#define BOOTARGC_MAX	NBPG	/* one page */

/* locore copies the arguments from /boot to here for us */
char bootinfo[BOOTARGC_MAX];
int bootinfo_size = BOOTARGC_MAX;

void getbootinfo(char *, int);

/* Data passed to us by /boot, filled in by getbootinfo() */
#if NAPM > 0 || defined(DEBUG)
bios_apminfo_t	*apm;
#endif
#if NPCI > 0
bios_pciinfo_t	*bios_pciinfo;
#endif
bios_diskinfo_t	*bios_diskinfo;
bios_memmap_t	*bios_memmap;
u_int32_t	bios_cksumlen;

/*
d219 1
a219 8

#ifdef APERTURE
#ifdef INSECURE
int allowaperture = 1;
#else
int allowaperture = 0;
#endif
#endif
d338 1
a338 1
	 * first 2MB of memory, and 10% of the rest, with a minimum of 16
a525 66
bios_diskinfo_t *
bios_getdiskinfo(dev)
	dev_t dev;
{
	bios_diskinfo_t *pdi;

	if (bios_diskinfo == NULL)
		return NULL;

	for (pdi = bios_diskinfo; pdi->bios_number != -1; pdi++) {
		if ((dev & B_MAGICMASK) == B_DEVMAGIC) { /* search by bootdev */
			if (pdi->bsd_dev == dev)
				break;
		} else {
			if (pdi->bios_number == dev)
				break;
		}
	}

	if (pdi->bios_number == -1)
		return NULL;
	else
		return pdi;
}

int
bios_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
{
	bios_diskinfo_t *pdi;
	extern dev_t bootdev;
	int biosdev;

	/* all sysctl names at this level except diskinfo are terminal */
	if (namelen != 1 && name[0] != BIOS_DISKINFO)
		return (ENOTDIR);	       /* overloaded */

	if (!(bootapiver & BAPIV_VECTOR))
		return EOPNOTSUPP;

	switch (name[0]) {
	case BIOS_DEV:
		if ((pdi = bios_getdiskinfo(bootdev)) == NULL)
			return ENXIO;
		biosdev = pdi->bios_number;
		return sysctl_rdint(oldp, oldlenp, newp, biosdev);
	case BIOS_DISKINFO:
		if (namelen != 2)
			return ENOTDIR;
		if ((pdi = bios_getdiskinfo(name[1])) == NULL)
			return ENXIO;
		return sysctl_rdstruct(oldp, oldlenp, newp, pdi, sizeof(*pdi));
	case BIOS_CKSUMLEN:
		return sysctl_rdint(oldp, oldlenp, newp, bios_cksumlen);
	default:
		return EOPNOTSUPP;
	}
	/* NOTREACHED */
}

d540 4
a543 1
	dev_t dev;
a546 2
		if (namelen != 1)
			return (ENOTDIR);		/* overloaded */
d553 13
a565 31
	case CPU_CHR2BLK:
		if (namelen != 2)
			return (ENOTDIR);		/* overloaded */
		dev = chrtoblk((dev_t)name[1]);
		return sysctl_rdstruct(oldp, oldlenp, newp, &dev, sizeof(dev));
	case CPU_BIOS:
		return bios_sysctl(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen, p);
	case CPU_CPUVENDOR:
		return (sysctl_rdstring(oldp, oldlenp, newp, cpu_vendor));
	case CPU_CPUFEATURE:
		return (sysctl_rdint(oldp, oldlenp, newp, cpu_feature));
	case CPU_KBDRESET:
		if (securelevel > 0)
			return (sysctl_rdint(oldp, oldlenp, newp,
			    kbd_reset));
		else
			return (sysctl_int(oldp, oldlenp, newp, newlen,
			    &kbd_reset));
	case CPU_ALLOWAPERTURE:
		if (namelen != 1)
			return (ENOTDIR);		/* overloaded */
#ifdef APERTURE
		if (securelevel > 0)
			return (sysctl_rdint(oldp, oldlenp, newp,
			    allowaperture));
		else
			return (sysctl_int(oldp, oldlenp, newp, newlen,
			    &allowaperture));
#else
		return (sysctl_rdint(oldp, oldlenp, newp, 0));
d601 3
a606 1
	ksc.sc_fpstate = NULL;
d614 1
a614 1
		sp = tf->tf_rsp - 128;
a617 10

	if (p->p_md.md_flags & MDP_USEDFPU) {
		fpusave_proc(p, 1);
		sp -= sizeof(struct fxsave64);
		ksc.sc_fpstate = (struct fxsave64 *)sp;
		if (copyout(&p->p_addr->u_pcb.pcb_savefpu.fp_fxsave,
		    (void *)sp, sizeof(struct fxsave64)))
			sigexit(p, SIGILL);
	}

d648 1
a648 1
	tf->tf_rsp = scp;
a682 6
	if ((error = copyin((caddr_t)scp, &ksc, sizeof ksc)))
		return (error);

	if (((ksc.sc_rflags ^ tf->tf_rflags) & PSL_USERSTATIC) != 0 ||
	    !USERMODE(ksc.sc_cs, ksc.sc_eflags))
		return (EINVAL);
d684 1
a684 5
	if (p->p_md.md_flags & MDP_USEDFPU)
		fpusave_proc(p, 0);

	if (ksc.sc_fpstate && (error = copyin(ksc.sc_fpstate,
	    &p->p_addr->u_pcb.pcb_savefpu.fp_fxsave, sizeof (struct fxsave64))))
d709 1
a709 6
		/*
		 * If the system is cold, just halt, unless the user
		 * explicitly asked for reboot.
		 */
		if ((howto & RB_USERREQ) == 0)
			howto |= RB_HALT;
a789 3
	cpu_kcore_hdr_t *cpuhdrp;
	phys_ram_seg_t *memsegp;
	int i;
a794 3
	cpuhdrp = (cpu_kcore_hdr_t *)&buf[ALIGN(sizeof(*segp))];
	memsegp = (phys_ram_seg_t *)&buf[ALIGN(sizeof(*segp)) +
	    ALIGN(sizeof(*cpuhdrp))];
a801 14
	/*
	 * Add the machine-dependent header info.
	 */
	cpuhdrp->ptdpaddr = PTDpaddr;
	cpuhdrp->nmemsegs = mem_cluster_cnt;

	/*
	 * Fill in the memory segment descriptors.
	 */
	for (i = 0; i < mem_cluster_cnt; i++) {
		memsegp[i].start = mem_clusters[i].start;
		memsegp[i].size = mem_clusters[i].size & ~PAGE_MASK;
	}

d997 2
d1001 1
a1001 1
	pcb->pcb_savefpu.fp_fxsave.fx_fcw = __OpenBSD_NPXCW__;
a1191 17
 
	/*
	 * Boot arguments are in a single page specified by /boot.
	 *
	 * We require the "new" vector form, as well as memory ranges
	 * to be given in bytes rather than KB.
	 *
	 * locore copies the data into bootinfo[] for us.
	 */
	if ((bootapiver & (BAPIV_VECTOR | BAPIV_BMEMMAP)) ==
	    (BAPIV_VECTOR | BAPIV_BMEMMAP)) {
		if (bootinfo_size >= sizeof(bootinfo))
			panic("boot args too big");

		getbootinfo(bootinfo, bootinfo_size);
	} else
		panic("invalid /boot");
a1274 1
	kern_end = KERNBASE + first_avail;
d1646 6
a1733 85

void
getbootinfo(char *bootinfo, int bootinfo_size)
{
	bootarg32_t *q;

#undef BOOTINFO_DEBUG
#ifdef BOOTINFO_DEBUG
	printf("bootargv:");
#endif

	for (q = (bootarg32_t *)bootinfo;
	    (q->ba_type != BOOTARG_END) &&
	    ((((char *)q) - bootinfo) < bootinfo_size);
	    q = (bootarg32_t *)(((char *)q) + q->ba_size)) {

		switch (q->ba_type) {
		case BOOTARG_MEMMAP:
			bios_memmap = (bios_memmap_t *)q->ba_arg;
#ifdef BOOTINFO_DEBUG
			printf(" memmap %p", bios_memmap);
#endif
			break;
		case BOOTARG_DISKINFO:
			bios_diskinfo = (bios_diskinfo_t *)q->ba_arg;
#ifdef BOOTINFO_DEBUG
			printf(" diskinfo %p", bios_diskinfo);
#endif
			break;
#if 0
#if NAPM > 0 || defined(DEBUG)
		case BOOTARG_APMINFO:
#ifdef BOOTINFO_DEBUG
			printf(" apminfo %p", q->ba_arg);
#endif
			apm = (bios_apminfo_t *)q->ba_arg;
			break;
#endif
#endif
		case BOOTARG_CKSUMLEN:
			bios_cksumlen = *(u_int32_t *)q->ba_arg;
#ifdef BOOTINFO_DEBUG
			printf(" cksumlen %d", bios_cksumlen);
#endif
			break;
#if 0
#if NPCI > 0
		case BOOTARG_PCIINFO:
			bios_pciinfo = (bios_pciinfo_t *)q->ba_arg;
#ifdef BOOTINFO_DEBUG
			printf(" pciinfo %p", bios_pciinfo);
#endif
			break;
#endif
#endif
		case BOOTARG_CONSDEV:
			if (q->ba_size >= sizeof(bios_consdev_t))
			{
				bios_consdev_t *cdp =
				    (bios_consdev_t*)q->ba_arg;
#include "com.h"
#if NCOM > 0
				extern int comdefaultrate; /* ic/com.c */
				comdefaultrate = cdp->conspeed;
#endif
#ifdef BOOTINFO_DEBUG
				printf(" console 0x%x:%d",
				    cdp->consdev, cdp->conspeed);
#endif
				cnset(cdp->consdev);
			}
			break;

		default:
#ifdef BOOTINFO_DEBUG
			printf(" unsupported arg (%d) %p", q->ba_type,
			    q->ba_arg);
#endif
			break;
		}
	}
#ifdef BOOTINFO_DEBUG
	printf("\n");
#endif
}
@


1.4
log
@on sigreturn check cs and rflags for evilness; from i386
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.3 2004/02/03 12:09:47 mickey Exp $	*/
a600 3
	if (p->p_md.md_flags & MDP_USEDFPU)
		fpusave_proc(p, 1);

d604 1
d612 1
a612 1
		sp = tf->tf_rsp;
d616 10
d691 1
a691 2

	if (copyin((caddr_t)scp, &ksc, sizeof ksc))
d697 7
@


1.3
log
@das boot; das cloned das from das i386
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.2 2004/01/29 13:21:10 mickey Exp $	*/
d686 4
@


1.2
log
@check struct reg for evil; from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.1 2004/01/28 01:39:39 mickey Exp $	*/
a122 1
#include <machine/bootinfo.h>
a144 3
char bootinfo[BOOTINFO_MAXSIZE];

struct bi_devmatch *x86_64_alldisks = NULL;
a539 1
	struct btinfo_bootpath *bibp;
d554 1
d566 1
a1173 4
#if !defined(REALEXTMEM) && !defined(REALBASEMEM)
	struct btinfo_memmap *bim;
	u_int64_t addr, size, io_end;
#endif
a1208 98
#if !defined(REALBASEMEM) && !defined(REALEXTMEM)

	/*
	 * Check to see if we have a memory map from the BIOS (passed
	 * to us by the boot program.
	 */
	bim = lookup_bootinfo(BTINFO_MEMMAP);
	if (bim != NULL && bim->num > 0) {
#if DEBUG_MEMLOAD
		printf("BIOS MEMORY MAP (%d ENTRIES):\n", bim->num);
#endif
		for (x = 0; x < bim->num; x++) {
			addr = bim->entry[x].addr;
			size = bim->entry[x].size;
#if DEBUG_MEMLOAD
			printf("    addr 0x%lx  size 0x%lx  type 0x%x\n",
			    addr, size, bim->entry[x].type);
#endif

			/*
			 * If the segment is not memory, skip it.
			 */
			switch (bim->entry[x].type) {
			case BIM_Memory:
			case BIM_ACPI:
			case BIM_NVS:
				break;
			default:
				continue;
			}

			seg_start = addr;
			seg_end = addr + size;

			if (seg_end > 0x100000000000ULL) {
				printf("WARNING: skipping large "
				    "memory map entry: "
				    "0x%lx/0x%lx/0x%x\n",
				    addr, size,
				    bim->entry[x].type);
				continue;
			}

			/*
			 * Allocate the physical addresses used by RAM
			 * from the iomem extent map.  This is done before
			 * the addresses are page rounded just to make
			 * sure we get them all.
			 */
			if (seg_start < 0x100000000UL) {
				if (seg_end > 0x100000000UL)
					io_end = 0x100000000UL;
				else
					io_end = seg_end;
				if (extent_alloc_region(iomem_ex, seg_start,
				    io_end - seg_start, EX_NOWAIT)) {
					/* XXX What should we do? */
					printf("WARNING: CAN'T ALLOCATE "
					    "MEMORY SEGMENT %d "
					    "(0x%lx/0x%lx/0l%x) FROM "
					    "IOMEM EXTENT MAP!\n",
					    x, seg_start, io_end - seg_start,
					    bim->entry[x].type);
				}
			}

			/*
			 * If it's not free memory, skip it.
			 */
			if (bim->entry[x].type != BIM_Memory)
				continue;

			/* XXX XXX XXX */
			if (mem_cluster_cnt >= VM_PHYSSEG_MAX)
				panic("init386: too many memory segments");

			seg_start = round_page(seg_start);
			seg_end = trunc_page(seg_end);

			if (seg_start == seg_end)
				continue;

			mem_clusters[mem_cluster_cnt].start = seg_start;
			mem_clusters[mem_cluster_cnt].size =
			    seg_end - seg_start;

			if (avail_end < seg_end)
				avail_end = seg_end;
			physmem += atop(mem_clusters[mem_cluster_cnt].size);
			mem_cluster_cnt++;
		}
	}
#endif	/* ! REALBASEMEM && ! REALEXTMEM */

	/*
	 * If the loop above didn't find any valid segment, fall back to
	 * former code.
	 */
d1529 2
a1530 14
	{
		extern caddr_t esym;
		struct btinfo_symtab *symtab;

		symtab = lookup_bootinfo(BTINFO_SYMTAB);
		if (symtab) {
			ssym = (char *)((vaddr_t)symtab->ssym + KERNBASE);
			esym = (caddr_t)((vaddr_t)symtab->esym + KERNBASE);
		}

		db_machine_init();
		ddb_init();
	}

a1550 24
}

void *
lookup_bootinfo(type)
	int type;
{
	struct btinfo_common *help;
	int n = *(int*)bootinfo;
	help = (struct btinfo_common *)(bootinfo + sizeof(int));
	while(n--) {
		if(help->type == type) {
#if 0
        		if (type == BTINFO_CONSOLE) {
				struct btinfo_console *consinfo = (struct btinfo_console *)help;
				snprintf(consinfo->devname, 16, "com");
			        consinfo->speed = 9600;
			        consinfo->addr = 0x3f8; 
			}
#endif
			return(help);
		}
		help = (struct btinfo_common *)((char*)help + help->len);
	}
	return(0);
@


1.1
log
@an amd64 arch support.
hacked by art@@ from netbsd sources and then later debugged
by me into the shape where it can host itself.
no bootloader yet as needs redoing from the
recent advanced i386 sources (anyone? ;)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d127 1
d1876 37
@

