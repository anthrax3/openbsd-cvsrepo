head	1.58;
access;
symbols
	OPENBSD_6_1:1.53.0.4
	OPENBSD_6_1_BASE:1.53
	OPENBSD_6_0:1.49.0.2
	OPENBSD_6_0_BASE:1.49
	OPENBSD_5_9:1.48.0.2
	OPENBSD_5_9_BASE:1.48
	OPENBSD_5_8:1.46.0.4
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.43.0.2
	OPENBSD_5_7_BASE:1.43
	OPENBSD_5_6:1.42.0.4
	OPENBSD_5_6_BASE:1.42
	OPENBSD_5_5:1.33.0.4
	OPENBSD_5_5_BASE:1.33
	OPENBSD_5_4:1.32.0.4
	OPENBSD_5_4_BASE:1.32
	OPENBSD_5_3:1.32.0.2
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.28.0.2
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.2
	OPENBSD_5_0:1.25.0.2
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.22.0.2
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.18.0.2
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.4
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.16.0.2
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.13.0.4
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.2
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.10.0.2
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.4
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.7.0.2
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.3.0.4
	OPENBSD_3_6_BASE:1.3
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	OPENBSD_3_5:1.3.0.2
	OPENBSD_3_5_BASE:1.3
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.58
date	2017.09.16.02.03.40;	author guenther;	state Exp;
branches;
next	1.57;
commitid	EtVx0z1Pdcy08AXO;

1.57
date	2017.08.25.19.28.48;	author guenther;	state Exp;
branches;
next	1.56;
commitid	pIA4jy9i3oGgdop6;

1.56
date	2017.07.20.18.22.25;	author bluhm;	state Exp;
branches;
next	1.55;
commitid	eXLHJ8oEZQtPpKri;

1.55
date	2017.07.14.12.20.32;	author bluhm;	state Exp;
branches;
next	1.54;
commitid	VFZshI1fA5zraDfQ;

1.54
date	2017.04.30.13.04.49;	author mpi;	state Exp;
branches;
next	1.53;
commitid	xDPbcPU6tYP39nZG;

1.53
date	2017.03.03.20.49.47;	author bluhm;	state Exp;
branches
	1.53.4.1;
next	1.52;
commitid	HvXIPFg1fj3hCUTx;

1.52
date	2017.01.21.05.42.03;	author guenther;	state Exp;
branches;
next	1.51;
commitid	CHRb0fCqa8XxUAMH;

1.51
date	2016.10.08.05.49.08;	author guenther;	state Exp;
branches;
next	1.50;
commitid	z63v1DilayzHcfkw;

1.50
date	2016.08.20.19.22.05;	author stefan;	state Exp;
branches;
next	1.49;
commitid	jtVba9Rgl4cEMtRx;

1.49
date	2016.02.27.13.08.06;	author mpi;	state Exp;
branches
	1.49.2.1;
next	1.48;
commitid	hnv9KfQtxhCytAnd;

1.48
date	2015.09.01.08.11.02;	author jsg;	state Exp;
branches;
next	1.47;
commitid	5TkleqZFmMfuHbNO;

1.47
date	2015.09.01.05.47.19;	author guenther;	state Exp;
branches;
next	1.46;
commitid	nqKgaCqoCvsPD1nQ;

1.46
date	2015.06.28.01.16.28;	author guenther;	state Exp;
branches;
next	1.45;
commitid	cOmfOzJx69tehqZa;

1.45
date	2015.04.18.05.14.05;	author guenther;	state Exp;
branches;
next	1.44;
commitid	omyqf8P2CTirfWNm;

1.44
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.43;
commitid	p4LJxGKbi0BU2cG6;

1.43
date	2014.11.16.12.30.56;	author deraadt;	state Exp;
branches;
next	1.42;
commitid	yv0ECmCdICvq576h;

1.42
date	2014.07.13.12.11.01;	author jasper;	state Exp;
branches;
next	1.41;
commitid	XHZxhpAa5R1Ymp1z;

1.41
date	2014.07.09.07.29.00;	author guenther;	state Exp;
branches;
next	1.40;
commitid	e4lHxUW3rh9EKH2Z;

1.40
date	2014.06.15.11.43.24;	author sf;	state Exp;
branches;
next	1.39;
commitid	Y0AWLKcfCeF28jP4;

1.39
date	2014.05.11.00.12.43;	author guenther;	state Exp;
branches;
next	1.38;

1.38
date	2014.05.10.05.33.00;	author guenther;	state Exp;
branches;
next	1.37;

1.37
date	2014.04.30.06.24.23;	author sf;	state Exp;
branches;
next	1.36;

1.36
date	2014.04.18.11.51.16;	author guenther;	state Exp;
branches;
next	1.35;

1.35
date	2014.03.30.21.54.48;	author guenther;	state Exp;
branches;
next	1.34;

1.34
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.33;

1.33
date	2014.02.13.23.11.06;	author kettenis;	state Exp;
branches;
next	1.32;

1.32
date	2012.12.31.06.46.13;	author guenther;	state Exp;
branches;
next	1.31;

1.31
date	2012.10.31.03.30.22;	author jsg;	state Exp;
branches;
next	1.30;

1.30
date	2012.10.09.04.40.36;	author jsg;	state Exp;
branches;
next	1.29;

1.29
date	2012.08.07.05.16.53;	author guenther;	state Exp;
branches;
next	1.28;

1.28
date	2012.04.11.14.38.55;	author mikeb;	state Exp;
branches;
next	1.27;

1.27
date	2011.11.16.20.50.18;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2011.11.14.15.06.14;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2011.07.11.15.40.47;	author guenther;	state Exp;
branches;
next	1.24;

1.24
date	2011.07.07.18.11.23;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2011.07.06.21.41.37;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2010.11.01.15.41.01;	author phessler;	state Exp;
branches;
next	1.21;

1.21
date	2010.11.01.15.37.03;	author phessler;	state Exp;
branches;
next	1.20;

1.20
date	2010.10.26.05.49.10;	author guenther;	state Exp;
branches;
next	1.19;

1.19
date	2010.09.28.03.53.14;	author guenther;	state Exp;
branches;
next	1.18;

1.18
date	2010.05.06.21.33.51;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2009.06.06.18.57.31;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2009.01.31.21.18.35;	author grange;	state Exp;
branches;
next	1.15;

1.15
date	2008.06.26.05.42.09;	author ray;	state Exp;
branches;
next	1.14;

1.14
date	2008.05.23.15.39.43;	author jasper;	state Exp;
branches;
next	1.13;

1.13
date	2007.05.11.10.06.55;	author pedro;	state Exp;
branches;
next	1.12;

1.12
date	2007.04.20.16.15.36;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2007.03.15.10.22.29;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2007.01.15.23.19.05;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2006.01.30.20.34.45;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2005.12.13.00.18.19;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2005.06.23.11.13.01;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2005.05.29.03.20.36;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2005.05.25.23.17.47;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	2004.12.06.20.12.23;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.23.08.32.36;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.20.22.35.12;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.28.01.39.39;	author mickey;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.06.05.23.09.24;	author niklas;	state Exp;
branches;
next	;

1.49.2.1
date	2017.08.26.00.15.05;	author bluhm;	state Exp;
branches;
next	;
commitid	EJSKXWVfg55NrgI5;

1.53.4.1
date	2017.08.26.00.14.20;	author bluhm;	state Exp;
branches;
next	;
commitid	ubjDaswy90l5VD3W;


desc
@@


1.58
log
@The copyin(9) family of functions should return EFAULT for all memory
protection issues.  So make amd64 do that instead of passing through
uvm_fault()'s return value, which lead to other possible errors
(particularly EACCES) being returned to userspace.  Clean up a vestige
on arm64 too.

ok bluhn@@ deraadt@@
@
text
@/*	$OpenBSD: trap.c,v 1.57 2017/08/25 19:28:48 guenther Exp $	*/
/*	$NetBSD: trap.c,v 1.2 2003/05/04 23:51:56 fvdl Exp $	*/

/*-
 * Copyright (c) 1998, 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Charles M. Hannum.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*-
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the University of Utah, and William Jolitz.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)trap.c	7.4 (Berkeley) 5/13/91
 */

/*
 * amd64 Trap and System call handling
 */
#undef	TRAP_SIGDEBUG

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/user.h>
#include <sys/acct.h>
#include <sys/kernel.h>
#include <sys/signal.h>
#include <sys/syscall.h>
#include <sys/syscall_mi.h>

#include <uvm/uvm_extern.h>

#include <machine/cpu.h>
#include <machine/cpufunc.h>
#include <machine/fpu.h>
#include <machine/psl.h>
#include <machine/trap.h>
#ifdef DDB
#include <machine/db_machdep.h>
#endif

#include "isa.h"

void trap(struct trapframe *);
void ast(struct trapframe *);
void syscall(struct trapframe *);

const char *trap_type[] = {
	"privileged instruction fault",		/*  0 T_PRIVINFLT */
	"breakpoint trap",			/*  1 T_BPTFLT */
	"arithmetic trap",			/*  2 T_ARITHTRAP */
	"reserved trap",			/*  3 T_RESERVED */
	"protection fault",			/*  4 T_PROTFLT */
	"trace trap",				/*  5 T_TRCTRAP */
	"page fault",				/*  6 T_PAGEFLT */
	"alignment fault",			/*  7 T_ALIGNFLT */
	"integer divide fault",			/*  8 T_DIVIDE */
	"non-maskable interrupt",		/*  9 T_NMI */
	"overflow trap",			/* 10 T_OFLOW */
	"bounds check fault",			/* 11 T_BOUND */
	"FPU not available fault",		/* 12 T_DNA */
	"double fault",				/* 13 T_DOUBLEFLT */
	"FPU operand fetch fault",		/* 14 T_FPOPFLT */
	"invalid TSS fault",			/* 15 T_TSSFLT */
	"segment not present fault",		/* 16 T_SEGNPFLT */
	"stack fault",				/* 17 T_STKFLT */
	"machine check",			/* 18 T_MCA */
	"SSE FP exception",			/* 19 T_XMM */
};
int	trap_types = nitems(trap_type);

#ifdef DEBUG
int	trapdebug = 0;
#endif

#define	IDTVEC(name)	__CONCAT(X, name)

#ifdef TRAP_SIGDEBUG
static void frame_dump(struct trapframe *);
#endif

/*
 * trap(frame):
 *	Exception, fault, and trap interface to BSD kernel. This
 * common code is called from assembly language IDT gate entry
 * routines that prepare a suitable stack frame, and restore this
 * frame after the exception has been processed.
 */
void
trap(struct trapframe *frame)
{
	struct proc *p = curproc;
	int type = (int)frame->tf_trapno;
	struct pcb *pcb;
	extern char doreti_iret[], resume_iret[];
	caddr_t onfault;
	int error;
	uint64_t cr2;
	union sigval sv;

	uvmexp.traps++;

	pcb = (p != NULL && p->p_addr != NULL) ? &p->p_addr->u_pcb : NULL;

#ifdef DEBUG
	if (trapdebug) {
		printf("trap %d code %llx rip %llx cs %llx rflags %llx "
		       "cr2 %llx cpl %x\n",
		    type, frame->tf_err, frame->tf_rip, frame->tf_cs,
		    frame->tf_rflags, rcr2(), curcpu()->ci_ilevel);
		printf("curproc %p\n", (void *)p);
		if (p != NULL)
			printf("pid %d\n", p->p_p->ps_pid);
	}
#endif
#ifdef DIAGNOSTIC
	if (curcpu()->ci_feature_sefflags_ebx & SEFF0EBX_SMAP) {
		u_long rf = read_rflags();
		if (rf & PSL_AC) {
			write_rflags(rf & ~PSL_AC);
			panic("%s: AC set on entry", "trap");
		}
	}
#endif

	if (!KERNELMODE(frame->tf_cs, frame->tf_rflags)) {
		type |= T_USER;
		p->p_md.md_regs = frame;
		refreshcreds(p);
	}

	switch (type) {

	default:
	we_re_toast:
#ifdef DDB
		if (db_ktrap(type, 0, frame))
			return;
#endif
		if (frame->tf_trapno < trap_types)
			printf("fatal %s", trap_type[frame->tf_trapno]);
		else
			printf("unknown trap %ld", (u_long)frame->tf_trapno);
		printf(" in %s mode\n", (type & T_USER) ? "user" : "supervisor");
		printf("trap type %d code %llx rip %llx cs %llx rflags %llx cr2 "
		       " %llx cpl %x rsp %llx\n",
		    type, frame->tf_err, frame->tf_rip, frame->tf_cs,
		    frame->tf_rflags, rcr2(), curcpu()->ci_ilevel, frame->tf_rsp);

		panic("trap type %d, code=%llx, pc=%llx",
		    type, frame->tf_err, frame->tf_rip);
		/*NOTREACHED*/

	case T_PROTFLT:
	case T_SEGNPFLT:
	case T_ALIGNFLT:
	case T_TSSFLT:
		if (p == NULL)
			goto we_re_toast;
		/* Check for copyin/copyout fault. */
		if (pcb->pcb_onfault != 0) {
copyfault:
			frame->tf_rip = (u_int64_t)pcb->pcb_onfault;
			return;
		}

		/*
		 * Check for failure during return to user mode.
		 * We do this by looking at the address of the
		 * instruction that faulted.
		 */
		if (frame->tf_rip == (u_int64_t)doreti_iret) {
			frame->tf_rip = (u_int64_t)resume_iret;
			return;
		}
		goto we_re_toast;

	case T_PROTFLT|T_USER:		/* protection fault */
	case T_TSSFLT|T_USER:
	case T_SEGNPFLT|T_USER:
	case T_STKFLT|T_USER:
#ifdef TRAP_SIGDEBUG
		printf("pid %d (%s): %s at rip %llx addr %llx\n",
		    p->p_p->ps_pid, p->p_p->ps_comm, "BUS",
		    frame->tf_rip, rcr2());
		frame_dump(frame);
#endif
		sv.sival_ptr = (void *)frame->tf_rip;
		KERNEL_LOCK();
		trapsignal(p, SIGBUS, type & ~T_USER, BUS_OBJERR, sv);
		KERNEL_UNLOCK();
		goto out;
	case T_ALIGNFLT|T_USER:
		sv.sival_ptr = (void *)frame->tf_rip;
		KERNEL_LOCK();
		trapsignal(p, SIGBUS, type & ~T_USER, BUS_ADRALN, sv);
		KERNEL_UNLOCK();
		goto out;

	case T_PRIVINFLT|T_USER:	/* privileged instruction fault */
		sv.sival_ptr = (void *)frame->tf_rip;
		KERNEL_LOCK();
		trapsignal(p, SIGILL, type & ~T_USER, ILL_PRVOPC, sv);
		KERNEL_UNLOCK();
		goto out;
	case T_FPOPFLT|T_USER:		/* coprocessor operand fault */
#ifdef TRAP_SIGDEBUG
		printf("pid %d (%s): %s at rip %llx addr %llx\n",
		    p->p_p->ps_pid, p->p_p->ps_comm, "ILL",
		    frame->tf_rip, rcr2());
		frame_dump(frame);
#endif
		sv.sival_ptr = (void *)frame->tf_rip;
		KERNEL_LOCK();
		trapsignal(p, SIGILL, type & ~T_USER, ILL_COPROC, sv);
		KERNEL_UNLOCK();
		goto out;
	case T_BOUND|T_USER:
		sv.sival_ptr = (void *)frame->tf_rip;
		KERNEL_LOCK();
		trapsignal(p, SIGFPE, type &~ T_USER, FPE_FLTSUB, sv);
		KERNEL_UNLOCK();
		goto out;
	case T_OFLOW|T_USER:
		sv.sival_ptr = (void *)frame->tf_rip;
		KERNEL_LOCK();
		trapsignal(p, SIGFPE, type &~ T_USER, FPE_INTOVF, sv);
		KERNEL_UNLOCK();
		goto out;
	case T_DIVIDE|T_USER:
		sv.sival_ptr = (void *)frame->tf_rip;
		KERNEL_LOCK();
		trapsignal(p, SIGFPE, type &~ T_USER, FPE_INTDIV, sv);
		KERNEL_UNLOCK();
		goto out;

	case T_ARITHTRAP|T_USER:
	case T_XMM|T_USER:
		fputrap(frame);
		goto out;

	case T_PAGEFLT:			/* allow page faults in kernel mode */
		if (p == NULL)
			goto we_re_toast;
		cr2 = rcr2();
		KERNEL_LOCK();
		/* This will only trigger if SMEP is enabled */
		if (cr2 <= VM_MAXUSER_ADDRESS && frame->tf_err & PGEX_I)
			panic("attempt to execute user address %p "
			    "in supervisor mode", (void *)cr2);
		/* This will only trigger if SMAP is enabled */
		if (pcb->pcb_onfault == NULL && cr2 <= VM_MAXUSER_ADDRESS &&
		    frame->tf_err & PGEX_P)
			panic("attempt to access user address %p "
			    "in supervisor mode", (void *)cr2);
		goto faultcommon;

	case T_PAGEFLT|T_USER: {	/* page fault */
		vaddr_t va, fa;
		struct vmspace *vm;
		struct vm_map *map;
		vm_prot_t ftype;
		extern struct vm_map *kernel_map;
		int signal, sicode;

		cr2 = rcr2();
		KERNEL_LOCK();
faultcommon:
		vm = p->p_vmspace;
		if (vm == NULL)
			goto we_re_toast;
		fa = cr2;
		va = trunc_page((vaddr_t)cr2);
		/*
		 * It is only a kernel address space fault iff:
		 *	1. (type & T_USER) == 0  and
		 *	2. pcb_onfault not set or
		 *	3. pcb_onfault set but supervisor space fault
		 * The last can occur during an exec() copyin where the
		 * argument space is lazy-allocated.
		 */
		if (type == T_PAGEFLT && va >= VM_MIN_KERNEL_ADDRESS)
			map = kernel_map;
		else
			map = &vm->vm_map;
		if (frame->tf_err & PGEX_W)
			ftype = PROT_WRITE;
		else if (frame->tf_err & PGEX_I)
			ftype = PROT_EXEC;
		else
			ftype = PROT_READ;

#ifdef DIAGNOSTIC
		if (map == kernel_map && va == 0) {
			printf("trap: bad kernel access at %lx\n", fa);
			goto we_re_toast;
		}
#endif

		if (curcpu()->ci_inatomic == 0 || map == kernel_map) {
			/* Fault the original page in. */
			onfault = pcb->pcb_onfault;
			pcb->pcb_onfault = NULL;
			error = uvm_fault(map, va, frame->tf_err & PGEX_P?
			    VM_FAULT_PROTECT : VM_FAULT_INVALID, ftype);
			pcb->pcb_onfault = onfault;
		} else
			error = EFAULT;

		if (error == 0) {
			if (map != kernel_map)
				uvm_grow(p, va);

			if (type == T_PAGEFLT) {
				KERNEL_UNLOCK();
				return;
			}
			KERNEL_UNLOCK();
			goto out;
		}

		if (type == T_PAGEFLT) {
			if (pcb->pcb_onfault != 0) {
				KERNEL_UNLOCK();
				goto copyfault;
			}
			printf("uvm_fault(%p, 0x%lx, 0, %d) -> %x\n",
			    map, fa, ftype, error);
			goto we_re_toast;
		}

		signal = SIGSEGV;
		sicode = SEGV_MAPERR;
		if (error == ENOMEM) {
			printf("UVM: pid %d (%s), uid %d killed:"
			    " out of swap\n", p->p_p->ps_pid, p->p_p->ps_comm,
			    p->p_ucred ? (int)p->p_ucred->cr_uid : -1);
			signal = SIGKILL;
		} else {
#ifdef TRAP_SIGDEBUG
			printf("pid %d (%s): %s at rip %llx addr %llx\n",
			    p->p_p->ps_pid, p->p_p->ps_comm, "SEGV",
			    frame->tf_rip, rcr2());
			frame_dump(frame);
#endif
		}
		if (error == EACCES)
			sicode = SEGV_ACCERR;
		if (error == EIO) {
			signal = SIGBUS;
			sicode = BUS_OBJERR;
		}
		sv.sival_ptr = (void *)fa;
		trapsignal(p, signal, T_PAGEFLT, sicode, sv);
		KERNEL_UNLOCK();
		break;
	}

	case T_TRCTRAP:
		goto we_re_toast;

	case T_BPTFLT|T_USER:		/* bpt instruction fault */
	case T_TRCTRAP|T_USER:		/* trace trap */
		sv.sival_ptr = (void *)frame->tf_rip;
		KERNEL_LOCK();
		trapsignal(p, SIGTRAP, type &~ T_USER, TRAP_BRKPT, sv);
		KERNEL_UNLOCK();
		break;

#if NISA > 0
	case T_NMI:
	case T_NMI|T_USER:
#ifdef DDB
		/* NMI can be hooked up to a pushbutton for debugging */
		printf ("NMI ... going to debugger\n");
		if (db_ktrap(type, 0, frame))
			return;
#endif
		/* machine/parity/power fail/"kitchen sink" faults */

		if (x86_nmi() != 0)
			goto we_re_toast;
		else
			return;
#endif /* NISA > 0 */
	}

	if ((type & T_USER) == 0)
		return;
out:
	userret(p);
}

#ifdef TRAP_SIGDEBUG
static void
frame_dump(struct trapframe *tf)
{
	printf("rip %p  rsp %p  rfl %p\n",
	    (void *)tf->tf_rip, (void *)tf->tf_rsp, (void *)tf->tf_rflags);
	printf("rdi %p  rsi %p  rdx %p\n",
	    (void *)tf->tf_rdi, (void *)tf->tf_rsi, (void *)tf->tf_rdx);
	printf("rcx %p  r8  %p  r9  %p\n",
	    (void *)tf->tf_rcx, (void *)tf->tf_r8, (void *)tf->tf_r9);
	printf("r10 %p  r11 %p  r12 %p\n",
	    (void *)tf->tf_r10, (void *)tf->tf_r11, (void *)tf->tf_r12);
	printf("r13 %p  r14 %p  r15 %p\n",
	    (void *)tf->tf_r13, (void *)tf->tf_r14, (void *)tf->tf_r15);
	printf("rbp %p  rbx %p  rax %p\n",
	    (void *)tf->tf_rbp, (void *)tf->tf_rbx, (void *)tf->tf_rax);
}
#endif


/*
 * ast(frame):
 *	AST handler.  This is called from assembly language stubs when
 *	returning to userspace after a syscall or interrupt.
 */
void
ast(struct trapframe *frame)
{
	struct proc *p = curproc;

	uvmexp.traps++;
	KASSERT(!KERNELMODE(frame->tf_cs, frame->tf_rflags));
	p->p_md.md_regs = frame;
	refreshcreds(p);
	uvmexp.softs++;
	mi_ast(p, curcpu()->ci_want_resched);
	userret(p);
}


/*
 * syscall(frame):
 *	System call request from POSIX system call gate interface to kernel.
 */
void
syscall(struct trapframe *frame)
{
	caddr_t params;
	const struct sysent *callp;
	struct proc *p;
	int error;
	int nsys;
	size_t argsize, argoff;
	register_t code, args[9], rval[2], *argp;

#ifdef DIAGNOSTIC
	if (curcpu()->ci_feature_sefflags_ebx & SEFF0EBX_SMAP) {
		u_long rf = read_rflags();
		if (rf & PSL_AC) {
			write_rflags(rf & ~PSL_AC);
			panic("%s: AC set on entry", "syscall");
		}
	}
#endif

	uvmexp.syscalls++;
	p = curproc;

	code = frame->tf_rax;
	callp = p->p_p->ps_emul->e_sysent;
	nsys = p->p_p->ps_emul->e_nsysent;
	argp = &args[0];
	argoff = 0;

	switch (code) {
	case SYS_syscall:
	case SYS___syscall:
		/*
		 * Code is first argument, followed by actual args.
		 */
		code = frame->tf_rdi;
		argp = &args[1];
		argoff = 1;
		break;
	default:
		break;
	}

	if (code < 0 || code >= nsys)
		callp += p->p_p->ps_emul->e_nosys;
	else
		callp += code;

	argsize = (callp->sy_argsize >> 3) + argoff;
	if (argsize) {
		switch (MIN(argsize, 6)) {
		case 6:
			args[5] = frame->tf_r9;
		case 5:
			args[4] = frame->tf_r8;
		case 4:
			args[3] = frame->tf_r10;
		case 3:
			args[2] = frame->tf_rdx;
		case 2:	
			args[1] = frame->tf_rsi;
		case 1:
			args[0] = frame->tf_rdi;
			break;
		default:
			panic("impossible syscall argsize");
		}
		if (argsize > 6) {
			argsize -= 6;
			params = (caddr_t)frame->tf_rsp + sizeof(register_t);
			if ((error = copyin(params, &args[6], argsize << 3)))
				goto bad;
		}
	}

	rval[0] = 0;
	rval[1] = frame->tf_rdx;

	error = mi_syscall(p, code, callp, argp, rval);

	switch (error) {
	case 0:
		frame->tf_rax = rval[0];
		frame->tf_rdx = rval[1];
		frame->tf_rflags &= ~PSL_C;	/* carry bit */
		break;
	case ERESTART:
		/* Back up over the syscall instruction (2 bytes) */
		frame->tf_rip -= 2;
		break;
	case EJUSTRETURN:
		/* nothing to do */
		break;
	default:
	bad:
		frame->tf_rax = error;
		frame->tf_rflags |= PSL_C;	/* carry bit */
		break;
	}

	mi_syscall_return(p, code, error, rval);
}

void
child_return(void *arg)
{
	struct proc *p = arg;
	struct trapframe *tf = p->p_md.md_regs;

	tf->tf_rax = 0;
	tf->tf_rdx = 1;
	tf->tf_rflags &= ~PSL_C;

	KERNEL_UNLOCK();

	mi_child_return(p);
}

@


1.57
log
@If SMAP is present, clear PSL_AC on kernel entry and interrupt so that
only the code in copy{in,out}* that need it run with it set.  Panic if
it's set on entry to trap() or syscall().  Prompted by Maxime Villard's
NetBSD work.

ok kettenis@@ mlarkin@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.56 2017/07/20 18:22:25 bluhm Exp $	*/
a213 1
			error = EFAULT;
a215 1
			frame->tf_rax = error;
@


1.56
log
@Accessing a mmap(2)ed file behind its end should result in a SIGBUS
according to POSIX.  Bring regression test and kernel in line for
amd64 and i386.  Other architectures have to follow.
OK deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.55 2017/07/14 12:20:32 bluhm Exp $	*/
d168 9
d502 10
@


1.55
log
@The regress test src/regress/sys/kern/siginfo-fault checks whether
the si_code is SEGV_ACCERR after memory access with wrong permissions
has triggert a SIGSEGV.  Adapt the behavior of i386 and amd64 kernel.
Remove the useless code that changed error from EACCES to EFAULT
in amd64.  Also convert variable name rv to errno in i386 to make
it look like amd64.
OK kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.54 2017/04/30 13:04:49 mpi Exp $	*/
d309 1
d376 3
d383 1
a383 2
			sv.sival_ptr = (void *)fa;
			trapsignal(p, SIGKILL, T_PAGEFLT, SEGV_MAPERR, sv);
a390 3
			sv.sival_ptr = (void *)fa;
			trapsignal(p, SIGSEGV, T_PAGEFLT,
			    error == EACCES ? SEGV_ACCERR : SEGV_MAPERR, sv);
d392 8
@


1.54
log
@Unifdef KGDB.

It doesn't compile und hasn't been working during the last decade.

ok kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.53 2017/03/03 20:49:47 bluhm Exp $	*/
a364 3
		if (error == EACCES) {
			error = EFAULT;
		}
d389 2
a390 1
			trapsignal(p, SIGSEGV, T_PAGEFLT, SEGV_MAPERR, sv);
@


1.53
log
@Whan an amd64 machine got an NMI, the current process in user land
was killed with SIGBUS.  Better drop to ddb regardless wether a
user process is currently scheduled or not.  NMI signals hardware
failure or a debug button.  The code in i386 trap() has always been
that way.  The switch in db_ktrap() must also not depend on the
fact wether kernel or user land is running.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.52 2017/01/21 05:42:03 guenther Exp $	*/
a95 4
#ifdef KGDB
#include <sys/kgdb.h>
#endif

a178 14
#ifdef KGDB
		if (kgdb_trap(type, frame))
			return;
		else {
			/*
			 * If this is a breakpoint, don't panic
			 * if we're not connected.
			 */
			if (type == T_BPTFLT) {
				printf("kgdb: ignored %s\n", trap_type[type]);
				return;
			}
		}
#endif
d412 1
a412 1
#if defined(KGDB) || defined(DDB)
a414 6
#ifdef KGDB

		if (kgdb_trap(type, frame))
			return;
#endif
#ifdef DDB
a417 1
#endif /* KGDB || DDB */
@


1.53.4.1
log
@If SMAP is present, clear PSL_AC on kernel entry and interrupt so that
only the code in copy{in,out}* that need it run with it set.  Panic if
it's set on entry to trap() or syscall().  Prompted by Maxime Villard's
NetBSD work.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.53 2017/03/03 20:49:47 bluhm Exp $	*/
a171 9
#ifdef DIAGNOSTIC
	if (curcpu()->ci_feature_sefflags_ebx & SEFF0EBX_SMAP) {
		u_long rf = read_rflags();
		if (rf & PSL_AC) {
			write_rflags(rf & ~PSL_AC);
			panic("%s: AC set on entry", "trap");
		}
	}
#endif
a511 10

#ifdef DIAGNOSTIC
	if (curcpu()->ci_feature_sefflags_ebx & SEFF0EBX_SMAP) {
		u_long rf = read_rflags();
		if (rf & PSL_AC) {
			write_rflags(rf & ~PSL_AC);
			panic("%s: AC set on entry", "syscall");
		}
	}
#endif
@


1.52
log
@p_comm is the process's command and isn't per thread, so move it from
struct proc to struct process.

ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.51 2016/10/08 05:49:08 guenther Exp $	*/
a244 1
	case T_NMI|T_USER:
d427 1
a427 1
#if	NISA > 0
d429 1
@


1.51
log
@Various printf claim to report the PID, so actually report that and not the TID

Build testing assistance from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.50 2016/08/20 19:22:05 stefan Exp $	*/
d248 2
a249 1
		    p->p_p->ps_pid, p->p_comm, "BUS", frame->tf_rip, rcr2());
d273 2
a274 1
		    p->p_p->ps_pid, p->p_comm, "ILL", frame->tf_rip, rcr2());
d399 1
a399 1
			    " out of swap\n", p->p_p->ps_pid, p->p_comm,
d406 2
a407 2
			    p->p_p->ps_pid, p->p_comm, "SEGV", frame->tf_rip,
			    rcr2());
@


1.50
log
@Format string fixes in debug code: need %llx to print 64 bit values

ok kettenis@@ deraadt@@ mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.49 2016/02/27 13:08:06 mpi Exp $	*/
d167 3
a169 3
		printf("curproc %p\n", curproc);
		if (curproc)
			printf("pid %d\n", p->p_pid);
d247 2
a248 2
		printf("pid %d (%s): BUS at rip %llx addr %llx\n",
		    p->p_pid, p->p_comm, frame->tf_rip, rcr2());
d271 2
a272 2
		printf("pid %d (%s): ILL at rip %llx addr %llx\n",
		    p->p_pid, p->p_comm, frame->tf_rip, rcr2());
d396 3
a398 3
			printf("UVM: pid %d (%s), uid %d killed: out of swap\n",
			       p->p_pid, p->p_comm,
			       p->p_ucred ?  (int)p->p_ucred->cr_uid : -1);
d403 3
a405 2
			printf("pid %d (%s): SEGV at rip %llx addr %lx\n",
			    p->p_pid, p->p_comm, frame->tf_rip, fa);
@


1.49
log
@Rename kdb_trap() into db_ktrap().

The goal is to include it in the list of functions that must not be
instrumented.  All ddb(8) functions should be in this list and have
their names start with 'db_'.

ok visa@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.48 2015/09/01 08:11:02 jsg Exp $	*/
d247 1
a247 1
		printf("pid %d (%s): BUS at rip %lx addr %lx\n",
d271 1
a271 1
		printf("pid %d (%s): ILL at rip %lx addr %lx\n",
d403 1
a403 1
			printf("pid %d (%s): SEGV at rip %lx addr %lx\n",
@


1.49.2.1
log
@If SMAP is present, clear PSL_AC on kernel entry and interrupt so that
only the code in copy{in,out}* that need it run with it set.  Panic if
it's set on entry to trap() or syscall().  Prompted by Maxime Villard's
NetBSD work.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.49 2016/02/27 13:08:06 mpi Exp $	*/
a171 9
#ifdef DIAGNOSTIC
	if (curcpu()->ci_feature_sefflags_ebx & SEFF0EBX_SMAP) {
		u_long rf = read_rflags();
		if (rf & PSL_AC) {
			write_rflags(rf & ~PSL_AC);
			panic("%s: AC set on entry", "trap");
		}
	}
#endif
a508 10

#ifdef DIAGNOSTIC
	if (curcpu()->ci_feature_sefflags_ebx & SEFF0EBX_SMAP) {
		u_long rf = read_rflags();
		if (rf & PSL_AC) {
			write_rflags(rf & ~PSL_AC);
			panic("%s: AC set on entry", "syscall");
		}
	}
#endif
@


1.48
log
@set sival_ptr before calling trapsignal() for user breakpoint/trace traps
ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.47 2015/09/01 05:47:19 guenther Exp $	*/
d198 1
a198 1
		if (kdb_trap(type, 0, frame))
d436 1
a436 1
		if (kdb_trap(type, 0, frame))
@


1.47
log
@Delete bogus MATH_EMULATE holdover from i386
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.46 2015/06/28 01:16:28 guenther Exp $	*/
d419 1
@


1.46
log
@Split AST handling from trap() into ast() and get rid of T_ASTFLT.
Don't skip the AST check when returning from *fork() in the child.
Make sure to count interrupts even when they're deferred or stray.

testing by krw@@, and then many via snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.45 2015/04/18 05:14:05 guenther Exp $	*/
a418 3
#ifdef MATH_EMULATE
	trace:
#endif
@


1.45
log
@i386 and amd64 have only one syscall entry point now, so simply the
EIP/RIP adjustment for ERESTART

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.44 2015/03/14 03:38:46 jsg Exp $	*/
d101 1
d108 1
a108 1
	"asynchronous system trap",		/*  3 T_ASTFLT */
a124 1
	"reserved trap",			/* 20 T_RESERVED */
a144 1
/*ARGSUSED*/
a279 6

	case T_ASTFLT|T_USER:		/* Allow process switch */
		uvmexp.softs++;
		mi_ast(p, curcpu()->ci_want_resched);
		goto out;

d475 21
@


1.44
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.43 2014/11/16 12:30:56 deraadt Exp $	*/
d565 2
a566 6
		/*
		 * The offset to adjust the PC by depends on whether we entered
		 * the kernel through the trap or call gate.  We pushed the
		 * size of the instruction into tf_err on entry.
		 */
		frame->tf_rip -= frame->tf_err;
@


1.43
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.42 2014/07/13 12:11:01 jasper Exp $	*/
a88 1
#include <machine/reg.h>
@


1.42
log
@use nitems() instead of handrolling something identical

ok mpi@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.41 2014/07/09 07:29:00 guenther Exp $	*/
d356 1
a356 1
			ftype = VM_PROT_WRITE;
d358 1
a358 1
			ftype = VM_PROT_EXECUTE;
d360 1
a360 1
			ftype = VM_PROT_READ;
@


1.41
log
@Fix boot -d.  refreshcreds() should be called when trapping from userspace,
but I flipped the test on i386/amd64, thus breaking kernel traps before
enough proc0 bits were set up.  In theory, this could have resulted in
a NFS read for a page fault being done with a process's old credentials.

pointed out by Patrick Wildt of bitrig
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.40 2014/06/15 11:43:24 sf Exp $	*/
d127 1
a127 1
int	trap_types = sizeof trap_type / sizeof trap_type[0];
@


1.40
log
@Fix a few format string bugs with -DDEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.39 2014/05/11 00:12:43 guenther Exp $	*/
a177 1
	} else /* if (type != T_NMI) */
d179 1
@


1.39
log
@Move the increment of uvmexp.softs back to the caller of mi_ast():
it needs to be done atomicly on some MP archs and we don't have
atomic_add_int() everywhere yet.  Also, mi_ast() was meant to be inline.

noted by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.38 2014/05/10 05:33:00 guenther Exp $	*/
d165 2
a166 2
		printf("trap %d code %lx rip %lx cs %lx rflags %lx cr2 %lx "
		       "cpl %x\n",
@


1.38
log
@Factor out the common ast bits into mi_ast()

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.37 2014/04/30 06:24:23 sf Exp $	*/
d284 1
@


1.37
log
@format string fixes for (u)int64 vars

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.36 2014/04/18 11:51:16 guenther Exp $	*/
d284 1
a284 9
		uvmexp.softs++;
		if (p->p_flag & P_OWEUPC) {
			KERNEL_LOCK();
			ADDUPROF(p);
			KERNEL_UNLOCK();
		}
		/* Allow a forced task switch. */
		if (curcpu()->ci_want_resched)
			preempt(NULL);
@


1.36
log
@Have each thread keeps its own (counted!) reference to the process's ucreds
to avoid possible use-after-free references when swapping ids in threaded
processes.  "Do I have the right creds?" checks are always made with the
threads creds.

Inspired by FreeBSD and NetBSD
"right time" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.35 2014/03/30 21:54:48 guenther Exp $	*/
d208 3
a210 3
		printf("trap type %d code %lx rip %lx cs %lx rflags %lx cr2 "
		       " %lx cpl %x rsp %lx\n",
		    type, frame->tf_err, (u_long)frame->tf_rip, frame->tf_cs,
d213 1
a213 1
		panic("trap type %d, code=%lx, pc=%lx",
@


1.35
log
@Eliminates struct pcred by moving the real and saved ugids into
struct ucred; struct process then directly links to the ucred

Based on a discussion at c2k10 or so before noting that FreeBSD and
NetBSD did this too.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.34 2014/03/26 05:23:42 guenther Exp $	*/
d178 2
a179 1
	}
@


1.34
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.33 2014/02/13 23:11:06 kettenis Exp $	*/
d412 1
a412 2
			       p->p_cred && p->p_ucred ?
			       (int)p->p_ucred->cr_uid : -1);
@


1.33
log
@Some Linux i915 drm "fast" path code relies on being able to "disable" page
faults to avoid sleeping.  Implement this functionality for i386 and amd64
for faults in the user address space.  If the ci_inatomic flag is set in
struct cpu_info, copyin(9) and copyout(9) will return EFAULT when a user-space
address needs to be faulted in.  Use this to properly implement
__copy_to_user_inatomic() and __copy_from_user_inatomic_nocache() in the
inteldrm(4) code.

ok krw@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.32 2012/12/31 06:46:13 guenther Exp $	*/
d510 2
a511 2
	callp = p->p_emul->e_sysent;
	nsys = p->p_emul->e_nsysent;
d530 1
a530 1
		callp += p->p_emul->e_nosys;
@


1.32
log
@Remove emulation errno mapping code from platforms that no longer have
non-native emulations.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.31 2012/10/31 03:30:22 jsg Exp $	*/
d375 10
a384 6
		/* Fault the original page in. */
		onfault = pcb->pcb_onfault;
		pcb->pcb_onfault = NULL;
		error = uvm_fault(map, va, frame->tf_err & PGEX_P?
		    VM_FAULT_PROTECT : VM_FAULT_INVALID, ftype);
		pcb->pcb_onfault = onfault;
@


1.31
log
@Add support for Intel's Supervisor Mode Access Prevention (SMAP) feature.
When enabled SMAP will generate page faults on the kernel attempting
to read/write user data pages unless an override flag is set.

Instructions that modify the flag are patched into copyin/copyout and
friends on boot if SMAP is enabled.

Those with access to hardware with SMAP can contact me for a test case.

joint work with deraadt@@

ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.30 2012/10/09 04:40:36 jsg Exp $	*/
d370 1
a370 1
			printf("trap: bad kernel access at %lx\n", va);
d402 1
a402 1
			    map, va, ftype, error);
d415 1
a415 1
			    p->p_pid, p->p_comm, frame->tf_rip, va);
@


1.30
log
@Enable Supervisor Mode Execution Protection (SMEP), found in recent
Intel chips.  If the kernel is tricked into running code from a user
page while in supervisor mode we'll now get a page fault and panic
instead of running it.

suggestions and ok guenther@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.29 2012/08/07 05:16:53 guenther Exp $	*/
d326 5
@


1.29
log
@Move the common bits of syscall invocation and return handling into
an MI file, <sys/syscall_mi.h>, correcting inconsistencies and the
handling when copyin() of arguments fails.

Tested on i386, amd64, sparc64, and alpha (thanks naddy@@)
Any issues with other platforms will be fixed in tree.

header name from millert@@; ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.28 2012/04/11 14:38:55 mikeb Exp $	*/
d323 4
@


1.28
log
@The first ktrace record for a newly spawned thread is a return
from a fork syscall done by the parent.  Use __tfork, not rfork
here to match the ktrace records for the parent (CALL __tfork,
RET __tfork).  ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.27 2011/11/16 20:50:18 deraadt Exp $	*/
a79 3
#ifdef KTRACE
#include <sys/ktrace.h>
#endif
d81 1
a81 3

#include "systrace.h"
#include <dev/systrace.h>
a491 1
	int lock;
d543 1
a543 3
			error = copyin(params, (caddr_t)&args[6],
					argsize << 3);
			if (error != 0)
a547 14
	lock = !(callp->sy_flags & SY_NOLOCK);

#ifdef SYSCALL_DEBUG
	KERNEL_LOCK();
	scdebug_call(p, code, argp);
	KERNEL_UNLOCK();
#endif
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSCALL)) {
		KERNEL_LOCK();
		ktrsyscall(p, code, callp->sy_argsize, argp);
		KERNEL_UNLOCK();
	}
#endif
d550 3
a552 14
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE)) {
		KERNEL_LOCK();
		error = systrace_redirect(code, p, argp, rval);
		KERNEL_UNLOCK();
	} else
#endif
	{
		if (lock)
			KERNEL_LOCK();
		error = (*callp->sy_call)(p, argp, rval);
		if (lock)
			KERNEL_UNLOCK();
	}
d577 1
a577 13
#ifdef SYSCALL_DEBUG
	KERNEL_LOCK();
	scdebug_ret(p, code, error, rval);
	KERNEL_UNLOCK();
#endif
	userret(p);
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET)) {
		KERNEL_LOCK();
		ktrsysret(p, code, error, rval[0]);
		KERNEL_UNLOCK();
	}
#endif
d592 1
a592 11
	userret(p);
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET)) {
		KERNEL_LOCK();
		ktrsysret(p,
		    (p->p_flag & P_THREAD) ? SYS___tfork :
		    (p->p_p->ps_flags & PS_PPWAIT) ? SYS_vfork : SYS_fork,
		    0, 0);
		KERNEL_UNLOCK();
	}
#endif
d594 1
@


1.27
log
@Make userret() MI.  On architectures which jammed stuff into it in the
past, pull that code out seperately.
ok guenther miod
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.26 2011/11/14 15:06:14 deraadt Exp $	*/
d642 1
a642 1
		    (p->p_flag & P_THREAD) ? SYS_rfork :
@


1.26
log
@merge syscall.c into the end of trap.c as almost all architectures do.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.25 2011/07/11 15:40:47 guenther Exp $	*/
a95 1
#include <machine/userret.h>
@


1.25
log
@Revert art@@'s moving around of the KERNEL_LOCK()/KERNEL_UNLOCK() calls,
as it causes hangs in some ports, including libsigsegv's configure script

confirmed by krw@@, landry@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.23 2011/07/06 21:41:37 art Exp $	*/
d75 1
d80 3
d84 3
a86 2
#include <sys/reboot.h>
#include <sys/pool.h>
d108 1
d483 167
@


1.24
log
@There is a bunch of places in the kernel entry points where we don't
hold the kernel lock, but still need call one function that needs it.

Instead of grabbing the lock all over the place, move the locks into
the affected functions: trapsignal, scdebug*, ktrsyscall, ktrsysret,
systrace_redirect and ADDUPROF. In the cases we already hold the biglock
we'll just recurse.

kettenis@@, beck@@ ok
@
text
@d253 1
d255 1
d259 1
d261 1
d266 1
d268 1
d277 1
d279 1
d285 1
d287 1
d296 1
d298 1
d302 1
d304 1
d308 1
d310 1
d424 1
d426 1
@


1.23
log
@Clean up after P_BIGLOCK removal.
KERNEL_PROC_LOCK -> KERNEL_LOCK
KERNEL_PROC_UNLOCK -> KERNEL_UNLOCK

oga@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.22 2010/11/01 15:41:01 phessler Exp $	*/
a252 1
		KERNEL_LOCK();
a253 1
		KERNEL_UNLOCK();
a256 1
		KERNEL_LOCK();
a257 1
		KERNEL_UNLOCK();
a261 1
		KERNEL_LOCK();
a262 1
		KERNEL_UNLOCK();
a270 1
		KERNEL_LOCK();
a271 1
		KERNEL_UNLOCK();
a276 1
			KERNEL_LOCK();
a277 1
			KERNEL_UNLOCK();
a285 1
		KERNEL_LOCK();
a286 1
		KERNEL_UNLOCK();
a289 1
		KERNEL_LOCK();
a290 1
		KERNEL_UNLOCK();
a293 1
		KERNEL_LOCK();
a294 1
		KERNEL_UNLOCK();
a407 1
		KERNEL_LOCK();
a408 1
		KERNEL_UNLOCK();
@


1.22
log
@use the amd64 name for this frame, instead of the i386 name, to be
consistent with the rest of the file.

requested to be a seperate commit by kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.21 2010/11/01 15:37:03 phessler Exp $	*/
d253 1
a253 1
		KERNEL_PROC_LOCK(p);
d255 1
a255 1
		KERNEL_PROC_UNLOCK(p);
d259 1
a259 1
		KERNEL_PROC_LOCK(p);
d261 1
a261 1
		KERNEL_PROC_UNLOCK(p);
d266 1
a266 1
		KERNEL_PROC_LOCK(p);
d268 1
a268 1
		KERNEL_PROC_UNLOCK(p);
d277 1
a277 1
		KERNEL_PROC_LOCK(p);
d279 1
a279 1
		KERNEL_PROC_UNLOCK(p);
d285 1
a285 1
			KERNEL_PROC_LOCK(p);
d287 1
a287 1
			KERNEL_PROC_UNLOCK(p);
d296 1
a296 1
		KERNEL_PROC_LOCK(p);
d298 1
a298 1
		KERNEL_PROC_UNLOCK(p);
d302 1
a302 1
		KERNEL_PROC_LOCK(p);
d304 1
a304 1
		KERNEL_PROC_UNLOCK(p);
d308 1
a308 1
		KERNEL_PROC_LOCK(p);
d310 1
a310 1
		KERNEL_PROC_UNLOCK(p);
d333 1
a333 1
		KERNEL_PROC_LOCK(p);
d380 1
a380 1
			KERNEL_PROC_UNLOCK(p);
d412 1
a412 4
		if (type == T_PAGEFLT)
			KERNEL_UNLOCK();
		else
			KERNEL_PROC_UNLOCK(p);
d424 1
a424 1
		KERNEL_PROC_LOCK(p);
d426 1
a426 1
		KERNEL_PROC_UNLOCK(p);
@


1.21
log
@convert a trap that ends up in 'we_re_toast' from a boot(RB_HALT) into a
real panic.  this brings amd64 inline with all of the other arches.

OK kettenis@@, mikeb@@, krw@@, guenther@@, thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.20 2010/10/26 05:49:10 guenther Exp $	*/
d165 1
a165 1
		printf("trap %d code %lx eip %lx cs %lx rflags %lx cr2 %lx "
@


1.20
log
@The LDT is only used by dead compat code now, so load the ldt
register with the null selector (disabling use of it), stop reloading
it on every context switch, and blow away the table itself, as well
as the pcb and pmap bits that were used to track it.  Also, delete
two other unused pcb members: pcb_usersp and pcb_flags.  (Deleting
pcb_usersp also keeps the pcb_savefpu member aligned properly.)
Finally, delete the defines for the unimplemented AMD64_{GET,SET}_LDT
sysarch() calls.

Tested by various with both AMD and Intel chips
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.19 2010/09/28 03:53:14 guenther Exp $	*/
d212 2
a213 2
		/* panic("trap"); */
		boot(RB_HALT);
@


1.19
log
@Correct the handling of GS.base when iretq faults: the fault happens
with CPL == 0 but the user's GS.base, so the normal INTRENTRY handling
won't work.  Contrawise, the asm that trap() redirects us to when that
happens (resume_iret) sees a trapframe showing CPL==3 but it's run with
the kernel's GS.base, so INTRENTRY won't work there either.

asm style fixes drahn@@ and mikeb@@
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.18 2010/05/06 21:33:51 nicm Exp $	*/
d153 1
a153 4
	extern char doreti_iret[], resume_iret[], IDTVEC(oosyscall)[];
#if 0
	extern char resume_pop_ds[], resume_pop_es[];
#endif
a419 7
		/* Check whether they single-stepped into a lcall. */
		if (frame->tf_rip == (register_t)IDTVEC(oosyscall))
			return;
		if (frame->tf_rip == (register_t)IDTVEC(oosyscall) + 1) {
			frame->tf_rflags &= ~PSL_T;
			return;
		}
@


1.18
log
@Change trap() and syscall() to accept a pointer rather than using call
by reference for the trap frame, the infrastructure in locore.S for this
was already present.

This prevents gcc4 from optimising away stores into the frame and allows
a gcc4-compiled kernel to boot.

ok kettenis robert guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.17 2009/06/06 18:57:31 art Exp $	*/
d153 1
a153 1
	extern char resume_iret[], IDTVEC(oosyscall)[];
a156 2
	struct trapframe *vframe;
	void *resume;
d236 2
a237 14
		 *
		 * XXXfvdl check for rex prefix?
		 *
		 * We do this by looking at the instruction we faulted on.  The
		 * specific instructions we recognize only happen when
		 * returning from a trap, syscall, or interrupt.
		 *
		 * XXX
		 * The heuristic used here will currently fail for the case of
		 * one of the 2 pop instructions faulting when returning from a
		 * a fast interrupt.  This should not be possible.  It can be
		 * fixed by rearranging the trap frame so that the stack format
		 * at this point is the same as on exit from a `slow'
		 * interrupt.
d239 3
a241 7
		switch (*(u_char *)frame->tf_rip) {
		case 0xcf:	/* iret */
			vframe = (void *)((u_int64_t)&frame->tf_rsp - 44);
			resume = resume_iret;
			break;
		default:
			goto we_re_toast;
d243 1
a243 5
		if (KERNELMODE(vframe->tf_cs, vframe->tf_rflags))
			goto we_re_toast;

		frame->tf_rip = (u_int64_t)resume;
		return;
@


1.17
log
@When getting a fault in the kernel, we checked for biglock and failed
immediately when biglock wasn't held. But there is nothing inherently
wrong with doing copyin/copyout faults without holding biglock, so
just remove the check because it prevent us from doing copyin in
syscall before we grab the biglock.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.16 2009/01/31 21:18:35 grange Exp $	*/
d102 1
a102 1
void trap(struct trapframe);
d144 1
a144 2
 * frame after the exception has been processed. Note that the
 * effect is as if the arguments were passed call by reference.
d148 1
a148 1
trap(struct trapframe frame)
d151 1
a151 1
	int type = (int)frame.tf_trapno;
d172 2
a173 2
		    type, frame.tf_err, frame.tf_rip, frame.tf_cs,
		    frame.tf_rflags, rcr2(), curcpu()->ci_ilevel);
d180 1
a180 1
	if (!KERNELMODE(frame.tf_cs, frame.tf_rflags)) {
d182 1
a182 1
		p->p_md.md_regs = &frame;
d190 1
a190 1
		if (kgdb_trap(type, &frame))
d204 1
a204 1
		if (kdb_trap(type, 0, &frame))
d207 2
a208 2
		if (frame.tf_trapno < trap_types)
			printf("fatal %s", trap_type[frame.tf_trapno]);
d210 1
a210 1
			printf("unknown trap %ld", (u_long)frame.tf_trapno);
d214 2
a215 2
		    type, frame.tf_err, (u_long)frame.tf_rip, frame.tf_cs,
		    frame.tf_rflags, rcr2(), curcpu()->ci_ilevel, frame.tf_rsp);
d231 2
a232 2
			frame.tf_rip = (u_int64_t)pcb->pcb_onfault;
			frame.tf_rax = error;
d253 1
a253 1
		switch (*(u_char *)frame.tf_rip) {
d255 1
a255 1
			vframe = (void *)((u_int64_t)&frame.tf_rsp - 44);
d264 1
a264 1
		frame.tf_rip = (u_int64_t)resume;
d274 2
a275 2
		    p->p_pid, p->p_comm, frame.tf_rip, rcr2());
		frame_dump(&frame);
d277 1
a277 1
		sv.sival_ptr = (void *)frame.tf_rip;
d283 1
a283 1
		sv.sival_ptr = (void *)frame.tf_rip;
d290 1
a290 1
		sv.sival_ptr = (void *)frame.tf_rip;
d298 2
a299 2
		    p->p_pid, p->p_comm, frame.tf_rip, rcr2());
		frame_dump(&frame);
d301 1
a301 1
		sv.sival_ptr = (void *)frame.tf_rip;
d320 1
a320 1
		sv.sival_ptr = (void *)frame.tf_rip;
d326 1
a326 1
		sv.sival_ptr = (void *)frame.tf_rip;
d332 1
a332 1
		sv.sival_ptr = (void *)frame.tf_rip;
d340 1
a340 1
		fputrap(&frame);
d377 1
a377 1
		if (frame.tf_err & PGEX_W)
d379 1
a379 1
		else if (frame.tf_err & PGEX_I)
d394 1
a394 1
		error = uvm_fault(map, va, frame.tf_err & PGEX_P?
d431 2
a432 2
			    p->p_pid, p->p_comm, frame.tf_rip, va);
			frame_dump(&frame);
d446 1
a446 1
		if (frame.tf_rip == (register_t)IDTVEC(oosyscall))
d448 2
a449 2
		if (frame.tf_rip == (register_t)IDTVEC(oosyscall) + 1) {
			frame.tf_rflags &= ~PSL_T;
d471 1
a471 1
		if (kgdb_trap(type, &frame))
d475 1
a475 1
		if (kdb_trap(type, 0, &frame))
@


1.16
log
@Don't cast pointer to int, use register_t here.

ok miod@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.15 2008/06/26 05:42:09 ray Exp $	*/
a346 4
#ifdef MULTIPROCESSOR
		if ((p->p_flag & P_BIGLOCK) == 0)
			goto we_re_toast;
#endif
@


1.15
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.14 2008/05/23 15:39:43 jasper Exp $	*/
d451 1
a451 1
		if (frame.tf_rip == (int)IDTVEC(oosyscall))
d453 1
a453 1
		if (frame.tf_rip == (int)IDTVEC(oosyscall) + 1) {
@


1.14
log
@- remove USER_LDT, it was never in a state where it would copile, nor will
we support i386-compat mode on amd64.

agreed by beck@@, dlg@@, kettenis@@
ok deraadt@@, tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.13 2007/05/11 10:06:55 pedro Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.13
log
@Don't use LK_CANRECURSE for the kernel lock, okay miod@@ art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.12 2007/04/20 16:15:36 miod Exp $	*/
a265 16
/*
 * XXXfvdl these are illegal in long mode (not in compat mode, though)
 * and we do not take back the descriptors from the signal context anyway,
 * but may do so later for USER_LDT, in which case we need to intercept
 * other instructions (movl %eax, %Xs).
 */
#if 0
		case 0x1f:	/* popl %ds */
			vframe = (void *)((u_int64_t)&frame.tf_rsp - 4);
			resume = resume_pop_ds;
			break;
		case 0x07:	/* popl %es */
			vframe = (void *)((u_int64_t)&frame.tf_rsp - 0);
			resume = resume_pop_es;
			break;
#endif
@


1.12
log
@Remove leftover trapwrite() prototype from... 80386 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.11 2007/03/15 10:22:29 art Exp $	*/
d375 1
a375 1
		KERNEL_LOCK(LK_CANRECURSE|LK_EXCLUSIVE);
@


1.11
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.10 2007/01/15 23:19:05 jsg Exp $	*/
a109 3
#if defined(I386_CPU)
int trapwrite(unsigned);
#endif
@


1.10
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.9 2006/01/30 20:34:45 kettenis Exp $	*/
a336 1
			p->p_flag &= ~P_OWEUPC;
@


1.9
log
@Remove dead code; we should never see T_DNA here.
ok weingart@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.8 2005/12/13 00:18:19 jsg Exp $	*/
d159 1
a159 2
trap(frame)
	struct trapframe frame;
@


1.8
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.
Checked by ian@@, deraadt@@ and millert@@, arm portion checked by drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.7 2005/06/23 11:13:01 art Exp $	*/
a346 10

	case T_DNA|T_USER: {
		printf("pid %d killed due to lack of floating point\n",
		    p->p_pid);
		sv.sival_ptr = (void *)frame.tf_rip;
		KERNEL_PROC_LOCK(p);
		trapsignal(p, SIGKILL, type &~ T_USER, FPE_FLTINV, sv);
		KERNEL_PROC_UNLOCK(p);
		goto out;
	}
@


1.7
log
@Dead code.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.5 2005/05/25 23:17:47 niklas Exp $	*/
d55 1
a55 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.6
log
@sched work by niklas and art backed out; causes panics
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.4 2004/12/06 20:12:23 miod Exp $	*/
a388 4
#ifdef LOCKDEBUG
		if (simple_lock_held(&sched_lock))
			goto we_re_toast;
#endif
@


1.5
log
@This patch is mortly art's work and was done *a year* ago.  Art wants to thank
everyone for the prompt review and ok of this work ;-)  Yeah, that includes me
too, or maybe especially me.  I am sorry.

Change the sched_lock to a mutex. This fixes, among other things, the infamous
"telnet localhost &" problem.  The real bug in that case was that the sched_lock
which is by design a non-recursive lock, was recursively acquired, and not
enough releases made us hold the lock in the idle loop, blocking scheduling
on the other processors.  Some of the other processors would hold the biglock though,
which made it impossible for cpu 0 to enter the kernel...  A nice deadlock.
Let me just say debugging this for days just to realize that it was all fixed
in an old diff noone ever ok'd was somewhat of an anti-climax.

This diff also changes splsched to be correct for all our architectures.
@
text
@d389 4
@


1.4
log
@Use uvm_grow() to account for stack growth, rather than home-grown code
or nothing.
Inspired by a similar recent change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.3 2004/02/23 08:32:36 mickey Exp $	*/
a388 4
#ifdef LOCKDEBUG
		if (simple_lock_held(&sched_lock))
			goto we_re_toast;
#endif
@


1.3
log
@get use of NX; partially from netbsd; passes the regress; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.2 2004/02/20 22:35:12 deraadt Exp $	*/
a406 1
		unsigned long nss;
a441 19
		nss = 0;
		if ((caddr_t)va >= vm->vm_maxsaddr
		    && (caddr_t)va < (caddr_t)VM_MAXUSER_ADDRESS
		    && map != kernel_map) {
			nss = btoc(USRSTACK-(unsigned long)va);
			if (nss > (u_long)btoc(p->p_rlimit[RLIMIT_STACK].rlim_cur)) {
				/*
				 * We used to fail here. However, it may
				 * just have been an mmap()ed page low
				 * in the stack, which is legal. If it
				 * wasn't, uvm_fault() will fail below.
				 *
				 * Set nss to 0, since this case is not
				 * a "stack extension".
				 */
				nss = 0;
			}
		}

d449 2
a450 2
			if (nss > (u_long)vm->vm_ssize)
				vm->vm_ssize = nss;
@


1.2
log
@turn off TRAP_SIGDEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.1 2004/01/28 01:39:39 mickey Exp $	*/
d431 2
d465 2
a466 1
		error = uvm_fault(map, va, 0, ftype);
@


1.1
log
@an amd64 arch support.
hacked by art@@ from netbsd sources and then later debugged
by me into the shape where it can host itself.
no bootloader yet as needs redoing from the
recent advanced i386 sources (anyone? ;)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d81 1
a81 1
#define	TRAP_SIGDEBUG
@


1.1.2.1
log
@Merge with the trunk
@
text
@d81 1
a81 1
#undef	TRAP_SIGDEBUG
a430 2
		else if (frame.tf_err & PGEX_I)
			ftype = VM_PROT_EXECUTE;
d463 1
a463 2
		error = uvm_fault(map, va, frame.tf_err & PGEX_P?
		    VM_FAULT_PROTECT : VM_FAULT_INVALID, ftype);
@


