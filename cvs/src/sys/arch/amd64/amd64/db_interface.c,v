head	1.26;
access;
symbols
	OPENBSD_6_1:1.26.0.4
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.25.0.2
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.23.0.4
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.17.0.8
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.6
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.2
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.16.0.12
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.10
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.8
	OPENBSD_5_0:1.16.0.6
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.4
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.2
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.15.0.4
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.6
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.2
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.13.0.4
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.11.0.4
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.2
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.6.0.4
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.5.0.2
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	OPENBSD_3_5:1.1.0.4
	OPENBSD_3_5_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.26
date	2017.03.03.20.49.47;	author bluhm;	state Exp;
branches;
next	1.25;
commitid	HvXIPFg1fj3hCUTx;

1.25
date	2016.03.14.23.08.05;	author krw;	state Exp;
branches;
next	1.24;
commitid	kCz5QgxnxRMKOzNf;

1.24
date	2016.02.27.13.08.06;	author mpi;	state Exp;
branches;
next	1.23;
commitid	hnv9KfQtxhCytAnd;

1.23
date	2015.05.18.19.59.27;	author guenther;	state Exp;
branches;
next	1.22;
commitid	MLFvGCnCMKMdmAtY;

1.22
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.21;
commitid	p4LJxGKbi0BU2cG6;

1.21
date	2014.10.15.15.55.42;	author uebayasi;	state Exp;
branches;
next	1.20;
commitid	TYm1otpEdh4UZ0Fg;

1.20
date	2014.10.15.15.54.47;	author uebayasi;	state Exp;
branches;
next	1.19;
commitid	qGBPOsdY9lLbZPJQ;

1.19
date	2014.10.15.13.36.45;	author uebayasi;	state Exp;
branches;
next	1.18;
commitid	nEnw3N0aAm748ksu;

1.18
date	2014.09.14.14.17.23;	author jsg;	state Exp;
branches;
next	1.17;
commitid	uzzBR7hz9ncd4O6G;

1.17
date	2013.05.12.20.47.44;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2010.04.01.19.47.59;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2008.10.03.21.57.25;	author weingart;	state Exp;
branches;
next	1.14;

1.14
date	2008.10.03.17.07.53;	author weingart;	state Exp;
branches;
next	1.13;

1.13
date	2007.11.16.16.16.07;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2007.11.14.17.52.35;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2007.01.15.23.19.05;	author jsg;	state Exp;
branches;
next	1.10;

1.10
date	2006.10.24.19.03.10;	author marco;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.08.21.04.57;	author marco;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.07.23.15.02;	author marco;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.05.14.46.45;	author marco;	state Exp;
branches;
next	1.6;

1.6
date	2005.12.05.21.31.23;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2005.03.31.02.53.48;	author tedu;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.02.20.45.42;	author andreas;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.22.11.15.00;	author art;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.25.17.27.01;	author andreas;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.28.01.39.38;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Whan an amd64 machine got an NMI, the current process in user land
was killed with SIGBUS.  Better drop to ddb regardless wether a
user process is currently scheduled or not.  NMI signals hardware
failure or a debug button.  The code in i386 trap() has always been
that way.  The switch in db_ktrap() must also not depend on the
fact wether kernel or user land is running.
OK deraadt@@
@
text
@/*	$OpenBSD: db_interface.c,v 1.25 2016/03/14 23:08:05 krw Exp $	*/
/*	$NetBSD: db_interface.c,v 1.1 2003/04/26 18:39:27 fvdl Exp $	*/

/*
 * Mach Operating System
 * Copyright (c) 1991,1990 Carnegie Mellon University
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 *
 *	db_interface.c,v 2.4 1991/02/05 17:11:13 mrt (CMU)
 */

/*
 * Interface to new debugger.
 */

#include <sys/param.h>
#include <sys/reboot.h>
#include <sys/systm.h>

#include <uvm/uvm_extern.h>

#include <dev/cons.h>

#include <machine/cpufunc.h>
#include <machine/db_machdep.h>
#include <machine/cpuvar.h>
#include <machine/i82093var.h>
#include <machine/i82489reg.h>
#include <machine/atomic.h>

#include <ddb/db_sym.h>
#include <ddb/db_command.h>
#include <ddb/db_extern.h>
#include <ddb/db_output.h>
#include <ddb/db_run.h>
#include <ddb/db_var.h>

#include "acpi.h"
#if NACPI > 0
#include <dev/acpi/acpidebug.h>
#endif /* NACPI > 0 */

#include "wsdisplay.h"
#if NWSDISPLAY > 0
#include <dev/wscons/wsdisplayvar.h>
#endif

extern label_t *db_recover;
extern char *trap_type[];
extern int trap_types;

#ifdef MULTIPROCESSOR
struct mutex ddb_mp_mutex = MUTEX_INITIALIZER(IPL_HIGH);
volatile int ddb_state = DDB_STATE_NOT_RUNNING;
volatile cpuid_t ddb_active_cpu;
boolean_t	 db_switch_cpu;
long		 db_switch_to_cpu;
#endif

int	db_active;
db_regs_t ddb_regs;

void db_printtrap(int, int);
#ifdef MULTIPROCESSOR
void db_cpuinfo_cmd(db_expr_t, int, db_expr_t, char *);
void db_startproc_cmd(db_expr_t, int, db_expr_t, char *);
void db_stopproc_cmd(db_expr_t, int, db_expr_t, char *);
void db_ddbproc_cmd(db_expr_t, int, db_expr_t, char *);
#endif

/*
 * Print trap reason.
 */
void
db_printtrap(int type, int code)
{
	db_printf("kernel: ");
	if (type >= trap_types || type < 0)
		db_printf("type %d", type);
	else
		db_printf("%s", trap_type[type]);
	db_printf(" trap, code=%x\n", code);
}

/*
 *  db_ktrap - field a TRACE or BPT trap
 */
int
db_ktrap(int type, int code, db_regs_t *regs)
{
	int s;

#if NWSDISPLAY > 0
	wsdisplay_switchtoconsole();
#endif

	switch (type) {
	case T_BPTFLT:	/* breakpoint */
	case T_TRCTRAP:	/* single_step */
	case T_NMI:	/* NMI */
	case T_NMI|T_USER:
	case -1:	/* keyboard interrupt */
		break;
	default:
		if (!db_panic)
			return (0);

		db_printtrap(type, code);
		if (db_recover != 0) {
			db_error("Faulted in DDB; continuing...\n");
			/*NOTREACHED*/
		}
	}

#ifdef MULTIPROCESSOR
	mtx_enter(&ddb_mp_mutex);
	if (ddb_state == DDB_STATE_EXITING)
		ddb_state = DDB_STATE_NOT_RUNNING;
	mtx_leave(&ddb_mp_mutex);
	while (db_enter_ddb()) {
#endif

	ddb_regs = *regs;

	ddb_regs.tf_cs &= 0xffff;
	ddb_regs.tf_ss &= 0xffff;

	s = splhigh();
	db_active++;
	cnpollc(TRUE);
	db_trap(type, code);
	cnpollc(FALSE);
	db_active--;
	splx(s);

	*regs = ddb_regs;

#ifdef MULTIPROCESSOR
		if (!db_switch_cpu)
			ddb_state = DDB_STATE_EXITING;
	}
#endif
	return (1);
}


#ifdef MULTIPROCESSOR
void
db_cpuinfo_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	int i;

	for (i = 0; i < MAXCPUS; i++) {
		if (cpu_info[i] != NULL) {
			db_printf("%c%4d: ", (i == cpu_number()) ? '*' : ' ',
			    CPU_INFO_UNIT(cpu_info[i]));
			switch(cpu_info[i]->ci_ddb_paused) {
			case CI_DDB_RUNNING:
				db_printf("running\n");
				break;
			case CI_DDB_SHOULDSTOP:
				db_printf("stopping\n");
				break;
			case CI_DDB_STOPPED:
				db_printf("stopped\n");
				break;
			case CI_DDB_ENTERDDB:
				db_printf("entering ddb\n");
				break;
			case CI_DDB_INDDB:
				db_printf("ddb\n");
				break;
			default:
				db_printf("? (%d)\n",
				    cpu_info[i]->ci_ddb_paused);
				break;
			}
		}
	}
}

void
db_startproc_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	int i;

	if (have_addr) {
		if (addr >= 0 && addr < MAXCPUS &&
		    cpu_info[addr] != NULL && addr != cpu_number())
			db_startcpu(addr);
		else
			db_printf("Invalid cpu %d\n", (int)addr);
	} else {
		for (i = 0; i < MAXCPUS; i++) {
			if (cpu_info[i] != NULL && i != cpu_number())
				db_startcpu(i);
		}
	}
}

void
db_stopproc_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	int i;

	if (have_addr) {
		if (addr >= 0 && addr < MAXCPUS &&
		    cpu_info[addr] != NULL && addr != cpu_number())
			db_stopcpu(addr);
		else
			db_printf("Invalid cpu %d\n", (int)addr);
	} else {
		for (i = 0; i < MAXCPUS; i++) {
			if (cpu_info[i] != NULL && i != cpu_number())
				db_stopcpu(i);
		}
	}
}

void
db_ddbproc_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	if (have_addr) {
		if (addr >= 0 && addr < MAXCPUS &&
		    cpu_info[addr] != NULL && addr != cpu_number()) {
			db_stopcpu(addr);
			db_switch_to_cpu = addr;
			db_switch_cpu = 1;
			db_cmd_loop_done = 1;
		} else {
			db_printf("Invalid cpu %d\n", (int)addr);
		}
	} else {
		db_printf("CPU not specified\n");
	}
}

int
db_enter_ddb(void)
{
	int i;

	mtx_enter(&ddb_mp_mutex);

	/* If we are first in, grab ddb and stop all other CPUs */
	if (ddb_state == DDB_STATE_NOT_RUNNING) {
		ddb_active_cpu = cpu_number();
		ddb_state = DDB_STATE_RUNNING;
		curcpu()->ci_ddb_paused = CI_DDB_INDDB;
		mtx_leave(&ddb_mp_mutex);
		for (i = 0; i < MAXCPUS; i++) {
			if (cpu_info[i] != NULL && i != cpu_number() &&
			    cpu_info[i]->ci_ddb_paused != CI_DDB_STOPPED) {
				cpu_info[i]->ci_ddb_paused = CI_DDB_SHOULDSTOP;
				x86_send_ipi(cpu_info[i], X86_IPI_DDB);
			}
		}
		return (1);
	}

	/* Leaving ddb completely.  Start all other CPUs and return 0 */
	if (ddb_active_cpu == cpu_number() && ddb_state == DDB_STATE_EXITING) {
		for (i = 0; i < MAXCPUS; i++) {
			if (cpu_info[i] != NULL) {
				cpu_info[i]->ci_ddb_paused = CI_DDB_RUNNING;
			}
		}
		mtx_leave(&ddb_mp_mutex);
		return (0);
	}

	/* We're switching to another CPU.  db_ddbproc_cmd() has made sure
	 * it is waiting for ddb, we just have to set ddb_active_cpu. */
	if (ddb_active_cpu == cpu_number() && db_switch_cpu) {
		curcpu()->ci_ddb_paused = CI_DDB_SHOULDSTOP;
		db_switch_cpu = 0;
		ddb_active_cpu = db_switch_to_cpu;
		cpu_info[db_switch_to_cpu]->ci_ddb_paused = CI_DDB_ENTERDDB;
	}

	/* Wait until we should enter ddb or resume */
	while (ddb_active_cpu != cpu_number() &&
	    curcpu()->ci_ddb_paused != CI_DDB_RUNNING) {
		if (curcpu()->ci_ddb_paused == CI_DDB_SHOULDSTOP)
			curcpu()->ci_ddb_paused = CI_DDB_STOPPED;
		mtx_leave(&ddb_mp_mutex);

		/* Busy wait without locking, we'll confirm with lock later */
		while (ddb_active_cpu != cpu_number() &&
		    curcpu()->ci_ddb_paused != CI_DDB_RUNNING)
			CPU_BUSY_CYCLE();

		mtx_enter(&ddb_mp_mutex);
	}

	/* Either enter ddb or exit */
	if (ddb_active_cpu == cpu_number() && ddb_state == DDB_STATE_RUNNING) {
		curcpu()->ci_ddb_paused = CI_DDB_INDDB;
		mtx_leave(&ddb_mp_mutex);
		return (1);
	} else {
		mtx_leave(&ddb_mp_mutex);
		return (0);
	}
}

void
db_startcpu(int cpu)
{
	if (cpu != cpu_number() && cpu_info[cpu] != NULL) {
		mtx_enter(&ddb_mp_mutex);
		cpu_info[cpu]->ci_ddb_paused = CI_DDB_RUNNING;
		mtx_leave(&ddb_mp_mutex);
	}
}

void
db_stopcpu(int cpu)
{
	mtx_enter(&ddb_mp_mutex);
	if (cpu != cpu_number() && cpu_info[cpu] != NULL &&
	    cpu_info[cpu]->ci_ddb_paused != CI_DDB_STOPPED) {
		cpu_info[cpu]->ci_ddb_paused = CI_DDB_SHOULDSTOP;
		mtx_leave(&ddb_mp_mutex);
		x86_send_ipi(cpu_info[cpu], X86_IPI_DDB);
	} else {
		mtx_leave(&ddb_mp_mutex);
	}
}

void
x86_ipi_db(struct cpu_info *ci)
{
	Debugger();
}
#endif /* MULTIPROCESSOR */

#if NACPI > 0
struct db_command db_acpi_cmds[] = {
	{ "disasm",	db_acpi_disasm,		CS_OWN,	NULL },
	{ "showval",	db_acpi_showval,	CS_OWN,	NULL },
	{ "tree",	db_acpi_tree,		0,	NULL },
	{ "trace",	db_acpi_trace,		0,	NULL },
	{ NULL,		NULL,			0,	NULL }
};
#endif /* NACPI > 0 */

struct db_command db_machine_command_table[] = {
#ifdef MULTIPROCESSOR
	{ "cpuinfo",	db_cpuinfo_cmd,		0,	0 },
	{ "startcpu",	db_startproc_cmd,	0,	0 },
	{ "stopcpu",	db_stopproc_cmd,	0,	0 },
	{ "ddbcpu",	db_ddbproc_cmd,		0,	0 },
#endif
#if NACPI > 0
	{ "acpi",	NULL,			0,	db_acpi_cmds },
#endif /* NACPI > 0 */
	{ NULL, },
};

void
db_machine_init(void)
{
#ifdef MULTIPROCESSOR
	int i;
#endif

	db_machine_commands_install(db_machine_command_table);
#ifdef MULTIPROCESSOR
	for (i = 0; i < MAXCPUS; i++) {
		if (cpu_info[i] != NULL)
			cpu_info[i]->ci_ddb_paused = CI_DDB_RUNNING;
	}
#endif
}

void
Debugger(void)
{
	breakpoint();
}
@


1.25
log
@Change a bunch of (<blah> *)0 to NULL.

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.24 2016/02/27 13:08:06 mpi Exp $	*/
d121 1
@


1.24
log
@Rename kdb_trap() into db_ktrap().

The goal is to include it in the list of functions that must not be
instrumented.  All ddb(8) functions should be in this list and have
their names start with 'db_'.

ok visa@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.23 2015/05/18 19:59:27 guenther Exp $	*/
d377 1
a377 1
	{ (char *)0, },
@


1.23
log
@Do lazy update/reset of the FS.base and %[def]s segment registers: reseting
segment registers in cpu_switchto if the old thread had made it to userspace
and restoring FS.base only on first return to userspace since context switch.

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.22 2015/03/14 03:38:46 jsg Exp $	*/
d83 1
a83 1
void kdbprinttrap(int, int);
d95 1
a95 1
kdbprinttrap(int type, int code)
d106 1
a106 1
 *  kdb_trap - field a TRACE or BPT trap
d109 1
a109 1
kdb_trap(int type, int code, db_regs_t *regs)
d127 1
a127 1
		kdbprinttrap(type, code);
@


1.22
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.21 2014/10/15 15:55:42 uebayasi Exp $	*/
a144 4
	ddb_regs.tf_ds &= 0xffff;
	ddb_regs.tf_es &= 0xffff;
	ddb_regs.tf_fs &= 0xffff;
	ddb_regs.tf_gs &= 0xffff;
@


1.21
log
@Sprinkle CPU_BUSY_CYCLE() in a few places.

OK kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a53 1
#include <ddb/db_access.h>
@


1.20
log
@Revert previous (wrong commit message).
@
text
@d315 1
a315 1
			;	/* Do nothing */
@


1.19
log
@pppx(4): Correct pppx_dev_lookup() and pppx_dev2pxd() local declarations

Those two functions take one dev_t argument, not int.  Match declarations
with reality.  No functional changes.
@
text
@d315 1
a315 1
			CPU_BUSY_CYCLE();
@


1.18
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.17 2013/05/12 20:47:44 kettenis Exp $	*/
d315 1
a315 1
			;	/* Do nothing */
@


1.17
log
@Tell wsdisplay(4) to switch back to the console screen upon entering ddb(4).
This gives users a decent chance to see panic messages and interact with ddb(4)
when they're running X on hardware for which we have a KMS driver.  Currently
that means inteldrm(4).

ok jsg@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.16 2010/04/01 19:47:59 kettenis Exp $	*/
a36 1
#include <sys/proc.h>
@


1.16
log
@Don't index cpu_info by apic id, but by device unit number instead.  Recent
Intel CPUs come up with apic id's >= 32, even on systems with less than 32
logical CPUs.

ok krw@@, marco@@; tested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.15 2008/10/03 21:57:25 weingart Exp $	*/
d65 5
d114 4
@


1.15
log
@Backout. kettenis@@ has reservations.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.14 2008/10/03 17:07:53 weingart Exp $	*/
a85 1
int db_cpuid2apic(int);
a163 13
int
db_cpuid2apic(int id)
{
	int apic;

	for (apic = 0; apic < MAXCPUS; apic++) {
		if (cpu_info[apic] != NULL &&
		    CPU_INFO_UNIT(cpu_info[apic]) == id)
			return (apic);
	}
	return (-1);
}

d201 1
a201 1
	int apic;
d204 3
a206 4
		apic = db_cpuid2apic(addr);
		if (apic >= 0 && apic < MAXCPUS &&
		    cpu_info[apic] != NULL && apic != cpu_number())
			db_startcpu(apic);
d210 3
a212 4
		for (apic = 0; apic < MAXCPUS; apic++) {
			if (cpu_info[apic] != NULL && apic != cpu_number()) {
				db_startcpu(apic);
			}
d220 1
a220 1
	int apic;
d223 3
a225 4
		apic = db_cpuid2apic(addr);
		if (apic >= 0 && apic < MAXCPUS &&
		    cpu_info[apic] != NULL && apic != cpu_number())
			db_stopcpu(apic);
d229 3
a231 4
		for (apic = 0; apic < MAXCPUS; apic++) {
			if (cpu_info[apic] != NULL && apic != cpu_number()) {
				db_stopcpu(apic);
			}
a238 2
	int apic;

d240 4
a243 5
		apic = db_cpuid2apic(addr);
		if (apic >= 0 && apic < MAXCPUS &&
		    cpu_info[apic] != NULL && apic != cpu_number()) {
			db_stopcpu(apic);
			db_switch_to_cpu = apic;
@


1.14
log
@Make extra cpu's in DDB not spin in tight loop.
Having them 'hlt' is a good thing, especially
where thermal management (acpi, etc) is concerned.

They wake up lots due to local tick timer anyhow.

ok gwk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.13 2007/11/16 16:16:07 deraadt Exp $	*/
d328 1
a328 1
			__asm __volatile ("hlt");	/* Do nothing */
@


1.13
log
@fix the bus_space #define nightmare, so that amd64 and i386 are much more
uniform. as a result shared code like acpi needs less #ifdef's
ok marco kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.12 2007/11/14 17:52:35 miod Exp $	*/
d328 1
a328 1
			;	/* Do nothing */
@


1.12
log
@Be consistent in db_cmd_loop_done declaration.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.11 2007/01/15 23:19:05 jsg Exp $	*/
d170 1
a170 1
	for (apic = 0; apic < X86_MAXPROCS; apic++) {
d183 1
a183 1
	for (i = 0; i < X86_MAXPROCS; i++) {
d219 1
a219 1
		if (apic >= 0 && apic < X86_MAXPROCS &&
d225 1
a225 1
		for (apic = 0; apic < X86_MAXPROCS; apic++) {
d240 1
a240 1
		if (apic >= 0 && apic < X86_MAXPROCS &&
d246 1
a246 1
		for (apic = 0; apic < X86_MAXPROCS; apic++) {
d261 1
a261 1
		if (apic >= 0 && apic < X86_MAXPROCS &&
d288 1
a288 1
		for (i = 0; i < X86_MAXPROCS; i++) {
d300 1
a300 1
		for (i = 0; i < X86_MAXPROCS; i++) {
d407 1
a407 1
	for (i = 0; i < X86_MAXPROCS; i++) {
@


1.11
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.10 2006/10/24 19:03:10 marco Exp $	*/
d57 1
a67 1
extern boolean_t db_cmd_loop_done;
@


1.10
log
@Hook brand new trace function into ddb.  Now users can send useful traces
without enabling acpi debug.  Usage "machine acpi trace".

ok jordan
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.9 2006/03/08 21:04:57 marco Exp $	*/
d93 1
a93 2
kdbprinttrap(type, code)
	int type, code;
d107 1
a107 3
kdb_trap(type, code, regs)
	int type, code;
	db_regs_t *regs;
d276 1
a276 1
db_enter_ddb()
d399 1
a399 1
db_machine_init()
d415 1
a415 1
Debugger()
@


1.9
log
@Glue showval into ddb.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.8 2006/03/07 23:15:02 marco Exp $	*/
d383 1
@


1.8
log
@Add hooks for "machine acpi disasm"

ok jordan
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.7 2006/03/05 14:46:45 marco Exp $	*/
d381 1
@


1.7
log
@Hook acpi to ddb since we need to be able to do some live debugging.

Lots and lots of help from miod@@ and deraadt@@
ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.6 2005/12/05 21:31:23 miod Exp $	*/
d380 1
@


1.6
log
@Remove duplicate declaration.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.5 2005/03/31 02:53:48 tedu Exp $	*/
d59 5
d378 7
d392 3
@


1.5
log
@go back to the old trace code, but add -fno-omit-frame-pointer so it works.
makes trace output more reasonable.  ok andreas
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.3 2004/07/22 11:15:00 art Exp $	*/
a67 1
extern volatile int ddb_state;
@


1.4
log
@Heuristic approach to 'trace' in ddb which works without frame pointers.
Not perfect yet but better than nothing.
art@@ ok
@
text
@a55 1
#include <ddb/db_variables.h>
a74 53

#define dbreg(xx) (long *)offsetof(db_regs_t, tf_ ## xx)

static int db_x86_64_regop(struct db_variable *, db_expr_t *, int);

struct db_variable db_regs[] = {
	{ "ds",		dbreg(ds),     db_x86_64_regop },
	{ "es",		dbreg(es),     db_x86_64_regop },
	{ "fs",		dbreg(fs),     db_x86_64_regop },
	{ "gs",		dbreg(gs),     db_x86_64_regop },
	{ "rdi",	dbreg(rdi),    db_x86_64_regop },
	{ "rsi",	dbreg(rsi),    db_x86_64_regop },
	{ "rbp",	dbreg(rbp),    db_x86_64_regop },
	{ "rbx",	dbreg(rbx),    db_x86_64_regop },
	{ "rdx",	dbreg(rdx),    db_x86_64_regop },
	{ "rcx",	dbreg(rcx),    db_x86_64_regop },
	{ "rax",	dbreg(rax),    db_x86_64_regop },
	{ "r8",		dbreg(r8),     db_x86_64_regop },
	{ "r9",		dbreg(r9),     db_x86_64_regop },
	{ "r10",	dbreg(r10),    db_x86_64_regop },
	{ "r11",	dbreg(r11),    db_x86_64_regop },
	{ "r12",	dbreg(r12),    db_x86_64_regop },
	{ "r13",	dbreg(r13),    db_x86_64_regop },
	{ "r14",	dbreg(r14),    db_x86_64_regop },
	{ "r15",	dbreg(r15),    db_x86_64_regop },
	{ "rip",	dbreg(rip),    db_x86_64_regop },
	{ "cs",		dbreg(cs),     db_x86_64_regop },
	{ "rflags",	dbreg(rflags), db_x86_64_regop },
	{ "rsp",	dbreg(rsp),    db_x86_64_regop },
	{ "ss",		dbreg(ss),     db_x86_64_regop },
};

struct db_variable * db_eregs =
	db_regs + sizeof(db_regs)/sizeof(db_regs[0]);

static int
db_x86_64_regop(struct db_variable *vp, db_expr_t *val, int opcode)
{
        db_expr_t *regaddr =
            (db_expr_t *)(((uint8_t *)DDB_REGS) + ((size_t)vp->valuep));

        switch (opcode) {
        case DB_VAR_GET:
                *val = *regaddr;
                break;
        case DB_VAR_SET:
                *regaddr = *val;
                break;
        default:
                panic("db_x86_64_regop: unknown op %d", opcode);
        }
        return 0;
}
@


1.3
log
@mutex instead of SIMPLELOCK for mp ddb.

"reads good" niklas@@
"looks good" andreas@@
"works" tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.2 2004/06/25 17:27:01 andreas Exp $	*/
d56 1
d76 53
@


1.2
log
@'machine cpuinfo' and 'machine ddbcpu' in ddb for amd64
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.1 2004/01/28 01:39:38 mickey Exp $	*/
d65 1
a65 1
struct SIMPLELOCK ddb_mp_slock;
d128 1
a128 2
	s = splhigh();
	SIMPLE_LOCK(&ddb_mp_slock);
d131 1
a131 2
	SIMPLE_UNLOCK(&ddb_mp_slock);
	splx(s);
d277 1
a277 1
	int s, i;
d279 1
a279 2
	s = splhigh();
	SIMPLE_LOCK(&ddb_mp_slock);
d286 1
a286 2
		SIMPLE_UNLOCK(&ddb_mp_slock);
		splx(s);
d304 1
a304 2
		SIMPLE_UNLOCK(&ddb_mp_slock);
		splx(s);
d322 1
a322 2
		SIMPLE_UNLOCK(&ddb_mp_slock);
		splx(s);
d329 1
a329 2
		s = splhigh();
		SIMPLE_LOCK(&ddb_mp_slock);
d335 1
a335 2
		SIMPLE_UNLOCK(&ddb_mp_slock);
		splx(s);
d338 1
a338 2
		SIMPLE_UNLOCK(&ddb_mp_slock);
		splx(s);
a345 2
	int s;

d347 1
a347 2
		s = splhigh();
		SIMPLE_LOCK(&ddb_mp_slock);
d349 1
a349 2
		SIMPLE_UNLOCK(&ddb_mp_slock);
		splx(s);
d356 1
a356 4
	int s;

	s = splhigh();
	SIMPLE_LOCK(&ddb_mp_slock);
d360 1
a360 2
		SIMPLE_UNLOCK(&ddb_mp_slock);
		splx(s);
d363 1
a363 2
		SIMPLE_UNLOCK(&ddb_mp_slock);
		splx(s);
a396 1
	SIMPLE_LOCK_INIT(&ddb_mp_slock);
@


1.1
log
@an amd64 arch support.
hacked by art@@ from netbsd sources and then later debugged
by me into the shape where it can host itself.
no bootloader yet as needs redoing from the
recent advanced i386 sources (anyone? ;)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d62 1
a63 7
int	db_active;
db_regs_t ddb_regs;	/* register state */
db_regs_t *ddb_regp;

void db_mach_cpu (db_expr_t, int, db_expr_t, char *);

const struct db_command db_machine_command_table[] = {
d65 6
a70 1
	{ "cpu",	db_mach_cpu,	0,	0 },
d72 3
a74 2
	{ (char *)0, },
};
d78 5
a82 66
extern void ddb_ipi(struct trapframe);
static void ddb_suspend(struct trapframe *);
int ddb_vec;
#endif

#define NOCPU	-1

int ddb_cpu = NOCPU;

typedef void (vector)(void);
extern vector Xintrddb;

void
db_machine_init()
{

#ifdef MULTIPROCESSOR
	ddb_vec = idt_vec_alloc(0xf0, 0xff);
	setgate((struct gate_descriptor *)&idt[ddb_vec], &Xintrddb, 1,
	    SDT_SYS386IGT, SEL_KPL, GSEL(GCODE_SEL, SEL_KPL));
#endif
}

#ifdef MULTIPROCESSOR

__cpu_simple_lock_t db_lock;

static int
db_suspend_others(void)
{
	int cpu_me = cpu_number();
	int win;

	if (ddb_vec == 0)
		return 1;

	__cpu_simple_lock(&db_lock);
	if (ddb_cpu == NOCPU)
		ddb_cpu = cpu_me;
	win = (ddb_cpu == cpu_me);
	__cpu_simple_unlock(&db_lock);
	if (win) {
		x86_ipi(ddb_vec, LAPIC_DEST_ALLEXCL, LAPIC_DLMODE_FIXED);
	}
	return win;
}

static void
db_resume_others(void)
{
	int i;

	__cpu_simple_lock(&db_lock);
	ddb_cpu = NOCPU;
	__cpu_simple_unlock(&db_lock);

	for (i=0; i < X86_MAXPROCS; i++) {
		struct cpu_info *ci = cpu_info[i];
		if (ci == NULL)
			continue;
		if (ci->ci_flags & CPUF_PAUSE)
			x86_atomic_clearbits_l(&ci->ci_flags, CPUF_PAUSE);
	}

}

a108 1
	db_regs_t dbreg;
d128 7
a134 5
	if (!db_suspend_others()) {
		ddb_suspend(regs);
	} else {
	curcpu()->ci_ddb_regs = &dbreg;
	ddb_regp = &dbreg;
a152 5
#ifdef MULTIPROCESSOR  
	db_resume_others();
	}
#endif  
	ddb_regp = &dbreg;
d156 5
d164 49
d214 1
a214 1
Debugger()
d216 16
a231 1
	breakpoint();
d234 4
a237 1
#ifdef MULTIPROCESSOR
d239 15
a253 7
/*
 * Called when we receive a debugger IPI (inter-processor interrupt).
 * As with trap() in trap.c, this function is called from an assembly
 * language IDT gate entry routine which prepares a suitable stack frame,
 * and restores this frame after the exception has been processed. Note
 * that the effect is as if the arguments were passed call by reference.
 */
d256 1
a256 1
ddb_ipi(struct trapframe frame)
d258 1
d260 14
a273 1
	ddb_suspend(&frame);
d276 2
a277 2
static void
ddb_suspend(struct trapframe *frame)
d279 4
a282 2
	volatile struct cpu_info *ci = curcpu();
	db_regs_t regs;
d284 37
a320 1
	regs = *frame;
d322 12
a333 1
	ci->ci_ddb_regs = &regs;
d335 3
a337 1
	x86_atomic_setbits_l(&ci->ci_flags, CPUF_PAUSE);
d339 11
a349 3
	while (ci->ci_flags & CPUF_PAUSE)
		;
	ci->ci_ddb_regs = 0;
d352 4
d357 8
a364 1
extern void cpu_debug_dump(void); /* XXX */
d367 15
a381 26
db_mach_cpu(addr, have_addr, count, modif)
	db_expr_t	addr;
	int		have_addr;
	db_expr_t	count;
	char *		modif;
{
	struct cpu_info *ci;
	if (!have_addr) {
		cpu_debug_dump();
		return;
	}

	if ((addr < 0) || (addr >= X86_MAXPROCS)) {
		db_printf("%ld: cpu out of range\n", addr);
		return;
	}
	ci = cpu_info[addr];
	if (ci == NULL) {
		db_printf("cpu %ld not configured\n", addr);
		return;
	}
	if (ci != curcpu()) {
		if (!(ci->ci_flags & CPUF_PAUSE)) {
			db_printf("cpu %ld not paused\n", addr);
			return;
		}
d383 31
a413 3
	if (ci->ci_ddb_regs == 0) {
		db_printf("cpu %ld has no saved regs\n", addr);
		return;
d415 2
a416 2
	db_printf("using cpu %ld", addr);
	ddb_regp = ci->ci_ddb_regs;
d419 5
a423 1
#endif
@

