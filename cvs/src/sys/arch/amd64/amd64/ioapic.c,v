head	1.25;
access;
symbols
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.25.0.2
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.23.0.4
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.20.0.20
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.18
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.14
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.12
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.10
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.8
	OPENBSD_5_0:1.20.0.6
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.4
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.2
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.17.0.6
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.2
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.12.0.6
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.4
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.2
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.6.0.6
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.2
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.3.0.4
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3;
locks; strict;
comment	@ * @;


1.25
date	2016.06.29.06.05.15;	author mlarkin;	state Exp;
branches;
next	1.24;
commitid	vjZUIOW1whiQYE9y;

1.24
date	2016.05.07.14.19.50;	author kettenis;	state Exp;
branches;
next	1.23;
commitid	dLJGiP2q7RyaboOz;

1.23
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.22;
commitid	p4LJxGKbi0BU2cG6;

1.22
date	2014.12.09.06.58.28;	author doug;	state Exp;
branches;
next	1.21;
commitid	yWAxzpQP2PPpYlfT;

1.21
date	2014.11.22.18.55.20;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	nFIm5oOp8CCDBtjV;

1.20
date	2010.08.08.16.43.21;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2010.07.22.00.41.29;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2009.08.13.13.24.48;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2008.12.21.18.49.45;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2008.10.21.21.52.07;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2008.10.21.21.31.10;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2008.09.15.19.19.45;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2008.06.26.05.42.09;	author ray;	state Exp;
branches;
next	1.12;

1.12
date	2007.02.22.19.46.16;	author marco;	state Exp;
branches;
next	1.11;

1.11
date	2007.02.22.03.47.15;	author marco;	state Exp;
branches;
next	1.10;

1.10
date	2007.01.24.20.47.45;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.15.23.19.05;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.06.20.51.46;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.06.19.10.06;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2005.05.31.09.34.22;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2005.05.29.03.20.36;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2005.05.25.23.17.47;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.27.16.17.50;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.25.11.31.21;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.25.11.03.27;	author art;	state Exp;
branches;
next	;


desc
@@


1.25
log
@
Don't write a 1 to the RIRR bit in the IOAPIC redirection register. This bit
is R/O, and although it should not matter what value is written there,
Hyper-V's emulated IOAPIC interprets a write of 1 in some unexpected way and
subsequently blocks interrupt delivery. This primarily manifests itself as
de(4) timeouts when using Hyper-V VMs with the "Legacy Network Adapter"
interface.

This diff has been in snaps for almost a month with no reported fallout.

Based on an idea originally from mikeb with further input from kettenis and
deraadt.
@
text
@/*	$OpenBSD: ioapic.c,v 1.24 2016/05/07 14:19:50 kettenis Exp $	*/
/* 	$NetBSD: ioapic.c,v 1.6 2003/05/15 13:30:31 fvdl Exp $	*/

/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by RedBack Networks Inc.
 *
 * Author: Bill Sommerfeld
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */


/*
 * Copyright (c) 1999 Stefan Grefen
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the NetBSD
 *      Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR AND CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <machine/bus.h>
#include <machine/isa_machdep.h> /* XXX intrhand */
 
#include <uvm/uvm_extern.h>
#include <machine/i82093reg.h>
#include <machine/i82093var.h>

#include <machine/i82489var.h>

#include <machine/pmap.h>

#include <machine/mpbiosvar.h>

/*
 * XXX locking
 */

int     ioapic_match(struct device *, void *, void *);
void    ioapic_attach(struct device *, struct device *, void *);
int	ioapic_activate(struct device *, int);

extern int x86_mem_add_mapping(bus_addr_t, bus_size_t,
    int, bus_space_handle_t *); /* XXX XXX */

void ioapic_hwmask(struct pic *, int);
void ioapic_hwunmask(struct pic *, int);
void ioapic_addroute(struct pic *, struct cpu_info *, int, int, int);
void ioapic_delroute(struct pic *, struct cpu_info *, int, int, int);
void apic_set_redir(struct ioapic_softc *, int, int, struct cpu_info *);

int ioapic_bsp_id = 0;
int ioapic_cold = 1;

struct ioapic_softc *ioapics;	 /* head of linked list */
int nioapics = 0;	   	 /* number attached */
static int ioapic_vecbase;

void ioapic_set_id(struct ioapic_softc *);

static __inline u_long
ioapic_lock(struct ioapic_softc *sc)
{
	u_long flags;

	flags = read_psl();
	disable_intr();
#ifdef MULTIPROCESSOR
	mtx_enter(&sc->sc_pic.pic_mutex);
#endif
	return flags;
}

static __inline void
ioapic_unlock(struct ioapic_softc *sc, u_long flags)
{
#ifdef MULTIPROCESSOR
	mtx_leave(&sc->sc_pic.pic_mutex);
#endif
	write_psl(flags);
}

/*
 * Register read/write routines.
 */
static __inline u_int32_t
ioapic_read_ul(struct ioapic_softc *sc,int regid)
{
	u_int32_t val;
	
	*(sc->sc_reg) = regid;
	val = *sc->sc_data;

	return (val);
}

static __inline void
ioapic_write_ul(struct ioapic_softc *sc,int regid, u_int32_t val)
{
	*(sc->sc_reg) = regid;
	*(sc->sc_data) = val;
}

static __inline u_int32_t
ioapic_read(struct ioapic_softc *sc, int regid)
{
	u_int32_t val;
	u_long flags;

	flags = ioapic_lock(sc);
	val = ioapic_read_ul(sc, regid);
	ioapic_unlock(sc, flags);
	return val;
}

static __inline void
ioapic_write(struct ioapic_softc *sc,int regid, int val)
{
	u_long flags;

	flags = ioapic_lock(sc);
	ioapic_write_ul(sc, regid, val);
	ioapic_unlock(sc, flags);
}

struct ioapic_softc *
ioapic_find(int apicid)
{
	struct ioapic_softc *sc;

	if (apicid == MPS_ALL_APICS) {	/* XXX mpbios-specific */
		/*
		 * XXX kludge for all-ioapics interrupt support
		 * on single ioapic systems
		 */
		if (nioapics <= 1)
			return (ioapics);
		panic("unsupported: all-ioapics interrupt with >1 ioapic");
	}

	for (sc = ioapics; sc != NULL; sc = sc->sc_next)
		if (sc->sc_apicid == apicid)
			return (sc);

	return (NULL);
}

/*
 * For the case the I/O APICs were configured using ACPI, there must
 * be an option to match global ACPI interrupts with APICs.
 */
struct ioapic_softc *
ioapic_find_bybase(int vec)
{
	struct ioapic_softc *sc;

	for (sc = ioapics; sc != NULL; sc = sc->sc_next) {
		if (vec >= sc->sc_apic_vecbase &&
		    vec < (sc->sc_apic_vecbase + sc->sc_apic_sz))
			return sc;
	}

	return NULL;
}

static __inline void
ioapic_add(struct ioapic_softc *sc)
{
	sc->sc_next = ioapics;
	ioapics = sc;
	nioapics++;
}

void
ioapic_print_redir(struct ioapic_softc *sc, char *why, int pin)
{
	u_int32_t redirlo = ioapic_read(sc, IOAPIC_REDLO(pin));
	u_int32_t redirhi = ioapic_read(sc, IOAPIC_REDHI(pin));

	apic_format_redir(sc->sc_pic.pic_name, why, pin, redirhi, redirlo);
}

struct cfattach ioapic_ca = {
	sizeof(struct ioapic_softc), ioapic_match, ioapic_attach, NULL,
	ioapic_activate
};

struct cfdriver ioapic_cd = {
	NULL, "ioapic", DV_DULL
};

int
ioapic_match(struct device *parent, void *v, void *aux)
{
	struct apic_attach_args *aaa = (struct apic_attach_args *)aux;
	struct cfdata *match = v;

	if (strcmp(aaa->aaa_name, match->cf_driver->cd_name) == 0)
		return (1);
	return (0);
}

/* Reprogram the APIC ID, and check that it actually got set. */
void
ioapic_set_id(struct ioapic_softc *sc)
{
	u_int8_t apic_id;

	ioapic_write(sc, IOAPIC_ID,
	    (ioapic_read(sc, IOAPIC_ID) & ~IOAPIC_ID_MASK) |
	    (sc->sc_apicid << IOAPIC_ID_SHIFT));

	apic_id = (ioapic_read(sc, IOAPIC_ID) & IOAPIC_ID_MASK) >>
	    IOAPIC_ID_SHIFT;

	if (apic_id != sc->sc_apicid)
		printf(", can't remap to apid %d\n", sc->sc_apicid);
	else
		printf(", remapped to apid %d\n", sc->sc_apicid);
}

/*
 * can't use bus_space_xxx as we don't have a bus handle ...
 */
void
ioapic_attach(struct device *parent, struct device *self, void *aux)
{
	struct ioapic_softc *sc = (struct ioapic_softc *)self;
	struct apic_attach_args  *aaa = (struct apic_attach_args *)aux;
	int apic_id;
	bus_space_handle_t bh;
	u_int32_t ver_sz;
	int i;

	sc->sc_flags = aaa->flags;
	sc->sc_apicid = aaa->apic_id;

	printf(": apid %d", aaa->apic_id);

	if (ioapic_find(aaa->apic_id) != NULL) {
		printf(", duplicate apic id (ignored)\n");
		return;
	}

	ioapic_add(sc);

	printf(" pa 0x%lx", aaa->apic_address);

	if (x86_mem_add_mapping(aaa->apic_address, PAGE_SIZE, 0, &bh) != 0) {
		printf(", map failed\n");
		return;
	}
	sc->sc_reg = (volatile u_int32_t *)(bh + IOAPIC_REG);
	sc->sc_data = (volatile u_int32_t *)(bh + IOAPIC_DATA);

	sc->sc_pic.pic_type = PIC_IOAPIC;
#ifdef MULTIPROCESSOR
	mtx_init(&sc->sc_pic.pic_mutex, IPL_NONE);
#endif
	sc->sc_pic.pic_hwmask = ioapic_hwmask;
	sc->sc_pic.pic_hwunmask = ioapic_hwunmask;
	sc->sc_pic.pic_addroute = ioapic_addroute;
	sc->sc_pic.pic_delroute = ioapic_delroute;
	sc->sc_pic.pic_edge_stubs = ioapic_edge_stubs;
	sc->sc_pic.pic_level_stubs = ioapic_level_stubs;

	ver_sz = ioapic_read(sc, IOAPIC_VER);
	sc->sc_apic_vers = (ver_sz & IOAPIC_VER_MASK) >> IOAPIC_VER_SHIFT;
	sc->sc_apic_sz = (ver_sz & IOAPIC_MAX_MASK) >> IOAPIC_MAX_SHIFT;
	sc->sc_apic_sz++;

	if (aaa->apic_vecbase != -1)
		sc->sc_apic_vecbase = aaa->apic_vecbase;
	else {
		/*
		 * XXX this assumes ordering of ioapics in the table.
		 * Only needed for broken BIOS workaround (see mpbios.c)
		 */
		sc->sc_apic_vecbase = ioapic_vecbase;
		ioapic_vecbase += sc->sc_apic_sz;
	}

	if (mp_verbose) {
		printf(", %s mode",
		    aaa->flags & IOAPIC_PICMODE ? "PIC" : "virtual wire");
	}

	printf(", version %x, %d pins\n", sc->sc_apic_vers, sc->sc_apic_sz);

	apic_id = (ioapic_read(sc, IOAPIC_ID) & IOAPIC_ID_MASK) >>
	    IOAPIC_ID_SHIFT;

	sc->sc_pins = mallocarray(sc->sc_apic_sz, sizeof(struct ioapic_pin),
	    M_DEVBUF, M_WAITOK);

	for (i = 0; i < sc->sc_apic_sz; i++) {
		sc->sc_pins[i].ip_next = NULL;
		sc->sc_pins[i].ip_map = NULL;
		sc->sc_pins[i].ip_vector = 0;
		sc->sc_pins[i].ip_type = IST_NONE;
	}

	/*
	 * In case the APIC is not initialized to the correct ID
	 * do it now.
	 * Maybe we should record the original ID for interrupt
	 * mapping later ...
	 */
	if (mp_verbose && apic_id != sc->sc_apicid) {
		printf("%s: misconfigured as apic %d",
		    sc->sc_pic.pic_name, apic_id);
		ioapic_set_id(sc);
	}
#if 0
	/* output of this was boring. */
	if (mp_verbose)
		for (i = 0; i < sc->sc_apic_sz; i++)
			ioapic_print_redir(sc, "boot", i);
#endif
}

int
ioapic_activate(struct device *self, int act)
{
	struct ioapic_softc *sc = (struct ioapic_softc *)self;

	switch (act) {
	case DVACT_RESUME:
		/* On resume, reset the APIC id, like we do on boot */
		ioapic_write(sc, IOAPIC_ID,
		    (ioapic_read(sc, IOAPIC_ID) & ~IOAPIC_ID_MASK) |
		    (sc->sc_apicid << IOAPIC_ID_SHIFT));
	}

	return (0);
}

void
apic_set_redir(struct ioapic_softc *sc, int pin, int idt_vec,
    struct cpu_info *ci)
{
	u_int32_t redlo;
	u_int32_t redhi = 0;
	int delmode;

	struct ioapic_pin *pp;
	struct mp_intr_map *map;

	pp = &sc->sc_pins[pin];
	map = pp->ip_map;
	redlo = (map == NULL) ? IOAPIC_REDLO_MASK : map->redir;
	delmode = (redlo & IOAPIC_REDLO_DEL_MASK) >> IOAPIC_REDLO_DEL_SHIFT;

	/* XXX magic numbers */
	if ((delmode != 0) && (delmode != 1))
		;
	else if (pp->ip_type == IST_NONE) {
		redlo |= IOAPIC_REDLO_MASK;
	} else {
		redlo |= (idt_vec & 0xff);
		redlo &= ~IOAPIC_REDLO_DEL_MASK;
		redlo |= (IOAPIC_REDLO_DEL_FIXED << IOAPIC_REDLO_DEL_SHIFT);
		redlo &= ~IOAPIC_REDLO_DSTMOD;

		/*
		 * Destination: BSP CPU
		 *
		 * XXX will want to distribute interrupts across cpu's
		 * eventually.  most likely, we'll want to vector each
		 * interrupt to a specific CPU and load-balance across
		 * cpu's.  but there's no point in doing that until after
		 * most interrupts run without the kernel lock.
		 */
		redhi |= (ci->ci_apicid << IOAPIC_REDHI_DEST_SHIFT);

		/* XXX derive this bit from BIOS info */
		if (pp->ip_type == IST_LEVEL)
			redlo |= IOAPIC_REDLO_LEVEL;
		else
			redlo &= ~IOAPIC_REDLO_LEVEL;
		if (map != NULL && ((map->flags & 3) == MPS_INTPO_DEF)) {
			if (pp->ip_type == IST_LEVEL)
				redlo |= IOAPIC_REDLO_ACTLO;
			else
				redlo &= ~IOAPIC_REDLO_ACTLO;
		}
	}
	/* Do atomic write */
	ioapic_write(sc, IOAPIC_REDLO(pin), IOAPIC_REDLO_MASK);
	ioapic_write(sc, IOAPIC_REDHI(pin), redhi);
	ioapic_write(sc, IOAPIC_REDLO(pin), redlo);
	if (mp_verbose)
		ioapic_print_redir(sc, "int", pin);
}

/*
 * Throw the switch and enable interrupts..
 */

void
ioapic_enable(void)
{
	int p;
	struct ioapic_softc *sc;
	struct ioapic_pin *ip;

	ioapic_cold = 0;

	if (ioapics == NULL)
		return;

	if (ioapics->sc_flags & IOAPIC_PICMODE) {
		printf("%s: writing to IMCR to disable pics\n",
		    ioapics->sc_pic.pic_name);
		outb(IMCR_ADDR, IMCR_REGISTER);
		outb(IMCR_DATA, IMCR_APIC);
	}

	for (sc = ioapics; sc != NULL; sc = sc->sc_next) {
		if (mp_verbose)
			printf("%s: enabling\n", sc->sc_pic.pic_name);

		for (p = 0; p < sc->sc_apic_sz; p++) {
			ip = &sc->sc_pins[p];
			if (ip->ip_type != IST_NONE)
				apic_set_redir(sc, p, ip->ip_vector,
				    ip->ip_cpu);
		}
	}
}

void
ioapic_hwmask(struct pic *pic, int pin)
{
	u_int32_t redlo;
	struct ioapic_softc *sc = (struct ioapic_softc *)pic;
	u_long flags;

	if (ioapic_cold)
		return;
	flags = ioapic_lock(sc);
	redlo = ioapic_read_ul(sc, IOAPIC_REDLO(pin));
	redlo |= IOAPIC_REDLO_MASK;
	redlo &= ~IOAPIC_REDLO_RIRR;
	ioapic_write_ul(sc, IOAPIC_REDLO(pin), redlo);
	ioapic_unlock(sc, flags);
}

void
ioapic_hwunmask(struct pic *pic, int pin)
{
	u_int32_t redlo;
	struct ioapic_softc *sc = (struct ioapic_softc *)pic;
	u_long flags;

	if (ioapic_cold)
		return;
	flags = ioapic_lock(sc);
	redlo = ioapic_read_ul(sc, IOAPIC_REDLO(pin));
	redlo &= ~IOAPIC_REDLO_MASK;
	redlo &= ~IOAPIC_REDLO_RIRR;
	ioapic_write_ul(sc, IOAPIC_REDLO(pin), redlo);
	ioapic_unlock(sc, flags);
}

void
ioapic_addroute(struct pic *pic, struct cpu_info *ci, int pin,
    int idtvec, int type)
{
	struct ioapic_softc *sc = (struct ioapic_softc *)pic;
	struct ioapic_pin *pp;

	pp = &sc->sc_pins[pin];
	pp->ip_type = type;
	pp->ip_vector = idtvec;
	pp->ip_cpu = ci;
	if (ioapic_cold)
		return;
	apic_set_redir(sc, pin, idtvec, ci);
}

void
ioapic_delroute(struct pic *pic, struct cpu_info *ci, int pin,
    int idtvec, int type)
{
	struct ioapic_softc *sc = (struct ioapic_softc *)pic;
	struct ioapic_pin *pp;

	if (ioapic_cold) {
		pp = &sc->sc_pins[pin];
		pp->ip_type = IST_NONE;
		return;
	}
	ioapic_hwmask(pic, pin);
}

#ifdef DDB
void ioapic_dump(void);

void
ioapic_dump(void)
{
	struct ioapic_softc *sc;
	struct ioapic_pin *ip;
	int p;

	for (sc = ioapics; sc != NULL; sc = sc->sc_next) {
		for (p = 0; p < sc->sc_apic_sz; p++) {
			ip = &sc->sc_pins[p];
			if (ip->ip_type != IST_NONE)
				ioapic_print_redir(sc, "dump", p);
		}
	}
}
#endif
@


1.24
log
@Stop printing the "ioapic0: misconfigured as apic..." messages.  Basically
all modern machines are "misconfigured".  We simply have to configure them
and it is pointless to complain.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.23 2015/03/14 03:38:46 jsg Exp $	*/
d495 1
d512 1
@


1.23
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.22 2014/12/09 06:58:28 doug Exp $	*/
d360 1
a360 1
	if (apic_id != sc->sc_apicid) {
@


1.22
log
@Replace some malloc(n*size,...) calls with mallocarray().

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.21 2014/11/22 18:55:20 deraadt Exp $	*/
a79 1
#include <machine/i82489reg.h>
@


1.21
log
@{ on seperate line at start of function or I go crazy
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.20 2010/08/08 16:43:21 deraadt Exp $	*/
d345 1
a345 1
	sc->sc_pins = malloc(sizeof(struct ioapic_pin) * sc->sc_apic_sz,
@


1.20
log
@Restore the APIC ID to what we set it to at boot (some machines come up
with it incorrect)
from mklarkin, ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.19 2010/07/22 00:41:29 deraadt Exp $	*/
d257 2
a258 1
ioapic_set_id(struct ioapic_softc *sc) {
@


1.19
log
@remove unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.18 2009/08/13 13:24:48 kettenis Exp $	*/
d93 1
d236 2
a237 1
	sizeof(struct ioapic_softc), ioapic_match, ioapic_attach
d371 16
@


1.18
log
@Make the i386 APIC code closer to the amd64 version.  Many whitespace fixes,
some additional code.

ok toby@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.17 2008/12/21 18:49:45 kettenis Exp $	*/
a101 2

int apic_verbose = 0;
@


1.17
log
@Change the way we include mpbios code to be similar to what we do on i386.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.16 2008/10/21 21:52:07 brad Exp $	*/
d49 5
a53 5
 *      This product includes software developed by the NetBSD 
 *      Foundation, Inc. and its contributors.  
 * 4. Neither the name of The NetBSD Foundation nor the names of its 
 *    contributors may be used to endorse or promote products derived  
 *    from this software without specific prior written permission.   
d139 1
a139 1
static __inline  u_int32_t
d147 1
a147 2
	return val;
	
d150 1
a150 1
static __inline  void
d169 1
a169 1
static __inline  void
d190 1
a190 1
			return ioapics;
d196 1
a196 1
			return sc;
d198 1
a198 1
	return NULL;
d228 1
a228 1
ioapic_print_redir (struct ioapic_softc *sc, char *why, int pin)
d233 1
a233 2
	apic_format_redir(sc->sc_pic.pic_dev.dv_xname, why, pin, redirhi,
	    redirlo);
d247 1
a247 1
	struct apic_attach_args *aaa = (struct apic_attach_args *) aux;
d251 2
a252 2
		return 1;
	return 0;
d276 1
a276 1
void 
d279 2
a280 2
	struct ioapic_softc *sc = (struct ioapic_softc *)self;  
	struct apic_attach_args  *aaa = (struct apic_attach_args  *) aux;
d285 1
a285 1
	
d289 1
a289 1
	printf(" apid %d", aaa->apic_id);
d305 1
a305 1
	sc->sc_data = (volatile u_int32_t *)(bh + IOAPIC_DATA);	
d362 1
a362 1
		    sc->sc_pic.pic_dev.dv_xname, apic_id);
d383 1
a383 1
	
d388 1
a388 1
	
d406 2
a407 2
		 * cpu's.  but there's no point in doing that until after 
		 * most interrupts run without the kernel lock.  
d449 1
a449 1
		    ioapics->sc_pic.pic_dev.dv_xname);
d456 1
a456 1
			printf("%s: enabling\n", sc->sc_pic.pic_dev.dv_xname);
@


1.16
log
@more style nits.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.15 2008/10/21 21:31:10 brad Exp $	*/
a85 4

#if !defined(MPBIOS) && !defined(MPACPI)
#error "ioapic needs at least one of the MPBIOS or MPACPI options"
#endif
@


1.15
log
@style nits.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.14 2008/09/15 19:19:45 kettenis Exp $	*/
d374 1
a374 1
		for (i=0; i<sc->sc_apic_sz; i++)
@


1.14
log
@Make this compile if !MULTIPROCESSOR.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.13 2008/06/26 05:42:09 ray Exp $	*/
d353 1
a353 1
	for (i=0; i<sc->sc_apic_sz; i++) {
d496 1
a496 1
	if (ioapic_cold) {
a497 1
	}
@


1.13
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.12 2007/02/22 19:46:16 marco Exp $	*/
d125 1
d127 1
d134 1
d136 1
d314 1
d316 1
@


1.12
log
@Revert my previous commit.  Kettenis no likey.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.11 2007/02/22 03:47:15 marco Exp $	*/
a20 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.11
log
@Print base so that we can make a correct mapping between apic and irq.

ok jordan
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.10 2007/01/24 20:47:45 kettenis Exp $	*/
d346 1
a346 2
	printf(", version %x, pins %d, base %d\n", sc->sc_apic_vers,
	    sc->sc_apic_sz, sc->sc_apic_vecbase);
@


1.10
log
@Actually establish interrupt handler in !ioapic_cold case.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.9 2007/01/15 23:19:05 jsg Exp $	*/
d346 2
a347 1
	printf(", version %x, %d pins\n", sc->sc_apic_vers, sc->sc_apic_sz);
@


1.9
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.8 2006/03/06 20:51:46 kettenis Exp $	*/
d514 5
a518 5
	if (ioapic_cold) {
		pp = &sc->sc_pins[pin];
		pp->ip_type = type;
		pp->ip_vector = idtvec;
		pp->ip_cpu = ci;
a519 1
	}
@


1.8
log
@Remove accidentally committed debug printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.7 2006/03/06 19:10:06 kettenis Exp $	*/
d382 1
a382 1
	       struct cpu_info *ci)
d509 1
a509 2
		int idtvec, int type)

d526 1
a526 1
		int idtvec, int type)
@


1.7
log
@Synch bits of the i386 and amd64 ioapic code.
Make ioapic redirect register writes atomic on amd64 just like on i386.
ok niklas@@, grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.6 2005/05/31 09:34:22 art Exp $	*/
a515 1
		printf("ioapic_addroute: pin %d\n", pin);
@


1.6
log
@Lock the apic with a mutex, not a SIMPLE_LOCK.

markus@@ ok
miod@@ tried to ok, but he doesn't officially have an amd64.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.5 2005/05/29 03:20:36 deraadt Exp $	*/
d123 2
d264 18
d301 1
a301 1
		printf(": duplicate apic id (ignored)\n");
d306 2
a307 2
	
	printf(": pa 0x%lx", sc->sc_pic.pic_dev.dv_xname, aaa->apic_address);
d310 1
a310 1
		printf(": map failed\n");
a324 1
	apic_id = (ioapic_read(sc,IOAPIC_ID)&IOAPIC_ID_MASK)>>IOAPIC_ID_SHIFT;
a325 1
	
d345 1
a345 1
	
d348 3
d360 1
a360 1
	
d368 1
a368 1
		printf("%s: misconfigured as apic %d\n",
d370 1
a370 16

		ioapic_write(sc,IOAPIC_ID,
		    (ioapic_read(sc,IOAPIC_ID)&~IOAPIC_ID_MASK)
		    |(sc->sc_apicid<<IOAPIC_ID_SHIFT));
		
		apic_id = (ioapic_read(sc,IOAPIC_ID)&IOAPIC_ID_MASK)>>IOAPIC_ID_SHIFT;
		
		if (apic_id != sc->sc_apicid) {
			printf("%s: can't remap to apid %d\n",
			    sc->sc_pic.pic_dev.dv_xname,
			    sc->sc_apicid);
		} else {
			printf("%s: remapped to apic %d\n",
			    sc->sc_pic.pic_dev.dv_xname,
			    sc->sc_apicid);
		}
d393 1
a393 1
	redlo = map == NULL ? IOAPIC_REDLO_MASK : map->redir;
d404 1
a404 1
		redlo |= (IOAPIC_REDLO_DEL_FIXED<<IOAPIC_REDLO_DEL_SHIFT);
d406 1
a406 1
		
d430 3
a433 1
	ioapic_write(sc, IOAPIC_REDHI(pin), redhi);
d460 1
a460 1
			
d462 3
d516 1
@


1.5
log
@sched work by niklas and art backed out; causes panics
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.3 2004/06/27 16:17:50 deraadt Exp $	*/
d130 1
a130 1
	SIMPLE_LOCK(&sc->sc_pic.pic_lock);
d137 1
a137 1
	SIMPLE_UNLOCK(&sc->sc_pic.pic_lock);
d297 1
a297 1
	SIMPLE_LOCK_INIT(&sc->sc_pic.pic_lock);
@


1.4
log
@This patch is mortly art's work and was done *a year* ago.  Art wants to thank
everyone for the prompt review and ok of this work ;-)  Yeah, that includes me
too, or maybe especially me.  I am sorry.

Change the sched_lock to a mutex. This fixes, among other things, the infamous
"telnet localhost &" problem.  The real bug in that case was that the sched_lock
which is by design a non-recursive lock, was recursively acquired, and not
enough releases made us hold the lock in the idle loop, blocking scheduling
on the other processors.  Some of the other processors would hold the biglock though,
which made it impossible for cpu 0 to enter the kernel...  A nice deadlock.
Let me just say debugging this for days just to realize that it was all fixed
in an old diff noone ever ok'd was somewhat of an anti-climax.

This diff also changes splsched to be correct for all our architectures.
@
text
@d130 1
a130 1
	mtx_enter(&sc->sc_pic.pic_mutex);
d137 1
a137 1
	mtx_leave(&sc->sc_pic.pic_mutex);
d297 1
a297 1
	mtx_init(&sc->sc_pic.pic_mutex, IPL_NONE);
@


1.3
log
@quieter boot requested by art
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.2 2004/06/25 11:31:21 deraadt Exp $	*/
d130 1
a130 1
	SIMPLE_LOCK(&sc->sc_pic.pic_lock);
d137 1
a137 1
	SIMPLE_UNLOCK(&sc->sc_pic.pic_lock);
d297 1
a297 1
	SIMPLE_LOCK_INIT(&sc->sc_pic.pic_lock);
@


1.2
log
@pretty
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.1 2004/06/25 11:03:27 art Exp $	*/
d347 2
a348 1
		printf("%s: misconfigured as apic %d\n", sc->sc_pic.pic_dev.dv_xname, apic_id);
a453 2
		printf("%s: enabling\n", sc->sc_pic.pic_dev.dv_xname);

@


1.1
log
@SMP support. Big parts from NetBSD, but with some really serious debugging
done by me, niklas and others. Especially wrt. NXE support.

Still needs some polishing, especially in dmesg messages, but we're now
building kernel faster than ever.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d278 1
a278 1
	printf(" apid %d (I/O APIC)\n", aaa->apic_id);
d281 1
a281 2
		printf("%s: duplicate apic id (ignored)\n",
		    sc->sc_pic.pic_dev.dv_xname);
d287 1
a287 1
	printf("%s: pa 0x%lx", sc->sc_pic.pic_dev.dv_xname, aaa->apic_address);
@

