head	1.8;
access;
symbols
	OPENBSD_6_0:1.8.0.4
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.6.0.16
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.8
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.12
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.10
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.6
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.14
	OPENBSD_5_0:1.5.0.12
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.10
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.8
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.4
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.6
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.2
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.4.0.2
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.3.0.8
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.6
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.4
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.2
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.2.0.14
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.10
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.8
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.6
	OPENBSD_3_6_BASE:1.2
	SMP_SYNC_A:1.2
	SMP_SYNC_B:1.2
	OPENBSD_3_5:1.2.0.4
	OPENBSD_3_5_BASE:1.2
	SMP:1.2.0.2;
locks; strict;
comment	@ * @;


1.8
date	2016.02.03.03.25.07;	author guenther;	state Exp;
branches;
next	1.7;
commitid	ApB7haYYMOab9uut;

1.7
date	2015.11.13.07.52.20;	author mlarkin;	state Exp;
branches;
next	1.6;
commitid	KdsjYlqLpqhwOUHf;

1.6
date	2012.03.16.01.53.00;	author haesbaert;	state Exp;
branches;
next	1.5;

1.5
date	2009.02.16.15.50.05;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2008.06.26.05.42.09;	author ray;	state Exp;
branches;
next	1.3;

1.3
date	2006.05.09.13.02.29;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.09.22.15.52;	author mickey;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2004.01.28.01.39.38;	author mickey;	state Exp;
branches;
next	;

1.2.2.1
date	2004.02.22.22.08.18;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2004.06.05.23.09.24;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Test cpuid_level or ci->ci_pnfeatset before using a CPUID leaf; some BIOSes
can disable leaves that CPU feature flags would seem to imply.  Corrects
signal delivery on systems where the AVX leaf is disabled.

report and debugging help from Marcus MERIGHI (mcmer-openbsd (at) tor.at)
ok kettenis@@
@
text
@/*	$OpenBSD: cacheinfo.c,v 1.7 2015/11/13 07:52:20 mlarkin Exp $	*/

/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>

#include <machine/cpu.h>
#include <machine/specialreg.h>

static char *print_cache_config(struct cpu_info *, int, char *, char *);
static char *print_tlb_config(struct cpu_info *, int, char *, char *);

static char *
print_cache_config(struct cpu_info *ci, int cache_tag, char *name, char *sep)
{
	struct x86_cache_info *cai = &ci->ci_cinfo[cache_tag];

	if (cai->cai_totalsize == 0)
		return sep;

	if (sep == NULL)
		printf("%s: ", ci->ci_dev->dv_xname);
	else
		printf("%s", sep);

	if (cai->cai_string != NULL)
		printf("%s ", cai->cai_string);
	else if (cai->cai_totalsize >= 1024*1024)
		printf("%dMB %db/line ", cai->cai_totalsize / 1024 / 1024,
		    cai->cai_linesize);
	else
		printf("%dKB %db/line ", cai->cai_totalsize / 1024,
		    cai->cai_linesize);

	switch (cai->cai_associativity) {
	case    0:
		printf("disabled");
		break;
	case    1:
		printf("direct-mapped");
		break;
	case 0xff:
		printf("fully associative");
		break;
	default:
		printf("%d-way", cai->cai_associativity);
		break;
	}

	if (name != NULL)
		printf(" %s", name);

	return ", ";
}

static char *
print_tlb_config(struct cpu_info *ci, int cache_tag, char *name, char *sep)
{
	struct x86_cache_info *cai = &ci->ci_cinfo[cache_tag];

	if (cai->cai_totalsize == 0)
		return sep;

	if (sep == NULL)
		printf("%s: ", ci->ci_dev->dv_xname);
	else
		printf("%s", sep);
	if (name != NULL)
		printf("%s ", name);

	if (cai->cai_string != NULL) {
		printf("%s", cai->cai_string);
	} else {
		if (cai->cai_linesize >= 1024*1024)
			printf("%d %dMB entries ", cai->cai_totalsize,
			    cai->cai_linesize / 1024 / 1024);
		else
			printf("%d %dKB entries ", cai->cai_totalsize,
			    cai->cai_linesize / 1024);
		switch (cai->cai_associativity) {
		case 0:
			printf("disabled");
			break;
		case 1:
			printf("direct-mapped");
			break;
		case 0xff:
			printf("fully associative");
			break;
		default:
			printf("%d-way", cai->cai_associativity);
			break;
		}
	}
	return ", ";
}

const struct x86_cache_info *
cache_info_lookup(const struct x86_cache_info *cai, u_int8_t desc)
{
	int i;

	for (i = 0; cai[i].cai_desc != 0; i++) {
		if (cai[i].cai_desc == desc)
			return (&cai[i]);
	}

	return (NULL);
}


static const struct x86_cache_info amd_cpuid_l2cache_assoc_info[] = {
	{ 0, 0x01,    1 },
	{ 0, 0x02,    2 },
	{ 0, 0x04,    4 },
	{ 0, 0x06,    8 },
	{ 0, 0x08,   16 },
	{ 0, 0x0a,   32 },
	{ 0, 0x0b,   48 },
	{ 0, 0x0c,   64 },
	{ 0, 0x0d,   96 },
	{ 0, 0x0e,  128 },
	{ 0, 0x0f, 0xff },
	{ 0, 0x00,    0 },
};

void
amd_cpu_cacheinfo(struct cpu_info *ci)
{
	const struct x86_cache_info *cp;
	struct x86_cache_info *cai;
	int family, model;
	u_int descs[4];

	family = ci->ci_family;
	model = ci->ci_model;

	/*
	 * K5 model 0 has none of this info.
	 */
	if (family == 5 && model == 0)
		return;

	/*
	 * Determine L1 cache/TLB info.
	 */
	if (ci->ci_pnfeatset < 0x80000005) {
		/* No L1 cache info available. */
		return;
	}

	CPUID(0x80000005, descs[0], descs[1], descs[2], descs[3]);
	ci->ci_amdcacheinfo[0] = descs[0];
	ci->ci_amdcacheinfo[1] = descs[1];
	ci->ci_amdcacheinfo[2] = descs[2];
	ci->ci_amdcacheinfo[3] = descs[3];

	/*
	 * K6-III and higher have large page TLBs.
	 */
	if ((family == 5 && model >= 9) || family >= 6) {
		cai = &ci->ci_cinfo[CAI_ITLB2];
		cai->cai_totalsize = AMD_L1_EAX_ITLB_ENTRIES(descs[0]);
		cai->cai_associativity = AMD_L1_EAX_ITLB_ASSOC(descs[0]);
		cai->cai_linesize = (4 * 1024 * 1024);

		cai = &ci->ci_cinfo[CAI_DTLB2];
		cai->cai_totalsize = AMD_L1_EAX_DTLB_ENTRIES(descs[0]);
		cai->cai_associativity = AMD_L1_EAX_DTLB_ASSOC(descs[0]);
		cai->cai_linesize = (4 * 1024 * 1024);
	}

	cai = &ci->ci_cinfo[CAI_ITLB];
	cai->cai_totalsize = AMD_L1_EBX_ITLB_ENTRIES(descs[1]);
	cai->cai_associativity = AMD_L1_EBX_ITLB_ASSOC(descs[1]);
	cai->cai_linesize = (4 * 1024);

	cai = &ci->ci_cinfo[CAI_DTLB];
	cai->cai_totalsize = AMD_L1_EBX_DTLB_ENTRIES(descs[1]);
	cai->cai_associativity = AMD_L1_EBX_DTLB_ASSOC(descs[1]);
	cai->cai_linesize = (4 * 1024);

	cai = &ci->ci_cinfo[CAI_DCACHE];
	cai->cai_totalsize = AMD_L1_ECX_DC_SIZE(descs[2]);
	cai->cai_associativity = AMD_L1_ECX_DC_ASSOC(descs[2]);
	cai->cai_linesize = AMD_L1_EDX_IC_LS(descs[2]);

	cai = &ci->ci_cinfo[CAI_ICACHE];
	cai->cai_totalsize = AMD_L1_EDX_IC_SIZE(descs[3]);
	cai->cai_associativity = AMD_L1_EDX_IC_ASSOC(descs[3]);
	cai->cai_linesize = AMD_L1_EDX_IC_LS(descs[3]);

	/*
	 * Determine L2 cache/TLB info.
	 */
	if (ci->ci_pnfeatset < 0x80000006) {
		/* No L2 cache info available. */
		return;
	}

	CPUID(0x80000006, descs[0], descs[1], descs[2], descs[3]);
	ci->ci_extcacheinfo[0] = descs[0];
	ci->ci_extcacheinfo[1] = descs[1];
	ci->ci_extcacheinfo[2] = descs[2];
	ci->ci_extcacheinfo[3] = descs[3];

	cai = &ci->ci_cinfo[CAI_L2CACHE];
	cai->cai_totalsize = AMD_L2_ECX_C_SIZE(descs[2]);
	cai->cai_associativity = AMD_L2_ECX_C_ASSOC(descs[2]);
	cai->cai_linesize = AMD_L2_ECX_C_LS(descs[2]);

	cp = cache_info_lookup(amd_cpuid_l2cache_assoc_info,
	    cai->cai_associativity);
	if (cp != NULL)
		cai->cai_associativity = cp->cai_associativity;
	else
		cai->cai_associativity = 0;	/* XXX Unknown/reserved */

	/*
	 * Determine L3 cache, Intel is different
	 */
	if (!strcmp(cpu_vendor, "AuthenticAMD") && family >= 0xf) {
		cai = &ci->ci_cinfo[CAI_L3CACHE];
		cai->cai_totalsize = AMD_L3_EDX_C_SIZE(descs[3]);
		cai->cai_associativity = AMD_L3_EDX_C_ASSOC(descs[3]);
		cai->cai_linesize = AMD_L3_EDX_C_LS(descs[3]);
		cp = cache_info_lookup(amd_cpuid_l2cache_assoc_info,
		    cai->cai_associativity);
		if (cp != NULL)
			cai->cai_associativity = cp->cai_associativity;
		else
			cai->cai_associativity = 0;	/* XXX Unknown/reserved */
	}
}

void
x86_print_cacheinfo(struct cpu_info *ci)
{
	char *sep;
	
	sep = print_cache_config(ci, CAI_ICACHE, "I-cache", NULL);
	sep = print_cache_config(ci, CAI_DCACHE, "D-cache", sep);
	sep = print_cache_config(ci, CAI_L2CACHE, "L2 cache", sep);
	sep = print_cache_config(ci, CAI_L3CACHE, "L3 cache", sep);
	if (sep != NULL)
		printf("\n");
	sep = print_tlb_config(ci, CAI_ITLB, "ITLB", NULL);
	sep = print_tlb_config(ci, CAI_ITLB2, NULL, sep);
	if (sep != NULL)
		printf("\n");
	sep = print_tlb_config(ci, CAI_DTLB, "DTLB", NULL);
	sep = print_tlb_config(ci, CAI_DTLB2, NULL, sep);
	if (sep != NULL)
		printf("\n");
}
@


1.7
log
@
vmm(4) kernel code

circulated on hackers@@, no objections. Disabled by default.
@
text
@d1 1
a1 1
/*	$OpenBSD: cacheinfo.c,v 1.6 2012/03/16 01:53:00 haesbaert Exp $	*/
a161 1
	u_int lfunc;
a172 6
	 * Determine the largest extended function value.
	 */
	CPUID(0x80000000, descs[0], descs[1], descs[2], descs[3]);
	lfunc = descs[0];

	/*
d175 1
a175 1
	if (lfunc < 0x80000005) {
d224 1
a224 1
	if (lfunc < 0x80000006) {
@


1.6
log
@Display L3 cache information on amd64 for amd cpus, Intel now uses a
different scheme.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cacheinfo.c,v 1.5 2009/02/16 15:50:05 jsg Exp $	*/
d188 4
d237 4
@


1.5
log
@Store conditionally extended cpuid family/model values
in seperate variables in struct cpu_info instead
of duplicating the process of extracting it from the signature.

Discussed with several, 'just do it' weingart@@, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cacheinfo.c,v 1.4 2008/06/26 05:42:09 ray Exp $	*/
d146 5
d245 16
d267 15
a281 24

	sep = NULL;
	if (ci->ci_cinfo[CAI_ICACHE].cai_totalsize != 0 ||
	    ci->ci_cinfo[CAI_DCACHE].cai_totalsize != 0) {
		sep = print_cache_config(ci, CAI_ICACHE, "I-cache", NULL);
		sep = print_cache_config(ci, CAI_DCACHE, "D-cache", sep);
	}
	if (ci->ci_cinfo[CAI_L2CACHE].cai_totalsize != 0) {
		sep = print_cache_config(ci, CAI_L2CACHE, "L2 cache", sep);
		if (sep != NULL)
			printf("\n");
	}
	if (ci->ci_cinfo[CAI_ITLB].cai_totalsize != 0) {
		sep = print_tlb_config(ci, CAI_ITLB, "ITLB", NULL);
		sep = print_tlb_config(ci, CAI_ITLB2, NULL, sep);
		if (sep != NULL)
			printf("\n");
	}
	if (ci->ci_cinfo[CAI_DTLB].cai_totalsize != 0) {
		sep = print_tlb_config(ci, CAI_DTLB, "DTLB", NULL);
		sep = print_tlb_config(ci, CAI_DTLB2, NULL, sep);
		if (sep != NULL)
			printf("\n");
	}
@


1.4
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cacheinfo.c,v 1.3 2006/05/09 13:02:29 mickey Exp $	*/
d159 2
a160 2
	family = (ci->ci_signature >> 8) & 15;
	model = CPUID2MODEL(ci->ci_signature);
a166 8

	/*
	 * Get extended values for K8 and up.
	 */
	if (family == 0xf) {
		family += (ci->ci_signature >> 20) & 0xff;
		model += (ci->ci_signature >> 16) & 0xf;
	}
@


1.3
log
@missing license; pt out by krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a17 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the NetBSD
 *      Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.2
log
@repair cpu dmesg print a bit
@
text
@d1 38
@


1.2.2.1
log
@The merge of these files were done to another date than the rest, fix.
@
text
@a21 2
	if (name != NULL)
		printf("%s ", name);
d23 1
a23 1
	if (cai->cai_string != NULL) {
d25 7
a31 3
	} else {
		printf("%d %db/line ", cai->cai_totalsize, cai->cai_linesize);
	}
d46 4
d71 6
a76 1
		printf("%d %d entries ", cai->cai_totalsize, cai->cai_linesize);
d224 1
a228 2
		if (sep != NULL)
			printf("\n");
d231 1
a231 1
		sep = print_cache_config(ci, CAI_L2CACHE, "L2 cache", NULL);
@


1.2.2.2
log
@Merge with the trunk
@
text
@d22 2
d25 1
a25 1
	if (cai->cai_string != NULL)
d27 3
a29 7
	else if (cai->cai_totalsize >= 1024*1024)
		printf("%dMB %db/line ", cai->cai_totalsize / 1024 / 1024,
		    cai->cai_linesize);
	else
		printf("%dKB %db/line ", cai->cai_totalsize / 1024,
		    cai->cai_linesize);

a43 4

	if (name != NULL)
		printf(" %s", name);

d65 1
a65 6
		if (cai->cai_linesize >= 1024*1024)
			printf("%d %dMB entries ", cai->cai_totalsize,
			    cai->cai_linesize / 1024 / 1024);
		else
			printf("%d %dKB entries ", cai->cai_totalsize,
			    cai->cai_linesize / 1024);
a212 1
	sep = NULL;
d217 2
d221 1
a221 1
		sep = print_cache_config(ci, CAI_L2CACHE, "L2 cache", sep);
@


1.1
log
@an amd64 arch support.
hacked by art@@ from netbsd sources and then later debugged
by me into the shape where it can host itself.
no bootloader yet as needs redoing from the
recent advanced i386 sources (anyone? ;)
@
text
@a21 2
	if (name != NULL)
		printf("%s ", name);
d23 1
a23 1
	if (cai->cai_string != NULL) {
d25 7
a31 3
	} else {
		printf("%d %db/line ", cai->cai_totalsize, cai->cai_linesize);
	}
d46 4
d71 6
a76 1
		printf("%d %d entries ", cai->cai_totalsize, cai->cai_linesize);
d224 1
a228 2
		if (sep != NULL)
			printf("\n");
d231 1
a231 1
		sep = print_cache_config(ci, CAI_L2CACHE, "L2 cache", NULL);
@

