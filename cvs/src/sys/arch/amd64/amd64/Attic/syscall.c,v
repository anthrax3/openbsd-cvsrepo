head	1.20;
access;
symbols
	OPENBSD_5_0:1.19.0.2
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.15.0.4
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.2
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.13.0.6
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.8
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.4
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.11.0.2
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.9.0.4
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.2
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.4
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.7.0.6
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.4
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	SMP:1.5.0.2;
locks; strict;
comment	@ * @;


1.20
date	2011.11.14.15.06.14;	author deraadt;	state dead;
branches;
next	1.19;

1.19
date	2011.07.11.15.40.47;	author guenther;	state Exp;
branches;
next	1.18;

1.18
date	2011.07.07.18.11.23;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2011.07.06.21.41.37;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2011.04.03.14.56.28;	author guenther;	state Exp;
branches;
next	1.15;

1.15
date	2010.06.26.23.24.43;	author guenther;	state Exp;
branches;
next	1.14;

1.14
date	2010.05.06.21.33.51;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2008.06.26.05.42.09;	author ray;	state Exp;
branches;
next	1.12;

1.12
date	2008.04.07.16.21.26;	author thib;	state Exp;
branches;
next	1.11;

1.11
date	2007.12.01.16.20.07;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2007.11.27.18.09.37;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.15.23.19.05;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2005.09.15.21.09.29;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.13.20.20.24;	author sturm;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.19.18.43.32;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.18.16.40.06;	author tdeval;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2004.02.09.19.14.27;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.09.14.11.09;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.07.08.00.33;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.28.01.39.39;	author mickey;	state Exp;
branches;
next	;

1.5.2.1
date	2004.02.22.22.08.18;	author niklas;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2004.06.05.23.09.24;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.20
log
@merge syscall.c into the end of trap.c as almost all architectures do.
@
text
@/*	$OpenBSD: syscall.c,v 1.19 2011/07/11 15:40:47 guenther Exp $	*/
/*	$NetBSD: syscall.c,v 1.1 2003/04/26 18:39:32 fvdl Exp $	*/

/*-
 * Copyright (c) 1998, 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Charles M. Hannum.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/signal.h>
#ifdef KTRACE
#include <sys/ktrace.h>
#endif

#include "systrace.h"
#include <dev/systrace.h>

#include <sys/syscall.h>

#include <uvm/uvm_extern.h>

#include <machine/cpu.h>
#include <machine/psl.h>
#include <machine/userret.h>

void syscall(struct trapframe *);

/*
 * syscall(frame):
 *	System call request from POSIX system call gate interface to kernel.
 */
void
syscall(struct trapframe *frame)
{
	caddr_t params;
	const struct sysent *callp;
	struct proc *p;
	int error;
	int nsys;
	size_t argsize, argoff;
	register_t code, args[9], rval[2], *argp;
	int lock;

	uvmexp.syscalls++;
	p = curproc;

	code = frame->tf_rax;
	callp = p->p_emul->e_sysent;
	nsys = p->p_emul->e_nsysent;
	argp = &args[0];
	argoff = 0;

	switch (code) {
	case SYS_syscall:
	case SYS___syscall:
		/*
		 * Code is first argument, followed by actual args.
		 */
		code = frame->tf_rdi;
		argp = &args[1];
		argoff = 1;
		break;
	default:
		break;
	}

	if (code < 0 || code >= nsys)
		callp += p->p_emul->e_nosys;
	else
		callp += code;

	argsize = (callp->sy_argsize >> 3) + argoff;
	if (argsize) {
		switch (MIN(argsize, 6)) {
		case 6:
			args[5] = frame->tf_r9;
		case 5:
			args[4] = frame->tf_r8;
		case 4:
			args[3] = frame->tf_r10;
		case 3:
			args[2] = frame->tf_rdx;
		case 2:	
			args[1] = frame->tf_rsi;
		case 1:
			args[0] = frame->tf_rdi;
			break;
		default:
			panic("impossible syscall argsize");
		}
		if (argsize > 6) {
			argsize -= 6;
			params = (caddr_t)frame->tf_rsp + sizeof(register_t);
			error = copyin(params, (caddr_t)&args[6],
					argsize << 3);
			if (error != 0)
				goto bad;
		}
	}

	lock = !(callp->sy_flags & SY_NOLOCK);

#ifdef SYSCALL_DEBUG
	KERNEL_LOCK();
	scdebug_call(p, code, argp);
	KERNEL_UNLOCK();
#endif
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSCALL)) {
		KERNEL_LOCK();
		ktrsyscall(p, code, callp->sy_argsize, argp);
		KERNEL_UNLOCK();
	}
#endif
	rval[0] = 0;
	rval[1] = frame->tf_rdx;
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE)) {
		KERNEL_LOCK();
		error = systrace_redirect(code, p, argp, rval);
		KERNEL_UNLOCK();
	} else
#endif
	{
		if (lock)
			KERNEL_LOCK();
		error = (*callp->sy_call)(p, argp, rval);
		if (lock)
			KERNEL_UNLOCK();
	}
	switch (error) {
	case 0:
		frame->tf_rax = rval[0];
		frame->tf_rdx = rval[1];
		frame->tf_rflags &= ~PSL_C;	/* carry bit */
		break;
	case ERESTART:
		/*
		 * The offset to adjust the PC by depends on whether we entered
		 * the kernel through the trap or call gate.  We pushed the
		 * size of the instruction into tf_err on entry.
		 */
		frame->tf_rip -= frame->tf_err;
		break;
	case EJUSTRETURN:
		/* nothing to do */
		break;
	default:
	bad:
		frame->tf_rax = error;
		frame->tf_rflags |= PSL_C;	/* carry bit */
		break;
	}

#ifdef SYSCALL_DEBUG
	KERNEL_LOCK();
	scdebug_ret(p, code, error, rval);
	KERNEL_UNLOCK();
#endif
	userret(p);
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET)) {
		KERNEL_LOCK();
		ktrsysret(p, code, error, rval[0]);
		KERNEL_UNLOCK();
	}
#endif
}

void
child_return(void *arg)
{
	struct proc *p = arg;
	struct trapframe *tf = p->p_md.md_regs;

	tf->tf_rax = 0;
	tf->tf_rdx = 1;
	tf->tf_rflags &= ~PSL_C;

	KERNEL_UNLOCK();

	userret(p);
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET)) {
		KERNEL_LOCK();
		ktrsysret(p,
		    (p->p_flag & P_THREAD) ? SYS_rfork :
		    (p->p_p->ps_flags & PS_PPWAIT) ? SYS_vfork : SYS_fork,
		    0, 0);
		KERNEL_UNLOCK();
	}
#endif
}
@


1.19
log
@Revert art@@'s moving around of the KERNEL_LOCK()/KERNEL_UNLOCK() calls,
as it causes hangs in some ports, including libsigsegv's configure script

confirmed by krw@@, landry@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.c,v 1.17 2011/07/06 21:41:37 art Exp $	*/
@


1.18
log
@There is a bunch of places in the kernel entry points where we don't
hold the kernel lock, but still need call one function that needs it.

Instead of grabbing the lock all over the place, move the locks into
the affected functions: trapsignal, scdebug*, ktrsyscall, ktrsysret,
systrace_redirect and ADDUPROF. In the cases we already hold the biglock
we'll just recurse.

kettenis@@, beck@@ ok
@
text
@d130 1
d132 1
d136 1
d138 1
d145 1
d147 1
d182 1
d184 1
d189 1
d191 1
d211 1
d216 1
@


1.17
log
@Clean up after P_BIGLOCK removal.
KERNEL_PROC_LOCK -> KERNEL_LOCK
KERNEL_PROC_UNLOCK -> KERNEL_UNLOCK

oga@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.c,v 1.16 2011/04/03 14:56:28 guenther Exp $	*/
a129 1
	KERNEL_LOCK();
a130 1
	KERNEL_UNLOCK();
a133 1
		KERNEL_LOCK();
a134 1
		KERNEL_UNLOCK();
a140 1
		KERNEL_LOCK();
a141 1
		KERNEL_UNLOCK();
a175 1
	KERNEL_LOCK();
a176 1
	KERNEL_UNLOCK();
a180 1
		KERNEL_LOCK();
a181 1
		KERNEL_UNLOCK();
a200 1
		KERNEL_LOCK();
a204 1
		KERNEL_UNLOCK();
@


1.16
log
@Move PPWAIT flag from struct proc to process, so that rthreads in
a vforked child behave correctly.  Have the parent in a vfork()
wait on a (different) flag in *its* process instead of the child
to prevent a possible use-after-free.  When ktracing the child
return from a fork, call it rfork if an rthread was created.

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.c,v 1.15 2010/06/26 23:24:43 guenther Exp $	*/
d130 1
a130 1
	KERNEL_PROC_LOCK(p);
d132 1
a132 1
	KERNEL_PROC_UNLOCK(p);
d136 1
a136 1
		KERNEL_PROC_LOCK(p);
d138 1
a138 1
		KERNEL_PROC_UNLOCK(p);
d145 1
a145 1
		KERNEL_PROC_LOCK(p);
d147 1
a147 1
		KERNEL_PROC_UNLOCK(p);
d152 1
a152 1
			KERNEL_PROC_LOCK(p);
d155 1
a155 1
			KERNEL_PROC_UNLOCK(p);
d182 1
a182 1
	KERNEL_PROC_LOCK(p);
d184 1
a184 1
	KERNEL_PROC_UNLOCK(p);
d189 1
a189 1
		KERNEL_PROC_LOCK(p);
d191 1
a191 1
		KERNEL_PROC_UNLOCK(p);
d206 1
a206 1
	KERNEL_PROC_UNLOCK(p);
d211 1
a211 1
		KERNEL_PROC_LOCK(p);
d216 1
a216 1
		KERNEL_PROC_UNLOCK(p);
@


1.15
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.c,v 1.14 2010/05/06 21:33:51 nicm Exp $	*/
d213 3
a215 1
		    (p->p_flag & P_PPWAIT) ? SYS_vfork : SYS_fork, 0, 0);
@


1.14
log
@Change trap() and syscall() to accept a pointer rather than using call
by reference for the trap frame, the infrastructure in locore.S for this
was already present.

This prevents gcc4 from optimising away stores into the frame and allows
a gcc4-compiled kernel to boot.

ok kettenis robert guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.c,v 1.13 2008/06/26 05:42:09 ray Exp $	*/
a35 1
#include <sys/user.h>
@


1.13
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.c,v 1.12 2008/04/07 16:21:26 thib Exp $	*/
d53 1
a53 1
void syscall(struct trapframe);
a57 1
 * Like trap(), argument is call by reference.
d60 1
a60 1
syscall(struct trapframe frame)
d74 1
a74 1
	code = frame.tf_rax;
d86 1
a86 1
		code = frame.tf_rdi;
d103 1
a103 1
			args[5] = frame.tf_r9;
d105 1
a105 1
			args[4] = frame.tf_r8;
d107 1
a107 1
			args[3] = frame.tf_r10;
d109 1
a109 1
			args[2] = frame.tf_rdx;
d111 1
a111 1
			args[1] = frame.tf_rsi;
d113 1
a113 1
			args[0] = frame.tf_rdi;
d120 1
a120 1
			params = (caddr_t)frame.tf_rsp + sizeof(register_t);
d143 1
a143 1
	rval[1] = frame.tf_rdx;
d160 3
a162 3
		frame.tf_rax = rval[0];
		frame.tf_rdx = rval[1];
		frame.tf_rflags &= ~PSL_C;	/* carry bit */
d170 1
a170 1
		frame.tf_rip -= frame.tf_err;
d177 2
a178 2
		frame.tf_rax = error;
		frame.tf_rflags |= PSL_C;	/* carry bit */
@


1.12
log
@Don't grab the kernel biglock for syscalls marked SY_NOLOCK;
make the amd64 code a bit nicer and make the sparc64 match that.

tested by a few;
OK toby@@, dlg@@, kettenis@@ (for the sparc64 part).
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.c,v 1.11 2007/12/01 16:20:07 art Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.11
log
@Don't be lazy in the locking in SYSCALL_DEBUG code.
KERNEL_PROC_UNLOCK is not safe for recursion (becuase it clears P_BIGLOCK)
so we have to make that lock conditional as well.

Found by tholo@@ when reviewing the i386 diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.c,v 1.10 2007/11/27 18:09:37 art Exp $	*/
d77 1
a77 1
	int nolock;
d136 1
a136 1
	nolock = (callp->sy_flags & SY_NOLOCK);
a137 2
	if (!nolock)
		KERNEL_PROC_LOCK(p);
d139 1
a139 2
	if (nolock)
		KERNEL_PROC_LOCK(p);
d141 1
a141 2
	if (nolock)
		KERNEL_PROC_UNLOCK(p);
d145 1
a145 2
		if (nolock)
			KERNEL_PROC_LOCK(p);
d147 1
a147 2
		if (nolock)
			KERNEL_PROC_UNLOCK(p);
a149 1

d154 1
a154 2
		if (nolock)
			KERNEL_PROC_LOCK(p);
d156 1
a156 2
		if (nolock)
			KERNEL_PROC_UNLOCK(p);
d159 3
d163 3
a165 2
	if (!nolock)
		KERNEL_PROC_UNLOCK(p);
@


1.10
log
@Implement the NOLOCK semantics. MPSAFE will have to wait a while until
we decide how to handle interrupts.

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.c,v 1.9 2007/01/15 23:19:05 jsg Exp $	*/
d141 2
a142 1
	KERNEL_PROC_LOCK(p);
d144 2
a145 1
	KERNEL_PROC_UNLOCK(p);
@


1.9
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.c,v 1.8 2005/09/15 21:09:29 miod Exp $	*/
d77 1
d136 5
a141 1
#ifdef SYSCALL_DEBUG
d143 1
d146 3
a148 1
	if (KTRPOINT(p, KTR_SYSCALL))
d150 3
d158 3
a160 1
	if (ISSET(p->p_flag, P_SYSTRACE))
d162 3
a164 1
	else
d167 2
a168 1
	KERNEL_PROC_UNLOCK(p);
@


1.8
log
@Change child_return() to record a proper ktrace record for vfork child
processes.

ok art@@ uwe@@ (some time ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.c,v 1.7 2004/05/13 20:20:24 sturm Exp $	*/
d68 1
a68 2
syscall(frame)
	struct trapframe frame;
@


1.7
log
@activate systrace on amd64, while here get rid of syscall_{plain,fancy}
instead use syscall() as everywhere else

ok mickey, tested and ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.c,v 1.6 2004/02/19 18:43:32 deraadt Exp $	*/
d209 2
a210 1
		ktrsysret(p, SYS_fork, 0, 0);
@


1.6
log
@correct pointer to args
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.c,v 1.5 2004/02/18 16:40:06 tdeval Exp $	*/
d48 4
a51 3
#ifdef SYSTRACE
#include <sys/systrace.h>
#endif
d60 1
a60 22
void syscall_intern(struct proc *);
void syscall_plain(struct trapframe);
void syscall_fancy(struct trapframe);

void
syscall_intern(p)
	struct proc *p;
{
#ifdef KTRACE
	if (p->p_traceflag & (KTRFAC_SYSCALL | KTRFAC_SYSRET)) {
		p->p_md.md_syscall = syscall_fancy;
		return;
	}
#endif
#ifdef SYSTRACE
	if (ISSET(p->p_flag, P_SYSTRACE)) {
		p->p_md.md_syscall = syscall_fancy;
		return;
	} 
#endif
	p->p_md.md_syscall = syscall_plain;
}
d68 1
a68 111
syscall_plain(frame)
	struct trapframe frame;
{
	caddr_t params;
	const struct sysent *callp;
	struct proc *p;
	int error;
	int nsys;
	size_t argsize, argoff;
	register_t code, args[9], rval[2], *argp;


	uvmexp.syscalls++;
	p = curproc;

	code = frame.tf_rax;
	nsys = p->p_emul->e_nsysent;
	callp = p->p_emul->e_sysent;
	argoff = 0;
	argp = &args[0];

	switch (code) {
	case SYS_syscall:
	case SYS___syscall:
		/*
		 * Code is first argument, followed by actual args.
		 */
		code = frame.tf_rdi;
		argp = &args[1];
		argoff = 1;
		break;
	default:
		break;
	}

	if (code < 0 || code >= nsys)
		callp += p->p_emul->e_nosys;
	else
		callp += code;

	argsize = (callp->sy_argsize >> 3) + argoff;
	if (argsize) {
		switch (MIN(argsize, 6)) {
		case 6:
			args[5] = frame.tf_r9;
		case 5:
			args[4] = frame.tf_r8;
		case 4:
			args[3] = frame.tf_r10;
		case 3:
			args[2] = frame.tf_rdx;
		case 2:	
			args[1] = frame.tf_rsi;
		case 1:
			args[0] = frame.tf_rdi;
			break;
		default:
			panic("impossible syscall argsize");
		}
		if (argsize > 6) {
			argsize -= 6;
			params = (caddr_t)frame.tf_rsp + sizeof(register_t);
			error = copyin(params, (caddr_t)&args[6],
					argsize << 3);
			if (error != 0)
				goto bad;
		}
	}

#ifdef SYSCALL_DEBUG
	scdebug_call(p, code, argp);
#endif /* SYSCALL_DEBUG */

	rval[0] = 0;
	rval[1] = frame.tf_rdx;
	KERNEL_PROC_LOCK(p);
	error = (*callp->sy_call)(p, argp, rval);
	KERNEL_PROC_UNLOCK(p);

	switch (error) {
	case 0:
		frame.tf_rax = rval[0];
		frame.tf_rdx = rval[1];
		frame.tf_rflags &= ~PSL_C;	/* carry bit */
		break;
	case ERESTART:
		/*
		 * The offset to adjust the PC by depends on whether we entered
		 * the kernel through the trap or call gate.  We pushed the
		 * size of the instruction into tf_err on entry.
		 */
		frame.tf_rip -= frame.tf_err;
		break;
	case EJUSTRETURN:
		/* nothing to do */
		break;
	default:
	bad:
		frame.tf_rax = error;
		frame.tf_rflags |= PSL_C;	/* carry bit */
		break;
	}

#ifdef SYSCALL_DEBUG
	scdebug_ret(p, code, error, rval);
#endif /* SYSCALL_DEBUG */
	userret(p);
}

void
syscall_fancy(frame)
d138 1
a138 1
	scdebug_call(p, code, args);
d149 2
a150 1
		error = systrace_redirect(code, p, args, rval);
@


1.5
log
@Stealth typo. ok deraadt@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.c,v 1.4 2004/02/09 19:14:27 mickey Exp $	*/
d272 1
a272 1
		ktrsyscall(p, code, callp->sy_argsize, args);
@


1.5.2.1
log
@The merge of these files were done to another date than the rest, fix.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d162 1
a162 1
	rval[1] = 0;
d272 1
a272 1
		ktrsyscall(p, code, argsize, args);
d276 1
a276 1
	rval[1] = 0;
d329 1
d332 1
a332 1
	KERNEL_PROC_UNLOCK(l);
@


1.5.2.2
log
@Merge with the trunk
@
text
@d48 3
a50 4

#include "systrace.h"
#include <dev/systrace.h>

d59 22
a80 1
void syscall(struct trapframe);
d88 111
a198 1
syscall(frame)
d268 1
a268 1
	scdebug_call(p, code, argp);
d272 1
a272 1
		ktrsyscall(p, code, callp->sy_argsize, argp);
d276 1
a276 1
	rval[1] = frame.tf_rdx;
d279 1
a279 2
		error = systrace_redirect(code, p, argp, rval);
	else
a328 1
	tf->tf_rdx = 1;
d331 1
a331 1
	KERNEL_PROC_UNLOCK(p);
@


1.4
log
@duh. there are two syscall entry points and both have to preserve rdx. also make sure child process gets 1 in rdx as libc expects
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.c,v 1.3 2004/02/09 14:11:09 mickey Exp $	*/
d332 1
a332 1
	KERNEL_PROC_UNLOCK(l);
@


1.3
log
@preserve high word of return value like other archs do
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.c,v 1.2 2004/02/07 08:00:33 deraadt Exp $	*/
d276 1
a276 1
	rval[1] = 0;
d329 1
@


1.2
log
@pass correct argument count to ktrsyscall(); now ktrace & kdump work
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall.c,v 1.1 2004/01/28 01:39:39 mickey Exp $	*/
d162 1
a162 1
	rval[1] = 0;
@


1.1
log
@an amd64 arch support.
hacked by art@@ from netbsd sources and then later debugged
by me into the shape where it can host itself.
no bootloader yet as needs redoing from the
recent advanced i386 sources (anyone? ;)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d272 1
a272 1
		ktrsyscall(p, code, argsize, args);
@

