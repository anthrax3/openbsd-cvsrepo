head	1.48;
access;
symbols
	OPENBSD_6_1:1.48.0.6
	OPENBSD_6_1_BASE:1.48
	OPENBSD_6_0:1.48.0.2
	OPENBSD_6_0_BASE:1.48
	OPENBSD_5_9:1.47.0.2
	OPENBSD_5_9_BASE:1.47
	OPENBSD_5_8:1.43.0.4
	OPENBSD_5_8_BASE:1.43
	OPENBSD_5_7:1.40.0.2
	OPENBSD_5_7_BASE:1.40
	OPENBSD_5_6:1.37.0.4
	OPENBSD_5_6_BASE:1.37
	OPENBSD_5_5:1.35.0.6
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.35.0.2
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.32.0.2
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.31.0.4
	OPENBSD_5_2_BASE:1.31
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.2
	OPENBSD_5_0:1.29.0.2
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.26.0.2
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.24.0.4
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.24.0.2
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.22.0.6
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.2
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.17.0.2
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.15.0.2
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.14.0.2
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.13.0.2
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.4
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.6.0.4
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	OPENBSD_3_5:1.1.0.4
	OPENBSD_3_5_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.48
date	2016.06.22.01.12.38;	author mikeb;	state Exp;
branches;
next	1.47;
commitid	aoZwpavraFkBTbjg;

1.47
date	2015.12.08.19.45.55;	author mikeb;	state Exp;
branches;
next	1.46;
commitid	k3df0wPG0WyTVD3t;

1.46
date	2015.09.13.11.48.17;	author kettenis;	state Exp;
branches;
next	1.45;
commitid	bJgsm4dAHZIpVv3F;

1.45
date	2015.08.28.16.16.44;	author tedu;	state Exp;
branches;
next	1.44;
commitid	gZ1Bbd6wHX8SUrB3;

1.44
date	2015.08.28.00.03.53;	author deraadt;	state Exp;
branches;
next	1.43;
commitid	NdgfPIGUgJxQPnT7;

1.43
date	2015.07.16.05.10.14;	author guenther;	state Exp;
branches;
next	1.42;
commitid	vUE3LzynpntlHxEC;

1.42
date	2015.04.24.02.22.08;	author jsg;	state Exp;
branches;
next	1.41;
commitid	MOWfHvngdSMoBbZz;

1.41
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.40;
commitid	p4LJxGKbi0BU2cG6;

1.40
date	2015.01.06.12.50.47;	author dlg;	state Exp;
branches;
next	1.39;
commitid	EAvvmUR28EGEqQFd;

1.39
date	2014.12.02.18.13.10;	author tedu;	state Exp;
branches;
next	1.38;
commitid	ZYUxNRICiD9sC1vn;

1.38
date	2014.09.14.14.17.23;	author jsg;	state Exp;
branches;
next	1.37;
commitid	uzzBR7hz9ncd4O6G;

1.37
date	2014.07.12.18.44.41;	author tedu;	state Exp;
branches;
next	1.36;
commitid	uKVPYMN2MLxdZxzH;

1.36
date	2014.03.29.18.09.28;	author guenther;	state Exp;
branches;
next	1.35;

1.35
date	2013.06.26.19.53.50;	author kettenis;	state Exp;
branches;
next	1.34;

1.34
date	2013.05.16.16.20.00;	author kettenis;	state Exp;
branches;
next	1.33;

1.33
date	2013.05.12.14.15.31;	author ratchov;	state Exp;
branches;
next	1.32;

1.32
date	2012.12.05.23.20.10;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2011.10.29.19.17.30;	author kettenis;	state Exp;
branches;
next	1.30;

1.30
date	2011.10.21.20.48.11;	author kettenis;	state Exp;
branches;
next	1.29;

1.29
date	2011.06.16.19.46.39;	author kettenis;	state Exp;
branches;
next	1.28;

1.28
date	2011.05.28.21.10.40;	author kettenis;	state Exp;
branches;
next	1.27;

1.27
date	2011.04.16.00.40.56;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2010.12.27.20.22.23;	author guenther;	state Exp;
branches;
next	1.25;

1.25
date	2010.09.20.06.33.46;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	2010.03.01.20.36.32;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2009.08.22.02.54.50;	author mk;	state Exp;
branches;
next	1.22;

1.22
date	2008.12.06.19.59.38;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2008.12.06.14.36.49;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2008.12.06.04.31.24;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2008.10.22.19.53.31;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2008.10.09.18.35.38;	author chl;	state Exp;
branches;
next	1.17;

1.17
date	2008.04.28.18.09.00;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2008.04.25.19.27.36;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2007.09.17.15.34.38;	author chl;	state Exp;
branches;
next	1.14;

1.14
date	2007.05.10.17.59.23;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2007.01.15.23.19.05;	author jsg;	state Exp;
branches;
next	1.12;

1.12
date	2006.01.22.04.52.23;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2005.09.25.20.48.18;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2005.07.26.08.07.39;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2005.07.18.02.43.24;	author fgsch;	state Exp;
branches;
next	1.8;

1.8
date	2005.05.28.05.15.18;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	2005.04.26.20.56.59;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.10.14.21.40;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.28.02.14.11;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.28.01.52.24;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.26.05.29.17;	author art;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.25.11.03.27;	author art;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.28.01.39.38;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.48
log
@Setup Hyper-V hypercall page and an IDT vector.

ok mlarkin, kettenis, deraadt
@
text
@/*	$OpenBSD: intr.c,v 1.47 2015/12/08 19:45:55 mikeb Exp $	*/
/*	$NetBSD: intr.c,v 1.3 2003/03/03 22:16:20 fvdl Exp $	*/

/*
 * Copyright 2002 (c) Wasabi Systems, Inc.
 * All rights reserved.
 *
 * Written by Frank van der Linden for Wasabi Systems, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed for the NetBSD Project by
 *      Wasabi Systems, Inc.
 * 4. The name of Wasabi Systems, Inc. may not be used to endorse
 *    or promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/* #define	INTRDEBUG */

#include <sys/param.h> 
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/syslog.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/errno.h>

#include <machine/atomic.h>
#include <machine/i8259.h>
#include <machine/cpu.h>
#include <machine/pio.h>
#include <machine/cpufunc.h>

#include "ioapic.h"
#include "lapic.h"
#include "xen.h"
#include "hyperv.h"

#if NIOAPIC > 0
#include <machine/mpbiosvar.h>
#endif

#if NLAPIC > 0
#include <machine/i82489var.h>
#endif

struct pic softintr_pic = {
        {0, {NULL}, NULL, 0, "softintr_pic0", NULL, 0, 0},
        PIC_SOFT,
#ifdef MULTIPROCESSOR
	{},
#endif
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
};

/*
 * Fill in default interrupt table (in case of spurious interrupt
 * during configuration of kernel), setup interrupt control unit
 */
void
intr_default_setup(void)
{
	int i;

	/* icu vectors */
	for (i = 0; i < NUM_LEGACY_IRQS; i++) {
		idt_allocmap[ICU_OFFSET + i] = 1;
		setgate(&idt[ICU_OFFSET + i],
		    i8259_stubs[i].ist_entry, 0, SDT_SYS386IGT,
		    SEL_KPL, GSEL(GCODE_SEL, SEL_KPL));
	}

	/*
	 * Eventually might want to check if it's actually there.
	 */
	i8259_default_setup();
}

/*
 * Handle a NMI, possibly a machine check.
 * return true to panic system, false to ignore.
 */
int
x86_nmi(void)
{
	log(LOG_CRIT, "NMI port 61 %x, port 70 %x\n", inb(0x61), inb(0x70));
	return(0);
}

/*
 * Recalculate the interrupt masks from scratch.
 */
void
intr_calculatemasks(struct cpu_info *ci)
{
	int irq, level;
	u_int64_t unusedirqs, intrlevel[MAX_INTR_SOURCES];
	struct intrhand *q;

	/* First, figure out which levels each IRQ uses. */
	unusedirqs = 0xffffffffffffffffUL;
	for (irq = 0; irq < MAX_INTR_SOURCES; irq++) {
		int levels = 0;

		if (ci->ci_isources[irq] == NULL) {
			intrlevel[irq] = 0;
			continue;
		}
		for (q = ci->ci_isources[irq]->is_handlers; q; q = q->ih_next)
			levels |= (1 << q->ih_level);
		intrlevel[irq] = levels;
		if (levels)
			unusedirqs &= ~(1UL << irq);
	}

	/* Then figure out which IRQs use each level. */
	for (level = 0; level < NIPL; level++) {
		u_int64_t irqs = 0;
		for (irq = 0; irq < MAX_INTR_SOURCES; irq++)
			if (intrlevel[irq] & (1 << level))
				irqs |= (1UL << irq);
		ci->ci_imask[level] = irqs | unusedirqs;
	}

	for (level = 0; level< (NIPL - 1); level++)
		ci->ci_imask[level + 1] |= ci->ci_imask[level];

	for (irq = 0; irq < MAX_INTR_SOURCES; irq++) {
		int maxlevel = IPL_NONE;
		int minlevel = IPL_HIGH;

		if (ci->ci_isources[irq] == NULL)
			continue;
		for (q = ci->ci_isources[irq]->is_handlers; q;
		     q = q->ih_next) {
			if (q->ih_level < minlevel)
				minlevel = q->ih_level;
			if (q->ih_level > maxlevel)
				maxlevel = q->ih_level;
		}
		ci->ci_isources[irq]->is_maxlevel = maxlevel;
		ci->ci_isources[irq]->is_minlevel = minlevel;
	}

	for (level = 0; level < NIPL; level++)
		ci->ci_iunmask[level] = ~ci->ci_imask[level];
}

int
intr_allocate_slot_cpu(struct cpu_info *ci, struct pic *pic, int pin,
    int *index)
{
	int start, slot, i;
	struct intrsource *isp;

	start = CPU_IS_PRIMARY(ci) ? NUM_LEGACY_IRQS : 0;
	slot = -1;

	for (i = 0; i < start; i++) {
		isp = ci->ci_isources[i];
		if (isp != NULL && isp->is_pic == pic && isp->is_pin == pin) {
			slot = i;
			start = MAX_INTR_SOURCES;
			break;
		}
	}
	for (i = start; i < MAX_INTR_SOURCES ; i++) {
		isp = ci->ci_isources[i];
		if (isp != NULL && isp->is_pic == pic && isp->is_pin == pin) {
			slot = i;
			break;
		}
		if (isp == NULL && slot == -1) {
			slot = i;
			continue;
		}
	}
	if (slot == -1) {
		return EBUSY;
	}

	isp = ci->ci_isources[slot];
	if (isp == NULL) {
		isp = malloc(sizeof (struct intrsource), M_DEVBUF,
		    M_NOWAIT|M_ZERO);
		if (isp == NULL) {
			return ENOMEM;
		}
		snprintf(isp->is_evname, sizeof (isp->is_evname),
		    "pin %d", pin);
		ci->ci_isources[slot] = isp;
	}

	*index = slot;
	return 0;
}

/*
 * A simple round-robin allocator to assign interrupts to CPUs.
 */
int
intr_allocate_slot(struct pic *pic, int legacy_irq, int pin, int level,
    struct cpu_info **cip, int *index, int *idt_slot)
{
	CPU_INFO_ITERATOR cii;
	struct cpu_info *ci;
	struct intrsource *isp;
	int slot, idtvec, error;

	/*
	 * If a legacy IRQ is wanted, try to use a fixed slot pointing
	 * at the primary CPU. In the case of IO APICs, multiple pins
	 * may map to one legacy IRQ, but they should not be shared
	 * in that case, so the first one gets the legacy slot, but
	 * a subsequent allocation with a different pin will get
	 * a different slot.
	 */
	if (legacy_irq != -1) {
		ci = &cpu_info_primary;
		/* must check for duplicate pic + pin first */
		for (slot = 0 ; slot < MAX_INTR_SOURCES ; slot++) {
			isp = ci->ci_isources[slot];
			if (isp != NULL && isp->is_pic == pic &&
			    isp->is_pin == pin ) {
				goto duplicate;
			}
		}
		slot = legacy_irq;
		isp = ci->ci_isources[slot];
		if (isp == NULL) {
			isp = malloc(sizeof (struct intrsource), M_DEVBUF,
			     M_NOWAIT|M_ZERO);
			if (isp == NULL)
				return ENOMEM;
			snprintf(isp->is_evname, sizeof (isp->is_evname),
			    "pin %d", pin);

			ci->ci_isources[slot] = isp;
		} else {
			if (isp->is_pic != pic || isp->is_pin != pin) {
				if (pic == &i8259_pic)
					return EINVAL;
				goto other;
			}
		}
duplicate:
		if (pic == &i8259_pic)
			idtvec = ICU_OFFSET + legacy_irq;
		else {
#ifdef IOAPIC_HWMASK
			if (level > isp->is_maxlevel) {
#else
			if (isp->is_minlevel == 0 || level < isp->is_minlevel) {
#endif
				idtvec = idt_vec_alloc(APIC_LEVEL(level),
				    IDT_INTR_HIGH);
				if (idtvec == 0)
					return EBUSY;
			} else
				idtvec = isp->is_idtvec;
		}
	} else {
other:
		/*
		 * Otherwise, look for a free slot elsewhere. Do the primary
		 * CPU first.
		 */
		ci = &cpu_info_primary;
		error = intr_allocate_slot_cpu(ci, pic, pin, &slot);
		if (error == 0)
			goto found;

		/*
		 * ..now try the others.
		 */
		CPU_INFO_FOREACH(cii, ci) {
			if (CPU_IS_PRIMARY(ci))
				continue;
			error = intr_allocate_slot_cpu(ci, pic, pin, &slot);
			if (error == 0)
				goto found;
		}
		return EBUSY;
found:
		idtvec = idt_vec_alloc(APIC_LEVEL(level), IDT_INTR_HIGH);
		if (idtvec == 0) {
			free(ci->ci_isources[slot], M_DEVBUF, sizeof (struct intrsource));
			ci->ci_isources[slot] = NULL;
			return EBUSY;
		}
	}
	*idt_slot = idtvec;
	*index = slot;
	*cip = ci;
	return 0;
}

/*
 * True if the system has any non-level interrupts which are shared
 * on the same pin.
 */
int	intr_shared_edge;

void *
intr_establish(int legacy_irq, struct pic *pic, int pin, int type, int level,
    int (*handler)(void *), void *arg, const char *what)
{
	struct intrhand **p, *q, *ih;
	struct cpu_info *ci;
	int slot, error, idt_vec;
	struct intrsource *source;
	struct intrstub *stubp;
	int flags;

#ifdef DIAGNOSTIC
	if (legacy_irq != -1 && (legacy_irq < 0 || legacy_irq > 15))
		panic("intr_establish: bad legacy IRQ value");

	if (legacy_irq == -1 && pic == &i8259_pic)
		panic("intr_establish: non-legacy IRQ on i8259");
#endif

	flags = level & IPL_MPSAFE;
	level &= ~IPL_MPSAFE;

	KASSERT(level <= IPL_TTY || level >= IPL_CLOCK || flags & IPL_MPSAFE);

	error = intr_allocate_slot(pic, legacy_irq, pin, level, &ci, &slot,
	    &idt_vec);
	if (error != 0) {
		printf("failed to allocate interrupt slot for PIC %s pin %d\n",
		    pic->pic_dev.dv_xname, pin);
		return NULL;
	}

	/* no point in sleeping unless someone can free memory. */
	ih = malloc(sizeof *ih, M_DEVBUF, cold ? M_NOWAIT : M_WAITOK);
	if (ih == NULL) {
		printf("intr_establish: can't allocate handler info\n");
		return NULL;
	}

	source = ci->ci_isources[slot];

	if (source->is_handlers != NULL &&
	    source->is_pic->pic_type != pic->pic_type) {
		free(ih, M_DEVBUF, sizeof(*ih));
		printf("intr_establish: can't share intr source between "
		       "different PIC types (legacy_irq %d pin %d slot %d)\n",
		    legacy_irq, pin, slot);
		return NULL;
	}

	source->is_pin = pin;
	source->is_pic = pic;

	switch (source->is_type) {
	case IST_NONE:
		source->is_type = type;
		break;
	case IST_EDGE:
		intr_shared_edge = 1;
		/* FALLTHROUGH */
	case IST_LEVEL:
		if (source->is_type == type)
			break;
	case IST_PULSE:
		if (type != IST_NONE) {
			printf("intr_establish: pic %s pin %d: can't share "
			       "type %d with %d\n", pic->pic_name, pin,
				source->is_type, type);
			free(ih, M_DEVBUF, sizeof(*ih));
			return NULL;
		}
		break;
	default:
		panic("intr_establish: bad intr type %d for pic %s pin %d",
		    source->is_type, pic->pic_dev.dv_xname, pin);
	}

	if (!cold)
		pic->pic_hwmask(pic, pin);

	/*
	 * Figure out where to put the handler.
	 * This is O(N^2), but we want to preserve the order, and N is
	 * generally small.
	 */
	for (p = &ci->ci_isources[slot]->is_handlers;
	     (q = *p) != NULL && q->ih_level > level;
	     p = &q->ih_next)
		;

	ih->ih_fun = handler;
	ih->ih_arg = arg;
	ih->ih_next = *p;
	ih->ih_level = level;
	ih->ih_flags = flags; 
	ih->ih_pin = pin;
	ih->ih_cpu = ci;
	ih->ih_slot = slot;
	evcount_attach(&ih->ih_count, what, &source->is_idtvec);

	*p = ih;

	intr_calculatemasks(ci);

	if (ci->ci_isources[slot]->is_resume == NULL ||
	    source->is_idtvec != idt_vec) {
		if (source->is_idtvec != 0 && source->is_idtvec != idt_vec)
			idt_vec_free(source->is_idtvec);
		source->is_idtvec = idt_vec;
		stubp = type == IST_LEVEL ?
		    &pic->pic_level_stubs[slot] : &pic->pic_edge_stubs[slot];
		ci->ci_isources[slot]->is_resume = stubp->ist_resume;
		ci->ci_isources[slot]->is_recurse = stubp->ist_recurse;
		setgate(&idt[idt_vec], stubp->ist_entry, 0, SDT_SYS386IGT,
		    SEL_KPL, GSEL(GCODE_SEL, SEL_KPL));
	}

	pic->pic_addroute(pic, ci, pin, idt_vec, type);

	if (!cold)
		pic->pic_hwunmask(pic, pin);

#ifdef INTRDEBUG
	printf("allocated pic %s type %s pin %d level %d to cpu%u slot %d idt entry %d\n",
	    pic->pic_name, type == IST_EDGE ? "edge" : "level", pin, level,
	    ci->ci_apicid, slot, idt_vec);
#endif

	return (ih);
}

/*
 * Deregister an interrupt handler.
 */
void
intr_disestablish(struct intrhand *ih)
{
	struct intrhand **p, *q;
	struct cpu_info *ci;
	struct pic *pic;
	struct intrsource *source;
	int idtvec;

	ci = ih->ih_cpu;
	pic = ci->ci_isources[ih->ih_slot]->is_pic;
	source = ci->ci_isources[ih->ih_slot];
	idtvec = source->is_idtvec;

	pic->pic_hwmask(pic, ih->ih_pin);	
	x86_atomic_clearbits_u64(&ci->ci_ipending, (1UL << ih->ih_slot));

	/*
	 * Remove the handler from the chain.
	 */
	for (p = &source->is_handlers; (q = *p) != NULL && q != ih;
	     p = &q->ih_next)
		;
	if (q == NULL) {
		panic("intr_disestablish: handler not registered");
	}

	*p = q->ih_next;

	intr_calculatemasks(ci);
	if (source->is_handlers == NULL)
		pic->pic_delroute(pic, ci, ih->ih_pin, idtvec, source->is_type);
	else
		pic->pic_hwunmask(pic, ih->ih_pin);

#ifdef INTRDEBUG
	printf("cpu%u: remove slot %d (pic %s pin %d vec %d)\n",
	    ci->ci_apicid, ih->ih_slot, pic->pic_dev.dv_xname, ih->ih_pin,
	    idtvec);
#endif

	if (source->is_handlers == NULL) {
		free(source, M_DEVBUF, sizeof (struct intrsource));
		ci->ci_isources[ih->ih_slot] = NULL;
		if (pic != &i8259_pic)
			idt_vec_free(idtvec);
	}

	evcount_detach(&ih->ih_count);
	free(ih, M_DEVBUF, sizeof(*ih));
}

int
intr_handler(struct intrframe *frame, struct intrhand *ih)
{
	struct cpu_info *ci = curcpu();
	int floor;
	int rc;
#ifdef MULTIPROCESSOR
	int need_lock;

	if (ih->ih_flags & IPL_MPSAFE)
		need_lock = 0;
	else
		need_lock = frame->if_ppl < IPL_SCHED;

	if (need_lock)
		__mp_lock(&kernel_lock);
#endif
	floor = ci->ci_handled_intr_level;
	ci->ci_handled_intr_level = ih->ih_level;
	rc = (*ih->ih_fun)(ih->ih_arg ? ih->ih_arg : frame);
	ci->ci_handled_intr_level = floor;
#ifdef MULTIPROCESSOR
	if (need_lock)
		__mp_unlock(&kernel_lock);
#endif
	return rc;
}

#define CONCAT(x,y)	__CONCAT(x,y)

/*
 * Fake interrupt handler structures for the benefit of symmetry with
 * other interrupt sources, and the benefit of intr_calculatemasks()
 */
struct intrhand fake_softclock_intrhand;
struct intrhand fake_softnet_intrhand;
struct intrhand fake_softtty_intrhand;
struct intrhand fake_timer_intrhand;
struct intrhand fake_ipi_intrhand;
#if NXEN > 0
struct intrhand fake_xen_intrhand;
#endif
#if NHYPERV > 0
struct intrhand fake_hyperv_intrhand;
#endif

#if NLAPIC > 0 && defined(MULTIPROCESSOR) && 0
static char *x86_ipi_names[X86_NIPI] = X86_IPI_NAMES;
#endif

/*
 * Initialize all handlers that aren't dynamically allocated, and exist
 * for each CPU.
 */
void
cpu_intr_init(struct cpu_info *ci)
{
	struct intrsource *isp;
#if NLAPIC > 0 && defined(MULTIPROCESSOR) && 0
	int i;
#endif

	isp = malloc(sizeof (struct intrsource), M_DEVBUF, M_NOWAIT|M_ZERO);
	if (isp == NULL)
		panic("can't allocate fixed interrupt source");
	isp->is_recurse = Xsoftclock;
	isp->is_resume = Xsoftclock;
	fake_softclock_intrhand.ih_level = IPL_SOFTCLOCK;
	isp->is_handlers = &fake_softclock_intrhand;
	isp->is_pic = &softintr_pic;
	ci->ci_isources[SIR_CLOCK] = isp;
	isp = malloc(sizeof (struct intrsource), M_DEVBUF, M_NOWAIT|M_ZERO);
	if (isp == NULL)
		panic("can't allocate fixed interrupt source");
	isp->is_recurse = Xsoftnet;
	isp->is_resume = Xsoftnet;
	fake_softnet_intrhand.ih_level = IPL_SOFTNET;
	isp->is_handlers = &fake_softnet_intrhand;
	isp->is_pic = &softintr_pic;
	ci->ci_isources[SIR_NET] = isp;
	isp = malloc(sizeof (struct intrsource), M_DEVBUF, M_NOWAIT|M_ZERO);
	if (isp == NULL)
		panic("can't allocate fixed interrupt source");
	isp->is_recurse = Xsofttty;
	isp->is_resume = Xsofttty;
	fake_softtty_intrhand.ih_level = IPL_SOFTTTY;
	isp->is_handlers = &fake_softtty_intrhand;
	isp->is_pic = &softintr_pic;
	ci->ci_isources[SIR_TTY] = isp;
#if NLAPIC > 0
	isp = malloc(sizeof (struct intrsource), M_DEVBUF, M_NOWAIT|M_ZERO);
	if (isp == NULL)
		panic("can't allocate fixed interrupt source");
	isp->is_recurse = Xrecurse_lapic_ltimer;
	isp->is_resume = Xresume_lapic_ltimer;
	fake_timer_intrhand.ih_level = IPL_CLOCK;
	isp->is_handlers = &fake_timer_intrhand;
	isp->is_pic = &local_pic;
	ci->ci_isources[LIR_TIMER] = isp;
#ifdef MULTIPROCESSOR
	isp = malloc(sizeof (struct intrsource), M_DEVBUF, M_NOWAIT|M_ZERO);
	if (isp == NULL)
		panic("can't allocate fixed interrupt source");
	isp->is_recurse = Xrecurse_lapic_ipi;
	isp->is_resume = Xresume_lapic_ipi;
	fake_ipi_intrhand.ih_level = IPL_IPI;
	isp->is_handlers = &fake_ipi_intrhand;
	isp->is_pic = &local_pic;
	ci->ci_isources[LIR_IPI] = isp;
#endif
#if NXEN > 0
	isp = malloc(sizeof (struct intrsource), M_DEVBUF, M_NOWAIT|M_ZERO);
	if (isp == NULL)
		panic("can't allocate fixed interrupt source");
	isp->is_recurse = Xrecurse_xen_upcall;
	isp->is_resume = Xresume_xen_upcall;
	fake_xen_intrhand.ih_level = IPL_NET;
	isp->is_handlers = &fake_xen_intrhand;
	isp->is_pic = &local_pic;
	ci->ci_isources[LIR_XEN] = isp;
#endif
#if NHYPERV > 0
	isp = malloc(sizeof (struct intrsource), M_DEVBUF, M_NOWAIT|M_ZERO);
	if (isp == NULL)
		panic("can't allocate fixed interrupt source");
	isp->is_recurse = Xrecurse_hyperv_upcall;
	isp->is_resume = Xresume_hyperv_upcall;
	fake_hyperv_intrhand.ih_level = IPL_NET;
	isp->is_handlers = &fake_hyperv_intrhand;
	isp->is_pic = &local_pic;
	ci->ci_isources[LIR_HYPERV] = isp;
#endif
#endif	/* NLAPIC */

	intr_calculatemasks(ci);

}

void
intr_printconfig(void)
{
#ifdef INTRDEBUG
	int i;
	struct intrhand *ih;
	struct intrsource *isp;
	struct cpu_info *ci;
	CPU_INFO_ITERATOR cii;

	CPU_INFO_FOREACH(cii, ci) {
		printf("cpu%d: interrupt masks:\n", ci->ci_apicid);
		for (i = 0; i < NIPL; i++)
			printf("IPL %d mask %lx unmask %lx\n", i,
			    (u_long)ci->ci_imask[i], (u_long)ci->ci_iunmask[i]);
		for (i = 0; i < MAX_INTR_SOURCES; i++) {
			isp = ci->ci_isources[i];
			if (isp == NULL)
				continue;
			printf("cpu%u source %d is pin %d from pic %s maxlevel %d\n",
			    ci->ci_apicid, i, isp->is_pin,
			    isp->is_pic->pic_name, isp->is_maxlevel);
			for (ih = isp->is_handlers; ih != NULL;
			     ih = ih->ih_next)
				printf("\thandler %p level %d\n",
				    ih->ih_fun, ih->ih_level);

		}
	}
#endif
}

void
intr_barrier(void *ih)
{
	sched_barrier(NULL);
}

/*
 * Add a mask to cpl, and return the old value of cpl.
 */
int
splraise(int nlevel)
{
	int olevel;
	struct cpu_info *ci = curcpu();

	olevel = ci->ci_ilevel;
	ci->ci_ilevel = MAX(ci->ci_ilevel, nlevel);
	return (olevel);
}

/*
 * Restore a value to cpl (unmasking interrupts).  If any unmasked
 * interrupts are pending, call Xspllower() to process them.
 */
int
spllower(int nlevel)
{
	int olevel;
	struct cpu_info *ci = curcpu();
	u_int64_t imask;
	u_long psl;

	imask = IUNMASK(ci, nlevel);
	olevel = ci->ci_ilevel;

	psl = read_psl();
	disable_intr();

	if (ci->ci_ipending & imask) {
		Xspllower(nlevel);
	} else {
		ci->ci_ilevel = nlevel;
		write_psl(psl);
	}
	return (olevel);
}

/*
 * Software interrupt registration
 *
 * We hand-code this to ensure that it's atomic.
 *
 * XXX always scheduled on the current CPU.
 */
void
softintr(int sir)
{
	struct cpu_info *ci = curcpu();

	__asm volatile("lock; orq %1, %0" :
	    "=m"(ci->ci_ipending) : "ir" (1UL << sir));
}
@


1.47
log
@Set up an IDT vector for Xen callbacks

This adds support for delivering the combined Xen interrupt
that later fans out into event port specific (device specific)
interrupts via an IDT of a guest system.

The Xen IDT vector is set to be the first of the IPL_NET group
and is implemented the same way LAPIC timer and IPIs are done.
The additional machinery is there to be able to mask it via
standard mechanisms (e.g. splnet).

Discussed with kettenis@@, OK mlarkin, reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.46 2015/09/13 11:48:17 kettenis Exp $	*/
d58 1
d557 3
d635 11
@


1.46
log
@Introduce intr_barrier(4), an interface that guarantees that an interrupt
handler that was running has finished.

ok miod@@, guenther@@ (both for the equivalent sparc64 diff)
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.45 2015/08/28 16:16:44 tedu Exp $	*/
d57 1
d553 3
a619 1

d621 10
d632 1
@


1.45
log
@a few more free sizes. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.44 2015/08/28 00:03:53 deraadt Exp $	*/
d654 6
@


1.44
log
@fairly simple sizes for free(); ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.43 2015/07/16 05:10:14 guenther Exp $	*/
d310 1
a310 1
			free(ci->ci_isources[slot], M_DEVBUF, 0);
d503 1
a503 1
		free(source, M_DEVBUF, 0);
@


1.43
log
@Move grab/release of the kernel_lock for softintrs from the ASM stubs to
softintr_dispatch().  Delete traces of long superseded stats code.

ok beck@@ mpi@@ uebayasi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.42 2015/04/24 02:22:08 jsg Exp $	*/
d370 1
a370 1
		free(ih, M_DEVBUF, 0);
d395 1
a395 1
			free(ih, M_DEVBUF, 0);
d510 1
a510 1
	free(ih, M_DEVBUF, 0);
@


1.42
log
@Use "softintr_pic0" instead of "softintr_fakepic" when faking a
struct device so there is enough space in the buffer for a NUL and
the unit is included in the string.

discussed with deraadt and millert
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.41 2015/03/14 03:38:46 jsg Exp $	*/
a622 14

#ifdef MULTIPROCESSOR
void
x86_softintlock(void)
{
	__mp_lock(&kernel_lock);
}

void
x86_softintunlock(void)
{
	__mp_unlock(&kernel_lock);
}
#endif
@


1.41
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.40 2015/01/06 12:50:47 dlg Exp $	*/
d67 1
a67 1
        {0, {NULL}, NULL, 0, "softintr_fakepic", NULL, 0, 0},
@


1.40
log
@when we're entering an interrupt handler, record its ipl so splassert
can check if we're entering code we think should only be used from
lower ipls.

modelled a bit on how sparc64 does things.

with help from and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.39 2014/12/02 18:13:10 tedu Exp $	*/
a58 1
#include <machine/i82093var.h> 
@


1.39
log
@delete all the simplelocks. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.38 2014/09/14 14:17:23 jsg Exp $	*/
d517 2
d531 2
d534 1
@


1.38
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.37 2014/07/12 18:44:41 tedu Exp $	*/
a182 1
	simple_lock(&ci->ci_slock);
a202 1
		simple_unlock(&ci->ci_slock);
a210 1
			simple_unlock(&ci->ci_slock);
a216 1
	simple_unlock(&ci->ci_slock);
a261 1
			simple_lock(&ci->ci_slock);
a262 1
			simple_unlock(&ci->ci_slock);
a310 1
			simple_lock(&ci->ci_slock);
a312 1
			simple_unlock(&ci->ci_slock);
a377 2
	simple_lock(&ci->ci_slock);

a392 1
			simple_unlock(&ci->ci_slock);
a400 1
		simple_unlock(&ci->ci_slock);
a431 2
	simple_unlock(&ci->ci_slock);

a475 1
	simple_lock(&ci->ci_slock);
a485 1
		simple_unlock(&ci->ci_slock);
a511 2

	simple_unlock(&ci->ci_slock);
a648 1
		simple_lock(&ci->ci_slock);
a661 1
		simple_unlock(&ci->ci_slock);
@


1.37
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.36 2014/03/29 18:09:28 guenther Exp $	*/
a46 1
#include <sys/proc.h>
@


1.36
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.35 2013/06/26 19:53:50 kettenis Exp $	*/
d319 1
a319 1
			free(ci->ci_isources[slot], M_DEVBUF);
d380 1
a380 1
		free(ih, M_DEVBUF);
d408 1
a408 1
			free(ih, M_DEVBUF);
d521 1
a521 1
		free(source, M_DEVBUF);
d528 1
a528 1
	free(ih, M_DEVBUF);
@


1.35
log
@Since interrupts at IPL_AUDIO no longer grab the kernel lock, and nobody
is supposed to establish interrupts at IPL_VM, we only need to "flatten"
mutex ipls up until IPL_TTY.  Add an assertion to enforce that IPL_AUDIO
interrupts are establish with the IPL_MPSAFE flag set.  Should improve
latency of audio interrupts a tiny bit.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.34 2013/05/16 16:20:00 kettenis Exp $	*/
d740 1
a740 1
	__asm __volatile("lock; orq %1, %0" :
@


1.34
log
@Implement a mechanism to establish interrupt handlers that don't grab the
kernel lock upon entry through a new IPL_MPSAFE flag/level.

ok mikeb@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.33 2013/05/12 14:15:31 ratchov Exp $	*/
d358 2
@


1.33
log
@Take the kernel lock and call the actual interrupt handler from a
single c function. This will hopefully make easier to stop taking
the kernel lock when running "mp safe" interrupt handlers.

help from ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.32 2012/12/05 23:20:10 deraadt Exp $	*/
d346 1
d356 3
d433 1
d538 4
a541 1
	need_lock = frame->if_ppl < IPL_SCHED;
@


1.32
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.31 2011/10/29 19:17:30 kettenis Exp $	*/
d526 20
a629 14
void
x86_intlock(struct intrframe iframe)
{
	if (iframe.if_ppl < IPL_SCHED)
		__mp_lock(&kernel_lock);
}

void
x86_intunlock(struct intrframe iframe)
{
	if (iframe.if_ppl < IPL_SCHED)
		__mp_unlock(&kernel_lock);
}

@


1.31
log
@Make sure we don't accidentally use ISA or EISA interrupt mappings on PCI
busses.

tested by krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.30 2011/10/21 20:48:11 kettenis Exp $	*/
a40 1
#include <sys/cdefs.h>
@


1.30
log
@Add bounds checks for access to mp_busses.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.29 2011/06/16 19:46:39 kettenis Exp $	*/
a173 19

#if NIOAPIC > 0
int
intr_find_mpmapping(int bus, int pin, int *handle)
{
	struct mp_intr_map *mip;

	if (bus == -1 || bus >= mp_nbusses)
		return ENOENT;

	for (mip = mp_busses[bus].mb_intrs; mip != NULL; mip = mip->next) {
		if (mip->bus_pin == pin) {
			*handle = mip->ioapic_ih;
			return 0;
		}
	}
	return ENOENT;
}
#endif
@


1.29
log
@Raise the number of interrupt sources per CPU from 32 to 64.  This effectively
triples the number of interrupt vectors that can be handled by the primary
CPU.  Important for MSI, but could also fix some issues with large machines
loaded with a lot of devices.

tested by many; ok deraadt@@, marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.28 2011/05/28 21:10:40 kettenis Exp $	*/
d181 1
a181 1
	if (bus == -1 || mp_busses[bus].mb_intrs == NULL)
d184 1
a184 1
	for (mip = mp_busses[bus].mb_intrs; mip != NULL; mip=mip->next) {
@


1.28
log
@Remove out of data XXX comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.27 2011/04/16 00:40:56 deraadt Exp $	*/
d122 2
a123 1
	int irq, level, unusedirqs, intrlevel[MAX_INTR_SOURCES];
d127 1
a127 1
	unusedirqs = 0xffffffff;
d136 1
a136 1
			levels |= 1 << q->ih_level;
d139 1
a139 1
			unusedirqs &= ~(1 << irq);
d144 1
a144 1
		int irqs = 0;
d147 1
a147 1
				irqs |= 1 << irq;
d151 2
a152 2
	for (level = 0; level<(NIPL-1); level++)
		ci->ci_imask[level+1] |= ci->ci_imask[level];
d506 1
a506 1
	x86_atomic_clearbits_u32(&ci->ci_ipending, (1 << ih->ih_slot));
d714 1
a714 1
	u_int32_t imask;
d744 2
a745 2
	__asm __volatile("lock ; orl %1, %0" :
	    "=m"(ci->ci_ipending) : "ir" (1 << sir));
@


1.27
log
@More than a decade ago, interrupt handlers on sparc started returning 0
(interrupt was not for me), 1 (positive interrupt was for me), or -1
(i am not sure...).  We have continued with this practice in as many
drivers as possible, throughout the tree.

This makes some of the architectures use that information in their
interrupt handler calling code -- if 1 is returned (and we know
this specific machine does not have edge-shared interrupts), we
finish servicing other possible handlers on the same pin.  If the
interrupt pin remains asserted (from a different device), we will
end up back in the interrupt servicing code of course... but this is
cheaper than calling all the chained interrupts on a pin.

This does of course count on shared level interrupts being properly
sorted by IPL.

There have been some concerns about starvation of drivers which
incorrectly return 1.  Those drivers should be hunted down so that
they return -1.

ok and help from various people.  In snaps for about a week now.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.26 2010/12/27 20:22:23 guenther Exp $	*/
a173 4

/*
 * XXX if defined(MULTIPROCESSOR) && .. ?
 */
@


1.26
log
@Correct x86_atomic_*_ul() to operate on 64bit integers, eliminate
x86_atomic_*_l(), and update the callers of all of those to use the
underlying x86_atomic_*_u32() functions that they were expecting anyway.
Whether the x86_atomic_*_ul() macros should be eliminated has been deferred.

ok kettenis@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.25 2010/09/20 06:33:46 matthew Exp $	*/
d354 6
d414 2
@


1.25
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.24 2010/03/01 20:36:32 kettenis Exp $	*/
d501 1
a501 1
	x86_atomic_clearbits_l(&ci->ci_ipending, (1 << ih->ih_slot));
@


1.24
log
@Set the user data of interrupt counters to the interrupt vector number used
for the interrupt.  Makes the vmstat -i output similar to what we see on
i386.

ok deraadt@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.23 2009/08/22 02:54:50 mk Exp $	*/
d447 1
a447 1
	evcount_attach(&ih->ih_count, what, &source->is_idtvec, &evcount_intr);
@


1.23
log
@Constify the what/name parameter of pci_intr_establish().

Tested by myself, sthen, oga, kettenis, and jasper.
Input from sthen and jasper.

ok kettenis

(Manpage follows shortly.)
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.22 2008/12/06 19:59:38 tedu Exp $	*/
d447 1
a447 2
	evcount_attach(&ih->ih_count, what, (void *)&ih->ih_pin,
	    &evcount_intr);
@


1.22
log
@revert all changes related to the mpsafe intr handler.  i screwed up the commit
and even then it didn't work.  we have higher standards than this.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.21 2008/12/06 14:36:49 tedu Exp $	*/
d356 1
a356 1
    int (*handler)(void *), void *arg, char *what)
@


1.21
log
@the not MP version didn't compile, mglocker found
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.20 2008/12/06 04:31:24 tedu Exp $	*/
a81 2
int intr_biglock_wrap(void *);

d356 1
a356 1
    int (*handler)(void *), void *arg, char *what, int flags)
a362 4
	int mpsafe = 0;

	if (level >= IPL_SCHED || (flags & INTR_ESTABLISH_MPSAFE))
		mpsafe = 1;
a446 8
#ifdef MULTIPROCESSOR
	if (!mpsafe) {
		ih->ih_wrapped_fun = handler;
		ih->ih_wrapped_arg = arg;
		ih->ih_fun = intr_biglock_wrap;
		ih->ih_arg = ih;
	}
#endif
a541 15
#ifdef MULTIPROCESSOR
int
intr_biglock_wrap(void *v)
{
	struct intrhand *ih = v;
	int ret;

	__mp_lock(&kernel_lock);
	ret = (*ih->ih_wrapped_fun)(ih->ih_wrapped_arg);
	__mp_unlock(&kernel_lock);

	return (ret);
}
#endif

d626 14
@


1.20
log
@mpsafe intr_establish that doesn't get biglock, so that we may dream of the day when this is useful.
mostly macro magic that does nothing.  only actually useful on amd64 for now, compliments of art.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.19 2008/10/22 19:53:31 kettenis Exp $	*/
d556 1
d569 1
@


1.19
log
@Only call pic->pic_delroute() when disestablishing the last interrupt handler
for a pin.  Resolves issues with azalia(4) devices that have no usable codecs
when they share an interrupt pin with other devices.

ok weingart@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.18 2008/10/09 18:35:38 chl Exp $	*/
d82 2
d358 1
a358 1
    int (*handler)(void *), void *arg, char *what)
d365 4
d453 8
d556 13
a652 14
void
x86_intlock(struct intrframe iframe)
{
	if (iframe.if_ppl < IPL_SCHED)
		__mp_lock(&kernel_lock);
}

void
x86_intunlock(struct intrframe iframe)
{
	if (iframe.if_ppl < IPL_SCHED)
		__mp_unlock(&kernel_lock);
}

@


1.18
log
@replace M_WAITOK with M_NOWAIT

ok krw@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.17 2008/04/28 18:09:00 kettenis Exp $	*/
d518 4
a521 2
	pic->pic_delroute(pic, ci, ih->ih_pin, idtvec, source->is_type);
	pic->pic_hwunmask(pic, ih->ih_pin);
@


1.17
log
@Rename IPL_SOFTSERIAL to IPL_SOFTTY and rename the associated symbols.
Remove IPL_SERIAL since it is unused.

ok krw@@, weingart@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.16 2008/04/25 19:27:36 kettenis Exp $	*/
d568 1
a568 1
	isp = malloc(sizeof (struct intrsource), M_DEVBUF, M_WAITOK|M_ZERO);
d577 1
a577 1
	isp = malloc(sizeof (struct intrsource), M_DEVBUF, M_WAITOK|M_ZERO);
d586 1
a586 1
	isp = malloc(sizeof (struct intrsource), M_DEVBUF, M_WAITOK|M_ZERO);
d596 1
a596 1
	isp = malloc(sizeof (struct intrsource), M_DEVBUF, M_WAITOK|M_ZERO);
d606 1
a606 1
	isp = malloc(sizeof (struct intrsource), M_DEVBUF, M_WAITOK|M_ZERO);
@


1.16
log
@When allocating an interrupt 'slot', always check all slots to see if we
already allocated a slot for a particular apic pin.

ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.15 2007/09/17 15:34:38 chl Exp $	*/
d548 1
a548 1
struct intrhand fake_softserial_intrhand;
d589 4
a592 4
	isp->is_recurse = Xsoftserial;
	isp->is_resume = Xsoftserial;
	fake_softserial_intrhand.ih_level = IPL_SOFTSERIAL;
	isp->is_handlers = &fake_softserial_intrhand;
d594 1
a594 1
	ci->ci_isources[SIR_SERIAL] = isp;
@


1.15
log
@MALLOC/FREE -> malloc/free and M_ZERO changes

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.14 2007/05/10 17:59:23 deraadt Exp $	*/
d208 8
@


1.14
log
@evcnt & friends were replaced by a proper interrupt counting mechanism 3 years ago; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.13 2007/01/15 23:19:05 jsg Exp $	*/
d226 2
a227 2
		MALLOC(isp, struct intrsource *, sizeof (struct intrsource),
		    M_DEVBUF, M_NOWAIT);
a231 1
		memset(isp, 0, sizeof(struct intrsource));
d275 2
a276 3
			MALLOC(isp, struct intrsource *,
			    sizeof (struct intrsource), M_DEVBUF,
			     M_NOWAIT);
a278 1
			memset(isp, 0, sizeof(struct intrsource));
d334 1
a334 1
			FREE(ci->ci_isources[slot], M_DEVBUF);
d520 1
a520 1
		FREE(source, M_DEVBUF);
d560 1
a560 2
	MALLOC(isp, struct intrsource *, sizeof (struct intrsource), M_DEVBUF,
	    M_WAITOK);
a562 1
	memset(isp, 0, sizeof(struct intrsource));
d569 1
a569 2
	MALLOC(isp, struct intrsource *, sizeof (struct intrsource), M_DEVBUF,
	    M_WAITOK);
a571 1
	memset(isp, 0, sizeof(struct intrsource));
d578 1
a578 2
	MALLOC(isp, struct intrsource *, sizeof (struct intrsource), M_DEVBUF,
	    M_WAITOK);
a580 1
	memset(isp, 0, sizeof(struct intrsource));
d588 1
a588 2
	MALLOC(isp, struct intrsource *, sizeof (struct intrsource), M_DEVBUF,
	    M_WAITOK);
a590 1
	memset(isp, 0, sizeof(struct intrsource));
d598 1
a598 2
	MALLOC(isp, struct intrsource *, sizeof (struct intrsource), M_DEVBUF,
	    M_WAITOK);
a600 1
	memset(isp, 0, sizeof(struct intrsource));
@


1.13
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.12 2006/01/22 04:52:23 brad Exp $	*/
a234 4
#if notyet
		evcnt_attach_dynamic(&isp->is_evcnt, EVCNT_TYPE_INTR, NULL,
		    pic->pic_dev.dv_xname, isp->is_evname);
#endif
a284 4
#if notyet
			evcnt_attach_dynamic(&isp->is_evcnt, EVCNT_TYPE_INTR,
			    NULL, pic->pic_dev.dv_xname, isp->is_evname);
#endif
a522 3
#if notyet
		evcnt_detach(&source->is_evcnt);
#endif
a573 4
#if notyet
	evcnt_attach_dynamic(&isp->is_evcnt, EVCNT_TYPE_INTR, NULL,
	    ci->ci_dev->dv_xname, "softclock");
#endif
a584 4
#if notyet
	evcnt_attach_dynamic(&isp->is_evcnt, EVCNT_TYPE_INTR, NULL,
	    ci->ci_dev->dv_xname, "softnet");
#endif
a595 4
#if notyet
	evcnt_attach_dynamic(&isp->is_evcnt, EVCNT_TYPE_INTR, NULL,
	    ci->ci_dev->dv_xname, "softserial");
#endif
a607 4
#if notyet
	evcnt_attach_dynamic(&isp->is_evcnt, EVCNT_TYPE_INTR, NULL,
	    ci->ci_dev->dv_xname, "timer");
#endif
a620 5
#ifdef notyet
	for (i = 0; i < X86_NIPI; i++)
		evcnt_attach_dynamic(&ci->ci_ipi_events[i], EVCNT_TYPE_INTR,
		    NULL, ci->ci_dev->dv_xname, x86_ipi_names[i]);
#endif
@


1.12
log
@Fix for ioapic irq routing.

From NetBSD, NetBSD PR 22728 for details

ok beck@@ krw@@
tested by beck@@ krw@@ marc@@ and a few others on a number of amd64 systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.11 2005/09/25 20:48:18 miod Exp $	*/
d199 1
a199 1
		       int *index)
d252 1
a252 1
		   struct cpu_info **cip, int *index, int *idt_slot)
d359 1
a359 1
	       int (*handler)(void *), void *arg, char *what)
@


1.11
log
@Turn CPU_INFO_FOREACH into a real construct, like all queue(3) iterators,
instead of the contents of a for() loop. No functional change.
From the m88k SMP tree; ok art@@ deraadt@@

[complete diff this time]
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.10 2005/07/26 08:07:39 art Exp $	*/
d269 8
d303 1
a303 1

@


1.10
log
@In splraise, change an:
	if (x > foo->bar)
		foo->bar = x;
to:
	foo->bar = MAX(x, foo->bar);

This forces gcc to generate much better code even though both
experessions are equivalent. Normally I wouldn't bother with
microoptimizations like this, but I needed some generated assembler
that uses cmov and splraise used so often..

ok toby@@ (well, he ok:ed a diff that didn't use the MAX macro, but it's
 the same code)
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.9 2005/07/18 02:43:24 fgsch Exp $	*/
d325 1
a325 1
		for (CPU_INFO_FOREACH(cii, ci)) {
d690 1
a690 1
	for (CPU_INFO_FOREACH(cii, ci)) {
@


1.9
log
@remove trailing newline in panic(9); ok millert@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.8 2005/05/28 05:15:18 niklas Exp $	*/
d724 1
a724 2
	if (nlevel > olevel)
		ci->ci_ilevel = nlevel;
@


1.8
log
@If irq-sharing happens over different ioapics, we must not overwrite setup info for one of them
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.7 2005/04/26 20:56:59 miod Exp $	*/
d418 1
a418 1
		panic("intr_establish: bad intr type %d for pic %s pin %d\n",
@


1.7
log
@Check for memory allocation failure before zeroing memory, not after;
from mpech@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.6 2004/07/10 14:21:40 art Exp $	*/
d289 1
a289 1
			if (isp->is_pin != pin) {
@


1.6
log
@From NetBSD:
date: 2004/06/28 09:13:11;  author: fvdl;  state: Exp;  lines: +6 -5
Updaing ci_ilevel and testing ci_ipending must be done with all interrupts
off, or priority inversion can occur, which can lead to IPI deadlocks.
Leaves interrupts off for a bit longer, sadly, but with no noticeable
effects on the systems I tested on.

From YAMAMOTO Takashi.

Fixes the IPI rendezvous panics for me.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.5 2004/06/28 02:14:11 deraadt Exp $	*/
a227 1
		memset(isp, 0, sizeof(struct intrsource));
d232 1
a274 1
			memset(isp, 0, sizeof(struct intrsource));
d277 1
a567 1
	memset(isp, 0, sizeof(struct intrsource));
d570 1
a582 1
	memset(isp, 0, sizeof(struct intrsource));
d585 1
a597 1
	memset(isp, 0, sizeof(struct intrsource));
d600 1
a613 1
	memset(isp, 0, sizeof(struct intrsource));
d616 1
a629 1
	memset(isp, 0, sizeof(struct intrsource));
d632 1
@


1.5
log
@pass pin instead of level out to userland
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.4 2004/06/28 01:52:24 deraadt Exp $	*/
d55 1
d738 2
d741 1
a741 5
	/*
	 * Since this should only lower the interrupt level,
	 * the XOR below should only show interrupts that
	 * are being unmasked.
	 */
d743 5
a747 1
	if (ci->ci_ipending & IUNMASK(ci,nlevel))
d749 1
a749 1
	else
d751 2
@


1.4
log
@Use new event counter API for interrupt counting on amd64.  Based in part
on some changes in the i386 codebase.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.3 2004/06/26 05:29:17 art Exp $	*/
d441 1
a441 1
	evcount_attach(&ih->ih_count, what, (void *)&ih->ih_level,
@


1.3
log
@deinline splraise, spllower and setsoftint.
Makes the kernel smaller and faster.
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.2 2004/06/25 11:03:27 art Exp $	*/
d350 1
a350 1
	       int (*handler)(void *), void *arg)
d441 3
d531 1
@


1.2
log
@SMP support. Big parts from NetBSD, but with some really serious debugging
done by me, niklas and others. Especially wrt. NXE support.

Still needs some polishing, especially in dmesg messages, but we're now
building kernel faster than ever.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.1 2004/01/28 01:39:38 mickey Exp $	*/
d707 54
@


1.1
log
@an amd64 arch support.
hacked by art@@ from netbsd sources and then later debugged
by me into the shape where it can host itself.
no bootloader yet as needs redoing from the
recent advanced i386 sources (anyone? ;)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d72 1
a72 3
        __SIMPLELOCK_UNLOCKED,
#else
	0,
d545 1
a545 1
#if NLAPIC > 0 && defined(MULTIPROCESSOR)
d557 1
a557 1
#if NLAPIC > 0 && defined(MULTIPROCESSOR)
d635 1
d641 1
d652 1
a652 1
		spinlockmgr(&kernel_lock, LK_EXCLUSIVE|LK_CANRECURSE, 0);
d659 1
a659 1
		spinlockmgr(&kernel_lock, LK_RELEASE, 0);
d665 1
a665 1
	spinlockmgr(&kernel_lock, LK_EXCLUSIVE|LK_CANRECURSE, 0);
d671 1
a671 1
	spinlockmgr(&kernel_lock, LK_RELEASE, 0);
@

