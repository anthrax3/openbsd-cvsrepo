head	1.48;
access;
symbols
	OPENBSD_6_2_BASE:1.48
	OPENBSD_6_1:1.45.0.4
	OPENBSD_6_1_BASE:1.45
	OPENBSD_6_0:1.44.0.2
	OPENBSD_6_0_BASE:1.44
	OPENBSD_5_9:1.42.0.2
	OPENBSD_5_9_BASE:1.42
	OPENBSD_5_8:1.41.0.4
	OPENBSD_5_8_BASE:1.41
	OPENBSD_5_7:1.37.0.2
	OPENBSD_5_7_BASE:1.37
	OPENBSD_5_6:1.31.0.4
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.29.0.4
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.28.0.2
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.27.0.10
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.8
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.6
	OPENBSD_5_0:1.27.0.4
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.27.0.2
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.26.0.2
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.21.0.4
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.15.0.2
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.14.0.2
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.10.0.2
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.9.0.2
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.4.0.4
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.3.0.6
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.4
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3;
locks; strict;
comment	@ * @;


1.48
date	2017.07.24.15.31.14;	author robert;	state Exp;
branches;
next	1.47;
commitid	gHx0ylCdB3WO0FOt;

1.47
date	2017.05.29.14.19.49;	author mpi;	state Exp;
branches;
next	1.46;
commitid	4u6PWvBw90PH7UDq;

1.46
date	2017.05.25.03.54.10;	author visa;	state Exp;
branches;
next	1.45;
commitid	J0PLAPzKuJAH1OX8;

1.45
date	2016.11.01.01.13.19;	author yasuoka;	state Exp;
branches;
next	1.44;
commitid	3eJlGUfmDEQ3v9Gh;

1.44
date	2016.06.22.01.12.38;	author mikeb;	state Exp;
branches;
next	1.43;
commitid	aoZwpavraFkBTbjg;

1.43
date	2016.03.06.22.41.24;	author naddy;	state Exp;
branches;
next	1.42;
commitid	m1enxPveYSHWYNdC;

1.42
date	2015.12.08.19.45.55;	author mikeb;	state Exp;
branches;
next	1.41;
commitid	k3df0wPG0WyTVD3t;

1.41
date	2015.07.18.19.21.02;	author sf;	state Exp;
branches;
next	1.40;
commitid	fKIY1z4O2YV68kXY;

1.40
date	2015.07.18.19.19.14;	author sf;	state Exp;
branches;
next	1.39;
commitid	2xGM1gJBLGHVxwpd;

1.39
date	2015.04.19.19.45.21;	author sf;	state Exp;
branches;
next	1.38;
commitid	QHmlY8tYf1BGbIw1;

1.38
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.37;
commitid	p4LJxGKbi0BU2cG6;

1.37
date	2015.01.06.12.50.47;	author dlg;	state Exp;
branches;
next	1.36;
commitid	EAvvmUR28EGEqQFd;

1.36
date	2014.12.18.05.33.48;	author mlarkin;	state Exp;
branches;
next	1.35;
commitid	JVgpC5JUPLFOXy8N;

1.35
date	2014.11.20.06.51.41;	author mlarkin;	state Exp;
branches;
next	1.34;
commitid	rZAY1nGaAOyEEKdK;

1.34
date	2014.11.11.17.09.30;	author mlarkin;	state Exp;
branches;
next	1.33;
commitid	SngWYObQEQDudX2H;

1.33
date	2014.09.21.16.14.52;	author sf;	state Exp;
branches;
next	1.32;
commitid	21xJ8BIHPTUlmyiK;

1.32
date	2014.09.14.14.17.23;	author jsg;	state Exp;
branches;
next	1.31;
commitid	uzzBR7hz9ncd4O6G;

1.31
date	2014.03.29.18.09.28;	author guenther;	state Exp;
branches;
next	1.30;

1.30
date	2014.03.07.16.56.57;	author guenther;	state Exp;
branches;
next	1.29;

1.29
date	2014.01.21.09.40.54;	author kettenis;	state Exp;
branches;
next	1.28;

1.28
date	2013.06.02.18.16.42;	author gerhard;	state Exp;
branches;
next	1.27;

1.27
date	2010.09.20.06.33.46;	author matthew;	state Exp;
branches;
next	1.26;

1.26
date	2010.07.25.21.43.38;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2010.07.23.07.21.02;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	2010.06.26.23.24.43;	author guenther;	state Exp;
branches;
next	1.23;

1.23
date	2010.04.01.19.47.59;	author kettenis;	state Exp;
branches;
next	1.22;

1.22
date	2009.08.10.17.04.37;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2009.06.09.02.56.38;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2009.06.06.23.45.35;	author guenther;	state Exp;
branches;
next	1.19;

1.19
date	2009.06.05.10.51.44;	author guenther;	state Exp;
branches;
next	1.18;

1.18
date	2009.05.28.09.05.33;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2009.04.27.17.48.22;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2009.04.23.07.42.02;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2008.08.13.15.44.44;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2008.06.26.05.42.09;	author ray;	state Exp;
branches;
next	1.13;

1.13
date	2008.01.26.11.18.42;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2007.11.29.10.53.54;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2007.11.16.16.16.07;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2007.05.25.16.22.11;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2007.02.19.11.59.00;	author tom;	state Exp;
branches;
next	1.8;

1.8
date	2007.01.24.20.26.59;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.15.23.19.05;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2006.03.10.21.21.08;	author brad;	state Exp;
branches;
next	1.5;

1.5
date	2006.03.10.21.09.22;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2005.12.13.23.33.25;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.28.01.52.24;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.27.16.17.50;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.25.11.03.27;	author art;	state Exp;
branches;
next	;


desc
@@


1.48
log
@add some missing MULTIPROCESSOR ifdefs to not compile in code on
non-multiprocessor kernels to avoid unused function warnings by clang
@
text
@/*	$OpenBSD: lapic.c,v 1.47 2017/05/29 14:19:49 mpi Exp $	*/
/* $NetBSD: lapic.c,v 1.2 2003/05/08 01:04:35 fvdl Exp $ */

/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by RedBack Networks Inc.
 *
 * Author: Bill Sommerfeld
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>

#include <uvm/uvm_extern.h>

#include <machine/codepatch.h>
#include <machine/cpu.h>
#include <machine/cpufunc.h>
#include <machine/pmap.h>
#include <machine/vmparam.h>
#include <machine/mpbiosvar.h>
#include <machine/pcb.h>
#include <machine/specialreg.h>
#include <machine/segments.h>

#include <machine/apicvar.h>
#include <machine/i82489reg.h>
#include <machine/i82489var.h>

#include <dev/ic/i8253reg.h>

#include "ioapic.h"
#include "xen.h"
#include "hyperv.h"

#if NIOAPIC > 0
#include <machine/i82093var.h>
#endif

struct evcount clk_count;
#ifdef MULTIPROCESSOR
struct evcount ipi_count;
#endif

void	lapic_delay(int);
static u_int32_t lapic_gettick(void);
void	lapic_clockintr(void *, struct intrframe);
void	lapic_initclocks(void);
void	lapic_map(paddr_t);

void lapic_hwmask(struct pic *, int);
void lapic_hwunmask(struct pic *, int);
void lapic_setup(struct pic *, struct cpu_info *, int, int, int);

extern char idt_allocmap[];

struct pic local_pic = {
	{0, {NULL}, NULL, 0, "lapic", NULL, 0, 0},
	PIC_LAPIC,
#ifdef MULTIPROCESSOR
	{},
#endif
	lapic_hwmask,
	lapic_hwunmask,
	lapic_setup,
	lapic_setup,
};

extern int x2apic_eoi;
int x2apic_enabled = 0;

u_int32_t x2apic_readreg(int reg);
u_int32_t x2apic_cpu_number(void);
void x2apic_writereg(int reg, u_int32_t val);
void x2apic_ipi(int vec, int target, int dl);

u_int32_t i82489_readreg(int reg);
u_int32_t i82489_cpu_number(void);
void i82489_writereg(int reg, u_int32_t val);
void i82489_ipi(int vec, int target, int dl);

u_int32_t (*lapic_readreg)(int)			= i82489_readreg;
void (*lapic_writereg)(int, u_int32_t)		= i82489_writereg;
#ifdef MULTIPROCESSOR
void (*x86_ipi)(int vec, int target, int dl)	= i82489_ipi;
#endif

u_int32_t
i82489_readreg(int reg)
{
	return *((volatile u_int32_t *)(((volatile u_int8_t *)local_apic)
	    + reg));
}

u_int32_t
i82489_cpu_number(void)
{
	return i82489_readreg(LAPIC_ID) >> LAPIC_ID_SHIFT;
}

void
i82489_writereg(int reg, u_int32_t val)
{
	*((volatile u_int32_t *)(((volatile u_int8_t *)local_apic) + reg)) =
	    val;
}

u_int32_t
x2apic_readreg(int reg)
{
	return rdmsr(MSR_X2APIC_BASE + (reg >> 4));
}

u_int32_t
x2apic_cpu_number(void)
{
	return x2apic_readreg(LAPIC_ID) & X2APIC_ID_MASK;
}

void
x2apic_writereg(int reg, u_int32_t val)
{
	wrmsr(MSR_X2APIC_BASE + (reg >> 4), val);
}

#ifdef MULTIPROCESSOR
static inline void
x2apic_writeicr(u_int32_t hi, u_int32_t lo)
{
	u_int32_t msr = MSR_X2APIC_BASE + (LAPIC_ICRLO >> 4);
	__asm volatile("wrmsr" : : "a" (lo), "d" (hi), "c" (msr));
}
#endif

u_int32_t
lapic_cpu_number(void)
{
	if (x2apic_enabled)
		return x2apic_cpu_number();
	return i82489_cpu_number();
}


void
lapic_map(paddr_t lapic_base)
{
	int s;
	pt_entry_t *pte;
	vaddr_t va;
	u_int64_t msr;

	disable_intr();
	s = lapic_tpr;

	msr = rdmsr(MSR_APICBASE);

	if (ISSET(msr, APICBASE_ENABLE_X2APIC) ||
	    (ISSET(cpu_ecxfeature, CPUIDECX_HV) &&
	    ISSET(cpu_ecxfeature, CPUIDECX_X2APIC))) {
		 /*
		  * On real hardware, x2apic must only be enabled if interrupt
		  * remapping is also enabled. See 10.12.7 of the SDM vol 3.
		  * On hypervisors, this is not necessary. Hypervisors can
		  * implement x2apic support even if the host CPU does not
		  * support it.  Until we support interrupt remapping, use
		  * x2apic only if the hypervisor flag is also set or it is
		  * enabled by BIOS.
		  */
		if (!ISSET(msr, APICBASE_ENABLE_X2APIC)) {
			msr |= APICBASE_ENABLE_X2APIC;
			wrmsr(MSR_APICBASE, msr);
		}
		lapic_readreg = x2apic_readreg;
		lapic_writereg = x2apic_writereg;
#ifdef MULTIPROCESSOR
		x86_ipi = x2apic_ipi;
#endif
		x2apic_enabled = 1;
		codepatch_call(CPTAG_EOI, &x2apic_eoi);

		lapic_writereg(LAPIC_TPRI, s);
	} else {
		/*
		 * Map local apic.  If we have a local apic, it's safe to
		 * assume we're on a 486 or better and can use invlpg and
		 * non-cacheable PTE's
		 *
		 * Whap the PTE "by hand" rather than calling pmap_kenter_pa
		 * because the latter will attempt to invoke TLB shootdown
		 * code just as we might have changed the value of
		 * cpu_number()..
		 */
		va = (vaddr_t)&local_apic;
		pte = kvtopte(va);
		*pte = lapic_base | PG_RW | PG_V | PG_N | PG_G | pg_nx;
		invlpg(va);

		lapic_tpr = s;
	}

	enable_intr();
}

/*
 * enable local apic
 */
void
lapic_enable(void)
{
	lapic_writereg(LAPIC_SVR, LAPIC_SVR_ENABLE | LAPIC_SPURIOUS_VECTOR);
}

void
lapic_disable(void)
{
	lapic_writereg(LAPIC_SVR, 0);
}

void
lapic_set_lvt(void)
{
	struct cpu_info *ci = curcpu();
	int i;
	struct mp_intr_map *mpi;
	uint32_t lint0;

#ifdef MULTIPROCESSOR
	if (mp_verbose) {
		apic_format_redir(ci->ci_dev->dv_xname, "prelint", 0, 0,
		    lapic_readreg(LAPIC_LVINT0));
		apic_format_redir(ci->ci_dev->dv_xname, "prelint", 1, 0,
		    lapic_readreg(LAPIC_LVINT1));
	}
#endif

#if NIOAPIC > 0
	/*
	 * Disable ExtINT by default when using I/O APICs.
	 */
	if (nioapics > 0) {
		lint0 = lapic_readreg(LAPIC_LVINT0);
		lint0 |= LAPIC_LVT_MASKED;
		lapic_writereg(LAPIC_LVINT0, lint0);
	}
#endif

	if (strcmp(cpu_vendor, "AuthenticAMD") == 0) {
		/*
		 * Detect the presence of C1E capability mostly on latest
		 * dual-cores (or future) k8 family. This mis-feature renders
		 * the local APIC timer dead, so we disable it by reading
		 * the Interrupt Pending Message register and clearing both
		 * C1eOnCmpHalt (bit 28) and SmiOnCmpHalt (bit 27).
		 * 
		 * Reference:
		 *   "BIOS and Kernel Developer's Guide for AMD NPT
		 *    Family 0Fh Processors"
		 *   #32559 revision 3.00
		 */
		if ((cpu_id & 0x00000f00) == 0x00000f00 &&
		    (cpu_id & 0x0fff0000) >= 0x00040000) {
			uint64_t msr;

			msr = rdmsr(MSR_INT_PEN_MSG);
			if (msr & (IPM_C1E_CMP_HLT|IPM_SMI_CMP_HLT)) {
				msr &= ~(IPM_C1E_CMP_HLT|IPM_SMI_CMP_HLT);
				wrmsr(MSR_INT_PEN_MSG, msr);
			}
		}
	}

	for (i = 0; i < mp_nintrs; i++) {
		mpi = &mp_intrs[i];
		if (mpi->ioapic == NULL && (mpi->cpu_id == MPS_ALL_APICS
					    || mpi->cpu_id == ci->ci_apicid)) {
#ifdef DIAGNOSTIC
			if (mpi->ioapic_pin > 1)
				panic("lapic_set_lvt: bad pin value %d",
				    mpi->ioapic_pin);
#endif
			if (mpi->ioapic_pin == 0)
				lapic_writereg(LAPIC_LVINT0, mpi->redir);
			else
				lapic_writereg(LAPIC_LVINT1, mpi->redir);
		}
	}

#ifdef MULTIPROCESSOR
	if (mp_verbose) {
		apic_format_redir(ci->ci_dev->dv_xname, "timer", 0, 0,
		    lapic_readreg(LAPIC_LVTT));
		apic_format_redir(ci->ci_dev->dv_xname, "pcint", 0, 0,
		    lapic_readreg(LAPIC_PCINT));
		apic_format_redir(ci->ci_dev->dv_xname, "lint", 0, 0,
		    lapic_readreg(LAPIC_LVINT0));
		apic_format_redir(ci->ci_dev->dv_xname, "lint", 1, 0,
		    lapic_readreg(LAPIC_LVINT1));
		apic_format_redir(ci->ci_dev->dv_xname, "err", 0, 0,
		    lapic_readreg(LAPIC_LVERR));
	}
#endif
}

/*
 * Initialize fixed idt vectors for use by local apic.
 */
void
lapic_boot_init(paddr_t lapic_base)
{
	static u_int64_t clk_irq = 0;
#ifdef MULTIPROCESSOR
	static u_int64_t ipi_irq = 0;
#endif

	lapic_map(lapic_base);

#ifdef MULTIPROCESSOR
	idt_allocmap[LAPIC_IPI_VECTOR] = 1;
	idt_vec_set(LAPIC_IPI_VECTOR, Xintr_lapic_ipi);
	idt_allocmap[LAPIC_IPI_INVLTLB] = 1;
	idt_vec_set(LAPIC_IPI_INVLTLB, Xipi_invltlb);
	idt_allocmap[LAPIC_IPI_INVLPG] = 1;
	idt_vec_set(LAPIC_IPI_INVLPG, Xipi_invlpg);
	idt_allocmap[LAPIC_IPI_INVLRANGE] = 1;
	idt_vec_set(LAPIC_IPI_INVLRANGE, Xipi_invlrange);
#endif
	idt_allocmap[LAPIC_SPURIOUS_VECTOR] = 1;
	idt_vec_set(LAPIC_SPURIOUS_VECTOR, Xintrspurious);

	idt_allocmap[LAPIC_TIMER_VECTOR] = 1;
	idt_vec_set(LAPIC_TIMER_VECTOR, Xintr_lapic_ltimer);

#if NXEN > 0
	/* Xen HVM Event Channel Interrupt Vector */
	idt_allocmap[LAPIC_XEN_VECTOR] = 1;
	idt_vec_set(LAPIC_XEN_VECTOR, Xintr_xen_upcall);
#endif
#if NHYPERV > 0
	/* Hyper-V Interrupt Vector */
	idt_allocmap[LAPIC_HYPERV_VECTOR] = 1;
	idt_vec_set(LAPIC_HYPERV_VECTOR, Xintr_hyperv_upcall);
#endif

	evcount_attach(&clk_count, "clock", &clk_irq);
#ifdef MULTIPROCESSOR
	evcount_attach(&ipi_count, "ipi", &ipi_irq);
#endif
}

static __inline u_int32_t
lapic_gettick(void)
{
	return lapic_readreg(LAPIC_CCR_TIMER);
}

#include <sys/kernel.h>		/* for hz */

u_int32_t lapic_tval;

/*
 * this gets us up to a 4GHz busclock....
 */
u_int32_t lapic_per_second;
u_int32_t lapic_frac_usec_per_cycle;
u_int64_t lapic_frac_cycle_per_usec;
u_int32_t lapic_delaytab[26];

void
lapic_clockintr(void *arg, struct intrframe frame)
{
	struct cpu_info *ci = curcpu();
	int floor;

	floor = ci->ci_handled_intr_level;
	ci->ci_handled_intr_level = ci->ci_ilevel;
	hardclock((struct clockframe *)&frame);
	ci->ci_handled_intr_level = floor;

	clk_count.ec_count++;
}

void
lapic_startclock(void)
{
	/*
	 * Start local apic countdown timer running, in repeated mode.
	 *
	 * Mask the clock interrupt and set mode,
	 * then set divisor,
	 * then unmask and set the vector.
	 */
	lapic_writereg(LAPIC_LVTT, LAPIC_LVTT_TM|LAPIC_LVTT_M);
	lapic_writereg(LAPIC_DCR_TIMER, LAPIC_DCRT_DIV1);
	lapic_writereg(LAPIC_ICR_TIMER, lapic_tval);
	lapic_writereg(LAPIC_LVTT, LAPIC_LVTT_TM|LAPIC_TIMER_VECTOR);
}

void
lapic_initclocks(void)
{
	lapic_startclock();

	i8254_inittimecounter_simple();
}


extern int gettick(void);	/* XXX put in header file */
extern u_long rtclock_tval; /* XXX put in header file */

static __inline void
wait_next_cycle(void)
{
	unsigned int tick, tlast;

	tlast = (1 << 16);	/* i8254 counter has 16 bits at most */
	for (;;) {
		tick = gettick();
		if (tick > tlast)
			return;
		tlast = tick;
	}
}

/*
 * Calibrate the local apic count-down timer (which is running at
 * bus-clock speed) vs. the i8254 counter/timer (which is running at
 * a fixed rate).
 *
 * The Intel MP spec says: "An MP operating system may use the IRQ8
 * real-time clock as a reference to determine the actual APIC timer clock
 * speed."
 *
 * We're actually using the IRQ0 timer.  Hmm.
 */
void
lapic_calibrate_timer(struct cpu_info *ci)
{
	unsigned int startapic, endapic;
	u_int64_t dtick, dapic, tmp;
	long rf = read_rflags();
	int i;

	if (mp_verbose)
		printf("%s: calibrating local timer\n", ci->ci_dev->dv_xname);

	/*
	 * Configure timer to one-shot, interrupt masked,
	 * large positive number.
	 */
	lapic_writereg(LAPIC_LVTT, LAPIC_LVTT_M);
	lapic_writereg(LAPIC_DCR_TIMER, LAPIC_DCRT_DIV1);
	lapic_writereg(LAPIC_ICR_TIMER, 0x80000000);

	disable_intr();

	/* wait for current cycle to finish */
	wait_next_cycle();

	startapic = lapic_gettick();

	/* wait the next hz cycles */
	for (i = 0; i < hz; i++)
		wait_next_cycle();

	endapic = lapic_gettick();
	write_rflags(rf);

	dtick = hz * rtclock_tval;
	dapic = startapic-endapic;

	/*
	 * there are TIMER_FREQ ticks per second.
	 * in dtick ticks, there are dapic bus clocks.
	 */
	tmp = (TIMER_FREQ * dapic) / dtick;

	lapic_per_second = tmp;

	printf("%s: apic clock running at %lldMHz\n",
	    ci->ci_dev->dv_xname, tmp / (1000 * 1000));

	if (lapic_per_second != 0) {
		/*
		 * reprogram the apic timer to run in periodic mode.
		 * XXX need to program timer on other cpu's, too.
		 */
		lapic_tval = (lapic_per_second * 2) / hz;
		lapic_tval = (lapic_tval / 2) + (lapic_tval & 0x1);

		lapic_writereg(LAPIC_LVTT, LAPIC_LVTT_TM | LAPIC_LVTT_M |
		    LAPIC_TIMER_VECTOR);
		lapic_writereg(LAPIC_DCR_TIMER, LAPIC_DCRT_DIV1);
		lapic_writereg(LAPIC_ICR_TIMER, lapic_tval);

		/*
		 * Compute fixed-point ratios between cycles and
		 * microseconds to avoid having to do any division
		 * in lapic_delay.
		 */

		tmp = (1000000 * (u_int64_t)1 << 32) / lapic_per_second;
		lapic_frac_usec_per_cycle = tmp;

		tmp = (lapic_per_second * (u_int64_t)1 << 32) / 1000000;

		lapic_frac_cycle_per_usec = tmp;

		/*
		 * Compute delay in cycles for likely short delays in usec.
		 */
		for (i = 0; i < 26; i++)
			lapic_delaytab[i] = (lapic_frac_cycle_per_usec * i) >>
			    32;

		/*
		 * Now that the timer's calibrated, use the apic timer routines
		 * for all our timing needs..
		 */
		delay_func = lapic_delay;
		initclock_func = lapic_initclocks;
	}
}

/*
 * delay for N usec.
 */

void
lapic_delay(int usec)
{
	int32_t tick, otick;
	int64_t deltat;		/* XXX may want to be 64bit */

	otick = lapic_gettick();

	if (usec <= 0)
		return;
	if (usec <= 25)
		deltat = lapic_delaytab[usec];
	else
		deltat = (lapic_frac_cycle_per_usec * usec) >> 32;

	while (deltat > 0) {
		tick = lapic_gettick();
		if (tick > otick)
			deltat -= lapic_tval - (tick - otick);
		else
			deltat -= otick - tick;
		otick = tick;

		CPU_BUSY_CYCLE();
	}
}

/*
 * XXX the following belong mostly or partly elsewhere..
 */

#ifdef MULTIPROCESSOR
static __inline void i82489_icr_wait(void);

static __inline void
i82489_icr_wait(void)
{
#ifdef DIAGNOSTIC
	unsigned j = 100000;
#endif /* DIAGNOSTIC */

	while ((i82489_readreg(LAPIC_ICRLO) & LAPIC_DLSTAT_BUSY) != 0) {
		__asm volatile("pause": : :"memory");
#ifdef DIAGNOSTIC
		j--;
		if (j == 0)
			panic("i82489_icr_wait: busy");
#endif /* DIAGNOSTIC */
	}
}

void
i82489_ipi_init(int target)
{

	if ((target & LAPIC_DEST_MASK) == 0)
		i82489_writereg(LAPIC_ICRHI, target << LAPIC_ID_SHIFT);

	i82489_writereg(LAPIC_ICRLO, (target & LAPIC_DEST_MASK) |
	    LAPIC_DLMODE_INIT | LAPIC_LVL_ASSERT );

	i82489_icr_wait();

	i8254_delay(10000);

	i82489_writereg(LAPIC_ICRLO, (target & LAPIC_DEST_MASK) |
	     LAPIC_DLMODE_INIT | LAPIC_LVL_TRIG | LAPIC_LVL_DEASSERT);

	i82489_icr_wait();
}

void
i82489_ipi(int vec, int target, int dl)
{
	int s;

	s = splhigh();

	i82489_icr_wait();

	if ((target & LAPIC_DEST_MASK) == 0)
		i82489_writereg(LAPIC_ICRHI, target << LAPIC_ID_SHIFT);

	i82489_writereg(LAPIC_ICRLO,
	    (target & LAPIC_DEST_MASK) | vec | dl | LAPIC_LVL_ASSERT);

	i82489_icr_wait();

	splx(s);
}

void
x2apic_ipi_init(int target)
{
	u_int64_t hi = 0;

	if ((target & LAPIC_DEST_MASK) == 0)
		hi = target & 0xff;

	x2apic_writeicr(hi, (target & LAPIC_DEST_MASK) | LAPIC_DLMODE_INIT |
	    LAPIC_LVL_ASSERT );

	i8254_delay(10000);

	x2apic_writeicr(0, (target & LAPIC_DEST_MASK) | LAPIC_DLMODE_INIT |
	    LAPIC_LVL_TRIG | LAPIC_LVL_DEASSERT);
}

void
x2apic_ipi(int vec, int target, int dl)
{
	u_int64_t hi = 0, lo;

	if ((target & LAPIC_DEST_MASK) == 0)
		hi = target & 0xff;

	lo = (target & LAPIC_DEST_MASK) | vec | dl | LAPIC_LVL_ASSERT;

	x2apic_writeicr(hi, lo);
}

void
x86_ipi_init(int target)
{
	if (x2apic_enabled)
		x2apic_ipi_init(target);
	else
		i82489_ipi_init(target);
}
#endif /* MULTIPROCESSOR */


/*
 * Using 'pin numbers' as:
 * 0 - timer
 * 1 - unused
 * 2 - PCINT
 * 3 - LVINT0
 * 4 - LVINT1
 * 5 - LVERR
 */

void
lapic_hwmask(struct pic *pic, int pin)
{
	int reg;
	u_int32_t val;

	reg = LAPIC_LVTT + (pin << 4);
	val = lapic_readreg(reg);
	val |= LAPIC_LVT_MASKED;
	lapic_writereg(reg, val);
}

void
lapic_hwunmask(struct pic *pic, int pin)
{
	int reg;
	u_int32_t val;

	reg = LAPIC_LVTT + (pin << 4);
	val = lapic_readreg(reg);
	val &= ~LAPIC_LVT_MASKED;
	lapic_writereg(reg, val);
}

void
lapic_setup(struct pic *pic, struct cpu_info *ci, int pin, int idtvec, int type)
{
}
@


1.47
log
@Kill SPINLOCK_SPIN_HOOK, use CPU_BUSY_CYCLE() instead.

ok visa@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.46 2017/05/25 03:54:10 visa Exp $	*/
d151 1
d158 1
d584 1
a603 1
#ifdef MULTIPROCESSOR
@


1.46
log
@Replace the only usage of x86_pause() with SPINLOCK_SPIN_HOOK.

OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.45 2016/11/01 01:13:19 yasuoka Exp $	*/
a43 1
#include <machine/lock.h>
d574 1
a574 1
		SPINLOCK_SPIN_HOOK;
@


1.45
log
@Use x2APIC if it is enabled by BIOS.  It is expected that this doesn't
change the behavior on the system whose x2apic is disabled by BIOS.

ok sf
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.44 2016/06/22 01:12:38 mikeb Exp $	*/
d44 1
d575 1
a575 1
		x86_pause();
@


1.44
log
@Setup Hyper-V hypercall page and an IDT vector.

ok mlarkin, kettenis, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.43 2016/03/06 22:41:24 naddy Exp $	*/
d173 1
d175 4
a178 17
	/*
	 * On real hardware, x2apic must only be enabled if interrupt remapping
	 * is also enabled. See 10.12.7 of the SDM vol 3.
	 * On hypervisors, this is not necessary. Hypervisors can implement
	 * x2apic support even if the host CPU does not support it.
	 * Until we support interrupt remapping, use x2apic only if the
	 * hypervisor flag is also set.
	 */
	if ((cpu_ecxfeature&CPUIDECX_X2APIC) && (cpu_ecxfeature&CPUIDECX_HV)) {
		u_int64_t msr;

		disable_intr();
		s = lapic_tpr;

		msr = rdmsr(MSR_APICBASE);
		msr |= APICBASE_ENABLE_X2APIC;
		wrmsr(MSR_APICBASE, msr);
d180 16
a201 1

d205 15
a219 1
		enable_intr();
d221 1
a221 1
		return;
a223 19
	va = (vaddr_t)&local_apic;

	disable_intr();
	s = lapic_tpr;

	/*
	 * Map local apic.  If we have a local apic, it's safe to assume
	 * we're on a 486 or better and can use invlpg and non-cacheable PTE's
	 *
	 * Whap the PTE "by hand" rather than calling pmap_kenter_pa because
	 * the latter will attempt to invoke TLB shootdown code just as we
	 * might have changed the value of cpu_number()..
	 */

	pte = kvtopte(va);
	*pte = lapic_base | PG_RW | PG_V | PG_N | PG_G | pg_nx;
	invlpg(va);

	lapic_tpr = s;
@


1.43
log
@Sync no-argument function declaration and definition by adding (void).
ok kettenis@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.42 2015/12/08 19:45:55 mikeb Exp $	*/
d59 1
d362 5
@


1.42
log
@Set up an IDT vector for Xen callbacks

This adds support for delivering the combined Xen interrupt
that later fans out into event port specific (device specific)
interrupts via an IDT of a guest system.

The Xen IDT vector is set to be the first of the IPL_NET group
and is implemented the same way LAPIC timer and IPIs are done.
The additional machinery is there to be able to mask it via
standard mechanisms (e.g. splnet).

Discussed with kettenis@@, OK mlarkin, reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.41 2015/07/18 19:21:02 sf Exp $	*/
d97 1
a97 1
u_int32_t x2apic_cpu_number();
d102 1
a102 1
u_int32_t i82489_cpu_number();
d120 1
a120 1
i82489_cpu_number()
d139 1
a139 1
x2apic_cpu_number()
d158 1
a158 1
lapic_cpu_number()
@


1.41
log
@Make {x86,i82489,x2apic,i386}_ipi return void

They always returned 0

ok mlarkin@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.40 2015/07/18 19:19:14 sf Exp $	*/
d58 1
d356 6
@


1.40
log
@Make *_ipi_init return void on i386/amd64

They always returned 0

ok mlarkin@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.39 2015/04/19 19:45:21 sf Exp $	*/
d98 1
a98 1
int x2apic_ipi(int vec, int target, int dl);
d103 1
a103 1
int i82489_ipi(int vec, int target, int dl);
d108 1
a108 1
int (*x86_ipi)(int vec, int target, int dl)	= i82489_ipi;
d611 1
a611 1
int
a628 2

	return 0;
d648 1
a648 1
int
a658 2

	return 0;
@


1.39
log
@Add support for x2apic mode

This is currently only enabled on hypervisors because on real hardware, it
requires interrupt remapping which we don't support yet. But on virtualization
it reduces the number of vmexits required per IPI from 4 to 1, causing a
significant speed-up for MP guests.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.38 2015/03/14 03:38:46 jsg Exp $	*/
d591 1
a591 1
int
a608 2

	return 0;
d633 1
a633 1
int
a647 2

	return 0;
d665 1
a665 1
int
d669 1
a669 1
		return x2apic_ipi_init(target);
d671 1
a671 1
		return i82489_ipi_init(target);
@


1.38
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.37 2015/01/06 12:50:47 dlg Exp $	*/
d41 1
d92 73
d170 36
a205 1
	vaddr_t va = (vaddr_t)&local_apic;
d233 1
a233 1
	i82489_writereg(LAPIC_SVR, LAPIC_SVR_ENABLE | LAPIC_SPURIOUS_VECTOR);
d239 1
a239 1
	i82489_writereg(LAPIC_SVR, 0);
d253 1
a253 1
		    i82489_readreg(LAPIC_LVINT0));
d255 1
a255 1
		    i82489_readreg(LAPIC_LVINT1));
d264 1
a264 1
		lint0 = i82489_readreg(LAPIC_LVINT0);
d266 1
a266 1
		i82489_writereg(LAPIC_LVINT0, lint0);
d305 1
a305 1
				i82489_writereg(LAPIC_LVINT0, mpi->redir);
d307 1
a307 1
				i82489_writereg(LAPIC_LVINT1, mpi->redir);
d314 1
a314 1
		    i82489_readreg(LAPIC_LVTT));
d316 1
a316 1
		    i82489_readreg(LAPIC_PCINT));
d318 1
a318 1
		    i82489_readreg(LAPIC_LVINT0));
d320 1
a320 1
		    i82489_readreg(LAPIC_LVINT1));
d322 1
a322 1
		    i82489_readreg(LAPIC_LVERR));
d365 1
a365 1
	return i82489_readreg(LAPIC_CCR_TIMER);
d404 4
a407 4
	i82489_writereg(LAPIC_LVTT, LAPIC_LVTT_TM|LAPIC_LVTT_M);
	i82489_writereg(LAPIC_DCR_TIMER, LAPIC_DCRT_DIV1);
	i82489_writereg(LAPIC_ICR_TIMER, lapic_tval);
	i82489_writereg(LAPIC_LVTT, LAPIC_LVTT_TM|LAPIC_TIMER_VECTOR);
d462 3
a464 3
	i82489_writereg(LAPIC_LVTT, LAPIC_LVTT_M);
	i82489_writereg(LAPIC_DCR_TIMER, LAPIC_DCRT_DIV1);
	i82489_writereg(LAPIC_ICR_TIMER, 0x80000000);
d502 1
a502 1
		i82489_writereg(LAPIC_LVTT, LAPIC_LVTT_TM | LAPIC_LVTT_M |
d504 2
a505 2
		i82489_writereg(LAPIC_DCR_TIMER, LAPIC_DCRT_DIV1);
		i82489_writereg(LAPIC_ICR_TIMER, lapic_tval);
d592 1
a592 1
x86_ipi_init(int target)
d614 1
a614 1
x86_ipi(int vec, int target, int dl)
d634 43
d697 1
a697 1
	val = i82489_readreg(reg);
d699 1
a699 1
	i82489_writereg(reg, val);
d709 1
a709 1
	val = i82489_readreg(reg);
d711 1
a711 1
	i82489_writereg(reg, val);
@


1.37
log
@when we're entering an interrupt handler, record its ipl so splassert
can check if we're entering code we think should only be used from
lower ipls.

modelled a bit on how sparc64 does things.

with help from and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.36 2014/12/18 05:33:48 mlarkin Exp $	*/
a42 1
#include <machine/cpuvar.h>
@


1.36
log
@
Unmap the MP hatch and ACPI resume trampolines when not in active use.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.35 2014/11/20 06:51:41 mlarkin Exp $	*/
d275 2
d278 2
d281 1
@


1.35
log
@
Move previous PTE permission fixup code into locore, and fixup some more
ranges while we're there.

ok deraadt@@, tested by many and in snaps
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.34 2014/11/11 17:09:30 mlarkin Exp $	*/
a113 4

#ifdef MULTIPROCESSOR
	cpu_init_first();
#endif
@


1.34
log
@
Local APIC page doesn't need X permissions.

ok deraadt, guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.33 2014/09/21 16:14:52 sf Exp $	*/
a97 1
	pt_entry_t pg_nx = (cpu_feature & CPUID_NXE? PG_NX : 0);
@


1.33
log
@Don't check LAPIC_DLSTAT_BUSY again after an IPI

Depending on DIAGNOSTICS, i82489_icr_wait() will either spin or panic in
this case. Therefore there is no need to check the flag again.

On virtualization, this saves one VMEXIT per IPI.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.32 2014/09/14 14:17:23 jsg Exp $	*/
d98 1
d113 1
a113 1
	*pte = lapic_base | PG_RW | PG_V | PG_N | PG_G;
@


1.32
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.31 2014/03/29 18:09:28 guenther Exp $	*/
d501 1
a501 1
	return (i82489_readreg(LAPIC_ICRLO) & LAPIC_DLSTAT_BUSY) ? EBUSY : 0;
d507 1
a507 1
	int result, s;
a520 2
	result = (i82489_readreg(LAPIC_ICRLO) & LAPIC_DLSTAT_BUSY) ? EBUSY : 0;

d523 1
a523 1
	return result;
@


1.31
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.30 2014/03/07 16:56:57 guenther Exp $	*/
a35 1
#include <sys/proc.h>
@


1.30
log
@We already assume global mappings (PG_G) are supported, so pmap_pg_g is
unnecessary

ok krw@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.29 2014/01/21 09:40:54 kettenis Exp $	*/
d473 1
a473 1
		__asm __volatile("pause": : :"memory");
@


1.29
log
@Disable lapic when halting CPUs.  Allegedly this is necessary to make
suspend work on some machines.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.28 2013/06/02 18:16:42 gerhard Exp $	*/
d113 1
a113 1
	*pte = lapic_base | PG_RW | PG_V | PG_N | pmap_pg_g;
@


1.28
log
@Fix a bug where the calibration loop could show wrong CPU frequencies.
In case the 'starttick' had a rather large value, the code could miss
one or more cycles of the i8254 timer.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.27 2010/09/20 06:33:46 matthew Exp $	*/
d131 6
@


1.27
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.26 2010/07/25 21:43:38 deraadt Exp $	*/
d308 14
d336 1
a336 2
	unsigned int starttick, tick1, tick2, endtick;
	unsigned int startapic, apic1, apic2, endapic;
d353 4
a356 1
	starttick = gettick();
d359 3
a361 12
	for (i = 0; i < hz; i++) {
		i8254_delay(2);
		do {
			tick1 = gettick();
			apic1 = lapic_gettick();
		} while (tick1 < starttick);
		i8254_delay(2);
		do {
			tick2 = gettick();
			apic2 = lapic_gettick();
		} while (tick2 > starttick);
	}
a362 1
	endtick = gettick();
d366 1
a366 1
	dtick = hz * rtclock_tval + (starttick-endtick);
@


1.26
log
@in the clock drivers, seperate the soft-state and hard-state which was
all jumbled up in the same functions. the rtc (mc chip) and clock (i8243)
startup was also mixed up.  they the soft state and hardware state can
be started in the right order, and it is easy to restart just the
neccessary parts upon resume.  tested in numerous cases:
(apic, pic) * (GENERIC.MP, GENERIC) * (mp, non-mp) * (i386, amd64)
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.25 2010/07/23 07:21:02 matthew Exp $	*/
d247 1
a247 1
	evcount_attach(&clk_count, "clock", (void *)&clk_irq, &evcount_intr);
d249 1
a249 1
	evcount_attach(&ipi_count, "ipi", (void *)&ipi_irq, &evcount_intr);
@


1.25
log
@Omit more IPI code from non-MP kernels.  Found using --gc-sections.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.24 2010/06/26 23:24:43 guenther Exp $	*/
d281 1
a281 1
lapic_initclocks(void)
d296 9
a306 1
extern void (*initclock_func)(void); /* XXX put in header file */
@


1.24
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.23 2010/04/01 19:47:59 kettenis Exp $	*/
d65 1
d67 1
d225 1
d227 1
d248 1
d250 1
d462 1
d508 1
@


1.23
log
@Don't index cpu_info by apic id, but by device unit number instead.  Recent
Intel CPUs come up with apic id's >= 32, even on systems with less than 32
logical CPUs.

ok krw@@, marco@@; tested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.22 2009/08/10 17:04:37 deraadt Exp $	*/
a36 1
#include <sys/user.h>
@


1.22
log
@use splhigh instead of splclock to block in the i386_ipi
fixes stability problems on some machines; ie. crashes in
in cpu_idle_cycle
from netbsd, via dhill
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.21 2009/06/09 02:56:38 krw Exp $	*/
d116 1
a116 1
	cpu_init_first();	/* catch up to changed cpu_number() */
@


1.21
log
@revert guenther@@'s un-revert of art's curpmap.

My

bios0: ASUSTeK Computer INC. P5K-E
cpu0: Intel(R) Core(TM)2 Quad CPU Q6600 @@ 2.40GHz, 2405.74 MHz
cpu1: Intel(R) Core(TM)2 Quad CPU Q6600 @@ 2.40GHz, 2405.46 MHz
cpu2: Intel(R) Core(TM)2 Quad CPU Q6600 @@ 2.40GHz, 2405.46 MHz
cpu3: Intel(R) Core(TM)2 Quad CPU Q6600 @@ 2.40GHz, 2405.46 MHz

can't boot with this in. It always hangs somewhere in fsck'ing if
any, or between netstart and local daemons if no fsck'ing. Also
fubars theo's real amd machine.

Much more testing needed for this.
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.20 2009/06/06 23:45:35 guenther Exp $	*/
d484 1
a484 1
	s = splclock();
@


1.20
log
@Unrevert the curpmap change with the addition of correct %gs handling
in the IPI handler so that it works when it interrupts userspace,
waiting for the droppmap IPI to complete when destroying it, and
(most importantly) don't call pmap_tlb_droppmap() from cpu_exit().
Tested by myself and ckuethe, as our machines choked on the original.

ok @@art
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.18 2009/05/28 09:05:33 art Exp $	*/
a236 2
	idt_allocmap[LAPIC_IPI_RELOADCR3] = 1;
	idt_vec_set(LAPIC_IPI_RELOADCR3, Xipi_reloadcr3);
@


1.19
log
@Revert the curpmap change.  We know the IPI is broken on both ends,
but even with proposed fixes, the reaper panics are back.
@
text
@d237 2
@


1.18
log
@Bring back the curpmap change. It was missing a reload of the pmap on
curcpu when we were freeing a pmap. Tested and working for a few weeks
now, but I was a bit too busy to commit it earlier.
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.16 2009/04/23 07:42:02 art Exp $	*/
a236 2
	idt_allocmap[LAPIC_IPI_RELOADCR3] = 1;
	idt_vec_set(LAPIC_IPI_RELOADCR3, Xipi_reloadcr3);
@


1.17
log
@turning pmap_deactivate into a NOP brought back the reaper panics, probably
because the reaper is running on the mappings of pmap from the process it
is about to unmap.  back it out until ht is fixed right; don't let this sit
in the tree waiting for a fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.15 2008/08/13 15:44:44 art Exp $	*/
d237 2
@


1.16
log
@Make pmap_deactivate a NOP.

Instead of keeping a bitmask of on which cpu the pmap might be active which
we clear in pmap_deactivate, always keep a pointer to the currently loaded
pmap in cpu_info. We can now optimize a context switch to the kernel pmap
(idle and kernel threads) to keep the previously loaded pmap still loaded
and then reuse that pmap if we context switch back to the same process.

Introduce a new IPI to force a pmap reload before the pmap is destroyed.

Clean up cpu_switchto.

toby@@ ok
@
text
@a236 2
	idt_allocmap[LAPIC_IPI_RELOADCR3] = 1;
	idt_vec_set(LAPIC_IPI_RELOADCR3, Xipi_reloadcr3);
@


1.15
log
@Disable the fantastics mis-feature on some newer Turion CPUs called C1E.
This "power saving" disables the apic when both cpu cores hit the hlt
instruction which kills our timer.

From FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.14 2008/06/26 05:42:09 ray Exp $	*/
d237 2
@


1.14
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.13 2008/01/26 11:18:42 kettenis Exp $	*/
d159 25
@


1.13
log
@Unify i386 and amd64 lapic code, and calibrate lapic timer with interrupts
disabled (as suggested by mickey).

ok krw@@, marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.12 2007/11/29 10:53:54 deraadt Exp $	*/
a20 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.12
log
@outdated comment
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.11 2007/11/16 16:16:07 deraadt Exp $	*/
a49 2
#include <dev/ic/i8253reg.h>

d64 2
d75 1
a75 1
void		lapic_delay(int);
d77 3
a79 2
void		lapic_clockintr(void *, struct intrframe);
void	 	lapic_map(paddr_t);
d149 1
a149 1
		apic_format_redir (ci->ci_dev->dv_xname, "prelint", 0, 0,
d151 1
a151 1
		apic_format_redir (ci->ci_dev->dv_xname, "prelint", 1, 0,
d185 1
a185 1
		apic_format_redir (ci->ci_dev->dv_xname, "timer", 0, 0,
d187 1
a187 1
		apic_format_redir (ci->ci_dev->dv_xname, "pcint", 0, 0,
d189 1
a189 1
		apic_format_redir (ci->ci_dev->dv_xname, "lint", 0, 0,
d191 1
a191 1
		apic_format_redir (ci->ci_dev->dv_xname, "lint", 1, 0,
d193 1
a193 1
		apic_format_redir (ci->ci_dev->dv_xname, "err", 0, 0,
d230 1
a230 1
static inline u_int32_t
d267 4
a270 4
	i82489_writereg (LAPIC_LVTT, LAPIC_LVTT_TM|LAPIC_LVTT_M);
	i82489_writereg (LAPIC_DCR_TIMER, LAPIC_DCRT_DIV1);
	i82489_writereg (LAPIC_ICR_TIMER, lapic_tval);
	i82489_writereg (LAPIC_LVTT, LAPIC_LVTT_TM|LAPIC_TIMER_VECTOR);
d294 1
d304 3
a306 3
	i82489_writereg (LAPIC_LVTT, LAPIC_LVTT_M);
	i82489_writereg (LAPIC_DCR_TIMER, LAPIC_DCRT_DIV1);
	i82489_writereg (LAPIC_ICR_TIMER, 0x80000000);
d308 1
d312 2
a313 2
	for (i=0; i<hz; i++) {
		DELAY(2);
d318 1
a318 1
		DELAY(2);
d327 1
d351 4
a354 4
		i82489_writereg (LAPIC_LVTT, LAPIC_LVTT_TM|LAPIC_LVTT_M
		    |LAPIC_TIMER_VECTOR);
		i82489_writereg (LAPIC_DCR_TIMER, LAPIC_DCRT_DIV1);
		i82489_writereg (LAPIC_ICR_TIMER, lapic_tval);
d362 1
a362 1
		tmp = (1000000 * (u_int64_t)1<<32) / lapic_per_second;
d365 1
a365 1
		tmp = (lapic_per_second * (u_int64_t)1<<32) / 1000000;
d372 1
a372 1
		for (i=0; i<26; i++)
d430 1
a430 1
		x86_pause();
d443 2
a444 3
	if ((target&LAPIC_DEST_MASK)==0) {
		i82489_writereg(LAPIC_ICRHI, target<<LAPIC_ID_SHIFT);
	}
d451 1
a451 1
	delay(10000);
d458 1
a458 1
	return (i82489_readreg(LAPIC_ICRLO) & LAPIC_DLSTAT_BUSY)?EBUSY:0;
@


1.11
log
@fix the bus_space #define nightmare, so that amd64 and i386 are much more
uniform. as a result shared code like acpi needs less #ifdef's
ok marco kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.10 2007/05/25 16:22:11 art Exp $	*/
a75 1
void		lapic_microtime(struct timeval *);
d355 1
a355 1
		 * in lapic_delay and lapic_microtime.
@


1.10
log
@Change the old slow and complicated TLB shootdown code to new, fast and
simple. This is basically the same code as on i386 and basically the same
performance improvements.

This change also includes code to delay the freeing of ptps until they
have been properly shot.

in snaps for a week, no problems reported.
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.9 2007/02/19 11:59:00 tom Exp $	*/
d167 1
a167 1
	for (i = 0; i < mp_nintr; i++) {
@


1.9
log
@Remove unused variable lapic_timer

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.8 2007/01/24 20:26:59 kettenis Exp $	*/
d213 6
@


1.8
log
@Check nioapics to see whether we're using I/O APICs.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.7 2007/01/15 23:19:05 jsg Exp $	*/
a231 1
int lapic_timer = 0;
@


1.7
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.6 2006/03/10 21:21:08 brad Exp $	*/
d66 6
d156 1
a158 1
	 * XXX mp_nintr > 0 isn't quite the right test for this.
d160 1
a160 1
	if (mp_nintr > 0) {
d165 1
d182 1
a182 1
			
@


1.6
log
@- Wrap IPI sending in splclock(), since an interrupt at
  IPL_CLOCK or lower may cause IPIs.
- Make broadcast IPIs go through x86_ipi() as well, so that
  they wait for the APIC to be ready too.
- Introduce a function, i82489_icr_wait, which waits for
  LAPIC_DLSTAT_BUSY cleared, and use it where appropriate.
- Panic if lapic's busy too long and DIAGNOSTIC.

From NetBSD

Tested on a few amd64 MP systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.5 2006/03/10 21:09:22 mickey Exp $	*/
d94 1
a94 2
lapic_map(lapic_base)
	paddr_t lapic_base;
d128 1
a128 1
lapic_enable()
d134 1
a134 1
lapic_set_lvt()
d196 1
a196 2
lapic_boot_init(lapic_base)
	paddr_t lapic_base;
d217 2
a218 1
static inline u_int32_t lapic_gettick()
d246 1
a246 1
lapic_initclocks()
d277 1
a277 2
lapic_calibrate_timer(ci)
	struct cpu_info *ci;
d375 1
a375 2
lapic_delay(usec)
	int usec;
d408 1
a408 1
i82489_icr_wait()
d425 1
a425 2
x86_ipi_init(target)
	int target;
d448 1
a448 2
x86_ipi(vec,target,dl)
	int vec,target,dl;
@


1.5
log
@provide a counter for ipis
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.4 2005/12/13 23:33:25 mickey Exp $	*/
d408 19
a430 1
	unsigned j;
d439 1
a439 3
	for (j=100000; j > 0; j--)
		if ((i82489_readreg(LAPIC_ICRLO) & LAPIC_DLSTAT_BUSY) == 0)
			break;
d446 1
a446 3
	for (j=100000; j > 0; j--)
		if ((i82489_readreg(LAPIC_ICRLO) & LAPIC_DLSTAT_BUSY) == 0)
			break;
d455 1
a455 2
	unsigned j;
	int result;
d457 3
a459 4
	for (j=100000;
	     j > 0 && (i82489_readreg(LAPIC_ICRLO) & LAPIC_DLSTAT_BUSY);
	     j--)
		;
d467 1
a467 4
	for (j=100000;
	     j > 0 && (i82489_readreg(LAPIC_ICRLO) & LAPIC_DLSTAT_BUSY);
	     j--)
		;
d470 2
@


1.4
log
@print lapic clock in mhz (instead of hz)
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.3 2004/06/28 01:52:24 deraadt Exp $	*/
d67 1
d201 1
d216 1
@


1.3
log
@Use new event counter API for interrupt counting on amd64.  Based in part
on some changes in the i386 codebase.
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.2 2004/06/27 16:17:50 deraadt Exp $	*/
d324 2
a325 1
	printf("%s: apic clock running at %lldHz\n", ci->ci_dev->dv_xname, tmp);
@


1.2
log
@quieter boot requested by art
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.1 2004/06/25 11:03:27 art Exp $	*/
d66 2
d199 1
d212 2
d239 2
@


1.1
log
@SMP support. Big parts from NetBSD, but with some really serious debugging
done by me, niklas and others. Especially wrt. NXE support.

Still needs some polishing, especially in dmesg messages, but we're now
building kernel faster than ever.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d276 2
a277 1
	printf("%s: calibrating local timer\n", ci->ci_dev->dv_xname);
@

