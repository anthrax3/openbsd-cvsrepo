head	1.82;
access;
symbols
	OPENBSD_6_0:1.73.0.2
	OPENBSD_6_0_BASE:1.73
	OPENBSD_5_9:1.72.0.2
	OPENBSD_5_9_BASE:1.72
	OPENBSD_5_8:1.63.0.4
	OPENBSD_5_8_BASE:1.63
	OPENBSD_5_7:1.60.0.2
	OPENBSD_5_7_BASE:1.60
	OPENBSD_5_6:1.54.0.4
	OPENBSD_5_6_BASE:1.54
	OPENBSD_5_5:1.52.0.4
	OPENBSD_5_5_BASE:1.52
	OPENBSD_5_4:1.49.0.2
	OPENBSD_5_4_BASE:1.49
	OPENBSD_5_3:1.43.0.2
	OPENBSD_5_3_BASE:1.43
	OPENBSD_5_2:1.36.0.2
	OPENBSD_5_2_BASE:1.36
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.2
	OPENBSD_5_0:1.32.0.2
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.30.0.2
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.29.0.2
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.20.0.4
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.17.0.2
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.14.0.4
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.2
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.11.0.2
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.6.0.6
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.2
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	OPENBSD_3_5:1.4.0.2
	OPENBSD_3_5_BASE:1.4
	SMP:1.2.0.2;
locks; strict;
comment	@ * @;


1.82
date	2017.03.28.21.36.27;	author mlarkin;	state Exp;
branches;
next	1.81;
commitid	3Fbu1w0kuLUYtaxv;

1.81
date	2017.02.14.15.39.14;	author reyk;	state Exp;
branches;
next	1.80;
commitid	apvPenni4FhYRaFJ;

1.80
date	2017.01.13.17.15.27;	author mikeb;	state Exp;
branches;
next	1.79;
commitid	xf3Mp5sczmZXop5L;

1.79
date	2016.12.14.10.30.59;	author reyk;	state Exp;
branches;
next	1.78;
commitid	NXKMneDbVFqc8kx2;

1.78
date	2016.10.13.19.36.25;	author martijn;	state Exp;
branches;
next	1.77;
commitid	hw7D4Jnj0S4fKrmP;

1.77
date	2016.09.30.07.33.06;	author mlarkin;	state Exp;
branches;
next	1.76;
commitid	SE7Bj6m3HBGqhmFT;

1.76
date	2016.09.27.08.06.22;	author mlarkin;	state Exp;
branches;
next	1.75;
commitid	wBS4oSuvIow7Ys7J;

1.75
date	2016.09.27.08.04.49;	author mlarkin;	state Exp;
branches;
next	1.74;
commitid	ku4p47mroNn82mrs;

1.74
date	2016.09.03.12.12.43;	author mlarkin;	state Exp;
branches;
next	1.73;
commitid	VxEixNTRhSw9wrcd;

1.73
date	2016.06.22.07.22.00;	author mlarkin;	state Exp;
branches;
next	1.72;
commitid	M1lpFrN5wVgMVhed;

1.72
date	2016.02.03.03.25.08;	author guenther;	state Exp;
branches;
next	1.71;
commitid	ApB7haYYMOab9uut;

1.71
date	2015.12.27.04.31.34;	author jsg;	state Exp;
branches;
next	1.70;
commitid	dxEnyjnljo1QbPFz;

1.70
date	2015.12.12.12.33.49;	author reyk;	state Exp;
branches;
next	1.69;
commitid	BGb3xaQZJ9ACCtNF;

1.69
date	2015.12.07.06.34.14;	author jsg;	state Exp;
branches;
next	1.68;
commitid	SlCrK8YSV6f5HTmS;

1.68
date	2015.12.05.10.27.48;	author kettenis;	state Exp;
branches;
next	1.67;
commitid	h77jAaRQqmw04uvv;

1.67
date	2015.11.23.22.57.12;	author deraadt;	state Exp;
branches;
next	1.66;
commitid	lOkXFQaUGdej50W4;

1.66
date	2015.11.13.07.52.20;	author mlarkin;	state Exp;
branches;
next	1.65;
commitid	KdsjYlqLpqhwOUHf;

1.65
date	2015.11.07.01.37.26;	author naddy;	state Exp;
branches;
next	1.64;
commitid	L3HpIZTyGf6C2PRf;

1.64
date	2015.08.12.05.31.41;	author mlarkin;	state Exp;
branches;
next	1.63;
commitid	kgFr88L7fdFL8wku;

1.63
date	2015.07.21.03.38.22;	author reyk;	state Exp;
branches;
next	1.62;
commitid	t8p39jbat5DBrbFu;

1.62
date	2015.05.28.20.10.58;	author guenther;	state Exp;
branches;
next	1.61;
commitid	nRKEXgw8UCVd37E0;

1.61
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.60;
commitid	p4LJxGKbi0BU2cG6;

1.60
date	2015.02.08.04.41.48;	author deraadt;	state Exp;
branches;
next	1.59;
commitid	X74o6HL4fdPsmZnb;

1.59
date	2015.02.08.03.01.29;	author mlarkin;	state Exp;
branches;
next	1.58;
commitid	ztYFvu2IY19TuyQa;

1.58
date	2015.01.19.16.01.43;	author jsg;	state Exp;
branches;
next	1.57;
commitid	XxkrcoKyIcX4NWk4;

1.57
date	2014.12.16.21.02.58;	author sf;	state Exp;
branches;
next	1.56;
commitid	nEi2aBsgsNXJbY4F;

1.56
date	2014.10.17.18.15.48;	author kettenis;	state Exp;
branches;
next	1.55;
commitid	0TqbINb4qNa18Q8S;

1.55
date	2014.09.14.14.17.23;	author jsg;	state Exp;
branches;
next	1.54;
commitid	uzzBR7hz9ncd4O6G;

1.54
date	2014.07.13.12.11.01;	author jasper;	state Exp;
branches;
next	1.53;
commitid	XHZxhpAa5R1Ymp1z;

1.53
date	2014.07.03.21.15.28;	author matthew;	state Exp;
branches;
next	1.52;
commitid	P69HFjn5e4zdBZir;

1.52
date	2013.11.19.04.12.17;	author guenther;	state Exp;
branches;
next	1.51;

1.51
date	2013.09.26.14.38.51;	author jsg;	state Exp;
branches;
next	1.50;

1.50
date	2013.08.24.23.45.31;	author mlarkin;	state Exp;
branches;
next	1.49;

1.49
date	2013.07.30.20.42.34;	author kettenis;	state Exp;
branches;
next	1.48;

1.48
date	2013.06.04.15.29.16;	author haesbaert;	state Exp;
branches;
next	1.47;

1.47
date	2013.05.06.04.32.12;	author dlg;	state Exp;
branches;
next	1.46;

1.46
date	2013.04.09.01.47.04;	author guenther;	state Exp;
branches;
next	1.45;

1.45
date	2013.03.21.19.43.14;	author kurt;	state Exp;
branches;
next	1.44;

1.44
date	2013.03.21.18.39.18;	author kurt;	state Exp;
branches;
next	1.43;

1.43
date	2012.11.10.09.45.05;	author mglocker;	state Exp;
branches;
next	1.42;

1.42
date	2012.10.31.03.30.22;	author jsg;	state Exp;
branches;
next	1.41;

1.41
date	2012.10.09.09.16.09;	author jsg;	state Exp;
branches;
next	1.40;

1.40
date	2012.10.09.04.40.36;	author jsg;	state Exp;
branches;
next	1.39;

1.39
date	2012.09.19.20.19.31;	author jsg;	state Exp;
branches;
next	1.38;

1.38
date	2012.09.07.22.02.34;	author naddy;	state Exp;
branches;
next	1.37;

1.37
date	2012.08.24.02.49.23;	author guenther;	state Exp;
branches;
next	1.36;

1.36
date	2012.04.22.19.36.09;	author haesbaert;	state Exp;
branches;
next	1.35;

1.35
date	2012.03.27.02.23.04;	author haesbaert;	state Exp;
branches;
next	1.34;

1.34
date	2012.01.08.14.39.26;	author haesbaert;	state Exp;
branches;
next	1.33;

1.33
date	2011.12.26.23.07.04;	author haesbaert;	state Exp;
branches;
next	1.32;

1.32
date	2011.05.29.14.50.25;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2011.05.23.09.52.24;	author claudio;	state Exp;
branches;
next	1.30;

1.30
date	2010.09.07.16.22.48;	author mikeb;	state Exp;
branches;
next	1.29;

1.29
date	2010.07.01.00.24.27;	author thib;	state Exp;
branches;
next	1.28;

1.28
date	2010.06.26.23.24.43;	author guenther;	state Exp;
branches;
next	1.27;

1.27
date	2010.03.21.23.00.57;	author jsg;	state Exp;
branches;
next	1.26;

1.26
date	2009.12.09.21.42.10;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2009.12.09.14.27.33;	author oga;	state Exp;
branches;
next	1.24;

1.24
date	2009.10.07.02.15.48;	author kevlo;	state Exp;
branches;
next	1.23;

1.23
date	2009.09.20.21.58.31;	author jsg;	state Exp;
branches;
next	1.22;

1.22
date	2009.09.20.15.37.23;	author kevlo;	state Exp;
branches;
next	1.21;

1.21
date	2009.07.22.20.33.12;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2009.06.01.03.50.57;	author gwk;	state Exp;
branches;
next	1.19;

1.19
date	2009.05.31.03.48.05;	author matthieu;	state Exp;
branches;
next	1.18;

1.18
date	2009.05.31.03.20.10;	author matthieu;	state Exp;
branches;
next	1.17;

1.17
date	2009.02.16.17.24.21;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2009.02.16.15.50.05;	author jsg;	state Exp;
branches;
next	1.15;

1.15
date	2008.06.13.00.00.45;	author jsg;	state Exp;
branches;
next	1.14;

1.14
date	2007.05.29.07.35.55;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2007.05.29.06.31.44;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2007.05.06.03.37.08;	author gwk;	state Exp;
branches;
next	1.11;

1.11
date	2007.02.17.17.35.43;	author tom;	state Exp;
branches;
next	1.10;

1.10
date	2007.02.13.00.20.59;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.16.02.55.52;	author dlg;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.08.03.33.21;	author uwe;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.07.05.21.40;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2005.08.20.00.33.59;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.25.11.03.27;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2004.02.28.18.12.21;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.27.21.21.44;	author grange;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.09.22.15.52;	author mickey;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2004.01.28.01.39.38;	author mickey;	state Exp;
branches;
next	;

1.2.2.1
date	2004.02.22.22.08.18;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2004.06.05.23.09.24;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.82
log
@add RDTSCP flags to identcpu.c

ok guenther, deraadt
@
text
@/*	$OpenBSD: identcpu.c,v 1.81 2017/02/14 15:39:14 reyk Exp $	*/
/*	$NetBSD: identcpu.c,v 1.1 2003/04/26 18:39:28 fvdl Exp $	*/

/*
 * Copyright (c) 2003 Wasabi Systems, Inc.
 * All rights reserved.
 *
 * Written by Frank van der Linden for Wasabi Systems, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed for the NetBSD Project by
 *      Wasabi Systems, Inc.
 * 4. The name of Wasabi Systems, Inc. may not be used to endorse
 *    or promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sysctl.h>
#include <sys/timetc.h>

#include "vmm.h"

#include <machine/cpu.h>
#include <machine/cpufunc.h>

void	replacesmap(void);
u_int64_t cpu_tsc_freq(struct cpu_info *);
u_int64_t cpu_tsc_freq_ctr(struct cpu_info *);
#if NVMM > 0
void	cpu_check_vmm_cap(struct cpu_info *);
#endif /* NVMM > 0 */

/* sysctl wants this. */
char cpu_model[48];
int cpuspeed;

u_int tsc_get_timecount(struct timecounter *tc);

struct timecounter tsc_timecounter = {
	tsc_get_timecount, NULL, ~0u, 0, "tsc", -1000, NULL
};

int amd64_has_xcrypt;
#ifdef CRYPTO
int amd64_has_pclmul;
int amd64_has_aesni;
#endif
int has_rdrand;
int has_rdseed;

#include "pvbus.h"
#if NPVBUS > 0
#include <dev/pv/pvvar.h>
#endif

const struct {
	u_int32_t	bit;
	char		str[12];
} cpu_cpuid_features[] = {
	{ CPUID_FPU,	"FPU" },
	{ CPUID_VME,	"VME" },
	{ CPUID_DE,	"DE" },
	{ CPUID_PSE,	"PSE" },
	{ CPUID_TSC,	"TSC" },
	{ CPUID_MSR,	"MSR" },
	{ CPUID_PAE,	"PAE" },
	{ CPUID_MCE,	"MCE" },
	{ CPUID_CX8,	"CX8" },
	{ CPUID_APIC,	"APIC" },
	{ CPUID_SEP,	"SEP" },
	{ CPUID_MTRR,	"MTRR" },
	{ CPUID_PGE,	"PGE" },
	{ CPUID_MCA,	"MCA" },
	{ CPUID_CMOV,	"CMOV" },
	{ CPUID_PAT,	"PAT" },
	{ CPUID_PSE36,	"PSE36" },
	{ CPUID_PSN,	"PSN" },
	{ CPUID_CFLUSH,	"CFLUSH" },
	{ CPUID_DS,	"DS" },
	{ CPUID_ACPI,	"ACPI" },
	{ CPUID_MMX,	"MMX" },
	{ CPUID_FXSR,	"FXSR" },
	{ CPUID_SSE,	"SSE" },
	{ CPUID_SSE2,	"SSE2" },
	{ CPUID_SS,	"SS" },
	{ CPUID_HTT,	"HTT" },
	{ CPUID_TM,	"TM" },
	{ CPUID_PBE,	"PBE" }
}, cpu_ecpuid_features[] = {
	{ CPUID_MPC,		"MPC" },
	{ CPUID_NXE,		"NXE" },
	{ CPUID_MMXX,		"MMXX" },
	{ CPUID_FFXSR,		"FFXSR" },
	{ CPUID_PAGE1GB,	"PAGE1GB" },
	{ CPUID_RDTSCP,		"RDTSCP" },
	{ CPUID_LONG,		"LONG" },
	{ CPUID_3DNOW2,		"3DNOW2" },
	{ CPUID_3DNOW,		"3DNOW" }
}, cpu_cpuid_ecxfeatures[] = {
	{ CPUIDECX_SSE3,	"SSE3" },
	{ CPUIDECX_PCLMUL,	"PCLMUL" },
	{ CPUIDECX_DTES64,	"DTES64" },
	{ CPUIDECX_MWAIT,	"MWAIT" },
	{ CPUIDECX_DSCPL,	"DS-CPL" },
	{ CPUIDECX_VMX,		"VMX" },
	{ CPUIDECX_SMX,		"SMX" },
	{ CPUIDECX_EST,		"EST" },
	{ CPUIDECX_TM2,		"TM2" },
	{ CPUIDECX_SSSE3,	"SSSE3" },
	{ CPUIDECX_CNXTID,	"CNXT-ID" },
	{ CPUIDECX_SDBG,	"SDBG" },
	{ CPUIDECX_FMA3,	"FMA3" },
	{ CPUIDECX_CX16,	"CX16" },
	{ CPUIDECX_XTPR,	"xTPR" },
	{ CPUIDECX_PDCM,	"PDCM" },
	{ CPUIDECX_PCID,	"PCID" },
	{ CPUIDECX_DCA,		"DCA" },
	{ CPUIDECX_SSE41,	"SSE4.1" },
	{ CPUIDECX_SSE42,	"SSE4.2" },
	{ CPUIDECX_X2APIC,	"x2APIC" },
	{ CPUIDECX_MOVBE,	"MOVBE" },
	{ CPUIDECX_POPCNT,	"POPCNT" },
	{ CPUIDECX_DEADLINE,	"DEADLINE" },
	{ CPUIDECX_AES,		"AES" },
	{ CPUIDECX_XSAVE,	"XSAVE" },
	{ CPUIDECX_OSXSAVE,	"OSXSAVE" },
	{ CPUIDECX_AVX,		"AVX" },
	{ CPUIDECX_F16C,	"F16C" },
	{ CPUIDECX_RDRAND,	"RDRAND" },
	{ CPUIDECX_HV,		"HV" },
}, cpu_ecpuid_ecxfeatures[] = {
	{ CPUIDECX_LAHF,	"LAHF" },
	{ CPUIDECX_CMPLEG,	"CMPLEG" },
	{ CPUIDECX_SVM,		"SVM" },
	{ CPUIDECX_EAPICSP,	"EAPICSP"},
	{ CPUIDECX_AMCR8,	"AMCR8"},
	{ CPUIDECX_ABM,		"ABM" },
	{ CPUIDECX_SSE4A,	"SSE4A" },
	{ CPUIDECX_MASSE,	"MASSE" },
	{ CPUIDECX_3DNOWP,	"3DNOWP" },
	{ CPUIDECX_OSVW,	"OSVW" },
	{ CPUIDECX_IBS,		"IBS" },
	{ CPUIDECX_XOP,		"XOP" },
	{ CPUIDECX_SKINIT,	"SKINIT" },
	{ CPUIDECX_LWP,		"WDT" },
	{ CPUIDECX_FMA4,	"FMA4" },
	{ CPUIDECX_NODEID,	"NODEID" },
	{ CPUIDECX_TBM,		"TBM" },
	{ CPUIDECX_TOPEXT,	"TOPEXT" },
}, cpu_seff0_ebxfeatures[] = {
	{ SEFF0EBX_FSGSBASE,	"FSGSBASE" },
	{ SEFF0EBX_SGX,		"SGX" },
	{ SEFF0EBX_BMI1,	"BMI1" },
	{ SEFF0EBX_HLE,		"HLE" },
	{ SEFF0EBX_AVX2,	"AVX2" },
	{ SEFF0EBX_SMEP,	"SMEP" },
	{ SEFF0EBX_BMI2,	"BMI2" },
	{ SEFF0EBX_ERMS,	"ERMS" },
	{ SEFF0EBX_INVPCID,	"INVPCID" },
	{ SEFF0EBX_RTM,		"RTM" },
	{ SEFF0EBX_PQM,		"PQM" },
	{ SEFF0EBX_MPX,		"MPX" },
	{ SEFF0EBX_AVX512F,	"AVX512F" },
	{ SEFF0EBX_AVX512DQ,	"AVX512DQ" },
	{ SEFF0EBX_RDSEED,	"RDSEED" },
	{ SEFF0EBX_ADX,		"ADX" },
	{ SEFF0EBX_SMAP,	"SMAP" },
	{ SEFF0EBX_AVX512IFMA,	"AVX512IFMA" },
	{ SEFF0EBX_PCOMMIT,	"PCOMMIT" },
	{ SEFF0EBX_CLFLUSHOPT,	"CLFLUSHOPT" },
	{ SEFF0EBX_CLWB,	"CLWB" },
	{ SEFF0EBX_PT,		"PT" },
	{ SEFF0EBX_AVX512PF,	"AVX512PF" },
	{ SEFF0EBX_AVX512ER,	"AVX512ER" },
	{ SEFF0EBX_AVX512CD,	"AVX512CD" },
	{ SEFF0EBX_SHA,		"SHA" },
	{ SEFF0EBX_AVX512BW,	"AVX512BW" },
	{ SEFF0EBX_AVX512VL,	"AVX512VL" },
}, cpu_seff0_ecxfeatures[] = {
	{ SEFF0ECX_PREFETCHWT1,	"PREFETCHWT1" },
	{ SEFF0ECX_AVX512VBMI,	"AVX512VBMI" },
	{ SEFF0ECX_UMIP,	"UMIP" },
	{ SEFF0ECX_PKU,		"PKU" },
}, cpu_tpm_eaxfeatures[] = {
	{ TPM_SENSOR,		"SENSOR" },
	{ TPM_ARAT,		"ARAT" },
}, cpu_cpuid_perf_eax[] = {
	{ CPUIDEAX_VERID,	"PERF" },
}, cpu_cpuid_apmi_edx[] = {
	{ CPUIDEDX_ITSC,	"ITSC" },
};

int
cpu_amd64speed(int *freq)
{
	*freq = cpuspeed;
	return (0);
}

#ifndef SMALL_KERNEL
void	intelcore_update_sensor(void *args);
/*
 * Temperature read on the CPU is relative to the maximum
 * temperature supported by the CPU, Tj(Max).
 * Refer to:
 * 64-ia-32-architectures-software-developer-vol-3c-part-3-manual.pdf
 * Section 35 and
 * http://www.intel.com/content/dam/www/public/us/en/documents/
 * white-papers/cpu-monitoring-dts-peci-paper.pdf
 *
 * The temperature on Intel CPUs can be between 70 and 105 degC, since
 * Westmere we can read the TJmax from the die. For older CPUs we have
 * to guess or use undocumented MSRs. Then we subtract the temperature
 * portion of thermal status from max to get current temperature.
 */
void
intelcore_update_sensor(void *args)
{
	struct cpu_info *ci = (struct cpu_info *) args;
	u_int64_t msr;
	int max = 100;

	/* Only some Core family chips have MSR_TEMPERATURE_TARGET. */
	if (ci->ci_model == 0x0e &&
	    (rdmsr(MSR_TEMPERATURE_TARGET_UNDOCUMENTED) &
	     MSR_TEMPERATURE_TARGET_LOW_BIT_UNDOCUMENTED))
		max = 85;

	/*
	 * Newer CPUs can tell you what their max temperature is.
	 * See: '64-ia-32-architectures-software-developer-
	 * vol-3c-part-3-manual.pdf'
	 */
	if (ci->ci_model > 0x17 && ci->ci_model != 0x1c &&
	    ci->ci_model != 0x26 && ci->ci_model != 0x27 &&
	    ci->ci_model != 0x35 && ci->ci_model != 0x36)
		max = MSR_TEMPERATURE_TARGET_TJMAX(
		    rdmsr(MSR_TEMPERATURE_TARGET));

	msr = rdmsr(MSR_THERM_STATUS);
	if (msr & MSR_THERM_STATUS_VALID_BIT) {
		ci->ci_sensor.value = max - MSR_THERM_STATUS_TEMP(msr);
		/* micro degrees */
		ci->ci_sensor.value *= 1000000;
		/* kelvin */
		ci->ci_sensor.value += 273150000;
		ci->ci_sensor.flags &= ~SENSOR_FINVALID;
	} else {
		ci->ci_sensor.value = 0;
		ci->ci_sensor.flags |= SENSOR_FINVALID;
	}
}

#endif

void (*setperf_setup)(struct cpu_info *);

void via_nano_setup(struct cpu_info *ci);

void cpu_topology(struct cpu_info *ci);

void
via_nano_setup(struct cpu_info *ci)
{
	u_int32_t regs[4], val;
	u_int64_t msreg;
	int model = (ci->ci_signature >> 4) & 15;

	if (model >= 9) {
		CPUID(0xC0000000, regs[0], regs[1], regs[2], regs[3]);
		val = regs[0];
		if (val >= 0xC0000001) {
			CPUID(0xC0000001, regs[0], regs[1], regs[2], regs[3]);
			val = regs[3];
		} else
			val = 0;

		if (val & (C3_CPUID_HAS_RNG | C3_CPUID_HAS_ACE))
			printf("%s:", ci->ci_dev->dv_xname);

		/* Enable RNG if present and disabled */
		if (val & C3_CPUID_HAS_RNG) {
			extern int viac3_rnd_present;

			if (!(val & C3_CPUID_DO_RNG)) {
				msreg = rdmsr(0x110B);
				msreg |= 0x40;
				wrmsr(0x110B, msreg);
			}
			viac3_rnd_present = 1;
			printf(" RNG");
		}

		/* Enable AES engine if present and disabled */
		if (val & C3_CPUID_HAS_ACE) {
#ifdef CRYPTO
			if (!(val & C3_CPUID_DO_ACE)) {
				msreg = rdmsr(0x1107);
				msreg |= (0x01 << 28);
				wrmsr(0x1107, msreg);
			}
			amd64_has_xcrypt |= C3_HAS_AES;
#endif /* CRYPTO */
			printf(" AES");
		}

		/* Enable ACE2 engine if present and disabled */
		if (val & C3_CPUID_HAS_ACE2) {
#ifdef CRYPTO
			if (!(val & C3_CPUID_DO_ACE2)) {
				msreg = rdmsr(0x1107);
				msreg |= (0x01 << 28);
				wrmsr(0x1107, msreg);
			}
			amd64_has_xcrypt |= C3_HAS_AESCTR;
#endif /* CRYPTO */
			printf(" AES-CTR");
		}

		/* Enable SHA engine if present and disabled */
		if (val & C3_CPUID_HAS_PHE) {
#ifdef CRYPTO
			if (!(val & C3_CPUID_DO_PHE)) {
				msreg = rdmsr(0x1107);
				msreg |= (0x01 << 28/**/);
				wrmsr(0x1107, msreg);
			}
			amd64_has_xcrypt |= C3_HAS_SHA;
#endif /* CRYPTO */
			printf(" SHA1 SHA256");
		}

		/* Enable MM engine if present and disabled */
		if (val & C3_CPUID_HAS_PMM) {
#ifdef CRYPTO
			if (!(val & C3_CPUID_DO_PMM)) {
				msreg = rdmsr(0x1107);
				msreg |= (0x01 << 28/**/);
				wrmsr(0x1107, msreg);
			}
			amd64_has_xcrypt |= C3_HAS_MM;
#endif /* CRYPTO */
			printf(" RSA");
		}

		printf("\n");
	}
}

#ifndef SMALL_KERNEL
void via_update_sensor(void *args);
void
via_update_sensor(void *args)
{
	struct cpu_info *ci = (struct cpu_info *) args;
	u_int64_t msr;

	msr = rdmsr(MSR_CENT_TMTEMPERATURE);
	ci->ci_sensor.value = (msr & 0xffffff);
	/* micro degrees */
	ci->ci_sensor.value *= 1000000;
	ci->ci_sensor.value += 273150000;
	ci->ci_sensor.flags &= ~SENSOR_FINVALID;
}
#endif

u_int64_t
cpu_tsc_freq_ctr(struct cpu_info *ci)
{
	u_int64_t count, last_count, msr;

	if ((ci->ci_flags & CPUF_CONST_TSC) == 0 ||
	    (ci->ci_flags & CPUF_INVAR_TSC) ||
	    (cpu_perf_eax & CPUIDEAX_VERID) <= 1 ||
	    CPUIDEDX_NUM_FC(cpu_perf_edx) <= 1)
		return (0);

	msr = rdmsr(MSR_PERF_FIXED_CTR_CTRL);
	if (msr & MSR_PERF_FIXED_CTR_FC(1, MSR_PERF_FIXED_CTR_FC_MASK)) {
		/* some hypervisor is dicking us around */
		return (0);
	}

	msr |= MSR_PERF_FIXED_CTR_FC(1, MSR_PERF_FIXED_CTR_FC_1);
	wrmsr(MSR_PERF_FIXED_CTR_CTRL, msr);

	msr = rdmsr(MSR_PERF_GLOBAL_CTRL) | MSR_PERF_GLOBAL_CTR1_EN;
	wrmsr(MSR_PERF_GLOBAL_CTRL, msr);

	last_count = rdmsr(MSR_PERF_FIXED_CTR1);
	delay(100000);
	count = rdmsr(MSR_PERF_FIXED_CTR1);

	msr = rdmsr(MSR_PERF_FIXED_CTR_CTRL);
	msr &= MSR_PERF_FIXED_CTR_FC(1, MSR_PERF_FIXED_CTR_FC_MASK);
	wrmsr(MSR_PERF_FIXED_CTR_CTRL, msr);

	msr = rdmsr(MSR_PERF_GLOBAL_CTRL);
	msr &= ~MSR_PERF_GLOBAL_CTR1_EN;
	wrmsr(MSR_PERF_GLOBAL_CTRL, msr);

	return ((count - last_count) * 10);
}

u_int64_t
cpu_tsc_freq(struct cpu_info *ci)
{
	u_int64_t last_count, count;
	uint32_t eax, ebx, khz, dummy;

	if (!strcmp(cpu_vendor, "GenuineIntel") &&
	    cpuid_level >= 0x15) {
		eax = ebx = khz = dummy = 0;
		CPUID(0x15, eax, ebx, khz, dummy);
		khz /= 1000;
		if (khz == 0) {
			switch (ci->ci_model) {
			case 0x4e: /* Skylake mobile */
			case 0x5e: /* Skylake desktop */
			case 0x8e: /* Kabylake mobile */
			case 0x9e: /* Kabylake desktop */
				khz = 24000; /* 24.0 Mhz */
				break;
			case 0x55: /* Skylake X */
				khz = 25000; /* 25.0 Mhz */
				break;
			case 0x5c: /* Atom Goldmont */
				khz = 19200; /* 19.2 Mhz */
				break;
			}
		}
		if (ebx == 0 || eax == 0)
			count = 0;
		else if ((count = khz * ebx / eax) != 0) {
			/*
			 * Using the CPUID-derived frequency increases
			 * the quality of the TSC time counter.
			 */
			tsc_timecounter.tc_quality = 2000;
			return (count * 1000);
		}
	}

	count = cpu_tsc_freq_ctr(ci);
	if (count != 0)
		return (count);

	last_count = rdtsc();
	delay(100000);
	count = rdtsc();

	return ((count - last_count) * 10);
}

u_int
tsc_get_timecount(struct timecounter *tc)
{
	return rdtsc();
}

void
identifycpu(struct cpu_info *ci)
{
	u_int32_t dummy, val;
	char mycpu_model[48];
	int i;
	char *brandstr_from, *brandstr_to;
	int skipspace;

	CPUID(1, ci->ci_signature, val, dummy, ci->ci_feature_flags);
	CPUID(0x80000000, ci->ci_pnfeatset, dummy, dummy, dummy);
	if (ci->ci_pnfeatset >= 0x80000001) {
		CPUID(0x80000001, ci->ci_efeature_eax, dummy,
		    ci->ci_efeature_ecx, ci->ci_feature_eflags);
		/* Other bits may clash */
		ci->ci_feature_flags |= (ci->ci_feature_eflags & CPUID_NXE);
		if (ci->ci_flags & CPUF_PRIMARY)
			ecpu_ecxfeature = ci->ci_efeature_ecx;
		/* Let cpu_feature be the common bits */
		cpu_feature &= ci->ci_feature_flags;
	}

	CPUID(0x80000002, ci->ci_brand[0],
	    ci->ci_brand[1], ci->ci_brand[2], ci->ci_brand[3]);
	CPUID(0x80000003, ci->ci_brand[4],
	    ci->ci_brand[5], ci->ci_brand[6], ci->ci_brand[7]);
	CPUID(0x80000004, ci->ci_brand[8],
	    ci->ci_brand[9], ci->ci_brand[10], ci->ci_brand[11]);
	strlcpy(mycpu_model, (char *)ci->ci_brand, sizeof(mycpu_model));

	/* Remove leading, trailing and duplicated spaces from mycpu_model */
	brandstr_from = brandstr_to = mycpu_model;
	skipspace = 1;
	while (*brandstr_from != '\0') {
		if (!skipspace || *brandstr_from != ' ') {
			skipspace = 0;
			*(brandstr_to++) = *brandstr_from;
		}
		if (*brandstr_from == ' ')
			skipspace = 1;
		brandstr_from++;
	}
	if (skipspace && brandstr_to > mycpu_model)
		brandstr_to--;
	*brandstr_to = '\0';

	if (mycpu_model[0] == 0)
		strlcpy(mycpu_model, "Opteron or Athlon 64",
		    sizeof(mycpu_model));

	/* If primary cpu, fill in the global cpu_model used by sysctl */
	if (ci->ci_flags & CPUF_PRIMARY)
		strlcpy(cpu_model, mycpu_model, sizeof(cpu_model));

	ci->ci_family = (ci->ci_signature >> 8) & 0x0f;
	ci->ci_model = (ci->ci_signature >> 4) & 0x0f;
	if (ci->ci_family == 0x6 || ci->ci_family == 0xf) {
		ci->ci_family += (ci->ci_signature >> 20) & 0xff;
		ci->ci_model += ((ci->ci_signature >> 16) & 0x0f) << 4;
	}

	if (ci->ci_feature_flags && ci->ci_feature_flags & CPUID_TSC) {
		/* Has TSC, check if it's constant */
		if (!strcmp(cpu_vendor, "GenuineIntel")) {
			if ((ci->ci_family == 0x0f && ci->ci_model >= 0x03) ||
			    (ci->ci_family == 0x06 && ci->ci_model >= 0x0e)) {
				ci->ci_flags |= CPUF_CONST_TSC;
			}
		} else if (!strcmp(cpu_vendor, "CentaurHauls")) {
			/* VIA */
			if (ci->ci_model >= 0x0f) {
				ci->ci_flags |= CPUF_CONST_TSC;
			}
		} else if (!strcmp(cpu_vendor, "AuthenticAMD")) {
			if (cpu_apmi_edx & CPUIDEDX_ITSC) {
				/* Invariant TSC indicates constant TSC on
				 * AMD.
				 */
				ci->ci_flags |= CPUF_CONST_TSC;
			}
		}

		/* Check if it's an invariant TSC */
		if (cpu_apmi_edx & CPUIDEDX_ITSC)
			ci->ci_flags |= CPUF_INVAR_TSC;
	}

	ci->ci_tsc_freq = cpu_tsc_freq(ci);

	amd_cpu_cacheinfo(ci);

	printf("%s: %s", ci->ci_dev->dv_xname, mycpu_model);

	if (ci->ci_tsc_freq != 0)
		printf(", %llu.%02llu MHz", (ci->ci_tsc_freq + 4999) / 1000000,
		    ((ci->ci_tsc_freq + 4999) / 10000) % 100);

	if (ci->ci_flags & CPUF_PRIMARY) {
		cpuspeed = (ci->ci_tsc_freq + 4999) / 1000000;
		cpu_cpuspeed = cpu_amd64speed;
	}

	printf("\n%s: ", ci->ci_dev->dv_xname);

	for (i = 0; i < nitems(cpu_cpuid_features); i++)
		if (ci->ci_feature_flags & cpu_cpuid_features[i].bit)
			printf("%s%s", i? "," : "", cpu_cpuid_features[i].str);
	for (i = 0; i < nitems(cpu_cpuid_ecxfeatures); i++)
		if (cpu_ecxfeature & cpu_cpuid_ecxfeatures[i].bit)
			printf(",%s", cpu_cpuid_ecxfeatures[i].str);
	for (i = 0; i < nitems(cpu_ecpuid_features); i++)
		if (ci->ci_feature_eflags & cpu_ecpuid_features[i].bit)
			printf(",%s", cpu_ecpuid_features[i].str);
	for (i = 0; i < nitems(cpu_ecpuid_ecxfeatures); i++)
		if (ecpu_ecxfeature & cpu_ecpuid_ecxfeatures[i].bit)
			printf(",%s", cpu_ecpuid_ecxfeatures[i].str);
	for (i = 0; i < nitems(cpu_cpuid_perf_eax); i++)
		if (cpu_perf_eax & cpu_cpuid_perf_eax[i].bit)
			printf(",%s", cpu_cpuid_perf_eax[i].str);
	for (i = 0; i < nitems(cpu_cpuid_apmi_edx); i++)
		if (cpu_apmi_edx & cpu_cpuid_apmi_edx[i].bit)
			printf(",%s", cpu_cpuid_apmi_edx[i].str);

	if (cpuid_level >= 0x07) {
		/* "Structured Extended Feature Flags" */
		CPUID_LEAF(0x7, 0, dummy, ci->ci_feature_sefflags_ebx,
		    ci->ci_feature_sefflags_ecx, dummy);
		for (i = 0; i < nitems(cpu_seff0_ebxfeatures); i++)
			if (ci->ci_feature_sefflags_ebx &
			    cpu_seff0_ebxfeatures[i].bit)
				printf(",%s", cpu_seff0_ebxfeatures[i].str);
		for (i = 0; i < nitems(cpu_seff0_ecxfeatures); i++)
			if (ci->ci_feature_sefflags_ecx &
			    cpu_seff0_ecxfeatures[i].bit)
				printf(",%s", cpu_seff0_ecxfeatures[i].str);
	}

	if (!strcmp(cpu_vendor, "GenuineIntel") && cpuid_level >= 0x06) {
		CPUID(0x06, ci->ci_feature_tpmflags, dummy, dummy, dummy);
		for (i = 0; i < nitems(cpu_tpm_eaxfeatures); i++)
			if (ci->ci_feature_tpmflags &
			    cpu_tpm_eaxfeatures[i].bit)
				printf(",%s", cpu_tpm_eaxfeatures[i].str);
	} else if (!strcmp(cpu_vendor, "AuthenticAMD")) {
		if (ci->ci_family >= 0x12)
			ci->ci_feature_tpmflags |= TPM_ARAT;
	}

	printf("\n");

	x86_print_cacheinfo(ci);

	/*
	 * Attempt to disable Silicon Debug and lock the configuration
	 * if it's enabled and unlocked.
	 */
	if (!strcmp(cpu_vendor, "GenuineIntel") &&
	    (cpu_ecxfeature & CPUIDECX_SDBG)) {
		uint64_t msr;

		msr = rdmsr(IA32_DEBUG_INTERFACE);
		if ((msr & IA32_DEBUG_INTERFACE_ENABLE) &&
		    (msr & IA32_DEBUG_INTERFACE_LOCK) == 0) {
			msr &= IA32_DEBUG_INTERFACE_MASK;
			msr |= IA32_DEBUG_INTERFACE_LOCK;
			wrmsr(IA32_DEBUG_INTERFACE, msr);
		} else if (msr & IA32_DEBUG_INTERFACE_ENABLE)
			printf("%s: cannot disable silicon debug\n",
			    ci->ci_dev->dv_xname);
	}

#ifndef SMALL_KERNEL
	if (ci->ci_flags & CPUF_PRIMARY) {
		if (!strcmp(cpu_vendor, "AuthenticAMD") &&
		    ci->ci_pnfeatset >= 0x80000007) {
			CPUID(0x80000007, dummy, dummy, dummy, val);

			if (val & 0x06) {
				if ((ci->ci_signature & 0xF00) == 0xF00)
					setperf_setup = k8_powernow_init;
			}
			if (ci->ci_family >= 0x10)
				setperf_setup = k1x_init;
		}

		if (cpu_ecxfeature & CPUIDECX_EST)
			setperf_setup = est_init;

#ifdef CRYPTO
		if (cpu_ecxfeature & CPUIDECX_PCLMUL)
			amd64_has_pclmul = 1;

		if (cpu_ecxfeature & CPUIDECX_AES)
			amd64_has_aesni = 1;
#endif

		if (cpu_ecxfeature & CPUIDECX_RDRAND)
			has_rdrand = 1;

		if (ci->ci_feature_sefflags_ebx & SEFF0EBX_RDSEED)
			has_rdseed = 1;

		if (ci->ci_feature_sefflags_ebx & SEFF0EBX_SMAP)
			replacesmap();
	}
	if (!strncmp(mycpu_model, "Intel", 5)) {
		u_int32_t cflushsz;

		CPUID(0x01, dummy, cflushsz, dummy, dummy);
		/* cflush cacheline size is equal to bits 15-8 of ebx * 8 */
		ci->ci_cflushsz = ((cflushsz >> 8) & 0xff) * 8;
	}

	if (CPU_IS_PRIMARY(ci) && (ci->ci_feature_tpmflags & TPM_SENSOR)) {
		strlcpy(ci->ci_sensordev.xname, ci->ci_dev->dv_xname,
		    sizeof(ci->ci_sensordev.xname));
		ci->ci_sensor.type = SENSOR_TEMP;
		sensor_task_register(ci, intelcore_update_sensor, 5);
		sensor_attach(&ci->ci_sensordev, &ci->ci_sensor);
		sensordev_install(&ci->ci_sensordev);
	}

#endif

	if (!strcmp(cpu_vendor, "AuthenticAMD"))
		amd64_errata(ci);

	if (CPU_IS_PRIMARY(ci) && !strcmp(cpu_vendor, "CentaurHauls")) {
		ci->cpu_setup = via_nano_setup;
#ifndef SMALL_KERNEL
		strlcpy(ci->ci_sensordev.xname, ci->ci_dev->dv_xname,
		    sizeof(ci->ci_sensordev.xname));
		ci->ci_sensor.type = SENSOR_TEMP;
		sensor_task_register(ci, via_update_sensor, 5);
		sensor_attach(&ci->ci_sensordev, &ci->ci_sensor);
		sensordev_install(&ci->ci_sensordev);
#endif
	}

	if ((ci->ci_flags & CPUF_PRIMARY) &&
	    (ci->ci_flags & CPUF_CONST_TSC) &&
	    (ci->ci_flags & CPUF_INVAR_TSC)) {
		printf("%s: TSC frequency %llu Hz\n",
		    ci->ci_dev->dv_xname, ci->ci_tsc_freq);
		tsc_timecounter.tc_frequency = ci->ci_tsc_freq;
		tc_init(&tsc_timecounter);
	}

	cpu_topology(ci);
#if NVMM > 0
	cpu_check_vmm_cap(ci);
#endif /* NVMM > 0 */
}

#ifndef SMALL_KERNEL
/*
 * Base 2 logarithm of an int. returns 0 for 0 (yeye, I know).
 */
static int
log2(unsigned int i)
{
	int ret = 0;

	while (i >>= 1)
		ret++;

	return (ret);
}

static int
mask_width(u_int x)
{
	int bit;
	int mask;
	int powerof2;

	powerof2 = ((x - 1) & x) == 0;
	mask = (x << (1 - powerof2)) - 1;

	/* fls */
	if (mask == 0)
		return (0);
	for (bit = 1; mask != 1; bit++)
		mask = (unsigned int)mask >> 1;

	return (bit);
}
#endif

/*
 * Build up cpu topology for given cpu, must run on the core itself.
 */
void
cpu_topology(struct cpu_info *ci)
{
#ifndef SMALL_KERNEL
	u_int32_t eax, ebx, ecx, edx;
	u_int32_t apicid, max_apicid = 0, max_coreid = 0;
	u_int32_t smt_bits = 0, core_bits, pkg_bits = 0;
	u_int32_t smt_mask = 0, core_mask, pkg_mask = 0;

	/* We need at least apicid at CPUID 1 */
	if (cpuid_level < 1)
		goto no_topology;

	/* Initial apicid */
	CPUID(1, eax, ebx, ecx, edx);
	apicid = (ebx >> 24) & 0xff;

	if (strcmp(cpu_vendor, "AuthenticAMD") == 0) {
		/* We need at least apicid at CPUID 0x80000008 */
		if (ci->ci_pnfeatset < 0x80000008)
			goto no_topology;

		CPUID(0x80000008, eax, ebx, ecx, edx);
		core_bits = (ecx >> 12) & 0xf;
		if (core_bits == 0)
			goto no_topology;
		/* So coreidsize 2 gives 3, 3 gives 7... */
		core_mask = (1 << core_bits) - 1;
		/* Core id is the least significant considering mask */
		ci->ci_core_id = apicid & core_mask;
		/* Pkg id is the upper remaining bits */
		ci->ci_pkg_id = apicid & ~core_mask;
		ci->ci_pkg_id >>= core_bits;
	} else if (strcmp(cpu_vendor, "GenuineIntel") == 0) {
		/* We only support leaf 1/4 detection */
		if (cpuid_level < 4)
			goto no_topology;
		/* Get max_apicid */
		CPUID(1, eax, ebx, ecx, edx);
		max_apicid = (ebx >> 16) & 0xff;
		/* Get max_coreid */
		CPUID_LEAF(4, 0, eax, ebx, ecx, edx);
		max_coreid = ((eax >> 26) & 0x3f) + 1;
		/* SMT */
		smt_bits = mask_width(max_apicid / max_coreid);
		smt_mask = (1 << smt_bits) - 1;
		/* Core */
		core_bits = log2(max_coreid);
		core_mask = (1 << (core_bits + smt_bits)) - 1;
		core_mask ^= smt_mask;
		/* Pkg */
		pkg_bits = core_bits + smt_bits;
		pkg_mask = -1 << core_bits;

		ci->ci_smt_id = apicid & smt_mask;
		ci->ci_core_id = (apicid & core_mask) >> smt_bits;
		ci->ci_pkg_id = (apicid & pkg_mask) >> pkg_bits;
	} else
		goto no_topology;
#ifdef DEBUG
	printf("cpu%d: smt %u, core %u, pkg %u "
		"(apicid 0x%x, max_apicid 0x%x, max_coreid 0x%x, smt_bits 0x%x, smt_mask 0x%x, "
		"core_bits 0x%x, core_mask 0x%x, pkg_bits 0x%x, pkg_mask 0x%x)\n",
		ci->ci_cpuid, ci->ci_smt_id, ci->ci_core_id, ci->ci_pkg_id,
		apicid, max_apicid, max_coreid, smt_bits, smt_mask, core_bits,
		core_mask, pkg_bits, pkg_mask);
#else
	printf("cpu%d: smt %u, core %u, package %u\n", ci->ci_cpuid,
		ci->ci_smt_id, ci->ci_core_id, ci->ci_pkg_id);

#endif
	return;
	/* We can't map, so consider ci_core_id as ci_cpuid */
no_topology:
#endif
	ci->ci_smt_id  = 0;
	ci->ci_core_id = ci->ci_cpuid;
	ci->ci_pkg_id  = 0;
}

#if NVMM > 0
/*
 * cpu_check_vmm_cap
 *
 * Checks for VMM capabilities for 'ci'. Initializes certain per-cpu VMM
 * state in 'ci' if virtualization extensions are found.
 *
 * Parameters:
 *  ci: the cpu being checked
 */
void
cpu_check_vmm_cap(struct cpu_info *ci)
{
	uint64_t msr;
	uint32_t cap, dummy;

	/*
	 * Check for workable VMX
	 */
	if (cpu_ecxfeature & CPUIDECX_VMX) {
		msr = rdmsr(MSR_IA32_FEATURE_CONTROL);

		if (!(msr & IA32_FEATURE_CONTROL_LOCK))
			ci->ci_vmm_flags |= CI_VMM_VMX;
		else {
			if (msr & IA32_FEATURE_CONTROL_VMX_EN)
				ci->ci_vmm_flags |= CI_VMM_VMX;
			else
				ci->ci_vmm_flags |= CI_VMM_DIS;
		}
	}

	/*
	 * Check for EPT (Intel Nested Paging) and other secondary
	 * controls
	 */
	if (ci->ci_vmm_flags & CI_VMM_VMX) {
		/* Secondary controls available? */
		/* XXX should we check true procbased ctls here if avail? */
		msr = rdmsr(IA32_VMX_PROCBASED_CTLS);
		if (msr & (IA32_VMX_ACTIVATE_SECONDARY_CONTROLS) << 32) {
			msr = rdmsr(IA32_VMX_PROCBASED2_CTLS);
			/* EPT available? */
			if (msr & (IA32_VMX_ENABLE_EPT) << 32)
				ci->ci_vmm_flags |= CI_VMM_EPT;
			/* VM Functions available? */
			if (msr & (IA32_VMX_ENABLE_VM_FUNCTIONS) << 32) {
				ci->ci_vmm_cap.vcc_vmx.vmx_vm_func =
				    rdmsr(IA32_VMX_VMFUNC);	
			}
		}
	}

	/*
	 * Check startup config (VMX)
	 */
	if (ci->ci_vmm_flags & CI_VMM_VMX) {
		/* CR0 fixed and flexible bits */
		msr = rdmsr(IA32_VMX_CR0_FIXED0);
		ci->ci_vmm_cap.vcc_vmx.vmx_cr0_fixed0 = msr;
		msr = rdmsr(IA32_VMX_CR0_FIXED1);
		ci->ci_vmm_cap.vcc_vmx.vmx_cr0_fixed1 = msr;

		/* CR4 fixed and flexible bits */
		msr = rdmsr(IA32_VMX_CR4_FIXED0);
		ci->ci_vmm_cap.vcc_vmx.vmx_cr4_fixed0 = msr;
		msr = rdmsr(IA32_VMX_CR4_FIXED1);
		ci->ci_vmm_cap.vcc_vmx.vmx_cr4_fixed1 = msr;

		/* VMXON region revision ID (bits 30:0 of IA32_VMX_BASIC) */
		msr = rdmsr(IA32_VMX_BASIC);
		ci->ci_vmm_cap.vcc_vmx.vmx_vmxon_revision =
			(uint32_t)(msr & 0x7FFFFFFF);

		/* MSR save / load table size */
		msr = rdmsr(IA32_VMX_MISC);
		ci->ci_vmm_cap.vcc_vmx.vmx_msr_table_size =
			(uint32_t)(msr & IA32_VMX_MSR_LIST_SIZE_MASK) >> 25;

		/* CR3 target count size */
		ci->ci_vmm_cap.vcc_vmx.vmx_cr3_tgt_count =
			(uint32_t)(msr & IA32_VMX_CR3_TGT_SIZE_MASK) >> 16;
	}

	/*
	 * Check for workable SVM
	 */
	if (ecpu_ecxfeature & CPUIDECX_SVM) {
		msr = rdmsr(MSR_AMD_VM_CR);

		if (!(msr & AMD_SVMDIS))
			ci->ci_vmm_flags |= CI_VMM_SVM;
	}

	/*
	 * Check for SVM Nested Paging
	 */
	if ((ci->ci_vmm_flags & CI_VMM_SVM) &&
	    ci->ci_pnfeatset >= CPUID_AMD_SVM_CAP) {
		CPUID(CPUID_AMD_SVM_CAP, dummy, dummy, dummy, cap);
		if (cap & AMD_SVM_NESTED_PAGING_CAP)
			ci->ci_vmm_flags |= CI_VMM_RVI;
	}
}
#endif /* NVMM > 0 */
@


1.81
log
@Set the default TSC quality to -1000 to be less than the i8254

This makes sure that TSC is not used if we really don't want to.  The
kernel bumps the quality to 2000 for constant invariants TSCs on
latest CPUs only.

OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.80 2017/01/13 17:15:27 mikeb Exp $	*/
d118 1
@


1.80
log
@Disable and lock Silicon Debug feature on modern Intel CPUs

This implements one of the countermeasures against using Direct
Connect Interface (DCI) to debug CPUs via USB3 mentioned in the
"Tapping into the core" talk at the 33c3: identify and disable
the Silicon Debug feature found in Haswell and newer CPUs.

ok mlarkin, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.79 2016/12/14 10:30:59 reyk Exp $	*/
d63 1
a63 1
	tsc_get_timecount, NULL, ~0u, 0, "tsc", 0, NULL
@


1.79
log
@Add the TSC timecounter and use it on Skylake machines where the HPET
is too slow and the invariant TSC more accurate.

The commit includes joint work by mikeb@@ kettenis@@ and me;
tested for some time by a large group of volunteers.

OK mikeb@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.78 2016/10/13 19:36:25 martijn Exp $	*/
d634 19
@


1.78
log
@Add an extra debug line when virtualization is disabled in the firmware.
This line would have saved me about an hour of hairpulling.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.77 2016/09/30 07:33:06 mlarkin Exp $	*/
d42 1
d60 6
d395 1
d431 34
d477 6
d564 4
d701 9
@


1.77
log
@
Compute CR3 target count. Needed for upcoming debugging diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.76 2016/09/27 08:06:22 mlarkin Exp $	*/
d802 2
@


1.76
log
@
clarify a comment whose text became out of date with the previous commit
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.75 2016/09/27 08:04:49 mlarkin Exp $	*/
d851 4
@


1.75
log
@
read and cache VMFUNC capability during boot. for use in an upcoming diff
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.74 2016/09/03 12:12:43 mlarkin Exp $	*/
d806 2
a807 1
	 * Check for EPT (Intel Nested Paging)
@


1.74
log
@
add SDBG to cpuid bits and identcpu
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.73 2016/06/22 07:22:00 mlarkin Exp $	*/
d817 5
@


1.73
log
@
Identify UMIP feature, if available.

ok millert, kettenis, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.72 2016/02/03 03:25:08 guenther Exp $	*/
d126 1
@


1.72
log
@Test cpuid_level or ci->ci_pnfeatset before using a CPUID leaf; some BIOSes
can disable leaves that CPU feature flags would seem to imply.  Corrects
signal delivery on systems where the AVX leaf is disabled.

report and debugging help from Marcus MERIGHI (mcmer-openbsd (at) tor.at)
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.71 2015/12/27 04:31:34 jsg Exp $	*/
d196 1
@


1.71
log
@If available prefer the rdseed instruction over rdrand when adding entropy
to the kernel rng.  If the rdseed source is empty fallback to rdrand
as suggested by naddy.  rdrand output comes from a prng that is
periodically reseeded.  rdseed should give us more bits of entropy.

ok naddy@@ djm@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.70 2015/12/12 12:33:49 reyk Exp $	*/
d703 1
a703 2
	CPUID(0, eax, ebx, ecx, edx);
	if (eax < 1)
d712 1
a712 2
		CPUID(0x80000000, eax, ebx, ecx, edx);
		if (eax < 0x80000008)
d728 1
a728 2
		CPUID(0, eax, ebx, ecx, edx);
		if (eax < 4)
d858 2
a859 1
	if (ci->ci_vmm_flags & CI_VMM_SVM) {
@


1.70
log
@Identify hypervisors before configuring other children of the mainbus
(bios, CPU, interrupt handlers, pvbus).  This splits the pvbus attach
function into two parts: pvbus_identify() to scan the CPUID registers
for supported hypervisors and pvbus_attach() to attach the bus, print
information, and configure the children.

This will be needed for Xen and KVM, as discussed with mikeb@@ and sf@@
OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.69 2015/12/07 06:34:14 jsg Exp $	*/
d65 1
d608 3
@


1.69
log
@Add cpuid bits documented in the August 2015 revision of
"Intel Architecture Instruction Set Extensions Programming Reference"
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.68 2015/12/05 10:27:48 kettenis Exp $	*/
a606 5

#if NPVBUS > 0
		if (cpu_ecxfeature & CPUIDECX_HV)
			has_hv_cpuid = 1;
#endif
@


1.68
log
@AMD Family 12h and later processors keep their APIC clock running in deeper
C-states.  Set the TMP_ARAT flag for these (which is Intel-specific) such
that acpicpu(4) enables the deeper C-states on these CPUs.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.67 2015/11/23 22:57:12 deraadt Exp $	*/
d165 1
d174 4
d181 11
d194 1
@


1.67
log
@No longer need 'option VMM', declaring the vmm0 device is sufficient.
ok mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.66 2015/11/13 07:52:20 mlarkin Exp $	*/
d548 1
a548 1
	if (!strcmp(cpu_vendor, "GenuineIntel") && cpuid_level >= 0x06 ) {
d554 3
@


1.66
log
@
vmm(4) kernel code

circulated on hackers@@, no objections. Disabled by default.
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.65 2015/11/07 01:37:26 naddy Exp $	*/
d51 1
a51 1
#ifdef VMM
d53 1
a53 1
#endif /* VMM */
d631 1
a631 1
#ifdef VMM
d633 1
a633 1
#endif /* VMM */
d757 1
a757 1
#ifdef VMM
d848 1
a848 1
#endif /* VMM */
@


1.65
log
@Allow overriding ghash_update() with an optimized MD function.  Use
this on amd64 to provide a version that uses the PCLMUL instruction
on CPUs that support it but don't have AESNI.  ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.64 2015/08/12 05:31:41 mlarkin Exp $	*/
d42 3
d51 3
d176 3
d418 1
a418 2
	u_int32_t dummy, val, pnfeatset;
	u_int32_t brand[12];
d425 4
a428 6
	CPUID(0x80000000, pnfeatset, dummy, dummy, dummy);
	if (pnfeatset >= 0x80000001) {
		u_int32_t ecx;

		CPUID(0x80000001, dummy, dummy,
		    ecx, ci->ci_feature_eflags);
d432 1
a432 1
			ecpu_ecxfeature = ecx;
d437 7
a443 4
	CPUID(0x80000002, brand[0], brand[1], brand[2], brand[3]);
	CPUID(0x80000003, brand[4], brand[5], brand[6], brand[7]);
	CPUID(0x80000004, brand[8], brand[9], brand[10], brand[11]);
	strlcpy(mycpu_model, (char *)brand, sizeof(mycpu_model));
d536 2
a537 1
		CPUID_LEAF(0x7, 0, dummy, ci->ci_feature_sefflags, dummy, dummy);
d539 1
a539 1
			if (ci->ci_feature_sefflags &
d542 4
d563 2
a564 2
		    pnfeatset >= 0x80000007) {
			CPUID(0x80000007, dummy, dummy, dummy, pnfeatset);
d566 1
a566 1
			if (pnfeatset & 0x06) {
d593 1
a593 1
		if (ci->ci_feature_sefflags & SEFF0EBX_SMAP)
d631 3
d756 93
@


1.64
log
@Incorrect comparison when accessing cpuid extended function 0x80000007.

ok kettenis@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.63 2015/07/21 03:38:22 reyk Exp $	*/
d55 1
d564 3
@


1.63
log
@Add pvbus(4), a pseudo-bus to attach non-PCI paravirtual devices and buses.
vmt(4) is moved from mainbus0 to pvbus0, more devices will follow.

OK sf@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.62 2015/05/28 20:10:58 guenther Exp $	*/
d547 2
a548 1
		if (pnfeatset > 0x80000007) {
d552 1
a552 1
				if ((ci->ci_signature & 0xF00) == 0xf00)
@


1.62
log
@Save the cpuid(6) eax bits in the cpu_info and report the SENSOR and ARAT
bits from it.

ok krw@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.61 2015/03/14 03:38:46 jsg Exp $	*/
d59 5
d568 5
@


1.61
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.60 2015/02/08 04:41:48 deraadt Exp $	*/
d164 3
d528 8
d575 7
a581 11
	if (CPU_IS_PRIMARY(ci) && !strcmp(cpu_vendor, "GenuineIntel") &&
	    cpuid_level >= 0x06 ) {
		CPUID(0x06, val, dummy, dummy, dummy);
		if (val & 0x1) {
			strlcpy(ci->ci_sensordev.xname, ci->ci_dev->dv_xname,
			    sizeof(ci->ci_sensordev.xname));
			ci->ci_sensor.type = SENSOR_TEMP;
			sensor_task_register(ci, intelcore_update_sensor, 5);
			sensor_attach(&ci->ci_sensordev, &ci->ci_sensor);
			sensordev_install(&ci->ci_sensordev);
		}
@


1.60
log
@Only attach cpu-based sensors on the primary cpu, for two reasons
- The sensor framework cannot fetch values on the right cpu
- sensor_task_register() calls malloc, and calling it is inapproapriate
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.59 2015/02/08 03:01:29 mlarkin Exp $	*/
a40 1
#include <sys/kernel.h>
@


1.59
log
@
Typo "fature" -> "feature"
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.58 2015/01/19 16:01:43 jsg Exp $	*/
d565 2
a566 1
	if (!strcmp(cpu_vendor, "GenuineIntel") && cpuid_level >= 0x06 ) {
d583 1
a583 1
	if (!strcmp(cpu_vendor, "CentaurHauls")) {
@


1.58
log
@Make use of an msr available on recent Intel processors to obtain the
maximum supported temperature, Tj(Max).  As the temperature values are
relative to this value this should make the sensor values more accurate.

From Simon Mages.
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.57 2014/12/16 21:02:58 sf Exp $	*/
d419 1
a419 1
		/* Let cpu_fature be the common bits */
@


1.57
log
@Define and print HV cpuid flag.

This is set by many hypervisors, including kvm, vmware, hyper-v.
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.56 2014/10/17 18:15:48 kettenis Exp $	*/
d183 10
a192 6
 * Poorly documented, refer to:
 * http://softwarecommunity.intel.com/isn/Community/
 * en-US/forums/thread/30228638.aspx
 * Basically, depending on a bit in one msr, the max is either 85 or 100.
 * Then we subtract the temperature portion of thermal status from
 * max to get current temperature.
d202 3
a204 2
	if (ci->ci_model == 0xe &&
	    (rdmsr(MSR_TEMPERATURE_TARGET) & MSR_TEMPERATURE_TARGET_LOW_BIT))
d206 11
@


1.56
log
@Also remove trailing spaces from the CPU brand string.

ok deraadt@@, armani@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.55 2014/09/14 14:17:23 jsg Exp $	*/
d132 1
@


1.55
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.54 2014/07/13 12:11:01 jasper Exp $	*/
d411 1
a411 1
	/* Remove leading and duplicated spaces from mycpu_model */
d423 2
@


1.54
log
@use nitems() instead of handrolling something identical

ok mpi@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.53 2014/07/03 21:15:28 matthew Exp $	*/
a41 1
#include <sys/proc.h>
@


1.53
log
@Add identcpu detection for 1-GByte pages

ok mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.52 2013/11/19 04:12:17 guenther Exp $	*/
d388 1
a388 1
	int i, max;
d480 1
a480 2
	max = sizeof(cpu_cpuid_features) / sizeof(cpu_cpuid_features[0]);
	for (i = 0; i < max; i++)
d483 1
a483 2
	max = sizeof(cpu_cpuid_ecxfeatures) / sizeof(cpu_cpuid_ecxfeatures[0]);
	for (i = 0; i < max; i++)
d486 1
a486 2
	max = sizeof(cpu_ecpuid_features) / sizeof(cpu_ecpuid_features[0]);
	for (i = 0; i < max; i++)
d489 1
a489 2
	max = sizeof(cpu_ecpuid_ecxfeatures) / sizeof(cpu_ecpuid_ecxfeatures[0]);
	for (i = 0; i < max; i++)
d492 1
a492 2
	max = sizeof(cpu_cpuid_perf_eax) / sizeof(cpu_cpuid_perf_eax[0]);
	for (i = 0; i < max; i++)
d495 1
a495 2
	max = sizeof(cpu_cpuid_apmi_edx) / sizeof(cpu_cpuid_apmi_edx[0]);
	for (i = 0; i < max; i++)
d502 1
a502 3
		max = sizeof(cpu_seff0_ebxfeatures) /
		    sizeof(cpu_seff0_ebxfeatures[0]);
		for (i = 0; i < max; i++)
@


1.52
log
@format string fixes picked up with -Wformat=2

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.51 2013/09/26 14:38:51 jsg Exp $	*/
d95 8
a102 7
	{ CPUID_MPC,	"MPC" },
	{ CPUID_NXE,	"NXE" },
	{ CPUID_MMXX,	"MMXX" },
	{ CPUID_FFXSR,	"FFXSR" },
	{ CPUID_LONG,	"LONG" },
	{ CPUID_3DNOW2,	"3DNOW2" },
	{ CPUID_3DNOW,	"3DNOW" }
@


1.51
log
@Use the cpuid vendor string instead of the model string when enabling
VIA specific amd64 code.  Makes the code work with Eden X2 processors
which have the same model/family as a Nano but don't claim to be one
in the model string.

from bytevolcano at Safe-mail.net
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.50 2013/08/24 23:45:31 mlarkin Exp $	*/
d469 1
a469 1
		printf(", %lu.%02lu MHz", (ci->ci_tsc_freq + 4999) / 1000000,
@


1.50
log
@

fix use of uninitialized variables (used only in a DEBUG printf)

found by Maxime Villard
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.49 2013/07/30 20:42:34 kettenis Exp $	*/
d571 1
a571 1
	if (strncmp(mycpu_model, "VIA Nano processor", 18) == 0) {
@


1.49
log
@Or in the CPUID_NXE bit from ci->ci_feature_eflags into ci->ci_feature_flags
to mimic what is done in locore.S.  Otherwise we lose the CPUID_NXE bit.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.48 2013/06/04 15:29:16 haesbaert Exp $	*/
d629 3
a631 3
	u_int32_t apicid, max_apicid, max_coreid;
	u_int32_t smt_bits, core_bits, pkg_bits;
	u_int32_t smt_mask, core_mask, pkg_mask;
@


1.48
log
@Cpu topology for AMD64.

This adds information about smt id (thread), core id and package id
(socket) to amd64.

ci_smt_id, ci_core_id, ci_pkg_id should be followed by other
archictectures and core relying on them should be under
ARCH_HAVE_CPU_TOPOLOGY.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.47 2013/05/06 04:32:12 dlg Exp $	*/
d398 2
@


1.47
log
@the use of modern intel performance counter msrs to measure the number of
cycles per second isnt reliable, particularly inside "virtual" machines.
cpuspeed can be calculated as 0, which causes a divide by zero later on
which is bad.

this goes to more effort to detect if the performance counters are in use
by the hypervisor, or detecting if they gave us a cpuspeed of 0 so we can
fall through to using rdtsc.

the same change as:
src/sys/arch/i386/include/specialreg.h r.45
src/sys/arch/i386/isa/clock.c 1.49

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.46 2013/04/09 01:47:04 guenther Exp $	*/
d221 2
d580 123
@


1.46
log
@Add missing #ifdef CRYPTO around amd64_has_aesni

Diff from Silamael (Silamael (at) coronamundi.de)
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.45 2013/03/21 19:43:14 kurt Exp $	*/
d48 2
d326 53
a381 1
	u_int64_t last_count, count, msr;
d458 1
a458 24
	if ((ci->ci_flags & CPUF_CONST_TSC) &&
	    (cpu_perf_eax & CPUIDEAX_VERID) > 1 &&
	    CPUIDEDX_NUM_FC(cpu_perf_edx) > 1) {
		msr = rdmsr(MSR_PERF_FIXED_CTR_CTRL) | MSR_PERF_FIXED_CTR1_EN;
		wrmsr(MSR_PERF_FIXED_CTR_CTRL, msr);
		msr = rdmsr(MSR_PERF_GLOBAL_CTRL) | MSR_PERF_GLOBAL_CTR1_EN;
		wrmsr(MSR_PERF_GLOBAL_CTRL, msr);

		last_count = rdmsr(MSR_PERF_FIXED_CTR1);
		delay(100000);
		count = rdmsr(MSR_PERF_FIXED_CTR1);

		msr = rdmsr(MSR_PERF_FIXED_CTR_CTRL);
		msr &= ~MSR_PERF_FIXED_CTR1_EN;
		wrmsr(MSR_PERF_FIXED_CTR_CTRL, msr);
		msr = rdmsr(MSR_PERF_GLOBAL_CTRL);
		msr &= ~MSR_PERF_GLOBAL_CTR1_EN;
		wrmsr(MSR_PERF_GLOBAL_CTRL, msr);
	} else {
		last_count = rdtsc();
		delay(100000);
		count = rdtsc();
	}
	ci->ci_tsc_freq = (count - last_count) * 10;
@


1.45
log
@style(9)
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.44 2013/03/21 18:39:18 kurt Exp $	*/
d500 1
d503 1
@


1.44
log
@Detect on-die temp sensor for Atom E6xx on amd64. Adapted from
diff submitted by Matt Dainty. okay jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.43 2012/11/10 09:45:05 mglocker Exp $	*/
d521 1
a521 1
		    	sizeof(ci->ci_sensordev.xname));
@


1.43
log
@Recent x86 CPUs come with a constant time stamp counter.  If this is
the case we verify if the CPU supports a specific version of the
architectural performance monitoring feature and read out the current
frequency from the fixed-function performance counter of the unhalted
core.

My initial motivation to implement this was the Soekris net6501-70
which comes with an Intel Atom E6xx 1.60GHz CPU.  It has a constant
time stamp counter plus speed step support and boots on the lowest
frequency of 600MHz.  This caused hw.cpuspeed and hw.setperf to
reflect the wrong values.

The diff is a cooperation work with jsg@@.  The fixed-function
performance counter read code comes from a former diff of him.

OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.42 2012/10/31 03:30:22 jsg Exp $	*/
d515 3
d521 1
a521 1
			    sizeof(ci->ci_sensordev.xname));
@


1.42
log
@Add support for Intel's Supervisor Mode Access Prevention (SMAP) feature.
When enabled SMAP will generate page faults on the kernel attempting
to read/write user data pages unless an override flag is set.

Instructions that modify the flag are patched into copyin/copyout and
friends on boot if SMAP is enabled.

Those with access to hardware with SMAP can contact me for a test case.

joint work with deraadt@@

ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.41 2012/10/09 09:16:09 jsg Exp $	*/
d162 4
d327 1
a327 1
	u_int64_t last_tsc;
d382 46
a427 3
	last_tsc = rdtsc();
	delay(100000);
	ci->ci_tsc_freq = (rdtsc() - last_tsc) * 10;
d460 8
@


1.41
log
@Sync "Structured Extended Feature Flags" cpuid bits with
the August 2012 revision of
"Intel Architecture Instruction Set Extensions Programming Reference".

Correct definitions of EREP and INVPCID, rename EREP to ERMS to
match Intel's docs.  Add some more Haswell feature bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.40 2012/10/09 04:40:36 jsg Exp $	*/
d47 2
d450 3
@


1.40
log
@Enable Supervisor Mode Execution Protection (SMEP), found in recent
Intel chips.  If the kernel is tricked into running code from a user
page while in supervisor mode we'll now get a page fault and panic
instead of running it.

suggestions and ok guenther@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.39 2012/09/19 20:19:31 jsg Exp $	*/
d149 3
d153 2
a154 1
	{ SEFF0EBX_EREP,	"EREP" },
d156 4
@


1.39
log
@Add support for the rdrand instruction found in recent Intel processors.
Joint work with naddy@@

ok naddy@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.38 2012/09/07 22:02:34 naddy Exp $	*/
d406 1
a406 1
		CPUID_LEAF(0x7, 0, dummy, val, dummy, dummy);
d410 2
a411 1
			if (val & cpu_seff0_ebxfeatures[i].bit)
@


1.38
log
@bump CPU feature strings to 12 chars since some names are now 8 characters
long, leaving no space for a trailing NUL; ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.37 2012/08/24 02:49:23 guenther Exp $	*/
d55 1
d436 3
@


1.37
log
@Synchronize CR4 and CPUID portions of <machine/specialreg.h> for i386 and amd64
Add display of more feature bits: DTES64 PCID DEADLINE F16C RDRAND
Add display of "Structured Extended Feature Flags Parameters":
    FSGSBASE SMEP EREP INVPCID

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.36 2012/04/22 19:36:09 haesbaert Exp $	*/
d58 1
a58 1
	char		str[8];
@


1.36
log
@Test vendor against cpu_vendor instead of calling CPUID, this matches
the other uses.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.35 2012/03/27 02:23:04 haesbaert Exp $	*/
d77 1
a77 1
	{ CPUID_PN,	"PN" },
d88 1
a88 1
	{ CPUID_SBF,	"SBF" }
d100 1
d113 1
d120 1
d124 3
a126 1
	{ CPUIDECX_AVX,		"AVX" }
d146 5
d402 10
@


1.35
log
@Run identifycpu() on its own cpu.
Discussed with many on hackers.

"Go ahead" kettenis@@
"Get to it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.34 2012/01/08 14:39:26 haesbaert Exp $	*/
a304 1
	u_int32_t vendor[4];
d435 1
a435 5
	vendor[3] = 0;
	CPUID(0, dummy, vendor[0], vendor[2], vendor[1]);	/* yup, 0 2 1 */
	/* AuthenticAMD:    h t u A                    i t n e */
	if (vendor[0] == 0x68747541 && vendor[1] == 0x69746e65 &&
	    vendor[2] == 0x444d4163)	/* DMAc */
@


1.34
log
@Make sure we only read cpuid 0x80000001 features if pnfeatset reports it.
This is already done in i386.

ok jsg "if there is no change to the flags in your dmesg"
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.33 2011/12/26 23:07:04 haesbaert Exp $	*/
d306 1
d313 3
a315 1
	if (pnfeatset >= 0x80000001)
d317 6
a322 1
		    ecpu_ecxfeature, ci->ci_feature_eflags);
a323 2
	vendor[3] = 0;
	CPUID(0, dummy, vendor[0], vendor[2], vendor[1]);	/* yup, 0 2 1 */
d327 1
d329 2
a330 4
	strlcpy(cpu_model, (char *)brand, sizeof(cpu_model));

	/* Remove leading and duplicated spaces from cpu_model */
	brandstr_from = brandstr_to = cpu_model;
d343 7
a349 2
	if (cpu_model[0] == 0)
		strlcpy(cpu_model, "Opteron or Athlon 64", sizeof(cpu_model));
d364 1
a364 1
	printf("%s: %s", ci->ci_dev->dv_xname, cpu_model);
d369 5
a373 2
	cpuspeed = (ci->ci_tsc_freq + 4999) / 1000000;
	cpu_cpuspeed = cpu_amd64speed;
d399 11
a409 2
	if (pnfeatset > 0x80000007) {
		CPUID(0x80000007, dummy, dummy, dummy, pnfeatset);
d411 2
a412 7
		if (pnfeatset & 0x06) {
			if ((ci->ci_signature & 0xF00) == 0xf00)
				setperf_setup = k8_powernow_init;
		}
		if (ci->ci_family >= 0x10)
			setperf_setup = k1x_init;
	}
d414 2
a415 2
	if (cpu_ecxfeature & CPUIDECX_EST) {
		setperf_setup = est_init;
d417 1
a417 5

	if (cpu_ecxfeature & CPUIDECX_AES)
		amd64_has_aesni = 1;

	if (!strncmp(cpu_model, "Intel", 5)) {
d436 2
a437 1

d443 1
a443 1
	if (strncmp(cpu_model, "VIA Nano processor", 18) == 0) {
a453 7
}

void
cpu_probe_features(struct cpu_info *ci)
{
	ci->ci_feature_flags = cpu_feature;
	ci->ci_signature = 0;
@


1.33
log
@Add the missing ECX cpu flags from CPUID at 0x80000001.
This is all documented at:

http://support.amd.com/us/Embedded_TechDocs/25481.pdf (page 20)
http://www.intel.com/assets/pdf/appnote/241618.pdf (page 41)

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.32 2011/05/29 14:50:25 deraadt Exp $	*/
a311 1
	CPUID(0x80000001, dummy, dummy, dummy, ci->ci_feature_eflags);
d313 2
a314 1
		CPUID(0x80000001, dummy, dummy, ecpu_ecxfeature, dummy);
@


1.32
log
@Use k1x cpu scaling on all families 0x10 and above (the trend is likely to
continue); makes the AMD E-350 speed adjust (from slow to way slower).
discussion with jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.31 2011/05/23 09:52:24 claudio Exp $	*/
d122 19
d313 2
d376 5
@


1.31
log
@AMD K10/K11 pstate driver allows setperf and apm to change CPU
frequencies on newer AMD systems.
Driver written by Bryan Steele / brynet gmail.com
Put it in deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.30 2010/09/07 16:22:48 mikeb Exp $	*/
d367 1
a367 1
		if (ci->ci_family == 0x10 || ci->ci_family == 0x11)
@


1.30
log
@enable aesni.

that means that all users running ipsec on amd64 with 'aes'
cpu flag will have aes encryption accelerated in cbc and ctr
modes for all three key sizes: 128, 192 and 256.

for debug purposed a number of operations performed by the
driver is visible throught the pstat(8) utility:

  pstat -d u aesni_ops

note that you need to run config(8) to hook up new files.

ok kettenis thib deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.29 2010/07/01 00:24:27 thib Exp $	*/
d367 2
@


1.29
log
@Add things to enable aesni either ifdef'ed or commented out to ease
testing.

Note: aesni is not in a usable state yet!

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.28 2010/06/26 23:24:43 guenther Exp $	*/
a52 1
#ifdef notyet
a54 1
#endif
a372 1
#ifdef notyet
a374 1
#endif
@


1.28
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.27 2010/03/21 23:00:57 jsg Exp $	*/
d50 1
d52 5
d374 5
@


1.27
log
@Add some additional Intel CPUID values for recent and upcoming processors.
With some additions from sthen@@

ok kettenis@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.26 2009/12/09 21:42:10 deraadt Exp $	*/
a42 1
#include <sys/user.h>
@


1.26
log
@this does not even compile
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.25 2009/12/09 14:27:33 oga Exp $	*/
d96 1
d103 1
d105 1
d107 12
a118 1
	{ CPUIDECX_XTPR,	"xTPR" }
@


1.25
log
@Detect the cache line size for the clflush instruction when we identify
the cpu.

ok kettenis@@ as part of a larger diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.24 2009/10/07 02:15:48 kevlo Exp $	*/
d267 1
a267 1
	u_int32_t dummy, val, pnfeatset, cflushsz;
d357 2
@


1.24
log
@add support for the temperature sensor of VIA Nano and C7-M CPUs.
some improvements suggested by jsg@@

"commit" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.23 2009/09/20 21:58:31 jsg Exp $	*/
d267 1
a267 1
	u_int32_t dummy, val, pnfeatset;
d357 3
@


1.23
log
@Back out via nano temperature sensor changes.
They break ramdisks as noticed by jasper, and have not been
adequately discussed.
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.22 2009/09/20 15:37:23 kevlo Exp $	*/
d246 17
d376 1
a376 1
	if (strncmp(cpu_model, "VIA Nano processor", 18) == 0)
d378 9
@


1.22
log
@add support for VIA Nano cpu core temperature sensor

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.21 2009/07/22 20:33:12 deraadt Exp $	*/
a157 2
void via_update_sensor(void *args);

a246 14
via_update_sensor(void *args)
{
	struct cpu_info *ci = (struct cpu_info *) args;
	u_int64_t msr;

	msr = rdmsr(MSR_CENT_TMTEMPERATURE);
	ci->ci_sensor.value = (msr & 0xffffff);
	/* micro degrees */
	ci->ci_sensor.value *= 1000000;
	ci->ci_sensor.value += 273150000;
	ci->ci_sensor.flags &= ~SENSOR_FINVALID;
}

void
d359 1
a359 1
	if (strncmp(cpu_model, "VIA Nano processor", 18) == 0) {
a360 7
		strlcpy(ci->ci_sensordev.xname, ci->ci_dev->dv_xname,
		    sizeof(ci->ci_sensordev.xname));
		ci->ci_sensor.type = SENSOR_TEMP;
		sensor_task_register(ci, via_update_sensor, 5);
		sensor_attach(&ci->ci_sensordev, &ci->ci_sensor);
		sensordev_install(&ci->ci_sensordev);
	}
@


1.21
log
@via nano cpus are amd64, and so we need machdep.xcrypt
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.20 2009/06/01 03:50:57 gwk Exp $	*/
d158 2
d249 14
d375 1
a375 1
	if (strncmp(cpu_model, "VIA Nano processor", 18) == 0)
d377 7
@


1.20
log
@New VIA nano's support amd64 and EST. Move the setperf init routine outside
of the vendor check for intel and use the EST cpu feature flag to determine
if we should call the est init routine. Tested on mattieu@@'s via nano laptop.

ok deraadt@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.19 2009/05/31 03:48:05 matthieu Exp $	*/
a50 1
#ifdef CRYPTO
a51 1
#endif
@


1.19
log
@Fix RAMDISK kernels after previous. amd64_has_xcrypt needs to be
#ifdef CRYPTO. noticed by marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.18 2009/05/31 03:20:10 matthieu Exp $	*/
d166 2
a167 2
	
	if (model >= 9) { 
d175 1
a175 1
		
d178 1
a178 1
		
d182 1
a182 1
			
d191 1
a191 1
		
d204 1
a204 1
		
d217 1
a217 1
		
d230 1
a230 1
		
d243 1
a243 1
		
d337 4
d342 2
a343 5
		if (cpu_ecxfeature & CPUIDECX_EST) {
			setperf_setup = est_init;
		}
	 	CPUID(0x06, val, dummy, dummy, dummy);
	 	if (val & 0x1) {
@


1.18
log
@Add VIA crypto features support to amd64. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.17 2009/02/16 17:24:21 krw Exp $	*/
d51 1
d53 1
a165 1
	extern int amd64_has_xcrypt;
@


1.17
log
@Core i7 chips don't have MSR_TEMPERATURE_TARGET register, and blow up
if attempts are made to read it. So read MSR_TEMPERATURE_TARGET only
when ci_model == 0xe.

Found when my Core i7 box blew up. FreeBSD allows a few more chips
but this allows my box to boot.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.16 2009/02/16 15:50:05 jsg Exp $	*/
d51 1
d156 91
d358 3
@


1.16
log
@Store conditionally extended cpuid family/model values
in seperate variables in struct cpu_info instead
of duplicating the process of extracting it from the signature.

Discussed with several, 'just do it' weingart@@, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.15 2008/06/13 00:00:45 jsg Exp $	*/
d132 3
a134 1
	if (rdmsr(MSR_TEMPERATURE_TARGET) & MSR_TEMPERATURE_TARGET_LOW_BIT)
@


1.15
log
@Detect if Intel's Safer Mode Extensions (SMX) are present,
See http://download.intel.com/technology/security/downloads/31516804.pdf
for more information.

ok deraadt@@ 'looks ok to me' djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.14 2007/05/29 07:35:55 tedu Exp $	*/
d192 7
@


1.14
log
@theo says degrees is spelled degrees
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.13 2007/05/29 06:31:44 tedu Exp $	*/
d98 1
@


1.13
log
@Some improvements for better intel cpu support.
Add EST support from i386, minus the tables
Also add in support for CPU temperature sensors, based on diff to tech
by Pierre Riteau.
ok deraadt gwk
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.12 2007/05/06 03:37:08 gwk Exp $	*/
d137 1
a137 1
		/* micro degress */
@


1.12
log
@Add the mp setperf mechanism to AMD64, like its i386 counterpart it allows
all cpus in a system supporting frequency and voltage scaling to be scaled
by the same amount corresponding to the user (or apmd on their behalf)
performance level.

This diff also teaches amd64 about acpi_hasprocfvs (ACPI has processor
frequency and voltage scaling).

It also moves initilization of the underlying setperf mechanism such
as powernow to mainbus from the cpu indentification and initilization
code inspired by similar changes dim@@ made to i386 durring h2k6. This
is necessary to implement the AMD recommended method for retreiving
p_state data from the ACPI _PSS object (a diff comming soon). It will
also simplify the potential addition of enhanced speedstep as found
on newer intel processors with EMT64 capable of running OpenBSD/amd64.

MP setperf functionality verifed by myself and Johan M:son Lindman <tybolt
AT solace DOT miun DOT se> on opteron 265 and 270 systems respectively.
General testing done by many others thanks!

ok tedu, dim
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.11 2007/02/17 17:35:43 tom Exp $	*/
d112 38
d224 1
d233 18
@


1.11
log
@Add code to check for the AMD amd64 errata, and correct them where
possible.  Taken from NetBSD.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.10 2007/02/13 00:20:59 jsg Exp $	*/
d112 2
a185 1
#ifndef MULTIPROCESSOR
d187 2
a188 2
		CPUID(0x80000007, dummy, dummy, dummy, pnfeatset);	
		
d191 1
a191 1
				k8_powernow_init();
a193 1
#endif
@


1.10
log
@Check for some CPUID flags found on newer Intel processors.
ok tom@@ gwk@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.9 2006/03/16 02:55:52 dlg Exp $	*/
d118 1
d127 2
d194 5
@


1.9
log
@remove useless powernow cruft from dmesg. we're interested in the
available speed states (which is output separately), not if the cpu can
support them even if the speedstates are not provided.

from gwk, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.9 2006/03/15 23:28:14 gwk Exp $	*/
d94 9
a102 1
	{ CPUIDECX_SSE3, "SSE3" }
@


1.8
log
@Patch from Gordon Klock to update AMD PowerNow K8 support on i386,
and to add amd64 K8 support from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.7 2006/03/07 05:21:40 jsg Exp $	*/
a96 12
const struct {
	u_int32_t mask;
	const char * name;
} amd_pn_flags[] = {
	{ 0x01,		"TS"},
	{ 0x02,		"FID"},
	{ 0x04,		"VID"},
	{ 0x08,		"TTP"},
	{ 0x10,		"TM"},
	{ 0x20,		"STC"}
};

a175 6
		printf("%s: AMD Powernow:", ci->ci_dev->dv_xname);
		for (i = 0; i < 6; i++) {
			if (pnfeatset & amd_pn_flags[i].mask)
				printf(" %s", amd_pn_flags[i].name);
		}
		printf("\n");
@


1.7
log
@It does not make sense to check for IA64 CPUID flag here.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.6 2005/08/20 00:33:59 jsg Exp $	*/
d97 12
d120 1
a120 1
	u_int32_t dummy, val;
d127 1
d184 17
@


1.6
log
@Check for and report the presense of SSE3.  This has started to appear
in AMD products with the arrival of the venice core.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.5 2004/06/25 11:03:27 art Exp $	*/
a83 1
	{ CPUID_IA64,	"IA64" },
@


1.5
log
@SMP support. Big parts from NetBSD, but with some really serious debugging
done by me, niklas and others. Especially wrt. NXE support.

Still needs some polishing, especially in dmesg messages, but we're now
building kernel faster than ever.
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.4 2004/02/28 18:12:21 deraadt Exp $	*/
d94 2
d161 4
@


1.4
log
@sysctl hw.cpuspeed output
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.3 2004/02/27 21:21:44 grange Exp $	*/
a165 5

	return;	/* TODO - warning to fix this ifdef later */
#ifdef notyet
	microtime_func = cc_microtime;
#endif
@


1.3
log
@Backport from i386 andreas' diff for removing leading and
duplicated spaces from cpu brand string.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.2 2004/02/09 22:15:52 mickey Exp $	*/
d39 1
a39 1
#include <sys/types.h>
d41 4
d50 1
d96 7
d150 2
@


1.2
log
@repair cpu dmesg print a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: identcpu.c,v 1.1 2004/01/28 01:39:38 mickey Exp $	*/
d98 2
d109 15
@


1.2.2.1
log
@The merge of these files were done to another date than the rest, fix.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d47 44
d97 1
d100 1
a100 2
	CPUID(0x80000001, dummy, dummy, dummy, val);
	ci->ci_feature_flags |= val;
d121 11
a132 13

	if ((ci->ci_feature_flags & CPUID_MASK1) != 0) {
		printf("%s: features: %b\n", ci->ci_dev->dv_xname, 
		    ci->ci_feature_flags, CPUID_FLAGS1);
	}
	if ((ci->ci_feature_flags & CPUID_MASK2) != 0) {
		printf("%s: features: %b\n", ci->ci_dev->dv_xname,
		    ci->ci_feature_flags, CPUID_EXT_FLAGS2);
	}
	if ((ci->ci_feature_flags & CPUID_MASK3) != 0) {
		printf("%s: features: %b\n", ci->ci_dev->dv_xname,
		    ci->ci_feature_flags, CPUID_EXT_FLAGS3);
	}
@


1.2.2.2
log
@Merge with the trunk
@
text
@d39 1
a39 1
#include <sys/param.h>
a40 4
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/sysctl.h>
a45 52
int cpuspeed;

const struct {
	u_int32_t	bit;
	char		str[8];
} cpu_cpuid_features[] = {
	{ CPUID_FPU,	"FPU" },
	{ CPUID_VME,	"VME" },
	{ CPUID_DE,	"DE" },
	{ CPUID_PSE,	"PSE" },
	{ CPUID_TSC,	"TSC" },
	{ CPUID_MSR,	"MSR" },
	{ CPUID_PAE,	"PAE" },
	{ CPUID_MCE,	"MCE" },
	{ CPUID_CX8,	"CX8" },
	{ CPUID_APIC,	"APIC" },
	{ CPUID_SEP,	"SEP" },
	{ CPUID_MTRR,	"MTRR" },
	{ CPUID_PGE,	"PGE" },
	{ CPUID_MCA,	"MCA" },
	{ CPUID_CMOV,	"CMOV" },
	{ CPUID_PAT,	"PAT" },
	{ CPUID_PSE36,	"PSE36" },
	{ CPUID_PN,	"PN" },
	{ CPUID_CFLUSH,	"CFLUSH" },
	{ CPUID_DS,	"DS" },
	{ CPUID_ACPI,	"ACPI" },
	{ CPUID_MMX,	"MMX" },
	{ CPUID_FXSR,	"FXSR" },
	{ CPUID_SSE,	"SSE" },
	{ CPUID_SSE2,	"SSE2" },
	{ CPUID_SS,	"SS" },
	{ CPUID_HTT,	"HTT" },
	{ CPUID_TM,	"TM" },
	{ CPUID_IA64,	"IA64" },
	{ CPUID_SBF,	"SBF" }
}, cpu_ecpuid_features[] = {
	{ CPUID_MPC,	"MPC" },
	{ CPUID_NXE,	"NXE" },
	{ CPUID_MMXX,	"MMXX" },
	{ CPUID_FFXSR,	"FFXSR" },
	{ CPUID_LONG,	"LONG" },
	{ CPUID_3DNOW2,	"3DNOW2" },
	{ CPUID_3DNOW,	"3DNOW" }
};

int
cpu_amd64speed(int *freq)
{
	*freq = cpuspeed;
	return (0);
}
a52 3
	int i, max;
	char *brandstr_from, *brandstr_to;
	int skipspace;
d55 2
a56 1
	CPUID(0x80000001, dummy, dummy, dummy, ci->ci_feature_eflags);
a62 15

	/* Remove leading and duplicated spaces from cpu_model */
	brandstr_from = brandstr_to = cpu_model;
	skipspace = 1;
	while (*brandstr_from != '\0') {
		if (!skipspace || *brandstr_from != ' ') {
			skipspace = 0;
			*(brandstr_to++) = *brandstr_from;
		}
		if (*brandstr_from == ' ')
			skipspace = 1;
		brandstr_from++;
	}
	*brandstr_to = '\0';

d77 1
a77 2
	cpuspeed = (ci->ci_tsc_freq + 4999) / 1000000;
	cpu_cpuspeed = cpu_amd64speed;
d79 12
a90 11
	printf("\n%s: ", ci->ci_dev->dv_xname);

	max = sizeof(cpu_cpuid_features) / sizeof(cpu_cpuid_features[0]);
	for (i = 0; i < max; i++)
		if (ci->ci_feature_flags & cpu_cpuid_features[i].bit)
			printf("%s%s", i? "," : "", cpu_cpuid_features[i].str);
	max = sizeof(cpu_ecpuid_features) / sizeof(cpu_ecpuid_features[0]);
	for (i = 0; i < max; i++)
		if (ci->ci_feature_eflags & cpu_ecpuid_features[i].bit)
			printf(",%s", cpu_ecpuid_features[i].str);
	printf("\n");
@


1.1
log
@an amd64 arch support.
hacked by art@@ from netbsd sources and then later debugged
by me into the shape where it can host itself.
no bootloader yet as needs redoing from the
recent advanced i386 sources (anyone? ;)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d47 44
d97 1
d100 1
a100 2
	CPUID(0x80000001, dummy, dummy, dummy, val);
	ci->ci_feature_flags |= val;
d121 11
a132 13

	if ((ci->ci_feature_flags & CPUID_MASK1) != 0) {
		printf("%s: features: %b\n", ci->ci_dev->dv_xname, 
		    ci->ci_feature_flags, CPUID_FLAGS1);
	}
	if ((ci->ci_feature_flags & CPUID_MASK2) != 0) {
		printf("%s: features: %b\n", ci->ci_dev->dv_xname,
		    ci->ci_feature_flags, CPUID_EXT_FLAGS2);
	}
	if ((ci->ci_feature_flags & CPUID_MASK3) != 0) {
		printf("%s: features: %b\n", ci->ci_dev->dv_xname,
		    ci->ci_feature_flags, CPUID_EXT_FLAGS3);
	}
@

