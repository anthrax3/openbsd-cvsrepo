head	1.34;
access;
symbols
	OPENBSD_6_1:1.34.0.6
	OPENBSD_6_1_BASE:1.34
	OPENBSD_6_0:1.34.0.4
	OPENBSD_6_0_BASE:1.34
	OPENBSD_5_9:1.34.0.2
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.31.0.4
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.30.0.2
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.27.0.4
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.26.0.4
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.25.0.2
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.22.0.2
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.21.0.6
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.4
	OPENBSD_5_0:1.21.0.2
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.20.0.4
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.2
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.17.0.4
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.16.0.2
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.15.0.4
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.2
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.12.0.2
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10;
locks; strict;
comment	@ * @;


1.34
date	2015.09.12.23.03.30;	author uebayasi;	state Exp;
branches;
next	1.33;
commitid	cUFuPt9huXOiT9W5;

1.33
date	2015.09.03.03.13.56;	author yasuoka;	state Exp;
branches;
next	1.32;
commitid	dUHfqLm9bUtqA38m;

1.32
date	2015.08.30.10.05.09;	author yasuoka;	state Exp;
branches;
next	1.31;
commitid	8KYmU15QlyhusRif;

1.31
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.30;
commitid	p4LJxGKbi0BU2cG6;

1.30
date	2014.12.15.01.53.45;	author tedu;	state Exp;
branches;
next	1.29;
commitid	zTvdNqjakdDTl6z6;

1.29
date	2014.11.16.12.30.56;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	yv0ECmCdICvq576h;

1.28
date	2014.09.14.14.17.23;	author jsg;	state Exp;
branches;
next	1.27;
commitid	uzzBR7hz9ncd4O6G;

1.27
date	2014.07.13.12.11.01;	author jasper;	state Exp;
branches;
next	1.26;
commitid	XHZxhpAa5R1Ymp1z;

1.26
date	2013.11.19.04.12.17;	author guenther;	state Exp;
branches;
next	1.25;

1.25
date	2013.05.30.16.15.01;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2013.04.24.08.23.44;	author blambert;	state Exp;
branches;
next	1.23;

1.23
date	2013.03.12.16.31.50;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2012.08.10.18.50.04;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2011.04.07.15.30.13;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2010.04.20.22.05.41;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2010.03.28.12.08.49;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2009.11.23.17.57.22;	author mlarkin;	state Exp;
branches;
next	1.17;

1.17
date	2009.04.21.19.18.09;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2009.01.13.13.53.50;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2007.12.05.19.17.14;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2007.11.25.16.40.04;	author jmc;	state Exp;
branches;
next	1.13;

1.13
date	2007.11.03.05.49.17;	author ckuethe;	state Exp;
branches;
next	1.12;

1.12
date	2007.08.06.16.12.25;	author gwk;	state Exp;
branches;
next	1.11;

1.11
date	2007.03.29.15.00.15;	author gwk;	state Exp;
branches;
next	1.10;

1.10
date	2006.08.22.19.40.19;	author tom;	state Exp;
branches;
next	1.9;

1.9
date	2006.07.17.23.45.11;	author fgsch;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.19.04.49.17;	author gwk;	state Exp;
branches;
next	1.7;

1.7
date	2006.05.11.23.22.13;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.10.12.36.39;	author krw;	state Exp;
branches;
next	1.5;

1.5
date	2006.05.09.00.02.27;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2006.05.09.00.00.50;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2006.05.09.00.00.21;	author gwk;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.08.23.25.43;	author gwk;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.08.22.51.17;	author gwk;	state Exp;
branches;
next	;


desc
@@


1.34
log
@Restore SMBIOS detection in ISA.  OK yasuoka@@
@
text
@/*	$OpenBSD$	*/
/*
 * Copyright (c) 2006 Gordon Willem Klok <gklok@@cogeco.ca>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/errno.h>
#include <sys/malloc.h>

#include <uvm/uvm_extern.h>
#include <sys/sysctl.h>

#include <machine/conf.h>
#include <machine/biosvar.h>
#include <machine/mpbiosvar.h>
#include <machine/smbiosvar.h>

#include <dev/isa/isareg.h>
#include <amd64/include/isa_machdep.h>
#include <dev/pci/pcivar.h>

#include <dev/acpi/acpivar.h>

#include <dev/rndvar.h>

#include "acpi.h"
#include "mpbios.h"
#include "pci.h"

struct bios_softc {
	struct device sc_dev;
};

struct smbhdr *smbios_find(u_int8_t *);
void smbios_info(char *);
int bios_match(struct device *, void *, void *);
void bios_attach(struct device *, struct device *, void *);
int bios_print(void *, const char *);
char *fixstring(char *);

struct cfattach bios_ca = {
	sizeof(struct bios_softc), bios_match, bios_attach
};

struct cfdriver bios_cd = {
	NULL, "bios", DV_DULL
};

struct smbios_entry smbios_entry;
/*
 * used by hw_sysctl
 */
extern char *hw_vendor, *hw_prod, *hw_uuid, *hw_serial, *hw_ver;

const char *smbios_uninfo[] = {
	"System",
	"Not ",
	"To be",
	"SYS-"
};

int
bios_match(struct device *parent, void *match , void *aux)
{
	struct bios_attach_args *bia = aux;

	/* only one */
	if (bios_cd.cd_ndevs || strcmp(bia->ba_name, bios_cd.cd_name))
		return 0;
	return 1;
}

void
bios_attach(struct device *parent, struct device *self, void *aux)
{
	struct bios_softc *sc = (struct bios_softc *)self;
	struct smbios_struct_bios *sb;
	struct smbtable bios;
	char scratch[64];
	vaddr_t va;
	paddr_t pa, end;
	u_int8_t *p;
	int smbiosrev = 0;
	struct smbhdr *hdr = NULL;

	if (bios_efiinfo != NULL && bios_efiinfo->config_smbios != 0)
		hdr = smbios_find(PMAP_DIRECT_MAP(
		    (u_int8_t *)bios_efiinfo->config_smbios));

	if (hdr == NULL) {
		/* see if we have SMBIOS extentions */
		for (p = ISA_HOLE_VADDR(SMBIOS_START);
		    p < (u_int8_t *)ISA_HOLE_VADDR(SMBIOS_END); p+= 16) {
			hdr = smbios_find(p);
			if (hdr != NULL)
				break;
		}
	}

	if (hdr != NULL) {
		pa = trunc_page(hdr->addr);
		end = round_page(hdr->addr + hdr->size);
		va = uvm_km_valloc(kernel_map, end-pa);
		if (va == 0)
			goto out;

		smbios_entry.addr = (u_int8_t *)(va + (hdr->addr & PGOFSET));
		smbios_entry.len = hdr->size;
		smbios_entry.mjr = hdr->majrev;
		smbios_entry.min = hdr->minrev;
		smbios_entry.count = hdr->count;

		for (; pa < end; pa+= NBPG, va+= NBPG)
			pmap_kenter_pa(va, pa, PROT_READ);

		printf(": SMBIOS rev. %d.%d @@ 0x%x (%d entries)",
		    hdr->majrev, hdr->minrev, hdr->addr, hdr->count);

		smbiosrev = hdr->majrev * 100 + hdr->minrev;
		if (hdr->minrev < 10)
			smbiosrev = hdr->majrev * 100 + hdr->minrev * 10;

		bios.cookie = 0;
		if (smbios_find_table(SMBIOS_TYPE_BIOS, &bios)) {
			sb = bios.tblhdr;
			printf("\n%s:", sc->sc_dev.dv_xname);
			if ((smbios_get_string(&bios, sb->vendor,
			    scratch, sizeof(scratch))) != NULL)
				printf(" vendor %s",
				    fixstring(scratch));
			if ((smbios_get_string(&bios, sb->version,
			    scratch, sizeof(scratch))) != NULL)
				printf(" version \"%s\"",
				    fixstring(scratch));
			if ((smbios_get_string(&bios, sb->release,
			    scratch, sizeof(scratch))) != NULL)
				printf(" date %s", fixstring(scratch));
		}

		smbios_info(sc->sc_dev.dv_xname);
	}
out:
	printf("\n");

	/* No SMBIOS extensions, go looking for Soekris comBIOS */
	if (smbiosrev == 0) {
		const char *signature = "Soekris Engineering";

		for (p = ISA_HOLE_VADDR(SMBIOS_START);
		    p <= (u_int8_t *)ISA_HOLE_VADDR(SMBIOS_END -
		    (strlen(signature) - 1)); p++)
			if (!memcmp(p, signature, strlen(signature))) {
				hw_vendor = malloc(strlen(signature) + 1,
				    M_DEVBUF, M_NOWAIT);
				if (hw_vendor)
					strlcpy(hw_vendor, signature,
					    strlen(signature) + 1);
				p += strlen(signature);
				break;
			}

		for (; hw_vendor &&
		    p <= (u_int8_t *)ISA_HOLE_VADDR(SMBIOS_END - 6); p++)
			/*
			 * Search only for "net6501" in the comBIOS as that's
			 * the only Soekris platform that can run amd64
			 */
			if (!memcmp(p, "net6501", 7)) {
				hw_prod = malloc(8, M_DEVBUF, M_NOWAIT);
				if (hw_prod) {
					memcpy(hw_prod, p, 7);
					hw_prod[7] = '\0';
				}
				break;
			}
	}

#if NACPI > 0
	{
		struct bios_attach_args ba;

		memset(&ba, 0, sizeof(ba));
		ba.ba_name = "acpi";
		ba.ba_iot = X86_BUS_SPACE_IO;
		ba.ba_memt = X86_BUS_SPACE_MEM;

		if (bios_efiinfo != NULL)
			ba.ba_acpipbase = bios_efiinfo->config_acpi;

		config_found(self, &ba, bios_print);
	}
#endif

#if NMPBIOS > 0
	if (mpbios_probe(self)) {
		struct bios_attach_args ba;

		memset(&ba, 0, sizeof(ba));
		ba.ba_name = "mpbios";
		ba.ba_iot = X86_BUS_SPACE_IO;
		ba.ba_memt = X86_BUS_SPACE_MEM;

		config_found(self, &ba, bios_print);
	}
#endif
}

struct smbhdr *
smbios_find(u_int8_t *p)
{
	struct smbhdr * hdr = (struct smbhdr *)p;
	u_int8_t chksum;
	int i;

	if (hdr->sig != SMBIOS_SIGNATURE)
		return (NULL);
	i = hdr->len;
	for (chksum = 0; i--; chksum += p[i])
		;
	if (chksum != 0)
		return (NULL);
	p += 0x10;
	if (!(p[0] == '_' && p[1] == 'D' && p[2] == 'M' && p[3] == 'I' &&
	    p[4] == '_'))
		return (NULL);
	for (chksum = 0, i = 0xf; i--; chksum += p[i])
		;
	if (chksum != 0)
		return (NULL);

	return (hdr);
}

/*
 * smbios_find_table() takes a caller supplied smbios struct type and
 * a pointer to a handle (struct smbtable) returning one if the structure
 * is successfully located and zero otherwise. Callers should take care
 * to initialize the cookie field of the smbtable structure to zero before
 * the first invocation of this function.
 * Multiple tables of the same type can be located by repeatedly calling
 * smbios_find_table with the same arguments.
 */
int
smbios_find_table(u_int8_t type, struct smbtable *st)
{
	u_int8_t *va, *end;
	struct smbtblhdr *hdr;
	int ret = 0, tcount = 1;

	va = smbios_entry.addr;
	end = va + smbios_entry.len;

	/*
	 * The cookie field of the smtable structure is used to locate
	 * multiple instances of a table of an arbitrary type. Following the
	 * successful location of a table, the type is encoded as bits 0:7 of
	 * the cookie value, the offset in terms of the number of structures
	 * preceding that referenced by the handle is encoded in bits 15:31.
	 */
	if ((st->cookie & 0xfff) == type && st->cookie >> 16) {
		if ((u_int8_t *)st->hdr >= va && (u_int8_t *)st->hdr < end) {
			hdr = st->hdr;
			if (hdr->type == type) {
				va = (u_int8_t *)hdr + hdr->size;
				for (; va + 1 < end; va++)
					if (*va == 0 && *(va + 1) == 0)
						break;
				va+= 2;
				tcount = st->cookie >> 16;
			}
		}
	}
	for (; va + sizeof(struct smbtblhdr) < end && tcount <=
	    smbios_entry.count; tcount++) {
		hdr = (struct smbtblhdr *)va;
		if (hdr->type == type) {
			ret = 1;
			st->hdr = hdr;
			st->tblhdr = va + sizeof(struct smbtblhdr);
			st->cookie = (tcount + 1) << 16 | type;
			break;
		}
		if (hdr->type == SMBIOS_TYPE_EOT)
			break;
		va+= hdr->size;
		for (; va + 1 < end; va++)
			if (*va == 0 && *(va + 1) == 0)
				break;
		va+=2;
	}
	return ret;
}

char *
smbios_get_string(struct smbtable *st, u_int8_t indx, char *dest, size_t len)
{
	u_int8_t *va, *end;
	char *ret = NULL;
	int i;

	va = (u_int8_t *)st->hdr + st->hdr->size;
	end = smbios_entry.addr + smbios_entry.len;
	for (i = 1; va < end && i < indx && *va; i++)
		while (*va++)
			;
	if (i == indx) {
		if (va + len < end) {
			ret = dest;
			memcpy(ret, va, len);
			ret[len-1] = '\0';
		}
	}

	return ret;
}

char *
fixstring(char *s)
{
	char *p, *e;
	int i;

	for (i = 0; i < nitems(smbios_uninfo); i++)
		if ((strncasecmp(s, smbios_uninfo[i],
		    strlen(smbios_uninfo[i])))==0)
			return NULL;
	/*
	 * Remove leading and trailing whitespace
	 */
	for (p = s; *p == ' '; p++)
		;
	/*
	 * Special case entire string is whitespace
	 */
	if (p == s + strlen(s))
		return NULL;
	for (e = s + strlen(s) - 1; e > s && *e == ' '; e--)
		;
	if (p > s || e < s + strlen(s) - 1) {
		memmove(s, p, e - p + 1);
		s[e - p + 1] = '\0';
	}

	return s;
}

void
smbios_info(char * str)
{
	char *sminfop, sminfo[64];
	struct smbtable stbl, btbl;
	struct smbios_sys *sys;
	struct smbios_board *board;
	int i, infolen, uuidf, havebb;
	char *p;

	if (smbios_entry.mjr < 2)
		return;
	/*
	 * According to the spec the system table among others is required,
	 * if it is not we do not bother with this smbios implementation.
	 */
	stbl.cookie = btbl.cookie = 0;
	if (!smbios_find_table(SMBIOS_TYPE_SYSTEM, &stbl))
		return;
	havebb = smbios_find_table(SMBIOS_TYPE_BASEBOARD, &btbl);

	sys = (struct smbios_sys *)stbl.tblhdr;
	if (havebb)
		board = (struct smbios_board *)btbl.tblhdr;
	/*
	 * Some smbios implementations have no system vendor or product strings,
	 * some have very uninformative data which is harder to work around
	 * and we must rely upon various heuristics to detect this. In both
	 * cases we attempt to fall back on the base board information in the
	 * perhaps naive belief that motherboard vendors will supply this
	 * information.
	 */
	sminfop = NULL;
	if ((p = smbios_get_string(&stbl, sys->vendor, sminfo,
	    sizeof(sminfo))) != NULL)
		sminfop = fixstring(p);
	if (sminfop == NULL) {
		if (havebb) {
			if ((p = smbios_get_string(&btbl, board->vendor,
			    sminfo, sizeof(sminfo))) != NULL)
				sminfop = fixstring(p);
		}
	}
	if (sminfop) {
		infolen = strlen(sminfop) + 1;
		hw_vendor = malloc(infolen, M_DEVBUF, M_NOWAIT);
		if (hw_vendor)
			strlcpy(hw_vendor, sminfop, infolen);
		sminfop = NULL;
	}
	if ((p = smbios_get_string(&stbl, sys->product, sminfo,
	    sizeof(sminfo))) != NULL)
		sminfop = fixstring(p);
	if (sminfop == NULL) {
		if (havebb) {
			if ((p = smbios_get_string(&btbl, board->product,
			    sminfo, sizeof(sminfo))) != NULL)
				sminfop = fixstring(p);
		}
	}
	if (sminfop) {
		infolen = strlen(sminfop) + 1;
		hw_prod = malloc(infolen, M_DEVBUF, M_NOWAIT);
		if (hw_prod)
			strlcpy(hw_prod, sminfop, infolen);
		sminfop = NULL;
	}
	if (hw_vendor != NULL && hw_prod != NULL)
		printf("\n%s: %s %s", str, hw_vendor, hw_prod);
	if ((p = smbios_get_string(&stbl, sys->version, sminfo,
	    sizeof(sminfo))) != NULL)
		sminfop = fixstring(p);
	if (sminfop) {
		infolen = strlen(sminfop) + 1;
		hw_ver = malloc(infolen, M_DEVBUF, M_NOWAIT);
		if (hw_ver)
			strlcpy(hw_ver, sminfop, infolen);
		sminfop = NULL;
	}
	if ((p = smbios_get_string(&stbl, sys->serial, sminfo,
	    sizeof(sminfo))) != NULL)
		sminfop = fixstring(p);
	if (sminfop) {
		infolen = strlen(sminfop) + 1;
		for (i = 0; i < infolen - 1; i++)
			add_timer_randomness(sminfop[i]);
		hw_serial = malloc(infolen, M_DEVBUF, M_NOWAIT);
		if (hw_serial)
			strlcpy(hw_serial, sminfop, infolen);
	}
	if (smbios_entry.mjr > 2 || (smbios_entry.mjr == 2 &&
	    smbios_entry.min >= 1)) {
		/*
		 * If the uuid value is all 0xff the uuid is present but not
		 * set, if its all 0 then the uuid isn't present at all.
		 */
		uuidf = SMBIOS_UUID_NPRESENT|SMBIOS_UUID_NSET;
		for (i = 0; i < sizeof(sys->uuid); i++) {
			if (sys->uuid[i] != 0xff)
				uuidf &= ~SMBIOS_UUID_NSET;
			if (sys->uuid[i] != 0)
				uuidf &= ~SMBIOS_UUID_NPRESENT;
		}

		if (uuidf & SMBIOS_UUID_NPRESENT)
			hw_uuid = NULL;
		else if (uuidf & SMBIOS_UUID_NSET)
			hw_uuid = "Not Set";
		else {
			for (i = 0; i < sizeof(sys->uuid); i++)
				add_timer_randomness(sys->uuid[i]);
			hw_uuid = malloc(SMBIOS_UUID_REPLEN, M_DEVBUF,
			    M_NOWAIT);
			if (hw_uuid) {
				snprintf(hw_uuid, SMBIOS_UUID_REPLEN,
				    SMBIOS_UUID_REP,
				    sys->uuid[0], sys->uuid[1], sys->uuid[2],
				    sys->uuid[3], sys->uuid[4], sys->uuid[5],
				    sys->uuid[6], sys->uuid[7], sys->uuid[8],
				    sys->uuid[9], sys->uuid[10], sys->uuid[11],
				    sys->uuid[12], sys->uuid[13], sys->uuid[14],
				    sys->uuid[15]);
			}
		}
	}
}

int
bios_print(void *aux, const char *pnp)
{
        struct bios_attach_args *ba = aux;

        if (pnp)
                printf("%s at %s",
                    ba->ba_name, pnp);
        return (UNCONF);
}
@


1.33
log
@Fix the condition of finding SMBIOS.  Found by gerhard@@.

ok gerhard uebayasi deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.32 2015/08/30 10:05:09 yasuoka Exp $	*/
d110 2
a111 2
			if (hdr == NULL)
				continue;
@


1.32
log
@Modify kernel to prepare boot from UEFI.

- Add new boot arg "bios_efi_info_t" to pass the paramters from UEFI
- Make bios(4) and acpi(4) be able to probe with the parameters from
  UEFI
- Add efifb(8).  It uses the framebuffer from UEFI and it will work as
  a backend of wsdisplay(4) and wsfb (X11 video driver).  Disabled by
  the kernel config for this moment

input and ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.31 2015/03/14 03:38:46 jsg Exp $	*/
d238 2
a239 2
	if (p[0] != '_' && p[1] != 'D' && p[2] != 'M' && p[3] != 'I' &&
	    p[4] != '_')
@


1.31
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.30 2014/12/15 01:53:45 tedu Exp $	*/
d49 1
d99 1
d101 3
a103 22
	/* see if we have SMBIOS extentions */
	for (p = ISA_HOLE_VADDR(SMBIOS_START);
	    p < (u_int8_t *)ISA_HOLE_VADDR(SMBIOS_END); p+= 16) {
		struct smbhdr * hdr = (struct smbhdr *)p;
		u_int8_t chksum;
		int i;

		if (hdr->sig != SMBIOS_SIGNATURE)
			continue;
		i = hdr->len;
		for (chksum = 0; i--; chksum += p[i])
			;
		if (chksum != 0)
			continue;
		p += 0x10;
		if (p[0] != '_' && p[1] != 'D' && p[2] != 'M' &&
		    p[3] != 'I' && p[4] != '_')
			continue;
		for (chksum = 0, i = 0xf; i--; chksum += p[i])
			;
		if (chksum != 0)
			continue;
d105 11
d120 1
a120 1
			break;
a155 1
		break;
d157 1
d202 3
d221 26
@


1.30
log
@change bcopy to memcpy. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.29 2014/11/16 12:30:56 deraadt Exp $	*/
a36 1
#include <dev/acpi/acpireg.h>
@


1.29
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.28 2014/09/14 14:17:23 jsg Exp $	*/
d302 1
a302 1
			bcopy(va, ret, len);
d333 1
a333 1
		bcopy(p, s, e-p + 1);
@


1.28
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.27 2014/07/13 12:11:01 jasper Exp $	*/
d136 1
a136 1
			pmap_kenter_pa(va, pa, VM_PROT_READ);
@


1.27
log
@use nitems() instead of handrolling something identical

ok mpi@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.26 2013/11/19 04:12:17 guenther Exp $	*/
a25 1
#include <sys/proc.h>
@


1.26
log
@format string fixes picked up with -Wformat=2

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.25 2013/05/30 16:15:01 deraadt Exp $	*/
d317 1
a317 1
	for (i = 0; i < sizeof(smbios_uninfo)/sizeof(smbios_uninfo[0]); i++)
@


1.25
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.24 2013/04/24 08:23:44 blambert Exp $	*/
d139 1
a139 1
		printf(": SMBIOS rev. %d.%d @@ 0x%lx (%d entries)",
@


1.24
log
@Use the manufacturer-supplied bios serial/uuid as a source of
uniqueness to seed the random pool; although it's somewhat
hit-or-miss, as serial numbers of 123456789 (I have the same
combination on my luggage!) and lazy uuid instantiation
mean it's not as unique as we would like.

Still, on those boards where the manufacturer isn't a slacker,
it's better than nothing...

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.23 2013/03/12 16:31:50 deraadt Exp $	*/
d58 1
a58 2
	sizeof(struct bios_softc), bios_match, bios_attach, NULL,
	config_activate_children
@


1.23
log
@Fake 'SMBIOS detection' for the Soekris boxes, by Matt Dainty
This will make it easier to have device drivers for some oddities these
machines have
ok kettenis, assume jsg is ok with it too
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.22 2012/08/10 18:50:04 krw Exp $	*/
d41 2
d426 2
d451 2
@


1.22
log
@';;', even with a newline between the semicolons, doesn't make much
sense as a for() body. One semicolon is enough. From llvm via Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.21 2011/04/07 15:30:13 miod Exp $	*/
d98 1
d141 4
d166 33
@


1.21
log
@Do not use NULL in integer comparisons. No functional change.
ok matthew@@ tedu@@, also eyeballed by at least krw@@ oga@@ kettenis@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.20 2010/04/20 22:05:41 tedu Exp $	*/
d117 1
a117 1
		for (chksum = 0, i = 0xf; i--; chksum += p[i]);
@


1.20
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.19 2010/03/28 12:08:49 kettenis Exp $	*/
d221 1
a221 1
					if (*va == NULL && *(va + 1) == NULL)
d242 1
a242 1
			if (*va == NULL && *(va + 1) == NULL)
@


1.19
log
@Properly initialize variable instead of just ORing in bits into random garbage.
Shouldn't change the behaviour since only the ORed in bits are checked later,
but it makes the code clearer and should shut up the clang static analyser.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.18 2009/11/23 17:57:22 mlarkin Exp $	*/
d26 1
@


1.18
log
@

bios* devices need to call their children on suspend/resume.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.17 2009/04/21 19:18:09 kettenis Exp $	*/
d395 1
a395 1
		uuidf |= SMBIOS_UUID_NPRESENT|SMBIOS_UUID_NSET;
@


1.17
log
@Simplify PCI config space access code.  There is no way we're ever going to
see the ancient mode 2 on machines capable of running OpenBSD/amd64.

ok deraadt@@, toby@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.16 2009/01/13 13:53:50 kettenis Exp $	*/
d55 2
a56 1
	sizeof(struct bios_softc), bios_match, bios_attach
@


1.16
log
@Turn mpbios into a real device, such that people can disable it on crappy
BIOSes.

ok deraadt@@ (for the amd64 bit, or the i386 bit, can't remember which)
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.15 2007/12/05 19:17:14 deraadt Exp $	*/
a160 3
#if NPCI > 0
	if (pci_mode != 0)
#endif
@


1.15
log
@Hang acpi(4) below bios(4) instead of mainbus(4).  This lets us move acpi(4)
before pcibios(4), and then.... if acpi(4) attaches, skip pcibios(4) since
it messes the machines up.  Fixes claudio's HP dl320 G5, and almost assuredly
others.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.14 2007/11/25 16:40:04 jmc Exp $	*/
d30 1
d41 1
d169 13
@


1.14
log
@spelling fixes, from Martynas Venckus;
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.13 2007/11/03 05:49:17 ckuethe Exp $	*/
d34 7
d49 1
d79 1
a79 1
	if (bios_cd.cd_ndevs || strcmp(bia->bios_dev, bios_cd.cd_name))
d157 16
d409 11
@


1.13
log
@don't spam dmesg with huge, whitespace padded bios strings.
ok beck, gwk
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.12 2007/08/06 16:12:25 gwk Exp $	*/
d154 1
a154 1
 * is sucessfully located and zero otherwise. Callers should take care
d173 1
a173 1
	 * sucessful location of a table, the type is encoded as bits 0:7 of
@


1.12
log
@Spew smbios bios table vendor/version/release date into the dmesg. Diff
from theo.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.11 2007/03/29 15:00:15 gwk Exp $	*/
d134 2
a135 1
				printf(" vendor %s", scratch);
d138 2
a139 1
				printf(" version \"%s\"", scratch);
d142 1
a142 1
				printf(" date %s", scratch);
@


1.11
log
@Comment fixes from Daniel Dickman <didickman AT gmail DOT com>, relevant changes
for amd64 added by myself and while here nuke some whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.10 2006/08/22 19:40:19 tom Exp $	*/
d80 3
d127 16
@


1.10
log
@Same change as on i386: use a case-insensitive comparison when checking
for bogus SMBIOS strings.  Fixes identification of millert@@'s system.
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.9 2006/07/17 23:45:11 fgsch Exp $	*/
d134 1
a134 1
 * to initilize the cookie field of the smbtable structure to zero before
d136 1
a136 1
 * Multiple tables of the same type can be located by repeadtly calling
d272 1
a272 1
	 * perhaps naieve belief that motherboard vendors will supply this
d335 1
a335 1
		 * set, if its all 0 then the uuid isnt present at all.
@


1.9
log
@same changes as i386. tested by kettenis@@ and ckuethe@@. thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.8 2006/05/19 04:49:17 gwk Exp $	*/
d220 2
a221 1
		if ((strncmp(s, smbios_uninfo[i], strlen(smbios_uninfo[i])))==0)
@


1.8
log
@Smbios cleanup
Improve the heuristics a little and extend them to the version and serial
number fields. Clean the strings of leading/trailing space and deal with
strings which consist entirely of space. Use fixed buffers for strings
instead of using pointers into the table.
ok deraadt@@, and tested by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.7 2006/05/11 23:22:13 deraadt Exp $	*/
d243 1
a243 1
smbios_info(char* str)
d245 1
a245 1
	static char vend[40], prod[30], ver[30], ser[20];
d249 1
a249 1
	int i, uuidf, havebb;
d274 5
a278 4
	if ((p = smbios_get_string(&stbl, sys->vendor, vend, sizeof(vend))) !=
	    NULL)
		hw_vendor = fixstring(p);
	if (hw_vendor == NULL) {
d280 3
a282 3
			if ((p = smbios_get_string(&btbl, board->vendor, vend,
			    sizeof(vend))) != NULL)
				hw_vendor = fixstring(p);
d285 11
a295 4
	if ((p = smbios_get_string(&stbl, sys->product, prod, sizeof(prod))) !=
	    NULL)
		hw_prod = fixstring(p);
	if (hw_prod == NULL) {
d297 3
a299 3
			if ((p = smbios_get_string(&btbl, board->product, prod, 
			    sizeof(prod))) != NULL)
				hw_prod = fixstring(p);
d302 7
d311 9
a319 3
	if ((p = smbios_get_string(&stbl, sys->version, ver, sizeof(ver))) !=
	    NULL) {
		hw_ver = fixstring(p);
d321 8
a328 3
	if ((p = smbios_get_string(&stbl, sys->serial, ser, sizeof(ser))) !=
	    NULL) {
		hw_serial = fixstring(p);
@


1.7
log
@clean
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.6 2006/05/10 12:36:39 krw Exp $	*/
d42 1
d60 3
a62 1
	"Not Specified"
d191 1
a191 1
smbios_get_string(struct smbtable *st, u_int8_t indx)
d202 7
a208 2
	if (i == indx)
		ret = (char *)va;
d213 29
d243 1
a243 1
smbios_info(char * str)
d245 1
d250 1
d255 2
a256 3
	 * According to the spec the system table among others are required to
	 * be present, if it is not we dont bother with this smbios
	 * implementation.
d274 8
a281 10
	if ((hw_vendor = smbios_get_string(&stbl, sys->vendor)) != NULL) {
		for (i = 0; i < sizeof(smbios_uninfo)/sizeof(smbios_uninfo[0]);
		    i++) {
			if ((strncmp(hw_vendor, smbios_uninfo[i],
			    strlen(smbios_uninfo[i]))) == 0) {
				if (havebb)
					hw_vendor = smbios_get_string(&btbl,
				   	    board->vendor);
				break;
			}
d283 9
a291 12
	} else
		hw_vendor = smbios_get_string(&btbl, board->vendor);
	if ((hw_prod = smbios_get_string(&stbl, sys->product)) != NULL) {
		for (i = 0; i < sizeof(smbios_uninfo)/sizeof(smbios_uninfo[0]);
		    i++) {
			if ((strncmp(hw_prod, smbios_uninfo[i],
			    strlen(smbios_uninfo[i]))) == 0) {
				if (havebb)
					hw_prod = smbios_get_string(&btbl,
				   		board->product);
				break;
			}
d293 1
a293 2
	} else
		hw_prod = smbios_get_string(&btbl, board->product);
d296 8
a303 2
	hw_ver = smbios_get_string(&stbl, sys->version);
	hw_serial = smbios_get_string(&stbl, sys->serial);
@


1.6
log
@Missing $OpenBSD$ tags.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d56 2
a57 1
const char * smbios_uninfo[] = {
d157 1
a157 1
				va = (u_int8_t *) hdr + hdr->size;
d168 1
a168 1
		hdr = (struct smbtblhdr *) va;
d200 1
a200 1
		ret = (char *) va;
@


1.5
log
@more pretty
@
text
@d1 1
@


1.4
log
@more spaces
@
text
@d64 1
a67 1

d90 1
a90 1
		;
a121 1

a181 1

d235 2
a236 2
		for (i = 0; i < sizeof(smbios_uninfo) / sizeof(smbios_uninfo[0])
		    ; i++) {
d248 2
a249 2
		for (i = 0; i < sizeof(smbios_uninfo) / sizeof(smbios_uninfo[0])
		    ; i++) {
@


1.3
log
@spacing and a little KNF
@
text
@d79 1
a79 1
	/* see if we have SMBIOS extentions */	
@


1.2
log
@spacing
@
text
@d56 2
a57 2
        "System",
        "Not Specified"
d114 1
a114 1
		for(; pa < end; pa+= NBPG, va+= NBPG)
d116 1
a116 1
		
@


1.1
log
@Add smbios support for i386 and amd64, fix ipmi to use this new functionallity,
hook up some sysctls to add system vendor/product/version and UUID reporting.

"get it in" deraadt@@
@
text
@d117 1
a117 1
		printf(": SMBIOS rev. %d.%d @@ 0x%lx (%d entries)", 
d136 1
a136 1
smbios_find_table(u_int8_t type, struct smbtable *st) 
d206 1
a206 1
smbios_info(char * str) 
d228 1
a228 1
	/* 
@

