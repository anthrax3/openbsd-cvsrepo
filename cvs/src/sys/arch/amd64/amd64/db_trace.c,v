head	1.34;
access;
symbols
	OPENBSD_6_2:1.34.0.4
	OPENBSD_6_2_BASE:1.34
	OPENBSD_6_1:1.25.0.4
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.18.0.2
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.4
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.4
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.7.0.16
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.12
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.10
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.8
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.6
	OPENBSD_5_0:1.7.0.4
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.6.0.6
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.4
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.4.0.10
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.8
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.6
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.4
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.2
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.3.0.4
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.6
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.2
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.2.0.4
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	OPENBSD_3_5:1.1.0.4
	OPENBSD_3_5_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.34
date	2017.08.14.16.32.37;	author mpi;	state Exp;
branches;
next	1.33;
commitid	mLRdTRQn2m0jgtHm;

1.33
date	2017.08.11.20.50.15;	author mpi;	state Exp;
branches;
next	1.32;
commitid	wVXEBQlY9db5AjLx;

1.32
date	2017.07.05.10.48.41;	author mpi;	state Exp;
branches;
next	1.31;
commitid	soLHLAgOlfUNhOc5;

1.31
date	2017.05.30.15.39.04;	author mpi;	state Exp;
branches;
next	1.30;
commitid	PnZZkFEIj4rPydZo;

1.30
date	2017.05.29.06.14.10;	author mpi;	state Exp;
branches;
next	1.29;
commitid	kOJ4rx83W4cr7RQt;

1.29
date	2017.05.28.14.24.19;	author mpi;	state Exp;
branches;
next	1.28;
commitid	78V0YPcBVaG7RVc5;

1.28
date	2017.05.08.21.17.09;	author bluhm;	state Exp;
branches;
next	1.27;
commitid	uUURAxLW6co83Jka;

1.27
date	2017.05.08.00.13.38;	author dlg;	state Exp;
branches;
next	1.26;
commitid	TeAd99ze4UAoyHfq;

1.26
date	2017.04.20.12.41.43;	author visa;	state Exp;
branches;
next	1.25;
commitid	Ok8Q9JWEGQTbpDky;

1.25
date	2017.02.06.09.13.41;	author mpi;	state Exp;
branches;
next	1.24;
commitid	wTgEeyM3ktFNF2jh;

1.24
date	2017.01.24.00.58.55;	author mpi;	state Exp;
branches;
next	1.23;
commitid	r0ks7yUPmANG37rA;

1.23
date	2016.09.16.19.13.16;	author jasper;	state Exp;
branches;
next	1.22;
commitid	aag1XqKQQN6pS0l5;

1.22
date	2016.09.10.06.36.26;	author jasper;	state Exp;
branches;
next	1.21;
commitid	5zt7PjkXY2TQIokA;

1.21
date	2016.09.09.19.42.30;	author jasper;	state Exp;
branches;
next	1.20;
commitid	Qbet0NVZpZWm8AJv;

1.20
date	2016.09.04.09.22.28;	author mpi;	state Exp;
branches;
next	1.19;
commitid	jBolvsPoQ0BaYiLs;

1.19
date	2016.09.03.21.12.00;	author jasper;	state Exp;
branches;
next	1.18;
commitid	nZNgRlqcO7bCpUS2;

1.18
date	2016.03.03.12.44.08;	author mpi;	state Exp;
branches;
next	1.17;
commitid	C5OsdVbmpqsebKWq;

1.17
date	2016.03.03.12.40.04;	author mpi;	state Exp;
branches;
next	1.16;
commitid	wpfXiEFdj8MWXx1G;

1.16
date	2016.03.01.21.35.13;	author mpi;	state Exp;
branches;
next	1.15;
commitid	cgyWVaMY5TPuOMDK;

1.15
date	2016.03.01.21.28.24;	author mpi;	state Exp;
branches;
next	1.14;
commitid	2tGVUgQfuQ1vj5lQ;

1.14
date	2016.02.26.09.29.20;	author mpi;	state Exp;
branches;
next	1.13;
commitid	Hq6GdUGmjFfywwuz;

1.13
date	2015.06.28.01.16.28;	author guenther;	state Exp;
branches;
next	1.12;
commitid	cOmfOzJx69tehqZa;

1.12
date	2015.05.18.19.59.27;	author guenther;	state Exp;
branches;
next	1.11;
commitid	MLFvGCnCMKMdmAtY;

1.11
date	2015.03.31.04.40.47;	author guenther;	state Exp;
branches;
next	1.10;
commitid	XqnJ0ZwGPHeqs17p;

1.10
date	2015.03.22.05.41.50;	author guenther;	state Exp;
branches;
next	1.9;
commitid	y2zUVVqOpg5K0DBc;

1.9
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.8;
commitid	p4LJxGKbi0BU2cG6;

1.8
date	2014.07.13.12.11.01;	author jasper;	state Exp;
branches;
next	1.7;
commitid	XHZxhpAa5R1Ymp1z;

1.7
date	2010.09.27.10.08.28;	author mikeb;	state Exp;
branches;
next	1.6;

1.6
date	2009.06.04.22.56.13;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.04.19.42.22;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2007.01.15.23.19.05;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2005.03.31.02.53.48;	author tedu;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.02.20.45.42;	author andreas;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.28.01.39.38;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.34
log
@Do not dereference a pointer directly but use db_get_value() instead.

Prevents crashing the kernel when a fault occurs when printing a stack
trace.

ok mortimer@@, kettenis@@
@
text
@/*	$OpenBSD: db_trace.c,v 1.33 2017/08/11 20:50:15 mpi Exp $	*/
/*	$NetBSD: db_trace.c,v 1.1 2003/04/26 18:39:27 fvdl Exp $	*/

/*
 * Mach Operating System
 * Copyright (c) 1991,1990 Carnegie Mellon University
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/user.h>

#include <machine/db_machdep.h>
#include <machine/frame.h>
#include <machine/trap.h>

#include <ddb/db_sym.h>
#include <ddb/db_access.h>
#include <ddb/db_variables.h>
#include <ddb/db_output.h>

/*
 * Machine register set.
 */
struct db_variable db_regs[] = {
	{ "rdi",	(long *)&ddb_regs.tf_rdi,    FCN_NULL },
	{ "rsi",	(long *)&ddb_regs.tf_rsi,    FCN_NULL },
	{ "rbp",	(long *)&ddb_regs.tf_rbp,    FCN_NULL },
	{ "rbx",	(long *)&ddb_regs.tf_rbx,    FCN_NULL },
	{ "rdx",	(long *)&ddb_regs.tf_rdx,    FCN_NULL },
	{ "rcx",	(long *)&ddb_regs.tf_rcx,    FCN_NULL },
	{ "rax",	(long *)&ddb_regs.tf_rax,    FCN_NULL },
	{ "r8",		(long *)&ddb_regs.tf_r8,     FCN_NULL },
	{ "r9",		(long *)&ddb_regs.tf_r9,     FCN_NULL },
	{ "r10",	(long *)&ddb_regs.tf_r10,    FCN_NULL },
	{ "r11",	(long *)&ddb_regs.tf_r11,    FCN_NULL },
	{ "r12",	(long *)&ddb_regs.tf_r12,    FCN_NULL },
	{ "r13",	(long *)&ddb_regs.tf_r13,    FCN_NULL },
	{ "r14",	(long *)&ddb_regs.tf_r14,    FCN_NULL },
	{ "r15",	(long *)&ddb_regs.tf_r15,    FCN_NULL },
	{ "rip",	(long *)&ddb_regs.tf_rip,    FCN_NULL },
	{ "cs",		(long *)&ddb_regs.tf_cs,     FCN_NULL },
	{ "rflags",	(long *)&ddb_regs.tf_rflags, FCN_NULL },
	{ "rsp",	(long *)&ddb_regs.tf_rsp,    FCN_NULL },
	{ "ss",		(long *)&ddb_regs.tf_ss,     FCN_NULL },
};
struct db_variable * db_eregs = db_regs + nitems(db_regs);

/*
 * Stack trace.
 */
#define	INKERNEL(va)	(((vaddr_t)(va)) >= VM_MIN_KERNEL_ADDRESS)

#define	NONE		0
#define	TRAP		1
#define	SYSCALL		2
#define	INTERRUPT	3
#define	AST		4

int db_numargs(struct callframe *, Elf_Sym *);
void db_nextframe(struct callframe **, db_addr_t *, long *, int,
    int (*) (const char *, ...));

int
db_numargs(struct callframe *fp, Elf_Sym *sym)
{
	int args;

	if ((args = db_ctf_func_numargs(sym)) != -1)
		return args;

	return 6;
}

/*
 * Figure out the next frame up in the call stack.
 * For trap(), we print the address of the faulting instruction and
 *   proceed with the calling frame.  We return the ip that faulted.
 *   If the trap was caused by jumping through a bogus pointer, then
 *   the next line in the backtrace will list some random function as
 *   being called.  It should get the argument list correct, though.
 *   It might be possible to dig out from the next frame up the name
 *   of the function that faulted, but that could get hairy.
 */
void
db_nextframe(struct callframe **fp, db_addr_t *ip, long *argp, int is_trap,
    int (*pr)(const char *, ...))
{

	switch (is_trap) {
	    case NONE:
		*ip = (db_addr_t)
			db_get_value((db_addr_t)&(*fp)->f_retaddr, 8, FALSE);
		*fp = (struct callframe *)
			db_get_value((db_addr_t)&(*fp)->f_frame, 8, FALSE);
		break;

	    default: {
		struct trapframe *tf;

		/* The only argument to trap() or syscall() is the trapframe. */
		tf = (struct trapframe *)argp;
		switch (is_trap) {
		case TRAP:
			(*pr)("--- trap (number %d) ---\n", tf->tf_trapno);
			break;
		case AST:
			(*pr)("--- ast ---\n");
			break;
		case SYSCALL:
			(*pr)("--- syscall (number %ld) ---\n", tf->tf_rax);
			break;
		case INTERRUPT:
			(*pr)("--- interrupt ---\n");
			break;
		}
		*fp = (struct callframe *)tf->tf_rbp;
		*ip = (db_addr_t)tf->tf_rip;
		break;
	    }
	}
}

static inline int
db_is_trap(const char *name)
{
	if (name != NULL) {
		if (!strcmp(name, "trap"))
			return TRAP;
		if (!strcmp(name, "ast"))
			return AST;
		if (!strcmp(name, "syscall"))
			return SYSCALL;
		if (name[0] == 'X') {
			if (!strncmp(name, "Xintr", 5) ||
			    !strncmp(name, "Xresume", 7) ||
			    !strncmp(name, "Xrecurse", 8) ||
			    !strcmp(name, "Xdoreti") ||
			    !strncmp(name, "Xsoft", 5))
				return INTERRUPT;
		}
	}
	return NONE;
}

const unsigned long *db_reg_args[6] = {
	(unsigned long *)&ddb_regs.tf_rdi,
	(unsigned long *)&ddb_regs.tf_rsi,
	(unsigned long *)&ddb_regs.tf_rdx,
	(unsigned long *)&ddb_regs.tf_rcx,
	(unsigned long *)&ddb_regs.tf_r8,
	(unsigned long *)&ddb_regs.tf_r9,
};

void
db_stack_trace_print(db_expr_t addr, boolean_t have_addr, db_expr_t count,
    char *modif, int (*pr)(const char *, ...))
{
	struct callframe *frame, *lastframe;
	unsigned long	*argp, *arg0;
	db_addr_t	callpc;
	int		is_trap = 0;
	boolean_t	kernel_only = TRUE;
	boolean_t	trace_proc = FALSE;

	{
		char *cp = modif;
		char c;

		while ((c = *cp++) != 0) {
			if (c == 'p')
				trace_proc = TRUE;
			if (c == 'u')
				kernel_only = FALSE;
		}
	}

	if (!have_addr) {
		frame = (struct callframe *)ddb_regs.tf_rbp;
		callpc = (db_addr_t)ddb_regs.tf_rip;
	} else {
		if (trace_proc) {
			struct proc *p = tfind((pid_t)addr);
			if (p == NULL) {
				(*pr) ("not found\n");
				return;
			}
			frame = (struct callframe *)p->p_addr->u_pcb.pcb_rbp;
		} else {
			frame = (struct callframe *)addr;
		}
		callpc = (db_addr_t)
			 db_get_value((db_addr_t)&frame->f_retaddr, 8, FALSE);
		frame = (struct callframe *)frame->f_frame;
	}

	lastframe = 0;
	while (count && frame != 0) {
		int		narg;
		unsigned int	i;
		char *		name;
		db_expr_t	offset;
		Elf_Sym *	sym;

		sym = db_search_symbol(callpc, DB_STGY_ANY, &offset);
		db_symbol_values(sym, &name, NULL);

		if (lastframe == 0 && sym == NULL) {
			/* Symbol not found, peek at code */
			unsigned long instr = db_get_value(callpc, 8, FALSE);

			offset = 1;
			if ((instr & 0x00ffffff) == 0x00e58955 ||
					/* enter: pushl %ebp, movl %esp, %ebp */
			    (instr & 0x0000ffff) == 0x0000e589
					/* enter+1: movl %esp, %ebp */) {
				offset = 0;
			}
		}
		if (INKERNEL(callpc) && (is_trap = db_is_trap(name)) != NONE)
			narg = 0;
		else {
			is_trap = NONE;
			narg = db_numargs(frame, sym);
		}

		(*pr)("%s(", name);

		if (lastframe == 0 && offset == 0 && !have_addr) {
			/* We have a breakpoint before the frame is set up */
			for (i = 0; i < min(6, narg); i++) {
				(*pr)("%lx", *db_reg_args[i]);
				if (--narg != 0)
					(*pr)(",");
			}

			/* Use %rsp instead */
			arg0 =
			    &((struct callframe *)(ddb_regs.tf_rsp-8))->f_arg0;
		} else {
			argp = (unsigned long *)frame;
			for (i = min(6, narg); i > 0; i--) {
				argp--;
				(*pr)("%lx", db_get_value((db_addr_t)argp,
				    sizeof(*argp), FALSE));
				if (--narg != 0)
					(*pr)(",");
			}

			arg0 = &frame->f_arg0;
		}

		for (argp = arg0; narg > 0; ) {
			(*pr)("%lx", db_get_value((db_addr_t)argp,
			    sizeof(*argp), FALSE));
			argp++;
			if (--narg != 0)
				(*pr)(",");
		}
		(*pr)(") at ");
		db_printsym(callpc, DB_STGY_PROC, pr);
		(*pr)("\n");

		if (lastframe == 0 && offset == 0 && !have_addr && !is_trap) {
			/* Frame really belongs to next callpc */
			lastframe = (struct callframe *)(ddb_regs.tf_rsp-8);
			callpc = (db_addr_t)
				 db_get_value((db_addr_t)&lastframe->f_retaddr,
				    8, FALSE);
			continue;
		}

		if (is_trap == INTERRUPT) {
			/*
			 * Interrupt routines don't update %rbp, so it still
			 * points to the frame that was interrupted.  Pull
			 * back to just above lastframe so we can find the
			 * trapframe as with syscalls and traps.
			 */
			frame = (struct callframe *)db_get_value(
			    (db_addr_t)&lastframe->f_retaddr, sizeof(long), 0);
			arg0 = &frame->f_arg0;
		}

		lastframe = frame;
		db_nextframe(&frame, &callpc, arg0, is_trap, pr);

		if (frame == 0) {
			/* end of chain */
			break;
		}
		if (INKERNEL(frame)) {
			/* staying in kernel */
			if (frame <= lastframe) {
				(*pr)("Bad frame pointer: %p\n", frame);
				break;
			}
		} else if (INKERNEL(lastframe)) {
			/* switch from user to kernel */
			if (kernel_only) {
				(*pr)("end of kernel\n");
				break;	/* kernel stack only */
			}
		} else {
			/* in user */
			if (frame <= lastframe) {
				(*pr)("Bad user frame pointer: %p\n",
					  frame);
				break;
			}
		}
		--count;
	}
	(*pr)("end trace frame: 0x%lx, count: %d\n", frame, count);

	if (count && is_trap != NONE) {
		db_printsym(callpc, DB_STGY_XTRN, pr);
		(*pr)(":\n");
	}
}

void
db_save_stack_trace(struct db_stack_trace *st)
{
	struct callframe *frame, *lastframe;
	db_addr_t callpc;
	unsigned int i;

	frame = __builtin_frame_address(0);

	callpc = db_get_value((db_addr_t)&frame->f_retaddr, 8, FALSE);
	frame = frame->f_frame;

	lastframe = NULL;
	for (i = 0; i < DB_STACK_TRACE_MAX && frame != NULL; i++) {
		struct trapframe *tf;
		char		*name;
		db_expr_t	offset;
		Elf_Sym *	sym;
		int		is_trap;

		st->st_pc[st->st_count++] = callpc;
		sym = db_search_symbol(callpc, DB_STGY_ANY, &offset);
		db_symbol_values(sym, &name, NULL);

		if (INKERNEL(callpc))
			is_trap = db_is_trap(name);
		else
			is_trap = NONE;

		if (is_trap == NONE) {
			lastframe = frame;
			callpc = frame->f_retaddr;
			frame = frame->f_frame;
		} else {
			if (is_trap == INTERRUPT) {
				/*
				 * Interrupt routines don't update %rbp,
				 * so it still points to the frame that
				 * was interrupted.  Pull back to just
				 * above lastframe so we can find the
				 * trapframe as with syscalls and traps.
				 */
				if (lastframe == NULL)
					break;

				frame = (struct callframe *)db_get_value(
				    (db_addr_t)&lastframe->f_retaddr,
				    sizeof(long), 0);
			}
			lastframe = frame;

			tf = (struct trapframe *)&frame->f_arg0;
			callpc = (db_addr_t)tf->tf_rip;
			frame = (struct callframe *)tf->tf_rbp;
		}

		if (!INKERNEL(frame))
			break;
		if (frame <= lastframe)
			break;
	}
}

vaddr_t
db_get_pc(struct trapframe *tf)
{
	struct callframe *cf = (struct callframe *)(tf->tf_rsp - sizeof(long));

	return db_get_value((db_addr_t)&cf->f_retaddr, sizeof(long), 0);
}

vaddr_t
db_get_probe_addr(struct trapframe *tf)
{
	return tf->tf_rip - BKPT_SIZE;
}
@


1.33
log
@Merge DDBCTF into DDB.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.32 2017/07/05 10:48:41 mpi Exp $	*/
d271 1
a271 1
			
d302 2
a303 1
			frame = (struct callframe *)&lastframe->f_retaddr;
d389 3
a391 2
				frame =
				    (struct callframe *)&lastframe->f_retaddr;
@


1.32
log
@Comments are lying.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.31 2017/05/30 15:39:04 mpi Exp $	*/
a88 1
#ifdef DDBCTF
d93 1
a93 1
#endif /* DDBCTF */
@


1.31
log
@Kill db_sym_t.

ok deraadt@@, kettenis@@, jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.30 2017/05/29 06:14:10 mpi Exp $	*/
a85 8
/*
 * Lookup the function signature in the CTF section, or just
 * return 0 like before when unable to do so. In case of no CTF:
 * Figure out how many arguments were passed into the frame at "fp".
 * We can probably figure out how many arguments where passed above
 * the first 6 (which are in registers), but since we can't
 * reliably determine the values currently, just return 0.
 */
@


1.30
log
@Pass the symbol instead of its name when looking for CTF infos.

ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.29 2017/05/28 14:24:19 mpi Exp $	*/
d82 1
a82 1
int db_numargs(struct callframe *, db_sym_t);
d95 1
a95 1
db_numargs(struct callframe *fp, db_sym_t sym)
d234 1
a234 1
		db_sym_t	sym;
d369 1
a369 1
		db_sym_t	sym;
@


1.29
log
@If a function is not found in the CTF data, do not assume it takes no
argument.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.28 2017/05/08 21:17:09 bluhm Exp $	*/
a38 3
#ifdef DDBCTF
#include <ddb/db_extern.h>
#endif
d82 1
a82 1
int db_numargs(struct callframe *, const char *);
d95 1
a95 1
db_numargs(struct callframe *fp, const char *sym)
d255 1
a255 1
			narg = db_numargs(frame, name);
@


1.28
log
@After a break point at the beginning of a function, printing its
arguments faulted in ddb.  Accessing the register arguments was off
by one and in wrong order.
OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.27 2017/05/08 00:13:38 dlg Exp $	*/
d101 5
a105 2
	return db_ctf_func_numargs(sym);
#else
a106 1
#endif /* DDBCTF */
@


1.27
log
@add printing of arguments in stack traces.

this relies on building the kernel with -msave-args, which has
functions save their register arguments on the stack, so ddb can
easily find them and print them.

while here try to print arguments out of registers if we're at the
top of the stack (ie, if we set a breakpoint on a function entry).

-msave-args is only added to the compiler flags if the kernel has
been configured with ddb. this means it wont waste the space on
RAMDISK kernels because they don't include ddb.

inspired by similar functionality that has been in use on solaris
and its derivatives for well over a decade.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.26 2017/04/20 12:41:43 visa Exp $	*/
d263 1
a263 1
			for (i = min(6, narg); i > 0; i--) {
@


1.26
log
@Add routines for saving stack traces and printing saved traces
on amd64 and i386.

With guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.25 2017/02/06 09:13:41 mpi Exp $	*/
d103 1
a103 1
	return 0;
d178 9
d192 1
a192 1
	long		*argp, *arg0;
d232 2
a233 1
		char *	name;
d242 1
a242 1
			long	instr = db_get_value(callpc, 8, FALSE);
d262 8
a269 4
			/*
			 * We have a breakpoint before the frame is set up
			 * Use %rsp instead
			 */
d273 9
d286 2
a287 1
			(*pr)("%lx", db_get_value((db_addr_t)argp, 8, FALSE));
@


1.25
log
@Implement Dynamic Profiling, a ddb(4) based & gprof compatible kernel
profiling framework, for i386.

Code patching is used to enable probes when entering functions.  The
probes will call a mcount()-like function to match the behavior of a
GPROF kernel.

A new sysctl knob, ddb.profile, need to be set to 1 in securelevel 0
to be able to use this feature.

ok jasper@@, guenther@@, mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.24 2017/01/24 00:58:55 mpi Exp $	*/
d156 22
d242 1
a242 18
		if (INKERNEL(callpc) && name) {
			if (!strcmp(name, "trap")) {
				is_trap = TRAP;
			} else if (!strcmp(name, "ast")) {
				is_trap = AST;
			} else if (!strcmp(name, "syscall")) {
				is_trap = SYSCALL;
			} else if (name[0] == 'X') {
				if (!strncmp(name, "Xintr", 5) ||
				    !strncmp(name, "Xresume", 7) ||
				    !strncmp(name, "Xrecurse", 8) ||
				    !strcmp(name, "Xdoreti") ||
				    !strncmp(name, "Xsoft", 5)) {
					is_trap = INTERRUPT;
				} else
					goto normal;
			} else
				goto normal;
d244 1
a244 2
		} else {
		normal:
d326 62
@


1.24
log
@Rename pfind(9) into tfind(9) to reflect that it deals with threads.

While here document prfind(9.

with and ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.23 2016/09/16 19:13:16 jasper Exp $	*/
d328 1
a328 1
	struct callframe *cf = (struct callframe *)(tf->tf_rsp - 8);
d330 1
a330 1
	return db_get_value((db_addr_t)&cf->f_retaddr, 8, 0);
@


1.23
log
@teach ddb(4) about CTF. currently it only loads the CTF and uses it on amd64
to lookup the number of function parameters. however having this basic
facility allows us to expand it's usage.

currently hidden behind the (disabled) DDBCTF kernel option as some of the
required tools are not available in base yet. in addition to that one
also needs recent bootblocks that load the .SUNW_ctf kernel section.

discussed with mpi@@ over many a cider and ale in cambridge
feedback and ok guenther@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.22 2016/09/10 06:36:26 jasper Exp $	*/
d184 1
a184 1
			struct proc *p = pfind((pid_t)addr);
@


1.22
log
@take it one step further and bring the message inline with arm/sparc64

pointed out by guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.21 2016/09/09 19:42:30 jasper Exp $	*/
d39 3
d85 1
a85 1
int db_numargs(struct callframe *);
d90 2
d98 1
a98 1
db_numargs(struct callframe *fp)
d100 3
d104 1
d242 1
a242 1
			narg = db_numargs(frame);
@


1.21
log
@don't hardcode the filename in an error message; use the function name instead

ok jsg@@ (who spotted the powerpc straggler too) millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.20 2016/09/04 09:22:28 mpi Exp $	*/
d177 1
a177 1
				(*pr) ("%s: process not found\n", __func__);
@


1.20
log
@Introduce Dynamic Profiling, a ddb(4) based & gprof compatible kernel
profiling framework.

Code patching is used to enable probes when entering functions.  The
probes will call a mcount()-like function to match the behavior of a
GPROF kernel.

Currently only available on amd64 and guarded under DDBPROF.  Support
for other archs will follow soon.

A new sysctl knob, ddb.console, need to be set to 1 in securelevel 0
to be able to use this feature.

Inputs and ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.19 2016/09/03 21:12:00 jasper Exp $	*/
d177 1
a177 1
				(*pr) ("db_trace.c: process not found\n");
@


1.19
log
@zap eyesore whitespace at EOL
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.18 2016/03/03 12:44:08 mpi Exp $	*/
d314 14
@


1.18
log
@Unwind the trapframe correctly when a breakpoint is set on `syscall'.

Prevent a fault in DDB on amd64.

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.17 2016/03/03 12:40:04 mpi Exp $	*/
d4 1
a4 1
/* 
d8 1
a8 1
 * 
d14 1
a14 1
 * 
d18 1
a18 1
 * 
d20 1
a20 1
 * 
d25 1
a25 1
 * 
d33 1
a33 1
#include <sys/user.h> 
d98 3
a100 3
/* 
 * Figure out the next frame up in the call stack.  
 * For trap(), we print the address of the faulting instruction and 
d103 2
a104 2
 *   the next line in the backtrace will list some random function as 
 *   being called.  It should get the argument list correct, though.  
@


1.17
log
@Kill db_x86_64_regop() to unify how db_regs[] is defined between archs.

No objection from mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.16 2016/03/01 21:35:13 mpi Exp $	*/
d152 1
a152 1
	long		*argp;
d211 1
a211 1
		if (INKERNEL(frame) && name) {
d241 1
a241 1
			 * Use %esp instead
d243 2
a244 1
			argp = &((struct callframe *)(ddb_regs.tf_rsp-8))->f_arg0;
d246 1
a246 1
			argp = &frame->f_arg0;
d249 1
a249 1
		while (narg) {
d259 1
a259 1
		if (lastframe == 0 && offset == 0 && !have_addr) {
d276 1
d278 1
d280 1
a280 1
		db_nextframe(&frame, &callpc, &frame->f_arg0, is_trap, pr);
@


1.16
log
@db_sym_numargs() has always been defined to FALSE so nuke it with all
its associated dead code.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.15 2016/03/01 21:28:24 mpi Exp $	*/
a43 8
#if 1
#define dbreg(xx) (long *)offsetof(db_regs_t, tf_ ## xx)
#else
#define dbreg(xx) (long *)&ddb_regs.tf_ ## xx
#endif

static int db_x86_64_regop(struct db_variable *, db_expr_t *, int);

d48 20
a67 20
	{ "rdi",	dbreg(rdi),    db_x86_64_regop },
	{ "rsi",	dbreg(rsi),    db_x86_64_regop },
	{ "rbp",	dbreg(rbp),    db_x86_64_regop },
	{ "rbx",	dbreg(rbx),    db_x86_64_regop },
	{ "rdx",	dbreg(rdx),    db_x86_64_regop },
	{ "rcx",	dbreg(rcx),    db_x86_64_regop },
	{ "rax",	dbreg(rax),    db_x86_64_regop },
	{ "r8",		dbreg(r8),     db_x86_64_regop },
	{ "r9",		dbreg(r9),     db_x86_64_regop },
	{ "r10",	dbreg(r10),    db_x86_64_regop },
	{ "r11",	dbreg(r11),    db_x86_64_regop },
	{ "r12",	dbreg(r12),    db_x86_64_regop },
	{ "r13",	dbreg(r13),    db_x86_64_regop },
	{ "r14",	dbreg(r14),    db_x86_64_regop },
	{ "r15",	dbreg(r15),    db_x86_64_regop },
	{ "rip",	dbreg(rip),    db_x86_64_regop },
	{ "cs",		dbreg(cs),     db_x86_64_regop },
	{ "rflags",	dbreg(rflags), db_x86_64_regop },
	{ "rsp",	dbreg(rsp),    db_x86_64_regop },
	{ "ss",		dbreg(ss),     db_x86_64_regop },
a69 19

static int
db_x86_64_regop(struct db_variable *vp, db_expr_t *val, int opcode)
{
        db_expr_t *regaddr =
            (db_expr_t *)(((uint8_t *)DDB_REGS) + ((size_t)vp->valuep));
        
        switch (opcode) {
        case DB_VAR_GET:
                *val = *regaddr;
                break;
        case DB_VAR_SET:
                *regaddr = *val;
                break;
        default:
                panic("db_x86_64_regop: unknown op %d", opcode);
        }
        return 0;
}
@


1.15
log
@Kill never called db_find_trace_symbols().

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.14 2016/02/26 09:29:20 mpi Exp $	*/
a221 2
#define MAXNARG	16
		char	*argnames[MAXNARG], **argnp = NULL;
d260 1
a260 5
			narg = MAXNARG;
			if (db_sym_numargs(sym, &narg, argnames))
				argnp = argnames;
			else
				narg = db_numargs(frame);
a275 2
			if (argnp)
				(*pr)("%s=", *argnp++);
@


1.14
log
@Rename and move x86 calllframe definitions in <machine/frame.h> to use
it in MI code.

ok mlarkin@@, visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.13 2015/06/28 01:16:28 guenther Exp $	*/
a108 6
db_addr_t	db_trap_symbol_value = 0;
db_addr_t	db_syscall_symbol_value = 0;
db_addr_t	db_kdintr_symbol_value = 0;
boolean_t	db_trace_symbols_found = FALSE;

void db_find_trace_symbols(void);
a112 14
void
db_find_trace_symbols(void)
{
	db_expr_t	value;

	if (db_value_of_name("_trap", &value))
		db_trap_symbol_value = (db_addr_t) value;
	if (db_value_of_name("_kdintr", &value))
		db_kdintr_symbol_value = (db_addr_t) value;
	if (db_value_of_name("_syscall", &value))
		db_syscall_symbol_value = (db_addr_t) value;
	db_trace_symbols_found = TRUE;
}

a183 5

#if 0
	if (!db_trace_symbols_found)
		db_find_trace_symbols();
#endif
@


1.13
log
@Split AST handling from trap() into ast() and get rid of T_ASTFLT.
Don't skip the AST check when returning from *fork() in the child.
Make sure to count interrupts even when they're deferred or stray.

testing by krw@@, and then many via snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.12 2015/05/18 19:59:27 guenther Exp $	*/
a102 6
struct x86_64_frame {
	struct x86_64_frame	*f_frame;
	long			f_retaddr;
	long			f_arg0;
};

d115 2
a116 2
int db_numargs(struct x86_64_frame *);
void db_nextframe(struct x86_64_frame **, db_addr_t *, long *, int,
d140 1
a140 1
db_numargs(struct x86_64_frame *fp)
d156 1
a156 1
db_nextframe(struct x86_64_frame **fp, db_addr_t *ip, long *argp, int is_trap,
d164 1
a164 1
		*fp = (struct x86_64_frame *)
d187 1
a187 1
		*fp = (struct x86_64_frame *)tf->tf_rbp;
d198 1
a198 1
	struct x86_64_frame *frame, *lastframe;
d223 1
a223 1
		frame = (struct x86_64_frame *)ddb_regs.tf_rbp;
d232 1
a232 1
			frame = (struct x86_64_frame *)p->p_addr->u_pcb.pcb_rbp;
d234 1
a234 1
			frame = (struct x86_64_frame *)addr;
d238 1
a238 1
		frame = (struct x86_64_frame *)frame->f_frame;
d301 1
a301 1
			argp = &((struct x86_64_frame *)(ddb_regs.tf_rsp-8))->f_arg0;
d320 1
a320 1
			lastframe = (struct x86_64_frame *)(ddb_regs.tf_rsp-8);
d334 1
a334 1
			frame = (struct x86_64_frame *)&lastframe->f_retaddr;
@


1.12
log
@Do lazy update/reset of the FS.base and %[def]s segment registers: reseting
segment registers in cpu_switchto if the old thread had made it to userspace
and restoring FS.base only on first return to userspace since context switch.

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.11 2015/03/31 04:40:47 guenther Exp $	*/
d113 1
d183 3
d274 2
@


1.11
log
@Tracing across an interrupt frame was failing because the trace code thought
the interrupt frame was at the same address as the frame that was interrupted.
Correct the calculated frame pointer for the interrupt frame to have the same
offset to the struct trapframe on the stack as does syscall and trap.

ok kettenis@@ mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.10 2015/03/22 05:41:50 guenther Exp $	*/
a55 4
	{ "ds",		dbreg(ds),     db_x86_64_regop },
	{ "es",		dbreg(es),     db_x86_64_regop },
	{ "fs",		dbreg(fs),     db_x86_64_regop },
	{ "gs",		dbreg(gs),     db_x86_64_regop },
@


1.10
log
@Xstray* and Xhold* symbols vanished at some point; delete special handling
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.9 2015/03/14 03:38:46 jsg Exp $	*/
a110 1
	long			f_arg1;
d331 9
a339 4
		if (is_trap == INTERRUPT)
			argp = &lastframe->f_arg1;
		else
			argp = &frame->f_arg0;
d341 1
a341 1
		db_nextframe(&frame, &callpc, argp, is_trap, pr);
@


1.9
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.8 2014/07/13 12:11:01 jasper Exp $	*/
a279 2
				    !strncmp(name, "Xstray", 6) ||
				    !strncmp(name, "Xhold", 5) ||
@


1.8
log
@use nitems() instead of handrolling something identical

ok mpi@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.7 2010/09/27 10:08:28 mikeb Exp $	*/
a42 1
#include <ddb/db_interface.h>
@


1.7
log
@add support for tracing process stacks in ddb (trace /p).
due to the way arguments are parsed, pid has to be specified
in the hexadecimal notation.

tested by me and sthen,  ok sthen kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.6 2009/06/04 22:56:13 kettenis Exp $	*/
d82 1
a82 2
struct db_variable * db_eregs =
	db_regs + sizeof(db_regs)/sizeof(db_regs[0]);
@


1.6
log
@Make backtraces through interrupts work.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.5 2009/06/04 19:42:22 kettenis Exp $	*/
d212 1
a212 1
	boolean_t	trace_thread = FALSE;
d224 2
a225 2
			if (c == 't')
				trace_thread = TRUE;
d235 2
a236 7
#if 0
		if (trace_thread) {
			struct proc *p;
			struct user *u;
			struct lwp *l;
			(*pr)("trace: pid %d ", (int)addr);
			p = pfind(addr);
d238 1
a238 6
				(*pr)("not found\n");
				return;
			}
			l = proc_representative_lwp(p);
			if (!(l->l_flag&L_INMEM)) {
				(*pr)("swapped out\n");
d241 2
a242 5
			u = l->l_addr;
			frame = (struct x86_64_frame *) u->u_pcb.pcb_rbp;
			(*pr)("at %p\n", frame);
		} else
#endif
d244 1
@


1.5
log
@Remove support for non-ELF; it never existed for amd64.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.4 2007/01/15 23:19:05 jsg Exp $	*/
d113 1
d348 4
d353 1
a353 1
		db_nextframe(&frame, &callpc, &frame->f_arg0, is_trap, pr);
@


1.4
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.3 2005/03/31 02:53:48 tedu Exp $	*/
a285 1
#ifdef __ELF__
a303 20
#else
			if (!strcmp(name, "_trap")) {
				is_trap = TRAP;
			} else if (!strcmp(name, "_syscall")) {
				is_trap = SYSCALL;
			} else if (name[0] == '_' && name[1] == 'X') {
				if (!strncmp(name, "_Xintr", 6) ||
				    !strncmp(name, "_Xresume", 8) ||
				    !strncmp(name, "_Xstray", 7) ||
				    !strncmp(name, "_Xhold", 6) ||
				    !strncmp(name, "_Xrecurse", 9) ||
				    !strcmp(name, "_Xdoreti") ||
				    !strncmp(name, "_Xsoft", 6)) {
					is_trap = INTERRUPT;
				} else
					goto normal;
			} else
				goto normal;
			narg = 0;
#endif /* __ELF__ */
@


1.3
log
@go back to the old trace code, but add -fno-omit-frame-pointer so it works.
makes trace output more reasonable.  ok andreas
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.1 2004/01/28 01:39:38 mickey Exp $	*/
d131 1
a131 1
db_find_trace_symbols()
d151 1
a151 2
db_numargs(fp)
	struct x86_64_frame *fp;
d167 2
a168 6
db_nextframe(fp, ip, argp, is_trap, pr)
	struct x86_64_frame **fp;		/* in/out */
	db_addr_t	*ip;		/* out */
	long *argp;			/* in */
	int is_trap;			/* in */
	int (*pr)(const char *, ...); /* in */
d203 2
a204 6
db_stack_trace_print(addr, have_addr, count, modif, pr)
	db_expr_t	addr;
	boolean_t	have_addr;
	db_expr_t	count;
	char		*modif;
	int		(*pr)(const char *, ...);
d219 2
a220 2
		register char *cp = modif;
		register char c;
@


1.2
log
@Heuristic approach to 'trace' in ddb which works without frame pointers.
Not perfect yet but better than nothing.
art@@ ok
@
text
@d1 2
a2 1
/*	$OpenBSD$	*/
d4 24
a27 14
/*
 * Copyright (c) 2004 Andreas Gunnarsson <andreas@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d30 5
d36 3
d41 2
d45 5
a49 2
extern char end[];
extern unsigned int db_maxoff;
d51 1
a51 2
db_addr_t db_findcaller(db_addr_t, db_addr_t, char **name, db_expr_t *);
int db_endtrace(db_addr_t);
d53 34
a86 2
db_addr_t
db_findcaller(db_addr_t sp, db_addr_t ip, char **name, db_expr_t *offset)
d88 15
a102 25
	db_addr_t previp;
	db_addr_t called_addr = 0;
	db_expr_t value;
	db_sym_t sym;
	unsigned char callinstr;
	int calloffs;
	short scalloffs;

	if (*(char **)sp < (char *)VM_MIN_KERNEL_ADDRESS || *(char **)sp >= end)
		return 0;

	sym = db_search_symbol((db_addr_t)*(char **)sp, DB_STGY_PROC, offset);
	db_symbol_values(sym, name, &value);
	if (!*name || *offset > db_maxoff || !value)
		return 0;

	/* Check for call with 32 bit relative displacement */
	/* e8 xx xx xx xx */
	previp = (db_addr_t)*(char **)sp - 5;
	callinstr = db_get_value(previp, 1, 0);
	if (callinstr == 0xe8) {
		calloffs = db_get_value(previp + 1, 4, 1);
		called_addr = previp + 5 + calloffs;
		goto found;
	}
d104 4
a107 12
	/* Check for call with 16 bit relative displacement */
	/* 66 e8 xx xx */
	previp = (db_addr_t)*(char **)sp - 4;
	callinstr = db_get_value(previp, 1, 0);
	if (callinstr == 0x66) {
		callinstr = db_get_value(previp + 1, 1, 0);
		if (callinstr == 0xe8) {
			scalloffs = db_get_value(previp + 2, 2, 1);
			called_addr = previp + 4 + scalloffs;
			goto found;
		}
	}
d109 20
a128 10
	/* Check for call with reg/mem */
	previp = (db_addr_t)*(char **)sp - 2;
	callinstr = db_get_value(previp, 1, 0);
	if (callinstr == 0xff) {
		callinstr = db_get_value(previp + 1, 1, 0);
		if (((callinstr & 0xf8) == 0x10 || (callinstr & 0xf8) == 0xd0) &&
		    callinstr != 0x15) {
			goto found;
		}
	}
d130 4
a133 8
	previp = (db_addr_t)*(char **)sp - 3;
	callinstr = db_get_value(previp, 1, 0);
	if (callinstr == 0xff) {
		callinstr = db_get_value(previp + 1, 1, 0);
		if ((callinstr & 0xf8) == 0x50) {
			goto found;
		}
	}
d135 8
a142 8
	previp = (db_addr_t)*(char **)sp - 6;
	callinstr = db_get_value(previp, 1, 0);
	if (callinstr == 0xff) {
		callinstr = db_get_value(previp + 1, 1, 0);
		if (callinstr == 0x15 || (callinstr & 0xf8) == 0x90) {
			goto found;
		}
	}
d144 10
a153 1
	/* Value on stack doesn't seem to be a return address */
a154 12

found:
	if (called_addr) {
		sym = db_search_symbol(called_addr, DB_STGY_PROC, offset);
	} else {
		sym = db_search_symbol(ip, DB_STGY_PROC, offset);
		*offset = 0;
	}
	db_symbol_values(sym, name, &value);
	if (!*name || *offset > db_maxoff || !value)
		return 0;
	return previp;
d157 17
a173 2
int
db_endtrace(db_addr_t ip)
d175 29
a203 18
	db_expr_t offset, value;
	db_sym_t sym;
	char *name;

	sym = db_search_symbol(ip, DB_STGY_PROC, &offset);
	db_symbol_values(sym, &name, &value);
	if (!name || offset > db_maxoff || !value)
		return 1;
	if (!strcmp(name, "trap") ||
	    !strcmp(name, "syscall") ||
	    !strncmp(name, "Xintr", 5) ||
	    !strncmp(name, "Xresume", 7) ||
	    !strncmp(name, "Xstray", 6) ||
	    !strncmp(name, "Xhold", 5) ||
	    !strncmp(name, "Xrecurse", 8) ||
	    !strcmp(name, "Xdoreti") ||
	    !strncmp(name, "Xsoft", 5)) {
		return 1;
a204 1
	return 0;
d208 6
a213 2
db_stack_trace_print(db_expr_t addr, boolean_t have_addr, db_expr_t count,
    char *modif, int (*pr)(const char *, ...))
d215 128
a342 4
	db_addr_t ip, previp, sp;
	db_expr_t offset, value;
	db_sym_t sym;
	char *name;
d344 11
a354 1
	ip = ddb_regs.tf_rip;
d356 18
a373 11
	for (sp = ddb_regs.tf_rsp; !db_endtrace(ip); sp += 4) {
		if (*(char **)sp >= end)
			continue;
		previp = db_findcaller(sp, ip, &name, &offset);
		if (!previp || !name)
			continue;
		if (offset) {
			pr("[%s+%p", name, offset);
			pr(" called from ");
			db_printsym(previp, DB_STGY_PROC, pr);
			pr("]");
d376 35
a410 5
		pr("%s() at ", name);
		/* pr("%s(%%rsp=%p) at ", name, sp); */
		db_printsym(ip, DB_STGY_PROC, pr);
		pr("\n");
		ip = previp;
a411 6
	sym = db_search_symbol(ip, DB_STGY_PROC, &offset);
	db_symbol_values(sym, &name, &value);
	if (name)
		pr("%s() at ", name);
	db_printsym(ip, DB_STGY_PROC, pr);
	pr("\n");
@


1.1
log
@an amd64 arch support.
hacked by art@@ from netbsd sources and then later debugged
by me into the shape where it can host itself.
no bootloader yet as needs redoing from the
recent advanced i386 sources (anyone? ;)
@
text
@a1 1
/*	$NetBSD: db_trace.c,v 1.1 2003/04/26 18:39:27 fvdl Exp $	*/
d3 14
a16 24
/* 
 * Mach Operating System
 * Copyright (c) 1991,1990 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
a18 5
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/user.h> 

a19 3
#include <machine/frame.h>
#include <machine/trap.h>

a21 2
#include <ddb/db_variables.h>
#include <ddb/db_output.h>
d24 2
a25 5
#if 1
#define dbreg(xx) (long *)offsetof(db_regs_t, tf_ ## xx)
#else
#define dbreg(xx) (long *)&ddb_regs.tf_ ## xx
#endif
d27 2
a28 1
static int db_x86_64_regop(struct db_variable *, db_expr_t *, int);
d30 2
a31 34
/*
 * Machine register set.
 */
struct db_variable db_regs[] = {
	{ "ds",		dbreg(ds),     db_x86_64_regop },
	{ "es",		dbreg(es),     db_x86_64_regop },
	{ "fs",		dbreg(fs),     db_x86_64_regop },
	{ "gs",		dbreg(gs),     db_x86_64_regop },
	{ "rdi",	dbreg(rdi),    db_x86_64_regop },
	{ "rsi",	dbreg(rsi),    db_x86_64_regop },
	{ "rbp",	dbreg(rbp),    db_x86_64_regop },
	{ "rbx",	dbreg(rbx),    db_x86_64_regop },
	{ "rdx",	dbreg(rdx),    db_x86_64_regop },
	{ "rcx",	dbreg(rcx),    db_x86_64_regop },
	{ "rax",	dbreg(rax),    db_x86_64_regop },
	{ "r8",		dbreg(r8),     db_x86_64_regop },
	{ "r9",		dbreg(r9),     db_x86_64_regop },
	{ "r10",	dbreg(r10),    db_x86_64_regop },
	{ "r11",	dbreg(r11),    db_x86_64_regop },
	{ "r12",	dbreg(r12),    db_x86_64_regop },
	{ "r13",	dbreg(r13),    db_x86_64_regop },
	{ "r14",	dbreg(r14),    db_x86_64_regop },
	{ "r15",	dbreg(r15),    db_x86_64_regop },
	{ "rip",	dbreg(rip),    db_x86_64_regop },
	{ "cs",		dbreg(cs),     db_x86_64_regop },
	{ "rflags",	dbreg(rflags), db_x86_64_regop },
	{ "rsp",	dbreg(rsp),    db_x86_64_regop },
	{ "ss",		dbreg(ss),     db_x86_64_regop },
};
struct db_variable * db_eregs =
	db_regs + sizeof(db_regs)/sizeof(db_regs[0]);

static int
db_x86_64_regop(struct db_variable *vp, db_expr_t *val, int opcode)
d33 25
a57 15
        db_expr_t *regaddr =
            (db_expr_t *)(((uint8_t *)DDB_REGS) + ((size_t)vp->valuep));
        
        switch (opcode) {
        case DB_VAR_GET:
                *val = *regaddr;
                break;
        case DB_VAR_SET:
                *regaddr = *val;
                break;
        default:
                panic("db_x86_64_regop: unknown op %d", opcode);
        }
        return 0;
}
d59 12
a70 4
/*
 * Stack trace.
 */
#define	INKERNEL(va)	(((vaddr_t)(va)) >= VM_MIN_KERNEL_ADDRESS)
d72 10
a81 20
struct x86_64_frame {
	struct x86_64_frame	*f_frame;
	long			f_retaddr;
	long			f_arg0;
};

#define	NONE		0
#define	TRAP		1
#define	SYSCALL		2
#define	INTERRUPT	3

db_addr_t	db_trap_symbol_value = 0;
db_addr_t	db_syscall_symbol_value = 0;
db_addr_t	db_kdintr_symbol_value = 0;
boolean_t	db_trace_symbols_found = FALSE;

void db_find_trace_symbols(void);
int db_numargs(struct x86_64_frame *);
void db_nextframe(struct x86_64_frame **, db_addr_t *, long *, int,
    int (*) (const char *, ...));
d83 8
a90 4
void
db_find_trace_symbols()
{
	db_expr_t	value;
d92 8
a99 8
	if (db_value_of_name("_trap", &value))
		db_trap_symbol_value = (db_addr_t) value;
	if (db_value_of_name("_kdintr", &value))
		db_kdintr_symbol_value = (db_addr_t) value;
	if (db_value_of_name("_syscall", &value))
		db_syscall_symbol_value = (db_addr_t) value;
	db_trace_symbols_found = TRUE;
}
d101 1
a101 10
/*
 * Figure out how many arguments were passed into the frame at "fp".
 * We can probably figure out how many arguments where passed above
 * the first 6 (which are in registers), but since we can't
 * reliably determine the values currently, just return 0.
 */
int
db_numargs(fp)
	struct x86_64_frame *fp;
{
d103 12
d117 2
a118 17
/* 
 * Figure out the next frame up in the call stack.  
 * For trap(), we print the address of the faulting instruction and 
 *   proceed with the calling frame.  We return the ip that faulted.
 *   If the trap was caused by jumping through a bogus pointer, then
 *   the next line in the backtrace will list some random function as 
 *   being called.  It should get the argument list correct, though.  
 *   It might be possible to dig out from the next frame up the name
 *   of the function that faulted, but that could get hairy.
 */
void
db_nextframe(fp, ip, argp, is_trap, pr)
	struct x86_64_frame **fp;		/* in/out */
	db_addr_t	*ip;		/* out */
	long *argp;			/* in */
	int is_trap;			/* in */
	int (*pr)(const char *, ...); /* in */
d120 18
a137 29

	switch (is_trap) {
	    case NONE:
		*ip = (db_addr_t)
			db_get_value((db_addr_t)&(*fp)->f_retaddr, 8, FALSE);
		*fp = (struct x86_64_frame *)
			db_get_value((db_addr_t)&(*fp)->f_frame, 8, FALSE);
		break;

	    default: {
		struct trapframe *tf;

		/* The only argument to trap() or syscall() is the trapframe. */
		tf = (struct trapframe *)argp;
		switch (is_trap) {
		case TRAP:
			(*pr)("--- trap (number %d) ---\n", tf->tf_trapno);
			break;
		case SYSCALL:
			(*pr)("--- syscall (number %ld) ---\n", tf->tf_rax);
			break;
		case INTERRUPT:
			(*pr)("--- interrupt ---\n");
			break;
		}
		*fp = (struct x86_64_frame *)tf->tf_rbp;
		*ip = (db_addr_t)tf->tf_rip;
		break;
	    }
d139 1
d143 2
a144 6
db_stack_trace_print(addr, have_addr, count, modif, pr)
	db_expr_t	addr;
	boolean_t	have_addr;
	db_expr_t	count;
	char		*modif;
	int		(*pr)(const char *, ...);
d146 4
a149 23
	struct x86_64_frame *frame, *lastframe;
	long		*argp;
	db_addr_t	callpc;
	int		is_trap = 0;
	boolean_t	kernel_only = TRUE;
	boolean_t	trace_thread = FALSE;

#if 0
	if (!db_trace_symbols_found)
		db_find_trace_symbols();
#endif

	{
		register char *cp = modif;
		register char c;

		while ((c = *cp++) != 0) {
			if (c == 't')
				trace_thread = TRUE;
			if (c == 'u')
				kernel_only = FALSE;
		}
	}
d151 1
a151 30
	if (!have_addr) {
		frame = (struct x86_64_frame *)ddb_regs.tf_rbp;
		callpc = (db_addr_t)ddb_regs.tf_rip;
	} else {
#if 0
		if (trace_thread) {
			struct proc *p;
			struct user *u;
			struct lwp *l;
			(*pr)("trace: pid %d ", (int)addr);
			p = pfind(addr);
			if (p == NULL) {
				(*pr)("not found\n");
				return;
			}
			l = proc_representative_lwp(p);
			if (!(l->l_flag&L_INMEM)) {
				(*pr)("swapped out\n");
				return;
			}
			u = l->l_addr;
			frame = (struct x86_64_frame *) u->u_pcb.pcb_rbp;
			(*pr)("at %p\n", frame);
		} else
#endif
			frame = (struct x86_64_frame *)addr;
		callpc = (db_addr_t)
			 db_get_value((db_addr_t)&frame->f_retaddr, 8, FALSE);
		frame = (struct x86_64_frame *)frame->f_frame;
	}
d153 11
a163 104
	lastframe = 0;
	while (count && frame != 0) {
		int		narg;
		char *	name;
		db_expr_t	offset;
		db_sym_t	sym;
#define MAXNARG	16
		char	*argnames[MAXNARG], **argnp = NULL;

		sym = db_search_symbol(callpc, DB_STGY_ANY, &offset);
		db_symbol_values(sym, &name, NULL);

		if (lastframe == 0 && sym == NULL) {
			/* Symbol not found, peek at code */
			long	instr = db_get_value(callpc, 8, FALSE);

			offset = 1;
			if ((instr & 0x00ffffff) == 0x00e58955 ||
					/* enter: pushl %ebp, movl %esp, %ebp */
			    (instr & 0x0000ffff) == 0x0000e589
					/* enter+1: movl %esp, %ebp */) {
				offset = 0;
			}
		}
		if (INKERNEL(frame) && name) {
#ifdef __ELF__
			if (!strcmp(name, "trap")) {
				is_trap = TRAP;
			} else if (!strcmp(name, "syscall")) {
				is_trap = SYSCALL;
			} else if (name[0] == 'X') {
				if (!strncmp(name, "Xintr", 5) ||
				    !strncmp(name, "Xresume", 7) ||
				    !strncmp(name, "Xstray", 6) ||
				    !strncmp(name, "Xhold", 5) ||
				    !strncmp(name, "Xrecurse", 8) ||
				    !strcmp(name, "Xdoreti") ||
				    !strncmp(name, "Xsoft", 5)) {
					is_trap = INTERRUPT;
				} else
					goto normal;
			} else
				goto normal;
			narg = 0;
#else
			if (!strcmp(name, "_trap")) {
				is_trap = TRAP;
			} else if (!strcmp(name, "_syscall")) {
				is_trap = SYSCALL;
			} else if (name[0] == '_' && name[1] == 'X') {
				if (!strncmp(name, "_Xintr", 6) ||
				    !strncmp(name, "_Xresume", 8) ||
				    !strncmp(name, "_Xstray", 7) ||
				    !strncmp(name, "_Xhold", 6) ||
				    !strncmp(name, "_Xrecurse", 9) ||
				    !strcmp(name, "_Xdoreti") ||
				    !strncmp(name, "_Xsoft", 6)) {
					is_trap = INTERRUPT;
				} else
					goto normal;
			} else
				goto normal;
			narg = 0;
#endif /* __ELF__ */
		} else {
		normal:
			is_trap = NONE;
			narg = MAXNARG;
			if (db_sym_numargs(sym, &narg, argnames))
				argnp = argnames;
			else
				narg = db_numargs(frame);
		}

		(*pr)("%s(", name);

		if (lastframe == 0 && offset == 0 && !have_addr) {
			/*
			 * We have a breakpoint before the frame is set up
			 * Use %esp instead
			 */
			argp = &((struct x86_64_frame *)(ddb_regs.tf_rsp-8))->f_arg0;
		} else {
			argp = &frame->f_arg0;
		}

		while (narg) {
			if (argnp)
				(*pr)("%s=", *argnp++);
			(*pr)("%lx", db_get_value((db_addr_t)argp, 8, FALSE));
			argp++;
			if (--narg != 0)
				(*pr)(",");
		}
		(*pr)(") at ");
		db_printsym(callpc, DB_STGY_PROC, pr);
		(*pr)("\n");

		if (lastframe == 0 && offset == 0 && !have_addr) {
			/* Frame really belongs to next callpc */
			lastframe = (struct x86_64_frame *)(ddb_regs.tf_rsp-8);
			callpc = (db_addr_t)
				 db_get_value((db_addr_t)&lastframe->f_retaddr,
				    8, FALSE);
d166 5
a170 35

		lastframe = frame;
		db_nextframe(&frame, &callpc, &frame->f_arg0, is_trap, pr);

		if (frame == 0) {
			/* end of chain */
			break;
		}
		if (INKERNEL(frame)) {
			/* staying in kernel */
			if (frame <= lastframe) {
				(*pr)("Bad frame pointer: %p\n", frame);
				break;
			}
		} else if (INKERNEL(lastframe)) {
			/* switch from user to kernel */
			if (kernel_only) {
				(*pr)("end of kernel\n");
				break;	/* kernel stack only */
			}
		} else {
			/* in user */
			if (frame <= lastframe) {
				(*pr)("Bad user frame pointer: %p\n",
					  frame);
				break;
			}
		}
		--count;
	}
	(*pr)("end trace frame: 0x%lx, count: %d\n", frame, count);

	if (count && is_trap != NONE) {
		db_printsym(callpc, DB_STGY_XTRN, pr);
		(*pr)(":\n");
d172 6
@

