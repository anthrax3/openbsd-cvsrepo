head	1.36;
access;
symbols
	OPENBSD_6_0:1.35.0.2
	OPENBSD_6_0_BASE:1.35
	OPENBSD_5_9:1.33.0.2
	OPENBSD_5_9_BASE:1.33
	OPENBSD_5_8:1.33.0.4
	OPENBSD_5_8_BASE:1.33
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.28.0.8
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.28.0.6
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.28.0.2
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.27.0.2
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.26.0.2
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.4
	OPENBSD_5_0:1.25.0.2
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.24.0.2
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.22.0.6
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.22.0.4
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.15.0.2
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.12.0.4
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.2
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.10.0.2
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.8.0.2
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.6.0.4
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	SMP_SYNC_A:1.2
	SMP_SYNC_B:1.2
	OPENBSD_3_5:1.1.0.4
	OPENBSD_3_5_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.36
date	2017.02.12.04.55.08;	author guenther;	state Exp;
branches;
next	1.35;
commitid	1rXx7AiXIWFC9gYa;

1.35
date	2016.04.03.19.49.35;	author guenther;	state Exp;
branches;
next	1.34;
commitid	gPkLk25LehmllQxP;

1.34
date	2016.04.03.17.48.33;	author guenther;	state Exp;
branches;
next	1.33;
commitid	9ebLv9UDmLVagKMI;

1.33
date	2015.06.28.18.54.54;	author guenther;	state Exp;
branches;
next	1.32;
commitid	9qSlzkscc1lVVnYi;

1.32
date	2015.05.18.19.59.27;	author guenther;	state Exp;
branches;
next	1.31;
commitid	MLFvGCnCMKMdmAtY;

1.31
date	2015.05.05.02.13.46;	author guenther;	state Exp;
branches;
next	1.30;
commitid	dNPv28CJI5BxtRGW;

1.30
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.29;
commitid	p4LJxGKbi0BU2cG6;

1.29
date	2014.11.16.12.30.56;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	yv0ECmCdICvq576h;

1.28
date	2013.06.02.16.38.05;	author guenther;	state Exp;
branches;
next	1.27;

1.27
date	2013.01.16.19.04.43;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2012.04.14.14.26.41;	author guenther;	state Exp;
branches;
next	1.25;

1.25
date	2011.03.18.03.10.47;	author guenther;	state Exp;
branches;
next	1.24;

1.24
date	2010.11.13.04.16.42;	author guenther;	state Exp;
branches;
next	1.23;

1.23
date	2010.10.26.05.49.10;	author guenther;	state Exp;
branches;
next	1.22;

1.22
date	2009.06.09.02.56.38;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2009.06.06.23.45.35;	author guenther;	state Exp;
branches;
next	1.20;

1.20
date	2009.06.05.10.51.44;	author guenther;	state Exp;
branches;
next	1.19;

1.19
date	2009.05.28.09.05.33;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2009.04.27.17.48.22;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2009.04.23.07.42.02;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2009.03.26.17.24.33;	author oga;	state Exp;
branches;
next	1.15;

1.15
date	2009.02.03.11.24.19;	author mikeb;	state Exp;
branches;
next	1.14;

1.14
date	2009.01.28.08.02.02;	author grange;	state Exp;
branches;
next	1.13;

1.13
date	2009.01.17.23.44.46;	author guenther;	state Exp;
branches;
next	1.12;

1.12
date	2007.10.13.07.18.32;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2007.10.10.15.53.51;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2007.05.27.20.59.25;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2007.05.25.16.22.11;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2006.11.29.12.26.13;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2006.06.23.13.46.05;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2005.12.13.00.18.19;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2005.10.28.21.57.31;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.20.17.51.05;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.25.11.03.27;	author art;	state Exp;
branches;
next	1.2;

1.2
date	2004.05.13.20.20.24;	author sturm;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.28.01.39.39;	author mickey;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.06.05.23.09.24;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.36
log
@Split up fork1():
 - FORK_THREAD handling is a totally separate function, thread_fork(),
   that is only used by sys___tfork() and which loses the flags, func,
   arg, and newprocp parameters and gains tcb parameter to guarantee
   the new thread's TCB is set before the creating thread returns
 - fork1() loses its stack and tidptr parameters
Common bits factor out:
 - struct proc allocation and initialization moves to thread_new()
 - maxthread handling moves to fork_check_maxthread()
 - setting the new thread running moves to fork_thread_start()
The MD cpu_fork() function swaps its unused stacksize parameter for
a tcb parameter.

luna88k testing by aoyama@@, alpha testing by dlg@@
ok mpi@@
@
text
@/*	$OpenBSD: vm_machdep.c,v 1.35 2016/04/03 19:49:35 guenther Exp $	*/
/*	$NetBSD: vm_machdep.c,v 1.1 2003/04/26 18:39:33 fvdl Exp $	*/

/*-
 * Copyright (c) 1995 Charles M. Hannum.  All rights reserved.
 * Copyright (c) 1982, 1986 The Regents of the University of California.
 * Copyright (c) 1989, 1990 William Jolitz
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department, and William Jolitz.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)vm_machdep.c	7.3 (Berkeley) 5/13/91
 */

/*
 *	Utah $Hdr: vm_machdep.c 1.16.1.1 89/06/23$
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/malloc.h>
#include <sys/vnode.h>
#include <sys/buf.h>
#include <sys/user.h>
#include <sys/exec.h>
#include <sys/ptrace.h>
#include <sys/signalvar.h>

#include <uvm/uvm_extern.h>

#include <machine/cpu.h>
#include <machine/reg.h>
#include <machine/fpu.h>
#include <machine/tcb.h>

void setredzone(struct proc *);

/*
 * Finish a fork operation, with process p2 nearly set up.
 * Copy and update the kernel stack and pcb, making the child
 * ready to run, and marking it so that it can return differently
 * than the parent.
 */
void
cpu_fork(struct proc *p1, struct proc *p2, void *stack, void *tcb,
    void (*func)(void *), void *arg)
{
	struct pcb *pcb = &p2->p_addr->u_pcb;
	struct trapframe *tf;
	struct switchframe *sf;

	/*
	 * If fpuproc != p1, then the fpu h/w state is irrelevant and the
	 * state had better already be in the pcb.  This is true for forks
	 * but not for dumps.
	 *
	 * If fpuproc == p1, then we have to save the fpu h/w state to
	 * p1's pcb so that we can copy it.
	 */
	if (p1->p_addr->u_pcb.pcb_fpcpu != NULL)
		fpusave_proc(p1, 1);

	p2->p_md.md_flags = p1->p_md.md_flags;

#ifdef DIAGNOSTIC
	if (p1 != curproc && p1 != &proc0)
		panic("cpu_fork: curproc");
#endif
	*pcb = p1->p_addr->u_pcb;

	/*
	 * Activate the address space.
	 */
	pmap_activate(p2);

	/* Record where this process's kernel stack is */
	pcb->pcb_kstack = (u_int64_t)p2->p_addr + USPACE - 16;

	/*
	 * Copy the trapframe.
	 */
	p2->p_md.md_regs = tf = (struct trapframe *)pcb->pcb_kstack - 1;
	*tf = *p1->p_md.md_regs;

	setredzone(p2);

	/*
	 * If specified, give the child a different stack and/or TCB
	 */
	if (stack != NULL)
		tf->tf_rsp = (u_int64_t)stack;
	if (tcb != NULL)
		pcb->pcb_fsbase = (u_int64_t)tcb;

	sf = (struct switchframe *)tf - 1;
	sf->sf_r12 = (u_int64_t)func;
	sf->sf_r13 = (u_int64_t)arg;
	sf->sf_rip = (u_int64_t)proc_trampoline;
	pcb->pcb_rsp = (u_int64_t)sf;
	pcb->pcb_rbp = 0;
}

/*
 * cpu_exit is called as the last action during exit.
 *
 * We clean up a little and then call sched_exit() with the old proc as an
 * argument.
 */
void
cpu_exit(struct proc *p)
{

	/* If we were using the FPU, forget about it. */
	if (p->p_addr->u_pcb.pcb_fpcpu != NULL)
		fpusave_proc(p, 0);

	pmap_deactivate(p);
	sched_exit(p);
}

/*
 * Set a red zone in the kernel stack after the u. area.
 */
void
setredzone(struct proc *p)
{
#if 0
	pmap_remove(pmap_kernel(), (vaddr_t)p->p_addr + PAGE_SIZE,
	    (vaddr_t)p->p_addr + 2 * PAGE_SIZE);
	pmap_update(pmap_kernel());
#endif
}

/*
 * Map a user I/O request into kernel virtual address space.
 * Note: the pages are already locked by uvm_vslock(), so we
 * do not need to pass an access_type to pmap_enter().   
 */
void
vmapbuf(struct buf *bp, vsize_t len)
{
	vaddr_t faddr, taddr, off;
	paddr_t fpa;

	if ((bp->b_flags & B_PHYS) == 0)
		panic("vmapbuf");
	faddr = trunc_page((vaddr_t)(bp->b_saveaddr = bp->b_data));
	off = (vaddr_t)bp->b_data - faddr;
	len = round_page(off + len);
	taddr= uvm_km_valloc_wait(phys_map, len);
	bp->b_data = (caddr_t)(taddr + off);
	/*
	 * The region is locked, so we expect that pmap_pte() will return
	 * non-NULL.
	 * XXX: unwise to expect this in a multithreaded environment.
	 * anything can happen to a pmap between the time we lock a 
	 * region, release the pmap lock, and then relock it for
	 * the pmap_extract().
	 *
	 * no need to flush TLB since we expect nothing to be mapped
	 * where we we just allocated (TLB will be flushed when our
	 * mapping is removed).
	 */
	while (len) {
		(void) pmap_extract(vm_map_pmap(&bp->b_proc->p_vmspace->vm_map),
		    faddr, &fpa);
		pmap_kenter_pa(taddr, fpa, PROT_READ | PROT_WRITE);
		faddr += PAGE_SIZE;
		taddr += PAGE_SIZE;
		len -= PAGE_SIZE;
	}
}

/*
 * Unmap a previously-mapped user I/O request.
 */
void
vunmapbuf(struct buf *bp, vsize_t len)
{
	vaddr_t addr, off;

	if ((bp->b_flags & B_PHYS) == 0)
		panic("vunmapbuf");
	addr = trunc_page((vaddr_t)bp->b_data);
	off = (vaddr_t)bp->b_data - addr;
	len = round_page(off + len);
	pmap_kremove(addr, len);
	pmap_update(pmap_kernel());
	uvm_km_free_wakeup(phys_map, addr, len);
	bp->b_data = bp->b_saveaddr;
	bp->b_saveaddr = 0;
}

void *
tcb_get(struct proc *p)
{
	return ((void *)p->p_addr->u_pcb.pcb_fsbase);
}

void
tcb_set(struct proc *p, void *tcb)
{
	KASSERT(p == curproc);
	reset_segs();
	p->p_addr->u_pcb.pcb_fsbase = (u_int64_t)tcb;
}
@


1.35
log
@Don't call savectx() from cpu_fork(): the registers saved are overwritten

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.34 2016/04/03 17:48:33 guenther Exp $	*/
d69 1
a69 1
 * than the parent.  Returns 1 in the child process, 0 in the parent.
d72 1
a72 1
cpu_fork(struct proc *p1, struct proc *p2, void *stack, size_t stacksize,
d115 1
a115 1
	 * If specified, give the child a different stack.
d118 3
a120 1
		tf->tf_rsp = (u_int64_t)stack + stacksize;
@


1.34
log
@Move the setting of pcb_fsbase out of reset_segs() into its callers

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.33 2015/06/28 18:54:54 guenther Exp $	*/
a91 5
	/* Copy pcb from proc p1 to p2. */
	if (p1 == curproc) {
		/* Sync the PCB before we copy it. */
		savectx(curpcb);
	}
d93 1
a93 1
	else if (p1 != &proc0)
@


1.33
log
@Force the return to userspace from execve to go through iretq to get all
registers.  This lets us kill the special handling of pid 1 in fork and
merge {proc,child}_trampoline(). Do the same if ptrace(PT_SETREGS) is used
to modify registers.

ok mlarkin@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.32 2015/05/18 19:59:27 guenther Exp $	*/
d234 2
a235 1
	reset_segs(&p->p_addr->u_pcb, (u_int64_t)tcb);
@


1.32
log
@Do lazy update/reset of the FS.base and %[def]s segment registers: reseting
segment registers in cpu_switchto if the old thread had made it to userspace
and restoring FS.base only on first return to userspace since context switch.

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.31 2015/05/05 02:13:46 guenther Exp $	*/
d128 1
a128 5
	/* XXX fork of init(8) returns via proc_trampoline() */
	if (p2->p_pid == 1)
		sf->sf_rip = (u_int64_t)proc_trampoline;
	else
		sf->sf_rip = (u_int64_t)child_trampoline;
@


1.31
log
@emul_native is only used for kernel threads which can't dump core, so
delete coredump_trad(), uvm_coredump(), cpu_coredump(), struct md_coredump,
and various #includes that are superfluous.

This leaves compat_linux processes without a coredump callback.  If that
ability is desired, someone should update it to use coredump_elf32() and
verify the results...

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.30 2015/03/14 03:38:46 jsg Exp $	*/
d61 1
d226 13
@


1.30
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.29 2014/11/16 12:30:56 deraadt Exp $	*/
a51 1
#include <sys/core.h>
a151 50
}

/*
 * Dump the machine specific segment at the start of a core dump.
 */     
struct md_core {
	struct reg intreg;
	struct fpreg freg;
};

int
cpu_coredump(struct proc *p, struct vnode *vp, struct ucred *cred,
    struct core *chdr)
{
	struct md_core md_core;
	struct coreseg cseg;
	int error;

	CORE_SETMAGIC(*chdr, COREMAGIC, MID_MACHINE, 0);
	chdr->c_hdrsize = ALIGN(sizeof(*chdr));
	chdr->c_seghdrsize = ALIGN(sizeof(cseg));
	chdr->c_cpusize = sizeof(md_core);

	/* Save integer registers. */
	error = process_read_regs(p, &md_core.intreg);
	if (error)
		return error;

	/* Save floating point registers. */
	error = process_read_fpregs(p, &md_core.freg);
	if (error)
		return error;

	CORE_SETMAGIC(cseg, CORESEGMAGIC, MID_MACHINE, CORE_CPU);
	cseg.c_addr = 0;
	cseg.c_size = chdr->c_cpusize;

	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&cseg, chdr->c_seghdrsize,
	    (off_t)chdr->c_hdrsize, UIO_SYSSPACE, IO_UNIT, cred, NULL, p);
	if (error)
		return error;

	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&md_core, sizeof(md_core),
	    (off_t)(chdr->c_hdrsize + chdr->c_seghdrsize), UIO_SYSSPACE,
	    IO_UNIT, cred, NULL, p);
	if (error)
		return error;

	chdr->c_nseg++;
	return 0;
@


1.29
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.28 2013/06/02 16:38:05 guenther Exp $	*/
a60 1
#include <machine/specialreg.h>
@


1.28
log
@Don't need gdt.h here
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.27 2013/01/16 19:04:43 miod Exp $	*/
d252 1
a252 1
		pmap_kenter_pa(taddr, fpa, VM_PROT_READ|VM_PROT_WRITE);
@


1.27
log
@cpu_coredump() also needs to invoke vn_rdwr() without IO_NODELOCKED; only
affects a.out binaries' core dumps.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.26 2012/04/14 14:26:41 guenther Exp $	*/
a59 1
#include <machine/gdt.h>
@


1.26
log
@User area hasn't been double-mapped in a long time
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.25 2011/03/18 03:10:47 guenther Exp $	*/
d193 1
a193 2
	    (off_t)chdr->c_hdrsize, UIO_SYSSPACE, IO_NODELOCKED|IO_UNIT, cred,
	    NULL, p);
d199 1
a199 1
	    IO_NODELOCKED|IO_UNIT, cred, NULL, p);
@


1.25
log
@Old-style MTRRs were never used on amd64, so remove the remaining traces
of them, as well as some other unused proc md_flags bits: MDP_COMPAT and
MDP_SYSCALL.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.24 2010/11/13 04:16:42 guenther Exp $	*/
a71 3
 * We currently double-map the user area so that the stack is at the same
 * address in each process; in the future we will probably relocate
 * the frame pointers on the stack after copying.
@


1.24
log
@Switch from TSS-per-process to TSS-per-CPU, placing the TSS right
next to the cpu's GDT, also making the double-fault stack per-CPU,
leaving it at the top of the page of the CPU's idle process.  Inline
pmap_activate() and pmap_deactivate() into the asm cpu_switchto
routine, adding a check for the new pmap already being marked as
active on the CPU.  Garbage collect the hasn't-been-used-in-years
GDT update IPI.

Tested by many; ok mikeb@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.23 2010/10/26 05:49:10 guenther Exp $	*/
a63 1
#include <machine/mtrr.h>
a154 3

	if (p->p_md.md_flags & MDP_USEDMTRR)
		mtrr_clean(p);
@


1.23
log
@The LDT is only used by dead compat code now, so load the ldt
register with the null selector (disabling use of it), stop reloading
it on every context switch, and blow away the table itself, as well
as the pcb and pmap bits that were used to track it.  Also, delete
two other unused pcb members: pcb_usersp and pcb_flags.  (Deleting
pcb_usersp also keeps the pcb_savefpu member aligned properly.)
Finally, delete the defines for the unimplemented AMD64_{GET,SET}_LDT
sysarch() calls.

Tested by various with both AMD and Intel chips
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.22 2009/06/09 02:56:38 krw Exp $	*/
d114 2
a115 4
	/* Fix up the TSS. */
	pcb->pcb_tss.tss_rsp0 = (u_int64_t)p2->p_addr + USPACE - 16;
	pcb->pcb_tss.tss_ist[0] = (u_int64_t)p2->p_addr + PAGE_SIZE - 16;
	p2->p_md.md_tss_sel = tss_alloc(pcb);
d120 1
a120 1
	p2->p_md.md_regs = tf = (struct trapframe *)pcb->pcb_tss.tss_rsp0 - 1;
a160 1
	tss_free(p->p_md.md_tss_sel);
@


1.22
log
@revert guenther@@'s un-revert of art's curpmap.

My

bios0: ASUSTeK Computer INC. P5K-E
cpu0: Intel(R) Core(TM)2 Quad CPU Q6600 @@ 2.40GHz, 2405.74 MHz
cpu1: Intel(R) Core(TM)2 Quad CPU Q6600 @@ 2.40GHz, 2405.46 MHz
cpu2: Intel(R) Core(TM)2 Quad CPU Q6600 @@ 2.40GHz, 2405.46 MHz
cpu3: Intel(R) Core(TM)2 Quad CPU Q6600 @@ 2.40GHz, 2405.46 MHz

can't boot with this in. It always hangs somewhere in fsck'ing if
any, or between netstart and local daemons if no fsck'ing. Also
fubars theo's real amd machine.

Much more testing needed for this.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.21 2009/06/06 23:45:35 guenther Exp $	*/
d110 1
a110 1
	 * Activate the address space.  Note this will refresh pcb_ldt_sel.
@


1.21
log
@Unrevert the curpmap change with the addition of correct %gs handling
in the IPI handler so that it works when it interrupts userspace,
waiting for the droppmap IPI to complete when destroying it, and
(most importantly) don't call pmap_tlb_droppmap() from cpu_exit().
Tested by myself and ckuethe, as our machines choked on the original.

ok @@art
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.19 2009/05/28 09:05:33 art Exp $	*/
d109 4
a112 3
	pcb->pcb_pmap = p2->p_vmspace->vm_map.pmap;
	pcb->pcb_ldt_sel = p2->p_vmspace->vm_map.pmap->pm_ldt_sel;
	pcb->pcb_cr3 = p2->p_vmspace->vm_map.pmap->pm_pdirpa;
d162 1
@


1.20
log
@Revert the curpmap change.  We know the IPI is broken on both ends,
but even with proposed fixes, the reaper panics are back.
@
text
@d109 3
a111 4
	/*
	 * Activate the address space.  Note this will refresh pcb_ldt_sel.
	 */
	pmap_activate(p2);
a160 1
	pmap_deactivate(p);
@


1.19
log
@Bring back the curpmap change. It was missing a reload of the pmap on
curcpu when we were freeing a pmap. Tested and working for a few weeks
now, but I was a bit too busy to commit it earlier.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.17 2009/04/23 07:42:02 art Exp $	*/
d109 4
a112 3
	pcb->pcb_pmap = p2->p_vmspace->vm_map.pmap;
	pcb->pcb_ldt_sel = p2->p_vmspace->vm_map.pmap->pm_ldt_sel;
	pcb->pcb_cr3 = p2->p_vmspace->vm_map.pmap->pm_pdirpa;
d162 1
a162 1
	pmap_tlb_droppmap(p->p_vmspace->vm_map.pmap);
@


1.18
log
@turning pmap_deactivate into a NOP brought back the reaper panics, probably
because the reaper is running on the mappings of pmap from the process it
is about to unmap.  back it out until ht is fixed right; don't let this sit
in the tree waiting for a fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.16 2009/03/26 17:24:33 oga Exp $	*/
d109 3
a111 4
	/*
	 * Activate the address space.  Note this will refresh pcb_ldt_sel.
	 */
	pmap_activate(p2);
d161 1
a161 1
	pmap_deactivate(p);
@


1.17
log
@Make pmap_deactivate a NOP.

Instead of keeping a bitmask of on which cpu the pmap might be active which
we clear in pmap_deactivate, always keep a pointer to the currently loaded
pmap in cpu_info. We can now optimize a context switch to the kernel pmap
(idle and kernel threads) to keep the previously loaded pmap still loaded
and then reuse that pmap if we context switch back to the same process.

Introduce a new IPI to force a pmap reload before the pmap is destroyed.

Clean up cpu_switchto.

toby@@ ok
@
text
@d109 4
a112 3
	pcb->pcb_pmap = p2->p_vmspace->vm_map.pmap;
	pcb->pcb_ldt_sel = p2->p_vmspace->vm_map.pmap->pm_ldt_sel;
	pcb->pcb_cr3 = p2->p_vmspace->vm_map.pmap->pm_pdirpa;
d162 1
a162 1
	pmap_tlb_droppmap(p->p_vmspace->vm_map.pmap);
@


1.16
log
@Remove cpu_wait(). It's original use was to be called from the reaper so
MD code would free resources that couldn't be freed until we were no
longer running in that processor. However, it's is unused on all
architectures since mikeb@@'s tss changes on x86 earlier in the year.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.15 2009/02/03 11:24:19 mikeb Exp $	*/
d109 3
a111 4
	/*
	 * Activate the address space.  Note this will refresh pcb_ldt_sel.
	 */
	pmap_activate(p2);
d161 1
a161 1
	pmap_deactivate(p);
@


1.15
log
@Free TSS on the stack of the dead process.

In order to do that we have to remove all sleeping parts: sleeping
memory allocation and a sleeping lock.  Thus we're moving this code
to the spinning lock (mutex) and getting rid of the GDT grow code.
Downside is that now we're pre-allocating 64kb of memory per CPU
from the start, but this might be optimized in future.

This also unifies GDT code and MAXGDTSIZ define across i386 and amd64.

With help from mickey.

ok toby, art
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.14 2009/01/28 08:02:02 grange Exp $	*/
a164 10
}

/*
 * cpu_wait is called from reaper() to let machine-dependent
 * code free machine-dependent resources that couldn't be freed
 * in cpu_exit().
 */
void
cpu_wait(struct proc *p)
{
@


1.14
log
@Add missing braces in trunc_page() call from vmapbuf().

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.13 2009/01/17 23:44:46 guenther Exp $	*/
d163 1
a174 2
	/* Nuke the TSS. */
	tss_free(p->p_md.md_tss_sel);
@


1.13
log
@gdt_compact() was removed years ago, so kill the code and comments
that worked around its presence

ok'ed by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.12 2007/10/13 07:18:32 miod Exp $	*/
d255 1
a255 1
	faddr = trunc_page((vaddr_t)bp->b_saveaddr = bp->b_data);
@


1.12
log
@Fix cpu_exit() comments to be more closer to reality.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.11 2007/10/10 15:53:51 art Exp $	*/
a107 9

	/*
	 * Preset these so that gdt_compact() doesn't get confused if called
	 * during the allocations below.
	 *
	 * Note: pcb_ldt_sel is handled in the pmap_activate() call when
	 * we run the new process.
	 */
	p2->p_md.md_tss_sel = GSEL(GNULL_SEL, SEL_KPL);
@


1.11
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.10 2007/05/27 20:59:25 miod Exp $	*/
d157 2
a158 3
 * We clean up a little and then call switch_exit() with the old proc as an
 * argument.  switch_exit() first switches to proc0's context, and finally
 * jumps into switch() to wait for another process to wake up.
@


1.10
log
@pagemove() is no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.9 2007/05/25 16:22:11 art Exp $	*/
d172 2
a173 6
	/*
	 * No need to do user LDT cleanup here; it's handled in
	 * pmap_destroy().
	 */

	switch_exit(p, exit2);
@


1.9
log
@Change the old slow and complicated TLB shootdown code to new, fast and
simple. This is basically the same code as on i386 and basically the same
performance improvements.

This change also includes code to delay the freeing of ptps until they
have been properly shot.

in snaps for a week, no problems reported.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.8 2006/11/29 12:26:13 miod Exp $	*/
a253 44
}


/*
 * Move pages from one kernel virtual address to another.
 * Both addresses are assumed to reside in the Sysmap.
 */
void
pagemove(caddr_t from, caddr_t to, size_t size)
{
	pt_entry_t *fpte, *tpte, ofpte, otpte;
	vaddr_t fsva, tsva, feva, teva;

#ifdef DIAGNOSTIC
	if ((size & PAGE_MASK) != 0)
		panic("pagemove");
#endif

	fsva = (vaddr_t)from;
	tsva = (vaddr_t)to;
	feva = fsva + size;
	teva = tsva + size;

	fpte = kvtopte((vaddr_t)from);
	tpte = kvtopte((vaddr_t)to);
#ifdef LARGEPAGES
	/* XXX For now... */
	if (*fpte & PG_PS)
		panic("pagemove: fpte PG_PS");
	if (*tpte & PG_PS)
		panic("pagemove: tpte PG_PS");
#endif
	while (size > 0) {
		otpte = *tpte;
		ofpte = *fpte;
		*tpte++ = *fpte;
		*fpte++ = 0;
		from += PAGE_SIZE;
		to += PAGE_SIZE;
		size -= PAGE_SIZE;
	}
	pmap_tlb_shootrange(pmap_kernel(), fsva, feva);
	pmap_tlb_shootrange(pmap_kernel(), tsva, teva);
	pmap_tlb_shootwait();
@


1.8
log
@Remove cpu_swapin() and cpu_swapout(), they are no longer necessary (except
for cpu_swapin() on hppa* which is kept).
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.7 2006/06/23 13:46:05 mickey Exp $	*/
d265 1
a265 1
	int32_t cpumask = 0;
d271 6
a290 6
		if (otpte & PG_V)
			pmap_tlb_shootdown(pmap_kernel(),
			    (vaddr_t)to, otpte, &cpumask);
		if (ofpte & PG_V)
			pmap_tlb_shootdown(pmap_kernel(),
			    (vaddr_t)from, ofpte, &cpumask);
d295 3
a297 1
	pmap_tlb_shootnow(cpumask);
@


1.7
log
@consistantly count context switches on exit; miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.6 2005/12/13 00:18:19 jsg Exp $	*/
a151 16
}

void
cpu_swapin(struct proc *p)
{
	setredzone(p);
}

void
cpu_swapout(struct proc *p)
{

	/*
	 * Make sure we save the FP state before the user area vanishes.
	 */
	fpusave_proc(p, 1);
@


1.6
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.
Checked by ian@@, deraadt@@ and millert@@, arm portion checked by drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.5 2005/10/28 21:57:31 kettenis Exp $	*/
a192 1
	uvmexp.swtch++;
@


1.5
log
@Check for init(8) return path by process ID and make it the exception rather
than the default.
ok deraadt@@, weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.4 2004/09/20 17:51:05 miod Exp $	*/
d22 1
a22 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.4
log
@addres -> address
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.3 2004/06/25 11:03:27 art Exp $	*/
d149 4
a152 1
	if (func == child_return)
a153 2
	else
		sf->sf_rip = (u_int64_t)proc_trampoline;
@


1.3
log
@SMP support. Big parts from NetBSD, but with some really serious debugging
done by me, niklas and others. Especially wrt. NXE support.

Still needs some polishing, especially in dmesg messages, but we're now
building kernel faster than ever.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.2 2004/05/13 20:20:24 sturm Exp $	*/
d123 1
a123 1
	 * Activate the addres space.  Note this will refresh pcb_ldt_sel.
@


1.2
log
@activate systrace on amd64, while here get rid of syscall_{plain,fancy}
instead use syscall() as everywhere else

ok mickey, tested and ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.1 2004/01/28 01:39:39 mickey Exp $	*/
a146 1
	sf->sf_ppl = IPL_NONE;
@


1.1
log
@an amd64 arch support.
hacked by art@@ from netbsd sources and then later debugged
by me into the shape where it can host itself.
no bootloader yet as needs redoing from the
recent advanced i386 sources (anyone? ;)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a70 1
void syscall_intern(struct proc *p);	/* syscall.c */
a100 1
	syscall_intern(p2);
@


1.1.2.1
log
@Merge with the trunk
@
text
@d71 1
d102 1
@


