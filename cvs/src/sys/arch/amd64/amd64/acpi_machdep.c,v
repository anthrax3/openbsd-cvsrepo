head	1.78;
access;
symbols
	OPENBSD_6_1_BASE:1.78
	OPENBSD_6_0:1.76.0.2
	OPENBSD_6_0_BASE:1.76
	OPENBSD_5_9:1.72.0.2
	OPENBSD_5_9_BASE:1.72
	OPENBSD_5_8:1.70.0.4
	OPENBSD_5_8_BASE:1.70
	OPENBSD_5_7:1.68.0.2
	OPENBSD_5_7_BASE:1.68
	OPENBSD_5_6:1.62.0.4
	OPENBSD_5_6_BASE:1.62
	OPENBSD_5_5:1.57.0.4
	OPENBSD_5_5_BASE:1.57
	OPENBSD_5_4:1.55.0.2
	OPENBSD_5_4_BASE:1.55
	OPENBSD_5_3:1.52.0.2
	OPENBSD_5_3_BASE:1.52
	OPENBSD_5_2:1.49.0.2
	OPENBSD_5_2_BASE:1.49
	OPENBSD_5_1_BASE:1.47
	OPENBSD_5_1:1.47.0.6
	OPENBSD_5_0:1.47.0.4
	OPENBSD_5_0_BASE:1.47
	OPENBSD_4_9:1.47.0.2
	OPENBSD_4_9_BASE:1.47
	OPENBSD_4_8:1.44.0.2
	OPENBSD_4_8_BASE:1.44
	OPENBSD_4_7:1.33.0.2
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.21.0.4
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.16.0.2
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.12.0.2
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.6.0.4
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.2
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.4.0.2
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.4
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.1.0.2
	OPENBSD_3_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.78
date	2017.03.27.18.32.53;	author mlarkin;	state Exp;
branches;
next	1.77;
commitid	V2XqR4UPWQnnGV9h;

1.77
date	2017.03.27.18.24.08;	author deraadt;	state Exp;
branches;
next	1.76;
commitid	KkdbYCyrebNljBOz;

1.76
date	2016.07.15.22.05.40;	author tom;	state Exp;
branches;
next	1.75;
commitid	uhzNmY0D770HCgTW;

1.75
date	2016.05.18.04.42.49;	author mlarkin;	state Exp;
branches;
next	1.74;
commitid	XhhppJFizmPPnPDN;

1.74
date	2016.05.18.04.33.01;	author mlarkin;	state Exp;
branches;
next	1.73;
commitid	JGkcPSs0jmZKdjck;

1.73
date	2016.05.16.01.19.27;	author mlarkin;	state Exp;
branches;
next	1.72;
commitid	ejjZCIi4SS95OnQx;

1.72
date	2016.01.10.16.59.42;	author kettenis;	state Exp;
branches;
next	1.71;
commitid	RY6ynEalDrvUnDAA;

1.71
date	2015.08.30.10.05.09;	author yasuoka;	state Exp;
branches;
next	1.70;
commitid	8KYmU15QlyhusRif;

1.70
date	2015.03.16.20.31.47;	author deraadt;	state Exp;
branches;
next	1.69;
commitid	UF5MXB4OGf08laCK;

1.69
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.68;
commitid	p4LJxGKbi0BU2cG6;

1.68
date	2015.01.06.12.50.47;	author dlg;	state Exp;
branches;
next	1.67;
commitid	EAvvmUR28EGEqQFd;

1.67
date	2014.12.18.05.33.48;	author mlarkin;	state Exp;
branches;
next	1.66;
commitid	JVgpC5JUPLFOXy8N;

1.66
date	2014.12.08.07.12.37;	author mlarkin;	state Exp;
branches;
next	1.65;
commitid	9gsjQWzKEbWkbtZI;

1.65
date	2014.12.01.04.22.34;	author mlarkin;	state Exp;
branches;
next	1.64;
commitid	cy8NohEYV27HSFCT;

1.64
date	2014.11.16.12.30.56;	author deraadt;	state Exp;
branches;
next	1.63;
commitid	yv0ECmCdICvq576h;

1.63
date	2014.09.19.20.02.25;	author kettenis;	state Exp;
branches;
next	1.62;
commitid	lZNawJpIJwhgF8VB;

1.62
date	2014.07.16.07.42.50;	author mlarkin;	state Exp;
branches;
next	1.61;
commitid	BhZaVf1oRCQi7Ocn;

1.61
date	2014.06.08.17.53.14;	author daniel;	state Exp;
branches;
next	1.60;
commitid	qaHw3cZiWo1gKs8f;

1.60
date	2014.04.25.14.37.06;	author mlarkin;	state Exp;
branches;
next	1.59;

1.59
date	2014.03.27.10.24.40;	author dlg;	state Exp;
branches;
next	1.58;

1.58
date	2014.03.13.03.52.55;	author dlg;	state Exp;
branches;
next	1.57;

1.57
date	2014.01.21.09.40.54;	author kettenis;	state Exp;
branches;
next	1.56;

1.56
date	2013.12.19.21.30.02;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2013.07.01.10.08.08;	author kettenis;	state Exp;
branches;
next	1.54;

1.54
date	2013.03.20.21.23.05;	author kettenis;	state Exp;
branches;
next	1.53;

1.53
date	2013.03.19.06.46.27;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2012.11.27.17.38.45;	author pirofti;	state Exp;
branches;
next	1.51;

1.51
date	2012.10.17.22.49.27;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2012.10.08.21.47.47;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2012.07.13.16.02.24;	author mlarkin;	state Exp;
branches;
next	1.48;

1.48
date	2012.07.13.14.15.12;	author mlarkin;	state Exp;
branches;
next	1.47;

1.47
date	2010.11.13.04.16.42;	author guenther;	state Exp;
branches;
next	1.46;

1.46
date	2010.10.06.16.37.29;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2010.08.11.21.22.44;	author kettenis;	state Exp;
branches;
next	1.44;

1.44
date	2010.08.08.21.23.42;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2010.07.29.00.29.49;	author mlarkin;	state Exp;
branches;
next	1.42;

1.42
date	2010.07.27.16.53.11;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2010.07.25.21.43.38;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2010.07.06.06.25.56;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2010.07.01.21.45.03;	author mlarkin;	state Exp;
branches;
next	1.38;

1.38
date	2010.07.01.03.22.12;	author jsg;	state Exp;
branches;
next	1.37;

1.37
date	2010.07.01.00.48.48;	author mlarkin;	state Exp;
branches;
next	1.36;

1.36
date	2010.06.26.04.05.32;	author mlarkin;	state Exp;
branches;
next	1.35;

1.35
date	2010.04.20.22.08.17;	author tedu;	state Exp;
branches;
next	1.34;

1.34
date	2010.04.07.06.33.06;	author kettenis;	state Exp;
branches;
next	1.33;

1.33
date	2010.02.23.21.54.53;	author kettenis;	state Exp;
branches;
next	1.32;

1.32
date	2009.11.29.21.21.06;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2009.11.26.22.08.30;	author mlarkin;	state Exp;
branches;
next	1.30;

1.30
date	2009.11.26.11.49.49;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2009.11.26.11.49.33;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2009.11.26.11.49.07;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2009.11.26.00.14.11;	author mlarkin;	state Exp;
branches;
next	1.26;

1.26
date	2009.11.24.17.39.59;	author mlarkin;	state Exp;
branches;
next	1.25;

1.25
date	2009.11.23.16.21.54;	author pirofti;	state Exp;
branches;
next	1.24;

1.24
date	2009.11.22.22.00.25;	author pirofti;	state Exp;
branches;
next	1.23;

1.23
date	2009.11.22.21.41.37;	author pirofti;	state Exp;
branches;
next	1.22;

1.22
date	2009.08.13.15.33.20;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2009.06.06.00.23.38;	author mlarkin;	state Exp;
branches;
next	1.20;

1.20
date	2009.06.04.23.32.06;	author mlarkin;	state Exp;
branches;
next	1.19;

1.19
date	2009.06.02.12.50.29;	author kurt;	state Exp;
branches;
next	1.18;

1.18
date	2009.06.01.19.59.18;	author mlarkin;	state Exp;
branches;
next	1.17;

1.17
date	2009.05.31.03.42.38;	author mlarkin;	state Exp;
branches;
next	1.16;

1.16
date	2009.02.19.21.02.05;	author marco;	state Exp;
branches;
next	1.15;

1.15
date	2009.02.15.02.03.40;	author marco;	state Exp;
branches;
next	1.14;

1.14
date	2008.12.28.22.27.10;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2008.06.01.17.59.55;	author marco;	state Exp;
branches;
next	1.12;

1.12
date	2008.02.05.22.00.54;	author marco;	state Exp;
branches;
next	1.11;

1.11
date	2007.12.05.19.17.13;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2007.11.25.09.11.12;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2007.11.16.02.45.56;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2007.11.15.22.19.14;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2007.11.12.20.58.12;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2007.02.22.07.39.55;	author jordan;	state Exp;
branches;
next	1.5;

1.5
date	2006.11.29.11.57.27;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2006.02.20.05.16.20;	author marco;	state Exp;
branches;
next	1.3;

1.3
date	2005.12.16.20.41.50;	author marco;	state Exp;
branches;
next	1.2;

1.2
date	2005.10.21.18.55.00;	author martin;	state Exp;
branches;
next	1.1;

1.1
date	2005.06.02.20.09.38;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.78
log
@add a newline to an error printf
@
text
@/*	$OpenBSD: acpi_machdep.c,v 1.77 2017/03/27 18:24:08 deraadt Exp $	*/
/*
 * Copyright (c) 2005 Thorsten Lockert <tholo@@sigmasoft.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/memrange.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/reboot.h>
#include <sys/hibernate.h>

#include <uvm/uvm_extern.h>

#include <machine/bus.h>
#include <machine/biosvar.h>
#include <machine/isa_machdep.h>

#include <machine/cpu.h>
#include <machine/cpufunc.h>
#include <machine/cpuvar.h>

#include <dev/isa/isareg.h>
#include <dev/acpi/acpireg.h>
#include <dev/acpi/acpivar.h>
#include <dev/acpi/acpidev.h>
#include <dev/acpi/dsdt.h>

#include "isa.h"
#include "ioapic.h"
#include "lapic.h"

#if NIOAPIC > 0
#include <machine/i82093reg.h>
#include <machine/i82093var.h>
#include <machine/mpbiosvar.h>
#endif

#if NLAPIC > 0
#include <machine/i82489reg.h>
#include <machine/i82489var.h>
#endif

extern u_char acpi_real_mode_resume[], acpi_resume_end[];
extern u_char acpi_tramp_data_start[], acpi_tramp_data_end[];
extern u_int32_t acpi_pdirpa;
extern paddr_t tramp_pdirpa;

extern int acpi_savecpu(void) __returns_twice;

#define ACPI_BIOS_RSDP_WINDOW_BASE        0xe0000
#define ACPI_BIOS_RSDP_WINDOW_SIZE        0x20000

u_int8_t	*acpi_scan(struct acpi_mem_map *, paddr_t, size_t);

int
acpi_map(paddr_t pa, size_t len, struct acpi_mem_map *handle)
{
	paddr_t pgpa = trunc_page(pa);
	paddr_t endpa = round_page(pa + len);
	vaddr_t va = uvm_km_valloc(kernel_map, endpa - pgpa);

	if (va == 0)
		return (ENOMEM);

	handle->baseva = va;
	handle->va = (u_int8_t *)(va + (pa & PGOFSET));
	handle->vsize = endpa - pgpa;
	handle->pa = pa;

	do {
		pmap_kenter_pa(va, pgpa, PROT_READ | PROT_WRITE);
		va += NBPG;
		pgpa += NBPG;
	} while (pgpa < endpa);

	return 0;
}

void
acpi_unmap(struct acpi_mem_map *handle)
{
	pmap_kremove(handle->baseva, handle->vsize);
	uvm_km_free(kernel_map, handle->baseva, handle->vsize);
}

void *
acpi_intr_establish(int irq, int flags, int level,
    int (*handler)(void *), void *arg, const char *what)
{
#if NIOAPIC > 0
	struct ioapic_softc *apic;
	struct mp_intr_map *map;
	int type;

	apic = ioapic_find_bybase(irq);
	if (apic == NULL)
		return NULL;
	
	map = malloc(sizeof(*map), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (map == NULL)
		return NULL;

	map->ioapic = apic;
	map->ioapic_pin = irq - apic->sc_apic_vecbase;
	map->bus_pin = irq;
	if (flags & LR_EXTIRQ_POLARITY)
		map->flags |= (MPS_INTPO_ACTLO << MPS_INTPO_SHIFT);
	else
		map->flags |= (MPS_INTPO_ACTHI << MPS_INTPO_SHIFT);
	if (flags & LR_EXTIRQ_MODE)
		map->flags |= (MPS_INTTR_EDGE << MPS_INTTR_SHIFT);
	else
		map->flags |= (MPS_INTTR_LEVEL << MPS_INTTR_SHIFT);

	map->redir = (IOAPIC_REDLO_DEL_LOPRI << IOAPIC_REDLO_DEL_SHIFT);
	switch ((map->flags >> MPS_INTPO_SHIFT) & MPS_INTPO_MASK) {
	case MPS_INTPO_DEF:
	case MPS_INTPO_ACTLO:
		map->redir |= IOAPIC_REDLO_ACTLO;
		break;
	}
	switch ((map->flags >> MPS_INTTR_SHIFT) & MPS_INTTR_MASK) {
	case MPS_INTTR_DEF:
	case MPS_INTTR_LEVEL:
		map->redir |= IOAPIC_REDLO_LEVEL;
		break;
	}

	apic->sc_pins[map->ioapic_pin].ip_map = map;

	type = (flags & LR_EXTIRQ_MODE) ? IST_EDGE : IST_LEVEL;
	return (intr_establish(-1, (struct pic *)apic, map->ioapic_pin,
	    type, level, handler, arg, what));
#else
	return NULL;
#endif
}

u_int8_t *
acpi_scan(struct acpi_mem_map *handle, paddr_t pa, size_t len)
{
	size_t i;
	u_int8_t *ptr;
	struct acpi_rsdp1 *rsdp;

	if (acpi_map(pa, len, handle))
		return (NULL);
	for (ptr = handle->va, i = 0; i < len; ptr += 16, i += 16) {
		/* is there a valid signature? */
		if (memcmp(ptr, RSDP_SIG, sizeof(RSDP_SIG) - 1))
			continue;

		/* is the checksum valid? */
		if (acpi_checksum(ptr, sizeof(struct acpi_rsdp1)) != 0)
			continue;

		/* check the extended checksum as needed */
		rsdp = (struct acpi_rsdp1 *)ptr;
		if (rsdp->revision == 0)
			return (ptr);
		else if (rsdp->revision >= 2 && rsdp->revision <= 4)
			if (acpi_checksum(ptr, sizeof(struct acpi_rsdp)) == 0)
				return (ptr);
	}
	acpi_unmap(handle);

	return (NULL);
}

int
acpi_probe(struct device *parent, struct cfdata *match,
    struct bios_attach_args *ba)
{
	struct acpi_mem_map handle;
	u_int8_t *ptr;
	paddr_t ebda;

	/*
	 * First try to scan the ACPI table passed by parent if any
	 */
	if (ba->ba_acpipbase != 0) {
		if (acpi_scan(&handle, ba->ba_acpipbase, 16) != NULL) {
			acpi_unmap(&handle);
			return (1);
		}
		ba->ba_acpipbase = 0;
	}

	/*
	 * Next try to find ACPI table entries in the EBDA
	 */
	if (acpi_map(0, NBPG, &handle))
		printf("acpi: failed to map BIOS data area\n");
	else {
		ebda = *(const u_int16_t *)(&handle.va[0x40e]);
		ebda <<= 4;
		acpi_unmap(&handle);

		if (ebda && ebda < IOM_BEGIN) {
			if ((ptr = acpi_scan(&handle, ebda, 1024)))
				goto havebase;
		}
	}

	/*
	 * Next try to find the ACPI table entries in the
	 * BIOS memory
	 */
	if ((ptr = acpi_scan(&handle, ACPI_BIOS_RSDP_WINDOW_BASE,
	    ACPI_BIOS_RSDP_WINDOW_SIZE)))
		goto havebase;

	return (0);

havebase:
	ba->ba_acpipbase = ptr - handle.va + handle.pa;
	acpi_unmap(&handle);

	return (1);
}

/*
 * Acquire the global lock.  If busy, set the pending bit.  The caller
 * will wait for notification from the BIOS that the lock is available
 * and then attempt to acquire it again.
 */
int
acpi_acquire_glk(uint32_t *lock)
{
	uint32_t	new, old;

	do {
		old = *lock;
		new = (old & ~GL_BIT_PENDING) | GL_BIT_OWNED;
		if ((old & GL_BIT_OWNED) != 0)
			new |= GL_BIT_PENDING;
	} while (atomic_cas_uint(lock, old, new) != old);

	return ((new & GL_BIT_PENDING) == 0);
}

/*
 * Release the global lock, returning whether there is a waiter pending.
 * If the BIOS set the pending bit, OSPM must notify the BIOS when it
 * releases the lock.
 */
int
acpi_release_glk(uint32_t *lock)
{
	uint32_t	new, old;

	do {
		old = *lock;
		new = old & ~(GL_BIT_PENDING | GL_BIT_OWNED);
	} while (atomic_cas_uint(lock, old, new) != old);

	return ((old & GL_BIT_PENDING) != 0);
}

void
acpi_attach_machdep(struct acpi_softc *sc)
{
	extern void (*cpuresetfn)(void);

	sc->sc_interrupt = isa_intr_establish(NULL, sc->sc_fadt->sci_int,
	    IST_LEVEL, IPL_TTY, acpi_interrupt, sc, sc->sc_dev.dv_xname);
	cpuresetfn = acpi_reset;

#ifndef SMALL_KERNEL
	/*
	 * Sanity check before setting up trampoline.
	 * Ensure the trampoline page sizes are < PAGE_SIZE
	 */
	KASSERT(acpi_resume_end - acpi_real_mode_resume < PAGE_SIZE);
	KASSERT(acpi_tramp_data_end - acpi_tramp_data_start < PAGE_SIZE);

	/* Map ACPI tramp code and data pages RW for copy */
	pmap_kenter_pa(ACPI_TRAMPOLINE, ACPI_TRAMPOLINE,
	    PROT_READ | PROT_WRITE);
	pmap_kenter_pa(ACPI_TRAMP_DATA, ACPI_TRAMP_DATA,
	    PROT_READ | PROT_WRITE);

	/* Fill the trampoline pages with int3 */
	memset((caddr_t)ACPI_TRAMPOLINE, 0xcc, PAGE_SIZE);
	memset((caddr_t)ACPI_TRAMP_DATA, 0xcc, PAGE_SIZE);

	/* Copy over real trampoline pages (code and data) */
	memcpy((caddr_t)ACPI_TRAMPOLINE, acpi_real_mode_resume,
	    acpi_resume_end - acpi_real_mode_resume);
	memcpy((caddr_t)ACPI_TRAMP_DATA, acpi_tramp_data_start,
	    acpi_tramp_data_end - acpi_tramp_data_start);

	acpi_pdirpa = tramp_pdirpa;

	/* Unmap, will be remapped in acpi_sleep_cpu */
	pmap_kremove(ACPI_TRAMPOLINE, PAGE_SIZE);
	pmap_kremove(ACPI_TRAMP_DATA, PAGE_SIZE);
#endif /* SMALL_KERNEL */
}

#ifndef SMALL_KERNEL

void
acpi_sleep_clocks(struct acpi_softc *sc, int state)
{
	rtcstop();

#if NLAPIC > 0
	lapic_disable();
#endif
}

/*
 * We repair the interrupt hardware so that any events which occur
 * will cause the least number of unexpected side effects.  We re-start
 * the clocks early because we will soon run AML whigh might do DELAY.
 */ 
void
acpi_resume_clocks(struct acpi_softc *sc)
{
#if NISA > 0
	i8259_default_setup();
#endif
	intr_calculatemasks(curcpu());

#if NIOAPIC > 0
	ioapic_enable();
#endif

#if NLAPIC > 0
	lapic_enable();
	if (initclock_func == lapic_initclocks)
		lapic_startclock();
	lapic_set_lvt();
#endif

	i8254_startclock();
	if (initclock_func == i8254_initclocks)
		rtcstart();		/* in i8254 mode, rtc is profclock */
}

/*
 * This function may not have local variables due to a bug between
 * acpi_savecpu() and the resume path.
 */
int
acpi_sleep_cpu(struct acpi_softc *sc, int state)
{
	/*
	 * ACPI defines two wakeup vectors. One is used for ACPI 1.0
	 * implementations - it's in the FACS table as wakeup_vector and
	 * indicates a 32-bit physical address containing real-mode wakeup
	 * code.
	 *
	 * The second wakeup vector is in the FACS table as
	 * x_wakeup_vector and indicates a 64-bit physical address
	 * containing protected-mode wakeup code.
	 */
	sc->sc_facs->wakeup_vector = (u_int32_t)ACPI_TRAMPOLINE;
	if (sc->sc_facs->length > 32 && sc->sc_facs->version >= 1)
		sc->sc_facs->x_wakeup_vector = 0;

	/* Map trampoline and data page */
	pmap_kenter_pa(ACPI_TRAMPOLINE, ACPI_TRAMPOLINE, PROT_READ | PROT_EXEC);
	pmap_kenter_pa(ACPI_TRAMP_DATA, ACPI_TRAMP_DATA,
	    PROT_READ | PROT_WRITE);

	/*
	 * Copy the current cpu registers into a safe place for resume.
	 * acpi_savecpu actually returns twice - once in the suspend
	 * path and once in the resume path (see setjmp(3)).
	 */
	if (acpi_savecpu()) {
		/* Suspend path */
		fpusave_cpu(curcpu(), 1);
		wbinvd();

#ifdef HIBERNATE
		if (state == ACPI_STATE_S4) {
			if (hibernate_suspend()) {
				printf("%s: hibernate_suspend failed\n",
				    DEVNAME(sc));
				return (ECANCELED);
			}
		}
#endif

		/*
		 * XXX
		 * Flag to disk drivers that they should "power down" the disk
		 * when we get to DVACT_POWERDOWN.
		 */
		boothowto |= RB_POWERDOWN;
		config_suspend_all(DVACT_POWERDOWN);
		boothowto &= ~RB_POWERDOWN;

		acpi_sleep_pm(sc, state);
		printf("%s: acpi_sleep_pm failed", DEVNAME(sc));
		return (ECANCELED);
	}
	/* Resume path */

	/* Reset the vectors */
	sc->sc_facs->wakeup_vector = 0;
	if (sc->sc_facs->length > 32 && sc->sc_facs->version >= 1)
		sc->sc_facs->x_wakeup_vector = 0;

	pmap_kremove(ACPI_TRAMPOLINE, PAGE_SIZE);
	pmap_kremove(ACPI_TRAMP_DATA, PAGE_SIZE);

	return (0);
}

void
acpi_resume_cpu(struct acpi_softc *sc)
{
	fpuinit(&cpu_info_primary);

	cpu_init(&cpu_info_primary);

	/* Re-initialise memory range handling on BSP */
	if (mem_range_softc.mr_op != NULL)
		mem_range_softc.mr_op->initAP(&mem_range_softc);
}

#ifdef MULTIPROCESSOR
void
acpi_sleep_mp(void)
{
	int i;

	sched_stop_secondary_cpus();
	KASSERT(CPU_IS_PRIMARY(curcpu()));

	/* 
	 * Wait for cpus to halt so we know their FPU state has been
	 * saved and their caches have been written back.
	 */
	x86_broadcast_ipi(X86_IPI_HALT);
	for (i = 0; i < ncpus; i++) {
		struct cpu_info *ci = cpu_info[i];

		if (CPU_IS_PRIMARY(ci))
			continue;
		while (ci->ci_flags & CPUF_RUNNING)
			;
	}
}

void
acpi_resume_mp(void)
{
	void	cpu_start_secondary(struct cpu_info *ci);
	struct cpu_info *ci;
	struct proc *p;
	struct pcb *pcb;
	struct trapframe *tf;
	struct switchframe *sf;
	int i;

	/* XXX refactor with matching code in cpu.c */

	for (i = 0; i < MAXCPUS; i++) {
		ci = cpu_info[i];
		if (ci == NULL)
			continue;
		if (ci->ci_idle_pcb == NULL)
			continue;
		if (ci->ci_flags & (CPUF_BSP|CPUF_SP|CPUF_PRIMARY))
			continue;
		KASSERT((ci->ci_flags & CPUF_RUNNING) == 0);

		p = ci->ci_schedstate.spc_idleproc;
		pcb = &p->p_addr->u_pcb;

		tf = (struct trapframe *)pcb->pcb_kstack - 1;
		sf = (struct switchframe *)tf - 1;
		sf->sf_r12 = (u_int64_t)sched_idle;
		sf->sf_r13 = (u_int64_t)ci;
		sf->sf_rip = (u_int64_t)proc_trampoline;
		pcb->pcb_rsp = (u_int64_t)sf;
		pcb->pcb_rbp = 0;

		ci->ci_idepth = 0;
		ci->ci_handled_intr_level = IPL_NONE;

		ci->ci_flags &= ~CPUF_PRESENT;
		cpu_start_secondary(ci);
	}

	cpu_boot_secondary_processors();
	sched_start_secondary_cpus();
}
#endif /* MULTIPROCESSOR */

#endif /* ! SMALL_KERNEL */
@


1.77
log
@hibernate_free() should not be called from MD code, acpi_sleep_state()
unwinds that.  Upon hibernate fail, this was a collection of double-frees..
ok claudio mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.76 2016/07/15 22:05:40 tom Exp $	*/
d398 1
a398 1
				printf("%s: hibernate_suspend failed",
@


1.76
log
@Remove duplicate line in amd64/acpi_machdep.c

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.75 2016/05/18 04:42:49 mlarkin Exp $	*/
a399 1
				hibernate_free();
@


1.75
log
@
tabs vs spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.74 2016/05/18 04:33:01 mlarkin Exp $	*/
a131 1
	map->redir = (IOAPIC_REDLO_DEL_LOPRI << IOAPIC_REDLO_DEL_SHIFT);
@


1.74
log
@
add a check for the acpi trampoline data page to match the code check
already there.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.73 2016/05/16 01:19:27 mlarkin Exp $	*/
d384 1
a384 1
		PROT_READ | PROT_WRITE);
@


1.73
log
@
Use int3 padding instead of nop in the ACPI resume trampoline, as it is
certain no intentional nop sled is required here.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.72 2016/01/10 16:59:42 kettenis Exp $	*/
d290 1
a290 1
	 * Ensure the trampoline size is < PAGE_SIZE
d293 1
@


1.72
log
@Introduce acpi_intr_establish(9), an API to establish interrupt handlers for
"platform" devices that attach to acpi(4).

ok mlarkin@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.71 2015/08/30 10:05:09 yasuoka Exp $	*/
d300 5
@


1.71
log
@Modify kernel to prepare boot from UEFI.

- Add new boot arg "bios_efi_info_t" to pass the paramters from UEFI
- Make bios(4) and acpi(4) be able to probe with the parameters from
  UEFI
- Add efifb(8).  It uses the framebuffer from UEFI and it will work as
  a backend of wsdisplay(4) and wsfb (X11 video driver).  Disabled by
  the kernel config for this moment

input and ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.70 2015/03/16 20:31:47 deraadt Exp $	*/
d43 1
d50 1
d52 1
d101 54
@


1.70
log
@Reduce use of SMALL_KERNEL in acpi, bringing acpiec driver and more gpe
handling into RAMDISK.  This is now possible because the install media
has ample room.  The goal is to reduce special cases where we may be
skipping (unknown) important operations...
ok mlarkin kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.69 2015/03/14 03:38:46 jsg Exp $	*/
d140 12
a151 1
	 * First try to find ACPI table entries in the EBDA
@


1.69
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.68 2015/01/06 12:50:47 dlg Exp $	*/
a209 2
#ifndef SMALL_KERNEL

d219 1
d242 1
d244 2
@


1.68
log
@when we're entering an interrupt handler, record its ipl so splassert
can check if we're entering code we think should only be used from
lower ipls.

modelled a bit on how sparc64 does things.

with help from and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.67 2014/12/18 05:33:48 mlarkin Exp $	*/
a52 1
#include <machine/apicvar.h>
@


1.67
log
@
Unmap the MP hatch and ACPI resume trampolines when not in active use.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.66 2014/12/08 07:12:37 mlarkin Exp $	*/
d429 1
@


1.66
log
@
Split the ACPI resume trampoline into code and data, move the data page to
.rodata (kernel copies to the RW page), protect the code page with RX
permissions, protect the code page with RW permissions.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.65 2014/12/01 04:22:34 mlarkin Exp $	*/
d228 6
a235 3

	pmap_kenter_pa(ACPI_TRAMP_DATA, ACPI_TRAMP_DATA,
	    PROT_READ | PROT_WRITE);
d239 1
a239 3
	/* Remap trampoline code page RX */
	pmap_kenter_pa(ACPI_TRAMPOLINE, ACPI_TRAMPOLINE,
	    PROT_READ | PROT_EXEC);
d241 3
a243 1
	acpi_pdirpa = tramp_pdirpa;
d306 5
d351 3
@


1.65
log
@
Remove an old and superfluous comment, and fix some KNF style issues in
some other comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.64 2014/11/16 12:30:56 deraadt Exp $	*/
d59 1
d228 1
a228 1
	bcopy(acpi_real_mode_resume, (caddr_t)ACPI_TRAMPOLINE,
d230 9
@


1.64
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.63 2014/09/19 20:02:25 kettenis Exp $	*/
a278 2
	/* amd64 does not do lazy pmap_activate */

d293 2
a294 1
	/* Copy the current cpu registers into a safe place for resume.
d314 2
a315 1
		/* XXX
@


1.63
log
@Use config_suspend_all(9).
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.62 2014/07/16 07:42:50 mlarkin Exp $	*/
d85 1
a85 1
		pmap_kenter_pa(va, pgpa, VM_PROT_READ | VM_PROT_WRITE);
@


1.62
log
@

Reenable hibernate RLE support and flush+zero all memory after unpack.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.61 2014/06/08 17:53:14 daniel Exp $	*/
d320 1
a320 1
		config_suspend(device_mainbus(), DVACT_POWERDOWN);
@


1.61
log
@check both rsdp checksums in the case of rsdp revision >= 2.

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.60 2014/04/25 14:37:06 mlarkin Exp $	*/
a305 1
			uvm_pmr_zero_everything();
a309 1
				uvm_pmr_dirty_everything();
@


1.60
log
@

Defer the free of the hibernate structures until later, when it is safe to
do so.

Freeing the hibernate structures too early leads to inadvertent calls into
splx when we aren't ready for them yet. Found when trapping splx calls in
the resume path.

discussed with deraadt@@ at m2k14
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.59 2014/03/27 10:24:40 dlg Exp $	*/
d109 15
a123 11
	for (ptr = handle->va, i = 0;
	     i < len;
	     ptr += 16, i += 16)
		if (memcmp(ptr, RSDP_SIG, sizeof(RSDP_SIG) - 1) == 0) {
			rsdp = (struct acpi_rsdp1 *)ptr;
			/*
			 * Only checksum whichever portion of the
			 * RSDP that is actually present
			 */
			if (rsdp->revision == 0 &&
			    acpi_checksum(ptr, sizeof(struct acpi_rsdp1)) == 0)
d125 1
a125 4
			else if (rsdp->revision >= 2 && rsdp->revision <= 4 &&
			    acpi_checksum(ptr, sizeof(struct acpi_rsdp)) == 0)
				return (ptr);
		}
@


1.59
log
@replace x86_atomic_cas_things with atomic_cas_foo equivalents.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.58 2014/03/13 03:52:55 dlg Exp $	*/
a328 7

#ifdef HIBERNATE
	if (state == ACPI_STATE_S4) {
		hibernate_free();
		uvm_pmr_dirty_everything();
	}
#endif
@


1.58
log
@get rid of the assumption that the head of the alldevs list is the
"mainbus" device. this breaks when mpath is enabled because it
attaches before mainbus and therefore takes the head position.

have autoconf provide device_mainbus() which looks up mainbus_cd,
and use that instead.

discussed with deraadt who just wants mpath stuff to move forward
despite there being many ways to shine this particular turd.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.57 2014/01/21 09:40:54 kettenis Exp $	*/
d186 1
a186 1
	} while (x86_atomic_cas_int32(lock, old, new) != old);
d204 1
a204 1
	} while (x86_atomic_cas_int32(lock, old, new) != old);
@


1.57
log
@Disable lapic when halting CPUs.  Allegedly this is necessary to make
suspend work on some machines.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.56 2013/12/19 21:30:02 deraadt Exp $	*/
d321 1
a321 1
		config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.56
log
@Mtrr stops being a pseudo-device.  We need to probe the cpu type and
initialize the structures when we see the first cpu.  We also need to
initialize each cpu's properly (for PAT) before we setup mtrr on that
cpu.  On i386 (late hatch) we were getting this desperately wrong on
the primary cpu.

After suspend/resume, we also need to do the same work.  re-initialize
PAT before mtrr.  On some laptops apparently PAT was not turned on by the
BIOS, so we ended up with incorrect setup for the primary cpu.  Oops.

This makes mplayer on the x201 (and similar) machines work without weird
pauses after a suspend/resume.  Many other things are likely fixed.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.55 2013/07/01 10:08:08 kettenis Exp $	*/
d236 4
@


1.55
log
@Make the acpi global lock functions actually work.  Luckily these functions
were still unused.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.55 2013/07/01 09:35:58 kettenis Exp $	*/
d344 4
a350 1
	fpuinit(&cpu_info_primary);
@


1.54
log
@Previous commit to acpi_machdep.c broke suspend because the IPI to save the
FPU state needs a little bit more setup.  Fix things properly this time by
simplifying matters and saving the FPU state from the IPI that halts the
CPU.  With help from deraadt@@ and mlarkin@@.

ok deraadt@@, mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.53 2013/03/19 06:46:27 deraadt Exp $	*/
d186 1
a186 1
	} while (x86_atomic_cas_int32(lock, old, new) == 0);
d204 1
a204 1
	} while (x86_atomic_cas_int32(lock, old, new) == 0);
@


1.53
log
@in acpi_sleep_mp() properly flush fpu and halt the AP's
found when i told mlarkin to look at it for re-use in a different place
ok mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.52 2012/11/27 17:38:45 pirofti Exp $	*/
d359 4
a362 12
	/* Wait for cpus to save their floating point context */
	x86_broadcast_ipi(X86_IPI_SYNCH_FPU);
	for (i = 0; i < ncpus; i++) {
		struct cpu_info *ci = cpu_info[i];

		if (CPU_IS_PRIMARY(ci))
			continue;
		while (ci->ci_fpcurproc)
			;
	}

	/* Wait for cpus to halt so we know their caches are written back */
@


1.52
log
@Add acpi_{acquire,release}_glk locking functions.

These functions represent the basic blocks for using the ACPI global
lock that provides mutual exclusion between the OSPM and the BIOS.

No functional change. Okay kettenis@@, deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.51 2012/10/17 22:49:27 deraadt Exp $	*/
d364 3
a366 1
		while (!CPU_IS_PRIMARY(curcpu()) && ci->ci_fpcurproc)
d375 3
a377 2
		while (!CPU_IS_PRIMARY(curcpu()) &&
		    (ci->ci_flags & CPUF_RUNNING))
@


1.51
log
@Document the 'boothowto hack' used to flag to (a few) DVACT_POWERDOWN
handlers how hard they should hit the hardware.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.51 2012/10/17 22:43:50 deraadt Exp $	*/
d169 38
@


1.50
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.49 2012/07/13 16:02:24 mlarkin Exp $	*/
d274 4
@


1.49
log
@

extraneous comment (corresponding code was removed a while back)
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.48 2012/07/13 14:15:12 mlarkin Exp $	*/
d26 1
d195 1
a195 1
acpi_cpu_flush(struct acpi_softc *sc, int state)
d197 30
a226 5
	/*
	 * Flush write back caches since we'll lose them.
	 */
	if (state > ACPI_STATE_S1)
		wbinvd();
d229 4
d234 1
a234 1
acpi_sleep_machdep(struct acpi_softc *sc, int state)
d236 1
a236 6
	if (sc->sc_facs == NULL) {
		printf("%s: acpi_sleep_machdep: no FACS\n", DEVNAME(sc));
		return (ENXIO);
	}

	rtcstop();
a258 4
#ifdef MULTIPROCESSOR
		x86_broadcast_ipi(X86_IPI_SYNCH_FPU);
		x86_broadcast_ipi(X86_IPI_HALT);
#endif
d260 1
d264 7
a270 2
			if (hibernate_suspend())
				panic("%s: hibernate failed", DEVNAME(sc));
d273 8
a280 2
		acpi_enter_sleep_state(sc, state);
		panic("%s: acpi_enter_sleep_state failed", DEVNAME(sc));
d282 1
d284 6
a289 1
	/* Resume path continues here */
d291 1
a291 1
	/* Reset the vector */
d293 5
d299 8
a306 4
#if NISA > 0
	i8259_default_setup();
#endif
	intr_calculatemasks(curcpu());
d308 5
a312 6
#if NLAPIC > 0
	lapic_enable();
	if (initclock_func == lapic_initclocks)
		lapic_startclock();
	lapic_set_lvt();
#endif
d314 2
a315 1
	fpuinit(&cpu_info_primary);
d317 4
a320 3
	/* Re-initialise memory range handling */
	if (mem_range_softc.mr_op != NULL)
		mem_range_softc.mr_op->initAP(&mem_range_softc);
d322 3
a324 7
#if NIOAPIC > 0
	ioapic_enable();
#endif
	i8254_startclock();
	if (initclock_func == i8254_initclocks)
		rtcstart();		/* in i8254 mode, rtc is profclock */
	inittodr(time_second);
d326 9
a334 1
	return (0);
a336 2
void		cpu_start_secondary(struct cpu_info *ci);

d338 1
a338 1
acpi_resume_machdep(void)
d340 1
a340 1
#ifdef MULTIPROCESSOR
d378 2
d381 1
a381 1
}
@


1.48
log
@

Make amd64 like i386 for hibernate support in acpi_sleep_machdep

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.47 2010/11/13 04:16:42 guenther Exp $	*/
a211 2

	/* amd64 does not do lazy pmap_activate */
@


1.47
log
@Switch from TSS-per-process to TSS-per-CPU, placing the TSS right
next to the cpu's GDT, also making the double-fault stack per-CPU,
leaving it at the top of the page of the CPU's idle process.  Inline
pmap_activate() and pmap_deactivate() into the asm cpu_switchto
routine, adding a check for the new pmap already being marked as
active on the CPU.  Garbage collect the hasn't-been-used-in-years
GDT update IPI.

Tested by many; ok mikeb@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.46 2010/10/06 16:37:29 deraadt Exp $	*/
d26 1
d241 7
@


1.46
log
@Correct the condition under which the x_wakeup_vector is cleared.
ok mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.45 2010/08/11 21:22:44 kettenis Exp $	*/
d306 1
a306 1
		tf = (struct trapframe *)pcb->pcb_tss.tss_rsp0 - 1;
@


1.45
log
@Disable the RTC the periodic interrupt.  Leaving it enabled causes the
Dell Inspirion 4150 to wake up immediately even though RTC_EN isn't set
in the PM1 Enable register.

ok deraadt@@, mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.44 2010/08/08 21:23:42 deraadt Exp $	*/
a214 1
	 *
a222 1
	 *
d225 1
a225 1
	if (sc->sc_facs->version == 1)
@


1.44
log
@Accept "ACPI 4" or such, bug in laptop or spec? -- Thinkpad SL510
from marco, ok kettenis, hard to argue with it making the laptop work
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.43 2010/07/29 00:29:49 mlarkin Exp $	*/
d209 2
@


1.43
log
@

Zero out the firmware waking vector on successful resume from ACPI sleep.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.42 2010/07/27 16:53:11 deraadt Exp $	*/
d119 1
a119 1
			else if (rsdp->revision >= 2 && rsdp->revision <= 3 &&
@


1.42
log
@delete a #if 0 chunk which was used for early development and will never
be reused
ok jordan
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.41 2010/07/25 21:43:38 deraadt Exp $	*/
d245 3
@


1.41
log
@in the clock drivers, seperate the soft-state and hard-state which was
all jumbled up in the same functions. the rtc (mc chip) and clock (i8243)
startup was also mixed up.  they the soft state and hardware state can
be started in the right order, and it is easy to restart just the
neccessary parts upon resume.  tested in numerous cases:
(apic, pic) * (GENERIC.MP, GENERIC) * (mp, non-mp) * (i386, amd64)
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.40 2010/07/06 06:25:56 deraadt Exp $	*/
a244 5
#if 0
	/* Temporarily disabled for debugging purposes */
	/* Reset the wakeup vector to avoid resuming on reboot */
	sc->sc_facs->wakeup_vector = 0;
#endif
@


1.40
log
@get rid of ridiculous differences between the i386 and amd64 versions
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.39 2010/07/01 21:45:03 mlarkin Exp $	*/
d258 2
a259 1
	lapic_initclocks();
d272 3
a274 1
	initrtclock();
@


1.39
log
@

Synch instead of flush FPU state on APs before suspending.

tested by kettenis@@ on i386 and myself on amd64
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.38 2010/07/01 03:22:12 jsg Exp $	*/
d238 1
a238 1
#endif 
d277 1
a277 1
void    	cpu_start_secondary(struct cpu_info *ci);
d301 1
a301 1
		
@


1.38
log
@mark acpi_savecpu with the gcc returns_twice attribute as suggested
by deraadt so the stack will be sane during suspend/resume with gcc4.
Noticed on i386 due to the lack of general purpose registers compared
to amd64.

ok deraadt@@ mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.37 2010/07/01 00:48:48 mlarkin Exp $	*/
d236 1
a236 1
		x86_broadcast_ipi(X86_IPI_FLUSH_FPU);
@


1.37
log
@

More accurate comment as to what happens with acpi_savecpu

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.36 2010/06/26 04:05:32 mlarkin Exp $	*/
d60 1
a60 1
extern int acpi_savecpu(void);
@


1.36
log
@

Fix 100% interrupt usage on amd64 MP resume.

ok kettenis@@, pirofti@@, marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.35 2010/04/20 22:08:17 tedu Exp $	*/
d228 4
a231 1
	/* Copy the current cpu registers into a safe place for resume. */
d233 1
d243 2
@


1.35
log
@need proc.h before user.h
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.34 2010/04/07 06:33:06 kettenis Exp $	*/
d306 2
@


1.34
log
@Make suspend/resume work on MP machines (running an MP kernel).  Joint work
from mlarkin@@ and me, with some amd64 fixes thrown in by deraadt@@

ok marco@@, deraadt@@, pirofti@@, mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.33 2010/02/23 21:54:53 kettenis Exp $	*/
d24 1
@


1.33
log
@Restore MTRRs on resume.

ok oga@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.32 2009/11/29 21:21:06 deraadt Exp $	*/
d24 1
d32 1
d34 1
d230 4
d235 2
a236 2
		if (acpi_enter_sleep_state(sc, state) != 0)
			panic("%s: acpi_enter_sleep_state failed", DEVNAME(sc));
d270 43
@


1.32
log
@At suspend time there is no need for a fancy cr3 dance to decide if
pmap_activate() should be called to force the kthread into the kernel pmap.
If it is i386 it is lazy pmap it may not be in the kernel kthread, so
it must be called so that pmap_activate can decide.  If it is amd64
without lazy pmap, it must not be called.
A comment is added to remind us about this in the future in case these
assumptions change.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.31 2009/11/26 22:08:30 mlarkin Exp $	*/
d23 1
d249 4
@


1.31
log
@

Reset the wakeup vector to ensure that we don't resume on reboot.
Temporarily disabled for debugging purposes, but can be turned on if
needed.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.30 2009/11/26 11:49:49 deraadt Exp $	*/
d205 1
a205 5
	if (rcr3() != pmap_kernel()->pm_pdirpa) {
		pmap_activate(curproc);

		KASSERT(rcr3() == pmap_kernel()->pm_pdirpa);
	}
@


1.30
log
@knf relative to i386
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.29 2009/11/26 11:49:33 deraadt Exp $	*/
d234 5
@


1.29
log
@re-init the fpu like on i386
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.28 2009/11/26 11:49:07 deraadt Exp $	*/
a237 1

@


1.28
log
@Really want isa.h when using #ifdef NISA > 0
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.27 2009/11/26 00:14:11 mlarkin Exp $	*/
d246 3
@


1.27
log
@

Fix a stack problem on amd64, now the resume functions get called properly.
Tested mlarkin on thinkpad x60, pirofti on dell d620, and deraadt on
thinkpad T61.

ok deraadt@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.26 2009/11/24 17:39:59 mlarkin Exp $	*/
d37 1
@


1.26
log
@

Save FPU state before suspend.

ok deraadt@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.25 2009/11/23 16:21:54 pirofti Exp $	*/
d230 2
a231 2
		acpi_enter_sleep_state(sc, state);
		panic("%s: acpi_enter_sleep_state failed", DEVNAME(sc));
a232 9

	/*
	 * On resume, the execution path will actually occur here.
	 * This is because we previously saved the stack location
	 * in acpi_savecpu, and issued a far jmp to the restore
	 * routine in the wakeup code. This means we are
	 * returning to the location immediately following the
	 * last call instruction - after the call to acpi_savecpu.
	 */
@


1.25
log
@Remove ACPI_SLEEP_ENABLED checks.

This enables by default the suspend/resume paths in the kernel.

Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.24 2009/11/22 22:00:25 pirofti Exp $	*/
d228 1
@


1.24
log
@Check for ISA before calling the setup function.

Suggested by and okay mlarkin@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.23 2009/11/22 21:41:37 pirofti Exp $	*/
a173 1
#ifdef ACPI_SLEEP_ENABLED
a183 1
#endif /* ACPI_SLEEP_ENABLED */
a198 1
#ifdef ACPI_SLEEP_ENABLED
a257 1
#endif /* ACPI_SLEEP_ENABLED */
@


1.23
log
@Bring amd64 closer to resume, while at it kill dead code. Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.22 2009/08/13 15:33:20 kettenis Exp $	*/
d245 1
d247 2
@


1.22
log
@Cleanup differences between i386 and amd64.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.21 2009/06/06 00:23:38 mlarkin Exp $	*/
d245 3
d251 1
@


1.21
log
@
Matching fix for amd64. This also removes a spurious disable_intr() call
that wasn't needed.

ok pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.20 2009/06/04 23:32:06 mlarkin Exp $	*/
d30 2
d40 4
a54 1
extern void ioapic_enable(void);
d123 2
a124 1
acpi_probe(struct device *parent, struct cfdata *match, struct bios_attach_args *ba)
d164 1
a174 1

d181 1
a181 2
	bcopy(acpi_real_mode_resume, 
	    (caddr_t)ACPI_TRAMPOLINE, 
a184 1

d197 1
a201 1

d209 1
a209 1
		
a224 1

a254 2
	return 0;
 }
d256 2
@


1.20
log
@
Ensure we are sleeping from the kernel. Code changed to match i386.

ok art
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.19 2009/06/02 12:50:29 kurt Exp $	*/
d48 2
a49 3
int acpi_savecpu(void);
void ioapic_enable(void);
void lapic_enable(void);
a225 2
	disable_intr();

d244 1
a244 1
	lapic_calibrate_timer(&cpu_info_primary);
d250 1
a250 1
	enable_intr();
@


1.19
log
@Add a DIAGNOSTIC panic to ensure we are not running
via an interrupt handler in acpi_sleep_machdep.
okay mlarkin@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.18 2009/06/01 19:59:18 mlarkin Exp $	*/
a203 5
#ifdef DIAGNOSTIC
	if (curproc != &proc0)
		panic("acpi_sleep_machdep: sleeping in non-kernel proc");
#endif

d206 2
@


1.18
log
@
Use proper pmap during ACPI sleep on amd64. Original code by Kurt,
this version by Art.

additional ok by marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.17 2009/05/31 03:42:38 mlarkin Exp $	*/
d203 5
@


1.17
log
@Reinitialize lapic on ACPI resume.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.16 2009/02/19 21:02:05 marco Exp $	*/
d205 1
a205 3
		printf("%s: acpi_sleep_machdep: only kernel may sleep\n",
		    DEVNAME(sc));
		return (ENXIO);
@


1.16
log
@suspend/resume bits so that we can develop this in tree.  This is disabled.
code from mlarkin and me
help from art,toby,jordan and several others
ok jordan, go for it deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.15 2009/02/15 02:03:40 marco Exp $	*/
d36 7
d49 2
d245 7
@


1.15
log
@Add sleep plumbing code for amd64 making it the sameish as i386. Committing
per mlarkin request.

Code from mlarkin, mptramp code from kurt
Lots of comments weingart, art & others
Tested in snaps for weeks
ok kurt, marco
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.14 2008/12/28 22:27:10 kettenis Exp $	*/
d33 1
d175 68
@


1.14
log
@No longer look for RSDP in memory marked as "ACPI Reclaim" in the BIOS memory
map.  The standard doesn't tell us to look there, Linux and NetBSD don't look
there either. It seems that some BIOSes use this memory as a scratch area
to build the final ACPI tables which means we can accidentally find what
seems like a valid RSDP there.  Fixes PR 5847.

ok krw@@, marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.13 2008/06/01 17:59:55 marco Exp $	*/
d36 6
d157 16
d174 1
a174 1
#endif /* SMALL_KERNEL */
@


1.13
log
@Re-enable new parser.  Lots of testing by various folks.  Fits all media
now too.

ok kettenis deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.12 2008/02/05 22:00:54 marco Exp $	*/
a107 1
	bios_memmap_t *im;
d110 1
a110 10
	 * First look for ACPI entries in the BIOS memory map
	 */
	for (im = bios_memmap; im->type != BIOS_MAP_END; im++)
		if (im->type == BIOS_MAP_ACPI) {
			if ((ptr = acpi_scan(&handle, im->addr, im->size)))
				goto havebase;
		}

	/*
	 * Next try to find ACPI table entries in the EBDA
d126 1
a126 1
	 * Finally try to find the ACPI table entries in the
@


1.12
log
@ACPI 3.0 seems to work just fine so lets enable it.

Idea from fulvio ciriaco <oivulf@@gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.11 2007/12/05 19:17:13 deraadt Exp $	*/
d152 1
d162 1
@


1.11
log
@Hang acpi(4) below bios(4) instead of mainbus(4).  This lets us move acpi(4)
before pcibios(4), and then.... if acpi(4) attaches, skip pcibios(4) since
it messes the machines up.  Fixes claudio's HP dl320 G5, and almost assuredly
others.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.10 2007/11/25 09:11:12 jsg Exp $	*/
d93 1
a93 1
			else if (rsdp->revision == 2 &&
@


1.10
log
@When available and ACPI is enabled use the ACPI reset method
to reboot.  This is required for some quirky sis machines
and likely others to reboot.

Tested by many. 'commit early commit often' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.9 2007/11/16 02:45:56 deraadt Exp $	*/
d103 1
a103 1
acpi_probe(struct device *parent, struct cfdata *match, struct acpi_attach_args *aaa)
d146 1
a146 1
	aaa->aaa_pbase = ptr - handle.va + handle.pa;
d156 1
@


1.9
log
@do not make up a device name for interrupts.. give it the dv_xname
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.8 2007/11/15 22:19:14 deraadt Exp $	*/
d155 1
d158 1
@


1.8
log
@remove the #ifdef ACPI_ENABLE.  the EC codepath is either safe enough (and
will be improved), or it is unsafe because AML assumes it must be there
ok almost everyone
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.7 2007/11/12 20:58:12 kettenis Exp $	*/
d156 1
a156 1
	    IST_LEVEL, IPL_TTY, acpi_interrupt, sc, "acpi");
@


1.7
log
@Use isa_intr_establish() to establish the SCI interrupt handler; this makes
sure that interrupt overrides from the MADT are applied.

ok marco@@, toby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.6 2007/02/22 07:39:55 jordan Exp $	*/
a154 1
#ifdef ACPI_ENABLE
a156 1
#endif
@


1.6
log
@Enable ACPI interrupts in APIC mode
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.5 2006/11/29 11:57:27 kettenis Exp $	*/
d28 1
a35 5
#if NIOAPIC > 0
#include <machine/i82093var.h>
#include <machine/mpbiosvar.h>
#endif

d156 2
a157 16
	struct pic *pic;
	int pin;
	int irq;

	pic = &i8259_pic;
	pin = sc->sc_fadt->sci_int;
	irq = sc->sc_fadt->sci_int;
#if NIOAPIC > 0
	pic = (struct pic *)ioapic_find_bybase(sc->sc_fadt->sci_int);
	if (pic == NULL) {
		printf("error: can't establish ACPI interrupt!\n");
		return;
	}
#endif
	sc->sc_interrupt = intr_establish(irq, pic, pin, IST_LEVEL, IPL_TTY, 
	    acpi_interrupt, sc, "acpi");
@


1.5
log
@Only establish acpi interrupt if ACPI_ENABLE.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.4 2006/02/20 05:16:20 marco Exp $	*/
d33 7
d160 16
a175 3
	sc->sc_interrupt = intr_establish(sc->sc_fadt->sci_int, &i8259_pic,
	    sc->sc_fadt->sci_int, IST_LEVEL, IPL_TTY, acpi_interrupt, sc,
	    "acpi");
@


1.4
log
@Region has to be read and write not just read.
ok jordan

Pointed out by Bjorn Andersson <bjorn at silversmedjan dot se>
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.3 2005/12/16 20:41:50 marco Exp $	*/
d152 1
d156 1
@


1.3
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.2 2005/10/21 18:55:00 martin Exp $	*/
d54 1
a54 1
		pmap_kenter_pa(va, pgpa, VM_PROT_READ);
@


1.2
log
@use the MI trunc_page() and round_page() macros instead of rolling or own

ok weingart@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.1 2005/06/02 20:09:38 tholo Exp $	*/
d152 3
a154 2
	sc->sc_interrupt = intr_establish(sc->sc_fadt->sci_int, &i8259_pic, sc->sc_fadt->sci_int,
					  IST_LEVEL, IPL_TTY, acpi_interrupt, sc, "acpi");
@


1.1
log
@Start on a basic ACPI framework -- does not do much more than read out the
ACPI tables into kernel memory and attach ACPI and HPET timers currently.

In order to test this code, enabling the devices in GENERIC as well as
the ACPI_ENABLE option is needed.  This code does not do any thermal
control yet, so this should be done with care depending on the platform.

In the tree so more people can contribute to making this more fully
featured.

Ok niklas@@ grange@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d41 2
a42 2
	paddr_t pgpa = x86_trunc_page(pa);
	paddr_t endpa = x86_round_page(pa + len);
@

