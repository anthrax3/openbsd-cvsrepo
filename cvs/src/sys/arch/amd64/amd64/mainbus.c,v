head	1.39;
access;
symbols
	OPENBSD_6_2:1.39.0.6
	OPENBSD_6_2_BASE:1.39
	OPENBSD_6_1:1.39.0.4
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.37.0.2
	OPENBSD_6_0_BASE:1.37
	OPENBSD_5_9:1.36.0.2
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.30.0.4
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.27.0.4
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.27.0.8
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.27.0.6
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.27.0.2
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.26.0.2
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.24.0.4
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.2
	OPENBSD_5_0:1.23.0.4
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.2
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.22.0.4
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.19.0.4
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.16.0.2
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.14.0.4
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.2
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.12.0.2
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.11.0.2
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.4.0.4
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.2.0.2
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.1.0.8
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.6
	OPENBSD_3_6_BASE:1.1
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	OPENBSD_3_5:1.1.0.4
	OPENBSD_3_5_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.39
date	2017.03.25.22.24.01;	author deraadt;	state Exp;
branches;
next	1.38;
commitid	0BdiEUSnzOoly0V9;

1.38
date	2016.07.28.21.57.57;	author kettenis;	state Exp;
branches;
next	1.37;
commitid	h0GHFDGWnEdswfbK;

1.37
date	2016.06.21.15.24.55;	author jcs;	state Exp;
branches;
next	1.36;
commitid	RnGuu1BeGyvYHPrZ;

1.36
date	2015.12.12.12.33.49;	author reyk;	state Exp;
branches;
next	1.35;
commitid	BGb3xaQZJ9ACCtNF;

1.35
date	2015.11.23.22.57.12;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	lOkXFQaUGdej50W4;

1.34
date	2015.11.13.07.52.20;	author mlarkin;	state Exp;
branches;
next	1.33;
commitid	KdsjYlqLpqhwOUHf;

1.33
date	2015.08.31.19.56.32;	author kettenis;	state Exp;
branches;
next	1.32;
commitid	bQYNf2dfjwCUc5w2;

1.32
date	2015.08.30.18.08.24;	author kettenis;	state Exp;
branches;
next	1.31;
commitid	zhpP91Q5InJeqPgl;

1.31
date	2015.08.30.10.05.09;	author yasuoka;	state Exp;
branches;
next	1.30;
commitid	8KYmU15QlyhusRif;

1.30
date	2015.07.21.20.12.00;	author reyk;	state Exp;
branches;
next	1.29;
commitid	Icn4Maik5XtDk9KR;

1.29
date	2015.07.21.03.38.22;	author reyk;	state Exp;
branches;
next	1.28;
commitid	t8p39jbat5DBrbFu;

1.28
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.27;
commitid	p4LJxGKbi0BU2cG6;

1.27
date	2013.05.30.16.15.01;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2012.10.04.08.32.20;	author ehrhardt;	state Exp;
branches;
next	1.25;

1.25
date	2012.09.19.23.23.50;	author kettenis;	state Exp;
branches;
next	1.24;

1.24
date	2011.10.21.20.48.11;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2010.11.03.10.15.22;	author dlg;	state Exp;
branches;
next	1.22;

1.22
date	2009.12.28.14.22.09;	author dlg;	state Exp;
branches;
next	1.21;

1.21
date	2009.11.23.15.34.48;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2009.11.23.15.21.05;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2009.04.21.19.18.09;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2009.04.11.17.13.33;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2009.03.31.22.19.57;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2009.01.13.13.53.50;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2008.12.21.18.49.45;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2007.12.05.19.17.14;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2007.11.16.16.16.07;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2007.05.06.03.37.08;	author gwk;	state Exp;
branches;
next	1.11;

1.11
date	2006.12.14.17.36.12;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2006.11.25.16.59.31;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	2006.11.17.20.55.47;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.08.22.51.17;	author gwk;	state Exp;
branches;
next	1.7;

1.7
date	2006.04.14.21.33.56;	author marco;	state Exp;
branches;
next	1.6;

1.6
date	2006.03.13.20.10.49;	author brad;	state Exp;
branches;
next	1.5;

1.5
date	2006.03.13.15.57.18;	author marco;	state Exp;
branches;
next	1.4;

1.4
date	2005.12.29.00.50.43;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.19.01.41.44;	author marco;	state Exp;
branches;
next	1.2;

1.2
date	2005.06.02.20.09.38;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.28.01.39.39;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.39
log
@Split vmm_probe() into a vmm_enabled() function, to better follow the
probe/attach approach used by mainbus.
ok mlarkin kettenis
@
text
@/*	$OpenBSD: mainbus.c,v 1.38 2016/07/28 21:57:57 kettenis Exp $	*/
/*	$NetBSD: mainbus.c,v 1.1 2003/04/26 18:39:29 fvdl Exp $	*/

/*
 * Copyright (c) 1996 Christopher G. Demetriou.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christopher G. Demetriou
 *	for the NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>

#include <machine/bus.h>
#include <machine/specialreg.h>

#include <dev/isa/isavar.h>
#include <dev/pci/pcivar.h>

#include <dev/isa/isareg.h>

#include "pci.h"
#include "isa.h"
#include "acpi.h"
#include "ipmi.h"
#include "bios.h"
#include "mpbios.h"
#include "vmm.h"
#include "pvbus.h"
#include "efifb.h"

#include <machine/cpuvar.h>
#include <machine/i82093var.h>

#include <dev/acpi/acpivar.h>

#if NIPMI > 0
#include <dev/ipmivar.h>
#endif

#if NPVBUS > 0
#include <dev/pv/pvvar.h>
#endif

#if NBIOS > 0
#include <machine/biosvar.h>
#endif

#if NEFIFB > 0
#include <machine/efifbvar.h>
#endif

int	mainbus_match(struct device *, void *, void *);
void	mainbus_attach(struct device *, struct device *, void *);

struct cfattach mainbus_ca = {
	sizeof(struct device), mainbus_match, mainbus_attach
};

struct cfdriver mainbus_cd = {
	NULL, "mainbus", DV_DULL
};

int	mainbus_print(void *, const char *);

union mainbus_attach_args {
	const char *mba_busname;		/* first elem of all */
	struct pcibus_attach_args mba_pba;
	struct isabus_attach_args mba_iba;
	struct cpu_attach_args mba_caa;
	struct apic_attach_args aaa_caa;
#if NIPMI > 0
	struct ipmi_attach_args mba_iaa;
#endif
#if NBIOS > 0
	struct bios_attach_args mba_bios;
#endif
#if NPVBUS > 0
	struct pvbus_attach_args mba_pvba;
#endif
#if NEFIFB > 0
	struct efifb_attach_args mba_eaa;
#endif
};

/*
 * This is set when the ISA bus is attached.  If it's not set by the
 * time it's checked below, then mainbus attempts to attach an ISA.
 */
int	isa_has_been_seen;
#if NISA > 0
struct isabus_attach_args mba_iba = {
	"isa",
	X86_BUS_SPACE_IO, X86_BUS_SPACE_MEM,
#if NISADMA > 0
	&isa_bus_dma_tag
#else
	NULL
#endif
};
#endif

#if NMPBIOS > 0 || NACPI > 0
struct mp_bus *mp_busses;
int mp_nbusses;
struct mp_intr_map *mp_intrs;
int mp_nintrs;

struct mp_bus *mp_isa_bus;
struct mp_bus *mp_eisa_bus;

#ifdef MPVERBOSE
int mp_verbose = 1;
#else
int mp_verbose = 0;
#endif
#endif


/*
 * Probe for the mainbus; always succeeds.
 */
int
mainbus_match(struct device *parent, void *match, void *aux)
{
	return (1);
}

/*
 * Attach the mainbus.
 */
void
mainbus_attach(struct device *parent, struct device *self, void *aux)
{
#if NPCI > 0
	union mainbus_attach_args	mba;
#endif
#if NVMM > 0
	extern int vmm_enabled(void);
#endif
	extern void			(*setperf_setup)(struct cpu_info *);

	printf("\n");

#if NPVBUS > 0
	/* Detect hypervisors early, attach the paravirtual bus later */
	if (cpu_ecxfeature & CPUIDECX_HV)
		pvbus_identify();
#endif

#if NBIOS > 0
	{
		mba.mba_bios.ba_name = "bios";
		mba.mba_bios.ba_iot = X86_BUS_SPACE_IO;
		mba.mba_bios.ba_memt = X86_BUS_SPACE_MEM;
		config_found(self, &mba.mba_bios, mainbus_print);
	}
#endif

#if NIPMI > 0
	{
		memset(&mba.mba_iaa, 0, sizeof(mba.mba_iaa));
		mba.mba_iaa.iaa_name = "ipmi";
		mba.mba_iaa.iaa_iot  = X86_BUS_SPACE_IO;
		mba.mba_iaa.iaa_memt = X86_BUS_SPACE_MEM;
		if (ipmi_probe(&mba.mba_iaa))
			config_found(self, &mba.mba_iaa, mainbus_print);
	}
#endif

	if ((cpu_info_primary.ci_flags & CPUF_PRESENT) == 0) {
		struct cpu_attach_args caa;

		memset(&caa, 0, sizeof(caa));
		caa.caa_name = "cpu";
		caa.cpu_role = CPU_ROLE_SP;

		config_found(self, &caa, mainbus_print);
	}

#if NACPI > 0
	if (!acpi_hasprocfvs)
#endif
	{
		if (setperf_setup != NULL)
			setperf_setup(&cpu_info_primary);
	}

#ifdef MULTIPROCESSOR
	mp_setperf_init();
#endif

#if NPVBUS > 0
	/* Probe first to hide the "not configured" message */
	if (pvbus_probe()) {
		mba.mba_pvba.pvba_busname = "pvbus";
		config_found(self, &mba.mba_pvba.pvba_busname, mainbus_print);
	}
#endif

#if NPCI > 0
	{
		pci_init_extents();

		bzero(&mba.mba_pba, sizeof(mba.mba_pba));
		mba.mba_pba.pba_busname = "pci";
		mba.mba_pba.pba_iot = X86_BUS_SPACE_IO;
		mba.mba_pba.pba_memt = X86_BUS_SPACE_MEM;
		mba.mba_pba.pba_dmat = &pci_bus_dma_tag;
		mba.mba_pba.pba_ioex = pciio_ex;
		mba.mba_pba.pba_memex = pcimem_ex;
		mba.mba_pba.pba_busex = pcibus_ex;
		mba.mba_pba.pba_domain = pci_ndomains++;
		mba.mba_pba.pba_bus = 0;
		config_found(self, &mba.mba_pba, mainbus_print);
#if NACPI > 0
		acpi_pciroots_attach(self, &mba.mba_pba, mainbus_print);
#endif
	}
#endif

#if NISA > 0
	if (isa_has_been_seen == 0)
		config_found(self, &mba_iba, mainbus_print);
#endif

#if NVMM > 0
	if (vmm_enabled()) {
		mba.mba_busname = "vmm";
		config_found(self, &mba.mba_busname, mainbus_print);
	}
#endif /* NVMM > 0 */

#if NEFIFB > 0
	if (bios_efiinfo != NULL || efifb_cb_found()) {
		mba.mba_eaa.eaa_name = "efifb";
		config_found(self, &mba, mainbus_print);
	}
#endif
}

int
mainbus_print(void *aux, const char *pnp)
{
	union mainbus_attach_args	*mba = aux;

	if (pnp)
		printf("%s at %s", mba->mba_busname, pnp);
	if (strcmp(mba->mba_busname, "pci") == 0)
		printf(" bus %d", mba->mba_pba.pba_bus);

	return (UNCONF);
}
@


1.38
log
@Store the acpi processor ID/UID in struct cpu_info, and use it to attach
acpicpu(4) drivers to the right cpu(4).

ok mlarkin@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.37 2016/06/21 15:24:55 jcs Exp $	*/
d162 3
d252 4
a255 2
	mba.mba_busname = "vmm";
	config_found(self, &mba.mba_busname, mainbus_print);
@


1.37
log
@add support to efifb for drawing a console on a coreboot framebuffer
if coreboot's memory table is found, it has a framebuffer entry, and
there is no previously attached efi, vga, or serial console.

useful on chromebooks that have no legacy vga device to get an early
console before inteldrm(4) attaches or, for newer chipsets, a full
console and X with wsfb(4).

ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.36 2015/12/12 12:33:49 reyk Exp $	*/
a196 1
		caa.cpu_number = 0;
a197 1
		caa.cpu_func = 0;
@


1.36
log
@Identify hypervisors before configuring other children of the mainbus
(bios, CPU, interrupt handlers, pvbus).  This splits the pvbus attach
function into two parts: pvbus_identify() to scan the CPUID registers
for supported hypervisors and pvbus_attach() to attach the bus, print
information, and configure the children.

This will be needed for Xen and KVM, as discussed with mikeb@@ and sf@@
OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.35 2015/11/23 22:57:12 deraadt Exp $	*/
d256 1
a256 1
	if (bios_efiinfo != NULL) {
@


1.35
log
@No longer need 'option VMM', declaring the vmm0 device is sufficient.
ok mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.34 2015/11/13 07:52:20 mlarkin Exp $	*/
d39 1
d165 6
@


1.34
log
@
vmm(4) kernel code

circulated on hackers@@, no objections. Disabled by default.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.33 2015/08/31 19:56:32 kettenis Exp $	*/
d243 1
a243 1
#ifdef VMM
d246 1
a246 1
#endif /* VMM */
@


1.33
log
@Check driver name in match function such that driver only attempts to attach
when we actually want it to.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.32 2015/08/30 18:08:24 kettenis Exp $	*/
d51 1
d242 5
@


1.32
log
@Don't try to attach efifb(4) on non-UEFI boots.

ok miod@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.31 2015/08/30 10:05:09 yasuoka Exp $	*/
d71 4
d103 3
d244 1
a244 1
		mba.mba_busname = "efifb";
@


1.31
log
@Modify kernel to prepare boot from UEFI.

- Add new boot arg "bios_efi_info_t" to pass the paramters from UEFI
- Make bios(4) and acpi(4) be able to probe with the parameters from
  UEFI
- Add efifb(8).  It uses the framebuffer from UEFI and it will work as
  a backend of wsdisplay(4) and wsfb (X11 video driver).  Disabled by
  the kernel config for this moment

input and ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.30 2015/07/21 20:12:00 reyk Exp $	*/
d234 1
d236 4
a239 2
	mba.mba_busname = "efifb";
	config_found(self, &mba, mainbus_print);
a240 1

@


1.30
log
@pvbus(4) was attaching too early, it has to wait for identifycpu.
Problem found on GENERIC by mlarkin.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.29 2015/07/21 03:38:22 reyk Exp $	*/
d52 1
d233 4
@


1.29
log
@Add pvbus(4), a pseudo-bus to attach non-PCI paravirtual devices and buses.
vmt(4) is moved from mainbus0 to pvbus0, more devices will follow.

OK sf@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.28 2015/03/14 03:38:46 jsg Exp $	*/
a175 8
#if NPVBUS > 0
	/* Probe first to hide the "not configured" message */
	if (pvbus_probe()) {
		mba.mba_pvba.pvba_busname = "pvbus";
		config_found(self, &mba.mba_pvba.pvba_busname, mainbus_print);
	}
#endif

d198 8
@


1.28
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.27 2013/05/30 16:15:01 deraadt Exp $	*/
d51 1
a51 1
#include "vmt.h"
d62 2
a63 2
#if NVMT > 0
#include <dev/vmtvar.h>
d95 3
d176 5
a180 4
#if NVMT > 0
	if (vmt_probe()) {
		mba.mba_busname = "vmt";
		config_found(self, &mba.mba_busname, mainbus_print);
@


1.27
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.26 2012/10/04 08:32:20 ehrhardt Exp $	*/
a55 1
#include <dev/acpi/acpireg.h>
@


1.26
log
@Use information provided by ACPI to attach secondary PCI host bridges.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.25 2012/09/19 23:23:50 kettenis Exp $	*/
d75 1
a75 2
	sizeof(struct device), mainbus_match, mainbus_attach, NULL,
	config_activate_children
@


1.25
log
@Set up PCI bus number resource accounting for the main PCI bus hierarchy.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.24 2011/10/21 20:48:11 kettenis Exp $	*/
d221 3
@


1.24
log
@Add bounds checks for access to mp_busses.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.23 2010/11/03 10:15:22 dlg Exp $	*/
d217 1
@


1.23
log
@only let vmt match and therefore attach if mainbus is specifically asking
for vmt to attach after vmt_probe succeeds. this prevents vmt from
appearing at other attach points hanging off mainbus.

found by phessler@@ and debugged gently by claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.22 2009/12/28 14:22:09 dlg Exp $	*/
d118 1
a118 1
int mp_nbus;
@


1.22
log
@tweak vmt to work on amd64 as well as i386. like i386, it is still
commented out in GENERIC. it needs more love.

diff by david cranshaw a long time ago. sorry it has taken so long
for me to look at it.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.21 2009/11/23 15:34:48 deraadt Exp $	*/
d177 1
a177 1
		mba.mba_busname = "vmware";
@


1.21
log
@oops, call config_activate_children
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.20 2009/11/23 15:21:05 deraadt Exp $	*/
d51 1
d63 4
d172 7
@


1.20
log
@Use config_activate_children() for our cf_activate function
ok mlarkin pirofti
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.19 2009/04/21 19:18:09 kettenis Exp $	*/
d71 1
a71 1
	config_suspend_children
@


1.19
log
@Simplify PCI config space access code.  There is no way we're ever going to
see the ancient mode 2 on machines capable of running OpenBSD/amd64.

ok deraadt@@, toby@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.18 2009/04/11 17:13:33 kettenis Exp $	*/
d70 2
a71 1
	sizeof(struct device), mainbus_match, mainbus_attach
@


1.18
log
@Create extents for resource accounting on the root PCI bus and populate them
based on the BIOS memory map.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.17 2009/03/31 22:19:57 kettenis Exp $	*/
a148 4
#if NPCI > 0
	pci_mode = pci_mode_detect();
#endif

d194 1
a194 1
	if (pci_mode != 0) {
@


1.17
log
@bzero pci attach args
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.16 2009/01/13 13:53:50 kettenis Exp $	*/
d199 2
d206 2
@


1.16
log
@Turn mpbios into a real device, such that people can disable it on crappy
BIOSes.

ok deraadt@@ (for the amd64 bit, or the i386 bit, can't remember which)
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.15 2008/12/21 18:49:45 kettenis Exp $	*/
d199 1
a205 2
		mba.mba_pba.pba_bridgetag = NULL;
		mba.mba_pba.pba_pc = NULL;
@


1.15
log
@Change the way we include mpbios code to be similar to what we do on i386.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.14 2007/12/05 19:17:14 deraadt Exp $	*/
a53 1
#include <machine/mpbiosvar.h>
a170 5
#endif

#if NMPBIOS > 0
	if (mpbios_probe(self))
		mpbios_scan(self);
@


1.14
log
@Hang acpi(4) below bios(4) instead of mainbus(4).  This lets us move acpi(4)
before pcibios(4), and then.... if acpi(4) attaches, skip pcibios(4) since
it messes the machines up.  Fixes claudio's HP dl320 G5, and almost assuredly
others.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.13 2007/11/16 16:16:07 deraadt Exp $	*/
d50 1
d111 1
a111 1
#if defined(MPBIOS) || defined(MPACPI)
a145 3
#ifdef MPBIOS
	int				mpbios_present = 0;
#endif
d174 2
a175 6
#ifdef MPBIOS
	mpbios_present = mpbios_probe(self);
#endif

#ifdef MPBIOS
	if (mpbios_present)
a176 1
	else
@


1.13
log
@fix the bus_space #define nightmare, so that amd64 and i386 are much more
uniform. as a result shared code like acpi needs less #ifdef's
ok marco kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.12 2007/05/06 03:37:08 gwk Exp $	*/
a54 1
#if NACPI > 0
a56 1
#endif
a84 3
#if NACPI > 0
	struct acpi_attach_args mba_aaa;
#endif
d158 3
a160 3
		mba.mba_bios.bios_dev = "bios";
		mba.mba_bios.bios_iot = X86_BUS_SPACE_IO;
		mba.mba_bios.bios_memt = X86_BUS_SPACE_MEM;
a161 14
	}
#endif

#if NACPI > 0
#if NPCI > 0
	if (pci_mode != 0)
#endif
	{
		memset(&mba.mba_aaa, 0, sizeof(mba.mba_aaa));
		mba.mba_aaa.aaa_name = "acpi";
		mba.mba_aaa.aaa_iot = X86_BUS_SPACE_IO;
		mba.mba_aaa.aaa_memt = X86_BUS_SPACE_MEM;

		config_found(self, &mba.mba_aaa, mainbus_print);
@


1.12
log
@Add the mp setperf mechanism to AMD64, like its i386 counterpart it allows
all cpus in a system supporting frequency and voltage scaling to be scaled
by the same amount corresponding to the user (or apmd on their behalf)
performance level.

This diff also teaches amd64 about acpi_hasprocfvs (ACPI has processor
frequency and voltage scaling).

It also moves initilization of the underlying setperf mechanism such
as powernow to mainbus from the cpu indentification and initilization
code inspired by similar changes dim@@ made to i386 durring h2k6. This
is necessary to implement the AMD recommended method for retreiving
p_state data from the ACPI _PSS object (a diff comming soon). It will
also simplify the potential addition of enhanced speedstep as found
on newer intel processors with EMT64 capable of running OpenBSD/amd64.

MP setperf functionality verifed by myself and Johan M:son Lindman <tybolt
AT solace DOT miun DOT se> on opteron 265 and 270 systems respectively.
General testing done by many others thanks!

ok tedu, dim
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.11 2006/12/14 17:36:12 kettenis Exp $	*/
d119 1
a119 1
int mp_nintr;
@


1.11
log
@Make pci subsystem aware of domains.  Each host bridge gets assigned a unique
domain number such that we can distinguish between busses with the same bus
number that are behind different host bridges.  Domains can be accessed by
using different device nodes.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.10 2006/11/25 16:59:31 niklas Exp $	*/
d89 1
a89 1
#endif	
d120 1
a120 1
 
d153 1
d207 1
a207 1
                        
d213 1
a213 1
                        
d216 12
@


1.10
log
@sync amd64 to i386 w.r.t. acpi support. Also fix interrupt routing for multi-ioapic systems.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.9 2006/11/17 20:55:47 kettenis Exp $	*/
d222 1
@


1.9
log
@Decide whether we need to attach the primary cpu by checking the CPUF_PRESENT
flag just like we do on i386.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.8 2006/05/08 22:51:17 gwk Exp $	*/
d121 2
a122 2
int mp_isa_bus = -1;
int mp_eisa_bus = -1;
@


1.8
log
@Add smbios support for i386 and amd64, fix ipmi to use this new functionallity,
hook up some sysctls to add system vendor/product/version and UUID reporting.

"get it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.7 2006/04/14 21:33:56 marco Exp $	*/
d203 2
a204 1
	{
@


1.7
log
@ANSIfy functions.
Spacing.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.6 2006/03/13 20:10:49 brad Exp $	*/
d49 1
d64 4
d93 3
d158 9
@


1.6
log
@* Add "pcitag_t *pba_bridgetag" to pci_attach_args.  This is set to
  NULL for root PCI busses.  For busses behind a bridge, it points to
  a persistent copy of the bridge's pcitag_t.  This can be very useful
  for machine-dependent PCI bus enumeration code.

From NetBSD

ok grange@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.5 2006/03/13 15:57:18 marco Exp $	*/
d130 1
a130 2

	return 1;
d137 1
a137 3
mainbus_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d140 1
a140 1
	union mainbus_attach_args mba;
d143 1
a143 1
	int mpbios_present = 0;
d219 1
a219 3
mainbus_print(aux, pnp)
	void *aux;
	const char *pnp;
d221 1
a221 1
	union mainbus_attach_args *mba = aux;
d227 1
@


1.5
log
@Fix machines that need PCI access during ACPI bringup.

Help and ok kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.4 2005/12/29 00:50:43 kettenis Exp $	*/
d208 1
@


1.4
log
@Fix isadma0 at isa0 at mainbus0
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.3 2005/10/19 01:41:44 marco Exp $	*/
d151 4
d156 3
a181 4
#endif

#if NPCI > 0
	pci_mode = pci_mode_detect();
@


1.3
log
@Add IPMI to amd64.  Keep it disabled for now.

Prodded earlier today by deraadt@@
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.2 2005/06/02 20:09:38 tholo Exp $	*/
d99 5
a103 1
	NULL,
@


1.2
log
@Start on a basic ACPI framework -- does not do much more than read out the
ACPI tables into kernel memory and attach ACPI and HPET timers currently.

In order to test this code, enabling the devices in GENERIC as well as
the ACPI_ENABLE option is needed.  This code does not do any thermal
control yet, so this should be done with care depending on the platform.

In the tree so more people can contribute to making this more fully
featured.

Ok niklas@@ grange@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.1 2004/01/28 01:39:39 mickey Exp $	*/
d48 1
d59 4
d85 3
d155 11
@


1.1
log
@an amd64 arch support.
hacked by art@@ from netbsd sources and then later debugged
by me into the shape where it can host itself.
no bootloader yet as needs redoing from the
recent advanced i386 sources (anyone? ;)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d47 1
d53 4
a56 3
/*
 * XXXfvdl ACPI
 */
d77 3
d138 11
@

