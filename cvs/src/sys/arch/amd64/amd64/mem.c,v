head	1.31;
access;
symbols
	OPENBSD_6_1:1.31.0.4
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.28.0.4
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.28.0.2
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.25.0.4
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.17.0.4
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.15.0.12
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.10
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.8
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.6
	OPENBSD_5_0:1.15.0.4
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.2
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.14.0.8
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.4
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.6
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.9.0.2
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.6.0.4
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.2
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.4
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.4.0.2
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.3.0.4
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	SMP_SYNC_A:1.2
	SMP_SYNC_B:1.2
	OPENBSD_3_5:1.2.0.2
	OPENBSD_3_5_BASE:1.2
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.31
date	2016.09.25.15.23.36;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	YxqfPf79WCjoxCH9;

1.30
date	2016.08.15.22.01.59;	author tedu;	state Exp;
branches;
next	1.29;
commitid	hzJmUc5FH2irhNvz;

1.29
date	2016.07.27.21.13.39;	author tedu;	state Exp;
branches;
next	1.28;
commitid	UeBa4IIp6ZK9aoH3;

1.28
date	2015.09.08.04.28.34;	author semarie;	state Exp;
branches;
next	1.27;
commitid	Ajpcv6B3UUP5Q4Cd;

1.27
date	2015.08.29.12.30.30;	author sthen;	state Exp;
branches;
next	1.26;
commitid	7VcfS2bfcEZUrClV;

1.26
date	2015.08.28.00.03.53;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	NdgfPIGUgJxQPnT7;

1.25
date	2015.06.22.18.57.26;	author kettenis;	state Exp;
branches;
next	1.24;
commitid	E55PWdSNtZj8bfyG;

1.24
date	2015.05.28.20.53.05;	author jcs;	state Exp;
branches;
next	1.23;
commitid	mm0ThjDof6ifWCwA;

1.23
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.22;
commitid	p4LJxGKbi0BU2cG6;

1.22
date	2015.02.10.22.44.35;	author miod;	state Exp;
branches;
next	1.21;
commitid	lsrmQ0A4gY4UmdnD;

1.21
date	2015.02.10.21.56.08;	author miod;	state Exp;
branches;
next	1.20;
commitid	C5iGb36LQxjM60Q3;

1.20
date	2014.12.15.01.53.45;	author tedu;	state Exp;
branches;
next	1.19;
commitid	zTvdNqjakdDTl6z6;

1.19
date	2014.10.09.04.18.09;	author tedu;	state Exp;
branches;
next	1.18;
commitid	TALRTC31uBKXjwur;

1.18
date	2014.09.14.14.17.23;	author jsg;	state Exp;
branches;
next	1.17;
commitid	uzzBR7hz9ncd4O6G;

1.17
date	2014.07.12.18.44.41;	author tedu;	state Exp;
branches;
next	1.16;
commitid	uKVPYMN2MLxdZxzH;

1.16
date	2013.12.19.21.30.02;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2010.12.26.15.40.59;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2008.11.05.06.32.47;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2008.06.11.10.54.08;	author phessler;	state Exp;
branches;
next	1.12;

1.12
date	2008.06.11.09.46.38;	author phessler;	state Exp;
branches;
next	1.11;

1.11
date	2008.06.11.09.22.38;	author phessler;	state Exp;
branches;
next	1.10;

1.10
date	2008.06.10.02.55.39;	author weingart;	state Exp;
branches;
next	1.9;

1.9
date	2007.11.03.22.23.35;	author mikeb;	state Exp;
branches;
next	1.8;

1.8
date	2007.10.28.10.25.09;	author martin;	state Exp;
branches;
next	1.7;

1.7
date	2007.09.17.15.34.38;	author chl;	state Exp;
branches;
next	1.6;

1.6
date	2007.01.15.23.19.05;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2005.10.26.18.46.06;	author martin;	state Exp;
branches;
next	1.4;

1.4
date	2005.05.27.19.32.39;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.22.00.48.41;	author art;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.24.00.20.45;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.28.01.39.39;	author mickey;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.06.05.23.09.24;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Make a move towards ending 4 decades of kernel snooping.

Add sysctl kern.allowkmem (default 0) which controls the ability to open
/dev/mem or /dev/kmem at securelevel > 0.  Over 15 years we converted 99%
of utilities in the tree to operate on sysctl-nodes (either by themselves
or via code hiding in the guts of -lkvm).

pstat -d and -v & procmap are affected and continued use of them will
require kern.allowkmem=1 in /etc/sysctl.conf.  acpidump (and it's
buddy sendbug) are affected, but we'll work out a solution soon.

There will be some impact in ports.

ok kettenis guenther
@
text
@/*	$OpenBSD: mem.c,v 1.30 2016/08/15 22:01:59 tedu Exp $ */
/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)mem.c	8.3 (Berkeley) 1/12/94
 */

/*
 * Memory special file
 */

#include <sys/param.h>
#include <sys/buf.h>
#include <sys/systm.h>
#include <sys/conf.h>
#include <sys/exec.h>
#include <sys/uio.h>
#include <sys/ioccom.h>
#include <sys/malloc.h>
#include <sys/memrange.h>
#include <sys/fcntl.h>

#include <machine/cpu.h>

#include <uvm/uvm_extern.h>

caddr_t zeropage;
extern int start, end, etext;

/* open counter for aperture */
#ifdef APERTURE
static int ap_open_count = 0;
extern int allowaperture;

#define VGA_START 0xA0000
#define BIOS_END  0xFFFFF
#endif

#ifdef MTRR
struct mem_range_softc mem_range_softc;
int mem_ioctl(dev_t, u_long, caddr_t, int, struct proc *);
int mem_range_attr_get(struct mem_range_desc *, int *);
int mem_range_attr_set(struct mem_range_desc *, int *);
#endif


int
mmopen(dev_t dev, int flag, int mode, struct proc *p)
{
	extern int allowkmem;

	switch (minor(dev)) {
	case 0:
	case 1:
		if (securelevel <= 0 || allowkmem)
			break;
		return (EPERM);
	case 2:
	case 12:
		break;
#ifdef APERTURE
	case 4:
	        if (suser(p, 0) != 0 || !allowaperture)
			return (EPERM);

		/* authorize only one simultaneous open() unless
		 * allowaperture=3 */
		if (ap_open_count > 0 && allowaperture < 3)
			return (EPERM);
		ap_open_count++;
		break;
#endif
	default:
		return (ENXIO);
	}
	return (0);
}

int
mmclose(dev_t dev, int flag, int mode, struct proc *p)
{
#ifdef APERTURE
	if (minor(dev) == 4)
		ap_open_count = 0;
#endif
	return (0);
}

int
mmrw(dev_t dev, struct uio *uio, int flags)
{
	extern vaddr_t kern_end;
	vaddr_t v;
	size_t c;
	struct iovec *iov;
	int error = 0;

	while (uio->uio_resid > 0 && error == 0) {
		iov = uio->uio_iov;
		if (iov->iov_len == 0) {
			uio->uio_iov++;
			uio->uio_iovcnt--;
			if (uio->uio_iovcnt < 0)
				panic("mmrw");
			continue;
		}
		switch (minor(dev)) {

		/* minor device 0 is physical memory */
		case 0:
			v = PMAP_DIRECT_MAP(uio->uio_offset);
			error = uiomove((caddr_t)v, uio->uio_resid, uio);
			continue;

		/* minor device 1 is kernel memory */
		case 1:
			v = uio->uio_offset;
			c = ulmin(iov->iov_len, MAXPHYS);
			if (v >= (vaddr_t)&start && v < kern_end) {
                                if (v < (vaddr_t)&etext &&
                                    uio->uio_rw == UIO_WRITE)
                                        return EFAULT;
                        } else if ((!uvm_kernacc((caddr_t)v, c,
			    uio->uio_rw == UIO_READ ? B_READ : B_WRITE)) &&
			    (v < PMAP_DIRECT_BASE && v > PMAP_DIRECT_END))
				return (EFAULT);
			error = uiomove((caddr_t)v, c, uio);
			continue;

		/* minor device 2 is /dev/null */
		case 2:
			if (uio->uio_rw == UIO_WRITE)
				uio->uio_resid = 0;
			return (0);

		/* minor device 12 is /dev/zero */
		case 12:
			if (uio->uio_rw == UIO_WRITE) {
				c = iov->iov_len;
				break;
			}
			if (zeropage == NULL)
				zeropage =
				    malloc(PAGE_SIZE, M_TEMP, M_WAITOK|M_ZERO);
			c = ulmin(iov->iov_len, PAGE_SIZE);
			error = uiomove(zeropage, c, uio);
			continue;

		default:
			return (ENXIO);
		}
		iov->iov_base += c;
		iov->iov_len -= c;
		uio->uio_offset += c;
		uio->uio_resid -= c;
	}

	return (error);
}

paddr_t
mmmmap(dev_t dev, off_t off, int prot)
{
	struct proc *p = curproc;	/* XXX */

	switch (minor(dev)) {
	/* minor device 0 is physical memory */
	case 0:
		if (suser(p, 0) != 0 && amd64_pa_used(off))
			return -1;
		return off;

#ifdef APERTURE
	/* minor device 4 is aperture driver */
	case 4:
		/* Check if a write combining mapping is requested. */
		if (off >= MEMRANGE_WC_RANGE)
			off = (off - MEMRANGE_WC_RANGE) | PMAP_WC;

		switch (allowaperture) {
		case 1:
			/* Allow mapping of the VGA framebuffer & BIOS only */
			if ((off >= VGA_START && off <= BIOS_END) ||
			    !amd64_pa_used(off))
				return off;
			else
				return -1;
		case 2:
		case 3:
			/* Allow mapping of the whole 1st megabyte 
			   for x86emu */
			if (off <= BIOS_END || !amd64_pa_used(off))
				return off;
			else
				return -1;
		default:
			return -1;
		}

#endif
	default:
		return -1;
	}
}

int
mmioctl(dev_t dev, u_long cmd, caddr_t data, int flags, struct proc *p)
{
#ifdef MTRR
	switch (minor(dev)) {
	case 0:
	case 4:
		return mem_ioctl(dev, cmd, data, flags, p);
	}
#endif
	return (ENODEV);
}

#ifdef MTRR
/*
 * Operations for changing memory attributes.
 *
 * This is basically just an ioctl shim for mem_range_attr_get
 * and mem_range_attr_set.
 */
int
mem_ioctl(dev_t dev, u_long cmd, caddr_t data, int flags, struct proc *p)
{
	int nd, error = 0;
	struct mem_range_op *mo = (struct mem_range_op *)data;
	struct mem_range_desc *md;
	
	/* is this for us? */
	if ((cmd != MEMRANGE_GET) &&
	    (cmd != MEMRANGE_SET))
		return (ENOTTY);

	/* any chance we can handle this? */
	if (mem_range_softc.mr_op == NULL)
		return (EOPNOTSUPP);
	/* do we have any descriptors? */
	if (mem_range_softc.mr_ndesc == 0)
		return (ENXIO);

	switch (cmd) {
	case MEMRANGE_GET:
		nd = imin(mo->mo_arg[0], mem_range_softc.mr_ndesc);
		if (nd > 0) {
			md = mallocarray(nd, sizeof(struct mem_range_desc),
			    M_MEMDESC, M_WAITOK);
			error = mem_range_attr_get(md, &nd);
			if (!error)
				error = copyout(md, mo->mo_desc,
					nd * sizeof(struct mem_range_desc));
			free(md, M_MEMDESC, nd * sizeof(struct mem_range_desc));
		} else {
			nd = mem_range_softc.mr_ndesc;
		}
		mo->mo_arg[0] = nd;
		break;
		
	case MEMRANGE_SET:
		md = malloc(sizeof(struct mem_range_desc), M_MEMDESC, M_WAITOK);
		error = copyin(mo->mo_desc, md, sizeof(struct mem_range_desc));
		/* clamp description string */
		md->mr_owner[sizeof(md->mr_owner) - 1] = 0;
		if (error == 0)
			error = mem_range_attr_set(md, &mo->mo_arg[0]);
		free(md, M_MEMDESC, sizeof(struct mem_range_desc));
		break;
	}
	return (error);
}

/*
 * Implementation-neutral, kernel-callable functions for manipulating
 * memory range attributes.
 */
int
mem_range_attr_get(struct mem_range_desc *mrd, int *arg)
{
	/* can we handle this? */
	if (mem_range_softc.mr_op == NULL)
		return (EOPNOTSUPP);

	if (*arg == 0) {
		*arg = mem_range_softc.mr_ndesc;
	} else {
		memcpy(mrd, mem_range_softc.mr_desc, (*arg) * sizeof(struct mem_range_desc));
	}
	return (0);
}

int
mem_range_attr_set(struct mem_range_desc *mrd, int *arg)
{
	/* can we handle this? */
	if (mem_range_softc.mr_op == NULL)
		return (EOPNOTSUPP);

	return (mem_range_softc.mr_op->set(&mem_range_softc, mrd, arg));
}
#endif /* MTRR */
@


1.30
log
@normalize some comments
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.29 2016/07/27 21:13:39 tedu Exp $ */
d84 2
d89 3
@


1.29
log
@improve comments a bit. ok mlarkin tom
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.28 2015/09/08 04:28:34 semarie Exp $ */
d98 1
a98 1
			return(EPERM);
@


1.28
log
@convert several malloc(9) to mallocarray(9).

ok deraadt@@ guenther@@ "re-wrap the long lines" kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.27 2015/08/29 12:30:30 sthen Exp $ */
a80 1
/*ARGSUSED*/
a107 1
/*ARGSUSED*/
a117 1
/*ARGSUSED*/
d138 1
a138 1
/* minor device 0 is physical memory */
d144 1
a144 1
/* minor device 1 is kernel memory */
d159 1
a159 1
/* minor device 2 is EOF/RATHOLE */
d165 1
a165 1
/* minor device 12 (/dev/zero) is source of nulls on read, rathole on write */
d172 1
a172 1
				zeropage = (caddr_t)
d196 1
a196 1
/* minor device 0 is physical memory */
d203 1
a203 1
/* minor device 4 is aperture driver */
a331 1

a332 1

@


1.27
log
@use correct size for free(9), problem reported by Theo Buehler, ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.26 2015/08/28 00:03:53 deraadt Exp $ */
d281 2
a282 3
			md = (struct mem_range_desc *)
				malloc(nd * sizeof(struct mem_range_desc),
				       M_MEMDESC, M_WAITOK);
@


1.26
log
@fairly simple sizes for free(); ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.25 2015/06/22 18:57:26 kettenis Exp $ */
d302 1
a302 1
		free(md, M_MEMDESC, nd * sizeof(struct mem_range_desc));
@


1.25
log
@Make it possible to create write combing mappings through /dev/mem.  This is
done by introducining a magic offset.  Pages below this offset are mapped
with default memory attributes.  Above this offset pages are mapped write
combining.

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.24 2015/05/28 20:53:05 jcs Exp $ */
d288 1
a288 1
			free(md, M_MEMDESC, 0);
d302 1
a302 1
		free(md, M_MEMDESC, 0);
@


1.24
log
@when machdep.allowaperture sysctl is set to 3, allow concurrent access
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.23 2015/03/14 03:38:46 jsg Exp $ */
d208 4
@


1.23
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.22 2015/02/10 22:44:35 miod Exp $ */
d96 3
a98 2
		/* authorize only one simultaneous open() */
		if (ap_open_count > 0)
d217 1
@


1.22
log
@Convert to uiomove().
ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.20 2014/12/15 01:53:45 tedu Exp $ */
a57 1
#include <machine/conf.h>
@


1.21
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d126 1
a126 1
	int c;
d144 1
a144 1
			error = uiomovei((caddr_t)v, uio->uio_resid, uio);
d150 1
a150 1
			c = min(iov->iov_len, MAXPHYS);
d159 1
a159 1
			error = uiomovei((caddr_t)v, c, uio);
d177 2
a178 2
			c = min(iov->iov_len, PAGE_SIZE);
			error = uiomovei(zeropage, c, uio);
@


1.20
log
@change bcopy to memcpy. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.19 2014/10/09 04:18:09 tedu Exp $ */
d144 1
a144 1
			error = uiomove((caddr_t)v, uio->uio_resid, uio);
d159 1
a159 1
			error = uiomove((caddr_t)v, c, uio);
d178 1
a178 1
			error = uiomove(zeropage, c, uio);
@


1.19
log
@no need for lkm_map now
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.18 2014/09/14 14:17:23 jsg Exp $ */
d317 1
a317 1
		bcopy(mem_range_softc.mr_desc, mrd, (*arg) * sizeof(struct mem_range_desc));
@


1.18
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.17 2014/07/12 18:44:41 tedu Exp $ */
a55 3
#ifdef LKM
#include <sys/lkm.h>
#endif
a64 4
#ifdef LKM
extern vaddr_t lkm_start, lkm_end;
#endif

a154 7
#ifdef LKM
			} else if (v >= lkm_start && v < lkm_end) {
				if (!uvm_map_checkprot(lkm_map, v, v + c,
				    uio->uio_rw == UIO_READ ?
				    UVM_PROT_READ: UVM_PROT_WRITE))
					return (EFAULT);
#endif
@


1.17
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.16 2013/12/19 21:30:02 deraadt Exp $ */
a54 1
#include <sys/proc.h>
@


1.16
log
@Mtrr stops being a pseudo-device.  We need to probe the cpu type and
initialize the structures when we see the first cpu.  We also need to
initialize each cpu's properly (for PAT) before we setup mtrr on that
cpu.  On i386 (late hatch) we were getting this desperately wrong on
the primary cpu.

After suspend/resume, we also need to do the same work.  re-initialize
PAT before mtrr.  On some laptops apparently PAT was not turned on by the
BIOS, so we ended up with incorrect setup for the primary cpu.  Oops.

This makes mplayer on the x201 (and similar) machines work without weird
pauses after a suspend/resume.  Many other things are likely fixed.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.15 2010/12/26 15:40:59 miod Exp $ */
d298 1
a298 1
			free(md, M_MEMDESC);
d312 1
a312 1
		free(md, M_MEMDESC);
@


1.15
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.14 2008/11/05 06:32:47 matthieu Exp $ */
a65 2
#include "mtrr.h"

d82 1
a82 1
#if NMTRR > 0
d251 1
a251 1
#if NMTRR > 0
d261 1
a261 1
#if NMTRR > 0
d347 2
a348 1
#endif /* NMTRR > 0 */
@


1.14
log
@since mmclose() is only called once for the final close,
set ap_open_count = 0 in mmclose() instread of decrementing it.
ok miod@@, oga@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.13 2008/06/11 10:54:08 phessler Exp $ */
d220 1
a220 1
		return atop(off);
d229 2
a230 2
				!amd64_pa_used(off))
				return atop(off);
d237 1
a237 1
				return atop(off);
@


1.13
log
@actually unbreak RAMDISK.  double plus minus cookie for me
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.12 2008/06/11 09:46:38 phessler Exp $ */
d125 1
a125 1
		ap_open_count--;
@


1.12
log
@unbreak RAMDISK

no cookie for me
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.11 2008/06/11 09:22:38 phessler Exp $ */
a65 1
#if NMTRR > 0
a66 1
#endif
@


1.11
log
@Synchronize the MTRR API with i386, and enable

"just commit it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.10 2008/06/10 02:55:39 weingart Exp $ */
d66 1
d68 1
@


1.10
log
@All your memory belong to us.  This has been in snaps for a while,
and seems to work.  If it breaks, people had plenty of chances to
complain.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.9 2007/11/03 22:23:35 mikeb Exp $ */
d66 2
d84 8
d253 7
d263 87
@


1.9
log
@Fix LKM support for amd64.

ok deraadt weingart
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.8 2007/10/28 10:25:09 martin Exp $ */
d208 1
a208 1
		if ((paddr_t)off > (paddr_t)ptoa(physmem) && suser(p, 0) != 0)
d219 1
a219 1
			    (unsigned)off > (unsigned)ptoa(physmem))
d226 1
a226 2
			if (off <= BIOS_END || 
			    (unsigned)off > (unsigned)ptoa(physmem))
d228 1
a228 1
			else 
d233 1
a233 1
			
@


1.8
log
@get rid of btoc/ctob in favor of atop/ptoa
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.7 2007/09/17 15:34:38 chl Exp $ */
d49 2
d57 3
d69 4
d155 7
@


1.7
log
@MALLOC/FREE -> malloc/free and M_ZERO changes

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.6 2007/01/15 23:19:05 jsg Exp $ */
d192 1
a192 1
		if ((paddr_t)off > (paddr_t)ctob(physmem) && suser(p, 0) != 0)
d203 1
a203 1
			    (unsigned)off > (unsigned)ctob(physmem))
d211 1
a211 1
			    (unsigned)off > (unsigned)ctob(physmem))
@


1.6
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.5 2005/10/26 18:46:06 martin Exp $ */
d165 1
a165 1
			if (zeropage == NULL) {
d167 1
a167 3
				    malloc(PAGE_SIZE, M_TEMP, M_WAITOK);
				bzero(zeropage, PAGE_SIZE);
			}
@


1.5
log
@goodbye more Mach macros

help toby, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.4 2005/05/27 19:32:39 art Exp $ */
d75 1
a75 4
mmopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
a76 1

d102 1
a102 4
mmclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
d187 1
a187 4
mmmmap(dev, off, prot)
	dev_t dev;
	off_t off;
	int prot;
d228 1
a228 6
mmioctl(dev, cmd, data, flags, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flags;
	struct proc *p;
@


1.4
log
@Stop pretending that amd64 is i386. We're insulting the cpu by not even
pretending to use all the address space it gives us.

 - Map all physical memory 1-1 and implement PMAP_DIRECT
 - Remove the vast magic we do to map pages for pmap_zero_page,
   pmap_copy_page, pv allocation, magic while bootstrapping,
   reading of /dev/mem, etc.
 - implement a fast pmap_zero_page based on sse instructions.

I love removing code. More to come.

deraadt@@ ok tested by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.3 2004/07/22 00:48:41 art Exp $ */
d206 1
a206 1
		return btop((paddr_t)off);
d216 1
a216 1
				return btop((paddr_t)off);
d224 1
a224 1
				return btop((paddr_t)off);
@


1.3
log
@Fix access to direct mapped memory through /dev/kmem.
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.2 2004/02/24 00:20:45 mickey Exp $ */
a60 1
extern char *vmmap;            /* poor name! */
d123 1
a123 1
	vaddr_t o, v;
a126 1
	static int physlock;
a127 11
	if (minor(dev) == 0) {
		/* lock against other uses of shared vmmap */
		while (physlock > 0) {
			physlock++;
			error = tsleep((caddr_t)&physlock, PZERO | PCATCH,
			    "mmrw", 0);
			if (error)
				return (error);
		}
		physlock = 1;
	}
d141 2
a142 11
			v = uio->uio_offset;
			pmap_enter(pmap_kernel(), (vaddr_t)vmmap,
			    trunc_page(v), uio->uio_rw == UIO_READ ?
			    VM_PROT_READ : VM_PROT_WRITE, PMAP_WIRED);
			pmap_update(pmap_kernel());
			o = uio->uio_offset & PGOFSET;
			c = min(uio->uio_resid, (int)(NBPG - o));
			error = uiomove((caddr_t)vmmap + o, c, uio);
			pmap_remove(pmap_kernel(), (vaddr_t)vmmap,
			    (vaddr_t)vmmap + NBPG);
			pmap_update(pmap_kernel());
d189 1
a189 5
	if (minor(dev) == 0) {
		if (physlock > 1)
			wakeup((caddr_t)&physlock);
		physlock = 0;
	}
@


1.2
log
@repair kvm; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.1 2004/01/28 01:39:39 mickey Exp $ */
d175 3
a177 2
                        } else if (!uvm_kernacc((caddr_t)v, c,
			    uio->uio_rw == UIO_READ ? B_READ : B_WRITE))
@


1.1
log
@an amd64 arch support.
hacked by art@@ from netbsd sources and then later debugged
by me into the shape where it can host itself.
no bootloader yet as needs redoing from the
recent advanced i386 sources (anyone? ;)
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.25 2003/02/26 18:25:29 tedu Exp $ */
d63 1
d123 1
d171 5
a175 1
			if (!uvm_kernacc((caddr_t)v, c,
@


1.1.2.1
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a62 1
extern int start, end, etext;
a121 1
	extern vaddr_t kern_end;
d169 1
a169 5
			if (v >= (vaddr_t)&start && v < kern_end) {
                                if (v < (vaddr_t)&etext &&
                                    uio->uio_rw == UIO_WRITE)
                                        return EFAULT;
                        } else if (!uvm_kernacc((caddr_t)v, c,
@


