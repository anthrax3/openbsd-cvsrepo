head	1.24;
access;
symbols
	OPENBSD_6_2:1.24.0.8
	OPENBSD_6_2_BASE:1.24
	OPENBSD_6_1:1.24.0.10
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.24.0.6
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.24.0.2
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.24.0.4
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.19.0.4
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.18.0.16
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.12
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.10
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.8
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.6
	OPENBSD_5_0:1.18.0.4
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.2
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.16.0.2
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.14.0.6
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.12.0.2
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.10.0.4
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.2
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.9.0.2
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.4
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.5.0.6
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	OPENBSD_3_5:1.2.0.2
	OPENBSD_3_5_BASE:1.2
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.24
date	2015.05.24.01.01.49;	author guenther;	state Exp;
branches;
next	1.23;
commitid	ZeKgaxXwOerLHwE3;

1.23
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.22;
commitid	p4LJxGKbi0BU2cG6;

1.22
date	2014.12.15.01.53.45;	author tedu;	state Exp;
branches;
next	1.21;
commitid	zTvdNqjakdDTl6z6;

1.21
date	2014.11.16.12.30.56;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	yv0ECmCdICvq576h;

1.20
date	2014.09.14.14.17.23;	author jsg;	state Exp;
branches;
next	1.19;
commitid	uzzBR7hz9ncd4O6G;

1.19
date	2014.04.01.09.05.03;	author mpi;	state Exp;
branches;
next	1.18;

1.18
date	2010.11.13.04.16.42;	author guenther;	state Exp;
branches;
next	1.17;

1.17
date	2010.10.26.05.49.10;	author guenther;	state Exp;
branches;
next	1.16;

1.16
date	2010.06.26.23.24.43;	author guenther;	state Exp;
branches;
next	1.15;

1.15
date	2009.09.18.21.08.19;	author martynas;	state Exp;
branches;
next	1.14;

1.14
date	2009.02.03.11.24.19;	author mikeb;	state Exp;
branches;
next	1.13;

1.13
date	2009.01.17.23.44.46;	author guenther;	state Exp;
branches;
next	1.12;

1.12
date	2008.07.25.15.01.33;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2008.06.26.05.42.09;	author ray;	state Exp;
branches;
next	1.10;

1.10
date	2007.05.29.00.17.33;	author thib;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.15.23.19.05;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2007.01.12.07.41.31;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.19.02.18.00;	author pedro;	state Exp;
branches;
next	1.6;

1.6
date	2005.09.25.20.48.18;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.08.04.23.04;	author david;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.25.11.03.27;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.20.21.06.46;	author nordin;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.27.23.45.23;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.28.01.39.38;	author mickey;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.06.05.23.09.24;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Treat primary cpu like others and put pointer to its GDT in cpu_info.ci_gdt

requested by and ok mlarkin@@
@
text
@/*	$OpenBSD: gdt.c,v 1.23 2015/03/14 03:38:46 jsg Exp $	*/
/*	$NetBSD: gdt.c,v 1.1 2003/04/26 18:39:28 fvdl Exp $	*/

/*-
 * Copyright (c) 1996, 1997 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by John T. Kohl and Charles M. Hannum.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Modified to deal with variable-length entries for amd64 by
 * fvdl@@wasabisystems.com, may 2001
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mutex.h>

#include <uvm/uvm_extern.h>

#include <machine/tss.h>
#include <machine/pcb.h>

/*
 * Allocate shadow GDT for a slave cpu.
 */
void
gdt_alloc_cpu(struct cpu_info *ci)
{
	struct vm_page *pg;
	vaddr_t va;

	ci->ci_gdt = (char *)uvm_km_valloc(kernel_map,
	    GDT_SIZE + sizeof(*ci->ci_tss));
	ci->ci_tss = (void *)(ci->ci_gdt + GDT_SIZE);
	uvm_map_pageable(kernel_map, (vaddr_t)ci->ci_gdt,
            (vaddr_t)ci->ci_gdt + GDT_SIZE, FALSE, FALSE);
	for (va = (vaddr_t)ci->ci_gdt;
	    va < (vaddr_t)ci->ci_gdt + GDT_SIZE + sizeof(*ci->ci_tss);
	    va += PAGE_SIZE) {
		pg = uvm_pagealloc(NULL, 0, NULL, UVM_PGA_ZERO);
		if (pg == NULL)
			panic("gdt_init: no pages");
		pmap_kenter_pa(va, VM_PAGE_TO_PHYS(pg), PROT_READ | PROT_WRITE);
	}
	memcpy(ci->ci_gdt, cpu_info_primary.ci_gdt, GDT_SIZE);
	bzero(ci->ci_tss, sizeof(*ci->ci_tss));
}


/*
 * Load appropriate gdt descriptor; we better be running on *ci
 * (for the most part, this is how a cpu knows who it is).
 */
void
gdt_init_cpu(struct cpu_info *ci)
{
	struct region_descriptor region;

	set_sys_segment(GDT_ADDR_SYS(ci->ci_gdt, GPROC0_SEL), ci->ci_tss,
	    sizeof (struct x86_64_tss)-1, SDT_SYS386TSS, SEL_KPL, 0);

	setregion(&region, ci->ci_gdt, GDT_SIZE - 1);
	lgdt(&region);
	ltr(GSYSSEL(GPROC0_SEL, SEL_KPL));
}
@


1.23
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.22 2014/12/15 01:53:45 tedu Exp $	*/
d69 1
a69 1
	memcpy(ci->ci_gdt, gdtstore, GDT_SIZE);
@


1.22
log
@change bcopy to memcpy. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.21 2014/11/16 12:30:56 deraadt Exp $	*/
a43 1
#include <machine/gdt.h>
@


1.21
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.20 2014/09/14 14:17:23 jsg Exp $	*/
d70 1
a70 1
	bcopy(gdtstore, ci->ci_gdt, GDT_SIZE);
@


1.20
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.19 2014/04/01 09:05:03 mpi Exp $	*/
d68 1
a68 2
		pmap_kenter_pa(va, VM_PAGE_TO_PHYS(pg),
		    VM_PROT_READ | VM_PROT_WRITE);
@


1.19
log
@More <uvm/uvm.h> -> <uvm/uvm_extern.h> cleaning.

ok kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.18 2010/11/13 04:16:42 guenther Exp $	*/
a39 1
#include <sys/proc.h>
@


1.18
log
@Switch from TSS-per-process to TSS-per-CPU, placing the TSS right
next to the cpu's GDT, also making the double-fault stack per-CPU,
leaving it at the top of the page of the CPU's idle process.  Inline
pmap_activate() and pmap_deactivate() into the asm cpu_switchto
routine, adding a check for the new pmap already being marked as
active on the CPU.  Garbage collect the hasn't-been-used-in-years
GDT update IPI.

Tested by many; ok mikeb@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.17 2010/10/26 05:49:10 guenther Exp $	*/
d43 1
a43 1
#include <uvm/uvm.h>
@


1.17
log
@The LDT is only used by dead compat code now, so load the ldt
register with the null selector (disabling use of it), stop reloading
it on every context switch, and blow away the table itself, as well
as the pcb and pmap bits that were used to track it.  Also, delete
two other unused pcb members: pcb_usersp and pcb_flags.  (Deleting
pcb_usersp also keeps the pcb_savefpu member aligned properly.)
Finally, delete the defines for the unimplemented AMD64_{GET,SET}_LDT
sysarch() calls.

Tested by various with both AMD and Intel chips
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.16 2010/06/26 23:24:43 guenther Exp $	*/
a35 2
 * XXX this file should be shared with the i386 code, the difference
 * can be hidden in macros.
d46 1
a48 82
int gdt_next;		/* next available slot for sweeping */
int gdt_free;		/* next free slot; terminated with GNULL_SEL */

struct mutex gdt_lock_store = MUTEX_INITIALIZER(IPL_HIGH);

void gdt_init(void);
int gdt_get_slot(void);
void gdt_put_slot(int);

/*
 * Lock and unlock the GDT.
 */
#define gdt_lock()	(mtx_enter(&gdt_lock_store))
#define gdt_unlock()	(mtx_leave(&gdt_lock_store))

void
set_mem_gdt(struct mem_segment_descriptor *sd, void *base, size_t limit,
    int type, int dpl, int gran, int def32, int is64)
{
	CPU_INFO_ITERATOR cii;
	struct cpu_info *ci;
	int off;

        set_mem_segment(sd, base, limit, type, dpl, gran, def32, is64);
	off = (char *)sd - gdtstore;
        CPU_INFO_FOREACH(cii, ci) {
                if (ci->ci_gdt != NULL)
			*(struct mem_segment_descriptor *)(ci->ci_gdt + off) =
			    *sd;
        }
}

void
set_sys_gdt(struct sys_segment_descriptor *sd, void *base, size_t limit,
    int type, int dpl, int gran)
{
	CPU_INFO_ITERATOR cii;
	struct cpu_info *ci;
	int off;

        set_sys_segment(sd, base, limit, type, dpl, gran);
	off = (char *)sd - gdtstore;
        CPU_INFO_FOREACH(cii, ci) {
                if (ci->ci_gdt != NULL)
			*(struct sys_segment_descriptor *)(ci->ci_gdt + off) =
			    *sd;
        }
}


/*
 * Initialize the GDT.
 */
void
gdt_init(void)
{
	char *old_gdt;
	struct vm_page *pg;
	vaddr_t va;
	struct cpu_info *ci = &cpu_info_primary;

	gdt_next = 0;
	gdt_free = GNULL_SEL;

	old_gdt = gdtstore;
	gdtstore = (char *)uvm_km_valloc(kernel_map, MAXGDTSIZ);
	for (va = (vaddr_t)gdtstore; va < (vaddr_t)gdtstore + MAXGDTSIZ;
	    va += PAGE_SIZE) {
		pg = uvm_pagealloc(NULL, 0, NULL, UVM_PGA_ZERO);
		if (pg == NULL) {
			panic("gdt_init: no pages");
		}
		pmap_kenter_pa(va, VM_PAGE_TO_PHYS(pg),
		    VM_PROT_READ | VM_PROT_WRITE);
	}
	bcopy(old_gdt, gdtstore, DYNSEL_START);
	ci->ci_gdt = gdtstore;

	gdt_init_cpu(ci);
}

#ifdef MULTIPROCESSOR
d58 3
a60 1
	ci->ci_gdt = (char *)uvm_km_valloc(kernel_map, MAXGDTSIZ);
d62 3
a64 2
            (vaddr_t)ci->ci_gdt + MAXGDTSIZ, FALSE, FALSE);
	for (va = (vaddr_t)ci->ci_gdt; va < (vaddr_t)ci->ci_gdt + MAXGDTSIZ;
d72 2
a73 2
	bzero(ci->ci_gdt, MAXGDTSIZ);
	bcopy(gdtstore, ci->ci_gdt, MAXGDTSIZ);
a74 1
#endif	/* MULTIPROCESSOR */
d86 2
a87 5
	setregion(&region, ci->ci_gdt, (u_int16_t)(MAXGDTSIZ - 1));
	lgdt(&region);
}

#ifdef MULTIPROCESSOR
d89 1
a89 6
void
gdt_reload_cpu(struct cpu_info *ci)
{
	struct region_descriptor region;

	setregion(&region, ci->ci_gdt, MAXGDTSIZ - 1);
d91 1
a92 90
#endif

/*
 * Allocate a GDT slot as follows:
 * 1) If there are entries on the free list, use those.
 * 2) If there are fewer than MAXGDTSIZ entries in use, there are free slots
 *    near the end that we can sweep through.
 */
int
gdt_get_slot(void)
{
	int slot;
	struct sys_segment_descriptor *gdt;

	gdt = (struct sys_segment_descriptor *)&gdtstore[DYNSEL_START];

	gdt_lock();

	if (gdt_free != GNULL_SEL) {
		slot = gdt_free;
		gdt_free = gdt[slot].sd_xx3;	/* XXXfvdl res. field abuse */
	} else {
		if (gdt_next >= MAXGDTSIZ)
			panic("gdt_get_slot: out of GDT descriptors");
		slot = gdt_next++;
	}

	gdt_unlock();
	return (slot);
}

/*
 * Deallocate a GDT slot, putting it on the free list.
 */
void
gdt_put_slot(int slot)
{
	struct sys_segment_descriptor *gdt;

	gdt = (struct sys_segment_descriptor *)&gdtstore[DYNSEL_START];

	gdt_lock();

	gdt[slot].sd_type = SDT_SYSNULL;
	gdt[slot].sd_xx3 = gdt_free;
	gdt_free = slot;

	gdt_unlock();
}

int
tss_alloc(struct pcb *pcb)
{
	int slot;
	struct sys_segment_descriptor *gdt;

	gdt = (struct sys_segment_descriptor *)&gdtstore[DYNSEL_START];

	slot = gdt_get_slot();
#if 0
	printf("tss_alloc: slot %d addr %p\n", slot, &gdt[slot]);
#endif
	set_sys_gdt(&gdt[slot], &pcb->pcb_tss, sizeof (struct x86_64_tss)-1,
	    SDT_SYS386TSS, SEL_KPL, 0);
#if 0
	printf("lolimit %lx lobase %lx type %lx dpl %lx p %lx hilimit %lx\n"
	       "xx1 %lx gran %lx hibase %lx xx2 %lx zero %lx xx3 %lx pad %lx\n",
		(unsigned long)gdt[slot].sd_lolimit,
		(unsigned long)gdt[slot].sd_lobase,
		(unsigned long)gdt[slot].sd_type,
		(unsigned long)gdt[slot].sd_dpl,
		(unsigned long)gdt[slot].sd_p,
		(unsigned long)gdt[slot].sd_hilimit,
		(unsigned long)gdt[slot].sd_xx1,
		(unsigned long)gdt[slot].sd_gran,
		(unsigned long)gdt[slot].sd_hibase,
		(unsigned long)gdt[slot].sd_xx2,
		(unsigned long)gdt[slot].sd_zero,
		(unsigned long)gdt[slot].sd_xx3);
#endif
	return GDYNSEL(slot, SEL_KPL);
}

void
tss_free(int sel)
{

	gdt_put_slot(IDXDYNSEL(sel));
}

@


1.16
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.15 2009/09/18 21:08:19 martynas Exp $	*/
a126 2
	set_sys_segment(GDT_ADDR_SYS(gdtstore, GLDT_SEL), ldtstore,
	    LDT_SIZE - 1, SDT_SYSLDT, SEL_KPL, 0);
@


1.15
log
@ldt removal missed some.  amd64_{get,set}_ldt gone.  also remove
ldt_{alloc,free} to shave a few.  ok jasper@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.14 2009/02/03 11:24:19 mikeb Exp $	*/
a42 1
#include <sys/user.h>
d48 1
@


1.14
log
@Free TSS on the stack of the dead process.

In order to do that we have to remove all sleeping parts: sleeping
memory allocation and a sleeping lock.  Thus we're moving this code
to the spinning lock (mutex) and getting rid of the GDT grow code.
Downside is that now we're pre-allocating 64kb of memory per CPU
from the start, but this might be optimized in future.

This also unifies GDT code and MAXGDTSIZ define across i386 and amd64.

With help from mickey.

ok toby, art
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.13 2009/01/17 23:44:46 guenther Exp $	*/
a272 22
void
ldt_alloc(struct pmap *pmap, char *ldt, size_t len)
{
	int slot;
	struct sys_segment_descriptor *gdt;

	gdt = (struct sys_segment_descriptor *)&gdtstore[DYNSEL_START];

	slot = gdt_get_slot();
	set_sys_gdt(&gdt[slot], ldt, len - 1, SDT_SYSLDT, SEL_KPL, 0);
	pmap->pm_ldt_sel = GSEL(slot, SEL_KPL);
}

void
ldt_free(struct pmap *pmap)
{
	int slot;

	slot = IDXDYNSEL(pmap->pm_ldt_sel);

	gdt_put_slot(slot);
}
@


1.13
log
@gdt_compact() was removed years ago, so kill the code and comments
that worked around its presence

ok'ed by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.12 2008/07/25 15:01:33 art Exp $	*/
a42 1
#include <sys/rwlock.h>
d44 1
a49 3
int gdt_size;		/* size of GDT in bytes */
int gdt_dyncount;	/* number of dyn. allocated GDT entries in use */
int gdt_dynavail;
d53 1
a53 1
struct rwlock gdt_lock_store = RWLOCK_INITIALIZER("gdtlk");
a54 2
static __inline void gdt_lock(void);
static __inline void gdt_unlock(void);
a55 1
void gdt_grow(void);
d60 1
a60 2
 * Lock and unlock the GDT, to avoid races in case gdt_{ge,pu}t_slot() sleep
 * waiting for memory.
d62 2
a63 13
static __inline void
gdt_lock(void)
{
	if (curproc != NULL)		/* XXX - ugh. needed for startup */
		rw_enter_write(&gdt_lock_store);
}

static __inline void
gdt_unlock(void)
{
	if (curproc != NULL)
		rw_exit_write(&gdt_lock_store);
}
a110 2
	gdt_size = MINGDTSIZ;
	gdt_dyncount = 0;
a112 2
	gdt_dynavail =
	    (gdt_size - DYNSEL_START) / sizeof (struct sys_segment_descriptor);
d116 1
a116 1
	for (va = (vaddr_t)gdtstore; va < (vaddr_t)gdtstore + gdt_size;
d125 1
a125 1
	memcpy(gdtstore, old_gdt, DYNSEL_START);
d140 16
a155 6
        ci->ci_gdt = (char *)uvm_km_valloc(kernel_map, MAXGDTSIZ);
        uvm_map_pageable(kernel_map, (vaddr_t)ci->ci_gdt,
            (vaddr_t)ci->ci_gdt + MINGDTSIZ, FALSE, FALSE);
        memset(ci->ci_gdt, 0, MINGDTSIZ);
        memcpy(ci->ci_gdt, gdtstore,
	   DYNSEL_START + gdt_dyncount * sizeof(struct sys_segment_descriptor));
a184 33

/*
 * Grow or shrink the GDT.
 */
void
gdt_grow(void)
{
	CPU_INFO_ITERATOR cii;
	struct cpu_info *ci;
	struct vm_page *pg;
	size_t old_len;
	vaddr_t va;

	old_len = gdt_size;
	gdt_size = 2 * gdt_size;
	gdt_dynavail =
	    (gdt_size - DYNSEL_START) / sizeof (struct sys_segment_descriptor);

	CPU_INFO_FOREACH(cii, ci) {
		for (va = (vaddr_t)(ci->ci_gdt) + old_len;
		    va < (vaddr_t)(ci->ci_gdt) + gdt_size;
		    va += PAGE_SIZE) {
			while ((pg =
			    uvm_pagealloc(NULL, 0, NULL, UVM_PGA_ZERO)) ==
			    NULL) {
				uvm_wait("gdt_grow");
			}
			pmap_kenter_pa(va, VM_PAGE_TO_PHYS(pg),
			    VM_PROT_READ | VM_PROT_WRITE);
		}
	}
}

d188 1
a188 1
 * 2) If there are fewer than gdt_dynavail entries in use, there are free slots
a189 2
 * 3) As a last resort, we increase the size of the GDT, and sweep through
 *    the new slots.
d205 2
a206 11
#ifdef DIAGNOSTIC
		if (gdt_next != gdt_dyncount)
			panic("gdt_get_slot botch 1");
#endif
		if (gdt_next >= gdt_dynavail) {
#ifdef DIAGNOSTIC
			if (gdt_size >= MAXGDTSIZ)
				panic("gdt_get_slot botch 2");
#endif
			gdt_grow();
		}
a209 1
	gdt_dyncount++;
a224 1
	gdt_dyncount--;
@


1.12
log
@In gdt_grow, always map the gdt on the secondary cpus too. This far
we depended on the pageability of the kernel_map to map them which worked
most of the time, until we hit the most improbable case - when cpu_switchto
wanted to fault in the missing gdt page, which at this moment is Verboten.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.11 2008/06/26 05:42:09 ray Exp $	*/
a67 5
 *
 * Note that the locking done here is not sufficient for multiprocessor
 * systems.  A freshly allocated slot will still be of type SDT_SYSNULL for
 * some time after the GDT is unlocked, so gdt_compact() could attempt to
 * reclaim it.
@


1.11
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.10 2007/05/29 00:17:33 thib Exp $	*/
d209 3
a212 1
	struct vm_page *pg;
d220 11
a230 6
	for (va = (vaddr_t)gdtstore + old_len;
	    va < (vaddr_t)gdtstore + gdt_size;
	    va += PAGE_SIZE) {
		while ((pg = uvm_pagealloc(NULL, 0, NULL, UVM_PGA_ZERO)) ==
		       NULL) {
			uvm_wait("gdt_grow");
a231 2
		pmap_kenter_pa(va, VM_PAGE_TO_PHYS(pg),
		    VM_PROT_READ | VM_PROT_WRITE);
@


1.10
log
@Add a name argument to the RWLOCK_INITIALIZER macro.
Pick reasonble names for the locks involved..

ok tedu@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.9 2007/01/15 23:19:05 jsg Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.9
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.8 2007/01/12 07:41:31 art Exp $	*/
d63 1
a63 1
struct rwlock gdt_lock_store = RWLOCK_INITIALIZER;
@


1.8
log
@Switch some lockmgr locks to rwlocks.
In this commit:
 - gdt lock on amd64
 - sysctl lock
 - malloc sysctl lock
 - disk sysctl lock
 - swap syscall lock

miod@@, pedro@@ ok (and "looks good" others@@)
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.7 2005/11/19 02:18:00 pedro Exp $	*/
d96 2
a97 5
set_mem_gdt(sd, base, limit, type, dpl, gran, def32, is64)
	struct mem_segment_descriptor *sd;
	void *base;
	size_t limit;
	int type, dpl, gran, def32, is64;
d113 2
a114 5
set_sys_gdt(sd, base, limit, type, dpl, gran)
	struct sys_segment_descriptor *sd;
	void *base;
	size_t limit;
	int type, dpl, gran;
d134 1
a134 1
gdt_init()
d214 1
a214 1
gdt_grow()
d246 1
a246 1
gdt_get_slot()
d282 1
a282 2
gdt_put_slot(slot)
	int slot;
d299 1
a299 2
tss_alloc(pcb)
	struct pcb *pcb;
d339 1
a339 4
ldt_alloc(pmap, ldt, len)
	struct pmap *pmap;
	char *ldt;
	size_t len;
d352 1
a352 2
ldt_free(pmap)
	struct pmap *pmap;
@


1.7
log
@Remove unnecessary lockmgr() archaism that was costing too much in terms
of panics and bugfixes. Access curproc directly, do not expect a process
pointer as an argument. Should fix many "process context required" bugs.
Incentive and okay millert@@, okay marc@@. Various testing, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.6 2005/09/25 20:48:18 miod Exp $	*/
d50 1
a50 1
#include <sys/lock.h>
d63 1
a63 1
struct lock gdt_lock_store;
d82 1
a82 1
gdt_lock()
d85 1
a85 1
		(void) lockmgr(&gdt_lock_store, LK_EXCLUSIVE, NULL);
d89 1
a89 1
gdt_unlock()
d92 1
a92 1
		(void) lockmgr(&gdt_lock_store, LK_RELEASE, NULL);
a145 2

	lockinit(&gdt_lock_store, PZERO, "gdtlck", 0, 0);
@


1.6
log
@Turn CPU_INFO_FOREACH into a real construct, like all queue(3) iterators,
instead of the contents of a for() loop. No functional change.
From the m88k SMP tree; ok art@@ deraadt@@

[complete diff this time]
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.5 2004/07/08 04:23:04 david Exp $	*/
d85 1
a85 1
		(void) lockmgr(&gdt_lock_store, LK_EXCLUSIVE, NULL, curproc);
d92 1
a92 1
		(void) lockmgr(&gdt_lock_store, LK_RELEASE, NULL, curproc);
@


1.5
log
@enclose some MP-only things in #ifdef MULTIPROCESSOR
ok deraadt@@ niklas@@; testing by pvalchev@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.4 2004/06/25 11:03:27 art Exp $	*/
d108 1
a108 1
        for (CPU_INFO_FOREACH(cii, ci)) {
d128 1
a128 1
        for (CPU_INFO_FOREACH(cii, ci)) {
@


1.4
log
@SMP support. Big parts from NetBSD, but with some really serious debugging
done by me, niklas and others. Especially wrt. NXE support.

Still needs some polishing, especially in dmesg messages, but we're now
building kernel faster than ever.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.3 2004/05/20 21:06:46 nordin Exp $	*/
d175 1
d189 1
@


1.3
log
@Make MINGDTSIZ a multiple of PAGE_SIZE to avoid destroying the gdt table.
ok tom@@ toby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.2 2004/02/27 23:45:23 deraadt Exp $	*/
d84 2
a85 2

	(void) lockmgr(&gdt_lock_store, LK_EXCLUSIVE, NULL, curproc);
d91 2
a92 2

	(void) lockmgr(&gdt_lock_store, LK_RELEASE, NULL, curproc);
@


1.2
log
@remove old crud
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.1 2004/01/28 01:39:38 mickey Exp $	*/
a56 3
#define	MINGDTSIZ	2048
#define	MAXGDTSIZ	65536

d158 1
a158 1
	for (va = (vaddr_t)gdtstore; va < (vaddr_t)gdtstore + MINGDTSIZ;
d222 1
a222 1
	size_t old_len, new_len;
d227 1
a227 2
	gdt_size <<= 1;
	new_len = old_len << 1;
d231 2
a232 1
	for (va = (vaddr_t)gdtstore + old_len; va < (vaddr_t)gdtstore + new_len;
@


1.1
log
@an amd64 arch support.
hacked by art@@ from netbsd sources and then later debugged
by me into the shape where it can host itself.
no bootloader yet as needs redoing from the
recent advanced i386 sources (anyone? ;)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d41 1
a41 1
 * Modified to deal with variable-length entries for NetBSD/x86_64 by
@


1.1.2.1
log
@Merge with the trunk
@
text
@d41 1
a41 1
 * Modified to deal with variable-length entries for amd64 by
d57 3
d161 1
a161 1
	for (va = (vaddr_t)gdtstore; va < (vaddr_t)gdtstore + gdt_size;
d225 1
a225 1
	size_t old_len;
d230 2
a231 1
	gdt_size = 2 * gdt_size;
d235 1
a235 2
	for (va = (vaddr_t)gdtstore + old_len;
	    va < (vaddr_t)gdtstore + gdt_size;
@


