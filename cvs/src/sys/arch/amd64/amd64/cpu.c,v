head	1.102;
access;
symbols
	OPENBSD_6_1_BASE:1.102
	OPENBSD_6_0:1.101.0.2
	OPENBSD_6_0_BASE:1.101
	OPENBSD_5_9:1.95.0.2
	OPENBSD_5_9_BASE:1.95
	OPENBSD_5_8:1.88.0.4
	OPENBSD_5_8_BASE:1.88
	OPENBSD_5_7:1.79.0.2
	OPENBSD_5_7_BASE:1.79
	OPENBSD_5_6:1.64.0.4
	OPENBSD_5_6_BASE:1.64
	OPENBSD_5_5:1.59.0.4
	OPENBSD_5_5_BASE:1.59
	OPENBSD_5_4:1.56.0.2
	OPENBSD_5_4_BASE:1.56
	OPENBSD_5_3:1.54.0.2
	OPENBSD_5_3_BASE:1.54
	OPENBSD_5_2:1.50.0.2
	OPENBSD_5_2_BASE:1.50
	OPENBSD_5_1_BASE:1.44
	OPENBSD_5_1:1.44.0.4
	OPENBSD_5_0:1.44.0.2
	OPENBSD_5_0_BASE:1.44
	OPENBSD_4_9:1.40.0.2
	OPENBSD_4_9_BASE:1.40
	OPENBSD_4_8:1.35.0.2
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.28.0.2
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.28.0.4
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.22.0.2
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.19.0.2
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.16.0.2
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.13.0.2
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.12.0.2
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.4
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.7.0.4
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	OPENBSD_3_5:1.2.0.2
	OPENBSD_3_5_BASE:1.2
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.102
date	2016.07.28.21.57.57;	author kettenis;	state Exp;
branches;
next	1.101;
commitid	h0GHFDGWnEdswfbK;

1.101
date	2016.06.28.05.37.50;	author mlarkin;	state Exp;
branches;
next	1.100;
commitid	ok6fKTnq7WY1hK1K;

1.100
date	2016.06.08.01.00.18;	author tedu;	state Exp;
branches;
next	1.99;
commitid	LxnFiNvzZpRlcJBu;

1.99
date	2016.05.30.17.52.26;	author tedu;	state Exp;
branches;
next	1.98;
commitid	m09O7IRRFacwooXV;

1.98
date	2016.05.03.08.30.15;	author kettenis;	state Exp;
branches;
next	1.97;
commitid	MZpYt2QjcBZtOFba;

1.97
date	2016.04.29.16.49.53;	author mpi;	state Exp;
branches;
next	1.96;
commitid	kLGRoBzBa5Gai7Fe;

1.96
date	2016.03.17.13.18.47;	author mpi;	state Exp;
branches;
next	1.95;
commitid	YYXwHgvcvZhstSh4;

1.95
date	2016.02.03.03.25.07;	author guenther;	state Exp;
branches;
next	1.94;
commitid	ApB7haYYMOab9uut;

1.94
date	2015.12.27.04.31.34;	author jsg;	state Exp;
branches;
next	1.93;
commitid	dxEnyjnljo1QbPFz;

1.93
date	2015.12.06.03.14.55;	author dlg;	state Exp;
branches;
next	1.92;
commitid	u2DBgU7yR9kT3PPC;

1.92
date	2015.12.06.01.16.58;	author mlarkin;	state Exp;
branches;
next	1.91;
commitid	tuWELREcxbiJZlI1;

1.91
date	2015.11.23.22.57.12;	author deraadt;	state Exp;
branches;
next	1.90;
commitid	lOkXFQaUGdej50W4;

1.90
date	2015.11.16.10.08.41;	author mpi;	state Exp;
branches;
next	1.89;
commitid	KZ30ShVeuLAwERed;

1.89
date	2015.11.13.07.52.20;	author mlarkin;	state Exp;
branches;
next	1.88;
commitid	KdsjYlqLpqhwOUHf;

1.88
date	2015.07.18.19.21.02;	author sf;	state Exp;
branches;
next	1.87;
commitid	fKIY1z4O2YV68kXY;

1.87
date	2015.07.18.19.19.14;	author sf;	state Exp;
branches;
next	1.86;
commitid	2xGM1gJBLGHVxwpd;

1.86
date	2015.07.18.17.26.09;	author sf;	state Exp;
branches;
next	1.85;
commitid	yXHcYx3WRC35CvGA;

1.85
date	2015.07.18.00.53.37;	author guenther;	state Exp;
branches;
next	1.84;
commitid	ATWH37CkH1qgVxC1;

1.84
date	2015.07.13.17.45.55;	author mikeb;	state Exp;
branches;
next	1.83;
commitid	kMi0tGAac5ZLvFg3;

1.83
date	2015.06.07.06.24.59;	author guenther;	state Exp;
branches;
next	1.82;
commitid	TPuT1ptKkvRzlUfp;

1.82
date	2015.04.18.22.16.21;	author kettenis;	state Exp;
branches;
next	1.81;
commitid	yRnPx9jjsPnb6oP6;

1.81
date	2015.03.25.21.05.18;	author kettenis;	state Exp;
branches;
next	1.80;
commitid	k6HPjf5wfG49EBGs;

1.80
date	2015.03.21.20.42.38;	author kettenis;	state Exp;
branches;
next	1.79;
commitid	tilqEUDj6duaLWpC;

1.79
date	2015.02.11.00.54.39;	author dlg;	state Exp;
branches;
next	1.78;
commitid	6w8JJ0DwXpKXHiTS;

1.78
date	2015.01.16.10.17.51;	author sf;	state Exp;
branches;
next	1.77;
commitid	Mg2nJormk2PyesMj;

1.77
date	2015.01.06.12.50.47;	author dlg;	state Exp;
branches;
next	1.76;
commitid	EAvvmUR28EGEqQFd;

1.76
date	2014.12.18.16.23.26;	author deraadt;	state Exp;
branches;
next	1.75;
commitid	gw4ExnCJDIr6LMDe;

1.75
date	2014.12.18.05.33.48;	author mlarkin;	state Exp;
branches;
next	1.74;
commitid	JVgpC5JUPLFOXy8N;

1.74
date	2014.12.15.01.53.45;	author tedu;	state Exp;
branches;
next	1.73;
commitid	zTvdNqjakdDTl6z6;

1.73
date	2014.12.14.05.04.49;	author guenther;	state Exp;
branches;
next	1.72;
commitid	tJI2pEquN5s3HlpJ;

1.72
date	2014.12.12.16.51.32;	author tedu;	state Exp;
branches;
next	1.71;
commitid	zyldZMVE7Qo1kjvt;

1.71
date	2014.12.02.18.13.10;	author tedu;	state Exp;
branches;
next	1.70;
commitid	ZYUxNRICiD9sC1vn;

1.70
date	2014.11.23.00.25.05;	author guenther;	state Exp;
branches;
next	1.69;
commitid	83mVtEFG1oiGteGB;

1.69
date	2014.11.22.18.31.46;	author mlarkin;	state Exp;
branches;
next	1.68;
commitid	OZhulzwbZ5ey9UWV;

1.68
date	2014.11.21.07.02.11;	author mlarkin;	state Exp;
branches;
next	1.67;
commitid	FDl1j9GPwunzY6im;

1.67
date	2014.11.16.12.30.56;	author deraadt;	state Exp;
branches;
next	1.66;
commitid	yv0ECmCdICvq576h;

1.66
date	2014.10.09.03.59.58;	author tedu;	state Exp;
branches;
next	1.65;
commitid	I0KLtD9aVxAdm6aW;

1.65
date	2014.09.14.14.17.23;	author jsg;	state Exp;
branches;
next	1.64;
commitid	uzzBR7hz9ncd4O6G;

1.64
date	2014.07.10.11.56.56;	author mlarkin;	state Exp;
branches;
next	1.63;
commitid	ywwhG3GQkbaRo0jV;

1.63
date	2014.07.09.16.18.03;	author mlarkin;	state Exp;
branches;
next	1.62;
commitid	a0lYB3DVEaXrgqbj;

1.62
date	2014.07.09.11.37.16;	author mlarkin;	state Exp;
branches;
next	1.61;
commitid	ZzCjmXn3ZAUY3nHp;

1.61
date	2014.04.30.06.24.23;	author sf;	state Exp;
branches;
next	1.60;

1.60
date	2014.03.29.18.09.28;	author guenther;	state Exp;
branches;
next	1.59;

1.59
date	2014.01.19.12.45.35;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2013.12.19.21.30.02;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2013.10.05.16.58.30;	author guenther;	state Exp;
branches;
next	1.56;

1.56
date	2013.06.03.16.55.21;	author guenther;	state Exp;
branches;
next	1.55;

1.55
date	2013.05.30.15.58.06;	author mlarkin;	state Exp;
branches;
next	1.54;

1.54
date	2012.11.02.15.10.28;	author jsg;	state Exp;
branches;
next	1.53;

1.53
date	2012.10.31.03.30.22;	author jsg;	state Exp;
branches;
next	1.52;

1.52
date	2012.10.09.04.40.36;	author jsg;	state Exp;
branches;
next	1.51;

1.51
date	2012.09.19.20.19.31;	author jsg;	state Exp;
branches;
next	1.50;

1.50
date	2012.07.09.15.25.39;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2012.07.09.09.07.27;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2012.04.17.16.02.33;	author guenther;	state Exp;
branches;
next	1.47;

1.47
date	2012.04.04.18.44.22;	author mikeb;	state Exp;
branches;
next	1.46;

1.46
date	2012.03.27.02.23.04;	author haesbaert;	state Exp;
branches;
next	1.45;

1.45
date	2012.02.25.00.12.07;	author haesbaert;	state Exp;
branches;
next	1.44;

1.44
date	2011.04.13.02.49.12;	author guenther;	state Exp;
branches;
next	1.43;

1.43
date	2011.04.10.03.56.38;	author guenther;	state Exp;
branches;
next	1.42;

1.42
date	2011.04.05.21.14.00;	author guenther;	state Exp;
branches;
next	1.41;

1.41
date	2011.03.18.03.10.47;	author guenther;	state Exp;
branches;
next	1.40;

1.40
date	2010.11.27.13.03.04;	author kettenis;	state Exp;
branches;
next	1.39;

1.39
date	2010.11.26.11.59.40;	author krw;	state Exp;
branches;
next	1.38;

1.38
date	2010.11.13.04.16.42;	author guenther;	state Exp;
branches;
next	1.37;

1.37
date	2010.10.26.05.49.10;	author guenther;	state Exp;
branches;
next	1.36;

1.36
date	2010.10.14.04.38.24;	author guenther;	state Exp;
branches;
next	1.35;

1.35
date	2010.07.25.21.43.38;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2010.06.26.23.24.43;	author guenther;	state Exp;
branches;
next	1.33;

1.33
date	2010.05.08.16.54.07;	author oga;	state Exp;
branches;
next	1.32;

1.32
date	2010.04.16.17.44.00;	author kettenis;	state Exp;
branches;
next	1.31;

1.31
date	2010.04.08.19.27.40;	author kettenis;	state Exp;
branches;
next	1.30;

1.30
date	2010.04.07.06.33.06;	author kettenis;	state Exp;
branches;
next	1.29;

1.29
date	2010.04.01.19.47.59;	author kettenis;	state Exp;
branches;
next	1.28;

1.28
date	2009.06.09.02.56.38;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2009.06.06.23.45.35;	author guenther;	state Exp;
branches;
next	1.26;

1.26
date	2009.06.05.10.51.44;	author guenther;	state Exp;
branches;
next	1.25;

1.25
date	2009.05.28.09.05.33;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2009.04.27.17.48.21;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2009.04.23.07.42.02;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2009.02.15.02.03.40;	author marco;	state Exp;
branches;
next	1.21;

1.21
date	2008.10.15.23.23.46;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2008.10.06.20.42.02;	author chl;	state Exp;
branches;
next	1.19;

1.19
date	2008.06.26.05.42.09;	author ray;	state Exp;
branches;
next	1.18;

1.18
date	2008.06.11.09.22.38;	author phessler;	state Exp;
branches;
next	1.17;

1.17
date	2008.04.13.11.35.55;	author thib;	state Exp;
branches;
next	1.16;

1.16
date	2007.11.16.16.16.07;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2007.10.10.15.53.51;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2007.09.17.15.34.38;	author chl;	state Exp;
branches;
next	1.13;

1.13
date	2007.08.02.16.40.27;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2007.01.15.23.19.05;	author jsg;	state Exp;
branches;
next	1.11;

1.11
date	2005.09.25.20.48.18;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2005.07.26.08.38.29;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2005.07.18.02.43.24;	author fgsch;	state Exp;
branches;
next	1.8;

1.8
date	2005.05.24.09.30.32;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2004.07.19.15.09.05;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.08.04.23.04;	author david;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.25.11.03.27;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.24.19.35.23;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.09.10.17.10;	author art;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.23.08.32.36;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.28.01.39.38;	author mickey;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.06.05.23.09.24;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2004.06.06.05.24.37;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.102
log
@Store the acpi processor ID/UID in struct cpu_info, and use it to attach
acpicpu(4) drivers to the right cpu(4).

ok mlarkin@@, guenther@@
@
text
@/*	$OpenBSD: cpu.c,v 1.101 2016/06/28 05:37:50 mlarkin Exp $	*/
/* $NetBSD: cpu.c,v 1.1 2003/04/26 18:39:26 fvdl Exp $ */

/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by RedBack Networks Inc.
 *
 * Author: Bill Sommerfeld
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1999 Stefan Grefen
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the NetBSD
 *      Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR AND CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "lapic.h"
#include "ioapic.h"
#include "vmm.h"

#include <sys/param.h>
#include <sys/timeout.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/memrange.h>
#include <dev/rndvar.h>
#include <sys/atomic.h>

#include <uvm/uvm_extern.h>

#include <machine/codepatch.h>
#include <machine/cpu.h>
#include <machine/cpufunc.h>
#include <machine/cpuvar.h>
#include <machine/pmap.h>
#include <machine/vmparam.h>
#include <machine/mpbiosvar.h>
#include <machine/pcb.h>
#include <machine/specialreg.h>
#include <machine/segments.h>
#include <machine/gdt.h>
#include <machine/pio.h>
#include <machine/vmmvar.h>

#if NLAPIC > 0
#include <machine/apicvar.h>
#include <machine/i82489reg.h>
#include <machine/i82489var.h>
#endif

#if NIOAPIC > 0
#include <machine/i82093var.h>
#endif

#include <dev/ic/mc146818reg.h>
#include <amd64/isa/nvram.h>
#include <dev/isa/isareg.h>

#ifdef HIBERNATE
#include <sys/hibernate.h>
#include <machine/hibernate.h>
#endif /* HIBERNATE */

int     cpu_match(struct device *, void *, void *);
void    cpu_attach(struct device *, struct device *, void *);
int     cpu_activate(struct device *, int);
void	patinit(struct cpu_info *ci);
#if NVMM > 0
void	cpu_init_vmm(struct cpu_info *ci);
#endif /* NVMM > 0 */

struct cpu_softc {
	struct device sc_dev;		/* device tree glue */
	struct cpu_info *sc_info;	/* pointer to CPU info */
};

#ifndef SMALL_KERNEL
void	replacesmap(void);

extern long _stac;
extern long _clac;

void
replacesmap(void)
{
	static int replacedone = 0;
	int s;

	if (replacedone)
		return;
	replacedone = 1;

	s = splhigh();

	codepatch_replace(CPTAG_STAC, &_stac, 3);
	codepatch_replace(CPTAG_CLAC, &_clac, 3);

	splx(s);
}
#endif /* !SMALL_KERNEL */

#ifdef MULTIPROCESSOR
int mp_cpu_start(struct cpu_info *);
void mp_cpu_start_cleanup(struct cpu_info *);
struct cpu_functions mp_cpu_funcs = { mp_cpu_start, NULL,
				      mp_cpu_start_cleanup };
#endif /* MULTIPROCESSOR */

struct cfattach cpu_ca = {
	sizeof(struct cpu_softc), cpu_match, cpu_attach, NULL, cpu_activate
};

struct cfdriver cpu_cd = {
	NULL, "cpu", DV_DULL
};

/*
 * Statically-allocated CPU info for the primary CPU (or the only
 * CPU, on uniprocessors).  The CPU info list is initialized to
 * point at it.
 */
struct cpu_info cpu_info_primary = { 0, &cpu_info_primary };

struct cpu_info *cpu_info_list = &cpu_info_primary;

#ifdef MULTIPROCESSOR
/*
 * Array of CPU info structures.  Must be statically-allocated because
 * curproc, etc. are used early.
 */
struct cpu_info *cpu_info[MAXCPUS] = { &cpu_info_primary };

void    	cpu_hatch(void *);
void    	cpu_boot_secondary(struct cpu_info *ci);
void    	cpu_start_secondary(struct cpu_info *ci);
#endif

int
cpu_match(struct device *parent, void *match, void *aux)
{
	struct cfdata *cf = match;
	struct cpu_attach_args *caa = aux;

	if (strcmp(caa->caa_name, cf->cf_driver->cd_name) != 0)
		return 0;

	if (cf->cf_unit >= MAXCPUS)
		return 0;

	return 1;
}

static void
cpu_vm_init(struct cpu_info *ci)
{
	int ncolors = 2, i;

	for (i = CAI_ICACHE; i <= CAI_L2CACHE; i++) {
		struct x86_cache_info *cai;
		int tcolors;

		cai = &ci->ci_cinfo[i];

		tcolors = atop(cai->cai_totalsize);
		switch(cai->cai_associativity) {
		case 0xff:
			tcolors = 1; /* fully associative */
			break;
		case 0:
		case 1:
			break;
		default:
			tcolors /= cai->cai_associativity;
		}
		ncolors = max(ncolors, tcolors);
	}

#ifdef notyet
	/*
	 * Knowing the size of the largest cache on this CPU, re-color
	 * our pages.
	 */
	if (ncolors <= uvmexp.ncolors)
		return;
	printf("%s: %d page colors\n", ci->ci_dev->dv_xname, ncolors);
	uvm_page_recolor(ncolors);
#endif
}


void	cpu_idle_mwait_cycle(void);
void	cpu_init_mwait(struct cpu_softc *);

u_int	cpu_mwait_size, cpu_mwait_states;

void
cpu_idle_mwait_cycle(void)
{
	struct cpu_info *ci = curcpu();

	if ((read_rflags() & PSL_I) == 0)
		panic("idle with interrupts blocked!");

	/* something already queued? */
	if (!cpu_is_idle(ci))
		return;

	/*
	 * About to idle; setting the MWAIT_IN_IDLE bit tells
	 * cpu_unidle() that it can't be a no-op and tells cpu_kick()
	 * that it doesn't need to use an IPI.  We also set the
	 * MWAIT_KEEP_IDLING bit: those routines clear it to stop
	 * the mwait.  Once they're set, we do a final check of the
	 * queue, in case another cpu called setrunqueue() and added
	 * something to the queue and called cpu_unidle() between
	 * the check in sched_idle() and here.
	 */
	atomic_setbits_int(&ci->ci_mwait, MWAIT_IDLING | MWAIT_ONLY);
	if (cpu_is_idle(ci)) {
		monitor(&ci->ci_mwait, 0, 0);
		if ((ci->ci_mwait & MWAIT_IDLING) == MWAIT_IDLING)
			mwait(0, 0);
	}

	/* done idling; let cpu_kick() know that an IPI is required */
	atomic_clearbits_int(&ci->ci_mwait, MWAIT_IDLING);
}

void
cpu_init_mwait(struct cpu_softc *sc)
{
	unsigned int smallest, largest, extensions, c_substates;

	if ((cpu_ecxfeature & CPUIDECX_MWAIT) == 0 || cpuid_level < 0x5)
		return;

	/* get the monitor granularity */
	CPUID(0x5, smallest, largest, extensions, cpu_mwait_states);
	smallest &= 0xffff;
	largest  &= 0xffff;

	printf("%s: mwait min=%u, max=%u", sc->sc_dev.dv_xname,
	    smallest, largest);
	if (extensions & 0x1) {
		if (cpu_mwait_states > 0) {
			c_substates = cpu_mwait_states;
			printf(", C-substates=%u", 0xf & c_substates);
			while ((c_substates >>= 4) > 0)
				printf(".%u", 0xf & c_substates);
		}
		if (extensions & 0x2)
			printf(", IBE");
	} else {
		/* substates not supported, forge the default: just C1 */
		cpu_mwait_states = 1 << 4;
	}

	/* paranoia: check the values */
	if (smallest < sizeof(int) || largest < smallest ||
	    (largest & (sizeof(int)-1)))
		printf(" (bogus)");
	else
		cpu_mwait_size = largest;
	printf("\n");

	/* enable use of mwait; may be overriden by acpicpu later */
	if (cpu_mwait_size > 0)
		cpu_idle_cycle_fcn = &cpu_idle_mwait_cycle;
}

void
cpu_attach(struct device *parent, struct device *self, void *aux)
{
	struct cpu_softc *sc = (void *) self;
	struct cpu_attach_args *caa = aux;
	struct cpu_info *ci;
#if defined(MULTIPROCESSOR)
	int cpunum = sc->sc_dev.dv_unit;
	vaddr_t kstack;
	struct pcb *pcb;
#endif

	/*
	 * If we're an Application Processor, allocate a cpu_info
	 * structure, otherwise use the primary's.
	 */
	if (caa->cpu_role == CPU_ROLE_AP) {
		ci = malloc(sizeof(*ci), M_DEVBUF, M_WAITOK|M_ZERO);
#if defined(MULTIPROCESSOR)
		if (cpu_info[cpunum] != NULL)
			panic("cpu at apic id %d already attached?", cpunum);
		cpu_info[cpunum] = ci;
#endif
#ifdef TRAPLOG
		ci->ci_tlog_base = malloc(sizeof(struct tlog),
		    M_DEVBUF, M_WAITOK);
#endif
	} else {
		ci = &cpu_info_primary;
#if defined(MULTIPROCESSOR)
		if (caa->cpu_apicid != lapic_cpu_number()) {
			panic("%s: running cpu is at apic %d"
			    " instead of at expected %d",
			    sc->sc_dev.dv_xname, lapic_cpu_number(), caa->cpu_apicid);
		}
#endif
	}

	ci->ci_self = ci;
	sc->sc_info = ci;

	ci->ci_dev = self;
	ci->ci_apicid = caa->cpu_apicid;
	ci->ci_acpi_proc_id = caa->cpu_acpi_proc_id;
#ifdef MULTIPROCESSOR
	ci->ci_cpuid = cpunum;
#else
	ci->ci_cpuid = 0;	/* False for APs, but they're not used anyway */
#endif
	ci->ci_func = caa->cpu_func;
	ci->ci_handled_intr_level = IPL_NONE;

#if defined(MULTIPROCESSOR)
	/*
	 * Allocate UPAGES contiguous pages for the idle PCB and stack.
	 */
	kstack = uvm_km_alloc (kernel_map, USPACE);
	if (kstack == 0) {
		if (caa->cpu_role != CPU_ROLE_AP) {
			panic("cpu_attach: unable to allocate idle stack for"
			    " primary");
		}
		printf("%s: unable to allocate idle stack\n",
		    sc->sc_dev.dv_xname);
		return;
	}
	pcb = ci->ci_idle_pcb = (struct pcb *) kstack;
	memset(pcb, 0, USPACE);

	pcb->pcb_kstack = kstack + USPACE - 16;
	pcb->pcb_rbp = pcb->pcb_rsp = kstack + USPACE - 16;
	pcb->pcb_pmap = pmap_kernel();
	pcb->pcb_cr0 = rcr0();
	pcb->pcb_cr3 = pcb->pcb_pmap->pm_pdirpa;
#endif

	/* further PCB init done later. */

	printf(": ");

	switch (caa->cpu_role) {
	case CPU_ROLE_SP:
		printf("(uniprocessor)\n");
		ci->ci_flags |= CPUF_PRESENT | CPUF_SP | CPUF_PRIMARY;
		cpu_intr_init(ci);
		identifycpu(ci);
#ifdef MTRR
		mem_range_attach();
#endif /* MTRR */
		cpu_init(ci);
		cpu_init_mwait(sc);
		break;

	case CPU_ROLE_BP:
		printf("apid %d (boot processor)\n", caa->cpu_apicid);
		ci->ci_flags |= CPUF_PRESENT | CPUF_BSP | CPUF_PRIMARY;
		cpu_intr_init(ci);
		identifycpu(ci);
#ifdef MTRR
		mem_range_attach();
#endif /* MTRR */
		cpu_init(ci);

#if NLAPIC > 0
		/*
		 * Enable local apic
		 */
		lapic_enable();
		lapic_calibrate_timer(ci);
#endif
#if NIOAPIC > 0
		ioapic_bsp_id = caa->cpu_apicid;
#endif
		cpu_init_mwait(sc);
		break;

	case CPU_ROLE_AP:
		/*
		 * report on an AP
		 */
		printf("apid %d (application processor)\n", caa->cpu_apicid);

#if defined(MULTIPROCESSOR)
		cpu_intr_init(ci);
		gdt_alloc_cpu(ci);
		sched_init_cpu(ci);
		cpu_start_secondary(ci);
		ncpus++;
		if (ci->ci_flags & CPUF_PRESENT) {
			ci->ci_next = cpu_info_list->ci_next;
			cpu_info_list->ci_next = ci;
		}
#else
		printf("%s: not started\n", sc->sc_dev.dv_xname);
#endif
		break;

	default:
		panic("unknown processor type??");
	}
	cpu_vm_init(ci);

#if defined(MULTIPROCESSOR)
	if (mp_verbose) {
		printf("%s: kstack at 0x%lx for %d bytes\n",
		    sc->sc_dev.dv_xname, kstack, USPACE);
		printf("%s: idle pcb at %p, idle sp at 0x%llx\n",
		    sc->sc_dev.dv_xname, pcb, pcb->pcb_rsp);
	}
#endif
#if NVMM > 0
	cpu_init_vmm(ci);
#endif /* NVMM > 0 */
}

/*
 * Initialize the processor appropriately.
 */

void
cpu_init(struct cpu_info *ci)
{
	u_int cr4;

	/* configure the CPU if needed */
	if (ci->cpu_setup != NULL)
		(*ci->cpu_setup)(ci);
	/*
	 * We do this here after identifycpu() because errata may affect
	 * what we do.
	 */
	patinit(ci);

	lcr0(rcr0() | CR0_WP);
	cr4 = rcr4() | CR4_DEFAULT;
	if (ci->ci_feature_sefflags_ebx & SEFF0EBX_SMEP)
		cr4 |= CR4_SMEP;
#ifndef SMALL_KERNEL
	if (ci->ci_feature_sefflags_ebx & SEFF0EBX_SMAP)
		cr4 |= CR4_SMAP;
	if (ci->ci_feature_sefflags_ebx & SEFF0EBX_FSGSBASE)
		cr4 |= CR4_FSGSBASE;
	if (ci->ci_feature_sefflags_ecx & SEFF0ECX_UMIP)
		cr4 |= CR4_UMIP;
#endif
	if (cpu_ecxfeature & CPUIDECX_XSAVE)
		cr4 |= CR4_OSXSAVE;
	lcr4(cr4);

	if ((cpu_ecxfeature & CPUIDECX_XSAVE) && cpuid_level >= 0xd) {
		u_int32_t eax, ebx, ecx, edx;

		xsave_mask = XCR0_X87 | XCR0_SSE;
		CPUID_LEAF(0xd, 0, eax, ebx, ecx, edx);
		if (eax & XCR0_AVX)
			xsave_mask |= XCR0_AVX;
		xsetbv(0, xsave_mask);
		CPUID_LEAF(0xd, 0, eax, ebx, ecx, edx);
		fpu_save_len = ebx;
	}

#if NVMM > 0
	/* Re-enable VMM if needed */
	if (ci->ci_flags & CPUF_VMM)
		start_vmm_on_cpu(ci);
#endif /* NVMM > 0 */

#ifdef MULTIPROCESSOR
	ci->ci_flags |= CPUF_RUNNING;
	tlbflushg();
#endif
}

#if NVMM > 0
/*
 * cpu_init_vmm
 *
 * Initializes per-cpu VMM state
 *
 * Parameters:
 *  ci: the cpu for which state is being initialized
 */
void
cpu_init_vmm(struct cpu_info *ci)
{
	/*
	 * Allocate a per-cpu VMXON region for VMX CPUs
	 */
	if (ci->ci_vmm_flags & CI_VMM_VMX) {
		ci->ci_vmxon_region = (struct vmxon_region *)malloc(PAGE_SIZE,
		    M_DEVBUF, M_WAITOK | M_ZERO);
		if (!pmap_extract(pmap_kernel(), (vaddr_t)ci->ci_vmxon_region,
		    &ci->ci_vmxon_region_pa))
			panic("Can't locate VMXON region in phys mem\n");
	}
}
#endif /* NVMM > 0 */

#ifdef MULTIPROCESSOR
void
cpu_boot_secondary_processors(void)
{
	struct cpu_info *ci;
	u_long i;

	for (i=0; i < MAXCPUS; i++) {
		ci = cpu_info[i];
		if (ci == NULL)
			continue;
		if (ci->ci_idle_pcb == NULL)
			continue;
		if ((ci->ci_flags & CPUF_PRESENT) == 0)
			continue;
		if (ci->ci_flags & (CPUF_BSP | CPUF_SP | CPUF_PRIMARY))
			continue;
		ci->ci_randseed = (arc4random() & 0x7fffffff) + 1;
		cpu_boot_secondary(ci);
	}
}

void
cpu_init_idle_pcbs(void)
{
	struct cpu_info *ci;
	u_long i;

	for (i=0; i < MAXCPUS; i++) {
		ci = cpu_info[i];
		if (ci == NULL)
			continue;
		if (ci->ci_idle_pcb == NULL)
			continue;
		if ((ci->ci_flags & CPUF_PRESENT) == 0)
			continue;
		x86_64_init_pcb_tss_ldt(ci);
	}
}

void
cpu_start_secondary(struct cpu_info *ci)
{
	int i;

	ci->ci_flags |= CPUF_AP;

	pmap_kenter_pa(MP_TRAMPOLINE, MP_TRAMPOLINE, PROT_READ | PROT_EXEC);
	pmap_kenter_pa(MP_TRAMP_DATA, MP_TRAMP_DATA, PROT_READ | PROT_WRITE);

	CPU_STARTUP(ci);

	/*
	 * wait for it to become ready
	 */
	for (i = 100000; (!(ci->ci_flags & CPUF_PRESENT)) && i>0;i--) {
		delay(10);
	}
	if (! (ci->ci_flags & CPUF_PRESENT)) {
		printf("%s: failed to become ready\n", ci->ci_dev->dv_xname);
#if defined(MPDEBUG) && defined(DDB)
		printf("dropping into debugger; continue from here to resume boot\n");
		Debugger();
#endif
	}

	if ((ci->ci_flags & CPUF_IDENTIFIED) == 0) {
		atomic_setbits_int(&ci->ci_flags, CPUF_IDENTIFY);

		/* wait for it to identify */
		for (i = 100000; (ci->ci_flags & CPUF_IDENTIFY) && i > 0; i--)
			delay(10);

		if (ci->ci_flags & CPUF_IDENTIFY)
			printf("%s: failed to identify\n",
			    ci->ci_dev->dv_xname);
	}

	CPU_START_CLEANUP(ci);

	pmap_kremove(MP_TRAMPOLINE, PAGE_SIZE);
	pmap_kremove(MP_TRAMP_DATA, PAGE_SIZE);
}

void
cpu_boot_secondary(struct cpu_info *ci)
{
	int i;

	atomic_setbits_int(&ci->ci_flags, CPUF_GO);

	for (i = 100000; (!(ci->ci_flags & CPUF_RUNNING)) && i>0;i--) {
		delay(10);
	}
	if (! (ci->ci_flags & CPUF_RUNNING)) {
		printf("cpu failed to start\n");
#if defined(MPDEBUG) && defined(DDB)
		printf("dropping into debugger; continue from here to resume boot\n");
		Debugger();
#endif
	}
}

/*
 * The CPU ends up here when it's ready to run
 * This is called from code in mptramp.s; at this point, we are running
 * in the idle pcb/idle stack of the new cpu.  When this function returns,
 * this processor will enter the idle loop and start looking for work.
 *
 * XXX should share some of this with init386 in machdep.c
 */
void
cpu_hatch(void *v)
{
	struct cpu_info *ci = (struct cpu_info *)v;
	int s;

	cpu_init_msrs(ci);

#ifdef DEBUG
	if (ci->ci_flags & CPUF_PRESENT)
		panic("%s: already running!?", ci->ci_dev->dv_xname);
#endif

	ci->ci_flags |= CPUF_PRESENT;

	lapic_enable();
	lapic_startclock();

	if ((ci->ci_flags & CPUF_IDENTIFIED) == 0) {
		/*
		 * We need to wait until we can identify, otherwise dmesg
		 * output will be messy.
		 */
		while ((ci->ci_flags & CPUF_IDENTIFY) == 0)
			delay(10);

		identifycpu(ci);

		/* Signal we're done */
		atomic_clearbits_int(&ci->ci_flags, CPUF_IDENTIFY);
		/* Prevent identifycpu() from running again */
		atomic_setbits_int(&ci->ci_flags, CPUF_IDENTIFIED);
	}

	while ((ci->ci_flags & CPUF_GO) == 0)
		delay(10);
#ifdef HIBERNATE
	if ((ci->ci_flags & CPUF_PARK) != 0) {
		atomic_clearbits_int(&ci->ci_flags, CPUF_PARK);
		hibernate_drop_to_real_mode();
	}
#endif /* HIBERNATE */

#ifdef DEBUG
	if (ci->ci_flags & CPUF_RUNNING)
		panic("%s: already running!?", ci->ci_dev->dv_xname);
#endif

	lcr0(ci->ci_idle_pcb->pcb_cr0);
	cpu_init_idt();
	lapic_set_lvt();
	gdt_init_cpu(ci);
	fpuinit(ci);

	lldt(0);

	cpu_init(ci);

	/* Re-initialise memory range handling on AP */
	if (mem_range_softc.mr_op != NULL)
		mem_range_softc.mr_op->initAP(&mem_range_softc);

	s = splhigh();
	lcr8(0);
	enable_intr();

	nanouptime(&ci->ci_schedstate.spc_runtime);
	splx(s);

	SCHED_LOCK(s);
	cpu_switchto(NULL, sched_chooseproc());
}

#if defined(DDB)

#include <ddb/db_output.h>
#include <machine/db_machdep.h>

/*
 * Dump cpu information from ddb.
 */
void
cpu_debug_dump(void)
{
	struct cpu_info *ci;
	CPU_INFO_ITERATOR cii;

	db_printf("addr		dev	id	flags	ipis	curproc		fpcurproc\n");
	CPU_INFO_FOREACH(cii, ci) {
		db_printf("%p	%s	%u	%x	%x	%10p	%10p\n",
		    ci,
		    ci->ci_dev == NULL ? "BOOT" : ci->ci_dev->dv_xname,
		    ci->ci_cpuid,
		    ci->ci_flags, ci->ci_ipis,
		    ci->ci_curproc,
		    ci->ci_fpcurproc);
	}
}
#endif

int
mp_cpu_start(struct cpu_info *ci)
{
	unsigned short dwordptr[2];

	/*
	 * "The BSP must initialize CMOS shutdown code to 0Ah ..."
	 */

	outb(IO_RTC, NVRAM_RESET);
	outb(IO_RTC+1, NVRAM_RESET_JUMP);

	/*
	 * "and the warm reset vector (DWORD based at 40:67) to point
	 * to the AP startup code ..."
	 */

	dwordptr[0] = 0;
	dwordptr[1] = MP_TRAMPOLINE >> 4;

	pmap_kenter_pa(0, 0, PROT_READ | PROT_WRITE);
	memcpy((u_int8_t *) 0x467, dwordptr, 4);
	pmap_kremove(0, PAGE_SIZE);

#if NLAPIC > 0
	/*
	 * ... prior to executing the following sequence:"
	 */

	if (ci->ci_flags & CPUF_AP) {
		x86_ipi_init(ci->ci_apicid);

		delay(10000);

		if (cpu_feature & CPUID_APIC) {
			x86_ipi(MP_TRAMPOLINE/PAGE_SIZE, ci->ci_apicid,
			    LAPIC_DLMODE_STARTUP);
			delay(200);

			x86_ipi(MP_TRAMPOLINE/PAGE_SIZE, ci->ci_apicid,
			    LAPIC_DLMODE_STARTUP);
			delay(200);
		}
	}
#endif
	return 0;
}

void
mp_cpu_start_cleanup(struct cpu_info *ci)
{
	/*
	 * Ensure the NVRAM reset byte contains something vaguely sane.
	 */

	outb(IO_RTC, NVRAM_RESET);
	outb(IO_RTC+1, NVRAM_RESET_RST);
}
#endif	/* MULTIPROCESSOR */

typedef void (vector)(void);
extern vector Xsyscall, Xsyscall32;

void
cpu_init_msrs(struct cpu_info *ci)
{
	wrmsr(MSR_STAR,
	    ((uint64_t)GSEL(GCODE_SEL, SEL_KPL) << 32) |
	    ((uint64_t)GSEL(GUCODE32_SEL, SEL_UPL) << 48));
	wrmsr(MSR_LSTAR, (uint64_t)Xsyscall);
	wrmsr(MSR_CSTAR, (uint64_t)Xsyscall32);
	wrmsr(MSR_SFMASK, PSL_NT|PSL_T|PSL_I|PSL_C|PSL_D);

	wrmsr(MSR_FSBASE, 0);
	wrmsr(MSR_GSBASE, (u_int64_t)ci);
	wrmsr(MSR_KERNELGSBASE, 0);
}

void
patinit(struct cpu_info *ci)
{
	extern int	pmap_pg_wc;
	u_int64_t	reg;

	if ((ci->ci_feature_flags & CPUID_PAT) == 0)
		return;
	/*
	 * Set up PAT bits.
	 * The default pat table is the following:
	 * WB, WT, UC- UC, WB, WT, UC-, UC
	 * We change it to:
	 * WB, WC, UC-, UC, WB, WC, UC-, UC.
	 * i.e change the WT bit to be WC.
	 */
	reg = PATENTRY(0, PAT_WB) | PATENTRY(1, PAT_WC) |
	    PATENTRY(2, PAT_UCMINUS) | PATENTRY(3, PAT_UC) |
	    PATENTRY(4, PAT_WB) | PATENTRY(5, PAT_WC) |
	    PATENTRY(6, PAT_UCMINUS) | PATENTRY(7, PAT_UC);

	wrmsr(MSR_CR_PAT, reg);
	pmap_pg_wc = PG_WC;
}

struct timeout rdrand_tmo;
void rdrand(void *);

void
rdrand(void *v)
{
	struct timeout *tmo = v;
	extern int	has_rdrand, has_rdseed;
	union {
		uint64_t u64;
		uint32_t u32[2];
	} r, t;
	uint8_t valid = 0;

	if (has_rdseed)
		__asm volatile(
		    "rdseed	%0\n\t"
		    "setc	%1\n"
		    : "=r" (r.u64), "=qm" (valid) );
	if (has_rdrand && (has_rdseed == 0 || valid == 0))
		__asm volatile(
		    "rdrand	%0\n\t"
		    "setc	%1\n"
		    : "=r" (r.u64), "=qm" (valid) );

	t.u64 = rdtsc();

	if (valid)
		t.u64 ^= r.u64;
	add_true_randomness(t.u32[0]);
	add_true_randomness(t.u32[1]);

	if (tmo)
		timeout_add_msec(tmo, 10);
}

int
cpu_activate(struct device *self, int act)
{
	struct cpu_softc *sc = (struct cpu_softc *)self;

	switch (act) {
	case DVACT_RESUME:
		if (sc->sc_info->ci_cpuid == 0)
			rdrand(NULL);
		break;
	}

	return (0);
}
@


1.101
log
@
Enable UMIP feature if present. miod originally pointed this out to me.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.100 2016/06/08 01:00:18 tedu Exp $	*/
d352 1
a352 1
		if (caa->cpu_number != lapic_cpu_number()) {
d355 1
a355 1
			    sc->sc_dev.dv_xname, lapic_cpu_number(), caa->cpu_number);
d364 2
a365 1
	ci->ci_apicid = caa->cpu_number;
d416 1
a416 1
		printf("apid %d (boot processor)\n", caa->cpu_number);
d433 1
a433 1
		ioapic_bsp_id = caa->cpu_number;
d442 1
a442 1
		printf("apid %d (application processor)\n", caa->cpu_number);
@


1.100
log
@reporting a different issue, bluhm noticed that valid is not initialized.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.99 2016/05/30 17:52:26 tedu Exp $	*/
d503 2
@


1.99
log
@include rdtsc in the rdrand callback. some systems don't have rdrand yet,
but rdtsc may provide a few bits. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.98 2016/05/03 08:30:15 kettenis Exp $	*/
d883 1
a883 1
	uint8_t valid;
@


1.98
log
@Revert previous commit.  Calling sched_init_cpu() from
cpu_boot_secondary_processors() break suspend/resume.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.97 2016/04/29 16:49:53 mpi Exp $	*/
d882 1
a882 1
	} r;
a883 1
	int i;
d885 17
a901 18
	if (has_rdrand == 0 && has_rdseed == 0)
		return;
	for (i = 0; i < 2; i++) {
		if (has_rdseed)
			__asm volatile(
			    "rdseed	%0\n\t"
			    "setc	%1\n"
			    : "=r" (r.u64), "=qm" (valid) );
		if (has_rdseed == 0 || valid == 0)
			__asm volatile(
			    "rdrand	%0\n\t"
			    "setc	%1\n"
			    : "=r" (r.u64), "=qm" (valid) );
		if (valid) {
			add_true_randomness(r.u32[0]);
			add_true_randomness(r.u32[1]);
		}
	}
@


1.97
log
@Call sched_init_cpu() just before booting secondary CPUs.

This prevent the scheduler from scheduling tasks to CPUs not beeing able
to execute them during the boot process.

ok visa@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.96 2016/03/17 13:18:47 mpi Exp $	*/
d446 1
a573 1
		sched_init_cpu(ci);
@


1.96
log
@Replace curcpu_is_idle() by cpu_is_idle() and use it instead of rolling
our own.

From Michal Mazurek, ok mmcc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.95 2016/02/03 03:25:07 guenther Exp $	*/
a445 1
		sched_init_cpu(ci);
d573 1
@


1.95
log
@Test cpuid_level or ci->ci_pnfeatset before using a CPUID leaf; some BIOSes
can disable leaves that CPU feature flags would seem to imply.  Corrects
signal delivery on systems where the AVX leaf is disabled.

report and debugging help from Marcus MERIGHI (mcmer-openbsd (at) tor.at)
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.94 2015/12/27 04:31:34 jsg Exp $	*/
d256 1
a256 1
	if (ci->ci_schedstate.spc_whichqs != 0)
d270 1
a270 1
	if (ci->ci_schedstate.spc_whichqs == 0) {
@


1.94
log
@If available prefer the rdseed instruction over rdrand when adding entropy
to the kernel rng.  If the rdseed source is empty fallback to rdrand
as suggested by naddy.  rdrand output comes from a prng that is
periodically reseeded.  rdseed should give us more bits of entropy.

ok naddy@@ djm@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.93 2015/12/06 03:14:55 dlg Exp $	*/
d285 1
a285 1
	if ((cpu_ecxfeature & CPUIDECX_MWAIT) == 0)
d508 1
a508 1
	if (cpu_ecxfeature & CPUIDECX_XSAVE) {
@


1.93
log
@unbreak kernel link if vmm isnt being built as part of the kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.92 2015/12/06 01:16:58 mlarkin Exp $	*/
d878 1
a878 1
	extern int	has_rdrand;
d883 1
a883 1
	uint64_t valid;
d886 1
a886 1
	if (has_rdrand == 0)
d889 10
a898 6
		__asm volatile(
		    "xor	%1, %1\n\t"
		    "rdrand	%0\n\t"
		    "rcl	$1, %1\n"
		    : "=r" (r.u64), "=r" (valid) );

@


1.92
log
@
restore VMM mode after resume from suspend/hibernate
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.91 2015/11/23 22:57:12 deraadt Exp $	*/
d520 1
d524 1
@


1.91
log
@No longer need 'option VMM', declaring the vmm0 device is sufficient.
ok mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.90 2015/11/16 10:08:41 mpi Exp $	*/
d94 1
d519 4
@


1.90
log
@Some minor tweaks:

- Add $OpenBSD$ tag,
- constify "struct cfattach",
- Use <uvm/uvm_extern.h> rather than <uvm/uvm.h>, it's enough.
- Keep the "struct vm" private.  This allows us to not pull <uvm/uvm_extern.h>
  in <macine/vmmvar.h>
- Prefer DPRINTF() for debug macro as dprintf(3) is a standard function name.
- Add vmm_debug and fix VMM_DEBUG build
- Remove unneeded <sys/rwlock.h> from <machine/vmmvar.h>
- Kill whitespaces

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.89 2015/11/13 07:52:20 mlarkin Exp $	*/
d118 1
a118 1
#ifdef VMM
d120 1
a120 1
#endif /* VMM */
d470 1
a470 1
#ifdef VMM
d472 1
a472 1
#endif /* VMM */
d525 1
a525 1
#ifdef VMM
d548 1
a548 1
#endif /* VMM */
@


1.89
log
@
vmm(4) kernel code

circulated on hackers@@, no objections. Disabled by default.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.88 2015/07/18 19:21:02 sf Exp $	*/
d545 1
a545 1
			panic("Can't locate VMXON region in phys mem\n");	
@


1.88
log
@Make {x86,i82489,x2apic,i386}_ipi return void

They always returned 0

ok mlarkin@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.87 2015/07/18 19:19:14 sf Exp $	*/
d69 1
d118 3
d470 3
d495 1
a495 1
	if (ci->ci_feature_sefflags & SEFF0EBX_SMEP)
d498 1
a498 1
	if (ci->ci_feature_sefflags & SEFF0EBX_SMAP)
d500 1
a500 1
	if (ci->ci_feature_sefflags & SEFF0EBX_FSGSBASE)
d525 24
a846 7
#define	PATENTRY(n, type)	(type << ((n) * 8))
#define	PAT_UC		0x0UL
#define	PAT_WC		0x1UL
#define	PAT_WT		0x4UL
#define	PAT_WP		0x5UL
#define	PAT_WB		0x6UL
#define	PAT_UCMINUS	0x7UL
@


1.87
log
@Make *_ipi_init return void on i386/amd64

They always returned 0

ok mlarkin@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.86 2015/07/18 17:26:09 sf Exp $	*/
a732 3
#if NLAPIC > 0
	int error;
#endif
d765 2
a766 4
			if ((error = x86_ipi(MP_TRAMPOLINE/PAGE_SIZE,
					     ci->ci_apicid,
					     LAPIC_DLMODE_STARTUP)) != 0)
				return error;
d769 2
a770 4
			if ((error = x86_ipi(MP_TRAMPOLINE/PAGE_SIZE,
					     ci->ci_apicid,
					     LAPIC_DLMODE_STARTUP)) != 0)
				return error;
@


1.86
log
@unexpand spaces to tabs
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.85 2015/07/18 00:53:37 guenther Exp $	*/
d763 1
a763 2
		if ((error = x86_ipi_init(ci->ci_apicid)) != 0)
			return error;
@


1.85
log
@Set all the cr4 bits we want at once, instead of one by one

ok jsg@@ mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.84 2015/07/13 17:45:55 mikeb Exp $	*/
d566 2
a567 2
        pmap_kenter_pa(MP_TRAMPOLINE, MP_TRAMPOLINE, PROT_READ | PROT_EXEC);
        pmap_kenter_pa(MP_TRAMP_DATA, MP_TRAMP_DATA, PROT_READ | PROT_WRITE);
@


1.84
log
@remove unused cpu_copy_trampoline;  ok mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.83 2015/06/07 06:24:59 guenther Exp $	*/
d143 1
a143 1
	
d475 2
d487 3
a489 2
	lcr4(rcr4() | CR4_DEFAULT |
	    (ci->ci_feature_sefflags & SEFF0EBX_SMEP ? CR4_SMEP : 0));
d492 7
a498 2
		lcr4(rcr4() | CR4_SMAP);
#endif
a502 1
		lcr4(rcr4() | CR4_OSXSAVE);
d831 1
a831 1
	/* 
@


1.83
log
@Enable use of mwait in non-MP boxes and report # of C-substates up to C7,
truncating trailing zeros.

Testing by many as part of a larger change to use ACPI _CST objects
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.82 2015/04/18 22:16:21 kettenis Exp $	*/
a181 1
void		cpu_copy_trampoline(void);
a721 36

void
cpu_copy_trampoline(void)
{
	/*
	 * Copy boot code.
	 */
	extern u_char cpu_spinup_trampoline[];
	extern u_char cpu_spinup_trampoline_end[];
	extern u_char mp_tramp_data_start[];
	extern u_char mp_tramp_data_end[];

	extern u_int32_t mp_pdirpa;
	extern paddr_t tramp_pdirpa;

	memcpy((caddr_t)MP_TRAMPOLINE,
	    cpu_spinup_trampoline,
	    cpu_spinup_trampoline_end-cpu_spinup_trampoline);

	pmap_kenter_pa(MP_TRAMP_DATA, MP_TRAMP_DATA,
		PROT_READ | PROT_WRITE);
	memcpy((caddr_t)MP_TRAMP_DATA,
		mp_tramp_data_start,
		mp_tramp_data_end - mp_tramp_data_start);

	/*
	 * We need to patch this after we copy the tramp data,
	 * the symbol points into the copied tramp data page.
	 */
	mp_pdirpa = tramp_pdirpa;

	/* Unmap, will be remapped in cpu_start_secondary */
	pmap_kremove(MP_TRAMPOLINE, PAGE_SIZE);
	pmap_kremove(MP_TRAMP_DATA, PAGE_SIZE);
}

@


1.82
log
@It seems that the CPUID lies about the monitor-line size, or at least our
interpretation of it isn't quite right.  So instead of allocating memory
and slicing it based on the parameters returned by CPUID, simply use a member
in struct cpu_info like basically all other OSes out there do.  Our struct
cpu_info is large enough to never cause any overlap.  This makes the
mwait-based idle loop actually work.  We still execute the CPUID instruction
to make sure monitor/mwait is properly supported by the hardware we're
running on.

ok sthen@@, deraadt@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.81 2015/03/25 21:05:18 kettenis Exp $	*/
d237 1
a237 1
#if defined(MULTIPROCESSOR)
d240 2
a241 1
void	cpu_enable_mwait(void);
d265 1
a265 1
	atomic_setbits_int(&ci->ci_mwait, MWAIT_IDLING);
a275 2
u_int cpu_mwait_size;

d285 1
a285 1
	CPUID(0x5, smallest, largest, extensions, c_substates);
d292 6
a297 6
		printf(", C-substates=%u.%u.%u.%u.%u",
		    0xf & (c_substates),
		    0xf & (c_substates >> 4),
		    0xf & (c_substates >> 8),
		    0xf & (c_substates >> 12),
		    0xf & (c_substates >> 16));
d300 3
a311 1
}
d313 1
a313 3
void
cpu_enable_mwait(void)
{
a316 1
#endif /* MULTIPROCESSOR */
d407 1
a429 1
#if defined(MULTIPROCESSOR)
a430 1
#endif
a518 2

	cpu_enable_mwait();
@


1.81
log
@Save/restore AVX registers and other XSAVE-managed state information when
entering/leaving a signal handler like we already do the the FPU and SSE
state.  This should make it possible to use AVX instructions in signal
handlers.

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.80 2015/03/21 20:42:38 kettenis Exp $	*/
a245 1
	volatile int *state = &ci->ci_mwait[0];
d264 1
a264 1
	atomic_setbits_int(state, MWAIT_IDLING);
d266 2
a267 2
		monitor(state, 0, 0);
		if ((*state & MWAIT_IDLING) == MWAIT_IDLING)
d272 1
a272 1
	atomic_clearbits_int(state, MWAIT_IDLING);
d275 1
a275 1
unsigned int mwait_size;
d308 1
a308 1
		mwait_size = largest;
a309 2
	/* XXX disable mwait: ACPI says not to use it on too many systems */
	mwait_size = 0;
d315 1
a315 23
	unsigned long area;
	struct cpu_info *ci;
	CPU_INFO_ITERATOR cii;

	if (mwait_size == 0)
		return;

	/*
	 * Allocate the area, with a bit extra so that we can align
	 * to a multiple of mwait_size
	 */
	area = (unsigned long)malloc((ncpus * mwait_size) + mwait_size
	    - sizeof(int), M_DEVBUF, M_NOWAIT|M_ZERO);
	if (area == 0) {
		printf("cpu0: mwait failed\n");
	} else {
		/* round to a multiple of mwait_size  */
		area = ((area + mwait_size - sizeof(int)) / mwait_size)
		    * mwait_size;
		CPU_INFO_FOREACH(cii, ci) {
			ci->ci_mwait = (int *)area;
			area += mwait_size;
		}
a316 1
	}
@


1.80
log
@Add support for saving/restoring FPU state using the XSAVE/XRSTOR.  Limit
support to the X87, SSE and AVX state.

This gives us (almost) full AVX support.  The AVX state isn't saved by
signal handlers yet, and ptrace(2) support is still missing.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.79 2015/02/11 00:54:39 dlg Exp $	*/
a504 2
	extern uint64_t xsave_mask;

d531 2
@


1.79
log
@need sys/atomic.h for atomic_{set,clear}bits_int.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.78 2015/01/16 10:17:51 sf Exp $	*/
d505 2
d523 11
@


1.78
log
@Binary code patching on amd64

This commit adds generic infrastructure to do binary code patching on amd64.
The existing code patching for SMAP is converted to the new infrastruture.

More consumers and support for i386 will follow later.

This version of the diff has some simplifications in codepatch_fill_nop()
compared to a version that was:

OK @@kettenis @@mlarkin @@jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.77 2015/01/06 12:50:47 dlg Exp $	*/
d77 1
@


1.77
log
@when we're entering an interrupt handler, record its ipl so splassert
can check if we're entering code we think should only be used from
lower ipls.

modelled a bit on how sparc64 does things.

with help from and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.76 2014/12/18 16:23:26 deraadt Exp $	*/
d80 1
a124 8
extern long _copyout_stac;
extern long _copyout_clac;
extern long _copyin_stac;
extern long _copyin_clac;
extern long _copy_fault_clac;
extern long _copyoutstr_stac;
extern long _copyinstr_stac;
extern long _copystr_fault_clac;
a127 14
static const struct {
	void *daddr;
	void *saddr;
} ireplace[] = {
	{ &_copyout_stac, &_stac },
	{ &_copyout_clac, &_clac },
	{ &_copyin_stac, &_stac },
	{ &_copyin_clac, &_clac },
	{ &_copy_fault_clac, &_clac },
	{ &_copyoutstr_stac, &_stac },
	{ &_copyinstr_stac, &_stac },
	{ &_copystr_fault_clac, &_clac },
};

d132 1
a132 2
	int i, s;
	vaddr_t nva;
a138 20
	/*
	 * Create writeable aliases of memory we need
	 * to write to as kernel is mapped read-only
	 */
	nva = (vaddr_t)km_alloc(2 * PAGE_SIZE, &kv_any, &kp_none, &kd_waitok);

	for (i = 0; i < nitems(ireplace); i++) {
		paddr_t kva = trunc_page((paddr_t)ireplace[i].daddr);
		paddr_t po = (paddr_t)ireplace[i].daddr & PAGE_MASK;
		paddr_t pa1, pa2;

		pmap_extract(pmap_kernel(), kva, &pa1);
		pmap_extract(pmap_kernel(), kva + PAGE_SIZE, &pa2);
		pmap_kenter_pa(nva, pa1, PROT_READ | PROT_WRITE);
		pmap_kenter_pa(nva + PAGE_SIZE, pa2, PROT_READ | PROT_WRITE);
		pmap_update(pmap_kernel());

		/* replace 3 byte nops with stac/clac instructions */
		memcpy((void *)(nva + po), ireplace[i].saddr, 3);
	}
d140 2
a141 1
	km_free((void *)nva, 2 * PAGE_SIZE, &kv_any, &kp_none);
@


1.76
log
@If support is present, use rdrand() at resume time.  Make the rdrand()
function easier to call.
ok reyk djm
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.75 2014/12/18 05:33:48 mlarkin Exp $	*/
d435 1
@


1.75
log
@
Unmap the MP hatch and ACPI resume trampolines when not in active use.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.74 2014/12/15 01:53:45 tedu Exp $	*/
d113 1
d196 1
a196 1
	sizeof(struct cpu_softc), cpu_match, cpu_attach
d942 1
d950 2
d965 17
a981 1
	timeout_add_msec(tmo, 10);
@


1.74
log
@change bcopy to memcpy. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.73 2014/12/14 05:04:49 guenther Exp $	*/
a221 12

/*
 * Runs once per boot once multiprocessor goo has been detected and
 * the local APIC on the boot processor has been mapped.
 *
 * Called from lapic_boot_init() (from mpbios_scan()).
 */
void
cpu_init_first(void)
{
	cpu_copy_trampoline();
}
d616 3
d648 3
d810 3
a812 3
	/* Remap the trampoline RX */
	pmap_kenter_pa(MP_TRAMPOLINE, MP_TRAMPOLINE,
		PROT_READ | PROT_EXEC);
@


1.73
log
@Disable MWAIT again, this time on both i386 and amd64.  Too many systems
run excessively hot with it to have it on by default, and I still don't
have good logic to let acpicpu enable it when the AML says it's good.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.72 2014/12/12 16:51:32 tedu Exp $	*/
d178 1
a178 1
		bcopy(ireplace[i].saddr, (void *)(nva + po), 3);
@


1.72
log
@oops, i was not supposed to disable mwait. found by stsp
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.71 2014/12/02 18:13:10 tedu Exp $	*/
d362 2
@


1.71
log
@delete all the simplelocks. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.70 2014/11/23 00:25:05 guenther Exp $	*/
a335 2

	return;
@


1.70
log
@Make sure the direction bit is cleared on entry to the kernel by syscall
or interrupt, as specified by the ABIs.  Our current gcc doesn't assume
this bit of the ABI, but future compilers may and some ASM can be
simplified by assuming it.

in snaps for a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.69 2014/11/22 18:31:46 mlarkin Exp $	*/
a445 2

	simple_lock_init(&ci->ci_slock);
@


1.69
log
@
Split the MP trampoline into two pages, one for code and one for data/stack
and then protect the code page as RX and the data/stack page as RW (NX).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.68 2014/11/21 07:02:11 mlarkin Exp $	*/
d903 1
a903 1
	wrmsr(MSR_SFMASK, PSL_NT|PSL_T|PSL_I|PSL_C);
@


1.68
log
@
Since we enable NX in locore now, no need to do it again later in the
bootstrap sequence

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.67 2014/11/16 12:30:56 deraadt Exp $	*/
d796 2
d806 6
d813 2
a814 2
	 * We need to patch this after we copy the trampoline,
	 * the symbol points into the copied trampoline.
d817 4
@


1.67
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.66 2014/10/09 03:59:58 tedu Exp $	*/
a895 3

	if (cpu_feature & CPUID_NXE)
		wrmsr(MSR_EFER, rdmsr(MSR_EFER) | EFER_NXE);
@


1.66
log
@remove LKM devices
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.65 2014/09/14 14:17:23 jsg Exp $	*/
d173 2
a174 3
		pmap_kenter_pa(nva, pa1, VM_PROT_READ | VM_PROT_WRITE);
		pmap_kenter_pa(nva + PAGE_SIZE, pa2, VM_PROT_READ | 
		    VM_PROT_WRITE);
d835 1
a835 1
	pmap_kenter_pa(0, 0, VM_PROT_READ|VM_PROT_WRITE);
@


1.65
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.64 2014/07/10 11:56:56 mlarkin Exp $	*/
d337 2
@


1.64
log
@
Clear CPUF_PARK flag to avoid re-parking on resume.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.63 2014/07/09 16:18:03 mlarkin Exp $	*/
d71 1
a71 1
#include <sys/proc.h>
@


1.63
log
@

CPUF_PARK check was placed improperly in the previous commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.62 2014/07/09 11:37:16 mlarkin Exp $	*/
d724 2
a725 1
	if ((ci->ci_flags & CPUF_PARK) != 0)
d727 1
@


1.62
log
@
Fixes a hibernate issue wherein we locked the kernel lock while hatching
but then parked ourselves in real mode without completing acquisition of
said lock. Also removes the park routine from i386 since we don't need it
(the APs are already parked at the time we start unpack).

discussed with and ok kettenis@@, also ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.61 2014/04/30 06:24:23 sf Exp $	*/
a712 5
#ifdef HIBERNATE
		if ((ci->ci_flags & CPUF_PARK) != 0)
			hibernate_drop_to_real_mode();
#endif /* HIBERNATE */

d723 5
@


1.61
log
@format string fixes for (u)int64 vars

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.60 2014/03/29 18:09:28 guenther Exp $	*/
d106 5
d597 1
a597 1
		if (ci->ci_flags & (CPUF_BSP|CPUF_SP|CPUF_PRIMARY))
d712 5
@


1.60
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.59 2014/01/19 12:45:35 deraadt Exp $	*/
d538 1
a538 1
		printf("%s: idle pcb at %p, idle sp at 0x%lx\n",
@


1.59
log
@Initialize ci_randseed better using arc4random() + a trick.  Remove the
libkern srandom() API since it is not suitable for this use.
ok kettenis miod
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.58 2013/12/19 21:30:02 deraadt Exp $	*/
d935 1
a935 1
		__asm __volatile(
@


1.58
log
@Mtrr stops being a pseudo-device.  We need to probe the cpu type and
initialize the structures when we see the first cpu.  We also need to
initialize each cpu's properly (for PAT) before we setup mtrr on that
cpu.  On i386 (late hatch) we were getting this desperately wrong on
the primary cpu.

After suspend/resume, we also need to do the same work.  re-initialize
PAT before mtrr.  On some laptops apparently PAT was not turned on by the
BIOS, so we ended up with incorrect setup for the primary cpu.  Oops.

This makes mplayer on the x201 (and similar) machines work without weird
pauses after a suspend/resume.  Many other things are likely fixed.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.57 2013/10/05 16:58:30 guenther Exp $	*/
d76 1
a104 1
#include <dev/rndvar.h>
d594 1
a594 1
		ci->ci_randseed = random();
@


1.57
log
@Use monitor/mwait to idle when available.  Make cpu_unidle() do nothing
if can tell the target CPU isn't actually idling and introduce cpu_kick()
for the cases where we want to force a non-idle CPU into the kernel.

critical review of early versions by weingart@@; testing by many
ok haesbaert@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.56 2013/06/03 16:55:21 guenther Exp $	*/
d477 3
d488 3
d731 2
a735 2

	cpu_init(ci);
@


1.56
log
@Convert some internal APIs to use timespecs instead of timevals

ok matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.55 2013/05/30 15:58:06 mlarkin Exp $	*/
d284 106
d497 3
d575 2
@


1.55
log
@

fix typos in some comments
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.54 2012/11/02 15:10:28 jsg Exp $	*/
d624 1
a624 1
	microuptime(&ci->ci_schedstate.spc_runtime);
@


1.54
log
@uvm_km_alloc() allocs bytes rounded up to the nearest page not pages.
Problem spotted by and diff to fix this (and convert to km_alloc) from oga

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.53 2012/10/31 03:30:22 jsg Exp $	*/
d558 1
a558 1
 * The CPU ends up here when its ready to run
@


1.53
log
@Add support for Intel's Supervisor Mode Access Prevention (SMAP) feature.
When enabled SMAP will generate page faults on the kernel attempting
to read/write user data pages unless an override flag is set.

Instructions that modify the flag are patched into copyin/copyout and
friends on boot if SMAP is enabled.

Those with access to hardware with SMAP can contact me for a test case.

joint work with deraadt@@

ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.52 2012/10/09 04:40:36 jsg Exp $	*/
d159 1
a159 1
	nva = uvm_km_valloc(kernel_map, 2);
d177 1
a177 1
	uvm_km_free(kernel_map, nva, 2);
@


1.52
log
@Enable Supervisor Mode Execution Protection (SMEP), found in recent
Intel chips.  If the kernel is tricked into running code from a user
page while in supervisor mode we'll now get a page fault and panic
instead of running it.

suggestions and ok guenther@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.51 2012/09/19 20:19:31 jsg Exp $	*/
d115 68
d448 4
@


1.51
log
@Add support for the rdrand instruction found in recent Intel processors.
Joint work with naddy@@

ok naddy@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.50 2012/07/09 15:25:39 deraadt Exp $	*/
d378 2
a379 1
	lcr4(rcr4() | CR4_DEFAULT);
@


1.50
log
@After a resume, re-initialize the MTRR registers on the AP processors
as well.  This fixes very slow performance due to lots of uncached
memory on buggy machines, for instance on very large memory thinkpad
W500 and such.
ok mlarkin kettenis sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.49 2012/07/09 09:07:27 deraadt Exp $	*/
d104 1
d728 30
@


1.49
log
@Do not re-initialize ci_randseed on the primary cpu
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.48 2012/04/17 16:02:33 guenther Exp $	*/
d75 1
d539 4
@


1.48
log
@Don't try to cache the CPU's FS.base, as userland can make it a lie by
setting %fs, resulting in it not getting restored properly later

ok mikeb@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.47 2012/04/04 18:44:22 mikeb Exp $	*/
a395 1
		ci->ci_randseed = random();
d402 1
@


1.47
log
@Make sure that identifycpu() is run only once; fixes occasional
hangs on resume.  Discussed with and ok kettenis, haesbaert
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.46 2012/03/27 02:23:04 haesbaert Exp $	*/
a683 1
	ci->ci_cur_fsbase = 0;
@


1.46
log
@Run identifycpu() on its own cpu.
Discussed with many on hackers.

"Go ahead" kettenis@@
"Get to it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.45 2012/02/25 00:12:07 haesbaert Exp $	*/
d448 2
a449 1
	atomic_setbits_int(&ci->ci_flags, CPUF_IDENTIFY);
d451 8
a458 8
	/*
	 * wait for it to identify
	 */
	for (i = 100000; (ci->ci_flags & CPUF_IDENTIFY) && i > 0; i--)
		delay(10);
	
	if (ci->ci_flags & CPUF_IDENTIFY)
		printf("%s: failed to identify\n", ci->ci_dev->dv_xname);
d508 7
a514 4
	/* We need to wait until we can identify, otherwise dmesg output 
	 * will be messy. */
	while ((ci->ci_flags & CPUF_IDENTIFY) == 0)
		delay(10);
d516 1
a516 1
	identifycpu(ci);
d518 5
a522 2
	/* Signal we're done */
	atomic_clearbits_int(&ci->ci_flags, CPUF_IDENTIFY);
@


1.45
log
@Make CPUF_GO setting atomic.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.44 2011/04/13 02:49:12 guenther Exp $	*/
a335 1
			identifycpu(ci);
d448 11
a496 3
	cpu_probe_features(ci);
	cpu_feature &= ci->ci_feature_flags;

d506 10
@


1.44
log
@Unrevert the FS.base diff: the issues were actually elsewhere
Additional testing by jasper@@ and pea@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.43 2011/04/10 03:56:38 guenther Exp $	*/
d457 1
a457 1
	ci->ci_flags |= CPUF_GO; /* XXX atomic */
@


1.43
log
@Revert bulk of the FS.base diff, as it causes issues on some machines
and the problem isn't obvious yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.42 2011/04/05 21:14:00 guenther Exp $	*/
d660 1
@


1.42
log
@Add support for per-rthread base-offset for the %fs selector on amd64.
Add pcb_fsbase to the PCB for tracking what the value for the thread
is, and ci_cur_fsbase to struct cpu_info for tracking the CPU's current
value for FS.base, then on return to user-space, skip the setting if the
CPU has the right value already.  Non-threaded processes without TLS leave
FS.base zero, which can be conveniently optimized: setting %fs zeros
FS.base for fewer cycles than wrmsr.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.41 2011/03/18 03:10:47 guenther Exp $	*/
a659 1
	ci->ci_cur_fsbase = 0;
@


1.41
log
@Old-style MTRRs were never used on amd64, so remove the remaining traces
of them, as well as some other unused proc md_flags bits: MDP_COMPAT and
MDP_SYSCALL.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.40 2010/11/27 13:03:04 kettenis Exp $	*/
d660 1
@


1.40
log
@Make sure we don't attach more CPUs than we can handle.  Prevents an
out-of-bounds array access later on.

Allows OpenBSD to boot on machines with more than 32 CPUs/cores.

ok krw@@, jsing@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.39 2010/11/26 11:59:40 krw Exp $	*/
a87 1
#include <machine/mtrr.h>
@


1.39
log
@Nuke the unused variable cpus_attached. It is unused and 32 bits
aren't enough to keep track of possible cores these days anyway.

36-core amd64 box encountered by dlg@@

ok dlg@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.38 2010/11/13 04:16:42 guenther Exp $	*/
d169 7
a175 3
	if (strcmp(caa->caa_name, cf->cf_driver->cd_name) == 0)
		return 1;
	return 0;
@


1.38
log
@Switch from TSS-per-process to TSS-per-CPU, placing the TSS right
next to the cpu's GDT, also making the double-fault stack per-CPU,
leaving it at the top of the page of the CPU's idle process.  Inline
pmap_activate() and pmap_deactivate() into the asm cpu_switchto
routine, adding a check for the new pmap already being marked as
active on the CPU.  Garbage collect the hasn't-been-used-in-years
GDT update IPI.

Tested by many; ok mikeb@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.37 2010/10/26 05:49:10 guenther Exp $	*/
a137 2
u_int32_t cpus_attached = 0;

a345 2

	cpus_attached |= (1 << ci->ci_cpuid);
@


1.37
log
@The LDT is only used by dead compat code now, so load the ldt
register with the null selector (disabling use of it), stop reloading
it on every context switch, and blow away the table itself, as well
as the pcb and pmap bits that were used to track it.  Also, delete
two other unused pcb members: pcb_usersp and pcb_flags.  (Deleting
pcb_usersp also keeps the pcb_savefpu member aligned properly.)
Finally, delete the defines for the unimplemented AMD64_{GET,SET}_LDT
sysarch() calls.

Tested by various with both AMD and Intel chips
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.36 2010/10/14 04:38:24 guenther Exp $	*/
d283 1
a283 1
	pcb->pcb_tss.tss_rsp0 = kstack + USPACE - 16;
a284 1
	pcb->pcb_tss.tss_ist[0] = kstack + PAGE_SIZE - 16;
@


1.36
log
@Clean up segment handling: switch user-space to using code and data
segments in the GDT instead of the LDT and eliminate the GDT slots
that we don't actually use.

tested on both amd and intel by several
not really the right person, but ok: kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.35 2010/07/25 21:43:38 deraadt Exp $	*/
d515 1
a515 1
	lldt(GSYSSEL(GLDT_SEL, SEL_KPL));
@


1.35
log
@in the clock drivers, seperate the soft-state and hard-state which was
all jumbled up in the same functions. the rtc (mc chip) and clock (i8243)
startup was also mixed up.  they the soft state and hardware state can
be started in the right order, and it is easy to restart just the
neccessary parts upon resume.  tested in numerous cases:
(apic, pic) * (GENERIC.MP, GENERIC) * (mp, non-mp) * (i386, amd64)
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.34 2010/06/26 23:24:43 guenther Exp $	*/
d657 1
a657 1
	    ((uint64_t)LSEL(LSYSRETBASE_SEL, SEL_UPL) << 48));
@


1.34
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.33 2010/05/08 16:54:07 oga Exp $	*/
d500 1
a500 1
	lapic_initclocks();
@


1.33
log
@Page Attribute Tables (PAT) support for x86.

PAT allows setting per-mapping cachability bits. Our main interest in it
for write combining mappings so we do not have to rely so heaviliy on
mtrrs (which are stupidly set up on more and more machines). MD flags to
pmap allow setting these bits (which bus_space now uses for PREFETCHABLE
maps), if a vm page has a bit set, then we will use WC for all mappings
of a page (used for userland mappings). We also check for known errata
and fall back to UC- mappings in that case.

comments from kettenis@@, tedu@@ and william@@. kettenis@@, tedu@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.32 2010/04/16 17:44:00 kettenis Exp $	*/
a71 1
#include <sys/user.h>
@


1.32
log
@Use a somewhat bigger hammer and als flush tlb entries that have the global
bit set.  While there, add an #ifdef MULTIPROCESSOR to make the diff between
amd64 and i386 smaller.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.31 2010/04/08 19:27:40 kettenis Exp $	*/
d108 1
d373 5
d669 32
@


1.31
log
@Since we only start doing tlb shootdowns after setting the CPUF_RUNNING flag,
flush the TLB immediately after doing so, to make sure there are no stale
TLB entries.  Suggested by art@@

ok art@@, oga@@, deraadt@@, weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.30 2010/04/07 06:33:06 kettenis Exp $	*/
d378 1
a378 1
	tlbflush();
@


1.30
log
@Make suspend/resume work on MP machines (running an MP kernel).  Joint work
from mlarkin@@ and me, with some amd64 fixes thrown in by deraadt@@

ok marco@@, deraadt@@, pirofti@@, mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.29 2010/04/01 19:47:59 kettenis Exp $	*/
d378 1
@


1.29
log
@Don't index cpu_info by apic id, but by device unit number instead.  Recent
Intel CPUs come up with apic id's >= 32, even on systems with less than 32
logical CPUs.

ok krw@@, marco@@; tested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.28 2009/06/09 02:56:38 krw Exp $	*/
d148 3
a150 3
static void    	cpu_boot_secondary(struct cpu_info *ci);
static void    	cpu_start_secondary(struct cpu_info *ci);
static void	cpu_copy_trampoline(void);
d551 1
a551 1
static void
@


1.28
log
@revert guenther@@'s un-revert of art's curpmap.

My

bios0: ASUSTeK Computer INC. P5K-E
cpu0: Intel(R) Core(TM)2 Quad CPU Q6600 @@ 2.40GHz, 2405.74 MHz
cpu1: Intel(R) Core(TM)2 Quad CPU Q6600 @@ 2.40GHz, 2405.46 MHz
cpu2: Intel(R) Core(TM)2 Quad CPU Q6600 @@ 2.40GHz, 2405.46 MHz
cpu3: Intel(R) Core(TM)2 Quad CPU Q6600 @@ 2.40GHz, 2405.46 MHz

can't boot with this in. It always hangs somewhere in fsck'ing if
any, or between netstart and local daemons if no fsck'ing. Also
fubars theo's real amd machine.

Much more testing needed for this.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.27 2009/06/06 23:45:35 guenther Exp $	*/
a160 7
	int cpunum = lapic_cpu_number();

	if (cpunum != 0) {
		cpu_info[0] = NULL;
		cpu_info[cpunum] = &cpu_info_primary;
	}

d221 1
a221 1
	int cpunum = caa->cpu_number;
d244 1
a244 1
		if (cpunum != lapic_cpu_number()) {
d247 1
a247 1
			    sc->sc_dev.dv_xname, lapic_cpu_number(), cpunum);
d258 1
a258 1
	ci->ci_cpuid = ci->ci_apicid;
@


1.27
log
@Unrevert the curpmap change with the addition of correct %gs handling
in the IPI handler so that it works when it interrupts userspace,
waiting for the droppmap IPI to complete when destroying it, and
(most importantly) don't call pmap_tlb_droppmap() from cpu_exit().
Tested by myself and ckuethe, as our machines choked on the original.

ok @@art
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.25 2009/05/28 09:05:33 art Exp $	*/
a296 1
	ci->ci_curpmap = pmap_kernel();
@


1.26
log
@Revert the curpmap change.  We know the IPI is broken on both ends,
but even with proposed fixes, the reaper panics are back.
@
text
@d297 1
@


1.25
log
@Bring back the curpmap change. It was missing a reload of the pmap on
curcpu when we were freeing a pmap. Tested and working for a few weeks
now, but I was a bit too busy to commit it earlier.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.23 2009/04/23 07:42:02 art Exp $	*/
a296 1
	ci->ci_curpmap = pmap_kernel();
@


1.24
log
@turning pmap_deactivate into a NOP brought back the reaper panics, probably
because the reaper is running on the mappings of pmap from the process it
is about to unmap.  back it out until ht is fixed right; don't let this sit
in the tree waiting for a fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.22 2009/02/15 02:03:40 marco Exp $	*/
d297 1
@


1.23
log
@Make pmap_deactivate a NOP.

Instead of keeping a bitmask of on which cpu the pmap might be active which
we clear in pmap_deactivate, always keep a pointer to the currently loaded
pmap in cpu_info. We can now optimize a context switch to the kernel pmap
(idle and kernel threads) to keep the previously loaded pmap still loaded
and then reuse that pmap if we context switch back to the same process.

Introduce a new IPI to force a pmap reload before the pmap is destroyed.

Clean up cpu_switchto.

toby@@ ok
@
text
@a296 1
	ci->ci_curpmap = pmap_kernel();
@


1.22
log
@Add sleep plumbing code for amd64 making it the sameish as i386. Committing
per mlarkin request.

Code from mlarkin, mptramp code from kurt
Lots of comments weingart, art & others
Tested in snaps for weeks
ok kurt, marco
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.21 2008/10/15 23:23:46 deraadt Exp $	*/
d297 1
@


1.21
log
@make random(9) return per-cpu values (by saving the seed in the cpuinfo),
which are uniform for the profclock on each cpu in a SMP system (but using
a different seed for each cpu).  on all cpus, avoid seeding with a value out
of the [0, 2^31-1] range (since that is not stable)
ok kettenis drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.20 2008/10/06 20:42:02 chl Exp $	*/
a566 1
	struct pmap *kmp = pmap_kernel();
d568 1
a568 2
	extern vaddr_t lo32_vaddr;
	extern paddr_t lo32_paddr;
a569 3
	pmap_kenter_pa((vaddr_t)MP_TRAMPOLINE,	/* virtual */
	    (paddr_t)MP_TRAMPOLINE,	/* physical */
	    VM_PROT_ALL);		/* protection */
a574 2
	 * The initial PML4 pointer must be below 4G, so if the
	 * current one isn't, use a "bounce buffer"
d578 1
a578 5
	if (kmp->pm_pdirpa > 0xffffffff) {
		memcpy((void *)lo32_vaddr, kmp->pm_pdir, PAGE_SIZE);
		mp_pdirpa = lo32_paddr;
	} else
		mp_pdirpa = kmp->pm_pdirpa;
@


1.20
log
@remove dead stores and newly created unused variables.

Found by LLVM/Clang Static Analyzer.

ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.19 2008/06/26 05:42:09 ray Exp $	*/
d400 1
@


1.19
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.18 2008/06/11 09:22:38 phessler Exp $	*/
a430 1
	struct pcb *pcb;
a431 2

	pcb = ci->ci_idle_pcb;
@


1.18
log
@Synchronize the MTRR API with i386, and enable

"just commit it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.17 2008/04/13 11:35:55 thib Exp $	*/
a20 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.17
log
@garbage collect the cpus_running global variable;

pointed out by and ok drahn@@, toby@@;
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.16 2007/11/16 16:16:07 deraadt Exp $	*/
a388 6

#ifdef MTRR
	if ((ci->ci_flags & CPUF_AP) == 0)
		i686_mtrr_init_first();
	mtrr_init_cpu(ci);
#endif
@


1.16
log
@fix the bus_space #define nightmare, so that amd64 and i386 are much more
uniform. as a result shared code like acpi needs less #ifdef's
ok marco kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.15 2007/10/10 15:53:51 art Exp $	*/
a153 2
u_int32_t cpus_running = 0;

a397 1
	cpus_running |= 1 << ci->ci_cpuid;
@


1.15
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.14 2007/09/17 15:34:38 chl Exp $	*/
d152 1
a152 1
struct cpu_info *cpu_info[X86_MAXPROCS] = { &cpu_info_primary };
d412 1
a412 1
	for (i=0; i < X86_MAXPROCS; i++) {
d432 1
a432 1
	for (i=0; i < X86_MAXPROCS; i++) {
@


1.14
log
@MALLOC/FREE -> malloc/free and M_ZERO changes

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.13 2007/08/02 16:40:27 deraadt Exp $	*/
d348 1
d544 3
@


1.13
log
@copy nvram code from i386, because amd64 can use it too.  done by
tybollt@@solace.miun.se, ok jcs
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.12 2007/01/15 23:19:05 jsg Exp $	*/
d247 1
a247 2
		ci = malloc(sizeof(*ci), M_DEVBUF, M_WAITOK);
		memset(ci, 0, sizeof(*ci));
@


1.12
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.11 2005/09/25 20:48:18 miod Exp $	*/
d110 1
a110 1
#include <i386/isa/nvram.h>
@


1.11
log
@Turn CPU_INFO_FOREACH into a real construct, like all queue(3) iterators,
instead of the contents of a for() loop. No functional change.
From the m88k SMP tree; ok art@@ deraadt@@

[complete diff this time]
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.10 2005/07/26 08:38:29 art Exp $	*/
d168 1
a168 1
cpu_init_first()
d231 1
a231 3
cpu_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d383 1
a383 2
cpu_init(ci)
	struct cpu_info *ci;
d407 1
a407 1
cpu_boot_secondary_processors()
d427 1
a427 1
cpu_init_idle_pcbs()
d445 1
a445 2
cpu_start_secondary (ci)
	struct cpu_info *ci;
d474 1
a474 2
cpu_boot_secondary(ci)
	struct cpu_info *ci;
d574 1
a574 1
cpu_copy_trampoline()
@


1.10
log
@Instead of juggling around with cr4 and enabling parts of it sometimes,
other parts later, etc. Just set it to the same default value everywhere.
We won't survive without PSE and tt's not like someone will suddenly make
an amd64 that doesn't support PGE.

This will allow us to make the bootstrap process slightly more sane.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.9 2005/07/18 02:43:24 fgsch Exp $	*/
d566 1
a566 1
	for (CPU_INFO_FOREACH(cii, ci)) {
@


1.9
log
@remove trailing newline in panic(9); ok millert@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.8 2005/05/24 09:30:32 deraadt Exp $	*/
d393 1
a393 1
	lcr4(rcr4() | CR4_PGE | CR4_PSE | CR4_OSFXSR | CR4_OSXMMEXCPT);
@


1.8
log
@do not print cpu startup messages (because they are obvious)
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.7 2004/07/19 15:09:05 art Exp $	*/
d364 1
a364 1
		panic("unknown processor type??\n");
@


1.7
log
@Implement __HAVE_PMAP_DIRECT on amd64 using large pages. At this moment
it's limited to 512GB (one L4 page table entry) physical memory. Only
used carefully at this moment, but more improvements are in the pipeline.

tested by many, deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.6 2004/07/08 04:23:04 david Exp $	*/
a546 1
	printf("%s: CPU %u running\n",ci->ci_dev->dv_xname, ci->ci_cpuid);
@


1.6
log
@enclose some MP-only things in #ifdef MULTIPROCESSOR
ok deraadt@@ niklas@@; testing by pvalchev@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.5 2004/06/25 11:03:27 art Exp $	*/
d393 1
a393 1
	lcr4(rcr4() | CR4_PGE | CR4_OSFXSR | CR4_OSXMMEXCPT);
@


1.5
log
@SMP support. Big parts from NetBSD, but with some really serious debugging
done by me, niklas and others. Especially wrt. NXE support.

Still needs some polishing, especially in dmesg messages, but we're now
building kernel faster than ever.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.4 2004/06/24 19:35:23 tholo Exp $	*/
d121 1
d126 1
a612 2
#endif

d680 1
@


1.4
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.3 2004/06/09 10:17:10 art Exp $	*/
d350 1
a450 14
	struct pmap *kmp = pmap_kernel();
	extern u_int64_t mp_pdirpa;
	extern vaddr_t lo32_vaddr;
	extern paddr_t lo32_paddr;

	/*
	 * The initial PML4 pointer must be below 4G, so if the
	 * current one isn't, use a "bounce buffer"
	 */
	if (kmp->pm_pdirpa > 0xffffffff) {
		memcpy((void *)lo32_vaddr, kmp->pm_pdir, PAGE_SIZE);
		mp_pdirpa = lo32_paddr;
	} else
		mp_pdirpa = kmp->pm_pdirpa;
a455 2
	printf("%s: starting\n", ci->ci_dev->dv_xname);

a545 4
#if defined(I586_CPU) || defined(I686_CPU)
	if (ci->ci_feature_flags & CPUID_TSC)
		cc_microset(ci);
#endif
d585 6
d597 12
d637 3
a639 3
	pmap_kenter_pa (0, 0, VM_PROT_READ|VM_PROT_WRITE);
	memcpy ((u_int8_t *) 0x467, dwordptr, 4);
	pmap_kremove (0, PAGE_SIZE);
a652 1

@


1.3
log
@Minor sync from the SMP branch.
NVRAM_RESET_SOFT -> NVRAM_RESET_JUMP
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.2 2004/02/23 08:32:36 mickey Exp $	*/
d565 1
a565 1
	microtime(&ci->ci_schedstate.spc_runtime);
@


1.2
log
@get use of NX; partially from netbsd; passes the regress; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.1 2004/01/28 01:39:38 mickey Exp $	*/
d628 1
a628 1
	outb(IO_RTC+1, NVRAM_RESET_SOFT);
@


1.1
log
@an amd64 arch support.
hacked by art@@ from netbsd sources and then later debugged
by me into the shape where it can host itself.
no bootloader yet as needs redoing from the
recent advanced i386 sources (anyone? ;)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d699 3
@


1.1.2.1
log
@Merge with the trunk
@
text
@a698 3

	if (cpu_feature & CPUID_NXE)
		wrmsr(MSR_EFER, rdmsr(MSR_EFER) | EFER_NXE);
@


1.1.2.2
log
@RESET_SOFT is now called RESET_JUMP
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.1.2.1 2004/06/05 23:09:24 niklas Exp $	*/
d628 1
a628 1
	outb(IO_RTC+1, NVRAM_RESET_JUMP);
@


