head	1.36;
access;
symbols
	OPENBSD_6_2:1.36.0.2
	OPENBSD_6_2_BASE:1.36
	OPENBSD_6_1:1.33.0.6
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.33.0.2
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.32.0.2
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.32.0.4
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.29.0.4
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.27.0.8
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.27.0.4
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.27.0.2
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.26.0.6
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.4
	OPENBSD_5_0:1.26.0.2
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.21.0.2
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.19.0.2
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.14.0.4
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.6
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.13.0.4
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.12.0.4
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.2
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.9.0.4
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.8.0.2
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	OPENBSD_3_5:1.4.0.2
	OPENBSD_3_5_BASE:1.4
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.36
date	2017.10.03.17.36.40;	author guenther;	state Exp;
branches;
next	1.35;
commitid	6KcnIhWcZrm3Ptb7;

1.35
date	2017.05.29.14.19.49;	author mpi;	state Exp;
branches;
next	1.34;
commitid	4u6PWvBw90PH7UDq;

1.34
date	2017.04.27.06.16.39;	author mlarkin;	state Exp;
branches;
next	1.33;
commitid	ZHkhUOyGvsrTGUP9;

1.33
date	2016.04.21.22.08.27;	author mlarkin;	state Exp;
branches
	1.33.6.1;
next	1.32;
commitid	UPhx207ViycPjARC;

1.32
date	2015.03.25.21.05.18;	author kettenis;	state Exp;
branches;
next	1.31;
commitid	k6HPjf5wfG49EBGs;

1.31
date	2015.03.21.20.42.38;	author kettenis;	state Exp;
branches;
next	1.30;
commitid	tilqEUDj6duaLWpC;

1.30
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.29;
commitid	p4LJxGKbi0BU2cG6;

1.29
date	2014.05.06.11.50.13;	author mpi;	state Exp;
branches;
next	1.28;

1.28
date	2014.03.29.18.09.28;	author guenther;	state Exp;
branches;
next	1.27;

1.27
date	2012.08.30.16.10.32;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2011.07.11.15.40.47;	author guenther;	state Exp;
branches;
next	1.25;

1.25
date	2011.07.10.18.09.27;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2011.07.07.18.11.23;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2011.07.06.21.41.37;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2011.03.20.21.44.08;	author guenther;	state Exp;
branches;
next	1.21;

1.21
date	2010.09.29.15.11.31;	author joshe;	state Exp;
branches;
next	1.20;

1.20
date	2010.09.29.13.46.38;	author joshe;	state Exp;
branches;
next	1.19;

1.19
date	2010.07.23.15.10.16;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2010.07.23.14.56.31;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2010.07.21.14.08.09;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2010.06.29.21.13.43;	author thib;	state Exp;
branches;
next	1.15;

1.15
date	2010.06.07.08.23.58;	author thib;	state Exp;
branches;
next	1.14;

1.14
date	2008.12.04.15.48.19;	author weingart;	state Exp;
branches;
next	1.13;

1.13
date	2007.11.12.14.47.56;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2006.11.29.12.24.17;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2006.04.19.15.51.22;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2006.04.19.15.48.17;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2005.12.13.00.18.19;	author jsg;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	2005.04.21.04.39.34;	author mickey;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2004.10.28.20.36.15;	author kettenis;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2004.07.11.11.31.57;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.25.11.03.27;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2004.02.28.20.33.33;	author nordin;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.27.21.15.49;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.20.01.28.01;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.28.01.39.38;	author mickey;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.06.05.23.09.24;	author niklas;	state Exp;
branches;
next	;

1.7.2.1
date	2006.05.02.04.08.54;	author brad;	state Exp;
branches;
next	;

1.8.2.1
date	2006.05.02.04.07.27;	author brad;	state Exp;
branches;
next	;

1.9.4.1
date	2006.05.02.04.05.33;	author brad;	state Exp;
branches;
next	;

1.33.6.1
date	2017.05.03.02.29.16;	author jsg;	state Exp;
branches;
next	;
commitid	G8fCSoM66ex6Gjxp;


desc
@@


1.36
log
@The xrstor instruction will fault if the provided xstate data, which
is under userspace control via sigreturn, fails various consistency
checks.  Rather than trying to replicate the CPU's hardwired checks
in C code, handle it like iretq: check in trap() whether a fault
is from the problem instruction and handle it there.

CPU behavior and the potential issue pointed out on Linux kernel-hardening
ok mikeb@@ deraadt@@
@
text
@/*	$OpenBSD: fpu.c,v 1.35 2017/05/29 14:19:49 mpi Exp $	*/
/*	$NetBSD: fpu.c,v 1.1 2003/04/26 18:39:28 fvdl Exp $	*/

/*-
 * Copyright (c) 1994, 1995, 1998 Charles M. Hannum.  All rights reserved.
 * Copyright (c) 1990 William Jolitz.
 * Copyright (c) 1991 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/ioctl.h>
#include <sys/device.h>
#include <sys/signalvar.h>

#include <uvm/uvm_extern.h>

#include <machine/bus.h>
#include <machine/cpu.h>
#include <machine/intr.h>
#include <machine/cpufunc.h>
#include <machine/pcb.h>
#include <machine/trap.h>
#include <machine/specialreg.h>
#include <machine/fpu.h>

#include <dev/isa/isavar.h>

void	xrstor_user(struct savefpu *_addr, uint64_t _mask);

/*
 * We do lazy initialization and switching using the TS bit in cr0 and the
 * MDP_USEDFPU bit in mdproc.
 *
 * DNA exceptions are handled like this:
 *
 * 1) If there is no FPU, return and go to the emulator.
 * 2) If someone else has used the FPU, save its state into that process' PCB.
 * 3a) If MDP_USEDFPU is not set, set it and initialize the FPU.
 * 3b) Otherwise, reload the process' previous FPU state.
 *
 * When a process is created or exec()s, its saved cr0 image has the TS bit
 * set and the MDP_USEDFPU bit clear.  The MDP_USEDFPU bit is set when the
 * process first gets a DNA and the FPU is initialized.  The TS bit is turned
 * off when the FPU is used, and turned on again later when the process' FPU
 * state is saved.
 */

/*
 * The mask of enabled XSAVE features.
 */
uint64_t	xsave_mask;

void fpudna(struct cpu_info *);
static int x86fpflags_to_siginfo(u_int32_t);

/*
 * Size of the area needed to save the FPU state and other
 * XSAVE-supported state components.
 */
size_t		fpu_save_len = sizeof(struct fxsave64);

/*
 * The mxcsr_mask for this host, taken from fxsave() on the primary CPU
 */
uint32_t	fpu_mxcsr_mask;

/*
 * Init the FPU.
 */
void
fpuinit(struct cpu_info *ci)
{
	lcr0(rcr0() & ~(CR0_EM|CR0_TS));
	fninit();
	if (fpu_mxcsr_mask == 0) {
		struct fxsave64 fx __attribute__((aligned(16)));

		bzero(&fx, sizeof(fx));
		fxsave(&fx);
		if (fx.fx_mxcsr_mask)
			fpu_mxcsr_mask = fx.fx_mxcsr_mask;
		else
			fpu_mxcsr_mask = __INITIAL_MXCSR_MASK__;
	}
	lcr0(rcr0() | (CR0_TS));
}

/*
 * Record the FPU state and reinitialize it all except for the control word.
 * Then generate a SIGFPE.
 *
 * Reinitializing the state allows naive SIGFPE handlers to longjmp without
 * doing any fixups.
 */
void
fputrap(struct trapframe *frame)
{
	struct proc *p = curcpu()->ci_fpcurproc;
	struct savefpu *sfp = &p->p_addr->u_pcb.pcb_savefpu;
	u_int32_t mxcsr, statbits;
	u_int16_t cw;
	int code;
	union sigval sv;

#ifdef DIAGNOSTIC
	/*
	 * At this point, fpcurproc should be curproc.  If it wasn't,
	 * the TS bit should be set, and we should have gotten a DNA exception.
	 */
	if (p != curproc)
		panic("fputrap: wrong proc");
#endif

	fxsave(sfp);
	if (frame->tf_trapno == T_XMM) {
		mxcsr = sfp->fp_fxsave.fx_mxcsr;
	  	statbits = mxcsr;
		mxcsr &= ~0x3f;
		ldmxcsr(&mxcsr);
	} else {
		fninit();
		fwait();
		cw = sfp->fp_fxsave.fx_fcw;
		fldcw(&cw);
		fwait();
		statbits = sfp->fp_fxsave.fx_fsw;
	}
	sfp->fp_ex_tw = sfp->fp_fxsave.fx_ftw;
	sfp->fp_ex_sw = sfp->fp_fxsave.fx_fsw;
	code = x86fpflags_to_siginfo (statbits);
	sv.sival_ptr = (void *)frame->tf_rip;	/* XXX - ? */
	KERNEL_LOCK();
	trapsignal(p, SIGFPE, frame->tf_err, code, sv);
	KERNEL_UNLOCK();
}

static int
x86fpflags_to_siginfo(u_int32_t flags)
{
        int i;
        static int x86fp_siginfo_table[] = {
                FPE_FLTINV, /* bit 0 - invalid operation */
                FPE_FLTRES, /* bit 1 - denormal operand */
                FPE_FLTDIV, /* bit 2 - divide by zero   */
                FPE_FLTOVF, /* bit 3 - fp overflow      */
                FPE_FLTUND, /* bit 4 - fp underflow     */
                FPE_FLTRES, /* bit 5 - fp precision     */
                FPE_FLTINV, /* bit 6 - stack fault      */
        };

        for (i = 0; i < nitems(x86fp_siginfo_table); i++) {
                if (flags & (1 << i))
                        return (x86fp_siginfo_table[i]);
        }
        /* punt if flags not set */
        return (FPE_FLTINV);
}

/*
 * Implement device not available (DNA) exception
 *
 * If we were the last process to use the FPU, we can simply return.
 * Otherwise, we save the previous state, if necessary, and restore our last
 * saved state.
 */
void
fpudna(struct cpu_info *ci)
{
	struct savefpu *sfp;
	struct proc *p;
	int s;

	if (ci->ci_fpsaving) {
		printf("recursive fpu trap; cr0=%x\n", rcr0());
		return;
	}

	s = splipi();

#ifdef MULTIPROCESSOR
	p = ci->ci_curproc;
#else
	p = curproc;
#endif

	/*
	 * Initialize the FPU state to clear any exceptions.  If someone else
	 * was using the FPU, save their state.
	 */
	if (ci->ci_fpcurproc != NULL && ci->ci_fpcurproc != p) {
		fpusave_cpu(ci, ci->ci_fpcurproc != &proc0);
		uvmexp.fpswtch++;
	}
	splx(s);

	if (p == NULL) {
		clts();
		return;
	}

	KDASSERT(ci->ci_fpcurproc == NULL);
#ifndef MULTIPROCESSOR
	KDASSERT(p->p_addr->u_pcb.pcb_fpcpu == NULL);
#else
	if (p->p_addr->u_pcb.pcb_fpcpu != NULL)
		fpusave_proc(p, 1);
#endif

	p->p_addr->u_pcb.pcb_cr0 &= ~CR0_TS;
	clts();

	s = splipi();
	ci->ci_fpcurproc = p;
	p->p_addr->u_pcb.pcb_fpcpu = ci;
	splx(s);

	sfp = &p->p_addr->u_pcb.pcb_savefpu;

	if ((p->p_md.md_flags & MDP_USEDFPU) == 0) {
		fninit();
		bzero(&sfp->fp_fxsave, sizeof(sfp->fp_fxsave));
		sfp->fp_fxsave.fx_fcw = __INITIAL_NPXCW__;
		sfp->fp_fxsave.fx_mxcsr = __INITIAL_MXCSR__;
		fxrstor(&sfp->fp_fxsave);
		p->p_md.md_flags |= MDP_USEDFPU;
	} else {
		if (xsave_mask) {
			xrstor_user(sfp, xsave_mask);
		} else {
			static double	zero = 0.0;

			/*
			 * amd fpu does not restore fip, fdp, fop on fxrstor
			 * thus leaking other process's execution history.
			 */
			fnclex();
			__asm volatile("ffree %%st(7)\n\tfldl %0" : : "m" (zero));
			fxrstor(sfp);
		}
	}
}


void
fpusave_cpu(struct cpu_info *ci, int save)
{
	struct proc *p;
	int s;

	KDASSERT(ci == curcpu());

	p = ci->ci_fpcurproc;
	if (p == NULL)
		return;

	if (save) {
#ifdef DIAGNOSTIC
		if (ci->ci_fpsaving != 0)
			panic("fpusave_cpu: recursive save!");
#endif
		/*
		 * Set ci->ci_fpsaving, so that any pending exception will be
		 * thrown away.  (It will be caught again if/when the FPU
		 * state is restored.)
		 */
		clts();
		ci->ci_fpsaving = 1;
		if (xsave_mask)
			xsave(&p->p_addr->u_pcb.pcb_savefpu, xsave_mask);
		else
			fxsave(&p->p_addr->u_pcb.pcb_savefpu);
		ci->ci_fpsaving = 0;
	}

	stts();
	p->p_addr->u_pcb.pcb_cr0 |= CR0_TS;

	s = splipi();
	p->p_addr->u_pcb.pcb_fpcpu = NULL;
	ci->ci_fpcurproc = NULL;
	splx(s);
}

/*
 * Save p's FPU state, which may be on this processor or another processor.
 */
void
fpusave_proc(struct proc *p, int save)
{
	struct cpu_info *ci = curcpu();
	struct cpu_info *oci;

	KDASSERT(p->p_addr != NULL);

	oci = p->p_addr->u_pcb.pcb_fpcpu;
	if (oci == NULL)
		return;

#if defined(MULTIPROCESSOR)
	if (oci == ci) {
		int s = splipi();
		fpusave_cpu(ci, save);
		splx(s);
	} else {
		oci->ci_fpsaveproc = p;
		x86_send_ipi(oci,
	    	    save ? X86_IPI_SYNCH_FPU : X86_IPI_FLUSH_FPU);
		while (p->p_addr->u_pcb.pcb_fpcpu != NULL)
			CPU_BUSY_CYCLE();
	}
#else
	KASSERT(ci->ci_fpcurproc == p);
	fpusave_cpu(ci, save);
#endif
}

void
fpu_kernel_enter(void)
{
	struct cpu_info	*ci = curcpu();
	uint32_t	 cw;
	int		 s;

	/*
	 * Fast path.  If the kernel was using the FPU before, there
	 * is no work to do besides clearing TS.
	 */
	if (ci->ci_fpcurproc == &proc0) {
		clts();
		return;
	}

	s = splipi();

	if (ci->ci_fpcurproc != NULL) {
		fpusave_cpu(ci, 1);
		uvmexp.fpswtch++;
	}

	/* Claim the FPU */
	ci->ci_fpcurproc = &proc0;

	splx(s);

	/* Disable DNA exceptions */
	clts();

	/* Initialize the FPU */
	fninit();
	cw = __INITIAL_NPXCW__;
	fldcw(&cw);
	cw = __INITIAL_MXCSR__;
	ldmxcsr(&cw);
}

void
fpu_kernel_exit(void)
{
	/* Enable DNA exceptions */
	stts();
}
@


1.35
log
@Kill SPINLOCK_SPIN_HOOK, use CPU_BUSY_CYCLE() instead.

ok visa@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.34 2017/04/27 06:16:39 mlarkin Exp $	*/
d58 2
d258 1
a258 1
			xrstor(sfp, xsave_mask);
@


1.34
log
@vmm(4): proper save/restore of FPU context during entry/exit.

tested by reyk, dcoppa, and a few others.

ok kettenis@@ on the fpu bits
ok deraadt@@ on the vmm bits
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.33 2016/04/21 22:08:27 mlarkin Exp $	*/
a54 1
#include <machine/lock.h>
d337 1
a337 1
			SPINLOCK_SPIN_HOOK;
@


1.33
log
@
KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.32 2015/03/25 21:05:18 kettenis Exp $	*/
a76 10
#define	fninit()		__asm("fninit")
#define fwait()			__asm("fwait")
#define fnclex()		__asm("fnclex")
#define	fxsave(addr)		__asm("fxsave %0" : "=m" (*addr))
#define	fxrstor(addr)		__asm("fxrstor %0" : : "m" (*addr))
#define	ldmxcsr(addr)		__asm("ldmxcsr %0" : : "m" (*addr))
#define fldcw(addr)		__asm("fldcw %0" : : "m" (*addr))
#define	clts()			__asm("clts")
#define	stts()			lcr0(rcr0() | CR0_TS)

a80 21

static inline void
xsave(struct savefpu *addr, uint64_t mask)
{
	uint32_t lo, hi;

	lo = mask;
	hi = mask >> 32;
	__asm volatile("xsave %0" : "=m" (*addr) : "a" (lo), "d" (hi) :
	    "memory");
}

static inline void
xrstor(struct savefpu *addr, uint64_t mask)
{
	uint32_t lo, hi;

	lo = mask;
	hi = mask >> 32;
	__asm volatile("xrstor %0" : : "m" (*addr), "a" (lo), "d" (hi));
}
@


1.33.6.1
log
@OpenBSD 6.1 errata 002, May 2, 2017

vmm(4) mismanaged floating point contexts.
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.33 2016/04/21 22:08:27 mlarkin Exp $	*/
d77 10
d91 21
@


1.32
log
@Save/restore AVX registers and other XSAVE-managed state information when
entering/leaving a signal handler like we already do the the FPU and SSE
state.  This should make it possible to use AVX instructions in signal
handlers.

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.31 2015/03/21 20:42:38 kettenis Exp $	*/
a154 1

d321 5
a325 5
		 /*
		  * Set ci->ci_fpsaving, so that any pending exception will be
		  * thrown away.  (It will be caught again if/when the FPU
		  * state is restored.)
		  */
@


1.31
log
@Add support for saving/restoring FPU state using the XSAVE/XRSTOR.  Limit
support to the X87, SSE and AVX state.

This gives us (almost) full AVX support.  The AVX state isn't saved by
signal handlers yet, and ptrace(2) support is still missing.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.30 2015/03/14 03:38:46 jsg Exp $	*/
d87 4
a90 1
uint64_t xsave_mask;
d115 6
@


1.30
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.29 2014/05/06 11:50:13 mpi Exp $	*/
d87 23
d279 13
a291 9
		static double	zero = 0.0;

		/*
		 * amd fpu does not restore fip, fdp, fop on fxrstor
		 * thus leaking other process's execution history.
		 */
		fnclex();
		__asm volatile("ffree %%st(7)\n\tfldl %0" : : "m" (zero));
		fxrstor(sfp);
d320 4
a323 1
		fxsave(&p->p_addr->u_pcb.pcb_savefpu);
@


1.29
log
@Include <sys/vmmeter.h> directly instead of relying on it being
pulled by <uvm/uvm_extern.h> and turn uvm_total() into a private
function.

The preferred way to get memory stats is through the VM_UVMEXP
sysctl(3) since VM_METER is just a wrapper on top of it.  In the
kernel, use `uvmexp' directly instead of uvm_total().

This change does not remove <sys/vmmeter.h> from <uvm/uvm_extern.h>
to give some more time to port maintainers to fix their ports.

ok guenther@@ as part of a larger diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.28 2014/03/29 18:09:28 guenther Exp $	*/
a56 1
#include <dev/isa/isareg.h>
@


1.28
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.27 2012/08/30 16:10:32 kettenis Exp $	*/
a42 1
#include <sys/vmmeter.h>
@


1.27
log
@Use an explicit suffix for the "fld" instruction to shut up clang.  The correct
instruction is fldl sinze we try to load a double-precision value.
GCC actually gets it wrong and emits "flds" (which is harmless).

Pointed out by Brad.  ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.26 2011/07/11 15:40:47 guenther Exp $	*/
d265 1
a265 1
		__asm __volatile("ffree %%st(7)\n\tfldl %0" : : "m" (zero));
@


1.26
log
@Revert art@@'s moving around of the KERNEL_LOCK()/KERNEL_UNLOCK() calls,
as it causes hangs in some ports, including libsigsegv's configure script

confirmed by krw@@, landry@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.23 2011/07/06 21:41:37 art Exp $	*/
d265 1
a265 1
		__asm __volatile("ffree %%st(7)\n\tfld %0" : : "m" (zero));
@


1.25
log
@remove irrelevant old comment
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.24 2011/07/07 18:11:23 art Exp $	*/
d163 1
d165 1
@


1.24
log
@There is a bunch of places in the kernel entry points where we don't
hold the kernel lock, but still need call one function that needs it.

Instead of grabbing the lock all over the place, move the locks into
the affected functions: trapsignal, scdebug*, ktrsyscall, ktrsysret,
systrace_redirect and ADDUPROF. In the cases we already hold the biglock
we'll just recurse.

kettenis@@, beck@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.23 2011/07/06 21:41:37 art Exp $	*/
a32 6
 *
 *	@@(#)npx.c	7.2 (Berkeley) 5/12/91
 */

/*
 * XXXfvdl update copyright notice. this started out as a stripped isa/npx.c
@


1.23
log
@Clean up after P_BIGLOCK removal.
KERNEL_PROC_LOCK -> KERNEL_LOCK
KERNEL_PROC_UNLOCK -> KERNEL_UNLOCK

oga@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.22 2011/03/20 21:44:08 guenther Exp $	*/
a168 1
	KERNEL_LOCK();
a169 1
	KERNEL_UNLOCK();
@


1.22
log
@When reading MXCSR from userland sigcontext or a ptrace request,
mask out invalid bits to prevent a protect fault.

Original diff by joshe@@; further feedback and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.21 2010/09/29 15:11:31 joshe Exp $	*/
d169 1
a169 1
	KERNEL_PROC_LOCK(p);
d171 1
a171 1
	KERNEL_PROC_UNLOCK(p);
@


1.21
log
@Back out previous, it appears to be broken.
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.19 2010/07/23 15:10:16 kettenis Exp $	*/
d99 5
d111 10
@


1.20
log
@When reading MXCSR from userland sigcontext, mask out invalid bits.

This prevents a protection fault if a userland signal handler
scribbles all over it's struct sigcontext

Help from and ok guenther@@ kettenis@@
@
text
@a94 5
/*
 * The mxcsr_mask for this host, taken from fxsave() on the primary CPU
 */
uint32_t	fpu_mxcsr_mask;

a105 10
	if (CPU_IS_PRIMARY(ci)) {
		struct fxsave64 fx __attribute__((aligned(16)));

		bzero(&fx, sizeof(fx));
		fxsave(&fx);
		if (fx.fx_mxcsr_mask)
			fpu_mxcsr_mask = fx.fx_mxcsr_mask;
		else
			fpu_mxcsr_mask = __INITIAL_MXCSR_MASK__;
	}
@


1.19
log
@Change the strategy for using the FPU in the kernel.  The kernel FPU state
is now shared with all processes/threads.  As a result, you can now use the
FPU in true process context (instead of just in kernel threads), but you
need to make sure you restore the default FPU state before calling
fpu_kernel_exit() if you change rounding mode, precision or exception masks.

Lots of discussion with thib@@ and Mike Belopuhov.

ok thib@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.18 2010/07/23 14:56:31 kettenis Exp $	*/
d95 5
d111 10
@


1.18
log
@Don't leak the contents of the FPU and SSE registers between processes.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.17 2010/07/21 14:08:09 kettenis Exp $	*/
d213 1
a213 1
		fpusave_cpu(ci, 1);
d335 1
a335 2
	struct cpu_info	*oci, *ci = curcpu();
	struct proc	*p = curproc;
a338 2
	KASSERT(p != NULL && (p->p_flag & P_SYSTEM));

d340 2
a341 2
	 * Fast path. If we were the last proc on the FPU,
	 * there is no work to do besides clearing TS.
d343 1
a343 2
	if (ci->ci_fpcurproc == p) {
		p->p_addr->u_pcb.pcb_cr0 &= ~CR0_TS;
a354 8
	/*
	 * If we were switched away to the other cpu, cleanup
	 * an fpcurproc pointer.
	 */
	oci = p->p_addr->u_pcb.pcb_fpcpu;
	if (oci != NULL && oci != ci && oci->ci_fpcurproc == p)
		oci->ci_fpcurproc = NULL;

d356 1
a356 3
	ci->ci_fpcurproc = p;
	p->p_addr->u_pcb.pcb_fpcpu = ci;
	p->p_addr->u_pcb.pcb_cr0 &= ~CR0_TS;
d360 1
a360 1
	/* Disables DNA exceptions */
d374 2
a375 5
	/*
	 * Nothing to do.
	 * TS is restored on a context switch automatically
	 * as long as we use hardware assisted task switching.
	 */
@


1.17
log
@Make sure that the FPU IPIs shoot down the right FPU context and not the FPU
context of some random process that happened to be switched onto the FPU
after the decision was made to send the IPI.
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.16 2010/06/29 21:13:43 thib Exp $	*/
d191 1
d239 2
d243 4
a246 2
		fldcw(&p->p_addr->u_pcb.pcb_savefpu.fp_fxsave.fx_fcw);
		ldmxcsr(&p->p_addr->u_pcb.pcb_savefpu.fp_fxsave.fx_mxcsr);
d257 1
a257 1
		fxrstor(&p->p_addr->u_pcb.pcb_savefpu);
@


1.16
log
@fpu_kernel_{enter,exit}; Functions to allow the use of
the FPU in the kernel.

From Mike Belopuhov; Little bits by myself.

Comments/OK kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.15 2010/06/07 08:23:58 thib Exp $	*/
d315 1
d317 1
a317 1
	    	save ? X86_IPI_SYNCH_FPU : X86_IPI_FLUSH_FPU);
@


1.15
log
@space nit and use nitems().

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.14 2008/12/04 15:48:19 weingart Exp $	*/
d324 63
@


1.14
log
@Fix "fp_save ipi didn't" panic, and move i386/amd64 closer in the process.
Positive test results by a handful of people.  Ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.13 2007/11/12 14:47:56 millert Exp $	*/
d173 1
a173 1
        for (i=0;i < sizeof(x86fp_siginfo_table)/sizeof(int); i++) {
@


1.13
log
@fix some problems with lazy fpu context handling:
    put the "fninit" where it belongs logically
    deal with XMM exceptions
From NetBSD (drochner)
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.12 2006/11/29 12:24:17 miod Exp $	*/
d62 1
a314 4
#ifdef DIAGNOSTIC
		int spincount;
#endif

d316 1
a316 5
		    save ? X86_IPI_SYNCH_FPU : X86_IPI_FLUSH_FPU);

#ifdef DIAGNOSTIC
		spincount = 0;
#endif
d318 1
a318 11
#ifdef DIAGNOSTIC
		{
			spincount++;
			if (spincount > 10000000) {
				panic("fp_save ipi didn't");
			}
		}
#else
		__splbarrier();		/* XXX replace by generic barrier */
		;
#endif
@


1.12
log
@Kernel stack can be swapped. This means that stuff that's on the stack
should never be referenced outside the context of the process to which
this stack belongs unless we do the PHOLD/PRELE dance. Loads of code
doesn't follow the rules here. Instead of trying to track down all
offenders and fix this hairy situation, it makes much more sense
to not swap kernel stacks.

From art@@, tested by many some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.11 2006/04/19 15:51:22 mickey Exp $	*/
d121 1
a121 1
	u_int32_t statbits;
d137 4
a140 1
	  	statbits = sfp->fp_fxsave.fx_mxcsr;
a212 5
	} else {
		clts();
		fninit();
		fwait();
		stts();
d238 1
@


1.11
log
@oops. forgot fnclex define (:
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.10 2006/04/19 15:48:17 mickey Exp $	*/
a303 1
	KDASSERT(p->p_flag & P_INMEM);
@


1.10
log
@from todays freebsd advisory: fxrstor on amd cpu does not restore fip,fdp,fop thus leaking other proc's execution history; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.9 2005/12/13 00:18:19 jsg Exp $	*/
d86 1
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.
Checked by ian@@, deraadt@@ and millert@@, arm portion checked by drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.8 2005/04/21 04:39:34 mickey Exp $	*/
d242 9
a250 1
	} else
d252 1
@


1.9.4.1
log
@MFC:
Fix by mickey@@

from todays freebsd advisory: fxrstor on amd cpu does not restore fip,fdp,fop thus leaking other proc'sexecution history
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.9 2005/12/13 00:18:19 jsg Exp $	*/
a85 1
#define fnclex()		__asm("fnclex")
d242 1
a242 9
	} else {
		static double	zero = 0.0;

		/*
		 * amd fpu does not restore fip, fdp, fop on fxrstor
		 * thus leaking other process's execution history.
		 */
		fnclex();
		__asm __volatile("ffree %%st(7)\n\tfld %0" : : "m" (zero));
a243 1
	}
@


1.8
log
@count fpu lazy context switches; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.7 2004/10/28 20:36:15 kettenis Exp $	*/
d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.8.2.1
log
@MFC:
Fix by mickey@@

from todays freebsd advisory: fxrstor on amd cpu does not restore fip,fdp,fop thus leaking other proc'sexecution history
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.8 2005/04/21 04:39:34 mickey Exp $	*/
a89 1
#define fnclex()		__asm("fnclex")
d246 1
a246 9
	} else {
		static double	zero = 0.0;

		/*
		 * amd fpu does not restore fip, fdp, fop on fxrstor
		 * thus leaking other process's execution history.
		 */
		fnclex();
		__asm __volatile("ffree %%st(7)\n\tfld %0" : : "m" (zero));
a247 1
	}
@


1.7
log
@SIGFPE signal codes.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.6 2004/07/11 11:31:57 kettenis Exp $	*/
d210 1
a210 1
	if (ci->ci_fpcurproc != NULL && ci->ci_fpcurproc != p) 
d212 2
a213 1
	else {
@


1.7.2.1
log
@MFC:
Fix by mickey@@

from todays freebsd advisory: fxrstor on amd cpu does not restore fip,fdp,fop thus leaking other proc'sexecution history
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.7 2004/10/28 20:36:15 kettenis Exp $	*/
a89 1
#define fnclex()		__asm("fnclex")
d245 1
a245 9
	} else {
		static double	zero = 0.0;

		/*
		 * amd fpu does not restore fip, fdp, fop on fxrstor
		 * thus leaking other process's execution history.
		 */
		fnclex();
		__asm __volatile("ffree %%st(7)\n\tfld %0" : : "m" (zero));
a246 1
	}
@


1.6
log
@Fix ldmxcsr asm macro.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.5 2004/06/25 11:03:27 art Exp $	*/
d98 1
d124 1
d126 1
d140 1
d147 1
d151 1
d154 1
a154 1
	trapsignal(p, SIGFPE, frame->tf_err, 0 /* XXX */, sv);
d156 22
@


1.5
log
@SMP support. Big parts from NetBSD, but with some really serious debugging
done by me, niklas and others. Especially wrt. NXE support.

Still needs some polishing, especially in dmesg messages, but we're now
building kernel faster than ever.
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.4 2004/02/28 20:33:33 nordin Exp $	*/
d92 1
a92 1
#define	ldmxcsr(addr)		__asm("ldmxcsr %0" : "=m" (*addr))
@


1.4
log
@Initialize MXCSR when FPU is first used. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.3 2004/02/27 21:15:49 deraadt Exp $	*/
d291 1
a291 1
		while (p->dpl_addr->u_pcb.pcb_fpcpu != NULL)
@


1.3
log
@zap bad message; spotted by pvalchev
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.2 2004/02/20 01:28:01 deraadt Exp $	*/
d92 1
a161 1
	u_int16_t cw;
d214 2
a215 2
		cw = p->p_addr->u_pcb.pcb_savefpu.fp_fxsave.fx_fcw;
		fldcw(&cw);
@


1.2
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.1 2004/01/28 01:39:38 mickey Exp $	*/
a124 1
printf("fputrap\n");
@


1.1
log
@an amd64 arch support.
hacked by art@@ from netbsd sources and then later debugged
by me into the shape where it can host itself.
no bootloader yet as needs redoing from the
recent advanced i386 sources (anyone? ;)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d261 1
a261 1
 * Save l's FPU state, which may be on this processor or another processor.
@


1.1.2.1
log
@Merge with the trunk
@
text
@a91 1
#define	ldmxcsr(addr)		__asm("ldmxcsr %0" : "=m" (*addr))
d125 1
d162 1
d215 2
a216 2
		fldcw(&p->p_addr->u_pcb.pcb_savefpu.fp_fxsave.fx_fcw);
		ldmxcsr(&p->p_addr->u_pcb.pcb_savefpu.fp_fxsave.fx_mxcsr);
d261 1
a261 1
 * Save p's FPU state, which may be on this processor or another processor.
@


