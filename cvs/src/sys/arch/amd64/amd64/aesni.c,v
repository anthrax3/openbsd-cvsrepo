head	1.41;
access;
symbols
	OPENBSD_6_1:1.40.0.4
	OPENBSD_6_1_BASE:1.40
	OPENBSD_6_0:1.38.0.2
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.36.0.2
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.32.0.4
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.31.0.2
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.27.0.4
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.26.0.4
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.25.0.2
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.24.0.2
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.22.0.4
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.2
	OPENBSD_5_0:1.21.0.2
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.19.0.2
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.8.0.2
	OPENBSD_4_8_BASE:1.8;
locks; strict;
comment	@ * @;


1.41
date	2017.05.02.11.47.49;	author mikeb;	state Exp;
branches;
next	1.40;
commitid	eIhnnHwMlTLXJ9Zb;

1.40
date	2017.02.07.17.25.45;	author patrick;	state Exp;
branches;
next	1.39;
commitid	dMJlqKWYCJoMV7JN;

1.39
date	2016.09.15.02.00.16;	author dlg;	state Exp;
branches;
next	1.38;
commitid	RlO92XR575sygHqm;

1.38
date	2016.04.18.21.15.18;	author kettenis;	state Exp;
branches;
next	1.37;
commitid	F6wz8aC5EFBAoGkl;

1.37
date	2016.04.17.03.12.08;	author dlg;	state Exp;
branches;
next	1.36;
commitid	GUchhX5N42HVQV16;

1.36
date	2015.11.07.01.37.26;	author naddy;	state Exp;
branches;
next	1.35;
commitid	L3HpIZTyGf6C2PRf;

1.35
date	2015.08.28.19.59.36;	author tedu;	state Exp;
branches;
next	1.34;
commitid	SxGqTviQRin6ZyIi;

1.34
date	2015.08.28.16.16.44;	author tedu;	state Exp;
branches;
next	1.33;
commitid	gZ1Bbd6wHX8SUrB3;

1.33
date	2015.08.28.00.03.53;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	NdgfPIGUgJxQPnT7;

1.32
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.31;
commitid	p4LJxGKbi0BU2cG6;

1.31
date	2014.12.15.01.53.45;	author tedu;	state Exp;
branches;
next	1.30;
commitid	zTvdNqjakdDTl6z6;

1.30
date	2014.11.18.20.51.00;	author krw;	state Exp;
branches;
next	1.29;
commitid	G35ycnLxaVis5TX9;

1.29
date	2014.11.18.15.18.01;	author mikeb;	state Exp;
branches;
next	1.28;
commitid	rwwB6bBuPAUgS0zp;

1.28
date	2014.08.18.05.11.03;	author dlg;	state Exp;
branches;
next	1.27;
commitid	hjFdrSJM3VTXJUZV;

1.27
date	2014.07.12.18.44.41;	author tedu;	state Exp;
branches;
next	1.26;
commitid	uKVPYMN2MLxdZxzH;

1.26
date	2014.01.18.23.17.24;	author mikeb;	state Exp;
branches;
next	1.25;

1.25
date	2013.03.26.15.47.01;	author jsing;	state Exp;
branches;
next	1.24;

1.24
date	2012.12.10.15.06.45;	author mikeb;	state Exp;
branches;
next	1.23;

1.23
date	2012.10.04.13.17.12;	author haesbaert;	state Exp;
branches;
next	1.22;

1.22
date	2011.08.17.17.00.35;	author mikeb;	state Exp;
branches;
next	1.21;

1.21
date	2011.05.06.17.31.16;	author mikeb;	state Exp;
branches;
next	1.20;

1.20
date	2011.04.20.06.51.34;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2011.01.12.17.15.23;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2011.01.11.15.42.05;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2010.12.15.23.34.23;	author mikeb;	state Exp;
branches;
next	1.16;

1.16
date	2010.11.15.14.48.17;	author mikeb;	state Exp;
branches;
next	1.15;

1.15
date	2010.11.15.14.41.41;	author mikeb;	state Exp;
branches;
next	1.14;

1.14
date	2010.11.15.14.24.13;	author mikeb;	state Exp;
branches;
next	1.13;

1.13
date	2010.11.15.12.57.24;	author mikeb;	state Exp;
branches;
next	1.12;

1.12
date	2010.11.15.12.30.29;	author mikeb;	state Exp;
branches;
next	1.11;

1.11
date	2010.11.15.11.52.58;	author mikeb;	state Exp;
branches;
next	1.10;

1.10
date	2010.11.10.17.05.39;	author mikeb;	state Exp;
branches;
next	1.9;

1.9
date	2010.09.07.15.51.00;	author mikeb;	state Exp;
branches;
next	1.8;

1.8
date	2010.07.22.12.47.40;	author thib;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2010.07.08.08.15.18;	author thib;	state Exp;
branches;
next	1.6;

1.6
date	2010.07.05.16.53.08;	author thib;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.05.16.33.36;	author thib;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.30.17.14.36;	author thib;	state Exp;
branches;
next	1.3;

1.3
date	2010.06.30.17.11.05;	author thib;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.30.17.00.42;	author thib;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.29.21.34.11;	author thib;	state Exp;
branches;
next	;

1.8.2.1
date	2010.12.17.16.25.14;	author jasper;	state Exp;
branches;
next	;


desc
@@


1.41
log
@Switch glxsb(4), VIA padlock and AES-NI drivers over to the new AES
@
text
@/*	$OpenBSD: aesni.c,v 1.40 2017/02/07 17:25:45 patrick Exp $	*/
/*-
 * Copyright (c) 2003 Jason Wright
 * Copyright (c) 2003, 2004 Theo de Raadt
 * Copyright (c) 2010, Thordur I. Bjornsson
 * Copyright (c) 2010, Mike Belopuhov
 * All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/queue.h>
#include <sys/types.h>
#include <sys/malloc.h>
#include <sys/pool.h>
#include <sys/mbuf.h>

#include <crypto/cryptodev.h>
#include <crypto/aes.h>
#include <crypto/gmac.h>
#include <crypto/xform.h>
#include <crypto/cryptosoft.h>

#include <machine/fpu.h>

/* defines from crypto/xform.c */
#define AESCTR_NONCESIZE	4
#define AESCTR_IVSIZE		8
#define AESCTR_BLOCKSIZE	16

#define AES_XTS_BLOCKSIZE	16
#define AES_XTS_IVSIZE		8
#define AES_XTS_ALPHA		0x87	/* GF(2^128) generator polynomial */

struct aesni_aes_ctx {
	uint32_t		 aes_ekey[4 * (AES_MAXROUNDS + 1)];
	uint32_t		 aes_dkey[4 * (AES_MAXROUNDS + 1)];
	uint32_t		 aes_klen;
	uint32_t		 aes_pad[3];
};

struct aesni_xts_ctx {
	struct aesni_aes_ctx	 xts_keys[2];
};

struct aesni_session {
	uint32_t		 ses_ekey[4 * (AES_MAXROUNDS + 1)];
	uint32_t		 ses_dkey[4 * (AES_MAXROUNDS + 1)];
	uint32_t		 ses_klen;
	uint8_t			 ses_nonce[AESCTR_NONCESIZE];
	int			 ses_sid;
	GHASH_CTX		*ses_ghash;
	struct aesni_xts_ctx	*ses_xts;
	struct swcr_data	*ses_swd;
	LIST_ENTRY(aesni_session)
				 ses_entries;
	uint8_t			*ses_buf;
	size_t			 ses_buflen;
};

struct aesni_softc {
	int32_t			 sc_cid;
	uint32_t		 sc_sid;
	struct mutex		 sc_mtx;
	LIST_HEAD(, aesni_session)
				 sc_sessions;
} *aesni_sc;

struct pool aesnipl;

uint32_t aesni_ops;

/* assembler-assisted key setup */
extern void aesni_set_key(struct aesni_session *ses, uint8_t *key, size_t len);

/* aes encryption/decryption */
extern void aesni_enc(struct aesni_session *ses, uint8_t *dst, uint8_t *src);
extern void aesni_dec(struct aesni_session *ses, uint8_t *dst, uint8_t *src);

/* assembler-assisted CBC mode */
extern void aesni_cbc_enc(struct aesni_session *ses, uint8_t *dst,
	    uint8_t *src, size_t len, uint8_t *iv);
extern void aesni_cbc_dec(struct aesni_session *ses, uint8_t *dst,
	    uint8_t *src, size_t len, uint8_t *iv);

/* assembler-assisted CTR mode */
extern void aesni_ctr_enc(struct aesni_session *ses, uint8_t *dst,
	    uint8_t *src, size_t len, uint8_t *icb);

/* assembler-assisted XTS mode */
extern void aesni_xts_enc(struct aesni_xts_ctx *xts, uint8_t *dst,
	    uint8_t *src, size_t len, uint8_t *tweak);
extern void aesni_xts_dec(struct aesni_xts_ctx *xts, uint8_t *dst,
	    uint8_t *src, size_t len, uint8_t *tweak);

/* assembler-assisted GMAC */
extern void aesni_gmac_update(GHASH_CTX *ghash, uint8_t *src, size_t len);
extern void aesni_gmac_final(struct aesni_session *ses, uint8_t *tag,
    uint8_t *icb, uint8_t *hashstate);

void	aesni_setup(void);
int	aesni_newsession(u_int32_t *, struct cryptoini *);
int	aesni_freesession(u_int64_t);
int	aesni_process(struct cryptop *);

int	aesni_swauth(struct cryptop *, struct cryptodesc *, struct swcr_data *,
	    caddr_t);

int	aesni_encdec(struct cryptop *, struct cryptodesc *,
	    struct cryptodesc *, struct aesni_session *);

void	pclmul_setup(void);
void	ghash_update_pclmul(GHASH_CTX *, uint8_t *, size_t);

void
aesni_setup(void)
{
	int algs[CRYPTO_ALGORITHM_MAX + 1];

	aesni_sc = malloc(sizeof(*aesni_sc), M_DEVBUF, M_NOWAIT|M_ZERO);
	if (aesni_sc == NULL)
		return;

	bzero(algs, sizeof(algs));

	/* Encryption algorithms. */
	algs[CRYPTO_AES_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_AES_CTR] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_AES_GCM_16] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_AES_XTS] = CRYPTO_ALG_FLAG_SUPPORTED;

	/* Authenticated encryption algorithms. */
	algs[CRYPTO_AES_GMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_AES_128_GMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_AES_192_GMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_AES_256_GMAC] = CRYPTO_ALG_FLAG_SUPPORTED;

	/* HMACs needed for IPsec, uses software crypto. */
	algs[CRYPTO_MD5_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_SHA1_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_RIPEMD160_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_SHA2_256_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_SHA2_384_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_SHA2_512_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;

	/* IPsec Extended Sequence Numbers. */
	algs[CRYPTO_ESN] = CRYPTO_ALG_FLAG_SUPPORTED;

	aesni_sc->sc_cid = crypto_get_driverid(CRYPTOCAP_F_MPSAFE);
	if (aesni_sc->sc_cid < 0) {
		free(aesni_sc, M_DEVBUF, sizeof(*aesni_sc));
		return;
	}

	pool_init(&aesnipl, sizeof(struct aesni_session), 16, IPL_VM, 0,
	    "aesni", NULL);
	pool_setlowat(&aesnipl, 2);

	mtx_init(&aesni_sc->sc_mtx, IPL_VM);

	crypto_register(aesni_sc->sc_cid, algs, aesni_newsession,
	    aesni_freesession, aesni_process);
}

int
aesni_newsession(u_int32_t *sidp, struct cryptoini *cri)
{
	struct aesni_session *ses = NULL;
	struct aesni_aes_ctx *aes1, *aes2;
	struct cryptoini *c;
	struct auth_hash *axf;
	struct swcr_data *swd;
	int i;

	if (sidp == NULL || cri == NULL)
		return (EINVAL);

	ses = pool_get(&aesnipl, PR_NOWAIT | PR_ZERO);
	if (!ses)
		return (ENOMEM);

	ses->ses_buf = malloc(PAGE_SIZE, M_DEVBUF, M_NOWAIT|M_ZERO);
	if (ses->ses_buf != NULL)
		ses->ses_buflen = PAGE_SIZE;

	mtx_enter(&aesni_sc->sc_mtx);
	LIST_INSERT_HEAD(&aesni_sc->sc_sessions, ses, ses_entries);
	mtx_leave(&aesni_sc->sc_mtx);
	ses->ses_sid = ++aesni_sc->sc_sid;

	for (c = cri; c != NULL; c = c->cri_next) {
		switch (c->cri_alg) {
		case CRYPTO_AES_CBC:
			ses->ses_klen = c->cri_klen / 8;
			fpu_kernel_enter();
			aesni_set_key(ses, c->cri_key, ses->ses_klen);
			fpu_kernel_exit();
			break;

		case CRYPTO_AES_CTR:
		case CRYPTO_AES_GCM_16:
		case CRYPTO_AES_GMAC:
			ses->ses_klen = c->cri_klen / 8 - AESCTR_NONCESIZE;
			memcpy(ses->ses_nonce, c->cri_key + ses->ses_klen,
			    AESCTR_NONCESIZE);
			fpu_kernel_enter();
			aesni_set_key(ses, c->cri_key, ses->ses_klen);
			fpu_kernel_exit();
			break;

		case CRYPTO_AES_XTS:
			ses->ses_xts = malloc(sizeof(struct aesni_xts_ctx),
			    M_CRYPTO_DATA, M_NOWAIT | M_ZERO);
			if (ses->ses_xts == NULL) {
				aesni_freesession(ses->ses_sid);
				return (ENOMEM);
			}

			ses->ses_klen = c->cri_klen / 16;
			aes1 = &ses->ses_xts->xts_keys[0];
			aes1->aes_klen = ses->ses_klen;
			aes2 = &ses->ses_xts->xts_keys[1];
			aes2->aes_klen = ses->ses_klen;

			fpu_kernel_enter();
			aesni_set_key((struct aesni_session *)aes1,
			    c->cri_key, aes1->aes_klen);
			aesni_set_key((struct aesni_session *)aes2,
			    c->cri_key + ses->ses_klen, aes2->aes_klen);
			fpu_kernel_exit();
			break;

		case CRYPTO_AES_128_GMAC:
		case CRYPTO_AES_192_GMAC:
		case CRYPTO_AES_256_GMAC:
			ses->ses_ghash = malloc(sizeof(GHASH_CTX),
			    M_CRYPTO_DATA, M_NOWAIT | M_ZERO);
			if (ses->ses_ghash == NULL) {
				aesni_freesession(ses->ses_sid);
				return (ENOMEM);
			}

			bzero(ses->ses_ghash->H, GMAC_BLOCK_LEN);
			bzero(ses->ses_ghash->S, GMAC_BLOCK_LEN);
			bzero(ses->ses_ghash->Z, GMAC_BLOCK_LEN);

			/* prepare a hash subkey */
			aesni_enc(ses, ses->ses_ghash->H, ses->ses_ghash->H);
			break;

		case CRYPTO_MD5_HMAC:
			axf = &auth_hash_hmac_md5_96;
			goto authcommon;
		case CRYPTO_SHA1_HMAC:
			axf = &auth_hash_hmac_sha1_96;
			goto authcommon;
		case CRYPTO_RIPEMD160_HMAC:
			axf = &auth_hash_hmac_ripemd_160_96;
			goto authcommon;
		case CRYPTO_SHA2_256_HMAC:
			axf = &auth_hash_hmac_sha2_256_128;
			goto authcommon;
		case CRYPTO_SHA2_384_HMAC:
			axf = &auth_hash_hmac_sha2_384_192;
			goto authcommon;
		case CRYPTO_SHA2_512_HMAC:
			axf = &auth_hash_hmac_sha2_512_256;
		authcommon:
			swd = malloc(sizeof(struct swcr_data), M_CRYPTO_DATA,
			    M_NOWAIT|M_ZERO);
			if (swd == NULL) {
				aesni_freesession(ses->ses_sid);
				return (ENOMEM);
			}
			ses->ses_swd = swd;

			swd->sw_ictx = malloc(axf->ctxsize, M_CRYPTO_DATA,
			    M_NOWAIT);
			if (swd->sw_ictx == NULL) {
				aesni_freesession(ses->ses_sid);
				return (ENOMEM);
			}

			swd->sw_octx = malloc(axf->ctxsize, M_CRYPTO_DATA,
			    M_NOWAIT);
			if (swd->sw_octx == NULL) {
				aesni_freesession(ses->ses_sid);
				return (ENOMEM);
			}

			for (i = 0; i < c->cri_klen / 8; i++)
				c->cri_key[i] ^= HMAC_IPAD_VAL;

			axf->Init(swd->sw_ictx);
			axf->Update(swd->sw_ictx, c->cri_key, c->cri_klen / 8);
			axf->Update(swd->sw_ictx, hmac_ipad_buffer,
			    axf->blocksize - (c->cri_klen / 8));

			for (i = 0; i < c->cri_klen / 8; i++)
				c->cri_key[i] ^= (HMAC_IPAD_VAL ^
				    HMAC_OPAD_VAL);

			axf->Init(swd->sw_octx);
			axf->Update(swd->sw_octx, c->cri_key, c->cri_klen / 8);
			axf->Update(swd->sw_octx, hmac_opad_buffer,
			    axf->blocksize - (c->cri_klen / 8));

			for (i = 0; i < c->cri_klen / 8; i++)
				c->cri_key[i] ^= HMAC_OPAD_VAL;

			swd->sw_axf = axf;
			swd->sw_alg = c->cri_alg;

			break;

		case CRYPTO_ESN:
			/* nothing to do */
			break;

		default:
			aesni_freesession(ses->ses_sid);
			return (EINVAL);
		}
	}

	*sidp = ses->ses_sid;
	return (0);
}

int
aesni_freesession(u_int64_t tid)
{
	struct aesni_session *ses;
	struct swcr_data *swd;
	struct auth_hash *axf;
	u_int32_t sid = (u_int32_t)tid;

	mtx_enter(&aesni_sc->sc_mtx);
	LIST_FOREACH(ses, &aesni_sc->sc_sessions, ses_entries) {
		if (ses->ses_sid == sid)
			break;
	}
	mtx_leave(&aesni_sc->sc_mtx);

	if (ses == NULL)
		return (EINVAL);

	mtx_enter(&aesni_sc->sc_mtx);
	LIST_REMOVE(ses, ses_entries);
	mtx_leave(&aesni_sc->sc_mtx);

	if (ses->ses_ghash) {
		explicit_bzero(ses->ses_ghash, sizeof(GHASH_CTX));
		free(ses->ses_ghash, M_CRYPTO_DATA, sizeof(GHASH_CTX));
	}

	if (ses->ses_xts) {
		explicit_bzero(ses->ses_xts, sizeof(struct aesni_xts_ctx));
		free(ses->ses_xts, M_CRYPTO_DATA, sizeof(struct aesni_xts_ctx));
	}

	if (ses->ses_swd) {
		swd = ses->ses_swd;
		axf = swd->sw_axf;

		if (swd->sw_ictx) {
			explicit_bzero(swd->sw_ictx, axf->ctxsize);
			free(swd->sw_ictx, M_CRYPTO_DATA, axf->ctxsize);
		}
		if (swd->sw_octx) {
			explicit_bzero(swd->sw_octx, axf->ctxsize);
			free(swd->sw_octx, M_CRYPTO_DATA, axf->ctxsize);
		}
		free(swd, M_CRYPTO_DATA, sizeof(*swd));
	}

	if (ses->ses_buf) {
		explicit_bzero(ses->ses_buf, ses->ses_buflen);
		free(ses->ses_buf, M_DEVBUF, ses->ses_buflen);
	}

	explicit_bzero(ses, sizeof (*ses));
	pool_put(&aesnipl, ses);

	return (0);
}

int
aesni_swauth(struct cryptop *crp, struct cryptodesc *crd,
    struct swcr_data *sw, caddr_t buf)
{
	int type;

	if (crp->crp_flags & CRYPTO_F_IMBUF)
		type = CRYPTO_BUF_MBUF;
	else
		type = CRYPTO_BUF_IOV;

	return (swcr_authcompute(crp, crd, sw, buf, type));
}

int
aesni_encdec(struct cryptop *crp, struct cryptodesc *crd,
    struct cryptodesc *crda, struct aesni_session *ses)
{
	int aadlen, err, ivlen, iskip, oskip, rlen;
	uint8_t iv[EALG_MAX_BLOCK_LEN];
	uint8_t icb[AESCTR_BLOCKSIZE];
	uint8_t tag[GMAC_DIGEST_LEN];
	uint8_t *buf = ses->ses_buf;
	uint32_t *dw;

	aadlen = rlen = err = iskip = oskip = 0;

	if (crd->crd_len > ses->ses_buflen) {
		KERNEL_LOCK();
		if (buf != NULL) {
			explicit_bzero(buf, ses->ses_buflen);
			free(buf, M_DEVBUF, ses->ses_buflen);
		}

		ses->ses_buflen = 0;
		rlen = roundup(crd->crd_len, EALG_MAX_BLOCK_LEN);
		ses->ses_buf = buf = malloc(rlen, M_DEVBUF, M_NOWAIT |
		    M_ZERO);
		KERNEL_UNLOCK();
		if (buf == NULL)
			return (ENOMEM);
		ses->ses_buflen = rlen;
	}

	/* CBC uses 16, CTR/XTS only 8. */
	ivlen = (crd->crd_alg == CRYPTO_AES_CBC) ? 16 : 8;

	/* Initialize the IV */
	if (crd->crd_flags & CRD_F_ENCRYPT) {
		if (crd->crd_flags & CRD_F_IV_EXPLICIT)
			memcpy(iv, crd->crd_iv, ivlen);
		else
			arc4random_buf(iv, ivlen);

		/* Do we need to write the IV */
		if ((crd->crd_flags & CRD_F_IV_PRESENT) == 0) {
			if (crp->crp_flags & CRYPTO_F_IMBUF) {
				if (m_copyback((struct mbuf *)crp->crp_buf,
				    crd->crd_inject, ivlen, iv, M_NOWAIT)) {
					err = ENOMEM;
					goto out;
				}
			} else
				cuio_copyback((struct uio *)crp->crp_buf,
				    crd->crd_inject, ivlen, iv);
		}
	} else {
		if (crd->crd_flags & CRD_F_IV_EXPLICIT)
			memcpy(iv, crd->crd_iv, ivlen);
		else {
			if (crp->crp_flags & CRYPTO_F_IMBUF)
				m_copydata((struct mbuf *)crp->crp_buf,
				    crd->crd_inject, ivlen, iv);
			else
				cuio_copydata((struct uio *)crp->crp_buf,
				    crd->crd_inject, ivlen, iv);
		}
	}

	if (crda) {
		/* Supply GMAC with AAD */
		aadlen = crda->crd_len;
		if (crda->crd_flags & CRD_F_ESN) {
			aadlen += 4;
			/* SPI */
			if (crp->crp_flags & CRYPTO_F_IMBUF)
				m_copydata((struct mbuf *)crp->crp_buf,
				    crda->crd_skip, 4, buf);
			else
				cuio_copydata((struct uio *)crp->crp_buf,
				    crda->crd_skip, 4, buf);
			iskip = 4; /* additional input offset */
			/* ESN */
			memcpy(buf + 4, crda->crd_esn, 4);
			oskip = iskip + 4; /* offset output buffer by 8 */
		}
		rlen = roundup(aadlen, GMAC_BLOCK_LEN);
		if (crp->crp_flags & CRYPTO_F_IMBUF)
			m_copydata((struct mbuf *)crp->crp_buf,
			    crda->crd_skip + iskip, crda->crd_len - iskip,
			    buf + oskip);
		else
			cuio_copydata((struct uio *)crp->crp_buf,
			    crda->crd_skip + iskip, crda->crd_len - iskip,
			    buf + oskip);
		fpu_kernel_enter();
		aesni_gmac_update(ses->ses_ghash, buf, rlen);
		fpu_kernel_exit();
		bzero(buf, aadlen);
	}

	/* Copy data to be processed to the buffer */
	if (crp->crp_flags & CRYPTO_F_IMBUF)
		m_copydata((struct mbuf *)crp->crp_buf, crd->crd_skip,
		    crd->crd_len, buf);
	else
		cuio_copydata((struct uio *)crp->crp_buf, crd->crd_skip,
		    crd->crd_len, buf);

	if (crd->crd_alg == CRYPTO_AES_CTR ||
	    crd->crd_alg == CRYPTO_AES_GCM_16 ||
	    crd->crd_alg == CRYPTO_AES_GMAC) {
		bzero(icb, AESCTR_BLOCKSIZE);
		memcpy(icb, ses->ses_nonce, AESCTR_NONCESIZE);
		memcpy(icb + AESCTR_NONCESIZE, iv, AESCTR_IVSIZE);
		/* rlen is for gcm and gmac only */
		rlen = roundup(crd->crd_len, AESCTR_BLOCKSIZE);
	}

	/* Apply cipher */
	fpu_kernel_enter();
	switch (crd->crd_alg) {
	case CRYPTO_AES_CBC:
		if (crd->crd_flags & CRD_F_ENCRYPT)
			aesni_cbc_enc(ses, buf, buf, crd->crd_len, iv);
		else
			aesni_cbc_dec(ses, buf, buf, crd->crd_len, iv);
		break;
	case CRYPTO_AES_CTR:
		aesni_ctr_enc(ses, buf, buf, crd->crd_len, icb);
		break;
	case CRYPTO_AES_GCM_16:
		icb[AESCTR_BLOCKSIZE - 1] = 1;
		if (crd->crd_flags & CRD_F_ENCRYPT) {
			/* encrypt padded data */
			aesni_ctr_enc(ses, buf, buf, rlen, icb);
			/* zero out padding bytes */
			bzero(buf + crd->crd_len, rlen - crd->crd_len);
			/* hash encrypted data padded with zeroes */
			aesni_gmac_update(ses->ses_ghash, buf, rlen);
		} else {
			aesni_gmac_update(ses->ses_ghash, buf, rlen);
			aesni_ctr_enc(ses, buf, buf, rlen, icb);
		}
		goto gcmcommon;
	case CRYPTO_AES_GMAC:
		icb[AESCTR_BLOCKSIZE - 1] = 1;
		aesni_gmac_update(ses->ses_ghash, buf, rlen);
	gcmcommon:
		/* lengths block */
		bzero(tag, GMAC_BLOCK_LEN);
		dw = (uint32_t *)tag + 1;
		*dw = htobe32(aadlen * 8);
		dw = (uint32_t *)tag + 3;
		*dw = htobe32(crd->crd_len * 8);
		aesni_gmac_update(ses->ses_ghash, tag, GMAC_BLOCK_LEN);
		/* finalization */
		aesni_gmac_final(ses, tag, icb, ses->ses_ghash->S);
		break;
	case CRYPTO_AES_XTS:
		if (crd->crd_flags & CRD_F_ENCRYPT)
			aesni_xts_enc(ses->ses_xts, buf, buf, crd->crd_len, iv);
		else
			aesni_xts_dec(ses->ses_xts, buf, buf, crd->crd_len, iv);
		break;
	}
	fpu_kernel_exit();

	aesni_ops++;

	/* Copy back the result */
	if (crp->crp_flags & CRYPTO_F_IMBUF) {
		if (m_copyback((struct mbuf *)crp->crp_buf, crd->crd_skip,
		    crd->crd_len, buf, M_NOWAIT)) {
			err = ENOMEM;
			goto out;
		}
	} else
		cuio_copyback((struct uio *)crp->crp_buf, crd->crd_skip,
		    crd->crd_len, buf);

	/* Copy back the authentication tag */
	if (crda) {
		if (crp->crp_flags & CRYPTO_F_IMBUF) {
			if (m_copyback((struct mbuf *)crp->crp_buf,
			    crda->crd_inject, GMAC_DIGEST_LEN, tag,
			    M_NOWAIT)) {
				err = ENOMEM;
				goto out;
			}
		} else
			memcpy(crp->crp_mac, tag, GMAC_BLOCK_LEN);

		/* clean up GHASH state */
		bzero(ses->ses_ghash->S, GMAC_BLOCK_LEN);
		bzero(ses->ses_ghash->Z, GMAC_BLOCK_LEN);
	}

out:
	explicit_bzero(buf, roundup(crd->crd_len, EALG_MAX_BLOCK_LEN));
	return (err);
}

int
aesni_process(struct cryptop *crp)
{
	struct aesni_session *ses;
	struct cryptodesc *crd, *crda, *crde;
	int err = 0;
	int i;

	if (crp == NULL || crp->crp_callback == NULL)
		return (EINVAL);
	if (crp->crp_ndesc < 1)
		return (EINVAL);

	mtx_enter(&aesni_sc->sc_mtx);
	LIST_FOREACH(ses, &aesni_sc->sc_sessions, ses_entries) {
		if (ses->ses_sid == (crp->crp_sid & 0xffffffff))
			break;
	}
	mtx_leave(&aesni_sc->sc_mtx);

	if (!ses) {
		err = EINVAL;
		goto out;
	}

	crda = crde = NULL;
	for (i = 0; i < crp->crp_ndesc; i++) {
		crd = &crp->crp_desc[i];
		switch (crd->crd_alg) {
		case CRYPTO_AES_CBC:
		case CRYPTO_AES_CTR:
		case CRYPTO_AES_XTS:
			err = aesni_encdec(crp, crd, NULL, ses);
			if (err != 0)
				goto out;
			break;

		case CRYPTO_AES_GCM_16:
		case CRYPTO_AES_GMAC:
			crde = crd;
			if (!crda)
				continue;
			goto gcmcommon;
		case CRYPTO_AES_128_GMAC:
		case CRYPTO_AES_192_GMAC:
		case CRYPTO_AES_256_GMAC:
			crda = crd;
			if (!crde)
				continue;
		gcmcommon:
			err = aesni_encdec(crp, crde, crda, ses);
			if (err != 0)
				goto out;
			break;

		case CRYPTO_MD5_HMAC:
		case CRYPTO_SHA1_HMAC:
		case CRYPTO_RIPEMD160_HMAC:
		case CRYPTO_SHA2_256_HMAC:
		case CRYPTO_SHA2_384_HMAC:
		case CRYPTO_SHA2_512_HMAC:
			err = aesni_swauth(crp, crd, ses->ses_swd,
			    crp->crp_buf);
			if (err != 0)
				goto out;
			break;

		default:
			err = EINVAL;
			goto out;
		}
	}

out:
	crp->crp_etype = err;
	crypto_done(crp);
	return (err);
}

void
pclmul_setup(void)
{
	ghash_update = ghash_update_pclmul;
}

void
ghash_update_pclmul(GHASH_CTX *ghash, uint8_t *src, size_t len)
{
	fpu_kernel_enter();
	aesni_gmac_update(ghash, src, len);
	fpu_kernel_exit();
}
@


1.40
log
@Reduce the per-packet allocation costs for crypto operations (cryptop)
by pre-allocating two cryptodesc objects and storing them in an array
instead of a linked list.  If more than two cryptodesc objects are
required use mallocarray to fetch them.  Adapt the drivers to the new
API.

This change results in one pool-get per ESP packet instead of three.
It also simplifies softraid crypto where more cryptodesc objects are
allocated than used.

From, with and ok markus@@, ok bluhm@@
"looks sane" mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aesni.c,v 1.39 2016/09/15 02:00:16 dlg Exp $	*/
d31 1
a31 1
#include <crypto/rijndael.h>
@


1.39
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@d1 1
a1 1
/*	$OpenBSD: aesni.c,v 1.38 2016/04/18 21:15:18 kettenis Exp $	*/
d619 1
d623 2
d639 2
a640 1
	for (crd = crp->crp_desc; crd; crd = crd->crd_next) {
@


1.38
log
@Make the aesni crypto implementation mpsafe.  In order to do so this moves
the working buffer from the softc into session struct.  The list of sessions
is protected by a mutex.

There has been some discussion about what IPL should be used for the mutex.
Initially my code used IPL_HIGH since that is the default to be used for
subsystems that can be called from any other subsystem.  But since the crypto
code may call malloc/free, I settled on IPL_VM.  Calling it from an interrupt
handler that runs at a higher level is unsafe.  Sorry, can't encrypt audio!

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aesni.c,v 1.37 2016/04/17 03:12:08 dlg Exp $	*/
d167 1
a167 1
	pool_init(&aesnipl, sizeof(struct aesni_session), 16, 0, 0,
a168 1
	pool_setipl(&aesnipl, IPL_VM);
@


1.37
log
@pool_setipl for the aesnipl

it's set to IPL_VM to be conservative wrt its interaction with the crypto
subsystem.
@
text
@d1 1
a1 1
/*	$OpenBSD: aesni.c,v 1.36 2015/11/07 01:37:26 naddy Exp $	*/
d69 2
a73 2
	uint8_t			*sc_buf;
	size_t			 sc_buflen;
d76 1
a135 4
	aesni_sc->sc_buf = malloc(PAGE_SIZE, M_DEVBUF, M_NOWAIT|M_ZERO);
	if (aesni_sc->sc_buf != NULL)
		aesni_sc->sc_buflen = PAGE_SIZE;

d161 1
a161 1
	aesni_sc->sc_cid = crypto_get_driverid(0);
a162 1
		free(aesni_sc->sc_buf, M_DEVBUF, aesni_sc->sc_buflen);
d172 2
d194 6
d201 1
d351 1
d356 1
d361 1
d363 1
d390 5
d423 1
a423 1
	uint8_t *buf = aesni_sc->sc_buf;
d428 2
a429 1
	if (crd->crd_len > aesni_sc->sc_buflen) {
d431 2
a432 2
			explicit_bzero(buf, aesni_sc->sc_buflen);
			free(buf, M_DEVBUF, aesni_sc->sc_buflen);
d435 1
a435 1
		aesni_sc->sc_buflen = 0;
d437 1
a437 1
		aesni_sc->sc_buf = buf = malloc(rlen, M_DEVBUF, M_NOWAIT |
d439 1
d442 1
a442 1
		aesni_sc->sc_buflen = rlen;
d624 1
d629 1
@


1.36
log
@Allow overriding ghash_update() with an optimized MD function.  Use
this on amd64 to provide a version that uses the PCLMUL instruction
on CPUs that support it but don't have AESNI.  ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aesni.c,v 1.35 2015/08/28 19:59:36 tedu Exp $	*/
d173 1
@


1.35
log
@fix an unprobable leak. ok deraadt mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: aesni.c,v 1.34 2015/08/28 16:16:44 tedu Exp $	*/
d123 3
d668 14
@


1.34
log
@a few more free sizes. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: aesni.c,v 1.33 2015/08/28 00:03:53 deraadt Exp $	*/
d163 1
@


1.33
log
@fairly simple sizes for free(); ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: aesni.c,v 1.32 2015/03/14 03:38:46 jsg Exp $	*/
d353 1
a353 1
		free(ses->ses_ghash, M_CRYPTO_DATA, 0);
d358 1
a358 1
		free(ses->ses_xts, M_CRYPTO_DATA, 0);
d367 1
a367 1
			free(swd->sw_ictx, M_CRYPTO_DATA, 0);
d371 1
a371 1
			free(swd->sw_octx, M_CRYPTO_DATA, 0);
d373 1
a373 1
		free(swd, M_CRYPTO_DATA, 0);
d412 1
a412 1
			free(buf, M_DEVBUF, 0);
@


1.32
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aesni.c,v 1.31 2014/12/15 01:53:45 tedu Exp $	*/
d163 1
a163 1
		free(aesni_sc, M_DEVBUF, 0);
@


1.31
log
@change bcopy to memcpy. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: aesni.c,v 1.30 2014/11/18 20:51:00 krw Exp $	*/
a34 2

#include <dev/rndvar.h>
@


1.30
log
@Nuke some obvious #include duplications.

ok espie@@ deraadt@@ millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aesni.c,v 1.29 2014/11/18 15:18:01 mikeb Exp $	*/
d209 1
a209 1
			bcopy(c->cri_key + ses->ses_klen, ses->ses_nonce,
d432 1
a432 1
			bcopy(crd->crd_iv, iv, ivlen);
d450 1
a450 1
			bcopy(crd->crd_iv, iv, ivlen);
d475 1
a475 1
			bcopy(crda->crd_esn, buf + 4, 4);
d505 2
a506 2
		bcopy(ses->ses_nonce, icb, AESCTR_NONCESIZE);
		bcopy(iv, icb + AESCTR_NONCESIZE, AESCTR_IVSIZE);
d583 1
a583 1
			bcopy(tag, crp->crp_mac, GMAC_BLOCK_LEN);
@


1.29
log
@drop "pl" from the pool name and use pool_setlowat
@
text
@d1 1
a1 1
/*	$OpenBSD: aesni.c,v 1.28 2014/08/18 05:11:03 dlg Exp $	*/
a28 1
#include <sys/pool.h>
@


1.28
log
@dont rely on mbuf.h to provide pool.h.

ok miod@@, who has offerred to help with any MD fallout
ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aesni.c,v 1.27 2014/07/12 18:44:41 tedu Exp $	*/
d171 2
a172 2
	    "aesnipl", NULL);
	pool_prime(&aesnipl, 2);
@


1.27
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: aesni.c,v 1.26 2014/01/18 23:17:24 mikeb Exp $	*/
d27 1
@


1.26
log
@tweak comments a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: aesni.c,v 1.25 2013/03/26 15:47:01 jsing Exp $	*/
d165 1
a165 1
		free(aesni_sc, M_DEVBUF);
d355 1
a355 1
		free(ses->ses_ghash, M_CRYPTO_DATA);
d360 1
a360 1
		free(ses->ses_xts, M_CRYPTO_DATA);
d369 1
a369 1
			free(swd->sw_ictx, M_CRYPTO_DATA);
d373 1
a373 1
			free(swd->sw_octx, M_CRYPTO_DATA);
d375 1
a375 1
		free(swd, M_CRYPTO_DATA);
d414 1
a414 1
			free(buf, M_DEVBUF);
@


1.25
log
@Add AES-XTS support to the aesni crypto driver. This allows softraid(4)
to benefit from the AES-NI instructions found on newer Intel CPUs.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aesni.c,v 1.24 2012/12/10 15:06:45 mikeb Exp $	*/
d146 1
a146 1
	/* Authentication algorithms. */
d160 1
@


1.24
log
@Implement support for Extended Sequence Numbers for the aesni driver
exercising the same approach as in sys/crypto/cryptosoft.c rev1.67.
@
text
@d1 1
a1 1
/*	$OpenBSD: aesni.c,v 1.23 2012/10/04 13:17:12 haesbaert Exp $	*/
d45 15
d67 1
d103 6
d139 2
d144 3
d152 1
a152 1
	/* needed for ipsec, uses software crypto */
d180 1
d215 22
d353 1
a353 1
		bzero(ses->ses_ghash, sizeof(GHASH_CTX));
d357 5
d401 1
a406 1
	int aadlen, err, ivlen, iskip, oskip, rlen;
d425 1
a425 1
	/* CBC uses 16, CTR only 8 */
d550 6
d619 1
@


1.23
log
@Clean up uninitialized warnings from cryptosoft and aesni.
Part of the work to remove -Wno-uninitialized.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aesni.c,v 1.22 2011/08/17 17:00:35 mikeb Exp $	*/
d133 2
d269 5
d351 3
a353 1
	int ivlen, rlen = 0, err = 0;
d407 16
a422 1
		rlen = roundup(crda->crd_len, GMAC_BLOCK_LEN);
d424 3
a426 2
			m_copydata((struct mbuf *)crp->crp_buf, crda->crd_skip,
			    crda->crd_len, buf);
d429 2
a430 1
			    crda->crd_skip, crda->crd_len, buf);
d434 1
a434 1
		bzero(buf, crda->crd_len);
d488 1
a488 1
		*dw = htobe32(crda->crd_len * 8);
@


1.22
log
@Assembler implementation of the GCM mode using the Carry-less
Multiplication (CLMUL) instruction found in the new Intel and
future AMD CPUs.

Done about a year ago and was rotting in my trees until Ryan
prodded Theo to read the white paper and figure out the license
issues.  Apparently, there are none.  All C code and SSE glue
code was written by me, while the GF multiplication function
is taken from the CLMUL white paper, specifically Figure 6:
"Code Sample - Performing Ghash Using Algorithms 1 and 5".
@
text
@d1 1
a1 1
/*	$OpenBSD: aesni.c,v 1.21 2011/05/06 17:31:16 mikeb Exp $	*/
d344 1
a344 1
	int ivlen, rlen, err = 0;
@


1.21
log
@session id is only in the lower 32 bits of crp_sid
@
text
@d1 1
a1 1
/*	$OpenBSD: aesni.c,v 1.20 2011/04/20 06:51:34 deraadt Exp $	*/
d32 1
d51 1
d87 5
d101 1
a101 1
	    struct aesni_session *);
d119 5
d175 2
d185 18
d295 5
d337 1
a337 1
    struct aesni_session *ses)
d341 1
d343 1
a345 5
	if ((crd->crd_len % 16) != 0) {
		err = EINVAL;
		return (err);
	}

d396 15
d419 10
a438 3
		bzero(icb, AESCTR_BLOCKSIZE);
		bcopy(ses->ses_nonce, icb, AESCTR_NONCESIZE);
		bcopy(iv, icb + AESCTR_NONCESIZE, AESCTR_IVSIZE);
d441 28
d485 17
d511 1
a511 1
	struct cryptodesc *crd;
d527 1
d532 19
a550 1
			err = aesni_encdec(crp, crd, ses);
@


1.20
log
@Potential NULL deref in an error case spotted by chl on one copy;
correct fix applied to 3 similar drivers
ok chl
@
text
@d1 1
a1 1
/*	$OpenBSD: aesni.c,v 1.19 2011/01/12 17:15:23 deraadt Exp $	*/
d417 1
a417 1
		if (ses->ses_sid == crp->crp_sid)
@


1.19
log
@use explicit_bzero() for the session, in drivers where struct session
contains key material (note, that is not true in all drivers... hence
not always neccessary)
discussed with mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: aesni.c,v 1.18 2011/01/11 15:42:05 deraadt Exp $	*/
d413 2
a414 4
	if (crp == NULL || crp->crp_callback == NULL) {
		err = EINVAL;
		goto out;
	}
@


1.18
log
@for key material that is being being discarded, convert bzero() to
explicit_bzero() where required
ok markus mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: aesni.c,v 1.17 2010/12/15 23:34:23 mikeb Exp $	*/
d278 1
a278 1
	bzero(ses, sizeof (*ses));
@


1.17
log
@Bring CBC oracle attack countermeasure from r1.32 of cryptosoft.c to
the hardware crypto accelerator land.  This fixes aes-ni, via xcrypt,
glxsb(4), hifn(4), safe(4) and ubsec(4) drivers.

Original commit message by angelos:

Don't keep the last blocksize-bytes of ciphertext for use as the next
plaintext's IV, in CBC mode. Use arc4random() to acquire fresh IVs per
message.

with and ok deraadt, ok markus, djm
@
text
@d1 1
a1 1
/*	$OpenBSD: aesni.c,v 1.16 2010/11/15 14:48:17 mikeb Exp $	*/
d268 1
a268 1
			bzero(swd->sw_ictx, axf->ctxsize);
d272 1
a272 1
			bzero(swd->sw_octx, axf->ctxsize);
d314 1
a314 1
			bzero(buf, aesni_sc->sc_buflen);
d402 1
a402 1
	bzero(buf, roundup(crd->crd_len, EALG_MAX_BLOCK_LEN));
@


1.16
log
@rename aesni_sess to aesni_session;  bugged me all the time
@
text
@d1 1
a1 1
/*	$OpenBSD: aesni.c,v 1.15 2010/11/15 14:41:41 mikeb Exp $	*/
a48 1
	uint8_t			 ses_iv[EALG_MAX_BLOCK_LEN];
a156 1
			arc4random_buf(ses->ses_iv, 16);
a165 1
			arc4random_buf(ses->ses_iv, 8);
d335 1
a335 1
			bcopy(ses->ses_iv, iv, ivlen);
a399 18

	/*
	 * Copy out last block for use as next session IV for CBC,
	 * generate new IV for CTR.
	 */
	if (crd->crd_flags & CRD_F_ENCRYPT) {
		if (crd->crd_alg == CRYPTO_AES_CBC) {
			if (crp->crp_flags & CRYPTO_F_IMBUF)
				m_copydata((struct mbuf *)crp->crp_buf,
				    crd->crd_skip + crd->crd_len - ivlen, ivlen,
				    ses->ses_iv);
			else
				cuio_copydata((struct uio *)crp->crp_buf,
				    crd->crd_skip + crd->crd_len - ivlen, ivlen,
				    ses->ses_iv);
		} else if (crd->crd_alg == CRYPTO_AES_CTR)
			arc4random_buf(ses->ses_iv, ivlen);
	}
@


1.15
log
@do session allocations from the pool
@
text
@d1 1
a1 1
/*	$OpenBSD: aesni.c,v 1.14 2010/11/15 14:24:13 mikeb Exp $	*/
d44 1
a44 1
struct aesni_sess {
d52 2
a53 1
	LIST_ENTRY(aesni_sess)	 ses_entries;
d61 2
a62 1
	LIST_HEAD(, aesni_sess)	 sc_sessions;
d70 1
a70 1
extern void aesni_set_key(struct aesni_sess *ses, uint8_t *key, size_t len);
d73 2
a74 2
extern void aesni_enc(struct aesni_sess *ses, uint8_t *dst, uint8_t *src);
extern void aesni_dec(struct aesni_sess *ses, uint8_t *dst, uint8_t *src);
d77 1
a77 1
extern void aesni_cbc_enc(struct aesni_sess *ses, uint8_t *dst,
d79 1
a79 1
extern void aesni_cbc_dec(struct aesni_sess *ses, uint8_t *dst,
d83 1
a83 1
extern void aesni_ctr_enc(struct aesni_sess *ses, uint8_t *dst,
d95 1
a95 1
	    struct aesni_sess *);
d128 1
a128 1
	pool_init(&aesnipl, sizeof(struct aesni_sess), 16, 0, 0,
d139 1
a140 1
	struct aesni_sess *ses = NULL;
d251 1
a251 1
	struct aesni_sess *ses;
d303 1
a303 1
    struct aesni_sess *ses)
d430 1
a430 1
	struct aesni_sess *ses;
@


1.14
log
@thrash less cache lines and zero out only what we've touched
@
text
@d1 1
a1 1
/*	$OpenBSD: aesni.c,v 1.13 2010/11/15 12:57:24 mikeb Exp $	*/
d28 1
a50 1
	int		 	 ses_used;
d59 1
d63 3
a65 1
uint32_t aesni_nsessions, aesni_ops;
d126 4
a140 1
	caddr_t ptr = NULL;
d146 5
a150 21
	LIST_FOREACH(ses, &aesni_sc->sc_sessions, ses_entries) {
		if (ses->ses_used == 0)
			break;
	}

	if (!ses) {
		/* XXX use pool? */
		ptr = malloc(sizeof(*ses) + 16, M_DEVBUF, M_NOWAIT | M_ZERO);
		if (!ptr)
			return (ENOMEM);
		/*
		 * align to a 16 byte boundary, "the most utterly retarded
		 * requirement".
		 */
		ses = (struct aesni_sess *)(roundup(((uint64_t)ptr), 16));

		LIST_INSERT_HEAD(&aesni_sc->sc_sessions, ses, ses_entries);
		ses->ses_sid = ++aesni_nsessions;
	}

	ses->ses_used = 1;
d280 1
a280 3

	LIST_INSERT_HEAD(&aesni_sc->sc_sessions, ses, ses_entries);
	ses->ses_sid = sid;
@


1.13
log
@convert one if-else instance to the switch to ease gcm integration;
use proper define for the initial counter block
@
text
@d1 1
a1 1
/*	$OpenBSD: aesni.c,v 1.12 2010/11/15 12:30:29 mikeb Exp $	*/
d433 1
a433 1
	bzero(buf, aesni_sc->sc_buflen);
@


1.12
log
@round up crd_len to the blocksize;  will be needed for gcm
@
text
@d1 1
a1 1
/*	$OpenBSD: aesni.c,v 1.11 2010/11/15 11:52:58 mikeb Exp $	*/
d316 1
a316 1
	uint8_t icb[EALG_MAX_BLOCK_LEN];
d385 2
a386 1
	if (crd->crd_alg == CRYPTO_AES_CBC) {
d391 3
a393 2
	} else if (crd->crd_alg == CRYPTO_AES_CTR) {
		bzero(icb, sizeof(icb));
d397 1
@


1.11
log
@there's either mbuf or an iovec, no other option is possible
@
text
@d1 1
a1 1
/*	$OpenBSD: aesni.c,v 1.10 2010/11/10 17:05:39 mikeb Exp $	*/
d318 1
a318 2
	int ivlen = 0;
	int err = 0;
d332 3
a334 2
		aesni_sc->sc_buf = buf = malloc(crd->crd_len, M_DEVBUF,
		    M_NOWAIT|M_ZERO);
d337 1
a337 1
		aesni_sc->sc_buflen = crd->crd_len;
d430 1
a430 1
	bzero(buf, crd->crd_len);
@


1.10
log
@pass aesni_ctr_enc an initial counter block instead of an initialization vector
@
text
@d1 1
a1 1
/*	$OpenBSD: aesni.c,v 1.9 2010/09/07 15:51:00 mikeb Exp $	*/
a37 1

d355 2
a356 2
				    err = ENOMEM;
				    goto out;
d358 1
a358 1
			} else if (crp->crp_flags & CRYPTO_F_IOV)
a360 3
			else
				bcopy(iv, crp->crp_buf + crd->crd_inject,
				    ivlen);
d369 1
a369 1
			else if (crp->crp_flags & CRYPTO_F_IOV)
a371 3
			else
				bcopy(crp->crp_buf + crd->crd_inject,
				    iv, ivlen);
d379 1
a379 1
	else if (crp->crp_flags & CRYPTO_F_IOV)
a381 2
	else
		bcopy(crp->crp_buf + crd->crd_skip, buf, crd->crd_len);
d407 1
a407 1
	} else if (crp->crp_flags & CRYPTO_F_IOV)
a409 2
	else
		bcopy(buf, crp->crp_buf + crd->crd_skip, crd->crd_len);
d421 1
a421 1
			else if (crp->crp_flags & CRYPTO_F_IOV)
a424 3
			else
				bcopy(crp->crp_buf + crd->crd_skip +
				    crd->crd_len - ivlen, ses->ses_iv, ivlen);
@


1.9
log
@shorten fpu critical sections so that all frees and other manipulations
won't interfere with an actual fp code.

reminder from kettenis: fpu_kernel_enter and fpu_kernel_exit should be
thought of as if they were mutex_enter and mutex_leave in regard to the
length of critical section and sleeps.

ok kettenis thib
@
text
@d1 1
a1 1
/*	$OpenBSD: aesni.c,v 1.8 2010/07/22 12:47:40 thib Exp $	*/
d80 1
a80 1
	    uint8_t *src, size_t len, uint8_t *iv);
d317 1
d400 4
a403 1
		aesni_ctr_enc(ses, buf, buf, crd->crd_len, iv);
@


1.8
log
@Fixes for AES CTR mode from mikeb:

o Fix up counter increment for buffers larger then 64 bytes, by
  calling the increment routine before loading the IV into the
  encryption routine input register.

o In aesni_encdec() regenerate the IV for every new request.

Also use nice defines instead of magic constants for the size
of ses_iv.
@
text
@d1 1
a1 1
/*	$OpenBSD: aesni.c,v 1.7 2010/07/08 08:15:18 thib Exp $	*/
a162 1
	fpu_kernel_enter();
d168 1
d170 1
d178 1
d180 1
a251 1
	fpu_kernel_exit();
d392 1
d401 1
a465 1
	fpu_kernel_enter();
d472 1
a472 1
				goto cleanup;
d484 1
a484 1
				goto cleanup;
d489 1
a489 1
			goto cleanup;
d492 1
a492 2
cleanup:
	fpu_kernel_exit();
@


1.8.2.1
log
@Backport from -current, original commit by mikeb@@:
------
Bring CBC oracle attack countermeasure from r1.32 of cryptosoft.c to
the hardware crypto accelerator land.  This fixes aes-ni, via xcrypt,
glxsb(4), hifn(4), safe(4) and ubsec(4) drivers.
------

ok deraadt@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aesni.c,v 1.8 2010/07/22 12:47:40 thib Exp $	*/
d49 1
d168 1
d176 1
d346 1
a346 1
			arc4random_buf(iv, ivlen);
d413 21
@


1.7
log
@better op buf handling. Instead of mallocing a new buffer for every
encdec operation, keep a PAGE_SIZE (or not, depending if we fail during
setup) buf around; if the crd_len is larger then the current buf, re allocate
a new one that fits the data, and keep it around.
@
text
@d1 1
a1 1
/*	$OpenBSD: aesni.c,v 1.6 2010/07/05 16:53:08 thib Exp $	*/
d49 1
a49 1
	uint8_t			 ses_iv[16];
d414 19
a432 13
	/* Copy out last block for use as next session IV for CBC */
	if (crd->crd_alg == CRYPTO_AES_CBC && crd->crd_flags & CRD_F_ENCRYPT) {
		if (crp->crp_flags & CRYPTO_F_IMBUF)
			m_copydata((struct mbuf *)crp->crp_buf,
			    crd->crd_skip + crd->crd_len - ivlen, ivlen,
			    ses->ses_iv);
		else if (crp->crp_flags & CRYPTO_F_IOV)
			cuio_copydata((struct uio *)crp->crp_buf,
			    crd->crd_skip + crd->crd_len - ivlen, ivlen,
			    ses->ses_iv);
		else
			bcopy(crp->crp_buf + crd->crd_skip +
			    crd->crd_len - ivlen, ses->ses_iv, ivlen);
@


1.6
log
@remove a debugging panic, as pointed out by mike;
also, remove the flag variable in the setup routine, as we'll
always register with a flag value of 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: aesni.c,v 1.5 2010/07/05 16:33:36 thib Exp $	*/
d57 2
a58 1
	uint8_t			 op_buf[16384];
d102 4
d305 1
a305 1
		type= CRYPTO_BUF_IOV;
d315 1
a315 1
	uint8_t *buf = &aesni_sc->op_buf[0];
d324 5
a328 4
	if (crd->crd_len > sizeof (aesni_sc->op_buf)) {
		printf("aesni: crd->crd_len > sizeof (aesni_sc->op_buf)\n");
		return (EINVAL);
	}
d330 6
a335 5
	/*
	buf = malloc(crd->crd_len, M_DEVBUF, M_NOWAIT);
	if (buf == NULL) {
		err = ENOMEM;
		return (err);
a336 1
	*/
a427 7

	/*
	if (buf != NULL) {
		bzero(buf, crd->crd_len);
		free(buf, M_DEVBUF);
	}
	*/
@


1.5
log
@cope with the recent changes to m_copyback();
@
text
@d1 1
a1 1
/*	$OpenBSD: aesni.c,v 1.4 2010/06/30 17:14:36 thib Exp $	*/
a95 1
	int flags = 0;	/* CRYPTOCAP_F_SOFTWARE */
d113 1
a113 1
	aesni_sc->sc_cid = crypto_get_driverid(flags);
a156 3

	if ((uint64_t)ses % 16 != 0)
		panic("aesni: unaligned address %p\n", ses);
@


1.4
log
@Remove #ifdef CRYPTO. config will do this for us.
@
text
@d1 1
a1 1
/*	$OpenBSD: aesni.c,v 1.3 2010/06/30 17:11:05 thib Exp $	*/
d348 7
a354 4
			if (crp->crp_flags & CRYPTO_F_IMBUF)
				m_copyback((struct mbuf *)crp->crp_buf,
				    crd->crd_inject, ivlen, iv);
			else if (crp->crp_flags & CRYPTO_F_IOV)
d400 7
a406 4
	if (crp->crp_flags & CRYPTO_F_IMBUF)
		m_copyback((struct mbuf *)crp->crp_buf, crd->crd_skip,
		    crd->crd_len, buf);
	else if (crp->crp_flags & CRYPTO_F_IOV)
d434 1
@


1.3
log
@get rid of a few c++ comments and a few spacing nits
@
text
@d1 1
a1 1
/*	$OpenBSD: aesni.c,v 1.2 2010/06/30 17:00:42 thib Exp $	*/
a28 1
#ifdef CRYPTO
a32 1
#endif
a37 1
#ifdef CRYPTO
a487 2

#endif /* CRYPTO */
@


1.2
log
@remove two useless defines.
fixup arguments to the fpu_kernel_enter/exit.

from mike
@
text
@d1 1
a1 1
/*	$OpenBSD: aesni.c,v 1.1 2010/06/29 21:34:11 thib Exp $	*/
a61 1
//	uint32_t		 sc_nsessions;
d69 1
d73 1
d79 1
d99 1
a99 2
//	int flags = CRYPTOCAP_F_SOFTWARE;
	int flags = 0; /* XXX TESTING */
@


1.1
log
@aesni, a driver for the crypto framework, similar to the
via driver for supporting the AES-NI instructions found
on recent Intel cores.

I would like to thank Huang Ying at Intel for getting the
assembly code relicensed from GPL to a more suitable license!

Inital diff by myself, but Mike Belopuhov beat this into a
usable shape and fixed many bugs.

Not enabled yet.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a46 3
#define AESCTR_MINKEY		16+4
#define AESCTR_MAXKEY		32+4

d164 1
a164 1
	fpu_kernel_enter(0);
d250 1
a250 1
	fpu_kernel_exit(0);
d456 1
a456 1
	fpu_kernel_enter(0);
d484 1
a484 1
	fpu_kernel_exit(0);
@

