head	1.23;
access;
symbols
	OPENBSD_6_2_BASE:1.23
	OPENBSD_6_1:1.22.0.4
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.21.0.4
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.20.0.4
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.14.0.6
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.12.0.6
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.4
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.2
	OPENBSD_5_0:1.11.0.2
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.10.0.2
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.7.0.2
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.23
date	2017.05.02.11.47.49;	author mikeb;	state Exp;
branches;
next	1.22;
commitid	eIhnnHwMlTLXJ9Zb;

1.22
date	2017.02.07.17.25.45;	author patrick;	state Exp;
branches;
next	1.21;
commitid	dMJlqKWYCJoMV7JN;

1.21
date	2015.08.28.00.03.53;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	NdgfPIGUgJxQPnT7;

1.20
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.19;
commitid	p4LJxGKbi0BU2cG6;

1.19
date	2014.12.15.01.53.45;	author tedu;	state Exp;
branches;
next	1.18;
commitid	zTvdNqjakdDTl6z6;

1.18
date	2014.12.09.06.58.28;	author doug;	state Exp;
branches;
next	1.17;
commitid	yWAxzpQP2PPpYlfT;

1.17
date	2014.09.14.14.17.23;	author jsg;	state Exp;
branches;
next	1.16;
commitid	uzzBR7hz9ncd4O6G;

1.16
date	2014.07.12.18.44.41;	author tedu;	state Exp;
branches;
next	1.15;
commitid	uKVPYMN2MLxdZxzH;

1.15
date	2014.03.29.18.09.28;	author guenther;	state Exp;
branches;
next	1.14;

1.14
date	2013.06.02.16.38.05;	author guenther;	state Exp;
branches;
next	1.13;

1.13
date	2013.05.30.15.37.51;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	2012.01.13.09.53.24;	author mikeb;	state Exp;
branches;
next	1.11;

1.11
date	2011.04.20.06.51.34;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2011.01.12.17.15.23;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2011.01.11.15.42.05;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2010.12.15.23.34.23;	author mikeb;	state Exp;
branches;
next	1.7;

1.7
date	2010.07.06.09.49.47;	author blambert;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2010.07.02.02.40.15;	author blambert;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.29.22.42.14;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.26.23.24.43;	author guenther;	state Exp;
branches;
next	1.3;

1.3
date	2010.06.08.07.36.36;	author thib;	state Exp;
branches;
next	1.2;

1.2
date	2010.01.10.12.43.07;	author markus;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2009.05.31.03.20.10;	author matthieu;	state Exp;
branches;
next	;

1.2.2.1
date	2010.12.20.14.08.39;	author jasper;	state Exp;
branches;
next	;

1.7.2.1
date	2010.12.17.16.25.14;	author jasper;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Switch glxsb(4), VIA padlock and AES-NI drivers over to the new AES
@
text
@/*	$OpenBSD: via.c,v 1.22 2017/02/07 17:25:45 patrick Exp $	*/
/*	$NetBSD: machdep.c,v 1.214 1996/11/10 03:16:17 thorpej Exp $	*/

/*-
 * Copyright (c) 2003 Jason Wright
 * Copyright (c) 2003, 2004 Theo de Raadt
 * All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/signalvar.h>
#include <sys/kernel.h>
#include <sys/exec.h>
#include <sys/buf.h>
#include <sys/reboot.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/timeout.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/extent.h>
#include <sys/sysctl.h>

#ifdef CRYPTO
#include <crypto/cryptodev.h>
#include <crypto/aes.h>
#include <crypto/xform.h>
#include <crypto/cryptosoft.h>
#endif

#include <uvm/uvm_extern.h>

#include <machine/cpu.h>
#include <machine/cpufunc.h>
#include <machine/pio.h>
#include <machine/bus.h>
#include <machine/psl.h>
#include <machine/reg.h>
#include <machine/specialreg.h>

#include <dev/rndvar.h>

void	viac3_rnd(void *);


#ifdef CRYPTO

struct viac3_session {
	u_int32_t	ses_ekey[4 * (AES_MAXROUNDS + 1) + 4];	/* 128 bit aligned */
	u_int32_t	ses_dkey[4 * (AES_MAXROUNDS + 1) + 4];	/* 128 bit aligned */
	u_int32_t	ses_cw0;
	struct swcr_data *swd;
	int		ses_klen;
	int		ses_used;
};

struct viac3_softc {
	u_int32_t		op_cw[4];		/* 128 bit aligned */
	u_int8_t		op_iv[16];		/* 128 bit aligned */
	void			*op_buf;

	/* normal softc stuff */
	int32_t			sc_cid;
	int			sc_nsessions;
	struct viac3_session	*sc_sessions;
};

#define VIAC3_SESSION(sid)		((sid) & 0x0fffffff)
#define	VIAC3_SID(crd,ses)		(((crd) << 28) | ((ses) & 0x0fffffff))

static struct viac3_softc *vc3_sc;

extern const u_int8_t hmac_ipad_buffer[HMAC_MAX_BLOCK_LEN];
extern const u_int8_t hmac_opad_buffer[HMAC_MAX_BLOCK_LEN];

void viac3_crypto_setup(void);
int viac3_crypto_newsession(u_int32_t *, struct cryptoini *);
int viac3_crypto_process(struct cryptop *);
int viac3_crypto_swauth(struct cryptop *, struct cryptodesc *,
    struct swcr_data *, caddr_t);
int viac3_crypto_encdec(struct cryptop *, struct cryptodesc *,
    struct viac3_session *, struct viac3_softc *, caddr_t);
int viac3_crypto_freesession(u_int64_t);
static __inline void viac3_cbc(void *, void *, void *, void *, int, void *);

void
viac3_crypto_setup(void)
{
	int algs[CRYPTO_ALGORITHM_MAX + 1];

	vc3_sc = malloc(sizeof(*vc3_sc), M_DEVBUF, M_NOWAIT|M_ZERO);
	if (vc3_sc == NULL)
		return;		/* YYY bitch? */

	bzero(algs, sizeof(algs));
	algs[CRYPTO_AES_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_MD5_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_SHA1_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_RIPEMD160_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_SHA2_256_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_SHA2_384_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_SHA2_512_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;

	vc3_sc->sc_cid = crypto_get_driverid(0);
	if (vc3_sc->sc_cid < 0) {
		free(vc3_sc, M_DEVBUF, sizeof(*vc3_sc));
		return;		/* YYY bitch? */
	}

	crypto_register(vc3_sc->sc_cid, algs, viac3_crypto_newsession,
	    viac3_crypto_freesession, viac3_crypto_process);
}

int
viac3_crypto_newsession(u_int32_t *sidp, struct cryptoini *cri)
{
	struct cryptoini	*c;
	struct viac3_softc	*sc = vc3_sc;
	struct viac3_session	*ses = NULL;
	struct auth_hash	*axf;
	struct swcr_data	*swd;
	int			 sesn, i, cw0;

	if (sc == NULL || sidp == NULL || cri == NULL)
		return (EINVAL);

	if (sc->sc_sessions == NULL) {
		ses = sc->sc_sessions = malloc(sizeof(*ses), M_DEVBUF,
		    M_NOWAIT);
		if (ses == NULL)
			return (ENOMEM);
		sesn = 0;
		sc->sc_nsessions = 1;
	} else {
		for (sesn = 0; sesn < sc->sc_nsessions; sesn++) {
			if (sc->sc_sessions[sesn].ses_used == 0) {
				ses = &sc->sc_sessions[sesn];
				break;
			}
		}

		if (ses == NULL) {
			sesn = sc->sc_nsessions;
			ses = mallocarray(sesn + 1, sizeof(*ses), M_DEVBUF,
			    M_NOWAIT);
			if (ses == NULL)
				return (ENOMEM);
			memcpy(ses, sc->sc_sessions, sesn * sizeof(*ses));
			explicit_bzero(sc->sc_sessions, sesn * sizeof(*ses));
			free(sc->sc_sessions, M_DEVBUF, 0);
			sc->sc_sessions = ses;
			ses = &sc->sc_sessions[sesn];
			sc->sc_nsessions++;
		}
	}

	bzero(ses, sizeof(*ses));
	ses->ses_used = 1;

	for (c = cri; c != NULL; c = c->cri_next) {
		switch (c->cri_alg) {
		case CRYPTO_AES_CBC:
			switch (c->cri_klen) {
			case 128:
				cw0 = C3_CRYPT_CWLO_KEY128;
				break;
			case 192:
				cw0 = C3_CRYPT_CWLO_KEY192;
				break;
			case 256:
				cw0 = C3_CRYPT_CWLO_KEY256;
				break;
			default:
				viac3_crypto_freesession(sesn);
				return (EINVAL);
			}
			cw0 |= C3_CRYPT_CWLO_ALG_AES | C3_CRYPT_CWLO_KEYGEN_SW |
			    C3_CRYPT_CWLO_NORMAL;

			ses->ses_klen = c->cri_klen;
			ses->ses_cw0 = cw0;

			/* Build expanded keys for both directions */
			AES_KeySetup_Encrypt(ses->ses_ekey, c->cri_key,
			    c->cri_klen);
			AES_KeySetup_Decrypt(ses->ses_dkey, c->cri_key,
			    c->cri_klen);
			for (i = 0; i < 4 * (AES_MAXROUNDS + 1); i++) {
				ses->ses_ekey[i] = ntohl(ses->ses_ekey[i]);
				ses->ses_dkey[i] = ntohl(ses->ses_dkey[i]);
			}

			break;

		case CRYPTO_MD5_HMAC:
			axf = &auth_hash_hmac_md5_96;
			goto authcommon;
		case CRYPTO_SHA1_HMAC:
			axf = &auth_hash_hmac_sha1_96;
			goto authcommon;
		case CRYPTO_RIPEMD160_HMAC:
			axf = &auth_hash_hmac_ripemd_160_96;
			goto authcommon;
		case CRYPTO_SHA2_256_HMAC:
			axf = &auth_hash_hmac_sha2_256_128;
			goto authcommon;
		case CRYPTO_SHA2_384_HMAC:
			axf = &auth_hash_hmac_sha2_384_192;
			goto authcommon;
		case CRYPTO_SHA2_512_HMAC:
			axf = &auth_hash_hmac_sha2_512_256;
		authcommon:
			swd = malloc(sizeof(struct swcr_data), M_CRYPTO_DATA,
			    M_NOWAIT|M_ZERO);
			if (swd == NULL) {
				viac3_crypto_freesession(sesn);
				return (ENOMEM);
			}
			ses->swd = swd;

			swd->sw_ictx = malloc(axf->ctxsize, M_CRYPTO_DATA,
			    M_NOWAIT);
			if (swd->sw_ictx == NULL) {
				viac3_crypto_freesession(sesn);
				return (ENOMEM);
			}

			swd->sw_octx = malloc(axf->ctxsize, M_CRYPTO_DATA,
			    M_NOWAIT);
			if (swd->sw_octx == NULL) {
				viac3_crypto_freesession(sesn);
				return (ENOMEM);
			}

			for (i = 0; i < c->cri_klen / 8; i++)
				c->cri_key[i] ^= HMAC_IPAD_VAL;

			axf->Init(swd->sw_ictx);
			axf->Update(swd->sw_ictx, c->cri_key, c->cri_klen / 8);
			axf->Update(swd->sw_ictx, hmac_ipad_buffer,
			    axf->blocksize - (c->cri_klen / 8));

			for (i = 0; i < c->cri_klen / 8; i++)
				c->cri_key[i] ^= (HMAC_IPAD_VAL ^
				    HMAC_OPAD_VAL);

			axf->Init(swd->sw_octx);
			axf->Update(swd->sw_octx, c->cri_key, c->cri_klen / 8);
			axf->Update(swd->sw_octx, hmac_opad_buffer,
			    axf->blocksize - (c->cri_klen / 8));

			for (i = 0; i < c->cri_klen / 8; i++)
				c->cri_key[i] ^= HMAC_OPAD_VAL;

			swd->sw_axf = axf;
			swd->sw_alg = c->cri_alg;

			break;
		default:
			viac3_crypto_freesession(sesn);
			return (EINVAL);
		}
	}

	*sidp = VIAC3_SID(0, sesn);
	return (0);
}

int
viac3_crypto_freesession(u_int64_t tid)
{
	struct viac3_softc *sc = vc3_sc;
	struct swcr_data *swd;
	struct auth_hash *axf;
	int sesn;
	u_int32_t sid = ((u_int32_t)tid) & 0xffffffff;

	if (sc == NULL)
		return (EINVAL);
	sesn = VIAC3_SESSION(sid);
	if (sesn >= sc->sc_nsessions)
		return (EINVAL);

	if (sc->sc_sessions[sesn].swd) {
		swd = sc->sc_sessions[sesn].swd;
		axf = swd->sw_axf;

		if (swd->sw_ictx) {
			explicit_bzero(swd->sw_ictx, axf->ctxsize);
			free(swd->sw_ictx, M_CRYPTO_DATA, 0);
		}
		if (swd->sw_octx) {
			explicit_bzero(swd->sw_octx, axf->ctxsize);
			free(swd->sw_octx, M_CRYPTO_DATA, 0);
		}
		free(swd, M_CRYPTO_DATA, 0);
	}

	explicit_bzero(&sc->sc_sessions[sesn], sizeof(sc->sc_sessions[sesn]));
	return (0);
}

static __inline void
viac3_cbc(void *cw, void *src, void *dst, void *key, int rep,
    void *iv)
{
	unsigned int creg0;

	creg0 = rcr0();		/* Permit access to SIMD/FPU path */
	lcr0(creg0 & ~(CR0_EM|CR0_TS));

	/* Do the deed */
	__asm volatile("pushfq; popfq");
	__asm volatile("rep xcryptcbc" :
	    : "b" (key), "a" (iv), "c" (rep), "d" (cw), "S" (src), "D" (dst)
	    : "memory", "cc");

	lcr0(creg0);
}

int
viac3_crypto_swauth(struct cryptop *crp, struct cryptodesc *crd,
    struct swcr_data *sw, caddr_t buf)
{
	int	type;

	if (crp->crp_flags & CRYPTO_F_IMBUF)
		type = CRYPTO_BUF_MBUF;
	else
		type= CRYPTO_BUF_IOV;
		
	return (swcr_authcompute(crp, crd, sw, buf, type));
}

int
viac3_crypto_encdec(struct cryptop *crp, struct cryptodesc *crd,
    struct viac3_session *ses, struct viac3_softc *sc, caddr_t buf)
{
	u_int32_t *key;
	int	err = 0;

	if ((crd->crd_len % 16) != 0) {
		err = EINVAL;
		return (err);
	}

	sc->op_buf = malloc(crd->crd_len, M_DEVBUF, M_NOWAIT);
	if (sc->op_buf == NULL) {
		err = ENOMEM;
		return (err);
	}

	if (crd->crd_flags & CRD_F_ENCRYPT) {
		sc->op_cw[0] = ses->ses_cw0 | C3_CRYPT_CWLO_ENCRYPT;
		key = ses->ses_ekey;
		if (crd->crd_flags & CRD_F_IV_EXPLICIT)
			memcpy(sc->op_iv, crd->crd_iv, 16);
		else
			arc4random_buf(sc->op_iv, 16);

		if ((crd->crd_flags & CRD_F_IV_PRESENT) == 0) {
			if (crp->crp_flags & CRYPTO_F_IMBUF)
				err = m_copyback((struct mbuf *)crp->crp_buf,
				    crd->crd_inject, 16, sc->op_iv, M_NOWAIT);
			else if (crp->crp_flags & CRYPTO_F_IOV)
				cuio_copyback((struct uio *)crp->crp_buf,
				    crd->crd_inject, 16, sc->op_iv);
			else
				memcpy(crp->crp_buf + crd->crd_inject,
				    sc->op_iv, 16);
			if (err)
				return (err);
		}
	} else {
		sc->op_cw[0] = ses->ses_cw0 | C3_CRYPT_CWLO_DECRYPT;
		key = ses->ses_dkey;
		if (crd->crd_flags & CRD_F_IV_EXPLICIT)
			memcpy(sc->op_iv, crd->crd_iv, 16);
		else {
			if (crp->crp_flags & CRYPTO_F_IMBUF)
				m_copydata((struct mbuf *)crp->crp_buf,
				    crd->crd_inject, 16, sc->op_iv);
			else if (crp->crp_flags & CRYPTO_F_IOV)
				cuio_copydata((struct uio *)crp->crp_buf,
				    crd->crd_inject, 16, sc->op_iv);
			else
				memcpy(sc->op_iv,
				    crp->crp_buf + crd->crd_inject, 16);
		}
	}

	if (crp->crp_flags & CRYPTO_F_IMBUF)
		m_copydata((struct mbuf *)crp->crp_buf,
		    crd->crd_skip, crd->crd_len, sc->op_buf);
	else if (crp->crp_flags & CRYPTO_F_IOV)
		cuio_copydata((struct uio *)crp->crp_buf,
		    crd->crd_skip, crd->crd_len, sc->op_buf);
	else
		memcpy(sc->op_buf, crp->crp_buf + crd->crd_skip, crd->crd_len);

	sc->op_cw[1] = sc->op_cw[2] = sc->op_cw[3] = 0;
	viac3_cbc(&sc->op_cw, sc->op_buf, sc->op_buf, key,
	    crd->crd_len / 16, sc->op_iv);

	if (crp->crp_flags & CRYPTO_F_IMBUF)
		err = m_copyback((struct mbuf *)crp->crp_buf,
		    crd->crd_skip, crd->crd_len, sc->op_buf, M_NOWAIT);
	else if (crp->crp_flags & CRYPTO_F_IOV)
		cuio_copyback((struct uio *)crp->crp_buf,
		    crd->crd_skip, crd->crd_len, sc->op_buf);
	else
		memcpy(crp->crp_buf + crd->crd_skip, sc->op_buf,
		    crd->crd_len);

	if (sc->op_buf != NULL) {
		explicit_bzero(sc->op_buf, crd->crd_len);
		free(sc->op_buf, M_DEVBUF, 0);
		sc->op_buf = NULL;
	}

	return (err);
}

int
viac3_crypto_process(struct cryptop *crp)
{
	struct viac3_softc *sc = vc3_sc;
	struct viac3_session *ses;
	struct cryptodesc *crd;
	int sesn, err = 0;
	int i;

	if (crp == NULL || crp->crp_callback == NULL)
		return (EINVAL);
	if (crp->crp_ndesc < 1)
		return (EINVAL);

	sesn = VIAC3_SESSION(crp->crp_sid);
	if (sesn >= sc->sc_nsessions) {
		err = EINVAL;
		goto out;
	}
	ses = &sc->sc_sessions[sesn];
	if (ses->ses_used == 0) {
		err = EINVAL;
		goto out;
	}

	for (i = 0; i < crp->crp_ndesc; i++) {
		crd = &crp->crp_desc[i];
		switch (crd->crd_alg) {
		case CRYPTO_AES_CBC:
			if ((err = viac3_crypto_encdec(crp, crd, ses, sc,
			    crp->crp_buf)) != 0)
				goto out;
			break;

		case CRYPTO_MD5_HMAC:
		case CRYPTO_SHA1_HMAC:
		case CRYPTO_RIPEMD160_HMAC:
		case CRYPTO_SHA2_256_HMAC:
		case CRYPTO_SHA2_384_HMAC:
		case CRYPTO_SHA2_512_HMAC:
			if ((err = viac3_crypto_swauth(crp, crd, ses->swd,
			    crp->crp_buf)) != 0)
				goto out;
			break;

		default:
			err = EINVAL;
			goto out;
		}
	}
out:
	crp->crp_etype = err;
	crypto_done(crp);
	return (err);
}

#endif /* CRYPTO */

/*
 * Note, the VIA C3 Nehemiah provides 4 internal 8-byte buffers, which
 * store random data, and can be accessed a lot quicker than waiting
 * for new data to be generated.  As we are using every 8th bit only
 * due to whitening. Since the RNG generates in excess of 21KB/s at
 * its worst, collecting 64 bytes worth of entropy should not affect
 * things significantly.
 *
 * Note, due to some weirdness in the RNG, we need at least 7 bytes
 * extra on the end of our buffer.  Also, there is an outside chance
 * that the VIA RNG can "wedge", as the generated bit-rate is variable.
 * We could do all sorts of startup testing and things, but
 * frankly, I don't really see the point.  If the RNG wedges, then the
 * chances of you having a defective CPU are very high.  Let it wedge.
 *
 * Adding to the whole confusion, in order to access the RNG, we need
 * to have FXSR support enabled, and the correct FPU enable bits must
 * be there to enable the FPU in kernel.  It would be nice if all this
 * mumbo-jumbo was not needed in order to use the RNG.  Oh well, life
 * does go on...
 */
#define VIAC3_RNG_BUFSIZ	16		/* 32bit words */
struct timeout viac3_rnd_tmo;
int viac3_rnd_present;

void
viac3_rnd(void *v)
{
	struct timeout *tmo = v;
	unsigned int *p, i, rv, creg0, len = VIAC3_RNG_BUFSIZ;
	static int buffer[VIAC3_RNG_BUFSIZ + 2];	/* XXX why + 2? */
#ifdef MULTIPROCESSOR
	int s = splipi();
#endif

	creg0 = rcr0();		/* Permit access to SIMD/FPU path */
	lcr0(creg0 & ~(CR0_EM|CR0_TS));

	/*
	 * Here we collect the random data from the VIA C3 RNG.  We make
	 * sure that we turn on maximum whitening (%edx[0,1] == "11"), so
	 * that we get the best random data possible.
	 */
	__asm volatile("rep xstorerng"
	    : "=a" (rv) : "d" (3), "D" (buffer), "c" (len*sizeof(int))
	    : "memory", "cc");

	lcr0(creg0);

#ifdef MULTIPROCESSOR
	splx(s);
#endif

	for (i = 0, p = buffer; i < VIAC3_RNG_BUFSIZ; i++, p++)
		add_true_randomness(*p);

	timeout_add_msec(tmo, 10);
}
@


1.22
log
@Reduce the per-packet allocation costs for crypto operations (cryptop)
by pre-allocating two cryptodesc objects and storing them in an array
instead of a linked list.  If more than two cryptodesc objects are
required use mallocarray to fetch them.  Adapt the drivers to the new
API.

This change results in one pool-get per ESP packet instead of three.
It also simplifies softraid crypto where more cryptodesc objects are
allocated than used.

From, with and ok markus@@, ok bluhm@@
"looks sane" mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.21 2015/08/28 00:03:53 deraadt Exp $	*/
d39 1
a39 1
#include <crypto/rijndael.h>
d197 1
a197 1
			rijndaelKeySetupEnc(ses->ses_ekey, c->cri_key,
d199 1
a199 1
			rijndaelKeySetupDec(ses->ses_dkey, c->cri_key,
@


1.21
log
@fairly simple sizes for free(); ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.20 2015/03/14 03:38:46 jsg Exp $	*/
d444 1
d448 2
d462 2
a463 1
	for (crd = crp->crp_desc; crd; crd = crd->crd_next) {
@


1.20
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.19 2014/12/15 01:53:45 tedu Exp $	*/
d119 1
a119 1
		free(vc3_sc, M_DEVBUF, 0);
@


1.19
log
@change bcopy to memcpy. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.18 2014/12/09 06:58:28 doug Exp $	*/
a52 1
#include <machine/biosvar.h>
@


1.18
log
@Replace some malloc(n*size,...) calls with mallocarray().

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.17 2014/09/14 14:17:23 jsg Exp $	*/
d162 1
a162 1
			bcopy(sc->sc_sessions, ses, sesn * sizeof(*ses));
d371 1
a371 1
			bcopy(crd->crd_iv, sc->op_iv, 16);
d383 2
a384 2
				bcopy(sc->op_iv,
				    crp->crp_buf + crd->crd_inject, 16);
d392 1
a392 1
			bcopy(crd->crd_iv, sc->op_iv, 16);
d401 2
a402 2
				bcopy(crp->crp_buf + crd->crd_inject,
				    sc->op_iv, 16);
d413 1
a413 1
		bcopy(crp->crp_buf + crd->crd_skip, sc->op_buf, crd->crd_len);
d426 1
a426 1
		bcopy(sc->op_buf, crp->crp_buf + crd->crd_skip,
@


1.17
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.16 2014/07/12 18:44:41 tedu Exp $	*/
d158 1
a158 1
			ses = malloc((sesn + 1) * sizeof(*ses), M_DEVBUF,
@


1.16
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.15 2014/03/29 18:09:28 guenther Exp $	*/
a25 1
#include <sys/proc.h>
@


1.15
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.14 2013/06/02 16:38:05 guenther Exp $	*/
d121 1
a121 1
		free(vc3_sc, M_DEVBUF);
d165 1
a165 1
			free(sc->sc_sessions, M_DEVBUF);
d305 1
a305 1
			free(swd->sw_ictx, M_CRYPTO_DATA);
d309 1
a309 1
			free(swd->sw_octx, M_CRYPTO_DATA);
d311 1
a311 1
		free(swd, M_CRYPTO_DATA);
d432 1
a432 1
		free(sc->op_buf, M_DEVBUF);
@


1.14
log
@Don't need gdt.h here
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.13 2013/05/30 15:37:51 matthew Exp $	*/
d328 2
a329 2
	__asm __volatile("pushfq; popfq");
	__asm __volatile("rep xcryptcbc" :
d536 1
a536 1
	__asm __volatile("rep xstorerng"
@


1.13
log
@Switch to using unhyphenated VIA padlock mnemonics.  VIA abandoned the
hyphen in their official programming guide sometime between 2003 and
2005, and Clang's integrated assembler does not support hyphenated
mnemonics.

ok jsg, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.12 2012/01/13 09:53:24 mikeb Exp $	*/
a48 1
#include <machine/gdt.h>
@


1.12
log
@handle m_copyback errors, this code is too sensitive for such
failures to be neglected;  ok markus
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.11 2011/04/20 06:51:34 deraadt Exp $	*/
d330 1
a330 1
	__asm __volatile("rep xcrypt-cbc" :
d537 1
a537 1
	__asm __volatile("rep xstore-rng"
@


1.11
log
@Potential NULL deref in an error case spotted by chl on one copy;
correct fix applied to 3 similar drivers
ok chl
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.10 2011/01/12 17:15:23 deraadt Exp $	*/
d379 1
a379 1
				m_copyback((struct mbuf *)crp->crp_buf,
d387 2
d422 1
a422 1
		m_copyback((struct mbuf *)crp->crp_buf,
@


1.10
log
@use explicit_bzero() for the session, in drivers where struct session
contains key material (note, that is not true in all drivers... hence
not always neccessary)
discussed with mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.9 2011/01/11 15:42:05 deraadt Exp $	*/
d446 2
a447 4
	if (crp == NULL || crp->crp_callback == NULL) {
		err = EINVAL;
		goto out;
	}
@


1.9
log
@for key material that is being being discarded, convert bzero() to
explicit_bzero() where required
ok markus mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.8 2010/12/15 23:34:23 mikeb Exp $	*/
d165 1
a165 1
			bzero(sc->sc_sessions, sesn * sizeof(*ses));
d315 1
a315 1
	bzero(&sc->sc_sessions[sesn], sizeof(sc->sc_sessions[sesn]));
@


1.8
log
@Bring CBC oracle attack countermeasure from r1.32 of cryptosoft.c to
the hardware crypto accelerator land.  This fixes aes-ni, via xcrypt,
glxsb(4), hifn(4), safe(4) and ubsec(4) drivers.

Original commit message by angelos:

Don't keep the last blocksize-bytes of ciphertext for use as the next
plaintext's IV, in CBC mode. Use arc4random() to acquire fresh IVs per
message.

with and ok deraadt, ok markus, djm
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.7 2010/07/06 09:49:47 blambert Exp $	*/
d305 1
a305 1
			bzero(swd->sw_ictx, axf->ctxsize);
d309 1
a309 1
			bzero(swd->sw_octx, axf->ctxsize);
d430 1
a430 1
		bzero(sc->op_buf, crd->crd_len);
@


1.7
log
@timeout_add -> timeout_add_msec

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.6 2010/07/02 02:40:15 blambert Exp $	*/
a66 1
	u_int8_t	ses_iv[16];			/* 128 bit aligned */
a195 1
			arc4random_buf(ses->ses_iv, sizeof(ses->ses_iv));
d375 1
a375 1
			bcopy(ses->ses_iv, sc->op_iv, 16);
a427 15

	/* copy out last block for use as next session IV */
	if (crd->crd_flags & CRD_F_ENCRYPT) {
		if (crp->crp_flags & CRYPTO_F_IMBUF)
			m_copydata((struct mbuf *)crp->crp_buf,
			    crd->crd_skip + crd->crd_len - 16, 16,
			    ses->ses_iv);
		else if (crp->crp_flags & CRYPTO_F_IOV)
			cuio_copydata((struct uio *)crp->crp_buf,
			    crd->crd_skip + crd->crd_len - 16, 16,
			    ses->ses_iv);
		else
			bcopy(crp->crp_buf + crd->crd_skip +
			    crd->crd_len - 16, ses->ses_iv, 16);
	}
@


1.7.2.1
log
@Backport from -current, original commit by mikeb@@:
------
Bring CBC oracle attack countermeasure from r1.32 of cryptosoft.c to
the hardware crypto accelerator land.  This fixes aes-ni, via xcrypt,
glxsb(4), hifn(4), safe(4) and ubsec(4) drivers.
------

ok deraadt@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.7 2010/07/06 09:49:47 blambert Exp $	*/
d67 1
d197 1
d377 1
a377 1
			arc4random_buf(sc->op_iv, 16);
d430 15
@


1.6
log
@m_copyback can fail to allocate memory, but is a void fucntion so gymnastics
are required to detect that.

Change the function to take a wait argument (used in nfs server, but
M_NOWAIT everywhere else for now) and to return an error

ok claudio@@ henning@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.5 2010/06/29 22:42:14 deraadt Exp $	*/
d567 1
a567 1
	timeout_add(tmo, (hz > 100) ? (hz / 100) : 1);
@


1.5
log
@make the xcrypt match the jsg code in openssl
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.4 2010/06/26 23:24:43 guenther Exp $	*/
d382 1
a382 1
				    crd->crd_inject, 16, sc->op_iv);
d423 1
a423 1
		    crd->crd_skip, crd->crd_len, sc->op_buf);
@


1.4
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.3 2010/06/08 07:36:36 thib Exp $	*/
d331 1
a331 1
	__asm __volatile("pushf; popf");
d333 1
a333 1
	    : "a" (iv), "b" (key), "c" (rep), "d" (cw), "S" (src), "D" (dst)
@


1.3
log
@in viac3_crypto_setup(), if we fail to get a crypto driverid,
free the softc before we return. While here, make the allocation
code a bit prettier too.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.2 2010/01/10 12:43:07 markus Exp $	*/
a26 1
#include <sys/user.h>
@


1.2
log
@Fix two bugs in IPsec/HMAC-SHA2:
(1) use correct (message) block size of 128 byte (instead of 64
    bytes) for HMAC-SHA512/384 (RFC4634).
(2) RFC4868 specifies that HMAC-SHA-{256,384,512} is truncated to
    nnn/2 bits, while we still use 96 bits. 96 bits have been
    specified in draft-ietf-ipsec-ciph-sha-256-00 while
    draft-ietf-ipsec-ciph-sha-256-01 changed it to 128 bits.

WARNING: this change makes IPsec with SHA-256 (the default)
incompatible with older OpenBSD versions and other IPsec-implementations
that share this bug.

ok+tests naddy, fries; requested by reyk/deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.1 2009/05/31 03:20:10 matthieu Exp $	*/
d109 2
a110 2
	if ((vc3_sc = malloc(sizeof(*vc3_sc), M_DEVBUF,
	    M_NOWAIT|M_ZERO)) == NULL)
d123 2
a124 1
	if (vc3_sc->sc_cid < 0)
d126 1
@


1.2.2.1
log
@Backport from -current, original commit by mikeb@@:
------
Bring CBC oracle attack countermeasure from r1.32 of cryptosoft.c to
the hardware crypto accelerator land.  This fixes aes-ni, via xcrypt,
glxsb(4), hifn(4), safe(4) and ubsec(4) drivers.
------
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.2 2010/01/10 12:43:07 markus Exp $	*/
d68 1
d196 1
d376 1
a376 1
			arc4random_buf(sc->op_iv, 16);
d429 15
@


1.1
log
@Add VIA crypto features support to amd64. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.19 2008/06/09 07:07:15 djm Exp $	*/
d91 2
a92 2
extern const u_int8_t hmac_ipad_buffer[64];
extern const u_int8_t hmac_opad_buffer[64];
d222 1
a222 1
			axf = &auth_hash_hmac_sha2_256_96;
d225 1
a225 1
			axf = &auth_hash_hmac_sha2_384_96;
d228 1
a228 1
			axf = &auth_hash_hmac_sha2_512_96;
d258 1
a258 1
			    HMAC_BLOCK_LEN - (c->cri_klen / 8));
d267 1
a267 1
			    HMAC_BLOCK_LEN - (c->cri_klen / 8));
@

