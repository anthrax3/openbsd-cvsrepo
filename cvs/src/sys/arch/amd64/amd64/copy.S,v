head	1.7;
access;
symbols
	OPENBSD_6_0:1.7.0.6
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.5.0.10
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.8
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.4.0.18
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.16
	OPENBSD_5_0:1.4.0.14
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.12
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.10
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.6
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.8
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.4
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.2
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.3.0.4
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.2
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.2.0.10
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.6
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.8
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.4
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.2
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.1.0.6
	OPENBSD_3_6_BASE:1.1
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	OPENBSD_3_5:1.1.0.4
	OPENBSD_3_5_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@# @;


1.7
date	2015.04.25.21.31.24;	author guenther;	state Exp;
branches;
next	1.6;
commitid	Jx2fq8kp0uEBpslo;

1.6
date	2015.01.16.10.17.51;	author sf;	state Exp;
branches;
next	1.5;
commitid	Mg2nJormk2PyesMj;

1.5
date	2012.10.31.03.30.22;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2008.06.09.20.43.41;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2007.05.29.23.03.20;	author tom;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.16.07.08.38;	author tedu;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.28.01.39.38;	author mickey;	state Exp;
branches
	1.1.4.1
	1.1.6.1;
next	;

1.1.4.1
date	2005.03.16.23.53.27;	author brad;	state Exp;
branches;
next	;

1.1.6.1
date	2005.03.16.23.49.00;	author brad;	state Exp;
branches;
next	;


desc
@@


1.7
log
@We now following the ABI and always clear cld on function entry, so remove
the extra CLD instructions from when that wasn't true

testing miod@@ krw@@
@
text
@/*	$OpenBSD: copy.S,v 1.6 2015/01/16 10:17:51 sf Exp $	*/
/*	$NetBSD: copy.S,v 1.1 2003/04/26 18:39:26 fvdl Exp $	*/

/*
 * Copyright (c) 2001 Wasabi Systems, Inc.
 * All rights reserved.
 *
 * Written by Frank van der Linden for Wasabi Systems, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed for the NetBSD Project by
 *      Wasabi Systems, Inc.
 * 4. The name of Wasabi Systems, Inc. may not be used to endorse
 *    or promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include "assym.h"

#include <sys/errno.h>
#include <sys/syscall.h>

#include <machine/asm.h>
#include <machine/codepatch.h>

/*
 * As stac/clac SMAP instructions are 3 bytes, we want the fastest
 * 3 byte nop sequence possible here.  This will be replaced by
 * stac/clac instructions if SMAP is detected after booting.
 *
 * This would be 'nop (%rax)' if binutils could cope.
 * Intel documents multi-byte NOP sequences as being available
 * on all family 0x6 and 0xf processors (ie 686+)
 */
#define SMAP_NOP	.byte 0x0f, 0x1f, 0x00
#define SMAP_STAC	CODEPATCH_START			;\
			SMAP_NOP			;\
			CODEPATCH_END(CPTAG_STAC)
#define SMAP_CLAC	CODEPATCH_START			;\
			SMAP_NOP			;\
			CODEPATCH_END(CPTAG_CLAC)

/*
 * Copy routines from and to userland, plus a few more. See the
 * section 9 manpages for info. Some cases can be optimized more.
 *
 * I wonder if it's worthwhile to make these use SSE2 registers.
 */

ENTRY(kcopy)
	movq	CPUVAR(CURPCB),%rax
	pushq	PCB_ONFAULT(%rax)
	leaq	_C_LABEL(copy_fault)(%rip),%r11
	movq	%r11, PCB_ONFAULT(%rax)

	xchgq	%rdi,%rsi
	movq	%rdx,%rcx

	movq	%rdi,%rax
	subq	%rsi,%rax
	cmpq	%rcx,%rax		# overlapping?
	jb	1f
	shrq	$3,%rcx			# nope, copy forward by 64-bit words
	rep
	movsq

	movq	%rdx,%rcx
	andl	$7,%ecx			# any bytes left?
	rep
	movsb

	movq	CPUVAR(CURPCB),%rdx
	popq	PCB_ONFAULT(%rdx)
	xorq	%rax,%rax
	ret

1:	addq	%rcx,%rdi		# copy backward
	addq	%rcx,%rsi
	std
	andq	$7,%rcx			# any fractional bytes?
	decq	%rdi
	decq	%rsi
	rep
	movsb
	movq	%rdx,%rcx		# copy remainder by 64-bit words
	shrq	$3,%rcx
	subq	$7,%rsi
	subq	$7,%rdi
	rep
	movsq
	cld

	movq	CPUVAR(CURPCB),%rdx
	popq	PCB_ONFAULT(%rdx)
	xorq	%rax,%rax
	ret

ENTRY(copyout)
	pushq	$0

	xchgq	%rdi,%rsi
	movq	%rdx,%rax
	
	movq	%rdi,%rdx
	addq	%rax,%rdx
	jc	_C_LABEL(copy_efault)
	movq	$VM_MAXUSER_ADDRESS,%r8
	cmpq	%r8,%rdx
	ja	_C_LABEL(copy_efault)

	movq	CPUVAR(CURPCB),%rdx
	leaq	_C_LABEL(copy_fault)(%rip),%r11
	movq	%r11,PCB_ONFAULT(%rdx)
	SMAP_STAC
	movq	%rax,%rcx
	shrq	$3,%rcx
	rep
	movsq
	movb	%al,%cl
	andb	$7,%cl
	rep
	movsb
	SMAP_CLAC
	popq	PCB_ONFAULT(%rdx)
	xorl	%eax,%eax
	ret

ENTRY(copyin)
	movq	CPUVAR(CURPCB),%rax
	pushq	$0
	leaq	_C_LABEL(copy_fault)(%rip),%r11
	movq	%r11,PCB_ONFAULT(%rax)
	SMAP_STAC
	xchgq	%rdi,%rsi
	movq	%rdx,%rax

	movq	%rsi,%rdx
	addq	%rax,%rdx
	jc	_C_LABEL(copy_efault)
	movq	$VM_MAXUSER_ADDRESS,%r8
	cmpq	%r8,%rdx
	ja	_C_LABEL(copy_efault)

3:	/* bcopy(%rsi, %rdi, %rax); */
	movq	%rax,%rcx
	shrq	$3,%rcx
	rep
	movsq
	movb	%al,%cl
	andb	$7,%cl
	rep
	movsb

	SMAP_CLAC
	movq	CPUVAR(CURPCB),%rdx
	popq	PCB_ONFAULT(%rdx)
	xorl	%eax,%eax
	ret

NENTRY(copy_efault)
	movq	$EFAULT,%rax

NENTRY(copy_fault)
	SMAP_CLAC
	movq	CPUVAR(CURPCB),%rdx
	popq	PCB_ONFAULT(%rdx)
	ret

ENTRY(copyoutstr)
	xchgq	%rdi,%rsi
	movq	%rdx,%r8
	movq	%rcx,%r9

5:	movq	CPUVAR(CURPCB),%rax
	leaq	_C_LABEL(copystr_fault)(%rip),%r11
	movq	%r11,PCB_ONFAULT(%rax)
	SMAP_STAC
	/*
	 * Get min(%rdx, VM_MAXUSER_ADDRESS-%rdi).
	 */
	movq	$VM_MAXUSER_ADDRESS,%rax
	subq	%rdi,%rax
	jbe	_C_LABEL(copystr_efault)	/* die if CF == 1 || ZF == 1 */
	cmpq	%rdx,%rax
	jae	1f
	movq	%rax,%rdx
	movq	%rax,%r8

1:	incq	%rdx

1:	decq	%rdx
	jz	2f
	lodsb
	stosb
	testb	%al,%al
	jnz	1b

	/* Success -- 0 byte reached. */
	decq	%rdx
	xorq	%rax,%rax
	jmp	copystr_return

2:	/* rdx is zero -- return EFAULT or ENAMETOOLONG. */
	movq	$VM_MAXUSER_ADDRESS,%r11
	cmpq	%r11,%rdi
	jae	_C_LABEL(copystr_efault)
	movq	$ENAMETOOLONG,%rax
	jmp	copystr_return

ENTRY(copyinstr)
	xchgq	%rdi,%rsi
	movq	%rdx,%r8
	movq	%rcx,%r9

	movq	CPUVAR(CURPCB),%rcx
	leaq	_C_LABEL(copystr_fault)(%rip),%r11
	movq	%r11,PCB_ONFAULT(%rcx)
	SMAP_STAC

	/*
	 * Get min(%rdx, VM_MAXUSER_ADDRESS-%rsi).
	 */
	movq	$VM_MAXUSER_ADDRESS,%rax
	subq	%rsi,%rax
	jbe	_C_LABEL(copystr_efault)	/* die if CF == 1 || ZF == 1 */
	cmpq	%rdx,%rax
	jae	1f
	movq	%rax,%rdx
	movq	%rax,%r8

1:	incq	%rdx

1:	decq	%rdx
	jz	2f
	lodsb
	stosb
	testb	%al,%al
	jnz	1b

	/* Success -- 0 byte reached. */
	decq	%rdx
	xorq	%rax,%rax
	jmp	copystr_return

2:	/* edx is zero -- return EFAULT or ENAMETOOLONG. */
	movq	$VM_MAXUSER_ADDRESS,%r11
	cmpq	%r11,%rsi
	jae	_C_LABEL(copystr_efault)
	movq	$ENAMETOOLONG,%rax
	jmp	copystr_return

ENTRY(copystr_efault)
	movl	$EFAULT,%eax

ENTRY(copystr_fault)
copystr_return:
	SMAP_CLAC
	/* Set *lencopied and return %eax. */
	movq	CPUVAR(CURPCB),%rcx
	movq	$0,PCB_ONFAULT(%rcx)
	testq	%r9,%r9
	jz	8f
	subq	%rdx,%r8
	movq	%r8,(%r9)

8:	ret

ENTRY(copystr)
	xchgq	%rdi,%rsi
	movq	%rdx,%r8

	incq	%rdx

1:	decq	%rdx
	jz	4f
	lodsb
	stosb
	testb	%al,%al
	jnz	1b

	/* Success -- 0 byte reached. */
	decq	%rdx
	xorl	%eax,%eax
	jmp	6f

4:	/* edx is zero -- return ENAMETOOLONG. */
	movl	$ENAMETOOLONG,%eax

6:	/* Set *lencopied and return %eax. */
	testq	%rcx,%rcx
	jz	7f
	subq	%rdx,%r8
	movq	%r8,(%rcx)

7:	ret

.globl _C_LABEL(_stac)
_C_LABEL(_stac):
	stac

.globl _C_LABEL(_clac)
_C_LABEL(_clac):
	clac
@


1.6
log
@Binary code patching on amd64

This commit adds generic infrastructure to do binary code patching on amd64.
The existing code patching for SMAP is converted to the new infrastruture.

More consumers and support for i386 will follow later.

This version of the diff has some simplifications in codepatch_fill_nop()
compared to a version that was:

OK @@kettenis @@mlarkin @@jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: copy.S,v 1.5 2012/10/31 03:30:22 jsg Exp $	*/
d84 1
a84 2
	cld				# nope, copy forward
	shrq	$3,%rcx			# copy by 64-bit words
a135 1
	cld
a165 1
	cld
a210 1
	cld
a252 1
	cld
a293 1
	cld
@


1.5
log
@Add support for Intel's Supervisor Mode Access Prevention (SMAP) feature.
When enabled SMAP will generate page faults on the kernel attempting
to read/write user data pages unless an override flag is set.

Instructions that modify the flag are patched into copyin/copyout and
friends on boot if SMAP is enabled.

Those with access to hardware with SMAP can contact me for a test case.

joint work with deraadt@@

ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: copy.S,v 1.4 2008/06/09 20:43:41 miod Exp $	*/
d45 1
d57 6
a119 1
.globl _C_LABEL(_copyout_stac), _C_LABEL(_copyout_clac)
d136 1
a136 3
_C_LABEL(_copyout_stac):
	SMAP_NOP

d146 1
a146 3

_C_LABEL(_copyout_clac):
	SMAP_NOP
a150 1
.globl _C_LABEL(_copyin_stac), _C_LABEL(_copyin_clac)
d156 1
a156 3
_C_LABEL(_copyin_stac):
	SMAP_NOP

d178 1
a178 2
_C_LABEL(_copyin_clac):
	SMAP_NOP
a186 1
.globl _C_LABEL(_copy_fault_clac)
d188 1
a188 2
_C_LABEL(_copy_fault_clac):
	SMAP_NOP
a192 1
.globl _C_LABEL(_copyoutstr_stac)
d201 1
a201 2
_C_LABEL(_copyoutstr_stac):
	SMAP_NOP
a234 1
.globl _C_LABEL(_copyinstr_stac)
d243 1
a243 2
_C_LABEL(_copyinstr_stac):
	SMAP_NOP
a280 1
.globl _C_LABEL(_copystr_fault_clac)
d283 1
a283 2
_C_LABEL(_copystr_fault_clac):
	SMAP_NOP
@


1.4
log
@Remove fillw(). Bonus points if you do not remember what it was used for.
@
text
@d1 1
a1 1
/*	$OpenBSD: copy.S,v 1.3 2007/05/29 23:03:20 tom Exp $	*/
d47 11
d113 1
d130 2
d143 2
d149 1
d155 2
d179 2
d189 1
d191 2
d197 1
d206 2
d241 1
d250 2
d289 1
d292 2
d333 8
@


1.3
log
@Improve copyinstr and copyoutstr by erroring out when the userland
pointer is VM_MAXUSER_ADDRESS right up front, rather than when
startig the loop.  This is how it is done on i386.

ok weingart@@ art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: copy.S,v 1.2 2005/03/16 07:08:38 tedu Exp $	*/
a51 24

/*
 * XXXfvdl appears only to be used by pccons.
 *
 * fillw(short pattern, caddr_t addr, size_t len);
 * Write len copies of pattern at addr.
 * appears to be used by pccons.
 */
ENTRY(fillw)
	movl	%edi,%eax
	movq	%rsi,%rdi
	movw	%ax,%cx
	rorl	$16,%eax
	movw	%cx,%ax
	cld
	movq	%rdx,%rcx
	shrq	%rcx
	rep
	stosl
	movq	%rdx,%rcx
	andq	$1,%rcx
	rep
	stosw
	ret
@


1.2
log
@amd64 also fails copyoutstr regress, missed in the first round.
need to checker the to address.
patch from netbsd.  ok deraadt mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: copy.S,v 1.1 2004/01/28 01:39:38 mickey Exp $	*/
d210 1
a210 1
	jc	_C_LABEL(copystr_efault)
d252 1
a252 1
	jc	_C_LABEL(copystr_efault)
@


1.1
log
@an amd64 arch support.
hacked by art@@ from netbsd sources and then later debugged
by me into the shape where it can host itself.
no bootloader yet as needs redoing from the
recent advanced i386 sources (anyone? ;)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d210 1
d252 1
@


1.1.4.1
log
@MFC:
Fix by tedu@@

amd64 also fails copyoutstr regress, missed in the first round.
need to checker the to address.
patch from netbsd.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: copy.S,v 1.1 2004/01/28 01:39:38 mickey Exp $	*/
a209 1
	jc	_C_LABEL(copystr_efault)
a250 1
	jc	_C_LABEL(copystr_efault)
@


1.1.6.1
log
@MFC:
Fix by tedu@@

amd64 also fails copyoutstr regress, missed in the first round.
need to checker the to address.
patch from netbsd.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: copy.S,v 1.1 2004/01/28 01:39:38 mickey Exp $	*/
a209 1
	jc	_C_LABEL(copystr_efault)
a250 1
	jc	_C_LABEL(copystr_efault)
@


