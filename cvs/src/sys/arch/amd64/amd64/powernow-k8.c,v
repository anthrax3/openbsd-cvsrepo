head	1.26;
access;
symbols
	OPENBSD_6_2:1.26.0.4
	OPENBSD_6_2_BASE:1.26
	OPENBSD_6_1:1.25.0.10
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.25.0.6
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.25.0.4
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.23.0.4
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.22.0.18
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.14
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.12
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.10
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.8
	OPENBSD_5_0:1.22.0.6
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.4
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.2
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.21.0.6
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.21.0.8
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.4
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.2
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.19.0.4
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.2
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10;
locks; strict;
comment	@ * @;


1.26
date	2017.09.08.05.36.51;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	uRv5pa9QDlZaYgwD;

1.25
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.24;
commitid	p4LJxGKbi0BU2cG6;

1.24
date	2014.09.14.14.17.23;	author jsg;	state Exp;
branches;
next	1.23;
commitid	uzzBR7hz9ncd4O6G;

1.23
date	2014.07.12.18.44.41;	author tedu;	state Exp;
branches;
next	1.22;
commitid	uKVPYMN2MLxdZxzH;

1.22
date	2010.04.20.22.05.41;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2008.06.29.03.50.49;	author gwk;	state Exp;
branches;
next	1.20;

1.20
date	2008.06.15.00.10.47;	author gwk;	state Exp;
branches;
next	1.19;

1.19
date	2007.05.31.17.49.15;	author gwk;	state Exp;
branches;
next	1.18;

1.18
date	2007.05.06.03.37.08;	author gwk;	state Exp;
branches;
next	1.17;

1.17
date	2007.04.25.00.27.43;	author gwk;	state Exp;
branches;
next	1.16;

1.16
date	2007.02.17.11.51.21;	author tom;	state Exp;
branches;
next	1.15;

1.15
date	2006.12.20.22.48.29;	author gwk;	state Exp;
branches;
next	1.14;

1.14
date	2006.12.12.23.14.27;	author dim;	state Exp;
branches;
next	1.13;

1.13
date	2006.12.09.00.16.46;	author gwk;	state Exp;
branches;
next	1.12;

1.12
date	2006.10.19.10.55.56;	author tom;	state Exp;
branches;
next	1.11;

1.11
date	2006.09.25.22.28.11;	author gwk;	state Exp;
branches;
next	1.10;

1.10
date	2006.08.25.20.52.59;	author gwk;	state Exp;
branches;
next	1.9;

1.9
date	2006.08.24.20.52.21;	author gwk;	state Exp;
branches;
next	1.8;

1.8
date	2006.06.16.05.58.50;	author gwk;	state Exp;
branches;
next	1.7;

1.7
date	2006.06.13.00.32.35;	author gwk;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.27.04.46.12;	author gwk;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.18.04.58.41;	author gwk;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.16.02.39.57;	author dlg;	state Exp;
branches;
next	1.3;

1.3
date	2006.03.16.02.35.08;	author dlg;	state Exp;
branches;
next	1.2;

1.2
date	2006.03.15.19.56.00;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2006.03.08.03.33.21;	author uwe;	state Exp;
branches;
next	;


desc
@@


1.26
log
@If you use sys/param.h, you don't need sys/types.h
@
text
@/*	$OpenBSD: powernow-k8.c,v 1.25 2015/03/14 03:38:46 jsg Exp $ */
/*
 * Copyright (c) 2004 Martin Végiard.
 * Copyright (c) 2004-2005 Bruno Ducrot
 * Copyright (c) 2004 FUKUDA Nobuhiko <nfukuda@@spa.is.uec.ac.jp>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/* AMD POWERNOW K8 driver */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/sysctl.h>

#include <dev/isa/isareg.h>
#include <amd64/include/isa_machdep.h>

#include <machine/cpu.h>
#include <machine/cpufunc.h>
#include <machine/bus.h>

#include "acpicpu.h"

#if NACPICPU > 0
#include <dev/acpi/acpidev.h>
#endif

#define BIOS_START			0xe0000
#define	BIOS_LEN			0x20000

extern int setperf_prio;
extern int perflevel;

/*
 * MSRs and bits used by PowerNow technology
 */
#define MSR_AMDK7_FIDVID_CTL		0xc0010041
#define MSR_AMDK7_FIDVID_STATUS		0xc0010042

/* Bitfields used by K8 */

#define PN8_CTR_FID(x)			((x) & 0x3f)
#define PN8_CTR_VID(x)			(((x) & 0x1f) << 8)
#define PN8_CTR_PENDING(x)		(((x) & 1) << 32)

#define PN8_STA_CFID(x)			((x) & 0x3f)
#define PN8_STA_SFID(x)			(((x) >> 8) & 0x3f)
#define PN8_STA_MFID(x)			(((x) >> 16) & 0x3f)
#define PN8_STA_PENDING(x)		(((x) >> 31) & 0x01)
#define PN8_STA_CVID(x)			(((x) >> 32) & 0x1f)
#define PN8_STA_SVID(x)			(((x) >> 40) & 0x1f)
#define PN8_STA_MVID(x)			(((x) >> 48) & 0x1f)

/* Reserved1 to PowerNow K8 configuration */
#define PN8_PSB_TO_RVO(x)		((x) & 0x03)
#define PN8_PSB_TO_IRT(x)		(((x) >> 2) & 0x03)
#define PN8_PSB_TO_MVS(x)		(((x) >> 4) & 0x03)
#define PN8_PSB_TO_BATT(x)		(((x) >> 6) & 0x03)

/* ACPI ctr_val status register to PowerNow K8 configuration */
#define PN8_ACPI_CTRL_TO_FID(x)		((x) & 0x3f)
#define PN8_ACPI_CTRL_TO_VID(x)		(((x) >> 6) & 0x1f)
#define PN8_ACPI_CTRL_TO_VST(x)		(((x) >> 11) & 0x1f)
#define PN8_ACPI_CTRL_TO_MVS(x)		(((x) >> 18) & 0x03)
#define PN8_ACPI_CTRL_TO_PLL(x)		(((x) >> 20) & 0x7f)
#define PN8_ACPI_CTRL_TO_RVO(x)		(((x) >> 28) & 0x03)
#define PN8_ACPI_CTRL_TO_IRT(x)		(((x) >> 30) & 0x03)

#define PN8_PSS_CFID(x)			((x) & 0x3f)
#define PN8_PSS_CVID(x)			(((x) >> 6) & 0x1f)

#define WRITE_FIDVID(fid, vid, ctrl)	\
	wrmsr(MSR_AMDK7_FIDVID_CTL,	\
	    (((ctrl) << 32) | (1ULL << 16) | ((vid) << 8) | (fid)))


#define COUNT_OFF_IRT(irt)	DELAY(10 * (1 << (irt)))
#define COUNT_OFF_VST(vst)	DELAY(20 * (vst))

#define FID_TO_VCO_FID(fid)	\
	(((fid) < 8) ? (8 + ((fid) << 1)) : (fid))

#define POWERNOW_MAX_STATES		16

struct k8pnow_state {
	int freq;
	uint8_t fid;
	uint8_t vid;
};

struct k8pnow_cpu_state {
	struct k8pnow_state state_table[POWERNOW_MAX_STATES];
	unsigned int n_states;
	unsigned int sgtc;
	unsigned int vst;
	unsigned int mvs;
	unsigned int pll;
	unsigned int rvo;
	unsigned int irt;
	int low;
};

struct psb_s {
	char signature[10];     /* AMDK7PNOW! */
	uint8_t version;
	uint8_t flags;
	uint16_t ttime;		/* Min Settling time */
	uint8_t reserved;
	uint8_t n_pst;
};

struct pst_s {
	uint32_t cpuid;
	uint8_t pll;
	uint8_t fid;
	uint8_t vid;
	uint8_t n_states;
};

struct k8pnow_cpu_state *k8pnow_current_state;

int k8pnow_read_pending_wait(uint64_t *);
int k8pnow_decode_pst(struct k8pnow_cpu_state *, uint8_t *);
int k8pnow_states(struct k8pnow_cpu_state *, uint32_t, unsigned int, unsigned int);
void k8pnow_transition(struct k8pnow_cpu_state *e, int);

#if NACPICPU > 0
int k8pnow_acpi_init(struct k8pnow_cpu_state *, uint64_t);
void k8pnow_acpi_pss_changed(struct acpicpu_pss *, int);
int k8pnow_acpi_states(struct k8pnow_cpu_state *, struct acpicpu_pss *, int,
    uint64_t);
#endif

int
k8pnow_read_pending_wait(uint64_t *status)
{
	unsigned int i = 100000;

	while (i--) {
		*status = rdmsr(MSR_AMDK7_FIDVID_STATUS);
		if (!PN8_STA_PENDING(*status))
			return 0;

	}
	printf("k8pnow_read_pending_wait: change pending stuck.\n");
	return 1;
}

void
k8_powernow_setperf(int level)
{
	unsigned int i;
	struct k8pnow_cpu_state *cstate;

	cstate = k8pnow_current_state;

	i = ((level * cstate->n_states) + 1) / 101;
	if (i >= cstate->n_states)
		i = cstate->n_states - 1;

	k8pnow_transition(cstate, i);
}

void
k8pnow_transition(struct k8pnow_cpu_state *cstate, int level)
{
	uint64_t status;
	int cfid, cvid, fid = 0, vid = 0;
	int rvo;
	u_int val;

	/*
	 * We dont do a k8pnow_read_pending_wait here, need to ensure that the
	 * change pending bit isn't stuck,
	 */
	status = rdmsr(MSR_AMDK7_FIDVID_STATUS);
	if (PN8_STA_PENDING(status))
		return;
	cfid = PN8_STA_CFID(status);
	cvid = PN8_STA_CVID(status);

	fid = cstate->state_table[level].fid;
	vid = cstate->state_table[level].vid;

	if (fid == cfid && vid == cvid)
		return;

	/*
	 * Phase 1: Raise core voltage to requested VID if frequency is
	 * going up.
	 */
	while (cvid > vid) {
		val = cvid - (1 << cstate->mvs);
		WRITE_FIDVID(cfid, (val > 0) ? val : 0, 1ULL);
		if (k8pnow_read_pending_wait(&status))
			return;
		cvid = PN8_STA_CVID(status);
		COUNT_OFF_VST(cstate->vst);
	}

	/* ... then raise to voltage + RVO (if required) */
	for (rvo = cstate->rvo; rvo > 0 && cvid > 0; --rvo) {
		/* XXX It's not clear from spec if we have to do that
		 * in 0.25 step or in MVS.  Therefore do it as it's done
		 * under Linux */
		WRITE_FIDVID(cfid, cvid - 1, 1ULL);
		if (k8pnow_read_pending_wait(&status))
			return;
		cvid = PN8_STA_CVID(status);
		COUNT_OFF_VST(cstate->vst);
	}

	/* Phase 2: change to requested core frequency */
	if (cfid != fid) {
		u_int vco_fid, vco_cfid;

		vco_fid = FID_TO_VCO_FID(fid);
		vco_cfid = FID_TO_VCO_FID(cfid);

		while (abs(vco_fid - vco_cfid) > 2) {
			if (fid > cfid) {
				if (cfid > 6)
					val = cfid + 2;
				else
					val = FID_TO_VCO_FID(cfid) + 2;
			} else
				val = cfid - 2;
			WRITE_FIDVID(val, cvid, (uint64_t)cstate->pll * 1000 / 5);

			if (k8pnow_read_pending_wait(&status))
				return;
			cfid = PN8_STA_CFID(status);
			COUNT_OFF_IRT(cstate->irt);

			vco_cfid = FID_TO_VCO_FID(cfid);
		}

		WRITE_FIDVID(fid, cvid, (uint64_t) cstate->pll * 1000 / 5);
		if (k8pnow_read_pending_wait(&status))
			return;
		cfid = PN8_STA_CFID(status);
		COUNT_OFF_IRT(cstate->irt);
	}

	/* Phase 3: change to requested voltage */
	if (cvid != vid) {
		WRITE_FIDVID(cfid, vid, 1ULL);
		if (k8pnow_read_pending_wait(&status))
			return;
		cvid = PN8_STA_CVID(status);
		COUNT_OFF_VST(cstate->vst);
	}

	if (cfid == fid || cvid == vid)
		cpuspeed = cstate->state_table[level].freq;
}

/*
 * Given a set of pair of fid/vid, and number of performance states,
 * compute state_table via an insertion sort.
 */
int
k8pnow_decode_pst(struct k8pnow_cpu_state *cstate, uint8_t *p)
{
	int i, j, n;
	struct k8pnow_state state;
	for (n = 0, i = 0; i < cstate->n_states; i++) {
		state.fid = *p++;
		state.vid = *p++;

		/*
		 * The minimum supported frequency per the data sheet is 800MHz
		 * The maximum supported frequency is 5000MHz.
		 */
		state.freq = 800 + state.fid * 100;
		j = n;
		while (j > 0 && cstate->state_table[j - 1].freq > state.freq) {
			memcpy(&cstate->state_table[j],
			    &cstate->state_table[j - 1],
			    sizeof(struct k8pnow_state));
			--j;
		}
		memcpy(&cstate->state_table[j], &state,
		    sizeof(struct k8pnow_state));
		n++;
	}
	return 1;
}

#if NACPICPU > 0

int
k8pnow_acpi_states(struct k8pnow_cpu_state * cstate, struct acpicpu_pss * pss,
    int nstates, uint64_t status)
{
	struct k8pnow_state state;
	int j, k, n;
	uint32_t ctrl;

	k = -1;

	for (n = 0; n < cstate->n_states; n++) {
		if ((PN8_STA_CFID(status) == PN8_PSS_CFID(pss[n].pss_status)) &&
		    (PN8_STA_CVID(status) == PN8_PSS_CVID(pss[n].pss_status)))
			k = n;
		ctrl = pss[n].pss_ctrl;
		state.fid = PN8_ACPI_CTRL_TO_FID(ctrl);
		state.vid = PN8_ACPI_CTRL_TO_VID(ctrl);

		state.freq = pss[n].pss_core_freq;
		j = n;
		while (j > 0 && cstate->state_table[j - 1].freq > state.freq) {
			memcpy(&cstate->state_table[j],
			    &cstate->state_table[j - 1],
			    sizeof(struct k8pnow_state));
			--j;
		}
		memcpy(&cstate->state_table[j], &state,
		    sizeof(struct k8pnow_state));
	}

	return k;
}

void
k8pnow_acpi_pss_changed(struct acpicpu_pss * pss, int npss)
{
	int curs, needtran;
	struct k8pnow_cpu_state *cstate, *nstate;
	uint32_t ctrl;
	uint64_t status;

	status = rdmsr(MSR_AMDK7_FIDVID_STATUS);
	cstate = k8pnow_current_state;

	nstate = malloc(sizeof(struct k8pnow_cpu_state), M_DEVBUF, M_NOWAIT);
	if (!nstate)
		return;

	curs = k8pnow_acpi_states(nstate, pss, npss, status);
	needtran = 0;

	if (curs < 0) {
		/* Our current opearting state is not among the ones found the new PSS */
		curs = ((perflevel * npss) + 1) / 101;
		if (curs >= npss)
			curs = npss - 1;
		needtran = 1;
	}

	ctrl = pss[curs].pss_ctrl;

	nstate->rvo = PN8_ACPI_CTRL_TO_RVO(ctrl);
	nstate->vst = PN8_ACPI_CTRL_TO_VST(ctrl);
	nstate->mvs = PN8_ACPI_CTRL_TO_MVS(ctrl);
	nstate->pll = PN8_ACPI_CTRL_TO_PLL(ctrl);
	nstate->irt = PN8_ACPI_CTRL_TO_IRT(ctrl);
	nstate->low = 0;
	nstate->n_states = npss;

	if (needtran)
		k8pnow_transition(nstate, curs);

	free(cstate, M_DEVBUF, 0);
	k8pnow_current_state = nstate;
}

int
k8pnow_acpi_init(struct k8pnow_cpu_state * cstate, uint64_t status)
{
	int curs;
	uint32_t ctrl;
	struct acpicpu_pss *pss;

	cstate->n_states = acpicpu_fetch_pss(&pss);
	if (cstate->n_states == 0)
		return 0;
	acpicpu_set_notify(k8pnow_acpi_pss_changed);

	curs = k8pnow_acpi_states(cstate, pss, cstate->n_states, status);
	ctrl = pss[curs].pss_ctrl;

	cstate->rvo = PN8_ACPI_CTRL_TO_RVO(ctrl);
	cstate->vst = PN8_ACPI_CTRL_TO_VST(ctrl);
	cstate->mvs = PN8_ACPI_CTRL_TO_MVS(ctrl);
	cstate->pll = PN8_ACPI_CTRL_TO_PLL(ctrl);
	cstate->irt = PN8_ACPI_CTRL_TO_IRT(ctrl);
	cstate->low = 0;

	return 1;
}

#endif /* NACPICPU */

int
k8pnow_states(struct k8pnow_cpu_state *cstate, uint32_t cpusig,
    unsigned int fid, unsigned int vid)
{
	struct psb_s *psb;
	struct pst_s *pst;
	uint8_t *p;
	int i;

	for (p = (u_int8_t *)ISA_HOLE_VADDR(BIOS_START);
	    p < (u_int8_t *)ISA_HOLE_VADDR(BIOS_START + BIOS_LEN); p += 16) {
		if (memcmp(p, "AMDK7PNOW!", 10) == 0) {
			psb = (struct psb_s *)p;
			if (psb->version != 0x14)
				return 0;

			cstate->vst = psb->ttime;
			cstate->rvo = PN8_PSB_TO_RVO(psb->reserved);
			cstate->irt = PN8_PSB_TO_IRT(psb->reserved);
			cstate->mvs = PN8_PSB_TO_MVS(psb->reserved);
			cstate->low = PN8_PSB_TO_BATT(psb->reserved);
			p+= sizeof(struct psb_s);

			for(i = 0; i < psb->n_pst; ++i) {
				pst = (struct pst_s *) p;

				cstate->pll = pst->pll;
				cstate->n_states = pst->n_states;
				if (cpusig == pst->cpuid &&
				    pst->fid == fid && pst->vid == vid) {
					return (k8pnow_decode_pst(cstate,
					    p+= sizeof (struct pst_s)));
				}
				p += sizeof(struct pst_s) + 2
				    * cstate->n_states;
			}
		}
	}

	return 0;

}

void
k8_powernow_init(struct cpu_info *ci)
{
	uint64_t status;
	u_int maxfid, maxvid, i;
	u_int32_t extcpuid, dummy;
	struct k8pnow_cpu_state *cstate;
	struct k8pnow_state *state;
	char * techname = NULL;

	if (setperf_prio > 1)
		return;

	cstate = malloc(sizeof(struct k8pnow_cpu_state), M_DEVBUF, M_NOWAIT);
	if (!cstate)
		return;

	cstate->n_states = 0;
	status = rdmsr(MSR_AMDK7_FIDVID_STATUS);
	maxfid = PN8_STA_MFID(status);
	maxvid = PN8_STA_MVID(status);

	/*
	* If start FID is different to max FID, then it is a
	* mobile processor.  If not, it is a low powered desktop
	* processor.
	*/
	if (PN8_STA_SFID(status) != PN8_STA_MFID(status))
		techname = "PowerNow! K8";
	else
		techname = "Cool'n'Quiet K8";

#if NACPICPU > 0
	/* If we have acpi check acpi first */
	if (!k8pnow_acpi_init(cstate, status))
#endif
	{
		if (!k8pnow_states(cstate, ci->ci_signature, maxfid, maxvid)) {
			/* Extended CPUID signature value */
			CPUID(0x80000001, extcpuid, dummy, dummy, dummy);
			k8pnow_states(cstate, extcpuid, maxfid, maxvid);
		}
	}
	if (cstate->n_states) {
		printf("%s: %s %d MHz: speeds:",
		    ci->ci_dev->dv_xname, techname, cpuspeed);
		for (i = cstate->n_states; i > 0; i--) {
			state = &cstate->state_table[i-1];
			printf(" %d", state->freq);
		}
		printf(" MHz\n");
		k8pnow_current_state = cstate;
		cpu_setperf = k8_powernow_setperf;
		setperf_prio = 1;
		return;
	}
	free(cstate, M_DEVBUF, 0);
}
@


1.25
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.24 2014/09/14 14:17:23 jsg Exp $ */
a28 1
#include <sys/types.h>
@


1.24
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.23 2014/07/12 18:44:41 tedu Exp $ */
a45 1
#include <dev/acpi/acpivar.h>
@


1.23
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.22 2010/04/20 22:05:41 tedu Exp $ */
a32 1
#include <sys/proc.h>
@


1.22
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.21 2008/06/29 03:50:49 gwk Exp $ */
d386 1
a386 1
	free(cstate, M_DEVBUF);
d516 1
a516 1
	free(cstate, M_DEVBUF);
@


1.21
log
@Split k8_powernow_setperf into two functions, the new function called
k8pnow_transition handles the actual transition, this change is
necessitated by some of the ACPI work which can involve dynamic changes
in the available states in response to endogenous events such as removing
the AC power. This new code is designed to cope with the current operating
point not being among the newly available states in which case we
recalculate what the current desired performance level coresponds to among
the new states.

Also fix a screw up with the acpi_states function (fix originally by
Markus Hennecke in a diff to tech@@ thanks) which resolves PR 5854. Diff
tested by numerous people thanks!

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.20 2008/06/15 00:10:47 gwk Exp $ */
d33 1
@


1.20
log
@Ensure that when using the ACPI tables the RVO field is initialized from the ctrl value.
commit it marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.19 2007/05/31 17:49:15 gwk Exp $ */
d53 1
d90 3
d145 2
a146 2
int k8pnow_states(struct k8pnow_cpu_state *, uint32_t, unsigned int,
    unsigned int);
d174 14
a191 1
	struct k8pnow_cpu_state *cstate;
d203 2
a204 8
	cstate = k8pnow_current_state;

	i = ((level * cstate->n_states) + 1) / 101;
	if (i >= cstate->n_states)
		i = cstate->n_states - 1;

	fid = cstate->state_table[i].fid;
	vid = cstate->state_table[i].vid;
d276 1
a276 1
		cpuspeed = cstate->state_table[i].freq;
d324 2
a325 1
		if (status == pss[n].pss_status)
d349 2
a350 2
	int curs;
	struct k8pnow_cpu_state * cstate;
d357 15
a371 1
	curs = k8pnow_acpi_states(cstate, pss, npss, status);
d374 13
a386 7
	cstate->rvo = PN8_ACPI_CTRL_TO_RVO(ctrl);
	cstate->vst = PN8_ACPI_CTRL_TO_VST(ctrl);
	cstate->mvs = PN8_ACPI_CTRL_TO_MVS(ctrl);
	cstate->pll = PN8_ACPI_CTRL_TO_PLL(ctrl);
	cstate->irt = PN8_ACPI_CTRL_TO_IRT(ctrl);
	cstate->low = 0;
	cstate->n_states = npss;
@


1.19
log
@Make powernow-k8 on amd64 and i386 use the _PSS object from acpi to
retreive p_state data as spelled out in the amd64 bios and kernel
developers guide. This code is still a little rough around the edges but
has been tested by myself on a tyan machine and by phessler at theapt
dot org on an HP DL145. This diff also takes a first stab and cleaning up
the acpicpu dmesg spam.

ok tedu, marco
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.18 2007/05/06 03:37:08 gwk Exp $ */
d347 2
d372 1
@


1.18
log
@Add the mp setperf mechanism to AMD64, like its i386 counterpart it allows
all cpus in a system supporting frequency and voltage scaling to be scaled
by the same amount corresponding to the user (or apmd on their behalf)
performance level.

This diff also teaches amd64 about acpi_hasprocfvs (ACPI has processor
frequency and voltage scaling).

It also moves initilization of the underlying setperf mechanism such
as powernow to mainbus from the cpu indentification and initilization
code inspired by similar changes dim@@ made to i386 durring h2k6. This
is necessary to implement the AMD recommended method for retreiving
p_state data from the ACPI _PSS object (a diff comming soon). It will
also simplify the potential addition of enhanced speedstep as found
on newer intel processors with EMT64 capable of running OpenBSD/amd64.

MP setperf functionality verifed by myself and Johan M:son Lindman <tybolt
AT solace DOT miun DOT se> on opteron 265 and 270 systems respectively.
General testing done by many others thanks!

ok tedu, dim
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.17 2007/04/25 00:27:43 gwk Exp $ */
d42 7
d81 7
a87 7
#define ACPI_PN8_CTRL_TO_FID(x)		((x) & 0x3f)
#define ACPI_PN8_CTRL_TO_VID(x)		(((x) >> 6) & 0x1f)
#define ACPI_PN8_CTRL_TO_VST(x)		(((x) >> 11) & 0x1f)
#define ACPI_PN8_CTRL_TO_MVS(x)		(((x) >> 18) & 0x03)
#define ACPI_PN8_CTRL_TO_PLL(x)		(((x) >> 20) & 0x7f)
#define ACPI_PN8_CTRL_TO_RVO(x)		(((x) >> 28) & 0x03)
#define ACPI_PN8_CTRL_TO_IRT(x)		(((x) >> 30) & 0x03)
d144 7
d300 81
d456 11
a466 5
	/* Extended CPUID signature value */
	CPUID(0x80000001, extcpuid, dummy, dummy, dummy);

	if (!k8pnow_states(cstate, ci->ci_signature, maxfid, maxvid))
		k8pnow_states(cstate, extcpuid, maxfid, maxvid);
@


1.17
log
@Same change as i386, use the number of states to calculate performance
levels.

ok canacar
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.16 2007/02/17 11:51:21 tom Exp $ */
d330 1
a330 1
k8_powernow_init(void)
a336 1
	struct cpu_info * ci;
a337 1
	ci = curcpu();
@


1.16
log
@Fix spelling of Cool'n'Quiet, as done on i386 some time ago.  Also
correct PowerNow in a couple of places.
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.15 2006/12/20 22:48:29 gwk Exp $ */
d117 1
a117 1
	uint16_t ttime;         /* Min Settling time */
a131 3
/*
 * Prototypes
 */
d155 1
a155 1
	unsigned int i, low, high, freq;
a172 2
	low = cstate->state_table[0].freq;
	high = cstate->state_table[cstate->n_states-1].freq;
d174 3
a176 1
	freq = low + (high - low) * level / 100;
d178 2
a179 7
	for (i = 0; i < cstate->n_states; i++) {
		if (cstate->state_table[i].freq >= freq) {
			fid = cstate->state_table[i].fid;
			vid = cstate->state_table[i].vid;
			break;
		}
	}
d266 1
a266 1
	
d319 2
a320 1
				p += sizeof(struct pst_s) + 2 * cstate->n_states;
@


1.15
log
@Decalre extern int cpuspeed in sys/arch/amd64/include/cpu.h like cpuspeed
is declared in the equivalent file on i386 and delete the repeticious
declarations already scattered in a few places.
Thanks to Will Backman for letting me test this on his machine,
ok mk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.14 2006/12/12 23:14:27 dim Exp $ */
d48 1
a48 1
 * MSRs and bits used by Powernow technology
d67 1
a67 1
/* Reserved1 to powernow k8 configuration */
d73 1
a73 1
/* ACPI ctr_val status register to powernow k8 configuration */
d368 1
a368 1
		techname = "Cool`n'Quiet K8";
@


1.14
log
@Complete gwk's previous patch to stop setperf methods from returning
errors to userland: make all cpu_setperf functions return void.

Tested by many, ok gwk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.13 2006/12/09 00:16:46 gwk Exp $ */
a44 1
extern int cpuspeed;
@


1.13
log
@Like the earlier change to powernow-k7.c check for both the regular cpuid
signature AND the AMD extended cpuid 0x800000001 (%eax).
Tested by,
krw@@, Joerg Niendorf <joerg.bsd AT internode.net.au> and
steven mestdagh <steven.mestdagh AT esat.kuleuven.be>

ok dim@@
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.12 2006/10/19 10:55:56 tom Exp $ */
d156 1
a156 1
int
d172 1
a172 1
		return 0;
d191 1
a191 1
		return (0);
d201 1
a201 1
			return 0;
d213 1
a213 1
			return 0;
d236 1
a236 1
				return 0;
d245 1
a245 1
			return 0;
d254 1
a254 1
			return 0;
a260 2

	return (0);
@


1.12
log
@s/Mhz/MHz/ in comments and printf() strings

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.11 2006/09/25 22:28:11 gwk Exp $ */
d344 1
d358 1
d373 11
a383 13
	if (k8pnow_states(cstate, ci->ci_signature, maxfid, maxvid)) {
		if (cstate->n_states) {
			printf("%s: %s %d MHz: speeds:",
			    ci->ci_dev->dv_xname, techname, cpuspeed);
			for(i = cstate->n_states; i > 0; i--) {
				state = &cstate->state_table[i-1];
				printf(" %d", state->freq);
			}
			printf(" MHz\n");
			k8pnow_current_state = cstate;
			cpu_setperf = k8_powernow_setperf;
			setperf_prio = 1;
			return;
d385 5
@


1.11
log
@Martin Végiard <deadbug AT gmail.com> has been kind enough to rescind the
third clause of his license and strike the phrase "All rights reserved", so we
can consolidate both license blocks into one. Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.10 2006/08/25 20:52:59 gwk Exp $ */
d373 1
a373 1
			printf("%s: %s %d Mhz: speeds:",
d379 1
a379 1
			printf(" Mhz\n");
@


1.10
log
@Be a little less agressive in declaring the change pending bit stuck, increase
the number of retries by two orders of magnitude wont affect most systems
but will make transitions smoother on marginal ones, if people see
"change pending bit stuck" printed to the console after this I would like to
hear about it.

tested by and ok niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.9 2006/08/24 20:52:21 gwk Exp $ */
a3 24
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
@


1.9
log
@Fix a few more cases where we propogate low level errors to userland.
found by niallo.
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.8 2006/06/16 05:58:50 gwk Exp $ */
d168 1
a168 1
	unsigned int i = 1000;
@


1.8
log
@From k*_powernow_setperf() always return 0, i.e.
Do not return low level errors to userspace where they will not/can not be
coped with.
: ----------------------------------------------------------------------
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.7 2006/06/13 00:32:35 gwk Exp $ */
d196 1
a196 1
		return 1;
d225 1
a225 1
			return 1;
d237 1
a237 1
			return 1;
d260 1
a260 1
				return 1;
d269 1
a269 1
			return 1;
d278 1
a278 1
			return 1;
@


1.7
log
@Change the value returned if the CPU fails to honor a request to
adjust frequency from 1 (EPERM) to EIO.
Suggested by and ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.6 2006/05/27 04:46:12 gwk Exp $ */
d283 2
a284 6
	/* Check if transition failed. */
	if (cfid != fid || cvid != vid) {
		printf("%s transition to fid: %d vid: %d failed.", __func__,
		    fid, vid);
		return (EIO);
	}
a285 1
	cpuspeed = cstate->state_table[i].freq;
@


1.6
log
@Teach powernow about setperf prioritys, add a setperf_prio to amd64.
ok uwe@@, "good" tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.5 2006/04/18 04:58:41 gwk Exp $ */
d287 1
a287 1
		return (0);
@


1.5
log
@Print a usefull diagnostic message if we fail to transition between states
like the K8 driver for i386.
Fix some indentation.
ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.4 2006/03/16 02:39:57 dlg Exp $ */
d70 1
d379 3
d411 1
@


1.4
log
@dont leak memory when we fail to find any valid states.

from gwk, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.4 2006/03/15 22:59:43 gwk Exp $ */
d66 2
a67 2
#define BIOS_START		0xe0000
#define	BIOS_LEN		0x20000
d283 5
a287 2
	if (cfid != fid || cvid != vid)
		return (1);
@


1.3
log
@display the possible speedstep values like we do on intel chips.

from gwk, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.3 2006/03/15 22:39:53 gwk Exp $ */
d404 1
d407 1
@


1.2
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.1 2006/03/08 03:33:21 uwe Exp $ */
d395 5
a399 6
			printf("%s: AMD %s available states ",
			    ci->ci_dev->dv_xname, techname);
			for(i= 0; i < cstate->n_states; i++) {
				state = &cstate->state_table[i];
				printf("%c%d", i==0 ? '(' : ',',
				    state->freq);
d401 1
a401 1
			printf(")\n");
@


1.1
log
@Patch from Gordon Klock to update AMD PowerNow K8 support on i386,
and to add amd64 K8 support from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.3 2005/11/26 11:22:12 tedu Exp $ */
d164 3
a166 1
int k8pnow_read_pending_wait(uint64_t * status) {
d168 2
a169 1
	while(i--) {
d303 1
a303 1
		/* 
d305 2
a306 2
	   	 * The maximum supported frequency is 5000MHz. 
		 */ 	   
@

