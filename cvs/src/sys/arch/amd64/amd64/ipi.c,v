head	1.16;
access;
symbols
	OPENBSD_6_2:1.16.0.8
	OPENBSD_6_2_BASE:1.16
	OPENBSD_6_1:1.16.0.10
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.6
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.4
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.11.0.10
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.8
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.4
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.2
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.10.0.8
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.6
	OPENBSD_5_0:1.10.0.4
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.2
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.8.0.10
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.6
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.8
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.4
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.2
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.7.0.4
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.2
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.5.0.4
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.2.0.4
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.1.0.6
	OPENBSD_3_8_BASE:1.1
	OPENBSD_3_7:1.1.0.4
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.2
	OPENBSD_3_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.16
date	2015.07.19.18.44.15;	author sf;	state Exp;
branches;
next	1.15;
commitid	Nd6OWMpsso6mg5mS;

1.15
date	2015.07.18.19.21.02;	author sf;	state Exp;
branches;
next	1.14;
commitid	fKIY1z4O2YV68kXY;

1.14
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.13;
commitid	p4LJxGKbi0BU2cG6;

1.13
date	2015.01.06.12.50.47;	author dlg;	state Exp;
branches;
next	1.12;
commitid	EAvvmUR28EGEqQFd;

1.12
date	2015.01.06.00.38.32;	author dlg;	state Exp;
branches;
next	1.11;
commitid	W3kfFzaKNOKHuHue;

1.11
date	2012.12.05.23.20.10;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2010.12.27.20.22.23;	author guenther;	state Exp;
branches;
next	1.9;

1.9
date	2010.12.27.19.51.27;	author guenther;	state Exp;
branches;
next	1.8;

1.8
date	2008.06.26.05.42.09;	author ray;	state Exp;
branches;
next	1.7;

1.7
date	2007.05.25.16.22.11;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2007.05.10.17.59.23;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2006.03.10.21.21.08;	author brad;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.10.21.11.08;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2006.03.10.21.09.22;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.25.20.48.18;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.25.11.03.27;	author art;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Make x86_send_ipi() return void

Nobody uses its return value. This fixes it returning an undefined
value since the previous commit.
@
text
@/*	$OpenBSD: ipi.c,v 1.15 2015/07/18 19:21:02 sf Exp $	*/
/*	$NetBSD: ipi.c,v 1.2 2003/03/01 13:05:37 fvdl Exp $	*/

/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by RedBack Networks Inc.
 *
 * Author: Bill Sommerfeld
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h> 
#include <sys/device.h>
#include <sys/systm.h>
 
#include <machine/intr.h>
#include <machine/atomic.h>
#include <machine/cpuvar.h>
#include <machine/i82489reg.h>
#include <machine/i82489var.h>

void
x86_send_ipi(struct cpu_info *ci, int ipimask)
{
	x86_atomic_setbits_u32(&ci->ci_ipis, ipimask);

	/* Don't send IPI to cpu which isn't (yet) running. */
	if (!(ci->ci_flags & CPUF_RUNNING))
		return;

	x86_ipi(LAPIC_IPI_VECTOR, ci->ci_apicid, LAPIC_DLMODE_FIXED);
}

int
x86_fast_ipi(struct cpu_info *ci, int ipi)
{
	if (!(ci->ci_flags & CPUF_RUNNING))
		return (ENOENT);

	x86_ipi(ipi, ci->ci_apicid, LAPIC_DLMODE_FIXED);

	return 0;
}

void
x86_broadcast_ipi(int ipimask)
{
	struct cpu_info *ci, *self = curcpu();
	int count = 0;
	CPU_INFO_ITERATOR cii;

	CPU_INFO_FOREACH(cii, ci) {
		if (ci == self)
			continue;
		if ((ci->ci_flags & CPUF_RUNNING) == 0)
			continue;
		x86_atomic_setbits_u32(&ci->ci_ipis, ipimask);
		count++;
	}
	if (!count)
		return;

	x86_ipi(LAPIC_IPI_VECTOR, LAPIC_DEST_ALLEXCL, LAPIC_DLMODE_FIXED);
}

void
x86_ipi_handler(void)
{
	extern struct evcount ipi_count;
	struct cpu_info *ci = curcpu();
	u_int32_t pending;
	int bit;
	int floor;

	floor = ci->ci_handled_intr_level;
	ci->ci_handled_intr_level = ci->ci_ilevel;

	pending = atomic_swap_uint(&ci->ci_ipis, 0);
	for (bit = 0; bit < X86_NIPI && pending; bit++) {
		if (pending & (1<<bit)) {
			pending &= ~(1<<bit);
			(*ipifunc[bit])(ci);
			ipi_count.ec_count++;
		}
	}

	ci->ci_handled_intr_level = floor;
}
@


1.15
log
@Make {x86,i82489,x2apic,i386}_ipi return void

They always returned 0

ok mlarkin@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipi.c,v 1.14 2015/03/14 03:38:46 jsg Exp $	*/
d45 1
a45 1
int
a47 2
	int ret;

d52 1
a52 1
		return ENOENT;
a54 2

	return ret;
@


1.14
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipi.c,v 1.13 2015/01/06 12:50:47 dlg Exp $	*/
d56 1
a56 7
	ret = x86_ipi(LAPIC_IPI_VECTOR, ci->ci_apicid, LAPIC_DLMODE_FIXED);
	if (ret != 0) {
		printf("ipi of %x from %s to %s failed\n",
		    ipimask,
		    curcpu()->ci_dev->dv_xname,
		    ci->ci_dev->dv_xname);
	}
d67 3
a69 1
	return (x86_ipi(ipi, ci->ci_apicid, LAPIC_DLMODE_FIXED));
@


1.13
log
@when we're entering an interrupt handler, record its ipl so splassert
can check if we're entering code we think should only be used from
lower ipls.

modelled a bit on how sparc64 does things.

with help from and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipi.c,v 1.12 2015/01/06 00:38:32 dlg Exp $	*/
a41 1
#include <machine/i82093var.h>
@


1.12
log
@implement atomic_swap_{uint,ulong,ptr) and some md variants. use these
to replace x86_atomic_testset_{u32,u64}.

help from guenther@@ kettenis@@
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipi.c,v 1.11 2012/12/05 23:20:10 deraadt Exp $	*/
d105 4
a110 1

d118 2
@


1.11
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ipi.c,v 1.10 2010/12/27 20:22:23 guenther Exp $	*/
d106 1
a106 1
	pending = x86_atomic_testset_u32(&ci->ci_ipis, 0);
@


1.10
log
@Correct x86_atomic_*_ul() to operate on 64bit integers, eliminate
x86_atomic_*_l(), and update the callers of all of those to use the
underlying x86_atomic_*_u32() functions that they were expecting anyway.
Whether the x86_atomic_*_ul() macros should be eliminated has been deferred.

ok kettenis@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipi.c,v 1.9 2010/12/27 19:51:27 guenther Exp $	*/
a33 2

#include <sys/cdefs.h>                  /* RCS ID & Copyright macro defns */
@


1.9
log
@Eliminate x86_multicast_ipi() as unused and broken (doesn't handle #cpu>32).
The i386 version was removed some time ago, so kill its declaration too.
ok tedu@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipi.c,v 1.8 2008/06/26 05:42:09 ray Exp $	*/
d53 1
a53 1
	x86_atomic_setbits_l(&ci->ci_ipis, ipimask);
d91 1
a91 1
		x86_atomic_setbits_l(&ci->ci_ipis, ipimask);
d108 1
a108 1
	pending = x86_atomic_testset_ul(&ci->ci_ipis, 0);
@


1.8
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipi.c,v 1.7 2007/05/25 16:22:11 art Exp $	*/
a97 17
}

void
x86_multicast_ipi(int cpumask, int ipimask)
{
	struct cpu_info *ci;
	CPU_INFO_ITERATOR cii;

	cpumask &= ~(1U << cpu_number());
	if (cpumask == 0)
		return;

	CPU_INFO_FOREACH(cii, ci) {
		if ((cpumask & (1U << ci->ci_cpuid)) == 0)
			continue;
		x86_send_ipi(ci, ipimask);
	}
@


1.7
log
@Change the old slow and complicated TLB shootdown code to new, fast and
simple. This is basically the same code as on i386 and basically the same
performance improvements.

This change also includes code to delay the freeing of ptps until they
have been properly shot.

in snaps for a week, no problems reported.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipi.c,v 1.6 2007/05/10 17:59:23 deraadt Exp $	*/
a20 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.6
log
@evcnt & friends were replaced by a proper interrupt counting mechanism 3 years ago; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: ipi.c,v 1.5 2006/03/10 21:21:08 brad Exp $	*/
d75 9
@


1.5
log
@- Wrap IPI sending in splclock(), since an interrupt at
  IPL_CLOCK or lower may cause IPIs.
- Make broadcast IPIs go through x86_ipi() as well, so that
  they wait for the APIC to be ready too.
- Introduce a function, i82489_icr_wait, which waits for
  LAPIC_DLSTAT_BUSY cleared, and use it where appropriate.
- Panic if lapic's busy too long and DIAGNOSTIC.

From NetBSD

Tested on a few amd64 MP systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipi.c,v 1.4 2006/03/10 21:11:08 mickey Exp $	*/
a127 1
			ci->ci_ipi_events[bit].ev_count++;
@


1.4
log
@oops; from otto
@
text
@d1 1
a1 1
/*	$OpenBSD: ipi.c,v 1.3 2006/03/10 21:09:22 mickey Exp $	*/
d78 1
a78 9
x86_self_ipi (int vector)
{
	i82489_writereg(LAPIC_ICRLO,
	    vector | LAPIC_DLMODE_FIXED | LAPIC_LVL_ASSERT | LAPIC_DEST_SELF);
}


void
x86_broadcast_ipi (int ipimask)
a81 1

d95 1
a95 3
	i82489_writereg(LAPIC_ICRLO,
	    LAPIC_IPI_VECTOR | LAPIC_DLMODE_FIXED | LAPIC_LVL_ASSERT |
	    LAPIC_DEST_ALLEXCL);
@


1.3
log
@provide a counter for ipis
@
text
@d1 1
a1 1
/*	$OpenBSD: ipi.c,v 1.2 2005/09/25 20:48:18 miod Exp $	*/
d129 1
a129 1
	extern struct evcount clk_count;
@


1.2
log
@Turn CPU_INFO_FOREACH into a real construct, like all queue(3) iterators,
instead of the contents of a for() loop. No functional change.
From the m88k SMP tree; ok art@@ deraadt@@

[complete diff this time]
@
text
@d1 1
a1 1
/*	$OpenBSD: ipi.c,v 1.1 2004/06/25 11:03:27 art Exp $	*/
d129 1
d141 1
@


1.1
log
@SMP support. Big parts from NetBSD, but with some really serious debugging
done by me, niklas and others. Especially wrt. NXE support.

Still needs some polishing, especially in dmesg messages, but we're now
building kernel faster than ever.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d93 1
a93 1
	for (CPU_INFO_FOREACH(cii, ci)) {
d119 1
a119 1
	for (CPU_INFO_FOREACH(cii, ci)) {
@

