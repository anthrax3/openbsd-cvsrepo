head	1.8;
access;
symbols
	OPENBSD_6_2:1.8.0.4
	OPENBSD_6_2_BASE:1.8
	OPENBSD_6_1:1.7.0.6
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.2
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.6.0.2
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.4
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.4.0.28
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.24
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.22
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.20
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.18
	OPENBSD_5_0:1.4.0.16
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.14
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.12
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.8
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.10
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.6
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.4
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.2
	OPENBSD_4_3_BASE:1.4;
locks; strict;
comment	@ * @;


1.8
date	2017.09.08.05.36.51;	author deraadt;	state Exp;
branches;
next	1.7;
commitid	uRv5pa9QDlZaYgwD;

1.7
date	2016.04.14.07.00.24;	author mlarkin;	state Exp;
branches;
next	1.6;
commitid	81lumGcTTM2QQ8It;

1.6
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.5;
commitid	p4LJxGKbi0BU2cG6;

1.5
date	2014.03.29.18.09.28;	author guenther;	state Exp;
branches;
next	1.4;

1.4
date	2007.10.24.17.56.56;	author mikeb;	state Exp;
branches;
next	1.3;

1.3
date	2007.10.24.06.30.21;	author mikeb;	state Exp;
branches;
next	1.2;

1.2
date	2007.10.17.02.30.26;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2007.09.12.18.18.27;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.8
log
@If you use sys/param.h, you don't need sys/types.h
@
text
@/*	$OpenBSD: pctr.c,v 1.7 2016/04/14 07:00:24 mlarkin Exp $	*/

/*
 * Copyright (c) 2007 Mike Belopuhov
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Pentium performance counter driver for OpenBSD.
 * Copyright 1996 David Mazieres <dm@@lcs.mit.edu>.
 *
 * Modification and redistribution in source and binary forms is
 * permitted provided that due credit is given to the author and the
 * OpenBSD project by leaving this copyright notice intact.
 */

#include <sys/param.h>
#include <sys/errno.h>
#include <sys/fcntl.h>
#include <sys/ioccom.h>
#include <sys/systm.h>

#include <machine/pctr.h>
#include <machine/cpu.h>
#include <machine/specialreg.h>

#define PCTR_AMD_NUM	PCTR_NUM
#define PCTR_INTEL_NUM	2		/* Intel supports only 2 counters */
#define PCTR_INTEL_VERSION_MASK 0xff

#define usetsc		(cpu_feature & CPUID_TSC)
#define usepctr		((pctr_isamd && ((cpu_id >> 8) & 15) >= 6) || \
			    (pctr_isintel && \
			    (pctr_intel_cap & PCTR_INTEL_VERSION_MASK) >= 1))

int			pctr_isamd;
int			pctr_isintel;
uint32_t		pctr_intel_cap;

static void		pctrrd(struct pctrst *);
static int		pctrsel(int, u_int32_t, u_int32_t);

static void
pctrrd(struct pctrst *st)
{
	int i, num, reg;

	num = pctr_isamd ? PCTR_AMD_NUM : PCTR_INTEL_NUM;
	reg = pctr_isamd ? MSR_K7_EVNTSEL0 : MSR_EVNTSEL0;
	for (i = 0; i < num; i++)
		st->pctr_fn[i] = rdmsr(reg + i);
	__asm volatile("cli");
	st->pctr_tsc = rdtsc();
	for (i = 0; i < num; i++)
		st->pctr_hwc[i] = rdpmc(i);
	__asm volatile("sti");
}

void
pctrattach(int num)
{
	uint32_t dummy;

	if (num > 1)
		return;

	pctr_isamd = (strcmp(cpu_vendor, "AuthenticAMD") == 0);
	if (!pctr_isamd) {
		pctr_isintel = (strcmp(cpu_vendor, "GenuineIntel") == 0);
		CPUID(0xa, pctr_intel_cap, dummy, dummy, dummy);
	}

	if (usepctr) {
		/* Enable RDTSC and RDPMC instructions from user-level. */
		__asm volatile("movq %%cr4,%%rax\n"
				 "\tandq %0,%%rax\n"
				 "\torq %1,%%rax\n"
				 "\tmovq %%rax,%%cr4"
				 :: "i" (~CR4_TSD), "i" (CR4_PCE) : "rax");
	} else if (usetsc) {
		/* Enable RDTSC instruction from user-level. */
		__asm volatile("movq %%cr4,%%rax\n"
				 "\tandq %0,%%rax\n"
				 "\tmovq %%rax,%%cr4"
				 :: "i" (~CR4_TSD) : "rax");
	}
}

int
pctropen(dev_t dev, int oflags, int devtype, struct proc *p)
{

	if (minor(dev))
		return (ENXIO);
	return (0);
}

int
pctrclose(dev_t dev, int oflags, int devtype, struct proc *p)
{

	return (0);
}

static int
pctrsel(int fflag, u_int32_t cmd, u_int32_t fn)
{
	int msrsel, msrval;

	cmd -= PCIOCS0;
	if (pctr_isamd) {
		if (cmd > PCTR_AMD_NUM-1)
			return (EINVAL);
		msrsel = MSR_K7_EVNTSEL0 + cmd;
		msrval = MSR_K7_PERFCTR0 + cmd;
	} else {
		if (cmd > PCTR_INTEL_NUM-1)
			return (EINVAL);
		msrsel = MSR_EVNTSEL0 + cmd;
		msrval = MSR_PERFCTR0 + cmd;
	}

	if (!(fflag & FWRITE))
		return (EPERM);
	if (fn & 0x380000)
		return (EINVAL);

	wrmsr(msrval, 0);
	wrmsr(msrsel, fn);
	wrmsr(msrval, 0);

	return (0);
}

int
pctrioctl(dev_t dev, u_long cmd, caddr_t data, int fflag, struct proc *p)
{
	switch (cmd) {
	case PCIOCRD:
	{
		struct pctrst *st = (struct pctrst *)data;
		
		if (usepctr)
			pctrrd(st);
		else if (usetsc)
			st->pctr_tsc = rdtsc();
		return (0);
	}
	case PCIOCS0:
	case PCIOCS1:
	case PCIOCS2:
	case PCIOCS3:
		if (usepctr)
			return (pctrsel(fflag, cmd, *(u_int *)data));
		return (ENODEV);
	default:
		return (EINVAL);
	}
}
@


1.7
log
@
Use cpuid function 0xa to determine presence of general purpose
architectural performance counters, instead of cpu family/model values.

Fixes a panic seen on some hypervisors when pctr(1) is used when the
hypervisor masks out the counters.

Reported by Hiltjo Posthuma, thanks.

ok mikeb@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.6 2015/03/14 03:38:46 jsg Exp $	*/
a28 1
#include <sys/types.h>
@


1.6
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.5 2014/03/29 18:09:28 guenther Exp $	*/
d41 1
d44 3
a46 2
#define usepctr		((pctr_isamd || pctr_isintel) && \
			    ((cpu_id >> 8) & 15) >= 6)
d50 1
d74 1
d80 1
a80 1
	if (!pctr_isamd)
d82 2
@


1.5
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.4 2007/10/24 17:56:56 mikeb Exp $	*/
a34 1
#include <machine/psl.h>
@


1.4
log
@Remove idle loop counter.

ok art deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.3 2007/10/24 06:30:21 mikeb Exp $	*/
d62 1
a62 1
	__asm __volatile("cli");
d66 1
a66 1
	__asm __volatile("sti");
d82 1
a82 1
		__asm __volatile("movq %%cr4,%%rax\n"
d89 1
a89 1
		__asm __volatile("movq %%cr4,%%rax\n"
@


1.3
log
@Don't spam the dmesg.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.2 2007/10/17 02:30:26 deraadt Exp $	*/
a46 2
u_int64_t		pctr_idlcnt;	/* Gets incremented in locore.S */

a153 1
		st->pctr_idl = pctr_idlcnt;
@


1.2
log
@replacement for the pctr codebase that can handle amd64 processors as
well (in fact, all 4 combinations of codebase and processor) written by
Mike Belopuhov and Aleksey Lomovtsev
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.1 2007/09/12 18:18:27 deraadt Exp $	*/
a88 1
		printf("pctr: user-level performance counters enabled\n");
a94 1
		printf("pctr: user-level cycle counter enabled\n");
@


1.1
log
@port of i386 pctr code to amd64; Mike Belopuhov
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a37 1
#include <machine/cpufunc.h>
d40 6
a45 2
/* Check for Model Specific Registers and RDMSR/WRMSR support */
#define usepctr		(cpu_feature & CPUID_MSR)
d53 1
a61 1

a63 3

	reg = pctr_isamd ? MSR_K7_PERFCTR0 : MSR_PERFCTR0;

a64 1

a65 1

d67 1
a67 3
		st->pctr_hwc[i] = rdmsr(reg + i);
		/*st->pctr_hwc[i] = rdpmc(i);*/

a80 2
	if (!pctr_isintel && !pctr_isamd)
		return;
a81 1
	/* Enable RDTSC and RDPMC instructions from user-level. */
d83 1
d90 7
d116 1
a116 1
int
d147 1
a147 1
pctrioctl(dev_t dev, u_int64_t cmd, caddr_t data, int fflag, struct proc *p)
a148 1

d156 2
d166 1
a166 1
			return (pctrsel(fflag, cmd, *(u_int32_t *)data));
@

