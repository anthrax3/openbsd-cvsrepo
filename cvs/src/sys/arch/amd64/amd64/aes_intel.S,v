head	1.9;
access;
symbols
	OPENBSD_6_2_BASE:1.9
	OPENBSD_6_1:1.9.0.18
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.14
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.10
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.12
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.4
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.8
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.6
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.2
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.2.0.2
	OPENBSD_4_8_BASE:1.2;
locks; strict;
comment	@# @;


1.9
date	2013.03.26.15.47.01;	author jsing;	state Exp;
branches;
next	1.8;

1.8
date	2012.12.09.23.14.28;	author mikeb;	state Exp;
branches;
next	1.7;

1.7
date	2012.12.09.23.11.13;	author mikeb;	state Exp;
branches;
next	1.6;

1.6
date	2012.12.09.22.47.29;	author mikeb;	state Exp;
branches;
next	1.5;

1.5
date	2011.08.17.17.00.35;	author mikeb;	state Exp;
branches;
next	1.4;

1.4
date	2010.11.15.14.48.17;	author mikeb;	state Exp;
branches;
next	1.3;

1.3
date	2010.11.10.17.05.39;	author mikeb;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.22.12.47.40;	author thib;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.29.21.34.11;	author thib;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Add AES-XTS support to the aesni crypto driver. This allows softraid(4)
to benefit from the AES-NI instructions found on newer Intel CPUs.

ok mikeb@@
@
text
@/*	$OpenBSD: aes_intel.S,v 1.8 2012/12/09 23:14:28 mikeb Exp $	*/

/*
 * Implement AES algorithm in Intel AES-NI instructions.
 *
 * The white paper of AES-NI instructions can be downloaded from:
 *   http://softwarecommunity.intel.com/isn/downloads/intelavx/AES-Instructions-Set_WP.pdf
 *
 * Copyright (C) 2008-2010, Intel Corporation
 *    Author: Huang Ying <ying.huang@@intel.com>
 *            Vinodh Gopal <vinodh.gopal@@intel.com>
 *            Kahraman Akdemir
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following
 * conditions are met:
 *
 * - Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 *
 * - Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the
 *   distribution.
 *
 * - Neither the name of Intel Corporation nor the names of its
 *   contributors may be used to endorse or promote products
 *   derived from this software without specific prior written
 *   permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Changes to the original source code released by Intel:
 *
 * - assembler macros were converted to the actual instructions;
 * - aesni_ctr_enc was changed to be RFC 3686 compliant;
 * - aes-gcm mode added;
 * - aes-xts implementation added;
 *
 * Copyright (c) 2010,2011 Mike Belopuhov
 * Copyright (c) 2013 Joel Sing <jsing@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <machine/param.h>
#include <machine/asm.h>

#define STATE1		%xmm0
#define STATE2		%xmm4
#define STATE3		%xmm5
#define STATE4		%xmm6
#define STATE		STATE1
#define IN1		%xmm1
#define IN2		%xmm7
#define IN3		%xmm8
#define IN4		%xmm9
#define IN		IN1
#define KEY		%xmm2
#define IV		%xmm3
#define BSWAP_MASK	%xmm10
#define CTR		%xmm11
#define INC		%xmm12

#define KEYP		%rdi
#define OUTP		%rsi
#define INP		%rdx
#define LEN		%rcx
#define HSTATE		%rcx
#define IVP		%r8
#define ICBP		%r8
#define KLEN		%r9d
#define T1		%r10
#define TKEYP		T1
#define T2		%r11
#define TCTR_LOW	T2

	.data
.align 16
.Lbswap_mask:
	.byte 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0

	.text

_key_expansion_128:
_key_expansion_256a:
	pshufd	$0b11111111,%xmm1,%xmm1
	shufps	$0b00010000,%xmm0,%xmm4
	pxor	%xmm4,%xmm0
	shufps	$0b10001100,%xmm0,%xmm4
	pxor	%xmm4,%xmm0
	pxor	%xmm1,%xmm0
	movaps	%xmm0,(%rcx)
	add	$0x10,%rcx
	ret

_key_expansion_192a:
	pshufd	$0b01010101,%xmm1,%xmm1
	shufps	$0b00010000,%xmm0,%xmm4
	pxor	%xmm4,%xmm0
	shufps	$0b10001100,%xmm0,%xmm4
	pxor	%xmm4,%xmm0
	pxor	%xmm1,%xmm0

	movaps	%xmm2,%xmm5
	movaps	%xmm2,%xmm6
	pslldq	$4,%xmm5
	pshufd	$0b11111111,%xmm0,%xmm3
	pxor	%xmm3,%xmm2
	pxor	%xmm5,%xmm2

	movaps	%xmm0,%xmm1
	shufps	$0b01000100,%xmm0,%xmm6
	movaps	%xmm6,(%rcx)
	shufps	$0b01001110,%xmm2,%xmm1
	movaps	%xmm1,16(%rcx)
	add	$0x20,%rcx
	ret

_key_expansion_192b:
	pshufd	$0b01010101,%xmm1,%xmm1
	shufps	$0b00010000,%xmm0,%xmm4
	pxor	%xmm4,%xmm0
	shufps	$0b10001100,%xmm0,%xmm4
	pxor	%xmm4,%xmm0
	pxor	%xmm1,%xmm0

	movaps	%xmm2,%xmm5
	pslldq	$4,%xmm5
	pshufd	$0b11111111,%xmm0,%xmm3
	pxor	%xmm3,%xmm2
	pxor	%xmm5,%xmm2

	movaps	%xmm0,(%rcx)
	add	$0x10,%rcx
	ret

_key_expansion_256b:
	pshufd	$0b10101010,%xmm1,%xmm1
	shufps	$0b00010000,%xmm2,%xmm4
	pxor	%xmm4,%xmm2
	shufps	$0b10001100,%xmm2,%xmm4
	pxor	%xmm4,%xmm2
	pxor	%xmm1,%xmm2
	movaps	%xmm2,(%rcx)
	add	$0x10,%rcx
	ret

/*
 * void aesni_set_key(struct aesni_session *ses, uint8_t *key, size_t len)
 */
ENTRY(aesni_set_key)
	movups	(%rsi),%xmm0		# user key (first 16 bytes)
	movaps	%xmm0,(%rdi)
	lea	0x10(%rdi),%rcx		# key addr
	movl	%edx,480(%rdi)
	pxor	%xmm4,%xmm4		# xmm4 is assumed 0 in _key_expansion_x
	cmp	$24,%dl
	jb	2f
	je	1f
	movups	0x10(%rsi),%xmm2	# other user key
	movaps	%xmm2,(%rcx)
	add	$0x10,%rcx
	aeskeygenassist $0x1,%xmm2,%xmm1	# round 1
	call	_key_expansion_256a
	aeskeygenassist $0x1,%xmm0,%xmm1
	call	_key_expansion_256b
	aeskeygenassist $0x2,%xmm2,%xmm1	# round 2
	call	_key_expansion_256a
	aeskeygenassist $0x2,%xmm0,%xmm1
	call	_key_expansion_256b
	aeskeygenassist $0x4,%xmm2,%xmm1	# round 3
	call	_key_expansion_256a
	aeskeygenassist $0x4,%xmm0,%xmm1
	call	_key_expansion_256b
	aeskeygenassist $0x8,%xmm2,%xmm1	# round 4
	call	_key_expansion_256a
	aeskeygenassist $0x8,%xmm0,%xmm1
	call	_key_expansion_256b
	aeskeygenassist $0x10,%xmm2,%xmm1	# round 5
	call	_key_expansion_256a
	aeskeygenassist $0x10,%xmm0,%xmm1
	call	_key_expansion_256b
	aeskeygenassist $0x20,%xmm2,%xmm1	# round 6
	call	_key_expansion_256a
	aeskeygenassist $0x20,%xmm0,%xmm1
	call	_key_expansion_256b
	aeskeygenassist $0x40,%xmm2,%xmm1	# round 7
	call	_key_expansion_256a
	jmp	3f
1:	/* 192 bit key */
	movq	0x10(%rsi),%xmm2	# other user key
	aeskeygenassist $0x1,%xmm2,%xmm1	# round 1
	call	_key_expansion_192a
	aeskeygenassist $0x2,%xmm2,%xmm1	# round 2
	call	_key_expansion_192b
	aeskeygenassist $0x4,%xmm2,%xmm1	# round 3
	call	_key_expansion_192a
	aeskeygenassist $0x8,%xmm2,%xmm1	# round 4
	call	_key_expansion_192b
	aeskeygenassist $0x10,%xmm2,%xmm1	# round 5
	call	_key_expansion_192a
	aeskeygenassist $0x20,%xmm2,%xmm1	# round 6
	call	_key_expansion_192b
	aeskeygenassist $0x40,%xmm2,%xmm1	# round 7
	call	_key_expansion_192a
	aeskeygenassist $0x80,%xmm2,%xmm1	# round 8
	call	_key_expansion_192b
	jmp	3f
2:	/* 128 bit key */
	aeskeygenassist $0x1,%xmm0,%xmm1	# round 1
	call	_key_expansion_128
	aeskeygenassist $0x2,%xmm0,%xmm1	# round 2
	call	_key_expansion_128
	aeskeygenassist $0x4,%xmm0,%xmm1	# round 3
	call	_key_expansion_128
	aeskeygenassist $0x8,%xmm0,%xmm1	# round 4
	call	_key_expansion_128
	aeskeygenassist $0x10,%xmm0,%xmm1	# round 5
	call	_key_expansion_128
	aeskeygenassist $0x20,%xmm0,%xmm1	# round 6
	call	_key_expansion_128
	aeskeygenassist $0x40,%xmm0,%xmm1	# round 7
	call	_key_expansion_128
	aeskeygenassist $0x80,%xmm0,%xmm1	# round 8
	call	_key_expansion_128
	aeskeygenassist $0x1b,%xmm0,%xmm1	# round 9
	call	_key_expansion_128
	aeskeygenassist $0x36,%xmm0,%xmm1	# round 10
	call	_key_expansion_128
3:
	sub	$0x10,%rcx
	movaps	(%rdi),%xmm0
	movaps	(%rcx),%xmm1
	movaps	%xmm0,240(%rcx)
	movaps	%xmm1,240(%rdi)
	add	$0x10,%rdi
	lea	240-16(%rcx),%rsi
.align 4
4:
	movaps	(%rdi),%xmm0
	aesimc	%xmm0,%xmm1
	movaps	%xmm1,(%rsi)
	add	$0x10,%rdi
	sub	$0x10,%rsi
	cmp	%rcx,%rdi
	jb	4b
	ret

/*
 * void aesni_enc(struct aesni_session *ses, uint8_t *dst, uint8_t *src)
 */
ENTRY(aesni_enc)
	movl	480(KEYP),KLEN		# key length
	movups	(INP),STATE		# input
	call	_aesni_enc1
	movups	STATE,(OUTP)		# output
	ret

/*
 * _aesni_enc1:		internal ABI
 * input:
 *	KEYP:		key struct pointer
 *	KLEN:		round count
 *	STATE:		initial state (input)
 * output:
 *	STATE:		final state (output)
 * changed:
 *	KEY
 *	TKEYP (T1)
 */
_aesni_enc1:
	movaps	(KEYP),KEY		# key
	mov	KEYP,TKEYP
	pxor	KEY,STATE		# round 0
	add	$0x30,TKEYP
	cmp	$24,KLEN
	jb	2f
	lea	0x20(TKEYP),TKEYP
	je	1f
	add	$0x20,TKEYP
	movaps	-0x60(TKEYP),KEY
	aesenc	KEY,STATE
	movaps	-0x50(TKEYP),KEY
	aesenc	KEY,STATE
.align 4
1:	/* 192 bit key */
	movaps	-0x40(TKEYP),KEY
	aesenc	KEY,STATE
	movaps	-0x30(TKEYP),KEY
	aesenc	KEY,STATE
.align 4
2:	/* 128 bit key */
	movaps	-0x20(TKEYP),KEY
	aesenc	KEY,STATE
	movaps	-0x10(TKEYP),KEY
	aesenc	KEY,STATE
	movaps	(TKEYP),KEY
	aesenc	KEY,STATE
	movaps	0x10(TKEYP),KEY
	aesenc	KEY,STATE
	movaps	0x20(TKEYP),KEY
	aesenc	KEY,STATE
	movaps	0x30(TKEYP),KEY
	aesenc	KEY,STATE
	movaps	0x40(TKEYP),KEY
	aesenc	KEY,STATE
	movaps	0x50(TKEYP),KEY
	aesenc	KEY,STATE
	movaps	0x60(TKEYP),KEY
	aesenc	KEY,STATE
	movaps	0x70(TKEYP),KEY
	aesenclast KEY,STATE
	ret

/*
 * _aesni_enc4:	internal ABI
 * input:
 *	KEYP:		key struct pointer
 *	KLEN:		round count
 *	STATE1:		initial state (input)
 *	STATE2
 *	STATE3
 *	STATE4
 * output:
 *	STATE1:		final state (output)
 *	STATE2
 *	STATE3
 *	STATE4
 * changed:
 *	KEY
 *	TKEYP (T1)
 */
_aesni_enc4:
	movaps	(KEYP),KEY		# key
	mov	KEYP,TKEYP
	pxor	KEY,STATE1		# round 0
	pxor	KEY,STATE2
	pxor	KEY,STATE3
	pxor	KEY,STATE4
	add	$0x30,TKEYP
	cmp	$24,KLEN
	jb	2f
	lea	0x20(TKEYP),TKEYP
	je	1f
	add	$0x20,TKEYP
	movaps	-0x60(TKEYP),KEY
	aesenc	KEY,STATE1
	aesenc	KEY,STATE2
	aesenc	KEY,STATE3
	aesenc	KEY,STATE4
	movaps	-0x50(TKEYP),KEY
	aesenc	KEY,STATE1
	aesenc	KEY,STATE2
	aesenc	KEY,STATE3
	aesenc	KEY,STATE4
#.align 4
1:	/* 192 bit key */
	movaps	-0x40(TKEYP),KEY
	aesenc	KEY,STATE1
	aesenc	KEY,STATE2
	aesenc	KEY,STATE3
	aesenc	KEY,STATE4
	movaps	-0x30(TKEYP),KEY
	aesenc	KEY,STATE1
	aesenc	KEY,STATE2
	aesenc	KEY,STATE3
	aesenc	KEY,STATE4
#.align 4
2:	/* 128 bit key */
	movaps	-0x20(TKEYP),KEY
	aesenc	KEY,STATE1
	aesenc	KEY,STATE2
	aesenc	KEY,STATE3
	aesenc	KEY,STATE4
	movaps	-0x10(TKEYP),KEY
	aesenc	KEY,STATE1
	aesenc	KEY,STATE2
	aesenc	KEY,STATE3
	aesenc	KEY,STATE4
	movaps	(TKEYP),KEY
	aesenc	KEY,STATE1
	aesenc	KEY,STATE2
	aesenc	KEY,STATE3
	aesenc	KEY,STATE4
	movaps	0x10(TKEYP),KEY
	aesenc	KEY,STATE1
	aesenc	KEY,STATE2
	aesenc	KEY,STATE3
	aesenc	KEY,STATE4
	movaps	0x20(TKEYP),KEY
	aesenc	KEY,STATE1
	aesenc	KEY,STATE2
	aesenc	KEY,STATE3
	aesenc	KEY,STATE4
	movaps	0x30(TKEYP),KEY
	aesenc	KEY,STATE1
	aesenc	KEY,STATE2
	aesenc	KEY,STATE3
	aesenc	KEY,STATE4
	movaps	0x40(TKEYP),KEY
	aesenc	KEY,STATE1
	aesenc	KEY,STATE2
	aesenc	KEY,STATE3
	aesenc	KEY,STATE4
	movaps	0x50(TKEYP),KEY
	aesenc	KEY,STATE1
	aesenc	KEY,STATE2
	aesenc	KEY,STATE3
	aesenc	KEY,STATE4
	movaps	0x60(TKEYP),KEY
	aesenc	KEY,STATE1
	aesenc	KEY,STATE2
	aesenc	KEY,STATE3
	aesenc	KEY,STATE4
	movaps	0x70(TKEYP),KEY
	aesenclast KEY,STATE1		# last round
	aesenclast KEY,STATE2
	aesenclast KEY,STATE3
	aesenclast KEY,STATE4
	ret

/*
 * void aesni_dec(struct aesni_session *ses, uint8_t *dst, uint8_t *src)
 */
ENTRY(aesni_dec)
	mov	480(KEYP),KLEN		# key length
	add	$240,KEYP
	movups	(INP),STATE		# input
	call	_aesni_dec1
	movups	STATE,(OUTP)		# output
	ret

/*
 * _aesni_dec1:		internal ABI
 * input:
 *	KEYP:		key struct pointer
 *	KLEN:		key length
 *	STATE:		initial state (input)
 * output:
 *	STATE:		final state (output)
 * changed:
 *	KEY
 *	TKEYP (T1)
 */
_aesni_dec1:
	movaps	(KEYP),KEY		# key
	mov	KEYP,TKEYP
	pxor	KEY,STATE		# round 0
	add	$0x30,TKEYP
	cmp	$24,KLEN
	jb	2f
	lea	0x20(TKEYP),TKEYP
	je	1f
	add	$0x20,TKEYP
	movaps	-0x60(TKEYP),KEY
	aesdec	KEY,STATE
	movaps	-0x50(TKEYP),KEY
	aesdec	KEY,STATE
.align 4
1:	/* 192 bit key */
	movaps	-0x40(TKEYP),KEY
	aesdec	KEY,STATE
	movaps	-0x30(TKEYP),KEY
	aesdec	KEY,STATE
.align 4
2:	/* 128 bit key */
	movaps	-0x20(TKEYP),KEY
	aesdec	KEY,STATE
	movaps	-0x10(TKEYP),KEY
	aesdec	KEY,STATE
	movaps	(TKEYP),KEY
	aesdec	KEY,STATE
	movaps	0x10(TKEYP),KEY
	aesdec	KEY,STATE
	movaps	0x20(TKEYP),KEY
	aesdec	KEY,STATE
	movaps	0x30(TKEYP),KEY
	aesdec	KEY,STATE
	movaps	0x40(TKEYP),KEY
	aesdec	KEY,STATE
	movaps	0x50(TKEYP),KEY
	aesdec	KEY,STATE
	movaps	0x60(TKEYP),KEY
	aesdec	KEY,STATE
	movaps	0x70(TKEYP),KEY
	aesdeclast KEY,STATE
	ret

/*
 * _aesni_dec4:	internal ABI
 * input:
 *	KEYP:		key struct pointer
 *	KLEN:		key length
 *	STATE1:		initial state (input)
 *	STATE2
 *	STATE3
 *	STATE4
 * output:
 *	STATE1:		final state (output)
 *	STATE2
 *	STATE3
 *	STATE4
 * changed:
 *	KEY
 *	TKEYP (T1)
 */
_aesni_dec4:
	movaps	(KEYP),KEY		# key
	mov	KEYP,TKEYP
	pxor	KEY,STATE1		# round 0
	pxor	KEY,STATE2
	pxor	KEY,STATE3
	pxor	KEY,STATE4
	add	$0x30,TKEYP
	cmp	$24,KLEN
	jb	2f
	lea	0x20(TKEYP),TKEYP
	je	1f
	add 	$0x20,TKEYP
	movaps	-0x60(TKEYP),KEY
	aesdec	KEY,STATE1
	aesdec	KEY,STATE2
	aesdec	KEY,STATE3
	aesdec	KEY,STATE4
	movaps	-0x50(TKEYP),KEY
	aesdec	KEY,STATE1
	aesdec	KEY,STATE2
	aesdec	KEY,STATE3
	aesdec	KEY,STATE4
.align 4
1:	/* 192 bit key */
	movaps	-0x40(TKEYP),KEY
	aesdec	KEY,STATE1
	aesdec	KEY,STATE2
	aesdec	KEY,STATE3
	aesdec	KEY,STATE4
	movaps	-0x30(TKEYP),KEY
	aesdec	KEY,STATE1
	aesdec	KEY,STATE2
	aesdec	KEY,STATE3
	aesdec	KEY,STATE4
.align 4
2:	/* 128 bit key */
	movaps	-0x20(TKEYP),KEY
	aesdec	KEY,STATE1
	aesdec	KEY,STATE2
	aesdec	KEY,STATE3
	aesdec	KEY,STATE4
	movaps	-0x10(TKEYP),KEY
	aesdec	KEY,STATE1
	aesdec	KEY,STATE2
	aesdec	KEY,STATE3
	aesdec	KEY,STATE4
	movaps	(TKEYP),KEY
	aesdec	KEY,STATE1
	aesdec	KEY,STATE2
	aesdec	KEY,STATE3
	aesdec	KEY,STATE4
	movaps	0x10(TKEYP),KEY
	aesdec	KEY,STATE1
	aesdec	KEY,STATE2
	aesdec	KEY,STATE3
	aesdec	KEY,STATE4
	movaps	0x20(TKEYP),KEY
	aesdec	KEY,STATE1
	aesdec	KEY,STATE2
	aesdec	KEY,STATE3
	aesdec	KEY,STATE4
	movaps	0x30(TKEYP),KEY
	aesdec	KEY,STATE1
	aesdec	KEY,STATE2
	aesdec	KEY,STATE3
	aesdec	KEY,STATE4
	movaps	0x40(TKEYP),KEY
	aesdec	KEY,STATE1
	aesdec	KEY,STATE2
	aesdec	KEY,STATE3
	aesdec	KEY,STATE4
	movaps	0x50(TKEYP),KEY
	aesdec	KEY,STATE1
	aesdec	KEY,STATE2
	aesdec	KEY,STATE3
	aesdec	KEY,STATE4
	movaps	0x60(TKEYP),KEY
	aesdec	KEY,STATE1
	aesdec	KEY,STATE2
	aesdec	KEY,STATE3
	aesdec	KEY,STATE4
	movaps	0x70(TKEYP),KEY
	aesdeclast KEY,STATE1		# last round
	aesdeclast KEY,STATE2
	aesdeclast KEY,STATE3
	aesdeclast KEY,STATE4
	ret

#if 0
/*
 * void aesni_ecb_enc(struct aesni_session *ses, uint8_t *dst, uint8_t *src,
 *     size_t len)
 */
ENTRY(aesni_ecb_enc)
	test	LEN,LEN			# check length
	jz	3f
	mov	480(KEYP),KLEN
	cmp	$16,LEN
	jb	3f
	cmp	$64,LEN
	jb	2f
.align 4
1:
	movups	(INP),STATE1
	movups	0x10(INP),STATE2
	movups	0x20(INP),STATE3
	movups	0x30(INP),STATE4
	call	_aesni_enc4
	movups	STATE1,(OUTP)
	movups	STATE2,0x10(OUTP)
	movups	STATE3,0x20(OUTP)
	movups	STATE4,0x30(OUTP)
	sub	$64,LEN
	add	$64,INP
	add	$64,OUTP
	cmp	$64,LEN
	jge	1b
	cmp	$16,LEN
	jb	3f
.align 4
2:
	movups	(INP),STATE1
	call	_aesni_enc1
	movups	STATE1,(OUTP)
	sub	$16,LEN
	add	$16,INP
	add	$16,OUTP
	cmp	$16,LEN
	jge	2b
3:
	ret

/*
 * void aesni_ecb_dec(struct aesni_session *ses, uint8_t *dst, uint8_t *src,
 *     size_t len);
 */
ENTRY(aesni_ecb_dec)
	test	LEN,LEN
	jz	3f
	mov	480(KEYP),KLEN
	add	$240,KEYP
	cmp	$16,LEN
	jb	3f
	cmp	$64,LEN
	jb	2f
.align 4
1:
	movups	(INP),STATE1
	movups	0x10(INP),STATE2
	movups	0x20(INP),STATE3
	movups	0x30(INP),STATE4
	call	_aesni_dec4
	movups	STATE1,(OUTP)
	movups	STATE2,0x10(OUTP)
	movups	STATE3,0x20(OUTP)
	movups	STATE4,0x30(OUTP)
	sub	$64,LEN
	add	$64,INP
	add	$64,OUTP
	cmp	$64,LEN
	jge	1b
	cmp	$16,LEN
	jb	3f
.align 4
2:
	movups	(INP),STATE1
	call	_aesni_dec1
	movups	STATE1,(OUTP)
	sub	$16,LEN
	add	$16,INP
	add	$16,OUTP
	cmp	$16,LEN
	jge	2b
3:
	ret
#endif

/*
 * void aesni_cbc_enc(struct aesni_session *ses, uint8_t *dst, uint8_t *src,
 *     size_t len, uint8_t *iv)
 */
ENTRY(aesni_cbc_enc)
	cmp	$16,LEN
	jb	2f
	mov	480(KEYP),KLEN
	movups	(IVP),STATE	# load iv as initial state
.align 4
1:
	movups	(INP),IN	# load input
	pxor	IN,STATE
	call	_aesni_enc1
	movups	STATE,(OUTP)	# store output
	sub	$16,LEN
	add	$16,INP
	add	$16,OUTP
	cmp	$16,LEN
	jge	1b
	movups	STATE,(IVP)
2:
	ret

/*
 * void aesni_cbc_dec(struct aesni_session *ses, uint8_t *dst, uint8_t *src,
 *     size_t len, uint8_t *iv)
 */
ENTRY(aesni_cbc_dec)
	cmp	$16,LEN
	jb	4f
	mov	480(KEYP),KLEN
	add	$240,KEYP
	movups	(IVP),IV
	cmp	$64,LEN
	jb	2f
.align 4
1:	/* pipeline 4 instructions when possible */
	movups	(INP),IN1
	movaps	IN1,STATE1
	movups	0x10(INP),IN2
	movaps	IN2,STATE2
	movups	0x20(INP),IN3
	movaps	IN3,STATE3
	movups	0x30(INP),IN4
	movaps	IN4,STATE4
	call	_aesni_dec4
	pxor	IV,STATE1
	pxor	IN1,STATE2
	pxor	IN2,STATE3
	pxor	IN3,STATE4
	movaps	IN4,IV
	movups	STATE1,(OUTP)
	movups	STATE2,0x10(OUTP)
	movups	STATE3,0x20(OUTP)
	movups	STATE4,0x30(OUTP)
	sub	$64,LEN
	add	$64,INP
	add	$64,OUTP
	cmp	$64,LEN
	jge	1b
	cmp	$16,LEN
	jb	3f
.align 4
2:
	movups	(INP),IN
	movaps	IN,STATE
	call	_aesni_dec1
	pxor	IV,STATE
	movups	STATE,(OUTP)
	movaps	IN,IV
	sub	$16,LEN
	add	$16,INP
	add	$16,OUTP
	cmp	$16,LEN
	jge	2b
3:
	movups	IV,(IVP)
4:
	ret

/*
 * _aesni_inc_init:	internal ABI
 *	setup registers used by _aesni_inc
 * input:
 *	ICB
 * output:
 *	CTR:		== CTR, in little endian
 *	IV:		== IV, in big endian
 *	TCTR_LOW:	== lower dword of CTR
 *	INC:		== 1, in little endian
 *	BSWAP_MASK	== endian swapping mask
 */
_aesni_inc_init:
	movdqa	CTR,IV
	pslldq	$8,IV
	movdqu	.Lbswap_mask,BSWAP_MASK
	pshufb	BSWAP_MASK,CTR
	mov	$1,TCTR_LOW
	movd	TCTR_LOW,INC
	movd	CTR,TCTR_LOW
	ret

/*
 * _aesni_inc:		internal ABI
 *	Increase IV by 1, IV is in big endian
 * input:
 *	IV
 *	CTR:		== IV, in little endian
 *	TCTR_LOW:	== lower dword of CTR
 *	INC:		== 1, in little endian
 *	BSWAP_MASK	== endian swapping mask
 * output:
 *	IV:		Increase by 1
 * changed:
 *	CTR:		== output IV, in little endian
 *	TCTR_LOW:	== lower dword of CTR
 */
_aesni_inc:
	paddq	INC,CTR
	add	$1,TCTR_LOW
	jnc	1f
	pslldq	$8,INC
	paddq	INC,CTR
	psrldq	$8,INC
1:
	movaps	CTR,IV
	pshufb	BSWAP_MASK,IV
	ret

/*
 * void aesni_ctr_enc(struct aesni_session *ses, uint8_t *dst, uint8_t *src,
 *     size_t len, uint8_t *icb)
 */
ENTRY(aesni_ctr_enc)
	cmp	$16,LEN
	jb	4f
	mov	480(KEYP),KLEN
	movdqu	(ICBP),CTR
	call	_aesni_inc_init
	cmp	$64,LEN
	jb	2f
.align 4
1:	/* pipeline 4 instructions when possible */
	call	_aesni_inc
	movaps	IV,STATE1
	movups	(INP),IN1
	call	_aesni_inc
	movaps	IV,STATE2
	movups	0x10(INP),IN2
	call	_aesni_inc
	movaps	IV,STATE3
	movups	0x20(INP),IN3
	call	_aesni_inc
	movaps	IV,STATE4
	movups	0x30(INP),IN4
	call	_aesni_enc4
	pxor	IN1,STATE1
	movups	STATE1,(OUTP)
	pxor	IN2,STATE2
	movups	STATE2,0x10(OUTP)
	pxor	IN3,STATE3
	movups	STATE3,0x20(OUTP)
	pxor	IN4,STATE4
	movups	STATE4,0x30(OUTP)
	sub	$64,LEN
	add	$64,INP
	add	$64,OUTP
	cmp	$64,LEN
	jge	1b
	cmp	$16,LEN
	jb	3f
.align 4
2:
	call	_aesni_inc
	movaps	IV,STATE
	movups	(INP),IN
	call	_aesni_enc1
	pxor	IN,STATE
	movups	STATE,(OUTP)
	sub	$16,LEN
	add	$16,INP
	add	$16,OUTP
	cmp	$16,LEN
	jge	2b
3:
	movq	IV,(IVP)
4:
	ret

_aesni_gmac_gfmul:
	movdqa	%xmm0,%xmm3
	pclmulqdq $0x00,%xmm1,%xmm3	# xmm3 holds a0*b0
	movdqa	%xmm0,%xmm4
	pclmulqdq $0x10,%xmm1,%xmm4	# xmm4 holds a0*b1
	movdqa	%xmm0,%xmm5
	pclmulqdq $0x01,%xmm1,%xmm5	# xmm5 holds a1*b0
	movdqa	%xmm0,%xmm6
	pclmulqdq $0x11,%xmm1,%xmm6	# xmm6 holds a1*b1

	pxor	%xmm5,%xmm4		# xmm4 holds a0*b1 + a1*b0
	movdqa	%xmm4,%xmm5
	psrldq	$8,%xmm4
	pslldq	$8,%xmm5
	pxor	%xmm5,%xmm3
	pxor	%xmm4,%xmm6

	/*
	 * <xmm6:xmm3> holds the result of the carry-less
	 * multiplication of xmm0 by xmm1
	 *
	 * shift the result by one bit position to the left
	 * cope for the fact that bits are reversed
	 */
	movdqa	%xmm3,%xmm7
	movdqa	%xmm6,%xmm8
	pslld	$1,%xmm3
	pslld	$1,%xmm6
	psrld	$31,%xmm7
	psrld	$31,%xmm8
	movdqa	%xmm7,%xmm9
	pslldq	$4,%xmm8
	pslldq	$4,%xmm7
	psrldq	$12,%xmm9
	por	%xmm7,%xmm3
	por	%xmm8,%xmm6
	por	%xmm9,%xmm6

	/* first phase of the reduction */
	movdqa	%xmm3,%xmm7
	movdqa	%xmm3,%xmm8
	movdqa	%xmm3,%xmm9
	pslld	$31,%xmm7		# packed right shifting << 31
	pslld	$30,%xmm8		# packed right shifting shift << 30
	pslld	$25,%xmm9		# packed right shifting shift << 25
	pxor	%xmm8,%xmm7		# xor the shifted versions
	pxor	%xmm9,%xmm7
	movdqa	%xmm7,%xmm8
	pslldq	$12,%xmm7
	psrldq	$4,%xmm8
	pxor	%xmm7,%xmm3

	/* second phase of the reduction */
	movdqa	%xmm3,%xmm2
	movdqa	%xmm3,%xmm4
	movdqa	%xmm3,%xmm5
	psrld	$1,%xmm2		# packed left shifting >> 1
	psrld	$2,%xmm4		# packed left shifting >> 2
	psrld	$7,%xmm5		# packed left shifting >> 7
	pxor	%xmm4,%xmm2		# xor the shifted versions
	pxor	%xmm5,%xmm2
	pxor	%xmm8,%xmm2
	pxor	%xmm2,%xmm3
	pxor	%xmm3,%xmm6		# the result is in xmm6
	ret

/*
 * void aesni_gmac_update(GHASH_CTX *ghash, uint8_t *src, size_t len)
 */
ENTRY(aesni_gmac_update)
	cmp	$16,%rdx
	jb	2f

	movdqu	.Lbswap_mask,BSWAP_MASK	# endianness swap mask

	movdqu	(%rdi),%xmm1		# hash subkey
	movdqu	32(%rdi),%xmm6		# initial state
	pshufb	BSWAP_MASK,%xmm1
	pshufb	BSWAP_MASK,%xmm6
1:
	movdqu	(%rsi),%xmm2
	pshufb	BSWAP_MASK,%xmm2
	movdqa	%xmm6,%xmm0
	pxor	%xmm2,%xmm0
	call	_aesni_gmac_gfmul

	sub	$16,%rdx
	add	$16,%rsi
	cmp	$16,%rdx
	jge	1b

	pshufb	BSWAP_MASK,%xmm6
	movdqu	%xmm6,16(%rdi)
	movdqu	%xmm6,32(%rdi)
2:
	ret

/*
 * void aesni_gmac_final(struct aesni_sess *ses, uint8_t *tag,
 *     uint8_t *icb, uint8_t *hashstate)
 */
ENTRY(aesni_gmac_final)
	movl	480(KEYP),KLEN		# key length
	movdqu	(INP),STATE		# icb
	call	_aesni_enc1
	movdqu	(HSTATE),IN
	pxor	IN,STATE
	movdqu	STATE,(OUTP)		# output
	ret

/*
 * void aesni_xts_enc(struct aesni_xts_ctx *xts, uint8_t *dst, uint8_t *src,
 *    size_t len, uint8_t *iv)
 */
ENTRY(aesni_xts_enc)
	cmp	$16,%rcx
	jb	2f

	call	_aesni_xts_tweak
	
	movl	480(KEYP),KLEN		# key length
1:
	movups	(%rdx),%xmm0		# src
	pxor	%xmm3,%xmm0		# xor block with tweak
	call	_aesni_enc1
	pxor	%xmm3,%xmm0		# xor block with tweak
	movups	%xmm0,(%rsi)		# dst

	call	_aesni_xts_tweak_exp

	add	$16,%rsi
	add	$16,%rdx
	sub	$16,%rcx
	cmp	$16,%rcx
	jge	1b
2:
	ret

/*
 * void aesni_xts_dec(struct aesni_xts_ctx *xts, uint8_t *dst, uint8_t *src,
 *    size_t len, uint8_t *iv)
 */
ENTRY(aesni_xts_dec)
	cmp	$16,%rcx
	jb	2f

	call	_aesni_xts_tweak

	movl	480(KEYP),KLEN		# key length
	add	$240,KEYP		# decryption key
1:
	movups	(%rdx),%xmm0		# src
	pxor	%xmm3,%xmm0		# xor block with tweak
	call	_aesni_dec1
	pxor	%xmm3,%xmm0		# xor block with tweak
	movups	%xmm0,(%rsi)		# dst

	call	_aesni_xts_tweak_exp
	
	add	$16,%rsi
	add	$16,%rdx
	sub	$16,%rcx
	cmp	$16,%rcx
	jge	1b
2:
	ret

/*
 * Prepare tweak as E_k2(IV). IV is specified as LE representation of a
 * 64-bit block number which we allow to be passed in directly. Since
 * we're on a 64-bit LE host the representation is already correct.
 *
 * xts is in %rdi, iv is in %r8 and we return the tweak in %xmm3.
 */
_aesni_xts_tweak:
	mov	(%r8),%r10
	movd	%r10,%xmm0		# Last 64-bits of IV are always zero.
	mov	KEYP,%r11
	lea	496(%rdi),KEYP
	movl	480(KEYP),KLEN
	call	_aesni_enc1
	movdqa	%xmm0,%xmm3
	mov	%r11,KEYP
	ret

/*
 * Exponentiate AES XTS tweak (in %xmm3).
 */
_aesni_xts_tweak_exp:
	pextrw	$7,%xmm3,%r10
	pextrw	$3,%xmm3,%r11
	psllq	$1,%xmm3		# Left shift.

	and	$0x8000,%r11		# Carry between quads.
	jz	1f
	mov	$1,%r11
	pxor	%xmm0,%xmm0
	pinsrw	$4,%r11,%xmm0
	por	%xmm0,%xmm3
1:
	and	$0x8000,%r10
	jz	2f
	pextrw	$0,%xmm3,%r11
	xor	$0x87,%r11		# AES XTS alpha - GF(2^128).
	pinsrw	$0,%r11,%xmm3
2:
	ret
@


1.8
log
@clarify that changes to this module were not done by intel
@
text
@d1 1
a1 1
/*	$OpenBSD: aes_intel.S,v 1.7 2012/12/09 23:11:13 mikeb Exp $	*/
d50 1
d53 1
d289 1
a289 1
 *	STATE:		finial state (output)
d348 1
a348 1
 *	STATE1:		finial state (output)
d463 1
a463 1
 *	STATE:		finial state (output)
d522 1
a522 1
 *	STATE1:		finial state (output)
d1006 98
@


1.7
log
@get rid of awkward label names and use simple forward/backward
notation;  no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: aes_intel.S,v 1.6 2012/12/09 22:47:29 mikeb Exp $	*/
d49 15
@


1.6
log
@whitespace cleanup that's been due a long time
@
text
@d1 1
a1 1
/*	$OpenBSD: aes_intel.S,v 1.5 2011/08/17 17:00:35 mikeb Exp $	*/
d164 2
a165 2
	jb	.Lenc_key128
	je	.Lenc_key192
d195 2
a196 2
	jmp	.Ldec_key
.Lenc_key192:
d214 2
a215 2
	jmp	.Ldec_key
.Lenc_key128:
d236 1
a236 1
.Ldec_key:
d245 1
a245 1
.Ldec_key_loop:
d252 1
a252 1
	jb	.Ldec_key_loop
d283 1
a283 1
	jb	.Lenc128
d285 1
a285 1
	je	.Lenc192
d292 1
a292 1
.Lenc192:
d298 1
a298 1
.Lenc128:
d348 1
a348 1
	jb	.L4enc128
d350 1
a350 1
	je	.L4enc192
d363 1
a363 1
.L4enc192:
d375 1
a375 1
.L4enc128:
d457 1
a457 1
	jb	.Ldec128
d459 1
a459 1
	je	.Ldec192
d466 1
a466 1
.Ldec192:
d472 1
a472 1
.Ldec128:
d522 1
a522 1
	jb	.L4dec128
d524 1
a524 1
	je	.L4dec192
d537 1
a537 1
.L4dec192:
d549 1
a549 1
.L4dec128:
d609 1
a609 1
	jz	.Lecb_enc_ret
d612 1
a612 1
	jb	.Lecb_enc_ret
d614 1
a614 1
	jb	.Lecb_enc_loop1
d616 1
a616 1
.Lecb_enc_loop4:
d630 1
a630 1
	jge	.Lecb_enc_loop4
d632 1
a632 1
	jb	.Lecb_enc_ret
d634 1
a634 1
.Lecb_enc_loop1:
d642 2
a643 2
	jge	.Lecb_enc_loop1
.Lecb_enc_ret:
d652 1
a652 1
	jz	.Lecb_dec_ret
d656 1
a656 1
	jb	.Lecb_dec_ret
d658 1
a658 1
	jb	.Lecb_dec_loop1
d660 1
a660 1
.Lecb_dec_loop4:
d674 1
a674 1
	jge	.Lecb_dec_loop4
d676 1
a676 1
	jb	.Lecb_dec_ret
d678 1
a678 1
.Lecb_dec_loop1:
d686 2
a687 2
	jge	.Lecb_dec_loop1
.Lecb_dec_ret:
d697 1
a697 1
	jb	.Lcbc_enc_ret
d701 1
a701 1
.Lcbc_enc_loop:
d710 1
a710 1
	jge	.Lcbc_enc_loop
d712 1
a712 1
.Lcbc_enc_ret:
d721 1
a721 1
	jb	.Lcbc_dec_just_ret
d726 1
a726 1
	jb	.Lcbc_dec_loop1
d728 1
a728 1
.Lcbc_dec_loop4:
d751 1
a751 1
	jge	.Lcbc_dec_loop4
d753 1
a753 1
	jb	.Lcbc_dec_ret
d755 1
a755 1
.Lcbc_dec_loop1:
d766 2
a767 2
	jge	.Lcbc_dec_loop1
.Lcbc_dec_ret:
d769 1
a769 1
.Lcbc_dec_just_ret:
d812 1
a812 1
	jnc	.Linc_low
d816 1
a816 1
.Linc_low:
d827 1
a827 1
	jb	.Lctr_enc_just_ret
d832 1
a832 1
	jb	.Lctr_enc_loop1
d834 1
a834 1
.Lctr_enc_loop4:
d860 1
a860 1
	jge	.Lctr_enc_loop4
d862 1
a862 1
	jb	.Lctr_enc_ret
d864 1
a864 1
.Lctr_enc_loop1:
d875 2
a876 2
	jge	.Lctr_enc_loop1
.Lctr_enc_ret:
d878 1
a878 1
.Lctr_enc_just_ret:
d952 1
a952 1
	jb	.Lgcm_hash_just_ret
d960 1
a960 2

.Lgcm_hash_loop:
d970 1
a970 1
	jge	.Lgcm_hash_loop
d975 1
a975 1
.Lgcm_hash_just_ret:
@


1.5
log
@Assembler implementation of the GCM mode using the Carry-less
Multiplication (CLMUL) instruction found in the new Intel and
future AMD CPUs.

Done about a year ago and was rotting in my trees until Ryan
prodded Theo to read the white paper and figure out the license
issues.  Apparently, there are none.  All C code and SSE glue
code was written by me, while the GF multiplication function
is taken from the CLMUL white paper, specifically Figure 6:
"Code Sample - Performing Ghash Using Algorithms 1 and 5".
@
text
@d1 1
a1 1
/*	$OpenBSD: aes_intel.S,v 1.4 2010/11/15 14:48:17 mikeb Exp $	*/
d92 8
a99 8
	pshufd $0b11111111, %xmm1, %xmm1
	shufps $0b00010000, %xmm0, %xmm4
	pxor %xmm4, %xmm0
	shufps $0b10001100, %xmm0, %xmm4
	pxor %xmm4, %xmm0
	pxor %xmm1, %xmm0
	movaps %xmm0, (%rcx)
	add $0x10, %rcx
d103 20
a122 20
	pshufd $0b01010101, %xmm1, %xmm1
	shufps $0b00010000, %xmm0, %xmm4
	pxor %xmm4, %xmm0
	shufps $0b10001100, %xmm0, %xmm4
	pxor %xmm4, %xmm0
	pxor %xmm1, %xmm0

	movaps %xmm2, %xmm5
	movaps %xmm2, %xmm6
	pslldq $4, %xmm5
	pshufd $0b11111111, %xmm0, %xmm3
	pxor %xmm3, %xmm2
	pxor %xmm5, %xmm2

	movaps %xmm0, %xmm1
	shufps $0b01000100, %xmm0, %xmm6
	movaps %xmm6, (%rcx)
	shufps $0b01001110, %xmm2, %xmm1
	movaps %xmm1, 16(%rcx)
	add $0x20, %rcx
d126 12
a137 12
	pshufd $0b01010101, %xmm1, %xmm1
	shufps $0b00010000, %xmm0, %xmm4
	pxor %xmm4, %xmm0
	shufps $0b10001100, %xmm0, %xmm4
	pxor %xmm4, %xmm0
	pxor %xmm1, %xmm0

	movaps %xmm2, %xmm5
	pslldq $4, %xmm5
	pshufd $0b11111111, %xmm0, %xmm3
	pxor %xmm3, %xmm2
	pxor %xmm5, %xmm2
d139 2
a140 2
	movaps %xmm0, (%rcx)
	add $0x10, %rcx
d144 8
a151 8
	pshufd $0b10101010, %xmm1, %xmm1
	shufps $0b00010000, %xmm2, %xmm4
	pxor %xmm4, %xmm2
	shufps $0b10001100, %xmm2, %xmm4
	pxor %xmm4, %xmm2
	pxor %xmm1, %xmm2
	movaps %xmm2, (%rcx)
	add $0x10, %rcx
d158 38
a195 38
	movups (%rsi), %xmm0		# user key (first 16 bytes)
	movaps %xmm0, (%rdi)
	lea 0x10(%rdi), %rcx		# key addr
	movl %edx, 480(%rdi)
	pxor %xmm4, %xmm4		# xmm4 is assumed 0 in _key_expansion_x
	cmp $24, %dl
	jb .Lenc_key128
	je .Lenc_key192
	movups 0x10(%rsi), %xmm2	# other user key
	movaps %xmm2, (%rcx)
	add $0x10, %rcx
	aeskeygenassist $0x1, %xmm2, %xmm1	# round 1
	call _key_expansion_256a
	aeskeygenassist $0x1, %xmm0, %xmm1
	call _key_expansion_256b
	aeskeygenassist $0x2, %xmm2, %xmm1	# round 2
	call _key_expansion_256a
	aeskeygenassist $0x2, %xmm0, %xmm1
	call _key_expansion_256b
	aeskeygenassist $0x4, %xmm2, %xmm1	# round 3
	call _key_expansion_256a
	aeskeygenassist $0x4, %xmm0, %xmm1
	call _key_expansion_256b
	aeskeygenassist $0x8, %xmm2, %xmm1	# round 4
	call _key_expansion_256a
	aeskeygenassist $0x8, %xmm0, %xmm1
	call _key_expansion_256b
	aeskeygenassist $0x10, %xmm2, %xmm1	# round 5
	call _key_expansion_256a
	aeskeygenassist $0x10, %xmm0, %xmm1
	call _key_expansion_256b
	aeskeygenassist $0x20, %xmm2, %xmm1	# round 6
	call _key_expansion_256a
	aeskeygenassist $0x20, %xmm0, %xmm1
	call _key_expansion_256b
	aeskeygenassist $0x40, %xmm2, %xmm1	# round 7
	call _key_expansion_256a
	jmp .Ldec_key
d197 18
a214 18
	movq 0x10(%rsi), %xmm2		# other user key
	aeskeygenassist $0x1, %xmm2, %xmm1	# round 1
	call _key_expansion_192a
	aeskeygenassist $0x2, %xmm2, %xmm1	# round 2
	call _key_expansion_192b
	aeskeygenassist $0x4, %xmm2, %xmm1	# round 3
	call _key_expansion_192a
	aeskeygenassist $0x8, %xmm2, %xmm1	# round 4
	call _key_expansion_192b
	aeskeygenassist $0x10, %xmm2, %xmm1	# round 5
	call _key_expansion_192a
	aeskeygenassist $0x20, %xmm2, %xmm1	# round 6
	call _key_expansion_192b
	aeskeygenassist $0x40, %xmm2, %xmm1	# round 7
	call _key_expansion_192a
	aeskeygenassist $0x80, %xmm2, %xmm1	# round 8
	call _key_expansion_192b
	jmp .Ldec_key
d216 20
a235 20
	aeskeygenassist $0x1, %xmm0, %xmm1	# round 1
	call _key_expansion_128
	aeskeygenassist $0x2, %xmm0, %xmm1	# round 2
	call _key_expansion_128
	aeskeygenassist $0x4, %xmm0, %xmm1	# round 3
	call _key_expansion_128
	aeskeygenassist $0x8, %xmm0, %xmm1	# round 4
	call _key_expansion_128
	aeskeygenassist $0x10, %xmm0, %xmm1	# round 5
	call _key_expansion_128
	aeskeygenassist $0x20, %xmm0, %xmm1	# round 6
	call _key_expansion_128
	aeskeygenassist $0x40, %xmm0, %xmm1	# round 7
	call _key_expansion_128
	aeskeygenassist $0x80, %xmm0, %xmm1	# round 8
	call _key_expansion_128
	aeskeygenassist $0x1b, %xmm0, %xmm1	# round 9
	call _key_expansion_128
	aeskeygenassist $0x36, %xmm0, %xmm1	# round 10
	call _key_expansion_128
d237 7
a243 7
	sub $0x10, %rcx
	movaps (%rdi), %xmm0
	movaps (%rcx), %xmm1
	movaps %xmm0, 240(%rcx)
	movaps %xmm1, 240(%rdi)
	add $0x10, %rdi
	lea 240-16(%rcx), %rsi
d246 7
a252 7
	movaps (%rdi), %xmm0
	aesimc %xmm0, %xmm1
	movaps %xmm1, (%rsi)
	add $0x10, %rdi
	sub $0x10, %rsi
	cmp %rcx, %rdi
	jb .Ldec_key_loop
d259 4
a262 4
	movl 480(KEYP), KLEN		# key length
	movups (INP), STATE		# input
	call _aesni_enc1
	movups STATE, (OUTP)		# output
d278 13
a290 13
	movaps (KEYP), KEY		# key
	mov KEYP, TKEYP
	pxor KEY, STATE			# round 0
	add $0x30, TKEYP
	cmp $24, KLEN
	jb .Lenc128
	lea 0x20(TKEYP), TKEYP
	je .Lenc192
	add $0x20, TKEYP
	movaps -0x60(TKEYP), KEY
	aesenc KEY, STATE
	movaps -0x50(TKEYP), KEY
	aesenc KEY, STATE
d293 4
a296 4
	movaps -0x40(TKEYP), KEY
	aesenc KEY, STATE
	movaps -0x30(TKEYP), KEY
	aesenc KEY, STATE
d299 20
a318 20
	movaps -0x20(TKEYP), KEY
	aesenc KEY, STATE
	movaps -0x10(TKEYP), KEY
	aesenc KEY, STATE
	movaps (TKEYP), KEY
	aesenc KEY, STATE
	movaps 0x10(TKEYP), KEY
	aesenc KEY, STATE
	movaps 0x20(TKEYP), KEY
	aesenc KEY, STATE
	movaps 0x30(TKEYP), KEY
	aesenc KEY, STATE
	movaps 0x40(TKEYP), KEY
	aesenc KEY, STATE
	movaps 0x50(TKEYP), KEY
	aesenc KEY, STATE
	movaps 0x60(TKEYP), KEY
	aesenc KEY, STATE
	movaps 0x70(TKEYP), KEY
	aesenclast KEY, STATE
d340 22
a361 22
	movaps (KEYP), KEY		# key
	mov KEYP, TKEYP
	pxor KEY, STATE1		# round 0
	pxor KEY, STATE2
	pxor KEY, STATE3
	pxor KEY, STATE4
	add $0x30, TKEYP
	cmp $24, KLEN
	jb .L4enc128
	lea 0x20(TKEYP), TKEYP
	je .L4enc192
	add $0x20, TKEYP
	movaps -0x60(TKEYP), KEY
	aesenc KEY, STATE1
	aesenc KEY, STATE2
	aesenc KEY, STATE3
	aesenc KEY, STATE4
	movaps -0x50(TKEYP), KEY
	aesenc KEY, STATE1
	aesenc KEY, STATE2
	aesenc KEY, STATE3
	aesenc KEY, STATE4
d364 10
a373 10
	movaps -0x40(TKEYP), KEY
	aesenc KEY, STATE1
	aesenc KEY, STATE2
	aesenc KEY, STATE3
	aesenc KEY, STATE4
	movaps -0x30(TKEYP), KEY
	aesenc KEY, STATE1
	aesenc KEY, STATE2
	aesenc KEY, STATE3
	aesenc KEY, STATE4
d376 50
a425 50
	movaps -0x20(TKEYP), KEY
	aesenc KEY, STATE1
	aesenc KEY, STATE2
	aesenc KEY, STATE3
	aesenc KEY, STATE4
	movaps -0x10(TKEYP), KEY
	aesenc KEY, STATE1
	aesenc KEY, STATE2
	aesenc KEY, STATE3
	aesenc KEY, STATE4
	movaps (TKEYP), KEY
	aesenc KEY, STATE1
	aesenc KEY, STATE2
	aesenc KEY, STATE3
	aesenc KEY, STATE4
	movaps 0x10(TKEYP), KEY
	aesenc KEY, STATE1
	aesenc KEY, STATE2
	aesenc KEY, STATE3
	aesenc KEY, STATE4
	movaps 0x20(TKEYP), KEY
	aesenc KEY, STATE1
	aesenc KEY, STATE2
	aesenc KEY, STATE3
	aesenc KEY, STATE4
	movaps 0x30(TKEYP), KEY
	aesenc KEY, STATE1
	aesenc KEY, STATE2
	aesenc KEY, STATE3
	aesenc KEY, STATE4
	movaps 0x40(TKEYP), KEY
	aesenc KEY, STATE1
	aesenc KEY, STATE2
	aesenc KEY, STATE3
	aesenc KEY, STATE4
	movaps 0x50(TKEYP), KEY
	aesenc KEY, STATE1
	aesenc KEY, STATE2
	aesenc KEY, STATE3
	aesenc KEY, STATE4
	movaps 0x60(TKEYP), KEY
	aesenc KEY, STATE1
	aesenc KEY, STATE2
	aesenc KEY, STATE3
	aesenc KEY, STATE4
	movaps 0x70(TKEYP), KEY
	aesenclast KEY, STATE1		# last round
	aesenclast KEY, STATE2
	aesenclast KEY, STATE3
	aesenclast KEY, STATE4
d432 5
a436 5
	mov 480(KEYP), KLEN		# key length
	add $240, KEYP
	movups (INP), STATE		# input
	call _aesni_dec1
	movups STATE, (OUTP)		#output
d452 13
a464 13
	movaps (KEYP), KEY		# key
	mov KEYP, TKEYP
	pxor KEY, STATE			# round 0
	add $0x30, TKEYP
	cmp $24, KLEN
	jb .Ldec128
	lea 0x20(TKEYP), TKEYP
	je .Ldec192
	add $0x20, TKEYP
	movaps -0x60(TKEYP), KEY
	aesdec KEY, STATE
	movaps -0x50(TKEYP), KEY
	aesdec KEY, STATE
d467 4
a470 4
	movaps -0x40(TKEYP), KEY
	aesdec KEY, STATE
	movaps -0x30(TKEYP), KEY
	aesdec KEY, STATE
d473 20
a492 20
	movaps -0x20(TKEYP), KEY
	aesdec KEY, STATE
	movaps -0x10(TKEYP), KEY
	aesdec KEY, STATE
	movaps (TKEYP), KEY
	aesdec KEY, STATE
	movaps 0x10(TKEYP), KEY
	aesdec KEY, STATE
	movaps 0x20(TKEYP), KEY
	aesdec KEY, STATE
	movaps 0x30(TKEYP), KEY
	aesdec KEY, STATE
	movaps 0x40(TKEYP), KEY
	aesdec KEY, STATE
	movaps 0x50(TKEYP), KEY
	aesdec KEY, STATE
	movaps 0x60(TKEYP), KEY
	aesdec KEY, STATE
	movaps 0x70(TKEYP), KEY
	aesdeclast KEY, STATE
d514 22
a535 22
	movaps (KEYP), KEY		# key
	mov KEYP, TKEYP
	pxor KEY, STATE1		# round 0
	pxor KEY, STATE2
	pxor KEY, STATE3
	pxor KEY, STATE4
	add $0x30, TKEYP
	cmp $24, KLEN
	jb .L4dec128
	lea 0x20(TKEYP), TKEYP
	je .L4dec192
	add $0x20, TKEYP
	movaps -0x60(TKEYP), KEY
	aesdec KEY, STATE1
	aesdec KEY, STATE2
	aesdec KEY, STATE3
	aesdec KEY, STATE4
	movaps -0x50(TKEYP), KEY
	aesdec KEY, STATE1
	aesdec KEY, STATE2
	aesdec KEY, STATE3
	aesdec KEY, STATE4
d538 10
a547 10
	movaps -0x40(TKEYP), KEY
	aesdec KEY, STATE1
	aesdec KEY, STATE2
	aesdec KEY, STATE3
	aesdec KEY, STATE4
	movaps -0x30(TKEYP), KEY
	aesdec KEY, STATE1
	aesdec KEY, STATE2
	aesdec KEY, STATE3
	aesdec KEY, STATE4
d550 50
a599 50
	movaps -0x20(TKEYP), KEY
	aesdec KEY, STATE1
	aesdec KEY, STATE2
	aesdec KEY, STATE3
	aesdec KEY, STATE4
	movaps -0x10(TKEYP), KEY
	aesdec KEY, STATE1
	aesdec KEY, STATE2
	aesdec KEY, STATE3
	aesdec KEY, STATE4
	movaps (TKEYP), KEY
	aesdec KEY, STATE1
	aesdec KEY, STATE2
	aesdec KEY, STATE3
	aesdec KEY, STATE4
	movaps 0x10(TKEYP), KEY
	aesdec KEY, STATE1
	aesdec KEY, STATE2
	aesdec KEY, STATE3
	aesdec KEY, STATE4
	movaps 0x20(TKEYP), KEY
	aesdec KEY, STATE1
	aesdec KEY, STATE2
	aesdec KEY, STATE3
	aesdec KEY, STATE4
	movaps 0x30(TKEYP), KEY
	aesdec KEY, STATE1
	aesdec KEY, STATE2
	aesdec KEY, STATE3
	aesdec KEY, STATE4
	movaps 0x40(TKEYP), KEY
	aesdec KEY, STATE1
	aesdec KEY, STATE2
	aesdec KEY, STATE3
	aesdec KEY, STATE4
	movaps 0x50(TKEYP), KEY
	aesdec KEY, STATE1
	aesdec KEY, STATE2
	aesdec KEY, STATE3
	aesdec KEY, STATE4
	movaps 0x60(TKEYP), KEY
	aesdec KEY, STATE1
	aesdec KEY, STATE2
	aesdec KEY, STATE3
	aesdec KEY, STATE4
	movaps 0x70(TKEYP), KEY
	aesdeclast KEY, STATE1		# last round
	aesdeclast KEY, STATE2
	aesdeclast KEY, STATE3
	aesdeclast KEY, STATE4
d608 7
a614 7
	test LEN, LEN			# check length
	jz .Lecb_enc_ret
	mov 480(KEYP), KLEN
	cmp $16, LEN
	jb .Lecb_enc_ret
	cmp $64, LEN
	jb .Lecb_enc_loop1
d617 16
a632 16
	movups (INP), STATE1
	movups 0x10(INP), STATE2
	movups 0x20(INP), STATE3
	movups 0x30(INP), STATE4
	call _aesni_enc4
	movups STATE1, (OUTP)
	movups STATE2, 0x10(OUTP)
	movups STATE3, 0x20(OUTP)
	movups STATE4, 0x30(OUTP)
	sub $64, LEN
	add $64, INP
	add $64, OUTP
	cmp $64, LEN
	jge .Lecb_enc_loop4
	cmp $16, LEN
	jb .Lecb_enc_ret
d635 8
a642 8
	movups (INP), STATE1
	call _aesni_enc1
	movups STATE1, (OUTP)
	sub $16, LEN
	add $16, INP
	add $16, OUTP
	cmp $16, LEN
	jge .Lecb_enc_loop1
d651 8
a658 8
	test LEN, LEN
	jz .Lecb_dec_ret
	mov 480(KEYP), KLEN
	add $240, KEYP
	cmp $16, LEN
	jb .Lecb_dec_ret
	cmp $64, LEN
	jb .Lecb_dec_loop1
d661 16
a676 16
	movups (INP), STATE1
	movups 0x10(INP), STATE2
	movups 0x20(INP), STATE3
	movups 0x30(INP), STATE4
	call _aesni_dec4
	movups STATE1, (OUTP)
	movups STATE2, 0x10(OUTP)
	movups STATE3, 0x20(OUTP)
	movups STATE4, 0x30(OUTP)
	sub $64, LEN
	add $64, INP
	add $64, OUTP
	cmp $64, LEN
	jge .Lecb_dec_loop4
	cmp $16, LEN
	jb .Lecb_dec_ret
d679 8
a686 8
	movups (INP), STATE1
	call _aesni_dec1
	movups STATE1, (OUTP)
	sub $16, LEN
	add $16, INP
	add $16, OUTP
	cmp $16, LEN
	jge .Lecb_dec_loop1
d696 4
a699 4
	cmp $16, LEN
	jb .Lcbc_enc_ret
	mov 480(KEYP), KLEN
	movups (IVP), STATE	# load iv as initial state
d702 10
a711 10
	movups (INP), IN	# load input
	pxor IN, STATE
	call _aesni_enc1
	movups STATE, (OUTP)	# store output
	sub $16, LEN
	add $16, INP
	add $16, OUTP
	cmp $16, LEN
	jge .Lcbc_enc_loop
	movups STATE, (IVP)
d720 7
a726 7
	cmp $16, LEN
	jb .Lcbc_dec_just_ret
	mov 480(KEYP), KLEN
	add $240, KEYP
	movups (IVP), IV
	cmp $64, LEN
	jb .Lcbc_dec_loop1
d729 25
a753 25
	movups (INP), IN1
	movaps IN1, STATE1
	movups 0x10(INP), IN2
	movaps IN2, STATE2
	movups 0x20(INP), IN3
	movaps IN3, STATE3
	movups 0x30(INP), IN4
	movaps IN4, STATE4
	call _aesni_dec4
	pxor IV, STATE1
	pxor IN1, STATE2
	pxor IN2, STATE3
	pxor IN3, STATE4
	movaps IN4, IV
	movups STATE1, (OUTP)
	movups STATE2, 0x10(OUTP)
	movups STATE3, 0x20(OUTP)
	movups STATE4, 0x30(OUTP)
	sub $64, LEN
	add $64, INP
	add $64, OUTP
	cmp $64, LEN
	jge .Lcbc_dec_loop4
	cmp $16, LEN
	jb .Lcbc_dec_ret
d756 11
a766 11
	movups (INP), IN
	movaps IN, STATE
	call _aesni_dec1
	pxor IV, STATE
	movups STATE, (OUTP)
	movaps IN, IV
	sub $16, LEN
	add $16, INP
	add $16, OUTP
	cmp $16, LEN
	jge .Lcbc_dec_loop1
d768 1
a768 1
	movups IV, (IVP)
d785 7
a791 7
	movdqa	CTR, IV
	pslldq	$8, IV
	movdqu	.Lbswap_mask, BSWAP_MASK
	pshufb	BSWAP_MASK, CTR
	mov	$1, TCTR_LOW
	movd	TCTR_LOW, INC
	movd	CTR, TCTR_LOW
d810 6
a815 6
	paddq INC, CTR
	add $1, TCTR_LOW
	jnc .Linc_low
	pslldq $8, INC
	paddq INC, CTR
	psrldq $8, INC
d817 2
a818 2
	movaps CTR, IV
	pshufb BSWAP_MASK, IV
d826 7
a832 7
	cmp $16, LEN
	jb .Lctr_enc_just_ret
	mov 480(KEYP), KLEN
	movdqu (ICBP), CTR
	call _aesni_inc_init
	cmp $64, LEN
	jb .Lctr_enc_loop1
d835 28
a862 28
	call _aesni_inc
	movaps IV, STATE1
	movups (INP), IN1
	call _aesni_inc
	movaps IV, STATE2
	movups 0x10(INP), IN2
	call _aesni_inc
	movaps IV, STATE3
	movups 0x20(INP), IN3
	call _aesni_inc
	movaps IV, STATE4
	movups 0x30(INP), IN4
	call _aesni_enc4
	pxor IN1, STATE1
	movups STATE1, (OUTP)
	pxor IN2, STATE2
	movups STATE2, 0x10(OUTP)
	pxor IN3, STATE3
	movups STATE3, 0x20(OUTP)
	pxor IN4, STATE4
	movups STATE4, 0x30(OUTP)
	sub $64, LEN
	add $64, INP
	add $64, OUTP
	cmp $64, LEN
	jge .Lctr_enc_loop4
	cmp $16, LEN
	jb .Lctr_enc_ret
d865 11
a875 11
	call _aesni_inc
	movaps IV, STATE
	movups (INP), IN
	call _aesni_enc1
	pxor IN, STATE
	movups STATE, (OUTP)
	sub $16, LEN
	add $16, INP
	add $16, OUTP
	cmp $16, LEN
	jge .Lctr_enc_loop1
d877 1
a877 1
	movq IV, (IVP)
d882 15
a896 15
	movdqa	%xmm0, %xmm3
	pclmulqdq $0x00, %xmm1, %xmm3	# xmm3 holds a0*b0
	movdqa	%xmm0, %xmm4
	pclmulqdq $0x10, %xmm1, %xmm4	# xmm4 holds a0*b1
	movdqa	%xmm0, %xmm5
	pclmulqdq $0x01, %xmm1, %xmm5	# xmm5 holds a1*b0
	movdqa	%xmm0, %xmm6
	pclmulqdq $0x11, %xmm1, %xmm6	# xmm6 holds a1*b1

	pxor	%xmm5, %xmm4		# xmm4 holds a0*b1 + a1*b0
	movdqa	%xmm4, %xmm5
	psrldq	$8, %xmm4
	pslldq	$8, %xmm5
	pxor	%xmm5, %xmm3
	pxor	%xmm4, %xmm6
d905 13
a917 13
	movdqa	%xmm3, %xmm7
	movdqa	%xmm6, %xmm8
	pslld	$1, %xmm3
	pslld	$1, %xmm6
	psrld	$31, %xmm7
	psrld	$31, %xmm8
	movdqa	%xmm7, %xmm9
	pslldq	$4, %xmm8
	pslldq	$4, %xmm7
	psrldq	$12, %xmm9
	por	%xmm7, %xmm3
	por	%xmm8, %xmm6
	por	%xmm9, %xmm6
d920 12
a931 12
	movdqa	%xmm3, %xmm7
	movdqa	%xmm3, %xmm8
	movdqa	%xmm3, %xmm9
	pslld	$31, %xmm7		# packed right shifting << 31
	pslld	$30, %xmm8		# packed right shifting shift << 30
	pslld	$25, %xmm9		# packed right shifting shift << 25
	pxor	%xmm8, %xmm7		# xor the shifted versions
	pxor	%xmm9, %xmm7
	movdqa	%xmm7, %xmm8
	pslldq	$12, %xmm7
	psrldq	$4, %xmm8
	pxor	%xmm7, %xmm3
d937 8
a944 8
	psrld	$1, %xmm2		# packed left shifting >> 1
	psrld	$2, %xmm4		# packed left shifting >> 2
	psrld	$7, %xmm5		# packed left shifting >> 7
	pxor	%xmm4, %xmm2		# xor the shifted versions
	pxor	%xmm5, %xmm2
	pxor	%xmm8, %xmm2
	pxor	%xmm2, %xmm3
	pxor	%xmm3, %xmm6		# the result is in xmm6
d951 1
a951 1
	cmp	$16, %rdx
d954 1
a954 1
	movdqu	.Lbswap_mask, BSWAP_MASK	# endianness swap mask
d956 4
a959 4
	movdqu	(%rdi), %xmm1		# hash subkey
	movdqu	32(%rdi), %xmm6		# initial state
	pshufb	BSWAP_MASK, %xmm1
	pshufb	BSWAP_MASK, %xmm6
d962 4
a965 4
	movdqu	(%rsi), %xmm2
	pshufb	BSWAP_MASK, %xmm2
	movdqa	%xmm6, %xmm0
	pxor	%xmm2, %xmm0
d968 3
a970 3
	sub	$16, %rdx
	add	$16, %rsi
	cmp	$16, %rdx
d973 3
a975 3
	pshufb	BSWAP_MASK, %xmm6
	movdqu	%xmm6, 16(%rdi)
	movdqu	%xmm6, 32(%rdi)
d984 2
a985 2
	movl	480(KEYP), KLEN		# key length
	movdqu	(INP), STATE		# icb
d987 3
a989 3
	movdqu	(HSTATE), IN
	pxor	IN, STATE
	movdqu	STATE, (OUTP)		# output
@


1.4
log
@rename aesni_sess to aesni_session;  bugged me all the time
@
text
@d1 1
a1 1
/*	$OpenBSD: aes_intel.S,v 1.3 2010/11/10 17:05:39 mikeb Exp $	*/
d74 1
d879 111
@


1.3
log
@pass aesni_ctr_enc an initial counter block instead of an initialization vector
@
text
@d1 1
a1 1
/*	$OpenBSD: aes_intel.S,v 1.2 2010/07/22 12:47:40 thib Exp $	*/
d154 1
a154 1
 * void aesni_set_key(struct aesni_sess *ses, uint8_t *key, size_t len)
d255 1
a255 1
 * void aesni_enc(struct aesni_sess *ses, uint8_t *dst, uint8_t *src)
d428 1
a428 1
 * void aesni_dec(struct aesni_sess *ses, uint8_t *dst, uint8_t *src)
d603 1
a603 1
 * void aesni_ecb_enc(struct aesni_sess *ses, uint8_t *dst, uint8_t *src,
d646 1
a646 1
 * void aesni_ecb_dec(struct aesni_sess *ses, uint8_t *dst, uint8_t *src,
d691 1
a691 1
 * void aesni_cbc_enc(struct aesni_sess *ses, uint8_t *dst, uint8_t *src,
d715 1
a715 1
 * void aesni_cbc_dec(struct aesni_sess *ses, uint8_t *dst, uint8_t *src,
d821 1
a821 1
 * void aesni_ctr_enc(struct aesni_sess *ses, uint8_t *dst, uint8_t *src,
@


1.2
log
@Fixes for AES CTR mode from mikeb:

o Fix up counter increment for buffers larger then 64 bytes, by
  calling the increment routine before loading the IV into the
  encryption routine input register.

o In aesni_encdec() regenerate the IV for every new request.

Also use nice defines instead of magic constants for the size
of ses_iv.
@
text
@d1 1
a1 1
/*	$OpenBSD: aes_intel.S,v 1.1 2010/06/29 21:34:11 thib Exp $	*/
a68 1
#define NONCE		%xmm13
d75 1
d775 1
a775 1
 *	IV
d777 2
a778 1
 *	CTR:		== IV, in little endian
d784 7
a790 8
	movaps .Lbswap_mask, BSWAP_MASK
	movaps IV, CTR
	pslldq $4, CTR
	por NONCE, CTR
	pshufb BSWAP_MASK, CTR
	mov $1, TCTR_LOW
	movd TCTR_LOW, INC
	movd CTR, TCTR_LOW
d822 1
a822 1
 *     size_t len, uint8_t *iv)
d828 1
a828 2
	movd 484(KEYP), NONCE
	movq (IVP), IV
@


1.1
log
@aesni, a driver for the crypto framework, similar to the
via driver for supporting the AES-NI instructions found
on recent Intel cores.

I would like to thank Huang Ying at Intel for getting the
assembly code relicensed from GPL to a more suitable license!

Inital diff by myself, but Mike Belopuhov beat this into a
usable shape and fixed many bugs.

Not enabled yet.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d835 1
d837 1
a838 1
	movups (INP), IN1
d840 1
a841 1
	movups 0x10(INP), IN2
d843 1
a844 1
	movups 0x20(INP), IN3
a845 1
	call _aesni_inc
@

