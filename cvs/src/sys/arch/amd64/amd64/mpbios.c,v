head	1.27;
access;
symbols
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.26.0.2
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.25.0.4
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.22.0.4
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.21.0.12
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.8
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.6
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.4
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.2
	OPENBSD_5_0:1.20.0.2
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.18.0.8
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.6
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.4
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.16.0.2
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.12.0.2
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.11.0.2
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.9.0.4
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.2
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.3.0.4
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.2.0.2
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.1.0.4
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.2
	OPENBSD_3_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.27
date	2016.07.28.21.57.57;	author kettenis;	state Exp;
branches;
next	1.26;
commitid	h0GHFDGWnEdswfbK;

1.26
date	2016.04.21.22.13.27;	author mlarkin;	state Exp;
branches;
next	1.25;
commitid	B9qJFBLTuH1tAVKL;

1.25
date	2015.06.07.12.16.27;	author jsg;	state Exp;
branches;
next	1.24;
commitid	uN5YxxZFxaAxG5nD;

1.24
date	2014.12.09.06.58.28;	author doug;	state Exp;
branches;
next	1.23;
commitid	yWAxzpQP2PPpYlfT;

1.23
date	2014.11.16.12.30.56;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	yv0ECmCdICvq576h;

1.22
date	2014.05.26.19.03.28;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2011.10.21.20.48.11;	author kettenis;	state Exp;
branches;
next	1.20;

1.20
date	2011.04.02.22.51.53;	author marco;	state Exp;
branches;
next	1.19;

1.19
date	2011.03.06.22.40.05;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2009.04.21.19.18.09;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2009.04.19.17.53.39;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2009.01.13.19.38.44;	author grange;	state Exp;
branches;
next	1.15;

1.15
date	2009.01.13.13.53.50;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2008.12.22.18.01.47;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2008.09.15.19.24.47;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2008.06.26.05.42.09;	author ray;	state Exp;
branches;
next	1.11;

1.11
date	2007.11.16.16.16.07;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2007.09.17.15.34.38;	author chl;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.15.23.19.05;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2006.11.25.16.59.31;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	2006.10.03.22.39.40;	author gwk;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.29.20.40.55;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.21.20.13.26;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.22.21.16.00;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.21.18.55.00;	author martin;	state Exp;
branches;
next	1.2;

1.2
date	2005.07.18.02.43.24;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.25.11.03.27;	author art;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Store the acpi processor ID/UID in struct cpu_info, and use it to attach
acpicpu(4) drivers to the right cpu(4).

ok mlarkin@@, guenther@@
@
text
@/*	$OpenBSD: mpbios.c,v 1.26 2016/04/21 22:13:27 mlarkin Exp $	*/
/*	$NetBSD: mpbios.c,v 1.7 2003/05/15 16:32:50 fvdl Exp $	*/

/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by RedBack Networks Inc.
 *
 * Author: Bill Sommerfeld
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1999 Stefan Grefen
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the NetBSD
 *      Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR AND CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*
 * Derived from FreeBSD's mp_machdep.c
 */
/*
 * Copyright (c) 1996, by Steve Passe
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the developer may NOT be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * The Intel MP-stuff is just one way of x86 SMP systems
 * so only Intel MP specific stuff is here.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <uvm/uvm_extern.h>

#include <machine/specialreg.h>
#include <machine/cpuvar.h>
#include <machine/bus.h>
#include <machine/biosvar.h>
#include <machine/mpbiosvar.h>

#include <machine/i82093reg.h>
#include <machine/i82093var.h>
#include <machine/i82489reg.h>
#include <machine/i82489var.h>

#include <dev/isa/isareg.h>
#include <dev/pci/pcivar.h>

#ifdef X86_MPBIOS_SUPPORT_EISA
#include <dev/eisa/eisavar.h>	/* for ELCR* def'ns */
#endif

#include "pci.h"

/* descriptions of MP basetable entries */
struct mpbios_baseentry {
	u_int8_t	type;
	u_int8_t	length;
	u_int16_t	count;
	const char	*name;
};

static const char *loc_where[] = {
	"extended bios data area",
	"last page of base memory",
	"bios"
};

struct mp_map
{
	vaddr_t		baseva;
	int		vsize;
	paddr_t		pa;
	paddr_t		pg;
	int		psize;
};

int	mp_print(void *, const char *);
int	mp_match(struct device *, void *, void *);
const void *mpbios_search(struct device *, paddr_t, int, struct mp_map *);
static __inline int mpbios_cksum(const void *, int);

void	mp_cfg_special_intr(const struct mpbios_int *, u_int32_t *);
void	mp_print_special_intr(int);

void	mp_cfg_pci_intr(const struct mpbios_int *, u_int32_t *);
void	mp_print_pci_intr(int);

#ifdef X86_MPBIOS_SUPPORT_EISA
void	mp_cfg_eisa_intr(const struct mpbios_int *, u_int32_t *);
void	mp_print_eisa_intr(int);
#endif

void	mp_cfg_isa_intr(const struct mpbios_int *, u_int32_t *);
void	mp_print_isa_intr(int);

void	mpbios_cpu(const u_int8_t *, struct device *);
void	mpbios_bus(const u_int8_t *, struct device *);
void	mpbios_ioapic(const u_int8_t *, struct device *);
int	mpbios_int(const u_int8_t *, int, struct mp_intr_map *);

const void *mpbios_map(paddr_t, int, struct mp_map *);
void	mpbios_unmap(struct mp_map *);

/*
 * globals to help us bounce our way through parsing the config table.
 */

static struct mp_map mp_cfg_table_map;
static struct mp_map mp_fp_map;
const struct mpbios_cth	*mp_cth;
const struct mpbios_fps	*mp_fps;

int mpbios_scanned;

int	mpbios_match(struct device *, void *, void *);
void	mpbios_attach(struct device *, struct device *, void *);

struct cfattach mpbios_ca = {
	sizeof(struct device), mpbios_match, mpbios_attach
};

struct cfdriver mpbios_cd = {
	NULL, "mpbios", DV_DULL
};

int
mpbios_match(struct device *parent, void *match, void *aux)
{
	struct cfdata *cf = match;
	struct bios_attach_args *bia = aux;

	if (strcmp(bia->ba_name, cf->cf_driver->cd_name) == 0)
		return (1);
	return (0);
}

void
mpbios_attach(struct device *parent, struct device *self, void *aux)
{
	mpbios_scan(self);
}

int
mp_print(void *aux, const char *pnp)
{
	struct cpu_attach_args *caa = aux;

	if (pnp)
		printf("%s at %s:", caa->caa_name, pnp);
	return (UNCONF);
}

int
mp_match(struct device *parent, void *cfv, void *aux)
{
	struct cfdata *cf = cfv;
	struct cpu_attach_args *caa = aux;

	if (strcmp(caa->caa_name, cf->cf_driver->cd_name))
		return 0;

	return ((*cf->cf_attach->ca_match)(parent, cf, aux));
}

/*
 * Map a chunk of memory read-only and return an appropriately
 * const'ed pointer.
 */
const void *
mpbios_map(paddr_t pa, int len, struct mp_map *handle)
{
	paddr_t pgpa = trunc_page(pa);
	paddr_t endpa = round_page(pa + len);
	vaddr_t va = uvm_km_valloc(kernel_map, endpa - pgpa);
	vaddr_t retva = va + (pa & PGOFSET);

	handle->pa = pa;
	handle->pg = pgpa;
	handle->psize = len;
	handle->baseva = va;
	handle->vsize = endpa - pgpa;

	do {
		pmap_kenter_pa(va, pgpa, PROT_READ);
		va += PAGE_SIZE;
		pgpa += PAGE_SIZE;
	} while (pgpa < endpa);

	return ((const void *)retva);
}

void
mpbios_unmap(struct mp_map *handle)
{
	pmap_kremove(handle->baseva, handle->vsize);
	uvm_km_free(kernel_map, handle->baseva, handle->vsize);
}

/*
 * Look for an Intel MP spec table, indicating SMP capable hardware.
 */
int
mpbios_probe(struct device *self)
{
	paddr_t  	ebda, memtop;

	paddr_t		cthpa;
	int		cthlen;
	const u_int8_t	*mpbios_page;
	int 		scan_loc;

	struct		mp_map t;

	/*
	 * Skip probe if someone else (e.g. acpi) already provided the
	 * necessary details.
	 */
	if (mp_busses)
		return (0);

	/* see if EBDA exists */

	mpbios_page = mpbios_map(0, PAGE_SIZE, &t);

	/* XXX Ugly magic constants below. */
	ebda = *(const u_int16_t *)(&mpbios_page[0x40e]);
	ebda <<= 4;

	memtop = *(const u_int16_t *)(&mpbios_page[0x413]);
	memtop <<= 10;

	mpbios_page = NULL;
	mpbios_unmap(&t);

	scan_loc = 0;

	if (ebda && ebda < IOM_BEGIN ) {
		mp_fps = mpbios_search(self, ebda, 1024, &mp_fp_map);
		if (mp_fps != NULL)
			goto found;
	}

	scan_loc = 1;

	if (memtop && memtop <= IOM_BEGIN ) {
		mp_fps = mpbios_search(self, memtop - 1024, 1024, &mp_fp_map);
		if (mp_fps != NULL)
			goto found;
	}

	scan_loc = 2;

	mp_fps = mpbios_search(self, BIOS_BASE, BIOS_COUNT, &mp_fp_map);
	if (mp_fps != NULL)
		goto found;

	/* nothing found */
	return (0);

 found:
	if (mp_verbose)
		printf("%s: MP floating pointer found in %s at 0x%lx\n",
		    self->dv_xname, loc_where[scan_loc], mp_fp_map.pa);

	if (mp_fps->pap == 0) {
		if (mp_fps->mpfb1 == 0)
			printf("%s: MP fps invalid: "
			    "no default config and no configuration table\n",
			    self->dv_xname);
		else
			printf("%s: MP default configuration %d not "
			    "supported\n", self->dv_xname, mp_fps->mpfb1);
		goto err;
	}

	cthpa = mp_fps->pap;

	mp_cth = mpbios_map(cthpa, sizeof (*mp_cth), &mp_cfg_table_map);
	cthlen = mp_cth->base_len;
	mpbios_unmap(&mp_cfg_table_map);

	mp_cth = mpbios_map(cthpa, cthlen, &mp_cfg_table_map);

	if (mp_verbose)
		printf("%s: MP config table at 0x%lx, %d bytes long\n",
		    self->dv_xname, cthpa, cthlen);

	if (mp_cth->signature != MP_CT_SIG) {
		printf("%s: MP signature mismatch (%x vs %x)\n",
		    self->dv_xname,
		    MP_CT_SIG, mp_cth->signature);
		goto err;
	}

	if (mpbios_cksum(mp_cth, cthlen)) {
		printf ("%s: MP Configuration Table checksum mismatch\n",
		    self->dv_xname);
		goto err;
	}
	return (1);

 err:
	if (mp_fps) {
		mp_fps = NULL;
		mpbios_unmap(&mp_fp_map);
	}
	if (mp_cth) {
		mp_cth = NULL;
		mpbios_unmap(&mp_cfg_table_map);
	}
	return (0);
}


/*
 * Simple byte checksum used on config tables.
 */

static __inline int
mpbios_cksum(const void *start, int len)
{
	unsigned char res=0;
	const char *p = start;
	const char *end = p + len;

	while (p < end)
		res += *p++;

	return res;
}


/*
 * Look for the MP floating pointer signature in the given physical
 * address range.
 *
 * We map the memory, scan through it, and unmap it.
 * If we find it, remap the floating pointer structure and return it.
 */

const void *
mpbios_search(struct device *self, paddr_t start, int count, struct mp_map *map)
{
	struct mp_map t;

	int i, len;
	const struct mpbios_fps *m;
	int end = count - sizeof(*m);
	const u_int8_t *base = mpbios_map(start, count, &t);

	if (mp_verbose)
		printf("%s: scanning 0x%lx to 0x%lx for MP signature\n",
		    self->dv_xname, start, start + count - sizeof(*m));

	for (i = 0; i <= end; i += 4) {
		m = (struct mpbios_fps *)&base[i];

		if ((m->signature == MP_FP_SIG) &&
		    ((len = m->length << 4) != 0) &&
		    mpbios_cksum(m, (m->length << 4)) == 0) {
			mpbios_unmap(&t);

			return (mpbios_map(start + i, len, map));
		}
	}
	mpbios_unmap(&t);

	return (0);
}

/*
 * MP configuration table parsing.
 */

static struct mpbios_baseentry mp_conf[] =
{
	{0, 20, 0, "cpu"},
	{1, 8, 0, "bus"},
	{2, 8, 0, "ioapic"},
	{3, 8, 0, "ioint"},
	{4, 8, 0, "lint"},
};

static struct mp_bus extint_bus = {
	"ExtINT",
	-1,
	mp_print_special_intr,
	mp_cfg_special_intr,
	0
};
static struct mp_bus smi_bus = {
	"SMI",
	-1,
	mp_print_special_intr,
	mp_cfg_special_intr,
	0
};
static struct mp_bus nmi_bus = {
	"NMI",
	-1,
	mp_print_special_intr,
	mp_cfg_special_intr,
	0
};


/*
 * 1st pass on BIOS's Intel MP specification table.
 *
 * initializes:
 *	mp_ncpus = 1
 *
 * determines:
 *	cpu_apic_address (common to all CPUs)
 *	ioapic_address[N]
 *	mp_naps
 *	mp_nbusses
 *	mp_napics
 *	nintrs
 */
void
mpbios_scan(struct device *self)
{
	const u_int8_t 	*position, *end;
	int		count;
	int		type;
	int		intr_cnt, cur_intr;
	paddr_t		lapic_base;
	const struct mpbios_int *iep;
	struct mpbios_int ie;
	struct ioapic_softc *sc;

	printf(": Intel MP Specification 1.%d\n", mp_fps->spec_rev);

	/*
	 * looks like we've got a MP system.  start setting up
	 * infrastructure..
	 * XXX is this the right place??
	 */

	lapic_base = LAPIC_BASE;
	if (mp_cth != NULL)
		lapic_base = (paddr_t)mp_cth->apic_address;

	lapic_boot_init(lapic_base);

	/*
	 * Walk the table once, counting items
	 */
	position = (const u_int8_t *)(mp_cth);
	end = position + mp_cth->base_len;
	position += sizeof(*mp_cth);

	count = mp_cth->entry_count;
	intr_cnt = 0;

	while ((count--) && (position < end)) {
		type = *position;
		if (type >= MPS_MCT_NTYPES) {
			printf("%s: unknown entry type %x"
			    " in MP config table\n",
			    self->dv_xname, type);
			break;
		}
		mp_conf[type].count++;
		if (type == MPS_MCT_BUS) {
			const struct mpbios_bus *bp =
			    (const struct mpbios_bus *)position;
			if (bp->bus_id >= mp_nbusses)
				mp_nbusses = bp->bus_id + 1;
		}
		/*
		 * Count actual interrupt instances.
		 * dst_apic_id of MPS_ALL_APICS means "wired to all
		 * apics of this type".
		 */
		if (type == MPS_MCT_IOINT) {
			iep = (const struct mpbios_int *)position;
			if (iep->dst_apic_id == MPS_ALL_APICS)
				intr_cnt +=
				    mp_conf[MPS_MCT_IOAPIC].count;
			else
				intr_cnt++;
		} else if (type == MPS_MCT_LINT)
			intr_cnt++;
		position += mp_conf[type].length;
	}

	mp_busses = mallocarray(mp_nbusses, sizeof(struct mp_bus),
	    M_DEVBUF, M_NOWAIT|M_ZERO);
	mp_intrs = mallocarray(intr_cnt, sizeof(struct mp_intr_map),
	    M_DEVBUF, M_NOWAIT);

	/* re-walk the table, recording info of interest */
	position = (const u_int8_t *)mp_cth + sizeof(*mp_cth);
	count = mp_cth->entry_count;
	cur_intr = 0;

	while ((count--) && (position < end)) {
		switch (type = *(u_char *)position) {
		case MPS_MCT_CPU:
			mpbios_cpu(position, self);
			break;
		case MPS_MCT_BUS:
			mpbios_bus(position, self);
			break;
		case MPS_MCT_IOAPIC:
			mpbios_ioapic(position, self);
			break;
		case MPS_MCT_IOINT:
			iep = (const struct mpbios_int *)position;
			ie = *iep;
			if (iep->dst_apic_id == MPS_ALL_APICS) {
				for (sc = ioapics ; sc != NULL;
				     sc = sc->sc_next) {
					ie.dst_apic_id = sc->sc_apicid;
					if (mpbios_int((char *)&ie,
					    type, &mp_intrs[cur_intr]) == 0)
						cur_intr++;
				}
			} else {
				if (mpbios_int(position, type,
				    &mp_intrs[cur_intr]) == 0)
					cur_intr++;
			}
			break;
		case MPS_MCT_LINT:
			if (mpbios_int(position, type,
			    &mp_intrs[cur_intr]) == 0)
				cur_intr++;
			break;
		default:
			printf("%s: unknown entry type %x "
			    "in MP config table\n",
			    self->dv_xname, type);
			/* NOTREACHED */
			return;
		}

		position += mp_conf[type].length;
	}
	mp_nintrs = cur_intr;

	if (mp_verbose && mp_cth->ext_len)
		printf("%s: MP WARNING: %d "
		    "bytes of extended entries not examined\n",
		    self->dv_xname, mp_cth->ext_len);

	/* Clean up. */
	mp_fps = NULL;
	mpbios_unmap(&mp_fp_map);
	if (mp_cth != NULL) {
		mp_cth = NULL;
		mpbios_unmap(&mp_cfg_table_map);
	}
	mpbios_scanned = 1;

#if NPCI > 0
	mpbios_intr_fixup();
#endif
}

void
mpbios_cpu(const u_int8_t *ent, struct device *self)
{
	const struct mpbios_proc *entry = (const struct mpbios_proc *)ent;
	struct device *mainbus = self->dv_parent->dv_parent;
	struct cpu_attach_args caa;

	/* XXX move this into the CPU attachment goo. */
	/* check for usability */
	if (!(entry->cpu_flags & PROCENTRY_FLAG_EN))
		return;

	/* check for BSP flag */
	if (entry->cpu_flags & PROCENTRY_FLAG_BP)
		caa.cpu_role = CPU_ROLE_BP;
	else {
		caa.cpu_role = CPU_ROLE_AP;
		ncpusfound++;
	}

	caa.caa_name = "cpu";
	caa.cpu_apicid = entry->apic_id;
#ifdef MULTIPROCESSOR
	caa.cpu_func = &mp_cpu_funcs;
#endif

	config_found_sm(mainbus, &caa, mp_print, mp_match);
}

/*
 * The following functions conspire to compute base ioapic redirection
 * table entry for a given interrupt line.
 *
 * Fill in: trigger mode, polarity, and possibly delivery mode.
 */
void
mp_cfg_special_intr(const struct mpbios_int *entry, u_int32_t *redir)
{

	/*
	 * All of these require edge triggered, zero vector,
	 * appropriate delivery mode.
	 * see page 13 of the 82093AA datasheet.
	 */
	*redir &= ~IOAPIC_REDLO_DEL_MASK;
	*redir &= ~IOAPIC_REDLO_VECTOR_MASK;
	*redir &= ~IOAPIC_REDLO_LEVEL;

	switch (entry->int_type) {
	case MPS_INTTYPE_NMI:
		*redir |= (IOAPIC_REDLO_DEL_NMI<<IOAPIC_REDLO_DEL_SHIFT);
		break;

	case MPS_INTTYPE_SMI:
		*redir |= (IOAPIC_REDLO_DEL_SMI<<IOAPIC_REDLO_DEL_SHIFT);
		break;
	case MPS_INTTYPE_ExtINT:
		/*
		 * We are using the ioapic in "native" mode.
		 * This indicates where the 8259 is wired to the ioapic
		 * and/or local apic..
		 */
		*redir |= (IOAPIC_REDLO_DEL_EXTINT<<IOAPIC_REDLO_DEL_SHIFT);
		*redir |= (IOAPIC_REDLO_MASK);
		break;
	default:
		panic("unknown MPS interrupt type %d", entry->int_type);
	}
}

/* XXX too much duplicated code here. */

void
mp_cfg_pci_intr(const struct mpbios_int *entry, u_int32_t *redir)
{
	int mpspo = (entry->int_flags >> MPS_INTPO_SHIFT) & MPS_INTPO_MASK;
	int mpstrig = (entry->int_flags >> MPS_INTTR_SHIFT) & MPS_INTTR_MASK;

	*redir &= ~IOAPIC_REDLO_DEL_MASK;
	switch (mpspo) {
	case MPS_INTPO_ACTHI:
		*redir &= ~IOAPIC_REDLO_ACTLO;
		break;
	case MPS_INTPO_DEF:
	case MPS_INTPO_ACTLO:
		*redir |= IOAPIC_REDLO_ACTLO;
		break;
	default:
		panic("unknown MPS interrupt polarity %d", mpspo);
	}

	if (entry->int_type != MPS_INTTYPE_INT) {
		mp_cfg_special_intr(entry, redir);
		return;
	}
	*redir |= (IOAPIC_REDLO_DEL_LOPRI<<IOAPIC_REDLO_DEL_SHIFT);

	switch (mpstrig) {
	case MPS_INTTR_DEF:
	case MPS_INTTR_LEVEL:
		*redir |= IOAPIC_REDLO_LEVEL;
		break;
	case MPS_INTTR_EDGE:
		*redir &= ~IOAPIC_REDLO_LEVEL;
		break;
	default:
		panic("unknown MPS interrupt trigger %d", mpstrig);
	}
}

#ifdef X86_MPBIOS_SUPPORT_EISA
void
mp_cfg_eisa_intr(const struct mpbios_int *entry, u_int32_t *redir)
{
	int mpspo = (entry->int_flags >> MPS_INTPO_SHIFT) & MPS_INTPO_MASK;
	int mpstrig = (entry->int_flags >> MPS_INTTR_SHIFT) & MPS_INTTR_MASK;

	*redir &= ~IOAPIC_REDLO_DEL_MASK;
	switch (mpspo) {
	case MPS_INTPO_DEF:
	case MPS_INTPO_ACTHI:
		*redir &= ~IOAPIC_REDLO_ACTLO;
		break;
	case MPS_INTPO_ACTLO:
		*redir |= IOAPIC_REDLO_ACTLO;
		break;
	default:
		panic("unknown MPS interrupt polarity %d", mpspo);
	}

	if (entry->int_type != MPS_INTTYPE_INT) {
		mp_cfg_special_intr(entry, redir);
		return;
	}
	*redir |= (IOAPIC_REDLO_DEL_LOPRI<<IOAPIC_REDLO_DEL_SHIFT);

	switch (mpstrig) {
	case MPS_INTTR_LEVEL:
		*redir |= IOAPIC_REDLO_LEVEL;
		break;
	case MPS_INTTR_EDGE:
		*redir &= ~IOAPIC_REDLO_LEVEL;
		break;
	case MPS_INTTR_DEF:
		/*
		 * Set "default" setting based on ELCR value snagged
		 * earlier.
		 */
		if (mp_busses[entry->src_bus_id].mb_data &
		    (1<<entry->src_bus_irq)) {
			*redir |= IOAPIC_REDLO_LEVEL;
		} else {
			*redir &= ~IOAPIC_REDLO_LEVEL;
		}
		break;
	default:
		panic("unknown MPS interrupt trigger %d", mpstrig);
	}
}
#endif


void
mp_cfg_isa_intr(const struct mpbios_int *entry, u_int32_t *redir)
{
	int mpspo = (entry->int_flags >> MPS_INTPO_SHIFT) & MPS_INTPO_MASK;
	int mpstrig = (entry->int_flags >> MPS_INTTR_SHIFT) & MPS_INTTR_MASK;

	*redir &= ~IOAPIC_REDLO_DEL_MASK;
	switch (mpspo) {
	case MPS_INTPO_DEF:
	case MPS_INTPO_ACTHI:
		*redir &= ~IOAPIC_REDLO_ACTLO;
		break;
	case MPS_INTPO_ACTLO:
		*redir |= IOAPIC_REDLO_ACTLO;
		break;
	default:
		panic("unknown MPS interrupt polarity %d", mpspo);
	}

	if (entry->int_type != MPS_INTTYPE_INT) {
		mp_cfg_special_intr(entry, redir);
		return;
	}
	*redir |= (IOAPIC_REDLO_DEL_LOPRI << IOAPIC_REDLO_DEL_SHIFT);

	switch (mpstrig) {
	case MPS_INTTR_LEVEL:
		*redir |= IOAPIC_REDLO_LEVEL;
		break;
	case MPS_INTTR_DEF:
	case MPS_INTTR_EDGE:
		*redir &= ~IOAPIC_REDLO_LEVEL;
		break;
	default:
		panic("unknown MPS interrupt trigger %d", mpstrig);
	}
}


void
mp_print_special_intr(int intr)
{
}

void
mp_print_pci_intr(int intr)
{
	printf(" device %d INT_%c", (intr >> 2) & 0x1f, 'A' + (intr & 0x3));
}

void
mp_print_isa_intr(int intr)
{
	printf(" irq %d", intr);
}

#ifdef X86_MPBIOS_SUPPORT_EISA
void
mp_print_eisa_intr(int intr)
{
	printf(" EISA irq %d", intr);
}
#endif



#define TAB_UNIT	4
#define TAB_ROUND(a)	_TAB_ROUND(a, TAB_UNIT)

#define _TAB_ROUND(a,u)	(((a) + (u - 1)) & ~(u - 1))
#define EXTEND_TAB(a,u)	(!(_TAB_ROUND(a, u) == _TAB_ROUND((a + 1), u)))

void
mpbios_bus(const u_int8_t *ent, struct device *self)
{
	const struct mpbios_bus *entry = (const struct mpbios_bus *)ent;
	int bus_id = entry->bus_id;

	printf("%s: bus %d is type %6.6s\n", self->dv_xname,
	    bus_id, entry->bus_type);

#ifdef DIAGNOSTIC
	/*
	 * This "should not happen" unless the table changes out
	 * from underneath us
	 */
	if (bus_id >= mp_nbusses) {
		panic("%s: bus number %d out of range?? (type %6.6s)",
		    self->dv_xname, bus_id, entry->bus_type);
	}
#endif

	mp_busses[bus_id].mb_intrs = NULL;

	if (memcmp(entry->bus_type, "PCI   ", 6) == 0) {
		mp_busses[bus_id].mb_name = "pci";
		mp_busses[bus_id].mb_idx = bus_id;
		mp_busses[bus_id].mb_intr_print = mp_print_pci_intr;
		mp_busses[bus_id].mb_intr_cfg = mp_cfg_pci_intr;
#ifdef X86_MPBIOS_SUPPORT_EISA
	} else if (memcmp(entry->bus_type, "EISA  ", 6) == 0) {
		mp_busses[bus_id].mb_name = "eisa";
		mp_busses[bus_id].mb_idx = bus_id;
		mp_busses[bus_id].mb_intr_print = mp_print_eisa_intr;
		mp_busses[bus_id].mb_intr_cfg = mp_cfg_eisa_intr;

		mp_busses[bus_id].mb_data = inb(ELCR0) | (inb(ELCR1) << 8);

		if (mp_eisa_bus)
			printf("%s: multiple eisa busses?\n",
			    self->dv_xname);
		else
			mp_eisa_bus = &mp_busses[bus_id];
#endif
	} else if (memcmp(entry->bus_type, "ISA   ", 6) == 0) {
		mp_busses[bus_id].mb_name = "isa";
		mp_busses[bus_id].mb_idx = bus_id;
		mp_busses[bus_id].mb_intr_print = mp_print_isa_intr;
		mp_busses[bus_id].mb_intr_cfg = mp_cfg_isa_intr;
		if (mp_isa_bus)
			printf("%s: multiple isa busses?\n",
			    self->dv_xname);
		else
			mp_isa_bus = &mp_busses[bus_id];
	} else {
		printf("%s: unsupported bus type %6.6s\n", self->dv_xname,
		    entry->bus_type);
	}
}


void
mpbios_ioapic(const u_int8_t *ent, struct device *self)
{
	const struct mpbios_ioapic *entry = (const struct mpbios_ioapic *)ent;
	struct device *mainbus = self->dv_parent->dv_parent;
	struct apic_attach_args aaa;

	/* XXX let flags checking happen in ioapic driver.. */
	if (!(entry->apic_flags & IOAPICENTRY_FLAG_EN))
		return;

	aaa.aaa_name = "ioapic";
	aaa.apic_id = entry->apic_id;
	aaa.apic_version = entry->apic_version;
	aaa.apic_address = (paddr_t)entry->apic_address;
	aaa.apic_vecbase = -1;
	aaa.flags = (mp_fps->mpfb2 & 0x80) ? IOAPIC_PICMODE : IOAPIC_VWIRE;

	config_found_sm(mainbus, &aaa, mp_print, mp_match);
}

int
mpbios_int(const u_int8_t *ent, int enttype, struct mp_intr_map *mpi)
{
	const struct mpbios_int *entry = (const struct mpbios_int *)ent;
	struct ioapic_softc *sc = NULL, *sc2;

	struct mp_intr_map *altmpi;
	struct mp_bus *mpb;

	u_int32_t id = entry->dst_apic_id;
	u_int32_t pin = entry->dst_apic_int;
	u_int32_t bus = entry->src_bus_id;
	u_int32_t dev = entry->src_bus_irq;
	u_int32_t type = entry->int_type;
	u_int32_t flags = entry->int_flags;

	switch (type) {
	case MPS_INTTYPE_INT:
		mpb = &(mp_busses[bus]);
		break;
	case MPS_INTTYPE_ExtINT:
		mpb = &extint_bus;
		break;
	case MPS_INTTYPE_SMI:
		mpb = &smi_bus;
		break;
	case MPS_INTTYPE_NMI:
		mpb = &nmi_bus;
		break;
	default:
		panic("unknown MPS interrupt type %d", entry->int_type);
	}
	mpi->bus = mpb;
	mpi->bus_pin = dev;

	mpi->type = type;
	mpi->flags = flags;
	mpi->redir = 0;
	if (mpb->mb_intr_cfg == NULL) {
		printf("mpbios: can't find bus %d for apic %d pin %d\n",
		    bus, id, pin);
		return (1);
	}

	(*mpb->mb_intr_cfg)(entry, &mpi->redir);

	if (enttype == MPS_MCT_IOINT) {
		sc = ioapic_find(id);
		if (sc == NULL) {
			printf("mpbios: can't find ioapic %d\n", id);
			return (1);
		}

		/*
		 * XXX workaround for broken BIOSs that put the ACPI
		 * global interrupt number in the entry, not the pin
		 * number.
		 */
		if (pin >= sc->sc_apic_sz) {
			sc2 = ioapic_find_bybase(pin);
			if (sc2 != sc) {
				printf("mpbios: bad pin %d for apic %d\n",
				    pin, id);
				return (1);
			}
			printf("mpbios: WARNING: pin %d for apic %d too high; "
			       "assuming ACPI global int value\n", pin, id);
			pin -= sc->sc_apic_vecbase;
		}

		mpi->ioapic = sc;
		mpi->ioapic_pin = pin;

		altmpi = sc->sc_pins[pin].ip_map;

		if (altmpi != NULL) {
			if ((altmpi->type != type) ||
			    (altmpi->flags != flags)) {
				printf(
				    "%s: conflicting map entries for pin %d\n",
				    sc->sc_pic.pic_dev.dv_xname, pin);
			}
		} else {
			sc->sc_pins[pin].ip_map = mpi;
		}
	} else {
		if (pin >= 2)
			printf("pin %d of local apic doesn't exist!\n", pin);
		else {
			mpi->ioapic = NULL;
			mpi->ioapic_pin = pin;
			mpi->cpu_id = id;
		}
	}

	mpi->ioapic_ih = APIC_INT_VIA_APIC |
	    ((id<<APIC_INT_APIC_SHIFT) | ((pin<<APIC_INT_PIN_SHIFT)));

	if (mp_verbose) {
		printf("%s: int%d attached to %s",
		    sc ? sc->sc_pic.pic_dev.dv_xname : "local apic",
		    pin, mpb->mb_name);

		if (mpb->mb_idx != -1)
			printf("%d", mpb->mb_idx);

		(*(mpb->mb_intr_print))(dev);

		printf(" (type 0x%x flags 0x%x)\n", type, flags);
	}

	mpi->next = mpb->mb_intrs;
	mpb->mb_intrs = mpi;

	return (0);
}
@


1.26
log
@
Support for 'default configuration' mpbios attachment was never completed,
so instead of halfway configuring this mode and unconditionally panicing,
just don't attach mpbios at all if this mode is detected during probe.

ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.25 2015/06/07 12:16:27 jsg Exp $	*/
d657 1
a657 1
	caa.cpu_number = entry->apic_id;
@


1.25
log
@Add a default panic case to a switch statement where code after assumes
one of the cases was reached.  Matches other parts of the mpbios code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.24 2014/12/09 06:58:28 doug Exp $	*/
a126 5

static struct mpbios_ioapic default_ioapic = {
    2, 0, 1, IOAPICENTRY_FLAG_EN, (u_int32_t)IOAPIC_BASE_DEFAULT
};

d339 1
a339 1
		if (mp_fps->mpfb1 == 0) {
d343 4
a346 6

			goto err;
		}
		printf("%s: MP default configuration %d\n",
		    self->dv_xname, mp_fps->mpfb1);
		return (10);
d373 1
a373 1
	return (10);
d520 25
a544 35
	/* check for use of 'default' configuration */
	if (mp_fps->mpfb1 != 0) {
		struct mpbios_proc pe;

		printf("%s: MP default configuration %d\n",
		    self->dv_xname, mp_fps->mpfb1);

		/* use default addresses */
		pe.apic_id = lapic_cpu_number();
		pe.cpu_flags = PROCENTRY_FLAG_EN|PROCENTRY_FLAG_BP;
		pe.cpu_signature = cpu_info_primary.ci_signature;
		pe.feature_flags = cpu_info_primary.ci_feature_flags;

		mpbios_cpu((u_int8_t *)&pe, self);

		pe.apic_id = 1 - lapic_cpu_number();
		pe.cpu_flags = PROCENTRY_FLAG_EN;

		mpbios_cpu((u_int8_t *)&pe, self);

		mpbios_ioapic((u_int8_t *)&default_ioapic, self);

		/* XXX */
		printf("%s: WARNING: interrupts not configured\n",
		    self->dv_xname);
		panic("lazy bum");
		return;
	} else {
		/*
		 * should not happen; mp_probe returns 0 in this case,
		 * but..
		 */
		if (mp_cth == NULL)
			panic("mpbios_scan: no config (can't happen?)");

d546 3
a548 1
		 * Walk the table once, counting items
d550 6
a555 35
		position = (const u_int8_t *)(mp_cth);
		end = position + mp_cth->base_len;
		position += sizeof(*mp_cth);

		count = mp_cth->entry_count;
		intr_cnt = 0;

		while ((count--) && (position < end)) {
			type = *position;
			if (type >= MPS_MCT_NTYPES) {
				printf("%s: unknown entry type %x"
				    " in MP config table\n",
				    self->dv_xname, type);
				break;
			}
			mp_conf[type].count++;
			if (type == MPS_MCT_BUS) {
				const struct mpbios_bus *bp =
				    (const struct mpbios_bus *)position;
				if (bp->bus_id >= mp_nbusses)
					mp_nbusses = bp->bus_id + 1;
			}
			/*
			 * Count actual interrupt instances.
			 * dst_apic_id of MPS_ALL_APICS means "wired to all
			 * apics of this type".
			 */
			if (type == MPS_MCT_IOINT) {
				iep = (const struct mpbios_int *)position;
				if (iep->dst_apic_id == MPS_ALL_APICS)
					intr_cnt +=
					    mp_conf[MPS_MCT_IOAPIC].count;
				else
					intr_cnt++;
			} else if (type == MPS_MCT_LINT)
d557 4
a560 2
			position += mp_conf[type].length;
		}
d562 30
a591 35
		mp_busses = mallocarray(mp_nbusses, sizeof(struct mp_bus),
		    M_DEVBUF, M_NOWAIT|M_ZERO);
		mp_intrs = mallocarray(intr_cnt, sizeof(struct mp_intr_map),
		    M_DEVBUF, M_NOWAIT);

		/* re-walk the table, recording info of interest */
		position = (const u_int8_t *)mp_cth + sizeof(*mp_cth);
		count = mp_cth->entry_count;
		cur_intr = 0;

		while ((count--) && (position < end)) {
			switch (type = *(u_char *)position) {
			case MPS_MCT_CPU:
				mpbios_cpu(position, self);
				break;
			case MPS_MCT_BUS:
				mpbios_bus(position, self);
				break;
			case MPS_MCT_IOAPIC:
				mpbios_ioapic(position, self);
				break;
			case MPS_MCT_IOINT:
				iep = (const struct mpbios_int *)position;
				ie = *iep;
				if (iep->dst_apic_id == MPS_ALL_APICS) {
					for (sc = ioapics ; sc != NULL;
					     sc = sc->sc_next) {
						ie.dst_apic_id = sc->sc_apicid;
						if (mpbios_int((char *)&ie,
						    type, &mp_intrs[cur_intr]) == 0)
							cur_intr++;
					}
				} else {
					if (mpbios_int(position, type,
					    &mp_intrs[cur_intr]) == 0)
d594 1
a594 2
				break;
			case MPS_MCT_LINT:
a597 7
				break;
			default:
				printf("%s: unknown entry type %x "
				    "in MP config table\n",
				    self->dv_xname, type);
				/* NOTREACHED */
				return;
d599 12
a610 2

			position += mp_conf[type].length;
a611 1
		mp_nintrs = cur_intr;
d613 1
a613 4
		if (mp_verbose && mp_cth->ext_len)
			printf("%s: MP WARNING: %d "
			    "bytes of extended entries not examined\n",
			    self->dv_xname, mp_cth->ext_len);
d615 6
@


1.24
log
@Replace some malloc(n*size,...) calls with mallocarray().

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.23 2014/11/16 12:30:56 deraadt Exp $	*/
d1022 2
@


1.23
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.22 2014/05/26 19:03:28 kettenis Exp $	*/
d604 1
a604 1
		mp_busses = malloc(sizeof(struct mp_bus) * mp_nbusses,
d606 1
a606 1
		mp_intrs = malloc(sizeof(struct mp_intr_map) * intr_cnt,
@


1.22
log
@Replace some magic constants with appropriate defines.

ok krw@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.21 2011/10/21 20:48:11 kettenis Exp $	*/
d262 1
a262 1
		pmap_kenter_pa(va, pgpa, VM_PROT_READ);
@


1.21
log
@Add bounds checks for access to mp_busses.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.20 2011/04/02 22:51:53 marco Exp $	*/
d754 2
a755 2
	int mpspo = entry->int_flags & 0x03; /* XXX magic */
	int mpstrig = (entry->int_flags >> 2) & 0x03; /* XXX magic */
d793 2
a794 2
	int mpspo = entry->int_flags & 0x03; /* XXX magic */
	int mpstrig = (entry->int_flags >> 2) & 0x03; /* XXX magic */
d844 2
a845 2
	int mpspo = entry->int_flags & 0x03; /* XXX magic */
	int mpstrig = (entry->int_flags >> 2) & 0x03; /* XXX magic */
@


1.20
log
@just some spaces; no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.19 2011/03/06 22:40:05 deraadt Exp $	*/
d584 2
a585 2
				if (bp->bus_id >= mp_nbus)
					mp_nbus = bp->bus_id + 1;
d604 1
a604 1
		mp_busses = malloc(sizeof(struct mp_bus) * mp_nbus,
d927 1
a927 1
	if (bus_id >= mp_nbus) {
@


1.19
log
@The global_int information acpi collects is not used by amd64.
ok ketttenis
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.18 2009/04/21 19:18:09 kettenis Exp $	*/
d134 2
a135 2
	u_int8_t  	type;
	u_int8_t  	length;
d137 1
a137 1
	const char    	*name;
d148 4
a151 4
	vaddr_t 	baseva;
	int	 	vsize;
	paddr_t 	pa;
	paddr_t 	pg;
@


1.18
log
@Simplify PCI config space access code.  There is no way we're ever going to
see the ancient mode 2 on machines capable of running OpenBSD/amd64.

ok deraadt@@, toby@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.17 2009/04/19 17:53:39 deraadt Exp $	*/
a1024 1
	mpi->global_int = -1;
@


1.17
log
@Count number of cpus found (potentially not attached) and store that
in sysctl hw.ncpufound; ok miod kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.16 2009/01/13 19:38:44 grange Exp $	*/
d675 1
a675 2
	if (pci_mode != 0)
		mpbios_intr_fixup();
@


1.16
log
@Fix lvalue abuse by removing a redundant cast.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.15 2009/01/13 13:53:50 kettenis Exp $	*/
d695 1
a695 1
	else
d697 2
@


1.15
log
@Turn mpbios into a real device, such that people can disable it on crappy
BIOSes.

ok deraadt@@ (for the amd64 bit, or the i386 bit, can't remember which)
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.14 2008/12/22 18:01:47 kettenis Exp $	*/
d655 1
a655 1
			(u_char*)position += mp_conf[type].length;
@


1.14
log
@Get rid of many arbitrary differences between the i386 and amd64 mpbios code.
Mostly KNF issues, some reorganisation of the code.

ok dlg@@, deraadt@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.13 2008/09/15 19:24:47 kettenis Exp $	*/
d110 1
d193 28
d513 1
a513 12
	printf("%s: Intel MP Specification ", self->dv_xname);

	switch (mp_fps->spec_rev) {
	case 1:
		printf("(Version 1.1)\n");
		break;
	case 4:
		printf("(Version 1.4)\n");
		break;
	default:
		printf("(unrecognized rev %d)\n", mp_fps->spec_rev);
	}
d531 1
a531 1
		printf("\n%s: MP default configuration %d\n",
d684 1
d704 1
a704 1
	config_found_sm(self, &caa, mp_print, mp_match);
d975 1
d989 1
a989 1
	config_found_sm(self, &aaa, mp_print, mp_match);
@


1.13
log
@Make this compile if !MULTIPROCESSOR.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.12 2008/06/26 05:42:09 ray Exp $	*/
d154 2
a155 2
int mp_print(void *, const char *);
int mp_match(struct device *, void *,void *);
d157 1
a157 1
static __inline int mpbios_cksum(const void *,int);
d159 2
a160 2
void mp_cfg_special_intr(const struct mpbios_int *, u_int32_t *);
void mp_print_special_intr(int intr);
d162 2
a163 2
void mp_cfg_pci_intr(const struct mpbios_int *, u_int32_t *);
void mp_print_pci_intr(int intr);
d166 2
a167 2
void mp_print_eisa_intr(int intr);
void mp_cfg_eisa_intr(const struct mpbios_int *, u_int32_t *);
d170 2
a171 2
void mp_cfg_isa_intr(const struct mpbios_int *, u_int32_t *);
void mp_print_isa_intr (int intr);
d173 4
a176 4
void mpbios_cpu(const u_int8_t *, struct device *);
void mpbios_bus(const u_int8_t *, struct device *);
void mpbios_ioapic(const u_int8_t *, struct device *);
int mpbios_int(const u_int8_t *, int, struct mp_intr_map *);
d179 1
a179 1
void mpbios_unmap(struct mp_map *);
d195 2
a196 1
	struct cpu_attach_args * caa = (struct cpu_attach_args *) aux;
d198 1
a198 1
		printf("%s at %s:",caa->caa_name, pnp);
d205 3
a207 2
	struct cfdata *cf = (struct cfdata *)cfv;
	struct cpu_attach_args * caa = (struct cpu_attach_args *) aux;
d215 1
a215 1
 * Map a chunk of memory read-only and return an appropraitely
a217 1

d230 1
a230 1
	handle->vsize = endpa-pgpa;
d233 1
a233 1
		pmap_kenter_pa (va, pgpa, VM_PROT_READ);
d238 1
a238 1
	return (const void *)retva;
d244 2
a245 2
	pmap_kremove (handle->baseva, handle->vsize);
	uvm_km_free (kernel_map, handle->baseva, handle->vsize);
d272 1
a272 1
	mpbios_page = mpbios_map (0, PAGE_SIZE, &t);
d274 2
a275 1
	ebda =   *(const u_int16_t *) (&mpbios_page[0x40e]);
d278 1
a278 1
	memtop = *(const u_int16_t *) (&mpbios_page[0x413]);
d307 1
a307 1
	return 0;
d324 1
a324 1
		return 10;
d329 1
a329 1
	mp_cth = mpbios_map (cthpa, sizeof (*mp_cth), &mp_cfg_table_map);
d333 1
a333 1
	mp_cth = mpbios_map (cthpa, cthlen, &mp_cfg_table_map);
d351 2
a352 1
	return 10;
d362 1
a362 1
	return 0;
d400 1
a400 1
	const u_int8_t *base = mpbios_map (start, count, &t);
d404 1
a404 1
		    self->dv_xname, start, start+count-sizeof(*m));
d412 1
d414 1
a414 3
			mpbios_unmap (&t);

			return mpbios_map (start+i, len, map);
d419 1
a419 1
	return 0;
d484 1
a484 1
	printf ("%s: Intel MP Specification ", self->dv_xname);
d542 1
a542 1
			panic ("mpbios_scan: no config (can't happen?)");
d586 1
a586 1
		mp_busses = malloc(sizeof(struct mp_bus)*mp_nbus,
d588 1
a588 1
		mp_intrs = malloc(sizeof(struct mp_intr_map)*intr_cnt,
d592 1
a592 1
		position = (const u_int8_t *) mp_cth + sizeof(*mp_cth);
d597 1
a597 1
			switch (type = *(u_char *) position) {
d630 2
a631 1
				printf("%s: unknown entry type %x in MP config table\n",
d642 3
a644 3
			printf("%s: MP WARNING: %d bytes of extended entries not examined\n",
			    self->dv_xname,
			    mp_cth->ext_len);
d649 1
a649 1
	mpbios_unmap (&mp_fp_map);
d652 1
a652 1
		mpbios_unmap (&mp_cfg_table_map);
d679 1
a679 1
	caa.caa_name   = "cpu";
d694 2
a695 1
void mp_cfg_special_intr (const struct mpbios_int *entry, u_int32_t *redir)
d771 1
a771 1
mp_cfg_eisa_intr(const struct *entry, u_int32_t *redir)
d844 1
a844 1
	*redir |= (IOAPIC_REDLO_DEL_LOPRI<<IOAPIC_REDLO_DEL_SHIFT);
d859 1
d865 1
a865 1
void 
d868 1
a868 1
	printf(" device %d INT_%c", (intr>>2)&0x1f, 'A' + (intr & 0x3));
d890 2
a891 2
#define _TAB_ROUND(a,u)	(((a) + (u - 1)) & ~(u-1))
#define EXTEND_TAB(a,u)	(!(_TAB_ROUND(a,u) == _TAB_ROUND((a+1),u)))
d899 2
a900 1
	printf("mpbios: bus %d is type %6.6s\n", bus_id, entry->bus_type);
d908 2
a909 2
		panic("mpbios: bus number %d out of range?? (type %6.6s)",
		    bus_id, entry->bus_type);
d927 1
a927 2
		mp_busses[bus_id].mb_data =
		    inb(ELCR0) | (inb(ELCR1) << 8);
d930 1
a930 1
			printf("%s: multiple isa busses?\n",
a934 1

d962 1
a962 1
	aaa.aaa_name   = "ioapic";
d967 1
a967 1
	aaa.flags =  (mp_fps->mpfb2 & 0x80) ? IOAPIC_PICMODE : IOAPIC_VWIRE;
d1049 2
a1050 1
				printf("%s: conflicting map entries for pin %d\n",
a1069 1

@


1.12
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.11 2007/11/16 16:16:07 deraadt Exp $	*/
d678 1
d680 1
@


1.11
log
@fix the bus_space #define nightmare, so that amd64 and i386 are much more
uniform. as a result shared code like acpi needs less #ifdef's
ok marco kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.10 2007/09/17 15:34:38 chl Exp $	*/
a20 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.10
log
@MALLOC/FREE -> malloc/free and M_ZERO changes

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.9 2007/01/15 23:19:05 jsg Exp $	*/
d643 1
a643 1
		mp_nintr = cur_intr;
@


1.9
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.8 2006/11/25 16:59:31 niklas Exp $	*/
d592 1
a592 2
		    M_DEVBUF, M_NOWAIT);
		memset(mp_busses, 0, sizeof(struct mp_bus) * mp_nbus);
@


1.8
log
@sync amd64 to i386 w.r.t. acpi support. Also fix interrupt routing for multi-ioapic systems.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.7 2006/10/03 22:39:40 gwk Exp $	*/
d200 1
a200 3
mp_print(aux, pnp)
	void *aux;
	const char *pnp;
d209 1
a209 4
mp_match(parent, cfv, aux)
	struct device *parent;
	void *cfv;
	void *aux;
d225 1
a225 4
mpbios_map(pa, len, handle)
	paddr_t pa;
	int len;
	struct mp_map *handle;
d248 1
a248 2
mpbios_unmap(handle)
	struct mp_map *handle;
d258 1
a258 2
mpbios_probe(self)
	struct device *self;
d375 1
a375 3
mpbios_cksum (start, len)
	const void *start;
	int len;
d397 1
a397 5
mpbios_search (self, start, count, map)
	struct device *self;
	paddr_t start;
	int count;
	struct mp_map *map;
d478 1
a478 2
mpbios_scan(self)
	struct device *self;
d668 1
a668 3
mpbios_cpu(ent, self)
	const u_int8_t *ent;
	struct device *self;
d697 1
a697 3
void mp_cfg_special_intr (entry, redir)
	const struct mpbios_int *entry;
	u_int32_t *redir;
d733 2
a734 3
void mp_cfg_pci_intr (entry, redir)
	const struct mpbios_int *entry;
	u_int32_t *redir;
d772 2
a773 3
void mp_cfg_eisa_intr (entry, redir)
	const struct mpbios_int *entry;
	u_int32_t *redir;
d823 2
a824 3
void mp_cfg_isa_intr (entry, redir)
	const struct mpbios_int *entry;
	u_int32_t *redir;
d862 1
a862 2
mp_print_special_intr (intr)
	int intr;
d867 1
a867 2
mp_print_pci_intr (intr)
	int intr;
d873 1
a873 2
mp_print_isa_intr (intr)
	int intr;
d880 1
a880 2
mp_print_eisa_intr (intr)
	int intr;
d895 1
a895 3
mpbios_bus(ent, self)
	const u_int8_t *ent;
	struct device *self;
d955 1
a955 3
mpbios_ioapic(ent, self)
	const u_int8_t *ent;
	struct device *self;
d975 1
a975 4
mpbios_int(ent, enttype, mpi)
	const u_int8_t *ent;
	int enttype;
	struct mp_intr_map *mpi;
@


1.7
log
@Cease printing mpbios vendor/version strings on AMD64 as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.6 2006/05/29 20:40:55 miod Exp $	*/
d279 7
d960 3
a962 2
		if (mp_eisa_bus != -1)
			printf("oops: multiple isa busses?\n");
d964 1
a964 1
			mp_eisa_bus = bus_id;
d969 1
a969 1
		mp_busses[bus_id].mb_idx = 0; /* XXX */
d972 3
a974 2
		if (mp_isa_bus != -1)
			printf("oops: multiple isa busses?\n");
d976 1
a976 1
			mp_isa_bus = bus_id;
@


1.6
log
@Remove unused NetBSD new-style %b strings.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.5 2006/04/21 20:13:26 kettenis Exp $	*/
d503 1
a503 1
		printf("(Version 1.1)");
d506 1
a506 1
		printf("(Version 1.4)");
d509 1
a509 1
		printf("(unrecognized rev %d)", mp_fps->spec_rev);
a557 3

		printf(" (%8.8s %12.12s)\n",
		    mp_cth->oem_id, mp_cth->product_id);
@


1.5
log
@Do not leave behind half-initialized data structures of we stumble over corrupt
interrupt table entries.
ok brad@@, mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.4 2006/03/22 21:16:00 kettenis Exp $	*/
a998 7

static const char inttype_fmt[] = "\177\020"
		"f\0\2type\0" "=\1NMI\0" "=\2SMI\0" "=\3ExtINT\0";

static const char flagtype_fmt[] = "\177\020"
		"f\0\2pol\0" "=\1Act Hi\0" "=\3Act Lo\0"
		"f\2\2trig\0" "=\1Edge\0" "=\3Level\0";
@


1.4
log
@Fixup broken mpbios'es on VT8237 and nForce4 chipsets.  Fixes interrupt
routing for SATA on those chipsets in GENERIC.MP.
ok mickey@@, brad@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.3 2005/10/21 18:55:00 martin Exp $	*/
d183 1
a183 1
void mpbios_int(const u_int8_t *, int, struct mp_intr_map *);
a608 1
		mp_nintr = intr_cnt;
d633 4
a636 2
						mpbios_int((char *)&ie, type,
						    &mp_intrs[cur_intr++]);						}
d638 3
a640 2
					mpbios_int(position, type,
					    &mp_intrs[cur_intr++]);
d644 3
a646 3
				mpbios_int(position, type,
				    &mp_intrs[cur_intr]);
				cur_intr++;
d657 2
d664 1
d1007 1
a1007 1
void
a1039 2
	mpi->next = mpb->mb_intrs;
	mpb->mb_intrs = mpi;
d1050 1
a1050 1
		return;
d1059 1
a1059 1
			return;
d1072 1
a1072 1
				return;
d1119 5
@


1.3
log
@use the MI trunc_page() and round_page() macros instead of rolling or own

ok weingart@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.2 2005/07/18 02:43:24 fgsch Exp $	*/
d125 1
d131 2
d668 5
@


1.2
log
@remove trailing newline in panic(9); ok millert@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.1 2004/06/25 11:03:27 art Exp $	*/
d232 2
a233 2
	paddr_t pgpa = x86_trunc_page(pa);
	paddr_t endpa = x86_round_page(pa + len);
@


1.1
log
@SMP support. Big parts from NetBSD, but with some really serious debugging
done by me, niklas and others. Especially wrt. NXE support.

Still needs some polishing, especially in dmesg messages, but we're now
building kernel faster than ever.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d921 1
a921 1
		panic("mpbios: bus number %d out of range?? (type %6.6s)\n",
@

