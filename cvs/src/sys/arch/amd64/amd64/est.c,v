head	1.39;
access;
symbols
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.39.0.2
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.38.0.2
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.36.0.4
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.33.0.4
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.29.0.8
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.29.0.4
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.29.0.2
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.28.0.2
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.4
	OPENBSD_5_0:1.25.0.2
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.24.0.2
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.21.0.2
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.13.0.4
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.7.0.2
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.5.0.4
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.2
	OPENBSD_4_2_BASE:1.5;
locks; strict;
comment	@ * @;


1.39
date	2016.03.06.22.41.24;	author naddy;	state Exp;
branches;
next	1.38;
commitid	m1enxPveYSHWYNdC;

1.38
date	2015.09.08.04.28.34;	author semarie;	state Exp;
branches;
next	1.37;
commitid	Ajpcv6B3UUP5Q4Cd;

1.37
date	2015.08.28.00.03.53;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	NdgfPIGUgJxQPnT7;

1.36
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.35;
commitid	p4LJxGKbi0BU2cG6;

1.35
date	2014.12.09.06.58.28;	author doug;	state Exp;
branches;
next	1.34;
commitid	yWAxzpQP2PPpYlfT;

1.34
date	2014.09.14.14.17.23;	author jsg;	state Exp;
branches;
next	1.33;
commitid	uzzBR7hz9ncd4O6G;

1.33
date	2014.07.12.18.44.41;	author tedu;	state Exp;
branches;
next	1.32;
commitid	uKVPYMN2MLxdZxzH;

1.32
date	2014.05.23.03.30.41;	author guenther;	state Exp;
branches;
next	1.31;

1.31
date	2014.05.10.18.59.29;	author guenther;	state Exp;
branches;
next	1.30;

1.30
date	2014.03.16.05.19.44;	author jsg;	state Exp;
branches;
next	1.29;

1.29
date	2012.10.08.09.01.21;	author jsg;	state Exp;
branches;
next	1.28;

1.28
date	2012.03.27.07.04.33;	author jsg;	state Exp;
branches;
next	1.27;

1.27
date	2012.03.19.00.49.08;	author jsg;	state Exp;
branches;
next	1.26;

1.26
date	2012.02.25.00.19.20;	author haesbaert;	state Exp;
branches;
next	1.25;

1.25
date	2011.04.19.22.14.54;	author jsg;	state Exp;
branches;
next	1.24;

1.24
date	2011.01.28.05.03.10;	author dlg;	state Exp;
branches;
next	1.23;

1.23
date	2011.01.27.21.27.44;	author jsg;	state Exp;
branches;
next	1.22;

1.22
date	2010.12.29.18.10.17;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2010.07.05.22.47.41;	author jsg;	state Exp;
branches;
next	1.20;

1.20
date	2010.06.04.15.03.34;	author jsg;	state Exp;
branches;
next	1.19;

1.19
date	2010.04.20.22.05.41;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2010.03.28.03.09.50;	author marco;	state Exp;
branches;
next	1.17;

1.17
date	2009.12.01.18.59.13;	author jsg;	state Exp;
branches;
next	1.16;

1.16
date	2009.12.01.18.31.36;	author jsg;	state Exp;
branches;
next	1.15;

1.15
date	2009.11.22.20.13.12;	author jsg;	state Exp;
branches;
next	1.14;

1.14
date	2009.07.27.11.28.55;	author dms;	state Exp;
branches;
next	1.13;

1.13
date	2009.06.08.23.18.05;	author gwk;	state Exp;
branches;
next	1.12;

1.12
date	2009.06.06.23.21.43;	author gwk;	state Exp;
branches;
next	1.11;

1.11
date	2009.04.23.07.30.03;	author jsg;	state Exp;
branches;
next	1.10;

1.10
date	2009.02.24.19.32.37;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2009.02.24.13.19.59;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2008.11.22.16.03.31;	author gwk;	state Exp;
branches;
next	1.7;

1.7
date	2008.08.06.05.24.44;	author gwk;	state Exp;
branches;
next	1.6;

1.6
date	2008.06.15.05.24.07;	author gwk;	state Exp;
branches;
next	1.5;

1.5
date	2007.06.07.11.20.58;	author dim;	state Exp;
branches;
next	1.4;

1.4
date	2007.06.04.06.57.57;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2007.06.03.04.30.31;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2007.06.01.22.28.21;	author tedu;	state Exp;
branches;
next	1.1;

1.1
date	2007.05.29.06.31.44;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.39
log
@Sync no-argument function declaration and definition by adding (void).
ok kettenis@@ mpi@@
@
text
@/*	$OpenBSD: est.c,v 1.38 2015/09/08 04:28:34 semarie Exp $ */
/*
 * Copyright (c) 2003 Michael Eriksson.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


/*
 * This is a driver for Intel's Enhanced SpeedStep, as implemented in
 * Pentium M processors.
 *
 * Reference documentation:
 *
 * - IA-32 Intel Architecture Software Developer's Manual, Volume 3:
 *   System Programming Guide.
 *   Section 13.14, Enhanced Intel SpeedStep technology.
 *   Table B-2, MSRs in Pentium M Processors.
 *   http://www.intel.com/design/pentium4/manuals/245472.htm
 *
 * - Intel Pentium M Processor Datasheet.
 *   Table 5, Voltage and Current Specifications.
 *   http://www.intel.com/design/mobile/datashts/252612.htm
 *
 * - Intel Pentium M Processor on 90 nm Process with 2-MB L2 Cache Datasheet
 *   Table 3-4, Voltage and Current Specifications.
 *   http://www.intel.com/design/mobile/datashts/302189.htm
 *
 * - Linux cpufreq patches, speedstep-centrino.c.
 *   Encoding of MSR_PERF_CTL and MSR_PERF_STATUS.
 *   http://www.codemonkey.org.uk/projects/cpufreq/cpufreq-2.4.22-pre6-1.gz
 */


#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sysctl.h>
#include <sys/malloc.h>

#include <machine/cpu.h>
#include <machine/cpufunc.h>
#include <machine/specialreg.h>
#include <machine/bus.h>

#include "acpicpu.h"

#if NACPICPU > 0
#include <dev/acpi/acpidev.h>
#endif

/* Possible bus speeds (multiplied by 100 for rounding) */
#define BUS100 10000
#define BUS133 13333
#define BUS166 16667
#define BUS200 20000
#define BUS266 26667
#define BUS333 33333

#define MSR2MHZ(msr, bus) \
	(((((int)(msr) >> 8) & 0xff) * (bus) + 50) / 100)

struct est_op {
	uint16_t ctrl;
	uint16_t mhz;
};

struct fqlist {
	int vendor: 5;
	unsigned bus_clk : 1;
	unsigned n : 5;
	struct est_op *table;
};


static struct fqlist *est_fqlist;

extern int setperf_prio;
extern int perflevel;

int bus_clock;

void p4_get_bus_clock(struct cpu_info *);
void p3_get_bus_clock(struct cpu_info *);

void
p4_get_bus_clock(struct cpu_info *ci)
{
	u_int64_t msr;
	int model, bus;

	model = (ci->ci_signature >> 4) & 15;
	msr = rdmsr(MSR_EBC_FREQUENCY_ID);
	if (model < 2) {
		bus = (msr >> 21) & 0x7;
		switch (bus) {
		case 0:
			bus_clock = BUS100;
			break;
		case 1:
			bus_clock = BUS133;
			break;
		default:
			printf("%s: unknown Pentium 4 (model %d) "
			    "EBC_FREQUENCY_ID value %d\n",
			    ci->ci_dev->dv_xname, model, bus);
			break;
		}
	} else {
		bus = (msr >> 16) & 0x7;
		switch (bus) {
		case 0:
			bus_clock = (model == 2) ? BUS100 : BUS266;
			break;
		case 1:
			bus_clock = BUS133;
			break;
		case 2:
			bus_clock = BUS200;
			break;
		case 3:
			bus_clock = BUS166;
			break;
		default:
			printf("%s: unknown Pentium 4 (model %d) "
			    "EBC_FREQUENCY_ID value %d\n",
			    ci->ci_dev->dv_xname, model, bus);
			break;
		}
	}
}

void
p3_get_bus_clock(struct cpu_info *ci)
{
	u_int64_t msr;
	int bus;

	switch (ci->ci_model) {
	case 0xe: /* Core Duo/Solo */
	case 0xf: /* Core Xeon */
	case 0x16: /* 65nm Celeron */
	case 0x17: /* Core 2 Extreme/45nm Xeon */
	case 0x1d: /* Xeon MP 7400 */
		msr = rdmsr(MSR_FSB_FREQ);
		bus = (msr >> 0) & 0x7;
		switch (bus) {
		case 5:
			bus_clock = BUS100;
			break;
		case 1:
			bus_clock = BUS133;
			break;
		case 3:
			bus_clock = BUS166;
			break;
		case 2:
			bus_clock = BUS200;
			break;
		case 0:
			bus_clock = BUS266;
			break;
		case 4:
			bus_clock = BUS333;
			break;
		default:
			printf("%s: unknown Core FSB_FREQ value %d",
			    ci->ci_dev->dv_xname, bus);
			break;
		}
		break;
	case 0x1c: /* Atom */
	case 0x26: /* Atom Z6xx */
	case 0x36: /* Atom [DN]2xxx */
		msr = rdmsr(MSR_FSB_FREQ);
		bus = (msr >> 0) & 0x7;
		switch (bus) {
		case 5:
			bus_clock = BUS100;
			break;
		case 1:
			bus_clock = BUS133;
			break;
		case 3:
			bus_clock = BUS166;
			break;
		case 2:
			bus_clock = BUS200;
			break;
		default:
			printf("%s: unknown Atom FSB_FREQ value %d",
			    ci->ci_dev->dv_xname, bus);
			break;
		}
		break;
	default:
		/* no FSB on modern Intel processors */
		break;
	}
}

#if NACPICPU > 0
struct fqlist * est_acpi_init(void);
void est_acpi_pss_changed(struct acpicpu_pss *, int);

struct fqlist *
est_acpi_init(void)
{
	struct acpicpu_pss *pss;
	struct fqlist *acpilist;
	int nstates, i;

	if ((nstates = acpicpu_fetch_pss(&pss)) == 0)
		goto nolist;

	if ((acpilist = malloc(sizeof(struct fqlist), M_DEVBUF, M_NOWAIT))
	    == NULL)
		goto nolist;

	if ((acpilist->table = mallocarray(nstates, sizeof(struct est_op),
	    M_DEVBUF, M_NOWAIT)) == NULL)
		goto notable;

	acpilist->n = nstates;

	for (i = 0; i < nstates; i++) {
		acpilist->table[i].mhz = pss[i].pss_core_freq;
		acpilist->table[i].ctrl = pss[i].pss_ctrl;
	}

	acpicpu_set_notify(est_acpi_pss_changed);

	return acpilist;

notable:
	free(acpilist, M_DEVBUF, sizeof(struct fqlist));
	acpilist = NULL;
nolist:
	return NULL;
}

void
est_acpi_pss_changed(struct acpicpu_pss *pss, int npss)
{
	struct fqlist *acpilist;
	int needtran = 1, i;
	u_int64_t msr;
	u_int16_t cur;

	msr = rdmsr(MSR_PERF_STATUS);
	cur = msr & 0xffff;

	if ((acpilist = malloc(sizeof(struct fqlist), M_DEVBUF, M_NOWAIT))
	    == NULL) {
		printf("est_acpi_pss_changed: cannot allocate memory for new "
		    "est state");
		return;
	}

	if ((acpilist->table = mallocarray(npss, sizeof(struct est_op),
	    M_DEVBUF, M_NOWAIT)) == NULL) {
		printf("est_acpi_pss_changed: cannot allocate memory for new "
		    "operating points");
		free(acpilist, M_DEVBUF, sizeof(struct fqlist));
		return;
	}

	for (i = 0; i < npss; i++) {
		acpilist->table[i].mhz = pss[i].pss_core_freq;
		acpilist->table[i].ctrl = pss[i].pss_ctrl;
		if (pss[i].pss_ctrl == cur)
			needtran = 0;
	}

	free(est_fqlist->table, M_DEVBUF, npss * sizeof(struct est_op));
	free(est_fqlist, M_DEVBUF, sizeof(struct fqlist));
	est_fqlist = acpilist;

	if (needtran) {
		est_setperf(perflevel);
	}
}
#endif

void
est_init(struct cpu_info *ci)
{
	const char *cpu_device = ci->ci_dev->dv_xname;
	int vendor = -1;
	int i, low, high;
	u_int64_t msr;
	u_int16_t idhi, idlo, cur;
	u_int8_t crhi, crlo, crcur;
	struct fqlist *fake_fqlist;
	struct est_op *fake_table;

	if (setperf_prio > 3)
		return;

#if NACPICPU > 0
	est_fqlist = est_acpi_init();
#endif

	/* bus_clock is only used if we can't get values from ACPI */
	if (est_fqlist == NULL) {
		if (ci->ci_family == 0xf)
			p4_get_bus_clock(ci);
		else if (ci->ci_family == 6)
			p3_get_bus_clock(ci);
	}

	/*
	 * Interpreting the values of PERF_STATUS is not valid
	 * on recent processors so don't do it on anything unknown
	 */
	if (est_fqlist == NULL && bus_clock != 0) {
		msr = rdmsr(MSR_PERF_STATUS);
		idhi = (msr >> 32) & 0xffff;
		idlo = (msr >> 48) & 0xffff;
		cur = msr & 0xffff;
		crhi = (idhi  >> 8) & 0xff;
		crlo = (idlo  >> 8) & 0xff;
		crcur = (cur >> 8) & 0xff;

		if (crhi == 0 || crcur == 0 || crlo > crhi ||
		    crcur < crlo || crcur > crhi) {
			/*
			 * Do complain about other weirdness, because we first
			 * want to know about it, before we decide what to do
			 * with it.
			 */
			printf("%s: EST: strange msr value 0x%016llx\n",
			    cpu_device, msr);
			return;
		}
		if (crlo == 0 || crhi == crlo) {
			/*
			 * Don't complain about these cases, and silently
			 * disable EST: - A lowest clock ratio of 0, which
			 * seems to happen on all Pentium 4's that report EST.
			 * - An equal highest and lowest clock ratio, which
			 * happens on at least the Core 2 Duo X6800, maybe on 
			 * newer models too.
			 */
			return;
		}

		printf("%s: unknown Enhanced SpeedStep CPU, msr 0x%016llx\n",
		    cpu_device, msr);
		/*
		 * Generate a fake table with the power states we know.
		 */

		if ((fake_fqlist = malloc(sizeof(struct fqlist), M_DEVBUF,
		    M_NOWAIT)) == NULL) {
			printf("%s: EST: cannot allocate memory for fake "
			    "list\n", cpu_device);
			return;
		}


		if ((fake_table = mallocarray(3, sizeof(struct est_op),
		    M_DEVBUF, M_NOWAIT)) == NULL) {
			free(fake_fqlist, M_DEVBUF, sizeof(struct fqlist));
			printf("%s: EST: cannot allocate memory for fake "
			    "table\n", cpu_device);
			return;
		}
		fake_table[0].ctrl = idhi;
		fake_table[0].mhz = MSR2MHZ(idhi, bus_clock);
		if (cur == idhi || cur == idlo) {
			printf("%s: using only highest and lowest power "
			       "states\n", cpu_device);

			fake_table[1].ctrl = idlo;
			fake_table[1].mhz = MSR2MHZ(idlo, bus_clock);
			fake_fqlist->n = 2;
		} else {
			printf("%s: using only highest, current and lowest "
			    "power states\n", cpu_device);

			fake_table[1].ctrl = cur;
			fake_table[1].mhz = MSR2MHZ(cur, bus_clock);

			fake_table[2].ctrl = idlo;
			fake_table[2].mhz = MSR2MHZ(idlo, bus_clock);
			fake_fqlist->n = 3;
		}

		fake_fqlist->vendor = vendor;
		fake_fqlist->table = fake_table;
		est_fqlist = fake_fqlist;
	}

	if (est_fqlist == NULL)
		return;

	if (est_fqlist->n < 2)
		goto nospeedstep;

	low = est_fqlist->table[est_fqlist->n - 1].mhz;
	high = est_fqlist->table[0].mhz;
	if (low == high)
		goto nospeedstep;

	perflevel = (cpuspeed - low) * 100 / (high - low);

	printf("%s: Enhanced SpeedStep %d MHz", cpu_device, cpuspeed);

	/*
	 * OK, tell the user the available frequencies.
	 */
	printf(": speeds: ");
	for (i = 0; i < est_fqlist->n; i++)
		printf("%d%s", est_fqlist->table[i].mhz, i < est_fqlist->n - 1
		    ?  ", " : " MHz\n");

	cpu_setperf = est_setperf;
	setperf_prio = 3;

	return;

nospeedstep:
	free(est_fqlist->table, M_DEVBUF, 0);
	free(est_fqlist, M_DEVBUF, sizeof(*est_fqlist));
}

void
est_setperf(int level)
{
	int i;
	uint64_t msr;

	if (est_fqlist == NULL)
		return;

	i = ((level * est_fqlist->n) + 1) / 101;
	if (i >= est_fqlist->n)
		i = est_fqlist->n - 1;
	i = est_fqlist->n - 1 - i;

	msr = rdmsr(MSR_PERF_CTL);
	msr &= ~0xffffULL;
	msr |= est_fqlist->table[i].ctrl;

	wrmsr(MSR_PERF_CTL, msr);
	cpuspeed = est_fqlist->table[i].mhz;
}
@


1.38
log
@convert several malloc(9) to mallocarray(9).

ok deraadt@@ guenther@@ "re-wrap the long lines" kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.37 2015/08/28 00:03:53 deraadt Exp $ */
d227 1
a227 1
est_acpi_init()
@


1.37
log
@fairly simple sizes for free(); ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.36 2015/03/14 03:38:46 jsg Exp $ */
d382 2
a383 2
		if ((fake_table = malloc(sizeof(struct est_op) * 3, M_DEVBUF,
		     M_NOWAIT)) == NULL) {
@


1.36
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.35 2014/12/09 06:58:28 doug Exp $ */
d256 1
a256 1
	free(acpilist, M_DEVBUF, 0);
d284 1
a284 1
		free(acpilist, M_DEVBUF, 0);
d295 2
a296 2
	free(est_fqlist->table, M_DEVBUF, 0);
	free(est_fqlist, M_DEVBUF, 0);
d384 1
a384 1
			free(fake_fqlist, M_DEVBUF, 0);
d445 1
a445 1
	free(est_fqlist, M_DEVBUF, 0);
@


1.35
log
@Replace some malloc(n*size,...) calls with mallocarray().

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.34 2014/09/14 14:17:23 jsg Exp $ */
a69 1
#include <dev/acpi/acpivar.h>
@


1.34
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.33 2014/07/12 18:44:41 tedu Exp $ */
d241 1
a241 1
	if ((acpilist->table = malloc(sizeof(struct est_op) * nstates,
d281 1
a281 1
	if ((acpilist->table = malloc(sizeof(struct est_op) * npss,
@


1.33
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.32 2014/05/23 03:30:41 guenther Exp $ */
a57 1
#include <sys/proc.h>
@


1.32
log
@Free the est_fqlist allocations if we end up not using it.

suggested by Benjamin Baier (programmer (at) netzbasis.de)
ok and comment suggestion kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.31 2014/05/10 18:59:29 guenther Exp $ */
d258 1
a258 1
	free(acpilist, M_DEVBUF);
d286 1
a286 1
		free(acpilist, M_DEVBUF);
d297 2
a298 2
	free(est_fqlist->table, M_DEVBUF);
	free(est_fqlist, M_DEVBUF);
d386 1
a386 1
			free(fake_fqlist, M_DEVBUF);
d446 2
a447 2
	free(est_fqlist->table, M_DEVBUF);
	free(est_fqlist, M_DEVBUF);
@


1.31
log
@Disable speedstep instead of panicing if the high and low speeds are the same.

Problem noted by Benjamin Baier (programmer (at) netzbasis.de)
improvements and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.30 2014/03/16 05:19:44 jsg Exp $ */
d421 1
a421 1
		return;
d426 1
a426 1
		return;
d442 6
@


1.30
log
@Remove warnings on unknown x86 models in the code that returns the FSB
speed and remove the no-op cases added to avoid the warning.

We shouldn't normally hit the warning anyway, the bus speed is only
used on older i386 machines with piixpcib/ichpcib based speedstep or
to create a fake high/low table with newer style speedstep when we
can't get the table from ACPI.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.29 2012/10/08 09:01:21 jsg Exp $ */
a422 2
	printf("%s: Enhanced SpeedStep %d MHz", cpu_device, cpuspeed);

d425 3
d429 2
@


1.29
log
@reduce the difference between i386 and amd64 versions of the speedstep code
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.28 2012/03/27 07:04:33 jsg Exp $ */
d218 2
a219 14
	/* nehalem */
	case 0x1a: /* Core i7, Xeon 3500/5500 */
	case 0x1e: /* Core i5/i7, Xeon 3400 */
	case 0x1f: /* Core i5/i7 */
	case 0x2e: /* Xeon 6500/7500 */
	/* westmere */
	case 0x25: /* Core i3/i5, Xeon 3400 */
	case 0x2c: /* Core i7, Xeon 3600/5600 */
	case 0x2f: /* Xeon E7 */
	/* sandy bridge */
	case 0x2a: /* Core i5/i7 2nd Generation */
	case 0x2d: /* Xeon E5 */
	/* ivy bridge */
	case 0x3a: /* Core i3/i5/i7 3rd Generation */
a220 3
	default:
		printf("%s: unknown i686 model 0x%x, can't get bus clock\n",
		    ci->ci_dev->dv_xname, ci->ci_model);
@


1.28
log
@only attempt to calculate bus_clock if we can't get tables from acpi
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.27 2012/03/19 00:49:08 jsg Exp $ */
a73 4
/* Convert MHz and mV into IDs for passing to the MSR. */
#define ID16(MHz, mV, bus_clk) \
	((((MHz * 100 + 50) / bus_clk) << 8) | ((mV ? mV - 700 : 0) >> 4))

d292 2
a293 2
		printf("est_acpi_pss_changed: cannot allocate memory for new"
		    " est state");
d299 2
a300 2
		printf("est_acpi_pss_changed: cannot allocate memory for new"
		    " operating points");
d393 2
a394 2
			printf("%s: cannot allocate memory for fake list",
			    cpu_device);
d402 2
a403 2
			printf("%s: cannot allocate memory for fake table",
			    cpu_device);
d450 1
a450 1
		       ?  ", " : " MHz\n");
@


1.27
log
@more intel cpu models, though the low/high est method is largely
irrelevant with acpi machines
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.26 2012/02/25 00:19:20 haesbaert Exp $ */
d344 7
a350 4
	if (ci->ci_family == 0xf) {
		p4_get_bus_clock(ci);
	} else if (ci->ci_family == 6) {
		p3_get_bus_clock(ci);
@


1.26
log
@Remove useless code.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.25 2011/04/19 22:14:54 jsg Exp $ */
d170 1
d199 2
d222 1
d226 2
d230 2
a231 2
		/* BUS133 */
		break;
d234 2
a235 4
		/* BUS100 */
		break;
	case 0x1d: /* Xeon MP 7400 */
	case 0x2e: /* Xeon 6500/7500 */
@


1.25
log
@add some more intel cpuid models
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.24 2011/01/28 05:03:10 dlg Exp $ */
a65 3

#define CPUVENDOR_INTEL 0
#define CPUVENDOR_VIA 8
@


1.24
log
@you use ; to end a statement, not a :.
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.23 2011/01/27 21:27:44 jsg Exp $ */
d224 1
d227 7
@


1.23
log
@Atom uses the same value for bus clock 200 MHz as Core, though
this is not documented by Intel.

tested by henning on d525
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.22 2010/12/29 18:10:17 kettenis Exp $ */
d214 1
a214 1
			bus_clock = BUS200:
@


1.22
log
@Bus clock doesn't matter on the Xeon 3600/5600 and Xeon 6500/7500, so don't
print the "can't get bus clock" message.  While there, adjust comments for
the i3/i5/i7 CPUs and include the relevant Xeon models.  The Intel marketing
people seem to have less influence on the Xeon names, so they describe the
CPU generation much better.

ok marco@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.21 2010/07/05 22:47:41 jsg Exp $ */
d212 3
@


1.21
log
@Rework somewhat for safety, so that we only interpret the values of
the PERF_STATUS MSR on earlier processors when we can't find the values
via acpi and have a bus clock value to use.  And let processors we
don't set a bus clock on (ie nehalem) use speedstep again.

Expanded/changed version of a diff from gwk who isn't around right now.
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.20 2010/06/04 15:03:34 jsg Exp $ */
d219 5
a223 3
	case 0x1a: /* Core i7 */
	case 0x1e: /* Core i5 */
	case 0x25: /* Core i3 */
@


1.20
log
@Don't warn about not knowing what the bus clock is on core i7/i5/i3
as the high/low guessing won't be done on these processors due to MSR
differences.
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.19 2010/04/20 22:05:41 tedu Exp $ */
d317 1
a317 1
	int i, low, high, family;
d327 4
a330 2
	family = (ci->ci_signature >> 8) & 15;
	if (family == 0xf) {
d332 1
a332 1
	} else if (family == 6) {
d336 5
a340 17
	if (bus_clock == 0) {
		printf("%s: EST: PSS not yet available for this processor\n",
		    cpu_device);
		return;
	}

#if NACPICPU > 0
	est_fqlist = est_acpi_init();
#endif

	if (est_fqlist == NULL) {
		if (bus_clock == 0) {
			printf("%s: EST: unknown system bus clock\n",
			    cpu_device);
			return;
		}

@


1.19
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.18 2010/03/28 03:09:50 marco Exp $ */
d218 4
@


1.18
log
@Remove uninitialized nitems and use npss as $deity intended.
Found by clang and krw

ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.17 2009/12/01 18:59:13 jsg Exp $ */
d58 1
@


1.17
log
@Don't claim to know about nehalem until we can be sure
the the msr paths are sane.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.16 2009/12/01 18:31:36 jsg Exp $ */
d268 1
a268 1
	int needtran = 1, nstates, i;
d282 1
a282 1
	if ((acpilist->table = malloc(sizeof(struct est_op) * nstates,
d290 1
a290 1
	for (i = 0; i < nstates; i++) {
@


1.16
log
@The MD ACPI PSS paths are using MSRs they shouldn't be
so don't try to do EST on machines we don't know the
bus_clock on for now.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.15 2009/11/22 20:13:12 jsg Exp $ */
a197 3
		break;
	case 0x1a: /* Nehalem based Core i7 and Xeon */
		bus_clock = BUS133; 
@


1.15
log
@Match the i386 behaviour and only care about bus_clock if we
don't have the tables from acpi.  This way we don't have
to have knowledge of the cpu model to do speedstep in the acpi case.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.14 2009/07/27 11:28:55 dms Exp $ */
d330 6
@


1.14
log
@add bus speed recognition on Nehalem based cpus, this
makes Enhanced SpeedStep work on new machines, but requires
acpimadt0 to be enabled.

ok by jsg@@ and claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.13 2009/06/08 23:18:05 gwk Exp $ */
d199 3
a201 3
       case 0x1a: /* Nehalem based Core i7 and Xeon */
               bus_clock = BUS133; 
               break;
a330 12
	if (bus_clock == 0) {
		printf("%s: EST: unknown system bus clock\n", cpu_device);
		return;
	}

	msr = rdmsr(MSR_PERF_STATUS);
	idhi = (msr >> 32) & 0xffff;
	idlo = (msr >> 48) & 0xffff;
	cur = msr & 0xffff;
	crhi = (idhi  >> 8) & 0xff;
	crlo = (idlo  >> 8) & 0xff;
	crcur = (cur >> 8) & 0xff;
d337 14
d362 1
a362 1
		if   (crlo == 0 || crhi == crlo) {
@


1.13
log
@If the machine only has one state enabling the EST driver is pointless,
this might need to be revisted later if its clear that there are machines
which only come up with a single state but more may appear after a PPC
change but for now we will just not initilize on systems with a single
state a boot. Solves a divide by zero panic when using the PDC diff on
broken hardware.

ok marco@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.12 2009/06/06 23:21:43 gwk Exp $ */
d199 3
@


1.12
log
@Update est.c, make it capable of using ACPI if the PSS is available but
still support all different methods of getting states without e.g.
(highest/lowest state), and on i386 use the tables. The only change
should be the deletion of the mV from the printf at boot.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.11 2009/04/23 07:30:03 jsg Exp $ */
d417 3
@


1.11
log
@add missing newline in the unknown model case
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.10 2009/02/24 19:32:37 deraadt Exp $ */
d59 1
d64 1
d69 6
d89 6
a94 3
	(((((int) (msr) >> 8) & 0xff) * (bus) + 50) / 100)
#define MSR2MV(msr) \
	(((int) (msr) & 0xff) * 16 + 700)
d100 1
a100 1
	const u_int16_t *table;
a102 1
static const struct fqlist *est_fqlist;
d104 1
a104 2
static u_int16_t fake_table[3];
static struct fqlist fake_fqlist;
d218 1
a218 1
	default: 
d224 83
d312 1
a312 1
	int i, mhz, mv, low, high, family;
d316 2
d340 5
a344 20
	if (crlo == 0 || crhi == crlo) {
		/*
		 * Don't complain about these cases, and silently disable EST:
		 * - A lowest clock ratio of 0, which seems to happen on all
		 *   Pentium 4's that report EST.
		 * - An equal highest and lowest clock ratio, which happens on
		 *   at least the Core 2 Duo X6800, maybe on newer models too.
		 */
		return;
	}
	if (crhi == 0 || crcur == 0 || crlo > crhi ||
	    crcur < crlo || crcur > crhi) {
		/*
		 * Do complain about other weirdness, because we first want to
		 * know about it, before we decide what to do with it.
		 */
		printf("%s: EST: strange msr value 0x%016llx\n",
		    cpu_device, msr);
		return;
	}
d346 23
a370 1

d374 18
a391 1
		fake_table[0] = idhi;
d394 1
a394 1
			    "states\n", cpu_device);
d396 3
a398 2
			fake_table[1] = idlo;
			fake_fqlist.n = 2;
d403 6
a408 3
			fake_table[1] = cur;
			fake_table[2] = idlo;
			fake_fqlist.n = 3;
d410 4
a413 3
		fake_fqlist.vendor = vendor;
		fake_fqlist.table = fake_table;
		est_fqlist = &fake_fqlist;
d416 8
a423 7
	mhz = MSR2MHZ(cur, bus_clock);
	mv = MSR2MV(cur);
	printf("%s: Enhanced SpeedStep %d MHz (%d mV)", cpu_device, mhz, mv);

	low = MSR2MHZ(est_fqlist->table[est_fqlist->n - 1], bus_clock);
	high = MSR2MHZ(est_fqlist->table[0], bus_clock);
	perflevel = (mhz - low) * 100 / (high - low);
d430 2
a431 2
		printf("%d%s", MSR2MHZ(est_fqlist->table[i], bus_clock),
		    i < est_fqlist->n - 1 ? ", " : " MHz\n");
d453 2
a454 1
	msr |= est_fqlist->table[i];
d456 1
a456 1
	cpuspeed = MSR2MHZ(est_fqlist->table[i], bus_clock);
@


1.10
log
@match new cpuid stuff from i386; by jsg
ok toby and tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.9 2009/02/24 13:19:59 deraadt Exp $ */
d210 1
a210 1
		printf("%s: unknown i686 model 0x%x, can't get bus clock",
@


1.9
log
@back out est.c 1.8 and bring acpicpu.c all the way back to 1.47 because of
hanging machines.  backed out correctly this time, as pointed out by tedu.
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.7 2008/08/06 05:24:44 gwk Exp $ */
d156 1
a156 1
	int model, bus;
d158 1
a158 2
	model = (ci->ci_signature >> 4) & 15;
	switch (model) {
d161 2
d190 19
d210 2
a211 2
		printf("%s: unknown i686 model %d, can't get bus clock",
		    ci->ci_dev->dv_xname, model);
@


1.8
log
@Re-enable ACPI PDC support and fetching cpu performance states
from ACPI for est on amd64. This incorporates a few changes from krw@@
to fix minor nits, its unlikely to fix the problems with some machines
from acer and dell but lots of machines benefit.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a58 1
#include <sys/malloc.h>
a62 1
#include <machine/bus.h>
d64 2
a65 1
#include "acpicpu.h"
d67 17
a83 9
#if NACPICPU > 0
#include <dev/acpi/acpidev.h>
#include <dev/acpi/acpivar.h>
#endif

struct est_op {
	uint16_t ctrl;
	uint16_t mhz;
};
d86 2
d89 1
a89 1
	struct est_op *table;
d92 1
d94 2
a95 1
static struct fqlist *est_fqlist;
d100 4
a103 3
#if NACPICPU > 0
struct fqlist * est_acpi_init(void);
void est_acpi_pss_changed(struct acpicpu_pss *, int);
d105 2
a106 2
struct fqlist *
est_acpi_init()
d108 2
a109 7
	struct acpicpu_pss *pss;
	struct fqlist *acpilist;
	int nstates, i;

	nstates = acpicpu_fetch_pss(&pss);
	if (nstates <= 0 || nstates > 31)
		goto nolist;
d111 38
a148 13
	if ((acpilist = malloc(sizeof(struct fqlist), M_DEVBUF, M_NOWAIT))
	    == NULL)
		goto nolist;

	if ((acpilist->table = malloc(sizeof(struct est_op) * nstates, M_DEVBUF,
	   M_NOWAIT)) == NULL)
		goto notable;

	acpilist->n = nstates;

	for (i = 0; i < nstates; i++) {
		acpilist->table[i].mhz = pss[i].pss_core_freq;
		acpilist->table[i].ctrl = pss[i].pss_ctrl;
a149 10

	acpicpu_set_notify(est_acpi_pss_changed);

	return acpilist;

notable:
	free(acpilist, M_DEVBUF);
	acpilist = NULL;
nolist:
	return NULL;
d153 1
a153 1
est_acpi_pss_changed(struct acpicpu_pss *pss, int nstates)
a154 2
	struct fqlist *acpilist;
	int needtran = 1, i;
d156 1
a156 15
	u_int16_t cur;

	msr = rdmsr(MSR_PERF_STATUS);
	cur = msr & 0xffff;

	if (nstates <= 0 || nstates > 31) {
		printf("est_acpi_pss_changed: nstates invalid (%d)", nstates);
		return;
	}

	if ((acpilist = malloc(sizeof(struct fqlist), M_DEVBUF, M_NOWAIT))
	    == NULL) {
		printf("est_acpi_pss_changed: cannot allocate memory for new est state");
		return;
	}
d158 34
a191 21
	acpilist->n = nstates;
	if ((acpilist->table = malloc(sizeof(struct est_op) * nstates, M_DEVBUF,
	   M_NOWAIT)) == NULL) {
		printf("est_acpi_pss_changed: cannot allocate memory for new operating points");
		free(acpilist, M_DEVBUF);
		return;
	}

	for (i = 0; i < nstates; i++) {
		acpilist->table[i].mhz = pss[i].pss_core_freq;
		acpilist->table[i].ctrl = pss[i].pss_ctrl;
		if (pss[i].pss_ctrl == cur)
			needtran = 0;
	}

	free(est_fqlist->table, M_DEVBUF);
	free(est_fqlist, M_DEVBUF);
	est_fqlist = acpilist;

	if (needtran) {
		est_setperf(perflevel);
a193 1
#endif
d199 2
a200 1
	int i, low, high;
d208 11
a225 1

d236 8
a243 6


#if NACPICPU > 0
		est_fqlist = est_acpi_init();
#endif
	if (est_fqlist == NULL)
d245 4
d250 22
a271 1
	printf("%s: Enhanced SpeedStep %d MHz", cpu_device, cpuspeed);
d273 7
a279 3
	low = est_fqlist->table[est_fqlist->n - 1].mhz;
	high = est_fqlist->table[0].mhz;
	perflevel = (cpuspeed - low) * 100 / (high - low);
d286 2
a287 2
		printf("%d%s", est_fqlist->table[i].mhz, i < est_fqlist->n - 1 ?
		    ", " : " MHz\n");
d309 1
a309 2
	msr |= est_fqlist->table[i].ctrl;

d311 1
a311 1
	cpuspeed = est_fqlist->table[i].mhz;
@


1.7
log
@Backout the acpicpu_setpdc code and the code to allow est to use acpicpu
on amd64.
Evaluating the _PDC seems to lead to instability (PR5878 and a report by
jmc@@) on lower end machines its too close to release and I don't have
enough nickels.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.5 2007/06/07 11:20:58 dim Exp $ */
d59 1
d64 1
d66 1
a66 2
#define CPUVENDOR_INTEL 0
#define CPUVENDOR_VIA 8
d68 9
a76 17

/* Convert MHz and mV into IDs for passing to the MSR. */
#define ID16(MHz, mV, bus_clk) \
	((((MHz * 100 + 50) / bus_clk) << 8) | ((mV ? mV - 700 : 0) >> 4))

/* Possible bus speeds (multiplied by 100 for rounding) */
#define BUS100 10000
#define BUS133 13333
#define BUS166 16667
#define BUS200 20000
#define BUS266 26667
#define BUS333 33333

#define MSR2MHZ(msr, bus) \
	(((((int) (msr) >> 8) & 0xff) * (bus) + 50) / 100)
#define MSR2MV(msr) \
	(((int) (msr) & 0xff) * 16 + 700)
a78 2
	int vendor: 5;
	unsigned bus_clk : 1;
d80 1
a80 1
	const u_int16_t *table;
a82 1
static const struct fqlist *est_fqlist;
d84 1
a84 2
static u_int16_t fake_table[3];
static struct fqlist fake_fqlist;
d89 18
a106 1
int bus_clock;
d108 3
a110 2
void p4_get_bus_clock(struct cpu_info *);
void p3_get_bus_clock(struct cpu_info *);
d112 1
a112 5
void
p4_get_bus_clock(struct cpu_info *ci)
{
	u_int64_t msr;
	int model, bus;
d114 3
a116 38
	model = (ci->ci_signature >> 4) & 15;
	msr = rdmsr(MSR_EBC_FREQUENCY_ID);
	if (model < 2) {
		bus = (msr >> 21) & 0x7;
		switch (bus) {
		case 0:
			bus_clock = BUS100;
			break;
		case 1:
			bus_clock = BUS133;
			break;
		default:
			printf("%s: unknown Pentium 4 (model %d) "
			    "EBC_FREQUENCY_ID value %d\n",
			    ci->ci_dev->dv_xname, model, bus);
			break;
		}
	} else {
		bus = (msr >> 16) & 0x7;
		switch (bus) {
		case 0:
			bus_clock = (model == 2) ? BUS100 : BUS266;
			break;
		case 1:
			bus_clock = BUS133;
			break;
		case 2:
			bus_clock = BUS200;
			break;
		case 3:
			bus_clock = BUS166;
			break;
		default:
			printf("%s: unknown Pentium 4 (model %d) "
			    "EBC_FREQUENCY_ID value %d\n",
			    ci->ci_dev->dv_xname, model, bus);
			break;
		}
d118 10
d131 1
a131 1
p3_get_bus_clock(struct cpu_info *ci)
d133 2
d136 15
a150 1
	int model, bus;
d152 21
a172 34
	model = (ci->ci_signature >> 4) & 15;
	switch (model) {
	case 0xe: /* Core Duo/Solo */
	case 0xf: /* Core Xeon */
		msr = rdmsr(MSR_FSB_FREQ);
		bus = (msr >> 0) & 0x7;
		switch (bus) {
		case 5:
			bus_clock = BUS100;
			break;
		case 1:
			bus_clock = BUS133;
			break;
		case 3:
			bus_clock = BUS166;
			break;
		case 2:
			bus_clock = BUS200;
			break;
		case 0:
			bus_clock = BUS266;
			break;
		case 4:
			bus_clock = BUS333;
			break;
		default:
			printf("%s: unknown Core FSB_FREQ value %d",
			    ci->ci_dev->dv_xname, bus);
			break;
		}
		break;
	default: 
		printf("%s: unknown i686 model %d, can't get bus clock",
		    ci->ci_dev->dv_xname, model);
d175 1
d181 1
a181 2
	int vendor = -1;
	int i, mhz, mv, low, high, family;
a188 11
	family = (ci->ci_signature >> 8) & 15;
	if (family == 0xf) {
		p4_get_bus_clock(ci);
	} else if (family == 6) {
		p3_get_bus_clock(ci);
	}
	if (bus_clock == 0) {
		printf("%s: EST: unknown system bus clock\n", cpu_device);
		return;
	}

d196 1
d207 6
a212 8
	if (crhi == 0 || crcur == 0 || crlo > crhi ||
	    crcur < crlo || crcur > crhi) {
		/*
		 * Do complain about other weirdness, because we first want to
		 * know about it, before we decide what to do with it.
		 */
		printf("%s: EST: strange msr value 0x%016llx\n",
		    cpu_device, msr);
a213 4
	}
	if (est_fqlist == NULL) {
		printf("%s: unknown Enhanced SpeedStep CPU, msr 0x%016llx\n",
		    cpu_device, msr);
d215 1
a215 22
		/*
		 * Generate a fake table with the power states we know.
		 */
		fake_table[0] = idhi;
		if (cur == idhi || cur == idlo) {
			printf("%s: using only highest and lowest power "
			    "states\n", cpu_device);

			fake_table[1] = idlo;
			fake_fqlist.n = 2;
		} else {
			printf("%s: using only highest, current and lowest "
			    "power states\n", cpu_device);

			fake_table[1] = cur;
			fake_table[2] = idlo;
			fake_fqlist.n = 3;
		}
		fake_fqlist.vendor = vendor;
		fake_fqlist.table = fake_table;
		est_fqlist = &fake_fqlist;
	}
d217 3
a219 7
	mhz = MSR2MHZ(cur, bus_clock);
	mv = MSR2MV(cur);
	printf("%s: Enhanced SpeedStep %d MHz (%d mV)", cpu_device, mhz, mv);

	low = MSR2MHZ(est_fqlist->table[est_fqlist->n - 1], bus_clock);
	high = MSR2MHZ(est_fqlist->table[0], bus_clock);
	perflevel = (mhz - low) * 100 / (high - low);
d226 2
a227 2
		printf("%d%s", MSR2MHZ(est_fqlist->table[i], bus_clock),
		    i < est_fqlist->n - 1 ? ", " : " MHz\n");
d249 2
a250 1
	msr |= est_fqlist->table[i];
d252 1
a252 1
	cpuspeed = MSR2MHZ(est_fqlist->table[i], bus_clock);
@


1.6
log
@On AMD64 running on Intel processors with EST add support for retreiving
operating points from ACPI. In support of this add evaluation of the _PDC
object and give it the capability flags asserting OSPM management of CPU
power states.

ok marco@@, canacar@@
@
text
@a58 1
#include <sys/malloc.h>
a62 1
#include <machine/bus.h>
d64 2
a65 1
#include "acpicpu.h"
d67 17
a83 9
#if NACPICPU > 0
#include <dev/acpi/acpidev.h>
#include <dev/acpi/acpivar.h>
#endif

struct est_op {
	uint16_t ctrl;
	uint16_t mhz;
};
d86 2
d89 1
a89 1
	struct est_op *table;
d92 1
d94 2
a95 1
static struct fqlist *est_fqlist;
d100 4
a103 3
#if NACPICPU > 0
struct fqlist * est_acpi_init(void);
void est_acpi_pss_changed(struct acpicpu_pss *, int);
d105 2
a106 2
struct fqlist *
est_acpi_init()
d108 2
a109 3
	struct acpicpu_pss *pss;
	struct fqlist *acpilist;
	int nstates, i;
d111 38
a148 16
	if ((nstates = acpicpu_fetch_pss(&pss)) == 0)
		goto nolist;

	if ((acpilist = malloc(sizeof(struct fqlist), M_DEVBUF, M_NOWAIT))
	    == NULL)
		goto nolist;

	if ((acpilist->table = malloc(sizeof(struct est_op) * nstates, M_DEVBUF,
	   M_NOWAIT)) == NULL)
		goto notable;

	acpilist->n = nstates;

	for (i = 0; i < nstates; i++) {
		acpilist->table[i].mhz = pss[i].pss_core_freq;
		acpilist->table[i].ctrl = pss[i].pss_ctrl;
a149 10

	acpicpu_set_notify(est_acpi_pss_changed);

	return acpilist;

notable:
	free(acpilist, M_DEVBUF);
	acpilist = NULL;
nolist:
	return NULL;
d153 1
a153 1
est_acpi_pss_changed(struct acpicpu_pss *pss, int npss)
a154 2
	struct fqlist *acpilist;
	int needtran = 1, nstates, i;
d156 1
a156 4
	u_int16_t cur;

	msr = rdmsr(MSR_PERF_STATUS);
	cur = msr & 0xffff;
d158 34
a191 26
	if ((acpilist = malloc(sizeof(struct fqlist), M_DEVBUF, M_NOWAIT))
	    == NULL) {
		printf("est_acpi_pss_changed: cannot allocate memory for new est state");
		return;
	}

	if ((acpilist->table = malloc(sizeof(struct est_op) * nstates, M_DEVBUF,
	   M_NOWAIT)) == NULL) {
		printf("est_acpi_pss_changed: cannot allocate memory for new operating points");
		free(acpilist, M_DEVBUF);
		return;
	}

	for (i = 0; i < nstates; i++) {
		acpilist->table[i].mhz = pss[i].pss_core_freq;
		acpilist->table[i].ctrl = pss[i].pss_ctrl;
		if (pss[i].pss_ctrl == cur)
			needtran = 0;
	}

	free(est_fqlist->table, M_DEVBUF);
	free(est_fqlist, M_DEVBUF);
	est_fqlist = acpilist;

	if (needtran) {
		est_setperf(perflevel);
a193 1
#endif
d199 2
a200 1
	int i, low, high;
d208 11
a225 1

d236 8
a243 6


#if NACPICPU > 0
		est_fqlist = est_acpi_init();
#endif
	if (est_fqlist == NULL)
d245 4
d250 30
a279 5
	printf("%s: Enhanced SpeedStep %d MHz", cpu_device, cpuspeed);

	low = est_fqlist->table[est_fqlist->n - 1].mhz;
	high = est_fqlist->table[0].mhz;
	perflevel = (cpuspeed - low) * 100 / (high - low);
d286 2
a287 2
		printf("%d%s", est_fqlist->table[i].mhz, i < est_fqlist->n - 1 ?
		    ", " : " MHz\n");
d309 1
a309 2
	msr |= est_fqlist->table[i].ctrl;

d311 1
a311 1
	cpuspeed = est_fqlist->table[i].mhz;
@


1.5
log
@Replace magic bus clock constants in est related files with defines.

ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.4 2007/06/04 06:57:57 jsg Exp $ */
d59 1
d64 1
d66 1
a66 2
#define CPUVENDOR_INTEL 0
#define CPUVENDOR_VIA 8
d68 9
a76 17

/* Convert MHz and mV into IDs for passing to the MSR. */
#define ID16(MHz, mV, bus_clk) \
	((((MHz * 100 + 50) / bus_clk) << 8) | ((mV ? mV - 700 : 0) >> 4))

/* Possible bus speeds (multiplied by 100 for rounding) */
#define BUS100 10000
#define BUS133 13333
#define BUS166 16667
#define BUS200 20000
#define BUS266 26667
#define BUS333 33333

#define MSR2MHZ(msr, bus) \
	(((((int) (msr) >> 8) & 0xff) * (bus) + 50) / 100)
#define MSR2MV(msr) \
	(((int) (msr) & 0xff) * 16 + 700)
a78 2
	int vendor: 5;
	unsigned bus_clk : 1;
d80 1
a80 1
	const u_int16_t *table;
a82 1
static const struct fqlist *est_fqlist;
d84 1
a84 2
static u_int16_t fake_table[3];
static struct fqlist fake_fqlist;
d89 13
a101 1
int bus_clock;
d103 3
a105 2
void p4_get_bus_clock(struct cpu_info *);
void p3_get_bus_clock(struct cpu_info *);
d107 5
a111 5
void
p4_get_bus_clock(struct cpu_info *ci)
{
	u_int64_t msr;
	int model, bus;
d113 3
a115 38
	model = (ci->ci_signature >> 4) & 15;
	msr = rdmsr(MSR_EBC_FREQUENCY_ID);
	if (model < 2) {
		bus = (msr >> 21) & 0x7;
		switch (bus) {
		case 0:
			bus_clock = BUS100;
			break;
		case 1:
			bus_clock = BUS133;
			break;
		default:
			printf("%s: unknown Pentium 4 (model %d) "
			    "EBC_FREQUENCY_ID value %d\n",
			    ci->ci_dev->dv_xname, model, bus);
			break;
		}
	} else {
		bus = (msr >> 16) & 0x7;
		switch (bus) {
		case 0:
			bus_clock = (model == 2) ? BUS100 : BUS266;
			break;
		case 1:
			bus_clock = BUS133;
			break;
		case 2:
			bus_clock = BUS200;
			break;
		case 3:
			bus_clock = BUS166;
			break;
		default:
			printf("%s: unknown Pentium 4 (model %d) "
			    "EBC_FREQUENCY_ID value %d\n",
			    ci->ci_dev->dv_xname, model, bus);
			break;
		}
d117 10
d130 1
a130 1
p3_get_bus_clock(struct cpu_info *ci)
d132 2
d135 4
a138 1
	int model, bus;
d140 26
a165 34
	model = (ci->ci_signature >> 4) & 15;
	switch (model) {
	case 0xe: /* Core Duo/Solo */
	case 0xf: /* Core Xeon */
		msr = rdmsr(MSR_FSB_FREQ);
		bus = (msr >> 0) & 0x7;
		switch (bus) {
		case 5:
			bus_clock = BUS100;
			break;
		case 1:
			bus_clock = BUS133;
			break;
		case 3:
			bus_clock = BUS166;
			break;
		case 2:
			bus_clock = BUS200;
			break;
		case 0:
			bus_clock = BUS266;
			break;
		case 4:
			bus_clock = BUS333;
			break;
		default:
			printf("%s: unknown Core FSB_FREQ value %d",
			    ci->ci_dev->dv_xname, bus);
			break;
		}
		break;
	default: 
		printf("%s: unknown i686 model %d, can't get bus clock",
		    ci->ci_dev->dv_xname, model);
d168 1
d174 1
a174 2
	int vendor = -1;
	int i, mhz, mv, low, high, family;
a181 11
	family = (ci->ci_signature >> 8) & 15;
	if (family == 0xf) {
		p4_get_bus_clock(ci);
	} else if (family == 6) {
		p3_get_bus_clock(ci);
	}
	if (bus_clock == 0) {
		printf("%s: EST: unknown system bus clock\n", cpu_device);
		return;
	}

d189 1
d200 6
a205 8
	if (crhi == 0 || crcur == 0 || crlo > crhi ||
	    crcur < crlo || crcur > crhi) {
		/*
		 * Do complain about other weirdness, because we first want to
		 * know about it, before we decide what to do with it.
		 */
		printf("%s: EST: strange msr value 0x%016llx\n",
		    cpu_device, msr);
a206 4
	}
	if (est_fqlist == NULL) {
		printf("%s: unknown Enhanced SpeedStep CPU, msr 0x%016llx\n",
		    cpu_device, msr);
d208 1
a208 22
		/*
		 * Generate a fake table with the power states we know.
		 */
		fake_table[0] = idhi;
		if (cur == idhi || cur == idlo) {
			printf("%s: using only highest and lowest power "
			    "states\n", cpu_device);

			fake_table[1] = idlo;
			fake_fqlist.n = 2;
		} else {
			printf("%s: using only highest, current and lowest "
			    "power states\n", cpu_device);

			fake_table[1] = cur;
			fake_table[2] = idlo;
			fake_fqlist.n = 3;
		}
		fake_fqlist.vendor = vendor;
		fake_fqlist.table = fake_table;
		est_fqlist = &fake_fqlist;
	}
d210 3
a212 7
	mhz = MSR2MHZ(cur, bus_clock);
	mv = MSR2MV(cur);
	printf("%s: Enhanced SpeedStep %d MHz (%d mV)", cpu_device, mhz, mv);

	low = MSR2MHZ(est_fqlist->table[est_fqlist->n - 1], bus_clock);
	high = MSR2MHZ(est_fqlist->table[0], bus_clock);
	perflevel = (mhz - low) * 100 / (high - low);
d219 2
a220 2
		printf("%d%s", MSR2MHZ(est_fqlist->table[i], bus_clock),
		    i < est_fqlist->n - 1 ? ", " : " MHz\n");
d242 2
a243 1
	msr |= est_fqlist->table[i];
d245 1
a245 1
	cpuspeed = MSR2MHZ(est_fqlist->table[i], bus_clock);
@


1.4
log
@Use 166.67 and 266.67 for bus_clock and not 166.66 and 266.66,
as per recommended values from Intel documentation.
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.3 2007/06/03 04:30:31 jsg Exp $ */
d75 1
a75 1
#define BUS166 16666
d77 2
d117 1
a117 1
			bus_clock = 10000;
d120 1
a120 1
			bus_clock = 13333;
d132 1
a132 1
			bus_clock = (model == 2) ? 10000 : 26666;
d135 1
a135 1
			bus_clock = 13333;
d138 1
a138 1
			bus_clock = 20000;
d141 1
a141 1
			bus_clock = 16666;
d166 1
a166 1
			bus_clock = 10000;
d169 1
a169 1
			bus_clock = 13333;
d172 1
a172 1
			bus_clock = 16667;
d175 1
a175 1
			bus_clock = 20000;
d178 1
a178 1
			bus_clock = 26667;
d181 1
a181 1
			bus_clock = 33333;
@


1.3
log
@Add a check for Intel Core processors with Scalable Bus Speed of 200 MHz.
From NetBSD and verified in Intel doc #253669

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.2 2007/06/01 22:28:21 tedu Exp $ */
d170 1
a170 1
			bus_clock = 16666;
d176 1
a176 1
			bus_clock = 26666;
@


1.2
log
@some pentium 4 machines are 64-bit and have EST, but a different msr to
get bus clock.  copy in some more code from i386 to deal with both families,
and be more watchful for unknown models.
fixes a panic reported by johan lindman.  ok gwk
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.1 2007/05/29 06:31:44 tedu Exp $ */
d171 3
@


1.1
log
@Some improvements for better intel cpu support.
Add EST support from i386, minus the tables
Also add in support for CPU temperature sensors, based on diff to tech
by Pierre Riteau.
ok deraadt gwk
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.28 2007/04/24 17:12:26 gwk Exp $ */
d100 90
d195 1
a195 1
	int i, mhz, mv, low, high, bus;
d202 6
a207 20
	msr = rdmsr(MSR_FSB_FREQ);
	bus = msr & 0x07;
	switch (bus) {
	case 5:
		bus_clock = 10000;
		break;
	case 1:
		bus_clock = 13333;
		break;
	case 3:
		bus_clock = 16666;
		break;
	case 0:
		bus_clock = 26666;
		break;
	case 4:
		bus_clock = 33333;
		break;
	default:
		printf("unknown bus %d\n", bus);
a208 1

@

