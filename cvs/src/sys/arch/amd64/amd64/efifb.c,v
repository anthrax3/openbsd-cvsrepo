head	1.10;
access;
symbols
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.9.0.2
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8;
locks; strict;
comment	@ * @;


1.10
date	2016.12.12.13.13.15;	author yasuoka;	state Exp;
branches;
next	1.9;
commitid	5r2jxJVvTbqdc94M;

1.9
date	2016.06.21.15.24.55;	author jcs;	state Exp;
branches;
next	1.8;
commitid	RnGuu1BeGyvYHPrZ;

1.8
date	2015.12.01.18.42.56;	author yasuoka;	state Exp;
branches;
next	1.7;
commitid	o6JoDva1RQHk2Zet;

1.7
date	2015.10.30.11.21.01;	author kettenis;	state Exp;
branches;
next	1.6;
commitid	VcCJwOOmRBie2Wwe;

1.6
date	2015.09.07.18.19.58;	author kettenis;	state Exp;
branches;
next	1.5;
commitid	Mi1kZUFjPkvIKlhm;

1.5
date	2015.09.07.18.06.00;	author kettenis;	state Exp;
branches;
next	1.4;
commitid	pjyo3jF1QZbA7jvJ;

1.4
date	2015.09.05.08.21.27;	author miod;	state Exp;
branches;
next	1.3;
commitid	ONsbuDRDMnyP3Azu;

1.3
date	2015.09.01.06.57.10;	author kettenis;	state Exp;
branches;
next	1.2;
commitid	Xv1XFpANf0jV3Nzn;

1.2
date	2015.08.31.19.56.32;	author kettenis;	state Exp;
branches;
next	1.1;
commitid	bQYNf2dfjwCUc5w2;

1.1
date	2015.08.30.10.05.09;	author yasuoka;	state Exp;
branches;
next	;
commitid	8KYmU15QlyhusRif;


desc
@@


1.10
log
@Pass WSDISPLAYIO_{GET,SET}PARAM to ws_{get,set}_param.  This allows
the brightness on some machines to be adjusted through wsconsctl(8).

diff from Anton Lindqvist
@
text
@/*	$OpenBSD: efifb.c,v 1.9 2016/06/21 15:24:55 jcs Exp $	*/

/*
 * Copyright (c) 2015 YASUOKA Masahiko <yasuoka@@yasuoka.net>
 * Copyright (c) 2016 joshua stein <jcs@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>

#include <uvm/uvm_extern.h>
#include <machine/bus.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>
#include <dev/pci/pcivar.h>

#include <machine/biosvar.h>
#include <machine/efifbvar.h>

/* coreboot tables */

struct cb_header {
	union {
		uint8_t signature[4]; /* "LBIO" */
		uint32_t signature32;
	};
	uint32_t	header_bytes;
	uint32_t	header_checksum;
	uint32_t	table_bytes;
	uint32_t	table_checksum;
	uint32_t	table_entries;
};

struct cb_framebuffer {
	uint64_t	physical_address;
	uint32_t	x_resolution;
	uint32_t	y_resolution;
	uint32_t	bytes_per_line;
	uint8_t		bits_per_pixel;
	uint8_t		red_mask_pos;
	uint8_t		red_mask_size;
	uint8_t		green_mask_pos;
	uint8_t		green_mask_size;
	uint8_t		blue_mask_pos;
	uint8_t		blue_mask_size;
	uint8_t		reserved_mask_pos;
	uint8_t		reserved_mask_size;
};

struct cb_entry {
	uint32_t	tag;
#define CB_TAG_VERSION          0x0004
#define CB_TAG_FORWARD          0x0011
#define CB_TAG_FRAMEBUFFER      0x0012
	uint32_t	size;
	union {
		char	string[0];
		uint64_t forward;
		struct cb_framebuffer fb;
	} u;
};

struct efifb {
	struct rasops_info	 rinfo;
	int			 depth;
	paddr_t			 paddr;
	psize_t			 psize;

	struct cb_framebuffer	 cb_table_fb;
};

struct efifb_softc {
	struct device		 sc_dev;
	struct efifb		*sc_fb;
};

int	 efifb_match(struct device *, void *, void *);
void	 efifb_attach(struct device *, struct device *, void *);
void	 efifb_rasops_preinit(struct efifb *);
void	 efifb_rasops_init(void);
int	 efifb_ioctl(void *, u_long, caddr_t, int, struct proc *);
paddr_t	 efifb_mmap(void *, off_t, int);
int	 efifb_alloc_screen(void *, const struct wsscreen_descr *, void **,
	    int *, int *, long *);
void	 efifb_free_screen(void *, void *);
int	 efifb_show_screen(void *, void *, int, void (*cb) (void *, int, int),
	    void *);
int	 efifb_list_font(void *, struct wsdisplay_font *);
int	 efifb_load_font(void *, void *, struct wsdisplay_font *);

struct cb_framebuffer *cb_find_fb(paddr_t);

extern int	(*ws_get_param)(struct wsdisplay_param *);
extern int	(*ws_set_param)(struct wsdisplay_param *);

const struct cfattach efifb_ca = {
	sizeof(struct efifb_softc), efifb_match, efifb_attach, NULL
};

#define	EFIFB_WIDTH	100
#define	EFIFB_HEIGHT	31

struct wsscreen_descr efifb_std_descr = { "std" };

const struct wsscreen_descr *efifb_descrs[] = {
	&efifb_std_descr
};

const struct wsscreen_list efifb_screen_list = {
	nitems(efifb_descrs), efifb_descrs
};

struct wsdisplay_accessops efifb_accessops = {
	.ioctl = efifb_ioctl,
	.mmap = efifb_mmap,
	.alloc_screen = efifb_alloc_screen,
	.free_screen = efifb_free_screen,
	.show_screen = efifb_show_screen,
	.load_font = efifb_load_font,
	.list_font = efifb_list_font
};

struct cfdriver efifb_cd = {
	NULL, "efifb", DV_DULL
};

struct efifb efifb_console;

int
efifb_match(struct device *parent, void *cf, void *aux)
{
	struct efifb_attach_args *eaa = aux;

	if (strcmp(eaa->eaa_name, efifb_cd.cd_name) == 0 &&
	    efifb_console.paddr != 0)
		return (1);

	return (0);
}

void
efifb_attach(struct device *parent, struct device *self, void *aux)
{
	struct efifb		*fb;
	struct efifb_softc	*sc = (struct efifb_softc *)self;
	struct wsemuldisplaydev_attach_args aa;
	struct rasops_info 	*ri;
	int			 ccol = 0, crow = 0;
	bus_space_tag_t		 iot = X86_BUS_SPACE_MEM;
	bus_space_handle_t	 ioh;
	long			 defattr;

	printf(": %dx%d, %dbpp\n", efifb_console.rinfo.ri_width,
	    efifb_console.rinfo.ri_height, efifb_console.rinfo.ri_depth);

	if (1) {	/* XXX console */
		aa.console = 1;
		fb = sc->sc_fb = &efifb_console;
		ri = &fb->rinfo;
		ccol = ri->ri_ccol;
		crow = ri->ri_crow;

		if (bus_space_map(iot, fb->paddr, fb->psize,
		    BUS_SPACE_MAP_PREFETCHABLE | BUS_SPACE_MAP_LINEAR,
		    &ioh) == 0)
			ri->ri_origbits = bus_space_vaddr(iot, ioh);

		efifb_rasops_preinit(fb);
		ri->ri_flg &= ~RI_CLEAR;
		ri->ri_flg |= RI_VCONS | RI_WRONLY;

		rasops_init(ri, efifb_std_descr.nrows, efifb_std_descr.ncols);
	}

	aa.scrdata = &efifb_screen_list;
	aa.accessops = &efifb_accessops;
	aa.accesscookie = sc;
	aa.defaultscreens = 0;

	ri->ri_ops.alloc_attr(ri->ri_active, 0, 0, 0, &defattr);
	wsdisplay_cnattach(&efifb_std_descr, ri->ri_active, ccol, crow, defattr);

	config_found(self, &aa, wsemuldisplaydevprint);
}

void
efifb_rasops_preinit(struct efifb *fb)
{
#define bmnum(_x) (fls(_x) - ffs(_x) + 1)
#define bmpos(_x) (ffs(_x) - 1)
	struct rasops_info	*ri = &fb->rinfo;

	if (efifb_console.cb_table_fb.x_resolution) {
		ri->ri_width = efifb_console.cb_table_fb.x_resolution;
		ri->ri_height = efifb_console.cb_table_fb.y_resolution;
		ri->ri_depth = fb->depth;
		ri->ri_stride = efifb_console.cb_table_fb.bytes_per_line;
		ri->ri_rnum = efifb_console.cb_table_fb.red_mask_size;
		ri->ri_rpos = efifb_console.cb_table_fb.red_mask_pos;
		ri->ri_gnum = efifb_console.cb_table_fb.green_mask_size;
		ri->ri_gpos = efifb_console.cb_table_fb.green_mask_pos;
		ri->ri_bnum = efifb_console.cb_table_fb.blue_mask_size;
		ri->ri_bpos = efifb_console.cb_table_fb.blue_mask_pos;
	} else {
		ri->ri_width = bios_efiinfo->fb_width;
		ri->ri_height = bios_efiinfo->fb_height;
		ri->ri_depth = fb->depth;
		ri->ri_stride = bios_efiinfo->fb_pixpsl * (fb->depth / 8);
		ri->ri_rnum = bmnum(bios_efiinfo->fb_red_mask);
		ri->ri_rpos = bmpos(bios_efiinfo->fb_red_mask);
		ri->ri_gnum = bmnum(bios_efiinfo->fb_green_mask);
		ri->ri_gpos = bmpos(bios_efiinfo->fb_green_mask);
		ri->ri_bnum = bmnum(bios_efiinfo->fb_blue_mask);
		ri->ri_bpos = bmpos(bios_efiinfo->fb_blue_mask);
	}
}

int
efifb_ioctl(void *v, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct efifb_softc	*sc = v;
	struct efifb		*fb = sc->sc_fb;
	struct rasops_info 	*ri = &fb->rinfo;
	struct wsdisplay_fbinfo	*wdf;

	switch (cmd) {
	case WSDISPLAYIO_GETPARAM:
		if (ws_get_param != NULL)
			return (*ws_get_param)((struct wsdisplay_param *)data);
		else
			return (-1);
	case WSDISPLAYIO_SETPARAM:
		if (ws_set_param != NULL)
			return (*ws_set_param)((struct wsdisplay_param *)data);
		else
			return (-1);
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_EFIFB;
		break;
	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->width = ri->ri_width;
		wdf->height = ri->ri_height;
		wdf->depth = ri->ri_depth;
		wdf->cmsize = 0;	/* color map is unavailable */
		break;
	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = ri->ri_stride;
		break;
	case WSDISPLAYIO_SMODE:
		break;
	case WSDISPLAYIO_GETSUPPORTEDDEPTH:
		switch (ri->ri_depth) {
		case 32:
			*(u_int *)data = WSDISPLAYIO_DEPTH_24_32;
			break;
		case 24:
			*(u_int *)data = WSDISPLAYIO_DEPTH_24_24;
			break;
		case 16:
			*(u_int *)data = WSDISPLAYIO_DEPTH_16;
			break;
		case 15:
			*(u_int *)data = WSDISPLAYIO_DEPTH_15;
			break;
		case 8:
			*(u_int *)data = WSDISPLAYIO_DEPTH_8;
			break;
		case 4:
			*(u_int *)data = WSDISPLAYIO_DEPTH_4;
			break;
		case 1:
			*(u_int *)data = WSDISPLAYIO_DEPTH_1;
			break;
		default:
			return (-1);
		}
		break;
	default:
		return (-1);
	}

	return (0);
}

paddr_t
efifb_mmap(void *v, off_t off, int prot)
{
	struct efifb_softc	*sc = v;

	if (off < 0 || off >= sc->sc_fb->psize)
		return (-1);

	return ((sc->sc_fb->paddr + off) | PMAP_WC);
}

int
efifb_alloc_screen(void *v, const struct wsscreen_descr *descr,
    void **cookiep, int *curxp, int *curyp, long *attrp)
{
	struct efifb_softc	*sc = v;
	struct rasops_info	*ri = &sc->sc_fb->rinfo;

	return rasops_alloc_screen(ri, cookiep, curxp, curyp, attrp);
}

void
efifb_free_screen(void *v, void *cookie)
{
	struct efifb_softc	*sc = v;
	struct rasops_info	*ri = &sc->sc_fb->rinfo;

	rasops_free_screen(ri, cookie);
}

int
efifb_show_screen(void *v, void *cookie, int waitok,
    void (*cb) (void *, int, int), void *cb_arg)
{
	struct efifb_softc	*sc = v;
	struct rasops_info	*ri = &sc->sc_fb->rinfo;

	return rasops_show_screen(ri, cookie, waitok, cb, cb_arg);
}

int
efifb_load_font(void *v, void *cookie, struct wsdisplay_font *font)
{
	struct efifb_softc	*sc = v;
	struct rasops_info	*ri = &sc->sc_fb->rinfo;

	return (rasops_load_font(ri, cookie, font));
}

int
efifb_list_font(void *v, struct wsdisplay_font *font)
{
	struct efifb_softc	*sc = v;
	struct rasops_info	*ri = &sc->sc_fb->rinfo;

	return (rasops_list_font(ri, font));
}

struct wsdisplay_charcell efifb_bs[EFIFB_HEIGHT * EFIFB_WIDTH];

int
efifb_cnattach(void)
{
	struct efifb		*fb = &efifb_console;

	if (bios_efiinfo == NULL || bios_efiinfo->fb_addr == 0)
		return (-1);

	memset(&efifb_console, 0, sizeof(efifb_console));

	fb = &efifb_console;
	fb->paddr = bios_efiinfo->fb_addr;
	fb->depth = max(fb->depth, fls(bios_efiinfo->fb_red_mask));
	fb->depth = max(fb->depth, fls(bios_efiinfo->fb_green_mask));
	fb->depth = max(fb->depth, fls(bios_efiinfo->fb_blue_mask));
	fb->depth = max(fb->depth, fls(bios_efiinfo->fb_reserved_mask));
	fb->psize = bios_efiinfo->fb_height *
	    bios_efiinfo->fb_pixpsl * (fb->depth / 8);

	efifb_rasops_init();

	return (0);
}

int
efifb_is_console(struct pci_attach_args *pa)
{
	pci_chipset_tag_t pc = pa->pa_pc;
	pcitag_t tag = pa->pa_tag;
	pcireg_t type;
	bus_addr_t base;
	bus_size_t size;
	int reg;

	for (reg = PCI_MAPREG_START; reg < PCI_MAPREG_END; reg += 4) {
		if (!pci_mapreg_probe(pc, tag, reg, &type))
			continue;

		if (type == PCI_MAPREG_TYPE_IO)
			continue;

		if (pci_mapreg_info(pc, tag, reg, type, &base, &size, NULL))
			continue;

		if (efifb_console.paddr >= base &&
		    efifb_console.paddr < base + size)
			return 1;

		if (type & PCI_MAPREG_MEM_TYPE_64BIT)
			reg += 4;
	}

	return 0;
}

void
efifb_cndetach(void)
{
	efifb_console.paddr = 0;
}

void
efifb_rasops_init(void)
{
	struct efifb		*fb = &efifb_console;
	struct rasops_info	*ri = &fb->rinfo;
	long			 defattr = 0;

	ri->ri_bits = (u_char *)PMAP_DIRECT_MAP(fb->paddr);

	efifb_rasops_preinit(fb);

	ri->ri_bs = efifb_bs;
	ri->ri_flg = RI_CLEAR | RI_CENTER | RI_WRONLY;
	rasops_init(ri, EFIFB_HEIGHT, EFIFB_WIDTH);
	efifb_std_descr.ncols = ri->ri_cols;
	efifb_std_descr.nrows = ri->ri_rows;
	efifb_std_descr.textops = &ri->ri_ops;
	efifb_std_descr.fontwidth = ri->ri_font->fontwidth;
	efifb_std_descr.fontheight = ri->ri_font->fontheight;
	efifb_std_descr.capabilities = ri->ri_caps;

	ri->ri_ops.alloc_attr(ri, 0, 0, 0, &defattr);
	wsdisplay_cnattach(&efifb_std_descr, ri, 0, 0, defattr);
}

int
efifb_cb_cnattach(void)
{
	struct cb_framebuffer *cb_fb = cb_find_fb((paddr_t)0x0);

	if (cb_fb == NULL || !cb_fb->x_resolution)
		return (-1);

	memset(&efifb_console, 0, sizeof(efifb_console));
	memcpy(&efifb_console.cb_table_fb, cb_fb,
	    sizeof(struct cb_framebuffer));

	efifb_console.paddr = cb_fb->physical_address;
	efifb_console.depth = cb_fb->bits_per_pixel;
	efifb_console.psize = cb_fb->y_resolution * cb_fb->bytes_per_line;

	efifb_rasops_init();

	return (0);
}

int
efifb_cb_found(void)
{
	return (efifb_console.paddr && efifb_console.cb_table_fb.x_resolution);
}

static uint16_t
cb_checksum(const void *addr, unsigned size)
{
	const uint16_t *p = addr;
	unsigned i, n = size / 2;
	uint32_t sum = 0;

	for (i = 0; i < n; i++)
		sum += p[i];

	sum = (sum >> 16) + (sum & 0xffff);
	sum += (sum >> 16);
	sum = ~sum & 0xffff;

	return (uint16_t)sum;
}

struct cb_framebuffer *
cb_find_fb(paddr_t addr)
{
	int i, j;

	for (i = 0; i < (4 * 1024); i += 16) {
		struct cb_header *cbh;
		struct cb_entry *cbe;
		paddr_t cbtable;

		cbh = (struct cb_header *)(PMAP_DIRECT_MAP(addr + i));
		if (memcmp(cbh->signature, "LBIO", 4) != 0)
			continue;

		if (!cbh->header_bytes)
			continue;

		if (cb_checksum(cbh, sizeof(*cbh)) != 0)
			return NULL;

		cbtable = PMAP_DIRECT_MAP(addr + i + cbh->header_bytes);

		for (j = 0; j < cbh->table_bytes; j += cbe->size) {
			cbe = (struct cb_entry *)((char *)cbtable + j);

			switch (cbe->tag) {
			case CB_TAG_FORWARD:
				return cb_find_fb(cbe->u.forward);

			case CB_TAG_FRAMEBUFFER:
				return &cbe->u.fb;
			}
		}
	}

	return NULL;
}
@


1.9
log
@add support to efifb for drawing a console on a coreboot framebuffer
if coreboot's memory table is found, it has a framebuffer entry, and
there is no previously attached efi, vga, or serial console.

useful on chromebooks that have no legacy vga device to get an early
console before inteldrm(4) attaches or, for newer chipsets, a full
console and X with wsfb(4).

ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: efifb.c,v 1.8 2015/12/01 18:42:56 yasuoka Exp $	*/
d107 3
d241 10
@


1.8
log
@Change a lot of "else if" lines to single switch block.

input by tobias
@
text
@d1 1
a1 1
/*	$OpenBSD: efifb.c,v 1.7 2015/10/30 11:21:01 kettenis Exp $	*/
d5 1
d34 43
d82 2
d94 1
d105 3
a107 1
struct cfattach efifb_ca = {
d164 2
a165 1
	printf("\n");
d204 23
a226 10
	ri->ri_width = bios_efiinfo->fb_width;
	ri->ri_height = bios_efiinfo->fb_height;
	ri->ri_depth = fb->depth;
	ri->ri_stride = bios_efiinfo->fb_pixpsl * (fb->depth / 8);
	ri->ri_rnum = bmnum(bios_efiinfo->fb_red_mask);
	ri->ri_rpos = bmpos(bios_efiinfo->fb_red_mask);
	ri->ri_gnum = bmnum(bios_efiinfo->fb_green_mask);
	ri->ri_gpos = bmpos(bios_efiinfo->fb_green_mask);
	ri->ri_bnum = bmnum(bios_efiinfo->fb_blue_mask);
	ri->ri_bpos = bmpos(bios_efiinfo->fb_blue_mask);
a350 2
	struct rasops_info	*ri = &fb->rinfo;
	long			 defattr = 0;
d366 1
a366 16
	ri->ri_bits = (u_char *)PMAP_DIRECT_MAP(fb->paddr);

	efifb_rasops_preinit(fb);

	ri->ri_bs = efifb_bs;
	ri->ri_flg = RI_CLEAR | RI_CENTER | RI_WRONLY;
	rasops_init(ri, EFIFB_HEIGHT, EFIFB_WIDTH);
	efifb_std_descr.ncols = ri->ri_cols;
	efifb_std_descr.nrows = ri->ri_rows;
	efifb_std_descr.textops = &ri->ri_ops;
	efifb_std_descr.fontwidth = ri->ri_font->fontwidth;
	efifb_std_descr.fontheight = ri->ri_font->fontheight;
	efifb_std_descr.capabilities = ri->ri_caps;

	ri->ri_ops.alloc_attr(ri, 0, 0, 0, &defattr);
	wsdisplay_cnattach(&efifb_std_descr, ri, 0, 0, defattr);
d406 107
@


1.7
log
@Fix interaction between inteldrm(4) and efifb(4).  If we were booted by UEFI
firmware and the efifb(4) framebuffer address matches one of the BARs
associated with the inteldrm(4) device, make inteldrm(4) the console and
prevent efifb(4) from attaching.  Make sure that we do a full clear of the
framebuffer when inteldrm(4) attaches to prevent the contents of the old
framebuffer from showing up.

Based on an earlier diff from yasuoka@@
ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: efifb.c,v 1.6 2015/09/07 18:19:58 kettenis Exp $	*/
d191 2
a192 2
		/* can't change the depth */
		if (ri->ri_depth == 32)
d194 2
a195 1
		else if (ri->ri_depth == 24)
d197 2
a198 1
		else if (ri->ri_depth == 16)
d200 2
a201 1
		else if (ri->ri_depth == 15)
d203 2
a204 1
		else if (ri->ri_depth == 8)
d206 2
a207 1
		else if (ri->ri_depth == 4)
d209 2
a210 1
		else if (ri->ri_depth == 1)
d212 2
a213 1
		else
d215 1
@


1.6
log
@Remap the framebuffer as write-combining when we actually attach.  Speeds up
scrolling by a factor of 20 on my x1.
@
text
@d1 1
a1 1
/*	$OpenBSD: efifb.c,v 1.5 2015/09/07 18:06:00 kettenis Exp $	*/
d28 1
d97 1
a97 1
	    bios_efiinfo != NULL)
d315 37
@


1.5
log
@Use the RI_WRONLY flag to avoid reading back pixels from buffer memory.
Make scrolling efifb(4) a bit faster.

ok yasuoka@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: efifb.c,v 1.4 2015/09/05 08:21:27 miod Exp $	*/
d107 1
a107 2
	struct wsemuldisplaydev_attach_args
				 aa;
d110 2
d122 5
@


1.4
log
@Correct bounds checking in efifb_mmap(). ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: efifb.c,v 1.3 2015/09/01 06:57:10 kettenis Exp $	*/
d124 1
a124 1
		ri->ri_flg |= RI_VCONS;
d267 2
d294 2
a295 1
	ri->ri_flg = RI_CLEAR | RI_CENTER;
@


1.3
log
@Only advertise the color depth we actually support.  This makes the
xf86-video-wsfb driver work.

Map the framebuffer in write-combining mode.  This significantly speeds
things up.

ok yuo@@, yasuoka@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: efifb.c,v 1.2 2015/08/31 19:56:32 kettenis Exp $	*/
d214 1
a214 1
	if (off > sc->sc_fb->psize)
@


1.2
log
@Check driver name in match function such that driver only attempts to attach
when we actually want it to.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: efifb.c,v 1.1 2015/08/30 10:05:09 yasuoka Exp $	*/
d185 4
a188 2
		if (ri->ri_depth == 32 || ri->ri_depth == 24)
			*(u_int *)data = WSDISPLAYIO_DEPTH_24;
d217 1
a217 1
	return (sc->sc_fb->paddr + off);
@


1.1
log
@Modify kernel to prepare boot from UEFI.

- Add new boot arg "bios_efi_info_t" to pass the paramters from UEFI
- Make bios(4) and acpi(4) be able to probe with the parameters from
  UEFI
- Add efifb(8).  It uses the framebuffer from UEFI and it will work as
  a backend of wsdisplay(4) and wsfb (X11 video driver).  Disabled by
  the kernel config for this moment

input and ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d93 4
a96 1
	if (bios_efiinfo != NULL)
@

