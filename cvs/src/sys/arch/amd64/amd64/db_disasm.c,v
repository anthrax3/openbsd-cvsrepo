head	1.17;
access;
symbols
	OPENBSD_6_1:1.17.0.4
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.16.0.2
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.4
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.11.0.4
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.9.0.20
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.18
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.16
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.14
	OPENBSD_5_0:1.9.0.12
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.10
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.8
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.4
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.8.0.4
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.2
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.6.0.4
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.2
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.5.0.8
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.10
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.6
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.2
	SMP_SYNC_B:1.2
	OPENBSD_3_5:1.2.0.2
	OPENBSD_3_5_BASE:1.2
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.17
date	2017.03.05.01.02.48;	author guenther;	state Exp;
branches;
next	1.16;
commitid	ZQ7I9zTQDDR1OnUt;

1.16
date	2016.04.03.17.46.26;	author guenther;	state Exp;
branches;
next	1.15;
commitid	ztoJTXebDZOXAS4M;

1.15
date	2015.06.24.20.50.39;	author miod;	state Exp;
branches;
next	1.14;
commitid	DmJOCDC5c8NlzgNP;

1.14
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.13;
commitid	p4LJxGKbi0BU2cG6;

1.13
date	2014.09.14.14.17.23;	author jsg;	state Exp;
branches;
next	1.12;
commitid	uzzBR7hz9ncd4O6G;

1.12
date	2014.03.11.04.11.14;	author guenther;	state Exp;
branches;
next	1.11;

1.11
date	2013.11.19.04.12.17;	author guenther;	state Exp;
branches;
next	1.10;

1.10
date	2013.10.02.21.20.22;	author sf;	state Exp;
branches;
next	1.9;

1.9
date	2008.10.06.20.42.02;	author chl;	state Exp;
branches;
next	1.8;

1.8
date	2007.11.05.19.23.24;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2007.09.01.11.54.02;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2007.01.15.23.19.05;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.26.20.29.36;	author andreas;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.24.22.29.31;	author andreas;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.24.19.01.30;	author andreas;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.28.22.22.35;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.28.01.39.38;	author mickey;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.06.05.23.09.24;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Teach the ddb disassembler about most of the vm* instructions

ok mlarkin@@
@
text
@/*	$OpenBSD: db_disasm.c,v 1.16 2016/04/03 17:46:26 guenther Exp $	*/
/*	$NetBSD: db_disasm.c,v 1.11 1996/05/03 19:41:58 christos Exp $	*/

/* 
 * Mach Operating System
 * Copyright (c) 1991,1990 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 *
 *	Id: db_disasm.c,v 2.6  92/01/03  20:05:00  dbg (CMU)
 */

/*
 * Instruction disassembler.
 */
#include <sys/param.h>
#include <machine/db_machdep.h>

#include <ddb/db_access.h>
#include <ddb/db_sym.h>
#include <ddb/db_output.h>

/*
 * Size attributes
 */
#define	BYTE	0
#define	WORD	1
#define	LONG	2
#define	QUAD	3
#define	SNGL	4
#define	DBLR	5
#define	EXTR	6
#define	SDEP	7
#define	NONE	8
#define	RDEP	9

/*
 * Addressing modes
 */
#define	E	1			/* general effective address */
#define	Eind	2			/* indirect address (jump, call) */
#define	Ew	3			/* address, word size */
#define	Eb	4			/* address, byte size */
#define	R	5			/* register, in 'reg' field */
#define	Rw	6			/* word register, in 'reg' field */
#define	Ri	7			/* register in instruction */
#define	S	8			/* segment reg, in 'reg' field */
#define	Si	9			/* segment reg, in instruction */
#define	A	10			/* accumulator */
#define	BX	11			/* (bx) */
#define	CL	12			/* cl, for shifts */
#define	DX	13			/* dx, for IO */
#define	SI	14			/* si */
#define	DI	15			/* di */
#define	CR	16			/* control register */
#define	DR	17			/* debug register */
#define	TR	18			/* test register */
#define	I	19			/* immediate, unsigned */
#define	Is	20			/* immediate, signed */
#define	Ib	21			/* byte immediate, unsigned */
#define	Ibs	22			/* byte immediate, signed */
#define	Iw	23			/* word immediate, unsigned */
#define	Iq	24			/* quad immediate, unsigned */
#define	O	25			/* direct address */
#define	Db	26			/* byte displacement from EIP */
#define	Dl	27			/* long displacement from EIP */
#define	o1	28			/* constant 1 */
#define	o3	29			/* constant 3 */
#define	OS	30			/* immediate offset/segment */
#define	ST	31			/* FP stack top */
#define	STI	32			/* FP stack */
#define	X	33			/* extended FP op */
#define	XA	34			/* for 'fstcw %ax' */
#define	Ril	36			/* long register in instruction */
#define	Iba	37			/* byte immediate, don't print if 0xa */
#define	MEx	38			/* memory, or an extension op */

struct inst {
	char *	i_name;			/* name */
	short	i_has_modrm;		/* has regmodrm byte */
	short	i_size;			/* operand size */
	int	i_mode;			/* addressing modes */
	void *	i_extra;		/* pointer to extra opcode table */
};

#define	op1(x)		(x)
#define	op2(x,y)	((x)|((y)<<8))
#define	op3(x,y,z)	((x)|((y)<<8)|((z)<<16))

struct finst {
	char *	f_name;			/* name for memory instruction */
	int	f_size;			/* size for memory instruction */
	int	f_rrmode;		/* mode for rr instruction */
	void *	f_rrname;		/* name for rr instruction
					   (or pointer to table) */
};

char *	db_Grp6[] = {
	"sldt",		"str",		"lldt",		"ltr",
	"verr",		"verw",		"",		""
};

struct inst db_Grp7[] = {
	{ "sgdt",   FALSE, NONE, op2(MEx,5), "\0vmcall\0vmlaunch\0vmresume\0vmxoff"},
	{ "sidt",   FALSE, NONE, op2(MEx,4), "monitor\0mwait\0clac\0stac"},
	{ "lgdt",   FALSE, NONE, op2(MEx,7), "xgetbv\0xsetbv\0\0\0vmfunc\0xend\0xtest" },
	{ "lidt",   FALSE, NONE, op1(E),     0 },
	{ "smsw",   FALSE, NONE, op1(E),     0 },
	{ "",       FALSE, NONE, 0,          0 },
	{ "lmsw",   FALSE, NONE, op1(E),     0 },
	{ "invlpg", FALSE, NONE, op2(MEx,2), "swapgs\0rdtscp" },
};

char *	db_Grp8[] = {
	"",		"",		"",		"",
	"bt",		"bts",		"btr",		"btc"
};

struct inst db_Grp9[] = {
	{ "fxsave",   FALSE, NONE, op2(MEx,1), "rdfsbase" },
	{ "fxrstor",  FALSE, NONE, op2(MEx,1), "rdgsbase" },
	{ "ldmxcsr",  FALSE, NONE, op2(MEx,1), "wrfsbase" },
	{ "stmxcsr",  FALSE, NONE, op2(MEx,1), "wrgsbase" },
	{ "xsave",    FALSE, NONE, op1(E),     0 },
	{ "xrstor",   FALSE, NONE, op2(MEx,1), "lfence" },
	{ "xsaveopt", FALSE, NONE, op2(MEx,1), "mfence" },
	{ "clflush",  FALSE, NONE, op2(MEx,1), "sfence" },
};

char *	db_GrpA[] = {
	"",		"cmpxchg8b",	"",		"",
	"",		"",		"rdrand",	"rdseed"
};

char *	db_GrpB[] = {
	"xstore-rng",	"xcrypt-ecb",	"xcrypt-cbc",	"xcrypt-ctr",
	"xcrypt-cfb",	"xcrypt-ofb",	"",		""
};

char * db_GrpC[] = {
	"montmul",	"xsha1",	"xsha256",	"",
	"",		"",		"",		""
};

struct inst db_inst_0f0x[] = {
/*00*/	{ NULL,	   TRUE,  NONE,  op1(Ew),     db_Grp6 },
/*01*/	{ "",	   TRUE,  RDEP,  0,           db_Grp7 },
/*02*/	{ "lar",   TRUE,  LONG,  op2(E,R),    0 },
/*03*/	{ "lsl",   TRUE,  LONG,  op2(E,R),    0 },
/*04*/	{ "",      FALSE, NONE,  0,	      0 },
/*05*/	{ "",      FALSE, NONE,  0,	      0 },
/*06*/	{ "clts",  FALSE, NONE,  0,	      0 },
/*07*/	{ "",      FALSE, NONE,  0,	      0 },

/*08*/	{ "invd",  FALSE, NONE,  0,	      0 },
/*09*/	{ "wbinvd",FALSE, NONE,  0,	      0 },
/*0a*/	{ "",      FALSE, NONE,  0,	      0 },
/*0b*/	{ "",      FALSE, NONE,  0,	      0 },
/*0c*/	{ "",      FALSE, NONE,  0,	      0 },
/*0d*/	{ "",      FALSE, NONE,  0,	      0 },
/*0e*/	{ "",      FALSE, NONE,  0,	      0 },
/*0f*/	{ "",      FALSE, NONE,  0,	      0 },
};

struct inst	db_inst_0f2x[] = {
/*20*/	{ "mov",   TRUE,  LONG,  op2(CR,E),   0 }, /* use E for reg */
/*21*/	{ "mov",   TRUE,  LONG,  op2(DR,E),   0 }, /* since mod == 11 */
/*22*/	{ "mov",   TRUE,  LONG,  op2(E,CR),   0 },
/*23*/	{ "mov",   TRUE,  LONG,  op2(E,DR),   0 },
/*24*/	{ "mov",   TRUE,  LONG,  op2(TR,E),   0 },
/*25*/	{ "",      FALSE, NONE,  0,	      0 },
/*26*/	{ "mov",   TRUE,  LONG,  op2(E,TR),   0 },
/*27*/	{ "",      FALSE, NONE,  0,	      0 },

/*28*/	{ "",      FALSE, NONE,  0,	      0 },
/*29*/	{ "",      FALSE, NONE,  0,	      0 },
/*2a*/	{ "",      FALSE, NONE,  0,	      0 },
/*2b*/	{ "",      FALSE, NONE,  0,	      0 },
/*2c*/	{ "",      FALSE, NONE,  0,	      0 },
/*2d*/	{ "",      FALSE, NONE,  0,	      0 },
/*2e*/	{ "",      FALSE, NONE,  0,	      0 },
/*2f*/	{ "",      FALSE, NONE,  0,	      0 },
};

struct inst	db_inst_0f3x[] = {
/*30*/	{ "wrmsr", FALSE, NONE,  0,           0 },
/*31*/	{ "rdtsc", FALSE, NONE,  0,           0 },
/*32*/	{ "rdmsr", FALSE, NONE,  0,           0 },
/*33*/	{ "rdpmc", FALSE, NONE,  0,           0 },
/*34*/	{ "",      FALSE, NONE,  0,           0 },
/*35*/	{ "",      FALSE, NONE,  0,           0 },
/*36*/	{ "",      FALSE, NONE,  0,           0 },
/*37*/	{ "",      FALSE, NONE,  0,           0 },

/*38*/	{ "",      FALSE, NONE,  0,           0 },
/*39*/	{ "",      FALSE, NONE,  0,           0 },
/*3a*/	{ "",      FALSE, NONE,  0,           0 },
/*3b*/	{ "",      FALSE, NONE,  0,           0 },
/*3c*/	{ "",      FALSE, NONE,  0,           0 },
/*3d*/	{ "",      FALSE, NONE,  0,           0 },
/*3e*/	{ "",      FALSE, NONE,  0,           0 },
/*3f*/	{ "",      FALSE, NONE,  0,           0 },
};

struct inst	db_inst_0f8x[] = {
/*80*/	{ "jo",    FALSE, NONE,  op1(Dl),     0 },
/*81*/	{ "jno",   FALSE, NONE,  op1(Dl),     0 },
/*82*/	{ "jb",    FALSE, NONE,  op1(Dl),     0 },
/*83*/	{ "jnb",   FALSE, NONE,  op1(Dl),     0 },
/*84*/	{ "jz",    FALSE, NONE,  op1(Dl),     0 },
/*85*/	{ "jnz",   FALSE, NONE,  op1(Dl),     0 },
/*86*/	{ "jbe",   FALSE, NONE,  op1(Dl),     0 },
/*87*/	{ "jnbe",  FALSE, NONE,  op1(Dl),     0 },

/*88*/	{ "js",    FALSE, NONE,  op1(Dl),     0 },
/*89*/	{ "jns",   FALSE, NONE,  op1(Dl),     0 },
/*8a*/	{ "jp",    FALSE, NONE,  op1(Dl),     0 },
/*8b*/	{ "jnp",   FALSE, NONE,  op1(Dl),     0 },
/*8c*/	{ "jl",    FALSE, NONE,  op1(Dl),     0 },
/*8d*/	{ "jnl",   FALSE, NONE,  op1(Dl),     0 },
/*8e*/	{ "jle",   FALSE, NONE,  op1(Dl),     0 },
/*8f*/	{ "jnle",  FALSE, NONE,  op1(Dl),     0 },
};

struct inst	db_inst_0f9x[] = {
/*90*/	{ "seto",  TRUE,  NONE,  op1(Eb),     0 },
/*91*/	{ "setno", TRUE,  NONE,  op1(Eb),     0 },
/*92*/	{ "setb",  TRUE,  NONE,  op1(Eb),     0 },
/*93*/	{ "setnb", TRUE,  NONE,  op1(Eb),     0 },
/*94*/	{ "setz",  TRUE,  NONE,  op1(Eb),     0 },
/*95*/	{ "setnz", TRUE,  NONE,  op1(Eb),     0 },
/*96*/	{ "setbe", TRUE,  NONE,  op1(Eb),     0 },
/*97*/	{ "setnbe",TRUE,  NONE,  op1(Eb),     0 },

/*98*/	{ "sets",  TRUE,  NONE,  op1(Eb),     0 },
/*99*/	{ "setns", TRUE,  NONE,  op1(Eb),     0 },
/*9a*/	{ "setp",  TRUE,  NONE,  op1(Eb),     0 },
/*9b*/	{ "setnp", TRUE,  NONE,  op1(Eb),     0 },
/*9c*/	{ "setl",  TRUE,  NONE,  op1(Eb),     0 },
/*9d*/	{ "setnl", TRUE,  NONE,  op1(Eb),     0 },
/*9e*/	{ "setle", TRUE,  NONE,  op1(Eb),     0 },
/*9f*/	{ "setnle",TRUE,  NONE,  op1(Eb),     0 },
};

struct inst	db_inst_0fax[] = {
/*a0*/	{ "push",  FALSE, QUAD,  op1(Si),     0 },
/*a1*/	{ "pop",   FALSE, QUAD,  op1(Si),     0 },
/*a2*/	{ "cpuid", FALSE, NONE,  0,	      0 },
/*a3*/	{ "bt",    TRUE,  LONG,  op2(R,E),    0 },
/*a4*/	{ "shld",  TRUE,  LONG,  op3(Ib,R,E), 0 },
/*a5*/	{ "shld",  TRUE,  LONG,  op3(CL,R,E), 0 },
/*a6*/	{ NULL,    TRUE,  NONE,  0,	      db_GrpC },
/*a7*/	{ NULL,    TRUE,  NONE,  0,	      db_GrpB },

/*a8*/	{ "push",  FALSE, QUAD,  op1(Si),     0 },
/*a9*/	{ "pop",   FALSE, QUAD,  op1(Si),     0 },
/*aa*/	{ "",      FALSE, NONE,  0,	      0 },
/*ab*/	{ "bts",   TRUE,  LONG,  op2(R,E),    0 },
/*ac*/	{ "shrd",  TRUE,  LONG,  op3(Ib,E,R), 0 },
/*ad*/	{ "shrd",  TRUE,  LONG,  op3(CL,E,R), 0 },
/*ae*/	{ "",      TRUE,  RDEP,  op1(E),      db_Grp9 },
/*af*/	{ "imul",  TRUE,  LONG,  op2(E,R),    0 },
};

struct inst	db_inst_0fbx[] = {
/*b0*/	{ "cmpxchg",TRUE, BYTE,	 op2(R, E),   0 },
/*b1*/	{ "cmpxchg",TRUE, LONG,	 op2(R, E),   0 },
/*b2*/	{ "lss",   TRUE,  LONG,  op2(E, R),   0 },
/*b3*/	{ "btr",   TRUE,  LONG,  op2(R, E),   0 },
/*b4*/	{ "lfs",   TRUE,  LONG,  op2(E, R),   0 },
/*b5*/	{ "lgs",   TRUE,  LONG,  op2(E, R),   0 },
/*b6*/	{ "movzb", TRUE,  LONG,  op2(Eb, R),  0 },
/*b7*/	{ "movzw", TRUE,  LONG,  op2(Ew, R),  0 },

/*b8*/	{ "",      FALSE, NONE,  0,	      0 },
/*b9*/	{ "",      FALSE, NONE,  0,	      0 },
/*ba*/	{ NULL,    TRUE,  LONG,  op2(Ib, E),  db_Grp8 },
/*bb*/	{ "btc",   TRUE,  LONG,  op2(R, E),   0 },
/*bc*/	{ "bsf",   TRUE,  LONG,  op2(E, R),   0 },
/*bd*/	{ "bsr",   TRUE,  LONG,  op2(E, R),   0 },
/*be*/	{ "movsb", TRUE,  LONG,  op2(Eb, R),  0 },
/*bf*/	{ "movsw", TRUE,  LONG,  op2(Ew, R),  0 },
};

struct inst	db_inst_0fcx[] = {
/*c0*/	{ "xadd",  TRUE,  BYTE,	 op2(R, E),   0 },
/*c1*/	{ "xadd",  TRUE,  LONG,	 op2(R, E),   0 },
/*c2*/	{ "",	   FALSE, NONE,	 0,	      0 },
/*c3*/	{ "",	   FALSE, NONE,	 0,	      0 },
/*c4*/	{ "",	   FALSE, NONE,	 0,	      0 },
/*c5*/	{ "",	   FALSE, NONE,	 0,	      0 },
/*c6*/	{ "",	   FALSE, NONE,	 0,	      0 },
/*c7*/	{ NULL,    TRUE,  NONE,  op1(E),      db_GrpA },

/*c8*/	{ "bswap", FALSE, LONG,  op1(Ril),    0 },
/*c9*/	{ "bswap", FALSE, LONG,  op1(Ril),    0 },
/*ca*/	{ "bswap", FALSE, LONG,  op1(Ril),    0 },
/*cb*/	{ "bswap", FALSE, LONG,  op1(Ril),    0 },
/*cc*/	{ "bswap", FALSE, LONG,  op1(Ril),    0 },
/*cd*/	{ "bswap", FALSE, LONG,  op1(Ril),    0 },
/*ce*/	{ "bswap", FALSE, LONG,  op1(Ril),    0 },
/*cf*/	{ "bswap", FALSE, LONG,  op1(Ril),    0 },
};

struct inst *db_inst_0f[] = {
	db_inst_0f0x,
	NULL,
	db_inst_0f2x,
	db_inst_0f3x,
	NULL,
	NULL,
	NULL,
	NULL,
	db_inst_0f8x,
	db_inst_0f9x,
	db_inst_0fax,
	db_inst_0fbx,
	db_inst_0fcx,
	NULL,
	NULL,
	NULL
};

char *	db_Esc92[] = {
	"fnop",		"",		"",		"",
	"",		"",		"",		""
};
char *	db_Esc94[] = {
	"fchs",		"fabs",		"",		"",
	"ftst",		"fxam",		"",		""
};
char *	db_Esc95[] = {
	"fld1",		"fldl2t",	"fldl2e",	"fldpi",
	"fldlg2",	"fldln2",	"fldz",		""
};
char *	db_Esc96[] = {
	"f2xm1",	"fyl2x",	"fptan",	"fpatan",
	"fxtract",	"fprem1",	"fdecstp",	"fincstp"
};
char *	db_Esc97[] = {
	"fprem",	"fyl2xp1",	"fsqrt",	"fsincos",
	"frndint",	"fscale",	"fsin",		"fcos"
};

char *	db_Esca5[] = {
	"",		"fucompp",	"",		"",
	"",		"",		"",		""
};

char *	db_Escb4[] = {
	"fneni",	"fndisi",       "fnclex",	"fninit",
	"fsetpm",	"",		"",		""
};

char *	db_Esce3[] = {
	"",		"fcompp",	"",		"",
	"",		"",		"",		""
};

char *	db_Escf4[] = {
	"fnstsw",	"",		"",		"",
	"",		"",		"",		""
};

struct finst db_Esc8[] = {
/*0*/	{ "fadd",   SNGL,  op2(STI,ST),	0 },
/*1*/	{ "fmul",   SNGL,  op2(STI,ST),	0 },
/*2*/	{ "fcom",   SNGL,  op2(STI,ST),	0 },
/*3*/	{ "fcomp",  SNGL,  op2(STI,ST),	0 },
/*4*/	{ "fsub",   SNGL,  op2(STI,ST),	0 },
/*5*/	{ "fsubr",  SNGL,  op2(STI,ST),	0 },
/*6*/	{ "fdiv",   SNGL,  op2(STI,ST),	0 },
/*7*/	{ "fdivr",  SNGL,  op2(STI,ST),	0 },
};

struct finst db_Esc9[] = {
/*0*/	{ "fld",    SNGL,  op1(STI),	0 },
/*1*/	{ "",       NONE,  op1(STI),	"fxch" },
/*2*/	{ "fst",    SNGL,  op1(X),	db_Esc92 },
/*3*/	{ "fstp",   SNGL,  op1(X),	0 },
/*4*/	{ "fldenv", NONE,  op1(X),	db_Esc94 },
/*5*/	{ "fldcw",  NONE,  op1(X),	db_Esc95 },
/*6*/	{ "fnstenv",NONE,  op1(X),	db_Esc96 },
/*7*/	{ "fnstcw", NONE,  op1(X),	db_Esc97 },
};

struct finst db_Esca[] = {
/*0*/	{ "fiadd",  LONG,  0,		0 },
/*1*/	{ "fimul",  LONG,  0,		0 },
/*2*/	{ "ficom",  LONG,  0,		0 },
/*3*/	{ "ficomp", LONG,  0,		0 },
/*4*/	{ "fisub",  LONG,  op1(X),	0 },
/*5*/	{ "fisubr", LONG,  0,		0 },
/*6*/	{ "fidiv",  LONG,  0,		0 },
/*7*/	{ "fidivr", LONG,  0,		0 }
};

struct finst db_Escb[] = {
/*0*/	{ "fild",   LONG,  0,		0 },
/*1*/	{ "",       NONE,  0,		0 },
/*2*/	{ "fist",   LONG,  0,		0 },
/*3*/	{ "fistp",  LONG,  0,		0 },
/*4*/	{ "",       WORD,  op1(X),	db_Escb4 },
/*5*/	{ "fld",    EXTR,  0,		0 },
/*6*/	{ "",       WORD,  0,		0 },
/*7*/	{ "fstp",   EXTR,  0,		0 },
};

struct finst db_Escc[] = {
/*0*/	{ "fadd",   DBLR,  op2(ST,STI),	0 },
/*1*/	{ "fmul",   DBLR,  op2(ST,STI),	0 },
/*2*/	{ "fcom",   DBLR,  0,	 	0 },
/*3*/	{ "fcomp",  DBLR,  0,		0 },
/*4*/	{ "fsub",   DBLR,  op2(ST,STI),	"fsubr" },
/*5*/	{ "fsubr",  DBLR,  op2(ST,STI),	"fsub" },
/*6*/	{ "fdiv",   DBLR,  op2(ST,STI),	"fdivr" },
/*7*/	{ "fdivr",  DBLR,  op2(ST,STI),	"fdiv" },
};

struct finst db_Escd[] = {
/*0*/	{ "fld",    DBLR,  op1(STI),	"ffree" },
/*1*/	{ "",       NONE,  0,		0 },
/*2*/	{ "fst",    DBLR,  op1(STI),	0 },
/*3*/	{ "fstp",   DBLR,  op1(STI),	0 },
/*4*/	{ "frstor", NONE,  op1(STI),	"fucom" },
/*5*/	{ "",       NONE,  op1(STI),	"fucomp" },
/*6*/	{ "fnsave", NONE,  0,		0 },
/*7*/	{ "fnstsw", NONE,  0,		0 },
};

struct finst db_Esce[] = {
/*0*/	{ "fiadd",  WORD,  op2(ST,STI),	"faddp" },
/*1*/	{ "fimul",  WORD,  op2(ST,STI),	"fmulp" },
/*2*/	{ "ficom",  WORD,  0,		0 },
/*3*/	{ "ficomp", WORD,  op1(X),	db_Esce3 },
/*4*/	{ "fisub",  WORD,  op2(ST,STI),	"fsubrp" },
/*5*/	{ "fisubr", WORD,  op2(ST,STI),	"fsubp" },
/*6*/	{ "fidiv",  WORD,  op2(ST,STI),	"fdivrp" },
/*7*/	{ "fidivr", WORD,  op2(ST,STI),	"fdivp" },
};

struct finst db_Escf[] = {
/*0*/	{ "fild",   WORD,  0,		0 },
/*1*/	{ "",       WORD,  0,		0 },
/*2*/	{ "fist",   WORD,  0,		0 },
/*3*/	{ "fistp",  WORD,  0,		0 },
/*4*/	{ "fbld",   NONE,  op1(XA),	db_Escf4 },
/*5*/	{ "fild",   QUAD,  0,		0 },
/*6*/	{ "fbstp",  NONE,  0,		0 },
/*7*/	{ "fistp",  QUAD,  0,		0 },
};

struct finst *db_Esc_inst[] = {
	db_Esc8, db_Esc9, db_Esca, db_Escb,
	db_Escc, db_Escd, db_Esce, db_Escf
};

char *	db_Grp1[] = {
	"add",
	"or",
	"adc",
	"sbb",
	"and",
	"sub",
	"xor",
	"cmp"
};

char *	db_Grp2[] = {
	"rol",
	"ror",
	"rcl",
	"rcr",
	"shl",
	"shr",
	"shl",
	"sar"
};

struct inst db_Grp3[] = {
	{ "test",  TRUE, NONE, op2(I,E), 0 },
	{ "test",  TRUE, NONE, op2(I,E), 0 },
	{ "not",   TRUE, NONE, op1(E),   0 },
	{ "neg",   TRUE, NONE, op1(E),   0 },
	{ "mul",   TRUE, NONE, op2(E,A), 0 },
	{ "imul",  TRUE, NONE, op2(E,A), 0 },
	{ "div",   TRUE, NONE, op2(E,A), 0 },
	{ "idiv",  TRUE, NONE, op2(E,A), 0 },
};

struct inst	db_Grp4[] = {
	{ "inc",   TRUE, BYTE, op1(E),   0 },
	{ "dec",   TRUE, BYTE, op1(E),   0 },
	{ "",      TRUE, NONE, 0,	 0 },
	{ "",      TRUE, NONE, 0,	 0 },
	{ "",      TRUE, NONE, 0,	 0 },
	{ "",      TRUE, NONE, 0,	 0 },
	{ "",      TRUE, NONE, 0,	 0 },
	{ "",      TRUE, NONE, 0,	 0 }
};

struct inst	db_Grp5[] = {
	{ "inc",   TRUE, LONG, op1(E),   0 },
	{ "dec",   TRUE, LONG, op1(E),   0 },
	{ "call",  TRUE, QUAD, op1(Eind),0 },
	{ "lcall", TRUE, NONE, op1(Eind),0 },
	{ "jmp",   TRUE, NONE, op1(Eind),0 },
	{ "ljmp",  TRUE, NONE, op1(Eind),0 },
	{ "push",  TRUE, QUAD, op1(E),   0 },
	{ "",      TRUE, NONE, 0,	 0 }
};

struct inst db_inst_table[256] = {
/*00*/	{ "add",   TRUE,  BYTE,  op2(R, E),  0 },
/*01*/	{ "add",   TRUE,  LONG,  op2(R, E),  0 },
/*02*/	{ "add",   TRUE,  BYTE,  op2(E, R),  0 },
/*03*/	{ "add",   TRUE,  LONG,  op2(E, R),  0 },
/*04*/	{ "add",   FALSE, BYTE,  op2(I, A),  0 },
/*05*/	{ "add",   FALSE, LONG,  op2(Is, A), 0 },
/*06*/	{ "",      FALSE, NONE,  op1(Si),    0 },
/*07*/	{ "",      FALSE, NONE,  op1(Si),    0 },

/*08*/	{ "or",    TRUE,  BYTE,  op2(R, E),  0 },
/*09*/	{ "or",    TRUE,  LONG,  op2(R, E),  0 },
/*0a*/	{ "or",    TRUE,  BYTE,  op2(E, R),  0 },
/*0b*/	{ "or",    TRUE,  LONG,  op2(E, R),  0 },
/*0c*/	{ "or",    FALSE, BYTE,  op2(I, A),  0 },
/*0d*/	{ "or",    FALSE, LONG,  op2(I, A),  0 },
/*0e*/	{ "",      FALSE, NONE,  op1(Si),    0 },
/*0f*/	{ "",      FALSE, NONE,  0,	     0 },

/*10*/	{ "adc",   TRUE,  BYTE,  op2(R, E),  0 },
/*11*/	{ "adc",   TRUE,  LONG,  op2(R, E),  0 },
/*12*/	{ "adc",   TRUE,  BYTE,  op2(E, R),  0 },
/*13*/	{ "adc",   TRUE,  LONG,  op2(E, R),  0 },
/*14*/	{ "adc",   FALSE, BYTE,  op2(I, A),  0 },
/*15*/	{ "adc",   FALSE, LONG,  op2(Is, A), 0 },
/*16*/	{ "",      FALSE, NONE,  op1(Si),    0 },
/*17*/	{ "",      FALSE, NONE,  op1(Si),    0 },

/*18*/	{ "sbb",   TRUE,  BYTE,  op2(R, E),  0 },
/*19*/	{ "sbb",   TRUE,  LONG,  op2(R, E),  0 },
/*1a*/	{ "sbb",   TRUE,  BYTE,  op2(E, R),  0 },
/*1b*/	{ "sbb",   TRUE,  LONG,  op2(E, R),  0 },
/*1c*/	{ "sbb",   FALSE, BYTE,  op2(I, A),  0 },
/*1d*/	{ "sbb",   FALSE, LONG,  op2(Is, A), 0 },
/*1e*/	{ "",      FALSE, NONE,  op1(Si),    0 },
/*1f*/	{ "",      FALSE, NONE,  op1(Si),    0 },

/*20*/	{ "and",   TRUE,  BYTE,  op2(R, E),  0 },
/*21*/	{ "and",   TRUE,  LONG,  op2(R, E),  0 },
/*22*/	{ "and",   TRUE,  BYTE,  op2(E, R),  0 },
/*23*/	{ "and",   TRUE,  LONG,  op2(E, R),  0 },
/*24*/	{ "and",   FALSE, BYTE,  op2(I, A),  0 },
/*25*/	{ "and",   FALSE, LONG,  op2(I, A),  0 },
/*26*/	{ "",      FALSE, NONE,  0,	     0 },
/*27*/	{ "",      FALSE, NONE,  0,	     0 },

/*28*/	{ "sub",   TRUE,  BYTE,  op2(R, E),  0 },
/*29*/	{ "sub",   TRUE,  LONG,  op2(R, E),  0 },
/*2a*/	{ "sub",   TRUE,  BYTE,  op2(E, R),  0 },
/*2b*/	{ "sub",   TRUE,  LONG,  op2(E, R),  0 },
/*2c*/	{ "sub",   FALSE, BYTE,  op2(I, A),  0 },
/*2d*/	{ "sub",   FALSE, LONG,  op2(Is, A), 0 },
/*2e*/	{ "",      FALSE, NONE,  0,	     0 },
/*2f*/	{ "",      FALSE, NONE,  0,	     0 },

/*30*/	{ "xor",   TRUE,  BYTE,  op2(R, E),  0 },
/*31*/	{ "xor",   TRUE,  LONG,  op2(R, E),  0 },
/*32*/	{ "xor",   TRUE,  BYTE,  op2(E, R),  0 },
/*33*/	{ "xor",   TRUE,  LONG,  op2(E, R),  0 },
/*34*/	{ "xor",   FALSE, BYTE,  op2(I, A),  0 },
/*35*/	{ "xor",   FALSE, LONG,  op2(I, A),  0 },
/*36*/	{ "",      FALSE, NONE,  0,	     0 },
/*37*/	{ "",      FALSE, NONE,  0,	     0 },

/*38*/	{ "cmp",   TRUE,  BYTE,  op2(R, E),  0 },
/*39*/	{ "cmp",   TRUE,  LONG,  op2(R, E),  0 },
/*3a*/	{ "cmp",   TRUE,  BYTE,  op2(E, R),  0 },
/*3b*/	{ "cmp",   TRUE,  LONG,  op2(E, R),  0 },
/*3c*/	{ "cmp",   FALSE, BYTE,  op2(I, A),  0 },
/*3d*/	{ "cmp",   FALSE, LONG,  op2(Is, A), 0 },
/*3e*/	{ "",      FALSE, NONE,  0,	     0 },
/*3f*/	{ "",      FALSE, NONE,  0,	     0 },

/*40*/	{ "",      FALSE, LONG,  op1(Ri),    0 },
/*41*/	{ "",      FALSE, LONG,  op1(Ri),    0 },
/*42*/	{ "",      FALSE, LONG,  op1(Ri),    0 },
/*43*/	{ "",      FALSE, LONG,  op1(Ri),    0 },
/*44*/	{ "",      FALSE, LONG,  op1(Ri),    0 },
/*45*/	{ "",      FALSE, LONG,  op1(Ri),    0 },
/*46*/	{ "",      FALSE, LONG,  op1(Ri),    0 },
/*47*/	{ "",      FALSE, LONG,  op1(Ri),    0 },

/*48*/	{ "",      FALSE, LONG,  op1(Ri),    0 },
/*49*/	{ "",      FALSE, LONG,  op1(Ri),    0 },
/*4a*/	{ "",      FALSE, LONG,  op1(Ri),    0 },
/*4b*/	{ "",      FALSE, LONG,  op1(Ri),    0 },
/*4c*/	{ "",      FALSE, LONG,  op1(Ri),    0 },
/*4d*/	{ "",      FALSE, LONG,  op1(Ri),    0 },
/*4e*/	{ "",      FALSE, LONG,  op1(Ri),    0 },
/*4f*/	{ "",      FALSE, LONG,  op1(Ri),    0 },

/*50*/	{ "push",  FALSE, QUAD,  op1(Ri),    0 },
/*51*/	{ "push",  FALSE, QUAD,  op1(Ri),    0 },
/*52*/	{ "push",  FALSE, QUAD,  op1(Ri),    0 },
/*53*/	{ "push",  FALSE, QUAD,  op1(Ri),    0 },
/*54*/	{ "push",  FALSE, QUAD,  op1(Ri),    0 },
/*55*/	{ "push",  FALSE, QUAD,  op1(Ri),    0 },
/*56*/	{ "push",  FALSE, QUAD,  op1(Ri),    0 },
/*57*/	{ "push",  FALSE, QUAD,  op1(Ri),    0 },

/*58*/	{ "pop",   FALSE, QUAD,  op1(Ri),    0 },
/*59*/	{ "pop",   FALSE, QUAD,  op1(Ri),    0 },
/*5a*/	{ "pop",   FALSE, QUAD,  op1(Ri),    0 },
/*5b*/	{ "pop",   FALSE, QUAD,  op1(Ri),    0 },
/*5c*/	{ "pop",   FALSE, QUAD,  op1(Ri),    0 },
/*5d*/	{ "pop",   FALSE, QUAD,  op1(Ri),    0 },
/*5e*/	{ "pop",   FALSE, QUAD,  op1(Ri),    0 },
/*5f*/	{ "pop",   FALSE, QUAD,  op1(Ri),    0 },

/*60*/	{ "",      FALSE, LONG,  0,	     0 },
/*61*/	{ "",      FALSE, LONG,  0,	     0 },
/*62*/	{ "",      TRUE,  LONG,  op2(E, R),  0 },
/*63*/	{ "movsxd",TRUE,  LONG,  op2(E, R),  0 },
/*64*/	{ "",      FALSE, NONE,  0,	     0 },
/*65*/	{ "",      FALSE, NONE,  0,	     0 },
/*66*/	{ "",      FALSE, NONE,  0,	     0 },
/*67*/	{ "",      FALSE, NONE,  0,	     0 },

/*68*/	{ "push",  FALSE, QUAD,  op1(I),     0 },
/*69*/	{ "imul",  TRUE,  LONG,  op3(I,E,R), 0 },
/*6a*/	{ "push",  FALSE, QUAD,  op1(Ibs),   0 },
/*6b*/	{ "imul",  TRUE,  LONG,  op3(Ibs,E,R),0 },
/*6c*/	{ "ins",   FALSE, BYTE,  op2(DX, DI), 0 },
/*6d*/	{ "ins",   FALSE, LONG,  op2(DX, DI), 0 },
/*6e*/	{ "outs",  FALSE, BYTE,  op2(SI, DX), 0 },
/*6f*/	{ "outs",  FALSE, LONG,  op2(SI, DX), 0 },

/*70*/	{ "jo",    FALSE, NONE,  op1(Db),     0 },
/*71*/	{ "jno",   FALSE, NONE,  op1(Db),     0 },
/*72*/	{ "jb",    FALSE, NONE,  op1(Db),     0 },
/*73*/	{ "jnb",   FALSE, NONE,  op1(Db),     0 },
/*74*/	{ "jz",    FALSE, NONE,  op1(Db),     0 },
/*75*/	{ "jnz",   FALSE, NONE,  op1(Db),     0 },
/*76*/	{ "jbe",   FALSE, NONE,  op1(Db),     0 },
/*77*/	{ "jnbe",  FALSE, NONE,  op1(Db),     0 },

/*78*/	{ "js",    FALSE, NONE,  op1(Db),     0 },
/*79*/	{ "jns",   FALSE, NONE,  op1(Db),     0 },
/*7a*/	{ "jp",    FALSE, NONE,  op1(Db),     0 },
/*7b*/	{ "jnp",   FALSE, NONE,  op1(Db),     0 },
/*7c*/	{ "jl",    FALSE, NONE,  op1(Db),     0 },
/*7d*/	{ "jnl",   FALSE, NONE,  op1(Db),     0 },
/*7e*/	{ "jle",   FALSE, NONE,  op1(Db),     0 },
/*7f*/	{ "jnle",  FALSE, NONE,  op1(Db),     0 },

/*80*/	{ NULL,	   TRUE,  BYTE,  op2(I, E),   db_Grp1 },
/*81*/	{ NULL,	   TRUE,  LONG,  op2(I, E),   db_Grp1 },
/*82*/	{ NULL,	   TRUE,  BYTE,  op2(I, E),   db_Grp1 },
/*83*/	{ NULL,	   TRUE,  LONG,  op2(Ibs,E),  db_Grp1 },
/*84*/	{ "test",  TRUE,  BYTE,  op2(R, E),   0 },
/*85*/	{ "test",  TRUE,  LONG,  op2(R, E),   0 },
/*86*/	{ "xchg",  TRUE,  BYTE,  op2(R, E),   0 },
/*87*/	{ "xchg",  TRUE,  LONG,  op2(R, E),   0 },

/*88*/	{ "mov",   TRUE,  BYTE,  op2(R, E),   0 },
/*89*/	{ "mov",   TRUE,  LONG,  op2(R, E),   0 },
/*8a*/	{ "mov",   TRUE,  BYTE,  op2(E, R),   0 },
/*8b*/	{ "mov",   TRUE,  LONG,  op2(E, R),   0 },
/*8c*/	{ "mov",   TRUE,  NONE,  op2(S, Ew),  0 },
/*8d*/	{ "lea",   TRUE,  LONG,  op2(E, R),   0 },
/*8e*/	{ "mov",   TRUE,  NONE,  op2(Ew, S),  0 },
/*8f*/	{ "pop",   TRUE,  QUAD,  op1(Dl),     0 },

/*90*/	{ "nop",   FALSE, NONE,  0,	      0 },
/*91*/	{ "xchg",  FALSE, LONG,  op2(A, Ri),  0 },
/*92*/	{ "xchg",  FALSE, LONG,  op2(A, Ri),  0 },
/*93*/	{ "xchg",  FALSE, LONG,  op2(A, Ri),  0 },
/*94*/	{ "xchg",  FALSE, LONG,  op2(A, Ri),  0 },
/*95*/	{ "xchg",  FALSE, LONG,  op2(A, Ri),  0 },
/*96*/	{ "xchg",  FALSE, LONG,  op2(A, Ri),  0 },
/*97*/	{ "xchg",  FALSE, LONG,  op2(A, Ri),  0 },

/*98*/	{ "cbw",   FALSE, SDEP,  0,	      "cwde\0cdqe" },
/*99*/	{ "cwd",   FALSE, SDEP,  0,	      "cdq\0cqo"  },
/*9a*/	{ "",      FALSE, NONE,  op1(OS),     0 },
/*9b*/	{ "wait",  FALSE, NONE,  0,	      0 },
/*9c*/	{ "pushf", FALSE, QUAD,  0,	      0 },
/*9d*/	{ "popf",  FALSE, QUAD,  0,	      0 },
/*9e*/	{ "sahf",  FALSE, NONE,  0,	      0 },
/*9f*/	{ "lahf",  FALSE, NONE,  0,	      0 },

/*a0*/	{ "mov",   FALSE, BYTE,  op2(O, A),   0 },
/*a1*/	{ "mov",   FALSE, LONG,  op2(O, A),   0 },
/*a2*/	{ "mov",   FALSE, BYTE,  op2(A, O),   0 },
/*a3*/	{ "mov",   FALSE, LONG,  op2(A, O),   0 },
/*a4*/	{ "movs",  FALSE, BYTE,  op2(SI,DI),  0 },
/*a5*/	{ "movs",  FALSE, LONG,  op2(SI,DI),  0 },
/*a6*/	{ "cmps",  FALSE, BYTE,  op2(SI,DI),  0 },
/*a7*/	{ "cmps",  FALSE, LONG,  op2(SI,DI),  0 },

/*a8*/	{ "test",  FALSE, BYTE,  op2(I, A),   0 },
/*a9*/	{ "test",  FALSE, LONG,  op2(I, A),   0 },
/*aa*/	{ "stos",  FALSE, BYTE,  op1(DI),     0 },
/*ab*/	{ "stos",  FALSE, LONG,  op1(DI),     0 },
/*ac*/	{ "lods",  FALSE, BYTE,  op1(SI),     0 },
/*ad*/	{ "lods",  FALSE, LONG,  op1(SI),     0 },
/*ae*/	{ "scas",  FALSE, BYTE,  op1(SI),     0 },
/*af*/	{ "scas",  FALSE, LONG,  op1(SI),     0 },

/*b0*/	{ "mov",   FALSE, BYTE,  op2(I, Ri),  0 },
/*b1*/	{ "mov",   FALSE, BYTE,  op2(I, Ri),  0 },
/*b2*/	{ "mov",   FALSE, BYTE,  op2(I, Ri),  0 },
/*b3*/	{ "mov",   FALSE, BYTE,  op2(I, Ri),  0 },
/*b4*/	{ "mov",   FALSE, BYTE,  op2(I, Ri),  0 },
/*b5*/	{ "mov",   FALSE, BYTE,  op2(I, Ri),  0 },
/*b6*/	{ "mov",   FALSE, BYTE,  op2(I, Ri),  0 },
/*b7*/	{ "mov",   FALSE, BYTE,  op2(I, Ri),  0 },

/*b8*/	{ "mov",   FALSE, LONG,  op2(I, Ri),  0 },
/*b9*/	{ "mov",   FALSE, LONG,  op2(I, Ri),  0 },
/*ba*/	{ "mov",   FALSE, LONG,  op2(I, Ri),  0 },
/*bb*/	{ "mov",   FALSE, LONG,  op2(I, Ri),  0 },
/*bc*/	{ "mov",   FALSE, LONG,  op2(I, Ri),  0 },
/*bd*/	{ "mov",   FALSE, LONG,  op2(I, Ri),  0 },
/*be*/	{ "mov",   FALSE, LONG,  op2(I, Ri),  0 },
/*bf*/	{ "mov",   FALSE, LONG,  op2(I, Ri),  0 },

/*c0*/	{ NULL,	   TRUE,  BYTE,  op2(Ib, E),  db_Grp2 },
/*c1*/	{ NULL,	   TRUE,  LONG,  op2(Ib, E),  db_Grp2 },
/*c2*/	{ "ret",   FALSE, NONE,  op1(Iw),     0 },
/*c3*/	{ "ret",   FALSE, NONE,  0,	      0 },
/*c4*/	{ "",      TRUE,  LONG,  op2(E, R),   0 },
/*c5*/	{ "",      TRUE,  LONG,  op2(E, R),   0 },
/*c6*/	{ "mov",   TRUE,  BYTE,  op2(I, E),   0 },
/*c7*/	{ "mov",   TRUE,  LONG,  op2(I, E),   0 },

/*c8*/	{ "enter", FALSE, NONE,  op2(Iq, Ib), 0 },
/*c9*/	{ "leave", FALSE, NONE,  0,           0 },
/*ca*/	{ "lret",  FALSE, NONE,  op1(Iw),     0 },
/*cb*/	{ "lret",  FALSE, NONE,  0,	      0 },
/*cc*/	{ "int",   FALSE, NONE,  op1(o3),     0 },
/*cd*/	{ "int",   FALSE, NONE,  op1(Ib),     0 },
/*ce*/	{ "",      FALSE, NONE,  0,	      0 },
/*cf*/	{ "iret",  FALSE, NONE,  0,	      0 },

/*d0*/	{ NULL,	   TRUE,  BYTE,  op2(o1, E),  db_Grp2 },
/*d1*/	{ NULL,	   TRUE,  LONG,  op2(o1, E),  db_Grp2 },
/*d2*/	{ NULL,	   TRUE,  BYTE,  op2(CL, E),  db_Grp2 },
/*d3*/	{ NULL,	   TRUE,  LONG,  op2(CL, E),  db_Grp2 },
/*d4*/	{ "",      TRUE,  NONE,  op1(Iba),    0 },
/*d5*/	{ "",      TRUE,  NONE,  op1(Iba),    0 },
/*d6*/	{ ".byte\t0xd6",FALSE, NONE, 0,       0 },
/*d7*/	{ "xlat",  FALSE, BYTE,  op1(BX),     0 },

/* d8 to df block is ignored: direct test in code handles them */
/*d8*/	{ "",      TRUE,  NONE,  0,	      db_Esc8 },
/*d9*/	{ "",      TRUE,  NONE,  0,	      db_Esc9 },
/*da*/	{ "",      TRUE,  NONE,  0,	      db_Esca },
/*db*/	{ "",      TRUE,  NONE,  0,	      db_Escb },
/*dc*/	{ "",      TRUE,  NONE,  0,	      db_Escc },
/*dd*/	{ "",      TRUE,  NONE,  0,	      db_Escd },
/*de*/	{ "",      TRUE,  NONE,  0,	      db_Esce },
/*df*/	{ "",      TRUE,  NONE,  0,	      db_Escf },

/*e0*/	{ "loopne",FALSE, NONE,  op1(Db),     0 },
/*e1*/	{ "loope", FALSE, NONE,  op1(Db),     0 },
/*e2*/	{ "loop",  FALSE, NONE,  op1(Db),     0 },
/*e3*/	{ "jcxz",  FALSE, SDEP,  op1(Db),     "jecxz\0jrcxz" },
/*e4*/	{ "in",    FALSE, BYTE,  op2(Ib, A),  0 },
/*e5*/	{ "in",    FALSE, LONG,  op2(Ib, A) , 0 },
/*e6*/	{ "out",   FALSE, BYTE,  op2(A, Ib),  0 },
/*e7*/	{ "out",   FALSE, LONG,  op2(A, Ib) , 0 },

/*e8*/	{ "call",  FALSE, QUAD,  op1(Dl),     0 },
/*e9*/	{ "jmp",   FALSE, NONE,  op1(Dl),     0 },
/*ea*/	{ "",      FALSE, NONE,  op1(OS),     0 },
/*eb*/	{ "jmp",   FALSE, NONE,  op1(Db),     0 },
/*ec*/	{ "in",    FALSE, BYTE,  op2(DX, A),  0 },
/*ed*/	{ "in",    FALSE, LONG,  op2(DX, A) , 0 },
/*ee*/	{ "out",   FALSE, BYTE,  op2(A, DX),  0 },
/*ef*/	{ "out",   FALSE, LONG,  op2(A, DX) , 0 },

/*f0*/	{ "",      FALSE, NONE,  0,	     0 },
/*f1*/	{ "",      FALSE, NONE,  0,	     0 },
/*f2*/	{ "",      FALSE, NONE,  0,	     0 },
/*f3*/	{ "",      FALSE, NONE,  0,	     0 },
/*f4*/	{ "hlt",   FALSE, NONE,  0,	     0 },
/*f5*/	{ "cmc",   FALSE, NONE,  0,	     0 },
/*f6*/	{ "",      TRUE,  BYTE,  0,	     db_Grp3 },
/*f7*/	{ "",	   TRUE,  LONG,  0,	     db_Grp3 },

/*f8*/	{ "clc",   FALSE, NONE,  0,	     0 },
/*f9*/	{ "stc",   FALSE, NONE,  0,	     0 },
/*fa*/	{ "cli",   FALSE, NONE,  0,	     0 },
/*fb*/	{ "sti",   FALSE, NONE,  0,	     0 },
/*fc*/	{ "cld",   FALSE, NONE,  0,	     0 },
/*fd*/	{ "std",   FALSE, NONE,  0,	     0 },
/*fe*/	{ "",	   TRUE,  RDEP,  0,	     db_Grp4 },
/*ff*/	{ "",	   TRUE,  RDEP,  0,	     db_Grp5 },
};

struct inst	db_bad_inst =
	{ "???",   FALSE, NONE,  0,	      0 }
;

#define REX_W(rex)	(((rex) & 0x8) == 0x8)	/* 64-bit operand size */
#define REX_R(rex)	(((rex) & 0x4) << 1)	/* ModRM reg field extension */
#define REX_X(rex)	(((rex) & 0x2) << 2)	/* SIB index field extension */
#define REX_B(rex)	(((rex) & 0x1) << 3)	/* ModRM r/m and SIB base ext */

#define	f_mod(byte)		((byte)>>6)
#define	f_reg(byte, rex)	((((byte)>>3)&0x7) + REX_R(rex))
#define	f_rm(byte, rex)		(((byte)&0x7) + REX_B(rex))

#define	sib_ss(byte)		((byte)>>6)
#define	sib_index(byte, rex)	((((byte)>>3)&0x7) + REX_X(rex))
#define	sib_base(byte, rex)	(((byte)&0x7) + REX_B(rex))

struct i_addr {
	int		is_reg;	/* if reg, reg number is in 'disp' */
	int		disp;
	char *		base;
	char *		index;
	int		ss;
};

char *	db_index_reg_16[8] = {
	"%bx,%si",
	"%bx,%di",
	"%bp,%si",
	"%bp,%di",
	"%si",
	"%di",
	"%bp",
	"%bx"
};

char *	db_reg[4][16] = {
	{ "%al",  "%cl",  "%dl",  "%bl",  "%ah",  "%ch",  "%dh",  "%bh",
	  "%r8b", "%r9b", "%r10b", "%r11b", "%r12b", "%r13b", "%r14b", "%r15b"},
	{ "%ax",  "%cx",  "%dx",  "%bx",  "%sp",  "%bp",  "%si",  "%di",
	  "%r8w", "%r9w", "%r10w", "%r11w", "%r12w", "%r13w", "%r14w", "%r15w"},
	{ "%eax", "%ecx", "%edx", "%ebx", "%esp", "%ebp", "%esi", "%edi",
	  "%r8d", "%r9d", "%r10d", "%r11d", "%r12d", "%r13d", "%r14d", "%r15d"},
	{ "%rax", "%rcx", "%rdx", "%rbx", "%rsp", "%rbp", "%rsi", "%rdi",
	  "%r8",  "%r9",  "%r10", "%r11", "%r12", "%r13", "%r14", "%r15" }
};

char *	db_seg_reg[8] = {
	"%es", "%cs", "%ss", "%ds", "%fs", "%gs", "", ""
};

/*
 * lengths for size attributes
 */
int db_lengths[] = {
	1,	/* BYTE */
	2,	/* WORD */
	4,	/* LONG */
	8,	/* QUAD */
	4,	/* SNGL */
	8,	/* DBLR */
	10,	/* EXTR */
};

#define	get_value_inc(result, loc, size, is_signed) \
	do { \
		result = db_get_value((loc), (size), (is_signed)); \
		(loc) += (size); \
	} while (0)


db_addr_t db_read_address(db_addr_t, int, int, int, struct i_addr *);
void db_print_address(char *, int, struct i_addr *);
db_addr_t db_disasm_esc(db_addr_t, int, int, int, int, char *);
db_addr_t db_disasm_3dnow(db_addr_t, int, int, int, char *);

/*
 * Read address at location and return updated location.
 */
db_addr_t
db_read_address(db_addr_t loc, int short_addr, int regmodrm, int rex,
    struct i_addr *addrp)
{
	int		mod, rm, sib, index, disp, size;

	size = (short_addr ? LONG : QUAD);
	mod = f_mod(regmodrm);
	rm  = f_rm(regmodrm, rex);

	if (mod == 3) {
		addrp->is_reg = TRUE;
		addrp->disp = rm;
		return (loc);
	}
	addrp->is_reg = FALSE;
	addrp->index = 0;

	if (rm == 4 || rm == 12) {
		get_value_inc(sib, loc, 1, FALSE);
		rm = sib_base(sib, rex);
		index = sib_index(sib, rex);
		if (index != 4)
			addrp->index = db_reg[size][index];
		addrp->ss = sib_ss(sib);
	}

	switch (mod) {
	case 0:
		if (rm == 5) {
		get_value_inc(addrp->disp, loc, 4, FALSE);
			addrp->base = 0;
		} else {
			addrp->disp = 0;
			addrp->base = db_reg[size][rm];
		}
		break;
	case 1:
		get_value_inc(disp, loc, 1, TRUE);
		addrp->disp = disp;
		addrp->base = db_reg[size][rm];
		break;
	case 2:
		get_value_inc(disp, loc, 4, FALSE);
		addrp->disp = disp;
		addrp->base = db_reg[size][rm];
		break;
	}
	return (loc);
}

void
db_print_address(char *seg, int size, struct i_addr *addrp)
{
	if (addrp->is_reg) {
		db_printf("%s", db_reg[size][addrp->disp]);
		return;
	}

	if (seg)
		db_printf("%s:", seg);

	db_printsym((db_addr_t)addrp->disp, DB_STGY_ANY, db_printf);
	if (addrp->base != 0 || addrp->index != 0) {
		db_printf("(");
		if (addrp->base)
			db_printf("%s", addrp->base);
		if (addrp->index)
			db_printf(",%s,%d", addrp->index, 1<<addrp->ss);
		db_printf(")");
	}
}

/*
 * Disassemble 3DNow! instruction and return updated location.
 */
db_addr_t
db_disasm_3dnow(db_addr_t loc, int short_addr, int size, int rex, char *seg)
{
	int regmodrm, sib, displacement, opcode;

	get_value_inc(regmodrm, loc, 1, FALSE);
	get_value_inc(sib, loc, 1, FALSE);
	get_value_inc(displacement, loc, 1, FALSE);
	get_value_inc(opcode, loc, 1, FALSE);

	/* XXX fix later... */ 
	db_printf("<3DNow! instruction>");

	return (loc);
}

/*
 * Disassemble floating-point ("escape") instruction
 * and return updated location.
 */
db_addr_t
db_disasm_esc(db_addr_t loc, int inst, int short_addr, int size, int rex,
    char *seg)
{
	int		regmodrm;
	struct finst	*fp;
	int		mod;
	struct i_addr	address;
	char *		name;

	get_value_inc(regmodrm, loc, 1, FALSE);
	fp = &db_Esc_inst[inst - 0xd8][f_reg(regmodrm, 0)];
	mod = f_mod(regmodrm);
	if (mod != 3) {
		if (*fp->f_name == '\0') {
			db_printf("<bad instruction>");
			return (loc);
		}

		/*
		 * Normal address modes.
		 */
		loc = db_read_address(loc, short_addr, regmodrm, rex, &address);
		db_printf("%s", fp->f_name);
		switch (fp->f_size) {
		case SNGL:
			db_printf("s");
			break;
		case DBLR:
			db_printf("l");
			break;
		case EXTR:
			db_printf("t");
			break;
		case WORD:
			db_printf("s");
			break;
		case LONG:
			db_printf("l");
			break;
		case QUAD:
			db_printf("q");
			break;
		default:
			break;
		}
		db_printf("\t");
		db_print_address(seg, BYTE, &address);
	} else {
		/*
		 * 'reg-reg' - special formats
		 */
		switch (fp->f_rrmode) {
		case op2(ST,STI):
			name = (fp->f_rrname) ? fp->f_rrname : fp->f_name;
			db_printf("%s\t%%st,%%st(%d)",name, f_rm(regmodrm, 0));
			break;
		case op2(STI,ST):
			name = (fp->f_rrname) ? fp->f_rrname : fp->f_name;
			db_printf("%s\t%%st(%d),%%st",name, f_rm(regmodrm, 0));
			break;
		case op1(STI):
			name = (fp->f_rrname) ? fp->f_rrname : fp->f_name;
			db_printf("%s\t%%st(%d)",name, f_rm(regmodrm, 0));
			break;
		case op1(X):
			name = ((char * const *)fp->f_rrname)[f_rm(regmodrm,0)];
			if (*name == '\0')
				goto bad;
			db_printf("%s", name);
			break;
		case op1(XA):
			name = ((char * const *)fp->f_rrname)[f_rm(regmodrm,0)];
			if (*name == '\0')
				goto bad;
			db_printf("%s\t%%ax", name);
			break;
		default:
		bad:
			db_printf("<bad instruction>");
			break;
		}
	}

	return (loc);
}

/*
 * Disassemble instruction at 'loc'.  'altfmt' specifies an
 * (optional) alternate format.  Return address of start of
 * next instruction.
 */
db_addr_t
db_disasm(db_addr_t loc, boolean_t altfmt)
{
	int	inst;
	int	size;
	int	short_addr;
	char *	seg;
	struct inst *	ip;
	char *	i_name;
	int	i_size;
	int	i_mode;
	int	regmodrm = 0;
	boolean_t	first;
	int	displ;
	int	prefix;
	long	imm;
	int	imm2;
	int	len;
	int	rex = 0;
	int	segovr_grp;
	int	repe, repne;
	struct i_addr	address;
	db_addr_t	loc_orig = loc;
	char	tmpfmt[28];

	get_value_inc(inst, loc, 1, FALSE);
	short_addr = FALSE;
	size = LONG;
	seg = 0;
	segovr_grp = 0;
	repe = 0;
	repne = 0;

	/*
	 * Get prefixes
	 */
	prefix = TRUE;
	do {
		switch (inst) {
		case 0x66:		/* data16 */
			size = WORD;
			break;
		case 0x67:
			short_addr = TRUE;
			break;
		case 0x26:
			segovr_grp++;
			db_printf(" <segment override prefix ignored>");
			break;
		case 0x36:
			db_printf(" <segment override prefix ignored>");
			segovr_grp++;
			break;
		case 0x2e:
			db_printf(" <segment override prefix ignored>");
			segovr_grp++;
			break;
		case 0x3e:
			db_printf(" <segment override prefix ignored>");
			segovr_grp++;
			break;
		case 0x64:
			segovr_grp++;
			seg = "%fs";
			break;
		case 0x65:
			segovr_grp++;
			seg = "%gs";
			break;
		case 0xf0:
			db_printf("lock ");
			break;
		case 0xf2:
			repne++;
			break;
		case 0xf3:
			repe++;
			break;
		default:
			prefix = FALSE;
			break;
		}
		if (prefix)
			get_value_inc(inst, loc, 1, FALSE);
	} while (prefix);
	if (segovr_grp > 1)
		seg = "<bad segment override prefix combination> ";
	if (repe > 0 && repne > 0)
		db_printf("<bad repeat prefex combination> ");
	else if (repe > 0)
		db_printf("repe ");	/* XXX "rep" if not CMPSx or SCASx */
	else if (repne > 0)
		db_printf("repne ");

	if (inst >= 0x40 && inst <= 0x4f) {
		// rex page 14
		rex = inst;
		if (REX_W(rex))
			size = QUAD;
		get_value_inc(inst, loc, 1, FALSE);
	}

	if (inst >= 0xd8 && inst <= 0xdf) {
		loc = db_disasm_esc(loc, inst, short_addr, size, rex, seg);
		goto done;
	}

	if (inst == 0x0f) {
		get_value_inc(inst, loc, 1, FALSE);
		if (inst == 0x0f) {
			loc = db_disasm_3dnow(loc, short_addr, size, rex, seg);
			goto done;
		}
		ip = db_inst_0f[inst>>4];
		if (ip == 0)
			ip = &db_bad_inst;
		else
			ip = &ip[inst&0xf];
	} else {
		ip = &db_inst_table[inst];
	}

	if (ip->i_has_modrm) {
		get_value_inc(regmodrm, loc, 1, FALSE);
		loc = db_read_address(loc, short_addr, regmodrm, rex, &address);
	}

	i_name = ip->i_name;
	i_size = ip->i_size;
	i_mode = ip->i_mode;

	if (i_size == RDEP) {
		/* sub-table to handle dependency on reg from ModR/M byte */
		ip = (struct inst *)ip->i_extra;
		ip = &ip[f_reg(regmodrm, 0)];
		i_name = ip->i_name;
		i_mode = ip->i_mode;
		i_size = ip->i_size;
	} else if (i_name == NULL) {
		i_name = ((char **)ip->i_extra)[f_reg(regmodrm, 0)];
	} else if (ip->i_extra == db_Grp3) {
		ip = (struct inst *)ip->i_extra;
		ip = &ip[f_reg(regmodrm, 0)];
		i_name = ip->i_name;
		i_mode = ip->i_mode;
	}

	/* ModR/M-specific operation? */
	if ((i_mode & 0xFF) == MEx) {
		if (f_mod(regmodrm) != 3)
			i_mode = op1(E);
		else {
			/* unknown extension? */
			if (f_rm(regmodrm, 0) > (i_mode >> 8))
				i_name = "";
			else {
				/* skip to the specific op */
				int i = f_rm(regmodrm, 0);
				i_name = ip->i_extra;
				while (i-- > 0)
					while (*i_name++)
						;
			}
			i_mode = 0;
		}
	}

	if (i_size == SDEP) {
		if (size == WORD)
			db_printf("%s", i_name);
		else if (size == LONG)
			db_printf("%s", (char *)ip->i_extra);
		else {
			char *cp = ip->i_extra;
			while (*cp)
				cp++;
			cp++;
			db_printf("%s", cp);
		}
	} else {
		db_printf("%s", i_name);
		if (i_size != NONE) {
			if (i_size == BYTE) {
				db_printf("b");
				size = BYTE;
			} else if (REX_W(rex)) {
				db_printf("q");
				size = QUAD;
			} else if (i_size == WORD) {
				db_printf("w");
				size = WORD;
			} else if (i_size == QUAD) {
				size = QUAD;
				db_printf("q");
			} else if (size == WORD) {
				db_printf("w");
			} else {
				db_printf("l");
			}
		}
	}
	db_printf("\t");
	for (first = TRUE; i_mode != 0; i_mode >>= 8, first = FALSE) {
		if (!first)
			db_printf(",");

		switch (i_mode & 0xFF) {
		case E: //XXX
			db_print_address(seg, size, &address);
			break;
		case Eind: //XXX
			db_printf("*");
			db_print_address(seg, size, &address);
			break;
		case Ew: //XXX
			db_print_address(seg, WORD, &address);
			break;
		case Eb: //XXX
			db_print_address(seg, BYTE, &address);
			break;
		case R:
			db_printf("%s", db_reg[size][f_reg(regmodrm, rex)]);
			break;
		case Rw:
			db_printf("%s", db_reg[WORD][f_reg(regmodrm, rex)]);
			break;
		case Ri:
			db_printf("%s", db_reg[size][f_rm(inst, rex)]);
			break;
		case Ril:
			db_printf("%s", db_reg[LONG][f_rm(inst, rex)]);
			break;
		case S:
			db_printf("%s", db_seg_reg[f_reg(regmodrm, 0)]);
			break;
		case Si:
			db_printf("%s", db_seg_reg[f_reg(inst, 0)]);
			break;
		case A:
			db_printf("%s", db_reg[size][0]);	/* acc */
			break;
		case BX:
			if (seg)
				db_printf("%s:", seg);
			db_printf("(%s)", short_addr ? "%ebx" : "%rbx");
			break;
		case CL:
			db_printf("%%cl");
			break;
		case DX:
			db_printf("%%dx");
			break;
		case SI:
			if (seg)
				db_printf("%s:", seg);
			db_printf("(%s)", short_addr ? "%esi" : "%rsi");
			break;
		case DI:
			db_printf("%%es:(%s)", short_addr ? "%edi" : "%rdi");
			break;
		case CR:
			db_printf("%%cr%d", f_reg(regmodrm, rex));
			break;
		case DR:
			db_printf("%%dr%d", f_reg(regmodrm, rex));
			break;
		case TR: //XXX
			db_printf("%%tr%d", f_reg(regmodrm, rex));
			break;
		case I:
			len = db_lengths[size];
			get_value_inc(imm, loc, len, FALSE);
			db_printf("$%s", db_format(tmpfmt, sizeof tmpfmt,
			    (int)imm, DB_FORMAT_N, 1, 0));
			break;
		case Is:
			len = db_lengths[size];
			get_value_inc(imm, loc, len, TRUE);
			db_printf("$%s", db_format(tmpfmt, sizeof tmpfmt,
			    (int)imm, DB_FORMAT_R, 1, 0));
			break;
		case Ib:
			get_value_inc(imm, loc, 1, FALSE);
			db_printf("$%s", db_format(tmpfmt, sizeof tmpfmt,
			    (int)imm, DB_FORMAT_N, 1, 0));
			break;
		case Iba:
			get_value_inc(imm, loc, 1, FALSE);
			if (imm != 0x0a)
				db_printf("$%s", db_format(tmpfmt, sizeof tmpfmt,
				    (int)imm, DB_FORMAT_N, 1, 0));
			break;
		case Ibs: //XXX
			get_value_inc(imm, loc, 1, TRUE);
			if (size == WORD)
				imm &= 0xFFFF;
			db_printf("$%s", db_format(tmpfmt, sizeof tmpfmt,
			    (int)imm, DB_FORMAT_R, 1, 0));
			break;
		case Iw:
			get_value_inc(imm, loc, 2, FALSE);
			db_printf("$%s", db_format(tmpfmt, sizeof tmpfmt,
			    (int)imm, DB_FORMAT_N, 1, 0));
			break;
		case Iq:
			get_value_inc(imm, loc, 8, TRUE);
			db_printf("$%s", db_format(tmpfmt, sizeof tmpfmt,
			   (int)((imm >> 32) & 0xffffffff), DB_FORMAT_R, 1, 0));
			db_printf(" %s", db_format(tmpfmt, sizeof tmpfmt,
			   (int)(imm & 0xffffffff), DB_FORMAT_R, 1, 0));
			break;
		case O: //XXX
			if (short_addr)
				get_value_inc(displ, loc, 2, TRUE);
			else
				get_value_inc(displ, loc, 4, TRUE);
			if (seg)
				db_printf("%s:%s", seg, db_format(tmpfmt,
				    sizeof tmpfmt, displ, DB_FORMAT_R, 1, 0));
			else
				db_printsym((db_addr_t)displ, DB_STGY_ANY,
				    db_printf);
			break;
		case Db: //XXX
			get_value_inc(displ, loc, 1, TRUE);
			displ += loc;
			if (size == WORD)
				displ &= 0xFFFF;
			db_printsym((db_addr_t)displ, DB_STGY_XTRN, db_printf);
			break;
		case Dl: //XXX
			len = db_lengths[size];
			get_value_inc(displ, loc, len, FALSE);
			displ += loc;
			if (size == WORD)
				displ &= 0xFFFF;
			db_printsym((db_addr_t)displ, DB_STGY_XTRN, db_printf);
			break;
		case o1: //XXX
			db_printf("$1");
			break;
		case o3: //XXX
			db_printf("$3");
			break;
		case OS: //XXX
			len = db_lengths[size];
			get_value_inc(imm, loc, len, FALSE);	/* offset */
			get_value_inc(imm2, loc, 2, FALSE);	/* segment */
			db_printf("$0x%#x", imm2);
			break;
		}
	}

	if (altfmt == 0 && (inst == 0xe9 || inst == 0xeb)) {
		/*
		 * GAS pads to longword boundary after unconditional jumps.
		 */
		loc = (loc + (4-1)) & ~(4-1);
	}
done:
	if (loc - loc_orig > 15)
		db_printf(" <instruction too long>");
	if (altfmt) {
		db_printf("\n\t");
		while (loc_orig < loc) {
			get_value_inc(imm, loc_orig, 1, FALSE);
			if (imm < 0x10)
				db_printf("0");
			db_printf("%x ", (int)imm);
		}
	}
	db_printf("\n");
	return (loc);
}
@


1.16
log
@Teach ddb's disassembler about {rd,wr}[fg]sbase

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.15 2015/06/24 20:50:39 miod Exp $	*/
d123 1
a123 1
	{ "sgdt",   FALSE, NONE, op1(E),     0 },
d125 1
a125 1
	{ "lgdt",   FALSE, NONE, op2(MEx,2), "xgetbv\0xsetbv" },
@


1.15
log
@Uninitialized variables; pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.14 2015/03/14 03:38:46 jsg Exp $	*/
d139 4
a142 4
	{ "fxsave",   FALSE, NONE, op1(E),     0 },
	{ "fxrstor",  FALSE, NONE, op1(E),     0 },
	{ "ldmxcsr",  FALSE, NONE, op1(E),     0 },
	{ "stmxcsr",  FALSE, NONE, op1(E),     0 },
@


1.14
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.13 2014/09/14 14:17:23 jsg Exp $	*/
d1435 1
@


1.13
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.12 2014/03/11 04:11:14 guenther Exp $	*/
a40 1
#include <ddb/db_interface.h>
@


1.12
log
@Synchronize the i386 and amd64 ddb disassemblers and add support
for many newer instructions.

With feedback from jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.11 2013/11/19 04:12:17 guenther Exp $	*/
a35 1
#include <sys/proc.h>
@


1.11
log
@format string fixes picked up with -Wformat=2

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.10 2013/10/02 21:20:22 sf Exp $	*/
d56 1
d97 1
d124 9
a132 3
char *	db_Grp7[] = {
	"sgdt",		"sidt",		"lgdt",		"lidt",
	"smsw",		"",		"lmsw",		"invlpg"
d140 9
a148 3
char *	db_Grp9[] = {
	"fxsave",	"fxrstor",	"",		"",
	"",		"",		"",		""
d153 1
a153 1
	"",		"",		"",		""
d157 1
a157 1
	"xstore-rng",	"xcrypt-ecb",	"xcrypt-cbc",	"",
d161 5
d167 2
a168 2
/*00*/	{ "",	   TRUE,  NONE,  op1(Ew),     db_Grp6 },
/*01*/	{ "",	   TRUE,  NONE,  op1(Ew),     db_Grp7 },
d273 2
a274 2
/*a6*/	{ "",      FALSE, NONE,  0,	      0 },
/*a7*/	{ "",      TRUE,  NONE,  0,	      db_GrpB },
d282 1
a282 1
/*ae*/	{ "",      TRUE,  NONE,  op1(E),      db_Grp9 },
d298 1
a298 1
/*ba*/	{ "",      TRUE,  LONG,  op2(Ib, E),  db_Grp8 },
d314 1
a314 1
/*c7*/	{ "",      TRUE,  NONE,  op1(E),      db_GrpA },
d679 4
a682 4
/*80*/	{ "",	   TRUE,  BYTE,  op2(I, E),   db_Grp1 },
/*81*/	{ "",	   TRUE,  LONG,  op2(I, E),   db_Grp1 },
/*82*/	{ "",	   TRUE,  BYTE,  op2(I, E),   db_Grp1 },
/*83*/	{ "",	   TRUE,  LONG,  op2(Ibs,E),  db_Grp1 },
d751 2
a752 2
/*c0*/	{ "",	   TRUE,  BYTE,  op2(Ib, E),  db_Grp2 },
/*c1*/	{ "",	   TRUE,  LONG,  op2(Ib, E),  db_Grp2 },
d769 4
a772 4
/*d0*/	{ "",	   TRUE,  BYTE,  op2(o1, E),  db_Grp2 },
/*d1*/	{ "",	   TRUE,  LONG,  op2(o1, E),  db_Grp2 },
/*d2*/	{ "",	   TRUE,  BYTE,  op2(CL, E),  db_Grp2 },
/*d3*/	{ "",	   TRUE,  LONG,  op2(CL, E),  db_Grp2 },
d778 1
d821 2
a822 2
/*fe*/	{ "",	   TRUE,  NONE,  0,	     db_Grp4 },
/*ff*/	{ "",	   TRUE,  NONE,  0,	     db_Grp5 },
d1223 2
a1224 6
	if (ip->i_extra == db_Grp1 || ip->i_extra == db_Grp2 ||
	    ip->i_extra == db_Grp6 || ip->i_extra == db_Grp7 ||
	    ip->i_extra == db_Grp8 || ip->i_extra == db_Grp9 ||
	    ip->i_extra == db_GrpA || ip->i_extra == db_GrpB) {
		i_name = ((char **)ip->i_extra)[f_reg(regmodrm, 0)];
	} else if (ip->i_extra == db_Grp3) {
d1229 4
a1232 1
	} else if (ip->i_extra == db_Grp4 || ip->i_extra == db_Grp5) {
d1237 20
a1256 1
		i_size = ip->i_size;
@


1.10
log
@Format string fixes
- cast void * before using as %s
- imm2 is int
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.9 2008/10/06 20:42:02 chl Exp $	*/
d1003 1
a1003 1
		db_printf(fp->f_name);
@


1.9
log
@remove dead stores and newly created unused variables.

Found by LLVM/Clang Static Analyzer.

ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.8 2007/11/05 19:23:24 miod Exp $	*/
d1225 1
a1225 1
			db_printf("%s", ip->i_extra);
d1401 1
a1401 1
			db_printf("$0x%#lx", imm2);
@


1.8
log
@temporary ddb buffers need to be a bit larger on 64 bit systems to cope with
some radix configurations.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.7 2007/09/01 11:54:02 miod Exp $	*/
a1091 1
	int	rep_grp;
a1101 1
	rep_grp = 0;
@


1.7
log
@Use db_format() instead of ddb-specific format specifiers; no functional
change inteded.
ok ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.6 2007/01/15 23:19:05 jsg Exp $	*/
d1096 1
a1096 1
	char	tmpfmt[24];
@


1.6
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.5 2004/06/26 20:29:36 andreas Exp $	*/
d1096 1
d1328 2
a1329 1
			db_printf("$%#n", (int)imm);
d1334 2
a1335 1
			db_printf("$%#r", (int)imm);
d1339 2
a1340 1
			db_printf("$%#n", (int)imm);
d1345 2
a1346 1
				db_printf("$%#n", (int)imm);
d1352 2
a1353 1
			db_printf("$%#r", (int)imm);
d1357 2
a1358 1
			db_printf("$%#n", (int)imm);
d1362 4
a1365 2
			db_printf("$%#r %#r", (int)((imm >> 32) & 0xffffffff),
			    (int)(imm & 0xffffffff));
d1373 2
a1374 1
				db_printf("%s:%#r",seg, displ);
@


1.5
log
@pop is quad in 64-bit mode
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.4 2004/06/24 22:29:31 andreas Exp $	*/
d885 2
a886 6
db_read_address(loc, short_addr, regmodrm, rex, addrp)
	db_addr_t	loc;
	int		short_addr;
	int		regmodrm;
	int		rex;
	struct i_addr	*addrp;		/* out */
d936 1
a936 4
db_print_address(seg, size, addrp)
	char *		seg;
	int		size;
	struct i_addr	*addrp;
d961 1
a961 6
db_disasm_3dnow(loc, short_addr, size, rex, seg)
	db_addr_t	loc;
	int		short_addr;
	int		size;
	int		rex;
	char *		seg;
d981 2
a982 7
db_disasm_esc(loc, inst, short_addr, size, rex, seg)
	db_addr_t	loc;
	int		inst;
	int		short_addr;
	int		size;
	int		rex;
	char *		seg;
d1073 1
a1073 3
db_disasm(loc, altfmt)
	db_addr_t	loc;
	boolean_t	altfmt;
@


1.4
log
@A little better but still work in progress.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.2 2004/02/28 22:22:35 deraadt Exp $	*/
d249 1
a249 1
/*a1*/	{ "pop",   FALSE, NONE,  op1(Si),     0 },
d258 1
a258 1
/*a9*/	{ "pop",   FALSE, NONE,  op1(Si),     0 },
d615 8
a622 8
/*58*/	{ "pop",   FALSE, LONG,  op1(Ri),    0 },
/*59*/	{ "pop",   FALSE, LONG,  op1(Ri),    0 },
/*5a*/	{ "pop",   FALSE, LONG,  op1(Ri),    0 },
/*5b*/	{ "pop",   FALSE, LONG,  op1(Ri),    0 },
/*5c*/	{ "pop",   FALSE, LONG,  op1(Ri),    0 },
/*5d*/	{ "pop",   FALSE, LONG,  op1(Ri),    0 },
/*5e*/	{ "pop",   FALSE, LONG,  op1(Ri),    0 },
/*5f*/	{ "pop",   FALSE, LONG,  op1(Ri),    0 },
d691 2
a692 2
/*9c*/	{ "pushf", FALSE, LONG,  0,	      0 },
/*9d*/	{ "popf",  FALSE, LONG,  0,	      0 },
d1412 1
a1412 1
			db_printf("$%#n,%#n", imm2, (int)imm);
@


1.3
log
@Work in progress, early check-in requested by niklas@@
@
text
@d248 1
a248 1
/*a0*/	{ "push",  FALSE, NONE,  op1(Si),     0 },
d257 1
a257 1
/*a8*/	{ "push",  FALSE, NONE,  op1(Si),     0 },
d507 1
a507 1
	{ "call",  TRUE, NONE, op1(Eind),0 },
d511 1
a511 1
	{ "push",  TRUE, LONG, op1(E),   0 },
d606 8
a613 8
/*50*/	{ "push",  FALSE, LONG,  op1(Ri),    0 },
/*51*/	{ "push",  FALSE, LONG,  op1(Ri),    0 },
/*52*/	{ "push",  FALSE, LONG,  op1(Ri),    0 },
/*53*/	{ "push",  FALSE, LONG,  op1(Ri),    0 },
/*54*/	{ "push",  FALSE, LONG,  op1(Ri),    0 },
/*55*/	{ "push",  FALSE, LONG,  op1(Ri),    0 },
/*56*/	{ "push",  FALSE, LONG,  op1(Ri),    0 },
/*57*/	{ "push",  FALSE, LONG,  op1(Ri),    0 },
d633 1
a633 1
/*68*/	{ "push",  FALSE, LONG,  op1(I),     0 },
d635 1
a635 1
/*6a*/	{ "push",  FALSE, LONG,  op1(Ibs),   0 },
d777 1
a777 1
/*e8*/	{ "call",  FALSE, NONE,  op1(Dl),     0 },
d928 1
a928 1
		addrp->base = db_reg[LONG][rm];
d933 1
a933 1
		addrp->base = db_reg[LONG][rm];
d1260 1
a1260 1
				db_printf("x");
d1265 3
d1346 1
a1346 1
			db_printf("$%#n", imm);
d1351 1
a1351 1
			db_printf("$%#r", imm);
d1355 1
a1355 1
			db_printf("$%#n", imm);
d1360 1
a1360 1
				db_printf("$%#n", imm);
d1366 1
a1366 1
			db_printf("$%#r", imm);
d1370 1
a1370 1
			db_printf("$%#n", imm);
d1374 2
a1375 1
			db_printf("$%#r", imm);
d1412 1
a1412 1
			db_printf("$%#n,%#n", imm2, imm);
d1426 9
@


1.2
log
@copy from i386, no changes yet
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.10 2004/02/01 19:13:44 deraadt Exp $	*/
d83 1
a93 1
#define	El	35			/* address, long size */
d522 2
a523 2
/*06*/	{ "push",  FALSE, NONE,  op1(Si),    0 },
/*07*/	{ "pop",   FALSE, NONE,  op1(Si),    0 },
d531 1
a531 1
/*0e*/	{ "push",  FALSE, NONE,  op1(Si),    0 },
d540 2
a541 2
/*16*/	{ "push",  FALSE, NONE,  op1(Si),    0 },
/*17*/	{ "pop",   FALSE, NONE,  op1(Si),    0 },
d549 2
a550 2
/*1e*/	{ "push",  FALSE, NONE,  op1(Si),    0 },
/*1f*/	{ "pop",   FALSE, NONE,  op1(Si),    0 },
d559 1
a559 1
/*27*/	{ "aaa",   FALSE, NONE,  0,	     0 },
d568 1
a568 1
/*2f*/	{ "das",   FALSE, NONE,  0,	     0 },
d577 1
a577 1
/*37*/	{ "daa",   FALSE, NONE,  0,	     0 },
d586 1
a586 1
/*3f*/	{ "aas",   FALSE, NONE,  0,	     0 },
d588 17
a604 17
/*40*/	{ "inc",   FALSE, LONG,  op1(Ri),    0 },
/*41*/	{ "inc",   FALSE, LONG,  op1(Ri),    0 },
/*42*/	{ "inc",   FALSE, LONG,  op1(Ri),    0 },
/*43*/	{ "inc",   FALSE, LONG,  op1(Ri),    0 },
/*44*/	{ "inc",   FALSE, LONG,  op1(Ri),    0 },
/*45*/	{ "inc",   FALSE, LONG,  op1(Ri),    0 },
/*46*/	{ "inc",   FALSE, LONG,  op1(Ri),    0 },
/*47*/	{ "inc",   FALSE, LONG,  op1(Ri),    0 },

/*48*/	{ "dec",   FALSE, LONG,  op1(Ri),    0 },
/*49*/	{ "dec",   FALSE, LONG,  op1(Ri),    0 },
/*4a*/	{ "dec",   FALSE, LONG,  op1(Ri),    0 },
/*4b*/	{ "dec",   FALSE, LONG,  op1(Ri),    0 },
/*4c*/	{ "dec",   FALSE, LONG,  op1(Ri),    0 },
/*4d*/	{ "dec",   FALSE, LONG,  op1(Ri),    0 },
/*4e*/	{ "dec",   FALSE, LONG,  op1(Ri),    0 },
/*4f*/	{ "dec",   FALSE, LONG,  op1(Ri),    0 },
d624 4
a627 4
/*60*/	{ "pusha", FALSE, LONG,  0,	     0 },
/*61*/	{ "popa",  FALSE, LONG,  0,	     0 },
/*62*/	{ "bound", TRUE,  LONG,  op2(E, R),  0 },
/*63*/	{ "arpl",  TRUE,  NONE,  op2(Rw,Ew), 0 },
d676 1
a676 1
/*8f*/	{ "pop",   TRUE,  LONG,  op1(E),      0 },
d687 3
a689 3
/*98*/	{ "cbw",   FALSE, SDEP,  0,	      "cwde" },	/* cbw/cwde */
/*99*/	{ "cwd",   FALSE, SDEP,  0,	      "cdq"  },	/* cwd/cdq */
/*9a*/	{ "lcall", FALSE, NONE,  op1(OS),     0 },
d736 2
a737 2
/*c4*/	{ "les",   TRUE,  LONG,  op2(E, R),   0 },
/*c5*/	{ "lds",   TRUE,  LONG,  op2(E, R),   0 },
d741 1
a741 1
/*c8*/	{ "enter", FALSE, NONE,  op2(Iw, Ib), 0 },
d747 1
a747 1
/*ce*/	{ "into",  FALSE, NONE,  0,	      0 },
d754 2
a755 2
/*d4*/	{ "aam",   TRUE,  NONE,  op1(Iba),    0 },
/*d5*/	{ "aad",   TRUE,  NONE,  op1(Iba),    0 },
d771 1
a771 1
/*e3*/	{ "jcxz",  FALSE, SDEP,  op1(Db),     "jecxz" },
d779 1
a779 1
/*ea*/	{ "ljmp",  FALSE, NONE,  op1(OS),     0 },
d809 12
a820 7
#define	f_mod(byte)	((byte)>>6)
#define	f_reg(byte)	(((byte)>>3)&0x7)
#define	f_rm(byte)	((byte)&0x7)

#define	sib_ss(byte)	((byte)>>6)
#define	sib_index(byte)	(((byte)>>3)&0x7)
#define	sib_base(byte)	((byte)&0x7)
d841 9
a849 4
char *	db_reg[3][8] = {
	{ "%al",  "%cl",  "%dl",  "%bl",  "%ah",  "%ch",  "%dh",  "%bh" },
	{ "%ax",  "%cx",  "%dx",  "%bx",  "%sp",  "%bp",  "%si",  "%di" },
	{ "%eax", "%ecx", "%edx", "%ebx", "%esp", "%ebp", "%esi", "%edi" }
d876 1
a876 1
db_addr_t db_read_address(db_addr_t, int, int, struct i_addr *);
d878 2
a879 1
db_addr_t db_disasm_esc(db_addr_t, int, int, int, char *);
d885 1
a885 1
db_read_address(loc, short_addr, regmodrm, addrp)
d889 1
d892 1
a892 1
	int		mod, rm, sib, index, disp;
d894 1
d896 1
a896 1
	rm  = f_rm(regmodrm);
d906 8
a913 35
	if (short_addr) {
		addrp->index = 0;
		addrp->ss = 0;
		switch (mod) {
		    case 0:
			if (rm == 6) {
				get_value_inc(disp, loc, 2, FALSE);
				addrp->disp = disp;
				addrp->base = 0;
			} else {
				addrp->disp = 0;
				addrp->base = db_index_reg_16[rm];
			}
			break;
		    case 1:
			get_value_inc(disp, loc, 1, TRUE);
			disp &= 0xffff;
			addrp->disp = disp;
			addrp->base = db_index_reg_16[rm];
			break;
		    case 2:
			get_value_inc(disp, loc, 2, FALSE);
			addrp->disp = disp;
			addrp->base = db_index_reg_16[rm];
			break;
		}
	} else {
		if (rm == 4) {
			get_value_inc(sib, loc, 1, FALSE);
			rm = sib_base(sib);
			index = sib_index(sib);
			if (index != 4)
				addrp->index = db_reg[LONG][index];
			addrp->ss = sib_ss(sib);
		}
d915 8
a922 20
		switch (mod) {
		    case 0:
			if (rm == 5) {
				get_value_inc(addrp->disp, loc, 4, FALSE);
				addrp->base = 0;
			} else {
				addrp->disp = 0;
				addrp->base = db_reg[LONG][rm];
			}
			break;
		    case 1:
			get_value_inc(disp, loc, 1, TRUE);
			addrp->disp = disp;
			addrp->base = db_reg[LONG][rm];
			break;
		    case 2:
			get_value_inc(disp, loc, 4, FALSE);
			addrp->disp = disp;
			addrp->base = db_reg[LONG][rm];
			break;
d924 11
d965 24
d993 1
a993 1
db_disasm_esc(loc, inst, short_addr, size, seg)
d998 1
d1008 1
a1008 1
	fp = &db_Esc_inst[inst - 0xd8][f_reg(regmodrm)];
d1019 1
a1019 1
		loc = db_read_address(loc, short_addr, regmodrm, &address);
d1021 2
a1022 2
		switch(fp->f_size) {
		    case SNGL:
d1025 1
a1025 1
		    case DBLR:
d1028 1
a1028 1
		    case EXTR:
d1031 1
a1031 1
		    case WORD:
d1034 1
a1034 1
		    case LONG:
d1037 1
a1037 1
		    case QUAD:
d1040 1
a1040 1
		    default:
d1050 1
a1050 1
		    case op2(ST,STI):
d1052 1
a1052 1
			db_printf("%s\t%%st,%%st(%d)",name,f_rm(regmodrm));
d1054 1
a1054 1
		    case op2(STI,ST):
d1056 1
a1056 1
			db_printf("%s\t%%st(%d),%%st",name, f_rm(regmodrm));
d1058 1
a1058 1
		    case op1(STI):
d1060 1
a1060 1
			db_printf("%s\t%%st(%d)",name, f_rm(regmodrm));
d1062 2
a1063 2
		    case op1(X):
			name = ((char * const *)fp->f_rrname)[f_rm(regmodrm)];
d1068 2
a1069 2
		    case op1(XA):
			name = ((char * const *)fp->f_rrname)[f_rm(regmodrm)];
d1074 2
a1075 2
		    default:
		    bad:
d1106 1
a1106 1
	int	imm;
d1109 4
d1114 1
d1120 4
d1131 1
a1131 1
		    case 0x66:		/* data16 */
d1134 1
a1134 1
		    case 0x67:
d1137 15
a1151 11
		    case 0x26:
			seg = "%es";
			break;
		    case 0x36:
			seg = "%ss";
			break;
		    case 0x2e:
			seg = "%cs";
			break;
		    case 0x3e:
			seg = "%ds";
d1153 2
a1154 1
		    case 0x64:
d1157 2
a1158 1
		    case 0x65:
d1161 1
a1161 1
		    case 0xf0:
d1164 2
a1165 2
		    case 0xf2:
			db_printf("repne ");
d1167 2
a1168 2
		    case 0xf3:
			db_printf("repe ");	/* XXX repe VS rep */
d1170 1
a1170 1
		    default:
d1177 16
d1195 2
a1196 3
		loc = db_disasm_esc(loc, inst, short_addr, size, seg);
		db_printf("\n");
		return (loc);
d1201 4
d1216 1
a1216 1
		loc = db_read_address(loc, short_addr, regmodrm, &address);
d1227 1
a1227 1
		i_name = ((char **)ip->i_extra)[f_reg(regmodrm)];
d1230 1
a1230 1
		ip = &ip[f_reg(regmodrm)];
d1235 1
a1235 1
		ip = &ip[f_reg(regmodrm)];
d1244 1
a1244 1
		else
d1246 7
d1259 3
d1273 1
a1273 3
	for (first = TRUE;
	     i_mode != 0;
	     i_mode >>= 8, first = FALSE) {
d1278 1
a1278 1
		    case E:
d1281 1
a1281 1
		    case Eind:
d1285 1
a1285 4
		    case El:
			db_print_address(seg, LONG, &address);
			break;
		    case Ew:
d1288 1
a1288 1
		    case Eb:
d1291 2
a1292 2
		    case R:
			db_printf("%s", db_reg[size][f_reg(regmodrm)]);
d1294 2
a1295 2
		    case Rw:
			db_printf("%s", db_reg[WORD][f_reg(regmodrm)]);
d1297 2
a1298 2
		    case Ri:
			db_printf("%s", db_reg[size][f_rm(inst)]);
d1300 2
a1301 2
		    case Ril:
			db_printf("%s", db_reg[LONG][f_rm(inst)]);
d1303 2
a1304 2
		    case S:
			db_printf("%s", db_seg_reg[f_reg(regmodrm)]);
d1306 2
a1307 2
		    case Si:
			db_printf("%s", db_seg_reg[f_reg(inst)]);
d1309 1
a1309 1
		    case A:
d1312 1
a1312 1
		    case BX:
d1315 1
a1315 1
			db_printf("(%s)", short_addr ? "%bx" : "%ebx");
d1317 1
a1317 1
		    case CL:
d1320 1
a1320 1
		    case DX:
d1323 1
a1323 1
		    case SI:
d1326 1
a1326 1
			db_printf("(%s)", short_addr ? "%si" : "%esi");
d1328 2
a1329 2
		    case DI:
			db_printf("%%es:(%s)", short_addr ? "%di" : "%edi");
d1331 2
a1332 2
		    case CR:
			db_printf("%%cr%d", f_reg(regmodrm));
d1334 2
a1335 2
		    case DR:
			db_printf("%%dr%d", f_reg(regmodrm));
d1337 2
a1338 2
		    case TR:
			db_printf("%%tr%d", f_reg(regmodrm));
d1340 1
a1340 1
		    case I:
d1345 1
a1345 1
		    case Is:
d1350 1
a1350 1
		    case Ib:
d1354 1
a1354 1
		    case Iba:
d1359 1
a1359 1
		    case Ibs:
d1365 1
a1365 1
		    case Iw:
d1369 5
a1373 1
		    case O:
d1384 1
a1384 1
		    case Db:
d1391 1
a1391 1
		    case Dl:
d1399 1
a1399 1
		    case o1:
d1402 1
a1402 1
		    case o3:
d1405 1
a1405 1
		    case OS:
d1419 3
@


1.1
log
@an amd64 arch support.
hacked by art@@ from netbsd sources and then later debugged
by me into the shape where it can host itself.
no bootloader yet as needs redoing from the
recent advanced i386 sources (anyone? ;)
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: db_disasm.c,v 1.1 2003/04/26 18:39:27 fvdl Exp $	*/
d26 2
a27 2
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
d29 1
a29 1
 *	Id: db_disasm.c,v 2.3 91/02/05 17:11:03 mrt (CMU)
a34 1

d45 1030
d1084 284
a1367 1
	return loc;
@


1.1.2.1
log
@Merge with the trunk
@
text
@d2 1
a2 1
/*	$NetBSD: db_disasm.c,v 1.11 1996/05/03 19:41:58 christos Exp $	*/
d26 2
a27 2
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
d29 1
a29 1
 *	Id: db_disasm.c,v 2.6  92/01/03  20:05:00  dbg (CMU)
d35 1
a45 1030
 * Size attributes
 */
#define	BYTE	0
#define	WORD	1
#define	LONG	2
#define	QUAD	3
#define	SNGL	4
#define	DBLR	5
#define	EXTR	6
#define	SDEP	7
#define	NONE	8

/*
 * Addressing modes
 */
#define	E	1			/* general effective address */
#define	Eind	2			/* indirect address (jump, call) */
#define	Ew	3			/* address, word size */
#define	Eb	4			/* address, byte size */
#define	R	5			/* register, in 'reg' field */
#define	Rw	6			/* word register, in 'reg' field */
#define	Ri	7			/* register in instruction */
#define	S	8			/* segment reg, in 'reg' field */
#define	Si	9			/* segment reg, in instruction */
#define	A	10			/* accumulator */
#define	BX	11			/* (bx) */
#define	CL	12			/* cl, for shifts */
#define	DX	13			/* dx, for IO */
#define	SI	14			/* si */
#define	DI	15			/* di */
#define	CR	16			/* control register */
#define	DR	17			/* debug register */
#define	TR	18			/* test register */
#define	I	19			/* immediate, unsigned */
#define	Is	20			/* immediate, signed */
#define	Ib	21			/* byte immediate, unsigned */
#define	Ibs	22			/* byte immediate, signed */
#define	Iw	23			/* word immediate, unsigned */
#define	O	25			/* direct address */
#define	Db	26			/* byte displacement from EIP */
#define	Dl	27			/* long displacement from EIP */
#define	o1	28			/* constant 1 */
#define	o3	29			/* constant 3 */
#define	OS	30			/* immediate offset/segment */
#define	ST	31			/* FP stack top */
#define	STI	32			/* FP stack */
#define	X	33			/* extended FP op */
#define	XA	34			/* for 'fstcw %ax' */
#define	El	35			/* address, long size */
#define	Ril	36			/* long register in instruction */
#define	Iba	37			/* byte immediate, don't print if 0xa */

struct inst {
	char *	i_name;			/* name */
	short	i_has_modrm;		/* has regmodrm byte */
	short	i_size;			/* operand size */
	int	i_mode;			/* addressing modes */
	void *	i_extra;		/* pointer to extra opcode table */
};

#define	op1(x)		(x)
#define	op2(x,y)	((x)|((y)<<8))
#define	op3(x,y,z)	((x)|((y)<<8)|((z)<<16))

struct finst {
	char *	f_name;			/* name for memory instruction */
	int	f_size;			/* size for memory instruction */
	int	f_rrmode;		/* mode for rr instruction */
	void *	f_rrname;		/* name for rr instruction
					   (or pointer to table) */
};

char *	db_Grp6[] = {
	"sldt",		"str",		"lldt",		"ltr",
	"verr",		"verw",		"",		""
};

char *	db_Grp7[] = {
	"sgdt",		"sidt",		"lgdt",		"lidt",
	"smsw",		"",		"lmsw",		"invlpg"
};

char *	db_Grp8[] = {
	"",		"",		"",		"",
	"bt",		"bts",		"btr",		"btc"
};

char *	db_Grp9[] = {
	"fxsave",	"fxrstor",	"",		"",
	"",		"",		"",		""
};

char *	db_GrpA[] = {
	"",		"cmpxchg8b",	"",		"",
	"",		"",		"",		""
};

char *	db_GrpB[] = {
	"xstore-rng",	"xcrypt-ecb",	"xcrypt-cbc",	"",
	"xcrypt-cfb",	"xcrypt-ofb",	"",		""
};

struct inst db_inst_0f0x[] = {
/*00*/	{ "",	   TRUE,  NONE,  op1(Ew),     db_Grp6 },
/*01*/	{ "",	   TRUE,  NONE,  op1(Ew),     db_Grp7 },
/*02*/	{ "lar",   TRUE,  LONG,  op2(E,R),    0 },
/*03*/	{ "lsl",   TRUE,  LONG,  op2(E,R),    0 },
/*04*/	{ "",      FALSE, NONE,  0,	      0 },
/*05*/	{ "",      FALSE, NONE,  0,	      0 },
/*06*/	{ "clts",  FALSE, NONE,  0,	      0 },
/*07*/	{ "",      FALSE, NONE,  0,	      0 },

/*08*/	{ "invd",  FALSE, NONE,  0,	      0 },
/*09*/	{ "wbinvd",FALSE, NONE,  0,	      0 },
/*0a*/	{ "",      FALSE, NONE,  0,	      0 },
/*0b*/	{ "",      FALSE, NONE,  0,	      0 },
/*0c*/	{ "",      FALSE, NONE,  0,	      0 },
/*0d*/	{ "",      FALSE, NONE,  0,	      0 },
/*0e*/	{ "",      FALSE, NONE,  0,	      0 },
/*0f*/	{ "",      FALSE, NONE,  0,	      0 },
};

struct inst	db_inst_0f2x[] = {
/*20*/	{ "mov",   TRUE,  LONG,  op2(CR,E),   0 }, /* use E for reg */
/*21*/	{ "mov",   TRUE,  LONG,  op2(DR,E),   0 }, /* since mod == 11 */
/*22*/	{ "mov",   TRUE,  LONG,  op2(E,CR),   0 },
/*23*/	{ "mov",   TRUE,  LONG,  op2(E,DR),   0 },
/*24*/	{ "mov",   TRUE,  LONG,  op2(TR,E),   0 },
/*25*/	{ "",      FALSE, NONE,  0,	      0 },
/*26*/	{ "mov",   TRUE,  LONG,  op2(E,TR),   0 },
/*27*/	{ "",      FALSE, NONE,  0,	      0 },

/*28*/	{ "",      FALSE, NONE,  0,	      0 },
/*29*/	{ "",      FALSE, NONE,  0,	      0 },
/*2a*/	{ "",      FALSE, NONE,  0,	      0 },
/*2b*/	{ "",      FALSE, NONE,  0,	      0 },
/*2c*/	{ "",      FALSE, NONE,  0,	      0 },
/*2d*/	{ "",      FALSE, NONE,  0,	      0 },
/*2e*/	{ "",      FALSE, NONE,  0,	      0 },
/*2f*/	{ "",      FALSE, NONE,  0,	      0 },
};

struct inst	db_inst_0f3x[] = {
/*30*/	{ "wrmsr", FALSE, NONE,  0,           0 },
/*31*/	{ "rdtsc", FALSE, NONE,  0,           0 },
/*32*/	{ "rdmsr", FALSE, NONE,  0,           0 },
/*33*/	{ "rdpmc", FALSE, NONE,  0,           0 },
/*34*/	{ "",      FALSE, NONE,  0,           0 },
/*35*/	{ "",      FALSE, NONE,  0,           0 },
/*36*/	{ "",      FALSE, NONE,  0,           0 },
/*37*/	{ "",      FALSE, NONE,  0,           0 },

/*38*/	{ "",      FALSE, NONE,  0,           0 },
/*39*/	{ "",      FALSE, NONE,  0,           0 },
/*3a*/	{ "",      FALSE, NONE,  0,           0 },
/*3b*/	{ "",      FALSE, NONE,  0,           0 },
/*3c*/	{ "",      FALSE, NONE,  0,           0 },
/*3d*/	{ "",      FALSE, NONE,  0,           0 },
/*3e*/	{ "",      FALSE, NONE,  0,           0 },
/*3f*/	{ "",      FALSE, NONE,  0,           0 },
};

struct inst	db_inst_0f8x[] = {
/*80*/	{ "jo",    FALSE, NONE,  op1(Dl),     0 },
/*81*/	{ "jno",   FALSE, NONE,  op1(Dl),     0 },
/*82*/	{ "jb",    FALSE, NONE,  op1(Dl),     0 },
/*83*/	{ "jnb",   FALSE, NONE,  op1(Dl),     0 },
/*84*/	{ "jz",    FALSE, NONE,  op1(Dl),     0 },
/*85*/	{ "jnz",   FALSE, NONE,  op1(Dl),     0 },
/*86*/	{ "jbe",   FALSE, NONE,  op1(Dl),     0 },
/*87*/	{ "jnbe",  FALSE, NONE,  op1(Dl),     0 },

/*88*/	{ "js",    FALSE, NONE,  op1(Dl),     0 },
/*89*/	{ "jns",   FALSE, NONE,  op1(Dl),     0 },
/*8a*/	{ "jp",    FALSE, NONE,  op1(Dl),     0 },
/*8b*/	{ "jnp",   FALSE, NONE,  op1(Dl),     0 },
/*8c*/	{ "jl",    FALSE, NONE,  op1(Dl),     0 },
/*8d*/	{ "jnl",   FALSE, NONE,  op1(Dl),     0 },
/*8e*/	{ "jle",   FALSE, NONE,  op1(Dl),     0 },
/*8f*/	{ "jnle",  FALSE, NONE,  op1(Dl),     0 },
};

struct inst	db_inst_0f9x[] = {
/*90*/	{ "seto",  TRUE,  NONE,  op1(Eb),     0 },
/*91*/	{ "setno", TRUE,  NONE,  op1(Eb),     0 },
/*92*/	{ "setb",  TRUE,  NONE,  op1(Eb),     0 },
/*93*/	{ "setnb", TRUE,  NONE,  op1(Eb),     0 },
/*94*/	{ "setz",  TRUE,  NONE,  op1(Eb),     0 },
/*95*/	{ "setnz", TRUE,  NONE,  op1(Eb),     0 },
/*96*/	{ "setbe", TRUE,  NONE,  op1(Eb),     0 },
/*97*/	{ "setnbe",TRUE,  NONE,  op1(Eb),     0 },

/*98*/	{ "sets",  TRUE,  NONE,  op1(Eb),     0 },
/*99*/	{ "setns", TRUE,  NONE,  op1(Eb),     0 },
/*9a*/	{ "setp",  TRUE,  NONE,  op1(Eb),     0 },
/*9b*/	{ "setnp", TRUE,  NONE,  op1(Eb),     0 },
/*9c*/	{ "setl",  TRUE,  NONE,  op1(Eb),     0 },
/*9d*/	{ "setnl", TRUE,  NONE,  op1(Eb),     0 },
/*9e*/	{ "setle", TRUE,  NONE,  op1(Eb),     0 },
/*9f*/	{ "setnle",TRUE,  NONE,  op1(Eb),     0 },
};

struct inst	db_inst_0fax[] = {
/*a0*/	{ "push",  FALSE, NONE,  op1(Si),     0 },
/*a1*/	{ "pop",   FALSE, NONE,  op1(Si),     0 },
/*a2*/	{ "cpuid", FALSE, NONE,  0,	      0 },
/*a3*/	{ "bt",    TRUE,  LONG,  op2(R,E),    0 },
/*a4*/	{ "shld",  TRUE,  LONG,  op3(Ib,R,E), 0 },
/*a5*/	{ "shld",  TRUE,  LONG,  op3(CL,R,E), 0 },
/*a6*/	{ "",      FALSE, NONE,  0,	      0 },
/*a7*/	{ "",      TRUE,  NONE,  0,	      db_GrpB },

/*a8*/	{ "push",  FALSE, NONE,  op1(Si),     0 },
/*a9*/	{ "pop",   FALSE, NONE,  op1(Si),     0 },
/*aa*/	{ "",      FALSE, NONE,  0,	      0 },
/*ab*/	{ "bts",   TRUE,  LONG,  op2(R,E),    0 },
/*ac*/	{ "shrd",  TRUE,  LONG,  op3(Ib,E,R), 0 },
/*ad*/	{ "shrd",  TRUE,  LONG,  op3(CL,E,R), 0 },
/*ae*/	{ "",      TRUE,  NONE,  op1(E),      db_Grp9 },
/*af*/	{ "imul",  TRUE,  LONG,  op2(E,R),    0 },
};

struct inst	db_inst_0fbx[] = {
/*b0*/	{ "cmpxchg",TRUE, BYTE,	 op2(R, E),   0 },
/*b1*/	{ "cmpxchg",TRUE, LONG,	 op2(R, E),   0 },
/*b2*/	{ "lss",   TRUE,  LONG,  op2(E, R),   0 },
/*b3*/	{ "btr",   TRUE,  LONG,  op2(R, E),   0 },
/*b4*/	{ "lfs",   TRUE,  LONG,  op2(E, R),   0 },
/*b5*/	{ "lgs",   TRUE,  LONG,  op2(E, R),   0 },
/*b6*/	{ "movzb", TRUE,  LONG,  op2(Eb, R),  0 },
/*b7*/	{ "movzw", TRUE,  LONG,  op2(Ew, R),  0 },

/*b8*/	{ "",      FALSE, NONE,  0,	      0 },
/*b9*/	{ "",      FALSE, NONE,  0,	      0 },
/*ba*/	{ "",      TRUE,  LONG,  op2(Ib, E),  db_Grp8 },
/*bb*/	{ "btc",   TRUE,  LONG,  op2(R, E),   0 },
/*bc*/	{ "bsf",   TRUE,  LONG,  op2(E, R),   0 },
/*bd*/	{ "bsr",   TRUE,  LONG,  op2(E, R),   0 },
/*be*/	{ "movsb", TRUE,  LONG,  op2(Eb, R),  0 },
/*bf*/	{ "movsw", TRUE,  LONG,  op2(Ew, R),  0 },
};

struct inst	db_inst_0fcx[] = {
/*c0*/	{ "xadd",  TRUE,  BYTE,	 op2(R, E),   0 },
/*c1*/	{ "xadd",  TRUE,  LONG,	 op2(R, E),   0 },
/*c2*/	{ "",	   FALSE, NONE,	 0,	      0 },
/*c3*/	{ "",	   FALSE, NONE,	 0,	      0 },
/*c4*/	{ "",	   FALSE, NONE,	 0,	      0 },
/*c5*/	{ "",	   FALSE, NONE,	 0,	      0 },
/*c6*/	{ "",	   FALSE, NONE,	 0,	      0 },
/*c7*/	{ "",      TRUE,  NONE,  op1(E),      db_GrpA },

/*c8*/	{ "bswap", FALSE, LONG,  op1(Ril),    0 },
/*c9*/	{ "bswap", FALSE, LONG,  op1(Ril),    0 },
/*ca*/	{ "bswap", FALSE, LONG,  op1(Ril),    0 },
/*cb*/	{ "bswap", FALSE, LONG,  op1(Ril),    0 },
/*cc*/	{ "bswap", FALSE, LONG,  op1(Ril),    0 },
/*cd*/	{ "bswap", FALSE, LONG,  op1(Ril),    0 },
/*ce*/	{ "bswap", FALSE, LONG,  op1(Ril),    0 },
/*cf*/	{ "bswap", FALSE, LONG,  op1(Ril),    0 },
};

struct inst *db_inst_0f[] = {
	db_inst_0f0x,
	NULL,
	db_inst_0f2x,
	db_inst_0f3x,
	NULL,
	NULL,
	NULL,
	NULL,
	db_inst_0f8x,
	db_inst_0f9x,
	db_inst_0fax,
	db_inst_0fbx,
	db_inst_0fcx,
	NULL,
	NULL,
	NULL
};

char *	db_Esc92[] = {
	"fnop",		"",		"",		"",
	"",		"",		"",		""
};
char *	db_Esc94[] = {
	"fchs",		"fabs",		"",		"",
	"ftst",		"fxam",		"",		""
};
char *	db_Esc95[] = {
	"fld1",		"fldl2t",	"fldl2e",	"fldpi",
	"fldlg2",	"fldln2",	"fldz",		""
};
char *	db_Esc96[] = {
	"f2xm1",	"fyl2x",	"fptan",	"fpatan",
	"fxtract",	"fprem1",	"fdecstp",	"fincstp"
};
char *	db_Esc97[] = {
	"fprem",	"fyl2xp1",	"fsqrt",	"fsincos",
	"frndint",	"fscale",	"fsin",		"fcos"
};

char *	db_Esca5[] = {
	"",		"fucompp",	"",		"",
	"",		"",		"",		""
};

char *	db_Escb4[] = {
	"fneni",	"fndisi",       "fnclex",	"fninit",
	"fsetpm",	"",		"",		""
};

char *	db_Esce3[] = {
	"",		"fcompp",	"",		"",
	"",		"",		"",		""
};

char *	db_Escf4[] = {
	"fnstsw",	"",		"",		"",
	"",		"",		"",		""
};

struct finst db_Esc8[] = {
/*0*/	{ "fadd",   SNGL,  op2(STI,ST),	0 },
/*1*/	{ "fmul",   SNGL,  op2(STI,ST),	0 },
/*2*/	{ "fcom",   SNGL,  op2(STI,ST),	0 },
/*3*/	{ "fcomp",  SNGL,  op2(STI,ST),	0 },
/*4*/	{ "fsub",   SNGL,  op2(STI,ST),	0 },
/*5*/	{ "fsubr",  SNGL,  op2(STI,ST),	0 },
/*6*/	{ "fdiv",   SNGL,  op2(STI,ST),	0 },
/*7*/	{ "fdivr",  SNGL,  op2(STI,ST),	0 },
};

struct finst db_Esc9[] = {
/*0*/	{ "fld",    SNGL,  op1(STI),	0 },
/*1*/	{ "",       NONE,  op1(STI),	"fxch" },
/*2*/	{ "fst",    SNGL,  op1(X),	db_Esc92 },
/*3*/	{ "fstp",   SNGL,  op1(X),	0 },
/*4*/	{ "fldenv", NONE,  op1(X),	db_Esc94 },
/*5*/	{ "fldcw",  NONE,  op1(X),	db_Esc95 },
/*6*/	{ "fnstenv",NONE,  op1(X),	db_Esc96 },
/*7*/	{ "fnstcw", NONE,  op1(X),	db_Esc97 },
};

struct finst db_Esca[] = {
/*0*/	{ "fiadd",  LONG,  0,		0 },
/*1*/	{ "fimul",  LONG,  0,		0 },
/*2*/	{ "ficom",  LONG,  0,		0 },
/*3*/	{ "ficomp", LONG,  0,		0 },
/*4*/	{ "fisub",  LONG,  op1(X),	0 },
/*5*/	{ "fisubr", LONG,  0,		0 },
/*6*/	{ "fidiv",  LONG,  0,		0 },
/*7*/	{ "fidivr", LONG,  0,		0 }
};

struct finst db_Escb[] = {
/*0*/	{ "fild",   LONG,  0,		0 },
/*1*/	{ "",       NONE,  0,		0 },
/*2*/	{ "fist",   LONG,  0,		0 },
/*3*/	{ "fistp",  LONG,  0,		0 },
/*4*/	{ "",       WORD,  op1(X),	db_Escb4 },
/*5*/	{ "fld",    EXTR,  0,		0 },
/*6*/	{ "",       WORD,  0,		0 },
/*7*/	{ "fstp",   EXTR,  0,		0 },
};

struct finst db_Escc[] = {
/*0*/	{ "fadd",   DBLR,  op2(ST,STI),	0 },
/*1*/	{ "fmul",   DBLR,  op2(ST,STI),	0 },
/*2*/	{ "fcom",   DBLR,  0,	 	0 },
/*3*/	{ "fcomp",  DBLR,  0,		0 },
/*4*/	{ "fsub",   DBLR,  op2(ST,STI),	"fsubr" },
/*5*/	{ "fsubr",  DBLR,  op2(ST,STI),	"fsub" },
/*6*/	{ "fdiv",   DBLR,  op2(ST,STI),	"fdivr" },
/*7*/	{ "fdivr",  DBLR,  op2(ST,STI),	"fdiv" },
};

struct finst db_Escd[] = {
/*0*/	{ "fld",    DBLR,  op1(STI),	"ffree" },
/*1*/	{ "",       NONE,  0,		0 },
/*2*/	{ "fst",    DBLR,  op1(STI),	0 },
/*3*/	{ "fstp",   DBLR,  op1(STI),	0 },
/*4*/	{ "frstor", NONE,  op1(STI),	"fucom" },
/*5*/	{ "",       NONE,  op1(STI),	"fucomp" },
/*6*/	{ "fnsave", NONE,  0,		0 },
/*7*/	{ "fnstsw", NONE,  0,		0 },
};

struct finst db_Esce[] = {
/*0*/	{ "fiadd",  WORD,  op2(ST,STI),	"faddp" },
/*1*/	{ "fimul",  WORD,  op2(ST,STI),	"fmulp" },
/*2*/	{ "ficom",  WORD,  0,		0 },
/*3*/	{ "ficomp", WORD,  op1(X),	db_Esce3 },
/*4*/	{ "fisub",  WORD,  op2(ST,STI),	"fsubrp" },
/*5*/	{ "fisubr", WORD,  op2(ST,STI),	"fsubp" },
/*6*/	{ "fidiv",  WORD,  op2(ST,STI),	"fdivrp" },
/*7*/	{ "fidivr", WORD,  op2(ST,STI),	"fdivp" },
};

struct finst db_Escf[] = {
/*0*/	{ "fild",   WORD,  0,		0 },
/*1*/	{ "",       WORD,  0,		0 },
/*2*/	{ "fist",   WORD,  0,		0 },
/*3*/	{ "fistp",  WORD,  0,		0 },
/*4*/	{ "fbld",   NONE,  op1(XA),	db_Escf4 },
/*5*/	{ "fild",   QUAD,  0,		0 },
/*6*/	{ "fbstp",  NONE,  0,		0 },
/*7*/	{ "fistp",  QUAD,  0,		0 },
};

struct finst *db_Esc_inst[] = {
	db_Esc8, db_Esc9, db_Esca, db_Escb,
	db_Escc, db_Escd, db_Esce, db_Escf
};

char *	db_Grp1[] = {
	"add",
	"or",
	"adc",
	"sbb",
	"and",
	"sub",
	"xor",
	"cmp"
};

char *	db_Grp2[] = {
	"rol",
	"ror",
	"rcl",
	"rcr",
	"shl",
	"shr",
	"shl",
	"sar"
};

struct inst db_Grp3[] = {
	{ "test",  TRUE, NONE, op2(I,E), 0 },
	{ "test",  TRUE, NONE, op2(I,E), 0 },
	{ "not",   TRUE, NONE, op1(E),   0 },
	{ "neg",   TRUE, NONE, op1(E),   0 },
	{ "mul",   TRUE, NONE, op2(E,A), 0 },
	{ "imul",  TRUE, NONE, op2(E,A), 0 },
	{ "div",   TRUE, NONE, op2(E,A), 0 },
	{ "idiv",  TRUE, NONE, op2(E,A), 0 },
};

struct inst	db_Grp4[] = {
	{ "inc",   TRUE, BYTE, op1(E),   0 },
	{ "dec",   TRUE, BYTE, op1(E),   0 },
	{ "",      TRUE, NONE, 0,	 0 },
	{ "",      TRUE, NONE, 0,	 0 },
	{ "",      TRUE, NONE, 0,	 0 },
	{ "",      TRUE, NONE, 0,	 0 },
	{ "",      TRUE, NONE, 0,	 0 },
	{ "",      TRUE, NONE, 0,	 0 }
};

struct inst	db_Grp5[] = {
	{ "inc",   TRUE, LONG, op1(E),   0 },
	{ "dec",   TRUE, LONG, op1(E),   0 },
	{ "call",  TRUE, NONE, op1(Eind),0 },
	{ "lcall", TRUE, NONE, op1(Eind),0 },
	{ "jmp",   TRUE, NONE, op1(Eind),0 },
	{ "ljmp",  TRUE, NONE, op1(Eind),0 },
	{ "push",  TRUE, LONG, op1(E),   0 },
	{ "",      TRUE, NONE, 0,	 0 }
};

struct inst db_inst_table[256] = {
/*00*/	{ "add",   TRUE,  BYTE,  op2(R, E),  0 },
/*01*/	{ "add",   TRUE,  LONG,  op2(R, E),  0 },
/*02*/	{ "add",   TRUE,  BYTE,  op2(E, R),  0 },
/*03*/	{ "add",   TRUE,  LONG,  op2(E, R),  0 },
/*04*/	{ "add",   FALSE, BYTE,  op2(I, A),  0 },
/*05*/	{ "add",   FALSE, LONG,  op2(Is, A), 0 },
/*06*/	{ "push",  FALSE, NONE,  op1(Si),    0 },
/*07*/	{ "pop",   FALSE, NONE,  op1(Si),    0 },

/*08*/	{ "or",    TRUE,  BYTE,  op2(R, E),  0 },
/*09*/	{ "or",    TRUE,  LONG,  op2(R, E),  0 },
/*0a*/	{ "or",    TRUE,  BYTE,  op2(E, R),  0 },
/*0b*/	{ "or",    TRUE,  LONG,  op2(E, R),  0 },
/*0c*/	{ "or",    FALSE, BYTE,  op2(I, A),  0 },
/*0d*/	{ "or",    FALSE, LONG,  op2(I, A),  0 },
/*0e*/	{ "push",  FALSE, NONE,  op1(Si),    0 },
/*0f*/	{ "",      FALSE, NONE,  0,	     0 },

/*10*/	{ "adc",   TRUE,  BYTE,  op2(R, E),  0 },
/*11*/	{ "adc",   TRUE,  LONG,  op2(R, E),  0 },
/*12*/	{ "adc",   TRUE,  BYTE,  op2(E, R),  0 },
/*13*/	{ "adc",   TRUE,  LONG,  op2(E, R),  0 },
/*14*/	{ "adc",   FALSE, BYTE,  op2(I, A),  0 },
/*15*/	{ "adc",   FALSE, LONG,  op2(Is, A), 0 },
/*16*/	{ "push",  FALSE, NONE,  op1(Si),    0 },
/*17*/	{ "pop",   FALSE, NONE,  op1(Si),    0 },

/*18*/	{ "sbb",   TRUE,  BYTE,  op2(R, E),  0 },
/*19*/	{ "sbb",   TRUE,  LONG,  op2(R, E),  0 },
/*1a*/	{ "sbb",   TRUE,  BYTE,  op2(E, R),  0 },
/*1b*/	{ "sbb",   TRUE,  LONG,  op2(E, R),  0 },
/*1c*/	{ "sbb",   FALSE, BYTE,  op2(I, A),  0 },
/*1d*/	{ "sbb",   FALSE, LONG,  op2(Is, A), 0 },
/*1e*/	{ "push",  FALSE, NONE,  op1(Si),    0 },
/*1f*/	{ "pop",   FALSE, NONE,  op1(Si),    0 },

/*20*/	{ "and",   TRUE,  BYTE,  op2(R, E),  0 },
/*21*/	{ "and",   TRUE,  LONG,  op2(R, E),  0 },
/*22*/	{ "and",   TRUE,  BYTE,  op2(E, R),  0 },
/*23*/	{ "and",   TRUE,  LONG,  op2(E, R),  0 },
/*24*/	{ "and",   FALSE, BYTE,  op2(I, A),  0 },
/*25*/	{ "and",   FALSE, LONG,  op2(I, A),  0 },
/*26*/	{ "",      FALSE, NONE,  0,	     0 },
/*27*/	{ "aaa",   FALSE, NONE,  0,	     0 },

/*28*/	{ "sub",   TRUE,  BYTE,  op2(R, E),  0 },
/*29*/	{ "sub",   TRUE,  LONG,  op2(R, E),  0 },
/*2a*/	{ "sub",   TRUE,  BYTE,  op2(E, R),  0 },
/*2b*/	{ "sub",   TRUE,  LONG,  op2(E, R),  0 },
/*2c*/	{ "sub",   FALSE, BYTE,  op2(I, A),  0 },
/*2d*/	{ "sub",   FALSE, LONG,  op2(Is, A), 0 },
/*2e*/	{ "",      FALSE, NONE,  0,	     0 },
/*2f*/	{ "das",   FALSE, NONE,  0,	     0 },

/*30*/	{ "xor",   TRUE,  BYTE,  op2(R, E),  0 },
/*31*/	{ "xor",   TRUE,  LONG,  op2(R, E),  0 },
/*32*/	{ "xor",   TRUE,  BYTE,  op2(E, R),  0 },
/*33*/	{ "xor",   TRUE,  LONG,  op2(E, R),  0 },
/*34*/	{ "xor",   FALSE, BYTE,  op2(I, A),  0 },
/*35*/	{ "xor",   FALSE, LONG,  op2(I, A),  0 },
/*36*/	{ "",      FALSE, NONE,  0,	     0 },
/*37*/	{ "daa",   FALSE, NONE,  0,	     0 },

/*38*/	{ "cmp",   TRUE,  BYTE,  op2(R, E),  0 },
/*39*/	{ "cmp",   TRUE,  LONG,  op2(R, E),  0 },
/*3a*/	{ "cmp",   TRUE,  BYTE,  op2(E, R),  0 },
/*3b*/	{ "cmp",   TRUE,  LONG,  op2(E, R),  0 },
/*3c*/	{ "cmp",   FALSE, BYTE,  op2(I, A),  0 },
/*3d*/	{ "cmp",   FALSE, LONG,  op2(Is, A), 0 },
/*3e*/	{ "",      FALSE, NONE,  0,	     0 },
/*3f*/	{ "aas",   FALSE, NONE,  0,	     0 },

/*40*/	{ "inc",   FALSE, LONG,  op1(Ri),    0 },
/*41*/	{ "inc",   FALSE, LONG,  op1(Ri),    0 },
/*42*/	{ "inc",   FALSE, LONG,  op1(Ri),    0 },
/*43*/	{ "inc",   FALSE, LONG,  op1(Ri),    0 },
/*44*/	{ "inc",   FALSE, LONG,  op1(Ri),    0 },
/*45*/	{ "inc",   FALSE, LONG,  op1(Ri),    0 },
/*46*/	{ "inc",   FALSE, LONG,  op1(Ri),    0 },
/*47*/	{ "inc",   FALSE, LONG,  op1(Ri),    0 },

/*48*/	{ "dec",   FALSE, LONG,  op1(Ri),    0 },
/*49*/	{ "dec",   FALSE, LONG,  op1(Ri),    0 },
/*4a*/	{ "dec",   FALSE, LONG,  op1(Ri),    0 },
/*4b*/	{ "dec",   FALSE, LONG,  op1(Ri),    0 },
/*4c*/	{ "dec",   FALSE, LONG,  op1(Ri),    0 },
/*4d*/	{ "dec",   FALSE, LONG,  op1(Ri),    0 },
/*4e*/	{ "dec",   FALSE, LONG,  op1(Ri),    0 },
/*4f*/	{ "dec",   FALSE, LONG,  op1(Ri),    0 },

/*50*/	{ "push",  FALSE, LONG,  op1(Ri),    0 },
/*51*/	{ "push",  FALSE, LONG,  op1(Ri),    0 },
/*52*/	{ "push",  FALSE, LONG,  op1(Ri),    0 },
/*53*/	{ "push",  FALSE, LONG,  op1(Ri),    0 },
/*54*/	{ "push",  FALSE, LONG,  op1(Ri),    0 },
/*55*/	{ "push",  FALSE, LONG,  op1(Ri),    0 },
/*56*/	{ "push",  FALSE, LONG,  op1(Ri),    0 },
/*57*/	{ "push",  FALSE, LONG,  op1(Ri),    0 },

/*58*/	{ "pop",   FALSE, LONG,  op1(Ri),    0 },
/*59*/	{ "pop",   FALSE, LONG,  op1(Ri),    0 },
/*5a*/	{ "pop",   FALSE, LONG,  op1(Ri),    0 },
/*5b*/	{ "pop",   FALSE, LONG,  op1(Ri),    0 },
/*5c*/	{ "pop",   FALSE, LONG,  op1(Ri),    0 },
/*5d*/	{ "pop",   FALSE, LONG,  op1(Ri),    0 },
/*5e*/	{ "pop",   FALSE, LONG,  op1(Ri),    0 },
/*5f*/	{ "pop",   FALSE, LONG,  op1(Ri),    0 },

/*60*/	{ "pusha", FALSE, LONG,  0,	     0 },
/*61*/	{ "popa",  FALSE, LONG,  0,	     0 },
/*62*/	{ "bound", TRUE,  LONG,  op2(E, R),  0 },
/*63*/	{ "arpl",  TRUE,  NONE,  op2(Rw,Ew), 0 },
/*64*/	{ "",      FALSE, NONE,  0,	     0 },
/*65*/	{ "",      FALSE, NONE,  0,	     0 },
/*66*/	{ "",      FALSE, NONE,  0,	     0 },
/*67*/	{ "",      FALSE, NONE,  0,	     0 },

/*68*/	{ "push",  FALSE, LONG,  op1(I),     0 },
/*69*/	{ "imul",  TRUE,  LONG,  op3(I,E,R), 0 },
/*6a*/	{ "push",  FALSE, LONG,  op1(Ibs),   0 },
/*6b*/	{ "imul",  TRUE,  LONG,  op3(Ibs,E,R),0 },
/*6c*/	{ "ins",   FALSE, BYTE,  op2(DX, DI), 0 },
/*6d*/	{ "ins",   FALSE, LONG,  op2(DX, DI), 0 },
/*6e*/	{ "outs",  FALSE, BYTE,  op2(SI, DX), 0 },
/*6f*/	{ "outs",  FALSE, LONG,  op2(SI, DX), 0 },

/*70*/	{ "jo",    FALSE, NONE,  op1(Db),     0 },
/*71*/	{ "jno",   FALSE, NONE,  op1(Db),     0 },
/*72*/	{ "jb",    FALSE, NONE,  op1(Db),     0 },
/*73*/	{ "jnb",   FALSE, NONE,  op1(Db),     0 },
/*74*/	{ "jz",    FALSE, NONE,  op1(Db),     0 },
/*75*/	{ "jnz",   FALSE, NONE,  op1(Db),     0 },
/*76*/	{ "jbe",   FALSE, NONE,  op1(Db),     0 },
/*77*/	{ "jnbe",  FALSE, NONE,  op1(Db),     0 },

/*78*/	{ "js",    FALSE, NONE,  op1(Db),     0 },
/*79*/	{ "jns",   FALSE, NONE,  op1(Db),     0 },
/*7a*/	{ "jp",    FALSE, NONE,  op1(Db),     0 },
/*7b*/	{ "jnp",   FALSE, NONE,  op1(Db),     0 },
/*7c*/	{ "jl",    FALSE, NONE,  op1(Db),     0 },
/*7d*/	{ "jnl",   FALSE, NONE,  op1(Db),     0 },
/*7e*/	{ "jle",   FALSE, NONE,  op1(Db),     0 },
/*7f*/	{ "jnle",  FALSE, NONE,  op1(Db),     0 },

/*80*/	{ "",	   TRUE,  BYTE,  op2(I, E),   db_Grp1 },
/*81*/	{ "",	   TRUE,  LONG,  op2(I, E),   db_Grp1 },
/*82*/	{ "",	   TRUE,  BYTE,  op2(I, E),   db_Grp1 },
/*83*/	{ "",	   TRUE,  LONG,  op2(Ibs,E),  db_Grp1 },
/*84*/	{ "test",  TRUE,  BYTE,  op2(R, E),   0 },
/*85*/	{ "test",  TRUE,  LONG,  op2(R, E),   0 },
/*86*/	{ "xchg",  TRUE,  BYTE,  op2(R, E),   0 },
/*87*/	{ "xchg",  TRUE,  LONG,  op2(R, E),   0 },

/*88*/	{ "mov",   TRUE,  BYTE,  op2(R, E),   0 },
/*89*/	{ "mov",   TRUE,  LONG,  op2(R, E),   0 },
/*8a*/	{ "mov",   TRUE,  BYTE,  op2(E, R),   0 },
/*8b*/	{ "mov",   TRUE,  LONG,  op2(E, R),   0 },
/*8c*/	{ "mov",   TRUE,  NONE,  op2(S, Ew),  0 },
/*8d*/	{ "lea",   TRUE,  LONG,  op2(E, R),   0 },
/*8e*/	{ "mov",   TRUE,  NONE,  op2(Ew, S),  0 },
/*8f*/	{ "pop",   TRUE,  LONG,  op1(E),      0 },

/*90*/	{ "nop",   FALSE, NONE,  0,	      0 },
/*91*/	{ "xchg",  FALSE, LONG,  op2(A, Ri),  0 },
/*92*/	{ "xchg",  FALSE, LONG,  op2(A, Ri),  0 },
/*93*/	{ "xchg",  FALSE, LONG,  op2(A, Ri),  0 },
/*94*/	{ "xchg",  FALSE, LONG,  op2(A, Ri),  0 },
/*95*/	{ "xchg",  FALSE, LONG,  op2(A, Ri),  0 },
/*96*/	{ "xchg",  FALSE, LONG,  op2(A, Ri),  0 },
/*97*/	{ "xchg",  FALSE, LONG,  op2(A, Ri),  0 },

/*98*/	{ "cbw",   FALSE, SDEP,  0,	      "cwde" },	/* cbw/cwde */
/*99*/	{ "cwd",   FALSE, SDEP,  0,	      "cdq"  },	/* cwd/cdq */
/*9a*/	{ "lcall", FALSE, NONE,  op1(OS),     0 },
/*9b*/	{ "wait",  FALSE, NONE,  0,	      0 },
/*9c*/	{ "pushf", FALSE, LONG,  0,	      0 },
/*9d*/	{ "popf",  FALSE, LONG,  0,	      0 },
/*9e*/	{ "sahf",  FALSE, NONE,  0,	      0 },
/*9f*/	{ "lahf",  FALSE, NONE,  0,	      0 },

/*a0*/	{ "mov",   FALSE, BYTE,  op2(O, A),   0 },
/*a1*/	{ "mov",   FALSE, LONG,  op2(O, A),   0 },
/*a2*/	{ "mov",   FALSE, BYTE,  op2(A, O),   0 },
/*a3*/	{ "mov",   FALSE, LONG,  op2(A, O),   0 },
/*a4*/	{ "movs",  FALSE, BYTE,  op2(SI,DI),  0 },
/*a5*/	{ "movs",  FALSE, LONG,  op2(SI,DI),  0 },
/*a6*/	{ "cmps",  FALSE, BYTE,  op2(SI,DI),  0 },
/*a7*/	{ "cmps",  FALSE, LONG,  op2(SI,DI),  0 },

/*a8*/	{ "test",  FALSE, BYTE,  op2(I, A),   0 },
/*a9*/	{ "test",  FALSE, LONG,  op2(I, A),   0 },
/*aa*/	{ "stos",  FALSE, BYTE,  op1(DI),     0 },
/*ab*/	{ "stos",  FALSE, LONG,  op1(DI),     0 },
/*ac*/	{ "lods",  FALSE, BYTE,  op1(SI),     0 },
/*ad*/	{ "lods",  FALSE, LONG,  op1(SI),     0 },
/*ae*/	{ "scas",  FALSE, BYTE,  op1(SI),     0 },
/*af*/	{ "scas",  FALSE, LONG,  op1(SI),     0 },

/*b0*/	{ "mov",   FALSE, BYTE,  op2(I, Ri),  0 },
/*b1*/	{ "mov",   FALSE, BYTE,  op2(I, Ri),  0 },
/*b2*/	{ "mov",   FALSE, BYTE,  op2(I, Ri),  0 },
/*b3*/	{ "mov",   FALSE, BYTE,  op2(I, Ri),  0 },
/*b4*/	{ "mov",   FALSE, BYTE,  op2(I, Ri),  0 },
/*b5*/	{ "mov",   FALSE, BYTE,  op2(I, Ri),  0 },
/*b6*/	{ "mov",   FALSE, BYTE,  op2(I, Ri),  0 },
/*b7*/	{ "mov",   FALSE, BYTE,  op2(I, Ri),  0 },

/*b8*/	{ "mov",   FALSE, LONG,  op2(I, Ri),  0 },
/*b9*/	{ "mov",   FALSE, LONG,  op2(I, Ri),  0 },
/*ba*/	{ "mov",   FALSE, LONG,  op2(I, Ri),  0 },
/*bb*/	{ "mov",   FALSE, LONG,  op2(I, Ri),  0 },
/*bc*/	{ "mov",   FALSE, LONG,  op2(I, Ri),  0 },
/*bd*/	{ "mov",   FALSE, LONG,  op2(I, Ri),  0 },
/*be*/	{ "mov",   FALSE, LONG,  op2(I, Ri),  0 },
/*bf*/	{ "mov",   FALSE, LONG,  op2(I, Ri),  0 },

/*c0*/	{ "",	   TRUE,  BYTE,  op2(Ib, E),  db_Grp2 },
/*c1*/	{ "",	   TRUE,  LONG,  op2(Ib, E),  db_Grp2 },
/*c2*/	{ "ret",   FALSE, NONE,  op1(Iw),     0 },
/*c3*/	{ "ret",   FALSE, NONE,  0,	      0 },
/*c4*/	{ "les",   TRUE,  LONG,  op2(E, R),   0 },
/*c5*/	{ "lds",   TRUE,  LONG,  op2(E, R),   0 },
/*c6*/	{ "mov",   TRUE,  BYTE,  op2(I, E),   0 },
/*c7*/	{ "mov",   TRUE,  LONG,  op2(I, E),   0 },

/*c8*/	{ "enter", FALSE, NONE,  op2(Iw, Ib), 0 },
/*c9*/	{ "leave", FALSE, NONE,  0,           0 },
/*ca*/	{ "lret",  FALSE, NONE,  op1(Iw),     0 },
/*cb*/	{ "lret",  FALSE, NONE,  0,	      0 },
/*cc*/	{ "int",   FALSE, NONE,  op1(o3),     0 },
/*cd*/	{ "int",   FALSE, NONE,  op1(Ib),     0 },
/*ce*/	{ "into",  FALSE, NONE,  0,	      0 },
/*cf*/	{ "iret",  FALSE, NONE,  0,	      0 },

/*d0*/	{ "",	   TRUE,  BYTE,  op2(o1, E),  db_Grp2 },
/*d1*/	{ "",	   TRUE,  LONG,  op2(o1, E),  db_Grp2 },
/*d2*/	{ "",	   TRUE,  BYTE,  op2(CL, E),  db_Grp2 },
/*d3*/	{ "",	   TRUE,  LONG,  op2(CL, E),  db_Grp2 },
/*d4*/	{ "aam",   TRUE,  NONE,  op1(Iba),    0 },
/*d5*/	{ "aad",   TRUE,  NONE,  op1(Iba),    0 },
/*d6*/	{ ".byte\t0xd6",FALSE, NONE, 0,       0 },
/*d7*/	{ "xlat",  FALSE, BYTE,  op1(BX),     0 },

/*d8*/	{ "",      TRUE,  NONE,  0,	      db_Esc8 },
/*d9*/	{ "",      TRUE,  NONE,  0,	      db_Esc9 },
/*da*/	{ "",      TRUE,  NONE,  0,	      db_Esca },
/*db*/	{ "",      TRUE,  NONE,  0,	      db_Escb },
/*dc*/	{ "",      TRUE,  NONE,  0,	      db_Escc },
/*dd*/	{ "",      TRUE,  NONE,  0,	      db_Escd },
/*de*/	{ "",      TRUE,  NONE,  0,	      db_Esce },
/*df*/	{ "",      TRUE,  NONE,  0,	      db_Escf },

/*e0*/	{ "loopne",FALSE, NONE,  op1(Db),     0 },
/*e1*/	{ "loope", FALSE, NONE,  op1(Db),     0 },
/*e2*/	{ "loop",  FALSE, NONE,  op1(Db),     0 },
/*e3*/	{ "jcxz",  FALSE, SDEP,  op1(Db),     "jecxz" },
/*e4*/	{ "in",    FALSE, BYTE,  op2(Ib, A),  0 },
/*e5*/	{ "in",    FALSE, LONG,  op2(Ib, A) , 0 },
/*e6*/	{ "out",   FALSE, BYTE,  op2(A, Ib),  0 },
/*e7*/	{ "out",   FALSE, LONG,  op2(A, Ib) , 0 },

/*e8*/	{ "call",  FALSE, NONE,  op1(Dl),     0 },
/*e9*/	{ "jmp",   FALSE, NONE,  op1(Dl),     0 },
/*ea*/	{ "ljmp",  FALSE, NONE,  op1(OS),     0 },
/*eb*/	{ "jmp",   FALSE, NONE,  op1(Db),     0 },
/*ec*/	{ "in",    FALSE, BYTE,  op2(DX, A),  0 },
/*ed*/	{ "in",    FALSE, LONG,  op2(DX, A) , 0 },
/*ee*/	{ "out",   FALSE, BYTE,  op2(A, DX),  0 },
/*ef*/	{ "out",   FALSE, LONG,  op2(A, DX) , 0 },

/*f0*/	{ "",      FALSE, NONE,  0,	     0 },
/*f1*/	{ "",      FALSE, NONE,  0,	     0 },
/*f2*/	{ "",      FALSE, NONE,  0,	     0 },
/*f3*/	{ "",      FALSE, NONE,  0,	     0 },
/*f4*/	{ "hlt",   FALSE, NONE,  0,	     0 },
/*f5*/	{ "cmc",   FALSE, NONE,  0,	     0 },
/*f6*/	{ "",      TRUE,  BYTE,  0,	     db_Grp3 },
/*f7*/	{ "",	   TRUE,  LONG,  0,	     db_Grp3 },

/*f8*/	{ "clc",   FALSE, NONE,  0,	     0 },
/*f9*/	{ "stc",   FALSE, NONE,  0,	     0 },
/*fa*/	{ "cli",   FALSE, NONE,  0,	     0 },
/*fb*/	{ "sti",   FALSE, NONE,  0,	     0 },
/*fc*/	{ "cld",   FALSE, NONE,  0,	     0 },
/*fd*/	{ "std",   FALSE, NONE,  0,	     0 },
/*fe*/	{ "",	   TRUE,  NONE,  0,	     db_Grp4 },
/*ff*/	{ "",	   TRUE,  NONE,  0,	     db_Grp5 },
};

struct inst	db_bad_inst =
	{ "???",   FALSE, NONE,  0,	      0 }
;

#define	f_mod(byte)	((byte)>>6)
#define	f_reg(byte)	(((byte)>>3)&0x7)
#define	f_rm(byte)	((byte)&0x7)

#define	sib_ss(byte)	((byte)>>6)
#define	sib_index(byte)	(((byte)>>3)&0x7)
#define	sib_base(byte)	((byte)&0x7)

struct i_addr {
	int		is_reg;	/* if reg, reg number is in 'disp' */
	int		disp;
	char *		base;
	char *		index;
	int		ss;
};

char *	db_index_reg_16[8] = {
	"%bx,%si",
	"%bx,%di",
	"%bp,%si",
	"%bp,%di",
	"%si",
	"%di",
	"%bp",
	"%bx"
};

char *	db_reg[3][8] = {
	{ "%al",  "%cl",  "%dl",  "%bl",  "%ah",  "%ch",  "%dh",  "%bh" },
	{ "%ax",  "%cx",  "%dx",  "%bx",  "%sp",  "%bp",  "%si",  "%di" },
	{ "%eax", "%ecx", "%edx", "%ebx", "%esp", "%ebp", "%esi", "%edi" }
};

char *	db_seg_reg[8] = {
	"%es", "%cs", "%ss", "%ds", "%fs", "%gs", "", ""
};

/*
 * lengths for size attributes
 */
int db_lengths[] = {
	1,	/* BYTE */
	2,	/* WORD */
	4,	/* LONG */
	8,	/* QUAD */
	4,	/* SNGL */
	8,	/* DBLR */
	10,	/* EXTR */
};

#define	get_value_inc(result, loc, size, is_signed) \
	do { \
		result = db_get_value((loc), (size), (is_signed)); \
		(loc) += (size); \
	} while (0)


db_addr_t db_read_address(db_addr_t, int, int, struct i_addr *);
void db_print_address(char *, int, struct i_addr *);
db_addr_t db_disasm_esc(db_addr_t, int, int, int, char *);

/*
 * Read address at location and return updated location.
 */
db_addr_t
db_read_address(loc, short_addr, regmodrm, addrp)
	db_addr_t	loc;
	int		short_addr;
	int		regmodrm;
	struct i_addr	*addrp;		/* out */
{
	int		mod, rm, sib, index, disp;

	mod = f_mod(regmodrm);
	rm  = f_rm(regmodrm);

	if (mod == 3) {
		addrp->is_reg = TRUE;
		addrp->disp = rm;
		return (loc);
	}
	addrp->is_reg = FALSE;
	addrp->index = 0;

	if (short_addr) {
		addrp->index = 0;
		addrp->ss = 0;
		switch (mod) {
		    case 0:
			if (rm == 6) {
				get_value_inc(disp, loc, 2, FALSE);
				addrp->disp = disp;
				addrp->base = 0;
			} else {
				addrp->disp = 0;
				addrp->base = db_index_reg_16[rm];
			}
			break;
		    case 1:
			get_value_inc(disp, loc, 1, TRUE);
			disp &= 0xffff;
			addrp->disp = disp;
			addrp->base = db_index_reg_16[rm];
			break;
		    case 2:
			get_value_inc(disp, loc, 2, FALSE);
			addrp->disp = disp;
			addrp->base = db_index_reg_16[rm];
			break;
		}
	} else {
		if (rm == 4) {
			get_value_inc(sib, loc, 1, FALSE);
			rm = sib_base(sib);
			index = sib_index(sib);
			if (index != 4)
				addrp->index = db_reg[LONG][index];
			addrp->ss = sib_ss(sib);
		}

		switch (mod) {
		    case 0:
			if (rm == 5) {
				get_value_inc(addrp->disp, loc, 4, FALSE);
				addrp->base = 0;
			} else {
				addrp->disp = 0;
				addrp->base = db_reg[LONG][rm];
			}
			break;
		    case 1:
			get_value_inc(disp, loc, 1, TRUE);
			addrp->disp = disp;
			addrp->base = db_reg[LONG][rm];
			break;
		    case 2:
			get_value_inc(disp, loc, 4, FALSE);
			addrp->disp = disp;
			addrp->base = db_reg[LONG][rm];
			break;
		}
	}
	return (loc);
}

void
db_print_address(seg, size, addrp)
	char *		seg;
	int		size;
	struct i_addr	*addrp;
{
	if (addrp->is_reg) {
		db_printf("%s", db_reg[size][addrp->disp]);
		return;
	}

	if (seg)
		db_printf("%s:", seg);

	db_printsym((db_addr_t)addrp->disp, DB_STGY_ANY, db_printf);
	if (addrp->base != 0 || addrp->index != 0) {
		db_printf("(");
		if (addrp->base)
			db_printf("%s", addrp->base);
		if (addrp->index)
			db_printf(",%s,%d", addrp->index, 1<<addrp->ss);
		db_printf(")");
	}
}

/*
 * Disassemble floating-point ("escape") instruction
 * and return updated location.
 */
db_addr_t
db_disasm_esc(loc, inst, short_addr, size, seg)
	db_addr_t	loc;
	int		inst;
	int		short_addr;
	int		size;
	char *		seg;
{
	int		regmodrm;
	struct finst	*fp;
	int		mod;
	struct i_addr	address;
	char *		name;

	get_value_inc(regmodrm, loc, 1, FALSE);
	fp = &db_Esc_inst[inst - 0xd8][f_reg(regmodrm)];
	mod = f_mod(regmodrm);
	if (mod != 3) {
		if (*fp->f_name == '\0') {
			db_printf("<bad instruction>");
			return (loc);
		}

		/*
		 * Normal address modes.
		 */
		loc = db_read_address(loc, short_addr, regmodrm, &address);
		db_printf(fp->f_name);
		switch(fp->f_size) {
		    case SNGL:
			db_printf("s");
			break;
		    case DBLR:
			db_printf("l");
			break;
		    case EXTR:
			db_printf("t");
			break;
		    case WORD:
			db_printf("s");
			break;
		    case LONG:
			db_printf("l");
			break;
		    case QUAD:
			db_printf("q");
			break;
		    default:
			break;
		}
		db_printf("\t");
		db_print_address(seg, BYTE, &address);
	} else {
		/*
		 * 'reg-reg' - special formats
		 */
		switch (fp->f_rrmode) {
		    case op2(ST,STI):
			name = (fp->f_rrname) ? fp->f_rrname : fp->f_name;
			db_printf("%s\t%%st,%%st(%d)",name,f_rm(regmodrm));
			break;
		    case op2(STI,ST):
			name = (fp->f_rrname) ? fp->f_rrname : fp->f_name;
			db_printf("%s\t%%st(%d),%%st",name, f_rm(regmodrm));
			break;
		    case op1(STI):
			name = (fp->f_rrname) ? fp->f_rrname : fp->f_name;
			db_printf("%s\t%%st(%d)",name, f_rm(regmodrm));
			break;
		    case op1(X):
			name = ((char * const *)fp->f_rrname)[f_rm(regmodrm)];
			if (*name == '\0')
				goto bad;
			db_printf("%s", name);
			break;
		    case op1(XA):
			name = ((char * const *)fp->f_rrname)[f_rm(regmodrm)];
			if (*name == '\0')
				goto bad;
			db_printf("%s\t%%ax", name);
			break;
		    default:
		    bad:
			db_printf("<bad instruction>");
			break;
		}
	}

	return (loc);
}

/*
d55 1
a55 284
	int	inst;
	int	size;
	int	short_addr;
	char *	seg;
	struct inst *	ip;
	char *	i_name;
	int	i_size;
	int	i_mode;
	int	regmodrm = 0;
	boolean_t	first;
	int	displ;
	int	prefix;
	int	imm;
	int	imm2;
	int	len;
	struct i_addr	address;

	get_value_inc(inst, loc, 1, FALSE);
	short_addr = FALSE;
	size = LONG;
	seg = 0;

	/*
	 * Get prefixes
	 */
	prefix = TRUE;
	do {
		switch (inst) {
		    case 0x66:		/* data16 */
			size = WORD;
			break;
		    case 0x67:
			short_addr = TRUE;
			break;
		    case 0x26:
			seg = "%es";
			break;
		    case 0x36:
			seg = "%ss";
			break;
		    case 0x2e:
			seg = "%cs";
			break;
		    case 0x3e:
			seg = "%ds";
			break;
		    case 0x64:
			seg = "%fs";
			break;
		    case 0x65:
			seg = "%gs";
			break;
		    case 0xf0:
			db_printf("lock ");
			break;
		    case 0xf2:
			db_printf("repne ");
			break;
		    case 0xf3:
			db_printf("repe ");	/* XXX repe VS rep */
			break;
		    default:
			prefix = FALSE;
			break;
		}
		if (prefix)
			get_value_inc(inst, loc, 1, FALSE);
	} while (prefix);

	if (inst >= 0xd8 && inst <= 0xdf) {
		loc = db_disasm_esc(loc, inst, short_addr, size, seg);
		db_printf("\n");
		return (loc);
	}

	if (inst == 0x0f) {
		get_value_inc(inst, loc, 1, FALSE);
		ip = db_inst_0f[inst>>4];
		if (ip == 0)
			ip = &db_bad_inst;
		else
			ip = &ip[inst&0xf];
	} else {
		ip = &db_inst_table[inst];
	}

	if (ip->i_has_modrm) {
		get_value_inc(regmodrm, loc, 1, FALSE);
		loc = db_read_address(loc, short_addr, regmodrm, &address);
	}

	i_name = ip->i_name;
	i_size = ip->i_size;
	i_mode = ip->i_mode;

	if (ip->i_extra == db_Grp1 || ip->i_extra == db_Grp2 ||
	    ip->i_extra == db_Grp6 || ip->i_extra == db_Grp7 ||
	    ip->i_extra == db_Grp8 || ip->i_extra == db_Grp9 ||
	    ip->i_extra == db_GrpA || ip->i_extra == db_GrpB) {
		i_name = ((char **)ip->i_extra)[f_reg(regmodrm)];
	} else if (ip->i_extra == db_Grp3) {
		ip = (struct inst *)ip->i_extra;
		ip = &ip[f_reg(regmodrm)];
		i_name = ip->i_name;
		i_mode = ip->i_mode;
	} else if (ip->i_extra == db_Grp4 || ip->i_extra == db_Grp5) {
		ip = (struct inst *)ip->i_extra;
		ip = &ip[f_reg(regmodrm)];
		i_name = ip->i_name;
		i_mode = ip->i_mode;
		i_size = ip->i_size;
	}

	if (i_size == SDEP) {
		if (size == WORD)
			db_printf("%s", i_name);
		else
			db_printf("%s", ip->i_extra);
	} else {
		db_printf("%s", i_name);
		if (i_size != NONE) {
			if (i_size == BYTE) {
				db_printf("b");
				size = BYTE;
			} else if (i_size == WORD) {
				db_printf("w");
				size = WORD;
			} else if (size == WORD) {
				db_printf("w");
			} else {
				db_printf("l");
			}
		}
	}
	db_printf("\t");
	for (first = TRUE;
	     i_mode != 0;
	     i_mode >>= 8, first = FALSE) {
		if (!first)
			db_printf(",");

		switch (i_mode & 0xFF) {
		    case E:
			db_print_address(seg, size, &address);
			break;
		    case Eind:
			db_printf("*");
			db_print_address(seg, size, &address);
			break;
		    case El:
			db_print_address(seg, LONG, &address);
			break;
		    case Ew:
			db_print_address(seg, WORD, &address);
			break;
		    case Eb:
			db_print_address(seg, BYTE, &address);
			break;
		    case R:
			db_printf("%s", db_reg[size][f_reg(regmodrm)]);
			break;
		    case Rw:
			db_printf("%s", db_reg[WORD][f_reg(regmodrm)]);
			break;
		    case Ri:
			db_printf("%s", db_reg[size][f_rm(inst)]);
			break;
		    case Ril:
			db_printf("%s", db_reg[LONG][f_rm(inst)]);
			break;
		    case S:
			db_printf("%s", db_seg_reg[f_reg(regmodrm)]);
			break;
		    case Si:
			db_printf("%s", db_seg_reg[f_reg(inst)]);
			break;
		    case A:
			db_printf("%s", db_reg[size][0]);	/* acc */
			break;
		    case BX:
			if (seg)
				db_printf("%s:", seg);
			db_printf("(%s)", short_addr ? "%bx" : "%ebx");
			break;
		    case CL:
			db_printf("%%cl");
			break;
		    case DX:
			db_printf("%%dx");
			break;
		    case SI:
			if (seg)
				db_printf("%s:", seg);
			db_printf("(%s)", short_addr ? "%si" : "%esi");
			break;
		    case DI:
			db_printf("%%es:(%s)", short_addr ? "%di" : "%edi");
			break;
		    case CR:
			db_printf("%%cr%d", f_reg(regmodrm));
			break;
		    case DR:
			db_printf("%%dr%d", f_reg(regmodrm));
			break;
		    case TR:
			db_printf("%%tr%d", f_reg(regmodrm));
			break;
		    case I:
			len = db_lengths[size];
			get_value_inc(imm, loc, len, FALSE);
			db_printf("$%#n", imm);
			break;
		    case Is:
			len = db_lengths[size];
			get_value_inc(imm, loc, len, TRUE);
			db_printf("$%#r", imm);
			break;
		    case Ib:
			get_value_inc(imm, loc, 1, FALSE);
			db_printf("$%#n", imm);
			break;
		    case Iba:
			get_value_inc(imm, loc, 1, FALSE);
			if (imm != 0x0a)
				db_printf("$%#n", imm);
			break;
		    case Ibs:
			get_value_inc(imm, loc, 1, TRUE);
			if (size == WORD)
				imm &= 0xFFFF;
			db_printf("$%#r", imm);
			break;
		    case Iw:
			get_value_inc(imm, loc, 2, FALSE);
			db_printf("$%#n", imm);
			break;
		    case O:
			if (short_addr)
				get_value_inc(displ, loc, 2, TRUE);
			else
				get_value_inc(displ, loc, 4, TRUE);
			if (seg)
				db_printf("%s:%#r",seg, displ);
			else
				db_printsym((db_addr_t)displ, DB_STGY_ANY,
				    db_printf);
			break;
		    case Db:
			get_value_inc(displ, loc, 1, TRUE);
			displ += loc;
			if (size == WORD)
				displ &= 0xFFFF;
			db_printsym((db_addr_t)displ, DB_STGY_XTRN, db_printf);
			break;
		    case Dl:
			len = db_lengths[size];
			get_value_inc(displ, loc, len, FALSE);
			displ += loc;
			if (size == WORD)
				displ &= 0xFFFF;
			db_printsym((db_addr_t)displ, DB_STGY_XTRN, db_printf);
			break;
		    case o1:
			db_printf("$1");
			break;
		    case o3:
			db_printf("$3");
			break;
		    case OS:
			get_value_inc(imm, loc, len, FALSE);	/* offset */
			get_value_inc(imm2, loc, 2, FALSE);	/* segment */
			db_printf("$%#n,%#n", imm2, imm);
			break;
		}
	}

	if (altfmt == 0 && (inst == 0xe9 || inst == 0xeb)) {
		/*
		 * GAS pads to longword boundary after unconditional jumps.
		 */
		loc = (loc + (4-1)) & ~(4-1);
	}
	db_printf("\n");
	return (loc);
@


