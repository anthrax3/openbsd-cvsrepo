head	1.47;
access;
symbols
	OPENBSD_6_0:1.47.0.2
	OPENBSD_6_0_BASE:1.47
	OPENBSD_5_9:1.45.0.2
	OPENBSD_5_9_BASE:1.45
	OPENBSD_5_8:1.43.0.4
	OPENBSD_5_8_BASE:1.43
	OPENBSD_5_7:1.41.0.2
	OPENBSD_5_7_BASE:1.41
	OPENBSD_5_6:1.40.0.6
	OPENBSD_5_6_BASE:1.40
	OPENBSD_5_5:1.40.0.4
	OPENBSD_5_5_BASE:1.40
	OPENBSD_5_4:1.39.0.4
	OPENBSD_5_4_BASE:1.39
	OPENBSD_5_3:1.39.0.2
	OPENBSD_5_3_BASE:1.39
	OPENBSD_5_2:1.38.0.2
	OPENBSD_5_2_BASE:1.38
	OPENBSD_5_1_BASE:1.37
	OPENBSD_5_1:1.37.0.6
	OPENBSD_5_0:1.37.0.4
	OPENBSD_5_0_BASE:1.37
	OPENBSD_4_9:1.37.0.2
	OPENBSD_4_9_BASE:1.37
	OPENBSD_4_8:1.35.0.2
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.30.0.2
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.30.0.4
	OPENBSD_4_6_BASE:1.30
	OPENBSD_4_5:1.29.0.2
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.28.0.2
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.24.0.2
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.22.0.2
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.17.0.2
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.14.0.2
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.11.0.4
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.6.0.4
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	SMP:1.4.0.2;
locks; strict;
comment	@ * @;


1.47
date	2016.06.08.17.24.44;	author tedu;	state Exp;
branches;
next	1.46;
commitid	oK6mhkiIMNMJ6OsK;

1.46
date	2016.05.30.17.52.26;	author tedu;	state Exp;
branches;
next	1.45;
commitid	m09O7IRRFacwooXV;

1.45
date	2015.12.27.04.31.34;	author jsg;	state Exp;
branches;
next	1.44;
commitid	dxEnyjnljo1QbPFz;

1.44
date	2015.11.07.01.37.26;	author naddy;	state Exp;
branches;
next	1.43;
commitid	L3HpIZTyGf6C2PRf;

1.43
date	2015.07.17.21.53.56;	author mlarkin;	state Exp;
branches;
next	1.42;
commitid	1RFZ9NlS2KARWsKl;

1.42
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.41;
commitid	p4LJxGKbi0BU2cG6;

1.41
date	2014.12.16.18.30.03;	author tedu;	state Exp;
branches;
next	1.40;
commitid	P6Av4XGqOi3rFasL;

1.40
date	2013.11.19.09.00.43;	author mpi;	state Exp;
branches;
next	1.39;

1.39
date	2012.09.19.20.19.31;	author jsg;	state Exp;
branches;
next	1.38;

1.38
date	2012.07.13.14.43.28;	author mlarkin;	state Exp;
branches;
next	1.37;

1.37
date	2010.11.18.21.13.16;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2010.09.07.16.22.48;	author mikeb;	state Exp;
branches;
next	1.35;

1.35
date	2010.07.25.21.43.38;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2010.07.01.00.24.27;	author thib;	state Exp;
branches;
next	1.33;

1.33
date	2010.06.28.22.20.12;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2010.06.27.19.21.20;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2010.04.20.23.12.01;	author phessler;	state Exp;
branches;
next	1.30;

1.30
date	2009.05.31.03.20.10;	author matthieu;	state Exp;
branches;
next	1.29;

1.29
date	2008.08.19.02.02.02;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2008.07.21.04.35.54;	author todd;	state Exp;
branches;
next	1.27;

1.27
date	2008.05.26.22.49.58;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2008.05.25.03.21.24;	author krw;	state Exp;
branches;
next	1.25;

1.25
date	2008.03.19.05.47.47;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2007.12.27.18.04.27;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2007.12.11.17.53.18;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2007.06.01.19.25.09;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2007.05.15.01.56.47;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2007.05.04.19.30.54;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2007.05.04.03.44.44;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2007.05.01.17.41.36;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2007.01.15.23.19.05;	author jsg;	state Exp;
branches;
next	1.16;

1.16
date	2006.10.29.18.28.07;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2006.10.17.19.39.07;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2006.05.28.14.58.14;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2006.05.20.22.40.32;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2006.03.15.20.04.33;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.27.18.31.08;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2005.12.13.00.18.19;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.01.03.11.02;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.12.25.23.02.23;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.10.23.08.21.26;	author mjc;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.27.23.45.23;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.25.00.16.04;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2004.02.09.20.39.25;	author mickey;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2004.02.08.03.15.04;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.03.12.09.47;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.28.01.39.38;	author mickey;	state Exp;
branches;
next	;

1.4.2.1
date	2004.02.22.22.08.18;	author niklas;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2004.06.05.23.09.24;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.47
log
@remove obsolete raid from namtoblk tables. from Artturi Alm
@
text
@/*	$OpenBSD: autoconf.c,v 1.46 2016/05/30 17:52:26 tedu Exp $	*/
/*	$NetBSD: autoconf.c,v 1.1 2003/04/26 18:39:26 fvdl Exp $	*/

/*-
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * William Jolitz.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)autoconf.c	7.1 (Berkeley) 5/9/91
 */

/*
 * Setup the system to run on the current machine.
 *
 * cpu_configure() is called at boot time and initializes the vba 
 * device tables and the memory controller monitoring.  Available
 * devices are determined (from possibilities mentioned in ioconf.c),
 * and the drivers are initialized.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/disklabel.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/vnode.h>
#include <sys/fcntl.h>
#include <sys/dkio.h>
#include <sys/reboot.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/timeout.h>
#include <sys/hibernate.h>

#include <net/if.h>
#include <net/if_types.h>
#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <machine/pte.h>
#include <machine/cpu.h>
#include <machine/cpufunc.h>
#include <machine/biosvar.h>

#include "ioapic.h"
#include "lapic.h"

#if NIOAPIC > 0
#include <machine/i82093var.h>
#endif

#if NLAPIC > 0
#include <machine/i82489var.h>
#endif

int	cold = 1;	/* if 1, still working on cold-start */
extern dev_t bootdev;

/* Support for VIA C3 RNG */
extern struct timeout viac3_rnd_tmo;
extern int	viac3_rnd_present;
void		viac3_rnd(void *);

extern struct timeout rdrand_tmo;
extern int	has_rdrand;
extern int	has_rdseed;
void		rdrand(void *);

#ifdef CRYPTO
void		viac3_crypto_setup(void);
extern int	amd64_has_xcrypt;

void		pclmul_setup(void);
extern int	amd64_has_pclmul;

void		aesni_setup(void);
extern int	amd64_has_aesni;
#endif

/*
 * Determine i/o configuration for a machine.
 */
void
cpu_configure(void)
{
	x86_64_proc0_tss_ldt_init();

	if (config_rootfound("mainbus", NULL) == NULL)
		panic("configure: mainbus not configured");

	intr_printconfig();

#if NIOAPIC > 0
	lapic_set_lvt();
	ioapic_enable();
#endif

#ifdef MULTIPROCESSOR
	cpu_init_idle_pcbs();
#endif

	lcr8(0);
	spl0();
	cold = 0;

	/*
	 * At this point the RNG is running, and if FSXR is set we can
	 * use it.  Here we setup a periodic timeout to collect the data.
	 */
	if (viac3_rnd_present) {
		timeout_set(&viac3_rnd_tmo, viac3_rnd, &viac3_rnd_tmo);
		viac3_rnd(&viac3_rnd_tmo);
	}
	timeout_set(&rdrand_tmo, rdrand, &rdrand_tmo);
	rdrand(&rdrand_tmo);
#ifdef CRYPTO
	/*
	 * Also, if the chip has crypto available, enable it.
	 */
	if (amd64_has_xcrypt)
		viac3_crypto_setup();

	if (amd64_has_pclmul)
		pclmul_setup();

	if (amd64_has_aesni)
		aesni_setup();
#endif
}

void
device_register(struct device *dev, void *aux)
{
}

/*
 * Now that we are fully operational, we can checksum the
 * disks, and using some heuristics, hopefully are able to
 * always determine the correct root disk.
 */
void
diskconf(void)
{
	int majdev, unit, part = 0;
	struct device *bootdv = NULL;
	dev_t tmpdev;
	char buf[128];
	extern bios_bootmac_t *bios_bootmac;

	dkcsumattach();

	if ((bootdev & B_MAGICMASK) == (u_int)B_DEVMAGIC) {
		majdev = B_TYPE(bootdev);
		unit = B_UNIT(bootdev);
		part = B_PARTITION(bootdev);
		snprintf(buf, sizeof buf, "%s%d%c", findblkname(majdev),
		    unit, part + 'a');
		bootdv = parsedisk(buf, strlen(buf), part, &tmpdev);
	}

	if (bios_bootmac) {
		struct ifnet *ifp;

		for (ifp = TAILQ_FIRST(&ifnet); ifp != NULL;
		    ifp = TAILQ_NEXT(ifp, if_list)) {
			if (ifp->if_type == IFT_ETHER &&
			    bcmp(bios_bootmac->mac,
			    ((struct arpcom *)ifp)->ac_enaddr,
			    ETHER_ADDR_LEN) == 0)
				break;
		}
		if (ifp) {
#if defined(NFSCLIENT)
			printf("PXE boot MAC address %s, interface %s\n",
			    ether_sprintf(bios_bootmac->mac), ifp->if_xname);
			bootdv = parsedisk(ifp->if_xname, strlen(ifp->if_xname),
			    0, &tmpdev);
			part = 0;
#endif
		} else
			printf("PXE boot MAC address %s, interface %s\n",
			    ether_sprintf(bios_bootmac->mac), "unknown");
	}

	setroot(bootdv, part, RB_USERREQ);
	dumpconf();

#ifdef HIBERNATE
	hibernate_resume();
#endif /* HIBERNATE */
}

struct nam2blk nam2blk[] = {
	{ "wd",		0 },
	{ "fd",		2 },
	{ "sd",		4 },
	{ "cd",		6 },
	{ "vnd",	14 },
	{ "rd",		17 },
	{ NULL,		-1 }
};
@


1.46
log
@include rdtsc in the rdrand callback. some systems don't have rdrand yet,
but rdtsc may provide a few bits. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.45 2015/12/27 04:31:34 jsg Exp $	*/
a227 1
	{ "raid",	19 },
@


1.45
log
@If available prefer the rdseed instruction over rdrand when adding entropy
to the kernel rng.  If the rdseed source is empty fallback to rdrand
as suggested by naddy.  rdrand output comes from a prng that is
periodically reseeded.  rdseed should give us more bits of entropy.

ok naddy@@ djm@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.44 2015/11/07 01:37:26 naddy Exp $	*/
d142 2
a143 4
	if (has_rdrand || has_rdseed) {
		timeout_set(&rdrand_tmo, rdrand, &rdrand_tmo);
		rdrand(&rdrand_tmo);
	}
@


1.44
log
@Allow overriding ghash_update() with an optimized MD function.  Use
this on amd64 to provide a version that uses the PCLMUL instruction
on CPUs that support it but don't have AESNI.  ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.43 2015/07/17 21:53:56 mlarkin Exp $	*/
d94 1
d142 1
a142 1
	if (has_rdrand) {
@


1.43
log
@
Remove (unused) references to bios32, which is not present in amd64.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.42 2015/03/14 03:38:46 jsg Exp $	*/
d100 3
d151 3
@


1.42
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.41 2014/12/16 18:30:03 tedu Exp $	*/
a83 7
#if 0
#include "bios32.h"
#if NBIOS32 > 0
#include <machine/bios32.h>
#endif
#endif

a109 4
#if NBIOS32 > 0
	bios32_init();
#endif

@


1.41
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.40 2013/11/19 09:00:43 mpi Exp $	*/
a71 2

#include <dev/cons.h>
@


1.40
log
@Remove some FDDI/ATM leftovers.

ok mikeb@@, henning@@, deraadt@@, brad@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.39 2012/09/19 20:19:31 jsg Exp $	*/
d70 1
@


1.39
log
@Add support for the rdrand instruction found in recent Intel processors.
Joint work with naddy@@

ok naddy@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.38 2012/07/13 14:43:28 mlarkin Exp $	*/
d201 1
a201 2
			if ((ifp->if_type == IFT_ETHER ||
			    ifp->if_type == IFT_FDDI) &&
@


1.38
log
@

Make amd64 look like i386 for hibernate resume
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.37 2010/11/18 21:13:16 miod Exp $	*/
d100 4
d149 4
@


1.37
log
@Do not #include <sys/dkstat.h> if you don't need anything from it.
ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.36 2010/09/07 16:22:48 mikeb Exp $	*/
d61 1
d215 4
@


1.36
log
@enable aesni.

that means that all users running ipsec on amd64 with 'aes'
cpu flag will have aes encryption accelerated in cbc and ctr
modes for all three key sizes: 128, 192 and 256.

for debug purposed a number of operations performed by the
driver is visible throught the pstat(8) utility:

  pstat -d u aesni_ops

note that you need to run config(8) to hook up new files.

ok kettenis thib deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.35 2010/07/25 21:43:38 deraadt Exp $	*/
a49 1
#include <sys/dkstat.h>
@


1.35
log
@in the clock drivers, seperate the soft-state and hard-state which was
all jumbled up in the same functions. the rtc (mc chip) and clock (i8243)
startup was also mixed up.  they the soft state and hardware state can
be started in the right order, and it is easy to restart just the
neccessary parts upon resume.  tested in numerous cases:
(apic, pic) * (GENERIC.MP, GENERIC) * (mp, non-mp) * (i386, amd64)
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.34 2010/07/01 00:24:27 thib Exp $	*/
d103 1
a103 1
#ifdef notyet
a106 1
#endif
d152 1
a152 1
#ifdef notyet
a154 1
#endif
@


1.34
log
@Add things to enable aesni either ifdef'ed or commented out to ease
testing.

Note: aesni is not in a usable state yet!

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.33 2010/06/28 22:20:12 deraadt Exp $	*/
a119 2

	startrtclock();
@


1.33
log
@Ah, this will not help the netboot case
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.32 2010/06/27 19:21:20 deraadt Exp $	*/
d103 4
d155 4
@


1.32
log
@Mark the PXE boot device as "netboot" even if we do not contain
nfs client support (yes, it becomes the root device too, but for ramdisks
this is OK because they are not a swap generic configuration)
Discussion with reyk and halex
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.31 2010/04/20 23:12:01 phessler Exp $	*/
d197 1
d203 1
@


1.31
log
@fix amd64 kernel compile after proc.h was removed from uvm_map.h

OK tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.30 2009/05/31 03:20:10 matthieu Exp $	*/
a196 1
#if defined(NFSCLIENT)
a201 1
#endif
@


1.30
log
@Add VIA crypto features support to amd64. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.29 2008/08/19 02:02:02 deraadt Exp $	*/
d61 1
@


1.29
log
@add missing devices to nam2blk[]
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.28 2008/07/21 04:35:54 todd Exp $	*/
d94 10
d135 16
@


1.28
log
@nam2blk[] needs a "vnd" entry for some things (like softraid)
ok marco@@ no objection miod@@ need this for regress djm@@ no objection krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.27 2008/05/26 22:49:58 deraadt Exp $	*/
d188 1
d190 2
a193 1
	{ "vnd",	14 },
@


1.27
log
@do not muck with the mountroot variable, since setroot() uses the state of
it and rootdev to determine whether it is booting 'generic', 'nfs', or from
a specified disk partition
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.26 2008/05/25 03:21:24 krw Exp $	*/
d191 1
@


1.26
log
@Nuke a couple of unused variables (booted_device, booted_partition).

ok weingart@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.25 2008/03/19 05:47:47 deraadt Exp $	*/
a172 1
			mountroot = nfs_mountroot;	/* potentially */
@


1.25
log
@label all interfaces we netboot from in group "netboot", in a MI fashion
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.24 2007/12/27 18:04:27 deraadt Exp $	*/
a91 2
struct device *booted_device;
int booted_partition;
@


1.24
log
@missing newline in autoconf pxe report; spotted by henning
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.23 2007/12/11 17:53:18 deraadt Exp $	*/
a171 1
			if_addgroup(ifp, "pxeboot");
@


1.23
log
@if we pxebooted, and can find the interface, put it in a "pxeboot" group
so that later applications can try to do the right thing
for reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.22 2007/06/01 19:25:09 deraadt Exp $	*/
d174 1
a174 1
			printf("PXE boot MAC address %s, interface %s",
@


1.22
log
@some architectures called setroot() from cpu_configure(), *way* before some
subsystems were enabled.  others used a *md_diskconf -> diskconf() method to
make sure init_main could "do late setroot".  Change all architectures to
have diskconf(), use it directly & late.  tested by todd and myself on most
architectures, ok miod too
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.22 2007/06/01 19:20:46 deraadt Exp $	*/
a145 1
#if defined(NFSCLIENT)
a146 1
#endif
a158 1
#if defined(NFSCLIENT)
a161 2
		printf("PXE boot MAC address %s, ",
		    ether_sprintf(bios_bootmac->mac));
d172 4
a175 1
			printf("interface %s\n", ifp->if_xname);
d180 1
d182 2
a183 1
			printf("unknown interface\n");
a184 1
#endif
@


1.21
log
@kill __HAVE_DEVICE_REGISTER by requiring all architectures to have a
device_register() function -- even if it does nothing.  reduces the
cpp-based blather different between architectures
idea ok'd by miod; tested on all architectures (except a few miod will
need to cleanup because he has them)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.20 2007/05/04 19:30:54 deraadt Exp $	*/
a83 2
void diskconf(void);

a126 2

	md_diskconf = diskconf;
@


1.20
log
@make findblkmajor() and findblkname() MI; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.19 2007/05/04 03:44:44 deraadt Exp $	*/
d131 5
@


1.19
log
@setroot() was a ugly mix of MI and MD code, with different bugs on different
machines.  Instead -- build one solid clean MI version, and thenchange all
the architectures to use it.  ok various people, tested on almost all cases.
(it is a 10094 line diff..)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.18 2007/05/01 17:41:36 deraadt Exp $	*/
d190 1
a190 4
static struct {
	char	*name;
	int	maj;
} nam2blk[] = {
d195 1
a196 23

int
findblkmajor(struct device *dv)
{
	char *name = dv->dv_xname;
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); i++)
		if (!strncmp(name, nam2blk[i].name, strlen(nam2blk[i].name)))
			return (nam2blk[i].maj);
	return (-1);
}

char *
findblkname(int maj)
{
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); i++)
		if (nam2blk[i].maj == maj)
			return (nam2blk[i].name);
	return (NULL);
}
@


1.18
log
@similar exit support for -a, to what i386 does
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.17 2007/01/15 23:19:05 jsg Exp $	*/
a83 2
void setroot(void);
void rootconf(void);
a84 3
int findblkmajor(struct device *);
char *findblkname(int);
struct device * parsedisk(char *, int, int, dev_t *);
a97 4
#ifdef RAMDISK_HOOKS
static struct device fakerdrootdev = { DV_DISK, {}, NULL, 0, "rd0", NULL };
#endif

a132 98
void
diskconf(void)
{
	/* Checksum disks, same as /boot did, then fixup *dev vars */
	dkcsumattach();

	rootconf();
	dumpconf();
}

struct device *
parsedisk(char *str, int len, int defpart, dev_t *devp)
{
	struct device *dv;
	char *cp, c;
	int majdev, unit, part;

	if (len == 0)
		return (NULL);
	cp = str + len - 1;
	c = *cp;
	if (c >= 'a' && (c - 'a') < MAXPARTITIONS) {
		part = c - 'a';
		*cp = '\0';
	} else
		part = defpart;

#ifdef RAMDISK_HOOKS
	if (strcmp(str, fakerdrootdev.dv_xname) == 0) {
		dv = &fakerdrootdev;
		goto gotdisk;
	}
#endif

	TAILQ_FOREACH(dv, &alldevs, dv_list) {
		if (dv->dv_class == DV_DISK &&
		    strcmp(str, dv->dv_xname) == 0) {
#ifdef RAMDISK_HOOKS
gotdisk:
#endif
			majdev = findblkmajor(dv);
			unit = dv->dv_unit;
			if (majdev < 0)
				panic("parsedisk");
			*devp = MAKEDISKDEV(majdev, unit, part);
			break;
		}
#ifdef NFSCLIENT
		if (dv->dv_class == DV_IFNET &&
		    strcmp(str, dv->dv_xname) == 0) {
			*devp = NODEV;
			break;
		}
#endif
	}

	*cp = c;
	return (dv);
}

/* XXX */
static	struct nam2blk {
	char *name;
	int  maj;
} nam2blk[] = {
	{ "wd",		0 },	/* 0 = wd */
	{ "sd",		4 },	/* 2 = sd */
	{ "rd",		17 },	/* 17 = rd */
	{ "raid",	19 },	/* 19 = raid */
};

int
findblkmajor(struct device *dv)
{
	char *name = dv->dv_xname;
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); ++i)
		if (strncmp(name, nam2blk[i].name, strlen(nam2blk[i].name)) == 0)
			return (nam2blk[i].maj);
	 return (-1);
}

char *
findblkname(int maj)
{
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); i++)
		if (nam2blk[i].maj == maj)
			return (nam2blk[i].name);
	 return (NULL);
}

/* Code from here to handle "bsd swap generic" */

dev_t	argdev = NODEV;

d134 3
a136 3
 * Attempt to find the device from which we were booted.
 * If we can do so, and not instructed not to do so,
 * change rootdev to correspond to the load device.
d139 1
a139 1
setroot(void)
d141 4
a144 2
	int  majdev, mindev, unit, part, adaptor;
	dev_t orootdev;
d148 11
a158 4
#ifdef DOSWAP
	dev_t temp = 0;
	struct swdevt *swp;
#endif
a161 1
		extern char *nfsbootdevname;
a163 2
		mountroot = nfs_mountroot;

a165 1

d176 5
a180 2
			nfsbootdevname = ifp->if_xname;
			printf("interface %s\n", nfsbootdevname);
d182 1
a182 2
			printf("no interface selected\n");
		return;
a184 35
	if (boothowto & RB_DFLTROOT ||
	    (bootdev & B_MAGICMASK) != (u_long)B_DEVMAGIC)
		return;

	majdev = B_TYPE(bootdev);
	if (findblkname(majdev) == NULL)
		return;
	adaptor = B_ADAPTOR(bootdev);
	part = B_PARTITION(bootdev);
	unit = B_UNIT(bootdev);
	mindev = (unit * MAXPARTITIONS) + part;
	orootdev = rootdev;
	rootdev = makedev(majdev, mindev);
	mountroot = dk_mountroot;

	/*
	 * If the original rootdev is the same as the one
	 * just calculated, don't need to adjust the swap configuration.
	 */
	printf("root on %s%d%c\n", findblkname(majdev), unit, part + 'a');
	if (rootdev == orootdev)
		return;

#ifdef DOSWAP
	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		if (majdev == major(swp->sw_dev) &&
		    mindev/MAXPARTITIONS == minor(swp->sw_dev)/MAXPARTITIONS) {
			temp = swdevt[0].sw_dev;
			swdevt[0].sw_dev = swp->sw_dev;
			swp->sw_dev = temp;
			break;
		}
	}
	if (swp->sw_dev == NODEV)
		return;
d186 2
a187 7
	/*
	 * If dumpdev was the same as the old primary swap device, move
	 * it to the new primary swap device.
	 */
	if (temp == dumpdev)
		dumpdev = swdevt[0].sw_dev;
#endif
d190 8
a197 56
#include "wd.h"
#if NWD > 0
extern	struct cfdriver wd_cd;
#endif
#include "sd.h"
#if NSD > 0
extern	struct cfdriver sd_cd;
#endif
#include "cd.h"
#if NCD > 0
extern	struct cfdriver cd_cd;
#endif
#include "mcd.h"
#if NMCD > 0
extern	struct cfdriver mcd_cd;
#endif
#include "fd.h"
#if NFD > 0
extern	struct cfdriver fd_cd;
#endif
#include "rd.h"
#if NRD > 0
extern	struct cfdriver rd_cd;
#endif
#include "raid.h"
#if NRAID > 0
extern	struct cfdriver raid_cd;
#endif

struct	genericconf {
	struct cfdriver *gc_driver;
	char *gc_name;
	dev_t gc_major;
} genericconf[] = {
#if NWD > 0
	{ &wd_cd,  "wd",  0 },
#endif
#if NFD > 0
	{ &fd_cd,  "fd",  2 },
#endif
#if NSD > 0
	{ &sd_cd,  "sd",  4 },
#endif
#if NCD > 0
	{ &cd_cd,  "cd",  6 },
#endif
#if NMCD > 0
	{ &mcd_cd, "mcd", 7 },
#endif
#if NRD > 0
	{ &rd_cd,  "rd",  17 },
#endif
#if NRAID > 0
	{ &raid_cd,  "raid",  19 },
#endif
	{ 0 }
d200 2
a201 2
void
rootconf(void)
d203 2
a204 7
	struct genericconf *gc;
	int unit, part = 0;
#if defined(NFSCLIENT)
	struct ifnet *ifp;
#endif
	char name[128];
	char *num;
d206 5
a210 57
	if (boothowto & RB_ASKNAME) {
		while (1) {
			printf("root device? ");
			cnpollc(TRUE);
			getsn(name, sizeof name);
			cnpollc(FALSE);
			if (*name == '\0')
				break;
			if (strcmp(name, "exit") == 0)
				boot(RB_USERREQ);
			for (gc = genericconf; gc->gc_driver; gc++)
				if (gc->gc_driver->cd_ndevs &&
				    strncmp(gc->gc_name, name,
				    strlen(gc->gc_name)) == 0)
					break;
			if (gc->gc_driver) {
				num = &name[strlen(gc->gc_name)];
	
				unit = -2;
				do {
					if (unit != -2 && *num >= 'a' &&
					    *num <= 'a'+MAXPARTITIONS-1 &&
					    num[1] == '\0') {
						part = *num++ - 'a';
						break;
					}
					if (unit == -2)
						unit = 0;
					unit = (unit * 10) + *num - '0';
					if (*num < '0' || *num > '9')
						unit = -1;
				} while (unit != -1 && *++num);
	
				if (unit < 0) {
					printf("%s: not a unit number\n",
					    &name[strlen(gc->gc_name)]);
				} else if (unit >= gc->gc_driver->cd_ndevs ||
				    gc->gc_driver->cd_devs[unit] == NULL) {
					printf("%d: no such unit\n", unit);
				} else {
					rootdev = makedev(gc->gc_major,
					    unit * MAXPARTITIONS + part);
					mountroot = dk_mountroot;
					break;
				}
#if defined(NFSCLIENT)
			} else {
				ifp = ifunit(name);
				if (ifp && (ifp->if_flags & IFF_BROADCAST)) {
					extern char *nfsbootdevname;

					mountroot = nfs_mountroot;
					nfsbootdevname = ifp->if_xname;
					return;
				}
#endif
			}
d212 4
a215 18
			printf("use one of: exit");
			for (gc = genericconf; gc->gc_driver; gc++) {
				for (unit=0; unit < gc->gc_driver->cd_ndevs; unit++) {
					if (gc->gc_driver->cd_devs[unit])
						printf(" %s%d[a-%c]", gc->gc_name,
						    unit, 'a'+MAXPARTITIONS-1);
				}
			}
#if defined(NFSCLIENT)
			for (ifp = TAILQ_FIRST(&ifnet); ifp != NULL;
			    ifp = TAILQ_NEXT(ifp, if_list)) {
				if ((ifp->if_flags & IFF_BROADCAST))
					printf(" %s", ifp->if_xname);
			}
#endif
			printf("\n");
		}
	}
d217 4
a220 21
	if (mountroot == NULL) {
		/* `swap generic' */
		setroot();
#if defined(NFSCLIENT)
	} else if (mountroot == nfs_mountroot) {
		;
#endif
	} else {
		/* preconfigured on disk */
		int  majdev, unit, part;

		majdev = major(rootdev);
		if (findblkname(majdev) == NULL)
			return;
		part = minor(rootdev) % MAXPARTITIONS;
		unit = minor(rootdev) / MAXPARTITIONS;
		printf("root on %s%d%c\n", findblkname(majdev), unit, part + 'a');
	}
	if (mountroot == dk_mountroot)
		swdevt[0].sw_dev = argdev = dumpdev =
		    MAKEDISKDEV(major(rootdev), DISKUNIT(rootdev), 1);
@


1.17
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.16 2006/10/29 18:28:07 kettenis Exp $	*/
d407 2
d457 1
a457 1
			printf("use one of: ");
d461 1
a461 1
						printf("%s%d[a-%c] ", gc->gc_name,
d469 1
a469 1
					printf("%s ", ifp->if_xname);
@


1.16
log
@The default for swap should be partition 'b' on the same unit as root is,
not partition 'b' on unit 0.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.15 2006/10/17 19:39:07 deraadt Exp $	*/
d153 1
a153 4
parsedisk(str, len, defpart, devp)
	char *str;
	int len, defpart;
	dev_t *devp;
d226 1
a226 2
findblkname(maj)
	int maj;
d246 1
a246 1
setroot()
d389 1
a389 1
rootconf()
d391 1
a391 1
	register struct genericconf *gc;
@


1.15
log
@swap is partition b, not partition after root (wherever root is defined
to be); pr 5256
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.14 2006/05/28 14:58:14 deraadt Exp $	*/
d498 1
a498 1
		    makedev(major(rootdev), 1);
@


1.14
log
@do not print "root on ..." twice for the -a case, also cope with systems
configured for 'root on nfs'
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.13 2006/05/20 22:40:32 deraadt Exp $	*/
d498 1
a498 1
		    makedev(major(rootdev), minor(rootdev) + 1);
@


1.13
log
@Detect BOOTARG_BOOTMAC coming from PXE; search for interface and attempt
to boot from it.  At the same time add -a support for network interface
selection; tested by reyk, mk, deraadt on i386, cloned code applied to
amd64 and tested a little bit less
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.12 2006/03/15 20:04:33 miod Exp $	*/
a267 1
		nfsbootdevname = NULL;		/* we do not know */
a440 2
					printf("root on %s%d%c\n", gc->gc_name, unit,
					    'a' + part);
d481 4
d486 1
a486 1
		/* preconfigured */
a494 1
		mountroot = dk_mountroot;
@


1.12
log
@Correct checks against cd_ndevs - valid numbers are strictly inferior to
cd_ndevs.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.11 2005/12/27 18:31:08 miod Exp $	*/
d59 7
d69 1
d254 3
d262 28
d293 1
d303 2
d398 4
a403 8
#ifdef INSTALL
	if (B_TYPE(bootdev) == 2) {
		printf("\n\nInsert file system floppy...\n");
		if (!(boothowto & RB_ASKNAME))
			cngetc();
	}
#endif

d405 6
a410 12
		char name[128];
retry:
		printf("root device? ");
		cnpollc(TRUE);
		getsn(name, sizeof name);
		cnpollc(FALSE);
		if (*name == '\0')
			goto noask;
		for (gc = genericconf; gc->gc_driver; gc++)
			if (gc->gc_driver->cd_ndevs &&
			    strncmp(gc->gc_name, name,
			    strlen(gc->gc_name)) == 0)
d412 35
a446 9
		if (gc->gc_driver) {
			num = &name[strlen(gc->gc_name)];

			unit = -2;
			do {
				if (unit != -2 && *num >= 'a' &&
				    *num <= 'a'+MAXPARTITIONS-1 &&
				    num[1] == '\0') {
					part = *num++ - 'a';
d449 1
a449 13
				if (unit == -2)
					unit = 0;
				unit = (unit * 10) + *num - '0';
				if (*num < '0' || *num > '9')
					unit = -1;
			} while (unit != -1 && *++num);

			if (unit < 0) {
				printf("%s: not a unit number\n",
				    &name[strlen(gc->gc_name)]);
			} else if (unit >= gc->gc_driver->cd_ndevs ||
			    gc->gc_driver->cd_devs[unit] == NULL) {
				printf("%d: no such unit\n", unit);
d451 18
a468 5
				printf("root on %s%d%c\n", gc->gc_name, unit,
				    'a' + part);
				rootdev = makedev(gc->gc_major,
				    unit * MAXPARTITIONS + part);
				goto doswap;
d470 5
a474 7
		}
		printf("use one of: ");
		for (gc = genericconf; gc->gc_driver; gc++) {
			for (unit=0; unit < gc->gc_driver->cd_ndevs; unit++) {
				if (gc->gc_driver->cd_devs[unit])
					printf("%s%d[a-%c] ", gc->gc_name,
					    unit, 'a'+MAXPARTITIONS-1);
d476 2
a478 2
		printf("\n");
		goto retry;
d480 1
a480 1
noask:
d494 1
a494 1
		return;
d496 3
a498 8

doswap:
#ifndef DISKLESS
	mountroot = dk_mountroot;
#endif
	swdevt[0].sw_dev = argdev = dumpdev =
	    makedev(major(rootdev), minor(rootdev) + 1);
	/* swap size and dumplo set during autoconfigure */
@


1.11
log
@Remove unused sw_nblks field of struct swdevt. Then, remove swapconf()
which duplicates work done by uvm_swap_init().
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.10 2005/12/13 00:18:19 jsg Exp $	*/
d401 1
a401 1
			} else if (unit > gc->gc_driver->cd_ndevs ||
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.
Checked by ian@@, deraadt@@ and millert@@, arm portion checked by drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.9 2005/01/01 03:11:02 millert Exp $	*/
a77 1
void swapconf(void);
a140 1
	swapconf();
a141 18
}

void
swapconf(void)
{
	struct swdevt *swp;
	int nblks;

	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		if (bdevsw[major(swp->sw_dev)].d_psize) {
			nblks =
			    (*bdevsw[major(swp->sw_dev)].d_psize)(swp->sw_dev);
			if (nblks != -1 &&
			    (swp->sw_nblks == 0 || swp->sw_nblks > nblks))
				swp->sw_nblks = nblks;
			swp->sw_nblks = ctod(dtoc(swp->sw_nblks));
		}
	}
@


1.9
log
@gcc 3.3.5 will store zero-initialized variables in bss by default,
move bootdev to data so it doesn't get zapped when bss is cleared.
deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.8 2004/12/25 23:02:23 miod Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.8
log
@Use list and queue macros where applicable to make the code easier to read;
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.7 2004/10/23 08:21:26 mjc Exp $	*/
d98 1
a98 1
dev_t bootdev = 0;
@


1.7
log
@configure() -> cpu_configure()
ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.6 2004/02/27 23:45:23 deraadt Exp $	*/
d195 1
a195 1
	for (dv = alldevs.tqh_first; dv != NULL; dv = dv->dv_list.tqe_next) {
@


1.6
log
@remove old crud
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.5 2004/02/25 00:16:04 deraadt Exp $	*/
d45 1
a45 1
 * Configure() is called at boot time and initializes the vba 
@


1.5
log
@dkcsum stuff for amd64, written by tom, who cannot commit it at the moment.
now the amd64 knows what drive it was booted from.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.4 2004/02/09 20:39:25 mickey Exp $	*/
a86 3

extern struct disklist *x86_64_alldisks;
extern int x86_64_ndisks;
@


1.4
log
@init the clock before autoconf start for delay() to be truly usable; i moved it to after while debugging clocks in the early days
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.3 2004/02/08 03:15:04 deraadt Exp $	*/
d81 1
a85 1
static	struct device *getdisk(char *, int, int, dev_t *);
a86 1
static	int getstr(char *, int);
d101 1
a101 1
dev_t bootdev;
d145 4
a148 1
	setroot();
a153 209
setroot()
{
	struct swdevt *swp;
	struct device *dv;
	int len, majdev, unit, part;
	dev_t nrootdev, nswapdev = NODEV;
	char buf[128];
	dev_t temp;
	struct device *bootdv;
	struct bootpath *bp;
#if defined(NFSCLIENT)
	extern char *nfsbootdevname;
#endif

#ifdef RAMDISK_HOOKS
	bootdv = &fakerdrootdev;
#else
	bootdv = booted_device;
#endif

	/*
	 * (raid) device auto-configuration could have returned
	 * the root device's id in rootdev.  Check this case.
	 */
	if (rootdev != NODEV) {
		majdev = major(rootdev);
		unit = DISKUNIT(rootdev);
		part = DISKPART(rootdev);

		len = snprintf(buf, sizeof buf, "%s%d", findblkname(majdev),
			unit);
		if (len >= sizeof(buf))
			panic("setroot: device name too long");

		bootdv = getdisk(buf, len, part, &rootdev);
	}

	/*
	 * If `swap generic' and we couldn't determine boot device,
	 * ask the user.
	 */
	if (mountroot == NULL && bootdv == NULL)
		boothowto |= RB_ASKNAME;

	if (boothowto & RB_ASKNAME) {
		for (;;) {
			printf("root device ");
			if (bootdv != NULL)
				printf("(default %s%c)",
					bootdv->dv_xname,
					bootdv->dv_class == DV_DISK
						? booted_partition + 'a' : ' ');
			printf(": ");
			len = getstr(buf, sizeof(buf));
			if (len == 0 && bootdv != NULL) {
				strlcpy(buf, bootdv->dv_xname, sizeof buf);
				len = strlen(buf);
			}
			if (len > 0 && buf[len - 1] == '*') {
				buf[--len] = '\0';
				dv = getdisk(buf, len, 1, &nrootdev);
				if (dv != NULL) {
					bootdv = dv;
					nswapdev = nrootdev;
					goto gotswap;
				}
			}
			if (len == 4 && strncmp(buf, "exit", 4) == 0)
				boot(RB_HALT);
			dv = getdisk(buf, len, bp ? booted_partition : 0,
			    &nrootdev);
			if (dv != NULL) {
				bootdv = dv;
				break;
			}
		}

		/*
		 * because swap must be on same device as root, for
		 * network devices this is easy.
		 */
		if (bootdv->dv_class == DV_IFNET) {
			goto gotswap;
		}
		for (;;) {
			printf("swap device ");
			if (bootdv != NULL)
				printf("(default %s%c)",
					bootdv->dv_xname,
					bootdv->dv_class == DV_DISK?'b':' ');
			printf(": ");
			len = getstr(buf, sizeof(buf));
			if (len == 0 && bootdv != NULL) {
				switch (bootdv->dv_class) {
				case DV_IFNET:
					nswapdev = NODEV;
					break;
				case DV_DISK:
					nswapdev = MAKEDISKDEV(major(nrootdev),
					    DISKUNIT(nrootdev), 1);
					break;
				case DV_TAPE:
				case DV_TTY:
				case DV_DULL:
				case DV_CPU:
					break;
				}
				break;
			}
			if (len == 4 && strncmp(buf, "exit", 4) == 0)
				boot(RB_HALT);
			dv = getdisk(buf, len, 1, &nswapdev);
			if (dv) {
				if (dv->dv_class == DV_IFNET)
					nswapdev = NODEV;
				break;
			}
		}
gotswap:
		rootdev = nrootdev;
		dumpdev = nswapdev;
		swdevt[0].sw_dev = nswapdev;
		swdevt[1].sw_dev = NODEV;

	} else if (mountroot == NULL) {

		/*
		 * `swap generic': Use the device the ROM told us to use.
		 */
		majdev = findblkmajor(bootdv);
		if (majdev >= 0) {
			/*
			 * Root and swap are on a disk.
			 * val[2] of the boot device is the partition number.
			 * Assume swap is on partition b.
			 */
			part = booted_partition;
			unit = bootdv->dv_unit;
			rootdev = MAKEDISKDEV(majdev, unit, part);
			nswapdev = dumpdev = MAKEDISKDEV(major(rootdev),
			    DISKUNIT(rootdev), 1);
		} else {
			/*
			 * Root and swap are on a net.
			 */
			nswapdev = dumpdev = NODEV;
		}
		swdevt[0].sw_dev = nswapdev;
		/* swdevt[1].sw_dev = NODEV; */

	} else {

		/*
		 * `root DEV swap DEV': honour rootdev/swdevt.
		 * rootdev/swdevt/mountroot already properly set.
		 */
		if (bootdv->dv_class == DV_DISK)
			printf("root on %s%c\n", bootdv->dv_xname,
			    part + 'a');
		majdev = major(rootdev);
		unit = DISKUNIT(rootdev);
		part = DISKPART(rootdev);
		return;
	}

	switch (bootdv->dv_class) {
#if defined(NFSCLIENT)
	case DV_IFNET:
		mountroot = nfs_mountroot;
		nfsbootdevname = bootdv->dv_xname;
		return;
#endif
	case DV_DISK:
		mountroot = dk_mountroot;
		majdev = major(rootdev);
		unit = DISKUNIT(rootdev);
		part = DISKPART(rootdev);
		printf("root on %s%c\n", bootdv->dv_xname,
		    part + 'a');
		break;
	default:
		printf("can't figure root, hope your kernel is right\n");
		return;
	}

	/*
	 * Make the swap partition on the root drive the primary swap.
	 */
	temp = NODEV;
	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		if (majdev == major(swp->sw_dev) &&
		    unit == DISKUNIT(swp->sw_dev)) {
			temp = swdevt[0].sw_dev;
			swdevt[0].sw_dev = swp->sw_dev;
			swp->sw_dev = temp;
			break;
		}
	}
	if (swp->sw_dev != NODEV) {
		/*
		 * If dumpdev was the same as the old primary swap device,
		 * move it to the new primary swap device.
		 */
		if (temp == dumpdev)
			dumpdev = swdevt[0].sw_dev;
	}
}

void
a170 27
static struct device *
getdisk(str, len, defpart, devp)
	char *str;
	int len, defpart;
	dev_t *devp;
{
	struct device *dv;

	if ((dv = parsedisk(str, len, defpart, devp)) == NULL) {
		printf("use one of: exit");
#ifdef RAMDISK_HOOKS
		printf(" %s[a-p]", fakerdrootdev.dv_xname);
#endif
		for (dv = alldevs.tqh_first; dv != NULL;
		    dv = dv->dv_list.tqe_next) {        
			if (dv->dv_class == DV_DISK)
				printf(" %s[a-p]", dv->dv_xname);
#ifdef NFSCLIENT
			if (dv->dv_class == DV_IFNET)
				printf(" %s", dv->dv_xname);
#endif
		}
		printf("\n");
	}
	return (dv);
}

a223 46
static int
getstr(cp, size)
	char *cp;
	int size;
{
	char *lp;
	int c;
	int len;

	lp = cp;
	len = 0;
	for (;;) {
		c = cngetc();
		switch (c) {
		case '\n':
		case '\r':
			printf("\n");
			*lp++ = '\0';
			return (len);
		case '\b':
		case '\177':
		case '#':
			if (len) {
				--len;
				--lp;
				printf("\b \b");
			}
			continue;
		case '@@':
		case 'u'&037:
			len = 0;
			lp = cp;
			printf("\n");
			continue;
		default:
			if (len + 1 >= size || c < ' ') {
				printf("\007");
				continue;
			}
			printf("%c", c);
			++len;
			*lp++ = c;
		}
	}
}

d257 217
@


1.4.2.1
log
@The merge of these files were done to another date than the rest, fix.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d104 4
d120 2
a124 2
	startrtclock();

d511 1
@


1.4.2.2
log
@Merge with the trunk
@
text
@a80 1
void rootconf(void);
d85 1
d87 4
d102 1
a102 5
dev_t bootdev = 0;

#ifdef RAMDISK_HOOKS
static struct device fakerdrootdev = { DV_DISK, {}, NULL, 0, "rd0", NULL };
#endif
a115 2
	startrtclock();

d119 2
d142 1
a142 4
	/* Checksum disks, same as /boot did, then fixup *dev vars */
	dkcsumattach();

	rootconf();
d148 209
d374 27
d454 46
a506 1
	{ "rd",		17 },	/* 17 = rd */
a531 217
}

/* Code from here to handle "bsd swap generic" */

dev_t	argdev = NODEV;

/*
 * Attempt to find the device from which we were booted.
 * If we can do so, and not instructed not to do so,
 * change rootdev to correspond to the load device.
 */
void
setroot()
{
	int  majdev, mindev, unit, part, adaptor;
	dev_t orootdev;
#ifdef DOSWAP
	dev_t temp = 0;
	struct swdevt *swp;
#endif

	if (boothowto & RB_DFLTROOT ||
	    (bootdev & B_MAGICMASK) != (u_long)B_DEVMAGIC)
		return;
	majdev = B_TYPE(bootdev);
	if (findblkname(majdev) == NULL)
		return;
	adaptor = B_ADAPTOR(bootdev);
	part = B_PARTITION(bootdev);
	unit = B_UNIT(bootdev);
	mindev = (unit * MAXPARTITIONS) + part;
	orootdev = rootdev;
	rootdev = makedev(majdev, mindev);
	/*
	 * If the original rootdev is the same as the one
	 * just calculated, don't need to adjust the swap configuration.
	 */
	printf("root on %s%d%c\n", findblkname(majdev), unit, part + 'a');
	if (rootdev == orootdev)
		return;

#ifdef DOSWAP
	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		if (majdev == major(swp->sw_dev) &&
		    mindev/MAXPARTITIONS == minor(swp->sw_dev)/MAXPARTITIONS) {
			temp = swdevt[0].sw_dev;
			swdevt[0].sw_dev = swp->sw_dev;
			swp->sw_dev = temp;
			break;
		}
	}
	if (swp->sw_dev == NODEV)
		return;

	/*
	 * If dumpdev was the same as the old primary swap device, move
	 * it to the new primary swap device.
	 */
	if (temp == dumpdev)
		dumpdev = swdevt[0].sw_dev;
#endif
}

#include "wd.h"
#if NWD > 0
extern	struct cfdriver wd_cd;
#endif
#include "sd.h"
#if NSD > 0
extern	struct cfdriver sd_cd;
#endif
#include "cd.h"
#if NCD > 0
extern	struct cfdriver cd_cd;
#endif
#include "mcd.h"
#if NMCD > 0
extern	struct cfdriver mcd_cd;
#endif
#include "fd.h"
#if NFD > 0
extern	struct cfdriver fd_cd;
#endif
#include "rd.h"
#if NRD > 0
extern	struct cfdriver rd_cd;
#endif
#include "raid.h"
#if NRAID > 0
extern	struct cfdriver raid_cd;
#endif

struct	genericconf {
	struct cfdriver *gc_driver;
	char *gc_name;
	dev_t gc_major;
} genericconf[] = {
#if NWD > 0
	{ &wd_cd,  "wd",  0 },
#endif
#if NFD > 0
	{ &fd_cd,  "fd",  2 },
#endif
#if NSD > 0
	{ &sd_cd,  "sd",  4 },
#endif
#if NCD > 0
	{ &cd_cd,  "cd",  6 },
#endif
#if NMCD > 0
	{ &mcd_cd, "mcd", 7 },
#endif
#if NRD > 0
	{ &rd_cd,  "rd",  17 },
#endif
#if NRAID > 0
	{ &raid_cd,  "raid",  19 },
#endif
	{ 0 }
};

void
rootconf()
{
	register struct genericconf *gc;
	int unit, part = 0;
	char *num;

#ifdef INSTALL
	if (B_TYPE(bootdev) == 2) {
		printf("\n\nInsert file system floppy...\n");
		if (!(boothowto & RB_ASKNAME))
			cngetc();
	}
#endif

	if (boothowto & RB_ASKNAME) {
		char name[128];
retry:
		printf("root device? ");
		cnpollc(TRUE);
		getsn(name, sizeof name);
		cnpollc(FALSE);
		if (*name == '\0')
			goto noask;
		for (gc = genericconf; gc->gc_driver; gc++)
			if (gc->gc_driver->cd_ndevs &&
			    strncmp(gc->gc_name, name,
			    strlen(gc->gc_name)) == 0)
				break;
		if (gc->gc_driver) {
			num = &name[strlen(gc->gc_name)];

			unit = -2;
			do {
				if (unit != -2 && *num >= 'a' &&
				    *num <= 'a'+MAXPARTITIONS-1 &&
				    num[1] == '\0') {
					part = *num++ - 'a';
					break;
				}
				if (unit == -2)
					unit = 0;
				unit = (unit * 10) + *num - '0';
				if (*num < '0' || *num > '9')
					unit = -1;
			} while (unit != -1 && *++num);

			if (unit < 0) {
				printf("%s: not a unit number\n",
				    &name[strlen(gc->gc_name)]);
			} else if (unit > gc->gc_driver->cd_ndevs ||
			    gc->gc_driver->cd_devs[unit] == NULL) {
				printf("%d: no such unit\n", unit);
			} else {
				printf("root on %s%d%c\n", gc->gc_name, unit,
				    'a' + part);
				rootdev = makedev(gc->gc_major,
				    unit * MAXPARTITIONS + part);
				goto doswap;
			}
		}
		printf("use one of: ");
		for (gc = genericconf; gc->gc_driver; gc++) {
			for (unit=0; unit < gc->gc_driver->cd_ndevs; unit++) {
				if (gc->gc_driver->cd_devs[unit])
					printf("%s%d[a-%c] ", gc->gc_name,
					    unit, 'a'+MAXPARTITIONS-1);
			}
		}
		printf("\n");
		goto retry;
	}
noask:
	if (mountroot == NULL) {
		/* `swap generic' */
		setroot();
	} else {
		/* preconfigured */
		int  majdev, unit, part;

		majdev = major(rootdev);
		if (findblkname(majdev) == NULL)
			return;
		part = minor(rootdev) % MAXPARTITIONS;
		unit = minor(rootdev) / MAXPARTITIONS;
		printf("root on %s%d%c\n", findblkname(majdev), unit, part + 'a');
		return;
	}

doswap:
#ifndef DISKLESS
	mountroot = dk_mountroot;
#endif
	swdevt[0].sw_dev = argdev = dumpdev =
	    makedev(major(rootdev), minor(rootdev) + 1);
	/* swap size and dumplo set during autoconfigure */
@


1.3
log
@correct ramdisk support
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.2 2004/02/03 12:09:47 mickey Exp $	*/
d120 2
a123 2

	startrtclock();
@


1.2
log
@das boot; das cloned das from das i386
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.1 2004/01/28 01:39:38 mickey Exp $	*/
d104 4
d511 1
@


1.1
log
@an amd64 arch support.
hacked by art@@ from netbsd sources and then later debugged
by me into the shape where it can host itself.
no bootloader yet as needs redoing from the
recent advanced i386 sources (anyone? ;)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a65 1
#include <machine/bootinfo.h>
d102 1
a141 1
printf("setroot\n");
a142 1
printf("swapconf\n");
a143 1
printf("dumpconf\n");
a497 71
}

#include "pci.h"

#include <dev/isa/isavar.h>
#if NPCI > 0
#include <dev/pci/pcivar.h>
#endif

void
device_register(struct device *dev, void *aux)
{
	/*
	 * Handle network interfaces here, the attachment information is
	 * not available driver independantly later.
	 * For disks, there is nothing useful available at attach time.
	 */
	if (dev->dv_class == DV_IFNET) {
		struct btinfo_netif *bin = lookup_bootinfo(BTINFO_NETIF);
		if (bin == NULL)
			return;

		/*
		 * We don't check the driver name against the device name
		 * passed by the boot ROM. The ROM should stay usable
		 * if the driver gets obsoleted.
		 * The physical attachment information (checked below)
		 * must be sufficient to identify the device.
		 */

		if (bin->bus == BI_BUS_ISA &&
		    !strcmp(dev->dv_parent->dv_cfdata->cf_driver->cd_name,
		    "isa")) {
			struct isa_attach_args *iaa = aux;

			/* compare IO base address */
			/* XXXJRT what about multiple I/O addrs? */
			if (iaa->ipa_nio > 0 &&
			    bin->addr.iobase == iaa->ipa_io[0].base)
				goto found;
		}
#if NPCI > 0
		if (bin->bus == BI_BUS_PCI &&
		    !strcmp(dev->dv_parent->dv_cfdata->cf_driver->cd_name,
		    "pci")) {
			struct pci_attach_args *paa = aux;
			int b, d, f;

			/*
			 * Calculate BIOS representation of:
			 *
			 *	<bus,device,function>
			 *
			 * and compare.
			 */
			pci_decompose_tag(paa->pa_pc, paa->pa_tag, &b, &d, &f);
			if (bin->addr.tag == ((b << 8) | (d << 3) | f))
				goto found;
		}
#endif
	}
	return;

found:
	if (booted_device) {
		/* XXX should be a "panic()" */
		printf("warning: double match for boot device (%s, %s)\n",
		    booted_device->dv_xname, dev->dv_xname);
		return;
	}
	booted_device = dev;
@

