head	1.26;
access;
symbols
	OPENBSD_6_2_BASE:1.26
	OPENBSD_6_1:1.26.0.10
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.26.0.6
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.26.0.4
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.23.0.4
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.22.0.8
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.4
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.2
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.20.0.2
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.4
	OPENBSD_5_0:1.19.0.2
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.18.0.2
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.17.0.2
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.14.0.4
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.9.0.2
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.8.0.2
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.6.0.2
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.4.0.2
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.3.0.2
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.4
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.1.0.10
	OPENBSD_3_8_BASE:1.1
	OPENBSD_3_7:1.1.0.8
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.6
	OPENBSD_3_6_BASE:1.1
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	OPENBSD_3_5:1.1.0.4
	OPENBSD_3_5_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.26
date	2015.04.25.21.31.24;	author guenther;	state Exp;
branches;
next	1.25;
commitid	Jx2fq8kp0uEBpslo;

1.25
date	2014.11.16.12.30.56;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	yv0ECmCdICvq576h;

1.24
date	2014.10.25.16.57.58;	author kettenis;	state Exp;
branches;
next	1.23;
commitid	Zy0HwEHBV8xYYhHT;

1.23
date	2014.03.29.18.09.28;	author guenther;	state Exp;
branches;
next	1.22;

1.22
date	2013.01.18.01.54.40;	author dlg;	state Exp;
branches;
next	1.21;

1.21
date	2013.01.15.09.33.30;	author dlg;	state Exp;
branches;
next	1.20;

1.20
date	2012.05.23.08.23.43;	author mikeb;	state Exp;
branches;
next	1.19;

1.19
date	2011.04.09.21.30.27;	author jsg;	state Exp;
branches;
next	1.18;

1.18
date	2010.12.26.15.40.59;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2010.05.08.16.54.07;	author oga;	state Exp;
branches;
next	1.16;

1.16
date	2010.04.04.12.49.29;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2009.08.11.17.15.54;	author oga;	state Exp;
branches;
next	1.14;

1.14
date	2009.05.31.19.41.57;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2009.03.26.19.04.56;	author oga;	state Exp;
branches;
next	1.12;

1.12
date	2009.03.10.15.03.16;	author oga;	state Exp;
branches;
next	1.11;

1.11
date	2008.12.03.15.46.06;	author oga;	state Exp;
branches;
next	1.10;

1.10
date	2008.11.21.23.16.16;	author oga;	state Exp;
branches;
next	1.9;

1.9
date	2008.06.26.05.42.09;	author ray;	state Exp;
branches;
next	1.8;

1.8
date	2007.11.16.16.16.06;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2007.08.31.20.11.09;	author marco;	state Exp;
branches;
next	1.6;

1.6
date	2007.05.27.08.59.25;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2007.05.25.16.22.11;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2007.01.15.23.19.05;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.26.18.46.06;	author martin;	state Exp;
branches;
next	1.2;

1.2
date	2005.10.21.18.55.00;	author martin;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.28.01.39.38;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.26
log
@We now following the ABI and always clear cld on function entry, so remove
the extra CLD instructions from when that wasn't true

testing miod@@ krw@@
@
text
@/*	$OpenBSD: bus_space.c,v 1.25 2014/11/16 12:30:56 deraadt Exp $	*/
/*	$NetBSD: bus_space.c,v 1.2 2003/03/14 18:47:53 christos Exp $	*/

/*-
 * Copyright (c) 1996, 1997, 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Charles M. Hannum and by Jason R. Thorpe of the Numerical Aerospace
 * Simulation Facility, NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/extent.h>

#include <uvm/uvm_extern.h>

#include <machine/bus.h>

#include <dev/isa/isareg.h>
#include <machine/isa_machdep.h>

/*
 * Extent maps to manage I/O and memory space.  Allocate
 * storage for 16 regions in each, initially.  Later, ioport_malloc_safe
 * will indicate that it's safe to use malloc() to dynamically allocate
 * region descriptors.
 *
 * N.B. At least two regions are _always_ allocated from the iomem
 * extent map; (0 -> ISA hole) and (end of ISA hole -> end of RAM).
 *
 * The extent maps are not static!  Machine-dependent ISA and EISA
 * routines need access to them for bus address space allocation.
 */
static	long ioport_ex_storage[EXTENT_FIXED_STORAGE_SIZE(16) / sizeof(long)];
static	long iomem_ex_storage[EXTENT_FIXED_STORAGE_SIZE(16) / sizeof(long)];
struct	extent *ioport_ex;
struct	extent *iomem_ex;
static	int ioport_malloc_safe;

int	x86_mem_add_mapping(bus_addr_t, bus_size_t,
	    int, bus_space_handle_t *);

u_int8_t	x86_bus_space_io_read_1(bus_space_handle_t, bus_size_t);
u_int16_t	x86_bus_space_io_read_2(bus_space_handle_t, bus_size_t);
u_int32_t	x86_bus_space_io_read_4(bus_space_handle_t, bus_size_t);
u_int64_t	x86_bus_space_io_read_8(bus_space_handle_t, bus_size_t);

void		x86_bus_space_io_read_multi_1(bus_space_handle_t, bus_size_t,
		    u_int8_t *, bus_size_t);
void		x86_bus_space_io_read_multi_2(bus_space_handle_t, bus_size_t,
		    u_int16_t *, bus_size_t);
void		x86_bus_space_io_read_multi_4(bus_space_handle_t, bus_size_t,
		    u_int32_t *, bus_size_t);
void		x86_bus_space_io_read_multi_8(bus_space_handle_t, bus_size_t,
		    u_int64_t *, bus_size_t);

void		x86_bus_space_io_read_region_1(bus_space_handle_t, bus_size_t,
		    u_int8_t *, bus_size_t);
void		x86_bus_space_io_read_region_2(bus_space_handle_t, bus_size_t,
		    u_int16_t *, bus_size_t);
void		x86_bus_space_io_read_region_4(bus_space_handle_t, bus_size_t,
		    u_int32_t *, bus_size_t);
void		x86_bus_space_io_read_region_8(bus_space_handle_t, bus_size_t,
		    u_int64_t *, bus_size_t);

void		x86_bus_space_io_write_1(bus_space_handle_t, bus_size_t,
		    u_int8_t);
void		x86_bus_space_io_write_2(bus_space_handle_t, bus_size_t,
		    u_int16_t);
void		x86_bus_space_io_write_4(bus_space_handle_t, bus_size_t,
		    u_int32_t);
void		x86_bus_space_io_write_8(bus_space_handle_t, bus_size_t,
		    u_int64_t);

void		x86_bus_space_io_write_multi_1(bus_space_handle_t,
		    bus_size_t, const u_int8_t *, bus_size_t);
void		x86_bus_space_io_write_multi_2(bus_space_handle_t,
		    bus_size_t, const u_int16_t *, bus_size_t);
void		x86_bus_space_io_write_multi_4(bus_space_handle_t,
		    bus_size_t, const u_int32_t *, bus_size_t);
void		x86_bus_space_io_write_multi_8(bus_space_handle_t,
		    bus_size_t, const u_int64_t *, bus_size_t);

void		x86_bus_space_io_write_region_1(bus_space_handle_t,
		    bus_size_t, const u_int8_t *, bus_size_t);
void		x86_bus_space_io_write_region_2(bus_space_handle_t,
		    bus_size_t, const u_int16_t *, bus_size_t);
void		x86_bus_space_io_write_region_4(bus_space_handle_t,
		    bus_size_t, const u_int32_t *, bus_size_t);
void		x86_bus_space_io_write_region_8(bus_space_handle_t,
		    bus_size_t, const u_int64_t *, bus_size_t);

void		x86_bus_space_io_set_multi_1(bus_space_handle_t, bus_size_t,
		    u_int8_t, size_t);
void		x86_bus_space_io_set_multi_2(bus_space_handle_t, bus_size_t,
		    u_int16_t, size_t);
void		x86_bus_space_io_set_multi_4(bus_space_handle_t, bus_size_t,
		    u_int32_t, size_t);
void		x86_bus_space_io_set_multi_8(bus_space_handle_t, bus_size_t,
		    u_int64_t, size_t);

void		x86_bus_space_io_set_region_1(bus_space_handle_t, bus_size_t,
		    u_int8_t, size_t);
void		x86_bus_space_io_set_region_2(bus_space_handle_t, bus_size_t,
		    u_int16_t, size_t);
void		x86_bus_space_io_set_region_4(bus_space_handle_t, bus_size_t,
		    u_int32_t, size_t);
void		x86_bus_space_io_set_region_8(bus_space_handle_t, bus_size_t,
		    u_int64_t, size_t);

void		x86_bus_space_io_copy_1(bus_space_handle_t, bus_size_t,
		    bus_space_handle_t, bus_size_t, size_t);
void		x86_bus_space_io_copy_2(bus_space_handle_t, bus_size_t,
		    bus_space_handle_t, bus_size_t, size_t);
void		x86_bus_space_io_copy_4(bus_space_handle_t, bus_size_t,
		    bus_space_handle_t, bus_size_t, size_t);
void		x86_bus_space_io_copy_8(bus_space_handle_t, bus_size_t,
		    bus_space_handle_t, bus_size_t, size_t);

void *		x86_bus_space_io_vaddr(bus_space_handle_t);
paddr_t		x86_bus_space_io_mmap(bus_addr_t, off_t, int, int);

const struct x86_bus_space_ops x86_bus_space_io_ops = {
	x86_bus_space_io_read_1,
	x86_bus_space_io_read_2,
	x86_bus_space_io_read_4,
	x86_bus_space_io_read_8,
	x86_bus_space_io_read_multi_1,
	x86_bus_space_io_read_multi_2,
	x86_bus_space_io_read_multi_4,
	x86_bus_space_io_read_multi_8,
	x86_bus_space_io_read_region_1,
	x86_bus_space_io_read_region_2,
	x86_bus_space_io_read_region_4,
	x86_bus_space_io_read_region_8,
	x86_bus_space_io_write_1,
	x86_bus_space_io_write_2,
	x86_bus_space_io_write_4,
	x86_bus_space_io_write_8,
	x86_bus_space_io_write_multi_1,
	x86_bus_space_io_write_multi_2,
	x86_bus_space_io_write_multi_4,
	x86_bus_space_io_write_multi_8,
	x86_bus_space_io_write_region_1,
	x86_bus_space_io_write_region_2,
	x86_bus_space_io_write_region_4,
	x86_bus_space_io_write_region_8,
	x86_bus_space_io_set_multi_1,
	x86_bus_space_io_set_multi_2,
	x86_bus_space_io_set_multi_4,
	x86_bus_space_io_set_multi_8,
	x86_bus_space_io_set_region_1,
	x86_bus_space_io_set_region_2,
	x86_bus_space_io_set_region_4,
	x86_bus_space_io_set_region_8,
	x86_bus_space_io_copy_1,
	x86_bus_space_io_copy_2,
	x86_bus_space_io_copy_4,
	x86_bus_space_io_copy_8,
	x86_bus_space_io_vaddr,
	x86_bus_space_io_mmap
};

u_int8_t	x86_bus_space_mem_read_1(bus_space_handle_t, bus_size_t);
u_int16_t	x86_bus_space_mem_read_2(bus_space_handle_t, bus_size_t);
u_int32_t	x86_bus_space_mem_read_4(bus_space_handle_t, bus_size_t);
u_int64_t	x86_bus_space_mem_read_8(bus_space_handle_t, bus_size_t);

void		x86_bus_space_mem_read_multi_1(bus_space_handle_t, bus_size_t,
		    u_int8_t *, bus_size_t);
void		x86_bus_space_mem_read_multi_2(bus_space_handle_t, bus_size_t,
		    u_int16_t *, bus_size_t);
void		x86_bus_space_mem_read_multi_4(bus_space_handle_t, bus_size_t,
		    u_int32_t *, bus_size_t);
void		x86_bus_space_mem_read_multi_8(bus_space_handle_t, bus_size_t,
		    u_int64_t *, bus_size_t);

void		x86_bus_space_mem_read_region_1(bus_space_handle_t, bus_size_t,
		    u_int8_t *, bus_size_t);
void		x86_bus_space_mem_read_region_2(bus_space_handle_t, bus_size_t,
		    u_int16_t *, bus_size_t);
void		x86_bus_space_mem_read_region_4(bus_space_handle_t, bus_size_t,
		    u_int32_t *, bus_size_t);
void		x86_bus_space_mem_read_region_8(bus_space_handle_t, bus_size_t,
		    u_int64_t *, bus_size_t);

void		x86_bus_space_mem_write_1(bus_space_handle_t, bus_size_t,
		    u_int8_t);
void		x86_bus_space_mem_write_2(bus_space_handle_t, bus_size_t,
		    u_int16_t);
void		x86_bus_space_mem_write_4(bus_space_handle_t, bus_size_t,
		    u_int32_t);
void		x86_bus_space_mem_write_8(bus_space_handle_t, bus_size_t,
		    u_int64_t);

void		x86_bus_space_mem_write_multi_1(bus_space_handle_t,
		    bus_size_t, const u_int8_t *, bus_size_t);
void		x86_bus_space_mem_write_multi_2(bus_space_handle_t,
		    bus_size_t, const u_int16_t *, bus_size_t);
void		x86_bus_space_mem_write_multi_4(bus_space_handle_t,
		    bus_size_t, const u_int32_t *, bus_size_t);
void		x86_bus_space_mem_write_multi_8(bus_space_handle_t,
		    bus_size_t, const u_int64_t *, bus_size_t);

void		x86_bus_space_mem_write_region_1(bus_space_handle_t,
		    bus_size_t, const u_int8_t *, bus_size_t);
void		x86_bus_space_mem_write_region_2(bus_space_handle_t,
		    bus_size_t, const u_int16_t *, bus_size_t);
void		x86_bus_space_mem_write_region_4(bus_space_handle_t,
		    bus_size_t, const u_int32_t *, bus_size_t);
void		x86_bus_space_mem_write_region_8(bus_space_handle_t,
		    bus_size_t, const u_int64_t *, bus_size_t);

void		x86_bus_space_mem_set_multi_1(bus_space_handle_t, bus_size_t,
		    u_int8_t, size_t);
void		x86_bus_space_mem_set_multi_2(bus_space_handle_t, bus_size_t,
		    u_int16_t, size_t);
void		x86_bus_space_mem_set_multi_4(bus_space_handle_t, bus_size_t,
		    u_int32_t, size_t);
void		x86_bus_space_mem_set_multi_8(bus_space_handle_t, bus_size_t,
		    u_int64_t, size_t);

void		x86_bus_space_mem_set_region_1(bus_space_handle_t, bus_size_t,
		    u_int8_t, size_t);
void		x86_bus_space_mem_set_region_2(bus_space_handle_t, bus_size_t,
		    u_int16_t, size_t);
void		x86_bus_space_mem_set_region_4(bus_space_handle_t, bus_size_t,
		    u_int32_t, size_t);
void		x86_bus_space_mem_set_region_8(bus_space_handle_t, bus_size_t,
		    u_int64_t, size_t);

void		x86_bus_space_mem_copy_1(bus_space_handle_t, bus_size_t,
		    bus_space_handle_t, bus_size_t, size_t);
void		x86_bus_space_mem_copy_2(bus_space_handle_t, bus_size_t,
		    bus_space_handle_t, bus_size_t, size_t);
void		x86_bus_space_mem_copy_4(bus_space_handle_t, bus_size_t,
		    bus_space_handle_t, bus_size_t, size_t);
void		x86_bus_space_mem_copy_8(bus_space_handle_t, bus_size_t,
		    bus_space_handle_t, bus_size_t, size_t);

void *		x86_bus_space_mem_vaddr(bus_space_handle_t);

paddr_t		x86_bus_space_mem_mmap(bus_addr_t, off_t, int, int);

const struct x86_bus_space_ops x86_bus_space_mem_ops = {
	x86_bus_space_mem_read_1,
	x86_bus_space_mem_read_2,
	x86_bus_space_mem_read_4,
	x86_bus_space_mem_read_8,
	x86_bus_space_mem_read_multi_1,
	x86_bus_space_mem_read_multi_2,
	x86_bus_space_mem_read_multi_4,
	x86_bus_space_mem_read_multi_8,
	x86_bus_space_mem_read_region_1,
	x86_bus_space_mem_read_region_2,
	x86_bus_space_mem_read_region_4,
	x86_bus_space_mem_read_region_8,
	x86_bus_space_mem_write_1,
	x86_bus_space_mem_write_2,
	x86_bus_space_mem_write_4,
	x86_bus_space_mem_write_8,
	x86_bus_space_mem_write_multi_1,
	x86_bus_space_mem_write_multi_2,
	x86_bus_space_mem_write_multi_4,
	x86_bus_space_mem_write_multi_8,
	x86_bus_space_mem_write_region_1,
	x86_bus_space_mem_write_region_2,
	x86_bus_space_mem_write_region_4,
	x86_bus_space_mem_write_region_8,
	x86_bus_space_mem_set_multi_1,
	x86_bus_space_mem_set_multi_2,
	x86_bus_space_mem_set_multi_4,
	x86_bus_space_mem_set_multi_8,
	x86_bus_space_mem_set_region_1,
	x86_bus_space_mem_set_region_2,
	x86_bus_space_mem_set_region_4,
	x86_bus_space_mem_set_region_8,
	x86_bus_space_mem_copy_1,
	x86_bus_space_mem_copy_2,
	x86_bus_space_mem_copy_4,
	x86_bus_space_mem_copy_8,
	x86_bus_space_mem_vaddr,
	x86_bus_space_mem_mmap
};

void
x86_bus_space_init(void)
{
	/*
	 * Initialize the I/O port and I/O mem extent maps.
	 * Note: we don't have to check the return value since
	 * creation of a fixed extent map will never fail (since
	 * descriptor storage has already been allocated).
	 *
	 * N.B. The iomem extent manages _all_ physical addresses
	 * on the machine.  When the amount of RAM is found, the two
	 * extents of RAM are allocated from the map (0 -> ISA hole
	 * and end of ISA hole -> end of RAM).
	 */
	ioport_ex = extent_create("ioport", 0x0, 0xffff, M_DEVBUF,
	    (caddr_t)ioport_ex_storage, sizeof(ioport_ex_storage),
	    EX_NOCOALESCE|EX_NOWAIT);
	iomem_ex = extent_create("iomem", 0x0, 0xffffffffffff, M_DEVBUF,
	    (caddr_t)iomem_ex_storage, sizeof(iomem_ex_storage),
	    EX_NOCOALESCE|EX_NOWAIT);
}

void
x86_bus_space_mallocok(void)
{
	ioport_malloc_safe = 1;
}

int
bus_space_map(bus_space_tag_t t, bus_addr_t bpa, bus_size_t size, int flags,
    bus_space_handle_t *bshp)
{
	int error;
	struct extent *ex;

	/*
	 * Pick the appropriate extent map.
	 */
	if (t == X86_BUS_SPACE_IO) {
		ex = ioport_ex;
		if (flags & BUS_SPACE_MAP_LINEAR)
			return (EINVAL);
	} else if (t == X86_BUS_SPACE_MEM)
		ex = iomem_ex;
	else
		panic("bus_space_map: bad bus space tag");

	/*
	 * Before we go any further, let's make sure that this
	 * region is available.
	 */
	error = extent_alloc_region(ex, bpa, size,
	    EX_NOWAIT | (ioport_malloc_safe ? EX_MALLOCOK : 0));
	if (error)
		return (error);

	/*
	 * For I/O space, that's all she wrote.
	 */
	if (t == X86_BUS_SPACE_IO) {
		*bshp = bpa;
		return (0);
	}

	if (bpa >= IOM_BEGIN && (bpa + size) <= IOM_END) {
		*bshp = (bus_space_handle_t)ISA_HOLE_VADDR(bpa);
		return(0);
	}

	/*
	 * For memory space, map the bus physical address to
	 * a kernel virtual address.
	 */
	error = x86_mem_add_mapping(bpa, size, flags, bshp);
	if (error) {
		if (extent_free(ex, bpa, size, EX_NOWAIT |
		    (ioport_malloc_safe ? EX_MALLOCOK : 0))) {
			printf("bus_space_map: pa 0x%lx, size 0x%lx\n",
			    bpa, size);
			printf("bus_space_map: can't free region\n");
		}
	}

	return (error);
}

int
_bus_space_map(bus_space_tag_t t, bus_addr_t bpa, bus_size_t size, int flags,
    bus_space_handle_t *bshp)
{

	/*
	 * For I/O space, just fill in the handle.
	 */
	if (t == X86_BUS_SPACE_IO) {
		*bshp = bpa;
		return (0);
	}

	/*
	 * For memory space, map the bus physical address to
	 * a kernel virtual address.
	 */
	return (x86_mem_add_mapping(bpa, size, flags, bshp));
}

int
bus_space_alloc(bus_space_tag_t t, bus_addr_t rstart, bus_addr_t rend,
    bus_size_t size, bus_size_t alignment, bus_size_t boundary, int flags,
    bus_addr_t *bpap, bus_space_handle_t *bshp)
{
	struct extent *ex;
	u_long bpa;
	int error;

	/*
	 * Pick the appropriate extent map.
	 */
	if (t == X86_BUS_SPACE_IO) {
		ex = ioport_ex;
	} else if (t == X86_BUS_SPACE_MEM)
		ex = iomem_ex;
	else
		panic("bus_space_alloc: bad bus space tag");

	/*
	 * Sanity check the allocation against the extent's boundaries.
	 */
	if (rstart < ex->ex_start || rend > ex->ex_end)
		panic("bus_space_alloc: bad region start/end");

	/*
	 * Do the requested allocation.
	 */
	error = extent_alloc_subregion(ex, rstart, rend, size, alignment,
	    0, boundary,
	    EX_FAST | EX_NOWAIT | (ioport_malloc_safe ?  EX_MALLOCOK : 0),
	    &bpa);

	if (error)
		return (error);

	/*
	 * For I/O space, that's all she wrote.
	 */
	if (t == X86_BUS_SPACE_IO) {
		*bshp = *bpap = bpa;
		return (0);
	}

	/*
	 * For memory space, map the bus physical address to
	 * a kernel virtual address.
	 */
	error = x86_mem_add_mapping(bpa, size, flags, bshp);
	if (error) {
		if (extent_free(iomem_ex, bpa, size, EX_NOWAIT |
		    (ioport_malloc_safe ? EX_MALLOCOK : 0))) {
			printf("bus_space_alloc: pa 0x%lx, size 0x%lx\n",
			    bpa, size);
			printf("bus_space_alloc: can't free region\n");
		}
	}

	*bpap = bpa;

	return (error);
}

int
x86_mem_add_mapping(bus_addr_t bpa, bus_size_t size, int flags,
    bus_space_handle_t *bshp)
{
	paddr_t pa, endpa;
	vaddr_t va;
	bus_size_t map_size;
	int pmap_flags = PMAP_NOCACHE;

	pa = trunc_page(bpa);
	endpa = round_page(bpa + size);

#ifdef DIAGNOSTIC
	if (endpa <= pa && endpa != 0)
		panic("bus_mem_add_mapping: overflow");
#endif

	map_size = endpa - pa;

	va = (vaddr_t)km_alloc(map_size, &kv_any, &kp_none, &kd_nowait);
	if (va == 0)
		return (ENOMEM);

	*bshp = (bus_space_handle_t)(va + (bpa & PGOFSET));

	if (flags & BUS_SPACE_MAP_CACHEABLE)
		pmap_flags = 0;
	else if (flags & BUS_SPACE_MAP_PREFETCHABLE)
		pmap_flags = PMAP_WC;

	for (; map_size > 0;
	    pa += PAGE_SIZE, va += PAGE_SIZE, map_size -= PAGE_SIZE)
		pmap_kenter_pa(va, pa | pmap_flags, PROT_READ | PROT_WRITE);
	pmap_update(pmap_kernel());

	return 0;
}

/*
 * void _bus_space_unmap(bus_space_tag bst, bus_space_handle bsh,
 *                        bus_size_t size, bus_addr_t *adrp)
 *
 *   This function unmaps memory- or io-space mapped by the function
 *   _bus_space_map().  This function works nearly as same as
 *   bus_space_unmap(), but this function does not ask kernel
 *   built-in extents and returns physical address of the bus space,
 *   for the convenience of the extra extent manager.
 */
void
_bus_space_unmap(bus_space_tag_t t, bus_space_handle_t bsh, bus_size_t size,
    bus_addr_t *adrp)
{
	u_long va, endva;
	bus_addr_t bpa;

	/*
	 * Find the correct bus physical address.
	 */
	if (t == X86_BUS_SPACE_IO) {
		bpa = bsh;
	} else if (t == X86_BUS_SPACE_MEM) {
		bpa = (bus_addr_t)ISA_PHYSADDR(bsh);
		if (IOM_BEGIN <= bpa && bpa <= IOM_END)
			goto ok;

		va = trunc_page(bsh);
		endva = round_page(bsh + size);

#ifdef DIAGNOSTIC
		if (endva <= va)
			panic("_bus_space_unmap: overflow");
#endif

		(void) pmap_extract(pmap_kernel(), va, &bpa);
		bpa += (bsh & PGOFSET);

		pmap_kremove(va, endva - va);
		pmap_update(pmap_kernel());

		/*
		 * Free the kernel virtual mapping.
		 */
		km_free((void *)va, endva - va, &kv_any, &kp_none);
	} else
		panic("bus_space_unmap: bad bus space tag");

ok:
	if (adrp != NULL)
		*adrp = bpa;
}

void
bus_space_unmap(bus_space_tag_t t, bus_space_handle_t bsh, bus_size_t size)
{
	struct extent *ex;
	u_long va, endva;
	bus_addr_t bpa;

	/*
	 * Find the correct extent and bus physical address.
	 */
	if (t == X86_BUS_SPACE_IO) {
		ex = ioport_ex;
		bpa = bsh;
	} else if (t == X86_BUS_SPACE_MEM) {
		ex = iomem_ex;
		bpa = (bus_addr_t)ISA_PHYSADDR(bsh);
		if (IOM_BEGIN <= bpa && bpa <= IOM_END)
			goto ok;

		va = trunc_page(bsh);
		endva = round_page(bsh + size);

#ifdef DIAGNOSTIC
		if (endva <= va)
			panic("bus_space_unmap: overflow");
#endif

		(void)pmap_extract(pmap_kernel(), va, &bpa);
		bpa += (bsh & PGOFSET);

		pmap_kremove(va, endva - va);
		pmap_update(pmap_kernel());

		/*
		 * Free the kernel virtual mapping.
		 */
		km_free((void *)va, endva - va, &kv_any, &kp_none);
	} else
		panic("bus_space_unmap: bad bus space tag");

ok:
	if (extent_free(ex, bpa, size,
	    EX_NOWAIT | (ioport_malloc_safe ? EX_MALLOCOK : 0))) {
		printf("bus_space_unmap: %s 0x%lx, size 0x%lx\n",
		    (t == X86_BUS_SPACE_IO) ? "port" : "pa", bpa, size);
		printf("bus_space_unmap: can't free region\n");
	}
}

void
bus_space_free(bus_space_tag_t t, bus_space_handle_t bsh, bus_size_t size)
{

	/* bus_space_unmap() does all that we need to do. */
	bus_space_unmap(t, bsh, size);
}

int
bus_space_subregion(bus_space_tag_t t, bus_space_handle_t bsh,
    bus_size_t offset, bus_size_t size, bus_space_handle_t *nbshp)
{

	*nbshp = bsh + offset;
	return (0);
}

u_int8_t
x86_bus_space_io_read_1(bus_space_handle_t h, bus_size_t o)
{
	return (inb(h + o));
}

u_int16_t
x86_bus_space_io_read_2(bus_space_handle_t h, bus_size_t o)
{
	return (inw(h + o));
}

u_int32_t
x86_bus_space_io_read_4(bus_space_handle_t h, bus_size_t o)
{
	return (inl(h + o));
}

u_int64_t
x86_bus_space_io_read_8(bus_space_handle_t h, bus_size_t o)
{
	panic("bus_space_read_8: invalid bus space tag");
}

void
x86_bus_space_io_read_multi_1(bus_space_handle_t h, bus_size_t o,
    u_int8_t *ptr, bus_size_t cnt)
{
	insb(h + o, ptr, cnt);
}

void
x86_bus_space_io_read_multi_2(bus_space_handle_t h, bus_size_t o,
    u_int16_t *ptr, bus_size_t cnt)
{
	insw(h + o, ptr, cnt);
}

void
x86_bus_space_io_read_multi_4(bus_space_handle_t h, bus_size_t o,
    u_int32_t *ptr, bus_size_t cnt)
{
	insl(h + o, ptr, cnt);
}

void
x86_bus_space_io_read_multi_8(bus_space_handle_t h, bus_size_t o,
    u_int64_t *ptr, bus_size_t cnt)
{
	panic("bus_space_multi_8: invalid bus space tag");
}

void
x86_bus_space_io_read_region_1(bus_space_handle_t h,
    bus_size_t o, u_int8_t *ptr, bus_size_t cnt)
{
	int dummy1;
	void *dummy2;
	int dummy3;
	int __x;
	u_int32_t port = h + o;
	__asm volatile(
	"1:	inb %w1,%%al				;"
	"	stosb					;"
	"	incl %1					;"
	"	loop 1b"				:
	    "=&a" (__x), "=d" (dummy1), "=D" (dummy2),
	    "=c" (dummy3)				:
	    "1" (port), "2" (ptr), "3" (cnt)	:
	    "memory");
}

void
x86_bus_space_io_read_region_2(bus_space_handle_t h,
    bus_size_t o, u_int16_t *ptr, bus_size_t cnt)
{
	int dummy1;
	void *dummy2;
	int dummy3;
	int __x;
	u_int32_t port = h + o;
	__asm volatile(
	"1:	inw %w1,%%ax				;"
	"	stosw					;"
	"	addl $2,%1				;"
	"	loop 1b"				:
	    "=&a" (__x), "=d" (dummy1), "=D" (dummy2),
	    "=c" (dummy3)				:
	    "1" ((port)), "2" ((ptr)), "3" ((cnt))	:
	    "memory");
}

void
x86_bus_space_io_read_region_4(bus_space_handle_t h,
    bus_size_t o, u_int32_t *ptr, bus_size_t cnt)
{
	int dummy1;
	void *dummy2;
	int dummy3;
	int __x;
	u_int32_t port = h + o;
	__asm volatile(
	"1:	inl %w1,%%eax				;"
	"	stosl					;"
	"	addl $4,%1				;"
	"	loop 1b"				:
	    "=&a" (__x), "=d" (dummy1), "=D" (dummy2),
	    "=c" (dummy3)				:
	    "1" (port), "2" (ptr), "3" (cnt)	:
	    "memory");
}

void
x86_bus_space_io_read_region_8(bus_space_handle_t h,
    bus_size_t o, u_int64_t *ptr, bus_size_t cnt)
{
	panic("bus_space_read_region_8: invalid bus space tag");
}

void
x86_bus_space_io_write_1(bus_space_handle_t h, bus_size_t o, u_int8_t v)
{
	outb(h + o, v);
}

void
x86_bus_space_io_write_2(bus_space_handle_t h, bus_size_t o, u_int16_t v)
{
	outw(h + o, v);
}

void
x86_bus_space_io_write_4(bus_space_handle_t h, bus_size_t o, u_int32_t v)
{
	outl(h + o, v);
}

void
x86_bus_space_io_write_8(bus_space_handle_t h, bus_size_t o, u_int64_t v)
{
	panic("bus_space_write_8: invalid bus space tag");
}

void
x86_bus_space_io_write_multi_1(bus_space_handle_t h,
    bus_size_t o, const u_int8_t *ptr, bus_size_t cnt)
{
	outsb(h + o, ptr, cnt);
}

void
x86_bus_space_io_write_multi_2(bus_space_handle_t h,
    bus_size_t o, const u_int16_t *ptr, bus_size_t cnt)
{
	outsw(h + o, ptr, cnt);
}

void
x86_bus_space_io_write_multi_4(bus_space_handle_t h,
    bus_size_t o, const u_int32_t *ptr, bus_size_t cnt)
{
	outsl(h + o, ptr, cnt);
}

void
x86_bus_space_io_write_multi_8(bus_space_handle_t h,
    bus_size_t o, const u_int64_t *ptr, bus_size_t cnt)
{
	panic("bus_space_write_multi_8: invalid bus space tag");
}

void
x86_bus_space_io_write_region_1(bus_space_handle_t h,
    bus_size_t o, const u_int8_t *ptr, bus_size_t cnt)
{
	int dummy1;
	void *dummy2;
	int dummy3;
	int __x;
	u_int32_t port = h + o;
	__asm volatile(
	"1:	lodsb					;"
	"	outb %%al,%w1				;"
	"	incl %1					;"
	"	loop 1b"				:
	    "=&a" (__x), "=d" (dummy1), "=S" (dummy2),
	    "=c" (dummy3)				:
	    "1" (port), "2" (ptr), "3" (cnt)	:
	    "memory");
}

void
x86_bus_space_io_write_region_2(bus_space_handle_t h,
    bus_size_t o, const u_int16_t *ptr, bus_size_t cnt)
{
	int dummy1;
	void *dummy2;
	int dummy3;
	int __x;
	u_int32_t port = h + o;
	__asm volatile(
	"1:	lodsw					;"
	"	outw %%ax,%w1				;"
	"	addl $2,%1				;"
	"	loop 1b"				: 
	    "=&a" (__x), "=d" (dummy1), "=S" (dummy2),
	    "=c" (dummy3)				:
	    "1" (port), "2" (ptr), "3" (cnt)	:
	    "memory");
}

void
x86_bus_space_io_write_region_4(bus_space_handle_t h,
    bus_size_t o, const u_int32_t *ptr, bus_size_t cnt)
{
	int dummy1;
	void *dummy2;
	int dummy3;
	int __x;
	u_int32_t port = h + o;
	__asm volatile(
	"1:	lodsl					;"
	"	outl %%eax,%w1				;"
	"	addl $4,%1				;"
	"	loop 1b"				:
	    "=&a" (__x), "=d" (dummy1), "=S" (dummy2),
	    "=c" (dummy3)				:
	    "1" (port), "2" (ptr), "3" (cnt)	:
	    "memory");
}

void
x86_bus_space_io_write_region_8(bus_space_handle_t h,
    bus_size_t o, const u_int64_t *ptr, bus_size_t cnt)
{
	panic("bus_space_write_region_8: invalid bus space tag");
}

void
x86_bus_space_io_set_multi_1(bus_space_handle_t h, bus_size_t o,
    u_int8_t v, size_t c)
{
	bus_addr_t addr = h + o;

	while (c--)
		outb(addr, v);
}

void
x86_bus_space_io_set_multi_2(bus_space_handle_t h, bus_size_t o,
    u_int16_t v, size_t c)
{
	bus_addr_t addr = h + o;

	while (c--)
		outw(addr, v);
}

void
x86_bus_space_io_set_multi_4(bus_space_handle_t h, bus_size_t o,
    u_int32_t v, size_t c)
{
	bus_addr_t addr = h + o;

	while (c--)
		outl(addr, v);
}

void
x86_bus_space_io_set_multi_8(bus_space_handle_t h, bus_size_t o,
    u_int64_t v, size_t c)
{
	panic("bus_space_set_multi_8: invalid bus space tag");
}

void
x86_bus_space_io_set_region_1(bus_space_handle_t h, bus_size_t o,
    u_int8_t v, size_t c)
{
	bus_addr_t addr = h + o;

	for (; c != 0; c--, addr++)
		outb(addr, v);
}

void
x86_bus_space_io_set_region_2(bus_space_handle_t h, bus_size_t o,
    u_int16_t v, size_t c)
{
	bus_addr_t addr = h + o;

	for (; c != 0; c--, addr += sizeof(v))
		outw(addr, v);
}

void
x86_bus_space_io_set_region_4(bus_space_handle_t h, bus_size_t o,
    u_int32_t v, size_t c)
{
	bus_addr_t addr = h + o;

	for (; c != 0; c--, addr += sizeof(v))
		outl(addr, v);
}

void
x86_bus_space_io_set_region_8(bus_space_handle_t h, bus_size_t o,
    u_int64_t v, size_t c)
{
	panic("bus_space_set_region_8: invalid bus space tag");
}

void
x86_bus_space_io_copy_1(bus_space_handle_t h1, bus_size_t o1,
    bus_space_handle_t h2, bus_size_t o2, size_t c)
{
	bus_addr_t addr1 = h1 + o1;
	bus_addr_t addr2 = h2 + o2;

	if (addr1 >= addr2) {
		/* src after dest: copy forward */
		for (; c != 0; c--, addr1++, addr2++)
			outb(addr2, inb(addr1));
	} else {
		/* dest after src: copy backwards */
		for (addr1 += (c - 1), addr2 += (c - 1);
		    c != 0; c--, addr1--, addr2--)
			outb(addr2, inb(addr1));
	}
}

void
x86_bus_space_io_copy_2(bus_space_handle_t h1, bus_size_t o1,
    bus_space_handle_t h2, bus_size_t o2, size_t c)
{
	bus_addr_t addr1 = h1 + o1;
	bus_addr_t addr2 = h2 + o2;

	if (addr1 >= addr2) {
		/* src after dest: copy forward */
		for (; c != 0; c--, addr1 += 2, addr2 += 2)
			outw(addr2, inw(addr1));
	} else {
		/* dest after src: copy backwards */
		for (addr1 += 2 * (c - 1), addr2 += 2 * (c - 1);
		    c != 0; c--, addr1 -= 2, addr2 -= 2)
			outw(addr2, inw(addr1));
	}
}

void
x86_bus_space_io_copy_4(bus_space_handle_t h1, bus_size_t o1,
    bus_space_handle_t h2, bus_size_t o2, size_t c)
{
	bus_addr_t addr1 = h1 + o1;
	bus_addr_t addr2 = h2 + o2;

	if (addr1 >= addr2) {
		/* src after dest: copy forward */
		for (; c != 0; c--, addr1 += 4, addr2 += 4)
			outl(addr2, inl(addr1));
	} else {
		/* dest after src: copy backwards */
		for (addr1 += 4 * (c - 1), addr2 += 4 * (c - 1);
		    c != 0; c--, addr1 -= 4, addr2 -= 4)
			outl(addr2, inl(addr1));
	}
}

void
x86_bus_space_io_copy_8(bus_space_handle_t h1, bus_size_t o1,
    bus_space_handle_t h2, bus_size_t o2, size_t c)
{
	panic("bus_space_set_region_8: invalid bus space tag");
}

void *
x86_bus_space_io_vaddr(bus_space_handle_t h)
{
	return (NULL);
}

paddr_t
x86_bus_space_io_mmap(bus_addr_t addr, off_t off, int prot, int flags)
{
	/* Can't mmap I/O space. */
	return (-1);
}

void
x86_bus_space_mem_write_1(bus_space_handle_t h, bus_size_t o, u_int8_t v)
{
	*(volatile u_int8_t *)(h + o) = v;
}

void
x86_bus_space_mem_write_2(bus_space_handle_t h, bus_size_t o, u_int16_t v)
{
	*(volatile u_int16_t *)(h + o) = v;
}

u_int8_t
x86_bus_space_mem_read_1(bus_space_handle_t h, bus_size_t o)
{
	return (*(volatile u_int8_t *)(h + o));
}

u_int16_t
x86_bus_space_mem_read_2(bus_space_handle_t h, bus_size_t o)
{
	return (*(volatile u_int16_t *)(h + o));
}

u_int32_t
x86_bus_space_mem_read_4(bus_space_handle_t h, bus_size_t o)
{
	return (*(volatile u_int32_t *)(h + o));
}

u_int64_t
x86_bus_space_mem_read_8(bus_space_handle_t h, bus_size_t o)
{
	return (*(volatile u_int64_t *)(h + o));
}

void
x86_bus_space_mem_read_multi_1(bus_space_handle_t h, bus_size_t o,
    u_int8_t *ptr, bus_size_t cnt)
{
	void *dummy1;
	int dummy2;
	void *dummy3;
	int __x;
	__asm volatile(
	"1:	movb (%2),%%al				;"
	"	stosb					;"
	"	loop 1b"				:
	    "=D" (dummy1), "=c" (dummy2), "=r" (dummy3), "=&a" (__x) :
	    "0" ((ptr)), "1" ((cnt)), "2" (h + o)       :
	    "memory");
}

void
x86_bus_space_mem_read_multi_2(bus_space_handle_t h, bus_size_t o,
    u_int16_t *ptr, bus_size_t cnt)
{
	void *dummy1;
	int dummy2;
	void *dummy3;
	int __x;
	__asm volatile(
	"1:	movw (%2),%%ax				;"
	"	stosw					;"
	"	loop 1b"				:
	    "=D" (dummy1), "=c" (dummy2), "=r" (dummy3), "=&a" (__x) :
	    "0" ((ptr)), "1" ((cnt)), "2" (h + o)       :
	    "memory");
}

void
x86_bus_space_mem_read_multi_4(bus_space_handle_t h, bus_size_t o,
    u_int32_t *ptr, bus_size_t cnt)
{
	void *dummy1;
	int dummy2;
	void *dummy3;
	int __x;
	__asm volatile(
	"1:	movl (%2),%%eax				;"
	"	stosl					;"
	"	loop 1b"				:
	    "=D" (dummy1), "=c" (dummy2), "=r" (dummy3), "=&a" (__x) :
	    "0" ((ptr)), "1" ((cnt)), "2" (h + o)       :
	    "memory");
}

void
x86_bus_space_mem_read_multi_8(bus_space_handle_t h, bus_size_t o,
    u_int64_t *ptr, bus_size_t cnt)
{
	void *dummy1;
	int dummy2;
	void *dummy3;
	int __x;
	__asm volatile(
	"1:	movq (%2),%%rax				;"
	"	stosq					;"
	"	loop 1b"				:
	    "=D" (dummy1), "=c" (dummy2), "=r" (dummy3), "=&a" (__x) :
	    "0" ((ptr)), "1" ((cnt)), "2" (h + o)       :
	    "memory");
}

void
x86_bus_space_mem_read_region_1(bus_space_handle_t h,
    bus_size_t o, u_int8_t *ptr, bus_size_t cnt)
{
	int dummy1;
	void *dummy2;
	int dummy3;
	__asm volatile(
	"	repne					;"
	"	movsb"					:
	    "=S" (dummy1), "=D" (dummy2), "=c" (dummy3)	:
	    "0" (h + o), "1" (ptr), "2" (cnt)	:
	    "memory");
}

void
x86_bus_space_mem_read_region_2(bus_space_handle_t h,
    bus_size_t o, u_int16_t *ptr, bus_size_t cnt)
{
	int dummy1;
	void *dummy2;
	int dummy3;
	__asm volatile(
	"	repne					;"
	"	movsw"					:
	    "=S" (dummy1), "=D" (dummy2), "=c" (dummy3)	:
	    "0" (h + o), "1" (ptr), "2" (cnt)	:
	    "memory");
}

void
x86_bus_space_mem_read_region_4(bus_space_handle_t h,
    bus_size_t o, u_int32_t *ptr, bus_size_t cnt)
{
	int dummy1;
	void *dummy2;
	int dummy3;
	__asm volatile(
	"	repne					;"
	"	movsl"					:
	    "=S" (dummy1), "=D" (dummy2), "=c" (dummy3)	:
	    "0" (h + o), "1" (ptr), "2" (cnt)	:
	    "memory");
}

void
x86_bus_space_mem_read_region_8(bus_space_handle_t h,
    bus_size_t o, u_int64_t *ptr, bus_size_t cnt)
{
	int dummy1;
	void *dummy2;
	int dummy3;
	__asm volatile(
	"	repne					;"
	"	movsq"					:
	    "=S" (dummy1), "=D" (dummy2), "=c" (dummy3)	:
	    "0" (h + o), "1" (ptr), "2" (cnt)	:
	    "memory");
}

void
x86_bus_space_mem_write_4(bus_space_handle_t h, bus_size_t o, u_int32_t v)
{
	*(volatile u_int32_t *)(h + o) = v;
}

void
x86_bus_space_mem_write_8(bus_space_handle_t h, bus_size_t o, u_int64_t v)
{
	*(volatile u_int64_t *)(h + o) = v;
}

void
x86_bus_space_mem_write_multi_1(bus_space_handle_t h,
    bus_size_t o, const u_int8_t *ptr, bus_size_t cnt)
{
	void *dummy1;
	int dummy2;
	void *dummy3;
	int __x;
	__asm volatile(
	"1:	lodsb					;"
	"	movb %%al,(%2)				;"
	"	loop 1b"				:
	    "=S" (dummy1), "=c" (dummy2), "=r" (dummy3), "=&a" (__x) :
	    "0" (ptr), "1" (cnt), "2" (h + o));
}

void
x86_bus_space_mem_write_multi_2(bus_space_handle_t h,
    bus_size_t o, const u_int16_t *ptr, bus_size_t cnt)
{
	void *dummy1;
	int dummy2;
	void *dummy3;
	int __x;
	__asm volatile(
	"1:	lodsw					;"
	"	movw %%ax,(%2)				;"
	"	loop 1b"				:
	    "=S" (dummy1), "=c" (dummy2), "=r" (dummy3), "=&a" (__x) :
	    "0" (ptr), "1" (cnt), "2" (h + o));
}

void
x86_bus_space_mem_write_multi_4(bus_space_handle_t h,
    bus_size_t o, const u_int32_t *ptr, bus_size_t cnt)
{
	void *dummy1;
	int dummy2;
	void *dummy3;
	int __x;
	__asm volatile(
	"1:	lodsl					;"
	"	movl %%eax,(%2)				;"
	"	loop 1b"				:
	    "=S" (dummy1), "=c" (dummy2), "=r" (dummy3), "=&a" (__x) :
	    "0" (ptr), "1" (cnt), "2" (h + o));
}

void
x86_bus_space_mem_write_multi_8(bus_space_handle_t h,
    bus_size_t o, const u_int64_t *ptr, bus_size_t cnt)
{
	void *dummy1;
	int dummy2;
	void *dummy3;
	int __x;
	__asm volatile(
	"1:	lodsq					;"
	"	movq %%rax,(%2)				;"
	"	loop 1b"				:
	    "=S" (dummy1), "=c" (dummy2), "=r" (dummy3), "=&a" (__x) :
	    "0" (ptr), "1" (cnt), "2" (h + o));
}

void
x86_bus_space_mem_write_region_1(bus_space_handle_t h,
    bus_size_t o, const u_int8_t *ptr, bus_size_t cnt)
{
	int dummy1;
	void *dummy2;
	int dummy3;
	__asm volatile(
	"	repne					;"
	"	movsb"					:
	    "=D" (dummy1), "=S" (dummy2), "=c" (dummy3)	:
	    "0" (h + o), "1" (ptr), "2" (cnt)	:
	    "memory");
}

void
x86_bus_space_mem_write_region_2(bus_space_handle_t h,
    bus_size_t o, const u_int16_t *ptr, bus_size_t cnt)
{
	int dummy1;
	void *dummy2;
	int dummy3;
	__asm volatile(
	"	repne					;"
	"	movsw"					:
	    "=D" (dummy1), "=S" (dummy2), "=c" (dummy3)	:
	    "0" (h + o), "1" (ptr), "2" (cnt)	:
	    "memory");
}

void
x86_bus_space_mem_write_region_4(bus_space_handle_t h,
    bus_size_t o, const u_int32_t *ptr, bus_size_t cnt)
{
	int dummy1;
	void *dummy2;
	int dummy3;
	__asm volatile(
	"	repne					;"
	"	movsl"					:
	    "=D" (dummy1), "=S" (dummy2), "=c" (dummy3)	:
	    "0" (h + o), "1" (ptr), "2" (cnt)	:
	    "memory");
}

void
x86_bus_space_mem_write_region_8(bus_space_handle_t h,
    bus_size_t o, const u_int64_t *ptr, bus_size_t cnt)
{
	int dummy1;
	void *dummy2;
	int dummy3;
	__asm volatile(
	"	repne					;"
	"	movsq"					:
	    "=D" (dummy1), "=S" (dummy2), "=c" (dummy3)	:
	    "0" (h + o), "1" (ptr), "2" (cnt)	:
	    "memory");
}

void
x86_bus_space_mem_set_multi_1(bus_space_handle_t h, bus_size_t o,
    u_int8_t v, size_t c)
{
	bus_addr_t addr = h + o;

	while (c--)
		*(volatile u_int8_t *)(addr) = v;
}

void
x86_bus_space_mem_set_multi_2(bus_space_handle_t h, bus_size_t o,
    u_int16_t v, size_t c)
{
	bus_addr_t addr = h + o;

	while (c--)
		*(volatile u_int16_t *)(addr) = v;
}

void
x86_bus_space_mem_set_multi_4(bus_space_handle_t h, bus_size_t o,
    u_int32_t v, size_t c)
{
	bus_addr_t addr = h + o;

	while (c--)
		*(volatile u_int32_t *)(addr) = v;
}

void
x86_bus_space_mem_set_multi_8(bus_space_handle_t h, bus_size_t o,
    u_int64_t v, size_t c)
{
	bus_addr_t addr = h + o;

	while (c--)
		*(volatile u_int64_t *)(addr) = v;
}

void
x86_bus_space_mem_set_region_1(bus_space_handle_t h, bus_size_t o,
    u_int8_t v, size_t c)
{
	bus_addr_t addr = h + o;

	for (; c != 0; c--, addr++)
		*(volatile u_int8_t *)(addr) = v;
}

void
x86_bus_space_mem_set_region_2(bus_space_handle_t h, bus_size_t o,
    u_int16_t v, size_t c)
{
	bus_addr_t addr = h + o;

	for (; c != 0; c--, addr += sizeof(v))
		*(volatile u_int16_t *)(addr) = v;
}

void
x86_bus_space_mem_set_region_4(bus_space_handle_t h, bus_size_t o,
    u_int32_t v, size_t c)
{
	bus_addr_t addr = h + o;

	for (; c != 0; c--, addr += sizeof(v))
		*(volatile u_int32_t *)(addr) = v;
}

void
x86_bus_space_mem_set_region_8(bus_space_handle_t h, bus_size_t o,
    u_int64_t v, size_t c)
{
	bus_addr_t addr = h + o;

	for (; c != 0; c--, addr += sizeof(v))
		*(volatile u_int64_t *)(addr) = v;
}

void
x86_bus_space_mem_copy_1( bus_space_handle_t h1, bus_size_t o1,
    bus_space_handle_t h2, bus_size_t o2, size_t c)
{
	bus_addr_t addr1 = h1 + o1;
	bus_addr_t addr2 = h2 + o2;

	if (addr1 >= addr2) {
		/* src after dest: copy forward */
		for (; c != 0; c--, addr1++, addr2++)
			*(volatile u_int8_t *)(addr2) =
			    *(volatile u_int8_t *)(addr1);
	} else {
		/* dest after src: copy backwards */
		for (addr1 += (c - 1), addr2 += (c - 1);
		    c != 0; c--, addr1--, addr2--)
			*(volatile u_int8_t *)(addr2) =
			    *(volatile u_int8_t *)(addr1);
	}
}

void
x86_bus_space_mem_copy_2(bus_space_handle_t h1, bus_size_t o1,
    bus_space_handle_t h2, bus_size_t o2, size_t c)
{
	bus_addr_t addr1 = h1 + o1;
	bus_addr_t addr2 = h2 + o2;

	if (addr1 >= addr2) {
		/* src after dest: copy forward */
		for (; c != 0; c--, addr1 += 2, addr2 += 2)
			*(volatile u_int16_t *)(addr2) =
			    *(volatile u_int16_t *)(addr1);
	} else {
		/* dest after src: copy backwards */
		for (addr1 += 2 * (c - 1), addr2 += 2 * (c - 1);
		    c != 0; c--, addr1 -= 2, addr2 -= 2)
			*(volatile u_int16_t *)(addr2) =
			    *(volatile u_int16_t *)(addr1);
	}
}

void
x86_bus_space_mem_copy_4(bus_space_handle_t h1, bus_size_t o1,
    bus_space_handle_t h2, bus_size_t o2, size_t c)
{
	bus_addr_t addr1 = h1 + o1;
	bus_addr_t addr2 = h2 + o2;

	if (addr1 >= addr2) {
		/* src after dest: copy forward */
		for (; c != 0; c--, addr1 += 4, addr2 += 4)
			*(volatile u_int32_t *)(addr2) =
			    *(volatile u_int32_t *)(addr1);
	} else {
		/* dest after src: copy backwards */
		for (addr1 += 4 * (c - 1), addr2 += 4 * (c - 1);
		    c != 0; c--, addr1 -= 4, addr2 -= 4)
			*(volatile u_int32_t *)(addr2) =
			    *(volatile u_int32_t *)(addr1);
	}
}

void
x86_bus_space_mem_copy_8(bus_space_handle_t h1, bus_size_t o1,
    bus_space_handle_t h2, bus_size_t o2, size_t c)
{
	bus_addr_t addr1 = h1 + o1;
	bus_addr_t addr2 = h2 + o2;

	if (addr1 >= addr2) {
		/* src after dest: copy forward */
		for (; c != 0; c--, addr1 += 8, addr2 += 8)
			*(volatile u_int64_t *)(addr2) =
			    *(volatile u_int64_t *)(addr1);
	} else {
		/* dest after src: copy backwards */
		for (addr1 += 8 * (c - 1), addr2 += 8 * (c - 1);
		    c != 0; c--, addr1 -= 8, addr2 -= 8)
			*(volatile u_int64_t *)(addr2) =
			    *(volatile u_int64_t *)(addr1);
	}
}

void *
x86_bus_space_mem_vaddr(bus_space_handle_t h)
{
	return ((void *)h);
}

paddr_t
x86_bus_space_mem_mmap(bus_addr_t addr, off_t off, int prot, int flags)
{
	/*
	 * "addr" is the base address of the device we're mapping.
	 * "off" is the offset into that device.
	 *
	 * Note we are called for each "page" in the device that
	 * the upper layers want to map.
	 */
	return (addr + off);
}
@


1.25
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.24 2014/10/25 16:57:58 kettenis Exp $	*/
d697 1
a697 1
	__asm volatile(" cld				;"
d717 1
a717 1
	__asm volatile(" cld				;"
d737 1
a737 1
	__asm volatile("cld				;"
d816 1
a816 1
	__asm volatile("cld				;"
d836 1
a836 1
	__asm volatile("cld				;"
d856 1
a856 1
	__asm volatile(" cld				;"
d1069 1
a1069 1
	__asm volatile(" cld				;"
d1086 1
a1086 1
	__asm volatile(" cld				;"
d1103 1
a1103 1
	__asm volatile(" cld				;"
d1120 1
a1120 1
	__asm volatile(" cld				;"
d1136 1
a1136 1
	__asm volatile(" cld				;"
d1151 1
a1151 1
	__asm volatile(" cld				;"
d1166 1
a1166 1
	__asm volatile("cld				;"
d1181 1
a1181 1
	__asm volatile("cld				;"
d1209 1
a1209 1
	__asm volatile("cld				;"
d1225 1
a1225 1
	__asm volatile("cld				;"
d1241 1
a1241 1
	__asm volatile("cld				;"
d1257 1
a1257 1
	__asm volatile("cld				;"
d1272 1
a1272 1
	__asm volatile("cld				;"
d1287 1
a1287 1
	__asm volatile("cld				;"
d1302 1
a1302 1
	__asm volatile("cld				;"
d1317 1
a1317 1
	__asm volatile("cld				;"
@


1.24
log
@uvm_km_valloc -> km_alloc

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.23 2014/03/29 18:09:28 guenther Exp $	*/
d511 1
a511 2
		pmap_kenter_pa(va, pa | pmap_flags,
		    VM_PROT_READ | VM_PROT_WRITE);
@


1.23
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.22 2013/01/18 01:54:40 dlg Exp $	*/
d498 1
a498 1
	va = uvm_km_valloc(kernel_map, map_size);
d562 1
a562 1
		uvm_km_free(kernel_map, va, endva - va);
d607 1
a607 1
		uvm_km_free(kernel_map, va, endva - va);
@


1.22
log
@twist the amd64 bus_space implementation a bit. instead of using the tag
as an identifier for IO or memory mappings that was checked inside the api,
turn it into a pointer to a structure of function pointers. the api then
generally becomes a set of macros that deref the function pointers on the
callers behalf. the idea is that following a pointer to very small
functions is cheap compared to doing compares continuously.

a notable exception to the macro wrappers is bus_space_barrier which is now
a static inline function. the only argument to it that gets used is the
flags, and thats usually a constant at compile time so it can be inlined
to a single fence instruction.

the kernel is smaller and the api is more cache friendly now.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.20 2012/05/23 08:23:43 mikeb Exp $	*/
d698 1
a698 1
	__asm __volatile(" cld					;"
d718 1
a718 1
	__asm __volatile(" cld				;"
d738 1
a738 1
	__asm __volatile("cld				;"
d817 1
a817 1
	__asm __volatile("cld				;"
d837 1
a837 1
	__asm __volatile("cld				;"
d857 1
a857 1
	__asm __volatile(" cld				;"
d1070 1
a1070 1
	__asm __volatile(" cld				;"
d1087 1
a1087 1
	__asm __volatile(" cld				;"
d1104 1
a1104 1
	__asm __volatile(" cld				;"
d1121 1
a1121 1
	__asm __volatile(" cld				;"
d1137 1
a1137 1
	__asm __volatile(" cld				;"
d1152 1
a1152 1
	__asm __volatile(" cld				;"
d1167 1
a1167 1
	__asm __volatile("cld				;"
d1182 1
a1182 1
	__asm __volatile("cld				;"
d1210 1
a1210 1
	__asm __volatile("cld				;"
d1226 1
a1226 1
	__asm __volatile("cld					;"
d1242 1
a1242 1
	__asm __volatile("cld				;"
d1258 1
a1258 1
	__asm __volatile("cld				;"
d1273 1
a1273 1
	__asm __volatile("cld				;"
d1288 1
a1288 1
	__asm __volatile("cld				;"
d1303 1
a1303 1
	__asm __volatile("cld				;"
d1318 1
a1318 1
	__asm __volatile("cld				;"
@


1.21
log
@implement bus_space_foo_8 for amd64. it will panic on attempts to do 8
byte operations on I/O space with "invalid I/O operation", but works great
for mem mappings.

compiled AND tested on myx(4) on amd64.
ok deraadt@@ kettenis@@ miod@@ pirofti@@
@
text
@d67 243
a334 1

a636 18
paddr_t
bus_space_mmap(bus_space_tag_t t, bus_addr_t addr, off_t off, int prot, int flags)
{

	/* Can't mmap I/O space. */
	if (t == X86_BUS_SPACE_IO)
		return (-1);

	/*
	 * "addr" is the base address of the device we're mapping.
	 * "off" is the offset into that device.
	 *
	 * Note we are called for each "page" in the device that
	 * the upper layers want to map.
	 */
	return (addr + off);
}

d638 1
a638 1
bus_space_read_1(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o)
d640 1
a640 2
	return (t == X86_BUS_SPACE_IO ? (inb(h + o)) :
	    (*(volatile u_int8_t *)(h + o)));
d644 1
a644 1
bus_space_read_2(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o)
d646 1
a646 2
	return (t == X86_BUS_SPACE_IO ? (inw(h + o)) :
	    (*(volatile u_int16_t *)(h + o)));
d650 1
a650 1
bus_space_read_4(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o)
d652 1
a652 2
	return (t == X86_BUS_SPACE_IO ? (inl(h + o)) :
	    (*(volatile u_int32_t *)(h + o)));
d656 1
a656 1
bus_space_read_8(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o)
d658 1
a658 4
	if (t == X86_BUS_SPACE_IO)
		panic("bus_space_read_8: invalid I/O operation");

	return (*(volatile u_int64_t *)(h + o));
d662 2
a663 2
bus_space_read_multi_1(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
	    u_int8_t *ptr, bus_size_t cnt)
d665 1
a665 15
	if ((t) == X86_BUS_SPACE_IO) {
		insb(h + o, ptr, cnt);
	} else {
		void *dummy1;
		int dummy2;
		void *dummy3;
		int __x;
		__asm __volatile(" cld					;"
		"1:	movb (%2),%%al				;"
		"	stosb					;"
		"	loop 1b"				:
		    "=D" (dummy1), "=c" (dummy2), "=r" (dummy3), "=&a" (__x) :
		    "0" ((ptr)), "1" ((cnt)), "2" (h + o)       :
		    "memory");
	}
d669 1
a669 1
bus_space_read_multi_2(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
d672 1
a672 15
	if ((t) == X86_BUS_SPACE_IO) {
		insw(h + o, ptr, cnt);
	} else {
		void *dummy1;
		int dummy2;
		void *dummy3;
		int __x;
		__asm __volatile(" cld				;"
		"1:	movw (%2),%%ax				;"
		"	stosw					;"
		"	loop 1b"				:
		    "=D" (dummy1), "=c" (dummy2), "=r" (dummy3), "=&a" (__x) :
		    "0" ((ptr)), "1" ((cnt)), "2" (h + o)       :
		    "memory");
	}
d676 1
a676 1
bus_space_read_multi_4(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
d679 1
a679 15
	if ((t) == X86_BUS_SPACE_IO) {
		insl(h + o, ptr, cnt);
	} else {
		void *dummy1;
		int dummy2;
		void *dummy3;
		int __x;
		__asm __volatile(" cld				;"
		"1:	movl (%2),%%eax				;"
		"	stosl					;"
		"	loop 1b"				:
		    "=D" (dummy1), "=c" (dummy2), "=r" (dummy3), "=&a" (__x) :
		    "0" ((ptr)), "1" ((cnt)), "2" (h + o)       :
		    "memory");
	}
d683 1
a683 1
bus_space_read_multi_8(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
d686 1
a686 15
	if ((t) == X86_BUS_SPACE_IO) {
		panic("bus_space_multi_8: invalid I/O operation");
	} else {
		void *dummy1;
		int dummy2;
		void *dummy3;
		int __x;
		__asm __volatile(" cld				;"
		"1:	movq (%2),%%rax				;"
		"	stosq					;"
		"	loop 1b"				:
		    "=D" (dummy1), "=c" (dummy2), "=r" (dummy3), "=&a" (__x) :
		    "0" ((ptr)), "1" ((cnt)), "2" (h + o)       :
		    "memory");
	}
d690 1
a690 1
bus_space_read_region_1(bus_space_tag_t t, bus_space_handle_t h,
d693 14
a706 26
	if ((t) == X86_BUS_SPACE_IO) {
		int dummy1;
		void *dummy2;
		int dummy3;
		int __x;
		u_int32_t port = h + o;
		__asm __volatile(" cld					;"
		"1:	inb %w1,%%al				;"
		"	stosb					;"
		"	incl %1					;"
		"	loop 1b"				:
		    "=&a" (__x), "=d" (dummy1), "=D" (dummy2),
		    "=c" (dummy3)				:
		    "1" (port), "2" (ptr), "3" (cnt)	:
		    "memory");
	} else {
		int dummy1;
		void *dummy2;
		int dummy3;
		__asm __volatile(" cld					;"
		"	repne					;"
		"	movsb"					:
		    "=S" (dummy1), "=D" (dummy2), "=c" (dummy3)	:
		    "0" (h + o), "1" (ptr), "2" (cnt)	:
		    "memory");
	}
d710 1
a710 1
bus_space_read_region_2(bus_space_tag_t t, bus_space_handle_t h,
d713 247
a959 15
	if ((t) == X86_BUS_SPACE_IO) {
		int dummy1;
		void *dummy2;
		int dummy3;
		int __x;
		u_int32_t port = h + o;
		__asm __volatile(" cld				;"
		"1:	inw %w1,%%ax				;"
		"	stosw					;"
		"	addl $2,%1				;"
		"	loop 1b"				:
		    "=&a" (__x), "=d" (dummy1), "=D" (dummy2),
		    "=c" (dummy3)				:
		    "1" ((port)), "2" ((ptr)), "3" ((cnt))	:
		    "memory");
d961 4
a964 9
		int dummy1;
		void *dummy2;
		int dummy3;
		__asm __volatile(" cld				;"
		"	repne					;"
		"	movsw"					:
		    "=S" (dummy1), "=D" (dummy2), "=c" (dummy3)	:
		    "0" (h + o), "1" (ptr), "2" (cnt)	:
		    "memory");
d969 2
a970 2
bus_space_read_region_4(bus_space_tag_t t, bus_space_handle_t h,
    bus_size_t o, u_int32_t *ptr, bus_size_t cnt)
d972 7
a978 15
	if ((t) == X86_BUS_SPACE_IO) {
		int dummy1;
		void *dummy2;
		int dummy3;
		int __x;
		u_int32_t port = h + o;
		__asm __volatile("cld				;"
		"1:	inl %w1,%%eax				;"
		"	stosl					;"
		"	addl $4,%1				;"
		"	loop 1b"				:
		    "=&a" (__x), "=d" (dummy1), "=D" (dummy2),
		    "=c" (dummy3)				:
		    "1" (port), "2" (ptr), "3" (cnt)	:
		    "memory");
d980 4
a983 9
		int dummy1;
		void *dummy2;
		int dummy3;
		__asm __volatile("cld				;"
		"	repne					;"
		"	movsl"					:
		    "=S" (dummy1), "=D" (dummy2), "=c" (dummy3)	:
		    "0" (h + o), "1" (ptr), "2" (cnt)	:
		    "memory");
d988 2
a989 2
bus_space_read_region_8(bus_space_tag_t t, bus_space_handle_t h,
    bus_size_t o, u_int64_t *ptr, bus_size_t cnt)
d991 7
a997 2
	if ((t) == X86_BUS_SPACE_IO) {
		panic("bus_space_read_region_8: invalid I/O operation");
d999 4
a1002 9
		int dummy1;
		void *dummy2;
		int dummy3;
		__asm __volatile("cld				;"
		"	repne					;"
		"	movsq"					:
		    "=S" (dummy1), "=D" (dummy2), "=c" (dummy3)	:
		    "0" (h + o), "1" (ptr), "2" (cnt)	:
		    "memory");
a1005 8
/*
 *	void bus_space_write_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_intN_t value);
 *
 * Write the 1, 2, 4, or 8 byte value `value' to bus space
 * described by tag/handle/offset.
 */
d1007 156
a1162 2
bus_space_write_1(bus_space_tag_t t, bus_space_handle_t h,
    bus_size_t o, u_int8_t v)
d1164 9
a1172 4
	if (t == X86_BUS_SPACE_IO)
		outb(h + o, v);
	else
		((void)(*(volatile u_int8_t *)(h + o) = v));
d1176 2
a1177 2
bus_space_write_2(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
    u_int16_t v)
d1179 9
a1187 4
	if ((t) == X86_BUS_SPACE_IO)
		outw(h + o, v);
	else
		((void)(*(volatile u_int16_t *)(h + o) = v));
d1191 1
a1191 2
bus_space_write_4(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
    u_int32_t v)
d1193 1
a1193 4
	if ((t) == X86_BUS_SPACE_IO)
		outl(h + o, v);
	else
		((void)(*(volatile u_int32_t *)(h + o) = v));
d1197 1
a1197 2
bus_space_write_8(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
    u_int64_t v)
d1199 1
a1199 4
	if ((t) == X86_BUS_SPACE_IO)
		panic("bus_space_write_8: invalid I/O operation");
	else
		((void)(*(volatile u_int64_t *)(h + o) = v));
d1203 1
a1203 1
bus_space_write_multi_1(bus_space_tag_t t, bus_space_handle_t h,
d1206 10
a1215 14
	if ((t) == X86_BUS_SPACE_IO) {
		outsb(h + o, ptr, cnt);
	} else {
		void *dummy1;
		int dummy2;
		void *dummy3;
		int __x;
		__asm __volatile("cld				;"
		"1:	lodsb					;"
		"	movb %%al,(%2)				;"
		"	loop 1b"				:
		    "=S" (dummy1), "=c" (dummy2), "=r" (dummy3), "=&a" (__x) :
		    "0" (ptr), "1" (cnt), "2" (h + o));
	}
d1219 1
a1219 1
bus_space_write_multi_2(bus_space_tag_t t, bus_space_handle_t h,
d1222 10
a1231 14
	if ((t) == X86_BUS_SPACE_IO) {
		outsw(h + o, ptr, cnt);
	} else {
		void *dummy1;
		int dummy2;
		void *dummy3;
		int __x;
		__asm __volatile("cld					;"
		"1:	lodsw					;"
		"	movw %%ax,(%2)				;"
		"	loop 1b"				:
		    "=S" (dummy1), "=c" (dummy2), "=r" (dummy3), "=&a" (__x) :
		    "0" (ptr), "1" (cnt), "2" (h + o));
	}
d1235 1
a1235 1
bus_space_write_multi_4(bus_space_tag_t t, bus_space_handle_t h,
d1238 10
a1247 14
	if ((t) == X86_BUS_SPACE_IO) {
		outsl(h + o, ptr, cnt);
	} else {
		void *dummy1;
		int dummy2;
		void *dummy3;
		int __x;
		__asm __volatile("cld				;"
		"1:	lodsl					;"
		"	movl %%eax,(%2)				;"
		"	loop 1b"				:
		    "=S" (dummy1), "=c" (dummy2), "=r" (dummy3), "=&a" (__x) :
		    "0" (ptr), "1" (cnt), "2" (h + o));
	}
d1251 1
a1251 1
bus_space_write_multi_8(bus_space_tag_t t, bus_space_handle_t h,
d1254 10
a1263 14
	if ((t) == X86_BUS_SPACE_IO) {
		panic("bus_space_write_multi_8: invalid I/O operation");
	} else {
		void *dummy1;
		int dummy2;
		void *dummy3;
		int __x;
		__asm __volatile("cld				;"
		"1:	lodsq					;"
		"	movq %%rax,(%2)				;"
		"	loop 1b"				:
		    "=S" (dummy1), "=c" (dummy2), "=r" (dummy3), "=&a" (__x) :
		    "0" (ptr), "1" (cnt), "2" (h + o));
	}
d1267 1
a1267 1
bus_space_write_region_1(bus_space_tag_t t, bus_space_handle_t h,
d1270 9
a1278 26
	if ((t) == X86_BUS_SPACE_IO) {
		int dummy1;
		void *dummy2;
		int dummy3;
		int __x;
		u_int32_t port = h + o;
		__asm __volatile("cld				;"
		"1:	lodsb					;"
		"	outb %%al,%w1				;"
		"	incl %1					;"
		"	loop 1b"				:
		    "=&a" (__x), "=d" (dummy1), "=S" (dummy2),
		    "=c" (dummy3)				:
		    "1" (port), "2" (ptr), "3" (cnt)	:
		    "memory");
	} else {
		int dummy1;
		void *dummy2;
		int dummy3;
		__asm __volatile("cld				;"
		"	repne					;"
		"	movsb"					:
		    "=D" (dummy1), "=S" (dummy2), "=c" (dummy3)	:
		    "0" (h + o), "1" (ptr), "2" (cnt)	:
		    "memory");
	}
d1282 1
a1282 1
bus_space_write_region_2(bus_space_tag_t t, bus_space_handle_t h,
d1285 9
a1293 26
	if ((t) == X86_BUS_SPACE_IO) {
		int dummy1;
		void *dummy2;
		int dummy3;
		int __x;
		u_int32_t port = h + o;
		__asm __volatile("cld				;"
		"1:	lodsw					;"
		"	outw %%ax,%w1				;"
		"	addl $2,%1				;"
		"	loop 1b"				: 
		    "=&a" (__x), "=d" (dummy1), "=S" (dummy2),
		    "=c" (dummy3)				:
		    "1" (port), "2" (ptr), "3" (cnt)	:
		    "memory");
	} else {
		int dummy1;
		void *dummy2;
		int dummy3;
		__asm __volatile("cld				;"
		"	repne					;"
		"	movsw"					:
		    "=D" (dummy1), "=S" (dummy2), "=c" (dummy3)	:
		    "0" (h + o), "1" (ptr), "2" (cnt)	:
		    "memory");
	}
d1297 1
a1297 1
bus_space_write_region_4(bus_space_tag_t t, bus_space_handle_t h,
d1300 9
a1308 26
	if ((t) == X86_BUS_SPACE_IO) {
		int dummy1;
		void *dummy2;
		int dummy3;
		int __x;
		u_int32_t port = h + o;
		__asm __volatile(" cld				;"
		"1:	lodsl					;"
		"	outl %%eax,%w1				;"
		"	addl $4,%1				;"
		"	loop 1b"				:
		    "=&a" (__x), "=d" (dummy1), "=S" (dummy2),
		    "=c" (dummy3)				:
		    "1" (port), "2" (ptr), "3" (cnt)	:
		    "memory");
	} else {
		int dummy1;
		void *dummy2;
		int dummy3;
		__asm __volatile("cld				;"
		"	repne					;"
		"	movsl"					:
		    "=D" (dummy1), "=S" (dummy2), "=c" (dummy3)	:
		    "0" (h + o), "1" (ptr), "2" (cnt)	:
		    "memory");
	}
d1312 1
a1312 1
bus_space_write_region_8(bus_space_tag_t t, bus_space_handle_t h,
d1315 9
a1323 13
	if ((t) == X86_BUS_SPACE_IO) {
		panic("bus_space_write_region_8: invalid I/O operation");
	} else {
		int dummy1;
		void *dummy2;
		int dummy3;
		__asm __volatile("cld				;"
		"	repne					;"
		"	movsq"					:
		    "=D" (dummy1), "=S" (dummy2), "=c" (dummy3)	:
		    "0" (h + o), "1" (ptr), "2" (cnt)	:
		    "memory");
	}
d1327 1
a1327 1
bus_space_set_multi_1(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
d1332 2
a1333 6
	if (t == X86_BUS_SPACE_IO)
		while (c--)
			outb(addr, v);
	else
		while (c--)
			*(volatile u_int8_t *)(addr) = v;
d1337 1
a1337 1
bus_space_set_multi_2(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
d1342 2
a1343 6
	if (t == X86_BUS_SPACE_IO)
		while (c--)
			outw(addr, v);
	else
		while (c--)
			*(volatile u_int16_t *)(addr) = v;
d1347 1
a1347 1
bus_space_set_multi_4(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
d1352 2
a1353 6
	if (t == X86_BUS_SPACE_IO)
		while (c--)
			outl(addr, v);
	else
		while (c--)
			*(volatile u_int32_t *)(addr) = v;
d1357 1
a1357 1
bus_space_set_multi_8(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
d1362 2
a1363 5
	if (t == X86_BUS_SPACE_IO)
		panic("bus_space_set_multi_8: invalid I/O operation");
	else
		while (c--)
			*(volatile u_int64_t *)(addr) = v;
d1367 1
a1367 1
bus_space_set_region_1(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
d1372 2
a1373 6
	if (t == X86_BUS_SPACE_IO)
		for (; c != 0; c--, addr++)
			outb(addr, v);
	else
		for (; c != 0; c--, addr++)
			*(volatile u_int8_t *)(addr) = v;
d1377 1
a1377 1
bus_space_set_region_2(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
d1382 2
a1383 6
	if (t == X86_BUS_SPACE_IO)
		for (; c != 0; c--, addr += 2)
			outw(addr, v);
	else
		for (; c != 0; c--, addr += 2)
			*(volatile u_int16_t *)(addr) = v;
d1387 1
a1387 1
bus_space_set_region_4(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
d1392 2
a1393 6
	if (t == X86_BUS_SPACE_IO)
		for (; c != 0; c--, addr += 4)
			outl(addr, v);
	else
		for (; c != 0; c--, addr += 4)
			*(volatile u_int32_t *)(addr) = v;
d1397 1
a1397 1
bus_space_set_region_8(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
d1402 2
a1403 5
	if (t == X86_BUS_SPACE_IO)
		panic("bus_space_set_region_8: invalid I/O operation");
	else
		for (; c != 0; c--, addr += sizeof(v))
			*(volatile u_int64_t *)(addr) = v;
d1407 1
a1407 2
bus_space_copy_1(bus_space_tag_t t,
    bus_space_handle_t h1, bus_size_t o1,
d1413 5
a1417 11
	if (t == X86_BUS_SPACE_IO) {
		if (addr1 >= addr2) {
			/* src after dest: copy forward */
			for (; c != 0; c--, addr1++, addr2++)
				outb(addr2, inb(addr1));
		} else {
			/* dest after src: copy backwards */
			for (addr1 += (c - 1), addr2 += (c - 1);
			    c != 0; c--, addr1--, addr2--)
				outb(addr2, inb(addr1));
		}
d1419 5
a1423 12
		if (addr1 >= addr2) {
			/* src after dest: copy forward */
			for (; c != 0; c--, addr1++, addr2++)
				*(volatile u_int8_t *)(addr2) =
				    *(volatile u_int8_t *)(addr1);
		} else {
			/* dest after src: copy backwards */
			for (addr1 += (c - 1), addr2 += (c - 1);
			    c != 0; c--, addr1--, addr2--)
				*(volatile u_int8_t *)(addr2) =
				    *(volatile u_int8_t *)(addr1);
		}
d1428 1
a1428 2
bus_space_copy_2(bus_space_tag_t t,
    bus_space_handle_t h1, bus_size_t o1,
d1434 5
a1438 11
	if (t == X86_BUS_SPACE_IO) {
		if (addr1 >= addr2) {
			/* src after dest: copy forward */
			for (; c != 0; c--, addr1 += 2, addr2 += 2)
				outw(addr2, inw(addr1));
		} else {
			/* dest after src: copy backwards */
			for (addr1 += 2 * (c - 1), addr2 += 2 * (c - 1);
			    c != 0; c--, addr1 -= 2, addr2 -= 2)
				outw(addr2, inw(addr1));
		}
d1440 5
a1444 12
		if (addr1 >= addr2) {
			/* src after dest: copy forward */
			for (; c != 0; c--, addr1 += 2, addr2 += 2)
				*(volatile u_int16_t *)(addr2) =
				    *(volatile u_int16_t *)(addr1);
		} else {
			/* dest after src: copy backwards */
			for (addr1 += 2 * (c - 1), addr2 += 2 * (c - 1);
			    c != 0; c--, addr1 -= 2, addr2 -= 2)
				*(volatile u_int16_t *)(addr2) =
				    *(volatile u_int16_t *)(addr1);
		}
d1449 1
a1449 2
bus_space_copy_4(bus_space_tag_t t,
    bus_space_handle_t h1, bus_size_t o1,
d1455 5
a1459 11
	if (t == X86_BUS_SPACE_IO) {
		if (addr1 >= addr2) {
			/* src after dest: copy forward */
			for (; c != 0; c--, addr1 += 4, addr2 += 4)
				outl(addr2, inl(addr1));
		} else {
			/* dest after src: copy backwards */
			for (addr1 += 4 * (c - 1), addr2 += 4 * (c - 1);
			    c != 0; c--, addr1 -= 4, addr2 -= 4)
				outl(addr2, inl(addr1));
		}
d1461 5
a1465 12
		if (addr1 >= addr2) {
			/* src after dest: copy forward */
			for (; c != 0; c--, addr1 += 4, addr2 += 4)
				*(volatile u_int32_t *)(addr2) =
				    *(volatile u_int32_t *)(addr1);
		} else {
			/* dest after src: copy backwards */
			for (addr1 += 4 * (c - 1), addr2 += 4 * (c - 1);
			    c != 0; c--, addr1 -= 4, addr2 -= 4)
				*(volatile u_int32_t *)(addr2) =
				    *(volatile u_int32_t *)(addr1);
		}
d1470 1
a1470 2
bus_space_copy_8(bus_space_tag_t t,
    bus_space_handle_t h1, bus_size_t o1,
d1476 5
a1480 2
	if (t == X86_BUS_SPACE_IO) {
		panic("bus_space_set_region_8: invalid I/O operation");
d1482 5
a1486 12
		if (addr1 >= addr2) {
			/* src after dest: copy forward */
			for (; c != 0; c--, addr1 += 8, addr2 += 8)
				*(volatile u_int64_t *)(addr2) =
				    *(volatile u_int64_t *)(addr1);
		} else {
			/* dest after src: copy backwards */
			for (addr1 += 8 * (c - 1), addr2 += 8 * (c - 1);
			    c != 0; c--, addr1 -= 8, addr2 -= 8)
				*(volatile u_int64_t *)(addr2) =
				    *(volatile u_int64_t *)(addr1);
		}
d1490 2
a1491 3
void
bus_space_barrier(bus_space_tag_t tag, bus_space_handle_t bsh,
    bus_size_t offset, bus_size_t len, int flags)
d1493 1
a1493 6
	if (flags == (BUS_SPACE_BARRIER_READ|BUS_SPACE_BARRIER_WRITE))
		__asm __volatile("mfence");
	else if (flags == BUS_SPACE_BARRIER_WRITE)
		__asm __volatile("sfence");
	else
		__asm __volatile("lfence");
d1496 12
@


1.20
log
@increase the number of io and mem extent regions for amd64 to 16
as it was done for i386 some time ago;  update the comment in the
i386 code to reflect reality.  this helps machines with plenty of
memory regions set up by the bios.  ok kettenis, jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.19 2011/04/09 21:30:27 jsg Exp $	*/
d434 9
d507 21
d622 20
d681 10
d751 20
d867 19
d928 13
d983 13
d1096 26
@


1.19
log
@don't tell the inline assembly here it will take a 64 bit io port
value when this isn't possible in practice, use a 32 bit value.

ok kettenis@@ miod@@ oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.18 2010/12/26 15:40:59 miod Exp $	*/
d48 1
a48 1
 * storage for 8 regions in each, initially.  Later, ioport_malloc_safe
d58 2
a59 2
static	long ioport_ex_storage[EXTENT_FIXED_STORAGE_SIZE(8) / sizeof(long)];
static	long iomem_ex_storage[EXTENT_FIXED_STORAGE_SIZE(8) / sizeof(long)];
@


1.18
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.17 2010/05/08 16:54:07 oga Exp $	*/
d506 1
d514 1
a514 1
		    "1" (h + o), "2" (ptr), "3" (cnt)	:
d538 1
d546 1
a546 1
		    "1" ((h) + (o)), "2" ((ptr)), "3" ((cnt))	:
d570 1
d578 1
a578 1
		    "1" (h + o), "2" (ptr), "3" (cnt)	:
d699 1
d707 1
a707 1
		    "1" (h + o), "2" (ptr), "3" (cnt)	:
d731 1
d739 1
a739 1
		    "1" (h + o), "2" (ptr), "3" (cnt)	:
d763 1
d771 1
a771 1
		    "1" (h + o), "2" (ptr), "3" (cnt)	:
@


1.17
log
@Page Attribute Tables (PAT) support for x86.

PAT allows setting per-mapping cachability bits. Our main interest in it
for write combining mappings so we do not have to rely so heaviliy on
mtrrs (which are stupidly set up on more and more machines). MD flags to
pmap allow setting these bits (which bus_space now uses for PREFETCHABLE
maps), if a vm page has a bit set, then we will use WC for all mappings
of a page (used for userland mappings). We also check for known errata
and fall back to UC- mappings in that case.

comments from kettenis@@, tedu@@ and william@@. kettenis@@, tedu@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.16 2010/04/04 12:49:29 miod Exp $	*/
d410 1
a410 1
	return (atop(addr + off));
@


1.16
log
@OpenBSD uses bus_space_copy_#, not bus_space_copy_region_#. Make sure only the
first name is used, and remove any #define foo_region foo compatibility
defines.
Also, on sparc64, do not provide a `raw' version of bus_space_copy.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.15 2009/08/11 17:15:54 oga Exp $	*/
d241 1
a241 1
	u_long pa, endpa;
d244 1
d262 5
d269 2
a270 2
		pmap_kenter_pa(va, pa | ((flags & BUS_SPACE_MAP_CACHEABLE) ?
		    0 : PMAP_NOCACHE), VM_PROT_READ | VM_PROT_WRITE);
@


1.15
log
@fix some stupidity in x86 bus_space_map.

right now, we do a pmap_kenter_pa(), we then get the pte (behind pmap's
back) and check for the cache inhibit bit (if needed). If it isn't what
we want (this is the normal case) then we change it ourselves, and do a
manual tlb shootdown (i386 was a bit more stupid about it than amd64,
too).

Instead, make it so that like on some other archs (sparc64 comes to
mind) you can pass in flags in the low bits of the physical address,
pmap then does everything correctly for you.

Discovered this when I had some code doing a lot of bus_space_maps(), it
was incredibly slow, and profilling was dominated by
pmap_tlb_shootwait();

discussed with kettenis@@, miod@@, toby@@ and art@@.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.14 2009/05/31 19:41:57 kettenis Exp $	*/
d859 1
a859 1
bus_space_copy_region_1(bus_space_tag_t t,
d894 1
a894 1
bus_space_copy_region_2(bus_space_tag_t t,
d929 1
a929 1
bus_space_copy_region_4(bus_space_tag_t t,
@


1.14
log
@Make iomem_ex cover the complete (48-bit) physical address space.  Makes
bigmem kernels work again.

ok oga@@, ariane@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.13 2009/03/26 19:04:56 oga Exp $	*/
d242 1
a242 2
	vaddr_t va, sva;
	pt_entry_t *pte;
a260 1
	sva = va;
d262 3
a264 11
	    pa += PAGE_SIZE, va += PAGE_SIZE, map_size -= PAGE_SIZE) {
		pmap_kenter_pa(va, pa, VM_PROT_READ | VM_PROT_WRITE);

		pte = kvtopte(va);
		if (flags & BUS_SPACE_MAP_CACHEABLE)
			*pte &= ~PG_N;
		else
			*pte |= PG_N;
	}
	pmap_tlb_shootrange(pmap_kernel(), sva, va);
	pmap_tlb_shootwait();
@


1.13
log
@Change amd64 bus_space_{map,unmap} to be the same as i386. While
theoretically the current solution of using the direct (and direct
uncached) maps is better for tlb pressure, two direct maps is dangerous,
especially when we support Page Attribute Tables (soon), since that will
cause illegal cache aliases. When that work is done a clever solution
may be worked out.

"reluctant ok, the uncached direct map is evil" art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.12 2009/03/10 15:03:16 oga Exp $	*/
d84 1
a84 1
	iomem_ex = extent_create("iomem", 0x0, 0xffffffff, M_DEVBUF,
@


1.12
log
@remove the _BUS_DMA_PRIVATE define from amd64 and i386.

a define needed to get to ``private'' functions that needs to be defined
5 or more times isn't much use and may cause namespace issues anyway.
Other archs will probably follow.

Discussed in portugal.  "Hell yes" weingart@@, ok kettenis@@, no
objections miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.11 2008/12/03 15:46:06 oga Exp $	*/
d141 1
a141 1
	error = x86_mem_add_mapping(bpa, size, 0, bshp);
d171 1
a171 1
	return (x86_mem_add_mapping(bpa, size, 0, bshp));
d222 1
a222 1
	error = x86_mem_add_mapping(bpa, size, 0, bshp);
d238 1
a238 1
x86_mem_add_mapping(bus_addr_t bpa, bus_size_t size, int cacheable,
d241 36
a276 4
	if (cacheable)
		*bshp = PMAP_DIRECT_MAP(bpa);
	else
		*bshp = PMAP_DIRECT_NC_MAP(bpa);
d294 1
d298 1
a298 1
	 * Find the correct extent and bus physical address.
d303 24
a326 12
		if (bsh >= atdevbase && (bsh + size) <= (atdevbase + IOM_SIZE)) {
			bpa = (bus_addr_t)ISA_PHYSADDR(bsh);
		} else {
			if (bsh >= PMAP_DIRECT_BASE_NC &&
			    bsh < PMAP_DIRECT_END_NC)
				bpa = PMAP_DIRECT_NC_UNMAP(bsh);
			else
				bpa = PMAP_DIRECT_UNMAP(bsh);
		}
	} else {
		panic("_bus_space_unmap: bad bus space tag");
	}
d328 2
a329 1
	if (adrp != NULL) {
a330 1
	}
d337 1
d348 3
d352 2
a353 5
		if (bsh >= atdevbase &&
		    (bsh + size) <= (atdevbase + IOM_SIZE)) {
			bpa = (bus_addr_t)ISA_PHYSADDR(bsh);
			goto ok;
		}
d355 15
a369 5
		if (bsh >= PMAP_DIRECT_BASE_NC &&
		    bsh < PMAP_DIRECT_END_NC)
			bpa = PMAP_DIRECT_NC_UNMAP(bsh);
		else
			bpa = PMAP_DIRECT_UNMAP(bsh);
@


1.11
log
@Remove the x86 and i386 prefixes to the bus_dma types. It's really quite
pointless and just makes the code different for no reason. This moves i386 and
amd64 bus_dma to being a lot closer to identical.

suggestion to just remove the prefix instead of merge them from deraadt@@.

no objections art@@, kettenis@@, ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.10 2008/11/21 23:16:16 oga Exp $	*/
a40 1
#define _BUS_DMA_PRIVATE
@


1.10
log
@de-inline the bus_space_* functions in favour of real functions

This shaves 135.7kb from amd64 GENERIC.MP. An afternoons worth of
testing proved to art, toby and myself that this doesn't slow things
down. i386 will follow shortly.

ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.9 2008/06/26 05:42:09 ray Exp $	*/
d41 1
a41 1
#define _X86_BUS_DMA_PRIVATE
@


1.9
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.8 2007/11/16 16:16:06 deraadt Exp $	*/
d361 569
@


1.8
log
@fix the bus_space #define nightmare, so that amd64 and i386 are much more
uniform. as a result shared code like acpi needs less #ifdef's
ok marco kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.7 2007/08/31 20:11:09 marco Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.7
log
@Add vaddr.

ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.6 2007/05/27 08:59:25 art Exp $	*/
d105 1
a105 1
x86_memio_map(bus_space_tag_t t, bus_addr_t bpa, bus_size_t size, int flags,
d121 1
a121 1
		panic("x86_memio_map: bad bus space tag");
d153 1
a153 1
			printf("x86_memio_map: pa 0x%lx, size 0x%lx\n",
d155 1
a155 1
			printf("x86_memio_map: can't free region\n");
d163 1
a163 1
_x86_memio_map(bus_space_tag_t t, bus_addr_t bpa, bus_size_t size, int flags,
d183 1
a183 1
x86_memio_alloc(bus_space_tag_t t, bus_addr_t rstart, bus_addr_t rend,
d199 1
a199 1
		panic("x86_memio_alloc: bad bus space tag");
d205 1
a205 1
		panic("x86_memio_alloc: bad region start/end");
d234 1
a234 1
			printf("x86_memio_alloc: pa 0x%lx, size 0x%lx\n",
d236 1
a236 1
			printf("x86_memio_alloc: can't free region\n");
d257 1
a257 1
 * void _x86_memio_unmap(bus_space_tag bst, bus_space_handle bsh,
d261 2
a262 2
 *   _x86_memio_map().  This function works nearly as same as
 *   x86_memio_unmap(), but this function does not ask kernel
d267 1
a267 1
_x86_memio_unmap(bus_space_tag_t t, bus_space_handle_t bsh, bus_size_t size,
d288 1
a288 1
		panic("_x86_memio_unmap: bad bus space tag");
d297 1
a297 1
x86_memio_unmap(bus_space_tag_t t, bus_space_handle_t bsh, bus_size_t size)
d323 1
a323 1
		panic("x86_memio_unmap: bad bus space tag");
d328 1
a328 1
		printf("x86_memio_unmap: %s 0x%lx, size 0x%lx\n",
d330 1
a330 1
		printf("x86_memio_unmap: can't free region\n");
d335 1
a335 1
x86_memio_free(bus_space_tag_t t, bus_space_handle_t bsh, bus_size_t size)
d338 2
a339 2
	/* x86_memio_unmap() does all that we need to do. */
	x86_memio_unmap(t, bsh, size);
d343 1
a343 1
x86_memio_subregion(bus_space_tag_t t, bus_space_handle_t bsh,
d352 1
a352 1
x86_memio_mmap(bus_space_tag_t t, bus_addr_t addr, off_t off, int prot, int flags)
@


1.6
log
@Use the direct maps (cached on uncached) for bus_space mappings.

jason@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.5 2007/05/25 16:22:11 art Exp $	*/
d116 2
@


1.5
log
@Change the old slow and complicated TLB shootdown code to new, fast and
simple. This is basically the same code as on i386 and basically the same
performance improvements.

This change also includes code to delay the freeing of ptps until they
have been properly shot.

in snaps for a week, no problems reported.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.4 2007/01/15 23:19:05 jsg Exp $	*/
d247 4
a250 52
	u_long pa, endpa;
	vaddr_t va, sva;
	pt_entry_t *pte;

	pa = trunc_page(bpa);
	endpa = round_page(bpa + size);

#ifdef DIAGNOSTIC
	if (endpa <= pa)
		panic("x86_mem_add_mapping: overflow");
#endif

	va = uvm_km_valloc(kernel_map, endpa - pa);
	if (va == 0)
		return (ENOMEM);

	sva = va;

	*bshp = (bus_space_handle_t)(va + (bpa & PGOFSET));

	for (; pa < endpa; pa += PAGE_SIZE, va += PAGE_SIZE) {
		pmap_kenter_pa(va, pa, VM_PROT_READ | VM_PROT_WRITE);

		/*
		 * PG_N doesn't exist on 386's, so we assume that
		 * the mainboard has wired up device space non-cacheable
		 * on those machines.
		 *
		 * Note that it's not necessary to use atomic ops to
		 * fiddle with the PTE here, because we don't care
		 * about mod/ref information.
		 *
		 * XXX should hand this bit to pmap_kenter_pa to
		 * save the extra invalidate!
		 *
		 * XXX extreme paranoia suggests tlb shootdown belongs here.
		 */
		if (pmap_cpu_has_pg_n()) {
			pte = kvtopte(va);
			if (cacheable)
				*pte &= ~PG_N;
			else
				*pte |= PG_N;
		}
	}
	if (!cacheable) {
		pmap_tlb_shootrange(pmap_kernel(), sva, sva + size);
		pmap_tlb_shootwait();
	}

	pmap_update(pmap_kernel());

a267 1
	u_long va, endva;
d279 5
a283 21

			va = trunc_page(bsh);
			endva = round_page(bsh + size);

#ifdef DIAGNOSTIC
			if (endva <= va) {
				panic("_x86_memio_unmap: overflow");
			}
#endif

			if (pmap_extract(pmap_kernel(), va, &bpa) == FALSE) {
				panic("_x86_memio_unmap:"
				    " wrong virtual address");
			}
			bpa += (bsh & PGOFSET);

			pmap_kremove(va, endva - va);
			/*
			 * Free the kernel virtual mapping.
			 */
			uvm_km_free(kernel_map, va, endva - va);
a297 1
	u_long va, endva;
d315 5
a319 16
		va = trunc_page(bsh);
		endva = round_page(bsh + size);

#ifdef DIAGNOSTIC
		if (endva <= va)
			panic("x86_memio_unmap: overflow");
#endif

		(void) pmap_extract(pmap_kernel(), va, &bpa);
		bpa += (bsh & PGOFSET);

		pmap_kremove(va, endva - va);
		/*
		 * Free the kernel virtual mapping.
		 */
		uvm_km_free(kernel_map, va, endva - va);
@


1.4
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.3 2005/10/26 18:46:06 martin Exp $	*/
d248 1
a248 1
	vaddr_t va;
a249 1
	int32_t cpumask = 0;
d263 2
a289 2
			pmap_tlb_shootdown(pmap_kernel(), va, *pte,
			    &cpumask);
d292 4
a296 1
	pmap_tlb_shootnow(cpumask);
@


1.3
log
@goodbye more Mach macros

help toby, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.2 2005/10/21 18:55:00 martin Exp $	*/
d76 1
a76 1
x86_bus_space_init()
d98 1
a98 1
x86_bus_space_mallocok()
d105 2
a106 6
x86_memio_map(t, bpa, size, flags, bshp)
	bus_space_tag_t t;
	bus_addr_t bpa;
	bus_size_t size;
	int flags;
	bus_space_handle_t *bshp;
d161 2
a162 6
_x86_memio_map(t, bpa, size, flags, bshp)
	bus_space_tag_t t;
	bus_addr_t bpa;
	bus_size_t size;
	int flags;
	bus_space_handle_t *bshp;
d181 3
a183 8
x86_memio_alloc(t, rstart, rend, size, alignment, boundary, flags,
    bpap, bshp)
	bus_space_tag_t t;
	bus_addr_t rstart, rend;
	bus_size_t size, alignment, boundary;
	int flags;
	bus_addr_t *bpap;
	bus_space_handle_t *bshp;
d244 2
a245 5
x86_mem_add_mapping(bpa, size, cacheable, bshp)
	bus_addr_t bpa;
	bus_size_t size;
	int cacheable;
	bus_space_handle_t *bshp;
d311 2
a312 5
_x86_memio_unmap(t, bsh, size, adrp)
	bus_space_tag_t t;
	bus_space_handle_t bsh;
	bus_size_t size;
	bus_addr_t *adrp;
d358 1
a358 4
x86_memio_unmap(t, bsh, size)
	bus_space_tag_t t;
	bus_space_handle_t bsh;
	bus_size_t size;
d408 1
a408 4
x86_memio_free(t, bsh, size)
	bus_space_tag_t t;
	bus_space_handle_t bsh;
	bus_size_t size;
d416 2
a417 5
x86_memio_subregion(t, bsh, offset, size, nbshp)
	bus_space_tag_t t;
	bus_space_handle_t bsh;
	bus_size_t offset, size;
	bus_space_handle_t *nbshp;
d425 1
a425 6
x86_memio_mmap(t, addr, off, prot, flags)
	bus_space_tag_t t;
	bus_addr_t addr;
	off_t off;
	int prot;
	int flags;
@


1.2
log
@use the MI trunc_page() and round_page() macros instead of rolling or own

ok weingart@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.1 2004/01/28 01:39:38 mickey Exp $	*/
d472 1
a472 1
	return (x86_btop(addr + off));
@


1.1
log
@an amd64 arch support.
hacked by art@@ from netbsd sources and then later debugged
by me into the shape where it can host itself.
no bootloader yet as needs redoing from the
recent advanced i386 sources (anyone? ;)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d268 2
a269 2
	pa = x86_trunc_page(bpa);
	endpa = x86_round_page(bpa + size);
d346 2
a347 2
			va = x86_trunc_page(bsh);
			endva = x86_round_page(bsh + size);
d401 2
a402 2
		va = x86_trunc_page(bsh);
		endva = x86_round_page(bsh + size);
@

