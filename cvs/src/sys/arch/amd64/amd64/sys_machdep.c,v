head	1.16;
access;
symbols
	OPENBSD_6_1:1.16.0.8
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.6
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.4
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.14.0.4
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.14.0.8
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.6
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.12.0.8
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.6
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.4
	OPENBSD_5_0:1.12.0.2
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.8.0.12
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.10
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.6
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.8
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.4
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.2
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.5.0.6
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.4
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.2
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.4.0.2
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.3.0.12
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.8
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.6
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.4
	OPENBSD_3_6_BASE:1.3
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	OPENBSD_3_5:1.3.0.2
	OPENBSD_3_5_BASE:1.3
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.16
date	2015.05.18.19.59.27;	author guenther;	state Exp;
branches;
next	1.15;
commitid	MLFvGCnCMKMdmAtY;

1.15
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.14;
commitid	p4LJxGKbi0BU2cG6;

1.14
date	2013.06.02.16.38.05;	author guenther;	state Exp;
branches;
next	1.13;

1.13
date	2013.05.05.19.25.57;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2011.04.13.02.49.12;	author guenther;	state Exp;
branches;
next	1.11;

1.11
date	2011.04.10.03.56.38;	author guenther;	state Exp;
branches;
next	1.10;

1.10
date	2011.04.05.21.14.00;	author guenther;	state Exp;
branches;
next	1.9;

1.9
date	2011.03.18.03.10.47;	author guenther;	state Exp;
branches;
next	1.8;

1.8
date	2008.06.26.05.42.09;	author ray;	state Exp;
branches;
next	1.7;

1.7
date	2008.06.11.09.22.38;	author phessler;	state Exp;
branches;
next	1.6;

1.6
date	2008.05.23.15.39.43;	author jasper;	state Exp;
branches;
next	1.5;

1.5
date	2007.01.15.23.19.05;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2006.06.30.21.34.45;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.27.23.45.55;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.21.03.00.23;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.28.01.39.39;	author mickey;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.06.05.23.09.24;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Do lazy update/reset of the FS.base and %[def]s segment registers: reseting
segment registers in cpu_switchto if the old thread had made it to userspace
and restoring FS.base only on first return to userspace since context switch.

ok mlarkin@@
@
text
@/*	$OpenBSD: sys_machdep.c,v 1.15 2015/03/14 03:38:46 jsg Exp $	*/
/*	$NetBSD: sys_machdep.c,v 1.1 2003/04/26 18:39:32 fvdl Exp $	*/

/*-
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Charles M. Hannum.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/ioctl.h>
#include <sys/file.h>
#include <sys/time.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/uio.h>
#include <sys/kernel.h>
#include <sys/buf.h>
#include <sys/signal.h>

#include <sys/mount.h>
#include <sys/syscallargs.h>

#include <uvm/uvm_extern.h>

#include <machine/cpufunc.h>
#include <machine/psl.h>
#include <machine/reg.h>
#include <machine/sysarch.h>
#include <machine/tcb.h>

#if defined(PERFCTRS) && 0
#include <machine/pmc.h>
#endif

extern struct vm_map *kernel_map;

int amd64_iopl(struct proc *, void *, register_t *);

#ifdef APERTURE
extern int allowaperture;
#endif

int
amd64_iopl(struct proc *p, void *args, register_t *retval)
{
	int error;
	struct trapframe *tf = p->p_md.md_regs;
	struct amd64_iopl_args ua;

	if ((error = suser(p, 0)) != 0)
		return error;

#ifdef APERTURE
	if (!allowaperture && securelevel > 0)
		return EPERM;
#else
	if (securelevel > 0)
		return EPERM;
#endif

	if ((error = copyin(args, &ua, sizeof(ua))) != 0)
		return error;

	if (ua.iopl)
		tf->tf_rflags |= PSL_IOPL;
	else
		tf->tf_rflags &= ~PSL_IOPL;

	return 0;
}

int
amd64_get_fsbase(struct proc *p, void *args)
{
	void *base = tcb_get(p);

	return (copyout(&base, args, sizeof(base)));
}

int
amd64_set_fsbase(struct proc *p, void *args)
{
	int error;
	void *base;

	if ((error = copyin(args, &base, sizeof(base))) != 0)
		return (error);

	tcb_set(p, base);
	return 0;
}

int
sys_sysarch(struct proc *p, void *v, register_t *retval)
{
	struct sys_sysarch_args /* {
		syscallarg(int) op;
		syscallarg(void *) parms;
	} */ *uap = v;
	int error = 0;

	switch(SCARG(uap, op)) {
	case AMD64_IOPL: 
		error = amd64_iopl(p, SCARG(uap, parms), retval);
		break;

#if defined(PERFCTRS) && 0
	case AMD64_PMC_INFO:
		error = pmc_info(p, SCARG(uap, parms), retval);
		break;

	case AMD64_PMC_STARTSTOP:
		error = pmc_startstop(p, SCARG(uap, parms), retval);
		break;

	case AMD64_PMC_READ:
		error = pmc_read(p, SCARG(uap, parms), retval);
		break;
#endif

	case AMD64_GET_FSBASE: 
		error = amd64_get_fsbase(p, SCARG(uap, parms));
		break;

	case AMD64_SET_FSBASE: 
		error = amd64_set_fsbase(p, SCARG(uap, parms));
		break;

	default:
		error = EINVAL;
		break;
	}
	return (error);
}
@


1.15
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.14 2013/06/02 16:38:05 guenther Exp $	*/
d54 1
d100 3
a102 2
	return copyout(&p->p_addr->u_pcb.pcb_fsbase, args,
	    sizeof(p->p_addr->u_pcb.pcb_fsbase));
d109 1
a109 1
	uint64_t base;
d114 1
a114 4
	if (base >= VM_MAXUSER_ADDRESS)
		return (EINVAL);

	p->p_addr->u_pcb.pcb_fsbase = base;
@


1.14
log
@Don't need gdt.h here
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.13 2013/05/05 19:25:57 tedu Exp $	*/
a49 1
#include <machine/cpu.h>
@


1.13
log
@remove never used get/set ioperm sysarch functions. ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.12 2011/04/13 02:49:12 guenther Exp $	*/
a51 1
#include <machine/gdt.h>
@


1.12
log
@Unrevert the FS.base diff: the issues were actually elsewhere
Additional testing by jasper@@ and pea@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.11 2011/04/10 03:56:38 guenther Exp $	*/
a62 4
#if 0
int amd64_get_ioperm(struct proc *, void *, register_t *);
int amd64_set_ioperm(struct proc *, void *, register_t *);
#endif
a97 36
#if 0

int
amd64_get_ioperm(struct proc *p, void *args, register_t *retval)
{
	int error;
	struct pcb *pcb = &p->p_addr->u_pcb;
	struct amd64_get_ioperm_args ua;

	if ((error = copyin(args, &ua, sizeof(ua))) != 0)
		return (error);

	return copyout(pcb->pcb_iomap, ua.iomap, sizeof(pcb->pcb_iomap));
}

int
amd64_set_ioperm(struct proc *p, void *args, register_t *retval)
{
	int error;
	struct pcb *pcb = &p->p_addr->u_pcb;
	struct amd64_set_ioperm_args ua;

	if (securelevel > 1)
		return EPERM;

	if ((error = suser(p, 0)) != 0)
		return error;

	if ((error = copyin(args, &ua, sizeof(ua))) != 0)
		return (error);

	return copyin(ua.iomap, pcb->pcb_iomap, sizeof(pcb->pcb_iomap));
}

#endif

a133 10

#if 0
	case AMD64_GET_IOPERM: 
		error = amd64_get_ioperm(p, SCARG(uap, parms), retval);
		break;

	case AMD64_SET_IOPERM: 
		error = amd64_set_ioperm(p, SCARG(uap, parms), retval);
		break;
#endif
@


1.11
log
@Revert bulk of the FS.base diff, as it causes issues on some machines
and the problem isn't obvious yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.10 2011/04/05 21:14:00 guenther Exp $	*/
d139 23
d198 9
@


1.10
log
@Add support for per-rthread base-offset for the %fs selector on amd64.
Add pcb_fsbase to the PCB for tracking what the value for the thread
is, and ci_cur_fsbase to struct cpu_info for tracking the CPU's current
value for FS.base, then on return to user-space, skip the setting if the
CPU has the right value already.  Non-threaded processes without TLS leave
FS.base zero, which can be conveniently optimized: setting %fs zeros
FS.base for fewer cycles than wrmsr.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.9 2011/03/18 03:10:47 guenther Exp $	*/
a138 23
amd64_get_fsbase(struct proc *p, void *args)
{
	return copyout(&p->p_addr->u_pcb.pcb_fsbase, args,
	    sizeof(p->p_addr->u_pcb.pcb_fsbase));
}

int
amd64_set_fsbase(struct proc *p, void *args)
{
	int error;
	uint64_t base;

	if ((error = copyin(args, &base, sizeof(base))) != 0)
		return (error);

	if (base >= VM_MAXUSER_ADDRESS)
		return (EINVAL);

	p->p_addr->u_pcb.pcb_fsbase = base;
	return 0;
}

int
a174 9

	case AMD64_GET_FSBASE: 
		error = amd64_get_fsbase(p, SCARG(uap, parms));
		break;

	case AMD64_SET_FSBASE: 
		error = amd64_set_fsbase(p, SCARG(uap, parms));
		break;

@


1.9
log
@Old-style MTRRs were never used on amd64, so remove the remaining traces
of them, as well as some other unused proc md_flags bits: MDP_COMPAT and
MDP_SYSCALL.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.8 2008/06/26 05:42:09 ray Exp $	*/
d139 23
d198 9
@


1.8
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.7 2008/06/11 09:22:38 phessler Exp $	*/
a55 1
#include <machine/mtrr.h>
@


1.7
log
@Synchronize the MTRR API with i386, and enable

"just commit it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.6 2008/05/23 15:39:43 jasper Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.6
log
@- remove USER_LDT, it was never in a state where it would copile, nor will
we support i386-compat mode on amd64.

agreed by beck@@, dlg@@, kettenis@@
ok deraadt@@, tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.5 2007/01/15 23:19:05 jsg Exp $	*/
a75 2
int amd64_get_mtrr(struct proc *, void *, register_t *);
int amd64_set_mtrr(struct proc *, void *, register_t *);
a145 57
#ifdef MTRR

int
amd64_get_mtrr(struct proc *p, void *args, register_t *retval)
{
	struct amd64_get_mtrr_args ua;
	int error, n;

	if (mtrr_funcs == NULL)
		return ENOSYS;

	error = copyin(args, &ua, sizeof ua);
	if (error != 0)
		return error;

	error = copyin(ua.n, &n, sizeof n);
	if (error != 0)
		return error;

	error = mtrr_get(ua.mtrrp, &n, p, MTRR_GETSET_USER);

	copyout(&n, ua.n, sizeof (int));

	return error;
}

int
amd64_set_mtrr(struct proc *p, void *args, register_t *retval)
{
	int error, n;
	struct amd64_set_mtrr_args ua;

	if (mtrr_funcs == NULL)
		return ENOSYS;

	error = suser(p, 0);
	if (error != 0)
		return error;

	error = copyin(args, &ua, sizeof ua);
	if (error != 0)
		return error;

	error = copyin(ua.n, &n, sizeof n);
	if (error != 0)
		return error;

	error = mtrr_set(ua.mtrrp, &n, p, MTRR_GETSET_USER);
	if (n != 0)
		mtrr_commit();

	copyout(&n, ua.n, sizeof n);

	return error;
}
#endif

a166 8
		break;
#endif
#ifdef MTRR
	case AMD64_GET_MTRR:
		error = amd64_get_mtrr(p, SCARG(uap, parms), retval);
		break;
	case AMD64_SET_MTRR:
		error = amd64_set_mtrr(p, SCARG(uap, parms), retval);
@


1.5
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.4 2006/06/30 21:34:45 miod Exp $	*/
a39 4
/*
 * XXXfvdl check USER_LDT
 */

a78 195
/* XXXfvdl disabled USER_LDT stuff until I check this stuff */

#if defined(USER_LDT) && 0
int
amd64_get_ldt(struct proc *p, void *args, register_t *retval)
{
	int error;
	pmap_t pmap = p->p_vmspace->vm_map.pmap;
	int nldt, num;
	union descriptor *lp;
	struct amd64_get_ldt_args ua;

	if ((error = copyin(args, &ua, sizeof(ua))) != 0)
		return (error);

#ifdef	LDT_DEBUG
	printf("amd64_get_ldt: start=%d num=%d descs=%p\n", ua.start,
	    ua.num, ua.desc);
#endif

	if (ua.start < 0 || ua.num < 0)
		return (EINVAL);

	/*
	 * XXX LOCKING.
	 */

	if (pmap->pm_flags & PMF_USER_LDT) {
		nldt = pmap->pm_ldt_len;
		lp = pmap->pm_ldt;
	} else {
		nldt = NLDT;
		lp = ldt;
	}

	if (ua.start > nldt)
		return (EINVAL);

	lp += ua.start;
	num = min(ua.num, nldt - ua.start);

	error = copyout(lp, ua.desc, num * sizeof(union descriptor));
	if (error)
		return (error);

	*retval = num;
	return (0);
}

int
amd64_set_ldt(struct proc *p, void *args, register_t *retval)
{
	int error, i, n;
	struct pcb *pcb = &p->p_addr->u_pcb;
	pmap_t pmap = p->p_vmspace->vm_map.pmap;
	struct amd64_set_ldt_args ua;
	union descriptor desc;

	if ((error = copyin(args, &ua, sizeof(ua))) != 0)
		return (error);

#ifdef	LDT_DEBUG
	printf("amd64_set_ldt: start=%d num=%d descs=%p\n", ua.start,
	    ua.num, ua.desc);
#endif

	if (ua.start < 0 || ua.num < 0)
		return (EINVAL);
	if (ua.start > 8192 || (ua.start + ua.num) > 8192)
		return (EINVAL);

	/*
	 * XXX LOCKING
	 */

	/* allocate user ldt */
	if (pmap->pm_ldt == 0 || (ua.start + ua.num) > pmap->pm_ldt_len) {
		size_t old_len, new_len;
		union descriptor *old_ldt, *new_ldt;

		if (pmap->pm_flags & PMF_USER_LDT) {
			old_len = pmap->pm_ldt_len * sizeof(union descriptor);
			old_ldt = pmap->pm_ldt;
		} else {
			old_len = NLDT * sizeof(union descriptor);
			old_ldt = ldt;
			pmap->pm_ldt_len = 512;
		}
		while ((ua.start + ua.num) > pmap->pm_ldt_len)
			pmap->pm_ldt_len *= 2;
		new_len = pmap->pm_ldt_len * sizeof(union descriptor);
		new_ldt = (union descriptor *)uvm_km_alloc(kernel_map, new_len);
		memcpy(new_ldt, old_ldt, old_len);
		memset((caddr_t)new_ldt + old_len, 0, new_len - old_len);
		pmap->pm_ldt = new_ldt;

		if (pmap->pm_flags & PCB_USER_LDT)
			ldt_free(pmap);
		else
			pmap->pm_flags |= PCB_USER_LDT;
		ldt_alloc(pmap, new_ldt, new_len);
		pcb->pcb_ldt_sel = pmap->pm_ldt_sel;
		if (pcb == curpcb)
			lldt(pcb->pcb_ldt_sel);

		/*
		 * XXX Need to notify other processors which may be
		 * XXX currently using this pmap that they need to
		 * XXX re-load the LDT.
		 */

		if (old_ldt != ldt)
			uvm_km_free(kernel_map, (vaddr_t)old_ldt, old_len);
#ifdef LDT_DEBUG
		printf("amd64_set_ldt(%d): new_ldt=%p\n", p->p_pid, new_ldt);
#endif
	}

	if (pcb == curpcb)
		savectx(curpcb);
	error = 0;

	/* Check descriptors for access violations. */
	for (i = 0, n = ua.start; i < ua.num; i++, n++) {
		if ((error = copyin(&ua.desc[i], &desc, sizeof(desc))) != 0)
			return (error);

		switch (desc.sd.sd_type) {
		case SDT_SYSNULL:
			desc.sd.sd_p = 0;
			break;
		case SDT_SYS286CGT:
		case SDT_SYS386CGT:
			/*
			 * Only allow call gates targeting a segment
			 * in the LDT or a user segment in the fixed
			 * part of the gdt.  Segments in the LDT are
			 * constrained (below) to be user segments.
			 */
			if (desc.gd.gd_p != 0 && !ISLDT(desc.gd.gd_selector) &&
			    ((IDXSEL(desc.gd.gd_selector) >= NGDT) ||
			     (gdt[IDXSEL(desc.gd.gd_selector)].sd.sd_dpl !=
				 SEL_UPL)))
				return (EACCES);
			break;
		case SDT_MEMEC:
		case SDT_MEMEAC:
		case SDT_MEMERC:
		case SDT_MEMERAC:
			/* Must be "present" if executable and conforming. */
			if (desc.sd.sd_p == 0)
				return (EACCES);
			break;
		case SDT_MEMRO:
		case SDT_MEMROA:
		case SDT_MEMRW:
		case SDT_MEMRWA:
		case SDT_MEMROD:
		case SDT_MEMRODA:
		case SDT_MEMRWD:
		case SDT_MEMRWDA:
		case SDT_MEME:
		case SDT_MEMEA:
		case SDT_MEMER:
		case SDT_MEMERA:
			break;
		default:
			/* Only care if it's present. */
			if (desc.sd.sd_p != 0)
				return (EACCES);
			break;
		}

		if (desc.sd.sd_p != 0) {
			/* Only user (ring-3) descriptors may be present. */
			if (desc.sd.sd_dpl != SEL_UPL)
				return (EACCES);
		}
	}

	/* Now actually replace the descriptors. */
	for (i = 0, n = ua.start; i < ua.num; i++, n++) {
		if ((error = copyin(&ua.desc[i], &desc, sizeof(desc))) != 0)
			goto out;

		pmap->pm_ldt[n] = desc;
	}

	*retval = ua.start;

out:
	return (error);
}
#endif	/* USER_LDT */

a214 9
#if defined(USER_LDT) && 0
	case AMD64_GET_LDT: 
		error = amd64_get_ldt(p, SCARG(uap, parms), retval);
		break;

	case AMD64_SET_LDT: 
		error = amd64_set_ldt(p, SCARG(uap, parms), retval);
		break;
#endif
@


1.4
log
@Make routines which may set PSL_IOPL consistent wrt the securelevel for
which this is allowed; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.3 2004/02/27 23:45:55 deraadt Exp $	*/
d87 1
a87 4
amd64_get_ldt(p, args, retval)
	struct proc *p;
	void *args;
	register_t *retval;
d133 1
a133 4
amd64_set_ldt(p, args, retval)
	struct proc *p;
	void *args;
	register_t *retval;
d314 1
a314 4
amd64_get_ioperm(p, args, retval)
	struct proc *p;
	void *args;
	register_t *retval;
d327 1
a327 4
amd64_set_ioperm(p, args, retval)
	struct proc *p;
	void *args;
	register_t *retval;
@


1.3
log
@move to amd64_() functions
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.2 2004/02/21 03:00:23 deraadt Exp $	*/
d302 1
a302 1
	if (securelevel > 1)
@


1.2
log
@aperture stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.1 2004/01/28 01:39:39 mickey Exp $	*/
d76 2
a77 2
int x86_64_get_ioperm(struct proc *, void *, register_t *);
int x86_64_set_ioperm(struct proc *, void *, register_t *);
d79 3
a81 3
int x86_64_iopl(struct proc *, void *, register_t *);
int x86_64_get_mtrr(struct proc *, void *, register_t *);
int x86_64_set_mtrr(struct proc *, void *, register_t *);
d87 1
a87 1
x86_64_get_ldt(p, args, retval)
d96 1
a96 1
	struct x86_64_get_ldt_args ua;
d102 1
a102 1
	printf("x86_64_get_ldt: start=%d num=%d descs=%p\n", ua.start,
d136 1
a136 1
x86_64_set_ldt(p, args, retval)
d144 1
a144 1
	struct x86_64_set_ldt_args ua;
d151 1
a151 1
	printf("x86_64_set_ldt: start=%d num=%d descs=%p\n", ua.start,
d203 1
a203 1
		printf("x86_64_set_ldt(%d): new_ldt=%p\n", p->p_pid, new_ldt);
d289 1
a289 1
x86_64_iopl(struct proc *p, void *args, register_t *retval)
d293 1
a293 1
	struct x86_64_iopl_args ua;
d320 1
a320 1
x86_64_get_ioperm(p, args, retval)
d327 1
a327 1
	struct x86_64_get_ioperm_args ua;
d336 1
a336 1
x86_64_set_ioperm(p, args, retval)
d343 1
a343 1
	struct x86_64_set_ioperm_args ua;
d362 1
a362 1
x86_64_get_mtrr(struct proc *p, void *args, register_t *retval)
d364 1
a364 1
	struct x86_64_get_mtrr_args ua;
d386 1
a386 1
x86_64_set_mtrr(struct proc *p, void *args, register_t *retval)
d389 1
a389 1
	struct x86_64_set_mtrr_args ua;
d427 2
a428 2
	case X86_64_GET_LDT: 
		error = x86_64_get_ldt(p, SCARG(uap, parms), retval);
d431 2
a432 2
	case X86_64_SET_LDT: 
		error = x86_64_set_ldt(p, SCARG(uap, parms), retval);
d435 2
a436 2
	case X86_64_IOPL: 
		error = x86_64_iopl(p, SCARG(uap, parms), retval);
d440 2
a441 2
	case X86_64_GET_IOPERM: 
		error = x86_64_get_ioperm(p, SCARG(uap, parms), retval);
d444 2
a445 2
	case X86_64_SET_IOPERM: 
		error = x86_64_set_ioperm(p, SCARG(uap, parms), retval);
d449 2
a450 2
	case X86_64_GET_MTRR:
		error = x86_64_get_mtrr(p, SCARG(uap, parms), retval);
d452 2
a453 2
	case X86_64_SET_MTRR:
		error = x86_64_set_mtrr(p, SCARG(uap, parms), retval);
d458 1
a458 1
	case X86_64_PMC_INFO:
d462 1
a462 1
	case X86_64_PMC_STARTSTOP:
d466 1
a466 1
	case X86_64_PMC_READ:
@


1.1
log
@an amd64 arch support.
hacked by art@@ from netbsd sources and then later debugged
by me into the shape where it can host itself.
no bootloader yet as needs redoing from the
recent advanced i386 sources (anyone? ;)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d284 4
d295 7
d304 1
a304 3

	if ((error = suser(p, 0)) != 0)
		return error;
@


1.1.2.1
log
@Merge with the trunk
@
text
@d76 2
a77 2
int amd64_get_ioperm(struct proc *, void *, register_t *);
int amd64_set_ioperm(struct proc *, void *, register_t *);
d79 3
a81 3
int amd64_iopl(struct proc *, void *, register_t *);
int amd64_get_mtrr(struct proc *, void *, register_t *);
int amd64_set_mtrr(struct proc *, void *, register_t *);
d87 1
a87 1
amd64_get_ldt(p, args, retval)
d96 1
a96 1
	struct amd64_get_ldt_args ua;
d102 1
a102 1
	printf("amd64_get_ldt: start=%d num=%d descs=%p\n", ua.start,
d136 1
a136 1
amd64_set_ldt(p, args, retval)
d144 1
a144 1
	struct amd64_set_ldt_args ua;
d151 1
a151 1
	printf("amd64_set_ldt: start=%d num=%d descs=%p\n", ua.start,
d203 1
a203 1
		printf("amd64_set_ldt(%d): new_ldt=%p\n", p->p_pid, new_ldt);
a283 4
#ifdef APERTURE
extern int allowaperture;
#endif

d285 1
a285 1
amd64_iopl(struct proc *p, void *args, register_t *retval)
d289 4
a292 1
	struct amd64_iopl_args ua;
a296 8
#ifdef APERTURE
	if (!allowaperture && securelevel > 0)
		return EPERM;
#else
	if (securelevel > 1)
		return EPERM;
#endif

d311 1
a311 1
amd64_get_ioperm(p, args, retval)
d318 1
a318 1
	struct amd64_get_ioperm_args ua;
d327 1
a327 1
amd64_set_ioperm(p, args, retval)
d334 1
a334 1
	struct amd64_set_ioperm_args ua;
d353 1
a353 1
amd64_get_mtrr(struct proc *p, void *args, register_t *retval)
d355 1
a355 1
	struct amd64_get_mtrr_args ua;
d377 1
a377 1
amd64_set_mtrr(struct proc *p, void *args, register_t *retval)
d380 1
a380 1
	struct amd64_set_mtrr_args ua;
d418 2
a419 2
	case AMD64_GET_LDT: 
		error = amd64_get_ldt(p, SCARG(uap, parms), retval);
d422 2
a423 2
	case AMD64_SET_LDT: 
		error = amd64_set_ldt(p, SCARG(uap, parms), retval);
d426 2
a427 2
	case AMD64_IOPL: 
		error = amd64_iopl(p, SCARG(uap, parms), retval);
d431 2
a432 2
	case AMD64_GET_IOPERM: 
		error = amd64_get_ioperm(p, SCARG(uap, parms), retval);
d435 2
a436 2
	case AMD64_SET_IOPERM: 
		error = amd64_set_ioperm(p, SCARG(uap, parms), retval);
d440 2
a441 2
	case AMD64_GET_MTRR:
		error = amd64_get_mtrr(p, SCARG(uap, parms), retval);
d443 2
a444 2
	case AMD64_SET_MTRR:
		error = amd64_set_mtrr(p, SCARG(uap, parms), retval);
d449 1
a449 1
	case AMD64_PMC_INFO:
d453 1
a453 1
	case AMD64_PMC_STARTSTOP:
d457 1
a457 1
	case AMD64_PMC_READ:
@


