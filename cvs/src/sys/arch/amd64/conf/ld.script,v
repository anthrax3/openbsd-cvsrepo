head	1.4;
access;
symbols
	OPENBSD_6_1:1.4.0.4
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.3.0.6
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.2
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.4
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.2.0.2
	OPENBSD_5_7_BASE:1.2;
locks; strict;
comment	@# @;


1.4
date	2016.09.03.13.13.07;	author deraadt;	state Exp;
branches;
next	1.3;
commitid	MO2vedHMyHNyR6Mg;

1.3
date	2015.04.28.22.29.24;	author kettenis;	state Exp;
branches;
next	1.2;
commitid	F35wzl6T2bcBwG3s;

1.2
date	2014.12.21.16.27.07;	author mlarkin;	state Exp;
branches;
next	1.1;
commitid	dB4lAFOCpyuORTUm;

1.1
date	2014.11.18.01.11.13;	author deraadt;	state Exp;
branches;
next	;
commitid	yKb6V6q931TzDlbT;


desc
@@


1.4
log
@Make .openbsd.randomdata section RO.  Highlight is that the stack protector
cookie becomes readonly, spraying over it in KVA becomes more difficult.
amd64 version from guenther, i386 version by myself
ok guenther kettenis
@
text
@/*	$OpenBSD: ld.script,v 1.3 2015/04/28 22:29:24 kettenis Exp $	*/

/*
 * Copyright (c) 2009 Tobias Weingartner <weingart@@tepid.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

OUTPUT_FORMAT("elf64-x86-64", "elf64-x86-64", "elf64-x86-64")
OUTPUT_ARCH(i386:x86-64)

/* Define how we want out ELF binary to look like. */
PHDRS
{
	text PT_LOAD FILEHDR PHDRS;
	rodata PT_LOAD;
	data PT_LOAD;
	bss PT_LOAD;
	openbsd_randomize PT_OPENBSD_RANDOMIZE;
}

/*
 * If we want the text/rodata/data sections aligned on 2M boundaries,
 * we could use the following instead.  Note, file size would increase
 * due to necessary padding.
 *
 *__ALIGN_SIZE = 0x200000;
 */
__ALIGN_SIZE = 0x1000;
__kernel_base_virt = 0xffffffff81000000 + SIZEOF_HEADERS;
__kernel_base_phys = __kernel_base_virt & 0x7fffffff;

/* We use physical address to jump to kernel */
start_phys = LOADADDR(.text) + (start - __kernel_base_virt);
ENTRY(start_phys)
SECTIONS
{
	__kernel_text_virt = __kernel_base_virt;
	__kernel_text_phys = __kernel_base_phys;
	.text (__kernel_text_virt) : AT (__kernel_text_phys)
	{
		__text_start = ABSOLUTE(.) & 0xfffffffffffff000;
		__text_size = SIZEOF(.text);
		__text_load = LOADADDR(.text);
		locore.o(.text)
		*(.text .text.*)
	} :text
	PROVIDE (__etext = .);
	PROVIDE (etext = .);
	_etext = .;

	/* Move rodata to the next page, so we can nuke X and W bit on them */
	. = ALIGN(__ALIGN_SIZE);
	__kernel_rodata_virt = .;
	__kernel_rodata_phys = . & 0x7fffffff;
	.rodata (__kernel_rodata_virt) : AT (__kernel_rodata_phys)
	{
		__rodata_start = ABSOLUTE(.);
		__rodata_size = SIZEOF(.rodata);
		__rodata_load = LOADADDR(.rodata);
		*(.rodata .rodata.*)
		*(.codepatch)
		*(.codepatchend)
	} :rodata
	. = ALIGN(0x1000);
	__kernel_randomdata_phys = . & 0x7fffffff;
	.openbsd.randomdata : AT (__kernel_randomdata_phys)
	{
		*(.openbsd.randomdata)
	} :rodata :openbsd_randomize
	. = ALIGN(0x1000);
	PROVIDE (erodata = .);
	_erodata = .;

	/* Move data to the next page, so we can add W bit on them */
	. = ALIGN(__ALIGN_SIZE);
	__kernel_data_virt = .;
	__kernel_data_phys = . & 0x7fffffff;
	.data (__kernel_data_virt) : AT (__kernel_data_phys)
	{
		__data_start = ABSOLUTE(.);
		__data_size = SIZEOF(.data);
		__data_load = LOADADDR(.data);
		*(.data .data.*)
	} :data
	. = ALIGN(0x1000);
	PROVIDE (edata = .);
	_edata = .;

	/* BSS starts right after padded data */
	__kernel_bss_virt = .;
	__kernel_bss_phys = . & 0x7fffffff;
	.bss (__kernel_bss_virt) : AT (__kernel_bss_phys)
	{
		__bss_start = ABSOLUTE(.);
		__bss_size = SIZEOF(.bss);
		__bss_load = LOADADDR(.bss);
		*(.bss .bss.*)
		*(COMMON)
		/* Align after .bss to ensure correct alignment even if the
		 * .bss section disappears because there are no input sections.
		 */
		. = ALIGN(0x1000);
	} :bss
	__kernel_bss_end = .;
	. = ALIGN(0x200000);
	_end = .;
	PROVIDE (end = .);
	__kernel_end_phys = . & 0x7fffffff;

	/* XXX - hack alert, since we are not C++, nuke these */
	/DISCARD/ :
	{
		*(.note.GNU-stack)
		*(.eh_frame)
	}
}
@


1.3
log
@Explicitly include .codepatch and .codepatchend in .rodata such that
the binutils 2.17 linker doesn't make them disappear.

ok deraadt@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ld.script,v 1.2 2014/12/21 16:27:07 mlarkin Exp $	*/
d29 1
a29 1
	openbsd_randomize 0x65a3dbe6; /* PT_OPENBSD_RANDOMIZE */
d75 7
a95 6
	. = ALIGN(0x1000);
	__kernel_randomdata_phys = . & 0x7fffffff;
	.openbsd.randomdata : AT (__kernel_randomdata_phys)
	{
		*(.openbsd.randomdata)
	} :data :openbsd_randomize
@


1.2
log
@Prevent writing to the kernel area via the direct map. We do this by padding
the end of the kernel area to 2MB, so that the direct map pages can then
have the W permission removed (X permission was already removed in a previous
diff). This creates a VA hole at the end of bss, so adjust for that since
that's where symbols get loaded by the bootloader (for now, map that region
RO until the boot loader can be updated to place the symbols at "end" instead
of "end of bss").

with help from and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ld.script,v 1.1 2014/11/18 01:11:13 deraadt Exp $	*/
d72 2
a126 1

@


1.1
log
@rename ld.script to same name as other architectures
@
text
@d1 1
a1 1
/*	$OpenBSD: kern.ldscript,v 1.4 2014/11/17 23:54:32 guenther Exp $	*/
d107 2
a108 4
		/* Align here to ensure that the .bss section occupies space
		 * up to _end.  Align after .bss to ensure correct alignment
		 * even if the .bss section disappears because there are no
		 * input sections.
d110 1
a110 1
		. = ALIGN(64 / 8);
d112 2
a113 1
	. = ALIGN(64 / 8);
d116 1
@

