head	1.28;
access;
symbols
	OPENBSD_6_1:1.28.0.8
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.28.0.4
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.28.0.2
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.27.0.4
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.24.0.4
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.22.0.16
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.12
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.10
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.8
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.6
	OPENBSD_5_0:1.22.0.4
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.2
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.21.0.2
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.4
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.19.0.2
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.14.0.2
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.12.0.2
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.11.0.2
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.7.0.2
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.3.0.6
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.4
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	OPENBSD_3_5:1.1.0.4
	OPENBSD_3_5_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.28
date	2015.09.27.10.12.09;	author semarie;	state Exp;
branches;
next	1.27;
commitid	1dIhYMDj5NezOASM;

1.27
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.26;
commitid	p4LJxGKbi0BU2cG6;

1.26
date	2015.01.24.15.13.55;	author kettenis;	state Exp;
branches;
next	1.25;
commitid	Ol0pICcR5PormuCL;

1.25
date	2014.12.22.03.13.45;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	vxoaY1rimsNqupqJ;

1.24
date	2014.07.13.21.51.12;	author kettenis;	state Exp;
branches;
next	1.23;
commitid	9A5SNRwpm0B73qKM;

1.23
date	2014.07.12.18.44.41;	author tedu;	state Exp;
branches;
next	1.22;
commitid	uKVPYMN2MLxdZxzH;

1.22
date	2010.11.20.20.58.51;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2010.03.25.22.44.57;	author oga;	state Exp;
branches;
next	1.20;

1.20
date	2009.03.10.15.03.17;	author oga;	state Exp;
branches;
next	1.19;

1.19
date	2008.12.11.17.07.14;	author oga;	state Exp;
branches;
next	1.18;

1.18
date	2008.12.10.20.26.56;	author oga;	state Exp;
branches;
next	1.17;

1.17
date	2008.12.06.19.59.38;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2008.12.06.17.46.52;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2008.12.03.15.46.06;	author oga;	state Exp;
branches;
next	1.14;

1.14
date	2008.06.26.05.42.09;	author ray;	state Exp;
branches;
next	1.13;

1.13
date	2007.09.17.15.34.38;	author chl;	state Exp;
branches;
next	1.12;

1.12
date	2007.04.28.03.55.40;	author jsg;	state Exp;
branches;
next	1.11;

1.11
date	2007.01.15.23.19.05;	author jsg;	state Exp;
branches;
next	1.10;

1.10
date	2006.11.25.16.59.31;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	2006.06.08.03.18.08;	author weingart;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.08.19.44.02;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.01.21.51.39;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2005.12.13.00.18.19;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2005.12.11.20.13.33;	author krw;	state Exp;
branches;
next	1.4;

1.4
date	2005.09.19.01.28.04;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.28.01.52.26;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.13.21.49.13;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.28.01.39.39;	author mickey;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.06.06.05.24.01;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.28
log
@free(x, 0) cleanup:
  - set size argument of free()
  - remove pointless if expression around free() call

ok guenther@@
@
text
@/*	$OpenBSD: isa_machdep.c,v 1.27 2015/03/14 03:38:46 jsg Exp $	*/
/*	$NetBSD: isa_machdep.c,v 1.22 1997/06/12 23:57:32 thorpej Exp $	*/

#define ISA_DMA_STATS

/*-
 * Copyright (c) 1996, 1997 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*-
 * Copyright (c) 1993, 1994, 1996, 1997
 *	Charles M. Hannum.  All rights reserved.
 * Copyright (c) 1991 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * William Jolitz.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)isa.c	7.2 (Berkeley) 5/13/91
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/syslog.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/proc.h>

#include <uvm/uvm_extern.h>

#include "ioapic.h"

#if NIOAPIC > 0
#include <machine/i82093var.h>
#include <machine/mpbiosvar.h>
#endif

#include <machine/bus.h>

#include <machine/intr.h>
#include <machine/pio.h>
#include <machine/cpufunc.h>
#include <machine/i8259.h>

#include <dev/isa/isavar.h>
#if 0
#include <dev/isa/isadmavar.h>
#endif
#include <i386/isa/isa_machdep.h>

#include "isadma.h"

extern	paddr_t avail_end;

#define	IDTVEC(name)	__CONCAT(X,name)
/* default interrupt vector table entries */
typedef int (*vector)(void);
extern vector IDTVEC(intr)[];
void isa_strayintr(int);
int fakeintr(void *);

#if NISADMA > 0
int	_isa_bus_dmamap_create(bus_dma_tag_t, bus_size_t, int,
	    bus_size_t, bus_size_t, int, bus_dmamap_t *);
void	_isa_bus_dmamap_destroy(bus_dma_tag_t, bus_dmamap_t);
int	_isa_bus_dmamap_load(bus_dma_tag_t, bus_dmamap_t, void *,
	    bus_size_t, struct proc *, int);
int	_isa_bus_dmamap_load_mbuf(bus_dma_tag_t, bus_dmamap_t,
	    struct mbuf *, int);
int	_isa_bus_dmamap_load_uio(bus_dma_tag_t, bus_dmamap_t,
	    struct uio *, int);
int	_isa_bus_dmamap_load_raw(bus_dma_tag_t, bus_dmamap_t,
	    bus_dma_segment_t *, int, bus_size_t, int);
void	_isa_bus_dmamap_unload(bus_dma_tag_t, bus_dmamap_t);
void	_isa_bus_dmamap_sync(bus_dma_tag_t, bus_dmamap_t,
	    bus_addr_t, bus_size_t, int);

int	_isa_bus_dmamem_alloc(bus_dma_tag_t, bus_size_t, bus_size_t,
	    bus_size_t, bus_dma_segment_t *, int, int *, int);

int	_isa_dma_check_buffer(void *, bus_size_t, int, bus_size_t,
	    struct proc *);
int	_isa_dma_alloc_bouncebuf(bus_dma_tag_t, bus_dmamap_t,
	    bus_size_t, int);
void	_isa_dma_free_bouncebuf(bus_dma_tag_t, bus_dmamap_t);

/*
 * Entry points for ISA DMA.  These are mostly wrappers around
 * the generic functions that understand how to deal with bounce
 * buffers, if necessary.
 */
struct bus_dma_tag isa_bus_dma_tag = {
	NULL,			/* _cookie */
	_isa_bus_dmamap_create,
	_isa_bus_dmamap_destroy,
	_isa_bus_dmamap_load,
	_isa_bus_dmamap_load_mbuf,
	_isa_bus_dmamap_load_uio,
	_isa_bus_dmamap_load_raw,
	_isa_bus_dmamap_unload,
	_isa_bus_dmamap_sync,
	_isa_bus_dmamem_alloc,
	_bus_dmamem_alloc_range,
	_bus_dmamem_free,
	_bus_dmamem_map,
	_bus_dmamem_unmap,
	_bus_dmamem_mmap,
};
#endif /* NISADMA > 0 */

#define GICODE_SEL	10

u_long  intrstray[ICU_LEN];

/*
 * Caught a stray interrupt, notify
 */
void
isa_strayintr(int irq)
{
        /*
         * Stray interrupts on irq 7 occur when an interrupt line is raised
         * and then lowered before the CPU acknowledges it.  This generally
         * means either the device is screwed or something is cli'ing too
         * long and it's timing out.
         */
	if (++intrstray[irq] <= 5)
		log(LOG_ERR, "stray interrupt %d%s\n", irq,
		    intrstray[irq] >= 5 ? "; stopped logging" : "");
}

int intrtype[ICU_LEN], intrmask[ICU_LEN], intrlevel[ICU_LEN];
int iminlevel[ICU_LEN], imaxlevel[ICU_LEN];
struct intrhand *intrhand[ICU_LEN];

int
fakeintr(void *arg)
{
	return 0;
}

#define	LEGAL_IRQ(x)	((x) >= 0 && (x) < ICU_LEN && (x) != 2)

int
isa_intr_alloc(isa_chipset_tag_t ic, int mask, int type, int *irq)
{
	int i, bestirq, count;
	int tmp;
	struct intrhand **p, *q;

	if (type == IST_NONE)
		panic("intr_alloc: bogus type");

	bestirq = -1;
	count = -1;

	/* some interrupts should never be dynamically allocated */
	mask &= 0xdef8;

	/*
	 * XXX some interrupts will be used later (6 for fdc, 12 for pms).
	 * the right answer is to do "breadth-first" searching of devices.
	 */
	mask &= 0xefbf;

	for (i = 0; i < ICU_LEN; i++) {
		if (LEGAL_IRQ(i) == 0 || (mask & (1<<i)) == 0)
			continue;

		switch(intrtype[i]) {
		case IST_NONE:
			/*
			 * if nothing's using the irq, just return it
			 */
			*irq = i;
			return (0);

		case IST_EDGE:
		case IST_LEVEL:
			if (type != intrtype[i])
				continue;
			/*
			 * if the irq is shareable, count the number of other
			 * handlers, and if it's smaller than the last irq like
			 * this, remember it
			 *
			 * XXX We should probably also consider the
			 * interrupt level and stick IPL_TTY with other
			 * IPL_TTY, etc.
			 */
			for (p = &intrhand[i], tmp = 0; (q = *p) != NULL;
			     p = &q->ih_next, tmp++)
				;
			if ((bestirq == -1) || (count > tmp)) {
				bestirq = i;
				count = tmp;
			}
			break;

		case IST_PULSE:
			/* this just isn't shareable */
			continue;
		}
	}

	if (bestirq == -1)
		return (1);

	*irq = bestirq;

	return (0);
}

/*
 * Just check to see if an IRQ is available/can be shared.
 * 0 = interrupt not available
 * 1 = interrupt shareable
 * 2 = interrupt all to ourself
 */
int
isa_intr_check(isa_chipset_tag_t ic, int irq, int type)
{
	if (!LEGAL_IRQ(irq) || type == IST_NONE)
		return (0);

	switch (intrtype[irq]) {
	case IST_NONE:
		return (2);
		break;
	case IST_LEVEL:
		if (type != intrtype[irq])
			return (0);
		return (1);
		break;
	case IST_EDGE:
	case IST_PULSE:
		if (type != IST_NONE)
			return (0);
	}
	return (1);
}

/*
 * Set up an interrupt handler to start being called.
 * XXX PRONE TO RACE CONDITIONS, UGLY, 'INTERESTING' INSERTION ALGORITHM.
 */
void *
isa_intr_establish(isa_chipset_tag_t ic, int irq, int type, int level,
    int (*ih_fun)(void *), void *ih_arg, char *ih_what)
{
	struct pic *pic = &i8259_pic;
	int pin = irq;

#if NIOAPIC > 0
	struct mp_intr_map *mip;

 	if (mp_busses != NULL) {
		if (mp_isa_bus == NULL)
			panic("no isa bus");

		for (mip = mp_isa_bus->mb_intrs; mip != NULL;
		    mip = mip->next) {
 			if (mip->bus_pin == pin) {
				pin = APIC_IRQ_PIN(mip->ioapic_ih);
				pic = &mip->ioapic->sc_pic;
 				break;
 			}
 		}
 	}
#endif

	KASSERT(pic);

	return intr_establish(irq, pic, pin, type, level, ih_fun,
	    ih_arg, ih_what);
}

/*
 * Deregister an interrupt handler.
 */
void
isa_intr_disestablish(isa_chipset_tag_t ic, void *arg)
{
	intr_disestablish(arg);
	return;
}

void
isa_attach_hook(struct device *parent, struct device *self,
    struct isabus_attach_args *iba)
{
	extern int isa_has_been_seen;

	/*
	 * Notify others that might need to know that the ISA bus
	 * has now been attached.
	 */
	if (isa_has_been_seen)
		panic("isaattach: ISA bus already seen!");
	isa_has_been_seen = 1;
}

#if NISADMA > 0
/**********************************************************************
 * bus.h dma interface entry points
 **********************************************************************/

#ifdef ISA_DMA_STATS
#define	STAT_INCR(v)	(v)++
#define	STAT_DECR(v)	do { \
		if ((v) == 0) \
			printf("%s:%d -- Already 0!\n", __FILE__, __LINE__); \
		else \
			(v)--; \
		} while (0)
u_long	isa_dma_stats_loads;
u_long	isa_dma_stats_bounces;
u_long	isa_dma_stats_nbouncebufs;
#else
#define	STAT_INCR(v)
#define	STAT_DECR(v)
#endif

/*
 * Create an ISA DMA map.
 */
int
_isa_bus_dmamap_create(bus_dma_tag_t t, bus_size_t size, int nsegments,
    bus_size_t maxsegsz, bus_size_t boundary, int flags, bus_dmamap_t *dmamp)
{
	struct isa_dma_cookie *cookie;
	bus_dmamap_t map;
	int error, cookieflags;
	void *cookiestore;
	size_t cookiesize;

	/* Call common function to create the basic map. */
	error = _bus_dmamap_create(t, size, nsegments, maxsegsz, boundary,
	    flags, dmamp);
	if (error)
		return (error);

	map = *dmamp;
	map->_dm_cookie = NULL;

	cookiesize = sizeof(struct isa_dma_cookie);

	/*
	 * ISA only has 24-bits of address space.  This means
	 * we can't DMA to pages over 16M.  In order to DMA to
	 * arbitrary buffers, we use "bounce buffers" - pages
	 * in memory below the 16M boundary.  On DMA reads,
	 * DMA happens to the bounce buffers, and is copied into
	 * the caller's buffer.  On writes, data is copied into
	 * the bounce buffer, and the DMA happens from those
	 * pages.  To software using the DMA mapping interface,
	 * this looks simply like a data cache.
	 *
	 * If we have more than 16M of RAM in the system, we may
	 * need bounce buffers.  We check and remember that here.
	 *
	 * There are exceptions, however.  VLB devices can do
	 * 32-bit DMA, and indicate that here.
	 *
	 * ...or, there is an opposite case.  The most segments
	 * a transfer will require is (maxxfer / NBPG) + 1.  If
	 * the caller can't handle that many segments (e.g. the
	 * ISA DMA controller), we may have to bounce it as well.
	 */
	cookieflags = 0;
	if ((avail_end > ISA_DMA_BOUNCE_THRESHOLD &&
	    (flags & ISABUS_DMA_32BIT) == 0) ||
	    ((map->_dm_size / NBPG) + 1) > map->_dm_segcnt) {
		cookieflags |= ID_MIGHT_NEED_BOUNCE;
		cookiesize += (sizeof(bus_dma_segment_t) * map->_dm_segcnt);
	}

	/*
	 * Allocate our cookie.
	 */
	if ((cookiestore = malloc(cookiesize, M_DEVBUF,
	    (flags & BUS_DMA_NOWAIT) ?
	        (M_NOWAIT|M_ZERO) : (M_WAITOK|M_ZERO))) == NULL) {
		error = ENOMEM;
		goto out;
	}
	cookie = (struct isa_dma_cookie *)cookiestore;
	cookie->id_flags = cookieflags;
	map->_dm_cookie = cookie;

	if (cookieflags & ID_MIGHT_NEED_BOUNCE) {
		/*
		 * Allocate the bounce pages now if the caller
		 * wishes us to do so.
		 */
		if ((flags & BUS_DMA_ALLOCNOW) == 0)
			goto out;

		error = _isa_dma_alloc_bouncebuf(t, map, size, flags);
	}

 out:
	if (error) {
		free(map->_dm_cookie, M_DEVBUF, cookiesize);
		_bus_dmamap_destroy(t, map);
	}
	return (error);
}

/*
 * Destroy an ISA DMA map.
 */
void
_isa_bus_dmamap_destroy(bus_dma_tag_t t, bus_dmamap_t map)
{
	struct isa_dma_cookie *cookie = map->_dm_cookie;

	/*
	 * Free any bounce pages this map might hold.
	 */
	if (cookie->id_flags & ID_HAS_BOUNCE)
		_isa_dma_free_bouncebuf(t, map);

	free(cookie, M_DEVBUF, 0);
	_bus_dmamap_destroy(t, map);
}

/*
 * Load an ISA DMA map with a linear buffer.
 */
int
_isa_bus_dmamap_load(bus_dma_tag_t t, bus_dmamap_t map, void *buf,
    bus_size_t buflen, struct proc *p, int flags)
{
	struct isa_dma_cookie *cookie = map->_dm_cookie;
	int error;

	STAT_INCR(isa_dma_stats_loads);

	/*
	 * Check to see if we might need to bounce the transfer.
	 */
	if (cookie->id_flags & ID_MIGHT_NEED_BOUNCE) {
		/*
		 * Check if all pages are below the bounce
		 * threshold.  If they are, don't bother bouncing.
		 */
		if (_isa_dma_check_buffer(buf, buflen,
		    map->_dm_segcnt, map->_dm_boundary, p) == 0)
			return (_bus_dmamap_load(t, map, buf, buflen,
			    p, flags));

		STAT_INCR(isa_dma_stats_bounces);

		/*
		 * Allocate bounce pages, if necessary.
		 */
		if ((cookie->id_flags & ID_HAS_BOUNCE) == 0) {
			error = _isa_dma_alloc_bouncebuf(t, map, buflen,
			    flags);
			if (error)
				return (error);
		}

		/*
		 * Cache a pointer to the caller's buffer and
		 * load the DMA map with the bounce buffer.
		 */
		cookie->id_origbuf = buf;
		cookie->id_origbuflen = buflen;
		error = _bus_dmamap_load(t, map, cookie->id_bouncebuf,
		    buflen, p, flags);
		
		if (error) {
			/*
			 * Free the bounce pages, unless our resources
			 * are reserved for our exclusive use.
			 */
			if ((map->_dm_flags & BUS_DMA_ALLOCNOW) == 0)
				_isa_dma_free_bouncebuf(t, map);
		}

		/* ...so _isa_bus_dmamap_sync() knows we're bouncing */
		cookie->id_flags |= ID_IS_BOUNCING;
	} else {
		/*
		 * Just use the generic load function.
		 */
		error = _bus_dmamap_load(t, map, buf, buflen, p, flags); 
	}

	return (error);
}

/*
 * Like _isa_bus_dmamap_load(), but for mbufs.
 */
int
_isa_bus_dmamap_load_mbuf(bus_dma_tag_t t, bus_dmamap_t map, struct mbuf *m,
    int flags)  
{

	panic("_isa_bus_dmamap_load_mbuf: not implemented");
}

/*
 * Like _isa_bus_dmamap_load(), but for uios.
 */
int
_isa_bus_dmamap_load_uio(bus_dma_tag_t t, bus_dmamap_t map, struct uio *uio,
    int flags)
{

	panic("_isa_bus_dmamap_load_uio: not implemented");
}

/*
 * Like _isa_bus_dmamap_load(), but for raw memory allocated with
 * bus_dmamem_alloc().
 */
int
_isa_bus_dmamap_load_raw(bus_dma_tag_t t, bus_dmamap_t map,
    bus_dma_segment_t *segs, int nsegs, bus_size_t size, int flags)
{

	panic("_isa_bus_dmamap_load_raw: not implemented");
}

/*
 * Unload an ISA DMA map.
 */
void
_isa_bus_dmamap_unload(bus_dma_tag_t t, bus_dmamap_t map)
{
	struct isa_dma_cookie *cookie = map->_dm_cookie;

	/*
	 * If we have bounce pages, free them, unless they're
	 * reserved for our exclusive use.
	 */
	if ((cookie->id_flags & ID_HAS_BOUNCE) &&
	    (map->_dm_flags & BUS_DMA_ALLOCNOW) == 0)
		_isa_dma_free_bouncebuf(t, map);

	cookie->id_flags &= ~ID_IS_BOUNCING;

	/*
	 * Do the generic bits of the unload.
	 */
	_bus_dmamap_unload(t, map);
}

/*
 * Synchronize an ISA DMA map.
 */
void
_isa_bus_dmamap_sync(bus_dma_tag_t t, bus_dmamap_t map, bus_addr_t offset,
    bus_size_t len, int op)
{
	struct isa_dma_cookie *cookie = map->_dm_cookie;

#ifdef DEBUG
	if ((op & (BUS_DMASYNC_PREWRITE|BUS_DMASYNC_POSTREAD)) != 0) {
		if (offset >= map->dm_mapsize)
			panic("_isa_bus_dmamap_sync: bad offset");
		if (len == 0 || (offset + len) > map->dm_mapsize)
			panic("_isa_bus_dmamap_sync: bad length");
	}
#endif
#ifdef DIAGNOSTIC
	if ((op & (BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE)) != 0 &&
	    (op & (BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE)) != 0)
		panic("_isa_bus_dmamap_sync: mix PRE and POST");
#endif /* DIAGNOSTIC */

	/* PREREAD and POSTWRITE are no-ops */
	if (op & BUS_DMASYNC_PREWRITE) {
		/*
		 * If we're bouncing this transfer, copy the
		 * caller's buffer to the bounce buffer.
		 */
		if (cookie->id_flags & ID_IS_BOUNCING)
			memcpy(cookie->id_bouncebuf + offset,
			    cookie->id_origbuf + offset, len);
	}

	_bus_dmamap_sync(t, map, offset, len, op);

	if (op & BUS_DMASYNC_POSTREAD) {
		/*
		 * If we're bouncing this transfer, copy the
		 * bounce buffer to the caller's buffer.
		 */
		if (cookie->id_flags & ID_IS_BOUNCING)
			memcpy(cookie->id_origbuf + offset,
			    cookie->id_bouncebuf + offset, len);
	}
}

/*
 * Allocate memory safe for ISA DMA.
 */
int
_isa_bus_dmamem_alloc(bus_dma_tag_t t, bus_size_t size, bus_size_t alignment,
    bus_size_t boundary, bus_dma_segment_t *segs, int nsegs, int *rsegs,
    int flags)
{
	int error;

	/* Try in ISA addressable region first */
	error = _bus_dmamem_alloc_range(t, size, alignment, boundary,
	    segs, nsegs, rsegs, flags, 0, ISA_DMA_BOUNCE_THRESHOLD);
	if (!error)
		return (error);

	/* Otherwise try anywhere (we'll bounce later) */
	error = _bus_dmamem_alloc_range(t, size, alignment, boundary,
	    segs, nsegs, rsegs, flags, (bus_addr_t)0, (bus_addr_t)-1);
	return (error);
}

/**********************************************************************
 * ISA DMA utility functions
 **********************************************************************/

/*
 * Return 0 if all pages in the passed buffer lie within the DMA'able
 * range RAM.
 */
int
_isa_dma_check_buffer(void *buf, bus_size_t buflen, int segcnt,
    bus_size_t boundary, struct proc *p)
{
	vaddr_t vaddr = (vaddr_t)buf;
	vaddr_t endva;
	paddr_t pa, lastpa;
	u_long pagemask = ~(boundary - 1);
	pmap_t pmap;
	int nsegs;

	endva = round_page(vaddr + buflen);

	nsegs = 1;
	lastpa = 0;

	if (p != NULL)
		pmap = p->p_vmspace->vm_map.pmap;
	else
		pmap = pmap_kernel();

	for (; vaddr < endva; vaddr += NBPG) {
		/*
		 * Get physical address for this segment.
		 */
		pmap_extract(pmap, (vaddr_t)vaddr, &pa);
		pa = trunc_page(pa);

		/*
		 * Is it below the DMA'able threshold?
		 */
		if (pa > ISA_DMA_BOUNCE_THRESHOLD)
			return (EINVAL);

		if (lastpa) {
			/*
			 * Check excessive segment count.
			 */
			if (lastpa + NBPG != pa) {
				if (++nsegs > segcnt)
					return (EFBIG);
			}

			/*
			 * Check boundary restriction.
			 */
			if (boundary) {
				if ((lastpa ^ pa) & pagemask)
					return (EINVAL);
			}
		}
		lastpa = pa;
	}

	return (0);
}

int
_isa_dma_alloc_bouncebuf(bus_dma_tag_t t, bus_dmamap_t map, bus_size_t size,
    int flags)
{
	struct isa_dma_cookie *cookie = map->_dm_cookie;
	int error = 0;

	cookie->id_bouncebuflen = round_page(size);
	error = _bus_dmamem_alloc_range(t, cookie->id_bouncebuflen,
	    NBPG, map->_dm_boundary, cookie->id_bouncesegs,
	    map->_dm_segcnt, &cookie->id_nbouncesegs, flags,
	    0, ISA_DMA_BOUNCE_THRESHOLD);
	if (error)
		goto out;
	error = _bus_dmamem_map(t, cookie->id_bouncesegs,
	    cookie->id_nbouncesegs, cookie->id_bouncebuflen,
	    (caddr_t *)&cookie->id_bouncebuf, flags);

 out:
	if (error) {
		_bus_dmamem_free(t, cookie->id_bouncesegs,
		    cookie->id_nbouncesegs);
		cookie->id_bouncebuflen = 0;
		cookie->id_nbouncesegs = 0;
	} else {
		cookie->id_flags |= ID_HAS_BOUNCE;
		STAT_INCR(isa_dma_stats_nbouncebufs);
	}

	return (error);
}

void
_isa_dma_free_bouncebuf(bus_dma_tag_t t, bus_dmamap_t map)
{
	struct isa_dma_cookie *cookie = map->_dm_cookie;

	STAT_DECR(isa_dma_stats_nbouncebufs);

	_bus_dmamem_unmap(t, cookie->id_bouncebuf,
	    cookie->id_bouncebuflen);
	_bus_dmamem_free(t, cookie->id_bouncesegs,
	    cookie->id_nbouncesegs);
	cookie->id_bouncebuflen = 0;
	cookie->id_nbouncesegs = 0;
	cookie->id_flags &= ~ID_HAS_BOUNCE;
}
#endif /* NISADMA > 0 */
@


1.27
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.26 2015/01/24 15:13:55 kettenis Exp $	*/
d454 1
a454 2
		if (map->_dm_cookie != NULL)
			free(map->_dm_cookie, M_DEVBUF, 0);
@


1.26
log
@Add bus_dmamem_alloc_range(9) to allow drivers to allocate DMA'able memory
within a range that is more (or less) restrictive than the default range.

ok deraadt@@, stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.25 2014/12/22 03:13:45 deraadt Exp $	*/
a94 1
#include <dev/isa/isareg.h>
@


1.25
log
@bcopy -> memcpy; ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.24 2014/07/13 21:51:12 kettenis Exp $	*/
d154 1
d670 1
a670 1
	    segs, nsegs, rsegs, flags, (paddr_t)0, (paddr_t)-1);
@


1.24
log
@The correct place to call _bus_dmamap_sync() is after we copy data *to* the
bounce buffer and before we copy data *from* the bounce buffer.  Currently
_bus_dmamap_sync() is a no-op, but keeping it #ifdef'ed out in the wrong
place makes no sense.

ok deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.23 2014/07/12 18:44:41 tedu Exp $	*/
d634 2
a635 3
			bcopy(cookie->id_origbuf + offset,
			    cookie->id_bouncebuf + offset,
			    len);
d646 2
a647 3
			bcopy(cookie->id_bouncebuf + offset,
			    cookie->id_origbuf + offset,
			    len);
@


1.23
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.22 2010/11/20 20:58:51 miod Exp $	*/
d637 5
a641 1
	} else if (op & BUS_DMASYNC_POSTREAD) {
a650 5

#if 0
	/* This is a noop anyhow, so why bother calling it? */
	_bus_dmamap_sync(t, map, op);
#endif
@


1.22
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.21 2010/03/25 22:44:57 oga Exp $	*/
d455 1
a455 1
			free(map->_dm_cookie, M_DEVBUF);
d475 1
a475 1
	free(cookie, M_DEVBUF);
@


1.21
log
@Make the i386 and amd64 bus_dma functions for isa less stupid:

1) when you have a wrapper function in a dmatag that just calls the
_bus_dmamem original, you don't need it, just put the original function
in the tag

2) don't trunc_page the avail_end/ISA_BOUNCE_THRESHOLD stuff (see icb
for a discussion of why this is wrong about 00:00 gmt). make i386 and
amd64 both do this the same (the amd64 way is cleaner and makes the
third diff actually possible without a lot of pain). just do
dmamem_alloc_range(0, threshold) and if that fails do a alloc_range(0,
-1) and assume we'll bounce to pick up the pieces. Also using avail_end
for alloc_range is not nice (miod has been trying to avoid these abuses
iirc), so just use (paddr_t)-1, which is equivalent since you want "any"
memory.

3) now this is the funny one. consider point 2. then considering why
using the same bloody function to allocate your bouncebuffer is just
f'ing wrong. instead allocate with alloc_range(0, threshold) to make
sure that our bouncebuffer is actually uner 16megs.

ok deraadt@@, kettenis@@. Tested by several people.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.20 2009/03/10 15:03:17 oga Exp $	*/
d405 1
a405 1
	 * but bounce buffer, and the DMA happens from those
@


1.20
log
@remove the _BUS_DMA_PRIVATE define from amd64 and i386.

a define needed to get to ``private'' functions that needs to be defined
5 or more times isn't much use and may cause namespace issues anyway.
Other archs will probably follow.

Discussed in portugal.  "Hell yes" weingart@@, ok kettenis@@, no
objections miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.19 2008/12/11 17:07:14 oga Exp $	*/
a130 7
void	_isa_bus_dmamem_free(bus_dma_tag_t,
	    bus_dma_segment_t *, int);
int	_isa_bus_dmamem_map(bus_dma_tag_t, bus_dma_segment_t *,
	    int, size_t, caddr_t *, int);
void	_isa_bus_dmamem_unmap(bus_dma_tag_t, caddr_t, size_t);
paddr_t	_isa_bus_dmamem_mmap(bus_dma_tag_t, bus_dma_segment_t *,
	    int, off_t, int, int);
d154 4
a157 4
	_isa_bus_dmamem_free,
	_isa_bus_dmamem_map,
	_isa_bus_dmamem_unmap,
	_isa_bus_dmamem_mmap,
d672 1
a672 1
	    segs, nsegs, rsegs, flags, 0, trunc_page(avail_end));
a675 42
/*
 * Free memory safe for ISA DMA.
 */
void
_isa_bus_dmamem_free(bus_dma_tag_t t, bus_dma_segment_t *segs, int nsegs)
{

	_bus_dmamem_free(t, segs, nsegs);
}

/*
 * Map ISA DMA-safe memory into kernel virtual address space.
 */
int
_isa_bus_dmamem_map(bus_dma_tag_t t, bus_dma_segment_t *segs, int nsegs,
    size_t size, caddr_t *kvap, int flags)
{

	return (_bus_dmamem_map(t, segs, nsegs, size, kvap, flags));
}

/*
 * Unmap ISA DMA-safe memory from kernel virtual address space.
 */
void
_isa_bus_dmamem_unmap(bus_dma_tag_t t, caddr_t kva, size_t size)
{

	_bus_dmamem_unmap(t, kva, size);
}

/*
 * mmap(2) ISA DMA-safe memory.
 */
paddr_t
_isa_bus_dmamem_mmap(bus_dma_tag_t t, bus_dma_segment_t *segs, int nsegs,
    off_t off, int prot, int flags)
{

	return (_bus_dmamem_mmap(t, segs, nsegs, off, prot, flags));
}

d749 1
a749 1
	error = _isa_bus_dmamem_alloc(t, cookie->id_bouncebuflen,
d751 2
a752 1
	    map->_dm_segcnt, &cookie->id_nbouncesegs, flags);
d755 1
a755 1
	error = _isa_bus_dmamem_map(t, cookie->id_bouncesegs,
d761 1
a761 1
		_isa_bus_dmamem_free(t, cookie->id_bouncesegs,
d780 1
a780 1
	_isa_bus_dmamem_unmap(t, cookie->id_bouncebuf,
d782 1
a782 1
	_isa_bus_dmamem_free(t, cookie->id_bouncesegs,
@


1.19
log
@Kill the $ARCH prefix for isa_dma_cookie. With this change, the i386 and
amd64 isa dma code is identical save for some formatting, and a slight
difference in bus_dmamem_alloc.

"Die x86_!" krw@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.18 2008/12/10 20:26:56 oga Exp $	*/
a87 1
#define _BUS_DMA_PRIVATE
@


1.18
log
@both x86 platforms isa bus_dma implementations handle bus_dmamap_sync
incorrectly.

The spec (manpage) states that using two PRE or two POST ops together is
entirely valid, but mixing pre and post is invalid. The way this was
handled before with a switch statement meant that only individual
commands actually would be recognised, so move to just checking the
commands indidually using "if (op & $command)". Additionally, add a
DIAGNOSTIC check and panic for the mixing of pre and post operations
(this is done on several other architectures already).

tested by several people; thanks!

ok dlg@@, kettenis@@, "the diff made sense" deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.17 2008/12/06 19:59:38 tedu Exp $	*/
d389 1
a389 1
	struct x86_isa_dma_cookie *cookie;
d404 1
a404 1
	cookiesize = sizeof(struct x86_isa_dma_cookie);
d445 1
a445 1
	cookie = (struct x86_isa_dma_cookie *)cookiestore;
d475 1
a475 1
	struct x86_isa_dma_cookie *cookie = map->_dm_cookie;
d494 1
a494 1
	struct x86_isa_dma_cookie *cookie = map->_dm_cookie;
d594 1
a594 1
	struct x86_isa_dma_cookie *cookie = map->_dm_cookie;
d619 1
a619 1
	struct x86_isa_dma_cookie *cookie = map->_dm_cookie;
d795 1
a795 1
	struct x86_isa_dma_cookie *cookie = map->_dm_cookie;
d825 1
a825 1
	struct x86_isa_dma_cookie *cookie = map->_dm_cookie;
@


1.17
log
@revert all changes related to the mpsafe intr handler.  i screwed up the commit
and even then it didn't work.  we have higher standards than this.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.16 2008/12/06 17:46:52 tedu Exp $	*/
d629 5
d635 2
a636 8
	switch (op) {
	case BUS_DMASYNC_PREREAD:
		/*
		 * Nothing to do for pre-read.
		 */
		break;

	case BUS_DMASYNC_PREWRITE:
d645 1
a645 3
		break;

	case BUS_DMASYNC_POSTREAD:
a653 7
		break;

	case BUS_DMASYNC_POSTWRITE:
		/*
		 * Nothing to do for post-write.
		 */
		break;
@


1.16
log
@not commited, i'm a retard
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.15 2008/12/03 15:46:06 oga Exp $	*/
d333 1
a333 1
	    ih_arg, ih_what, 0);
@


1.15
log
@Remove the x86 and i386 prefixes to the bus_dma types. It's really quite
pointless and just makes the code different for no reason. This moves i386 and
amd64 bus_dma to being a lot closer to identical.

suggestion to just remove the prefix instead of merge them from deraadt@@.

no objections art@@, kettenis@@, ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.14 2008/06/26 05:42:09 ray Exp $	*/
d333 1
a333 1
	    ih_arg, ih_what);
@


1.14
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.13 2007/09/17 15:34:38 chl Exp $	*/
d88 1
a88 1
#define _X86_BUS_DMA_PRIVATE
d151 1
a151 1
struct x86_bus_dma_tag isa_bus_dma_tag = {
@


1.13
log
@MALLOC/FREE -> malloc/free and M_ZERO changes

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.12 2007/04/28 03:55:40 jsg Exp $	*/
a21 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.12
log
@Remove a duplicate copyright statement.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.11 2007/01/15 23:19:05 jsg Exp $	*/
d447 2
a448 1
	    (flags & BUS_DMA_NOWAIT) ? M_NOWAIT : M_WAITOK)) == NULL) {
a451 1
	bzero(cookiestore, cookiesize);
@


1.11
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.10 2006/11/25 16:59:31 niklas Exp $	*/
a4 37

/*-
 * Copyright (c) 1996, 1997 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
@


1.10
log
@sync amd64 to i386 w.r.t. acpi support. Also fix interrupt routing for multi-ioapic systems.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.9 2006/06/08 03:18:08 weingart Exp $	*/
d221 1
a221 2
isa_strayintr(irq)
	int irq;
d239 1
a239 2
fakeintr(arg)
	void *arg;
d247 1
a247 5
isa_intr_alloc(ic, mask, type, irq)
	isa_chipset_tag_t ic;
	int mask;
	int type;
	int *irq;
d323 1
a323 4
isa_intr_check(ic, irq, type)
	isa_chipset_tag_t ic;	/* Not used. */
	int irq;
	int type;
d350 2
a351 8
isa_intr_establish(ic, irq, type, level, ih_fun, ih_arg, ih_what)
	isa_chipset_tag_t ic;
	int irq;
	int type;
	int level;
	int (*ih_fun)(void *);
	void *ih_arg;
	char *ih_what;
d384 1
a384 3
isa_intr_disestablish(ic, arg)
	isa_chipset_tag_t ic;
	void *arg;
d391 2
a392 3
isa_attach_hook(parent, self, iba)
	struct device *parent, *self;
	struct isabus_attach_args *iba;
d430 2
a431 8
_isa_bus_dmamap_create(t, size, nsegments, maxsegsz, boundary, flags, dmamp)
	bus_dma_tag_t t;
	bus_size_t size;
	int nsegments;
	bus_size_t maxsegsz;
	bus_size_t boundary;
	int flags;
	bus_dmamap_t *dmamp;
d517 1
a517 3
_isa_bus_dmamap_destroy(t, map)
	bus_dma_tag_t t;
	bus_dmamap_t map;
d535 2
a536 7
_isa_bus_dmamap_load(t, map, buf, buflen, p, flags)
	bus_dma_tag_t t;
	bus_dmamap_t map; 
	void *buf;
	bus_size_t buflen;
	struct proc *p;
	int flags;
d602 2
a603 5
_isa_bus_dmamap_load_mbuf(t, map, m, flags)  
	bus_dma_tag_t t;
	bus_dmamap_t map;
	struct mbuf *m;
	int flags;
d613 2
a614 5
_isa_bus_dmamap_load_uio(t, map, uio, flags)
	bus_dma_tag_t t;
	bus_dmamap_t map;
	struct uio *uio;
	int flags;
d625 2
a626 7
_isa_bus_dmamap_load_raw(t, map, segs, nsegs, size, flags)
	bus_dma_tag_t t;
	bus_dmamap_t map;
	bus_dma_segment_t *segs;
	int nsegs;
	bus_size_t size;
	int flags;
d636 1
a636 3
_isa_bus_dmamap_unload(t, map)
	bus_dma_tag_t t;
	bus_dmamap_t map;
d660 2
a661 6
_isa_bus_dmamap_sync(t, map, offset, len, op)
	bus_dma_tag_t t;
	bus_dmamap_t map;
	bus_addr_t offset;
	bus_size_t len;
	int op;
d720 3
a722 7
_isa_bus_dmamem_alloc(t, size, alignment, boundary, segs, nsegs, rsegs, flags)
	bus_dma_tag_t t;
	bus_size_t size, alignment, boundary;
	bus_dma_segment_t *segs;
	int nsegs;
	int *rsegs;
	int flags;
d742 1
a742 4
_isa_bus_dmamem_free(t, segs, nsegs)
	bus_dma_tag_t t;
	bus_dma_segment_t *segs;
	int nsegs;
d752 2
a753 7
_isa_bus_dmamem_map(t, segs, nsegs, size, kvap, flags)
	bus_dma_tag_t t;
	bus_dma_segment_t *segs;
	int nsegs;
	size_t size;
	caddr_t *kvap;
	int flags;
d763 1
a763 4
_isa_bus_dmamem_unmap(t, kva, size)
	bus_dma_tag_t t;
	caddr_t kva;
	size_t size;
d773 2
a774 6
_isa_bus_dmamem_mmap(t, segs, nsegs, off, prot, flags)
	bus_dma_tag_t t;
	bus_dma_segment_t *segs;
	int nsegs;
	off_t off;
	int prot, flags;
d789 2
a790 6
_isa_dma_check_buffer(buf, buflen, segcnt, boundary, p)
	void *buf;
	bus_size_t buflen;
	int segcnt;
	bus_size_t boundary;
	struct proc *p;
d846 2
a847 5
_isa_dma_alloc_bouncebuf(t, map, size, flags)
	bus_dma_tag_t t;
	bus_dmamap_t map;
	bus_size_t size;
	int flags;
d877 1
a877 3
_isa_dma_free_bouncebuf(t, map)
	bus_dma_tag_t t;
	bus_dmamap_t map;
@


1.9
log
@Move ISA logic of allocation functions to better place.
Thanks for krw@@ for testing isa floppies.  brad@@ ok,
jason@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.8 2006/03/08 19:44:02 kettenis Exp $	*/
d375 5
a379 2
 		for (mip = mp_busses[mp_isa_bus].mb_intrs; mip != NULL;
 		    mip = mip->next) {
@


1.8
log
@Properly route ISA interrupts through ioapics.
tested by many; ok mickey@@, brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.7 2006/03/01 21:51:39 deraadt Exp $	*/
d773 1
a773 1
	paddr_t high;
d775 5
a779 4
	if (avail_end > ISA_DMA_BOUNCE_THRESHOLD)
		high = trunc_page(ISA_DMA_BOUNCE_THRESHOLD);
	else
		high = trunc_page(avail_end);
d781 4
a784 2
	return (_bus_dmamem_alloc_range(t, size, alignment, boundary,
	    segs, nsegs, rsegs, flags, 0, high));
@


1.7
log
@from mickey, like on i386:
prioritise <16m memory for isa bus_dma'ble memorble memory allocations
why?
this is now needed because the nvidia ethernet running with jumbo frames
is allocating much more memory, and was robbing isadma of bounce buffers.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.6 2005/12/13 00:18:19 jsg Exp $	*/
d125 7
d368 21
a388 1
	return intr_establish(irq, &i8259_pic, irq, type, level, ih_fun,
@


1.6
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.
Checked by ian@@, deraadt@@ and millert@@, arm portion checked by drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.5 2005/12/11 20:13:33 krw Exp $	*/
a140 5

/*
 * ISA can only DMA to 0-16M.
 */
#define	ISA_DMA_BOUNCE_THRESHOLD	0x00ffffff
@


1.5
log
@Remove some dead code spotted by lint.

ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.4 2005/09/19 01:28:04 deraadt Exp $	*/
d97 1
a97 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.4
log
@floppy support; form@@openbsd.ru
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.3 2004/06/28 01:52:26 deraadt Exp $	*/
a369 3
	struct intrhand **p, *q, *ih;
	static struct intrhand fakehand = {fakeintr};

a371 60

	/* no point in sleeping unless someone can free memory. */
	ih = malloc(sizeof *ih, M_DEVBUF, cold ? M_NOWAIT : M_WAITOK);
	if (ih == NULL) {
		printf("%s: isa_intr_establish: can't malloc handler info\n",
		    ih_what);
		return NULL;
	}

	if (!LEGAL_IRQ(irq) || type == IST_NONE) {
		printf("%s: intr_establish: bogus irq or type\n", ih_what);
		return NULL;
	}
	switch (intrtype[irq]) {
	case IST_NONE:
		intrtype[irq] = type;
		break;
	case IST_EDGE:
	case IST_LEVEL:
		if (type == intrtype[irq])
			break;
	case IST_PULSE:
		if (type != IST_NONE) {
			/*printf("%s: intr_establish: can't share %s with %s, irq %d\n",
			    ih_what, isa_intr_typename(intrtype[irq]),
			    isa_intr_typename(type), irq);*/
			return NULL;
		}
		break;
	}

	/*
	 * Figure out where to put the handler.
	 * This is O(N^2), but we want to preserve the order, and N is
	 * generally small.
	 */
	for (p = &intrhand[irq]; (q = *p) != NULL; p = &q->ih_next)
		;

	/*
	 * Actually install a fake handler momentarily, since we might be doing
	 * this with interrupts enabled and don't want the real routine called
	 * until masking is set up.
	 */
	fakehand.ih_level = level;
	*p = &fakehand;

	/*
	 * Poke the real handler in now.
	 */
	ih->ih_fun = ih_fun;
	ih->ih_arg = ih_arg;
	ih->ih_next = NULL;
	ih->ih_level = level;
	ih->ih_irq = irq;
	evcount_attach(&ih->ih_count, ih_what, (void *)&ih->ih_irq,
	    &evcount_intr);
	*p = ih;

	return (ih);
a381 4
	struct intrhand *ih = arg;
	int irq = ih->ih_irq;
	struct intrhand **p, *q;

a383 19

	if (!LEGAL_IRQ(irq))
		panic("intr_disestablish: bogus irq");

	/*
	 * Remove the handler from the chain.
	 * This is O(n^2), too.
	 */
	for (p = &intrhand[irq]; (q = *p) != NULL && q != ih; p = &q->ih_next)
		;
	if (q)
		*p = q->ih_next;
	else
		panic("intr_disestablish: handler not registered");
	evcount_detach(&ih->ih_count);
	free(ih, M_DEVBUF);

	if (intrhand[irq] == NULL)
		intrtype[irq] = IST_NONE;
@


1.3
log
@Use new event counter API for interrupt counting on amd64.  Based in part
on some changes in the i386 codebase.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.2 2004/06/13 21:49:13 niklas Exp $	*/
d129 1
a129 1
#define _I386_BUS_DMA_PRIVATE
d197 1
a197 1
struct i386_bus_dma_tag isa_bus_dma_tag = {
d522 1
a522 1
	struct i386_isa_dma_cookie *cookie;
d537 1
a537 1
	cookiesize = sizeof(struct i386_isa_dma_cookie);
d578 1
a578 1
	cookie = (struct i386_isa_dma_cookie *)cookiestore;
d610 1
a610 1
	struct i386_isa_dma_cookie *cookie = map->_dm_cookie;
d634 1
a634 1
	struct i386_isa_dma_cookie *cookie = map->_dm_cookie;
d747 1
a747 1
	struct i386_isa_dma_cookie *cookie = map->_dm_cookie;
d776 1
a776 1
	struct i386_isa_dma_cookie *cookie = map->_dm_cookie;
d985 1
a985 1
	struct i386_isa_dma_cookie *cookie = map->_dm_cookie;
d1017 1
a1017 1
	struct i386_isa_dma_cookie *cookie = map->_dm_cookie;
@


1.2
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d373 2
a374 1
	return intr_establish(irq, &i8259_pic, irq, type, level, ih_fun, ih_arg);
d430 2
a431 1
	ih->ih_what = ih_what;
d465 1
@


1.1
log
@an amd64 arch support.
hacked by art@@ from netbsd sources and then later debugged
by me into the shape where it can host itself.
no bootloader yet as needs redoing from the
recent advanced i386 sources (anyone? ;)
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.47 2003/01/16 04:17:10 art Exp $	*/
d135 1
a142 1
#include <i386/isa/icu.h>
@


1.1.2.1
log
@icu.h is gone
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.1 2004/01/28 01:39:39 mickey Exp $	*/
a134 1
#include <machine/i8259.h>
d142 1
@

