head	1.11;
access;
symbols
	OPENBSD_6_1:1.11.0.10
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.6
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.9.0.12
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.16
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.14
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.10
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.8
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.6
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.4
	OPENBSD_5_0:1.9.0.2
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.4.0.2
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.12
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.14
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.10
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.8
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.6
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.4
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.2
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.2.0.10
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.12
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.8
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.6
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.4
	OPENBSD_3_6_BASE:1.2
	SMP_SYNC_A:1.2
	SMP_SYNC_B:1.2
	OPENBSD_3_5:1.2.0.2
	OPENBSD_3_5_BASE:1.2
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.11
date	2015.03.25.21.05.18;	author kettenis;	state Exp;
branches;
next	1.10;
commitid	k6HPjf5wfG49EBGs;

1.10
date	2015.03.21.20.42.38;	author kettenis;	state Exp;
branches;
next	1.9;
commitid	tilqEUDj6duaLWpC;

1.9
date	2011.03.23.16.54.34;	author pirofti;	state Exp;
branches;
next	1.8;

1.8
date	2011.03.20.21.44.08;	author guenther;	state Exp;
branches;
next	1.7;

1.7
date	2010.11.20.20.11.17;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2010.09.29.15.11.31;	author joshe;	state Exp;
branches;
next	1.5;

1.5
date	2010.09.29.13.46.38;	author joshe;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.29.21.13.43;	author thib;	state Exp;
branches;
next	1.3;

1.3
date	2006.10.01.10.52.10;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.28.22.26.05;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.28.01.39.39;	author mickey;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.06.05.23.09.25;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Save/restore AVX registers and other XSAVE-managed state information when
entering/leaving a signal handler like we already do the the FPU and SSE
state.  This should make it possible to use AVX instructions in signal
handlers.

ok mlarkin@@
@
text
@/*	$OpenBSD: fpu.h,v 1.10 2015/03/21 20:42:38 kettenis Exp $	*/
/*	$NetBSD: fpu.h,v 1.1 2003/04/26 18:39:40 fvdl Exp $	*/

#ifndef	_MACHINE_FPU_H_
#define	_MACHINE_FPU_H_

#include <sys/types.h>

/*
 * amd64 only uses the extended save/restore format used
 * by fxsave/fsrestore, to always deal with the SSE registers,
 * which are part of the ABI to pass floating point values.
 * Must be stored in memory on a 16-byte boundary.
 */

struct fxsave64 {
	u_int16_t  fx_fcw;
	u_int16_t  fx_fsw;
	u_int8_t   fx_ftw;
	u_int8_t   fx_unused1;
	u_int16_t  fx_fop;
	u_int64_t  fx_rip;
	u_int64_t  fx_rdp;
	u_int32_t  fx_mxcsr;
	u_int32_t  fx_mxcsr_mask;
	u_int64_t  fx_st[8][2];   /* 8 normal FP regs */
	u_int64_t  fx_xmm[16][2]; /* 16 SSE2 registers */
	u_int8_t   fx_unused3[96];
} __packed;

struct xstate_hdr {
	uint64_t	xstate_bv;
	uint64_t	xstate_xcomp_bv;
	uint8_t		xstate_rsrv0[0];
	uint8_t		xstate_rsrv[40];
} __packed;

struct savefpu {
	struct fxsave64 fp_fxsave;	/* see above */
	struct xstate_hdr fp_xstate;
	u_int64_t fp_ymm[16][2];
	u_int16_t fp_ex_sw;		/* saved status from last exception */
	u_int16_t fp_ex_tw;		/* saved tag from last exception */
};

/*
 * The i387 defaults to Intel extended precision mode and round to nearest,
 * with all exceptions masked.
 */
#define	__INITIAL_NPXCW__	0x037f
#define __INITIAL_MXCSR__ 	0x1f80
#define __INITIAL_MXCSR_MASK__	0xffbf

#ifdef _KERNEL
/*
 * XXX
 */
struct trapframe;
struct cpu_info;

extern size_t	fpu_save_len;
extern uint32_t	fpu_mxcsr_mask;
extern uint64_t	xsave_mask;

void fpuinit(struct cpu_info *);
void fpudrop(void);
void fpudiscard(struct proc *);
void fputrap(struct trapframe *);
void fpusave_proc(struct proc *, int);
void fpusave_cpu(struct cpu_info *, int);
void fpu_kernel_enter(void);
void fpu_kernel_exit(void);

#endif

#endif /* _MACHINE_FPU_H_ */
@


1.10
log
@Add support for saving/restoring FPU state using the XSAVE/XRSTOR.  Limit
support to the X87, SSE and AVX state.

This gives us (almost) full AVX support.  The AVX state isn't saved by
signal handlers yet, and ptrace(2) support is still missing.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.h,v 1.9 2011/03/23 16:54:34 pirofti Exp $	*/
d61 1
d63 1
@


1.9
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.h,v 1.8 2011/03/20 21:44:08 guenther Exp $	*/
d31 7
d40 2
@


1.8
log
@When reading MXCSR from userland sigcontext or a ptrace request,
mask out invalid bits to prevent a protect fault.

Original diff by joshe@@; further feedback and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.h,v 1.7 2010/11/20 20:11:17 miod Exp $	*/
d4 2
a5 2
#ifndef	_AMD64_FPU_H_
#define	_AMD64_FPU_H_
d65 1
a65 1
#endif /* _AMD64_FPU_H_ */
@


1.7
log
@__attribute__((packed)) -> __packed. The ioprbs.c chunk was commented out, and
uncommenting it is intentional.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.h,v 1.6 2010/09/29 15:11:31 joshe Exp $	*/
d51 2
@


1.6
log
@Back out previous, it appears to be broken.
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.h,v 1.4 2010/06/29 21:13:43 thib Exp $	*/
d29 1
a29 1
} __attribute__((packed));
@


1.5
log
@When reading MXCSR from userland sigcontext, mask out invalid bits.

This prevents a protection fault if a userland signal handler
scribbles all over it's struct sigcontext

Help from and ok guenther@@ kettenis@@
@
text
@a51 2
extern uint32_t	fpu_mxcsr_mask;

@


1.4
log
@fpu_kernel_{enter,exit}; Functions to allow the use of
the FPU in the kernel.

From Mike Belopuhov; Little bits by myself.

Comments/OK kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.h,v 1.3 2006/10/01 10:52:10 kettenis Exp $	*/
d51 2
@


1.3
log
@Switch fpu control word to the hardware default.  This makes us use 64-bit
precision instead of 53-bit precision, giving us proper support for
"long double".

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.h,v 1.2 2004/02/28 22:26:05 deraadt Exp $	*/
a53 1
void fpusave(struct proc *);
d58 2
@


1.2
log
@rename our NPXCW setting
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.h,v 1.1 2004/01/28 01:39:39 mickey Exp $	*/
a43 22

/* OpenBSD uses IEEE double precision. */
#define	__OpenBSD_NPXCW__	0x127f
/* Linux just uses the default control word. */
#define	__Linux_NPXCW__		0x037f

/*
 * The standard control word from finit is 0x37F, giving:
 *	round to nearest
 *	64-bit precision
 *	all exceptions masked.
 *
 * Now we want:
 *	affine mode (if we decide to support 287's)
 *	round to nearest
 *	53-bit precision
 *	all exceptions masked.
 *
 * 64-bit precision often gives bad results with high level languages
 * because it makes the results of calculations depend on whether
 * intermediate values are stored in memory or in FPU registers.
 */
@


1.1
log
@an amd64 arch support.
hacked by art@@ from netbsd sources and then later debugged
by me into the shape where it can host itself.
no bootloader yet as needs redoing from the
recent advanced i386 sources (anyone? ;)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d10 1
a10 1
 * NetBSD/amd64 only uses the extended save/restore format used
d45 2
a46 2
/* NetBSD uses IEEE double precision. */
#define	__NetBSD_NPXCW__	0x127f
@


1.1.2.1
log
@Merge with the trunk
@
text
@d10 1
a10 1
 * amd64 only uses the extended save/restore format used
d45 2
a46 2
/* OpenBSD uses IEEE double precision. */
#define	__OpenBSD_NPXCW__	0x127f
@


