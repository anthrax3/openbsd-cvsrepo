head	1.43;
access;
symbols
	OPENBSD_6_1:1.32.0.4
	OPENBSD_6_1_BASE:1.32
	OPENBSD_6_0:1.15.0.2
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9;
locks; strict;
comment	@ * @;


1.43
date	2017.07.12.05.32.50;	author mlarkin;	state Exp;
branches;
next	1.42;
commitid	o1K6HF75nsKMkhFy;

1.42
date	2017.07.06.06.19.15;	author mlarkin;	state Exp;
branches;
next	1.41;
commitid	wUgnL4TOS2LKO70d;

1.41
date	2017.05.30.20.31.24;	author mlarkin;	state Exp;
branches;
next	1.40;
commitid	J6oguuaQkwofWTMC;

1.40
date	2017.05.30.17.49.47;	author mlarkin;	state Exp;
branches;
next	1.39;
commitid	UUYd9gBIsonhUkI2;

1.39
date	2017.05.28.23.50.19;	author mlarkin;	state Exp;
branches;
next	1.38;
commitid	X9iyCYidk233OQ5x;

1.38
date	2017.05.19.06.29.21;	author mlarkin;	state Exp;
branches;
next	1.37;
commitid	G3D7ASX9mGO2MnYU;

1.37
date	2017.05.05.07.46.59;	author mlarkin;	state Exp;
branches;
next	1.36;
commitid	ToZZOQnGaLr35SVz;

1.36
date	2017.05.02.02.57.46;	author mlarkin;	state Exp;
branches;
next	1.35;
commitid	HydTd3xyEEPzT0KK;

1.35
date	2017.04.28.07.44.36;	author mlarkin;	state Exp;
branches;
next	1.34;
commitid	W3YIhOUPRwVQOMzX;

1.34
date	2017.04.27.07.15.35;	author mlarkin;	state Exp;
branches;
next	1.33;
commitid	UCcYFv2pV95IAVaE;

1.33
date	2017.04.27.06.16.39;	author mlarkin;	state Exp;
branches;
next	1.32;
commitid	ZHkhUOyGvsrTGUP9;

1.32
date	2017.03.23.08.05.58;	author mlarkin;	state Exp;
branches
	1.32.4.1;
next	1.31;
commitid	Ff8vDSG7AFdRDiwp;

1.31
date	2017.02.20.07.36.20;	author mlarkin;	state Exp;
branches;
next	1.30;
commitid	FHlFYjJ8E3g13IeF;

1.30
date	2017.01.24.09.50.54;	author mlarkin;	state Exp;
branches;
next	1.29;
commitid	wicrbbrs5Xx8YVe0;

1.29
date	2017.01.19.23.18.55;	author mlarkin;	state Exp;
branches;
next	1.28;
commitid	XHYKEJ6HTSHDCBo3;

1.28
date	2017.01.19.05.53.40;	author mlarkin;	state Exp;
branches;
next	1.27;
commitid	jqUwhD8sBcg6IE3K;

1.27
date	2017.01.19.01.33.45;	author mlarkin;	state Exp;
branches;
next	1.26;
commitid	QtJNxfg6Ki9fn2L9;

1.26
date	2017.01.13.02.27.37;	author mlarkin;	state Exp;
branches;
next	1.25;
commitid	HGQU3UN0D5tY1YX0;

1.25
date	2017.01.12.09.02.47;	author mlarkin;	state Exp;
branches;
next	1.24;
commitid	38nlqcIpQulk95ZY;

1.24
date	2017.01.11.09.15.18;	author mlarkin;	state Exp;
branches;
next	1.23;
commitid	aS3iYsNBHNI2jimM;

1.23
date	2016.10.26.05.15.13;	author mlarkin;	state Exp;
branches;
next	1.22;
commitid	9CtCNtWi118ZYGSV;

1.22
date	2016.10.12.06.56.54;	author mlarkin;	state Exp;
branches;
next	1.21;
commitid	d9eAYZoqV2dTESpL;

1.21
date	2016.10.06.07.37.51;	author mlarkin;	state Exp;
branches;
next	1.20;
commitid	ZI7DVHMVrS3IZX7i;

1.20
date	2016.10.03.04.53.54;	author mlarkin;	state Exp;
branches;
next	1.19;
commitid	SL6Z19PRyrIxqi88;

1.19
date	2016.09.04.08.49.18;	author mlarkin;	state Exp;
branches;
next	1.18;
commitid	QwHgCl0y5KPqqx14;

1.18
date	2016.09.01.16.04.47;	author stefan;	state Exp;
branches;
next	1.17;
commitid	xgCRvP7hLEqkM3Qf;

1.17
date	2016.09.01.15.01.45;	author stefan;	state Exp;
branches;
next	1.16;
commitid	1e4MbaS66tHETpf4;

1.16
date	2016.09.01.14.45.36;	author mlarkin;	state Exp;
branches;
next	1.15;
commitid	K7ioSO1L1IqvraJ9;

1.15
date	2016.06.10.16.37.16;	author stefan;	state Exp;
branches;
next	1.14;
commitid	CoKzeU4gWMUOOnIe;

1.14
date	2016.06.07.16.19.06;	author stefan;	state Exp;
branches;
next	1.13;
commitid	N4IUFQQXbAPAUf9e;

1.13
date	2016.04.25.15.24.55;	author mlarkin;	state Exp;
branches;
next	1.12;
commitid	IjKO3WbSR226gdka;

1.12
date	2016.04.06.06.15.06;	author mlarkin;	state Exp;
branches;
next	1.11;
commitid	cX1Avd5qqK2AWhez;

1.11
date	2016.03.13.13.11.47;	author stefan;	state Exp;
branches;
next	1.10;
commitid	tNFHzbetplEWT4Tg;

1.10
date	2016.03.09.08.06.59;	author mlarkin;	state Exp;
branches;
next	1.9;
commitid	e77RNR33wIry504s;

1.9
date	2016.02.20.20.49.08;	author mlarkin;	state Exp;
branches;
next	1.8;
commitid	J9Nf8wKYYiNBOlDr;

1.8
date	2016.02.16.18.59.30;	author stefan;	state Exp;
branches;
next	1.7;
commitid	wwRmEfOnB4C4MiVx;

1.7
date	2016.01.04.01.35.56;	author mlarkin;	state Exp;
branches;
next	1.6;
commitid	CdiRbflraxv1GBxf;

1.6
date	2015.12.17.09.29.28;	author mlarkin;	state Exp;
branches;
next	1.5;
commitid	8J3NuBrhKPtN9MxY;

1.5
date	2015.12.15.01.56.51;	author mlarkin;	state Exp;
branches;
next	1.4;
commitid	i1tEkWoVWghB5C5j;

1.4
date	2015.12.14.06.59.07;	author mlarkin;	state Exp;
branches;
next	1.3;
commitid	u2MfphuvnzQceP1z;

1.3
date	2015.11.26.08.26.48;	author reyk;	state Exp;
branches;
next	1.2;
commitid	GRMyPzYJL6q2Nvq3;

1.2
date	2015.11.16.10.08.41;	author mpi;	state Exp;
branches;
next	1.1;
commitid	KZ30ShVeuLAwERed;

1.1
date	2015.11.13.07.52.20;	author mlarkin;	state Exp;
branches;
next	;
commitid	KdsjYlqLpqhwOUHf;

1.32.4.1
date	2017.05.03.02.29.16;	author jsg;	state Exp;
branches;
next	;
commitid	G8fCSoM66ex6Gjxp;


desc
@@


1.43
log
@Make max memory for VMs equal to MAXDSIZ to avoid failing later during
VM setup.

ok pd
@
text
@/*	$OpenBSD: vmmvar.h,v 1.42 2017/07/06 06:19:15 mlarkin Exp $	*/
/*
 * Copyright (c) 2014 Mike Larkin <mlarkin@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * CPU capabilities for VMM operation
 */
#ifndef _MACHINE_VMMVAR_H_
#define _MACHINE_VMMVAR_H_

#define VMM_HV_SIGNATURE 	"OpenBSDVMM58"

#define VMM_MAX_MEM_RANGES	16
#define VMM_MAX_DISKS_PER_VM	4
#define VMM_MAX_PATH_DISK	128
#define VMM_MAX_NAME_LEN	32
#define VMM_MAX_KERNEL_PATH	128
#define VMM_MAX_VCPUS_PER_VM	64
#define VMM_MAX_VM_MEM_SIZE	32768
#define VMM_MAX_NICS_PER_VM	4

#define VMM_PCI_MMIO_BAR_BASE	0xF0000000
#define VMM_PCI_MMIO_BAR_END	0xFFFFFFFF
#define VMM_PCI_MMIO_BAR_SIZE	0x00010000
#define VMM_PCI_IO_BAR_BASE	0x1000
#define VMM_PCI_IO_BAR_END	0xFFFF
#define VMM_PCI_IO_BAR_SIZE	0x1000

/* VMX: Basic Exit Reasons */
#define VMX_EXIT_NMI				0
#define VMX_EXIT_EXTINT				1
#define VMX_EXIT_TRIPLE_FAULT			2
#define VMX_EXIT_INIT				3
#define VMX_EXIT_SIPI				4
#define VMX_EXIT_IO_SMI				5
#define VMX_EXIT_OTHER_SMI			6
#define VMX_EXIT_INT_WINDOW			7
#define VMX_EXIT_NMI_WINDOW			8
#define VMX_EXIT_TASK_SWITCH			9
#define VMX_EXIT_CPUID				10
#define VMX_EXIT_GETSEC				11
#define VMX_EXIT_HLT				12
#define VMX_EXIT_INVD				13
#define VMX_EXIT_INVLPG				14
#define VMX_EXIT_RDPMC				15
#define VMX_EXIT_RDTSC				16
#define VMX_EXIT_RSM				17
#define VMX_EXIT_VMCALL				18
#define VMX_EXIT_VMCLEAR			19
#define VMX_EXIT_VMLAUNCH			20
#define VMX_EXIT_VMPTRLD			21
#define VMX_EXIT_VMPTRST			22
#define VMX_EXIT_VMREAD				23
#define VMX_EXIT_VMRESUME			24
#define VMX_EXIT_VMWRITE			25
#define VMX_EXIT_VMXOFF				26
#define VMX_EXIT_VMXON				27
#define VMX_EXIT_CR_ACCESS			28
#define VMX_EXIT_MOV_DR				29
#define VMX_EXIT_IO				30
#define VMX_EXIT_RDMSR				31
#define VMX_EXIT_WRMSR				32
#define VMX_EXIT_ENTRY_FAILED_GUEST_STATE	33
#define VMX_EXIT_ENTRY_FAILED_MSR_LOAD		34
#define VMX_EXIT_MWAIT				36
#define VMX_EXIT_MTF				37
#define VMX_EXIT_MONITOR			39
#define VMX_EXIT_PAUSE				40
#define VMX_EXIT_ENTRY_FAILED_MCE		41
#define VMX_EXIT_TPR_BELOW_THRESHOLD		43
#define VMX_EXIT_APIC_ACCESS			44
#define VMX_EXIT_VIRTUALIZED_EOI		45
#define VMX_EXIT_GDTR_IDTR			46
#define	VMX_EXIT_LDTR_TR			47
#define VMX_EXIT_EPT_VIOLATION			48
#define VMX_EXIT_EPT_MISCONFIGURATION		49
#define VMX_EXIT_INVEPT				50
#define VMX_EXIT_RDTSCP				51
#define VMX_EXIT_VMX_PREEMPTION_TIMER_EXPIRED	52
#define VMX_EXIT_INVVPID			53
#define VMX_EXIT_WBINVD				54
#define VMX_EXIT_XSETBV				55
#define VMX_EXIT_APIC_WRITE			56
#define VMX_EXIT_RDRAND				57
#define VMX_EXIT_INVPCID			58
#define VMX_EXIT_VMFUNC				59
#define VMX_EXIT_RDSEED				61
#define VMX_EXIT_XSAVES				63
#define VMX_EXIT_XRSTORS			64

/*
 * VMX: Misc defines
 */
#define VMX_MAX_CR3_TARGETS			256

#define VM_EXIT_TERMINATED			0xFFFE
#define VM_EXIT_NONE				0xFFFF

/*
 * SVM: Intercept codes (exit reasons)
 */
#define SVM_VMEXIT_CR0_READ			0x00
#define SVM_VMEXIT_CR1_READ			0x01
#define SVM_VMEXIT_CR2_READ			0x02
#define SVM_VMEXIT_CR3_READ			0x03
#define SVM_VMEXIT_CR4_READ			0x04
#define SVM_VMEXIT_CR5_READ			0x05
#define SVM_VMEXIT_CR6_READ			0x06
#define SVM_VMEXIT_CR7_READ			0x07
#define SVM_VMEXIT_CR8_READ			0x08
#define SVM_VMEXIT_CR9_READ			0x09
#define SVM_VMEXIT_CR10_READ			0x0A
#define SVM_VMEXIT_CR11_READ			0x0B
#define SVM_VMEXIT_CR12_READ			0x0C
#define SVM_VMEXIT_CR13_READ			0x0D
#define SVM_VMEXIT_CR14_READ			0x0E
#define SVM_VMEXIT_CR15_READ			0x0F
#define SVM_VMEXIT_CR0_WRITE			0x10
#define SVM_VMEXIT_CR1_WRITE			0x11
#define SVM_VMEXIT_CR2_WRITE			0x12
#define SVM_VMEXIT_CR3_WRITE			0x13
#define SVM_VMEXIT_CR4_WRITE			0x14
#define SVM_VMEXIT_CR5_WRITE			0x15
#define SVM_VMEXIT_CR6_WRITE			0x16
#define SVM_VMEXIT_CR7_WRITE			0x17
#define SVM_VMEXIT_CR8_WRITE			0x18
#define SVM_VMEXIT_CR9_WRITE			0x19
#define SVM_VMEXIT_CR10_WRITE			0x1A
#define SVM_VMEXIT_CR11_WRITE			0x1B
#define SVM_VMEXIT_CR12_WRITE			0x1C
#define SVM_VMEXIT_CR13_WRITE			0x1D
#define SVM_VMEXIT_CR14_WRITE			0x1E
#define SVM_VMEXIT_CR15_WRITE			0x1F
#define SVM_VMEXIT_DR0_READ			0x20
#define SVM_VMEXIT_DR1_READ			0x21
#define SVM_VMEXIT_DR2_READ			0x22
#define SVM_VMEXIT_DR3_READ			0x23
#define SVM_VMEXIT_DR4_READ			0x24
#define SVM_VMEXIT_DR5_READ			0x25
#define SVM_VMEXIT_DR6_READ			0x26
#define SVM_VMEXIT_DR7_READ			0x27
#define SVM_VMEXIT_DR8_READ			0x28
#define SVM_VMEXIT_DR9_READ			0x29
#define SVM_VMEXIT_DR10_READ			0x2A
#define SVM_VMEXIT_DR11_READ			0x2B
#define SVM_VMEXIT_DR12_READ			0x2C
#define SVM_VMEXIT_DR13_READ			0x2D
#define SVM_VMEXIT_DR14_READ			0x2E
#define SVM_VMEXIT_DR15_READ			0x2F
#define SVM_VMEXIT_DR0_WRITE			0x30
#define SVM_VMEXIT_DR1_WRITE			0x31
#define SVM_VMEXIT_DR2_WRITE			0x32
#define SVM_VMEXIT_DR3_WRITE			0x33
#define SVM_VMEXIT_DR4_WRITE			0x34
#define SVM_VMEXIT_DR5_WRITE			0x35
#define SVM_VMEXIT_DR6_WRITE			0x36
#define SVM_VMEXIT_DR7_WRITE			0x37
#define SVM_VMEXIT_DR8_WRITE			0x38
#define SVM_VMEXIT_DR9_WRITE			0x39
#define SVM_VMEXIT_DR10_WRITE			0x3A
#define SVM_VMEXIT_DR11_WRITE			0x3B
#define SVM_VMEXIT_DR12_WRITE			0x3C
#define SVM_VMEXIT_DR13_WRITE			0x3D
#define SVM_VMEXIT_DR14_WRITE			0x3E
#define SVM_VMEXIT_DR15_WRITE			0x3F
#define SVM_VMEXIT_EXCP0			0x40
#define SVM_VMEXIT_EXCP1			0x41
#define SVM_VMEXIT_EXCP2			0x42
#define SVM_VMEXIT_EXCP3			0x43
#define SVM_VMEXIT_EXCP4			0x44
#define SVM_VMEXIT_EXCP5			0x45
#define SVM_VMEXIT_EXCP6			0x46
#define SVM_VMEXIT_EXCP7			0x47
#define SVM_VMEXIT_EXCP8			0x48
#define SVM_VMEXIT_EXCP9			0x49
#define SVM_VMEXIT_EXCP10			0x4A
#define SVM_VMEXIT_EXCP11			0x4B
#define SVM_VMEXIT_EXCP12			0x4C
#define SVM_VMEXIT_EXCP13			0x4D
#define SVM_VMEXIT_EXCP14			0x4E
#define SVM_VMEXIT_EXCP15			0x4F
#define SVM_VMEXIT_EXCP16			0x50
#define SVM_VMEXIT_EXCP17			0x51
#define SVM_VMEXIT_EXCP18			0x52
#define SVM_VMEXIT_EXCP19			0x53
#define SVM_VMEXIT_EXCP20			0x54
#define SVM_VMEXIT_EXCP21			0x55
#define SVM_VMEXIT_EXCP22			0x56
#define SVM_VMEXIT_EXCP23			0x57
#define SVM_VMEXIT_EXCP24			0x58
#define SVM_VMEXIT_EXCP25			0x59
#define SVM_VMEXIT_EXCP26			0x5A
#define SVM_VMEXIT_EXCP27			0x5B
#define SVM_VMEXIT_EXCP28			0x5C
#define SVM_VMEXIT_EXCP29			0x5D
#define SVM_VMEXIT_EXCP30			0x5E
#define SVM_VMEXIT_EXCP31			0x5F
#define SVM_VMEXIT_INTR				0x60
#define SVM_VMEXIT_NMI				0x61
#define SVM_VMEXIT_SMI				0x62
#define SVM_VMEXIT_INIT				0x63
#define SVM_VMEXIT_VINTR			0x64
#define SVM_VMEXIT_CR0_SEL_WRITE		0x65
#define SVM_VMEXIT_IDTR_READ			0x66
#define SVM_VMEXIT_GDTR_READ			0x67
#define SVM_VMEXIT_LDTR_READ			0x68
#define SVM_VMEXIT_TR_READ			0x69
#define SVM_VMEXIT_IDTR_WRITE			0x6A
#define SVM_VMEXIT_GDTR_WRITE			0x6B
#define SVM_VMEXIT_LDTR_WRITE			0x6C
#define SVM_VMEXIT_TR_WRITE			0x6D
#define SVM_VMEXIT_RDTSC			0x6E
#define SVM_VMEXIT_RDPMC			0x6F
#define SVM_VMEXIT_PUSHF			0x70
#define SVM_VMEXIT_POPF				0x71
#define SVM_VMEXIT_CPUID			0x72
#define SVM_VMEXIT_RSM				0x73
#define SVM_VMEXIT_IRET				0x74
#define SVM_VMEXIT_SWINT			0x75
#define SVM_VMEXIT_INVD				0x76
#define SVM_VMEXIT_PAUSE			0x77
#define SVM_VMEXIT_HLT				0x78
#define SVM_VMEXIT_INVLPG			0x79
#define SVM_VMEXIT_INVLPGA			0x7A
#define SVM_VMEXIT_IOIO				0x7B
#define SVM_VMEXIT_MSR				0x7C
#define SVM_VMEXIT_TASK_SWITCH			0x7D
#define SVM_VMEXIT_FERR_FREEZE			0x7E
#define SVM_VMEXIT_SHUTDOWN			0x7F
#define SVM_VMEXIT_VMRUN			0x80
#define SVM_VMEXIT_VMMCALL			0x81
#define SVM_VMEXIT_VMLOAD			0x82
#define SVM_VMEXIT_VMSAVE			0x83
#define SVM_VMEXIT_STGI				0x84
#define SVM_VMEXIT_CLGI				0x85
#define SVM_VMEXIT_SKINIT			0x86
#define SVM_VMEXIT_RDTSCP			0x87
#define SVM_VMEXIT_ICEBP			0x88
#define SVM_VMEXIT_WBINVD			0x89
#define SVM_VMEXIT_MONITOR			0x8A
#define SVM_VMEXIT_MWAIT			0x8B
#define SVM_VMEXIT_MWAIT_CONDITIONAL		0x8C
#define SVM_VMEXIT_XSETBV			0x8D
#define SVM_VMEXIT_EFER_WRITE_TRAP		0x8F
#define SVM_VMEXIT_CR0_WRITE_TRAP		0x90
#define SVM_VMEXIT_CR1_WRITE_TRAP		0x91
#define SVM_VMEXIT_CR2_WRITE_TRAP		0x92
#define SVM_VMEXIT_CR3_WRITE_TRAP		0x93
#define SVM_VMEXIT_CR4_WRITE_TRAP		0x94
#define SVM_VMEXIT_CR5_WRITE_TRAP		0x95
#define SVM_VMEXIT_CR6_WRITE_TRAP		0x96
#define SVM_VMEXIT_CR7_WRITE_TRAP		0x97
#define SVM_VMEXIT_CR8_WRITE_TRAP		0x98
#define SVM_VMEXIT_CR9_WRITE_TRAP		0x99
#define SVM_VMEXIT_CR10_WRITE_TRAP		0x9A
#define SVM_VMEXIT_CR11_WRITE_TRAP		0x9B
#define SVM_VMEXIT_CR12_WRITE_TRAP		0x9C
#define SVM_VMEXIT_CR13_WRITE_TRAP		0x9D
#define SVM_VMEXIT_CR14_WRITE_TRAP		0x9E
#define SVM_VMEXIT_CR15_WRITE_TRAP		0x9F
#define SVM_VMEXIT_NPF				0x400
#define SVM_AVIC_INCOMPLETE_IPI			0x401
#define SVM_AVIC_NOACCEL			0x402
#define SVM_VMEXIT_VMGEXIT			0x403
#define SVM_VMEXIT_INVALID			-1

/*
 * VCPU state values. Note that there is a conversion function in vmm.c
 * (vcpu_state_decode) that converts these to human readable strings,
 * so this enum and vcpu_state_decode should be kept in sync.
 */
enum {
	VCPU_STATE_STOPPED,
	VCPU_STATE_RUNNING,
	VCPU_STATE_REQTERM,
	VCPU_STATE_TERMINATED,
	VCPU_STATE_UNKNOWN,
};

enum {
	VEI_DIR_OUT,
	VEI_DIR_IN
};

/*
 * vm exit data
 *  vm_exit_inout		: describes an IN/OUT exit
 */
struct vm_exit_inout {
	uint8_t			vei_size;	/* Size of access */
	uint8_t			vei_dir;	/* Direction */
	uint8_t			vei_rep;	/* REP prefix? */
	uint8_t			vei_string;	/* string variety? */
	uint8_t			vei_encoding;	/* operand encoding */
	uint16_t		vei_port;	/* port */
	uint32_t		vei_data;	/* data (for IN insns) */
};

union vm_exit {
	struct vm_exit_inout	vei;		/* IN/OUT exit */
};

/*
 * struct vcpu_segment_info describes a segment + selector set, used
 * in constructing the initial vcpu register content
 */
struct vcpu_segment_info {
	uint16_t vsi_sel;
	uint32_t vsi_limit;
	uint32_t vsi_ar;
	uint64_t vsi_base;
};

#define VCPU_REGS_RAX		0
#define VCPU_REGS_RBX		1
#define VCPU_REGS_RCX		2
#define VCPU_REGS_RDX		3
#define VCPU_REGS_RSI		4
#define VCPU_REGS_RDI		5
#define VCPU_REGS_R8		6
#define VCPU_REGS_R9		7
#define VCPU_REGS_R10		8
#define VCPU_REGS_R11		9
#define VCPU_REGS_R12		10
#define VCPU_REGS_R13		11
#define VCPU_REGS_R14		12
#define VCPU_REGS_R15		13
#define VCPU_REGS_RSP		14
#define VCPU_REGS_RBP		15
#define VCPU_REGS_RIP		16
#define VCPU_REGS_RFLAGS	17
#define VCPU_REGS_NGPRS		(VCPU_REGS_RFLAGS + 1)

#define VCPU_REGS_CR0	0
#define VCPU_REGS_CR2	1
#define VCPU_REGS_CR3	2
#define VCPU_REGS_CR4	3
#define VCPU_REGS_CR8	4
#define VCPU_REGS_XCR0	5
#define VCPU_REGS_NCRS	(VCPU_REGS_XCR0 + 1)

#define VCPU_REGS_CS		0
#define VCPU_REGS_DS		1
#define VCPU_REGS_ES		2
#define VCPU_REGS_FS		3
#define VCPU_REGS_GS		4
#define VCPU_REGS_SS		5
#define VCPU_REGS_LDTR		6
#define VCPU_REGS_TR		7
#define VCPU_REGS_NSREGS	(VCPU_REGS_TR + 1)

#define VCPU_REGS_EFER   	0
#define VCPU_REGS_STAR   	1
#define VCPU_REGS_LSTAR  	2
#define VCPU_REGS_CSTAR  	3
#define VCPU_REGS_SFMASK 	4
#define VCPU_REGS_KGSBASE	5
#define VCPU_REGS_NMSRS	(VCPU_REGS_KGSBASE + 1)

struct vcpu_reg_state {
	uint64_t			vrs_gprs[VCPU_REGS_NGPRS];
	uint64_t			vrs_crs[VCPU_REGS_NCRS];
	uint64_t			vrs_msrs[VCPU_REGS_NMSRS];
	struct vcpu_segment_info	vrs_sregs[VCPU_REGS_NSREGS];
	struct vcpu_segment_info	vrs_gdtr;
	struct vcpu_segment_info	vrs_idtr;
};

struct vm_mem_range {
	paddr_t	vmr_gpa;
	vaddr_t vmr_va;
	size_t	vmr_size;
};

struct vm_create_params {
	/* Input parameters to VMM_IOC_CREATE */
	size_t			vcp_nmemranges;
	size_t			vcp_ncpus;
	size_t			vcp_ndisks;
	size_t			vcp_nnics;
	struct vm_mem_range	vcp_memranges[VMM_MAX_MEM_RANGES];
	char			vcp_disks[VMM_MAX_DISKS_PER_VM][VMM_MAX_PATH_DISK];
	char			vcp_name[VMM_MAX_NAME_LEN];
	char			vcp_kernel[VMM_MAX_KERNEL_PATH];
	uint8_t			vcp_macs[VMM_MAX_NICS_PER_VM][6];

	/* Output parameter from VMM_IOC_CREATE */
	uint32_t	vcp_id;
};

struct vm_run_params {
	/* Input parameters to VMM_IOC_RUN */
	uint32_t	vrp_vm_id;
	uint32_t	vrp_vcpu_id;
	uint8_t		vrp_continue;		/* Continuing from an exit */
	uint16_t	vrp_irq;		/* IRQ to inject */

	/* Input/output parameter to VMM_IOC_RUN */
	union vm_exit	*vrp_exit;		/* updated exit data */

	/* Output parameter from VMM_IOC_RUN */
	uint16_t	vrp_exit_reason;	/* exit reason */
	uint8_t		vrp_irqready;		/* ready for IRQ on entry */
};

struct vm_info_result {
	/* Output parameters from VMM_IOC_INFO */
	size_t		vir_memory_size;
	size_t		vir_used_size;
	size_t		vir_ncpus;
	uint8_t		vir_vcpu_state[VMM_MAX_VCPUS_PER_VM];
	pid_t		vir_creator_pid;
	uint32_t	vir_id;
	char		vir_name[VMM_MAX_NAME_LEN];
};

struct vm_info_params {
	/* Input parameters to VMM_IOC_INFO */
	size_t			vip_size;	/* Output buffer size */

	/* Output Parameters from VMM_IOC_INFO */
	size_t			 vip_info_ct;	/* # of entries returned */
	struct vm_info_result	*vip_info;	/* Output buffer */
};

struct vm_terminate_params {
	/* Input parameters to VMM_IOC_TERM */
	uint32_t		vtp_vm_id;
};

struct vm_resetcpu_params {
	/* Input parameters to VMM_IOC_RESETCPU */
	uint32_t		vrp_vm_id;
	uint32_t		vrp_vcpu_id;
	struct vcpu_reg_state	vrp_init_state;
};

struct vm_intr_params {
	/* Input parameters to VMM_IOC_INTR */
	uint32_t		vip_vm_id;
	uint32_t		vip_vcpu_id;
	uint16_t		vip_intr;
};

#define VM_RWREGS_GPRS	0x1	/* read/write GPRs */
#define VM_RWREGS_SREGS	0x2	/* read/write segment registers */
#define VM_RWREGS_CRS	0x4	/* read/write CRs */
#define VM_RWREGS_MSRS	0x8	/* read/write MSRs */
#define VM_RWREGS_ALL	(VM_RWREGS_GPRS | VM_RWREGS_SREGS | VM_RWREGS_CRS | \
    VM_RWREGS_MSRS)

struct vm_rwregs_params {
	uint32_t		vrwp_vm_id;
	uint32_t		vrwp_vcpu_id;
	uint64_t		vrwp_mask;
	struct vcpu_reg_state	vrwp_regs;
};

/* IOCTL definitions */
#define VMM_IOC_CREATE _IOWR('V', 1, struct vm_create_params) /* Create VM */
#define VMM_IOC_RUN _IOWR('V', 2, struct vm_run_params) /* Run VCPU */
#define VMM_IOC_INFO _IOWR('V', 3, struct vm_info_params) /* Get VM Info */
#define VMM_IOC_TERM _IOW('V', 4, struct vm_terminate_params) /* Terminate VM */
#define VMM_IOC_RESETCPU _IOW('V', 5, struct vm_resetcpu_params) /* Reset */
#define VMM_IOC_INTR _IOW('V', 6, struct vm_intr_params) /* Intr pending */
#define VMM_IOC_READREGS _IOWR('V', 7, struct vm_rwregs_params) /* Get registers */
#define VMM_IOC_WRITEREGS _IOW('V', 8, struct vm_rwregs_params) /* Set registers */

#ifdef _KERNEL

#define VMX_FAIL_LAUNCH_UNKNOWN 1
#define VMX_FAIL_LAUNCH_INVALID_VMCS 2
#define VMX_FAIL_LAUNCH_VALID_VMCS 3

#define VMX_NUM_MSR_STORE 6

/* MSR bitmap manipulation macros */
#define VMX_MSRIDX(m) ((m) / 8)
#define VMX_MSRBIT(m) (1 << (m) % 8)

#define SVM_MSRIDX(m) ((m) / 4)
#define SVM_MSRBIT_R(m) (1 << (((m) % 4) * 2))
#define SVM_MSRBIT_W(m) (1 << (((m) % 4) * 2 + 1))

enum {
	VMM_MODE_UNKNOWN,
	VMM_MODE_VMX,
	VMM_MODE_EPT,
	VMM_MODE_SVM,
	VMM_MODE_RVI
};

enum {
	VMM_MEM_TYPE_REGULAR,
	VMM_MEM_TYPE_UNKNOWN	
};

/* Forward declarations */
struct vm;

/*
 * Implementation-specific cpu state
 */

struct vmcb_segment {
	uint16_t 			vs_sel;			/* 000h */
	uint16_t 			vs_attr;		/* 002h */
	uint32_t			vs_lim;			/* 004h */
	uint64_t			vs_base;		/* 008h */
};

struct vmcb {
	union {
		struct {
			uint32_t	v_cr_rw;		/* 000h */
			uint32_t	v_dr_rw;		/* 004h */
			uint32_t	v_excp;			/* 008h */
			uint32_t	v_intercept1;		/* 00Ch */
			uint32_t	v_intercept2;		/* 010h */
			uint8_t		v_pad1[0x28];		/* 014h-03Bh */
			uint16_t	v_pause_thr;		/* 03Ch */
			uint16_t	v_pause_ct;		/* 03Eh */
			uint64_t	v_iopm_pa;		/* 040h */
			uint64_t	v_msrpm_pa;		/* 048h */
			uint64_t	v_tsc_offset;		/* 050h */
			uint32_t	v_asid;			/* 058h */
			uint8_t		v_tlb_control;		/* 05Ch */
			uint8_t		v_pad2[0x3];		/* 05Dh-05Fh */
			uint8_t		v_tpr;			/* 060h */
			uint8_t		v_irq;			/* 061h */
			uint8_t		v_intr_misc;		/* 062h */
			uint8_t		v_intr_masking;		/* 063h */
			uint8_t		v_intr_vector;		/* 064h */
			uint8_t		v_pad3[0x3];		/* 065h-067h */
			uint64_t	v_intr_shadow;		/* 068h */
			uint64_t	v_exitcode;		/* 070h */
			uint64_t	v_exitinfo1;		/* 078h */
			uint64_t	v_exitinfo2;		/* 080h */
			uint64_t	v_exitintinfo;		/* 088h */
			uint64_t	v_np_enable;		/* 090h */
			uint64_t	v_avic_apic_bar;	/* 098h */
			uint64_t	v_pad4;			/* 0A0h */
			uint64_t	v_eventinj;		/* 0A8h */
			uint64_t	v_n_cr3;		/* 0B0h */
			uint64_t	v_lbr_virt_enable;	/* 0B8h */
			uint64_t	v_vmcb_clean_bits;	/* 0C0h */
			uint64_t	v_nrip;			/* 0C8h */
			uint8_t		v_n_bytes_fetched;	/* 0D0h */
			uint8_t		v_guest_ins_bytes[0xf];	/* 0D1h-0DFh */
			uint64_t	v_avic_apic_back_page;	/* 0E0h */
			uint64_t	v_pad5;			/* 0E8h-0EFh */
			uint64_t	v_avic_logical_table;	/* 0F0h */
			uint64_t	v_avic_phys;		/* 0F8h */
			
		};
		uint8_t vmcb_control[0x400];
	};

	union {
		struct {
			/* Offsets here are relative to start of VMCB SSA */
			struct vmcb_segment	v_es;		/* 000h */
			struct vmcb_segment	v_cs;		/* 010h */
			struct vmcb_segment	v_ss;		/* 020h */
			struct vmcb_segment	v_ds;		/* 030h */
			struct vmcb_segment	v_fs;		/* 040h */
			struct vmcb_segment	v_gs;		/* 050h */
			struct vmcb_segment	v_gdtr;		/* 060h */
			struct vmcb_segment	v_ldtr;		/* 070h */
			struct vmcb_segment	v_idtr;		/* 080h */
			struct vmcb_segment	v_tr;		/* 090h */
			uint8_t 		v_pad6[0x2B];	/* 0A0h-0CAh */
			uint8_t			v_cpl;		/* 0CBh */
			uint32_t		v_pad7;		/* 0CCh-0CFh */
			uint64_t		v_efer;		/* 0D0h */
			uint8_t			v_pad8[0x70];	/* 0D8h-147h */
			uint64_t		v_cr4;		/* 148h */
			uint64_t		v_cr3;		/* 150h */
			uint64_t		v_cr0;		/* 158h */
			uint64_t		v_dr7;		/* 160h */
			uint64_t		v_dr6;		/* 168h */
			uint64_t		v_rflags;	/* 170h */
			uint64_t		v_rip;		/* 178h */
			uint64_t		v_pad9[0xB];	/* 180h-1D7h */
			uint64_t		v_rsp;		/* 1D8h */
			uint64_t		v_pad10[0x3];	/* 1E0h-1F7h */
			uint64_t		v_rax;		/* 1F8h */
			uint64_t		v_star;		/* 200h */
			uint64_t		v_lstar;	/* 208h */
			uint64_t		v_cstar;	/* 210h */
			uint64_t		v_sfmask;	/* 218h */
			uint64_t		v_kgsbase;	/* 220h */
			uint64_t		v_sysenter_cs;	/* 228h */
			uint64_t		v_sysenter_esp;	/* 230h */
			uint64_t		v_sysenter_eip;	/* 238h */
			uint64_t		v_cr2;		/* 240h */
			uint64_t		v_pad11[0x4];	/* 248h-267h */
			uint64_t		v_g_pat;	/* 268h */
			uint64_t		v_dbgctl;	/* 270h */
			uint64_t		v_br_from;	/* 278h */
			uint64_t		v_br_to;	/* 280h */
			uint64_t		v_lastexcpfrom;	/* 288h */
			uint64_t		v_lastexcpto;	/* 290h */
		};

		uint8_t vmcb_layout[PAGE_SIZE - 0x400];
	};
};

struct vmcs {
	uint32_t	vmcs_revision;
};

struct vmx_invvpid_descriptor
{
	uint64_t	vid_vpid;
	uint64_t	vid_addr;
};

struct vmx_invept_descriptor
{
	uint64_t	vid_eptp;
	uint64_t	vid_reserved;
};

struct vmx_msr_store
{
	uint64_t	vms_index;
	uint64_t	vms_data;
};

/*
 * Storage for guest registers not preserved in VMCS and various exit
 * information.
 *
 * Note that vmx/svm_enter_guest depend on the layout of this struct for
 * field access.
 */
struct vcpu_gueststate
{
	/* %rsi should be first */
	uint64_t	vg_rsi;			/* 0x00 */
	uint64_t	vg_rax;			/* 0x08 */
	uint64_t	vg_rbx;			/* 0x10 */
	uint64_t	vg_rcx;			/* 0x18 */
	uint64_t	vg_rdx;			/* 0x20 */
	uint64_t	vg_rdi;			/* 0x28 */
	uint64_t	vg_rbp;			/* 0x30 */
	uint64_t	vg_r8;			/* 0x38 */
	uint64_t	vg_r9;			/* 0x40 */
	uint64_t	vg_r10;			/* 0x48 */
	uint64_t	vg_r11;			/* 0x50 */
	uint64_t	vg_r12;			/* 0x58 */
	uint64_t	vg_r13;			/* 0x60 */
	uint64_t	vg_r14;			/* 0x68 */
	uint64_t	vg_r15;			/* 0x70 */
	uint64_t	vg_cr2;			/* 0x78 */
	uint64_t	vg_rip;			/* 0x80 */
	uint32_t	vg_exit_reason;		/* 0x88 */
	uint64_t	vg_rflags;		/* 0x90 */
	uint64_t	vg_xcr0;		/* 0x98 */
};

/*
 * Virtual Machine
 */
struct vm;

/*
 * Virtual CPU
 */
struct vcpu {
	/*
	 * Guest FPU state - this must remain as the first member of the struct
	 * to ensure 64-byte alignment (set up during vcpu_pool init)
	 */
	struct savefpu vc_g_fpu;

	/* VMCS / VMCB pointer */
	vaddr_t vc_control_va;
	uint64_t vc_control_pa;

	/* VLAPIC pointer */
	vaddr_t vc_vlapic_va;
	uint64_t vc_vlapic_pa;

	/* MSR bitmap address */
	vaddr_t vc_msr_bitmap_va;
	uint64_t vc_msr_bitmap_pa;

	struct vm *vc_parent;
	uint32_t vc_id;
	uint16_t vc_vpid;
	u_int vc_state;
	SLIST_ENTRY(vcpu) vc_vcpu_link;

	uint8_t vc_virt_mode;

	struct cpu_info *vc_last_pcpu;
	union vm_exit vc_exit;

	uint16_t vc_intr;
	uint8_t vc_irqready;

	uint8_t vc_fpuinited;

	uint64_t vc_h_xcr0;

	struct vcpu_gueststate vc_gueststate;

	uint8_t vc_event;

	/* VMX only */
	uint64_t vc_vmx_basic;
	uint64_t vc_vmx_entry_ctls;
	uint64_t vc_vmx_true_entry_ctls;
	uint64_t vc_vmx_exit_ctls;
	uint64_t vc_vmx_true_exit_ctls;
	uint64_t vc_vmx_pinbased_ctls;
	uint64_t vc_vmx_true_pinbased_ctls;
	uint64_t vc_vmx_procbased_ctls;
	uint64_t vc_vmx_true_procbased_ctls;
	uint64_t vc_vmx_procbased2_ctls;
	vaddr_t vc_vmx_msr_exit_save_va;
	paddr_t vc_vmx_msr_exit_save_pa;
	vaddr_t vc_vmx_msr_exit_load_va;
	paddr_t vc_vmx_msr_exit_load_pa;
	vaddr_t vc_vmx_msr_entry_load_va;
	paddr_t vc_vmx_msr_entry_load_pa;
	uint8_t vc_vmx_vpid_enabled;

	/* SVM only */
	vaddr_t vc_svm_hsa_va;
	paddr_t vc_svm_hsa_pa;
	vaddr_t vc_svm_ioio_va;
	paddr_t vc_svm_ioio_pa;
};

SLIST_HEAD(vcpu_head, vcpu);

void	vmm_dispatch_intr(vaddr_t);
int	vmxon(uint64_t *);
int	vmxoff(void);
int	vmclear(uint64_t *);
int	vmptrld(uint64_t *);
int	vmptrst(uint64_t *);
int	vmwrite(uint64_t, uint64_t);
int	vmread(uint64_t, uint64_t *);
void	invvpid(uint64_t, struct vmx_invvpid_descriptor *);
void	invept(uint64_t, struct vmx_invept_descriptor *);
int	vmx_enter_guest(uint64_t *, struct vcpu_gueststate *, int);
int	svm_enter_guest(uint64_t, struct vcpu_gueststate *,
    struct region_descriptor *);
void	start_vmm_on_cpu(struct cpu_info *);
void	stop_vmm_on_cpu(struct cpu_info *);

#endif /* _KERNEL */

#endif /* ! _MACHINE_VMMVAR_H_ */
@


1.42
log
@vmd: increase the max number of disks from 2 to 4. Requires kernel rebuild
as a struct passed to vmm has changed size.

ok deraadt, pd
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.41 2017/05/30 20:31:24 mlarkin Exp $	*/
d32 1
a32 1
#define VMM_MAX_VM_MEM_SIZE	(512 * 1024)
@


1.41
log
@event injection framework, will be used for other features coming shortly

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.40 2017/05/30 17:49:47 mlarkin Exp $	*/
d27 1
a27 1
#define VMM_MAX_DISKS_PER_VM	2
@


1.40
log
@FPU context save/restore for SVM in vmm(4), matches a previous diff
from a few weeks ago that did the same for Intel/VMX.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.39 2017/05/28 23:50:19 mlarkin Exp $	*/
d723 2
@


1.39
log
@rename some fields
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.38 2017/05/19 06:29:21 mlarkin Exp $	*/
d256 18
d275 3
@


1.38
log
@Respect max VPID/ASID limits. VMX VPIDs are capped at 4095, for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.37 2017/05/05 07:46:59 mlarkin Exp $	*/
d523 3
a525 3
			uint8_t		v_misc1;		/* 062h */
			uint8_t		v_misc2;		/* 063h */
			uint8_t		v_misc3;		/* 064h */
@


1.37
log
@Allow setting guest %xcr0 from vmd(8).

Tested on linux and amd64 OpenBSD guests.

Posted to tech by Pratik Vyas.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.36 2017/05/02 02:57:46 mlarkin Exp $	*/
d685 1
@


1.36
log
@Allow setting of guest MSRs from vmd(8). This change is the first part of
a larger effort to implement vmctl send/vmctl receive (snapshot and VM
migration).

From Pratik Vyas, Siri Chandana, Harshada Mone and Ashwin Agrawal, a
group of students I am supervising.

ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.35 2017/04/28 07:44:36 mlarkin Exp $	*/
d331 2
a332 1
#define VCPU_REGS_NCRS	(VCPU_REGS_CR8 + 1)
@


1.35
log
@vmm: don't use invvpid if we didn't detect vpid capability during
vcpu setup
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.34 2017/04/27 07:15:35 mlarkin Exp $	*/
d343 8
d354 1
d439 3
a441 1
#define VM_RWREGS_ALL	(VM_RWREGS_GPRS | VM_RWREGS_SREGS | VM_RWREGS_CRS)
@


1.34
log
@rename a struct that was denoted as "VMX only" to make it more clear
that it can be used in SVM and VMX.

no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.33 2017/04/27 06:16:39 mlarkin Exp $	*/
d707 1
@


1.33
log
@vmm(4): proper save/restore of FPU context during entry/exit.

tested by reyk, dcoppa, and a few others.

ok kettenis@@ on the fpu bits
ok deraadt@@ on the vmm bits
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.32 2017/03/23 08:05:58 mlarkin Exp $	*/
d616 1
a616 1
 * Note that vmx_enter_guest depends on the layout of this struct for
d619 1
a619 1
struct vmx_gueststate
d688 2
a700 1
	struct vmx_gueststate vc_gueststate;
d727 2
a728 2
int	vmx_enter_guest(uint64_t *, struct vmx_gueststate *, int);
int	svm_enter_guest(uint64_t, struct vmx_gueststate *,
@


1.32
log
@Bump the emulated PCI MMIO range end to 0xFFFFFFFF. This slightly
penalizes i386 guests who previously had memory allocated by vmd after
0xF0FFFFFF (the previous range end) but makes memory range calculation
in vmd/mc146818 much much easier. This diff needs to be combined with
the previous vmd diffs or you won't be able to create a vm with memory
size larger than ~3855MB.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.31 2017/02/20 07:36:20 mlarkin Exp $	*/
d641 1
d653 6
d683 4
@


1.32.4.1
log
@OpenBSD 6.1 errata 002, May 2, 2017

vmm(4) mismanaged floating point contexts.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.32 2017/03/23 08:05:58 mlarkin Exp $	*/
a640 1
	uint64_t	vg_xcr0;		/* 0x98 */
a651 6
	/*
	 * Guest FPU state - this must remain as the first member of the struct
	 * to ensure 64-byte alignment (set up during vcpu_pool init)
	 */
	struct savefpu vc_g_fpu;

a675 4

	uint8_t vc_fpuinited;

	uint64_t vc_h_xcr0;
@


1.31
log
@SVM: asm support for SVM/RVI
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.30 2017/01/24 09:50:54 mlarkin Exp $	*/
d36 1
a36 1
#define VMM_PCI_MMIO_BAR_END	0xF0FFFFFF
@


1.30
log
@SVM: misspelled field name in vmcb struct (renamed to match SVM code I'm
merging)
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.29 2017/01/19 23:18:55 mlarkin Exp $	*/
d716 2
@


1.29
log
@forgot this in previous commit (SVM_MSR* macro definitions)
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.28 2017/01/19 05:53:40 mlarkin Exp $	*/
d519 1
a519 1
			uint64_t	v_extintinfo;		/* 088h */
@


1.28
log
@rename a couple of macros that are causing me a merge headache with the
next SVM diff
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.27 2017/01/19 01:33:45 mlarkin Exp $	*/
d460 4
@


1.27
log
@SVM: vcpu_init_svm - allocate memory for control structures (vmcb,
msr bitmap, ioio bitmap, and host state save area)
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.26 2017/01/13 02:27:37 mlarkin Exp $	*/
d458 2
a459 2
#define MSRIDX(m) ((m) / 8)
#define MSRBIT(m) (1 << (m) % 8)
@


1.26
log
@Starting to merge my old AMD SVM/RVI tree, piece by piece.

SVM/RVI: VMCB structure definitions for amd64/i386
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.25 2017/01/12 09:02:47 mlarkin Exp $	*/
d691 6
@


1.25
log
@Remove vc_hsa_stack_va, it has not been used in a long time and is no
longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.24 2017/01/11 09:15:18 mlarkin Exp $	*/
d480 8
d489 95
@


1.24
log
@SVM intercept codes (exit reason) defines
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.23 2016/10/26 05:15:13 mlarkin Exp $	*/
a560 1
	vaddr_t vc_hsa_stack_va;
@


1.23
log
@
Don't use a bitfield in the msr store index structure. This may not end up
initializing the unused bits, leading to VMABORTs during vmentry. Found the
hard way on i386 vmm, but the problem could occur on amd64 as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.22 2016/10/12 06:56:54 mlarkin Exp $	*/
d111 147
@


1.22
log
@
Allow 4 vio(4) interfaces in each VM. Also fix a bad interrupt assignment that
caused IRQ9 to be shared between the second disk device and the vio(4)s,
which caused poor network performance.

ok reyk, stefan
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.21 2016/10/06 07:37:51 mlarkin Exp $	*/
d342 1
a342 1
	uint64_t	vid_vpid; // : 16;
d354 1
a354 1
	uint64_t	vms_index : 32;
@


1.21
log
@
add a debug function that was useful in finding the previous
broadwell/skylake bug.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.20 2016/10/03 04:53:54 mlarkin Exp $	*/
d33 1
a33 1
#define VMM_MAX_NICS_PER_VM	2
@


1.20
log
@
disable PAT and MTRR in guest VMs
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.19 2016/09/04 08:49:18 mlarkin Exp $	*/
d103 5
@


1.19
log
@
Restrict MSR access to supported ones, log invalid accesses.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.18 2016/09/01 16:04:47 stefan Exp $	*/
d303 1
a303 1
#define VMX_NUM_MSR_STORE 7
@


1.18
log
@Make vcpu_reset_regs use new writeregs code

Makes reset code a little simpler. ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.17 2016/09/01 15:01:45 stefan Exp $	*/
d304 4
@


1.17
log
@Add ioctls to get/set VCPU registers

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.16 2016/09/01 14:45:36 mlarkin Exp $	*/
a153 26
/*
 * struct vcpu_init_state describes the set of vmd-settable registers
 * that the VM's vcpus will be set to during VM boot or reset. Certain
 * registers are always set to 0 (eg, the GP regs) and certain registers
 * have fixed values based on hardware requirements and calculated by
 * vmm (eg, CR0/CR4)
 */
struct vcpu_init_state {
	uint64_t			vis_rflags;
	uint64_t			vis_rip;
	uint64_t			vis_rsp;
	uint64_t			vis_cr0;
	uint64_t			vis_cr3;

	struct vcpu_segment_info	vis_cs;
	struct vcpu_segment_info	vis_ds;
	struct vcpu_segment_info	vis_es;
	struct vcpu_segment_info	vis_fs;
	struct vcpu_segment_info	vis_gs;
	struct vcpu_segment_info	vis_ss;
	struct vcpu_segment_info	vis_gdtr;
	struct vcpu_segment_info	vis_idtr;
	struct vcpu_segment_info	vis_ldtr;
	struct vcpu_segment_info	vis_tr;
};

d265 1
a265 1
	struct vcpu_init_state	vrp_init_state;
@


1.16
log
@
Remove the clock hack, and properly handle interrupts generated from vmd(8)'s
forthcoming emulated interrupt controller.

ok stefan
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.15 2016/06/10 16:37:16 stefan Exp $	*/
d180 45
d301 12
d320 2
@


1.15
log
@Remove readpage and writepage ioctls.

They are not needed anymore now that guest memory is allocated
by and shared with the host.
ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.14 2016/06/07 16:19:06 stefan Exp $	*/
d207 1
a207 1
	int16_t		vrp_injint;		/* Injected interrupt vector */
d214 1
d344 1
d380 1
@


1.14
log
@Allocate RAM for guest VM in vmd(8) and pass it to vmm(4)

vmm(4) then maps the pages allocated by the vmd(8) user process into the
address space of the guest. This gives vmm(4) and vmd(8) a shared view of
the guest RAM. This will allow us to have faster guest<->host data
exchange by ordinary memory loads/stores later, as well as remove the
vm_readpage and vm_writepage ioctls next.

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.13 2016/04/25 15:24:55 mlarkin Exp $	*/
a240 18
struct vm_writepage_params {
	/* Input parameters to VMM_IOC_WRITEPAGE */
	uint32_t		vwp_vm_id; /* VM ID */
	paddr_t			vwp_paddr; /* Phys Addr */
	char			*vwp_data; /* Page Data */
	uint32_t		vwp_len;   /* Length */
};

struct vm_readpage_params {
	/* Input parameters to VMM_IOC_READPAGE */
	uint32_t		vrp_vm_id; /* VM ID */
	paddr_t			vrp_paddr; /* Phys Addr */
	uint32_t		vrp_len;   /* Length */

	/* Output parameters from VMM_IOC_READPAGE */
	char			*vrp_data; /* Page Data */
};

d260 2
a261 4
#define VMM_IOC_WRITEPAGE _IOW('V', 5, struct vm_writepage_params) /* Wr Pg */
#define VMM_IOC_READPAGE _IOW('V', 6, struct vm_readpage_params) /* Rd Pg */
#define VMM_IOC_RESETCPU _IOW('V', 7, struct vm_resetcpu_params) /* Reset */
#define VMM_IOC_INTR _IOW('V', 8, struct vm_intr_params) /* Intr pending */
@


1.13
log
@
add a few new exit types found in newer cpus
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.12 2016/04/06 06:15:06 mlarkin Exp $	*/
d182 1
@


1.12
log
@
define number of exit/entry save/load MSRs as a #define instead of a magic
number.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.11 2016/03/13 13:11:47 stefan Exp $	*/
d100 3
@


1.11
log
@Introduce memory ranges to support VMs with >= 4G RAM

Kernel bits:
- When creating a VM, a list of memory ranges has to be specified,
  similar to the BIOS memory map. This is necessary for VMs with
  RAM sizes approaching 4G because we'll need PCI MMIO space in
  the higher parts of the 32 bit address space.

vmctl and vmd bits:
- Construct appropriate memory ranges to create a VM with a given
  RAM size
- Construct a corresponding BIOS memory map from the memory ranges
  and update the boot params page accordingly.
- Make sure that all variables that represent guest physical addresses
  match the address width of the target CPU instead of using uint32_t.
- Fix some integer promotion glitches that actually restricted VM
  RAM size to 2G.

This changes the VM create ioctl interface, so update your kernel,
vmd, and vmctl.

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.10 2016/03/09 08:06:59 mlarkin Exp $	*/
d284 2
@


1.10
log
@
Add a comment to the vcpu state enum to remind people there is a matching
conversion function in vmm.c

Increase the size of the pending interrupt field from uint8_t to uint16_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.9 2016/02/20 20:49:08 mlarkin Exp $	*/
d26 1
d177 5
d184 9
a192 8
	size_t		vcp_memory_size;
	size_t		vcp_ncpus;
	size_t		vcp_ndisks;
	size_t		vcp_nnics;
	char		vcp_disks[VMM_MAX_DISKS_PER_VM][VMM_MAX_PATH_DISK];
	char		vcp_name[VMM_MAX_NAME_LEN];
	char		vcp_kernel[VMM_MAX_KERNEL_PATH];
	uint8_t		vcp_macs[VMM_MAX_NICS_PER_VM][6];
@


1.9
log
@
Add "interrupt pending on vcpu" ioctl to vmm. Needed for upcoming interrupt
controller work in vmd(8).

ok stefan@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.8 2016/02/16 18:59:30 stefan Exp $	*/
d103 5
d259 1
a259 1
	uint8_t			vip_intr;
d384 1
a384 1
	uint8_t vc_intr;
@


1.8
log
@Allow userland to initialize CR0 when resetting a VCPU instead of
hardcoding it. Be careful to obey VMX's must-be-0 and must-be-1
restrictions for CR0.
This gives us the opportunity later to start VCPUs in real-mode, etc.
(for those CPUs that support unrestricted guest).

Be sure to update your vmd(8) also, the ioctl interface has
changed.

ok mlarkin@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.7 2016/01/04 01:35:56 mlarkin Exp $	*/
d250 7
d265 1
d378 2
@


1.7
log
@
Do proper termination of VMs by doing proper VCPU run state management.

This should fix some of the odd termination errors people have been seeing
(vmctl status showing running VMs after they have exited/crashed, and
invalid instruction panics on vmptrld during certain races)

This diff also implements dropping the biglock when running a VCPU, and
reacquiring the lock as needed based on the type of exit (normal vs.
external interrupt)

diff supplied by Stefan Kempf <sn.kempf at t-online.de>, many thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.6 2015/12/17 09:29:28 mlarkin Exp $	*/
d156 1
@


1.6
log
@
Move vcpu register state init to vmd. Allows vmd bootloader to make the
decision as to how the vcpu should be set up for initial start and
reset. Also removes some hardcoded register constants from vmm(4).

ok jsing@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.5 2015/12/15 01:56:51 mlarkin Exp $	*/
d106 3
a108 2
	VCPU_STATE_REQSTOP,
	VCPU_STATE_UNKNOWN
d361 1
a365 1
	uint8_t vc_state;
@


1.5
log
@
support reset vcpu by triple fault (kernel part, userland fix will come
later).

discussed with deraadt@@ and reyk@@ at length.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.4 2015/12/14 06:59:07 mlarkin Exp $	*/
a114 1

d133 35
d245 1
@


1.4
log
@
track used memory in each VM. This is passed back to vmctl status.

ok reyk@@, beck@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.3 2015/11/26 08:26:48 reyk Exp $	*/
d207 6
d220 1
@


1.3
log
@Automatically start vmm(4) when the first VM is created and after the
last VM is terminated.  This allows to remove the explicit "vmm
enable" / "vmm disable" (VMM_IOC_START / VMM_IOC_STOP) ioctls.  You'll
have to update kernel and userland for this change, as the kernel ABI
changes.

OK mpi@@ mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmmvar.h,v 1.2 2015/11/16 10:08:41 mpi Exp $	*/
d167 1
@


1.2
log
@Some minor tweaks:

- Add $OpenBSD$ tag,
- constify "struct cfattach",
- Use <uvm/uvm_extern.h> rather than <uvm/uvm.h>, it's enough.
- Keep the "struct vm" private.  This allows us to not pull <uvm/uvm_extern.h>
  in <macine/vmmvar.h>
- Prefer DPRINTF() for debug macro as dprintf(3) is a standard function name.
- Add vmm_debug and fix VMM_DEBUG build
- Remove unneeded <sys/rwlock.h> from <machine/vmmvar.h>
- Kill whitespaces

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d207 6
a212 8
#define VMM_IOC_START _IO('V', 1)	/* Start virtualization */
#define VMM_IOC_STOP _IO('V', 2)	/* Stop virtualization */
#define VMM_IOC_CREATE _IOWR('V', 3, struct vm_create_params) /* Create VM */
#define VMM_IOC_RUN _IOWR('V', 4, struct vm_run_params) /* Run VCPU */
#define VMM_IOC_INFO _IOWR('V', 5, struct vm_info_params) /* Get VM Info */
#define VMM_IOC_TERM _IOW('V', 6, struct vm_terminate_params) /* Terminate VM */
#define VMM_IOC_WRITEPAGE _IOW('V', 7, struct vm_writepage_params) /* Wr Pg */
#define VMM_IOC_READPAGE _IOW('V', 8, struct vm_readpage_params) /* Rd Pg */
@


1.1
log
@
vmm(4) kernel code

circulated on hackers@@, no objections. Disabled by default.
@
text
@d1 1
a23 2
#include <sys/rwlock.h>

a217 2
#include <uvm/uvm_extern.h>

a221 6
#ifdef VMM_DEBUG
#define dprintf(x...)	do { if (vmm_debug) printf(x); } while(0)
#else
#define dprintf(x...)
#endif /* VMM_DEBUG */

d297 5
a348 17

/*
 * Virtual Machine
 */
struct vm {
	vm_map_t		 vm_map;
	uint32_t		 vm_id;
	pid_t			 vm_creator_pid;
	uint32_t		 vm_memory_size;
	char			 vm_name[VMM_MAX_NAME_LEN];

	struct vcpu_head	 vm_vcpu_list;
	uint32_t		 vm_vcpu_ct;
	struct rwlock		 vm_vcpu_lock;

	SLIST_ENTRY(vm)		 vm_link;
};
@

