head	1.59;
access;
symbols
	OPENBSD_6_1:1.55.0.4
	OPENBSD_6_1_BASE:1.55
	OPENBSD_6_0:1.45.0.2
	OPENBSD_6_0_BASE:1.45
	OPENBSD_5_9:1.40.0.2
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.37.0.4
	OPENBSD_5_8_BASE:1.37
	OPENBSD_5_7:1.32.0.2
	OPENBSD_5_7_BASE:1.32
	OPENBSD_5_6:1.28.0.4
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.27.0.4
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.26.0.2
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.24.0.2
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.21.0.2
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.2
	OPENBSD_5_0:1.19.0.6
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.4
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.2
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.14.0.4
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.13.0.2
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.12.0.2
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.11.0.4
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.2
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.7.0.2
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.4.0.4
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.3.0.2
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.2.0.8
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.6
	OPENBSD_3_6_BASE:1.2
	SMP_SYNC_A:1.2
	SMP_SYNC_B:1.2
	OPENBSD_3_5:1.2.0.4
	OPENBSD_3_5_BASE:1.2
	SMP:1.2.0.2;
locks; strict;
comment	@ * @;


1.59
date	2017.08.09.20.22.08;	author mlarkin;	state Exp;
branches;
next	1.58;
commitid	G8UXnw5zHyhqsbDo;

1.58
date	2017.06.20.06.25.01;	author mlarkin;	state Exp;
branches;
next	1.57;
commitid	zPUoVKthVczhuBiv;

1.57
date	2017.06.20.05.34.41;	author mlarkin;	state Exp;
branches;
next	1.56;
commitid	s2WnhMEQE21216EQ;

1.56
date	2017.05.30.17.49.47;	author mlarkin;	state Exp;
branches;
next	1.55;
commitid	UUYd9gBIsonhUkI2;

1.55
date	2017.03.28.21.36.27;	author mlarkin;	state Exp;
branches;
next	1.54;
commitid	3Fbu1w0kuLUYtaxv;

1.54
date	2017.01.24.09.02.33;	author mlarkin;	state Exp;
branches;
next	1.53;
commitid	mCIbTMib2EZs6Riz;

1.53
date	2017.01.19.23.17.19;	author mlarkin;	state Exp;
branches;
next	1.52;
commitid	juZ0BVuEZL2XqaYZ;

1.52
date	2017.01.13.17.15.27;	author mikeb;	state Exp;
branches;
next	1.51;
commitid	xf3Mp5sczmZXop5L;

1.51
date	2016.10.06.07.37.51;	author mlarkin;	state Exp;
branches;
next	1.50;
commitid	ZI7DVHMVrS3IZX7i;

1.50
date	2016.09.30.07.33.06;	author mlarkin;	state Exp;
branches;
next	1.49;
commitid	SE7Bj6m3HBGqhmFT;

1.49
date	2016.09.27.08.04.49;	author mlarkin;	state Exp;
branches;
next	1.48;
commitid	ku4p47mroNn82mrs;

1.48
date	2016.09.10.17.15.44;	author mlarkin;	state Exp;
branches;
next	1.47;
commitid	5UB7hcr8j6jKKV3d;

1.47
date	2016.09.03.13.35.03;	author mlarkin;	state Exp;
branches;
next	1.46;
commitid	e9H4uCx99GDpbjQ6;

1.46
date	2016.09.03.12.12.43;	author mlarkin;	state Exp;
branches;
next	1.45;
commitid	VxEixNTRhSw9wrcd;

1.45
date	2016.07.16.06.20.24;	author mlarkin;	state Exp;
branches;
next	1.44;
commitid	ycarQGKhkRhquKfd;

1.44
date	2016.06.22.07.22.00;	author mlarkin;	state Exp;
branches;
next	1.43;
commitid	M1lpFrN5wVgMVhed;

1.43
date	2016.04.26.15.57.09;	author mlarkin;	state Exp;
branches;
next	1.42;
commitid	mdTcZEnOVnQ5oQmU;

1.42
date	2016.04.26.15.27.32;	author mlarkin;	state Exp;
branches;
next	1.41;
commitid	F6kozG3kiHukwD4S;

1.41
date	2016.04.25.17.50.21;	author mlarkin;	state Exp;
branches;
next	1.40;
commitid	3emxXAo0TW6xsTks;

1.40
date	2016.01.10.18.18.25;	author stefan;	state Exp;
branches;
next	1.39;
commitid	LhXwmph3IQdIYLr4;

1.39
date	2015.12.07.06.34.14;	author jsg;	state Exp;
branches;
next	1.38;
commitid	SlCrK8YSV6f5HTmS;

1.38
date	2015.11.13.07.52.20;	author mlarkin;	state Exp;
branches;
next	1.37;
commitid	KdsjYlqLpqhwOUHf;

1.37
date	2015.06.07.08.11.50;	author guenther;	state Exp;
branches;
next	1.36;
commitid	g6ybrd6yNriRrJzC;

1.36
date	2015.05.28.20.10.58;	author guenther;	state Exp;
branches;
next	1.35;
commitid	nRKEXgw8UCVd37E0;

1.35
date	2015.04.19.19.45.21;	author sf;	state Exp;
branches;
next	1.34;
commitid	QHmlY8tYf1BGbIw1;

1.34
date	2015.03.25.20.59.30;	author kettenis;	state Exp;
branches;
next	1.33;
commitid	44AWXbatCiX6PDyN;

1.33
date	2015.03.21.20.42.38;	author kettenis;	state Exp;
branches;
next	1.32;
commitid	tilqEUDj6duaLWpC;

1.32
date	2015.01.19.16.01.43;	author jsg;	state Exp;
branches;
next	1.31;
commitid	XxkrcoKyIcX4NWk4;

1.31
date	2014.12.22.22.33.51;	author mlarkin;	state Exp;
branches;
next	1.30;
commitid	WL45Lv2srrOadrEZ;

1.30
date	2014.12.16.21.02.58;	author sf;	state Exp;
branches;
next	1.29;
commitid	nEi2aBsgsNXJbY4F;

1.29
date	2014.11.30.18.29.11;	author mlarkin;	state Exp;
branches;
next	1.28;
commitid	VxipkLhzoC0bnd0Q;

1.28
date	2014.07.03.21.15.28;	author matthew;	state Exp;
branches;
next	1.27;
commitid	P69HFjn5e4zdBZir;

1.27
date	2013.08.24.04.26.16;	author mlarkin;	state Exp;
branches;
next	1.26;

1.26
date	2013.06.02.16.34.15;	author guenther;	state Exp;
branches;
next	1.25;

1.25
date	2013.05.06.04.32.12;	author dlg;	state Exp;
branches;
next	1.24;

1.24
date	2012.11.10.09.45.05;	author mglocker;	state Exp;
branches;
next	1.23;

1.23
date	2012.10.09.09.16.09;	author jsg;	state Exp;
branches;
next	1.22;

1.22
date	2012.08.24.02.49.23;	author guenther;	state Exp;
branches;
next	1.21;

1.21
date	2012.03.27.05.59.46;	author jsg;	state Exp;
branches;
next	1.20;

1.20
date	2011.12.26.23.07.04;	author haesbaert;	state Exp;
branches;
next	1.19;

1.19
date	2010.04.29.17.00.48;	author oga;	state Exp;
branches;
next	1.18;

1.18
date	2010.03.21.23.00.57;	author jsg;	state Exp;
branches;
next	1.17;

1.17
date	2009.10.07.02.15.48;	author kevlo;	state Exp;
branches;
next	1.16;

1.16
date	2009.09.20.21.58.31;	author jsg;	state Exp;
branches;
next	1.15;

1.15
date	2009.09.20.15.37.23;	author kevlo;	state Exp;
branches;
next	1.14;

1.14
date	2009.05.31.03.20.10;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2008.08.13.15.44.44;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2008.06.13.00.00.45;	author jsg;	state Exp;
branches;
next	1.11;

1.11
date	2007.06.01.22.28.21;	author tedu;	state Exp;
branches;
next	1.10;

1.10
date	2007.05.29.06.40.15;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2007.05.29.06.31.44;	author tedu;	state Exp;
branches;
next	1.8;

1.8
date	2007.04.27.01.57.16;	author dlg;	state Exp;
branches;
next	1.7;

1.7
date	2007.02.17.17.35.43;	author tom;	state Exp;
branches;
next	1.6;

1.6
date	2007.02.13.00.20.59;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2006.03.07.05.21.40;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2005.12.13.00.18.19;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2005.08.20.00.33.59;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.09.22.15.52;	author mickey;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2004.01.28.01.39.39;	author mickey;	state Exp;
branches;
next	;

1.2.2.1
date	2004.02.22.22.08.18;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2004.06.05.23.09.25;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.59
log
@reorder some MSRs in the MSR list that were out of order. No functional
change; I'll be adding a few new ones and noticed these were misplaced.
@
text
@/*	$OpenBSD: specialreg.h,v 1.58 2017/06/20 06:25:01 mlarkin Exp $	*/
/*	$NetBSD: specialreg.h,v 1.1 2003/04/26 18:39:48 fvdl Exp $	*/
/*	$NetBSD: x86/specialreg.h,v 1.2 2003/04/25 21:54:30 fvdl Exp $	*/

/*-
 * Copyright (c) 1991 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)specialreg.h	7.1 (Berkeley) 5/9/91
 */

/*
 * Bits in 386 special registers:
 */
#define	CR0_PE	0x00000001	/* Protected mode Enable */
#define	CR0_MP	0x00000002	/* "Math" Present (NPX or NPX emulator) */
#define	CR0_EM	0x00000004	/* EMulate non-NPX coproc. (trap ESC only) */
#define	CR0_TS	0x00000008	/* Task Switched (if MP, trap ESC and WAIT) */
#define	CR0_ET	0x00000010	/* Extension Type (387 (if set) vs 287) */
#define	CR0_PG	0x80000000	/* PaGing enable */

/*
 * Bits in 486 special registers:
 */
#define CR0_NE	0x00000020	/* Numeric Error enable (EX16 vs IRQ13) */
#define CR0_WP	0x00010000	/* Write Protect (honor PG_RW in all modes) */
#define CR0_AM	0x00040000	/* Alignment Mask (set to enable AC flag) */
#define	CR0_NW	0x20000000	/* Not Write-through */
#define	CR0_CD	0x40000000	/* Cache Disable */

/*
 * Cyrix 486 DLC special registers, accessible as IO ports.
 */
#define CCR0	0xc0		/* configuration control register 0 */
#define CCR0_NC0	0x01	/* first 64K of each 1M memory region is non-cacheable */
#define CCR0_NC1	0x02	/* 640K-1M region is non-cacheable */
#define CCR0_A20M	0x04	/* enables A20M# input pin */
#define CCR0_KEN	0x08	/* enables KEN# input pin */
#define CCR0_FLUSH	0x10	/* enables FLUSH# input pin */
#define CCR0_BARB	0x20	/* flushes internal cache when entering hold state */
#define CCR0_CO		0x40	/* cache org: 1=direct mapped, 0=2x set assoc */
#define CCR0_SUSPEND	0x80	/* enables SUSP# and SUSPA# pins */

#define CCR1	0xc1		/* configuration control register 1 */
#define CCR1_RPL	0x01	/* enables RPLSET and RPLVAL# pins */
/* the remaining 7 bits of this register are reserved */

/*
 * bits in CR3
 */
#define CR3_PWT		(1ULL << 3)
#define CR3_PCD		(1ULL << 4)

/*
 * bits in the pentiums %cr4 register:
 */

#define	CR4_VME	0x00000001	/* virtual 8086 mode extension enable */
#define	CR4_PVI 0x00000002	/* protected mode virtual interrupt enable */
#define	CR4_TSD 0x00000004	/* restrict RDTSC instruction to cpl 0 only */
#define	CR4_DE	0x00000008	/* debugging extension */
#define	CR4_PSE	0x00000010	/* large (4MB) page size enable */
#define	CR4_PAE 0x00000020	/* physical address extension enable */
#define	CR4_MCE	0x00000040	/* machine check enable */
#define	CR4_PGE	0x00000080	/* page global enable */
#define	CR4_PCE	0x00000100	/* enable RDPMC instruction for all cpls */
#define	CR4_OSFXSR	0x00000200	/* enable fxsave/fxrestor and SSE */
#define	CR4_OSXMMEXCPT	0x00000400	/* enable unmasked SSE exceptions */
#define	CR4_UMIP	0x00000800	/* user mode instruction prevention */
#define	CR4_VMXE	0x00002000	/* enable virtual machine operation */
#define	CR4_SMXE	0x00004000	/* enable safe mode operation */
#define	CR4_FSGSBASE	0x00010000	/* enable {RD,WR}{FS,GS}BASE ops */
#define	CR4_PCIDE	0x00020000	/* enable process-context IDs */
#define	CR4_OSXSAVE	0x00040000	/* enable XSAVE and extended states */
#define	CR4_SMEP	0x00100000	/* supervisor mode exec protection */
#define	CR4_SMAP	0x00200000	/* supervisor mode access prevention */
#define CR4_PKE		0x00400000	/* protection key enable */

/*
 * Extended Control Register XCR0
 */
#define	XCR0_X87	0x00000001	/* x87 FPU/MMX state */
#define	XCR0_SSE	0x00000002	/* SSE state */
#define	XCR0_AVX	0x00000004	/* AVX state */

/*
 * CPUID "features" bits (CPUID function 0x1):
 * EDX bits, then ECX bits
 */

#define	CPUID_FPU	0x00000001	/* processor has an FPU? */
#define	CPUID_VME	0x00000002	/* has virtual mode (%cr4's VME/PVI) */
#define	CPUID_DE	0x00000004	/* has debugging extension */
#define	CPUID_PSE	0x00000008	/* has 4MB page size extension */
#define	CPUID_TSC	0x00000010	/* has time stamp counter */
#define	CPUID_MSR	0x00000020	/* has model specific registers */
#define	CPUID_PAE	0x00000040	/* has phys address extension */
#define	CPUID_MCE	0x00000080	/* has machine check exception */
#define	CPUID_CX8	0x00000100	/* has CMPXCHG8B instruction */
#define	CPUID_APIC	0x00000200	/* has enabled APIC */
#define	CPUID_SYS1	0x00000400	/* has SYSCALL/SYSRET inst. (Cyrix) */
#define	CPUID_SEP	0x00000800	/* has SYSCALL/SYSRET inst. (AMD/Intel) */
#define	CPUID_MTRR	0x00001000	/* has memory type range register */
#define	CPUID_PGE	0x00002000	/* has page global extension */
#define	CPUID_MCA	0x00004000	/* has machine check architecture */
#define	CPUID_CMOV	0x00008000	/* has CMOVcc instruction */
#define	CPUID_PAT	0x00010000	/* has page attribute table */
#define	CPUID_PSE36	0x00020000	/* has 36bit page size extension */
#define	CPUID_PSN	0x00040000	/* has processor serial number */
#define	CPUID_CFLUSH	0x00080000	/* CFLUSH insn supported */
#define	CPUID_B20	0x00100000	/* reserved */
#define	CPUID_DS	0x00200000	/* Debug Store */
#define	CPUID_ACPI	0x00400000	/* ACPI performance modulation regs */
#define	CPUID_MMX	0x00800000	/* has MMX instructions */
#define	CPUID_FXSR	0x01000000	/* has FXRSTOR instruction */
#define	CPUID_SSE	0x02000000	/* has streaming SIMD extensions */
#define	CPUID_SSE2	0x04000000	/* has streaming SIMD extensions #2 */
#define	CPUID_SS	0x08000000	/* self-snoop */
#define	CPUID_HTT	0x10000000	/* Hyper-Threading Technology */
#define	CPUID_TM	0x20000000	/* thermal monitor (TCC) */
#define	CPUID_B30	0x40000000	/* reserved */
#define	CPUID_PBE	0x80000000	/* Pending Break Enabled restarts clock */

#define	CPUIDECX_SSE3	0x00000001	/* streaming SIMD extensions #3 */
#define	CPUIDECX_PCLMUL	0x00000002	/* Carryless Multiplication */
#define	CPUIDECX_DTES64	0x00000004	/* 64bit debug store */
#define	CPUIDECX_MWAIT	0x00000008	/* Monitor/Mwait */
#define	CPUIDECX_DSCPL	0x00000010	/* CPL Qualified Debug Store */
#define	CPUIDECX_VMX	0x00000020	/* Virtual Machine Extensions */
#define	CPUIDECX_SMX	0x00000040	/* Safer Mode Extensions */
#define	CPUIDECX_EST	0x00000080	/* enhanced SpeedStep */
#define	CPUIDECX_TM2	0x00000100	/* thermal monitor 2 */
#define	CPUIDECX_SSSE3	0x00000200	/* Supplemental Streaming SIMD Ext. 3 */
#define	CPUIDECX_CNXTID	0x00000400	/* Context ID */
#define CPUIDECX_SDBG	0x00000800	/* Silicon debug capability */
#define	CPUIDECX_FMA3	0x00001000	/* Fused Multiply Add */
#define	CPUIDECX_CX16	0x00002000	/* has CMPXCHG16B instruction */
#define	CPUIDECX_XTPR	0x00004000	/* xTPR Update Control */
#define	CPUIDECX_PDCM	0x00008000	/* Perfmon and Debug Capability */
#define	CPUIDECX_PCID	0x00020000	/* Process-context ID Capability */
#define	CPUIDECX_DCA	0x00040000	/* Direct Cache Access */
#define	CPUIDECX_SSE41	0x00080000	/* Streaming SIMD Extensions 4.1 */
#define	CPUIDECX_SSE42	0x00100000	/* Streaming SIMD Extensions 4.2 */
#define	CPUIDECX_X2APIC	0x00200000	/* Extended xAPIC Support */
#define	CPUIDECX_MOVBE	0x00400000	/* MOVBE Instruction */
#define	CPUIDECX_POPCNT	0x00800000	/* POPCNT Instruction */
#define	CPUIDECX_DEADLINE	0x01000000	/* APIC one-shot via deadline */
#define	CPUIDECX_AES	0x02000000	/* AES Instruction */
#define	CPUIDECX_XSAVE	0x04000000	/* XSAVE/XSTOR States */
#define	CPUIDECX_OSXSAVE	0x08000000	/* OSXSAVE */
#define	CPUIDECX_AVX	0x10000000	/* Advanced Vector Extensions */
#define	CPUIDECX_F16C	0x20000000	/* 16bit fp conversion  */
#define	CPUIDECX_RDRAND	0x40000000	/* RDRAND instruction  */
#define	CPUIDECX_HV	0x80000000	/* Running on hypervisor */

/*
 * "Structured Extended Feature Flags Parameters" (CPUID function 0x7, leaf 0)
 * EBX bits
 */
#define	SEFF0EBX_FSGSBASE	0x00000001 /* {RD,WR}[FG]SBASE instructions */
#define	SEFF0EBX_SGX		0x00000004 /* Software Guard Extensions */
#define	SEFF0EBX_BMI1		0x00000008 /* advanced bit manipulation */
#define	SEFF0EBX_HLE		0x00000010 /* Hardware Lock Elision */
#define	SEFF0EBX_AVX2		0x00000020 /* Advanced Vector Extensions 2 */
#define	SEFF0EBX_SMEP		0x00000080 /* Supervisor mode exec protection */
#define	SEFF0EBX_BMI2		0x00000100 /* advanced bit manipulation */
#define	SEFF0EBX_ERMS		0x00000200 /* Enhanced REP MOVSB/STOSB */
#define	SEFF0EBX_INVPCID	0x00000400 /* INVPCID instruction */
#define	SEFF0EBX_RTM		0x00000800 /* Restricted Transactional Memory */
#define	SEFF0EBX_PQM		0x00001000 /* Quality of Service Monitoring */
#define	SEFF0EBX_MPX		0x00004000 /* Memory Protection Extensions */
#define	SEFF0EBX_AVX512F	0x00010000 /* AVX-512 foundation inst */
#define	SEFF0EBX_AVX512DQ	0x00020000 /* AVX-512 double/quadword */
#define	SEFF0EBX_RDSEED		0x00040000 /* RDSEED instruction */
#define	SEFF0EBX_ADX		0x00080000 /* ADCX/ADOX instructions */
#define	SEFF0EBX_SMAP		0x00100000 /* Supervisor mode access prevent */
#define	SEFF0EBX_AVX512IFMA	0x00200000 /* AVX-512 integer mult-add */
#define	SEFF0EBX_PCOMMIT	0x00400000 /* Persistent commit inst */
#define	SEFF0EBX_CLFLUSHOPT	0x00800000 /* cache line flush */
#define	SEFF0EBX_CLWB		0x01000000 /* cache line write back */
#define	SEFF0EBX_PT		0x02000000 /* Processor Trace */
#define	SEFF0EBX_AVX512PF	0x04000000 /* AVX-512 prefetch */
#define	SEFF0EBX_AVX512ER	0x08000000 /* AVX-512 exp/reciprocal */
#define	SEFF0EBX_AVX512CD	0x10000000 /* AVX-512 conflict detection */
#define	SEFF0EBX_SHA		0x20000000 /* SHA Extensions */
#define	SEFF0EBX_AVX512BW	0x40000000 /* AVX-512 byte/word inst */
#define	SEFF0EBX_AVX512VL	0x80000000 /* AVX-512 vector len inst */
/* SEFF ECX bits */
#define SEFF0ECX_PREFETCHWT1	0x00000001 /* PREFETCHWT1 instruction */
#define SEFF0ECX_AVX512VBMI	0x00000002 /* AVX-512 vector bit inst */
#define SEFF0ECX_UMIP		0x00000004 /* UMIP support */
#define SEFF0ECX_PKU		0x00000008 /* Page prot keys for user mode */

/*
 * Thermal and Power Management (CPUID function 0x6) EAX bits
 */
#define	TPM_SENSOR	0x00000001	 /* Digital temp sensor */
#define	TPM_ARAT	0x00000004	 /* APIC Timer Always Running */

 /*
  * "Architectural Performance Monitoring" bits (CPUID function 0x0a):
  * EAX bits, EBX bits, EDX bits.
  */

#define CPUIDEAX_VERID			0x000000ff /* Version ID */
#define CPUIDEAX_NUM_GC(cpuid)		(((cpuid) >>  8) & 0x000000ff)
#define CPUIDEAX_BIT_GC(cpuid)		(((cpuid) >> 16) & 0x000000ff)
#define CPUIDEAX_LEN_EBX(cpuid)		(((cpuid) >> 24) & 0x000000ff)

#define CPUIDEBX_EVT_CORE		(1 << 0) /* Core cycle */
#define CPUIDEBX_EVT_INST		(1 << 1) /* Instruction retired */
#define CPUIDEBX_EVT_REFR		(1 << 2) /* Reference cycles */
#define CPUIDEBX_EVT_CACHE_REF		(1 << 3) /* Last-level cache ref. */
#define CPUIDEBX_EVT_CACHE_MIS		(1 << 4) /* Last-level cache miss. */
#define CPUIDEBX_EVT_BRANCH_INST	(1 << 5) /* Branch instruction ret. */
#define CPUIDEBX_EVT_BRANCH_MISP	(1 << 6) /* Branch mispredict ret. */

#define CPUIDEDX_NUM_FC(cpuid)		(((cpuid) >> 0) & 0x0000001f)
#define CPUIDEDX_BIT_FC(cpuid)		(((cpuid) >> 5) & 0x000000ff)

/*
 * CPUID "extended features" bits (CPUID function 0x80000001):
 * EDX bits, then ECX bits
 */

#define	CPUID_MPC	0x00080000	/* Multiprocessing Capable */
#define	CPUID_NXE	0x00100000	/* No-Execute Extension */
#define	CPUID_MMXX	0x00400000	/* AMD MMX Extensions */
#define	CPUID_FFXSR	0x02000000	/* fast FP/MMX save/restore */
#define	CPUID_PAGE1GB	0x04000000	/* 1-GByte pages */
#define CPUID_RDTSCP	0x08000000	/* RDTSCP / IA32_TSC_AUX available */
#define	CPUID_LONG	0x20000000	/* long mode */
#define	CPUID_3DNOW2	0x40000000	/* 3DNow! Instruction Extension */
#define	CPUID_3DNOW	0x80000000	/* 3DNow! Instructions */

#define	CPUIDECX_LAHF		0x00000001 /* LAHF and SAHF instructions */
#define	CPUIDECX_CMPLEG		0x00000002 /* Core MP legacy mode */
#define	CPUIDECX_SVM		0x00000004 /* Secure Virtual Machine */
#define	CPUIDECX_EAPICSP	0x00000008 /* Extended APIC space */
#define	CPUIDECX_AMCR8		0x00000010 /* LOCK MOV CR0 means MOV CR8 */
#define	CPUIDECX_ABM		0x00000020 /* LZCNT instruction */
#define	CPUIDECX_SSE4A		0x00000040 /* SSE4-A instruction set */
#define	CPUIDECX_MASSE		0x00000080 /* Misaligned SSE mode */
#define	CPUIDECX_3DNOWP		0x00000100 /* 3DNowPrefetch */
#define	CPUIDECX_OSVW		0x00000200 /* OS visible workaround */
#define	CPUIDECX_IBS		0x00000400 /* Instruction based sampling */
#define	CPUIDECX_XOP		0x00000800 /* Extended operating support */
#define	CPUIDECX_SKINIT		0x00001000 /* SKINIT and STGI are supported */
#define	CPUIDECX_WDT		0x00002000 /* Watchdog timer */
/* Reserved			0x00004000 */
#define	CPUIDECX_LWP		0x00008000 /* Lightweight profiling support */
#define	CPUIDECX_FMA4		0x00010000 /* 4-operand FMA instructions */
/* Reserved			0x00020000 */
/* Reserved			0x00040000 */
#define	CPUIDECX_NODEID		0x00080000 /* Support for MSRC001C */
/* Reserved			0x00100000 */
#define	CPUIDECX_TBM		0x00200000 /* Trailing bit manipulation instruction */
#define	CPUIDECX_TOPEXT		0x00400000 /* Topology extensions support */

/*
 * "Advanced Power Management Information" bits (CPUID function 0x80000007):
 * EDX bits.
 */

#define CPUIDEDX_ITSC		(1 << 8)	/* Invariant TSC */

#define	CPUID2FAMILY(cpuid)	(((cpuid) >> 8) & 15)
#define	CPUID2MODEL(cpuid)	(((cpuid) >> 4) & 15)
#define	CPUID2STEPPING(cpuid)	((cpuid) & 15)

#define	CPUID(code, eax, ebx, ecx, edx)                         \
	__asm volatile("cpuid"                                  \
	    : "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx)    \
	    : "a" (code));
#define	CPUID_LEAF(code, leaf, eax, ebx, ecx, edx)		\
	__asm volatile("cpuid"                                  \
	    : "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx)    \
	    : "a" (code), "c" (leaf));


/*
 * Model-specific registers for the i386 family
 */
#define MSR_P5_MC_ADDR		0x000	/* P5 only */
#define MSR_P5_MC_TYPE		0x001	/* P5 only */
#define MSR_TSC			0x010
#define	MSR_CESR		0x011	/* P5 only (trap on P6) */
#define	MSR_CTR0		0x012	/* P5 only (trap on P6) */
#define	MSR_CTR1		0x013	/* P5 only (trap on P6) */
#define MSR_APICBASE		0x01b
#define APICBASE_BSP		0x100
#define APICBASE_ENABLE_X2APIC	0x400
#define APICBASE_GLOBAL_ENABLE	0x800
#define MSR_EBL_CR_POWERON	0x02a
#define MSR_EBC_FREQUENCY_ID    0x02c   /* Pentium 4 only */
#define	MSR_TEST_CTL		0x033
#define MSR_IA32_FEATURE_CONTROL 0x03a
#define MSR_BIOS_UPDT_TRIG	0x079
#define	MSR_BBL_CR_D0		0x088	/* PII+ only */
#define	MSR_BBL_CR_D1		0x089	/* PII+ only */
#define	MSR_BBL_CR_D2		0x08a	/* PII+ only */
#define MSR_BIOS_SIGN		0x08b
#define MSR_PERFCTR0		0x0c1
#define MSR_PERFCTR1		0x0c2
#define MSR_FSB_FREQ		0x0cd	/* Core Duo/Solo only */   
#define MSR_MTRRcap		0x0fe
#define MTRRcap_FIXED		0x100	/* bit 8 - fixed MTRRs supported */
#define MTRRcap_WC		0x400	/* bit 10 - WC type supported */
#define MTRRcap_SMRR		0x800	/* bit 11 - SMM range reg supported */
#define	MSR_BBL_CR_ADDR		0x116	/* PII+ only */
#define	MSR_BBL_CR_DECC		0x118	/* PII+ only */
#define	MSR_BBL_CR_CTL		0x119	/* PII+ only */
#define	MSR_BBL_CR_TRIG		0x11a	/* PII+ only */
#define	MSR_BBL_CR_BUSY		0x11b	/* PII+ only */
#define	MSR_BBL_CR_CTR3		0x11e	/* PII+ only */
#define	MSR_SYSENTER_CS		0x174 	/* PII+ only */
#define	MSR_SYSENTER_ESP	0x175 	/* PII+ only */
#define	MSR_SYSENTER_EIP	0x176   /* PII+ only */
#define MSR_MCG_CAP		0x179
#define MSR_MCG_STATUS		0x17a
#define MSR_MCG_CTL		0x17b
#define MSR_EVNTSEL0		0x186
#define MSR_EVNTSEL1		0x187
#define MSR_PERF_STATUS		0x198	/* Pentium M */
#define MSR_PERF_CTL		0x199	/* Pentium M */
#define PERF_CTL_TURBO		0x100000000ULL /* bit 32 - turbo mode */
#define MSR_THERM_CONTROL	0x19a
#define MSR_THERM_INTERRUPT	0x19b
#define MSR_THERM_STATUS	0x19c
#define MSR_THERM_STATUS_VALID_BIT	0x80000000
#define	MSR_THERM_STATUS_TEMP(msr)	((msr >> 16) & 0x7f)
#define MSR_THERM2_CTL		0x19d	/* Pentium M */
/*
 * for Core i Series and newer Xeons, see
 * http://www.intel.com/content/dam/www/public/us/en/
 * documents/white-papers/cpu-monitoring-dts-peci-paper.pdf
 */
#define MSR_TEMPERATURE_TARGET	0x1a2	/* Core i Series, Newer Xeons */
#define MSR_TEMPERATURE_TARGET_TJMAX(msr) (((msr) >> 16) & 0xff)
/*
 * not documented anywhere, see intelcore_update_sensor()
 * only available Core Duo and Core Solo Processors
 */
#define MSR_TEMPERATURE_TARGET_UNDOCUMENTED	0x0ee
#define MSR_TEMPERATURE_TARGET_LOW_BIT_UNDOCUMENTED	0x40000000
#define MSR_DEBUGCTLMSR		0x1d9
#define MSR_LASTBRANCHFROMIP	0x1db
#define MSR_LASTBRANCHTOIP	0x1dc
#define MSR_LASTINTFROMIP	0x1dd
#define MSR_LASTINTTOIP		0x1de
#define MSR_ROB_CR_BKUPTMPDR6	0x1e0
#define	MSR_MTRRvarBase		0x200
#define	MSR_MTRRfix64K_00000	0x250
#define	MSR_MTRRfix16K_80000	0x258
#define	MSR_MTRRfix4K_C0000	0x268
#define MSR_CR_PAT		0x277
#define MSR_MTRRdefType		0x2ff
#define MTRRdefType_FIXED_ENABLE	0x400 /* bit 10 - fixed MTRR enabled */
#define MTRRdefType_ENABLE	0x800 /* bit 11 - MTRRs enabled */
#define MSR_PERF_FIXED_CTR1	0x30a	/* CPU_CLK_Unhalted.Core */
#define MSR_PERF_FIXED_CTR2	0x30b	/* CPU_CLK.Unhalted.Ref */
#define MSR_PERF_FIXED_CTR_CTRL 0x38d
#define MSR_PERF_FIXED_CTR_FC_DIS	0x0 /* disable counter */
#define MSR_PERF_FIXED_CTR_FC_1	0x1 /* count ring 1 */
#define MSR_PERF_FIXED_CTR_FC_123	0x2 /* count rings 1,2,3 */
#define MSR_PERF_FIXED_CTR_FC_ANY	0x3 /* count everything */
#define MSR_PERF_FIXED_CTR_FC_MASK	0x3
#define MSR_PERF_FIXED_CTR_FC(_i, _v)	((_v) << (4 * (_i)))
#define MSR_PERF_FIXED_CTR_ANYTHR(_i)	(0x4 << (4 * (_i)))
#define MSR_PERF_FIXED_CTR_INT(_i)	(0x8 << (4 * (_i)))
#define MSR_PERF_GLOBAL_CTRL	0x38f
#define MSR_PERF_GLOBAL_CTR1_EN	(1ULL << 33)
#define MSR_PERF_GLOBAL_CTR2_EN	(1ULL << 34)
#define MSR_MC0_CTL		0x400
#define MSR_MC0_STATUS		0x401
#define MSR_MC0_ADDR		0x402
#define MSR_MC0_MISC		0x403
#define MSR_MC1_CTL		0x404
#define MSR_MC1_STATUS		0x405
#define MSR_MC1_ADDR		0x406
#define MSR_MC1_MISC		0x407
#define MSR_MC2_CTL		0x408
#define MSR_MC2_STATUS		0x409
#define MSR_MC2_ADDR		0x40a
#define MSR_MC2_MISC		0x40b
#define MSR_MC4_CTL		0x40c
#define MSR_MC4_STATUS		0x40d
#define MSR_MC4_ADDR		0x40e
#define MSR_MC4_MISC		0x40f
#define MSR_MC3_CTL		0x410
#define MSR_MC3_STATUS		0x411
#define MSR_MC3_ADDR		0x412
#define MSR_MC3_MISC		0x413

/* VIA MSR */
#define MSR_CENT_TMTEMPERATURE	0x1423	/* Thermal monitor temperature */

/*
 * AMD K6/K7 MSRs.
 */
#define	MSR_K6_UWCCR		0xc0000085
#define	MSR_K7_EVNTSEL0		0xc0010000
#define	MSR_K7_EVNTSEL1		0xc0010001
#define	MSR_K7_EVNTSEL2		0xc0010002
#define	MSR_K7_EVNTSEL3		0xc0010003
#define	MSR_K7_PERFCTR0		0xc0010004
#define	MSR_K7_PERFCTR1		0xc0010005
#define	MSR_K7_PERFCTR2		0xc0010006
#define	MSR_K7_PERFCTR3		0xc0010007

/*
 * AMD K8 (Opteron) MSRs.
 */
#define	MSR_SYSCFG	0xc0000010

#define MSR_EFER	0xc0000080	/* Extended feature enable */
#define EFER_SCE	0x00000001	/* SYSCALL extension */
#define EFER_LME	0x00000100	/* Long Mode Enabled */
#define	EFER_LMA	0x00000400	/* Long Mode Active */
#define EFER_NXE	0x00000800	/* No-Execute Enabled */
#define EFER_SVME	0x00001000	/* SVM Enabled */

#define MSR_STAR	0xc0000081	/* 32 bit syscall gate addr */
#define MSR_LSTAR	0xc0000082	/* 64 bit syscall gate addr */
#define MSR_CSTAR	0xc0000083	/* compat syscall gate addr */
#define MSR_SFMASK	0xc0000084	/* flags to clear on syscall */

#define MSR_FSBASE	0xc0000100	/* 64bit offset for fs: */
#define MSR_GSBASE	0xc0000101	/* 64bit offset for gs: */
#define MSR_KERNELGSBASE 0xc0000102	/* storage for swapgs ins */
#define MSR_INT_PEN_MSG	0xc0010055	/* Interrupt pending message */

#define MSR_DE_CFG	0xc0011029	/* Decode Configuration */
#define	DE_CFG_721	0x00000001	/* errata 721 */

#define IPM_C1E_CMP_HLT	0x10000000
#define IPM_SMI_CMP_HLT	0x08000000

/*
 * These require a 'passcode' for access.  See cpufunc.h.
 */
#define	MSR_HWCR	0xc0010015
#define		HWCR_FFDIS		0x00000040

#define	MSR_NB_CFG	0xc001001f
#define		NB_CFG_DISIOREQLOCK	0x0000000000000004ULL
#define		NB_CFG_DISDATMSK	0x0000001000000000ULL

#define	MSR_LS_CFG	0xc0011020
#define		LS_CFG_DIS_LS2_SQUISH	0x02000000

#define	MSR_IC_CFG	0xc0011021
#define		IC_CFG_DIS_SEQ_PREFETCH	0x00000800

#define	MSR_DC_CFG	0xc0011022
#define		DC_CFG_DIS_CNV_WC_SSO	0x00000004
#define		DC_CFG_DIS_SMC_CHK_BUF	0x00000400

#define	MSR_BU_CFG	0xc0011023
#define		BU_CFG_THRL2IDXCMPDIS	0x0000080000000000ULL
#define		BU_CFG_WBPFSMCCHKDIS	0x0000200000000000ULL
#define		BU_CFG_WBENHWSBDIS	0x0001000000000000ULL

/*
 * Constants related to MTRRs
 */
#define MTRR_N64K		8	/* numbers of fixed-size entries */
#define MTRR_N16K		16
#define MTRR_N4K		64

/*
 * the following four 3-byte registers control the non-cacheable regions.
 * These registers must be written as three separate bytes.
 *
 * NCRx+0: A31-A24 of starting address
 * NCRx+1: A23-A16 of starting address
 * NCRx+2: A15-A12 of starting address | NCR_SIZE_xx.
 * 
 * The non-cacheable region's starting address must be aligned to the
 * size indicated by the NCR_SIZE_xx field.
 */
#define NCR1	0xc4
#define NCR2	0xc7
#define NCR3	0xca
#define NCR4	0xcd

#define NCR_SIZE_0K	0
#define NCR_SIZE_4K	1
#define NCR_SIZE_8K	2
#define NCR_SIZE_16K	3
#define NCR_SIZE_32K	4
#define NCR_SIZE_64K	5
#define NCR_SIZE_128K	6
#define NCR_SIZE_256K	7
#define NCR_SIZE_512K	8
#define NCR_SIZE_1M	9
#define NCR_SIZE_2M	10
#define NCR_SIZE_4M	11
#define NCR_SIZE_8M	12
#define NCR_SIZE_16M	13
#define NCR_SIZE_32M	14
#define NCR_SIZE_4G	15

/*
 * Performance monitor events.
 *
 * Note that 586-class and 686-class CPUs have different performance
 * monitors available, and they are accessed differently:
 *
 *	686-class: `rdpmc' instruction
 *	586-class: `rdmsr' instruction, CESR MSR
 *
 * The descriptions of these events are too lengthy to include here.
 * See Appendix A of "Intel Architecture Software Developer's
 * Manual, Volume 3: System Programming" for more information.
 */

/*
 * 586-class CESR MSR format.  Lower 16 bits is CTR0, upper 16 bits
 * is CTR1.
 */

#define	PMC5_CESR_EVENT			0x003f
#define	PMC5_CESR_OS			0x0040
#define	PMC5_CESR_USR			0x0080
#define	PMC5_CESR_E			0x0100
#define	PMC5_CESR_P			0x0200

#define PMC5_DATA_READ			0x00
#define PMC5_DATA_WRITE			0x01
#define PMC5_DATA_TLB_MISS		0x02
#define PMC5_DATA_READ_MISS		0x03
#define PMC5_DATA_WRITE_MISS		0x04
#define PMC5_WRITE_M_E			0x05
#define PMC5_DATA_LINES_WBACK		0x06
#define PMC5_DATA_CACHE_SNOOP		0x07
#define PMC5_DATA_CACHE_SNOOP_HIT	0x08
#define PMC5_MEM_ACCESS_BOTH_PIPES	0x09
#define PMC5_BANK_CONFLICTS		0x0a
#define PMC5_MISALIGNED_DATA		0x0b
#define PMC5_INST_READ			0x0c
#define PMC5_INST_TLB_MISS		0x0d
#define PMC5_INST_CACHE_MISS		0x0e
#define PMC5_SEGMENT_REG_LOAD		0x0f
#define PMC5_BRANCHES		 	0x12
#define PMC5_BTB_HITS		 	0x13
#define PMC5_BRANCH_TAKEN		0x14
#define PMC5_PIPELINE_FLUSH		0x15
#define PMC5_INST_EXECUTED		0x16
#define PMC5_INST_EXECUTED_V_PIPE	0x17
#define PMC5_BUS_UTILIZATION		0x18
#define PMC5_WRITE_BACKUP_STALL		0x19
#define PMC5_DATA_READ_STALL		0x1a
#define PMC5_WRITE_E_M_STALL		0x1b
#define PMC5_LOCKED_BUS			0x1c
#define PMC5_IO_CYCLE			0x1d
#define PMC5_NONCACHE_MEM_READ		0x1e
#define PMC5_AGI_STALL			0x1f
#define PMC5_FLOPS			0x22
#define PMC5_BP0_MATCH			0x23
#define PMC5_BP1_MATCH			0x24
#define PMC5_BP2_MATCH			0x25
#define PMC5_BP3_MATCH			0x26
#define PMC5_HARDWARE_INTR		0x27
#define PMC5_DATA_RW			0x28
#define PMC5_DATA_RW_MISS		0x29

/*
 * 686-class Event Selector MSR format.
 */

#define	PMC6_EVTSEL_EVENT		0x000000ff
#define	PMC6_EVTSEL_UNIT		0x0000ff00
#define	PMC6_EVTSEL_UNIT_SHIFT		8
#define	PMC6_EVTSEL_USR			(1 << 16)
#define	PMC6_EVTSEL_OS			(1 << 17)
#define	PMC6_EVTSEL_E			(1 << 18)
#define	PMC6_EVTSEL_PC			(1 << 19)
#define	PMC6_EVTSEL_INT			(1 << 20)
#define	PMC6_EVTSEL_EN			(1 << 22)	/* PerfEvtSel0 only */
#define	PMC6_EVTSEL_INV			(1 << 23)
#define	PMC6_EVTSEL_COUNTER_MASK	0xff000000
#define	PMC6_EVTSEL_COUNTER_MASK_SHIFT	24

/* Data Cache Unit */
#define	PMC6_DATA_MEM_REFS		0x43
#define	PMC6_DCU_LINES_IN		0x45
#define	PMC6_DCU_M_LINES_IN		0x46
#define	PMC6_DCU_M_LINES_OUT		0x47
#define	PMC6_DCU_MISS_OUTSTANDING	0x48

/* Instruction Fetch Unit */
#define	PMC6_IFU_IFETCH			0x80
#define	PMC6_IFU_IFETCH_MISS		0x81
#define	PMC6_ITLB_MISS			0x85
#define	PMC6_IFU_MEM_STALL		0x86
#define	PMC6_ILD_STALL			0x87

/* L2 Cache */
#define	PMC6_L2_IFETCH			0x28
#define	PMC6_L2_LD			0x29
#define	PMC6_L2_ST			0x2a
#define	PMC6_L2_LINES_IN		0x24
#define	PMC6_L2_LINES_OUT		0x26
#define	PMC6_L2_M_LINES_INM		0x25
#define	PMC6_L2_M_LINES_OUTM		0x27
#define	PMC6_L2_RQSTS			0x2e
#define	PMC6_L2_ADS			0x21
#define	PMC6_L2_DBUS_BUSY		0x22
#define	PMC6_L2_DBUS_BUSY_RD		0x23

/* External Bus Logic */
#define	PMC6_BUS_DRDY_CLOCKS		0x62
#define	PMC6_BUS_LOCK_CLOCKS		0x63
#define	PMC6_BUS_REQ_OUTSTANDING	0x60
#define	PMC6_BUS_TRAN_BRD		0x65
#define	PMC6_BUS_TRAN_RFO		0x66
#define	PMC6_BUS_TRANS_WB		0x67
#define	PMC6_BUS_TRAN_IFETCH		0x68
#define	PMC6_BUS_TRAN_INVAL		0x69
#define	PMC6_BUS_TRAN_PWR		0x6a
#define	PMC6_BUS_TRANS_P		0x6b
#define	PMC6_BUS_TRANS_IO		0x6c
#define	PMC6_BUS_TRAN_DEF		0x6d
#define	PMC6_BUS_TRAN_BURST		0x6e
#define	PMC6_BUS_TRAN_ANY		0x70
#define	PMC6_BUS_TRAN_MEM		0x6f
#define	PMC6_BUS_DATA_RCV		0x64
#define	PMC6_BUS_BNR_DRV		0x61
#define	PMC6_BUS_HIT_DRV		0x7a
#define	PMC6_BUS_HITM_DRDV		0x7b
#define	PMC6_BUS_SNOOP_STALL		0x7e

/* Floating Point Unit */
#define	PMC6_FLOPS			0xc1
#define	PMC6_FP_COMP_OPS_EXE		0x10
#define	PMC6_FP_ASSIST			0x11
#define	PMC6_MUL			0x12
#define	PMC6_DIV			0x12
#define	PMC6_CYCLES_DIV_BUSY		0x14

/* Memory Ordering */
#define	PMC6_LD_BLOCKS			0x03
#define	PMC6_SB_DRAINS			0x04
#define	PMC6_MISALIGN_MEM_REF		0x05
#define	PMC6_EMON_KNI_PREF_DISPATCHED	0x07	/* P-III only */
#define	PMC6_EMON_KNI_PREF_MISS		0x4b	/* P-III only */

/* Instruction Decoding and Retirement */
#define	PMC6_INST_RETIRED		0xc0
#define	PMC6_UOPS_RETIRED		0xc2
#define	PMC6_INST_DECODED		0xd0
#define	PMC6_EMON_KNI_INST_RETIRED	0xd8
#define	PMC6_EMON_KNI_COMP_INST_RET	0xd9

/* Interrupts */
#define	PMC6_HW_INT_RX			0xc8
#define	PMC6_CYCLES_INT_MASKED		0xc6
#define	PMC6_CYCLES_INT_PENDING_AND_MASKED 0xc7

/* Branches */
#define	PMC6_BR_INST_RETIRED		0xc4
#define	PMC6_BR_MISS_PRED_RETIRED	0xc5
#define	PMC6_BR_TAKEN_RETIRED		0xc9
#define	PMC6_BR_MISS_PRED_TAKEN_RET	0xca
#define	PMC6_BR_INST_DECODED		0xe0
#define	PMC6_BTB_MISSES			0xe2
#define	PMC6_BR_BOGUS			0xe4
#define	PMC6_BACLEARS			0xe6

/* Stalls */
#define	PMC6_RESOURCE_STALLS		0xa2
#define	PMC6_PARTIAL_RAT_STALLS		0xd2

/* Segment Register Loads */
#define	PMC6_SEGMENT_REG_LOADS		0x06

/* Clocks */
#define	PMC6_CPU_CLK_UNHALTED		0x79

/* MMX Unit */
#define	PMC6_MMX_INSTR_EXEC		0xb0	/* Celeron, P-II, P-IIX only */
#define	PMC6_MMX_SAT_INSTR_EXEC		0xb1	/* P-II and P-III only */
#define	PMC6_MMX_UOPS_EXEC		0xb2	/* P-II and P-III only */
#define	PMC6_MMX_INSTR_TYPE_EXEC	0xb3	/* P-II and P-III only */
#define	PMC6_FP_MMX_TRANS		0xcc	/* P-II and P-III only */
#define	PMC6_MMX_ASSIST			0xcd	/* P-II and P-III only */
#define	PMC6_MMX_INSTR_RET		0xc3	/* P-II only */

/* Segment Register Renaming */
#define	PMC6_SEG_RENAME_STALLS		0xd4	/* P-II and P-III only */
#define	PMC6_SEG_REG_RENAMES		0xd5	/* P-II and P-III only */
#define	PMC6_RET_SEG_RENAMES		0xd6	/* P-II and P-III only */

/*
 * AMD K7 Event Selector MSR format.
 */

#define	K7_EVTSEL_EVENT			0x000000ff
#define	K7_EVTSEL_UNIT			0x0000ff00
#define	K7_EVTSEL_UNIT_SHIFT		8
#define	K7_EVTSEL_USR			(1 << 16)
#define	K7_EVTSEL_OS			(1 << 17)
#define	K7_EVTSEL_E			(1 << 18)
#define	K7_EVTSEL_PC			(1 << 19)
#define	K7_EVTSEL_INT			(1 << 20)
#define	K7_EVTSEL_EN			(1 << 22)
#define	K7_EVTSEL_INV			(1 << 23)
#define	K7_EVTSEL_COUNTER_MASK		0xff000000
#define	K7_EVTSEL_COUNTER_MASK_SHIFT	24

/* Segment Register Loads */
#define	K7_SEGMENT_REG_LOADS		0x20

#define	K7_STORES_TO_ACTIVE_INST_STREAM	0x21

/* Data Cache Unit */
#define	K7_DATA_CACHE_ACCESS		0x40
#define	K7_DATA_CACHE_MISS		0x41
#define	K7_DATA_CACHE_REFILL		0x42
#define	K7_DATA_CACHE_REFILL_SYSTEM	0x43
#define	K7_DATA_CACHE_WBACK		0x44
#define	K7_L2_DTLB_HIT			0x45
#define	K7_L2_DTLB_MISS			0x46
#define	K7_MISALIGNED_DATA_REF		0x47
#define	K7_SYSTEM_REQUEST		0x64
#define	K7_SYSTEM_REQUEST_TYPE		0x65

#define	K7_SNOOP_HIT			0x73
#define	K7_SINGLE_BIT_ECC_ERROR		0x74
#define	K7_CACHE_LINE_INVAL		0x75
#define	K7_CYCLES_PROCESSOR_IS_RUNNING	0x76
#define	K7_L2_REQUEST			0x79
#define	K7_L2_REQUEST_BUSY		0x7a

/* Instruction Fetch Unit */
#define	K7_IFU_IFETCH			0x80
#define	K7_IFU_IFETCH_MISS		0x81
#define	K7_IFU_REFILL_FROM_L2		0x82
#define	K7_IFU_REFILL_FROM_SYSTEM	0x83
#define	K7_ITLB_L1_MISS			0x84
#define	K7_ITLB_L2_MISS			0x85
#define	K7_SNOOP_RESYNC			0x86
#define	K7_IFU_STALL			0x87

#define	K7_RETURN_STACK_HITS		0x88
#define	K7_RETURN_STACK_OVERFLOW	0x89

/* Retired */
#define	K7_RETIRED_INST			0xc0
#define	K7_RETIRED_OPS			0xc1
#define	K7_RETIRED_BRANCHES		0xc2
#define	K7_RETIRED_BRANCH_MISPREDICTED	0xc3
#define	K7_RETIRED_TAKEN_BRANCH		0xc4
#define	K7_RETIRED_TAKEN_BRANCH_MISPREDICTED	0xc5
#define	K7_RETIRED_FAR_CONTROL_TRANSFER	0xc6
#define	K7_RETIRED_RESYNC_BRANCH	0xc7
#define	K7_RETIRED_NEAR_RETURNS		0xc8
#define	K7_RETIRED_NEAR_RETURNS_MISPREDICTED	0xc9
#define	K7_RETIRED_INDIRECT_MISPREDICTED	0xca

/* Interrupts */
#define	K7_CYCLES_INT_MASKED		0xcd
#define	K7_CYCLES_INT_PENDING_AND_MASKED	0xce
#define	K7_HW_INTR_RECV			0xcf

#define	K7_INSTRUCTION_DECODER_EMPTY	0xd0
#define	K7_DISPATCH_STALLS		0xd1
#define	K7_BRANCH_ABORTS_TO_RETIRE	0xd2
#define	K7_SERIALIZE			0xd3
#define	K7_SEGMENT_LOAD_STALL		0xd4
#define	K7_ICU_FULL			0xd5
#define	K7_RESERVATION_STATIONS_FULL	0xd6
#define	K7_FPU_FULL			0xd7
#define	K7_LS_FULL			0xd8
#define	K7_ALL_QUIET_STALL		0xd9
#define	K7_FAR_TRANSFER_OR_RESYNC_BRANCH_PENDING	0xda

#define	K7_BP0_MATCH			0xdc
#define	K7_BP1_MATCH			0xdd
#define	K7_BP2_MATCH			0xde
#define	K7_BP3_MATCH			0xdf

/* VIA C3 crypto featureset: for i386_has_xcrypt */
#define C3_HAS_AES			1	/* cpu has AES */
#define C3_HAS_SHA			2	/* cpu has SHA1 & SHA256 */
#define C3_HAS_MM			4	/* cpu has RSA instructions */
#define C3_HAS_AESCTR			8	/* cpu has AES-CTR instructions */

/* Centaur Extended Feature flags */
#define C3_CPUID_HAS_RNG		0x000004
#define C3_CPUID_DO_RNG			0x000008
#define C3_CPUID_HAS_ACE		0x000040
#define C3_CPUID_DO_ACE			0x000080
#define C3_CPUID_HAS_ACE2		0x000100
#define C3_CPUID_DO_ACE2		0x000200
#define C3_CPUID_HAS_PHE		0x000400
#define C3_CPUID_DO_PHE			0x000800
#define C3_CPUID_HAS_PMM		0x001000
#define C3_CPUID_DO_PMM			0x002000

/* VIA C3 xcrypt-* instruction context control options */
#define	C3_CRYPT_CWLO_ROUND_M		0x0000000f
#define	C3_CRYPT_CWLO_ALG_M		0x00000070
#define	C3_CRYPT_CWLO_ALG_AES		0x00000000
#define	C3_CRYPT_CWLO_KEYGEN_M		0x00000080
#define	C3_CRYPT_CWLO_KEYGEN_HW		0x00000000
#define	C3_CRYPT_CWLO_KEYGEN_SW		0x00000080
#define	C3_CRYPT_CWLO_NORMAL		0x00000000
#define	C3_CRYPT_CWLO_INTERMEDIATE	0x00000100
#define	C3_CRYPT_CWLO_ENCRYPT		0x00000000
#define	C3_CRYPT_CWLO_DECRYPT		0x00000200
#define	C3_CRYPT_CWLO_KEY128		0x0000000a	/* 128bit, 10 rds */
#define	C3_CRYPT_CWLO_KEY192		0x0000040c	/* 192bit, 12 rds */
#define	C3_CRYPT_CWLO_KEY256		0x0000080e	/* 256bit, 15 rds */

/* Intel Silicon Debug */
#define IA32_DEBUG_INTERFACE		0xc80
#define IA32_DEBUG_INTERFACE_ENABLE	0x00000001
#define IA32_DEBUG_INTERFACE_LOCK	0x40000000
#define IA32_DEBUG_INTERFACE_MASK	0x80000000

/*
 * VMX
 */
#define IA32_FEATURE_CONTROL_LOCK	0x01
#define IA32_FEATURE_CONTROL_SMX_EN	0x02
#define IA32_FEATURE_CONTROL_VMX_EN	0x04
#define IA32_FEATURE_CONTROL_SENTER_EN (1ULL << 15)
#define IA32_FEATURE_CONTROL_SENTER_PARAM_MASK 0x7f00
#define IA32_VMX_BASIC			0x480
#define IA32_VMX_PINBASED_CTLS		0x481
#define IA32_VMX_PROCBASED_CTLS		0x482
#define IA32_VMX_EXIT_CTLS		0x483
#define IA32_VMX_ENTRY_CTLS		0x484
#define IA32_VMX_MISC			0x485
#define IA32_VMX_CR0_FIXED0		0x486
#define IA32_VMX_CR0_FIXED1		0x487
#define IA32_VMX_CR4_FIXED0		0x488
#define IA32_VMX_CR4_FIXED1		0x489
#define IA32_VMX_PROCBASED2_CTLS	0x48B
#define IA32_VMX_EPT_VPID_CAP		0x48C
#define IA32_VMX_TRUE_PINBASED_CTLS	0x48D
#define IA32_VMX_TRUE_PROCBASED_CTLS	0x48E
#define IA32_VMX_TRUE_EXIT_CTLS		0x48F
#define IA32_VMX_TRUE_ENTRY_CTLS	0x490
#define IA32_VMX_VMFUNC			0x491

#define IA32_EPT_VPID_CAP_PAGE_WALK_4	(1ULL << 6)
#define IA32_EPT_VPID_CAP_WB		(1ULL << 14)
#define IA32_EPT_VPID_CAP_AD_BITS	(1ULL << 21)

#define IA32_EPT_PAGING_CACHE_TYPE_UC	0x0
#define IA32_EPT_PAGING_CACHE_TYPE_WB	0x6
#define IA32_EPT_AD_BITS_ENABLE		(1ULL << 6)
#define IA32_EPT_PAGE_WALK_LENGTH	0x4

/* VMX : IA32_VMX_BASIC bits */
#define IA32_VMX_TRUE_CTLS_AVAIL			(1ULL << 55)

/* VMX : IA32_VMX_PINBASED_CTLS bits */
#define IA32_VMX_EXTERNAL_INT_EXITING			(1ULL << 0)
#define IA32_VMX_NMI_EXITING				(1ULL << 3)
#define IA32_VMX_VIRTUAL_NMIS				(1ULL << 5)
#define IA32_VMX_ACTIVATE_VMX_PREEMPTION_TIMER		(1ULL << 6)
#define IA32_VMX_PROCESS_POSTED_INTERRUPTS		(1ULL << 7)

/* VMX : IA32_VMX_PROCBASED_CTLS bits */
#define IA32_VMX_INTERRUPT_WINDOW_EXITING		(1ULL << 2)
#define IA32_VMX_USE_TSC_OFFSETTING			(1ULL << 3)
#define IA32_VMX_HLT_EXITING				(1ULL << 7)
#define IA32_VMX_INVLPG_EXITING				(1ULL << 9)
#define IA32_VMX_MWAIT_EXITING				(1ULL << 10)
#define IA32_VMX_RDPMC_EXITING				(1ULL << 11)
#define IA32_VMX_RDTSC_EXITING				(1ULL << 12)
#define IA32_VMX_CR3_LOAD_EXITING			(1ULL << 15)
#define IA32_VMX_CR3_STORE_EXITING			(1ULL << 16)
#define IA32_VMX_CR8_LOAD_EXITING			(1ULL << 19)
#define IA32_VMX_CR8_STORE_EXITING			(1ULL << 20)
#define IA32_VMX_USE_TPR_SHADOW				(1ULL << 21)
#define IA32_VMX_NMI_WINDOW_EXITING			(1ULL << 22)
#define IA32_VMX_MOV_DR_EXITING				(1ULL << 23)
#define IA32_VMX_UNCONDITIONAL_IO_EXITING		(1ULL << 24)
#define IA32_VMX_USE_IO_BITMAPS				(1ULL << 25)
#define IA32_VMX_MONITOR_TRAP_FLAG			(1ULL << 27)
#define IA32_VMX_USE_MSR_BITMAPS			(1ULL << 28)
#define IA32_VMX_MONITOR_EXITING			(1ULL << 29)
#define IA32_VMX_PAUSE_EXITING				(1ULL << 30)
#define IA32_VMX_ACTIVATE_SECONDARY_CONTROLS		(1ULL << 31)

/* VMX : IA32_VMX_PROCBASED2_CTLS bits */
#define IA32_VMX_VIRTUALIZE_APIC			(1ULL << 0)
#define IA32_VMX_ENABLE_EPT				(1ULL << 1)
#define IA32_VMX_DESCRIPTOR_TABLE_EXITING		(1ULL << 2)
#define IA32_VMX_ENABLE_RDTSCP				(1ULL << 3)
#define IA32_VMX_VIRTUALIZE_X2APIC_MODE			(1ULL << 4)
#define IA32_VMX_ENABLE_VPID				(1ULL << 5)
#define IA32_VMX_WBINVD_EXITING				(1ULL << 6)
#define IA32_VMX_UNRESTRICTED_GUEST			(1ULL << 7)
#define IA32_VMX_APIC_REGISTER_VIRTUALIZATION		(1ULL << 8)
#define IA32_VMX_VIRTUAL_INTERRUPT_DELIVERY		(1ULL << 9)
#define IA32_VMX_PAUSE_LOOP_EXITING			(1ULL << 10)
#define IA32_VMX_RDRAND_EXITING				(1ULL << 11)
#define IA32_VMX_ENABLE_INVPCID				(1ULL << 12)
#define IA32_VMX_ENABLE_VM_FUNCTIONS			(1ULL << 13)
#define IA32_VMX_VMCS_SHADOWING				(1ULL << 14)
#define IA32_VMX_ENABLE_ENCLS_EXITING			(1ULL << 15)
#define IA32_VMX_RDSEED_EXITING				(1ULL << 16)
#define IA32_VMX_ENABLE_PML				(1ULL << 17)
#define IA32_VMX_EPT_VIOLATION_VE			(1ULL << 18)
#define IA32_VMX_CONCEAL_VMX_FROM_PT			(1ULL << 19)
#define IA32_VMX_ENABLE_XSAVES_XRSTORS			(1ULL << 20)
#define IA32_VMX_ENABLE_TSC_SCALING			(1ULL << 25)

/* VMX : IA32_VMX_EXIT_CTLS bits */
#define IA32_VMX_SAVE_DEBUG_CONTROLS			(1ULL << 2)
#define IA32_VMX_HOST_SPACE_ADDRESS_SIZE		(1ULL << 9)
#define IA32_VMX_LOAD_IA32_PERF_GLOBAL_CTRL_ON_EXIT	(1ULL << 12)
#define IA32_VMX_ACKNOWLEDGE_INTERRUPT_ON_EXIT		(1ULL << 15)
#define IA32_VMX_SAVE_IA32_PAT_ON_EXIT			(1ULL << 18)
#define IA32_VMX_LOAD_IA32_PAT_ON_EXIT			(1ULL << 19)
#define IA32_VMX_SAVE_IA32_EFER_ON_EXIT			(1ULL << 20)
#define IA32_VMX_LOAD_IA32_EFER_ON_EXIT			(1ULL << 21)
#define IA32_VMX_SAVE_VMX_PREEMPTION_TIMER		(1ULL << 22)
#define IA32_VMX_CLEAR_IA32_BNDCFGS_ON_EXIT		(1ULL << 23)
#define IA32_VMX_CONCEAL_VM_EXITS_FROM_PT		(1ULL << 24)

/* VMX: IA32_VMX_ENTRY_CTLS bits */
#define IA32_VMX_LOAD_DEBUG_CONTROLS			(1ULL << 2)
#define IA32_VMX_IA32E_MODE_GUEST			(1ULL << 9)
#define IA32_VMX_ENTRY_TO_SMM				(1ULL << 10)
#define IA32_VMX_DEACTIVATE_DUAL_MONITOR_TREATMENT	(1ULL << 11)
#define IA32_VMX_LOAD_IA32_PERF_GLOBAL_CTRL_ON_ENTRY	(1ULL << 13)
#define IA32_VMX_LOAD_IA32_PAT_ON_ENTRY			(1ULL << 14)
#define IA32_VMX_LOAD_IA32_EFER_ON_ENTRY		(1ULL << 15)
#define IA32_VMX_LOAD_IA32_BNDCFGS_ON_ENTRY		(1ULL << 16)
#define IA32_VMX_CONCEAL_VM_ENTRIES_FROM_PT		(1ULL << 17)

/*
 * VMX : VMCS Fields
 */

/* 16-bit control fields */
#define VMCS_GUEST_VPID			0x0000
#define VMCS_POSTED_INT_NOTIF_VECTOR	0x0002
#define VMCS_EPTP_INDEX			0x0004

/* 16-bit guest state fields */
#define VMCS_GUEST_IA32_ES_SEL		0x0800
#define VMCS_GUEST_IA32_CS_SEL		0x0802
#define VMCS_GUEST_IA32_SS_SEL		0x0804
#define VMCS_GUEST_IA32_DS_SEL		0x0806
#define VMCS_GUEST_IA32_FS_SEL		0x0808
#define VMCS_GUEST_IA32_GS_SEL		0x080A
#define VMCS_GUEST_IA32_LDTR_SEL	0x080C
#define VMCS_GUEST_IA32_TR_SEL		0x080E
#define VMCS_GUEST_INTERRUPT_STATUS	0x0810
#define VMCS_GUEST_PML_INDEX		0x0812

/* 16-bit host state fields */
#define VMCS_HOST_IA32_ES_SEL		0x0C00
#define VMCS_HOST_IA32_CS_SEL		0x0C02
#define VMCS_HOST_IA32_SS_SEL		0x0C04
#define VMCS_HOST_IA32_DS_SEL		0x0C06
#define VMCS_HOST_IA32_FS_SEL		0x0C08
#define VMCS_HOST_IA32_GS_SEL		0x0C0A
#define VMCS_HOST_IA32_TR_SEL		0x0C0C

/* 64-bit control fields */
#define VMCS_IO_BITMAP_A		0x2000
#define VMCS_IO_BITMAP_B		0x2002
#define VMCS_MSR_BITMAP_ADDRESS		0x2004
#define VMCS_EXIT_STORE_MSR_ADDRESS	0x2006
#define VMCS_EXIT_LOAD_MSR_ADDRESS	0x2008
#define VMCS_ENTRY_LOAD_MSR_ADDRESS	0x200A
#define VMCS_EXECUTIVE_VMCS_POINTER	0x200C
#define VMCS_PML_ADDRESS		0x200E
#define VMCS_TSC_OFFSET			0x2010
#define VMCS_VIRTUAL_APIC_ADDRESS	0x2012
#define VMCS_APIC_ACCESS_ADDRESS	0x2014
#define VMCS_POSTED_INTERRUPT_DESC	0x2016
#define VMCS_VM_FUNCTION_CONTROLS	0x2018
#define VMCS_GUEST_IA32_EPTP		0x201A
#define VMCS_EOI_EXIT_BITMAP_0		0x201C
#define VMCS_EOI_EXIT_BITMAP_1		0x201E
#define VMCS_EOI_EXIT_BITMAP_2		0x2020
#define VMCS_EOI_EXIT_BITMAP_3		0x2022
#define VMCS_EPTP_LIST_ADDRESS		0x2024
#define VMCS_VMREAD_BITMAP_ADDRESS	0x2026
#define VMCS_VMWRITE_BITMAP_ADDRESS	0x2028
#define VMCS_VIRTUALIZATION_EXC_ADDRESS	0x202A
#define VMCS_XSS_EXITING_BITMAP		0x202C
#define VMCS_ENCLS_EXITING_BITMAP	0x202E
#define VMCS_TSC_MULTIPLIER		0x2032

/* 64-bit RO data field */
#define VMCS_GUEST_PHYSICAL_ADDRESS	0x2400

/* 64-bit guest state fields */
#define VMCS_LINK_POINTER		0x2800
#define VMCS_GUEST_IA32_DEBUGCTL	0x2802
#define VMCS_GUEST_IA32_PAT		0x2804
#define VMCS_GUEST_IA32_EFER		0x2806
#define VMCS_GUEST_IA32_PERF_GBL_CTRL	0x2808
#define VMCS_GUEST_PDPTE0		0x280A
#define VMCS_GUEST_PDPTE1		0x280C
#define VMCS_GUEST_PDPTE2		0x280E
#define VMCS_GUEST_PDPTE3		0x2810
#define VMCS_GUEST_IA32_BNDCFGS		0x2812

/* 64-bit host state fields */
#define VMCS_HOST_IA32_PAT		0x2C00
#define VMCS_HOST_IA32_EFER		0x2C02
#define VMCS_HOST_IA32_PERF_GBL_CTRL	0x2C04

/* 32-bit control fields */
#define VMCS_PINBASED_CTLS		0x4000
#define VMCS_PROCBASED_CTLS		0x4002
#define VMCS_EXCEPTION_BITMAP		0x4004
#define VMCS_PF_ERROR_CODE_MASK		0x4006
#define VMCS_PF_ERROR_CODE_MATCH	0x4008
#define VMCS_CR3_TARGET_COUNT		0x400A
#define VMCS_EXIT_CTLS			0x400C
#define VMCS_EXIT_MSR_STORE_COUNT	0x400E
#define VMCS_EXIT_MSR_LOAD_COUNT	0x4010
#define VMCS_ENTRY_CTLS			0x4012
#define VMCS_ENTRY_MSR_LOAD_COUNT	0x4014
#define VMCS_ENTRY_INTERRUPTION_INFO	0x4016
#define VMCS_ENTRY_EXCEPTION_ERROR_CODE	0x4018
#define VMCS_ENTRY_INSTRUCTION_LENGTH	0x401A
#define VMCS_TPR_THRESHOLD		0x401C
#define VMCS_PROCBASED2_CTLS		0x401E
#define VMCS_PLE_GAP			0x4020
#define VMCS_PLE_WINDOW			0x4022

/* 32-bit RO data fields */
#define VMCS_INSTRUCTION_ERROR		0x4400
#define VMCS_EXIT_REASON		0x4402
#define VMCS_EXIT_INTERRUPTION_INFO	0x4404
#define VMCS_EXIT_INTERRUPTION_ERR_CODE	0x4406
#define VMCS_IDT_VECTORING_INFO		0x4408
#define VMCS_IDT_VECTORING_ERROR_CODE	0x440A
#define VMCS_INSTRUCTION_LENGTH		0x440C
#define VMCS_EXIT_INSTRUCTION_INFO	0x440E

/* 32-bit guest state fields */
#define VMCS_GUEST_IA32_ES_LIMIT	0x4800
#define VMCS_GUEST_IA32_CS_LIMIT	0x4802
#define VMCS_GUEST_IA32_SS_LIMIT	0x4804
#define VMCS_GUEST_IA32_DS_LIMIT	0x4806
#define VMCS_GUEST_IA32_FS_LIMIT	0x4808
#define VMCS_GUEST_IA32_GS_LIMIT	0x480A
#define VMCS_GUEST_IA32_LDTR_LIMIT	0x480C
#define VMCS_GUEST_IA32_TR_LIMIT	0x480E
#define VMCS_GUEST_IA32_GDTR_LIMIT	0x4810
#define VMCS_GUEST_IA32_IDTR_LIMIT	0x4812
#define VMCS_GUEST_IA32_ES_AR		0x4814
#define VMCS_GUEST_IA32_CS_AR		0x4816
#define VMCS_GUEST_IA32_SS_AR		0x4818
#define VMCS_GUEST_IA32_DS_AR		0x481A
#define VMCS_GUEST_IA32_FS_AR		0x481C
#define VMCS_GUEST_IA32_GS_AR		0x481E
#define VMCS_GUEST_IA32_LDTR_AR		0x4820
#define VMCS_GUEST_IA32_TR_AR		0x4822
#define VMCS_GUEST_INTERRUPTIBILITY_ST	0x4824
#define VMCS_GUEST_ACTIVITY_STATE	0x4826
#define VMCS_GUEST_SMBASE		0x4828
#define VMCS_GUEST_IA32_SYSENTER_CS	0x482A
#define VMCS_VMX_PREEMPTION_TIMER_VAL	0x482E

/* 32-bit host state field */
#define VMCS_HOST_IA32_SYSENTER_CS	0x4C00

/* Natural-width control fields */
#define VMCS_CR0_MASK			0x6000
#define VMCS_CR4_MASK			0x6002
#define VMCS_CR0_READ_SHADOW		0x6004
#define VMCS_CR4_READ_SHADOW		0x6006
#define VMCS_CR3_TARGET_0		0x6008
#define VMCS_CR3_TARGET_1		0x600A
#define VMCS_CR3_TARGET_2		0x600C
#define VMCS_CR3_TARGET_3		0x600E

/* Natural-width RO fields */
#define VMCS_GUEST_EXIT_QUALIFICATION	0x6400
#define VMCS_IO_RCX			0x6402
#define VMCS_IO_RSI			0x6404
#define VMCS_IO_RDI			0x6406
#define VMCS_IO_RIP			0x6408
#define VMCS_GUEST_LINEAR_ADDRESS	0x640A

/* Natural-width guest state fields */
#define VMCS_GUEST_IA32_CR0		0x6800
#define VMCS_GUEST_IA32_CR3		0x6802
#define VMCS_GUEST_IA32_CR4		0x6804
#define VMCS_GUEST_IA32_ES_BASE		0x6806
#define VMCS_GUEST_IA32_CS_BASE		0x6808
#define VMCS_GUEST_IA32_SS_BASE		0x680A
#define VMCS_GUEST_IA32_DS_BASE		0x680C
#define VMCS_GUEST_IA32_FS_BASE		0x680E
#define VMCS_GUEST_IA32_GS_BASE		0x6810
#define VMCS_GUEST_IA32_LDTR_BASE	0x6812
#define VMCS_GUEST_IA32_TR_BASE		0x6814
#define VMCS_GUEST_IA32_GDTR_BASE	0x6816
#define VMCS_GUEST_IA32_IDTR_BASE	0x6818
#define VMCS_GUEST_IA32_DR7		0x681A
#define VMCS_GUEST_IA32_RSP		0x681C
#define VMCS_GUEST_IA32_RIP		0x681E
#define VMCS_GUEST_IA32_RFLAGS		0x6820
#define VMCS_GUEST_PENDING_DBG_EXC	0x6822
#define VMCS_GUEST_IA32_SYSENTER_ESP	0x6824
#define VMCS_GUEST_IA32_SYSENTER_EIP	0x6826

/* Natural-width host state fields */
#define VMCS_HOST_IA32_CR0		0x6C00          
#define VMCS_HOST_IA32_CR3		0x6C02
#define VMCS_HOST_IA32_CR4		0x6C04
#define VMCS_HOST_IA32_FS_BASE		0x6C06
#define VMCS_HOST_IA32_GS_BASE		0x6C08
#define VMCS_HOST_IA32_TR_BASE		0x6C0A
#define VMCS_HOST_IA32_GDTR_BASE	0x6C0C
#define VMCS_HOST_IA32_IDTR_BASE	0x6C0E
#define VMCS_HOST_IA32_SYSENTER_ESP	0x6C10
#define VMCS_HOST_IA32_SYSENTER_EIP	0x6C12
#define VMCS_HOST_IA32_RSP		0x6C14
#define VMCS_HOST_IA32_RIP		0x6C16

#define IA32_VMX_INVVPID_INDIV_ADDR_CTX	0x0
#define IA32_VMX_INVVPID_SINGLE_CTX	0x1
#define IA32_VMX_INVVPID_ALL_CTX	0x2
#define IA32_VMX_INVVPID_SINGLE_CTX_GLB	0x3

#define IA32_VMX_INVEPT_SINGLE_CTX	0x1
#define IA32_VMX_INVEPT_GLOBAL_CTX	0x2

#define IA32_VMX_EPT_FAULT_READ		(1ULL << 0)
#define IA32_VMX_EPT_FAULT_WRITE	(1ULL << 1)
#define IA32_VMX_EPT_FAULT_EXEC		(1ULL << 2)

#define IA32_VMX_EPT_FAULT_WAS_READABLE (1ULL << 3)
#define IA32_VMX_EPT_FAULT_WAS_WRITABLE	(1ULL << 4)
#define IA32_VMX_EPT_FAULT_WAS_EXECABLE (1ULL << 5)

#define IA32_VMX_MSR_LIST_SIZE_MASK	(7ULL << 25)
#define IA32_VMX_CR3_TGT_SIZE_MASK	(0x1FFULL << 16)

/*
 * SVM
 */
#define MSR_AMD_VM_CR			0xc0010114
#define MSR_AMD_VM_HSAVE_PA		0xc0010117
#define CPUID_AMD_SVM_CAP		0x8000000A
#define AMD_SVM_NESTED_PAGING_CAP	(1 << 0)
#define AMD_SVM_VMCB_CLEAN_CAP		(1 << 5)
#define AMD_SVM_FLUSH_BY_ASID_CAP	(1 << 6)
#define AMD_SVMDIS			0x10

#define SVM_TLB_CONTROL_FLUSH_NONE	0
#define SVM_TLB_CONTROL_FLUSH_ALL	1
#define SVM_TLB_CONTROL_FLUSH_ASID	3
#define SVM_TLB_CONTROL_FLUSH_ASID_GLB	7

#define SVM_CLEANBITS_I			(1 << 0)
#define SVM_CLEANBITS_IOPM		(1 << 1)
#define SVM_CLEANBITS_ASID		(1 << 2)
#define SVM_CLEANBITS_TPR		(1 << 3)
#define SVM_CLEANBITS_NP		(1 << 4)
#define SVM_CLEANBITS_CR		(1 << 5)
#define SVM_CLEANBITS_DR		(1 << 6)
#define SVM_CLEANBITS_DT		(1 << 7)
#define SVM_CLEANBITS_SEG		(1 << 8)
#define SVM_CLEANBITS_CR2		(1 << 9)
#define SVM_CLEANBITS_LBR		(1 << 10)
#define SVM_CLEANBITS_AVIC		(1 << 11)

#define SVM_CLEANBITS_ALL \
	(SVM_CLEANBITS_I | SVM_CLEANBITS_IOPM | SVM_CLEANBITS_ASID | \
	 SVM_CLEANBITS_TPR | SVM_CLEANBITS_NP | SVM_CLEANBITS_CR | \
	 SVM_CLEANBITS_DR | SVM_CLEANBITS_DT | SVM_CLEANBITS_SEG | \
	 SVM_CLEANBITS_CR2 | SVM_CLEANBITS_LBR | SVM_CLEANBITS_AVIC )

/*
 * SVM : VMCB intercepts
 */
#define SVM_INTERCEPT_CR0_READ		(1UL << 0)
#define SVM_INTERCEPT_CR1_READ		(1UL << 1)
#define SVM_INTERCEPT_CR2_READ		(1UL << 2)
#define SVM_INTERCEPT_CR3_READ		(1UL << 2)
#define SVM_INTERCEPT_CR4_READ		(1UL << 4)
#define SVM_INTERCEPT_CR5_READ		(1UL << 5)
#define SVM_INTERCEPT_CR6_READ		(1UL << 6)
#define SVM_INTERCEPT_CR7_READ		(1UL << 7)
#define SVM_INTERCEPT_CR8_READ		(1UL << 8)
#define SVM_INTERCEPT_CR9_READ		(1UL << 9)
#define SVM_INTERCEPT_CR10_READ		(1UL << 10)
#define SVM_INTERCEPT_CR11_READ		(1UL << 11)
#define SVM_INTERCEPT_CR12_READ		(1UL << 12)
#define SVM_INTERCEPT_CR13_READ		(1UL << 13)
#define SVM_INTERCEPT_CR14_READ		(1UL << 14)
#define SVM_INTERCEPT_CR15_READ		(1UL << 15)
#define SVM_INTERCEPT_CR0_WRITE		(1UL << 16)
#define SVM_INTERCEPT_CR1_WRITE		(1UL << 17)
#define SVM_INTERCEPT_CR2_WRITE		(1UL << 18)
#define SVM_INTERCEPT_CR3_WRITE		(1UL << 19)
#define SVM_INTERCEPT_CR4_WRITE		(1UL << 20)
#define SVM_INTERCEPT_CR5_WRITE		(1UL << 21)
#define SVM_INTERCEPT_CR6_WRITE		(1UL << 22)
#define SVM_INTERCEPT_CR7_WRITE		(1UL << 23)
#define SVM_INTERCEPT_CR8_WRITE		(1UL << 24)
#define SVM_INTERCEPT_CR9_WRITE		(1UL << 25)
#define SVM_INTERCEPT_CR10_WRITE	(1UL << 26)
#define SVM_INTERCEPT_CR11_WRITE	(1UL << 27)
#define SVM_INTERCEPT_CR12_WRITE	(1UL << 28)
#define SVM_INTERCEPT_CR13_WRITE	(1UL << 29)
#define SVM_INTERCEPT_CR14_WRITE	(1UL << 30)
#define SVM_INTERCEPT_CR15_WRITE	(1UL << 31)
#define SVM_INTERCEPT_DR0_READ		(1UL << 0)
#define SVM_INTERCEPT_DR1_READ		(1UL << 1)
#define SVM_INTERCEPT_DR2_READ		(1UL << 2)
#define SVM_INTERCEPT_DR3_READ		(1UL << 2)
#define SVM_INTERCEPT_DR4_READ		(1UL << 4)
#define SVM_INTERCEPT_DR5_READ		(1UL << 5)
#define SVM_INTERCEPT_DR6_READ		(1UL << 6)
#define SVM_INTERCEPT_DR7_READ		(1UL << 7)
#define SVM_INTERCEPT_DR8_READ		(1UL << 8)
#define SVM_INTERCEPT_DR9_READ		(1UL << 9)
#define SVM_INTERCEPT_DR10_READ		(1UL << 10)
#define SVM_INTERCEPT_DR11_READ		(1UL << 11)
#define SVM_INTERCEPT_DR12_READ		(1UL << 12)
#define SVM_INTERCEPT_DR13_READ		(1UL << 13)
#define SVM_INTERCEPT_DR14_READ		(1UL << 14)
#define SVM_INTERCEPT_DR15_READ		(1UL << 15)
#define SVM_INTERCEPT_DR0_WRITE		(1UL << 16)
#define SVM_INTERCEPT_DR1_WRITE		(1UL << 17)
#define SVM_INTERCEPT_DR2_WRITE		(1UL << 18)
#define SVM_INTERCEPT_DR3_WRITE		(1UL << 19)
#define SVM_INTERCEPT_DR4_WRITE		(1UL << 20)
#define SVM_INTERCEPT_DR5_WRITE		(1UL << 21)
#define SVM_INTERCEPT_DR6_WRITE		(1UL << 22)
#define SVM_INTERCEPT_DR7_WRITE		(1UL << 23)
#define SVM_INTERCEPT_DR8_WRITE		(1UL << 24)
#define SVM_INTERCEPT_DR9_WRITE		(1UL << 25)
#define SVM_INTERCEPT_DR10_WRITE	(1UL << 26)
#define SVM_INTERCEPT_DR11_WRITE	(1UL << 27)
#define SVM_INTERCEPT_DR12_WRITE	(1UL << 28)
#define SVM_INTERCEPT_DR13_WRITE	(1UL << 29)
#define SVM_INTERCEPT_DR14_WRITE	(1UL << 30)
#define SVM_INTERCEPT_DR15_WRITE	(1UL << 31)
#define SVM_INTERCEPT_INTR		(1UL << 0)
#define SVM_INTERCEPT_NMI		(1UL << 1)
#define SVM_INTERCEPT_SMI		(1UL << 2)
#define SVM_INTERCEPT_INIT		(1UL << 3)
#define SVM_INTERCEPT_VINTR		(1UL << 4)
#define SVM_INTERCEPT_CR0_SEL_WRITE	(1UL << 5)
#define SVM_INTERCEPT_IDTR_READ		(1UL << 6)
#define SVM_INTERCEPT_GDTR_READ		(1UL << 7)
#define SVM_INTERCEPT_LDTR_READ		(1UL << 8)
#define SVM_INTERCEPT_TR_READ		(1UL << 9)
#define SVM_INTERCEPT_IDTR_WRITE	(1UL << 10)
#define SVM_INTERCEPT_GDTR_WRITE	(1UL << 11)
#define SVM_INTERCEPT_LDTR_WRITE	(1UL << 12)
#define SVM_INTERCEPT_TR_WRITE		(1UL << 13)
#define SVM_INTERCEPT_RDTSC		(1UL << 14)
#define SVM_INTERCEPT_RDPMC		(1UL << 15)
#define SVM_INTERCEPT_PUSHF		(1UL << 16)
#define SVM_INTERCEPT_POPF		(1UL << 17)
#define SVM_INTERCEPT_CPUID		(1UL << 18)
#define SVM_INTERCEPT_RSM		(1UL << 19)
#define SVM_INTERCEPT_IRET		(1UL << 20)
#define SVM_INTERCEPT_INTN		(1UL << 21)
#define SVM_INTERCEPT_INVD		(1UL << 22)
#define SVM_INTERCEPT_PAUSE		(1UL << 23)
#define SVM_INTERCEPT_HLT		(1UL << 24)
#define SVM_INTERCEPT_INVLPG		(1UL << 25)
#define SVM_INTERCEPT_INVLPGA		(1UL << 26)
#define SVM_INTERCEPT_INOUT		(1UL << 27)
#define SVM_INTERCEPT_MSR		(1UL << 28)
#define SVM_INTERCEPT_TASK_SWITCH	(1UL << 29)
#define SVM_INTERCEPT_FERR_FREEZE	(1UL << 30)
#define SVM_INTERCEPT_SHUTDOWN		(1UL << 31)
#define SVM_INTERCEPT_VMRUN		(1UL << 0)
#define SVM_INTERCEPT_VMMCALL		(1UL << 1)
#define SVM_INTERCEPT_VMLOAD		(1UL << 2)
#define SVM_INTERCEPT_VMSAVE		(1UL << 3)
#define SVM_INTERCEPT_STGI		(1UL << 4)
#define SVM_INTERCEPT_CLGI		(1UL << 5)
#define SVM_INTERCEPT_SKINIT		(1UL << 6)
#define SVM_INTERCEPT_RDTSCP		(1UL << 7)
#define SVM_INTERCEPT_ICEBP		(1UL << 8)
#define SVM_INTERCEPT_WBINVD		(1UL << 9)
#define SVM_INTERCEPT_MONITOR		(1UL << 10)
#define SVM_INTERCEPT_MWAIT_UNCOND	(1UL << 11)
#define SVM_INTERCEPT_MWAIT_COND	(1UL << 12)
#define SVM_INTERCEPT_XSETBV		(1UL << 13)
#define SVM_INTERCEPT_EFER_WRITE	(1UL << 15)
#define SVM_INTERCEPT_CR0_WRITE_POST	(1UL << 16)
#define SVM_INTERCEPT_CR1_WRITE_POST	(1UL << 17)
#define SVM_INTERCEPT_CR2_WRITE_POST	(1UL << 18)
#define SVM_INTERCEPT_CR3_WRITE_POST	(1UL << 19)
#define SVM_INTERCEPT_CR4_WRITE_POST	(1UL << 20)
#define SVM_INTERCEPT_CR5_WRITE_POST	(1UL << 21)
#define SVM_INTERCEPT_CR6_WRITE_POST	(1UL << 22)
#define SVM_INTERCEPT_CR7_WRITE_POST	(1UL << 23)
#define SVM_INTERCEPT_CR8_WRITE_POST	(1UL << 24)
#define SVM_INTERCEPT_CR9_WRITE_POST	(1UL << 25)
#define SVM_INTERCEPT_CR10_WRITE_POST	(1UL << 26)
#define SVM_INTERCEPT_CR11_WRITE_POST	(1UL << 27)
#define SVM_INTERCEPT_CR12_WRITE_POST	(1UL << 28)
#define SVM_INTERCEPT_CR13_WRITE_POST	(1UL << 29)
#define SVM_INTERCEPT_CR14_WRITE_POST	(1UL << 30)
#define SVM_INTERCEPT_CR15_WRITE_POST	(1UL << 31)

/*
 * PAT
 */
#define PATENTRY(n, type)       (type << ((n) * 8))
#define PAT_UC          0x0UL
#define PAT_WC          0x1UL
#define PAT_WT          0x4UL
#define PAT_WP          0x5UL
#define PAT_WB          0x6UL
#define PAT_UCMINUS     0x7UL

@


1.58
log
@remove some magic numbers in the flush-by-asid code and check if the CPU
supports that feature before we try to use it.

discussed with deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.57 2017/06/20 05:34:41 mlarkin Exp $	*/
a329 13
/*
 * for Core i Series and newer Xeons, see
 * http://www.intel.com/content/dam/www/public/us/en/
 * documents/white-papers/cpu-monitoring-dts-peci-paper.pdf
 */
#define MSR_TEMPERATURE_TARGET	0x1a2	/* Core i Series, Newer Xeons */
#define MSR_TEMPERATURE_TARGET_TJMAX(msr) (((msr) >> 16) & 0xff)
/*
 * not documented anywhere, see intelcore_update_sensor()
 * only available Core Duo and Core Solo Processors
 */
#define MSR_TEMPERATURE_TARGET_UNDOCUMENTED	0x0ee
#define MSR_TEMPERATURE_TARGET_LOW_BIT_UNDOCUMENTED	0x40000000
d357 13
@


1.57
log
@SVM: better cleanbits handling. Fixes an issue on Bulldozer CPUs causing
#TF exceptions during guest VM boot

ok brynet
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.56 2017/05/30 17:49:47 mlarkin Exp $	*/
d1181 5
@


1.56
log
@FPU context save/restore for SVM in vmm(4), matches a previous diff
from a few weeks ago that did the same for Intel/VMX.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.55 2017/03/28 21:36:27 mlarkin Exp $	*/
d1177 3
d1181 19
a1199 1
#define AMD_SVM_NESTED_PAGING_CAP	(1 << 0)
@


1.55
log
@add RDTSCP flags to identcpu.c

ok guenther, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.54 2017/01/24 09:02:33 mlarkin Exp $	*/
d1292 18
@


1.54
log
@SVM: missing msr defintion for host save area physaddr
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.53 2017/01/19 23:17:19 mlarkin Exp $	*/
d255 1
@


1.53
log
@SVM: VMCB intercept definitions
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.52 2017/01/13 17:15:27 mikeb Exp $	*/
d1174 1
@


1.52
log
@Disable and lock Silicon Debug feature on modern Intel CPUs

This implements one of the countermeasures against using Direct
Connect Interface (DCI) to debug CPUs via USB3 mentioned in the
"Tapping into the core" talk at the 33c3: identify and disable
the Silicon Debug feature found in Haswell and newer CPUs.

ok mlarkin, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.51 2016/10/06 07:37:51 mlarkin Exp $	*/
d1177 113
@


1.51
log
@
add a debug function that was useful in finding the previous
broadwell/skylake bug.
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.50 2016/09/30 07:33:06 mlarkin Exp $	*/
d839 6
@


1.50
log
@
Compute CR3 target count. Needed for upcoming debugging diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.49 2016/09/27 08:04:49 mlarkin Exp $	*/
d956 5
a960 1
/* VMX : VMCS Fields */
d962 4
d974 4
d985 4
d993 4
d998 2
d1001 13
d1015 2
d1018 1
d1020 9
d1031 3
d1036 4
d1046 3
d1050 4
d1057 3
d1061 3
d1082 20
d1103 7
d1123 1
d1127 5
d1136 1
d1140 2
@


1.49
log
@
read and cache VMFUNC capability during boot. for use in an upcoming diff
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.48 2016/09/10 17:15:44 mlarkin Exp $	*/
d1059 1
@


1.48
log
@Enable VMM debug and add a few new controls
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.47 2016/09/03 13:35:03 mlarkin Exp $	*/
d864 1
@


1.47
log
@
fix typo "mode" -> "model" when referring to "Model specific registers"
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.46 2016/09/03 12:12:43 mlarkin Exp $	*/
d923 3
d927 3
d941 2
d952 2
@


1.46
log
@
add SDBG to cpuid bits and identcpu
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.45 2016/07/16 06:20:24 mlarkin Exp $	*/
d120 1
a120 1
#define	CPUID_MSR	0x00000020	/* has mode specific registers */
@


1.45
log
@
Fix an incorrect shift value when calculating the mask for the VMCS MSR
list storage size. Noticed when attempting to get vmm(4) to nest under
Hyper-V.
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.44 2016/06/22 07:22:00 mlarkin Exp $	*/
d159 1
@


1.44
log
@
Identify UMIP feature, if available.

ok millert, kettenis, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.43 2016/04/26 15:57:09 mlarkin Exp $	*/
d1046 1
a1046 1
#define IA32_VMX_MSR_LIST_SIZE_MASK	(3ULL << 25)
@


1.43
log
@
Add decode functions for some of the MSRs that are commonly used. Only
compiled when VMM_DEBUG is enabled, and only used during VM crash.
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.42 2016/04/26 15:27:32 mlarkin Exp $	*/
d93 1
d214 1
@


1.42
log
@
Convert some magic numbers into #defines - this is needed for some MTRR
decoding code I'm working on for vmm(4) debugging. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.41 2016/04/25 17:50:21 mlarkin Exp $	*/
d311 1
d313 1
d843 2
@


1.41
log
@
cr0, cr3, cr4 diagnostics / debug functions (used when VMs crash)
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.40 2016/01/10 18:18:25 stefan Exp $	*/
d338 3
d357 1
d376 2
@


1.40
log
@Page fault handling tweaks for vmm:
- compute fault reason for uvm_fault() (e.g. page not present,
  protection violation) instead of passing a protection code
- a page does not need to be zero'd after faulting it in. uvm_fault() does
  that for fresh anon pages already, and we also do not want a page that
  is swapped back in have its contents wiped.

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.39 2015/12/07 06:34:14 jsg Exp $	*/
d73 6
d100 1
@


1.39
log
@Add cpuid bits documented in the August 2015 revision of
"Intel Architecture Instruction Set Extensions Programming Reference"
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.38 2015/11/13 07:52:20 mlarkin Exp $	*/
d1022 4
@


1.38
log
@
vmm(4) kernel code

circulated on hackers@@, no objections. Disabled by default.
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.37 2015/06/07 08:11:50 guenther Exp $	*/
d176 1
d185 4
d192 11
d205 1
@


1.37
log
@Add CR4_FSGSBASE
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.36 2015/05/28 20:10:58 guenther Exp $	*/
a174 1

d187 3
d291 1
d409 1
d804 223
@


1.36
log
@Save the cpuid(6) eax bits in the cpu_info and report the SENSOR and ARAT
bits from it.

ok krw@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.35 2015/04/19 19:45:21 sf Exp $	*/
d89 1
@


1.35
log
@Add support for x2apic mode

This is currently only enabled on hypervisors because on real hardware, it
requires interrupt remapping which we don't support yet. But on virtualization
it reduces the number of vmexits required per IPI from 4 to 1, causing a
significant speed-up for MP guests.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.34 2015/03/25 20:59:30 kettenis Exp $	*/
d187 6
@


1.34
log
@Mark CPUID_LEAF inline asm as volatile to prevent the compiler from reordering
it with respect to other instructions.

ok gunether@@, mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.33 2015/03/21 20:42:38 kettenis Exp $	*/
d278 1
@


1.33
log
@Add support for saving/restoring FPU state using the XSAVE/XRSTOR.  Limit
support to the X87, SSE and AVX state.

This gives us (almost) full AVX support.  The AVX state isn't saved by
signal handlers yet, and ptrace(2) support is still missing.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.32 2015/01/19 16:01:43 jsg Exp $	*/
d259 1
a259 1
	__asm("cpuid"                                           \
d263 1
a263 1
	__asm("cpuid"                                           \
@


1.32
log
@Make use of an msr available on recent Intel processors to obtain the
maximum supported temperature, Tj(Max).  As the temperature values are
relative to this value this should make the sensor values more accurate.

From Simon Mages.
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.31 2014/12/22 22:33:51 mlarkin Exp $	*/
d93 7
@


1.31
log
@
Clean up some weird spacing. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.30 2014/12/16 21:02:58 sf Exp $	*/
d282 13
a294 3
/* not documented anywhere, see intelcore_update_sensor() */
#define MSR_TEMPERATURE_TARGET	0x0ee
#define MSR_TEMPERATURE_TARGET_LOW_BIT	0x40000000
@


1.30
log
@Define and print HV cpuid flag.

This is set by many hypervisors, including kvm, vmware, hyper-v.
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.29 2014/11/30 18:29:11 mlarkin Exp $	*/
d376 15
a390 15
#define MSR_EFER	0xc0000080		/* Extended feature enable */
#define 	EFER_SCE		0x00000001	/* SYSCALL extension */
#define 	EFER_LME		0x00000100	/* Long Mode Enabled */
#define		EFER_LMA		0x00000400	/* Long Mode Active */
#define 	EFER_NXE		0x00000800	/* No-Execute Enabled */

#define MSR_STAR	0xc0000081		/* 32 bit syscall gate addr */
#define MSR_LSTAR	0xc0000082		/* 64 bit syscall gate addr */
#define MSR_CSTAR	0xc0000083		/* compat syscall gate addr */
#define MSR_SFMASK	0xc0000084		/* flags to clear on syscall */

#define MSR_FSBASE	0xc0000100		/* 64bit offset for fs: */
#define MSR_GSBASE	0xc0000101		/* 64bit offset for gs: */
#define MSR_KERNELGSBASE 0xc0000102		/* storage for swapgs ins */
#define MSR_INT_PEN_MSG	0xc0010055		/* Interrupt pending message */
d392 2
a393 2
#define MSR_DE_CFG	0xc0011029		/* Decode Configuration */
#define		DE_CFG_721		0x00000001	/* errata 721 */
@


1.29
log
@
Mask out EFER_LMA when restoring saved EFER on zzz/ZZZ resume as it's a
read only bit.

Also fix some comments describing EFER bits that were obviously wrong.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.28 2014/07/03 21:15:28 matthew Exp $	*/
d161 1
@


1.28
log
@Add identcpu detection for 1-GByte pages

ok mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.27 2013/08/24 04:26:16 mlarkin Exp $	*/
d377 2
a378 2
#define 	EFER_LME		0x00000100	/* Long Mode Active */
#define		EFER_LMA		0x00000400	/* Long Mode Enabled */
@


1.27
log
@

Cleanup amd64 and i386 MTRR code -

1. Makes amd64 and i386 MTRR code nearly identical
2. Removes support for per-process MTRRs (which were never implemented)
3. Treat "unknown" MTRR types as uncacheable instead of trying to preserve
bogus settings made by the BIOS
4. Various KNF cleanups

Should be no functional change.

ok jsg@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.26 2013/06/02 16:34:15 guenther Exp $	*/
d210 1
@


1.26
log
@fix tpyo
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.25 2013/05/06 04:32:12 dlg Exp $	*/
d312 1
a312 16
#define	MSR_MTRRphysBase0	0x200
#define	MSR_MTRRphysMask0	0x201
#define	MSR_MTRRphysBase1	0x202
#define	MSR_MTRRphysMask1	0x203
#define	MSR_MTRRphysBase2	0x204
#define	MSR_MTRRphysMask2	0x205
#define	MSR_MTRRphysBase3	0x206
#define	MSR_MTRRphysMask3	0x207
#define	MSR_MTRRphysBase4	0x208
#define	MSR_MTRRphysMask4	0x209
#define	MSR_MTRRphysBase5	0x20a
#define	MSR_MTRRphysMask5	0x20b
#define	MSR_MTRRphysBase6	0x20c
#define	MSR_MTRRphysMask6	0x20d
#define	MSR_MTRRphysBase7	0x20e
#define	MSR_MTRRphysMask7	0x20f
a314 1
#define	MSR_MTRRfix16K_A0000	0x259
a315 7
#define	MSR_MTRRfix4K_C8000	0x269
#define	MSR_MTRRfix4K_D0000	0x26a
#define	MSR_MTRRfix4K_D8000	0x26b
#define	MSR_MTRRfix4K_E0000	0x26c
#define	MSR_MTRRfix4K_E8000	0x26d
#define	MSR_MTRRfix4K_F0000	0x26e
#define	MSR_MTRRfix4K_F8000	0x26f
d321 8
a328 8
#define  MSR_PERF_FIXED_CTR_FC_DIS	0x0 /* disable counter */
#define  MSR_PERF_FIXED_CTR_FC_1	0x1 /* count ring 1 */
#define  MSR_PERF_FIXED_CTR_FC_123	0x2 /* count rings 1,2,3 */
#define  MSR_PERF_FIXED_CTR_FC_ANY	0x3 /* count everything */
#define  MSR_PERF_FIXED_CTR_FC_MASK	0x3
#define  MSR_PERF_FIXED_CTR_FC(_i, _v)	((_v) << (4 * (_i)))
#define  MSR_PERF_FIXED_CTR_ANYTHR(_i)	(0x4 << (4 * (_i)))
#define  MSR_PERF_FIXED_CTR_INT(_i)	(0x8 << (4 * (_i)))
@


1.25
log
@the use of modern intel performance counter msrs to measure the number of
cycles per second isnt reliable, particularly inside "virtual" machines.
cpuspeed can be calculated as 0, which causes a divide by zero later on
which is bad.

this goes to more effort to detect if the performance counters are in use
by the hypervisor, or detecting if they gave us a cpuspeed of 0 so we can
fall through to using rdtsc.

the same change as:
src/sys/arch/i386/include/specialreg.h r.45
src/sys/arch/i386/isa/clock.c 1.49

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.24 2012/11/10 09:45:05 mglocker Exp $	*/
d493 1
a493 1
 * The descriptions of these events are too lenghy to include here.
@


1.24
log
@Recent x86 CPUs come with a constant time stamp counter.  If this is
the case we verify if the CPU supports a specific version of the
architectural performance monitoring feature and read out the current
frequency from the fixed-function performance counter of the unhalted
core.

My initial motivation to implement this was the Soekris net6501-70
which comes with an Intel Atom E6xx 1.60GHz CPU.  It has a constant
time stamp counter plus speed step support and boots on the lowest
frequency of 600MHz.  This caused hw.cpuspeed and hw.setperf to
reflect the wrong values.

The diff is a cooperation work with jsg@@.  The fixed-function
performance counter read code comes from a former diff of him.

OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.23 2012/10/09 09:16:09 jsg Exp $	*/
d343 9
a351 3
#define MSR_PERF_FIXED_CTR_CTRL	0x38d
#define MSR_PERF_FIXED_CTR1_EN	(1 << 4)
#define MSR_PERF_FIXED_CTR2_EN	(1 << 8)
@


1.23
log
@Sync "Structured Extended Feature Flags" cpuid bits with
the August 2012 revision of
"Intel Architecture Instruction Set Extensions Programming Reference".

Correct definitions of EREP and INVPCID, rename EREP to ERMS to
match Intel's docs.  Add some more Haswell feature bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.22 2012/08/24 02:49:23 guenther Exp $	*/
d180 21
d238 7
d341 8
@


1.22
log
@Synchronize CR4 and CPUID portions of <machine/specialreg.h> for i386 and amd64
Add display of more feature bits: DTES64 PCID DEADLINE F16C RDRAND
Add display of "Structured Extended Feature Flags Parameters":
    FSGSBASE SMEP EREP INVPCID

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.21 2012/03/27 05:59:46 jsg Exp $	*/
d92 1
d168 3
d172 7
a178 2
#define	SEFF0EBX_EREP		0x00000100 /* Enhanced REP MOVSB/STOSB */
#define	SEFF0EBX_INVPCID	0x00000200 /* INVPCID instruction */
@


1.21
log
@Implement the AMD suggested workaround for family 10h & 12h errata 721
"Processor May Incorrectly Update Stack Pointer" by setting a bit
marked 'reserved' in an MSR that is only "documented" to exist on 12h.

AMD claim this problem can only occur in 64-bit mode, set the workaround
bit on i386 in case this isn't true and in the interest of keeping the
errata in sync between i386/amd64.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.20 2011/12/26 23:07:04 haesbaert Exp $	*/
d76 16
a91 11
#define CR4_VME	0x00000001	/* virtual 8086 mode extension enable */
#define CR4_PVI 0x00000002	/* protected mode virtual interrupt enable */
#define CR4_TSD 0x00000004	/* restrict RDTSC instruction to cpl 0 only */
#define CR4_DE	0x00000008	/* debugging extension */
#define CR4_PSE	0x00000010	/* large (4MB) page size enable */
#define CR4_PAE 0x00000020	/* physical address extension enable */
#define CR4_MCE	0x00000040	/* machine check enable */
#define CR4_PGE	0x00000080	/* page global enable */
#define CR4_PCE	0x00000100	/* enable RDPMC instruction for all cpls */
#define CR4_OSFXSR	0x00000200	/* enable fxsave/fxrestor and SSE */
#define CR4_OSXMMEXCPT	0x00000400	/* enable unmasked SSE exceptions */
d94 2
a95 1
 * CPUID "features" bits:
d101 1
a101 1
#define	CPUID_PSE	0x00000008	/* has page 4MB page size extension */
d108 2
a109 2
#define	CPUID_B10	0x00000400	/* reserved, MTRR */
#define	CPUID_SEP	0x00000800	/* has SYSENTER/SYSEXIT extension */
d114 3
a116 3
#define	CPUID_PAT	0x00010000	/* Page Attribute Table */
#define	CPUID_PSE36	0x00020000	/* 36-bit PSE */
#define	CPUID_PN	0x00040000	/* processor serial number */
d121 4
a124 4
#define	CPUID_MMX	0x00800000	/* MMX supported */
#define	CPUID_FXSR	0x01000000	/* FP/MMX save/restore */
#define	CPUID_SSE	0x02000000	/* streaming SIMD extensions */
#define	CPUID_SSE2	0x04000000	/* streaming SIMD extensions #2 */
d129 1
a129 1
#define	CPUID_SBF	0x80000000	/* signal break on FERR */
d132 38
a169 47
#define CPUIDECX_PCLMUL	0x00000002	/* Carryless Multiplication */
#define CPUIDECX_MWAIT	0x00000008	/* Monitor/Mwait */
#define CPUIDECX_DSCPL	0x00000010	/* CPL Qualified Debug Store */
#define CPUIDECX_VMX	0x00000020	/* Virtual Machine Extensions */
#define CPUIDECX_SMX	0x00000040	/* Safer Mode Extensions */
#define CPUIDECX_EST	0x00000080	/* enhanced SpeedStep */
#define CPUIDECX_TM2	0x00000100	/* thermal monitor 2 */
#define CPUIDECX_SSSE3	0x00000200	/* Supplemental Streaming SIMD Ext. 3 */
#define CPUIDECX_CNXTID	0x00000400	/* Context ID */
#define CPUIDECX_FMA3	0x00001000	/* Fused Multiply Add */
#define CPUIDECX_CX16	0x00002000	/* has CMPXCHG16B instruction */
#define CPUIDECX_XTPR	0x00004000	/* xTPR Update Control */
#define CPUIDECX_PDCM	0x00008000	/* Perfmon and Debug Capability */
#define CPUIDECX_DCA	0x00040000	/* Direct Cache Access */
#define CPUIDECX_SSE41	0x00080000	/* Streaming SIMD Extensions 4.1 */
#define CPUIDECX_SSE42	0x00100000	/* Streaming SIMD Extensions 4.2 */
#define CPUIDECX_X2APIC	0x00200000	/* Extended xAPIC Support */
#define CPUIDECX_MOVBE	0x00400000	/* MOVBE Instruction */
#define CPUIDECX_POPCNT	0x00800000	/* POPCNT Instruction */
#define CPUIDECX_AES	0x02000000	/* AES Instruction */
#define CPUIDECX_XSAVE	0x04000000	/* XSAVE/XSTOR States */
#define CPUIDECX_OSXSAVE	0x08000000	/* OSXSAVE */
#define CPUIDECX_AVX	0x10000000	/* Advanced Vector Extensions */

#define CPUIDECX_LAHF		0x00000001 /* LAHF and SAHF instructions */
#define CPUIDECX_CMPLEG		0x00000002 /* Core MP legacy mode */
#define CPUIDECX_SVM		0x00000004 /* Secure Virtual Machine */
#define CPUIDECX_EAPICSP	0x00000008 /* Extended APIC space */
#define CPUIDECX_AMCR8		0x00000010 /* LOCK MOV CR0 means MOV CR8 */
#define CPUIDECX_ABM		0x00000020 /* LZCNT instruction */
#define CPUIDECX_SSE4A		0x00000040 /* SSE4-A instruction set */
#define CPUIDECX_MASSE		0x00000080 /* Misaligned SSE mode */
#define CPUIDECX_3DNOWP		0x00000100 /* 3DNowPrefetch */
#define CPUIDECX_OSVW		0x00000200 /* OS visible workaround */
#define CPUIDECX_IBS		0x00000400 /* Instruction based sampling */
#define CPUIDECX_XOP		0x00000800 /* Extended operating support */
#define CPUIDECX_SKINIT		0x00001000 /* SKINIT and STGI are supported */
#define CPUIDECX_WDT		0x00002000 /* Watchdog timer */
/* Reserved			0x00004000 */
#define CPUIDECX_LWP		0x00008000 /* Lightweight profiling support */
#define CPUIDECX_FMA4		0x00010000 /* 4-operand FMA instructions */
/* Reserved			0x00020000 */
/* Reserved			0x00040000 */
#define CPUIDECX_NODEID		0x00080000 /* Support for MSRC001C */
/* Reserved			0x00100000 */
#define CPUIDECX_TBM		0x00200000 /* Trailing bit manipulation instruction */
#define CPUIDECX_TOPEXT		0x00400000 /* Topology extensions support */
d172 2
a173 1
 * AMD/VIA processor specific flags.
d176 1
a176 1
#define CPUID_MPC	0x00080000	/* Multiprocessing Capable */
d178 1
a178 1
#define CPUID_MMXX	0x00400000	/* AMD MMX Extensions */
d180 31
a210 7
#define CPUID_LONG	0x20000000	/* long mode */
#define CPUID_3DNOW2	0x40000000	/* 3DNow! Instruction Extension */
#define CPUID_3DNOW	0x80000000	/* 3DNow! Instructions */

#define CPUID2FAMILY(cpuid)	(((cpuid) >> 8) & 15)
#define CPUID2MODEL(cpuid)	(((cpuid) >> 4) & 15)
#define CPUID2STEPPING(cpuid)	((cpuid) & 15)
d212 1
a212 1
#define CPUID(code, eax, ebx, ecx, edx)                         \
d216 4
@


1.20
log
@Add the missing ECX cpu flags from CPUID at 0x80000001.
This is all documented at:

http://support.amd.com/us/Embedded_TechDocs/25481.pdf (page 20)
http://www.intel.com/assets/pdf/appnote/241618.pdf (page 41)

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.19 2010/04/29 17:00:48 oga Exp $	*/
d335 3
@


1.19
log
@Add the CR_PAT MSR to the list of defined msrs.

"Absolutely, don't forget i386" kettenis@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.18 2010/03/21 23:00:57 jsg Exp $	*/
d149 24
@


1.18
log
@Add some additional Intel CPUID values for recent and upcoming processors.
With some additions from sthen@@

ok kettenis@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.17 2009/10/07 02:15:48 kevlo Exp $	*/
d252 1
@


1.17
log
@add support for the temperature sensor of VIA Nano and C7-M CPUs.
some improvements suggested by jsg@@

"commit" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.16 2009/09/20 21:58:31 jsg Exp $	*/
d126 1
d133 1
d135 1
d138 11
@


1.16
log
@Back out via nano temperature sensor changes.
They break ramdisks as noticed by jasper, and have not been
adequately discussed.
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.15 2009/09/20 15:37:23 kevlo Exp $	*/
d259 3
@


1.15
log
@add support for VIA Nano cpu core temperature sensor

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.14 2009/05/31 03:20:10 matthieu Exp $	*/
a258 3

/* VIA MSR */
#define MSR_CENT_TMTEMPERATURE	0x1423	/* Thermal monitor temperature */
@


1.14
log
@Add VIA crypto features support to amd64. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.13 2008/08/13 15:44:44 art Exp $	*/
d259 3
@


1.13
log
@Disable the fantastics mis-feature on some newer Turion CPUs called C1E.
This "power saving" disables the apic when both cpu cores hit the hlt
instruction which kills our timer.

From FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.12 2008/06/13 00:00:45 jsg Exp $	*/
d641 33
@


1.12
log
@Detect if Intel's Safer Mode Extensions (SMX) are present,
See http://download.intel.com/technology/security/downloads/31516804.pdf
for more information.

ok deraadt@@ 'looks ok to me' djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.11 2007/06/01 22:28:21 tedu Exp $	*/
d292 4
@


1.11
log
@some pentium 4 machines are 64-bit and have EST, but a different msr to
get bus clock.  copy in some more code from i386 to deal with both families,
and be more watchful for unknown models.
fixes a panic reported by johan lindman.  ok gwk
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.10 2007/05/29 06:40:15 tedu Exp $	*/
d129 1
@


1.10
log
@put the temperature msr in line with the others
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.9 2007/05/29 06:31:44 tedu Exp $	*/
d168 1
@


1.9
log
@Some improvements for better intel cpu support.
Add EST support from i386, minus the tables
Also add in support for CPU temperature sensors, based on diff to tech
by Pierre Riteau.
ok deraadt gwk
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.8 2007/04/27 01:57:16 dlg Exp $	*/
d177 3
a634 4

/* not documented anywhere, see intelcore_update_sensor() */
#define MSR_TEMPERATURE_TARGET		0xee
#define MSR_TEMPERATURE_TARGET_LOW_BIT		0x40000000
@


1.8
log
@remove duplicate defines.

found by lint, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.7 2007/02/17 17:35:43 tom Exp $	*/
d176 1
d192 8
d632 4
@


1.7
log
@Add code to check for the AMD amd64 errata, and correct them where
possible.  Taken from NetBSD.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.6 2007/02/13 00:20:59 jsg Exp $	*/
a622 21

/*
 * Extended Feature Enable Register of the x86-64
 */

#define MSR_EFER	0xc0000080

#define EFER_SCE	0x00000001	/* SYSCALL extension */
#define EFER_LME	0x00000100	/* Long Mode Enabled */
#define EFER_LMA	0x00000400	/* Long Mode Active */
#define EFER_NXE	0x00000800	/* No-Execute Enable */
#define EFER_FFXSR	0x00004000	/* Fast FXSAVE/FXRSTOR */

#define MSR_STAR	0xc0000081		/* 32 bit syscall gate addr */
#define MSR_LSTAR	0xc0000082		/* 64 bit syscall gate addr */
#define MSR_CSTAR	0xc0000083		/* compat syscall gate addr */
#define MSR_SFMASK	0xc0000084		/* flags to clear on syscall */

#define MSR_FSBASE		0xc0000100	/* 64bit offset for fs: */
#define MSR_GSBASE		0xc0000101	/* 64bit offset for gs: */
#define MSR_KERNELGSBASE	0xc0000102	/* storage for swapgs ins */
@


1.6
log
@Check for some CPUID flags found on newer Intel processors.
ok tom@@ gwk@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.5 2006/03/07 05:21:40 jsg Exp $	*/
d258 45
@


1.5
log
@It does not make sense to check for IA64 CPUID flag here.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.4 2005/12/13 00:18:19 jsg Exp $	*/
d126 8
@


1.4
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.
Checked by ian@@, deraadt@@ and millert@@, arm portion checked by drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.3 2005/08/20 00:33:59 jsg Exp $	*/
d122 1
a122 1
#define	CPUID_IA64	0x40000000	/* IA-64 architecture */
@


1.3
log
@Check for and report the presense of SSE3.  This has started to appear
in AMD products with the arrival of the venice core.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.2 2004/02/09 22:15:52 mickey Exp $	*/
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.2
log
@repair cpu dmesg print a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: specialreg.h,v 1.1 2004/01/28 01:39:39 mickey Exp $	*/
d128 2
@


1.2.2.1
log
@The merge of these files were done to another date than the rest, fix.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d120 1
a120 1
#define	CPUID_FXSR	0x01000000	/* fast FP/MMX save/restore */
a128 9
#define CPUID_FLAGS1	"\20\1FPU\2VME\3DE\4PSE\5TSC\6MSR\7PAE" \
			    "\10MCE\11CX8\12APIC\13B10\14SEP\15MTRR"
#define CPUID_MASK1	0x00001fff
#define CPUID_FLAGS2	"\20\16PGE\17MCA\20CMOV\21PAT\22PSE36\23PN\24CFLUSH" \
			    "\25B20\26DS\27ACPI\30MMX"
#define CPUID_MASK2	0x00ffe000
#define CPUID_FLAGS3	"\20\31FXSR\32SSE\33SSE2\34SS\35HTT\36TM\37IA64\40SBF"
#define CPUID_MASK3	0xff000000

d136 2
a139 5

#define CPUID_EXT_FLAGS2	"\20\16PGE\17MCA\20CMOV\21PAT\22PSE36\23PN" \
				    "\24MPC\25NXE\26B21\27MMXX\30MMX"
#define CPUID_EXT_FLAGS3	"\20\31FXSR\32SSE\33SSE2\34B27\35B28\36LONG" \
				    "\0373DNOW2\0403DNOW"
@


1.2.2.2
log
@Merge with the trunk
@
text
@d120 1
a120 1
#define	CPUID_FXSR	0x01000000	/* FP/MMX save/restore */
d129 9
a144 2
#define	CPUID_FFXSR	0x02000000	/* fast FP/MMX save/restore */
#define CPUID_LONG	0x20000000	/* long mode */
d147 5
@


1.1
log
@an amd64 arch support.
hacked by art@@ from netbsd sources and then later debugged
by me into the shape where it can host itself.
no bootloader yet as needs redoing from the
recent advanced i386 sources (anyone? ;)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d120 1
a120 1
#define	CPUID_FXSR	0x01000000	/* fast FP/MMX save/restore */
a128 9
#define CPUID_FLAGS1	"\20\1FPU\2VME\3DE\4PSE\5TSC\6MSR\7PAE" \
			    "\10MCE\11CX8\12APIC\13B10\14SEP\15MTRR"
#define CPUID_MASK1	0x00001fff
#define CPUID_FLAGS2	"\20\16PGE\17MCA\20CMOV\21PAT\22PSE36\23PN\24CFLUSH" \
			    "\25B20\26DS\27ACPI\30MMX"
#define CPUID_MASK2	0x00ffe000
#define CPUID_FLAGS3	"\20\31FXSR\32SSE\33SSE2\34SS\35HTT\36TM\37IA64\40SBF"
#define CPUID_MASK3	0xff000000

d136 2
a139 5

#define CPUID_EXT_FLAGS2	"\20\16PGE\17MCA\20CMOV\21PAT\22PSE36\23PN" \
				    "\24MPC\25NXE\26B21\27MMXX\30MMX"
#define CPUID_EXT_FLAGS3	"\20\31FXSR\32SSE\33SSE2\34B27\35B28\36LONG" \
				    "\0373DNOW2\0403DNOW"
@

