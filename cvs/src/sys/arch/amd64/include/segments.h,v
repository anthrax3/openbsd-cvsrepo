head	1.14;
access;
symbols
	OPENBSD_6_2_BASE:1.14
	OPENBSD_6_1:1.14.0.8
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.4
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.12.0.4
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.10.0.12
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.16
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.14
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.10
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.8
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.6
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.4
	OPENBSD_5_0:1.10.0.2
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.5.0.10
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.6
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.8
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.4
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.2
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.4.0.10
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.8
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.6
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.2
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.4
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.3.0.6
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.4
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	SMP_SYNC_A:1.2
	SMP_SYNC_B:1.2
	OPENBSD_3_5:1.2.0.4
	OPENBSD_3_5_BASE:1.2
	SMP:1.2.0.2;
locks; strict;
comment	@ * @;


1.14
date	2015.09.30.05.44.32;	author guenther;	state Exp;
branches;
next	1.13;
commitid	WAoqMylmMWBeRMoU;

1.13
date	2015.09.26.15.59.25;	author guenther;	state Exp;
branches;
next	1.12;
commitid	2mXRxCfxfEZWsvHv;

1.12
date	2015.06.28.02.42.13;	author guenther;	state Exp;
branches;
next	1.11;
commitid	wrm7X1cxP0pviCpi;

1.11
date	2015.05.24.01.01.49;	author guenther;	state Exp;
branches;
next	1.10;
commitid	ZeKgaxXwOerLHwE3;

1.10
date	2011.03.23.16.54.34;	author pirofti;	state Exp;
branches;
next	1.9;

1.9
date	2010.11.20.20.11.17;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2010.11.13.04.16.42;	author guenther;	state Exp;
branches;
next	1.7;

1.7
date	2010.10.26.05.49.10;	author guenther;	state Exp;
branches;
next	1.6;

1.6
date	2010.10.14.04.38.24;	author guenther;	state Exp;
branches;
next	1.5;

1.5
date	2008.05.23.15.39.43;	author jasper;	state Exp;
branches;
next	1.4;

1.4
date	2005.12.13.00.18.19;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.15.17.46.44;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.01.29.13.21.10;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.28.01.39.39;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.14
log
@How about I delete _all_ the BITFIELDTYPE comments?
@
text
@/*	$OpenBSD: segments.h,v 1.13 2015/09/26 15:59:25 guenther Exp $	*/
/*	$NetBSD: segments.h,v 1.1 2003/04/26 18:39:47 fvdl Exp $	*/

/*-
 * Copyright (c) 1995, 1997
 *	Charles M. Hannum.  All rights reserved.
 * Copyright (c) 1989, 1990 William F. Jolitz
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * William Jolitz.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)segments.h	7.1 (Berkeley) 5/9/91
 */

/*
 * Adapted for NetBSD/amd64 by fvdl@@wasabisystems.com.
 */

/*
 * 386 Segmentation Data Structures and definitions
 *	William F. Jolitz (william@@ernie.berkeley.edu) 6/20/1989
 */

#ifndef _MACHINE_SEGMENTS_H_
#define _MACHINE_SEGMENTS_H_

/*
 * Selectors
 */

#define	ISPL(s)		((s) & SEL_RPL)	/* what is the priority level of a selector */
#define	SEL_KPL		0		/* kernel privilege level */	
#define	SEL_UPL		3		/* user privilege level */	
#define	SEL_RPL		3		/* requester's privilege level mask */
#define	ISLDT(s)	((s) & SEL_LDT)	/* is it local or global */
#define	SEL_LDT		4		/* local descriptor table */	

#define SYSSEL_START	(NGDT_MEM << 3)
#define GDT_SIZE	(SYSSEL_START + (NGDT_SYS << 4))

/*
 * These define the index not from the start of the GDT, but from
 * the part of the GDT that they're allocated from.
 * First NGDT_MEM entries are 8-byte descriptors for CS and DS.
 * Next NGDT_SYS entries are 16-byte descriptors defining TSSs.
 */

#define	IDXSEL(s)	(((s) >> 3) & 0x1fff)
#define IDXDYNSEL(s)	((((s) & ~SEL_RPL) - DYNSEL_START) >> 4)

#define	GSEL(s,r)	(((s) << 3) | r)
#define	GSYSSEL(s,r)	((((s) << 4) + SYSSEL_START) | r)
#define GDYNSEL(s,r)	((((s) << 4) + DYNSEL_START) | r | SEL_KPL)

#define LSEL(s,r)	((s) | r | SEL_LDT)

#define	USERMODE(c, f)		(ISPL(c) == SEL_UPL)
#define	KERNELMODE(c, f)	(ISPL(c) == SEL_KPL)

#ifndef _LOCORE

/*
 * Memory and System segment descriptors
 */

/*
 * Below is used for TSS and LDT.
 */
struct sys_segment_descriptor {
	u_int64_t sd_lolimit:16;	/* segment extent (lsb) */
	u_int64_t sd_lobase:24;		/* segment base address (lsb) */
	u_int64_t sd_type:5;		/* segment type */
	u_int64_t sd_dpl:2;		/* segment descriptor priority level */
	u_int64_t sd_p:1;		/* segment descriptor present */
	u_int64_t sd_hilimit:4;		/* segment extent (msb) */
	u_int64_t sd_xx1:3;		/* avl, long and def32 (not used) */
	u_int64_t sd_gran:1;		/* limit granularity (byte/page) */
	u_int64_t sd_hibase:40;		/* segment base address (msb) */
	u_int64_t sd_xx2:8;		/* reserved */
	u_int64_t sd_zero:5;		/* must be zero */
	u_int64_t sd_xx3:19;		/* reserved */
} __packed;

/*
 * Below is used for cs, ds, etc.
 */
struct mem_segment_descriptor {
	unsigned int sd_lolimit:16;         /* segment extent (lsb) */
	unsigned int sd_lobase:24;          /* segment base address (lsb) */
	unsigned int sd_type:5;             /* segment type */
	unsigned int sd_dpl:2;              /* segment descriptor priority level */
	unsigned int sd_p:1;                /* segment descriptor present */
	unsigned int sd_hilimit:4;          /* segment extent (msb) */
	unsigned int sd_avl:1;		/* available */
	unsigned int sd_long:1;		/* long mode */
	unsigned int sd_def32:1;            /* default 32 vs 16 bit size */
	unsigned int sd_gran:1;             /* limit granularity (byte/page) */
	unsigned int sd_hibase:8;           /* segment base address (msb) */
} __packed;

/*
 * Gate descriptors (e.g. indirect descriptors)
 */
struct gate_descriptor {
	u_int64_t gd_looffset:16;	/* gate offset (lsb) */
	u_int64_t gd_selector:16;	/* gate segment selector */
	u_int64_t gd_ist:3;		/* IST select */
	u_int64_t gd_xx1:5;		/* reserved */
	u_int64_t gd_type:5;		/* segment type */
	u_int64_t gd_dpl:2;		/* segment descriptor priority level */
	u_int64_t gd_p:1;		/* segment descriptor present */
	u_int64_t gd_hioffset:48;	/* gate offset (msb) */
	u_int64_t gd_xx2:8;		/* reserved */
	u_int64_t gd_zero:5;		/* must be zero */
	u_int64_t gd_xx3:19;		/* reserved */
} __packed;

/*
 * region descriptors, used to load gdt/idt tables before segments yet exist.
 */
struct region_descriptor {
	u_int16_t rd_limit;		/* segment extent */
	u_int64_t rd_base;		/* base address  */
} __packed;

#ifdef _KERNEL
extern struct gate_descriptor *idt;

void setgate(struct gate_descriptor *, void *, int, int, int, int);
void unsetgate(struct gate_descriptor *);
void setregion(struct region_descriptor *, void *, u_int16_t);
void set_sys_segment(struct sys_segment_descriptor *, void *, size_t,
			  int, int, int);
void set_mem_segment(struct mem_segment_descriptor *, void *, size_t,
			  int, int, int, int, int);
int idt_vec_alloc(int, int);
void idt_vec_set(int, void (*)(void));
void idt_vec_free(int);
void cpu_init_idt(void);

#endif /* _KERNEL */

#endif /* !_LOCORE */

/* system segments and gate types */
#define	SDT_SYSNULL	 0	/* system null */
#define	SDT_SYS286TSS	 1	/* system 286 TSS available */
#define	SDT_SYSLDT	 2	/* system local descriptor table */
#define	SDT_SYS286BSY	 3	/* system 286 TSS busy */
#define	SDT_SYS286CGT	 4	/* system 286 call gate */
#define	SDT_SYSTASKGT	 5	/* system task gate */
#define	SDT_SYS286IGT	 6	/* system 286 interrupt gate */
#define	SDT_SYS286TGT	 7	/* system 286 trap gate */
#define	SDT_SYSNULL2	 8	/* system null again */
#define	SDT_SYS386TSS	 9	/* system 386 TSS available */
#define	SDT_SYSNULL3	10	/* system null again */
#define	SDT_SYS386BSY	11	/* system 386 TSS busy */
#define	SDT_SYS386CGT	12	/* system 386 call gate */
#define	SDT_SYSNULL4	13	/* system null again */
#define	SDT_SYS386IGT	14	/* system 386 interrupt gate */
#define	SDT_SYS386TGT	15	/* system 386 trap gate */

/* memory segment types */
#define	SDT_MEMRO	16	/* memory read only */
#define	SDT_MEMROA	17	/* memory read only accessed */
#define	SDT_MEMRW	18	/* memory read write */
#define	SDT_MEMRWA	19	/* memory read write accessed */
#define	SDT_MEMROD	20	/* memory read only expand dwn limit */
#define	SDT_MEMRODA	21	/* memory read only expand dwn limit accessed */
#define	SDT_MEMRWD	22	/* memory read write expand dwn limit */
#define	SDT_MEMRWDA	23	/* memory read write expand dwn limit acessed */
#define	SDT_MEME	24	/* memory execute only */
#define	SDT_MEMEA	25	/* memory execute only accessed */
#define	SDT_MEMER	26	/* memory execute read */
#define	SDT_MEMERA	27	/* memory execute read accessed */
#define	SDT_MEMEC	28	/* memory execute only conforming */
#define	SDT_MEMEAC	29	/* memory execute only accessed conforming */
#define	SDT_MEMERC	30	/* memory execute read conforming */
#define	SDT_MEMERAC	31	/* memory execute read accessed conforming */

/* is memory segment descriptor pointer ? */
#define ISMEMSDP(s)	((s->d_type) >= SDT_MEMRO && \
			 (s->d_type) <= SDT_MEMERAC)

/* is 286 gate descriptor pointer ? */
#define IS286GDP(s)	((s->d_type) >= SDT_SYS286CGT && \
			 (s->d_type) < SDT_SYS286TGT)

/* is 386 gate descriptor pointer ? */
#define IS386GDP(s)	((s->d_type) >= SDT_SYS386CGT && \
			 (s->d_type) < SDT_SYS386TGT)

/* is gate descriptor pointer ? */
#define ISGDP(s)	(IS286GDP(s) || IS386GDP(s))

/* is segment descriptor pointer ? */
#define ISSDP(s)	(ISMEMSDP(s) || !ISGDP(s))

/* is system segment descriptor pointer ? */
#define ISSYSSDP(s)	(!ISMEMSDP(s) && !ISGDP(s))

/*
 * Segment Protection Exception code bits
 */
#define	SEGEX_EXT	0x01	/* recursive or externally induced */
#define	SEGEX_IDT	0x02	/* interrupt descriptor table */
#define	SEGEX_TI	0x04	/* local descriptor table */

/*
 * Entries in the Interrupt Descriptor Table (IDT)
 */
#define	NIDT	256
#define	NRSVIDT	32		/* reserved entries for cpu exceptions */

/*
 * Entries in the Global Descriptor Table (GDT)
 * The code and data descriptors must come first. There
 * are NGDT_MEM of them.
 *
 * Then comes the predefined TSS descriptor.
 * There are NGDT_SYS of them.
 *
 * The particular order of the UCODE32, UDATA, and UCODE descriptors is 
 * required by the syscall/sysret instructions.
 */
#define	GNULL_SEL	0	/* Null descriptor */
#define	GCODE_SEL	1	/* Kernel code descriptor */
#define	GDATA_SEL	2	/* Kernel data descriptor */
#define	GUCODE32_SEL	3	/* User 32bit code descriptor (unused) */
#define	GUDATA_SEL	4	/* User data descriptor */
#define	GUCODE_SEL	5	/* User code descriptor */
#define NGDT_MEM 6

#define	GPROC0_SEL	0	/* common TSS */
#define NGDT_SYS	1

#define GDT_SYS_OFFSET	(NGDT_MEM << 3)

#define GDT_ADDR_MEM(s,i)	\
    ((struct mem_segment_descriptor *)((s) + ((i) << 3)))
#define GDT_ADDR_SYS(s,i)	\
   ((struct sys_segment_descriptor *)((s) + (((i) << 4) + SYSSEL_START)))

/*
 * Checks for valid user selectors.
 */
#define VALID_USER_CSEL(s) \
    ((s) == GSEL(GUCODE_SEL, SEL_UPL))
#define VALID_USER_DSEL(s) \
    ((s) == GSEL(GUDATA_SEL, SEL_UPL))

#endif /* _MACHINE_SEGMENTS_H_ */
@


1.13
log
@lint is dead: BITFIELDTYPE comments aren't useful

ok miller@@
@
text
@d1 1
a1 1
/*	$OpenBSD: segments.h,v 1.12 2015/06/28 02:42:13 guenther Exp $	*/
d131 11
a141 11
/*BITFIELDTYPE*/ u_int64_t gd_looffset:16;/* gate offset (lsb) */
/*BITFIELDTYPE*/ u_int64_t gd_selector:16;/* gate segment selector */
/*BITFIELDTYPE*/ u_int64_t gd_ist:3;	/* IST select */
/*BITFIELDTYPE*/ u_int64_t gd_xx1:5;	/* reserved */
/*BITFIELDTYPE*/ u_int64_t gd_type:5;	/* segment type */
/*BITFIELDTYPE*/ u_int64_t gd_dpl:2;	/* segment descriptor priority level */
/*BITFIELDTYPE*/ u_int64_t gd_p:1;	/* segment descriptor present */
/*BITFIELDTYPE*/ u_int64_t gd_hioffset:48;/* gate offset (msb) */
/*BITFIELDTYPE*/ u_int64_t gd_xx2:8;	/* reserved */
/*BITFIELDTYPE*/ u_int64_t gd_zero:5;	/* must be zero */
/*BITFIELDTYPE*/ u_int64_t gd_xx3:19;	/* reserved */
@


1.12
log
@LDT is gone and not coming back
@
text
@d1 1
a1 1
/*	$OpenBSD: segments.h,v 1.11 2015/05/24 01:01:49 guenther Exp $	*/
d96 12
a107 12
/*BITFIELDTYPE*/ u_int64_t sd_lolimit:16;/* segment extent (lsb) */
/*BITFIELDTYPE*/ u_int64_t sd_lobase:24;/* segment base address (lsb) */
/*BITFIELDTYPE*/ u_int64_t sd_type:5;	/* segment type */
/*BITFIELDTYPE*/ u_int64_t sd_dpl:2;	/* segment descriptor priority level */
/*BITFIELDTYPE*/ u_int64_t sd_p:1;	/* segment descriptor present */
/*BITFIELDTYPE*/ u_int64_t sd_hilimit:4;/* segment extent (msb) */
/*BITFIELDTYPE*/ u_int64_t sd_xx1:3;	/* avl, long and def32 (not used) */
/*BITFIELDTYPE*/ u_int64_t sd_gran:1;	/* limit granularity (byte/page) */
/*BITFIELDTYPE*/ u_int64_t sd_hibase:40;/* segment base address (msb) */
/*BITFIELDTYPE*/ u_int64_t sd_xx2:8;	/* reserved */
/*BITFIELDTYPE*/ u_int64_t sd_zero:5;	/* must be zero */
/*BITFIELDTYPE*/ u_int64_t sd_xx3:19;	/* reserved */
@


1.11
log
@Treat primary cpu like others and put pointer to its GDT in cpu_info.ci_gdt

requested by and ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: segments.h,v 1.10 2011/03/23 16:54:34 pirofti Exp $	*/
a152 3
#if 0
extern struct sys_segment_descriptor *ldt;
#endif
@


1.10
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: segments.h,v 1.9 2010/11/20 20:11:17 miod Exp $	*/
a156 1
extern char *gdtstore;
@


1.9
log
@__attribute__((packed)) -> __packed. The ioprbs.c chunk was commented out, and
uncommenting it is intentional.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: segments.h,v 1.8 2010/11/13 04:16:42 guenther Exp $	*/
d50 2
a51 2
#ifndef _AMD64_SEGMENTS_H_
#define _AMD64_SEGMENTS_H_
d282 1
a282 1
#endif /* _AMD64_SEGMENTS_H_ */
@


1.8
log
@Switch from TSS-per-process to TSS-per-CPU, placing the TSS right
next to the cpu's GDT, also making the double-fault stack per-CPU,
leaving it at the top of the page of the CPU's idle process.  Inline
pmap_activate() and pmap_deactivate() into the asm cpu_switchto
routine, adding a check for the new pmap already being marked as
active on the CPU.  Garbage collect the hasn't-been-used-in-years
GDT update IPI.

Tested by many; ok mikeb@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: segments.h,v 1.7 2010/10/26 05:49:10 guenther Exp $	*/
d108 1
a108 1
} __attribute__((packed));
d125 1
a125 1
} __attribute__((packed));
d142 1
a142 1
} __attribute__((packed));
d150 1
a150 1
} __attribute__((packed));
@


1.7
log
@The LDT is only used by dead compat code now, so load the ldt
register with the null selector (disabling use of it), stop reloading
it on every context switch, and blow away the table itself, as well
as the pcb and pmap bits that were used to track it.  Also, delete
two other unused pcb members: pcb_usersp and pcb_flags.  (Deleting
pcb_usersp also keeps the pcb_savefpu member aligned properly.)
Finally, delete the defines for the unimplemented AMD64_{GET,SET}_LDT
sysarch() calls.

Tested by various with both AMD and Intel chips
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: segments.h,v 1.6 2010/10/14 04:38:24 guenther Exp $	*/
a63 1
/* Dynamically allocated TSSs start (byte offset) */
d65 1
a65 1
#define DYNSEL_START	(SYSSEL_START + (NGDT_SYS << 4))
d71 1
a71 2
 *
 * The rest is 16-byte descriptors for TSSs
d250 1
a250 1
 * Then come the predefined LDT (and possibly TSS) descriptors.
d264 2
a265 1
#define NGDT_SYS	0
@


1.6
log
@Clean up segment handling: switch user-space to using code and data
segments in the GDT instead of the LDT and eliminate the GDT slots
that we don't actually use.

tested on both amd and intel by several
not really the right person, but ok: kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: segments.h,v 1.5 2008/05/23 15:39:43 jasper Exp $	*/
d64 1
a64 1
/* Dynamically allocated TSSs and LDTs start (byte offset) */
a71 1
 * Next NGDT_SYS entries are 16-byte descriptors defining LDTs.
d73 1
a73 1
 * The rest is 16-byte descriptors for TSS and LDT.
a159 1
extern char *ldtstore;
d266 1
a266 2
#define	GLDT_SEL	0	/* Default LDT descriptor */
#define NGDT_SYS	1
a275 15
 * Byte offsets in the Local Descriptor Table (LDT)
 * Strange order because of syscall/sysret insns
 */
#define	LSYS5CALLS_SEL	0	/* iBCS system call gate */
#define LUCODE32_SEL	8	/* 32 bit user code descriptor */
#define	LUDATA_SEL	16	/* User data descriptor */
#define	LUCODE_SEL	24	/* User code descriptor */
#define	LSOL26CALLS_SEL	32	/* Solaris 2.6 system call gate */
#define LUDATA32_SEL	56	/* 32 bit user data descriptor (needed?)*/
#define	LBSDICALLS_SEL	128	/* BSDI system call gate */

#define LDT_SIZE	144


/*
a277 5
#define VALID_USER_DSEL32(s) \
    ((s) == GSEL(GUDATA32_SEL, SEL_UPL) || (s) == LSEL(LUDATA32_SEL, SEL_UPL))
#define VALID_USER_CSEL32(s) \
    ((s) == GSEL(GUCODE32_SEL, SEL_UPL) || (s) == LSEL(LUCODE32_SEL, SEL_UPL))

d279 1
a279 1
    ((s) == GSEL(GUCODE_SEL, SEL_UPL) || (s) == LSEL(LUCODE_SEL, SEL_UPL))
d281 1
a281 1
    ((s) == GSEL(GUDATA_SEL, SEL_UPL) || (s) == LSEL(LUDATA_SEL, SEL_UPL))
@


1.5
log
@- remove USER_LDT, it was never in a state where it would copile, nor will
we support i386-compat mode on amd64.

agreed by beck@@, dlg@@, kettenis@@
ok deraadt@@, tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: segments.h,v 1.4 2005/12/13 00:18:19 jsg Exp $	*/
d256 3
d263 1
a263 1
#define	GUCODE_SEL	3	/* User code descriptor */
d265 2
a266 12
#define	GAPM32CODE_SEL	5
#define	GAPM16CODE_SEL	6
#define	GAPMDATA_SEL	7
#define	GBIOSCODE_SEL	8
#define	GBIOSDATA_SEL	9
#define GPNPBIOSCODE_SEL 10
#define GPNPBIOSDATA_SEL 11
#define GPNPBIOSSCRATCH_SEL 12
#define GPNPBIOSTRAMP_SEL 13
#define GUCODE32_SEL	14
#define GUDATA32_SEL	15
#define NGDT_MEM 16
a291 1
#define LSYSRETBASE_SEL	LUCODE32_SEL
@


1.4
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.
Checked by ian@@, deraadt@@ and millert@@, arm portion checked by drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: segments.h,v 1.3 2004/07/15 17:46:44 deraadt Exp $	*/
d302 1
a302 3
 * Checks for valid user selectors. If USER_LDT ever gets implemented
 * for amd64, these must check the ldt length and SEL_UPL if a user
 * ldt is active.
@


1.3
log
@put int into a type
@
text
@d1 1
a1 1
/*	$OpenBSD: segments.h,v 1.2 2004/01/29 13:21:10 mickey Exp $	*/
d22 1
a22 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.2
log
@check struct reg for evil; from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: segments.h,v 1.1 2004/01/28 01:39:39 mickey Exp $	*/
d121 11
a131 11
	unsigned sd_lolimit:16;         /* segment extent (lsb) */
	unsigned sd_lobase:24;          /* segment base address (lsb) */
	unsigned sd_type:5;             /* segment type */
	unsigned sd_dpl:2;              /* segment descriptor priority level */
	unsigned sd_p:1;                /* segment descriptor present */
	unsigned sd_hilimit:4;          /* segment extent (msb) */
	unsigned sd_avl:1;		/* available */
	unsigned sd_long:1;		/* long mode */
	unsigned sd_def32:1;            /* default 32 vs 16 bit size */
	unsigned sd_gran:1;             /* limit granularity (byte/page) */
	unsigned sd_hibase:8;           /* segment base address (msb) */
@


1.1
log
@an amd64 arch support.
hacked by art@@ from netbsd sources and then later debugged
by me into the shape where it can host itself.
no bootloader yet as needs redoing from the
recent advanced i386 sources (anyone? ;)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d304 15
@

