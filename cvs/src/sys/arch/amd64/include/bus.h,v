head	1.32;
access;
symbols
	OPENBSD_6_1:1.32.0.12
	OPENBSD_6_1_BASE:1.32
	OPENBSD_6_0:1.32.0.8
	OPENBSD_6_0_BASE:1.32
	OPENBSD_5_9:1.32.0.4
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.32.0.6
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.32.0.2
	OPENBSD_5_7_BASE:1.32
	OPENBSD_5_6:1.31.0.4
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.30.0.4
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.29.0.2
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.28.0.2
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.25.0.6
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.4
	OPENBSD_5_0:1.25.0.2
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.24.0.2
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.23.0.2
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.19.0.4
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.10.0.2
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.8.0.2
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.5.0.6
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.4
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.4.0.4
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.3.0.2
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.2.0.6
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.4
	OPENBSD_3_6_BASE:1.2
	SMP_SYNC_A:1.2
	SMP_SYNC_B:1.2
	OPENBSD_3_5:1.2.0.2
	OPENBSD_3_5_BASE:1.2
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.32
date	2015.01.24.15.13.55;	author kettenis;	state Exp;
branches;
next	1.31;
commitid	Ol0pICcR5PormuCL;

1.31
date	2014.03.29.18.09.28;	author guenther;	state Exp;
branches;
next	1.30;

1.30
date	2013.12.12.21.04.50;	author kettenis;	state Exp;
branches;
next	1.29;

1.29
date	2013.03.17.21.49.00;	author kettenis;	state Exp;
branches;
next	1.28;

1.28
date	2013.01.29.01.15.57;	author dlg;	state Exp;
branches;
next	1.27;

1.27
date	2013.01.18.01.54.40;	author dlg;	state Exp;
branches;
next	1.26;

1.26
date	2013.01.15.09.33.30;	author dlg;	state Exp;
branches;
next	1.25;

1.25
date	2011.03.23.16.54.34;	author pirofti;	state Exp;
branches;
next	1.24;

1.24
date	2010.09.06.19.05.48;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2010.04.08.00.55.25;	author oga;	state Exp;
branches;
next	1.22;

1.22
date	2010.04.04.12.49.30;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2009.07.30.21.39.15;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2009.07.26.18.48.55;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2009.06.07.02.30.34;	author oga;	state Exp;
branches;
next	1.18;

1.18
date	2009.05.10.15.04.48;	author oga;	state Exp;
branches;
next	1.17;

1.17
date	2009.04.21.17.05.29;	author oga;	state Exp;
branches;
next	1.16;

1.16
date	2009.04.20.00.42.05;	author oga;	state Exp;
branches;
next	1.15;

1.15
date	2009.03.10.15.03.16;	author oga;	state Exp;
branches;
next	1.14;

1.14
date	2009.02.05.01.15.20;	author oga;	state Exp;
branches;
next	1.13;

1.13
date	2008.12.03.15.46.06;	author oga;	state Exp;
branches;
next	1.12;

1.12
date	2008.11.22.17.45.20;	author oga;	state Exp;
branches;
next	1.11;

1.11
date	2008.11.21.23.16.16;	author oga;	state Exp;
branches;
next	1.10;

1.10
date	2008.06.26.05.42.09;	author ray;	state Exp;
branches;
next	1.9;

1.9
date	2008.06.10.02.55.39;	author weingart;	state Exp;
branches;
next	1.8;

1.8
date	2007.11.16.16.16.07;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2007.09.01.03.41.17;	author marco;	state Exp;
branches;
next	1.6;

1.6
date	2007.08.31.20.11.09;	author marco;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.27.15.17.12;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2005.11.05.18.29.24;	author marco;	state Exp;
branches;
next	1.3;

1.3
date	2005.05.25.18.29.58;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.23.06.29.54;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.28.01.39.39;	author mickey;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.06.05.23.09.25;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Add bus_dmamem_alloc_range(9) to allow drivers to allocate DMA'able memory
within a range that is more (or less) restrictive than the default range.

ok deraadt@@, stsp@@
@
text
@/*	$OpenBSD: bus.h,v 1.31 2014/03/29 18:09:28 guenther Exp $	*/
/*	$NetBSD: bus.h,v 1.6 1996/11/10 03:19:25 thorpej Exp $	*/

/*-
 * Copyright (c) 1996, 1997 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1996 Charles M. Hannum.  All rights reserved.
 * Copyright (c) 1996 Jason R. Thorpe.  All rights reserved.
 * Copyright (c) 1996 Christopher G. Demetriou.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Christopher G. Demetriou
 *	for the NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _MACHINE_BUS_H_
#define _MACHINE_BUS_H_

#include <sys/mutex.h>
#include <sys/tree.h>

#include <machine/pio.h>

/*
 * Bus address and size types
 */
typedef u_long bus_addr_t;
typedef u_long bus_size_t;

/*
 * Access methods for bus resources and address space.
 */
struct x86_bus_space_ops;
typedef	const struct x86_bus_space_ops *bus_space_tag_t;
typedef	u_long bus_space_handle_t;

int	bus_space_map(bus_space_tag_t t, bus_addr_t addr,
    bus_size_t size, int flags, bus_space_handle_t *bshp);
/* like map, but without extent map checking/allocation */ 
int	_bus_space_map(bus_space_tag_t t, bus_addr_t addr,
    bus_size_t size, int flags, bus_space_handle_t *bshp);

int	bus_space_alloc(bus_space_tag_t t, bus_addr_t rstart,
	    bus_addr_t rend, bus_size_t size, bus_size_t align,
	    bus_size_t boundary, int flags, bus_addr_t *addrp,
	    bus_space_handle_t *bshp);
void	bus_space_free(bus_space_tag_t t, bus_space_handle_t bsh,  
	    bus_size_t size);

/* 
 *      int bus_space_unmap(bus_space_tag_t t,
 *          bus_space_handle_t bsh, bus_size_t size);
 * 
 * Unmap a region of bus space.
 */
 
void	bus_space_unmap(bus_space_tag_t t, bus_space_handle_t bsh,
	    bus_size_t size);
void	_bus_space_unmap(bus_space_tag_t t, bus_space_handle_t bsh,
	    bus_size_t size, bus_addr_t *);

/* like bus_space_map(), but without extent map checking/allocation */
int	_bus_space_map(bus_space_tag_t t, bus_addr_t addr,
	    bus_size_t size, int flags, bus_space_handle_t *bshp);

/*
 *      int bus_space_subregion(bus_space_tag_t t,
 *          bus_space_handle_t bsh, bus_size_t offset, bus_size_t size,
 *          bus_space_handle_t *nbshp);
 * 
 * Get a new handle for a subregion of an already-mapped area of bus space.
 */
 
int	bus_space_subregion(bus_space_tag_t t, bus_space_handle_t bsh,
	    bus_size_t offset, bus_size_t size, bus_space_handle_t *nbshp);

struct x86_bus_space_ops {

/*
 *	u_intN_t bus_space_read_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset);
 *
 * Read a 1, 2, 4, or 8 byte quantity from bus space
 * described by tag/handle/offset.
 */
	u_int8_t	(*read_1)(bus_space_handle_t, bus_size_t);
	u_int16_t	(*read_2)(bus_space_handle_t, bus_size_t);
	u_int32_t	(*read_4)(bus_space_handle_t, bus_size_t);
	u_int64_t	(*read_8)(bus_space_handle_t, bus_size_t);

#define bus_space_read_1(_t, _h, _o) ((_t)->read_1((_h), (_o)))
#define bus_space_read_2(_t, _h, _o) ((_t)->read_2((_h), (_o)))
#define bus_space_read_4(_t, _h, _o) ((_t)->read_4((_h), (_o)))
#define bus_space_read_8(_t, _h, _o) ((_t)->read_8((_h), (_o)))

#define bus_space_read_raw_2(_t, _h, _o) ((_t)->read_2((_h), (_o)))
#define bus_space_read_raw_4(_t, _h, _o) ((_t)->read_4((_h), (_o)))
#define bus_space_read_raw_8(_t, _h, _o) ((_t)->read_8((_h), (_o)))

/*
 *	void bus_space_read_multi_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_intN_t *addr, size_t count);
 *
 * Read `count' 1, 2, 4, or 8 byte quantities from bus space
 * described by tag/handle/offset and copy into buffer provided.
 */

	void		(*read_multi_1)(bus_space_handle_t, bus_size_t,
			    u_int8_t *, bus_size_t);
	void		(*read_multi_2)(bus_space_handle_t, bus_size_t,
			    u_int16_t *, bus_size_t);
	void		(*read_multi_4)(bus_space_handle_t, bus_size_t,
			    u_int32_t *, bus_size_t);
	void		(*read_multi_8)(bus_space_handle_t, bus_size_t,
			    u_int64_t *, bus_size_t);

#define bus_space_read_multi_1(_t, _h, _o, _a, _c) \
	((_t)->read_multi_1((_h), (_o), (_a), (_c)))
#define bus_space_read_multi_2(_t, _h, _o, _a, _c) \
	((_t)->read_multi_2((_h), (_o), (_a), (_c)))
#define bus_space_read_multi_4(_t, _h, _o, _a, _c) \
	((_t)->read_multi_4((_h), (_o), (_a), (_c)))
#define bus_space_read_multi_8(_t, _h, _o, _a, _c) \
	((_t)->read_multi_8((_h), (_o), (_a), (_c)))

/*
 *	void bus_space_read_raw_multi_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_int8_t *addr, size_t count);
 *
 * Read `count' bytes in 2, 4 or 8 byte wide quantities from bus space
 * described by tag/handle/offset and copy into buffer provided.  The buffer
 * must have proper alignment for the N byte wide entities.  Furthermore
 * possible byte-swapping should be done by these functions.
 */

#define bus_space_read_raw_multi_2(_t, _h, _o, _a, _c) \
	((_t)->read_multi_2((_h), (_o), (u_int16_t *)(_a), (_c) >> 1))
#define bus_space_read_raw_multi_4(_t, _h, _o, _a, _c) \
	((_t)->read_multi_4((_h), (_o), (u_int32_t *)(_a), (_c) >> 2))
#define bus_space_read_raw_multi_8(_t, _h, _o, _a, _c) \
	((_t)->read_multi_8((_h), (_o), (u_int64_t *)(_a), (_c) >> 3))

/*
 *	void bus_space_read_region_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_intN_t *addr, size_t count);
 *
 * Read `count' 1, 2, 4, or 8 byte quantities from bus space
 * described by tag/handle and starting at `offset' and copy into
 * buffer provided.
 */

	void		(*read_region_1)(bus_space_handle_t,
			    bus_size_t, u_int8_t *, bus_size_t);
	void		(*read_region_2)(bus_space_handle_t,
			    bus_size_t, u_int16_t *, bus_size_t);
	void		(*read_region_4)(bus_space_handle_t,
			    bus_size_t, u_int32_t *, bus_size_t);
	void		(*read_region_8)(bus_space_handle_t,
			    bus_size_t, u_int64_t *, bus_size_t);

#define bus_space_read_region_1(_t, _h, _o, _a, _c) \
	((_t)->read_region_1((_h), (_o), (_a), (_c)))
#define bus_space_read_region_2(_t, _h, _o, _a, _c) \
	((_t)->read_region_2((_h), (_o), (_a), (_c)))
#define bus_space_read_region_4(_t, _h, _o, _a, _c) \
	((_t)->read_region_4((_h), (_o), (_a), (_c)))
#define bus_space_read_region_8(_t, _h, _o, _a, _c) \
	((_t)->read_region_8((_h), (_o), (_a), (_c)))

/*
 *	void bus_space_read_raw_region_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_int8_t *addr, size_t count);
 *
 * Read `count' bytes in 2, 4 or 8 byte wide quantities from bus space
 * described by tag/handle and starting at `offset' and copy into
 * buffer provided.  The buffer must have proper alignment for the N byte
 * wide entities.  Furthermore possible byte-swapping should be done by
 * these functions.
 */

#define bus_space_read_raw_region_2(_t, _h, _o, _a, _c) \
	((_t)->read_region_2((_h), (_o), (u_int16_t *)(_a), (_c) >> 1))
#define bus_space_read_raw_region_4(_t, _h, _o, _a, _c) \
	((_t)->read_region_4((_h), (_o), (u_int32_t *)(_a), (_c) >> 2))
#define bus_space_read_raw_region_8(_t, _h, _o, _a, _c) \
	((_t)->read_region_8((_h), (_o), (u_int64_t *)(_a), (_c) >> 3))

/*
 *	void bus_space_write_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_intN_t value);
 *
 * Write the 1, 2, 4, or 8 byte value `value' to bus space
 * described by tag/handle/offset.
 */

	void		(*write_1)(bus_space_handle_t, bus_size_t, u_int8_t);
	void		(*write_2)(bus_space_handle_t, bus_size_t, u_int16_t);
	void		(*write_4)(bus_space_handle_t, bus_size_t, u_int32_t);
	void		(*write_8)(bus_space_handle_t, bus_size_t, u_int64_t);

#define bus_space_write_1(_t, _h, _o, _v) \
	((_t)->write_1((_h), (_o), (_v)))
#define bus_space_write_2(_t, _h, _o, _v) \
	((_t)->write_2((_h), (_o), (_v)))
#define bus_space_write_4(_t, _h, _o, _v) \
	((_t)->write_4((_h), (_o), (_v)))
#define bus_space_write_8(_t, _h, _o, _v) \
	((_t)->write_8((_h), (_o), (_v)))

#define bus_space_write_raw_2(_t, _h, _o, _v) \
	((_t)->write_2((_h), (_o), (_v)))
#define bus_space_write_raw_4(_t, _h, _o, _v) \
	((_t)->write_4((_h), (_o), (_v)))
#define bus_space_write_raw_8(_t, _h, _o, _v) \
	((_t)->write_8((_h), (_o), (_v)))

/*
 *	void bus_space_write_multi_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    const u_intN_t *addr, size_t count);
 *
 * Write `count' 1, 2, 4, or 8 byte quantities from the buffer
 * provided to bus space described by tag/handle/offset.
 */

	void		(*write_multi_1)(bus_space_handle_t,
			    bus_size_t, const u_int8_t *, bus_size_t);
	void		(*write_multi_2)(bus_space_handle_t,
			    bus_size_t, const u_int16_t *, bus_size_t);
	void		(*write_multi_4)(bus_space_handle_t,
			    bus_size_t, const u_int32_t *, bus_size_t);
	void		(*write_multi_8)(bus_space_handle_t,
			    bus_size_t, const u_int64_t *, bus_size_t);

#define bus_space_write_multi_1(_t, _h, _o, _a, _c) \
	((_t)->write_multi_1((_h), (_o), (_a), (_c)))
#define bus_space_write_multi_2(_t, _h, _o, _a, _c) \
	((_t)->write_multi_2((_h), (_o), (_a), (_c)))
#define bus_space_write_multi_4(_t, _h, _o, _a, _c) \
	((_t)->write_multi_4((_h), (_o), (_a), (_c)))
#define bus_space_write_multi_8(_t, _h, _o, _a, _c) \
	((_t)->write_multi_8((_h), (_o), (_a), (_c)))

/*
 *	void bus_space_write_raw_multi_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    const u_int8_t *addr, size_t count);
 *
 * Write `count' bytes in 2, 4 or 8 byte wide quantities from the buffer
 * provided to bus space described by tag/handle/offset.  The buffer
 * must have proper alignment for the N byte wide entities.  Furthermore
 * possible byte-swapping should be done by these functions.
 */

#define bus_space_write_raw_multi_2(_t, _h, _o, _a, _c) \
	((_t)->write_multi_2((_h), (_o), (const u_int16_t *)(_a), (_c) >> 1))
#define bus_space_write_raw_multi_4(_t, _h, _o, _a, _c) \
	((_t)->write_multi_4((_h), (_o), (const u_int32_t *)(_a), (_c) >> 2))
#define bus_space_write_raw_multi_8(_t, _h, _o, _a, _c) \
	((_t)->write_multi_8((_h), (_o), (const u_int64_t *)(_a), (_c) >> 3))

/*
 *	void bus_space_write_region_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    const u_intN_t *addr, size_t count);
 *
 * Write `count' 1, 2, 4, or 8 byte quantities from the buffer provided
 * to bus space described by tag/handle starting at `offset'.
 */

	void		(*write_region_1)(bus_space_handle_t,
			    bus_size_t, const u_int8_t *, bus_size_t);
	void		(*write_region_2)(bus_space_handle_t,
			    bus_size_t, const u_int16_t *, bus_size_t);
	void		(*write_region_4)(bus_space_handle_t,
			    bus_size_t, const u_int32_t *, bus_size_t);
	void		(*write_region_8)(bus_space_handle_t,
			    bus_size_t, const u_int64_t *, bus_size_t);

#define bus_space_write_region_1(_t, _h, _o, _a, _c) \
	((_t)->write_region_1((_h), (_o), (_a), (_c)))
#define bus_space_write_region_2(_t, _h, _o, _a, _c) \
	((_t)->write_region_2((_h), (_o), (_a), (_c)))
#define bus_space_write_region_4(_t, _h, _o, _a, _c) \
	((_t)->write_region_4((_h), (_o), (_a), (_c)))
#define bus_space_write_region_8(_t, _h, _o, _a, _c) \
	((_t)->write_region_8((_h), (_o), (_a), (_c)))

/*
 *	void bus_space_write_raw_region_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    const u_int8_t *addr, size_t count);
 *
 * Write `count' bytes in 2, 4 or 8 byte wide quantities to bus space
 * described by tag/handle and starting at `offset' from the
 * buffer provided.  The buffer must have proper alignment for the N byte
 * wide entities.  Furthermore possible byte-swapping should be done by
 * these functions.
 */

#define bus_space_write_raw_region_2(_t, _h, _o, _a, _c) \
	((_t)->write_region_2((_h), (_o), (const u_int16_t *)(_a), (_c) >> 1))
#define bus_space_write_raw_region_4(_t, _h, _o, _a, _c) \
	((_t)->write_region_4((_h), (_o), (const u_int32_t *)(_a), (_c) >> 2))
#define bus_space_write_raw_region_8(_t, _h, _o, _a, _c) \
	((_t)->write_region_8((_h), (_o), (const u_int64_t *)(_a), (_c) >> 3))

/*
 *	void bus_space_set_multi_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_intN_t val, size_t count);
 *
 * Write the 1, 2, 4, or 8 byte value `val' to bus space described
 * by tag/handle/offset `count' times.
 */

	void		(*set_multi_1)(bus_space_handle_t,
			    bus_size_t, u_int8_t, size_t);
	void		(*set_multi_2)(bus_space_handle_t,
			    bus_size_t, u_int16_t, size_t);
	void		(*set_multi_4)(bus_space_handle_t,
			    bus_size_t, u_int32_t, size_t);
	void		(*set_multi_8)(bus_space_handle_t,
			    bus_size_t, u_int64_t, size_t);

#define bus_space_set_multi_1(_t, _h, _o, _a, _c) \
	((_t)->set_multi_1((_h), (_o), (_a), (_c)))
#define bus_space_set_multi_2(_t, _h, _o, _a, _c) \
	((_t)->set_multi_2((_h), (_o), (_a), (_c)))
#define bus_space_set_multi_4(_t, _h, _o, _a, _c) \
	((_t)->set_multi_4((_h), (_o), (_a), (_c)))
#define bus_space_set_multi_8(_t, _h, _o, _a, _c) \
	((_t)->set_multi_8((_h), (_o), (_a), (_c)))

/*
 *	void bus_space_set_region_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_intN_t val, size_t count);
 *
 * Write `count' 1, 2, 4, or 8 byte value `val' to bus space described
 * by tag/handle starting at `offset'.
 */

	void		(*set_region_1)(bus_space_handle_t,
			    bus_size_t, u_int8_t, size_t);
	void		(*set_region_2)(bus_space_handle_t,
			    bus_size_t, u_int16_t, size_t);
	void		(*set_region_4)(bus_space_handle_t,
			    bus_size_t, u_int32_t, size_t);
	void		(*set_region_8)(bus_space_handle_t,
			    bus_size_t, u_int64_t, size_t);

#define bus_space_set_region_1(_t, _h, _o, _a, _c) \
	((_t)->set_region_1((_h), (_o), (_a), (_c)))
#define bus_space_set_region_2(_t, _h, _o, _a, _c) \
	((_t)->set_region_2((_h), (_o), (_a), (_c)))
#define bus_space_set_region_4(_t, _h, _o, _a, _c) \
	((_t)->set_region_4((_h), (_o), (_a), (_c)))
#define bus_space_set_region_8(_t, _h, _o, _a, _c) \
	((_t)->set_region_8((_h), (_o), (_a), (_c)))

/*
 *	void bus_space_copy_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh1, bus_size_t off1,
 *	    bus_space_handle_t bsh2, bus_size_t off2,
 *	    size_t count);
 *
 * Copy `count' 1, 2, 4, or 8 byte values from bus space starting
 * at tag/bsh1/off1 to bus space starting at tag/bsh2/off2.
 */

	void		(*copy_1)(bus_space_handle_t,
			    bus_size_t, bus_space_handle_t, bus_size_t, size_t);
	void		(*copy_2)(bus_space_handle_t,
			    bus_size_t, bus_space_handle_t, bus_size_t, size_t);
	void		(*copy_4)(bus_space_handle_t,
			    bus_size_t, bus_space_handle_t, bus_size_t, size_t);
	void		(*copy_8)(bus_space_handle_t,
			    bus_size_t, bus_space_handle_t, bus_size_t, size_t);

#define bus_space_copy_1(_t, _h1, _o1, _h2, _o2, _c) \
	((_t)->copy_1((_h1), (_o1), (_h2), (_o2), (_c)))
#define bus_space_copy_2(_t, _h1, _o1, _h2, _o2, _c) \
	((_t)->copy_2((_h1), (_o1), (_h2), (_o2), (_c)))
#define bus_space_copy_4(_t, _h1, _o1, _h2, _o2, _c) \
	((_t)->copy_4((_h1), (_o1), (_h2), (_o2), (_c)))
#define bus_space_copy_8(_t, _h1, _o1, _h2, _o2, _c) \
	((_t)->copy_8((_h1), (_o1), (_h2), (_o2), (_c)))

/*
 *	void *bus_space_vaddr(bus_space_tag_t, bus_space_handle_t);
 *
 * Get the kernel virtual address for the mapped bus space.
 * Only allowed for regions mapped with BUS_SPACE_MAP_LINEAR.
 */
	void *		(*vaddr)(bus_space_handle_t);

#define bus_space_vaddr(_t, _h) \
	((_t)->vaddr((_h)))

/*      
 *      paddr_t bus_space_mmap(bus_space_tag_t t, bus_addr_t base,
 *          off_t offset, int prot, int flags);
 * 
 * Mmap an area of bus space.
 */
 
	paddr_t		(*mmap)(bus_addr_t, off_t, int, int);

#define bus_space_mmap(_t, _a, _o, _p, _f) \
	((_t)->mmap((_a), (_o), (_p), (_f)))
};

/*
 * Bus read/write barrier methods.
 */
#define	BUS_SPACE_BARRIER_READ	0x01		/* force read barrier */
#define	BUS_SPACE_BARRIER_WRITE	0x02		/* force write barrier */

static inline void
bus_space_barrier(bus_space_tag_t space, bus_space_handle_t
    handle, bus_size_t offset, bus_size_t length, int flags)
{
	switch (flags) {
	case (BUS_SPACE_BARRIER_READ|BUS_SPACE_BARRIER_WRITE):
		__asm volatile("mfence");
		break;
	case BUS_SPACE_BARRIER_WRITE:
		__asm volatile("sfence");
		break;
	default:
		__asm volatile("lfence");
		break;
	}
}

#define	BUS_SPACE_MAP_CACHEABLE		0x0001
#define	BUS_SPACE_MAP_LINEAR		0x0002
#define	BUS_SPACE_MAP_PREFETCHABLE	0x0008

/*
 * Values for the x86 bus space tag, not to be used directly by MI code.
 */

/* space is i/o space */
extern const struct x86_bus_space_ops x86_bus_space_io_ops;
#define	X86_BUS_SPACE_IO	(&x86_bus_space_io_ops)

/* space is mem space */
extern const struct x86_bus_space_ops x86_bus_space_mem_ops;
#define X86_BUS_SPACE_MEM	(&x86_bus_space_mem_ops)

/*
 * bus_dma
 */

/*
 * Flags used in various bus DMA methods.
 */
#define	BUS_DMA_WAITOK		0x0000	/* safe to sleep (pseudo-flag) */
#define	BUS_DMA_NOWAIT		0x0001	/* not safe to sleep */
#define	BUS_DMA_ALLOCNOW	0x0002	/* perform resource allocation now */
#define	BUS_DMA_COHERENT	0x0004	/* hint: map memory DMA coherent */
#define	BUS_DMA_BUS1		0x0010	/* placeholders for bus functions... */
#define	BUS_DMA_BUS2		0x0020
#define	BUS_DMA_32BIT		0x0040
#define	BUS_DMA_24BIT		0x0080	/* isadma map */
#define	BUS_DMA_STREAMING	0x0100	/* hint: sequential, unidirectional */
#define	BUS_DMA_READ		0x0200	/* mapping is device -> memory only */
#define	BUS_DMA_WRITE		0x0400	/* mapping is memory -> device only */
#define	BUS_DMA_NOCACHE		0x0800	/* map memory uncached */
#define	BUS_DMA_ZERO		0x1000	/* zero memory in dmamem_alloc */

/* Forwards needed by prototypes below. */
struct mbuf;
struct proc;
struct uio;

/*
 * Operations performed by bus_dmamap_sync().
 */
#define BUS_DMASYNC_PREREAD	0x01
#define BUS_DMASYNC_POSTREAD	0x02
#define BUS_DMASYNC_PREWRITE	0x04
#define BUS_DMASYNC_POSTWRITE	0x08

typedef struct bus_dma_tag		*bus_dma_tag_t;
typedef struct bus_dmamap		*bus_dmamap_t;

/*
 *	bus_dma_segment_t
 *
 *	Describes a single contiguous DMA transaction.  Values
 *	are suitable for programming into DMA registers.
 */
struct bus_dma_segment {
	bus_addr_t	ds_addr;	/* DMA address */
	bus_size_t	ds_len;		/* length of transfer */
	/*
	 * Ugh. need this so can pass alignment down from bus_dmamem_alloc
	 * to scatter gather maps. only the first one is used so the rest is
	 * wasted space. bus_dma could do with fixing the api for this.
	 */
	 bus_size_t	_ds_boundary;	/* don't cross */
	 bus_size_t	_ds_align;	/* align to me */
};
typedef struct bus_dma_segment	bus_dma_segment_t;

/*
 *	bus_dma_tag_t
 *
 *	A machine-dependent opaque type describing the implementation of
 *	DMA for a given bus.
 */

struct bus_dma_tag {
	void	*_cookie;		/* cookie used in the guts */

	/*
	 * DMA mapping methods.
	 */
	int	(*_dmamap_create)(bus_dma_tag_t, bus_size_t, int,
		    bus_size_t, bus_size_t, int, bus_dmamap_t *);
	void	(*_dmamap_destroy)(bus_dma_tag_t, bus_dmamap_t);
	int	(*_dmamap_load)(bus_dma_tag_t, bus_dmamap_t, void *,
		    bus_size_t, struct proc *, int);
	int	(*_dmamap_load_mbuf)(bus_dma_tag_t, bus_dmamap_t,
		    struct mbuf *, int);
	int	(*_dmamap_load_uio)(bus_dma_tag_t, bus_dmamap_t,
		    struct uio *, int);
	int	(*_dmamap_load_raw)(bus_dma_tag_t, bus_dmamap_t,
		    bus_dma_segment_t *, int, bus_size_t, int);
	void	(*_dmamap_unload)(bus_dma_tag_t, bus_dmamap_t);
	void	(*_dmamap_sync)(bus_dma_tag_t, bus_dmamap_t,
		    bus_addr_t, bus_size_t, int);

	/*
	 * DMA memory utility functions.
	 */
	int	(*_dmamem_alloc)(bus_dma_tag_t, bus_size_t, bus_size_t,
		    bus_size_t, bus_dma_segment_t *, int, int *, int);
	int	(*_dmamem_alloc_range)(bus_dma_tag_t, bus_size_t, bus_size_t,
		    bus_size_t, bus_dma_segment_t *, int, int *, int,
		    bus_addr_t, bus_addr_t);
	void	(*_dmamem_free)(bus_dma_tag_t,
		    bus_dma_segment_t *, int);
	int	(*_dmamem_map)(bus_dma_tag_t, bus_dma_segment_t *,
		    int, size_t, caddr_t *, int);
	void	(*_dmamem_unmap)(bus_dma_tag_t, caddr_t, size_t);
	paddr_t	(*_dmamem_mmap)(bus_dma_tag_t, bus_dma_segment_t *,
		    int, off_t, int, int);
};

#define	bus_dmamap_create(t, s, n, m, b, f, p)			\
	(*(t)->_dmamap_create)((t), (s), (n), (m), (b), (f), (p))
#define	bus_dmamap_destroy(t, p)				\
	(*(t)->_dmamap_destroy)((t), (p))
#define	bus_dmamap_load(t, m, b, s, p, f)			\
	(*(t)->_dmamap_load)((t), (m), (b), (s), (p), (f))
#define	bus_dmamap_load_mbuf(t, m, b, f)			\
	(*(t)->_dmamap_load_mbuf)((t), (m), (b), (f))
#define	bus_dmamap_load_uio(t, m, u, f)				\
	(*(t)->_dmamap_load_uio)((t), (m), (u), (f))
#define	bus_dmamap_load_raw(t, m, sg, n, s, f)			\
	(*(t)->_dmamap_load_raw)((t), (m), (sg), (n), (s), (f))
#define	bus_dmamap_unload(t, p)					\
	(*(t)->_dmamap_unload)((t), (p))
#define	bus_dmamap_sync(t, p, o, l, ops)			\
	(*(t)->_dmamap_sync)((t), (p), (o), (l), (ops))

#define	bus_dmamem_alloc(t, s, a, b, sg, n, r, f)		\
	(*(t)->_dmamem_alloc)((t), (s), (a), (b), (sg), (n), (r), (f))
#define	bus_dmamem_alloc_range(t, s, a, b, sg, n, r, f, l, h)	\
	(*(t)->_dmamem_alloc_range)((t), (s), (a), (b), (sg),	\
		(n), (r), (f), (l), (h))
#define	bus_dmamem_free(t, sg, n)				\
	(*(t)->_dmamem_free)((t), (sg), (n))
#define	bus_dmamem_map(t, sg, n, s, k, f)			\
	(*(t)->_dmamem_map)((t), (sg), (n), (s), (k), (f))
#define	bus_dmamem_unmap(t, k, s)				\
	(*(t)->_dmamem_unmap)((t), (k), (s))
#define	bus_dmamem_mmap(t, sg, n, o, p, f)			\
	(*(t)->_dmamem_mmap)((t), (sg), (n), (o), (p), (f))

/*
 *	bus_dmamap_t
 *
 *	Describes a DMA mapping.
 */
struct bus_dmamap {
	/*
	 * PRIVATE MEMBERS: not for use by machine-independent code.
	 */
	bus_size_t	_dm_size;	/* largest DMA transfer mappable */
	int		_dm_segcnt;	/* number of segs this map can map */
	bus_size_t	_dm_maxsegsz;	/* largest possible segment */
	bus_size_t	_dm_boundary;	/* don't cross this */
	int		_dm_flags;	/* misc. flags */

	void		*_dm_cookie;	/* cookie for bus-specific functions */

	/*
	 * PUBLIC MEMBERS: these are used by machine-independent code.
	 */
	bus_size_t	dm_mapsize;	/* size of the mapping */
	int		dm_nsegs;	/* # valid segments in mapping */
	bus_dma_segment_t dm_segs[1];	/* segments; variable length */
};

int	_bus_dmamap_create(bus_dma_tag_t, bus_size_t, int, bus_size_t,
	    bus_size_t, int, bus_dmamap_t *);
void	_bus_dmamap_destroy(bus_dma_tag_t, bus_dmamap_t);
int	_bus_dmamap_load(bus_dma_tag_t, bus_dmamap_t, void *,
	    bus_size_t, struct proc *, int);
int	_bus_dmamap_load_mbuf(bus_dma_tag_t, bus_dmamap_t,
	    struct mbuf *, int);
int	_bus_dmamap_load_uio(bus_dma_tag_t, bus_dmamap_t,
	    struct uio *, int);
int	_bus_dmamap_load_raw(bus_dma_tag_t, bus_dmamap_t,
	    bus_dma_segment_t *, int, bus_size_t, int);
void	_bus_dmamap_unload(bus_dma_tag_t, bus_dmamap_t);
void	_bus_dmamap_sync(bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
	    bus_size_t, int);

int	_bus_dmamem_alloc(bus_dma_tag_t tag, bus_size_t size,
	    bus_size_t alignment, bus_size_t boundary,
	    bus_dma_segment_t *segs, int nsegs, int *rsegs, int flags);
void	_bus_dmamem_free(bus_dma_tag_t tag, bus_dma_segment_t *segs,
	    int nsegs);
int	_bus_dmamem_map(bus_dma_tag_t tag, bus_dma_segment_t *segs,
	    int nsegs, size_t size, caddr_t *kvap, int flags);
void	_bus_dmamem_unmap(bus_dma_tag_t tag, caddr_t kva,
	    size_t size);
paddr_t	_bus_dmamem_mmap(bus_dma_tag_t tag, bus_dma_segment_t *segs,
	    int nsegs, off_t off, int prot, int flags);

int	_bus_dmamem_alloc_range(bus_dma_tag_t tag, bus_size_t size,
	    bus_size_t alignment, bus_size_t boundary,
	    bus_dma_segment_t *segs, int nsegs, int *rsegs, int flags,
	    bus_addr_t low, bus_addr_t high);

#endif /* _MACHINE_BUS_H_ */
@


1.31
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.30 2013/12/12 21:04:50 kettenis Exp $	*/
d597 3
d628 3
d695 1
a695 1
	    paddr_t low, paddr_t high);
@


1.30
log
@Remove the scatter/gather dma implementation as it is no longer used.

ok krw@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.29 2013/03/17 21:49:00 kettenis Exp $	*/
d481 1
a481 1
		__asm __volatile("mfence");
d484 1
a484 1
		__asm __volatile("sfence");
d487 1
a487 1
		__asm __volatile("lfence");
@


1.29
log
@Add an interface to rebind AGP DMA mappings.  To be used by the upcoming KMS
support to reload bindings after suspend/resume and to update cachability
flags in the address translation table entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.28 2013/01/29 01:15:57 dlg Exp $	*/
a527 8
#define	BUS_DMA_SG		0x2000	/* Internal. memory is for SG map */

/* types for _dm_buftype */
#define	BUS_BUFTYPE_INVALID	0
#define	BUS_BUFTYPE_LINEAR	1
#define	BUS_BUFTYPE_MBUF	2
#define	BUS_BUFTYPE_UIO		3
#define	BUS_BUFTYPE_RAW		4
a689 61

struct extent;

/* Scatter gather bus_dma functions. */
struct sg_cookie {
	struct mutex	 sg_mtx;
	struct extent	*sg_ex;
	void		*sg_hdl;

	void		(*bind_page)(void *, bus_addr_t, paddr_t, int);
	void		(*unbind_page)(void *, bus_addr_t);
	void		(*flush_tlb)(void *);
};

/* 
 * per-map DVMA page table
 */
struct sg_page_entry {
	SPLAY_ENTRY(sg_page_entry)	spe_node;
	paddr_t				spe_pa;
	bus_addr_t			spe_va;
};

/* for sg_dma this will be in the map's dm_cookie. */
struct sg_page_map {
	SPLAY_HEAD(sg_page_tree, sg_page_entry) spm_tree;

	void			*spm_origbuf;	/* pointer to original data */
	int			 spm_buftype;	/* type of data */
	struct proc		*spm_proc;	/* proc that owns the mapping */

	int			 spm_maxpage;	/* Size of allocated page map */
	int			 spm_pagecnt;	/* Number of entries in use */
	bus_addr_t		 spm_start;	/* dva when bound */
	bus_size_t		 spm_size;	/* size of bound map */
	struct sg_page_entry	 spm_map[1];
};

struct sg_cookie	*sg_dmatag_init(char *, void *, bus_addr_t, bus_size_t,
			    void (*)(void *, vaddr_t, paddr_t, int),
			    void (*)(void *, vaddr_t), void (*)(void *));
void	sg_dmatag_destroy(struct sg_cookie *);
int	sg_dmamap_create(bus_dma_tag_t, bus_size_t, int, bus_size_t,
	    bus_size_t, int, bus_dmamap_t *);
void	sg_dmamap_destroy(bus_dma_tag_t, bus_dmamap_t);
void	sg_dmamap_set_alignment(bus_dma_tag_t, bus_dmamap_t, u_long);
int	sg_dmamap_load(bus_dma_tag_t, bus_dmamap_t, void *, bus_size_t,
	    struct proc *, int);
int	sg_dmamap_load_mbuf(bus_dma_tag_t, bus_dmamap_t,
	    struct mbuf *, int);
int	sg_dmamap_load_uio(bus_dma_tag_t, bus_dmamap_t, struct uio *, int);
int	sg_dmamap_load_raw(bus_dma_tag_t, bus_dmamap_t, bus_dma_segment_t *,
	    int, bus_size_t, int);
void	sg_dmamap_unload(bus_dma_tag_t, bus_dmamap_t);
int	sg_dmamap_load_buffer(bus_dma_tag_t, bus_dmamap_t, void *, bus_size_t,
	    struct proc *, int, int *, int);
int	sg_dmamap_load_physarray(bus_dma_tag_t, bus_dmamap_t, paddr_t *,
	    int, int, int *, int);
void	sg_dmamap_reload(bus_dma_tag_t, bus_dmamap_t, int);
int	sg_dmamem_alloc(bus_dma_tag_t, bus_size_t, bus_size_t, bus_size_t,
	    bus_dma_segment_t *, int, int *, int);
@


1.28
log
@the bus_space api implies that there's a bus endianness that it will
swap for you to the hosts endianness. sometimes you dont want this hand
holding and just want raw access to the registers. bus_space does have
stuff to do this already, but they deal with buffers which can be awkward
if you just want to get or set a single register.

this adds the following to i386 and amd64:

bus_space_read_raw_2() bus_space_read_raw_4() bus_space_read_raw_8()
bus_space_write_raw_2() bus_space_write_raw_4() bus_space_write_raw_8()

sparc64 already implements this, even though it wasnt part of the
official api. how handy.

i'll do other archs as i can.

kettenis@@ and miod@@ seem ok with this
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.27 2013/01/18 01:54:40 dlg Exp $	*/
d756 1
@


1.27
log
@twist the amd64 bus_space implementation a bit. instead of using the tag
as an identifier for IO or memory mappings that was checked inside the api,
turn it into a pointer to a structure of function pointers. the api then
generally becomes a set of macros that deref the function pointers on the
callers behalf. the idea is that following a pointer to very small
functions is cheap compared to doing compares continuously.

a notable exception to the macro wrappers is bus_space_barrier which is now
a static inline function. the only argument to it that gets used is the
flags, and thats usually a constant at compile time so it can be inlined
to a single fence instruction.

the kernel is smaller and the api is more cache friendly now.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.25 2011/03/23 16:54:34 pirofti Exp $	*/
d146 4
d263 7
@


1.26
log
@implement bus_space_foo_8 for amd64. it will panic on attempts to do 8
byte operations on I/O space with "invalid I/O operation", but works great
for mem mappings.

compiled AND tested on myx(4) on amd64.
ok deraadt@@ kettenis@@ miod@@ pirofti@@
@
text
@a74 6
 * Values for the x86 bus space tag, not to be used directly by MI code.
 */
#define	X86_BUS_SPACE_IO	0	/* space is i/o space */
#define X86_BUS_SPACE_MEM	1	/* space is mem space */

/*
d83 2
a84 1
typedef	int bus_space_tag_t;
d127 2
d136 9
a144 11
u_int8_t	bus_space_read_1(bus_space_tag_t, bus_space_handle_t,
		    bus_size_t);

u_int16_t	bus_space_read_2(bus_space_tag_t, bus_space_handle_t,
		    bus_size_t);

u_int32_t	bus_space_read_4(bus_space_tag_t, bus_space_handle_t,
		    bus_size_t);

u_int64_t	bus_space_read_8(bus_space_tag_t, bus_space_handle_t,
		    bus_size_t);
d155 17
a171 11
void	bus_space_read_multi_1(bus_space_tag_t, bus_space_handle_t, bus_size_t,
	    u_int8_t *, bus_size_t);

void	bus_space_read_multi_2(bus_space_tag_t, bus_space_handle_t, bus_size_t,
	    u_int16_t *, bus_size_t);

void	bus_space_read_multi_4(bus_space_tag_t, bus_space_handle_t, bus_size_t,
	    u_int32_t *, bus_size_t);

void	bus_space_read_multi_8(bus_space_tag_t, bus_space_handle_t, bus_size_t,
	    u_int64_t *, bus_size_t);
d184 6
a189 6
#define	bus_space_read_raw_multi_2(t, h, o, a, c) \
    bus_space_read_multi_2((t), (h), (o), (u_int16_t *)(a), (c) >> 1)
#define	bus_space_read_raw_multi_4(t, h, o, a, c) \
    bus_space_read_multi_4((t), (h), (o), (u_int32_t *)(a), (c) >> 2)
#define	bus_space_read_raw_multi_8(t, h, o, a, c) \
    bus_space_read_multi_8((t), (h), (o), (u_int32_t *)(a), (c) >> 3)
d201 17
a217 8
void	bus_space_read_region_1(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, u_int8_t *, bus_size_t);
void	bus_space_read_region_2(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, u_int16_t *, bus_size_t);
void	bus_space_read_region_4(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, u_int32_t *, bus_size_t);
void	bus_space_read_region_8(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, u_int64_t *, bus_size_t);
d231 6
a236 6
#define	bus_space_read_raw_region_2(t, h, o, a, c) \
    bus_space_read_region_2((t), (h), (o), (u_int16_t *)(a), (c) >> 1)
#define	bus_space_read_raw_region_4(t, h, o, a, c) \
    bus_space_read_region_4((t), (h), (o), (u_int32_t *)(a), (c) >> 2)
#define	bus_space_read_raw_region_8(t, h, o, a, c) \
    bus_space_read_region_4((t), (h), (o), (u_int64_t *)(a), (c) >> 3)
d247 13
a259 8
void	bus_space_write_1(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, u_int8_t);
void	bus_space_write_2(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, u_int16_t);
void	bus_space_write_4(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, u_int32_t);
void	bus_space_write_8(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, u_int64_t);
d270 17
a286 8
void	bus_space_write_multi_1(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, const u_int8_t *, bus_size_t);
void	bus_space_write_multi_2(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, const u_int16_t *, bus_size_t);
void	bus_space_write_multi_4(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, const u_int32_t *, bus_size_t);
void	bus_space_write_multi_8(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, const u_int64_t *, bus_size_t);
d299 6
a304 6
#define	bus_space_write_raw_multi_2(t, h, o, a, c) \
    bus_space_write_multi_2((t), (h), (o), (const u_int16_t *)(a), (c) >> 1)
#define	bus_space_write_raw_multi_4(t, h, o, a, c) \
    bus_space_write_multi_4((t), (h), (o), (const u_int32_t *)(a), (c) >> 2)
#define	bus_space_write_raw_multi_8(t, h, o, a, c) \
    bus_space_write_multi_4((t), (h), (o), (const u_int64_t *)(a), (c) >> 3)
d315 17
a331 8
void	bus_space_write_region_1(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, const u_int8_t *, bus_size_t);
void	bus_space_write_region_2(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, const u_int16_t *, bus_size_t);
void	bus_space_write_region_4(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, const u_int32_t *, bus_size_t);
void	bus_space_write_region_8(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, const u_int64_t *, bus_size_t);
d345 6
a350 6
#define	bus_space_write_raw_region_2(t, h, o, a, c) \
    bus_space_write_region_2((t), (h), (o), (const u_int16_t *)(a), (c) >> 1)
#define	bus_space_write_raw_region_4(t, h, o, a, c) \
    bus_space_write_region_4((t), (h), (o), (const u_int32_t *)(a), (c) >> 2)
#define	bus_space_write_raw_region_8(t, h, o, a, c) \
    bus_space_write_region_8((t), (h), (o), (const u_int64_t *)(a), (c) >> 3)
d361 17
a377 8
void	bus_space_set_multi_1(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, u_int8_t, size_t);
void	bus_space_set_multi_2(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, u_int16_t, size_t);
void	bus_space_set_multi_4(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, u_int32_t, size_t);
void	bus_space_set_multi_8(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, u_int64_t, size_t);
d388 17
a404 8
void	bus_space_set_region_1(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, u_int8_t, size_t);
void	bus_space_set_region_2(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, u_int16_t, size_t);
void	bus_space_set_region_4(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, u_int32_t, size_t);
void	bus_space_set_region_8(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, u_int64_t, size_t);
d416 41
a456 8
void	bus_space_copy_1(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, bus_space_handle_t, bus_size_t, size_t);
void	bus_space_copy_2(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, bus_space_handle_t, bus_size_t, size_t);
void	bus_space_copy_4(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, bus_space_handle_t, bus_size_t, size_t);
void	bus_space_copy_8(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, bus_space_handle_t, bus_size_t, size_t);
d464 16
a479 2
void	bus_space_barrier(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, bus_size_t, int);
d486 13
a498 4
 *	void *bus_space_vaddr(bus_space_tag_t, bus_space_handle_t);
 *
 * Get the kernel virtual address for the mapped bus space.
 * Only allowed for regions mapped with BUS_SPACE_MAP_LINEAR.
d500 1
a500 2
#define bus_space_vaddr(t, h) \
	((t) == X86_BUS_SPACE_IO ? (void *)(NULL) : (void *)(h))
a746 9

/*      
 *      paddr_t bus_space_mmap(bus_space_tag_t t, bus_addr_t base,
 *          off_t offset, int prot, int flags);
 * 
 * Mmap an area of bus space.
 */
 
paddr_t bus_space_mmap(bus_space_tag_t, bus_addr_t, off_t, int, int);
@


1.25
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.24 2010/09/06 19:05:48 kettenis Exp $	*/
d148 2
a149 3
#if 0	/* Cause a link error for bus_space_read_8 */
#define	bus_space_read_8(t, h, o)	!!! bus_space_read_8 unimplemented !!!
#endif
d169 2
a170 3
#if 0	/* Cause a link error for bus_space_read_multi_8 */
#define	bus_space_read_multi_8	!!! bus_space_read_multi_8 unimplemented !!!
#endif
d187 2
a188 5

#if 0	/* Cause a link error for bus_space_read_raw_multi_8 */
#define	bus_space_read_raw_multi_8 \
    !!! bus_space_read_raw_multi_8 unimplemented !!!
#endif
d206 2
a207 5

#define bus_space_read_region_stream_1 bus_space_read_region_1
#if 0	/* Cause a link error for bus_space_read_region_8 */
#define	bus_space_read_region_8	!!! bus_space_read_region_8 unimplemented !!!
#endif
d225 2
a226 5

#if 0	/* Cause a link error for bus_space_read_raw_region_8 */
#define	bus_space_read_raw_region_8 \
    !!! bus_space_read_raw_region_8 unimplemented !!!
#endif
d243 2
a244 4

#if 0	/* Cause a link error for bus_space_write_8 */
#define	bus_space_write_8	!!! bus_space_write_8 not implemented !!!
#endif
d261 2
a262 5

#if 0	/* Cause a link error for bus_space_write_multi_8 */
#define	bus_space_write_multi_8(t, h, o, a, c)				\
			!!! bus_space_write_multi_8 unimplemented !!!
#endif
d279 2
a280 5

#if 0	/* Cause a link error for bus_space_write_raw_multi_8 */
#define	bus_space_write_raw_multi_8 \
    !!! bus_space_write_raw_multi_8 unimplemented !!!
#endif
d297 2
a298 5

#if 0	/* Cause a link error for bus_space_write_region_8 */
#define	bus_space_write_region_8					\
			!!! bus_space_write_region_8 unimplemented !!!
#endif
d316 2
a317 5

#if 0	/* Cause a link error for bus_space_write_raw_region_8 */
#define	bus_space_write_raw_region_8 \
    !!! bus_space_write_raw_region_8 unimplemented !!!
#endif
d334 2
a335 5

#if 0	/* Cause a link error for bus_space_set_multi_8 */
#define	bus_space_set_multi_8					\
			!!! bus_space_set_multi_8 unimplemented !!!
#endif
d352 2
a353 5

#if 0	/* Cause a link error for bus_space_set_region_8 */
#define	bus_space_set_region_8					\
			!!! bus_space_set_region_8 unimplemented !!!
#endif
d371 2
a372 5

#if 0	/* Cause a link error for bus_space_copy_8 */
#define	bus_space_copy_8					\
			!!! bus_space_copy_8 unimplemented !!!
#endif
@


1.24
log
@Make sure bus_dmamap_sync() always involves a function call, to prevent the
compiler from doing stupid things like reordering stores around it.  There is
some debate whether this will be enough for newer versions of GCC and LLVM.
If this is indeed deemed necessary, this will be addressed in a future diff.

ok miod@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.23 2010/04/08 00:55:25 oga Exp $	*/
d66 2
a67 2
#ifndef _X86_BUS_H_
#define _X86_BUS_H_
d685 1
a685 1
#endif /* _X86_BUS_H_ */
@


1.23
log
@On amd64, move the bus_dma buftype stuff that is only used by sg_dma
into the sg_dma code instead of main bus_dma. Add identical code to i386
since this will be used in the next commit.

ok kettenis@@ back in december.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.22 2010/04/04 12:49:30 miod Exp $	*/
d546 1
a546 2
	(void)((t)->_dmamap_sync ?				\
	    (*(t)->_dmamap_sync)((t), (p), (o), (l), (ops)) : (void)0)
@


1.22
log
@OpenBSD uses bus_space_copy_#, not bus_space_copy_region_#. Make sure only the
first name is used, and remove any #define foo_region foo compatibility
defines.
Also, on sparc64, do not provide a `raw' version of bus_space_copy.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.21 2009/07/30 21:39:15 miod Exp $	*/
d70 1
a574 5
	void		*_dm_origbuf;	/* pointer to original data */
	int		_dm_buftype;	/* type of data */
	/* XXX do we REALLY need the proc stuff */
	struct proc	*_dm_proc;	/* proc that owns the mapping */

d624 1
d628 24
@


1.21
log
@Get rid of the obsolet BUS_BARRIER_xxx constants for bus_space_barrier(), only
provide and use BUS_SPACE_BARRIER_xxx.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.20 2009/07/26 18:48:55 miod Exp $	*/
d395 1
a395 6
#define bus_space_copy_1 bus_space_copy_region_1
#define bus_space_copy_2 bus_space_copy_region_2
#define bus_space_copy_4 bus_space_copy_region_4
#define bus_space_copy_8 bus_space_copy_region_8

void	bus_space_copy_region_1(bus_space_tag_t, bus_space_handle_t,
d397 1
a397 1
void	bus_space_copy_region_2(bus_space_tag_t, bus_space_handle_t,
d399 1
a399 1
void	bus_space_copy_region_4(bus_space_tag_t, bus_space_handle_t,
@


1.20
log
@Make sure all platforms understand the flags argument of bus_space_map() and
bus_space_alloc() as a bitmask of flags, and not a boolean controlling
cacheability; and make sure the three MI BUS_SPACE_MAP_xxx values documented
in the manual page are defined on all platforms as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.19 2009/06/07 02:30:34 oga Exp $	*/
a416 3
/* Compatibility defines */
#define	BUS_BARRIER_READ	BUS_SPACE_BARRIER_READ
#define	BUS_BARRIER_WRITE	BUS_SPACE_BARRIER_WRITE
@


1.19
log
@on amd64, store a pointer to the loaded data and the type. This will
eventually be needed by bouncebuffers, and I need it for some of my evil
graphics shitz.

ok kettenis@@ with some tweaks
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.18 2009/05/10 15:04:48 oga Exp $	*/
d118 1
a118 1
	    bus_size_t size, int cacheable, bus_space_handle_t *bshp);
@


1.18
log
@When I changed the implementation of iommu and sg_dma over to use
bus_addr_t instead of vaddr_t i forgot the bind_page prototypes. So
change them over, too.

This shows it really was just pedantry since it still built and worked.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.17 2009/04/21 17:05:29 oga Exp $	*/
d454 7
d581 5
@


1.17
log
@add a sg_dma backend for amd64 bus_dma. This is a lot more clever about
mapping to the gart than the old code, and shouldn't conflict with
bouncebuffers when they're added.

This is essentially the sparc64 iommu code that's been modularised a bit
so I can eventually use the same code for agp-based dma for memory
managed drm drivers.

Now, this would overflow ramdiskA, so iommu and sg_dma are now #ifndef
SMALL_KERNEL.

ok kettenis@@, marco@@. SMALL_KERNEL discussions with deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.16 2009/04/20 00:42:05 oga Exp $	*/
d624 2
a625 2
	void		(*bind_page)(void *, vaddr_t, paddr_t, int);
	void		(*unbind_page)(void *, vaddr_t);
@


1.16
log
@Add a BUS_DMA_ZERO flag for bus_dmamem_alloc() to return zeroed memory.

Saves every damned driver calling bzero(), and continues the M_ZERO,
PR_ZERO symmetry.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.15 2009/03/10 15:03:16 oga Exp $	*/
d69 2
d452 1
d479 7
d616 35
@


1.15
log
@remove the _BUS_DMA_PRIVATE define from amd64 and i386.

a define needed to get to ``private'' functions that needs to be defined
5 or more times isn't much use and may cause namespace issues anyway.
Other archs will probably follow.

Discussed in portugal.  "Hell yes" weingart@@, ok kettenis@@, no
objections miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.14 2009/02/05 01:15:20 oga Exp $	*/
d437 13
a449 12
#define	BUS_DMA_WAITOK		0x000	/* safe to sleep (pseudo-flag) */
#define	BUS_DMA_NOWAIT		0x001	/* not safe to sleep */
#define	BUS_DMA_ALLOCNOW	0x002	/* perform resource allocation now */
#define	BUS_DMA_COHERENT	0x004	/* hint: map memory DMA coherent */
#define	BUS_DMA_BUS1		0x010	/* placeholders for bus functions... */
#define	BUS_DMA_BUS2		0x020
#define	BUS_DMA_32BIT		0x040
#define	BUS_DMA_24BIT		0x080	/* isadma map */
#define	BUS_DMA_STREAMING	0x100	/* hint: sequential, unidirectional */
#define	BUS_DMA_READ		0x200	/* mapping is device -> memory only */
#define	BUS_DMA_WRITE		0x400	/* mapping is memory -> device only */
#define	BUS_DMA_NOCACHE		0x800	/* map memory uncached */
@


1.14
log
@Mirroring the i386 commit just made. Add MD PMAP_NOCACHE flag to pmap,
and use it to implement BUS_DMA_NOCACHE for uncached mappings of dma
memory. Needed for some broken hardware.

Discussion with art, miod, kettenis and toby, ok miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.13 2008/12/03 15:46:06 oga Exp $	*/
a573 1
#ifdef _BUS_DMA_PRIVATE
a613 3
            

#endif /* _BUS_DMA_PRIVATE */
@


1.13
log
@Remove the x86 and i386 prefixes to the bus_dma types. It's really quite
pointless and just makes the code different for no reason. This moves i386 and
amd64 bus_dma to being a lot closer to identical.

suggestion to just remove the prefix instead of merge them from deraadt@@.

no objections art@@, kettenis@@, ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.12 2008/11/22 17:45:20 oga Exp $	*/
d448 1
@


1.12
log
@same change as for amd64. Move bus_space_* functions from inlines and
defines into real functions. since machdep.c is cluttered as it is move them
into bus_space.c (like amd64). a later commit will move the stuff from machdep
across too. since machdep.c is cluttered as it is move them into bus_space.c
(like amd64). a later commit will move the stuff from machdep across too.

some shrinkage stats:
GENERIC.MP 209.66kb
RAMDISK 50.84kb
RAMDISKB 50.04kb
RAMDISC 36.28kb
RAMDISK_CD 168.03kb

don't fill it up all at once!

claudio found no network performance hit. toby thought the code went
looked alright. art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.11 2008/11/21 23:16:16 oga Exp $	*/
d462 2
a463 2
typedef struct x86_bus_dma_tag		*bus_dma_tag_t;
typedef struct x86_bus_dmamap		*bus_dmamap_t;
d471 1
a471 1
struct x86_bus_dma_segment {
d475 1
a475 1
typedef struct x86_bus_dma_segment	bus_dma_segment_t;
d484 1
a484 1
struct x86_bus_dma_tag {
d553 1
a553 1
struct x86_bus_dmamap {
d573 1
a573 1
#ifdef _X86_BUS_DMA_PRIVATE
d616 1
a616 1
#endif /* _X86_BUS_DMA_PRIVATE */
@


1.11
log
@de-inline the bus_space_* functions in favour of real functions

This shaves 135.7kb from amd64 GENERIC.MP. An afternoons worth of
testing proved to art, toby and myself that this doesn't slow things
down. i386 will follow shortly.

ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.10 2008/06/26 05:42:09 ray Exp $	*/
a203 1

a246 1

a248 1

a312 1

@


1.10
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.9 2008/06/10 02:55:39 weingart Exp $	*/
d136 2
d139 5
a143 11
#define	bus_space_read_1(t, h, o)					\
	((t) == X86_BUS_SPACE_IO ? (inb((h) + (o))) :			\
	    (*(volatile u_int8_t *)((h) + (o))))

#define	bus_space_read_2(t, h, o)					\
	((t) == X86_BUS_SPACE_IO ? (inw((h) + (o))) :			\
	    (*(volatile u_int16_t *)((h) + (o))))

#define	bus_space_read_4(t, h, o)					\
	((t) == X86_BUS_SPACE_IO ? (inl((h) + (o))) :			\
	    (*(volatile u_int32_t *)((h) + (o))))
d158 8
a165 59
#define	bus_space_read_multi_1(t, h, o, ptr, cnt)			\
do {									\
	if ((t) == X86_BUS_SPACE_IO) {					\
		insb((h) + (o), (ptr), (cnt));				\
	} else {							\
		void *dummy1;						\
		int dummy2;						\
		void *dummy3;						\
		int __x;						\
		__asm __volatile("					\
			cld					;	\
		1:	movb (%2),%%al				;	\
			stosb					;	\
			loop 1b"				: 	\
		    "=D" (dummy1), "=c" (dummy2), "=r" (dummy3), "=&a" (__x) : \
		    "0" ((ptr)), "1" ((cnt)), "2" ((h) + (o))       :	\
		    "memory");						\
	}								\
} while (/* CONSTCOND */ 0)

#define	bus_space_read_multi_2(t, h, o, ptr, cnt)			\
do {									\
	if ((t) == X86_BUS_SPACE_IO) {					\
		insw((h) + (o), (ptr), (cnt));				\
	} else {							\
		void *dummy1;						\
		int dummy2;						\
		void *dummy3;						\
		int __x;						\
		__asm __volatile("					\
			cld					;	\
		1:	movw (%2),%%ax				;	\
			stosw					;	\
			loop 1b"				:	\
		    "=D" (dummy1), "=c" (dummy2), "=r" (dummy3), "=&a" (__x) : \
		    "0" ((ptr)), "1" ((cnt)), "2" ((h) + (o))       :	\
		    "memory");						\
	}								\
} while (/* CONSTCOND */ 0)

#define	bus_space_read_multi_4(t, h, o, ptr, cnt)			\
do {									\
	if ((t) == X86_BUS_SPACE_IO) {					\
		insl((h) + (o), (ptr), (cnt));				\
	} else {							\
		void *dummy1;						\
		int dummy2;						\
		void *dummy3;						\
		int __x;						\
		__asm __volatile("					\
			cld					;	\
		1:	movl (%2),%%eax				;	\
			stosl					;	\
			loop 1b"				:	\
		    "=D" (dummy1), "=c" (dummy2), "=r" (dummy3), "=&a" (__x) : \
		    "0" ((ptr)), "1" ((cnt)), "2" ((h) + (o))       :       \
		    "memory");						\
	}								\
} while (/* CONSTCOND */ 0)
d202 7
a208 92
#define	bus_space_read_region_1(t, h, o, ptr, cnt)			\
do {									\
	if ((t) == X86_BUS_SPACE_IO) {					\
		int dummy1;						\
		void *dummy2;						\
		int dummy3;						\
		int __x;						\
		__asm __volatile("					\
			cld					;	\
		1:	inb %w1,%%al				;	\
			stosb					;	\
			incl %1					;	\
			loop 1b"				: 	\
		    "=&a" (__x), "=d" (dummy1), "=D" (dummy2),		\
		    "=c" (dummy3)				:	\
		    "1" ((h) + (o)), "2" ((ptr)), "3" ((cnt))	:	\
		    "memory");						\
	} else {							\
		int dummy1;						\
		void *dummy2;						\
		int dummy3;						\
		__asm __volatile("					\
			cld					;	\
			repne					;	\
			movsb"					:	\
		    "=S" (dummy1), "=D" (dummy2), "=c" (dummy3)	:	\
		    "0" ((h) + (o)), "1" ((ptr)), "2" ((cnt))	:	\
		    "memory");						\
	}								\
} while (/* CONSTCOND */ 0)

#define	bus_space_read_region_2(t, h, o, ptr, cnt)			\
do {									\
	if ((t) == X86_BUS_SPACE_IO) {					\
		int dummy1;						\
		void *dummy2;						\
		int dummy3;						\
		int __x;						\
		__asm __volatile("					\
			cld					;	\
		1:	inw %w1,%%ax				;	\
			stosw					;	\
			addl $2,%1				;	\
			loop 1b"				: 	\
		    "=&a" (__x), "=d" (dummy1), "=D" (dummy2),		\
		    "=c" (dummy3)				:	\
		    "1" ((h) + (o)), "2" ((ptr)), "3" ((cnt))	:	\
		    "memory");						\
	} else {							\
		int dummy1;						\
		void *dummy2;						\
		int dummy3;						\
		__asm __volatile("					\
			cld					;	\
			repne					;	\
			movsw"					:	\
		    "=S" (dummy1), "=D" (dummy2), "=c" (dummy3)	:	\
		    "0" ((h) + (o)), "1" ((ptr)), "2" ((cnt))	:	\
		    "memory");						\
	}								\
} while (/* CONSTCOND */ 0)

#define	bus_space_read_region_4(t, h, o, ptr, cnt)			\
do {									\
	if ((t) == X86_BUS_SPACE_IO) {					\
		int dummy1;						\
		void *dummy2;						\
		int dummy3;						\
		int __x;						\
		__asm __volatile("					\
			cld					;	\
		1:	inl %w1,%%eax				;	\
			stosl					;	\
			addl $4,%1				;	\
			loop 1b"				: 	\
		    "=&a" (__x), "=d" (dummy1), "=D" (dummy2),		\
		    "=c" (dummy3)				:	\
		    "1" ((h) + (o)), "2" ((ptr)), "3" ((cnt))	:	\
		    "memory");						\
	} else {							\
		int dummy1;						\
		void *dummy2;						\
		int dummy3;						\
		__asm __volatile("					\
			cld					;	\
			repne					;	\
			movsl"					:	\
		    "=S" (dummy1), "=D" (dummy2), "=c" (dummy3)	:	\
		    "0" ((h) + (o)), "1" ((ptr)), "2" ((cnt))	:	\
		    "memory");						\
	}								\
} while (/* CONSTCOND */ 0)
d246 8
a253 20
#define	bus_space_write_1(t, h, o, v)	do {				\
	if ((t) == X86_BUS_SPACE_IO)					\
		outb((h) + (o), (v));					\
	else								\
		((void)(*(volatile u_int8_t *)((h) + (o)) = (v)));	\
} while (0)

#define	bus_space_write_2(t, h, o, v)	do {				\
	if ((t) == X86_BUS_SPACE_IO)					\
		outw((h) + (o), (v));					\
	else								\
		((void)(*(volatile u_int16_t *)((h) + (o)) = (v)));	\
} while (0)

#define	bus_space_write_4(t, h, o, v)	do {				\
	if ((t) == X86_BUS_SPACE_IO)					\
		outl((h) + (o), (v));					\
	else								\
		((void)(*(volatile u_int32_t *)((h) + (o)) = (v)));	\
} while (0)
d268 6
a273 56
#define	bus_space_write_multi_1(t, h, o, ptr, cnt)			\
do {									\
	if ((t) == X86_BUS_SPACE_IO) {					\
		outsb((h) + (o), (ptr), (cnt));				\
	} else {							\
		void *dummy1;						\
		int dummy2;						\
		void *dummy3;						\
		int __x;						\
		__asm __volatile("					\
			cld					;	\
		1:	lodsb					;	\
			movb %%al,(%2)				;	\
			loop 1b"				: 	\
		    "=S" (dummy1), "=c" (dummy2), "=r" (dummy3), "=&a" (__x) : \
		    "0" ((ptr)), "1" ((cnt)), "2" ((h) + (o)));		\
	}								\
} while (/* CONSTCOND */ 0)

#define bus_space_write_multi_2(t, h, o, ptr, cnt)			\
do {									\
	if ((t) == X86_BUS_SPACE_IO) {					\
		outsw((h) + (o), (ptr), (cnt));				\
	} else {							\
		void *dummy1;						\
		int dummy2;						\
		void *dummy3;						\
		int __x;						\
		__asm __volatile("					\
			cld					;	\
		1:	lodsw					;	\
			movw %%ax,(%2)				;	\
			loop 1b"				: 	\
		    "=S" (dummy1), "=c" (dummy2), "=r" (dummy3), "=&a" (__x) : \
		    "0" ((ptr)), "1" ((cnt)), "2" ((h) + (o)));		\
	}								\
} while (/* CONSTCOND */ 0)

#define bus_space_write_multi_4(t, h, o, ptr, cnt)			\
do {									\
	if ((t) == X86_BUS_SPACE_IO) {					\
		outsl((h) + (o), (ptr), (cnt));				\
	} else {							\
		void *dummy1;						\
		int dummy2;						\
		void *dummy3;						\
		int __x;						\
		__asm __volatile("					\
			cld					;	\
		1:	lodsl					;	\
			movl %%eax,(%2)				;	\
			loop 1b"				: 	\
		    "=S" (dummy1), "=c" (dummy2), "=r" (dummy3), "=&a" (__x) : \
		    "0" ((ptr)), "1" ((cnt)), "2" ((h) + (o)));		\
	}								\
} while (/* CONSTCOND */ 0)
d310 7
a316 92
#define	bus_space_write_region_1(t, h, o, ptr, cnt)			\
do {									\
	if ((t) == X86_BUS_SPACE_IO) {					\
		int dummy1;						\
		void *dummy2;						\
		int dummy3;						\
		int __x;						\
		__asm __volatile("					\
			cld					;	\
		1:	lodsb					;	\
			outb %%al,%w1				;	\
			incl %1					;	\
			loop 1b"				: 	\
		    "=&a" (__x), "=d" (dummy1), "=S" (dummy2),		\
		    "=c" (dummy3)				:	\
		    "1" ((h) + (o)), "2" ((ptr)), "3" ((cnt))	:	\
		    "memory");						\
	} else {							\
		int dummy1;						\
		void *dummy2;						\
		int dummy3;						\
		__asm __volatile("					\
			cld					;	\
			repne					;	\
			movsb"					:	\
		    "=D" (dummy1), "=S" (dummy2), "=c" (dummy3)	:	\
		    "0" ((h) + (o)), "1" ((ptr)), "2" ((cnt))	:	\
		    "memory");						\
	}								\
} while (/* CONSTCOND */ 0)

#define	bus_space_write_region_2(t, h, o, ptr, cnt)			\
do {									\
	if ((t) == X86_BUS_SPACE_IO) {					\
		int dummy1;						\
		void *dummy2;						\
		int dummy3;						\
		int __x;						\
		__asm __volatile("					\
			cld					;	\
		1:	lodsw					;	\
			outw %%ax,%w1				;	\
			addl $2,%1				;	\
			loop 1b"				: 	\
		    "=&a" (__x), "=d" (dummy1), "=S" (dummy2),		\
		    "=c" (dummy3)				:	\
		    "1" ((h) + (o)), "2" ((ptr)), "3" ((cnt))	:	\
		    "memory");						\
	} else {							\
		int dummy1;						\
		void *dummy2;						\
		int dummy3;						\
		__asm __volatile("					\
			cld					;	\
			repne					;	\
			movsw"					:	\
		    "=D" (dummy1), "=S" (dummy2), "=c" (dummy3)	:	\
		    "0" ((h) + (o)), "1" ((ptr)), "2" ((cnt))	:	\
		    "memory");						\
	}								\
} while (/* CONSTCOND */ 0)

#define	bus_space_write_region_4(t, h, o, ptr, cnt)			\
do {									\
	if ((t) == X86_BUS_SPACE_IO) {					\
		int dummy1;						\
		void *dummy2;						\
		int dummy3;						\
		int __x;						\
		__asm __volatile("					\
			cld					;	\
		1:	lodsl					;	\
			outl %%eax,%w1				;	\
			addl $4,%1				;	\
			loop 1b"				: 	\
		    "=&a" (__x), "=d" (dummy1), "=S" (dummy2),		\
		    "=c" (dummy3)				:	\
		    "1" ((h) + (o)), "2" ((ptr)), "3" ((cnt))	:	\
		    "memory");						\
	} else {							\
		int dummy1;						\
		void *dummy2;						\
		int dummy3;						\
		__asm __volatile("					\
			cld					;	\
			repne					;	\
			movsl"					:	\
		    "=D" (dummy1), "=S" (dummy2), "=c" (dummy3)	:	\
		    "0" ((h) + (o)), "1" ((ptr)), "2" ((cnt))	:	\
		    "memory");						\
	}								\
} while (/* CONSTCOND */ 0)
d354 6
a359 48
static __inline void bus_space_set_multi_1(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, u_int8_t, size_t);
static __inline void bus_space_set_multi_2(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, u_int16_t, size_t);
static __inline void bus_space_set_multi_4(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, u_int32_t, size_t);

static __inline void
bus_space_set_multi_1(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
    u_int8_t v, size_t c)
{
	bus_addr_t addr = h + o;

	if (t == X86_BUS_SPACE_IO)
		while (c--)
			outb(addr, v);
	else
		while (c--)
			*(volatile u_int8_t *)(addr) = v;
}

static __inline void
bus_space_set_multi_2(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
    u_int16_t v, size_t c)
{
	bus_addr_t addr = h + o;

	if (t == X86_BUS_SPACE_IO)
		while (c--)
			outw(addr, v);
	else
		while (c--)
			*(volatile u_int16_t *)(addr) = v;
}

static __inline void
bus_space_set_multi_4(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
    u_int32_t v, size_t c)
{
	bus_addr_t addr = h + o;

	if (t == X86_BUS_SPACE_IO)
		while (c--)
			outl(addr, v);
	else
		while (c--)
			*(volatile u_int32_t *)(addr) = v;
}
d375 6
a380 48
static __inline void bus_space_set_region_1(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, u_int8_t, size_t);
static __inline void bus_space_set_region_2(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, u_int16_t, size_t);
static __inline void bus_space_set_region_4(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, u_int32_t, size_t);

static __inline void
bus_space_set_region_1(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
    u_int8_t v, size_t c)
{
	bus_addr_t addr = h + o;

	if (t == X86_BUS_SPACE_IO)
		for (; c != 0; c--, addr++)
			outb(addr, v);
	else
		for (; c != 0; c--, addr++)
			*(volatile u_int8_t *)(addr) = v;
}

static __inline void
bus_space_set_region_2(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
    u_int16_t v, size_t c)
{
	bus_addr_t addr = h + o;

	if (t == X86_BUS_SPACE_IO)
		for (; c != 0; c--, addr += 2)
			outw(addr, v);
	else
		for (; c != 0; c--, addr += 2)
			*(volatile u_int16_t *)(addr) = v;
}

static __inline void
bus_space_set_region_4(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
    u_int32_t v, size_t c)
{
	bus_addr_t addr = h + o;

	if (t == X86_BUS_SPACE_IO)
		for (; c != 0; c--, addr += 4)
			outl(addr, v);
	else
		for (; c != 0; c--, addr += 4)
			*(volatile u_int32_t *)(addr) = v;
}
d402 6
a407 114
static __inline void bus_space_copy_region_1(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, bus_space_handle_t,
	bus_size_t, size_t);
static __inline void bus_space_copy_region_2(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, bus_space_handle_t,
	bus_size_t, size_t);
static __inline void bus_space_copy_region_4(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, bus_space_handle_t,
	bus_size_t, size_t);

static __inline void
bus_space_copy_region_1(bus_space_tag_t t,
    bus_space_handle_t h1, bus_size_t o1,
    bus_space_handle_t h2, bus_size_t o2, size_t c)
{
	bus_addr_t addr1 = h1 + o1;
	bus_addr_t addr2 = h2 + o2;

	if (t == X86_BUS_SPACE_IO) {
		if (addr1 >= addr2) {
			/* src after dest: copy forward */
			for (; c != 0; c--, addr1++, addr2++)
				outb(addr2, inb(addr1));
		} else {
			/* dest after src: copy backwards */
			for (addr1 += (c - 1), addr2 += (c - 1);
			    c != 0; c--, addr1--, addr2--)
				outb(addr2, inb(addr1));
		}
	} else {
		if (addr1 >= addr2) {
			/* src after dest: copy forward */
			for (; c != 0; c--, addr1++, addr2++)
				*(volatile u_int8_t *)(addr2) =
				    *(volatile u_int8_t *)(addr1);
		} else {
			/* dest after src: copy backwards */
			for (addr1 += (c - 1), addr2 += (c - 1);
			    c != 0; c--, addr1--, addr2--)
				*(volatile u_int8_t *)(addr2) =
				    *(volatile u_int8_t *)(addr1);
		}
	}
}

static __inline void
bus_space_copy_region_2(bus_space_tag_t t,
    bus_space_handle_t h1, bus_size_t o1,
    bus_space_handle_t h2, bus_size_t o2, size_t c)
{
	bus_addr_t addr1 = h1 + o1;
	bus_addr_t addr2 = h2 + o2;

	if (t == X86_BUS_SPACE_IO) {
		if (addr1 >= addr2) {
			/* src after dest: copy forward */
			for (; c != 0; c--, addr1 += 2, addr2 += 2)
				outw(addr2, inw(addr1));
		} else {
			/* dest after src: copy backwards */
			for (addr1 += 2 * (c - 1), addr2 += 2 * (c - 1);
			    c != 0; c--, addr1 -= 2, addr2 -= 2)
				outw(addr2, inw(addr1));
		}
	} else {
		if (addr1 >= addr2) {
			/* src after dest: copy forward */
			for (; c != 0; c--, addr1 += 2, addr2 += 2)
				*(volatile u_int16_t *)(addr2) =
				    *(volatile u_int16_t *)(addr1);
		} else {
			/* dest after src: copy backwards */
			for (addr1 += 2 * (c - 1), addr2 += 2 * (c - 1);
			    c != 0; c--, addr1 -= 2, addr2 -= 2)
				*(volatile u_int16_t *)(addr2) =
				    *(volatile u_int16_t *)(addr1);
		}
	}
}

static __inline void
bus_space_copy_region_4(bus_space_tag_t t,
    bus_space_handle_t h1, bus_size_t o1,
    bus_space_handle_t h2, bus_size_t o2, size_t c)
{
	bus_addr_t addr1 = h1 + o1;
	bus_addr_t addr2 = h2 + o2;

	if (t == X86_BUS_SPACE_IO) {
		if (addr1 >= addr2) {
			/* src after dest: copy forward */
			for (; c != 0; c--, addr1 += 4, addr2 += 4)
				outl(addr2, inl(addr1));
		} else {
			/* dest after src: copy backwards */
			for (addr1 += 4 * (c - 1), addr2 += 4 * (c - 1);
			    c != 0; c--, addr1 -= 4, addr2 -= 4)
				outl(addr2, inl(addr1));
		}
	} else {
		if (addr1 >= addr2) {
			/* src after dest: copy forward */
			for (; c != 0; c--, addr1 += 4, addr2 += 4)
				*(volatile u_int32_t *)(addr2) =
				    *(volatile u_int32_t *)(addr1);
		} else {
			/* dest after src: copy backwards */
			for (addr1 += 4 * (c - 1), addr2 += 4 * (c - 1);
			    c != 0; c--, addr1 -= 4, addr2 -= 4)
				*(volatile u_int32_t *)(addr2) =
				    *(volatile u_int32_t *)(addr1);
		}
	}
}
d423 2
a424 11
static __inline void
bus_space_barrier(bus_space_tag_t tag, bus_space_handle_t bsh,
    bus_size_t offset, bus_size_t len, int flags)
{
	if (flags == (BUS_SPACE_BARRIER_READ|BUS_SPACE_BARRIER_WRITE))
		__asm __volatile("mfence");
	else if (flags == BUS_SPACE_BARRIER_WRITE)
		__asm __volatile("sfence");
	else
		__asm __volatile("lfence");
}
@


1.9
log
@All your memory belong to us.  This has been in snaps for a while,
and seems to work.  If it breaks, people had plenty of chances to
complain.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.8 2007/11/16 16:16:07 deraadt Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.8
log
@fix the bus_space #define nightmare, so that amd64 and i386 are much more
uniform. as a result shared code like acpi needs less #ifdef's
ok marco kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.7 2007/09/01 03:41:17 marco Exp $	*/
d942 1
a942 1
#define	BUS_DMA_BUS3		0x040
@


1.7
log
@Remove stale comments; prompted by millert.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.6 2007/08/31 20:11:09 marco Exp $	*/
d96 1
a96 6
#define	bus_space_map(t, a, s, f, hp)	x86_memio_map((t),(a),(s),(f),(hp))
#define	bus_space_unmap(t, h, s)	x86_memio_unmap((t),(h),(s))
#define bus_space_subregion(t, h, o, s, nhp)	\
    x86_memio_subregion((t), (h), (o), (s), (nhp))

int	x86_memio_map(bus_space_tag_t t, bus_addr_t addr,
d99 1
a99 1
int	_x86_memio_map(bus_space_tag_t t, bus_addr_t addr,
d102 1
a102 3
#define	bus_space_alloc(t,beg,end,sz,align,bound,flag,addrp,h) \
    x86_memio_alloc((t),(beg),(end),(sz),(align),(bound),(flag),(addrp),(h))
int	x86_memio_alloc(bus_space_tag_t t, bus_addr_t rstart,
d106 1
a106 2
#define	bus_space_free(t,h,z)	x86_memio_free((t),(h),(z))
void	x86_memio_free(bus_space_tag_t t, bus_space_handle_t bsh,  
d116 1
a116 1
void	x86_memio_unmap(bus_space_tag_t t, bus_space_handle_t bsh,
d118 1
a118 1
void	_x86_memio_unmap(bus_space_tag_t t, bus_space_handle_t bsh,
d133 1
a133 1
int	x86_memio_subregion(bus_space_tag_t t, bus_space_handle_t bsh,
d648 1
a648 1
static __inline void x86_memio_set_multi_1(bus_space_tag_t,
d650 1
a650 1
static __inline void x86_memio_set_multi_2(bus_space_tag_t,
d652 1
a652 1
static __inline void x86_memio_set_multi_4(bus_space_tag_t,
a654 9
#define	bus_space_set_multi_1(t, h, o, v, c)				\
	x86_memio_set_multi_1((t), (h), (o), (v), (c))

#define	bus_space_set_multi_2(t, h, o, v, c)				\
	x86_memio_set_multi_2((t), (h), (o), (v), (c))

#define	bus_space_set_multi_4(t, h, o, v, c)				\
	x86_memio_set_multi_4((t), (h), (o), (v), (c))

d656 1
a656 1
x86_memio_set_multi_1(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
d670 1
a670 1
x86_memio_set_multi_2(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
d684 1
a684 1
x86_memio_set_multi_4(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
d711 1
a711 1
static __inline void x86_memio_set_region_1(bus_space_tag_t,
d713 1
a713 1
static __inline void x86_memio_set_region_2(bus_space_tag_t,
d715 1
a715 1
static __inline void x86_memio_set_region_4(bus_space_tag_t,
a717 9
#define	bus_space_set_region_1(t, h, o, v, c)				\
	x86_memio_set_region_1((t), (h), (o), (v), (c))

#define	bus_space_set_region_2(t, h, o, v, c)				\
	x86_memio_set_region_2((t), (h), (o), (v), (c))

#define	bus_space_set_region_4(t, h, o, v, c)				\
	x86_memio_set_region_4((t), (h), (o), (v), (c))

d719 1
a719 1
x86_memio_set_region_1(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
d733 1
a733 1
x86_memio_set_region_2(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
d747 1
a747 1
x86_memio_set_region_4(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
d780 1
a780 1
static __inline void x86_memio_copy_region_1(bus_space_tag_t,
d783 1
a783 1
static __inline void x86_memio_copy_region_2(bus_space_tag_t,
d786 1
a786 1
static __inline void x86_memio_copy_region_4(bus_space_tag_t,
a789 9
#define	bus_space_copy_region_1(t, h1, o1, h2, o2, c)			\
	x86_memio_copy_region_1((t), (h1), (o1), (h2), (o2), (c))

#define	bus_space_copy_region_2(t, h1, o1, h2, o2, c)			\
	x86_memio_copy_region_2((t), (h1), (o1), (h2), (o2), (c))

#define	bus_space_copy_region_4(t, h1, o1, h2, o2, c)			\
	x86_memio_copy_region_4((t), (h1), (o1), (h2), (o2), (c))

d791 1
a791 1
x86_memio_copy_region_1(bus_space_tag_t t,
d826 1
a826 1
x86_memio_copy_region_2(bus_space_tag_t t,
d861 1
a861 1
x86_memio_copy_region_4(bus_space_tag_t t,
d1112 1
a1112 1
paddr_t x86_memio_mmap(bus_space_tag_t, bus_addr_t, off_t, int, int);
@


1.6
log
@Add vaddr.

ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.5 2006/04/27 15:17:12 mickey Exp $	*/
a964 1
 *  (XXX not enforced)
@


1.5
log
@from PAE work:
add a BUS_DMA_24BIT flag to signify that dmamap being created
is for the isadma use (thus already backed up by the bounce
buffers). later also to be used for dmamem allocation.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.4 2005/11/05 18:29:24 marco Exp $	*/
d956 13
@


1.4
log
@Add bus_space_alloc and _free.

from jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.3 2005/05/25 18:29:58 jason Exp $	*/
d966 1
a966 1
#define	BUS_DMA_BUS4		0x080
@


1.3
log
@comment typo
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.2 2004/02/23 06:29:54 mickey Exp $	*/
d107 10
a132 7
int	bus_space_alloc(bus_space_tag_t t, bus_addr_t rstart,
	    bus_addr_t rend, bus_size_t size, bus_size_t align,
	    bus_size_t boundary, int cacheable, bus_addr_t *addrp,
	    bus_space_handle_t *bshp);
void	bus_space_free(bus_space_tag_t t, bus_space_handle_t bsh,
	    bus_size_t size);

a1126 24

/* 
 *      int bus_space_alloc(bus_space_tag_t t, bus_addr_t rstart,
 *          bus_addr_t rend, bus_size_t size, bus_size_t align,
 *          bus_size_t boundary, int flags, bus_addr_t *addrp,
 *          bus_space_handle_t *bshp);
 *
 * Allocate a region of bus space.      
 */
 
int	x86_memio_alloc(bus_space_tag_t t, bus_addr_t rstart,
	    bus_addr_t rend, bus_size_t size, bus_size_t align,
	    bus_size_t boundary, int flags, bus_addr_t *addrp,
	    bus_space_handle_t *bshp);

/*          
 *      int bus_space_free(bus_space_tag_t t,
 *          bus_space_handle_t bsh, bus_size_t size);
 * 
 * Free a region of bus space.
 */
 
void	x86_memio_free(bus_space_tag_t t, bus_space_handle_t bsh,  
	    bus_size_t size);
@


1.2
log
@provide _barrier method w/ {l,s,m}fence instructions
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.1 2004/01/28 01:39:39 mickey Exp $	*/
d1074 1
a1074 1
	 * PRIVATE MEMBERS: not for use my machine-independent code.
@


1.1
log
@an amd64 arch support.
hacked by art@@ from netbsd sources and then later debugged
by me into the shape where it can host itself.
no bootloader yet as needs redoing from the
recent advanced i386 sources (anyone? ;)
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.35 2003/04/17 03:42:14 drahn Exp $	*/
a933 7
 *
 *	void bus_space_barrier(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    bus_size_t len, int flags);
 *
 * Note: the x86 does not currently require barriers, but we must
 * provide the flags to MI code.
a934 2
#define	bus_space_barrier(t, h, o, l, f)	\
	((void)((void)(t), (void)(h), (void)(o), (void)(l), (void)(f)))
d940 12
@


1.1.2.1
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d934 7
d942 2
a948 12

static __inline void
bus_space_barrier(bus_space_tag_t tag, bus_space_handle_t bsh,
    bus_size_t offset, bus_size_t len, int flags)
{
	if (flags == (BUS_SPACE_BARRIER_READ|BUS_SPACE_BARRIER_WRITE))
		__asm __volatile("mfence");
	else if (flags == BUS_SPACE_BARRIER_WRITE)
		__asm __volatile("sfence");
	else
		__asm __volatile("lfence");
}
@


