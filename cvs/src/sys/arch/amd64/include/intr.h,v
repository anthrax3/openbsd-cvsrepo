head	1.29;
access;
symbols
	OPENBSD_6_1:1.29.0.6
	OPENBSD_6_1_BASE:1.29
	OPENBSD_6_0:1.29.0.4
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.28.0.4
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.26.0.4
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.25.0.6
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.25.0.2
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.23.0.8
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.6
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.4
	OPENBSD_5_0:1.23.0.2
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.21.0.2
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.19.0.2
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.17.0.4
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.15.0.2
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.11.0.4
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.2
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.6.0.6
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.2
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.2
	SMP_SYNC_B:1.2
	OPENBSD_3_5:1.1.0.4
	OPENBSD_3_5_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.29
date	2015.09.13.11.48.17;	author kettenis;	state Exp;
branches;
next	1.28;
commitid	bJgsm4dAHZIpVv3F;

1.28
date	2015.07.19.18.44.15;	author sf;	state Exp;
branches;
next	1.27;
commitid	Nd6OWMpsso6mg5mS;

1.27
date	2015.07.16.05.10.14;	author guenther;	state Exp;
branches;
next	1.26;
commitid	vUE3LzynpntlHxEC;

1.26
date	2014.03.29.18.09.28;	author guenther;	state Exp;
branches;
next	1.25;

1.25
date	2013.05.16.16.20.00;	author kettenis;	state Exp;
branches;
next	1.24;

1.24
date	2013.05.12.14.15.31;	author ratchov;	state Exp;
branches;
next	1.23;

1.23
date	2011.04.16.00.40.58;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2011.03.23.16.54.34;	author pirofti;	state Exp;
branches;
next	1.21;

1.21
date	2010.12.27.19.51.27;	author guenther;	state Exp;
branches;
next	1.20;

1.20
date	2010.12.21.14.56.23;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2010.05.31.21.39.56;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2009.08.22.02.54.50;	author mk;	state Exp;
branches;
next	1.17;

1.17
date	2009.04.19.17.50.18;	author oga;	state Exp;
branches;
next	1.16;

1.16
date	2009.03.15.19.40.40;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2008.12.06.19.59.38;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2008.12.06.04.31.24;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2008.06.26.05.42.09;	author ray;	state Exp;
branches;
next	1.12;

1.12
date	2008.04.28.18.09.00;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2007.05.25.16.22.11;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2007.05.16.19.37.06;	author thib;	state Exp;
branches;
next	1.9;

1.9
date	2007.05.10.17.59.24;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2007.05.06.03.37.08;	author gwk;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.12.02.34.39;	author brad;	state Exp;
branches;
next	1.6;

1.6
date	2005.04.19.15.29.47;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.28.01.52.26;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.26.05.29.17;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.25.11.03.28;	author art;	state Exp;
branches;
next	1.2;

1.2
date	2004.05.07.20.33.04;	author tedu;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.28.01.39.39;	author mickey;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.06.05.23.09.25;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Introduce intr_barrier(4), an interface that guarantees that an interrupt
handler that was running has finished.

ok miod@@, guenther@@ (both for the equivalent sparc64 diff)
@
text
@/*	$OpenBSD: intr.h,v 1.28 2015/07/19 18:44:15 sf Exp $	*/
/*	$NetBSD: intr.h,v 1.2 2003/05/04 22:01:56 fvdl Exp $	*/

/*-
 * Copyright (c) 1998, 2001 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Charles M. Hannum, and by Jason R. Thorpe.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _MACHINE_INTR_H_
#define _MACHINE_INTR_H_

#include <machine/intrdefs.h>

#ifndef _LOCORE
#include <machine/cpu.h>

#include <sys/evcount.h>

/*
 * Struct describing an interrupt source for a CPU. struct cpu_info
 * has an array of MAX_INTR_SOURCES of these. The index in the array
 * is equal to the stub number of the stubcode as present in vector.s
 *
 * The primary CPU's array of interrupt sources has its first 16
 * entries reserved for legacy ISA irq handlers. This means that
 * they have a 1:1 mapping for arrayindex:irq_num. This is not
 * true for interrupts that come in through IO APICs, to find
 * their source, go through ci->ci_isources[index].is_pic
 *
 * It's possible to always maintain a 1:1 mapping, but that means
 * limiting the total number of interrupt sources to MAX_INTR_SOURCES
 * (32), instead of 32 per CPU. It also would mean that having multiple
 * IO APICs which deliver interrupts from an equal pin number would
 * overlap if they were to be sent to the same CPU.
 */

struct intrstub {
	void *ist_entry;
	void *ist_recurse;
	void *ist_resume;
};

struct intrsource {
	int is_maxlevel;		/* max. IPL for this source */
	int is_pin;			/* IRQ for legacy; pin for IO APIC */
	struct intrhand *is_handlers;	/* handler chain */
	struct pic *is_pic;		/* originating PIC */
	void *is_recurse;		/* entry for spllower */
	void *is_resume;		/* entry for doreti */
	char is_evname[32];		/* event counter name */
	int is_flags;			/* see below */
	int is_type;			/* level, edge */
	int is_idtvec;
	int is_minlevel;
};

#define IS_LEGACY	0x0001		/* legacy ISA irq source */
#define IS_IPI		0x0002
#define IS_LOG		0x0004


/*
 * Interrupt handler chains.  *_intr_establish() insert a handler into
 * the list.  The handler is called with its (single) argument.
 */

struct intrhand {
	int	(*ih_fun)(void *);
	void	*ih_arg;
	int	ih_level;
	int	ih_flags;
	struct	intrhand *ih_next;
	int	ih_pin;
	int	ih_slot;
	struct cpu_info *ih_cpu;
	int	ih_irq;
	struct evcount ih_count;
};

#define IMASK(ci,level) (ci)->ci_imask[(level)]
#define IUNMASK(ci,level) (ci)->ci_iunmask[(level)]

extern void Xspllower(int);

int splraise(int);
int spllower(int);
void softintr(int);

/*
 * Convert spl level to local APIC level
 */
#define APIC_LEVEL(l)   ((l) << 4)

/*
 * compiler barrier: prevent reordering of instructions.
 * XXX something similar will move to <sys/cdefs.h>
 * or thereabouts.
 * This prevents the compiler from reordering code around
 * this "instruction", acting as a sequence point for code generation.
 */

#define	__splbarrier() __asm volatile("":::"memory")

/*
 * Hardware interrupt masks
 */
#define	splbio()	splraise(IPL_BIO)
#define	splnet()	splraise(IPL_NET)
#define	spltty()	splraise(IPL_TTY)
#define	splaudio()	splraise(IPL_AUDIO)
#define	splclock()	splraise(IPL_CLOCK)
#define	splstatclock()	splclock()
#define splipi()	splraise(IPL_IPI)

/*
 * Software interrupt masks
 */
#define	splsoftclock()	splraise(IPL_SOFTCLOCK)
#define	splsoftnet()	splraise(IPL_SOFTNET)
#define	splsofttty()	splraise(IPL_SOFTTTY)

/*
 * Miscellaneous
 */
#define	splvm()		splraise(IPL_VM)
#define	splhigh()	splraise(IPL_HIGH)
#define	spl0()		spllower(IPL_NONE)
#define	splsched()	splraise(IPL_SCHED)
#define spllock() 	splhigh()
#define	splx(x)		spllower(x)

/* SPL asserts */
#ifdef DIAGNOSTIC
/*
 * Although this function is implemented in MI code, it must be in this MD
 * header because we don't want this header to include MI includes.
 */
void splassert_fail(int, int, const char *);
extern int splassert_ctl;
void splassert_check(int, const char *);
#define splassert(__wantipl) do {			\
	if (splassert_ctl > 0) {			\
		splassert_check(__wantipl, __func__);	\
	}						\
} while (0)
#define splsoftassert(wantipl) splassert(wantipl)
#else
#define splassert(wantipl)	do { /* nada */ } while (0)
#define splsoftassert(wantipl)	do { /* nada */ } while (0)
#endif

#define IPLSHIFT 4			/* The upper nibble of vectors is the IPL.      */
#define IPL(level) ((level) >> IPLSHIFT)	/* Extract the IPL.    */

#include <machine/pic.h>

/*
 * Stub declarations.
 */

extern void Xsoftclock(void);
extern void Xsoftnet(void);
extern void Xsofttty(void);

extern struct intrstub i8259_stubs[];
extern struct intrstub ioapic_edge_stubs[];
extern struct intrstub ioapic_level_stubs[];

struct cpu_info;

extern int intr_shared_edge;

extern char idt_allocmap[];

void intr_default_setup(void);
int x86_nmi(void);
void intr_calculatemasks(struct cpu_info *);
int intr_allocate_slot_cpu(struct cpu_info *, struct pic *, int, int *);
int intr_allocate_slot(struct pic *, int, int, int, struct cpu_info **, int *,
	    int *);
void *intr_establish(int, struct pic *, int, int, int, int (*)(void *),
	    void *, const char *);
void intr_disestablish(struct intrhand *);
int intr_handler(struct intrframe *, struct intrhand *);
void cpu_intr_init(struct cpu_info *);
int intr_find_mpmapping(int bus, int pin, int *handle);
void intr_printconfig(void);
void intr_barrier(void *);

#ifdef MULTIPROCESSOR
void x86_send_ipi(struct cpu_info *, int);
int x86_fast_ipi(struct cpu_info *, int);
void x86_broadcast_ipi(int);
void x86_ipi_handler(void);
void x86_setperf_ipi(struct cpu_info *);

extern void (*ipifunc[X86_NIPI])(struct cpu_info *);
#endif

#endif /* !_LOCORE */

/*
 * Generic software interrupt support.
 */

#define	X86_SOFTINTR_SOFTCLOCK		0
#define	X86_SOFTINTR_SOFTNET		1
#define	X86_SOFTINTR_SOFTTTY		2
#define	X86_NSOFTINTR			3

#ifndef _LOCORE
#include <sys/queue.h>

struct x86_soft_intrhand {
	TAILQ_ENTRY(x86_soft_intrhand)
		sih_q;
	struct x86_soft_intr *sih_intrhead;
	void	(*sih_fn)(void *);
	void	*sih_arg;
	int	sih_pending;
};

struct x86_soft_intr {
	TAILQ_HEAD(, x86_soft_intrhand)
			softintr_q;
	int		softintr_ssir;
	struct mutex	softintr_lock;
};

void	*softintr_establish(int, void (*)(void *), void *);
void	softintr_disestablish(void *);
void	softintr_init(void);
void	softintr_dispatch(int);

#define	softintr_schedule(arg)						\
do {									\
	struct x86_soft_intrhand *__sih = (arg);			\
	struct x86_soft_intr *__si = __sih->sih_intrhead;		\
									\
	mtx_enter(&__si->softintr_lock);				\
	if (__sih->sih_pending == 0) {					\
		TAILQ_INSERT_TAIL(&__si->softintr_q, __sih, sih_q);	\
		__sih->sih_pending = 1;					\
		softintr(__si->softintr_ssir);				\
	}								\
	mtx_leave(&__si->softintr_lock);				\
} while (/*CONSTCOND*/ 0)
#endif /* _LOCORE */

#endif /* !_MACHINE_INTR_H_ */
@


1.28
log
@Make x86_send_ipi() return void

Nobody uses its return value. This fixes it returning an undefined
value since the previous commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.27 2015/07/16 05:10:14 guenther Exp $	*/
d212 1
@


1.27
log
@Move grab/release of the kernel_lock for softintrs from the ASM stubs to
softintr_dispatch().  Delete traces of long superseded stats code.

ok beck@@ mpi@@ uebayasi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.26 2014/03/29 18:09:28 guenther Exp $	*/
d214 1
a214 1
int x86_send_ipi(struct cpu_info *, int);
@


1.26
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.25 2013/05/16 16:20:00 kettenis Exp $	*/
a217 2
void x86_softintlock(void);
void x86_softintunlock(void);
@


1.25
log
@Implement a mechanism to establish interrupt handlers that don't grab the
kernel lock upon entry through a new IPL_MPSAFE flag/level.

ok mikeb@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.24 2013/05/12 14:15:31 ratchov Exp $	*/
d126 1
a126 1
#define	__splbarrier() __asm __volatile("":::"memory")
@


1.24
log
@Take the kernel lock and call the actual interrupt handler from a
single c function. This will hopefully make easier to stop taking
the kernel lock when running "mp safe" interrupt handlers.

help from ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.23 2011/04/16 00:40:58 deraadt Exp $	*/
d95 1
@


1.23
log
@More than a decade ago, interrupt handlers on sparc started returning 0
(interrupt was not for me), 1 (positive interrupt was for me), or -1
(i am not sure...).  We have continued with this practice in as many
drivers as possible, throughout the tree.

This makes some of the architectures use that information in their
interrupt handler calling code -- if 1 is returned (and we know
this specific machine does not have edge-shared interrupts), we
finish servicing other possible handlers on the same pin.  If the
interrupt pin remains asserted (from a different device), we will
end up back in the interrupt servicing code of course... but this is
cheaper than calling all the chained interrupts on a pin.

This does of course count on shared level interrupts being properly
sorted by IPL.

There have been some concerns about starvation of drivers which
incorrectly return 1.  Those drivers should be hunted down so that
they return -1.

ok and help from various people.  In snaps for about a week now.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.22 2011/03/23 16:54:34 pirofti Exp $	*/
d207 1
a216 2
void x86_intlock(struct intrframe);
void x86_intunlock(struct intrframe);
@


1.22
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.21 2010/12/27 19:51:27 guenther Exp $	*/
d193 2
@


1.21
log
@Eliminate x86_multicast_ipi() as unused and broken (doesn't handle #cpu>32).
The i386 version was removed some time ago, so kill its declaration too.
ok tedu@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.20 2010/12/21 14:56:23 claudio Exp $	*/
d33 2
a34 2
#ifndef _X86_INTR_H_
#define _X86_INTR_H_
d273 1
a273 1
#endif /* !_X86_INTR_H_ */
@


1.20
log
@Convert netisr to a normal soft interrupt instead of hanving MD code
for it. This makes the netisr a real C function which will help further
development. No noticable performance change on i386 and amd64.
With input from kettenis@@ and miod@@ additional OKs mikeb@@ and henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.19 2010/05/31 21:39:56 deraadt Exp $	*/
a212 1
void x86_multicast_ipi(int, int);
@


1.19
log
@there is no spllpt(), since lpt's are just tty devices (call tty functions,
and thus should be using spltty()
from Matthew Dempsky
ok oga guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.18 2009/08/22 02:54:50 mk Exp $	*/
a173 5

/*
 * XXX
 */
#define	setsoftnet()	softintr(SIR_NET)
@


1.18
log
@Constify the what/name parameter of pci_intr_establish().

Tested by myself, sthen, oga, kettenis, and jasper.
Input from sthen and jasper.

ok kettenis

(Manpage follows shortly.)
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.17 2009/04/19 17:50:18 oga Exp $	*/
a136 4

#define spllpt()	spltty()

#define	spllpt()	spltty()
@


1.17
log
@Switch the softinterrupt code on x86 over to mutexes instead of
simplelocks + splhigh().

First part of making it possible to make mpsafe softinterrupts.

"oh yes, definitely" miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.16 2009/03/15 19:40:40 miod Exp $	*/
d212 1
a212 1
	    void *, char *);
@


1.16
log
@Introduce splsoftassert(), similar to splassert() but for soft interrupt
levels. This will allow for platforms where soft interrupt levels do not
map to real hardware interrupt levels to have soft ipl values overlapping
hard ipl values without breaking spl asserts.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.15 2008/12/06 19:59:38 tedu Exp $	*/
d258 3
a260 3
		softintr_q;
	int softintr_ssir;
	struct simplelock softintr_slock;
a262 12
#define	x86_softintr_lock(si, s)					\
do {									\
	(s) = splhigh();						\
	simple_lock(&si->softintr_slock);				\
} while (/*CONSTCOND*/ 0)

#define	x86_softintr_unlock(si, s)					\
do {									\
	simple_unlock(&si->softintr_slock);				\
	splx((s));							\
} while (/*CONSTCOND*/ 0)

a271 1
	int __s;							\
d273 1
a273 1
	x86_softintr_lock(__si, __s);					\
d279 1
a279 1
	x86_softintr_unlock(__si, __s);					\
@


1.15
log
@revert all changes related to the mpsafe intr handler.  i screwed up the commit
and even then it didn't work.  we have higher standards than this.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.14 2008/12/06 04:31:24 tedu Exp $	*/
d173 1
d175 2
a176 1
#define splassert(wantipl) do { /* nada */ } while (0)
@


1.14
log
@mpsafe intr_establish that doesn't get biglock, so that we may dream of the day when this is useful.
mostly macro magic that does nothing.  only actually useful on amd64 for now, compliments of art.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.13 2008/06/26 05:42:09 ray Exp $	*/
a93 2
	int	(*ih_wrapped_fun)(void *);
	void	*ih_wrapped_arg;
a208 2

#define		INTR_ESTABLISH_MPSAFE	0x01
d210 1
a210 1
	    void *, char *, int);
d222 2
@


1.13
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.12 2008/04/28 18:09:00 kettenis Exp $	*/
d94 2
d211 2
d214 1
a214 1
	    void *, char *);
a225 2
void x86_intlock(struct intrframe);
void x86_intunlock(struct intrframe);
@


1.12
log
@Rename IPL_SOFTSERIAL to IPL_SOFTTY and rename the associated symbols.
Remove IPL_SERIAL since it is unused.

ok krw@@, weingart@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.11 2007/05/25 16:22:11 art Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.11
log
@Change the old slow and complicated TLB shootdown code to new, fast and
simple. This is basically the same code as on i386 and basically the same
performance improvements.

This change also includes code to delay the freeing of ptps until they
have been properly shot.

in snaps for a week, no problems reported.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.10 2007/05/16 19:37:06 thib Exp $	*/
a142 1
#define	splserial()	splraise(IPL_SERIAL)
d154 1
a154 1
#define	splsoftserial()	splraise(IPL_SOFTSERIAL)
d200 1
a200 1
extern void Xsoftserial(void);
d246 1
a246 1
#define	X86_SOFTINTR_SOFTSERIAL		2
@


1.10
log
@splassert_ctl defaults to 1 now, so dont wrap the checks for
splassert_ctl > 0 in __predict_false().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.9 2007/05/10 17:59:24 deraadt Exp $	*/
d226 1
@


1.9
log
@evcnt & friends were replaced by a proper interrupt counting mechanism 3 years ago; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.8 2007/05/06 03:37:08 gwk Exp $	*/
d177 1
a177 1
	if (__predict_false(splassert_ctl > 0)) {	\
@


1.8
log
@Add the mp setperf mechanism to AMD64, like its i386 counterpart it allows
all cpus in a system supporting frequency and voltage scaling to be scaled
by the same amount corresponding to the user (or apmd on their behalf)
performance level.

This diff also teaches amd64 about acpi_hasprocfvs (ACPI has processor
frequency and voltage scaling).

It also moves initilization of the underlying setperf mechanism such
as powernow to mainbus from the cpu indentification and initilization
code inspired by similar changes dim@@ made to i386 durring h2k6. This
is necessary to implement the AMD recommended method for retreiving
p_state data from the ACPI _PSS object (a diff comming soon). It will
also simplify the potential addition of enhanced speedstep as found
on newer intel processors with EMT64 capable of running OpenBSD/amd64.

MP setperf functionality verifed by myself and Johan M:son Lindman <tybolt
AT solace DOT miun DOT se> on opteron 265 and 270 systems respectively.
General testing done by many others thanks!

ok tedu, dim
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.7 2006/03/12 02:34:39 brad Exp $	*/
a80 1
	struct evcnt is_evcnt;		/* interrupt counter */
@


1.7
log
@remove IPL_IMP and splimp().
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.6 2005/04/19 15:29:47 mickey Exp $	*/
d70 1
a70 1
	void *ist_recurse; 
d234 1
d247 1
a247 1
#define	X86_SOFTINTR_SOFTSERIAL	2
@


1.6
log
@nothing uses spllowersoftclock() anymore
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.5 2004/06/28 01:52:26 deraadt Exp $	*/
d161 1
a161 2
#define splimp()	splraise(IPL_IMP)
#define	splvm()		splraise(IPL_IMP)
@


1.5
log
@Use new event counter API for interrupt counting on amd64.  Based in part
on some changes in the i386 codebase.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.4 2004/06/26 05:29:17 art Exp $	*/
a152 3
 *
 * NOTE: spllowersoftclock() is used by hardclock() to lower the priority from
 * clock to softclock before it calls softclock().
a153 2
#define	spllowersoftclock() spllower(IPL_SOFTCLOCK)

@


1.4
log
@deinline splraise, spllower and setsoftint.
Makes the kernel smaller and faster.
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.3 2004/06/25 11:03:28 art Exp $	*/
d48 2
d108 1
a108 1
	char	*ih_what;
d223 3
a225 2
		       int *);
void *intr_establish(int, struct pic *, int, int, int, int (*)(void *), void *);
@


1.3
log
@SMP support. Big parts from NetBSD, but with some really serious debugging
done by me, niklas and others. Especially wrt. NXE support.

Still needs some polishing, especially in dmesg messages, but we're now
building kernel faster than ever.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.2 2004/05/07 20:33:04 tedu Exp $	*/
d114 3
a116 3
static __inline int splraise(int);
static __inline int spllower(int);
static __inline void softintr(int);
a133 40
 * Add a mask to cpl, and return the old value of cpl.
 */
static __inline int
splraise(int nlevel)
{
	int olevel;
	struct cpu_info *ci = curcpu();

	olevel = ci->ci_ilevel;
	if (nlevel > olevel)
		ci->ci_ilevel = nlevel;
	__splbarrier();
	return (olevel);
}

/*
 * Restore a value to cpl (unmasking interrupts).  If any unmasked
 * interrupts are pending, call Xspllower() to process them.
 */
static __inline int
spllower(int nlevel)
{
	int olevel;
	struct cpu_info *ci = curcpu();

	__splbarrier();
	/*
	 * Since this should only lower the interrupt level,
	 * the XOR below should only show interrupts that
	 * are being unmasked.
	 */
	olevel = ci->ci_ilevel;
	if (ci->ci_ipending & IUNMASK(ci,nlevel))
		Xspllower(nlevel);
	else
		ci->ci_ilevel = nlevel;
	return (olevel);
}

/*
a188 16

/*
 * Software interrupt registration
 *
 * We hand-code this to ensure that it's atomic.
 *
 * XXX always scheduled on the current CPU.
 */
static __inline void
softintr(int sir)
{
	struct cpu_info *ci = curcpu();

	__asm __volatile("lock ; orl %1, %0" :
	    "=m"(ci->ci_ipending) : "ir" (1 << sir));
}
@


1.2
log
@spllower should return the previous level, to match other archs.
"looks right" miod
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.1 2004/01/28 01:39:39 mickey Exp $	*/
a46 1
#include <machine/pic.h>
d253 2
@


1.1
log
@an amd64 arch support.
hacked by art@@ from netbsd sources and then later debugged
by me into the shape where it can host itself.
no bootloader yet as needs redoing from the
recent advanced i386 sources (anyone? ;)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d116 1
a116 1
static __inline void spllower(int);
d154 1
a154 1
static __inline void
d157 1
d166 1
d171 1
@


1.1.2.1
log
@Merge with the trunk
@
text
@d116 1
a116 1
static __inline int spllower(int);
d154 1
a154 1
static __inline int
a156 1
	int olevel;
a164 1
	olevel = ci->ci_ilevel;
a168 1
	return (olevel);
@


