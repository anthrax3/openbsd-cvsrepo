head	1.13;
access;
symbols
	OPENBSD_6_0:1.13.0.14
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.10
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.12
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.4
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.8
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.6
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.12.0.2
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.10.0.6
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.4
	OPENBSD_5_0:1.10.0.2
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.26
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.22
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.20
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.18
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.16
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.14
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.10
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.12
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.8
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.6
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.4
	OPENBSD_3_6_BASE:1.3
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	OPENBSD_3_5:1.3.0.2
	OPENBSD_3_5_BASE:1.3
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.13
date	2013.05.05.19.25.57;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2012.12.05.23.20.10;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2012.10.10.11.23.47;	author sthen;	state Exp;
branches;
next	1.10;

1.10
date	2011.04.13.02.49.12;	author guenther;	state Exp;
branches;
next	1.9;

1.9
date	2011.04.10.03.56.38;	author guenther;	state Exp;
branches;
next	1.8;

1.8
date	2011.04.05.21.14.00;	author guenther;	state Exp;
branches;
next	1.7;

1.7
date	2011.03.23.16.54.34;	author pirofti;	state Exp;
branches;
next	1.6;

1.6
date	2011.03.18.03.10.47;	author guenther;	state Exp;
branches;
next	1.5;

1.5
date	2010.10.26.05.49.10;	author guenther;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.18.21.08.19;	author martynas;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.27.23.45.55;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.26.01.46.49;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.28.01.39.39;	author mickey;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.06.05.23.09.25;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.13
log
@remove never used get/set ioperm sysarch functions. ok guenther
@
text
@/*	$OpenBSD: sysarch.h,v 1.12 2012/12/05 23:20:10 deraadt Exp $	*/
/*	$NetBSD: sysarch.h,v 1.1 2003/04/26 18:39:48 fvdl Exp $	*/

#ifndef _MACHINE_SYSARCH_H_
#define _MACHINE_SYSARCH_H_

/*
 * Architecture specific syscalls (amd64)
 */
#define	AMD64_IOPL		2
#define	AMD64_GET_IOPERM	3
#define	AMD64_SET_IOPERM	4
#define	AMD64_VM86		5
#define	AMD64_PMC_INFO		8
#define	AMD64_PMC_STARTSTOP	9
#define	AMD64_PMC_READ		10
#define	AMD64_GET_FSBASE	11
#define	AMD64_SET_FSBASE	12

struct amd64_iopl_args {
	int iopl;
};

struct amd64_pmc_info_args {
	int	type;
	int	flags;
};

#define	PMC_TYPE_NONE		0
#define	PMC_TYPE_I586		1
#define	PMC_TYPE_I686		2

#define	PMC_INFO_HASTSC		0x01

#define	PMC_NCOUNTERS		2

struct amd64_pmc_startstop_args {
	int counter;
	u_int64_t val;
	u_int8_t event;
	u_int8_t unit;
	u_int8_t compare;
	u_int8_t flags;
};

#define	PMC_SETUP_KERNEL	0x01
#define	PMC_SETUP_USER		0x02
#define	PMC_SETUP_EDGE		0x04
#define	PMC_SETUP_INV		0x08

struct amd64_pmc_read_args {
	int counter;
	u_int64_t val;
	u_int64_t time;
};


#ifdef _KERNEL
int amd64_iopl(struct proc *, void *, register_t *);
int amd64_set_fsbase(struct proc *, void *);
int amd64_get_fsbase(struct proc *, void *);
#else

#include <sys/cdefs.h>

__BEGIN_DECLS
int amd64_iopl(int);
int amd64_pmc_info(struct amd64_pmc_info_args *);
int amd64_pmc_startstop(struct amd64_pmc_startstop_args *);
int amd64_pmc_read(struct amd64_pmc_read_args *);
int amd64_set_fsbase(void *);
int amd64_get_fsbase(void **);
int sysarch(int, void *);
__END_DECLS
#endif

#endif /* !_MACHINE_SYSARCH_H_ */
@


1.12
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: sysarch.h,v 1.11 2012/10/10 11:23:47 sthen Exp $	*/
a23 8
struct amd64_get_ioperm_args {
	u_long *iomap;
};

struct amd64_set_ioperm_args {
	u_long *iomap;
};

a67 2
int amd64_get_ioperm(u_long *);
int amd64_set_ioperm(u_long *);
@


1.11
log
@Add __BEGIN_DECLS so that programs using C++ can use functions
defined in sysarch.h again, they were broken following the change
to NO_IMPLICIT_EXTERN_C.  help/ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysarch.h,v 1.10 2011/04/13 02:49:12 guenther Exp $	*/
a6 2
#include <sys/cdefs.h>

d71 3
@


1.10
log
@Unrevert the FS.base diff: the issues were actually elsewhere
Additional testing by jasper@@ and pea@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysarch.h,v 1.9 2011/04/10 03:56:38 guenther Exp $	*/
d7 2
d73 1
d83 1
@


1.9
log
@Revert bulk of the FS.base diff, as it causes issues on some machines
and the problem isn't obvious yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysarch.h,v 1.8 2011/04/05 21:14:00 guenther Exp $	*/
d10 1
a10 1
#define	AMD64_IOPL	2
d13 6
a18 4
#define	AMD64_VM86	5
#define	AMD64_PMC_INFO	8
#define	AMD64_PMC_STARTSTOP 9
#define	AMD64_PMC_READ	10
d68 2
d77 2
@


1.8
log
@Add support for per-rthread base-offset for the %fs selector on amd64.
Add pcb_fsbase to the PCB for tracking what the value for the thread
is, and ci_cur_fsbase to struct cpu_info for tracking the CPU's current
value for FS.base, then on return to user-space, skip the setting if the
CPU has the right value already.  Non-threaded processes without TLS leave
FS.base zero, which can be conveniently optimized: setting %fs zeros
FS.base for fewer cycles than wrmsr.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysarch.h,v 1.7 2011/03/23 16:54:34 pirofti Exp $	*/
d10 1
a10 1
#define	AMD64_IOPL		2
d13 4
a16 6
#define	AMD64_VM86		5
#define	AMD64_PMC_INFO		8
#define	AMD64_PMC_STARTSTOP	9
#define	AMD64_PMC_READ		10
#define	AMD64_GET_FSBASE	11
#define	AMD64_SET_FSBASE	12
a65 2
int amd64_set_fsbase(struct proc *, void *);
int amd64_get_fsbase(struct proc *, void *);
a72 2
int amd64_set_fsbase(void *);
int amd64_get_fsbase(void **);
@


1.7
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysarch.h,v 1.6 2011/03/18 03:10:47 guenther Exp $	*/
d10 1
a10 1
#define	AMD64_IOPL	2
d13 6
a18 4
#define	AMD64_VM86	5
#define	AMD64_PMC_INFO	8
#define	AMD64_PMC_STARTSTOP 9
#define	AMD64_PMC_READ	10
d68 2
d77 2
@


1.6
log
@Old-style MTRRs were never used on amd64, so remove the remaining traces
of them, as well as some other unused proc md_flags bits: MDP_COMPAT and
MDP_SYSCALL.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysarch.h,v 1.5 2010/10/26 05:49:10 guenther Exp $	*/
d4 2
a5 2
#ifndef _AMD64_SYSARCH_H_
#define _AMD64_SYSARCH_H_
d76 1
a76 1
#endif /* !_AMD64_SYSARCH_H_ */
@


1.5
log
@The LDT is only used by dead compat code now, so load the ldt
register with the null selector (disabling use of it), stop reloading
it on every context switch, and blow away the table itself, as well
as the pcb and pmap bits that were used to track it.  Also, delete
two other unused pcb members: pcb_usersp and pcb_flags.  (Deleting
pcb_usersp also keeps the pcb_savefpu member aligned properly.)
Finally, delete the defines for the unimplemented AMD64_{GET,SET}_LDT
sysarch() calls.

Tested by various with both AMD and Intel chips
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysarch.h,v 1.4 2009/09/18 21:08:19 martynas Exp $	*/
a16 2
#define AMD64_GET_MTRR   11
#define AMD64_SET_MTRR   12
a62 10
struct amd64_get_mtrr_args {
	struct mtrr *mtrrp;
	int *n;
};

struct amd64_set_mtrr_args {
	struct mtrr *mtrrp;
	int *n;
};

a65 2
int amd64_get_mtrr(struct proc *, void *, register_t *);
int amd64_set_mtrr(struct proc *, void *, register_t *);
a72 2
int amd64_set_mtrr(struct mtrr *, int *);
int amd64_get_mtrr(struct mtrr *, int *);
@


1.4
log
@ldt removal missed some.  amd64_{get,set}_ldt gone.  also remove
ldt_{alloc,free} to shave a few.  ok jasper@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysarch.h,v 1.3 2004/02/27 23:45:55 deraadt Exp $	*/
a9 2
#define AMD64_GET_LDT	0
#define AMD64_SET_LDT	1
@


1.3
log
@move to amd64_() functions
@
text
@d1 1
a1 1
/*	$OpenBSD: sysarch.h,v 1.2 2004/02/26 01:46:49 deraadt Exp $	*/
a21 15
/*
 * XXX todo.
 */
struct amd64_get_ldt_args {
	int start;
	union descriptor *desc;
	int num;
};

struct amd64_set_ldt_args {
	int start;
	union descriptor *desc;
	int num;
};

a82 2
int amd64_get_ldt(int, union descriptor *, int);
int amd64_set_ldt(int, union descriptor *, int);
@


1.2
log
@put the goo there for ldt handling, even if we do not do it yet
@
text
@d1 1
a1 1
/*	$OpenBSD: sysarch.h,v 1.1 2004/01/28 01:39:39 mickey Exp $	*/
d10 11
a20 11
#define X86_64_GET_LDT	0
#define X86_64_SET_LDT	1
#define	X86_64_IOPL	2
#define	X86_64_GET_IOPERM	3
#define	X86_64_SET_IOPERM	4
#define	X86_64_VM86	5
#define	X86_64_PMC_INFO	8
#define	X86_64_PMC_STARTSTOP 9
#define	X86_64_PMC_READ	10
#define X86_64_GET_MTRR   11
#define X86_64_SET_MTRR   12
d23 1
a23 1
 * XXXfvdl todo.
d25 1
a25 4

#if 1

struct x86_64_get_ldt_args {
d31 1
a31 1
struct x86_64_set_ldt_args {
d37 1
a37 3
#endif

struct x86_64_iopl_args {
d41 1
a41 3
#if 1

struct x86_64_get_ioperm_args {
d45 1
a45 1
struct x86_64_set_ioperm_args {
d49 1
a49 1
struct x86_64_pmc_info_args {
d62 1
a62 1
struct x86_64_pmc_startstop_args {
d76 1
a76 1
struct x86_64_pmc_read_args {
d82 1
a82 3
#endif /* todo */

struct x86_64_get_mtrr_args {
d87 1
a87 1
struct x86_64_set_mtrr_args {
d94 3
a96 3
int x86_64_iopl(struct proc *, void *, register_t *);
int x86_64_get_mtrr(struct proc *, void *, register_t *);
int x86_64_set_mtrr(struct proc *, void *, register_t *);
d98 10
a107 10
int x86_64_get_ldt(int, union descriptor *, int);
int x86_64_set_ldt(int, union descriptor *, int);
int x86_64_iopl(int);
int x86_64_get_ioperm(u_long *);
int x86_64_set_ioperm(u_long *);
int x86_64_pmc_info(struct x86_64_pmc_info_args *);
int x86_64_pmc_startstop(struct x86_64_pmc_startstop_args *);
int x86_64_pmc_read(struct x86_64_pmc_read_args *);
int x86_64_set_mtrr(struct mtrr *, int *);
int x86_64_get_mtrr(struct mtrr *, int *);
@


1.1
log
@an amd64 arch support.
hacked by art@@ from netbsd sources and then later debugged
by me into the shape where it can host itself.
no bootloader yet as needs redoing from the
recent advanced i386 sources (anyone? ;)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d26 1
a26 1
#if 0
d46 1
a46 1
#if 0
@


1.1.2.1
log
@Merge with the trunk
@
text
@d10 11
a20 11
#define AMD64_GET_LDT	0
#define AMD64_SET_LDT	1
#define	AMD64_IOPL	2
#define	AMD64_GET_IOPERM	3
#define	AMD64_SET_IOPERM	4
#define	AMD64_VM86	5
#define	AMD64_PMC_INFO	8
#define	AMD64_PMC_STARTSTOP 9
#define	AMD64_PMC_READ	10
#define AMD64_GET_MTRR   11
#define AMD64_SET_MTRR   12
d23 1
a23 1
 * XXX todo.
d25 4
a28 1
struct amd64_get_ldt_args {
d34 1
a34 1
struct amd64_set_ldt_args {
d40 3
a42 1
struct amd64_iopl_args {
d46 3
a48 1
struct amd64_get_ioperm_args {
d52 1
a52 1
struct amd64_set_ioperm_args {
d56 1
a56 1
struct amd64_pmc_info_args {
d69 1
a69 1
struct amd64_pmc_startstop_args {
d83 1
a83 1
struct amd64_pmc_read_args {
d89 3
a91 1
struct amd64_get_mtrr_args {
d96 1
a96 1
struct amd64_set_mtrr_args {
d103 3
a105 3
int amd64_iopl(struct proc *, void *, register_t *);
int amd64_get_mtrr(struct proc *, void *, register_t *);
int amd64_set_mtrr(struct proc *, void *, register_t *);
d107 10
a116 10
int amd64_get_ldt(int, union descriptor *, int);
int amd64_set_ldt(int, union descriptor *, int);
int amd64_iopl(int);
int amd64_get_ioperm(u_long *);
int amd64_set_ioperm(u_long *);
int amd64_pmc_info(struct amd64_pmc_info_args *);
int amd64_pmc_startstop(struct amd64_pmc_startstop_args *);
int amd64_pmc_read(struct amd64_pmc_read_args *);
int amd64_set_mtrr(struct mtrr *, int *);
int amd64_get_mtrr(struct mtrr *, int *);
@


