head	1.16;
access;
symbols
	OPENBSD_6_2_BASE:1.16
	OPENBSD_6_1:1.16.0.6
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.2
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.11.0.6
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.9.0.8
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.6
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.4
	OPENBSD_5_0:1.9.0.2
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.7.0.2
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.6.0.6
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.8
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.4
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.2
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.5.0.4
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.2
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.4.0.2
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.3.0.2
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.2.0.10
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.6
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.4
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	OPENBSD_3_5:1.1.0.4
	OPENBSD_3_5_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.16
date	2016.06.22.01.12.38;	author mikeb;	state Exp;
branches;
next	1.15;
commitid	aoZwpavraFkBTbjg;

1.15
date	2015.12.08.19.45.55;	author mikeb;	state Exp;
branches;
next	1.14;
commitid	k3df0wPG0WyTVD3t;

1.14
date	2015.11.13.07.52.20;	author mlarkin;	state Exp;
branches;
next	1.13;
commitid	KdsjYlqLpqhwOUHf;

1.13
date	2015.02.10.05.35.19;	author mlarkin;	state Exp;
branches;
next	1.12;
commitid	YgXjfGZtossZzOi6;

1.12
date	2014.07.09.11.37.16;	author mlarkin;	state Exp;
branches;
next	1.11;
commitid	ZzCjmXn3ZAUY3nHp;

1.11
date	2013.06.01.22.22.13;	author mlarkin;	state Exp;
branches;
next	1.10;

1.10
date	2013.05.16.16.20.00;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2011.06.16.19.46.40;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2010.11.13.04.16.42;	author guenther;	state Exp;
branches;
next	1.7;

1.7
date	2010.05.22.21.31.05;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2008.04.28.18.09.00;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2007.05.06.03.37.08;	author gwk;	state Exp;
branches;
next	1.4;

1.4
date	2007.02.01.20.39.42;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2006.03.12.02.34.39;	author brad;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.25.17.27.01;	author andreas;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.28.01.39.39;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Setup Hyper-V hypercall page and an IDT vector.

ok mlarkin, kettenis, deraadt
@
text
@/*	$OpenBSD: intrdefs.h,v 1.15 2015/12/08 19:45:55 mikeb Exp $	*/
/*	$NetBSD: intrdefs.h,v 1.2 2003/05/04 22:01:56 fvdl Exp $	*/

#ifndef _AMD64_INTRDEFS_H
#define _AMD64_INTRDEFS_H

/*
 * Interrupt priority levels.
 * 
 * There are tty, network and disk drivers that use free() at interrupt
 * time, so imp > (tty | net | bio).
 *
 * Since run queues may be manipulated by both the statclock and tty,
 * network, and disk drivers, clock > imp.
 *
 * IPL_HIGH must block everything that can manipulate a run queue.
 *
 * The level numbers are picked to fit into APIC vector priorities.
 *
 */
#define	IPL_NONE	0x0	/* nothing */
#define	IPL_SOFTCLOCK	0x4	/* timeouts */
#define	IPL_SOFTNET	0x5	/* protocol stacks */
#define	IPL_BIO		0x6	/* block I/O */
#define	IPL_NET		0x7	/* network */
#define	IPL_SOFTTTY	0x8	/* delayed terminal handling */
#define	IPL_TTY		0x9	/* terminal */
#define	IPL_VM		0xa	/* memory allocation */
#define	IPL_AUDIO	0xb	/* audio */
#define	IPL_CLOCK	0xc	/* clock */
#define	IPL_SCHED	IPL_CLOCK
#define	IPL_STATCLOCK	IPL_CLOCK
#define	IPL_HIGH	0xd	/* everything */
#define	IPL_IPI		0xe	/* inter-processor interrupts */
#define	NIPL		16

#define	IPL_MPSAFE	0x100

/* Interrupt sharing types. */
#define	IST_NONE	0	/* none */
#define	IST_PULSE	1	/* pulsed */
#define	IST_EDGE	2	/* edge-triggered */
#define	IST_LEVEL	3	/* level-triggered */

/*
 * Local APIC masks. Must not conflict with SIR_* above, and must
 * be >= NUM_LEGACY_IRQs. Note that LIR_IPI must be first.
 */
#define LIR_IPI		63
#define LIR_TIMER	62

/* Soft interrupt masks. */
#define	SIR_CLOCK	61
#define	SIR_NET		60
#define	SIR_TTY		59

#define	LIR_XEN		58
#define	LIR_HYPERV	57

/*
 * Maximum # of interrupt sources per CPU. 64 to fit in one word.
 * ioapics can theoretically produce more, but it's not likely to
 * happen. For multiple ioapics, things can be routed to different
 * CPUs.
 */
#define MAX_INTR_SOURCES	64
#define NUM_LEGACY_IRQS		16

/*
 * Low and high boundaries between which interrupt gates will
 * be allocated in the IDT.
 */
#define IDT_INTR_LOW	(0x20 + NUM_LEGACY_IRQS)
#define IDT_INTR_HIGH	0xef

#define X86_IPI_HALT			0x00000001
#define X86_IPI_NOP			0x00000002
#define X86_IPI_FLUSH_FPU		0x00000004
#define X86_IPI_SYNCH_FPU		0x00000008
#define X86_IPI_TLB			0x00000010
#define X86_IPI_MTRR			0x00000020
#define X86_IPI_SETPERF			0x00000040
#define X86_IPI_DDB			0x00000080
#define X86_IPI_START_VMM		0x00000100
#define X86_IPI_STOP_VMM		0x00000200

#define X86_NIPI			10

#define X86_IPI_NAMES { "halt IPI", "nop IPI", "FPU flush IPI", \
			 "FPU synch IPI", "TLB shootdown IPI", \
			 "MTRR update IPI", "setperf IPI", "ddb IPI", \
			 "VMM start IPI", "VMM stop IPI" }

#define IREENT_MAGIC	0x18041969

#endif /* _AMD64_INTRDEFS_H */
@


1.15
log
@Set up an IDT vector for Xen callbacks

This adds support for delivering the combined Xen interrupt
that later fans out into event port specific (device specific)
interrupts via an IDT of a guest system.

The Xen IDT vector is set to be the first of the IPL_NET group
and is implemented the same way LAPIC timer and IPIs are done.
The additional machinery is there to be able to mask it via
standard mechanisms (e.g. splnet).

Discussed with kettenis@@, OK mlarkin, reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: intrdefs.h,v 1.14 2015/11/13 07:52:20 mlarkin Exp $	*/
d58 1
@


1.14
log
@
vmm(4) kernel code

circulated on hackers@@, no objections. Disabled by default.
@
text
@d1 1
a1 1
/*	$OpenBSD: intrdefs.h,v 1.13 2015/02/10 05:35:19 mlarkin Exp $	*/
d57 1
@


1.13
log
@
Remove a #define for an ipi removed last year. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: intrdefs.h,v 1.12 2014/07/09 11:37:16 mlarkin Exp $	*/
d82 2
d85 1
a85 1
#define X86_NIPI			8
d89 2
a90 1
			 "MTRR update IPI", "setperf IPI", "ddb IPI" }
@


1.12
log
@
Fixes a hibernate issue wherein we locked the kernel lock while hatching
but then parked ourselves in real mode without completing acquisition of
said lock. Also removes the park routine from i386 since we don't need it
(the APs are already parked at the time we start unpack).

discussed with and ok kettenis@@, also ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intrdefs.h,v 1.11 2013/06/01 22:22:13 mlarkin Exp $	*/
a81 1
#define X86_IPI_HALT_REALMODE		0x00000100
@


1.11
log
@

Introduce a new amd64 IPI, x86_ipi_halt_realmode to park CPUS into real
mode and halt them. Needed for hibernate.

ok deraadt@@ kettenis@@ "there's no risk there"
@
text
@d1 1
a1 1
/*	$OpenBSD: intrdefs.h,v 1.10 2013/05/16 16:20:00 kettenis Exp $	*/
d84 1
a84 1
#define X86_NIPI			9
d88 1
a88 2
			 "MTRR update IPI", "setperf IPI", "ddb IPI", \
			 "realmode halt IPI" }
@


1.10
log
@Implement a mechanism to establish interrupt handlers that don't grab the
kernel lock upon entry through a new IPL_MPSAFE flag/level.

ok mikeb@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intrdefs.h,v 1.9 2011/06/16 19:46:40 kettenis Exp $	*/
d82 1
d84 1
a84 1
#define X86_NIPI			8
d88 2
a89 1
			 "MTRR update IPI", "setperf IPI", "ddb IPI" }
@


1.9
log
@Raise the number of interrupt sources per CPU from 32 to 64.  This effectively
triples the number of interrupt vectors that can be handled by the primary
CPU.  Important for MSI, but could also fix some issues with large machines
loaded with a lot of devices.

tested by many; ok deraadt@@, marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intrdefs.h,v 1.8 2010/11/13 04:16:42 guenther Exp $	*/
d31 2
a32 2
#define IPL_SCHED	IPL_CLOCK
#define IPL_STATCLOCK	IPL_CLOCK
d34 1
a34 1
#define IPL_IPI		0xe	/* inter-processor interrupts */
d36 2
@


1.8
log
@Switch from TSS-per-process to TSS-per-CPU, placing the TSS right
next to the cpu's GDT, also making the double-fault stack per-CPU,
leaving it at the top of the page of the CPU's idle process.  Inline
pmap_activate() and pmap_deactivate() into the asm cpu_switchto
routine, adding a check for the new pmap already being marked as
active on the CPU.  Garbage collect the hasn't-been-used-in-years
GDT update IPI.

Tested by many; ok mikeb@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intrdefs.h,v 1.7 2010/05/22 21:31:05 deraadt Exp $	*/
d47 2
a48 2
#define LIR_IPI		31
#define LIR_TIMER	30
d51 3
a53 3
#define	SIR_CLOCK	29
#define	SIR_NET		28
#define	SIR_TTY		27
d57 1
a57 1
 * Maximum # of interrupt sources per CPU. 32 to fit in one word.
d62 1
a62 1
#define MAX_INTR_SOURCES	32
@


1.7
log
@this is amd64, not i386, and the protection was all busted
@
text
@d1 1
a1 1
/*	$OpenBSD: intrdefs.h,v 1.6 2008/04/28 18:09:00 kettenis Exp $	*/
d78 1
a78 1
#define X86_IPI_GDT			0x00000040
a79 1
#define X86_IPI_SETPERF			0x00000100
d81 1
a81 1
#define X86_NIPI			9
d85 1
a85 2
			 "MTRR update IPI", "GDT update IPI", "ddb IPI", \
			 "setperf IPI"}
@


1.6
log
@Rename IPL_SOFTSERIAL to IPL_SOFTTY and rename the associated symbols.
Remove IPL_SERIAL since it is unused.

ok krw@@, weingart@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intrdefs.h,v 1.5 2007/05/06 03:37:08 gwk Exp $	*/
d4 2
a5 2
#ifndef _i386_INTRDEFS_H
#define _i386_INTRDEFS_H
d91 1
a91 1
#endif /* _X86_INTRDEFS_H */
@


1.5
log
@Add the mp setperf mechanism to AMD64, like its i386 counterpart it allows
all cpus in a system supporting frequency and voltage scaling to be scaled
by the same amount corresponding to the user (or apmd on their behalf)
performance level.

This diff also teaches amd64 about acpi_hasprocfvs (ACPI has processor
frequency and voltage scaling).

It also moves initilization of the underlying setperf mechanism such
as powernow to mainbus from the cpu indentification and initilization
code inspired by similar changes dim@@ made to i386 durring h2k6. This
is necessary to implement the AMD recommended method for retreiving
p_state data from the ACPI _PSS object (a diff comming soon). It will
also simplify the potential addition of enhanced speedstep as found
on newer intel processors with EMT64 capable of running OpenBSD/amd64.

MP setperf functionality verifed by myself and Johan M:son Lindman <tybolt
AT solace DOT miun DOT se> on opteron 265 and 270 systems respectively.
General testing done by many others thanks!

ok tedu, dim
@
text
@d1 1
a1 1
/*	$OpenBSD: intrdefs.h,v 1.4 2007/02/01 20:39:42 art Exp $	*/
a17 3
 * We need serial drivers to run at the absolute highest priority to
 * avoid overruns, so serial > high.
 *
d26 1
a26 1
#define	IPL_SOFTSERIAL	0x8	/* serial */
a33 1
#define	IPL_SERIAL	0xd	/* serial */
d53 1
a53 1
#define	SIR_SERIAL	27
@


1.4
log
@Rename the MICROSET IPI we inherited from NetBSD to simply NOP since
it doesn't do anything (other than poking into the kernel a processing
ASTs).
@
text
@d1 1
a1 1
/*	$OpenBSD: intrdefs.h,v 1.3 2006/03/12 02:34:39 brad Exp $	*/
d84 1
d86 1
a86 1
#define X86_NIPI		8
d90 2
a91 1
			 "MTRR update IPI", "GDT update IPI", "ddb IPI" }
@


1.3
log
@remove IPL_IMP and splimp().
@
text
@d1 1
a1 1
/*	$OpenBSD: intrdefs.h,v 1.2 2004/06/25 17:27:01 andreas Exp $	*/
d77 1
a77 1
#define X86_IPI_MICROSET		0x00000002
d87 1
a87 1
#define X86_IPI_NAMES { "halt IPI", "timeset IPI", "FPU flush IPI", \
@


1.2
log
@'machine cpuinfo' and 'machine ddbcpu' in ddb for amd64
@
text
@d1 1
a1 1
/*	$OpenBSD: intrdefs.h,v 1.1 2004/01/28 01:39:39 mickey Exp $	*/
a31 1
#define IPL_IMP		IPL_VM
@


1.1
log
@an amd64 arch support.
hacked by art@@ from netbsd sources and then later debugged
by me into the shape where it can host itself.
no bootloader yet as needs redoing from the
recent advanced i386 sources (anyone? ;)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d84 1
d86 1
a86 1
#define X86_NIPI		7
d90 1
a90 1
			 "MTRR update IPI", "GDT update IPI" }
@

