head	1.114;
access;
symbols
	OPENBSD_6_2:1.114.0.4
	OPENBSD_6_2_BASE:1.114
	OPENBSD_6_1:1.110.0.4
	OPENBSD_6_1_BASE:1.110
	OPENBSD_6_0:1.101.0.2
	OPENBSD_6_0_BASE:1.101
	OPENBSD_5_9:1.100.0.2
	OPENBSD_5_9_BASE:1.100
	OPENBSD_5_8:1.97.0.4
	OPENBSD_5_8_BASE:1.97
	OPENBSD_5_7:1.90.0.2
	OPENBSD_5_7_BASE:1.90
	OPENBSD_5_6:1.85.0.4
	OPENBSD_5_6_BASE:1.85
	OPENBSD_5_5:1.83.0.4
	OPENBSD_5_5_BASE:1.83
	OPENBSD_5_4:1.81.0.2
	OPENBSD_5_4_BASE:1.81
	OPENBSD_5_3:1.78.0.2
	OPENBSD_5_3_BASE:1.78
	OPENBSD_5_2:1.73.0.2
	OPENBSD_5_2_BASE:1.73
	OPENBSD_5_1_BASE:1.70
	OPENBSD_5_1:1.70.0.2
	OPENBSD_5_0:1.68.0.2
	OPENBSD_5_0_BASE:1.68
	OPENBSD_4_9:1.62.0.2
	OPENBSD_4_9_BASE:1.62
	OPENBSD_4_8:1.54.0.2
	OPENBSD_4_8_BASE:1.54
	OPENBSD_4_7:1.51.0.2
	OPENBSD_4_7_BASE:1.51
	OPENBSD_4_6:1.48.0.4
	OPENBSD_4_6_BASE:1.48
	OPENBSD_4_5:1.41.0.2
	OPENBSD_4_5_BASE:1.41
	OPENBSD_4_4:1.37.0.2
	OPENBSD_4_4_BASE:1.37
	OPENBSD_4_3:1.33.0.2
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.31.0.2
	OPENBSD_4_2_BASE:1.31
	OPENBSD_4_1:1.25.0.2
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.18.0.2
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.17.0.4
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.10.0.4
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	SMP:1.3.0.2;
locks; strict;
comment	@ * @;


1.114
date	2017.08.11.20.19.14;	author tedu;	state Exp;
branches;
next	1.113;
commitid	4QlZuCIFCHq7rVwT;

1.113
date	2017.07.12.06.26.32;	author natano;	state Exp;
branches;
next	1.112;
commitid	Jb2yji2oX9woPvMw;

1.112
date	2017.06.20.05.34.41;	author mlarkin;	state Exp;
branches;
next	1.111;
commitid	s2WnhMEQE21216EQ;

1.111
date	2017.04.14.01.02.28;	author mlarkin;	state Exp;
branches;
next	1.110;
commitid	Yee1D08v9BsclPOL;

1.110
date	2017.03.16.10.02.03;	author mpi;	state Exp;
branches;
next	1.109;
commitid	rweVgzyW1Z54hiV5;

1.109
date	2017.03.11.11.55.03;	author mpi;	state Exp;
branches;
next	1.108;
commitid	eXDj5wwfsbdFBB4L;

1.108
date	2017.03.02.10.38.10;	author natano;	state Exp;
branches;
next	1.107;
commitid	EeVoCYFCx2tYicZQ;

1.107
date	2016.12.14.10.30.59;	author reyk;	state Exp;
branches;
next	1.106;
commitid	NXKMneDbVFqc8kx2;

1.106
date	2016.10.13.19.36.25;	author martijn;	state Exp;
branches;
next	1.105;
commitid	hw7D4Jnj0S4fKrmP;

1.105
date	2016.09.30.07.33.06;	author mlarkin;	state Exp;
branches;
next	1.104;
commitid	SE7Bj6m3HBGqhmFT;

1.104
date	2016.09.27.08.04.49;	author mlarkin;	state Exp;
branches;
next	1.103;
commitid	ku4p47mroNn82mrs;

1.103
date	2016.09.04.09.22.28;	author mpi;	state Exp;
branches;
next	1.102;
commitid	jBolvsPoQ0BaYiLs;

1.102
date	2016.07.28.21.57.57;	author kettenis;	state Exp;
branches;
next	1.101;
commitid	h0GHFDGWnEdswfbK;

1.101
date	2016.05.09.22.45.07;	author deraadt;	state Exp;
branches;
next	1.100;
commitid	46xGIqgkWi42WqQG;

1.100
date	2015.12.06.23.41.32;	author guenther;	state Exp;
branches;
next	1.99;
commitid	fuhu5x5Uu2jMK619;

1.99
date	2015.11.23.22.57.12;	author deraadt;	state Exp;
branches;
next	1.98;
commitid	lOkXFQaUGdej50W4;

1.98
date	2015.11.13.07.52.20;	author mlarkin;	state Exp;
branches;
next	1.97;
commitid	KdsjYlqLpqhwOUHf;

1.97
date	2015.07.02.01.33.59;	author dlg;	state Exp;
branches;
next	1.96;
commitid	HBmwORlhlW47BLMN;

1.96
date	2015.06.28.18.54.54;	author guenther;	state Exp;
branches;
next	1.95;
commitid	9qSlzkscc1lVVnYi;

1.95
date	2015.06.13.21.41.42;	author guenther;	state Exp;
branches;
next	1.94;
commitid	niRu91s4TwItA66c;

1.94
date	2015.06.07.06.24.59;	author guenther;	state Exp;
branches;
next	1.93;
commitid	TPuT1ptKkvRzlUfp;

1.93
date	2015.05.28.20.10.58;	author guenther;	state Exp;
branches;
next	1.92;
commitid	nRKEXgw8UCVd37E0;

1.92
date	2015.05.18.19.59.27;	author guenther;	state Exp;
branches;
next	1.91;
commitid	MLFvGCnCMKMdmAtY;

1.91
date	2015.04.18.22.16.21;	author kettenis;	state Exp;
branches;
next	1.90;
commitid	yRnPx9jjsPnb6oP6;

1.90
date	2015.01.15.15.30.17;	author sf;	state Exp;
branches;
next	1.89;
commitid	kvzm4IH1Bv9o7MxC;

1.89
date	2015.01.06.12.50.48;	author dlg;	state Exp;
branches;
next	1.88;
commitid	EAvvmUR28EGEqQFd;

1.88
date	2014.12.16.21.20.23;	author tedu;	state Exp;
branches;
next	1.87;
commitid	a5Hk2YXEhjWDNeQe;

1.87
date	2014.12.02.18.13.10;	author tedu;	state Exp;
branches;
next	1.86;
commitid	ZYUxNRICiD9sC1vn;

1.86
date	2014.09.12.09.52.45;	author kettenis;	state Exp;
branches;
next	1.85;
commitid	fg3shv1MuGeLLh3b;

1.85
date	2014.07.11.10.53.07;	author uebayasi;	state Exp;
branches;
next	1.84;
commitid	CaCLs5fTSVpJlqFi;

1.84
date	2014.07.09.11.37.16;	author mlarkin;	state Exp;
branches;
next	1.83;
commitid	ZzCjmXn3ZAUY3nHp;

1.83
date	2014.02.13.23.11.06;	author kettenis;	state Exp;
branches;
next	1.82;

1.82
date	2013.10.05.16.58.30;	author guenther;	state Exp;
branches;
next	1.81;

1.81
date	2013.06.04.15.29.16;	author haesbaert;	state Exp;
branches;
next	1.80;

1.80
date	2013.03.31.17.07.02;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2013.03.12.09.37.16;	author mpi;	state Exp;
branches;
next	1.78;

1.78
date	2013.02.12.08.06.22;	author mpi;	state Exp;
branches;
next	1.77;

1.77
date	2013.02.11.17.05.25;	author mpi;	state Exp;
branches;
next	1.76;

1.76
date	2012.12.02.07.03.31;	author guenther;	state Exp;
branches;
next	1.75;

1.75
date	2012.11.10.09.45.05;	author mglocker;	state Exp;
branches;
next	1.74;

1.74
date	2012.10.09.04.40.36;	author jsg;	state Exp;
branches;
next	1.73;

1.73
date	2012.04.17.16.02.33;	author guenther;	state Exp;
branches;
next	1.72;

1.72
date	2012.04.04.18.44.22;	author mikeb;	state Exp;
branches;
next	1.71;

1.71
date	2012.03.27.02.23.04;	author haesbaert;	state Exp;
branches;
next	1.70;

1.70
date	2011.12.26.23.07.04;	author haesbaert;	state Exp;
branches;
next	1.69;

1.69
date	2011.09.20.14.32.50;	author pirofti;	state Exp;
branches;
next	1.68;

1.68
date	2011.06.16.19.46.40;	author kettenis;	state Exp;
branches;
next	1.67;

1.67
date	2011.05.23.09.52.24;	author claudio;	state Exp;
branches;
next	1.66;

1.66
date	2011.04.13.02.49.12;	author guenther;	state Exp;
branches;
next	1.65;

1.65
date	2011.04.10.03.56.38;	author guenther;	state Exp;
branches;
next	1.64;

1.64
date	2011.04.05.21.14.00;	author guenther;	state Exp;
branches;
next	1.63;

1.63
date	2011.03.23.16.54.34;	author pirofti;	state Exp;
branches;
next	1.62;

1.62
date	2010.11.29.00.04.09;	author dlg;	state Exp;
branches;
next	1.61;

1.61
date	2010.11.26.11.59.40;	author krw;	state Exp;
branches;
next	1.60;

1.60
date	2010.11.22.21.07.18;	author miod;	state Exp;
branches;
next	1.59;

1.59
date	2010.11.13.04.16.42;	author guenther;	state Exp;
branches;
next	1.58;

1.58
date	2010.10.02.23.13.27;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2010.09.28.20.27.54;	author miod;	state Exp;
branches;
next	1.56;

1.56
date	2010.09.24.13.21.30;	author matthew;	state Exp;
branches;
next	1.55;

1.55
date	2010.08.11.21.22.44;	author kettenis;	state Exp;
branches;
next	1.54;

1.54
date	2010.08.05.21.10.10;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2010.07.25.21.43.38;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2010.07.21.14.08.09;	author kettenis;	state Exp;
branches;
next	1.51;

1.51
date	2009.12.09.14.27.34;	author oga;	state Exp;
branches;
next	1.50;

1.50
date	2009.11.22.21.41.37;	author pirofti;	state Exp;
branches;
next	1.49;

1.49
date	2009.07.22.20.33.13;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2009.06.09.02.56.38;	author krw;	state Exp;
branches;
next	1.47;

1.47
date	2009.06.06.23.45.36;	author guenther;	state Exp;
branches;
next	1.46;

1.46
date	2009.06.05.10.51.45;	author guenther;	state Exp;
branches;
next	1.45;

1.45
date	2009.06.02.03.04.54;	author jordan;	state Exp;
branches;
next	1.44;

1.44
date	2009.05.28.09.05.33;	author art;	state Exp;
branches;
next	1.43;

1.43
date	2009.04.27.17.48.25;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2009.04.23.07.42.02;	author art;	state Exp;
branches;
next	1.41;

1.41
date	2009.02.16.15.50.05;	author jsg;	state Exp;
branches;
next	1.40;

1.40
date	2009.02.13.20.47.05;	author andreas;	state Exp;
branches;
next	1.39;

1.39
date	2008.11.22.18.12.32;	author art;	state Exp;
branches;
next	1.38;

1.38
date	2008.10.15.23.23.46;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2008.07.18.23.43.31;	author art;	state Exp;
branches;
next	1.36;

1.36
date	2008.06.10.02.55.39;	author weingart;	state Exp;
branches;
next	1.35;

1.35
date	2008.06.09.20.43.43;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2008.05.26.07.47.19;	author jasper;	state Exp;
branches;
next	1.33;

1.33
date	2007.11.16.16.16.07;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2007.11.01.23.30.46;	author mikeb;	state Exp;
branches;
next	1.31;

1.31
date	2007.05.29.18.53.52;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2007.05.29.06.31.44;	author tedu;	state Exp;
branches;
next	1.29;

1.29
date	2007.05.10.17.59.24;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2007.05.07.19.10.31;	author kettenis;	state Exp;
branches;
next	1.27;

1.27
date	2007.05.06.03.37.08;	author gwk;	state Exp;
branches;
next	1.26;

1.26
date	2007.03.15.10.22.29;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2007.02.17.17.35.43;	author tom;	state Exp;
branches;
next	1.24;

1.24
date	2007.02.01.20.42.17;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2006.12.24.20.30.35;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2006.12.20.22.48.29;	author gwk;	state Exp;
branches;
next	1.21;

1.21
date	2006.12.12.23.14.27;	author dim;	state Exp;
branches;
next	1.20;

1.20
date	2006.11.25.16.59.31;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	2006.11.07.09.09.42;	author otto;	state Exp;
branches;
next	1.18;

1.18
date	2006.03.08.03.33.21;	author uwe;	state Exp;
branches;
next	1.17;

1.17
date	2005.12.13.00.18.19;	author jsg;	state Exp;
branches;
next	1.16;

1.16
date	2005.09.25.20.48.21;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2005.09.20.23.00.34;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2005.09.20.21.04.13;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2005.08.20.00.33.59;	author jsg;	state Exp;
branches;
next	1.12;

1.12
date	2005.07.26.08.38.29;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.19.15.14.11;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2004.06.25.17.27.01;	author andreas;	state Exp;
branches;
next	1.9;

1.9
date	2004.06.25.11.03.28;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2004.06.22.01.16.50;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2004.06.13.21.49.13;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	2004.03.09.23.05.13;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.28.18.12.21;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2004.02.25.00.16.41;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.11.03.07.46;	author deraadt;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2004.02.09.22.15.52;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.28.01.39.39;	author mickey;	state Exp;
branches;
next	;

1.3.2.1
date	2004.02.22.22.08.18;	author niklas;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2004.06.05.23.09.25;	author niklas;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2004.06.06.05.23.38;	author tedu;	state Exp;
branches;
next	1.3.2.4;

1.3.2.4
date	2004.06.06.05.23.39;	author tedu;	state Exp;
branches;
next	1.3.2.5;

1.3.2.5
date	2004.06.06.21.58.49;	author tedu;	state Exp;
branches;
next	1.3.2.6;

1.3.2.6
date	2004.06.07.18.36.34;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.114
log
@apmwarn and the ridiculous apmhalt hack sysctls are not relevant here
@
text
@/*	$OpenBSD: cpu.h,v 1.113 2017/07/12 06:26:32 natano Exp $	*/
/*	$NetBSD: cpu.h,v 1.1 2003/04/26 18:39:39 fvdl Exp $	*/

/*-
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * William Jolitz.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)cpu.h	5.4 (Berkeley) 5/9/91
 */

#ifndef _MACHINE_CPU_H_
#define _MACHINE_CPU_H_

/*
 * Definitions unique to x86-64 cpu support.
 */
#ifdef _KERNEL
#include <machine/frame.h>
#include <machine/segments.h>
#include <machine/cacheinfo.h>
#include <machine/intrdefs.h>
#endif /* _KERNEL */

#include <sys/device.h>
#include <sys/sched.h>
#include <sys/sensors.h>

#ifdef _KERNEL

/* VMXON region (Intel) */
struct vmxon_region {
        uint32_t        vr_revision;
};

/*
 * VMX for Intel CPUs
 */
struct vmx {
	uint64_t	vmx_cr0_fixed0;
	uint64_t	vmx_cr0_fixed1;
	uint64_t	vmx_cr4_fixed0;
	uint64_t	vmx_cr4_fixed1;
	uint32_t	vmx_vmxon_revision;
	uint32_t	vmx_msr_table_size;
	uint32_t	vmx_cr3_tgt_count;
	uint64_t	vmx_vm_func;
};

/*
 * SVM for AMD CPUs
 */
struct svm {
	uint32_t	svm_max_asid;
	uint8_t		svm_flush_by_asid;
	uint8_t		svm_vmcb_clean;
};

union vmm_cpu_cap {
	struct vmx vcc_vmx;
	struct svm vcc_svm;
};

struct x86_64_tss;
struct cpu_info {
	struct device *ci_dev;
	struct cpu_info *ci_self;
	struct schedstate_percpu ci_schedstate; /* scheduler state */
	struct cpu_info *ci_next;

	struct proc *ci_curproc;
	u_int ci_cpuid;
	u_int ci_apicid;
	u_int ci_acpi_proc_id;
	u_int32_t ci_randseed;

	u_int64_t ci_scratch;

	struct proc *ci_fpcurproc;
	struct proc *ci_fpsaveproc;
	int ci_fpsaving;

	struct pcb *ci_curpcb;
	struct pcb *ci_idle_pcb;

	struct intrsource *ci_isources[MAX_INTR_SOURCES];
	u_int64_t	ci_ipending;
	int		ci_ilevel;
	int		ci_idepth;
	int		ci_handled_intr_level;
	u_int64_t	ci_imask[NIPL];
	u_int64_t	ci_iunmask[NIPL];
#ifdef DIAGNOSTIC
	int		ci_mutex_level;
#endif

	volatile u_int	ci_flags;
	u_int32_t	ci_ipis;

	u_int32_t	ci_feature_flags;
	u_int32_t	ci_feature_eflags;
	u_int32_t	ci_feature_sefflags_ebx;
	u_int32_t	ci_feature_sefflags_ecx;
	u_int32_t	ci_feature_tpmflags;
	u_int32_t	ci_pnfeatset;
	u_int32_t	ci_efeature_eax;
	u_int32_t	ci_efeature_ecx;
	u_int32_t	ci_brand[12];
	u_int32_t	ci_amdcacheinfo[4];
	u_int32_t	ci_extcacheinfo[4];
	u_int32_t	ci_signature;
	u_int32_t	ci_family;
	u_int32_t	ci_model;
	u_int32_t	ci_cflushsz;
	u_int64_t	ci_tsc_freq;

	int		ci_inatomic;

#define ARCH_HAVE_CPU_TOPOLOGY
	u_int32_t	ci_smt_id;
	u_int32_t	ci_core_id;
	u_int32_t	ci_pkg_id;

	struct cpu_functions *ci_func;
	void (*cpu_setup)(struct cpu_info *);
	void (*ci_info)(struct cpu_info *);

	struct device	*ci_acpicpudev;
	volatile u_int	ci_mwait;
#define	MWAIT_IN_IDLE		0x1	/* don't need IPI to wake */
#define	MWAIT_KEEP_IDLING	0x2	/* cleared by other cpus to wake me */
#define	MWAIT_ONLY		0x4	/* set if all idle states use mwait */
#define	MWAIT_IDLING	(MWAIT_IN_IDLE | MWAIT_KEEP_IDLING)

	int		ci_want_resched;

	struct x86_cache_info ci_cinfo[CAI_COUNT];

	struct	x86_64_tss *ci_tss;
	char		*ci_gdt;

	volatile int	ci_ddb_paused;
#define CI_DDB_RUNNING		0
#define CI_DDB_SHOULDSTOP	1
#define CI_DDB_STOPPED		2
#define CI_DDB_ENTERDDB		3
#define CI_DDB_INDDB		4

#ifdef MULTIPROCESSOR
	struct srp_hazard	ci_srp_hazards[SRP_HAZARD_NUM];
#endif

	struct ksensordev	ci_sensordev;
	struct ksensor		ci_sensor;
#if defined(GPROF) || defined(DDBPROF)
	struct gmonparam	*ci_gmon;
#endif
	u_int32_t	ci_vmm_flags;
#define	CI_VMM_VMX	(1 << 0)
#define	CI_VMM_SVM	(1 << 1)
#define	CI_VMM_RVI	(1 << 2)
#define	CI_VMM_EPT	(1 << 3)
#define	CI_VMM_DIS	(1 << 4)
	union		vmm_cpu_cap ci_vmm_cap;
	paddr_t		ci_vmxon_region_pa;
	struct vmxon_region *ci_vmxon_region;
};

#define CPUF_BSP	0x0001		/* CPU is the original BSP */
#define CPUF_AP		0x0002		/* CPU is an AP */ 
#define CPUF_SP		0x0004		/* CPU is only processor */  
#define CPUF_PRIMARY	0x0008		/* CPU is active primary processor */

#define CPUF_IDENTIFY	0x0010		/* CPU may now identify */
#define CPUF_IDENTIFIED	0x0020		/* CPU has been identified */

#define CPUF_CONST_TSC	0x0040		/* CPU has constant TSC */
#define CPUF_USERSEGS_BIT	7	/* CPU has curproc's segments */
#define CPUF_USERSEGS	(1<<CPUF_USERSEGS_BIT)		/* and FS.base */
#define CPUF_INVAR_TSC	0x0100		/* CPU has invariant TSC */

#define CPUF_PRESENT	0x1000		/* CPU is present */
#define CPUF_RUNNING	0x2000		/* CPU is running */
#define CPUF_PAUSE	0x4000		/* CPU is paused in DDB */
#define CPUF_GO		0x8000		/* CPU should start running */
#define CPUF_PARK	0x10000		/* CPU should self-park in real mode */
#define CPUF_VMM	0x20000		/* CPU is executing in VMM mode */

#define PROC_PC(p)	((p)->p_md.md_regs->tf_rip)
#define PROC_STACK(p)	((p)->p_md.md_regs->tf_rsp)

extern struct cpu_info cpu_info_primary;
extern struct cpu_info *cpu_info_list;

#define CPU_INFO_ITERATOR		int
#define CPU_INFO_FOREACH(cii, ci)	for (cii = 0, ci = cpu_info_list; \
					    ci != NULL; ci = ci->ci_next)

#define CPU_INFO_UNIT(ci)	((ci)->ci_dev ? (ci)->ci_dev->dv_unit : 0)

/*      
 * Preempt the current process if in interrupt from user mode,
 * or after the current trap/syscall if in system mode.
 */
extern void need_resched(struct cpu_info *);
#define clear_resched(ci) (ci)->ci_want_resched = 0

#if defined(MULTIPROCESSOR)

#define MAXCPUS		64	/* bitmask */

#define CPU_STARTUP(_ci)	((_ci)->ci_func->start(_ci))
#define CPU_STOP(_ci)		((_ci)->ci_func->stop(_ci))
#define CPU_START_CLEANUP(_ci)	((_ci)->ci_func->cleanup(_ci))

#define curcpu()	({struct cpu_info *__ci;                  \
			asm volatile("movq %%gs:8,%0" : "=r" (__ci)); \
			__ci;})
#define cpu_number()	(curcpu()->ci_cpuid)

#define CPU_IS_PRIMARY(ci)	((ci)->ci_flags & CPUF_PRIMARY)

extern struct cpu_info *cpu_info[MAXCPUS];

void cpu_boot_secondary_processors(void);
void cpu_init_idle_pcbs(void);    

void cpu_kick(struct cpu_info *);
void cpu_unidle(struct cpu_info *);

#define CPU_BUSY_CYCLE()	__asm volatile("pause": : : "memory")

#else /* !MULTIPROCESSOR */

#define MAXCPUS		1

#ifdef _KERNEL
extern struct cpu_info cpu_info_primary;

#define curcpu()		(&cpu_info_primary)

#define cpu_kick(ci)
#define cpu_unidle(ci)

#define CPU_BUSY_CYCLE()	do {} while (0)

#endif

/*
 * definitions of cpu-dependent requirements
 * referenced in generic code
 */
#define	cpu_number()		0
#define CPU_IS_PRIMARY(ci)	1

#endif	/* MULTIPROCESSOR */

#include <machine/psl.h>

#endif /* _KERNEL */

#ifdef MULTIPROCESSOR
#include <sys/mplock.h>
#endif

#define aston(p)	((p)->p_md.md_astpending = 1)

#define curpcb		curcpu()->ci_curpcb

/*
 * Arguments to hardclock, softclock and statclock
 * encapsulate the previous machine state in an opaque
 * clockframe; for now, use generic intrframe.
 */
#define clockframe intrframe

#define	CLKF_USERMODE(frame)	USERMODE((frame)->if_cs, (frame)->if_rflags)
#define CLKF_PC(frame)		((frame)->if_rip)
#define CLKF_INTR(frame)	(curcpu()->ci_idepth > 1)

/*
 * Give a profiling tick to the current process when the user profiling
 * buffer pages are invalid.  On the i386, request an ast to send us
 * through trap(), marking the proc as needing a profiling tick.
 */
#define	need_proftick(p)	aston(p)

void signotify(struct proc *);

/*
 * We need a machine-independent name for this.
 */
extern void (*delay_func)(int);
struct timeval;

#define DELAY(x)		(*delay_func)(x)
#define delay(x)		(*delay_func)(x)


#ifdef _KERNEL
/* locore.S */
extern int biosbasemem;
extern int biosextmem;
extern int cpu;
extern int cpu_feature;
extern int cpu_ebxfeature;
extern int cpu_ecxfeature;
extern int cpu_perf_eax;
extern int cpu_perf_ebx;
extern int cpu_perf_edx;
extern int cpu_apmi_edx;
extern int ecpu_ecxfeature;
extern int cpu_id;
extern char cpu_vendor[];
extern int cpuid_level;
extern int cpuspeed;

/* cpu.c */
extern u_int cpu_mwait_size;
extern u_int cpu_mwait_states;

/* identcpu.c */
void	identifycpu(struct cpu_info *);
int	cpu_amd64speed(int *);

/* machdep.c */
void	dumpconf(void);
void	cpu_reset(void);
void	x86_64_proc0_tss_ldt_init(void);
void	x86_64_bufinit(void);
void	x86_64_init_pcb_tss_ldt(struct cpu_info *);
void	cpu_proc_fork(struct proc *, struct proc *);
int	amd64_pa_used(paddr_t);
extern void (*cpu_idle_enter_fcn)(void);
extern void (*cpu_idle_cycle_fcn)(void);
extern void (*cpu_idle_leave_fcn)(void);

struct region_descriptor;
void	lgdt(struct region_descriptor *);

struct pcb;
void	savectx(struct pcb *);
void	switch_exit(struct proc *, void (*)(struct proc *));
void	proc_trampoline(void);

/* clock.c */
extern void (*initclock_func)(void);
void	startclocks(void);
void	rtcstart(void);
void	rtcstop(void);
void	i8254_delay(int);
void	i8254_initclocks(void);
void	i8254_startclock(void);
void	i8254_inittimecounter(void);
void	i8254_inittimecounter_simple(void);

/* i8259.c */
void	i8259_default_setup(void);


void cpu_init_msrs(struct cpu_info *);


/* dkcsum.c */
void	dkcsumattach(void);

/* bus_machdep.c */
void x86_bus_space_init(void);
void x86_bus_space_mallocok(void);

/* powernow-k8.c */
void k8_powernow_init(struct cpu_info *);
void k8_powernow_setperf(int);

/* k1x-pstate.c */
void k1x_init(struct cpu_info *);
void k1x_setperf(int);

void est_init(struct cpu_info *);
void est_setperf(int);

#ifdef MULTIPROCESSOR
/* mp_setperf.c */
void mp_setperf_init(void);
#endif

#endif /* _KERNEL */

/* 
 * CTL_MACHDEP definitions.
 */
#define	CPU_CONSDEV		1	/* dev_t: console terminal device */
#define	CPU_BIOS		2	/* BIOS variables */
#define	CPU_BLK2CHR		3	/* convert blk maj into chr one */
#define	CPU_CHR2BLK		4	/* convert chr maj into blk one */
#define CPU_ALLOWAPERTURE	5	/* allow mmap of /dev/xf86 */
#define CPU_CPUVENDOR		6	/* cpuid vendor string */
#define CPU_CPUID		7	/* cpuid */
#define CPU_CPUFEATURE		8	/* cpuid features */
#define CPU_KBDRESET		10	/* keyboard reset under pcvt */
#define CPU_XCRYPT		12	/* supports VIA xcrypt in userland */
#define CPU_LIDACTION		14	/* action caused by lid close */
#define CPU_FORCEUKBD		15	/* Force ukbd(4) as console keyboard */
#define CPU_MAXID		16	/* number of valid machdep ids */

#define	CTL_MACHDEP_NAMES { \
	{ 0, 0 }, \
	{ "console_device", CTLTYPE_STRUCT }, \
	{ "bios", CTLTYPE_INT }, \
	{ "blk2chr", CTLTYPE_STRUCT }, \
	{ "chr2blk", CTLTYPE_STRUCT }, \
	{ "allowaperture", CTLTYPE_INT }, \
	{ "cpuvendor", CTLTYPE_STRING }, \
	{ "cpuid", CTLTYPE_INT }, \
	{ "cpufeature", CTLTYPE_INT }, \
	{ 0, 0 }, \
	{ "kbdreset", CTLTYPE_INT }, \
	{ 0, 0 }, \
	{ "xcrypt", CTLTYPE_INT }, \
	{ 0, 0 }, \
	{ "lidaction", CTLTYPE_INT }, \
	{ "forceukbd", CTLTYPE_INT }, \
}

/*
 * Default cr4 flags.
 * Doesn't really belong here, but doesn't really belong anywhere else
 * either. Just to avoid painful mismatches of cr4 flags since they are
 * set in three different places.
 */
#define CR4_DEFAULT (CR4_PAE|CR4_PGE|CR4_PSE|CR4_OSFXSR|CR4_OSXMMEXCPT)

#endif /* !_MACHINE_CPU_H_ */
@


1.113
log
@remove CPU_LIDSUSPEND/machdep.lidsuspend

"fire away!" tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.112 2017/06/20 05:34:41 mlarkin Exp $	*/
a425 1
#define CPU_APMWARN		9	/* APM battery warning percentage */
a426 1
#define CPU_APMHALT		11	/* halt -p hack */
d442 1
a442 1
	{ "apmwarn", CTLTYPE_INT }, \
d444 1
a444 1
	{ "apmhalt", CTLTYPE_INT }, \
@


1.112
log
@SVM: better cleanbits handling. Fixes an issue on Bulldozer CPUs causing
#TF exceptions during guest VM boot

ok brynet
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.111 2017/04/14 01:02:28 mlarkin Exp $	*/
a429 1
#define CPU_LIDSUSPEND		13	/* lid close causes a suspend */
d448 1
a448 1
	{ "lidsuspend", CTLTYPE_INT }, \
@


1.111
log
@SVM: calculate max ASID value and save for later use. This will be used in
an upcoming diff to handle ASID/VPID reuse/rollover.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.110 2017/03/16 10:02:03 mpi Exp $	*/
d81 2
@


1.110
log
@Typo, from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.109 2017/03/11 11:55:03 mpi Exp $	*/
d80 1
@


1.109
log
@Introduce a new knob to force the first USB keyboard as console input.

By setting "machdep.forceukbd=1" you can now use your USB keyboard in
ddb(4) even if your BIOS emulates a pckbd(4).

ok tom@@, kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.108 2017/03/02 10:38:10 natano Exp $	*/
d429 1
a429 1
#define CPU_FORCEUKBD		15	/* Force ukbd(4) as console keybpoard */
@


1.108
log
@Add a new sysctl machdep.lidaction. The sysctl works as follows:

machdep.lidaction=0	# do nothing
machdep.lidaction=1	# suspend
machdep.lidaction=2	# hibernate

lidsuspend is just an alias for lidaction, so if you change one, the
other one will have the same value. The plan is to remove
machdep.lidsuspend eventually when people have upgraded their
/ets/sysctl.conf.

discussed with deraadt, who came up with the new MIB name
no objections mlarkin
ok stsp halex jcs
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.107 2016/12/14 10:30:59 reyk Exp $	*/
d429 2
a430 1
#define CPU_MAXID		15	/* number of valid machdep ids */
d448 1
@


1.107
log
@Add the TSC timecounter and use it on Skylake machines where the HPET
is too slow and the invariant TSC more accurate.

The commit includes joint work by mikeb@@ kettenis@@ and me;
tested for some time by a large group of volunteers.

OK mikeb@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.106 2016/10/13 19:36:25 martijn Exp $	*/
d428 2
a429 1
#define CPU_MAXID		14	/* number of valid machdep ids */
d446 1
@


1.106
log
@Add an extra debug line when virtualization is disabled in the firmware.
This line would have saved me about an hour of hairpulling.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.105 2016/09/30 07:33:06 mlarkin Exp $	*/
d203 1
@


1.105
log
@
Compute CR3 target count. Needed for upcoming debugging diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.104 2016/09/27 08:04:49 mlarkin Exp $	*/
d186 1
@


1.104
log
@
read and cache VMFUNC capability during boot. for use in an upcoming diff
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.103 2016/09/04 09:22:28 mpi Exp $	*/
d72 1
@


1.103
log
@Introduce Dynamic Profiling, a ddb(4) based & gprof compatible kernel
profiling framework.

Code patching is used to enable probes when entering functions.  The
probes will call a mcount()-like function to match the behavior of a
GPROF kernel.

Currently only available on amd64 and guarded under DDBPROF.  Support
for other archs will follow soon.

A new sysctl knob, ddb.console, need to be set to 1 in securelevel 0
to be able to use this feature.

Inputs and ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.102 2016/07/28 21:57:57 kettenis Exp $	*/
d72 1
@


1.102
log
@Store the acpi processor ID/UID in struct cpu_info, and use it to attach
acpicpu(4) drivers to the right cpu(4).

ok mlarkin@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.101 2016/05/09 22:45:07 deraadt Exp $	*/
d176 1
a176 1
#ifdef GPROF
@


1.101
log
@2nd identical definition of PROC_PC macro is not needed
from miod
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.100 2015/12/06 23:41:32 guenther Exp $	*/
d95 1
@


1.100
log
@child_return() is already declared in <sys/proc.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.99 2015/11/23 22:57:12 deraadt Exp $	*/
a297 5

/*
 * This is used during profiling to integrate system time.
 */
#define	PROC_PC(p)		((p)->p_md.md_regs->tf_rip)
@


1.99
log
@No longer need 'option VMM', declaring the vmm0 device is sufficient.
ok mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.98 2015/11/13 07:52:20 mlarkin Exp $	*/
a385 3

/* trap.c */
void	child_return(void *);
@


1.98
log
@
vmm(4) kernel code

circulated on hackers@@, no objections. Disabled by default.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.97 2015/07/02 01:33:59 dlg Exp $	*/
a56 1
#ifdef VMM
a83 1
#endif /* VMM */
a177 1
#ifdef VMM
a185 1
#endif /* VMM */
@


1.97
log
@introduce srp, which according to the manpage i wrote is short for
"shared reference pointers".

srp allows concurrent access to a data structure by multiple cpus
while avoiding interlocking cpu opcodes. it manages its own reference
counts and the garbage collection of those data structure to avoid
use after frees.

internally srp is a twisted version of hazard pointers, which are
a relative of RCU.

jmatthew wrote the bulk of a hazard pointer implementation and
changed bpf to use it to allow mpsafe access to bpfilters. however,
at s2k15 we were trying to apply it to other data structures but
the memory overhead of every hazard pointer would have blown out
significantly in several uses cases. a bulk of our time at s2k15
was spent reworking hazard pointers into srp.

this diff adds the srp api and adds the necessary metadata to struct
cpuinfo on our MP architectures. srp on uniprocessor platforms has
alternate code that is optimised because it knows there'll be no
concurrent access to data by multiple cpus.

srp is made available to the system via param.h, so it should be
available everywhere in the kernel.

the docs likely need improvement cos im too close to the implementation.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.96 2015/06/28 18:54:54 guenther Exp $	*/
d57 30
d124 2
a125 1
	u_int32_t	ci_feature_sefflags;
d127 6
d180 10
d209 1
d333 1
@


1.96
log
@Force the return to userspace from execve to go through iretq to get all
registers.  This lets us kill the special handling of pid 1 in fork and
merge {proc,child}_trampoline(). Do the same if ptrace(PT_SETREGS) is used
to modify registers.

ok mlarkin@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.95 2015/06/13 21:41:42 guenther Exp $	*/
d133 4
@


1.95
log
@Parse _CST objects and use the C-states they describe when they're sane.

testing by many, particularly krw@@ and jcs@@
tweaks by kettenis@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.94 2015/06/07 06:24:59 guenther Exp $	*/
a318 1
void	child_trampoline(void);
@


1.94
log
@Enable use of mwait in non-MP boxes and report # of C-substates up to C7,
truncating trailing zeros.

Testing by many as part of a larger change to use ACPI _CST objects
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.93 2015/05/28 20:10:58 guenther Exp $	*/
d113 1
@


1.93
log
@Save the cpuid(6) eax bits in the cpu_info and report the SENSOR and ARAT
bits from it.

ok krw@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.92 2015/05/18 19:59:27 guenther Exp $	*/
d116 1
a196 2
extern u_int cpu_mwait_size;

d275 1
d290 4
@


1.92
log
@Do lazy update/reset of the FS.base and %[def]s segment registers: reseting
segment registers in cpu_switchto if the old thread had made it to userspace
and restoring FS.base only on first return to userspace since context switch.

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.91 2015/04/18 22:16:21 kettenis Exp $	*/
d95 1
@


1.91
log
@It seems that the CPUID lies about the monitor-line size, or at least our
interpretation of it isn't quite right.  So instead of allocating memory
and slicing it based on the parameters returned by CPUID, simply use a member
in struct cpu_info like basically all other OSes out there do.  Our struct
cpu_info is large enough to never cause any overlap.  This makes the
mwait-based idle loop actually work.  We still execute the CPUID instruction
to make sure monitor/mwait is properly supported by the hardware we're
running on.

ok sthen@@, deraadt@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.90 2015/01/15 15:30:17 sf Exp $	*/
d147 2
@


1.90
log
@Don't include i82489 headers in cpu.h

Only pmap.c was not including them explicitly. Fix that.

"The direction is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.89 2015/01/06 12:50:48 dlg Exp $	*/
d112 1
a112 2
	u_int		*ci_mwait;
/* bits in ci_mwait[0] */
d192 2
@


1.89
log
@when we're entering an interrupt handler, record its ipl so splassert
can check if we're entering code we think should only be used from
lower ipls.

modelled a bit on how sparc64 does things.

with help from and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.88 2014/12/16 21:20:23 tedu Exp $	*/
a48 6

#ifdef MULTIPROCESSOR
#include <machine/i82489reg.h>
#include <machine/i82489var.h>
#endif

@


1.88
log
@these headers do not need to (and should not) include lock.h poisoning
the namespace. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.87 2014/12/02 18:13:10 tedu Exp $	*/
d88 1
@


1.87
log
@delete all the simplelocks. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.86 2014/09/12 09:52:45 kettenis Exp $	*/
a57 1
#include <sys/lock.h>
@


1.86
log
@Remove the code that attempts to synchronize P-state transitions between CPUs.
Spinning inside an IPI handler is generally a bad idea as it is very hard to
avoid deadlocks.  As far as I can tell the synchronization isn't necessary.
Multi-core CPUs have hardware mechanisms to do the appropropriate coordination
between cores and coordination between sockets isn't necessary either.

This seems to fix the various hangs and suspend/resume failures that people
have been seeing when running apmd -A or apmd -C.

Tested by many.
ok kspillner@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.85 2014/07/11 10:53:07 uebayasi Exp $	*/
a71 1
	struct simplelock ci_slock;
@


1.85
log
@CPU_BUSY_CYCLE(): A new MI statement for busy loop power reduction

The new CPU_BUSY_CYCLE() may be put in a busy loop body so that CPU can reduce
power consumption, as Linux's cpu_relax() and FreeBSD's cpu_spinwait().  To
start minimally, use PAUSE on i386/amd64 and empty on others.  The name is
chosen following the existing cpu_idle_*() functions.  Naming and API may be
polished later.

OK kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a137 6

	volatile int ci_setperf_state;
#define CI_SETPERF_READY	0
#define CI_SETPERF_SHOULDSTOP	1
#define CI_SETPERF_INTRANSIT	2
#define CI_SETPERF_DONE		3
@


1.84
log
@
Fixes a hibernate issue wherein we locked the kernel lock while hatching
but then parked ourselves in real mode without completing acquisition of
said lock. Also removes the park routine from i386 since we don't need it
(the APs are already parked at the time we start unpack).

discussed with and ok kettenis@@, also ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.83 2014/02/13 23:11:06 kettenis Exp $	*/
d210 2
d223 2
@


1.83
log
@Some Linux i915 drm "fast" path code relies on being able to "disable" page
faults to avoid sleeping.  Implement this functionality for i386 and amd64
for faults in the user address space.  If the ci_inatomic flag is set in
struct cpu_info, copyin(9) and copyout(9) will return EFAULT when a user-space
address needs to be faulted in.  Use this to properly implement
__copy_to_user_inatomic() and __copy_from_user_inatomic_nocache() in the
inteldrm(4) code.

ok krw@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.82 2013/10/05 16:58:30 guenther Exp $	*/
d166 1
@


1.82
log
@Use monitor/mwait to idle when available.  Make cpu_unidle() do nothing
if can tell the target CPU isn't actually idling and introduce cpu_kick()
for the cases where we want to force a non-idle CPU into the kernel.

critical review of early versions by weingart@@; testing by many
ok haesbaert@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.81 2013/06/04 15:29:16 haesbaert Exp $	*/
d107 2
@


1.81
log
@Cpu topology for AMD64.

This adds information about smt id (thread), core id and package id
(socket) to amd64.

ci_smt_id, ci_core_id, ci_pkg_id should be followed by other
archictectures and core relying on them should be under
ARCH_HAVE_CPU_TOPOLOGY.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.80 2013/03/31 17:07:02 deraadt Exp $	*/
d117 6
d204 1
d216 1
@


1.80
log
@try to avoid pulling in pte.h and other more crazy things.  Checked against
the things that libkvm needs.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.79 2013/03/12 09:37:16 mpi Exp $	*/
d107 5
@


1.79
log
@Fix kernel profiling on MP systems by using per-CPU buffers and teach
kgmon(8) to deal with them, this time without public header changes.

Previously various CPUs were iterating over the same global buffer at
the same time to modify it and never ended.

This diff includes some ideas submited by Thor Simon to NetBSD via miod@@.

ok deraadt@@, mikeb@@, haesbaert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.78 2013/02/12 08:06:22 mpi Exp $	*/
d44 1
d47 1
a48 1
#include <machine/cacheinfo.h>
d55 2
d217 2
a219 2

#include <machine/psl.h>
@


1.78
log
@Back out per-CPU kernel profiling, it shouldn't modify a public header
at this moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.77 2013/02/11 17:05:25 mpi Exp $	*/
d131 3
@


1.77
log
@Fix kernel profiling on MP systems by using per-CPU buffer. Previously
various CPUs were iterating over the same global buffer at the same
time to modify it and never ended.

This diff includes some ideas submited by Thor Simon to NetBSD via miod@@.

ok mikeb@@, haesbaert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.76 2012/12/02 07:03:31 guenther Exp $	*/
a130 3
#ifdef GPROF
	struct gmonparam	*ci_gmon;
#endif
@


1.76
log
@Determine whether we're currently on the alternative signal stack
dynamically, by comparing the stack pointer against the altstack
base and size, so that you get the correct answer if you longjmp
out of the signal handler, as tested by regress/sys/kern/stackjmp/.
Also, fix alt stack handling on vax, where it was completely broken.

Testing and corrections by miod@@, krw@@, tobiasu@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.75 2012/11/10 09:45:05 mglocker Exp $	*/
d131 3
@


1.75
log
@Recent x86 CPUs come with a constant time stamp counter.  If this is
the case we verify if the CPU supports a specific version of the
architectural performance monitoring feature and read out the current
frequency from the fixed-function performance counter of the unhalted
core.

My initial motivation to implement this was the Soekris net6501-70
which comes with an Intel Atom E6xx 1.60GHz CPU.  It has a constant
time stamp counter plus speed step support and boots on the lowest
frequency of 600MHz.  This caused hw.cpuspeed and hw.setperf to
reflect the wrong values.

The diff is a cooperation work with jsg@@.  The fixed-function
performance counter read code comes from a former diff of him.

OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.74 2012/10/09 04:40:36 jsg Exp $	*/
d149 1
@


1.74
log
@Enable Supervisor Mode Execution Protection (SMEP), found in recent
Intel chips.  If the kernel is tricked into running code from a user
page while in supervisor mode we'll now get a page fault and panic
instead of running it.

suggestions and ok guenther@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.73 2012/04/17 16:02:33 guenther Exp $	*/
d141 2
d263 4
@


1.73
log
@Don't try to cache the CPU's FS.base, as userland can make it a lie by
setting %fs, resulting in it not getting restored properly later

ok mikeb@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.72 2012/04/04 18:44:22 mikeb Exp $	*/
d98 1
@


1.72
log
@Make sure that identifycpu() is run only once; fixes occasional
hangs on resume.  Discussed with and ok kettenis, haesbaert
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.71 2012/03/27 02:23:04 haesbaert Exp $	*/
a74 1
	u_int64_t ci_cur_fsbase;
@


1.71
log
@Run identifycpu() on its own cpu.
Discussed with many on hackers.

"Go ahead" kettenis@@
"Get to it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.70 2011/12/26 23:07:04 haesbaert Exp $	*/
d139 1
@


1.70
log
@Add the missing ECX cpu flags from CPUID at 0x80000001.
This is all documented at:

http://support.amd.com/us/Embedded_TechDocs/25481.pdf (page 20)
http://www.intel.com/assets/pdf/appnote/241618.pdf (page 41)

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.69 2011/09/20 14:32:50 pirofti Exp $	*/
d138 2
a268 1
void cpu_probe_features(struct cpu_info *);
@


1.69
log
@Fix bogus comment. Okay miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.68 2011/06/16 19:46:40 kettenis Exp $	*/
d258 1
@


1.68
log
@Raise the number of interrupt sources per CPU from 32 to 64.  This effectively
triples the number of interrupt vectors that can be handled by the primary
CPU.  Important for MSI, but could also fix some issues with large machines
loaded with a lot of devices.

tested by many; ok deraadt@@, marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.67 2011/05/23 09:52:24 claudio Exp $	*/
d163 1
a163 1
#define MAXCPUS		64	/* bitmask; can be bumped to 64 */
@


1.67
log
@AMD K10/K11 pstate driver allows setperf and apm to change CPU
frequencies on newer AMD systems.
Driver written by Bryan Steele / brynet gmail.com
Put it in deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.66 2011/04/13 02:49:12 guenther Exp $	*/
d85 1
a85 1
	u_int32_t	ci_ipending;
d88 2
a89 2
	u_int32_t	ci_imask[NIPL];
	u_int32_t	ci_iunmask[NIPL];
@


1.66
log
@Unrevert the FS.base diff: the issues were actually elsewhere
Additional testing by jasper@@ and pea@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.65 2011/04/10 03:56:38 guenther Exp $	*/
d320 4
@


1.65
log
@Revert bulk of the FS.base diff, as it causes issues on some machines
and the problem isn't obvious yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.64 2011/04/05 21:14:00 guenther Exp $	*/
d75 1
@


1.64
log
@Add support for per-rthread base-offset for the %fs selector on amd64.
Add pcb_fsbase to the PCB for tracking what the value for the thread
is, and ci_cur_fsbase to struct cpu_info for tracking the CPU's current
value for FS.base, then on return to user-space, skip the setting if the
CPU has the right value already.  Non-threaded processes without TLS leave
FS.base zero, which can be conveniently optimized: setting %fs zeros
FS.base for fewer cycles than wrmsr.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.63 2011/03/23 16:54:34 pirofti Exp $	*/
a74 1
	u_int64_t ci_cur_fsbase;
@


1.63
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.62 2010/11/29 00:04:09 dlg Exp $	*/
d75 1
@


1.62
log
@bump the number of supported cpus from 32 up to 64. lets me attach and use
all 48 cores in one of my boxes.

requested by deraadt@@
made possible by the recent pmap diff by kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.61 2010/11/26 11:59:40 krw Exp $	*/
d38 2
a39 2
#ifndef _AMD64_CPU_H_
#define _AMD64_CPU_H_
d373 1
a373 1
#endif /* !_AMD64_CPU_H_ */
@


1.61
log
@Nuke the unused variable cpus_attached. It is unused and 32 bits
aren't enough to keep track of possible cores these days anyway.

36-core amd64 box encountered by dlg@@

ok dlg@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.60 2010/11/22 21:07:18 miod Exp $	*/
d162 1
a162 1
#define MAXCPUS		32	/* bitmask; can be bumped to 64 */
@


1.60
log
@Remove prototypes for missing (removed) functions or already found in a
MI header file.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.59 2010/11/13 04:16:42 guenther Exp $	*/
a212 2

extern u_int32_t cpus_attached;
@


1.59
log
@Switch from TSS-per-process to TSS-per-CPU, placing the TSS right
next to the cpu's GDT, also making the double-fault stack per-CPU,
leaving it at the top of the page of the CPU's idle process.  Inline
pmap_activate() and pmap_deactivate() into the asm cpu_switchto
routine, adding a check for the new pmap already being marked as
active on the CPU.  Garbage collect the hasn't-been-used-in-years
GDT update IPI.

Tested by many; ok mikeb@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.58 2010/10/02 23:13:27 deraadt Exp $	*/
a312 3

/* consinit.c */
void kgdb_port_init(void);
@


1.58
log
@make ci_flags volatile; some future MD code will depend on this.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.57 2010/09/28 20:27:54 miod Exp $	*/
a45 1
#include <machine/tss.h>
d61 1
a81 1
	int ci_idle_tss_sel;
d112 1
a127 4
	struct x86_64_tss	ci_doubleflt_tss;

	char *ci_doubleflt_stack;

a270 1
int	cpu_maxproc(void);
@


1.57
log
@Implement a per-cpu held mutex counter if DIAGNOSTIC on all non-x86 platforms,
to complete matthew@@'s commit of a few days ago, and drop __HAVE_CPU_MUTEX_LEVEL
define. With help from, and ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.56 2010/09/24 13:21:30 matthew Exp $	*/
d94 1
a94 1
	u_int		ci_flags;
@


1.56
log
@Add stricter asserts to DIAGNOSTIC kernels to help catch mutex and
rwlock misuse.  In particular, this commit makes the following
changes:

  1. i386 and amd64 now count the number of active mutexes so that
assertwaitok(9) can detect attempts to sleep while holding a mutex.

  2. i386 and amd64 check that we actually hold mutexes when passed to
mtx_leave().

  3. Calls to rw_exit*() now call rw_assert_{rd,wr}lock() as
appropriate.

ok krw@@, oga@@; "sounds good to me" deraadt@@; assembly bits double
checked by pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.55 2010/08/11 21:22:44 kettenis Exp $	*/
a91 1
#define __HAVE_CPU_MUTEX_LEVEL
@


1.55
log
@Disable the RTC the periodic interrupt.  Leaving it enabled causes the
Dell Inspirion 4150 to wake up immediately even though RTC_EN isn't set
in the PM1 Enable register.

ok deraadt@@, mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.54 2010/08/05 21:10:10 deraadt Exp $	*/
d90 4
@


1.54
log
@new i386/amd64 machdep.lidsuspend sysctl which decides whether a lid
close causes a suspend.  resumes are not tied to this; they happen
unconditionally.  this is a temporary knob for the 4.8 release; afterwards
it will move to a more convenient place
much moaning discussing where to put the knob with kettenis
tested by various including phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.53 2010/07/25 21:43:38 deraadt Exp $	*/
d296 1
@


1.53
log
@in the clock drivers, seperate the soft-state and hard-state which was
all jumbled up in the same functions. the rtc (mc chip) and clock (i8243)
startup was also mixed up.  they the soft state and hardware state can
be started in the right order, and it is easy to restart just the
neccessary parts upon resume.  tested in numerous cases:
(apic, pic) * (GENERIC.MP, GENERIC) * (mp, non-mp) * (i386, amd64)
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.52 2010/07/21 14:08:09 kettenis Exp $	*/
d351 2
a352 1
#define CPU_MAXID		13	/* number of valid machdep ids */
d368 1
@


1.52
log
@Make sure that the FPU IPIs shoot down the right FPU context and not the FPU
context of some random process that happened to be switched onto the FPU
after the decision was made to send the IPI.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.51 2009/12/09 14:27:34 oga Exp $	*/
d293 3
a295 2
void	initrtclock(void);
void	startrtclock(void);
d298 1
@


1.51
log
@Detect the cache line size for the clflush instruction when we identify
the cpu.

ok kettenis@@ as part of a larger diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.50 2009/11/22 21:41:37 pirofti Exp $	*/
d77 1
@


1.50
log
@Bring amd64 closer to resume, while at it kill dead code. Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.49 2009/07/22 20:33:13 deraadt Exp $	*/
d98 1
@


1.49
log
@via nano cpus are amd64, and so we need machdep.xcrypt
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.48 2009/06/09 02:56:38 krw Exp $	*/
d297 3
@


1.48
log
@revert guenther@@'s un-revert of art's curpmap.

My

bios0: ASUSTeK Computer INC. P5K-E
cpu0: Intel(R) Core(TM)2 Quad CPU Q6600 @@ 2.40GHz, 2405.74 MHz
cpu1: Intel(R) Core(TM)2 Quad CPU Q6600 @@ 2.40GHz, 2405.46 MHz
cpu2: Intel(R) Core(TM)2 Quad CPU Q6600 @@ 2.40GHz, 2405.46 MHz
cpu3: Intel(R) Core(TM)2 Quad CPU Q6600 @@ 2.40GHz, 2405.46 MHz

can't boot with this in. It always hangs somewhere in fsck'ing if
any, or between netstart and local daemons if no fsck'ing. Also
fubars theo's real amd machine.

Much more testing needed for this.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.47 2009/06/06 23:45:36 guenther Exp $	*/
d343 2
a344 1
#define CPU_MAXID		12	/* number of valid machdep ids */
d359 1
@


1.47
log
@Unrevert the curpmap change with the addition of correct %gs handling
in the IPI handler so that it works when it interrupts userspace,
waiting for the droppmap IPI to complete when destroying it, and
(most importantly) don't call pmap_tlb_droppmap() from cpu_exit().
Tested by myself and ckuethe, as our machines choked on the original.

ok @@art
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.45 2009/06/02 03:04:54 jordan Exp $	*/
a81 2

	struct pmap *ci_curpmap;
@


1.46
log
@Revert the curpmap change.  We know the IPI is broken on both ends,
but even with proposed fixes, the reaper panics are back.
@
text
@d83 2
@


1.45
log
@Added interface for cpu idle on amd64
ok gwk@@, toby@@, marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.44 2009/05/28 09:05:33 art Exp $	*/
a81 2

	struct pmap *ci_curpmap;
@


1.44
log
@Bring back the curpmap change. It was missing a reload of the pmap on
curcpu when we were freeing a pmap. Tested and working for a few weeks
now, but I was a bit too busy to commit it earlier.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.42 2009/04/23 07:42:02 art Exp $	*/
d279 3
@


1.43
log
@turning pmap_deactivate into a NOP brought back the reaper panics, probably
because the reaper is running on the mappings of pmap from the process it
is about to unmap.  back it out until ht is fixed right; don't let this sit
in the tree waiting for a fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.41 2009/02/16 15:50:05 jsg Exp $	*/
a71 2
	u_long ci_spin_locks;
	u_long ci_simple_locks;
a78 2
	volatile u_int32_t ci_tlb_ipi_mask;

d83 2
a91 1
	paddr_t 	ci_idle_pcb_paddr;
a108 5

	struct timeval 	ci_cc_time;
	int64_t		ci_cc_cc;
	int64_t		ci_cc_ms_delta;
	int64_t		ci_cc_denom;
@


1.42
log
@Make pmap_deactivate a NOP.

Instead of keeping a bitmask of on which cpu the pmap might be active which
we clear in pmap_deactivate, always keep a pointer to the currently loaded
pmap in cpu_info. We can now optimize a context switch to the kernel pmap
(idle and kernel threads) to keep the previously loaded pmap still loaded
and then reuse that pmap if we context switch back to the same process.

Introduce a new IPI to force a pmap reload before the pmap is destroyed.

Clean up cpu_switchto.

toby@@ ok
@
text
@d72 2
d81 2
a86 2
	struct pmap *ci_curpmap;

d94 1
d112 5
@


1.41
log
@Store conditionally extended cpuid family/model values
in seperate variables in struct cpu_info instead
of duplicating the process of extracting it from the signature.

Discussed with several, 'just do it' weingart@@, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.40 2009/02/13 20:47:05 andreas Exp $	*/
a71 2
	u_long ci_spin_locks;
	u_long ci_simple_locks;
a78 2
	volatile u_int32_t ci_tlb_ipi_mask;

d83 2
a91 1
	paddr_t 	ci_idle_pcb_paddr;
a108 5

	struct timeval 	ci_cc_time;
	int64_t		ci_cc_cc;
	int64_t		ci_cc_ms_delta;
	int64_t		ci_cc_denom;
@


1.40
log
@Make "boot -d" work on amd64 MP.
Prodded by oga@@ (a long time ago) and mikeb@@
Also ok by kettenis@@ and grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.39 2008/11/22 18:12:32 art Exp $	*/
d101 2
@


1.39
log
@The last parts of cpu_unidle. i386, amd64 and sparc64
In short, make cpu_unidle do what signotify used to do and
make signotify use cpu_unidle.
Also, include a cpu_unidle in need_resched, it won't change much right now
but will be needed in the future.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.38 2008/10/15 23:23:46 deraadt Exp $	*/
d158 1
a158 1
#define CPU_INFO_UNIT(ci)	((ci)->ci_dev->dv_unit)
@


1.38
log
@make random(9) return per-cpu values (by saving the seed in the cpuinfo),
which are uniform for the profclock on each cpu in a SMP system (but using
a different seed for each cpu).  on all cpus, avoid seeding with a value out
of the [0, 2^31-1] range (since that is not stable)
ok kettenis drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.37 2008/07/18 23:43:31 art Exp $	*/
d187 2
d197 2
@


1.37
log
@Add a macro that clears the want_resched flag that need_resched sets.
Right now when mi_switch picks up the same proc, we didn't clear the
flag which would mean that every time we service an AST we would attempt
a context switch. For some architectures, amd64 being probably the
most extreme, that meant attempting to context switch for every
trap and interrupt.

Now we clear_resched explicitly after every context switch, even if it
didn't do anything. Which also allows us to remove some more code
in cpu_switchto (not done yet).

miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.36 2008/06/10 02:55:39 weingart Exp $	*/
d74 1
@


1.36
log
@All your memory belong to us.  This has been in snaps for a while,
and seems to work.  If it breaks, people had plenty of chances to
complain.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.35 2008/06/09 20:43:43 miod Exp $	*/
d164 1
@


1.35
log
@Remove fillw(). Bonus points if you do not remember what it was used for.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.34 2008/05/26 07:47:19 jasper Exp $	*/
d278 1
@


1.34
log
@- also zap userldt here

from travers buda, via deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.33 2007/11/16 16:16:07 deraadt Exp $	*/
a280 1
void	fillw(short, void *, size_t);
@


1.33
log
@fix the bus_space #define nightmare, so that amd64 and i386 are much more
uniform. as a result shared code like acpi needs less #ifdef's
ok marco kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.32 2007/11/01 23:30:46 mikeb Exp $	*/
d342 1
a342 2
#define CPU_USERLDT		12
#define CPU_MAXID		13	/* number of valid machdep ids */
a356 1
	{ "userldt", CTLTYPE_INT }, \
@


1.32
log
@Remove curproc definition.  It is supposed to be in proc.h only.

ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.31 2007/05/29 18:53:52 deraadt Exp $	*/
d167 1
a167 1
#define X86_MAXPROCS		32	/* bitmask; can be bumped to 64 */
d180 1
a180 1
extern struct cpu_info *cpu_info[X86_MAXPROCS];
d187 1
a187 1
#define X86_MAXPROCS		1
@


1.31
log
@take a lot more stuff out of userland namespace (sysctl cared about ksensor use); ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.30 2007/05/29 06:31:44 tedu Exp $	*/
a217 1
#define curproc		curcpu()->ci_curproc
@


1.30
log
@Some improvements for better intel cpu support.
Add EST support from i386, minus the tables
Also add in support for CPU temperature sensors, based on diff to tech
by Pierre Riteau.
ok deraadt gwk
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.29 2007/05/10 17:59:24 deraadt Exp $	*/
d60 2
d204 2
@


1.29
log
@evcnt & friends were replaced by a proper interrupt counting mechanism 3 years ago; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.28 2007/05/07 19:10:31 kettenis Exp $	*/
d58 1
d131 3
d314 3
@


1.28
log
@Garbage collect ci_astpending; it's no longer used.

ok miod@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.27 2007/05/06 03:37:08 gwk Exp $	*/
a129 2

	struct evcnt ci_ipi_events[X86_NIPI];
@


1.27
log
@Add the mp setperf mechanism to AMD64, like its i386 counterpart it allows
all cpus in a system supporting frequency and voltage scaling to be scaled
by the same amount corresponding to the user (or apmd on their behalf)
performance level.

This diff also teaches amd64 about acpi_hasprocfvs (ACPI has processor
frequency and voltage scaling).

It also moves initilization of the underlying setperf mechanism such
as powernow to mainbus from the cpu indentification and initilization
code inspired by similar changes dim@@ made to i386 durring h2k6. This
is necessary to implement the AMD recommended method for retreiving
p_state data from the ACPI _PSS object (a diff comming soon). It will
also simplify the potential addition of enhanced speedstep as found
on newer intel processors with EMT64 capable of running OpenBSD/amd64.

MP setperf functionality verifed by myself and Johan M:son Lindman <tybolt
AT solace DOT miun DOT se> on opteron 265 and 270 systems respectively.
General testing done by many others thanks!

ok tedu, dim
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.26 2007/03/15 10:22:29 art Exp $	*/
a103 1
	int		ci_astpending;
@


1.26
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.25 2007/02/17 17:35:43 tom Exp $	*/
d122 6
d311 1
a311 1
void k8_powernow_init(void);
d313 5
@


1.25
log
@Add code to check for the AMD amd64 errata, and correct them where
possible.  Taken from NetBSD.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.24 2007/02/01 20:42:17 art Exp $	*/
d230 1
a230 1
#define	need_proftick(p)	((p)->p_flag |= P_OWEUPC, aston(p))
@


1.24
log
@When doing signotify, check if we're notifying a process on another
cpu and if we do, send it an IPI that will force to get into the kernel
and process the AST.

This makes signals to processes on other CPUs to be actually delivered
as soon as possible instead of some time in the future when some
interupt happens.

heavy testing by krw@@, miod@@ ok (in principle, since he doesn't do amd64)
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.23 2006/12/24 20:30:35 miod Exp $	*/
a242 4

/*
 * pull in #defines for kinds of processors
 */
@


1.23
log
@Define PROC_PC. Then, since profiling information is being reported in
statclock(), do not bother doing this in userret() anymore. As a result,
userret() does not need its pc and ticks arguments, simplify.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.22 2006/12/20 22:48:29 gwk Exp $	*/
d232 1
a232 5
/*
 * Notify the current process (p) that it has a signal pending,
 * process as soon as possible.
 */
#define	signotify(p)		aston(p)
@


1.22
log
@Decalre extern int cpuspeed in sys/arch/amd64/include/cpu.h like cpuspeed
is declared in the equivalent file on i386 and delete the repeticious
declarations already scattered in a few places.
Thanks to Will Backman for letting me test this on his machine,
ok mk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.21 2006/12/12 23:14:27 dim Exp $	*/
d219 5
@


1.21
log
@Complete gwk's previous patch to stop setperf methods from returning
errors to userland: make all cpu_setperf functions return void.

Tested by many, ok gwk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.20 2006/11/25 16:59:31 niklas Exp $	*/
d256 1
a258 1

@


1.20
log
@sync amd64 to i386 w.r.t. acpi support. Also fix interrupt routing for multi-ioapic systems.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.19 2006/11/07 09:09:42 otto Exp $	*/
d309 1
a309 1
int  k8_powernow_setperf(int);
@


1.19
log
@Timecounters for amd64. Diff by art@@, tested by many. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.18 2006/03/08 03:33:21 uwe Exp $	*/
d49 5
@


1.18
log
@Patch from Gordon Klock to update AMD PowerNow K8 support on i386,
and to add amd64 K8 support from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.17 2005/12/13 00:18:19 jsg Exp $	*/
a232 1
extern void (*microtime_func)(struct timeval *);
a235 1
#define microtime(tv)		(*microtime_func)(tv)
a251 6
/* kern_microtime.c */

extern struct timeval cc_microset_time;
void	cc_microtime(struct timeval *);
void	cc_microset(struct cpu_info *);

a280 1
void	i8254_microtime(struct timeval *);
d282 3
@


1.17
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.
Checked by ian@@, deraadt@@ and millert@@, arm portion checked by drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.16 2005/09/25 20:48:21 miod Exp $	*/
d307 4
@


1.16
log
@Turn CPU_INFO_FOREACH into a real construct, like all queue(3) iterators,
instead of the contents of a for() loop. No functional change.
From the m88k SMP tree; ok art@@ deraadt@@

[complete diff this time]
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.15 2005/09/20 23:00:34 deraadt Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.15
log
@unbreak tree, how did you do that miod
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.13 2005/08/20 00:33:59 jsg Exp $	*/
d144 2
a145 2
#define CPU_INFO_FOREACH(cii, ci)	cii = 0, ci = cpu_info_list; \
					ci != NULL; ci = ci->ci_next
@


1.14
log
@Turn CPU_INFO_FOREACH into a real construct, like all queue(3) iterators,
instead of the contents of a for() loop. No functional change.
From the m88k SMP tree; ok art@@ deraadt@@
@
text
@d144 2
a145 2
#define CPU_INFO_FOREACH(cii, ci)	for (cii = 0, ci = cpu_info_list; \
					    ci != NULL; ci = ci->ci_next)
@


1.13
log
@Check for and report the presense of SSE3.  This has started to appear
in AMD products with the arrival of the venice core.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.12 2005/07/26 08:38:29 art Exp $	*/
d144 2
a145 2
#define CPU_INFO_FOREACH(cii, ci)	cii = 0, ci = cpu_info_list; \
					ci != NULL; ci = ci->ci_next
@


1.12
log
@Instead of juggling around with cr4 and enabling parts of it sometimes,
other parts later, etc. Just set it to the same default value everywhere.
We won't survive without PSE and tt's not like someone will suddenly make
an amd64 that doesn't support PGE.

This will allow us to make the bootstrap process slightly more sane.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.11 2005/04/19 15:14:11 mickey Exp $	*/
d253 1
@


1.11
log
@CLKF_BASEPRI we do not have no more; noticed by miod
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.10 2004/06/25 17:27:01 andreas Exp $	*/
d345 8
@


1.10
log
@'machine cpuinfo' and 'machine ddbcpu' in ddb for amd64
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.9 2004/06/25 11:03:28 art Exp $	*/
a215 1
#define CLKF_BASEPRI(frame)	(0)
@


1.9
log
@SMP support. Big parts from NetBSD, but with some really serious debugging
done by me, niklas and others. Especially wrt. NXE support.

Still needs some polishing, especially in dmesg messages, but we're now
building kernel faster than ever.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.8 2004/06/22 01:16:50 art Exp $	*/
a103 1
	struct trapframe *ci_ddb_regs;
d114 7
a121 1
	struct x86_64_tss	ci_ddbipi_tss;
a123 1
	char *ci_ddbipi_stack;
@


1.8
log
@Switch amd64 to __HAVE_CPUINFO

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.7 2004/06/13 21:49:13 niklas Exp $	*/
d143 2
a181 2
#include <machine/psl.h>

d191 6
d232 1
a232 1
extern void delay(int);
d234 1
a234 1
extern void microtime(struct timeval *);
d236 3
a238 1
#define DELAY(x)		delay(x)
a266 1
void	delay(int);
@


1.7
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d56 1
a60 1
#if 0
a61 1
#endif
d143 6
a168 7

/*      
 * Preempt the current process if in interrupt from user mode,
 * or after the current trap/syscall if in system mode.
 */
extern void need_resched(struct cpu_info *);

d180 2
a188 13
/*
 * Preempt the current process if in interrupt from user mode,
 * or after the current trap/syscall if in system mode.
 */

#define need_resched(ci)						\
do {									\
	struct cpu_info *__ci = curcpu();					\
	__ci->ci_want_resched = 1;					\
	if (__ci->ci_curproc != NULL)					\
		aston(__ci->ci_curproc);				\
} while (/*CONSTCOND*/0)

a301 2

#include <machine/psl.h>
@


1.6
log
@simplify the delay stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.5 2004/02/28 18:12:21 deraadt Exp $	*/
a193 1
#ifdef MULTIPROCESSOR
d196 1
a196 1
	struct cpu_info *__ci = (ci);					\
a200 9
#else
#define need_resched()							\
do {									\
	struct cpu_info *__ci = curcpu();				\
	__ci->ci_want_resched = 1;					\
	if (__ci->ci_curproc != NULL)					\
		aston(__ci->ci_curproc);				\
} while (/*CONSTCOND*/0)
#endif
d202 1
a202 1
#endif
@


1.5
log
@sysctl hw.cpuspeed output
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.4 2004/02/25 00:16:41 deraadt Exp $	*/
d249 1
a249 1
extern void (*delay_func)(int);
d251 1
a251 1
extern void (*microtime_func)(struct timeval *);
d253 1
a253 3
#define DELAY(x)		(*delay_func)(x)
#define delay(x)		(*delay_func)(x)
#define microtime(tv)		(*microtime_func)(tv)
@


1.4
log
@dkcsum stuff for amd64, written by tom, who cannot commit it at the moment.
now the amd64 knows what drive it was booted from.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.3 2004/02/11 03:07:46 deraadt Exp $	*/
d280 1
@


1.3
log
@permit installboot to at least compile... remove some crud
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.1 2004/01/28 01:39:39 mickey Exp $	*/
d314 3
@


1.3.2.1
log
@The merge of these files were done to another date than the rest, fix.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d95 1
d330 12
a341 7
#define	CPU_BIOSBASEMEM		2	/* int: bios-reported base mem (K) */
#define	CPU_BIOSEXTMEM		3	/* int: bios-reported ext. mem (K) */
#define	CPU_NKPDE		4	/* int: number of kernel PDEs */
#define	CPU_BOOTED_KERNEL	5	/* string: booted kernel name */
#define CPU_DISKINFO		6	/* disk geometry information */
#define CPU_FPU_PRESENT		7	/* FPU is present */
#define	CPU_MAXID		8	/* number of valid machdep ids */
d346 11
a356 6
	{ "biosbasemem", CTLTYPE_INT }, \
	{ "biosextmem", CTLTYPE_INT }, \
	{ "nkpde", CTLTYPE_INT }, \
	{ "booted_kernel", CTLTYPE_STRING }, \
	{ "diskinfo", CTLTYPE_STRUCT }, \
	{ "fpu_present", CTLTYPE_INT }, \
a357 28


/*
 * Structure for CPU_DISKINFO sysctl call.
 * XXX this should be somewhere else.
 */
#define MAX_BIOSDISKS	16

struct disklist {
	int dl_nbiosdisks;			   /* number of bios disks */
	struct biosdisk_info {
		int bi_dev;			   /* BIOS device # (0x80 ..) */
		int bi_cyl;			   /* cylinders on disk */
		int bi_head;			   /* heads per track */
		int bi_sec;			   /* sectors per track */
		u_int64_t bi_lbasecs;		   /* total sec. (iff ext13) */
#define BIFLAG_INVALID		0x01
#define BIFLAG_EXTINT13		0x02
		int bi_flags;
	} dl_biosdisks[MAX_BIOSDISKS];

	int dl_nnativedisks;			   /* number of native disks */
	struct nativedisk_info {
		char ni_devname[16];		   /* native device name */
		int ni_nmatches; 		   /* # of matches w/ BIOS */
		int ni_biosmatches[MAX_BIOSDISKS]; /* indices in dl_biosdisks */
	} dl_nativedisks[1];			   /* actually longer */
};
@


1.3.2.2
log
@Merge with the trunk
@
text
@a94 1
	u_int32_t	ci_feature_eflags;
d248 1
a248 1
extern void delay(int);
d250 1
a250 1
extern void microtime(struct timeval *);
d252 3
a254 1
#define DELAY(x)		delay(x)
a278 1
int	cpu_amd64speed(int *);
a313 3
/* dkcsum.c */
void	dkcsumattach(void);

d329 7
a335 12
#define	CPU_BIOS		2	/* BIOS variables */
#define	CPU_BLK2CHR		3	/* convert blk maj into chr one */
#define	CPU_CHR2BLK		4	/* convert chr maj into blk one */
#define CPU_ALLOWAPERTURE	5	/* allow mmap of /dev/xf86 */
#define CPU_CPUVENDOR		6	/* cpuid vendor string */
#define CPU_CPUID		7	/* cpuid */
#define CPU_CPUFEATURE		8	/* cpuid features */
#define CPU_APMWARN		9	/* APM battery warning percentage */
#define CPU_KBDRESET		10	/* keyboard reset under pcvt */
#define CPU_APMHALT		11	/* halt -p hack */
#define CPU_USERLDT		12
#define CPU_MAXID		13	/* number of valid machdep ids */
d340 6
a345 11
	{ "bios", CTLTYPE_INT }, \
	{ "blk2chr", CTLTYPE_STRUCT }, \
	{ "chr2blk", CTLTYPE_STRUCT }, \
	{ "allowaperture", CTLTYPE_INT }, \
	{ "cpuvendor", CTLTYPE_STRING }, \
	{ "cpuid", CTLTYPE_INT }, \
	{ "cpufeature", CTLTYPE_INT }, \
	{ "apmwarn", CTLTYPE_INT }, \
	{ "kbdreset", CTLTYPE_INT }, \
	{ "apmhalt", CTLTYPE_INT }, \
	{ "userldt", CTLTYPE_INT }, \
d347 28
@


1.3.2.3
log
@need_resched macro needs to take ci arg to be compat with MP function
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.3.2.2 2004/06/05 23:09:25 niklas Exp $	*/
d194 1
d202 9
d212 1
a212 1
#endif	/* MULTIPROCESSOR */
@


1.3.2.4
log
@need_resched macro needs to take ci arg to be compat with MP function
@
text
@a122 7
	volatile int ci_ddb_paused;     /* paused due to other proc in ddb */
#define CI_DDB_RUNNING		0
#define CI_DDB_SHOULDSTOP	1
#define CI_DDB_STOPPED		2
#define CI_DDB_ENTERDDB		3
#define CI_DDB_INDDB		4

a168 1
#if 0
a169 2
#endif
extern void need_resched(void);
a193 1
#ifdef MULTIPROCESSOR
a200 9
#else
#define need_resched()							\
do {									\
	struct cpu_info *__ci = curcpu();				\
	__ci->ci_want_resched = 1;					\
	if (__ci->ci_curproc != NULL)					\
		aston(__ci->ci_curproc);				\
} while (/*CONSTCOND*/0)
#endif
d202 1
a202 1
#endif
a316 4

#ifdef MULTIPROCESSOR
#include <sys/mplock.h>
#endif
@


1.3.2.5
log
@this is the cpu.h we want
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.3.2.3 2004/06/06 05:23:38 tedu Exp $	*/
d123 7
d176 1
d178 2
d204 1
d212 9
d222 1
a222 1
#endif	/* MULTIPROCESSOR */
d337 4
@


1.3.2.6
log
@need_resched flipflop until there's curcpu everywhere
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.3.2.5 2004/06/06 21:58:49 tedu Exp $	*/
d196 1
a196 1
	struct cpu_info *__ci = curcpu();					\
@


1.2
log
@repair cpu dmesg print a bit
@
text
@d330 12
a341 7
#define	CPU_BIOSBASEMEM		2	/* int: bios-reported base mem (K) */
#define	CPU_BIOSEXTMEM		3	/* int: bios-reported ext. mem (K) */
#define	CPU_NKPDE		4	/* int: number of kernel PDEs */
#define	CPU_BOOTED_KERNEL	5	/* string: booted kernel name */
#define CPU_DISKINFO		6	/* disk geometry information */
#define CPU_FPU_PRESENT		7	/* FPU is present */
#define	CPU_MAXID		8	/* number of valid machdep ids */
d346 11
a356 6
	{ "biosbasemem", CTLTYPE_INT }, \
	{ "biosextmem", CTLTYPE_INT }, \
	{ "nkpde", CTLTYPE_INT }, \
	{ "booted_kernel", CTLTYPE_STRING }, \
	{ "diskinfo", CTLTYPE_STRUCT }, \
	{ "fpu_present", CTLTYPE_INT }, \
a357 28


/*
 * Structure for CPU_DISKINFO sysctl call.
 * XXX this should be somewhere else.
 */
#define MAX_BIOSDISKS	16

struct disklist {
	int dl_nbiosdisks;			   /* number of bios disks */
	struct biosdisk_info {
		int bi_dev;			   /* BIOS device # (0x80 ..) */
		int bi_cyl;			   /* cylinders on disk */
		int bi_head;			   /* heads per track */
		int bi_sec;			   /* sectors per track */
		u_int64_t bi_lbasecs;		   /* total sec. (iff ext13) */
#define BIFLAG_INVALID		0x01
#define BIFLAG_EXTINT13		0x02
		int bi_flags;
	} dl_biosdisks[MAX_BIOSDISKS];

	int dl_nnativedisks;			   /* number of native disks */
	struct nativedisk_info {
		char ni_devname[16];		   /* native device name */
		int ni_nmatches; 		   /* # of matches w/ BIOS */
		int ni_biosmatches[MAX_BIOSDISKS]; /* indices in dl_biosdisks */
	} dl_nativedisks[1];			   /* actually longer */
};
@


1.1
log
@an amd64 arch support.
hacked by art@@ from netbsd sources and then later debugged
by me into the shape where it can host itself.
no bootloader yet as needs redoing from the
recent advanced i386 sources (anyone? ;)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d95 1
@

