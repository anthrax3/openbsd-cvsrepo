head	1.41;
access;
symbols
	OPENBSD_6_1:1.41.0.12
	OPENBSD_6_1_BASE:1.41
	OPENBSD_6_0:1.41.0.10
	OPENBSD_6_0_BASE:1.41
	OPENBSD_5_9:1.41.0.6
	OPENBSD_5_9_BASE:1.41
	OPENBSD_5_8:1.41.0.8
	OPENBSD_5_8_BASE:1.41
	OPENBSD_5_7:1.41.0.2
	OPENBSD_5_7_BASE:1.41
	OPENBSD_5_6:1.41.0.4
	OPENBSD_5_6_BASE:1.41
	OPENBSD_5_5:1.40.0.4
	OPENBSD_5_5_BASE:1.40
	OPENBSD_5_4:1.39.0.4
	OPENBSD_5_4_BASE:1.39
	OPENBSD_5_3:1.39.0.2
	OPENBSD_5_3_BASE:1.39
	OPENBSD_5_2:1.37.0.8
	OPENBSD_5_2_BASE:1.37
	OPENBSD_5_1_BASE:1.37
	OPENBSD_5_1:1.37.0.6
	OPENBSD_5_0:1.37.0.4
	OPENBSD_5_0_BASE:1.37
	OPENBSD_4_9:1.37.0.2
	OPENBSD_4_9_BASE:1.37
	OPENBSD_4_8:1.35.0.2
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.29.0.4
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.27.0.2
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.25.0.2
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.18.0.2
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.10.0.2
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.5.0.2
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.4.0.2
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.3.0.4
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.2.0.6
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.4
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	OPENBSD_3_5:1.1.0.4
	OPENBSD_3_5_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.41
date	2014.03.26.14.41.41;	author mpi;	state Exp;
branches;
next	1.40;

1.40
date	2013.12.06.21.03.05;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2012.10.08.21.47.47;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2012.09.19.23.23.50;	author kettenis;	state Exp;
branches;
next	1.37;

1.37
date	2010.08.31.17.13.46;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2010.08.31.16.16.12;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2010.08.07.06.10.04;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2010.06.24.00.06.57;	author kettenis;	state Exp;
branches;
next	1.33;

1.33
date	2010.04.02.19.23.05;	author kettenis;	state Exp;
branches;
next	1.32;

1.32
date	2010.02.09.19.36.05;	author kettenis;	state Exp;
branches;
next	1.31;

1.31
date	2009.11.23.15.33.37;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2009.09.18.20.17.17;	author kettenis;	state Exp;
branches;
next	1.29;

1.29
date	2009.04.11.14.59.59;	author kettenis;	state Exp;
branches;
next	1.28;

1.28
date	2009.03.31.22.19.57;	author kettenis;	state Exp;
branches;
next	1.27;

1.27
date	2008.11.09.15.11.19;	author oga;	state Exp;
branches;
next	1.26;

1.26
date	2008.09.26.21.15.53;	author mikeb;	state Exp;
branches;
next	1.25;

1.25
date	2008.07.07.07.54.48;	author bernd;	state Exp;
branches;
next	1.24;

1.24
date	2008.06.26.05.42.09;	author ray;	state Exp;
branches;
next	1.23;

1.23
date	2008.06.25.18.54.06;	author oga;	state Exp;
branches;
next	1.22;

1.22
date	2008.06.05.09.45.14;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2008.04.28.06.17.47;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2008.03.23.08.36.41;	author damien;	state Exp;
branches;
next	1.19;

1.19
date	2008.03.16.19.00.28;	author oga;	state Exp;
branches;
next	1.18;

1.18
date	2008.01.04.00.23.26;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2007.12.18.22.48.14;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2007.11.27.15.40.56;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2007.11.26.19.52.09;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2007.11.26.15.35.17;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2007.11.26.10.35.42;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2007.11.25.17.11.12;	author oga;	state Exp;
branches;
next	1.11;

1.11
date	2007.11.16.15.31.19;	author mikeb;	state Exp;
branches;
next	1.10;

1.10
date	2007.07.04.21.30.48;	author ckuethe;	state Exp;
branches;
next	1.9;

1.9
date	2007.06.03.22.56.22;	author tedu;	state Exp;
branches;
next	1.8;

1.8
date	2007.06.01.01.00.45;	author tedu;	state Exp;
branches;
next	1.7;

1.7
date	2007.05.31.23.35.46;	author tedu;	state Exp;
branches;
next	1.6;

1.6
date	2007.05.19.19.32.03;	author tedu;	state Exp;
branches;
next	1.5;

1.5
date	2007.01.15.23.19.05;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.13.20.10.49;	author brad;	state Exp;
branches;
next	1.3;

1.3
date	2006.02.12.23.46.27;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.14.00.32.30;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.28.01.39.39;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.41
log
@No need to include <sys/lock.h> when only <sys/rwlock.h> is needed,
so remove the former and include the latter instead of pulling it
in <dev/pci/agpvar.h>.  This header already requires various other
types anyway.  While here remove unneeded headers.
@
text
@/*	$OpenBSD: pchb.c,v 1.40 2013/12/06 21:03:05 deraadt Exp $	*/
/*	$NetBSD: pchb.c,v 1.1 2003/04/26 18:39:50 fvdl Exp $	*/
/*
 * Copyright (c) 2000 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
/*-
 * Copyright (c) 1996, 1998, 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/timeout.h>
#include <sys/rwlock.h>

#include <machine/bus.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>

#include <dev/pci/agpvar.h>
#include <dev/pci/ppbreg.h>

#include <dev/rndvar.h>

#include <dev/ic/i82802reg.h>

#include "agp.h"

/* XXX should be in dev/ic/i82424{reg.var}.h */
#define I82424_CPU_BCTL_REG		0x53
#define I82424_PCI_BCTL_REG		0x54

#define I82424_BCTL_CPUMEM_POSTEN	0x01
#define I82424_BCTL_CPUPCI_POSTEN	0x02
#define I82424_BCTL_PCIMEM_BURSTEN	0x01
#define I82424_BCTL_PCI_BURSTEN		0x02

/* XXX should be in dev/ic/amd64htreg.h */
#define AMD64HT_LDT0_BUS	0x94
#define AMD64HT_LDT0_TYPE	0x98
#define AMD64HT_LDT1_BUS	0xb4
#define AMD64HT_LDT1_TYPE	0xb8
#define AMD64HT_LDT2_BUS	0xd4
#define AMD64HT_LDT2_TYPE	0xd8
#define AMD64HT_LDT3_BUS	0xf4
#define AMD64HT_LDT3_TYPE	0xf8

#define AMD64HT_NUM_LDT		4

#define AMD64HT_LDT_TYPE_MASK		0x0000001f
#define  AMD64HT_LDT_INIT_COMPLETE	0x00000002
#define  AMD64HT_LDT_NC			0x00000004

#define AMD64HT_LDT_SEC_BUS_NUM(reg)	(((reg) >> 8) & 0xff)

struct pchb_softc {
	struct device sc_dev;

	bus_space_tag_t sc_bt;
	bus_space_handle_t sc_bh;

	/* rng stuff */
	int sc_rng_active;
	int sc_rng_ax;
	int sc_rng_i;
	struct timeout sc_rng_to;
};

int	pchbmatch(struct device *, void *, void *);
void	pchbattach(struct device *, struct device *, void *);
int	pchbactivate(struct device *, int);

struct cfattach pchb_ca = {
	sizeof(struct pchb_softc), pchbmatch, pchbattach, NULL,
	pchbactivate
};

struct cfdriver pchb_cd = {
	NULL, "pchb", DV_DULL
};

int	pchb_print(void *, const char *);
void	pchb_rnd(void *);
void	pchb_amd64ht_attach(struct device *, struct pci_attach_args *, int);

int
pchbmatch(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = aux;

	if (PCI_CLASS(pa->pa_class) == PCI_CLASS_BRIDGE &&
	    PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_BRIDGE_HOST)
		return (1);

	return (0);
}

void
pchbattach(struct device *parent, struct device *self, void *aux)
{
	struct pchb_softc *sc = (struct pchb_softc *)self;
	struct pci_attach_args *pa = aux;
	struct pcibus_attach_args pba;
	pcireg_t bcreg, bir;
	u_char pbnum;
	pcitag_t tag;
	int i, r;
	int doattach = 0;

	switch (PCI_VENDOR(pa->pa_id)) {
	case PCI_VENDOR_AMD:
		printf("\n");
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_AMD_AMD64_0F_HT:
		case PCI_PRODUCT_AMD_AMD64_10_HT:
			for (i = 0; i < AMD64HT_NUM_LDT; i++)
				pchb_amd64ht_attach(self, pa, i);
			break;
		}
		break;
	case PCI_VENDOR_INTEL:
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_INTEL_82915G_HB:
		case PCI_PRODUCT_INTEL_82945G_HB:
		case PCI_PRODUCT_INTEL_82925X_HB:
		case PCI_PRODUCT_INTEL_82955X_HB:
			sc->sc_bt = pa->pa_memt;
			if (bus_space_map(sc->sc_bt, I82802_IOBASE,
			    I82802_IOSIZE, 0, &sc->sc_bh))
				break;

			/* probe and init rng */
			if (!(bus_space_read_1(sc->sc_bt, sc->sc_bh,
			    I82802_RNG_HWST) & I82802_RNG_HWST_PRESENT))
				break;

			/* enable RNG */
			bus_space_write_1(sc->sc_bt, sc->sc_bh,
			    I82802_RNG_HWST,
			    bus_space_read_1(sc->sc_bt, sc->sc_bh,
			    I82802_RNG_HWST) | I82802_RNG_HWST_ENABLE);

			/* see if we can read anything */
			for (i = 1000; i-- &&
			    !(bus_space_read_1(sc->sc_bt, sc->sc_bh,
			    I82802_RNG_RNGST) & I82802_RNG_RNGST_DATAV); )
				DELAY(10);

			if (!(bus_space_read_1(sc->sc_bt, sc->sc_bh,
			    I82802_RNG_RNGST) & I82802_RNG_RNGST_DATAV))
				break;

			r = bus_space_read_1(sc->sc_bt, sc->sc_bh,
			    I82802_RNG_DATA);

			timeout_set(&sc->sc_rng_to, pchb_rnd, sc);
			sc->sc_rng_i = 4;
			pchb_rnd(sc);
			sc->sc_rng_active = 1;
			break;
		}
		printf("\n");
		break;
	case PCI_VENDOR_VIATECH:
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_VIATECH_VT8251_PCIE_0:
			/*
			 * Bump the host bridge into PCI-PCI bridge
			 * mode by clearing magic bit on the VLINK
			 * device.  This allows us to read the bus
			 * number for the PCI bus attached to this
			 * host bridge.
			 */
			tag = pci_make_tag(pa->pa_pc, 0, 17, 7);
			bcreg = pci_conf_read(pa->pa_pc, tag, 0xfc);
			bcreg &= ~0x00000004; /* XXX Magic */
			pci_conf_write(pa->pa_pc, tag, 0xfc, bcreg);

			bir = pci_conf_read(pa->pa_pc,
			    pa->pa_tag, PPB_REG_BUSINFO);
			pbnum = PPB_BUSINFO_PRIMARY(bir);
			if (pbnum > 0)
				doattach = 1;

			/* Switch back to host bridge mode. */
			bcreg |= 0x00000004; /* XXX Magic */
			pci_conf_write(pa->pa_pc, tag, 0xfc, bcreg);
			break;
		}
		printf("\n");
		break;
	default:
		printf("\n");
		break;
	}

#if NAGP > 0
	/*
	 * Intel IGD have an odd interface and attach at vga, however,
	 * in that mode they don't have the AGP cap bit, so this
	 * test should be sufficient
	 */
	if (pci_get_capability(pa->pa_pc, pa->pa_tag, PCI_CAP_AGP,
	    NULL, NULL) != 0) {
		struct agp_attach_args	aa;
		aa.aa_busname = "agp";
		aa.aa_pa = pa;

		config_found(self, &aa, agpdev_print);
	}
#endif /* NAGP > 0 */

	if (doattach == 0)
		return;

	bzero(&pba, sizeof(pba));
	pba.pba_busname = "pci";
	pba.pba_iot = pa->pa_iot;
	pba.pba_memt = pa->pa_memt;
	pba.pba_dmat = pa->pa_dmat;
	pba.pba_busex = pa->pa_busex;
	pba.pba_domain = pa->pa_domain;
	pba.pba_bus = pbnum;
	pba.pba_pc = pa->pa_pc;
	config_found(self, &pba, pchb_print);
}

int
pchbactivate(struct device *self, int act)
{
	struct pchb_softc *sc = (struct pchb_softc *)self;
	int rv = 0;

	switch (act) {
	case DVACT_RESUME:
		/* re-enable RNG, if we have it */
		if (sc->sc_rng_active)
			bus_space_write_1(sc->sc_bt, sc->sc_bh,
			    I82802_RNG_HWST,
			    bus_space_read_1(sc->sc_bt, sc->sc_bh,
			    I82802_RNG_HWST) | I82802_RNG_HWST_ENABLE);
		rv = config_activate_children(self, act);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}

int
pchb_print(void *aux, const char *pnp)
{
	struct pcibus_attach_args *pba = aux;

	if (pnp)
		printf("%s at %s", pba->pba_busname, pnp);
	printf(" bus %d", pba->pba_bus);
	return (UNCONF);
}

/*
 * Should do FIPS testing as per:
 *	http://csrc.nist.gov/publications/fips/fips140-1/fips1401.pdf
 */
void
pchb_rnd(void *v)
{
	struct pchb_softc *sc = v;

	/*
	 * Don't wait for data to be ready. If it's not there, we'll check
	 * next time.
	 */
	if ((bus_space_read_1(sc->sc_bt, sc->sc_bh, I82802_RNG_RNGST) &
	    I82802_RNG_RNGST_DATAV)) {

		sc->sc_rng_ax = (sc->sc_rng_ax << 8) |
		    bus_space_read_1(sc->sc_bt, sc->sc_bh, I82802_RNG_DATA);

		if (!sc->sc_rng_i--) {
			sc->sc_rng_i = 4;
			add_true_randomness(sc->sc_rng_ax);
		}
	}

	timeout_add(&sc->sc_rng_to, 1);
}

void
pchb_amd64ht_attach(struct device *self, struct pci_attach_args *pa, int i)
{
	struct pcibus_attach_args pba;
	pcireg_t type, bus;
	int reg;

	reg = AMD64HT_LDT0_TYPE + i * 0x20;
	type = pci_conf_read(pa->pa_pc, pa->pa_tag, reg);
	if ((type & AMD64HT_LDT_INIT_COMPLETE) == 0 ||
	    (type & AMD64HT_LDT_NC) == 0)
		return;

	reg = AMD64HT_LDT0_BUS + i * 0x20;
	bus = pci_conf_read(pa->pa_pc, pa->pa_tag, reg);
	if (AMD64HT_LDT_SEC_BUS_NUM(bus) > 0) {
		bzero(&pba, sizeof(pba));
		pba.pba_busname = "pci";
		pba.pba_iot = pa->pa_iot;
		pba.pba_memt = pa->pa_memt;
		pba.pba_dmat = pa->pa_dmat;
		pba.pba_busex = pa->pa_busex;
		pba.pba_domain = pa->pa_domain;
		pba.pba_bus = AMD64HT_LDT_SEC_BUS_NUM(bus);
		pba.pba_pc = pa->pa_pc;
		config_found(self, &pba, pchb_print);
	}
}
@


1.40
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.39 2012/10/08 21:47:47 deraadt Exp $	*/
d61 1
@


1.39
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.38 2012/09/19 23:23:50 kettenis Exp $	*/
a282 9
	case DVACT_QUIESCE:
		rv = config_activate_children(self, act);
		break;
	case DVACT_SUSPEND:
		rv = config_activate_children(self, act);
		break;
	case DVACT_POWERDOWN:
		rv = config_activate_children(self, act);
		break;
d290 3
@


1.38
log
@Set up PCI bus number resource accounting for the main PCI bus hierarchy.
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.37 2010/08/31 17:13:46 deraadt Exp $	*/
d287 3
@


1.37
log
@Add DVACT_QUIECE support.  This is called before splhigh() and before
DVACT_SUSPEND, therefore DVACT_QUIECE can do standard sleeping operations
to get ready.
Discussed quite a while back with kettenis and jakemsr, oga suddenly needed
it as well and wrote half of it, so it was time to finish it.
proofread by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.36 2010/08/31 16:16:12 deraadt Exp $	*/
d269 1
d362 1
@


1.36
log
@pchbactivate should return result of config_activate_children
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.35 2010/08/07 06:10:04 deraadt Exp $	*/
d282 3
@


1.35
log
@On resume, re-activate the host RNG on the host bridges that need it.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.34 2010/06/24 00:06:57 kettenis Exp $	*/
d279 1
d283 1
a283 1
		config_activate_children(self, act);
d292 1
a292 1
		config_activate_children(self, act);
d295 1
a295 1
	return (0);
a296 1

@


1.34
log
@The new AMD Opteron CPUs have up to 4 HyperTransport links instead of 3.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.33 2010/04/02 19:23:05 kettenis Exp $	*/
d111 1
d119 1
d123 1
a123 1
	config_activate_children
d207 1
d274 23
@


1.33
log
@For the VT8251 host bridge, only attach the pci bus is non-zero, otherwise
keep attaching bus 0 forever.

tested by mk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.32 2010/02/09 19:36:05 kettenis Exp $	*/
d93 2
d96 1
a96 1
#define AMD64HT_NUM_LDT		3
@


1.32
log
@Switching the strange VIA VT8251 PCIE host bridge into a PCI-PCI bridge
didn't quite work since the bridge seems to end up largely unconfigured, and
our PCI resource configuration code isn't quite smart enough (yet) to fix
things up.  So instead switch it only into PCI-PCI bridge mode long enough to
snoop the bus number, and attach pci(4) using that number.

This is probably safer anyway, since ACPI may not like us switching things
around behind its back.  Fixes PR 6253 & 6304.
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.31 2009/11/23 15:33:37 deraadt Exp $	*/
d225 2
a226 1
			doattach = 1;
@


1.31
log
@pchb must walk children too
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.30 2009/09/18 20:17:17 kettenis Exp $	*/
d69 1
d147 4
a150 1
	pcireg_t bcreg;
d152 1
d209 1
a209 1
		case PCI_PRODUCT_VIATECH_VT8251_VLINK:
d211 5
a215 5
			 * For some strange reason, the VIA VT8251
			 * chipset can be configured to its PCIe
			 * bridge show up as a host bridge.  We whack
			 * it into PCI bridge mode here such that we
			 * can see the devices behind it.
d217 2
a218 1
			bcreg = pci_conf_read(pa->pa_pc, pa->pa_tag, 0xfc);
d220 10
a229 1
			pci_conf_write(pa->pa_pc, pa->pa_tag, 0xfc, bcreg);
d241 1
a241 1
	 * Intel IGD have an odd interface and attach at vga, however
d254 13
@


1.30
log
@For some dark reason there's a bit on the VLINK device of this chipset
that makes the PCIE device show up as a host bridge instead of a
PCI-PCI bridge.  As a result any devices sitting behind it won't be
detected.  Whack the device into PCI-PCI mode such that we can walk the
PCI bus hierarchy the normal way and detect all devices.  Fixes PR 6215.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.29 2009/04/11 14:59:59 kettenis Exp $	*/
d117 2
a118 1
	sizeof(struct pchb_softc), pchbmatch, pchbattach
@


1.29
log
@There is no support for building multi-socket machines in AMD Family 11h
processors, so the registers to configure addition HyperTransport links
are absent.  Don't try attaching addition pci busses on these processors
to avoid probing non-existant registers.
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.28 2009/03/31 22:19:57 kettenis Exp $	*/
d145 1
d197 17
@


1.28
log
@bzero pci attach args
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.27 2008/11/09 15:11:19 oga Exp $	*/
a152 1
		case PCI_PRODUCT_AMD_AMD64_11_HT:
@


1.27
log
@Rework that way that agp attaches.

previously, we had a static list of pcidevs and which agp driver would
be interanlly attached. Instead, split the agp drivers so they work like
audio(4), where we attach a driver, which sets up some callbacks and
initial state, then attaches the interface (agp(4)). Since this allows
us to attach different drivers in different places, and give them
/proper/ probe functions move most of the drivers back to attaching at
pchb, where they should, and intagp (formerly agp_i810) stays attaching
at vga, since it's part of the intel integrated graphics chips.

Diff shrinks the kernel slightly, gets rid of the annoying "no integrated
graphics" warning, and allows more cleanup later.

Tested by many. fix for alpha build (the only other vga_pci.c consumer)
suggested by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.26 2008/09/26 21:15:53 mikeb Exp $	*/
d278 1
a284 1
		pba.pba_bridgetag = NULL;
@


1.26
log
@Attach agp(4) to the Intel Q35 integrated video.
Tested on ASUS P5E-VM DO motherboard.

ok oga
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.25 2008/07/07 07:54:48 bernd Exp $	*/
d145 1
a145 1
	int has_agp = 0, i, r;
a160 24

		/*
		 * As for Intel AGP, the host bridge is either in GFX mode
		 * (internal graphics) or in AGP mode. In GFX mode, we pretend
		 * to have AGP because the graphics memory access is very
		 * similar and the AGP GATT code will deal with this. In the
		 * latter case, the pci_get_capability(PCI_CAP_AGP) test below
		 * will fire, so we do no harm by already setting the flag.
		 */

		/* AGP only */
		case PCI_PRODUCT_INTEL_82915GM_HB:
		case PCI_PRODUCT_INTEL_82945GM_HB:
		case PCI_PRODUCT_INTEL_82945GME_HB:
		case PCI_PRODUCT_INTEL_82G965_HB:
		case PCI_PRODUCT_INTEL_82Q965_HB:
		case PCI_PRODUCT_INTEL_82GM965_HB:
		case PCI_PRODUCT_INTEL_82G33_HB:
		case PCI_PRODUCT_INTEL_82G35_HB:
		case PCI_PRODUCT_INTEL_82Q35_HB:
			has_agp = 1;
			break;

		/* AGP + RNG */
a162 3
			has_agp = 1;
			/* FALLTHROUGH */

d208 3
a210 2
	 * If we haven't detected AGP yet (via a product ID),
	 * then check for AGP capability on the device.
d212 1
a212 2
	if (has_agp ||
	    pci_get_capability(pa->pa_pc, pa->pa_tag, PCI_CAP_AGP,
d214 5
a218 1
		agp_set_pchb(pa);
d220 1
a220 1
#endif
@


1.25
log
@Add AGP and hostbridge support for the Intel 82945GME chipset.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.24 2008/06/26 05:42:09 ray Exp $	*/
d180 1
@


1.24
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.23 2008/06/25 18:54:06 oga Exp $	*/
d174 1
@


1.23
log
@Support the Intel G35 which apparently works similarly to the 965.

Initial information, half the diff, and testing from Andrew Lutomirski,
thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.22 2008/06/05 09:45:14 brad Exp $	*/
a42 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.22
log
@Allow pchb(4) to find additional non-coherent HyperTransport links
with 10h and 11h families of AMD CPU's.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.21 2008/04/28 06:17:47 brad Exp $	*/
d185 1
@


1.21
log
@Sync PCI ids.
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.20 2008/03/23 08:36:41 damien Exp $	*/
d159 2
@


1.20
log
@Add AGP support for the Intel G33 chipset.
Tested on i386 with a Gigabyte G33M-DS2R motherboard (Intel GMA 3100).
Based on NetBSD code.

ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.19 2008/03/16 19:00:28 oga Exp $	*/
d158 1
a158 1
		case PCI_PRODUCT_AMD_AMD64_HT:
@


1.19
log
@Make agp(4) attach at vga(4) instead of pchb(4). This is because sometimes
agp and drm need to use the same memory mapping, the best way to deal
with that is to allow them to share (that's coming later), for this to
work cleanly we move the attach point of agp.

Ideally most agp drivers would attach at pchb, with only agp_i810
(and any that work similarly) attaching at vga, but this will do for
now.

ok kettenis@@, miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.18 2008/01/04 00:23:26 kettenis Exp $	*/
d182 1
@


1.18
log
@Clean up Intel host bridge PCI IDs.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.17 2007/12/18 22:48:14 deraadt Exp $	*/
d81 2
a131 1
int	agpbus_print(void *, const char *);
a151 1
	struct agpbus_attach_args apa;
d234 1
d242 1
a242 3
		apa.apa_busname = "agp";
		apa.apa_pci_args = *pa;
		config_found(self, &apa, agpbus_print);
d244 1
a254 8
	return (UNCONF);
}

int
agpbus_print(void *vaa, const char *pnp)
{
	if (pnp)
		printf("agp at %s", pnp);
@


1.17
log
@pass pci domain to the child too, ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.16 2007/11/27 15:40:56 deraadt Exp $	*/
d178 4
a181 4
		case PCI_PRODUCT_INTEL_82945GM_MCH:
		case PCI_PRODUCT_INTEL_82965GM_MCH:
		case PCI_PRODUCT_INTEL_82965_MCH:
		case PCI_PRODUCT_INTEL_82Q963_HB:
d187 1
a187 1
		case PCI_PRODUCT_INTEL_82945GP_MCH:
@


1.16
log
@Unify amd64 and i386 code further; ok oga kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.15 2007/11/26 19:52:09 deraadt Exp $	*/
d314 1
@


1.15
log
@First step towards unifying pchb between i386 and amd64
Light testing, mostly mechanical
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.14 2007/11/26 15:35:17 deraadt Exp $	*/
a80 11
#define PCISET_BRIDGETYPE_MASK	0x3
#define PCISET_TYPE_COMPAT	0x1
#define PCISET_TYPE_AUX		0x2

#define PCISET_BUSCONFIG_REG	0x48
#define PCISET_BRIDGE_NUMBER(reg)	(((reg) >> 8) & 0xff)
#define PCISET_PCI_BUS_NUMBER(reg)	(((reg) >> 16) & 0xff)

/* XXX should be in dev/ic/i82443reg.h */
#define	I82443BX_SDRAMC_REG	0x76

a154 25
	case PCI_VENDOR_INTEL:
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_INTEL_82915G_HB:
		case PCI_PRODUCT_INTEL_82915GM_HB:
		case PCI_PRODUCT_INTEL_82945GP_MCH:
		case PCI_PRODUCT_INTEL_82945GM_MCH:
		case PCI_PRODUCT_INTEL_82Q963_HB:
		case PCI_PRODUCT_INTEL_82965_MCH:
		case PCI_PRODUCT_INTEL_82965GM_MCH:
			/*
			 * The host bridge is either in GFX mode (internal
			 * graphics) or in AGP mode. In GFX mode, we pretend
			 * to have AGP because the graphics memory access
			 * is very similar and the AGP GATT code will
			 * deal with this. In the latter case, the
			 * pci_get_capability(PCI_CAP_AGP) test below will
			 * fire, so we do no harm by already setting the flag.
			 */
			has_agp = 1;
			break;
		}
		break;
	}

	switch (PCI_VENDOR(pa->pa_id)) {
a164 1
		printf("\n");
d166 20
d187 4
a191 1
		case PCI_PRODUCT_INTEL_82945GP_MCH:
d227 4
@


1.14
log
@correct newlines surrounding the sub-bus configuration, and unify
pchb's further
ok reyk oga
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.13 2007/11/26 10:35:42 reyk Exp $	*/
a63 1
#include <sys/types.h>
d123 4
a126 3
	int sc_rnd_i;
	u_int32_t sc_rnd_ax;
	struct timeout sc_rnd_to;
a131 5
int	pchb_print(void *, const char *);
int	agpbus_print(void *, const char *);
void	pchb_rnd(void *);
void	pchb_amd64ht_attach (struct device *, struct pci_attach_args *, int);

d133 1
a133 1
	sizeof(struct pchb_softc), pchbmatch, pchbattach,
d140 5
d151 1
a151 1
	    PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_BRIDGE_HOST) {
a152 1
	}
d163 1
a163 3
	int has_agp, i, r;

	has_agp = 0;
d209 1
a209 1
			    I82802_IOSIZE, 0, &sc->sc_bh)) {
a210 1
			}
d214 1
a214 1
			    I82802_RNG_HWST) & I82802_RNG_HWST_PRESENT)) {
a215 1
			}
d225 2
a226 2
			    !(bus_space_read_1(sc->sc_bt,sc->sc_bh,
			    I82802_RNG_RNGST) & I82802_RNG_RNGST_DATAV);)
d230 1
a230 1
			    I82802_RNG_RNGST) & I82802_RNG_RNGST_DATAV)) {
a231 1
			}
d236 2
a237 2
			timeout_set(&sc->sc_rnd_to, pchb_rnd, sc);
			sc->sc_rnd_i = 4;
d250 1
a250 1
			       NULL, NULL) != 0) {
d276 28
a328 28
}

/*
 * Should do FIPS testing as per:
 *	http://csrc.nist.gov/publications/fips/fips140-1/fips1401.pdf
 */
void
pchb_rnd(void *v)
{
	struct pchb_softc *sc = v;

	/*
	 * Don't wait for data to be ready. If it's not there, we'll check
	 * next time.
	 */
	if ((bus_space_read_1(sc->sc_bt, sc->sc_bh, I82802_RNG_RNGST) &
	    I82802_RNG_RNGST_DATAV)) {

		sc->sc_rnd_ax = (sc->sc_rnd_ax << 8) |
		    bus_space_read_1(sc->sc_bt, sc->sc_bh, I82802_RNG_DATA);

		if (!sc->sc_rnd_i--) {
			sc->sc_rnd_i = 4;
			add_true_randomness(sc->sc_rnd_ax);
		}
	}

	timeout_add(&sc->sc_rnd_to, 1);
@


1.13
log
@fix new agp code on amd64
- internal intel graphics semi-agp chipsets need special handling in pchb.c
- re-add the i965GM device
- use the correct major device id for /dev/agp0 on amd64 (not the i386 one)

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.12 2007/11/25 17:11:12 oga Exp $	*/
d195 1
d204 1
a248 1
	printf("\n");
a256 1
		printf("\n");
a259 1
		printf("\n");
@


1.12
log
@Make agp attach as a device. This means that many more agp bridges
actually get detected and attached. Also adds a kernel api for
manipulating agp.

Enable this on i386 and amd64.

"I think you should commit it" deraadt@@, ok matthieu. Looked over by
several others.
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.11 2007/11/16 15:31:19 mikeb Exp $	*/
d167 25
@


1.11
log
@Remove microtime calls and RNG benchmarking from the pchb attachment
code.  This is due to the fact that we do timecounter initialization
after autoconf(9).

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.10 2007/07/04 21:30:48 ckuethe Exp $	*/
d76 2
d133 1
d163 4
a166 1
	int i, r;
a177 3
#ifdef PCIAGP
		pciagp_set_pchb(pa);
#endif
d223 14
d247 8
@


1.10
log
@fix dmesg formatting error when hardware random number generator is present
"Yes" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.9 2007/06/03 22:56:22 tedu Exp $	*/
a159 1
	struct timeval tv1, tv2;
a210 19

			/* benchmark the RNG */
			microtime(&tv1);
			for (i = 8 * 1024; i--; ) {
				while(!(bus_space_read_1(sc->sc_bt, sc->sc_bh,
				    I82802_RNG_RNGST) & I82802_RNG_RNGST_DATAV))
					;
				r = bus_space_read_1(sc->sc_bt, sc->sc_bh,
				    I82802_RNG_DATA);
			}
			microtime(&tv2);

			timersub(&tv2, &tv1, &tv1);
			if (tv1.tv_sec)
				tv1.tv_usec += 1000000 * tv1.tv_sec;
			printf(": rng active");
			if (tv1.tv_usec != 0)
				printf(", %dKb/sec",
				    8 * 1000000 / tv1.tv_usec);
@


1.9
log
@if the 915gm didn't work on i386, it's worrisome here too. remove it.
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.8 2007/06/01 01:00:45 tedu Exp $	*/
a162 2
	printf("\n");

d239 1
@


1.8
log
@never attempt to tweak a file just before commit
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.7 2007/05/31 23:35:46 tedu Exp $	*/
a179 1
		case PCI_PRODUCT_INTEL_82915GM_HB:
@


1.7
log
@intel pchb rnd support, from i386
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.6 2007/05/19 19:32:03 tedu Exp $	*/
d205 1
a205 1
			    I82802_RNG_RNGST) & I82802_RNG_RNGST_DATAV));
@


1.6
log
@(disabled) option for PCIAGP.  at least lets i945 chipsets work
ok dim
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.5 2007/01/15 23:19:05 jsg Exp $	*/
d3 25
a27 1

d68 1
d74 1
d76 1
a76 1
#include <dev/pci/pcidevs.h>
d78 1
a78 1
#include <arch/amd64/pci/pchbvar.h>
d116 11
d131 1
d158 1
d160 2
a161 1
	int i;
d178 62
d256 1
a256 1
pchb_amd64ht_attach (struct device *self, struct pci_attach_args *pa, int i)
d280 28
@


1.5
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.4 2006/03/13 20:10:49 brad Exp $	*/
d133 6
@


1.4
log
@* Add "pcitag_t *pba_bridgetag" to pci_attach_args.  This is set to
  NULL for root PCI busses.  For busses behind a bridge, it points to
  a persistent copy of the bridge's pcitag_t.  This can be very useful
  for machine-dependent PCI bus enumeration code.

From NetBSD

ok grange@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.3 2006/02/12 23:46:27 kettenis Exp $	*/
d105 1
a105 3
pchbmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d118 1
a118 3
pchbattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d137 1
a137 3
pchb_print(aux, pnp)
	void *aux;
	const char *pnp;
@


1.3
log
@Find additional noncoherent HyperTransport links by looking at the
HyperTransport configuration on AMD Athlon 64 & Opteron CPU's.  This makes us
detect the missing PCI busses on various Opteron systems.
ok brad@@, marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.2 2004/06/14 00:32:30 deraadt Exp $	*/
d174 1
@


1.2
log
@de-__P
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.1 2004/01/28 01:39:39 mickey Exp $	*/
d74 16
d94 1
d125 1
d130 5
a134 2
		/* Nothing yet */
		default:
d136 1
a137 1

d151 26
@


1.1
log
@an amd64 arch support.
hacked by art@@ from netbsd sources and then later debugged
by me into the shape where it can host itself.
no bootloader yet as needs redoing from the
recent advanced i386 sources (anyone? ;)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d74 2
a75 2
int	pchbmatch __P((struct device *, void *, void *));
void	pchbattach __P((struct device *, struct device *, void *));
d77 1
a77 1
int	pchb_print __P((void *, const char *));
@

