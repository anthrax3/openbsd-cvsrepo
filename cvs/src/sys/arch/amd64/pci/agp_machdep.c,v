head	1.14;
access;
symbols
	OPENBSD_6_2:1.14.0.8
	OPENBSD_6_2_BASE:1.14
	OPENBSD_6_1:1.14.0.10
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.6
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.4
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.12
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.10
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.8
	OPENBSD_5_0:1.6.0.6
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.4
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.2
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.4
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.6
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.4
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.2
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2;
locks; strict;
comment	@ * @;


1.14
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.13;
commitid	p4LJxGKbi0BU2cG6;

1.13
date	2014.09.20.16.15.16;	author kettenis;	state Exp;
branches;
next	1.12;
commitid	6wfZPYqhJIzN4SFE;

1.12
date	2014.07.12.18.44.41;	author tedu;	state Exp;
branches;
next	1.11;
commitid	uKVPYMN2MLxdZxzH;

1.11
date	2014.04.01.09.05.03;	author mpi;	state Exp;
branches;
next	1.10;

1.10
date	2014.03.26.14.41.41;	author mpi;	state Exp;
branches;
next	1.9;

1.9
date	2013.12.09.19.52.11;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2013.12.07.10.57.06;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2013.03.17.21.49.00;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2010.05.10.22.06.04;	author oga;	state Exp;
branches;
next	1.5;

1.5
date	2010.04.08.01.26.44;	author oga;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.06.06.02.44;	author oga;	state Exp;
branches;
next	1.3;

1.3
date	2007.11.25.17.11.12;	author oga;	state Exp;
branches;
next	1.2;

1.2
date	2007.08.04.19.40.25;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2007.05.29.22.27.14;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@/*	$OpenBSD: agp_machdep.c,v 1.13 2014/09/20 16:15:16 kettenis Exp $	*/

/*
 * Copyright (c) 2008 - 2009 Owain G. Ainsworth <oga@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * Copyright (c) 2002 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/rwlock.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>

#include <uvm/uvm_extern.h>

#include <machine/cpufunc.h>
#include <machine/bus.h>
#include <machine/pmap.h>

void
agp_flush_cache(void)
{
	wbinvd();
}

void
agp_flush_cache_range(vaddr_t va, vsize_t sz)
{
	pmap_flush_cache(va, sz);
}

struct agp_map {
	bus_space_tag_t		bst;
	bus_space_handle_t	bsh;
	bus_size_t		size;
};

int
agp_init_map(bus_space_tag_t tag, bus_addr_t address, bus_size_t size,
    int flags, struct agp_map **mapp)
{
	struct agp_map	*map;
	int		 err;

	map = malloc(sizeof(*map), M_AGP, M_WAITOK | M_CANFAIL);
	if (map == NULL)
		return (ENOMEM);

	map->bst = tag;
	map->size = size;
	
	if ((err = bus_space_map(tag, address, size, flags, &map->bsh)) != 0) {
		free(map, M_AGP, sizeof(*map));
		return (err);
	}
	*mapp = map;
	return (0);
}

void
agp_destroy_map(struct agp_map *map)
{
	bus_space_unmap(map->bst, map->bsh, map->size);
	free(map, M_AGP, sizeof(*map));
}


int
agp_map_subregion(struct agp_map *map, bus_size_t offset, bus_size_t size,
    bus_space_handle_t *bshp)
{
	return (bus_space_subregion(map->bst, map->bsh, offset, size, bshp));
}

void
agp_unmap_subregion(struct agp_map *map, bus_space_handle_t bsh,
    bus_size_t size)
{
	/* subregion doesn't need unmapping, do nothing */
}

void
agp_map_atomic(struct agp_map *map, bus_size_t offset,
    bus_space_handle_t *bshp)
{
	agp_map_subregion(map, offset, PAGE_SIZE, bshp);
}

void
agp_unmap_atomic(struct agp_map *map, bus_space_handle_t bsh)
{
	/* subregion doesn't need unmapping, do nothing */
}
@


1.13
log
@On i386, agp_map_subregion might sleep, which is not allowed in some of
the inteldrm code.  Fix this by adding new interfaces that can map a single
page without sleeping and use that in the execbuffer fast path that needs
this "atomic" behaviour.  Should fix the panic I've seen under memory pressure
on i386.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_machdep.c,v 1.12 2014/07/12 18:44:41 tedu Exp $	*/
a51 1
#include <dev/pci/agpvar.h>
@


1.12
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_machdep.c,v 1.11 2014/04/01 09:05:03 mpi Exp $	*/
d93 1
a93 1
		free(map, M_AGP, 0);
d104 1
a104 1
	free(map, M_AGP, 0);
a111 2
	if (offset > map->size || size > map->size || offset + size > map->size)
		return (EINVAL);
a112 1
	
d118 13
@


1.11
log
@More <uvm/uvm.h> -> <uvm/uvm_extern.h> cleaning.

ok kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_machdep.c,v 1.10 2014/03/26 14:41:41 mpi Exp $	*/
d93 1
a93 1
		free(map, M_AGP);
d104 1
a104 1
	free(map, M_AGP);
@


1.10
log
@No need to include <sys/lock.h> when only <sys/rwlock.h> is needed,
so remove the former and include the latter instead of pulling it
in <dev/pci/agpvar.h>.  This header already requires various other
types anyway.  While here remove unneeded headers.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_machdep.c,v 1.9 2013/12/09 19:52:11 kettenis Exp $	*/
d54 2
d58 1
a58 2

#include <uvm/uvm.h>
@


1.9
log
@Remove MD intagp(4) code that is unused now that inteldrm(4) manages the GTT
all by itself.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_machdep.c,v 1.8 2013/12/07 10:57:06 kettenis Exp $	*/
a45 1
#include <sys/device.h>
d47 1
@


1.8
log
@Remove the agp-specific bus_dma code.  It is no longer used now that
inteldrm(4) manages the GTT by itself.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_machdep.c,v 1.7 2013/03/17 21:49:00 kettenis Exp $	*/
a58 9
#include "intagp.h"

/* bus_dma functions */

#if NINTAGP > 0
void	intagp_dma_sync(bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
	    bus_size_t, int);
#endif

a122 119

/*
 * ick ick ick. However, the rest of this driver is supposedly MI (though
 * they only exist on x86), so this can't be in dev/pci.
 */

#if NINTAGP > 0

/*
 * bus_dmamap_sync routine for intagp.
 *
 * This is tailored to the usage that drm with the GEM memory manager
 * will be using, since intagp is for intel IGD, and thus shouldn't be
 * used for anything other than gpu-based work. Essentially for the intel GEM
 * driver we use bus_dma as an abstraction to convert our memory into a gtt
 * address and deal with any cache incoherencies that we create.
 *
 * We use the cflush instruction to deal with clearing the caches, since our
 * cache is physically indexed, we can even map then clear the page and it'll
 * work. on i386 we need to check for the presence of cflush() in cpuid,
 * however, all cpus that have a new enough intel GMCH should be suitable.
 */
void	
intagp_dma_sync(bus_dma_tag_t tag, bus_dmamap_t dmam,
    bus_addr_t offset, bus_size_t size, int ops)
{
	bus_dma_segment_t	*segp;
	struct sg_page_map	*spm;
	void			*addr;
	paddr_t	 		 pa;
	bus_addr_t		 poff, endoff, soff;

#ifdef DIAGNOSTIC
	if ((ops & (BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE)) != 0 &&
	    (ops & (BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE)) != 0)
		panic("agp_dmamap_sync: mix PRE and POST");
	if (offset >= dmam->dm_mapsize)
		panic("_intagp_dma_sync: bad offset %lu (size = %lu)",
		    offset, dmam->dm_mapsize);
	if (size == 0 || (offset + size) > dmam->dm_mapsize)
		panic("intagp_dma_sync: bad length");
#endif /* DIAGNOSTIC */
	
	/* Coherent mappings need no sync. */
	if (dmam->_dm_flags & BUS_DMA_COHERENT)
		return;

	/*
	 * We need to clflush the object cache in all cases but postwrite.
	 *
	 * - Due to gpu incoherency, postread we need to flush speculative
	 * reads (which are not written back on intel cpus).
	 *
	 * - preread we need to flush data which will very soon be stale from
	 * the caches
	 *
	 * - prewrite we need to make sure our data hits the memory before the 
	 * gpu hoovers it up.
	 *
	 * The chipset also may need flushing, but that fits badly into
	 * bus_dma and it done in the driver.
	 */
	soff = trunc_page(offset);
	endoff = round_page(offset + size);
	if (ops & BUS_DMASYNC_POSTREAD || ops & BUS_DMASYNC_PREREAD ||
	    ops & BUS_DMASYNC_PREWRITE) {
		if (curcpu()->ci_cflushsz == 0) {
			/* save some wbinvd()s. we're MD anyway so it's ok */
			wbinvd();
			return;
		}

		mfence();
		spm = dmam->_dm_cookie;
		switch (spm->spm_buftype) {
		case BUS_BUFTYPE_LINEAR:
			addr = spm->spm_origbuf + soff;
			while (soff < endoff) {
				pmap_flush_cache((vaddr_t)addr, PAGE_SIZE);
				soff += PAGE_SIZE;
				addr += PAGE_SIZE;
			} break;
		case BUS_BUFTYPE_RAW:
			segp = (bus_dma_segment_t *)spm->spm_origbuf;
			poff = 0;

			while (poff < soff) {
				if (poff + segp->ds_len > soff)
					break;
				poff += segp->ds_len;
				segp++;
			}
			/* first time round may not start at seg beginning */
			pa = segp->ds_addr + (soff - poff);
			while (poff < endoff) {
				for (; pa < segp->ds_addr + segp->ds_len &&
				    poff < endoff; pa += PAGE_SIZE) {
					pmap_flush_page(pa);
					poff += PAGE_SIZE;
				}
				segp++;
				if (poff < endoff)
					pa = segp->ds_addr;
			}
			break;
		/* You do not want to load mbufs or uios onto a graphics card */
		case BUS_BUFTYPE_MBUF:
			/* FALLTHROUGH */
		case BUS_BUFTYPE_UIO:
			/* FALLTHROUGH */
		default:
			panic("intagp_dmamap_sync: bad buftype %d",
			    spm->spm_buftype);
			
		}
		mfence();
	}
}
#endif /* NINTAGP > 0 */
@


1.7
log
@Add an interface to rebind AGP DMA mappings.  To be used by the upcoming KMS
support to reload bindings after suspend/resume and to update cachability
flags in the address translation table entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_machdep.c,v 1.6 2010/05/10 22:06:04 oga Exp $	*/
a77 103
}

/*
 * functions for bus_dma used by drm for GEM
 *
 * We use the sg_dma backend (also used by iommu) to provide the actual
 * implementation, so all we need provide is the magic to create the tag, and
 * the appropriate callbacks.
 *
 * We give the backend drivers a chance to honour the bus_dma flags, some of
 * these may be used, for example to provide snooped mappings (intagp).
 * For intagp at least, we honour the BUS_DMA_COHERENT flag, though it is not
 * used often, and is * technically to be used for dmamem_map, we use it for
 * dmamap_load since adding coherency involes flags to the gtt pagetables.
 * We only use it for very special circumstances since when a GTT mapping is
 * set to coherent, the cpu can't read or write through the gtt aperture.
 *
 * Currently, since the userland agp driver still needs to access the gart, we
 * only do bus_dma for a section that we've been told is ours, hence the need
 * for the init function at present.
 */

int
agp_bus_dma_init(struct agp_softc *sc, bus_addr_t start, bus_addr_t end,
    bus_dma_tag_t *dmat)
{
	struct bus_dma_tag	*tag;
	struct sg_cookie	*cookie;

	/* 
	 * XXX add agp map into the main queue that takes up our chunk of
	 * GTT space to prevent the userland api stealing any of it.
	 */
	if ((tag = malloc(sizeof(*tag), M_DEVBUF,
	    M_WAITOK | M_CANFAIL)) == NULL)
		return (ENOMEM);

	if ((cookie = sg_dmatag_init("agpgtt", sc->sc_chipc, start, end - start,
	    sc->sc_methods->bind_page, sc->sc_methods->unbind_page,
	    sc->sc_methods->flush_tlb)) == NULL) {
		free(tag, M_DEVBUF);
		return (ENOMEM);
	}

	tag->_cookie = cookie;
	tag->_dmamap_create = sg_dmamap_create;
	tag->_dmamap_destroy = sg_dmamap_destroy;
	tag->_dmamap_load = sg_dmamap_load;
	tag->_dmamap_load_mbuf = sg_dmamap_load_mbuf;
	tag->_dmamap_load_uio = sg_dmamap_load_uio;
	tag->_dmamap_load_raw = sg_dmamap_load_raw;
	tag->_dmamap_unload = sg_dmamap_unload;
	tag->_dmamem_alloc = sg_dmamem_alloc;
	tag->_dmamem_free = _bus_dmamem_free;
	tag->_dmamem_map = _bus_dmamem_map;
	tag->_dmamem_unmap = _bus_dmamem_unmap;
	tag->_dmamem_mmap = _bus_dmamem_mmap;

	/* Driver may need special sync handling */
	if (sc->sc_methods->dma_sync != NULL) {
		tag->_dmamap_sync = sc->sc_methods->dma_sync;
	} else {
		tag->_dmamap_sync = _bus_dmamap_sync;
	}
	
	*dmat = tag;
	return (0);
}

void
agp_bus_dma_destroy(struct agp_softc *sc, bus_dma_tag_t dmat)
{
	struct sg_cookie	*cookie = dmat->_cookie;
	bus_addr_t		 offset;


	/*
	 * XXX clear up blocker queue 
	 */

	/*
	 * some backends use a dummy page to avoid errors on prefetching, etc.
	 * make sure that all of them are clean.
	 */
	for (offset = cookie->sg_ex->ex_start;
	    offset < cookie->sg_ex->ex_end; offset += PAGE_SIZE)
		sc->sc_methods->unbind_page(sc->sc_chipc, offset);

	sg_dmatag_destroy(cookie);
	free(dmat, M_DEVBUF);
}

void
agp_bus_dma_set_alignment(bus_dma_tag_t tag, bus_dmamap_t dmam,
    u_long alignment)
{
	sg_dmamap_set_alignment(tag, dmam, alignment);
}

void
agp_bus_dma_rebind(bus_dma_tag_t tag, bus_dmamap_t dmam, int flags)
{
	sg_dmamap_reload(tag, dmam, flags);
@


1.6
log
@Continue with the horrible habit of using agp_machdep.c for agp related MD
things that there really isn't a decent api for elsewhere.

Since on recent intel IGPs the gtt aperture is too big (256meg is not
uncommon) to be mapped on a kva-constrained arch like i386, introduce an agp
mapping api that does things depending on arch.

On amd64 which can afford the space (and will use the direct mapping
again soon)just do bus_space_map() on init, then parcels things out
using bus_space_subregion(), thus avoiding map/unmap overhead on every
call (this is how inteldrm does things right now).

On i386, we do bus_space_map() and bus_space_unmap as appropriate. Linux
has some tricks here involving ``atomic'' maps that are on only one cpu
and that you may not sleep with to avoid the ipi overhead for tlb
flushing. For now we don't go down that route but it is being
considered.

I am also considering if it is worth abstracting this a little more,
improving the api and making it a general MD interface.

Tested by myself on i386 and amd64 and by drahn@@ (who has one of the
machines with an aperture that is too big) on i386.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_machdep.c,v 1.5 2010/04/08 01:26:44 oga Exp $	*/
d175 6
@


1.5
log
@Fill in the bus_dma_sync for intagp to use clflush instead of wbinvd()
if supported.

When we do memory management on intel this would lead to a LOT of
wbinvd() to deal with gpu->cpu incoherency. no one wants that.

Needed for sanity of inteldrm memory management which is coming up next.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_machdep.c,v 1.4 2009/06/06 06:02:44 oga Exp $	*/
d175 53
@


1.4
log
@add an interface to agp to create a bus_dma_tag over a range of the
aperture, which will take your memory, bind it to agp, and return you the
aperture address. It's essentially the same as iommu on amd64 in the way it
works.

This will be used by the upcoming (works but is slow and will not be
enabled at first) drm memory management code for intel igp chipsets.

Right now the sync function for intagp is really slow (doing a wbinvd()
on every sync), this is in the process of getting fixed, but the size of
the diffs in my trees was getting silly.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_machdep.c,v 1.3 2007/11/25 17:11:12 oga Exp $	*/
d57 2
d74 6
d151 1
d158 8
a176 1

d202 6
d238 2
d242 50
a291 2
		/* XXX use clflush */
		wbinvd();
d294 1
a294 1
#endif
@


1.3
log
@Make agp attach as a device. This means that many more agp bridges
actually get detected and attached. Also adds a kernel api for
manipulating agp.

Enable this on i386 and amd64.

"I think you should commit it" deraadt@@, ok matthieu. Looked over by
several others.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_machdep.c,v 1.2 2007/08/04 19:40:25 reyk Exp $	*/
d4 15
d45 1
d47 1
d55 10
d71 152
@


1.2
log
@Add AGP support for the intel i965 chipset, this also extends the
internal AGP API to work with 64bit PCI-Express memory and
non-standard AGP aperture bases.

tested by many
ok matthieu@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_machdep.c,v 1.1 2007/05/29 22:27:14 tedu Exp $	*/
a37 10

const struct agp_product agp_products[] = {
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82915G_IV, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82915GM_IGD, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82945G_IGD_1, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82945GM_IGD, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82965_IGD_1, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82965GM_IGD_1, agp_i810_attach },
	{ 0, 0, NULL }
};
@


1.1
log
@only the i810 is known to be needed for agp, reduce driver set to just that
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_machdep.c,v 1.7 2006/05/15 08:27:19 dim Exp $	*/
d44 2
@

