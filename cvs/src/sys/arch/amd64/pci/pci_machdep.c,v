head	1.65;
access;
symbols
	OPENBSD_6_1:1.65.0.6
	OPENBSD_6_1_BASE:1.65
	OPENBSD_6_0:1.65.0.2
	OPENBSD_6_0_BASE:1.65
	OPENBSD_5_9:1.62.0.2
	OPENBSD_5_9_BASE:1.62
	OPENBSD_5_8:1.62.0.4
	OPENBSD_5_8_BASE:1.62
	OPENBSD_5_7:1.61.0.2
	OPENBSD_5_7_BASE:1.61
	OPENBSD_5_6:1.59.0.4
	OPENBSD_5_6_BASE:1.59
	OPENBSD_5_5:1.58.0.4
	OPENBSD_5_5_BASE:1.58
	OPENBSD_5_4:1.57.0.2
	OPENBSD_5_4_BASE:1.57
	OPENBSD_5_3:1.56.0.2
	OPENBSD_5_3_BASE:1.56
	OPENBSD_5_2:1.53.0.4
	OPENBSD_5_2_BASE:1.53
	OPENBSD_5_1_BASE:1.53
	OPENBSD_5_1:1.53.0.2
	OPENBSD_5_0:1.51.0.2
	OPENBSD_5_0_BASE:1.51
	OPENBSD_4_9:1.40.0.2
	OPENBSD_4_9_BASE:1.40
	OPENBSD_4_8:1.35.0.2
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.29.0.4
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.21.0.2
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.14.0.2
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.13.0.4
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.2
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.11.0.2
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.7.0.4
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.6.0.2
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.3.0.4
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	OPENBSD_3_5:1.1.0.4
	OPENBSD_3_5_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.65
date	2016.06.02.21.01.51;	author kettenis;	state Exp;
branches;
next	1.64;
commitid	N0dJSlBj0uxR7upW;

1.64
date	2016.05.14.20.22.41;	author kettenis;	state Exp;
branches;
next	1.63;
commitid	T0gbFzsexKUE43Y1;

1.63
date	2016.05.04.14.30.00;	author kettenis;	state Exp;
branches;
next	1.62;
commitid	n9OfCKyY3NAvSMg8;

1.62
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.61;
commitid	p4LJxGKbi0BU2cG6;

1.61
date	2015.01.24.15.13.55;	author kettenis;	state Exp;
branches;
next	1.60;
commitid	Ol0pICcR5PormuCL;

1.60
date	2014.12.16.23.13.20;	author jmatthew;	state Exp;
branches;
next	1.59;
commitid	Xr1FdVLlxSCGWU0q;

1.59
date	2014.04.19.11.53.42;	author kettenis;	state Exp;
branches;
next	1.58;

1.58
date	2013.11.06.10.40.36;	author mpi;	state Exp;
branches;
next	1.57;

1.57
date	2013.05.30.16.19.25;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2012.10.16.13.57.46;	author mikeb;	state Exp;
branches;
next	1.55;

1.55
date	2012.09.19.23.23.50;	author kettenis;	state Exp;
branches;
next	1.54;

1.54
date	2012.09.07.19.21.57;	author kettenis;	state Exp;
branches;
next	1.53;

1.53
date	2011.10.29.19.17.30;	author kettenis;	state Exp;
branches;
next	1.52;

1.52
date	2011.10.13.09.44.40;	author kettenis;	state Exp;
branches;
next	1.51;

1.51
date	2011.06.18.17.28.18;	author kettenis;	state Exp;
branches;
next	1.50;

1.50
date	2011.06.16.22.20.39;	author kettenis;	state Exp;
branches;
next	1.49;

1.49
date	2011.06.05.18.09.00;	author kettenis;	state Exp;
branches;
next	1.48;

1.48
date	2011.06.05.10.07.30;	author kettenis;	state Exp;
branches;
next	1.47;

1.47
date	2011.06.02.19.59.00;	author kettenis;	state Exp;
branches;
next	1.46;

1.46
date	2011.05.30.19.27.40;	author kettenis;	state Exp;
branches;
next	1.45;

1.45
date	2011.05.29.10.47.42;	author kettenis;	state Exp;
branches;
next	1.44;

1.44
date	2011.05.21.15.58.27;	author kettenis;	state Exp;
branches;
next	1.43;

1.43
date	2011.04.22.15.02.35;	author kettenis;	state Exp;
branches;
next	1.42;

1.42
date	2011.04.10.16.40.42;	author kettenis;	state Exp;
branches;
next	1.41;

1.41
date	2011.04.02.18.16.50;	author oga;	state Exp;
branches;
next	1.40;

1.40
date	2011.01.10.16.26.27;	author kettenis;	state Exp;
branches;
next	1.39;

1.39
date	2011.01.09.11.38.10;	author kettenis;	state Exp;
branches;
next	1.38;

1.38
date	2011.01.04.21.17.49;	author kettenis;	state Exp;
branches;
next	1.37;

1.37
date	2010.12.04.17.06.31;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2010.09.06.19.05.48;	author kettenis;	state Exp;
branches;
next	1.35;

1.35
date	2010.07.08.20.56.31;	author jordan;	state Exp;
branches;
next	1.34;

1.34
date	2010.07.01.06.29.32;	author jordan;	state Exp;
branches;
next	1.33;

1.33
date	2010.06.29.22.08.29;	author jordan;	state Exp;
branches;
next	1.32;

1.32
date	2009.09.28.15.58.30;	author kettenis;	state Exp;
branches;
next	1.31;

1.31
date	2009.08.22.02.54.50;	author mk;	state Exp;
branches;
next	1.30;

1.30
date	2009.07.20.23.40.43;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2009.04.29.18.28.38;	author kettenis;	state Exp;
branches;
next	1.28;

1.28
date	2009.04.21.19.18.09;	author kettenis;	state Exp;
branches;
next	1.27;

1.27
date	2009.04.21.17.05.29;	author oga;	state Exp;
branches;
next	1.26;

1.26
date	2009.04.13.21.23.16;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2009.04.11.17.13.33;	author kettenis;	state Exp;
branches;
next	1.24;

1.24
date	2009.04.04.16.03.17;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2009.04.04.15.08.05;	author kettenis;	state Exp;
branches;
next	1.22;

1.22
date	2009.03.10.15.03.17;	author oga;	state Exp;
branches;
next	1.21;

1.21
date	2009.01.27.15.33.59;	author oga;	state Exp;
branches;
next	1.20;

1.20
date	2008.12.28.18.26.53;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2008.12.07.14.33.26;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2008.12.06.19.59.38;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2008.12.06.05.08.02;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2008.12.03.15.46.06;	author oga;	state Exp;
branches;
next	1.15;

1.15
date	2008.11.26.12.27.31;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2008.06.26.05.42.09;	author ray;	state Exp;
branches;
next	1.13;

1.13
date	2007.08.08.18.54.29;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2007.05.21.22.10.45;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2007.01.15.23.19.05;	author jsg;	state Exp;
branches;
next	1.10;

1.10
date	2006.12.14.17.14.01;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2006.11.25.16.59.31;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.31.06.13.48;	author weingart;	state Exp;
branches;
next	1.7;

1.7
date	2005.09.04.19.19.40;	author brad;	state Exp;
branches;
next	1.6;

1.6
date	2005.06.25.21.00.56;	author brad;	state Exp;
branches;
next	1.5;

1.5
date	2005.05.27.07.46.38;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2005.05.14.00.13.15;	author brad;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.28.01.52.26;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.25.11.03.28;	author art;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.28.01.39.39;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.65
log
@Fix two issues in the MSI-X code.  First, actually read the MSI-X capability
register.  Second, correctly decode the table sizefromits contents.

First issue pointed out by David Hill (with the help of clang).  Second
issue spotted after seeing a diff from Christiano Hasbaert.
@
text
@/*	$OpenBSD: pci_machdep.c,v 1.64 2016/05/14 20:22:41 kettenis Exp $	*/
/*	$NetBSD: pci_machdep.c,v 1.3 2003/05/07 21:33:58 fvdl Exp $	*/

/*-
 * Copyright (c) 1997, 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1996 Christopher G. Demetriou.  All rights reserved.
 * Copyright (c) 1994 Charles M. Hannum.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Charles M. Hannum.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Machine-specific functions for PCI autoconfiguration.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/time.h>
#include <sys/systm.h>
#include <sys/errno.h>
#include <sys/device.h>
#include <sys/extent.h>
#include <sys/malloc.h>

#include <uvm/uvm_extern.h>

#include <machine/bus.h>

#include <machine/pio.h>
#include <machine/intr.h>
#include <machine/biosvar.h>

#include <dev/isa/isareg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>
#include <dev/pci/ppbreg.h>

#include "ioapic.h"

#if NIOAPIC > 0
#include <machine/i82093var.h>
#include <machine/mpbiosvar.h>
#endif

/*
 * Memory Mapped Configuration space access.
 *
 * Since mapping the whole configuration space will cost us up to
 * 256MB of kernel virtual memory, we use seperate mappings per bus.
 * The mappings are created on-demand, such that we only use kernel
 * virtual memory for busses that are actually present.
 */
bus_addr_t pci_mcfg_addr;
int pci_mcfg_min_bus, pci_mcfg_max_bus;
bus_space_tag_t pci_mcfgt = X86_BUS_SPACE_MEM;
bus_space_handle_t pci_mcfgh[256];
void pci_mcfg_map_bus(int);

struct mutex pci_conf_lock = MUTEX_INITIALIZER(IPL_HIGH);

#define	PCI_CONF_LOCK()						\
do {									\
	mtx_enter(&pci_conf_lock);					\
} while (0)

#define	PCI_CONF_UNLOCK()						\
do {									\
	mtx_leave(&pci_conf_lock);					\
} while (0)

#define	PCI_MODE1_ENABLE	0x80000000UL
#define	PCI_MODE1_ADDRESS_REG	0x0cf8
#define	PCI_MODE1_DATA_REG	0x0cfc

/*
 * PCI doesn't have any special needs; just use the generic versions
 * of these functions.
 */
struct bus_dma_tag pci_bus_dma_tag = {
	NULL,			/* _may_bounce */
	_bus_dmamap_create,
	_bus_dmamap_destroy,
	_bus_dmamap_load,
	_bus_dmamap_load_mbuf,
	_bus_dmamap_load_uio,
	_bus_dmamap_load_raw,
	_bus_dmamap_unload,
	_bus_dmamap_sync,
	_bus_dmamem_alloc,
	_bus_dmamem_alloc_range,
	_bus_dmamem_free,
	_bus_dmamem_map,
	_bus_dmamem_unmap,
	_bus_dmamem_mmap,
};

void
pci_attach_hook(struct device *parent, struct device *self,
    struct pcibus_attach_args *pba)
{
	pci_chipset_tag_t pc = pba->pba_pc;
	pcitag_t tag;
	pcireg_t id, class;

	if (pba->pba_bus != 0)
		return;

	/*
	 * In order to decide whether the system supports MSI we look
	 * at the host bridge, which should be device 0 function 0 on
	 * bus 0.  It is better to not enable MSI on systems that
	 * support it than the other way around, so be conservative
	 * here.  So we don't enable MSI if we don't find a host
	 * bridge there.  We also deliberately don't enable MSI on
	 * chipsets from low-end manifacturers like VIA and SiS.
	 */
	tag = pci_make_tag(pc, 0, 0, 0);
	id = pci_conf_read(pc, tag, PCI_ID_REG);
	class = pci_conf_read(pc, tag, PCI_CLASS_REG);

	if (PCI_CLASS(class) != PCI_CLASS_BRIDGE ||
	    PCI_SUBCLASS(class) != PCI_SUBCLASS_BRIDGE_HOST)
		return;

	switch (PCI_VENDOR(id)) {
	case PCI_VENDOR_INTEL:
		/*
		 * In the wonderful world of virtualization you can
		 * have the latest 64-bit AMD multicore CPU behind a
		 * prehistoric Intel host bridge.  Give them what they
		 * deserve.
		 */
		switch (PCI_PRODUCT(id)) {
		case PCI_PRODUCT_INTEL_82441FX:	/* QEMU */
		case PCI_PRODUCT_INTEL_82443BX:	/* VMWare */
			break;
		default:
			pba->pba_flags |= PCI_FLAGS_MSI_ENABLED;
			break;
		}
		break;
	case PCI_VENDOR_NVIDIA:
	case PCI_VENDOR_AMD:
		pba->pba_flags |= PCI_FLAGS_MSI_ENABLED;
		break;
	}

	/*
	 * Don't enable MSI on a HyperTransport bus.  In order to
	 * determine that bus 0 is a HyperTransport bus, we look at
	 * device 24 function 0, which is the HyperTransport
	 * host/primary interface integrated on most 64-bit AMD CPUs.
	 * If that device has a HyperTransport capability, bus 0 must
	 * be a HyperTransport bus and we disable MSI.
	 */
	tag = pci_make_tag(pc, 0, 24, 0);
	if (pci_get_capability(pc, tag, PCI_CAP_HT, NULL, NULL))
		pba->pba_flags &= ~PCI_FLAGS_MSI_ENABLED;
}

int
pci_bus_maxdevs(pci_chipset_tag_t pc, int busno)
{
	return (32);
}

pcitag_t
pci_make_tag(pci_chipset_tag_t pc, int bus, int device, int function)
{
	if (bus >= 256 || device >= 32 || function >= 8)
		panic("pci_make_tag: bad request");

	return (PCI_MODE1_ENABLE |
	    (bus << 16) | (device << 11) | (function << 8));
}

void
pci_decompose_tag(pci_chipset_tag_t pc, pcitag_t tag, int *bp, int *dp, int *fp)
{
	if (bp != NULL)
		*bp = (tag >> 16) & 0xff;
	if (dp != NULL)
		*dp = (tag >> 11) & 0x1f;
	if (fp != NULL)
		*fp = (tag >> 8) & 0x7;
}

int
pci_conf_size(pci_chipset_tag_t pc, pcitag_t tag)
{
	int bus;

	if (pci_mcfg_addr) {
		pci_decompose_tag(pc, tag, &bus, NULL, NULL);
		if (bus >= pci_mcfg_min_bus && bus <= pci_mcfg_max_bus)
			return PCIE_CONFIG_SPACE_SIZE;
	}

	return PCI_CONFIG_SPACE_SIZE;
}

void
pci_mcfg_map_bus(int bus)
{
	if (pci_mcfgh[bus])
		return;

	if (bus_space_map(pci_mcfgt, pci_mcfg_addr + (bus << 20), 1 << 20,
	    0, &pci_mcfgh[bus]))
		panic("pci_conf_read: cannot map mcfg space");
}

pcireg_t
pci_conf_read(pci_chipset_tag_t pc, pcitag_t tag, int reg)
{
	pcireg_t data;
	int bus;

	KASSERT((reg & 0x3) == 0);

	if (pci_mcfg_addr && reg >= PCI_CONFIG_SPACE_SIZE) {
		pci_decompose_tag(pc, tag, &bus, NULL, NULL);
		if (bus >= pci_mcfg_min_bus && bus <= pci_mcfg_max_bus) {
			pci_mcfg_map_bus(bus);
			data = bus_space_read_4(pci_mcfgt, pci_mcfgh[bus],
			    (tag & 0x000ff00) << 4 | reg);
			return data;
		}
	}

	PCI_CONF_LOCK();
	outl(PCI_MODE1_ADDRESS_REG, tag | reg);
	data = inl(PCI_MODE1_DATA_REG);
	outl(PCI_MODE1_ADDRESS_REG, 0);
	PCI_CONF_UNLOCK();

	return data;
}

void
pci_conf_write(pci_chipset_tag_t pc, pcitag_t tag, int reg, pcireg_t data)
{
	int bus;

	KASSERT((reg & 0x3) == 0);

	if (pci_mcfg_addr && reg >= PCI_CONFIG_SPACE_SIZE) {
		pci_decompose_tag(pc, tag, &bus, NULL, NULL);
		if (bus >= pci_mcfg_min_bus && bus <= pci_mcfg_max_bus) {
			pci_mcfg_map_bus(bus);
			bus_space_write_4(pci_mcfgt, pci_mcfgh[bus],
			    (tag & 0x000ff00) << 4 | reg, data);
			return;
		}
	}

	PCI_CONF_LOCK();
	outl(PCI_MODE1_ADDRESS_REG, tag | reg);
	outl(PCI_MODE1_DATA_REG, data);
	outl(PCI_MODE1_ADDRESS_REG, 0);
	PCI_CONF_UNLOCK();
}

void msi_hwmask(struct pic *, int);
void msi_hwunmask(struct pic *, int);
void msi_addroute(struct pic *, struct cpu_info *, int, int, int);
void msi_delroute(struct pic *, struct cpu_info *, int, int, int);

struct pic msi_pic = {
	{0, {NULL}, NULL, 0, "msi", NULL, 0, 0},
	PIC_MSI,
#ifdef MULTIPROCESSOR
	{},
#endif
	msi_hwmask,
	msi_hwunmask,
	msi_addroute,
	msi_delroute,
	NULL,
	ioapic_edge_stubs
};

void
msi_hwmask(struct pic *pic, int pin)
{
}

void
msi_hwunmask(struct pic *pic, int pin)
{
}

void
msi_addroute(struct pic *pic, struct cpu_info *ci, int pin, int vec, int type)
{
	pci_chipset_tag_t pc = NULL; /* XXX */
	pcitag_t tag = pin;
	pcireg_t reg, addr;
	int off;

	if (pci_get_capability(pc, tag, PCI_CAP_MSI, &off, &reg) == 0)
		panic("%s: no msi capability", __func__);

	addr = 0xfee00000UL | (ci->ci_apicid << 12);

	if (reg & PCI_MSI_MC_C64) {
		pci_conf_write(pc, tag, off + PCI_MSI_MA, addr);
		pci_conf_write(pc, tag, off + PCI_MSI_MAU32, 0);
		pci_conf_write(pc, tag, off + PCI_MSI_MD64, vec);
	} else {
		pci_conf_write(pc, tag, off + PCI_MSI_MA, addr);
		pci_conf_write(pc, tag, off + PCI_MSI_MD32, vec);
	}
	pci_conf_write(pc, tag, off, reg | PCI_MSI_MC_MSIE);
}

void
msi_delroute(struct pic *pic, struct cpu_info *ci, int pin, int vec, int type)
{
	pci_chipset_tag_t pc = NULL; /* XXX */
	pcitag_t tag = pin;
	pcireg_t reg;
	int off;

	if (pci_get_capability(pc, tag, PCI_CAP_MSI, &off, &reg))
		pci_conf_write(pc, tag, off, reg & ~PCI_MSI_MC_MSIE);
}

int
pci_intr_map_msi(struct pci_attach_args *pa, pci_intr_handle_t *ihp)
{
	pci_chipset_tag_t pc = pa->pa_pc;
	pcitag_t tag = pa->pa_tag;

	if ((pa->pa_flags & PCI_FLAGS_MSI_ENABLED) == 0 || mp_busses == NULL ||
	    pci_get_capability(pc, tag, PCI_CAP_MSI, NULL, NULL) == 0)
		return 1;

	ihp->tag = tag;
	ihp->line = APIC_INT_VIA_MSG;
	ihp->pin = 0;
	return 0;
}

void msix_hwmask(struct pic *, int);
void msix_hwunmask(struct pic *, int);
void msix_addroute(struct pic *, struct cpu_info *, int, int, int);
void msix_delroute(struct pic *, struct cpu_info *, int, int, int);

struct pic msix_pic = {
	{0, {NULL}, NULL, 0, "msix", NULL, 0, 0},
	PIC_MSI,
#ifdef MULTIPROCESSOR
	{},
#endif
	msix_hwmask,
	msix_hwunmask,
	msix_addroute,
	msix_delroute,
	NULL,
	ioapic_edge_stubs
};

/*
 * We pack the MSI-X vector number into the lower 8 bits of the PCI
 * tag and use that as the MSI-X "PIC" pin number.  This allows us to
 * address 256 MSI-X vectors which ought to be enough for anybody.
 */
#define PCI_MSIX_VEC_MASK	0xff
#define PCI_MSIX_VEC(pin)	((pin) & PCI_MSIX_VEC_MASK)
#define PCI_MSIX_TAG(pin)	((pin) & ~PCI_MSIX_VEC_MASK)
#define PCI_MSIX_PIN(tag, vec)	((tag) | (vec))

void
msix_hwmask(struct pic *pic, int pin)
{
}

void
msix_hwunmask(struct pic *pic, int pin)
{
}

void
msix_addroute(struct pic *pic, struct cpu_info *ci, int pin, int vec, int type)
{
	pci_chipset_tag_t pc = NULL; /* XXX */
	bus_space_tag_t memt = X86_BUS_SPACE_MEM; /* XXX */
	bus_space_handle_t memh;
	bus_addr_t base;
	pcitag_t tag = PCI_MSIX_TAG(pin);
	int entry = PCI_MSIX_VEC(pin);
	pcireg_t reg, addr, table;
	uint32_t ctrl;
	int bir, offset;
	int off, tblsz;

	if (pci_get_capability(pc, tag, PCI_CAP_MSIX, &off, &reg) == 0)
		panic("%s: no msix capability", __func__);

	addr = 0xfee00000UL | (ci->ci_apicid << 12);

	table = pci_conf_read(pc, tag, off + PCI_MSIX_TABLE);
	bir = (table & PCI_MSIX_TABLE_BIR);
	offset = (table & PCI_MSIX_TABLE_OFF);
	tblsz = PCI_MSIX_MC_TBLSZ(reg) + 1;

	bir = PCI_MAPREG_START + bir * 4;
	if (pci_mem_find(pc, tag, bir, &base, NULL, NULL) ||
	    _bus_space_map(memt, base + offset, tblsz * 16, 0, &memh))
		panic("%s: cannot map registers", __func__);

	bus_space_write_8(memt, memh, PCI_MSIX_MA(entry), addr);
	bus_space_write_4(memt, memh, PCI_MSIX_MD(entry), vec);
	bus_space_barrier(memt, memh, PCI_MSIX_MA(entry), 16,
	    BUS_SPACE_BARRIER_WRITE);
	ctrl = bus_space_read_4(memt, memh, PCI_MSIX_VC(entry));
	bus_space_write_4(memt, memh, PCI_MSIX_VC(entry),
	    ctrl & ~PCI_MSIX_VC_MASK);

	_bus_space_unmap(memt, memh, tblsz * 16, NULL);

	pci_conf_write(pc, tag, off, reg | PCI_MSIX_MC_MSIXE);
}

void
msix_delroute(struct pic *pic, struct cpu_info *ci, int pin, int vec, int type)
{
	pci_chipset_tag_t pc = NULL; /* XXX */
	bus_space_tag_t memt = X86_BUS_SPACE_MEM; /* XXX */
	bus_space_handle_t memh;
	bus_addr_t base;
	pcitag_t tag = PCI_MSIX_TAG(pin);
	int entry = PCI_MSIX_VEC(pin);
	pcireg_t reg, table;
	uint32_t ctrl;
	int bir, offset;
	int off, tblsz;

	if (pci_get_capability(pc, tag, PCI_CAP_MSIX, &off, &reg) == 0)
		return;

	table = pci_conf_read(pc, tag, off + PCI_MSIX_TABLE);
	bir = (table & PCI_MSIX_TABLE_BIR);
	offset = (table & PCI_MSIX_TABLE_OFF);
	tblsz = PCI_MSIX_MC_TBLSZ(reg) + 1;

	bir = PCI_MAPREG_START + bir * 4;
	if (pci_mem_find(pc, tag, bir, &base, NULL, NULL) ||
	    _bus_space_map(memt, base + offset, tblsz * 16, 0, &memh))
		panic("%s: cannot map registers", __func__);

	ctrl = bus_space_read_4(memt, memh, PCI_MSIX_VC(entry));
	bus_space_write_4(memt, memh, PCI_MSIX_VC(entry),
	    ctrl | PCI_MSIX_VC_MASK);

	_bus_space_unmap(memt, memh, tblsz * 16, NULL);
}

int
pci_intr_map_msix(struct pci_attach_args *pa, int vec, pci_intr_handle_t *ihp)
{
	pci_chipset_tag_t pc = pa->pa_pc;
	pcitag_t tag = pa->pa_tag;
	pcireg_t reg;

	KASSERT(PCI_MSIX_VEC(vec) == vec);

	if ((pa->pa_flags & PCI_FLAGS_MSI_ENABLED) == 0 || mp_busses == NULL ||
	    pci_get_capability(pc, tag, PCI_CAP_MSIX, NULL, &reg) == 0)
		return 1;

	if (vec > PCI_MSIX_MC_TBLSZ(reg))
		return 1;

	ihp->tag = PCI_MSIX_PIN(tag, vec);
	ihp->line = APIC_INT_VIA_MSGX;
	ihp->pin = 0;
	return 0;
}

int
pci_intr_map(struct pci_attach_args *pa, pci_intr_handle_t *ihp)
{
	int pin = pa->pa_rawintrpin;
	int line = pa->pa_intrline;
#if NIOAPIC > 0
	struct mp_intr_map *mip;
	int bus, dev, func;
#endif

	if (pin == 0) {
		/* No IRQ used. */
		goto bad;
	}

	if (pin > PCI_INTERRUPT_PIN_MAX) {
		printf("pci_intr_map: bad interrupt pin %d\n", pin);
		goto bad;
	}

	ihp->tag = pa->pa_tag;
	ihp->line = line;
	ihp->pin = pin;

#if NIOAPIC > 0
	pci_decompose_tag(pa->pa_pc, pa->pa_tag, &bus, &dev, &func);

	if (mp_busses != NULL) {
		int mpspec_pin = (dev << 2) | (pin - 1);

		if (bus < mp_nbusses) {
			for (mip = mp_busses[bus].mb_intrs;
			     mip != NULL; mip = mip->next) {
				if (&mp_busses[bus] == mp_isa_bus ||
				    &mp_busses[bus] == mp_eisa_bus)
					continue;
				if (mip->bus_pin == mpspec_pin) {
					ihp->line = mip->ioapic_ih | line;
					return 0;
				}
			}
		}

		if (pa->pa_bridgetag) {
			int swizpin = PPB_INTERRUPT_SWIZZLE(pin, dev);
			if (pa->pa_bridgeih[swizpin - 1].line != -1) {
				ihp->line = pa->pa_bridgeih[swizpin - 1].line;
				ihp->line |= line;
				return 0;
			}
		}
		/*
		 * No explicit PCI mapping found. This is not fatal,
		 * we'll try the ISA (or possibly EISA) mappings next.
		 */
	}
#endif

	/*
	 * Section 6.2.4, `Miscellaneous Functions', says that 255 means
	 * `unknown' or `no connection' on a PC.  We assume that a device with
	 * `no connection' either doesn't have an interrupt (in which case the
	 * pin number should be 0, and would have been noticed above), or
	 * wasn't configured by the BIOS (in which case we punt, since there's
	 * no real way we can know how the interrupt lines are mapped in the
	 * hardware).
	 *
	 * XXX
	 * Since IRQ 0 is only used by the clock, and we can't actually be sure
	 * that the BIOS did its job, we also recognize that as meaning that
	 * the BIOS has not configured the device.
	 */
	if (line == 0 || line == X86_PCI_INTERRUPT_LINE_NO_CONNECTION)
		goto bad;

	if (line >= NUM_LEGACY_IRQS) {
		printf("pci_intr_map: bad interrupt line %d\n", line);
		goto bad;
	}
	if (line == 2) {
		printf("pci_intr_map: changed line 2 to line 9\n");
		line = 9;
	}

#if NIOAPIC > 0
	if (mp_busses != NULL) {
		if (mip == NULL && mp_isa_bus) {
			for (mip = mp_isa_bus->mb_intrs; mip != NULL;
			    mip = mip->next) {
				if (mip->bus_pin == line) {
					ihp->line = mip->ioapic_ih | line;
					return 0;
				}
			}
		}
#if NEISA > 0
		if (mip == NULL && mp_eisa_bus) {
			for (mip = mp_eisa_bus->mb_intrs;  mip != NULL;
			    mip = mip->next) {
				if (mip->bus_pin == line) {
					ihp->line = mip->ioapic_ih | line;
					return 0;
				}
			}
		}
#endif
		if (mip == NULL) {
			printf("pci_intr_map: "
			    "bus %d dev %d func %d pin %d; line %d\n",
			    bus, dev, func, pin, line);
			printf("pci_intr_map: no MP mapping found\n");
		}
	}
#endif

	return 0;

bad:
	ihp->line = -1;
	return 1;
}

const char *
pci_intr_string(pci_chipset_tag_t pc, pci_intr_handle_t ih)
{
	static char irqstr[64];

	if (ih.line == 0)
		panic("pci_intr_string: bogus handle 0x%x", ih.line);

	if (ih.line & APIC_INT_VIA_MSG)
		return ("msi");
	if (ih.line & APIC_INT_VIA_MSGX)
		return ("msix");

#if NIOAPIC > 0
	if (ih.line & APIC_INT_VIA_APIC)
		snprintf(irqstr, sizeof(irqstr), "apic %d int %d",
		    APIC_IRQ_APIC(ih.line), APIC_IRQ_PIN(ih.line));
	else
		snprintf(irqstr, sizeof(irqstr), "irq %d",
		    pci_intr_line(pc, ih));
#else
	snprintf(irqstr, sizeof(irqstr), "irq %d", pci_intr_line(pc, ih));
#endif
	return (irqstr);
}

#include "acpiprt.h"
#if NACPIPRT > 0
void	acpiprt_route_interrupt(int bus, int dev, int pin);
#endif

void *
pci_intr_establish(pci_chipset_tag_t pc, pci_intr_handle_t ih, int level,
    int (*func)(void *), void *arg, const char *what)
{
	int pin, irq;
	int bus, dev;
	pcitag_t tag = ih.tag;
	struct pic *pic;

	if (ih.line & APIC_INT_VIA_MSG) {
		return intr_establish(-1, &msi_pic, tag, IST_PULSE, level,
		    func, arg, what);
	}
	if (ih.line & APIC_INT_VIA_MSGX) {
		return intr_establish(-1, &msix_pic, tag, IST_PULSE, level,
		    func, arg, what);
	}

	pci_decompose_tag(pc, ih.tag, &bus, &dev, NULL);
#if NACPIPRT > 0
	acpiprt_route_interrupt(bus, dev, ih.pin);
#endif

	pic = &i8259_pic;
	pin = irq = ih.line;

#if NIOAPIC > 0
	if (ih.line & APIC_INT_VIA_APIC) {
		pic = (struct pic *)ioapic_find(APIC_IRQ_APIC(ih.line));
		if (pic == NULL) {
			printf("pci_intr_establish: bad ioapic %d\n",
			    APIC_IRQ_APIC(ih.line));
			return NULL;
		}
		pin = APIC_IRQ_PIN(ih.line);
		irq = APIC_IRQ_LEGACY_IRQ(ih.line);
		if (irq < 0 || irq >= NUM_LEGACY_IRQS)
			irq = -1;
	}
#endif

	return intr_establish(irq, pic, pin, IST_LEVEL, level, func, arg, what);
}

void
pci_intr_disestablish(pci_chipset_tag_t pc, void *cookie)
{
	intr_disestablish(cookie);
}

struct extent *pciio_ex;
struct extent *pcimem_ex;
struct extent *pcibus_ex;

void
pci_init_extents(void)
{
	bios_memmap_t *bmp;
	u_int64_t size;

	if (pciio_ex == NULL) {
		/*
		 * We only have 64K of addressable I/O space.
		 * However, since BARs may contain garbage, we cover
		 * the full 32-bit address space defined by PCI of
		 * which we only make the first 64K available.
		 */
		pciio_ex = extent_create("pciio", 0, 0xffffffff, M_DEVBUF,
		    NULL, 0, EX_NOWAIT | EX_FILLED);
		if (pciio_ex == NULL)
			return;
		extent_free(pciio_ex, 0, 0x10000, EX_NOWAIT);
	}

	if (pcimem_ex == NULL) {
		/*
		 * Cover the 36-bit address space addressable by PAE
		 * here.  As long as vendors continue to support
		 * 32-bit operating systems, we should never see BARs
		 * outside that region.
		 *
		 * Dell 13G servers have important devices outside the
		 * 36-bit address space.  Until we can extract the address
		 * ranges from ACPI, expand the allowed range to suit.
		 */
		pcimem_ex = extent_create("pcimem", 0, 0xffffffffffffffffUL,
		    M_DEVBUF, NULL, 0, EX_NOWAIT);
		if (pcimem_ex == NULL)
			return;
		extent_alloc_region(pcimem_ex, 0x40000000000UL,
		    0xfffffc0000000000UL, EX_NOWAIT);

		for (bmp = bios_memmap; bmp->type != BIOS_MAP_END; bmp++) {
			/*
			 * Ignore address space beyond 4G.
			 */
			if (bmp->addr >= 0x100000000ULL)
				continue;
			size = bmp->size;
			if (bmp->addr + size >= 0x100000000ULL)
				size = 0x100000000ULL - bmp->addr;

			/* Ignore zero-sized regions. */
			if (size == 0)
				continue;

			if (extent_alloc_region(pcimem_ex, bmp->addr, size,
			    EX_NOWAIT))
				printf("memory map conflict 0x%llx/0x%llx\n",
				    bmp->addr, bmp->size);
		}

		/* Take out the video buffer area and BIOS areas. */
		extent_alloc_region(pcimem_ex, IOM_BEGIN, IOM_SIZE,
		    EX_CONFLICTOK | EX_NOWAIT);
	}

	if (pcibus_ex == NULL) {
		pcibus_ex = extent_create("pcibus", 0, 0xff, M_DEVBUF,
		    NULL, 0, EX_NOWAIT);
	}
}

#include "acpi.h"
#if NACPI > 0
void acpi_pci_match(struct device *, struct pci_attach_args *);
pcireg_t acpi_pci_min_powerstate(pci_chipset_tag_t, pcitag_t);
void acpi_pci_set_powerstate(pci_chipset_tag_t, pcitag_t, int, int);
#endif

void
pci_dev_postattach(struct device *dev, struct pci_attach_args *pa)
{
#if NACPI > 0
	acpi_pci_match(dev, pa);
#endif
}

pcireg_t
pci_min_powerstate(pci_chipset_tag_t pc, pcitag_t tag)
{
#if NACPI > 0
	return acpi_pci_min_powerstate(pc, tag);
#else
	return pci_get_powerstate(pc, tag);
#endif
}

void
pci_set_powerstate_md(pci_chipset_tag_t pc, pcitag_t tag, int state, int pre)
{
#if NACPI > 0
	acpi_pci_set_powerstate(pc, tag, state, pre);
#endif
}
@


1.64
log
@Fix typo; M_NOWAIT should be EX_NOWAIT.  Fortunately this was harmless.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.63 2016/05/04 14:30:00 kettenis Exp $	*/
d459 1
a459 1
	tblsz = (reg & PCI_MSIX_MC_TBLSZ) + 1;
d499 1
a499 1
	tblsz = (reg & PCI_MSIX_MC_TBLSZ) + 1;
d523 1
a523 1
	    pci_get_capability(pc, tag, PCI_CAP_MSIX, NULL, NULL) == 0)
d526 1
a526 1
	if (vec > (reg & PCI_MSIX_MC_TBLSZ))
@


1.63
log
@Initial support for MSI-X.  Only supported on amd64 for now.  I have diffs to
actually use this in em(4) and xhci(4), but I'm not committing those yet
because we almost certainly need to save and restore the MSI-X registers
during suspend/resume.  However, this allows mpi@@ to play with multiple-vector
support in networking hardware.

Requested by mpi@@
ok mlarkin@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.62 2015/03/14 03:38:46 jsg Exp $	*/
d759 1
a759 1
		extent_free(pciio_ex, 0, 0x10000, M_NOWAIT);
@


1.62
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.61 2015/01/24 15:13:55 kettenis Exp $	*/
d398 137
d667 2
d699 4
@


1.61
log
@Add bus_dmamem_alloc_range(9) to allow drivers to allocate DMA'able memory
within a range that is more (or less) restrictive than the default range.

ok deraadt@@, stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.60 2014/12/16 23:13:20 jmatthew Exp $	*/
a85 1
#include <dev/isa/isavar.h>
@


1.60
log
@Temporarily expand the pci memory range to suit Dell 13G servers.
They have devices outside the 36 bit range that their firmware needs to talk
to, and they get constant acpi interrupts if it can't.  We should get the
necessary ranges via ACPI, but for now just make the allowed range bigger.

ok kettenis@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.59 2014/04/19 11:53:42 kettenis Exp $	*/
d144 1
@


1.59
log
@Don't panic if we're trying to disestablish an MSI but the hardware is gone.

tested by & ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.58 2013/11/06 10:40:36 mpi Exp $	*/
d625 4
d634 2
a635 2
		extent_alloc_region(pcimem_ex, 0x1000000000UL,
		    0xfffffff000000000UL, EX_NOWAIT);
@


1.58
log
@Add support for Power Resources for Dx states and the necessary hook
for PCI devices.  This hook should be called twice, before and after
changing the power state of a PCI device.

Before setting the device to the new state, the ACPI layer will notify
every power resources linked to the device for that state and make sure
they are turned "_ON".  After changing the state of the device, it will
decrement the reference of every power resources linked to that device
for the old state and turn them "_OFF" if they are no longer referenced.

This fixes the no-USB after resume problem seen on various ThinkPad,
problem initialy diagnosed with Alexander Polakov.

ok kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.57 2013/05/30 16:19:25 deraadt Exp $	*/
d378 2
a379 3
	if (pci_get_capability(pc, tag, PCI_CAP_MSI, &off, &reg) == 0)
		panic("%s: no msi capability", __func__);
	pci_conf_write(pc, tag, off, reg & ~PCI_MSI_MC_MSIE);
@


1.57
log
@If ACPI is not compiled in, pci_min_powerstate() has no facts to support
is should return D3.  It should return the current power state.
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.56 2012/10/16 13:57:46 mikeb Exp $	*/
d668 2
a679 4
#if NACPI > 0
pcireg_t acpi_pci_min_powerstate(pci_chipset_tag_t, pcitag_t);
#endif

d687 8
@


1.56
log
@Change the PCI memory extent to cover the whole 64-bit memory space
but reserve everything above 36 bits so that the erroneous extent
allocation will fail but not panic the system.  Fixes the notorious
IBM x3100 panic where one of the PCI BARs is programmed with an
incorrect 64 bit address.

Idea and OK kettenis@@, tested by Walter Souza, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.55 2012/09/19 23:23:50 kettenis Exp $	*/
d688 1
a688 1
	return PCI_PMCSR_STATE_D3;
@


1.55
log
@Set up PCI bus number resource accounting for the main PCI bus hierarchy.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.54 2012/09/07 19:21:57 kettenis Exp $	*/
d627 2
a628 2
		pcimem_ex = extent_create("pcimem", 0, 0xfffffffff, M_DEVBUF,
		    NULL, 0, EX_NOWAIT);
d631 2
@


1.54
log
@Implement pci_min_powerstate().
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.53 2011/10/29 19:17:30 kettenis Exp $	*/
d598 1
d655 5
@


1.53
log
@Make sure we don't accidentally use ISA or EISA interrupt mappings on PCI
busses.

tested by krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.52 2011/10/13 09:44:40 kettenis Exp $	*/
d667 14
@


1.52
log
@I'm sick and tired of people doing misalgned reads and writes to PCI config
space and not noticing because they only test on amd64.  So enforce alignment
there as well, at least for a little while such that we find those bugs and
force people to fix them.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.51 2011/06/18 17:28:18 kettenis Exp $	*/
d405 1
a406 1
	int mppin;
d425 1
d427 13
a439 4
		mppin = (dev << 2)|(pin - 1);
		if (intr_find_mpmapping(bus, mppin, &ihp->line) == 0) {
			ihp->line |= line;
			return 0;
d441 1
d485 8
a492 4
		if (mp_isa_bus != NULL &&
		    intr_find_mpmapping(mp_isa_bus->mb_idx, line, &ihp->line) == 0) {
			ihp->line |= line;
			return 0;
d495 8
a502 4
		if (mp_eisa_bus != NULL &&
		    intr_find_mpmapping(mp_eisa_bus->mb_idx, line, &ihp->line) == 0) {
			ihp->line |= line;
			return 0;
d505 6
a510 3
		printf("pci_intr_map: bus %d dev %d func %d pin %d; line %d\n",
		    bus, dev, func, pin, line);
		printf("pci_intr_map: no MP mapping found\n");
@


1.51
log
@Cleanup MSI code a bit by moving the code to eanble/disable MSIs into
separate functions and install them as route/unroute functions for the
MIS pseudo-PIC.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.50 2011/06/16 22:20:39 kettenis Exp $	*/
d272 2
d297 2
@


1.50
log
@QEMU pretends to emulate a different prehistoric Intel host bridge.

From Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.49 2011/06/05 18:09:00 kettenis Exp $	*/
d315 2
a316 1
void msi_setup(struct pic *, struct cpu_info *, int, int, int);
d326 2
a327 2
	msi_setup,
	msi_setup,
d343 1
a343 1
msi_setup(struct pic *pic, struct cpu_info *ci, int pin, int idtvec, int type)
d345 32
d534 1
a534 9
		struct intrhand *ih;
		struct intrsource *source;
		pcireg_t reg, addr;
		int off, vec;

		if (pci_get_capability(pc, tag, PCI_CAP_MSI, &off, &reg) == 0)
			panic("%s: no msi capability", __func__);

		ih = intr_establish(-1, &msi_pic, tag, IST_PULSE, level,
a535 17
		if (ih == NULL)
			return (NULL);

		source = ih->ih_cpu->ci_isources[ih->ih_slot];
		addr = 0xfee00000UL | (ih->ih_cpu->ci_apicid << 12);
		vec = source->is_idtvec;

		if (reg & PCI_MSI_MC_C64) {
			pci_conf_write(pc, tag, off + PCI_MSI_MA, addr);
			pci_conf_write(pc, tag, off + PCI_MSI_MAU32, 0);
			pci_conf_write(pc, tag, off + PCI_MSI_MD64, vec);
		} else {
			pci_conf_write(pc, tag, off + PCI_MSI_MA, addr);
			pci_conf_write(pc, tag, off + PCI_MSI_MD32, vec);
		}
		pci_conf_write(pc, tag, off, reg | PCI_MSI_MC_MSIE);
		return (ih);
a566 17
	struct intrhand *ih = cookie;
	struct cpu_info *ci;
	struct pic *pic;

	ci = ih->ih_cpu;
	pic = ci->ci_isources[ih->ih_slot]->is_pic;

	if (pic == &msi_pic) {
		pcitag_t tag = ih->ih_pin;
		pcireg_t reg;
		int off;

		if (pci_get_capability(pc, tag, PCI_CAP_MSI, &off, &reg) == 0)
			panic("%s: no msi capability", __func__);
		pci_conf_write(pc, tag, off, reg & ~PCI_MSI_MC_MSIE);
	}

@


1.49
log
@Disable MSIs in pci_intr_disestablish() when appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.48 2011/06/05 10:07:30 kettenis Exp $	*/
d181 4
a184 3
		 * In the land of VMWare you can have the latest
		 * 64-bit AMD multicore CPU behind a prehistoric Intel
		 * host bridge.  Give them what they deserve.
d187 2
a188 1
		case PCI_PRODUCT_INTEL_82443BX:
@


1.48
log
@Direct MSIs at the appropriate CPU.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.47 2011/06/02 19:59:00 kettenis Exp $	*/
d557 17
@


1.47
log
@In the land of VMWare you can have the latest 64-bit AMD multicore CPU
behind a prehistoric Intel host bridge.  Disable MSI on these contortion.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.46 2011/05/30 19:27:40 kettenis Exp $	*/
d501 1
a501 1
		pcireg_t reg;
d513 1
d517 1
a517 1
			pci_conf_write(pc, tag, off + PCI_MSI_MA, 0xfee00000);
d521 1
a521 1
			pci_conf_write(pc, tag, off + PCI_MSI_MA, 0xfee00000);
@


1.46
log
@Enable MSI on selected hardware.  For now this means all Intel, AMD and NVIDIA
chipsets.  All of those that support 64-bit CPUs should support MSI as well.

Explicitly disable MSI on chipsets that connect to the CPU over HyperTransport.
Enabling MSI on those systems is handled by the HyperTransport support code
in our PCI subsystem.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.45 2011/05/29 10:47:42 kettenis Exp $	*/
d180 13
@


1.45
log
@Don't attempt to use MSI if we're not running in APIC mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.44 2011/05/21 15:58:27 kettenis Exp $	*/
d154 43
@


1.44
log
@First stab at suporting Message Signaled Interrupts on amd64.  Unfortunately
this code differs somewhat from the i386 code because the amd64 interrupt
subsystem is quite different.  Still disabled like on i386.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.43 2011/04/22 15:02:35 kettenis Exp $	*/
d294 1
a294 1
	if ((pa->pa_flags & PCI_FLAGS_MSI_ENABLED) == 0 ||
@


1.43
log
@Stop printing the PCI interrupt line programmed by the BIOS for APIC
interrupts.  It is irreleveant, confuses people and the information is
available in pcidump(8) output anyway.

ok oga@@, jsg@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.42 2011/04/10 16:40:42 kettenis Exp $	*/
d255 49
d412 3
d439 1
d441 29
@


1.42
log
@Extend the PCI memory address space to 36-bit.  The first BIOSen that assign
addresses >4GB to 64-bit BARs have started to appear.  But as long as machines
still support running 32-bit operating systems we don't expect to see BARs
that aren't addressable using PAE.  Fixes a panic reported by william@@.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.41 2011/04/02 18:16:50 oga Exp $	*/
d365 2
a366 4
		snprintf(irqstr, sizeof(irqstr), "apic %d int %d (irq %d)",
		    APIC_IRQ_APIC(ih.line),
		    APIC_IRQ_PIN(ih.line),
		    pci_intr_line(pc, ih));
@


1.41
log
@Remove the AMD GART based iommu code.

With current strategies to put memory in the ``correct'' place it isn't
needed.  There's also the problem that it did not work on all machines,
failing completely on some and utterly breaking DMA. So just remove it.
If anyone needs it it will be in the Attic.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.40 2011/01/10 16:26:27 kettenis Exp $	*/
d447 7
a453 1
		pcimem_ex = extent_create("pcimem", 0, 0xffffffff, M_DEVBUF,
@


1.40
log
@Only use MMCFG extended PCIe config space.  Gets us back the on-CPU PCI devices on AMD Family 0Fh processors.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.39 2011/01/09 11:38:10 kettenis Exp $	*/
a149 2
extern void amdgart_probe(struct pcibus_attach_args *);

a153 4
#ifndef SMALL_KERNEL
	if (pba->pba_bus == 0)
		amdgart_probe(pba);
#endif /* !SMALL_KERNEL */
@


1.39
log
@Only use memory mapped extended PCIe config space access for the busses
advertised in the MCFG table, and fall back on the traditional method for
other busses.  Fixes issue reported by henning@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.38 2011/01/04 21:17:49 kettenis Exp $	*/
d220 1
a220 1
	if (pci_mcfg_addr) {
d244 1
a244 1
	if (pci_mcfg_addr) {
@


1.38
log
@Add support for Memory Mapped Configuration space access.  This gives us
access to PCIe extended configuration space access on modern i386 and amd64
machines.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.37 2010/12/04 17:06:31 miod Exp $	*/
d111 1
a173 8
	if (pci_mcfg_addr) {
		if (bus < pci_mcfg_min_bus  || bus > pci_mcfg_max_bus ||
		    device >= 32 || function >= 8)
			panic("pci_make_tag: bad request");

		return (bus << 20) | (device << 15) | (function << 12);
	}

a180 10
	if (pci_mcfg_addr) {
		if (bp != NULL)
			*bp = (tag >> 20) & 0xff;
		if (dp != NULL)
			*dp = (tag >> 15) & 0x1f;
		if (fp != NULL)
			*fp = (tag >> 12) & 0x7;
		return;
	}

d192 7
a198 2
	if (pci_mcfg_addr)
		return PCIE_CONFIG_SPACE_SIZE;
d203 11
d222 6
a227 6
		if (pci_mcfgh[bus] == 0 &&
		    bus_space_map(pci_mcfgt, pci_mcfg_addr + (bus << 20),
		    1 << 20, 0, &pci_mcfgh[bus]))
			panic("pci_conf_read: cannot map mcfg space");
		return  bus_space_read_4(pci_mcfgt, pci_mcfgh[bus],
		    (tag & 0x000ff000) | reg);
d246 6
a251 7
		if (pci_mcfgh[bus] == 0 &&
		    bus_space_map(pci_mcfgt, pci_mcfg_addr + (bus << 20),
		    1 << 20, 0, &pci_mcfgh[bus]))
			panic("pci_conf_write: cannot map mcfg space");
		bus_space_write_4(pci_mcfgt, pci_mcfgh[bus],
		    (tag & 0x000ff000) | reg, data);
		return;
@


1.37
log
@Introduce a new pci routine, pci_conf_size(), which returns the size of a
given pcitag_t configuration address space. Currently, all pci controllers
will return the usual 0x100 bytes of PCI configuration space, but this will
eventually change on PCIe-capable controlers.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.36 2010/09/06 19:05:48 kettenis Exp $	*/
d99 13
d173 8
d188 10
d209 3
d219 11
d243 13
@


1.36
log
@Make sure bus_dmamap_sync() always involves a function call, to prevent the
compiler from doing stupid things like reordering stores around it.  There is
some debate whether this will be enough for newer versions of GCC and LLVM.
If this is indeed deemed necessary, this will be addressed in a future diff.

ok miod@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.35 2010/07/08 20:56:31 jordan Exp $	*/
d173 6
@


1.35
log
@Add mapping for ACPI device to PCI bdf (match autoconf tree)
Simplify resource parsing function to use buffer argument
Convert namespace linked lists to use queue macros
ok marco@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.34 2010/07/01 06:29:32 jordan Exp $	*/
d128 1
a128 1
	NULL,
@


1.34
log
@Backout recent AML changes, breaks on R210 and others
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.33 2010/06/29 22:08:29 jordan Exp $	*/
d431 1
a431 1
	//acpi_pci_match(dev, pa);
@


1.33
log
@Add support for mapping ACPI to PCI devices
ok kettenis, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.32 2009/09/28 15:58:30 kettenis Exp $	*/
d431 1
a431 1
	acpi_pci_match(dev, pa);
@


1.32
log
@Make video buffer area and BIOS areas unavailable for PCI resource allocation.
This should prevent problems on systems where these areas are not reserved in
the BIOS memory map.

ok miod@@, oga@@, marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.31 2009/08/22 02:54:50 mk Exp $	*/
d420 13
@


1.31
log
@Constify the what/name parameter of pci_intr_establish().

Tested by myself, sthen, oga, kettenis, and jasper.
Input from sthen and jasper.

ok kettenis

(Manpage follows shortly.)
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.30 2009/07/20 23:40:43 miod Exp $	*/
d415 4
@


1.30
log
@Pass a pci_chipset_tag_t to pci_intr_line(), to eventually allow the
logic to be chipset dependent; no functional change yet.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.29 2009/04/29 18:28:38 kettenis Exp $	*/
d329 1
a329 1
    int (*func)(void *), void *arg, char *what)
@


1.29
log
@Extend pciio extents to cover the while 32-bit address space.  The processor
can only address the first 64K but BARs can contain garbage and addresses
beyond the end of the extent would cause a panic.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.28 2009/04/21 19:18:09 kettenis Exp $	*/
d312 1
a312 1
		    pci_intr_line(ih));
d314 2
a315 1
		snprintf(irqstr, sizeof(irqstr), "irq %d", pci_intr_line(ih));
d317 1
a317 1
	snprintf(irqstr, sizeof(irqstr), "irq %d", pci_intr_line(ih));
@


1.28
log
@Simplify PCI config space access code.  There is no way we're ever going to
see the ancient mode 2 on machines capable of running OpenBSD/amd64.

ok deraadt@@, toby@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.27 2009/04/21 17:05:29 oga Exp $	*/
d375 13
a387 3
	if (pciio_ex == NULL)
		pciio_ex = extent_create("pciio", 0, 0xffff, M_DEVBUF,
		    NULL, 0, EX_NOWAIT);
@


1.27
log
@add a sg_dma backend for amd64 bus_dma. This is a lot more clever about
mapping to the gart than the old code, and shouldn't conflict with
bouncebuffers when they're added.

This is essentially the sparc64 iommu code that's been modularised a bit
so I can eventually use the same code for agp-based dma for memory
managed drm drivers.

Now, this would overflow ramdiskA, so iommu and sg_dma are now #ifndef
SMALL_KERNEL.

ok kettenis@@, marco@@. SMALL_KERNEL discussions with deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.26 2009/04/13 21:23:16 kettenis Exp $	*/
a65 8
 *
 * On PCs, there are two methods of generating PCI configuration cycles.
 * We try to detect the appropriate mechanism for this machine and set
 * up a few function pointers to access the correct method directly.
 *
 * The configuration method can be hard-coded in the config file by
 * using `options PCI_CONF_MODE=N', where `N' is the configuration mode
 * as defined section 3.6.4.1, `Generating Configuration Cycles'.
a98 2
int pci_mode = -1;

a114 24
#define	PCI_MODE2_ENABLE_REG	0x0cf8
#define	PCI_MODE2_FORWARD_REG	0x0cfa

#define _m1tag(b, d, f) \
	(PCI_MODE1_ENABLE | ((b) << 16) | ((d) << 11) | ((f) << 8))
#define _qe(bus, dev, fcn, vend, prod) \
	{_m1tag(bus, dev, fcn), PCI_ID_CODE(vend, prod)}
struct {
	u_int32_t tag;
	pcireg_t id;
} pcim1_quirk_tbl[] = {
	_qe(0, 0, 0, PCI_VENDOR_COMPAQ, PCI_PRODUCT_COMPAQ_TRIFLEX1),
	/* XXX Triflex2 not tested */
	_qe(0, 0, 0, PCI_VENDOR_COMPAQ, PCI_PRODUCT_COMPAQ_TRIFLEX2),
	_qe(0, 0, 0, PCI_VENDOR_COMPAQ, PCI_PRODUCT_COMPAQ_TRIFLEX4),
	/* Triton needed for Connectix Virtual PC */
	_qe(0, 0, 0, PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82437FX),
	/* Connectix Virtual PC 5 has a 440BX */
	_qe(0, 0, 0, PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82443BX_NOAGP),
	{0, 0xffffffff} /* patchable */
};
#undef _m1tag
#undef _qe

a141 2
	if (pba->pba_bus == 0) {
		printf(": configuration mode %d", pci_mode);
d143 1
a145 1
	}
d151 1
a151 11

	/*
	 * Bus number is irrelevant.  If Configuration Mechanism 2 is in
	 * use, can only have devices 0-15 on any bus.  If Configuration
	 * Mechanism 1 is in use, can have devices 0-32 (i.e. the `normal'
	 * range).
	 */
	if (pci_mode == 2)
		return (16);
	else
		return (32);
d157 2
a158 21
	pcitag_t tag;

	switch (pci_mode) {
	case 1:
		if (bus >= 256 || device >= 32 || function >= 8)
			panic("pci_make_tag: bad request");

		tag.mode1 = PCI_MODE1_ENABLE |
		    	(bus << 16) | (device << 11) | (function << 8);
		break;
	case 2:
		if (bus >= 256 || device >= 16 || function >= 8)
			panic("pci_make_tag: bad request");

		tag.mode2.port = 0xc000 | (device << 8);
		tag.mode2.enable = 0xf0 | (function << 1);
		tag.mode2.forward = bus;
		break;
	default:
		panic("pci_make_tag: mode not configured");
	}
d160 2
a161 1
	return tag;
d167 6
a172 21

	switch (pci_mode) {
	case 1:
		if (bp != NULL)
			*bp = (tag.mode1 >> 16) & 0xff;
		if (dp != NULL)
			*dp = (tag.mode1 >> 11) & 0x1f;
		if (fp != NULL)
			*fp = (tag.mode1 >> 8) & 0x7;
		break;
	case 2:
		if (bp != NULL)
			*bp = tag.mode2.forward & 0xff;
		if (dp != NULL)
			*dp = (tag.mode2.port >> 8) & 0xf;
		if (fp != NULL)
			*fp = (tag.mode2.enable >> 1) & 0x7;
		break;
	default:
		panic("pci_decompose_tag: mode not configured");
	}
d181 3
a183 15
	switch (pci_mode) {
	case 1:
		outl(PCI_MODE1_ADDRESS_REG, tag.mode1 | reg);
		data = inl(PCI_MODE1_DATA_REG);
		outl(PCI_MODE1_ADDRESS_REG, 0);
		break;
	case 2:
		outb(PCI_MODE2_ENABLE_REG, tag.mode2.enable);
		outb(PCI_MODE2_FORWARD_REG, tag.mode2.forward);
		data = inl(tag.mode2.port | reg);
		outb(PCI_MODE2_ENABLE_REG, 0);
		break;
	default:
		panic("pci_conf_read: mode not configured");
	}
a191 1

d193 3
a195 15
	switch (pci_mode) {
	case 1:
		outl(PCI_MODE1_ADDRESS_REG, tag.mode1 | reg);
		outl(PCI_MODE1_DATA_REG, data);
		outl(PCI_MODE1_ADDRESS_REG, 0);
		break;
	case 2:
		outb(PCI_MODE2_ENABLE_REG, tag.mode2.enable);
		outb(PCI_MODE2_FORWARD_REG, tag.mode2.forward);
		outl(tag.mode2.port | reg, data);
		outb(PCI_MODE2_ENABLE_REG, 0);
		break;
	default:
		panic("pci_conf_write: mode not configured");
	}
a196 88
}

int
pci_mode_detect(void)
{

#ifdef PCI_CONF_MODE
#if (PCI_CONF_MODE == 1) || (PCI_CONF_MODE == 2)
	return (pci_mode = PCI_CONF_MODE);
#else
#error Invalid PCI configuration mode.
#endif
#else
	u_int32_t sav, val;
	int i;
	pcireg_t idreg;

	if (pci_mode != -1)
		return pci_mode;

	/*
	 * We try to divine which configuration mode the host bridge wants.
	 */

	sav = inl(PCI_MODE1_ADDRESS_REG);

	pci_mode = 1; /* assume this for now */
	/*
	 * catch some known buggy implementations of mode 1
	 */
	for (i = 0; i < sizeof(pcim1_quirk_tbl) / sizeof(pcim1_quirk_tbl[0]);
	     i++) {
		pcitag_t t;

		if (!pcim1_quirk_tbl[i].tag)
			break;
		t.mode1 = pcim1_quirk_tbl[i].tag;
		idreg = pci_conf_read(0, t, PCI_ID_REG); /* needs "pci_mode" */
		if (idreg == pcim1_quirk_tbl[i].id) {
#ifdef DEBUG
			printf("known mode 1 PCI chipset (%08x)\n",
			       idreg);
#endif
			return (pci_mode);
		}
	}

	/*
	 * Strong check for standard compliant mode 1:
	 * 1. bit 31 ("enable") can be set
	 * 2. byte/word access does not affect register
	 */
	outl(PCI_MODE1_ADDRESS_REG, PCI_MODE1_ENABLE);
	outb(PCI_MODE1_ADDRESS_REG + 3, 0);
	outw(PCI_MODE1_ADDRESS_REG + 2, 0);
	val = inl(PCI_MODE1_ADDRESS_REG);
	if ((val & 0x80fffffc) != PCI_MODE1_ENABLE) {
#ifdef DEBUG
		printf("pci_mode_detect: mode 1 enable failed (%x)\n",
		       val);
#endif
		goto not1;
	}
	outl(PCI_MODE1_ADDRESS_REG, 0);
	val = inl(PCI_MODE1_ADDRESS_REG);
	if ((val & 0x80fffffc) != 0)
		goto not1;
	return (pci_mode);
not1:
	outl(PCI_MODE1_ADDRESS_REG, sav);

	/*
	 * This mode 2 check is quite weak (and known to give false
	 * positives on some Compaq machines).
	 * However, this doesn't matter, because this is the
	 * last test, and simply no PCI devices will be found if
	 * this happens.
	 */
	outb(PCI_MODE2_ENABLE_REG, 0);
	outb(PCI_MODE2_FORWARD_REG, 0);
	if (inb(PCI_MODE2_ENABLE_REG) != 0 ||
	    inb(PCI_MODE2_FORWARD_REG) != 0)
		goto not2;
	return (pci_mode = 2);
not2:

	return (pci_mode = 0);
#endif
@


1.26
log
@Ignore zero-sized regions from the BIOS memory map when reserving root PCI
bus address space.  Fixes a problem reported by david@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.25 2009/04/11 17:13:33 kettenis Exp $	*/
d178 1
d180 1
@


1.25
log
@Create extents for resource accounting on the root PCI bus and populate them
based on the BIOS memory map.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.24 2009/04/04 16:03:17 kettenis Exp $	*/
d584 4
@


1.24
log
@Remove an unused function inherited from NetBSD that deals with a broken
SiS chipset that we'll never see on and amd64 machine.

ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.23 2009/04/04 15:08:05 kettenis Exp $	*/
d82 2
d91 1
d554 37
@


1.23
log
@Remove unused #include.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.22 2009/03/10 15:03:17 oga Exp $	*/
a550 45
}

/*
 * Determine which flags should be passed to the primary PCI bus's
 * autoconfiguration node.  We use this to detect broken chipsets
 * which cannot safely use memory-mapped device access.
 */
int
pci_bus_flags(void)
{
	int rval = PCI_FLAGS_IO_ENABLED | PCI_FLAGS_MEM_ENABLED;
	int device, maxndevs;
	pcitag_t tag;
	pcireg_t id;

	maxndevs = pci_bus_maxdevs(NULL, 0);

	for (device = 0; device < maxndevs; device++) {
		tag = pci_make_tag(NULL, 0, device, 0);
		id = pci_conf_read(NULL, tag, PCI_ID_REG);

		/* Invalid vendor ID value? */
		if (PCI_VENDOR(id) == PCI_VENDOR_INVALID)
			continue;
		/* XXX Not invalid, but we've done this ~forever. */
		if (PCI_VENDOR(id) == 0)
			continue;

		switch (PCI_VENDOR(id)) {
		case PCI_VENDOR_SIS:
			switch (PCI_PRODUCT(id)) {
			case PCI_PRODUCT_SIS_85C496:
				goto disable_mem;
			}
			break;
		}
	}

	return (rval);

 disable_mem:
	printf("Warning: broken PCI-Host bridge detected; "
	    "disabling memory-mapped access\n");
	rval &= ~(PCI_FLAGS_MEM_ENABLED);
	return (rval);
@


1.22
log
@remove the _BUS_DMA_PRIVATE define from amd64 and i386.

a define needed to get to ``private'' functions that needs to be defined
5 or more times isn't much use and may cause namespace issues anyway.
Other archs will probably follow.

Discussed in portugal.  "Hell yes" weingart@@, ok kettenis@@, no
objections miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.21 2009/01/27 15:33:59 oga Exp $	*/
a81 1
#include <sys/lock.h>
@


1.21
log
@Switch the amd64 PCI_CONF_LOCK from being a simplelock and splhigh to a
mutex with ipl set to IPL_HIGH. While i'm here, unify the code with
i386, by giving the same lock to the i386 code.

This lock is mostly for MP, but could actually prevent a race where a
process is doing pci_conf_{read,write}, and then an interrupt fire and
also does pci_conf_{read,write}. Since this is a two stage process, the
interrupt could race with the one, causing the value to the written to
the wrong place, or the wrong value to be written.

Tested by many. "go ahead" kettenis@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.20 2008/12/28 18:26:53 kettenis Exp $	*/
a85 1
#define _BUS_DMA_PRIVATE
@


1.20
log
@Remove confusion between "raw" and "swizzled" interrupt pins.  Remove some
#ifdef __i386__ code that can go now things have been cleaned up.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.19 2008/12/07 14:33:26 kettenis Exp $	*/
d108 1
a108 5
#if defined(MULTIPROCESSOR) && 0
struct simplelock pci_conf_slock = SIMPLELOCK_INITIALIZER;
#else
struct simplelock pci_conf_slock = { 0 };
#endif
d110 1
a110 1
#define	PCI_CONF_LOCK(s)						\
d112 1
a112 2
	(s) = splhigh();						\
	simple_lock(&pci_conf_slock);					\
d115 1
a115 1
#define	PCI_CONF_UNLOCK(s)						\
d117 1
a117 2
	simple_unlock(&pci_conf_slock);					\
	splx((s));							\
a254 1
	int s;
d256 1
a256 1
	PCI_CONF_LOCK(s);
d272 1
a272 1
	PCI_CONF_UNLOCK(s);
a279 1
	int s;
d281 1
a281 1
	PCI_CONF_LOCK(s);
d297 1
a297 1
	PCI_CONF_UNLOCK(s);
@


1.19
log
@Make acpiprt(4) check whether the current interrupt routing is "possible" and
pick a new one from the list of possible routings if it isn't or if a pin is
currently not routed.  Delay re-routing interrupts until we establish a
handler for it.  This prevents us from messing with unused interrupt pins
which may have fatal consequences (some machines spontaniously reboot).

The heuristics for picking an interrupt from the list of possibe ones
probably needs some tweaking still, but this makes several NVIDIA-based
boards work much better than before.

tested by many, ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.18 2008/12/06 19:59:38 tedu Exp $	*/
d399 1
a399 1
	int pin = pa->pa_intrpin;
a400 1
	int rawpin = pa->pa_rawintrpin;
a401 1
	pci_chipset_tag_t pc = pa->pa_pc;
d418 1
a418 1
	ihp->pin = rawpin;
d421 1
a421 1
	pci_decompose_tag(pc, pa->pa_tag, &bus, &dev, &func);
d423 1
a423 1
		mppin = (dev << 2)|(rawpin - 1);
d429 3
a431 3
			int pin = PPB_INTERRUPT_SWIZZLE(rawpin, dev);
			if (pa->pa_bridgeih[pin - 1].line != -1) {
				ihp->line = pa->pa_bridgeih[pin - 1].line;
@


1.18
log
@revert all changes related to the mpsafe intr handler.  i screwed up the commit
and even then it didn't work.  we have higher standards than this.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.17 2008/12/06 05:08:02 tedu Exp $	*/
d520 5
d530 1
d532 5
@


1.17
log
@cvs wouldn't let me check this in before
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.16 2008/12/03 15:46:06 oga Exp $	*/
d521 2
a522 2
pci_intr_establish_flags(pci_chipset_tag_t pc, pci_intr_handle_t ih, int level,
    int (*func)(void *), void *arg, char *what, int flags)
d545 1
a545 2
	return intr_establish(irq, pic, pin, IST_LEVEL, level, func, arg, what,
	    flags);
@


1.16
log
@Remove the x86 and i386 prefixes to the bus_dma types. It's really quite
pointless and just makes the code different for no reason. This moves i386 and
amd64 bus_dma to being a lot closer to identical.

suggestion to just remove the prefix instead of merge them from deraadt@@.

no objections art@@, kettenis@@, ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.15 2008/11/26 12:27:31 kettenis Exp $	*/
d521 2
a522 2
pci_intr_establish(pci_chipset_tag_t pc, pci_intr_handle_t ih, int level,
    int (*func)(void *), void *arg, char *what)
d545 2
a546 1
	return intr_establish(irq, pic, pin, IST_LEVEL, level, func, arg, what);
@


1.15
log
@Change pci_intr_handle_t to be like i386 where it is a struct that stores the
tag and pin.  Reduces the differences between the two architectures and I need
it to fix acpiprt(4)-based interrupt routing.

ok toby@@, jordan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.14 2008/06/26 05:42:09 ray Exp $	*/
d86 1
a86 1
#define _X86_BUS_DMA_PRIVATE
d158 1
a158 1
struct x86_bus_dma_tag pci_bus_dma_tag = {
@


1.14
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.13 2007/08/08 18:54:29 kettenis Exp $	*/
d401 1
a402 1
	int rawpin = pa->pa_rawintrpin;
d418 4
d426 2
a427 2
		if (intr_find_mpmapping(bus, mppin, ihp) == 0) {
			*ihp |= line;
d432 3
a434 3
			if (pa->pa_bridgeih[pin - 1] != -1) {
				*ihp = pa->pa_bridgeih[pin - 1];
				*ihp |= line;
d474 2
a475 2
		    intr_find_mpmapping(mp_isa_bus->mb_idx, line, ihp) == 0) {
			*ihp |= line;
d480 2
a481 2
		    intr_find_mpmapping(mp_eisa_bus->mb_idx, line, ihp) == 0) {
			*ihp |= line;
a490 1
	*ihp = line;
d494 1
a494 1
	*ihp = -1;
d503 2
a504 3
	if (ih == 0)
		panic("pci_intr_string: bogus handle 0x%x", ih);

d507 1
a507 1
	if (ih & APIC_INT_VIA_APIC)
d509 3
a511 3
		    APIC_IRQ_APIC(ih),
		    APIC_IRQ_PIN(ih),
		    ih&0xff);
d513 1
a513 1
		snprintf(irqstr, sizeof(irqstr), "irq %d", ih&0xff);
d515 1
a515 2

	snprintf(irqstr, sizeof(irqstr), "irq %d", ih&0xff);
a517 1

d528 1
a528 1
	pin = irq = ih;
d531 2
a532 2
	if (ih & APIC_INT_VIA_APIC) {
		pic = (struct pic *)ioapic_find(APIC_IRQ_APIC(ih));
d535 1
a535 1
			    APIC_IRQ_APIC(ih));
d538 2
a539 2
		pin = APIC_IRQ_PIN(ih);
		irq = APIC_IRQ_LEGACY_IRQ(ih);
a597 1

@


1.13
log
@Prevent a potential null-pointer dereference.

ok krw@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.12 2007/05/21 22:10:45 kettenis Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.12
log
@Implement deep interrupt swizzling by mapping all four PCI interrupt pins
for PCI-PCI bridges and passing the mapping to the attached bus device.
MD code can use these when mapping PCI device interrupts.  This diff adds
such code for amd64 and i386.  This fixes interrupt mapping for devices that
sit behind two PCI-PCI bridges where the firmware only provides a mapping
for the first PCI-PCI bridge.

tested by sturm@@, krw@@, and a few others, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.11 2007/01/15 23:19:05 jsg Exp $	*/
d476 2
a477 1
		if (intr_find_mpmapping(mp_isa_bus->mb_idx, line, ihp) == 0) {
d482 2
a483 1
		if (intr_find_mpmapping(mp_eisa_bus->mb_idx, line, ihp) == 0) {
@


1.11
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.10 2006/12/14 17:14:01 kettenis Exp $	*/
d104 1
d434 3
a436 6
			int bridgebus, bridgedev;

			pci_decompose_tag(pc, *pa->pa_bridgetag,
			    &bridgebus, &bridgedev, NULL);
			mppin = (bridgedev << 2)|((rawpin + dev - 1) & 0x3);
			if (intr_find_mpmapping(bridgebus, mppin, ihp) == 0) {
d462 5
a466 3
	if (line == 0 || line == X86_PCI_INTERRUPT_LINE_NO_CONNECTION) {
		printf("pci_intr_map: no mapping for pin %c (line=%02x)\n",
		       '@@' + pin, line);
a467 9
	} else {
		if (line >= NUM_LEGACY_IRQS) {
			printf("pci_intr_map: bad interrupt line %d\n", line);
			goto bad;
		}
		if (line == 2) {
			printf("pci_intr_map: changed line 2 to line 9\n");
			line = 9;
		}
d469 5
@


1.10
log
@Swizzle interrupts for devices for which we don't have explicit inetrrupt
routing information.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.9 2006/11/25 16:59:31 niklas Exp $	*/
d184 2
a185 3
pci_attach_hook(parent, self, pba)
	struct device *parent, *self;
	struct pcibus_attach_args *pba;
d194 1
a194 3
pci_bus_maxdevs(pc, busno)
	pci_chipset_tag_t pc;
	int busno;
d210 1
a210 3
pci_make_tag(pc, bus, device, function)
	pci_chipset_tag_t pc;
	int bus, device, function;
d238 1
a238 4
pci_decompose_tag(pc, tag, bp, dp, fp)
	pci_chipset_tag_t pc;
	pcitag_t tag;
	int *bp, *dp, *fp;
d264 1
a264 4
pci_conf_read(pc, tag, reg)
	pci_chipset_tag_t pc;
	pcitag_t tag;
	int reg;
d291 1
a291 5
pci_conf_write(pc, tag, reg, data)
	pci_chipset_tag_t pc;
	pcitag_t tag;
	int reg;
	pcireg_t data;
d315 1
a315 1
pci_mode_detect()
d403 1
a403 3
pci_intr_map(pa, ihp)
	struct pci_attach_args *pa;
	pci_intr_handle_t *ihp;
d505 1
a505 3
pci_intr_string(pc, ih)
	pci_chipset_tag_t pc;
	pci_intr_handle_t ih;
d530 2
a531 6
pci_intr_establish(pc, ih, level, func, arg, what)
	pci_chipset_tag_t pc;
	pci_intr_handle_t ih;
	int level, (*func)(void *);
	void *arg;
	char *what;
d558 1
a558 3
pci_intr_disestablish(pc, cookie)
	pci_chipset_tag_t pc;
	void *cookie;
a559 1

d569 1
a569 1
pci_bus_flags()
@


1.9
log
@sync amd64 to i386 w.r.t. acpi support. Also fix interrupt routing for multi-ioapic systems.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.8 2006/05/31 06:13:48 weingart Exp $	*/
d428 1
d444 2
a445 1
		if (intr_find_mpmapping(bus, (dev<<2)|(rawpin-1), ihp) == 0) {
d448 11
@


1.8
log
@Reorg the code to be more sane.  More coming.
ok brad@@ jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.7 2005/09/04 19:19:40 brad Exp $	*/
d484 1
a484 1
		if (intr_find_mpmapping(mp_isa_bus, line, ihp) == 0) {
d489 1
a489 1
		if (intr_find_mpmapping(mp_eisa_bus, line, ihp) == 0) {
@


1.7
log
@remove unused NetBSD pci_intr_evcnt() function.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.6 2005/06/25 21:00:56 brad Exp $	*/
a218 1
#ifndef PCI_CONF_MODE
d221 6
a226 1
		goto mode1;
d228 7
a234 1
		goto mode2;
a237 8
#endif

#if !defined(PCI_CONF_MODE) || (PCI_CONF_MODE == 1)
#ifndef PCI_CONF_MODE
mode1:
#endif
	if (bus >= 256 || device >= 32 || function >= 8)
		panic("pci_make_tag: bad request");
a238 2
	tag.mode1 = PCI_MODE1_ENABLE |
		    (bus << 16) | (device << 11) | (function << 8);
a239 14
#endif

#if !defined(PCI_CONF_MODE) || (PCI_CONF_MODE == 2)
#ifndef PCI_CONF_MODE
mode2:
#endif
	if (bus >= 256 || device >= 16 || function >= 8)
		panic("pci_make_tag: bad request");

	tag.mode2.port = 0xc000 | (device << 8);
	tag.mode2.enable = 0xf0 | (function << 1);
	tag.mode2.forward = bus;
	return tag;
#endif
a248 1
#ifndef PCI_CONF_MODE
d251 7
a257 1
		goto mode1;
d259 7
a265 1
		goto mode2;
a268 26
#endif

#if !defined(PCI_CONF_MODE) || (PCI_CONF_MODE == 1)
#ifndef PCI_CONF_MODE
mode1:
#endif
	if (bp != NULL)
		*bp = (tag.mode1 >> 16) & 0xff;
	if (dp != NULL)
		*dp = (tag.mode1 >> 11) & 0x1f;
	if (fp != NULL)
		*fp = (tag.mode1 >> 8) & 0x7;
	return;
#endif

#if !defined(PCI_CONF_MODE) || (PCI_CONF_MODE == 2)
#ifndef PCI_CONF_MODE
mode2:
#endif
	if (bp != NULL)
		*bp = tag.mode2.forward & 0xff;
	if (dp != NULL)
		*dp = (tag.mode2.port >> 8) & 0xf;
	if (fp != NULL)
		*fp = (tag.mode2.enable >> 1) & 0x7;
#endif
d280 1
a280 1
#ifndef PCI_CONF_MODE
d283 4
a286 1
		goto mode1;
d288 5
a292 1
		goto mode2;
a295 10
#endif

#if !defined(PCI_CONF_MODE) || (PCI_CONF_MODE == 1)
#ifndef PCI_CONF_MODE
mode1:
#endif
	PCI_CONF_LOCK(s);
	outl(PCI_MODE1_ADDRESS_REG, tag.mode1 | reg);
	data = inl(PCI_MODE1_DATA_REG);
	outl(PCI_MODE1_ADDRESS_REG, 0);
a296 2
	return data;
#endif
a297 10
#if !defined(PCI_CONF_MODE) || (PCI_CONF_MODE == 2)
#ifndef PCI_CONF_MODE
mode2:
#endif
	PCI_CONF_LOCK(s);
	outb(PCI_MODE2_ENABLE_REG, tag.mode2.enable);
	outb(PCI_MODE2_FORWARD_REG, tag.mode2.forward);
	data = inl(tag.mode2.port | reg);
	outb(PCI_MODE2_ENABLE_REG, 0);
	PCI_CONF_UNLOCK(s);
a298 1
#endif
d310 1
a310 1
#ifndef PCI_CONF_MODE
d313 4
a316 1
		goto mode1;
d318 5
a322 1
		goto mode2;
a325 10
#endif

#if !defined(PCI_CONF_MODE) || (PCI_CONF_MODE == 1)
#ifndef PCI_CONF_MODE
mode1:
#endif
	PCI_CONF_LOCK(s);
	outl(PCI_MODE1_ADDRESS_REG, tag.mode1 | reg);
	outl(PCI_MODE1_DATA_REG, data);
	outl(PCI_MODE1_ADDRESS_REG, 0);
a326 14
	return;
#endif

#if !defined(PCI_CONF_MODE) || (PCI_CONF_MODE == 2)
#ifndef PCI_CONF_MODE
mode2:
#endif
	PCI_CONF_LOCK(s);
	outb(PCI_MODE2_ENABLE_REG, tag.mode2.enable);
	outb(PCI_MODE2_FORWARD_REG, tag.mode2.forward);
	outl(tag.mode2.port | reg, data);
	outb(PCI_MODE2_ENABLE_REG, 0);
	PCI_CONF_UNLOCK(s);
#endif
d620 1
@


1.6
log
@the local macro _id was removed before this code was even imported from NetBSD
when it was replaced with PCI_ID_CODE.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.5 2005/05/27 07:46:38 jason Exp $	*/
a594 10
}

const struct evcnt *
pci_intr_evcnt(pc, ih)
	pci_chipset_tag_t pc;
	pci_intr_handle_t ih;
{

	/* XXX for now, no evcnt parent reported */
	return NULL;
@


1.5
log
@hook in iommu, but it's still disabled by default for now
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.4 2005/05/14 00:13:15 brad Exp $	*/
a157 1
#undef _id
@


1.4
log
@remove redundant definition of PCI_ID_CODE. I added this to the
MI pcivar.h header 5 months ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.3 2004/06/28 01:52:26 deraadt Exp $	*/
d182 2
d189 1
a189 2

	if (pba->pba_bus == 0)
d191 2
@


1.3
log
@Use new event counter API for interrupt counting on amd64.  Based in part
on some changes in the i386 codebase.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.2 2004/06/25 11:03:28 art Exp $	*/
a137 4

#define PCI_ID_CODE(vid,pid)					\
	((((vid) & PCI_VENDOR_MASK) << PCI_VENDOR_SHIFT) |	\
	 (((pid) & PCI_PRODUCT_MASK) << PCI_PRODUCT_SHIFT))	\
@


1.2
log
@SMP support. Big parts from NetBSD, but with some really serious debugging
done by me, niklas and others. Especially wrt. NXE support.

Still needs some polishing, especially in dmesg messages, but we're now
building kernel faster than ever.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.1 2004/01/28 01:39:39 mickey Exp $	*/
d638 1
a638 1
	return intr_establish(irq, pic, pin, IST_LEVEL, level, func, arg);
@


1.1
log
@an amd64 arch support.
hacked by art@@ from netbsd sources and then later debugged
by me into the shape where it can host itself.
no bootloader yet as needs redoing from the
recent advanced i386 sources (anyone? ;)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d114 1
a114 1
#ifdef MULTIPROCESSOR
@

