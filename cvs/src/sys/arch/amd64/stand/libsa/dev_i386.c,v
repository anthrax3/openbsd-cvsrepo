head	1.20;
access;
symbols
	OPENBSD_6_2_BASE:1.20
	OPENBSD_6_1:1.19.0.4
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.16.0.4
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.15.0.8
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.13.0.8
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.4
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.2
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.10.0.2
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.2
	OPENBSD_5_0:1.8.0.2
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.3.0.14
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.10
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.12
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.8
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.6
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.4
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.2
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.2.0.12
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.8
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.10
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.6
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.4
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	OPENBSD_3_5:1.1.0.4
	OPENBSD_3_5_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.20
date	2017.05.31.08.40.32;	author yasuoka;	state Exp;
branches;
next	1.19;
commitid	xy5HQUtTP571qEt0;

1.19
date	2017.03.01.12.43.07;	author patrick;	state Exp;
branches;
next	1.18;
commitid	4uyvDK0n61h4IoQW;

1.18
date	2016.09.11.17.51.21;	author jsing;	state Exp;
branches;
next	1.17;
commitid	OdBRlx3Vvs2tfqrF;

1.17
date	2016.09.11.15.54.11;	author jsing;	state Exp;
branches;
next	1.16;
commitid	m28Q0aUDbVqwDb3p;

1.16
date	2015.09.18.13.30.56;	author miod;	state Exp;
branches;
next	1.15;
commitid	1BEcCDYd9p5DIl0g;

1.15
date	2014.07.13.09.26.08;	author jasper;	state Exp;
branches;
next	1.14;
commitid	Cnjup0HpCIRrcQ6o;

1.14
date	2014.07.12.21.54.58;	author jasper;	state Exp;
branches;
next	1.13;
commitid	3HeD4LaLGiS22I3y;

1.13
date	2012.10.30.14.06.29;	author jsing;	state Exp;
branches;
next	1.12;

1.12
date	2012.10.27.15.43.42;	author jsing;	state Exp;
branches;
next	1.11;

1.11
date	2012.10.08.14.15.23;	author jsing;	state Exp;
branches;
next	1.10;

1.10
date	2012.03.19.15.20.16;	author jsing;	state Exp;
branches;
next	1.9;

1.9
date	2012.01.11.14.47.02;	author jsing;	state Exp;
branches;
next	1.8;

1.8
date	2011.06.26.23.19.11;	author tedu;	state Exp;
branches;
next	1.7;

1.7
date	2011.06.26.21.37.52;	author tedu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.06.22.51.45;	author jasper;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.06.22.11.01;	author jasper;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.06.18.44.49;	author jasper;	state Exp;
branches;
next	1.3;

1.3
date	2007.06.27.20.29.37;	author mk;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.21.18.53.38;	author tom;	state Exp;
branches;
next	1.1;

1.1
date	2004.02.03.12.09.47;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Add serial console support for efiboot.
@
text
@/*	$OpenBSD: dev_i386.c,v 1.19 2017/03/01 12:43:07 patrick Exp $	*/

/*
 * Copyright (c) 1996-1999 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/queue.h>
#include <sys/disklabel.h>
#include <dev/cons.h>

#include "libsa.h"
#include "biosdev.h"
#include "disk.h"

#ifdef SOFTRAID
#include <dev/biovar.h>
#include <dev/softraidvar.h>
#include <lib/libsa/softraid.h>
#include "softraid_amd64.h"
#endif

extern int debug;

/* XXX use slot for 'rd' for 'hd' pseudo-device */
const char bdevs[][4] = {
	"wd", "", "fd", "", "sd", "st", "cd", "",
	"", "", "", "", "", "", "", "", "", "hd", ""
};
const int nbdevs = nitems(bdevs);

const char cdevs[][4] = {
	"cn", "", "", "", "", "", "", "",
	"com", "", "", "", "pc"
};
const int ncdevs = nitems(cdevs);

/* pass dev_t to the open routines */
int
devopen(struct open_file *f, const char *fname, char **file)
{
	struct devsw *dp = devsw;
	register int i, rc = 1;

	*file = (char *)fname;

#ifdef DEBUG
	if (debug)
		printf("devopen:");
#endif

	for (i = 0; i < ndevs && rc != 0; dp++, i++) {
#ifdef DEBUG
		if (debug)
			printf(" %s: ", dp->dv_name);
#endif
		if ((rc = (*dp->dv_open)(f, file)) == 0) {
			f->f_dev = dp;
			return 0;
		}
#ifdef DEBUG
		else if (debug)
			printf("%d", rc);
#endif

	}
#ifdef DEBUG
	if (debug)
		putchar('\n');
#endif

	if ((f->f_flags & F_NODEV) == 0)
		f->f_dev = dp;

	return rc;
}

void
devboot(dev_t bootdev, char *p)
{
#ifdef SOFTRAID
	struct sr_boot_volume *bv;
	struct sr_boot_chunk *bc;
	struct diskinfo *dip = NULL;
#endif
	int sr_boot_vol = -1;
	int part_type = FS_UNUSED;

#ifdef SOFTRAID
	/*
	 * Determine the partition type for the 'a' partition of the
	 * boot device.
	 */
	TAILQ_FOREACH(dip, &disklist, list)
		if (dip->bios_info.bios_number == bootdev &&
		    (dip->bios_info.flags & BDI_BADLABEL) == 0)
			part_type = dip->disklabel.d_partitions[0].p_fstype;

	/*
	 * See if we booted from a disk that is a member of a bootable
	 * softraid volume.
	 */
	SLIST_FOREACH(bv, &sr_volumes, sbv_link) {
		if (bv->sbv_flags & BIOC_SCBOOTABLE)
			SLIST_FOREACH(bc, &bv->sbv_chunks, sbc_link)
				if (bc->sbc_disk == bootdev)
					sr_boot_vol = bv->sbv_unit;
		if (sr_boot_vol != -1)
			break;
	}
#endif

	if (sr_boot_vol != -1 && part_type != FS_BSDFFS) {
		*p++ = 's';
		*p++ = 'r';
		*p++ = '0' + sr_boot_vol;
	} else if (bootdev & 0x100) {
		*p++ = 'c';
		*p++ = 'd';
		*p++ = '0';
	} else {
		if (bootdev & 0x80)
			*p++ = 'h';
		else
			*p++ = 'f';
		*p++ = 'd';
		*p++ = '0' + (bootdev & 0x7f);
	}
	*p++ = 'a';
	*p = '\0';
}

char ttyname_buf[8];

char *
ttyname(int fd)
{
	snprintf(ttyname_buf, sizeof ttyname_buf, "%s%d",
	    cdevs[major(cn_tab->cn_dev)], minor(cn_tab->cn_dev));

	return ttyname_buf;
}

dev_t
ttydev(char *name)
{
	int i, unit = -1;
	char *no = name + strlen(name) - 1;

	while (no >= name && *no >= '0' && *no <= '9')
		unit = (unit < 0 ? 0 : (unit * 10)) + *no-- - '0';
	if (no < name || unit < 0)
		return NODEV;
	for (i = 0; i < ncdevs; i++)
		if (strncmp(name, cdevs[i], no - name + 1) == 0)
			return makedev(i, unit);
	return NODEV;
}

int
cnspeed(dev_t dev, int sp)
{
	if (major(dev) == 8)	/* comN */
		return comspeed(dev, sp);

	/* pc0 and anything else */
	return 9600;
}
@


1.19
log
@Don't try to access the com(4) hardware to set up the console speed
on efiboot(8), as it can crash the EFI application.

ok tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dev_i386.c,v 1.18 2016/09/11 17:51:21 jsing Exp $	*/
a184 1
#ifndef EFIBOOT
a186 1
#endif
@


1.18
log
@Switch amd64 to libsa MI softraid.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev_i386.c,v 1.17 2016/09/11 15:54:11 jsing Exp $	*/
d185 1
d188 1
@


1.17
log
@Rename softraid boot files, which are currently in an MD location. This
will allow us to bring in a MI softraid.{c,h} in lib/libsa.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev_i386.c,v 1.16 2015/09/18 13:30:56 miod Exp $	*/
d41 1
@


1.16
log
@Remove support for building the boot blocks with DEBUGFLAGS=-D_TEST, which is
supposed to create a userland binary in order to test non-boot related
functionality. This feature has been bitrotting in a non-compiling state
for years, and causes a too-many-ifdefs disease now that there are intrusive
EFI changes.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev_i386.c,v 1.15 2014/07/13 09:26:08 jasper Exp $	*/
d41 1
a41 1
#include "softraid.h"
@


1.15
log
@move putchar() into libsa

"sure" miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dev_i386.c,v 1.14 2014/07/12 21:54:58 jasper Exp $	*/
a108 9

#ifdef _TEST
	*p++ = '/';
	*p++ = 'd';
	*p++ = 'e';
	*p++ = 'v';
	*p++ = '/';
	*p++ = 'r';
#endif
@


1.14
log
@move getchar() into libsa where applicable

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dev_i386.c,v 1.13 2012/10/30 14:06:29 jsing Exp $	*/
a160 31
}

int pch_pos = 0;

void
putchar(int c)
{
	switch (c) {
	case '\177':	/* DEL erases */
		cnputc('\b');
		cnputc(' ');
	case '\b':
		cnputc('\b');
		if (pch_pos)
			pch_pos--;
		break;
	case '\t':
		do {
			cnputc(' ');
		} while (++pch_pos % 8);
		break;
	case '\n':
	case '\r':
		cnputc(c);
		pch_pos=0;
		break;
	default:
		cnputc(c);
		pch_pos++;
		break;
	}
@


1.13
log
@Apply a bunch of style(9) and whitespace fixes to i386/amd64 libsa, making
the code actually diffable. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev_i386.c,v 1.12 2012/10/27 15:43:42 jsing Exp $	*/
a191 16
}

int
getchar(void)
{
	register int c = cngetc();

	if (c == '\r')
		c = '\n';

	if ((c < ' ' && c != '\n') || c == '\177')
		return c;

	putchar(c);

	return c;
@


1.12
log
@Move the code for softraid boot into separate files, leaving only minimal
hooks that are called from the normal code path. This allows softraid boot
support to be completely enabled or disabled at compile time. For boot(8)
all softraid boot support is now enabled by default, including support for
booting from crypto volumes. Disable softraid boot support for fdboot,
which further shrinks the binary.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev_i386.c,v 1.9 2012/01/11 14:47:02 jsing Exp $	*/
a32 2
#include <dev/biovar.h>
#include <dev/softraidvar.h>
d39 2
d86 1
a86 1
			
d168 1
a168 1
	switch(c) {
d178 1
a178 1
		do
d180 1
a180 1
		while(++pch_pos % 8);
d203 1
a203 1
		return(c);
d207 1
a207 1
	return(c);
d216 3
a218 3
	    cdevs[major(cn_tab->cn_dev)],
	    minor(cn_tab->cn_dev));
	return (ttyname_buf);
d230 1
a230 1
		return (NODEV);
d233 2
a234 2
			return (makedev(i, unit));
	return (NODEV);
d242 1
@


1.11
log
@If we have booted from a disk that is a member of a bootable softraid
volume, always select the srX device unless the 'a' partition of the disk
is FFS.
@
text
@d35 1
d40 4
d102 1
d106 1
d119 1
d141 1
@


1.10
log
@Only change the default boot device to a bootable softraid volume, if we
are able to handle the given discipline. At this stage amd64 boot(8) is
limited to RAID 1. This makes life easier for users who are booting from
a softraid crypto volume, but are loading a kernel from hd0a:/bsd.

Tested by jrick@@devio.us - thanks!
@
text
@d99 1
d101 1
d113 9
a125 3
		/* For now we only support booting from RAID 1 volumes. */
		if (bv->sbv_level != 1)
			continue;
d134 1
a134 1
	if (sr_boot_vol != -1) {
@


1.9
log
@Teach OpenBSD/amd64 boot(8) how to access softraid(8) volumes. This
allows a kernel to be loaded from a softraid RAID 1 volume. Furthermore,
if you boot from a disk that is a member of a bootable softraid volume
then it will default to booting from the softraid volume (sr[0-9]a:/bsd).

Discussed with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dev_i386.c,v 1.7 2011/06/26 21:37:52 tedu Exp $	*/
d115 3
@


1.8
log
@kill mcd dead.  ok krw matthew millert thib
@
text
@d29 6
d37 1
a37 2
#include <sys/param.h>
#include <dev/cons.h>
d97 4
d109 19
a127 1
	if (bootdev & 0x100) {
@


1.7
log
@remove remnants of scd device, discovered by Frederic Perrin
@
text
@d1 1
a1 1
/*	$OpenBSD: dev_i386.c,v 1.6 2010/12/06 22:51:45 jasper Exp $	*/
d38 1
a38 1
	"wd", "", "fd", "", "sd", "st", "cd", "mcd",
@


1.6
log
@- properly remove NENTS now after fixing the fallout.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dev_i386.c,v 1.5 2010/12/06 22:11:01 jasper Exp $	*/
d39 1
a39 1
	"", "", "", "", "", "", "", "scd", "", "hd", ""
@


1.5
log
@- partially revert previous NENTS removal for arches which got busted.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev_i386.c,v 1.4 2010/12/06 18:44:49 jasper Exp $	*/
d41 1
a41 1
const int nbdevs = NENTS(bdevs);
d47 1
a47 1
const int ncdevs = NENTS(cdevs);
@


1.4
log
@- drop NENTS(), which was yet another copy of nitems().
no binary change


ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dev_i386.c,v 1.3 2007/06/27 20:29:37 mk Exp $	*/
d41 1
a41 1
const int nbdevs = nitems(bdevs);
d47 1
a47 1
const int ncdevs = nitems(cdevs);
@


1.3
log
@wt(4) was removed a while ago, so don't support booting off it anoymore.

i386/amd64 was ok tom
zaurus ok drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: dev_i386.c,v 1.2 2004/08/21 18:53:38 tom Exp $	*/
d41 1
a41 1
const int nbdevs = NENTS(bdevs);
d47 1
a47 1
const int ncdevs = NENTS(cdevs);
@


1.2
log
@Enter cdboot, a CD-specific second-stage bootrap.  Based on the i386
cdboot that Toby and I put together at the hackathon.

"go for it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dev_i386.c,v 1.1 2004/02/03 12:09:47 mickey Exp $	*/
d38 1
a38 1
	"wd", "", "fd", "wt", "sd", "st", "cd", "mcd",
@


1.1
log
@das boot; das cloned das from das i386
@
text
@d1 1
a1 1
/*	$OpenBSD: dev_i386.c,v 1.27 2003/08/11 06:23:09 deraadt Exp $	*/
d100 12
a111 6
	if (bootdev & 0x80)
		*p++ = 'h';
	else
		*p++ = 'f';
	*p++ = 'd';
	*p++ = '0' + (bootdev & 0x7f);
@

