head	1.31;
access;
symbols
	OPENBSD_6_2:1.31.0.2
	OPENBSD_6_2_BASE:1.31
	OPENBSD_6_1:1.30.0.4
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.27.0.4
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.22.0.8
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.22.0.4
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.21.0.4
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.20.0.2
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.19.0.2
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.17.0.4
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.2
	OPENBSD_5_0:1.16.0.2
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.9.0.4
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.2
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.8.0.6
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.8
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.4
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.2
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.4.0.4
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.2
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.3.0.2
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.2.0.8
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.10
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.6
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.4
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	OPENBSD_3_5:1.1.0.4
	OPENBSD_3_5_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.31
date	2017.07.21.01.21.42;	author yasuoka;	state Exp;
branches;
next	1.30;
commitid	KhnY4tzd0VFPT3wU;

1.30
date	2016.09.18.15.13.10;	author jsing;	state Exp;
branches;
next	1.29;
commitid	s8Pq67pV4HEOyHxM;

1.29
date	2016.09.11.17.51.21;	author jsing;	state Exp;
branches;
next	1.28;
commitid	OdBRlx3Vvs2tfqrF;

1.28
date	2016.09.11.15.54.11;	author jsing;	state Exp;
branches;
next	1.27;
commitid	m28Q0aUDbVqwDb3p;

1.27
date	2015.10.01.20.28.12;	author krw;	state Exp;
branches;
next	1.26;
commitid	clda1fEydcUmLYPS;

1.26
date	2015.10.01.16.16.23;	author krw;	state Exp;
branches;
next	1.25;
commitid	MpVKqWgS6cH4roXM;

1.25
date	2015.10.01.16.08.19;	author krw;	state Exp;
branches;
next	1.24;
commitid	43YBo4Ce0DxgFS6N;

1.24
date	2015.09.19.21.07.04;	author semarie;	state Exp;
branches;
next	1.23;
commitid	9KMPSlP02LD1SpJP;

1.23
date	2015.09.02.01.52.26;	author yasuoka;	state Exp;
branches;
next	1.22;
commitid	CUwlbzT4LejFC15d;

1.22
date	2014.03.29.18.09.28;	author guenther;	state Exp;
branches;
next	1.21;

1.21
date	2013.12.28.02.40.41;	author jsing;	state Exp;
branches;
next	1.20;

1.20
date	2013.03.23.16.08.27;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2012.10.27.15.43.42;	author jsing;	state Exp;
branches;
next	1.18;

1.18
date	2012.10.09.13.55.36;	author jsing;	state Exp;
branches;
next	1.17;

1.17
date	2012.01.11.14.47.02;	author jsing;	state Exp;
branches;
next	1.16;

1.16
date	2011.07.19.01.08.35;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2011.03.17.12.53.44;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2011.03.15.14.00.26;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2011.03.14.22.14.40;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2011.03.13.00.13.52;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2011.03.11.21.08.25;	author krw;	state Exp;
branches;
next	1.10;

1.10
date	2011.03.08.17.24.31;	author krw;	state Exp;
branches;
next	1.9;

1.9
date	2010.08.11.13.11.59;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2008.08.12.22.48.32;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2008.08.04.15.58.13;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2008.06.25.15.32.18;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2008.06.25.15.26.44;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2007.04.04.14.36.05;	author jmc;	state Exp;
branches;
next	1.3;

1.3
date	2006.10.12.12.14.17;	author krw;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.21.18.53.38;	author tom;	state Exp;
branches;
next	1.1;

1.1
date	2004.02.03.12.09.47;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Check the hibernation signature for softraid disks and select valid bsd
for unhibernation.  reported by Natasha Kerensikova.  tested by Theo Buehler.

ok deraadt
@
text
@/*	$OpenBSD: biosdev.c,v 1.30 2016/09/18 15:13:10 jsing Exp $	*/

/*
 * Copyright (c) 1996 Michael Shalayeff
 * Copyright (c) 2003 Tobias Weingartner
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/reboot.h>
#include <sys/disklabel.h>
#include <isofs/cd9660/iso.h>
#include <lib/libsa/saerrno.h>
#include <machine/tss.h>
#include <machine/biosvar.h>

#include "biosdev.h"
#include "disk.h"
#include "libsa.h"

#ifdef SOFTRAID
#include <dev/softraidvar.h>
#include <lib/libsa/softraid.h>
#include "softraid_amd64.h"
#endif

static const char *biosdisk_err(u_int);
static int biosdisk_errno(u_int);

int CHS_rw (int, int, int, int, int, int, void *);
static int EDD_rw (int, int, u_int32_t, u_int32_t, void *);

static int biosd_io(int, bios_diskinfo_t *, u_int, int, void *);
static u_int findopenbsd(bios_diskinfo_t *, const char **);

extern int debug;
int bios_bootdev;
int bios_cddev = -1;		/* Set by srt0 if coming from CD */

struct EDD_CB {
	u_int8_t  edd_len;	/* size of packet */
	u_int8_t  edd_res1;	/* reserved */
	u_int8_t  edd_nblk;	/* # of blocks to transfer */
	u_int8_t  edd_res2;	/* reserved */
	u_int16_t edd_off;	/* address of buffer (offset) */
	u_int16_t edd_seg;	/* address of buffer (segment) */
	u_int64_t edd_daddr;	/* starting block */
};

/*
 * reset disk system
 */
static int
biosdreset(int dev)
{
	int rv;

	__asm volatile (DOINT(0x13) "; setc %b0" : "=a" (rv)
	    : "0" (0), "d" (dev) : "%ecx", "cc");

	return ((rv & 0xff)? rv >> 8 : 0);
}

/*
 * Fill out a bios_diskinfo_t for this device.
 * Return 0 if all ok.
 * Return 1 if not ok.
 */
int
bios_getdiskinfo(int dev, bios_diskinfo_t *pdi)
{
	u_int rv;

	/* Just reset, don't check return code */
	rv = biosdreset(dev);

#ifdef BIOS_DEBUG
	if (debug)
		printf("getinfo: try #8, 0x%x, %p\n", dev, pdi);
#endif
	__asm volatile (DOINT(0x13) "\n\t"
	    "setc %b0; movzbl %h1, %1\n\t"
	    "movzbl %%cl, %3; andb $0x3f, %b3\n\t"
	    "xchgb %%cl, %%ch; rolb $2, %%ch"
	    : "=a" (rv), "=d" (pdi->bios_heads),
	      "=c" (pdi->bios_cylinders),
	      "=b" (pdi->bios_sectors)
	    : "0" (0x0800), "1" (dev) : "cc");

#ifdef BIOS_DEBUG
	if (debug) {
		printf("getinfo: got #8\n");
		printf("disk 0x%x: %d,%d,%d\n", dev, pdi->bios_cylinders,
		    pdi->bios_heads, pdi->bios_sectors);
	}
#endif
	if (rv & 0xff)
		return 1;

	/* Fix up info */
	pdi->bios_number = dev;
	pdi->bios_heads++;
	pdi->bios_cylinders &= 0x3ff;
	pdi->bios_cylinders++;

	/* NOTE:
	 * This currently hangs/reboots some machines
	 * The IBM ThinkPad 750ED for one.
	 *
	 * Funny that an IBM/MS extension would not be
	 * implemented by an IBM system...
	 *
	 * Future hangs (when reported) can be "fixed"
	 * with getSYSCONFaddr() and an exceptions list.
	 */
	if (dev & 0x80 && (dev == 0x80 || dev == 0x81 || dev == bios_bootdev)) {
		int bm;

#ifdef BIOS_DEBUG
		if (debug)
			printf("getinfo: try #41, 0x%x\n", dev);
#endif
		/* EDD support check */
		__asm volatile(DOINT(0x13) "; setc %b0"
			 : "=a" (rv), "=c" (bm)
			 : "0" (0x4100), "b" (0x55aa), "d" (dev) : "cc");
		if (!(rv & 0xff) && (BIOS_regs.biosr_bx & 0xffff) == 0xaa55)
			pdi->bios_edd = (bm & 0xffff) | ((rv & 0xff) << 16);
		else
			pdi->bios_edd = -1;

#ifdef BIOS_DEBUG
		if (debug) {
			printf("getinfo: got #41\n");
			printf("disk 0x%x: 0x%x\n", dev, bm);
		}
#endif
		/*
		 * If extended disk access functions are not supported
		 * there is not much point on doing EDD.
		 */
		if (!(pdi->bios_edd & EXT_BM_EDA))
			pdi->bios_edd = -1;
	} else
		pdi->bios_edd = -1;

	/* Skip sanity check for CHS options in EDD mode. */
	if (pdi->bios_edd != -1)
		return 0;

	/* Sanity check */
	if (!pdi->bios_cylinders || !pdi->bios_heads || !pdi->bios_sectors)
		return 1;

	/* CD-ROMs sometimes return heads == 1 */
	if (pdi->bios_heads < 2)
		return 1;

	return 0;
}

/*
 * Read/Write a block from given place using the BIOS.
 */
int
CHS_rw(int rw, int dev, int cyl, int head, int sect, int nsect, void *buf)
{
	int rv;

	rw = rw == F_READ ? 2 : 3;
	BIOS_regs.biosr_es = (u_int32_t)buf >> 4;
	__asm volatile ("movb %b7, %h1\n\t"
	    "movb %b6, %%dh\n\t"
	    "andl $0xf, %4\n\t"
	    /* cylinder; the highest 2 bits of cyl is in %cl */
	    "xchgb %%ch, %%cl\n\t"
	    "rorb  $2, %%cl\n\t"
	    "orb %b5, %%cl\n\t"
	    "inc %%cx\n\t"
	    DOINT(0x13) "\n\t"
	    "setc %b0"
	    : "=a" (rv)
	    : "0" (nsect), "d" (dev), "c" (cyl),
	      "b" (buf), "m" (sect), "m" (head),
	      "m" (rw)
	    : "cc", "memory");

	return ((rv & 0xff)? rv >> 8 : 0);
}

static __inline int
EDD_rw(int rw, int dev, u_int32_t daddr, u_int32_t nblk, void *buf)
{
	int rv;
	volatile static struct EDD_CB cb;

	/* Zero out reserved stuff */
	cb.edd_res1 = 0;
	cb.edd_res2 = 0;

	/* Fill in parameters */
	cb.edd_len = sizeof(cb);
	cb.edd_nblk = nblk;
	cb.edd_seg = ((u_int32_t)buf >> 4) & 0xffff;
	cb.edd_off = (u_int32_t)buf & 0xf;
	cb.edd_daddr = daddr;

	/* if offset/segment are zero, punt */
	if (!cb.edd_seg && !cb.edd_off)
		return 1;

	/* Call extended read/write (with disk packet) */
	BIOS_regs.biosr_ds = (u_int32_t)&cb >> 4;
	__asm volatile (DOINT(0x13) "; setc %b0" : "=a" (rv)
	    : "0" ((rw == F_READ)? 0x4200: 0x4300),
	      "d" (dev), "S" ((int) (&cb) & 0xf) : "%ecx", "cc");
	return ((rv & 0xff)? rv >> 8 : 0);
}

/*
 * Read given sector, handling retry/errors/etc.
 */
int
biosd_io(int rw, bios_diskinfo_t *bd, u_int off, int nsect, void *buf)
{
	int dev = bd->bios_number;
	int j, error;
	void *bb, *bb1 = NULL;
	int bbsize = nsect * DEV_BSIZE;

	if (bd->flags & BDI_EL_TORITO) {	/* It's a CD device */
		dev &= 0xff;			/* Mask out this flag bit */

		/*
		 * sys/lib/libsa/cd9600.c converts 2,048-byte CD sectors
		 * to DEV_BSIZE blocks before calling the device strategy
		 * routine.  However, the El Torito spec says that the
		 * BIOS will work in 2,048-byte sectors.  So shift back.
		 */
		off /= (ISO_DEFAULT_BLOCK_SIZE / DEV_BSIZE);
		nsect /= (ISO_DEFAULT_BLOCK_SIZE / DEV_BSIZE);
	}

	/*
	 * Use a bounce buffer to not cross 64k DMA boundary, and to
	 * not access 1 MB or above.
	 */
	if (((((u_int32_t)buf) & ~0xffff) !=
	    (((u_int32_t)buf + bbsize) & ~0xffff)) ||
	    (((u_int32_t)buf) >= 0x100000)) {
		bb = bb1 = alloc(bbsize * 2);
		if ((((u_int32_t)bb) & ~0xffff) !=
		    (((u_int32_t)bb + bbsize - 1) & ~0xffff))
			bb = (void *)(((u_int32_t)bb + bbsize - 1) & ~0xffff);
		if (rw != F_READ)
			bcopy(buf, bb, bbsize);
	} else
		bb = buf;

	/* Try to do operation up to 5 times */
	for (error = 1, j = 5; j-- && error; ) {
		/* CHS or LBA access? */
		if (bd->bios_edd != -1) {
			error = EDD_rw(rw, dev, off, nsect, bb);
		} else {
			int cyl, head, sect;
			size_t i, n;
			char *p = bb;

			/* Handle track boundaries */
			for (error = i = 0; error == 0 && i < nsect;
			    i += n, off += n, p += n * DEV_BSIZE) {

				btochs(off, cyl, head, sect, bd->bios_heads,
				    bd->bios_sectors);

				if ((sect + (nsect - i)) >= bd->bios_sectors)
					n = bd->bios_sectors - sect;
				else
					n = nsect - i;

				error = CHS_rw(rw, dev, cyl, head, sect, n, p);

				/* ECC corrected */
				if (error == 0x11)
					error = 0;
			}
		}
		switch (error) {
		case 0x00:	/* No errors */
		case 0x11:	/* ECC corrected */
			error = 0;
			break;

		default:	/* All other errors */
#ifdef BIOS_DEBUG
			if (debug)
				printf("\nBIOS error 0x%x (%s)\n",
				    error, biosdisk_err(error));
#endif
			biosdreset(dev);
			break;
		}
	}

	if (bb != buf && rw == F_READ)
		bcopy(bb, buf, bbsize);
	free(bb1, bbsize * 2);

#ifdef BIOS_DEBUG
	if (debug) {
		if (error != 0)
			printf("=0x%x(%s)", error, biosdisk_err(error));
		putchar('\n');
	}
#endif

	return error;
}

int
biosd_diskio(int rw, struct diskinfo *dip, u_int off, int nsect, void *buf)
{
	return biosd_io(rw, &dip->bios_info, off, nsect, buf);
}
/*
 * Try to read the bsd label on the given BIOS device.
 */
static u_int
findopenbsd(bios_diskinfo_t *bd, const char **err)
{
	struct dos_mbr mbr;
	struct dos_partition *dp;
	u_int mbroff = DOSBBSECTOR;
	u_int mbr_eoff = DOSBBSECTOR;	/* Offset of MBR extended partition. */
	int error, i, maxebr = DOS_MAXEBR, nextebr;

again:
	if (!maxebr--) {
		*err = "too many extended partitions";
		return (-1);
	}

	/* Read MBR */
	bzero(&mbr, sizeof(mbr));
	error = biosd_io(F_READ, bd, mbroff, 1, &mbr);
	if (error) {
		*err = biosdisk_err(error);
		return (-1);
	}

	/* check mbr signature */
	if (mbr.dmbr_sign != DOSMBR_SIGNATURE) {
		*err = "bad MBR signature\n";
		return (-1);
	}

	/* Search for OpenBSD partition */
	nextebr = 0;
	for (i = 0; i < NDOSPART; i++) {
		dp = &mbr.dmbr_parts[i];
		if (!dp->dp_size)
			continue;
#ifdef BIOS_DEBUG
		if (debug)
			printf("found partition %u: "
			    "type %u (0x%x) offset %u (0x%x)\n",
			    (int)(dp - mbr.dmbr_parts),
			    dp->dp_typ, dp->dp_typ,
			    dp->dp_start, dp->dp_start);
#endif
		if (dp->dp_typ == DOSPTYP_OPENBSD) {
			if (dp->dp_start > (dp->dp_start + mbroff))
				continue;
			return (dp->dp_start + mbroff);
		}

		/*
		 * Record location of next ebr if and only if this is the first
		 * extended partition in this boot record!
		 */
		if (!nextebr && (dp->dp_typ == DOSPTYP_EXTEND ||
		    dp->dp_typ == DOSPTYP_EXTENDL)) {
			nextebr = dp->dp_start + mbr_eoff;
			if (nextebr < dp->dp_start)
				nextebr = (u_int)-1;
			if (mbr_eoff == DOSBBSECTOR)
				mbr_eoff = dp->dp_start;
		}
	}

	if (nextebr && nextebr != (u_int)-1) {
		mbroff = nextebr;
		goto again;
	}

	return (-1);
}

const char *
bios_getdisklabel(bios_diskinfo_t *bd, struct disklabel *label)
{
	u_int start = 0;
	char buf[DEV_BSIZE];
	const char *err = NULL;
	int error;

	/* Sanity check */
	if (bd->bios_edd == -1 &&
	    (bd->bios_heads == 0 || bd->bios_sectors == 0))
		return "failed to read disklabel";

	/* MBR is a harddisk thing */
	if (bd->bios_number & 0x80) {
		start = findopenbsd(bd, &err);
		if (start == (u_int)-1) {
			if (err != NULL)
				return (err);
			return "no OpenBSD partition\n";
		}
	}

	/* Load BSD disklabel */
#ifdef BIOS_DEBUG
	if (debug)
		printf("loading disklabel @@ %u\n", start + DOS_LABELSECTOR);
#endif
	/* read disklabel */
	error = biosd_io(F_READ, bd, start + DOS_LABELSECTOR, 1, buf);

	if (error)
		return "failed to read disklabel";

	/* Fill in disklabel */
	return (getdisklabel(buf, label));
}

int
biosopen(struct open_file *f, ...)
{
#ifdef SOFTRAID
	struct sr_boot_volume *bv;
#endif
	register char *cp, **file;
	dev_t maj, unit, part;
	struct diskinfo *dip;
	int biosdev, devlen;
	const char *st;
	va_list ap;
	char *dev;

	va_start(ap, f);
	cp = *(file = va_arg(ap, char **));
	va_end(ap);

#ifdef BIOS_DEBUG
	if (debug)
		printf("%s\n", cp);
#endif

	f->f_devdata = NULL;

	/* Search for device specification. */
	dev = cp;
	if (cp[4] == ':')
		devlen = 2;
	else if (cp[5] == ':')
		devlen = 3;
	else
		return ENOENT;
	cp += devlen;

	/* Get unit. */
	if ('0' <= *cp && *cp <= '9')
		unit = *cp++ - '0';
	else {
		printf("Bad unit number\n");
		return EUNIT;
	}

	/* Get partition. */
	if ('a' <= *cp && *cp <= 'p')
		part = *cp++ - 'a';
	else {
		printf("Bad partition\n");
		return EPART;
	}

	/* Get filename. */
	cp++;	/* skip ':' */
	if (*cp != 0)
		*file = cp;
	else
		f->f_flags |= F_RAW;

#ifdef SOFTRAID
	/* Intercept softraid disks. */
	if (strncmp("sr", dev, 2) == 0) {

		/* Create a fake diskinfo for this softraid volume. */
		SLIST_FOREACH(bv, &sr_volumes, sbv_link)
			if (bv->sbv_unit == unit)
				break;
		if (bv == NULL) {
			printf("Unknown device: sr%d\n", unit);
			return EADAPT;
		}

		if (bv->sbv_level == 'C' && bv->sbv_keys == NULL)
			if (sr_crypto_decrypt_keys(bv) != 0)
				return EPERM;

		if (bv->sbv_diskinfo == NULL) {
			dip = alloc(sizeof(struct diskinfo));
			bzero(dip, sizeof(*dip));
			dip->strategy = biosstrategy;
			bv->sbv_diskinfo = dip;
			dip->sr_vol = bv;
			dip->bios_info.flags |= BDI_BADLABEL;
		}

		dip = bv->sbv_diskinfo;

		if (dip->bios_info.flags & BDI_BADLABEL) {
			/* Attempt to read disklabel. */
			bv->sbv_part = 'c';
			if (sr_getdisklabel(bv, &dip->disklabel))
				return ERDLAB;
			dip->bios_info.flags &= ~BDI_BADLABEL;
			check_hibernate(dip);
		}

		bv->sbv_part = part + 'a';

		bootdev_dip = dip;
		f->f_devdata = dip;

		return 0;
	}
#endif

	for (maj = 0; maj < nbdevs &&
	    strncmp(dev, bdevs[maj], devlen); maj++);
	if (maj >= nbdevs) {
		printf("Unknown device: ");
		for (cp = *file; *cp != ':'; cp++)
			putchar(*cp);
		putchar('\n');
		return EADAPT;
	}

	biosdev = unit;
	switch (maj) {
	case 0:  /* wd */
	case 4:  /* sd */
	case 17: /* hd */
		biosdev |= 0x80;
		break;
	case 2:  /* fd */
		break;
	case 6:  /* cd */
		biosdev = bios_bootdev & 0xff;
		break;
	default:
		return ENXIO;
	}

	/* Find device */
	bootdev_dip = dip = dklookup(biosdev);

	/* Fix up bootdev */
	{ dev_t bsd_dev;
		bsd_dev = dip->bios_info.bsd_dev;
		dip->bsddev = MAKEBOOTDEV(B_TYPE(bsd_dev), B_ADAPTOR(bsd_dev),
		    B_CONTROLLER(bsd_dev), unit, part);
		dip->bootdev = MAKEBOOTDEV(B_TYPE(bsd_dev), B_ADAPTOR(bsd_dev),
		    B_CONTROLLER(bsd_dev), B_UNIT(bsd_dev), part);
	}

#if 0
	dip->bios_info.bsd_dev = dip->bootdev;
	bootdev = dip->bootdev;
#endif

#ifdef BIOS_DEBUG
	if (debug) {
		printf("BIOS geometry: heads=%u, s/t=%u; EDD=%d\n",
		    dip->bios_info.bios_heads, dip->bios_info.bios_sectors,
		    dip->bios_info.bios_edd);
	}
#endif

	/* Try for disklabel again (might be removable media) */
	if (dip->bios_info.flags & BDI_BADLABEL) {
		st = bios_getdisklabel(&dip->bios_info, &dip->disklabel);
#ifdef BIOS_DEBUG
		if (debug && st)
			printf("%s\n", st);
#endif
		if (!st) {
			dip->bios_info.flags &= ~BDI_BADLABEL;
			dip->bios_info.flags |= BDI_GOODLABEL;
		} else
			return ERDLAB;
	}

	f->f_devdata = dip;

	return 0;
}

const u_char bidos_errs[] =
/* ignored	"\x00" "successful completion\0" */
		"\x01" "invalid function/parameter\0"
		"\x02" "address mark not found\0"
		"\x03" "write-protected\0"
		"\x04" "sector not found\0"
		"\x05" "reset failed\0"
		"\x06" "disk changed\0"
		"\x07" "drive parameter activity failed\0"
		"\x08" "DMA overrun\0"
		"\x09" "data boundary error\0"
		"\x0A" "bad sector detected\0"
		"\x0B" "bad track detected\0"
		"\x0C" "invalid media\0"
		"\x0E" "control data address mark detected\0"
		"\x0F" "DMA arbitration level out of range\0"
		"\x10" "uncorrectable CRC or ECC error on read\0"
/* ignored	"\x11" "data ECC corrected\0" */
		"\x20" "controller failure\0"
		"\x31" "no media in drive\0"
		"\x32" "incorrect drive type in CMOS\0"
		"\x40" "seek failed\0"
		"\x80" "operation timed out\0"
		"\xAA" "drive not ready\0"
		"\xB0" "volume not locked in drive\0"
		"\xB1" "volume locked in drive\0"
		"\xB2" "volume not removable\0"
		"\xB3" "volume in use\0"
		"\xB4" "lock count exceeded\0"
		"\xB5" "valid eject request failed\0"
		"\xBB" "undefined error\0"
		"\xCC" "write fault\0"
		"\xE0" "status register error\0"
		"\xFF" "sense operation failed\0"
		"\x00" "\0";

static const char *
biosdisk_err(u_int error)
{
	register const u_char *p = bidos_errs;

	while (*p && *p != error)
		while (*p++);

	return ++p;
}

const struct biosdisk_errors {
	u_char error;
	u_char errno;
} tab[] = {
	{ 0x01, EINVAL },
	{ 0x03, EROFS },
	{ 0x08, EINVAL },
	{ 0x09, EINVAL },
	{ 0x0A, EBSE },
	{ 0x0B, EBSE },
	{ 0x0C, ENXIO },
	{ 0x0D, EINVAL },
	{ 0x10, EECC },
	{ 0x20, EHER },
	{ 0x31, ENXIO },
	{ 0x32, ENXIO },
	{ 0x00, EIO }
};

static int
biosdisk_errno(u_int error)
{
	register const struct biosdisk_errors *p;

	if (error == 0)
		return 0;

	for (p = tab; p->error && p->error != error; p++);

	return p->errno;
}

int
biosstrategy(void *devdata, int rw, daddr32_t blk, size_t size, void *buf,
    size_t *rsize)
{
	struct diskinfo *dip = (struct diskinfo *)devdata;
	bios_diskinfo_t *bd = &dip->bios_info;
	u_int8_t error = 0;
	size_t nsect;

#ifdef SOFTRAID
	/* Intercept strategy for softraid volumes. */
	if (dip->sr_vol)
		return sr_strategy(dip->sr_vol, rw, blk, size, buf, rsize);
#endif

	nsect = (size + DEV_BSIZE - 1) / DEV_BSIZE;
	blk += dip->disklabel.d_partitions[B_PARTITION(dip->bsddev)].p_offset;

	/* Read all, sub-functions handle track boundaries */
	if (blk < 0)
		error = EINVAL;
	else
		error = biosd_io(rw, bd, blk, nsect, buf);

#ifdef BIOS_DEBUG
	if (debug) {
		if (error != 0)
			printf("=0x%x(%s)", error, biosdisk_err(error));
		putchar('\n');
	}
#endif

	if (rsize != NULL)
		*rsize = nsect * DEV_BSIZE;

	return (biosdisk_errno(error));
}

int
biosclose(struct open_file *f)
{
	f->f_devdata = NULL;

	return 0;
}

int
biosioctl(struct open_file *f, u_long cmd, void *data)
{
	return 0;
}
@


1.30
log
@Fix a bug in the bounce buffer handling of BIOS disk I/O.

Currently, if a buffer crosses a 64KB boundary, a bounce buffer is
allocated, however it is assumed that this new buffer does not cross the
64KB boundary. In the case of i386 fdboot, it just so happens that (due to
the size of fdboot and heap allocations) UFS gets allocated a 4KB buffer
that crosses a 64KB boundary, then biosd_io() allocates a bounce buffer,
which also crosses a 64KB boundary. At this point the BIOS gets grumpy and
refuses to read from the disk.

Further clean up to come from tom@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.29 2016/09/11 17:51:21 jsing Exp $	*/
d538 1
d552 1
@


1.29
log
@Switch amd64 to libsa MI softraid.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.28 2016/09/11 15:54:11 jsing Exp $	*/
d273 4
a276 5
		/*
		 * XXX we believe that all the io is buffered
		 * by fs routines, so no big reads anyway
		 */
		bb = bb1 = alloc(bbsize);
d330 1
a330 1
	free(bb1, bbsize);
@


1.28
log
@Rename softraid boot files, which are currently in an MD location. This
will allow us to bring in a MI softraid.{c,h} in lib/libsa.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.27 2015/10/01 20:28:12 krw Exp $	*/
d45 1
@


1.27
log
@Use DOS_LABELSECTOR rather than LABELSECTOR to indicate offset into an
OpenBSD partition when accessing the disklabel. For these files both
are '1', but this makes the usage consistent across all archs.

ok guenther@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.26 2015/10/01 16:16:23 krw Exp $	*/
d45 1
a45 1
#include "softraid.h"
@


1.26
log
@Remove yet more blinding whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.25 2015/10/01 16:08:19 krw Exp $	*/
a443 1
	start = LABELSECTOR + start;
d448 1
a448 1
		printf("loading disklabel @@ %u\n", start);
d451 1
a451 1
	error = biosd_io(F_READ, bd, start, 1, buf);
@


1.25
log
@Remove more blinding trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.24 2015/09/19 21:07:04 semarie Exp $	*/
d441 1
a441 1
 			return "no OpenBSD partition\n";
@


1.24
log
@trivial "if(x) free(x)" replacement by "free(x)"

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.23 2015/09/02 01:52:26 yasuoka Exp $	*/
d562 1
a562 1
 
@


1.23
log
@Initial commit of uefi boot loader of OpenBSD.

ok deraadt yuo
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.22 2014/03/29 18:09:28 guenther Exp $	*/
d330 1
a330 2
	if (bb1 != NULL)
		free(bb1, bbsize);
@


1.22
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.21 2013/12/28 02:40:41 jsing Exp $	*/
d54 1
d249 1
a249 1
	void *bb;
d276 1
a276 1
		bb = alloca(bbsize);
d330 2
d344 5
d427 1
a427 1
	char *buf;
a447 1
	buf = alloca(DEV_BSIZE);
@


1.21
log
@If we fail to decrypt the softraid keys, return EPERM rather than falling
through and failing when we attempt to read and validate the disklabel.
Also return ENOTSUP rather than EPERM if an attempt is made to write to a
softraid volume.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.20 2013/03/23 16:08:27 deraadt Exp $	*/
d78 1
a78 1
	__asm __volatile (DOINT(0x13) "; setc %b0" : "=a" (rv)
d101 1
a101 1
	__asm __volatile (DOINT(0x13) "\n\t"
d144 1
a144 1
		__asm __volatile(DOINT(0x13) "; setc %b0"
d192 1
a192 1
	__asm __volatile ("movb %b7, %h1\n\t"
d234 1
a234 1
	__asm __volatile (DOINT(0x13) "; setc %b0" : "=a" (rv)
@


1.20
log
@Avoid using DEV_BSHIFT, and use DEV_BSIZE instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.19 2012/10/27 15:43:42 jsing Exp $	*/
d527 2
a528 1
			sr_crypto_decrypt_keys(bv);
@


1.19
log
@Move the code for softraid boot into separate files, leaving only minimal
hooks that are called from the normal code path. This allows softraid boot
support to be completely enabled or disabled at compile time. For boot(8)
all softraid boot support is now enabled by default, including support for
booting from crypto volumes. Disable softraid boot support for fdboot,
which further shrinks the binary.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.15 2011/03/17 12:53:44 krw Exp $	*/
d260 2
a261 2
		off >>= (ISO_DEFAULT_BLOCK_SHIFT - DEV_BSHIFT);
		nsect >>= (ISO_DEFAULT_BLOCK_SHIFT - DEV_BSHIFT);
@


1.18
log
@Teach amd64 boot(8) how to access a softraid crypto volume. This allows for
full disk encryption since the kernel can now be loaded directly from the
crypto volume, instead of needing to be on FFS.

This is currently disabled by default, however can be enabled by compiling
with boot(8) 'make -DBOOT_CRYPTO'.
@
text
@a33 2
#include <dev/biovar.h>
#include <dev/softraidvar.h>
d43 3
a45 5
#ifdef BOOT_CRYPTO
#include <lib/libsa/aes_xts.h>
#include <lib/libsa/hmac_sha1.h>
#include <lib/libsa/pbkdf2.h>
#include <lib/libsa/rijndael.h>
a55 8
static const char *sr_getdisklabel(struct sr_boot_volume *, struct disklabel *);
static int sr_strategy(struct sr_boot_volume *, int, daddr32_t, size_t,
    void *, size_t *);

#ifdef BOOT_CRYPTO
static int sr_crypto_decrypt_keys(struct sr_boot_volume *);
#endif

d458 1
d460 1
d513 1
a525 1
#ifdef BOOT_CRYPTO
a527 1
#endif
d554 1
d714 1
d718 1
a755 299

static int
sr_strategy(struct sr_boot_volume *bv, int rw, daddr32_t blk, size_t size,
    void *buf, size_t *rsize)
{
	struct diskinfo *sr_dip, *dip;
	struct sr_boot_chunk *bc;
#ifdef BOOT_CRYPTO
	struct aes_xts_ctx ctx;
	size_t i, j, nsect;
	daddr64_t blkno;
	u_char iv[8];
	u_char *bp;
	int err;
#endif

	/* We only support read-only softraid. */
	if (rw != F_READ)
		return EPERM;

	/* Partition offset within softraid volume. */
	sr_dip = (struct diskinfo *)bv->sbv_diskinfo;
	blk += sr_dip->disklabel.d_partitions[bv->sbv_part - 'a'].p_offset;

	if (bv->sbv_level == 0) {
		return ENOTSUP;
	} else if (bv->sbv_level == 1) {

		/* Select first online chunk. */
		SLIST_FOREACH(bc, &bv->sbv_chunks, sbc_link)
			if (bc->sbc_state == BIOC_SDONLINE)
				break;
		if (bc == NULL)
			return EIO;

		dip = (struct diskinfo *)bc->sbc_diskinfo;
		dip->bsddev = bc->sbc_mm;
		blk += bv->sbv_data_offset;

		/* XXX - If I/O failed we should try another chunk... */
		return biosstrategy(dip, rw, blk, size, buf, rsize);

#ifdef BOOT_CRYPTO
	} else if (bv->sbv_level == 'C') {

		/* Select first online chunk. */
		SLIST_FOREACH(bc, &bv->sbv_chunks, sbc_link)
			if (bc->sbc_state == BIOC_SDONLINE)
				break;
		if (bc == NULL)
			return EIO;

		dip = (struct diskinfo *)bc->sbc_diskinfo;
		dip->bsddev = bc->sbc_mm;

		/* XXX - select correct key. */
		aes_xts_setkey(&ctx, (u_char *)bv->sbv_keys, 64);

		nsect = (size + DEV_BSIZE - 1) / DEV_BSIZE;
		for (i = 0; i < nsect; i++) {
			blkno = blk + i;
			bp = ((u_char *)buf) + i * DEV_BSIZE;
			err = biosstrategy(dip, rw, bv->sbv_data_offset + blkno,
			    DEV_BSIZE, bp, NULL);
			if (err != 0)
				return err;

			bcopy(&blkno, iv, sizeof(blkno));
			aes_xts_reinit(&ctx, iv);
			for (j = 0; j < DEV_BSIZE; j += AES_XTS_BLOCKSIZE)
				aes_xts_decrypt(&ctx, bp + j);
		}
		if (rsize != NULL)
			*rsize = nsect * DEV_BSIZE;

		return err;
#endif
	} else
		return ENOTSUP;
}

static const char *
sr_getdisklabel(struct sr_boot_volume *bv, struct disklabel *label)
{
	struct dos_partition *dp;
	struct dos_mbr mbr;
	u_int start = 0;
	char *buf;
	int i;

	/* Check for MBR to determine partition offset. */
	bzero(&mbr, sizeof(mbr));
	sr_strategy(bv, F_READ, DOSBBSECTOR, sizeof(struct dos_mbr),
	    &mbr, NULL);
	if (mbr.dmbr_sign == DOSMBR_SIGNATURE) {

		/* Search for OpenBSD partition */
		for (i = 0; i < NDOSPART; i++) {
			dp = &mbr.dmbr_parts[i];
			if (!dp->dp_size)
				continue;
			if (dp->dp_typ == DOSPTYP_OPENBSD) {
				if (dp->dp_start > (dp->dp_start + DOSBBSECTOR))
					continue;
				start = dp->dp_start + DOSBBSECTOR;
			}
		}
	}

	start += LABELSECTOR;

	/* Read the disklabel. */
	buf = alloca(DEV_BSIZE);
	sr_strategy(bv, F_READ, start, sizeof(struct disklabel), buf, NULL);

#if BIOS_DEBUG
	printf("sr_getdisklabel: magic %lx\n",
	    ((struct disklabel *)buf)->d_magic);
	for (i = 0; i < MAXPARTITIONS; i++)
		printf("part %c: type = %d, size = %d, offset = %d\n", 'a' + i,
		    (int)((struct disklabel *)buf)->d_partitions[i].p_fstype,
		    (int)((struct disklabel *)buf)->d_partitions[i].p_size,
		    (int)((struct disklabel *)buf)->d_partitions[i].p_offset);
#endif

	/* Fill in disklabel */
	return (getdisklabel(buf, label));
}

#ifdef BOOT_CRYPTO

#define RIJNDAEL128_BLOCK_LEN     16
#define PASSPHRASE_LENGTH 1024

#define SR_CRYPTO_KEYBLOCK_BYTES SR_CRYPTO_MAXKEYS * SR_CRYPTO_KEYBYTES

#ifdef BIOS_DEBUG
void
printhex(const char *s, const u_int8_t *buf, size_t len)
{
	u_int8_t n1, n2;
	size_t i;

	printf("%s: ", s);
	for (i = 0; i < len; i++) {
		n1 = buf[i] & 0x0f;
		n2 = buf[i] >> 4;
		printf("%c", n2 > 9 ? n2 + 'a' - 10 : n2 + '0');
		printf("%c", n1 > 9 ? n1 + 'a' - 10 : n1 + '0');
	}
	printf("\n");
}
#endif

void
sr_clear_keys(void)
{
	struct sr_boot_volume *bv;

	SLIST_FOREACH(bv, &sr_volumes, sbv_link) {
		if (bv->sbv_level != 'C')
			continue;
		if (bv->sbv_keys != NULL) {
			explicit_bzero(bv->sbv_keys, SR_CRYPTO_KEYBLOCK_BYTES);
			free(bv->sbv_keys, 0);
			bv->sbv_keys = NULL;
		}
		if (bv->sbv_maskkey != NULL) {
			explicit_bzero(bv->sbv_maskkey, SR_CRYPTO_MAXKEYBYTES);
			free(bv->sbv_maskkey, 0);
			bv->sbv_maskkey = NULL;
		}
	}
}

void
sr_crypto_calculate_check_hmac_sha1(u_int8_t *maskkey, int maskkey_size,
    u_int8_t *key, int key_size, u_char *check_digest)
{
	u_int8_t check_key[SHA1_DIGEST_LENGTH];
	SHA1_CTX shactx;

	explicit_bzero(check_key, sizeof(check_key));
	explicit_bzero(&shactx, sizeof(shactx));

	/* k = SHA1(mask_key) */
	SHA1Init(&shactx);
	SHA1Update(&shactx, maskkey, maskkey_size);
	SHA1Final(check_key, &shactx);

	/* mac = HMAC_SHA1_k(unencrypted key) */
	hmac_sha1(key, key_size, check_key, sizeof(check_key), check_digest);

	explicit_bzero(check_key, sizeof(check_key));
	explicit_bzero(&shactx, sizeof(shactx));
}

int
sr_crypto_decrypt_keys(struct sr_boot_volume *bv)
{
	struct sr_meta_crypto *cm;
	struct sr_meta_opt_item *omi;
	struct sr_crypto_kdf_pbkdf2 *kdfhint;
	struct sr_crypto_kdfinfo kdfinfo;
	char passphrase[PASSPHRASE_LENGTH];
	u_int8_t digest[SHA1_DIGEST_LENGTH];
	u_int8_t *keys = NULL;
	u_int8_t *kp, *cp;
	rijndael_ctx ctx;
	int rv = -1;
	int c, i;

	SLIST_FOREACH(omi, &bv->sbv_meta_opt, omi_link)
		if (omi->omi_som->som_type == SR_OPT_CRYPTO)
			break;

	if (omi == NULL) {
		printf("Crypto metadata not found!\n");
		goto done;
	}

	cm = (struct sr_meta_crypto *)omi->omi_som;
	kdfhint = (struct sr_crypto_kdf_pbkdf2 *)&cm->scm_kdfhint;

	switch (cm->scm_mask_alg) {
	case SR_CRYPTOM_AES_ECB_256:
		break;
	default:
		printf("unsupported encryption algorithm %u\n",
		    cm->scm_mask_alg);
		goto done;
	}

	printf("Passphrase: ");
	i = 0;
	for (i = 0; i < PASSPHRASE_LENGTH - 1; i++) {
		c = cngetc();
		if (c == '\r' || c == '\n')
			break;
		passphrase[i] = (c & 0xff);
	}
	passphrase[i] = 0;
	printf("\n");

#ifdef BIOS_DEBUG
	printf("Got passphrase: %s with len %d\n",
	    passphrase, strlen(passphrase));
#endif

	if (pkcs5_pbkdf2(passphrase, strlen(passphrase), kdfhint->salt,
	    sizeof(kdfhint->salt), kdfinfo.maskkey, sizeof(kdfinfo.maskkey),
	    kdfhint->rounds) != 0) {
		printf("pbkdf2 failed\n");
		goto done;
	}

	/* kdfinfo->maskkey now has key. */

	/* Decrypt disk keys. */
	keys = alloc(SR_CRYPTO_KEYBLOCK_BYTES);
	bzero(keys, SR_CRYPTO_KEYBLOCK_BYTES);

	if (rijndael_set_key(&ctx, kdfinfo.maskkey, 256) != 0)
		goto done;

	cp = (u_int8_t *)cm->scm_key;
	kp = keys;
	for (i = 0; i < SR_CRYPTO_KEYBLOCK_BYTES; i += RIJNDAEL128_BLOCK_LEN)
		rijndael_decrypt(&ctx, (u_char *)(cp + i), (u_char *)(kp + i));

	/* Check that the key decrypted properly. */
	sr_crypto_calculate_check_hmac_sha1(kdfinfo.maskkey,
	    sizeof(kdfinfo.maskkey), keys, SR_CRYPTO_KEYBLOCK_BYTES, digest);

	if (bcmp(digest, cm->chk_hmac_sha1.sch_mac, sizeof(digest))) {
		printf("incorrect passphrase\n");
		goto done;
	}

	/* Keys will be cleared before boot and from _rtt. */
	bv->sbv_keys = keys;
	bv->sbv_maskkey = alloc(sizeof(kdfinfo.maskkey));
	bcopy(&kdfinfo.maskkey, bv->sbv_maskkey, sizeof(kdfinfo.maskkey));

	rv = 0;

done:
	explicit_bzero(passphrase, PASSPHRASE_LENGTH);
	explicit_bzero(&kdfinfo, sizeof(kdfinfo));
	explicit_bzero(digest, sizeof(digest));

	if (keys != NULL && rv != 0) {
		explicit_bzero(keys, SR_CRYPTO_KEYBLOCK_BYTES);
		free(keys, 0);
	}

	return (rv);
}
#endif
@


1.17
log
@Teach OpenBSD/amd64 boot(8) how to access softraid(8) volumes. This
allows a kernel to be loaded from a softraid RAID 1 volume. Furthermore,
if you boot from a disk that is a member of a bootable softraid volume
then it will default to booting from the softraid volume (sr[0-9]a:/bsd).

Discussed with deraadt@@
@
text
@d40 2
d44 7
a50 1
#include "biosdev.h"
d64 4
d534 6
d728 1
a728 1
	nsect = (size + DEV_BSIZE-1) / DEV_BSIZE;
d771 8
d806 1
d808 34
a841 3
		printf("mmmm... crypto!\n");
		return ENOTSUP;
	} else 
d892 171
@


1.16
log
@Warn about but don't prevent installboot from installing /boot when
the OpenBSD partition starts at >128G. This restores previous
behaviour but adds the warning.

ok deraadt@@ guenther@@
@
text
@d34 4
a39 2
#include <lib/libsa/saerrno.h>
#include <isofs/cd9660/iso.h>
d52 4
a59 8
#if 0
struct biosdisk {
	bios_diskinfo_t *bios_info;
	dev_t	bsddev;
	struct disklabel disklabel;
};
#endif

d342 1
a342 1
 * Try to read the bsd label on the given BIOS device
d458 2
a459 2
	va_list ap;
	register char	*cp, **file;
d462 4
a465 1
	int biosdev;
a476 8
	/* search for device specification */
	cp += 2;
	if (cp[2] != ':') {
		if (cp[3] != ':')
			return ENOENT;
		else
			cp++;
	}
d478 9
a486 9
	for (maj = 0; maj < nbdevs && strncmp(*file, bdevs[maj], cp - *file); )
	    maj++;
	if (maj >= nbdevs) {
		printf("Unknown device: ");
		for (cp = *file; *cp != ':'; cp++)
			putchar(*cp);
		putchar('\n');
		return EADAPT;
	}
d488 1
a488 1
	/* get unit */
d495 2
a496 1
	/* get partition */
d500 1
a500 1
		printf("Bad partition id\n");
d504 1
d511 47
d601 1
a601 2
		const char *st = bios_getdisklabel(&dip->bios_info,
		    &dip->disklabel);
d706 4
d711 1
a711 3
	if (rsize != NULL)
		blk += dip->disklabel.
			d_partitions[B_PARTITION(dip->bsddev)].p_offset;
d745 88
@


1.15
log
@Make the various findopenbsd() functions non-recursive, eliminating
a global, a couple of parameters, and opening up possibility of
traversing much longer EBR lists without blowing the stack.

Make seach algorithm the same as used in kern/subr_disk.c by checking
all primary partitions in the MBR/EBR before moving to next EBR. This
makes it more likely that everybody finds the same OpenBSD partition.

Largely from a diff posted to tech@@ by ucsavl.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.14 2011/03/15 14:00:26 krw Exp $	*/
a217 4

	/* Some (most?) BIOSen get confused by i/o above 2 ^ 28 - 1 sector. */
	if ((daddr + nblk) > BOOTBIOS_MAXSEC)
		return (1); /* Invalid function/parameter. */
@


1.14
log
@Bunch of white space and style adjustments to make amd64 version
the same as i386 version. No change to .o file except for the one
%lld -> %u format fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.13 2011/03/14 22:14:40 krw Exp $	*/
d48 1
a48 1
static u_int findopenbsd(bios_diskinfo_t *, u_int, const char **, int *);
a52 1
u_int mbr_eoff;			/* Offset of MBR extended partition. */
d351 1
a351 1
findopenbsd(bios_diskinfo_t *bd, u_int mbroff, const char **err, int *n)
d355 3
a357 2
	u_int start = (u_int)-1;
	int error, i;
d359 2
a360 2
	/* Limit the number of recursions */
	if (!(*n)--) {
d380 1
d396 1
a396 2
			start = dp->dp_start + mbroff;
			break;
d399 9
a407 3
		if (dp->dp_typ == DOSPTYP_EXTEND ||
		    dp->dp_typ == DOSPTYP_EXTENDL) {
			mbroff = dp->dp_start + mbr_eoff;
a409 5
			if (mbroff < dp->dp_start)
				continue;
			start = findopenbsd(bd, mbroff, err, n);
			if (start != (u_int)-1)
				break;
d413 6
a418 1
	return (start);
a427 1
	int n = 8;
d436 1
a436 2
		mbr_eoff = DOSBBSECTOR;
		start = findopenbsd(bd, DOSBBSECTOR, &err, &n);
@


1.13
log
@Clamp BIOS io attempts to < 2 ^28 - 1 sectors (a.k.a. 128GB for
512-byte sectors) as some BIOSen get confused when we ask for sectors
higher up.

Uss u_int throughout the boot code to calculate sector addresses,
since 32 bits is enough to do 28  ^ 1 - 1 arithmetic. Add checks
for wraparound.

I can now install and boot from the 7th extended partition below
128GB.

Much feedback & guidance from deraadt@@. Also from weingart@@ on
BIOS io.

ok deraadt@@ (less a couple of minor tweaks found in testing)
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.12 2011/03/13 00:13:52 deraadt Exp $	*/
d64 7
a70 7
	u_int8_t  edd_len;   /* size of packet */
	u_int8_t  edd_res1;  /* reserved */
	u_int8_t  edd_nblk;  /* # of blocks to transfer */
	u_int8_t  edd_res2;  /* reserved */
	u_int16_t edd_off;   /* address of buffer (offset) */
	u_int16_t edd_seg;   /* address of buffer (segment) */
	u_int64_t edd_daddr; /* starting block */
d80 1
d82 3
a84 2
			  : "0" (0), "d" (dev) : "%ecx", "cc");
	return (rv & 0xff)? rv >> 8 : 0;
d105 7
a111 7
			  "setc %b0; movzbl %h1, %1\n\t"
			  "movzbl %%cl, %3; andb $0x3f, %b3\n\t"
			  "xchgb %%cl, %%ch; rolb $2, %%ch"
			  : "=a" (rv), "=d" (pdi->bios_heads),
			    "=c" (pdi->bios_cylinders),
			    "=b" (pdi->bios_sectors)
			  : "0" (0x0800), "1" (dev) : "cc");
d117 1
a117 1
			pdi->bios_heads, pdi->bios_sectors);
d121 1
a121 1
		return (1);
d176 1
a176 1
		return(1);
d180 1
a180 1
		return(1);
d182 1
a182 1
	return(0);
d196 14
a209 14
			  "movb %b6, %%dh\n\t"
			  "andl $0xf, %4\n\t"
			  /* cylinder; the highest 2 bits of cyl is in %cl */
			  "xchgb %%ch, %%cl\n\t"
			  "rorb  $2, %%cl\n\t"
			  "orb %b5, %%cl\n\t"
			  "inc %%cx\n\t"
			  DOINT(0x13) "\n\t"
			  "setc %b0"
			  : "=a" (rv)
			  : "0" (nsect), "d" (dev), "c" (cyl),
			    "b" (buf), "m" (sect), "m" (head),
			    "m" (rw)
			  : "cc", "memory");
d211 1
a211 1
	return (rv & 0xff)? rv >> 8 : 0;
d237 1
a237 1
		return (1);
d242 3
a244 3
			  : "0" ((rw == F_READ)? 0x4200: 0x4300),
			    "d" (dev), "S" ((int) (&cb) & 0xf) : "%ecx", "cc");
	return (rv & 0xff)? rv >> 8 : 0;
d427 1
a427 1
		return("failed to read disklabel");
d445 1
a445 1
		printf("loading disklabel @@ %u\n", off);
d450 2
a451 2
	if(error)
		return("failed to read disklabel");
d462 1
a462 1
	dev_t	maj, unit, part;
d485 2
a486 2
	for (maj = 0; maj < nbdevs &&
	     strncmp(*file, bdevs[maj], cp - *file); maj++);
d509 1
a509 1
		
d539 1
a539 1
			B_CONTROLLER(bsd_dev), unit, part);
d541 1
a541 1
			B_CONTROLLER(bsd_dev), B_UNIT(bsd_dev), part);
d552 2
a553 2
			dip->bios_info.bios_heads, dip->bios_info.bios_sectors,
			dip->bios_info.bios_edd);
d558 1
a558 1
	if(dip->bios_info.flags & BDI_BADLABEL){
d569 1
a569 1
			return (ERDLAB);
d619 1
a619 1
		while(*p++);
d637 1
a637 1
	{ 0x20, EHER },	
d648 1
a648 1
	if (!error)
d687 1
a687 1
	return biosdisk_errno(error);
d694 1
a702 1

@


1.12
log
@Change daddr_t to daddr32_t.  The bootblocks on our architectures only
do 32-bit block spanning.  If later on we get some that can/should do
64-bit, that can be done now using daddr64_t (but of course, we are taking
this step to finalize the daddr_t 64-bit conversion).
ok miod krw
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.11 2011/03/11 21:08:25 krw Exp $	*/
d46 1
a46 1
static int EDD_rw (int, int, u_int64_t, u_int32_t, void *);
d48 1
a48 2
static daddr64_t findopenbsd(bios_diskinfo_t *, daddr64_t, const char **,
    int *);
d53 1
a53 1
daddr64_t mbr_eoff;		/* Offset of the MBR extended partition. */
d213 1
a213 1
EDD_rw(int rw, int dev, u_int64_t daddr, u_int32_t nblk, void *buf)
d218 4
d249 1
a249 1
biosd_io(int rw, bios_diskinfo_t *bd, daddr32_t off, int nsect, void *buf)
d349 2
a350 2
static daddr64_t
findopenbsd(bios_diskinfo_t *bd, daddr64_t mbroff, const char **err, int *n)
d354 1
a354 1
	daddr64_t start = -1;
d391 3
a393 1
			start = (daddr64_t)dp->dp_start + mbroff;
d399 5
a403 3
			mbroff = (daddr64_t)dp->dp_start + mbr_eoff;
			if (!mbr_eoff)
				mbr_eoff = (daddr64_t)dp->dp_start;
d405 1
a405 1
			if (start != -1)
d416 1
a416 1
	daddr64_t start = 0;
d429 3
a431 3
		mbr_eoff = 0;
		start = findopenbsd(bd, (daddr64_t)DOSBBSECTOR, &err, &n);
		if (start == -1) {
d446 1
a446 1
	error = biosd_io(F_READ, bd, (daddr32_t)start, 1, buf);
d669 4
a672 1
	error = biosd_io(rw, bd, blk, nsect, buf);
@


1.11
log
@Zap stack garbage before passing buffer to biosd_io(), which may
be lied to by the BIOS about successfully reading data.

ok deraadt@@ weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.10 2011/03/08 17:24:31 krw Exp $	*/
d246 1
a246 1
biosd_io(int rw, bios_diskinfo_t *bd, daddr_t off, int nsect, void *buf)
d439 1
a439 1
	error = biosd_io(F_READ, bd, (daddr_t)start, 1, buf);
d648 1
a648 1
biosstrategy(void *devdata, int rw, daddr_t blk, size_t size, void *buf,
@


1.10
log
@Fix extended partition searching so we don't get lost. The offset
of the next EBR is relative to the start of the extended partition
described in the first MBR, not relative to the EBR specifying the
offset in its extended partition entry.

Clean up installboot -v output. Use daddr64_t for all sector numbers.

Not a complete fix, but better than what we had. More tweaks to
come.

Inspired by a diff and cluebat from uscav on tech@@ a few weeks
ago.

Feedback from matthew@@, weingart@@.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.9 2010/08/11 13:11:59 deraadt Exp $	*/
d361 1
@


1.9
log
@De-inline CHS_rw.  Somehow the merger of two monster __asm __inline statements
into one function is generating broken code; it might be because of missing
register clobbers.
This is a workaround... it'd be nice to know the real problem
work done with mlarkin and pirofti
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.8 2008/08/12 22:48:32 deraadt Exp $	*/
d48 2
a49 1
static daddr_t findopenbsd(bios_diskinfo_t *, daddr_t, const char **, int *);
d54 1
d346 2
a347 2
static daddr_t
findopenbsd(bios_diskinfo_t *bd, daddr_t mbroff, const char **err, int *n)
a348 1
	int error, i;
d351 2
a352 1
	daddr_t off;
d387 5
a391 2
			return (dp->dp_start + mbroff);
		} else if (dp->dp_typ == DOSPTYP_EXTEND ||
d393 6
a398 3
			off = findopenbsd(bd, dp->dp_start + mbroff, err, n);
			if (off != -1)
				return (off);
d402 1
a402 1
	return (-1);
d408 1
a408 1
	daddr_t off = 0;
d421 3
a423 2
		off = findopenbsd(bd, DOSBBSECTOR, &err, &n);
		if (off == -1) {
d429 1
a429 1
	off = LABELSECTOR + off;
d438 1
a438 1
	error = biosd_io(F_READ, bd, off, 1, buf);
@


1.8
log
@Fix multiple addition error recently introduced for when extended partitions
are just before an OpenBSD partition in a MBR; done with kettenis & otto
ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.7 2008/08/04 15:58:13 reyk Exp $	*/
d45 1
a45 1
static int CHS_rw (int, int, int, int, int, int, void *);
d185 1
a185 1
static __inline int
@


1.7
log
@fix extended partition support by handling chained EBRs correctly
(using a recursion limit).  now OpenBSD can be installed in a
subsequent DOS/Linux-compatible extended partition.

ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.6 2008/06/25 15:32:18 reyk Exp $	*/
d345 1
a345 1
findopenbsd(bios_diskinfo_t *bd, daddr_t off, const char **err, int *n)
d350 1
d355 1
a355 1
		return (0);
d359 1
a359 1
	error = biosd_io(F_READ, bd, off, 1, &mbr);
d362 1
a362 1
		return (0);
d368 1
a368 1
		return (0);
d374 2
d385 1
a385 2
			off = dp->dp_start + off;
			break;
d388 3
a390 3
			off = findopenbsd(bd, dp->dp_start + off, err, n);
			if (off != 0)
				break;
d394 1
a394 12
#ifdef BIOS_DEBUG
	if (debug)
		printf("using offset %u\n", off);
#endif

	if (off == 0) {
		if (*err == NULL)
			*err = "no OpenBSD partition\n";
		return (0);
	}

	return (off);
d414 1
a414 1
		if (off == 0) {
@


1.6
log
@this diff changes the bootloader to skip the CHS sanity check if LBA
(EDD) is found and OK. it will also fix chainloading into OpenBSD from
grub in a few scenarios where grub doesn't report the CHS correctly
but the LBA. and we don't need CHS if there is LBA.

this has been in the snapshots for a while.

with input from weingart@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.5 2008/06/25 15:26:44 reyk Exp $	*/
d48 1
a48 2
static daddr_t findopenbsd(bios_diskinfo_t *, daddr_t, daddr_t *,
    const char **, int *);
d345 1
a345 2
findopenbsd(bios_diskinfo_t *bd, daddr_t off, daddr_t *roff, const char **err,
    int *n)
d371 1
a371 1
	for (off = 0, i = 0; off == 0 && i < NDOSPART; i++) {
d381 4
a384 3
		if (dp->dp_typ == DOSPTYP_OPENBSD)
			off = dp->dp_start;
		else if (dp->dp_typ == DOSPTYP_EXTEND ||
d386 1
a386 1
			off = findopenbsd(bd, dp->dp_start, roff, err, n);
d388 1
a388 1
				*roff = dp->dp_start;
d409 1
a409 1
	daddr_t off = 0, roff = 0;
d422 1
a422 1
		off = findopenbsd(bd, DOSBBSECTOR, &roff, &err, &n);
d429 1
a429 1
	off = LABELSECTOR + off + roff;
@


1.5
log
@allow to install and boot the OpenBSD A6 partition and disklabel in an
extended DOS partition.  the concept of extended partitions is very
simple, it is just another mbr at the partition offset (well, the
standard "EBR" is a linked list with a few limitations, but this diff
works with both variants).

this diff has been in the snapshots for a while.

with input from weingart@@ and krw@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.4 2007/04/04 14:36:05 jmc Exp $	*/
a126 8
	/* Sanity check */
	if (!pdi->bios_cylinders || !pdi->bios_heads || !pdi->bios_sectors)
		return(1);

	/* CD-ROMs sometimes return heads == 1 */
	if (pdi->bios_heads < 2)
		return(1);

d168 12
d417 2
a418 1
	if(bd->bios_heads == 0 || bd->bios_sectors == 0)
@


1.4
log
@Thinkpad -> ThinkPad; from Igor Sobrado
ok millert jasper mbalmer
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.3 2006/10/12 12:14:17 krw Exp $	*/
d48 3
d341 62
d406 1
a406 1
	daddr_t off = LABELSECTOR;
d408 3
a410 2
	struct dos_mbr mbr;
	int error, i;
d418 8
a425 17
		/* Read MBR */
		error = biosd_io(F_READ, bd, DOSBBSECTOR, 1, &mbr);
		if (error)
			return(biosdisk_err(error));

		/* check mbr signature */
		if (mbr.dmbr_sign != DOSMBR_SIGNATURE)
			return("bad MBR signature\n");

		/* Search for OpenBSD partition */
		for (off = 0, i = 0; off == 0 && i < NDOSPART; i++)
			if (mbr.dmbr_parts[i].dp_typ == DOSPTYP_OPENBSD)
				off = mbr.dmbr_parts[i].dp_start + LABELSECTOR;
		if (off == 0)
			return("no OpenBSD partition\n");
	} else
		off = LABELSECTOR;
@


1.3
log
@Don't try to boot from a NetBSD MBR partition when no OpenBSD MBR
partition is found. Change error message to 'no OpenBSD partition'.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.2 2004/08/21 18:53:38 tom Exp $	*/
d134 1
a134 1
	 * The IBM Thinkpad 750ED for one.
@


1.2
log
@Enter cdboot, a CD-specific second-stage bootrap.  Based on the i386
cdboot that Toby and I put together at the hackathon.

"go for it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.1 2004/02/03 12:09:47 mickey Exp $	*/
a364 7

		/* just in case */
		if (off == 0)
			for (off = 0, i = 0; off == 0 && i < NDOSPART; i++)
				if (mbr.dmbr_parts[i].dp_typ == DOSPTYP_NETBSD)
					off = mbr.dmbr_parts[i].dp_start + LABELSECTOR;

d366 1
a366 1
			return("no BSD partition\n");
@


1.1
log
@das boot; das cloned das from das i386
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.67 2003/11/27 00:33:24 espie Exp $	*/
d17 2
a18 2
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
d37 1
d50 1
d243 1
d245 20
a264 3
	/* use a bounce buffer to not cross 64k DMA boundary */
	if ((((u_int32_t)buf) & ~0xffff) !=
	    (((u_int32_t)buf + nsect * DEV_BSIZE) & ~0xffff)) {
d269 1
a269 1
		bb = alloca(nsect * DEV_BSIZE);
d271 1
a271 1
			bcopy (buf, bb, nsect * DEV_BSIZE);
d276 1
a276 1
	for (error = 1, j = 5; j-- && error;) {
d287 4
a290 1
 					i += n, off += n, p += n * DEV_BSIZE) {
a291 1
				btochs(off, cyl, head, sect, bd->bios_heads, bd->bios_sectors);
d314 1
a314 1
					error, biosdisk_err(error));
d322 1
a322 1
		bcopy (bb, buf, nsect * DEV_BSIZE);
d332 1
a332 1
	return (error);
d421 1
a421 1
	for (maj = 0; maj < nbdevs && 
d461 3
d513 1
a513 1
const u_char bidos_errs[] = 
@

