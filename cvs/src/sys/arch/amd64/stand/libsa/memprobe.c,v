head	1.17;
access;
symbols
	OPENBSD_6_1:1.17.0.4
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.17.0.2
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.13.0.8
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.12.0.6
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.11.0.2
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.10.0.8
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.6
	OPENBSD_5_0:1.10.0.4
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.2
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.7.0.2
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.5.0.14
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.10
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.8
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.6
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.4
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.2
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.4.0.4
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.6
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.2
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.1.0.8
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.6
	OPENBSD_3_6_BASE:1.1
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	OPENBSD_3_5:1.1.0.4
	OPENBSD_3_5_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.17
date	2016.06.10.18.36.06;	author jcs;	state Exp;
branches;
next	1.16;
commitid	x57WcyDUhZLxQO5Z;

1.16
date	2015.10.08.14.46.05;	author tedu;	state Exp;
branches;
next	1.15;
commitid	8K1b8WK0PMVfXg5l;

1.15
date	2015.09.18.13.30.56;	author miod;	state Exp;
branches;
next	1.14;
commitid	1BEcCDYd9p5DIl0g;

1.14
date	2015.09.02.01.52.26;	author yasuoka;	state Exp;
branches;
next	1.13;
commitid	CUwlbzT4LejFC15d;

1.13
date	2014.03.29.18.09.28;	author guenther;	state Exp;
branches;
next	1.12;

1.12
date	2013.03.21.21.51.00;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2012.10.30.14.06.29;	author jsing;	state Exp;
branches;
next	1.10;

1.10
date	2010.12.06.22.51.45;	author jasper;	state Exp;
branches;
next	1.9;

1.9
date	2010.12.06.22.11.01;	author jasper;	state Exp;
branches;
next	1.8;

1.8
date	2010.12.06.18.44.49;	author jasper;	state Exp;
branches;
next	1.7;

1.7
date	2010.07.02.00.36.52;	author weingart;	state Exp;
branches;
next	1.6;

1.6
date	2009.11.30.16.33.20;	author canacar;	state Exp;
branches;
next	1.5;

1.5
date	2006.09.18.21.15.33;	author mpf;	state Exp;
branches;
next	1.4;

1.4
date	2005.05.28.05.47.33;	author weingart;	state Exp;
branches;
next	1.3;

1.3
date	2005.05.03.13.18.05;	author tom;	state Exp;
branches;
next	1.2;

1.2
date	2005.05.03.13.02.45;	author tom;	state Exp;
branches;
next	1.1;

1.1
date	2004.02.03.12.09.47;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.17
log
@fix some typos in comments

from Tom Cosgrove
@
text
@/*	$OpenBSD: memprobe.c,v 1.16 2015/10/08 14:46:05 tedu Exp $	*/

/*
 * Copyright (c) 1997-1999 Michael Shalayeff
 * Copyright (c) 1997-1999 Tobias Weingartner
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <machine/biosvar.h>
#include <dev/isa/isareg.h>
#include <stand/boot/bootarg.h>
#include "libsa.h"

u_int cnvmem, extmem;		/* XXX - compatibility */

bios_memmap_t bios_memmap[64];	/* This is easier */
#ifndef EFIBOOT
/*
 * Check gateA20
 *
 * A sanity check.
 */
static __inline int
checkA20(void)
{
	register char *p = (char *)0x100000;
	register char *q = (char *)0x000000;
	int st;

	/* Simple check */
	if (*p != *q)
		return 1;

	/* Complex check */
	*p = ~(*p);
	st = (*p != *q);
	*p = ~(*p);

	return st;
}

/*
 * BIOS int 15, AX=E820
 *
 * This is the "preferred" method.
 */
static __inline bios_memmap_t *
bios_E820(bios_memmap_t *mp)
{
	int rc, off = 0, sig, gotcha = 0;

	do {
		BIOS_regs.biosr_es = ((u_int)(mp) >> 4);
		__asm volatile(DOINT(0x15) "; setc %b1"
		    : "=a" (sig), "=d" (rc), "=b" (off)
		    : "0" (0xE820), "1" (0x534d4150), "b" (off),
		      "c" (sizeof(*mp)), "D" (((u_int)mp) & 0xf)
		    : "cc", "memory");
		off = BIOS_regs.biosr_bx;

		if (rc & 0xff || sig != 0x534d4150)
			break;
		gotcha++;
		if (!mp->type)
			mp->type = BIOS_MAP_RES;
		mp++;
	} while (off);

	if (!gotcha)
		return NULL;
#ifdef DEBUG
	printf("0x15[E820] ");
#endif
	return mp;
}

/*
 * BIOS int 15, AX=8800
 *
 * Only used if int 15, AX=E801 does not work.
 * Machines with this are restricted to 64MB.
 */
static __inline bios_memmap_t *
bios_8800(bios_memmap_t *mp)
{
	int rc, mem;

	__asm volatile(DOINT(0x15) "; setc %b0"
	    : "=c" (rc), "=a" (mem) : "a" (0x8800));

	if (rc & 0xff)
		return NULL;
#ifdef DEBUG
	printf("0x15[8800] ");
#endif
	/* Fill out a BIOS_MAP */
	mp->addr = 1024 * 1024;		/* 1MB */
	mp->size = (mem & 0xffff) * 1024;
	mp->type = BIOS_MAP_FREE;

	return ++mp;
}

/*
 * BIOS int 0x12 Get Conventional Memory
 *
 * Only used if int 15, AX=E820 does not work.
 */
static __inline bios_memmap_t *
bios_int12(bios_memmap_t *mp)
{
	int mem;
#ifdef DEBUG
	printf("0x12 ");
#endif
	__asm volatile(DOINT(0x12) : "=a" (mem) :: "%ecx", "%edx", "cc");

	/* Fill out a bios_memmap_t */
	mp->addr = 0;
	mp->size = (mem & 0xffff) * 1024;
	mp->type = BIOS_MAP_FREE;

	return ++mp;
}


/*
 * addrprobe(kloc): Probe memory at address kloc * 1024.
 *
 * This is a hack, but it seems to work ok.  Maybe this is
 * the *real* way that you are supposed to do probing???
 *
 * Modify the original a bit.  We write everything first, and
 * then test for the values.  This should croak on machines that
 * return values just written on non-existent memory...
 *
 * BTW: These machines are pretty broken IMHO.
 *
 * XXX - Does not detect aliased memory.
 */
const u_int addrprobe_pat[] = {
	0x00000000, 0xFFFFFFFF,
	0x01010101, 0x10101010,
	0x55555555, 0xCCCCCCCC
};
static int
addrprobe(u_int kloc)
{
	volatile u_int *loc;
	register u_int i, ret = 0;
	u_int save[nitems(addrprobe_pat)];

	/* Get location */
	loc = (int *)(intptr_t)(kloc * 1024);

	save[0] = *loc;
	/* Probe address */
	for (i = 0; i < nitems(addrprobe_pat); i++) {
		*loc = addrprobe_pat[i];
		if (*loc != addrprobe_pat[i])
			ret++;
	}
	*loc = save[0];

	if (!ret) {
		/* Write address */
		for (i = 0; i < nitems(addrprobe_pat); i++) {
			save[i] = loc[i];
			loc[i] = addrprobe_pat[i];
		}

		/* Read address */
		for (i = 0; i < nitems(addrprobe_pat); i++) {
			if (loc[i] != addrprobe_pat[i])
				ret++;
			loc[i] = save[i];
		}
	}

	return ret;
}

/*
 * Probe for all extended memory.
 *
 * This is only used as a last resort.  If we resort to this
 * routine, we are getting pretty desperate.  Hopefully nobody
 * has to rely on this after all the work above.
 *
 * XXX - Does not detect aliased memory.
 * XXX - Could be destructive, as it does write.
 */
static __inline bios_memmap_t *
badprobe(bios_memmap_t *mp)
{
	u_int64_t ram;
#ifdef DEBUG
	printf("scan ");
#endif
	/*
	 * probe extended memory
	 *
	 * There is no need to do this in assembly language.  This is
	 * much easier to debug in C anyways.
	 */
	for (ram = 1024; ram < 512 * 1024; ram += 4)
		if (addrprobe(ram))
			break;

	mp->addr = 1024 * 1024;
	mp->size = (ram - 1024) * 1024;
	mp->type = BIOS_MAP_FREE;

	return ++mp;
}

void
memprobe(void)
{
	bios_memmap_t *pm = bios_memmap, *im;

#ifdef DEBUG
	printf(" mem(");
#else
	printf(" mem[");
#endif

	if ((pm = bios_E820(bios_memmap)) == NULL) {
		im = bios_int12(bios_memmap);
		pm = bios_8800(im);
		if (pm == NULL)
			pm = badprobe(im);
		if (pm == NULL) {
			printf(" No Extended memory detected.");
			pm = im;
		}
	}
	pm->type = BIOS_MAP_END;

	/* XXX - gotta peephole optimize the list */

#ifdef DEBUG
	printf(")[");
#endif

	/* XXX - Compatibility, remove later (smpprobe() relies on it) */
	extmem = cnvmem = 0;
	for (im = bios_memmap; im->type != BIOS_MAP_END; im++) {
		/* Count only "good" memory chunks 12K and up in size */
		if ((im->type == BIOS_MAP_FREE) && (im->size >= 12 * 1024)) {
			if (im->size > 1024 * 1024)
				printf("%uM ", (u_int)(im->size /
				    (1024 * 1024)));
			else
				printf("%uK ", (u_int)im->size / 1024);

			/*
			 * Compute compatibility values:
			 * cnvmem -- is the upper boundary of conventional
			 *	memory (below IOM_BEGIN (=640k))
			 * extmem -- is the size of the contiguous extended
			 *	memory segment starting at 1M
			 *
			 * We ignore "good" memory in the 640K-1M hole.
			 * We drop "machine {cnvmem,extmem}" commands.
			 */
			if (im->addr < IOM_BEGIN)
				cnvmem = max(cnvmem,
				    im->addr + im->size) / 1024;
			if (im->addr >= IOM_END &&
			    (im->addr / 1024) == (extmem + 1024))
				extmem += im->size / 1024;
		}
	}

	/*
	 * Adjust extmem to be no more than 4G (which it usually is not
	 * anyways).  In order for an x86 type machine (amd64/etc) to use
	 * more than 4GB of memory, it will need to grok and use the bios
	 * memory map we pass it.  Note that above we only count CONTIGUOUS
	 * memory from the 1MB boundary on for extmem (think I/O holes).
	 *
	 * extmem is in KB, and we have 4GB - 1MB (base/io hole) worth of it.
	 */
	if (extmem > 4 * 1024 * 1024 - 1024)
		extmem = 4 * 1024 * 1024 - 1024;

	/* Check if gate A20 is on */
	printf("a20=o%s] ", checkA20()? "n" : "ff!");
}
#endif

void
dump_biosmem(bios_memmap_t *tm)
{
	register bios_memmap_t *p;
	register u_int total = 0;

	if (tm == NULL)
		tm = bios_memmap;

	for (p = tm; p->type != BIOS_MAP_END; p++) {
		printf("Region %ld: type %u at 0x%llx for %uKB\n",
		    (long)(p - tm), p->type, p->addr,
		    (u_int)(p->size / 1024));

		if (p->type == BIOS_MAP_FREE)
			total += p->size / 1024;
	}

	printf("Low ram: %dKB  High ram: %dKB\n", cnvmem, extmem);
	printf("Total free memory: %uKB\n", total);
}

int
mem_limit(long long ml)
{
	register bios_memmap_t *p;

	for (p = bios_memmap; p->type != BIOS_MAP_END; p++) {
		register int64_t sp = p->addr, ep = p->addr + p->size;

		if (p->type != BIOS_MAP_FREE)
			continue;

		/* Wholly above limit, nuke it */
		if ((sp >= ml) && (ep >= ml)) {
			bcopy (p + 1, p, (char *)bios_memmap +
			       sizeof(bios_memmap) - (char *)p);
		} else if ((sp < ml) && (ep >= ml)) {
			p->size -= (ep - ml);
		}
	}
	return 0;
}

int
mem_delete(long long sa, long long ea)
{
	register bios_memmap_t *p;

	for (p = bios_memmap; p->type != BIOS_MAP_END; p++) {
		if (p->type == BIOS_MAP_FREE) {
			register int64_t sp = p->addr, ep = p->addr + p->size;

			/* can we eat it as a whole? */
			if ((sa - sp) <= PAGE_SIZE && (ep - ea) <= PAGE_SIZE) {
				bcopy(p + 1, p, (char *)bios_memmap +
				    sizeof(bios_memmap) - (char *)p);
				break;
			/* eat head or legs */
			} else if (sa <= sp && sp < ea) {
				p->addr = ea;
				p->size = ep - ea;
				break;
			} else if (sa < ep && ep <= ea) {
				p->size = sa - sp;
				break;
			} else if (sp < sa && ea < ep) {
				/* bite in half */
				bcopy(p, p + 1, (char *)bios_memmap +
				    sizeof(bios_memmap) - (char *)p -
				    sizeof(bios_memmap[0]));
				p[1].addr = ea;
				p[1].size = ep - ea;
				p->size = sa - sp;
				break;
			}
		}
	}
	return 0;
}

int
mem_add(long long sa, long long ea)
{
	register bios_memmap_t *p;

	for (p = bios_memmap; p->type != BIOS_MAP_END; p++) {
		if (p->type == BIOS_MAP_FREE) {
			register int64_t sp = p->addr, ep = p->addr + p->size;

			/* is it already there? */
			if (sp <= sa && ea <= ep) {
				break;
			/* join head or legs */
			} else if (sa < sp && sp <= ea) {
				p->addr = sa;
				p->size = ep - sa;
				break;
			} else if (sa <= ep && ep < ea) {
				p->size = ea - sp;
				break;
			} else if (ea < sp) {
				/* insert before */
				bcopy(p, p + 1, (char *)bios_memmap +
				    sizeof(bios_memmap) - (char *)(p - 1));
				p->addr = sa;
				p->size = ea - sa;
				break;
			}
		}
	}

	/* meaning add new item at the end of the list */
	if (p->type == BIOS_MAP_END) {
		p[1] = p[0];
		p->type = BIOS_MAP_FREE;
		p->addr = sa;
		p->size = ea - sa;
	}

	return 0;
}

void
mem_pass(void)
{
	bios_memmap_t *p;

	for (p = bios_memmap; p->type != BIOS_MAP_END; p++)
		;
	addbootarg(BOOTARG_MEMMAP, (p - bios_memmap + 1) * sizeof *bios_memmap,
	    bios_memmap);
}
@


1.16
log
@16 years after E801 memprobe was disabled, probably safe to delete it.
ok deraadt jung kettenis ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.15 2015/09/18 13:30:56 miod Exp $	*/
d284 1
a284 1
			 * extmem -- is the size of the contignous extended
d349 1
a349 1
		/* Wholy above limit, nuke it */
@


1.15
log
@Remove support for building the boot blocks with DEBUGFLAGS=-D_TEST, which is
supposed to create a userland binary in order to test non-boot related
functionality. This feature has been bitrotting in a non-compiling state
for years, and causes a too-many-ifdefs disease now that there are intrusive
EFI changes.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.14 2015/09/02 01:52:26 yasuoka Exp $	*/
a99 59
#if 0
/*
 * BIOS int 15, AX=E801
 *
 * Only used if int 15, AX=E820 does not work.
 * This should work for more than 64MB on most
 * modern machines.  However, there is always
 * an exception, the older IBM machine do not
 * like this call.
 */
static __inline bios_memmap_t *
bios_E801(bios_memmap_t *mp)
{
	int rc, m1, m2, m3, m4;
	u_int8_t *info;

	/* Test for possibility of 0xE801 */
	info =  getSYSCONFaddr();
	if (!info)
		return NULL;
	/* XXX - Should test model/submodel/rev here */
	printf("model(%d,%d,%d)", info[2], info[3], info[4]);

	/* Check for 94 or later bios */
	info = (void *)0xFFFFB;
	if (info[0] == '9' && info[1] <= '3')
		return NULL;

	/* We might have this call */
	__asm volatile(DOINT(0x15) "; mov %%ax, %%si; setc %b0"
	    : "=a" (rc), "=S" (m1), "=b" (m2), "=c" (m3), "=d" (m4)
	    : "0" (0xE801));

	/* Test for failure */
	if (rc & 0xff)
		return NULL;

	/* Fixup for screwed up machines */
	if (m1 == 0) {
		m1 = m3;
		m2 = m4;
	}
#ifdef DEBUG
	printf("0x15[E801] ");
#endif
	/* Fill out BIOS map */
	mp->addr = (1024 * 1024);	/* 1MB */
	mp->size = (m1 & 0xffff) * 1024;
	mp->type = BIOS_MAP_FREE;

	mp++;
	mp->addr = (1024 * 1024) * 16;	/* 16MB */
	mp->size = (m2 & 0xffff) * 64L * 1024;
	mp->type = BIOS_MAP_FREE;

	return ++mp;
}
#endif

d253 1
a253 5
#if 0
		pm = bios_E801(im);
		if (pm == NULL)
#endif
			pm = bios_8800(im);
@


1.14
log
@Initial commit of uefi boot loader of OpenBSD.

ok deraadt yuo
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.13 2014/03/29 18:09:28 guenther Exp $	*/
a298 1
#ifndef _TEST
a376 1
#endif
@


1.13
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.12 2013/03/21 21:51:00 deraadt Exp $	*/
d39 2
a40 1

d236 1
a236 1
	loc = (int *)(kloc * 1024);
a298 1
bios_memmap_t bios_memmap[64];	/* This is easier */
d378 1
@


1.12
log
@NBPG -> PAGE_SIZE, PGSHIFT -> PAGE_SHIFT, PGOFSET -> PAGE_MASK
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.11 2012/10/30 14:06:29 jsing Exp $	*/
d76 1
a76 1
		__asm __volatile(DOINT(0x15) "; setc %b1"
d128 1
a128 1
	__asm __volatile(DOINT(0x15) "; mov %%ax, %%si; setc %b0"
d169 1
a169 1
	__asm __volatile(DOINT(0x15) "; setc %b0"
d197 1
a197 1
	__asm __volatile(DOINT(0x12) : "=a" (mem) :: "%ecx", "%edx", "cc");
d230 1
a230 1
	__volatile u_int *loc;
@


1.11
log
@Apply a bunch of style(9) and whitespace fixes to i386/amd64 libsa, making
the code actually diffable. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.9 2010/12/06 22:11:01 jasper Exp $	*/
d434 1
a434 1
			if ((sa - sp) <= NBPG && (ep - ea) <= NBPG) {
@


1.10
log
@- properly remove NENTS now after fixing the fallout.

ok deraadt@@
@
text
@d17 2
a18 2
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
d40 2
a41 1
/* Check gateA20
d53 2
a54 2
	if(*p != *q)
		return(1);
d61 1
a61 1
	return(st);
d64 2
a65 1
/* BIOS int 15, AX=E820
d77 5
a81 5
				: "=a" (sig), "=d" (rc), "=b" (off)
				: "0" (0xE820), "1" (0x534d4150), "b" (off),
				  "c" (sizeof(*mp)), "D" (((u_int)mp) & 0xF)
				: "cc", "memory");
			off = BIOS_regs.biosr_bx;
d83 6
a88 6
			if (rc & 0xff || sig != 0x534d4150)
				break;
			gotcha++;
			if (!mp->type)
				mp->type = BIOS_MAP_RES;
			mp++;
d92 1
a92 1
		return (NULL);
d96 1
a96 1
	return (mp);
d100 2
a101 1
/* BIOS int 15, AX=E801
d117 2
a118 1
	if(!info) return(NULL);
d124 2
a125 1
	if(info[0] == '9' && info[1] <= '3') return(NULL);
d129 2
a130 2
		: "=a" (rc), "=S" (m1), "=b" (m2), "=c" (m3), "=d" (m4)
		: "0" (0xE801));
d133 2
a134 2
	if(rc & 0xff)
		return (NULL);
d137 1
a137 1
	if(m1 == 0){
d158 2
a159 1
/* BIOS int 15, AX=8800
d170 1
a170 1
		: "=c" (rc), "=a" (mem) : "a" (0x8800));
d172 2
a173 2
	if(rc & 0xff)
		return (NULL);
d185 2
a186 1
/* BIOS int 0x12 Get Conventional Memory
d208 2
a209 1
/* addrprobe(kloc): Probe memory at address kloc * 1024.
d239 1
a239 1
	for(i = 0; i < nitems(addrprobe_pat); i++){
d241 1
a241 1
		if(*loc != addrprobe_pat[i])
d248 1
a248 1
		for(i = 0; i < nitems(addrprobe_pat); i++) {
d254 2
a255 2
		for(i = 0; i < nitems(addrprobe_pat); i++) {
			if(loc[i] != addrprobe_pat[i])
d264 2
a265 1
/* Probe for all extended memory.
d281 2
a282 1
	/* probe extended memory
d287 2
a288 2
	for(ram = 1024; ram < 512 * 1024; ram += 4)
		if(addrprobe(ram))
d311 1
a311 1
	if(!(pm = bios_E820(bios_memmap))) {
d315 1
a315 1
		if (!pm)
d318 1
a318 1
		if (!pm)
d320 2
a321 2
		if (!pm) {
			printf (" No Extended memory detected.");
d335 1
a335 1
	for(im = bios_memmap; im->type != BIOS_MAP_END; im++) {
d337 1
a337 1
		if ((im->type == BIOS_MAP_FREE) && (im->size >= 12*1024)) {
d354 1
a354 1
			if(im->addr < IOM_BEGIN)
d357 2
a358 2
			if(im->addr >= IOM_END
			    && (im->addr/1024) == (extmem + 1024)) {
a359 1
			}
d363 2
a364 1
	/* Adjust extmem to be no more than 4G (which it usually is not
d372 2
a373 2
	if(extmem > 4*1024*1024 - 1024)
		extmem = 4*1024*1024 - 1024;
d386 1
a386 1
	if (!tm)
d389 2
a390 2
	for(p = tm; p->type != BIOS_MAP_END; p++) {
		printf("Region %ld: type %u at 0x%llx for %uKB\n", 
d394 1
a394 1
		if(p->type == BIOS_MAP_FREE)
d435 2
a436 2
				bcopy (p + 1, p, (char *)bios_memmap +
				       sizeof(bios_memmap) - (char *)p);
d448 3
a450 3
				bcopy (p, p + 1, (char *)bios_memmap +
				       sizeof(bios_memmap) - (char *)p -
				       sizeof(bios_memmap[0]));
d483 2
a484 2
				bcopy (p, p + 1, (char *)bios_memmap +
				       sizeof(bios_memmap) - (char *)(p - 1));
@


1.9
log
@- partially revert previous NENTS removal for arches which got busted.
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.8 2010/12/06 18:44:49 jasper Exp $	*/
d224 1
a224 1
	u_int save[NENTS(addrprobe_pat)];
d231 1
a231 1
	for(i = 0; i < NENTS(addrprobe_pat); i++){
d240 1
a240 1
		for(i = 0; i < NENTS(addrprobe_pat); i++) {
d246 1
a246 1
		for(i = 0; i < NENTS(addrprobe_pat); i++) {
@


1.8
log
@- drop NENTS(), which was yet another copy of nitems().
no binary change


ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.7 2010/07/02 00:36:52 weingart Exp $	*/
d224 1
a224 1
	u_int save[nitems(addrprobe_pat)];
d231 1
a231 1
	for(i = 0; i < nitems(addrprobe_pat); i++){
d240 1
a240 1
		for(i = 0; i < nitems(addrprobe_pat); i++) {
d246 1
a246 1
		for(i = 0; i < nitems(addrprobe_pat); i++) {
@


1.7
log
@Add ability to limit memory presented to kernel with
'machine memory =128M' style commands.  Thanks to
phessler for finding a small man page niggle.  Bumped
version strings to a nice round fraction, and make them
the same across the board.  Easier to identify boot
binary versions that way.

ok thib@@, tedu@@, phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.6 2009/11/30 16:33:20 canacar Exp $	*/
d224 1
a224 1
	u_int save[NENTS(addrprobe_pat)];
d231 1
a231 1
	for(i = 0; i < NENTS(addrprobe_pat); i++){
d240 1
a240 1
		for(i = 0; i < NENTS(addrprobe_pat); i++) {
d246 1
a246 1
		for(i = 0; i < NENTS(addrprobe_pat); i++) {
@


1.6
log
@Bump up array size to prevent overflow when probing memory
on machines reporting > 32 memory regions. ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.5 2006/09/18 21:15:33 mpf Exp $	*/
d390 22
@


1.5
log
@boot(8) ``machine memory'' support for > 4G.
Convert parser to strtoll(3) and use 64bit printf.
With help from mickey@@
i386 and amd64 tests by me, alpha test by mickey@@
OK mickey@@, miod@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.4 2005/05/28 05:47:33 weingart Exp $	*/
d288 1
a288 1
bios_memmap_t bios_memmap[32];	/* This is easier */
@


1.4
log
@*slightly drunk*

To all my "friends", and my lovely future wife...  Thank you.  Anyone
who still wants to sign the shirt, it's on my bakc.  Again, thank you.

This commit was ok'd by drahn@@, art@@, niklas@@, in spite of my condition.
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.3 2005/05/03 13:18:05 tom Exp $	*/
a369 22
/*
 * XXX - A hack until libgcc has the appropriate div/mod functions so
 * that we can use -DLIBSA_LONGLONG_PRINTF and simply print out the
 * 64-bit vars directly.
 */
static const char *
int64_str(u_int64_t num)
{
	static char buf[17], *p;
	u_int32_t i;

	buf[16] = '\0';
	for(p = buf + 15, i = 0; i < 16; p--,i++) {
		*p = "0123456789abcdef"[num & 0xF];
		num >>= 4;
		if(num == 0)
			break;
	}

	return p;
}

a378 5
	/* libsa printf does not handle quad args, so we use long
	 * instead.  Note, since we're unlikely to support more than
	 * 4G of RAM on a x86 box, this not likely to cause a problem.
	 * If/when we do, libsa may need to be updated some...
	 */
d380 2
a381 3
		printf("Region %ld: type %u at 0x%s for %uKB\n", 
		    (long)(p - tm), p->type,
		    int64_str(p->addr),
d393 1
a393 1
mem_delete(long sa, long ea)
d430 1
a430 1
mem_add(long sa, long ea)
@


1.3
log
@The return value from getEBDAaddr() (info) is not used in bios_E820(),
so nuke it.  amd64 no longer needs biosprobe.c listed in SRCS.  Trims
100 bytes from the boot blocks.

Bump versions on boot, cdboot and pxeboot, as I'm getting cautious in
my old age.

ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.2 2005/05/03 13:02:45 tom Exp $	*/
d347 2
a348 1
			if(im->addr >= IOM_END)
d350 1
d354 11
d370 22
d407 3
a409 2
		printf("Region %ld: type %u at 0x%x for %uKB\n", 
		    (long)(p - tm), p->type, (u_int)p->addr,
@


1.2
log
@Convert the size of a memory chunk from bytes to megabytes before
casting to a 32-bit value, not after.  Corrects the display of large
memory chunks in the probing: line (mem[615K 3518M 0M a20=on] becomes
mem[615K 3518M 12288M a20=on]).

Bump version on boot, cdboot and pxeboot accordingly.

"looks ok to me" weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.1 2004/02/03 12:09:47 mickey Exp $	*/
a69 1
	void *info;
a70 1
	info = getEBDAaddr();
@


1.1
log
@das boot; das cloned das from das i386
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.41 2004/01/09 21:15:00 deraadt Exp $	*/
d331 2
a332 1
				printf("%uM ", (u_int)im->size / (1024 * 1024));
@

