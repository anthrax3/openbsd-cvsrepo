head	1.19;
access;
symbols
	OPENBSD_6_1:1.17.0.4
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.16.0.4
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.15.0.8
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.13.0.4
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.12.0.4
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.2
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.9.0.4
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.2
	OPENBSD_5_0:1.8.0.6
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.4
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.2
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.4
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.6.0.2
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.5.0.6
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.4
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.2
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.4.0.2
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.3.0.8
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.10
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.6
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.4
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	SMP_SYNC_A:1.2
	SMP_SYNC_B:1.2
	OPENBSD_3_5:1.2.0.2
	OPENBSD_3_5_BASE:1.2
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.19
date	2017.06.22.01.26.28;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	3zTTK26TGx1N4rA8;

1.18
date	2017.06.19.22.50.50;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	qxUetDs8y9dCgVHx;

1.17
date	2016.09.11.15.54.11;	author jsing;	state Exp;
branches;
next	1.16;
commitid	m28Q0aUDbVqwDb3p;

1.16
date	2015.09.02.01.52.26;	author yasuoka;	state Exp;
branches;
next	1.15;
commitid	CUwlbzT4LejFC15d;

1.15
date	2014.07.12.20.58.31;	author tedu;	state Exp;
branches;
next	1.14;
commitid	oom7i9cmOZl8jGW7;

1.14
date	2014.07.12.18.44.41;	author tedu;	state Exp;
branches;
next	1.13;
commitid	uKVPYMN2MLxdZxzH;

1.13
date	2013.11.05.00.51.58;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2012.10.30.14.06.29;	author jsing;	state Exp;
branches;
next	1.11;

1.11
date	2012.10.27.15.43.42;	author jsing;	state Exp;
branches;
next	1.10;

1.10
date	2012.10.09.13.55.36;	author jsing;	state Exp;
branches;
next	1.9;

1.9
date	2012.01.11.14.47.02;	author jsing;	state Exp;
branches;
next	1.8;

1.8
date	2010.04.23.15.25.20;	author jsing;	state Exp;
branches;
next	1.7;

1.7
date	2009.05.21.23.45.48;	author krw;	state Exp;
branches;
next	1.6;

1.6
date	2008.12.10.23.41.19;	author krw;	state Exp;
branches;
next	1.5;

1.5
date	2007.06.18.22.11.20;	author krw;	state Exp;
branches;
next	1.4;

1.4
date	2006.09.26.23.33.04;	author krw;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.21.18.53.38;	author tom;	state Exp;
branches;
next	1.2;

1.2
date	2004.03.21.21.37.41;	author tom;	state Exp;
branches;
next	1.1;

1.1
date	2004.02.03.12.09.47;	author mickey;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.06.05.23.09.25;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Only print the magic '&' letter on a disk if the hibernate partition is
valid.  This is an undocumented little debugging diagnostic, much like
the '*'.
@
text
@/*	$OpenBSD: diskprobe.c,v 1.18 2017/06/19 22:50:50 deraadt Exp $	*/

/*
 * Copyright (c) 1997 Tobias Weingartner
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

/* We want the disk type names from disklabel.h */
#undef DKTYPENAMES

#include <sys/param.h>
#include <sys/queue.h>
#include <sys/reboot.h>
#include <sys/disklabel.h>
#include <sys/hibernate.h>

#include <lib/libz/zlib.h>
#include <machine/biosvar.h>
#include <stand/boot/bootarg.h>

#include "disk.h"
#include "biosdev.h"
#include "libsa.h"

#ifdef SOFTRAID
#include "softraid_amd64.h"
#endif
#ifdef EFIBOOT
#include "efidev.h"
#endif

#define MAX_CKSUMLEN MAXBSIZE / DEV_BSIZE	/* Max # of blks to cksum */

/* Local Prototypes */
static int disksum(int);
static void check_hibernate(struct diskinfo *);

int bootdev_has_hibernate(void);		/* export for loadfile() */

/* List of disk devices we found/probed */
struct disklist_lh disklist;

/* Pointer to boot device */
struct diskinfo *bootdev_dip;

extern int debug;
extern int bios_bootdev;
extern int bios_cddev;

#ifndef EFIBOOT
static void
diskinfo_init(struct diskinfo *dip)
{
	bzero(dip, sizeof(*dip));
	dip->diskio = biosd_diskio;
	dip->strategy = biosstrategy;
}

/* Probe for all BIOS floppies */
static void
floppyprobe(void)
{
	struct diskinfo *dip;
	int i;

	/* Floppies */
	for (i = 0; i < 4; i++) {
		dip = alloc(sizeof(struct diskinfo));
		diskinfo_init(dip);

		if (bios_getdiskinfo(i, &dip->bios_info)) {
#ifdef BIOS_DEBUG
			if (debug)
				printf(" <!fd%u>", i);
#endif
			free(dip, 0);
			break;
		}

		printf(" fd%u", i);

		/* Fill out best we can - (fd?) */
		dip->bios_info.bsd_dev = MAKEBOOTDEV(2, 0, 0, i, RAW_PART);

		/*
		 * Delay reading the disklabel until we're sure we want
		 * to boot from the floppy. Doing this avoids a delay
		 * (sometimes very long) when trying to read the label
		 * and the drive is unplugged.
		 */
		dip->bios_info.flags |= BDI_BADLABEL;

		/* Add to queue of disks */
		TAILQ_INSERT_TAIL(&disklist, dip, list);
	}
}

/* Probe for all BIOS hard disks */
static void
hardprobe(void)
{
	struct diskinfo *dip;
	int i;
	u_int bsdunit, type;
	u_int scsi = 0, ide = 0;
	const char *dc = (const char *)((0x40 << 4) + 0x75);

	/* Hard disks */
	for (i = 0x80; i < (0x80 + *dc); i++) {
		dip = alloc(sizeof(struct diskinfo));
		diskinfo_init(dip);

		if (bios_getdiskinfo(i, &dip->bios_info)) {
#ifdef BIOS_DEBUG
			if (debug)
				printf(" <!hd%u>", i&0x7f);
#endif
			free(dip, 0);
			break;
		}

		printf(" hd%u%s", i&0x7f, (dip->bios_info.bios_edd > 0?"+":""));

		/* Try to find the label, to figure out device type */
		if ((bios_getdisklabel(&dip->bios_info, &dip->disklabel)) ) {
			printf("*");
			bsdunit = ide++;
			type = 0;	/* XXX let it be IDE */
		} else {
			/* Best guess */
			switch (dip->disklabel.d_type) {
			case DTYPE_SCSI:
				type = 4;
				bsdunit = scsi++;
				dip->bios_info.flags |= BDI_GOODLABEL;
				break;

			case DTYPE_ESDI:
			case DTYPE_ST506:
				type = 0;
				bsdunit = ide++;
				dip->bios_info.flags |= BDI_GOODLABEL;
				break;

			default:
				dip->bios_info.flags |= BDI_BADLABEL;
				type = 0;	/* XXX Suggest IDE */
				bsdunit = ide++;
			}
		}

		dip->bios_info.checksum = 0; /* just in case */
		/* Fill out best we can */
		dip->bsddev = dip->bios_info.bsd_dev =
		    MAKEBOOTDEV(type, 0, 0, bsdunit, RAW_PART);
		check_hibernate(dip);

		/* Add to queue of disks */
		TAILQ_INSERT_TAIL(&disklist, dip, list);
	}
}
#endif

#ifdef EFIBOOT
static void
efi_hardprobe(void)
{
	int		 n;
	struct diskinfo	*dip, *dipt;
	u_int		 bsdunit, type = 0;
	u_int		 scsi= 0, ide = 0;
	extern struct disklist_lh
			 efi_disklist;

	n = 0;
	TAILQ_FOREACH_SAFE(dip, &efi_disklist, list, dipt) {
		TAILQ_REMOVE(&efi_disklist, dip, list);
		printf(" hd%u", n);

		dip->bios_info.bios_number = 0x80 | n;
		/* Try to find the label, to figure out device type */
		if ((efi_getdisklabel(dip->efi_info, &dip->disklabel))) {
			printf("*");
			bsdunit = ide++;
		} else {
			/* Best guess */
			switch (dip->disklabel.d_type) {
			case DTYPE_SCSI:
				type = 4;
				bsdunit = scsi++;
				dip->bios_info.flags |= BDI_GOODLABEL;
				break;

			case DTYPE_ESDI:
			case DTYPE_ST506:
				type = 0;
				bsdunit = ide++;
				dip->bios_info.flags |= BDI_GOODLABEL;
				break;

			default:
				dip->bios_info.flags |= BDI_BADLABEL;
				type = 0;	/* XXX Suggest IDE */
				bsdunit = ide++;
			}
		}

		dip->bios_info.checksum = 0; /* just in case */
		/* Fill out best we can */
		dip->bsddev = dip->bios_info.bsd_dev =
		    MAKEBOOTDEV(type, 0, 0, bsdunit, RAW_PART);
		check_hibernate(dip);

		/* Add to queue of disks */
		TAILQ_INSERT_TAIL(&disklist, dip, list);
		n++;
	}
}
#endif

/* Probe for all BIOS supported disks */
u_int32_t bios_cksumlen;
void
diskprobe(void)
{
	struct diskinfo *dip;
	int i;

	/* These get passed to kernel */
	bios_diskinfo_t *bios_diskinfo;

	/* Init stuff */
	TAILQ_INIT(&disklist);

#ifndef EFIBOOT
	/* Do probes */
	floppyprobe();
#ifdef BIOS_DEBUG
	if (debug)
		printf(";");
#endif
	hardprobe();
#else
	efi_hardprobe();
#endif

#ifdef SOFTRAID
	srprobe();
#endif

	/* Checksumming of hard disks */
	for (i = 0; disksum(i++) && i < MAX_CKSUMLEN; )
		;
	bios_cksumlen = i;

	/* Get space for passing bios_diskinfo stuff to kernel */
	for (i = 0, dip = TAILQ_FIRST(&disklist); dip;
	    dip = TAILQ_NEXT(dip, list))
		i++;
	bios_diskinfo = alloc(++i * sizeof(bios_diskinfo_t));

	/* Copy out the bios_diskinfo stuff */
	for (i = 0, dip = TAILQ_FIRST(&disklist); dip;
	    dip = TAILQ_NEXT(dip, list))
		bios_diskinfo[i++] = dip->bios_info;

	bios_diskinfo[i++].bios_number = -1;
	/* Register for kernel use */
	addbootarg(BOOTARG_CKSUMLEN, sizeof(u_int32_t), &bios_cksumlen);
	addbootarg(BOOTARG_DISKINFO, i * sizeof(bios_diskinfo_t),
	    bios_diskinfo);
}

#ifndef EFIBOOT
void
cdprobe(void)
{
	struct diskinfo *dip;
	int cddev = bios_cddev & 0xff;

	/* Another BIOS boot device... */

	if (bios_cddev == -1)			/* Not been set, so don't use */
		return;

	dip = alloc(sizeof(struct diskinfo));
	diskinfo_init(dip);

#if 0
	if (bios_getdiskinfo(cddev, &dip->bios_info)) {
		printf(" <!cd0>");	/* XXX */
		free(dip, 0);
		return;
	}
#endif

	printf(" cd0");

	dip->bios_info.bios_number = cddev;
	dip->bios_info.bios_edd = 1;		/* Use the LBA calls */
	dip->bios_info.flags |= BDI_GOODLABEL | BDI_EL_TORITO;
	dip->bios_info.checksum = 0;		 /* just in case */
	dip->bios_info.bsd_dev =
	    MAKEBOOTDEV(6, 0, 0, 0, RAW_PART);

	/* Create an imaginary disk label */
	dip->disklabel.d_secsize = 2048;
	dip->disklabel.d_ntracks = 1;
	dip->disklabel.d_nsectors = 100;
	dip->disklabel.d_ncylinders = 1;
	dip->disklabel.d_secpercyl = dip->disklabel.d_ntracks *
	    dip->disklabel.d_nsectors;
	if (dip->disklabel.d_secpercyl == 0) {
		dip->disklabel.d_secpercyl = 100;
		/* as long as it's not 0, since readdisklabel divides by it */
	}

	strncpy(dip->disklabel.d_typename, "ATAPI CD-ROM",
	    sizeof(dip->disklabel.d_typename));
	dip->disklabel.d_type = DTYPE_ATAPI;

	strncpy(dip->disklabel.d_packname, "fictitious",
	    sizeof(dip->disklabel.d_packname));
	DL_SETDSIZE(&dip->disklabel, 100);

	dip->disklabel.d_bbsize = 2048;
	dip->disklabel.d_sbsize = 2048;

	/* 'a' partition covering the "whole" disk */
	DL_SETPOFFSET(&dip->disklabel.d_partitions[0], 0);
	DL_SETPSIZE(&dip->disklabel.d_partitions[0], 100);
	dip->disklabel.d_partitions[0].p_fstype = FS_UNUSED;

	/* The raw partition is special */
	DL_SETPOFFSET(&dip->disklabel.d_partitions[RAW_PART], 0);
	DL_SETPSIZE(&dip->disklabel.d_partitions[RAW_PART], 100);
	dip->disklabel.d_partitions[RAW_PART].p_fstype = FS_UNUSED;

	dip->disklabel.d_npartitions = MAXPARTITIONS;

	dip->disklabel.d_magic = DISKMAGIC;
	dip->disklabel.d_magic2 = DISKMAGIC;
	dip->disklabel.d_checksum = dkcksum(&dip->disklabel);

	/* Add to queue of disks */
	TAILQ_INSERT_TAIL(&disklist, dip, list);
}
#endif


/* Find info on given BIOS disk */
struct diskinfo *
dklookup(int dev)
{
	struct diskinfo *dip;

	for (dip = TAILQ_FIRST(&disklist); dip; dip = TAILQ_NEXT(dip, list))
		if (dip->bios_info.bios_number == dev)
			return dip;

	return NULL;
}

void
dump_diskinfo(void)
{
	struct diskinfo *dip;

	printf("Disk\tBIOS#\tType\tCyls\tHeads\tSecs\tFlags\tChecksum\n");
	for (dip = TAILQ_FIRST(&disklist); dip; dip = TAILQ_NEXT(dip, list)) {
		bios_diskinfo_t *bdi = &dip->bios_info;
		int d = bdi->bios_number;
		int u = d & 0x7f;
		char c;

		if (bdi->flags & BDI_EL_TORITO) {
			c = 'c';
			u = 0;
		} else {
		    	c = (d & 0x80) ? 'h' : 'f';
		}

		printf("%cd%d\t0x%x\t%s\t%d\t%d\t%d\t0x%x\t0x%x\n",
		    c, u, d,
		    (bdi->flags & BDI_BADLABEL)?"*none*":"label",
		    bdi->bios_cylinders, bdi->bios_heads, bdi->bios_sectors,
		    bdi->flags, bdi->checksum);
	}
}

/* Find BIOS portion on given BIOS disk
 * XXX - Use dklookup() instead.
 */
bios_diskinfo_t *
bios_dklookup(int dev)
{
	struct diskinfo *dip;

	dip = dklookup(dev);
	if (dip)
		return &dip->bios_info;

	return NULL;
}

/*
 * Checksum one more block on all harddrives
 *
 * Use the adler32() function from libz,
 * as it is quick, small, and available.
 */
int
disksum(int blk)
{
	struct diskinfo *dip, *dip2;
	int st, reprobe = 0;
	char buf[DEV_BSIZE];

	for (dip = TAILQ_FIRST(&disklist); dip; dip = TAILQ_NEXT(dip, list)) {
		bios_diskinfo_t *bdi = &dip->bios_info;

		/* Skip this disk if it is not a HD or has had an I/O error */
		if (!(bdi->bios_number & 0x80) || bdi->flags & BDI_INVALID)
			continue;

		/* Adler32 checksum */
		st = dip->diskio(F_READ, dip, blk, 1, buf);
		if (st) {
			bdi->flags |= BDI_INVALID;
			continue;
		}
		bdi->checksum = adler32(bdi->checksum, buf, DEV_BSIZE);

		for (dip2 = TAILQ_FIRST(&disklist); dip2 != dip;
				dip2 = TAILQ_NEXT(dip2, list)) {
			bios_diskinfo_t *bd = &dip2->bios_info;
			if ((bd->bios_number & 0x80) &&
			    !(bd->flags & BDI_INVALID) &&
			    bdi->checksum == bd->checksum)
				reprobe = 1;
		}
	}

	return reprobe;
}

int
bootdev_has_hibernate(void)
{
	return ((bootdev_dip->bios_info.flags & BDI_HIBVALID)? 1 : 0);
}

static void
check_hibernate(struct diskinfo *dip)
{
	daddr_t sec;
	int error;
	union hibernate_info hib;

	/* read hibernate */
	if (dip->disklabel.d_partitions[1].p_fstype != FS_SWAP ||
	    DL_GETPSIZE(&dip->disklabel.d_partitions[1]) == 0)
		return;

	sec = DL_GETPOFFSET(&dip->disklabel.d_partitions[1]) +
	    DL_GETPSIZE(&dip->disklabel.d_partitions[1]) -
            (sizeof(union hibernate_info) / DEV_BSIZE);

	error = dip->strategy(dip, F_READ, (daddr32_t)sec, sizeof hib, &hib, NULL);
	if (error == 0 && hib.magic == HIBERNATE_MAGIC)	{
		/* Hibernate present */
		dip->bios_info.flags |= BDI_HIBVALID;
		printf("&");
	}
}
@


1.18
log
@As early as possible, create a link /bsd.booted to the /bsd kernel we
presume we booted from.  If you boot from another kernel, we cannot help
you later with hibernate, sorry -- The kernel does not get a useable
filename from the bootblocks.

In the bootblocks, detect a live hibernate signature and boot from
/bsd.booted instead.

with yasuoka, lots of discussion with mlarkin, ok tom
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.17 2016/09/11 15:54:11 jsing Exp $	*/
d492 2
a493 1
	if (error == 0 && hib.magic == HIBERNATE_MAGIC)	/* Hibernate present */
d495 2
a496 1
	printf("&");
@


1.17
log
@Rename softraid boot files, which are currently in an MD location. This
will allow us to bring in a MI softraid.{c,h} in lib/libsa.
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.16 2015/09/02 01:52:26 yasuoka Exp $	*/
d37 1
d58 3
d176 1
a176 1
		dip->bios_info.bsd_dev =
d178 1
d232 1
a232 1
		dip->bios_info.bsd_dev =
d234 1
d467 28
@


1.16
log
@Initial commit of uefi boot loader of OpenBSD.

ok deraadt yuo
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.15 2014/07/12 20:58:31 tedu Exp $	*/
d47 1
a47 1
#include "softraid.h"
@


1.15
log
@revert more free fallout
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.14 2014/07/12 18:44:41 tedu Exp $	*/
d49 3
d68 9
d87 1
a87 1
		bzero(dip, sizeof(*dip));
a115 1

d129 1
a129 1
		bzero(dip, sizeof(*dip));
d179 17
d197 39
d251 1
d259 3
d290 1
a290 1

d303 1
a303 1
	bzero(dip, sizeof(*dip));
d364 1
d433 1
a433 1
	char *buf;
a434 1
	buf = alloca(DEV_BSIZE);
d443 1
a443 1
		st = biosd_io(F_READ, bdi, blk, 1, buf);
@


1.14
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.13 2013/11/05 00:51:58 krw Exp $	*/
d82 1
a82 1
			free(dip, 0, 0);
d125 1
a125 1
			free(dip, 0, 0);
d237 1
a237 1
		free(dip, 0, 0);
@


1.13
log
@Replace direct references to p_size, p_offset and d_secperunit with
DL_[GET|SET]PSIZE(), DL_[GET|SET]POFFSET(), DL_[GET|SET]DSIZE() in
order to get|set correct value that includes the high bits of the
value.
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.12 2012/10/30 14:06:29 jsing Exp $	*/
d82 1
a82 1
			free(dip, 0);
d125 1
a125 1
			free(dip, 0);
d237 1
a237 1
		free(dip, 0);
@


1.12
log
@Apply a bunch of style(9) and whitespace fixes to i386/amd64 libsa, making
the code actually diffable. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.11 2012/10/27 15:43:42 jsing Exp $	*/
d269 1
a269 1
	dip->disklabel.d_secperunit = 100;
d275 2
a276 2
	dip->disklabel.d_partitions[0].p_offset = 0;
	dip->disklabel.d_partitions[0].p_size = 100;
d280 2
a281 2
	dip->disklabel.d_partitions[RAW_PART].p_offset = 0;
	dip->disklabel.d_partitions[RAW_PART].p_size = 100;
@


1.11
log
@Move the code for softraid boot into separate files, leaving only minimal
hooks that are called from the normal code path. This allows softraid boot
support to be completely enabled or disabled at compile time. For boot(8)
all softraid boot support is now enabled by default, including support for
booting from crypto volumes. Disable softraid boot support for fdboot,
which further shrinks the binary.
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.6 2008/12/10 23:41:19 krw Exp $	*/
d73 1
a73 1
	for(i = 0; i < 4; i++) {
d77 1
a77 1
		if(bios_getdiskinfo(i, &dip->bios_info)) {
d120 1
a120 1
		if(bios_getdiskinfo(i, &dip->bios_info)) {
d132 1
a132 1
		if((bios_getdisklabel(&dip->bios_info, &dip->disklabel)) ) {
d161 2
a162 1
		dip->bios_info.bsd_dev = MAKEBOOTDEV(type, 0, 0, bsdunit, RAW_PART);
d202 2
a203 1
	for(i = 0, dip = TAILQ_FIRST(&disklist); dip; dip = TAILQ_NEXT(dip, list))
d208 2
a209 1
	for(i = 0, dip = TAILQ_FIRST(&disklist); dip; dip = TAILQ_NEXT(dip, list))
d215 2
a216 1
	addbootarg(BOOTARG_DISKINFO, i * sizeof(bios_diskinfo_t), bios_diskinfo);
d301 3
a303 3
	for(dip = TAILQ_FIRST(&disklist); dip; dip = TAILQ_NEXT(dip, list))
		if(dip->bios_info.bios_number == dev)
			return(dip);
d305 1
a305 1
	return(NULL);
d344 2
a345 2
	if(dip)
		return(&dip->bios_info);
d347 1
a347 1
	return(NULL);
d364 1
a364 1
	for(dip = TAILQ_FIRST(&disklist); dip; dip = TAILQ_NEXT(dip, list)){
d379 2
a380 2
		for(dip2 = TAILQ_FIRST(&disklist); dip2 != dip;
				dip2 = TAILQ_NEXT(dip2, list)){
d389 1
a389 1
	return (reprobe);
@


1.10
log
@Teach amd64 boot(8) how to access a softraid crypto volume. This allows for
full disk encryption since the kernel can now be loaded directly from the
crypto volume, instead of needing to be on FFS.

This is currently disabled by default, however can be enabled by compiling
with boot(8) 'make -DBOOT_CRYPTO'.
@
text
@a4 1
 * Copyright (c) 2012 Joel Sing <jsing@@openbsd.org>
d37 3
a39 2
#include <dev/biovar.h>
#include <dev/softraidvar.h>
d41 1
a41 2
#include <machine/biosvar.h>
#include <lib/libz/zlib.h>
d46 4
a57 3
/* List of softraid volumes. */
struct sr_boot_volume_head sr_volumes;

a167 240
#ifdef BOOT_CRYPTO
void
srprobe_meta_opt_load(struct sr_metadata *sm, struct sr_meta_opt_head *som)
{
	struct sr_meta_opt_hdr	*omh;
	struct sr_meta_opt_item *omi;
#if 0
	u_int8_t checksum[MD5_DIGEST_LENGTH];
#endif
	int			i;

	/* Process optional metadata. */
	omh = (struct sr_meta_opt_hdr *)((u_int8_t *)(sm + 1) +
	    sizeof(struct sr_meta_chunk) * sm->ssdi.ssd_chunk_no);
	for (i = 0; i < sm->ssdi.ssd_opt_no; i++) {

#ifdef BIOS_DEBUG
		printf("Found optional metadata of type %u, length %u\n", 
		    omh->som_type, omh->som_length);
#endif

		/* Unsupported old fixed length optional metadata. */
		if (omh->som_length == 0) {
			omh = (struct sr_meta_opt_hdr *)((void *)omh +
			    omh->som_length);
			continue;
		}

		/* Load variable length optional metadata. */
		omi = alloc(sizeof(struct sr_meta_opt_item));
		bzero(omi, sizeof(struct sr_meta_opt_item));
		SLIST_INSERT_HEAD(som, omi, omi_link);
		omi->omi_som = alloc(omh->som_length);
		bzero(omi->omi_som, omh->som_length);
		bcopy(omh, omi->omi_som, omh->som_length);

#if 0
		/* XXX - Validate checksum. */
		bcopy(&omi->omi_som->som_checksum, &checksum,
		    MD5_DIGEST_LENGTH);
		bzero(&omi->omi_som->som_checksum, MD5_DIGEST_LENGTH);
		sr_checksum(sc, omi->omi_som,
		    &omi->omi_som->som_checksum, omh->som_length);
		if (bcmp(&checksum, &omi->omi_som->som_checksum,
		    sizeof(checksum)))
			panic("%s: invalid optional metadata checksum",
			    DEVNAME(sc));
#endif

		omh = (struct sr_meta_opt_hdr *)((void *)omh +
		    omh->som_length);
	}
}
#endif

static void
srprobe(void)
{
	struct sr_boot_volume *bv, *bv1, *bv2;
	struct sr_boot_chunk *bc, *bc1, *bc2;
	struct sr_meta_chunk *mc;
	struct sr_metadata *md;
	struct diskinfo *dip;
	struct partition *pp;
	int i, error, volno;
	dev_t bsd_dev;
	daddr_t off;

	/* Probe for softraid volumes. */
	SLIST_INIT(&sr_volumes);

	md = alloc(SR_META_SIZE * 512);

	TAILQ_FOREACH(dip, &disklist, list) {

		/* Only check hard disks, skip those with I/O errors. */
		if ((dip->bios_info.bios_number & 0x80) == 0 ||
		    (dip->bios_info.flags & BDI_INVALID))
			continue;

		/* Make sure disklabel has been read. */
		if ((dip->bios_info.flags & (BDI_BADLABEL|BDI_GOODLABEL)) == 0)
			continue;

		for (i = 0; i < MAXPARTITIONS; i++) {

			pp = &dip->disklabel.d_partitions[i];
			if (pp->p_fstype != FS_RAID || pp->p_size == 0)
				continue;

			/* Read softraid metadata. */
			bzero(md, SR_META_SIZE * 512);
			off = DL_GETPOFFSET(pp) + SR_META_OFFSET;
			error = biosd_io(F_READ, &dip->bios_info, off,
			    SR_META_SIZE, md);
			if (error)
				continue;
		
			/* Is this valid softraid metadata? */
			if (md->ssdi.ssd_magic != SR_MAGIC)
				continue;

			/* XXX - validate checksum. */

			/* Locate chunk-specific metadata for this chunk. */
			mc = (struct sr_meta_chunk *)(md + 1);
			mc += md->ssdi.ssd_chunk_id;

			bc = alloc(sizeof(struct sr_boot_chunk));
			bc->sbc_diskinfo = dip;
			bc->sbc_disk = dip->bios_info.bios_number;
			bc->sbc_part = 'a' + i;

			bsd_dev = dip->bios_info.bsd_dev;
			bc->sbc_mm = MAKEBOOTDEV(B_TYPE(bsd_dev),
			    B_ADAPTOR(bsd_dev), B_CONTROLLER(bsd_dev),
			    B_UNIT(bsd_dev), bc->sbc_part - 'a');

			bc->sbc_chunk_id = md->ssdi.ssd_chunk_id;
			bc->sbc_ondisk = md->ssd_ondisk;
			bc->sbc_state = mc->scm_status;

			/* Handle key disks separately... later. */
			if (md->ssdi.ssd_level == SR_KEYDISK_LEVEL)
				continue;

			SLIST_FOREACH(bv, &sr_volumes, sbv_link) {
				if (bcmp(&md->ssdi.ssd_uuid, &bv->sbv_uuid,
				    sizeof(md->ssdi.ssd_uuid)) == 0)
					break;
			}

			if (bv == NULL) {
				bv = alloc(sizeof(struct sr_boot_volume));
				bv->sbv_diskinfo = NULL;
				bv->sbv_keys = NULL;
				bv->sbv_level = md->ssdi.ssd_level;
				bv->sbv_volid = md->ssdi.ssd_volid;
				bv->sbv_chunk_no = md->ssdi.ssd_chunk_no;
				bv->sbv_flags = md->ssdi.ssd_vol_flags;
				bv->sbv_size = md->ssdi.ssd_size;
				bv->sbv_data_offset = md->ssd_data_offset;
				bcopy(&md->ssdi.ssd_uuid, &bv->sbv_uuid,
				    sizeof(md->ssdi.ssd_uuid));
				SLIST_INIT(&bv->sbv_chunks);
				SLIST_INIT(&bv->sbv_meta_opt);

#ifdef BOOT_CRYPTO
				/* Load optional metadata for this volume. */
				srprobe_meta_opt_load(md, &bv->sbv_meta_opt);
#endif

				/* Maintain volume order. */
				bv2 = NULL;
				SLIST_FOREACH(bv1, &sr_volumes, sbv_link) {
					if (bv1->sbv_volid > bv->sbv_volid)
						break;
					bv2 = bv1;
				}
				if (bv2 == NULL)
					SLIST_INSERT_HEAD(&sr_volumes, bv,
					    sbv_link);
				else
					SLIST_INSERT_AFTER(bv2, bv, sbv_link);
			}

			/* Maintain chunk order. */
			bc2 = NULL;
			SLIST_FOREACH(bc1, &bv->sbv_chunks, sbc_link) {
				if (bc1->sbc_chunk_id > bc->sbc_chunk_id)
					break;
				bc2 = bc1;
			}
			if (bc2 == NULL)
				SLIST_INSERT_HEAD(&bv->sbv_chunks,
				    bc, sbc_link);
			else
				SLIST_INSERT_AFTER(bc2, bc, sbc_link);

			bv->sbv_chunks_found++;
		}
	}

	/*
	 * Assemble RAID volumes.
	 */
	volno = 0;
	SLIST_FOREACH(bv, &sr_volumes, sbv_link) {

		/* Skip if this is a hotspare "volume". */
		if (bv->sbv_level == SR_HOTSPARE_LEVEL &&
		    bv->sbv_chunk_no == 1)
			continue;

		/* Determine current ondisk version. */
		bv->sbv_ondisk = 0;
		SLIST_FOREACH(bc, &bv->sbv_chunks, sbc_link) {
			if (bc->sbc_ondisk > bv->sbv_ondisk)
				bv->sbv_ondisk = bc->sbc_ondisk;
		}
		SLIST_FOREACH(bc, &bv->sbv_chunks, sbc_link) {
			if (bc->sbc_ondisk != bv->sbv_ondisk)
				bc->sbc_state = BIOC_SDOFFLINE;
		}

		/* XXX - Check for duplicate chunks. */

		/*
		 * Validate that volume has sufficient chunks for
		 * read-only access.
		 *
		 * XXX - check chunk states.
		 */
		bv->sbv_state = BIOC_SVOFFLINE;
		switch (bv->sbv_level) {
		case 0:
		case 'C':
		case 'c':
			if (bv->sbv_chunk_no == bv->sbv_chunks_found)
				bv->sbv_state = BIOC_SVONLINE;
			break;

		case 1:
			if (bv->sbv_chunk_no == bv->sbv_chunks_found)
				bv->sbv_state = BIOC_SVONLINE;
			else if (bv->sbv_chunks_found > 0)
				bv->sbv_state = BIOC_SVDEGRADED;
			break;
		}

		bv->sbv_unit = volno++;
		if (bv->sbv_state != BIOC_SVOFFLINE)
			printf(" sr%d%s", bv->sbv_unit,
			    bv->sbv_flags & BIOC_SCBOOTABLE ? "*" : "");
	}

	if (md)
		free(md, 0);
}

d191 1
d193 1
@


1.9
log
@Teach OpenBSD/amd64 boot(8) how to access softraid(8) volumes. This
allows a kernel to be loaded from a softraid RAID 1 volume. Furthermore,
if you boot from a disk that is a member of a bootable softraid volume
then it will default to booting from the softraid volume (sr[0-9]a:/bsd).

Discussed with deraadt@@
@
text
@d168 54
a275 2
			/* XXX - extract necessary optional metadata. */

d302 2
d313 6
@


1.8
log
@Recycle unused disklabel fields in order to create a disklabel unique
identifier, allowing the disk to be identified without relying on the
device name.

ok deraadt@@ krw@@ beck@@ marco@@ todd@@
@
text
@d5 1
d38 2
d55 3
d169 180
d370 2
@


1.7
log
@The only value that d_npartitions should have is MAXPARTITIONS.
@
text
@a255 2
	dip->disklabel.d_rpm = 300;
	dip->disklabel.d_interleave = 1;
@


1.6
log
@When booting from a CD on i386/amd64, assume the root filesystem
is on the CD rather than always asking for its location.  Behaviour
pointed out at OpenCON by Stephan Rickauer.

Tested by Stephan. nick@@ has no objections.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.5 2007/06/18 22:11:20 krw Exp $	*/
d272 1
a272 1
	dip->disklabel.d_npartitions = RAW_PART + 1;
@


1.5
log
@Calculate the disklabel checksum *after* filling in all the fields in
the disklabel.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.4 2006/09/26 23:33:04 krw Exp $	*/
d235 1
a235 1
	    MAKEBOOTDEV(0, 0, 0, 0xff, RAW_PART);
@


1.4
log
@Zap D_REMOVABLE flag from disklabel. If you didn't already know that
floppies and cd's were removable, displaying that fact in disklabel
output was unlikely to help. And the display in disklabel was the only
use of D_REMOVABLE in the tree.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.3 2004/08/21 18:53:38 tom Exp $	*/
a261 4
	dip->disklabel.d_magic = DISKMAGIC;
	dip->disklabel.d_magic2 = DISKMAGIC;
	dip->disklabel.d_checksum = dkcksum(&dip->disklabel);

d273 4
@


1.3
log
@Enter cdboot, a CD-specific second-stage bootrap.  Based on the i386
cdboot that Toby and I put together at the hackathon.

"go for it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.2 2004/03/21 21:37:41 tom Exp $	*/
a257 1
	dip->disklabel.d_flags = D_REMOVABLE;
@


1.2
log
@Enter pxeboot on amd64.  Initially intended to support network installs
using bsd.rd over TFTP.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.1 2004/02/03 12:09:47 mickey Exp $	*/
d16 2
a17 2
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
d56 2
d206 78
d303 1
a303 1
	for(dip = TAILQ_FIRST(&disklist); dip; dip = TAILQ_NEXT(dip, list)){
d306 9
d317 2
a318 2
		    (d & 0x80)?'h':'f', d & 0x7F, d,
			(bdi->flags & BDI_BADLABEL)?"*none*":"label",
a379 1

@


1.1
log
@das boot; das cloned das from das i386
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.24 2003/12/16 22:53:13 deraadt Exp $	*/
a172 1
	printf("disk:");
a200 2

	printf("\n");
@


1.1.2.1
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d173 1
d202 2
@


