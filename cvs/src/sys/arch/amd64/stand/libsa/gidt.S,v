head	1.11;
access;
symbols
	OPENBSD_6_2:1.11.0.22
	OPENBSD_6_2_BASE:1.11
	OPENBSD_6_1:1.11.0.20
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.16
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.12
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.14
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.6
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.10
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.8
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.4
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.2
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.6.0.24
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.22
	OPENBSD_5_0:1.6.0.20
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.18
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.16
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.12
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.14
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.10
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.8
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.6
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.4
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.2
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.5.0.4
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.6
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.2
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.2.0.6
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.4
	OPENBSD_3_6_BASE:1.2
	SMP_SYNC_A:1.2
	SMP_SYNC_B:1.2
	OPENBSD_3_5:1.2.0.2
	OPENBSD_3_5_BASE:1.2
	SMP:1.1.0.2;
locks; strict;
comment	@# @;


1.11
date	2012.10.27.15.43.42;	author jsing;	state Exp;
branches;
next	1.10;

1.10
date	2012.10.09.13.57.41;	author jsing;	state Exp;
branches;
next	1.9;

1.9
date	2012.10.09.12.39.12;	author jsing;	state Exp;
branches;
next	1.8;

1.8
date	2012.10.09.11.39.57;	author jsing;	state Exp;
branches;
next	1.7;

1.7
date	2012.10.08.12.46.37;	author jsing;	state Exp;
branches;
next	1.6;

1.6
date	2006.12.29.11.44.01;	author tom;	state Exp;
branches;
next	1.5;

1.5
date	2005.05.31.23.08.47;	author jmc;	state Exp;
branches;
next	1.4;

1.4
date	2005.04.30.16.39.03;	author tom;	state Exp;
branches;
next	1.3;

1.3
date	2005.04.29.16.14.04;	author tom;	state Exp;
branches;
next	1.2;

1.2
date	2004.03.21.21.37.41;	author tom;	state Exp;
branches;
next	1.1;

1.1
date	2004.02.03.12.09.47;	author mickey;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.06.05.23.09.25;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Move the code for softraid boot into separate files, leaving only minimal
hooks that are called from the normal code path. This allows softraid boot
support to be completely enabled or disabled at compile time. For boot(8)
all softraid boot support is now enabled by default, including support for
booting from crypto volumes. Disable softraid boot support for fdboot,
which further shrinks the binary.
@
text
@/*	$OpenBSD: gidt.S,v 1.9 2012/10/09 12:39:12 jsing Exp $	*/

/*
 * Copyright (c) 1997 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

	.file "gidt.S"

#include <machine/asm.h>
#define _LOCORE
#include <machine/trap.h>
#undef _LOCORE
#include <assym.h>

#include "gidt.h"

#ifdef GIDT_DEBUG
#define	gidt_debug0		; \
	mov	$0xb8000, %eax	; \
	mov	$0x47314730, (%eax)
#define	gidt_debug1		; \
	mov	$(0xb8000 - LINKADDR), %eax	; \
	mov	$0x4f314f30, (%eax)
#define	gidt_debug2		; \
	mov	$0xb8004, %eax	; \
	mov	$0x47334732, (%eax)
#define	gidt_debug3		; \
	mov	$0xb8004, %eax	; \
	mov	$0x4f334f32, (%eax)
#define gidt_debug4		; \
	movl	$0xb8008, %eax	; \
	movl	$0x47344733, (%eax)
#else
#define gidt_debug0 /* gidt_debug0 */
#define gidt_debug1 /* gidt_debug1 */
#define gidt_debug2 /* gidt_debug2 */
#define gidt_debug3 /* gidt_debug3 */
#define gidt_debug4 /* gidt_debug4 */
#endif

#define prot2real						\
	gidt_debug0;						\
								\
	ljmp	$S16TEXT, $1f - LINKADDR;			\
1:								\
	.code16;						\
	movw	$S16DATA, %ax;					\
	movw	%ax, %ds;					\
	movw	%ax, %es;					\
	gidt_debug1;						\
								\
	movl	%cr0, %eax;	/* disable pmmm */		\
	andl 	$~CR0_PE, %eax;					\
	movl	%eax, %cr0;					\
								\
	/* reload real cs:ip */					\
	data32 ljmp	$(LINKADDR >> 4), $1f - LINKADDR;	\
1:								\
	movw	%cs, %ax;	/* setup: %ds, %es, %ss = %cs */ \
	movw	%ax, %ds;					\
	movw	%ax, %es;					\
	xorw	%ax, %ax;					\
	movw	%ax, %ss;					\
								\
	gidt_debug2;						\
								\
	data32 addr32 lidt (Idtr_real - LINKADDR); /* load idtr for real mode */

#define real2prot						\
	gidt_debug3;						\
								\
	movw	$LINKADDR >> 4, %ax;				\
	movw	%ax, %ds;					\
	data32 addr32 lgdt (Gdtr - LINKADDR); 	/* load the gdtr */	\
								\
	movl	%cr0, %eax;	/* enable pmmm */		\
	orl	$CR0_PE, %eax;					\
	movl	%eax, %cr0;					\
								\
	data32 ljmp	$S32TEXT, $1f;   /* reload %cs,flush pipeline */\
1:								\
	.code32;						\
	/* reload 32bit %ds, %ss, %es */			\
	mov	$S32DATA, %eax;					\
	mov	%ax, %ds;					\
	mov	%ax, %ss;					\
	mov	%ax, %es;					\
								\
	gidt_debug4;						\
								\
	/* load idtr for debugger and DOS/BIOS iface */		\
	lidt	Idtr;


	.globl	_C_LABEL(BIOS_regs)

	.text
	.code32
	.globl	_ASM_LABEL(pmm_init)
	.globl	_C_LABEL(_rtt)

ENTRY(_rtt)
#ifdef SOFTRAID
	call	_C_LABEL(sr_clear_keys)
#endif
#ifdef GIDT_DEBUG
	movl	$0xb8000, %ebx
	movl	$0x4f514f51, (%ebx)
#endif
	movw	$0x1234, %ax
	movw	%ax, 0x472	/* warm boot */

	/* Try to use the KBD to reboot system */
	movb	$0xfe, %al
	outb	%al, $0x64

	movl	$0x5000, %ecx
1:	inb	$0x84, %al
	loop	1b

	movb	$0xfe, %al
	outb	%al, $0x64

#ifdef GIDT_DEBUG
	movl	$0xb8000, %ebx
	movl	$0x07310731, (%ebx)
#endif

	/* Try to cause a triple fault... */
	lidt	Idtr_reset
	xorl	%eax, %eax
	divl	%eax, %eax

	/* Again... */
	int $0x8

	/* Again... */
	movl	$0, %esp	/* segment violation */
	ret

#define IPROC(n)	X##n
#define IEMU(n)		IPROC(emu##n)

create_idt_entry:
	movw	%ax, (%ebx)
	movw	$S32TEXT, 2(%ebx)
	movw	$((0x80|SDT_SYS386TGT) << 8), 4(%ebx)
	shr	$16, %eax
	movw	%ax, 6(%ebx)
	addl	$8, %ebx
	ret

	.align	8, 0x90
pmm_init:

#define idte(e)	\
	movl $IPROC(e), %eax; call create_idt_entry
#define idtb(b)	idte(emu##b)

	/* Build interrupt descriptor table. */
	/* Maskable interrupts (32-255) */
	movl	$idt, %ebx
	movl	$Idtr, %eax
	movw	$(640 - 1), (%eax)
	movl	%ebx, 2(%eax)

	/* Internal (0-31) */
	idte(de); idte(db); idte(nmi); idte(bp); idte(of); idte(br)
	idte(ud); idte(nm); idte(df);  idte(fo); idte(ts); idte(np)
	idte(ss); idte(gp); idte(pf);  idte(xx); idte(mf); idte(ac)
	idte(xx)
	idte(xx); idte(xx); idte(xx);  idte(xx); idte(xx); idte(xx)
	idte(xx); idte(xx); idte(xx);  idte(xx); idte(xx); idte(xx)
	idte(xx) 
	/* BIOS entry points (32-63) */
	idtb(0);  idtb(1);  idtb(2);  idtb(3);  idtb(4);  idtb(5)
	idtb(6);  idtb(7);  idtb(8);  idtb(9);  idtb(10); idtb(11)
	idtb(12); idtb(13); idtb(14); idtb(15); idtb(16); idtb(17)
	idtb(18); idtb(19); idtb(20); idtb(21); idtb(22); idtb(23)
	idtb(24); idtb(25); idtb(26); idtb(27); idtb(28); idtb(29)
	idtb(30); idtb(31); idtb(32); idtb(33); idtb(34); idtb(35)
	idtb(36); idtb(37); idtb(38); idtb(39); idtb(40); idtb(41)
	idtb(42); idtb(43); idtb(44); idtb(45); idtb(46); idtb(47)
	/* DOS entry points (64-80) */

#undef idtb
#undef idte

	/* load idtr for interrupts */
	lidt	Idtr
	ret

	.bss
	.align 8, 0x90
idt:
	/* IDT has 80 entries at 8 bytes each. */
	.space  640

	.globl	Idtr
Idtr:	.word	0  // 640 - 1
	.long	0  // idt
	.word	0

	.text
	.align	8
	.globl	Idtr_real
Idtr_real:
	.word	1023
	.long	0
	.word	0

	.align	8
Idtr_reset:
	.long	0, 0

	.align	8
gdt:
		/* 0x00 : null */
	.space	8
		/* 0x08 : flat code */
	.word	0xFFFF			# lolimit
	.word	0			# lobase
	.byte	0			# midbase
	.byte	SDT_MEMERAC | 0 | 0x80	# RXAC, dpl = 0, present
	.byte	0xf | 0 | 0x40 | 0x80	# hilimit, xx, 32bit, 4k granularity
	.byte	0			# hibase
		/* 0x10 : flat data */
	.word	0xFFFF			# lolimit
	.word	0			# lobase
	.byte	0			# midbase
	.byte	SDT_MEMRWA | 0 | 0x80	# RWA, dpl = 0, present
	.byte	0xf | 0 | 0x40 | 0x80	# hilimit, xx, 32bit, 4k granularity
	.byte	0			# hibase
		/* 0x18 : 16 bit code */
	.word	0xFFFF			# lolimit
	.word	(LINKADDR & 0xffff)	# lobase
	.byte	(LINKADDR >> 16) & 0xff	# midbase
	.byte	SDT_MEMERAC | 0 | 0x80	# RXAC, dpl = 0, present
	.byte	0x0 | 0 | 0 | 0		# hilimit, xx, 16bit, byte granularity
	.byte	(LINKADDR >> 20) & 0xff	# hibase
		/* 0x20 : 16 bit data */
	.word	0xFFFF			# lolimit
	.word	(LINKADDR & 0xffff)	# lobase
	.byte	(LINKADDR >> 16) & 0xff	# midbase
	.byte	SDT_MEMRWA | 0 | 0x80	# RWA, dpl = 0, present
	.byte	0x0 | 0 | 0 | 0		# hilimit, xx, 16bit, byte granularity
	.byte	(LINKADDR >> 20) & 0xff	# hibase

.globl Gdtr
Gdtr:	.word	. - gdt - 1
	.long	gdt
	.word	0

#define IENTRY(name,type) \
IPROC(name): \
	pushl	$type ; \
	jmp	1f
#define IENTRY_ERR(name,err,type) \
IPROC(name): \
	pushl	$err ; \
	pushl	$type ; \
	jmp	1f

IPROC(xx):
	pushl	$1
	pushl	$T_RESERVED
	jmp	1f

IENTRY_ERR(de,0,T_DIVIDE)	/* #DE divide by zero */
IENTRY_ERR(db,0,T_TRCTRAP)	/* #DB debug */
IENTRY_ERR(nmi,0,T_NMI)		/* NMI */
IENTRY_ERR(bp,0,T_BPTFLT)	/* #BP breakpoint */
IENTRY_ERR(of,0,T_OFLOW)	/* #OF overflow */
IENTRY_ERR(br,0,T_BOUND)	/* #BR BOUND range exceeded */
IENTRY_ERR(ud,0,T_PRIVINFLT)	/* #UD invalid opcode */
IENTRY_ERR(nm,0,T_DNA)		/* #NM device not available */
IENTRY(df,T_DOUBLEFLT)		/* #DF double fault */
IENTRY_ERR(fo,0,T_FPOPFLT)	/* #FO coprocessor segment overrun */
IENTRY(ts,T_TSSFLT)		/* #TS invalid TSS */
IENTRY(np,T_SEGNPFLT)		/* #NP segment not present */
IENTRY(ss,T_STKFLT)		/* #SS stack fault */
IENTRY(gp,T_PROTFLT)		/* #GP general protection */
IENTRY(pf,T_PAGEFLT)		/* #PF page fault */
IENTRY_ERR(mf,0,T_ARITHTRAP)	/* #MF floating point error */
IENTRY(ac,T_ALIGNFLT)		/* #AC alignment check */
1:
	cli
	hlt

#define	IEMUENT(n)	IEMU(n): pushl $n; jmp 1f

IEMUENT(0);  IEMUENT(1);  IEMUENT(2);  IEMUENT(3)
IEMUENT(4);  IEMUENT(5);  IEMUENT(6);  IEMUENT(7)
IEMUENT(8);  IEMUENT(9);  IEMUENT(10); IEMUENT(11)
IEMUENT(12); IEMUENT(13); IEMUENT(14); IEMUENT(15)
IEMUENT(16); IEMUENT(17); IEMUENT(18); IEMUENT(19)
IEMUENT(20); IEMUENT(21); IEMUENT(22); IEMUENT(23)
IEMUENT(24); IEMUENT(25); IEMUENT(26); IEMUENT(27)
IEMUENT(28); IEMUENT(29); IEMUENT(30); IEMUENT(31)
1:	jmp	EMUh	/* redirect for short jumps */
IEMUENT(32); IEMUENT(33); IEMUENT(34); IEMUENT(35)
IEMUENT(36); IEMUENT(37); IEMUENT(38); IEMUENT(39)
IEMUENT(40); IEMUENT(41); IEMUENT(42); IEMUENT(43)
IEMUENT(44); IEMUENT(45); IEMUENT(46); IEMUENT(47)
1:	jmp	EMUh

/*
 * entry point for BIOS real-mode interface
 * all the magic for real-prot mode switching is here
 *
 * Note: Once in real mode access to .data or .bss should be avoided since it
 * may not be reachable within the current segment. The following code also
 * assumes that .text is writeable.
 *
 * Call:	%eax, %ecx, %edx, %ebx, %ebp, %esi, %edi, %es, %ds
 * Return:	%eax, %edx, %ecx, %eflags (as returned from BIOS)
 *
 */
	.globl	EMUh
	.align	8, 0x90
EMUh:
	/* save %eax */
	mov	%eax, 5f
	pop	%eax

	pusha
	push	%ds
	push	%es
	push	%fs
	push	%gs

	/* save BIOS int vector */
	mov	%al, intno

	/* Load BIOS registers prior to switching to real mode. */
	movl	_C_LABEL(BIOS_regs)+BIOSR_ES, %eax
	mov	%eax, 7f
	movl	_C_LABEL(BIOS_regs)+BIOSR_DS, %eax
	mov	%eax, 6f

	prot2real

	push	%ds

	# data32 movl $Leax, %eax
	.byte	0x66, 0xb8
7:	.long	0x90909090
	mov	%ax, %es

	# data32 movl $Leax, %eax
	.byte	0x66, 0xb8
6:	.long	0x90909090
	mov	%ax, %ds

	# data32 movl $Leax, %eax
	.byte	0x66, 0xb8
5:	.long	0x90909090

	;sti
	int	$0
intno	= . - 1
	;cli

	pop	%ds

	/* Preserve BX and ES for protected mode. */
	addr32 movl %eax, (2f - LINKADDR)
	movl	%ebx, %eax
	addr32 movl %eax, (4f - LINKADDR)
	movl	%es, %eax
	addr32 movl %eax, (3f - LINKADDR)
	addr32 movl (2f - LINKADDR), %eax

	movb	%ah, %bh
	lahf
	xchgb	%ah, %bh

	/* Preserve AX for protected mode. */
	addr32 movl %eax, (2f - LINKADDR)

	real2prot

	# movl $Leax, %eax
	.byte	0xb8
4:	.long	0x90909090
	movl	%eax, _C_LABEL(BIOS_regs)+BIOSR_BX

	# movl $Leax, %eax
	.byte	0xb8
3:	.long	0x90909090
	movl	%eax, _C_LABEL(BIOS_regs)+BIOSR_ES

	# movl $Leax, %eax
	.byte	0xb8
2:	.long	0x90909090

	/* pass BIOS return values back to caller */
	movl	%eax, 0xb*4(%esp)
	movl	%ecx, 0xa*4(%esp)
	movl	%edx, 0x9*4(%esp)
	movb	%bh , 0xe*4(%esp)

	/* clear NT flag in eflags */
	/* Martin Fredriksson <martin@@gbg.netman.se> */
	pushf
	pop	%eax
	and	$0xffffbfff, %eax
	push	%eax
	popf

	/* save registers into save area */
	movl	%eax, _C_LABEL(BIOS_regs)+BIOSR_AX
	movl	%ecx, _C_LABEL(BIOS_regs)+BIOSR_CX
	movl	%edx, _C_LABEL(BIOS_regs)+BIOSR_DX
	movl	%ebp, _C_LABEL(BIOS_regs)+BIOSR_BP
	movl	%esi, _C_LABEL(BIOS_regs)+BIOSR_SI
	movl	%edi, _C_LABEL(BIOS_regs)+BIOSR_DI

	pop	%gs
	pop	%fs
	pop	%es
	pop	%ds
	popa
	iret

/* Call buffer at 07c0:0000 in real mode to simulate a BIOS boot */
ENTRY(bootbuf)
	pop	%eax		/* Don't need return address */
	pop	%esi		/* Buffer */
	pop	%edx		/* Device */
	prot2real		/* Switch */

	/* Set up stack */
	cli
	xor	%ax, %ax
	mov	%ax, %ss
	mov	$0xfffc, %esp
	sti

	/* Jump to buffer */
	ljmp	$0x0, $0x7c00

	.end
@


1.10
log
@Ensure that softraid keys are cleared if rebooting from the boot loader.
@
text
@d126 1
a126 1
#ifdef BOOT_CRYPTO
@


1.9
log
@Put the real mode IDT and the GDT back in .text - having them in .data only
works if .data is within the same segment.
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.8 2012/10/09 11:39:57 jsing Exp $	*/
d126 3
@


1.8
log
@Dynamically build the Interrupt Descriptor Table (IDT), instead of using
a static table. This allows the IDT to be placed in .bss and avoids the
"relocation truncated" errors that result from the linker trying to put
a 32-bit address into a 16-bit hole.

With input from Marco Peereboom.

ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.7 2012/10/08 12:46:37 jsing Exp $	*/
d224 1
a224 1
	.data
a273 1
	.text
@


1.7
log
@Avoid accessing .data or .bss from real mode, since they may not be within
the current segment. Load and store the necessary BIOS registers from
protected mode, preserving the register values across the real mode and
protected mode switches by directly patching instructions. This allows for
boot(8) to be larger than 64KB.
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.5 2005/05/31 23:08:47 jmc Exp $	*/
d150 1
a150 1
	lidt    Idtr_reset
d161 12
a174 3
	/* load idtr for interrupts */
	lidt	Idtr
	ret
d176 10
d187 1
a187 13
#ifdef __STDC__
#define IPROC(n)	X##n
#define IEMU(n)		IPROC(emu##n)
#else
#define IPROC(n)	X/**/n
#define IEMU(n)		IPROC(emu/**/n)
#endif
	.align 8, 0x90
idt:
#define idte(e)	\
	.short	IPROC(e); .short (S32TEXT); \
	.short	((0x80|SDT_SYS386TGT) << 8); .short (LINKADDR >> 16)
/* internal (0-31) */
d195 1
a195 8
		/* Maskable interrupts (32-255) */
		/* BIOS entry points (32-63) */
		/* DOS entry points (64-80) */
#ifdef __STDC__
#define idtb(b)	idte(emu##b)
#else
#define idtb(b)	idte(emu/**/b)
#endif
d204 3
d208 11
d220 2
a221 2
Idtr:	.word	. - idt - 1
	.long	idt
d224 1
d227 4
a230 3
Idtr_real:	.word	1023
		.long	0
		.word	0
d233 2
a234 1
Idtr_reset:	.long	0, 0
d274 1
a306 1

@


1.6
log
@Fix another 'tripple' (not surprising, since this was copied from the
i386 code that I fixed earlier).  Noticed by Gregory Steuck (greg (at)
nest (dot) cx); thanks.
@
text
@d315 4
d327 1
a327 1
	mov	%eax, 3f
d339 6
d349 9
a357 4
	addr32  movw (_C_LABEL(BIOS_regs)+(BIOSR_ES) - LINKADDR), %ax
	movw	%ax, %es
	addr32  movw (_C_LABEL(BIOS_regs)+(BIOSR_DS) - LINKADDR), %ax
	movw	%ax, %ds
d361 1
a361 1
3:	.long	0x90909090
d370 8
a377 3
	addr32 movl %ebx, (_C_LABEL(BIOS_regs)+(BIOSR_BX) - LINKADDR)
	movw	%es, %bx
	addr32 movw %bx, (_C_LABEL(BIOS_regs)+(BIOSR_ES) - LINKADDR)
d382 1
d388 12
a399 2
	.byte 0xb8
2:	.long 0x90909090
d445 1
a445 1
	ljmp $0x0, $0x7c00
@


1.5
log
@spelling corrections in comments;
from charlie root;
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.4 2005/04/30 16:39:03 tom Exp $	*/
d149 1
a149 1
	/* Try to cause a tripple fault... */
@


1.4
log
@As on i386, ensure we save the %ebx register returned from the BIOS
call, not just %bx.  Fixes problem introduced in gidt.S r1.3.

Problem found, and fix tested, on i386 by Roy Morris rmorris (at)
internetsecure (dot) com.  Thanks.

Bump version on boot, cdboot and pxeboot accordingly.
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.3 2005/04/29 16:14:04 tom Exp $	*/
d282 2
a283 2
IENTRY(ts,T_TSSFLT)		/* #TS innvalid TSS */
IENTRY(np,T_SEGNPFLT)		/* #NP segmant not present */
@


1.3
log
@Make boot code use real mode with 64K segments instead of 1M segments,
to match i386 boot blocks.  Improves stability with some disk controller
cards.  Also expicitly state operand size on some moves.

Bump version on boot, cdboot and pxeboot accordingly.
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.1 2004/02/03 12:09:47 mickey Exp $	*/
d355 1
a355 1
	addr32 movw %bx, (_C_LABEL(BIOS_regs)+(BIOSR_BX) - LINKADDR)
@


1.2
log
@Enter pxeboot on amd64.  Initially intended to support network installs
using bsd.rd over TFTP.

ok deraadt@@
@
text
@d71 2
a72 2
	mov	%ax, %ds;					\
	mov	%ax, %es;					\
d82 5
a86 4
	xor	%ax, %ax;	/* setup: %ds, %es, %ss */	\
	mov	%ax, %ds;					\
	mov	%ax, %es;					\
	mov	%ax, %ss;					\
d90 1
a90 1
	data32 addr32 lidt Idtr_real;	/* load idtr for real mode */
d95 3
a97 1
	data32 addr32 lgdt Gdtr;	/* load the gdtr */	\
d242 1
a242 1
	.byte	0xf | 0 | 0 | 0		# hilimit, xx, 16bit, byte granularity
d249 1
a249 1
	.byte	0xf | 0 | 0 | 0		# hilimit, xx, 16bit, byte granularity
d339 4
a342 4
	addr32  mov _C_LABEL(BIOS_regs)+(BIOSR_ES), %eax
	mov	%ax, %es
	addr32  mov _C_LABEL(BIOS_regs)+(BIOSR_DS), %eax
	mov	%ax, %ds
d355 3
a357 3
	addr32 mov %ebx, _C_LABEL(BIOS_regs)+(BIOSR_BX)
	mov	%es, %bx
	addr32 mov %ebx, _C_LABEL(BIOS_regs)+(BIOSR_ES)
d362 1
a362 1
	addr32 mov %eax, 2f
d371 3
a373 3
	mov	%eax, 0xb*4(%esp)
	mov	%ecx, 0xa*4(%esp)
	mov	%edx, 0x9*4(%esp)
d385 6
a390 6
	mov	%eax, _C_LABEL(BIOS_regs)+BIOSR_AX
	mov	%ecx, _C_LABEL(BIOS_regs)+BIOSR_CX
	mov	%edx, _C_LABEL(BIOS_regs)+BIOSR_DX
	mov	%ebp, _C_LABEL(BIOS_regs)+BIOSR_BP
	mov	%esi, _C_LABEL(BIOS_regs)+BIOSR_SI
	mov	%edi, _C_LABEL(BIOS_regs)+BIOSR_DI
@


1.1
log
@das boot; das cloned das from das i386
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.27 2004/01/13 23:54:07 millert Exp $	*/
d38 1
a38 5
#define	SNULL	0x00
#define S32TEXT	0x08
#define	S32DATA	0x10
#define S16TEXT	0x18
#define	S16DATA	0x20
d202 1
d208 1
@


1.1.2.1
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d38 5
a42 1
#include "gidt.h"
a205 1
	.globl	Idtr
a210 1
	.globl	Idtr_real
@


