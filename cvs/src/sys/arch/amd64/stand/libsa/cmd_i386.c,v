head	1.11;
access;
symbols
	OPENBSD_6_2:1.11.0.4
	OPENBSD_6_2_BASE:1.11
	OPENBSD_6_1:1.10.0.6
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.2
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.6.0.10
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.6
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.8
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.4
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.2
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.12
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.14
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.10
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.8
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.6
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.4
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.2
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.1.0.12
	OPENBSD_4_0_BASE:1.1
	OPENBSD_3_9:1.1.0.14
	OPENBSD_3_9_BASE:1.1
	OPENBSD_3_8:1.1.0.10
	OPENBSD_3_8_BASE:1.1
	OPENBSD_3_7:1.1.0.8
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.6
	OPENBSD_3_6_BASE:1.1
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	OPENBSD_3_5:1.1.0.4
	OPENBSD_3_5_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.11
date	2017.05.31.08.23.33;	author yasuoka;	state Exp;
branches;
next	1.10;
commitid	yVdpi8DOOZlN2gSe;

1.10
date	2016.06.10.18.36.06;	author jcs;	state Exp;
branches;
next	1.9;
commitid	x57WcyDUhZLxQO5Z;

1.9
date	2015.11.08.00.42.39;	author yasuoka;	state Exp;
branches;
next	1.8;
commitid	4ochEksphbgq4px9;

1.8
date	2015.09.18.13.30.56;	author miod;	state Exp;
branches;
next	1.7;
commitid	1BEcCDYd9p5DIl0g;

1.7
date	2015.09.02.01.52.26;	author yasuoka;	state Exp;
branches;
next	1.6;
commitid	CUwlbzT4LejFC15d;

1.6
date	2013.10.23.05.05.19;	author mlarkin;	state Exp;
branches;
next	1.5;

1.5
date	2012.10.30.14.06.29;	author jsing;	state Exp;
branches;
next	1.4;

1.4
date	2012.06.03.13.18.33;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.02.00.36.52;	author weingart;	state Exp;
branches;
next	1.2;

1.2
date	2006.09.18.21.15.33;	author mpf;	state Exp;
branches;
next	1.1;

1.1
date	2004.02.03.12.09.47;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Disable "machine boot" and "machine comaddr" from efiboot.
@
text
@/*	$OpenBSD: cmd_i386.c,v 1.10 2016/06/10 18:36:06 jcs Exp $	*/

/*
 * Copyright (c) 1997-1999 Michael Shalayeff
 * Copyright (c) 1997 Tobias Weingartner
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/reboot.h>
#include <machine/biosvar.h>
#include <sys/disklabel.h>
#include "disk.h"
#include "biosdev.h"
#include "libsa.h"
#include <cmd.h>

#ifdef EFIBOOT
#include "efiboot.h"
#include "efidev.h"
#endif

extern const char version[];

int Xboot(void);
int Xcomaddr(void);
int Xdiskinfo(void);
int Xmemory(void);
int Xregs(void);

/* From gidt.S */
int bootbuf(void *, int);

const struct cmd_table cmd_machine[] = {
#ifndef EFIBOOT
	{ "boot",	CMDT_CMD, Xboot },
	{ "comaddr",	CMDT_CMD, Xcomaddr },
#endif
	{ "diskinfo",	CMDT_CMD, Xdiskinfo },
	{ "memory",	CMDT_CMD, Xmemory },
#ifdef EFIBOOT
	{ "video",	CMDT_CMD, Xvideo_efi },
	{ "exit",	CMDT_CMD, Xexit_efi },
	{ "poweroff",	CMDT_CMD, Xpoweroff_efi },
#endif
#ifdef DEBUG
	{ "regs",	CMDT_CMD, Xregs },
#endif
	{ NULL, 0 }
};

int
Xdiskinfo(void)
{
#ifndef EFIBOOT
	dump_diskinfo();
#else
	efi_dump_diskinfo();
#endif
	return 0;
}

#ifdef DEBUG
int
Xregs(void)
{
	DUMP_REGS;
	return 0;
}
#endif

#ifndef EFIBOOT
int
Xboot(void)
{
	printf("Not supported yet\n");
	int dev, part, st;
	struct diskinfo *dip;
	char buf[DEV_BSIZE], *dest = (void *)BOOTBIOS_ADDR;

	if (cmd.argc != 2) {
		printf("machine boot {fd,hd}<0123>[abcd]\n");
		printf("Where [0123] is the disk number,"
		    " and [abcd] is the partition.\n");
		return 0;
	}

	/* Check arg */
	if (cmd.argv[1][0] != 'f' && cmd.argv[1][0] != 'h')
		goto bad;
	if (cmd.argv[1][1] != 'd')
		goto bad;
	if (cmd.argv[1][2] < '0' || cmd.argv[1][2] > '3')
		goto bad;
	if ((cmd.argv[1][3] < 'a' || cmd.argv[1][3] > 'd') &&
	    cmd.argv[1][3] != '\0')
		goto bad;

	printf("Booting from %s ", cmd.argv[1]);

	dev = (cmd.argv[1][0] == 'h')?0x80:0;
	dev += (cmd.argv[1][2] - '0');
	part = (cmd.argv[1][3] - 'a');

	if (part > 0)
		printf("[%x,%d]\n", dev, part);
	else
		printf("[%x]\n", dev);

	/* Read boot sector from device */
	dip = dklookup(dev);
	st = dip->diskio(F_READ, dip, 0, 1, buf);
	if (st)
		goto bad;

	/* Frob boot flag in buffer from HD */
	if ((dev & 0x80) && (part > 0)){
		int i, j;

		for (i = 0, j = DOSPARTOFF; i < 4; i++, j += 16)
			if (part == i)
				buf[j] |= 0x80;
			else
				buf[j] &= ~0x80;
	}

	/* Load %dl, ljmp */
	bcopy(buf, dest, DEV_BSIZE);
	bootbuf(dest, dev);

bad:
	printf("Invalid device!\n");
	return 0;
}
#endif

int
Xmemory(void)
{
	if (cmd.argc >= 2) {
		int i;
		/* parse the memory specs */

		for (i = 1; i < cmd.argc; i++) {
			char *p;
			long long addr, size;

			p = cmd.argv[i];

			size = strtoll(p + 1, &p, 0);
			/* Size the size */
			switch (*p) {
				case 'G':
				case 'g':
					size *= 1024;
				case 'M':
				case 'm':
					size *= 1024;
				case 'K':
				case 'k':
					size *= 1024;
					p++;
			}

			/* Handle (possibly non-existent) address part */
			switch (*p) {
				case '@@':
					addr = strtoll(p + 1, NULL, 0);
					break;

				/* Adjust address if we don't need it */
				default:
					if (cmd.argv[i][0] == '=')
						addr = -1;
					else
						addr = 0;
			}

			if (addr == 0 || size == 0) {
				printf("bad language\n");
				return 0;
			} else {
				switch (cmd.argv[i][0]) {
				case '-':
					mem_delete(addr, addr + size);
					break;
				case '+':
					mem_add(addr, addr + size);
					break;
				case '=':
					mem_limit(size);
					break;
				default :
					printf("bad OP\n");
					return 0;
				}
			}
		}
	}

	dump_biosmem(NULL);

	return 0;
}

#ifndef EFIBOOT
int
Xcomaddr(void)
{
	extern int com_addr;

	if (cmd.argc >= 2)
		com_addr = (int)strtol(cmd.argv[1], NULL, 0);

	return 0;
}
#endif
@


1.10
log
@fix some typos in comments

from Tom Cosgrove
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.9 2015/11/08 00:42:39 yasuoka Exp $	*/
d57 1
d60 1
d94 1
a97 1
#ifdef EFIBOOT
a98 1
#else
a154 1
#endif
d157 1
d228 1
d239 1
@


1.9
log
@Make "machine disk" show some info for EFI instead of info for BIOS.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.8 2015/09/18 13:30:56 miod Exp $	*/
d186 1
a186 1
			/* Handle (possibly non-existant) address part */
@


1.8
log
@Remove support for building the boot blocks with DEBUGFLAGS=-D_TEST, which is
supposed to create a userland binary in order to test non-boot related
functionality. This feature has been bitrotting in a non-compiling state
for years, and causes a too-many-ifdefs disease now that there are intrusive
EFI changes.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.7 2015/09/02 01:52:26 yasuoka Exp $	*/
d42 1
d75 1
d77 3
@


1.7
log
@Initial commit of uefi boot loader of OpenBSD.

ok deraadt yuo
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.6 2013/10/23 05:05:19 mlarkin Exp $	*/
a73 1
#ifndef _TEST
a74 1
#endif
a92 1
#ifndef _TEST
a148 1
#endif
@


1.6
log
@

Allow uppercase "K/M/G" specification in "machine memory" boot command.

ok guenther, dlg, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.5 2012/10/30 14:06:29 jsing Exp $	*/
d40 3
d60 5
d92 3
d97 1
a97 1
	bios_diskinfo_t *bd = NULL;
d130 2
a131 2
	bd = bios_dklookup(dev);
	st = biosd_io(F_READ, bd, 0, 1, buf);
d152 1
@


1.5
log
@Apply a bunch of style(9) and whitespace fixes to i386/amd64 libsa, making
the code actually diffable. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.3 2010/07/02 00:36:52 weingart Exp $	*/
d162 1
d165 1
d168 1
@


1.4
log
@Add support for serial consoles at non-standard addresses.  This implements
a new "machine comaddr" command that makes it possible to configure the
io port used to access the serial port.  This can be used to use serial ports
on a puc(4) device as serial console.
@
text
@d17 2
a18 2
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
d53 4
a56 4
	{ "boot",     CMDT_CMD, Xboot },
	{ "comaddr",  CMDT_CMD, Xcomaddr },
	{ "diskinfo", CMDT_CMD, Xdiskinfo },
	{ "memory",   CMDT_CMD, Xmemory },
d58 1
a58 1
	{ "regs",     CMDT_CMD, Xregs },
d89 1
a89 1
	if(cmd.argc != 2) {
d92 1
a92 1
			" and [abcd] is the partition.\n");
d97 1
a97 1
	if(cmd.argv[1][0] != 'f' && cmd.argv[1][0] != 'h')
d99 1
a99 1
	if(cmd.argv[1][1] != 'd')
d101 1
a101 1
	if(cmd.argv[1][2] < '0' || cmd.argv[1][2] > '3')
d103 2
a104 1
	if((cmd.argv[1][3] < 'a' || cmd.argv[1][3] > 'd') && cmd.argv[1][3] != '\0')
d121 2
a122 1
	if(st) goto bad;
d125 1
a125 1
	if((dev & 0x80) && (part > 0)){
d128 2
a129 2
		for(i = 0, j = DOSPARTOFF; i < 4; i++, j += 16)
			if(part == i)
d160 1
a160 1
			switch(*p) {
d171 1
a171 1
			switch(*p) {
d185 1
a185 1
				printf ("bad language\n");
d199 1
a199 1
					printf ("bad OP\n");
@


1.3
log
@Add ability to limit memory presented to kernel with
'machine memory =128M' style commands.  Thanks to
phessler for finding a small man page niggle.  Bumped
version strings to a nice round fraction, and make them
the same across the board.  Easier to identify boot
binary versions that way.

ok thib@@, tedu@@, phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.2 2006/09/18 21:15:33 mpf Exp $	*/
d44 1
d54 1
d205 11
@


1.2
log
@boot(8) ``machine memory'' support for > 4G.
Convert parser to strtoll(3) and use 64bit printf.
With help from mickey@@
i386 and amd64 tests by me, alpha test by mickey@@
OK mickey@@, miod@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.1 2004/02/03 12:09:47 mickey Exp $	*/
d155 26
a180 5
			if (*p && *p == '@@')
				addr = strtoll(p + 1, NULL, 0);
			else
				addr = 0;
			if (addr == 0 && (*p != '@@' || size == 0)) {
d190 3
@


1.1
log
@das boot; das cloned das from das i386
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.27 2003/08/11 06:23:09 deraadt Exp $	*/
d150 1
a150 1
			long addr, size;
d154 1
a154 1
			size = strtol(p + 1, &p, 0);
d156 1
a156 1
				addr = strtol(p + 1, NULL, 0);
@

