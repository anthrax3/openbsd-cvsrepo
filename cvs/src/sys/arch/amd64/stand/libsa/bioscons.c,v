head	1.11;
access;
symbols
	OPENBSD_6_1:1.11.0.6
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.2
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.10.0.6
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.8
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.4
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.9.0.8
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.4
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.2
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.16
	OPENBSD_5_0:1.5.0.14
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.12
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.10
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.6
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.8
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.4
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.2
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.4.0.2
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.3.0.2
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.2.0.2
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.1.0.12
	OPENBSD_4_0_BASE:1.1
	OPENBSD_3_9:1.1.0.14
	OPENBSD_3_9_BASE:1.1
	OPENBSD_3_8:1.1.0.10
	OPENBSD_3_8_BASE:1.1
	OPENBSD_3_7:1.1.0.8
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.6
	OPENBSD_3_6_BASE:1.1
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	OPENBSD_3_5:1.1.0.4
	OPENBSD_3_5_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.11
date	2016.05.27.05.37.51;	author beck;	state Exp;
branches;
next	1.10;
commitid	hGj7TtravhkHshT2;

1.10
date	2014.03.29.18.09.28;	author guenther;	state Exp;
branches;
next	1.9;

1.9
date	2013.01.17.12.07.19;	author jsing;	state Exp;
branches;
next	1.8;

1.8
date	2012.10.30.14.06.29;	author jsing;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.21.02.42;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2012.06.03.13.18.33;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2008.04.20.01.46.35;	author dlg;	state Exp;
branches;
next	1.4;

1.4
date	2008.01.23.16.37.56;	author jsing;	state Exp;
branches;
next	1.3;

1.3
date	2007.04.28.19.23.10;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2007.01.02.16.34.16;	author tom;	state Exp;
branches;
next	1.1;

1.1
date	2004.02.03.12.09.47;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Modify com_init to match the com driver initializaiton, and add
a short delay so that baud rate changes on the console have
a chance of working.  Lots of help from theo on this one.

Makes my serial console on my APU work for an unattended
reboot instead of hanging when garbage is echoed to the tty.
ok deraadt@@
@
text
@/*	$OpenBSD: bioscons.c,v 1.10 2014/03/29 18:09:28 guenther Exp $	*/

/*
 * Copyright (c) 1997-1999 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>

#include <machine/biosvar.h>
#include <machine/pio.h>

#include <dev/cons.h>
#include <dev/ic/mc146818reg.h>
#include <dev/ic/comreg.h>
#include <dev/ic/ns16450reg.h>
#include <dev/isa/isareg.h>

#include <lib/libsa/stand.h>

#include "biosdev.h"

/* XXX cannot trust NVRAM on this.  Maybe later we make a real probe.  */
#if 0
#define PRESENT_MASK (NVRAM_EQUIPMENT_KBD|NVRAM_EQUIPMENT_DISPLAY)
#else
#define PRESENT_MASK 0
#endif

void
pc_probe(struct consdev *cn)
{
	cn->cn_pri = CN_MIDPRI;
	cn->cn_dev = makedev(12, 0);
	printf(" pc%d", minor(cn->cn_dev));

#if 0
	outb(IO_RTC, NVRAM_EQUIPMENT);
	if ((inb(IO_RTC+1) & PRESENT_MASK) == PRESENT_MASK) {
		cn->cn_pri = CN_MIDPRI;
		/* XXX from i386/conf.c */
		cn->cn_dev = makedev(12, 0);
		printf(" pc%d", minor(cn->cn_dev));
	}
#endif
}

void
pc_init(struct consdev *cn)
{
}

int
pc_getc(dev_t dev)
{
	register int rv;

	if (dev & 0x80) {
		__asm volatile(DOINT(0x16) "; setnz %b0" : "=a" (rv) :
		    "0" (0x100) : "%ecx", "%edx", "cc" );
		return (rv & 0xff);
	}

	/*
	 * Wait for a character to actually become available.  Appears to
	 * be necessary on (at least) the Intel Mac Mini.
	 */
	do {
		__asm volatile(DOINT(0x16) "; setnz %b0" : "=a" (rv) :
		    "0" (0x100) : "%ecx", "%edx", "cc" );
	} while ((rv & 0xff) == 0);

	__asm volatile(DOINT(0x16) : "=a" (rv) : "0" (0x000) :
	    "%ecx", "%edx", "cc" );

	return (rv & 0xff);
}

int
pc_getshifts(dev_t dev)
{
	register int rv;

	__asm volatile(DOINT(0x16) : "=a" (rv) : "0" (0x200) :
	    "%ecx", "%edx", "cc" );

	return (rv & 0xff);
}

void
pc_putc(dev_t dev, int c)
{
	__asm volatile(DOINT(0x10) : : "a" (c | 0xe00), "b" (1) :
	    "%ecx", "%edx", "cc" );
}

const int comports[4] = { 0x3f8, 0x2f8, 0x3e8, 0x2e8 };

void
com_probe(struct consdev *cn)
{
	register int i, n;

	/* get equip. (9-11 # of coms) */
	__asm volatile(DOINT(0x11) : "=a" (n) : : "%ecx", "%edx", "cc");
	n >>= 9;
	n &= 7;
	for (i = 0; i < n; i++)
		printf(" com%d", i);

	cn->cn_pri = CN_LOWPRI;
	/* XXX from i386/conf.c */
	cn->cn_dev = makedev(8, 0);
}

int com_speed = -1;
int com_addr = -1;

void
com_init(struct consdev *cn)
{
	int port = (com_addr == -1) ? comports[minor(cn->cn_dev)] : com_addr;
	time_t tt = getsecs() + 1;
	u_long i = 1;

	outb(port + com_ier, 0);
	if (com_speed == -1)
		comspeed(cn->cn_dev, 9600); /* default speed is 9600 baud */
	outb(port + com_mcr, MCR_DTR | MCR_RTS);
	outb(port + com_ier, 0);
	outb(port + com_fifo, FIFO_ENABLE | FIFO_RCV_RST | FIFO_XMT_RST |
	    FIFO_TRIGGER_1);
	(void) inb(port + com_iir);

	/* A few ms delay for the chip, using the getsecs() API */
	while (!(i++ % 1000) && getsecs() < tt)
		;

	/* drain the input buffer */
	while (inb(port + com_lsr) & LSR_RXRDY)
		(void)inb(port + com_data);
}

int
com_getc(dev_t dev)
{
	int port = (com_addr == -1) ? comports[minor(dev & 0x7f)] : com_addr;

	if (dev & 0x80)
		return (inb(port + com_lsr) & LSR_RXRDY);

	while ((inb(port + com_lsr) & LSR_RXRDY) == 0)
		;

	return (inb(port + com_data) & 0xff);
}

/* call with sp == 0 to query the current speed */
int
comspeed(dev_t dev, int sp)
{
	int port = (com_addr == -1) ? comports[minor(dev)] : com_addr;
	int i, newsp;
	int err;

	if (sp <= 0)
		return com_speed;
	/* valid baud rate? */
	if (115200 < sp || sp < 75)
		return -1;

	/*
	 * Accepted speeds:
	 *   75 150 300 600 1200 2400 4800 9600 19200 38400 76800 and
	 *   14400 28800 57600 115200
	 */
	for (i = sp; i != 75 && i != 14400; i >>= 1)
		if (i & 1)
			return -1;

/* ripped screaming from dev/ic/com.c */
#define divrnd(n, q)    (((n)*2/(q)+1)/2)       /* divide and round off */
	newsp = divrnd((COM_FREQ / 16), sp);
	if (newsp <= 0)
		return -1;
	err = divrnd((COM_FREQ / 16) * 1000, sp * newsp) - 1000;
	if (err < 0)
		err = -err;
	if (err > COM_TOLERANCE)
		return -1;
#undef  divrnd

	if (com_speed != -1 && cn_tab && cn_tab->cn_dev == dev &&
	    com_speed != sp) {
		printf("com%d: changing speed to %d baud in 5 seconds, "
		    "change your terminal to match!\n\a",
		    minor(dev), sp);
		sleep(5);
	}

	outb(port + com_cfcr, LCR_DLAB);
	outb(port + com_dlbl, newsp);
	outb(port + com_dlbh, newsp>>8);
	outb(port + com_cfcr, LCR_8BITS);
	if (com_speed != -1)
		printf("\ncom%d: %d baud\n", minor(dev), sp);

	newsp = com_speed;
	com_speed = sp;
	return newsp;
}

void
com_putc(dev_t dev, int c)
{
	int port = (com_addr == -1) ? comports[minor(dev)] : com_addr;

	while ((inb(port + com_lsr) & LSR_TXRDY) == 0)
		;

	outb(port + com_data, c);
}
@


1.10
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.9 2013/01/17 12:07:19 jsing Exp $	*/
d144 2
d151 1
d154 5
@


1.9
log
@Clean includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.6 2012/06/03 13:18:33 kettenis Exp $	*/
d80 1
a80 1
		__asm __volatile(DOINT(0x16) "; setnz %b0" : "=a" (rv) :
d90 1
a90 1
		__asm __volatile(DOINT(0x16) "; setnz %b0" : "=a" (rv) :
d94 1
a94 1
	__asm __volatile(DOINT(0x16) : "=a" (rv) : "0" (0x000) :
d105 1
a105 1
	__asm __volatile(DOINT(0x16) : "=a" (rv) : "0" (0x200) :
d114 1
a114 1
	__asm __volatile(DOINT(0x10) : : "a" (c | 0xe00), "b" (1) :
d126 1
a126 1
	__asm __volatile(DOINT(0x11) : "=a" (n) : : "%ecx", "%edx", "cc");
@


1.8
log
@Apply a bunch of style(9) and whitespace fixes to i386/amd64 libsa, making
the code actually diffable. No binary change.
@
text
@d30 1
d33 2
a34 1
#include <dev/isa/isareg.h>
d38 2
a39 2
/* #include <i386/isa/nvram.h> */
#include <dev/cons.h>
d41 1
@


1.7
log
@Always allow serial console, even if the BIOS doesn't report the presence of
any serial ports.  Otherwise the new code to use puc(4) ports as serial
console isn't all that useful.

ok sthen@@, miod@@
@
text
@d93 1
d134 1
a134 1
int com_speed = -1;  /* default speed is 9600 baud */
d144 1
a144 1
		comspeed(cn->cn_dev, 9600);
@


1.6
log
@Add support for serial consoles at non-standard addresses.  This implements
a new "machine comaddr" command that makes it possible to configure the
io port used to access the serial port.  This can be used to use serial ports
on a puc(4) device as serial console.
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.5 2008/04/20 01:46:35 dlg Exp $	*/
d127 4
a130 5
	if (n) {
		cn->cn_pri = CN_LOWPRI;
		/* XXX from i386/conf.c */
		cn->cn_dev = makedev(8, 0);
	}
@


1.5
log
@rewrite the serial port handling to manipulate the hardware directly
rather than relying on calls into the bios to work.

this is a result of me getting pissed off with solaris and linux
being able to cope the serial bios redirection on dracs, iloms, and
ilos. trying to do the same thing with openbsds boot loader caused
weird behaviour like machine hangs or no visible output. talking
to the serial chips directly is more reliable.

tested by many

ok sthen@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.3 2007/04/28 19:23:10 deraadt Exp $	*/
d135 1
d140 1
a140 1
	int port = comports[minor(cn->cn_dev)];
d157 1
a157 1
	int port = comports[minor(dev & 0x7f)];
d172 1
d174 1
a174 1
        int err;
d211 4
a214 4
	outb(comports[minor(dev)] + com_cfcr, LCR_DLAB);
	outb(comports[minor(dev)] + com_dlbl, newsp);
	outb(comports[minor(dev)] + com_dlbh, newsp>>8);
	outb(comports[minor(dev)] + com_cfcr, LCR_8BITS);
d226 1
a226 1
	int port = comports[minor(dev)];
a232 1

@


1.4
log
@Cleanup cn_pri. Change constants to more meaningful names, rather than
the hp300 related ones currently in use. CN_NORMAL becomes CN_LOWPRI,
CN_INTERNAL becomes CN_MIDPRI and CN_REMOTE becomes CN_HIGHPRI.

ok miod@@
@
text
@d134 2
d139 1
a139 1
	register int unit = minor(cn->cn_dev);
d141 10
a150 3
	/* let bios do necessary init first, 9600-N-1 */
	__asm __volatile(DOINT(0x14) : : "a" (0xe3), "d" (unit) :
	    "%ecx", "cc" );
d156 1
a156 1
	register int rv;
d158 2
a159 5
	if (dev & 0x80) {
		__asm __volatile(DOINT(0x14) : "=a" (rv) :
		    "0" (0x300), "d" (minor(dev&0x7f)) : "%ecx", "cc" );
		return ((rv & 0x100) == 0x100);
	}
d161 2
a162 4
	do
		__asm __volatile(DOINT(0x14) : "=a" (rv) :
		    "0" (0x200), "d" (minor(dev)) : "%ecx", "cc" );
	while (rv & 0x8000);
d164 1
a164 1
	return (rv & 0xff);
a167 1
int com_speed = 9600;  /* default speed is 9600 baud */
d201 2
a202 1
	if (cn_tab && cn_tab->cn_dev == dev && com_speed != sp) {
d213 2
a214 1
	printf("\ncom%d: %d baud\n", minor(dev), sp);
d224 1
a224 1
	register int rv;
d226 2
a227 1
	dev = minor(dev) & 0x7f;
d229 1
a229 9
	/* check online (DSR) */
	__asm __volatile(DOINT(0x14) : "=a" (rv) :
	    "0" (0x300), "d" (dev) : "%ecx", "cc" );
	if ( !(rv & 0x20) )
		return;

	/* send character */
	__asm __volatile(DOINT(0x14) : "=a" (rv) :
	    "0" (c | 0x100), "d" (dev) : "%ecx", "cc" );
@


1.3
log
@clone "Control key" logic from i386 written by tom; tested by art
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.2 2007/01/02 16:34:16 tom Exp $	*/
d51 1
a51 1
	cn->cn_pri = CN_INTERNAL;
d58 1
a58 1
		cn->cn_pri = CN_INTERNAL;
d128 1
a128 1
		cn->cn_pri = CN_NORMAL;
@


1.2
log
@Issue the BIOS "check for keystroke" call before "get keystroke", as
now required on i386 for Intel Macs.

Bump versions of boot, cdboot and pxeboot accordingly.

Reminded by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.1 2004/02/03 12:09:47 mickey Exp $	*/
d93 11
@


1.1
log
@das boot; das cloned das from das i386
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.26 2003/12/16 03:10:18 deraadt Exp $	*/
d81 9
@

