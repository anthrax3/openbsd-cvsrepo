head	1.17;
access;
symbols
	OPENBSD_6_0:1.13.0.2
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11;
locks; strict;
comment	@ * @;


1.17
date	2017.03.03.08.56.18;	author yasuoka;	state Exp;
branches;
next	1.16;
commitid	UkoMqxtPWOV7Hg2W;

1.16
date	2017.03.01.02.11.23;	author yasuoka;	state Exp;
branches;
next	1.15;
commitid	OGNhum9waET9G9qS;

1.15
date	2017.02.08.04.00.04;	author yasuoka;	state Exp;
branches;
next	1.14;
commitid	jV1pVWxSo3Olab7C;

1.14
date	2016.08.30.20.31.09;	author yasuoka;	state Exp;
branches;
next	1.13;
commitid	VQpum0lK6z0wbLqA;

1.13
date	2016.06.10.18.36.06;	author jcs;	state Exp;
branches;
next	1.12;
commitid	x57WcyDUhZLxQO5Z;

1.12
date	2016.05.15.22.48.02;	author kettenis;	state Exp;
branches;
next	1.11;
commitid	kbtD2y2fFJjNB9s6;

1.11
date	2016.02.04.09.19.39;	author kettenis;	state Exp;
branches;
next	1.10;
commitid	DsCovGFgQY7ZUFPY;

1.10
date	2015.11.26.20.26.20;	author yasuoka;	state Exp;
branches;
next	1.9;
commitid	7MyOAYWoN75a8KB6;

1.9
date	2015.11.08.00.17.29;	author yasuoka;	state Exp;
branches;
next	1.8;
commitid	TQmzXlXn4lWD93mI;

1.8
date	2015.11.03.16.03.04;	author yasuoka;	state Exp;
branches;
next	1.7;
commitid	iXSt8vT20MhD9fOP;

1.7
date	2015.11.03.10.56.38;	author yasuoka;	state Exp;
branches;
next	1.6;
commitid	8BHcGPiDR8nZTsSC;

1.6
date	2015.10.05.22.59.39;	author yasuoka;	state Exp;
branches;
next	1.5;
commitid	AT2154iJ6M9q2Mea;

1.5
date	2015.09.23.03.29.26;	author yasuoka;	state Exp;
branches;
next	1.4;
commitid	mFKCorQt9uk45z88;

1.4
date	2015.09.23.03.19.55;	author yasuoka;	state Exp;
branches;
next	1.3;
commitid	z7f6J8PFVkXAL0et;

1.3
date	2015.09.03.09.22.40;	author kettenis;	state Exp;
branches;
next	1.2;
commitid	UKGflsa5xYGO1x40;

1.2
date	2015.09.02.21.22.44;	author kettenis;	state Exp;
branches;
next	1.1;
commitid	mOt2AvlB9JdKPdCf;

1.1
date	2015.09.02.01.52.25;	author yasuoka;	state Exp;
branches;
next	;
commitid	CUwlbzT4LejFC15d;


desc
@@


1.17
log
@Delete "comspeed" which had been mistakenly added as a int value.
@
text
@/*	$OpenBSD: efiboot.c,v 1.16 2017/03/01 02:11:23 yasuoka Exp $	*/

/*
 * Copyright (c) 2015 YASUOKA Masahiko <yasuoka@@yasuoka.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/queue.h>
#include <dev/cons.h>
#include <sys/disklabel.h>
#include <cmd.h>
#include <stand/boot/bootarg.h>

#include "libsa.h"
#include "disk.h"

#include <efi.h>
#include <efiapi.h>
#include <efiprot.h>
#include <eficonsctl.h>

#include "efidev.h"
#include "efiboot.h"
#include "eficall.h"
#include "run_i386.h"

#define	KERN_LOADSPACE_SIZE	(32 * 1024 * 1024)

EFI_SYSTEM_TABLE	*ST;
EFI_BOOT_SERVICES	*BS;
EFI_RUNTIME_SERVICES	*RS;
EFI_HANDLE		 IH;
EFI_DEVICE_PATH		*efi_bootdp = NULL;
EFI_PHYSICAL_ADDRESS	 heap;
EFI_LOADED_IMAGE	*loadedImage;
UINTN			 heapsiz = 1 * 1024 * 1024;
UINTN			 mmap_key;
static EFI_GUID		 imgp_guid = LOADED_IMAGE_PROTOCOL;
static EFI_GUID		 blkio_guid = BLOCK_IO_PROTOCOL;
static EFI_GUID		 devp_guid = DEVICE_PATH_PROTOCOL;
u_long			 efi_loadaddr;

static int	 efi_device_path_cmp(EFI_DEVICE_PATH *, EFI_DEVICE_PATH *, int);
static void	 efi_heap_init(void);
static void	 efi_memprobe_internal(void);
static void	 efi_video_init(void);
static void	 efi_video_reset(void);
EFI_STATUS	 efi_main(EFI_HANDLE, EFI_SYSTEM_TABLE *);

void (*run_i386)(u_long, u_long, int, int, int, int, int, int, int, int)
    __attribute__((noreturn));

extern int bios_bootdev;

EFI_STATUS
efi_main(EFI_HANDLE image, EFI_SYSTEM_TABLE *systab)
{
	extern char		*progname;
	EFI_LOADED_IMAGE	*imgp;
	EFI_DEVICE_PATH		*dp0 = NULL, *dp;
	EFI_STATUS		 status;
	EFI_PHYSICAL_ADDRESS	 stack;

	ST = systab;
	BS = ST->BootServices;
	RS = ST->RuntimeServices;
	IH = image;

	efi_video_init();
	efi_heap_init();

	status = EFI_CALL(BS->HandleProtocol, image, &imgp_guid,
	    (void **)&imgp);
	if (status == EFI_SUCCESS)
		status = EFI_CALL(BS->HandleProtocol, imgp->DeviceHandle,
		    &devp_guid, (void **)&dp0);
	if (status == EFI_SUCCESS) {
		for (dp = dp0; !IsDevicePathEnd(dp);
		    dp = NextDevicePathNode(dp)) {
			if (DevicePathType(dp) == MEDIA_DEVICE_PATH &&
			    DevicePathSubType(dp) == MEDIA_HARDDRIVE_DP) {
				bios_bootdev = 0x80;
				efi_bootdp = dp0;
				break;
			}
		}
	}

#ifdef __amd64__
	/* allocate run_i386_start() on heap */
	if ((run_i386 = alloc(run_i386_size)) == NULL)
		panic("alloc() failed");
	memcpy(run_i386, run_i386_start, run_i386_size);
#endif

	/* can't use sa_cleanup since printf is used after sa_cleanup() */
	/* sa_cleanup = efi_cleanup; */

#ifdef __amd64__
	progname = "BOOTX64";
#else
	progname = "BOOTIA32";
#endif

	/*
	 * Move the stack before calling boot().  UEFI on some machines
	 * locate the stack on our kernel load address.
	 */
	stack = heap + heapsiz;
#if defined(__amd64__)
	asm("movq	%0, %%rsp;"
	    "mov	%1, %%edi;"
	    "call	boot;"
	    :: "r"(stack - 32), "r"(bios_bootdev));
#else
	asm("movl	%0, %%esp;"
	    "movl	%1, (%%esp);"
	    "call	boot;"
	    :: "r"(stack - 32), "r"(bios_bootdev));
#endif
	/* must not reach here */
	return (EFI_SUCCESS);
}

void
efi_cleanup(void)
{
	int		 retry;
	EFI_STATUS	 status;

	/* retry once in case of failure */
	for (retry = 1; retry >= 0; retry--) {
		efi_memprobe_internal();	/* sync the current map */
		status = EFI_CALL(BS->ExitBootServices, IH, mmap_key);
		if (status == EFI_SUCCESS)
			break;
		if (retry == 0)
			panic("ExitBootServices failed (%d)", status);
	}
}

/***********************************************************************
 * Disk
 ***********************************************************************/
struct disklist_lh efi_disklist;

void
efi_diskprobe(void)
{
	int			 i, bootdev;
	UINTN			 sz;
	EFI_STATUS		 status;
	EFI_HANDLE		*handles = NULL;
	EFI_BLOCK_IO		*blkio;
	EFI_BLOCK_IO_MEDIA	*media;
	struct diskinfo		*di;
	EFI_DEVICE_PATH		*dp;

	TAILQ_INIT(&efi_disklist);

	sz = 0;
	status = EFI_CALL(BS->LocateHandle, ByProtocol, &blkio_guid, 0, &sz, 0);
	if (status == EFI_BUFFER_TOO_SMALL) {
		handles = alloc(sz);
		status = EFI_CALL(BS->LocateHandle, ByProtocol, &blkio_guid,
		    0, &sz, handles);
	}
	if (handles == NULL || EFI_ERROR(status))
		panic("BS->LocateHandle() returns %d", status);

	for (i = 0; i < sz / sizeof(EFI_HANDLE); i++) {
		bootdev = 0;
		status = EFI_CALL(BS->HandleProtocol, handles[i], &blkio_guid,
		    (void **)&blkio);
		if (EFI_ERROR(status))
			panic("BS->HandleProtocol() returns %d", status);

		media = blkio->Media;
		if (media->LogicalPartition || !media->MediaPresent)
			continue;
		di = alloc(sizeof(struct diskinfo));
		efid_init(di, blkio);

		if (efi_bootdp == NULL)
			goto next;
		status = EFI_CALL(BS->HandleProtocol, handles[i], &devp_guid,
		    (void **)&dp);
		if (EFI_ERROR(status))
			goto next;
		if (!efi_device_path_cmp(efi_bootdp, dp, HARDWARE_DEVICE_PATH)&&
		    !efi_device_path_cmp(efi_bootdp, dp, ACPI_DEVICE_PATH) &&
		    !efi_device_path_cmp(efi_bootdp, dp, MESSAGING_DEVICE_PATH))
			bootdev = 1;
next:
		if (bootdev)
			TAILQ_INSERT_HEAD(&efi_disklist, di, list);
		else
			TAILQ_INSERT_TAIL(&efi_disklist, di, list);
	}

	free(handles, sz);
}

static int
efi_device_path_cmp(EFI_DEVICE_PATH *dpa, EFI_DEVICE_PATH *dpb, int dptype)
{
	int		 cmp;
	EFI_DEVICE_PATH	*dp, *dpt_a = NULL, *dpt_b = NULL;

	for (dp = dpa; !IsDevicePathEnd(dp); dp = NextDevicePathNode(dp)) {
		if (DevicePathType(dp) == dptype) {
			dpt_a = dp;
			break;
		}
	}
	for (dp = dpb; !IsDevicePathEnd(dp); dp = NextDevicePathNode(dp)) {
		if (DevicePathType(dp) == dptype) {
			dpt_b = dp;
			break;
		}
	}

	if (dpt_a && dpt_b) {
		cmp = DevicePathNodeLength(dpt_a) - DevicePathNodeLength(dpt_b);
		if (cmp)
			return (cmp);
		return (memcmp(dpt_a, dpt_b, DevicePathNodeLength(dpt_a)));
	}

	return ((uintptr_t)dpt_a - (uintptr_t)dpt_b);
}

/***********************************************************************
 * Memory
 ***********************************************************************/
bios_memmap_t		 bios_memmap[64];

static void
efi_heap_init(void)
{
	EFI_STATUS	 status;

	heap = HEAP_LIMIT;
	status = EFI_CALL(BS->AllocatePages, AllocateMaxAddress, EfiLoaderData,
	    EFI_SIZE_TO_PAGES(heapsiz), &heap);
	if (status != EFI_SUCCESS)
		panic("BS->AllocatePages()");
}

void
efi_memprobe(void)
{
	u_int		 n = 0;
	bios_memmap_t	*bm;
	EFI_STATUS	 status;
	EFI_PHYSICAL_ADDRESS
			 addr = 0x10000000ULL;	/* Below 256MB */

	status = EFI_CALL(BS->AllocatePages, AllocateMaxAddress, EfiLoaderData,
	    EFI_SIZE_TO_PAGES(KERN_LOADSPACE_SIZE), &addr);
	if (status != EFI_SUCCESS)
		panic("BS->AllocatePages()");
	efi_loadaddr = addr;

	printf(" mem[");
	efi_memprobe_internal();
	for (bm = bios_memmap; bm->type != BIOS_MAP_END; bm++) {
		if (bm->type == BIOS_MAP_FREE && bm->size > 12 * 1024) {
			if (n++ != 0)
				printf(" ");
			if (bm->size > 1024 * 1024)
				printf("%uM", bm->size / 1024 / 1024);
			else
				printf("%uK", bm->size / 1024);
		}
	}
	printf("]");
}

static void
efi_memprobe_internal(void)
{
	EFI_STATUS		 status;
	UINTN			 mapkey, mmsiz, siz;
	UINT32			 mmver;
	EFI_MEMORY_DESCRIPTOR	*mm0, *mm;
	int			 i, n;
	bios_memmap_t		*bm, bm0;

	cnvmem = extmem = 0;
	bios_memmap[0].type = BIOS_MAP_END;

	siz = 0;
	status = EFI_CALL(BS->GetMemoryMap, &siz, NULL, &mapkey, &mmsiz,
	    &mmver);
	if (status != EFI_BUFFER_TOO_SMALL)
		panic("cannot get the size of memory map");
	mm0 = alloc(siz);
	status = EFI_CALL(BS->GetMemoryMap, &siz, mm0, &mapkey, &mmsiz, &mmver);
	if (status != EFI_SUCCESS)
		panic("cannot get the memory map");
	n = siz / mmsiz;
	mmap_key = mapkey;

	for (i = 0, mm = mm0; i < n; i++, mm = NextMemoryDescriptor(mm, mmsiz)){
		bm0.type = BIOS_MAP_END;
		bm0.addr = mm->PhysicalStart;
		bm0.size = mm->NumberOfPages * EFI_PAGE_SIZE;
		if (mm->Type == EfiReservedMemoryType ||
		    mm->Type == EfiUnusableMemory ||
		    mm->Type == EfiRuntimeServicesCode ||
		    mm->Type == EfiRuntimeServicesData)
			bm0.type = BIOS_MAP_RES;
		else if (mm->Type == EfiLoaderCode ||
		    mm->Type == EfiLoaderData ||
		    mm->Type == EfiBootServicesCode ||
		    mm->Type == EfiBootServicesData ||
		    mm->Type == EfiConventionalMemory)
			bm0.type = BIOS_MAP_FREE;
		else if (mm->Type == EfiACPIReclaimMemory)
			bm0.type = BIOS_MAP_ACPI;
		else if (mm->Type == EfiACPIMemoryNVS)
			bm0.type = BIOS_MAP_NVS;
		else
			/*
			 * XXX Is there anything to do for EfiMemoryMappedIO
			 * XXX EfiMemoryMappedIOPortSpace EfiPalCode?
			 */
			bm0.type = BIOS_MAP_RES;

		for (bm = bios_memmap; bm->type != BIOS_MAP_END; bm++) {
			if (bm->type != bm0.type)
				continue;
			if (bm->addr <= bm0.addr &&
			    bm0.addr <= bm->addr + bm->size) {
				bm->size = bm0.addr + bm0.size - bm->addr;
				break;
			} else if (bm0.addr <= bm->addr &&
			    bm->addr <= bm0.addr + bm0.size) {
				bm->size = bm->addr + bm->size - bm0.addr;
				bm->addr = bm0.addr;
				break;
			}
		}
		if (bm->type == BIOS_MAP_END) {
			*bm = bm0;
			(++bm)->type = BIOS_MAP_END;
		}
	}
	for (bm = bios_memmap; bm->type != BIOS_MAP_END; bm++) {
		if (bm->addr < 0x0a0000)	/* Below memory hole */
			cnvmem =
			    max(cnvmem, (bm->addr + bm->size) / 1024);
		if (bm->addr >= 0x10000 /* Above the memory hole */ &&
		    bm->addr / 1024 == extmem + 1024)
			extmem += bm->size / 1024;
	}
	free(mm0, siz);
}

/***********************************************************************
 * Console
 ***********************************************************************/
static SIMPLE_TEXT_OUTPUT_INTERFACE     *conout = NULL;
static SIMPLE_INPUT_INTERFACE           *conin;
static EFI_GUID				 con_guid
					    = EFI_CONSOLE_CONTROL_PROTOCOL_GUID;
static EFI_GUID				 gop_guid
					    = EFI_GRAPHICS_OUTPUT_PROTOCOL_GUID;
struct efi_video {
	int	cols;
	int	rows;
} efi_video[32];

static void
efi_video_init(void)
{
	EFI_CONSOLE_CONTROL_PROTOCOL	*conctrl = NULL;
	int				 i, mode80x25, mode100x31;
	UINTN				 cols, rows;
	EFI_STATUS			 status;

	conout = ST->ConOut;
	status = EFI_CALL(BS->LocateProtocol, &con_guid, NULL,
	    (void **)&conctrl);
	if (status == EFI_SUCCESS)
		(void)EFI_CALL(conctrl->SetMode, conctrl,
			EfiConsoleControlScreenText);
	mode80x25 = -1;
	mode100x31 = -1;
	for (i = 0; i < conout->Mode->MaxMode; i++) {
		status = EFI_CALL(conout->QueryMode, conout, i, &cols, &rows);
		if (EFI_ERROR(status))
			continue;
		if (mode80x25 < 0 && cols == 80 && rows == 25)
			mode80x25 = i;
		if (mode100x31 < 0 && cols == 100 && rows == 31)
			mode100x31 = i;
		if (i < nitems(efi_video)) {
			efi_video[i].cols = cols;
			efi_video[i].rows = rows;
		}
	}
	if (mode100x31 >= 0)
		EFI_CALL(conout->SetMode, conout, mode100x31);
	else if (mode80x25 >= 0)
		EFI_CALL(conout->SetMode, conout, mode80x25);
	conin = ST->ConIn;
	efi_video_reset();
}

static void
efi_video_reset(void)
{
	EFI_CALL(conout->EnableCursor, conout, TRUE);
	EFI_CALL(conout->SetAttribute, conout,
	    EFI_TEXT_ATTR(EFI_LIGHTGRAY, EFI_BLACK));
	EFI_CALL(conout->ClearScreen, conout);
}

void
efi_cons_probe(struct consdev *cn)
{
	cn->cn_pri = CN_MIDPRI;
	cn->cn_dev = makedev(12, 0);
	printf(" pc%d", minor(cn->cn_dev));
}

void
efi_cons_init(struct consdev *cp)
{
}

int
efi_cons_getc(dev_t dev)
{
	EFI_INPUT_KEY	 key;
	EFI_STATUS	 status;
	UINTN		 dummy;
	static int	 lastchar = 0;

	if (lastchar) {
		int r = lastchar;
		if ((dev & 0x80) == 0)
			lastchar = 0;
		return (r);
	}

	status = EFI_CALL(conin->ReadKeyStroke, conin, &key);
	while (status == EFI_NOT_READY) {
		if (dev & 0x80)
			return (0);
		EFI_CALL(BS->WaitForEvent, 1, &conin->WaitForKey, &dummy);
		status = EFI_CALL(conin->ReadKeyStroke, conin, &key);
	}

	if (dev & 0x80)
		lastchar = key.UnicodeChar;

	return (key.UnicodeChar);
}

void
efi_cons_putc(dev_t dev, int c)
{
	CHAR16	buf[2];

	if (c == '\n')
		efi_cons_putc(dev, '\r');

	buf[0] = c;
	buf[1] = 0;

	EFI_CALL(conout->OutputString, conout, buf);
}

int
efi_cons_getshifts(dev_t dev)
{
	/* XXX */
	return (0);
}

/* XXX: serial console is not supported yet */
int com_addr = -1;
int com_speed = -1;

/***********************************************************************
 * Miscellaneous
 ***********************************************************************/
/*
 * ACPI GUID is confusing in UEFI spec.
 * {EFI_,}_ACPI_20_TABLE_GUID or EFI_ACPI_TABLE_GUID means
 * ACPI 2.0 or above.
 */
static EFI_GUID acpi_guid = ACPI_20_TABLE_GUID;
static EFI_GUID smbios_guid = SMBIOS_TABLE_GUID;

#define	efi_guidcmp(_a, _b)	memcmp((_a), (_b), sizeof(EFI_GUID))

void
efi_makebootargs(void)
{
	int			 i;
	EFI_STATUS		 status;
	EFI_GRAPHICS_OUTPUT	*gop;
	EFI_GRAPHICS_OUTPUT_MODE_INFORMATION
				*gopi;
	bios_efiinfo_t		 ei;
	int			 bestmode = -1;
	UINTN			 sz, gopsiz, bestsiz = 0;
	EFI_GRAPHICS_OUTPUT_MODE_INFORMATION
				*info;

	memset(&ei, 0, sizeof(ei));
	/*
	 * ACPI, BIOS configuration table
	 */
	for (i = 0; i < ST->NumberOfTableEntries; i++) {
		if (efi_guidcmp(&acpi_guid,
		    &ST->ConfigurationTable[i].VendorGuid) == 0)
			ei.config_acpi = (intptr_t)
			    ST->ConfigurationTable[i].VendorTable;
		else if (efi_guidcmp(&smbios_guid,
		    &ST->ConfigurationTable[i].VendorGuid) == 0)
			ei.config_smbios = (intptr_t)
			    ST->ConfigurationTable[i].VendorTable;
	}

	/*
	 * Frame buffer
	 */
	status = EFI_CALL(BS->LocateProtocol, &gop_guid, NULL,
	    (void **)&gop);
	if (!EFI_ERROR(status)) {
		for (i = 0; i < gop->Mode->MaxMode; i++) {
			status = EFI_CALL(gop->QueryMode, gop, i, &sz, &info);
			if (EFI_ERROR(status))
				continue;
			gopsiz = info->HorizontalResolution *
			    info->VerticalResolution;
			if (gopsiz > bestsiz) {
				bestmode = i;
				bestsiz = gopsiz;
			}
		}
		if (bestmode >= 0) {
			status = EFI_CALL(gop->SetMode, gop, bestmode);
			if (EFI_ERROR(status) && gop->Mode->Mode != bestmode)
				printf("GOP setmode failed(%d)\n", status);
		}

		gopi = gop->Mode->Info;
		switch (gopi->PixelFormat) {
		case PixelBlueGreenRedReserved8BitPerColor:
			ei.fb_red_mask      = 0x00ff0000;
			ei.fb_green_mask    = 0x0000ff00;
			ei.fb_blue_mask     = 0x000000ff;
			ei.fb_reserved_mask = 0xff000000;
			break;
		case PixelRedGreenBlueReserved8BitPerColor:
			ei.fb_red_mask      = 0x000000ff;
			ei.fb_green_mask    = 0x0000ff00;
			ei.fb_blue_mask     = 0x00ff0000;
			ei.fb_reserved_mask = 0xff000000;
			break;
		case PixelBitMask:
			ei.fb_red_mask = gopi->PixelInformation.RedMask;
			ei.fb_green_mask = gopi->PixelInformation.GreenMask;
			ei.fb_blue_mask = gopi->PixelInformation.BlueMask;
			ei.fb_reserved_mask =
			    gopi->PixelInformation.ReservedMask;
			break;
		default:
			break;
		}
		ei.fb_addr = gop->Mode->FrameBufferBase;
		ei.fb_size = gop->Mode->FrameBufferSize;
		ei.fb_height = gopi->VerticalResolution;
		ei.fb_width = gopi->HorizontalResolution;
		ei.fb_pixpsl = gopi->PixelsPerScanLine;
	}

	addbootarg(BOOTARG_EFIINFO, sizeof(ei), &ei);
}

void
_rtt(void)
{
#ifdef EFI_DEBUG
	printf("Hit any key to reboot\n");
	efi_cons_getc(0);
#endif
	EFI_CALL(RS->ResetSystem, EfiResetCold, EFI_SUCCESS, 0, NULL);
	while (1) { }
}

time_t
getsecs(void)
{
	EFI_TIME	t;
	time_t		r = 0;
	int		y = 0;
	const int	daytab[][14] = {
	    { 0, -1, 30, 58, 89, 119, 150, 180, 211, 242, 272, 303, 333, 364 },
	    { 0, -1, 30, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 },
	};
#define isleap(_y) (((_y) % 4) == 0 && (((_y) % 100) != 0 || ((_y) % 400) == 0))

	EFI_CALL(ST->RuntimeServices->GetTime, &t, NULL);

	/* Calc days from UNIX epoch */
	r = (t.Year - 1970) * 365;
	for (y = 1970; y < t.Year; y++) {
		if (isleap(y))
			r++;
	}
	r += daytab[isleap(t.Year)? 1 : 0][t.Month] + t.Day;

	/* Calc secs */
	r *= 60 * 60 * 24;
	r += ((t.Hour * 60) + t.Minute) * 60 + t.Second;
	if (-24 * 60 < t.TimeZone && t.TimeZone < 24 * 60)
		r += t.TimeZone * 60;

	return (r);
}

/***********************************************************************
 * Commands
 ***********************************************************************/
int
Xexit_efi(void)
{
	EFI_CALL(BS->Exit, IH, 0, 0, NULL);
	while (1) { }
	return (0);
}

int
Xvideo_efi(void)
{
	int	 i, mode = -1;
	char	*p;

	for (i = 0; i < nitems(efi_video) && i < conout->Mode->MaxMode; i++) {
		if (efi_video[i].cols > 0)
			printf("Mode %d: %d x %d\n", i,
			    efi_video[i].cols, efi_video[i].rows);
	}
	if (cmd.argc == 2) {
		p = cmd.argv[1];
		mode = strtol(p, &p, 10);
	}
	printf("\nCurrent Mode = %d\n", conout->Mode->Mode);
	if (0 <= mode && mode < i && efi_video[mode].cols > 0) {
		EFI_CALL(conout->SetMode, conout, mode);
		efi_video_reset();
	}

	return (0);
}

int
Xpoweroff_efi(void)
{
	EFI_CALL(RS->ResetSystem, EfiResetShutdown, EFI_SUCCESS, 0, NULL);
	return (0);
}
@


1.16
log
@Fix the code which preserves the device path of the loaded image if
booting from a disk.  It had a typo.  Also tweak the code which finds
the blkio of the boot disk to show how it is matching the device path
nodes clearly.  found by and discussed with patrick@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: efiboot.c,v 1.15 2017/02/08 04:00:04 yasuoka Exp $	*/
a496 1
int comspeed = 9600;
@


1.15
log
@Retry BS->ExitBootServices() if it fails.
Reported by Ryan, pulse.purge at gmail.com
@
text
@d1 1
a1 1
/*	$OpenBSD: efiboot.c,v 1.14 2016/08/30 20:31:09 yasuoka Exp $	*/
d44 2
a45 1
EFI_HANDLE		 IH, efi_bootdp = NULL;
d55 1
d92 2
a93 3
			if (DevicePathType(dp) == MEDIA_DEVICE_PATH)
				continue;
			if (DevicePathSubType(dp) == MEDIA_HARDDRIVE_DP) {
d95 1
a95 1
				efi_bootdp = dp;
a97 1
			break;
d169 1
a169 1
	EFI_DEVICE_PATH		*dp, *bp;
d202 4
a205 12
		bp = efi_bootdp;
		while (1) {
			if (IsDevicePathEnd(dp)) {
				bootdev = 1;
				break;
			}
			if (memcmp(dp, bp, sizeof(EFI_DEVICE_PATH)) != 0 ||
			    memcmp(dp, bp, DevicePathNodeLength(dp)) != 0)
				break;
			dp = NextDevicePathNode(dp);
			bp = NextDevicePathNode(bp);
		}
d214 29
@


1.14
log
@Use MaxMode to terminate the mode iteration.  Actually the old way
couldn't interate the ConsOut modes properly on qemu.

input NONAKA Kimihiro
@
text
@d1 1
a1 1
/*	$OpenBSD: efiboot.c,v 1.13 2016/06/10 18:36:06 jcs Exp $	*/
d140 1
d143 9
a151 4
	efi_memprobe_internal();	/* sync the current map */
	status = EFI_CALL(BS->ExitBootServices, IH, mmap_key);
	if (status != EFI_SUCCESS)
		panic("ExitBootServices");
@


1.13
log
@fix some typos in comments

from Tom Cosgrove
@
text
@d1 1
a1 1
/*	$OpenBSD: efiboot.c,v 1.12 2016/05/15 22:48:02 kettenis Exp $	*/
d376 1
a376 1
	for (i = 0; ; i++) {
d379 1
a379 1
			break;
d522 1
a522 1
		for (i = 0; ; i++) {
d525 1
a525 1
				break;
d632 4
a635 3
	for (i = 0; i < nitems(efi_video) && efi_video[i].cols > 0; i++) {
		printf("Mode %d: %d x %d\n", i,
		    efi_video[i].cols, efi_video[i].rows);
d642 1
a642 1
	if (0 <= mode && mode < i) {
@


1.12
log
@Give the 32-bit and 64-bit EFI boatloaders different names such that we can
tell which one we're using.

ok deraadt@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: efiboot.c,v 1.11 2016/02/04 09:19:39 kettenis Exp $	*/
d469 1
a469 1
/* XXX: serial console is not supporte yet */
d480 1
a480 1
 * ACPI 2.0 or abobe.
@


1.11
log
@Some (buggy) UEFI implementations don't report the correct framebuffer
parameters unless SetMode() has been called, even if we don't actually
change the mode.  Other (equally buggy) UEFI implementations report an
error if we call SetMode() but don't actually change the mode.  Work around
these issues by always calling SetMode() (like we did before rev 1.10), but
don't report an error if the current mode is the same as the desired mode.

ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: efiboot.c,v 1.10 2015/11/26 20:26:20 yasuoka Exp $	*/
d111 5
a115 1
	progname = "EFIBOOT";
@


1.10
log
@Avoid setting mode to GOP if the mode is unchanged.  Also don't panic
if the setting mode is failed.

reported and tested by Joe Gidi
@
text
@d1 1
a1 1
/*	$OpenBSD: efiboot.c,v 1.9 2015/11/08 00:17:29 yasuoka Exp $	*/
d529 1
a529 1
		if (bestmode >= 0 && conout->Mode->Mode != bestmode) {
d531 1
a531 1
			if (EFI_ERROR(status))
@


1.9
log
@Make the variables be "const" and fix white space.
@
text
@d1 1
a1 1
/*	$OpenBSD: efiboot.c,v 1.8 2015/11/03 16:03:04 yasuoka Exp $	*/
d529 1
a529 1
		if (bestmode >= 0) {
d532 1
a532 1
				panic("GOP setmode failed(%d)", status);
@


1.8
log
@Ignore disks whose media is not present.
@
text
@d1 1
a1 1
/*	$OpenBSD: efiboot.c,v 1.7 2015/11/03 10:56:38 yasuoka Exp $	*/
d583 4
a586 4
	EFI_TIME		t;
	time_t			r = 0;
	int			y = 0;
	int			daytab[][14] = {
@


1.7
log
@Use "Loaded Image Protocol" instead of "Loaded Device Path Protocol"
to find the boot device since macbook doesn't support later protocol.

reported by Joel Roberts and Bryan Vyhmeister
@
text
@d1 1
a1 1
/*	$OpenBSD: efiboot.c,v 1.6 2015/10/05 22:59:39 yasuoka Exp $	*/
d181 1
a181 1
		if (media->LogicalPartition)
@


1.6
log
@Fix efiboot not to use the usual kernel load address.  Load the kernel in
an allocated region and also move the stack to the end of the heap region.
Then move the kernel to the usual place just before run the kernel, after
calling ExitBootService().

report/test Toby Slight, Brian Conway
@
text
@d1 1
a1 1
/*	$OpenBSD: efiboot.c,v 1.5 2015/09/23 03:29:26 yasuoka Exp $	*/
d49 3
a51 2
static EFI_GUID		 imgdp_guid = { 0xbc62157e, 0x3e33, 0x4fec,
			    { 0x99, 0x20, 0x2d, 0x3b, 0x36, 0xd7, 0x50, 0xdf }};
d69 1
d82 5
a86 2
	status = EFI_CALL(BS->HandleProtocol, image, &imgdp_guid,
	    (void **)&dp0);
a146 2
static EFI_GUID blkio_guid = BLOCK_IO_PROTOCOL;
static EFI_GUID devp_guid = DEVICE_PATH_PROTOCOL;
a174 1
		blkio = handles[i];
@


1.5
log
@Fix white spaces and style.
@
text
@d1 1
a1 1
/*	$OpenBSD: efiboot.c,v 1.4 2015/09/23 03:19:55 yasuoka Exp $	*/
d39 2
d51 1
d67 4
a70 3
	extern char	*progname;
	EFI_DEVICE_PATH *dp0 = NULL, *dp;
	EFI_STATUS	 status;
d108 17
a124 2
	boot(bios_bootdev);

d234 9
d267 1
a267 1
	bios_memmap_t		 *bm, bm0;
@


1.4
log
@efiboot used 3MB memory below the region for the kernel, but UEFI
firmware on some machines allocates larger area whose upper part
overlaps the kernel region.  Let the efiboot use lower area for its
heap.  Also change its size from 3MB to 1MB and limit it by
HEAP_LIMIT.

The problem is reported by Toby Slight and Brian Conway.
@
text
@d1 1
a1 1
/*	$OpenBSD: efiboot.c,v 1.3 2015/09/03 09:22:40 kettenis Exp $	*/
d48 1
a48 1
			  { 0x99, 0x20, 0x2d, 0x3b, 0x36, 0xd7, 0x50, 0xdf }};
d57 1
a57 1
    __attribute__ ((noreturn));
d76 2
a77 1
	status = EFI_CALL(BS->HandleProtocol, image, &imgdp_guid, (void **)&dp0);
d245 2
a246 1
	status = EFI_CALL(BS->GetMemoryMap, &siz, NULL, &mapkey, &mmsiz, &mmver);
d337 1
a337 1
        if (status == EFI_SUCCESS)
d339 7
a345 7
		    EfiConsoleControlScreenText);
        mode80x25 = -1;
        mode100x31 = -1;
        for (i = 0; ; i++) {
                status = EFI_CALL(conout->QueryMode, conout, i, &cols, &rows);
                if (EFI_ERROR(status))
                        break;
d347 1
a347 1
                        mode80x25 = i;
d349 1
a349 1
                        mode100x31 = i;
d354 1
a354 1
        }
d356 3
a358 3
                EFI_CALL(conout->SetMode, conout, mode100x31);
        else if (mode80x25 >= 0)
                EFI_CALL(conout->SetMode, conout, mode80x25);
@


1.3
log
@Improve the code that tries to figure out which device we booted from.  The
EFI Loaded Image Device Path Protocol typically includes partition and file
components.  We want to match it to a "raw" Device Path without these
components though, so we declare we have found the boot device as soon as
the Device Path matches the initial components of the Loaded Image Device Path.

ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: efiboot.c,v 1.2 2015/09/02 21:22:44 kettenis Exp $	*/
d45 1
a45 1
UINTN			 heapsiz = 3 * 1024 * 1024;
d202 1
a202 1
	heap = 0x1000000;	/* Below kernel base address */
@


1.2
log
@Use the pointer we got back from alloc() when calling free() instead of
something that points smack in the middle of the buffer.
@
text
@d1 1
a1 1
/*	$OpenBSD: efiboot.c,v 1.1 2015/09/02 01:52:25 yasuoka Exp $	*/
d136 1
a136 1
	EFI_DEVICE_PATH		*dp, *dp0;
d167 1
a167 1
		    (void **)&dp0);
d170 3
a172 4
		for (dp = dp0; !IsDevicePathEnd(dp);
		    dp = NextDevicePathNode(dp)) {
			if (!memcmp(efi_bootdp, dp, sizeof(EFI_DEVICE_PATH)) &&
			    !memcmp(efi_bootdp, dp, DevicePathNodeLength(dp))) {
d176 5
@


1.1
log
@Initial commit of uefi boot loader of OpenBSD.

ok deraadt yuo
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d303 1
a303 1
	free(mm, siz);
@

