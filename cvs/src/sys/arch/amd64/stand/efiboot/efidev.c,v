head	1.27;
access;
symbols
	OPENBSD_6_1:1.24.0.4
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.18.0.2
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16;
locks; strict;
comment	@ * @;


1.27
date	2017.07.21.01.21.42;	author yasuoka;	state Exp;
branches;
next	1.26;
commitid	KhnY4tzd0VFPT3wU;

1.26
date	2017.05.16.02.56.23;	author yasuoka;	state Exp;
branches;
next	1.25;
commitid	vwGIN7IYUH95H6A7;

1.25
date	2017.05.11.01.37.24;	author yasuoka;	state Exp;
branches;
next	1.24;
commitid	vBw1Wk0VoVGqLuHc;

1.24
date	2016.12.24.08.41.13;	author yasuoka;	state Exp;
branches;
next	1.23;
commitid	zy2GiT2H76H5WUOO;

1.23
date	2016.12.23.07.35.01;	author yasuoka;	state Exp;
branches;
next	1.22;
commitid	drmz6UoYXmct7Zc8;

1.22
date	2016.12.23.05.57.26;	author yasuoka;	state Exp;
branches;
next	1.21;
commitid	IM80PrkLiVVtO6PH;

1.21
date	2016.09.11.17.51.21;	author jsing;	state Exp;
branches;
next	1.20;
commitid	OdBRlx3Vvs2tfqrF;

1.20
date	2016.09.11.15.54.11;	author jsing;	state Exp;
branches;
next	1.19;
commitid	m28Q0aUDbVqwDb3p;

1.19
date	2016.08.31.15.11.22;	author yasuoka;	state Exp;
branches;
next	1.18;
commitid	EJKMsAOhEcnTDdLM;

1.18
date	2016.05.06.03.13.52;	author yasuoka;	state Exp;
branches;
next	1.17;
commitid	fINQ2EROKDrGrNbX;

1.17
date	2016.05.01.10.43.05;	author krw;	state Exp;
branches;
next	1.16;
commitid	GAnDd15WjDAu5S6H;

1.16
date	2016.01.06.02.10.03;	author krw;	state Exp;
branches;
next	1.15;
commitid	bcweyGqj5y1tQZB2;

1.15
date	2016.01.03.15.01.31;	author krw;	state Exp;
branches;
next	1.14;
commitid	jnU68qVCdkEPkrEw;

1.14
date	2015.12.24.21.37.25;	author krw;	state Exp;
branches;
next	1.13;
commitid	jh7DeCpl8rKHdKIm;

1.13
date	2015.12.24.18.03.02;	author krw;	state Exp;
branches;
next	1.12;
commitid	tbcDMNza3QRe7dws;

1.12
date	2015.12.24.14.12.43;	author krw;	state Exp;
branches;
next	1.11;
commitid	JZjkyyEjRydsyd3o;

1.11
date	2015.11.29.15.35.41;	author krw;	state Exp;
branches;
next	1.10;
commitid	Ytk1qjKSjQKS8H4a;

1.10
date	2015.11.28.22.53.38;	author krw;	state Exp;
branches;
next	1.9;
commitid	UdS0cx1iHjoAUCC9;

1.9
date	2015.11.28.13.50.11;	author yasuoka;	state Exp;
branches;
next	1.8;
commitid	UDVKNgDA8dlFTSAL;

1.8
date	2015.11.09.01.07.56;	author krw;	state Exp;
branches;
next	1.7;
commitid	I5KlwSyXDeb6zM5S;

1.7
date	2015.11.08.00.42.39;	author yasuoka;	state Exp;
branches;
next	1.6;
commitid	4ochEksphbgq4px9;

1.6
date	2015.10.01.20.28.12;	author krw;	state Exp;
branches;
next	1.5;
commitid	clda1fEydcUmLYPS;

1.5
date	2015.09.12.21.55.14;	author yasuoka;	state Exp;
branches;
next	1.4;
commitid	GuRXTf62hEL2KSDl;

1.4
date	2015.09.07.05.10.52;	author yasuoka;	state Exp;
branches;
next	1.3;
commitid	iR2ggwsfXsD40rBu;

1.3
date	2015.09.06.09.35.59;	author yasuoka;	state Exp;
branches;
next	1.2;
commitid	bAUSjQyCbqNPOtMX;

1.2
date	2015.09.02.08.24.29;	author yasuoka;	state Exp;
branches;
next	1.1;
commitid	5tg3reGyYxgphkKg;

1.1
date	2015.09.02.01.52.25;	author yasuoka;	state Exp;
branches;
next	;
commitid	CUwlbzT4LejFC15d;


desc
@@


1.27
log
@Check the hibernation signature for softraid disks and select valid bsd
for unhibernation.  reported by Natasha Kerensikova.  tested by Theo Buehler.

ok deraadt
@
text
@/*	$OpenBSD: efidev.c,v 1.26 2017/05/16 02:56:23 yasuoka Exp $	*/

/*
 * Copyright (c) 1996 Michael Shalayeff
 * Copyright (c) 2003 Tobias Weingartner
 * Copyright (c) 2015 YASUOKA Masahiko <yasuoka@@yasuoka.net>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */
#include <sys/param.h>
#include <sys/reboot.h>
#include <sys/disklabel.h>
#include <lib/libz/zlib.h>
#include <isofs/cd9660/iso.h>

#include "libsa.h"
#include "disk.h"

#ifdef SOFTRAID
#include <dev/softraidvar.h>
#include <lib/libsa/softraid.h>
#include "softraid_amd64.h"
#endif

#include <efi.h>
#include "eficall.h"

extern int debug;

#include "efidev.h"
#include "biosdev.h"	/* for dklookup() */

#define EFI_BLKSPERSEC(_ed)	((_ed)->blkio->Media->BlockSize / DEV_BSIZE)
#define EFI_SECTOBLK(_ed, _n)	((_n) * EFI_BLKSPERSEC(_ed))

struct efi_diskinfo {
	EFI_BLOCK_IO		*blkio;
	UINT32			 mediaid;
};

int bios_bootdev;
static EFI_STATUS
		 efid_io(int, efi_diskinfo_t, u_int, int, void *);
static int	 efid_diskio(int, struct diskinfo *, u_int, int, void *);
static int	 efi_getdisklabel_cd9660(efi_diskinfo_t, struct disklabel *);
static u_int	 findopenbsd(efi_diskinfo_t, const char **);
static u_int	 findopenbsd_gpt(efi_diskinfo_t, const char **);
static int	 gpt_chk_mbr(struct dos_partition *, u_int64_t);

void
efid_init(struct diskinfo *dip, void *handle)
{
	EFI_BLOCK_IO		*blkio = handle;

	memset(dip, 0, sizeof(struct diskinfo));
	dip->efi_info = alloc(sizeof(struct efi_diskinfo));
	dip->efi_info->blkio = blkio;
	dip->efi_info->mediaid = blkio->Media->MediaId;
	dip->diskio = efid_diskio;
	dip->strategy = efistrategy;
}

static EFI_STATUS
efid_io(int rw, efi_diskinfo_t ed, u_int off, int nsect, void *buf)
{
	u_int		 blks, lba, i_lblks, i_tblks, i_nblks;
	EFI_STATUS	 status = EFI_SUCCESS;
	static u_char	*iblk = NULL;
	static u_int	 iblksz = 0;

	/* block count of the intrisic block size in DEV_BSIZE */
	blks = EFI_BLKSPERSEC(ed);
	if (blks == 0)
		/* block size < 512.  HP Stream 13 actually has such a disk. */
		return (EFI_UNSUPPORTED);

	/* leading and trailing unaligned blocks in intrisic block */
	i_lblks = ((off % blks) == 0)? 0 : blks - (off % blks);
	i_tblks = (nsect > i_lblks)? (off + nsect) % blks : 0;

	/* aligned blocks in intrisic block */
	i_nblks = (nsect > i_lblks + i_tblks)? nsect - (i_lblks + i_tblks) : 0;

	lba = (off + i_lblks) / blks;

	switch (rw) {
	case F_READ:
		/* allocate the space for reading unaligned blocks */
		if (ed->blkio->Media->BlockSize != DEV_BSIZE) {
			if (iblk && iblksz < ed->blkio->Media->BlockSize) {
				free(iblk, iblksz);
				iblk = NULL;
			}
			if (iblk == NULL) {
				iblk = alloc(ed->blkio->Media->BlockSize);
				iblksz = ed->blkio->Media->BlockSize;
			}
		}
		if (i_lblks > 0) {
			status = EFI_CALL(ed->blkio->ReadBlocks,
			    ed->blkio, ed->mediaid, lba - 1,
			    ed->blkio->Media->BlockSize, iblk);
			if (EFI_ERROR(status))
				goto on_eio;
			memcpy(buf, iblk + (blks - i_lblks) * DEV_BSIZE,
			    min(nsect, i_lblks) * DEV_BSIZE);
		}
		if (i_nblks > 0) {
			status = EFI_CALL(ed->blkio->ReadBlocks,
			    ed->blkio, ed->mediaid, lba,
			    ed->blkio->Media->BlockSize * (i_nblks / blks),
			    buf + (i_lblks * DEV_BSIZE));
			if (EFI_ERROR(status))
				goto on_eio;
		}
		if (i_tblks > 0) {
			status = EFI_CALL(ed->blkio->ReadBlocks,
			    ed->blkio, ed->mediaid, lba + (i_nblks / blks),
			    ed->blkio->Media->BlockSize, iblk);
			if (EFI_ERROR(status))
				goto on_eio;
			memcpy(buf + (i_lblks + i_nblks) * DEV_BSIZE, iblk,
			    i_tblks * DEV_BSIZE);
		}
		break;
	case F_WRITE:
		if (ed->blkio->Media->ReadOnly)
			goto on_eio;
		/* XXX not yet */
		goto on_eio;
		break;
	}
	return (EFI_SUCCESS);

on_eio:
	return (status);
}

static int
efid_diskio(int rw, struct diskinfo *dip, u_int off, int nsect, void *buf)
{
	EFI_STATUS status;

	status = efid_io(rw, dip->efi_info, off, nsect, buf);

	return ((EFI_ERROR(status))? -1 : 0);
}

/*
 * Returns 0 if the MBR with the provided partition array is a GPT protective
 * MBR, and returns 1 otherwise. A GPT protective MBR would have one and only
 * one MBR partition, an EFI partition that either covers the whole disk or as
 * much of it as is possible with a 32bit size field.
 *
 * Taken from kern/subr_disk.c.
 *
 * NOTE: MS always uses a size of UINT32_MAX for the EFI partition!**
 */
static int
gpt_chk_mbr(struct dos_partition *dp, u_int64_t dsize)
{
	struct dos_partition *dp2;
	int efi, found, i;
	u_int32_t psize;

	found = efi = 0;
	for (dp2=dp, i=0; i < NDOSPART; i++, dp2++) {
		if (dp2->dp_typ == DOSPTYP_UNUSED)
			continue;
		found++;
		if (dp2->dp_typ != DOSPTYP_EFI)
			continue;
		psize = letoh32(dp2->dp_size);
		if (psize == (dsize - 1) ||
		    psize == UINT32_MAX) {
			if (letoh32(dp2->dp_start) == 1)
				efi++;
		}
	}
	if (found == 1 && efi == 1)
		return (0);

	return (1);
}

/*
 * Try to find the disk address of the first MBR OpenBSD partition.
 *
 * N.B.: must boot from a partition within first 2^32-1 sectors!
 *
 * Called only if the MBR on sector 0 is *not* a protective MBR
 * and *does* have a valid signature.
 *
 * We don't check the signatures of EBR's, and they cannot be
 * protective MBR's so there is no need to check for that.
 */
static u_int
findopenbsd(efi_diskinfo_t ed, const char **err)
{
	EFI_STATUS status;
	struct dos_mbr mbr;
	struct dos_partition *dp;
	u_int mbroff = DOSBBSECTOR;
	u_int mbr_eoff = DOSBBSECTOR;	/* Offset of MBR extended partition. */
	int i, maxebr = DOS_MAXEBR, nextebr;

again:
	if (!maxebr--) {
		*err = "too many extended partitions";
		return (-1);
	}

	/* Read MBR */
	bzero(&mbr, sizeof(mbr));
	status = efid_io(F_READ, ed, mbroff, 1, &mbr);
	if (EFI_ERROR(status)) {
		*err = "Disk I/O Error";
		return (-1);
	}

	/* Search for OpenBSD partition */
	nextebr = 0;
	for (i = 0; i < NDOSPART; i++) {
		dp = &mbr.dmbr_parts[i];
		if (!dp->dp_size)
			continue;
#ifdef BIOS_DEBUG
		if (debug)
			printf("found partition %u: "
			    "type %u (0x%x) offset %u (0x%x)\n",
			    (int)(dp - mbr.dmbr_parts),
			    dp->dp_typ, dp->dp_typ,
			    dp->dp_start, dp->dp_start);
#endif
		if (dp->dp_typ == DOSPTYP_OPENBSD) {
			if (dp->dp_start > (dp->dp_start + mbroff))
				continue;
			return (dp->dp_start + mbroff);
		}

		/*
		 * Record location of next ebr if and only if this is the first
		 * extended partition in this boot record!
		 */
		if (!nextebr && (dp->dp_typ == DOSPTYP_EXTEND ||
		    dp->dp_typ == DOSPTYP_EXTENDL)) {
			nextebr = dp->dp_start + mbr_eoff;
			if (nextebr < dp->dp_start)
				nextebr = (u_int)-1;
			if (mbr_eoff == DOSBBSECTOR)
				mbr_eoff = dp->dp_start;
		}
	}

	if (nextebr && nextebr != (u_int)-1) {
		mbroff = nextebr;
		goto again;
	}

	return (-1);
}

/*
 * Try to find the disk address of the first GPT OpenBSD partition.
 *
 * N.B.: must boot from a partition within first 2^32-1 sectors!
 *
 * Called only if the MBR on sector 0 *is* a protective MBR
 * with a valid signature and sector 1 is a valid GPT header.
 */
static u_int
findopenbsd_gpt(efi_diskinfo_t ed, const char **err)
{
	EFI_STATUS		 status;
	struct			 gpt_header gh;
	int			 i, part, found;
	uint64_t		 lba;
	uint32_t		 orig_csum, new_csum;
	uint32_t		 ghsize, ghpartsize, ghpartnum, ghpartspersec;
	uint32_t		 gpsectors;
	const char		 openbsd_uuid_code[] = GPT_UUID_OPENBSD;
	struct gpt_partition	 gp;
	static struct uuid	*openbsd_uuid = NULL, openbsd_uuid_space;
	static u_char		 buf[4096];

	/* Prepare OpenBSD UUID */
	if (openbsd_uuid == NULL) {
		/* XXX: should be replaced by uuid_dec_be() */
		memcpy(&openbsd_uuid_space, openbsd_uuid_code,
		    sizeof(openbsd_uuid_space));
		openbsd_uuid_space.time_low =
		    betoh32(openbsd_uuid_space.time_low);
		openbsd_uuid_space.time_mid =
		    betoh16(openbsd_uuid_space.time_mid);
		openbsd_uuid_space.time_hi_and_version =
		    betoh16(openbsd_uuid_space.time_hi_and_version);

		openbsd_uuid = &openbsd_uuid_space;
	}

	if (EFI_BLKSPERSEC(ed) > 8) {
		*err = "disk sector > 4096 bytes\n";
		return (-1);
	}

	/* LBA1: GPT Header */
	lba = 1;
	status = efid_io(F_READ, ed, EFI_SECTOBLK(ed, lba), EFI_BLKSPERSEC(ed),
	    buf);
	if (EFI_ERROR(status)) {
		*err = "Disk I/O Error";
		return (-1);
	}
	memcpy(&gh, buf, sizeof(gh));

	/* Check signature */
	if (letoh64(gh.gh_sig) != GPTSIGNATURE) {
		*err = "bad GPT signature\n";
		return (-1);
	}

	if (letoh32(gh.gh_rev) != GPTREVISION) {
		*err = "bad GPT revision\n";
		return (-1);
	}

	ghsize = letoh32(gh.gh_size);
	if (ghsize < GPTMINHDRSIZE || ghsize > sizeof(struct gpt_header)) {
		*err = "bad GPT header size\n";
		return (-1);
	}

	/* Check checksum */
	orig_csum = gh.gh_csum;
	gh.gh_csum = 0;
	new_csum = crc32(0, (unsigned char *)&gh, ghsize);
	gh.gh_csum = orig_csum;
	if (letoh32(orig_csum) != new_csum) {
		*err = "bad GPT header checksum\n";
		return (-1);
	}

	lba = letoh64(gh.gh_part_lba);
	ghpartsize = letoh32(gh.gh_part_size);
	ghpartspersec = ed->blkio->Media->BlockSize / ghpartsize;
	ghpartnum = letoh32(gh.gh_part_num);
	gpsectors = (ghpartnum + ghpartspersec - 1) / ghpartspersec;
	new_csum = crc32(0L, Z_NULL, 0);
	found = 0;
	for (i = 0; i < gpsectors; i++, lba++) {
		status = efid_io(F_READ, ed, EFI_SECTOBLK(ed, lba),
		    EFI_BLKSPERSEC(ed), buf);
		if (EFI_ERROR(status)) {
			*err = "Disk I/O Error";
			return (-1);
		}
		for (part = 0; part < ghpartspersec; part++) {
			if (ghpartnum == 0)
				break;
			new_csum = crc32(new_csum, buf + part * sizeof(gp),
			    sizeof(gp));
			ghpartnum--;
			if (found)
				continue;
			memcpy(&gp, buf + part * sizeof(gp), sizeof(gp));
			if (memcmp(&gp.gp_type, openbsd_uuid,
			    sizeof(struct uuid)) == 0)
				found = 1;
		}
	}
	if (new_csum != letoh32(gh.gh_part_csum)) {
		*err = "bad GPT entries checksum\n";
		return (-1);
	}
	if (found) {
		lba = letoh64(gp.gp_lba_start);
		/* Bootloaders do not current handle addresses > UINT_MAX! */
		if (lba > UINT_MAX || EFI_SECTOBLK(ed, lba) > UINT_MAX) {
			*err = "OpenBSD Partition LBA > 2**32 - 1";
			return (-1);
		}
		return (u_int)lba;
	}

	return (-1);
}

const char *
efi_getdisklabel(efi_diskinfo_t ed, struct disklabel *label)
{
	u_int start = 0;
	uint8_t buf[DEV_BSIZE];
	struct dos_partition dosparts[NDOSPART];
	EFI_STATUS status;
	const char *err = NULL;
	int error;

	/*
	 * Read sector 0. Ensure it has a valid MBR signature.
	 *
	 * If it's a protective MBR then try to find the disklabel via
	 * GPT. If it's not a protective MBR, try to find the disklabel
	 * via MBR.
	 */
	memset(buf, 0, sizeof(buf));
	status = efid_io(F_READ, ed, DOSBBSECTOR, 1, buf);
	if (EFI_ERROR(status))
		return ("Disk I/O Error");

	/* Check MBR signature. */
	if (buf[510] != 0x55 || buf[511] != 0xaa) {
		if (efi_getdisklabel_cd9660(ed, label) == 0)
			return (NULL);
		return ("invalid MBR signature");
	}

	memcpy(dosparts, buf+DOSPARTOFF, sizeof(dosparts));

	/* check for GPT protective MBR. */
	if (gpt_chk_mbr(dosparts, ed->blkio->Media->LastBlock + 1) == 0) {
		start = findopenbsd_gpt(ed, &err);
		if (start == (u_int)-1) {
			if (err != NULL)
				return (err);
			return ("no OpenBSD GPT partition");
		}
	} else {
		start = findopenbsd(ed, &err);
		if (start == (u_int)-1) {
			if (err != NULL)
				return (err);
			return "no OpenBSD MBR partition\n";
		}
	}

	/* Load BSD disklabel */
#ifdef BIOS_DEBUG
	if (debug)
		printf("loading disklabel @@ %u\n", start + DOS_LABELSECTOR);
#endif
	/* read disklabel */
	error = efid_io(F_READ, ed, EFI_SECTOBLK(ed, start) + DOS_LABELSECTOR,
	    1, buf);

	if (error)
		return "failed to read disklabel";

	/* Fill in disklabel */
	return (getdisklabel(buf, label));
}

static int
efi_getdisklabel_cd9660(efi_diskinfo_t ed, struct disklabel *label)
{
	int		 off;
	uint8_t		 buf[DEV_BSIZE];
	EFI_STATUS	 status;

	for (off = 0; off < 100; off++) {
		status = efid_io(F_READ, ed,
		    EFI_BLKSPERSEC(ed) * (16 + off), 1, buf);
		if (EFI_ERROR(status))
			return (-1);
		if (bcmp(buf + 1, ISO_STANDARD_ID, 5) != 0 ||
		    buf[0] == ISO_VD_END)
			return (-1);
		if (buf[0] == ISO_VD_PRIMARY)
			break;
	}
	if (off >= 100)
		return (-1);

	/* Create an imaginary disk label */
	label->d_secsize = 2048;
	label->d_ntracks = 1;
	label->d_nsectors = 100;
	label->d_ncylinders = 1;
	label->d_secpercyl = label->d_ntracks * label->d_nsectors;
	if (label->d_secpercyl == 0) {
		label->d_secpercyl = 100;
		/* as long as it's not 0, since readdisklabel divides by it */
	}

	strncpy(label->d_typename, "ATAPI CD-ROM", sizeof(label->d_typename));
	label->d_type = DTYPE_ATAPI;

	strncpy(label->d_packname, "fictitious", sizeof(label->d_packname));
	DL_SETDSIZE(label, 100);

	label->d_bbsize = 2048;
	label->d_sbsize = 2048;

	/* 'a' partition covering the "whole" disk */
	DL_SETPOFFSET(&label->d_partitions[0], 0);
	DL_SETPSIZE(&label->d_partitions[0], 100);
	label->d_partitions[0].p_fstype = FS_UNUSED;

	/* The raw partition is special */
	DL_SETPOFFSET(&label->d_partitions[RAW_PART], 0);
	DL_SETPSIZE(&label->d_partitions[RAW_PART], 100);
	label->d_partitions[RAW_PART].p_fstype = FS_UNUSED;

	label->d_npartitions = MAXPARTITIONS;

	label->d_magic = DISKMAGIC;
	label->d_magic2 = DISKMAGIC;
	label->d_checksum = dkcksum(label);

	return (0);
}

int
efiopen(struct open_file *f, ...)
{
#ifdef SOFTRAID
	struct sr_boot_volume *bv;
#endif
	register char *cp, **file;
	dev_t maj, unit, part;
	struct diskinfo *dip;
	int biosdev, devlen;
#if 0
	const char *st;
#endif
	va_list ap;
	char *dev;

	va_start(ap, f);
	cp = *(file = va_arg(ap, char **));
	va_end(ap);

#ifdef EFI_DEBUG
	if (debug)
		printf("%s\n", cp);
#endif

	f->f_devdata = NULL;

	/* Search for device specification. */
	dev = cp;
	if (cp[4] == ':')
		devlen = 2;
	else if (cp[5] == ':')
		devlen = 3;
	else
		return ENOENT;
	cp += devlen;

	/* Get unit. */
	if ('0' <= *cp && *cp <= '9')
		unit = *cp++ - '0';
	else {
		printf("Bad unit number\n");
		return EUNIT;
	}

	/* Get partition. */
	if ('a' <= *cp && *cp <= 'p')
		part = *cp++ - 'a';
	else {
		printf("Bad partition\n");
		return EPART;
	}

	/* Get filename. */
	cp++;	/* skip ':' */
	if (*cp != 0)
		*file = cp;
	else
		f->f_flags |= F_RAW;

#ifdef SOFTRAID
	/* Intercept softraid disks. */
	if (strncmp("sr", dev, 2) == 0) {

		/* Create a fake diskinfo for this softraid volume. */
		SLIST_FOREACH(bv, &sr_volumes, sbv_link)
			if (bv->sbv_unit == unit)
				break;
		if (bv == NULL) {
			printf("Unknown device: sr%d\n", unit);
			return EADAPT;
		}

		if (bv->sbv_level == 'C' && bv->sbv_keys == NULL)
			if (sr_crypto_decrypt_keys(bv) != 0)
				return EPERM;

		if (bv->sbv_diskinfo == NULL) {
			dip = alloc(sizeof(struct diskinfo));
			bzero(dip, sizeof(*dip));
			dip->diskio = efid_diskio;
			dip->strategy = efistrategy;
			bv->sbv_diskinfo = dip;
			dip->sr_vol = bv;
			dip->bios_info.flags |= BDI_BADLABEL;
		}

		dip = bv->sbv_diskinfo;

		if (dip->bios_info.flags & BDI_BADLABEL) {
			/* Attempt to read disklabel. */
			bv->sbv_part = 'c';
			if (sr_getdisklabel(bv, &dip->disklabel))
				return ERDLAB;
			dip->bios_info.flags &= ~BDI_BADLABEL;
			check_hibernate(dip);
		}

		bv->sbv_part = part + 'a';

		bootdev_dip = dip;
		f->f_devdata = dip;

		return 0;
	}
#endif
	for (maj = 0; maj < nbdevs &&
	    strncmp(dev, bdevs[maj], devlen); maj++);
	if (maj >= nbdevs) {
		printf("Unknown device: ");
		for (cp = *file; *cp != ':'; cp++)
			putchar(*cp);
		putchar('\n');
		return EADAPT;
	}

	biosdev = unit;
	switch (maj) {
	case 0:  /* wd */
	case 4:  /* sd */
	case 17: /* hd */
		biosdev |= 0x80;
		break;
	case 2:  /* fd */
		break;
	case 6:  /* cd */
		biosdev = bios_bootdev & 0xff;
		break;
	default:
		return ENXIO;
	}

	/* Find device */
	dip = dklookup(biosdev);
	if (dip == NULL)
		return ENXIO;
	bootdev_dip = dip;

	/* Fix up bootdev */
	{ dev_t bsd_dev;
		bsd_dev = dip->bios_info.bsd_dev;
		dip->bsddev = MAKEBOOTDEV(B_TYPE(bsd_dev), B_ADAPTOR(bsd_dev),
		    B_CONTROLLER(bsd_dev), unit, part);
		dip->bootdev = MAKEBOOTDEV(B_TYPE(bsd_dev), B_ADAPTOR(bsd_dev),
		    B_CONTROLLER(bsd_dev), B_UNIT(bsd_dev), part);
	}

#if 0
	dip->bios_info.bsd_dev = dip->bootdev;
	bootdev = dip->bootdev;
#endif

#ifdef EFI_DEBUG
	if (debug) {
		printf("BIOS geometry: heads=%u, s/t=%u; EDD=%d\n",
		    dip->bios_info.bios_heads, dip->bios_info.bios_sectors,
		    dip->bios_info.bios_edd);
	}
#endif

#if 0
/*
 * XXX In UEFI, media change can be detected by MediaID
 */
	/* Try for disklabel again (might be removable media) */
	if (dip->bios_info.flags & BDI_BADLABEL) {
		st = efi_getdisklabel(dip->efi_info, &dip->disklabel);
#ifdef EFI_DEBUG
		if (debug && st)
			printf("%s\n", st);
#endif
		if (!st) {
			dip->bios_info.flags &= ~BDI_BADLABEL;
			dip->bios_info.flags |= BDI_GOODLABEL;
		} else
			return ERDLAB;
	}
#endif
	f->f_devdata = dip;

	return 0;
}

int
efistrategy(void *devdata, int rw, daddr32_t blk, size_t size, void *buf,
    size_t *rsize)
{
	struct diskinfo *dip = (struct diskinfo *)devdata;
	u_int8_t error = 0;
	size_t nsect;

#ifdef SOFTRAID
	/* Intercept strategy for softraid volumes. */
	if (dip->sr_vol)
		return sr_strategy(dip->sr_vol, rw, blk, size, buf, rsize);
#endif
	nsect = (size + DEV_BSIZE - 1) / DEV_BSIZE;
	blk += DL_SECTOBLK(&dip->disklabel,
	    dip->disklabel.d_partitions[B_PARTITION(dip->bsddev)].p_offset);

	if (blk < 0)
		error = EINVAL;
	else
		error = dip->diskio(rw, dip, blk, nsect, buf);

#ifdef EFI_DEBUG
	if (debug) {
		if (error != 0)
			printf("=0x%x(%s)", error, error);
		putchar('\n');
	}
#endif
	if (rsize != NULL)
		*rsize = nsect * DEV_BSIZE;

	return (error);
}

int
eficlose(struct open_file *f)
{
	f->f_devdata = NULL;

	return 0;
}

int
efiioctl(struct open_file *f, u_long cmd, void *data)
{

	return 0;
}

void
efi_dump_diskinfo(void)
{
	efi_diskinfo_t	 ed;
	struct diskinfo	*dip;
	bios_diskinfo_t *bdi;
	uint64_t	 siz;
	const char	*sizu;

	printf("Disk\tBlkSiz\tIoAlign\tSize\tFlags\tChecksum\n");
	TAILQ_FOREACH(dip, &disklist, list) {
		bdi = &dip->bios_info;
		ed = dip->efi_info;

		siz = (ed->blkio->Media->LastBlock + 1) *
		    ed->blkio->Media->BlockSize;
		siz /= 1024 * 1024;
		if (siz < 10000)
			sizu = "MB";
		else {
			siz /= 1024;
			sizu = "GB";
		}

		printf("hd%d\t%u\t%u\t%u%s\t0x%x\t0x%x\t%s\n",
		    (bdi->bios_number & 0x7f),
		    ed->blkio->Media->BlockSize,
		    ed->blkio->Media->IoAlign, (unsigned)siz, sizu,
		    bdi->flags, bdi->checksum,
		    (ed->blkio->Media->RemovableMedia)? "Removable" : "");
	}
}
@


1.26
log
@Tweak previous, s/int/unsigned/, since the format character is %u.
@
text
@d1 1
a1 1
/*	$OpenBSD: efidev.c,v 1.25 2017/05/11 01:37:24 yasuoka Exp $	*/
d628 1
@


1.25
log
@Casting int is required for passing uint64 value to "%u" since we don't
assume the size of int.  The problem was spotted by Michele Curti.
@
text
@d1 1
a1 1
/*	$OpenBSD: efidev.c,v 1.24 2016/12/24 08:41:13 yasuoka Exp $	*/
d792 1
a792 1
		    ed->blkio->Media->IoAlign, (int)siz, sizu,
@


1.24
log
@The unit of the parition offset in disklabel is number of sectors in the
sector size, not in 512 byte blocks.  tested by gonzalo.
@
text
@d1 1
a1 1
/*	$OpenBSD: efidev.c,v 1.23 2016/12/23 07:35:01 yasuoka Exp $	*/
d792 1
a792 1
		    ed->blkio->Media->IoAlign, siz, sizu,
@


1.23
log
@Convert the sector number in the patition table to the sector number
in 512 byte blocks.  This fixes efiboot to read disklabel on 4K sector
size disk properly.  tested by gonzalo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: efidev.c,v 1.22 2016/12/23 05:57:26 yasuoka Exp $	*/
d729 2
a730 1
	blk += dip->disklabel.d_partitions[B_PARTITION(dip->bsddev)].p_offset;
@


1.22
log
@The efi disk i/o to read sectors properly when the sector size is not
512.  The problem actually had happened on macbookair7,1.  reported
and tested by gonzalo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: efidev.c,v 1.21 2016/09/11 17:51:21 jsing Exp $	*/
d463 2
a464 1
	error = efid_io(F_READ, ed, start + DOS_LABELSECTOR, 1, buf);
@


1.21
log
@Switch amd64 to libsa MI softraid.
@
text
@d1 1
a1 1
/*	$OpenBSD: efidev.c,v 1.20 2016/09/11 15:54:11 jsing Exp $	*/
a96 1
	lba = off / blks;
d100 1
a100 1
	i_tblks = (off + nsect) % blks;
d103 3
a105 1
	i_nblks = nsect - (i_lblks + i_tblks);
d126 2
a127 2
			memcpy(buf, iblk + (blks - i_lblks),
			    i_lblks * DEV_BSIZE);
@


1.20
log
@Rename softraid boot files, which are currently in an MD location. This
will allow us to bring in a MI softraid.{c,h} in lib/libsa.
@
text
@d1 1
a1 1
/*	$OpenBSD: efidev.c,v 1.19 2016/08/31 15:11:22 yasuoka Exp $	*/
d42 1
@


1.19
log
@Enable cd9660 in efiboot.
@
text
@d1 1
a1 1
/*	$OpenBSD: efidev.c,v 1.18 2016/05/06 03:13:52 yasuoka Exp $	*/
d42 1
a42 1
#include "softraid.h"
@


1.18
log
@Fix efiboot not to hang with a disk whose block size < 512.

Report and diff from Vegar Linge Haaland
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: efidev.c,v 1.17 2016/05/01 10:43:05 krw Exp $	*/
d35 1
d65 1
d430 3
a432 1
	if (buf[510] != 0x55 || buf[511] != 0xaa)
d434 1
d468 60
@


1.17
log
@Shuffle gpt/mbr code around a bit to make it more like other searches
for the disklabel. Tweak a few comments to make it more clear what
is happening. No intentional functional change.

ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: efidev.c,v 1.16 2016/01/06 02:10:03 krw Exp $	*/
d91 3
@


1.16
log
@Bring efidev.c goodness into softraid.c by returning and displaying
the same error messages on GPT processing failures.

Add a message about failed GPT entry checksum error to both. This
was inadvertantly deleted in the switch to one entry at a time
processing.

tweaks & ok yasuoka@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: efidev.c,v 1.15 2016/01/03 15:01:31 krw Exp $	*/
d65 1
a65 1
static uint64_t	 findopenbsd_gpt(efi_diskinfo_t, const char **);
d201 9
a209 1
 * Try to read the bsd label on the given BIOS device.
a216 1
	uint64_t gptoff;
a234 19
	/* check mbr signature */
	if (mbr.dmbr_sign != DOSMBR_SIGNATURE) {
		*err = "bad MBR signature\n";
		return (-1);
	}

	/* check for GPT protective MBR. */
	if (mbroff == DOSBBSECTOR && gpt_chk_mbr(mbr.dmbr_parts,
	    ed->blkio->Media->LastBlock + 1) == 0) {
		gptoff = findopenbsd_gpt(ed, err);
		if (gptoff > UINT_MAX || EFI_SECTOBLK(ed, gptoff) > UINT_MAX) {
			*err = "Paritition LBA > 2**32";
			return (-1);
		}
		if (gptoff == -1)
			return (-1);
		return EFI_SECTOBLK(ed, gptoff);
	}

d277 9
a285 2
/* call this only if LBA1 == GPT */
static uint64_t
d389 9
a397 2
	if (found)
		return (letoh64(gp.gp_lba_start));
d406 3
a408 1
	char buf[DEV_BSIZE];
d412 17
a428 2
	/* Sanity check */
	/* XXX */
d430 15
a444 5
	start = findopenbsd(ed, &err);
	if (start == (u_int)-1) {
		if (err != NULL)
			return (err);
		return "no OpenBSD partition\n";
@


1.15
log
@Don't need two 16K static buffers to checksum the GPT entries and find the
OpenBSD partition. Just one 128-byte stack copy of a single entry.

Problems with EFI installs involving many disks reported by and fix
tested by Thomas Bohl.

Stefan Kempf pointed finger of suspicion at the addition of the 2nd
16K static buffer for softraid GPT and suggested/reviewed several
versions of the diff.

Tweaked and ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: efidev.c,v 1.14 2015/12/24 21:37:25 krw Exp $	*/
d390 6
a395 2
	if (found && new_csum == letoh32(gh.gh_part_csum))
		return letoh64(gp.gp_lba_start);
@


1.14
log
@If the GPT header checksum check fails, do *not* say the OpenBSD partition
starts at sector 1. Instead return -1, as for all other failures during
the header check.
@
text
@d1 1
a1 1
/*	$OpenBSD: efidev.c,v 1.13 2015/12/24 18:03:02 krw Exp $	*/
d295 1
a295 1
	int			 i, part;
d299 1
d301 1
a302 2
	static struct gpt_partition
				 gp[NGPTPARTITIONS];
d366 4
a369 2
	for (i = 0; i < (ghpartnum + ghpartspersec - 1) / ghpartspersec;
	    i++, lba++) {
d376 13
a388 13
		memcpy(gp + i * ghpartspersec, buf,
		    ghpartspersec * sizeof(struct gpt_partition));
	}
	new_csum = crc32(0, (unsigned char *)&gp, ghpartnum * ghpartsize);
	if (new_csum != letoh32(gh.gh_part_csum)) {
		*err = "bad GPT partitions checksum\n";
		return (-1);
	}

	for (part = 0; part < ghpartnum; part++) {
		if (memcmp(&gp[part].gp_type, openbsd_uuid,
		    sizeof(struct uuid)) == 0)
			return letoh64(gp[part].gp_lba_start);
d390 2
@


1.13
log
@Make all instances of gpt_chk_mbr() identical (bar static vs
non-static) by passing disk size as 2nd parameter instead of the
different structures holding the disk size info. The fifth copy of
gpt_chk_mbr() in fdisk is a little specialer. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: efidev.c,v 1.12 2015/12/24 14:12:43 krw Exp $	*/
d359 1
a359 1
		return (1);
@


1.12
log
@Add prototype for gpt_chk_mbr() to i386_installboot.c. Add 'static' to
declarations of gpt_chk_mbr() to match prototypes in efidev.c and
softraid.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: efidev.c,v 1.11 2015/11/29 15:35:41 krw Exp $	*/
d66 1
a66 1
static int	 gpt_chk_mbr(struct dos_partition *, efi_diskinfo_t);
d174 1
a174 1
gpt_chk_mbr(struct dos_partition *dp, efi_diskinfo_t ed)
a176 1
	EFI_LBA dsize;
a186 1
		dsize = ed->blkio->Media->LastBlock + 1;
d235 2
a236 1
	if (mbroff == DOSBBSECTOR && gpt_chk_mbr(mbr.dmbr_parts, ed) == 0) {
@


1.11
log
@Disk size in blocks is LastBlock+1. Fix whitespace nit.

ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: efidev.c,v 1.10 2015/11/28 22:53:38 krw Exp $	*/
d173 1
a173 1
int
@


1.10
log
@Use the same function as kern/subr_disk.c and fdisk/mbr.c to check
for a GPT protective MBR. Better than mangling findopenbsd() to do
the check.

Tested & ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: efidev.c,v 1.9 2015/11/28 13:50:11 yasuoka Exp $	*/
d671 2
a672 1
		siz = ed->blkio->Media->LastBlock * ed->blkio->Media->BlockSize;
d680 1
a680 1
		
@


1.9
log
@Check the protective MBR stricter not to choose a broken GPT.

test and ok gonzalo
@
text
@d1 1
a1 1
/*	$OpenBSD: efidev.c,v 1.8 2015/11/09 01:07:56 krw Exp $	*/
d66 1
d164 39
d211 1
d214 1
a214 1
	int i, maxebr = DOS_MAXEBR, nextebr, gpt = 0, npart = 0;
d236 12
d252 1
a252 1
		if (!dp->dp_size || dp->dp_typ == DOSPTYP_UNUSED)
a253 1
		npart++;
a279 3

		if (dp->dp_typ == DOSPTYP_EFI)
			gpt++;
a284 10
	}
	if (gpt == 1 && npart == 1) {
		uint64_t gptoff = findopenbsd_gpt(ed, err);
		if (gptoff > UINT_MAX || EFI_SECTOBLK(ed, gptoff) > UINT_MAX) {
			*err = "Paritition LBA > 2**32";
			return (-1);
		}
		if (gptoff == -1)
			return (-1);
		return EFI_SECTOBLK(ed, gptoff);
@


1.8
log
@Bring GPT validity checking into line with kern/subr_disk.c . In
particular don't attempt to calcuate the header checksum using a
size that will cause a crash.

Tested & ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: efidev.c,v 1.7 2015/11/08 00:42:39 yasuoka Exp $	*/
d173 1
a173 1
	int i, maxebr = DOS_MAXEBR, nextebr;
d199 1
a199 1
		if (!dp->dp_size)
d201 1
d229 2
a230 9
		if (dp->dp_typ == DOSPTYP_EFI) {
			uint64_t gptoff = findopenbsd_gpt(ed, err);
			if (gptoff > UINT_MAX ||
			    EFI_SECTOBLK(ed, gptoff) > UINT_MAX) {
				*err = "Paritition LBA > 2**32";
				return (-1);
			}
			return EFI_SECTOBLK(ed, gptoff);
		}
d236 10
@


1.7
log
@Make "machine disk" show some info for EFI instead of info for BIOS.
@
text
@d1 1
a1 1
/*	$OpenBSD: efidev.c,v 1.6 2015/10/01 20:28:12 krw Exp $	*/
d256 1
a256 1
	uint32_t		 ghpartsize, ghpartnum, ghpartspersec;
d299 11
d313 1
a313 1
	new_csum = crc32(0, (unsigned char *)&gh, letoh32(gh.gh_size));
@


1.6
log
@Use DOS_LABELSECTOR rather than LABELSECTOR to indicate offset into an
OpenBSD partition when accessing the disklabel. For these files both
are '1', but this makes the usage consistent across all archs.

ok guenther@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: efidev.c,v 1.5 2015/09/12 21:55:14 yasuoka Exp $	*/
d601 32
@


1.5
log
@Add missing free() in efid_io().  Found by jsg.

ok kettenis jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: efidev.c,v 1.4 2015/09/07 05:10:52 yasuoka Exp $	*/
a355 1
	start = LABELSECTOR + start;
d360 1
a360 1
		printf("loading disklabel @@ %u\n", start);
d363 1
a363 1
	error = efid_io(F_READ, ed, start, 1, buf);
@


1.4
log
@Fix the previous.  The condition of loop which read GPT partitions had been
broken.
@
text
@d1 1
a1 1
/*	$OpenBSD: efidev.c,v 1.3 2015/09/06 09:35:59 yasuoka Exp $	*/
d103 1
a103 1
			if (iblk && iblksz < ed->blkio->Media->BlockSize)
d105 2
@


1.3
log
@Use checksum to check the gpt parition.  Old check was missing
letoh32()/letoh64() calls.  Also increase buffer size from 512 to
4092.

initial work from krw
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: efidev.c,v 1.2 2015/09/02 08:24:29 yasuoka Exp $	*/
d311 1
a311 1
	for (i = 0; (ghpartnum + ghpartspersec - 1) / ghpartspersec;
@


1.2
log
@Add missing copyright.
@
text
@d1 1
a1 1
/*	$OpenBSD: efidev.c,v 1.1 2015/09/02 01:52:25 yasuoka Exp $	*/
d34 1
a249 1
	u_char			 buf[DEV_BSIZE];
a250 1
	struct			 gpt_partition *gp;
d253 2
d257 3
d276 5
d283 6
a288 1
	status = efid_io(F_READ, ed, EFI_SECTOBLK(ed, lba), 1, buf);
d297 8
a304 14
	/* assert and some checks not to read random place */
	if (gh.gh_part_size > DEV_BSIZE) {
		*err = "GPT paritition size beyonds the limit\n";
		return (-1);
	}
	if (gh.gh_lba_start >= ed->blkio->Media->LastBlock ||
	    gh.gh_part_lba >= gh.gh_lba_start) {
		*err = "bad GPT header\n";
		return (-1);
	}
	if ((gh.gh_part_num * gh.gh_part_size) / ed->blkio->Media->BlockSize
	    > gh.gh_lba_start - gh.gh_part_lba) {
		*err = "bad GPT number of partition entries\n";
		return (-1);
a306 1
	part = 0;
d308 7
a314 2
	while (part < letoh32(gh.gh_part_num)) {
		status = efid_io(F_READ, ed, EFI_SECTOBLK(ed, lba++), 1, buf);
d316 1
a316 1
			*err = "I/O Error\n";
d319 13
a331 8
		for (i = 0; i < GPT_PARTSPERSEC(&gh); i++) {
			gp = (struct gpt_partition *)
			    (buf + GPT_SECOFFSET(&gh, i));
			if (memcmp(&gp->gp_type, openbsd_uuid,
			    sizeof(struct uuid)) == 0)
				return letoh64(gp->gp_lba_start);
		}
		part += GPT_PARTSPERSEC(&gh);
@


1.1
log
@Initial commit of uefi boot loader of OpenBSD.

ok deraadt yuo
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d6 1
@

