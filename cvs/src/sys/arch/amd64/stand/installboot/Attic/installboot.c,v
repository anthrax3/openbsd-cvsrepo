head	1.28;
access;
symbols
	OPENBSD_5_5:1.27.0.4
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.26.0.2
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.25.0.2
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.24.0.4
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.2
	OPENBSD_5_0:1.23.0.2
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.12.0.6
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.4
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.10.0.4
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.2
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.8.0.2
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.6.0.8
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.6
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.4
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.5.0.6
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	OPENBSD_3_5:1.3.0.2
	OPENBSD_3_5_BASE:1.3
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.28
date	2014.06.09.15.51.40;	author jsing;	state dead;
branches;
next	1.27;
commitid	PoCfQX0AWtUJ5qUn;

1.27
date	2013.11.13.04.11.34;	author krw;	state Exp;
branches;
next	1.26;

1.26
date	2013.06.11.16.42.07;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2013.01.16.15.35.33;	author naddy;	state Exp;
branches;
next	1.24;

1.24
date	2011.11.13.14.52.30;	author jsing;	state Exp;
branches;
next	1.23;

1.23
date	2011.07.19.01.08.34;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2011.07.05.18.34.10;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2011.07.05.17.38.54;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2011.07.03.19.21.48;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2011.04.24.22.44.22;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2011.03.19.11.55.58;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2011.03.17.12.53.44;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2011.03.14.22.14.40;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2011.03.13.00.13.52;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2011.03.08.17.24.31;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2011.01.23.14.57.08;	author jsing;	state Exp;
branches;
next	1.12;

1.12
date	2009.05.30.23.13.14;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2009.04.23.16.39.16;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2008.08.04.15.58.13;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2008.06.25.15.26.44;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2008.01.24.12.09.53;	author krw;	state Exp;
branches;
next	1.7;

1.7
date	2008.01.05.19.50.48;	author otto;	state Exp;
branches;
next	1.6;

1.6
date	2006.02.14.17.16.19;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.15.21.44.16;	author tom;	state Exp;
branches;
next	1.4;

1.4
date	2004.05.05.04.33.56;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.22.09.03.05;	author tom;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.21.00.48.59;	author tom;	state Exp;
branches;
next	1.1;

1.1
date	2004.02.03.12.09.47;	author mickey;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.06.05.23.09.25;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Remove {amd64,i386}/stand/installboot - we now use usr.sbin/installboot
and these have been unhooked from the build for a while now.
@
text
@/*	$OpenBSD: installboot.c,v 1.27 2013/11/13 04:11:34 krw Exp $	*/
/*	$NetBSD: installboot.c,v 1.5 1995/11/17 23:23:50 gwr Exp $ */

/*
 * Copyright (c) 2011 Joel Sing <jsing@@openbsd.org>
 * Copyright (c) 2010 Otto Moerbeek <otto@@openbsd.org>
 * Copyright (c) 2003 Tom Cosgrove <tom.cosgrove@@arches-consulting.com>
 * Copyright (c) 1997 Michael Shalayeff
 * Copyright (c) 1994 Paul Kranenburg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Paul Kranenburg.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#define	ELFSIZE 32

#include <sys/param.h>
#include <sys/mount.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <sys/disklabel.h>
#include <sys/dkio.h>
#include <sys/ioctl.h>
#include <ufs/ufs/dinode.h>
#include <ufs/ufs/dir.h>
#include <ufs/ffs/fs.h>
#include <sys/reboot.h>

#include <dev/biovar.h>
#include <dev/softraidvar.h>

#include <uvm/uvm_extern.h>
#include <sys/sysctl.h>

#include <machine/cpu.h>
#include <machine/biosvar.h>

#include <err.h>
#include <a.out.h>
#include <sys/exec_elf.h>
#include <fcntl.h>
#include <nlist.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <util.h>

#include "nlist.c"

struct	sym_data {
	char		*sym_name;		/* Must be initialised */
	int		sym_size;		/* And this one */
	int		sym_set;		/* Rest set at runtime */
	u_int32_t	sym_value;
};

extern	char *__progname;
int	verbose, nowrite = 0;
char	*boot, *proto, *dev, *realdev;
char	*protostore;
long	protosize;
struct sym_data pbr_symbols[] = {
	{"_fs_bsize_p",	2},
	{"_fs_bsize_s",	2},
	{"_fsbtodb",	1},
	{"_p_offset",	4},
	{"_inodeblk",	4},
	{"_inodedbl",	4},
	{"_nblocks",	2},
	{NULL}
};

#define INODESEG	0x07e0	/* where we will put /boot's inode's block */
#define BOOTSEG		0x07c0	/* biosboot loaded here */

#define INODEOFF  ((INODESEG-BOOTSEG) << 4)

#define SR_FS_BLOCKSIZE	(16 * 1024)

static char	*loadproto(char *, long *);
static int	getbootparams(char *, int, struct disklabel *);
static void	devread(int, void *, daddr_t, size_t, char *);
static void	sym_set_value(struct sym_data *, char *, u_int32_t);
static void	pbr_set_symbols(char *, char *, struct sym_data *);
static void	usage(void);
static u_int	findopenbsd(int, struct disklabel *);
static void	write_bootblocks(int devfd, struct disklabel *);

static int	sr_volume(int, int *, int *);
static void	sr_installboot(int);
static void	sr_installpbr(int, int, int);

static void
usage(void)
{
	fprintf(stderr, "usage: %s [-nv] boot biosboot device\n", __progname);
	exit(1);
}

/*
 * Read information about /boot's inode and filesystem parameters, then
 * put biosboot (partition boot record) on the target drive with these
 * parameters patched in.
 */
int
main(int argc, char *argv[])
{
	int	vol = -1, ndisks = 0, disk;
	int	c;
	int	devfd;
	struct	disklabel dl;

	while ((c = getopt(argc, argv, "vn")) != -1) {
		switch (c) {
		case 'n':
			/* Do not actually write the bootblock to disk. */
			nowrite = 1;
			break;
		case 'v':
			/* Give more information. */
			verbose = 1;
			break;
		default:
			usage();
		}
	}

	if (argc - optind < 3)
		usage();

	boot = argv[optind];
	proto = argv[optind + 1];
	realdev = dev = argv[optind + 2];

	/* Open raw disk device. */
	if ((devfd = opendev(dev, (nowrite? O_RDONLY:O_RDWR),
	    OPENDEV_PART, &realdev)) < 0)
		err(1, "open: %s", realdev);

	if (verbose)
		fprintf(stderr, "boot: %s proto: %s device: %s\n",
		    boot, proto, realdev);

	/* Load proto blocks into core. */
	if ((protostore = loadproto(proto, &protosize)) == NULL)
		exit(1);

	/* XXX - Paranoia: Make sure size is aligned! */
	if (protosize & (DEV_BSIZE - 1))
		errx(1, "proto %s bad size=%ld", proto, protosize);

	if (protosize > SBSIZE - DEV_BSIZE)
		errx(1, "proto bootblocks too big");

	if (sr_volume(devfd, &vol, &ndisks)) {

		/* Install boot loader into softraid volume. */
		sr_installboot(devfd);

		/* Install biosboot on each disk that is part of this volume. */
		for (disk = 0; disk < ndisks; disk++)
			sr_installpbr(devfd, vol, disk);

	} else {

		/* Get and check disklabel. */
		if (ioctl(devfd, DIOCGDINFO, &dl) != 0)
			err(1, "disklabel: %s", realdev);
		if (dl.d_magic != DISKMAGIC)
			err(1, "bad disklabel magic=0x%08x", dl.d_magic);

		/* Warn on unknown disklabel types. */
		if (dl.d_type == 0)
			warnx("disklabel type unknown");

		/* Get bootstrap parameters to patch into proto. */
		if (getbootparams(boot, devfd, &dl) != 0)
			exit(1);

		/* Write boot blocks to device. */
		write_bootblocks(devfd, &dl);

	}

	(void)close(devfd);

	return 0;
}

void
write_bootblocks(int devfd, struct disklabel *dl)
{
	struct stat	sb;
	u_int8_t	*secbuf;
	u_int		start = 0;

	/* Write patched proto bootblock(s) into the superblock. */
	if (fstat(devfd, &sb) < 0)
		err(1, "stat: %s", realdev);

	if (!S_ISCHR(sb.st_mode))
		errx(1, "%s: not a character device", realdev);

	/* Patch the parameters into the proto bootstrap sector. */
	pbr_set_symbols(proto, protostore, pbr_symbols);

	if (!nowrite) {
		/* Sync filesystems (to clean in-memory superblock?). */
		sync(); sleep(1);
	}

	/*
	 * Find OpenBSD partition. Floppies are special, getting an
	 * everything-in-one biosboot starting at sector 0.
	 */
	if (dl->d_type != DTYPE_FLOPPY) {
		start = findopenbsd(devfd, dl);
		if (start == (u_int)-1)
 			errx(1, "no OpenBSD partition");
	}

	if (verbose)
		fprintf(stderr, "%s will be written at sector %u\n", proto,
		    start);

	if (start + (protosize / dl->d_secsize) > BOOTBIOS_MAXSEC)
		warnx("%s extends beyond sector %u. OpenBSD might not boot.",
		    proto, BOOTBIOS_MAXSEC);

	if (!nowrite) {
		if (lseek(devfd, (off_t)start * dl->d_secsize, SEEK_SET) < 0)
			err(1, "seek bootstrap");
		secbuf = calloc(1, dl->d_secsize);
		bcopy(protostore, secbuf, protosize);
		if (write(devfd, secbuf, dl->d_secsize) != dl->d_secsize)
			err(1, "write bootstrap");
		free(secbuf);
	}
}

u_int
findopenbsd(int devfd, struct disklabel *dl)
{
	struct		dos_mbr mbr;
	u_int		mbroff = DOSBBSECTOR;
	u_int		mbr_eoff = DOSBBSECTOR; /* Offset of extended part. */
	struct		dos_partition *dp;
	u_int8_t	*secbuf;
	int		i, maxebr = DOS_MAXEBR, nextebr;

again:
	if (!maxebr--) {
		if (verbose)
			fprintf(stderr, "Traversed more than %d Extended Boot "
			    "Records (EBRs)\n",
			    DOS_MAXEBR);
		return ((u_int)-1);
	}
		
	if (verbose)
		fprintf(stderr, "%s boot record (%cBR) at sector %u\n",
		    (mbroff == DOSBBSECTOR) ? "master" : "extended",
		    (mbroff == DOSBBSECTOR) ? 'M' : 'E', mbroff);

	secbuf = malloc(dl->d_secsize); 
	if (lseek(devfd, (off_t)mbroff * dl->d_secsize, SEEK_SET) < 0 ||
	    read(devfd, secbuf, dl->d_secsize) < sizeof(mbr))
		err(4, "can't read boot record");
	bcopy(secbuf, &mbr, sizeof(mbr));
	free(secbuf);

	if (mbr.dmbr_sign != DOSMBR_SIGNATURE)
		errx(1, "invalid boot record signature (0x%04X) @@ sector %u",
		    mbr.dmbr_sign, mbroff);

	nextebr = 0;
	for (i = 0; i < NDOSPART; i++) {
		dp = &mbr.dmbr_parts[i];
		if (!dp->dp_size)
			continue;

		if (verbose)
			fprintf(stderr,
			    "\tpartition %d: type 0x%02X offset %u size %u\n",
			    i, dp->dp_typ, dp->dp_start, dp->dp_size);

		if (dp->dp_typ == DOSPTYP_OPENBSD) {
			if (dp->dp_start > (dp->dp_start + mbroff))
				continue;
			return (dp->dp_start + mbroff);
		}

		if (!nextebr && (dp->dp_typ == DOSPTYP_EXTEND ||
		    dp->dp_typ == DOSPTYP_EXTENDL)) {
			nextebr = dp->dp_start + mbr_eoff;
			if (nextebr < dp->dp_start)
				nextebr = (u_int)-1;
			if (mbr_eoff == DOSBBSECTOR)
				mbr_eoff = dp->dp_start;
		}
	}

	if (nextebr && nextebr != (u_int)-1) {
		mbroff = nextebr;
		goto again;
	}

	return ((u_int)-1);
}

/*
 * Load the prototype boot sector (biosboot) into memory.
 */
static char *
loadproto(char *fname, long *size)
{
	int	fd;
	size_t	tdsize;		/* text+data size */
	char	*bp;
	Elf_Ehdr eh;
	Elf_Word phsize;
	Elf_Phdr *ph;

	if ((fd = open(fname, O_RDONLY)) < 0)
		err(1, "%s", fname);

	if (read(fd, &eh, sizeof(eh)) != sizeof(eh))
		errx(1, "%s: read failed", fname);

	if (!IS_ELF(eh))
		errx(1, "%s: bad magic: 0x%02x%02x%02x%02x",
		    fname,
		    eh.e_ident[EI_MAG0], eh.e_ident[EI_MAG1],
		    eh.e_ident[EI_MAG2], eh.e_ident[EI_MAG3]);

	/*
	 * We have to include the exec header in the beginning of
	 * the buffer, and leave extra space at the end in case
	 * the actual write to disk wants to skip the header.
	 */

	/* Program load header. */
	if (eh.e_phnum != 1)
		errx(1, "%s: %u ELF load sections (only support 1)",
		    fname, eh.e_phnum);

	phsize = eh.e_phnum * sizeof(Elf_Phdr);
	ph = malloc(phsize);
	if (ph == NULL)
		err(1, NULL);

	lseek(fd, eh.e_phoff, SEEK_SET);

	if (read(fd, ph, phsize) != phsize)
		errx(1, "%s: can't read header", fname);

	tdsize = ph->p_filesz;

	/*
	 * Allocate extra space here because the caller may copy
	 * the boot block starting at the end of the exec header.
	 * This prevents reading beyond the end of the buffer.
	 */
	if ((bp = calloc(tdsize, 1)) == NULL) {
		err(1, NULL);
	}

	/* Read the rest of the file. */
	lseek(fd, ph->p_offset, SEEK_SET);
	if (read(fd, bp, tdsize) != tdsize) {
		errx(1, "%s: read failed", fname);
	}

	*size = tdsize;	/* not aligned to DEV_BSIZE */

	close(fd);
	return bp;
}

static void
devread(int fd, void *buf, daddr_t blk, size_t size, char *msg)
{
	if (lseek(fd, dbtob((off_t)blk), SEEK_SET) != dbtob((off_t)blk))
		err(1, "%s: devread: lseek", msg);

	if (read(fd, buf, size) != size)
		err(1, "%s: devread: read", msg);
}

static char sblock[SBSIZE];

/*
 * Read information about /boot's inode, then put this and filesystem
 * parameters from the superblock into pbr_symbols.
 */
static int
getbootparams(char *boot, int devfd, struct disklabel *dl)
{
	int		fd;
	struct stat	statbuf, sb;
	struct statfs	statfsbuf;
	struct partition *pp;
	struct fs	*fs;
	char		*buf;
	u_int		blk, *ap;
	struct ufs1_dinode	*ip;
	int		ndb;
	int		mib[3];
	size_t		size;
	dev_t		dev;

	/*
	 * Open 2nd-level boot program and record enough details about
	 * where it is on the filesystem represented by `devfd'
	 * (inode block, offset within that block, and various filesystem
	 * parameters essentially taken from the superblock) for biosboot
	 * to be able to load it later.
	 */

	/* Make sure the (probably new) boot file is on disk. */
	sync(); sleep(1);

	if ((fd = open(boot, O_RDONLY)) < 0)
		err(1, "open: %s", boot);

	if (fstatfs(fd, &statfsbuf) != 0)
		err(1, "statfs: %s", boot);

	if (strncmp(statfsbuf.f_fstypename, "ffs", MFSNAMELEN) &&
	    strncmp(statfsbuf.f_fstypename, "ufs", MFSNAMELEN) )
		errx(1, "%s: not on an FFS filesystem", boot);

#if 0
	if (read(fd, &eh, sizeof(eh)) != sizeof(eh))
		errx(1, "read: %s", boot);

	if (!IS_ELF(eh)) {
		errx(1, "%s: bad magic: 0x%02x%02x%02x%02x",
		    boot,
		    eh.e_ident[EI_MAG0], eh.e_ident[EI_MAG1],
		    eh.e_ident[EI_MAG2], eh.e_ident[EI_MAG3]);
	}
#endif

	if (fsync(fd) != 0)
		err(1, "fsync: %s", boot);

	if (fstat(fd, &statbuf) != 0)
		err(1, "fstat: %s", boot);

	if (fstat(devfd, &sb) != 0)
		err(1, "fstat: %s", realdev);

	/* Check devices. */
	mib[0] = CTL_MACHDEP;
	mib[1] = CPU_CHR2BLK;
	mib[2] = sb.st_rdev;
	size = sizeof(dev);
	if (sysctl(mib, 3, &dev, &size, NULL, 0) >= 0) {
		if (statbuf.st_dev / MAXPARTITIONS != dev / MAXPARTITIONS)
			errx(1, "cross-device install");
	}

	pp = &dl->d_partitions[DISKPART(statbuf.st_dev)];
	close(fd);

	/* Read superblock. */
	devread(devfd, sblock, DL_SECTOBLK(dl, DL_GETPOFFSET(pp)) + SBLOCK,
	    SBSIZE, "superblock");
	fs = (struct fs *)sblock;

	/* Sanity-check super-block. */
	if (fs->fs_magic != FS_MAGIC)
		errx(1, "Bad magic number in superblock");
	if (fs->fs_inopb <= 0)
		err(1, "Bad inopb=%d in superblock", fs->fs_inopb);

	/* Read inode. */
	if ((buf = malloc(fs->fs_bsize)) == NULL)
		err(1, NULL);

	blk = fsbtodb(fs, ino_to_fsba(fs, statbuf.st_ino));

	devread(devfd, buf, DL_SECTOBLK(dl, DL_GETPOFFSET(pp)) + blk,
	    fs->fs_bsize, "inode");
	ip = (struct ufs1_dinode *)(buf) + ino_to_fsbo(fs, statbuf.st_ino);

	/*
	 * Have the inode.  Figure out how many filesystem blocks (not disk
	 * sectors) there are for biosboot to load.
	 */
	ndb = howmany(ip->di_size, fs->fs_bsize);
	if (ndb <= 0)
		errx(1, "No blocks to load");

	/*
	 * Now set the values that will need to go into biosboot
	 * (the partition boot record, a.k.a. the PBR).
	 */
	sym_set_value(pbr_symbols, "_fs_bsize_p", (fs->fs_bsize / 16));
	sym_set_value(pbr_symbols, "_fs_bsize_s", (fs->fs_bsize / 
	    dl->d_secsize));

	/*
	 * fs_fsbtodb is the shift to convert fs_fsize to DEV_BSIZE. The
	 * ino_to_fsba() return value is the number of fs_fsize units.
	 * Calculate the shift to convert fs_fsize into physical sectors,
	 * which are added to p_offset to get the sector address BIOS
	 * will use.
	 *
	 * N.B.: ASSUMES fs_fsize is a power of 2 of d_secsize.
	 */
	sym_set_value(pbr_symbols, "_fsbtodb",
	    ffs(fs->fs_fsize / dl->d_secsize) - 1);

	if (pp->p_offseth != 0)
		errx(1, "partition offset too high");
	sym_set_value(pbr_symbols, "_p_offset", pp->p_offset);
	sym_set_value(pbr_symbols, "_inodeblk",
	    ino_to_fsba(fs, statbuf.st_ino));
	ap = ip->di_db;
	sym_set_value(pbr_symbols, "_inodedbl",
	    ((((char *)ap) - buf) + INODEOFF));
	sym_set_value(pbr_symbols, "_nblocks", ndb);

	if (verbose) {
		fprintf(stderr, "%s is %d blocks x %d bytes\n",
		    boot, ndb, fs->fs_bsize);
		fprintf(stderr, "fs block shift %u; part offset %llu; "
		    "inode block %lld, offset %u\n",
		    ffs(fs->fs_fsize / dl->d_secsize) - 1,
		    DL_GETPOFFSET(pp), ino_to_fsba(fs, statbuf.st_ino),
		    (unsigned int)((((char *)ap) - buf) + INODEOFF));
	}

	return 0;
}

static void
sym_set_value(struct sym_data *sym_list, char *sym, u_int32_t value)
{
	struct sym_data *p;

	for (p = sym_list; p->sym_name != NULL; p++) {
		if (strcmp(p->sym_name, sym) == 0)
			break;
	}

	if (p->sym_name == NULL)
		errx(1, "%s: no such symbol", sym);

	p->sym_value = value;
	p->sym_set = 1;
}

/*
 * Write the parameters stored in sym_list into the in-memory copy of
 * the prototype biosboot (proto), ready for it to be written to disk.
 */
static void
pbr_set_symbols(char *fname, char *proto, struct sym_data *sym_list)
{
	struct sym_data *sym;
	struct nlist	*nl;
	char		*vp;
	u_int32_t	*lp;
	u_int16_t	*wp;
	u_int8_t	*bp;

	for (sym = sym_list; sym->sym_name != NULL; sym++) {
		if (!sym->sym_set)
			errx(1, "%s not set", sym->sym_name);

		/* Allocate space for 2; second is null-terminator for list. */
		nl = calloc(2, sizeof(struct nlist));
		if (nl == NULL)
			err(1, NULL);

		nl->n_un.n_name = sym->sym_name;

		if (nlist(fname, nl) != 0)
			errx(1, "%s: symbol %s not found",
			    fname, sym->sym_name);

		if (nl->n_type != (N_TEXT))
			errx(1, "%s: %s: wrong type (%x)",
			    fname, sym->sym_name, nl->n_type);

		/* Get a pointer to where the symbol's value needs to go. */
		vp = proto + nl->n_value;

		switch (sym->sym_size) {
		case 4:					/* u_int32_t */
			lp = (u_int32_t *) vp;
			*lp = sym->sym_value;
			break;
		case 2:					/* u_int16_t */
			if (sym->sym_value >= 0x10000)	/* out of range */
				errx(1, "%s: symbol out of range (%u)",
				    sym->sym_name, sym->sym_value);
			wp = (u_int16_t *) vp;
			*wp = (u_int16_t) sym->sym_value;
			break;
		case 1:					/* u_int16_t */
			if (sym->sym_value >= 0x100)	/* out of range */
				errx(1, "%s: symbol out of range (%u)",
				    sym->sym_name, sym->sym_value);
			bp = (u_int8_t *) vp;
			*bp = (u_int8_t) sym->sym_value;
			break;
		default:
			errx(1, "%s: bad symbol size %d",
			    sym->sym_name, sym->sym_size);
			/* NOTREACHED */
		}

		free(nl);
	}
}

int
sr_volume(int devfd, int *vol, int *disks)
{
	struct	bioc_inq bi;
	struct	bioc_vol bv;
	int	rv, i;

	/* Get volume information. */
	memset(&bi, 0, sizeof(bi));
	rv = ioctl(devfd, BIOCINQ, &bi);
	if (rv == -1)
		return 0;

	/* XXX - softraid volumes will always have a "softraid0" controller. */
	if (strncmp(bi.bi_dev, "softraid0", sizeof("softraid0")))
		return 0;

	/* Locate specific softraid volume. */
	for (i = 0; i < bi.bi_novol; i++) {

		memset(&bv, 0, sizeof(bv));
		bv.bv_volid = i;
		rv = ioctl(devfd, BIOCVOL, &bv);
		if (rv == -1)
			err(1, "BIOCVOL");

		if (strncmp(dev, bv.bv_dev, sizeof(bv.bv_dev)) == 0) {
			*vol = i;
			*disks = bv.bv_nodisk;
			break;
		}

	}

	if (verbose)
		fprintf(stderr, "%s: softraid volume with %i disk(s)\n",
		    dev, *disks);

	return 1;
}

void
sr_installboot(int devfd)
{
	struct bioc_installboot bb;
	struct stat sb;
	struct ufs1_dinode *ino_p;
	uint32_t bootsize, inodeblk, inodedbl;
	uint16_t bsize = SR_FS_BLOCKSIZE;
	uint16_t nblocks;
	uint8_t bshift = 5;		/* fragsize == blocksize */
	int fd, i, rv;
	u_char *p;

	/*
	 * Install boot loader into softraid boot loader storage area.
	 *
	 * In order to allow us to reuse the existing biosboot we construct
	 * a fake FFS filesystem with a single inode, which points to the
	 * boot loader.
	 */

	nblocks = howmany(SR_BOOT_LOADER_SIZE, SR_FS_BLOCKSIZE / DEV_BSIZE);
	inodeblk = nblocks - 1;
	bootsize = nblocks * SR_FS_BLOCKSIZE;

	p = malloc(bootsize);
	if (p == NULL)
		err(1, NULL);
	
	memset(p, 0, bootsize);
	fd = open(boot, O_RDONLY, 0);
	if (fd == -1)
		err(1, NULL);

	if (fstat(fd, &sb) == -1)
		err(1, NULL);

	nblocks = howmany(sb.st_blocks, SR_FS_BLOCKSIZE / DEV_BSIZE);
	if (sb.st_blocks * S_BLKSIZE > bootsize - sizeof(struct ufs1_dinode))
		errx(1, "boot code will not fit");

	/* We only need to fill the direct block array. */
	ino_p = (struct ufs1_dinode *)&p[bootsize - sizeof(struct ufs1_dinode)];

	ino_p->di_mode = sb.st_mode;
	ino_p->di_nlink = 1;
	ino_p->di_inumber = 0xfeebfaab;
	ino_p->di_size = read(fd, p, sb.st_blocks * S_BLKSIZE);
	ino_p->di_blocks = nblocks;
	for (i = 0; i < nblocks; i++)
		ino_p->di_db[i] = i;

	inodedbl = ((u_char*)&ino_p->di_db[0] -
	    &p[bootsize - SR_FS_BLOCKSIZE]) + INODEOFF;

	bb.bb_bootldr = p;
	bb.bb_bootldr_size = bootsize;
	bb.bb_bootblk = "XXX";
	bb.bb_bootblk_size = sizeof("XXX");
	strncpy(bb.bb_dev, dev, sizeof(bb.bb_dev));
	if (!nowrite) {
		if (verbose)
			fprintf(stderr, "%s: installing boot loader on "
			    "softraid volume\n", dev);
		rv = ioctl(devfd, BIOCINSTALLBOOT, &bb);
		if (rv != 0)
			errx(1, "softraid installboot failed");
	}

	/*
	 * Set the values that will need to go into biosboot
	 * (the partition boot record, a.k.a. the PBR).
	 */
	sym_set_value(pbr_symbols, "_fs_bsize_p", (bsize / 16));
	sym_set_value(pbr_symbols, "_fs_bsize_s", (bsize / 512));
	sym_set_value(pbr_symbols, "_fsbtodb", bshift);
	sym_set_value(pbr_symbols, "_inodeblk", inodeblk);
	sym_set_value(pbr_symbols, "_inodedbl", inodedbl);
	sym_set_value(pbr_symbols, "_nblocks", nblocks);

	if (verbose)
		fprintf(stderr, "%s is %d blocks x %d bytes\n",
		    boot, nblocks, bsize);

	close(fd);
}

void
sr_installpbr(int devfd, int vol, int disk)
{
	struct bioc_disk bd;
	struct disklabel dl;
	struct partition *pp;
	uint32_t poffset;
	char *realdiskdev;
	char part;
	int diskfd;
	int rv;

	/* Get device name for this disk/chunk. */
	memset(&bd, 0, sizeof(bd));
	bd.bd_volid = vol;
	bd.bd_diskid = disk;
	rv = ioctl(devfd, BIOCDISK, &bd);
	if (rv == -1)
		err(1, "BIOCDISK");

	/* Check disk status. */
	if (bd.bd_status != BIOC_SDONLINE && bd.bd_status != BIOC_SDREBUILD) {
		fprintf(stderr, "softraid chunk %u not online - skipping...\n",
		    disk);
		return;	
	}

	if (strlen(bd.bd_vendor) < 1)
		errx(1, "invalid disk name");
	part = bd.bd_vendor[strlen(bd.bd_vendor) - 1];
	if (part < 'a' || part >= 'a' + MAXPARTITIONS)
		errx(1, "invalid partition %c\n", part);
	bd.bd_vendor[strlen(bd.bd_vendor) - 1] = '\0';

	/* Open this device and check its disklabel. */
	if ((diskfd = opendev(bd.bd_vendor, (nowrite? O_RDONLY:O_RDWR),
	    OPENDEV_PART, &realdiskdev)) < 0)
		err(1, "open: %s", realdiskdev);

	/* Get and check disklabel. */
	if (ioctl(diskfd, DIOCGDINFO, &dl) != 0)
		err(1, "disklabel: %s", realdev);
	if (dl.d_magic != DISKMAGIC)
		err(1, "bad disklabel magic=0x%08x", dl.d_magic);

	/* Warn on unknown disklabel types. */
	if (dl.d_type == 0)
		warnx("disklabel type unknown");

	/* Determine poffset and set symbol value. */
	pp = &dl.d_partitions[part - 'a'];
	if (pp->p_offseth != 0)
		errx(1, "partition offset too high");
	poffset = pp->p_offset; 		/* Offset of RAID partition. */
	poffset += SR_BOOT_LOADER_OFFSET;	/* SR boot loader area. */
	sym_set_value(pbr_symbols, "_p_offset", poffset);

	if (verbose)
		fprintf(stderr, "%s%c: installing boot blocks on %s, "
		    "part offset %u\n", bd.bd_vendor, part, realdiskdev,
		    poffset);

	/* Write boot blocks to device. */
	write_bootblocks(diskfd, &dl);

	close(diskfd);
}
@


1.27
log
@Use DL_GETPOFFSET() to get partition offset, except where we
explicitly check p_offseth before assigning p_offset to
local variables. Add missing check for p_offseth.
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.26 2013/06/11 16:42:07 deraadt Exp $	*/
@


1.26
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.25 2013/01/16 15:35:33 naddy Exp $	*/
d492 1
a492 1
	devread(devfd, sblock, DL_SECTOBLK(dl, pp->p_offset) + SBLOCK,
d508 1
a508 1
	devread(devfd, buf, DL_SECTOBLK(dl, pp->p_offset) + blk,
d540 2
d553 1
a553 1
		fprintf(stderr, "fs block shift %u; part offset %u; "
d556 1
a556 2
		    pp->p_offset,
		    ino_to_fsba(fs, statbuf.st_ino),
@


1.25
log
@properly distinguish /boot and biosboot in informational and error messages
ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.24 2011/11/13 14:52:30 jsing Exp $	*/
d106 1
a106 1
static void	devread(int, void *, daddr64_t, size_t, char *);
d405 1
a405 1
devread(int fd, void *buf, daddr64_t blk, size_t size, char *msg)
@


1.24
log
@If a softraid chunk is offline we are not necessarily going to have the
disk/partition name - in this case print the chunk number instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.22 2011/07/05 18:34:10 krw Exp $	*/
d238 1
a238 1
	 * everything-in-one /boot starting at sector 0.
d247 2
a248 1
		fprintf(stderr, "/boot will be written at sector %u\n", start);
d251 2
a252 2
		warnx("/boot extends beyond sector %u. OpenBSD might not boot.",
		    BOOTBIOS_MAXSEC);
d356 1
a356 1
		    boot,
d369 1
a369 1
		    boot, eh.e_phnum);
d379 1
a379 1
		errx(1, "%s: can't read header", boot);
@


1.23
log
@Warn about but don't prevent installboot from installing /boot when
the OpenBSD partition starts at >128G. This restores previous
behaviour but adds the warning.

ok deraadt@@ guenther@@
@
text
@d793 2
a794 2
		fprintf(stderr, "softraid disk %s not online - skipping...\n",
		    bd.bd_vendor);
d799 1
a799 1
		errx(1, "invalid disk name %s", bd.bd_vendor);
@


1.22
log
@Don't write /boot to sector 0 on non-floppy devices. Non-floppy
devices must have an OpenBSD MBR partition to install /boot into.
But search anything except floppy devices (e.g. vnd) for such a
partition.

Feedback & ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.21 2011/07/05 17:38:54 krw Exp $	*/
d246 3
d250 1
a250 1
		errx(1, "invalid location: all of /boot must be < sector %u.",
a251 3

	if (verbose)
		fprintf(stderr, "/boot will be written at sector %u\n", start);
@


1.21
log
@More non-512-byte sector groundwork. Don't let disklabel hint that
a ffs frag size can be less than the d_secsize of the disk.  Make
sure amd64 writedisklabel() puts the disklabel where readdoslabel()
will read it. Tweak i386/amd64 installboot/biosboot so sectors are
indeed used where sectors are claimed.

Lets me fdisk, newfs, mount and installboot onto 2048 and 4096
byte sector devices. Other filesystem utilites will still hold
surprises.

Note that actually booting from such devices will await BIOSen that
acknowledge such devices as bootable.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.20 2011/07/03 19:21:48 krw Exp $	*/
d236 5
a240 3
	if (dl->d_type != 0 && dl->d_type != DTYPE_FLOPPY &&
	    dl->d_type != DTYPE_VND) {
		/* Find OpenBSD partition. */
@


1.20
log
@Change name of pointer to partition from pl to pp, as is used everywhere else, No
functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.19 2011/04/24 22:44:22 krw Exp $	*/
d218 1
d244 1
a244 1
	if (start + (protosize / DEV_BSIZE) > BOOTBIOS_MAXSEC)
d252 5
a256 2
		if (lseek(devfd, (off_t)start * dl->d_secsize, SEEK_SET) < 0 ||
		    write(devfd, protostore, protosize) != protosize)
d258 1
d269 1
d286 1
d288 1
a288 1
	    read(devfd, &mbr, sizeof(mbr)) != sizeof(mbr))
d290 2
d489 2
a490 1
	devread(devfd, sblock, pp->p_offset + SBLOCK, SBSIZE, "superblock");
d505 2
a506 1
	devread(devfd, buf, pp->p_offset + blk, fs->fs_bsize, "inode");
d522 15
a536 2
	sym_set_value(pbr_symbols, "_fs_bsize_s", (fs->fs_bsize / 512));
	sym_set_value(pbr_symbols, "_fsbtodb", fs->fs_fsbtodb);
d550 2
a551 1
		    fs->fs_fsbtodb, pp->p_offset,
@


1.19
log
@Don't leak fd's in sr_installboot(). From cppcheck via Amit Kulkarni.
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.18 2011/03/19 11:55:58 krw Exp $	*/
d414 1
a414 1
	struct partition *pl;
d476 1
a476 1
	pl = &dl->d_partitions[DISKPART(statbuf.st_dev)];
d480 1
a480 1
	devread(devfd, sblock, pl->p_offset + SBLOCK, SBSIZE, "superblock");
d495 1
a495 1
	devread(devfd, buf, pl->p_offset + blk, fs->fs_bsize, "inode");
d513 1
a513 1
	sym_set_value(pbr_symbols, "_p_offset", pl->p_offset);
d526 1
a526 1
		    fs->fs_fsbtodb, pl->p_offset,
@


1.18
log
@Make amd64/i386 installboot error out if /boot would cross the
BOOTBIOS_MAXSEC line.

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.17 2011/03/17 12:53:44 krw Exp $	*/
d740 2
@


1.17
log
@Make the various findopenbsd() functions non-recursive, eliminating
a global, a couple of parameters, and opening up possibility of
traversing much longer EBR lists without blowing the stack.

Make seach algorithm the same as used in kern/subr_disk.c by checking
all primary partitions in the MBR/EBR before moving to next EBR. This
makes it more likely that everybody finds the same OpenBSD partition.

Largely from a diff posted to tech@@ by ucsavl.
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.16 2011/03/14 22:14:40 krw Exp $	*/
d242 4
@


1.16
log
@Clamp BIOS io attempts to < 2 ^28 - 1 sectors (a.k.a. 128GB for
512-byte sectors) as some BIOSen get confused when we ask for sectors
higher up.

Uss u_int throughout the boot code to calculate sector addresses,
since 32 bits is enough to do 28  ^ 1 - 1 arithmetic. Add checks
for wraparound.

I can now install and boot from the 7th extended partition below
128GB.

Much feedback & guidance from deraadt@@. Also from weingart@@ on
BIOS io.

ok deraadt@@ (less a couple of minor tweaks found in testing)
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.15 2011/03/13 00:13:52 deraadt Exp $	*/
d110 1
a110 1
static u_int	findopenbsd(int, struct disklabel *, u_int, int *);
a116 2
static u_int	mbr_eoff; /* Offset of the MBR extended partition. */

d217 1
a217 1
	struct		stat sb;
a218 1
	int		n = 8;
d238 1
a238 2
		mbr_eoff = DOSBBSECTOR;	/* Offset of MBR extended partition. */
		start = findopenbsd(devfd, dl, DOSBBSECTOR, &n);
d254 1
a254 1
findopenbsd(int devfd, struct disklabel *dl, u_int mbroff, int *n)
d257 2
d260 1
a260 6
	u_int		start = (u_int)-1;
	int		i;

	/* Limit the number of recursions */
	if (!(*n)--)
		return (-1);
d262 9
d284 1
d298 1
a298 2
			start = dp->dp_start + mbroff;
			break;
d301 5
a305 3
		if (dp->dp_typ == DOSPTYP_EXTEND ||
		    dp->dp_typ == DOSPTYP_EXTENDL) {
			mbroff = dp->dp_start + mbr_eoff;
a307 5
			if (mbroff < dp->dp_start)
				continue;
			start = findopenbsd(devfd, dl, mbroff, n);
			if (start != (u_int)-1)
				break;
d311 6
a316 1
	return (start);
@


1.15
log
@Change daddr_t to daddr32_t.  The bootblocks on our architectures only
do 32-bit block spanning.  If later on we get some that can/should do
64-bit, that can be done now using daddr64_t (but of course, we are taking
this step to finalize the daddr_t 64-bit conversion).
ok miod krw
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.14 2011/03/08 17:24:31 krw Exp $	*/
d110 1
a110 1
static daddr64_t findopenbsd(int, struct disklabel *, daddr64_t, int *);
d117 1
a117 1
static daddr64_t mbr_eoff; /* Offset of the MBR extended partition. */
d220 1
a220 1
	daddr64_t	start = 0;
d241 3
a243 3
		mbr_eoff = 0;	/* Offset of MBR extended partition. */
		start = findopenbsd(devfd, dl, (daddr64_t)DOSBBSECTOR, &n);
		if (start == -1)
d248 1
a248 2
		fprintf(stderr, "/boot will be written at sector %lld\n",
		    (long long)start);
d257 2
a258 2
daddr64_t
findopenbsd(int devfd, struct disklabel *dl, daddr64_t mbroff, int *n)
d262 1
a262 1
	daddr64_t	start = -1;
d270 3
a272 4
		fprintf(stderr, "%s boot record (%cBR) at sector %lld\n",
		    (mbroff == (off_t)DOSBBSECTOR) ? "master" : "extended",
		    (mbroff == (off_t)DOSBBSECTOR) ? 'M' : 'E',
		    (long long)mbroff);
d279 2
a280 2
		errx(1, "invalid boot record signature (0x%04X)",
		    mbr.dmbr_sign);
d289 1
a289 1
			    "\tpartition %d: type 0x%02X offset %d size %d\n",
d293 3
a295 1
			start = (daddr64_t)dp->dp_start + mbroff;
d301 5
a305 3
			mbroff = (daddr64_t)dp->dp_start + mbr_eoff;
			if (!mbr_eoff)
				mbr_eoff = (daddr64_t)dp->dp_start;
d307 1
a307 1
			if (start != -1)
@


1.14
log
@Fix extended partition searching so we don't get lost. The offset
of the next EBR is relative to the start of the extended partition
described in the first MBR, not relative to the EBR specifying the
offset in its extended partition entry.

Clean up installboot -v output. Use daddr64_t for all sector numbers.

Not a complete fix, but better than what we had. More tweaks to
come.

Inspired by a diff and cluebat from uscav on tech@@ a few weeks
ago.

Feedback from matthew@@, weingart@@.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.13 2011/01/23 14:57:08 jsing Exp $	*/
d106 1
a106 1
static void	devread(int, void *, daddr_t, size_t, char *);
d383 1
a383 1
devread(int fd, void *buf, daddr_t blk, size_t size, char *msg)
d407 1
a407 1
	daddr_t		blk, *ap;
@


1.13
log
@Add support to installboot(8) for installing biosboot(8) and boot(8) on
softraid volumes. If installboot is run on a softraid volume, a fake
single inode FFS filesystem is constructed to contain boot(8). This is
then installed onto the softraid volume via the BIOCINSTALLBOOT ioctl.
biosboot(8) is then patched and installed onto each disk that is a member
of the softraid volume.

Joint work with otto@@ who came up with the concept of constructing a fake
FFS filesystem and wrote the code to do so.

No objection from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.11 2009/04/23 16:39:16 deraadt Exp $	*/
d110 1
a110 1
static long	findopenbsd(int, struct disklabel *, off_t, int *);
d117 2
d219 3
a221 4
	struct	stat sb;
	off_t	startoff = 0;
	long	start = 0;
	int	n = 8;
d241 2
a242 1
		start = findopenbsd(devfd, dl, (off_t)DOSBBSECTOR, &n);
a244 1
		startoff = (off_t)start * dl->d_secsize;
d247 4
d252 1
a252 1
		if (lseek(devfd, startoff, SEEK_SET) < 0 ||
d258 2
a259 2
long
findopenbsd(int devfd, struct disklabel *dl, off_t mbroff, int *n)
d263 2
a264 2
	off_t		startoff;
	long		start;
d270 7
a276 1
	if (lseek(devfd, mbroff * dl->d_secsize, SEEK_SET) < 0 ||
d278 1
a278 1
		err(4, "can't read master boot record");
d281 2
a282 1
		errx(1, "broken MBR");
d284 2
a285 2
	for (dp = mbr.dmbr_parts; dp < &mbr.dmbr_parts[NDOSPART];
	    dp++) {
d288 6
d295 5
a299 7
			if (verbose)
				fprintf(stderr,
				    "using MBR partition %ld: type 0x%02X offset %d\n",
				    (long)(dp - mbr.dmbr_parts),
				    dp->dp_typ, dp->dp_start);
			return (dp->dp_start + mbroff);
		} else if (dp->dp_typ == DOSPTYP_EXTEND ||
d301 4
a304 7
			if (verbose)
				fprintf(stderr,
				    "extended partition %ld: type 0x%02X offset %d\n",
				    (long)(dp - mbr.dmbr_parts),
				    dp->dp_typ, dp->dp_start);
			startoff = (off_t)dp->dp_start + mbroff;
			start = findopenbsd(devfd, dl, startoff, n);
d306 1
a306 1
				return (start);
d310 1
a310 1
	return (-1);
@


1.12
log
@Without -v, be quiet
ok toby
@
text
@d5 2
d52 3
d84 2
d102 2
d111 5
d132 1
a134 3
	char	*protostore;
	long	protosize;
	struct	stat sb;
a135 3
	off_t	startoff = 0;
	long	start = 0;
	int	n = 8;
d159 1
a159 1
	/* Open and check raw disk device. */
a167 11
	if (ioctl(devfd, DIOCGDINFO, &dl) != 0)
		err(1, "disklabel: %s", realdev);

	/* Check disklabel. */
	if (dl.d_magic != DISKMAGIC)
		err(1, "bad disklabel magic=0x%08x", dl.d_magic);

	/* Warn on unknown disklabel types. */
	if (dl.d_type == 0)
		warnx("disklabel type unknown");

a175 1
	/* Write patched proto bootblock(s) into the superblock. */
d179 44
a228 4
	/* Get bootstrap parameters that are to be patched into proto. */
	if (getbootparams(boot, devfd, &dl) != 0)
		exit(1);

d237 2
a238 2
	if (dl.d_type != 0 && dl.d_type != DTYPE_FLOPPY &&
	    dl.d_type != DTYPE_VND) {
d240 1
a240 1
		start = findopenbsd(devfd, &dl, (off_t)DOSBBSECTOR, &n);
d243 1
a243 1
		startoff = (off_t)start * dl.d_secsize;
a250 4

	(void)close(devfd);

	return 0;
a523 3
	if (p->sym_set)
		errx(1, "%s already set", p->sym_name);

d591 194
@


1.11
log
@-v was printing some information which is irrelevant or duplicate.  This
shrinks the output of installboot by a few lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.10 2008/08/04 15:58:13 reyk Exp $	*/
d244 5
a248 4
			fprintf(stderr,
			    "using MBR partition %ld: type 0x%02X offset %d\n",
			    (long)(dp - mbr.dmbr_parts),
			    dp->dp_typ, dp->dp_start);
d252 5
a256 4
			fprintf(stderr,
			    "extended partition %ld: type 0x%02X offset %d\n",
			    (long)(dp - mbr.dmbr_parts),
			    dp->dp_typ, dp->dp_start);
@


1.10
log
@fix extended partition support by handling chained EBRs correctly
(using a recursion limit).  now OpenBSD can be installed in a
subsequent DOS/Linux-compatible extended partition.

ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.9 2008/06/25 15:26:44 reyk Exp $	*/
d155 3
a157 5
	if (verbose) {
		fprintf(stderr, "boot: %s\n", boot);
		fprintf(stderr, "proto: %s\n", proto);
		fprintf(stderr, "device: %s\n", realdev);
	}
d244 2
a245 2
			fprintf(stderr, "using MBR partition %ld: "
			    "type %d (0x%02x) offset %d (0x%x)\n",
d247 1
a247 2
			    dp->dp_typ, dp->dp_typ,
			    dp->dp_start, dp->dp_start);
d251 2
a252 2
			fprintf(stderr, "extended partition %ld: "
			    "type %d (0x%02x) offset %d (0x%x)\n",
d254 1
a254 2
			    dp->dp_typ, dp->dp_typ,
			    dp->dp_start, dp->dp_start);
a328 5

	if (verbose) {
		fprintf(stderr, "%s: entry point %#x\n", fname, eh.e_entry);
		fprintf(stderr, "proto bootblock size %ld\n", *size);
	}
@


1.9
log
@allow to install and boot the OpenBSD A6 partition and disklabel in an
extended DOS partition.  the concept of extended partitions is very
simple, it is just another mbr at the partition offset (well, the
standard "EBR" is a linked list with a few limitations, but this diff
works with both variants).

this diff has been in the snapshots for a while.

with input from weingart@@ and krw@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.8 2008/01/24 12:09:53 krw Exp $	*/
d234 1
a234 1
	if (lseek(devfd, mbroff, SEEK_SET) < 0 ||
a244 1
		startoff = (off_t)dp->dp_start * dl->d_secsize;
d251 1
a251 1
			break;
d259 1
d262 1
a262 1
				return (dp->dp_start + start);
a264 3
	/* Don't check for old part number, that is ;-p */
	if (dp >= &mbr.dmbr_parts[NDOSPART])
		return (-1);
d266 1
a266 1
	return (dp->dp_start);
@


1.8
log
@"read(..., ..., sizeof Y) < sizeof Y" is a dangerous idiom because it
does an unsigned comparison and read() can return -1. Use '!=' instead
of '<' since read() can't return more than 'sizeof Y'. Not perfect
(that would require a separate test for -1) but a very common usage.

ok toby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.7 2008/01/05 19:50:48 otto Exp $	*/
d101 1
a123 2
	struct	dos_mbr mbr;
	struct	dos_partition *dp;
d125 2
a203 7
		if (lseek(devfd, (off_t)DOSBBSECTOR, SEEK_SET) < 0 ||
		    read(devfd, &mbr, sizeof(mbr)) != sizeof(mbr))
			err(4, "can't read master boot record");

		if (mbr.dmbr_sign != DOSMBR_SIGNATURE)
			errx(1, "broken MBR");

d205 4
a208 15
		for (dp = mbr.dmbr_parts; dp < &mbr.dmbr_parts[NDOSPART];
		    dp++) {
			if (dp->dp_size && dp->dp_typ == DOSPTYP_OPENBSD) {
				startoff = (off_t)dp->dp_start * dl.d_secsize;
				fprintf(stderr, "using MBR partition %ld: "
				    "type %d (0x%02x) offset %d (0x%x)\n",
				    (long)(dp - mbr.dmbr_parts),
				    dp->dp_typ, dp->dp_typ,
				    dp->dp_start, dp->dp_start);
				break;
			}
		}
		/* Don't check for old part number, that is ;-p */
		if (dp >= &mbr.dmbr_parts[NDOSPART])
			errx(1, "no OpenBSD partition");
d220 50
@


1.7
log
@handle 64-bit blkno in format string
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.6 2006/02/14 17:16:19 aaron Exp $	*/
d204 1
a204 1
		    read(devfd, &mbr, sizeof(mbr)) < sizeof(mbr))
@


1.6
log
@Fix botched format string specifiers.  From adobriyan at gmail.com.
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.5 2004/07/15 21:44:16 tom Exp $	*/
d446 1
a446 1
		    "inode block %u, offset %u\n",
@


1.5
log
@"mib[4] is too much and mib[3] would be enough" (left over from when
another sysctl() - which did require mib[4] - was removed).

From Andrey Matveev - andrushock (at) vniigim (dot) ru - via mickey@@.

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.4 2004/05/05 04:33:56 mickey Exp $	*/
d165 1
a165 1
		err(1, "bad disklabel magic=%0x8x", dl.d_magic);
@


1.4
log
@errx shall be used here
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.3 2004/02/22 09:03:05 tom Exp $	*/
d341 1
a341 1
	int		mib[4];
@


1.3
log
@Remove #if 0'd code.

requested by weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.2 2004/02/21 00:48:59 tom Exp $	*/
d177 1
a177 1
		err(1, "proto %s bad size=%ld", proto, protosize);
@


1.2
log
@Tidy up installboot -v output.

requested by and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.1 2004/02/03 12:09:47 mickey Exp $	*/
a536 6

#if 0
		if (verbose)
			fprintf(stderr, "%s = %u\n",
			    sym->sym_name, sym->sym_value);
#endif
@


1.1
log
@das boot; das cloned das from das i386
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.43 2004/01/26 23:21:49 tom Exp $	*/
a425 3
	if (verbose)
		fprintf(stderr, "%s is %d blocks x %d bytes\n",
		    boot, ndb, fs->fs_bsize);
d442 10
d538 1
d542 1
@


1.1.2.1
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d177 1
a177 1
		errx(1, "proto %s bad size=%ld", proto, protosize);
d426 3
a444 10
	if (verbose) {
		fprintf(stderr, "%s is %d blocks x %d bytes\n",
		    boot, ndb, fs->fs_bsize);
		fprintf(stderr, "fs block shift %u; part offset %u; "
		    "inode block %u, offset %u\n",
		    fs->fs_fsbtodb, pl->p_offset,
		    ino_to_fsba(fs, statbuf.st_ino),
		    (unsigned int)((((char *)ap) - buf) + INODEOFF));
	}

d530 4
@


