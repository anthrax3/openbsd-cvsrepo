head	1.44;
access;
symbols
	OPENBSD_6_1_BASE:1.44
	OPENBSD_6_0:1.43.0.2
	OPENBSD_6_0_BASE:1.43
	OPENBSD_5_9:1.42.0.4
	OPENBSD_5_9_BASE:1.42
	OPENBSD_5_8:1.42.0.6
	OPENBSD_5_8_BASE:1.42
	OPENBSD_5_7:1.42.0.2
	OPENBSD_5_7_BASE:1.42
	OPENBSD_5_6:1.40.0.4
	OPENBSD_5_6_BASE:1.40
	OPENBSD_5_5:1.29.0.4
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.28.0.2
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.27.0.2
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.26.0.6
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.4
	OPENBSD_5_0:1.26.0.2
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.23.0.4
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.2
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.17.0.6
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.8
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.4
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.2
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.13.0.4
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.2
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.9.0.2
	OPENBSD_4_1_BASE:1.9
	LANDISK_20061006:1.1.1.1
	miod:1.1.1;
locks; strict;
comment	@ * @;


1.44
date	2016.10.09.11.25.39;	author tom;	state Exp;
branches;
next	1.43;
commitid	DfYvEDcFmu1LY9q1;

1.43
date	2016.03.05.17.16.33;	author tobiasu;	state Exp;
branches;
next	1.42;
commitid	tnf9BWAlxRCsKh8M;

1.42
date	2014.12.10.15.29.53;	author mikeb;	state Exp;
branches;
next	1.41;
commitid	qHQiR2HLROzvZr7B;

1.41
date	2014.09.20.09.28.24;	author kettenis;	state Exp;
branches;
next	1.40;
commitid	IFRB8AkvBMXMTAKW;

1.40
date	2014.07.21.17.25.47;	author uebayasi;	state Exp;
branches;
next	1.39;
commitid	7QO4UJr3EKVAMc8t;

1.39
date	2014.07.14.08.36.31;	author uebayasi;	state Exp;
branches;
next	1.38;
commitid	q7wBn7ORojhipUMo;

1.38
date	2014.07.13.22.53.39;	author uebayasi;	state Exp;
branches;
next	1.37;
commitid	wsdp3qtXGjMj98oD;

1.37
date	2014.07.13.22.13.06;	author uebayasi;	state Exp;
branches;
next	1.36;
commitid	qYPOd6Qi4aRBKldK;

1.36
date	2014.07.10.21.46.03;	author mpi;	state Exp;
branches;
next	1.35;
commitid	iYq3Z1ZWDKR3sS9G;

1.35
date	2014.07.10.13.34.32;	author uebayasi;	state Exp;
branches;
next	1.34;
commitid	xpsLTYRIkonFtkr1;

1.34
date	2014.07.10.12.13.49;	author uebayasi;	state Exp;
branches;
next	1.33;
commitid	aofvn6ceiucgjg4N;

1.33
date	2014.05.31.15.49.28;	author mpi;	state Exp;
branches;
next	1.32;
commitid	eA4Y0YE1IUzj6hpW;

1.32
date	2014.05.30.13.46.16;	author mpi;	state Exp;
branches;
next	1.31;

1.31
date	2014.04.14.07.36.12;	author mpi;	state Exp;
branches;
next	1.30;

1.30
date	2014.03.13.03.52.55;	author dlg;	state Exp;
branches;
next	1.29;

1.29
date	2013.09.28.12.40.30;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2013.06.11.16.42.09;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2012.10.08.21.47.48;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2011.06.26.22.39.59;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2011.06.24.19.47.48;	author naddy;	state Exp;
branches;
next	1.24;

1.24
date	2011.05.30.22.25.21;	author oga;	state Exp;
branches;
next	1.23;

1.23
date	2010.06.27.12.41.23;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2010.06.27.03.03.48;	author thib;	state Exp;
branches;
next	1.21;

1.21
date	2010.06.26.23.24.43;	author guenther;	state Exp;
branches;
next	1.20;

1.20
date	2010.06.10.17.54.13;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2010.04.21.03.03.26;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2010.04.17.18.30.41;	author jasper;	state Exp;
branches;
next	1.17;

1.17
date	2008.06.26.05.42.11;	author ray;	state Exp;
branches;
next	1.16;

1.16
date	2008.06.08.20.57.18;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2008.04.09.16.58.10;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2008.03.23.17.05.41;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2007.06.06.17.15.12;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2007.04.29.18.18.03;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2007.04.29.17.53.37;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2007.03.13.19.30.36;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2007.03.03.21.37.27;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2007.02.06.23.13.37;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2006.11.09.00.12.12;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2006.11.06.19.12.13;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2006.10.25.03.59.59;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2006.10.19.22.15.02;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2006.10.16.21.21.00;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.06.21.48.50;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2006.10.06.21.16.15;	author miod;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.10.06.21.16.15;	author miod;	state Exp;
branches;
next	;


desc
@@


1.44
log
@Apply consistency to forever loops with continue and NOTREACHED

Same thought from kettenis@@, ok krw@@ phessler@@ millert@@
@
text
@/*	$OpenBSD: machdep.c,v 1.43 2016/03/05 17:16:33 tobiasu Exp $	*/
/*	$NetBSD: machdep.c,v 1.1 2006/09/01 21:26:18 uwe Exp $	*/

/*-
 * Copyright (c) 1996, 1997, 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Charles M. Hannum and by Jason R. Thorpe of the Numerical Aerospace
 * Simulation Facility, NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*-
 * Copyright (c) 1982, 1987, 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * William Jolitz.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)machdep.c	7.4 (Berkeley) 6/3/91
 */

#include "ksyms.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/mount.h>
#include <sys/reboot.h>
#include <sys/sysctl.h>
#include <sys/exec.h>
#include <sys/core.h>
#include <sys/kcore.h>

#include <net/if.h>

#include <uvm/uvm_extern.h>

#include <dev/cons.h>

#include <sh/bscreg.h>
#include <sh/cpgreg.h>
#include <sh/trap.h>

#include <sh/cache.h>
#include <sh/cache_sh4.h>
#include <sh/mmu_sh4.h>

#include <machine/cpu.h>
#include <machine/kcore.h>
#include <machine/pcb.h>

#include <landisk/landisk/landiskreg.h>

#ifdef DDB
#include <machine/db_machdep.h>
#include <ddb/db_extern.h>
#include <ddb/db_interface.h>
#endif

/* the following is used externally (sysctl_hw) */
char machine[] = MACHINE;		/* landisk */

__dead void landisk_startup(int, char *);
__dead void main(void);
void	cpu_init_kcore_hdr(void);
void	blink_led(void *);

int	led_blink;

extern u_int32_t getramsize(void);

struct uvm_constraint_range  dma_constraint = { 0x0, (paddr_t)-1 };
struct uvm_constraint_range *uvm_md_constraints[] = { NULL };

/*
 * safepri is a safe priority for sleep to set for a spin-wait
 * during autoconfiguration or after a panic.
 */
int   safepri = 0;

void
cpu_startup(void)
{
	extern char cpu_model[120];

	strlcpy(cpu_model, "SH4 SH7751R", sizeof cpu_model);

        sh_startup();
}

vaddr_t kernend;	/* used by /dev/mem too */
char *esym;

__dead void
landisk_startup(int howto, char *_esym)
{
	u_int32_t ramsize;

	/* Start to determine heap area */
	esym = _esym;
	kernend = (vaddr_t)round_page((vaddr_t)esym);

	boothowto = howto;

	ramsize = getramsize();

	/* Initialize CPU ops. */
	sh_cpu_init(CPU_ARCH_SH4, CPU_PRODUCT_7751R);	

	/* Initialize early console */
	consinit();

	/* Load memory to UVM */
	if (ramsize == 0 || ramsize > 512 * 1024 * 1024)
		ramsize = IOM_RAM_SIZE;
	physmem = atop(ramsize);
	kernend = atop(round_page(SH3_P1SEG_TO_PHYS(kernend)));
	uvm_page_physload(atop(IOM_RAM_BEGIN),
	    atop(IOM_RAM_BEGIN + ramsize), kernend,
	    atop(IOM_RAM_BEGIN + ramsize), 0);
	cpu_init_kcore_hdr();	/* need to be done before pmap_bootstrap */

	/* Initialize proc0 u-area */
	sh_proc0_init();

	/* Initialize pmap and start to address translation */
	pmap_bootstrap();

#if defined(DDB)
	db_machine_init();
	ddb_init();
	if (boothowto & RB_KDB) {
		Debugger();
	}
#endif

	/* Jump to main */
	__asm volatile(
		"jmp	@@%0\n\t"
		" mov	%1, sp"
		:: "r" (main), "r" (proc0.p_md.md_pcb->pcb_sf.sf_r7_bank));
	for (;;)
		continue;
	/* NOTREACHED */
}

__dead void
boot(int howto)
{
	if (cold) {
		if ((howto & RB_USERREQ) == 0)
			howto |= RB_HALT;
		goto haltsys;
	}

	boothowto = howto;
	if ((howto & RB_NOSYNC) == 0) {
		vfs_shutdown();

		if ((howto & RB_TIMEBAD) == 0) {
			resettodr();
		} else {
			printf("WARNING: not updating battery clock\n");
		}
	}
	if_downall();

	uvm_shutdown();
	splhigh();
	cold = 1;

	if ((howto & RB_DUMP) != 0)
		dumpsys();

haltsys:
	config_suspend_all(DVACT_POWERDOWN);

	if ((howto & RB_POWERDOWN) != 0) {
		_reg_write_1(LANDISK_PWRMNG, PWRMNG_POWEROFF);
		delay(1 * 1000 * 1000);
		printf("POWEROFF FAILED!\n");
		howto |= RB_HALT;
	}

	if ((howto & RB_HALT) != 0) {
		printf("\n");
		printf("The operating system has halted.\n");
		printf("Please press any key to reboot.\n\n");
		cnpollc(1);
		cngetc();
		cnpollc(0);
	}

	printf("rebooting...\n");
	machine_reset();

	for (;;)
		continue;
	/* NOTREACHED */
}

void
machine_reset(void)
{
	_cpu_exception_suspend();
	_reg_write_4(SH_(EXPEVT), EXPEVT_RESET_MANUAL);
	(void)*(volatile uint32_t *)0x80000001;	/* CPU shutdown */

	/*NOTREACHED*/
	for (;;) {
		continue;
	}
}

#if !defined(DONT_INIT_BSC)
/*
 * InitializeBsc
 * : BSC(Bus State Controller)
 */
void InitializeBsc(void);

void
InitializeBsc(void)
{

	/*
	 * Drive RAS,CAS in stand by mode and bus release mode
	 * Area0 = Normal memory, Area5,6=Normal(no burst)
	 * Area2 = Normal memory, Area3 = SDRAM, Area5 = Normal memory
	 * Area4 = Normal Memory
	 * Area6 = Normal memory
	 */
	_reg_write_4(SH4_BCR1, BSC_BCR1_VAL);

	/*
	 * Bus Width
	 * Area4: Bus width = 16bit
	 * Area6,5 = 16bit
	 * Area1 = 8bit
	 * Area2,3: Bus width = 32bit
	 */
	_reg_write_2(SH4_BCR2, BSC_BCR2_VAL);

#if defined(SH4) && defined(SH7751R)
	if (cpu_product == CPU_PRODUCT_7751R) {
#ifdef BSC_BCR3_VAL
		_reg_write_2(SH4_BCR3, BSC_BCR3_VAL);
#endif
#ifdef BSC_BCR4_VAL
		_reg_write_4(SH4_BCR4, BSC_BCR4_VAL);
#endif
	}
#endif	/* SH4 && SH7751R */

	/*
	 * Idle cycle number in transition area and read to write
	 * Area6 = 3, Area5 = 3, Area4 = 3, Area3 = 3, Area2 = 3
	 * Area1 = 3, Area0 = 3
	 */
	_reg_write_4(SH4_WCR1, BSC_WCR1_VAL);

	/*
	 * Wait cycle
	 * Area 6 = 6
	 * Area 5 = 2
	 * Area 4 = 10
	 * Area 3 = 3
	 * Area 2,1 = 3
	 * Area 0 = 6
	 */
	_reg_write_4(SH4_WCR2, BSC_WCR2_VAL);

#ifdef BSC_WCR3_VAL
	_reg_write_4(SH4_WCR3, BSC_WCR3_VAL);
#endif

	/*
	 * RAS pre-charge = 2cycle, RAS-CAS delay = 3 cycle,
	 * write pre-charge=1cycle
	 * CAS before RAS refresh RAS assert time = 3 cycle
	 * Disable burst, Bus size=32bit, Column Address=10bit, Refresh ON
	 * CAS before RAS refresh ON, EDO DRAM
	 */
	_reg_write_4(SH4_MCR, BSC_MCR_VAL);

#ifdef BSC_SDMR2_VAL
	_reg_write_1(BSC_SDMR2_VAL, 0);
#endif

#ifdef BSC_SDMR3_VAL
	_reg_write_1(BSC_SDMR3_VAL, 0);
#endif /* BSC_SDMR3_VAL */

	/*
	 * PCMCIA Control Register
	 * OE/WE assert delay 3.5 cycle
	 * OE/WE negate-address delay 3.5 cycle
	 */
#ifdef BSC_PCR_VAL
	_reg_write_2(SH4_PCR, BSC_PCR_VAL);
#endif

	/*
	 * Refresh Timer Control/Status Register
	 * Disable interrupt by CMF, closk 1/16, Disable OVF interrupt
	 * Count Limit = 1024
	 * In following statement, the reason why high byte = 0xa5(a4 in RFCR)
	 * is the rule of SH3 in writing these register.
	 */
	_reg_write_2(SH4_RTCSR, BSC_RTCSR_VAL);

	/*
	 * Refresh Timer Counter
	 * Initialize to 0
	 */
#ifdef BSC_RTCNT_VAL
	_reg_write_2(SH4_RTCNT, BSC_RTCNT_VAL);
#endif

	/* set Refresh Time Constant Register */
	_reg_write_2(SH4_RTCOR, BSC_RTCOR_VAL);

	/* init Refresh Count Register */
#ifdef BSC_RFCR_VAL
	_reg_write_2(SH4_RFCR, BSC_RFCR_VAL);
#endif

	/*
	 * Clock Pulse Generator
	 */
	/* Set Clock mode (make internal clock double speed) */
	_reg_write_2(SH4_FRQCR, FRQCR_VAL);
}
#endif /* !DONT_INIT_BSC */

/*
 * Dump the machine-dependent dump header.
 */
u_int
cpu_dump(int (*dump)(dev_t, daddr_t, caddr_t, size_t), daddr_t *blknop)
{
	extern cpu_kcore_hdr_t cpu_kcore_hdr;
	char buf[dbtob(1)];
	cpu_kcore_hdr_t *h;
	kcore_seg_t *kseg;
	int rc;

#ifdef DIAGNOSTIC
	if (cpu_dumpsize() > btodb(sizeof buf)) {
		printf("buffer too small in cpu_dump, ");
		return (EINVAL);	/* "aborted" */
	}
#endif

	bzero(buf, sizeof buf);
	kseg = (kcore_seg_t *)buf;
	h = (cpu_kcore_hdr_t *)(buf + ALIGN(sizeof(kcore_seg_t)));

	/* Create the segment header */
	CORE_SETMAGIC(*kseg, KCORE_MAGIC, MID_MACHINE, CORE_CPU);
	kseg->c_size = dbtob(1) - ALIGN(sizeof(kcore_seg_t));

	bcopy(&cpu_kcore_hdr, h, sizeof(*h));
	/* We can now fill kptp in the header... */
	h->kcore_kptp = SH3_P1SEG_TO_PHYS((vaddr_t)pmap_kernel()->pm_ptp);

	rc = (*dump)(dumpdev, *blknop, buf, sizeof buf);
	*blknop += btodb(sizeof buf);
	return (rc);
}

/*
 * Return the size of the machine-dependent dump header, in disk blocks.
 */
u_int
cpu_dumpsize(void)
{
	u_int size;

	size = ALIGN(sizeof(kcore_seg_t)) + ALIGN(sizeof(cpu_kcore_hdr_t));
	return (btodb(roundup(size, dbtob(1))));
}

/*
 * Fill the machine-dependent dump header.
 */
void
cpu_init_kcore_hdr(void)
{
	extern cpu_kcore_hdr_t cpu_kcore_hdr;
	cpu_kcore_hdr_t *h = &cpu_kcore_hdr;
	phys_ram_seg_t *seg = cpu_kcore_hdr.kcore_segs;
	struct vm_physseg *physseg = vm_physmem;
	u_int i;

	bzero(h, sizeof(*h));

	h->kcore_nsegs = min(NPHYS_RAM_SEGS, (u_int)vm_nphysseg);
	for (i = h->kcore_nsegs; i != 0; i--) {
		seg->start = ptoa(physseg->start);
		seg->size = (psize_t)ptoa(physseg->end - physseg->start);
		seg++;
		physseg++;
	}
}

int
cpu_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen, struct proc *p)
{
	int oldval, ret;

	/* all sysctl names at this level are terminal */
	if (namelen != 1)
		return (ENOTDIR);		/* overloaded */

	switch (name[0]) {
	case CPU_CONSDEV: {
		dev_t consdev;
		if (cn_tab != NULL)
			consdev = cn_tab->cn_dev;
		else
			consdev = NODEV;
		return (sysctl_rdstruct(oldp, oldlenp, newp, &consdev,
		    sizeof consdev));
	}

	case CPU_LED_BLINK:
		oldval = led_blink;
		ret = sysctl_int(oldp, oldlenp, newp, newlen, &led_blink);
		if (oldval != led_blink)
			blink_led(NULL);
		return (ret);

	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
}

void
blink_led(void *whatever)
{
	static struct timeout blink_tmo;
	u_int8_t ledctrl;

	if (led_blink == 0) {
		_reg_write_1(LANDISK_LEDCTRL,
		    LED_POWER_CHANGE | LED_POWER_VALUE);
		return;
	}

	ledctrl = (u_int8_t)_reg_read_1(LANDISK_LEDCTRL) & LED_POWER_VALUE;
	ledctrl ^= (LED_POWER_CHANGE | LED_POWER_VALUE);
	_reg_write_1(LANDISK_LEDCTRL, ledctrl);

	timeout_set(&blink_tmo, blink_led, NULL);
	timeout_add(&blink_tmo,
	    ((averunnable.ldavg[0] + FSCALE) * hz) >> FSHIFT);
}
@


1.43
log
@Sync no-argument function declaration and definition by adding (void).
Covers all of landisk/sh, per naddy's suggestion.

ok on previous diff deraadt@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.42 2014/12/10 15:29:53 mikeb Exp $	*/
d189 2
a191 1
	for (;;) ;
d244 2
a246 3
	for (;;) {
		continue;
	}
@


1.42
log
@retire shutdown hooks; ok deraadt, krw
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.41 2014/09/20 09:28:24 kettenis Exp $	*/
d423 1
a423 1
cpu_dumpsize()
d435 1
a435 1
cpu_init_kcore_hdr()
@


1.41
log
@Use config_suspend_all(9).

ok mpi@@, uebayasi@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.40 2014/07/21 17:25:47 uebayasi Exp $	*/
a221 1
	doshutdownhooks();
@


1.40
log
@boot(9): Reduce annoying style diffs

- Always use either: ((x & RB_XXX) != 0) or ((x & RB_XXX) == 0) in boolean
  context (mostly if (x), or x ? y : z)
  - prom_halt() in alpha is confirmed to take int as boolean

Converted by coccinelle.  No functional change intended.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a195 2
	struct device *mainbus;

d223 1
a223 3
	mainbus = device_mainbus();
	if (mainbus != NULL)
		config_suspend(mainbus, DVACT_POWERDOWN);
@


1.39
log
@More comment cleanup in boot().
@
text
@d220 1
a220 1
	if (howto & RB_DUMP)
d229 1
a229 1
	if ((howto & RB_POWERDOWN) == RB_POWERDOWN) {
d236 1
a236 1
	if (howto & RB_HALT) {
@


1.38
log
@boot(9): Cosmetic changes to improve diff'ability.
@
text
@a219 1
	/* Do a dump if requested. */
@


1.37
log
@Cosmetic changes to reduce diffs.
@
text
@d249 1
a249 1
	/*NOTREACHED*/
@


1.36
log
@Set cold to 1 before executing the DVACT_POWERDOWN handlers when halting or
rebooting a machine, like it is done in the hibernate case.

At least some USB host controller drivers rely on this to busy way instead
of sleeping.  Avoid a panic on macppc with an uhci(4) cardbus plugged in.

ok deraadt@@, uebayashi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.35 2014/07/10 13:34:32 uebayasi Exp $	*/
d208 1
a208 1
		if ((howto & RB_TIMEBAD) == 0)
d210 1
a210 1
		else
d212 1
d217 1
a217 1
	splhigh();		/* Disable interrupts. */
@


1.35
log
@boot(): Remove comments about RB_TIMEBAD to reduce diffs

RB_TIMEBAD is documented well enough that the comment is not needed.  sparc64
does slightly different and its comment is left with XXX.

OK deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d217 1
@


1.34
log
@boot(): Unify declarations

OK deraadt@@
@
text
@d207 1
a207 4
		/*
		 * If we've been adjusting the clock, the todr
		 * will be out of synch; adjust it now.
		 */
@


1.33
log
@Revert previous diff setting cold to 1 on shutdown because it breaks machine
with softraid(4) disks.

softraid(4) is the last real consumer of the doshutdownhooks(9) API and it is
not trivial to convert its hook to a DVACT_POWERDOWN handler since the latter
does not allow to sleep.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.32 2014/05/30 13:46:16 mpi Exp $	*/
d193 1
a193 1
void
@


1.32
log
@Set cold to 1 before executing the DVACT_POWERDOWN handlers when halting or
rebooting a machine, like it is done in the hibernate case.

At least some USB host controller drivers rely on this to busy way instead
of sleeping.  Avoid a panic on macppc with an uhci(4) cardbus plugged in.

ok deraadt@@, uebayashi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.31 2014/04/14 07:36:12 mpi Exp $	*/
a219 1
	cold = 1;
@


1.31
log
@Fewer <uvm/uvm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.30 2014/03/13 03:52:55 dlg Exp $	*/
d220 1
@


1.30
log
@get rid of the assumption that the head of the alldevs list is the
"mainbus" device. this breaks when mpath is enabled because it
attaches before mainbus and therefore takes the head position.

have autoconf provide device_mainbus() which looks up mainbus_cd,
and use that instead.

discussed with deraadt who just wants mpath stuff to move forward
despite there being many ways to shine this particular turd.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.29 2013/09/28 12:40:30 miod Exp $	*/
d82 2
a83 1
#include <uvm/uvm.h>
@


1.29
log
@In boot(), do not iterate over alldevs if it's empty (i.e. halting from ddb
with ddb entered early with boot -d or from UKC).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.28 2013/06/11 16:42:09 deraadt Exp $	*/
d195 1
d226 3
a228 2
	if (!TAILQ_EMPTY(&alldevs))
		config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.28
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.27 2012/10/08 21:47:48 deraadt Exp $	*/
d225 2
a226 1
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.27
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.26 2011/06/26 22:39:59 deraadt Exp $	*/
d390 1
a390 1
cpu_dump(int (*dump)(dev_t, daddr64_t, caddr_t, size_t), daddr64_t *blknop)
@


1.26
log
@if_downall() cannot be done MI in sys_reboot() because vfs_shutdown()
might need network (ie. nfs).  Move the call to the MD boot() routines.
This cause for boot hangs diagnosed by kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.25 2011/06/24 19:47:48 naddy Exp $	*/
d225 1
@


1.25
log
@machdep.kbdreset enables a shutdown by Ctrl-Alt-Del on amd64 and
i386.  Stop abusing it on other archs for controling a shutdown by
pressing the soft power button:

* Add a MI sysctl hw.allowpowerdown; if set to 1 (the default) it
  allows a power button shutdown.
* Make acpi(4)/acpibtn(4) honor hw.allowpowerdown.
* Switch the various power button intercepts on landisk, sgi, sparc64
  and zaurus over to hw.allowpowerdown.
* Garbage collect the machdep.kbdreset sysctl on all archs other than
  amd64 and i386.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.24 2011/05/30 22:25:21 oga Exp $	*/
d81 1
d214 1
@


1.24
log
@Remove the freelist member from vm_physseg

The new world order of pmemrange makes this data completely redundant
(being dealt with by the pmemrange constraints instead). Remove all code
that messes with the freelist.

While touching every caller of uvm_page_physload() anyway, add the flags
argument to all callers (all but one is 0 and that one already used
PHYSLOAD_DEVICE) and remove the macro magic to allow callers to continue
without it.

Should shrink the code a bit, as well.

matthew@@ pointed out some mistakes i'd made.
``freelist death, I like. Ok.' ariane@@
`I agree with the general direction, go ahead and i'll fix any fallout
shortly'' miod@@ (68k 88k and vax i could not check would build)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.23 2010/06/27 12:41:23 miod Exp $	*/
a112 1
int	kbd_reset;
a473 5

	case CPU_KBDRESET:
		if (securelevel > 0)
			return (sysctl_rdint(oldp, oldlenp, newp, kbd_reset));
		return (sysctl_int(oldp, oldlenp, newp, newlen, &kbd_reset));
@


1.23
log
@Bunch of include adjustements to restore compilability.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.22 2010/06/27 03:03:48 thib Exp $	*/
d166 1
a166 1
	    atop(IOM_RAM_BEGIN + ramsize), VM_FREELIST_DEFAULT);
@


1.22
log
@uvm constraints. Add two mandatory MD symbols, uvm_md_constraints
which contains the constraints for DMA/memory allocation for each
architecture, and dma_constraints which contains the range of addresses
that are dma accessable by the system.

This is based on ariane@@'s physcontig diff, with lots of bugfixes and
additions the following additions by my self:

Introduce a new function pool_set_constraints() which sets the address
range for which we allocate pages for the pool from, this is now used
for the mbuf/mbuf cluster pools to keep them dma accessible.

The !direct archs no longer stuff pages into the kernel object in
uvm_km_getpage_pla but rather do a pmap_extract() in uvm_km_putpages.

Tested heavily by my self on i386, amd64 and sparc64. Some tests on
alpha and SGI.

"commit it" beck, art, oga, deraadt
"i like the diff" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.20 2010/06/10 17:54:13 deraadt Exp $	*/
d81 1
a81 1
#include <uvm/uvm_extern.h>
@


1.21
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d118 3
@


1.20
log
@Declare safepri at the MD level on each platform, so that the kern_synch.c
does not have to deal with it as a common.  Some platforms may be missed
by this commit... if you spot one, fix it the same way.
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.19 2010/04/21 03:03:26 deraadt Exp $	*/
a73 1
#include <sys/user.h>
d95 1
@


1.19
log
@more cleanup to cope with the change that tries to make proc.h not act
like it is everything.h
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.18 2010/04/17 18:30:41 jasper Exp $	*/
d117 6
@


1.18
log
@- correctly set cpu_model: instead of a vendor + model, set the cpu type

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.17 2008/06/26 05:42:11 ray Exp $	*/
d73 1
@


1.17
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.16 2008/06/08 20:57:18 miod Exp $	*/
d122 1
a122 2
	/* XXX: show model (LANDISK/USL-5P) */
	strlcpy(cpu_model, "I-O DATA USL-5P", sizeof cpu_model);
@


1.16
log
@Make sure to cnpollc(1)/cnpollc(0) around cngetc() or getsn() calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.15 2008/04/09 16:58:10 deraadt Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.15
log
@Add new stub uvm_shutdown() and call it from the right place in MD boot()
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.15 2008/04/09 16:50:28 deraadt Exp $	*/
d234 1
d236 1
@


1.14
log
@setroot() is supposed to be safe in all cases, so kill the special cases
for RB_DFLTROOT; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.13 2007/06/06 17:15:12 deraadt Exp $	*/
d213 2
a214 2
	/* Disable interrupts. */
	splhigh();
@


1.13
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.12 2007/04/29 18:18:03 miod Exp $	*/
a171 4

#ifdef RAMDISK_HOOKS
	boothowto |= RB_DFLTROOT;   
#endif /* RAMDISK_HOOKS */
@


1.12
log
@Blink 8x slower, so that this fits better with Kraftwerk's ``Elektro
Kardiogramm'' in the background.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.11 2007/04/29 17:53:37 miod Exp $	*/
d388 1
a388 1
cpu_dump(int (*dump)(dev_t, daddr_t, caddr_t, size_t), daddr_t *blknop)
@


1.11
log
@machdep.led_blink sysctl for landisk, also move cpu_sysctl() code and related
variables from arch/sh/ to arch/landisk/. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.10 2007/03/13 19:30:36 miod Exp $	*/
d512 1
a512 1
	    ((averunnable.ldavg[0] + FSCALE) * hz) >> (FSHIFT + 3));
@


1.10
log
@Move UKC later in the boot process, so that it can use malloc().
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.9 2007/03/03 21:37:27 miod Exp $	*/
d117 4
d453 60
@


1.9
log
@Kernel crash dumps and associated libkvm bits for landisk.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.8 2007/02/06 23:13:37 miod Exp $	*/
a179 7
	if (boothowto & RB_CONFIG) {
#ifdef BOOT_CONFIG
		user_config();
#else
		printf("kernel does not support -c; continuing..\n");
#endif 
	}
@


1.8
log
@Get memory size from SH-IPL+g whenever possible, before relying upon the
hardcoded 64MB. No functional change since we have not encountered non-64MB
systems yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.7 2006/11/09 00:12:12 deraadt Exp $	*/
d84 3
d101 1
d116 1
d161 1
d202 2
a203 1
		howto |= RB_HALT;
d214 4
a217 1
		resettodr();
a219 3
	/* wait 1s */
	delay(1 * 1000 * 1000);

d224 1
a224 1
	if ((howto & (RB_DUMP | RB_HALT)) == RB_DUMP) {
a225 1
	}
d234 1
d386 71
@


1.7
log
@no newline at end of cpu_model
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.6 2006/11/06 19:12:13 miod Exp $	*/
d113 2
d132 2
d140 2
d149 3
a151 1
	physmem = atop(IOM_RAM_SIZE);
d154 2
a155 2
	    atop(IOM_RAM_BEGIN + IOM_RAM_SIZE), kernend,
	    atop(IOM_RAM_BEGIN + IOM_RAM_SIZE), VM_FREELIST_DEFAULT);
@


1.6
log
@No bootinfo stuff. We'll use something different to pass device information
from the boot blocks to the kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.5 2006/10/25 03:59:59 drahn Exp $	*/
d119 1
a119 1
	strlcpy(cpu_model, "I-O DATA USL-5P\n", sizeof cpu_model);
@


1.5
log
@Add ramdisk hooks portion.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.4 2006/10/19 22:15:02 drahn Exp $	*/
a96 1
#include <machine/bootinfo.h>
d110 1
a110 4
struct bootinfo _bootinfo;
struct bootinfo *bootinfo;

__dead void landisk_startup(int, char *, void *);
d128 1
a128 1
landisk_startup(int howto, char *_esym, void *bi)
a133 5
	/* Copy bootinfo */
	if (bi) {
		bootinfo = &_bootinfo;
		memcpy(bootinfo, bi, sizeof(struct bootinfo));
	}
a180 15
}

void *
lookup_bootinfo(int type)
{
	struct btinfo_common *help;
	int n = bootinfo->nentries;

	help = (struct btinfo_common *)(bootinfo->info);
	while (n--) {
		if (help->type == type)
			return (help);
		help = (struct btinfo_common *)((char *)help + help->len);
	}
	return (NULL);
@


1.4
log
@support boot -c
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.3 2006/10/16 21:21:00 drahn Exp $	*/
d163 4
@


1.3
log
@Do not zero bss in the kernel, the bootloader does this for us and it causes
a problem loading the kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.2 2006/10/06 21:48:50 mickey Exp $	*/
d171 7
@


1.2
log
@w/ help of netbsd srcs and some mother unzel made it lift off
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a133 5
	extern char edata[], end[];

	/* Clear bss */
	bzero(edata, end - edata);

@


1.1
log
@Initial revision
@
text
@d114 1
a114 1
__dead void landisk_startup(int, void *);
d129 1
d131 2
a132 2
void
landisk_startup(int howto, void *bi)
d137 1
a137 1
	memset(edata, 0, end - edata);
a138 1
/* XXX symbols */
d140 2
a141 1
	kernend = (vaddr_t)round_page((vaddr_t)end);
d144 4
a147 2
	bootinfo = &_bootinfo;
	memcpy(bootinfo, bi, sizeof(struct bootinfo));
d179 2
a180 2
		"jmp	@@%0;"
		"mov	%1, sp"
@


1.1.1.1
log
@Incomplete bits for an OpenBSD/landisk port to the I/O DATA USL-5P appliances,
mickey@@ has the other part.
@
text
@@
