head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.6
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.8
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.7.0.14
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.10
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.8
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.6
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.4
	OPENBSD_5_0:1.7.0.2
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.5.0.14
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.10
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.12
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.8
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.6
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.4
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.2
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.4.0.2
	OPENBSD_4_1_BASE:1.4
	LANDISK_20061006:1.1.1.1
	miod:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.08.29.23.59.19;	author deraadt;	state Exp;
branches;
next	1.9;
commitid	LKSgGhcKR3gVD4vW;

1.9
date	2014.07.12.18.44.42;	author tedu;	state Exp;
branches;
next	1.8;
commitid	uKVPYMN2MLxdZxzH;

1.8
date	2014.03.29.18.09.29;	author guenther;	state Exp;
branches;
next	1.7;

1.7
date	2011.04.15.20.40.07;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2010.09.20.06.33.47;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	2007.04.09.13.23.25;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2006.11.21.21.01.52;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2006.11.21.21.00.57;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.08.21.06.57;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2006.10.06.21.16.15;	author miod;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.10.06.21.16.15;	author miod;	state Exp;
branches;
next	;


desc
@@


1.10
log
@correct size for free()
@
text
@/*	$OpenBSD: intr.c,v 1.9 2014/07/12 18:44:42 tedu Exp $	*/
/*	$NetBSD: intr.c,v 1.1 2006/09/01 21:26:18 uwe Exp $	*/

/*-
 * Copyright (c) 2005 NONAKA Kimihiro
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/evcount.h>

#include <sh/trap.h>

#include <machine/intr.h>

#define	_N_EXTINTR		8

#define	LANDISK_INTEN		0xb0000005
#define	INTEN_ALL_MASK		0x00

struct intrhand {
	int	(*ih_fun)(void *);
	void	*ih_arg;
	struct	intrhand *ih_next;
	int	ih_enable;
	int	ih_level;
	int	ih_irq;
	struct evcount	ih_count;
	const char	*ih_name;
};

struct extintr_handler {
	int		(*eih_func)(void *eih_arg);
	void		*eih_arg;
	struct intrhand	*eih_ih;
	int		eih_nih;
};

static struct extintr_handler extintr_handler[_N_EXTINTR];

static int fakeintr(void *arg);
static int extintr_intr_handler(void *arg);

void
intc_intr(int ssr, int spc, int ssp)
{
	struct intc_intrhand *ih;
	struct clockframe cf;
	int evtcode;

	evtcode = _reg_read_4(SH4_INTEVT);
	ih = EVTCODE_IH(evtcode);
	KDASSERT(ih->ih_func);

	switch (evtcode) {
#if 0
#define	IRL(irq)	(0x200 + ((irq) << 5))
	case IRL(5): case IRL(6): case IRL(7): case IRL(8):
	case IRL(9): case IRL(10): case IRL(11): case IRL(12):
	{
		int level;
		uint8_t inten, bit;

		bit = 1 << (EVTCODE_TO_MAP_INDEX(evtcode) - 5);
		inten = _reg_read_1(LANDISK_INTEN);
		_reg_write_1(LANDISK_INTEN, inten & ~bit);
		level = (_IPL_NSOFT + 1) << 4;	/* disable softintr */
		ssr &= 0xf0;
		if (level < ssr)
			level = ssr;
		(void)_cpu_intr_resume(level);
		if ((*ih->ih_func)(ih->ih_arg) != 0)
			ih->ih_count.ec_count++;
		_reg_write_1(LANDISK_INTEN, inten);
		break;
	}
#endif
	default:
		(void)_cpu_intr_resume(ih->ih_level);
		if ((*ih->ih_func)(ih->ih_arg) != 0)
			ih->ih_count.ec_count++;
		break;

	case SH_INTEVT_TMU0_TUNI0:
		(void)_cpu_intr_resume(ih->ih_level);
		cf.spc = spc;
		cf.ssr = ssr;
		cf.ssp = ssp;
		if ((*ih->ih_func)(&cf) != 0)
			ih->ih_count.ec_count++;
		break;

	case SH_INTEVT_NMI:
		printf("NMI ignored.\n");
		break;
	}
}

void
intr_init(void)
{
	_reg_write_1(LANDISK_INTEN, INTEN_ALL_MASK);
}

void *
extintr_establish(int irq, int level, int (*ih_fun)(void *), void *ih_arg,
    const char *ih_name)
{
	static struct intrhand fakehand = {fakeintr};
	struct extintr_handler *eih;
	struct intrhand **p, *q, *ih;
	int evtcode;
	int s;

	KDASSERT(irq >= 5 && irq < 13);

	ih = malloc(sizeof(*ih), M_DEVBUF, cold ? M_NOWAIT : M_WAITOK);
	if (ih == NULL)
		panic("intr_establish: can't malloc handler info");

	s = _cpu_intr_suspend();

	switch (level) {
	default:
#if defined(DEBUG)
		panic("extintr_establish: unknown level %d", level);
		/*NOTREACHED*/
#endif
	case IPL_BIO:
	case IPL_NET:
	case IPL_TTY:
		break;
	}

	eih = &extintr_handler[irq - 5];
	if (eih->eih_func == NULL) {
		evtcode = 0x200 + (irq << 5);
		eih->eih_func = intc_intr_establish(evtcode, IST_LEVEL, level,
		    extintr_intr_handler, eih, NULL);
	}

	/*
	 * Figure out where to put the handler.
	 * This is O(N^2), but we want to preserve the order, and N is
	 * generally small.
	 */
	for (p = &eih->eih_ih; (q = *p) != NULL; p = &q->ih_next)
		continue;

	/*
	 * Actually install a fake handler momentarily, since we might be doing
	 * this with interrupts enabled and don't want the real routine called
	 * until masking is set up.
	 */
	fakehand.ih_level = level;
	*p = &fakehand;

	/*
	 * Poke the real handler in now.
	 */
	memset(ih, 0, sizeof(*ih));
	ih->ih_fun = ih_fun;
	ih->ih_arg = ih_arg;
	ih->ih_next = NULL;
	ih->ih_enable = 1;
	ih->ih_level = level;
	ih->ih_irq = irq;
	ih->ih_name = ih_name;

	if (ih_name != NULL)
		evcount_attach(&ih->ih_count, ih_name, &ih->ih_irq);
	*p = ih;

	if (++eih->eih_nih == 1) {
		/* Unmask interrupt */
		_reg_bset_1(LANDISK_INTEN, (1 << (irq - 5)));
	}

	_cpu_intr_resume(s);

	return (ih);
}

void
extintr_disestablish(void *aux)
{
	struct intrhand *ih = aux;
	struct intrhand **p, *q;
	struct extintr_handler *eih;
	int irq;
	int s;

	KDASSERT(ih != NULL);

	s = _cpu_intr_suspend();

	irq = ih->ih_irq - 5;
	eih = &extintr_handler[irq];
	/*
	 * Remove the handler from the chain.
	 * This is O(n^2), too.
	 */
	for (p = &eih->eih_ih; (q = *p) != NULL && q != ih; p = &q->ih_next)
		continue;
	if (q == NULL)
		panic("extintr_disestablish: handler not registered");

	*p = q->ih_next;

#if 0
	if (ih->ih_name != NULL)
		evcount_detach(&ih->ih_count);
#endif

	free(ih, M_DEVBUF, sizeof *ih);

	if (--eih->eih_nih == 0) {
		intc_intr_disestablish(eih->eih_func);

		/* Mask interrupt */
		_reg_bclr_1(LANDISK_INTEN, (1 << irq));
	}

	_cpu_intr_resume(s);
}

void
extintr_enable(void *aux)
{
	struct intrhand *ih = aux;
	struct intrhand *p, *q;
	struct extintr_handler *eih;
	int irq;
	int cnt;
	int s;

	KDASSERT(ih != NULL);

	s = _cpu_intr_suspend();

	irq = ih->ih_irq - 5;
	KDASSERT(irq >= 0 && irq < 8);
	eih = &extintr_handler[irq];
	for (cnt = 0, p = eih->eih_ih, q = NULL; p != NULL; p = p->ih_next) {
		if (p->ih_enable) {
			cnt++;
		}
		if (p == ih) {
			q = p;
			p->ih_enable = 1;
		}
	}
	KDASSERT(q != NULL);

	if (cnt == 0) {
		/* Unmask interrupt */
		_reg_bset_1(LANDISK_INTEN, (1 << irq));
	}

	_cpu_intr_resume(s);
}

void
extintr_disable(void *aux)
{
	struct intrhand *ih = aux;
	struct intrhand *p, *q;
	struct extintr_handler *eih;
	int irq;
	int cnt;
	int s;

	KDASSERT(ih != NULL);

	s = _cpu_intr_suspend();

	irq = ih->ih_irq - 5;
	KDASSERT(irq >= 0 && irq < 8);
	eih = &extintr_handler[irq];
	for (cnt = 0, p = eih->eih_ih, q = NULL; p != NULL; p = p->ih_next) {
		if (p == ih) {
			q = p;
			p->ih_enable = 0;
		}
		if (!ih->ih_enable) {
			cnt++;
		}
	}
	KDASSERT(q != NULL);

	if (cnt == 0) {
		/* Mask interrupt */
		_reg_bclr_1(LANDISK_INTEN, (1 << irq));
	}

	_cpu_intr_resume(s);
}

void
extintr_disable_by_num(int irq)
{
	struct extintr_handler *eih;
	struct intrhand *ih;
	int s;

	irq -= 5;
	KDASSERT(irq >= 0 && irq < 8);

	s = _cpu_intr_suspend();
	eih = &extintr_handler[irq];
	for (ih = eih->eih_ih; ih != NULL; ih = ih->ih_next) {
		ih->ih_enable = 0;
	}
	/* Mask interrupt */
	_reg_bclr_1(LANDISK_INTEN, (1 << irq));
	_cpu_intr_resume(s);
}

static int
fakeintr(void *arg)
{
	return 0;
}

static int
extintr_intr_handler(void *arg)
{
	struct extintr_handler *eih = arg;
	struct intrhand *ih;
	int r;

	if (__predict_true(eih != NULL)) {
		for (ih = eih->eih_ih; ih != NULL; ih = ih->ih_next) {
			if (__predict_true(ih->ih_enable)) {
				r = (*ih->ih_fun)(ih->ih_arg);
				if (__predict_true(r != 0)) {
					ih->ih_count.ec_count++;
					if (r == 1)
						break;
				}
			}
		}
		return 1;
	}
	return 0;
}

#ifdef DIAGNOSTIC
void
splassert_check(int wantipl, const char *func)
{
	register_t sr;
        int oldipl;

	__asm__ volatile ("stc sr,%0" : "=r" (sr));

	oldipl = (sr & 0xf0) >> 4;
        if (oldipl < wantipl) {
                splassert_fail(wantipl, oldipl, func);
                /*
                 * If the splassert_ctl is set to not panic, raise the ipl
                 * in a feeble attempt to reduce damage.
                 */
		_cpu_intr_raise(wantipl << 4);
        }
}
#endif
@


1.9
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.8 2014/03/29 18:09:29 guenther Exp $	*/
d240 1
a240 1
	free((void *)ih, M_DEVBUF, 0);
@


1.8
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.7 2011/04/15 20:40:07 deraadt Exp $	*/
d240 1
a240 1
	free((void *)ih, M_DEVBUF);
@


1.7
log
@More than a decade ago, interrupt handlers on sparc started returning 0
(interrupt was not for me), 1 (positive interrupt was for me), or -1
(i am not sure...).  We have continued with this practice in as many
drivers as possible, throughout the tree.

This makes some of the architectures use that information in their
interrupt handler calling code -- if 1 is returned (and we know
this specific machine does not have edge-shared interrupts), we
finish servicing other possible handlers on the same pin.  If the
interrupt pin remains asserted (from a different device), we will
end up back in the interrupt servicing code of course... but this is
cheaper than calling all the chained interrupts on a pin.

This does of course count on shared level interrupts being properly
sorted by IPL.

There have been some concerns about starvation of drivers which
incorrectly return 1.  Those drivers should be hunted down so that
they return -1.

(other architectures will follow)

ok kettenis drahn dlg miod
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.6 2010/09/20 06:33:47 matthew Exp $	*/
d380 1
a380 1
	__asm__ __volatile__ ("stc sr,%0" : "=r" (sr));
@


1.6
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.5 2007/04/09 13:23:25 miod Exp $	*/
d363 2
@


1.5
log
@Fix (unused) extintr_disable_by_num behaviour, and make vmstat -i output
provide the correct irq numbers.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.4 2006/11/21 21:01:52 miod Exp $	*/
d196 1
a196 2
		evcount_attach(&ih->ih_count, ih_name, (void *)&ih->ih_irq,
		    &evcount_intr);
@


1.4
log
@splassert support.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.3 2006/11/21 21:00:57 miod Exp $	*/
d140 1
a140 1
	KDASSERT(irq >= 5 && irq <= 12);
d192 1
a192 1
	ih->ih_irq = irq - 5;
d223 1
a223 1
	irq = ih->ih_irq;
a224 1

d267 1
a267 1
	irq = ih->ih_irq;
d303 1
a303 1
	irq = ih->ih_irq;
d332 2
a333 1
	KDASSERT(irq >= 5 && irq <= 12);
d336 1
a336 1
	eih = &extintr_handler[irq - 5];
@


1.3
log
@Use _cpu_intr_resume() instead of splx() for consistency. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.2 2006/11/08 21:06:57 drahn Exp $	*/
d371 21
@


1.2
log
@Implement interrupt counters (better)
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.1.1.1 2006/10/06 21:16:15 miod Exp $	*/
d205 1
a205 1
	splx(s);
d251 1
a251 1
	splx(s);
d287 1
a287 1
	splx(s);
d323 1
a323 1
	splx(s);
d342 1
a342 1
	splx(s);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d53 2
a54 1
	struct evcount ih_cnt;
d97 2
a98 1
		(*ih->ih_func)(ih->ih_arg);
d105 2
a106 1
		(*ih->ih_func)(ih->ih_arg);
d114 2
a115 1
		(*ih->ih_func)(&cf);
d164 1
a164 1
		    extintr_intr_handler, eih, ih_name);
d193 5
a197 4
#if 0
	evcnt_attach_dynamic(&ih->ih_evcnt, EVCNT_TYPE_INTR,
	    NULL, "ext", name);
#endif
d238 2
a239 1
	evcnt_detach(&ih->ih_evcnt);
d363 1
a363 1
					ih->ih_cnt.ec_count++;
@


1.1.1.1
log
@Incomplete bits for an OpenBSD/landisk port to the I/O DATA USL-5P appliances,
mickey@@ has the other part.
@
text
@@
