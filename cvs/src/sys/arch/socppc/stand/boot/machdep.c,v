head	1.7;
access;
symbols
	OPENBSD_6_2:1.7.0.2
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.7.0.4
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.6.0.10
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.6
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.8
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.4
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.4.0.16
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.14
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.12
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.10
	OPENBSD_5_0:1.4.0.8
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.6
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.1.0.8
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.4
	OPENBSD_4_5_BASE:1.1
	OPENBSD_4_4:1.1.0.2
	OPENBSD_4_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2016.10.09.11.25.40;	author tom;	state Exp;
branches;
next	1.6;
commitid	DfYvEDcFmu1LY9q1;

1.6
date	2014.03.29.18.09.30;	author guenther;	state Exp;
branches;
next	1.5;

1.5
date	2013.11.08.13.05.21;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2009.11.08.22.00.34;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2009.10.05.22.05.28;	author dms;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.07.21.16.57;	author dms;	state Exp;
branches;
next	1.1;

1.1
date	2008.05.10.20.06.26;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Apply consistency to forever loops with continue and NOTREACHED

Same thought from kettenis@@, ok krw@@ phessler@@ millert@@
@
text
@/*	$OpenBSD: machdep.c,v 1.6 2014/03/29 18:09:30 guenther Exp $	*/

/*
 * Copyright (c) 2008 Mark Kettenis
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include "libsa.h"
#include "wdvar.h"
#include "fdt.h"

/*
 * RouterBOOT firmware puts its FDT at an address that is low enough
 * to conflict with bsd.rd.  So we need to relocate the FDT.  As long
 * as we have at least 32MB of memory, the 16MB boundary should be
 * fine, and leave us plenty of room for future kernel growth.
 */
#define FDTADDRSTART	0x01000000

#define RPR	0xe0000918
#define  RPR_RSTE	0x52535445
#define RCR	0xe000091c
#define  RCR_SWSR	0x00000001
#define  RCR_SWHR	0x00000002

/* defines from pciide.c and wdc_obio.c */
int     pciide_init             (struct wdc_channel*, u_int);
int     wdc_obio_init           (struct wdc_channel*, u_int);

void
machdep(void)
{
	void *node;
	char *tmp;
	int len;

	extern int consfreq;
	extern uint8_t *consaddr;
	
	/* set default values */
	consfreq = NS16550_FREQ;
	consaddr = (uint8_t *)CONADDR;

	/* lookup FTD for informations about console */
	node = fdt_find_node("/chosen");
	if (node) {
		char *console;
		fdt_node_property(node, "linux,stdout-path", &console);
		node = fdt_find_node(console);
		if (node) {
			len = fdt_node_property(node, "clock-frequency", &tmp);
			if (len == 4)
				consfreq = *(int *)tmp;

			len = fdt_node_property(node, "reg", &tmp);
			if (len == 8)
				consaddr = (uint8_t *)*(int *)tmp;
		}
		if (node = fdt_parent_node(node)) {
			fdt_node_property(node, "device_type", &tmp);
			if (strncmp(tmp, "soc", 3) == 0) {
				/* we are on a soc */
				len = fdt_node_property(node, "reg", &tmp);
				if (len == 8)
					consaddr += *(int *)tmp;
			}
		}
	}

	cninit();
{
	extern int (*controller_init)(struct wdc_channel *chp, u_int chan);
	extern u_int32_t pciide_base_addr;
	extern u_int32_t wdc_base_addr[];
	int *addr;
	int chnum;

	/* Thecus defaults */
	controller_init = pciide_init;
	pciide_base_addr = 0xe2000000;

	/* lookup the FDT, may have some CF there */
	chnum = 0;
	wdc_base_addr[0] = 0;
	wdc_base_addr[1] = 0;
	node = fdt_find_node("/");
	for (node = fdt_child_node(node); node; node = fdt_next_node(node)) {
		len = fdt_node_property(node, "device_type", &tmp);
		if (len && (strcmp(tmp, "rb,cf") == 0) && (chnum < 2)) {
			len = fdt_node_property(node, "reg", (char **)&addr);
			if (len == 8) {
				wdc_base_addr[chnum] = *addr;
				chnum++;
			}
		}
	}
	if (chnum)
		controller_init = wdc_obio_init;
}

}

int
main(void)
{
	extern char __bss_start[], _end[];
	extern int fdtaddrsave;

	bzero(__bss_start, _end - __bss_start);

	/* initialize FDT if the blob is available */
	if (fdtaddrsave) {
		if (fdt_init((void *)fdtaddrsave) == 0)
			fdtaddrsave = 0; /* no usable blob there */
	}

	/* relocate FDT */
	if (fdtaddrsave && fdtaddrsave < FDTADDRSTART) {
		struct fdt_head *fh = (void *)fdtaddrsave;

		bcopy((void *)fdtaddrsave, (void *)FDTADDRSTART, fh->fh_size);
		fdtaddrsave = FDTADDRSTART;
	}

	boot(0);
	return 0;
}

void
_rtt(void)
{
	uint32_t v;

	*((volatile uint32_t *)(RPR)) = RPR_RSTE;
	__asm volatile("eieio");
	*((volatile uint32_t *)(RCR)) = RCR_SWHR;

	printf("RESET FAILED\n");
	for (;;)
		continue;
	/* NOTREACHED */
}
@


1.6
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.5 2013/11/08 13:05:21 fgsch Exp $	*/
d152 3
a154 1
	for (;;) ;
@


1.5
log
@fix spelling.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.4 2009/11/08 22:00:34 kettenis Exp $	*/
d148 1
a148 1
	__asm __volatile("eieio");
@


1.4
log
@Relocate FDT blob such that it doesn't clash with the kernel we're going to
load.  This makes it possible to load bsd.rd on the RB600.
Bump version number.

ok dms@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.3 2009/10/05 22:05:28 dms Exp $	*/
d57 1
a57 1
	/* lookup FTD for informations about conole */
@


1.3
log
@remove nasty code, since now we have a nice function to lookup node'ss parent.

ok by kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.2 2009/09/07 21:16:57 dms Exp $	*/
d25 8
d120 3
a122 1
	bzero(__bss_start, _end-__bss_start);
a124 1
	extern int fdtaddrsave;
d128 8
@


1.2
log
@Bring support for booting RB600.
Imported FDT parsing code, implemented wdc_obio driver to support booting
of CF cards. If FDT is available initialize console and wdc_obio
accordingly and pass it later to the kernel. Unified the code with Thecus
boot code, so that we can use one boot image. The whole boot code is now
compiled with -msoft-float. Bump version while there.

tested on Thecus by maja@@ and kettenis@@
tested on RB600 by dlg@@ and me

ok by kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.1 2008/05/10 20:06:26 kettenis Exp $	*/
a37 1
	char soc[32];
d64 4
a67 6
		memcpy(soc, console, 32);
		if (strchr(soc + 1, '/')!=0) {
			/* we are on a soc */
			*strchr(soc + 1, '/') = 0;
			node = fdt_find_node(soc);
			if (node) {
@


1.1
log
@First stab at a bootloader for the Thecus N1200.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d22 2
d31 4
d38 40
a78 1

d80 27
a106 2
	extern u_int32_t wdc_base_addr;
	wdc_base_addr = 0xe2000000;
d116 7
@

