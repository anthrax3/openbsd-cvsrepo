head	1.13;
access;
symbols
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.24
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.16
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.20
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.18
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.14
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.12
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.10
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.8
	OPENBSD_5_0:1.9.0.6
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.4
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.2
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7;
locks; strict;
comment	@ * @;


1.13
date	2016.03.03.02.42.16;	author bmercer;	state dead;
branches;
next	1.12;
commitid	T6tioCndC2dgvM4T;

1.12
date	2016.02.28.12.39.40;	author mpi;	state Exp;
branches;
next	1.11;
commitid	FCPRJPLxLydBV8k3;

1.11
date	2016.02.28.12.06.18;	author mpi;	state Exp;
branches;
next	1.10;
commitid	yKTPOeOT0nwRlTBp;

1.10
date	2015.12.14.03.25.59;	author mmcc;	state Exp;
branches;
next	1.9;
commitid	6idgy7jHjp60ENt8;

1.9
date	2010.04.21.03.03.26;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2010.04.20.23.35.16;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2009.10.01.20.21.05;	author dms;	state Exp;
branches;
next	1.6;

1.6
date	2009.09.06.19.28.12;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2009.09.02.19.36.15;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2009.08.29.11.01.13;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2009.08.26.17.30.14;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2009.08.25.21.27.24;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2009.08.25.13.18.11;	author dms;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Move fdt to a more centralized location so it can be used by arm as well. Diff from Patrick Wildt. Tested and OK dlg@@.
@
text
@/*	$OpenBSD: fdt.c,v 1.12 2016/02/28 12:39:40 mpi Exp $	*/

/*
 * Copyright (c) 2009 Dariusz Swiderski <sfires@@sfires.net>
 * Copyright (c) 2009 Mark Kettenis <kettenis@@sfires.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */


#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>

#include <machine/fdt.h>

#include <dev/ofw/openfirm.h>

unsigned int fdt_check_head(void *);
char	*fdt_get_str(u_int32_t);
void	*skip_property(u_int32_t *);
void	*skip_props(u_int32_t *);
void	*skip_node_name(u_int32_t *);
void	*fdt_parent_node_recurse(void *, void *);
#ifdef DEBUG
void 	 fdt_print_node_recurse(void *, int);
#endif

static int tree_inited = 0;
static struct fdt tree;

unsigned int
fdt_check_head(void *fdt)
{
	struct fdt_head *fh;
	u_int32_t *ptr;

	fh = fdt;
	ptr = (u_int32_t *)fdt;

	if (betoh32(fh->fh_magic) != FDT_MAGIC)
		return 0;

	if (betoh32(fh->fh_version) > FDT_CODE_VERSION)
		return 0;

	if (betoh32(*(ptr + (betoh32(fh->fh_struct_off) / 4))) !=
	    FDT_NODE_BEGIN)
		return 0;

	/* check for end signature on version 17 blob */
	if ((betoh32(fh->fh_version) >= 17) &&
	    (betoh32(*(ptr + betoh32(fh->fh_struct_size))) != FDT_END))
		return 0;

	return betoh32(fh->fh_version);
}

/*
 * Initializes internal structures of module.
 * Has to be called once, preferably in machdep.c.
 */
int
fdt_init(void *fdt)
{
	int version;

	bzero(&tree, sizeof(struct fdt));
	tree_inited = 0;

	if (!fdt)
		return 0;

	if (!(version = fdt_check_head(fdt)))
		return 0;

	tree.header = (struct fdt_head *)fdt;
	tree.tree = (char *)fdt + betoh32(tree.header->fh_struct_off);
	tree.strings = (char *)fdt + betoh32(tree.header->fh_strings_off);
	tree.memory = (char *)fdt + betoh32(tree.header->fh_reserve_off);
	tree.version = version;
	tree.strings_size = betoh32(tree.header->fh_strings_size);
	tree_inited = 1;

	return version;
}

/*
 * Retrieve string pointer from strings table.
 */
char *
fdt_get_str(u_int32_t num)
{
	if (num > tree.strings_size)
		return NULL;
	return (tree.strings) ? (tree.strings + num) : NULL;
}

/*
 * Utility functions for skipping parts of tree.
 */
void *
skip_property(u_int32_t *ptr)
{
	u_int32_t size;

	size = betoh32(*(ptr + 1));
	/* move forward by magic + size + nameid + rounded up property size */
	ptr += 3 + roundup(size, sizeof(u_int32_t)) / sizeof(u_int32_t);

	return ptr;
}

void *
skip_props(u_int32_t *ptr)
{
	while (betoh32(*ptr) == FDT_PROPERTY) {
		ptr = skip_property(ptr);
	}
	return ptr;
}

void *
skip_node_name(u_int32_t *ptr)
{
	/* skip name, aligned to 4 bytes, this is NULL term., so must add 1 */
	return ptr + roundup(strlen((char *)ptr) + 1,
	    sizeof(u_int32_t)) / sizeof(u_int32_t);
}

/*
 * Retrieves node property, the returned pointer is inside the fdt tree,
 * so we should not modify content pointed by it directly.
 */
int
fdt_node_property(void *node, char *name, char **out)
{
	u_int32_t *ptr;
	u_int32_t nameid;
	char *tmp;
	
	if (!tree_inited)
		return 0;

	ptr = (u_int32_t *)node;

	if (betoh32(*ptr) != FDT_NODE_BEGIN)
		return 0;

	ptr = skip_node_name(ptr + 1);

	while (betoh32(*ptr) == FDT_PROPERTY) {
		nameid = betoh32(*(ptr + 2)); /* id of name in strings table */
		tmp = fdt_get_str(nameid);
		if (!strcmp(name, tmp)) {
			*out = (char *)(ptr + 3); /* beginning of the value */
			return betoh32(*(ptr + 1)); /* size of value */
		}
		ptr = skip_property(ptr);
	}
	return 0;
}

/*
 * Retrieves next node, skipping all the children nodes of the pointed node
 * if passed 0 wil return first node of the tree (root)
 */
void *
fdt_next_node(void *node)
{
	u_int32_t *ptr;

	if (!tree_inited)
		return NULL;

	ptr = node;

	if (!node) {
		ptr = tree.tree;
		return (betoh32(*ptr) == FDT_NODE_BEGIN) ? ptr : NULL;
	}

	if (betoh32(*ptr) != FDT_NODE_BEGIN)
		return NULL;

	ptr++;

	ptr = skip_node_name(ptr);
	ptr = skip_props(ptr);

	/* skip children */
	while (betoh32(*ptr) == FDT_NODE_BEGIN)
		ptr = fdt_next_node(ptr);

	return (betoh32(*ptr) == FDT_NODE_END) ? (ptr + 1) : NULL;
}

/*
 * Retrieves next node, skipping all the children nodes of the pointed node
 */
void *
fdt_child_node(void *node)
{
	u_int32_t *ptr;

	if (!tree_inited)
		return NULL;

	ptr = node;

	if (betoh32(*ptr) != FDT_NODE_BEGIN)
		return NULL;

	ptr++;

	ptr = skip_node_name(ptr);
	ptr = skip_props(ptr);
	/* check if there is a child node */
	return (betoh32(*ptr) == FDT_NODE_BEGIN) ? (ptr) : NULL;
}

/*
 * Retrieves node name.
 */
char *
fdt_node_name(void *node)
{
	u_int32_t *ptr;

	if (!tree_inited)
		return NULL;

	ptr = node;

	if (betoh32(*ptr) != FDT_NODE_BEGIN)
		return NULL;

	return (char *)(ptr + 1);
}

void *
fdt_find_node(char *name)
{
	void *node = fdt_next_node(0);
	const char *p = name;

	if (!tree_inited)
		return NULL;

	if (*p != '/')
		return NULL;

	while (*p) {
		void *child;
		const char *q;

		while (*p == '/')
			p++;
		if (*p == 0)
			return node;
		q = strchr(p, '/');
		if (q == NULL)
			q = p + strlen(p);

		for (child = fdt_child_node(node); child;
		     child = fdt_next_node(child)) {
			if (strncmp(p, fdt_node_name(child), q - p) == 0) {
				node = child;
				break;
			}
		}

		p = q;
	}

	return node;
}

void *
fdt_parent_node_recurse(void *pnode, void *child)
{
	void *node = fdt_child_node(pnode);
	void *tmp;
	
	while (node && (node != child)) {
		if ((tmp = fdt_parent_node_recurse(node, child)))
			return tmp;
		node = fdt_next_node(node);
	}
	return (node) ? pnode : NULL;
}

void *
fdt_parent_node(void *node)
{
	void *pnode = fdt_next_node(0);

	if (!tree_inited)
		return NULL;

	return fdt_parent_node_recurse(pnode, node);
}

#ifdef DEBUG
/*
 * Debug methods for printing whole tree, particular odes and properies
 */
void *
fdt_print_property(void *node, int level)
{
	u_int32_t *ptr;
	char *tmp, *value;
	int cnt;
	u_int32_t nameid, size;

	ptr = (u_int32_t *)node;

	if (!tree_inited)
		return NULL;

	if (betoh32(*ptr) != FDT_PROPERTY)
		return ptr; /* should never happen */

	/* extract property name_id and size */
	size = betoh32(*++ptr);
	nameid = betoh32(*++ptr);

	for (cnt = 0; cnt < level; cnt++)
		printf("\t");

	tmp = fdt_get_str(nameid);
	printf("\t%s : ", tmp ? tmp : "NO_NAME");

	ptr++;
	value = (char *)ptr;

	if (!strcmp(tmp, "device_type") || !strcmp(tmp, "compatible") ||
	    !strcmp(tmp, "model") || !strcmp(tmp, "bootargs") ||
	    !strcmp(tmp, "linux,stdout-path")) {
		printf("%s", value);
	} else if (!strcmp(tmp, "clock-frequency") ||
	    !strcmp(tmp, "timebase-frequency")) {
		printf("%d", betoh32(*((unsigned int *)value)));
	} else {
		for (cnt = 0; cnt < size; cnt++) {
			if ((cnt % sizeof(u_int32_t)) == 0)
				printf(" ");
			printf("%02x", value[cnt]);
		}
	}
	ptr += roundup(size, sizeof(u_int32_t)) / sizeof(u_int32_t);
	printf("\n");

	return ptr;
}

void
fdt_print_node(void *node, int level)
{
	u_int32_t *ptr;
	int cnt;
	
	ptr = (u_int32_t *)node;

	if (betoh32(*ptr) != FDT_NODE_BEGIN)
		return;

	ptr++;

	for (cnt = 0; cnt < level; cnt++)
		printf("\t");
	printf("%s :\n", fdt_node_name(node));
	ptr = skip_node_name(ptr);

	while (betoh32(*ptr) == FDT_PROPERTY)
		ptr = fdt_print_property(ptr, level);
}

void
fdt_print_node_recurse(void *node, int level)
{
	void *child;

	fdt_print_node(node, level);
	for (child = fdt_child_node(node); child; child = fdt_next_node(child))
		fdt_print_node_recurse(child, level + 1);
}

void
fdt_print_tree(void)
{
	fdt_print_node_recurse(fdt_next_node(0), 0);
}
#endif

int
OF_peer(int handle)
{
	void *node = (char *)tree.header + handle;

	if (handle == 0)
		node = fdt_find_node("/");
	else
		node = fdt_next_node(node);
	return node ? ((char *)node - (char *)tree.header) : 0;
}

int
OF_child(int handle)
{
	void *node = (char *)tree.header + handle;

	node = fdt_child_node(node);
	return node ? ((char *)node - (char *)tree.header) : 0;
}

int
OF_parent(int handle)
{
	void *node = (char *)tree.header + handle;
	
	node = fdt_parent_node(node);
	return node ? ((char *)node - (char *)tree.header) : 0;
}

int
OF_finddevice(char *name)
{
	void *node;

	node = fdt_find_node(name);
	return node ? ((char *)node - (char *)tree.header) : -1;
}

int
OF_getproplen(int handle, char *prop)
{
	void *node = (char *)tree.header + handle;
	char *data;

	return fdt_node_property(node, prop, &data);
}

int
OF_getprop(int handle, char *prop, void *buf, int buflen)
{
	void *node = (char *)tree.header + handle;
	char *data;
	int len;

	len = fdt_node_property(node, prop, &data);

	/*
	 * The "name" property is optional since version 16 of the
	 * flattened device tree specification, so we synthesize one
	 * from the unit name of the node if it is missing.
	 */
	if (len == 0 && strcmp(prop, "name") == 0) {
		data = fdt_node_name(node);
		if (data) {
			len = strlcpy(buf, data, buflen);
			data = strchr(buf, '@@');
			if (data)
				*data = 0;
			return len + 1;
		}
	}

	if (len > 0)
		memcpy(buf, data, min(len, buflen));
	return len;
}
@


1.12
log
@Convert FDT values from big endian to host endian.

This is a no-op on socppc but will allows ARM ports (little-endian)
to make use of this code.

From Patrick Wildt.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdt.c,v 1.11 2016/02/28 12:06:18 mpi Exp $	*/
@


1.11
log
@Remove useless code, from Patrick Wildt.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdt.c,v 1.10 2015/12/14 03:25:59 mmcc Exp $	*/
d51 1
a51 1
	if (fh->fh_magic != FDT_MAGIC)
d54 1
a54 1
	if (fh->fh_version > FDT_CODE_VERSION)
d57 2
a58 1
	if (*(ptr + (fh->fh_struct_off / 4)) != FDT_NODE_BEGIN)
d62 2
a63 1
	if ((fh->fh_version >= 17) & (*(ptr + fh->fh_struct_size) != FDT_END))
d66 1
a66 1
	return fh->fh_version;
d88 3
a90 3
	tree.tree = (char *)fdt + tree.header->fh_struct_off;
	tree.strings = (char *)fdt + tree.header->fh_strings_off;
	tree.memory = (char *)fdt + tree.header->fh_reserve_off;
d92 1
a92 1
	tree.strings_size = tree.header->fh_strings_size;
d117 1
a117 1
	size = *(ptr + 1);
d127 1
a127 1
	while (*ptr == FDT_PROPERTY) {
d157 1
a157 1
	if (*ptr != FDT_NODE_BEGIN)
d162 2
a163 2
	while (*ptr == FDT_PROPERTY) {
		nameid = *(ptr + 2); /* id of name in strings table */
d167 1
a167 1
			return *(ptr + 1); /* size of value */
d190 1
a190 1
		return (*ptr == FDT_NODE_BEGIN) ? ptr : NULL;
d193 1
a193 1
	if (*ptr != FDT_NODE_BEGIN)
d202 1
a202 1
	while (*ptr == FDT_NODE_BEGIN)
d205 1
a205 1
	return (*ptr == FDT_NODE_END) ? (ptr + 1) : NULL;
d221 1
a221 1
	if (*ptr != FDT_NODE_BEGIN)
d229 1
a229 1
	return (*ptr == FDT_NODE_BEGIN) ? (ptr) : NULL;
d245 1
a245 1
	if (*ptr != FDT_NODE_BEGIN)
d331 1
a331 1
	if (*ptr != FDT_PROPERTY)
d335 2
a336 2
	size = *++ptr;
	nameid = *++ptr;
d353 1
a353 1
		printf("%d", *((unsigned int *)value));
d375 1
a375 1
	if (*ptr != FDT_NODE_BEGIN)
d385 1
a385 1
	while (*ptr == FDT_PROPERTY)
@


1.10
log
@s/begining/beginning/g
@
text
@d1 1
a1 1
/*	$OpenBSD: fdt.c,v 1.9 2010/04/21 03:03:26 deraadt Exp $	*/
a89 19

	if (version < 3) {
		if ((tree.strings < tree.tree) && (tree.tree < tree.memory))
			tree.strings_size = tree.tree - tree.strings;
		else if ((tree.strings < tree.memory) && (tree.memory <
		    tree.tree))
			tree.strings_size = tree.memory - tree.strings;
		else if ((tree.strings < tree.tree) && (tree.memory <
		    tree.strings))
			tree.strings_size = tree.tree - tree.strings;
		else if ((tree.strings < tree.memory) && (tree.tree <
		    tree.strings))
			tree.strings_size = tree.memory - tree.strings;
		else
			tree.strings_size = tree.header->fh_size -
			    (int)tree.strings;
	} else
		tree.strings_size = tree.header->fh_strings_size;

@


1.9
log
@more cleanup to cope with the change that tries to make proc.h not act
like it is everything.h
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: fdt.c,v 1.8 2010/04/20 23:35:16 deraadt Exp $	*/
d183 1
a183 1
			*out = (char *)(ptr + 3); /* begining of the value */
@


1.8
log
@more misuse of user.h and sysctl.h
@
text
@d1 1
a1 1
/*	$OpenBSD: fdt.c,v 1.7 2009/10/01 20:21:05 dms Exp $	*/
d23 1
@


1.7
log
@add fdt_parent_node() and OF_parent() functions,
as requested by kettenis@@

ok by kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdt.c,v 1.6 2009/09/06 19:28:12 kettenis Exp $	*/
a22 1
#include <sys/user.h>
@


1.6
log
@Implement OF_getproplen().
@
text
@d1 1
a1 1
/*	$OpenBSD: fdt.c,v 1.5 2009/09/02 19:36:15 kettenis Exp $	*/
d34 1
d306 25
d441 9
@


1.5
log
@Add a minimal set of OpenFirmware compatibility interfaces.

ok dms@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdt.c,v 1.4 2009/08/29 11:01:13 miod Exp $	*/
d425 9
@


1.4
log
@typos in comments
@
text
@d1 1
a1 1
/*	$OpenBSD: fdt.c,v 1.3 2009/08/26 17:30:14 kettenis Exp $	*/
d5 1
d24 1
d27 2
d396 60
@


1.3
log
@Change fdt_find_node() such that it takes a full path as argument.

ok dms@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdt.c,v 1.2 2009/08/25 21:27:24 kettenis Exp $	*/
d111 1
a111 1
 * Retrieve string pointer from srtings table.
@


1.2
log
@Add missing $OpenBSD$ tag.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a29 1
void	*fdt_find_node_recurse(void *node, char *name);
d264 1
a264 1
fdt_find_node_recurse(void *node, char *name)
d266 2
a267 4
	void *child;
	void *tmp;
	char *nname;
	int len;
d269 2
a270 1
	tmp = 0;
d272 1
a272 1
	if (!(nname = fdt_node_name(node)))
d275 7
a281 8
	/* root directory for version >= 16 can be null */
	if ((strlen(nname) == 0) && (tree.version >= 16)) {
		if (!strcmp(name, "/"))
			return node;
	} else {
		len = (strlen(name) > strlen(nname)) ? strlen(nname) :
		    strlen(name);
		if (!strncmp(name, nname, len)) {
d283 10
d294 2
d298 1
a298 14
	for (child = fdt_child_node(node); child && (!tmp);
	    child = fdt_next_node(child))
		tmp = fdt_find_node_recurse(child, name);

	return (tmp) ? tmp : NULL;
}

void *
fdt_find_node(char *name)
{
	if (!tree_inited)
		return NULL;

	return fdt_find_node_recurse(fdt_next_node(0), name);
@


1.1
log
@Add parser for 'Flattened Device Tree' which was introduced in
bootloaders such as u-boot, which is generally a simplified memory
dump of an OpenFirmware device tree. Tested on RB600 by me.
This is not used in the code ATM.

ok kettenis@@
@
text
@d1 1
@

