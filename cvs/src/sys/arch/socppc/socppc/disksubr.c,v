head	1.21;
access;
symbols
	OPENBSD_6_2_BASE:1.21
	OPENBSD_6_1:1.21.0.4
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.20.0.4
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.19.0.10
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.19.0.6
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.18.0.10
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.8
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.6
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.4
	OPENBSD_5_0:1.18.0.2
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.9.0.4
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.5.0.2
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.4.0.2
	OPENBSD_4_4_BASE:1.4;
locks; strict;
comment	@ * @;


1.21
date	2017.02.28.10.49.37;	author natano;	state Exp;
branches;
next	1.20;
commitid	9645cvu5lMcc7gZM;

1.20
date	2015.09.27.20.20.23;	author krw;	state Exp;
branches;
next	1.19;
commitid	OYyyQjE9Z0s0mlyI;

1.19
date	2013.10.19.09.32.15;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2011.07.08.00.08.00;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2011.07.06.15.26.50;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2011.05.22.15.11.40;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2011.04.16.03.21.15;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2011.04.15.14.57.29;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2011.04.06.13.46.50;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2011.02.26.13.07.48;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2009.08.17.23.27.57;	author dms;	state Exp;
branches;
next	1.10;

1.10
date	2009.08.13.15.23.11;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2009.06.19.11.47.09;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2009.06.14.00.09.39;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2009.06.05.00.41.13;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2009.06.04.21.13.02;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2008.08.24.12.56.17;	author krw;	state Exp;
branches;
next	1.4;

1.4
date	2008.06.12.06.58.36;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2008.06.11.12.35.43;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.10.20.50.23;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	2008.05.10.12.02.21;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Switch geteblks()'s size argument from int to size_t. It's called with
unsigned variables as argument in most places anyway. Decrease the
chance of signedness/range mismatch issues.

ok stefan
@
text
@/*	$OpenBSD: disksubr.c,v 1.20 2015/09/27 20:20:23 krw Exp $	*/
/*	$NetBSD: disksubr.c,v 1.21 1996/05/03 19:42:03 christos Exp $	*/

/*
 * Copyright (c) 1996 Theo de Raadt
 * Copyright (c) 1982, 1986, 1988 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/disklabel.h>
#include <sys/disk.h>

/*
 * Attempt to read a disk label from a device
 * using the indicated strategy routine.
 * The label must be partly set up before this:
 * secpercyl, secsize and anything required for a block i/o read
 * operation in the driver's strategy/start routines
 * must be filled in before calling us.
 *
 * If dos partition table requested, attempt to load it and
 * find disklabel inside a DOS partition.
 *
 * We would like to check if each MBR has a valid DOSMBR_SIGNATURE, but
 * we cannot because it doesn't always exist. So.. we assume the
 * MBR is valid.
 */
int
readdisklabel(dev_t dev, void (*strat)(struct buf *),
    struct disklabel *lp, int spoofonly)
{
	struct buf *bp = NULL;
	int error;

	if ((error = initdisklabel(lp)))
		goto done;

	/* get a buffer and initialize it */
	bp = geteblk(lp->d_secsize);
	bp->b_dev = dev;

	error = readdoslabel(bp, strat, lp, NULL, spoofonly);
	if (error == 0)
		goto done;

#if defined(CD9660)
	error = iso_disklabelspoof(dev, strat, lp);
	if (error == 0)
		goto done;
#endif
#if defined(UDF)
	error = udf_disklabelspoof(dev, strat, lp);
	if (error == 0)
		goto done;
#endif

done:
	if (bp) {
		bp->b_flags |= B_INVAL;
		brelse(bp);
	}
	disk_change = 1;
	return (error);
}

/*
 * Write disk label back to device after modification.
 */
int
writedisklabel(dev_t dev, void (*strat)(struct buf *), struct disklabel *lp)
{
	daddr_t partoff = -1;
	int error = EIO;
	int offset;
	struct disklabel *dlp;
	struct buf *bp = NULL;

	/* get a buffer and initialize it */
	bp = geteblk(lp->d_secsize);
	bp->b_dev = dev;

	if (readdoslabel(bp, strat, lp, &partoff, 1) != 0)
		goto done;

	/* Read it in, slap the new label in, and write it back out */
	error = readdisksector(bp, strat, lp, DL_BLKTOSEC(lp, partoff +
	    DOS_LABELSECTOR));
	if (error)
		goto done;
	offset = DL_BLKOFFSET(lp, partoff + DOS_LABELSECTOR);

	dlp = (struct disklabel *)(bp->b_data + offset);
	*dlp = *lp;
	CLR(bp->b_flags, B_READ | B_WRITE | B_DONE);
	SET(bp->b_flags, B_BUSY | B_WRITE | B_RAW);
	(*strat)(bp);
	error = biowait(bp);

done:
	if (bp) {
		bp->b_flags |= B_INVAL;
		brelse(bp);
	}
	disk_change = 1;
	return (error);
}
@


1.20
log
@Use readdisksector() instead of manual buf initialization. These are
identical to the amd64 change already committed.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.19 2013/10/19 09:32:15 krw Exp $	*/
d66 1
a66 1
	bp = geteblk((int)lp->d_secsize);
d106 1
a106 1
	bp = geteblk((int)lp->d_secsize);
@


1.19
log
@Use daddr_t * instead of int * for the partoffp parameter to
readdoslabel(). Ditto all the MD variables whose addresses are passed
to readdoslabel() via partoffp.

Fix some 512-byte block vs disk sector confusion in hppa and sgi.
All the DL_GETxxxxx() defines return disk sector values. All
DL_SETxxxx() take disk sector values. These changes should be no-ops
until a drive using non-512-byte-sectors is encountered.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.18 2011/07/08 00:08:00 krw Exp $	*/
d113 4
a116 2
	bp->b_blkno = DL_BLKTOSEC(lp, partoff + DOS_LABELSECTOR) *
	    DL_BLKSPERSEC(lp);
a117 6
	bp->b_bcount = lp->d_secsize;
	CLR(bp->b_flags, B_READ | B_WRITE | B_DONE);
	SET(bp->b_flags, B_BUSY | B_READ | B_RAW);
	(*strat)(bp);
	if ((error = biowait(bp)) != 0)
		goto done;
@


1.18
log
@When reading dos labels use DOS_LABELSECTOR and don't use LABELOFFSET. For all these
arch's LABELSECTOR == DOS_LABELSECTOR == 1, and LABELOFFSET == 0. Thus, to quote bob,
"This is a no-op". Makes the expression used when writing label the same as the one
used in readdoslabel().
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.17 2011/07/06 15:26:50 krw Exp $	*/
d99 2
a100 1
	int error = EIO, partoff = -1;
@


1.17
log
@On those archs that read their disk (vs iso/udf) disklabels exclusively
via readdoslabel(), tweak writedisklabel() to write disklabels at
the same place readdoslabel() reads them from. Irregardless of the
physical disk sector size. As is done in i386/amd64 already.

No change in behaviour for the 'normal' 512-byte sector case.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.16 2011/05/22 15:11:40 deraadt Exp $	*/
d112 3
a114 2
	bp->b_blkno = DL_BLKTOSEC(lp, partoff+LABELSECTOR) * DL_BLKSPERSEC(lp);
	offset = DL_BLKOFFSET(lp, partoff + LABELSECTOR) + LABELOFFSET;
@


1.16
log
@socppc is a pure MBR architecture (just like landisk and armish), so
it does not need macppc DPME logic
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.15 2011/04/16 03:21:15 krw Exp $	*/
d100 1
d112 2
a113 1
	bp->b_blkno = partoff + LABELSECTOR;
d121 1
a121 1
	dlp = (struct disklabel *)(bp->b_data + LABELOFFSET);
@


1.15
log
@Use 'CLR(<buf>->b_flags, B_READ | B_WRITE | B_DONE)' regardless of
what the previous IO was. Less chance of copy and paste errors.
Suggested by miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.14 2011/04/15 14:57:29 krw Exp $	*/
a39 3
int	readdpmelabel(struct buf *, void (*)(struct buf *),
	    struct disklabel *, int *, int);

a68 4
	error = readdpmelabel(bp, strat, lp, NULL, spoofonly);
	if (error == 0)
		goto done;

a92 89
int
readdpmelabel(struct buf *bp, void (*strat)(struct buf *),
    struct disklabel *lp, int *partoffp, int spoofonly)
{
	int i, part_cnt, n, hfspartoff = -1;
	u_int64_t hfspartend = DL_GETDSIZE(lp);
	struct part_map_entry *part;

	/* First check for a DPME (HFS) disklabel */
	bp->b_blkno = 1;
	bp->b_bcount = lp->d_secsize;
	CLR(bp->b_flags, B_READ | B_WRITE | B_DONE);
	SET(bp->b_flags, B_BUSY | B_READ | B_RAW);
	(*strat)(bp);
	if (biowait(bp))
		return (bp->b_error);

	/* if successful, wander through DPME partition table */
	part = (struct part_map_entry *)bp->b_data;
	/* if first partition is not valid, assume not HFS/DPME partitioned */
	if (part->pmSig != PART_ENTRY_MAGIC)
		return (EINVAL);	/* not a DPME partition */
	part_cnt = part->pmMapBlkCnt;
	n = 8;
	for (i = 0; i < part_cnt; i++) {
		struct partition *pp;
		char *s;

		bp->b_blkno = 1+i;
		bp->b_bcount = lp->d_secsize;
		CLR(bp->b_flags, B_READ | B_WRITE | B_DONE);
		SET(bp->b_flags, B_BUSY | B_READ | B_RAW);
		(*strat)(bp);
		if (biowait(bp))
			return (bp->b_error);

		part = (struct part_map_entry *)bp->b_data;
		/* toupper the string, in case caps are different... */
		for (s = part->pmPartType; *s; s++)
			if ((*s >= 'a') && (*s <= 'z'))
				*s = (*s - 'a' + 'A');

		if (strcmp(part->pmPartType, PART_TYPE_OPENBSD) == 0) {
			hfspartoff = part->pmPyPartStart - LABELSECTOR;
			hfspartend = hfspartoff + part->pmPartBlkCnt;
			if (partoffp) {
				*partoffp = hfspartoff;
				return (0);
			} else {
				DL_SETBSTART(lp, hfspartoff);
				DL_SETBEND(lp,
				    hfspartend < DL_GETDSIZE(lp) ? hfspartend :
				    DL_GETDSIZE(lp));
			}
			continue;
		}

		if (n >= MAXPARTITIONS || partoffp)
			continue;

		/* Currently we spoof HFS partitions only. */
		if (strcmp(part->pmPartType, PART_TYPE_MAC) == 0) {
			pp = &lp->d_partitions[n];
			DL_SETPOFFSET(pp, part->pmPyPartStart);
			DL_SETPSIZE(pp, part->pmPartBlkCnt);
			pp->p_fstype = FS_HFS;
			n++;
		}
	}

	if (hfspartoff == -1)
		return (EINVAL);

	if (spoofonly)
		return (0);

	/* next, dig out disk label */
	bp->b_blkno = hfspartoff + LABELSECTOR;
	bp->b_bcount = lp->d_secsize;
	CLR(bp->b_flags, B_READ | B_WRITE | B_DONE);
	SET(bp->b_flags, B_BUSY | B_READ | B_RAW);
	(*strat)(bp);
	if (biowait(bp))
		return (bp->b_error);

	return checkdisklabel(bp->b_data + LABELOFFSET, lp, hfspartoff,
	    hfspartend);
}

d107 1
a107 2
	if (readdpmelabel(bp, strat, lp, &partoff, 1) != 0 &&
	    readdoslabel(bp, strat, lp, &partoff, 1) != 0)
@


1.14
log
@In days of yore one could arbitrarily whack buffer flags. Those days
are past. Use CLR() and SET() to modify necessary flags while leaving
the flags used by the buffer cache in peace.

Should make bufcache code much less confused about the state of the
bufs used in reading/writing disklabels. Other such flag abuses no
doubt await a visit.

Errors in original diff found by miod@@.

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.13 2011/04/06 13:46:50 miod Exp $	*/
d111 1
a111 1
	CLR(bp->b_flags, B_WRITE | B_DONE);
d130 1
a130 1
		CLR(bp->b_flags, B_WRITE | B_DONE);
d179 1
a179 1
	CLR(bp->b_flags, B_WRITE | B_DONE);
d210 1
a210 1
	CLR(bp->b_flags, B_WRITE | B_DONE);
d218 1
a218 1
	CLR(bp->b_flags, B_READ | B_DONE);
@


1.13
log
@The various read*label() have stopped returning error strings for quite
some time, and return errnos instead. Fix or remove out-of-date comments
mentioning the error strings, and make their callers check the return value
against zero, not NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.12 2011/02/26 13:07:48 krw Exp $	*/
d111 2
a112 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d130 2
a131 1
		bp->b_flags = B_BUSY | B_READ | B_RAW;
d179 2
a180 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d210 2
a211 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d218 2
a219 1
	bp->b_flags = B_BUSY | B_WRITE | B_RAW;
@


1.12
log
@Force the DUID cache used to generate hw.disknames to be updated
after every disklabel read or write. This keeps the DUID cache more
in sync with the physical world. De-syncing noted by drahn@@ while
zapping disklabels with dd.

ok jsing@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.11 2009/08/17 23:27:57 dms Exp $	*/
d52 1
a52 2
 * find disklabel inside a DOS partition. Return buffer
 * for use in signalling errors if requested.
a56 2
 *
 * Returns null on success and an error string on failure.
d200 2
a201 2
	if (readdpmelabel(bp, strat, lp, &partoff, 1) != NULL &&
	    readdoslabel(bp, strat, lp, &partoff, 1) != NULL)
@


1.11
log
@fix readdpmelabel() declaration since the definition was changed
from returning char* to int, last char* return removed as well
(cleanup after deraadt@@ commit, it compiles now)
while there initialize hfspartend to some sane value (sync with macppc
version)

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.10 2009/08/13 15:23:11 deraadt Exp $	*/
d99 1
d226 1
@


1.10
log
@Replace the error strings that were being passed around with much simpler
errnos.  Note that the error strings are being ignored, since we long ago
decided to not spam the console, and there is no other nice way to use the
errors (without changing the ioctls to pass it back)
The errno is now useful, since we can pass b_error from failing IO up, and
the drive can decide how to use that
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.9 2009/06/19 11:47:09 krw Exp $	*/
d40 1
a40 1
char   *readdpmelabel(struct buf *, void (*)(struct buf *),
d107 1
a107 1
	u_int64_t hfspartend;
d122 1
a122 1
		return ("not a DPME partition");
@


1.9
log
@They're DPME partitions, not DPMI partitions.

ok miod@@ drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.8 2009/06/14 00:09:39 deraadt Exp $	*/
d61 1
a61 1
char *
d66 1
a66 1
	char *msg;
d68 1
a68 1
	if ((msg = initdisklabel(lp)))
d75 2
a76 2
	msg = readdpmelabel(bp, strat, lp, NULL, spoofonly);
	if (msg == NULL)
d79 2
a80 2
	msg = readdoslabel(bp, strat, lp, NULL, spoofonly);
	if (msg == NULL)
d84 2
a85 2
	if (iso_disklabelspoof(dev, strat, lp) == 0) {
		msg = NULL;
a86 1
	}
d89 2
a90 2
	if (udf_disklabelspoof(dev, strat, lp) == 0) {
		msg = NULL;
a91 1
	}
d99 1
a99 1
	return (msg);
d102 1
a102 1
char *
d116 1
a116 1
		return ("DPME partition I/O error");
d134 1
a134 1
			return ("DPME partition I/O error");
d147 1
a147 1
				return (NULL);
d171 1
a171 1
		return ("no OpenBSD partition inside DPME label");
d174 1
a174 1
		return (NULL);
d182 1
a182 1
		return("disk label I/O error");
@


1.8
log
@Don't mess with the bounds in the lp if *partoffp is non-NULL, since this
indicates that writedisklabel is trying to find the location for writing
the label.  If the lp is messed with, an invalid checksum is written.
done with miod and kettenis, lots of moaning and gnashing of teeth, etc
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.7 2009/06/05 00:41:13 deraadt Exp $	*/
d124 1
a124 1
		return ("not a DPMI partition");
@


1.7
log
@Clamp the ending bound to the size of the disk.  This makes disklabel -A
still do the right thing if the MBR has a lie in it
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.6 2009/06/04 21:13:02 deraadt Exp $	*/
d150 5
a169 4

		DL_SETBSTART(lp, hfspartoff);
		DL_SETBEND(lp, hfspartend < DL_GETDSIZE(lp) ? hfspartend :
		    DL_GETDSIZE(lp));
@


1.6
log
@Recycle four ancient fields in the disklabel structure, replacing them with
bounds information, ie. the zone of the disk that OpenBSD can use.  Have each
pre-disklabel parser (MBR, DPME, or per-arch MD disklabel parsers) figure out
this area and pass it up to userland.  Then, delete all the same disk parsing
code from disklabel(8) since the kernel passes it up.  Lots and lots of - signs
in the disklabel(8) code.
Tested on as many platforms as possible, the fallout will be repaired as time
goes on.  To test, use disklabel -d <drive> and validate that the bounds do not
overlap any boot blocks.  This same information is used by disklabel -A...
OK for the concept from krw, miod, and drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.5 2008/08/24 12:56:17 krw Exp $	*/
d109 1
a109 1
	u_int hfspartlen;
d146 1
a146 1
			hfspartlen = part->pmPartBlkCnt;
d167 2
a168 1
		DL_SETBEND(lp, hfspartoff + hfspartlen);
d186 1
a186 1
	    hfspartoff + hfspartlen);
@


1.5
log
@Fix readdpmelabel() so it doesn't corrupt a disklabel about to be
written (i.e. partoff != NULL), and doesn't corrupt a disklabel
with more than eight (8) dpme partitions.

Problems reported by Josh Elsasser via PR#5904. Testing by Josh,
otto@@, drahn@@, maja@@, kettenis@@. Most of the diff from otto@@.

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.4 2008/06/12 06:58:36 deraadt Exp $	*/
d109 1
a111 3
	if (partoffp)
		*partoffp = hfspartoff;

d146 1
d165 3
d169 1
a172 2
	lp->d_npartitions = MAXPARTITIONS;

d184 2
a185 1
	return checkdisklabel(bp->b_data + LABELOFFSET, lp);
@


1.4
log
@Bring biomem diff back into the tree after the nfs_bio.c fix went in.
ok thib beck art
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.2 2008/06/10 20:50:23 beck Exp $	*/
d111 3
d128 1
a128 1
	n = 0;
d130 1
a130 1
		struct partition *pp = &lp->d_partitions[8+n];
d146 1
a146 1
		if (strcmp(part->pmPartType, PART_TYPE_OPENBSD) == 0)
d148 9
d158 1
a158 1
		/* currently we ignore all but HFS partitions */
d160 1
a166 2
	lp->d_npartitions = MAXPARTITIONS;

d168 1
a168 1
		return ("no OpenBSD parition inside DPME label");
d170 1
a170 2
	if (partoffp)
		*partoffp = hfspartoff;
@


1.3
log
@back out biomem diff since it is not right yet.  Doing very large
file copies to nfsv2 causes the system to eventually peg the console.
On the console ^T indicates that the load is increasing rapidly, ddb
indicates many calls to getbuf, there is some very slow nfs traffic
making none (or extremely slow) progress.  Eventually some machines
seize up entirely.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.1 2008/05/10 12:02:21 kettenis Exp $	*/
d114 1
a114 1
	bp->b_flags = B_BUSY | B_READ;
d132 1
a132 1
		bp->b_flags = B_BUSY | B_READ;
d168 1
a168 1
	bp->b_flags = B_BUSY | B_READ;
d197 1
a197 1
	bp->b_flags = B_BUSY | B_READ;
d204 1
a204 1
	bp->b_flags = B_BUSY | B_WRITE;
@


1.2
log
@Fix buffer cache pending read statistics by ensuring we can identify
biowait() reads that do *not* come from the buffer cache - we use the
B_RAW flag to identify these at art's suggestion - since it makes sense
and the flag was not being used. this just flags all these buffers with
B_RAW - biodone already ignores returned buffers marked B_RAW.
ok art@@
@
text
@d114 1
a114 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d132 1
a132 1
		bp->b_flags = B_BUSY | B_READ | B_RAW;
d168 1
a168 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d197 1
a197 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d204 1
a204 1
	bp->b_flags = B_BUSY | B_WRITE | B_RAW;
@


1.1
log
@OpenBSD/socppc, a port to the Thecus N1200, and potentially other Freescale
PowerPC SoC platforms that use u-boot as a bootloader.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d114 1
a114 1
	bp->b_flags = B_BUSY | B_READ;
d132 1
a132 1
		bp->b_flags = B_BUSY | B_READ;
d168 1
a168 1
	bp->b_flags = B_BUSY | B_READ;
d197 1
a197 1
	bp->b_flags = B_BUSY | B_READ;
d204 1
a204 1
	bp->b_flags = B_BUSY | B_WRITE;
@

