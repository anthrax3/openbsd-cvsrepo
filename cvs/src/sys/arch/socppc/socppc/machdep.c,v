head	1.72;
access;
symbols
	OPENBSD_6_2:1.72.0.2
	OPENBSD_6_2_BASE:1.72
	OPENBSD_6_1:1.71.0.4
	OPENBSD_6_1_BASE:1.71
	OPENBSD_6_0:1.69.0.2
	OPENBSD_6_0_BASE:1.69
	OPENBSD_5_9:1.64.0.2
	OPENBSD_5_9_BASE:1.64
	OPENBSD_5_8:1.64.0.4
	OPENBSD_5_8_BASE:1.64
	OPENBSD_5_7:1.63.0.2
	OPENBSD_5_7_BASE:1.63
	OPENBSD_5_6:1.55.0.4
	OPENBSD_5_6_BASE:1.55
	OPENBSD_5_5:1.39.0.4
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.36.0.4
	OPENBSD_5_4_BASE:1.36
	OPENBSD_5_3:1.36.0.2
	OPENBSD_5_3_BASE:1.36
	OPENBSD_5_2:1.34.0.2
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.2
	OPENBSD_5_0:1.32.0.2
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.27.0.2
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.26.0.2
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.13.0.4
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.5.0.2
	OPENBSD_4_4_BASE:1.5;
locks; strict;
comment	@ * @;


1.72
date	2017.04.30.16.45.45;	author mpi;	state Exp;
branches;
next	1.71;
commitid	2Gtqjzrin9LL2yHk;

1.71
date	2016.10.09.11.25.40;	author tom;	state Exp;
branches;
next	1.70;
commitid	DfYvEDcFmu1LY9q1;

1.70
date	2016.09.18.14.28.25;	author deraadt;	state Exp;
branches;
next	1.69;
commitid	BJaYTqaJQ1246GGO;

1.69
date	2016.05.23.18.14.47;	author deraadt;	state Exp;
branches;
next	1.68;
commitid	EfFfbSBxCu0OV54U;

1.68
date	2016.05.21.00.56.44;	author deraadt;	state Exp;
branches;
next	1.67;
commitid	oWpLaBOdDMvIxei3;

1.67
date	2016.05.11.20.19.01;	author deraadt;	state Exp;
branches;
next	1.66;
commitid	lxwoX5l3JOpuLQVg;

1.66
date	2016.05.10.18.39.48;	author deraadt;	state Exp;
branches;
next	1.65;
commitid	qfOifNidEGDB2jL1;

1.65
date	2016.03.03.02.42.16;	author bmercer;	state Exp;
branches;
next	1.64;
commitid	T6tioCndC2dgvM4T;

1.64
date	2015.03.31.16.00.38;	author mpi;	state Exp;
branches;
next	1.63;
commitid	MMWnK4Mn4W58afQM;

1.63
date	2015.03.01.17.22.17;	author miod;	state Exp;
branches;
next	1.62;
commitid	7B0ugqDSzihvh84c;

1.62
date	2015.01.20.18.34.00;	author mpi;	state Exp;
branches;
next	1.61;
commitid	EdxyRml3kMx5DGKk;

1.61
date	2015.01.04.13.01.42;	author mpi;	state Exp;
branches;
next	1.60;
commitid	NhpbICTczAMSUxav;

1.60
date	2014.12.10.15.29.53;	author mikeb;	state Exp;
branches;
next	1.59;
commitid	qHQiR2HLROzvZr7B;

1.59
date	2014.11.16.12.30.58;	author deraadt;	state Exp;
branches;
next	1.58;
commitid	yv0ECmCdICvq576h;

1.58
date	2014.10.27.21.56.57;	author kettenis;	state Exp;
branches;
next	1.57;
commitid	FoIIoP29J2IYw7zk;

1.57
date	2014.09.19.17.34.05;	author kettenis;	state Exp;
branches;
next	1.56;
commitid	UWk0PUhhImBEkXW7;

1.56
date	2014.09.06.10.45.29;	author mpi;	state Exp;
branches;
next	1.55;
commitid	psPuYzRRUiGpyp76;

1.55
date	2014.07.21.17.25.47;	author uebayasi;	state Exp;
branches;
next	1.54;
commitid	7QO4UJr3EKVAMc8t;

1.54
date	2014.07.13.22.53.39;	author uebayasi;	state Exp;
branches;
next	1.53;
commitid	wsdp3qtXGjMj98oD;

1.53
date	2014.07.13.22.13.07;	author uebayasi;	state Exp;
branches;
next	1.52;
commitid	qYPOd6Qi4aRBKldK;

1.52
date	2014.07.10.21.46.03;	author mpi;	state Exp;
branches;
next	1.51;
commitid	iYq3Z1ZWDKR3sS9G;

1.51
date	2014.07.10.20.15.27;	author uebayasi;	state Exp;
branches;
next	1.50;
commitid	YzvTa4t6mddz7Mh4;

1.50
date	2014.07.10.13.34.32;	author uebayasi;	state Exp;
branches;
next	1.49;
commitid	xpsLTYRIkonFtkr1;

1.49
date	2014.07.10.12.13.49;	author uebayasi;	state Exp;
branches;
next	1.48;
commitid	aofvn6ceiucgjg4N;

1.48
date	2014.05.31.15.49.28;	author mpi;	state Exp;
branches;
next	1.47;
commitid	eA4Y0YE1IUzj6hpW;

1.47
date	2014.05.30.13.46.16;	author mpi;	state Exp;
branches;
next	1.46;

1.46
date	2014.05.09.18.16.15;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2014.04.01.20.42.39;	author mpi;	state Exp;
branches;
next	1.44;

1.44
date	2014.03.31.18.58.41;	author mpi;	state Exp;
branches;
next	1.43;

1.43
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.42;

1.42
date	2014.03.23.15.28.10;	author kettenis;	state Exp;
branches;
next	1.41;

1.41
date	2014.03.22.06.05.45;	author guenther;	state Exp;
branches;
next	1.40;

1.40
date	2014.03.13.03.52.55;	author dlg;	state Exp;
branches;
next	1.39;

1.39
date	2014.01.06.16.17.33;	author uebayasi;	state Exp;
branches;
next	1.38;

1.38
date	2013.11.18.08.20.22;	author uebayasi;	state Exp;
branches;
next	1.37;

1.37
date	2013.09.28.12.40.32;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2012.12.02.07.03.31;	author guenther;	state Exp;
branches;
next	1.35;

1.35
date	2012.10.08.21.47.50;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2012.03.14.21.56.46;	author kettenis;	state Exp;
branches;
next	1.33;

1.33
date	2011.08.29.20.21.44;	author drahn;	state Exp;
branches;
next	1.32;

1.32
date	2011.07.05.04.48.02;	author guenther;	state Exp;
branches;
next	1.31;

1.31
date	2011.06.26.22.40.00;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2011.06.05.19.41.08;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2011.04.18.21.44.55;	author guenther;	state Exp;
branches;
next	1.28;

1.28
date	2011.04.15.04.52.40;	author guenther;	state Exp;
branches;
next	1.27;

1.27
date	2011.01.08.18.10.22;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2010.06.27.13.28.46;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2010.06.27.03.03.48;	author thib;	state Exp;
branches;
next	1.24;

1.24
date	2010.06.10.17.54.13;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2009.10.01.20.19.19;	author kettenis;	state Exp;
branches;
next	1.22;

1.22
date	2009.08.30.14.57.41;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2009.08.26.19.09.44;	author kettenis;	state Exp;
branches;
next	1.20;

1.20
date	2009.08.26.17.38.06;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2009.08.25.21.18.20;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2009.08.11.19.17.17;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2009.08.11.18.46.32;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2009.08.09.10.40.17;	author blambert;	state Exp;
branches;
next	1.15;

1.15
date	2009.08.02.16.28.39;	author beck;	state Exp;
branches;
next	1.14;

1.14
date	2009.07.26.18.48.55;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2009.06.15.17.01.26;	author beck;	state Exp;
branches;
next	1.12;

1.12
date	2009.06.09.01.12.38;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2009.06.03.21.30.20;	author beck;	state Exp;
branches;
next	1.10;

1.10
date	2009.06.02.21.38.10;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2009.02.17.20.35.47;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.28.20.15.14;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2008.12.04.16.02.20;	author maja;	state Exp;
branches;
next	1.6;

1.6
date	2008.10.12.11.50.19;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2008.05.24.09.49.55;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2008.05.14.22.23.48;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2008.05.14.20.54.36;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.14.19.29.46;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2008.05.10.12.02.21;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.72
log
@Rename Debugger() into db_enter().

Using a name with the 'db_' prefix makes it invisible from the dynamic
profiler.

ok deraadt@@, kettenis@@, visa@@
@
text
@/*	$OpenBSD: machdep.c,v 1.71 2016/10/09 11:25:40 tom Exp $	*/
/*	$NetBSD: machdep.c,v 1.4 1996/10/16 19:33:11 ws Exp $	*/

/*
 * Copyright (C) 1995, 1996 Wolfgang Solfrank.
 * Copyright (C) 1995, 1996 TooLs GmbH.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/buf.h>
#include <sys/conf.h>
#include <sys/exec.h>
#include <sys/extent.h>
#include <sys/malloc.h>
#include <sys/mount.h>
#include <sys/msgbuf.h>
#include <sys/proc.h>
#include <sys/reboot.h>
#include <sys/signalvar.h>
#include <sys/syscallargs.h>
#include <sys/sysctl.h>
#include <sys/tty.h>
#include <sys/user.h>

#include <net/if.h>
#include <uvm/uvm_extern.h>

#include <machine/bus.h>
#include <machine/pio.h>
#include <powerpc/powerpc.h>
#include <machine/trap.h>

#include <dev/cons.h>

#include <dev/ic/comvar.h>

#include <dev/ofw/fdt.h>

#ifdef DDB
#include <machine/db_machdep.h>
#include <ddb/db_extern.h>
#endif

/*
 * Global variables used here and there
 */
extern struct user *proc0paddr;

struct uvm_constraint_range  dma_constraint = { 0x0, (paddr_t)-1 };
struct uvm_constraint_range *uvm_md_constraints[] = { NULL };

struct vm_map *exec_map = NULL;
struct vm_map *phys_map = NULL;

/*
 * safepri is a safe priority for sleep to set for a spin-wait
 * during autoconfiguration or after a panic.
 */
int   safepri = 0;

int ppc_malloc_ok = 0;

char *bootpath;
char bootpathbuf[512];

struct bd_info {
	unsigned long	bi_memstart;
	unsigned long	bi_memsize;
	unsigned long	bi_flashstart;
	unsigned long	bi_flashsize;
	unsigned long	bi_flashoffset;
	unsigned long	bi_sramstart;
	unsigned long	bi_sramsize;
	unsigned long	bi_immr_base;
	unsigned long	bi_bootflags;
	unsigned long	bi_ip_addr;
	unsigned char	bi_enetaddr[6];
	unsigned long	bi_ethspeed;
} bootinfo;

extern struct bd_info **fwargsave;
extern struct fdt_head *fwfdtsave;

#ifdef APERTURE
int allowaperture = 0;
#endif

void dumpsys(void);
int lcsplx(int ipl);
void myetheraddr(u_char *);

/*
 * Extent maps to manage I/O. Allocate storage for 8 regions in each,
 * initially. Later devio_malloc_safe will indicate that it's safe to
 * use malloc() to dynamically allocate region descriptors.
 */
static long devio_ex_storage[EXTENT_FIXED_STORAGE_SIZE(8) / sizeof (long)];
struct extent *devio_ex;
static int devio_malloc_safe = 0;

void initppc(u_int, u_int, char *);

void prom_printf(const char *, ...);

extern struct ppc_bus_space mainbus_bus_space;

void
initppc(u_int startkernel, u_int endkernel, char *args)
{
	extern void *trapcode; extern int trapsize;
	extern void *extint; extern int extsize;
	extern void *dsitrap; extern int dsisize;
	extern void *isitrap; extern int isisize;
	extern void *alitrap; extern int alisize;
	extern void *decrint; extern int decrsize;
	extern void *tlbimiss; extern int tlbimsize;
	extern void *tlbdlmiss; extern int tlbdlmsize;
	extern void *tlbdsmiss; extern int tlbdsmsize;
#ifdef DDB
	extern void *ddblow; extern int ddbsize;
#endif
	extern void *msgbuf_addr;
	int exc;
	void *node;

	extern char __bss_start[], __end[];
	bzero(__bss_start, __end - __bss_start);

	/* Make a copy of the args! */
	strlcpy(bootpathbuf, args ? args : "wd0a", sizeof bootpathbuf);

	if (fwfdtsave && fwfdtsave->fh_magic == FDT_MAGIC) {
		/* 
		 * Save the FDT firmware blob passed by the bootloader
		 * before we zero all memory.
		 * 
		 */
		void *fdt = (void *)endkernel;
		memcpy(fdt, fwfdtsave, fwfdtsave->fh_size);
		endkernel += fwfdtsave->fh_size;

		fdt_init(fdt);

		/*
		 * XXX Create a fake bootinfo structure if we were
		 * loaded by RouterBOOT.
		 */
		node = fdt_find_node("/memory");
		if (node) {
			char *reg;

			if (fdt_node_property(node, "reg", &reg)) {
				bootinfo.bi_memstart = *(u_int32_t *)reg;
				bootinfo.bi_memsize = *((u_int32_t *)reg + 1);
			}
		}
		node = fdt_find_node("/soc8343");
		if (node) {
			char *reg;

			if (fdt_node_property(node, "reg", &reg))
				bootinfo.bi_immr_base = *(u_int32_t *)reg;
		}
		node = fdt_find_node("/soc8343/ethernet");
		if (node) {
			char *addr;

			if (fdt_node_property(node, "mac-address", &addr))
				memcpy(bootinfo.bi_enetaddr, addr, 6);
		}
	} else {
		/*
		 * We were loaded by an old U-Boot that didn't provide
		 * a flattened device tree.  It should have provided a
		 * valid bootinfo structure which we'll use to build
		 * such a device tree ourselves.
		 *
		 * XXX We don't build a flattened device tree yet.
		 */
		memcpy(&bootinfo, *fwargsave, sizeof bootinfo);

		extern uint8_t dt_blob_start[];
		fdt_init(&dt_blob_start);
	}

	proc0.p_cpu = &cpu_info[0];
	proc0.p_addr = proc0paddr;
	bzero(proc0.p_addr, sizeof *proc0.p_addr);

	curpcb = &proc0paddr->u_pcb;

	curpm = curpcb->pcb_pmreal = curpcb->pcb_pm = pmap_kernel();

	cpu_bootstrap();

	/*
	 * Initialize pmap module.
	 */
	pmap_bootstrap(startkernel, endkernel);

	/*
	 * Set up trap vectors
	 */
	for (exc = EXC_RSVD; exc <= EXC_LAST; exc += 0x100) {
		switch (exc) {
		default:
			bcopy(&trapcode, (void *)exc, (size_t)&trapsize);
			break;
		case EXC_EXI:
			bcopy(&extint, (void *)EXC_EXI, (size_t)&extsize);
			break;
		case EXC_DSI:
			bcopy(&dsitrap, (void *)EXC_DSI, (size_t)&dsisize);
			break;
		case EXC_ISI:
			bcopy(&isitrap, (void *)EXC_ISI, (size_t)&isisize);
			break;
		case EXC_ALI:
			bcopy(&alitrap, (void *)EXC_ALI, (size_t)&alisize);
			break;
		case EXC_DECR:
			bcopy(&decrint, (void *)EXC_DECR, (size_t)&decrsize);
			break;
		case EXC_IMISS:
			bcopy(&tlbimiss, (void *)EXC_IMISS, (size_t)&tlbimsize);
			break;
		case EXC_DLMISS:
			bcopy(&tlbdlmiss, (void *)EXC_DLMISS, (size_t)&tlbdlmsize);
			break;
		case EXC_DSMISS:
			bcopy(&tlbdsmiss, (void *)EXC_DSMISS, (size_t)&tlbdsmsize);
			break;
		case EXC_PGM:
		case EXC_TRC:
		case EXC_BPT:
#if defined(DDB)
			bcopy(&ddblow, (void *)exc, (size_t)&ddbsize);
#endif
			break;
		}
	}

	syncicache((void *)EXC_RST, EXC_LAST - EXC_RST + 0x100);


	/*
	 * Now enable translation (and machine checks/recoverable interrupts).
	 */
	pmap_enable_mmu();

	/*
	 * use the memory provided by pmap_bootstrap for message buffer
	 */
	initmsgbuf(msgbuf_addr, MSGBUFSIZE);

	/*
	 * Look at arguments passed to us and compute boothowto.
	 */
	boothowto = RB_AUTOBOOT;

	/*
	 * Parse arg string.
	 */
	bootpath = &bootpathbuf[0];
	while (*++bootpath && *bootpath != ' ');
	if (*bootpath) {
		*bootpath++ = 0;
		while (*bootpath) {
			switch (*bootpath++) {
			case 'a':
				boothowto |= RB_ASKNAME;
				break;
			case 's':
				boothowto |= RB_SINGLE;
				break;
			case 'd':
				boothowto |= RB_KDB;
				break;
			case 'c':
				boothowto |= RB_CONFIG;
				break;
			default:
				break;
			}
		}
	}
	bootpath = &bootpathbuf[0];

#ifdef DDB
	ddb_init();
#endif

	/*
	 * Adjust base of internal memory mapped registers.
	 */
	mainbus_bus_space.bus_base = bootinfo.bi_immr_base;

	devio_ex = extent_create("devio", 0x80000000, 0xffffffff, M_DEVBUF,
		(caddr_t)devio_ex_storage, sizeof(devio_ex_storage),
		EX_NOCOALESCE|EX_NOWAIT);

	/*
	 * Initialize console.
	 */
	extern int comconsrate;
	comconsfreq = 266666666;
	comconsrate = 115200;
	comconsaddr = 0x00004500;
	comconsiot = &mainbus_bus_space;

	node = fdt_find_node("/chosen");
	if (node) {
		char *console;

		fdt_node_property(node, "linux,stdout-path", &console);
		node = fdt_find_node(console);
		if (node) {
			char *freq;
			char *reg;

			if (fdt_node_property(node, "clock-frequency", &freq))
				comconsfreq = *(u_int32_t *)freq;
			if (fdt_node_property(node, "reg", &reg))
				comconsaddr = *(u_int32_t *)reg;
		}
	}

	consinit();

#ifdef DDB
	if (boothowto & RB_KDB)
		db_enter();
#endif

	if (boothowto & RB_CONFIG) {
#ifdef BOOT_CONFIG
		user_config();
#else
		printf("kernel does not support -c; continuing..\n");
#endif
	}
}

void
dumpsys(void)
{
}

int cpu_imask[IPL_NUM];

int
lcsplx(int ipl)
{
	return spllower(ipl);
}

/*
 * Machine dependent startup code.
 */
void
cpu_startup()
{
	vaddr_t minaddr, maxaddr;

	proc0.p_addr = proc0paddr;

	printf("%s", version);

	printf("real mem = %lu (%luMB)\n", ptoa(physmem),
	    ptoa(physmem)/1024/1024);

	/*
	 * Allocate a submap for exec arguments.  This map effectively
	 * limits the number of processes exec'ing at any time.
	 */
	minaddr = vm_map_min(kernel_map);
	exec_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr, 16 * NCARGS,
	    VM_MAP_PAGEABLE, FALSE, NULL);

	/*
	 * Allocate a submap for physio
	 */
	phys_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    VM_PHYS_SIZE, 0, FALSE, NULL);
	ppc_malloc_ok = 1;

	printf("avail mem = %lu (%luMB)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free) / 1024 / 1024);

	/*
	 * Set up the buffers.
	 */
	bufinit();

	devio_malloc_safe = 1;
}

/*
 * consinit
 * Initialize system console.
 */
void
consinit()
{
	static int cons_initted = 0;

	if (cons_initted)
		return;
	cninit();
	cons_initted = 1;
}

/*
 * Clear registers on exec
 */
void
setregs(struct proc *p, struct exec_package *pack, u_long stack,
    register_t *retval)
{
	u_int32_t newstack;
	u_int32_t pargs;
	u_int32_t args[4];

	struct trapframe *tf = trapframe(p);
	pargs = -roundup(-stack + 8, 16);
	newstack = (u_int32_t)(pargs - 32);

	copyin ((void *)p->p_p->ps_strings, &args, 0x10);

	bzero(tf, sizeof *tf);
	tf->fixreg[1] = newstack;
	tf->fixreg[3] = retval[0] = args[1];	/* XXX */
	tf->fixreg[4] = retval[1] = args[0];	/* XXX */
	tf->fixreg[5] = args[2];		/* XXX */
	tf->fixreg[6] = args[3];		/* XXX */
	tf->srr0 = pack->ep_entry;
	tf->srr1 = PSL_MBO | PSL_USERSET | PSL_FE_DFLT;
	p->p_addr->u_pcb.pcb_flags = 0;
}

/*
 * Send a signal to process.
 */
void
sendsig(sig_t catcher, int sig, int mask, u_long code, int type,
    union sigval val)
{
	struct proc *p = curproc;
	struct trapframe *tf;
	struct sigframe *fp, frame;
	struct sigacts *psp = p->p_p->ps_sigacts;

	bzero(&frame, sizeof(frame));
	frame.sf_signum = sig;

	tf = trapframe(p);

	/*
	 * Allocate stack space for signal handler.
	 */
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0 &&
	    !sigonstack(tf->fixreg[1]) &&
	    (psp->ps_sigonstack & sigmask(sig)))
		fp = (struct sigframe *)(p->p_sigstk.ss_sp
					 + p->p_sigstk.ss_size);
	else
		fp = (struct sigframe *)tf->fixreg[1];

	fp = (struct sigframe *)((int)(fp - 1) & ~0xf);

	/*
	 * Generate signal context for SYS_sigreturn.
	 */
	frame.sf_sc.sc_mask = mask;
	frame.sf_sip = NULL;
	bcopy(tf, &frame.sf_sc.sc_frame, sizeof *tf);
	if (psp->ps_siginfo & sigmask(sig)) {
		frame.sf_sip = &fp->sf_si;
		initsiginfo(&frame.sf_si, sig, code, type, val);
	}
	frame.sf_sc.sc_cookie = (long)&fp->sf_sc ^ p->p_p->ps_sigcookie;
	if (copyout(&frame, fp, sizeof frame) != 0)
		sigexit(p, SIGILL);

	tf->fixreg[1] = (int)fp;
	tf->lr = (int)catcher;
	tf->fixreg[3] = (int)sig;
	tf->fixreg[4] = (psp->ps_siginfo & sigmask(sig)) ? (int)&fp->sf_si : 0;
	tf->fixreg[5] = (int)&fp->sf_sc;
	tf->srr0 = p->p_p->ps_sigcode;

#if WHEN_WE_ONLY_FLUSH_DATA_WHEN_DOING_PMAP_ENTER
	pmap_extract(vm_map_pmap(&p->p_vmspace->vm_map),tf->srr0, &pa);
	syncicache(pa, (p->p_p->ps_emul->e_esigcode -
	    p->p_p->ps_emul->e_sigcode));
#endif
}

/*
 * System call to cleanup state after a signal handler returns.
 */
int
sys_sigreturn(struct proc *p, void *v, register_t *retval)
{
	struct sys_sigreturn_args /* {
		syscallarg(struct sigcontext *) sigcntxp;
	} */ *uap = v;
	struct sigcontext ksc, *scp = SCARG(uap, sigcntxp);
	struct trapframe *tf;
	int error;

	if (PROC_PC(p) != p->p_p->ps_sigcoderet) {
		sigexit(p, SIGILL);
		return (EPERM);
	}

	if ((error = copyin(scp, &ksc, sizeof ksc)))
		return error;

	if (ksc.sc_cookie != ((long)scp ^ p->p_p->ps_sigcookie)) {
		sigexit(p, SIGILL);
		return (EFAULT);
	}

	/* Prevent reuse of the sigcontext cookie */
	ksc.sc_cookie = 0;
	(void)copyout(&ksc.sc_cookie, (caddr_t)scp +
	    offsetof(struct sigcontext, sc_cookie), sizeof (ksc.sc_cookie));

	tf = trapframe(p);
	if ((ksc.sc_frame.srr1 & PSL_USERSTATIC) != (tf->srr1 & PSL_USERSTATIC))
		return EINVAL;
	bcopy(&ksc.sc_frame, tf, sizeof *tf);
	p->p_sigmask = ksc.sc_mask & ~sigcantmask;
	return EJUSTRETURN;
}

/*
 * Machine dependent system variables.
 * None for now.
 */
int
cpu_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen, struct proc *p)
{
	/* all sysctl names at this level are terminal */
	if (namelen != 1)
		return ENOTDIR;
	switch (name[0]) {
	case CPU_ALLOWAPERTURE:
#ifdef APERTURE
		if (securelevel > 0)
			return (sysctl_int_lower(oldp, oldlenp, newp, newlen,
			    &allowaperture));
		else
			return (sysctl_int(oldp, oldlenp, newp, newlen,
			    &allowaperture));
#else
		return (sysctl_rdint(oldp, oldlenp, newp, 0));
#endif
	case CPU_ALTIVEC:
		return (sysctl_rdint(oldp, oldlenp, newp, 0));
	default:
		return EOPNOTSUPP;
	}
}

u_long dumpmag = 0x04959fca;			/* magic number */
int dumpsize = 0;			/* size of dump in pages */
long dumplo = -1;			/* blocks */

/*
 * This is called by configure to set dumplo and dumpsize.
 * Dumps always skip the first CLBYTES of disk space
 * in case there might be a disk label stored there.
 * If there is extra space, put dump at the end to
 * reduce the chance that swapping trashes it.
 */
void dumpconf(void);

void
dumpconf(void)
{
	int nblks;	/* size of dump area */
	int i;

	if (dumpdev == NODEV ||
	    (nblks = (bdevsw[major(dumpdev)].d_psize)(dumpdev)) == 0)
		return;
	if (nblks <= ctod(1))
		return;

	/* Always skip the first block, in case there is a label there. */
	if (dumplo < ctod(1))
		dumplo = ctod(1);

        for (i = 0; i < ndumpmem; i++)
		dumpsize = max(dumpsize, dumpmem[i].end);

	/* Put dump at end of partition, and make it fit. */
	if (dumpsize > dtoc(nblks - dumplo - 1))
		dumpsize = dtoc(nblks - dumplo - 1);
	if (dumplo < nblks - ctod(dumpsize) - 1)
		dumplo = nblks - ctod(dumpsize) - 1;

}

#define BYTES_PER_DUMP  (PAGE_SIZE)  /* must be a multiple of pagesize */
static vaddr_t dumpspace;

int
reserve_dumppages(caddr_t p)
{
	dumpspace = (vaddr_t)p;
	return BYTES_PER_DUMP;
}

/*
 * Halt or reboot the machine after syncing/dumping according to howto.
 */
__dead void
boot(int howto)
{
	static int syncing;

	if (cold) {
		if ((howto & RB_USERREQ) == 0)
			howto |= RB_HALT;
		goto haltsys;
	}

	boothowto = howto;
	if ((howto & RB_NOSYNC) == 0 && !syncing) {
		syncing = 1;
		vfs_shutdown();

		if ((howto & RB_TIMEBAD) == 0) {
			resettodr();
		} else {
			printf("WARNING: not updating battery clock\n");
		}
	}
	if_downall();

	uvm_shutdown();
	splhigh();
	cold = 1;

	if ((howto & RB_DUMP) != 0)
		dumpsys();

haltsys:
	config_suspend_all(DVACT_POWERDOWN);

	if ((howto & RB_HALT) != 0) {
		if ((howto & RB_POWERDOWN) != 0) {
			;
		}

		printf("halted\n\n");
		for (;;)
			continue;
		/* NOTREACHED */
	}
	printf("rebooting\n\n");

	{
		volatile int32_t *reset;
		int32_t v;

		reset = mapiodev(0xe0000900, 0x100);
		reset[6] = 0x52535445;
		v = reset[6];
		reset[7] = 0x00000002;
	}

	printf("boot failed, spinning\n");
	for (;;)
		continue;
	/* NOTREACHED */
}

/*
 * Notify the current process (p) that it has a signal pending,
 * process as soon as possible.
 */
void
signotify(struct proc *p)
{
	aston(p);
}

/* bcopy(), error on fault */
int
kcopy(const void *from, void *to, size_t size)
{
	faultbuf env;
	void *oldh = curproc->p_addr->u_pcb.pcb_onfault;

	if (setfault(&env)) {
		curproc->p_addr->u_pcb.pcb_onfault = oldh;
		return EFAULT;
	}
	bcopy(from, to, size);
	curproc->p_addr->u_pcb.pcb_onfault = oldh;

	return 0;
}

struct mem_region uboot_mem[2], uboot_avail[4];

void
ppc_mem_regions(struct mem_region **memp, struct mem_region **availp)
{
	uboot_mem[0].start = bootinfo.bi_memstart;
	uboot_mem[0].size = bootinfo.bi_memsize;

	/* Reserve memory used for exception vectors. */
	uboot_avail[0] = uboot_mem[0];
	if (uboot_mem[0].start < EXC_LAST + 0x100) {
		uboot_avail[0].size -= (EXC_LAST + 0x100 - uboot_mem[0].start);
		uboot_avail[0].start = EXC_LAST + 0x100;
	}

	*memp = uboot_mem;
	*availp = uboot_avail;
}

void
myetheraddr(u_char *cp)
{
	bcopy(bootinfo.bi_enetaddr, cp, sizeof bootinfo.bi_enetaddr);
	bootinfo.bi_enetaddr[5]++;
}

/* prototype for locore function */
void cpu_switchto_asm(struct proc *oldproc, struct proc *newproc);

void cpu_switchto(struct proc *oldproc, struct proc *newproc)
{
	cpu_switchto_asm(oldproc, newproc);
}
@


1.71
log
@Apply consistency to forever loops with continue and NOTREACHED

Same thought from kettenis@@, ok krw@@ phessler@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.70 2016/09/18 14:28:25 deraadt Exp $	*/
d358 1
a358 1
		Debugger();
@


1.70
log
@option INSECURE is obsolete
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.69 2016/05/23 18:14:47 deraadt Exp $	*/
d687 3
a689 1
		for (;;);
d704 2
a705 1
	for (;;) ;
@


1.69
log
@repair typo of sizeof in copyin()
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.68 2016/05/21 00:56:44 deraadt Exp $	*/
a110 3
#ifdef INSECURE
int allowaperture = 1;
#else
a111 1
#endif
@


1.68
log
@hand-massage sendsig() and sys_sigreturn() to be much more similar.
ok guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.67 2016/05/11 20:19:01 deraadt Exp $	*/
d547 1
a547 1
	if ((error = copyin(scp, &ksc, sizeof sc)))
@


1.67
log
@fix sigcookie value, address was off due to trapframe nesting
notice by miod
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.66 2016/05/10 18:39:48 deraadt Exp $	*/
d538 1
a538 1
	struct sigcontext sc, *scp = SCARG(uap, sigcntxp);
a542 2
		printf("%s(%d): sigreturn not from tramp [pc 0x%x 0x%lx]\n",
		    p->p_comm, p->p_pid, PROC_PC(p), p->p_p->ps_sigcoderet);
d547 1
a547 1
	if ((error = copyin(scp, &sc, sizeof sc)))
d550 1
a550 4
	if (sc.sc_cookie != ((long)scp ^ p->p_p->ps_sigcookie)) {
		printf("%s(%d): cookie %lx should have been %lx\n",
		    p->p_comm, p->p_pid, sc.sc_cookie,
		    (long)scp ^ p->p_p->ps_sigcookie);
d556 3
a558 4
	sc.sc_cookie = 0;
	(void)copyout(&sc.sc_cookie, (caddr_t)scp +
	    offsetof(struct sigcontext, sc_cookie),
	    sizeof (sc.sc_cookie));
d561 1
a561 1
	if ((sc.sc_frame.srr1 & PSL_USERSTATIC) != (tf->srr1 & PSL_USERSTATIC))
d563 2
a564 2
	bcopy(&sc.sc_frame, tf, sizeof *tf);
	p->p_sigmask = sc.sc_mask & ~sigcantmask;
@


1.66
log
@SROP mitigation.  sendsig() stores a (per-process ^ &sigcontext) cookie
inside the sigcontext.  sigreturn(2) checks syscall entry was from the
exact PC addr in the (per-process ASLR) sigtramp, verifies the cookie,
and clears it to prevent sigcontext reuse.
not yet tested on landisk, sparc, *88k, socppc.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.65 2016/03/03 02:42:16 bmercer Exp $	*/
d511 1
a511 1
	frame.sf_sc.sc_cookie = (long)fp ^ p->p_p->ps_sigcookie;
a513 1

@


1.65
log
@Move fdt to a more centralized location so it can be used by arm as well. Diff from Patrick Wildt. Tested and OK dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.64 2015/03/31 16:00:38 mpi Exp $	*/
d511 1
d539 1
a539 1
	struct sigcontext sc;
d543 8
a550 1
	if ((error = copyin(SCARG(uap, sigcntxp), &sc, sizeof sc)))
d552 15
@


1.64
log
@Make it possisble to disable block address translation mechanism on
processors that support it.

Due to the way trap code is patched it is currently not possible to
enabled/disable BAT at runtime.

ok miod@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.63 2015/03/01 17:22:17 miod Exp $	*/
a54 1
#include <machine/fdt.h>
d62 2
@


1.63
log
@Fix setregs() to correctly use ps_strings. ok kettenis@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.62 2015/01/20 18:34:00 mpi Exp $	*/
a53 1
#include <machine/bat.h>
a76 2
struct bat battable[16];

d152 1
a152 1
	int exc, scratch;
d223 1
a223 1
	ppc_check_procid();
d226 1
a226 2
	 * Initialize BAT registers to unmapped to not generate
	 * overlapping mappings below.
d228 1
a228 37
	ppc_mtibat0u(0);
	ppc_mtibat1u(0);
	ppc_mtibat2u(0);
	ppc_mtibat3u(0);
	ppc_mtibat4u(0);
	ppc_mtibat5u(0);
	ppc_mtibat6u(0);
	ppc_mtibat7u(0);
	ppc_mtdbat0u(0);
	ppc_mtdbat1u(0);
	ppc_mtdbat2u(0);
	ppc_mtdbat3u(0);
	ppc_mtdbat4u(0);
	ppc_mtdbat5u(0);
	ppc_mtdbat6u(0);
	ppc_mtdbat7u(0);

	/*
	 * Set up initial BAT table to only map the lowest 256 MB area
	 */
	battable[0].batl = BATL(0x00000000, BAT_M);
	 /* XXX only map 128MB for now */
	battable[0].batu = BATU(0x00000000, BAT_BL_128M);

	/*
	 * Now setup fixed bat registers
	 *
	 * Note that we still run in real mode, and the BAT
	 * registers were cleared above.
	 */
	/* DBAT0 used for initial 256 MB segment */
	ppc_mtdbat0l(battable[0].batl);
	ppc_mtdbat0u(battable[0].batu);

	/* IBAT0 only covering the kernel .text */
	ppc_mtibat0l(battable[0].batl);
	ppc_mtibat0u(BATU(0x00000000, BAT_BL_8M));
a274 38
	uvmexp.pagesize = 4096;
	uvm_setpagesize();

	/*
	 * Initialize pmap module.
	 */
	pmap_bootstrap(startkernel, endkernel);

	/* now that we know physmem size, map physical memory with BATs */
	if (physmem > atop(0x10000000)) {
		battable[0x1].batl = BATL(0x10000000, BAT_M);
		battable[0x1].batu = BATU(0x10000000, BAT_BL_256M);
	}
	if (physmem > atop(0x20000000)) {
		battable[0x2].batl = BATL(0x20000000, BAT_M);
		battable[0x2].batu = BATU(0x20000000, BAT_BL_256M);
	}
	if (physmem > atop(0x30000000)) {
		battable[0x3].batl = BATL(0x30000000, BAT_M);
		battable[0x3].batu = BATU(0x30000000, BAT_BL_256M);
	}
	if (physmem > atop(0x40000000)) {
		battable[0x4].batl = BATL(0x40000000, BAT_M);
		battable[0x4].batu = BATU(0x40000000, BAT_BL_256M);
	}
	if (physmem > atop(0x50000000)) {
		battable[0x5].batl = BATL(0x50000000, BAT_M);
		battable[0x5].batu = BATU(0x50000000, BAT_BL_256M);
	}
	if (physmem > atop(0x60000000)) {
		battable[0x6].batl = BATL(0x60000000, BAT_M);
		battable[0x6].batu = BATU(0x60000000, BAT_BL_256M);
	}
	if (physmem > atop(0x70000000)) {
		battable[0x7].batl = BATL(0x70000000, BAT_M);
		battable[0x7].batu = BATU(0x70000000, BAT_BL_256M);
	}

d278 1
a278 2
	__asm__ volatile ("eieio; mfmsr %0; ori %0,%0,%1; mtmsr %0; sync;isync"
		      : "=r"(scratch) : "K"(PSL_IR|PSL_DR|PSL_ME|PSL_RI));
@


1.62
log
@Merge two copies of the (almost) identical bus space code into one file.

This brings bus_space_mmap(9) to socppc and change its bus_space_map(9)
implementation to use kernel_map instead of phys_map like macppc and
everybody else.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.61 2015/01/04 13:01:42 mpi Exp $	*/
d536 1
a536 1
	copyin ((void *)(VM_MAX_ADDRESS-0x10), &args, 0x10);
@


1.61
log
@Implement splassert(9) for powerpc.

This changes the logic to prevent a recursion when processing soft
interrupts.  Previously a per-CPU flag was set before re-enabling
interrupts.  Now the IPL level is raised to SOFTTTY which makes
splsoftassert() happy, greatly inspired by mips64.

As a side effect, the ppc_intr_{disable,enable}() dance is now done
only once instead of twice per splx(9).

While here, make use of dosoftint() instead of having 3 different
functions for dispatching soft interrupts.

Tested by deraadt@@ on G4 smp and by myself G5 smp, G3, G4 and socppc.

No objection from the usual (and over busy) suspects.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.60 2014/12/10 15:29:53 mikeb Exp $	*/
a123 4
int bus_mem_add_mapping(bus_addr_t, bus_size_t, int, bus_space_handle_t *);
bus_addr_t bus_space_unmap_p(bus_space_tag_t, bus_space_handle_t,  bus_size_t);
void bus_space_unmap(bus_space_tag_t, bus_space_handle_t, bus_size_t);

a462 311
}

/* BUS functions */
int
bus_space_map(bus_space_tag_t t, bus_addr_t bpa, bus_size_t size,
    int flags, bus_space_handle_t *bshp)
{
	int error;

	if  (POWERPC_BUS_TAG_BASE(t) == 0) {
		/* if bus has base of 0 fail. */
		return EINVAL;
	}
	bpa |= POWERPC_BUS_TAG_BASE(t);
	if ((error = extent_alloc_region(devio_ex, bpa, size, EX_NOWAIT |
	    (ppc_malloc_ok ? EX_MALLOCOK : 0))))
		return error;

	if ((error = bus_mem_add_mapping(bpa, size, flags, bshp))) {
		if (extent_free(devio_ex, bpa, size, EX_NOWAIT |
			(ppc_malloc_ok ? EX_MALLOCOK : 0)))
		{
			printf("bus_space_map: pa 0x%lx, size 0x%lx\n",
				bpa, size);
			printf("bus_space_map: can't free region\n");
		}
	}
	return 0;
}

bus_addr_t
bus_space_unmap_p(bus_space_tag_t t, bus_space_handle_t bsh, bus_size_t size)
{
	bus_addr_t paddr;

	pmap_extract(pmap_kernel(), bsh, &paddr);
	bus_space_unmap((t), (bsh), (size));
	return paddr ;
}

void
bus_space_unmap(bus_space_tag_t t, bus_space_handle_t bsh, bus_size_t size)
{
	bus_addr_t sva;
	bus_size_t off, len;
	bus_addr_t bpa;

	/* should this verify that the proper size is freed? */
	sva = trunc_page(bsh);
	off = bsh - sva;
	len = size+off;

	if (pmap_extract(pmap_kernel(), sva, &bpa) == TRUE) {
		if (extent_free(devio_ex, bpa | (bsh & PAGE_MASK), size, EX_NOWAIT |
			(ppc_malloc_ok ? EX_MALLOCOK : 0)))
		{
			printf("bus_space_map: pa 0x%lx, size 0x%lx\n",
				bpa, size);
			printf("bus_space_map: can't free region\n");
		}
	}
	/* do not free memory which was stolen from the vm system */
	if (ppc_malloc_ok &&
	    ((sva >= VM_MIN_KERNEL_ADDRESS) && (sva < VM_MAX_KERNEL_ADDRESS)))
		uvm_km_free(phys_map, sva, len);
	else {
		pmap_remove(pmap_kernel(), sva, sva+len);
		pmap_update(pmap_kernel());
	}
}

vaddr_t ppc_kvm_stolen = VM_KERN_ADDRESS_SIZE;

int
bus_mem_add_mapping(bus_addr_t bpa, bus_size_t size, int flags,
    bus_space_handle_t *bshp)
{
	bus_addr_t vaddr;
	bus_addr_t spa, epa;
	bus_size_t off;
	int len;

	spa = trunc_page(bpa);
	epa = bpa + size;
	off = bpa - spa;
	len = size+off;

#if 0
	if (epa <= spa) {
		panic("bus_mem_add_mapping: overflow");
	}
#endif
	if (ppc_malloc_ok == 0) {
		bus_size_t alloc_size;

		/* need to steal vm space before kernel vm is initialized */
		alloc_size = round_page(len);

		vaddr = VM_MIN_KERNEL_ADDRESS + ppc_kvm_stolen;
		ppc_kvm_stolen += alloc_size;
		if (ppc_kvm_stolen > PPC_SEGMENT_LENGTH) {
			panic("ppc_kvm_stolen, out of space");
		}
	} else {
		vaddr = uvm_km_kmemalloc(phys_map, NULL, len,
		    UVM_KMF_NOWAIT|UVM_KMF_VALLOC);
		if (vaddr == 0)
			return (ENOMEM);
	}
	*bshp = vaddr + off;
#ifdef DEBUG_BUS_MEM_ADD_MAPPING
	printf("mapping %x size %x to %x vbase %x\n",
		bpa, size, *bshp, spa);
#endif
	for (; len > 0; len -= PAGE_SIZE) {
		pmap_kenter_cache(vaddr, spa, PROT_READ | PROT_WRITE,
		    (flags & BUS_SPACE_MAP_CACHEABLE) ?
		      PMAP_CACHE_WT : PMAP_CACHE_CI);
		spa += PAGE_SIZE;
		vaddr += PAGE_SIZE;
	}
	return 0;
}

int
bus_space_alloc(bus_space_tag_t tag, bus_addr_t rstart, bus_addr_t rend,
    bus_size_t size, bus_size_t alignment, bus_size_t boundary, int flags,
    bus_addr_t *addrp, bus_space_handle_t *handlep)
{

	panic("bus_space_alloc: unimplemented");
}

void
bus_space_free(bus_space_tag_t tag, bus_space_handle_t handle, bus_size_t size)
{

	panic("bus_space_free: unimplemented");
}

void *
mapiodev(paddr_t pa, psize_t len)
{
	paddr_t spa;
	vaddr_t vaddr, va;
	int off;
	int size;

	spa = trunc_page(pa);
	off = pa - spa;
	size = round_page(off+len);
	if (ppc_malloc_ok == 0) {
		/* need to steal vm space before kernel vm is initialized */
		va = VM_MIN_KERNEL_ADDRESS + ppc_kvm_stolen;
		ppc_kvm_stolen += size;
		if (ppc_kvm_stolen > PPC_SEGMENT_LENGTH) {
			panic("ppc_kvm_stolen, out of space");
		}
	} else {
		va = uvm_km_kmemalloc(phys_map, NULL, size,
		    UVM_KMF_NOWAIT|UVM_KMF_VALLOC);
	}

	if (va == 0)
		return NULL;

	for (vaddr = va; size > 0; size -= PAGE_SIZE) {
		pmap_kenter_cache(vaddr, spa,
		    PROT_READ | PROT_WRITE, PMAP_CACHE_DEFAULT);
		spa += PAGE_SIZE;
		vaddr += PAGE_SIZE;
	}
	return (void *) (va+off);
}

void
unmapiodev(void *kva, psize_t p_size)
{
	vaddr_t vaddr;
	int size;

	size = p_size;

	vaddr = trunc_page((vaddr_t)kva);

	uvm_km_free_wakeup(phys_map, vaddr, size);

	for (; size > 0; size -= PAGE_SIZE) {
		pmap_remove(pmap_kernel(), vaddr,  vaddr+PAGE_SIZE-1);
		vaddr += PAGE_SIZE;
	}
	pmap_update(pmap_kernel());
}


/*
 * probably should be ppc_space_copy
 */

#define _CONCAT(A,B) A ## B
#define __C(A,B)	_CONCAT(A,B)

#define BUS_SPACE_COPY_N(BYTES,TYPE)					\
void									\
__C(bus_space_copy_,BYTES)(void *v, bus_space_handle_t h1,		\
    bus_size_t o1, bus_space_handle_t h2, bus_size_t o2,		\
    bus_size_t c)							\
{									\
	TYPE *src, *dst;						\
	int i;								\
									\
	src = (TYPE *) (h1+o1);						\
	dst = (TYPE *) (h2+o2);						\
									\
	if (h1 == h2 && o2 > o1)					\
		for (i = c-1; i >= 0; i--)				\
			dst[i] = src[i];				\
	else								\
		for (i = 0; i < c; i++)					\
			dst[i] = src[i];				\
}
BUS_SPACE_COPY_N(1,u_int8_t)
BUS_SPACE_COPY_N(2,u_int16_t)
BUS_SPACE_COPY_N(4,u_int32_t)

void
bus_space_set_region_1(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
    u_int8_t val, bus_size_t c)
{
	u_int8_t *dst;
	int i;

	dst = (u_int8_t *) (h+o);

	for (i = 0; i < c; i++)
		dst[i] = val;
}

void
bus_space_set_region_2(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
    u_int16_t val, bus_size_t c)
{
	u_int16_t *dst;
	int i;

	dst = (u_int16_t *) (h+o);
	val = swap16(val);

	for (i = 0; i < c; i++)
		dst[i] = val;
}
void
bus_space_set_region_4(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
    u_int32_t val, bus_size_t c)
{
	u_int32_t *dst;
	int i;

	dst = (u_int32_t *) (h+o);
	val = swap32(val);

	for (i = 0; i < c; i++)
		dst[i] = val;
}

#define BUS_SPACE_READ_RAW_MULTI_N(BYTES,SHIFT,TYPE)			\
void									\
__C(bus_space_read_raw_multi_,BYTES)(bus_space_tag_t bst,		\
    bus_space_handle_t h, bus_addr_t o, u_int8_t *dst, bus_size_t size)	\
{									\
	TYPE *src;							\
	TYPE *rdst = (TYPE *)dst;					\
	int i;								\
	int count = size >> SHIFT;					\
									\
	src = (TYPE *)(h+o);						\
	for (i = 0; i < count; i++) {					\
		rdst[i] = *src;						\
		__asm__("eieio");					\
	}								\
}
BUS_SPACE_READ_RAW_MULTI_N(2,1,u_int16_t)
BUS_SPACE_READ_RAW_MULTI_N(4,2,u_int32_t)

#define BUS_SPACE_WRITE_RAW_MULTI_N(BYTES,SHIFT,TYPE)			\
void									\
__C(bus_space_write_raw_multi_,BYTES)( bus_space_tag_t bst,		\
    bus_space_handle_t h, bus_addr_t o, const u_int8_t *src,		\
    bus_size_t size)							\
{									\
	int i;								\
	TYPE *dst;							\
	TYPE *rsrc = (TYPE *)src;					\
	int count = size >> SHIFT;					\
									\
	dst = (TYPE *)(h+o);						\
	for (i = 0; i < count; i++) {					\
		*dst = rsrc[i];						\
		__asm__("eieio");					\
	}								\
}

BUS_SPACE_WRITE_RAW_MULTI_N(2,1,u_int16_t)
BUS_SPACE_WRITE_RAW_MULTI_N(4,2,u_int32_t)

int
bus_space_subregion(bus_space_tag_t t, bus_space_handle_t bsh,
    bus_size_t offset, bus_size_t size, bus_space_handle_t *nbshp)
{
	*nbshp = bsh + offset;
	return (0);
@


1.60
log
@retire shutdown hooks; ok deraadt, krw
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.59 2014/11/16 12:30:58 deraadt Exp $	*/
a1084 37
}

void
do_pending_int(void)
{
	struct cpu_info *ci = curcpu();
	int pcpl = ci->ci_cpl; /* XXX */
	int s;
	s = ppc_intr_disable();
	if (ci->ci_flags & CI_FLAGS_PROCESSING_SOFT) {
		ppc_intr_enable(s);
		return;
	}
	atomic_setbits_int(&ci->ci_flags, CI_FLAGS_PROCESSING_SOFT);

	do {
		if((ci->ci_ipending & SI_TO_IRQBIT(SI_SOFTCLOCK)) &&
		    (pcpl < IPL_SOFTCLOCK)) {
 			ci->ci_ipending &= ~SI_TO_IRQBIT(SI_SOFTCLOCK);
			softintr_dispatch(SI_SOFTCLOCK);
 		}
		if((ci->ci_ipending & SI_TO_IRQBIT(SI_SOFTNET)) &&
		    (pcpl < IPL_SOFTNET)) {
			ci->ci_ipending &= ~SI_TO_IRQBIT(SI_SOFTNET);
			softintr_dispatch(SI_SOFTNET);
		}
		if((ci->ci_ipending & SI_TO_IRQBIT(SI_SOFTTTY)) &&
		    (pcpl < IPL_SOFTTTY)) {
			ci->ci_ipending &= ~SI_TO_IRQBIT(SI_SOFTTTY);
			softintr_dispatch(SI_SOFTTTY);
		}

	} while (ci->ci_ipending & ppc_smask[pcpl]);
	splx(pcpl);
	ppc_intr_enable(s);

	atomic_clearbits_int(&ci->ci_flags, CI_FLAGS_PROCESSING_SOFT);
@


1.59
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.58 2014/10/27 21:56:57 kettenis Exp $	*/
a1059 1
	doshutdownhooks();
@


1.58
log
@Remove the spilling code for IBAT register and set up the first IBAT register
to cover the first 8 MB of memory such that it covers kernel .text and not
much else.  This is a first step towards W^X in the kernel for machines
with G4 and older processors.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.57 2014/09/19 17:34:05 kettenis Exp $	*/
d582 1
a582 1
		pmap_kenter_cache(vaddr, spa, VM_PROT_READ | VM_PROT_WRITE,
d635 1
a635 1
			VM_PROT_READ | VM_PROT_WRITE, PMAP_CACHE_DEFAULT);
@


1.57
log
@Use config_suspend_all(9).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.56 2014/09/06 10:45:29 mpi Exp $	*/
d257 2
a258 5
#if 0
	battable[0].batu = BATU(0x00000000);
#else
	battable[0].batu = 0x0ffe; /* XXX only map 128MB for now */
#endif
d266 1
a266 5
	/* IBAT0 used for initial 256 MB segment */
	ppc_mtibat0l(battable[0].batl);
	ppc_mtibat0u(battable[0].batu);

	/* DBAT0 used similar */
d270 4
d330 1
a330 1
		battable[0x1].batu = BATU(0x10000000);
d334 1
a334 1
		battable[0x2].batu = BATU(0x20000000);
d338 1
a338 1
		battable[0x3].batu = BATU(0x30000000);
d342 1
a342 1
		battable[0x4].batu = BATU(0x40000000);
d346 1
a346 1
		battable[0x5].batu = BATU(0x50000000);
d350 1
a350 1
		battable[0x6].batu = BATU(0x60000000);
d354 1
a354 1
		battable[0x7].batu = BATU(0x70000000);
@


1.56
log
@Rename ci_iactive into ci_flags, this field now holds the going-to-
sleep bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.55 2014/07/21 17:25:47 uebayasi Exp $	*/
a1034 1
	struct device *mainbus;
d1064 1
a1064 3
	mainbus = device_mainbus();
	if (mainbus != NULL)
		config_suspend(mainbus, DVACT_POWERDOWN);
@


1.55
log
@boot(9): Reduce annoying style diffs

- Always use either: ((x & RB_XXX) != 0) or ((x & RB_XXX) == 0) in boolean
  context (mostly if (x), or x ? y : z)
  - prom_halt() in alpha is confirmed to take int as boolean

Converted by coccinelle.  No functional change intended.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1101 1
a1101 1
	if (ci->ci_iactive & CI_IACTIVE_PROCESSING_SOFT) {
d1105 1
a1105 1
	atomic_setbits_int(&ci->ci_iactive, CI_IACTIVE_PROCESSING_SOFT);
d1128 1
a1128 1
	atomic_clearbits_int(&ci->ci_iactive, CI_IACTIVE_PROCESSING_SOFT);
@


1.54
log
@boot(9): Cosmetic changes to improve diff'ability.
@
text
@d1069 2
a1070 2
	if (howto & RB_HALT) {
		if ((howto & RB_POWERDOWN) == RB_POWERDOWN) {
@


1.53
log
@Cosmetic changes to reduce diffs.
@
text
@d1044 1
a1044 1
	if (!(howto & RB_NOSYNC) && !syncing) {
d1060 1
a1060 1
	if ((howto & RB_DUMP))
d1090 2
a1091 1
	while(1) /* forever */;
@


1.52
log
@Set cold to 1 before executing the DVACT_POWERDOWN handlers when halting or
rebooting a machine, like it is done in the hibernate case.

At least some USB host controller drivers rely on this to busy way instead
of sleeping.  Avoid a panic on macppc with an uhci(4) cardbus plugged in.

ok deraadt@@, uebayashi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.51 2014/07/10 20:15:27 uebayasi Exp $	*/
d1046 1
a1046 1
		vfs_shutdown();		/* sync */
@


1.51
log
@boot(9): Remove comments about RB_*, "cold", and savectx()

Again remove slightly different comments to reduce diffs.  These will be
re-added once boot() become MI and its specification is clearly re-defined.

OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1058 1
@


1.50
log
@boot(): Remove comments about RB_TIMEBAD to reduce diffs

RB_TIMEBAD is documented well enough that the comment is not needed.  sparc64
does slightly different and its comment is left with XXX.

OK deraadt@@ miod@@
@
text
@a1037 4
		/*
		 * If the system is cold, just halt, unless the user
		 * explicitly asked for reboot.
		 */
@


1.49
log
@boot(): Unify declarations

OK deraadt@@
@
text
@a1051 5
		/*
		 * If we've been adjusting the clock, the todr
		 * will be out of synch; adjust it now unless
		 * the system was sitting in ddb.
		 */
@


1.48
log
@Revert previous diff setting cold to 1 on shutdown because it breaks machine
with softraid(4) disks.

softraid(4) is the last real consumer of the doshutdownhooks(9) API and it is
not trivial to convert its hook to a DVACT_POWERDOWN handler since the latter
does not allow to sleep.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.47 2014/05/30 13:46:16 mpi Exp $	*/
d1031 1
a1031 1
void
@


1.47
log
@Set cold to 1 before executing the DVACT_POWERDOWN handlers when halting or
rebooting a machine, like it is done in the hibernate case.

At least some USB host controller drivers rely on this to busy way instead
of sleeping.  Avoid a panic on macppc with an uhci(4) cardbus plugged in.

ok deraadt@@, uebayashi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.46 2014/05/09 18:16:15 miod Exp $	*/
a1066 1
	cold = 1;
@


1.46
log
@Format string fixes and removal of -Wno-format for *ppc kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.45 2014/04/01 20:42:39 mpi Exp $	*/
d1067 1
@


1.45
log
@Remove the almost unused abstraction around "struct firmware" and use
instead a single function ppc_mem_regions() required by the ppc pmap.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.44 2014/03/31 18:58:41 mpi Exp $	*/
d492 1
a492 1
			printf("bus_space_map: pa 0x%lx, size 0x%x\n",
d526 1
a526 1
			printf("bus_space_map: pa 0x%lx, size 0x%x\n",
d795 1
a795 1
	printf("real mem = %u (%uMB)\n", ptoa(physmem),
@


1.44
log
@Including <uvm/uvm_extern.h> is enough, no need for <uvm/uvm.h> or more.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.43 2014/03/26 05:23:42 guenther Exp $	*/
d58 1
a58 1
#include <machine/powerpc.h>
a111 12
void uboot_mem_regions(struct mem_region **, struct mem_region **);
void uboot_vmon(void);

struct firmware uboot_firmware = {
	uboot_mem_regions,
	NULL,
	NULL,
	uboot_vmon
};

struct firmware *fw = &uboot_firmware;

a362 2
	(fw->vmon)();

d1019 1
a1019 1
vaddr_t dumpspace;
d1083 1
a1083 1
		(fw->exit)();
d1168 1
a1168 1
uboot_mem_regions(struct mem_region **memp, struct mem_region **availp)
a1181 5
}

void
uboot_vmon(void)
{
@


1.43
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.42 2014/03/23 15:28:10 kettenis Exp $	*/
d52 1
a52 1
#include <uvm/uvm.h>
@


1.42
log
@Initialize additional BATs (IBAT4-IBAT7 and DBAT4-IBAT7).  The rb600 firmware
has these enabled and this leads to memory corruption that (surprisingly)
only shows up when running PIE.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.41 2014/03/22 06:05:45 guenther Exp $	*/
d930 1
a930 1
	tf->srr0 = p->p_sigcode;
d934 2
a935 1
	syncicache(pa, (p->p_emul->e_esigcode - p->p_emul->e_sigcode));
@


1.41
log
@Move p_sigacts from struct proc to struct process.

testing help mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.40 2014/03/13 03:52:55 dlg Exp $	*/
d252 4
d260 4
@


1.40
log
@get rid of the assumption that the head of the alldevs list is the
"mainbus" device. this breaks when mpath is enabled because it
attaches before mainbus and therefore takes the head position.

have autoconf provide device_mainbus() which looks up mainbus_cd,
and use that instead.

discussed with deraadt who just wants mpath stuff to move forward
despite there being many ways to shine this particular turd.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.39 2014/01/06 16:17:33 uebayasi Exp $	*/
d883 1
a883 1
	struct sigacts *psp = p->p_sigacts;
@


1.39
log
@Make macppc/socppc boot() code path more similar to others.

This changes calling boot() during (cold != 0) to not call if_downall() and
uvm_shutdown().  Both of which must not be specific to PowerPC.

OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1040 1
d1078 3
a1080 2
	if (!TAILQ_EMPTY(&alldevs))
		config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.38
log
@Normalize code sequence around dumpsys(), doshutdownhooks(), and
config_suspend() in ppc boot() functions.  Always go through them regardless
of (howto & RB_HALT).

OK deraadt@@ mpi@@
@
text
@d1041 10
d1052 1
a1052 1
	if (!cold && !(howto & RB_NOSYNC) && !syncing) {
d1072 1
a1072 1
	if (!cold && (howto & RB_DUMP))
d1074 2
@


1.37
log
@In boot(), do not iterate over alldevs if it's empty (i.e. halting from ddb
with ddb entered early with boot -d or from UKC).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.36 2012/12/02 07:03:31 guenther Exp $	*/
d1061 7
a1068 3
		doshutdownhooks();
		if (!TAILQ_EMPTY(&alldevs))
			config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
a1075 5
	if (!cold && (howto & RB_DUMP))
		dumpsys();
	doshutdownhooks();
	if (!TAILQ_EMPTY(&alldevs))
		config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.36
log
@Determine whether we're currently on the alternative signal stack
dynamically, by comparing the stack pointer against the altstack
base and size, so that you get the correct answer if you longjmp
out of the signal handler, as tested by regress/sys/kern/stackjmp/.
Also, fix alt stack handling on vax, where it was completely broken.

Testing and corrections by miod@@, krw@@, tobiasu@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.35 2012/10/08 21:47:50 deraadt Exp $	*/
d1063 2
a1064 1
		config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
d1075 2
a1076 1
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.35
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.34 2012/03/14 21:56:46 kettenis Exp $	*/
a883 1
	int oldonstack;
d885 1
a888 1
	oldonstack = p->p_sigstk.ss_flags & SS_ONSTACK;
d893 3
a895 3
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0
	    && !oldonstack
	    && (psp->ps_sigonstack & sigmask(sig))) {
d898 1
a898 2
		p->p_sigstk.ss_flags |= SS_ONSTACK;
	} else
a905 1
	frame.sf_sc.sc_onstack = oldonstack;
a948 4
	if (sc.sc_onstack & 1)
		p->p_sigstk.ss_flags |= SS_ONSTACK;
	else
		p->p_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.34
log
@Fix booting on the Thecus N1200.  From Tobias Ulmer.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.33 2011/08/29 20:21:44 drahn Exp $	*/
d1070 1
d1081 1
@


1.33
log
@Return of the long missing powerpc interrupt rewrite.  Was working for
several weeks before release on macppc, socppc bugs just fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.32 2011/07/05 04:48:02 guenther Exp $	*/
a179 15
	if (fwfdtsave == NULL) {
		/*
		 * We were loaded by an old U-Boot that didn't provide
		 * a flattened device tree.  It should have provided a
		 * valid bootinfo structure which we'll use to build
		 * such a device tree ourselves.
		 *
		 * XXX We don't build a flattened device tree yet.
		 */
		memcpy(&bootinfo, *fwargsave, sizeof bootinfo);

		extern uint8_t dt_blob_start[];
		fdt_init(&dt_blob_start);
	}

d219 13
@


1.32
log
@Recommit the reverted sigacts change now that the NFS use-after-free
problem has been tracked down.  This fixes the sharing of the signal
handling state: shared bits go in sigacts, per-rthread bits goes in
struct proc.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.31 2011/06/26 22:40:00 deraadt Exp $	*/
a1097 2
extern void ipic_do_pending_int(void);

d1102 5
a1106 3
	int pcpl, s;

	if (ci->ci_iactive)
d1108 2
a1109 6

	ci->ci_iactive = 1;
	s = ppc_intr_disable();
	pcpl = ci->ci_cpl;

	ipic_do_pending_int();
d1112 3
a1114 5
		if((ci->ci_ipending & SINT_CLOCK) & ~pcpl) {
			ci->ci_ipending &= ~SINT_CLOCK;
			ci->ci_cpl = SINT_CLOCK|SINT_NET|SINT_TTY;
			ppc_intr_enable(1);
			KERNEL_LOCK();
d1116 4
a1119 9
			KERNEL_UNLOCK();
			ppc_intr_disable();
			continue;
		}
		if((ci->ci_ipending & SINT_NET) & ~pcpl) {
			ci->ci_ipending &= ~SINT_NET;
			ci->ci_cpl = SINT_NET|SINT_TTY;
			ppc_intr_enable(1);
			KERNEL_LOCK();
a1120 3
			KERNEL_UNLOCK();
			ppc_intr_disable();
			continue;
d1122 3
a1124 5
		if((ci->ci_ipending & SINT_TTY) & ~pcpl) {
			ci->ci_ipending &= ~SINT_TTY;
			ci->ci_cpl = SINT_TTY;
			ppc_intr_enable(1);
			KERNEL_LOCK();
a1125 3
			KERNEL_UNLOCK();
			ppc_intr_disable();
			continue;
a1126 2
	} while ((ci->ci_ipending & SINT_ALLMASK) & ~pcpl);
	ci->ci_cpl = pcpl;	/* Don't use splx... we are here already! */
d1128 2
a1129 1
	ci->ci_iactive = 0;
d1131 2
@


1.31
log
@if_downall() cannot be done MI in sys_reboot() because vfs_shutdown()
might need network (ie. nfs).  Move the call to the MD boot() routines.
This cause for boot hangs diagnosed by kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.30 2011/06/05 19:41:08 deraadt Exp $	*/
d891 1
a891 1
	oldonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d896 1
a896 1
	if ((psp->ps_flags & SAS_ALTSTACK)
d899 3
a901 3
		fp = (struct sigframe *)(psp->ps_sigstk.ss_sp
					 + psp->ps_sigstk.ss_size);
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
d955 1
a955 1
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
d957 1
a957 1
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.30
log
@Move the bufcachepercent setting code to MI locations -- set it to 42%
for now; that is unlikely to hit some of the remaining starvation bugs.
Repair the bufpages calculation too; i386 was doing it ahead of time
(incorrectly) and then re-calculating it.
ok thib
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.29 2011/04/18 21:44:55 guenther Exp $	*/
d51 1
d1066 1
@


1.29
log
@Revert the sigacts diff: NFS can apparently retain pointers to processes
until they're zombies and then send them signals (for intr mounts).  Until
that is untangled, the sigacts change is unsafe.  sthen@@ was the victim
for this one
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.27 2011/01/08 18:10:22 deraadt Exp $	*/
a72 14

/*
 * Declare these as initialized data so we can patch them.
 */
#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif

#ifdef BUFPAGES
int bufpages = BUFPAGES;
#else
int bufpages = 0;
#endif
int bufcachepercent = BUFCACHEPERCENT;
@


1.28
log
@Correct the sharing of the signal handling state: stuff that should
be shared (p_sigignore, p_sigcatch, P_NOCLDSTOP, P_NOCLDWAIT) moves
to struct sigacts, wihle stuff that should be per rthread (ps_oldmask,
SAS_OLDMASK, ps_sigstk) moves to struct proc.  Treat the coredumping
state bits (ps_sig, ps_code, ps_type, ps_sigval) as per-rthread
until our locking around coredumping is better.

Oh, and remove the old SunOS-compat ps_usertramp member.

"I like the sound of this" tedu@@
@
text
@d904 1
a904 1
	oldonstack = p->p_sigstk.ss_flags & SS_ONSTACK;
d909 1
a909 1
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0
d912 3
a914 3
		fp = (struct sigframe *)(p->p_sigstk.ss_sp
					 + p->p_sigstk.ss_size);
		p->p_sigstk.ss_flags |= SS_ONSTACK;
d968 1
a968 1
		p->p_sigstk.ss_flags |= SS_ONSTACK;
d970 1
a970 1
		p->p_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.27
log
@rename imask[] to cpu_imask[] to because imask is too loud as far as
kernel namespace
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.26 2010/06/27 13:28:46 miod Exp $	*/
d904 1
a904 1
	oldonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d909 1
a909 1
	if ((psp->ps_flags & SAS_ALTSTACK)
d912 3
a914 3
		fp = (struct sigframe *)(psp->ps_sigstk.ss_sp
					 + psp->ps_sigstk.ss_size);
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
d968 1
a968 1
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
d970 1
a970 1
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.26
log
@If you include <uvm/uvm.h>, you do not need to include any other <uvm/uvm_foo.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.25 2010/06/27 03:03:48 thib Exp $	*/
d485 1
a485 1
int imask[IPL_NUM];
@


1.25
log
@uvm constraints. Add two mandatory MD symbols, uvm_md_constraints
which contains the constraints for DMA/memory allocation for each
architecture, and dma_constraints which contains the range of addresses
that are dma accessable by the system.

This is based on ariane@@'s physcontig diff, with lots of bugfixes and
additions the following additions by my self:

Introduce a new function pool_set_constraints() which sets the address
range for which we allocate pages for the pool from, this is now used
for the mbuf/mbuf cluster pools to keep them dma accessible.

The !direct archs no longer stuff pages into the kernel object in
uvm_km_getpage_pla but rather do a pmap_extract() in uvm_km_putpages.

Tested heavily by my self on i386, amd64 and sparc64. Some tests on
alpha and SGI.

"commit it" beck, art, oga, deraadt
"i like the diff" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.23 2009/10/01 20:19:19 kettenis Exp $	*/
a51 1
#include <uvm/uvm_extern.h>
@


1.24
log
@Declare safepri at the MD level on each platform, so that the kern_synch.c
does not have to deal with it as a common.  Some platforms may be missed
by this commit... if you spot one, fix it the same way.
ok miod
@
text
@d51 1
d88 3
@


1.23
log
@Generic soft interrupts for macppc.  Tested by mk@@, deraadt@@
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.22 2009/08/30 14:57:41 kettenis Exp $	*/
d92 6
@


1.22
log
@Link in the flattened device tree for the Thecus N1200 and register it with
the ftd code upon boot if the firmware didn't provide a device tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.21 2009/08/26 19:09:44 kettenis Exp $	*/
a59 2
#include <net/netisr.h>

a477 15
int netisr;

/*
 * Soft networking interrupts.
 */
void
softnet(int isr)
{
#define DONETISR(flag, func) \
	if (isr & (1 << flag))\
		func();

#include <net/netisr_dispatch.h>
}

d1124 1
a1124 1
			softclock();
a1129 3
			extern int netisr;
			int pisr;
		       
d1132 5
a1136 8
			while ((pisr = netisr) != 0) {
				atomic_clearbits_int(&netisr, pisr);
				ppc_intr_enable(1);
				KERNEL_LOCK();
				softnet(pisr);
				KERNEL_UNLOCK();
				ppc_intr_disable();
			}
a1138 1
#if 0
d1144 1
a1144 1
			softtty();
d1149 1
a1149 2
#endif
	} while ((ci->ci_ipending & SINT_MASK) & ~pcpl);
@


1.21
log
@Build fake bootinfo structure based on the device tree.
Inspired by a diff from dms@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.20 2009/08/26 17:38:06 kettenis Exp $	*/
d196 3
@


1.20
log
@Override comconsfreq and comconsaddr with values from the FTD if provided.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.19 2009/08/25 21:18:20 kettenis Exp $	*/
d186 1
a186 18
	if (fwfdtsave) {
		/*
		 * We were loaded by a newer U-boot or RouterBOOT.
		 * Both provide a flattened device tree.
		 *
		 * XXX We only support RouterBOOT and fake a bootinfo
		 * structure.
		 */
		bootinfo.bi_memstart = 0x00000000;
		bootinfo.bi_memsize = 0x07ffffff;
		bootinfo.bi_immr_base = 0xe0000000;
		bootinfo.bi_enetaddr[0] = 0x00;
		bootinfo.bi_enetaddr[1] = 0x0c;
		bootinfo.bi_enetaddr[2] = 0x42;
		bootinfo.bi_enetaddr[3] = 0x20;
		bootinfo.bi_enetaddr[4] = 0xc6;
		bootinfo.bi_enetaddr[5] = 0xe5;
	} else {
d209 28
@


1.19
log
@Initialize flattened device tree support if a tree was passed by the firmware.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.18 2009/08/11 19:17:17 miod Exp $	*/
d178 1
d425 18
@


1.18
log
@Do not bother initializing bufpages in the md code if the computation is
exactly the same the mi could will use if bufinit() is invoked with
bufpages == 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.17 2009/08/11 18:46:32 miod Exp $	*/
d55 1
d116 1
d184 42
a225 1
	memcpy(&bootinfo, *fwargsave, sizeof bootinfo);
@


1.17
log
@With the SysV memory allocation changes, allocsys() doesn't do anything
anymore. Get rid of it completely.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.16 2009/08/09 10:40:17 blambert Exp $	*/
a749 7

	/*
	 * Determine how many buffers to allocate.
	 * We allocate bufcachepercent% of memory for buffer space.
	 */
	if (bufpages == 0)
		bufpages = physmem * bufcachepercent / 100;
@


1.16
log
@Rototill system V message queues.

No longer allocate a static amount of memory for messages in MD
boot path; message queues, message metadata, and message data now
all use dynamic memory, which means that runtime sysctls should now
be trivial to implement.

Since I'm going to be around all week to fix any breakage, this should
probably just go in now.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.15 2009/08/02 16:28:39 beck Exp $	*/
a135 1
caddr_t allocsys(caddr_t);
a741 2
	int sz;
	caddr_t v;
a743 1
	v = (caddr_t)proc0paddr + USPACE;
a751 10
	 * Find out how much space we need, allocate it,
	 * and then give everything true virtual addresses.
	 */
	sz = (int)allocsys((caddr_t)0);
	if ((v = (caddr_t)uvm_km_zalloc(kernel_map, round_page(sz))) == 0)
		panic("startup: no room for tables");
	if (allocsys(v) - v != sz)
		panic("startup: table size inconsistency");

	/*
a781 12
}

/*
 * Allocate space for system data structures.
 */
caddr_t
allocsys(caddr_t v)
{
#define	valloc(name, type, num) \
	v = (caddr_t)(((name) = (type *)v) + (num))

	return v;
@


1.15
log
@
Dynamic buffer cache support - a re-commit of what was backed out
after c2k9

allows buffer cache to be extended and grow/shrink dynamically

tested by many, ok oga@@, "why not just commit it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.14 2009/07/26 18:48:55 miod Exp $	*/
a41 3
#ifdef SYSVMSG
#include <sys/msg.h>
#endif
a805 7

#ifdef	SYSVMSG
	valloc(msgpool, char, msginfo.msgmax);
	valloc(msgmaps, struct msgmap, msginfo.msgseg);
	valloc(msghdrs, struct msg, msginfo.msgtql);
	valloc(msqids, struct msqid_ds, msginfo.msgmni);
#endif
@


1.14
log
@Make sure all platforms understand the flags argument of bus_space_map() and
bus_space_alloc() as a bitmask of flags, and not a boolean controlling
cacheability; and make sure the three MI BUS_SPACE_MAP_xxx values documented
in the manual page are defined on all platforms as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.13 2009/06/15 17:01:26 beck Exp $	*/
a773 6

	/* Restrict to at most 25% filled kvm */
	if (bufpages >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / PAGE_SIZE / 4) 
		bufpages = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    PAGE_SIZE / 4;
@


1.13
log
@Back out all the buffer cache changes I committed during c2k9. This reverts three
commits:

1) The sysctl allowing bufcachepercent to be changed at boot time.
2) The change moving the buffer cache hash chains to a red-black tree
3) The dynamic buffer cache (Which depended on the earlier too).

ok on the backout from marco and todd
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.12 2009/06/09 01:12:38 deraadt Exp $	*/
d432 1
a432 1
    int cacheable, bus_space_handle_t *bshp)
d438 1
a438 1
		return 1;
d445 1
a445 1
	if ((error = bus_mem_add_mapping(bpa, size, cacheable, bshp))) {
d501 1
a501 1
bus_mem_add_mapping(bus_addr_t bpa, bus_size_t size, int cacheable,
d542 3
a544 3
		pmap_kenter_cache(vaddr, spa,
			VM_PROT_READ | VM_PROT_WRITE,
			cacheable ? PMAP_CACHE_WT : PMAP_CACHE_CI);
d553 1
a553 1
    bus_size_t size, bus_size_t alignment, bus_size_t boundary, int cacheable,
@


1.12
log
@backout interrupt diff until it the next round of fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.9 2009/02/17 20:35:47 kettenis Exp $	*/
d774 6
@


1.11
log
@add kern.bufcachepercent sysctl to allow adjusting the buffer cache
size on a running system.
ok art@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.10 2009/06/02 21:38:10 drahn Exp $	*/
d1085 2
d1090 56
@


1.10
log
@Reintroduce the macppc interrupt subsystem rewrite. Several bugs have
been found and corrected.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.6 2008/10/12 11:50:19 kettenis Exp $	*/
a773 6

	/* Restrict to at most 25% filled kvm */
	if (bufpages >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / PAGE_SIZE / 4) 
		bufpages = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    PAGE_SIZE / 4;
@


1.9
log
@Remove debug printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.8 2009/01/28 20:15:14 kettenis Exp $	*/
a1090 2
extern void ipic_do_pending_int(void);

a1093 56
	struct cpu_info *ci = curcpu();
	int pcpl, s;

	if (ci->ci_iactive)
		return;

	ci->ci_iactive = 1;
	s = ppc_intr_disable();
	pcpl = ci->ci_cpl;

	ipic_do_pending_int();

	do {
		if((ci->ci_ipending & SINT_CLOCK) & ~pcpl) {
			ci->ci_ipending &= ~SINT_CLOCK;
			ci->ci_cpl = SINT_CLOCK|SINT_NET|SINT_TTY;
			ppc_intr_enable(1);
			KERNEL_LOCK();
			softclock();
			KERNEL_UNLOCK();
			ppc_intr_disable();
			continue;
		}
		if((ci->ci_ipending & SINT_NET) & ~pcpl) {
			extern int netisr;
			int pisr;
		       
			ci->ci_ipending &= ~SINT_NET;
			ci->ci_cpl = SINT_NET|SINT_TTY;
			while ((pisr = netisr) != 0) {
				atomic_clearbits_int(&netisr, pisr);
				ppc_intr_enable(1);
				KERNEL_LOCK();
				softnet(pisr);
				KERNEL_UNLOCK();
				ppc_intr_disable();
			}
			continue;
		}
#if 0
		if((ci->ci_ipending & SINT_TTY) & ~pcpl) {
			ci->ci_ipending &= ~SINT_TTY;
			ci->ci_cpl = SINT_TTY;
			ppc_intr_enable(1);
			KERNEL_LOCK();
			softtty();
			KERNEL_UNLOCK();
			ppc_intr_disable();
			continue;
		}
#endif
	} while ((ci->ci_ipending & SINT_MASK) & ~pcpl);
	ci->ci_cpl = pcpl;	/* Don't use splx... we are here already! */

	ci->ci_iactive = 0;
	ppc_intr_enable(s);
@


1.8
log
@Make bus_mem_add_mapping() return ENOMEM if we fail to allocate kva instead
of panicing.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.7 2008/12/04 16:02:20 maja Exp $	*/
a398 5

	printf("%02x:%02x:%02x:%02x:%02x:%02x\n", bootinfo.bi_enetaddr[0],
	    bootinfo.bi_enetaddr[1], bootinfo.bi_enetaddr[2],
	    bootinfo.bi_enetaddr[3],  bootinfo.bi_enetaddr[4],
	    bootinfo.bi_enetaddr[5]);
@


1.7
log
@Revert ppc intr stuff. Make socppc compile again. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.6 2008/10/12 11:50:19 kettenis Exp $	*/
d539 1
a539 2
			panic("bus_mem_add_mapping: kvm alloc of 0x%x failed",
			    len);
@


1.6
log
@Adjust for redesigned powerpc interrupt architecture.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.5 2008/05/24 09:49:55 kettenis Exp $	*/
d1097 2
d1102 56
@


1.5
log
@Use MAC address passed by the firmware.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.4 2008/05/14 22:23:48 kettenis Exp $	*/
a1096 2
extern void ipic_do_pending_int(void);

a1099 56
	struct cpu_info *ci = curcpu();
	int pcpl, s;

	if (ci->ci_iactive)
		return;

	ci->ci_iactive = 1;
	s = ppc_intr_disable();
	pcpl = ci->ci_cpl;

	ipic_do_pending_int();

	do {
		if((ci->ci_ipending & SINT_CLOCK) & ~pcpl) {
			ci->ci_ipending &= ~SINT_CLOCK;
			ci->ci_cpl = SINT_CLOCK|SINT_NET|SINT_TTY;
			ppc_intr_enable(1);
			KERNEL_LOCK();
			softclock();
			KERNEL_UNLOCK();
			ppc_intr_disable();
			continue;
		}
		if((ci->ci_ipending & SINT_NET) & ~pcpl) {
			extern int netisr;
			int pisr;
		       
			ci->ci_ipending &= ~SINT_NET;
			ci->ci_cpl = SINT_NET|SINT_TTY;
			while ((pisr = netisr) != 0) {
				atomic_clearbits_int(&netisr, pisr);
				ppc_intr_enable(1);
				KERNEL_LOCK();
				softnet(pisr);
				KERNEL_UNLOCK();
				ppc_intr_disable();
			}
			continue;
		}
#if 0
		if((ci->ci_ipending & SINT_TTY) & ~pcpl) {
			ci->ci_ipending &= ~SINT_TTY;
			ci->ci_cpl = SINT_TTY;
			ppc_intr_enable(1);
			KERNEL_LOCK();
			softtty();
			KERNEL_UNLOCK();
			ppc_intr_disable();
			continue;
		}
#endif
	} while ((ci->ci_ipending & SINT_MASK) & ~pcpl);
	ci->ci_cpl = pcpl;	/* Don't use splx... we are here already! */

	ci->ci_iactive = 0;
	ppc_intr_enable(s);
@


1.4
log
@Parse arguments passed by the bootloader and take appropriate action.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.3 2008/05/14 20:54:36 kettenis Exp $	*/
d111 5
a115 1
};
d142 2
d186 1
a198 5
	 * Adjust base of internal memory mapped registers.
	 */
	mainbus_bus_space.bus_base = (*fwargsave)->bi_immr_base;

	/*
d368 5
d378 1
a378 1
	 * Replace with real console.
d399 5
d1192 2
a1193 2
	uboot_mem[0].start = (*fwargsave)->bi_memstart;
	uboot_mem[0].size = (*fwargsave)->bi_memsize;
d1209 7
@


1.3
log
@Get memory size and base address of internal memory mapped registers from
firmware instead of hardcoding them.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.2 2008/05/14 19:29:46 kettenis Exp $	*/
d68 5
d99 3
d178 3
d334 32
d379 13
@


1.2
log
@Make all 128MB of memory available (except for the first three pages used
for the exception vectors).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.1 2008/05/10 12:02:21 kettenis Exp $	*/
d94 13
d180 4
a183 12
#if 0
	{
		prom_printf("AER:   0x%08x\n", *(uint32_t *)0xe000080c);
		prom_printf("AIDR:  0x%08x\n", *(uint32_t *)0xe0000810);
		prom_printf("AEATR: 0x%08x\n", *(uint32_t *)0xe0000818);
		prom_printf("AEADR: 0x%08x\n", *(uint32_t *)0xe000081c);
		*(uint32_t *)0xe0000810 = 0x00000001;
		*(uint32_t *)0xe0000814 = 0x00000001;
		*(uint32_t *)0xe0000818 = 0x00000000;
		*(uint32_t *)0xe000081c = 0x00000000;
	}
#endif
a309 5
#if 0
	ppc_mtdbat1l(BATL(0xe0000000, BAT_M | BAT_I | BAT_G));
	ppc_mtdbat1u(0xe000000e);
#endif

d1119 1
a1119 9
struct mem_region uboot_mem[2] = {
	{ 0x00000000, 0x08000000 },
	{ 0, 0 }
};

struct mem_region uboot_avail[4] = {
	{ 0x00003000, 0x07ffd000 },
	{ 0, 0 }
};
d1124 10
@


1.1
log
@OpenBSD/socppc, a port to the Thecus N1200, and potentially other Freescale
PowerPC SoC platforms that use u-boot as a bootloader.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1120 1
a1120 1
	{ 0x00000000, 0x04000000 },
d1124 2
a1125 2
struct mem_region uboot_avail[2] = {
	{ 0x00800000, 0x04000000 },
@

