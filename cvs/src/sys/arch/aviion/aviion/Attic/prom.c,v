head	1.9;
access;
symbols
	OPENBSD_5_8:1.8.0.8
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.4
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.4.0.10
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.8
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.4
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.2
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.8
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.10
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.6
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.4
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.2
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.2.0.6
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.4
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.2
	OPENBSD_4_0_BASE:1.2
	AV400_20060509:1.1.1.1
	miod:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.12.01.07.50.03;	author deraadt;	state dead;
branches;
next	1.8;
commitid	Rh8AZFtVMVCiwPts;

1.8
date	2014.03.29.18.09.29;	author guenther;	state Exp;
branches;
next	1.7;

1.7
date	2013.10.07.19.10.40;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2013.09.28.19.56.47;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2013.01.05.11.20.55;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2010.04.24.18.46.51;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2007.12.20.21.19.32;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.20.11.57.02;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.08.16.34.56;	author miod;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.05.08.16.34.56;	author miod;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Send Aviion to same place as Nova II
discussed with jsg
@
text
@/*	$OpenBSD: prom.c,v 1.8 2014/03/29 18:09:29 guenther Exp $	*/

/*
 * Copyright (c) 2006, Miodrag Vallat.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>

#include <machine/asm_macro.h>
#include <machine/prom.h>

register_t prom_vbr;					/* set in locore.S */

/*
 * No locking is necessary, since we will only use the SCM routines
 * during startup, before any secondary CPU is started.
 */

#define	SCM_DECL \
	register_t psr; \
	register_t ossr0, ossr1, ossr2, ossr3

#define	SCM_CALL(x) \
	__asm__ volatile ("or %r9, %r0, " __STRING(x));			\
	__asm__ volatile ("tb0 0, %%r0, 496" :::			\
	    "r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8",		\
	    "r9", "r10", "r11", "r12", "r13")

#define	SCM_VBR() \
	__asm__ volatile ("stcr %0, %%cr7" : : "r" (prom_vbr))

#define	SCM_CONTEXT() \
	__asm__ volatile ("ldcr %0, %%cr17" : "=r" (ossr0)); \
	__asm__ volatile ("ldcr %0, %%cr18" : "=r" (ossr1)); \
	__asm__ volatile ("ldcr %0, %%cr19" : "=r" (ossr2)); \
	__asm__ volatile ("ldcr %0, %%cr20" : "=r" (ossr3))

#define	OS_VBR() \
	__asm__ volatile ("stcr %0, %%cr7" : : "r" (kernel_vbr))

#define	OS_CONTEXT() \
	__asm__ volatile ("stcr %0, %%cr17" : : "r" (ossr0)); \
	__asm__ volatile ("stcr %0, %%cr18" : : "r" (ossr1)); \
	__asm__ volatile ("stcr %0, %%cr19" : : "r" (ossr2)); \
	__asm__ volatile ("stcr %0, %%cr20" : : "r" (ossr3))

/* ==== */

int
scm_cpuconfig(struct scm_cpuconfig *scc)
{
	SCM_DECL;
	int ret;

	psr = get_psr();
	set_psr(psr | PSR_IND);
	SCM_CONTEXT();
	SCM_VBR();
	__asm__ volatile ("or %%r2, %%r0, %0" : : "r" (scc));
	SCM_CALL(SCM_CPUCONFIG);
	__asm__ volatile ("or %0, %%r0, %%r2" : "=r" (ret));
	OS_CONTEXT();
	OS_VBR();
	set_psr(psr);

	return (ret);
}

u_int
scm_cpuid()
{
	SCM_DECL;
	u_int ret;

	psr = get_psr();
	set_psr(psr | PSR_IND);
	SCM_CONTEXT();
	SCM_VBR();
	SCM_CALL(SCM_CPUID);
	__asm__ volatile ("or %0, %%r0, %%r2" : "=r" (ret));
	OS_CONTEXT();
	OS_VBR();
	set_psr(psr);

	return (ret);
}

int
scm_getc(void)
{
	SCM_DECL;
	u_int ret;

	psr = get_psr();
	set_psr(psr | PSR_IND);
	SCM_CONTEXT();
	SCM_VBR();
	SCM_CALL(SCM_CHAR);
	__asm__ volatile ("or %0, %%r0, %%r2" : "=r" (ret));
	OS_CONTEXT();
	OS_VBR();
	set_psr(psr);

	return (ret & 0xff);
}

void
scm_getenaddr(u_char *ea)
{
	SCM_DECL;
	char *addr;

	psr = get_psr();
	set_psr(psr | PSR_IND);
	SCM_CONTEXT();
	SCM_VBR();
	SCM_CALL(SCM_COMMID);
	__asm__ volatile ("or %0, %%r0, %%r2" : "=r" (addr));
	OS_CONTEXT();
	OS_VBR();
	set_psr(psr);

	bcopy(addr, ea, 6);
}

__dead void
scm_halt()
{
	SCM_DECL;

	psr = get_psr();
	set_psr(psr | PSR_IND);
	SCM_CONTEXT();
	SCM_VBR();
	SCM_CALL(SCM_HALT);
#if 0
	OS_CONTEXT();
	OS_VBR();
	set_psr(psr);
#endif
	for (;;) ;
}

u_int
scm_memsize(int which)
{
	SCM_DECL;
	u_int msize;

	psr = get_psr();
	set_psr(psr | PSR_IND);
	SCM_CONTEXT();
	SCM_VBR();
	__asm__ volatile ("or %%r2, %%r0, %0" : : "r" (which));
	SCM_CALL(SCM_MSIZE);
	__asm__ volatile ("or %0, %%r0, %%r2" : "=r" (msize));
	OS_CONTEXT();
	OS_VBR();
	set_psr(psr);

	return (msize);
}

/*
 * Does not accept parameters beyond a string because this would need extra
 * register constraints.
 */
void
scm_printf(const char *msg)
{
	SCM_DECL;

	psr = get_psr();
	set_psr(psr | PSR_IND);
	SCM_CONTEXT();
	SCM_VBR();
	__asm__ volatile ("or %%r2, %%r0, %0" : : "r" (msg));
	SCM_CALL(SCM_PTLINE);
	OS_CONTEXT();
	OS_VBR();
	set_psr(psr);
}

u_int
scm_promver()
{
	SCM_DECL;
	u_int ret;

	psr = get_psr();
	set_psr(psr | PSR_IND);
	SCM_CONTEXT();
	SCM_VBR();
	SCM_CALL(SCM_REVNUM);
	__asm__ volatile ("or %0, %%r0, %%r2" : "=r" (ret));
	OS_CONTEXT();
	OS_VBR();
	set_psr(psr);

	return (ret);
}

void
scm_putc(int c)
{
	SCM_DECL;

	psr = get_psr();
	set_psr(psr | PSR_IND);
	SCM_CONTEXT();
	SCM_VBR();
	__asm__ volatile ("or %%r2, %%r0, %0" : : "r" (c));
	SCM_CALL(SCM_OCHAR);
	OS_CONTEXT();
	OS_VBR();
	set_psr(psr);
}

void
scm_putcrlf()
{
	SCM_DECL;

	psr = get_psr();
	set_psr(psr | PSR_IND);
	SCM_CONTEXT();
	SCM_VBR();
	SCM_CALL(SCM_OCRLF);
	OS_CONTEXT();
	OS_VBR();
	set_psr(psr);
}

__dead void
scm_reboot(const char *cmdline)
{
	SCM_DECL;

	psr = get_psr();
	set_psr(psr | PSR_IND);
	SCM_CONTEXT();
	SCM_VBR();
	__asm__ volatile ("or %%r2, %%r0, %0" : : "r" (cmdline));
	SCM_CALL(SCM_REBOOT);
#if 0
	OS_CONTEXT();
	OS_VBR();
	set_psr(psr);
#endif
	for (;;) ;
}

u_int
scm_sysid()
{
	SCM_DECL;
	u_int ret;

	psr = get_psr();
	set_psr(psr | PSR_IND);
	SCM_CONTEXT();
	SCM_VBR();
	SCM_CALL(SCM_SYSID);
	__asm__ volatile ("or %0, %%r0, %%r2" : "=r" (ret));
	OS_CONTEXT();
	OS_VBR();
	set_psr(psr);

	return (ret);
}

#ifdef MULTIPROCESSOR
u_int
scm_jpstart(cpuid_t cpu, vaddr_t addr)
{
	SCM_DECL;
	u_int ret;

	psr = get_psr();
	set_psr(psr | PSR_IND);
	SCM_CONTEXT();
	SCM_VBR();
	__asm__ volatile ("or %%r2, %%r0, %0; or %%r3, %%r0, %1" : :
	    "r" (cpu), "r" (addr));
	SCM_CALL(SCM_JPSTART);
	__asm__ volatile ("or %0, %%r0, %%r2" : "=r" (ret));
	OS_CONTEXT();
	OS_VBR();
	set_psr(psr);

	return (ret);
}
#endif
@


1.8
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: prom.c,v 1.7 2013/10/07 19:10:40 miod Exp $	*/
@


1.7
log
@Put the kernel VBR page at the beginning of the kernel text, as done on
mvme88k, to be able to unmap the page at address zero in the kernel, and have
the vbr page read-only after being initialized.
@
text
@d1 1
a1 1
/*	$OpenBSD: prom.c,v 1.6 2013/09/28 19:56:47 miod Exp $	*/
d46 2
a47 2
	__asm__ __volatile__ ("or %r9, %r0, " __STRING(x));		\
	__asm__ __volatile__ ("tb0 0, %%r0, 496" :::			\
d52 1
a52 1
	__asm__ __volatile__ ("stcr %0, %%cr7" : : "r" (prom_vbr))
d55 4
a58 4
	__asm__ __volatile__ ("ldcr %0, %%cr17" : "=r" (ossr0)); \
	__asm__ __volatile__ ("ldcr %0, %%cr18" : "=r" (ossr1)); \
	__asm__ __volatile__ ("ldcr %0, %%cr19" : "=r" (ossr2)); \
	__asm__ __volatile__ ("ldcr %0, %%cr20" : "=r" (ossr3))
d61 1
a61 1
	__asm__ __volatile__ ("stcr %0, %%cr7" : : "r" (kernel_vbr))
d64 4
a67 4
	__asm__ __volatile__ ("stcr %0, %%cr17" : : "r" (ossr0)); \
	__asm__ __volatile__ ("stcr %0, %%cr18" : : "r" (ossr1)); \
	__asm__ __volatile__ ("stcr %0, %%cr19" : : "r" (ossr2)); \
	__asm__ __volatile__ ("stcr %0, %%cr20" : : "r" (ossr3))
d81 1
a81 1
	__asm__ __volatile__ ("or %%r2, %%r0, %0" : : "r" (scc));
d83 1
a83 1
	__asm__ __volatile__ ("or %0, %%r0, %%r2" : "=r" (ret));
d102 1
a102 1
	__asm__ __volatile__ ("or %0, %%r0, %%r2" : "=r" (ret));
d121 1
a121 1
	__asm__ __volatile__ ("or %0, %%r0, %%r2" : "=r" (ret));
d140 1
a140 1
	__asm__ __volatile__ ("or %0, %%r0, %%r2" : "=r" (addr));
d176 1
a176 1
	__asm__ __volatile__ ("or %%r2, %%r0, %0" : : "r" (which));
d178 1
a178 1
	__asm__ __volatile__ ("or %0, %%r0, %%r2" : "=r" (msize));
d199 1
a199 1
	__asm__ __volatile__ ("or %%r2, %%r0, %0" : : "r" (msg));
d217 1
a217 1
	__asm__ __volatile__ ("or %0, %%r0, %%r2" : "=r" (ret));
d234 1
a234 1
	__asm__ __volatile__ ("or %%r2, %%r0, %0" : : "r" (c));
d265 1
a265 1
	__asm__ __volatile__ ("or %%r2, %%r0, %0" : : "r" (cmdline));
d286 1
a286 1
	__asm__ __volatile__ ("or %0, %%r0, %%r2" : "=r" (ret));
d305 1
a305 1
	__asm__ __volatile__ ("or %%r2, %%r0, %0; or %%r3, %%r0, %1" : :
d308 1
a308 1
	__asm__ __volatile__ ("or %0, %%r0, %%r2" : "=r" (ret));
@


1.6
log
@Make sure the stack is 1:1 mapped before attempting to give control back
to the PROM at halt/reboot time; this lets systems reboot again.
@
text
@d1 1
a1 1
/*	$OpenBSD: prom.c,v 1.5 2013/01/05 11:20:55 miod Exp $	*/
d61 1
a61 1
	__asm__ __volatile__ ("stcr %r0, %cr7")
@


1.5
log
@Switch m88k ports to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: prom.c,v 1.4 2010/04/24 18:46:51 miod Exp $	*/
d158 1
d162 1
d267 1
d271 1
@


1.4
log
@SMP support for models 4600 and 530, adapted from the MVME188 code. Models
4000 and 4300 will need more work, because they don't have as many distinct
software interrupt sources as required by this implementation, so a
different IPI scheme will be necessary.

Tested on dual-processor 4625 (AV530 family) and single processor 4300
(AV400 family).
@
text
@d1 1
a1 1
/*	$OpenBSD: prom.c,v 1.3 2007/12/20 21:19:32 miod Exp $	*/
d46 2
a47 2
	__asm__ __volatile__ ("or r9, r0, " __STRING(x));		\
	__asm__ __volatile__ ("tb0 0, r0, 496" :::			\
d52 1
a52 1
	__asm__ __volatile__ ("stcr %0, cr7" : : "r" (prom_vbr))
d55 4
a58 4
	__asm__ __volatile__ ("ldcr %0, cr17" : "=r" (ossr0)); \
	__asm__ __volatile__ ("ldcr %0, cr18" : "=r" (ossr1)); \
	__asm__ __volatile__ ("ldcr %0, cr19" : "=r" (ossr2)); \
	__asm__ __volatile__ ("ldcr %0, cr20" : "=r" (ossr3))
d61 1
a61 1
	__asm__ __volatile__ ("stcr r0, cr7")
d64 4
a67 4
	__asm__ __volatile__ ("stcr %0, cr17" : : "r" (ossr0)); \
	__asm__ __volatile__ ("stcr %0, cr18" : : "r" (ossr1)); \
	__asm__ __volatile__ ("stcr %0, cr19" : : "r" (ossr2)); \
	__asm__ __volatile__ ("stcr %0, cr20" : : "r" (ossr3))
d81 1
a81 1
	__asm__ __volatile__ ("or r2, r0, %0" : : "r" (scc));
d83 1
a83 1
	__asm__ __volatile__ ("or %0, r0, r2" : "=r" (ret));
d102 1
a102 1
	__asm__ __volatile__ ("or %0, r0, r2" : "=r" (ret));
d121 1
a121 1
	__asm__ __volatile__ ("or %0, r0, r2" : "=r" (ret));
d140 1
a140 1
	__asm__ __volatile__ ("or %0, r0, r2" : "=r" (addr));
d174 1
a174 1
	__asm__ __volatile__ ("or r2, r0, %0" : : "r" (which));
d176 1
a176 1
	__asm__ __volatile__ ("or %0, r0, r2" : "=r" (msize));
d197 1
a197 1
	__asm__ __volatile__ ("or r2, r0, %0" : : "r" (msg));
d215 1
a215 1
	__asm__ __volatile__ ("or %0, r0, r2" : "=r" (ret));
d232 1
a232 1
	__asm__ __volatile__ ("or r2, r0, %0" : : "r" (c));
d263 1
a263 1
	__asm__ __volatile__ ("or r2, r0, %0" : : "r" (cmdline));
d282 1
a282 1
	__asm__ __volatile__ ("or %0, r0, r2" : "=r" (ret));
d301 1
a301 1
	__asm__ __volatile__ ("or r2, r0, %0; or r3, r0, %1" : :
d304 1
a304 1
	__asm__ __volatile__ ("or %0, r0, r2" : "=r" (ret));
@


1.3
log
@Get rid of disable_interrupt() and have caller use get_psr() and set_psr();
this allows us to get rid of the dependency of asm_macro.h on asm.h, which
was really only there to bring in psl.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: prom.c,v 1.2 2006/05/20 11:57:02 miod Exp $	*/
d289 23
@


1.2
log
@Save the PROM VBR on startup, rather than assuming the PROM (and thus its
VBR) will always reside at the same address.
Also, when querying the PROM for the memory size, ask it for the ``user''
size - i.e. with the PROM data area taken out.
@
text
@d1 1
a1 1
/*	$OpenBSD: prom.c,v 1.1.1.1 2006/05/08 16:34:56 miod Exp $	*/
d77 2
a78 1
	disable_interrupt(psr);
d97 2
a98 1
	disable_interrupt(psr);
d116 2
a117 1
	disable_interrupt(psr);
d135 2
a136 1
	disable_interrupt(psr);
d153 2
a154 1
	disable_interrupt(psr);
d170 2
a171 1
	disable_interrupt(psr);
d193 2
a194 1
	disable_interrupt(psr);
d210 2
a211 1
	disable_interrupt(psr);
d228 2
a229 1
	disable_interrupt(psr);
d244 2
a245 1
	disable_interrupt(psr);
d259 2
a260 1
	disable_interrupt(psr);
d277 2
a278 1
	disable_interrupt(psr);
@


1.1
log
@Enter OpenBSD/aviion, a port to the m88k-based Data General AViiON workstations. Currently restricted to diskless serial console, tested on AV410 only; many thanks to Chris Tribo for documentation and testing.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a31 1
#include <machine/av400.h>		/* PROM_VBR */
d34 2
d52 1
a52 1
	__asm__ __volatile__ ("stcr %0, cr7" : : "r" (PROM_VBR))
d160 1
a160 1
scm_memsize()
d168 1
a168 1
	__asm__ __volatile__ ("or r2, r0, r0");
d176 19
@


1.1.1.1
log
@Oops, correct import this time.
@
text
@@
